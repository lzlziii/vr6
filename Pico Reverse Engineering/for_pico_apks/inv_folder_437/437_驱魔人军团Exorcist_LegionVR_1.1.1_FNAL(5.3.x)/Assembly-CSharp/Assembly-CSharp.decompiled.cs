using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters.Binary;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Xml;
using AOT;
using BoundarySystem_Ext;
using DigitalOpus.MB.Core;
using Facepunch.Steamworks;
using Jacovone;
using LiquidVolumeFX;
using LitJson;
using NewtonVR;
using ONSPPropagationInterface;
using ONSPPropagationInterface.Unity_Native;
using Pvr_UnitySDKAPI;
using Pvr_UnitySDKAPI.Achievement;
using RogoDigital.Lipsync;
using RootMotion.FinalIK;
using SteamNative;
using Subtitles;
using TMPro;
using UnityEngine;
using UnityEngine.AI;
using UnityEngine.Audio;
using UnityEngine.EventSystems;
using UnityEngine.Events;
using UnityEngine.Experimental.Rendering;
using UnityEngine.Playables;
using UnityEngine.Rendering;
using UnityEngine.SceneManagement;
using UnityEngine.Serialization;
using UnityEngine.Timeline;
using UnityEngine.UI;
using UnityEngine.Video;
using UnityEngine.XR;
using UnityStandardAssets.CrossPlatformInput;
using UnityStandardAssets.CrossPlatformInput.PlatformSpecific;
using UnityStandardAssets.ImageEffects;
using UnityStandardAssets.Utility;
using VLB;

[assembly: CompilationRelaxations(8)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: AssemblyVersion("0.0.0.0")]
public enum AchievementID
{
	COFFEE_BREAK,
	FEED_ME,
	MANS_BEST_FRIEND,
	PUKE,
	TRAINING_WHEELS,
	MUSIC_LOVER,
	FIRST_RITES,
	CHAPTER_ONE,
	ROCKY,
	BULL_IN_A_CHINA_SHOP,
	SCHOLAR,
	IDLE_HANDS,
	CHAPTER_TWO,
	SNAKE,
	HIGH_FIVE,
	BAPTISM,
	MINIATURE_COLLECTOR,
	MIKE_WHO,
	COWARD,
	SKIN_DEEP,
	CHAPTER_THREE,
	SAMARITAN,
	BETTER_THAN_STAIRS,
	OLD_FRIEND,
	IMPROVISING,
	CHAPTER_FOUR,
	LOST_LAMB,
	AFRAID_OF_THE_DARK,
	NO_RESPECT,
	CHAPTER_FIVE,
	THE_TOMB
}
public class AchievementManager : MonoBehaviour
{
	public enum AchievementType
	{
		SIMPLE,
		COUNT,
		BITFIELD
	}

	[Serializable]
	public struct AchievementPlatform
	{
		public NVRSDKIntegrations achievementPlatformType;

		public string achievementAPIKey;

		public bool achieved;
	}

	[Serializable]
	public struct AchievementStruct
	{
		public AchievementID achievementId;

		public AchievementType achievementType;

		public AchievementPlatform[] achievementPlatformDetails;
	}

	public AchievementStruct[] achievements;

	private void Start()
	{
	}

	private void Update()
	{
	}

	public void UnlockAchievement(AchievementID achievementId)
	{
		getAchievementAPIKeyById(achievementId);
		_ = SaveManager.instance.offlineMode;
	}

	private string getAchievementAPIKeyById(AchievementID achievementId)
	{
		for (int i = 0; i < achievements.Length; i++)
		{
			AchievementStruct achievementStruct = achievements[i];
			if (achievementStruct.achievementId == achievementId)
			{
				for (int j = 0; j < achievementStruct.achievementPlatformDetails.Length; j++)
				{
					_ = ref achievementStruct.achievementPlatformDetails[j];
				}
			}
		}
		return null;
	}
}
public class AnimationSfx_C5Prisoner : MonoBehaviour
{
	[SerializeField]
	private AudioScript audioScript;

	[SerializeField]
	private AudioClip doorBanging;

	private void Start()
	{
	}

	public void PlayDoorBang(float vol)
	{
		audioScript.PlayOne(doorBanging, vol);
	}
}
public class AudioCdPlayer : MonoBehaviour
{
	[SerializeField]
	private GameObject cdAbyziou2017;

	[SerializeField]
	private AudioScript speaker;

	[SerializeField]
	private Transform cdSnapPoint;

	[SerializeField]
	private GameObject diskUi;

	[SerializeField]
	private GameObject insertUi;

	[Space]
	[SerializeField]
	private AudioClip audioAbyzou2017;

	[SerializeField]
	private AudioClip switchSfx;

	[SerializeField]
	private AudioClip finishedSfx;

	[Space]
	private bool isPlayingThis;

	private bool interacting;

	private Coroutine playCoroutine;

	private bool cdMounted;

	private void Start()
	{
		if (diskUi.activeInHierarchy)
		{
			diskUi.SetActive(value: false);
		}
	}

	public void ReelInteraction()
	{
		if (cdMounted && !interacting)
		{
			if (!speaker.m_AudioSource.isPlaying)
			{
				playCoroutine = StartCoroutine(PlayTape());
			}
			else if (isPlayingThis && speaker.m_AudioSource.clip != finishedSfx)
			{
				StopCoroutine(playCoroutine);
				StartCoroutine(StopTape());
			}
		}
	}

	private IEnumerator StopTape()
	{
		interacting = true;
		isPlayingThis = false;
		speaker.StopLoop();
		speaker.Play(finishedSfx);
		yield return Yield.WaitSeconds(finishedSfx.length);
	}

	public void OnTriggerEnter(Collider other)
	{
		if (other.gameObject == cdAbyziou2017 && !cdMounted)
		{
			StartCoroutine(MoveCD());
		}
	}

	private IEnumerator MoveCD()
	{
		LeanTween.move(cdAbyziou2017, cdSnapPoint.position, 0.5f);
		LeanTween.rotate(cdAbyziou2017, cdSnapPoint.eulerAngles, 0.5f);
		cdAbyziou2017.GetComponent<NVRInteractableItem>().CanAttach = false;
		cdAbyziou2017.GetComponent<Rigidbody>().isKinematic = true;
		yield return Yield.WaitSeconds(0.5f);
		diskUi.SetActive(value: true);
		insertUi.SetActive(value: false);
		LeanTween.moveX(cdAbyziou2017, 2.745f, 1.5f);
		cdMounted = true;
	}

	private IEnumerator PlayTape()
	{
		interacting = true;
		GameController.instance.achievementManager.UnlockAchievement(AchievementID.MUSIC_LOVER);
		diskUi.SetActive(value: true);
		speaker.Play(switchSfx);
		yield return Yield.WaitSeconds(switchSfx.length);
		isPlayingThis = true;
		speaker.Play(audioAbyzou2017);
		yield return Yield.WaitSeconds(audioAbyzou2017.length);
		speaker.Play(finishedSfx);
		yield return Yield.WaitSeconds(finishedSfx.length);
		isPlayingThis = false;
	}

	public void StopInteraction()
	{
		StartCoroutine(SetInteractingFalse());
	}

	private IEnumerator SetInteractingFalse()
	{
		yield return Yield.WaitSeconds(0.5f);
		interacting = false;
	}
}
public enum STINGS_GOOD
{
	GOOD_STING_01,
	GOOD_STING_02,
	GOOD_STING_03,
	GOOD_SOFT_STING_01,
	GOOD_SOFT_STING_02,
	GOOD_SOFT_STING_03,
	GOOD_CHOIR_STING_01,
	GOOD_CHOIR_STING_02,
	GOOD_CHOIR_STING_03
}
public enum STINGS_BAD
{
	BAD_STING_01,
	BAD_STING_02,
	BAD_STING_03,
	BAD_STING_04,
	BAD_STING_05,
	BAD_STING_06,
	BAD_SOFT_STING_01,
	BAD_SOFT_STING_02,
	BAD_SOFT_STING_03
}
public class AudioController : MonoBehaviour
{
	public AudioMixer mainMixer;

	private bool inProgress;

	public AudioMixerSnapshot mute;

	public AudioMixerSnapshot full;

	public AudioMixerSnapshot dipMusic;

	public AudioMixerSnapshot dipAllNonVo;

	public AudioMixer oculusSpatialMixer;

	public AudioMixerSnapshot muteSpatial;

	public AudioMixerSnapshot fullSpatial;

	public AudioMixerSnapshot fullSpatialEchoEffect;

	public AudioMixerSnapshot fullSpatialLowPass;

	public AudioScript persistentMusicPlayer;

	[SerializeField]
	private AudioScript stingPlayer;

	[Space]
	[SerializeField]
	private AudioClip[] goodStings;

	[SerializeField]
	private AudioClip[] badStings;

	private void Awake()
	{
	}

	private void Start()
	{
	}

	public void SnapMute(float setTime)
	{
		mute.TransitionTo(setTime);
		muteSpatial.TransitionTo(setTime);
	}

	public void SnapAllOpen(float setTime)
	{
		full.TransitionTo(setTime);
		fullSpatial.TransitionTo(setTime);
	}

	public void SnapSpatialEcho(float setTime)
	{
		fullSpatialEchoEffect.TransitionTo(setTime);
	}

	public void SnapMusicDip(float setTime)
	{
		dipMusic.TransitionTo(setTime);
	}

	public void SnapDipAll(float setTime)
	{
		dipAllNonVo.TransitionTo(setTime);
		fullSpatialLowPass.TransitionTo(setTime);
	}

	public void PlayGoodSting(STINGS_GOOD sting, float vol = 1f)
	{
		stingPlayer.Play(goodStings[(int)sting], vol);
	}

	public void PlayBadSting(STINGS_BAD sting, float vol = 1f)
	{
		stingPlayer.Play(badStings[(int)sting], vol);
	}
}
public class AudioReel : MonoBehaviour
{
	[SerializeField]
	private GameObject reelAbyziou1974;

	[SerializeField]
	private AudioScript speaker;

	[SerializeField]
	private Transform reelSnapPoint;

	[SerializeField]
	private GameObject emptyReel;

	[SerializeField]
	private GameObject tapeObject;

	[SerializeField]
	private Material tapePlayerMaterial;

	[Space]
	[SerializeField]
	private AudioClip audioAbyzou1974;

	[SerializeField]
	private AudioClip switchSfx;

	[SerializeField]
	private AudioClip finishedSfx;

	[Space]
	private bool isPlayingThis;

	private bool interacting;

	private Coroutine playCoroutine;

	private bool tapeMounted;

	private void Start()
	{
		if (tapeObject.activeInHierarchy)
		{
			tapeObject.SetActive(value: false);
		}
		tapePlayerMaterial.SetColor("_EmissionColor", UnityEngine.Color.black);
	}

	public void ReelInteraction()
	{
		if (tapeMounted && !interacting)
		{
			if (!speaker.m_AudioSource.isPlaying)
			{
				playCoroutine = StartCoroutine(PlayTape());
			}
			else if (isPlayingThis && speaker.m_AudioSource.clip != finishedSfx)
			{
				StopCoroutine(playCoroutine);
				StartCoroutine(StopTape());
			}
		}
	}

	public void OnTriggerEnter(Collider other)
	{
		if (other.gameObject == reelAbyziou1974 && !tapeMounted)
		{
			StartCoroutine(MoveTape());
		}
	}

	private IEnumerator MoveTape()
	{
		LeanTween.move(reelAbyziou1974, reelSnapPoint.position, 0.3f);
		LeanTween.rotate(reelAbyziou1974, reelSnapPoint.eulerAngles, 0.3f);
		reelAbyziou1974.GetComponent<NVRInteractableItem>().CanAttach = false;
		reelAbyziou1974.GetComponent<Rigidbody>().isKinematic = true;
		yield return Yield.WaitSeconds(0.3f);
		tapeObject.SetActive(value: true);
		tapeMounted = true;
	}

	private IEnumerator StopTape()
	{
		interacting = true;
		speaker.StopLoop();
		speaker.Play(finishedSfx);
		tapePlayerMaterial.SetColor("_EmissionColor", UnityEngine.Color.black);
		LeanTween.cancel(emptyReel);
		LeanTween.cancel(reelAbyziou1974);
		yield return Yield.WaitSeconds(finishedSfx.length);
		isPlayingThis = false;
	}

	private IEnumerator PlayTape()
	{
		interacting = true;
		speaker.Play(switchSfx);
		yield return Yield.WaitSeconds(switchSfx.length);
		tapePlayerMaterial.SetColor("_EmissionColor", UnityEngine.Color.white);
		isPlayingThis = true;
		float num = audioAbyzou1974.length * 90f;
		LeanTween.rotateAroundLocal(emptyReel, Vector3.right, 0f - num, audioAbyzou1974.length);
		LeanTween.rotateAroundLocal(reelAbyziou1974, Vector3.right, 0f - num, audioAbyzou1974.length);
		speaker.Play(audioAbyzou1974);
		HUD.Instance.PlaySubtitles(audioAbyzou1974.name, hasPriority: true);
		yield return Yield.WaitSeconds(audioAbyzou1974.length);
		speaker.Play(finishedSfx);
		tapePlayerMaterial.SetColor("_EmissionColor", UnityEngine.Color.black);
		yield return Yield.WaitSeconds(finishedSfx.length);
		isPlayingThis = false;
	}

	public void StopInteraction()
	{
		StartCoroutine(SetInteractingFalse());
	}

	private IEnumerator SetInteractingFalse()
	{
		yield return Yield.WaitSeconds(0.5f);
		interacting = false;
	}
}
public class AudioScriptContainer : MonoBehaviour
{
	public static AudioScriptContainer Instance;

	public AudioScript[] audioScripts;

	private void Awake()
	{
		Instance = this;
	}

	private void OnDestroy()
	{
		Instance = null;
	}
}
public class AudioTrigger : MonoBehaviour
{
	[SerializeField]
	private GameObject AudioReelLeft;

	[SerializeField]
	private GameObject AudioReelRight;

	[SerializeField]
	private GameObject TriggerAudioReelLeft;

	[SerializeField]
	private GameObject TriggerAudioReelright;

	[SerializeField]
	private GameObject leftReelPosition;

	[SerializeField]
	private GameObject AudioTape;

	[SerializeField]
	private GameObject PlayTrigger;

	private bool leftReelsActivated;

	private bool rightReelsActivated;

	private bool leftInTrigger;

	private bool rightInTrigger;

	private Vector3 leftOrigionalPosition;

	private Quaternion leftOrigionalRotation;

	private void Start()
	{
		leftOrigionalPosition = AudioReelLeft.transform.position;
		leftOrigionalRotation = AudioReelRight.transform.rotation;
		AudioTape.SetActive(value: false);
		PlayTrigger.SetActive(value: false);
	}

	public void OnTriggerEnter(Collider other)
	{
		UnityEngine.Debug.Log("Audio Reel Triggered");
		if (other.gameObject == AudioReelLeft)
		{
			leftInTrigger = true;
		}
		else if (other.gameObject == AudioReelRight)
		{
			rightInTrigger = true;
		}
	}

	private void OnTriggerExit(Collider other)
	{
		UnityEngine.Debug.Log("Audio Reel Triggered");
		if (other.gameObject == AudioReelLeft)
		{
			leftInTrigger = false;
		}
		else if (other.gameObject == AudioReelRight)
		{
			rightInTrigger = false;
		}
	}

	private void Update()
	{
		if (leftInTrigger && !leftReelsActivated)
		{
			LeanTween.move(AudioReelLeft, leftOrigionalPosition, 1f);
		}
		if (leftReelsActivated && rightReelsActivated)
		{
			AudioTape.SetActive(value: true);
			PlayTrigger.SetActive(value: true);
		}
	}
}
public class AutopsyLight : MonoBehaviour
{
	[SerializeField]
	private GameObject mainPole;

	[SerializeField]
	private GameObject lightHead;

	[SerializeField]
	public LightFlicker lightFlicker;

	private Vector3 mainPolePosition;

	private Quaternion mainPoleRotation;

	private Vector3 lightHeadPosition;

	private Quaternion lightHeadRotation;

	private void Awake()
	{
		mainPolePosition = mainPole.transform.position;
		mainPoleRotation = mainPole.transform.rotation;
		lightHeadPosition = lightHead.transform.position;
		lightHeadRotation = lightHead.transform.rotation;
	}

	public void ResetPosition()
	{
		mainPole.transform.position = mainPolePosition;
		mainPole.transform.rotation = mainPoleRotation;
		lightHead.transform.position = lightHeadPosition;
		lightHead.transform.rotation = lightHeadRotation;
	}

	private void Update()
	{
	}
}
public class Baal : MonoBehaviour
{
	[Serializable]
	public struct Timings
	{
		public float impactDuration;

		public float slowdown;

		public float yield1;

		public float yield2;

		public float yield3;

		public float gracePeriod;

		public float attackTimeMin;

		public float attackTimeMax;
	}

	public enum AttackItemType
	{
		BARREL,
		PETROLCAN,
		CHAIR,
		TROLLEY
	}

	public enum State
	{
		NONE,
		IDLE,
		ATTACKING,
		DYING
	}

	public enum Health
	{
		FULLHEALTH,
		HALFHEALTH,
		DEAD
	}

	[Serializable]
	public struct AttackItems
	{
		public AttackItemType itemType;

		public Transform spawnTransform;

		public GameObject attackObject;

		public string levitateAnimTrigger;

		public float levitateAnimLength;

		public string floatAnimTrigger;

		public float floatAnimLength;
	}

	[SerializeField]
	private AudioClip throwAudioClip;

	[SerializeField]
	private ParticleSystem throwParticles;

	[SerializeField]
	private ParticleSystem baalVOParticles;

	[SerializeField]
	private ParticleSystem baalDeathParticles;

	[SerializeField]
	private Animator animator;

	[SerializeField]
	private AttackItems[] attackItems;

	[SerializeField]
	public bool playerHit;

	[SerializeField]
	public bool playerDodged;

	[SerializeField]
	private State baalState;

	[SerializeField]
	public Health baalHealth;

	[SerializeField]
	private float timeTillAttacks;

	[SerializeField]
	private GameObject spawnpoint;

	[Space]
	[Header("Attack/Diffiuculty Timings")]
	[SerializeField]
	private Timings attackTimings;

	[SerializeField]
	private float difficultyScaler;

	[SerializeField]
	private float difficultyStep;

	[SerializeField]
	private float lowestDifficulty;

	[SerializeField]
	private bool shouldChangeDifficultyBasedOnDistance;

	public bool canHitPlayer = true;

	private AudioScript throwAudio;

	public State BaalState => baalState;

	private void Start()
	{
		baalState = State.NONE;
		animator.SetBool("Dead", value: false);
		animator.SetBool("Melt_Idle", value: true);
	}

	private void Update()
	{
		if (baalState == State.IDLE && timeTillAttacks > 0f)
		{
			timeTillAttacks -= Time.deltaTime;
		}
	}

	public void RunSpeechParticles()
	{
		baalVOParticles.Clear();
		baalVOParticles.Play();
	}

	public void SetThrowAudio(AudioScript audio, Transform audioPos)
	{
		throwAudio = audio;
		throwAudio.transform.position = audioPos.position;
	}

	public void StartAttacking()
	{
		timeTillAttacks = UnityEngine.Random.Range(attackTimings.attackTimeMin, attackTimings.attackTimeMax);
		baalState = State.IDLE;
		StartCoroutine(StartAttackingRoutine());
	}

	public void StopAttacking()
	{
		StartCoroutine(StopAttackingRoutine());
	}

	private IEnumerator StopAttackingRoutine()
	{
		while (baalState == State.ATTACKING)
		{
			yield return Yield.EndOfFrame;
		}
		StopAllCoroutines();
	}

	public void StopDeathParticles()
	{
		baalDeathParticles.Stop();
	}

	public void PlayWeakAnimation()
	{
		baalDeathParticles.Play();
		animator.SetBool("Dead", value: true);
		animator.SetTrigger("Melt");
	}

	public void PlayDeathAnimation()
	{
		RunSpeechParticles();
		animator.SetBool("Melt_Idle", value: false);
	}

	public void PlayGrowlIdleAnimation()
	{
		animator.SetTrigger("Growl");
	}

	private IEnumerator StartAttackingRoutine()
	{
		while (baalState == State.IDLE && timeTillAttacks > 0f)
		{
			yield return Yield.WaitSeconds(0.5f);
		}
		baalState = State.ATTACKING;
		AttackItemType itemType = (AttackItemType)UnityEngine.Random.Range(0, Enum.GetValues(typeof(AttackItemType)).Length);
		SpawnObject(itemType);
	}

	private void SpawnObject(AttackItemType itemType)
	{
		AttackItems attackItemByType = getAttackItemByType(itemType);
		GameObject gameObject = UnityEngine.Object.Instantiate(attackItemByType.attackObject, spawnpoint.transform);
		gameObject.transform.localPosition = Vector3.zero;
		if (baalHealth == Health.FULLHEALTH)
		{
			animator.SetTrigger("Attack");
		}
		else
		{
			animator.SetTrigger("Attack_Weak");
		}
		StartCoroutine(LevitateObject(attackItemByType, gameObject));
	}

	private IEnumerator LevitateObject(AttackItems itemType, GameObject attackItemObject)
	{
		Animator component = attackItemObject.GetComponent<Animator>();
		component.enabled = true;
		component.SetTrigger(itemType.levitateAnimTrigger);
		yield return Yield.WaitSeconds(2.8f);
		StartCoroutine(ThrowObject(itemType, attackItemObject));
	}

	private IEnumerator ThrowObject(AttackItems itemType, GameObject attackItemObject)
	{
		throwAudio.Play(throwAudioClip);
		throwParticles.Clear(withChildren: true);
		throwParticles.Play(withChildren: true);
		Vector3 playerHeadBeforeThrowTransform = GameController.instance.player.Head.transform.position;
		attackItemObject.GetComponent<Animator>().enabled = false;
		LeanTween.move(attackItemObject.gameObject, playerHeadBeforeThrowTransform, attackTimings.impactDuration * difficultyScaler).destroyOnComplete = true;
		yield return Yield.WaitSeconds(attackTimings.yield1 * difficultyScaler);
		SlowTime(attackTimings.slowdown * difficultyScaler);
		yield return Yield.WaitSeconds(attackTimings.yield2 * difficultyScaler);
		SlowTime(1f);
		yield return Yield.WaitSeconds(attackTimings.yield3 * difficultyScaler);
		yield return Yield.WaitSeconds(attackTimings.gracePeriod);
		Vector3 position = GameController.instance.player.Head.transform.position;
		float distance = Vector3.Distance(playerHeadBeforeThrowTransform, position);
		yield return Yield.EndOfFrame;
		if (baalHealth == Health.FULLHEALTH)
		{
			timeTillAttacks = 4f;
		}
		else
		{
			timeTillAttacks = 3f;
		}
		if (distance > 0.3f)
		{
			UnityEngine.Debug.Log("Missed");
			playerHit = false;
			playerDodged = true;
			baalState = State.IDLE;
			StartCoroutine(StartAttackingRoutine());
		}
		else
		{
			UnityEngine.Debug.Log("Hit");
			baalState = State.IDLE;
			playerHit = true;
			playerDodged = false;
			difficultyScaler = Mathf.Clamp(difficultyScaler += difficultyStep, 0f, lowestDifficulty);
		}
	}

	private void SlowTime(float newTime)
	{
		AudioSource[] array = UnityEngine.Object.FindObjectsOfType(typeof(AudioSource)) as AudioSource[];
		for (int i = 0; i < array.Length; i++)
		{
			array[i].pitch = newTime;
		}
		Time.timeScale = newTime;
	}

	private AttackItems getAttackItemByType(AttackItemType type)
	{
		for (int i = 0; i < attackItems.Length; i++)
		{
			AttackItems result = attackItems[i];
			if (result.itemType == type)
			{
				return result;
			}
		}
		return default(AttackItems);
	}
}
public class BabyRattle : MonoBehaviour
{
	[SerializeField]
	private AudioScript audioScript;

	[SerializeField]
	private AudioClip[] rattleClips;

	[Space]
	[SerializeField]
	private float delay = 0.5f;

	private Rigidbody rb;

	private Vector3 lastPlayedDir = Vector3.zero;

	private void Start()
	{
		rb = GetComponent<Rigidbody>();
		if (audioScript == null)
		{
			if ((bool)base.gameObject.GetComponent<AudioScript>())
			{
				audioScript = base.gameObject.GetComponent<AudioScript>();
			}
			else
			{
				UnityEngine.Debug.Log("No audio script found for : " + base.gameObject.name);
			}
		}
	}

	private void Update()
	{
		if (lastPlayedDir == Vector3.zero || Vector3.Angle(lastPlayedDir, rb.velocity) > 90f)
		{
			float magnitude = rb.velocity.magnitude;
			if (magnitude > 0.1f)
			{
				float value = magnitude * 0.25f;
				value = Mathf.Clamp(value, 0.1f, 1f);
				audioScript.PlayOne(rattleClips[UnityEngine.Random.Range(0, rattleClips.Length)], value);
				lastPlayedDir = rb.velocity;
			}
		}
	}
}
public class BabySounds : MonoBehaviour
{
	public AudioScript audioScript;

	[SerializeField]
	private AudioClip painLoop;

	[SerializeField]
	private AudioClip cryLoop;

	[SerializeField]
	private AudioClip layLoop;

	public void PainSound()
	{
		if ((bool)audioScript && (bool)painLoop)
		{
			audioScript.m_AudioSource.clip = painLoop;
			audioScript.m_AudioSource.Play();
		}
	}

	public void CrySound()
	{
		if ((bool)audioScript && (bool)cryLoop)
		{
			audioScript.m_AudioSource.clip = cryLoop;
			audioScript.m_AudioSource.Play();
		}
	}

	public void LaySound()
	{
		if ((bool)audioScript && (bool)layLoop)
		{
			audioScript.m_AudioSource.clip = layLoop;
			audioScript.m_AudioSource.Play();
		}
	}
}
public class BatSwarm : MonoBehaviour
{
	[Serializable]
	public enum SwarmTargetType
	{
		STANDARD,
		PLAYER
	}

	[Serializable]
	public struct SwarmTarget
	{
		public SwarmTargetType swarmTargetType;

		public Transform transform;
	}

	[SerializeField]
	private AudioScript batAudioScript;

	[SerializeField]
	private AudioClip batAudioClip;

	[SerializeField]
	private float distanceFromPlayer;

	[SerializeField]
	public SwarmTarget[] swarmTargets;

	[SerializeField]
	public float radius;

	[SerializeField]
	public bool attackPlayer;

	[SerializeField]
	public float attackDuration;

	[SerializeField]
	private bool addRandomnessToTarget = true;

	[SerializeField]
	public GameObject[] batSwarm;

	private bool flyToPlayer = true;

	private NVRPlayer player;

	private void Start()
	{
		for (int i = 0; i < batSwarm.Length; i++)
		{
			batSwarm[i].SetActive(value: false);
		}
		player = GameController.instance.player;
	}

	public void StartSwarm()
	{
		for (int i = 0; i < batSwarm.Length; i++)
		{
			StartCoroutine(Fly(i));
		}
		batAudioScript.PlayLoop(batAudioClip);
	}

	private void FlyAwayFromPlayer()
	{
		LeanTween.resumeAll();
		flyToPlayer = false;
	}

	private IEnumerator StartAnimations(int batIndex)
	{
		yield return Yield.WaitSeconds(UnityEngine.Random.Range(0.33f, 2f));
		batSwarm[batIndex].GetComponent<Animator>().SetTrigger("Flying");
	}

	private IEnumerator Fly(int batIndex)
	{
		Vector3 previousTarget = Vector3.zero;
		flyToPlayer = true;
		batSwarm[batIndex].SetActive(value: true);
		StartCoroutine(StartAnimations(batIndex));
		float totalDistance = 0f;
		for (int i = 0; i < swarmTargets.Length - 1; i++)
		{
			if (swarmTargets[i].swarmTargetType == SwarmTargetType.PLAYER)
			{
				Vector3 a = player.Head.transform.position + player.Head.transform.forward * distanceFromPlayer;
				totalDistance += Vector3.Distance(a, swarmTargets[i + 1].transform.position);
			}
			else if (swarmTargets[i + 1].swarmTargetType == SwarmTargetType.PLAYER)
			{
				Vector3 b = player.Head.transform.position + player.Head.transform.forward * distanceFromPlayer;
				totalDistance += Vector3.Distance(swarmTargets[i].transform.position, b);
			}
			else
			{
				totalDistance += Vector3.Distance(swarmTargets[i].transform.position, swarmTargets[i + 1].transform.position);
			}
		}
		int targetCount = 0;
		SwarmTarget[] array = swarmTargets;
		for (int j = 0; j < array.Length; j++)
		{
			SwarmTarget target = array[j];
			if (target.swarmTargetType == SwarmTargetType.PLAYER)
			{
				_ = player.Head.transform;
				if (attackPlayer)
				{
					Vector3 targetDistanceCheck = new Vector3(player.Head.transform.position.x, player.Head.transform.position.y, player.Head.transform.position.z);
					Vector3 vector = player.Head.transform.position + player.Head.transform.forward * distanceFromPlayer;
					if (addRandomnessToTarget)
					{
						vector.x += UnityEngine.Random.Range(-1f, 1f);
						vector.y += UnityEngine.Random.Range(-1f, 1f);
						vector.z += UnityEngine.Random.Range(-1f, 1f);
					}
					batSwarm[batIndex].transform.LookAt(player.Head.transform.position);
					float time = Vector3.Distance(swarmTargets[targetCount - 1].transform.position, vector) / totalDistance * attackDuration;
					LeanTween.move(batSwarm[batIndex], vector, time).setOnComplete(FlyAwayFromPlayer);
					float timeRemaining = time;
					while (flyToPlayer)
					{
						if ((double)Vector3.Distance(targetDistanceCheck, player.Head.transform.position) > 0.5)
						{
							float num = Vector3.Distance(previousTarget, batSwarm[batIndex].transform.position) / (time - timeRemaining);
							float num2 = Vector3.Distance(batSwarm[batIndex].transform.position, player.Head.transform.position) / num;
							vector = player.Head.transform.position + player.Head.transform.forward * distanceFromPlayer;
							if (addRandomnessToTarget)
							{
								vector.x += UnityEngine.Random.Range(-1f, 1f);
								vector.y += UnityEngine.Random.Range(-1f, 1f);
								vector.z += UnityEngine.Random.Range(-1f, 1f);
							}
							LeanTween.cancel(batSwarm[batIndex]);
							LeanTween.move(batSwarm[batIndex], vector, num2).setOnComplete(FlyAwayFromPlayer);
							timeRemaining = num2;
							targetDistanceCheck = new Vector3(player.Head.transform.position.x, player.Head.transform.position.y, player.Head.transform.position.z) + new Vector3(0.5f, 0.5f, 0.5f);
						}
						yield return Yield.WaitSeconds(0.1f);
						timeRemaining -= 0.1f;
					}
					previousTarget = player.Head.transform.position;
				}
				else
				{
					if (!LeanTween.isTweening(batSwarm[batIndex]))
					{
						LeanTween.resume(batSwarm[batIndex]);
					}
					Vector3 vector2 = new Vector3(player.Head.transform.position.x, player.Head.transform.position.y, player.Head.transform.position.z);
					if (addRandomnessToTarget)
					{
						vector2.x += UnityEngine.Random.Range(-2f, 2f);
						vector2.y += UnityEngine.Random.Range(-2f, 2f);
						vector2.z += UnityEngine.Random.Range(-2f, 2f);
					}
					batSwarm[batIndex].transform.LookAt(vector2);
					float time2 = Vector3.Distance(swarmTargets[targetCount - 1].transform.position, vector2) / totalDistance * attackDuration;
					LeanTween.move(batSwarm[batIndex], vector2, time2);
					yield return Yield.WaitSeconds(time2);
					previousTarget = target.transform.position;
				}
			}
			else
			{
				if (!LeanTween.isTweening(batSwarm[batIndex]))
				{
					LeanTween.resume(batSwarm[batIndex]);
				}
				Vector3 vector3 = new Vector3(target.transform.position.x, target.transform.position.y, target.transform.position.z);
				if (addRandomnessToTarget)
				{
					vector3.x += UnityEngine.Random.Range(-2f, 2f);
					vector3.y += UnityEngine.Random.Range(-2f, 2f);
					vector3.z += UnityEngine.Random.Range(-2f, 2f);
				}
				batSwarm[batIndex].transform.LookAt(vector3);
				float time3;
				if (targetCount == 0)
				{
					if (swarmTargets[targetCount + 1].swarmTargetType == SwarmTargetType.PLAYER)
					{
						Vector3 b2 = player.Head.transform.position + player.Head.transform.forward * distanceFromPlayer;
						time3 = Vector3.Distance(vector3, b2) / totalDistance * attackDuration;
					}
					else
					{
						time3 = Vector3.Distance(vector3, swarmTargets[targetCount + 1].transform.position) / totalDistance * attackDuration;
					}
				}
				else if (swarmTargets[targetCount - 1].swarmTargetType == SwarmTargetType.PLAYER)
				{
					Vector3 b3 = player.Head.transform.position + player.Head.transform.forward * distanceFromPlayer;
					time3 = Vector3.Distance(vector3, b3) / totalDistance * attackDuration;
				}
				else
				{
					time3 = Vector3.Distance(swarmTargets[targetCount - 1].transform.position, vector3) / totalDistance * attackDuration;
				}
				LeanTween.move(batSwarm[batIndex], vector3, time3);
				yield return Yield.WaitSeconds(time3);
				previousTarget = target.transform.position;
			}
			int num3 = targetCount + 1;
			targetCount = num3;
		}
		batSwarm[batIndex].GetComponent<Animator>().SetTrigger("None");
		batSwarm[batIndex].SetActive(value: false);
	}
}
public class Beacon : MonoBehaviour
{
	[SerializeField]
	private Material beaconMat;

	[SerializeField]
	public AudioClip beaconAlertAudioClip;

	[SerializeField]
	public AudioScript beaconAudio;

	[SerializeField]
	public AudioClip beaconAudioClip;

	[HideInInspector]
	public bool isPlaying;

	private void Start()
	{
		beaconMat.DisableKeyword("_EMISSION");
	}

	public void PlayAlertLoop()
	{
		beaconAudio.PlayLoop(beaconAlertAudioClip, 0.1f);
		StartCoroutine(AlertFlash());
	}

	private IEnumerator AlertFlash()
	{
		while (!isPlaying)
		{
			beaconMat.SetTextureScale("_Illum", new Vector2(1f, 1f));
			yield return Yield.WaitSeconds(0.1f);
			beaconMat.SetTextureScale("_Illum", new Vector2(0f, 0f));
			yield return Yield.WaitSeconds(1.9f);
		}
	}

	public void StopAlertLoop()
	{
		if (beaconAudio.IsPlayingClip(beaconAlertAudioClip))
		{
			beaconAudio.StopLoop();
		}
	}

	public void PlayMessage()
	{
		StartCoroutine(PlayMessageRoutine());
	}

	private IEnumerator PlayMessageRoutine()
	{
		if (!isPlaying)
		{
			if (beaconAudio.IsPlayingClip(beaconAlertAudioClip))
			{
				beaconAudio.StopLoop();
			}
			isPlaying = true;
			beaconMat.SetTextureScale("_Illum", new Vector2(1f, 1f));
			beaconAudio.Play(beaconAudioClip);
			HUD.Instance.PlaySubtitles(beaconAudioClip.name, hasPriority: true);
			yield return Yield.WaitSeconds(beaconAudioClip.length);
			beaconMat.SetTextureScale("_Illum", new Vector2(0f, 0f));
			isPlaying = false;
		}
	}
}
public class BibleBurst : MonoBehaviour
{
	[SerializeField]
	private GameObject cover;

	[SerializeField]
	private ParticleSystem pageParticle;

	[SerializeField]
	private AudioScript audioScript;

	[SerializeField]
	private AudioClip impactSfx;

	private void Start()
	{
		audioScript = base.gameObject.GetComponent<AudioScript>();
	}

	public void Burst()
	{
		StartCoroutine(BurstBible());
	}

	private IEnumerator BurstBible()
	{
		LeanTween.rotateZ(cover, -124f, 0.25f);
		yield return Yield.WaitSeconds(0.1f);
		audioScript.Play(impactSfx);
		pageParticle.Play();
	}
}
public class Boat : MonoBehaviour
{
	public GameObject boatMeshObject;

	public Transform boatTransform;

	public Rigidbody body;

	public GameObject playerBoatPos;

	public Collider[] boatColliders;

	public GameObject[] arrivalFloors;

	public GameObject destinationFloor;

	public Transform destinationPoint;

	[Space]
	[Header("Audio")]
	public AudioClip waterClip;

	public AudioClip ropeClip;

	public AudioClip[] ropePullClip;

	public AudioScript waterAudio;

	public AudioScript ropeAudio;

	public AudioScript fatherBellVOScript;

	public AudioClip fatherBellVOClip;

	public AudioScriptPooled ropeAudioPooled;

	private bool _canPlayRopePullSFX = true;

	private Transform[] attachedHands;

	private Vector3[] handStartVecs;

	private NVRPlayer player;

	private NVRInteractable lastHeldRopeLink;

	private bool _rotated;

	private bool _startedTransition;

	private bool _reachedDestination;

	[Space]
	[Header("Movement Vars")]
	public float force = 8f;

	public float rotationLimit;

	public float rotationTime = 1f;

	private float _prevTheta;

	private const float kThetaThreshold = 2f;

	private int _handIndex = -1;

	public bool canInteract;

	private int _forwardID = -1;

	private int _rotID = -1;

	private Action resetForward;

	private Action resetRotation;

	private void Start()
	{
		player = GameController.instance.player;
		resetForward = ResetForward;
		resetRotation = ResetRotation;
		destinationFloor.SetActive(value: false);
		attachedHands = new Transform[2];
		handStartVecs = new Vector3[2]
		{
			Vector3.zero,
			Vector3.zero
		};
	}

	private float ClampAngle(float angle, float from, float to)
	{
		if (angle < 0f)
		{
			angle = 360f + angle;
		}
		if (angle > 180f)
		{
			return Mathf.Max(angle, 360f + from);
		}
		return Mathf.Min(angle, to);
	}

	private void Update()
	{
		if (!_reachedDestination)
		{
			if (_rotated)
			{
				float num = Vector2.SignedAngle(boatTransform.up, player.Head.transform.position) + 15f;
				if (num > 2f || num < 2f)
				{
					float to = ClampAngle(num, 0f - rotationLimit, rotationLimit);
					if (_rotID != 1)
					{
						LeanTween.cancel(_rotID);
					}
					_rotID = LeanTween.rotateX(base.gameObject, to, rotationTime).setOnComplete(resetRotation).id;
					_prevTheta = num;
				}
				else
				{
					if (_rotID != 1)
					{
						LeanTween.cancel(_rotID);
					}
					_rotID = LeanTween.rotateX(base.gameObject, 0f, rotationTime).setOnComplete(resetRotation).id;
				}
			}
			base.gameObject.transform.position = new Vector3(body.position.x, body.position.y, body.position.z);
			if (base.transform.position.z - destinationPoint.position.z < 0.8f)
			{
				body.velocity = Vector3.zero;
				body.gameObject.SetActive(value: false);
				Collider[] array = boatColliders;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].enabled = false;
				}
				destinationFloor.SetActive(value: true);
				_reachedDestination = true;
				player.transform.rotation = new Quaternion(player.transform.rotation.x, player.transform.rotation.y, 0f, player.transform.rotation.w);
				player.movement.EnableMovement();
				player.movement.overrideMovementEnabled = false;
				player.transform.parent = null;
			}
		}
		SetAudioVolumes();
	}

	private void SetAudioVolumes()
	{
		float value = Mathf.Abs(body.velocity.magnitude * 2f);
		waterAudio.m_AudioSource.volume = Mathf.Clamp(value, 0.75f, 1f);
	}

	private void FixedUpdate()
	{
		if (_handIndex <= -1 || _reachedDestination)
		{
			return;
		}
		if (!_rotated && !_startedTransition)
		{
			_startedTransition = true;
			StartCoroutine(RotateForward());
		}
		if (!_rotated || _handIndex <= -1)
		{
			return;
		}
		Vector3[] array = new Vector3[2]
		{
			Vector3.zero,
			Vector3.zero
		};
		for (int i = 0; i < attachedHands.Length; i++)
		{
			if (attachedHands[i] != null)
			{
				array[i] = handStartVecs[i] - attachedHands[i].transform.position;
			}
		}
		float num = ((array[0].z < array[1].z) ? array[0].z : array[1].z);
		if (num < 0f)
		{
			body.AddForceAtPosition(Vector3.forward * num * force, base.transform.position, ForceMode.Impulse);
			if (_canPlayRopePullSFX && num < -0.15f)
			{
				ropeAudioPooled.PlayOneShot(ropePullClip[UnityEngine.Random.Range(0, ropePullClip.Length)], 0.75f);
			}
		}
	}

	private IEnumerator PlayRopePullSFX()
	{
		_canPlayRopePullSFX = false;
		AudioClip audioClip = ropePullClip[UnityEngine.Random.Range(0, ropePullClip.Length)];
		ropeAudioPooled.PlayOneShot(audioClip);
		yield return Yield.WaitSeconds(audioClip.length);
		_canPlayRopePullSFX = true;
	}

	private IEnumerator RotateForward()
	{
		GameObject[] array = arrivalFloors;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(value: false);
		}
		player.movement.DisableMovement();
		player.movement.overrideMovementEnabled = true;
		player.screenFX.Fade(UnityEngine.Color.black, 1f);
		StartCoroutine(PlayRopePullSFX());
		yield return Yield.WaitSeconds(1.5f);
		player.SetPosition(playerBoatPos, setRotation: false);
		player.transform.parent = base.transform;
		player.screenFX.Fade(UnityEngine.Color.clear, 0.5f);
		yield return Yield.WaitSeconds(0.5f);
		if ((bool)body)
		{
			body.isKinematic = false;
		}
		_rotated = true;
	}

	public void PlayVOClip()
	{
		fatherBellVOScript.Play(fatherBellVOClip);
		HUD.Instance.PlaySubtitles(fatherBellVOClip.name, hasPriority: true);
	}

	public void BeginInteraction(NVRInteractable ropeFixture)
	{
		_handIndex++;
		lastHeldRopeLink = ropeFixture;
		attachedHands[_handIndex] = ropeFixture.AttachedHand.transform;
		handStartVecs[_handIndex] = attachedHands[_handIndex].position;
	}

	public void EndInteraction()
	{
		_handIndex--;
		if (_handIndex > -1)
		{
			attachedHands[_handIndex] = null;
			handStartVecs[_handIndex] = Vector3.zero;
		}
	}

	private void ResetForward()
	{
		_forwardID = -1;
	}

	private void ResetRotation()
	{
		_rotID = -1;
	}

	private void OnEnable()
	{
		waterAudio.PlayLoop(waterClip, 0.75f);
		ropeAudio.PlayLoop(ropeClip);
	}
}
public class UltimateVRRope : MonoBehaviour
{
	[SerializeField]
	private Transform parent;

	[SerializeField]
	private UltimateRope rope;

	[SerializeField]
	private GameObject ropeEnd;

	[SerializeField]
	private float maximumRadius;

	[SerializeField]
	private float radialMultiplier;

	[SerializeField]
	private bool lockStart = true;

	[SerializeField]
	private bool lockEnd = true;

	[SerializeField]
	private bool lockEndWhenAtRest;

	[SerializeField]
	private RigidbodyConstraints startLock;

	[SerializeField]
	private RigidbodyConstraints[] lockAxis;

	[SerializeField]
	private int id;

	[SerializeField]
	private GameObject[] enableAfterLock;

	[SerializeField]
	private bool isHint;

	[HideInInspector]
	public bool active = true;

	private bool parented;

	public UltimateVRRopeLink[] links;

	private float heightOffset;

	public bool Parented => parented;

	public Transform Transform => rope.RopeStart.transform;

	public Vector3 CentrePosition => rope.RopeStart.transform.position + (ropeEnd.transform.position - rope.RopeStart.transform.position) * 0.5f;

	private void Start()
	{
		if (!rope)
		{
			rope = GetComponent<UltimateRope>();
		}
		if (lockEndWhenAtRest && !lockEnd)
		{
			GameObject[] array = enableAfterLock;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].SetActive(value: false);
			}
		}
		StartCoroutine(InitRoutine());
	}

	private IEnumerator InitRoutine()
	{
		heightOffset = base.transform.GetChild(base.transform.childCount - 1).position.y - base.transform.GetChild(0).position.y;
		links = new UltimateVRRopeLink[base.transform.childCount];
		int num = 0;
		for (int i = 0; i < base.transform.childCount; i++)
		{
			if (!base.transform.GetChild(i).name.Contains("Node " + num))
			{
				num++;
			}
			links[i] = base.transform.GetChild(i).gameObject.AddComponent<UltimateVRRopeLink>();
			links[i].segmentID = num;
			links[i].lockRadius = GetRadius(i);
			RigidbodyConstraints[] array = lockAxis;
			foreach (RigidbodyConstraints rigidbodyConstraints in array)
			{
				links[i].lockContraints |= rigidbodyConstraints;
			}
			links[i].gameObject.layer = LayerMask.NameToLayer("Rope");
		}
		yield return Yield.WaitSeconds((float)id + 5f);
		int num2 = 0;
		for (int k = 0; k < links.Length; k++)
		{
			links[k].GetComponent<CapsuleCollider>().radius = 0.035f;
			if ((k == 0 && lockStart) || (links[k].segmentID != num2 && lockStart && lockEnd) || (k == links.Length - 1 && lockEnd))
			{
				links[k].CanAttach = false;
				links[k].Rigidbody.constraints = RigidbodyConstraints.FreezeAll;
				links[k].Rigidbody.isKinematic = true;
				num2 = links[k].segmentID;
			}
			else if (k == 0 && !lockStart)
			{
				ConfigurableJoint[] componentsInChildren = links[k].GetComponentsInChildren<ConfigurableJoint>();
				foreach (Joint joint in componentsInChildren)
				{
					if (joint.connectedBody.gameObject == rope.RopeStart)
					{
						joint.breakForce = 0f;
					}
				}
				links[k].Rigidbody.constraints = RigidbodyConstraints.None;
				links[k].Rigidbody.AddForce(Vector3.one);
				rope.RopeStart.GetComponent<Rigidbody>().constraints = RigidbodyConstraints.None;
			}
			else
			{
				if (lockEnd || k != links.Length - 1)
				{
					continue;
				}
				if (lockEndWhenAtRest)
				{
					Rigidbody component = ropeEnd.GetComponent<Rigidbody>();
					RigidbodyConstraints[] array = lockAxis;
					foreach (RigidbodyConstraints rigidbodyConstraints2 in array)
					{
						component.constraints |= rigidbodyConstraints2;
					}
					array = lockAxis;
					foreach (RigidbodyConstraints rigidbodyConstraints3 in array)
					{
						links[k].lockContraints |= rigidbodyConstraints3;
					}
					links[k].SetContraints(RigidbodyConstraints.FreezeAll);
					links[k].Rigidbody.isKinematic = true;
					GameObject[] array2 = enableAfterLock;
					for (int j = 0; j < array2.Length; j++)
					{
						array2[j].SetActive(value: true);
					}
					continue;
				}
				ropeEnd.GetComponent<Rigidbody>().constraints = RigidbodyConstraints.None;
				ConfigurableJoint[] componentsInChildren = links[k].GetComponentsInChildren<ConfigurableJoint>();
				foreach (Joint joint2 in componentsInChildren)
				{
					if (joint2.connectedBody.gameObject == ropeEnd)
					{
						joint2.breakForce = 0f;
					}
				}
				links[k].Rigidbody.AddForce(Vector3.one);
				links[k].Rigidbody.constraints = RigidbodyConstraints.None;
			}
		}
		base.transform.parent = parent;
		parented = true;
		base.gameObject.layer = LayerMask.NameToLayer("Rope");
	}

	private float GetRadius(int index)
	{
		float num = 0f;
		num = ((!Application.isPlaying) ? ((index <= base.transform.childCount / 2) ? (maximumRadius / (float)base.transform.childCount * (float)index * 2f) : (maximumRadius / (float)base.transform.childCount * (float)(base.transform.childCount - index) * 2f)) : ((index <= links.Length / 2) ? (maximumRadius / (float)links.Length * (float)index * 2f) : (maximumRadius / (float)links.Length * (float)(links.Length - index) * 2f)));
		num *= radialMultiplier + num;
		return Mathf.Clamp(num, 0f, maximumRadius);
	}

	public void BreakRopeAtNode(int nodeID)
	{
		if (nodeID >= links.Length || nodeID < 0)
		{
			UnityEngine.Debug.LogError("Please break the rope using a correct node ID, it should be in the range of 0-" + (links.Length - 1));
			return;
		}
		if (nodeID == 0 || nodeID == links.Length - 1)
		{
			links[nodeID].Rigidbody.constraints = RigidbodyConstraints.None;
			links[nodeID].Rigidbody.isKinematic = false;
		}
		links[nodeID].GetComponent<ConfigurableJoint>().breakForce = 0f;
	}

	private void OnDrawGizmosSelected()
	{
	}
}
public class UltimateVRRopeLink : NVRInteractableItem
{
	[Space]
	[Header("Rope Link Vars")]
	public float lockRadius;

	public RigidbodyConstraints lockContraints;

	public int segmentID;

	public UltimateVRRopeLink prev;

	public UltimateVRRopeLink next;

	private bool locked;

	private Transform parent;

	private RigidbodyConstraints startingConstraints;

	public bool IsHint
	{
		get
		{
			return isHint;
		}
		set
		{
			isHint = value;
		}
	}

	public RigidbodyConstraints Constrains
	{
		set
		{
			startingConstraints = value;
			Rigidbody.constraints = startingConstraints;
		}
	}

	public Vector3 CentrePos => startPosition;

	public void SetSkinnedMeshForHint(SkinnedMeshRenderer rend)
	{
		skinnedMeshArrayForHighlighting = new SkinnedMeshRenderer[1] { rend };
	}

	protected override void Start()
	{
		base.Start();
		parent = base.transform.parent;
		hideHands = true;
	}

	protected override void FixedUpdate()
	{
		base.FixedUpdate();
		_ = IsAttached;
	}

	public override void BeginInteraction(NVRHand hand, bool runBeginInteractionCallback = true)
	{
		base.BeginInteraction(hand, runBeginInteractionCallback);
	}

	public override void EndInteraction(NVRHand hand)
	{
		base.EndInteraction(hand);
		SetContraints(startingConstraints);
		locked = false;
		base.transform.parent = parent;
	}

	public void SetContraints(RigidbodyConstraints constraints)
	{
		Rigidbody.constraints = constraints;
		if (prev != null)
		{
			prev.Rigidbody.constraints = constraints;
		}
		if (next != null)
		{
			next.Rigidbody.constraints = constraints;
		}
	}
}
public enum NotebookPages
{
	Q01,
	Q02,
	Q03,
	Q04,
	Q05,
	Q06,
	Q07,
	Q08,
	Q09,
	Q10,
	Q11,
	Q12,
	Q13,
	Q14,
	Q15,
	Q16
}
public enum ArtefactType
{
	NONE,
	SOURCE_OF_NILE,
	LIGHTER_UPGRADE,
	SACRED_GROUND,
	CELTIC_CROSS
}
public class BookScript : MonoBehaviour
{
	[Tooltip("The Static Left Page")]
	public GameObject frontPage;

	private Renderer frontPageRenderer;

	[Tooltip("The Left side of the moving Page")]
	public GameObject leftPage;

	private Renderer leftPageRenderer;

	[Tooltip("The Right side of the moving Page")]
	public GameObject rightPage;

	private Renderer rightPageRenderer;

	[Tooltip("The Static Right Page")]
	public GameObject backPage;

	private Renderer backPageRenderer;

	public Material pageTexture;

	public Material tempPageTexture;

	private NotebookPages startPage;

	[SerializeField]
	private AudioClip[] pageTurnSfx;

	[SerializeField]
	private AudioScript audioScript;

	public bool pageTurning;

	private bool pagesOnTheRight = true;

	public int currentPage = 2;

	private int maxPage;

	[Tooltip("Time in seconds notebook to open")]
	public float timeToOpenBook = 0.2f;

	[Tooltip("Time in seconds for pages to turn")]
	public float timeBetweenPages = 0.5f;

	public float backTime = 0.6f;

	public bool isActiveItem;

	public float timeToCancelSetPage = 15f;

	[Tooltip("AdditionUI")]
	public GameObject additionUILighterUpgrade;

	public GameObject additionUIHolyWaterUpgrade;

	public GameObject additionUISaltSprayUpgrade;

	public GameObject additionUICrossUpgrade;

	public GameObject lighterUpgradeObject;

	public GameObject holyWaterUpgradeObject;

	public GameObject saltSprayUpgradeObject;

	public GameObject crossUpgradeObject;

	private bool openAnim;

	private bool showArtefactUI;

	private Material additionalUIToShow;

	private ArtefactType artefactType;

	private Vector2[] pageTiling = new Vector2[16]
	{
		new Vector2(0f, 0f),
		new Vector2(0.25f, 0f),
		new Vector2(0.5f, 0f),
		new Vector2(0.75f, 0f),
		new Vector2(0f, 0.25f),
		new Vector2(0.25f, 0.25f),
		new Vector2(0.5f, 0.25f),
		new Vector2(0.75f, 0.25f),
		new Vector2(0f, 0.5f),
		new Vector2(0.25f, 0.5f),
		new Vector2(0.5f, 0.5f),
		new Vector2(0.75f, 0.5f),
		new Vector2(0f, 0.75f),
		new Vector2(0.25f, 0.75f),
		new Vector2(0.5f, 0.75f),
		new Vector2(0.75f, 0.75f)
	};

	[Space]
	[SerializeField]
	private Texture texOculusQuest;

	private NotebookPages updatePageTo;

	private bool updatePage;

	private bool[] pagesViewed;

	private Vector3 frontPageStartRot;

	private Vector3 leftPageStartRot;

	private Vector3 rightPageStartRot;

	[HideInInspector]
	public bool animating
	{
		get
		{
			if (!openAnim)
			{
				return pageTurning;
			}
			return true;
		}
	}

	private void Start()
	{
		frontPageStartRot = frontPage.transform.localEulerAngles;
		leftPageStartRot = leftPage.transform.localEulerAngles;
		rightPageStartRot = rightPage.transform.localEulerAngles;
		frontPageRenderer = frontPage.GetComponent<Renderer>();
		leftPageRenderer = leftPage.GetComponent<Renderer>();
		rightPageRenderer = rightPage.GetComponent<Renderer>();
		backPageRenderer = backPage.GetComponent<Renderer>();
		pageTexture = leftPageRenderer.sharedMaterial;
		tempPageTexture = rightPageRenderer.sharedMaterial;
		pageTexture.SetTextureOffset("_MainTex", Vector2.zero);
		tempPageTexture.SetTextureOffset("_MainTex", Vector2.zero);
		holyWaterUpgradeObject.SetActive(value: false);
		lighterUpgradeObject.SetActive(value: false);
		Texture texture = GameController.instance.translator.GetTexture(texOculusQuest.name);
		pageTexture.mainTexture = texture ?? texOculusQuest;
		tempPageTexture.mainTexture = texture ?? texOculusQuest;
		if (SaveManager.instance.HasFoundArtifact(ChapterID.CHAPEL) || SaveManager.instance.HasFoundArtifact(ChapterID.CELL) || SaveManager.instance.HasFoundArtifact(ChapterID.NURSERY) || SaveManager.instance.HasFoundArtifact(ChapterID.MORGUE) || SaveManager.instance.HasFoundArtifact(ChapterID.TOMB))
		{
			maxPage = 14;
		}
		else
		{
			maxPage = 12;
		}
		pagesViewed = new bool[maxPage];
		pageTexture.SetTextureOffset("_MainTex", pageTiling[(int)startPage]);
		tempPageTexture.SetTextureOffset("_MainTex", pageTiling[(int)startPage]);
		Material[] sharedMaterials = frontPageRenderer.sharedMaterials;
		sharedMaterials[1] = tempPageTexture;
		frontPageRenderer.sharedMaterials = sharedMaterials;
		sharedMaterials = backPageRenderer.sharedMaterials;
		sharedMaterials[1] = tempPageTexture;
		backPageRenderer.sharedMaterials = sharedMaterials;
	}

	public void SetPage(NotebookPages page)
	{
		UnityEngine.Debug.Log("Setting notebook page to: " + page);
		updatePage = true;
		updatePageTo = page;
		currentPage = (int)page;
		additionUILighterUpgrade.SetActive(value: false);
		additionUIHolyWaterUpgrade.SetActive(value: false);
		additionUISaltSprayUpgrade.SetActive(value: false);
		holyWaterUpgradeObject.SetActive(value: false);
		lighterUpgradeObject.SetActive(value: false);
		saltSprayUpgradeObject.SetActive(value: false);
		additionUICrossUpgrade.SetActive(value: false);
		crossUpgradeObject.SetActive(value: false);
		artefactType = ArtefactType.NONE;
	}

	public void SetPage(NotebookPages page, ArtefactType artefact)
	{
		UnityEngine.Debug.Log("Setting notebook page to: " + page);
		updatePage = true;
		updatePageTo = page;
		currentPage = (int)page;
		showArtefactUI = true;
		artefactType = artefact;
		additionUILighterUpgrade.SetActive(value: false);
		additionUIHolyWaterUpgrade.SetActive(value: false);
		additionUISaltSprayUpgrade.SetActive(value: false);
		holyWaterUpgradeObject.SetActive(value: false);
		lighterUpgradeObject.SetActive(value: false);
		saltSprayUpgradeObject.SetActive(value: false);
		additionUICrossUpgrade.SetActive(value: false);
		crossUpgradeObject.SetActive(value: false);
	}

	public IEnumerator cancelSetPage()
	{
		yield return Yield.WaitSeconds(timeToCancelSetPage);
		updatePage = true;
		updatePageTo = NotebookPages.Q01;
		currentPage = 0;
	}

	private void Update()
	{
		if (updatePage && (bool)pageTexture)
		{
			updatePage = false;
			pageTexture.SetTextureOffset("_MainTex", pageTiling[(int)updatePageTo]);
			tempPageTexture.SetTextureOffset("_MainTex", pageTiling[(int)updatePageTo]);
			Material[] sharedMaterials = frontPageRenderer.sharedMaterials;
			sharedMaterials[1] = tempPageTexture;
			frontPageRenderer.sharedMaterials = sharedMaterials;
			sharedMaterials = backPageRenderer.sharedMaterials;
			sharedMaterials[1] = tempPageTexture;
			backPageRenderer.sharedMaterials = sharedMaterials;
		}
		if (!isActiveItem || openAnim)
		{
			return;
		}
		if (!pageTurning)
		{
			if (ControlsManager.instance.rotateMenuLeftDown)
			{
				TurnLeftPage();
			}
			else if (ControlsManager.instance.rotateMenuRightDown)
			{
				TurnRightPage();
			}
		}
		else if (!LeanTween.isTweening(leftPage) && !LeanTween.isTweening(frontPage) && !LeanTween.isTweening(rightPage) && !LeanTween.isTweening(backPage))
		{
			pageTurning = false;
		}
	}

	private void TurnLeftPage()
	{
		if (currentPage > 0)
		{
			currentPage--;
			rightPageRenderer.sharedMaterial = pageTexture;
			tempPageTexture.mainTextureOffset = pageTiling[currentPage];
			leftPageRenderer.sharedMaterial = tempPageTexture;
			pageTurning = true;
		}
		if (currentPage <= pagesViewed.Length)
		{
			pagesViewed[currentPage] = true;
		}
		if (pageTurning)
		{
			if (pagesOnTheRight)
			{
				LeanTween.rotateAroundLocal(leftPage, Vector3.forward, -135f, 0f);
				LeanTween.rotateAroundLocal(rightPage, Vector3.forward, -135f, 0f);
			}
			int num = UnityEngine.Random.Range(2, pageTurnSfx.Length);
			audioScript.Play(pageTurnSfx[num]);
			LeanTween.rotateAroundLocal(leftPage, Vector3.forward, 135f, timeBetweenPages).setEase(LeanTweenType.easeOutCubic);
			LeanTween.rotateAroundLocal(rightPage, Vector3.forward, 135f, timeBetweenPages).setEase(LeanTweenType.easeOutCubic);
			Material[] sharedMaterials = frontPageRenderer.sharedMaterials;
			sharedMaterials[1] = tempPageTexture;
			frontPageRenderer.sharedMaterials = sharedMaterials;
			pagesOnTheRight = true;
			CheckAchievementStatus();
			StartCoroutine(SwapBackTextures());
		}
	}

	private void TurnRightPage()
	{
		if (currentPage < maxPage)
		{
			currentPage++;
			rightPageRenderer.sharedMaterial = pageTexture;
			tempPageTexture.mainTextureOffset = pageTiling[currentPage];
			leftPageRenderer.sharedMaterial = tempPageTexture;
			pageTurning = true;
		}
		if (currentPage < pagesViewed.Length)
		{
			pagesViewed[currentPage] = true;
		}
		if (pageTurning)
		{
			if (!pagesOnTheRight)
			{
				LeanTween.rotateAroundLocal(leftPage, Vector3.forward, 135f, 0f);
				LeanTween.rotateAroundLocal(rightPage, Vector3.forward, 135f, 0f);
			}
			int num = UnityEngine.Random.Range(2, pageTurnSfx.Length);
			audioScript.Play(pageTurnSfx[num]);
			LeanTween.rotateAroundLocal(leftPage, Vector3.forward, -135f, timeBetweenPages).setEase(LeanTweenType.easeOutCubic);
			LeanTween.rotateAroundLocal(rightPage, Vector3.forward, -135f, timeBetweenPages).setEase(LeanTweenType.easeOutCubic);
			Material[] sharedMaterials = backPageRenderer.sharedMaterials;
			sharedMaterials[1] = tempPageTexture;
			backPageRenderer.sharedMaterials = sharedMaterials;
			pagesOnTheRight = false;
			CheckAchievementStatus();
			StartCoroutine(SwapBackTextures());
		}
	}

	public IEnumerator SwapBackTextures()
	{
		yield return Yield.WaitSeconds(backTime * timeBetweenPages);
		pageTexture.mainTextureOffset = tempPageTexture.mainTextureOffset;
		Material[] sharedMaterials = backPageRenderer.sharedMaterials;
		sharedMaterials[1] = pageTexture;
		backPageRenderer.sharedMaterials = sharedMaterials;
		frontPageRenderer.sharedMaterials = sharedMaterials;
	}

	public void OpenBook()
	{
		UnityEngine.Debug.Log("Opening book on page: " + currentPage);
		if (!openAnim)
		{
			StartCoroutine(Open());
		}
	}

	private IEnumerator Open()
	{
		openAnim = true;
		audioScript.Play(pageTurnSfx[0]);
		LeanTween.rotateAroundLocal(frontPage, Vector3.forward, -135f, timeToOpenBook);
		yield return Yield.WaitSeconds(timeToOpenBook);
		if (artefactType == ArtefactType.LIGHTER_UPGRADE)
		{
			if (lighterUpgradeObject != null)
			{
				additionUIHolyWaterUpgrade.SetActive(value: false);
				holyWaterUpgradeObject.SetActive(value: false);
				additionUILighterUpgrade.SetActive(value: true);
				lighterUpgradeObject.SetActive(value: true);
				additionUISaltSprayUpgrade.SetActive(value: false);
				saltSprayUpgradeObject.SetActive(value: false);
				additionUICrossUpgrade.SetActive(value: false);
				crossUpgradeObject.SetActive(value: false);
			}
		}
		else if (artefactType == ArtefactType.SOURCE_OF_NILE)
		{
			if (holyWaterUpgradeObject != null)
			{
				additionUIHolyWaterUpgrade.SetActive(value: true);
				holyWaterUpgradeObject.SetActive(value: true);
				additionUILighterUpgrade.SetActive(value: false);
				lighterUpgradeObject.SetActive(value: false);
				additionUISaltSprayUpgrade.SetActive(value: false);
				saltSprayUpgradeObject.SetActive(value: false);
				additionUICrossUpgrade.SetActive(value: false);
				crossUpgradeObject.SetActive(value: false);
			}
		}
		else if (artefactType == ArtefactType.SACRED_GROUND)
		{
			if (saltSprayUpgradeObject != null)
			{
				additionUIHolyWaterUpgrade.SetActive(value: false);
				holyWaterUpgradeObject.SetActive(value: false);
				additionUILighterUpgrade.SetActive(value: false);
				lighterUpgradeObject.SetActive(value: false);
				additionUISaltSprayUpgrade.SetActive(value: true);
				saltSprayUpgradeObject.SetActive(value: true);
				additionUICrossUpgrade.SetActive(value: false);
				crossUpgradeObject.SetActive(value: false);
			}
		}
		else if (artefactType == ArtefactType.CELTIC_CROSS && crossUpgradeObject != null)
		{
			additionUIHolyWaterUpgrade.SetActive(value: false);
			holyWaterUpgradeObject.SetActive(value: false);
			additionUILighterUpgrade.SetActive(value: false);
			lighterUpgradeObject.SetActive(value: false);
			additionUISaltSprayUpgrade.SetActive(value: false);
			saltSprayUpgradeObject.SetActive(value: false);
			additionUICrossUpgrade.SetActive(value: true);
			crossUpgradeObject.SetActive(value: true);
		}
		openAnim = false;
	}

	public void CloseBook(bool instantly)
	{
		StopAllCoroutines();
		if (instantly)
		{
			StartCoroutine(Close(0f));
		}
		else
		{
			StartCoroutine(Close(timeToOpenBook));
		}
	}

	private IEnumerator Close(float time)
	{
		LeanTween.cancel(frontPage);
		LeanTween.cancel(leftPage);
		LeanTween.cancel(rightPage);
		pageTurning = false;
		isActiveItem = false;
		openAnim = true;
		audioScript.Play(pageTurnSfx[1]);
		LeanTween.rotateLocal(frontPage, frontPageStartRot, time);
		LeanTween.rotateLocal(leftPage, leftPageStartRot, time);
		LeanTween.rotateLocal(rightPage, rightPageStartRot, time);
		pagesOnTheRight = true;
		additionUIHolyWaterUpgrade.SetActive(value: false);
		holyWaterUpgradeObject.SetActive(value: false);
		additionUILighterUpgrade.SetActive(value: false);
		lighterUpgradeObject.SetActive(value: false);
		additionUISaltSprayUpgrade.SetActive(value: false);
		saltSprayUpgradeObject.SetActive(value: false);
		additionUICrossUpgrade.SetActive(value: false);
		crossUpgradeObject.SetActive(value: false);
		artefactType = ArtefactType.NONE;
		yield return Yield.WaitSeconds(time);
		openAnim = false;
	}

	public void updateMaxPage(int maxPageUpdated)
	{
		UnityEngine.Debug.Log("Updating maz page to: " + maxPageUpdated);
		maxPage = maxPageUpdated;
	}

	public void resetBook()
	{
		maxPage = 12;
	}

	private void CheckAchievementStatus()
	{
		bool flag = true;
		for (int i = 0; i < pagesViewed.Length; i++)
		{
			if (!pagesViewed[i])
			{
				flag = false;
				return;
			}
		}
		if (flag)
		{
			GameController.instance.achievementManager.UnlockAchievement(AchievementID.SCHOLAR);
		}
	}

	public void UpdateTexturesForLanguage()
	{
		Texture texture = GameController.instance.translator.GetTexture(texOculusQuest.name);
		pageTexture.mainTexture = texture ?? texOculusQuest;
		tempPageTexture.mainTexture = texture ?? texOculusQuest;
		Material[] sharedMaterials = frontPageRenderer.sharedMaterials;
		sharedMaterials[1] = tempPageTexture;
		frontPageRenderer.sharedMaterials = sharedMaterials;
		sharedMaterials = backPageRenderer.sharedMaterials;
		sharedMaterials[1] = tempPageTexture;
		backPageRenderer.sharedMaterials = sharedMaterials;
	}
}
public class Buoyancy : MonoBehaviour
{
	public float density = 500f;

	public int slicesPerAxis = 2;

	public bool isConcave;

	public int voxelsLimit = 16;

	public Collider mainCollider;

	public Rigidbody body;

	private const float DAMPFER = 0.1f;

	private const float WATER_DENSITY = 1000f;

	private float voxelHalfHeight;

	private Vector3 localArchimedesForce;

	private List<Vector3> voxels;

	private bool isMeshCollider;

	private List<Vector3[]> forces;

	private void Start()
	{
		forces = new List<Vector3[]>();
		Quaternion rotation = base.transform.rotation;
		Vector3 position = base.transform.position;
		base.transform.rotation = Quaternion.identity;
		base.transform.position = Vector3.zero;
		isMeshCollider = GetComponent<MeshCollider>() != null;
		Bounds bounds = mainCollider.bounds;
		if (bounds.size.x < bounds.size.y)
		{
			voxelHalfHeight = bounds.size.x;
		}
		else
		{
			voxelHalfHeight = bounds.size.y;
		}
		if (bounds.size.z < voxelHalfHeight)
		{
			voxelHalfHeight = bounds.size.z;
		}
		voxelHalfHeight /= 2 * slicesPerAxis;
		if (body == null)
		{
			base.gameObject.AddComponent<Rigidbody>();
			UnityEngine.Debug.LogWarning($"[Buoyancy.cs] Object \"{base.name}\" had no Rigidbody. Rigidbody has been added.");
		}
		body.centerOfMass = new Vector3(0f, (0f - bounds.extents.y) * 0f, 0f) + base.transform.InverseTransformPoint(bounds.center);
		voxels = SliceIntoVoxels(isMeshCollider && isConcave);
		base.transform.rotation = rotation;
		base.transform.position = position;
		float num = body.mass / density;
		WeldPoints(voxels, voxelsLimit);
		float y = 1000f * Mathf.Abs(Physics.gravity.y) * num;
		localArchimedesForce = new Vector3(0f, y, 0f) / voxels.Count;
		UnityEngine.Debug.Log($"[Buoyancy.cs] Name=\"{base.name}\" volume={num:0.0}, mass={body.mass:0.0}, density={density:0.0}");
	}

	private List<Vector3> SliceIntoVoxels(bool concave)
	{
		List<Vector3> list = new List<Vector3>(slicesPerAxis * slicesPerAxis * slicesPerAxis);
		if (concave)
		{
			MeshCollider component = GetComponent<MeshCollider>();
			bool convex = component.convex;
			component.convex = false;
			Bounds bounds = mainCollider.bounds;
			for (int i = 0; i < slicesPerAxis; i++)
			{
				for (int j = 0; j < slicesPerAxis; j++)
				{
					for (int k = 0; k < slicesPerAxis; k++)
					{
						float x = bounds.min.x + bounds.size.x / (float)slicesPerAxis * (0.5f + (float)i);
						float y = bounds.min.y + bounds.size.y / (float)slicesPerAxis * (0.5f + (float)j);
						float z = bounds.min.z + bounds.size.z / (float)slicesPerAxis * (0.5f + (float)k);
						Vector3 vector = base.transform.InverseTransformPoint(new Vector3(x, y, z));
						if (PointIsInsideMeshCollider(component, vector))
						{
							list.Add(vector);
						}
					}
				}
			}
			if (list.Count == 0)
			{
				list.Add(bounds.center);
			}
			component.convex = convex;
		}
		else
		{
			Bounds bounds2 = GetComponent<Collider>().bounds;
			for (int l = 0; l < slicesPerAxis; l++)
			{
				for (int m = 0; m < slicesPerAxis; m++)
				{
					for (int n = 0; n < slicesPerAxis; n++)
					{
						float x2 = bounds2.min.x + bounds2.size.x / (float)slicesPerAxis * (0.5f + (float)l);
						float y2 = bounds2.min.y + bounds2.size.y / (float)slicesPerAxis * (0.5f + (float)m);
						float z2 = bounds2.min.z + bounds2.size.z / (float)slicesPerAxis * (0.5f + (float)n);
						Vector3 item = base.transform.InverseTransformPoint(new Vector3(x2, y2, z2));
						list.Add(item);
					}
				}
			}
		}
		return list;
	}

	private static bool PointIsInsideMeshCollider(Collider c, Vector3 p)
	{
		Vector3[] array = new Vector3[6]
		{
			Vector3.up,
			Vector3.down,
			Vector3.left,
			Vector3.right,
			Vector3.forward,
			Vector3.back
		};
		foreach (Vector3 vector in array)
		{
			if (!c.Raycast(new Ray(p - vector * 1000f, vector), out var _, 1000f))
			{
				return false;
			}
		}
		return true;
	}

	private static void FindClosestPoints(IList<Vector3> list, out int firstIndex, out int secondIndex)
	{
		float num = float.MaxValue;
		float num2 = float.MinValue;
		firstIndex = 0;
		secondIndex = 1;
		for (int i = 0; i < list.Count - 1; i++)
		{
			for (int j = i + 1; j < list.Count; j++)
			{
				float num3 = Vector3.Distance(list[i], list[j]);
				if (num3 < num)
				{
					num = num3;
					firstIndex = i;
					secondIndex = j;
				}
				if (num3 > num2)
				{
					num2 = num3;
				}
			}
		}
	}

	private static void WeldPoints(IList<Vector3> list, int targetCount)
	{
		if (list.Count > 2 && targetCount >= 2)
		{
			while (list.Count > targetCount)
			{
				FindClosestPoints(list, out var firstIndex, out var secondIndex);
				Vector3 item = (list[firstIndex] + list[secondIndex]) * 0.5f;
				list.RemoveAt(secondIndex);
				list.RemoveAt(firstIndex);
				list.Add(item);
			}
		}
	}

	private float GetWaterLevel(float x, float z)
	{
		return 0f;
	}

	private void FixedUpdate()
	{
		forces.Clear();
		foreach (Vector3 voxel in voxels)
		{
			Vector3 vector = base.transform.TransformPoint(voxel);
			float waterLevel = GetWaterLevel(vector.x, vector.z);
			if (vector.y - voxelHalfHeight < waterLevel)
			{
				float num = (waterLevel - vector.y) / (2f * voxelHalfHeight) + 0.5f;
				if (num > 1f)
				{
					num = 1f;
				}
				else if (num < 0f)
				{
					num = 0f;
				}
				Vector3 vector2 = -body.GetPointVelocity(vector) * 0.1f * body.mass + Mathf.Sqrt(num) * localArchimedesForce;
				body.AddForceAtPosition(vector2, vector);
				forces.Add(new Vector3[2] { vector, vector2 });
			}
		}
	}

	private void OnDrawGizmos()
	{
		if (voxels == null || forces == null)
		{
			return;
		}
		Gizmos.color = UnityEngine.Color.yellow;
		foreach (Vector3 voxel in voxels)
		{
			Gizmos.DrawCube(base.transform.TransformPoint(voxel), new Vector3(0.05f, 0.05f, 0.05f));
		}
		Gizmos.color = UnityEngine.Color.cyan;
		foreach (Vector3[] force in forces)
		{
			Gizmos.DrawCube(force[0], new Vector3(0.05f, 0.05f, 0.05f));
			Gizmos.DrawLine(force[0], force[0] + force[1] / body.mass);
		}
	}
}
public class BustArtifact : NVRInteractableRotator
{
	public enum Directions
	{
		NORTH,
		EAST,
		SOUTH,
		WEST
	}

	public Directions[] combination;

	public float timeToRotate;

	private Vector3 originalRotation;

	public AudioClip clickSound;

	public AudioClip wrongCodeSound;

	public AudioClip codeCompleteSound;

	public AudioClip rotatingSound;

	private bool isRotating;

	private bool checkCombination;

	private bool codeComplete;

	private int codeIndex;

	private AudioScript audio;

	private Vector2 lastXZ = Vector2.zero;

	[SerializeField]
	private GameObject colliders;

	public GameObject holyWaterReward;

	protected override void Start()
	{
		base.Start();
		holyWaterReward.SetActive(value: false);
		originalRotation = base.transform.localEulerAngles;
		audio = GetComponent<AudioScript>();
	}

	protected override void FixedUpdate()
	{
		if (codeComplete || LeanTween.isTweening(base.gameObject))
		{
			return;
		}
		if (checkCombination)
		{
			if (CheckCode())
			{
				codeIndex++;
				StartCoroutine(playCorrectSound());
			}
			else
			{
				UnityEngine.Debug.Log("Rotate Back");
				StartCoroutine(playIncorrectSound());
			}
			checkCombination = false;
		}
		if (IsAttached)
		{
			Vector3 worldPosition = new Vector3(base.AttachedHand.transform.position.x, base.transform.position.y, base.AttachedHand.transform.position.z);
			Vector3 eulerAngles = base.transform.eulerAngles;
			base.transform.LookAt(worldPosition);
			base.transform.rotation = Quaternion.Lerp(Quaternion.Euler(eulerAngles), Quaternion.Euler(base.transform.eulerAngles), Time.deltaTime * 2f);
			if (!isRotating)
			{
				audio.m_AudioSource.pitch = 0.8f;
				audio.PlayLoop(rotatingSound, 0.4f);
				isRotating = true;
			}
		}
		if (isRotating && !IsAttached)
		{
			isRotating = false;
			float num = base.gameObject.transform.localEulerAngles.y % 90f;
			if (num < 45f)
			{
				LeanTween.rotateAroundLocal(base.gameObject, Vector3.up, 0f - num, timeToRotate);
			}
			else
			{
				LeanTween.rotateAroundLocal(base.gameObject, Vector3.up, 90f - num, timeToRotate);
			}
			checkCombination = true;
		}
	}

	public override void BeginInteraction(NVRHand hand, bool runBeginInteractionCallback = true)
	{
		Rigidbody.isKinematic = false;
		base.BeginInteraction(hand, runBeginInteractionCallback);
		lastXZ = new Vector2(base.AttachedHand.transform.position.x, base.AttachedHand.transform.position.z);
		HandRendersActive(showHands: false, hand);
	}

	public override void EndInteraction(NVRHand hand)
	{
		base.EndInteraction(hand);
		HandRendersActive(showHands: true, hand);
	}

	public IEnumerator playCorrectSound()
	{
		audio.m_AudioSource.pitch = 1f;
		audio.Play(clickSound);
		yield return Yield.WaitSeconds(0.2f);
		if (codeIndex >= combination.Length)
		{
			codeComplete = true;
			revealArtifact();
		}
	}

	public IEnumerator playIncorrectSound()
	{
		audio.m_AudioSource.pitch = 1f;
		audio.Play(wrongCodeSound);
		codeIndex = 0;
		yield return Yield.WaitSeconds(0.2f);
		RotateToOriginalPosition();
	}

	public void RotateToOriginalPosition()
	{
		StartCoroutine(RotateToOriginalPositionRoutine());
	}

	public IEnumerator RotateToOriginalPositionRoutine()
	{
		yield return Yield.WaitSeconds(0.3f);
		audio.m_AudioSource.pitch = 0.8f;
		audio.PlayLoop(rotatingSound, 0.4f);
		LeanTween.rotateLocal(base.gameObject, originalRotation, timeToRotate);
		yield return Yield.WaitSeconds(timeToRotate);
		audio.StopLoop();
	}

	public bool CheckCode()
	{
		bool result = false;
		switch (combination[codeIndex])
		{
		case Directions.NORTH:
			if (base.gameObject.transform.localEulerAngles.y <= 1f && base.gameObject.transform.localEulerAngles.y >= -1f)
			{
				result = true;
			}
			break;
		case Directions.EAST:
			if (base.gameObject.transform.localEulerAngles.y <= 91f && base.gameObject.transform.localEulerAngles.y >= 89f)
			{
				result = true;
			}
			break;
		case Directions.SOUTH:
			if (base.gameObject.transform.localEulerAngles.y <= 181f && base.gameObject.transform.localEulerAngles.y >= 179f)
			{
				result = true;
			}
			break;
		case Directions.WEST:
			if (base.gameObject.transform.localEulerAngles.y <= 271f && base.gameObject.transform.localEulerAngles.y >= 269f)
			{
				result = true;
			}
			break;
		default:
			UnityEngine.Debug.Log("Error, check directions / degrees");
			break;
		}
		return result;
	}

	public void revealArtifact()
	{
		audio.m_AudioSource.pitch = 1f;
		StartCoroutine(displayArtifact());
	}

	public IEnumerator displayArtifact()
	{
		audio.m_AudioSource.pitch = 1f;
		audio.Play(codeCompleteSound);
		yield return Yield.EndOfFrame;
		NVRInteractableItem script = holyWaterReward.GetComponent<NVRInteractableItem>();
		script.CanAttach = false;
		colliders.SetActive(value: true);
		holyWaterReward.SetActive(value: true);
		EventManager.TriggerEvent(EventManager.AvailableEvents.ArtifactUnlocked.ToString());
		LeanTween.rotateY(base.gameObject, base.gameObject.transform.rotation.y + 720f, 4f);
		LeanTween.moveLocalY(base.gameObject, 1f, 4f);
		yield return Yield.WaitSeconds(4.3f);
		script.CanAttach = true;
		holyWaterReward.transform.parent = null;
		yield return Yield.EndOfFrame;
		UnityEngine.Object.DontDestroyOnLoad(holyWaterReward);
	}

	public void setArtifactRevealed()
	{
		colliders.SetActive(value: true);
		holyWaterReward.SetActive(value: false);
		CanAttach = false;
		LeanTween.rotateY(base.gameObject, base.gameObject.transform.rotation.y + 720f, 0f);
		LeanTween.moveLocalY(base.gameObject, 1f, 4f);
	}

	private void HandRendersActive(bool showHands, NVRHand hand)
	{
		if (!hand.IsPrimary)
		{
			GameController.instance.player.watch.gameObject.SetActive(showHands);
		}
		Renderer[] componentsInChildren = hand.RenderModel.GetComponentsInChildren<Renderer>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].enabled = showHands;
		}
	}
}
public class Campfire : MonoBehaviour
{
	public static string FIRE_TAG = "LightableFire";

	[SerializeField]
	private ParticleSystem flameParticles;

	[SerializeField]
	private Light pointLight;

	[SerializeField]
	private ParticleSystem sparksParticles;

	[SerializeField]
	private Collider triggerCollider;

	[SerializeField]
	private AudioScript audioScript;

	[SerializeField]
	private AudioClip fireStart;

	[SerializeField]
	private AudioClip fireLoop;

	private void Start()
	{
		base.gameObject.tag = FIRE_TAG;
		SetEnabled(enabled: false);
	}

	public void SetEnabled(bool enabled)
	{
		if (enabled)
		{
			StartCoroutine(PlayFireAudio());
		}
		triggerCollider.enabled = !enabled;
		flameParticles.gameObject.SetActive(enabled);
		pointLight.gameObject.SetActive(enabled);
		sparksParticles.gameObject.SetActive(enabled);
	}

	private IEnumerator PlayFireAudio()
	{
		audioScript.PlayOne(fireStart, 0.4f);
		yield return Yield.WaitSeconds(1.2f);
		audioScript.PlayLoop(fireLoop, 0.5f);
	}
}
public class Candle : MonoBehaviour
{
	[SerializeField]
	private LightFlicker lightFlicker;

	[SerializeField]
	private ParticleSystem particles;

	public bool isOn;

	private float elaspedTime;

	private float maxTime = 30f;

	private float fadeTime = 2f;

	private void Start()
	{
		lightFlicker.Fade(on: false, 0f);
		particles.Stop();
	}

	private void Update()
	{
		if (isOn)
		{
			elaspedTime += Time.deltaTime;
			if (elaspedTime > maxTime)
			{
				TurnOff();
			}
		}
	}

	public void TurnOn()
	{
		if (!isOn)
		{
			StartCoroutine(On());
		}
	}

	private IEnumerator On()
	{
		particles.Play();
		lightFlicker.Fade(on: true, fadeTime);
		yield return Yield.WaitSeconds(fadeTime);
		isOn = true;
	}

	public void TurnOff()
	{
		if (isOn)
		{
			StartCoroutine(Off());
		}
	}

	private IEnumerator Off()
	{
		particles.Stop();
		lightFlicker.Fade(on: false, fadeTime);
		yield return Yield.WaitSeconds(fadeTime);
		elaspedTime = 0f;
		isOn = false;
	}
}
public class CandleSet : MonoBehaviour
{
	public static string CANDLE_TAG = "LightableCandle";

	[SerializeField]
	private GameObject[] flames;

	private Vector3[] flameScales;

	[SerializeField]
	private Light pointLight;

	[SerializeField]
	private Collider triggerCollider;

	[SerializeField]
	private Renderer[] candles;

	public Action OnLightCallback;

	private void Start()
	{
		base.gameObject.tag = CANDLE_TAG;
		flameScales = new Vector3[flames.Length];
		for (int i = 0; i < flames.Length; i++)
		{
			flameScales[i] = flames[i].transform.localScale;
		}
		SetEnabled(enabled: true);
	}

	public void SetEnabled(bool enabled)
	{
		triggerCollider.enabled = !enabled;
		pointLight.enabled = enabled;
		for (int i = 0; i < flames.Length; i++)
		{
			if (enabled)
			{
				LeanTween.scale(flames[i], flameScales[i], 0.3f);
			}
			else
			{
				flames[i].transform.localScale = Vector3.zero;
			}
		}
		if (enabled && OnLightCallback != null)
		{
			OnLightCallback();
		}
	}
}
public class CCTVScanlines : MonoBehaviour
{
	[SerializeField]
	private Texture tvScreen;

	[SerializeField]
	private Texture tvScanlines;

	[SerializeField]
	private float speed = 0.1f;

	private bool runningScanlines;

	private Renderer scanlinesRenderer;

	private void Start()
	{
	}

	public void SetScanlines(bool enable)
	{
		if (scanlinesRenderer == null)
		{
			scanlinesRenderer = GetComponent<Renderer>();
		}
		if (enable)
		{
			scanlinesRenderer.sharedMaterial.SetTexture("_MainTex", tvScanlines);
			runningScanlines = true;
		}
		else
		{
			runningScanlines = false;
			scanlinesRenderer.sharedMaterial.SetTexture("_MainTex", tvScreen);
			scanlinesRenderer.sharedMaterial.mainTextureOffset = Vector2.zero;
		}
	}

	private void Update()
	{
		if (runningScanlines)
		{
			if (scanlinesRenderer.sharedMaterial.mainTextureOffset.y >= 0f)
			{
				scanlinesRenderer.sharedMaterial.mainTextureOffset = new Vector2(0f, scanlinesRenderer.sharedMaterial.mainTextureOffset.y - speed * Time.deltaTime);
			}
			else
			{
				scanlinesRenderer.sharedMaterial.mainTextureOffset = new Vector2(0f, 100f);
			}
		}
	}

	private void OnDisable()
	{
		runningScanlines = false;
		scanlinesRenderer.sharedMaterial.SetTexture("_MainTex", tvScreen);
		scanlinesRenderer.sharedMaterial.mainTextureOffset = Vector2.zero;
	}
}
public class CellTileController : MonoBehaviour
{
	public bool wobble;

	[SerializeField]
	private float speed = 1f;

	private Vector3 startPos;

	private Quaternion startRot;

	[SerializeField]
	private float intensity = 2f;

	private void Start()
	{
	}

	public void WobbleFall()
	{
		startPos = base.transform.position;
		startRot = base.transform.rotation;
		float setTime = UnityEngine.Random.Range(0f, 0.1f);
		StartCoroutine(WFall(setTime));
	}

	private IEnumerator WFall(float setTime)
	{
		yield return Yield.WaitSeconds(setTime);
		float yPos = base.gameObject.transform.position.y;
		LeanTween.moveY(base.gameObject, yPos - 0.1f, 0.25f).setEaseOutCirc();
		Vector3 vector = new Vector3(UnityEngine.Random.Range(-30f, 30f), UnityEngine.Random.Range(-30f, 30f), UnityEngine.Random.Range(-30f, 30f));
		LeanTween.rotate(base.gameObject, base.gameObject.transform.eulerAngles + vector, 1.25f);
		yield return Yield.WaitSeconds(0.25f);
		LeanTween.moveY(base.gameObject, yPos - 12f, 1.5f);
	}

	public void Reset()
	{
		_ = startPos;
		_ = startRot;
		base.transform.position = startPos;
		base.transform.rotation = startRot;
	}

	private void Update()
	{
	}
}
public class ChapelChairsC5 : MonoBehaviour
{
	[HideInInspector]
	public bool playedFullChairLiftAnim;

	[SerializeField]
	private GameObject smallChairBreakable;

	[SerializeField]
	private GameObject largeChairBreakable;

	[SerializeField]
	private Rigidbody[] smallChairDebris;

	[SerializeField]
	private Rigidbody[] largeChairDebris;

	[SerializeField]
	private Transform smallChairForcePoint;

	[SerializeField]
	private Transform largeChairForcePoint;

	private void OnEnable()
	{
		smallChairBreakable.SetActive(value: false);
		largeChairBreakable.SetActive(value: false);
	}

	public void SmashSmallChair()
	{
		smallChairBreakable.SetActive(value: true);
		for (int i = 0; i < smallChairDebris.Length; i++)
		{
			smallChairDebris[i].isKinematic = false;
			smallChairDebris[i].AddExplosionForce(140f, smallChairForcePoint.position, 2f);
		}
	}

	public void SmashLargeChair()
	{
		largeChairBreakable.SetActive(value: true);
		for (int i = 0; i < largeChairDebris.Length; i++)
		{
			largeChairDebris[i].isKinematic = false;
			largeChairDebris[i].AddExplosionForce(140f, largeChairForcePoint.position, 2f);
		}
	}

	public void SetChairLiftComplete()
	{
		playedFullChairLiftAnim = true;
	}
}
public enum ChapterStatus
{
	NOT_OWNED,
	OWNED_NOT_PLAYED,
	PLAYED_NOT_COMPLETED,
	COMPLETED
}
public enum ChapterCompletionStatus
{
	BLANK,
	TWENTYFIVC_PERCENT_COMPLETE,
	FIFTY_PERCENT_COMPLETE,
	SEVENTY_FIVE_COMPLETE,
	HUNDRED_PERCENT_COMPLETE
}
public class Chapter
{
	public ChapterID chapterID;

	public ChapterStatus chapterStatus;

	public ChapterCompletionStatus chapterCompletionStatus;

	public bool available;

	public bool started;

	public bool purchased;

	public bool completed;

	public bool artifactComplete;

	public string Description;

	public string FormattedPrice;

	public string Name;

	public string chapterPurchaseId;

	public bool completionCheckmark1;

	public bool completionCheckmark2;

	public bool completionCheckmark3;

	public bool completionCheckmark4;

	public void Initialise()
	{
	}

	public byte[] WriteToBuffer()
	{
		MemoryStream memoryStream = new MemoryStream();
		BinaryWriter binaryWriter = new BinaryWriter(memoryStream);
		binaryWriter.Write((int)chapterID);
		binaryWriter.Write((int)chapterStatus);
		binaryWriter.Write((int)chapterCompletionStatus);
		binaryWriter.Write(available);
		binaryWriter.Write(started);
		binaryWriter.Write(purchased);
		binaryWriter.Write(completed);
		binaryWriter.Write(artifactComplete);
		binaryWriter.Write(Description);
		binaryWriter.Write(FormattedPrice);
		binaryWriter.Write(Name);
		binaryWriter.Write(chapterPurchaseId);
		binaryWriter.Write(completionCheckmark1);
		binaryWriter.Write(completionCheckmark2);
		binaryWriter.Write(completionCheckmark3);
		binaryWriter.Write(completionCheckmark4);
		binaryWriter.Close();
		return memoryStream.GetBuffer();
	}

	public void ReadFromBuffer(byte[] buffer)
	{
		BinaryReader binaryReader = new BinaryReader(new MemoryStream(buffer));
		chapterID = (ChapterID)binaryReader.ReadInt32();
		chapterStatus = (ChapterStatus)binaryReader.ReadInt32();
		chapterCompletionStatus = (ChapterCompletionStatus)binaryReader.ReadInt32();
		available = binaryReader.ReadBoolean();
		started = binaryReader.ReadBoolean();
		purchased = binaryReader.ReadBoolean();
		completed = binaryReader.ReadBoolean();
		artifactComplete = binaryReader.ReadBoolean();
		Description = binaryReader.ReadString();
		FormattedPrice = binaryReader.ReadString();
		Name = binaryReader.ReadString();
		chapterPurchaseId = binaryReader.ReadString();
		completionCheckmark1 = binaryReader.ReadBoolean();
		completionCheckmark2 = binaryReader.ReadBoolean();
		completionCheckmark3 = binaryReader.ReadBoolean();
		completionCheckmark4 = binaryReader.ReadBoolean();
		binaryReader.Close();
	}
}
public class ChapterManager : MonoBehaviour
{
	private GameData savedGameData;

	[SerializeField]
	public UnityEngine.UI.Image[] chapterInteractVisualsLeft;

	[SerializeField]
	public UnityEngine.UI.Image[] chapterInteractVisualsRight;

	[Space]
	[Header("Chapter 1")]
	[SerializeField]
	public GameObject chapter1Button;

	[SerializeField]
	private GameObject chapter1EvidenceNoteboard;

	[SerializeField]
	private GameObject chapter1EvidenceRoom;

	[SerializeField]
	private GameObject chapter1DeskEvidence;

	[SerializeField]
	private GameObject[] chapter1MainCTA;

	[SerializeField]
	private GameObject[] chapter1FileCTA;

	[SerializeField]
	private GameObject[] chapter1FolderCTA;

	[SerializeField]
	private GameObject chapter1Checkmark1;

	[SerializeField]
	private GameObject chapter1Checkmark2;

	[SerializeField]
	private GameObject chapter1Checkmark3;

	[SerializeField]
	private GameObject chapter1Checkmark4;

	[Header("Chapter 2")]
	[SerializeField]
	public GameObject chapter2Button;

	[SerializeField]
	private GameObject chapter2EvidenceNoteboard;

	[SerializeField]
	private GameObject chapter2EvidenceRoom;

	[SerializeField]
	private GameObject chapter2DeskEvidence;

	[SerializeField]
	private GameObject[] chapter2MainCTA;

	[SerializeField]
	private GameObject[] chapter2FileCTA;

	[SerializeField]
	private GameObject[] chapter2FolderCTA;

	[SerializeField]
	private GameObject chapter2Checkmark1;

	[SerializeField]
	private GameObject chapter2Checkmark2;

	[SerializeField]
	private GameObject chapter2Checkmark3;

	[SerializeField]
	private GameObject chapter2Checkmark4;

	[Header("Chapter 3")]
	[SerializeField]
	public GameObject chapter3Button;

	[SerializeField]
	private GameObject chapter3EvidenceNoteboard;

	[SerializeField]
	private GameObject chapter3EvidenceRoom;

	[SerializeField]
	private GameObject chapter3DeskEvidence;

	[SerializeField]
	private GameObject[] chapter3MainCTA;

	[SerializeField]
	private GameObject[] chapter3FileCTA;

	[SerializeField]
	private GameObject[] chapter3FolderCTA;

	[SerializeField]
	private GameObject chapter3Checkmark1;

	[SerializeField]
	private GameObject chapter3Checkmark2;

	[SerializeField]
	private GameObject chapter3Checkmark3;

	[SerializeField]
	private GameObject chapter3Checkmark4;

	[Header("Chapter 4")]
	[SerializeField]
	public GameObject chapter4Button;

	[SerializeField]
	private GameObject chapter4EvidenceNoteboard;

	[SerializeField]
	private GameObject chapter4EvidenceRoom;

	[SerializeField]
	private GameObject chapter4DeskEvidence;

	[SerializeField]
	private GameObject[] chapter4MainCTA;

	[SerializeField]
	private GameObject[] chapter4FileCTA;

	[SerializeField]
	private GameObject[] chapter4FolderCTA;

	[SerializeField]
	private GameObject chapter4Checkmark1;

	[SerializeField]
	private GameObject chapter4Checkmark2;

	[SerializeField]
	private GameObject chapter4Checkmark3;

	[SerializeField]
	private GameObject chapter4Checkmark4;

	[Header("Chapter 5")]
	[SerializeField]
	public GameObject chapter5Button;

	[SerializeField]
	private GameObject chapter5EvidenceNoteboard;

	[SerializeField]
	private GameObject chapter5EvidenceRoom;

	[SerializeField]
	private GameObject chapter5DeskEvidence;

	[SerializeField]
	private GameObject[] chapter5MainCTA;

	[SerializeField]
	private GameObject[] chapter5FileCTA;

	[SerializeField]
	private GameObject[] chapter5FolderCTA;

	[SerializeField]
	private GameObject chapter5Checkmark1;

	[SerializeField]
	private GameObject chapter5Checkmark2;

	[SerializeField]
	private GameObject chapter5Checkmark3;

	[SerializeField]
	private GameObject chapter5Checkmark4;

	[Header("Hint Items")]
	public NVRInteractableItem Chapter1Hint;

	public NVRInteractableItem Chapter2Hint;

	public NVRInteractableItem Chapter3Hint;

	public NVRInteractableItem Chapter4Hint;

	public NVRInteractableItem Chapter5Hint;

	private Chapter previousChapter;

	private void Start()
	{
		StartCoroutine(StartRoutine());
	}

	private IEnumerator StartRoutine()
	{
		while (!SaveManager.instance.savedDataLoaded)
		{
			yield return Yield.WaitSeconds(1f);
		}
		ReloadChapterData();
	}

	public void ReloadChapterData()
	{
		UpdateChapterDisplay();
	}

	private void UpdateChapterDisplay()
	{
		savedGameData = SaveManager.instance.GetCurrentGameData();
		Chapter[] gameChapters = savedGameData.gameChapters;
		foreach (Chapter chapter in gameChapters)
		{
			if (chapter == null)
			{
				continue;
			}
			switch (chapter.chapterID)
			{
			case ChapterID.CHAPEL:
				if (chapter.chapterStatus == ChapterStatus.NOT_OWNED)
				{
					if (chapter1EvidenceNoteboard != null)
					{
						chapter1EvidenceNoteboard.SetActive(value: false);
					}
					if (chapter1EvidenceRoom != null)
					{
						chapter1EvidenceRoom.SetActive(value: false);
					}
					if (chapter1DeskEvidence != null)
					{
						chapter1DeskEvidence.SetActive(value: true);
					}
					chapter1MainCTA[0].SetActive(value: true);
					chapter1MainCTA[1].SetActive(value: false);
					chapter1MainCTA[2].SetActive(value: false);
					chapter1FileCTA[0].SetActive(value: true);
					chapter1FileCTA[1].SetActive(value: false);
					chapter1FileCTA[2].SetActive(value: false);
					chapter1FileCTA[3].SetActive(value: false);
					chapter1FolderCTA[0].SetActive(value: true);
					chapter1FolderCTA[1].SetActive(value: false);
					chapter1FolderCTA[2].SetActive(value: false);
					chapter1FolderCTA[3].SetActive(value: false);
					chapter1FolderCTA[4].SetActive(value: false);
					chapter1Checkmark1.SetActive(value: false);
					chapter1Checkmark2.SetActive(value: false);
					chapter1Checkmark3.SetActive(value: false);
					chapter1Checkmark4.SetActive(value: false);
				}
				else if (chapter.chapterStatus == ChapterStatus.OWNED_NOT_PLAYED)
				{
					if (chapter1EvidenceNoteboard != null)
					{
						chapter1EvidenceNoteboard.SetActive(value: false);
					}
					if (chapter1EvidenceRoom != null)
					{
						chapter1EvidenceRoom.SetActive(value: false);
					}
					if (chapter1DeskEvidence != null)
					{
						chapter1DeskEvidence.SetActive(value: true);
					}
					chapter1MainCTA[0].SetActive(value: false);
					chapter1MainCTA[1].SetActive(value: true);
					chapter1MainCTA[2].SetActive(value: false);
					chapter1FileCTA[0].SetActive(value: false);
					chapter1FileCTA[1].SetActive(value: true);
					chapter1FileCTA[2].SetActive(value: false);
					chapter1FileCTA[3].SetActive(value: false);
					chapter1FolderCTA[0].SetActive(value: true);
					chapter1FolderCTA[1].SetActive(value: false);
					chapter1FolderCTA[2].SetActive(value: false);
					chapter1FolderCTA[3].SetActive(value: false);
					chapter1FolderCTA[4].SetActive(value: false);
					chapter1Checkmark1.SetActive(value: false);
					chapter1Checkmark2.SetActive(value: false);
					chapter1Checkmark3.SetActive(value: false);
					chapter1Checkmark4.SetActive(value: false);
				}
				else if (chapter.chapterStatus == ChapterStatus.PLAYED_NOT_COMPLETED)
				{
					if (chapter1EvidenceNoteboard != null)
					{
						chapter1EvidenceNoteboard.SetActive(value: true);
					}
					if (chapter1EvidenceRoom != null)
					{
						chapter1EvidenceRoom.SetActive(value: true);
					}
					if (chapter1DeskEvidence != null)
					{
						chapter1DeskEvidence.SetActive(value: true);
					}
					chapter1MainCTA[0].SetActive(value: false);
					chapter1MainCTA[1].SetActive(value: false);
					chapter1MainCTA[2].SetActive(value: true);
					chapter1FileCTA[0].SetActive(value: false);
					chapter1FileCTA[1].SetActive(value: false);
					chapter1FileCTA[2].SetActive(value: true);
					chapter1FileCTA[3].SetActive(value: false);
					chapter1FolderCTA[0].SetActive(value: true);
					chapter1FolderCTA[1].SetActive(value: false);
					chapter1FolderCTA[2].SetActive(value: false);
					chapter1FolderCTA[3].SetActive(value: false);
					chapter1FolderCTA[4].SetActive(value: false);
					chapter1Checkmark1.SetActive(value: false);
					chapter1Checkmark2.SetActive(value: false);
					chapter1Checkmark3.SetActive(value: false);
					chapter1Checkmark4.SetActive(value: false);
				}
				else if (chapter.chapterStatus == ChapterStatus.COMPLETED)
				{
					if (chapter1EvidenceNoteboard != null)
					{
						chapter1EvidenceNoteboard.SetActive(value: true);
					}
					if (chapter1EvidenceRoom != null)
					{
						chapter1EvidenceRoom.SetActive(value: true);
					}
					if (chapter1DeskEvidence != null)
					{
						chapter1DeskEvidence.SetActive(value: true);
					}
					chapter1MainCTA[0].SetActive(value: false);
					chapter1MainCTA[1].SetActive(value: false);
					chapter1MainCTA[2].SetActive(value: true);
					chapter1FileCTA[0].SetActive(value: false);
					chapter1FileCTA[1].SetActive(value: false);
					chapter1FileCTA[2].SetActive(value: false);
					chapter1FileCTA[3].SetActive(value: true);
					if (chapter.chapterCompletionStatus == ChapterCompletionStatus.TWENTYFIVC_PERCENT_COMPLETE)
					{
						chapter1FolderCTA[0].SetActive(value: false);
						chapter1FolderCTA[1].SetActive(value: true);
						chapter1FolderCTA[2].SetActive(value: false);
						chapter1FolderCTA[3].SetActive(value: false);
						chapter1FolderCTA[4].SetActive(value: false);
					}
					else if (chapter.chapterCompletionStatus == ChapterCompletionStatus.FIFTY_PERCENT_COMPLETE)
					{
						chapter1FolderCTA[0].SetActive(value: false);
						chapter1FolderCTA[1].SetActive(value: false);
						chapter1FolderCTA[2].SetActive(value: true);
						chapter1FolderCTA[3].SetActive(value: false);
						chapter1FolderCTA[4].SetActive(value: false);
					}
					else if (chapter.chapterCompletionStatus == ChapterCompletionStatus.SEVENTY_FIVE_COMPLETE)
					{
						chapter1FolderCTA[0].SetActive(value: false);
						chapter1FolderCTA[1].SetActive(value: false);
						chapter1FolderCTA[2].SetActive(value: false);
						chapter1FolderCTA[3].SetActive(value: true);
						chapter1FolderCTA[4].SetActive(value: false);
					}
					else if (chapter.chapterCompletionStatus == ChapterCompletionStatus.HUNDRED_PERCENT_COMPLETE)
					{
						chapter1FolderCTA[0].SetActive(value: false);
						chapter1FolderCTA[1].SetActive(value: false);
						chapter1FolderCTA[2].SetActive(value: false);
						chapter1FolderCTA[3].SetActive(value: false);
						chapter1FolderCTA[4].SetActive(value: true);
					}
					else
					{
						chapter1FolderCTA[0].SetActive(value: true);
						chapter1FolderCTA[1].SetActive(value: false);
						chapter1FolderCTA[2].SetActive(value: false);
						chapter1FolderCTA[3].SetActive(value: false);
						chapter1FolderCTA[4].SetActive(value: false);
					}
					chapter1Checkmark1.SetActive(chapter.completionCheckmark1);
					chapter1Checkmark2.SetActive(chapter.completionCheckmark2);
					chapter1Checkmark3.SetActive(chapter.completionCheckmark3);
					chapter1Checkmark4.SetActive(chapter.completionCheckmark4);
				}
				break;
			case ChapterID.CELL:
				if (chapter.chapterStatus == ChapterStatus.NOT_OWNED)
				{
					if (chapter2EvidenceNoteboard != null)
					{
						chapter2EvidenceNoteboard.SetActive(value: false);
					}
					if (chapter2EvidenceRoom != null)
					{
						chapter2EvidenceRoom.SetActive(value: false);
					}
					if (chapter2DeskEvidence != null)
					{
						chapter2DeskEvidence.SetActive(value: false);
					}
					chapter2MainCTA[0].SetActive(value: true);
					chapter2MainCTA[1].SetActive(value: false);
					chapter2MainCTA[2].SetActive(value: false);
					chapter2FileCTA[0].SetActive(value: true);
					chapter2FileCTA[1].SetActive(value: false);
					chapter2FileCTA[2].SetActive(value: false);
					chapter2FileCTA[3].SetActive(value: false);
					chapter2FolderCTA[0].SetActive(value: true);
					chapter2FolderCTA[1].SetActive(value: false);
					chapter2FolderCTA[2].SetActive(value: false);
					chapter2FolderCTA[3].SetActive(value: false);
					chapter2FolderCTA[4].SetActive(value: false);
					chapter2Checkmark1.SetActive(value: false);
					chapter2Checkmark2.SetActive(value: false);
					chapter2Checkmark3.SetActive(value: false);
					chapter2Checkmark4.SetActive(value: false);
				}
				else if (chapter.chapterStatus == ChapterStatus.OWNED_NOT_PLAYED)
				{
					if (chapter2EvidenceNoteboard != null)
					{
						chapter2EvidenceNoteboard.SetActive(value: false);
					}
					if (chapter2EvidenceRoom != null)
					{
						chapter2EvidenceRoom.SetActive(value: false);
					}
					if (chapter2DeskEvidence != null)
					{
						chapter2DeskEvidence.SetActive(value: false);
					}
					chapter2MainCTA[0].SetActive(value: false);
					chapter2MainCTA[1].SetActive(value: true);
					chapter2MainCTA[2].SetActive(value: false);
					chapter2FileCTA[0].SetActive(value: false);
					chapter2FileCTA[1].SetActive(value: true);
					chapter2FileCTA[2].SetActive(value: false);
					chapter2FileCTA[3].SetActive(value: false);
					chapter2FolderCTA[0].SetActive(value: true);
					chapter2FolderCTA[1].SetActive(value: false);
					chapter2FolderCTA[2].SetActive(value: false);
					chapter2FolderCTA[3].SetActive(value: false);
					chapter2FolderCTA[4].SetActive(value: false);
					chapter2Checkmark1.SetActive(value: false);
					chapter2Checkmark2.SetActive(value: false);
					chapter2Checkmark3.SetActive(value: false);
					chapter2Checkmark4.SetActive(value: false);
				}
				else if (chapter.chapterStatus == ChapterStatus.PLAYED_NOT_COMPLETED)
				{
					if (chapter2EvidenceNoteboard != null)
					{
						chapter2EvidenceNoteboard.SetActive(value: true);
					}
					if (chapter2EvidenceRoom != null)
					{
						chapter2EvidenceRoom.SetActive(value: true);
					}
					if (chapter2DeskEvidence != null)
					{
						chapter2DeskEvidence.SetActive(value: false);
					}
					chapter2MainCTA[0].SetActive(value: false);
					chapter2MainCTA[1].SetActive(value: false);
					chapter2MainCTA[2].SetActive(value: true);
					chapter2FileCTA[0].SetActive(value: false);
					chapter2FileCTA[1].SetActive(value: false);
					chapter2FileCTA[2].SetActive(value: true);
					chapter2FileCTA[3].SetActive(value: false);
					chapter2FolderCTA[0].SetActive(value: true);
					chapter2FolderCTA[1].SetActive(value: false);
					chapter2FolderCTA[2].SetActive(value: false);
					chapter2FolderCTA[3].SetActive(value: false);
					chapter2FolderCTA[4].SetActive(value: false);
					chapter2Checkmark1.SetActive(value: false);
					chapter2Checkmark2.SetActive(value: false);
					chapter2Checkmark3.SetActive(value: false);
					chapter2Checkmark4.SetActive(value: false);
				}
				else if (chapter.chapterStatus == ChapterStatus.COMPLETED)
				{
					if (chapter2EvidenceNoteboard != null)
					{
						chapter2EvidenceNoteboard.SetActive(value: true);
					}
					if (chapter2EvidenceRoom != null)
					{
						chapter2EvidenceRoom.SetActive(value: true);
					}
					if (chapter2DeskEvidence != null)
					{
						chapter2DeskEvidence.SetActive(value: false);
					}
					chapter2MainCTA[0].SetActive(value: false);
					chapter2MainCTA[1].SetActive(value: false);
					chapter2MainCTA[2].SetActive(value: true);
					chapter2FileCTA[0].SetActive(value: false);
					chapter2FileCTA[1].SetActive(value: false);
					chapter2FileCTA[2].SetActive(value: false);
					chapter2FileCTA[3].SetActive(value: true);
					if (chapter.chapterCompletionStatus == ChapterCompletionStatus.TWENTYFIVC_PERCENT_COMPLETE)
					{
						chapter2FolderCTA[0].SetActive(value: false);
						chapter2FolderCTA[1].SetActive(value: true);
						chapter2FolderCTA[2].SetActive(value: false);
						chapter2FolderCTA[3].SetActive(value: false);
						chapter2FolderCTA[4].SetActive(value: false);
					}
					else if (chapter.chapterCompletionStatus == ChapterCompletionStatus.FIFTY_PERCENT_COMPLETE)
					{
						chapter2FolderCTA[0].SetActive(value: false);
						chapter2FolderCTA[1].SetActive(value: false);
						chapter2FolderCTA[2].SetActive(value: true);
						chapter2FolderCTA[3].SetActive(value: false);
						chapter2FolderCTA[4].SetActive(value: false);
					}
					else if (chapter.chapterCompletionStatus == ChapterCompletionStatus.SEVENTY_FIVE_COMPLETE)
					{
						chapter2FolderCTA[0].SetActive(value: false);
						chapter2FolderCTA[1].SetActive(value: false);
						chapter2FolderCTA[2].SetActive(value: false);
						chapter2FolderCTA[3].SetActive(value: true);
						chapter2FolderCTA[4].SetActive(value: false);
					}
					else if (chapter.chapterCompletionStatus == ChapterCompletionStatus.HUNDRED_PERCENT_COMPLETE)
					{
						chapter2FolderCTA[0].SetActive(value: false);
						chapter2FolderCTA[1].SetActive(value: false);
						chapter2FolderCTA[2].SetActive(value: false);
						chapter2FolderCTA[3].SetActive(value: false);
						chapter2FolderCTA[4].SetActive(value: true);
					}
					else
					{
						chapter2FolderCTA[0].SetActive(value: true);
						chapter2FolderCTA[1].SetActive(value: false);
						chapter2FolderCTA[2].SetActive(value: false);
						chapter2FolderCTA[3].SetActive(value: false);
						chapter2FolderCTA[4].SetActive(value: false);
					}
					chapter2Checkmark1.SetActive(chapter.completionCheckmark1);
					chapter2Checkmark2.SetActive(chapter.completionCheckmark2);
					chapter2Checkmark3.SetActive(chapter.completionCheckmark3);
					chapter2Checkmark4.SetActive(chapter.completionCheckmark4);
				}
				break;
			case ChapterID.NURSERY:
				if (chapter.chapterStatus == ChapterStatus.NOT_OWNED)
				{
					if (chapter3EvidenceNoteboard != null)
					{
						chapter3EvidenceNoteboard.SetActive(value: false);
					}
					if (chapter3EvidenceRoom != null)
					{
						chapter3EvidenceRoom.SetActive(value: false);
					}
					if (chapter3DeskEvidence != null)
					{
						chapter3DeskEvidence.SetActive(value: false);
					}
					chapter3MainCTA[0].SetActive(value: true);
					chapter3MainCTA[1].SetActive(value: false);
					chapter3MainCTA[2].SetActive(value: false);
					chapter3FileCTA[0].SetActive(value: true);
					chapter3FileCTA[1].SetActive(value: false);
					chapter3FileCTA[2].SetActive(value: false);
					chapter3FileCTA[3].SetActive(value: false);
					chapter3FolderCTA[0].SetActive(value: true);
					chapter3FolderCTA[1].SetActive(value: false);
					chapter3FolderCTA[2].SetActive(value: false);
					chapter3FolderCTA[3].SetActive(value: false);
					chapter3FolderCTA[4].SetActive(value: false);
					chapter3Checkmark1.SetActive(value: false);
					chapter3Checkmark2.SetActive(value: false);
					chapter3Checkmark3.SetActive(value: false);
					chapter3Checkmark4.SetActive(value: false);
				}
				else if (chapter.chapterStatus == ChapterStatus.OWNED_NOT_PLAYED)
				{
					if (chapter3EvidenceNoteboard != null)
					{
						chapter3EvidenceNoteboard.SetActive(value: false);
					}
					if (chapter3EvidenceRoom != null)
					{
						chapter3EvidenceRoom.SetActive(value: false);
					}
					if (chapter3DeskEvidence != null)
					{
						chapter3DeskEvidence.SetActive(value: false);
					}
					chapter3MainCTA[0].SetActive(value: false);
					chapter3MainCTA[1].SetActive(value: true);
					chapter3MainCTA[2].SetActive(value: false);
					chapter3FileCTA[0].SetActive(value: false);
					chapter3FileCTA[1].SetActive(value: true);
					chapter3FileCTA[2].SetActive(value: false);
					chapter3FileCTA[3].SetActive(value: false);
					chapter3FolderCTA[0].SetActive(value: true);
					chapter3FolderCTA[1].SetActive(value: false);
					chapter3FolderCTA[2].SetActive(value: false);
					chapter3FolderCTA[3].SetActive(value: false);
					chapter3FolderCTA[4].SetActive(value: false);
					chapter3Checkmark1.SetActive(value: false);
					chapter3Checkmark2.SetActive(value: false);
					chapter3Checkmark3.SetActive(value: false);
					chapter3Checkmark4.SetActive(value: false);
				}
				else if (chapter.chapterStatus == ChapterStatus.PLAYED_NOT_COMPLETED)
				{
					if (chapter3EvidenceNoteboard != null)
					{
						chapter3EvidenceNoteboard.SetActive(value: true);
					}
					if (chapter3EvidenceRoom != null)
					{
						chapter3EvidenceRoom.SetActive(value: true);
					}
					if (chapter3DeskEvidence != null)
					{
						chapter3DeskEvidence.SetActive(value: false);
					}
					chapter3MainCTA[0].SetActive(value: false);
					chapter3MainCTA[1].SetActive(value: false);
					chapter3MainCTA[2].SetActive(value: true);
					chapter3FileCTA[0].SetActive(value: false);
					chapter3FileCTA[1].SetActive(value: false);
					chapter3FileCTA[2].SetActive(value: true);
					chapter3FileCTA[3].SetActive(value: false);
					chapter3FolderCTA[0].SetActive(value: true);
					chapter3FolderCTA[1].SetActive(value: false);
					chapter3FolderCTA[2].SetActive(value: false);
					chapter3FolderCTA[3].SetActive(value: false);
					chapter3FolderCTA[4].SetActive(value: false);
					chapter3Checkmark1.SetActive(value: false);
					chapter3Checkmark2.SetActive(value: false);
					chapter3Checkmark3.SetActive(value: false);
					chapter3Checkmark4.SetActive(value: false);
				}
				else if (chapter.chapterStatus == ChapterStatus.COMPLETED)
				{
					if (chapter3EvidenceNoteboard != null)
					{
						chapter3EvidenceNoteboard.SetActive(value: true);
					}
					if (chapter3EvidenceRoom != null)
					{
						chapter3EvidenceRoom.SetActive(value: true);
					}
					if (chapter3DeskEvidence != null)
					{
						chapter3DeskEvidence.SetActive(value: false);
					}
					chapter3MainCTA[0].SetActive(value: false);
					chapter3MainCTA[1].SetActive(value: false);
					chapter3MainCTA[2].SetActive(value: true);
					chapter3FileCTA[0].SetActive(value: false);
					chapter3FileCTA[1].SetActive(value: false);
					chapter3FileCTA[2].SetActive(value: false);
					chapter3FileCTA[3].SetActive(value: true);
					if (chapter.chapterCompletionStatus == ChapterCompletionStatus.TWENTYFIVC_PERCENT_COMPLETE)
					{
						chapter3FolderCTA[0].SetActive(value: false);
						chapter3FolderCTA[1].SetActive(value: true);
						chapter3FolderCTA[2].SetActive(value: false);
						chapter3FolderCTA[3].SetActive(value: false);
						chapter3FolderCTA[4].SetActive(value: false);
					}
					else if (chapter.chapterCompletionStatus == ChapterCompletionStatus.FIFTY_PERCENT_COMPLETE)
					{
						chapter3FolderCTA[0].SetActive(value: false);
						chapter3FolderCTA[1].SetActive(value: false);
						chapter3FolderCTA[2].SetActive(value: true);
						chapter3FolderCTA[3].SetActive(value: false);
						chapter3FolderCTA[4].SetActive(value: false);
					}
					else if (chapter.chapterCompletionStatus == ChapterCompletionStatus.SEVENTY_FIVE_COMPLETE)
					{
						chapter3FolderCTA[0].SetActive(value: false);
						chapter3FolderCTA[1].SetActive(value: false);
						chapter3FolderCTA[2].SetActive(value: false);
						chapter3FolderCTA[3].SetActive(value: true);
						chapter3FolderCTA[4].SetActive(value: false);
					}
					else if (chapter.chapterCompletionStatus == ChapterCompletionStatus.HUNDRED_PERCENT_COMPLETE)
					{
						chapter3FolderCTA[0].SetActive(value: false);
						chapter3FolderCTA[1].SetActive(value: false);
						chapter3FolderCTA[2].SetActive(value: false);
						chapter3FolderCTA[3].SetActive(value: false);
						chapter3FolderCTA[4].SetActive(value: true);
					}
					else
					{
						chapter3FolderCTA[0].SetActive(value: true);
						chapter3FolderCTA[1].SetActive(value: false);
						chapter3FolderCTA[2].SetActive(value: false);
						chapter3FolderCTA[3].SetActive(value: false);
						chapter3FolderCTA[4].SetActive(value: false);
					}
					chapter3Checkmark1.SetActive(chapter.completionCheckmark1);
					chapter3Checkmark2.SetActive(chapter.completionCheckmark2);
					chapter3Checkmark3.SetActive(chapter.completionCheckmark3);
					chapter3Checkmark4.SetActive(chapter.completionCheckmark4);
				}
				break;
			case ChapterID.MORGUE:
				if (chapter.chapterStatus == ChapterStatus.NOT_OWNED)
				{
					if (chapter4EvidenceNoteboard != null)
					{
						chapter4EvidenceNoteboard.SetActive(value: false);
					}
					if (chapter4EvidenceRoom != null)
					{
						chapter4EvidenceRoom.SetActive(value: false);
					}
					if (chapter4DeskEvidence != null)
					{
						chapter4DeskEvidence.SetActive(value: false);
					}
					chapter4MainCTA[0].SetActive(value: true);
					chapter4MainCTA[1].SetActive(value: false);
					chapter4MainCTA[2].SetActive(value: false);
					chapter4FileCTA[0].SetActive(value: true);
					chapter4FileCTA[1].SetActive(value: false);
					chapter4FileCTA[2].SetActive(value: false);
					chapter4FileCTA[3].SetActive(value: false);
					chapter4FolderCTA[0].SetActive(value: true);
					chapter4FolderCTA[1].SetActive(value: false);
					chapter4FolderCTA[2].SetActive(value: false);
					chapter4FolderCTA[3].SetActive(value: false);
					chapter4FolderCTA[4].SetActive(value: false);
					chapter4Checkmark1.SetActive(value: false);
					chapter4Checkmark2.SetActive(value: false);
					chapter4Checkmark3.SetActive(value: false);
					chapter4Checkmark4.SetActive(value: false);
				}
				else if (chapter.chapterStatus == ChapterStatus.OWNED_NOT_PLAYED)
				{
					if (chapter4EvidenceNoteboard != null)
					{
						chapter4EvidenceNoteboard.SetActive(value: false);
					}
					if (chapter4EvidenceRoom != null)
					{
						chapter4EvidenceRoom.SetActive(value: false);
					}
					if (chapter4DeskEvidence != null)
					{
						chapter4DeskEvidence.SetActive(value: false);
					}
					chapter4MainCTA[0].SetActive(value: false);
					chapter4MainCTA[1].SetActive(value: true);
					chapter4MainCTA[2].SetActive(value: false);
					chapter4FileCTA[0].SetActive(value: false);
					chapter4FileCTA[1].SetActive(value: true);
					chapter4FileCTA[2].SetActive(value: false);
					chapter4FileCTA[3].SetActive(value: false);
					chapter4FolderCTA[0].SetActive(value: true);
					chapter4FolderCTA[1].SetActive(value: false);
					chapter4FolderCTA[2].SetActive(value: false);
					chapter4FolderCTA[3].SetActive(value: false);
					chapter4FolderCTA[4].SetActive(value: false);
					chapter4Checkmark1.SetActive(value: false);
					chapter4Checkmark2.SetActive(value: false);
					chapter4Checkmark3.SetActive(value: false);
					chapter4Checkmark4.SetActive(value: false);
				}
				else if (chapter.chapterStatus == ChapterStatus.PLAYED_NOT_COMPLETED)
				{
					if (chapter4EvidenceNoteboard != null)
					{
						chapter4EvidenceNoteboard.SetActive(value: true);
					}
					if (chapter4EvidenceRoom != null)
					{
						chapter4EvidenceRoom.SetActive(value: true);
					}
					if (chapter4DeskEvidence != null)
					{
						chapter4DeskEvidence.SetActive(value: false);
					}
					chapter4MainCTA[0].SetActive(value: false);
					chapter4MainCTA[1].SetActive(value: false);
					chapter4MainCTA[2].SetActive(value: true);
					chapter4FileCTA[0].SetActive(value: false);
					chapter4FileCTA[1].SetActive(value: false);
					chapter4FileCTA[2].SetActive(value: true);
					chapter4FileCTA[3].SetActive(value: false);
					chapter4FolderCTA[0].SetActive(value: true);
					chapter4FolderCTA[1].SetActive(value: false);
					chapter4FolderCTA[2].SetActive(value: false);
					chapter4FolderCTA[3].SetActive(value: false);
					chapter4FolderCTA[4].SetActive(value: false);
					chapter4Checkmark1.SetActive(value: false);
					chapter4Checkmark2.SetActive(value: false);
					chapter4Checkmark3.SetActive(value: false);
					chapter4Checkmark4.SetActive(value: false);
				}
				else if (chapter.chapterStatus == ChapterStatus.COMPLETED)
				{
					if (chapter4EvidenceNoteboard != null)
					{
						chapter4EvidenceNoteboard.SetActive(value: true);
					}
					if (chapter4EvidenceRoom != null)
					{
						chapter4EvidenceRoom.SetActive(value: true);
					}
					if (chapter4DeskEvidence != null)
					{
						chapter4DeskEvidence.SetActive(value: false);
					}
					chapter4MainCTA[0].SetActive(value: false);
					chapter4MainCTA[1].SetActive(value: false);
					chapter4MainCTA[2].SetActive(value: true);
					chapter4FileCTA[0].SetActive(value: false);
					chapter4FileCTA[1].SetActive(value: false);
					chapter4FileCTA[2].SetActive(value: false);
					chapter4FileCTA[3].SetActive(value: true);
					if (chapter.chapterCompletionStatus == ChapterCompletionStatus.TWENTYFIVC_PERCENT_COMPLETE)
					{
						chapter4FolderCTA[0].SetActive(value: false);
						chapter4FolderCTA[1].SetActive(value: true);
						chapter4FolderCTA[2].SetActive(value: false);
						chapter4FolderCTA[3].SetActive(value: false);
						chapter4FolderCTA[4].SetActive(value: false);
					}
					else if (chapter.chapterCompletionStatus == ChapterCompletionStatus.FIFTY_PERCENT_COMPLETE)
					{
						chapter4FolderCTA[0].SetActive(value: false);
						chapter4FolderCTA[1].SetActive(value: false);
						chapter4FolderCTA[2].SetActive(value: true);
						chapter4FolderCTA[3].SetActive(value: false);
						chapter4FolderCTA[4].SetActive(value: false);
					}
					else if (chapter.chapterCompletionStatus == ChapterCompletionStatus.SEVENTY_FIVE_COMPLETE)
					{
						chapter4FolderCTA[0].SetActive(value: false);
						chapter4FolderCTA[1].SetActive(value: false);
						chapter4FolderCTA[2].SetActive(value: false);
						chapter4FolderCTA[3].SetActive(value: true);
						chapter4FolderCTA[4].SetActive(value: false);
					}
					else if (chapter.chapterCompletionStatus == ChapterCompletionStatus.HUNDRED_PERCENT_COMPLETE)
					{
						chapter4FolderCTA[0].SetActive(value: false);
						chapter4FolderCTA[1].SetActive(value: false);
						chapter4FolderCTA[2].SetActive(value: false);
						chapter4FolderCTA[3].SetActive(value: false);
						chapter4FolderCTA[4].SetActive(value: true);
					}
					else
					{
						chapter4FolderCTA[0].SetActive(value: true);
						chapter4FolderCTA[1].SetActive(value: false);
						chapter4FolderCTA[2].SetActive(value: false);
						chapter4FolderCTA[3].SetActive(value: false);
						chapter4FolderCTA[4].SetActive(value: false);
					}
					chapter4Checkmark1.SetActive(chapter.completionCheckmark1);
					chapter4Checkmark2.SetActive(chapter.completionCheckmark2);
					chapter4Checkmark3.SetActive(chapter.completionCheckmark3);
					chapter4Checkmark4.SetActive(chapter.completionCheckmark4);
				}
				break;
			case ChapterID.TOMB:
				if (chapter.chapterStatus == ChapterStatus.NOT_OWNED)
				{
					if (chapter5EvidenceNoteboard != null)
					{
						chapter5EvidenceNoteboard.SetActive(value: false);
					}
					if (chapter5EvidenceRoom != null)
					{
						chapter5EvidenceRoom.SetActive(value: false);
					}
					if (chapter5DeskEvidence != null)
					{
						chapter5DeskEvidence.SetActive(value: false);
					}
					chapter5MainCTA[0].SetActive(value: true);
					chapter5MainCTA[1].SetActive(value: false);
					chapter5MainCTA[2].SetActive(value: false);
					chapter5FileCTA[0].SetActive(value: true);
					chapter5FileCTA[1].SetActive(value: false);
					chapter5FileCTA[2].SetActive(value: false);
					chapter5FileCTA[3].SetActive(value: false);
					chapter5FolderCTA[0].SetActive(value: true);
					chapter5FolderCTA[1].SetActive(value: false);
					chapter5FolderCTA[2].SetActive(value: false);
					chapter5FolderCTA[3].SetActive(value: false);
					chapter5FolderCTA[4].SetActive(value: false);
					chapter5Checkmark1.SetActive(value: false);
					chapter5Checkmark2.SetActive(value: false);
					chapter5Checkmark3.SetActive(value: false);
					chapter5Checkmark4.SetActive(value: false);
				}
				else if (chapter.chapterStatus == ChapterStatus.OWNED_NOT_PLAYED)
				{
					if (chapter5EvidenceNoteboard != null)
					{
						chapter5EvidenceNoteboard.SetActive(value: false);
					}
					if (chapter5EvidenceRoom != null)
					{
						chapter5EvidenceRoom.SetActive(value: false);
					}
					if (chapter5DeskEvidence != null)
					{
						chapter5DeskEvidence.SetActive(value: false);
					}
					chapter5MainCTA[0].SetActive(value: false);
					chapter5MainCTA[1].SetActive(value: true);
					chapter5MainCTA[2].SetActive(value: false);
					chapter5FileCTA[0].SetActive(value: false);
					chapter5FileCTA[1].SetActive(value: true);
					chapter5FileCTA[2].SetActive(value: false);
					chapter5FileCTA[3].SetActive(value: false);
					chapter5FolderCTA[0].SetActive(value: true);
					chapter5FolderCTA[1].SetActive(value: false);
					chapter5FolderCTA[2].SetActive(value: false);
					chapter5FolderCTA[3].SetActive(value: false);
					chapter5FolderCTA[4].SetActive(value: false);
					chapter5Checkmark1.SetActive(value: false);
					chapter5Checkmark2.SetActive(value: false);
					chapter5Checkmark3.SetActive(value: false);
					chapter5Checkmark4.SetActive(value: false);
				}
				else if (chapter.chapterStatus == ChapterStatus.PLAYED_NOT_COMPLETED)
				{
					if (chapter5EvidenceNoteboard != null)
					{
						chapter5EvidenceNoteboard.SetActive(value: true);
					}
					if (chapter5EvidenceRoom != null)
					{
						chapter5EvidenceRoom.SetActive(value: true);
					}
					if (chapter5DeskEvidence != null)
					{
						chapter5DeskEvidence.SetActive(value: false);
					}
					chapter5MainCTA[0].SetActive(value: false);
					chapter5MainCTA[1].SetActive(value: false);
					chapter5MainCTA[2].SetActive(value: true);
					chapter5FileCTA[0].SetActive(value: false);
					chapter5FileCTA[1].SetActive(value: false);
					chapter5FileCTA[2].SetActive(value: true);
					chapter5FileCTA[3].SetActive(value: false);
					chapter5FolderCTA[0].SetActive(value: true);
					chapter5FolderCTA[1].SetActive(value: false);
					chapter5FolderCTA[2].SetActive(value: false);
					chapter5FolderCTA[3].SetActive(value: false);
					chapter5FolderCTA[4].SetActive(value: false);
					chapter5Checkmark1.SetActive(value: false);
					chapter5Checkmark2.SetActive(value: false);
					chapter5Checkmark3.SetActive(value: false);
					chapter5Checkmark4.SetActive(value: false);
				}
				else if (chapter.chapterStatus == ChapterStatus.COMPLETED)
				{
					if (chapter5EvidenceNoteboard != null)
					{
						chapter5EvidenceNoteboard.SetActive(value: true);
					}
					if (chapter5EvidenceRoom != null)
					{
						chapter5EvidenceRoom.SetActive(value: true);
					}
					if (chapter5DeskEvidence != null)
					{
						chapter5DeskEvidence.SetActive(value: false);
					}
					chapter5MainCTA[0].SetActive(value: false);
					chapter5MainCTA[1].SetActive(value: false);
					chapter5MainCTA[2].SetActive(value: true);
					chapter5FileCTA[0].SetActive(value: false);
					chapter5FileCTA[1].SetActive(value: false);
					chapter5FileCTA[2].SetActive(value: false);
					chapter5FileCTA[3].SetActive(value: true);
					if (chapter.chapterCompletionStatus == ChapterCompletionStatus.TWENTYFIVC_PERCENT_COMPLETE)
					{
						chapter5FolderCTA[0].SetActive(value: false);
						chapter5FolderCTA[1].SetActive(value: true);
						chapter5FolderCTA[2].SetActive(value: false);
						chapter5FolderCTA[3].SetActive(value: false);
						chapter5FolderCTA[4].SetActive(value: false);
					}
					else if (chapter.chapterCompletionStatus == ChapterCompletionStatus.FIFTY_PERCENT_COMPLETE)
					{
						chapter5FolderCTA[0].SetActive(value: false);
						chapter5FolderCTA[1].SetActive(value: false);
						chapter5FolderCTA[2].SetActive(value: true);
						chapter5FolderCTA[3].SetActive(value: false);
						chapter5FolderCTA[4].SetActive(value: false);
					}
					else if (chapter.chapterCompletionStatus == ChapterCompletionStatus.SEVENTY_FIVE_COMPLETE)
					{
						chapter5FolderCTA[0].SetActive(value: false);
						chapter5FolderCTA[1].SetActive(value: false);
						chapter5FolderCTA[2].SetActive(value: false);
						chapter5FolderCTA[3].SetActive(value: true);
						chapter5FolderCTA[4].SetActive(value: false);
					}
					else if (chapter.chapterCompletionStatus == ChapterCompletionStatus.HUNDRED_PERCENT_COMPLETE)
					{
						chapter5FolderCTA[0].SetActive(value: false);
						chapter5FolderCTA[1].SetActive(value: false);
						chapter5FolderCTA[2].SetActive(value: false);
						chapter5FolderCTA[3].SetActive(value: false);
						chapter5FolderCTA[4].SetActive(value: true);
					}
					else
					{
						chapter5FolderCTA[0].SetActive(value: true);
						chapter5FolderCTA[1].SetActive(value: false);
						chapter5FolderCTA[2].SetActive(value: false);
						chapter5FolderCTA[3].SetActive(value: false);
						chapter5FolderCTA[4].SetActive(value: false);
					}
					chapter5Checkmark1.SetActive(chapter.completionCheckmark1);
					chapter5Checkmark2.SetActive(chapter.completionCheckmark2);
					chapter5Checkmark3.SetActive(chapter.completionCheckmark3);
					chapter5Checkmark4.SetActive(chapter.completionCheckmark4);
				}
				break;
			}
			previousChapter = chapter;
		}
		gameChapters = savedGameData.gameChapters;
		foreach (Chapter chapter2 in gameChapters)
		{
			if (chapter2 == null || chapter2.chapterStatus >= ChapterStatus.COMPLETED)
			{
				continue;
			}
			switch (chapter2.chapterID)
			{
			case ChapterID.CHAPEL:
				if (chapter1DeskEvidence != null)
				{
					chapter1DeskEvidence.SetActive(value: true);
					return;
				}
				break;
			case ChapterID.CELL:
				if (chapter2DeskEvidence != null)
				{
					chapter2DeskEvidence.SetActive(value: true);
					return;
				}
				break;
			case ChapterID.NURSERY:
				if (chapter3DeskEvidence != null)
				{
					chapter3DeskEvidence.SetActive(value: true);
					return;
				}
				break;
			case ChapterID.MORGUE:
				if (chapter4DeskEvidence != null)
				{
					chapter4DeskEvidence.SetActive(value: true);
					return;
				}
				break;
			case ChapterID.TOMB:
				if (chapter5DeskEvidence != null)
				{
					chapter5DeskEvidence.SetActive(value: true);
					return;
				}
				break;
			}
		}
	}

	public void UpdateReportCheckmarks(ChapterID chapterToUpdate)
	{
		Chapter chapterById = SaveManager.instance.GetChapterById(chapterToUpdate);
		switch (chapterToUpdate)
		{
		case ChapterID.CHAPEL:
			chapter1Checkmark1.SetActive(chapterById.completionCheckmark1);
			chapter1Checkmark2.SetActive(chapterById.completionCheckmark2);
			chapter1Checkmark3.SetActive(chapterById.completionCheckmark3);
			chapter1Checkmark4.SetActive(chapterById.completionCheckmark4);
			if (chapterById.chapterCompletionStatus == ChapterCompletionStatus.TWENTYFIVC_PERCENT_COMPLETE)
			{
				chapter1FolderCTA[0].SetActive(value: false);
				chapter1FolderCTA[1].SetActive(value: true);
				chapter1FolderCTA[2].SetActive(value: false);
				chapter1FolderCTA[3].SetActive(value: false);
				chapter1FolderCTA[4].SetActive(value: false);
			}
			else if (chapterById.chapterCompletionStatus == ChapterCompletionStatus.FIFTY_PERCENT_COMPLETE)
			{
				chapter1FolderCTA[0].SetActive(value: false);
				chapter1FolderCTA[1].SetActive(value: false);
				chapter1FolderCTA[2].SetActive(value: true);
				chapter1FolderCTA[3].SetActive(value: false);
				chapter1FolderCTA[4].SetActive(value: false);
			}
			else if (chapterById.chapterCompletionStatus == ChapterCompletionStatus.SEVENTY_FIVE_COMPLETE)
			{
				chapter1FolderCTA[0].SetActive(value: false);
				chapter1FolderCTA[1].SetActive(value: false);
				chapter1FolderCTA[2].SetActive(value: false);
				chapter1FolderCTA[3].SetActive(value: true);
				chapter1FolderCTA[4].SetActive(value: false);
			}
			else if (chapterById.chapterCompletionStatus == ChapterCompletionStatus.HUNDRED_PERCENT_COMPLETE)
			{
				chapter1FolderCTA[0].SetActive(value: false);
				chapter1FolderCTA[1].SetActive(value: false);
				chapter1FolderCTA[2].SetActive(value: false);
				chapter1FolderCTA[3].SetActive(value: false);
				chapter1FolderCTA[4].SetActive(value: true);
			}
			else
			{
				chapter1FolderCTA[0].SetActive(value: true);
				chapter1FolderCTA[1].SetActive(value: false);
				chapter1FolderCTA[2].SetActive(value: false);
				chapter1FolderCTA[3].SetActive(value: false);
				chapter1FolderCTA[4].SetActive(value: false);
			}
			break;
		case ChapterID.CELL:
			chapter2Checkmark1.SetActive(chapterById.completionCheckmark1);
			chapter2Checkmark2.SetActive(chapterById.completionCheckmark2);
			chapter2Checkmark3.SetActive(chapterById.completionCheckmark3);
			chapter2Checkmark4.SetActive(chapterById.completionCheckmark4);
			if (chapterById.chapterCompletionStatus == ChapterCompletionStatus.TWENTYFIVC_PERCENT_COMPLETE)
			{
				chapter2FolderCTA[0].SetActive(value: false);
				chapter2FolderCTA[1].SetActive(value: true);
				chapter2FolderCTA[2].SetActive(value: false);
				chapter2FolderCTA[3].SetActive(value: false);
				chapter2FolderCTA[4].SetActive(value: false);
			}
			else if (chapterById.chapterCompletionStatus == ChapterCompletionStatus.FIFTY_PERCENT_COMPLETE)
			{
				chapter2FolderCTA[0].SetActive(value: false);
				chapter2FolderCTA[1].SetActive(value: false);
				chapter2FolderCTA[2].SetActive(value: true);
				chapter2FolderCTA[3].SetActive(value: false);
				chapter2FolderCTA[4].SetActive(value: false);
			}
			else if (chapterById.chapterCompletionStatus == ChapterCompletionStatus.SEVENTY_FIVE_COMPLETE)
			{
				chapter2FolderCTA[0].SetActive(value: false);
				chapter2FolderCTA[1].SetActive(value: false);
				chapter2FolderCTA[2].SetActive(value: false);
				chapter2FolderCTA[3].SetActive(value: true);
				chapter2FolderCTA[4].SetActive(value: false);
			}
			else if (chapterById.chapterCompletionStatus == ChapterCompletionStatus.HUNDRED_PERCENT_COMPLETE)
			{
				chapter2FolderCTA[0].SetActive(value: false);
				chapter2FolderCTA[1].SetActive(value: false);
				chapter2FolderCTA[2].SetActive(value: false);
				chapter2FolderCTA[3].SetActive(value: false);
				chapter2FolderCTA[4].SetActive(value: true);
			}
			else
			{
				chapter2FolderCTA[0].SetActive(value: true);
				chapter2FolderCTA[1].SetActive(value: false);
				chapter2FolderCTA[2].SetActive(value: false);
				chapter2FolderCTA[3].SetActive(value: false);
				chapter2FolderCTA[4].SetActive(value: false);
			}
			break;
		case ChapterID.NURSERY:
			if (chapterById.chapterCompletionStatus == ChapterCompletionStatus.TWENTYFIVC_PERCENT_COMPLETE)
			{
				chapter3FolderCTA[0].SetActive(value: false);
				chapter3FolderCTA[1].SetActive(value: true);
				chapter3FolderCTA[2].SetActive(value: false);
				chapter3FolderCTA[3].SetActive(value: false);
				chapter3FolderCTA[4].SetActive(value: false);
			}
			else if (chapterById.chapterCompletionStatus == ChapterCompletionStatus.FIFTY_PERCENT_COMPLETE)
			{
				chapter3FolderCTA[0].SetActive(value: false);
				chapter3FolderCTA[1].SetActive(value: false);
				chapter3FolderCTA[2].SetActive(value: true);
				chapter3FolderCTA[3].SetActive(value: false);
				chapter3FolderCTA[4].SetActive(value: false);
			}
			else if (chapterById.chapterCompletionStatus == ChapterCompletionStatus.SEVENTY_FIVE_COMPLETE)
			{
				chapter3FolderCTA[0].SetActive(value: false);
				chapter3FolderCTA[1].SetActive(value: false);
				chapter3FolderCTA[2].SetActive(value: false);
				chapter3FolderCTA[3].SetActive(value: true);
				chapter3FolderCTA[4].SetActive(value: false);
			}
			else if (chapterById.chapterCompletionStatus == ChapterCompletionStatus.HUNDRED_PERCENT_COMPLETE)
			{
				chapter3FolderCTA[0].SetActive(value: false);
				chapter3FolderCTA[1].SetActive(value: false);
				chapter3FolderCTA[2].SetActive(value: false);
				chapter3FolderCTA[3].SetActive(value: false);
				chapter3FolderCTA[4].SetActive(value: true);
			}
			else
			{
				chapter3FolderCTA[0].SetActive(value: true);
				chapter3FolderCTA[1].SetActive(value: false);
				chapter3FolderCTA[2].SetActive(value: false);
				chapter3FolderCTA[3].SetActive(value: false);
				chapter3FolderCTA[4].SetActive(value: false);
			}
			chapter3Checkmark1.SetActive(chapterById.completionCheckmark1);
			chapter3Checkmark2.SetActive(chapterById.completionCheckmark2);
			chapter3Checkmark3.SetActive(chapterById.completionCheckmark3);
			chapter3Checkmark4.SetActive(chapterById.completionCheckmark4);
			break;
		case ChapterID.MORGUE:
			if (chapterById.chapterCompletionStatus == ChapterCompletionStatus.TWENTYFIVC_PERCENT_COMPLETE)
			{
				chapter4FolderCTA[0].SetActive(value: false);
				chapter4FolderCTA[1].SetActive(value: true);
				chapter4FolderCTA[2].SetActive(value: false);
				chapter4FolderCTA[3].SetActive(value: false);
				chapter4FolderCTA[4].SetActive(value: false);
			}
			else if (chapterById.chapterCompletionStatus == ChapterCompletionStatus.FIFTY_PERCENT_COMPLETE)
			{
				chapter4FolderCTA[0].SetActive(value: false);
				chapter4FolderCTA[1].SetActive(value: false);
				chapter4FolderCTA[2].SetActive(value: true);
				chapter4FolderCTA[3].SetActive(value: false);
				chapter4FolderCTA[4].SetActive(value: false);
			}
			else if (chapterById.chapterCompletionStatus == ChapterCompletionStatus.SEVENTY_FIVE_COMPLETE)
			{
				chapter4FolderCTA[0].SetActive(value: false);
				chapter4FolderCTA[1].SetActive(value: false);
				chapter4FolderCTA[2].SetActive(value: false);
				chapter4FolderCTA[3].SetActive(value: true);
				chapter4FolderCTA[4].SetActive(value: false);
			}
			else if (chapterById.chapterCompletionStatus == ChapterCompletionStatus.HUNDRED_PERCENT_COMPLETE)
			{
				chapter4FolderCTA[0].SetActive(value: false);
				chapter4FolderCTA[1].SetActive(value: false);
				chapter4FolderCTA[2].SetActive(value: false);
				chapter4FolderCTA[3].SetActive(value: false);
				chapter4FolderCTA[4].SetActive(value: true);
			}
			else
			{
				chapter4FolderCTA[0].SetActive(value: true);
				chapter4FolderCTA[1].SetActive(value: false);
				chapter4FolderCTA[2].SetActive(value: false);
				chapter4FolderCTA[3].SetActive(value: false);
				chapter4FolderCTA[4].SetActive(value: false);
			}
			chapter4Checkmark1.SetActive(chapterById.completionCheckmark1);
			chapter4Checkmark2.SetActive(chapterById.completionCheckmark2);
			chapter4Checkmark3.SetActive(chapterById.completionCheckmark3);
			chapter4Checkmark4.SetActive(chapterById.completionCheckmark4);
			break;
		case ChapterID.TOMB:
			if (chapterById.chapterCompletionStatus == ChapterCompletionStatus.TWENTYFIVC_PERCENT_COMPLETE)
			{
				chapter5FolderCTA[0].SetActive(value: false);
				chapter5FolderCTA[1].SetActive(value: true);
				chapter5FolderCTA[2].SetActive(value: false);
				chapter5FolderCTA[3].SetActive(value: false);
				chapter5FolderCTA[4].SetActive(value: false);
			}
			else if (chapterById.chapterCompletionStatus == ChapterCompletionStatus.FIFTY_PERCENT_COMPLETE)
			{
				chapter5FolderCTA[0].SetActive(value: false);
				chapter5FolderCTA[1].SetActive(value: false);
				chapter5FolderCTA[2].SetActive(value: true);
				chapter5FolderCTA[3].SetActive(value: false);
				chapter5FolderCTA[4].SetActive(value: false);
			}
			else if (chapterById.chapterCompletionStatus == ChapterCompletionStatus.SEVENTY_FIVE_COMPLETE)
			{
				chapter5FolderCTA[0].SetActive(value: false);
				chapter5FolderCTA[1].SetActive(value: false);
				chapter5FolderCTA[2].SetActive(value: false);
				chapter5FolderCTA[3].SetActive(value: true);
				chapter5FolderCTA[4].SetActive(value: false);
			}
			else if (chapterById.chapterCompletionStatus == ChapterCompletionStatus.HUNDRED_PERCENT_COMPLETE)
			{
				chapter5FolderCTA[0].SetActive(value: false);
				chapter5FolderCTA[1].SetActive(value: false);
				chapter5FolderCTA[2].SetActive(value: false);
				chapter5FolderCTA[3].SetActive(value: false);
				chapter5FolderCTA[4].SetActive(value: true);
			}
			else
			{
				chapter5FolderCTA[0].SetActive(value: true);
				chapter5FolderCTA[1].SetActive(value: false);
				chapter5FolderCTA[2].SetActive(value: false);
				chapter5FolderCTA[3].SetActive(value: false);
				chapter5FolderCTA[4].SetActive(value: false);
			}
			chapter5Checkmark1.SetActive(chapterById.completionCheckmark1);
			chapter5Checkmark2.SetActive(chapterById.completionCheckmark2);
			chapter5Checkmark3.SetActive(chapterById.completionCheckmark3);
			chapter5Checkmark4.SetActive(chapterById.completionCheckmark4);
			break;
		}
	}
}
public class Chessboard : MonoBehaviour
{
	[Serializable]
	private struct PlacementStruct
	{
		public GameObject placement;

		public bool placed;
	}

	[SerializeField]
	private GameObject pieceBishop;

	[SerializeField]
	private GameObject pieceCastle;

	[SerializeField]
	private GameObject pieceKing;

	[SerializeField]
	private GameObject piecePawn;

	public GameObject chessBoardCompartment;

	public float compartmentOpeningTime = 2f;

	public float compartmentRotationAmount = -50f;

	[SerializeField]
	private PlacementStruct[] correctPlacements;

	[HideInInspector]
	public bool allPiecesPlaced;

	private List<GameObject> placedPieces = new List<GameObject>();

	[SerializeField]
	private AudioScript audioScript;

	private AudioClip soundToPlay;

	[SerializeField]
	private AudioClip correctPlacementSound;

	[SerializeField]
	private AudioClip incorrectPlacementSound;

	[SerializeField]
	private AudioClip combinationCompleteSound;

	public bool artifactComplete;

	[Space]
	[SerializeField]
	private GameObject caseLid;

	[Header("Reward")]
	public GameObject oilReward;

	private void Start()
	{
		oilReward.SetActive(value: false);
	}

	private void OnTriggerEnter(Collider other)
	{
	}

	private void OnCollisionEnter(Collision collision)
	{
	}

	public bool CheckPlacementOpen(GameObject newPlacement)
	{
		bool flag = true;
		foreach (GameObject placedPiece in placedPieces)
		{
			if (placedPiece == newPlacement)
			{
				flag = false;
				break;
			}
		}
		if (flag)
		{
			soundToPlay = incorrectPlacementSound;
			placedPieces.Add(newPlacement);
			for (int i = 0; i < correctPlacements.Length; i++)
			{
				if (newPlacement == correctPlacements[i].placement)
				{
					correctPlacements[i].placed = true;
					soundToPlay = correctPlacementSound;
					StartCoroutine(CheckCombination());
					break;
				}
			}
			audioScript.Play(soundToPlay);
		}
		return flag;
	}

	public void RemovePlacedPiece(GameObject placedLocation)
	{
		placedPieces.Remove(placedLocation);
		for (int i = 0; i < correctPlacements.Length; i++)
		{
			if (placedLocation == correctPlacements[i].placement)
			{
				correctPlacements[i].placed = false;
			}
		}
	}

	private IEnumerator CheckCombination()
	{
		yield return null;
		int num = 0;
		for (int i = 0; i < correctPlacements.Length; i++)
		{
			if (correctPlacements[i].placed)
			{
				num++;
			}
		}
		if (num == 4)
		{
			artifactComplete = true;
			LeanTween.rotateZ(chessBoardCompartment, compartmentRotationAmount, compartmentOpeningTime);
			oilReward.SetActive(value: true);
			pieceBishop.GetComponent<NVRInteractableItem>().enabled = false;
			pieceCastle.GetComponent<NVRInteractableItem>().enabled = false;
			pieceKing.GetComponent<NVRInteractableItem>().enabled = false;
			piecePawn.GetComponent<NVRInteractableItem>().enabled = false;
		}
	}

	public void setArtifactRevealed()
	{
		artifactComplete = true;
		pieceBishop.GetComponent<NVRInteractableItem>().CanAttach = false;
		pieceCastle.GetComponent<NVRInteractableItem>().CanAttach = false;
		pieceKing.GetComponent<NVRInteractableItem>().CanAttach = false;
		piecePawn.GetComponent<NVRInteractableItem>().CanAttach = false;
		LeanTween.rotateZ(chessBoardCompartment, compartmentRotationAmount, compartmentOpeningTime);
		caseLid.transform.localEulerAngles = new Vector3(-93f, 0f, 0f);
	}
}
public class Clock : MonoBehaviour
{
	[SerializeField]
	private Vector3 axis = new Vector3(0f, 0f, 1f);

	[SerializeField]
	private GameObject hrs;

	[SerializeField]
	private GameObject min;

	[SerializeField]
	private GameObject sec;

	public bool useSpecificTime;

	public float specificHrs;

	public float specificMin;

	public float specificSec;

	private float startHrs;

	private float startMin;

	private float startSec;

	private bool trackedSpecTime;

	private int hrsToDeg = 30;

	private int minToDeg = 6;

	private int secToDeg = 6;

	[Space]
	[SerializeField]
	private AudioClip clockLoop;

	[SerializeField]
	private float volume = 0.6f;

	[SerializeField]
	private AudioScript audioScript;

	private bool clockPaused;

	private void Start()
	{
		if (clockLoop != null)
		{
			if (audioScript == null)
			{
				audioScript = base.gameObject.AddComponent<AudioScript>();
			}
			audioScript.PlayLoop(clockLoop, volume);
		}
	}

	public void Stop()
	{
		clockPaused = true;
		if (audioScript != null)
		{
			audioScript.StopLoop();
		}
	}

	public void Play()
	{
		clockPaused = false;
		audioScript.PlayLoop(clockLoop, volume);
	}

	private void Update()
	{
		if (clockPaused)
		{
			return;
		}
		TimeSpan timeOfDay = DateTime.Now.TimeOfDay;
		float num = (float)timeOfDay.TotalHours * (float)hrsToDeg;
		float num2 = (float)timeOfDay.TotalMinutes * (float)minToDeg;
		float num3 = (float)timeOfDay.TotalSeconds * (float)secToDeg;
		if (useSpecificTime)
		{
			if (!trackedSpecTime)
			{
				startHrs = (float)timeOfDay.TotalHours;
				startMin = (float)timeOfDay.TotalMinutes;
				startSec = (float)timeOfDay.TotalSeconds;
				trackedSpecTime = true;
			}
			num = (float)(timeOfDay.TotalHours - (double)startHrs + (double)specificHrs) * (float)hrsToDeg;
			num2 = (float)(timeOfDay.TotalMinutes - (double)startMin + (double)specificMin) * (float)minToDeg;
			num3 = (float)(timeOfDay.TotalSeconds - (double)startSec + (double)specificSec) * (float)secToDeg;
		}
		hrs.transform.localRotation = Quaternion.Euler((0f - axis.x) * num, axis.y * num, axis.z * num);
		min.transform.localRotation = Quaternion.Euler((0f - axis.x) * num2, axis.y * num2, axis.z * num2);
		if (sec != null)
		{
			sec.transform.localRotation = Quaternion.Euler(axis.x * num3, axis.y * num3, axis.z * num3);
		}
	}
}
public class Cockroach : NVRTrigger
{
	public override void TriggerEnter(NVRInteractableItem item)
	{
		Vector3 normalized = item.Rigidbody.velocity.normalized;
		UnityEngine.Debug.Log("Cockroach HIT!!! " + normalized);
		if ((double)normalized.magnitude > 0.5)
		{
			GameObject obj = UnityEngine.Object.Instantiate(base.gameObject, base.transform.parent.parent, worldPositionStays: true);
			UnityEngine.Object.Destroy(obj.GetComponent<Cockroach>());
			base.gameObject.SetActive(value: false);
			obj.SetActive(value: true);
		}
	}

	public override void TriggerEnd(NVRInteractableItem item)
	{
	}

	public override void TriggerStay(NVRInteractableItem item)
	{
	}
}
public class CoffeeMachine : MonoBehaviour
{
	[SerializeField]
	private NVRInteractable[] coffeeCups;

	[SerializeField]
	private GameObject[] coffeeCupsLids;

	[SerializeField]
	private GameObject led;

	private int limit = 3;

	private int used;

	private bool dispensing;

	[SerializeField]
	private AudioClip coffeePour;

	[SerializeField]
	private AudioClip coffeeHum;

	private AudioScript coffeeSound;

	[SerializeField]
	private AudioScript chiefsRoomAudioScript;

	[SerializeField]
	private AudioClip backToWorkClip;

	[SerializeField]
	private GameObject pourParticle;

	private bool playedChiefClip;

	private int itemsInTrigger;

	private void Start()
	{
		coffeeSound = GetComponent<AudioScript>();
		led.SetActive(value: false);
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.B))
		{
			StartCoroutine(Dispense());
		}
	}

	public void DispenseCoffee()
	{
		if (used < limit)
		{
			if (!dispensing && itemsInTrigger == 0)
			{
				StartCoroutine(Dispense());
			}
		}
		else if (!chiefsRoomAudioScript.m_AudioSource.isPlaying && !playedChiefClip)
		{
			chiefsRoomAudioScript.Play(backToWorkClip);
			GameController.instance.achievementManager.UnlockAchievement(AchievementID.COFFEE_BREAK);
			playedChiefClip = true;
		}
	}

	private IEnumerator Dispense()
	{
		dispensing = true;
		coffeeCups[used].CanAttach = false;
		SpillController spill = coffeeCups[used].gameObject.GetComponentInChildren<SpillController>();
		spill.canSpill = false;
		PourSound();
		yield return Yield.WaitSeconds(3f);
		coffeeCups[used].gameObject.SetActive(value: true);
		LeanTween.moveY(coffeeCups[used].gameObject, 0.7158f, 0.2f).setEaseInCubic();
		yield return Yield.WaitSeconds(3f);
		pourParticle.SetActive(value: true);
		pourParticle.GetComponent<ParticleSystem>().Play();
		spill.EmitSteam();
		coffeeCups[used].gameObject.GetComponentInChildren<Animator>().SetTrigger("Fill");
		yield return Yield.WaitSeconds(coffeePour.length - 5.5f);
		spill.canSpill = true;
		while (pourParticle.GetComponent<ParticleSystem>().isPlaying)
		{
			yield return null;
		}
		spill.StopSteam();
		coffeeCupsLids[used].SetActive(value: true);
		LeanTween.moveLocalY(coffeeCupsLids[used].gameObject, 0.0973f, 0.2f).setEaseInCubic();
		coffeeCups[used].CanAttach = true;
		spill.canSpill = true;
		pourParticle.SetActive(value: false);
		pourParticle.GetComponent<ParticleSystem>().Stop();
		used++;
		if (used == 3)
		{
			led.SetActive(value: true);
		}
		dispensing = false;
	}

	public void PourSound()
	{
		coffeeSound.PlayOne(coffeePour);
	}

	public void HumSound()
	{
		coffeeSound.PlayLoop(coffeeHum);
	}

	private void OnTriggerEnter(Collider other)
	{
		if ((bool)other.gameObject.GetComponent<NVRInteractable>())
		{
			itemsInTrigger++;
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if ((bool)other.gameObject.GetComponent<NVRInteractable>())
		{
			itemsInTrigger--;
		}
	}
}
public class CoffeeParticleCollision : MonoBehaviour
{
	public GameObject plantModel;

	public UnityEngine.Color plantDeadColour;

	public float dyingTime = 3f;

	public bool DebugModifyColour;

	public bool hasUnlockedAchievement;

	private void OnParticleCollision(GameObject other)
	{
		if (other.name == "PlantCapsule" || other.name == "Pot")
		{
			LeanTween.color(plantModel, plantDeadColour, dyingTime);
			if (!hasUnlockedAchievement)
			{
				hasUnlockedAchievement = true;
				GameController.instance.achievementManager.UnlockAchievement(AchievementID.FEED_ME);
			}
			GetComponent<CoffeeParticleCollision>().enabled = false;
		}
	}

	private void Update()
	{
		if (DebugModifyColour)
		{
			plantModel.GetComponent<Renderer>().material.color = plantDeadColour;
		}
	}
}
public class ColumnBreakParticles : MonoBehaviour
{
	[SerializeField]
	private ParticleSystem particle01;

	[SerializeField]
	private ParticleSystem particle02;

	[SerializeField]
	private ParticleSystem particle03;

	[SerializeField]
	private ParticleSystem particle04;

	[SerializeField]
	private Pazuzu pazuzu;

	public void PlayParticle(int particleNumber)
	{
		switch (particleNumber)
		{
		case 0:
			particle01.Play();
			break;
		case 1:
			particle02.Play();
			break;
		case 2:
			particle03.Play();
			break;
		case 3:
			particle04.Play();
			break;
		}
	}

	public void SlowTime(float time)
	{
		pazuzu.SlowTime(time);
	}
}
public class Corpse : MonoBehaviour
{
	[SerializeField]
	private Transform lookFrom;

	[SerializeField]
	private Transform lookAt;

	[SerializeField]
	private Animator animator;

	[SerializeField]
	private bool lookAtPlayer;

	[SerializeField]
	private GameObject ejectionAnimation;

	[SerializeField]
	private ParticleSystem particles;

	public bool hasHitWithSaltSpray;

	private void Start()
	{
		if ((bool)particles)
		{
			particles.gameObject.SetActive(value: false);
		}
		if (lookAtPlayer)
		{
			lookAt = GameController.instance.player.transform;
		}
		if (lookFrom == null)
		{
			lookFrom = base.gameObject.transform;
		}
		if (ejectionAnimation != null)
		{
			ejectionAnimation.SetActive(value: false);
		}
	}

	private void Update()
	{
	}

	public void PlaySitUpAnimation()
	{
		animator.SetTrigger("Situp");
	}

	public void PlayExorcismAnimation()
	{
		animator.SetTrigger("Exorcism");
	}

	public void PlayRiseUpAnimation()
	{
		animator.SetTrigger("Rise");
	}

	public void PlayFloatAnimation()
	{
		animator.SetTrigger("Float");
	}

	public void PlayAttackAnimation()
	{
		animator.SetTrigger("Attack");
	}

	public void ReturnToOriginalPosition()
	{
		animator.SetTrigger("Idle");
	}

	public void PlayBaalOutburst()
	{
		animator.SetTrigger("Outburst");
	}

	public void PlayEjectionAnimation()
	{
		if (ejectionAnimation != null)
		{
			ejectionAnimation.SetActive(value: true);
		}
	}

	public void PlayParticles()
	{
		if ((bool)particles)
		{
			particles.gameObject.SetActive(value: true);
			particles.Play();
		}
	}

	public void StopParticles()
	{
		if ((bool)particles)
		{
			particles.Stop();
			particles.gameObject.SetActive(value: false);
		}
	}
}
public class DeadBody : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class CanvasCamera : MonoBehaviour
{
	public static CanvasCamera instance;

	public Camera leftCam;

	public Camera rightCam;

	public Camera centerCam;

	private void Awake()
	{
		instance = this;
	}

	private void Update()
	{
	}
}
public class GetEventCamera : MonoBehaviour
{
	private Canvas m_canvas;

	private void Awake()
	{
		m_canvas = GetComponent<Canvas>();
	}
}
public class GlobalHead : MonoBehaviour
{
	public GameObject headPrefab;

	public static GlobalHead instance;

	private void Awake()
	{
		instance = this;
	}
}
public class Dictaphone : NVRInteractableItem
{
	[Serializable]
	public struct DictaphoneTrack
	{
		public Texture texture;

		public float length;

		public void SetTexture(Material mat)
		{
			mat.mainTexture = texture;
			mat.EnableKeyword("_EMISSION");
			mat.SetTexture("_EmissionMap", texture);
		}
	}

	[Space]
	[Header("Object Specific")]
	[SerializeField]
	public AudioClip messagePart1;

	[SerializeField]
	public AudioClip messagePart2;

	[SerializeField]
	public AudioScript audioScript;

	[SerializeField]
	public Transform chargerSnapPoint;

	[SerializeField]
	private GameObject onSwitch;

	[SerializeField]
	private Texture blackTexture;

	[SerializeField]
	private Texture originalTexture;

	[SerializeField]
	private AudioClip lowBatteryWarningClip;

	[SerializeField]
	private Texture lowBatteryTexture;

	[SerializeField]
	private Material screenMaterial;

	[SerializeField]
	private DictaphoneTrack[] tracks;

	public bool playedPart1;

	public bool playedPart2;

	private bool _isPowerOn;

	private bool _hasPickedUp;

	private bool _isPlaying;

	private bool _isCharging;

	private const float kChargerDistanceThreshold = 0.5f;

	public void SwitchDockOn()
	{
		_isPowerOn = true;
		onSwitch.SetActive(value: true);
	}

	protected override void Start()
	{
		base.Start();
		OnUseButtonDown = new UnityEvent();
		OnUseButtonDown.AddListener(PlayMessage);
		onSwitch.SetActive(value: false);
		screenMaterial.mainTexture = originalTexture;
		screenMaterial.DisableKeyword("_EMISSION");
		screenMaterial.SetTexture("_MainTex", blackTexture);
	}

	protected override void Update()
	{
		base.Update();
		if (!_isPlaying)
		{
			if ((bool)base.AttachedHand && (base.AttachedHand.IsPrimary ? ControlsManager.instance.interactPrimaryDown : ControlsManager.instance.interactSecondaryDown))
			{
				PlayMessage();
			}
			if (_isCharging && _isPowerOn)
			{
				PlayMessage();
			}
		}
	}

	public override void BeginInteraction(NVRHand hand, bool runBeginInteractionCallback = true)
	{
		base.BeginInteraction(hand, runBeginInteractionCallback);
		if (!_hasPickedUp)
		{
			screenMaterial.EnableKeyword("_EMISSION");
			screenMaterial.SetTexture("_MainTex", originalTexture);
		}
	}

	public override void EndInteraction(NVRHand hand)
	{
		base.EndInteraction(hand);
		if (Vector3.Distance(base.transform.position, chargerSnapPoint.position) <= 0.5f)
		{
			_isCharging = true;
			CanAttach = false;
			DisableKinematicOnAttach = false;
			Rigidbody.isKinematic = true;
			base.transform.position = chargerSnapPoint.position;
			base.transform.rotation = chargerSnapPoint.rotation;
			if (!_isPlaying && _isPowerOn)
			{
				PlayMessage();
			}
		}
	}

	public void PlayMessage()
	{
		StartCoroutine(PlayMessageRoutine());
	}

	private IEnumerator PlayMessageRoutine()
	{
		if (!playedPart1)
		{
			_isPlaying = true;
			audioScript.Play(messagePart1, 0.4f);
			HUD.Instance.PlaySubtitles(messagePart1.name, hasPriority: true);
			tracks[0].SetTexture(screenMaterial);
			yield return Yield.WaitSeconds(tracks[0].length);
			playedPart1 = true;
			if (_isCharging)
			{
				yield return StartCoroutine(MessagePart2());
			}
			else
			{
				audioScript.Play(lowBatteryWarningClip);
				HUD.Instance.PlaySubtitles(lowBatteryWarningClip.name, hasPriority: true);
				screenMaterial.mainTexture = lowBatteryTexture;
				screenMaterial.EnableKeyword("_EMISSION");
				screenMaterial.SetTexture("_MainTex", lowBatteryTexture);
			}
			_isPlaying = false;
		}
		else if (!playedPart2 && _isCharging)
		{
			yield return StartCoroutine(MessagePart2());
			screenMaterial.mainTexture = originalTexture;
			screenMaterial.DisableKeyword("_EMISSION");
			screenMaterial.SetTexture("_MainTex", blackTexture);
		}
	}

	private IEnumerator MessagePart2()
	{
		_isPlaying = true;
		audioScript.Play(messagePart2);
		HUD.Instance.PlaySubtitles(messagePart2.name, hasPriority: true);
		tracks[1].SetTexture(screenMaterial);
		yield return Yield.WaitSeconds(tracks[1].length);
		tracks[2].SetTexture(screenMaterial);
		yield return Yield.WaitSeconds(tracks[2].length);
		tracks[3].SetTexture(screenMaterial);
		yield return Yield.WaitSeconds(tracks[3].length);
		playedPart2 = true;
	}
}
public class DigitalCamera : NVRInteractableItem
{
	private enum CameraState
	{
		OFF,
		TURNING_OFF,
		ON,
		TURNING_ON,
		IDLE,
		CHANGING_IMAGE,
		FADING_DOWN,
		FADING_UP
	}

	[Space]
	[Header("Object Specific")]
	[SerializeField]
	private Texture[] cameraImages;

	[SerializeField]
	private MeshRenderer cameraScreen;

	[SerializeField]
	private AudioScriptPooled audioScript;

	[SerializeField]
	private AudioClip camBeep;

	private CameraState cameraState;

	private int currentImage;

	[HideInInspector]
	public bool viewedAllImages;

	protected override void Start()
	{
		base.Start();
		currentImage = 0;
		Texture texture = GameController.instance.translator.GetTexture(cameraImages[currentImage].name);
		cameraScreen.material.SetTexture("_EmissionMap", texture ? texture : cameraImages[currentImage]);
		cameraScreen.material.SetColor("_EmissionColor", UnityEngine.Color.black);
	}

	protected override void Update()
	{
		base.Update();
		if (cameraState == CameraState.IDLE && (bool)base.AttachedHand && (base.AttachedHand.IsPrimary ? ControlsManager.instance.interactPrimaryDown : ControlsManager.instance.interactSecondaryDown))
		{
			ShowNextImage();
		}
	}

	public override void BeginInteraction(NVRHand hand, bool runBeginInteractionCallback = true)
	{
		base.BeginInteraction(hand, runBeginInteractionCallback);
		TurnOn();
	}

	public override void EndInteraction(NVRHand hand)
	{
		base.EndInteraction(hand);
		TurnOff();
	}

	public void TurnOn()
	{
		if (cameraState == CameraState.TURNING_OFF)
		{
			StopAllCoroutines();
			cameraState = CameraState.TURNING_ON;
			Texture texture = GameController.instance.translator.GetTexture(cameraImages[currentImage].name);
			cameraScreen.material.SetTexture("_EmissionMap", texture ? texture : cameraImages[currentImage]);
			StartCoroutine(FadeUpEmissive());
		}
		else if (cameraState == CameraState.OFF)
		{
			cameraState = CameraState.TURNING_ON;
			Texture texture2 = GameController.instance.translator.GetTexture(cameraImages[currentImage].name);
			cameraScreen.material.SetTexture("_EmissionMap", texture2 ? texture2 : cameraImages[currentImage]);
			StartCoroutine(FadeUpEmissive());
		}
	}

	public void TurnOff()
	{
		StopAllCoroutines();
		cameraState = CameraState.TURNING_OFF;
		StartCoroutine(FadeDownEmissive());
	}

	public void ShowNextImage()
	{
		StartCoroutine(ShowNextImageRoutine());
	}

	private IEnumerator ShowNextImageRoutine()
	{
		if (cameraState == CameraState.IDLE)
		{
			audioScript.PlayOneShot(camBeep, 0.5f);
			cameraState = CameraState.FADING_DOWN;
			StartCoroutine(FadeDownEmissive());
			while (cameraState == CameraState.FADING_DOWN)
			{
				yield return null;
			}
			currentImage++;
			if (currentImage > cameraImages.Length - 1)
			{
				viewedAllImages = true;
				currentImage = 0;
			}
			Texture texture = GameController.instance.translator.GetTexture(cameraImages[currentImage].name);
			cameraScreen.material.SetTexture("_EmissionMap", texture ? texture : cameraImages[currentImage]);
			cameraState = CameraState.FADING_UP;
			StartCoroutine(FadeUpEmissive());
		}
	}

	private IEnumerator FadeUpEmissive()
	{
		float intensity = 0f;
		UnityEngine.Color black = UnityEngine.Color.black;
		while (intensity < 1f)
		{
			intensity += 0.14f;
			if ((double)intensity > 1.0)
			{
				intensity = 1f;
				if (cameraState == CameraState.FADING_UP)
				{
					cameraState = CameraState.IDLE;
				}
				else if (cameraState == CameraState.TURNING_ON)
				{
					cameraState = CameraState.IDLE;
				}
			}
			black.a = intensity;
			black.r = intensity;
			black.g = intensity;
			black.b = intensity;
			cameraScreen.material.SetColor("_EmissionColor", black);
			yield return null;
		}
	}

	private IEnumerator FadeDownEmissive()
	{
		float intensity = 1f;
		UnityEngine.Color black = UnityEngine.Color.black;
		while (intensity > 0f)
		{
			intensity = (black.b = (black.g = (black.r = (black.a = intensity - 0.14f))));
			cameraScreen.material.SetColor("_EmissionColor", black);
			if (intensity < 0f)
			{
				intensity = 0f;
				if (cameraState == CameraState.FADING_DOWN)
				{
					cameraState = CameraState.IDLE;
				}
				else if (cameraState == CameraState.TURNING_OFF)
				{
					cameraState = CameraState.OFF;
				}
			}
			yield return null;
		}
	}
}
public class DollHouse : MonoBehaviour
{
	[SerializeField]
	private GameObject[] props;

	private Vector3[] posResets;

	private Quaternion[] rotResets;

	[SerializeField]
	private GameObject[] state1Props;

	[SerializeField]
	private GameObject[] state2Props;

	[SerializeField]
	private GameObject[] state3Props;

	[SerializeField]
	private Material houseMat;

	[SerializeField]
	private UnityEngine.Color houseEmmisiveColor;

	[SerializeField]
	private int amountToPickup = 20;

	private int pickupCount;

	private bool achievementUnlocked;

	private void Start()
	{
		posResets = new Vector3[props.Length];
		rotResets = new Quaternion[props.Length];
		houseMat.SetColor("_EmissionColor", UnityEngine.Color.black);
		for (int i = 0; i < props.Length; i++)
		{
			posResets[i] = props[i].transform.position;
			rotResets[i] = props[i].transform.rotation;
		}
		GameObject[] array = state2Props;
		for (int j = 0; j < array.Length; j++)
		{
			array[j].SetActive(value: false);
		}
		array = state3Props;
		for (int j = 0; j < array.Length; j++)
		{
			array[j].SetActive(value: false);
		}
	}

	public void ResetProps()
	{
		for (int i = 0; i < props.Length; i++)
		{
			props[i].transform.position = posResets[i];
			props[i].transform.rotation = rotResets[i];
		}
		GameObject[] array = state1Props;
		for (int j = 0; j < array.Length; j++)
		{
			array[j].SetActive(value: false);
		}
		array = state2Props;
		for (int j = 0; j < array.Length; j++)
		{
			array[j].SetActive(value: false);
		}
		array = state3Props;
		for (int j = 0; j < array.Length; j++)
		{
			array[j].SetActive(value: false);
		}
	}

	public void ChangeState(int state)
	{
		ResetProps();
		switch (state)
		{
		case 1:
		{
			GameObject[] array = state1Props;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].SetActive(value: true);
			}
			break;
		}
		case 2:
		{
			GameObject[] array = state2Props;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].SetActive(value: true);
			}
			break;
		}
		case 3:
		{
			GameObject[] array = state3Props;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].SetActive(value: true);
			}
			break;
		}
		}
	}

	public bool recordInteractable(GameObject interactable)
	{
		if (isItemFromDollsHouse(interactable))
		{
			pickupCount++;
			if (pickupCount >= amountToPickup)
			{
				achievementUnlocked = true;
				GameController.instance.achievementManager.UnlockAchievement(AchievementID.MINIATURE_COLLECTOR);
			}
		}
		return achievementUnlocked;
	}

	private bool isItemFromDollsHouse(GameObject interactable)
	{
		for (int i = 0; i < props.Length; i++)
		{
			if (props[i] == interactable)
			{
				return true;
			}
		}
		return false;
	}

	public void TurnOffLight()
	{
		houseMat.SetColor("_EmissionColor", UnityEngine.Color.black);
	}

	public void TurnOnLight()
	{
		houseMat.SetColor("_EmissionColor", houseEmmisiveColor);
	}
}
public class DoorSfx : MonoBehaviour
{
	private HingeJoint m_Hinge;

	private AudioSource m_Audio;

	private AudioScript s_Audio;

	[SerializeField]
	private float maxVol = 1f;

	[SerializeField]
	private AudioClip sfxCreak;

	[SerializeField]
	public AudioClip sfxSlamShut;

	private float startAngle;

	private float newAngle;

	private float prevAng;

	private bool creakPlaying;

	private bool slamPlaying;

	private float targetVolume;

	private void Start()
	{
		m_Hinge = GetComponentInParent<HingeJoint>();
		m_Audio = base.gameObject.AddComponent<AudioSource>();
		m_Audio.spatialBlend = 1f;
		m_Audio.volume = 0f;
		m_Audio.playOnAwake = false;
		GameObject gameObject = new GameObject("SlamSoundEffect");
		gameObject.transform.position = base.gameObject.transform.position;
		gameObject.transform.parent = base.gameObject.transform;
		s_Audio = gameObject.AddComponent<AudioScript>();
		s_Audio.mixerChannel = AudioScript.MixerChannel.sfx;
		if (m_Hinge != null)
		{
			prevAng = m_Hinge.angle;
		}
		if (sfxCreak != null)
		{
			m_Audio.clip = sfxCreak;
		}
		m_Audio.loop = true;
	}

	private void Update()
	{
		if (!(m_Hinge != null))
		{
			return;
		}
		float num = m_Hinge.velocity;
		float num2 = m_Hinge.angle;
		if (num < 0f)
		{
			num *= -1f;
		}
		if (num2 < 0f)
		{
			num2 *= -1f;
		}
		targetVolume = Mathf.Clamp(num / 10f, 0f, maxVol);
		m_Audio.volume = Mathf.Lerp(m_Audio.volume, targetVolume, Time.deltaTime * 5f);
		m_Audio.pitch = Mathf.Clamp(num / 10f, 0.9f, 1.4f);
		if (sfxCreak != null)
		{
			if (num > 5f && !m_Audio.isPlaying)
			{
				m_Audio.Play();
			}
			if (num < 5f && targetVolume != 0f)
			{
				targetVolume = 0f;
			}
		}
		if (sfxSlamShut != null && !slamPlaying && prevAng > num2 && num2 < 1f && num > 2f)
		{
			slamPlaying = true;
			s_Audio.PlayOne(sfxSlamShut, targetVolume);
			StartCoroutine(PlayingSlam());
		}
		prevAng = num2;
	}

	public void PlayDoorSlam(float vol)
	{
		if ((bool)sfxSlamShut)
		{
			slamPlaying = true;
			s_Audio.PlayOne(sfxSlamShut, vol);
			StartCoroutine(PlayingSlam());
		}
	}

	private IEnumerator PlayingSlam()
	{
		yield return Yield.WaitSeconds(sfxSlamShut.length);
		slamPlaying = false;
	}

	public void PlayDoorCreak(float playLength)
	{
		StartCoroutine(PlayingCreak(playLength));
	}

	private IEnumerator PlayingCreak(float playLength)
	{
		m_Audio.Play();
		yield return Yield.WaitSeconds(playLength);
		m_Audio.Pause();
	}

	public void PlayDoorCreakWithFade(float playLength)
	{
		StartCoroutine(PlayCreekRoutineWithFade(playLength));
	}

	private IEnumerator PlayCreekRoutineWithFade(float duration)
	{
		if (!m_Audio.isPlaying)
		{
			m_Audio.Play();
		}
		for (float counter = 0f; counter < duration; counter += Time.deltaTime)
		{
			targetVolume = Mathf.Clamp(1f - counter / duration, 0f, maxVol);
			m_Audio.volume = Mathf.Lerp(m_Audio.volume, targetVolume, Time.deltaTime * 5f);
			m_Audio.pitch = Mathf.Clamp(1f - counter / duration, 0.9f, 1.4f);
			yield return Yield.WaitSeconds(Time.deltaTime);
		}
		m_Audio.volume = 0f;
		m_Audio.Pause();
	}
}
public class EchoSFXObject : MonoBehaviour
{
	private AudioScriptPooled audioScript;

	public const string ECHO_TAG = "EchoTrigger";

	[SerializeField]
	private AudioClip echoSFX;

	private void Start()
	{
		if (!base.gameObject.GetComponent<AudioScriptPooled>())
		{
			audioScript = base.gameObject.AddComponent<AudioScriptPooled>();
		}
		else
		{
			audioScript = base.gameObject.GetComponent<AudioScriptPooled>();
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.tag == "EchoTrigger")
		{
			PlaySound();
		}
	}

	public void PlaySound()
	{
		if (audioScript != null)
		{
			audioScript.SetMixerChannel(AudioScript.MixerChannel.sfx);
		}
		else
		{
			audioScript.SetMixerChannel(AudioScript.MixerChannel.sfx);
		}
		if (echoSFX != null)
		{
			audioScript.PlayOneShot(echoSFX);
		}
	}
}
public class Elevator : MonoBehaviour
{
	[SerializeField]
	private Material elevatorMaterial;

	[SerializeField]
	private float[] elevatorPositions;

	[SerializeField]
	public NVRInteractableItem floorButtons;

	[SerializeField]
	public GameObject floor;

	[SerializeField]
	public GameObject floor2Gate;

	[SerializeField]
	private Animator elevatorAnimator;

	public LightFlicker elevatorLight;

	[SerializeField]
	private ParticleSystem initialParticles;

	[SerializeField]
	private ParticleSystem[] dropParticles;

	[SerializeField]
	private ParticleSystem dustParticles;

	[SerializeField]
	private ParticleSystem landParticles;

	public Transform[] parentTriggerZones;

	[SerializeField]
	private Transform firstFloorParentTrigger;

	[SerializeField]
	private GameObject navBlock;

	[SerializeField]
	private AnimationClip secondFloorClip;

	[SerializeField]
	private GameObject liftButtonsTrigger;

	[SerializeField]
	private GameObject hazmatMan;

	[SerializeField]
	private GameObject oobLiftTop;

	[SerializeField]
	private GameObject floorCollider;

	[HideInInspector]
	public bool isMoving;

	[HideInInspector]
	public bool isWorking;

	[HideInInspector]
	public bool floorSelected;

	[HideInInspector]
	public bool insideLift;

	[HideInInspector]
	public ElevatorWheelChair medChair;

	[Space]
	[Header("Audio")]
	[SerializeField]
	private AudioScript audioScriptMain;

	[SerializeField]
	private AudioScriptPooled audioScriptPool;

	[SerializeField]
	private AudioClip clipMove2ndFloor;

	[SerializeField]
	private AudioClip clipIdleMain;

	[SerializeField]
	private AudioClip clipSnappedCable;

	[SerializeField]
	private AudioClip clipSnappedCableDrop;

	[SerializeField]
	private AudioClip clipFall;

	private void Start()
	{
		hazmatMan.SetActive(value: false);
		floor2Gate.SetActive(value: false);
		SetAccessGranted(accessGranted: false);
		navBlock.SetActive(value: false);
		elevatorMaterial.SetColor("_EmissionColor", UnityEngine.Color.red);
	}

	public void SetAccessGranted(bool accessGranted)
	{
		if (accessGranted)
		{
			elevatorMaterial.SetColor("_EmissionColor", UnityEngine.Color.green);
			isWorking = true;
		}
		else
		{
			elevatorMaterial.SetColor("_EmissionColor", UnityEngine.Color.red);
			isWorking = false;
		}
	}

	public void MoveElevator(int elevatorPosition, bool working = false)
	{
		switch (elevatorPosition)
		{
		case 0:
		{
			Vector3 localPosition = new Vector3(base.gameObject.transform.localPosition.x, elevatorPositions[elevatorPosition], base.gameObject.transform.localPosition.z);
			base.gameObject.transform.localPosition = localPosition;
			break;
		}
		case 1:
			if ((bool)medChair)
			{
				medChair.DisableChair();
			}
			elevatorAnimator.SetTrigger("SecondFloor");
			audioScriptPool.Play(clipMove2ndFloor);
			StartCoroutine(NavBlockLiftRoutine(secondFloorClip.length));
			break;
		case 2:
			if ((bool)medChair)
			{
				medChair.DisableChair();
			}
			floorCollider.SetActive(value: false);
			elevatorAnimator.SetTrigger("Drop01");
			initialParticles.Play();
			audioScriptPool.Play(clipSnappedCable);
			break;
		case 3:
			StartCoroutine(PlayTensionAudio());
			break;
		}
		isWorking = working;
	}

	private IEnumerator NavBlockLiftRoutine(float time)
	{
		floorCollider.SetActive(value: false);
		parentTriggerZones[1].gameObject.SetActive(value: false);
		oobLiftTop.SetActive(value: false);
		navBlock.SetActive(value: true);
		yield return Yield.WaitSeconds(time);
		navBlock.SetActive(value: false);
		hazmatMan.SetActive(value: false);
		parentTriggerZones[1].gameObject.SetActive(value: true);
		floorCollider.SetActive(value: true);
	}

	private IEnumerator PlayTensionAudio(float vol = 1f)
	{
		audioScriptPool.Play(clipSnappedCableDrop);
		yield return Yield.WaitSeconds(1f);
		elevatorAnimator.SetTrigger("Drop02");
		PlayParticles();
		audioScriptMain.Play(clipFall, vol);
		yield return Yield.WaitSeconds(1.85f);
		landParticles.Play();
		initialParticles.Play();
		elevatorMaterial.SetColor("_EmissionColor", UnityEngine.Color.black);
		liftButtonsTrigger.SetActive(value: false);
	}

	private void PlayParticles()
	{
		dustParticles.Play();
		for (int i = 0; i < dropParticles.Length; i++)
		{
			dropParticles[i].Play();
		}
	}

	public void DisableParentedObjects()
	{
		firstFloorParentTrigger.gameObject.SetActive(value: false);
		Transform[] array = parentTriggerZones;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].gameObject.SetActive(value: false);
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject.name == "CenterEyePoint")
		{
			insideLift = true;
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (other.gameObject.name == "CenterEyePoint")
		{
			insideLift = false;
		}
	}

	public void FloorButtonPressed()
	{
		floorSelected = true;
	}
}
public class ElevatorWheelChair : WheelChair
{
	[SerializeField]
	private NVRInteractable nvr;

	[SerializeField]
	private Elevator elevator;

	private string[] triggerNames;

	protected override void Start()
	{
		base.Start();
		triggerNames = new string[elevator.parentTriggerZones.Length];
		for (int i = 0; i < triggerNames.Length; i++)
		{
			triggerNames[i] = elevator.parentTriggerZones[i].name;
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (Array.Exists(triggerNames, (string e) => e == other.name))
		{
			elevator.medChair = this;
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (Array.Exists(triggerNames, (string e) => e == other.name))
		{
			elevator.medChair = null;
		}
	}

	public void DisableChair()
	{
		if ((bool)nvr)
		{
			ConfigurableJoint component = GetComponent<ConfigurableJoint>();
			if ((bool)component)
			{
				component.yMotion = ConfigurableJointMotion.Free;
			}
			nvr.CanAttach = false;
			nvr.enabled = false;
			rb.isKinematic = true;
			base.transform.parent = elevator.parentTriggerZones[0];
		}
	}
}
public class ExorcismItem : NVRInteractableItem
{
	public enum ExItemType
	{
		SALT,
		CROSS,
		CANDLE,
		HOLYWATER,
		LIGHTER
	}

	public Vector3 originalPos;

	public Quaternion originalRot;

	public Transform parentTransform;

	public float distToObject;

	public float defaultRespawnTimer = 5f;

	public float respawnTimer = 5f;

	private float elaspedTime;

	public bool inHand;

	public bool inKit = true;

	public bool inEnvironment;

	public GameObject saltFull;

	public GameObject saltHalf;

	public GameObject lighterFull;

	public GameObject lighterHalf;

	public bool kitOpen;

	public ExItemType type;

	public HolyWater holyWaterScript;

	public Candle candleScript;

	public OilLighter lighterScript;

	public SaltSprayer saltScript;

	public TuneController tuneController;

	[SerializeField]
	private AudioClip addedToExKitSFX;

	[SerializeField]
	private AudioClip removedFromExKitSFX;

	[SerializeField]
	private AudioScript audioSource;

	private bool fading;

	public UnityEngine.UI.Image kitLabel;

	[SerializeField]
	private bool forceKitUI;

	public bool SpawnSecondWater;

	public bool isInitilised;

	private bool dontDestroy;

	protected override void Start()
	{
		base.Start();
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		ignoreInteractableTrigger = true;
		originalPos = base.transform.localPosition;
		originalRot = base.transform.localRotation;
		parentTransform = base.transform.parent;
		if (type == ExItemType.HOLYWATER)
		{
			holyWaterScript = GetComponent<HolyWater>();
		}
		else if (type == ExItemType.CANDLE)
		{
			candleScript = GetComponent<Candle>();
		}
		else if (type == ExItemType.LIGHTER)
		{
			lighterScript = GetComponent<OilLighter>();
		}
		else if (type == ExItemType.SALT)
		{
			saltScript = GetComponent<SaltSprayer>();
		}
		else if (type == ExItemType.CROSS)
		{
			tuneController = GetComponent<TuneController>();
		}
		SwitchToStandardShader();
		defaultRespawnTimer = respawnTimer;
		if (forceKitUI)
		{
			kitLabel.color = new UnityEngine.Color(kitLabel.color.r, kitLabel.color.g, kitLabel.color.b, 1f);
		}
		isInitilised = true;
	}

	public override void BeginInteraction(NVRHand hand, bool runBeginInteractionCallback = true)
	{
		if (fading)
		{
			return;
		}
		if (inKit)
		{
			if (!hand.IsPrimary)
			{
				return;
			}
			if (removedFromExKitSFX != null)
			{
				audioSource.PlayOne(removedFromExKitSFX, 0.6f);
			}
		}
		dontDestroy = false;
		inKit = false;
		inHand = true;
		base.BeginInteraction(hand, runBeginInteractionCallback);
		ignoreInteractableTrigger = false;
		if (base.transform.parent != null)
		{
			base.transform.parent = null;
		}
		if (type == ExItemType.HOLYWATER)
		{
			Rigidbody.isKinematic = false;
		}
		else if (type == ExItemType.SALT)
		{
			saltScript.RemovedFromKit();
			if ((bool)saltFull)
			{
				saltFull.SetActive(value: true);
			}
			if ((bool)saltHalf)
			{
				saltHalf.SetActive(value: false);
			}
		}
		else if (type == ExItemType.LIGHTER)
		{
			if ((bool)lighterFull)
			{
				lighterFull.SetActive(value: true);
			}
			if ((bool)lighterHalf)
			{
				lighterHalf.SetActive(value: false);
			}
		}
		else if (type == ExItemType.CANDLE)
		{
			candleScript.TurnOn();
		}
		elaspedTime = 0f;
	}

	public void ForceSnapBack()
	{
		if (!kitOpen)
		{
			return;
		}
		if (type == ExItemType.HOLYWATER)
		{
			HolyWater component = GetComponent<HolyWater>();
			if ((bool)component && component.hasSmashed)
			{
				holyWaterScript.HardReset();
			}
		}
		if (addedToExKitSFX != null)
		{
			audioSource.PlayOne(addedToExKitSFX, 0.6f);
		}
		base.transform.parent = parentTransform;
		Rigidbody.useGravity = false;
		Rigidbody.isKinematic = true;
		ignoreInteractableTrigger = true;
		inKit = true;
		base.transform.localPosition = originalPos;
		base.transform.localRotation = originalRot;
		if (type == ExItemType.SALT)
		{
			saltScript.PlacedInKit();
			if ((bool)saltFull)
			{
				saltFull.SetActive(value: false);
			}
			if ((bool)saltHalf)
			{
				saltHalf.SetActive(value: true);
			}
		}
		else if (type == ExItemType.LIGHTER)
		{
			lighterScript.PlacedInKit();
			if ((bool)lighterFull)
			{
				lighterFull.SetActive(value: false);
			}
			if ((bool)lighterHalf)
			{
				lighterHalf.SetActive(value: true);
			}
		}
		else if (type == ExItemType.CANDLE)
		{
			candleScript.TurnOff();
		}
		else if (type == ExItemType.HOLYWATER && SpawnSecondWater)
		{
			NVRPlayer component2 = GameObject.FindGameObjectWithTag("Player").GetComponent<NVRPlayer>();
			component2.HandMenu.exKitScript.water2.GetComponent<ExorcismItem>().inKit = true;
			component2.HandMenu.exKitScript.water2.GetComponent<ExorcismItem>().inEnvironment = false;
			component2.HandMenu.exKitScript.water2.gameObject.SetActive(value: true);
			SpawnSecondWater = false;
		}
	}

	public void SnapBack()
	{
		if (Vector3.Distance(base.transform.position, parentTransform.position) < distToObject && kitOpen)
		{
			if (addedToExKitSFX != null)
			{
				audioSource.PlayOne(addedToExKitSFX, 0.6f);
			}
			ignoreInteractableTrigger = true;
			inKit = true;
			base.transform.parent = parentTransform;
			base.transform.localPosition = originalPos;
			base.transform.localRotation = originalRot;
			if (type == ExItemType.SALT)
			{
				saltScript.PlacedInKit();
				if ((bool)saltFull)
				{
					saltFull.SetActive(value: false);
				}
				if ((bool)saltHalf)
				{
					saltHalf.SetActive(value: true);
				}
			}
			else if (type == ExItemType.LIGHTER)
			{
				lighterScript.PlacedInKit();
				if ((bool)lighterFull)
				{
					lighterFull.SetActive(value: false);
				}
				if ((bool)lighterHalf)
				{
					lighterHalf.SetActive(value: true);
				}
			}
			else if (type == ExItemType.CANDLE)
			{
				candleScript.TurnOff();
			}
			else if (type == ExItemType.HOLYWATER && SpawnSecondWater)
			{
				NVRPlayer player = GameController.instance.player;
				player.HandMenu.exKitScript.water2.GetComponent<ExorcismItem>().inKit = true;
				player.HandMenu.exKitScript.water2.GetComponent<ExorcismItem>().inEnvironment = false;
				player.HandMenu.exKitScript.water2.gameObject.SetActive(value: true);
				SpawnSecondWater = false;
			}
			inKit = true;
		}
		else
		{
			Rigidbody.useGravity = true;
			Rigidbody.isKinematic = false;
		}
		inHand = false;
		if (base.gameObject.activeInHierarchy)
		{
			StartCoroutine(FadeKitUI(0f, 0.25f));
		}
	}

	private IEnumerator FadeKitUI(float fadeAmount, float fadeDuration)
	{
		if (fadeAmount < kitLabel.color.a)
		{
			float a = kitLabel.color.a;
			while (a > fadeAmount && !forceKitUI)
			{
				kitLabel.color = new UnityEngine.Color(kitLabel.color.r, kitLabel.color.g, kitLabel.color.b, a);
				yield return Yield.EndOfFrame;
				a -= Time.deltaTime / fadeDuration;
			}
		}
		else
		{
			for (float a = kitLabel.color.a; a < fadeAmount; a += Time.deltaTime / fadeDuration)
			{
				if (!base.AttachedHand)
				{
					break;
				}
				if (forceKitUI)
				{
					break;
				}
				kitLabel.color = new UnityEngine.Color(kitLabel.color.r, kitLabel.color.g, kitLabel.color.b, a);
				yield return Yield.EndOfFrame;
			}
		}
		if (!forceKitUI)
		{
			kitLabel.color = new UnityEngine.Color(kitLabel.color.r, kitLabel.color.g, kitLabel.color.b, fadeAmount);
		}
	}

	public void setForceKitUI(bool setting)
	{
		forceKitUI = setting;
		if (forceKitUI)
		{
			kitLabel.color = new UnityEngine.Color(kitLabel.color.r, kitLabel.color.g, kitLabel.color.b, 1f);
		}
	}

	private new void Update()
	{
		if (Input.GetKeyDown(KeyCode.V))
		{
			SnapBack();
		}
		if ((bool)base.AttachedHand)
		{
			if (type == ExItemType.SALT && (base.AttachedHand.IsPrimary ? ControlsManager.instance.interactPrimaryDown : ControlsManager.instance.interactSecondaryDown))
			{
				saltScript.Fire();
			}
			else if (type == ExItemType.LIGHTER && (base.AttachedHand.IsPrimary ? ControlsManager.instance.interactPrimaryDown : ControlsManager.instance.interactSecondaryDown) && !lighterScript.transitioningState)
			{
				lighterScript.TurnOn();
			}
			if (Vector3.Distance(base.transform.position, parentTransform.position) < distToObject && kitLabel.color.a == 0f)
			{
				StartCoroutine(FadeKitUI(1f, 1f));
			}
			else if (Vector3.Distance(base.transform.position, parentTransform.position) > distToObject * 1.25f && kitLabel.color.a == 1f)
			{
				StartCoroutine(FadeKitUI(0f, 1f));
			}
		}
		if (!inKit && !inEnvironment)
		{
			if (elaspedTime > respawnTimer)
			{
				if (type == ExItemType.LIGHTER)
				{
					if (!lighterScript.isOn)
					{
						StartCoroutine(RespawnItem(1f));
					}
				}
				else
				{
					StartCoroutine(RespawnItem(1f));
				}
			}
			if (inHand)
			{
				elaspedTime = 0f;
			}
			else
			{
				elaspedTime += Time.deltaTime;
			}
		}
		if (!inKit && !dontDestroy)
		{
			UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
			dontDestroy = true;
		}
	}

	private void SwitchToStandardShader()
	{
		if (type == ExItemType.HOLYWATER)
		{
			holyWaterScript.SetStandardShader();
		}
		else if (type == ExItemType.LIGHTER)
		{
			lighterScript.SetStandardShader();
		}
		else if (type == ExItemType.SALT)
		{
			saltScript.SetStandardShader();
		}
		else if (type == ExItemType.CROSS)
		{
			tuneController.SetStandardShader();
		}
	}

	private void SwitchToDissolveShader()
	{
		if (type == ExItemType.HOLYWATER)
		{
			holyWaterScript.SetDissolveShader();
		}
		else if (type == ExItemType.LIGHTER)
		{
			lighterScript.SetDissolveShader();
		}
		else if (type == ExItemType.SALT)
		{
			saltScript.SetDissolveShader();
		}
		else if (type == ExItemType.CROSS)
		{
			tuneController.SetDissolveShader();
		}
	}

	public IEnumerator RespawnItem(float time)
	{
		ignoreInteractableTrigger = true;
		fading = true;
		elaspedTime = 0f;
		CanAttach = false;
		respawnTimer = defaultRespawnTimer;
		SwitchToDissolveShader();
		if (time > 0f)
		{
			if (type == ExItemType.HOLYWATER)
			{
				yield return StartCoroutine(holyWaterScript.StartFadeOut(time));
			}
			else if (type == ExItemType.LIGHTER)
			{
				yield return StartCoroutine(lighterScript.StartFadeOut(time));
			}
			else if (type == ExItemType.SALT)
			{
				yield return StartCoroutine(saltScript.StartFadeOut(time));
			}
			else if (type == ExItemType.CROSS)
			{
				yield return StartCoroutine(tuneController.StartFadeOut(time));
			}
		}
		if (type == ExItemType.CANDLE)
		{
			candleScript.TurnOff();
			while (candleScript.isOn)
			{
				yield return null;
			}
		}
		Rigidbody.useGravity = false;
		Rigidbody.isKinematic = true;
		originalParent = parentTransform;
		base.transform.parent = parentTransform;
		base.transform.localPosition = originalPos;
		base.transform.localRotation = originalRot;
		if (type == ExItemType.HOLYWATER)
		{
			if (SpawnSecondWater)
			{
				NVRPlayer component = GameObject.FindGameObjectWithTag("Player").GetComponent<NVRPlayer>();
				component.HandMenu.exKitScript.water2.GetComponent<ExorcismItem>().inKit = true;
				component.HandMenu.exKitScript.water2.GetComponent<ExorcismItem>().inEnvironment = false;
				if (kitOpen)
				{
					component.HandMenu.exKitScript.water2.gameObject.SetActive(value: true);
				}
				SpawnSecondWater = false;
			}
			holyWaterScript.HardReset();
		}
		else if (type == ExItemType.SALT)
		{
			saltScript.HardReset();
			if ((bool)saltFull)
			{
				saltFull.SetActive(value: false);
			}
			if ((bool)saltHalf)
			{
				saltHalf.SetActive(value: true);
			}
		}
		else if (type == ExItemType.LIGHTER)
		{
			lighterScript.HardReset();
			if ((bool)lighterFull)
			{
				lighterFull.SetActive(value: false);
			}
			if ((bool)lighterHalf)
			{
				lighterHalf.SetActive(value: true);
			}
		}
		if (!kitOpen)
		{
			base.gameObject.SetActive(value: false);
		}
		SwitchToStandardShader();
		GameController.instance.player.RightHand.CurrentlyHoveringOver.Remove(this);
		GameController.instance.player.LeftHand.CurrentlyHoveringOver.Remove(this);
		inKit = true;
		CanAttach = true;
		fading = false;
	}

	private void OnDisable()
	{
		if (fading)
		{
			ForceSnapBack();
			SwitchToStandardShader();
		}
		GameController.instance.player.LeftHand.CurrentlyHoveringOver.Remove(this);
		GameController.instance.player.RightHand.CurrentlyHoveringOver.Remove(this);
		if (!GameController.instance.player.LeftHand.IsInteracting)
		{
			GameController.instance.player.LeftHand.SetAnimation("IdleBool");
		}
		if (!GameController.instance.player.RightHand.IsInteracting)
		{
			GameController.instance.player.RightHand.SetAnimation("IdleBool");
		}
		CanAttach = true;
		fading = false;
	}
}
public class ExorcismKit : MonoBehaviour
{
	[SerializeField]
	private AudioClip close;

	[SerializeField]
	private AudioClip open;

	[SerializeField]
	private AudioScript audioScript;

	public GameObject caseLid;

	public GameObject caseDrawer;

	[SerializeField]
	private ExorcismItem[] items;

	public GameObject cross;

	public GameObject salt;

	public GameObject water1;

	public GameObject water2;

	public GameObject candle;

	private float animTime = 0.5f;

	public CanvasGroup KitUI;

	[HideInInspector]
	public bool animating;

	private void Start()
	{
		cross = items[0].gameObject;
	}

	public void OpenKit()
	{
		if (!animating)
		{
			audioScript.PlayOne(open);
			StartCoroutine(Open());
		}
	}

	public void SwapOutHolyWater()
	{
		HolyWater component = water1.GetComponent<HolyWater>();
		HolyWater component2 = water2.GetComponent<HolyWater>();
		component.isSourceOfNile = true;
		component.setupLiquid();
		component2.isSourceOfNile = true;
		component2.setupLiquid();
	}

	public void SwapOutLighterFuel()
	{
		candle.GetComponent<OilLighter>().UpgradeFuel(upgrade: true);
	}

	public void UpgradeSaltSprayer()
	{
		salt.GetComponent<SaltSprayer>().UpgradeSaltSprayer(upgrade: true);
	}

	public void UpgradeCross()
	{
		cross.GetComponent<TuneController>().UpgradeCross(upgrade: true);
	}

	private IEnumerator Open()
	{
		animating = true;
		ExorcismItem[] array = items;
		foreach (ExorcismItem exorcismItem in array)
		{
			if (exorcismItem.inKit)
			{
				exorcismItem.gameObject.SetActive(value: true);
			}
			exorcismItem.kitOpen = true;
		}
		LeanTween.cancel(base.gameObject);
		LeanTween.rotateLocal(caseLid, new Vector3(0f, 0f, -120f), animTime);
		LeanTween.moveLocalX(caseDrawer, -0.1474f, animTime);
		yield return Yield.WaitSeconds(animTime * 0.8f);
		LeanTween.alphaCanvas(KitUI, 1f, animTime * 0.2f);
		if (water1.GetComponent<ExorcismItem>().inKit)
		{
			LeanTween.moveLocalY(water1, 0.005f, animTime * 0.2f);
		}
		if (water2.GetComponent<ExorcismItem>().inKit)
		{
			LeanTween.moveLocalY(water2, 0.005f, animTime * 0.2f);
		}
		yield return Yield.WaitSeconds(animTime * 0.2f);
		animating = false;
	}

	public void CloseKit(bool instantly, bool ignoreAnimation = false)
	{
		if (!animating || ignoreAnimation)
		{
			if (instantly)
			{
				StartCoroutine(Close(0f));
			}
			else
			{
				StartCoroutine(Close(animTime));
			}
		}
	}

	private IEnumerator Close(float time)
	{
		animating = true;
		LeanTween.cancel(base.gameObject);
		LeanTween.alphaCanvas(KitUI, 0f, 0.1f);
		if (water1.GetComponent<ExorcismItem>().inKit)
		{
			LeanTween.moveLocalY(water1, 0.002f, animTime * 0.2f);
		}
		if (water2.GetComponent<ExorcismItem>().inKit)
		{
			LeanTween.moveLocalY(water2, 0.002f, animTime * 0.2f);
		}
		audioScript.PlayOne(close);
		LeanTween.rotateLocal(caseLid, new Vector3(0f, 0f, 0f), time);
		LeanTween.moveLocalX(caseDrawer, -0.1121741f, time);
		yield return Yield.WaitSeconds(time);
		ExorcismItem[] array = items;
		foreach (ExorcismItem exorcismItem in array)
		{
			if (exorcismItem.inKit)
			{
				exorcismItem.gameObject.SetActive(value: false);
			}
			exorcismItem.kitOpen = false;
		}
		animating = false;
	}

	public void ResetItemUpgrades()
	{
		water1.GetComponent<HolyWater>().isSourceOfNile = false;
		water1.GetComponent<HolyWater>().setupLiquid();
		water2.GetComponent<HolyWater>().isSourceOfNile = false;
		water2.GetComponent<HolyWater>().setupLiquid();
		candle.GetComponent<OilLighter>().UpgradeFuel(upgrade: false);
		salt.GetComponent<SaltSprayer>().UpgradeSaltSprayer(upgrade: false);
		cross.GetComponent<TuneController>().UpgradeCross(upgrade: false);
	}
}
public class FallingPigHead : MonoBehaviour
{
	[SerializeField]
	private AudioScript audioScript;

	[SerializeField]
	private AudioClip splatSFX;

	[SerializeField]
	private GameObject bloodPool;

	private void Start()
	{
	}

	private void Update()
	{
	}

	public void OnCollisionEnter(Collision collision)
	{
		if (collision.collider.gameObject.tag == "Floor")
		{
			audioScript.PlayOne(splatSFX);
			bloodPool.transform.position = new Vector3(base.gameObject.transform.position.x, bloodPool.transform.position.y, base.gameObject.transform.position.z);
			bloodPool.transform.localScale = new Vector3(0.5f, 0.5f, 0.5f);
			bloodPool.SetActive(value: true);
			StartCoroutine(increaseBoodPool());
		}
	}

	private IEnumerator increaseBoodPool()
	{
		float scale = 0.5f;
		do
		{
			scale += 0.03f;
			bloodPool.transform.localScale = new Vector3(scale, scale, scale);
			yield return Yield.WaitSeconds(0.3f);
		}
		while (bloodPool.transform.localScale.x < 1f);
	}
}
public class Fanimation : MonoBehaviour
{
	private Vector3 angle;

	private void Start()
	{
		angle = base.transform.localEulerAngles;
	}

	private void Update()
	{
		angle.y += 6f;
		base.transform.localEulerAngles = angle;
	}
}
public class FaultyLightControl : LightFlicker
{
	[SerializeField]
	private ParticleSystem smallSparks;

	[SerializeField]
	private ParticleSystem bigSparks;

	[SerializeField]
	private AudioClip switchSound;

	public void SparkOn()
	{
		StartCoroutine(TurnOnRoutine());
	}

	public void TurnOn()
	{
		m_audio.PlayOneShot(switchSound, 1f);
		SwitchLight(switchOn: true);
	}

	private IEnumerator TurnOnRoutine()
	{
		smallSparks.Play();
		StartCoroutine(Burst(1.5f, finshOn: true));
		yield return Yield.WaitSeconds(1.5f);
		StartBurst(float.PositiveInfinity, finishOn: true);
	}

	public void DestroyLight(float time)
	{
		on = false;
		bigSparks.gameObject.SetActive(value: true);
		bigSparks.Play();
		if (light.intensity > 0f)
		{
			Fade(on: false, time);
		}
	}
}
[RequireComponent(typeof(BoxCollider), typeof(Rigidbody), typeof(ConstantForce))]
public class FeatherScript : MonoBehaviour
{
	[SerializeField]
	[Range(0.01f, 1f)]
	private float m_FloatForce = 0.8f;

	[SerializeField]
	[Range(0.01f, 1f)]
	private float m_SlidePower = 0.2f;

	[SerializeField]
	[Range(0.01f, 1f)]
	private float m_PuffPower = 0.05f;

	[SerializeField]
	[Range(0.01f, 1f)]
	private float m_PuffDelayMin = 0.2f;

	[SerializeField]
	[Range(0.01f, 1f)]
	private float m_PuffDelayMax = 0.3f;

	private Rigidbody m_Rigidbody;

	private BoxCollider m_Collider;

	private Vector3 m_AntigravityForce;

	private float m_LastTime;

	private float m_Delay;

	private Vector3[] m_EdgePoints;

	private Vector3 m_SlideVector;

	private Vector3 m_LastPuffPosition;

	private Vector3 m_LastPuffPower;

	private void Start()
	{
		m_Rigidbody = GetComponent<Rigidbody>();
		m_Collider = GetComponent<BoxCollider>();
		m_AntigravityForce = GetAntigravityForce();
		GetComponent<ConstantForce>().force = m_AntigravityForce * m_FloatForce;
		Vector3 center = m_Collider.center;
		Vector3 vector = m_Collider.size / 2f;
		m_EdgePoints = new Vector3[8]
		{
			new Vector3(0f - vector.x, 0f, vector.z) + center,
			new Vector3(0f, 0f, vector.z) + center,
			new Vector3(vector.x, 0f, vector.z) + center,
			new Vector3(vector.x, 0f, 0f) + center,
			new Vector3(vector.x, 0f, 0f - vector.z) + center,
			new Vector3(0f, 0f, 0f - vector.z) + center,
			new Vector3(0f - vector.x, 0f, 0f - vector.z) + center,
			new Vector3(0f - vector.x, 0f, 0f) + center
		};
	}

	private void Update()
	{
		UpdateSlide();
		UpdatePuffs();
	}

	private void UpdateSlide()
	{
		Vector3 up = base.transform.up;
		m_SlideVector.x = up.x * up.y;
		m_SlideVector.z = up.z * up.y;
		m_SlideVector.y = 0f - up.x * up.x - up.z * up.z;
		m_SlideVector *= m_SlidePower;
		m_Rigidbody.AddForce(m_SlideVector);
	}

	private void UpdatePuffs()
	{
		if (m_LastTime + m_Delay < Time.time)
		{
			Puff();
		}
	}

	private void Puff()
	{
		float num = ((m_Rigidbody.velocity.y < 0f) ? m_Rigidbody.velocity.magnitude : (0f - m_Rigidbody.velocity.magnitude));
		if (!(Mathf.Abs(num) < 0.001f))
		{
			Vector3 puffPosition = GetPuffPosition();
			m_LastPuffPosition = base.transform.InverseTransformPoint(puffPosition);
			Vector3 vector = ((Vector3.Dot(base.transform.up, Vector3.down) > 0f) ? (-Vector3.up) : Vector3.up);
			m_LastPuffPower = vector * m_AntigravityForce.magnitude * m_PuffPower * num / 100f;
			Vector3 force = base.transform.TransformDirection(m_LastPuffPower);
			m_Rigidbody.AddForceAtPosition(force, puffPosition, ForceMode.Impulse);
			m_LastTime = Time.time;
			m_Delay = UnityEngine.Random.Range(m_PuffDelayMin, m_PuffDelayMax);
		}
	}

	private Vector3 GetPuffPosition()
	{
		int num = UnityEngine.Random.Range(0, m_EdgePoints.Length - 1);
		m_LastPuffPosition = m_EdgePoints[num];
		Vector3 vector = base.transform.TransformPoint(m_LastPuffPosition);
		if (!IsLeadingEdge(vector))
		{
			m_LastPuffPosition = m_EdgePoints[(num + m_EdgePoints.Length / 2) % m_EdgePoints.Length];
			vector = base.transform.TransformPoint(m_LastPuffPosition);
		}
		return vector;
	}

	private bool IsLeadingEdge(Vector3 globalPoint)
	{
		Vector3 center = m_Collider.bounds.center;
		return Vector3.Dot(globalPoint - center, m_Rigidbody.velocity) > 0f;
	}

	private Vector3 GetAntigravityForce()
	{
		float num = base.transform.GetComponentsInChildren<Rigidbody>().Sum((Rigidbody rb) => rb.mass);
		return Physics.gravity * num * -1f;
	}

	private void OnDrawGizmos()
	{
		if (m_EdgePoints != null)
		{
			UnityEngine.Debug.DrawRay(base.transform.position, m_SlideVector, UnityEngine.Color.blue);
			Vector3 start = base.transform.TransformPoint(m_LastPuffPosition);
			UnityEngine.Color white = UnityEngine.Color.white;
			float num = Time.time - m_LastTime;
			white.a = 1f - num / m_Delay;
			Vector3 vector = base.transform.TransformDirection(m_LastPuffPower);
			UnityEngine.Debug.DrawRay(start, vector * 10f, white);
			Vector3[] edgePoints = m_EdgePoints;
			foreach (Vector3 position in edgePoints)
			{
				Vector3 center = base.transform.TransformPoint(position);
				Gizmos.color = UnityEngine.Color.white;
				Gizmos.DrawSphere(center, 0.01f);
			}
		}
	}
}
public class Finch : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class FireObstacle : MonoBehaviour
{
	[SerializeField]
	private GameObject[] floorTiles;

	[SerializeField]
	private Vector3[] tileRotations;

	private ParticleSystem[] fireParticles;

	private Light fireLight;

	[SerializeField]
	private GameObject collider;

	[SerializeField]
	private GameObject firePit;

	[SerializeField]
	private LightFlicker fireFlicker;

	private Renderer firePitRender;

	private float lightIntensity;

	private bool active;

	[HideInInspector]
	public bool putOut;

	private AudioScript whispersAudio;

	private AudioScript fireAudio;

	[SerializeField]
	private AudioClip startClip;

	[SerializeField]
	private AudioClip loopClip;

	[SerializeField]
	private AudioClip[] sparksClips;

	[SerializeField]
	private AudioClip dronesClip;

	private int hitCount;

	private bool isSecondFire;

	private void Start()
	{
		fireParticles = GetComponents<ParticleSystem>();
		collider.SetActive(value: false);
		whispersAudio = GetComponent<AudioScript>();
		fireAudio = firePit.AddComponent<AudioScript>();
		fireFlicker.SwitchLight(switchOn: false);
	}

	private void Update()
	{
		if (active)
		{
			int num = UnityEngine.Random.Range(0, 300);
			if (num <= 5)
			{
				num = UnityEngine.Random.Range(0, 3);
				whispersAudio.PlayOne(sparksClips[num], 0.8f);
			}
		}
	}

	public void HitByWater(int increment)
	{
		hitCount += increment;
		if (hitCount == 1)
		{
			LeanTween.moveY(base.gameObject, base.gameObject.transform.position.y - 0.5f, 0.5f);
		}
		if (hitCount >= 2)
		{
			Stop();
		}
	}

	public void Play(bool secondFire)
	{
		isSecondFire = secondFire;
		StartCoroutine(StartFire());
	}

	public void Stop()
	{
		StartCoroutine(StopFire());
	}

	private IEnumerator StartFire()
	{
		if (active)
		{
			yield break;
		}
		active = true;
		whispersAudio.PlayOne(startClip);
		if (isSecondFire)
		{
			for (int i = 0; i < floorTiles.Length; i++)
			{
				floorTiles[i].SetActive(value: false);
			}
		}
		else
		{
			for (int j = 0; j < floorTiles.Length; j++)
			{
				LeanTween.rotateLocal(floorTiles[j], floorTiles[j].transform.localEulerAngles + tileRotations[j] * 35f, 0.2f);
			}
		}
		ParticleSystem[] array = fireParticles;
		for (int k = 0; k < array.Length; k++)
		{
			array[k].Play();
		}
		firePit.SetActive(value: true);
		yield return Yield.WaitSeconds(0.1f);
		fireAudio.PlayLoop(loopClip);
		whispersAudio.PlayLoop(dronesClip, 0.6f);
		fireFlicker.Fade(on: true, 0.25f);
		collider.SetActive(value: true);
	}

	private IEnumerator StopFire()
	{
		whispersAudio.FadeOut(0.2f);
		fireAudio.StopLoop();
		fireAudio.PlayOne(startClip);
		ParticleSystem[] array = fireParticles;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].Stop();
		}
		firePit.SetActive(value: false);
		collider.SetActive(value: false);
		if (isSecondFire)
		{
			for (int j = 0; j < floorTiles.Length; j++)
			{
				floorTiles[j].SetActive(value: true);
			}
		}
		else
		{
			for (int k = 0; k < floorTiles.Length; k++)
			{
				LeanTween.rotateLocal(floorTiles[k], floorTiles[k].transform.localEulerAngles + tileRotations[k] * -35f, 0.05f);
			}
		}
		fireFlicker.Fade(on: false, 0.35f);
		yield return Yield.WaitSeconds(1f);
		putOut = true;
		base.gameObject.SetActive(value: false);
	}
}
public class FireObstacleC5 : MonoBehaviour
{
	public bool active;

	private int _hitCount;

	private bool _isOnFire = true;

	public bool IsOnFire => _isOnFire;

	private void Start()
	{
		base.gameObject.tag = "FireC5";
	}

	public void HitByWater(int increment)
	{
		if (active)
		{
			_hitCount += increment;
			if (_hitCount >= 2)
			{
				_isOnFire = false;
				active = false;
				base.gameObject.SetActive(value: false);
			}
		}
		UnityEngine.Debug.Log("HIT COUNT " + _hitCount);
	}
}
public enum FloorType
{
	WOOD,
	CONCRETE,
	CARPET,
	WOODPLANK,
	METALHOLLOW,
	DIRTSAND
}
public class FloorTag : MonoBehaviour
{
	public FloorType type;
}
public class FollowPath : MonoBehaviour
{
	public enum MovementType
	{
		MoveTowards,
		LerpTowards
	}

	public MovementType Type;

	public MovementPath MyPath;

	public float Speed = 1f;

	public float MaxDistanceToGoal = 0.1f;

	private IEnumerator<Transform> pointInPath;

	public void Start()
	{
		if (MyPath == null)
		{
			UnityEngine.Debug.LogError("Movement Path cannot be null, I must have a path to follow.", base.gameObject);
			return;
		}
		pointInPath = MyPath.GetNextPathPoint();
		UnityEngine.Debug.Log(pointInPath.Current);
		pointInPath.MoveNext();
		UnityEngine.Debug.Log(pointInPath.Current);
		if (pointInPath.Current == null)
		{
			UnityEngine.Debug.LogError("A path must have points in it to follow", base.gameObject);
		}
		else
		{
			base.transform.position = pointInPath.Current.position;
		}
	}

	public void Update()
	{
		if (pointInPath != null && !(pointInPath.Current == null))
		{
			if (Type == MovementType.MoveTowards)
			{
				base.transform.position = Vector3.MoveTowards(base.transform.position, pointInPath.Current.position, Time.deltaTime * Speed);
			}
			else if (Type == MovementType.LerpTowards)
			{
				base.transform.position = Vector3.Lerp(base.transform.position, pointInPath.Current.position, Time.deltaTime * Speed);
			}
			if ((base.transform.position - pointInPath.Current.position).sqrMagnitude < MaxDistanceToGoal * MaxDistanceToGoal)
			{
				pointInPath.MoveNext();
			}
		}
	}
}
public class FrogController : MonoBehaviour
{
	private Animator anim;

	private bool moving;

	private bool animating;

	private bool playingSound;

	[SerializeField]
	private AudioClip sound;

	private AudioScript audio;

	public bool inPosition;

	private void Start()
	{
		anim = GetComponent<Animator>();
		audio = GetComponent<AudioScript>();
	}

	private void FixedUpdate()
	{
		if (!moving && !animating && !playingSound)
		{
			if (UnityEngine.Random.Range(0, 1000) <= 1)
			{
				StartCoroutine(Eat());
			}
			else if (UnityEngine.Random.Range(0, 1000) <= 1)
			{
				StartCoroutine(PlaySound());
			}
		}
	}

	public void StartMoving()
	{
		StartCoroutine(MoveFrog());
	}

	private IEnumerator MoveFrog()
	{
		moving = true;
		for (int i = 0; i < 5; i++)
		{
			anim.SetTrigger("Jump");
			yield return Yield.WaitSeconds(0.05f);
			audio.PlayOne(sound, 0.8f);
			LeanTween.moveX(base.gameObject, base.transform.position.x - 0.5f, 0.2f);
			yield return Yield.WaitSeconds(2f);
		}
		moving = false;
		inPosition = true;
	}

	private IEnumerator Eat()
	{
		animating = true;
		anim.SetTrigger("Eat");
		yield return Yield.WaitSeconds(6f);
		animating = false;
	}

	private IEnumerator PlaySound()
	{
		playingSound = true;
		audio.PlayOne(sound, 0.8f);
		yield return Yield.WaitSeconds(5f);
		playingSound = false;
	}
}
public class FuseboxLeaver : NVRInteractable
{
	protected Vector3 pickupTransforms;

	protected override void Start()
	{
		base.Start();
	}

	public override void BeginInteraction(NVRHand hand, bool runBeginInteractionCallback = true)
	{
		base.BeginInteraction(hand, runBeginInteractionCallback);
		pickupTransforms = hand.transform.position;
	}

	public override void EndInteraction(NVRHand hand)
	{
		base.EndInteraction(hand);
	}

	public override void AddExternalAngularVelocity(Vector3 angularVelocity)
	{
	}

	public override void AddExternalVelocity(Vector3 velocity)
	{
	}
}
public enum SCENES
{
	PERSISTENT,
	PROFILE,
	CALIBRATION,
	ONBOARDING,
	TITLES,
	PRECINCT,
	CHAPEL,
	CELL,
	NURSERY,
	MORGUE,
	TOMB
}
public enum ChapterID
{
	PRECINCT,
	CHAPEL,
	CELL,
	NURSERY,
	MORGUE,
	TOMB
}
public class GameController : MonoBehaviour
{
	public enum GameState
	{
		NONE,
		SPLASH,
		PROFILE,
		CALLIBRATION,
		ONBOARDING,
		TITLES,
		MENU,
		GAME,
		PAUSED
	}

	public static GameController instance;

	public SceneTranslator translator;

	public AudioController audioController;

	public AudioSourcePoolManager audioSourcePool;

	public HintManager hintManager;

	[SerializeField]
	private PersistentScene persistent;

	[SerializeField]
	public AchievementManager achievementManager;

	[SerializeField]
	public LevelCompletionManager levelCompletionManager;

	[HideInInspector]
	public IAPManager IAP;

	[HideInInspector]
	public Room currentRoom;

	[SerializeField]
	public Camera loadingCamera;

	[SerializeField]
	public TextMeshProUGUI introSequenceText;

	[HideInInspector]
	public GameState gameState = GameState.SPLASH;

	public NVRPlayer player;

	private bool isPaused;

	private SCENES currentLevel;

	private string nextLevelString;

	[Space]
	[Header("DEBUG")]
	public bool DebugMode;

	[HideInInspector]
	public bool blockLoad;

	[HideInInspector]
	public bool isLoading;

	[HideInInspector]
	public UnityEngine.AsyncOperation async;

	[HideInInspector]
	public BoundDetection boundDetection;

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
		else if (instance != this)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
		SceneManager.sceneLoaded += FinishedLoading;
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
	}

	private void Start()
	{
		StartCoroutine(StartRoutine());
	}

	private IEnumerator StartRoutine()
	{
		while (!SaveManager.instance.savedDataLoaded)
		{
			yield return Yield.WaitSeconds(0.5f);
		}
		boundDetection = player.boundDetection;
		UnityEngine.Debug.Log("DEPTH TEXTURE MODE: " + player.mainCamera.depthTextureMode);
	}

	private void HeadsetFocusLost()
	{
		isPaused = true;
		Pause();
	}

	private void HeadsetFocusGained()
	{
		isPaused = false;
		UnPause();
	}

	private void RecenterUserView()
	{
		UnityEngine.Debug.Log("Recentered View");
	}

	private void Pause()
	{
		instance.boundDetection.SwitchOffOOB();
		AudioSource[] array = UnityEngine.Object.FindObjectsOfType(typeof(AudioSource)) as AudioSource[];
		for (int i = 0; i < array.Length; i++)
		{
			array[i].pitch = 0f;
		}
		Time.timeScale = 0f;
	}

	private void UnPause()
	{
		AudioSource[] array = UnityEngine.Object.FindObjectsOfType(typeof(AudioSource)) as AudioSource[];
		for (int i = 0; i < array.Length; i++)
		{
			array[i].pitch = 1f;
		}
		Time.timeScale = 1f;
		instance.boundDetection.SwitchOnOOB();
	}

	private void PreferencesLoaded()
	{
		int @int = PreferenceManager.instance.GetInt(PlayerPreferences.GAME_LANGUAGE.ToString());
		PreferenceManager.instance.GetLanguageFromEnum(@int);
	}

	public string GetCurrentScene()
	{
		return GetLevelString(currentLevel);
	}

	public Scene GetCurrentSceneObject()
	{
		return SceneManager.GetSceneByName(GetLevelString(currentLevel));
	}

	public Scene GetPersistentSceneObject()
	{
		return SceneManager.GetSceneByName("Persistent");
	}

	private void removePreviousScene()
	{
		for (int i = 0; i < SceneManager.sceneCount; i++)
		{
			Scene sceneAt = SceneManager.GetSceneAt(i);
			if (sceneAt.name != "Persistent")
			{
				SceneManager.UnloadSceneAsync(sceneAt);
			}
		}
		Resources.UnloadUnusedAssets();
	}

	public void GotoNextScene(bool completedPrev = false)
	{
		if (!isLoading)
		{
			SCENES prevScene = currentLevel;
			removePreviousScene();
			currentLevel++;
			SceneManager.LoadSceneAsync(GetLevelString(currentLevel), LoadSceneMode.Additive);
			isLoading = true;
			persistent.LoadNewScene(currentLevel, prevScene, completedPrev);
		}
	}

	public void GotoPreviousScene(bool completedPrev = false)
	{
		if (!isLoading)
		{
			SCENES prevScene = currentLevel;
			removePreviousScene();
			currentLevel--;
			SceneManager.LoadSceneAsync(GetLevelString(currentLevel), LoadSceneMode.Additive);
			isLoading = true;
			persistent.LoadNewScene(currentLevel, prevScene, completedPrev);
		}
	}

	public void ResetLevel(bool completedPrev = false)
	{
		player.playerAudio.FadeOut(3f);
		audioController.persistentMusicPlayer.FadeOut(3f);
		GoToSpecificScene(currentLevel);
	}

	public void GoToSpecificScene(SCENES newScene, bool completedPrev = false)
	{
		StartCoroutine(LoadScene(newScene, completedPrev));
	}

	private IEnumerator LoadScene(SCENES newScene, bool completedPrev)
	{
		audioSourcePool.ForceAllAudioBackToPool();
		player.screenFX.Fade(UnityEngine.Color.black, 3f);
		audioController.SnapMute(3f);
		yield return Yield.WaitSeconds(3f);
		player.screenFX.BlurScreen(enabled: false);
		player.screenFX.DisableColourGrading();
		player.ForceDropItems();
		player.HandMenu.CloseMenu();
		player.playerLight.shouldLightBeOn = false;
		player.playerLight.GetComponent<LightFlicker>().SwitchLight(switchOn: false);
		if (currentLevel == SCENES.CHAPEL)
		{
			blockLoad = true;
			EventManager.TriggerEvent(EventManager.AvailableEvents.BlockingLoad.ToString());
		}
		while (blockLoad)
		{
			yield return null;
		}
		if (!isLoading)
		{
			SCENES prevScene = currentLevel;
			removePreviousScene();
			currentLevel = newScene;
			async = SceneManager.LoadSceneAsync(GetLevelString(currentLevel), LoadSceneMode.Additive);
			isLoading = true;
			persistent.LoadNewScene(currentLevel, prevScene, completedPrev);
			async.allowSceneActivation = false;
		}
		currentRoom = null;
		if (player.LeftHand.CurrentlyHoveringOver != null)
		{
			player.LeftHand.CurrentlyHoveringOver.Clear();
		}
		if (player.RightHand.CurrentlyHoveringOver != null)
		{
			player.RightHand.CurrentlyHoveringOver.Clear();
		}
	}

	private string GetLevelString(SCENES scene)
	{
		switch (scene)
		{
		case SCENES.PERSISTENT:
			gameState = GameState.GAME;
			return "Persistent";
		case SCENES.CALIBRATION:
			gameState = GameState.CALLIBRATION;
			return "Calibration";
		case SCENES.ONBOARDING:
			gameState = GameState.ONBOARDING;
			return "Onboarding";
		case SCENES.TITLES:
			gameState = GameState.TITLES;
			return "Titles";
		case SCENES.PRECINCT:
			gameState = GameState.GAME;
			return "PolicePrecinctCombined";
		case SCENES.CHAPEL:
			gameState = GameState.GAME;
			return "ChapelCombined";
		case SCENES.CELL:
			gameState = GameState.GAME;
			return "CellCombined";
		case SCENES.NURSERY:
			gameState = GameState.GAME;
			return "NurseryCombined";
		case SCENES.MORGUE:
			gameState = GameState.GAME;
			return "MorgueCombined";
		case SCENES.TOMB:
			gameState = GameState.GAME;
			return "TombCombined";
		default:
			gameState = GameState.GAME;
			return "PolicePrecinctCombined";
		}
	}

	private void FinishedLoading(Scene scene, LoadSceneMode mode)
	{
		isLoading = false;
	}

	public void DebugLog(object message)
	{
	}

	private void OnDisable()
	{
		SceneManager.sceneLoaded -= FinishedLoading;
	}

	public SCENES GetCurrentLevel()
	{
		return currentLevel;
	}

	public bool isUsingAnOculus()
	{
		if (XRDevice.model.IndexOf("oculus", StringComparison.CurrentCultureIgnoreCase) != -1)
		{
			return true;
		}
		return false;
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.A))
		{
			SceneManager.LoadScene("PolicePrecinctCombined");
		}
		if (Input.GetKeyDown(KeyCode.Escape))
		{
			Application.Quit();
		}
	}

	private void OnDestroy()
	{
		Time.timeScale = 1f;
	}
}
[Serializable]
public class GameData
{
	public Chapter[] gameChapters;

	public static string precinctDescription = "A hardened detective turned exorcist.";

	public static string chapelDescription = "A place of worship covered in blood, a notebook filled with writings of demonic possession and the ‘ritualistic murder’ of a priest. Will you answer the call to investigate?";

	public static string cellDescription = "In this chapter you will you come to the aid of Lucie Moss, an ex-schoolteacher who seems to have lost her mind and is set upon by some unseen force.  What torments her?  How can the ancient tools you’ve found aid you in your journey?";

	public static string nurseryDescription = "A wave of infant mortality has struck and a number of distraught parents have posted online, claiming to have heard the sound of an old woman calming the cries of their babies in the weeks before. A copy of one such recording landed on your desk, it’s recent, can you calm the cries before it is too late?";

	public static string morgueDescription = "Haiti has become a failed quarantine zone wrapped in a plague, a slew of health worker deaths and failed foreign intervention has led to the collapse of efforts to control the mounting death toll. What lies at the heart of the epidemic?";

	public static string tombDescription = "In this tense climax, your journey takes you deep into the mountains of Upper Mesopotamia where one last confrontation with an ancient evil will put everything that you have learned to the test.";

	public GameData()
	{
		Environment.SetEnvironmentVariable("MONO_REFLECTION_SERIALIZER", "yes");
	}

	public bool InitialiseWithData()
	{
		int num = Enum.GetNames(typeof(ChapterID)).Length;
		gameChapters = new Chapter[num];
		foreach (ChapterID value in Enum.GetValues(typeof(ChapterID)))
		{
			Chapter chapter = new Chapter();
			chapter.Initialise();
			chapter.chapterID = value;
			chapter.chapterPurchaseId = "";
			if (chapter.chapterID == ChapterID.PRECINCT)
			{
				chapter.available = true;
				chapter.purchased = true;
				chapter.started = false;
				chapter.completed = false;
				chapter.chapterStatus = ChapterStatus.OWNED_NOT_PLAYED;
				chapter.chapterCompletionStatus = ChapterCompletionStatus.BLANK;
				chapter.artifactComplete = false;
				chapter.Name = "Precinct";
				chapter.Description = precinctDescription;
				chapter.FormattedPrice = "";
			}
			else if (chapter.chapterID == ChapterID.CHAPEL)
			{
				chapter.available = true;
				chapter.purchased = true;
				chapter.started = false;
				chapter.completed = false;
				chapter.chapterStatus = ChapterStatus.OWNED_NOT_PLAYED;
				chapter.chapterCompletionStatus = ChapterCompletionStatus.BLANK;
				chapter.artifactComplete = false;
				chapter.Name = "First Rites";
				chapter.Description = chapelDescription;
				chapter.FormattedPrice = "";
			}
			else if (chapter.chapterID == ChapterID.CELL)
			{
				chapter.available = true;
				chapter.purchased = true;
				chapter.started = false;
				chapter.completed = false;
				chapter.chapterStatus = ChapterStatus.OWNED_NOT_PLAYED;
				chapter.chapterCompletionStatus = ChapterCompletionStatus.BLANK;
				chapter.artifactComplete = false;
				chapter.Name = "Idle Hands";
				chapter.Description = cellDescription;
				chapter.FormattedPrice = "";
			}
			else if (chapter.chapterID == ChapterID.NURSERY)
			{
				chapter.available = true;
				chapter.purchased = true;
				chapter.started = false;
				chapter.completed = false;
				chapter.chapterStatus = ChapterStatus.OWNED_NOT_PLAYED;
				chapter.chapterCompletionStatus = ChapterCompletionStatus.BLANK;
				chapter.artifactComplete = false;
				chapter.Name = "Skin Deep";
				chapter.Description = nurseryDescription;
				chapter.FormattedPrice = "";
			}
			else if (chapter.chapterID == ChapterID.MORGUE)
			{
				chapter.available = true;
				chapter.purchased = true;
				chapter.started = false;
				chapter.completed = false;
				chapter.chapterStatus = ChapterStatus.OWNED_NOT_PLAYED;
				chapter.chapterCompletionStatus = ChapterCompletionStatus.BLANK;
				chapter.artifactComplete = false;
				chapter.Name = "Samaritan";
				chapter.Description = morgueDescription;
				chapter.FormattedPrice = "";
			}
			else if (chapter.chapterID == ChapterID.TOMB)
			{
				chapter.available = true;
				chapter.purchased = true;
				chapter.started = false;
				chapter.completed = false;
				chapter.chapterStatus = ChapterStatus.OWNED_NOT_PLAYED;
				chapter.chapterCompletionStatus = ChapterCompletionStatus.BLANK;
				chapter.artifactComplete = false;
				chapter.Name = "The Tomb";
				chapter.Description = tombDescription;
				chapter.FormattedPrice = "";
			}
			else
			{
				chapter.available = false;
				chapter.purchased = false;
				chapter.started = false;
				chapter.completed = false;
				chapter.chapterStatus = ChapterStatus.NOT_OWNED;
				chapter.chapterCompletionStatus = ChapterCompletionStatus.BLANK;
				chapter.artifactComplete = false;
				chapter.Name = "";
				chapter.Description = "";
				chapter.FormattedPrice = "";
			}
			gameChapters[(int)value] = chapter;
		}
		return true;
	}

	public List<byte[]> ConvertChaptersToData()
	{
		List<byte[]> list = new List<byte[]>();
		Chapter[] array = gameChapters;
		foreach (Chapter chapter in array)
		{
			if (chapter != null)
			{
				list.Add(chapter.WriteToBuffer());
			}
		}
		return list;
	}

	public bool ConvertDataToChapters(byte[] chapterData, int totalChapterCount)
	{
		bool result = false;
		Chapter chapter = new Chapter();
		chapter.ReadFromBuffer(chapterData);
		UnityEngine.Debug.Log("Loading chapter from save : " + chapter.Name);
		if (chapter != null)
		{
			result = true;
			chapter.available = true;
		}
		if (gameChapters == null)
		{
			gameChapters = new Chapter[totalChapterCount];
		}
		gameChapters[(int)chapter.chapterID] = chapter;
		return result;
	}
}
public class GrabberArm : MonoBehaviour
{
	private NVRPlayer player;

	private Animator anim;

	public bool hitPlayer;

	[SerializeField]
	private CCDIK IK;

	private float lerpSpeed = 0.1f;

	private bool playerInRange;

	private Quaternion origionalRotation;

	private bool entryAnimComplete;

	private void Awake()
	{
		player = GameObject.FindGameObjectWithTag("Player").GetComponent<NVRPlayer>();
		anim = GetComponent<Animator>();
		if ((bool)IK)
		{
			IK.solver.IKPositionWeight = 0f;
		}
		origionalRotation = base.transform.rotation;
	}

	private IEnumerator WaitForEntry()
	{
		yield return Yield.WaitSeconds(3f);
		entryAnimComplete = true;
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject == player.Head.gameObject && !hitPlayer)
		{
			playerInRange = true;
		}
	}

	private void OnTriggerStay(Collider other)
	{
		if (other.gameObject == player.Head.gameObject && !hitPlayer && Vector3.Distance(base.transform.position, player.Head.gameObject.transform.position) < 1f && entryAnimComplete)
		{
			hitPlayer = true;
			StartCoroutine(Attack());
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (other.gameObject == player.Head.gameObject && !hitPlayer)
		{
			playerInRange = false;
		}
	}

	private void Update()
	{
		if (!hitPlayer)
		{
			if (playerInRange && IK.solver.IKPositionWeight < 0.2f)
			{
				IK.solver.IKPositionWeight = Mathf.Clamp01(IK.solver.IKPositionWeight + Time.deltaTime * lerpSpeed);
			}
			else if (!playerInRange && IK.solver.IKPositionWeight > 0f)
			{
				IK.solver.IKPositionWeight = Mathf.Clamp01(IK.solver.IKPositionWeight - Time.deltaTime * lerpSpeed);
				base.transform.rotation = Quaternion.Lerp(base.transform.rotation, origionalRotation, Time.deltaTime * lerpSpeed * 2f);
			}
		}
	}

	private IEnumerator Attack()
	{
		anim.SetTrigger("MazeGrab");
		switch (UnityEngine.Random.Range(0, 3))
		{
		case 0:
			GameController.instance.audioController.PlayBadSting(STINGS_BAD.BAD_STING_01, 0.5f);
			break;
		case 1:
			GameController.instance.audioController.PlayBadSting(STINGS_BAD.BAD_STING_02, 0.5f);
			break;
		case 2:
			GameController.instance.audioController.PlayBadSting(STINGS_BAD.BAD_STING_03, 0.5f);
			break;
		default:
			GameController.instance.audioController.PlayBadSting(STINGS_BAD.BAD_STING_01, 0.5f);
			break;
		}
		while (IK.solver.IKPositionWeight < 0.95f)
		{
			IK.solver.IKPositionWeight = Mathf.Clamp01(IK.solver.IKPositionWeight + Time.deltaTime * lerpSpeed);
		}
		yield return Yield.WaitSeconds(0.25f);
		player.screenFX.BlurScreen(enabled: true);
		IK.solver.IKPositionWeight = 0f;
		yield return Yield.WaitSeconds(1.25f);
		player.screenFX.BlurScreen(enabled: false);
	}

	private void OnEnable()
	{
		anim.SetTrigger("MazeWait");
		StartCoroutine(WaitForEntry());
	}
}
public class HandPointerDistanceCheck : MonoBehaviour
{
	public float distanceForUse = 1f;
}
public class MathUtils
{
	public static float GetQuatLength(Quaternion q)
	{
		return Mathf.Sqrt(q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w);
	}

	public static Quaternion GetQuatConjugate(Quaternion q)
	{
		return new Quaternion(0f - q.x, 0f - q.y, 0f - q.z, q.w);
	}

	public static Quaternion GetQuatLog(Quaternion q)
	{
		Quaternion result = q;
		result.w = 0f;
		if (Mathf.Abs(q.w) < 1f)
		{
			float num = Mathf.Acos(q.w);
			float num2 = Mathf.Sin(num);
			if ((double)Mathf.Abs(num2) > 0.0001)
			{
				float num3 = num / num2;
				result.x = q.x * num3;
				result.y = q.y * num3;
				result.z = q.z * num3;
			}
		}
		return result;
	}

	public static Quaternion GetQuatExp(Quaternion q)
	{
		Quaternion result = q;
		float num = Mathf.Sqrt(q.x * q.x + q.y * q.y + q.z * q.z);
		float num2 = Mathf.Sin(num);
		result.w = Mathf.Cos(num);
		if ((double)Mathf.Abs(num2) > 0.0001)
		{
			float num3 = num2 / num;
			result.x = num3 * q.x;
			result.y = num3 * q.y;
			result.z = num3 * q.z;
		}
		return result;
	}

	public static Quaternion GetQuatSquad(float t, Quaternion q0, Quaternion q1, Quaternion a0, Quaternion a1)
	{
		float t2 = 2f * t * (1f - t);
		Quaternion p = Slerp(q0, q1, t);
		Quaternion q2 = Slerp(a0, a1, t);
		return Slerp(p, q2, t2);
	}

	public static Quaternion GetSquadIntermediate(Quaternion q0, Quaternion q1, Quaternion q2)
	{
		Quaternion quatConjugate = GetQuatConjugate(q1);
		Quaternion quatLog = GetQuatLog(quatConjugate * q0);
		Quaternion quatLog2 = GetQuatLog(quatConjugate * q2);
		Quaternion q3 = new Quaternion(-0.25f * (quatLog.x + quatLog2.x), -0.25f * (quatLog.y + quatLog2.y), -0.25f * (quatLog.z + quatLog2.z), -0.25f * (quatLog.w + quatLog2.w));
		return q1 * GetQuatExp(q3);
	}

	public static float Ease(float t, float k1, float k2)
	{
		float num = k1 * 2f / (float)Math.PI + k2 - k1 + (1f - k2) * 2f / (float)Math.PI;
		float num2 = ((t < k1) ? (k1 * (2f / (float)Math.PI) * (Mathf.Sin(t / k1 * (float)Math.PI / 2f - (float)Math.PI / 2f) + 1f)) : ((!(t < k2)) ? (2f * k1 / (float)Math.PI + k2 - k1 + (1f - k2) * (2f / (float)Math.PI) * Mathf.Sin((t - k2) / (1f - k2) * (float)Math.PI / 2f)) : (2f * k1 / (float)Math.PI + t - k1)));
		return num2 / num;
	}

	public static Quaternion Slerp(Quaternion p, Quaternion q, float t)
	{
		float num = Quaternion.Dot(p, q);
		Quaternion result = default(Quaternion);
		if ((double)(1f + num) > 1E-05)
		{
			float num4;
			float num5;
			if ((double)(1f - num) > 1E-05)
			{
				float num2 = Mathf.Acos(num);
				float num3 = 1f / Mathf.Sin(num2);
				num4 = Mathf.Sin((1f - t) * num2) * num3;
				num5 = Mathf.Sin(t * num2) * num3;
			}
			else
			{
				num4 = 1f - t;
				num5 = t;
			}
			result.x = num4 * p.x + num5 * q.x;
			result.y = num4 * p.y + num5 * q.y;
			result.z = num4 * p.z + num5 * q.z;
			result.w = num4 * p.w + num5 * q.w;
		}
		else
		{
			float num6 = Mathf.Sin((1f - t) * (float)Math.PI * 0.5f);
			float num7 = Mathf.Sin(t * (float)Math.PI * 0.5f);
			result.x = num6 * p.x - num7 * p.y;
			result.y = num6 * p.y + num7 * p.x;
			result.z = num6 * p.z - num7 * p.w;
			result.w = p.z;
		}
		return result;
	}
}
public enum eOrientationMode
{
	NODE,
	TANGENT
}
[AddComponentMenu("Splines/Spline Controller")]
[RequireComponent(typeof(SplineInterpolator))]
public class SplineController : MonoBehaviour
{
	public GameObject SplineRoot;

	public float Duration = 10f;

	public eOrientationMode OrientationMode;

	public eWrapMode WrapMode;

	public bool AutoStart = true;

	public bool AutoClose = true;

	public bool HideOnExecute = true;

	private SplineInterpolator mSplineInterp;

	private Transform[] mTransforms;

	private void OnDrawGizmos()
	{
		if (Application.isPlaying)
		{
			return;
		}
		Transform[] transforms = GetTransforms();
		if (transforms != null && transforms.Length >= 2)
		{
			SplineInterpolator splineInterpolator = GetComponent(typeof(SplineInterpolator)) as SplineInterpolator;
			SetupSplineInterpolator(splineInterpolator, transforms);
			splineInterpolator.StartInterpolation(null, bRotations: false, WrapMode);
			Vector3 vector = transforms[0].position;
			for (int i = 1; i <= 100; i++)
			{
				float timeParam = (float)i * Duration / 100f;
				Vector3 hermiteAtTime = splineInterpolator.GetHermiteAtTime(timeParam);
				Gizmos.color = new UnityEngine.Color((hermiteAtTime - vector).magnitude * 2f, 0f, 0f, 1f);
				Gizmos.DrawLine(vector, hermiteAtTime);
				vector = hermiteAtTime;
			}
		}
	}

	private void Start()
	{
		mSplineInterp = GetComponent(typeof(SplineInterpolator)) as SplineInterpolator;
		if (mTransforms == null)
		{
			mTransforms = GetTransforms();
		}
		if (HideOnExecute)
		{
			DisableTransforms();
		}
		if (AutoStart)
		{
			FollowSpline();
		}
	}

	private void SetupSplineInterpolator(SplineInterpolator interp, Transform[] trans)
	{
		interp.Reset();
		float num = (AutoClose ? (Duration / (float)trans.Length) : (Duration / (float)(trans.Length - 1)));
		int i;
		for (i = 0; i < trans.Length; i++)
		{
			if (OrientationMode == eOrientationMode.NODE)
			{
				interp.AddPoint(trans[i].position, trans[i].rotation, num * (float)i, new Vector2(0f, 1f));
			}
			else if (OrientationMode == eOrientationMode.TANGENT)
			{
				interp.AddPoint(quat: (i != trans.Length - 1) ? Quaternion.LookRotation(trans[i + 1].position - trans[i].position, trans[i].up) : ((!AutoClose) ? trans[i].rotation : Quaternion.LookRotation(trans[0].position - trans[i].position, trans[i].up)), pos: trans[i].position, timeInSeconds: num * (float)i, easeInOut: new Vector2(0f, 1f));
			}
		}
		if (AutoClose)
		{
			interp.SetAutoCloseMode(num * (float)i);
		}
	}

	public void ShuffleTransforms(Transform startPoint)
	{
		if (!(SplineRoot != null))
		{
			return;
		}
		if (mTransforms == null)
		{
			mTransforms = GetTransforms();
		}
		int num = Array.IndexOf(mTransforms, startPoint);
		if (num > 0)
		{
			if (num == mTransforms.Length - 1)
			{
				mTransforms.Reverse();
				return;
			}
			int num2 = mTransforms.Length - num;
			Transform[] array = new Transform[num];
			Transform[] array2 = new Transform[num2];
			Array.Copy(mTransforms, 0, array, 0, num);
			Array.Copy(mTransforms, num, array2, 0, num2);
			Array.Copy(array2, 0, mTransforms, 0, array2.Length);
			Array.Copy(array, 0, mTransforms, array2.Length, array.Length);
		}
	}

	private Transform[] GetTransforms()
	{
		if (SplineRoot != null)
		{
			List<Transform> list = new List<UnityEngine.Component>(SplineRoot.GetComponentsInChildren(typeof(Transform), includeInactive: true)).ConvertAll((UnityEngine.Component c) => (Transform)c);
			list.Remove(SplineRoot.transform);
			list.Sort((Transform a, Transform b) => a.name.CompareTo(b.name));
			return list.ToArray();
		}
		return null;
	}

	private void DisableTransforms()
	{
		if (SplineRoot != null)
		{
			SplineRoot.SetActive(value: false);
		}
	}

	public void FollowSpline()
	{
		if (mTransforms.Length != 0)
		{
			SetupSplineInterpolator(mSplineInterp, mTransforms);
			mSplineInterp.StartInterpolation(null, bRotations: true, WrapMode);
		}
	}

	public void StopFollowingSpline()
	{
		if (mTransforms.Length != 0)
		{
			mSplineInterp.Reset();
		}
	}
}
public enum eEndPointsMode
{
	AUTO,
	AUTOCLOSED,
	EXPLICIT
}
public enum eWrapMode
{
	ONCE,
	LOOP
}
public delegate void OnEndCallback();
public class SplineInterpolator : MonoBehaviour
{
	internal class SplineNode
	{
		internal Vector3 Point;

		internal Quaternion Rot;

		internal float Time;

		internal Vector2 EaseIO;

		internal SplineNode(Vector3 p, Quaternion q, float t, Vector2 io)
		{
			Point = p;
			Rot = q;
			Time = t;
			EaseIO = io;
		}

		internal SplineNode(SplineNode o)
		{
			Point = o.Point;
			Rot = o.Rot;
			Time = o.Time;
			EaseIO = o.EaseIO;
		}
	}

	private eEndPointsMode mEndPointsMode;

	private List<SplineNode> mNodes = new List<SplineNode>();

	private string mState = "";

	private bool mRotations;

	private OnEndCallback mOnEndCallback;

	private float mCurrentTime;

	private int mCurrentIdx = 1;

	private void Awake()
	{
		Reset();
	}

	public void StartInterpolation(OnEndCallback endCallback, bool bRotations, eWrapMode mode)
	{
		if (mState != "Reset")
		{
			throw new Exception("First reset, add points and then call here");
		}
		mState = ((mode == eWrapMode.ONCE) ? "Once" : "Loop");
		mRotations = bRotations;
		mOnEndCallback = endCallback;
		SetInput();
	}

	public void Reset()
	{
		mNodes.Clear();
		mState = "Reset";
		mCurrentIdx = 1;
		mCurrentTime = 0f;
		mRotations = false;
		mEndPointsMode = eEndPointsMode.AUTO;
	}

	public void AddPoint(Vector3 pos, Quaternion quat, float timeInSeconds, Vector2 easeInOut)
	{
		if (mState != "Reset")
		{
			throw new Exception("Cannot add points after start");
		}
		mNodes.Add(new SplineNode(pos, quat, timeInSeconds, easeInOut));
	}

	private void SetInput()
	{
		if (mNodes.Count < 2)
		{
			throw new Exception("Invalid number of points");
		}
		if (mRotations)
		{
			for (int i = 1; i < mNodes.Count; i++)
			{
				SplineNode splineNode = mNodes[i];
				SplineNode splineNode2 = mNodes[i - 1];
				if (Quaternion.Dot(splineNode.Rot, splineNode2.Rot) < 0f)
				{
					splineNode.Rot.x = 0f - splineNode.Rot.x;
					splineNode.Rot.y = 0f - splineNode.Rot.y;
					splineNode.Rot.z = 0f - splineNode.Rot.z;
					splineNode.Rot.w = 0f - splineNode.Rot.w;
				}
			}
		}
		if (mEndPointsMode == eEndPointsMode.AUTO)
		{
			mNodes.Insert(0, mNodes[0]);
			mNodes.Add(mNodes[mNodes.Count - 1]);
		}
		else if (mEndPointsMode == eEndPointsMode.EXPLICIT && mNodes.Count < 4)
		{
			throw new Exception("Invalid number of points");
		}
	}

	private void SetExplicitMode()
	{
		if (mState != "Reset")
		{
			throw new Exception("Cannot change mode after start");
		}
		mEndPointsMode = eEndPointsMode.EXPLICIT;
	}

	public void SetAutoCloseMode(float joiningPointTime)
	{
		if (mState != "Reset")
		{
			throw new Exception("Cannot change mode after start");
		}
		mEndPointsMode = eEndPointsMode.AUTOCLOSED;
		mNodes.Add(new SplineNode(mNodes[0]));
		mNodes[mNodes.Count - 1].Time = joiningPointTime;
		Vector3 normalized = (mNodes[1].Point - mNodes[0].Point).normalized;
		Vector3 normalized2 = (mNodes[mNodes.Count - 2].Point - mNodes[mNodes.Count - 1].Point).normalized;
		float magnitude = (mNodes[1].Point - mNodes[0].Point).magnitude;
		float magnitude2 = (mNodes[mNodes.Count - 2].Point - mNodes[mNodes.Count - 1].Point).magnitude;
		SplineNode splineNode = new SplineNode(mNodes[0]);
		splineNode.Point = mNodes[0].Point + normalized2 * magnitude;
		SplineNode splineNode2 = new SplineNode(mNodes[mNodes.Count - 1]);
		splineNode2.Point = mNodes[0].Point + normalized * magnitude2;
		mNodes.Insert(0, splineNode);
		mNodes.Add(splineNode2);
	}

	private void Update()
	{
		if (mState == "Reset" || mState == "Stopped" || mNodes.Count < 4)
		{
			return;
		}
		mCurrentTime += Time.deltaTime;
		if (mCurrentTime >= mNodes[mCurrentIdx + 1].Time)
		{
			if (mCurrentIdx < mNodes.Count - 3)
			{
				mCurrentIdx++;
			}
			else if (mState != "Loop")
			{
				mState = "Stopped";
				base.transform.position = mNodes[mNodes.Count - 2].Point;
				if (mRotations)
				{
					base.transform.rotation = mNodes[mNodes.Count - 2].Rot;
				}
				if (mOnEndCallback != null)
				{
					mOnEndCallback();
				}
			}
			else
			{
				mCurrentIdx = 1;
				mCurrentTime = 0f;
			}
		}
		if (mState != "Stopped")
		{
			float t = (mCurrentTime - mNodes[mCurrentIdx].Time) / (mNodes[mCurrentIdx + 1].Time - mNodes[mCurrentIdx].Time);
			t = MathUtils.Ease(t, mNodes[mCurrentIdx].EaseIO.x, mNodes[mCurrentIdx].EaseIO.y);
			base.transform.position = GetHermiteInternal(mCurrentIdx, t);
			if (mRotations)
			{
				base.transform.rotation = GetSquad(mCurrentIdx, t);
			}
		}
	}

	private Quaternion GetSquad(int idxFirstPoint, float t)
	{
		Quaternion rot = mNodes[idxFirstPoint - 1].Rot;
		Quaternion rot2 = mNodes[idxFirstPoint].Rot;
		Quaternion rot3 = mNodes[idxFirstPoint + 1].Rot;
		Quaternion rot4 = mNodes[idxFirstPoint + 2].Rot;
		Quaternion squadIntermediate = MathUtils.GetSquadIntermediate(rot, rot2, rot3);
		Quaternion squadIntermediate2 = MathUtils.GetSquadIntermediate(rot2, rot3, rot4);
		return MathUtils.GetQuatSquad(t, rot2, rot3, squadIntermediate, squadIntermediate2);
	}

	public Vector3 GetHermiteInternal(int idxFirstPoint, float t)
	{
		float num = t * t;
		float num2 = num * t;
		Vector3 point = mNodes[idxFirstPoint - 1].Point;
		Vector3 point2 = mNodes[idxFirstPoint].Point;
		Vector3 point3 = mNodes[idxFirstPoint + 1].Point;
		Vector3 point4 = mNodes[idxFirstPoint + 2].Point;
		Vector3 vector = 0.5f * (point3 - point);
		Vector3 vector2 = 0.5f * (point4 - point2);
		float num3 = 2f * num2 - 3f * num + 1f;
		float num4 = -2f * num2 + 3f * num;
		float num5 = num2 - 2f * num + t;
		float num6 = num2 - num;
		return num3 * point2 + num4 * point3 + num5 * vector + num6 * vector2;
	}

	public Vector3 GetHermiteAtTime(float timeParam)
	{
		if (timeParam >= mNodes[mNodes.Count - 2].Time)
		{
			return mNodes[mNodes.Count - 2].Point;
		}
		int i;
		for (i = 1; i < mNodes.Count - 2 && !(mNodes[i].Time > timeParam); i++)
		{
		}
		int num = i - 1;
		float t = (timeParam - mNodes[num].Time) / (mNodes[num + 1].Time - mNodes[num].Time);
		t = MathUtils.Ease(t, mNodes[num].EaseIO.x, mNodes[num].EaseIO.y);
		return GetHermiteInternal(num, t);
	}
}
public class HintManager : MonoBehaviour
{
	private List<NVRInteractableItem> hintItems = new List<NVRInteractableItem>();

	private void Start()
	{
		EventManager.StartListening(EventManager.AvailableEvents.StartedLoading.ToString(), ClearHints);
	}

	private void ClearHints()
	{
		hintItems.Clear();
	}

	public void ShowHints()
	{
		StartCoroutine(ShowHints(10f));
	}

	private IEnumerator ShowHints(float time)
	{
		for (int i = 0; i < hintItems.Count; i++)
		{
			hintItems[i].HighlightItem(highlight: true);
		}
		yield return Yield.WaitSeconds(time);
		for (int j = 0; j < hintItems.Count; j++)
		{
			hintItems[j].HighlightItem(highlight: false);
		}
	}

	public void AddHint(NVRInteractableItem item)
	{
		hintItems.Add(item);
	}

	public void AddHint(GameObject obj)
	{
		NVRInteractableItem component = obj.GetComponent<NVRInteractableItem>();
		if (component != null)
		{
			AddHint(component);
		}
		else
		{
			UnityEngine.Debug.LogError("Hint Manager(Add): No NVRInteractableItem Script on " + obj.name);
		}
	}

	public void RemoveHint(NVRInteractableItem item)
	{
		if (item.isHighlighting)
		{
			item.HighlightItem(highlight: false);
		}
		hintItems.Remove(item);
	}

	public void RemoveHint(GameObject obj)
	{
		NVRInteractableItem component = obj.GetComponent<NVRInteractableItem>();
		if (component != null)
		{
			RemoveHint(component);
		}
		else
		{
			UnityEngine.Debug.LogError("Hint Manager(Remove): No NVRInteractableItem Script on " + obj.name);
		}
	}
}
public class HolyWater : SoundObject
{
	[SerializeField]
	private GameObject[] ends;

	[SerializeField]
	private GameObject middle;

	[SerializeField]
	private MeshRenderer holywaterTopMeshRenderer;

	[SerializeField]
	private MeshRenderer holywaterGlassMeshRenderer;

	[SerializeField]
	private MeshRenderer holywaterBottomMeshRenderer;

	[SerializeField]
	private Material holywaterMaterial;

	[SerializeField]
	private Material holywaterMaterialFade;

	[SerializeField]
	private Material holywaterUpgadeMaterial;

	[SerializeField]
	private Material holywaterUpgadeMaterialFade;

	private Renderer render;

	[SerializeField]
	private float power = 100f;

	private GameObject particleSmash;

	[SerializeField]
	private AudioClip smashSound;

	[SerializeField]
	private AudioClip hissSound;

	public float smashVel = 5f;

	private Vector3[] localPositions;

	private Vector3[] localRotations;

	private Rigidbody[] rigidBodies;

	private Collider[] colliders;

	private Rigidbody rigidBody;

	private Vector3 storedVelocity;

	private ExorcismItem exItem;

	public bool hasSmashed;

	public bool canSmash = true;

	public bool isSourceOfNile;

	[HideInInspector]
	public GameObject currentTarget;

	[HideInInspector]
	public bool hitTarget;

	private new void Start()
	{
		base.Start();
		if (SaveManager.instance.HasFoundArtifact(ChapterID.CHAPEL))
		{
			isSourceOfNile = true;
		}
		render = middle.GetComponent<Renderer>();
		rigidBody = GetComponent<Rigidbody>();
		localPositions = new Vector3[2];
		localPositions[0] = ends[0].transform.localPosition;
		localPositions[1] = ends[1].transform.localPosition;
		localRotations = new Vector3[2];
		localRotations[0] = ends[0].transform.localEulerAngles;
		localRotations[1] = ends[1].transform.localEulerAngles;
		rigidBodies = new Rigidbody[2];
		for (int i = 0; i < ends.Length; i++)
		{
			Rigidbody rigidbody = ends[i].GetComponent<Rigidbody>();
			if (rigidbody == null)
			{
				rigidbody = ends[i].AddComponent<Rigidbody>();
			}
			rigidBodies[i] = rigidbody;
			rigidBodies[i].useGravity = false;
			rigidBodies[i].isKinematic = true;
		}
		colliders = new Collider[2];
		colliders[0] = ends[0].GetComponent<Collider>();
		colliders[1] = ends[1].GetComponent<Collider>();
		colliders[0].enabled = false;
		colliders[1].enabled = false;
		exItem = GetComponent<ExorcismItem>();
		setupLiquid();
	}

	private void Update()
	{
		storedVelocity = rigidBody.velocity;
	}

	protected override void OnCollisionEnter(Collision collision)
	{
		if (hasSmashed)
		{
			return;
		}
		if (exItem != null)
		{
			if (!exItem.inKit && !exItem.inHand)
			{
				Collision(collision);
			}
		}
		else
		{
			Collision(collision);
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject.tag == "Fire" && !hasSmashed)
		{
			if (isSourceOfNile)
			{
				other.gameObject.GetComponentInParent<FireObstacle>().HitByWater(2);
			}
			else
			{
				other.gameObject.GetComponentInParent<FireObstacle>().HitByWater(1);
			}
			if ((bool)hissSound)
			{
				audioScript.PlayOneShot(hissSound);
			}
		}
		else if (other.gameObject.tag == "FireC5" && !hasSmashed)
		{
			if (isSourceOfNile)
			{
				other.gameObject.GetComponent<FireObstacleC5>().HitByWater(2);
			}
			else
			{
				other.gameObject.GetComponent<FireObstacleC5>().HitByWater(1);
			}
			if ((bool)hissSound)
			{
				audioScript.PlayOneShot(hissSound);
			}
		}
	}

	private void Collision(Collision collision)
	{
		if (collision.gameObject == currentTarget)
		{
			hitTarget = true;
		}
		if (collision.relativeVelocity.magnitude > smashVel && canSmash)
		{
			hasSmashed = true;
			exItem.CanAttach = false;
			if (!audioScript.IsPlaying())
			{
				PlaySound(collision, smashSound);
			}
			for (int i = 0; i < ends.Length; i++)
			{
				Vector3 force = Vector3.Reflect(storedVelocity, collision.contacts[0].normal) * power;
				ends[i].transform.parent = null;
				rigidBodies[i].useGravity = true;
				rigidBodies[i].isKinematic = false;
				rigidBodies[i].AddForce(force);
				colliders[i].enabled = true;
			}
			render.enabled = false;
		}
	}

	public void HardReset()
	{
		ends[0].transform.parent = middle.transform.parent;
		ends[1].transform.parent = middle.transform.parent;
		ends[0].transform.localPosition = localPositions[0];
		ends[0].transform.localEulerAngles = localRotations[0];
		ends[1].transform.localPosition = localPositions[1];
		ends[1].transform.localEulerAngles = localRotations[1];
		rigidBodies[0].useGravity = false;
		rigidBodies[0].isKinematic = true;
		rigidBodies[1].useGravity = false;
		rigidBodies[1].isKinematic = true;
		colliders[0].enabled = false;
		colliders[1].enabled = false;
		hitTarget = false;
		exItem.CanAttach = true;
		hasSmashed = false;
		render.enabled = true;
		setupLiquid();
	}

	public void setupLiquid()
	{
		if (isSourceOfNile)
		{
			holywaterTopMeshRenderer.material = holywaterUpgadeMaterial;
			holywaterGlassMeshRenderer.material = holywaterUpgadeMaterial;
			holywaterBottomMeshRenderer.material = holywaterUpgadeMaterial;
		}
		else
		{
			holywaterTopMeshRenderer.material = holywaterMaterial;
			holywaterGlassMeshRenderer.material = holywaterMaterial;
			holywaterBottomMeshRenderer.material = holywaterMaterial;
		}
	}

	public void SetStandardShader()
	{
		if (isSourceOfNile)
		{
			holywaterTopMeshRenderer.material = holywaterUpgadeMaterial;
			holywaterGlassMeshRenderer.material = holywaterUpgadeMaterial;
			holywaterBottomMeshRenderer.material = holywaterUpgadeMaterial;
		}
		else
		{
			holywaterTopMeshRenderer.material = holywaterMaterial;
			holywaterGlassMeshRenderer.material = holywaterMaterial;
			holywaterBottomMeshRenderer.material = holywaterMaterial;
		}
	}

	public void SetDissolveShader()
	{
		if (isSourceOfNile)
		{
			holywaterTopMeshRenderer.material = holywaterUpgadeMaterialFade;
			holywaterGlassMeshRenderer.material = holywaterUpgadeMaterialFade;
			holywaterBottomMeshRenderer.material = holywaterUpgadeMaterialFade;
		}
		else
		{
			holywaterTopMeshRenderer.material = holywaterMaterialFade;
			holywaterGlassMeshRenderer.material = holywaterMaterialFade;
			holywaterBottomMeshRenderer.material = holywaterMaterialFade;
		}
	}

	public IEnumerator StartFadeOut(float time)
	{
		for (float t = 1f; t > 0f; t -= Time.deltaTime / time)
		{
			holywaterTopMeshRenderer.material.SetFloat("_Dissolve", t);
			holywaterGlassMeshRenderer.material.SetFloat("_Dissolve", t);
			holywaterBottomMeshRenderer.material.SetFloat("_Dissolve", t);
			yield return null;
		}
		yield return null;
	}
}
public abstract class IAPManager : MonoBehaviour
{
	[HideInInspector]
	public bool storeAvailable;

	[HideInInspector]
	public bool purchaseInProgress;

	public abstract void AttemptPurchase(ChapterID chapterId);

	public abstract void UpdateAvailablePurchaseInformation();

	public abstract void UpdatePurchasedInformation();
}
public class IAPOculus : IAPManager
{
	private void Start()
	{
	}

	public override void AttemptPurchase(ChapterID chapterId)
	{
	}

	private void InitiatePurchase(ChapterID chapterId)
	{
	}

	private void LaunchCheckoutFlowCallback(Pvr_Message msg)
	{
	}

	public override void UpdateAvailablePurchaseInformation()
	{
	}

	public override void UpdatePurchasedInformation()
	{
	}
}
public class IAPOculusQuest : IAPManager
{
	private void Start()
	{
	}

	public override void AttemptPurchase(ChapterID chapterId)
	{
	}

	private void InitiatePurchase(ChapterID chapterId)
	{
	}

	private void LaunchCheckoutFlowCallback(Pvr_Message msg)
	{
	}

	public override void UpdateAvailablePurchaseInformation()
	{
	}

	public override void UpdatePurchasedInformation()
	{
	}
}
public class IAPPlayStation : IAPManager
{
	public override void AttemptPurchase(ChapterID chapterId)
	{
		if (UnityEngine.Debug.isDebugBuild)
		{
			EventManager.TriggerEvent(EventManager.AvailableEvents.IAPSuccess.ToString());
		}
		else if (!purchaseInProgress)
		{
			purchaseInProgress = true;
		}
	}

	public override void UpdateAvailablePurchaseInformation()
	{
		throw new NotImplementedException();
	}

	public override void UpdatePurchasedInformation()
	{
		throw new NotImplementedException();
	}
}
public class IAPSteam : IAPManager
{
	private Client steamworksClient;

	private AppId_t appId;

	public override void AttemptPurchase(ChapterID chapterId)
	{
	}

	private void Update()
	{
	}

	public void OnGameOverLayActivated(bool active)
	{
		UnityEngine.Debug.Log("Game overlay activated : " + active);
	}

	public override void UpdateAvailablePurchaseInformation()
	{
	}

	public override void UpdatePurchasedInformation()
	{
		throw new NotImplementedException();
	}
}
public class IDScanner : MonoBehaviour
{
	[SerializeField]
	private Renderer[] renderes;

	[SerializeField]
	private Texture greenLightGrantedTexture;

	[SerializeField]
	private Texture greenLightIdleTexture;

	[SerializeField]
	private Texture redLightDeceasedTexture;

	[SerializeField]
	private Texture redLightDeniedTexture;

	[SerializeField]
	private Texture redLightIdleTexture;

	[SerializeField]
	private Texture redLightScanTexture;

	[SerializeField]
	private Renderer redScanlines;

	[SerializeField]
	private Keycard[] keycards;

	[SerializeField]
	private Keycard correctKeycard;

	[HideInInspector]
	private Keycard currentKeycard;

	[HideInInspector]
	private bool isPoweredOn;

	[HideInInspector]
	private bool isScanning;

	[HideInInspector]
	private bool readyToScan;

	[HideInInspector]
	public bool elevatorAccessGranted;

	[SerializeField]
	private AudioScriptPooled audioScript;

	[SerializeField]
	private AudioClip clipCorrect;

	[SerializeField]
	private AudioClip clipFail;

	private bool wrongKeycardUsed;

	private void Start()
	{
		EnableEmmisive(enabled: false);
		isPoweredOn = false;
		readyToScan = false;
		redScanlines.enabled = false;
		wrongKeycardUsed = false;
	}

	public void PowerSwitchedOn()
	{
		if (isPoweredOn)
		{
			EnableEmmisive(enabled: false);
			isPoweredOn = false;
			readyToScan = false;
		}
		else
		{
			EnableEmmisive(enabled: true);
			Texture texture = GameController.instance.translator.GetTexture(redLightIdleTexture.name);
			SetEmmisive(texture ? texture : redLightIdleTexture);
			isPoweredOn = true;
			readyToScan = true;
		}
	}

	private void Update()
	{
		if (readyToScan && !isScanning && currentKeycard != null && !elevatorAccessGranted)
		{
			StartCoroutine(ScanKeycard());
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (!elevatorAccessGranted && other.gameObject.tag == "Keycard" && currentKeycard == null)
		{
			currentKeycard = other.gameObject.GetComponent<Keycard>();
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (!elevatorAccessGranted && other.gameObject.tag == "Keycard")
		{
			if (isScanning)
			{
				audioScript.StopLoop();
				Texture texture = GameController.instance.translator.GetTexture(redLightIdleTexture.name);
				SetEmmisive(texture ? texture : redLightIdleTexture);
				redScanlines.enabled = false;
				StopCoroutine(ScanKeycard());
				isScanning = false;
			}
			currentKeycard = null;
		}
	}

	private IEnumerator ScanKeycard()
	{
		if (!currentKeycard)
		{
			yield break;
		}
		isScanning = true;
		Texture texture = GameController.instance.translator.GetTexture(redLightScanTexture.name);
		SetEmmisive(texture ? texture : redLightScanTexture);
		redScanlines.enabled = true;
		if (currentKeycard == correctKeycard)
		{
			audioScript.Play(clipCorrect, 0.6f);
		}
		else
		{
			audioScript.Play(clipFail, 0.6f);
		}
		float t = 0f;
		while (t < 1.5f)
		{
			if (!isScanning)
			{
				t = 2f;
			}
			t += Time.deltaTime;
			yield return null;
		}
		if (isScanning)
		{
			if (currentKeycard == correctKeycard)
			{
				ShowValidMessage();
			}
			else
			{
				StartCoroutine(ShowInvalidMessage());
			}
		}
	}

	private IEnumerator ShowInvalidMessage()
	{
		wrongKeycardUsed = true;
		Texture texture = GameController.instance.translator.GetTexture(redLightDeceasedTexture.name);
		SetEmmisive(texture ? texture : redLightDeceasedTexture);
		yield return Yield.WaitSeconds(1f);
		texture = GameController.instance.translator.GetTexture(redLightDeniedTexture.name);
		SetEmmisive(texture ? texture : redLightDeniedTexture);
		StartCoroutine(ResetScanner());
	}

	private void ShowValidMessage()
	{
		Texture texture = GameController.instance.translator.GetTexture(greenLightGrantedTexture.name);
		SetEmmisive(texture ? texture : greenLightGrantedTexture);
		elevatorAccessGranted = true;
		StartCoroutine(SetUnlocked());
	}

	private IEnumerator ResetScanner()
	{
		redScanlines.enabled = false;
		yield return Yield.WaitSeconds(2f);
		Texture texture = GameController.instance.translator.GetTexture(redLightIdleTexture.name);
		SetEmmisive(texture ? texture : redLightIdleTexture);
		isScanning = false;
		readyToScan = true;
	}

	private IEnumerator SetUnlocked()
	{
		if (!wrongKeycardUsed)
		{
			GameController.instance.achievementManager.UnlockAchievement(AchievementID.BETTER_THAN_STAIRS);
		}
		redScanlines.enabled = false;
		yield return Yield.WaitSeconds(2f);
		Texture texture = GameController.instance.translator.GetTexture(greenLightIdleTexture.name);
		SetEmmisive(texture ? texture : greenLightIdleTexture);
		isScanning = false;
		readyToScan = false;
	}

	private void SetEmmisive(Texture tex)
	{
		Renderer[] array = renderes;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].material.SetTexture("_EmissionMap", tex);
		}
	}

	private void EnableEmmisive(bool enabled)
	{
		Renderer[] array = renderes;
		foreach (Renderer renderer in array)
		{
			if (enabled)
			{
				renderer.material.SetColor("_EmissionColor", UnityEngine.Color.white);
			}
			else
			{
				renderer.material.SetColor("_EmissionColor", UnityEngine.Color.black);
			}
		}
	}
}
public class InteractionManager : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}

	public virtual void BeginInteraction(NVRInteractable interactable)
	{
	}

	public virtual void EndInteraction(NVRInteractable interactable)
	{
	}

	public virtual void OnTriggerEnter(Collider collider)
	{
	}

	public virtual void OnTriggerStay(Collider collider)
	{
	}

	public virtual void OnTriggerExit(Collider collider)
	{
	}

	public virtual void OnPointerEnter(Collider collider)
	{
	}

	public virtual void OnPointerStay(Collider collider)
	{
	}

	public virtual void OnPointerExit(Collider collider)
	{
	}

	public virtual void OnSightTriggerEnter(Collider other)
	{
	}

	public virtual void OnSightTriggerEnterDistance(Collider other, float distance)
	{
	}

	public virtual void OnSightTriggerExit(Collider other)
	{
	}

	public virtual void OnSightTriggerStay(Collider other)
	{
	}

	public virtual GameObject GetCurrentLevelRoot()
	{
		return null;
	}
}
public class InterstitialTitleManager : MonoBehaviour
{
	[Serializable]
	public class InterstitialTitles
	{
		public string displayText;

		public float displayTime;

		public InterstitialTitles(string displayText, float displayTime)
		{
			this.displayText = displayText;
			this.displayTime = displayTime;
		}
	}

	[HideInInspector]
	public List<InterstitialTitles> interstitialTitles;

	[SerializeField]
	private TextMeshProUGUI displayTextArea;

	[SerializeField]
	private Camera titlesCamera;

	[SerializeField]
	private GameObject playerHead;

	[SerializeField]
	private CanvasGroup canvasGroup;

	private float fadeInTime = 4f;

	private float fadeOutTime = 4f;

	private void Start()
	{
		clearTitles();
		LeanTween.alphaCanvas(canvasGroup, 0f, 0.1f);
	}

	public void clearTitles()
	{
		interstitialTitles.Clear();
	}

	public void showTitles()
	{
		if (interstitialTitles.Count > 0)
		{
			titlesCamera.enabled = true;
			StartCoroutine(showTitlesRoutine());
		}
	}

	public void addTitle(string displayText, float displayTime)
	{
		interstitialTitles.Add(new InterstitialTitles(displayText, displayTime));
	}

	public float getTotalWaitTime()
	{
		float num = fadeInTime + fadeOutTime;
		foreach (InterstitialTitles interstitialTitle in interstitialTitles)
		{
			num += interstitialTitle.displayTime;
		}
		return num;
	}

	private IEnumerator showTitlesRoutine()
	{
		InterstitialTitles interstitialTitles = this.interstitialTitles[0];
		displayTextArea.text = interstitialTitles.displayText;
		LeanTween.alphaCanvas(canvasGroup, 1f, fadeInTime);
		yield return Yield.WaitSeconds(interstitialTitles.displayTime + fadeInTime);
		for (int i = 1; i < this.interstitialTitles.Count; i++)
		{
			InterstitialTitles interstitialTitles2 = this.interstitialTitles[i];
			displayTextArea.text = interstitialTitles2.displayText;
			yield return Yield.WaitSeconds(interstitialTitles2.displayTime);
		}
		LeanTween.alphaCanvas(canvasGroup, 0f, fadeOutTime);
		yield return Yield.WaitSeconds(fadeOutTime);
		titlesCamera.enabled = false;
	}
}
public class IntroSequence : MonoBehaviour
{
	private NVRPlayer player;

	public GameObject loadPosition;

	[SerializeField]
	private TextMeshProUGUI textHolder;

	[Header("Chapel Intro")]
	[Space]
	[SerializeField]
	private AudioClip[] audioChapel;

	[Header("Cell Intro")]
	[Space]
	[SerializeField]
	private AudioClip[] audioCell;

	[Header("Nursery Intro")]
	[Space]
	[SerializeField]
	private AudioClip[] audioNursery;

	[Header("Morgue Intro")]
	[Space]
	[SerializeField]
	private AudioClip[] audioMorgue;

	[Header("Tomb Intro")]
	[SerializeField]
	private AudioClip[] audioTomb;

	private TMP_FontAsset _originalInterstitialFont;

	private SCENES loadingInto = SCENES.ONBOARDING;

	private void Start()
	{
		player = GameController.instance.player;
		_originalInterstitialFont = textHolder.font;
	}

	public void PlayIntro(SCENES newScene, SCENES prevScene, bool completedPrev)
	{
		player.HandMenu.CloseMenu(hideHandsAfter: true);
		player.HandMenu.LockMenu(locked: true);
		player.HandRendersActive(showHands: false);
		player.screenFX.BlurScreen(enabled: false);
		player.screenFX.PeripheralFade(0f);
		player.HandRendersActive(showHands: false);
		player.visual_OOB.SetActive(value: false);
		loadingInto = newScene;
		if (GameController.instance.DebugMode)
		{
			StartCoroutine(Complete());
			return;
		}
		player.SetPosition(loadPosition);
		if (player.movement != null)
		{
			player.movement.DisableEverything();
		}
		GameController.instance.audioController.SnapAllOpen(2f);
		switch (newScene)
		{
		case SCENES.PRECINCT:
			PrecinctController(prevScene, completedPrev);
			break;
		case SCENES.CHAPEL:
			StartCoroutine(IntroChapel());
			break;
		case SCENES.CELL:
			StartCoroutine(IntroCell());
			break;
		case SCENES.NURSERY:
			StartCoroutine(IntroNursery());
			break;
		case SCENES.MORGUE:
			StartCoroutine(IntroMorgue());
			break;
		case SCENES.TOMB:
			StartCoroutine(IntroTomb());
			break;
		default:
			StartCoroutine(Complete());
			break;
		}
	}

	private void PrecinctController(SCENES prevScene, bool completedPrev)
	{
		if (completedPrev)
		{
			switch (prevScene)
			{
			case SCENES.CHAPEL:
				StartCoroutine(IntroPrecinctChapelComplete());
				break;
			case SCENES.CELL:
				StartCoroutine(IntroPrecinctCellComplete());
				break;
			case SCENES.NURSERY:
				StartCoroutine(IntroPrecinctNurseryComplete());
				break;
			case SCENES.MORGUE:
				StartCoroutine(IntroPrecinctMorgueComplete());
				break;
			case SCENES.TOMB:
				StartCoroutine(IntroPrecinctTombComplete());
				break;
			default:
				StartCoroutine(IntroPrecinct());
				break;
			}
		}
		else
		{
			StartCoroutine(IntroPrecinct());
		}
	}

	private IEnumerator Complete()
	{
		player.screenFX.Fade(UnityEngine.Color.black, 2f);
		GameController.instance.audioController.SnapMute(2f);
		player.visual_OOB.SetActive(value: false);
		yield return Yield.WaitSeconds(2f);
		GameController.instance.async.allowSceneActivation = true;
		while (GameController.instance.isLoading)
		{
			yield return null;
		}
		DynamicGI.UpdateEnvironment();
		if (loadingInto != SCENES.TITLES)
		{
			player.HandRendersActive(showHands: true);
			player.HandMenu.LockMenu(locked: false);
		}
		EventManager.TriggerEvent(EventManager.AvailableEvents.IntroComplete.ToString());
	}

	private IEnumerator IntroPrecinct()
	{
		UnityEngine.Debug.Log("IntroPrecinct");
		GameController.instance.translator.SetTextMesh(textHolder, "Late shift", _originalInterstitialFont);
		player.screenFX.Fade(UnityEngine.Color.clear, 2f);
		yield return Yield.WaitSeconds(5f);
		textHolder.CrossFadeAlpha(0f, 2f, ignoreTimeScale: false);
		yield return Yield.WaitSeconds(2f);
		textHolder.CrossFadeAlpha(1f, 2f, ignoreTimeScale: false);
		GameController.instance.translator.SetTextMesh(textHolder, "HOMICIDE \nBOSTON P.D.", _originalInterstitialFont);
		yield return Yield.WaitSeconds(5f);
		StartCoroutine(Complete());
	}

	private IEnumerator IntroPrecinctChapelComplete()
	{
		UnityEngine.Debug.Log("IntroPrecinctFromChurch");
		base.gameObject.GetComponent<AudioScript>().Play(audioChapel[1]);
		TranslateText("A dead exorcist, me out cold and that thing in the shadows");
		player.screenFX.Fade(UnityEngine.Color.clear, 2f);
		yield return Yield.WaitSeconds(5f);
		textHolder.CrossFadeAlpha(0f, 2f, ignoreTimeScale: false);
		yield return Yield.WaitSeconds(2f);
		textHolder.CrossFadeAlpha(1f, 2f, ignoreTimeScale: false);
		TranslateText("...how the hell do I write this case up?");
		yield return Yield.WaitSeconds(3f);
		textHolder.CrossFadeAlpha(0f, 2f, ignoreTimeScale: false);
		yield return Yield.WaitSeconds(2f);
		textHolder.CrossFadeAlpha(1f, 2f, ignoreTimeScale: false);
		TranslateText("HOMICIDE \nBOSTON P.D.");
		yield return Yield.WaitSeconds(5f);
		StartCoroutine(Complete());
	}

	private IEnumerator IntroPrecinctCellComplete()
	{
		UnityEngine.Debug.Log("IntroPrecinctFromCell");
		base.gameObject.GetComponent<AudioScript>().Play(audioCell[1]);
		TranslateText("She was used by Ronove to take souls.");
		player.screenFX.Fade(UnityEngine.Color.clear, 2f);
		yield return Yield.WaitSeconds(5f);
		textHolder.CrossFadeAlpha(0f, 2f, ignoreTimeScale: false);
		yield return Yield.WaitSeconds(2f);
		textHolder.CrossFadeAlpha(1f, 2f, ignoreTimeScale: false);
		TranslateText("Lucie was free of evil, but at what cost?");
		yield return Yield.WaitSeconds(3f);
		textHolder.CrossFadeAlpha(0f, 2f, ignoreTimeScale: false);
		yield return Yield.WaitSeconds(2f);
		textHolder.CrossFadeAlpha(1f, 2f, ignoreTimeScale: false);
		TranslateText("HOMICIDE \nBOSTON P.D.");
		yield return Yield.WaitSeconds(5f);
		StartCoroutine(Complete());
	}

	private IEnumerator IntroPrecinctNurseryComplete()
	{
		UnityEngine.Debug.Log("IntroPrecinctFromNursery");
		TranslateText("I offered my condolences to Mr. Del Mar but chose not to tell him about my encounter with the demon.");
		player.screenFX.Fade(UnityEngine.Color.clear, 2f);
		yield return Yield.WaitSeconds(7f);
		textHolder.CrossFadeAlpha(0f, 2f, ignoreTimeScale: false);
		yield return Yield.WaitSeconds(2f);
		textHolder.CrossFadeAlpha(1f, 2f, ignoreTimeScale: false);
		TranslateText("What could I possibly say? If I don't understand, how could anyone else?");
		yield return Yield.WaitSeconds(7f);
		textHolder.CrossFadeAlpha(0f, 2f, ignoreTimeScale: false);
		yield return Yield.WaitSeconds(2f);
		textHolder.CrossFadeAlpha(1f, 2f, ignoreTimeScale: false);
		TranslateText("When I returned to the Precinct to log items into the evidence room, I discovered a new letter on my desk.");
		yield return Yield.WaitSeconds(7f);
		textHolder.CrossFadeAlpha(0f, 2f, ignoreTimeScale: false);
		yield return Yield.WaitSeconds(2f);
		textHolder.CrossFadeAlpha(1f, 2f, ignoreTimeScale: false);
		TranslateText("Who is sending me this information, and how do they know so much about Father Bell's work?");
		yield return Yield.WaitSeconds(7f);
		StartCoroutine(Complete());
	}

	private IEnumerator IntroPrecinctMorgueComplete()
	{
		UnityEngine.Debug.Log("IntroPrecinctFromMorgue");
		TranslateText("Trapped below ground, the Haitian army found me a day later among the corpses of the research team.");
		player.screenFX.Fade(UnityEngine.Color.clear, 2f);
		yield return Yield.WaitSeconds(7f);
		textHolder.CrossFadeAlpha(0f, 2f, ignoreTimeScale: false);
		yield return Yield.WaitSeconds(2f);
		textHolder.CrossFadeAlpha(1f, 2f, ignoreTimeScale: false);
		TranslateText("Posing as Dr. Hopkins, I made it to the airport without too many questions.");
		yield return Yield.WaitSeconds(6f);
		textHolder.CrossFadeAlpha(0f, 2f, ignoreTimeScale: false);
		yield return Yield.WaitSeconds(2f);
		textHolder.CrossFadeAlpha(1f, 2f, ignoreTimeScale: false);
		TranslateText("These demonic encounters have left me with a strange sensation... as if I am being lead towards an inevitable confrontation.");
		yield return Yield.WaitSeconds(6f);
		textHolder.CrossFadeAlpha(0f, 2f, ignoreTimeScale: false);
		yield return Yield.WaitSeconds(2f);
		GameController.instance.audioController.persistentMusicPlayer.FadeOut(3.5f);
		textHolder.CrossFadeAlpha(1f, 2f, ignoreTimeScale: false);
		TranslateText("I can feel Pazuzu's presence.");
		yield return Yield.WaitSeconds(4f);
		StartCoroutine(Complete());
	}

	private IEnumerator IntroPrecinctTombComplete()
	{
		UnityEngine.Debug.Log("IntroPrecinctFromTomb");
		TranslateText("In a flash of brilliant light it was over.");
		player.screenFX.Fade(UnityEngine.Color.clear, 2f);
		yield return Yield.WaitSeconds(6f);
		textHolder.CrossFadeAlpha(0f, 2f, ignoreTimeScale: false);
		yield return Yield.WaitSeconds(2f);
		textHolder.CrossFadeAlpha(1f, 2f, ignoreTimeScale: false);
		TranslateText("Everything that led me here crumbled to dust around me.");
		yield return Yield.WaitSeconds(6f);
		textHolder.CrossFadeAlpha(0f, 2f, ignoreTimeScale: false);
		yield return Yield.WaitSeconds(2f);
		textHolder.CrossFadeAlpha(1f, 2f, ignoreTimeScale: false);
		TranslateText("I still couldn't say if it was an intervention or a coincidence.");
		yield return Yield.WaitSeconds(6f);
		textHolder.CrossFadeAlpha(0f, 2f, ignoreTimeScale: false);
		yield return Yield.WaitSeconds(2f);
		textHolder.CrossFadeAlpha(1f, 2f, ignoreTimeScale: false);
		TranslateText("But the midday sun illuminated Pazuzu's tomb, leaving him nowhere to hide.");
		yield return Yield.WaitSeconds(6f);
		textHolder.CrossFadeAlpha(0f, 2f, ignoreTimeScale: false);
		if (GameController.instance.audioController.persistentMusicPlayer.IsPlaying())
		{
			GameController.instance.audioController.persistentMusicPlayer.FadeOut(2f);
		}
		yield return Yield.WaitSeconds(2f);
		GameController.instance.audioController.persistentMusicPlayer.Play(audioTomb[1]);
		textHolder.CrossFadeAlpha(1f, 2f, ignoreTimeScale: false);
		textHolder.text = "...";
		yield return Yield.WaitSeconds(3f);
		textHolder.CrossFadeAlpha(0f, 2f, ignoreTimeScale: false);
		yield return Yield.WaitSeconds(2f);
		textHolder.CrossFadeAlpha(1f, 2f, ignoreTimeScale: false);
		TranslateText("The fight between good and evil would seem surreal now if not for the stench...");
		yield return Yield.WaitSeconds(6f);
		textHolder.CrossFadeAlpha(0f, 2f, ignoreTimeScale: false);
		yield return Yield.WaitSeconds(2f);
		textHolder.CrossFadeAlpha(1f, 2f, ignoreTimeScale: false);
		TranslateText("That sick stench of Pazuzu's charred rotting flesh that lingered around me for months after.");
		yield return Yield.WaitSeconds(6f);
		textHolder.CrossFadeAlpha(0f, 2f, ignoreTimeScale: false);
		yield return Yield.WaitSeconds(2f);
		textHolder.CrossFadeAlpha(1f, 2f, ignoreTimeScale: false);
		TranslateText("The chief wants the Bell murder case off my desk.");
		yield return Yield.WaitSeconds(6f);
		textHolder.CrossFadeAlpha(0f, 2f, ignoreTimeScale: false);
		yield return Yield.WaitSeconds(2f);
		textHolder.CrossFadeAlpha(1f, 2f, ignoreTimeScale: false);
		TranslateText("HOMICIDE, Boston PD.");
		yield return Yield.WaitSeconds(4f);
		StartCoroutine(Complete());
	}

	private IEnumerator IntroChapel()
	{
		UnityEngine.Debug.Log("IntroChapel");
		base.gameObject.GetComponent<AudioScript>().Play(audioChapel[0]);
		TranslateText("Church of St. Vincent de Paul");
		player.screenFX.Fade(UnityEngine.Color.clear, 2f);
		yield return Yield.WaitSeconds(5f);
		textHolder.CrossFadeAlpha(0f, 2f, ignoreTimeScale: false);
		yield return Yield.WaitSeconds(2f);
		textHolder.CrossFadeAlpha(1f, 2f, ignoreTimeScale: false);
		TranslateText("As uniformed cops ushered away the crowd of onlookers, someone shouted...");
		yield return Yield.WaitSeconds(3f);
		textHolder.CrossFadeAlpha(0f, 2f, ignoreTimeScale: false);
		yield return Yield.WaitSeconds(2f);
		textHolder.CrossFadeAlpha(1f, 2f, ignoreTimeScale: false);
		TranslateText("\"and all the devils besought him, saying, send us into the swine, that we may enter into them.\"");
		yield return Yield.WaitSeconds(3f);
		textHolder.CrossFadeAlpha(0f, 2f, ignoreTimeScale: false);
		yield return Yield.WaitSeconds(2f);
		textHolder.CrossFadeAlpha(1f, 2f, ignoreTimeScale: false);
		TranslateText("Through the doors I could see a trail of blood and evidence markers laid out for me to follow.");
		yield return Yield.WaitSeconds(5f);
		StartCoroutine(Complete());
	}

	private IEnumerator IntroCell()
	{
		UnityEngine.Debug.Log("IntroCell");
		base.gameObject.GetComponent<AudioScript>().Play(audioCell[0]);
		TranslateText("St. Dymphna Community Hospital");
		player.screenFX.Fade(UnityEngine.Color.clear, 2f);
		yield return Yield.WaitSeconds(5f);
		textHolder.CrossFadeAlpha(0f, 2f, ignoreTimeScale: false);
		yield return Yield.WaitSeconds(2f);
		textHolder.CrossFadeAlpha(1f, 2f, ignoreTimeScale: false);
		TranslateText("The logo by the door reads, \"Compassion, care and safety...\"");
		yield return Yield.WaitSeconds(3f);
		textHolder.CrossFadeAlpha(0f, 2f, ignoreTimeScale: false);
		yield return Yield.WaitSeconds(2f);
		textHolder.CrossFadeAlpha(1f, 2f, ignoreTimeScale: false);
		TranslateText("The signs outside said, \n\"DO NOT PICK UP HITCHHIKERS\".");
		yield return Yield.WaitSeconds(3f);
		textHolder.CrossFadeAlpha(0f, 2f, ignoreTimeScale: false);
		yield return Yield.WaitSeconds(2f);
		textHolder.CrossFadeAlpha(1f, 2f, ignoreTimeScale: false);
		TranslateText("What can I find out about Lucie Moss? What has taken hold of her?");
		yield return Yield.WaitSeconds(5f);
		StartCoroutine(Complete());
	}

	private IEnumerator IntroNursery()
	{
		UnityEngine.Debug.Log("IntroNursery");
		GameController.instance.audioController.persistentMusicPlayer.Play(audioNursery[0]);
		TranslateText("Saint Homobonus, Fall River, Massachusetts");
		player.screenFX.Fade(UnityEngine.Color.clear, 2f);
		yield return Yield.WaitSeconds(5f);
		textHolder.CrossFadeAlpha(0f, 2f, ignoreTimeScale: false);
		yield return Yield.WaitSeconds(2f);
		textHolder.CrossFadeAlpha(1f, 2f, ignoreTimeScale: false);
		TranslateText("Was the strange voice on the CD the same voice heard back in 1974?");
		yield return Yield.WaitSeconds(7f);
		textHolder.CrossFadeAlpha(0f, 2f, ignoreTimeScale: false);
		yield return Yield.WaitSeconds(2f);
		textHolder.CrossFadeAlpha(1f, 2f, ignoreTimeScale: false);
		TranslateText("As we met at the door, I assured Mr. Del-Mar that the voices on the baby monitor were probably radio interference.");
		yield return Yield.WaitSeconds(7f);
		textHolder.CrossFadeAlpha(0f, 2f, ignoreTimeScale: false);
		yield return Yield.WaitSeconds(2f);
		textHolder.CrossFadeAlpha(1f, 2f, ignoreTimeScale: false);
		TranslateText("I lied...");
		yield return Yield.WaitSeconds(4f);
		textHolder.CrossFadeAlpha(0f, 2f, ignoreTimeScale: false);
		yield return Yield.WaitSeconds(2f);
		textHolder.CrossFadeAlpha(1f, 2f, ignoreTimeScale: false);
		TranslateText("Could this be Abyzou, one of the demons Father Bell described as a member of the Legion?");
		yield return Yield.WaitSeconds(7f);
		StartCoroutine(Complete());
	}

	private IEnumerator IntroMorgue()
	{
		UnityEngine.Debug.Log("IntroMorgue");
		GameController.instance.audioController.persistentMusicPlayer.Play(audioMorgue[0]);
		TranslateText("An unknown epidemic has ravaged a Haitian community, causing unrest.");
		player.screenFX.Fade(UnityEngine.Color.clear, 2f);
		yield return Yield.WaitSeconds(6f);
		textHolder.CrossFadeAlpha(0f, 2f, ignoreTimeScale: false);
		yield return Yield.WaitSeconds(2f);
		textHolder.CrossFadeAlpha(1f, 2f, ignoreTimeScale: false);
		TranslateText("An international team of doctors was sent to investigate but haven't been seen since.");
		yield return Yield.WaitSeconds(6f);
		textHolder.CrossFadeAlpha(0f, 2f, ignoreTimeScale: false);
		yield return Yield.WaitSeconds(2f);
		textHolder.CrossFadeAlpha(1f, 2f, ignoreTimeScale: false);
		TranslateText("Overrun by looters, the \"Sante Sant\" health center now strikes fear into the local residents.");
		yield return Yield.WaitSeconds(5f);
		textHolder.CrossFadeAlpha(0f, 2f, ignoreTimeScale: false);
		yield return Yield.WaitSeconds(2f);
		textHolder.CrossFadeAlpha(1f, 2f, ignoreTimeScale: false);
		TranslateText("Is this disease mother nature at work or something more... unnatural?");
		yield return Yield.WaitSeconds(4f);
		StartCoroutine(Complete());
	}

	private IEnumerator IntroTomb()
	{
		UnityEngine.Debug.Log("IntroTomb");
		GameController.instance.audioController.persistentMusicPlayer.Play(audioTomb[0]);
		TranslateText("Cut off its head and the body will follow...");
		player.screenFX.Fade(UnityEngine.Color.clear, 2f);
		yield return Yield.WaitSeconds(5f);
		textHolder.CrossFadeAlpha(0f, 2f, ignoreTimeScale: false);
		yield return Yield.WaitSeconds(2f);
		textHolder.CrossFadeAlpha(1f, 2f, ignoreTimeScale: false);
		TranslateText("at least that's what they say.");
		yield return Yield.WaitSeconds(3f);
		textHolder.CrossFadeAlpha(0f, 2f, ignoreTimeScale: false);
		yield return Yield.WaitSeconds(2f);
		textHolder.CrossFadeAlpha(1f, 2f, ignoreTimeScale: false);
		TranslateText("I have travelled too far on this path to turn back...");
		yield return Yield.WaitSeconds(5f);
		textHolder.CrossFadeAlpha(0f, 2f, ignoreTimeScale: false);
		yield return Yield.WaitSeconds(2f);
		textHolder.CrossFadeAlpha(1f, 2f, ignoreTimeScale: false);
		TranslateText("at least that's what I told myself.");
		yield return Yield.WaitSeconds(3f);
		textHolder.CrossFadeAlpha(0f, 2f, ignoreTimeScale: false);
		yield return Yield.WaitSeconds(2f);
		textHolder.CrossFadeAlpha(1f, 2f, ignoreTimeScale: false);
		TranslateText("The Iraq-Syria border, Upper Mesopotamia.");
		yield return Yield.WaitSeconds(6f);
		StartCoroutine(Complete());
	}

	private void TranslateText(string txt)
	{
		GameController.instance.translator.SetTextMesh(textHolder, txt, _originalInterstitialFont);
	}
}
public class JointReset : MonoBehaviour
{
	private Quaternion initialLocalRotation;

	private Vector3 initialLocalPosition;

	private Quaternion localRotationOnDisable;

	private Vector3 localPositionOnDisable;

	private bool hasDisabled;

	private void Awake()
	{
		initialLocalRotation = base.transform.localRotation;
		initialLocalPosition = base.transform.localPosition;
	}

	public void UpdateTransform(Quaternion rot, Vector3 pos)
	{
		localRotationOnDisable = rot;
		localPositionOnDisable = pos;
	}

	private void OnDisable()
	{
		localRotationOnDisable = base.transform.localRotation;
		base.transform.localRotation = initialLocalRotation;
		localPositionOnDisable = base.transform.localPosition;
		base.transform.localPosition = initialLocalPosition;
		hasDisabled = true;
	}

	private void Update()
	{
		if (hasDisabled)
		{
			hasDisabled = false;
			base.transform.localRotation = localRotationOnDisable;
			base.transform.localPosition = localPositionOnDisable;
		}
	}
}
public class Keycard : MonoBehaviour
{
	public enum ScannedErrorType
	{
		INVALID,
		DECEASED
	}

	[SerializeField]
	public ScannedErrorType errorType;

	[SerializeField]
	public ConstantForce paperForce;

	[SerializeField]
	private Rigidbody paperConst;

	public bool hasPrinted;

	private bool insidePrinter;

	public bool InsidePrinter => insidePrinter;

	private void Start()
	{
		StartCoroutine(SwitchOffRoutine());
	}

	private IEnumerator SwitchOffRoutine()
	{
		yield return Yield.WaitSeconds(2f);
		paperForce.enabled = false;
		paperConst.constraints = RigidbodyConstraints.None;
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.tag == Printer.PRINTER_TAG)
		{
			insidePrinter = true;
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (other.tag == Printer.PRINTER_TAG)
		{
			insidePrinter = false;
		}
	}
}
public class KitSnapTrigger : MonoBehaviour
{
	private ExorcismItem item;

	private void OnTriggerEnter(Collider other)
	{
		if (other.GetComponent<ExorcismItem>() != null)
		{
			item = other.GetComponent<ExorcismItem>();
			if (!item.inHand && !item.inKit && !item.inEnvironment)
			{
				item.ForceSnapBack();
			}
		}
	}
}
public class LadderRelease : MonoBehaviour
{
	[SerializeField]
	public GameObject[] smashableObjects;

	[SerializeField]
	public GameObject hammer;

	[SerializeField]
	private GameObject ladderReleaseButton;

	[SerializeField]
	private Rigidbody[] glassPieces;

	[SerializeField]
	private ParticleSystem glassParticles;

	[SerializeField]
	private Rigidbody ladder;

	[SerializeField]
	private GameObject ladderGrabPoint;

	[SerializeField]
	private GameObject ladderStopper;

	[HideInInspector]
	public bool smashedGlass;

	[HideInInspector]
	public bool ladderReleased;

	private void Start()
	{
	}

	private void Update()
	{
	}

	private void OnTriggerEnter(Collider other)
	{
		if (!smashedGlass && !(other.transform.parent == null) && IsSmashableObject(other.transform.parent.gameObject))
		{
			if (other.gameObject.transform.parent.gameObject != hammer)
			{
				GameController.instance.achievementManager.UnlockAchievement(AchievementID.IMPROVISING);
			}
			SmashLadderRelease();
		}
	}

	public bool IsSmashableObject(GameObject interactable)
	{
		GameObject[] array = smashableObjects;
		foreach (GameObject gameObject in array)
		{
			if (interactable == gameObject)
			{
				return true;
			}
		}
		return false;
	}

	public void SmashLadderRelease()
	{
		if (!smashedGlass)
		{
			smashedGlass = true;
			glassParticles.gameObject.SetActive(value: true);
			for (int i = 0; i < glassPieces.Length; i++)
			{
				Rigidbody obj = glassPieces[i];
				obj.isKinematic = false;
				obj.AddExplosionForce(80f, ladderReleaseButton.transform.position, 1f, 0f);
			}
		}
	}

	public void ReleaseLadder()
	{
		StartCoroutine(ReleaseLadderRoutine());
	}

	private IEnumerator ReleaseLadderRoutine()
	{
		ladderReleased = true;
		ladder.isKinematic = false;
		yield return Yield.WaitSeconds(0.75f);
		ladderGrabPoint.SetActive(value: true);
	}

	public void LockLadderInPosition()
	{
		ladder.isKinematic = true;
		ladderStopper.SetActive(value: false);
	}
}
public class LevelCompletionManager : MonoBehaviour
{
	public void SetLevelCompletionForChapel(bool playedTapes, bool completedKit, bool foundSourceOfTheNile, bool completedLevel)
	{
		Chapter chapterById = SaveManager.instance.GetChapterById(ChapterID.CHAPEL);
		if (foundSourceOfTheNile)
		{
			chapterById.artifactComplete = foundSourceOfTheNile;
			chapterById.completionCheckmark4 = foundSourceOfTheNile;
		}
		if (completedLevel)
		{
			chapterById.completionCheckmark1 = completedLevel;
		}
		if (playedTapes)
		{
			chapterById.completionCheckmark2 = playedTapes;
		}
		if (completedKit)
		{
			chapterById.completionCheckmark3 = completedKit;
		}
		chapterById.chapterCompletionStatus = GetStatus(chapterById);
		if (chapterById.chapterCompletionStatus == ChapterCompletionStatus.HUNDRED_PERCENT_COMPLETE)
		{
			chapterById.chapterStatus = ChapterStatus.COMPLETED;
			chapterById.completed = true;
		}
		else if (completedLevel)
		{
			chapterById.chapterStatus = ChapterStatus.COMPLETED;
		}
		else if (chapterById.chapterStatus == ChapterStatus.COMPLETED)
		{
			chapterById.chapterStatus = ChapterStatus.COMPLETED;
		}
		else
		{
			chapterById.chapterStatus = ChapterStatus.PLAYED_NOT_COMPLETED;
		}
		if (completedLevel)
		{
			GameController.instance.achievementManager.UnlockAchievement(AchievementID.CHAPTER_ONE);
		}
		if (chapterById.chapterCompletionStatus == ChapterCompletionStatus.HUNDRED_PERCENT_COMPLETE)
		{
			GameController.instance.achievementManager.UnlockAchievement(AchievementID.FIRST_RITES);
		}
		SaveManager.instance.Save(SaveManager.instance.currentSavedGameSlot);
		EventManager.TriggerEvent(EventManager.AvailableEvents.ChapelChapterCompleted.ToString());
	}

	private ChapterCompletionStatus GetStatus(Chapter chapterData)
	{
		ChapterCompletionStatus result = ChapterCompletionStatus.BLANK;
		if (chapterData.completionCheckmark4)
		{
			result = ChapterCompletionStatus.TWENTYFIVC_PERCENT_COMPLETE;
			if (chapterData.completionCheckmark1)
			{
				result = ChapterCompletionStatus.FIFTY_PERCENT_COMPLETE;
				if (chapterData.completionCheckmark3)
				{
					result = ChapterCompletionStatus.SEVENTY_FIVE_COMPLETE;
					if (chapterData.completionCheckmark2)
					{
						result = ChapterCompletionStatus.HUNDRED_PERCENT_COMPLETE;
					}
				}
				else if (chapterData.completionCheckmark2)
				{
					result = ChapterCompletionStatus.SEVENTY_FIVE_COMPLETE;
				}
			}
			else if (chapterData.completionCheckmark3)
			{
				result = ChapterCompletionStatus.FIFTY_PERCENT_COMPLETE;
				if (chapterData.completionCheckmark2)
				{
					result = ChapterCompletionStatus.SEVENTY_FIVE_COMPLETE;
				}
			}
			else if (chapterData.completionCheckmark2)
			{
				result = ChapterCompletionStatus.FIFTY_PERCENT_COMPLETE;
			}
		}
		else if (chapterData.completionCheckmark1)
		{
			result = ChapterCompletionStatus.TWENTYFIVC_PERCENT_COMPLETE;
			if (chapterData.completionCheckmark3)
			{
				result = ChapterCompletionStatus.FIFTY_PERCENT_COMPLETE;
				if (chapterData.completionCheckmark2)
				{
					result = ChapterCompletionStatus.SEVENTY_FIVE_COMPLETE;
				}
			}
			else if (chapterData.completionCheckmark2)
			{
				result = ChapterCompletionStatus.FIFTY_PERCENT_COMPLETE;
			}
		}
		else if (chapterData.completionCheckmark3)
		{
			result = ChapterCompletionStatus.TWENTYFIVC_PERCENT_COMPLETE;
			if (chapterData.completionCheckmark2)
			{
				result = ChapterCompletionStatus.FIFTY_PERCENT_COMPLETE;
			}
		}
		else if (chapterData.completionCheckmark2)
		{
			result = ChapterCompletionStatus.TWENTYFIVC_PERCENT_COMPLETE;
		}
		return result;
	}

	public void SetLevelCompletionForCell(bool exorcismInOne, bool usedCorrectTools, bool foundArtefact, bool completedLevel)
	{
		UnityEngine.Debug.Log("Setting Level Completion for cell");
		Chapter chapterById = SaveManager.instance.GetChapterById(ChapterID.CELL);
		if (foundArtefact)
		{
			chapterById.artifactComplete = true;
		}
		if (completedLevel)
		{
			chapterById.completionCheckmark1 = completedLevel;
		}
		if (exorcismInOne)
		{
			chapterById.completionCheckmark2 = exorcismInOne;
		}
		if (usedCorrectTools)
		{
			chapterById.completionCheckmark3 = usedCorrectTools;
		}
		if (foundArtefact)
		{
			chapterById.completionCheckmark4 = foundArtefact;
		}
		chapterById.chapterCompletionStatus = GetStatus(chapterById);
		if (chapterById.chapterCompletionStatus == ChapterCompletionStatus.HUNDRED_PERCENT_COMPLETE)
		{
			chapterById.chapterStatus = ChapterStatus.COMPLETED;
			chapterById.completed = true;
		}
		else if (completedLevel)
		{
			chapterById.chapterStatus = ChapterStatus.COMPLETED;
		}
		else if (chapterById.chapterStatus == ChapterStatus.COMPLETED)
		{
			chapterById.chapterStatus = ChapterStatus.COMPLETED;
		}
		else
		{
			chapterById.chapterStatus = ChapterStatus.PLAYED_NOT_COMPLETED;
		}
		if (completedLevel)
		{
			GameController.instance.achievementManager.UnlockAchievement(AchievementID.CHAPTER_TWO);
		}
		if (chapterById.chapterCompletionStatus == ChapterCompletionStatus.HUNDRED_PERCENT_COMPLETE)
		{
			GameController.instance.achievementManager.UnlockAchievement(AchievementID.IDLE_HANDS);
		}
		UnityEngine.Debug.Log("About to save the data");
		SaveManager.instance.Save(SaveManager.instance.currentSavedGameSlot);
		EventManager.TriggerEvent(EventManager.AvailableEvents.CellChapterCompleted.ToString());
	}

	public void SetLevelCompletionForNursery(bool foundGhostedItems, bool noSnakesinCrib, bool foundArtefact, bool completedLevel)
	{
		UnityEngine.Debug.Log("Setting Level Completion for Nursery");
		Chapter chapterById = SaveManager.instance.GetChapterById(ChapterID.NURSERY);
		if (foundArtefact)
		{
			chapterById.artifactComplete = true;
		}
		if (completedLevel)
		{
			chapterById.completionCheckmark1 = completedLevel;
		}
		if (foundGhostedItems)
		{
			chapterById.completionCheckmark2 = foundGhostedItems;
		}
		if (noSnakesinCrib)
		{
			chapterById.completionCheckmark3 = noSnakesinCrib;
		}
		if (foundArtefact)
		{
			chapterById.completionCheckmark4 = foundArtefact;
		}
		chapterById.chapterCompletionStatus = GetStatus(chapterById);
		if (chapterById.chapterCompletionStatus == ChapterCompletionStatus.HUNDRED_PERCENT_COMPLETE)
		{
			chapterById.chapterStatus = ChapterStatus.COMPLETED;
			chapterById.completed = true;
		}
		else if (completedLevel)
		{
			chapterById.chapterStatus = ChapterStatus.COMPLETED;
		}
		else if (chapterById.chapterStatus == ChapterStatus.COMPLETED)
		{
			chapterById.chapterStatus = ChapterStatus.COMPLETED;
		}
		else
		{
			chapterById.chapterStatus = ChapterStatus.PLAYED_NOT_COMPLETED;
		}
		if (completedLevel)
		{
			GameController.instance.achievementManager.UnlockAchievement(AchievementID.CHAPTER_THREE);
		}
		if (chapterById.chapterCompletionStatus == ChapterCompletionStatus.HUNDRED_PERCENT_COMPLETE)
		{
			GameController.instance.achievementManager.UnlockAchievement(AchievementID.SKIN_DEEP);
		}
		UnityEngine.Debug.Log("About to save the data");
		SaveManager.instance.Save(SaveManager.instance.currentSavedGameSlot);
		EventManager.TriggerEvent(EventManager.AvailableEvents.NurseryChapterCompleted.ToString());
	}

	public void SetLevelCompletionForMorgue(bool notHitByBaal, bool researchedTheDisease, bool foundArtefact, bool completedLevel)
	{
		UnityEngine.Debug.Log("Setting Level Completion for Morgue");
		Chapter chapterById = SaveManager.instance.GetChapterById(ChapterID.MORGUE);
		if (foundArtefact)
		{
			chapterById.artifactComplete = true;
		}
		if (completedLevel)
		{
			chapterById.completionCheckmark1 = completedLevel;
		}
		if (researchedTheDisease)
		{
			chapterById.completionCheckmark2 = researchedTheDisease;
		}
		if (notHitByBaal)
		{
			chapterById.completionCheckmark3 = notHitByBaal;
		}
		if (foundArtefact)
		{
			chapterById.completionCheckmark4 = foundArtefact;
		}
		chapterById.chapterCompletionStatus = GetStatus(chapterById);
		if (chapterById.chapterCompletionStatus == ChapterCompletionStatus.HUNDRED_PERCENT_COMPLETE)
		{
			chapterById.chapterStatus = ChapterStatus.COMPLETED;
			chapterById.completed = true;
		}
		else if (completedLevel)
		{
			chapterById.chapterStatus = ChapterStatus.COMPLETED;
		}
		else if (chapterById.chapterStatus == ChapterStatus.COMPLETED)
		{
			chapterById.chapterStatus = ChapterStatus.COMPLETED;
		}
		else
		{
			chapterById.chapterStatus = ChapterStatus.PLAYED_NOT_COMPLETED;
		}
		if (completedLevel)
		{
			GameController.instance.achievementManager.UnlockAchievement(AchievementID.CHAPTER_FOUR);
		}
		if (chapterById.chapterCompletionStatus == ChapterCompletionStatus.HUNDRED_PERCENT_COMPLETE)
		{
			GameController.instance.achievementManager.UnlockAchievement(AchievementID.SAMARITAN);
		}
		UnityEngine.Debug.Log("About to save the data");
		SaveManager.instance.Save(SaveManager.instance.currentSavedGameSlot);
		EventManager.TriggerEvent(EventManager.AvailableEvents.MorgueChapterCompleted.ToString());
	}

	public void SetLevelCompletionForTomb(bool noHints, bool exorcisedCrack, bool noDeadEnds, bool completedLevel)
	{
		UnityEngine.Debug.Log("Setting Level Completion for Tomb");
		Chapter chapterById = SaveManager.instance.GetChapterById(ChapterID.TOMB);
		if (completedLevel)
		{
			chapterById.completionCheckmark1 = completedLevel;
		}
		if (noHints)
		{
			chapterById.completionCheckmark2 = noHints;
		}
		if (exorcisedCrack)
		{
			chapterById.completionCheckmark3 = exorcisedCrack;
		}
		if (noDeadEnds)
		{
			chapterById.completionCheckmark4 = noDeadEnds;
		}
		chapterById.chapterCompletionStatus = GetStatus(chapterById);
		if (chapterById.chapterCompletionStatus == ChapterCompletionStatus.HUNDRED_PERCENT_COMPLETE)
		{
			chapterById.chapterStatus = ChapterStatus.COMPLETED;
			chapterById.completed = true;
		}
		else if (completedLevel)
		{
			chapterById.chapterStatus = ChapterStatus.COMPLETED;
		}
		else if (chapterById.chapterStatus == ChapterStatus.COMPLETED)
		{
			chapterById.chapterStatus = ChapterStatus.COMPLETED;
		}
		else
		{
			chapterById.chapterStatus = ChapterStatus.PLAYED_NOT_COMPLETED;
		}
		if (completedLevel)
		{
			GameController.instance.achievementManager.UnlockAchievement(AchievementID.CHAPTER_FIVE);
		}
		if (chapterById.chapterCompletionStatus == ChapterCompletionStatus.HUNDRED_PERCENT_COMPLETE)
		{
			GameController.instance.achievementManager.UnlockAchievement(AchievementID.THE_TOMB);
		}
		UnityEngine.Debug.Log("About to save the data");
		SaveManager.instance.Save(SaveManager.instance.currentSavedGameSlot);
		EventManager.TriggerEvent(EventManager.AvailableEvents.TombChapterCompleted.ToString());
	}
}
public class LightAttach : MonoBehaviour
{
	private void Start()
	{
		base.gameObject.transform.parent = GameObject.Find("PlayerLight").transform;
		base.gameObject.transform.localPosition = Vector3.zero;
	}
}
public class LightController : MonoBehaviour
{
	[SerializeField]
	private Light[] lights;

	private LightFlicker[] lightFlickers;

	[SerializeField]
	private Renderer[] emissiveObjects;

	private UnityEngine.Color[] emissiveObjectsIntensity;

	[SerializeField]
	private ReflectionProbe[] reflectionProbes;

	private bool emissivesOff;

	private void Start()
	{
		List<LightFlicker> list = new List<LightFlicker>();
		Light[] array = lights;
		for (int i = 0; i < array.Length; i++)
		{
			LightFlicker component = array[i].gameObject.GetComponent<LightFlicker>();
			if (component != null)
			{
				list.Add(component);
			}
		}
		lightFlickers = list.ToArray();
		emissiveObjectsIntensity = new UnityEngine.Color[emissiveObjects.Length];
		ReflectionProbe[] array2 = reflectionProbes;
		for (int i = 0; i < array2.Length; i++)
		{
			array2[i].refreshMode = ReflectionProbeRefreshMode.ViaScripting;
		}
	}

	public void FlickerLights(float time, bool endOn)
	{
		if (base.isActiveAndEnabled)
		{
			LightFlicker[] array = lightFlickers;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].StartBurst(time, endOn);
			}
			StartCoroutine(WaitAndUpdateProbes(time));
		}
	}

	private IEnumerator WaitAndUpdateProbes(float time)
	{
		yield return Yield.WaitSeconds(time);
		UpdateReflectionProbes();
	}

	public void TurnOffLights()
	{
		for (int i = 0; i < lights.Length; i++)
		{
			lights[i].gameObject.SetActive(value: false);
		}
	}

	public void TurnOnLights()
	{
		for (int i = 0; i < lights.Length; i++)
		{
			lights[i].gameObject.SetActive(value: true);
		}
	}

	public void TurnOffEmissives()
	{
		emissivesOff = true;
		for (int i = 0; i < emissiveObjects.Length; i++)
		{
			emissiveObjectsIntensity[i] = emissiveObjects[i].sharedMaterial.GetColor("_EmissionColor");
			emissiveObjects[i].sharedMaterial.SetColor("_EmissionColor", UnityEngine.Color.clear);
		}
	}

	public void TurnOnEmissives()
	{
		emissivesOff = false;
		for (int i = 0; i < emissiveObjects.Length; i++)
		{
			emissiveObjects[i].sharedMaterial.SetColor("_EmissionColor", emissiveObjectsIntensity[i]);
		}
	}

	public void UpdateReflectionProbes()
	{
		ReflectionProbe[] array = reflectionProbes;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].RenderProbe();
		}
	}

	public void SwitchOffReflectionProbes()
	{
		ReflectionProbe[] array = reflectionProbes;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].intensity = 0f;
		}
	}

	private void OnDisable()
	{
		if (emissivesOff)
		{
			TurnOnEmissives();
		}
	}
}
public class LightFlicker : MonoBehaviour
{
	public bool on;

	private float random;

	public AudioClip sfxFlicker;

	public float volume = 1f;

	protected AudioSource m_audio;

	public Renderer[] parentRenderer;

	public float lowIntensity;

	public float highIntensity;

	private Material mat;

	public float noisePoint = 0.46f;

	[SerializeField]
	private GameObject[] additionalFx;

	public Light light;

	private Material[] materialsWhite;

	private Material[] materialsBlack;

	private Material[] materialsLow;

	public bool looping;

	public bool flickering;

	private float storedIntensity;

	private void Awake()
	{
		light = base.gameObject.GetComponent<Light>();
		if (light != null)
		{
			highIntensity = light.intensity;
			storedIntensity = highIntensity;
		}
		if (parentRenderer != null)
		{
			materialsWhite = new Material[parentRenderer.Length];
			materialsBlack = new Material[parentRenderer.Length];
			materialsLow = new Material[parentRenderer.Length];
			for (int i = 0; i < parentRenderer.Length; i++)
			{
				materialsWhite[i] = parentRenderer[i].material;
				materialsBlack[i] = parentRenderer[i].material;
				materialsLow[i] = parentRenderer[i].material;
			}
		}
	}

	private void Start()
	{
		if (sfxFlicker != null)
		{
			AudioMixer mainMixer = GameObject.Find("AudioController").GetComponent<AudioController>().mainMixer;
			m_audio = base.gameObject.AddComponent<AudioSource>();
			m_audio.outputAudioMixerGroup = mainMixer.FindMatchingGroups("Sfx")[0];
			m_audio.spatialBlend = 1f;
			m_audio.clip = sfxFlicker;
			m_audio.volume = volume;
		}
	}

	public void UpdateConnectedMaterials()
	{
		for (int i = 0; i < parentRenderer.Length; i++)
		{
			materialsWhite[i] = parentRenderer[i].material;
			materialsBlack[i] = parentRenderer[i].material;
			materialsLow[i] = parentRenderer[i].material;
		}
	}

	public void StartBurst(float timeFor, bool finishOn)
	{
		if (!base.gameObject.activeSelf)
		{
			base.gameObject.SetActive(value: true);
		}
		StartCoroutine(Burst(timeFor, finishOn));
		looping = false;
	}

	public IEnumerator Burst(float timeFor, bool finshOn)
	{
		flickering = true;
		on = true;
		if (additionalFx != null)
		{
			for (int i = 0; i < additionalFx.Length; i++)
			{
				additionalFx[i].SetActive(value: false);
			}
		}
		yield return Yield.WaitSeconds(timeFor);
		on = false;
		if (finshOn)
		{
			light.intensity = highIntensity;
			if (parentRenderer != null)
			{
				for (int j = 0; j < parentRenderer.Length; j++)
				{
					materialsBlack[j].SetColor("_EmissionColor", UnityEngine.Color.white);
				}
			}
			if (additionalFx != null)
			{
				for (int k = 0; k < additionalFx.Length; k++)
				{
					additionalFx[k].SetActive(value: true);
				}
			}
		}
		else
		{
			light.intensity = 0f;
			if (parentRenderer != null)
			{
				for (int l = 0; l < parentRenderer.Length; l++)
				{
					materialsBlack[l].SetColor("_EmissionColor", UnityEngine.Color.black);
				}
			}
		}
		flickering = false;
	}

	public void SwitchLight(bool switchOn, bool flickerOn = false)
	{
		if (looping)
		{
			StopCoroutine("LoopingFlicker");
			looping = false;
		}
		if (flickering)
		{
			StopCoroutine("Burst");
			on = false;
			flickering = false;
		}
		if (flickerOn)
		{
			on = true;
		}
		else
		{
			on = false;
		}
		if (switchOn)
		{
			light.intensity = highIntensity;
			if (parentRenderer != null)
			{
				for (int i = 0; i < parentRenderer.Length; i++)
				{
					materialsBlack[i].SetColor("_EmissionColor", UnityEngine.Color.white);
				}
			}
			if (additionalFx != null)
			{
				for (int j = 0; j < additionalFx.Length; j++)
				{
					additionalFx[j].SetActive(value: true);
				}
			}
			return;
		}
		light.intensity = 0f;
		if (parentRenderer != null)
		{
			for (int k = 0; k < parentRenderer.Length; k++)
			{
				materialsBlack[k].SetColor("_EmissionColor", UnityEngine.Color.black);
			}
		}
		if (additionalFx != null)
		{
			for (int l = 0; l < additionalFx.Length; l++)
			{
				additionalFx[l].SetActive(value: false);
			}
		}
	}

	private void Update()
	{
		if (!on)
		{
			return;
		}
		random = UnityEngine.Random.Range(0.4f, 0.6f);
		float num = Mathf.PerlinNoise(random, Time.time * 2f);
		if (num > noisePoint)
		{
			light.intensity = highIntensity;
			if (parentRenderer != null)
			{
				for (int i = 0; i < parentRenderer.Length; i++)
				{
					materialsBlack[i].SetColor("_EmissionColor", UnityEngine.Color.white);
				}
			}
		}
		else
		{
			light.intensity = lowIntensity;
			if (parentRenderer != null)
			{
				for (int j = 0; j < parentRenderer.Length; j++)
				{
					materialsBlack[j].SetColor("_EmissionColor", UnityEngine.Color.white * lowIntensity);
				}
			}
		}
		if (sfxFlicker != null && num > 0.58f)
		{
			m_audio.Play();
		}
	}

	public void Loop(float intervals, float onTime)
	{
		looping = true;
		StartCoroutine(LoopingFlicker(intervals, onTime));
	}

	private IEnumerator LoopingFlicker(float intervals, float onTime)
	{
		while (looping)
		{
			light.intensity = highIntensity;
			yield return Yield.WaitSeconds(onTime);
			light.intensity = lowIntensity;
			yield return Yield.WaitSeconds(intervals);
		}
	}

	public void StopLooping()
	{
		looping = false;
	}

	public void Fade(bool on, float time)
	{
		StartCoroutine(FadeLight(on, time));
	}

	private IEnumerator FadeLight(bool on, float time)
	{
		if (!light.isActiveAndEnabled)
		{
			light.enabled = true;
		}
		if (on)
		{
			while (light.intensity < highIntensity)
			{
				if (time == 0f)
				{
					light.intensity = highIntensity;
				}
				else
				{
					light.intensity += Time.deltaTime / time;
				}
				if (parentRenderer != null)
				{
					for (int i = 0; i < parentRenderer.Length; i++)
					{
						UnityEngine.Color value = new UnityEngine.Color(light.intensity, light.intensity, light.intensity, light.intensity);
						materialsBlack[i].SetColor("_EmissionColor", value);
					}
				}
				if (additionalFx != null)
				{
					for (int j = 0; j < additionalFx.Length; j++)
					{
						additionalFx[j].SetActive(value: true);
					}
				}
				yield return null;
			}
			yield break;
		}
		while (light.intensity > lowIntensity)
		{
			if (time == 0f)
			{
				light.intensity = lowIntensity;
			}
			else
			{
				light.intensity -= Time.deltaTime / time;
			}
			if (parentRenderer != null)
			{
				for (int k = 0; k < parentRenderer.Length; k++)
				{
					UnityEngine.Color value = new UnityEngine.Color(light.intensity, light.intensity, light.intensity, light.intensity);
					materialsBlack[k].SetColor("_EmissionColor", value);
				}
			}
			if (additionalFx != null)
			{
				for (int l = 0; l < additionalFx.Length; l++)
				{
					additionalFx[l].SetActive(value: false);
				}
			}
			yield return null;
		}
	}

	public void SetIntensity(float intensity)
	{
		light.intensity = intensity;
		if (parentRenderer != null)
		{
			for (int i = 0; i < parentRenderer.Length; i++)
			{
				UnityEngine.Color value = new UnityEngine.Color(light.intensity, light.intensity, light.intensity, light.intensity);
				materialsBlack[i].SetColor("_EmissionColor", value);
			}
		}
	}

	public void ResetIntensity()
	{
		highIntensity = storedIntensity;
	}

	public void SetHighIntensity(float newIntensity)
	{
		highIntensity = newIntensity;
	}
}
public class LightIntensityFlicker : MonoBehaviour
{
	public Light light;

	public float flickerSpeed = 0.5f;

	public float flickerIntensity = 0.05f;

	private float initialIntensity;

	private float targetIntensity;

	private bool increasing = true;

	public bool flickerActive = true;

	private void Start()
	{
		if (light == null)
		{
			light = base.gameObject.GetComponent<Light>();
		}
		if (light == null)
		{
			flickerActive = false;
			return;
		}
		initialIntensity = light.intensity;
		targetIntensity = UnityEngine.Random.Range(initialIntensity, initialIntensity + flickerIntensity);
	}

	private void Update()
	{
		if (!flickerActive)
		{
			return;
		}
		if (increasing)
		{
			if (targetIntensity >= light.intensity)
			{
				light.intensity += flickerSpeed * Time.deltaTime;
				return;
			}
			increasing = false;
			targetIntensity = UnityEngine.Random.Range(initialIntensity - flickerIntensity, initialIntensity);
		}
		else if (targetIntensity <= light.intensity && light.intensity > 0f)
		{
			light.intensity -= flickerSpeed * Time.deltaTime;
		}
		else
		{
			increasing = true;
			targetIntensity = UnityEngine.Random.Range(initialIntensity, initialIntensity + flickerIntensity);
		}
	}
}
public class LockerScript : MonoBehaviour
{
	[SerializeField]
	private GameObject lockerDoor;

	private NVRPlayer player;

	private bool leftHandInLocker;

	private bool rightHandInLocker;

	private bool achievementUnlocked;

	private void Start()
	{
		player = GameController.instance.player;
	}

	private void Update()
	{
		if (lockerDoor.transform.localEulerAngles.y < 10f && leftHandInLocker && rightHandInLocker && !achievementUnlocked)
		{
			achievementUnlocked = true;
			GameController.instance.achievementManager.UnlockAchievement(AchievementID.SNAKE);
		}
	}

	private void OnTriggerStay(Collider other)
	{
		if (other.gameObject.transform.parent != null && other.gameObject.transform.parent.transform.parent.gameObject != null)
		{
			if (other.gameObject.transform.parent.transform.parent.gameObject == player.LeftHand.gameObject)
			{
				leftHandInLocker = true;
			}
			else if (other.gameObject.transform.parent.transform.parent.gameObject == player.RightHand.gameObject)
			{
				rightHandInLocker = true;
			}
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (other.gameObject.transform.parent != null && other.gameObject.transform.parent.transform.parent.gameObject != null)
		{
			if (other.gameObject.transform.parent.transform.parent.gameObject == player.LeftHand.gameObject)
			{
				leftHandInLocker = false;
			}
			else if (other.gameObject.transform.parent.transform.parent.gameObject == player.RightHand.gameObject)
			{
				rightHandInLocker = false;
			}
		}
	}
}
public class LookAt : MonoBehaviour
{
	[Header("Adams LookAt Vars")]
	[SerializeField]
	private Transform lookFrom;

	public Transform lookAt;

	public bool looking;

	public float lookSpeed = 1f;

	public bool useEyes = true;

	public Transform leftEye;

	public Transform rightEye;

	public Vector3 offset;

	private Quaternion lastRot;

	[Header("LookAt Using IK")]
	[SerializeField]
	private LookAtIK lookIK;

	private float headWeighting = 0.5f;

	private float bodyWeighting = 0.5f;

	private float eyeWeighting = 1f;

	private void Start()
	{
		if (lookFrom == null)
		{
			lookFrom = base.gameObject.transform;
		}
		lastRot = lookFrom.rotation;
		if ((bool)lookIK)
		{
			headWeighting = lookIK.solver.headWeight;
			bodyWeighting = lookIK.solver.bodyWeight;
			eyeWeighting = lookIK.solver.eyesWeight;
			lookIK.solver.bodyWeight = 0f;
			lookIK.solver.headWeight = 0f;
			lookIK.solver.eyesWeight = 0f;
		}
	}

	private void LateUpdate()
	{
		if (looking)
		{
			lookFrom.rotation = lastRot;
			Vector3 target = lookAt.position - lookFrom.position;
			float maxRadiansDelta = lookSpeed * Time.deltaTime;
			Vector3 vector = Vector3.RotateTowards(lookFrom.forward, target, maxRadiansDelta, 0f);
			lookFrom.rotation = Quaternion.LookRotation(vector + offset);
			lastRot = lookFrom.rotation;
			if (useEyes)
			{
				if ((bool)leftEye)
				{
					leftEye.LookAt(lookAt);
					rightEye.LookAt(lookAt);
				}
				else
				{
					UnityEngine.Debug.LogError("LookAt: Null reference on LeftEye/RightEye - Fix by dragging references from mixamorig or uncheck Use Eyes if not needed");
				}
			}
		}
		else
		{
			lastRot = lookFrom.rotation;
		}
	}

	public void StopLookingIK(float time = 0f)
	{
		if (time == 0f)
		{
			lookIK.solver.bodyWeight = 0f;
			lookIK.solver.headWeight = 0f;
			lookIK.solver.eyesWeight = 0f;
		}
		else
		{
			StartCoroutine(StopIK(time));
		}
	}

	private IEnumerator StopIK(float time)
	{
		for (float t = 1f; t > 0f; t += Time.deltaTime / time)
		{
			lookIK.solver.bodyWeight = t;
			lookIK.solver.headWeight = t;
			lookIK.solver.eyesWeight = t;
			yield return null;
		}
		lookIK.solver.bodyWeight = 0f;
		lookIK.solver.headWeight = 0f;
		lookIK.solver.eyesWeight = 0f;
	}

	public void StartLookingIK(float time = 0f)
	{
		if (time == 0f)
		{
			lookIK.solver.bodyWeight = bodyWeighting;
			lookIK.solver.headWeight = headWeighting;
			lookIK.solver.eyesWeight = eyeWeighting;
		}
		else
		{
			StartCoroutine(StartIK(time, bodyWeighting, headWeighting, eyeWeighting));
		}
	}

	public void StartLookingIK(float time, float bodyWeight, float headWeight, float eyeWeight)
	{
		if (time == 0f)
		{
			lookIK.solver.bodyWeight = bodyWeight;
			lookIK.solver.headWeight = headWeight;
			lookIK.solver.eyesWeight = eyeWeight;
		}
		else
		{
			StartCoroutine(StartIK(time, bodyWeight, headWeight, eyeWeight));
		}
	}

	private IEnumerator StartIK(float time, float bodyWeight, float headWeight, float eyeWeight)
	{
		for (float t = 0f; t < 1f; t += Time.deltaTime / time)
		{
			lookIK.solver.bodyWeight = t * bodyWeight;
			lookIK.solver.headWeight = t * headWeight;
			lookIK.solver.eyesWeight = t * eyeWeight;
			yield return null;
		}
	}
}
public class Maggot : MonoBehaviour
{
	private Rigidbody rb;

	private BoxCollider col;

	public void StartCrawl(float time)
	{
		StartCoroutine(Crawl(time));
	}

	private IEnumerator Crawl(float time)
	{
		LeanTween.moveLocalY(base.gameObject, base.transform.localPosition.y + 0.0041f, 2f).setEaseInOutQuad();
		yield return Yield.WaitSeconds(2f);
	}
}
public class MaryC5 : MonoBehaviour
{
	[SerializeField]
	private SkinnedMeshRenderer mesh;

	[SerializeField]
	private float breathingDuration;

	[SerializeField]
	private float faceBlendMinDistance;

	[SerializeField]
	private float faceBlendMaxDistance;

	[SerializeField]
	private float maxBreathingBlend;

	[SerializeField]
	private float lookAtPlayerDuration;

	[SerializeField]
	private Transform head;

	[SerializeField]
	private Transform neck;

	public bool updateLookAtTimer;

	private NVRPlayer _player;

	private Vector3 _rotationOffset;

	private bool _updateFaceBlend = true;

	private bool _updateBreathingBlend;

	public bool UpdateFaceBlend
	{
		get
		{
			return _updateFaceBlend;
		}
		set
		{
			_updateFaceBlend = value;
			if (!_updateFaceBlend)
			{
				mesh.SetBlendShapeWeight(0, 0f);
			}
		}
	}

	public bool UpdateBreathingBlend
	{
		get
		{
			return _updateBreathingBlend;
		}
		set
		{
			_updateBreathingBlend = value;
			if (!_updateBreathingBlend)
			{
				mesh.SetBlendShapeWeight(1, 0f);
			}
		}
	}

	private void Start()
	{
		_player = GameController.instance.player;
		mesh.SetBlendShapeWeight(0, 0f);
		mesh.SetBlendShapeWeight(1, 0f);
		_rotationOffset = head.transform.rotation.eulerAngles;
	}

	public void SetMaryHeadDown()
	{
		head.rotation = Quaternion.Euler(55f, 9.3f, 82.7f);
		neck.rotation = Quaternion.Euler(12.9f, 187.9f, 273.1f);
	}

	public void RunMaryLookAt()
	{
		StartCoroutine(MaryLookAtRoutine());
	}

	private IEnumerator MaryLookAtRoutine()
	{
		while (!updateLookAtTimer)
		{
			LookAt();
			yield return Yield.EndOfFrame;
		}
		for (float counter = 0f; counter < lookAtPlayerDuration; counter += Time.deltaTime)
		{
			LookAt();
			yield return Yield.EndOfFrame;
		}
	}

	private void LookAt()
	{
		Vector3 forward = head.transform.position - GameController.instance.player.Head.transform.position;
		head.transform.rotation = Quaternion.LookRotation(forward);
		head.transform.rotation = Quaternion.Euler(head.transform.rotation.eulerAngles + _rotationOffset);
		Vector3 eulerAngles = head.transform.rotation.eulerAngles;
		if (eulerAngles.x < 50f)
		{
			head.transform.rotation = Quaternion.Euler(50f, eulerAngles.y, eulerAngles.z);
		}
	}

	private void Update()
	{
		float num = Mathf.Clamp(Mathf.Abs(Vector3.Distance(b: new Vector3(base.transform.position.x, _player.Head.transform.position.y, base.transform.position.z), a: _player.Head.transform.position)), 0f, faceBlendMaxDistance);
		if (_updateFaceBlend && num > faceBlendMinDistance)
		{
			mesh.SetBlendShapeWeight(0, 100f * (num - faceBlendMinDistance) / (faceBlendMaxDistance - faceBlendMinDistance));
		}
		else if (!_updateFaceBlend || num <= faceBlendMinDistance)
		{
			mesh.SetBlendShapeWeight(0, 0f);
		}
	}

	public void RunBreathing()
	{
		StartCoroutine(BreathingRoutine());
	}

	private IEnumerator BreathingRoutine()
	{
		_updateBreathingBlend = true;
		bool forward = true;
		while (_updateBreathingBlend)
		{
			for (float counter = 0f; counter < breathingDuration; counter += Time.deltaTime)
			{
				mesh.SetBlendShapeWeight(1, forward ? (maxBreathingBlend * counter / breathingDuration) : (maxBreathingBlend - maxBreathingBlend * counter / breathingDuration));
				yield return Yield.EndOfFrame;
			}
			forward = !forward;
		}
	}
}
public class MazeCell : MonoBehaviour
{
	public enum CellFace
	{
		FRONT,
		BACK,
		LEFT,
		RIGHT,
		FLOOR,
		ROOF
	}

	[Serializable]
	public struct CellStructure
	{
		public CellFace face;

		public GameObject paddedWall;

		public GameObject rockWall;

		public void SetRockWallEnabled(bool enabled)
		{
			if ((bool)paddedWall)
			{
				paddedWall.SetActive(!enabled);
			}
			if ((bool)rockWall)
			{
				rockWall.SetActive(enabled);
			}
		}
	}

	[Serializable]
	public struct PrisionerMeshFadeOut
	{
		public SkinnedMeshRenderer skinnedMeshRenderer;

		public Material standardMaterial;

		public Material fadeMaterial;
	}

	[SerializeField]
	private TombScene tombScene;

	[SerializeField]
	private Transform playerStartPos;

	[SerializeField]
	public InteractiveDoor cellEntranceDoor;

	[SerializeField]
	public InteractiveDoor cellExitDoor;

	[SerializeField]
	private GameObject cellEntranceDoorObj;

	[SerializeField]
	private GameObject cellExitDoorObj;

	[SerializeField]
	private GameObject cellEntranceWallWithDoor;

	[SerializeField]
	private GameObject cellEntranceWallNoDoor;

	[SerializeField]
	private GameObject cellExitWallWithDoor;

	[SerializeField]
	private GameObject cellExitWallNoDoor;

	[SerializeField]
	private GameObject flames;

	[SerializeField]
	private LightFlicker flameLight;

	[SerializeField]
	private GameObject prisoner;

	[SerializeField]
	public PrisionerMeshFadeOut[] prisonerBodyMeshRenderers;

	[SerializeField]
	private Animator prisonerAnimator;

	[SerializeField]
	private Renderer cellDoorRenderer;

	[SerializeField]
	private Light cellWindowLight;

	[SerializeField]
	private GameObject backWallCollider;

	[SerializeField]
	private Transform prisonerExitDoorPos;

	[SerializeField]
	private Transform prisonerEntranceDoorPos;

	[SerializeField]
	private Transform prisonerCrossFirePos;

	[SerializeField]
	private Transform prisonerCrossPos;

	[SerializeField]
	public LightFlicker ceilingLight;

	[SerializeField]
	private GameObject ceilingLightObject;

	[SerializeField]
	private BipedIK prisonerBipedIk;

	[SerializeField]
	private ParticleSystem fireParticles;

	[SerializeField]
	private ParticleSystem combustParticles;

	[SerializeField]
	private GameObject bedLeft;

	[SerializeField]
	private GameObject bedRight;

	[SerializeField]
	private GameObject crossPrisioner;

	[SerializeField]
	public FireObstacleC5 crossFireCollider;

	[SerializeField]
	private ParticleSystem crossFireParticles;

	[SerializeField]
	private LightFlicker crossFireLight;

	[SerializeField]
	private GameObject[] frontWallRocks;

	[SerializeField]
	private GameObject navBlocker;

	[SerializeField]
	private CellStructure[] structure;

	[SerializeField]
	private MeshRenderer[] exitDoorRenders;

	[Space]
	[Header("Audio")]
	[SerializeField]
	private AudioScript cellFoleyAudio;

	[SerializeField]
	private AudioClip fireSfx;

	[SerializeField]
	private AudioClip fireBurstSfx;

	[SerializeField]
	private AudioClip fireDouceClip;

	[SerializeField]
	private AudioClip prisionerVOClip;

	[SerializeField]
	private LipSync prisonerLipSync;

	[SerializeField]
	private LipSyncData prisonerLipSyncData01;

	[SerializeField]
	private AudioClip[] whisperClips;

	[SerializeField]
	private Transform[] whipserPoints;

	[SerializeField]
	private AudioClip doorSlamClip;

	[HideInInspector]
	public bool doorLocked = true;

	[HideInInspector]
	public bool hasCellCaveFinished;

	[HideInInspector]
	public bool hasCellCaveWhispersFinished;

	private void Start()
	{
		cellEntranceWallWithDoor.SetActive(value: true);
		cellEntranceWallNoDoor.SetActive(value: false);
		cellExitDoorObj.SetActive(value: false);
		cellExitWallWithDoor.SetActive(value: false);
		flames.SetActive(value: false);
		prisoner.SetActive(value: false);
		cellExitWallNoDoor.SetActive(value: true);
		crossPrisioner.SetActive(value: false);
		navBlocker.SetActive(value: false);
		for (int i = 0; i < structure.Length; i++)
		{
			structure[i].SetRockWallEnabled(enabled: false);
		}
		for (int j = 0; j < prisonerBodyMeshRenderers.Length; j++)
		{
			PrisionerMeshFadeOut prisionerMeshFadeOut = prisonerBodyMeshRenderers[j];
			prisionerMeshFadeOut.skinnedMeshRenderer.material = prisionerMeshFadeOut.standardMaterial;
		}
		cellDoorRenderer.sharedMaterial.SetColor("_EmissionColor", UnityEngine.Color.black);
		ceilingLight.SwitchLight(switchOn: false);
		prisoner.transform.position = prisonerEntranceDoorPos.position;
		prisoner.transform.rotation = prisonerEntranceDoorPos.rotation;
	}

	private void OnDisable()
	{
		for (int i = 0; i < prisonerBodyMeshRenderers.Length; i++)
		{
			PrisionerMeshFadeOut prisionerMeshFadeOut = prisonerBodyMeshRenderers[i];
			prisionerMeshFadeOut.skinnedMeshRenderer.material = prisionerMeshFadeOut.standardMaterial;
		}
	}

	public void SetRockWall(CellFace face, bool enabled)
	{
		Array.Find(structure, (CellStructure e) => e.face == face).SetRockWallEnabled(enabled);
		if (face == CellFace.FRONT && enabled)
		{
			cellWindowLight.enabled = false;
			bedLeft.SetActive(value: false);
			bedRight.SetActive(value: false);
		}
	}

	public bool IsCellCave()
	{
		if (!base.gameObject.activeInHierarchy)
		{
			return false;
		}
		CellStructure[] array = structure;
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i].paddedWall.activeInHierarchy)
			{
				return false;
			}
		}
		return true;
	}

	public void RunPrisionerOnCross()
	{
		StartCoroutine(PrisionerOnCrossRoutine());
	}

	public void RunWhispers()
	{
		StartCoroutine(WhispersRoutine());
	}

	private IEnumerator WhispersRoutine()
	{
		AudioScript audioScript1 = AudioScriptContainer.Instance.audioScripts[1];
		AudioScript audioScript2 = AudioScriptContainer.Instance.audioScripts[2];
		navBlocker.SetActive(value: true);
		tombScene.musicStem01.FadeIn(tombScene.musicBuildWhipsers, 1f, 8.5f, loop: true);
		audioScript1.transform.position = whipserPoints[0].position;
		audioScript1.Play(whisperClips[0]);
		yield return Yield.WaitSeconds(2.5f);
		audioScript2.transform.position = whipserPoints[1].position;
		audioScript2.Play(whisperClips[1]);
		ceilingLight.StartBurst(5f, finishOn: false);
		yield return Yield.WaitSeconds(0.5f);
		ceilingLightObject.SetActive(value: false);
		yield return Yield.WaitSeconds(3.5f);
		audioScript1.transform.position = whipserPoints[2].position;
		audioScript1.Play(whisperClips[2]);
		yield return Yield.WaitSeconds(2f);
		hasCellCaveWhispersFinished = true;
	}

	private IEnumerator PrisionerOnCrossRoutine()
	{
		AudioScript audioScript1 = AudioScriptContainer.Instance.audioScripts[1];
		AudioScript audioScript2 = AudioScriptContainer.Instance.audioScripts[2];
		cellDoorRenderer.sharedMaterial.SetColor("_EmissionColor", UnityEngine.Color.black);
		prisoner.transform.SetParent(prisonerCrossPos);
		prisoner.transform.position = prisonerCrossPos.position;
		prisoner.transform.rotation = prisonerCrossPos.rotation;
		prisoner.SetActive(value: true);
		yield return Yield.EndOfFrame;
		crossPrisioner.SetActive(value: true);
		yield return Yield.EndOfFrame;
		prisonerAnimator.SetTrigger("CrossIdle");
		cellFoleyAudio.transform.position = prisonerCrossFirePos.position;
		cellFoleyAudio.FadeIn(fireSfx, 1f, 0.5f, loop: true);
		GameController.instance.audioController.PlayBadSting(STINGS_BAD.BAD_STING_05, 0.75f);
		yield return Yield.WaitSeconds(3.5f);
		prisonerAnimator.SetTrigger("CrossSpeak");
		yield return Yield.WaitSeconds(0.5f);
		prisonerLipSync.Play(prisonerLipSyncData01);
		HUD.Instance.PlaySubtitles(prisonerLipSyncData01.clip.name, hasPriority: true);
		yield return Yield.WaitSeconds(0.5f);
		crossFireCollider.active = true;
		while (crossFireCollider.IsOnFire)
		{
			yield return Yield.EndOfFrame;
		}
		tombScene.musicStem01.FadeOut(2f);
		cellFoleyAudio.FadeOut(0.5f);
		crossFireParticles.Stop();
		audioScript1.transform.position = prisonerCrossFirePos.transform.position;
		audioScript1.Play(fireDouceClip, 0.25f);
		cellFoleyAudio.transform.position = prisonerCrossFirePos.position;
		cellFoleyAudio.Play(fireBurstSfx);
		prisonerAnimator.SetTrigger("CrossExpel");
		yield return Yield.EndOfFrame;
		combustParticles.Play();
		for (int j = 0; j < prisonerBodyMeshRenderers.Length; j++)
		{
			PrisionerMeshFadeOut prisionerMeshFadeOut = prisonerBodyMeshRenderers[j];
			prisionerMeshFadeOut.skinnedMeshRenderer.material = prisionerMeshFadeOut.fadeMaterial;
			prisionerMeshFadeOut.skinnedMeshRenderer.material.SetFloat("_Dissolve", 0f);
		}
		crossFireLight.Fade(on: false, 4f);
		float dissolveDuration = 4f;
		bool fadedLight = false;
		for (float counter = 0f; counter < dissolveDuration; counter += Time.deltaTime)
		{
			for (int k = 0; k < prisonerBodyMeshRenderers.Length; k++)
			{
				prisonerBodyMeshRenderers[k].skinnedMeshRenderer.material.SetFloat("_Dissolve", counter / dissolveDuration);
			}
			if (counter > dissolveDuration / 2f && !fadedLight)
			{
				crossFireLight.Fade(on: false, dissolveDuration);
			}
			yield return Yield.EndOfFrame;
		}
		audioScript1.transform.position = whipserPoints[0].position;
		audioScript1.Play(whisperClips[0]);
		yield return Yield.WaitSeconds(2f);
		bedRight.SetActive(value: true);
		yield return Yield.EndOfFrame;
		bedLeft.SetActive(value: false);
		yield return Yield.EndOfFrame;
		for (int i = 0; i < frontWallRocks.Length; i++)
		{
			frontWallRocks[i].SetActive(value: false);
			yield return Yield.EndOfFrame;
		}
		SetRockWall(CellFace.RIGHT, enabled: false);
		backWallCollider.SetActive(value: false);
		cellExitWallWithDoor.SetActive(value: true);
		yield return Yield.EndOfFrame;
		cellExitWallNoDoor.SetActive(value: false);
		cellExitDoorObj.gameObject.SetActive(value: true);
		yield return Yield.EndOfFrame;
		ceilingLightObject.SetActive(value: true);
		yield return Yield.EndOfFrame;
		structure[0].paddedWall.SetActive(value: true);
		yield return Yield.EndOfFrame;
		crossPrisioner.SetActive(value: false);
		prisoner.SetActive(value: false);
		navBlocker.SetActive(value: false);
		audioScript2.transform.position = whipserPoints[3].position;
		audioScript2.Play(whisperClips[3]);
		yield return Yield.WaitSeconds(1.5f);
		ceilingLight.StartBurst(1f, finishOn: true);
		hasCellCaveFinished = true;
	}

	private IEnumerator RemoveLookAt(float delayTime)
	{
		yield return Yield.WaitSeconds(delayTime);
		prisonerBipedIk.SetLookAtWeight(0f, 0f, 0f, 0f, 0f, 0f, 0f);
	}

	public void DeactivateEntranceDoor()
	{
		cellEntranceWallWithDoor.SetActive(value: false);
		cellEntranceWallNoDoor.SetActive(value: true);
	}

	public void ActivateExitDoor()
	{
		backWallCollider.SetActive(value: false);
		cellExitWallWithDoor.SetActive(value: true);
		cellExitWallNoDoor.SetActive(value: false);
		cellExitDoorObj.gameObject.SetActive(value: true);
		prisoner.SetActive(value: true);
		prisonerAnimator.SetTrigger("Reveal");
		prisoner.transform.position = prisonerExitDoorPos.position;
		prisoner.transform.rotation = prisonerExitDoorPos.rotation;
	}

	public void RunFlamingCellRoutine()
	{
		StartCoroutine(FlamingCellRoutine());
	}

	private IEnumerator FlamingCellRoutine()
	{
		yield return Yield.WaitSeconds(1f);
		GameController.instance.audioController.PlayBadSting(STINGS_BAD.BAD_STING_03);
		prisoner.transform.SetParent(prisonerEntranceDoorPos);
		prisoner.transform.position = prisonerEntranceDoorPos.position;
		prisoner.transform.rotation = prisonerEntranceDoorPos.rotation;
		prisoner.SetActive(value: true);
		prisonerAnimator.SetTrigger("SlamOnDoor");
		yield return Yield.EndOfFrame;
		flames.SetActive(value: true);
		flameLight.StartBurst(0.5f, finishOn: true);
		yield return Yield.EndOfFrame;
		cellFoleyAudio.transform.position = prisonerEntranceDoorPos.position;
		cellFoleyAudio.FadeIn(fireSfx, 1f, 1f, loop: true);
		yield return Yield.WaitSeconds(10f);
		fireParticles.Stop();
		flameLight.Fade(on: false, 1.8f);
		yield return Yield.WaitSeconds(1.8f);
		cellFoleyAudio.FadeOut(0.5f);
		ceilingLight.StartBurst(0.8f, finishOn: true);
		yield return Yield.WaitSeconds(2f);
		prisoner.SetActive(value: false);
		cellDoorRenderer.sharedMaterial.SetColor("_EmissionColor", new UnityEngine.Color(0.2863f, 0.2863f, 0.2863f));
		cellEntranceDoor.doorLocked = false;
		doorLocked = false;
	}

	public void CloseExitDoor()
	{
		cellExitDoor.LockDoor();
	}
}
public class MazeChapel : MonoBehaviour
{
	[SerializeField]
	private TombScene tombScene;

	[Header("General")]
	[SerializeField]
	public InteractiveDoor exitDoor;

	[SerializeField]
	private GameObject wallEntrance;

	[SerializeField]
	private MeshRenderer[] paintings;

	[SerializeField]
	public GameObject fatherBellDead;

	[SerializeField]
	private Animator fatherBellDeadAnim;

	[SerializeField]
	private GameObject pigMan;

	[SerializeField]
	private Animator pigManAnim;

	[SerializeField]
	private GameObject pigHead;

	[SerializeField]
	private GameObject tapePlayer;

	[SerializeField]
	private ReflectionProbe[] reflectionProbes;

	[SerializeField]
	private Transform pigManRedRoomLocation;

	[SerializeField]
	private GameObject entranceRocks;

	[SerializeField]
	private GameObject chapelMainStructure;

	[SerializeField]
	private GameObject chapelExitDoorStructure;

	[Space]
	[Header("Standard Room")]
	[SerializeField]
	private Material standardPaintingMat;

	[SerializeField]
	private GameObject exitDoorObj;

	[SerializeField]
	private GameObject wallWithDoor;

	[SerializeField]
	private LightFlicker deskLight;

	[SerializeField]
	private LightFlicker deskLightAmbient;

	[SerializeField]
	private Clock clock;

	[SerializeField]
	private Pendulum pendulum;

	[SerializeField]
	private MeshRenderer[] exitDoorRenderers;

	[Space]
	[Header("Red Room")]
	[SerializeField]
	private Material bloodyPaintingMat;

	[SerializeField]
	private GameObject redRoomBooks;

	[SerializeField]
	private GameObject redRoomCrucifixWalls;

	[SerializeField]
	private GameObject wallWithNoDoor;

	[SerializeField]
	private LightFlicker redStrobe;

	[SerializeField]
	private ChapelChairsC5 redRoomChairs;

	[SerializeField]
	private Animator redRoomChairsAnimator;

	[SerializeField]
	private GameObject redRoomDesk;

	[SerializeField]
	private Animator redRoomDeskAnimator;

	[Space]
	[Header("Throw Books")]
	[SerializeField]
	private float explosionForce;

	[SerializeField]
	private float explosionRadius;

	[SerializeField]
	private Transform explosionPosition;

	[SerializeField]
	private ParticleSystem pageParticle;

	[Space]
	[Header("Pig Man Charge Player")]
	[SerializeField]
	private Transform pigManStartLocation;

	private SkinnedMeshRenderer[] _pigManSkinnedMeshes;

	private MeshRenderer[] _pigManMeshes;

	[Space]
	[Header("Audio")]
	[SerializeField]
	private AudioScript redRoomAudio;

	[HideInInspector]
	private AudioScript floatAudio01;

	[HideInInspector]
	private AudioScript floatAudio02;

	[HideInInspector]
	private AudioScript floatAudio03;

	[SerializeField]
	private AudioClip redNoise_Clip;

	[SerializeField]
	private AudioScript tapeAudioNormal;

	[SerializeField]
	private AudioScript tapeAudioRedRoom;

	[SerializeField]
	private AudioClip redRoomAudioHeavy;

	[SerializeField]
	private AudioClip fatherBellVoNormal;

	[SerializeField]
	private AudioClip fatherBellVoRedRoom;

	[SerializeField]
	private AudioClip redRoomHarsh;

	[SerializeField]
	private AudioClip doorSlamClip;

	[SerializeField]
	private Transform[] floatingPoints;

	[SerializeField]
	private AudioClip[] floatingClips;

	private Transform target;

	private bool _updatePigManRot;

	private bool _playedClockChime;

	private bool _hasStoppedBellAudio;

	[HideInInspector]
	private bool firstScare;

	[HideInInspector]
	public bool thrownBooks;

	[HideInInspector]
	public bool thrownChair;

	[HideInInspector]
	public bool pigManAttackedPlayer;

	[HideInInspector]
	public bool isRunningCoroutine;

	[HideInInspector]
	public bool useDefaultPigBellAnimation;

	private void Start()
	{
		_pigManSkinnedMeshes = pigMan.GetComponentsInChildren<SkinnedMeshRenderer>();
		_pigManMeshes = pigMan.GetComponentsInChildren<MeshRenderer>();
		clock.Stop();
		redStrobe.gameObject.SetActive(value: true);
		redStrobe.light.enabled = true;
		redStrobe.SwitchLight(switchOn: false);
		deskLight.gameObject.SetActive(value: true);
		if (deskLight.light == null)
		{
			deskLight.light = deskLight.gameObject.GetComponent<Light>();
		}
		deskLight.light.enabled = true;
		deskLight.SwitchLight(switchOn: true);
		deskLightAmbient.gameObject.SetActive(value: false);
		pigHead.SetActive(value: false);
		exitDoorObj.SetActive(value: true);
		wallWithDoor.SetActive(value: true);
		wallWithNoDoor.SetActive(value: false);
		wallEntrance.SetActive(value: false);
		fatherBellDead.SetActive(value: true);
		pigMan.SetActive(value: false);
		entranceRocks.SetActive(value: true);
		redRoomBooks.SetActive(value: true);
		redRoomChairs.gameObject.SetActive(value: true);
		redRoomDesk.SetActive(value: true);
		floatAudio01 = AudioScriptContainer.Instance.audioScripts[0];
		floatAudio02 = AudioScriptContainer.Instance.audioScripts[1];
		floatAudio03 = AudioScriptContainer.Instance.audioScripts[2];
		SetRedRoom(redRoomEnabled: false, playAudio: false);
	}

	private void OnEnable()
	{
		redRoomCrucifixWalls.SetActive(value: false);
		fatherBellDeadAnim.SetTrigger("C5Seat");
	}

	public void RunChapel()
	{
		isRunningCoroutine = true;
		StartCoroutine(RunChapelRoutine());
	}

	public void BlockEntrance()
	{
		wallEntrance.SetActive(value: true);
		entranceRocks.SetActive(value: false);
		fatherBellDeadAnim.SetTrigger("C5Seat");
	}

	public void StartFatherBellTape()
	{
		tapeAudioNormal.Play(fatherBellVoNormal, 0.7f);
		HUD.Instance.PlaySubtitles(fatherBellVoNormal.name, hasPriority: true);
	}

	private IEnumerator RunChapelRoutine()
	{
		isRunningCoroutine = true;
		useDefaultPigBellAnimation = false;
		pigMan.SetActive(value: false);
		redRoomAudio.PlayLoop(redNoise_Clip, 0f);
		GameController.instance.audioController.PlayBadSting(STINGS_BAD.BAD_SOFT_STING_02, 0.7f);
		fatherBellDeadAnim.SetTrigger("C5Spray");
		floatAudio01.transform.position = floatingPoints[4].position;
		floatAudio01.Play(floatingClips[4]);
		yield return Yield.WaitSeconds(3f);
		fatherBellDead.SetActive(value: false);
		tapePlayer.SetActive(value: false);
		SetRedRoom(redRoomEnabled: true);
		pigHead.SetActive(value: true);
		firstScare = true;
		yield return Yield.WaitSeconds(4f);
		useDefaultPigBellAnimation = true;
		isRunningCoroutine = false;
	}

	public void RunThrowBooks()
	{
		isRunningCoroutine = true;
		StartCoroutine(ThrowBooksRoutine());
	}

	public void RunChairLift()
	{
		redRoomChairsAnimator.SetTrigger("ChairLift");
	}

	public void RunThrowChair(Vector3 targetPos)
	{
		isRunningCoroutine = true;
		StartCoroutine(ThrowChairRoutine(targetPos));
	}

	public void RunPigMan()
	{
		isRunningCoroutine = true;
		StartCoroutine(PigManRoutine());
	}

	private void Update()
	{
		if (_updatePigManRot)
		{
			Vector3 forward = GameController.instance.player.Head.transform.position - pigMan.transform.position;
			forward.y = 0f;
			pigMan.transform.rotation = Quaternion.LookRotation(forward);
		}
	}

	private IEnumerator PigManRoutine()
	{
		redStrobe.lowIntensity = 0.7f;
		SetRedRoom(redRoomEnabled: true);
		pigMan.SetActive(value: true);
		pigManAnim.SetTrigger("C5Wait");
		GameController.instance.audioController.PlayBadSting(STINGS_BAD.BAD_STING_06);
		NVRPlayer player = GameController.instance.player;
		yield return Yield.WaitSeconds(0.8f);
		redRoomAudio.PlayFromTime(redRoomAudioHeavy, redRoomAudio.m_AudioSource.time, 0.8f);
		_updatePigManRot = true;
		pigManAnim.SetTrigger("Run");
		floatAudio01.transform.position = floatingPoints[5].position;
		floatAudio01.Play(floatingClips[5]);
		yield return Yield.WaitSeconds(0.7f);
		player.screenFX.Fade(UnityEngine.Color.black, 0.2f);
		yield return Yield.WaitSeconds(0.25f);
		SetRedRoom(redRoomEnabled: false);
		pigMan.SetActive(value: false);
		_updatePigManRot = false;
		player.screenFX.Fade(UnityEngine.Color.clear, 0f);
		exitDoor.doorLocked = false;
		pigManAttackedPlayer = true;
		isRunningCoroutine = false;
		UnityEngine.Debug.Log("Finished running PigManRoutine");
		yield return Yield.WaitSeconds(2.5f);
		clock.Stop();
		pendulum.Stop();
	}

	private IEnumerator ThrowBooksRoutine()
	{
		SetRedRoom(redRoomEnabled: true);
		isRunningCoroutine = true;
		pageParticle.Play();
		floatAudio01.transform.position = floatingPoints[3].position;
		floatAudio01.Play(floatingClips[3]);
		Collider[] array = Physics.OverlapSphere(explosionPosition.position, explosionRadius);
		Collider[] array2 = array;
		foreach (Collider collider in array2)
		{
			Rigidbody component = collider.GetComponent<Rigidbody>();
			if (component != null && collider.gameObject.activeInHierarchy && component.gameObject.tag == "RedRoomBook")
			{
				component.isKinematic = false;
				Vector3 position = component.position;
				position.x += 1f;
				component.AddExplosionForce(explosionForce, position, explosionRadius, 0.2f);
				yield return Yield.WaitSeconds(UnityEngine.Random.Range(0.05f, 0.2f));
			}
		}
		floatAudio02.transform.position = floatingPoints[2].position;
		floatAudio02.Play(floatingClips[2]);
		yield return Yield.EndOfFrame;
		redRoomDeskAnimator.SetTrigger("Slam");
		yield return Yield.WaitSeconds(0.5f);
		floatAudio01.transform.position = floatingPoints[2].position;
		floatAudio01.Play(floatingClips[1]);
		yield return Yield.WaitSeconds(1f);
		SetRedRoom(redRoomEnabled: false);
		thrownBooks = true;
		isRunningCoroutine = false;
		UnityEngine.Debug.Log("Finished running ThrowBooksRoutine");
	}

	private IEnumerator ThrowChairRoutine(Vector3 targetPos)
	{
		SetRedRoom(redRoomEnabled: true);
		isRunningCoroutine = true;
		tapeAudioRedRoom.FadeIn(tombScene.musicBuildSiren, 1f, 5.25f, loop: true);
		while (!redRoomChairs.playedFullChairLiftAnim)
		{
			yield return Yield.WaitSeconds(0.5f);
		}
		redRoomChairsAnimator.SetTrigger("Throw");
		yield return Yield.EndOfFrame;
		tapeAudioRedRoom.StopLoop();
		yield return Yield.WaitSeconds(0.25f);
		floatAudio01.transform.position = floatingPoints[0].position;
		floatAudio01.Play(floatingClips[1]);
		yield return Yield.WaitSeconds(0.15f);
		floatAudio02.transform.position = floatingPoints[1].position;
		floatAudio02.Play(floatingClips[1]);
		yield return Yield.WaitSeconds(1.1f);
		SetRedRoom(redRoomEnabled: false);
		thrownChair = true;
		isRunningCoroutine = false;
		UnityEngine.Debug.Log("Finished running ThrowChairRoutine");
	}

	public void SetRedRoom(bool redRoomEnabled, bool playAudio = true)
	{
		StartCoroutine(SetRedRoomRoutine(redRoomEnabled, playAudio));
	}

	private IEnumerator SetRedRoomRoutine(bool redRoomEnabled, bool playAudio = true)
	{
		if (redRoomEnabled)
		{
			if (!thrownChair)
			{
				redRoomAudio.m_AudioSource.volume = 0.4f;
			}
			else
			{
				redRoomAudio.m_AudioSource.volume = 0.8f;
			}
			clock.Stop();
		}
		else
		{
			redRoomAudio.m_AudioSource.volume = 0f;
			clock.Play();
		}
		if (tapeAudioNormal.IsPlaying() && !_hasStoppedBellAudio)
		{
			tapeAudioNormal.StopLoop();
			_hasStoppedBellAudio = true;
		}
		if (useDefaultPigBellAnimation)
		{
			pigManAnim.SetTrigger("C5Wait");
		}
		MeshRenderer[] pigManMeshes;
		if (thrownChair && !pigManAttackedPlayer && redRoomEnabled)
		{
			SkinnedMeshRenderer[] pigManSkinnedMeshes = _pigManSkinnedMeshes;
			for (int i = 0; i < pigManSkinnedMeshes.Length; i++)
			{
				pigManSkinnedMeshes[i].enabled = true;
				yield return Yield.EndOfFrame;
			}
			yield return Yield.EndOfFrame;
			pigManMeshes = _pigManMeshes;
			for (int i = 0; i < pigManMeshes.Length; i++)
			{
				pigManMeshes[i].enabled = true;
				yield return Yield.EndOfFrame;
			}
		}
		else if (!firstScare)
		{
			SkinnedMeshRenderer[] pigManSkinnedMeshes = _pigManSkinnedMeshes;
			for (int i = 0; i < pigManSkinnedMeshes.Length; i++)
			{
				pigManSkinnedMeshes[i].enabled = true;
				yield return Yield.EndOfFrame;
			}
			yield return Yield.EndOfFrame;
			pigManMeshes = _pigManMeshes;
			for (int i = 0; i < pigManMeshes.Length; i++)
			{
				pigManMeshes[i].enabled = true;
				yield return Yield.EndOfFrame;
			}
		}
		else
		{
			SkinnedMeshRenderer[] pigManSkinnedMeshes = _pigManSkinnedMeshes;
			for (int i = 0; i < pigManSkinnedMeshes.Length; i++)
			{
				pigManSkinnedMeshes[i].enabled = false;
				yield return Yield.EndOfFrame;
			}
			yield return Yield.EndOfFrame;
			pigManMeshes = _pigManMeshes;
			for (int i = 0; i < pigManMeshes.Length; i++)
			{
				pigManMeshes[i].enabled = false;
				yield return Yield.EndOfFrame;
			}
		}
		pigManMeshes = paintings;
		for (int i = 0; i < pigManMeshes.Length; i++)
		{
			pigManMeshes[i].material = (redRoomEnabled ? bloodyPaintingMat : standardPaintingMat);
			yield return Yield.EndOfFrame;
		}
		if (redRoomEnabled)
		{
			redRoomCrucifixWalls.SetActive(value: true);
		}
		else
		{
			redRoomCrucifixWalls.SetActive(value: false);
		}
		redStrobe.SwitchLight(redRoomEnabled, redRoomEnabled);
		yield return Yield.EndOfFrame;
		deskLight.SwitchLight(!redRoomEnabled);
		yield return Yield.EndOfFrame;
		yield return Yield.EndOfFrame;
		wallWithNoDoor.SetActive(redRoomEnabled);
		yield return Yield.EndOfFrame;
		exitDoorObj.SetActive(!redRoomEnabled);
		yield return Yield.EndOfFrame;
		wallWithDoor.SetActive(!redRoomEnabled);
		yield return Yield.EndOfFrame;
		if (!redRoomEnabled)
		{
			if (playAudio)
			{
				tapeAudioRedRoom.PlayOne(floatingClips[6]);
			}
		}
		else if (!_playedClockChime)
		{
			floatAudio03.transform.position = floatingPoints[7].position;
			floatAudio03.Play(floatingClips[7]);
			_playedClockChime = true;
		}
	}

	public void CloseExitDoor()
	{
	}
}
public class MazeController : MonoBehaviour
{
	public enum MazeState
	{
		NONE,
		ROUTE1_P1,
		ROUTE1_P2,
		ROUTE1_P3,
		ROUTE2_P1,
		ROUTE2_CELL,
		ROUTE2_P2,
		ROUTE3_P1,
		ROUTE3_CHAPEL,
		ROUTE3_P2,
		CENTRE_WELL
	}

	[Header("Other Rooms")]
	[SerializeField]
	private Room caveRoom;

	[SerializeField]
	private Room caveMazeConnectorRoom;

	[SerializeField]
	private Room cellRoom;

	[SerializeField]
	private Room chapelRoom;

	[Header("Maze Peices")]
	[SerializeField]
	private GameObject mazeRoute1;

	[SerializeField]
	public GameObject mazeRoute2;

	[SerializeField]
	public GameObject mazeRoute2AfterChapel;

	[SerializeField]
	public Room mazeRoute1Room;

	[SerializeField]
	public Room mazeRoute2Room;

	[SerializeField]
	public Room mazeRoute3Room;

	[Space]
	[Header("Maze Route 1")]
	[SerializeField]
	public GameObject mazeRoute1EntranceBlocker;

	[SerializeField]
	public GameObject mazeRoute1Part1;

	[SerializeField]
	private GameObject[] mazeRoute1Part1FloorOOB;

	[SerializeField]
	public GameObject mazeRoute1Part2;

	[SerializeField]
	private GameObject[] mazeRoute1Part2FloorOOB;

	[SerializeField]
	public GameObject mazeRoute1Part3;

	[SerializeField]
	private GameObject[] mazeRoute1Part3FloorOOB;

	[SerializeField]
	public GameObject[] mazeRoute1ExitFloorOOB;

	[SerializeField]
	public GameObject mazeCave;

	[SerializeField]
	public GameObject mazeBridge;

	[SerializeField]
	public GameObject mazeRoute1Part1Blocker;

	[SerializeField]
	public GameObject mazeRoute1Part2Blocker;

	[SerializeField]
	public GameObject mazeRoute1Part3Blocker;

	[SerializeField]
	public GameObject mazeRoute1ExitBlocker;

	public bool completedRoute1;

	[Space]
	[Header("Maze Route 2")]
	[SerializeField]
	public GameObject mazeRoute2EntranceBlocker;

	[SerializeField]
	private GameObject mazeRoute2CellEntranceBlocker;

	[SerializeField]
	private GameObject mazeRoute3Blocker;

	[SerializeField]
	public GameObject mazeRoute2ExitBlocker;

	[SerializeField]
	private GameObject[] mazeRoute2Part1FloorOOB;

	[SerializeField]
	public GameObject[] mazeRoute2Part2FloorOOB;

	[SerializeField]
	public GameObject mazeRoute2Exit;

	[SerializeField]
	public GameObject[] mazeRoute2BlockerOn;

	[SerializeField]
	public GameObject[] mazeRoute2BlockerOff;

	[SerializeField]
	public GameObject mazeRoute2UneededRoute;

	public bool completedRoute2;

	[Space]
	[Header("Maze Route 3")]
	[SerializeField]
	public GameObject mazeRoute3EntranceBlocker1;

	[SerializeField]
	private GameObject mazeRoute3EntranceBlocker2;

	[SerializeField]
	public GameObject mazeRoute3ExitBlocker;

	[SerializeField]
	public GameObject mazeRoute3Exit;

	[SerializeField]
	public GameObject mazeRoute3ChapelBlocker;

	[SerializeField]
	private GameObject[] mazeRoute3Part1FloorOOB;

	[SerializeField]
	public GameObject[] mazeRoute3Part2FloorOOB;

	[SerializeField]
	public GameObject[] mazeRoute3BlockerOn;

	[SerializeField]
	public GameObject[] mazeRoute3BlockerOff;

	public bool completedRoute3;

	[Space]
	[Header("Rooms")]
	[SerializeField]
	public GameObject mazeWellRoom;

	[SerializeField]
	public GameObject mazeChapelRoom;

	[SerializeField]
	private GameObject mazeCellRoom;

	[SerializeField]
	public Room centralMazeRoom;

	[Space]
	[Header("Other")]
	[SerializeField]
	private GameObject mazeWellLid;

	[SerializeField]
	private GameObject unroundRope;

	[SerializeField]
	private GameObject unroundRopeBody;

	[SerializeField]
	private GameObject rope;

	[SerializeField]
	private GameObject wellNavBlock;

	[SerializeField]
	private GameObject route3Skull;

	[SerializeField]
	public MazeState currentMazeState;

	[SerializeField]
	public Collider[] centralMazeRoomOOB;

	private void Start()
	{
		CloseWell();
		mazeCave.SetActive(value: false);
		mazeRoute3EntranceBlocker1.SetActive(value: false);
		mazeRoute2Exit.SetActive(value: false);
		mazeBridge.SetActive(value: false);
		for (int i = 0; i < centralMazeRoomOOB.Length; i++)
		{
			centralMazeRoomOOB[i].enabled = false;
		}
	}

	public void SwitchRoute(MazeState route)
	{
		UnityEngine.Debug.Log("Switching to Route: " + route);
		switch (route)
		{
		case MazeState.ROUTE1_P1:
			currentMazeState = MazeState.ROUTE1_P1;
			GameController.instance.boundDetection.SwitchOffOOB();
			GameController.instance.currentRoom = mazeRoute1Room;
			mazeRoute1EntranceBlocker.SetActive(value: false);
			mazeRoute2EntranceBlocker.SetActive(value: true);
			mazeRoute3EntranceBlocker1.SetActive(value: true);
			caveRoom.UpdateColliders(enabled: true);
			caveRoom.associatedParentGameObject.SetActive(value: false);
			caveRoom.playerInRoom = false;
			caveRoom.gameObject.SetActive(value: false);
			caveMazeConnectorRoom.UpdateColliders(enabled: false);
			caveMazeConnectorRoom.associatedParentGameObject.SetActive(value: true);
			caveMazeConnectorRoom.playerInRoom = false;
			centralMazeRoom.associatedParentGameObject.SetActive(value: true);
			mazeRoute1Room.UpdateColliders(enabled: false);
			mazeRoute1Room.associatedParentGameObject.SetActive(value: true);
			mazeRoute1Room.playerInRoom = true;
			mazeRoute1Room.floorOOB = mazeRoute1Part1FloorOOB;
			mazeRoute1EntranceBlocker.SetActive(value: false);
			mazeRoute1Part1Blocker.SetActive(value: false);
			mazeRoute1Part2Blocker.SetActive(value: false);
			mazeRoute1Part1.SetActive(value: true);
			mazeRoute1Part2.SetActive(value: true);
			mazeRoute1Part3.SetActive(value: false);
			mazeCave.SetActive(value: false);
			mazeRoute2ExitBlocker.SetActive(value: true);
			mazeRoute3ExitBlocker.SetActive(value: true);
			GameController.instance.player.mainCamera.farClipPlane = 17f;
			GameController.instance.boundDetection.SwitchOnOOB();
			break;
		case MazeState.ROUTE1_P2:
			currentMazeState = MazeState.ROUTE1_P2;
			mazeRoute1EntranceBlocker.SetActive(value: true);
			mazeRoute1Part1Blocker.SetActive(value: true);
			mazeRoute1Room.floorOOB = mazeRoute1Part2FloorOOB;
			mazeRoute1Part3.SetActive(value: true);
			break;
		case MazeState.ROUTE1_P3:
			currentMazeState = MazeState.ROUTE1_P3;
			mazeRoute1Part1.SetActive(value: false);
			mazeRoute1Part2Blocker.SetActive(value: true);
			mazeRoute1Part3Blocker.SetActive(value: false);
			mazeRoute1Room.floorOOB = mazeRoute1Part3FloorOOB;
			mazeRoute1ExitBlocker.SetActive(value: false);
			mazeCave.SetActive(value: false);
			break;
		case MazeState.ROUTE2_P1:
		{
			currentMazeState = MazeState.ROUTE1_P2;
			GameController.instance.boundDetection.SwitchOffOOB();
			GameController.instance.currentRoom = mazeRoute2Room;
			mazeRoute1Room.UpdateColliders(enabled: true);
			mazeRoute1Room.associatedParentGameObject.SetActive(value: false);
			mazeRoute1Room.playerInRoom = false;
			mazeRoute2EntranceBlocker.SetActive(value: false);
			mazeRoute2CellEntranceBlocker.SetActive(value: false);
			mazeRoute2Room.UpdateColliders(enabled: false);
			mazeRoute2Room.associatedParentGameObject.SetActive(value: true);
			mazeRoute2Room.playerInRoom = true;
			mazeRoute2UneededRoute.SetActive(value: false);
			mazeRoute2Room.floorOOB = mazeRoute2Part1FloorOOB;
			for (int l = 0; l < mazeRoute2BlockerOn.Length; l++)
			{
				mazeRoute2BlockerOn[l].SetActive(value: true);
			}
			for (int m = 0; m < mazeRoute2BlockerOff.Length; m++)
			{
				mazeRoute2BlockerOff[m].SetActive(value: false);
			}
			GameController.instance.boundDetection.SwitchOnOOB();
			break;
		}
		case MazeState.ROUTE2_CELL:
			currentMazeState = MazeState.ROUTE2_CELL;
			GameController.instance.boundDetection.SwitchOffOOB();
			GameController.instance.currentRoom = cellRoom;
			mazeRoute2EntranceBlocker.SetActive(value: true);
			mazeRoute2Room.UpdateColliders(enabled: true);
			mazeRoute2Room.associatedParentGameObject.SetActive(value: false);
			mazeRoute2Room.playerInRoom = false;
			cellRoom.UpdateColliders(enabled: false);
			cellRoom.associatedParentGameObject.SetActive(value: true);
			cellRoom.playerInRoom = true;
			mazeRoute2Room.floorOOB = cellRoom.floorOOB;
			GameController.instance.boundDetection.SwitchOnOOB();
			break;
		case MazeState.ROUTE2_P2:
			currentMazeState = MazeState.ROUTE2_P2;
			GameController.instance.boundDetection.SwitchOffOOB();
			GameController.instance.currentRoom = mazeRoute2Room;
			cellRoom.UpdateColliders(enabled: true);
			cellRoom.associatedParentGameObject.SetActive(value: false);
			cellRoom.playerInRoom = false;
			mazeRoute2Room.UpdateColliders(enabled: false);
			mazeRoute2Room.associatedParentGameObject.SetActive(value: false);
			mazeRoute2Room.playerInRoom = true;
			mazeRoute2Exit.SetActive(value: true);
			mazeRoute3Blocker.SetActive(value: true);
			mazeRoute2ExitBlocker.SetActive(value: false);
			mazeRoute2Room.floorOOB = mazeRoute2Part2FloorOOB;
			GameController.instance.boundDetection.SwitchOnOOB();
			break;
		case MazeState.ROUTE3_P1:
		{
			currentMazeState = MazeState.ROUTE3_P1;
			GameController.instance.boundDetection.SwitchOffOOB();
			GameController.instance.currentRoom = mazeRoute3Room;
			mazeRoute2Exit.SetActive(value: false);
			mazeRoute3Room.UpdateColliders(enabled: false);
			mazeRoute3Room.associatedParentGameObject.SetActive(value: true);
			mazeRoute3Room.playerInRoom = true;
			mazeRoute3EntranceBlocker1.SetActive(value: false);
			mazeRoute3EntranceBlocker2.SetActive(value: false);
			mazeRoute3Blocker.SetActive(value: false);
			mazeRoute2UneededRoute.SetActive(value: true);
			for (int j = 0; j < mazeRoute3BlockerOn.Length; j++)
			{
				mazeRoute3BlockerOn[j].SetActive(value: true);
			}
			for (int k = 0; k < mazeRoute3BlockerOff.Length; k++)
			{
				mazeRoute3BlockerOff[k].SetActive(value: false);
			}
			mazeRoute3Room.floorOOB = mazeRoute3Part1FloorOOB;
			route3Skull.SetActive(value: true);
			GameController.instance.boundDetection.SwitchOnOOB();
			break;
		}
		case MazeState.ROUTE3_CHAPEL:
			currentMazeState = MazeState.ROUTE3_CHAPEL;
			GameController.instance.boundDetection.SwitchOffOOB();
			GameController.instance.currentRoom = chapelRoom;
			mazeRoute3Room.UpdateColliders(enabled: true);
			mazeRoute3Room.associatedParentGameObject.SetActive(value: false);
			mazeRoute3Room.playerInRoom = false;
			chapelRoom.UpdateColliders(enabled: false);
			chapelRoom.associatedParentGameObject.SetActive(value: true);
			chapelRoom.playerInRoom = true;
			GameController.instance.boundDetection.SwitchOnOOB();
			break;
		case MazeState.ROUTE3_P2:
			currentMazeState = MazeState.ROUTE3_P2;
			GameController.instance.boundDetection.SwitchOffOOB();
			GameController.instance.currentRoom = mazeRoute3Room;
			chapelRoom.UpdateColliders(enabled: true);
			chapelRoom.associatedParentGameObject.SetActive(value: false);
			chapelRoom.playerInRoom = false;
			mazeRoute3Room.UpdateColliders(enabled: false);
			mazeRoute3Room.associatedParentGameObject.SetActive(value: false);
			mazeRoute3Room.playerInRoom = true;
			mazeRoute3Exit.SetActive(value: true);
			mazeRoute3Blocker.SetActive(value: false);
			mazeRoute3ExitBlocker.SetActive(value: false);
			mazeRoute3EntranceBlocker1.SetActive(value: true);
			mazeRoute3Room.floorOOB = mazeRoute3Part2FloorOOB;
			GameController.instance.boundDetection.SwitchOnOOB();
			break;
		case MazeState.CENTRE_WELL:
		{
			currentMazeState = MazeState.CENTRE_WELL;
			GameController.instance.boundDetection.SwitchOffOOB();
			GameController.instance.currentRoom = centralMazeRoom;
			mazeRoute3Exit.SetActive(value: false);
			mazeRoute3Room.UpdateColliders(enabled: true);
			mazeRoute3Room.associatedParentGameObject.SetActive(value: false);
			mazeRoute3Room.playerInRoom = false;
			for (int i = 0; i < centralMazeRoomOOB.Length; i++)
			{
				centralMazeRoomOOB[i].enabled = true;
			}
			centralMazeRoom.UpdateColliders(enabled: false);
			centralMazeRoom.associatedParentGameObject.SetActive(value: true);
			centralMazeRoom.playerInRoom = true;
			GameController.instance.boundDetection.SwitchOnOOB();
			break;
		}
		}
	}

	public void OpenWell()
	{
		StartCoroutine(OpenWellRoutine());
	}

	private IEnumerator OpenWellRoutine()
	{
		mazeWellLid.SetActive(value: false);
		rope.SetActive(value: false);
		yield return Yield.EndOfFixedUpdate;
		unroundRope.SetActive(value: true);
		wellNavBlock.SetActive(value: true);
		unroundRopeBody.SetActive(value: true);
	}

	public void CloseWell()
	{
		unroundRopeBody.SetActive(value: false);
		mazeWellLid.SetActive(value: true);
		rope.SetActive(value: true);
		unroundRope.SetActive(value: false);
		wellNavBlock.SetActive(value: false);
	}
}
public class MazeEntranceDoor : MonoBehaviour
{
	public float movementScalar;

	public float openAt;

	public float maxAt;

	public Transform doorOpenFloatingPos;

	public NVRInteractableItem pulley;

	public AudioScript doorAudioScript;

	public AudioScript pulleyAudioScript;

	public AudioClip pulleyAudioClip;

	public AudioClip doorAudioClip;

	public AudioClip doorOpenClip;

	[SerializeField]
	private AudioClip slamShutClip;

	[HideInInspector]
	public bool open;

	[SerializeField]
	private ParticleSystem[] particlesOpen;

	[SerializeField]
	private ParticleSystem particlesClose;

	[SerializeField]
	public GameObject navmeshObstacleInConnector;

	[SerializeField]
	public GameObject navmeshObstacleInCave;

	private bool playedParticles;

	private Transform _attachedHand;

	private Vector3 _startVec;

	private float _startYPos;

	private bool _reachedMax;

	private int _handCount;

	public bool ShouldEndInteraction => _handCount < 2;

	private void Start()
	{
		_startYPos = base.transform.position.y;
		doorAudioScript.PlayLoop(doorAudioClip, 0f);
		pulleyAudioScript.PlayLoop(pulleyAudioClip, 0f);
	}

	private void Update()
	{
		if (_reachedMax)
		{
			return;
		}
		if ((bool)_attachedHand)
		{
			Vector3 vector = _attachedHand.transform.position - _startVec;
			if (vector.y < 0f)
			{
				Vector3 position = base.transform.position;
				position.y -= vector.y * movementScalar;
				base.transform.position = position;
				float num = Mathf.Clamp(Mathf.Abs(vector.y), 0f, 1f);
				doorAudioScript.StopAllCoroutines();
				pulleyAudioScript.StopAllCoroutines();
				doorAudioScript.m_AudioSource.volume = num * 2f;
				pulleyAudioScript.m_AudioSource.volume = num;
				if (!playedParticles)
				{
					StartCoroutine(PlayOpenParticles());
					playedParticles = true;
				}
			}
			if (base.transform.localPosition.y > openAt)
			{
				navmeshObstacleInConnector.SetActive(value: false);
				UnityEngine.Debug.Log("Can go through");
			}
			if (base.transform.localPosition.y > maxAt)
			{
				_reachedMax = true;
				StartCoroutine(FadeOutAndStopAudio());
				AudioScript obj = AudioScriptContainer.Instance.audioScripts[2];
				obj.transform.position = doorOpenFloatingPos.position;
				obj.Play(doorOpenClip);
				navmeshObstacleInConnector.SetActive(value: false);
				StartCoroutine(PlayOpenParticles());
			}
		}
		else
		{
			if ((bool)doorAudioScript.m_AudioSource && doorAudioScript.m_AudioSource.volume > 0f)
			{
				doorAudioScript.FadeVolumeOut(0.5f);
			}
			if ((bool)pulleyAudioScript.m_AudioSource && pulleyAudioScript.m_AudioSource.volume > 0f)
			{
				pulleyAudioScript.FadeVolumeOut(0.5f);
			}
		}
	}

	private IEnumerator PlayOpenParticles()
	{
		particlesOpen[0].Play();
		particlesOpen[1].Play();
		particlesOpen[2].Play();
		yield return Yield.EndOfFrame;
	}

	private IEnumerator FadeOutAndStopAudio()
	{
		doorAudioScript.FadeVolumeOut(0.5f);
		pulleyAudioScript.FadeVolumeOut(0.5f);
		yield return Yield.WaitSeconds(0.5f);
		doorAudioScript.StopLoop();
		pulleyAudioScript.StopLoop();
	}

	public IEnumerator ShutRoutine(Room caveArea, Room mazeCaveConnector, Room centralMaze, MazeController mazeController)
	{
		NVRPlayer player = GameController.instance.player;
		LeanTween.moveLocalY(base.gameObject, 1.579f, 0.7f).setEase(LeanTweenType.easeInExpo);
		AudioScript obj = AudioScriptContainer.Instance.audioScripts[1];
		obj.transform.position = doorOpenFloatingPos.position;
		obj.Play(slamShutClip);
		player.screenFX.cameraShakeAmount = 0.005f;
		player.screenFX.ShakeCamera();
		player.screenFX.Fade(UnityEngine.Color.black, 0.2f);
		yield return Yield.WaitSeconds(0.4f);
		player.screenFX.Fade(UnityEngine.Color.clear, 0.2f);
		yield return Yield.WaitSeconds(0.4f);
		player.screenFX.Fade(UnityEngine.Color.black, 0.4f);
		yield return Yield.WaitSeconds(0.6f);
		GameController.instance.currentRoom = mazeCaveConnector;
		player.mainCamera.farClipPlane = 20f;
		caveArea.UpdateColliders(enabled: true);
		caveArea.associatedParentGameObject.SetActive(value: false);
		caveArea.playerInRoom = false;
		yield return Yield.EndOfFrame;
		mazeCaveConnector.UpdateColliders(enabled: false);
		mazeCaveConnector.associatedParentGameObject.SetActive(value: true);
		mazeCaveConnector.playerInRoom = true;
		yield return Yield.EndOfFrame;
		centralMaze.associatedParentGameObject.SetActive(value: true);
		navmeshObstacleInCave.SetActive(value: true);
		mazeController.SwitchRoute(MazeController.MazeState.ROUTE1_P1);
		yield return Yield.EndOfFrame;
		mazeController.CloseWell();
		yield return Yield.WaitSeconds(2f);
		player.screenFX.Fade(UnityEngine.Color.clear, 1.5f);
		particlesClose.Play();
		float startingCamShake = player.screenFX.cameraShakeAmount;
		for (float t = 0f; t < 3f; t += Time.deltaTime)
		{
			player.screenFX.cameraShakeAmount = startingCamShake - startingCamShake / 6f * t;
			yield return Yield.EndOfFrame;
		}
		player.movement.EnableEverything();
		GameController.instance.boundDetection.SwitchOnOOB();
	}

	public void BeginInteraction(NVRInteractable intercative)
	{
		_handCount++;
		open = true;
		_attachedHand = intercative.AttachedHand.transform;
		_startVec = _attachedHand.position;
	}

	public void EndInteraction()
	{
		_handCount--;
		_attachedHand = null;
		_startVec = Vector3.zero;
	}
}
public class MenuScript : MonoBehaviour
{
	public NVRPlayer player;

	private bool canOpen = true;

	[Tooltip("The object containing the real items")]
	public GameObject items;

	public GameObject replacementItems;

	[Tooltip("The list containing each real object")]
	public GameObject[] listOfRealItems = new GameObject[3];

	public GameObject[] listOfReplacementItems = new GameObject[2];

	private GameObject[] activeItems = new GameObject[3];

	public int activeItem;

	public bool menuActive;

	public bool itemActive;

	private bool rotating;

	private float rotateTime;

	[Tooltip("The time it takes the ghost objects rotate")]
	public float timeToCompleteRotation = 1f;

	private bool animating;

	public ExorcismKit exKitScript;

	public PhoneButtons phoneScript;

	public BookScript bookScript;

	private PoliceBadge badgeScript;

	private PoliceNotepad notepadScript;

	private OilLighter oilLighter;

	private bool straightToBook;

	private bool straightToExKit;

	[SerializeField]
	private Light menuLight;

	[SerializeField]
	private GameObject inventoryUI;

	[SerializeField]
	private GameObject menuUIOculus;

	[SerializeField]
	private GameObject menuUIOculusQuest;

	[SerializeField]
	private GameObject menuUISteam;

	[SerializeField]
	private GameObject menuUIPico;

	private float holdTime = 1f;

	private float elaspedTimeExKit;

	private bool lockInput;

	private bool isInitilised;

	public bool playerLightsDisable;

	private Locomotion playerLocomotion;

	private LightFlicker playerLightFlicker;

	private bool enablePlayerLightOnClose;

	private bool enableOilLightOnClose;

	public bool IsActive
	{
		get
		{
			if (!menuActive)
			{
				return itemActive;
			}
			return true;
		}
	}

	public void InitialiseMenu()
	{
		player = GameController.instance.player;
		menuLight.enabled = false;
		StartCoroutine(Init());
		UnityEngine.Debug.Log("Init Menu");
	}

	private IEnumerator Init()
	{
		bookScript = listOfRealItems[0].GetComponent<BookScript>();
		exKitScript = listOfRealItems[1].GetComponent<ExorcismKit>();
		phoneScript = listOfRealItems[2].GetComponent<PhoneButtons>();
		notepadScript = listOfReplacementItems[0].GetComponent<PoliceNotepad>();
		badgeScript = listOfReplacementItems[1].GetComponent<PoliceBadge>();
		oilLighter = exKitScript.candle.GetComponent<OilLighter>();
		LeanTween.alpha(inventoryUI, 0f, 0f);
		if (!inventoryUI.activeInHierarchy)
		{
			inventoryUI.SetActive(value: true);
		}
		menuUIOculus.SetActive(value: false);
		menuUIOculusQuest.SetActive(value: false);
		menuUISteam.SetActive(value: false);
		menuUIPico.SetActive(value: false);
		activeItem = 2;
		activeItems[0] = listOfRealItems[0];
		activeItems[1] = listOfRealItems[1];
		activeItems[2] = listOfRealItems[2];
		listOfReplacementItems[0].SetActive(value: false);
		listOfReplacementItems[1].SetActive(value: false);
		menuActive = false;
		rotating = false;
		rotateTime = 0f;
		items.SetActive(value: true);
		replacementItems.SetActive(value: true);
		base.transform.localPosition = new Vector3(-0.0372f, -0.0311f, -0.0353f);
		base.transform.localEulerAngles = new Vector3(-9.925f, 0.089f, 16.702f);
		menuUIOculusQuest.transform.localPosition = new Vector3(-0.021f, 0.094f, 0.177f);
		menuUIOculusQuest.transform.localEulerAngles = new Vector3(80.289f, -0.295f, -1.62f);
		menuUIPico.transform.localPosition = new Vector3(-0.021f, 0.094f, 0.177f);
		menuUIPico.transform.localEulerAngles = new Vector3(80.289f, -0.295f, -1.62f);
		while (player.movement == null)
		{
			yield return Yield.WaitSeconds(0.1f);
		}
		playerLocomotion = player.movement;
		playerLightFlicker = player.playerLight.GetComponent<LightFlicker>();
		isInitilised = true;
	}

	public void SetToLeft()
	{
		base.transform.localPosition = new Vector3(-0.0372f, -0.0311f, -0.0353f);
		base.transform.localEulerAngles = new Vector3(-9.925f, 0.089f, 16.702f);
		menuUIOculusQuest.transform.localPosition = new Vector3(-0.021f, 0.094f, 0.177f);
		menuUIOculusQuest.transform.localEulerAngles = new Vector3(80.289f, -0.295f, -1.62f);
		menuUIPico.transform.localPosition = new Vector3(-0.021f, 0.094f, 0.177f);
		menuUIPico.transform.localEulerAngles = new Vector3(80.289f, -0.295f, -1.62f);
	}

	public void SetToRight()
	{
		base.transform.localPosition = new Vector3(0.02404682f, -0.01478132f, -0.03578034f);
		base.transform.localEulerAngles = new Vector3(-2.048f, -2.94f, 20.124f);
		menuUIOculusQuest.transform.localPosition = new Vector3(0.02104617f, 0.0644508f, 0.1861224f);
		menuUIOculusQuest.transform.localEulerAngles = new Vector3(88.024f, 7.186f, 9.353001f);
		menuUIPico.transform.localPosition = new Vector3(-0.021f, 0.094f, 0.177f);
		menuUIPico.transform.localEulerAngles = new Vector3(80.289f, -0.295f, -1.62f);
	}

	private void Update()
	{
		if (!isInitilised || playerLocomotion.isTeleporting || playerLocomotion.teleporterActive || !canOpen)
		{
			return;
		}
		if (ControlsManager.instance.menuButtonHold && !lockInput)
		{
			elaspedTimeExKit += Time.deltaTime;
		}
		else if (ControlsManager.instance.secondaryMenuButtonHold && !lockInput)
		{
			elaspedTimeExKit += Time.deltaTime;
		}
		if (menuActive)
		{
			if (rotating)
			{
				rotateTime += Time.deltaTime;
				if (rotateTime > timeToCompleteRotation)
				{
					rotating = false;
				}
			}
			else
			{
				if (animating || CheckAnimations())
				{
					return;
				}
				if (ControlsManager.instance.menuButtonUp)
				{
					fadeoutUI();
					menuActive = false;
					itemActive = false;
					items.SetActive(value: false);
					replacementItems.SetActive(value: false);
					HandRendersActive(showHands: true);
					menuLight.enabled = false;
					elaspedTimeExKit = 0f;
				}
				else if (ControlsManager.instance.secondaryMenuButtonUp)
				{
					fadeoutUI();
					menuActive = false;
					itemActive = false;
					items.SetActive(value: false);
					replacementItems.SetActive(value: false);
					HandRendersActive(showHands: true);
					menuLight.enabled = false;
					elaspedTimeExKit = 0f;
				}
				else if (ControlsManager.instance.rotateMenuLeftDown)
				{
					rotating = true;
					rotateTime = 0f;
					LeanTween.rotateAroundLocal(items, Vector3.forward, -120f, timeToCompleteRotation);
					LeanTween.rotateAroundLocal(replacementItems, Vector3.forward, -120f, timeToCompleteRotation);
					if (activeItem - 1 < 0)
					{
						activeItem = activeItems.Length - 1;
					}
					else
					{
						activeItem--;
					}
				}
				else if (ControlsManager.instance.rotateMenuRightDown)
				{
					rotating = true;
					rotateTime = 0f;
					LeanTween.rotateAroundLocal(items, Vector3.forward, 120f, timeToCompleteRotation);
					LeanTween.rotateAroundLocal(replacementItems, Vector3.forward, 120f, timeToCompleteRotation);
					if (activeItem + 1 >= activeItems.Length)
					{
						activeItem = 0;
					}
					else
					{
						activeItem++;
					}
				}
				else if (ControlsManager.instance.secondaryTriggerButtonDown)
				{
					itemActive = true;
					menuActive = false;
					StartCoroutine(AnimateItem(on: true));
				}
			}
		}
		else if (elaspedTimeExKit >= holdTime && !itemActive)
		{
			if (!player.LeftHand.IsPrimary && player.LeftHand.CurrentlyInteracting != null)
			{
				if (player.LeftHand.CurrentlyInteracting != null && player.LeftHand.CurrentlyInteracting.gameObject == exKitScript.cross && exKitScript.cross.GetComponent<ExorcismItem>().lockedToHand)
				{
					return;
				}
			}
			else if (player.LeftHand.IsPrimary && player.RightHand.CurrentlyInteracting != null && player.RightHand.CurrentlyInteracting != null && player.RightHand.CurrentlyInteracting.gameObject == exKitScript.cross && exKitScript.cross.GetComponent<ExorcismItem>().lockedToHand)
			{
				return;
			}
			straightToExKit = true;
			lockInput = true;
			HandRendersActive(showHands: false);
			OpenMenu();
		}
		else if (ControlsManager.instance.menuButtonUp)
		{
			if (lockInput)
			{
				lockInput = false;
			}
			else if (itemActive)
			{
				if ((player.LeftHand.IsPrimary || !(player.LeftHand.CurrentlyInteracting != null)) && (!player.LeftHand.IsPrimary || !(player.RightHand.CurrentlyInteracting != null)))
				{
					fadeinUI();
					StartCoroutine(AnimateItem(on: false));
					itemActive = false;
					HandRendersActive(showHands: false);
					menuActive = true;
				}
			}
			else
			{
				OpenMenu();
			}
		}
		else
		{
			if (!ControlsManager.instance.secondaryMenuButtonUp)
			{
				return;
			}
			if (lockInput)
			{
				lockInput = false;
			}
			else if (itemActive)
			{
				if ((player.LeftHand.IsPrimary || !(player.LeftHand.CurrentlyInteracting != null)) && (!player.LeftHand.IsPrimary || !(player.RightHand.CurrentlyInteracting != null)))
				{
					fadeinUI();
					StartCoroutine(AnimateItem(on: false));
					itemActive = false;
					HandRendersActive(showHands: false);
					menuActive = true;
				}
			}
			else
			{
				OpenMenu();
			}
		}
	}

	public void OpenMenu()
	{
		if (!player.LeftHand.IsPrimary && player.LeftHand.CurrentlyInteracting != null)
		{
			if (player.LeftHand.CurrentlyInteracting != null && player.LeftHand.CurrentlyInteracting.gameObject == exKitScript.cross && exKitScript.cross.GetComponent<ExorcismItem>().lockedToHand)
			{
				return;
			}
		}
		else if (player.LeftHand.IsPrimary && player.RightHand.CurrentlyInteracting != null && player.RightHand.CurrentlyInteracting != null && player.RightHand.CurrentlyInteracting.gameObject == exKitScript.cross && exKitScript.cross.GetComponent<ExorcismItem>().lockedToHand)
		{
			return;
		}
		switch (GameController.instance.GetCurrentLevel())
		{
		case SCENES.PRECINCT:
			notepadScript.showPrecinctMaterial();
			break;
		case SCENES.CHAPEL:
			notepadScript.showChapert1Material();
			break;
		default:
			notepadScript.showBlankMaterial();
			break;
		}
		StartCoroutine(FixHand());
		fadeinUI();
		HandRendersActive(showHands: false);
		elaspedTimeExKit = 0f;
		if (player.playerLight.enabled && playerLightFlicker.light.intensity > 0f)
		{
			menuLight.enabled = false;
		}
		else if (oilLighter.isOn)
		{
			menuLight.enabled = false;
		}
		else
		{
			menuLight.enabled = true;
		}
		items.SetActive(value: true);
		replacementItems.SetActive(value: true);
		if (straightToBook)
		{
			itemActive = true;
			menuActive = false;
			if (activeItem == 1)
			{
				LeanTween.rotateAroundLocal(items, Vector3.forward, -120f, 0.01f);
				LeanTween.rotateAroundLocal(replacementItems, Vector3.forward, -120f, 0.01f);
			}
			else if (activeItem == 2)
			{
				LeanTween.rotateAroundLocal(items, Vector3.forward, 120f, 0.01f);
				LeanTween.rotateAroundLocal(replacementItems, Vector3.forward, 120f, 0.01f);
			}
			activeItem = 0;
			StartCoroutine(AnimateItem(on: true));
			straightToBook = false;
		}
		else if (straightToExKit)
		{
			itemActive = true;
			menuActive = false;
			if (activeItem == 2)
			{
				LeanTween.rotateAroundLocal(items, Vector3.forward, -120f, 0.01f);
				LeanTween.rotateAroundLocal(replacementItems, Vector3.forward, -120f, 0.01f);
			}
			else if (activeItem == 0)
			{
				LeanTween.rotateAroundLocal(items, Vector3.forward, 120f, 0.01f);
				LeanTween.rotateAroundLocal(replacementItems, Vector3.forward, 120f, 0.01f);
			}
			activeItem = 1;
			StartCoroutine(AnimateItem(on: true));
			straightToExKit = false;
		}
		else
		{
			menuActive = true;
		}
	}

	private IEnumerator FixHand()
	{
		if (player.RightHand.IsPrimary)
		{
			if (player.LeftHand.IsInteracting)
			{
				player.LeftHand.ForceDropItem();
			}
			yield return Yield.EndOfFrame;
			GameController.instance.player.LeftHand.CurrentlyHoveringOver.Clear();
			yield return Yield.EndOfFrame;
			GameController.instance.player.LeftHand.SetAnimation("IdleBool");
		}
		else if (player.LeftHand.IsPrimary)
		{
			if (player.RightHand.IsInteracting)
			{
				player.RightHand.ForceDropItem();
			}
			yield return Yield.EndOfFrame;
			GameController.instance.player.RightHand.CurrentlyHoveringOver.Clear();
			yield return Yield.EndOfFrame;
			GameController.instance.player.RightHand.SetAnimation("IdleBool");
		}
	}

	private bool CheckAnimations()
	{
		if (!bookScript.animating)
		{
			return exKitScript.animating;
		}
		return true;
	}

	private IEnumerator AnimateItem(bool on, bool instantly = false)
	{
		animating = true;
		if (activeItem == 0)
		{
			if (activeItems[0] == listOfRealItems[0])
			{
				if (on)
				{
					fadeoutUI();
					bookScript.isActiveItem = true;
					bookScript.OpenBook();
				}
				else
				{
					fadeinUI();
					bookScript.CloseBook(instantly);
				}
			}
			else if (on)
			{
				fadeoutUI();
				notepadScript.OpenPad();
			}
			else
			{
				fadeinUI();
				notepadScript.ClosePad(instantly);
			}
			activeItems[1].SetActive(!on);
			activeItems[2].SetActive(!on);
		}
		else if (activeItem == 1)
		{
			if (activeItems[1] == listOfRealItems[1])
			{
				if (on)
				{
					fadeoutUI();
					exKitScript.OpenKit();
				}
				else
				{
					fadeinUI();
					exKitScript.CloseKit(instantly, ignoreAnimation: true);
				}
			}
			else if (on)
			{
				fadeoutUI();
				badgeScript.OpenBadge();
			}
			else
			{
				fadeinUI();
				badgeScript.CloseBadge(instantly);
			}
			activeItems[0].SetActive(!on);
			activeItems[2].SetActive(!on);
		}
		else if (activeItem == 2)
		{
			if (on)
			{
				fadeoutUI();
				phoneScript.TurnOn();
			}
			else
			{
				fadeinUI();
				phoneScript.TurnOff();
			}
			activeItems[0].SetActive(!on);
			activeItems[1].SetActive(!on);
		}
		while (CheckAnimations())
		{
			yield return null;
		}
		animating = false;
	}

	public void BookInMenu(bool active)
	{
		if (active)
		{
			activeItems[0].SetActive(value: false);
			activeItems[0] = listOfRealItems[0];
			activeItems[0].SetActive(value: true);
		}
		else
		{
			activeItems[0].SetActive(value: false);
			activeItems[0] = listOfReplacementItems[0];
			activeItems[0].SetActive(value: true);
		}
	}

	public void KitInMenu(bool active)
	{
		if (active)
		{
			activeItems[1].SetActive(value: false);
			activeItems[1] = listOfRealItems[1];
			activeItems[1].SetActive(value: true);
		}
		else
		{
			activeItems[1].SetActive(value: false);
			activeItems[1] = listOfReplacementItems[1];
			activeItems[1].SetActive(value: true);
		}
	}

	public void OpenStraightToBook(NotebookPages page = NotebookPages.Q03)
	{
		bookScript.SetPage(page);
		if (!straightToBook && !listOfRealItems[0].activeSelf)
		{
			BookInMenu(active: true);
		}
		straightToBook = true;
	}

	public void OpenStraightToBookForArtefact(ArtefactType artefactType, NotebookPages page = NotebookPages.Q03)
	{
		bookScript.SetPage(page, artefactType);
		if (!straightToBook && !listOfRealItems[0].activeSelf)
		{
			BookInMenu(active: true);
		}
		straightToBook = true;
	}

	public void OpenStraightToExKit()
	{
		if (!straightToExKit && !listOfRealItems[1].activeSelf)
		{
			KitInMenu(active: true);
		}
		straightToExKit = true;
	}

	public void CancelStraightToKit()
	{
		straightToExKit = false;
	}

	public void CancelStraightToBook()
	{
		straightToBook = false;
	}

	private void HandRendersActive(bool showHands)
	{
		if (!isInitilised)
		{
			return;
		}
		NVRHand[] hands = player.Hands;
		foreach (NVRHand nVRHand in hands)
		{
			if (!nVRHand.IsPrimary)
			{
				Renderer[] componentsInChildren = nVRHand.RenderModel.GetComponentsInChildren<Renderer>();
				for (int j = 0; j < componentsInChildren.Length; j++)
				{
					componentsInChildren[j].enabled = showHands;
				}
			}
		}
		player.watch.gameObject.SetActive(showHands);
	}

	private void fadeoutUI()
	{
		LeanTween.alpha(inventoryUI, 0f, 1f);
		if (menuUIOculus.activeInHierarchy)
		{
			menuUIOculus.SetActive(value: false);
		}
		if (menuUIOculusQuest.activeInHierarchy)
		{
			menuUIOculusQuest.SetActive(value: false);
		}
		if (menuUISteam.activeInHierarchy)
		{
			menuUISteam.SetActive(value: false);
		}
		if (menuUIPico.activeInHierarchy)
		{
			menuUIPico.SetActive(value: false);
		}
	}

	private void fadeinUI()
	{
		LeanTween.alpha(inventoryUI, 1f, 1f);
		if (GameController.instance.GetCurrentLevel() != SCENES.ONBOARDING)
		{
			return;
		}
		if (player.CurrentIntegrationType == NVRSDKIntegrations.SteamVR)
		{
			if (GameController.instance.isUsingAnOculus())
			{
				menuUIOculus.SetActive(value: true);
			}
			else
			{
				menuUISteam.SetActive(value: true);
			}
		}
		else if (player.CurrentIntegrationType == NVRSDKIntegrations.Oculus)
		{
			menuUIOculus.SetActive(value: true);
		}
		else if (player.CurrentIntegrationType == NVRSDKIntegrations.OculusQuest)
		{
			menuUIOculusQuest.SetActive(value: true);
		}
		else if (player.CurrentIntegrationType == NVRSDKIntegrations.Pico)
		{
			menuUIPico.SetActive(value: true);
		}
	}

	public void LockMenu(bool locked)
	{
		canOpen = !locked;
		if (locked)
		{
			CloseMenu();
		}
	}

	public void SwapOutHolyWater()
	{
		exKitScript.SwapOutHolyWater();
	}

	public void SwapOutLighterFuel()
	{
		exKitScript.SwapOutLighterFuel();
	}

	public void UpgradeCross()
	{
		exKitScript.UpgradeCross();
	}

	public void UpgradeSaltSprayer()
	{
		exKitScript.UpgradeSaltSprayer();
	}

	public void CloseMenu(bool hideHandsAfter = false)
	{
		try
		{
			if (base.gameObject.activeInHierarchy)
			{
				StartCoroutine(CloseMenuInstantly(hideHandsAfter));
			}
		}
		catch
		{
			UnityEngine.Debug.LogWarning("Failed to close menu after locking.");
		}
	}

	private IEnumerator CloseMenuInstantly(bool hideHandsAfter)
	{
		if (itemActive)
		{
			StartCoroutine(AnimateItem(on: false, instantly: true));
		}
		while (animating)
		{
			yield return null;
		}
		fadeoutUI();
		menuActive = false;
		itemActive = false;
		items.SetActive(value: false);
		menuLight.enabled = false;
		replacementItems.SetActive(value: false);
		if (!hideHandsAfter)
		{
			HandRendersActive(showHands: true);
		}
		elaspedTimeExKit = 0f;
	}
}
public class MirrorPortal : MonoBehaviour
{
	[HideInInspector]
	public bool playerPassedThroughPortal;

	[HideInInspector]
	public bool playerTeleportingThroughPortal;

	[HideInInspector]
	public bool portalEnabled;

	public float maximumDeformRange = 0.5f;

	private float minimumDeformRangeSquared;

	private bool isDeforming;

	private Renderer meshRenderer;

	private MeshFilter meshFilter;

	private MeshDeformer meshDeformer;

	private bool triggerZDirection;

	private float deformPower = 0.75f;

	private float portalSwitchDistance = 0.03f;

	private NVRPlayer player;

	[SerializeField]
	public LayerMask alternateLayerMask;

	private void Start()
	{
		player = GameController.instance.player;
		meshRenderer = GetComponent<Renderer>();
		meshFilter = GetComponent<MeshFilter>();
		meshDeformer = GetComponent<MeshDeformer>();
		minimumDeformRangeSquared = maximumDeformRange * maximumDeformRange;
		triggerZDirection = base.transform.InverseTransformPoint(player.mainCamera.transform.position).z > 0f;
	}

	private void Update()
	{
		if (!portalEnabled)
		{
			return;
		}
		Vector3 size = meshFilter.mesh.bounds.size;
		if (Mathf.Pow(base.transform.InverseTransformDirection(player.transform.position - base.transform.position).z, 2f) <= minimumDeformRangeSquared && Mathf.Abs(base.transform.InverseTransformDirection(player.mainCamera.transform.position - base.transform.position).x) <= size.x * base.transform.lossyScale.x / 2f && Mathf.Abs(base.transform.InverseTransformDirection(player.mainCamera.transform.position - base.transform.position).y) <= size.y * base.transform.lossyScale.y / 2f && portalEnabled)
		{
			DeformPortalWithTransform(player.mainCamera.transform);
		}
		else if (isDeforming)
		{
			isDeforming = false;
			if ((bool)meshDeformer)
			{
				meshDeformer.ClearDeformingForce();
			}
		}
	}

	private void DeformPortalWithTransform(Transform otherTransform)
	{
		Vector3 vector = base.transform.InverseTransformPoint(otherTransform.position);
		if (vector.z > 0f != triggerZDirection && Mathf.Abs(vector.z) > portalSwitchDistance)
		{
			triggerZDirection = vector.z > 0f;
			if (isDeforming)
			{
				SwitchDimensions();
			}
		}
		if ((bool)meshDeformer)
		{
			meshDeformer.AddDeformingForce(otherTransform.position, deformPower, triggerZDirection);
		}
		isDeforming = true;
	}

	public void SwitchDimensions()
	{
		playerPassedThroughPortal = true;
		player.screenFX.Fade(UnityEngine.Color.black, 0f);
		player.mainCamera.cullingMask = alternateLayerMask;
	}

	public void TeleportToOtherDimension()
	{
		StartCoroutine(TeleportToOtherDimensionRoutine());
	}

	private IEnumerator TeleportToOtherDimensionRoutine()
	{
		GameController.instance.player.screenFX.Fade(UnityEngine.Color.black, 0f);
		playerTeleportingThroughPortal = true;
		SwitchDimensions();
		yield return null;
	}
}
public class MothSwarm : MonoBehaviour
{
	[SerializeField]
	private GameObject[] moths;

	[SerializeField]
	private ParticleSystem particles;

	private Animator[] anims;

	private void Start()
	{
	}

	private void Update()
	{
	}

	public void StartSwarm(GameObject target, float radius, float emitTime, float travelTime)
	{
	}
}
public class MovementPath : MonoBehaviour
{
	public enum PathTypes
	{
		linear,
		loop
	}

	public PathTypes PathType;

	public int movementDirection = 1;

	public int movingTo;

	public Transform[] PathSequence;

	private void Update()
	{
	}

	public void OnDrawGizmos()
	{
		if (PathSequence != null && PathSequence.Length >= 2)
		{
			for (int i = 1; i < PathSequence.Length; i++)
			{
				Gizmos.DrawLine(PathSequence[i - 1].position, PathSequence[i].position);
			}
			if (PathType == PathTypes.loop)
			{
				Gizmos.DrawLine(PathSequence[0].position, PathSequence[PathSequence.Length - 1].position);
			}
		}
	}

	public IEnumerator<Transform> GetNextPathPoint()
	{
		if (PathSequence == null || PathSequence.Length < 1)
		{
			yield break;
		}
		while (true)
		{
			yield return PathSequence[movingTo];
			if (PathSequence.Length == 1)
			{
				continue;
			}
			if (PathType == PathTypes.linear)
			{
				if (movingTo <= 0)
				{
					movementDirection = 1;
				}
				else if (movingTo >= PathSequence.Length - 1)
				{
					movementDirection = -1;
				}
			}
			movingTo += movementDirection;
			if (PathType == PathTypes.loop)
			{
				if (movingTo >= PathSequence.Length)
				{
					movingTo = 0;
				}
				if (movingTo < 0)
				{
					movingTo = PathSequence.Length - 1;
				}
			}
		}
	}
}
public class NurseryClosetLight : MonoBehaviour
{
	[HideInInspector]
	public bool bulbBroken;

	[SerializeField]
	private LightFlicker closetLight;

	private void OnEnable()
	{
		if (!bulbBroken && (bool)closetLight)
		{
			closetLight.StartBurst(float.PositiveInfinity, finishOn: false);
		}
	}
}
public abstract class NVRTrigger : MonoBehaviour
{
	public abstract void TriggerEnter(NVRInteractableItem item);

	public abstract void TriggerEnd(NVRInteractableItem item);

	public abstract void TriggerStay(NVRInteractableItem item);
}
public class ObjectAddExplosionForce : MonoBehaviour
{
	[SerializeField]
	private Rigidbody rb;

	[SerializeField]
	private float forceAmount = 50f;

	[SerializeField]
	private Transform forceTransform;

	[SerializeField]
	private float forceRadius = 1f;

	private void Start()
	{
		rb.isKinematic = true;
	}

	public void ObjectForce()
	{
		rb.isKinematic = false;
		rb.AddExplosionForce(forceAmount, forceTransform.position, forceRadius, 0f, ForceMode.Impulse);
	}
}
public class OilLighter : MonoBehaviour
{
	[SerializeField]
	private SparkEmitter spark;

	[SerializeField]
	private ParticleSystem flame;

	[SerializeField]
	private LightFlicker lightFlick;

	[SerializeField]
	private LightIntensityFlicker lightIntensityFlick;

	[SerializeField]
	private UnityEngine.UI.Image rechargeVisual;

	[SerializeField]
	private MeshRenderer lighterMeshRenderer;

	[SerializeField]
	private MeshRenderer lighterHalfMeshRenderer;

	[SerializeField]
	private Material lighterMaterial;

	[SerializeField]
	private Material lighterMaterialFade;

	[SerializeField]
	private Material lighterUpgadedMaterial;

	[SerializeField]
	private Material lighterUpgadedMaterialFade;

	[SerializeField]
	private VolumetricLightBeam lightBeam;

	[SerializeField]
	private LayerMask playerLightLayerOn;

	[SerializeField]
	private LayerMask playerLightLayerOff;

	private PlayerLight playerLight;

	private LightFlicker playerLightFlicker;

	public bool isOn;

	private bool recharging;

	private bool isUpgraded;

	private float elapsedTime;

	private float maxTime = 30f;

	private float fadeTime = 0.5f;

	private float rechargeTime = 5f;

	private float disabledTime;

	[HideInInspector]
	public bool canTurnOnLight;

	[HideInInspector]
	public bool transitioningState;

	[HideInInspector]
	private GameObject currentTarget;

	private bool disabled;

	[HideInInspector]
	public bool infiniteMode;

	private void Start()
	{
		flame.Stop();
		lightBeam.enabled = false;
		playerLight = GameController.instance.player.playerLight;
		playerLightFlicker = playerLight.GetComponent<LightFlicker>();
		if (SaveManager.instance.HasFoundArtifact(ChapterID.CELL))
		{
			UpgradeFuel(upgrade: true);
		}
	}

	private void Update()
	{
		if (isOn)
		{
			elapsedTime += Time.deltaTime;
			rechargeVisual.fillAmount = 1f - elapsedTime / maxTime;
			if (elapsedTime > maxTime && !infiniteMode)
			{
				TurnOff();
			}
		}
	}

	public void UpgradeFuel(bool upgrade)
	{
		isUpgraded = upgrade;
		if (upgrade)
		{
			maxTime = 45f;
			lighterHalfMeshRenderer.material = lighterUpgadedMaterial;
			lighterMeshRenderer.material = lighterUpgadedMaterial;
		}
		else
		{
			maxTime = 30f;
			lighterHalfMeshRenderer.material = lighterMaterial;
			lighterMeshRenderer.material = lighterMaterial;
		}
	}

	public void TogglePlayerLightingLayer(bool on)
	{
		if (lightFlick.light == null)
		{
			lightFlick.light = lightFlick.gameObject.GetComponent<Light>();
		}
		if (on)
		{
			lightFlick.light.cullingMask = playerLightLayerOn;
		}
		else
		{
			lightFlick.light.cullingMask = playerLightLayerOff;
		}
	}

	public void TurnOn()
	{
		if (!isOn && disabled)
		{
			spark.PlayOnce();
			return;
		}
		StopAllCoroutines();
		lightFlick.StopAllCoroutines();
		if (!isOn && !recharging)
		{
			StartCoroutine("On");
		}
		else if (isOn && !recharging)
		{
			StartCoroutine("Off", false);
		}
		else if (!isOn && recharging)
		{
			StartCoroutine("On");
		}
	}

	public void TurnOnLight()
	{
		StartCoroutine(LightOn());
	}

	private IEnumerator LightOn()
	{
		transitioningState = true;
		lightFlick.Fade(on: true, fadeTime);
		yield return Yield.WaitSeconds(fadeTime);
		lightIntensityFlick.flickerActive = true;
		transitioningState = false;
	}

	public void TurnOffLight()
	{
		lightFlick.SwitchLight(switchOn: false);
		lightIntensityFlick.flickerActive = false;
	}

	private IEnumerator On()
	{
		transitioningState = true;
		isOn = true;
		recharging = false;
		spark.PlayOnce();
		flame.Play();
		if (canTurnOnLight)
		{
			if (playerLight.shouldLightBeOn)
			{
				playerLightFlicker.SwitchLight(switchOn: false);
				playerLight.PlayClick();
				yield return Yield.EndOfFrame;
			}
			UnityEngine.Debug.Log("Fading in oil lighter light!");
			lightFlick.Fade(on: true, fadeTime);
		}
		lightBeam.enabled = true;
		yield return Yield.WaitSeconds(0.1f);
		spark.loopSound(loopingActive: true);
		yield return Yield.WaitSeconds(fadeTime);
		if (canTurnOnLight)
		{
			lightIntensityFlick.flickerActive = true;
		}
		yield return Yield.WaitSeconds(0.25f);
		transitioningState = false;
	}

	public void TurnOff()
	{
		if (isOn && !recharging)
		{
			StopAllCoroutines();
			StartCoroutine("Off", false);
		}
	}

	public void DisableLighter(bool disable)
	{
		if (disable)
		{
			disabled = true;
			StopAllCoroutines();
			if (isOn)
			{
				StartCoroutine("Off", true);
			}
		}
		else
		{
			disabled = false;
		}
	}

	public void PlacedInKit()
	{
		if (isOn && playerLight.shouldLightBeOn)
		{
			playerLightFlicker.SwitchLight(switchOn: true);
			playerLight.PlayClick();
		}
		StopCoroutine("On");
		StopCoroutine("Off");
		StopCoroutine("LightOn");
		transitioningState = false;
		lightIntensityFlick.flickerActive = false;
		lightFlick.SwitchLight(switchOn: false);
		lightBeam.enabled = false;
		flame.Stop();
		spark.loopSound(loopingActive: false);
		isOn = false;
		if (rechargeVisual.fillAmount != 1f)
		{
			recharging = true;
			StartCoroutine(Recharge());
		}
	}

	private IEnumerator Off(bool flickerOff)
	{
		transitioningState = true;
		recharging = true;
		lightIntensityFlick.flickerActive = false;
		flame.Stop();
		spark.loopSound(loopingActive: false);
		lightBeam.enabled = false;
		if (flickerOff)
		{
			if (canTurnOnLight)
			{
				lightFlick.StartBurst(1f, finishOn: false);
				yield return Yield.WaitSeconds(1f);
			}
		}
		else if (canTurnOnLight)
		{
			lightFlick.Fade(on: false, fadeTime);
			yield return Yield.WaitSeconds(fadeTime);
		}
		yield return Yield.WaitSeconds(0.25f);
		if (playerLight.shouldLightBeOn)
		{
			yield return Yield.EndOfFrame;
			playerLightFlicker.SwitchLight(switchOn: true);
			playerLight.PlayClick();
			yield return Yield.EndOfFrame;
		}
		isOn = false;
		StartCoroutine(Recharge());
		transitioningState = false;
	}

	private IEnumerator Recharge(bool startInstantly = false)
	{
		float remainingAmount = 1f - rechargeVisual.fillAmount;
		for (float t = rechargeVisual.fillAmount; t < 1f; t += Time.deltaTime / (rechargeTime * remainingAmount))
		{
			rechargeVisual.fillAmount = t;
			elapsedTime = maxTime - maxTime * t;
			yield return null;
		}
		elapsedTime = 0f;
		rechargeVisual.fillAmount = 1f;
		recharging = false;
	}

	public void HardReset()
	{
		StopAllCoroutines();
		lightIntensityFlick.flickerActive = false;
		lightFlick.SwitchLight(switchOn: false);
		lightBeam.enabled = false;
		transitioningState = false;
		if (isOn && playerLight.shouldLightBeOn)
		{
			playerLightFlicker.SwitchLight(switchOn: true);
			playerLight.PlayClick();
		}
		elapsedTime = 0f;
		isOn = false;
		recharging = false;
		rechargeVisual.fillAmount = 1f;
	}

	private void OnDisable()
	{
		if (recharging)
		{
			disabledTime = Time.time;
		}
	}

	private void OnEnable()
	{
		if (recharging)
		{
			disabledTime = Time.time - disabledTime;
			if (elapsedTime > disabledTime)
			{
				elapsedTime -= disabledTime;
				rechargeVisual.fillAmount = elapsedTime / maxTime;
				StartCoroutine(Recharge(startInstantly: true));
			}
			else
			{
				elapsedTime = 0f;
				recharging = false;
				rechargeVisual.fillAmount = 1f;
			}
		}
	}

	public void SetStandardShader()
	{
		if (isUpgraded)
		{
			lighterHalfMeshRenderer.material = lighterUpgadedMaterial;
			lighterMeshRenderer.material = lighterUpgadedMaterial;
		}
		else
		{
			lighterHalfMeshRenderer.material = lighterMaterial;
			lighterMeshRenderer.material = lighterMaterial;
		}
	}

	public void SetDissolveShader()
	{
		if (isUpgraded)
		{
			lighterHalfMeshRenderer.material = lighterUpgadedMaterialFade;
			lighterMeshRenderer.material = lighterUpgadedMaterialFade;
		}
		else
		{
			lighterHalfMeshRenderer.material = lighterMaterialFade;
			lighterMeshRenderer.material = lighterMaterialFade;
		}
	}

	public IEnumerator StartFadeOut(float time)
	{
		for (float t = 1f; t > 0f; t -= Time.deltaTime / time)
		{
			lighterMeshRenderer.material.SetFloat("_Dissolve", t);
			yield return null;
		}
		yield return null;
	}
}
public class OilLighterLookAt : MonoBehaviour
{
	private OilLighter lighter;

	[SerializeField]
	private GameObject maggot;

	[SerializeField]
	private GameObject poster;

	public bool hoveringOverMaggot;

	public bool hoveringOverPoster;

	private void Start()
	{
		lighter = GameController.instance.player.HandMenu.exKitScript.candle.GetComponent<OilLighter>();
	}

	private void FixedUpdate()
	{
		base.transform.position = lighter.transform.position;
		base.transform.rotation = lighter.transform.rotation;
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject == poster)
		{
			hoveringOverPoster = true;
		}
		else if (other.gameObject == maggot)
		{
			hoveringOverMaggot = true;
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (other.gameObject == poster)
		{
			hoveringOverPoster = false;
		}
		else if (other.gameObject == maggot)
		{
			hoveringOverMaggot = false;
		}
	}
}
public class OilLighterLookAtC5 : MonoBehaviour
{
	private OilLighter lighter;

	[SerializeField]
	private GameObject bridge;

	public bool hoveringOverBridge;

	private void Start()
	{
		lighter = GameController.instance.player.HandMenu.exKitScript.candle.GetComponent<OilLighter>();
	}

	private void FixedUpdate()
	{
		if ((bool)lighter)
		{
			base.transform.position = lighter.transform.position;
			base.transform.rotation = lighter.transform.rotation;
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject == bridge)
		{
			hoveringOverBridge = true;
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (other.gameObject == bridge)
		{
			hoveringOverBridge = false;
		}
	}
}
public class OptionsManager : MonoBehaviour
{
}
public class ParticleLight : MonoBehaviour
{
	private Light m_light;

	[SerializeField]
	private float flashTime = 2f;

	private bool startOnEnable;

	private float fullIntensity;

	private void Start()
	{
		if (base.gameObject.GetComponent<Light>() != null)
		{
			m_light = base.gameObject.GetComponent<Light>();
		}
		else
		{
			m_light = base.gameObject.AddComponent<Light>();
		}
		fullIntensity = m_light.intensity;
		m_light.intensity = 0f;
	}

	private void OnEnable()
	{
		if (startOnEnable)
		{
			StartCoroutine(FadeOut());
		}
		startOnEnable = true;
	}

	private IEnumerator Flash()
	{
		float fadeInTime = flashTime * 0.25f;
		while (m_light.intensity < fullIntensity)
		{
			float num = Mathf.Clamp01(Time.deltaTime / fadeInTime);
			m_light.intensity += num;
			yield return null;
		}
		StartCoroutine(FadeOut());
	}

	private IEnumerator FadeOut()
	{
		m_light.intensity = fullIntensity;
		float fadeOutTime = flashTime * 0.75f;
		while (m_light.intensity > 0f)
		{
			float num = Mathf.Clamp01(Time.deltaTime / fadeOutTime);
			m_light.intensity -= num;
			yield return null;
		}
	}
}
public class PatientHeadBang : MonoBehaviour
{
	[SerializeField]
	private AudioSource bangAudio;

	[SerializeField]
	private AudioClip bangSound;

	[Space]
	[SerializeField]
	private AudioScript patientAudio;

	[SerializeField]
	private AudioClip[] patientShouts;

	[HideInInspector]
	public bool seenPatient;

	[HideInInspector]
	public bool showRonove;

	public void PlayBang()
	{
		bangAudio.PlayOneShot(bangSound);
		if (seenPatient)
		{
			showRonove = true;
		}
	}

	public void PlayShout()
	{
		if (!patientAudio.m_AudioSource.isPlaying)
		{
			patientAudio.Play(patientShouts[UnityEngine.Random.Range(0, patientShouts.Length)]);
		}
	}
}
public class PazDarkness : MonoBehaviour
{
	[SerializeField]
	private GameObject floorGuide;

	[SerializeField]
	private GameObject pazObj;

	[SerializeField]
	private Animator pazAnim;

	[SerializeField]
	private GameObject moth;

	[SerializeField]
	public GameObject pazSightTrigger;

	[SerializeField]
	public Renderer pazEyeRenderer;

	[SerializeField]
	public Light darknessLight;

	[SerializeField]
	private Transform animPos01;

	[SerializeField]
	private Transform animPos02;

	[SerializeField]
	private Transform animPos03;

	[SerializeField]
	private AnimationClip voAnimClip1;

	[SerializeField]
	private AnimationClip voAnimClip2;

	[SerializeField]
	private AnimationClip voAnimClip3;

	[SerializeField]
	private Transform[] voClipPos;

	[SerializeField]
	private AudioClip[] voClip;

	[SerializeField]
	private AudioScript audioScript;

	[SerializeField]
	private LipSync pazuzuLipSync;

	[SerializeField]
	private LipSyncData pazLipSyncData01;

	[SerializeField]
	private LipSyncData pazLipSyncData02;

	[SerializeField]
	private LipSyncData pazLipSyncData03;

	public GameObject playerStartPos;

	[HideInInspector]
	public bool hasRunPazDarknessRoutine;

	private float _pazCounter;

	private NVRPlayer player;

	private void Start()
	{
		floorGuide.SetActive(value: false);
		moth.SetActive(value: true);
		pazSightTrigger.SetActive(value: false);
		darknessLight.range = 1f;
		player = GameController.instance.player;
	}

	public void RunPazFromDarkness()
	{
		StartCoroutine(RunPazFromDarknessRoutine());
	}

	private IEnumerator RunPazFromDarknessRoutine()
	{
		UnityEngine.Color pazEm = new UnityEngine.Color(0.1f, 0.1f, 0.1f);
		SetPaz(animPos01);
		SetAudio(voClipPos[0]);
		pazSightTrigger.SetActive(value: true);
		pazEyeRenderer.sharedMaterial.SetColor("_EmissionColor", pazEm);
		while (pazSightTrigger.activeInHierarchy)
		{
			yield return Yield.EndOfFrame;
		}
		LeanTween.moveLocalY(moth, 4.5f, 10f);
		yield return Yield.WaitSeconds(1.5f);
		pazAnim.SetTrigger("Vo1");
		pazuzuLipSync.Play(pazLipSyncData01);
		audioScript.Play(voClip[0]);
		HUD.Instance.PlaySubtitles(voClip[0].name, hasPriority: true);
		yield return Yield.WaitSeconds(voAnimClip1.length - 1f);
		pazEyeRenderer.sharedMaterial.SetColor("_EmissionColor", UnityEngine.Color.black);
		yield return Yield.WaitSeconds(1f);
		darknessLight.range = 0.8f;
		SetAudio(voClipPos[1]);
		audioScript.Play(voClip[1]);
		HUD.Instance.PlaySubtitles(voClip[1].name, hasPriority: true);
		yield return Yield.WaitSeconds(voClip[1].length);
		SetAudio(voClipPos[2]);
		audioScript.Play(voClip[2]);
		HUD.Instance.PlaySubtitles(voClip[2].name, hasPriority: true);
		yield return Yield.WaitSeconds(voClip[2].length);
		SetAudio(voClipPos[3]);
		audioScript.Play(voClip[3]);
		HUD.Instance.PlaySubtitles(voClip[3].name, hasPriority: true);
		yield return Yield.WaitSeconds(voClip[3].length);
		SetPaz(animPos02);
		SetAudio(voClipPos[4]);
		pazSightTrigger.SetActive(value: true);
		pazEyeRenderer.sharedMaterial.SetColor("_EmissionColor", pazEm);
		while (pazSightTrigger.activeInHierarchy)
		{
			yield return Yield.EndOfFrame;
		}
		audioScript.Play(voClip[4]);
		HUD.Instance.PlaySubtitles(voClip[4].name, hasPriority: true);
		pazAnim.SetTrigger("Vo2");
		pazuzuLipSync.Play(pazLipSyncData02);
		yield return Yield.WaitSeconds(voAnimClip2.length - 1f);
		pazEyeRenderer.sharedMaterial.SetColor("_EmissionColor", UnityEngine.Color.black);
		yield return Yield.WaitSeconds(1f);
		darknessLight.range = 0.6f;
		SetAudio(voClipPos[5]);
		audioScript.Play(voClip[5]);
		HUD.Instance.PlaySubtitles(voClip[5].name, hasPriority: true);
		yield return Yield.WaitSeconds(voClip[5].length);
		SetPaz(animPos03);
		SetAudio(voClipPos[6]);
		pazSightTrigger.SetActive(value: true);
		pazEyeRenderer.sharedMaterial.SetColor("_EmissionColor", pazEm);
		while (pazSightTrigger.activeInHierarchy)
		{
			yield return Yield.EndOfFrame;
		}
		audioScript.Play(voClip[6]);
		HUD.Instance.PlaySubtitles(voClip[6].name, hasPriority: true);
		pazAnim.SetTrigger("Vo3");
		pazuzuLipSync.Play(pazLipSyncData03);
		yield return Yield.WaitSeconds(voClip[6].length - 7f);
		hasRunPazDarknessRoutine = true;
		yield return Yield.WaitSeconds(7f);
		pazEyeRenderer.sharedMaterial.SetColor("_EmissionColor", UnityEngine.Color.black);
	}

	private void SetPaz(Transform trans)
	{
		pazObj.transform.position = trans.position;
		pazObj.transform.rotation = trans.rotation;
	}

	private void SetAudio(Transform trans)
	{
		audioScript.gameObject.transform.position = trans.position;
	}

	private void Update()
	{
		if (player != null)
		{
			Vector3 forward = player.Head.transform.position - pazObj.transform.position;
			forward.y = 0f;
			pazObj.transform.rotation = Quaternion.LookRotation(forward);
		}
	}
}
public class Pazuzu : MonoBehaviour
{
	[Serializable]
	public struct Range
	{
		public float min;

		public float max;

		public float Distance => max - min;
	}

	[Serializable]
	public struct TuneCrossParticles
	{
		public ParticleSystem particle;

		public Range lifetimeRange;

		public Range emmitRateRange;
	}

	[Serializable]
	public class FishEyeBreathing
	{
		public float time;

		public float xStrength;

		public float yStrength;
	}

	[Serializable]
	public struct MovementAnim
	{
		public string animTriggerName;

		public GameObject sightTrigger;

		public AnimationClip clip;
	}

	[Header("Pazuzu")]
	[SerializeField]
	public GameObject pazuzuMesh;

	[SerializeField]
	private GameObject[] eyeMesh;

	[SerializeField]
	public Animator pazuzuAnimator;

	[SerializeField]
	public BoxCollider pazuzuHipCollider;

	[SerializeField]
	public BoxCollider pazuzuMainCollider;

	[SerializeField]
	public MovementAnim[] movementAnimTriggersOrdered;

	[SerializeField]
	public MovementAnim[] movementAnimTriggersLooped;

	private int movementAnimIndex;

	private int loopedAnimIndex;

	[SerializeField]
	private float waitTimeAfterMovementAnim;

	[SerializeField]
	public Transform pazuzuPossesTransform;

	[SerializeField]
	public Transform pazuzuEndTransform;

	[SerializeField]
	private GameObject pazTuneTarget;

	[SerializeField]
	private GameObject[] pazExorcismTargets;

	[SerializeField]
	private ParticleSystem pazLandingParticle;

	[SerializeField]
	private Renderer[] pazRenderer;

	[SerializeField]
	private Material pazBurnMat;

	[SerializeField]
	private Material pazFadeMat;

	[SerializeField]
	private Material pazStandardMat;

	[SerializeField]
	private Material pazBurnHands;

	[SerializeField]
	private Material pazBurnFromCrossMat;

	[SerializeField]
	private Range pazBurnFromCrossDissolveRange;

	[SerializeField]
	private ParticleSystem pazAttackParticle01;

	[SerializeField]
	private ParticleSystem pazAttackParticle02;

	[SerializeField]
	private ParticleSystem pazPersonalLightBurn;

	[SerializeField]
	private ParticleSystem pazPersonalBurnOneShotParticle;

	[SerializeField]
	private ParticleSystem pazPreAttackParticles;

	[SerializeField]
	private TuneCrossParticles[] tuneCrossParticles;

	[SerializeField]
	private float tuneParticlesMinAt;

	[SerializeField]
	private float tuneParticlesMaxAt;

	[HideInInspector]
	public bool pauseAnimation;

	[HideInInspector]
	public bool seenPazuzu;

	[HideInInspector]
	public bool canBeAttacked;

	[HideInInspector]
	public bool canDeathBeSeen;

	[HideInInspector]
	public bool hasSeenDeath;

	[HideInInspector]
	public bool hasSeenPazHurt;

	[Space]
	[Header("Environment")]
	[SerializeField]
	private TombScene tombScene;

	[SerializeField]
	private Animator columnAnim;

	[SerializeField]
	private Animator mercuryAnim;

	[SerializeField]
	private GameObject finalCrossLightObject;

	[SerializeField]
	private GameObject finalCrossLight;

	[SerializeField]
	private GameObject[] finalCrossLightTargets;

	[SerializeField]
	private BatSwarm batSwarm;

	[SerializeField]
	public ParticleSystem rockFall01;

	[SerializeField]
	public ParticleSystem rockFall02;

	[SerializeField]
	public ParticleSystem rockFall03;

	[SerializeField]
	private GameObject ceilingRocks;

	[SerializeField]
	private ParticleSystem ceilingParticleBurst;

	[SerializeField]
	private ParticleSystem lightCrackTuneParticles;

	[SerializeField]
	private ParticleSystem fallingRocksEndingParticle;

	[SerializeField]
	private GameObject fallingRockSetpiece;

	[SerializeField]
	private GameObject navMeshBlockFull;

	[Space]
	[Header("Player")]
	[SerializeField]
	private GameObject playerFloatTarget;

	[SerializeField]
	private Transform playerParent;

	[SerializeField]
	private AudioClip playerSineClip;

	[SerializeField]
	private ParticleSystem playerHitParticles;

	[SerializeField]
	private FishEyeBreathing fishEyeValues;

	[SerializeField]
	private UnityEngine.Color pazAttackFlashColour;

	[HideInInspector]
	private NVRPlayer player;

	[Space]
	[Header("Audio")]
	[SerializeField]
	private Transform[] floatingAudioPoints;

	[SerializeField]
	private AudioClip[] pazVOFinaleClips;

	[SerializeField]
	private AudioClip[] pazVOFightClips;

	[SerializeField]
	private AudioClip[] pazAttackClips;

	[SerializeField]
	private AudioClip columbBreakClip;

	[SerializeField]
	private AudioClip pazBreathClip;

	[SerializeField]
	private AudioClip pazBurnClip;

	[SerializeField]
	private AudioClip pazColumnClip;

	[SerializeField]
	private AudioClip heartbeatClip;

	[SerializeField]
	public AudioClip[] fatherBellHintClips;

	[SerializeField]
	private Transform pazuzuFloatingAudio;

	[SerializeField]
	private AudioClip angelSfx;

	[SerializeField]
	private AudioClip pazHissSmall;

	[SerializeField]
	private AudioScript growlAudioScript;

	private GameObject cross;

	private TuneController tuneCross;

	private ExorcismItem interactableCross;

	[HideInInspector]
	public GameObject currentSightTrigger;

	[HideInInspector]
	public bool hitSightTrigger;

	private Transform originalParent;

	private float tuneCrossDuration = 40f;

	private float animationSpeedStandard = 1f;

	private float animationSpeedAttacked = 1.3f;

	private float chargeTimeStarted;

	private bool moving;

	private bool stopMovement;

	private bool hasBeenHit;

	private bool movementSpeedIncreased;

	private bool columnDestroyed;

	private bool movementAnimationFinished;

	private bool updatePosition;

	private bool pazDeathLand;

	private bool canHitPazWithCross;

	private bool isFishEyeBreathing;

	private bool runEarthquake;

	private bool disableSparksPermently;

	private bool isLoopingAnimations;

	private bool runBatSwarm = true;

	private bool hasAttacked1;

	private bool hasAttacked2;

	public bool exorcisedCrackInTime;

	private void Start()
	{
		navMeshBlockFull.SetActive(value: false);
		player = GameController.instance.player;
		originalParent = base.transform.parent;
		finalCrossLightObject.SetActive(value: false);
		fallingRockSetpiece.SetActive(value: false);
		playerHitParticles.transform.parent = player.Head.transform;
		playerHitParticles.transform.localPosition = Vector3.zero;
		playerHitParticles.transform.localRotation = default(Quaternion);
		cross = player.HandMenu.exKitScript.cross;
		tuneCross = cross.GetComponent<TuneController>();
		interactableCross = cross.GetComponent<ExorcismItem>();
		for (int i = 0; i < pazRenderer.Length; i++)
		{
			pazRenderer[i].sharedMaterial.SetFloat("_Dissolve", 0f);
			pazRenderer[i].sharedMaterial = pazStandardMat;
		}
		for (int j = 0; j < movementAnimTriggersOrdered.Length; j++)
		{
			movementAnimTriggersOrdered[j].sightTrigger.SetActive(value: false);
		}
		TuneCrossParticles[] array = tuneCrossParticles;
		for (int k = 0; k < array.Length; k++)
		{
			TuneCrossParticles obj = array[k];
			float min = obj.lifetimeRange.min;
			float min2 = obj.emmitRateRange.min;
			ParticleSystem.EmissionModule emission = obj.particle.emission;
			if (emission.enabled)
			{
				emission.rateOverTime = new ParticleSystem.MinMaxCurve(min2);
			}
			ParticleSystem.MainModule main = obj.particle.main;
			main.startLifetime = new ParticleSystem.MinMaxCurve(min);
		}
	}

	private IEnumerator TuneCrossParticlesRoutine()
	{
		while (tuneCross.HoldTime <= tuneCrossDuration)
		{
			float num = tuneCross.HoldTime / tuneCrossDuration;
			num = (num - tuneParticlesMinAt) / (tuneParticlesMaxAt - tuneParticlesMinAt);
			if (num > 0f)
			{
				for (int i = 0; i < pazRenderer.Length; i++)
				{
					if (!pazRenderer[i].sharedMaterial != (bool)pazBurnFromCrossMat)
					{
						pazRenderer[i].sharedMaterial = pazBurnFromCrossMat;
					}
					float value = pazBurnFromCrossDissolveRange.min + pazBurnFromCrossDissolveRange.Distance * num;
					value = Mathf.Clamp(value, pazBurnFromCrossDissolveRange.min, pazBurnFromCrossDissolveRange.max);
					pazRenderer[i].sharedMaterial.SetFloat("_Amount", value);
				}
				TuneCrossParticles[] array = this.tuneCrossParticles;
				for (int j = 0; j < array.Length; j++)
				{
					TuneCrossParticles tuneCrossParticles = array[j];
					if (!tuneCrossParticles.particle.isPlaying)
					{
						tuneCrossParticles.particle.Play();
					}
					float min = tuneCrossParticles.lifetimeRange.min;
					Range lifetimeRange = tuneCrossParticles.lifetimeRange;
					float constant = Mathf.Clamp(min + lifetimeRange.Distance * num, tuneCrossParticles.lifetimeRange.min, tuneCrossParticles.lifetimeRange.max);
					float min2 = tuneCrossParticles.emmitRateRange.min;
					lifetimeRange = tuneCrossParticles.emmitRateRange;
					float constant2 = Mathf.Clamp(min2 + lifetimeRange.Distance * num, tuneCrossParticles.emmitRateRange.min, tuneCrossParticles.emmitRateRange.max);
					ParticleSystem.EmissionModule emission = tuneCrossParticles.particle.emission;
					if (emission.enabled)
					{
						emission.rateOverTime = new ParticleSystem.MinMaxCurve(constant2);
					}
					ParticleSystem.MainModule main = tuneCrossParticles.particle.main;
					main.startLifetime = new ParticleSystem.MinMaxCurve(constant);
				}
			}
			yield return Yield.EndOfFrame;
		}
	}

	private void Update()
	{
		if (moving && !stopMovement && chargeTimeStarted < tuneCross.HoldTime && pazuzuAnimator.speed == animationSpeedStandard && !movementSpeedIncreased)
		{
			StartCoroutine(IncreaseMovementSpeed());
		}
		if (updatePosition)
		{
			base.transform.position = new Vector3(player.Head.transform.position.x, base.transform.position.y, player.Head.transform.position.z);
		}
	}

	private IEnumerator IncreaseMovementSpeed()
	{
		movementSpeedIncreased = true;
		yield return Yield.WaitSeconds(1f);
		pazuzuAnimator.speed = animationSpeedAttacked;
	}

	public void MovementAnimationStarted()
	{
		pazuzuMesh.SetActive(value: true);
		for (int i = 0; i < eyeMesh.Length; i++)
		{
			eyeMesh[i].SetActive(value: true);
		}
		TuneCrossParticles[] array = this.tuneCrossParticles;
		for (int j = 0; j < array.Length; j++)
		{
			TuneCrossParticles tuneCrossParticles = array[j];
			if ((!(tuneCrossParticles.particle == this.tuneCrossParticles[2].particle) || !disableSparksPermently) && !tuneCrossParticles.particle.isPlaying)
			{
				tuneCrossParticles.particle.Play();
			}
		}
	}

	public void MovementAnimationFinished()
	{
		movementAnimationFinished = true;
		pazuzuMesh.SetActive(value: false);
		for (int i = 0; i < eyeMesh.Length; i++)
		{
			eyeMesh[i].SetActive(value: false);
		}
		TuneCrossParticles[] array = tuneCrossParticles;
		for (int j = 0; j < array.Length; j++)
		{
			array[j].particle.Stop();
		}
	}

	private IEnumerator MovementRoutine()
	{
		moving = true;
		stopMovement = false;
		while (moving)
		{
			if (!isLoopingAnimations)
			{
				if (tuneCross.HoldTime < tuneCrossDuration * 0.3f && movementAnimIndex == movementAnimTriggersOrdered.Length / 2 && !hasAttacked1)
				{
					tuneCross.HoldTime = tuneCrossDuration * 0.3f;
					moving = false;
					stopMovement = true;
					UnityEngine.Debug.Log("Breaking from movement routine for attack 1");
					hasAttacked1 = true;
					break;
				}
				if (tuneCross.HoldTime < tuneCrossDuration * 0.5f && movementAnimIndex == movementAnimTriggersOrdered.Length && !hasAttacked2)
				{
					tuneCross.HoldTime = tuneCrossDuration * 0.5f;
					moving = false;
					stopMovement = true;
					isLoopingAnimations = true;
					UnityEngine.Debug.Log("Breaking from movement routine for attack 2");
					hasAttacked2 = true;
					break;
				}
			}
			if (runBatSwarm && movementAnimIndex == 2)
			{
				batSwarm.StartSwarm();
				yield return Yield.WaitSeconds(batSwarm.attackDuration);
			}
			if (!growlAudioScript.m_AudioSource.isPlaying)
			{
				growlAudioScript.PlayLoop(tombScene.voPazGrowlLoop, 0f);
			}
			chargeTimeStarted = tuneCross.HoldTime;
			movementAnimationFinished = false;
			movementSpeedIncreased = false;
			MovementAnim movement = (isLoopingAnimations ? movementAnimTriggersLooped[loopedAnimIndex] : movementAnimTriggersOrdered[movementAnimIndex]);
			currentSightTrigger = movement.sightTrigger;
			currentSightTrigger.SetActive(value: true);
			hitSightTrigger = false;
			while (!hitSightTrigger)
			{
				yield return Yield.EndOfFrame;
			}
			pazuzuAnimator.SetTrigger(movement.animTriggerName);
			UnityEngine.Debug.Log("Playing Movement Anim: " + movement.animTriggerName);
			growlAudioScript.FadeVolumeIn(1f);
			if (isLoopingAnimations)
			{
				loopedAnimIndex++;
				if (loopedAnimIndex == movementAnimTriggersLooped.Length)
				{
					loopedAnimIndex = 0;
				}
				yield return Yield.WaitSeconds(movement.clip.length - 1f);
			}
			else
			{
				movementAnimIndex++;
				yield return Yield.WaitSeconds(movement.clip.length - 1f);
			}
			growlAudioScript.FadeVolumeOut(1f);
			while (!movementAnimationFinished)
			{
				yield return Yield.EndOfFrame;
			}
			yield return Yield.WaitSeconds(waitTimeAfterMovementAnim);
			if (stopMovement)
			{
				UnityEngine.Debug.Log("Dropping out of movement routine");
				moving = false;
			}
		}
	}

	public IEnumerator ExorcismPart1()
	{
		PauseCrossTuning();
		StartCoroutine(MovementRoutine());
		tuneCross.StartTuning(pazTuneTarget, pazExorcismTargets, tuneCrossDuration, float.MaxValue, isSlowMo: false, 0.6f, 100f, reposition: false);
		tuneCross.TheLight(isEnabled: true);
		while ((double)tuneCross.HoldTime < (double)tuneCrossDuration * 0.3)
		{
			yield return Yield.EndOfFrame;
		}
		tuneCross.PauseCrossTuning = true;
		stopMovement = true;
		while (moving)
		{
			yield return Yield.EndOfFrame;
		}
		StopCoroutine(MovementRoutine());
		tombScene.hasSeenPazuzuAttack1 = false;
		tombScene.pazuzuAttack1SightTrigger.SetActive(value: true);
		pazuzuAnimator.SetTrigger("AttackIdle1");
		while (!tombScene.hasSeenPazuzuAttack1)
		{
			yield return Yield.EndOfFrame;
		}
		pazuzuAnimator.speed = animationSpeedStandard;
		pazuzuAnimator.SetTrigger("Attack1");
		yield return Yield.WaitSeconds(4.5f);
		tombScene.musicStem01.PlayOne(pazAttackClips[0]);
		tombScene.musicStem02.FadeOut(0.5f);
		tombScene.musicStem03.FadeVolumeOut(0.5f, 0.2f);
		tombScene.SlowTime(0.1f);
		yield return Yield.WaitSeconds(0.07f);
		tombScene.SlowTime(1f);
		yield return Yield.WaitSeconds(0.15f);
		player.screenFX.Fade(pazAttackFlashColour, 0.1f);
		player.screenFX.BlurScreen(enabled: true);
		player.playerAudio.FadeIn(playerSineClip, 1f, 0.5f, loop: true);
		yield return Yield.WaitSeconds(1.5f);
		playerHitParticles.Play();
		player.screenFX.Fade(UnityEngine.Color.clear, 1.5f);
		tombScene.musicStem03.FadeVolumeIn(3f, 0.4f);
		player.screenFX.BlurScreen(enabled: false, fade: true, 3f);
		player.playerAudio.FadeOut(6f);
		base.transform.localPosition = Vector3.zero;
		AudioScript obj = AudioScriptContainer.Instance.audioScripts[3];
		obj.transform.position = floatingAudioPoints[0].position;
		obj.Play(pazVOFightClips[0]);
		HUD.Instance.PlaySubtitles(pazVOFightClips[0].name, hasPriority: true);
		yield return Yield.WaitSeconds(6f);
	}

	public IEnumerator ExorcismPart2()
	{
		tuneCross.PauseCrossTuning = false;
		StartCoroutine(MovementRoutine());
		tombScene.musicStem02.PlayLoop(tombScene.musicDrums02);
		tombScene.musicStem03.FadeVolumeIn(1f);
		while ((double)tuneCross.HoldTime < (double)tuneCrossDuration * 0.5)
		{
			yield return Yield.EndOfFrame;
		}
		isLoopingAnimations = true;
		tuneCross.PauseCrossTuning = true;
		stopMovement = true;
		while (moving)
		{
			yield return Yield.EndOfFrame;
		}
		StopCoroutine(MovementRoutine());
		tombScene.hasSeenPazuzuAttack2 = false;
		tombScene.pazuzuAttack2SightTrigger.SetActive(value: true);
		pazuzuAnimator.SetTrigger("AttackIdle2");
		while (!tombScene.hasSeenPazuzuAttack2)
		{
			yield return Yield.EndOfFrame;
		}
		pazuzuAnimator.speed = animationSpeedStandard;
		pazuzuAnimator.SetTrigger("Attack2");
		yield return Yield.WaitSeconds(4.5f);
		StartCoroutine(EarthquakeAndCameraShake());
		tombScene.musicStem01.PlayOne(pazAttackClips[1]);
		tombScene.musicStem02.FadeOut(0.75f);
		tombScene.musicStem03.FadeVolumeOut(0.75f, 0.2f);
		tombScene.SlowTime(0.1f);
		yield return Yield.WaitSeconds(0.07f);
		tombScene.SlowTime(1f);
		yield return Yield.WaitSeconds(0.1f);
		player.screenFX.Fade(pazAttackFlashColour, 0.1f);
		player.screenFX.BlurScreen(enabled: true);
		player.playerAudio.FadeIn(playerSineClip, 1f, 0.5f, loop: true);
		yield return Yield.WaitSeconds(1.5f);
		TuneCrossParticles[] array = tuneCrossParticles;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].particle.Stop();
		}
		playerHitParticles.Play();
		player.screenFX.Fade(UnityEngine.Color.clear, 1.5f);
		tombScene.musicStem03.FadeVolumeIn(3f, 0.4f);
		player.screenFX.BlurScreen(enabled: false, fade: true, 6f);
		player.playerAudio.FadeOut(12f);
		base.transform.localPosition = Vector3.zero;
		AudioScript obj = AudioScriptContainer.Instance.audioScripts[3];
		obj.transform.position = floatingAudioPoints[1].position;
		obj.Play(pazVOFightClips[1]);
		HUD.Instance.PlaySubtitles(pazVOFightClips[1].name, hasPriority: true);
		yield return Yield.WaitSeconds(10f);
	}

	private IEnumerator EarthquakeAndCameraShake()
	{
		tombScene.fallingRockLoopAudio.PlayLoop(tombScene.earthquakeClip, 0f);
		player.screenFX.ShakeCamera();
		float maxCameraShake = 0.025f;
		runEarthquake = true;
		while (runEarthquake)
		{
			float num = tuneCross.HoldTime / tuneCrossDuration;
			num = (num - 0.5f) / 0.5f;
			if (num > 0f)
			{
				player.screenFX.cameraShakeAmount = maxCameraShake * num;
				tombScene.fallingRockLoopAudio.m_AudioSource.volume = num;
			}
			yield return Yield.WaitSeconds(0.1f);
		}
		tombScene.fallingRockLoopAudio.FadeOut(0.5f);
	}

	public IEnumerator ExorcismPart3()
	{
		tuneCross.PauseCrossTuning = false;
		StartCoroutine(MovementRoutine());
		StartCoroutine(TuneCrossParticlesRoutine());
		tombScene.musicStem02.PlayLoop(tombScene.musicDrums03);
		while (tuneCross.HoldTime <= tuneCrossDuration * 0.8f)
		{
			yield return Yield.EndOfFrame;
		}
		tuneCross.PauseCrossTuning = true;
		stopMovement = true;
		while (moving)
		{
			yield return Yield.EndOfFrame;
		}
		StopCoroutine(MovementRoutine());
		pazuzuAnimator.speed = animationSpeedStandard;
		tombScene.pazuzuWeakenedSightTrigger.SetActive(value: true);
		while (!hasSeenPazHurt)
		{
			yield return Yield.EndOfFrame;
		}
		pazuzuAnimator.SetTrigger("WeakenedState");
		while (!canHitPazWithCross)
		{
			yield return Yield.EndOfFrame;
		}
		tuneCross.OverrideHitSuccess = false;
		tuneCross.PauseCrossTuning = false;
		while (!tuneCross.tuneSuccess)
		{
			yield return Yield.EndOfFrame;
		}
		tuneCross.StartLightTarget(pazTuneTarget);
		pazTuneTarget.gameObject.SetLayer(11);
		while (!tuneCross.hitSuccess)
		{
			yield return Yield.EndOfFrame;
		}
		tuneCross.ShootBeam(withAudio: true, disableLight: false, keepLockedToHand: true, instant: true);
		tuneCross.FadeLightTarget();
		runEarthquake = false;
		for (int i = 0; i < pazRenderer.Length; i++)
		{
			pazRenderer[i].sharedMaterial.SetFloat("_Amount", 0.25f);
		}
		growlAudioScript.Play(pazColumnClip);
		pazuzuAnimator.speed = 0.5f;
		pazuzuAnimator.SetTrigger("Hurt2");
		tombScene.arenaAmbientLight.range = 12.5f;
		tombScene.musicStem02.FadeOut(0.5f);
		tombScene.musicStem03.FadeOut(6f);
		yield return Yield.WaitSeconds(0.6f);
		tombScene.fallingRockLoopAudio.PlayLoop(tombScene.fallingRockLoopClip);
		rockFall02.Play();
		rockFall03.Play();
		columnAnim.SetTrigger("Break");
		AudioScript obj = AudioScriptContainer.Instance.audioScripts[3];
		obj.transform.position = pazuzuMesh.transform.position;
		obj.Play(columbBreakClip);
		yield return Yield.WaitSeconds(3f);
		mercuryAnim.SetTrigger("Drain");
		yield return Yield.WaitSeconds(3.5f);
		columnDestroyed = true;
		tombScene.SlowTime(1f);
		tombScene.musicStem02.PlayLoop(tombScene.musicBuildLight);
		tuneCross.tuneSuccess = false;
		tuneCross.hitSuccess = false;
		finalCrossLightObject.SetActive(value: true);
	}

	public IEnumerator ExorcismPart4()
	{
		tuneCrossParticles[2].particle.Stop();
		disableSparksPermently = true;
		yield return Yield.WaitSeconds(5f);
		pazuzuAnimator.speed = animationSpeedStandard;
		pazuzuAnimator.SetTrigger("BeginPossesion");
		for (int i = 0; i < pazRenderer.Length; i++)
		{
			pazRenderer[i].sharedMaterial = pazBurnHands;
		}
		playerHitParticles.transform.parent = base.transform.parent;
		AudioScript audioScriptPaz1 = AudioScriptContainer.Instance.audioScripts[2];
		audioScriptPaz1.transform.position = floatingAudioPoints[5].position;
		audioScriptPaz1.Play(pazVOFinaleClips[0]);
		HUD.Instance.PlaySubtitles(pazVOFinaleClips[0].name, hasPriority: true);
		yield return Yield.WaitSeconds(pazVOFinaleClips[0].length - 5f);
		tombScene.musicStem01.FadeIn(pazBreathClip, 1f, 5f, loop: true);
		tombScene.musicStem01.SetMixerChannel(AudioScript.MixerChannel.vo);
		AudioScript obj = AudioScriptContainer.Instance.audioScripts[0];
		obj.transform.position = floatingAudioPoints[6].position;
		obj.Play(pazVOFinaleClips[1]);
		HUD.Instance.PlaySubtitles(pazVOFinaleClips[1].name, hasPriority: true);
		yield return Yield.WaitSeconds(pazVOFinaleClips[1].length - 4.5f);
		audioScriptPaz1.transform.position = floatingAudioPoints[7].position;
		audioScriptPaz1.Play(pazVOFinaleClips[2]);
		HUD.Instance.PlaySubtitles(pazVOFinaleClips[2].name, hasPriority: true);
		yield return Yield.WaitSeconds(pazVOFinaleClips[2].length - 5.5f);
		AudioScript obj2 = AudioScriptContainer.Instance.audioScripts[1];
		obj2.transform.position = floatingAudioPoints[5].position;
		obj2.Play(pazVOFinaleClips[3]);
		HUD.Instance.PlaySubtitles(pazVOFinaleClips[3].name, hasPriority: true);
		yield return Yield.WaitSeconds(pazVOFinaleClips[3].length - 3.5f);
		player.movement.DisableMovement();
		navMeshBlockFull.SetActive(value: true);
		base.transform.parent = player.Head.transform;
		Vector3 zero = Vector3.zero;
		zero.y -= 1.72f;
		base.transform.localPosition = zero;
		base.transform.localRotation = default(Quaternion);
		UnityEngine.Debug.Log("PARENTENING PAZ TO PLAYER");
		tombScene.fallingRockLoopAudio.FadeVolumeOut(pazVOFinaleClips[3].length, 0.35f);
		audioScriptPaz1.transform.parent = player.Head.transform;
		audioScriptPaz1.transform.localPosition = Vector3.zero - player.Head.transform.forward * 0.25f;
		audioScriptPaz1.Play(pazVOFinaleClips[4], 3f);
		HUD.Instance.PlaySubtitles(pazVOFinaleClips[4].name, hasPriority: true);
		tombScene.musicStem02.FadeOut(2f);
		pazuzuAnimator.SetTrigger("Posession");
		tombScene.musicStem03.SetMixerChannel(AudioScript.MixerChannel.vo);
		tombScene.musicStem03.Play(tombScene.musicPazEnter);
		yield return Yield.WaitSeconds(6.33f);
		player.screenFX.Fade(UnityEngine.Color.black, 0.1f);
		player.screenFX.cameraShakeAmount = 0.001f;
		GameController.instance.audioController.SnapDipAll(2f);
		UnityEngine.Color color = default(UnityEngine.Color);
		color.r = 1f;
		color.g = 0.35f;
		color.b = 0.35f;
		tombScene.arenaAmbientLight.color = color;
		growlAudioScript.transform.position = player.Head.transform.position;
		growlAudioScript.FadeIn(heartbeatClip, 1f, 1f, loop: true);
		yield return Yield.WaitSeconds(1f);
		player.screenFX.Fade(UnityEngine.Color.clear, 1f);
		base.transform.parent = originalParent;
		UnityEngine.Debug.Log("REVERTING PAZ PARENTING");
		yield return Yield.WaitSeconds(2f);
		yield return Yield.WaitSeconds(0.25f);
		yield return Yield.WaitSeconds(3f);
		LeanTween.move(player.gameObject, playerFloatTarget.transform, 45f);
		growlAudioScript.FadeOut(10f);
		player.playerAudio.SetMixerChannel(AudioScript.MixerChannel.vo);
		player.playerAudio.Play(pazVOFinaleClips[5]);
		HUD.Instance.PlaySubtitles(pazVOFinaleClips[5].name, hasPriority: true);
		Vector3 vector = player.Head.transform.position + player.Head.transform.forward * 2.5f;
		fallingRockSetpiece.transform.position = new Vector3(vector.x, fallingRockSetpiece.transform.position.y, vector.z);
		fallingRocksEndingParticle.Play(withChildren: true);
		fallingRockSetpiece.SetActive(value: true);
		yield return Yield.WaitSeconds(25f);
		tombScene.musicStem03.SetMixerChannel(AudioScript.MixerChannel.vo);
		tombScene.musicStem03.FadeIn(tombScene.musicBuildHighwire, 0.9f, 10f, loop: true);
		yield return Yield.WaitSeconds(20f);
		float finalCrossTuneTime = 5f;
		tuneCross.extraParticlesTune = lightCrackTuneParticles;
		tuneCross.SetWindRadius(11f);
		tuneCross.StartTuning(finalCrossLight, finalCrossLightTargets, finalCrossTuneTime, float.MaxValue, isSlowMo: false, 0.6f);
		tuneCross.TheLight(isEnabled: true);
		tuneCross.PauseCrossTuning = false;
		tuneCross.PauseHapticFeedback = false;
		StartCoroutine(FatherBellHint());
		while (tuneCross.HoldTime < finalCrossTuneTime * 0.5f)
		{
			yield return Yield.EndOfFrame;
		}
		GameController.instance.audioController.SnapAllOpen(finalCrossTuneTime * 0.5f);
		while (!tuneCross.tuneSuccess)
		{
			yield return Yield.EndOfFrame;
		}
		tuneCross.StartLightTarget(finalCrossLightObject);
		finalCrossLightObject.gameObject.SetLayer(11);
		tombScene.arenaAmbientLight.intensity = 0f;
		UnityEngine.Color color2 = default(UnityEngine.Color);
		color2.r = 1f;
		color2.g = 0.8980392f;
		color2.b = 0.772549f;
		tombScene.arenaAmbientLight.color = color2;
		while (!tuneCross.hitSuccess)
		{
			yield return Yield.EndOfFrame;
		}
		tuneCross.ShootBeam(withAudio: false, disableLight: false, keepLockedToHand: true, instant: true);
		tuneCross.FadeLightTarget();
		ceilingParticleBurst.Play();
		fallingRocksEndingParticle.Stop();
		fallingRockSetpiece.SetActive(value: false);
		tombScene.arenaSpotLight.cookie = tombScene.arenaSpotLightCookieLarge;
		tombScene.lightCrackMat.mainTexture = tombScene.arenaSpotLightCrackLarge;
		tombScene.arenaSpotLight.gameObject.SetActive(value: true);
		tombScene.musicStem02.Play(angelSfx);
		isFishEyeBreathing = false;
		yield return Yield.WaitSeconds(1f);
		tuneCross.tuneSuccess = false;
		tuneCross.hitSuccess = false;
		tuneCross.extraParticlesTune = null;
		tuneCross.ResetWindRadius();
		tombScene.musicStem01.FadeOut(1f);
		tombScene.musicStem03.FadeOut(1f);
		tombScene.fallingRockLoopAudio.FadeOut(2f);
		yield return Yield.WaitSeconds(0.8f);
		GameController.instance.audioController.persistentMusicPlayer.Play(tombScene.musicPlayoutFinale);
		pazuzuMesh.SetActive(value: true);
		for (int j = 0; j < eyeMesh.Length; j++)
		{
			eyeMesh[j].SetActive(value: true);
		}
		base.gameObject.transform.localPosition = Vector3.zero;
		base.gameObject.transform.eulerAngles = Vector3.zero;
		audioScriptPaz1.transform.position = pazuzuFloatingAudio.position;
		audioScriptPaz1.transform.SetParent(pazuzuFloatingAudio.transform);
		audioScriptPaz1.Play(pazVOFinaleClips[6]);
		tombScene.SlowTime(0.1f);
		tombScene.musicStem02.m_AudioSource.pitch = 1f;
		StartCoroutine(PazuzuDissolve(0.21f, 0.09f, pazFadeMat, dissolveOut: false));
		GameController.instance.audioController.persistentMusicPlayer.m_AudioSource.pitch = 1f;
		yield return Yield.EndOfFrame;
		pazuzuAnimator.speed = animationSpeedStandard;
		pazuzuAnimator.SetTrigger("Emerge");
		yield return Yield.EndOfFrame;
		canDeathBeSeen = true;
		player.transform.parent = playerParent;
		tombScene.pazuzuEmergeTrigger.SetActive(value: true);
		yield return Yield.WaitSeconds(0.4f);
		float superSlowDuration = 1.9f;
		float superSlowCounter = 0f;
		while (!hasSeenDeath && !(superSlowCounter >= superSlowDuration) && !pazDeathLand)
		{
			superSlowCounter += Time.deltaTime;
			yield return Yield.EndOfFrame;
		}
		canDeathBeSeen = false;
		tombScene.SlowTime(0.3f);
		GameController.instance.audioController.persistentMusicPlayer.m_AudioSource.pitch = 1f;
		while (superSlowCounter < superSlowDuration && !pazDeathLand)
		{
			superSlowCounter += Time.deltaTime;
			yield return Yield.EndOfFrame;
		}
		pazLandingParticle.Play();
		yield return Yield.WaitSeconds(0.33f);
		player.screenFX.Fade(UnityEngine.Color.black, 0.1f);
		player.screenFX.StopCameraShake();
		yield return Yield.WaitSeconds(0.1f);
		player.screenFX.Fade(UnityEngine.Color.clear, 0.1f);
		yield return Yield.WaitSeconds(3f);
		interactableCross.LockToHand(isLocked: false);
		interactableCross.respawnTimer = 0.5f;
		if (player.LeftHand.CurrentlyInteracting == interactableCross)
		{
			player.LeftHand.ForceDropItem();
		}
		else if (player.RightHand.CurrentlyInteracting == interactableCross)
		{
			player.RightHand.ForceDropItem();
		}
		yield return Yield.WaitSeconds(3f);
		interactableCross.respawnTimer = 5f;
		player.transform.parent = null;
		player.movement.EnableMovement();
		navMeshBlockFull.SetActive(value: false);
	}

	private IEnumerator PazuzuDissolve(float time, float delay, Material mat, bool dissolveOut, float dissolveTo = 1f)
	{
		if (!dissolveOut && dissolveTo == 1f)
		{
			dissolveTo = 0f;
		}
		for (int i = 0; i < pazRenderer.Length; i++)
		{
			pazRenderer[i].sharedMaterial = mat;
			pazRenderer[i].sharedMaterial.SetFloat("_Dissolve", dissolveOut ? 0f : 1f);
		}
		yield return Yield.WaitSeconds(delay);
		for (float counter = 0f; counter < time; counter += Time.deltaTime)
		{
			for (int j = 0; j < pazRenderer.Length; j++)
			{
				pazRenderer[j].sharedMaterial.SetFloat("_Dissolve", dissolveOut ? (dissolveTo * counter / time) : (1f - dissolveTo - counter / time));
			}
			yield return Yield.EndOfFrame;
		}
	}

	private IEnumerator FatherBellHint()
	{
		int i = 0;
		while (!tuneCross.tuneSuccess)
		{
			float counter = 0f;
			float duration = ((i == 0) ? 16 : 8);
			while (counter < duration)
			{
				if (tuneCross.tuneSuccess)
				{
					exorcisedCrackInTime = true;
					tombScene.musicStem01.FadeOut(0.05f);
					break;
				}
				counter += Time.deltaTime;
				yield return Yield.EndOfFrame;
			}
			if (i < fatherBellHintClips.Length)
			{
				tombScene.musicStem01.SetMixerChannel(AudioScript.MixerChannel.vo);
				tombScene.musicStem01.Play(fatherBellHintClips[i]);
				HUD.Instance.PlaySubtitles(fatherBellHintClips[i].name, hasPriority: true);
				i++;
			}
		}
	}

	private IEnumerator FishEyeBreathingRoutine(FishEyeBreathing values)
	{
		isFishEyeBreathing = true;
		while (isFishEyeBreathing)
		{
			player.fishEyeFX.FadeFishEye(enabled: true, values.time, values.xStrength, values.yStrength, Fisheye.FadeEase.EASE_IN_CUBIC);
			yield return Yield.WaitSeconds(values.time);
			player.fishEyeFX.FadeFishEye(enabled: false, values.time, values.xStrength, values.yStrength, Fisheye.FadeEase.EASE_OUT_CUBIC);
			yield return Yield.WaitSeconds(values.time);
		}
	}

	private IEnumerator StopPlayerHitParticles(float wait)
	{
		yield return Yield.WaitSeconds(wait);
		playerHitParticles.Stop();
	}

	public void AnimationTriggerParticle(int attackNumber)
	{
		switch (attackNumber)
		{
		case 1:
			pazAttackParticle01.Play();
			break;
		case 2:
			pazAttackParticle02.Play();
			break;
		}
	}

	private void OnDisable()
	{
		for (int i = 0; i < pazRenderer.Length; i++)
		{
			pazRenderer[i].sharedMaterial = pazStandardMat;
		}
	}

	public void OnCanHitWithCross()
	{
		canHitPazWithCross = true;
	}

	public void PauseCrossTuning()
	{
		tuneCross.PauseCrossTuning = true;
		tuneCross.PauseHapticFeedback = true;
		tuneCross.PauseCrossLightAndAudio = true;
	}

	public void UnPauseCrossTuning()
	{
		tuneCross.PauseCrossTuning = false;
		tuneCross.PauseHapticFeedback = false;
		tuneCross.PauseCrossLightAndAudio = false;
	}

	public void FollowPlayer()
	{
		updatePosition = true;
		Collider[] componentsInChildren = pazuzuMesh.GetComponentsInChildren<Collider>();
		Collider[] components = interactableCross.GetComponents<Collider>();
		Collider[] array = componentsInChildren;
		foreach (Collider collider in array)
		{
			Collider[] array2 = components;
			foreach (Collider collider2 in array2)
			{
				Physics.IgnoreCollision(collider, collider2, ignore: true);
			}
		}
	}

	public void UnfollowPlayer()
	{
		updatePosition = false;
	}

	public void PazBurnParticle()
	{
		if (!pazPersonalBurnOneShotParticle.gameObject.activeInHierarchy)
		{
			pazPersonalBurnOneShotParticle.gameObject.SetActive(value: true);
		}
		pazPersonalBurnOneShotParticle.Play();
	}

	public void OnLandDeadEvent()
	{
		StartCoroutine(PazuzuDissolve(1f, 0f, pazBurnMat, dissolveOut: true));
		pazDeathLand = true;
	}

	public void BurnPazOut()
	{
		StartCoroutine(PazuzuDissolve(0.83f, 0f, pazBurnMat, dissolveOut: true, 0.3f));
		pazPersonalLightBurn.Play();
		AudioScript obj = AudioScriptContainer.Instance.audioScripts[3];
		obj.transform.parent = pazuzuMesh.transform;
		obj.transform.localPosition = Vector3.zero;
		obj.Play(pazBurnClip);
	}

	public void SlowTime(float time)
	{
		tombScene.SlowTime(time);
	}

	public void PlayPreAttackParticles()
	{
		StartCoroutine(PreAttackParticlesRoutine());
	}

	private IEnumerator PreAttackParticlesRoutine()
	{
		if (tuneCross.IsTuningOnTarget)
		{
			UnityEngine.Debug.Log("Hit from cross...");
			pazPreAttackParticles.Play();
			AudioScript obj = AudioScriptContainer.Instance.audioScripts[2];
			obj.transform.position = pazuzuMesh.transform.position;
			obj.PlayOne(pazHissSmall);
			for (int i = 0; i < pazRenderer.Length; i++)
			{
				pazRenderer[i].sharedMaterial = pazBurnFromCrossMat;
				pazRenderer[i].sharedMaterial.SetFloat("_Amount", 0.2f);
			}
			yield return Yield.WaitSeconds(1.5f);
			for (int j = 0; j < pazRenderer.Length; j++)
			{
				pazRenderer[j].sharedMaterial = pazStandardMat;
			}
		}
	}
}
public class Pendulum : MonoBehaviour
{
	private bool swinging;

	private bool swingLeftNext;

	private Vector3 vec = new Vector3(10f, 0f, 0f);

	private bool stopSwinging;

	private void Update()
	{
		if (!swinging && !stopSwinging)
		{
			if (swingLeftNext)
			{
				StartCoroutine(SwingLeft());
			}
			else
			{
				StartCoroutine(SwingRight());
			}
		}
	}

	private IEnumerator SwingLeft()
	{
		swinging = true;
		LeanTween.rotate(base.gameObject, base.transform.eulerAngles - vec, 1f).setEaseInOutQuad();
		yield return Yield.WaitSeconds(1f);
		swingLeftNext = false;
		swinging = false;
	}

	private IEnumerator SwingRight()
	{
		swinging = true;
		LeanTween.rotate(base.gameObject, base.transform.eulerAngles + vec, 1f).setEaseInOutQuad();
		yield return Yield.WaitSeconds(1f);
		swingLeftNext = true;
		swinging = false;
	}

	public void Stop()
	{
		stopSwinging = true;
		StartCoroutine(StopSwinging());
	}

	private IEnumerator StopSwinging()
	{
		yield return Yield.WaitSeconds(1f);
		LeanTween.rotateLocal(base.gameObject, new Vector3(0f, 0f, 0f), 0.5f);
	}

	private void OnDisable()
	{
		base.gameObject.transform.localEulerAngles = new Vector3(-5f, 0f, 0f);
		swinging = false;
		swingLeftNext = false;
		stopSwinging = false;
	}
}
public static class GameObjectExtension
{
	public static void SetLayer(this GameObject parent, int layer, bool includeChildren = true)
	{
		parent.layer = layer;
		if (includeChildren)
		{
			Transform[] componentsInChildren = parent.transform.GetComponentsInChildren<Transform>(includeInactive: true);
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				componentsInChildren[i].gameObject.layer = layer;
			}
		}
	}
}
public class PhoneButtons : MonoBehaviour
{
	[SerializeField]
	private AudioScript phoneAudio;

	[SerializeField]
	private AudioClip lockClip;

	[SerializeField]
	private AudioClip unlockClip;

	[SerializeField]
	private AudioClip clickClip;

	[Space]
	public GameObject phoneUI;

	public GameObject carrierPanel;

	public GameObject homePanel;

	public GameObject gamePanel;

	public GameObject movementPanel;

	public GameObject languagePanel;

	public GameObject interactionsPanel;

	public GameObject interfacePanel;

	public GameObject overlay;

	public GameObject lockPanel;

	public GameObject background;

	public GameObject screenModel;

	public GameObject hintsPanel;

	public GameObject callsPanel;

	public GameObject messagesPanel;

	[Space]
	public Text audioText;

	public TextMeshProUGUI buttonHintsText;

	public TextMeshProUGUI crouchText;

	public TextMeshProUGUI freeMoveSpeedText;

	public TextMeshProUGUI freeRotationSpeedText;

	public TextMeshProUGUI gripText;

	public TextMeshProUGUI positionGuideText;

	public TextMeshProUGUI warningUIText;

	public TextMeshProUGUI primaryHandText;

	public TextMeshProUGUI rotationAmountText;

	public TextMeshProUGUI rotationFadeText;

	public TextMeshProUGUI subtitlesText;

	public TextMeshProUGUI interactButtonText;

	public TextMeshProUGUI locomotionButtonText;

	private int audioIndex;

	private int buttonHintsIndex;

	private int crouchIndex;

	private int freeMoveSpeedIndex;

	private int freeRotationSpeedIndex;

	private int gripIndex = 1;

	private int positionGuideIndex;

	private int primaryHandIndex;

	private int rotationAmountIndex;

	private int rotationFadeIndex;

	private int subtitlesIndex;

	private int movementTypeIndex = 1;

	private int interactIndex;

	private int warningUIIndex;

	public Button confirmButton;

	public Button cancelButton;

	public GameObject[] freeMoveContent;

	public GameObject[] rotationAmountOptions;

	public GameObject[] rotationFadeOptions;

	public UnityEngine.UI.Image signalImage;

	public Sprite SignalZero;

	public Sprite SignalOne;

	public Sprite SignalTwo;

	public Sprite SignalThree;

	[SerializeField]
	private bool hasSignal = true;

	private float signalTimer;

	private NVRPlayer player;

	[SerializeField]
	private Collider pointCollider;

	private bool showingHints;

	private bool firstOpen = true;

	private void Start()
	{
		player = GameController.instance.player;
		phoneUI.SetActive(value: false);
		TurnOff(playSound: false);
		StartCoroutine(StartRoutine());
	}

	private IEnumerator StartRoutine()
	{
		while (!SaveManager.instance.savedDataLoaded)
		{
			yield return Yield.WaitSeconds(1f);
		}
		PreferencesLoaded();
	}

	private void PreferencesLoaded()
	{
		PullPreferences();
		ApplyPreferences(setTranslation: true);
	}

	private void Update()
	{
		if (!hasSignal)
		{
			return;
		}
		if (signalTimer > 0f)
		{
			signalTimer -= Time.deltaTime;
			return;
		}
		signalTimer = UnityEngine.Random.Range(1, 11);
		switch (UnityEngine.Random.Range(1, 4))
		{
		case 1:
			signalImage.sprite = SignalOne;
			break;
		case 2:
			signalImage.sprite = SignalTwo;
			break;
		case 3:
			signalImage.sprite = SignalThree;
			break;
		default:
			signalImage.sprite = SignalThree;
			break;
		}
	}

	public void TurnOn()
	{
		if (firstOpen)
		{
			PullPreferences();
			ApplyPreferences(setTranslation: true);
			firstOpen = false;
		}
		base.gameObject.SetLayer(LayerMask.NameToLayer("PointerInteractableTrigger"));
		if (GameController.instance.GetCurrentLevel() == SCENES.ONBOARDING)
		{
			phoneUI.SetActive(value: true);
		}
		lockPanel.SetActive(value: false);
		screenModel.SetActive(value: false);
		homePanel.SetActive(value: true);
		background.SetActive(value: true);
		carrierPanel.SetActive(value: true);
		pointCollider.enabled = true;
		phoneAudio.PlayOne(unlockClip);
		if ((GameController.instance.GetCurrentScene() == "PolicePrecinct" || GameController.instance.GetCurrentScene() == "Onboarding") && !hasSignal)
		{
			signalImage.sprite = SignalThree;
			hasSignal = true;
			signalTimer = UnityEngine.Random.Range(1, 10);
		}
		else if (GameController.instance.GetCurrentScene() != "PolicePrecinct" && GameController.instance.GetCurrentScene() != "Onboarding" && hasSignal)
		{
			signalImage.sprite = SignalZero;
			hasSignal = false;
		}
	}

	public void TurnOff(bool playSound = true)
	{
		base.gameObject.SetLayer(LayerMask.NameToLayer("Ignore Raycast"));
		if (phoneUI.activeInHierarchy)
		{
			phoneUI.SetActive(value: false);
		}
		gamePanel.SetActive(value: false);
		movementPanel.SetActive(value: false);
		languagePanel.SetActive(value: false);
		interactionsPanel.SetActive(value: false);
		interfacePanel.SetActive(value: false);
		homePanel.SetActive(value: false);
		background.SetActive(value: false);
		carrierPanel.SetActive(value: false);
		hintsPanel.SetActive(value: false);
		callsPanel.SetActive(value: false);
		messagesPanel.SetActive(value: false);
		if (overlay.activeSelf)
		{
			confirmButton.onClick.RemoveAllListeners();
			overlay.SetActive(value: false);
		}
		pointCollider.enabled = false;
		screenModel.SetActive(value: true);
		lockPanel.SetActive(value: true);
		if (playSound)
		{
			phoneAudio.PlayOne(lockClip);
		}
	}

	public void reloadForReset()
	{
		PullPreferences();
		ApplyPreferences(setTranslation: false);
		player.movement.SetCrouch();
		player.movement.SetMoveSpeed();
		player.movement.SetRotationSpeed();
		player.LeftHand.ToggleInteractionStyle();
		player.RightHand.ToggleInteractionStyle();
		ControlsManager.instance.ChangeInteractButton();
		player.movement.SetShowUI();
		player.SwapPrimaryHand();
		player.movement.SetRotationMode();
		player.movement.SetRotationFade();
		player.movement.SetMovementType();
		player.playerAudio.FadeOut(3f);
		GameController.instance.audioController.persistentMusicPlayer.FadeOut(3f);
	}

	public void PullPreferences()
	{
		audioIndex = PreferenceManager.instance.GetInt(PlayerPreferences.AUDIO_LANGUAGE.ToString());
		buttonHintsIndex = PreferenceManager.instance.GetInt(PlayerPreferences.BUTTON_HINTS.ToString());
		crouchIndex = PreferenceManager.instance.GetInt(PlayerPreferences.CROUCH.ToString());
		freeMoveSpeedIndex = PreferenceManager.instance.GetInt(PlayerPreferences.FREE_MOVE_SPEED.ToString());
		freeRotationSpeedIndex = PreferenceManager.instance.GetInt(PlayerPreferences.FREE_ROTATION_SPEED.ToString());
		gripIndex = PreferenceManager.instance.GetInt(PlayerPreferences.GRIP.ToString());
		positionGuideIndex = PreferenceManager.instance.GetInt(PlayerPreferences.POSITION_GUIDE.ToString());
		primaryHandIndex = PreferenceManager.instance.GetInt(PlayerPreferences.PRIMARY_HAND.ToString());
		rotationAmountIndex = PreferenceManager.instance.GetInt(PlayerPreferences.ROTATION_AMOUNT.ToString());
		rotationFadeIndex = PreferenceManager.instance.GetInt(PlayerPreferences.ROTATION_FADE.ToString());
		subtitlesIndex = PreferenceManager.instance.GetInt(PlayerPreferences.GAME_LANGUAGE.ToString());
		movementTypeIndex = PreferenceManager.instance.GetInt(PlayerPreferences.MOVEMENT_TYPE.ToString());
		interactIndex = PreferenceManager.instance.GetInt(PlayerPreferences.INTERACT_BUTTON.ToString());
		warningUIIndex = PreferenceManager.instance.GetInt(PlayerPreferences.HIDE_WARNING_UI.ToString());
		SetSubtitleLanguage();
	}

	public void ApplyPreferences(bool setTranslation)
	{
		if (setTranslation)
		{
			subtitlesText.text = GetSubtitleOptionText((GameLanguage)subtitlesIndex);
			Text text = audioText;
			SceneTranslator translator = GameController.instance.translator;
			AudioLanguage audioLanguage = (AudioLanguage)audioIndex;
			text.text = translator.GetTextTranslation(audioLanguage.ToString(), isPhone: true);
			TextMeshProUGUI textMeshProUGUI = buttonHintsText;
			SceneTranslator translator2 = GameController.instance.translator;
			ButtonHints buttonHints = (ButtonHints)buttonHintsIndex;
			textMeshProUGUI.text = translator2.GetTextTranslation(buttonHints.ToString(), isPhone: true);
			TextMeshProUGUI textMeshProUGUI2 = crouchText;
			SceneTranslator translator3 = GameController.instance.translator;
			Crouch crouch = (Crouch)crouchIndex;
			textMeshProUGUI2.text = translator3.GetTextTranslation(crouch.ToString(), isPhone: true);
			TextMeshProUGUI textMeshProUGUI3 = freeMoveSpeedText;
			SceneTranslator translator4 = GameController.instance.translator;
			FreeMoveSpeed freeMoveSpeed = (FreeMoveSpeed)freeMoveSpeedIndex;
			textMeshProUGUI3.text = translator4.GetTextTranslation(freeMoveSpeed.ToString(), isPhone: true);
			TextMeshProUGUI textMeshProUGUI4 = freeRotationSpeedText;
			SceneTranslator translator5 = GameController.instance.translator;
			FreeRotationSpeed freeRotationSpeed = (FreeRotationSpeed)freeRotationSpeedIndex;
			textMeshProUGUI4.text = translator5.GetTextTranslation(freeRotationSpeed.ToString(), isPhone: true);
			TextMeshProUGUI textMeshProUGUI5 = gripText;
			SceneTranslator translator6 = GameController.instance.translator;
			Grip grip = (Grip)gripIndex;
			textMeshProUGUI5.text = translator6.GetTextTranslation(grip.ToString(), isPhone: true);
			TextMeshProUGUI textMeshProUGUI6 = positionGuideText;
			SceneTranslator translator7 = GameController.instance.translator;
			PositionGuide positionGuide = (PositionGuide)positionGuideIndex;
			textMeshProUGUI6.text = translator7.GetTextTranslation(positionGuide.ToString(), isPhone: true);
			TextMeshProUGUI textMeshProUGUI7 = primaryHandText;
			SceneTranslator translator8 = GameController.instance.translator;
			PrimaryHand primaryHand = (PrimaryHand)primaryHandIndex;
			textMeshProUGUI7.text = translator8.GetTextTranslation(primaryHand.ToString(), isPhone: true);
			TextMeshProUGUI textMeshProUGUI8 = rotationAmountText;
			SceneTranslator translator9 = GameController.instance.translator;
			RotationAmount rotationAmount = (RotationAmount)rotationAmountIndex;
			textMeshProUGUI8.text = translator9.GetTextTranslation(rotationAmount.ToString(), isPhone: true);
			TextMeshProUGUI textMeshProUGUI9 = rotationFadeText;
			SceneTranslator translator10 = GameController.instance.translator;
			RotationFade rotationFade = (RotationFade)rotationFadeIndex;
			textMeshProUGUI9.text = translator10.GetTextTranslation(rotationFade.ToString(), isPhone: true);
			TextMeshProUGUI textMeshProUGUI10 = interactButtonText;
			SceneTranslator translator11 = GameController.instance.translator;
			InteractButtons interactButtons = (InteractButtons)interactIndex;
			textMeshProUGUI10.text = translator11.GetTextTranslation(interactButtons.ToString(), isPhone: true);
			TextMeshProUGUI textMeshProUGUI11 = locomotionButtonText;
			SceneTranslator translator12 = GameController.instance.translator;
			MovementTypes movementTypes = (MovementTypes)movementTypeIndex;
			textMeshProUGUI11.text = translator12.GetTextTranslation(movementTypes.ToString(), isPhone: true);
		}
		else
		{
			Text text2 = audioText;
			AudioLanguage audioLanguage = (AudioLanguage)audioIndex;
			text2.text = audioLanguage.ToString();
			TextMeshProUGUI textMeshProUGUI12 = buttonHintsText;
			ButtonHints buttonHints = (ButtonHints)buttonHintsIndex;
			textMeshProUGUI12.text = buttonHints.ToString();
			TextMeshProUGUI textMeshProUGUI13 = crouchText;
			Crouch crouch = (Crouch)crouchIndex;
			textMeshProUGUI13.text = crouch.ToString();
			TextMeshProUGUI textMeshProUGUI14 = freeMoveSpeedText;
			FreeMoveSpeed freeMoveSpeed = (FreeMoveSpeed)freeMoveSpeedIndex;
			textMeshProUGUI14.text = freeMoveSpeed.ToString();
			TextMeshProUGUI textMeshProUGUI15 = freeRotationSpeedText;
			FreeRotationSpeed freeRotationSpeed = (FreeRotationSpeed)freeRotationSpeedIndex;
			textMeshProUGUI15.text = freeRotationSpeed.ToString();
			TextMeshProUGUI textMeshProUGUI16 = gripText;
			Grip grip = (Grip)gripIndex;
			textMeshProUGUI16.text = grip.ToString();
			TextMeshProUGUI textMeshProUGUI17 = positionGuideText;
			PositionGuide positionGuide = (PositionGuide)positionGuideIndex;
			textMeshProUGUI17.text = positionGuide.ToString();
			TextMeshProUGUI textMeshProUGUI18 = primaryHandText;
			PrimaryHand primaryHand = (PrimaryHand)primaryHandIndex;
			textMeshProUGUI18.text = primaryHand.ToString();
			TextMeshProUGUI textMeshProUGUI19 = rotationAmountText;
			RotationAmount rotationAmount = (RotationAmount)rotationAmountIndex;
			textMeshProUGUI19.text = rotationAmount.ToString();
			TextMeshProUGUI textMeshProUGUI20 = rotationFadeText;
			RotationFade rotationFade = (RotationFade)rotationFadeIndex;
			textMeshProUGUI20.text = rotationFade.ToString();
			TextMeshProUGUI textMeshProUGUI21 = subtitlesText;
			GameLanguage gameLanguage = (GameLanguage)subtitlesIndex;
			textMeshProUGUI21.text = gameLanguage.ToString();
			TextMeshProUGUI textMeshProUGUI22 = interactButtonText;
			InteractButtons interactButtons = (InteractButtons)interactIndex;
			textMeshProUGUI22.text = interactButtons.ToString();
			TextMeshProUGUI textMeshProUGUI23 = locomotionButtonText;
			MovementTypes movementTypes = (MovementTypes)movementTypeIndex;
			textMeshProUGUI23.text = movementTypes.ToString();
			UnityEngine.Debug.Log(locomotionButtonText.text);
		}
		if (movementTypeIndex == 0)
		{
			GameObject[] array = freeMoveContent;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].SetActive(value: false);
			}
		}
		else
		{
			GameObject[] array = freeMoveContent;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].SetActive(value: true);
			}
		}
		if (rotationAmountIndex == 4)
		{
			GameObject[] array = rotationAmountOptions;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].SetActive(value: true);
			}
		}
		else
		{
			GameObject[] array = rotationAmountOptions;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].SetActive(value: false);
			}
		}
		if (rotationAmountIndex == 0 || rotationAmountIndex == 4)
		{
			GameObject[] array = rotationFadeOptions;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].SetActive(value: false);
			}
		}
		else
		{
			GameObject[] array = rotationFadeOptions;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].SetActive(value: true);
			}
		}
	}

	public void ChangeScreen(GameObject nextScreen)
	{
		phoneAudio.PlayOne(clickClip);
		nextScreen.SetActive(value: true);
		homePanel.SetActive(value: false);
	}

	public void BackToHome()
	{
		phoneAudio.PlayOne(clickClip);
		gamePanel.SetActive(value: false);
		movementPanel.SetActive(value: false);
		languagePanel.SetActive(value: false);
		interactionsPanel.SetActive(value: false);
		interfacePanel.SetActive(value: false);
		hintsPanel.SetActive(value: false);
		callsPanel.SetActive(value: false);
		messagesPanel.SetActive(value: false);
		homePanel.SetActive(value: true);
	}

	public void AudioButton()
	{
		phoneAudio.PlayOne(clickClip);
		PlayerPreferences playerPreferences = PlayerPreferences.AUDIO_LANGUAGE;
		int length = Enum.GetValues(typeof(AudioLanguage)).Length;
		IncrementText(ref audioIndex, length);
		AudioLanguage option = (AudioLanguage)audioIndex;
		audioText.text = GameController.instance.translator.GetTextTranslation(option.ToString(), isPhone: true);
		WriteToPreference(playerPreferences.ToString(), (int)option);
	}

	public void ButtonHintsButton()
	{
		phoneAudio.PlayOne(clickClip);
		PlayerPreferences playerPreferences = PlayerPreferences.BUTTON_HINTS;
		int length = Enum.GetValues(typeof(ButtonHints)).Length;
		IncrementText(ref buttonHintsIndex, length);
		ButtonHints option = (ButtonHints)buttonHintsIndex;
		buttonHintsText.text = GameController.instance.translator.GetTextTranslation(option.ToString(), isPhone: true);
		WriteToPreference(playerPreferences.ToString(), (int)option);
	}

	public void ShowHintsButton()
	{
		if (!showingHints)
		{
			showingHints = true;
			phoneAudio.PlayOne(clickClip);
			GameController.instance.hintManager.ShowHints();
			StartCoroutine(HintDelay());
		}
	}

	private IEnumerator HintDelay()
	{
		yield return Yield.WaitSeconds(10.5f);
		showingHints = false;
	}

	public void CrouchButton()
	{
		phoneAudio.PlayOne(clickClip);
		PlayerPreferences playerPreferences = PlayerPreferences.CROUCH;
		int length = Enum.GetValues(typeof(Crouch)).Length;
		IncrementText(ref crouchIndex, length);
		Crouch option = (Crouch)crouchIndex;
		crouchText.text = GameController.instance.translator.GetTextTranslation(option.ToString(), isPhone: true);
		WriteToPreference(playerPreferences.ToString(), (int)option);
		player.movement.SetCrouch();
	}

	public void FreeMoveSpeedButton()
	{
		phoneAudio.PlayOne(clickClip);
		PlayerPreferences playerPreferences = PlayerPreferences.FREE_MOVE_SPEED;
		int length = Enum.GetValues(typeof(FreeMoveSpeed)).Length;
		IncrementText(ref freeMoveSpeedIndex, length);
		FreeMoveSpeed option = (FreeMoveSpeed)freeMoveSpeedIndex;
		freeMoveSpeedText.text = GameController.instance.translator.GetTextTranslation(option.ToString(), isPhone: true);
		WriteToPreference(playerPreferences.ToString(), (int)option);
		player.movement.SetMoveSpeed();
	}

	public void FreeRotationSpeedButton()
	{
		phoneAudio.PlayOne(clickClip);
		PlayerPreferences playerPreferences = PlayerPreferences.FREE_ROTATION_SPEED;
		int length = Enum.GetValues(typeof(FreeRotationSpeed)).Length;
		IncrementText(ref freeRotationSpeedIndex, length);
		FreeRotationSpeed option = (FreeRotationSpeed)freeRotationSpeedIndex;
		freeRotationSpeedText.text = GameController.instance.translator.GetTextTranslation(option.ToString(), isPhone: true);
		WriteToPreference(playerPreferences.ToString(), (int)option);
		player.movement.SetRotationSpeed();
	}

	public void GripButton()
	{
		phoneAudio.PlayOne(clickClip);
		PlayerPreferences playerPreferences = PlayerPreferences.GRIP;
		int length = Enum.GetValues(typeof(Grip)).Length;
		IncrementText(ref gripIndex, length);
		Grip option = (Grip)gripIndex;
		gripText.text = GameController.instance.translator.GetTextTranslation(option.ToString(), isPhone: true);
		WriteToPreference(playerPreferences.ToString(), (int)option);
		player.LeftHand.ToggleInteractionStyle();
		player.RightHand.ToggleInteractionStyle();
	}

	public void InteractButton()
	{
		phoneAudio.PlayOne(clickClip);
		PlayerPreferences playerPreferences = PlayerPreferences.INTERACT_BUTTON;
		int length = Enum.GetValues(typeof(InteractButtons)).Length;
		IncrementText(ref interactIndex, length);
		InteractButtons option = (InteractButtons)interactIndex;
		interactButtonText.text = GameController.instance.translator.GetTextTranslation(option.ToString(), isPhone: true);
		WriteToPreference(playerPreferences.ToString(), (int)option);
		ControlsManager.instance.ChangeInteractButton();
	}

	public void PositionGuideButton()
	{
		phoneAudio.PlayOne(clickClip);
		PlayerPreferences playerPreferences = PlayerPreferences.POSITION_GUIDE;
		int length = Enum.GetValues(typeof(PositionGuide)).Length;
		IncrementText(ref positionGuideIndex, length);
		PositionGuide option = (PositionGuide)positionGuideIndex;
		positionGuideText.text = GameController.instance.translator.GetTextTranslation(option.ToString(), isPhone: true);
		WriteToPreference(playerPreferences.ToString(), (int)option);
		player.movement.SetShowUI();
	}

	public void WarningUIButton()
	{
		phoneAudio.PlayOne(clickClip);
		PlayerPreferences playerPreferences = PlayerPreferences.HIDE_WARNING_UI;
		int length = Enum.GetValues(typeof(WarningUI)).Length;
		IncrementText(ref warningUIIndex, length);
		WarningUI option = (WarningUI)warningUIIndex;
		WriteToPreference(playerPreferences.ToString(), (int)option);
		player.movement.HideWarningUI();
	}

	public void PrimaryHandButton()
	{
		phoneAudio.PlayOne(clickClip);
		PlayerPreferences playerPreferences = PlayerPreferences.PRIMARY_HAND;
		int length = Enum.GetValues(typeof(PrimaryHand)).Length;
		IncrementText(ref primaryHandIndex, length);
		PrimaryHand option = (PrimaryHand)primaryHandIndex;
		primaryHandText.text = GameController.instance.translator.GetTextTranslation(option.ToString(), isPhone: true);
		WriteToPreference(playerPreferences.ToString(), (int)option);
		player.SwapPrimaryHand();
	}

	public void RotationAmountButton()
	{
		phoneAudio.PlayOne(clickClip);
		PlayerPreferences playerPreferences = PlayerPreferences.ROTATION_AMOUNT;
		int length = Enum.GetValues(typeof(RotationAmount)).Length;
		IncrementText(ref rotationAmountIndex, length);
		RotationAmount rotationAmount = (RotationAmount)rotationAmountIndex;
		rotationAmountText.text = GameController.instance.translator.GetTextTranslation(rotationAmount.ToString(), isPhone: true);
		if (rotationAmount == RotationAmount.FREE)
		{
			GameObject[] array = rotationAmountOptions;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].SetActive(value: true);
			}
			array = rotationFadeOptions;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].SetActive(value: false);
			}
		}
		else
		{
			if (rotationAmountOptions[0].activeSelf)
			{
				GameObject[] array = rotationAmountOptions;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].SetActive(value: false);
				}
			}
			if (rotationAmount == RotationAmount.OFF)
			{
				GameObject[] array = rotationFadeOptions;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].SetActive(value: false);
				}
			}
			else
			{
				GameObject[] array = rotationFadeOptions;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].SetActive(value: true);
				}
			}
		}
		WriteToPreference(playerPreferences.ToString(), (int)rotationAmount);
		player.movement.SetRotationMode();
	}

	public void RotationFadeButton()
	{
		phoneAudio.PlayOne(clickClip);
		PlayerPreferences playerPreferences = PlayerPreferences.ROTATION_FADE;
		int length = Enum.GetValues(typeof(RotationFade)).Length;
		IncrementText(ref rotationFadeIndex, length);
		RotationFade option = (RotationFade)rotationFadeIndex;
		rotationFadeText.text = GameController.instance.translator.GetTextTranslation(option.ToString(), isPhone: true);
		WriteToPreference(playerPreferences.ToString(), (int)option);
		player.movement.SetRotationFade();
	}

	public void SubtitlesButton()
	{
		phoneAudio.PlayOne(clickClip);
		PlayerPreferences playerPreferences = PlayerPreferences.GAME_LANGUAGE;
		int length = Enum.GetValues(typeof(GameLanguage)).Length;
		IncrementText(ref subtitlesIndex, length);
		GameLanguage gameLanguage = (GameLanguage)subtitlesIndex;
		subtitlesText.text = GetSubtitleOptionText(gameLanguage);
		WriteToPreference(playerPreferences.ToString(), (int)gameLanguage);
		SetSubtitleLanguage();
	}

	private string GetSubtitleOptionText(GameLanguage lan)
	{
		return lan switch
		{
			GameLanguage.EN => "ENGLISH", 
			GameLanguage.ES => "ESPAÑOL", 
			GameLanguage.SC => "中文", 
			_ => "ENGLISH", 
		};
	}

	private void SetSubtitleLanguage()
	{
		GameLanguage gameLanguage = (GameLanguage)subtitlesIndex;
		GameController.instance.translator.Language = gameLanguage;
		switch (gameLanguage)
		{
		case GameLanguage.EN:
			HUD.Instance.SetSubsLanguage(SubtitleLanguage.OFF);
			break;
		case GameLanguage.ES:
			HUD.Instance.SetSubsLanguage(SubtitleLanguage.ES);
			break;
		case GameLanguage.SC:
			HUD.Instance.SetSubsLanguage(SubtitleLanguage.SC);
			break;
		}
		ApplyPreferences(setTranslation: true);
	}

	public void SwitchMovementTypeButton()
	{
		phoneAudio.PlayOne(clickClip);
		PlayerPreferences playerPreferences = PlayerPreferences.MOVEMENT_TYPE;
		int length = Enum.GetValues(typeof(MovementTypes)).Length;
		IncrementText(ref movementTypeIndex, length);
		MovementTypes option = (MovementTypes)movementTypeIndex;
		locomotionButtonText.text = GameController.instance.translator.GetTextTranslation(option.ToString(), isPhone: true);
		if (movementTypeIndex == 0)
		{
			GameObject[] array = freeMoveContent;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].SetActive(value: false);
			}
		}
		else
		{
			GameObject[] array = freeMoveContent;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].SetActive(value: true);
			}
		}
		WriteToPreference(playerPreferences.ToString(), (int)option);
		player.movement.SetMovementType();
	}

	public void IncrementText(ref int index, int maxIndex)
	{
		if (index == maxIndex - 1)
		{
			index = 0;
		}
		else
		{
			index++;
		}
	}

	public void WriteToPreference(string pref, int option)
	{
		PreferenceManager.instance.SetInt(pref, option);
	}

	public void CalibrateButton()
	{
		OpenOverlay();
		confirmButton.onClick.AddListener(CalibrateFunction);
	}

	public void CalibrateFunction()
	{
		UnityEngine.Debug.Log("Write Calibrate Function");
	}

	public void ExitGameButton()
	{
		OpenOverlay();
		confirmButton.onClick.AddListener(ExitGameFunction);
	}

	public void ExitGameFunction()
	{
		CloseOverlay();
		StartCoroutine(ExitGameRoutine());
	}

	private IEnumerator ExitGameRoutine()
	{
		player.Head.GetComponentInChildren<ScreenFX>().Fade(UnityEngine.Color.black, 3f);
		GameController.instance.audioController.SnapMute(3f);
		yield return Yield.WaitSeconds(2f);
		SaveManager.instance.Save(SaveManager.instance.currentSavedGameSlot);
		yield return Yield.WaitSeconds(1f);
		Application.Quit();
	}

	public void ResetProgressButton()
	{
		OpenOverlay();
		confirmButton.onClick.AddListener(ResetProgressFunction);
	}

	public void ResetProgressFunction()
	{
		StartCoroutine(ResetProgressRoutine());
		GameController.instance.GoToSpecificScene(SCENES.PRECINCT);
	}

	private IEnumerator ResetProgressRoutine()
	{
		CloseOverlay();
		EventManager.TriggerEvent(EventManager.AvailableEvents.ResetProgress.ToString());
		yield return Yield.WaitSeconds(1.5f);
		GameController.instance.boundDetection.SwitchOffOOB();
		SaveManager.instance.ResetProgress();
	}

	public void ExitProfileButton()
	{
		OpenOverlay();
		confirmButton.onClick.AddListener(ExitProfileFunction);
	}

	public void ExitProfileFunction()
	{
		UnityEngine.Debug.Log("Write Exit Profile Function");
	}

	public void ExitToPrecinctButton()
	{
		OpenOverlay();
		confirmButton.onClick.AddListener(ExitToPrecinctFunction);
	}

	public void ExitToPrecinctFunction()
	{
		CloseOverlay();
		ExitToPrecinctRoutine();
	}

	private void ExitToPrecinctRoutine()
	{
		EventManager.TriggerEvent(EventManager.AvailableEvents.ExitLevelToPrecint.ToString());
		player.HandMenu.CloseMenu();
		player.playerAudio.FadeOut(3f);
		GameController.instance.audioController.persistentMusicPlayer.FadeOut(3f);
	}

	public void RestartLevelButton()
	{
		OpenOverlay();
		confirmButton.onClick.AddListener(RestartLevelFunction);
	}

	public void RestartLevelFunction()
	{
		CloseOverlay();
		GameController.instance.boundDetection.SwitchOffOOB();
		EventManager.TriggerEvent(EventManager.AvailableEvents.RestartScene.ToString());
		GameController.instance.ResetLevel();
	}

	private IEnumerator RestartLevelRoutine()
	{
		yield return Yield.WaitSeconds(1f);
		GameController.instance.ResetLevel();
	}

	public void OpenOverlay()
	{
		phoneAudio.PlayOne(clickClip);
		overlay.SetActive(value: true);
		gamePanel.SetActive(value: false);
	}

	public void CloseOverlay()
	{
		phoneAudio.PlayOne(clickClip);
		confirmButton.onClick.RemoveAllListeners();
		gamePanel.SetActive(value: true);
		overlay.SetActive(value: false);
	}

	private void OnDisable()
	{
		showingHints = false;
	}
}
public class PhoneClock : MonoBehaviour
{
	private TextMeshProUGUI clockString;

	private void Start()
	{
		clockString = GetComponent<TextMeshProUGUI>();
	}

	private void Update()
	{
		DateTime now = DateTime.Now;
		string text = now.Hour.ToString().PadLeft(2, '0');
		string text2 = now.Minute.ToString().PadLeft(2, '0');
		clockString.text = text + ":" + text2;
	}
}
public class PhoneItem : MonoBehaviour
{
	public HandPointer pointerScript;

	private Animator anim;

	private void OnEnable()
	{
		pointerScript.enabled = true;
	}

	private void OnDisable()
	{
		if ((bool)pointerScript.anim)
		{
			anim = pointerScript.anim;
		}
		pointerScript.enabled = false;
		if (anim != null)
		{
			anim.ResetTrigger("Point");
			anim.SetTrigger("Idle");
		}
	}

	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class Piano : MonoBehaviour
{
	[Serializable]
	public struct Note
	{
		public AudioClip note;

		public GameObject[] keys;
	}

	[SerializeField]
	private AudioScript audio;

	[SerializeField]
	private Note[] notes;

	[SerializeField]
	private int notesNeededForAchievement = 8;

	[SerializeField]
	private int[] song;

	private int index;

	private int notesPlayed;

	private bool notePlaying;

	private bool achievementUnlocked;

	[SerializeField]
	private AudioClip hitClip;

	private IEnumerator PlayNextNote()
	{
		notePlaying = true;
		audio.PlayOne(notes[song[index]].note, 0.5f);
		float length = notes[song[index]].note.length;
		GameObject[] keys = notes[song[index]].keys;
		for (int i = 0; i < keys.Length; i++)
		{
			_ = keys[i];
			notesPlayed++;
		}
		yield return Yield.WaitSeconds(length * 0.6f);
		keys = notes[song[index]].keys;
		for (int i = 0; i < keys.Length; i++)
		{
			_ = keys[i];
		}
		index = (index + 1) % song.Length;
		if (!achievementUnlocked)
		{
			UnityEngine.Debug.Log("Notes played : " + notesPlayed);
			if (notesPlayed >= notesNeededForAchievement)
			{
				achievementUnlocked = true;
				GameController.instance.achievementManager.UnlockAchievement(AchievementID.MIKE_WHO);
			}
		}
		notePlaying = false;
	}

	private void OnTriggerEnter(Collider other)
	{
		if (!(other.gameObject.name != "SightCollider") || !(other.gameObject.tag != "TriggerCollider"))
		{
			return;
		}
		if (notePlaying)
		{
			GameObject[] keys = notes[song[index]].keys;
			for (int i = 0; i < keys.Length; i++)
			{
				_ = keys[i];
			}
			notePlaying = false;
			StopAllCoroutines();
			index = (index + 1) % song.Length;
		}
		StartCoroutine(PlayNextNote());
	}

	public void PianoHit()
	{
		if (!notePlaying)
		{
			audio.Play(hitClip);
		}
	}
}
public class PigHeadCollider : MonoBehaviour
{
	[SerializeField]
	private NVRHand rightHand;

	[SerializeField]
	private NVRHand leftHand;

	private void Start()
	{
		StartCoroutine(startRoutine());
	}

	private IEnumerator startRoutine()
	{
		while (GameController.instance.player == null)
		{
			yield return Yield.WaitSeconds(0.5f);
		}
		rightHand = GameController.instance.player.RightHand;
		leftHand = GameController.instance.player.LeftHand;
	}

	private void Update()
	{
	}

	private void OnTriggerEnter(Collider other)
	{
		if (!(rightHand != null) || !(leftHand != null) || other.gameObject.transform.parent == null || other.gameObject.transform.parent.transform.parent == null)
		{
			return;
		}
		if (other.gameObject.transform.parent.transform.parent.gameObject == rightHand.gameObject)
		{
			if (rightHand.fist && rightHand.GetVelocityEstimation().magnitude > 0.6f)
			{
				GameController.instance.achievementManager.UnlockAchievement(AchievementID.ROCKY);
			}
		}
		else if (other.gameObject.transform.parent.transform.parent.gameObject == leftHand.gameObject && leftHand.fist && leftHand.GetVelocityEstimation().magnitude > 0.6f)
		{
			GameController.instance.achievementManager.UnlockAchievement(AchievementID.ROCKY);
		}
	}
}
public class PlayerLight : MonoBehaviour
{
	private NVRPlayer player;

	public Vector3 target;

	private bool useRay;

	[SerializeField]
	private AudioScript lightAudio;

	[SerializeField]
	private AudioClip clickOnClip;

	[SerializeField]
	private Light spotLight;

	[SerializeField]
	private Texture lightCookie;

	[HideInInspector]
	public bool shouldLightBeOn;

	private float defaultLightRange;

	private float defaultLightIntensity = 0.1f;

	private float defaultSpotAngle;

	private Color32 defaultLightColour;

	private void Start()
	{
		player = GameController.instance.player;
		defaultLightRange = spotLight.range;
		defaultLightColour = spotLight.color;
		defaultSpotAngle = spotLight.spotAngle;
	}

	private void Update()
	{
		if (GameController.instance.GetCurrentLevel() != SCENES.CHAPEL)
		{
			spotLight.intensity = defaultLightIntensity;
		}
		else
		{
			spotLight.intensity = 1f;
		}
		if (useRay)
		{
			if (Physics.Raycast(player.Head.transform.position, player.Head.transform.forward, out var hitInfo, 1f))
			{
				target = Vector3.Lerp(target, hitInfo.point, Time.deltaTime * 3f);
			}
			else
			{
				target = Vector3.Lerp(target, player.Head.transform.position + player.Head.transform.forward + player.Head.transform.up * -0.35f, Time.deltaTime * 10f);
			}
		}
		else
		{
			target = Vector3.Lerp(target, player.Head.transform.position + player.Head.transform.forward + player.Head.transform.up * -0.35f, Time.deltaTime * 10f);
		}
		base.transform.position = player.Head.transform.position + player.Head.transform.forward * 0.1f;
		Vector3 eulerAngles = base.transform.eulerAngles;
		base.transform.LookAt(target);
		base.transform.rotation = Quaternion.Lerp(Quaternion.Euler(eulerAngles), Quaternion.Euler(base.transform.eulerAngles), Time.deltaTime * 10f);
	}

	public void SetRange(float range)
	{
		spotLight.range = range;
	}

	public void ResetRange()
	{
		spotLight.range = defaultLightRange;
	}

	public void SetAngle(float angle)
	{
		spotLight.spotAngle = angle;
	}

	public void ResetAngle()
	{
		spotLight.spotAngle = defaultSpotAngle;
	}

	public void TeleportMovement()
	{
		target = player.Head.transform.position + player.Head.transform.forward + player.Head.transform.up * -0.35f;
		base.transform.LookAt(target);
	}

	public void EnableRay(bool enable)
	{
		useRay = enable;
	}

	public void PlayClick()
	{
		if ((bool)lightAudio && (bool)clickOnClip)
		{
			lightAudio.Play(clickOnClip);
		}
	}

	public void SetColour(Color32 newColour)
	{
		spotLight.color = newColour;
	}

	public void ResetColour()
	{
		spotLight.color = defaultLightColour;
	}

	public void SetStandardPlayerLightCookie()
	{
		spotLight.cookie = lightCookie;
	}

	public void RemovePlayerLightCookie()
	{
		spotLight.cookie = null;
	}
}
public class PlayerPositionalAudioManager : MonoBehaviour
{
	public enum AudioFadeType
	{
		NONE,
		FADE_IN,
		FADE_OUT,
		FADE_BOTH
	}

	public enum PathAxis
	{
		X_AXIS,
		Y_AXIS,
		Z_AXIS
	}

	[Serializable]
	public struct PlayerPositionalAudioContainer
	{
		public GameObject trigger;

		public AudioScript audioScript;

		public AudioClip clip;

		public bool hasSubTrack;

		public float headOffset;

		public bool loop;

		public float delay;

		public AudioFadeType fadeType;

		public float volume;

		public float fadeInTime;

		public float fadeOutTime;
	}

	public AudioScript audioScript;

	private NVRPlayer player;

	public PlayerPositionalAudioContainer[] playerPositionalAudio;

	private void Start()
	{
		player = GameController.instance.player;
	}

	public bool PlayIfTriggered(GameObject obj, bool disableTrigger)
	{
		PlayerPositionalAudioContainer[] array = playerPositionalAudio;
		for (int i = 0; i < array.Length; i++)
		{
			PlayerPositionalAudioContainer audio = array[i];
			if ((bool)audio.trigger && audio.trigger == obj)
			{
				audio.trigger.SetActive(!disableTrigger);
				Play(audio);
				if (audio.hasSubTrack)
				{
					HUD.Instance.PlaySubtitles(audio.clip.name, hasPriority: true);
				}
				return true;
			}
		}
		return false;
	}

	public void Play(PlayerPositionalAudioContainer audio)
	{
		StartCoroutine(PlayRoutine(audio));
	}

	private IEnumerator PlayRoutine(PlayerPositionalAudioContainer audio)
	{
		Vector3 position = player.Head.transform.position;
		Vector3 vector = audio.trigger.GetComponent<Collider>().ClosestPoint(player.Head.transform.position);
		Vector3 vector2 = player.Head.transform.position - vector;
		if (Mathf.Abs(vector2.x) > Mathf.Abs(vector2.z))
		{
			if (vector2.x > 0f)
			{
				position.x += audio.headOffset;
			}
			else
			{
				position.x -= audio.headOffset;
			}
		}
		else if (vector2.z > 0f)
		{
			position.z += audio.headOffset;
		}
		else
		{
			position.z -= audio.headOffset;
		}
		audioScript.gameObject.transform.position = position;
		if (audio.delay > 0f)
		{
			yield return Yield.WaitSeconds(audio.delay);
		}
		switch (audio.fadeType)
		{
		case AudioFadeType.NONE:
			audioScript.Play(audio.clip, audio.volume);
			break;
		case AudioFadeType.FADE_IN:
			audioScript.FadeIn(audio.clip, audio.volume, audio.fadeInTime, loop: false);
			break;
		case AudioFadeType.FADE_OUT:
			audioScript.Play(audio.clip, audio.volume);
			yield return Yield.WaitSeconds(audio.clip.length - audio.fadeOutTime);
			audioScript.FadeOut(audio.fadeOutTime);
			break;
		case AudioFadeType.FADE_BOTH:
			audioScript.FadeIn(audio.clip, audio.volume, audio.fadeInTime, loop: false);
			yield return Yield.WaitSeconds(audio.clip.length - audio.fadeOutTime);
			audioScript.FadeOut(audio.fadeOutTime);
			break;
		}
	}
}
public enum SFXAlertType
{
	ALERT,
	INFO
}
public class PlayerWatch : MonoBehaviour
{
	[Serializable]
	public struct SFXAlerts
	{
		public SFXAlertType type;

		public AudioClip audioClip;
	}

	[SerializeField]
	private AudioScript audioSource;

	[SerializeField]
	private SFXAlerts[] sfxAlerts;

	[SerializeField]
	private GameObject watch;

	[SerializeField]
	private Renderer screen;

	[SerializeField]
	private GameObject watchUI;

	[SerializeField]
	private GameObject watchInstructionUIPico;

	[SerializeField]
	private GameObject leftHandPoint;

	[SerializeField]
	private GameObject rightHandPoint;

	private NVRPlayer player;

	private UnityEngine.Color emissiveBlack = UnityEngine.Color.black;

	private void Start()
	{
		player = GameObject.FindGameObjectWithTag("Player").GetComponent<NVRPlayer>();
		watchInstructionUIPico.SetActive(value: false);
	}

	public void SetToRight()
	{
		base.gameObject.transform.position = rightHandPoint.transform.position;
		base.gameObject.transform.rotation = rightHandPoint.transform.rotation;
		screen.sharedMaterial.SetColor("_EmissionColor", emissiveBlack);
	}

	public void SetToLeft()
	{
		base.gameObject.transform.position = leftHandPoint.transform.position;
		base.gameObject.transform.rotation = leftHandPoint.transform.rotation;
		screen.sharedMaterial.SetColor("_EmissionColor", emissiveBlack);
	}

	public void WatchHintNoVibration(SFXAlertType sfxAlertType)
	{
		AudioClip audioClipForAlterType = getAudioClipForAlterType(sfxAlertType);
		if (audioClipForAlterType != null)
		{
			audioSource.PlayOne(audioClipForAlterType);
		}
	}

	public void WatchHint(float time)
	{
		if (base.gameObject.activeInHierarchy)
		{
			StartCoroutine("NotifyPlayer", time);
		}
	}

	public void WatchHintWithSFX(float time, SFXAlertType sfxAlertType)
	{
		if (base.gameObject.activeInHierarchy)
		{
			StartCoroutine(NotifyPlayerWithSFX(time, sfxAlertType));
		}
	}

	public void WatchHintWithSFXStayLit(SFXAlertType sfxAlertType)
	{
		if (base.gameObject.activeInHierarchy)
		{
			StartCoroutine(NotifyPlayerWithSFXStayLit(sfxAlertType));
		}
	}

	public void CancelWatchHint()
	{
		StopCoroutine("NotifyPlayer");
		watchInstructionUIPico.SetActive(value: false);
		screen.sharedMaterial.SetColor("_Color", emissiveBlack);
	}

	public void CancelWatchHintWithSFX()
	{
		StopCoroutine("NotifyPlayerWithSFX");
		watchInstructionUIPico.SetActive(value: false);
		screen.sharedMaterial.SetColor("_Color", emissiveBlack);
	}

	private IEnumerator NotifyPlayer(float timeCount)
	{
		float startTime = Time.time;
		WaitForSeconds intervals = new WaitForSeconds(0.3f);
		while (Time.time < startTime + timeCount)
		{
			screen.sharedMaterial.SetColor("_Color", UnityEngine.Color.white);
			if (player.LeftHand.IsPrimary)
			{
				player.RightHand.LongHapticPulse(0.3f);
			}
			else
			{
				player.LeftHand.LongHapticPulse(0.3f);
			}
			yield return intervals;
			screen.sharedMaterial.SetColor("_Color", emissiveBlack);
			yield return intervals;
		}
		screen.sharedMaterial.SetColor("_Color", UnityEngine.Color.white);
		yield return Yield.WaitSeconds(10f);
		screen.sharedMaterial.SetColor("_Color", emissiveBlack);
	}

	private IEnumerator NotifyPlayerWithSFX(float timeCount, SFXAlertType sfxAlertType)
	{
		float startTime = Time.time;
		WaitForSeconds intervals = new WaitForSeconds(0.3f);
		AudioClip audioClipForAlterType = getAudioClipForAlterType(sfxAlertType);
		if (audioClipForAlterType != null)
		{
			audioSource.PlayOne(audioClipForAlterType);
		}
		while (Time.time < startTime + timeCount)
		{
			screen.sharedMaterial.SetColor("_Color", UnityEngine.Color.white);
			if (player.LeftHand.IsPrimary)
			{
				player.RightHand.LongHapticPulse(0.3f);
			}
			else
			{
				player.LeftHand.LongHapticPulse(0.3f);
			}
			yield return intervals;
			screen.sharedMaterial.SetColor("_Color", emissiveBlack);
			yield return intervals;
		}
		screen.sharedMaterial.SetColor("_Color", UnityEngine.Color.white);
		yield return Yield.WaitSeconds(10f);
		screen.sharedMaterial.SetColor("_Color", emissiveBlack);
	}

	private IEnumerator NotifyPlayerWithSFXStayLit(SFXAlertType sfxAlertType)
	{
		_ = Time.time;
		WaitForSeconds waitForSeconds = new WaitForSeconds(0.3f);
		AudioClip audioClipForAlterType = getAudioClipForAlterType(sfxAlertType);
		if (audioClipForAlterType != null)
		{
			audioSource.PlayOne(audioClipForAlterType);
		}
		watchInstructionUIPico.SetActive(value: true);
		screen.sharedMaterial.SetColor("_Color", UnityEngine.Color.white);
		if (player.LeftHand.IsPrimary)
		{
			player.RightHand.LongHapticPulse(0.3f);
		}
		else
		{
			player.LeftHand.LongHapticPulse(0.3f);
		}
		yield return waitForSeconds;
	}

	private AudioClip getAudioClipForAlterType(SFXAlertType sfxAlertType)
	{
		SFXAlerts[] array = sfxAlerts;
		for (int i = 0; i < array.Length; i++)
		{
			SFXAlerts sFXAlerts = array[i];
			if (sFXAlerts.type == sfxAlertType)
			{
				return sFXAlerts.audioClip;
			}
		}
		return null;
	}

	private void OnDisable()
	{
		StopCoroutine("NotifyPlayer");
		StopCoroutine("NotifyPlayerWithSFX");
		screen.sharedMaterial.SetColor("_Color", emissiveBlack);
	}
}
public class PoliceBadge : MonoBehaviour
{
	private float animTime = 0.5f;

	[HideInInspector]
	public bool animating;

	public void OpenBadge()
	{
		if (!animating)
		{
			StartCoroutine(Open());
		}
	}

	private IEnumerator Open()
	{
		animating = true;
		yield return Yield.WaitSeconds(animTime);
		animating = false;
	}

	public void CloseBadge(bool instantly)
	{
		if (!animating)
		{
			if (instantly)
			{
				StartCoroutine(Close(0f));
			}
			else
			{
				StartCoroutine(Close(animTime));
			}
		}
	}

	private IEnumerator Close(float time)
	{
		animating = true;
		yield return Yield.WaitSeconds(time);
		animating = false;
	}
}
public class PoliceNotepad : MonoBehaviour
{
	private float animTime = 0.5f;

	[HideInInspector]
	public bool animating;

	[SerializeField]
	private MeshRenderer mesh;

	[SerializeField]
	private Material blankMaterial;

	[SerializeField]
	private Material precinctMaterial;

	[SerializeField]
	private Material chapter1Material;

	public void OpenPad()
	{
		if (!animating)
		{
			StartCoroutine(Open());
		}
	}

	public void showBlankMaterial()
	{
		mesh.material = blankMaterial;
	}

	public void showPrecinctMaterial()
	{
		Texture texture = GameController.instance.translator.GetTexture(precinctMaterial.mainTexture.name);
		mesh.material.mainTexture = texture ?? precinctMaterial.mainTexture;
	}

	public void showChapert1Material()
	{
		Texture texture = GameController.instance.translator.GetTexture(chapter1Material.mainTexture.name);
		mesh.material.mainTexture = texture ?? chapter1Material.mainTexture;
	}

	private IEnumerator Open()
	{
		animating = true;
		yield return Yield.WaitSeconds(animTime);
		animating = false;
	}

	public void ClosePad(bool instantly)
	{
		if (!animating)
		{
			if (instantly)
			{
				StartCoroutine(Close(0f));
			}
			else
			{
				StartCoroutine(Close(animTime));
			}
		}
	}

	private IEnumerator Close(float time)
	{
		animating = true;
		yield return Yield.WaitSeconds(time);
		animating = false;
	}
}
public class PoliceRadio : MonoBehaviour
{
	[SerializeField]
	private GameObject LED;

	[Space]
	public GameObject radioUI;

	public SpriteRenderer uiMaterial;

	public Sprite uiPico;

	[Space]
	public AudioClip dispatchMessage1;

	public AudioClip dispatchMessage2;

	public AudioClip dispatchMessage3;

	public AudioClip dispatchMessage4;

	public AudioClip answeredMessage1;

	public AudioClip answeredMessage2;

	public AudioClip checkBoardMessage;

	public NVRInteractableItem interactiveItem;

	private AudioScript audioScript;

	private ScreenFX screenEffects;

	public bool isAlertMessagePlaying;

	public bool isCalling;

	private int alertPlayedCount;

	private bool hasBeenPickedUp;

	private bool heardMessage;

	private bool heardCheckBoard;

	[HideInInspector]
	public bool canInteract;

	private void Start()
	{
		interactiveItem = base.gameObject.GetComponentInParent<NVRInteractableItem>();
		audioScript = new GameObject("AudioChild").AddComponent<AudioScript>();
		audioScript.gameObject.transform.parent = base.transform;
		audioScript.gameObject.transform.localPosition = Vector3.zero;
		screenEffects = GameObject.Find("Head").GetComponentInChildren<ScreenFX>();
		SwitchUI();
	}

	public void PlayAlertMessages(int delay)
	{
		StartCoroutine(PlayAlertMessagesRoutine(delay));
	}

	public IEnumerator PlayAlertMessagesRoutine(int delay)
	{
		isAlertMessagePlaying = true;
		LED.SetActive(value: true);
		audioScript.StopLoop();
		yield return Yield.WaitSeconds(delay);
		while (!heardMessage)
		{
			if (!heardMessage)
			{
				audioScript.Play(dispatchMessage1);
				HUD.Instance.PlaySubtitles(dispatchMessage1.name, hasPriority: true);
			}
			yield return Yield.WaitSeconds(dispatchMessage1.length + 5f);
			if (!heardMessage)
			{
				audioScript.Play(dispatchMessage2);
				HUD.Instance.PlaySubtitles(dispatchMessage2.name, hasPriority: true);
			}
			yield return Yield.WaitSeconds(dispatchMessage2.length + 5f);
			if (!heardMessage)
			{
				audioScript.Play(dispatchMessage3);
				HUD.Instance.PlaySubtitles(dispatchMessage3.name, hasPriority: true);
			}
			yield return Yield.WaitSeconds(dispatchMessage3.length + 10f);
			if (!heardMessage)
			{
				audioScript.Play(dispatchMessage4);
				HUD.Instance.PlaySubtitles(dispatchMessage4.name, hasPriority: true);
			}
			yield return Yield.WaitSeconds(dispatchMessage4.length + 10f);
		}
		alertPlayedCount++;
		LED.SetActive(value: false);
		isAlertMessagePlaying = false;
	}

	private void PlayAnsweredMessage()
	{
		StartCoroutine(PlayAnsweredMessageRoutine());
	}

	private IEnumerator PlayAnsweredMessageRoutine()
	{
		heardMessage = true;
		LED.SetActive(value: true);
		LeanTween.alpha(radioUI, 0f, 0.5f);
		audioScript.StopLoop();
		StopCoroutine(PlayAlertMessagesRoutine(0));
		while (audioScript.m_AudioSource.isPlaying)
		{
			yield return null;
		}
		if (UnityEngine.Random.Range(0, 2) == 0)
		{
			audioScript.Play(answeredMessage1);
			HUD.Instance.PlaySubtitles(answeredMessage1.name, hasPriority: true);
		}
		else
		{
			audioScript.Play(answeredMessage2);
			HUD.Instance.PlaySubtitles(answeredMessage2.name, hasPriority: true);
		}
		yield return Yield.WaitSeconds(6.5f);
		LED.SetActive(value: false);
		screenEffects.Fade(UnityEngine.Color.black, 2f);
		yield return Yield.WaitSeconds(2f);
		GameController.instance.boundDetection.SwitchOffOOB();
		GameController.instance.GoToSpecificScene(SCENES.CHAPEL);
	}

	private void PlayCheckBoardMessage()
	{
		StartCoroutine(PlayCheckBoardMessageRoutine());
	}

	private IEnumerator PlayCheckBoardMessageRoutine()
	{
		heardCheckBoard = true;
		audioScript.Play(checkBoardMessage);
		HUD.Instance.PlaySubtitles(checkBoardMessage.name, hasPriority: true);
		yield return Yield.WaitSeconds(checkBoardMessage.length + 1f);
		heardCheckBoard = false;
	}

	private void Update()
	{
		if (interactiveItem.IsAttached)
		{
			hasBeenPickedUp = true;
			if (!radioUI.activeSelf && !PreferenceManager.instance.GetBool(PlayerPreferences.HAS_SEEN_RADIO_UI.ToString(), defaultValue: false))
			{
				radioUI.SetActive(value: true);
				PreferenceManager.instance.SetBool(PlayerPreferences.HAS_SEEN_RADIO_UI.ToString(), value: true);
			}
			if ((!interactiveItem.AttachedHand.IsPrimary || !ControlsManager.instance.interactPrimaryUp) && (interactiveItem.AttachedHand.IsPrimary || !ControlsManager.instance.interactSecondaryUp))
			{
				return;
			}
			if (canInteract)
			{
				if (!heardMessage)
				{
					PlayAnsweredMessage();
				}
			}
			else if (!heardCheckBoard)
			{
				PlayCheckBoardMessage();
			}
		}
		else if (radioUI.activeSelf)
		{
			radioUI.SetActive(value: false);
		}
	}

	private void SwitchUI()
	{
		uiMaterial.sprite = uiPico;
	}
}
public class PopupBook : MonoBehaviour
{
	[SerializeField]
	private GameObject bookCover;

	[SerializeField]
	private GameObject bookCoverEdge;

	[Space]
	[SerializeField]
	private GameObject mother;

	[SerializeField]
	private GameObject doctor;

	[SerializeField]
	private GameObject tableLeft;

	[SerializeField]
	private GameObject tableRight;

	[Space]
	[SerializeField]
	private GameObject maggot;

	[SerializeField]
	private GameObject sightTrigger;

	[Space]
	[SerializeField]
	private bool isPrecinct;

	private float dist = 0.0828f;

	private void Start()
	{
		if (maggot != null)
		{
			maggot.SetLayer(16);
		}
	}

	private void Update()
	{
		if (isPrecinct)
		{
			float num = bookCover.transform.eulerAngles.x / 176f;
			if (bookCoverEdge.transform.position.x < 4.3f)
			{
				num = 1f - bookCover.transform.eulerAngles.x / 176f;
			}
			mother.transform.localEulerAngles = new Vector3(0f, -50f, 90f * num);
			doctor.transform.localEulerAngles = new Vector3(0f, 40f, 90f * num);
			tableLeft.transform.localScale = new Vector3(1f, 1f - num, -1f);
			tableRight.transform.localScale = new Vector3(1f, 1f - num, 1f);
			return;
		}
		float num2 = bookCover.transform.eulerAngles.x / 176f;
		if (bookCoverEdge.transform.position.x < -4.85f)
		{
			num2 = 1f - bookCover.transform.eulerAngles.x / 176f;
			if (sightTrigger != null)
			{
				sightTrigger.SetActive(value: false);
			}
		}
		else if (sightTrigger != null)
		{
			sightTrigger.SetActive(value: true);
		}
		mother.transform.localEulerAngles = new Vector3(0f, -50f, 90f * num2);
		doctor.transform.localEulerAngles = new Vector3(0f, 40f, 90f * num2);
		tableLeft.transform.localScale = new Vector3(1f, 1f - num2, -1f);
		tableRight.transform.localScale = new Vector3(1f, 1f - num2, 1f);
		if (maggot != null)
		{
			maggot.transform.localPosition = new Vector3(maggot.transform.localPosition.x, -0.0556f + (1f - num2) * dist, maggot.transform.localPosition.z);
		}
	}
}
public class PortalCamera : MonoBehaviour
{
	[SerializeField]
	private Transform portalOther;

	[SerializeField]
	private Transform maxXPos;

	[SerializeField]
	private Transform minXPos;

	[SerializeField]
	private bool affectsPos;

	[SerializeField]
	private bool affectsRot;

	private Transform playerCam;

	private Quaternion startRot;

	private Vector3 startPos;

	[SerializeField]
	public Camera portalCamera;

	[SerializeField]
	private LayerMask standardLayerMask;

	private void Start()
	{
	}

	public void setStandardLayerMask()
	{
		portalCamera.cullingMask = standardLayerMask;
	}

	private void Update()
	{
	}
}
public class Printer : MonoBehaviour
{
	public static string PRINTER_TAG = "PrinterTriggerZone";

	[SerializeField]
	private Material printerMaterial;

	[SerializeField]
	private Keycard[] keycards;

	[HideInInspector]
	public bool isPoweredOn;

	[HideInInspector]
	public bool readyToPrint;

	[SerializeField]
	private AudioScriptPooled audioScript;

	[SerializeField]
	private AudioClip clipPrint;

	private void Start()
	{
		isPoweredOn = false;
	}

	private void Update()
	{
	}

	public bool CanPrintKeycard()
	{
		Keycard[] array = keycards;
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i].InsidePrinter)
			{
				return false;
			}
		}
		return true;
	}

	public bool HasPrintedKeycard(int keycardNumber)
	{
		return keycards[keycardNumber].hasPrinted;
	}

	public void PrintKeycard(int keycardNumber)
	{
		readyToPrint = false;
		Keycard keycard = keycards[keycardNumber];
		keycard.hasPrinted = true;
		StartCoroutine(PrintKeycardRoutine(keycard));
	}

	private IEnumerator PrintKeycardRoutine(Keycard keycard)
	{
		audioScript.Play(clipPrint, 0.6f);
		yield return Yield.WaitSeconds(2f);
		keycard.gameObject.SetActive(value: true);
		while ((bool)keycard.paperForce)
		{
			yield return Yield.WaitSeconds(1f);
		}
		readyToPrint = true;
	}

	public void PowerButtonPressed()
	{
		if (isPoweredOn)
		{
			isPoweredOn = false;
			return;
		}
		isPoweredOn = true;
		readyToPrint = true;
		StartCoroutine(PrintPowerOn());
	}

	private IEnumerator PrintPowerOn()
	{
		audioScript.Play(clipPrint, 0.6f);
		yield return Yield.WaitSeconds(1.85f);
		audioScript.StopLoop();
	}

	public void ResetButtonPressed()
	{
		StartCoroutine(ResetButtonPressedRoutine());
	}

	private IEnumerator ResetButtonPressedRoutine()
	{
		isPoweredOn = true;
		yield return Yield.WaitSeconds(0.5f);
		isPoweredOn = true;
	}

	private void DebugCommands()
	{
		Input.GetKeyDown(KeyCode.Space);
	}
}
public class PuzzleBoxArtifact : MonoBehaviour
{
	[Serializable]
	public class PuzzleSegment
	{
		public BoxCollider collider;

		public GameObject item;

		public Rotation direction;

		[NonSerialized]
		public bool locked;

		public float Rotation => (direction == PuzzleBoxArtifact.Rotation.CLOCKWISE) ? 90 : (-90);

		public void RandomiseRotation(int avoidRot)
		{
			int num = 90 * UnityEngine.Random.Range(1, 4);
			if (num == avoidRot)
			{
				num += 90;
			}
			if (num == 360)
			{
				num += 90;
			}
			Vector3 localEulerAngles = item.transform.localEulerAngles;
			item.transform.localEulerAngles = new Vector3(localEulerAngles.x, num, localEulerAngles.z);
		}
	}

	public enum Rotation
	{
		CLOCKWISE,
		ANTICLOCKWISE
	}

	[Header("Components")]
	[SerializeField]
	private PuzzleSegment[] segmentPieces;

	[SerializeField]
	private GameObject realContainer;

	[SerializeField]
	private GameObject fakeContainer;

	[SerializeField]
	private GameObject fakeAngel;

	[SerializeField]
	private Animator animator;

	[SerializeField]
	private AudioScriptPooled audioScript;

	[SerializeField]
	private NVRInteractableItem itemUpgrade;

	[SerializeField]
	private AnimationClip openAnim;

	[Space]
	[Header("Audio")]
	[SerializeField]
	private AudioClip rotatePiece;

	[SerializeField]
	private AudioClip puzzleCompleted;

	private float segmentRotationDuration = 0.5f;

	private LeanTweenType tweenType = LeanTweenType.easeOutBack;

	private void Start()
	{
		if (SaveManager.instance.HasFoundArtifact(ChapterID.MORGUE))
		{
			SetArtifactRevealed();
			return;
		}
		realContainer.SetActive(value: false);
		fakeContainer.SetActive(value: true);
		fakeAngel.SetActive(value: true);
		for (int i = 0; i < segmentPieces.Length; i++)
		{
			segmentPieces[i].RandomiseRotation((int)segmentPieces[(i != 0) ? (i - 1) : 0].item.transform.localEulerAngles.y);
			segmentPieces[i].locked = false;
		}
	}

	private bool CheckComplete()
	{
		for (int i = 0; i < segmentPieces.Length; i++)
		{
			if ((int)segmentPieces[i].item.transform.localEulerAngles.y != 0)
			{
				return false;
			}
		}
		return true;
	}

	public void RotatePuzzlePiece(GameObject obj)
	{
		PuzzleSegment puzzleSegment = Array.Find(segmentPieces, (PuzzleSegment e) => e.item == obj);
		if (!puzzleSegment.locked)
		{
			StartCoroutine(RotatePuzzlePieceRoutine(puzzleSegment));
		}
	}

	private IEnumerator RotatePuzzlePieceRoutine(PuzzleSegment segment)
	{
		segment.locked = true;
		audioScript.PlayOneShot(rotatePiece, 0.25f);
		LeanTween.rotateAroundLocal(segment.item, Vector3.up, segment.Rotation, segmentRotationDuration).setEase(tweenType);
		yield return Yield.WaitSeconds(segmentRotationDuration);
		int num = (int)Math.Round(segment.item.transform.localEulerAngles.y / 90f, MidpointRounding.AwayFromZero) * 90;
		Vector3 localEulerAngles = segment.item.transform.localEulerAngles;
		segment.item.transform.localEulerAngles = new Vector3(localEulerAngles.x, num, localEulerAngles.z);
		if (CheckComplete())
		{
			realContainer.SetActive(value: true);
			fakeContainer.SetActive(value: false);
			fakeAngel.SetActive(value: false);
			PuzzleSegment[] array = segmentPieces;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].collider.gameObject.SetLayer(LayerMask.NameToLayer("Lighting01"));
			}
			audioScript.Play(puzzleCompleted);
			animator.SetTrigger("Open");
			yield return Yield.WaitSeconds(openAnim.length - 2.5f);
			itemUpgrade.CanAttach = true;
		}
		else
		{
			segment.locked = false;
		}
	}

	public void SetArtifactRevealed()
	{
		PuzzleSegment[] array = segmentPieces;
		foreach (PuzzleSegment obj in array)
		{
			obj.locked = true;
			obj.collider.gameObject.SetLayer(LayerMask.NameToLayer("Lighting01"));
		}
		itemUpgrade.gameObject.SetActive(value: false);
		realContainer.SetActive(value: true);
		fakeContainer.SetActive(value: false);
		fakeAngel.SetActive(value: false);
		animator.SetTrigger("Idle Open");
	}
}
public class RailsAudio : SoundObject
{
	[SerializeField]
	private AudioClip movementClip;

	private bool playing;

	private Rigidbody rb;

	public AudioScript slideAudio;

	private new void Start()
	{
		base.Start();
		rb = GetComponent<Rigidbody>();
		if ((bool)movementClip)
		{
			slideAudio.PlayLoop(movementClip);
		}
		slideAudio.m_AudioSource.volume = 0f;
	}

	private void FixedUpdate()
	{
		if (movementClip != null)
		{
			float num = rb.velocity.magnitude;
			if (num < 0f)
			{
				num *= -1f;
			}
			float num2 = Mathf.Clamp(num, 0f, 1f) * 2f;
			if (num2 > 1f)
			{
				num2 = 1f;
			}
			slideAudio.m_AudioSource.volume = num2;
		}
	}
}
public class RecordPlayer : MonoBehaviour
{
	[SerializeField]
	private AudioScript recordPlayerAudioScript;

	[SerializeField]
	private AudioClip recordPlayerClip;

	[SerializeField]
	private GameObject recordPlayerRecord;

	[SerializeField]
	private GameObject recordPlayerTurntable;

	[SerializeField]
	private GameObject recordPlayerArm;

	private float rotationsPerMinute = 10f;

	[HideInInspector]
	public bool recordPlaying;

	[HideInInspector]
	public bool stopping;

	private void Start()
	{
	}

	public void playRecord()
	{
		recordPlaying = true;
		stopping = false;
		recordPlayerAudioScript.PlayLoop(recordPlayerClip);
	}

	public void stopRecord()
	{
		if (!stopping)
		{
			StartCoroutine(stopRecordRoutine());
		}
	}

	private IEnumerator stopRecordRoutine()
	{
		stopping = true;
		LeanTween.rotateLocal(recordPlayerArm, new Vector3(0.95f, recordPlayerArm.transform.localRotation.y, recordPlayerArm.transform.localRotation.z), 2f);
		recordPlayerAudioScript.StopLoop();
		yield return Yield.WaitSeconds(2f);
		LeanTween.rotateLocal(recordPlayerArm, new Vector3(recordPlayerArm.transform.localRotation.x, 0f, recordPlayerArm.transform.localRotation.z), 3f);
		yield return Yield.WaitSeconds(1.5f);
		rotationsPerMinute = 9f;
		yield return Yield.WaitSeconds(0.5f);
		rotationsPerMinute = 8f;
		yield return Yield.WaitSeconds(0.5f);
		rotationsPerMinute = 7f;
		yield return Yield.WaitSeconds(0.5f);
		rotationsPerMinute = 8f;
		yield return Yield.WaitSeconds(0.5f);
		rotationsPerMinute = 5f;
		yield return Yield.WaitSeconds(0.5f);
		rotationsPerMinute = 4f;
		yield return Yield.WaitSeconds(0.5f);
		rotationsPerMinute = 3f;
		yield return Yield.WaitSeconds(0.5f);
		rotationsPerMinute = 2f;
		yield return Yield.WaitSeconds(0.5f);
		rotationsPerMinute = 1f;
		yield return Yield.WaitSeconds(0.5f);
		rotationsPerMinute = 0f;
		recordPlaying = false;
	}

	private void Update()
	{
		if (recordPlaying)
		{
			recordPlayerRecord.transform.Rotate(0f, 6f * rotationsPerMinute * Time.deltaTime, 0f);
			recordPlayerTurntable.transform.Rotate(0f, 6f * rotationsPerMinute * Time.deltaTime, 0f);
		}
	}
}
public class Room : MonoBehaviour
{
	public bool playerInRoom;

	[SerializeField]
	private GameObject roomOOB;

	[SerializeField]
	public GameObject navMeshBlocker;

	[SerializeField]
	public GameObject associatedParentGameObject;

	[SerializeField]
	public GameObject[] floorOOB;

	private int currentLayerMask;

	private int OOBLayerMask;

	private NVRPlayer player;

	private bool inOOB;

	public bool OOBEnabled;

	private int colliderCount;

	private Coroutine switchLayersOn;

	private Coroutine switchLayersOff;

	public GameObject OOB
	{
		get
		{
			return roomOOB;
		}
		set
		{
			roomOOB = value;
		}
	}

	public void Start()
	{
		player = GameController.instance.player;
		OOBLayerMask = 1 << LayerMask.NameToLayer("OOBFloor");
	}

	public void SwitchOnOOB()
	{
		OOBEnabled = true;
		currentLayerMask = player.mainCamera.cullingMask;
		UnityEngine.Debug.Log("Switching on OOB, layer mask : " + currentLayerMask);
	}

	public void AddToLayerMask(string layerName, bool setCamera)
	{
		currentLayerMask |= 1 << LayerMask.NameToLayer(layerName);
		if (setCamera)
		{
			player.mainCamera.cullingMask = currentLayerMask;
		}
	}

	public void AddToLayerMask(int layer, bool setCamera)
	{
		currentLayerMask |= 1 << layer;
		if (setCamera)
		{
			player.mainCamera.cullingMask = currentLayerMask;
		}
	}

	public void SubtractFromLayerMask(string layerName, bool setCamera)
	{
		currentLayerMask &= ~(1 << LayerMask.NameToLayer(layerName));
		if (setCamera)
		{
			player.mainCamera.cullingMask = currentLayerMask;
		}
	}

	public void SubtractFromLayerMask(int layer, bool setCamera)
	{
		currentLayerMask &= ~(1 << layer);
		if (setCamera)
		{
			player.mainCamera.cullingMask = currentLayerMask;
		}
	}

	public void SwitchOffOOB()
	{
		OOBEnabled = false;
		if (switchLayersOn != null)
		{
			StopCoroutine(switchLayersOn);
		}
		if (switchLayersOff != null)
		{
			StopCoroutine(switchLayersOff);
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject.name == "CenterEyePoint")
		{
			colliderCount++;
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (other.gameObject.name == "CenterEyePoint")
		{
			colliderCount--;
		}
	}

	public void UpdateColliders(bool enabled)
	{
		if ((bool)roomOOB)
		{
			roomOOB.SetActive(enabled);
		}
		if ((bool)navMeshBlocker)
		{
			navMeshBlocker.SetActive(enabled);
		}
	}

	private void FixedUpdate()
	{
		if (colliderCount > 0 && !playerInRoom)
		{
			playerInRoom = true;
			if (this == GameController.instance.currentRoom && OOBEnabled)
			{
				if (switchLayersOn != null)
				{
					StopCoroutine(switchLayersOn);
				}
				switchLayersOff = StartCoroutine(ToggleOOBCameraLayersOff());
			}
		}
		else
		{
			if (colliderCount != 0 || !playerInRoom)
			{
				return;
			}
			playerInRoom = false;
			if (this == GameController.instance.currentRoom && OOBEnabled)
			{
				if (switchLayersOff != null)
				{
					StopCoroutine(switchLayersOff);
				}
				switchLayersOn = StartCoroutine(ToggleOOBCameraLayersOn());
			}
		}
	}

	public IEnumerator ToggleOOBCameraLayersOn()
	{
		if (inOOB)
		{
			yield break;
		}
		inOOB = true;
		yield return Yield.WaitSeconds(5f);
		UnityEngine.Debug.Log("ToggleOOBCameraLayersOn Started, previous culling mask : " + player.mainCamera.cullingMask);
		if (GameController.instance.currentRoom != null)
		{
			player.mainCamera.cullingMask = OOBLayerMask;
			for (int i = 0; i < floorOOB.Length; i++)
			{
				floorOOB[i].SetActive(value: true);
			}
		}
	}

	public IEnumerator ToggleOOBCameraLayersOff()
	{
		if (!inOOB)
		{
			yield break;
		}
		inOOB = false;
		yield return Yield.EndOfFrame;
		UnityEngine.Debug.Log("ToggleOOBCameraLayersOff Started, with layermask : " + currentLayerMask);
		if (GameController.instance.currentRoom != null)
		{
			player.visual_OOB.SetActive(value: false);
			player.mainCamera.cullingMask = currentLayerMask;
			for (int i = 0; i < floorOOB.Length; i++)
			{
				floorOOB[i].SetActive(value: false);
			}
		}
	}
}
public class RoomScaleVive : MonoBehaviour
{
	private float left;

	private float right;

	private float back;

	private float front;

	private float width;

	private float length;

	public bool init;

	public void CalcRoomScale()
	{
	}

	public float GetScale()
	{
		return 0f;
	}
}
public class RoomScaleOculus : MonoBehaviour
{
	private float width;

	private float length;

	private OVRBoundary boundary;

	public bool init;

	public void CalcRoomScale()
	{
		if (boundary == null)
		{
			boundary = new OVRBoundary();
		}
		Vector3 dimensions = boundary.GetDimensions(OVRBoundary.BoundaryType.PlayArea);
		length = dimensions.x;
		width = dimensions.z;
		if (length > 1f && width > 1f)
		{
			init = true;
		}
	}

	public float GetScale()
	{
		if (!(width < length))
		{
			return length;
		}
		return width;
	}
}
public class RoomScaleOculusQuest : MonoBehaviour
{
	private float width;

	private float length;

	private OVRBoundary boundary;

	public bool init;

	public void CalcRoomScale()
	{
		if (boundary == null)
		{
			boundary = new OVRBoundary();
		}
		Vector3 dimensions = boundary.GetDimensions(OVRBoundary.BoundaryType.PlayArea);
		length = dimensions.x;
		width = dimensions.z;
		if (length > 1f && width > 1f)
		{
			init = true;
		}
	}

	public float GetScale()
	{
		if (!(width < length))
		{
			return length;
		}
		return width;
	}
}
public class RopeManager : MonoBehaviour
{
	[SerializeField]
	private UltimateVRRope[] ropes;

	[SerializeField]
	private float distanceCheck;

	private NVRPlayer _player;

	private void Start()
	{
		_player = GameController.instance.player;
	}

	private void Update()
	{
		UltimateVRRope[] array = ropes;
		foreach (UltimateVRRope ultimateVRRope in array)
		{
			if (!ultimateVRRope.Parented)
			{
				continue;
			}
			float num = Mathf.Abs(ultimateVRRope.CentrePosition.z - _player.Head.transform.position.z);
			if (num > distanceCheck && ultimateVRRope.active)
			{
				UltimateVRRopeLink[] links = ultimateVRRope.links;
				for (int j = 0; j < links.Length; j++)
				{
					links[j].gameObject.SetActive(value: false);
				}
				ultimateVRRope.active = false;
			}
			else if (num < distanceCheck && !ultimateVRRope.active)
			{
				UltimateVRRopeLink[] links = ultimateVRRope.links;
				for (int j = 0; j < links.Length; j++)
				{
					links[j].gameObject.SetActive(value: true);
				}
				ultimateVRRope.active = true;
			}
		}
	}
}
public class SaltSprayer : MonoBehaviour
{
	[SerializeField]
	private ParticleSystem particles;

	[SerializeField]
	private ParticleSystem particles_upgraded;

	[SerializeField]
	private GameObject pump;

	[Space]
	[SerializeField]
	private float rechargeTime = 5f;

	[SerializeField]
	private float fireTime = 2f;

	private bool recharging;

	[SerializeField]
	private AudioClip sfxCharge;

	[SerializeField]
	private AudioClip sfxSpray;

	[SerializeField]
	private AudioScript audioScript;

	[SerializeField]
	private MeshRenderer saltsprayerBottomMeshRenderer;

	[SerializeField]
	private MeshRenderer saltsprayerGlassMeshRenderer;

	[SerializeField]
	private MeshRenderer saltsprayerSaltMeshRenderer;

	[SerializeField]
	private MeshRenderer saltsprayerTopMeshRenderer;

	[SerializeField]
	private MeshRenderer saltsprayerHalvedBottomMeshRenderer;

	[SerializeField]
	private MeshRenderer saltsprayerHalvedGlassMeshRenderer;

	[SerializeField]
	private MeshRenderer saltsprayerHalvedSaltMeshRenderer;

	[SerializeField]
	private MeshRenderer saltsprayerHalvedTopMeshRenderer;

	[SerializeField]
	private Material saltsprayerMaterial;

	[SerializeField]
	private Material saltsprayerMaterialFade;

	[SerializeField]
	private Material saltsprayerUpgadedMaterial;

	[SerializeField]
	private Material saltsprayerUpgadedMaterialFade;

	[HideInInspector]
	public GameObject currentTarget;

	[HideInInspector]
	public List<GameObject> wrongTargets;

	[HideInInspector]
	public GameObject wrongTargetHit;

	[HideInInspector]
	public bool hitTarget;

	[HideInInspector]
	public bool hitWrongTarget;

	private ExorcismItem exItem;

	private float rechargingTime;

	private float disabledTime;

	private bool upgraded;

	private void Start()
	{
		if ((bool)GetComponent<ExorcismItem>())
		{
			exItem = GetComponent<ExorcismItem>();
		}
		upgraded = SaveManager.instance.HasFoundArtifact(ChapterID.NURSERY);
		if (upgraded)
		{
			UpgradeSaltSprayer(upgrade: true);
		}
	}

	public void Fire()
	{
		if (recharging)
		{
			return;
		}
		recharging = true;
		StartCoroutine(FireSalt());
		if (!currentTarget)
		{
			return;
		}
		Vector3 direction = base.transform.TransformDirection(Vector3.right);
		int layerMask = 2048;
		if (!Physics.Raycast(base.transform.position, direction, out var hitInfo, 1f, layerMask))
		{
			return;
		}
		if (hitInfo.collider.gameObject == currentTarget)
		{
			hitTarget = true;
			hitWrongTarget = false;
		}
		else
		{
			if (wrongTargets == null)
			{
				return;
			}
			for (int i = 0; i < wrongTargets.Count; i++)
			{
				if (hitInfo.collider.gameObject == wrongTargets[i])
				{
					hitTarget = false;
					hitWrongTarget = true;
					wrongTargetHit = hitInfo.collider.gameObject;
				}
			}
		}
	}

	private void Update()
	{
		Vector3 dir = base.transform.TransformDirection(Vector3.right);
		UnityEngine.Debug.DrawRay(base.transform.position, dir);
	}

	private IEnumerator FireSalt()
	{
		if (upgraded)
		{
			particles_upgraded.Play();
		}
		else
		{
			particles.Play();
		}
		audioScript.Play(sfxSpray);
		LeanTween.moveLocalY(pump, 0.0129f, 0.2f);
		yield return Yield.WaitSeconds(fireTime);
		if (upgraded)
		{
			particles_upgraded.Stop();
		}
		else
		{
			particles.Stop();
		}
		StartCoroutine(Recharge());
	}

	private IEnumerator Recharge()
	{
		if (!exItem.inKit)
		{
			audioScript.Play(sfxCharge);
		}
		else
		{
			audioScript.Play(sfxCharge, 0f);
		}
		LeanTween.moveLocalY(pump, -0.0131f, rechargeTime);
		rechargingTime = 0f;
		for (float i = 0f; i < 1f; i += Time.deltaTime / rechargeTime)
		{
			rechargingTime += Time.deltaTime;
			yield return Yield.EndOfFrame;
		}
		rechargingTime = 0f;
		recharging = false;
		hitTarget = false;
	}

	private IEnumerator ContinueRecharge()
	{
		float time = rechargeTime - rechargingTime;
		LeanTween.moveLocalY(pump, -0.0131f, time);
		audioScript.PlayFromTime(sfxCharge, rechargeTime - time, 0f);
		for (float i = 0f; i < 1f; i += Time.deltaTime / time)
		{
			rechargingTime += Time.deltaTime;
			yield return Yield.EndOfFrame;
		}
		rechargingTime = 0f;
		recharging = false;
		hitTarget = false;
	}

	public void PlacedInKit()
	{
		audioScript.FadeVolumeOut(0.25f);
	}

	public void RemovedFromKit()
	{
		audioScript.FadeVolumeIn(0.25f);
	}

	public void HardReset()
	{
		StopAllCoroutines();
		LeanTween.moveLocalY(pump, -0.0131f, 0f);
		recharging = false;
		hitTarget = false;
	}

	public void UpgradeSaltSprayer(bool upgrade)
	{
		upgraded = upgrade;
		if (upgrade)
		{
			fireTime = 4f;
			saltsprayerBottomMeshRenderer.material = saltsprayerUpgadedMaterial;
			saltsprayerGlassMeshRenderer.material = saltsprayerUpgadedMaterial;
			saltsprayerSaltMeshRenderer.material = saltsprayerUpgadedMaterial;
			saltsprayerTopMeshRenderer.material = saltsprayerUpgadedMaterial;
			saltsprayerHalvedBottomMeshRenderer.material = saltsprayerUpgadedMaterial;
			saltsprayerHalvedGlassMeshRenderer.material = saltsprayerUpgadedMaterial;
			saltsprayerHalvedSaltMeshRenderer.material = saltsprayerUpgadedMaterial;
			saltsprayerHalvedTopMeshRenderer.material = saltsprayerUpgadedMaterial;
		}
		else
		{
			fireTime = 2f;
			saltsprayerBottomMeshRenderer.material = saltsprayerMaterial;
			saltsprayerGlassMeshRenderer.material = saltsprayerMaterial;
			saltsprayerSaltMeshRenderer.material = saltsprayerMaterial;
			saltsprayerTopMeshRenderer.material = saltsprayerMaterial;
			saltsprayerHalvedBottomMeshRenderer.material = saltsprayerMaterial;
			saltsprayerHalvedGlassMeshRenderer.material = saltsprayerMaterial;
			saltsprayerHalvedSaltMeshRenderer.material = saltsprayerMaterial;
			saltsprayerHalvedTopMeshRenderer.material = saltsprayerMaterial;
		}
	}

	private void OnDisable()
	{
		if (pump.transform.localPosition.y != -0.0131f)
		{
			disabledTime = Time.time;
			recharging = true;
		}
	}

	private void OnEnable()
	{
		if (pump.transform.localPosition.y != -0.0131f)
		{
			disabledTime = Time.time - disabledTime;
			if (rechargingTime < rechargeTime - disabledTime)
			{
				rechargingTime += disabledTime;
				StartCoroutine(ContinueRecharge());
			}
			else
			{
				recharging = false;
				hitTarget = false;
				LeanTween.moveLocalY(pump, -0.0131f, 0f);
			}
		}
		else if (recharging)
		{
			recharging = false;
			hitTarget = false;
		}
	}

	public void SetStandardShader()
	{
		if (upgraded)
		{
			saltsprayerBottomMeshRenderer.material = saltsprayerUpgadedMaterial;
			saltsprayerGlassMeshRenderer.material = saltsprayerUpgadedMaterial;
			saltsprayerSaltMeshRenderer.material = saltsprayerUpgadedMaterial;
			saltsprayerTopMeshRenderer.material = saltsprayerUpgadedMaterial;
		}
		else
		{
			saltsprayerBottomMeshRenderer.material = saltsprayerMaterial;
			saltsprayerGlassMeshRenderer.material = saltsprayerMaterial;
			saltsprayerSaltMeshRenderer.material = saltsprayerMaterial;
			saltsprayerTopMeshRenderer.material = saltsprayerMaterial;
		}
	}

	public void SetDissolveShader()
	{
		if (upgraded)
		{
			saltsprayerBottomMeshRenderer.material = saltsprayerUpgadedMaterialFade;
			saltsprayerGlassMeshRenderer.material = saltsprayerUpgadedMaterialFade;
			saltsprayerSaltMeshRenderer.material = saltsprayerUpgadedMaterialFade;
			saltsprayerTopMeshRenderer.material = saltsprayerUpgadedMaterialFade;
		}
		else
		{
			saltsprayerBottomMeshRenderer.material = saltsprayerMaterialFade;
			saltsprayerGlassMeshRenderer.material = saltsprayerMaterialFade;
			saltsprayerSaltMeshRenderer.material = saltsprayerMaterialFade;
			saltsprayerTopMeshRenderer.material = saltsprayerMaterialFade;
		}
	}

	public IEnumerator StartFadeOut(float time)
	{
		for (float t = 1f; t > 0f; t -= Time.deltaTime / time)
		{
			saltsprayerBottomMeshRenderer.material.SetFloat("_Dissolve", t);
			saltsprayerGlassMeshRenderer.material.SetFloat("_Dissolve", t);
			saltsprayerSaltMeshRenderer.material.SetFloat("_Dissolve", t);
			saltsprayerTopMeshRenderer.material.SetFloat("_Dissolve", t);
			yield return null;
		}
		yield return null;
	}
}
public class Scales : MonoBehaviour
{
	[SerializeField]
	private SpringJoint joint;

	[SerializeField]
	private Transform needle;

	private Vector3 currentEuler;

	private bool jointBroken;

	private void Start()
	{
		currentEuler = new Vector3((joint.currentForce.y - 0.4f) * 100f, 180f, 0f);
	}

	private void Update()
	{
		if (joint != null)
		{
			currentEuler.x = (joint.currentForce.y - 0.39f) * 100f;
			needle.localEulerAngles = currentEuler;
		}
		else if (!jointBroken)
		{
			currentEuler.x = 180f;
			needle.localEulerAngles = currentEuler;
			jointBroken = true;
		}
	}
}
public class CalibrationScene : MonoBehaviour
{
	private NVRPlayer player;

	private GameObject playerCameraHolder;

	private float safeDistance = 1.7f;

	private Vector3 hmdPosition;

	private Vector3 primaryControllerPosition;

	private Vector3 secondaryControllerPosition;

	private Vector3 ds4ControllerPosition;

	private int[] primaryHandles = new int[1];

	private int[] secondaryHandles = new int[1];

	private int[] ds4Handles = new int[1];

	private bool inCircle;

	private bool calibrated;

	private bool usingDS4Controller;

	[SerializeField]
	private TextMesh instructionOne;

	[SerializeField]
	private TextMesh instructionTwo;

	[SerializeField]
	private TextMesh instructionThree;

	private void Start()
	{
		UnityEngine.Debug.LogError("Calibration scene");
	}

	private void OnEnable()
	{
	}

	private void OnDisable()
	{
	}

	private void Update()
	{
	}

	private void OnPreferencesSaved()
	{
		calibrated = true;
		instructionOne.gameObject.SetActive(value: false);
		instructionTwo.gameObject.SetActive(value: false);
		instructionThree.gameObject.SetActive(value: true);
	}

	private void OnGameSaved()
	{
		GameController.instance.GotoNextScene();
	}
}
public class CellScene : InteractionManager
{
	private bool introComplete;

	private NVRPlayer player;

	private LightFlicker playerLightFlicker;

	private Light PicoLight;

	[Header("General")]
	[SerializeField]
	private GameObject playerStartPosition;

	[SerializeField]
	private GameObject[] changeLayerObjects;

	[SerializeField]
	private LightController[] lightControllers;

	[SerializeField]
	private float startTime;

	[SerializeField]
	private float currentTime;

	[SerializeField]
	private AudioClip cellMusic;

	[SerializeField]
	private AudioClip mazeMusic;

	[SerializeField]
	private AudioClip agroBuildMusic;

	[SerializeField]
	private AudioClip wireMusic;

	[SerializeField]
	private AudioClip musicBuild5sec;

	[SerializeField]
	private AudioClip corridorMusicBuild;

	[Space]
	[SerializeField]
	private Chessboard artefact;

	[SerializeField]
	private GameObject chairEasterEgg;

	[SerializeField]
	private Shader questExorcismBurnPart2Shader;

	[Space]
	[Header("Rooms")]
	[SerializeField]
	private GameObject outsideRoom;

	[SerializeField]
	private Room securityRoom;

	[SerializeField]
	private Room corridorRoom;

	[SerializeField]
	private Room cellRoom;

	[SerializeField]
	private GameObject fakeCellRoom;

	[SerializeField]
	private Room mazeRoom;

	[SerializeField]
	private Room arenaRoom;

	[SerializeField]
	private GameObject[] combinedMeshesToDisable;

	[SerializeField]
	private GameObject[] fakeSecurityItems;

	[Space]
	[Header("Fade In")]
	[SerializeField]
	private TextMeshProUGUI chapterName;

	[SerializeField]
	private TextMeshProUGUI chapterNumber;

	[Space]
	[Header("Character Positions")]
	[SerializeField]
	private Transform patientPos01;

	[SerializeField]
	private Transform patientPos02;

	[SerializeField]
	private Transform patientPos03;

	[SerializeField]
	private Transform patientPos04;

	[SerializeField]
	private Transform patientFinalPos;

	[SerializeField]
	private Transform patientFinalPosRun;

	[Header("AudioArray")]
	[SerializeField]
	private Transform[] floataudioLocation;

	[SerializeField]
	private AudioClip[] floatAudio;

	[SerializeField]
	private GameObject floatingSample01;

	[SerializeField]
	private AudioClip musicEnding;

	private AudioScript floatAudio01;

	[Space]
	[Header("Security Room Items")]
	[SerializeField]
	private NVRInteractableItem intercomButton;

	[SerializeField]
	private Renderer intercomRenderer;

	[SerializeField]
	private AudioScript intercomAudioScript;

	[SerializeField]
	private AudioClip intercomBeepingClip;

	[SerializeField]
	private AudioClip intercomResponseClip;

	[SerializeField]
	private AudioClip intercomStaticClip;

	[SerializeField]
	private AudioClip intercomRonoveClip;

	[Space]
	[SerializeField]
	private GameObject cctvMonitor;

	[SerializeField]
	private GameObject cctvTrigger;

	[SerializeField]
	private GameObject cctvContent;

	[SerializeField]
	private AudioScript cctvAudioScript;

	[SerializeField]
	private AudioClip patientCryLoop;

	[SerializeField]
	private AudioClip patientSeeMeClip;

	[SerializeField]
	private AudioClip patientWatchMeClip;

	[SerializeField]
	private Renderer cctvContent1;

	[SerializeField]
	private Renderer cctvContent2;

	[SerializeField]
	private Material cctvNoSignalMaterial;

	[SerializeField]
	private NVRInteractableItem cctvButton;

	[SerializeField]
	private GameObject particleElectricityMalfunction;

	[SerializeField]
	private LightFlicker redLight;

	[SerializeField]
	private LightFlicker deskLamp;

	[Space]
	[SerializeField]
	private GameObject polaroid1;

	[SerializeField]
	private GameObject polaroid2;

	[SerializeField]
	private GameObject evidenceBag;

	[SerializeField]
	private AudioClip playerSineClip;

	private bool foundPolaroid1;

	private bool foundPolaroid2;

	private bool foundEvidenceBag;

	private bool intercomStaticPlaying;

	private bool intercomMessagePlayed;

	private bool intercomBeeping;

	[Space]
	[SerializeField]
	private NVRInteractableItem patientBook;

	[Space]
	[Header("Corridor")]
	[SerializeField]
	private GameObject glassWindow;

	[SerializeField]
	private GameObject windowTrigger1;

	[SerializeField]
	private GameObject windowTrigger2;

	[SerializeField]
	private LightFlicker underDoorLight;

	[SerializeField]
	private LightFlicker underDoorHighlight;

	[SerializeField]
	private GameObject doorLockPad1;

	[SerializeField]
	private Material doorLockPadGreen;

	[SerializeField]
	private Material doorLockPadRed;

	[SerializeField]
	private AudioScript cellDoorAudioScript;

	[SerializeField]
	private AudioClip doorUnlockingAudioClip;

	[SerializeField]
	private InteractiveDoor securityDoor1;

	[SerializeField]
	private InteractiveDoor securityDoor2;

	[SerializeField]
	private LightFlicker wallLight;

	[SerializeField]
	private GameObject bloodSplatter;

	[SerializeField]
	private PatientHeadBang headBang;

	[Space]
	[Header("Cell")]
	[SerializeField]
	private AudioClip doorSlamCellSfx;

	[SerializeField]
	private AudioClip doorCreakCellSfx;

	[SerializeField]
	private GameObject cellStart;

	[SerializeField]
	private GameObject patient;

	[SerializeField]
	private GameObject questPatient;

	[SerializeField]
	private GameObject patientEnd;

	[SerializeField]
	private LookAt patientLookAt;

	[SerializeField]
	private Transform patientShadowMaskFinalPos;

	[SerializeField]
	private GameObject floorReplacement;

	[SerializeField]
	private GameObject cellTrigger;

	[SerializeField]
	private GameObject cornerTrigger;

	[SerializeField]
	private FrogController frog;

	[SerializeField]
	private AudioClip hissClip;

	[SerializeField]
	private AudioClip seenWallSting;

	[SerializeField]
	private GameObject[] patientHandcuffs;

	[SerializeField]
	private GameObject CellOOB;

	[SerializeField]
	private GameObject ronovePosBehindPatient;

	[SerializeField]
	private GameObject cellMoths;

	private Transform[] floorTileTransforms;

	[Space]
	[Header("Patient chat")]
	[SerializeField]
	private Renderer patientEyeRenderer;

	[SerializeField]
	private AudioScript patientAudioSource;

	[SerializeField]
	private AudioClip patientCellEntry;

	[SerializeField]
	private AudioClip[] patientTauntClips;

	[SerializeField]
	private AudioClip patientToolClips;

	[SerializeField]
	private AudioClip patientToolClip2;

	[SerializeField]
	private AudioClip patientIntoArenaClip;

	[SerializeField]
	private AudioClip patientCantHaveHer;

	[SerializeField]
	private AudioClip patientMazeWelcome;

	[SerializeField]
	private AudioClip[] patientMazeTaunt;

	[SerializeField]
	private AudioClip voCantHaveHerRonoveReveal;

	[SerializeField]
	private AudioClip patientMazeScream;

	[SerializeField]
	private AudioClip patientCorridor;

	[SerializeField]
	private AudioClip patientCorridorScream;

	[SerializeField]
	private AudioClip ronoveDead;

	[SerializeField]
	private AudioClip[] voPain;

	[SerializeField]
	private AudioClip voPainLoop;

	[SerializeField]
	private AudioClip voEndMaze;

	[SerializeField]
	private AudioClip voFinished;

	[SerializeField]
	private AudioClip reactionLoop;

	private bool patientTauntPlayerFinished;

	[Space]
	[SerializeField]
	private LightFlicker cellLight;

	[SerializeField]
	private GameObject shrinkingWall1;

	[SerializeField]
	private GameObject shrinkingWall2;

	[SerializeField]
	private GameObject cellBackWall;

	[SerializeField]
	private GameObject ronove;

	[SerializeField]
	private Transform ronovePosCellDoor;

	[SerializeField]
	private Transform ronovePosMaze;

	[SerializeField]
	private Transform ronovePosArena;

	private Animator ronoveAnim;

	[SerializeField]
	private GameObject floorTrigger;

	[SerializeField]
	private GameObject replacementCieling;

	[SerializeField]
	private GameObject originalCieling;

	private Animator patientAnim;

	private Animator questPatientAnim;

	private bool seenBackWall;

	private bool seenMovedWall;

	[Space]
	[Header("Maze")]
	[SerializeField]
	private GameObject mazeStart;

	[SerializeField]
	private GameObject particleHeadDust;

	[SerializeField]
	private GameObject mazePart1;

	[SerializeField]
	private GameObject mazePart1OOB;

	[SerializeField]
	private GameObject mazePart2;

	[SerializeField]
	private GameObject mazePart2OOB;

	[SerializeField]
	private GameObject mazeStartWall;

	[SerializeField]
	private GameObject mazeMovingWall;

	[SerializeField]
	private FireObstacle fire1;

	[SerializeField]
	private FireObstacle fire2;

	[SerializeField]
	private GameObject fire1Trigger;

	[SerializeField]
	private GameObject fire2Trigger;

	[SerializeField]
	private GameObject boxInTrigger;

	[SerializeField]
	private GameObject boxInWallTrigger;

	[SerializeField]
	private GameObject boxInFakeWallTrigger;

	[SerializeField]
	private GameObject singleArm;

	[SerializeField]
	private GameObject singleArmTrigger;

	[SerializeField]
	private GrabberArm[] mazeArms;

	[SerializeField]
	private GameObject armsTrigger;

	[SerializeField]
	private GameObject mazeRonoveTrigger;

	[SerializeField]
	private GameObject endMazeTrigger;

	[SerializeField]
	private LightFlicker mazeLight;

	[SerializeField]
	private InteractiveDoor lockedDoorHandle;

	[SerializeField]
	private GameObject patientUnderFloor;

	[SerializeField]
	private GameObject arenaBlocker;

	[SerializeField]
	private GameObject exitMazeTrigger;

	[SerializeField]
	private AudioClip growlClip;

	[SerializeField]
	private GameObject grabberArmTarget;

	[SerializeField]
	private GameObject ronoveShadowParticle;

	[SerializeField]
	private GameObject handZoneTrigger;

	[SerializeField]
	private GameObject arenaCorridorDoor;

	private bool mazeDoorClosed;

	private bool startedFire1;

	private bool startedFire2;

	private bool movedRonove;

	private bool seenStartMazeWall;

	private bool seenMovingMazeWall;

	private bool cctvButtonPressed;

	private bool crossEquipedInCell;

	[Space]
	[Header("Exorcism")]
	[SerializeField]
	private GameObject patientExorcismTransform;

	[SerializeField]
	private GameObject arenaDoor;

	[SerializeField]
	private GameObject arenaOOB;

	[SerializeField]
	private GameObject cellArenaTrigger;

	[SerializeField]
	private GameObject cellArenaCorridorTrigger;

	[SerializeField]
	private LightFlicker lightArenaCell;

	[SerializeField]
	private LightFlicker lightFauxCell;

	[SerializeField]
	private GameObject arenaStart;

	[SerializeField]
	private GameObject arenaCorridorLight01Trigger;

	[SerializeField]
	private FaultyLightControl arenaCorridorLight01;

	[SerializeField]
	private GameObject arenaCorridorLight02Trigger;

	[SerializeField]
	private FaultyLightControl arenaCorridorLight02;

	[SerializeField]
	private GameObject arenaCorridorLight03Trigger;

	[SerializeField]
	private FaultyLightControl arenaCorridorLight03;

	[SerializeField]
	private GameObject[] finalFloorPanels;

	[SerializeField]
	private GameObject[] finalFloorEdgePanels;

	[SerializeField]
	private Vector3[] finalFloorEdgePanelsRotation;

	[SerializeField]
	private GameObject floorPit01;

	[SerializeField]
	private Light fireLight01;

	[SerializeField]
	private ParticleSystem fire01;

	[SerializeField]
	private Light fireLight02;

	[SerializeField]
	private ParticleSystem fire02;

	[SerializeField]
	private GameObject mothPrefab;

	[SerializeField]
	private ParticleSystem[] fire;

	[SerializeField]
	private GameObject firePit;

	[SerializeField]
	private AudioClip fireHitClip;

	[SerializeField]
	private AudioClip fireLoopClip;

	[SerializeField]
	private SparkEmitter[] sparks;

	[SerializeField]
	private GameObject fauxWalls;

	[SerializeField]
	private GameObject exorcismTarget;

	[SerializeField]
	private GameObject[] exorcismTargetLocations;

	[SerializeField]
	private GameObject[] exorcismTargetLocationsFinal;

	[SerializeField]
	private GameObject ghostArm01;

	[SerializeField]
	private GameObject ghostArm02;

	[SerializeField]
	private LightFlicker finalFirePit;

	[SerializeField]
	private GameObject finalPitObject;

	[SerializeField]
	private GameObject patientMask;

	[SerializeField]
	private GameObject patientMaskGhost;

	[SerializeField]
	private Animator patientMaskHospitalAnim;

	[SerializeField]
	private Animator patientFakeMaskHospitalAnim;

	[SerializeField]
	private Renderer ronoveRenderer;

	[SerializeField]
	private MothSwarm moths;

	[SerializeField]
	private GameObject corridorTrigger;

	[SerializeField]
	private Renderer patientRenderer;

	[SerializeField]
	private Material patientGlowMat;

	[SerializeField]
	private AudioClip doorCreakClip;

	[SerializeField]
	private GameObject ronoveMaskPosition;

	[SerializeField]
	private GameObject ronoveMask;

	[SerializeField]
	private ParticleSystem ronoveParticles;

	[SerializeField]
	private LightFlicker ronoveLightFinal;

	[SerializeField]
	private Transform playerFinalPos;

	private Material arm01Mat;

	private Material arm02Mat;

	private Material patientMaskMat;

	private Material patientGhostMaskMat;

	[SerializeField]
	private Material patientMaskDissolveMat;

	private bool inArenaCorridor;

	private bool floorShaking;

	private GameObject cross;

	private TuneController tuneCross;

	private ExorcismItem interactableCross;

	private OilLighter oilLighter;

	private bool crossCharged;

	private bool exorcismComplete;

	private bool intercomButtonPressed;

	private bool foundPatientBook;

	private bool seenPatientOnCCTV;

	private bool seenRononveCCTV;

	private bool inCellCorner;

	private bool inCell;

	private bool insideFirstCell;

	private bool armsComplete;

	private bool seenWindow1;

	private bool seenWindow2;

	private bool seenWindowWomen;

	private bool inBox;

	private bool seenBoxWall;

	private bool seenBoxFakeWall;

	private bool atMazeEnd;

	private bool inArmRoom;

	private bool seenCellFloor;

	private bool waitForExItem;

	private bool waitForCross;

	private bool waitForArenaCorridorCheck;

	private bool autoContinue;

	private bool foundAretfactUpgrade;

	private bool usedCorrectTools = true;

	private bool exorcismInOne;

	private int debugCount;

	private IEnumerator continueCoroutine;

	private UnityEngine.Color redColor = new UnityEngine.Color(0.866f, 0.086f, 0.101f, 1f);

	private UnityEngine.Color greenColor = new UnityEngine.Color(0.233f, 0.901f, 0.274f, 1f);

	private bool cameraShake;

	private float shakeAmount = 0.01f;

	private bool inSlowMo;

	private AudioSource[] allAudio;

	private void Awake()
	{
	}

	private void Start()
	{
		EventManager.StartListening(EventManager.AvailableEvents.IntroComplete.ToString(), IntroCompleted);
		EventManager.StartListening(EventManager.AvailableEvents.ExitLevelToPrecint.ToString(), ExitToPrecinct);
		EventManager.StartListening(EventManager.AvailableEvents.ArtifactUnlocked.ToString(), ArtifactUnlocked);
		EventManager.StartListening(EventManager.AvailableEvents.RestartScene.ToString(), RestartLevel);
		player = GameController.instance.player;
		player.movement.DisableEverything();
		player.screenFX.Fade(UnityEngine.Color.black, 0f);
		ExorcismKit exKitScript = player.HandMenu.exKitScript;
		cross = exKitScript.cross;
		tuneCross = cross.GetComponent<TuneController>();
		tuneCross.SetSpotLightEnabled(enabled: true);
		tuneCross.SetPointLightEnabled(enabled: true);
		interactableCross = cross.GetComponent<ExorcismItem>();
		patient.transform.SetParent(cellRoom.transform);
		patient.transform.position = patientPos01.position;
		patient.transform.rotation = patientPos01.rotation;
		oilLighter = exKitScript.candle.GetComponent<OilLighter>();
		oilLighter.canTurnOnLight = false;
		ronove.SetActive(value: false);
		ronoveLightFinal.SwitchLight(switchOn: false);
		chairEasterEgg.SetActive(value: false);
		underDoorHighlight.gameObject.SetActive(value: false);
		particleElectricityMalfunction.SetActive(value: false);
		playerLightFlicker = player.playerLight.GetComponent<LightFlicker>();
		PicoLight = player.PicoLight.GetComponent<Light>();
		playerLightFlicker.light.enabled = true;
		playerLightFlicker.SwitchLight(switchOn: false);
		player.playerLight.shouldLightBeOn = false;
		player.playerLight.GetComponent<Light>().enabled = true;
		player.playerLight.enabled = true;
		player.playerLight.EnableRay(enable: false);
		playerLightFlicker.light.shadows = LightShadows.None;
		playerLightFlicker.ResetIntensity();
		PicoLight.enabled = true;
		patientAnim = patient.GetComponent<Animator>();
		questPatientAnim = questPatient.GetComponent<Animator>();
		patientAnim.SetTrigger("UprightIdle");
		patientLookAt = patient.GetComponent<LookAt>();
		patientLookAt.lookAt = player.Head.gameObject.transform;
		patientEyeRenderer.sharedMaterial.SetColor("_EmissionColor", UnityEngine.Color.black);
		ronoveRenderer.material.SetFloat("_Amount", 0f);
		ronoveAnim = ronove.GetComponent<Animator>();
		arm01Mat = ghostArm01.GetComponentInChildren<Renderer>().material;
		arm01Mat.EnableKeyword("_Dis");
		arm01Mat.SetFloat("_Dis", 0f);
		arm02Mat = ghostArm02.GetComponentInChildren<Renderer>().material;
		arm02Mat.EnableKeyword("_Dis");
		arm02Mat.SetFloat("_Dis", 0f);
		patientMaskMat = patientMask.GetComponent<Renderer>().sharedMaterial;
		patientMaskMat.EnableKeyword("_Dis");
		patientMaskMat.SetFloat("_Dis", 0f);
		patientGhostMaskMat = patientMaskGhost.GetComponent<Renderer>().sharedMaterial;
		patientGhostMaskMat.EnableKeyword("_Dis");
		patientGhostMaskMat.SetFloat("_Dis", 0f);
		patientMaskDissolveMat.EnableKeyword("_Dis");
		patientMaskDissolveMat.SetFloat("_Dis", 0f);
		patientMask.SetActive(value: false);
		ghostArm01.SetActive(value: false);
		ghostArm02.SetActive(value: false);
		patientMaskGhost.SetActive(value: false);
		floatAudio01 = floatingSample01.GetComponent<AudioScript>();
		cctvTrigger.SetActive(value: false);
		fire01.gameObject.SetActive(value: false);
		floorPit01.SetActive(value: false);
		fireLight01.gameObject.SetActive(value: false);
		fire02.gameObject.SetActive(value: false);
		fireLight02.gameObject.SetActive(value: false);
		finalPitObject.SetActive(value: false);
		fauxWalls.SetActive(value: false);
		arenaCorridorDoor.SetActive(value: false);
		arenaCorridorLight01.SwitchLight(switchOn: false);
		arenaCorridorLight02.SwitchLight(switchOn: false);
		arenaCorridorLight03.SwitchLight(switchOn: false);
		lightFauxCell.SwitchLight(switchOn: false);
		lightArenaCell.SwitchLight(switchOn: false);
		cellArenaCorridorTrigger.SetActive(value: false);
		patientUnderFloor.SetActive(value: false);
		for (int i = 0; i < lightControllers.Length; i++)
		{
			lightControllers[i].TurnOnEmissives();
		}
		deskLamp.SwitchLight(switchOn: true);
		wallLight.SwitchLight(switchOn: true);
		bloodSplatter.SetActive(value: false);
		patientEnd.SetActive(value: false);
		grabberArmTarget.transform.SetParent(player.Head.transform);
		grabberArmTarget.transform.localPosition = Vector3.zero;
		cctvContent.GetComponent<Renderer>().sharedMaterial.SetTextureOffset("_MainTex", new Vector2(0f, 0.5f));
		cctvContent.GetComponent<Renderer>().sharedMaterial.SetTextureScale("_MainTex", new Vector2(0.5f, 0.5f));
		GameObject[] array = changeLayerObjects;
		for (int j = 0; j < array.Length; j++)
		{
			array[j].SetLayer(0);
		}
		SaveManager.instance.MarkChapterStarted(ChapterID.CELL);
		StartCoroutine(Master());
	}

	private void IntroCompleted()
	{
		introComplete = true;
	}

	private IEnumerator Master()
	{
		if (SaveManager.instance.HasFoundArtifact(ChapterID.CELL))
		{
			artefact.setArtifactRevealed();
		}
		GameController.instance.currentRoom = securityRoom;
		arenaOOB.SetActive(value: false);
		securityRoom.UpdateColliders(enabled: false);
		securityRoom.associatedParentGameObject.SetActive(value: true);
		securityRoom.playerInRoom = true;
		corridorRoom.UpdateColliders(enabled: true);
		corridorRoom.associatedParentGameObject.SetActive(value: true);
		corridorRoom.playerInRoom = false;
		cellRoom.UpdateColliders(enabled: true);
		cellRoom.associatedParentGameObject.SetActive(value: false);
		cellRoom.playerInRoom = false;
		mazeRoom.UpdateColliders(enabled: true);
		mazeRoom.associatedParentGameObject.SetActive(value: false);
		mazeRoom.playerInRoom = false;
		arenaRoom.UpdateColliders(enabled: true);
		arenaRoom.associatedParentGameObject.SetActive(value: false);
		arenaRoom.playerInRoom = false;
		yield return StartCoroutine(FadeInScene());
		yield return StartCoroutine(IntercomMessage());
		yield return StartCoroutine(PatientOnCCTV());
		yield return StartCoroutine(IntoTheCell());
		yield return StartCoroutine(Maze());
		yield return StartCoroutine(Exorcism());
		yield return StartCoroutine(FinalExorcism());
	}

	private IEnumerator FadeInScene()
	{
		player.HandMenu.BookInMenu(active: true);
		player.HandMenu.KitInMenu(active: true);
		while (!introComplete)
		{
			yield return null;
		}
		player.SetPosition(playerStartPosition);
		GameController.instance.audioController.SnapAllOpen(3f);
		yield return Yield.WaitSeconds(2f);
		floatingSample01.transform.position = floataudioLocation[0].position;
		floatAudio01.Play(floatAudio[0]);
		yield return Yield.WaitSeconds(5f);
		StartCoroutine(IntercomBeep());
		EventManager.TriggerEvent(EventManager.AvailableEvents.SwitchedScenes.ToString());
		SaveManager.instance.MarkChapterStarted(ChapterID.CELL);
		chapterName.transform.parent.gameObject.SetActive(value: true);
		player.screenFX.Fade(UnityEngine.Color.clear, 4f);
		yield return Yield.WaitSeconds(3f);
		GameController.instance.boundDetection.SwitchOnOOB();
		chapterName.CrossFadeAlpha(0f, 3f, ignoreTimeScale: false);
		chapterNumber.CrossFadeAlpha(0f, 3f, ignoreTimeScale: false);
		player.movement.EnableEverything();
	}

	private IEnumerator IntercomMessage()
	{
		GameController.instance.hintManager.AddHint(intercomButton);
		while (!intercomButtonPressed)
		{
			yield return null;
		}
		GameController.instance.hintManager.RemoveHint(intercomButton);
		intercomRenderer.sharedMaterial.SetColor("_EmissionColor", greenColor);
		intercomBeeping = false;
		intercomAudioScript.StopLoop();
		intercomAudioScript.Play(intercomResponseClip, 0.9f);
		HUD.Instance.PlaySubtitles(intercomResponseClip.name, hasPriority: true);
		yield return Yield.WaitSeconds(intercomResponseClip.length);
		cctvAudioScript.FadeIn(patientCryLoop, 0.8f, 7f, loop: true);
		intercomMessagePlayed = true;
		intercomRenderer.sharedMaterial.SetColor("_EmissionColor", UnityEngine.Color.black);
	}

	private IEnumerator PatientOnCCTV()
	{
		startTime = Time.time;
		currentTime = Time.time - startTime;
		if (!foundPatientBook)
		{
			GameController.instance.hintManager.AddHint(patientBook);
		}
		if (!foundEvidenceBag)
		{
			GameController.instance.hintManager.AddHint(evidenceBag);
		}
		while (!foundPatientBook || !foundEvidenceBag)
		{
			UnityEngine.Debug.Log("Passou Etapa: !foundPatientBook || !foundEvidenceBag");
			yield return null;
		}
		currentTime = Time.time - startTime;
		while (currentTime < 1f)
		{
			currentTime = Time.time - startTime;
			UnityEngine.Debug.Log("Passou Etapa: currentTime < 1f");
			yield return null;
		}
		cctvAudioScript.StopLoop();
		cctvAudioScript.PlayLoop(patientSeeMeClip, 0.9f);
		cctvContent.GetComponent<Renderer>().sharedMaterial.SetTextureOffset("_MainTex", new Vector2(0f, 0f));
		cctvContent.GetComponent<Renderer>().sharedMaterial.SetTextureScale("_MainTex", new Vector2(0.5f, 0.5f));
		seenPatientOnCCTV = false;
		cctvTrigger.SetActive(value: true);
		GameController.instance.hintManager.AddHint(cctvMonitor);
		while (!seenPatientOnCCTV)
		{
			UnityEngine.Debug.Log("Passou Etapa: !seenPatientOnCCTV");
			yield return null;
		}
		GameController.instance.hintManager.RemoveHint(cctvMonitor);
		cctvAudioScript.StopLoop();
		cctvContent.GetComponent<Renderer>().sharedMaterial.SetTextureOffset("_MainTex", new Vector2(0.5f, 0.5f));
		cctvContent.GetComponent<Renderer>().sharedMaterial.SetTextureScale("_MainTex", new Vector2(0.5f, 0.5f));
		yield return Yield.WaitSeconds(0.4f);
		cctvAudioScript.Play(patientWatchMeClip);
		HUD.Instance.PlaySubtitles(patientWatchMeClip.name, hasPriority: true);
		yield return Yield.WaitSeconds(1f);
		cctvContent.GetComponent<Renderer>().sharedMaterial.SetTextureOffset("_MainTex", new Vector2(0.5f, 0f));
		cctvContent.GetComponent<Renderer>().sharedMaterial.SetTextureScale("_MainTex", new Vector2(0.5f, 0.5f));
		lightControllers[0].FlickerLights(1f, endOn: false);
		lightControllers[4].FlickerLights(0.8f, endOn: false);
		yield return Yield.WaitSeconds(0.6f);
		patientFakeMaskHospitalAnim.SetBool("Talking", value: false);
		floatingSample01.transform.position = floataudioLocation[1].position;
		floatAudio01.Play(floatAudio[1]);
		particleElectricityMalfunction.SetActive(value: true);
		yield return Yield.WaitSeconds(0.2f);
		UnityEngine.Color color = default(UnityEngine.Color);
		ColorUtility.TryParseHtmlString("#FBF6D8", out color);
		player.screenFX.Fade(color, 0.1f);
		player.screenFX.BlurScreen(enabled: true);
		player.playerAudio.FadeIn(playerSineClip, 1f, 0.5f, loop: true);
		yield return Yield.WaitSeconds(0.4f);
		player.screenFX.BlurScreen(enabled: false, fade: true, 0.3f);
		player.screenFX.Fade(UnityEngine.Color.clear, 0.3f);
		player.playerAudio.FadeOut(1.5f);
		cctvContent1.sharedMaterial = cctvNoSignalMaterial;
		cctvContent2.sharedMaterial = cctvNoSignalMaterial;
		cctvContent.GetComponent<Renderer>().sharedMaterial = cctvNoSignalMaterial;
		cctvContent.GetComponent<AnimatedTextureUV>().enabled = true;
		yield return Yield.WaitSeconds(0.5f);
		underDoorHighlight.gameObject.SetActive(value: true);
		questPatient.transform.position = patientPos02.position;
		questPatient.transform.rotation = patientPos02.rotation;
		questPatientAnim.SetTrigger("Door");
		ronove.transform.SetParent(fakeCellRoom.transform);
		ronove.transform.position = ronovePosCellDoor.position;
		ronove.transform.rotation = ronovePosCellDoor.rotation;
		bloodSplatter.SetActive(value: true);
		GameController.instance.hintManager.AddHint(glassWindow);
		while (!seenWindowWomen)
		{
			UnityEngine.Debug.Log("Passou Etapa: !seenWindowWomen");
			yield return null;
		}
		GameController.instance.hintManager.RemoveHint(glassWindow);
		yield return Yield.WaitSeconds(2.5f);
		headBang.seenPatient = true;
		while (!headBang.showRonove)
		{
			UnityEngine.Debug.Log("Passou Etapa: !headBang.showRonove");
			yield return null;
		}
		underDoorHighlight.StartBurst(0.45f, finishOn: true);
		GameController.instance.audioController.PlayBadSting(STINGS_BAD.BAD_STING_06, 0.8f);
		questPatient.SetActive(value: false);
		ronove.SetActive(value: true);
		ronoveAnim.SetTrigger("CellDoor");
		yield return Yield.WaitSeconds(0.5f);
		underDoorHighlight.StartBurst(0.1f, finishOn: false);
		yield return Yield.WaitSeconds(0.2f);
		underDoorHighlight.gameObject.SetActive(value: false);
		ronove.SetActive(value: false);
		patient.SetActive(value: true);
		patient.transform.position = patientPos01.position;
		patient.transform.rotation = patientPos01.rotation;
		patientAnim.SetTrigger("UprightIdle");
		patientAnim.SetBool("TransitionToIdle", value: true);
		yield return Yield.WaitSeconds(3f);
		lightControllers[0].FlickerLights(0.5f, endOn: true);
		yield return Yield.WaitSeconds(3f);
		StartCoroutine(IntercomBeep());
		intercomMessagePlayed = false;
		intercomButtonPressed = false;
		GameController.instance.hintManager.AddHint(intercomButton);
		while (!intercomButtonPressed)
		{
			UnityEngine.Debug.Log("Passou Etapa: !intercomButtonPressed");
			yield return null;
		}
		GameController.instance.hintManager.RemoveHint(intercomButton);
		player.playerAudio.FadeIn(cellMusic, 1f, 8f, loop: true);
		intercomRenderer.sharedMaterial.SetColor("_EmissionColor", greenColor);
		intercomBeeping = false;
		intercomAudioScript.StopLoop();
		intercomAudioScript.PlayOne(intercomRonoveClip);
		HUD.Instance.PlaySubtitles(intercomRonoveClip.name, hasPriority: true);
		yield return Yield.WaitSeconds(intercomRonoveClip.length - 2.25f);
		cellDoorAudioScript.Play(doorUnlockingAudioClip);
		doorLockPad1.GetComponent<MeshRenderer>().material = doorLockPadGreen;
		securityDoor1.UnlockDoor();
		securityDoor2.UnlockDoor();
		securityDoor2.OpenDoorInstant(-30f, 0f);
		yield return Yield.WaitSeconds(2.25f);
		intercomRenderer.sharedMaterial.SetColor("_EmissionColor", UnityEngine.Color.black);
	}

	private IEnumerator IntoTheCell()
	{
		GameController.instance.hintManager.AddHint(securityDoor1);
		while (!insideFirstCell)
		{
			yield return null;
		}
		corridorRoom.navMeshBlocker.SetActive(value: true);
		floatingSample01.transform.position = securityDoor2.transform.position;
		floatAudio01.Play(doorSlamCellSfx);
		securityDoor2.CloseDoor();
		securityDoor2.LockDoor();
		GameController.instance.hintManager.RemoveHint(securityDoor1);
		yield return Yield.WaitSeconds(1f);
		GameController.instance.currentRoom.SwitchOffOOB();
		GameController.instance.currentRoom = cellRoom;
		securityRoom.UpdateColliders(enabled: true);
		securityRoom.associatedParentGameObject.SetActive(value: false);
		securityRoom.playerInRoom = false;
		corridorRoom.UpdateColliders(enabled: true);
		corridorRoom.associatedParentGameObject.SetActive(value: false);
		corridorRoom.playerInRoom = false;
		cellRoom.UpdateColliders(enabled: false);
		cellRoom.associatedParentGameObject.SetActive(value: true);
		cellRoom.playerInRoom = true;
		mazeRoom.UpdateColliders(enabled: true);
		mazeRoom.associatedParentGameObject.SetActive(value: false);
		mazeRoom.playerInRoom = false;
		arenaRoom.UpdateColliders(enabled: true);
		arenaRoom.associatedParentGameObject.SetActive(value: false);
		arenaRoom.playerInRoom = false;
		GameController.instance.currentRoom.SwitchOnOOB();
		StartCoroutine(PatientTauntPlayer());
		_ = shrinkingWall1.transform.position;
		Vector3 position = shrinkingWall2.transform.position;
		position.z = 7.73f;
		shrinkingWall2.transform.position = position;
		while (!seenBackWall)
		{
			yield return null;
		}
		shrinkingWall2.SetActive(value: true);
		securityRoom.associatedParentGameObject.SetActive(value: false);
		outsideRoom.SetActive(value: false);
		corridorRoom.associatedParentGameObject.SetActive(value: false);
		GameObject[] array = combinedMeshesToDisable;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(value: false);
		}
		float timeout = 0f;
		while (!seenMovedWall)
		{
			if (timeout > 10f)
			{
				seenMovedWall = true;
				break;
			}
			timeout += Time.deltaTime;
			yield return null;
		}
		GameController.instance.audioController.persistentMusicPlayer.FadeIn(wireMusic, 0.6f, 10f, loop: true);
		waitForCross = true;
		waitForExItem = true;
		while (waitForCross)
		{
			yield return StartCoroutine(ExorcismResponse());
		}
		crossEquipedInCell = true;
		while (!patientTauntPlayerFinished)
		{
			yield return Yield.WaitSeconds(0.5f);
		}
		StopCoroutine("PatientTauntPlayer");
		HUD.Instance.KillSubtitles();
		if (!patientAudioSource.m_AudioSource.isPlaying)
		{
			patientAudioSource.Play(patientToolClips);
		}
		cellLight.StartBurst(3f, finishOn: false);
		yield return Yield.WaitSeconds(2f);
		patientAnim.SetTrigger("LookAway");
		yield return Yield.WaitSeconds(1f);
		while (patientAudioSource.m_AudioSource.isPlaying)
		{
			yield return null;
		}
		lightControllers[0].UpdateReflectionProbes();
		yield return Yield.WaitSeconds(0.5f);
		patient.SetActive(value: false);
		frog.gameObject.SetActive(value: true);
		yield return Yield.WaitSeconds(1f);
		GameController.instance.audioController.persistentMusicPlayer.StopLoop();
		cellLight.light.shadowResolution = LightShadowResolution.High;
		cellLight.light.shadowStrength = 0.1f;
		cellLight.StartBurst(4f, finishOn: true);
		GameController.instance.audioController.PlayBadSting(STINGS_BAD.BAD_STING_04, 0.3f);
		yield return Yield.WaitSeconds(2f);
		frog.StartMoving();
		GameController.instance.hintManager.AddHint(frog.gameObject);
		while (!inCellCorner)
		{
			yield return null;
		}
		GameController.instance.hintManager.RemoveHint(frog.gameObject);
		player.movement.DisableEverything();
		cellLight.StartBurst(1f, finishOn: false);
		yield return Yield.WaitSeconds(1.25f);
		array = combinedMeshesToDisable;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(value: false);
		}
		frog.gameObject.SetActive(value: false);
	}

	private IEnumerator Maze()
	{
		mazePart1.SetActive(value: true);
		mazePart1OOB.SetActive(value: true);
		mazePart2.SetActive(value: false);
		mazePart2OOB.SetActive(value: false);
		GameController.instance.currentRoom.SwitchOffOOB();
		GameController.instance.currentRoom = mazeRoom;
		outsideRoom.SetActive(value: false);
		securityRoom.UpdateColliders(enabled: true);
		securityRoom.associatedParentGameObject.SetActive(value: false);
		securityRoom.playerInRoom = false;
		corridorRoom.UpdateColliders(enabled: true);
		corridorRoom.associatedParentGameObject.SetActive(value: false);
		corridorRoom.playerInRoom = false;
		cellRoom.UpdateColliders(enabled: true);
		cellRoom.associatedParentGameObject.SetActive(value: false);
		cellRoom.playerInRoom = false;
		mazeRoom.UpdateColliders(enabled: false);
		mazeRoom.associatedParentGameObject.SetActive(value: true);
		mazeRoom.playerInRoom = true;
		arenaRoom.UpdateColliders(enabled: true);
		arenaRoom.associatedParentGameObject.SetActive(value: false);
		arenaRoom.playerInRoom = false;
		player.movement.ForceTeleport(mazeStart.transform.position);
		GameController.instance.currentRoom.SwitchOnOOB();
		GameController.instance.audioController.SnapSpatialEcho(1f);
		yield return Yield.WaitSeconds(1f);
		floatingSample01.transform.position = floataudioLocation[2].position;
		floatAudio01.Play(patientMazeWelcome);
		yield return Yield.WaitSeconds(4f);
		player.movement.EnableEverything();
		player.movement.DisableMovement();
		player.playerLight.shouldLightBeOn = true;
		if (oilLighter.isOn)
		{
			oilLighter.TurnOnLight();
		}
		else
		{
			playerLightFlicker.StartBurst(1.5f, finishOn: true);
			yield return Yield.WaitSeconds(1.5f);
		}
		oilLighter.canTurnOnLight = true;
		particleHeadDust.transform.position = player.Head.gameObject.transform.position;
		particleHeadDust.transform.SetParent(player.Head.gameObject.transform);
		seenStartMazeWall = true;
		while (!seenMovingMazeWall)
		{
			yield return null;
		}
		GameController.instance.audioController.PlayBadSting(STINGS_BAD.BAD_SOFT_STING_01, 0.8f);
		seenStartMazeWall = false;
		while (!seenStartMazeWall)
		{
			yield return null;
		}
		mazeMovingWall.GetComponent<Renderer>().enabled = false;
		seenMovingMazeWall = false;
		while (!seenMovingMazeWall)
		{
			yield return null;
		}
		mazeMovingWall.SetActive(value: false);
		player.movement.EnableMovement();
		GameController.instance.audioController.persistentMusicPlayer.FadeIn(mazeMusic, 1f, 3f, loop: true);
		player.playerAudio.FadeOut(3f);
		while (!startedFire1)
		{
			yield return null;
		}
		UnityEngine.Debug.Log("Started Fire 1");
		GameController.instance.audioController.PlayBadSting(STINGS_BAD.BAD_STING_03, 0.5f);
		player.playerLight.shouldLightBeOn = false;
		if (oilLighter.isOn)
		{
			oilLighter.TurnOffLight();
		}
		else
		{
			playerLightFlicker.StartBurst(0.25f, finishOn: false);
			yield return Yield.WaitSeconds(0.25f);
		}
		oilLighter.canTurnOnLight = false;
		float fireTimer = 0f;
		bool shownHint = false;
		while (!fire1.putOut)
		{
			if (fireTimer > 8f && !shownHint)
			{
				UnityEngine.Debug.Log("Showing Fire Hint");
				player.HandMenu.OpenStraightToBook(NotebookPages.Q07);
				player.watch.WatchHintWithSFX(3f, SFXAlertType.ALERT);
				StartCoroutine(CheckMenuOpen());
				shownHint = true;
			}
			else
			{
				fireTimer += Time.deltaTime;
			}
			yield return null;
		}
		if (oilLighter.isOn)
		{
			oilLighter.TurnOnLight();
		}
		else
		{
			playerLightFlicker.StartBurst(0.5f, finishOn: true);
			yield return Yield.WaitSeconds(0.5f);
		}
		player.playerLight.shouldLightBeOn = true;
		oilLighter.canTurnOnLight = true;
		if ((bool)player.watch)
		{
			player.watch.CancelWatchHint();
			player.watch.CancelWatchHintWithSFX();
			player.HandMenu.CancelStraightToKit();
			player.HandMenu.CancelStraightToBook();
		}
		StopCoroutine("CheckMenuOpen");
		UnityEngine.Debug.Log("Fire 1 Put Out");
		while (!inBox)
		{
			yield return null;
		}
		floatingSample01.transform.position = floataudioLocation[4].position;
		floatAudio01.Play(patientMazeTaunt[0]);
		GameController.instance.audioController.PlayBadSting(STINGS_BAD.BAD_SOFT_STING_03, 0.8f);
		fire1.gameObject.SetActive(value: false);
		UnityEngine.Debug.Log("In Maze Box");
		while (!seenBoxFakeWall)
		{
			yield return null;
		}
		boxInWallTrigger.SetActive(value: true);
		while (!seenBoxWall)
		{
			yield return null;
		}
		mazePart2.SetActive(value: true);
		mazePart2OOB.SetActive(value: true);
		player.playerAudio.FadeIn(corridorMusicBuild, 0.7f, 8f, loop: true);
		UnityEngine.Debug.Log("Seen Maze Box Wall");
		mazePart1.SetActive(value: false);
		mazePart1OOB.SetActive(value: false);
		while (!startedFire2)
		{
			yield return null;
		}
		GameController.instance.audioController.SnapAllOpen(1f);
		UnityEngine.Debug.Log("Fire 2 Started");
		player.playerLight.shouldLightBeOn = false;
		if (oilLighter.isOn)
		{
			oilLighter.TurnOffLight();
		}
		else
		{
			playerLightFlicker.StartBurst(0.25f, finishOn: false);
			yield return Yield.WaitSeconds(0.25f);
		}
		oilLighter.canTurnOnLight = false;
		while (!fire2.putOut)
		{
			yield return null;
		}
		if (oilLighter.isOn)
		{
			oilLighter.TurnOnLight();
		}
		else
		{
			playerLightFlicker.StartBurst(0.5f, finishOn: true);
			yield return Yield.WaitSeconds(0.5f);
		}
		player.playerLight.shouldLightBeOn = true;
		oilLighter.canTurnOnLight = true;
		UnityEngine.Debug.Log("Fire 2 Put Out");
		patient.transform.SetParent(arenaRoom.transform);
		patient.transform.position = patientPos03.position;
		patient.transform.rotation = patientPos03.rotation;
		finalFirePit.SwitchLight(switchOn: false);
		arenaCorridorDoor.SetActive(value: true);
		while (!atMazeEnd)
		{
			yield return null;
		}
		chairEasterEgg.SetActive(value: true);
		GameController.instance.audioController.persistentMusicPlayer.FadeOut(3f);
		arenaBlocker.SetActive(value: true);
		particleHeadDust.transform.SetParent(mazeRoom.transform);
		UnityEngine.Debug.Log("Completed Maze");
	}

	private IEnumerator Exorcism()
	{
		floatingSample01.transform.position = lockedDoorHandle.gameObject.transform.position;
		floatAudio01.Play(voEndMaze);
		ronove.transform.SetParent(arenaRoom.transform);
		ronove.transform.position = ronovePosArena.position;
		ronove.transform.rotation = ronovePosArena.rotation;
		UnityEngine.Debug.Log("STARTED THE FINAL CORRIDOR");
		while (!inArenaCorridor)
		{
			yield return null;
		}
		GameController.instance.currentRoom.SwitchOffOOB();
		GameController.instance.currentRoom = arenaRoom;
		arenaOOB.SetActive(value: true);
		mazeRoom.UpdateColliders(enabled: true);
		mazeRoom.associatedParentGameObject.SetActive(value: false);
		mazeRoom.playerInRoom = false;
		arenaRoom.UpdateColliders(enabled: false);
		arenaRoom.associatedParentGameObject.SetActive(value: true);
		arenaRoom.playerInRoom = true;
		mazeRoom.gameObject.SetActive(value: false);
		GameController.instance.currentRoom.SwitchOnOOB();
		patient.SetActive(value: true);
		patientAnim.SetTrigger("UprightIdle");
		patientAnim.SetBool("TransitionToIdle", value: false);
		patientLookAt.looking = false;
		inCell = false;
		while (!inCell)
		{
			yield return null;
		}
		GameController.instance.audioController.SnapSpatialEcho(0.1f);
		UnityEngine.Debug.Log("In the Arena Cell");
		patientAnim.SetTrigger("ArenaLook");
		patientEyeRenderer.sharedMaterial.SetColor("_EmissionColor", UnityEngine.Color.white);
		patientMaskHospitalAnim.SetBool("Talking", value: true);
		patientAudioSource.Play(patientIntoArenaClip);
		yield return Yield.WaitSeconds(0.75f);
		patientMaskHospitalAnim.SetBool("Talking", value: false);
		floatingSample01.transform.position = patientAudioSource.transform.position;
		floatAudio01.PlayLoop(reactionLoop);
		floatAudio01.m_AudioSource.Pause();
		mazePart2.SetActive(value: false);
		waitForCross = true;
		waitForExItem = true;
		while (waitForExItem)
		{
			yield return StartCoroutine(ExorcismResponse());
		}
		patientAudioSource.Play(patientToolClip2);
		waitForExItem = true;
		while (waitForCross || !inCell)
		{
			yield return StartCoroutine(ExorcismResponse());
		}
		floatAudio01.StopLoop();
		patientAnim.SetBool("TransitionToIdle", value: true);
		interactableCross.LockToHand(isLocked: true);
		ghostArm02.SetActive(value: true);
		player.playerAudio.FadeOut(4f);
		player.movement.DisableMovement();
		UnityEngine.Debug.Log("Ready for Exorcism 01");
		patientAnim.SetTrigger("UprightEx01");
		patientAudioSource.PlayLoop(voPainLoop, 0.75f);
		patientMaskHospitalAnim.SetBool("Talking", value: true);
		exorcismComplete = false;
		StartCoroutine(PerformExorcism(realExorcism: false, slowMo: false));
		while (tuneCross.currentTuneTarget < 1)
		{
			yield return null;
		}
		ghostArm01.SetActive(value: true);
		patientAnim.SetTrigger("UprightEx02");
		tuneCross.ShootBeam(withAudio: false);
		patientAudioSource.PlayOne(voPain[0]);
		ghostArm02.GetComponent<Animator>().SetTrigger("Dead");
		StartCoroutine(Dissolve(2, 3f));
		finalFirePit.Fade(on: true, 3f);
		lightArenaCell.Fade(on: false, 3f);
		finalPitObject.SetActive(value: true);
		fire01.gameObject.SetActive(value: true);
		fire02.gameObject.SetActive(value: true);
		fire01.Play();
		fire02.Play();
		StartCoroutine(ShakeCamera());
		StartCoroutine(ShakeFloorTiles());
		shakeAmount = 0.02f;
		while (tuneCross.currentTuneTarget < 2)
		{
			yield return null;
		}
		patientMaskGhost.SetActive(value: true);
		tuneCross.ShootBeam(withAudio: false);
		patientAnim.SetTrigger("UprightEx03");
		patientAudioSource.PlayOne(voPain[1]);
		ghostArm01.GetComponent<Animator>().SetTrigger("Dead");
		StartCoroutine(Dissolve(1, 3f));
		shakeAmount = 0.03f;
		while (!exorcismComplete)
		{
			yield return null;
		}
		patientAudioSource.PlayOne(voPain[2]);
		patientMaskHospitalAnim.SetBool("Talking", value: false);
		StartCoroutine(Dissolve(4, 3f));
		tuneCross.StartLightTarget(playerStartPosition);
		yield return Yield.WaitSeconds(2f);
		lightArenaCell.Loop(0.15f, 0.075f);
		finalFirePit.Fade(on: false, 1f);
		fire01.Stop();
		fire02.Stop();
		cameraShake = false;
		GameController.instance.audioController.SnapAllOpen(0.1f);
		yield return Yield.WaitSeconds(0.5f);
		finalPitObject.SetActive(value: false);
		floatingSample01.transform.position = ronove.transform.position + new Vector3(0f, 2f, 0f);
		floatAudio01.Play(voCantHaveHerRonoveReveal);
		yield return Yield.WaitSeconds(2.1f);
		tuneCross.StopBackground();
		tuneCross.StopSFX();
		tuneCross.StopLightTarget();
		tuneCross.TheLight(isEnabled: false);
		GameController.instance.audioController.PlayBadSting(STINGS_BAD.BAD_STING_05);
		patient.SetActive(value: false);
		ronoveAnim.SetTrigger("UprightBed");
		ronove.SetActive(value: true);
		arenaCorridorLight01.highIntensity = 0.7f;
		arenaCorridorLight02.highIntensity = 0.7f;
		arenaCorridorLight03.highIntensity = 0.7f;
		arenaCorridorLight01.lowIntensity = 0f;
		arenaCorridorLight02.lowIntensity = 0f;
		arenaCorridorLight03.lowIntensity = 0f;
		yield return Yield.WaitSeconds(1f);
		lightArenaCell.SwitchLight(switchOn: false);
		yield return Yield.WaitSeconds(0.5f);
		ronove.SetActive(value: false);
		fauxWalls.SetActive(value: true);
		lightFauxCell.StartBurst(0.8f, finishOn: true);
		while (floorShaking)
		{
			yield return null;
		}
		ResetFloorTiles();
		UnityEngine.Debug.Log("FINISHED 1st EXORCISM");
	}

	private IEnumerator FinalExorcism()
	{
		UnityEngine.Debug.Log("Final Ex!");
		bool repeat = true;
		GameObject[] array = patientHandcuffs;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(value: false);
		}
		patientMask.SetActive(value: true);
		patientMask.GetComponent<Renderer>().shadowCastingMode = ShadowCastingMode.Off;
		patientMask.transform.localPosition = patientShadowMaskFinalPos.localPosition;
		bool firstTime = true;
		BoxCollider patientCollider = patient.GetComponent<BoxCollider>();
		patientCollider.size = new Vector3(2.5f, 3.5f, 0.2f);
		patientMask.GetComponent<Renderer>().sharedMaterial = patientMaskDissolveMat;
		floatingSample01.transform.position = ronoveLightFinal.gameObject.transform.position;
		player.playerAudio.FadeIn(agroBuildMusic, 0.6f, 5f, loop: true);
		while (repeat)
		{
			if (!patient.activeInHierarchy)
			{
				patient.SetActive(value: true);
			}
			LeanTween.cancel(patient);
			patient.transform.SetParent(arenaRoom.transform);
			patient.transform.position = patientPos04.position;
			patient.transform.rotation = patientPos04.rotation;
			arenaCorridorLight02.SwitchLight(switchOn: false);
			UnityEngine.Debug.Log("Start of repeat");
			if (firstTime)
			{
				patientAnim.SetTrigger("Door");
				floatAudio01.Play(patientCorridor);
				cellArenaCorridorTrigger.SetActive(value: true);
				waitForArenaCorridorCheck = false;
				while (!waitForArenaCorridorCheck)
				{
					yield return null;
				}
				arenaCorridorLight01.SwitchLight(switchOn: true);
				lightFauxCell.SwitchLight(switchOn: false);
				yield return Yield.WaitSeconds(1f);
				UnityEngine.Debug.Log("Corridor Check Complete");
			}
			arenaCorridorLight01.StartBurst(2f, finishOn: false);
			floatAudio01.Play(patientCorridorScream);
			patientAnim.SetTrigger("Run");
			yield return Yield.WaitSeconds(0.1f);
			LeanTween.move(patient, patientFinalPosRun, 6f);
			float startTime = Time.time;
			float failTime = 4f;
			bool calledSecondLight = false;
			int layerMask = 2048;
			bool readyToExorcise = false;
			while (true)
			{
				if (!readyToExorcise)
				{
					Vector3 vector = cross.transform.TransformDirection(Vector3.up);
					UnityEngine.Debug.DrawRay(cross.transform.position, vector * 100f);
					if (Physics.Raycast(cross.transform.position, vector, out var hitInfo, 100f, layerMask) && hitInfo.collider.gameObject == patient)
					{
						readyToExorcise = true;
					}
					if (Time.time >= startTime + 2f && !calledSecondLight)
					{
						arenaCorridorLight02.SwitchLight(switchOn: true, flickerOn: true);
						calledSecondLight = true;
					}
					if (Time.time >= startTime + failTime)
					{
						UnityEngine.Debug.Log("Out of time, Jumping to reset.");
						break;
					}
					yield return null;
					continue;
				}
				exorcismComplete = false;
				crossCharged = false;
				StartCoroutine(PerformExorcism(realExorcism: true, slowMo: false));
				StartCoroutine(ShakeCamera());
				shakeAmount = 0.02f;
				while (true)
				{
					if (!crossCharged)
					{
						if (Time.time >= startTime + failTime)
						{
							UnityEngine.Debug.Log("Out of time, Jumping to reset.");
							break;
						}
						yield return null;
						continue;
					}
					patientAnim.SetTrigger("RunCover");
					tuneCross.StartLightTarget(patient);
					while (!tuneCross.hitSuccess)
					{
						if (Time.time >= startTime + failTime)
						{
							UnityEngine.Debug.Log("Out of time, Jumping to reset.");
							break;
						}
						yield return null;
					}
					break;
				}
				break;
			}
			if (Time.time >= startTime + failTime)
			{
				player.screenFX.BlurScreen(enabled: true);
				player.screenFX.Fade(UnityEngine.Color.black, 1f);
				StopCoroutine("PerformExorcism");
				tuneCross.StopAll();
				cameraShake = false;
				arenaCorridorLight02.SwitchLight(switchOn: false);
				yield return new WaitForSecondsRealtime(1f);
				player.screenFX.Fade(UnityEngine.Color.clear, 0.1f);
				player.screenFX.BlurScreen(enabled: false);
				firstTime = false;
				UnityEngine.Debug.Log("Final Ex OUT OF TIME, reseting");
				continue;
			}
			UnityEngine.Debug.Log("EXORCISM COMPLETED!");
			while (Time.time < startTime + failTime)
			{
				yield return null;
			}
			tuneCross.ShootBeam();
			LeanTween.cancel(patient);
			player.playerAudio.FadeOut(0.25f);
			patientCollider.size = new Vector3(0.4f, 1.6f, 0.2f);
			patientEyeRenderer.sharedMaterial.SetColor("_EmissionColor", UnityEngine.Color.black);
			patientAnim.SetTrigger("Dead");
			StartCoroutine(Dissolve(3, 3f));
			arenaCorridorLight01.lowIntensity = 0f;
			arenaCorridorLight02.lowIntensity = 0f;
			arenaCorridorLight03.lowIntensity = 0f;
			allAudio = UnityEngine.Object.FindObjectsOfType(typeof(AudioSource)) as AudioSource[];
			SlowTime(0.25f);
			inSlowMo = true;
			arenaCorridorLight03.DestroyLight(0.5f);
			yield return Yield.WaitSeconds(0.125f);
			arenaCorridorLight02.DestroyLight(0.5f);
			yield return Yield.WaitSeconds(0.125f);
			arenaCorridorLight01.DestroyLight(0.5f);
			yield return Yield.WaitSeconds(0.65f);
			break;
		}
		exorcismInOne = firstTime;
		patientMask.GetComponent<Renderer>().shadowCastingMode = ShadowCastingMode.ShadowsOnly;
		patientMask.SetActive(value: false);
		cameraShake = false;
		yield return Yield.WaitSeconds(0.25f);
		floatingSample01.transform.position = patientFinalPosRun.position + new Vector3(-2.5f, 1f, 0f);
		floatAudio01.Play(ronoveDead);
		floatAudio01.m_AudioSource.pitch = 0.6f;
		ronove.transform.position = patientFinalPosRun.position + new Vector3(-5.25f, 0f, 0f);
		ronove.transform.rotation = patient.transform.rotation;
		patient.SetActive(value: false);
		ronove.SetActive(value: true);
		ronoveAnim.SetTrigger("Dead");
		LeanTween.moveX(ronove, ronove.transform.position.x + 2f, 6f);
		yield return Yield.WaitSeconds(0.75f);
		GameController.instance.audioController.persistentMusicPlayer.FadeIn(musicEnding, 1f, 6f, loop: true);
		GameController.instance.audioController.persistentMusicPlayer.m_AudioSource.pitch = 1f;
		ronoveLightFinal.Fade(on: true, 1f);
		yield return Yield.WaitSeconds(0.85f);
		ronoveParticles.gameObject.SetActive(value: true);
		StartCoroutine(RonoveDissolve(1f, 3f));
		ronoveLightFinal.Fade(on: false, 8f);
		yield return Yield.WaitSeconds(0.5f);
		ronoveMask.transform.position = ronoveMaskPosition.transform.position;
		ronoveMask.transform.rotation = ronoveMaskPosition.transform.rotation;
		ronoveMask.SetActive(value: true);
		Rigidbody component = ronoveMask.GetComponent<Rigidbody>();
		component.isKinematic = false;
		component.AddForce(new Vector3(1.25f, 0f, 0f), ForceMode.Impulse);
		ronoveMaskPosition.SetActive(value: false);
		yield return Yield.WaitSeconds(4f);
		player.screenFX.Fade(UnityEngine.Color.black, 0.75f);
		yield return Yield.WaitSeconds(1f);
		SlowTime(1f);
		inSlowMo = false;
		GameController.instance.currentRoom.SwitchOffOOB();
		GameController.instance.currentRoom = cellRoom;
		arenaRoom.UpdateColliders(enabled: true);
		arenaRoom.associatedParentGameObject.SetActive(value: false);
		arenaRoom.playerInRoom = false;
		cellRoom.UpdateColliders(enabled: false);
		cellRoom.associatedParentGameObject.SetActive(value: true);
		cellRoom.playerInRoom = true;
		corridorRoom.associatedParentGameObject.SetActive(value: true);
		fakeCellRoom.SetActive(value: false);
		array = combinedMeshesToDisable;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(value: true);
		}
		UnityEngine.Debug.Log("Moving Player to Cell");
		player.movement.ForceTeleport(playerFinalPos.position);
		cellLight.SwitchLight(switchOn: true);
		replacementCieling.SetActive(value: false);
		originalCieling.SetActive(value: true);
		shrinkingWall2.SetActive(value: false);
		cellMoths.SetActive(value: false);
		patient.SetActive(value: false);
		patientEnd.SetActive(value: true);
		patientEnd.GetComponent<Animator>().SetTrigger("Corner");
		floatingSample01.transform.position = patientEnd.transform.position + new Vector3(0f, 1f, 0f);
		floatAudio01.Play(voFinished);
		HUD.Instance.PlaySubtitles(voFinished.name, hasPriority: true);
		yield return Yield.WaitSeconds(0.5f);
		player.screenFX.Fade(UnityEngine.Color.clear, 2f);
		yield return Yield.WaitSeconds(1.5f);
		lightControllers[1].FlickerLights(0.75f, endOn: true);
		yield return Yield.WaitSeconds(1.5f);
		lightControllers[4].FlickerLights(0.75f, endOn: true);
		yield return Yield.WaitSeconds(3f);
		LeanTween.rotateLocal(securityDoor2.transform.parent.gameObject, new Vector3(0f, -30f, 0f), 2f).setEaseOutQuad();
		floatingSample01.transform.position = securityDoor2.gameObject.transform.position;
		floatAudio01.Play(doorCreakCellSfx);
		yield return Yield.WaitSeconds(2f);
		GameController.instance.audioController.persistentMusicPlayer.FadeOut(20f);
		player.screenFX.Fade(UnityEngine.Color.black, 3f);
		GameController.instance.audioController.SnapMute(3f);
		yield return Yield.WaitSeconds(4f);
		interactableCross.LockToHand(isLocked: false);
		interactableCross.CanAttach = false;
		if (player.LeftHand.CurrentlyInteracting == interactableCross)
		{
			player.LeftHand.ForceDropItem();
			player.LeftHand.CurrentlyInteracting = null;
			player.LeftHand.CurrentlyHoveringOver.Remove(interactableCross);
		}
		else if (player.RightHand.CurrentlyInteracting == interactableCross)
		{
			player.RightHand.ForceDropItem();
			player.RightHand.CurrentlyInteracting = null;
			player.RightHand.CurrentlyHoveringOver.Remove(interactableCross);
		}
		interactableCross.respawnTimer = 0.5f;
		yield return Yield.WaitSeconds(2f);
		interactableCross.respawnTimer = 5f;
		interactableCross.CanAttach = true;
		GameController.instance.levelCompletionManager.SetLevelCompletionForCell(exorcismInOne, usedCorrectTools, SaveManager.instance.HasFoundArtifact(ChapterID.CELL), completedLevel: true);
		float num = 0f;
		GrabberArm[] array2 = mazeArms;
		for (int i = 0; i < array2.Length; i++)
		{
			if (array2[i].hitPlayer)
			{
				num += 1f;
			}
		}
		if (num == 0f)
		{
			GameController.instance.achievementManager.UnlockAchievement(AchievementID.HIGH_FIVE);
		}
		GameController.instance.audioController.SnapMute(3f);
		GameController.instance.boundDetection.SwitchOffOOB();
		GameController.instance.GoToSpecificScene(SCENES.PRECINCT, completedPrev: true);
	}

	private IEnumerator RonoveDissolve(float burnDuration, float dissolveDuration)
	{
		for (float t2 = 0f; t2 < burnDuration; t2 += Time.deltaTime)
		{
			ronoveRenderer.material.SetFloat("_Amount", 0.95f / burnDuration * t2);
			yield return Yield.EndOfFrame;
		}
		ronoveRenderer.material.shader = questExorcismBurnPart2Shader;
		for (float t2 = 0f; t2 < dissolveDuration; t2 += Time.deltaTime)
		{
			ronoveRenderer.material.SetFloat("_Amount", Mathf.Clamp(0.95f - 0.55f / dissolveDuration * t2, 0.4f, 0.95f));
			yield return Yield.EndOfFrame;
		}
		ronoveRenderer.gameObject.SetActive(value: false);
	}

	private IEnumerator Dissolve(int objectReference, float dissolveTime)
	{
		Material mat = objectReference switch
		{
			1 => arm01Mat, 
			2 => arm02Mat, 
			3 => patientMaskDissolveMat, 
			_ => patientGhostMaskMat, 
		};
		for (float t = 0f; t < 1f; t += Time.deltaTime / dissolveTime)
		{
			mat.SetFloat("_Dis", t);
			yield return Yield.EndOfFrame;
		}
		switch (objectReference)
		{
		case 1:
			ghostArm01.SetActive(value: false);
			break;
		case 2:
			ghostArm02.SetActive(value: false);
			break;
		case 4:
			patientMaskGhost.SetActive(value: false);
			break;
		}
	}

	private IEnumerator ExorcismResponse()
	{
		player.HandMenu.exKitScript.salt.GetComponent<SaltSprayer>().currentTarget = patient;
		player.HandMenu.exKitScript.water1.GetComponent<HolyWater>().currentTarget = patient;
		player.HandMenu.exKitScript.water2.GetComponent<HolyWater>().currentTarget = patient;
		if (player.HandMenu.exKitScript.salt.GetComponent<SaltSprayer>().hitTarget)
		{
			usedCorrectTools = false;
			UnityEngine.Debug.Log("Hit Patient with Salt Sprayer");
			yield return StartCoroutine(PlayRandomAnim());
		}
		if (player.HandMenu.exKitScript.water1.GetComponent<HolyWater>().hitTarget)
		{
			UnityEngine.Debug.Log("Hit Patient with Holywater 1");
			yield return StartCoroutine(PlayRandomAnim());
			GameController.instance.achievementManager.UnlockAchievement(AchievementID.BAPTISM);
		}
		else if (player.HandMenu.exKitScript.water2.GetComponent<HolyWater>().hitTarget)
		{
			UnityEngine.Debug.Log("Hit Patient with Holywater 2");
			yield return StartCoroutine(PlayRandomAnim());
			GameController.instance.achievementManager.UnlockAchievement(AchievementID.BAPTISM);
		}
		else
		{
			yield return null;
		}
	}

	private IEnumerator PlayRandomAnim()
	{
		switch (UnityEngine.Random.Range(0, 3))
		{
		case 0:
			patientAudioSource.PlayOne(voPain[0]);
			patientAnim.SetTrigger("Flinch1");
			yield return Yield.WaitSeconds(voPain[0].length);
			break;
		case 1:
			patientAudioSource.PlayOne(voPain[1]);
			patientAnim.SetTrigger("Flinch2");
			yield return Yield.WaitSeconds(voPain[1].length);
			break;
		case 2:
			patientAudioSource.PlayOne(voPain[2]);
			patientAnim.SetTrigger("Flinch3");
			yield return Yield.WaitSeconds(voPain[2].length);
			break;
		default:
			patientAudioSource.PlayOne(voPain[2]);
			patientAnim.SetTrigger("Flinch3");
			yield return Yield.WaitSeconds(voPain[2].length);
			break;
		}
		if (atMazeEnd)
		{
			floatAudio01.m_AudioSource.UnPause();
			yield return Yield.WaitSeconds(4.5f);
			floatAudio01.m_AudioSource.Pause();
		}
		player.HandMenu.exKitScript.salt.GetComponent<SaltSprayer>().hitTarget = false;
		player.HandMenu.exKitScript.water1.GetComponent<HolyWater>().hitTarget = false;
		player.HandMenu.exKitScript.water2.GetComponent<HolyWater>().hitTarget = false;
	}

	private void SlowTime(float newTime, float fadeTime = 0f)
	{
		for (int i = 0; i < allAudio.Length; i++)
		{
			allAudio[i].pitch = newTime;
		}
		Time.timeScale = newTime;
	}

	private IEnumerator FadeTime(float newTime, float fadeTime = 0f)
	{
		UnityEngine.Debug.Log("STARTED SLOW TIME FUNCTION");
		AudioSource[] array = UnityEngine.Object.FindObjectsOfType(typeof(AudioSource)) as AudioSource[];
		if (fadeTime > 0f)
		{
			Time.timeScale = 0.25f;
			yield return Yield.EndOfFrame;
			yield break;
		}
		for (int i = 0; i < array.Length; i++)
		{
			array[i].pitch = newTime;
		}
		Time.timeScale = newTime;
	}

	private IEnumerator FinalCorridorLights(float burstTime, float waitTime)
	{
		arenaCorridorLight01.StartBurst(burstTime, finishOn: true);
		yield return Yield.WaitSeconds(waitTime);
		arenaCorridorLight02.StartBurst(burstTime, finishOn: true);
		yield return Yield.WaitSeconds(waitTime);
		arenaCorridorLight03.StartBurst(burstTime, finishOn: true);
	}

	private void RemoveFloorPanels(GameObject[] removeTiles)
	{
		for (int i = 0; i < removeTiles.Length; i++)
		{
			removeTiles[i].SetActive(value: false);
		}
	}

	private IEnumerator ShakeCamera()
	{
		cameraShake = true;
		while (cameraShake)
		{
			Vector3 random = UnityEngine.Random.insideUnitSphere * shakeAmount;
			player.transform.localPosition = player.transform.localPosition + random;
			yield return Yield.WaitSeconds(0.05f);
			player.transform.localPosition = player.transform.localPosition - random;
		}
	}

	private IEnumerator PerformExorcism(bool realExorcism, bool slowMo)
	{
		for (int i = 0; i < 5; i++)
		{
			while (interactableCross.AttachedHand == null)
			{
				yield return null;
			}
			patientAudioSource.PlayOne(patientTauntClips[i]);
			tuneCross.TheLight(isEnabled: true);
			if (realExorcism)
			{
				tuneCross.StartTuning(exorcismTarget, exorcismTargetLocationsFinal, 0.25f, 30f, slowMo, 0.2f);
			}
			else
			{
				tuneCross.StartTuning(exorcismTarget, exorcismTargetLocations, 5f, 30f, slowMo);
			}
			while (!tuneCross.tuneSuccess && !tuneCross.failed)
			{
				yield return null;
			}
			if (tuneCross.tuneSuccess)
			{
				break;
			}
			UnityEngine.Debug.Log("Failed Exorcism");
		}
		if (realExorcism)
		{
			crossCharged = true;
			while (!tuneCross.hitSuccess)
			{
				yield return null;
			}
			yield return Yield.WaitSeconds(3f);
			StopCoroutine("CheckCrossInHand");
		}
		exorcismComplete = true;
	}

	private IEnumerator CheckMenuOpen()
	{
		while (!player.HandMenu.IsActive)
		{
			yield return null;
		}
		if ((bool)player.watch)
		{
			player.watch.CancelWatchHint();
		}
		if ((bool)player.watch)
		{
			player.watch.CancelWatchHintWithSFX();
		}
	}

	private IEnumerator PatientTauntPlayer()
	{
		yield return Yield.WaitSeconds(3f);
		patientAudioSource.Play(patientCellEntry);
		HUD.Instance.PlaySubtitles(patientCellEntry.name, hasPriority: true);
		patientMaskHospitalAnim.SetBool("Talking", value: true);
		yield return Yield.WaitSeconds(patientCellEntry.length);
		patientMaskHospitalAnim.SetBool("Talking", value: false);
		yield return Yield.WaitSeconds(3f);
		if (crossEquipedInCell)
		{
			patientTauntPlayerFinished = true;
			yield break;
		}
		patientAnim.SetTrigger("UprightFocus");
		yield return Yield.WaitSeconds(2f);
		if (!atMazeEnd)
		{
			patientLookAt.looking = true;
		}
		for (int i = 0; i < patientTauntClips.Length; i++)
		{
			if (crossEquipedInCell)
			{
				patientTauntPlayerFinished = true;
				yield break;
			}
			patientAudioSource.Play(patientTauntClips[i]);
			if (waitForCross && i == 4)
			{
				HUD.Instance.PlaySubtitles(patientTauntClips[4].name, hasPriority: true);
			}
			patientMaskHospitalAnim.SetBool("Talking", value: true);
			yield return Yield.WaitSeconds(patientTauntClips[i].length * 0.95f);
			patientMaskHospitalAnim.SetBool("Talking", value: false);
			if (crossEquipedInCell)
			{
				patientTauntPlayerFinished = true;
				yield break;
			}
			yield return Yield.WaitSeconds(9f);
		}
		if (crossEquipedInCell)
		{
			patientTauntPlayerFinished = true;
		}
	}

	public void Update()
	{
		if (!waitForExItem)
		{
			return;
		}
		NVRHand[] hands = player.Hands;
		foreach (NVRHand nVRHand in hands)
		{
			if (!(nVRHand.CurrentlyInteracting != null))
			{
				continue;
			}
			ExorcismItem component = nVRHand.CurrentlyInteracting.gameObject.GetComponent<ExorcismItem>();
			if ((bool)component)
			{
				waitForExItem = false;
				if (component.type == ExorcismItem.ExItemType.CROSS)
				{
					waitForCross = false;
				}
				break;
			}
		}
	}

	private IEnumerator IntercomBeep()
	{
		intercomBeeping = true;
		intercomAudioScript.FadeIn(intercomBeepingClip, 0.5f, 0.5f, loop: true);
		while (intercomBeeping)
		{
			if (!intercomButtonPressed)
			{
				intercomRenderer.sharedMaterial.SetColor("_EmissionColor", redColor);
			}
			yield return Yield.WaitSeconds(1f);
			if (!intercomButtonPressed)
			{
				intercomRenderer.sharedMaterial.SetColor("_EmissionColor", UnityEngine.Color.black);
			}
			yield return Yield.WaitSeconds(2f);
		}
	}

	public void blurScreen()
	{
		player.screenFX.BlurScreen(enabled: true);
		unblurScreen();
	}

	public void unblurScreen()
	{
		StartCoroutine(unblurScreenRoutine());
	}

	private IEnumerator unblurScreenRoutine()
	{
		yield return Yield.WaitSeconds(2f);
		player.screenFX.BlurScreen(enabled: false);
	}

	public override void BeginInteraction(NVRInteractable interactable)
	{
		if (interactable.gameObject == patientBook.gameObject && !foundPatientBook)
		{
			GameController.instance.audioController.PlayBadSting(STINGS_BAD.BAD_SOFT_STING_01, 0.8f);
			foundPatientBook = true;
			GameController.instance.hintManager.RemoveHint(patientBook);
		}
		if (interactable == lockedDoorHandle)
		{
			atMazeEnd = true;
		}
		if (interactable.gameObject == cross && waitForCross)
		{
			waitForCross = false;
		}
		if (interactable.gameObject == polaroid1 && !foundPolaroid1)
		{
			foundPolaroid1 = true;
			GameController.instance.audioController.PlayGoodSting(STINGS_GOOD.GOOD_STING_01, 0.5f);
		}
		if (interactable.gameObject == polaroid2 && !foundPolaroid2)
		{
			foundPolaroid2 = true;
			GameController.instance.audioController.PlayGoodSting(STINGS_GOOD.GOOD_STING_02, 0.5f);
		}
		if (interactable.gameObject == evidenceBag && !foundEvidenceBag)
		{
			foundEvidenceBag = true;
			GameController.instance.audioController.PlayGoodSting(STINGS_GOOD.GOOD_SOFT_STING_03, 0.8f);
			GameController.instance.hintManager.RemoveHint(evidenceBag);
		}
		if (interactable.gameObject == artefact.oilReward && !foundAretfactUpgrade)
		{
			foundAretfactUpgrade = true;
			StartCoroutine(FoundAretfact());
			SaveManager.instance.MarkArtifactFound(ChapterID.CELL);
		}
	}

	private IEnumerator FoundAretfact()
	{
		GameController.instance.audioController.PlayGoodSting(STINGS_GOOD.GOOD_CHOIR_STING_03, 0.75f);
		player.HandMenu.bookScript.updateMaxPage(14);
		player.HandMenu.OpenStraightToBookForArtefact(ArtefactType.LIGHTER_UPGRADE, NotebookPages.Q14);
		player.HandMenu.SwapOutLighterFuel();
		yield return Yield.WaitSeconds(2f);
		player.watch.WatchHintWithSFX(5f, SFXAlertType.ALERT);
		StartCoroutine(RemoveArtifactFromUserHand());
	}

	private void ArtifactUnlocked()
	{
		foundPolaroid1 = true;
		foundPolaroid2 = true;
	}

	private IEnumerator IntercomStatic()
	{
		intercomStaticPlaying = true;
		intercomAudioScript.PlayOne(intercomStaticClip, 0.9f);
		yield return Yield.WaitSeconds(4f);
		intercomStaticPlaying = false;
	}

	private IEnumerator FlickerCorridorLights()
	{
		player.playerLight.shouldLightBeOn = false;
		if (oilLighter.isOn)
		{
			oilLighter.TurnOffLight();
		}
		else
		{
			playerLightFlicker.StartBurst(0.25f, finishOn: false);
		}
		oilLighter.canTurnOnLight = false;
		yield return Yield.WaitSeconds(0.25f);
		mazeLight.StartBurst(1f, finishOn: false);
		yield return Yield.WaitSeconds(1f);
		player.playerLight.shouldLightBeOn = true;
		if (oilLighter.isOn)
		{
			oilLighter.TurnOnLight();
		}
		else
		{
			playerLightFlicker.StartBurst(0.5f, finishOn: true);
		}
		oilLighter.canTurnOnLight = true;
	}

	private IEnumerator MoveRonove()
	{
		ronove.SetActive(value: true);
		LeanTween.move(ronove, new Vector3(-9.38f, -19.924f, 8.18f), 5f);
		yield return Yield.WaitSeconds(5f);
		ronove.SetActive(value: false);
	}

	public override void OnTriggerEnter(Collider collider)
	{
		if (collider.gameObject == intercomButton.gameObject)
		{
			if (!intercomButtonPressed)
			{
				intercomButtonPressed = true;
			}
			else if (intercomMessagePlayed && !intercomStaticPlaying)
			{
				StartCoroutine(IntercomStatic());
			}
		}
		else if (collider.gameObject == cctvButton.gameObject)
		{
			if (!cctvButtonPressed)
			{
				cctvButtonPressed = true;
				cctvContent1.GetComponent<AnimatedTextureUV>().RenderNextImage();
				cctvContent2.GetComponent<AnimatedTextureUV>().RenderNextImage();
			}
		}
		else if (collider.gameObject == cornerTrigger && frog.inPosition)
		{
			inCellCorner = true;
		}
		else if (!insideFirstCell && collider.gameObject == cellTrigger.gameObject)
		{
			insideFirstCell = true;
		}
		else if (!inCell && collider.gameObject == cellArenaTrigger.gameObject)
		{
			inCell = true;
		}
		else if (!inBox && collider.gameObject == boxInTrigger.gameObject)
		{
			inBox = true;
		}
		else if (collider.gameObject == fire1Trigger.gameObject)
		{
			fire1Trigger.gameObject.SetActive(value: false);
			fire1.Play(secondFire: false);
			startedFire1 = true;
		}
		else if (collider.gameObject == fire2Trigger.gameObject)
		{
			fire2Trigger.gameObject.SetActive(value: false);
			startedFire2 = true;
			StartCoroutine(Fire02SetPiece());
		}
		else if (collider.gameObject == mazeRonoveTrigger.gameObject && !fire2.putOut && !movedRonove)
		{
			ronoveShadowParticle.SetActive(value: true);
			floatingSample01.transform.position = floataudioLocation[6].position;
			floatAudio01.Play(growlClip);
			movedRonove = true;
		}
		else if (collider.gameObject == singleArmTrigger.gameObject)
		{
			singleArmTrigger.SetActive(value: false);
			singleArm.SetActive(value: true);
			singleArm.GetComponent<Animator>().SetTrigger("Creep");
			floatingSample01.transform.position = floataudioLocation[3].position;
			floatAudio01.Play(growlClip);
		}
		else if (collider.gameObject == armsTrigger.gameObject)
		{
			StartCoroutine(FlickerCorridorLights());
			armsTrigger.SetActive(value: false);
			GrabberArm[] array = mazeArms;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].gameObject.SetActive(value: true);
			}
			GameController.instance.audioController.PlayBadSting(STINGS_BAD.BAD_SOFT_STING_03, 0.8f);
		}
		else if (collider.gameObject == exitMazeTrigger.gameObject && !mazeDoorClosed)
		{
			mazeDoorClosed = true;
		}
		if (collider.gameObject == corridorTrigger.gameObject && !inArenaCorridor)
		{
			inArenaCorridor = true;
			UnityEngine.Debug.Log("Final COrridor tieoufgbkiefjbswfglubsk");
		}
		if (collider.gameObject == handZoneTrigger.gameObject)
		{
			handZoneTrigger.SetActive(value: false);
		}
		if (collider.gameObject == arenaCorridorLight01Trigger.gameObject)
		{
			arenaCorridorLight01Trigger.SetActive(value: false);
			StartCoroutine(ArenaCorridorLight1Triggered());
		}
		if (collider.gameObject == arenaCorridorLight02Trigger.gameObject)
		{
			arenaCorridorLight02Trigger.SetActive(value: false);
			StartCoroutine(ArenaCorridorLight2Triggered());
		}
		if (collider.gameObject == arenaCorridorLight03Trigger.gameObject)
		{
			arenaCorridorLight03Trigger.SetActive(value: false);
			StartCoroutine(ArenaCorridorLight3Triggered());
		}
	}

	private IEnumerator ArenaCorridorLight1Triggered()
	{
		player.playerLight.shouldLightBeOn = false;
		if (oilLighter.isOn)
		{
			oilLighter.TurnOffLight();
		}
		else
		{
			playerLightFlicker.StartBurst(0.3f, finishOn: false);
		}
		oilLighter.canTurnOnLight = false;
		yield return Yield.WaitSeconds(0.3f);
		arenaCorridorLight02.SwitchLight(switchOn: true);
	}

	private IEnumerator ArenaCorridorLight2Triggered()
	{
		arenaCorridorLight02.SwitchLight(switchOn: false);
		yield return Yield.WaitSeconds(0.1f);
		arenaCorridorLight03.StartBurst(0.25f, finishOn: true);
		LeanTween.rotateLocal(arenaDoor, new Vector3(0f, -179f, 0f), 5f).setEaseInQuart();
		floatingSample01.transform.position = arenaDoor.transform.position;
		floatAudio01.PlayOne(doorCreakClip, 0.8f);
	}

	private IEnumerator ArenaCorridorLight3Triggered()
	{
		arenaCorridorLight03.SwitchLight(switchOn: false);
		yield return Yield.WaitSeconds(0.5f);
		lightArenaCell.StartBurst(3f, finishOn: true);
		yield return Yield.WaitSeconds(0.5f);
	}

	public override void OnTriggerExit(Collider collider)
	{
		if (collider.gameObject == cctvButton.gameObject)
		{
			cctvButtonPressed = false;
		}
		else if (insideFirstCell && collider.gameObject == cellTrigger.gameObject)
		{
			insideFirstCell = false;
		}
		else if (inCell && collider.gameObject == cellArenaTrigger.gameObject)
		{
			inCell = false;
		}
		if (inBox && collider.gameObject == boxInTrigger.gameObject)
		{
			inBox = false;
		}
		if (collider.gameObject == corridorTrigger.gameObject && inArenaCorridor && !arenaCorridorLight03Trigger.activeInHierarchy)
		{
			arenaCorridorLight03.SwitchLight(switchOn: false);
		}
	}

	private IEnumerator Fire02SetPiece()
	{
		yield return Yield.WaitSeconds(0.5f);
		fire2.Play(secondFire: true);
		patientUnderFloor.SetActive(value: true);
		floatingSample01.transform.position = floataudioLocation[5].transform.position;
		floatAudio01.Play(ronoveDead);
		GameController.instance.audioController.PlayBadSting(STINGS_BAD.BAD_STING_05);
		yield return Yield.WaitSeconds(3.5f);
		if (patientUnderFloor.activeInHierarchy)
		{
			patientUnderFloor.SetActive(value: false);
		}
	}

	public override void OnSightTriggerEnter(Collider other)
	{
		if (other.gameObject == boxInWallTrigger && !seenBoxWall && inBox)
		{
			seenBoxWall = true;
		}
		else if (other.gameObject == shrinkingWall2 && insideFirstCell && !seenMovedWall)
		{
			GameController.instance.audioController.PlayBadSting(STINGS_BAD.BAD_SOFT_STING_03, 0.7f);
			seenMovedWall = true;
		}
		else if (other.gameObject == windowTrigger1 && !seenWindowWomen && seenPatientOnCCTV)
		{
			seenWindow1 = true;
			if (seenWindow2)
			{
				seenWindowWomen = true;
			}
		}
		else if (other.gameObject == windowTrigger2 && !seenWindowWomen && seenPatientOnCCTV)
		{
			seenWindow2 = true;
			if (seenWindow1)
			{
				seenWindowWomen = true;
			}
		}
		else if (other.gameObject == cellArenaCorridorTrigger && !waitForArenaCorridorCheck)
		{
			waitForArenaCorridorCheck = true;
		}
		else if (other.gameObject == mazeMovingWall && seenStartMazeWall)
		{
			seenMovingMazeWall = true;
		}
		else if (other.gameObject == mazeStartWall && seenMovingMazeWall)
		{
			seenStartMazeWall = true;
		}
	}

	private IEnumerator FlickerRonoveCCTV()
	{
		ronove.transform.position = ronovePosBehindPatient.transform.position;
		ronove.transform.rotation = ronovePosBehindPatient.transform.rotation;
		ronove.SetActive(value: true);
		yield return Yield.WaitSeconds(0.25f);
		ronove.SetActive(value: false);
	}

	public override void OnSightTriggerExit(Collider other)
	{
		if (other.gameObject == windowTrigger1 && !seenWindowWomen)
		{
			seenWindow1 = false;
		}
		else if (other.gameObject == windowTrigger2 && !seenWindowWomen)
		{
			seenWindow2 = false;
		}
		if (other.gameObject == cellBackWall && insideFirstCell)
		{
			seenBackWall = false;
		}
	}

	public override void OnSightTriggerStay(Collider other)
	{
		if (other.gameObject == boxInFakeWallTrigger && !seenBoxFakeWall && inBox)
		{
			seenBoxFakeWall = true;
		}
		if (other.gameObject == cctvTrigger && Vector3.Distance(cctvTrigger.transform.position, player.Head.gameObject.transform.position) < 2f)
		{
			if (!seenPatientOnCCTV && foundPatientBook)
			{
				seenPatientOnCCTV = true;
			}
			if (!foundPatientBook && !seenRononveCCTV)
			{
				StartCoroutine(FlickerRonoveCCTV());
				seenRononveCCTV = true;
			}
		}
		if (other.gameObject == cellBackWall && insideFirstCell)
		{
			seenBackWall = true;
		}
	}

	private IEnumerator ShakeFloorTiles()
	{
		floorShaking = true;
		StartCoroutine(RotateFloorEdges(reset: false));
		for (int i = 0; i < finalFloorPanels.Length; i++)
		{
			if (finalFloorPanels[i].activeInHierarchy)
			{
				finalFloorPanels[i].AddComponent<CellTileController>().WobbleFall();
			}
			if (i % 6 == 0)
			{
				if (i < 90)
				{
					yield return Yield.WaitSeconds(0.05f);
				}
				else
				{
					yield return Yield.WaitSeconds(0.1f);
				}
			}
		}
		floorShaking = false;
	}

	private IEnumerator RotateFloorEdges(bool reset)
	{
		for (int i = 0; i < finalFloorEdgePanels.Length; i++)
		{
			if (reset)
			{
				finalFloorEdgePanels[i].transform.localEulerAngles = new Vector3(0f, finalFloorEdgePanels[i].transform.localEulerAngles.y, 0f);
				continue;
			}
			yield return Yield.WaitSeconds(UnityEngine.Random.Range(0f, 0.2f));
			LeanTween.rotate(finalFloorEdgePanels[i], finalFloorEdgePanels[i].transform.eulerAngles + finalFloorEdgePanelsRotation[i] * UnityEngine.Random.Range(20f, 40f), 0.2f);
		}
	}

	private void ResetFloorTiles()
	{
		StopCoroutine("ShakeFloorTiles");
		StartCoroutine(RotateFloorEdges(reset: true));
		for (int i = 0; i < finalFloorPanels.Length; i++)
		{
			if (finalFloorPanels[i].activeInHierarchy)
			{
				CellTileController component = finalFloorPanels[i].GetComponent<CellTileController>();
				if ((bool)component)
				{
					component.Reset();
				}
			}
		}
	}

	private IEnumerator FadeArenaFloor(bool fadeIn)
	{
		if (fadeIn)
		{
			UnityEngine.Color pitColor = default(UnityEngine.Color);
			Renderer firePitRenderer = floorPit01.GetComponent<Renderer>();
			firePitRenderer.sharedMaterial.SetColor("_EmissionColor", UnityEngine.Color.black);
			floorPit01.SetActive(value: true);
			while (pitColor.a < 1f)
			{
				float num = Mathf.Clamp01(Time.deltaTime / 2f);
				pitColor.r += num;
				pitColor.g += num;
				pitColor.b += num;
				pitColor.a += num;
				firePitRenderer.sharedMaterial.SetColor("_EmissionColor", pitColor);
				yield return null;
			}
		}
		else
		{
			floorPit01.SetActive(value: false);
		}
	}

	private IEnumerator RemoveArtifactFromUserHand()
	{
		float counter = 0f;
		bool inHand = false;
		while (!player.HandMenu.bookScript.isActiveItem)
		{
			if (player.LeftHand.IsInteracting && player.LeftHand.CurrentlyInteracting.gameObject == artefact.oilReward)
			{
				inHand = true;
			}
			if (player.RightHand.IsInteracting && player.RightHand.CurrentlyInteracting.gameObject == artefact.oilReward)
			{
				inHand = true;
			}
			if (inHand)
			{
				counter = 0f;
				inHand = false;
			}
			else
			{
				counter += 1f;
			}
			if (counter > 2f)
			{
				break;
			}
			yield return Yield.WaitSeconds(1f);
		}
		if (player.LeftHand.IsInteracting)
		{
			if (player.LeftHand.CurrentlyInteracting != null && player.LeftHand.CurrentlyInteracting.gameObject == artefact.oilReward)
			{
				LeanTween.alpha(artefact.oilReward, 0f, 1f);
				player.LeftHand.ForceDropItem();
				yield return Yield.EndOfFrame;
				artefact.oilReward.SetActive(value: false);
				player.LeftHand.CurrentlyInteracting = null;
				yield return Yield.EndOfFrame;
				player.LeftHand.CurrentlyHoveringOver.Remove(artefact.oilReward.GetComponent<NVRInteractableItem>());
			}
		}
		else if (player.RightHand.IsInteracting)
		{
			if (player.RightHand.CurrentlyInteracting != null && player.RightHand.CurrentlyInteracting.gameObject == artefact.oilReward)
			{
				LeanTween.alpha(artefact.oilReward, 0f, 1f);
				player.RightHand.ForceDropItem();
				yield return Yield.EndOfFrame;
				artefact.oilReward.SetActive(value: false);
				player.RightHand.CurrentlyInteracting = null;
				yield return Yield.EndOfFrame;
				player.RightHand.CurrentlyHoveringOver.Remove(artefact.oilReward.GetComponent<NVRInteractableItem>());
			}
		}
		else
		{
			LeanTween.alpha(artefact.oilReward, 0f, 0.5f);
			yield return Yield.WaitSeconds(0.5f);
			artefact.oilReward.SetActive(value: false);
		}
		if (!GameController.instance.player.LeftHand.IsInteracting)
		{
			GameController.instance.player.LeftHand.SetAnimation("IdleBool");
		}
		if (!GameController.instance.player.RightHand.IsInteracting)
		{
			GameController.instance.player.RightHand.SetAnimation("IdleBool");
		}
	}

	private IEnumerator DropTile(GameObject tile)
	{
		yield return Yield.WaitSeconds(UnityEngine.Random.Range(0f, 1f));
		LeanTween.moveY(tile, -0.1f, 0.5f).setEaseInElastic();
		yield return Yield.WaitSeconds(0.5f);
		LeanTween.moveY(tile, -2f, 0.5f);
		Vector3 vector = new Vector3(UnityEngine.Random.Range(-30f, 30f), UnityEngine.Random.Range(-30f, 30f), UnityEngine.Random.Range(-30f, 30f));
		LeanTween.rotate(tile, tile.transform.eulerAngles + vector, 1f);
		yield return Yield.WaitSeconds(1f);
		tile.SetActive(value: false);
	}

	private IEnumerator RotateTile(GameObject tile, Vector3 axis)
	{
		yield return Yield.WaitSeconds(UnityEngine.Random.Range(0f, 0.5f));
		LeanTween.rotate(tile, tile.transform.eulerAngles + axis * UnityEngine.Random.Range(20f, 40f), 0.2f);
	}

	private void StartAutoContinue(float time)
	{
		continueCoroutine = AutoContinue(time);
		StartCoroutine(continueCoroutine);
	}

	private void StopAutoContinue()
	{
		StopCoroutine(continueCoroutine);
	}

	private IEnumerator AutoContinue(float time)
	{
		autoContinue = false;
		yield return Yield.WaitSeconds(time);
		autoContinue = true;
	}

	private void RestartLevel()
	{
		StartCoroutine(RestartLevelRoutine());
	}

	private IEnumerator RestartLevelRoutine()
	{
		player.screenFX.Fade(UnityEngine.Color.black, 3f);
		yield return Yield.WaitSeconds(3f);
		if (inSlowMo)
		{
			SlowTime(1f);
		}
		player.MoveToSafeZone();
	}

	public void ExitToPrecinct()
	{
		StartCoroutine(ExitToPrecinctRoutine());
	}

	private IEnumerator ExitToPrecinctRoutine()
	{
		tuneCross.AreaLight(active: false);
		tuneCross.StopBackground();
		tuneCross.StopSFX();
		tuneCross.StopLightTarget();
		tuneCross.TheLight(isEnabled: false);
		PicoLight.enabled = false;
		particleHeadDust.transform.SetParent(mazeRoom.transform);
		if (inSlowMo)
		{
			SlowTime(1f);
		}
		interactableCross.LockToHand(isLocked: false);
		if (player.LeftHand.CurrentlyInteracting == interactableCross)
		{
			player.LeftHand.ForceDropItem();
		}
		else if (player.RightHand.CurrentlyInteracting == interactableCross)
		{
			player.RightHand.ForceDropItem();
		}
		interactableCross.respawnTimer = 0.5f;
		yield return Yield.WaitSeconds(0.5f);
		DynamicGI.UpdateEnvironment();
		GameController.instance.audioController.persistentMusicPlayer.StopLoop();
		GameController.instance.levelCompletionManager.SetLevelCompletionForCell(exorcismInOne, usedCorrectTools: false, SaveManager.instance.HasFoundArtifact(ChapterID.CELL), completedLevel: false);
		GameController.instance.audioController.SnapMute(3f);
		GameController.instance.boundDetection.SwitchOffOOB();
		GameController.instance.GoToSpecificScene(SCENES.PRECINCT);
	}

	private void OnDestroy()
	{
		EventManager.StopListening(EventManager.AvailableEvents.IntroComplete.ToString(), IntroCompleted);
		EventManager.StopListening(EventManager.AvailableEvents.ExitLevelToPrecint.ToString(), ExitToPrecinct);
		EventManager.StopListening(EventManager.AvailableEvents.ArtifactUnlocked.ToString(), ArtifactUnlocked);
	}

	private void DebugCommands()
	{
		if (Input.GetKeyDown(KeyCode.Return))
		{
			switch (debugCount)
			{
			case 0:
				StartCoroutine(SkipIntercom());
				break;
			case 1:
				StartCoroutine(SkipCCTV());
				break;
			case 2:
				StartCoroutine(SkipCell());
				break;
			case 3:
				StartCoroutine(SkipMaze());
				break;
			case 4:
				StartCoroutine(SkipExorcism());
				break;
			}
			debugCount++;
		}
		else if (Input.GetKeyDown(KeyCode.Alpha0))
		{
			StartCoroutine(SkipAll());
		}
	}

	private IEnumerator SkipAll()
	{
		StopAllCoroutines();
		StopCoroutine(SkipIntercom());
		StopCoroutine(SkipCCTV());
		StopCoroutine(SkipCell());
		StopCoroutine(SkipMaze());
		StopCoroutine(SkipExorcism());
		UnityEngine.Debug.Log("SKIPPED ALL");
		yield return null;
	}

	private IEnumerator SkipIntercom()
	{
		StopAllCoroutines();
		UnityEngine.Debug.Log("SKIPPED INTERCOM");
		yield return StartCoroutine(PatientOnCCTV());
		yield return StartCoroutine(IntoTheCell());
		yield return StartCoroutine(Maze());
		yield return StartCoroutine(Exorcism());
		yield return StartCoroutine(FinalExorcism());
	}

	private IEnumerator SkipCCTV()
	{
		StopAllCoroutines();
		securityDoor1.UnlockDoor();
		securityDoor2.UnlockDoor();
		UnityEngine.Debug.Log("SKIPPED CCTV");
		yield return StartCoroutine(IntoTheCell());
		yield return StartCoroutine(Maze());
		yield return StartCoroutine(Exorcism());
		yield return StartCoroutine(FinalExorcism());
	}

	private IEnumerator SkipCell()
	{
		StopAllCoroutines();
		mazeRoom.associatedParentGameObject.SetActive(value: true);
		securityRoom.associatedParentGameObject.SetActive(value: false);
		outsideRoom.SetActive(value: false);
		corridorRoom.associatedParentGameObject.SetActive(value: false);
		cellRoom.associatedParentGameObject.SetActive(value: false);
		player.transform.position = mazeStart.transform.position + new Vector3((player.transform.position - player.Head.transform.position).x, 0f, (player.transform.position - player.Head.transform.position).z);
		UnityEngine.Debug.Log("SKIPPED CELL");
		yield return StartCoroutine(Maze());
		yield return StartCoroutine(Exorcism());
		yield return StartCoroutine(FinalExorcism());
	}

	private IEnumerator SkipMaze()
	{
		StopAllCoroutines();
		mazeRoom.associatedParentGameObject.SetActive(value: false);
		outsideRoom.SetActive(value: false);
		corridorRoom.associatedParentGameObject.SetActive(value: false);
		cellRoom.associatedParentGameObject.SetActive(value: false);
		arenaRoom.associatedParentGameObject.SetActive(value: true);
		atMazeEnd = true;
		player.transform.position = arenaStart.transform.position + new Vector3((player.transform.position - player.Head.transform.position).x, 0f, (player.transform.position - player.Head.transform.position).z);
		patient.transform.SetParent(arenaRoom.transform);
		patient.transform.position = patientPos03.position;
		patient.transform.rotation = patientPos03.rotation;
		patient.SetActive(value: true);
		player.SetPosition(patientFinalPosRun.gameObject);
		UnityEngine.Debug.Log("SKIPPED MAZE");
		yield return StartCoroutine(Exorcism());
		yield return StartCoroutine(FinalExorcism());
	}

	private IEnumerator SkipExorcism()
	{
		atMazeEnd = true;
		StopAllCoroutines();
		UnityEngine.Debug.Log("SKIPPED EXORCISM");
		yield return null;
	}
}
public class ChapelScene : InteractionManager
{
	private bool introComplete;

	private NVRPlayer player;

	private Light playerLight;

	private LightFlicker playerLightFlicker;

	private Light PicoLight;

	private int debugCount;

	private int breakCount;

	[Header("General")]
	[SerializeField]
	private GameObject playerStartPosition;

	[SerializeField]
	private GameObject[] changeLayerObjects;

	[SerializeField]
	private BreakableObject[] breakableGlass;

	[SerializeField]
	private LightController lightControllerMain;

	[SerializeField]
	private LightController lightControllerSide;

	[SerializeField]
	private AudioSource foleyChurch;

	[SerializeField]
	private AudioScript musicPlayer;

	[SerializeField]
	private AudioClip musicBed;

	[SerializeField]
	private AudioClip musicBuild;

	[SerializeField]
	private AudioClip musicPazuzuFound;

	[SerializeField]
	private AudioClip musicPigHeadDrop;

	[SerializeField]
	private AudioClip musicPazuzuFinale;

	[SerializeField]
	private AudioClip pazuzuGrowl_mild;

	[SerializeField]
	private AudioClip pazuzuGrowl_mad;

	[SerializeField]
	private AudioClip pazuzuHiss;

	[SerializeField]
	private AudioClip heartbeat;

	[SerializeField]
	private Renderer confessionBoothMesh;

	[SerializeField]
	private Renderer[] vertexLitShaderSwapouts;

	[SerializeField]
	private Renderer[] vertexLitSecondaryShaderSwapouts;

	private Shader[] orginalShaders;

	private Shader originalConfessionBoothShader;

	private Shader vertexLit;

	private Shader diffuseShader;

	[Header("AudioArray")]
	[SerializeField]
	private Transform[] floataudioLocation;

	[SerializeField]
	private AudioClip[] floatAudio;

	[SerializeField]
	private GameObject floatingSample01;

	private AudioScript floatAudio01;

	[Space]
	[Header("Rooms")]
	[SerializeField]
	private GameObject mainRoom;

	[SerializeField]
	private Room room_mainRoom;

	[SerializeField]
	private GameObject sideRoom;

	[SerializeField]
	private Room room_sideRoom;

	[Space]
	[Header("Fade In")]
	[SerializeField]
	private Transform walkPoint01;

	[SerializeField]
	private Transform walkPoint02;

	[SerializeField]
	private TextMeshProUGUI chapterName;

	[SerializeField]
	private TextMeshProUGUI chapterNumber;

	[Space]
	[Header("Main Room")]
	[SerializeField]
	private GameObject statue;

	[SerializeField]
	private NVRInteractableItem firstMarker;

	[SerializeField]
	private GameObject statueNavMeshBlock;

	[SerializeField]
	private BoxCollider statueCollider;

	[SerializeField]
	private Transform statuePos02;

	[SerializeField]
	private Material endTexture;

	[SerializeField]
	private InteractiveDoor door;

	[SerializeField]
	private Light ambientLight;

	[SerializeField]
	private LightFlicker candleLightSide;

	[SerializeField]
	private GameObject meatHooks;

	[SerializeField]
	private GameObject pigHead01;

	[SerializeField]
	private GameObject pigHead02;

	[SerializeField]
	private GameObject fallingPigHead;

	[SerializeField]
	private ParticleSystem pigsHeadBlood;

	[SerializeField]
	private GameObject pigHeadBloodAudio;

	[SerializeField]
	private Transform pigHeadCrossPosition;

	[SerializeField]
	private GameObject confessionHeadTrigger;

	[SerializeField]
	private GameObject moths;

	[SerializeField]
	private Transform mothPos01;

	[SerializeField]
	private Transform mothPos02;

	[SerializeField]
	private AudioSource fliesSFX;

	[SerializeField]
	private Animator fatherBellRoaches;

	[SerializeField]
	private Animator statueRoaches1;

	[SerializeField]
	private Animator statueRoaches2;

	[SerializeField]
	private Animator statueRoaches3;

	[SerializeField]
	private Animator statueRoaches4;

	[SerializeField]
	private Animator underStatueRoaches1;

	[SerializeField]
	private Animator underStatueRoaches2;

	[SerializeField]
	private AudioClip chairHitsFaceSFX;

	[SerializeField]
	private InteractiveDoor confessionalBoothDoor;

	[SerializeField]
	private GameObject confessionalDoorAdditionalBlocks;

	private WindyDoor confessionWindDoor;

	private bool seenStatue = true;

	[Space]
	[Header("Side Room")]
	[SerializeField]
	private GameObject sideRoomTrigger;

	[SerializeField]
	private GameObject pictureFrameButton;

	[SerializeField]
	private AudioScript clockScript;

	[SerializeField]
	private AudioClip clockClip;

	[SerializeField]
	private AudioClip clockChime;

	[SerializeField]
	private Pendulum clockPendulum;

	[SerializeField]
	private Clock clockController;

	[SerializeField]
	private TapePlayer tapePlayerController;

	[SerializeField]
	private GameObject tapePlayerTopLevel;

	[SerializeField]
	private GameObject tapePlayer;

	[SerializeField]
	private AudioScript tapeSpeakerMainHall;

	[SerializeField]
	private AudioScript tapePlayerScript;

	[SerializeField]
	private AudioClip churchVOFinalP1;

	[SerializeField]
	private AudioClip churchVOFinalP2;

	[SerializeField]
	private GameObject crossPosition;

	[SerializeField]
	private GameObject holyWaterPosition;

	[SerializeField]
	private GameObject saltPosition;

	[SerializeField]
	private GameObject candlePosition;

	[SerializeField]
	private GameObject boxRomePackage;

	[SerializeField]
	private GameObject notebook;

	[SerializeField]
	private GameObject notebookBack;

	[SerializeField]
	private GameObject notebookFront;

	[SerializeField]
	private GameObject notebookRingBinder;

	[SerializeField]
	private GameObject staticExKit;

	[SerializeField]
	private GameObject secretPictureFrame;

	[SerializeField]
	private InteractiveDoor secretPictureFrameHandle;

	[SerializeField]
	private GameObject candlesWhispers;

	[SerializeField]
	private GameObject pazuzuStatue;

	[SerializeField]
	private GameObject candlesPazuzu;

	[SerializeField]
	private LightFlicker[] candleLightPazuzu;

	[SerializeField]
	private Material[] notebookMaterials;

	[SerializeField]
	private Material[] exKitMaterials;

	[SerializeField]
	private GameObject[] lockableItems;

	[SerializeField]
	private Animator pictureFrameRoaches;

	[SerializeField]
	private NVRInteractableItem sourceOfTheNileItem;

	[SerializeField]
	private Material picturesNormal;

	[SerializeField]
	private Material picturesBlood;

	[SerializeField]
	private MeshRenderer[] allPictures;

	[SerializeField]
	private GameObject desk;

	[SerializeField]
	private BustArtifact artefact;

	private Animator priestAnim1;

	private GameObject cross;

	private bool pictureFrameButtonFound;

	private bool foundNotebook;

	private bool foundCross;

	private bool foundKit;

	private bool foundPictureFrame;

	private bool foundFirstExKitItem;

	private bool foundSourceOfTheNile;

	private bool seenBellMove;

	private bool openingConfessionDoor;

	private bool openedConfessionDoor;

	private bool lookingAtPigBell;

	private GameObject holyWater;

	private bool foundHolyWater;

	private bool foundHolyWaterInBowl;

	private GameObject saltSprayer;

	private bool foundSaltSprayer;

	private GameObject lighter;

	private bool foundLighter;

	private OilLighter oilLighter;

	private bool inSideRoom;

	private bool playedTape;

	private bool playingTape;

	private bool crossInHand;

	[Space]
	[Header("Main Room Again")]
	[SerializeField]
	private GameObject exitSideRoomTrigger;

	[SerializeField]
	private GameObject enterMainRoomTrigger;

	[SerializeField]
	private LightFlicker policeStrobeFlicker;

	[SerializeField]
	private LightFlicker pazuzuStrobeFlicker;

	[SerializeField]
	private Light policeStrobe;

	[SerializeField]
	private GameObject policeLightStand1;

	[SerializeField]
	private GameObject policeLightStand2;

	[SerializeField]
	private Light policeLight1;

	[SerializeField]
	private Light policeLight2;

	[SerializeField]
	private Material unlitCandleRackMaterial;

	[SerializeField]
	private MeshRenderer[] candleRackMeshes;

	[SerializeField]
	private Material unlitCandleLooseMaterial;

	[SerializeField]
	private ParticleSystem[] candleFlames;

	[SerializeField]
	private AudioScript firstWhispersScript;

	[SerializeField]
	private AudioClip firstWhispersClip;

	[SerializeField]
	private AudioScript secondWhispersScript;

	[SerializeField]
	private AudioClip secondWhispersClip;

	[SerializeField]
	private AudioScript thirdWhispersScript;

	[SerializeField]
	private AudioClip thirdWhispersClip;

	[SerializeField]
	private AudioScript floatingWhispersScript;

	[SerializeField]
	private AudioClip floatingWhispersClip;

	[SerializeField]
	private AudioClip floatingGrowlClip;

	[SerializeField]
	private GameObject[] floatingWhispersPositions;

	[SerializeField]
	private GameObject pazuzu;

	[SerializeField]
	private GameObject pazuzuParent;

	private Animator pazuzuAnim;

	[SerializeField]
	private GameObject hymmBlock;

	[SerializeField]
	private GameObject hymmBlockTrigger;

	[SerializeField]
	private GameObject flyingCandle01;

	[SerializeField]
	private GameObject flyingCandleBack01;

	[SerializeField]
	private GameObject flyingCandleBack02;

	[SerializeField]
	private GameObject flyingCandleBack03;

	[SerializeField]
	private GameObject bellDead;

	[SerializeField]
	private GameObject bellPig;

	[SerializeField]
	private Transform bellPigPos01;

	[SerializeField]
	private Transform bellPigPos02;

	[SerializeField]
	private Transform bellPigPos03;

	[SerializeField]
	private GameObject bibleSetPiece01;

	[SerializeField]
	private GameObject bibleSetPiece02;

	[SerializeField]
	private GameObject bibleSetPiece03;

	[SerializeField]
	private GameObject[] benches;

	[SerializeField]
	private GameObject lookingAtStageCollider;

	[SerializeField]
	private GameObject lookingAtCandlesCollider;

	[SerializeField]
	private GameObject lookingAtConfessionCollider;

	[SerializeField]
	private GameObject lookingAtNaiveCollider;

	[SerializeField]
	private GameObject lookingAwayFromMaryCollider;

	[SerializeField]
	private GameObject confessionDoor;

	[SerializeField]
	private GameObject confessionDoorHandle;

	[SerializeField]
	private GameObject confessionChair;

	[SerializeField]
	private GameObject benchFront;

	[SerializeField]
	private GameObject hallChair;

	[SerializeField]
	private GameObject naiveChair;

	[SerializeField]
	private GameObject movingBench;

	[SerializeField]
	private Renderer[] emissiveWindows;

	[SerializeField]
	private UnityEngine.Color windowEmission;

	[SerializeField]
	private GameObject tapeBreak;

	[SerializeField]
	private GameObject crossTarget;

	private bool lookingAtBench;

	private Transform confessionChairTrans;

	private Transform benchFrontTrans;

	private bool foundPazuzuStatue;

	private bool exitSideRoom;

	private bool whispersActive;

	private bool facingStage;

	private bool facingConfession;

	private bool facingCandles;

	private bool facingNaive;

	private bool switchedBack;

	private bool lookingAtHymnBoard;

	private bool crucifixPlacedInScene;

	private bool canSeeMary = true;

	private Vector3 candleStartPos1;

	private Quaternion candleStartRot1;

	private Vector3 candleStartPos2;

	private Quaternion candleStartRot2;

	private Vector3 candleStartPos3;

	private Quaternion candleStartRot3;

	private float distanceToHymboard = 3f;

	private InterstitialTitleManager interstitialTitleManager;

	private bool artifactUnlocked;

	[SerializeField]
	public InteractiveDoor interactiveDoor;

	private void Start()
	{
		vertexLit = Shader.Find("Mobile/VertexLit");
		diffuseShader = Shader.Find("Legacy Shaders/Diffuse");
		if (vertexLitShaderSwapouts.Length != 0)
		{
			orginalShaders = new Shader[vertexLitShaderSwapouts.Length];
		}
		EventManager.StartListening(EventManager.AvailableEvents.IntroComplete.ToString(), IntroCompleted);
		EventManager.StartListening(EventManager.AvailableEvents.ArtifactUnlocked.ToString(), ArtifactUnlocked);
		EventManager.StartListening(EventManager.AvailableEvents.BlockingLoad.ToString(), PopulateKit);
		EventManager.StartListening(EventManager.AvailableEvents.ExitLevelToPrecint.ToString(), ExitToPrecinct);
		EventManager.StartListening(EventManager.AvailableEvents.BrokenObject.ToString(), BreakObject);
		EventManager.StartListening(EventManager.AvailableEvents.RestartScene.ToString(), RestartLevel);
		EventManager.StartListening(EventManager.AvailableEvents.ResetProgress.ToString(), ResetProgress);
		player = GameController.instance.player;
		interstitialTitleManager = player.interstitialTitleManager;
		player.HandMenu.BookInMenu(active: false);
		player.HandMenu.KitInMenu(active: false);
		player.movement.DisableEverything();
		playerLight = player.playerLight.GetComponent<Light>();
		PicoLight = player.PicoLight.GetComponent<Light>();
		playerLightFlicker = player.playerLight.GetComponent<LightFlicker>();
		playerLight.enabled = true;
		playerLightFlicker.SwitchLight(switchOn: false);
		playerLightFlicker.ResetIntensity();
		player.playerLight.enabled = true;
		PicoLight.enabled = true;
		Camera componentInChildren = player.Head.GetComponentInChildren<Camera>();
		float[] array = new float[32];
		array[14] = 7f;
		componentInChildren.layerCullDistances = array;
		GameController.instance.hintManager.AddHint(firstMarker);
		if (!policeStrobe.enabled)
		{
			policeStrobe.enabled = true;
		}
		policeStrobe.gameObject.SetActive(value: false);
		if (!pazuzuStrobeFlicker.light.enabled)
		{
			pazuzuStrobeFlicker.light.enabled = true;
		}
		pazuzuStrobeFlicker.SwitchLight(switchOn: false);
		floatAudio01 = floatingSample01.GetComponent<AudioScript>();
		confessionChair.GetComponent<Rigidbody>().constraints = RigidbodyConstraints.FreezeAll;
		confessionChair.GetComponent<BreakableObject>().collisionActive = false;
		hymmBlockTrigger.SetActive(value: false);
		pazuzuAnim = pazuzu.GetComponent<Animator>();
		pazuzuStatue.SetActive(value: false);
		candleStartPos1 = flyingCandleBack01.transform.position;
		candleStartRot1 = flyingCandleBack01.transform.rotation;
		candleStartPos2 = flyingCandleBack02.transform.position;
		candleStartRot2 = flyingCandleBack02.transform.rotation;
		candleStartPos3 = flyingCandleBack03.transform.position;
		candleStartRot3 = flyingCandleBack03.transform.rotation;
		secretPictureFrameHandle.LockDoor();
		LockItems(activeState: false);
		flyingCandleBack01.SetActive(value: false);
		flyingCandleBack02.SetActive(value: false);
		flyingCandleBack03.SetActive(value: false);
		pazuzu.SetActive(value: false);
		bellPig.SetActive(value: false);
		exitSideRoomTrigger.SetActive(value: false);
		lookingAwayFromMaryCollider.SetActive(value: false);
		UnityEngine.Debug.Log("Turning on father bell");
		bellDead.SetActive(value: true);
		bellDead.GetComponent<Animator>().SetTrigger("SeatDead");
		confessionWindDoor = confessionDoor.GetComponentInChildren<WindyDoor>();
		moths.transform.position = mothPos01.position;
		for (int i = 0; i < emissiveWindows.Length; i++)
		{
			emissiveWindows[i].sharedMaterial.SetColor("_EmissionColor", new UnityEngine.Color(0.274f, 0.322f, 0.35f));
		}
		Material[] array2 = notebookMaterials;
		for (int j = 0; j < array2.Length; j++)
		{
			array2[j].SetFloat("_Dissolve", 1f);
		}
		array2 = exKitMaterials;
		for (int j = 0; j < array2.Length; j++)
		{
			array2[j].SetFloat("_Dissolve", 1f);
		}
		GameObject[] array3 = changeLayerObjects;
		for (int j = 0; j < array3.Length; j++)
		{
			array3[j].SetLayer(0);
		}
		SaveManager.instance.MarkChapterStarted(ChapterID.CHAPEL);
		sideRoom.SetActive(value: false);
		StartCoroutine(Master());
	}

	public void BreakObject()
	{
		breakCount++;
		if (breakCount == 3)
		{
			GameController.instance.achievementManager.UnlockAchievement(AchievementID.BULL_IN_A_CHINA_SHOP);
			EventManager.StopListening(EventManager.AvailableEvents.BrokenObject.ToString(), BreakObject);
		}
	}

	public void Update()
	{
		if (Input.GetKeyDown(KeyCode.X))
		{
			OnConfessionalDoorOpen();
		}
		if (Input.GetKeyDown(KeyCode.C))
		{
			TogglePlayerLight();
		}
		if (foundCross)
		{
			AimCross();
		}
		if (openingConfessionDoor)
		{
			if ((double)confessionDoor.transform.localEulerAngles.y < 25.0)
			{
				float num = confessionDoor.transform.localEulerAngles.y / 25f * 0.9f;
				fliesSFX.volume = 0.1f + num;
			}
			if (!openedConfessionDoor && (double)confessionDoor.transform.localEulerAngles.y >= 25.0)
			{
				openedConfessionDoor = true;
				StartCoroutine(ConfessionDoorOpened());
			}
		}
	}

	private void IntroCompleted()
	{
		introComplete = true;
	}

	private IEnumerator Master()
	{
		if (SaveManager.instance.HasFoundArtifact(ChapterID.CHAPEL))
		{
			artefact.setArtifactRevealed();
		}
		GameController.instance.currentRoom = room_mainRoom;
		room_mainRoom.UpdateColliders(enabled: false);
		room_mainRoom.associatedParentGameObject.SetActive(value: true);
		room_mainRoom.playerInRoom = true;
		room_sideRoom.UpdateColliders(enabled: true);
		room_sideRoom.associatedParentGameObject.SetActive(value: false);
		room_sideRoom.playerInRoom = false;
		yield return StartCoroutine(FadeInScene());
		yield return StartCoroutine(SideRoom());
		yield return StartCoroutine(Pazuzu());
		yield return StartCoroutine(FadeOutScene());
	}

	private IEnumerator FadeInScene()
	{
		while (!introComplete)
		{
			yield return null;
		}
		hallChair.GetComponent<Rigidbody>().constraints = RigidbodyConstraints.FreezeAll;
		EventManager.TriggerEvent(EventManager.AvailableEvents.SwitchedScenes.ToString());
		SaveManager.instance.MarkChapterStarted(ChapterID.CHAPEL);
		GameController.instance.audioController.SnapAllOpen(3f);
		StartCoroutine(PlaceExorcismItems());
		clockScript.PlayLoop(clockClip, 0.2f);
		chapterName.transform.parent.gameObject.SetActive(value: true);
		yield return Yield.WaitSeconds(2f);
		player.SetPosition(playerStartPosition);
		player.screenFX.Fade(UnityEngine.Color.clear, 2f);
		yield return Yield.WaitSeconds(2f);
		chapterName.CrossFadeAlpha(0f, 3f, ignoreTimeScale: false);
		chapterNumber.CrossFadeAlpha(0f, 3f, ignoreTimeScale: false);
		StartCoroutine(DisableCanvasAfterFade());
		GameController.instance.audioController.persistentMusicPlayer.FadeOut(5f);
		GameController.instance.boundDetection.SwitchOnOOB();
		player.movement.EnableEverything();
	}

	private IEnumerator DisableCanvasAfterFade()
	{
		yield return Yield.WaitSeconds(3f);
		chapterNumber.transform.parent.gameObject.SetActive(value: false);
	}

	private IEnumerator PlaceExorcismItems()
	{
		StartCoroutine(CrossInit());
		holyWater = player.HandMenu.exKitScript.water1;
		lighter = player.HandMenu.exKitScript.candle;
		saltSprayer = player.HandMenu.exKitScript.salt;
		holyWater.SetActive(value: true);
		saltSprayer.SetActive(value: true);
		lighter.SetActive(value: true);
		holyWater.GetComponent<HolyWater>().canSmash = false;
		holyWater.transform.parent = null;
		holyWater.transform.position = holyWaterPosition.transform.position;
		holyWater.transform.rotation = holyWaterPosition.transform.rotation;
		saltSprayer.transform.parent = null;
		saltSprayer.transform.position = saltPosition.transform.position;
		saltSprayer.transform.rotation = saltPosition.transform.rotation;
		lighter.transform.parent = null;
		lighter.transform.position = candlePosition.transform.position;
		lighter.transform.rotation = candlePosition.transform.rotation;
		ExorcismItem script3 = holyWater.GetComponent<ExorcismItem>();
		while (!script3.isInitilised)
		{
			yield return null;
		}
		holyWater.GetComponent<Rigidbody>().isKinematic = true;
		holyWater.GetComponent<Rigidbody>().useGravity = true;
		script3.inKit = false;
		script3.inEnvironment = true;
		UnityEngine.Object.DontDestroyOnLoad(holyWater);
		player.HandMenu.exKitScript.water2.SetActive(value: false);
		player.HandMenu.exKitScript.water2.GetComponent<ExorcismItem>().inKit = false;
		player.HandMenu.exKitScript.water2.GetComponent<ExorcismItem>().inEnvironment = true;
		script3 = saltSprayer.GetComponent<ExorcismItem>();
		while (!script3.isInitilised)
		{
			yield return null;
		}
		saltSprayer.GetComponent<Rigidbody>().isKinematic = true;
		saltSprayer.GetComponent<Rigidbody>().useGravity = true;
		script3.inKit = false;
		script3.inEnvironment = true;
		script3.saltFull.SetActive(value: true);
		script3.saltHalf.SetActive(value: false);
		UnityEngine.Object.DontDestroyOnLoad(saltSprayer);
		script3 = lighter.GetComponent<ExorcismItem>();
		while (!script3.isInitilised)
		{
			yield return null;
		}
		oilLighter = lighter.GetComponent<OilLighter>();
		oilLighter.canTurnOnLight = false;
		lighter.GetComponent<Rigidbody>().isKinematic = true;
		lighter.GetComponent<Rigidbody>().useGravity = true;
		script3.inKit = false;
		script3.inEnvironment = true;
		script3.lighterFull.SetActive(value: true);
		script3.lighterHalf.SetActive(value: false);
		UnityEngine.Object.DontDestroyOnLoad(lighter);
	}

	private IEnumerator CrossInit()
	{
		cross = player.HandMenu.exKitScript.cross;
		cross.GetComponent<Rigidbody>().isKinematic = true;
		cross.transform.parent = null;
		cross.transform.position = crossPosition.transform.position;
		cross.transform.rotation = crossPosition.transform.rotation;
		ExorcismItem script = cross.GetComponent<ExorcismItem>();
		while (!script.isInitilised)
		{
			yield return null;
		}
		crucifixPlacedInScene = true;
		cross.GetComponent<Rigidbody>().isKinematic = true;
		cross.GetComponent<Rigidbody>().useGravity = true;
		script.inKit = false;
		script.originalPos = Vector3.zero;
		script.originalRot = Quaternion.identity;
		script.inEnvironment = true;
		UnityEngine.Object.DontDestroyOnLoad(cross);
		UnityEngine.Debug.Log("Cross Placed");
	}

	private IEnumerator SideRoom()
	{
		while (!inSideRoom)
		{
			yield return null;
		}
		UnityEngine.Debug.Log("Turning off father bell");
		bellDead.SetActive(value: false);
		fatherBellRoaches.gameObject.SetActive(value: false);
		if (!foundKit)
		{
			GameController.instance.hintManager.RemoveHint(firstMarker);
		}
		GameController.instance.hintManager.AddHint(desk);
		clockScript.gameObject.GetComponent<AudioSource>().volume = 0.2f;
		while (!pictureFrameButtonFound)
		{
			yield return null;
		}
		GameController.instance.hintManager.RemoveHint(desk);
		GameController.instance.hintManager.AddHint(secretPictureFrameHandle);
		foleyChurch.volume = 0.45f;
		tapePlayerController.stopTape();
		HUD.Instance.KillSubtitles();
		yield return Yield.WaitSeconds(3f);
		floatingSample01.transform.position = floataudioLocation[0].position;
		floatAudio01.Play(floatAudio[6]);
		clockScript.StopLoop();
		clockPendulum.Stop();
		clockController.Stop();
		ExorcismItem component = cross.GetComponent<ExorcismItem>();
		component.originalPos = Vector3.zero;
		component.originalRot = Quaternion.identity;
		while (!crossInHand)
		{
			yield return null;
		}
		GameController.instance.hintManager.RemoveHint(secretPictureFrameHandle);
		cross.GetComponent<NVRInteractableItem>().AttachedHand.LongHapticPulse(5f);
		GameController.instance.audioController.PlayBadSting(STINGS_BAD.BAD_STING_04, 0.3f);
		yield return Yield.WaitSeconds(0.1f);
		for (int i = 0; i < emissiveWindows.Length; i++)
		{
			emissiveWindows[i].sharedMaterial.SetColor("_EmissionColor", windowEmission);
			yield return Yield.WaitSeconds(0.1f);
		}
		yield return Yield.WaitSeconds(0.1f);
		pigHead01.transform.SetParent(mainRoom.transform);
		pigHead01.transform.position = pigHeadCrossPosition.position;
		pigHead01.transform.rotation = pigHeadCrossPosition.rotation;
		pigHead02.SetActive(value: false);
		yield return Yield.WaitSeconds(0.1f);
		pigHeadBloodAudio.SetActive(value: false);
		moths.SetActive(value: false);
		statue.SetActive(value: false);
		fliesSFX.gameObject.SetActive(value: false);
		if (!foundSaltSprayer)
		{
			saltSprayer.GetComponent<Rigidbody>().isKinematic = false;
		}
		UnityEngine.Debug.Log("Turn off the lights");
		policeLight1.GetComponent<LightFlicker>().SwitchLight(switchOn: false);
		yield return Yield.WaitSeconds(1f);
		firstWhispersScript.Play(firstWhispersClip);
		lightControllerSide.FlickerLights(2f, endOn: true);
		lightControllerMain.TurnOffLights();
		lightControllerMain.UpdateReflectionProbes();
		yield return Yield.WaitSeconds(2.5f);
		if (!playedTape)
		{
			UnityEngine.Debug.Log("Started Playing the tape");
			tapePlayerController.PlayTape();
		}
		UnityEngine.Debug.Log("Set exit trigger active");
		exitSideRoomTrigger.gameObject.SetActive(value: true);
		while (!exitSideRoom)
		{
			yield return null;
		}
	}

	private IEnumerator Pazuzu()
	{
		UnityEngine.Debug.Log("Exited side room");
		player.HandMenu.BookInMenu(active: true);
		player.HandMenu.KitInMenu(active: true);
		tapePlayerTopLevel.transform.SetParent(mainRoom.transform);
		lightControllerSide.TurnOffLights();
		lightControllerSide.SwitchOffReflectionProbes();
		UnityEngine.Debug.Log("Door is shut");
		lookingAwayFromMaryCollider.SetActive(value: true);
		while (canSeeMary)
		{
			yield return null;
		}
		lookingAwayFromMaryCollider.SetActive(value: false);
		statue.SetActive(value: true);
		seenStatue = false;
		statue.GetComponent<Renderer>().sharedMaterial = endTexture;
		statue.transform.position = statuePos02.position;
		statue.transform.localEulerAngles = new Vector3(-90f, -180f, 0f);
		statueNavMeshBlock.SetActive(value: true);
		statueCollider.enabled = true;
		secondWhispersScript.Play(secondWhispersClip);
		musicPlayer.FadeIn(musicBed, 1f, 3f, loop: true);
		yield return Yield.WaitSeconds(2f);
		door.CloseDoor();
		floatingSample01.transform.position = floataudioLocation[1].position;
		floatAudio01.Play(floatAudio[1]);
		sideRoom.SetActive(value: false);
		tapePlayerScript.FadeOut(1.5f);
		HUD.Instance.KillSubtitles();
		tapeSpeakerMainHall.FadeOut(1.5f);
		crossTarget.transform.parent = floatingWhispersScript.gameObject.transform;
		crossTarget.transform.localPosition = Vector3.zero;
		while (!seenStatue)
		{
			yield return null;
		}
		GameController.instance.audioController.PlayBadSting(STINGS_BAD.BAD_STING_02, 0.4f);
		float startTime2 = Time.time;
		_ = Time.time - startTime2;
		floatingWhispersScript.FadeIn(floatingWhispersClip, 0.6f, 4f, loop: true);
		floatingWhispersScript.gameObject.transform.position = floatingWhispersPositions[0].transform.position;
		MoveFloatingWhisper(1, 5f);
		yield return Yield.WaitSeconds(5f);
		MoveFloatingWhisper(2, 5f);
		yield return Yield.WaitSeconds(5f);
		MoveFloatingWhisper(3, 5f);
		lookingAtHymnBoard = false;
		hymmBlockTrigger.SetActive(value: true);
		while (!lookingAtHymnBoard)
		{
			yield return null;
		}
		hymmBlockTrigger.SetActive(value: false);
		hymmBlock.GetComponent<Rigidbody>().isKinematic = false;
		hymmBlock.GetComponent<Rigidbody>().AddForce(0f, -5f, -0.5f, ForceMode.Impulse);
		hymmBlock.GetComponent<Rigidbody>().AddTorque(-500f, 0f, 0f, ForceMode.Impulse);
		floatingSample01.transform.position = floataudioLocation[7].position;
		floatAudio01.Play(floatAudio[4], 0.8f);
		MoveFloatingWhisper(4, 8f);
		yield return Yield.WaitSeconds(5f);
		lookingAtBench = false;
		while (!lookingAtBench)
		{
			yield return null;
		}
		floatingSample01.transform.position = floataudioLocation[2].position;
		floatAudio01.PlayOne(floatAudio[2]);
		LeanTween.moveLocal(benchFront, new Vector3(0.377f, 0f, -7.81f), 0.8f).setEaseOutCirc();
		LeanTween.rotateLocal(benchFront, new Vector3(0f, 264f, 0f), 0.8f).setEaseOutCirc();
		UnityEngine.Debug.Log("Bench Moved");
		MoveFloatingWhisper(8, 2f);
		floatingWhispersScript.FadeOut(2f);
		yield return Yield.WaitSeconds(2f);
		facingNaive = false;
		lookingAtNaiveCollider.SetActive(value: true);
		while (!facingNaive)
		{
			yield return null;
		}
		floatingSample01.transform.position = floataudioLocation[8].position;
		floatAudio01.Play(floatAudio[7]);
		HUD.Instance.PlaySubtitles(floatAudio[7].name, hasPriority: true);
		player.playerLight.shouldLightBeOn = false;
		if (oilLighter.isOn)
		{
			oilLighter.TurnOffLight();
		}
		else
		{
			player.playerLight.PlayClick();
			playerLightFlicker.SwitchLight(switchOn: false);
		}
		oilLighter.canTurnOnLight = false;
		floatingWhispersScript.FadeIn(floatingGrowlClip, 0.8f, 2f, loop: true);
		lookingAtNaiveCollider.SetActive(value: false);
		MoveFloatingWhisper(6, 2f);
		candlesPazuzu.SetActive(value: true);
		pazuzuStatue.SetActive(value: true);
		GameController.instance.hintManager.AddHint(pazuzuStatue);
		statueRoaches1.gameObject.SetActive(value: true);
		statueRoaches2.gameObject.SetActive(value: true);
		statueRoaches3.gameObject.SetActive(value: true);
		statueRoaches4.gameObject.SetActive(value: true);
		statueRoaches1.SetTrigger("StatueTrigger1");
		statueRoaches2.SetTrigger("StatueTrigger2");
		statueRoaches3.SetTrigger("StatueTrigger3");
		statueRoaches4.SetTrigger("StatueTrigger4");
		moths.transform.position = mothPos02.position;
		moths.SetActive(value: true);
		while (!foundPazuzuStatue)
		{
			yield return null;
		}
		musicPlayer.FadeOut(1.5f);
		GameController.instance.hintManager.RemoveHint(pazuzuStatue);
		MoveFloatingWhisper(5, 8f);
		floatingWhispersScript.FadeOut(8f);
		thirdWhispersScript.Play(thirdWhispersClip);
		yield return Yield.WaitSeconds(2f);
		floatingSample01.transform.position = floataudioLocation[6].position;
		floatAudio01.Play(floatAudio[6]);
		yield return Yield.WaitSeconds(0.5f);
		for (int i = 0; i < candleLightPazuzu.Length; i++)
		{
			if (candleLightPazuzu[i].gameObject.activeInHierarchy)
			{
				candleLightPazuzu[i].Fade(on: false, 0.5f);
				yield return Yield.WaitSeconds(0.5f);
			}
		}
		lightControllerMain.UpdateReflectionProbes();
		bellPig.transform.position = bellPigPos01.position;
		bellPig.transform.rotation = bellPigPos01.rotation;
		bellPig.SetActive(value: true);
		bellPig.GetComponent<Animator>().SetTrigger("Corner");
		yield return Yield.WaitSeconds(2.5f);
		tapeSpeakerMainHall.Play(churchVOFinalP1);
		musicPlayer.Play(musicPazuzuFound);
		HUD.Instance.PlaySubtitles(churchVOFinalP1.name, hasPriority: true);
		foleyChurch.Stop();
		startTime2 = Time.time;
		float currentTime = Time.time - startTime2;
		policeStrobe.gameObject.SetActive(value: true);
		policeStrobeFlicker.Loop(0.8f, 0.2f);
		facingConfession = false;
		lookingAtConfessionCollider.SetActive(value: true);
		while (!facingConfession)
		{
			if (currentTime > 20f)
			{
				facingConfession = true;
			}
			currentTime = Time.time - startTime2;
			yield return null;
		}
		lookingAtConfessionCollider.SetActive(value: false);
		bellPig.GetComponent<Animator>().SetTrigger("Squeal");
		UnityEngine.Debug.Log("Seen Pig Man Confession = " + facingConfession);
		floatingSample01.transform.position = floataudioLocation[9].position;
		floatAudio01.Play(floatAudio[8]);
		GameController.instance.audioController.PlayBadSting(STINGS_BAD.BAD_STING_06, 0.6f);
		yield return Yield.WaitSeconds(2f);
		policeStrobeFlicker.SwitchLight(switchOn: false);
		yield return Yield.WaitSeconds(0.8f);
		bellPig.transform.position = bellPigPos03.position;
		bellPig.transform.rotation = bellPigPos03.rotation;
		bellPig.GetComponent<Animator>().SetTrigger("Altar");
		yield return Yield.WaitSeconds(0.2f);
		policeStrobeFlicker.Loop(0.8f, 0.2f);
		floatingWhispersScript.FadeIn(pazuzuGrowl_mild, 0.7f, 4f, loop: true);
		MoveFloatingWhisper(6, 6f);
		yield return Yield.WaitSeconds(4f);
		lookingAtStageCollider.SetActive(value: true);
		facingStage = false;
		while (!facingStage)
		{
			if (currentTime >= 30f)
			{
				facingStage = true;
			}
			currentTime = Time.time - startTime2;
			yield return null;
		}
		lookingAtStageCollider.SetActive(value: false);
		UnityEngine.Debug.Log("Looked at stage");
		bellPig.GetComponent<Animator>().SetTrigger("AltarScare");
		floatingSample01.transform.position = floataudioLocation[10].position;
		floatAudio01.PlayOne(floatAudio[10]);
		policeStrobeFlicker.Loop(0.6f, 0.2f);
		if (confessionDoor.transform.localEulerAngles.y > 10f)
		{
			LeanTween.rotateLocal(confessionDoor, new Vector3(0f, 0f, 0f), 0.2f).setEase(LeanTweenType.easeInOutExpo);
		}
		MoveFloatingWhisper(5, 3f);
		facingConfession = false;
		lookingAtConfessionCollider.SetActive(value: true);
		while (!facingConfession)
		{
			if (currentTime > 40f)
			{
				facingConfession = true;
			}
			currentTime = Time.time - startTime2;
			yield return null;
		}
		lookingAtConfessionCollider.SetActive(value: false);
		LeanTween.rotateLocal(confessionDoor, new Vector3(0f, 88f, 0f), 4f).setEase(LeanTweenType.easeInOutSine);
		UnityEngine.Debug.Log("Confession Door Open");
		floatingSample01.transform.position = floataudioLocation[3].position;
		floatAudio01.PlayOne(floatAudio[3]);
		yield return Yield.WaitSeconds(4f);
		policeStrobeFlicker.SwitchLight(switchOn: true);
		floatingSample01.transform.position = floataudioLocation[4].position;
		floatAudio01.Play(floatAudio[4]);
		confessionChair.GetComponent<Rigidbody>().constraints = RigidbodyConstraints.None;
		confessionChair.GetComponent<Rigidbody>().AddForce(-60f, 1f, 0f, ForceMode.Impulse);
		yield return Yield.WaitSeconds(0.2f);
		confessionChair.GetComponent<BreakableObject>().collisionActive = false;
		confessionChair.GetComponent<BreakableObject>().canSmash = true;
		yield return Yield.WaitSeconds(0.8f);
		UnityEngine.Debug.Log("Confession Chair Triggered");
		MoveFloatingWhisper(7, 3f);
		floatingWhispersScript.PlayLoop(pazuzuGrowl_mad);
		policeStrobeFlicker.Loop(0.6f, 0.2f);
		facingNaive = false;
		lookingAtNaiveCollider.SetActive(value: true);
		while (currentTime < 42f)
		{
			currentTime = Time.time - startTime2;
			yield return null;
		}
		floatingSample01.transform.position = floataudioLocation[11].position;
		floatAudio01.Play(pazuzuHiss);
		while (!facingNaive)
		{
			if (currentTime > 46f)
			{
				facingNaive = true;
			}
			currentTime = Time.time - startTime2;
			yield return null;
		}
		lookingAtNaiveCollider.SetActive(value: false);
		floatingSample01.transform.position = floataudioLocation[5].position;
		floatAudio01.Play(floatAudio[5]);
		hallChair.GetComponent<Rigidbody>().constraints = RigidbodyConstraints.None;
		hallChair.GetComponent<Rigidbody>().AddTorque(-6000f, 1000f, 500f, ForceMode.Impulse);
		hallChair.GetComponent<Rigidbody>().AddForce(4f, 20f, -2f, ForceMode.Impulse);
		UnityEngine.Debug.Log("Hall Chair Triggered");
		yield return Yield.WaitSeconds(0.1f);
		yield return Yield.WaitSeconds(0.9f);
		MoveFloatingWhisper(8, 3f);
		pazuzu.SetActive(value: true);
		pazuzuAnim.SetTrigger("Idle");
		while (currentTime < 49.5f)
		{
			currentTime = Time.time - startTime2;
			yield return null;
		}
		floatingSample01.transform.position = floataudioLocation[8].position;
		floatAudio01.Play(floatAudio[9]);
		HUD.Instance.PlaySubtitles(floatAudio[9].name, hasPriority: true);
		while (currentTime < 55f)
		{
			currentTime = Time.time - startTime2;
			yield return null;
		}
		policeStrobeFlicker.SwitchLight(switchOn: false);
		pazuzuStrobeFlicker.Fade(on: true, 5f);
		facingNaive = false;
		lookingAtNaiveCollider.SetActive(value: true);
		while (!facingNaive)
		{
			if (bellPig.activeInHierarchy)
			{
				bellPig.SetActive(value: false);
			}
			yield return null;
		}
		musicPlayer.Play(musicPigHeadDrop);
		StartCoroutine(PigDeath());
		yield return Yield.WaitSeconds(5f);
		tapeSpeakerMainHall.Play(churchVOFinalP2);
		musicPlayer.Play(musicPazuzuFinale);
		bibleSetPiece02.GetComponent<BibleBurst>().Burst();
		yield return Yield.WaitSeconds(1f);
		pazuzuAnim.SetTrigger("Crawl");
		LeanTween.moveZ(pazuzuParent, -8f, 7.5f);
		mainRoom.GetComponent<PlayableDirector>().Play();
		pazuzuStrobeFlicker.light.range = 10.75f;
		pazuzuStrobeFlicker.Loop(0.1f, 0.2f);
		yield return Yield.WaitSeconds(0.25f);
		tapeBreak.SetActive(value: false);
		flyingCandleBack02.SetActive(value: true);
		flyingCandleBack02.GetComponent<Rigidbody>().AddForce(2f, 12f, 44f, ForceMode.Impulse);
		bibleSetPiece03.GetComponent<BibleBurst>().Burst();
		yield return Yield.WaitSeconds(0.75f);
		flyingCandleBack01.SetActive(value: true);
		flyingCandleBack01.GetComponent<Rigidbody>().AddForce(0f, 0f, 50f, ForceMode.Impulse);
		yield return Yield.WaitSeconds(1.25f);
		flyingCandleBack03.SetActive(value: true);
		flyingCandleBack03.GetComponent<Rigidbody>().AddForce(-3f, 9f, 40f, ForceMode.Impulse);
		yield return Yield.WaitSeconds(1f);
		bibleSetPiece01.GetComponent<BibleBurst>().Burst();
		pazuzuStrobeFlicker.looping = false;
		yield return Yield.WaitSeconds(0.75f);
		pazuzu.GetComponent<AudioScript>().PlayOne(pazuzuHiss);
		pazuzuStrobeFlicker.SwitchLight(switchOn: true);
		yield return Yield.WaitSeconds(1.25f);
		policeStrobeFlicker.SwitchLight(switchOn: true);
		LeanTween.move(naiveChair, player.Head.transform, 0.25f);
		yield return Yield.WaitSeconds(0.25f);
		policeStrobeFlicker.SwitchLight(switchOn: false);
		player.playerAudio.PlayOne(chairHitsFaceSFX);
		player.screenFX.Fade(UnityEngine.Color.black, 0f);
		pazuzuStrobeFlicker.light.range = 6.5f;
		naiveChair.SetActive(value: false);
		musicPlayer.StopLoop();
		pazuzuAnim.SetTrigger("LowWait");
		Vector3 to = player.Head.transform.position + new Vector3(0f, 0f, -0.8f);
		LeanTween.move(floatingWhispersScript.gameObject, to, 1f);
		player.screenFX.BlurScreen(enabled: true);
		musicPlayer.PlayLoop(heartbeat, 0.3f);
		player.movement.DisableEverything();
		player.HandMenu.LockMenu(locked: true);
		PopulateKit();
		yield return Yield.WaitSeconds(2f);
		player.screenFX.Fade(UnityEngine.Color.clear, 0.75f);
		yield return Yield.WaitSeconds(0.75f);
		player.screenFX.Fade(UnityEngine.Color.black, 0.75f);
		yield return Yield.WaitSeconds(1.25f);
		player.gameObject.transform.position = new Vector3(player.gameObject.transform.position.x, player.gameObject.transform.position.y - 0.3f, player.gameObject.transform.position.z);
		player.gameObject.transform.eulerAngles = new Vector3(player.gameObject.transform.eulerAngles.x + 10f, player.gameObject.transform.eulerAngles.y, player.gameObject.transform.eulerAngles.z - 10f);
		player.screenFX.Fade(UnityEngine.Color.clear, 0.75f);
		yield return Yield.WaitSeconds(0.75f);
		player.screenFX.Fade(UnityEngine.Color.black, 0.75f);
		yield return Yield.WaitSeconds(1.25f);
		player.gameObject.transform.position = new Vector3(player.gameObject.transform.position.x, player.gameObject.transform.position.y - 0.55f, player.gameObject.transform.position.z);
		player.gameObject.transform.eulerAngles = new Vector3(player.gameObject.transform.eulerAngles.x + 5f, player.gameObject.transform.eulerAngles.y, player.gameObject.transform.eulerAngles.z - 5f);
		player.screenFX.Fade(UnityEngine.Color.clear, 0.75f);
		yield return Yield.WaitSeconds(2.75f);
		pazuzu.GetComponent<AudioScript>().PlayOne(pazuzuHiss);
		player.screenFX.Fade(UnityEngine.Color.black, 0.25f);
		yield return Yield.WaitSeconds(pazuzuHiss.length - 0.25f);
	}

	private IEnumerator FadeOutScene()
	{
		bool playedTapes = false;
		bool completedKit = false;
		if (tapePlayerController.playedTape2 || tapePlayerController.playedTape3)
		{
			playedTapes = true;
		}
		if (foundCross && foundHolyWater && foundLighter && foundSaltSprayer && foundKit)
		{
			completedKit = true;
		}
		GameController.instance.levelCompletionManager.SetLevelCompletionForChapel(playedTapes, completedKit, SaveManager.instance.HasFoundArtifact(ChapterID.CHAPEL), completedLevel: true);
		GameController.instance.audioController.SnapMute(1f);
		yield return Yield.WaitSeconds(2f);
		player.screenFX.BlurScreen(enabled: false);
		GameController.instance.boundDetection.SwitchOffOOB();
		GameController.instance.GoToSpecificScene(SCENES.PRECINCT, completedPrev: true);
	}

	private IEnumerator PigDeath()
	{
		pigsHeadBlood.gameObject.SetActive(value: true);
		pigsHeadBlood.Play();
		yield return Yield.WaitSeconds(0.5f);
		policeStrobeFlicker.Loop(0.1f, 0.2f);
		yield return Yield.WaitSeconds(1f);
		pigsHeadBlood.Stop(withChildren: true, ParticleSystemStopBehavior.StopEmitting);
		fallingPigHead.SetActive(value: true);
		yield return Yield.WaitSeconds(0.5f);
		policeStrobeFlicker.SwitchLight(switchOn: false);
	}

	private void LockItems(bool activeState)
	{
		for (int i = 0; i < lockableItems.Length; i++)
		{
			lockableItems[i].SetActive(activeState);
			UnityEngine.Debug.Log("Locked item : " + lockableItems[i]);
		}
	}

	private void SecretPictureFrame()
	{
		StartCoroutine(SecretPictureFrameRoutine());
	}

	private IEnumerator SecretPictureFrameRoutine()
	{
		floatingSample01.transform.position = floataudioLocation[0].position;
		floatAudio01.Play(floatAudio[0]);
		yield return Yield.WaitSeconds(2.4f);
		secretPictureFrameHandle.UnlockDoor();
		LeanTween.rotate(secretPictureFrame, new Vector3(0f, 100f, 90f), 0.6f).setEaseOutQuart();
		lightControllerMain.TurnOffLights();
		lightControllerMain.SwitchOffReflectionProbes();
	}

	private IEnumerator ConfessionDoorOpened()
	{
		yield return Yield.WaitSeconds(0.1f);
	}

	private IEnumerator StartFloatingWhispers()
	{
		floatingWhispersScript.gameObject.transform.position = floatingWhispersPositions[0].transform.position;
		whispersActive = true;
		int positionCounter = 1;
		while (whispersActive)
		{
			if (positionCounter >= floatingWhispersPositions.Length)
			{
				positionCounter = 0;
			}
			LeanTween.move(floatingWhispersScript.gameObject, floatingWhispersPositions[positionCounter].transform.position, 3f);
			yield return Yield.WaitSeconds(3f);
			positionCounter++;
		}
	}

	private void MoveFloatingWhisper(int positionCounter, float timeToPos)
	{
		LeanTween.move(floatingWhispersScript.gameObject, floatingWhispersPositions[positionCounter].transform.position, timeToPos);
	}

	private IEnumerator CheckMenuOpen(NVRInteractable itemToRemove)
	{
		NVRInteractable notebookScript = notebook.GetComponent<NVRInteractable>();
		NVRInteractable kitScript = staticExKit.GetComponent<NVRInteractable>();
		bool exKitInHand = player.RightHand.CurrentlyInteracting == kitScript || player.LeftHand.CurrentlyInteracting == kitScript;
		bool bookInHand = player.RightHand.CurrentlyInteracting == notebookScript || player.LeftHand.CurrentlyInteracting == notebookScript;
		while (!player.HandMenu.IsActive)
		{
			exKitInHand = player.RightHand.CurrentlyInteracting == kitScript || player.LeftHand.CurrentlyInteracting == kitScript;
			bookInHand = player.RightHand.CurrentlyInteracting == notebookScript || player.LeftHand.CurrentlyInteracting == notebookScript;
			yield return null;
		}
		if ((bool)player.watch)
		{
			player.watch.CancelWatchHint();
		}
		if ((bool)player.watch)
		{
			player.watch.CancelWatchHintWithSFX();
		}
		if (itemToRemove.gameObject == notebook.gameObject)
		{
			if (bookInHand)
			{
				player.ForceDropItems();
				if (player.RightHand.CurrentlyInteracting == notebookScript)
				{
					player.RightHand.CurrentlyInteracting = null;
					player.RightHand.CurrentlyHoveringOver.Remove(notebookScript);
				}
				else
				{
					player.LeftHand.CurrentlyInteracting = null;
					player.LeftHand.CurrentlyHoveringOver.Remove(notebookScript);
				}
				itemToRemove.CanAttach = false;
				notebook.GetComponent<Rigidbody>().isKinematic = true;
				yield return Yield.EndOfFrame;
				yield return Yield.EndOfFrame;
				LeanTween.moveLocal(notebook, player.HandMenu.listOfRealItems[0].transform.position, 0.75f);
				LeanTween.rotateLocal(notebook, player.HandMenu.listOfRealItems[0].transform.eulerAngles, 0.75f);
			}
			StartCoroutine(RemoveNotebook(itemToRemove, 0.5f));
		}
		else if (itemToRemove.gameObject == staticExKit.gameObject)
		{
			if (exKitInHand)
			{
				player.ForceDropItems();
				itemToRemove.CanAttach = false;
				staticExKit.GetComponent<Rigidbody>().isKinematic = true;
				yield return Yield.EndOfFrame;
				yield return Yield.EndOfFrame;
				LeanTween.moveLocal(staticExKit, player.HandMenu.listOfRealItems[1].transform.position, 0.75f);
				LeanTween.rotateLocal(staticExKit, player.HandMenu.listOfRealItems[1].transform.eulerAngles, 0.75f);
			}
			StartCoroutine(RemoveStaticKit(itemToRemove, 0.5f, removeInstantly: true));
		}
	}

	private IEnumerator RemoveNotebook(NVRInteractable itemToRemove, float time)
	{
		while (itemToRemove.AttachedHands.Count > 0)
		{
			yield return null;
		}
		NVRInteractable component = notebook.GetComponent<NVRInteractable>();
		if (player.RightHand.CurrentlyInteracting == component)
		{
			player.RightHand.CurrentlyInteracting = null;
			player.RightHand.CurrentlyHoveringOver.Remove(component);
			player.RightHand.hoverRemoveObject = component;
		}
		else
		{
			player.LeftHand.CurrentlyInteracting = null;
			player.LeftHand.CurrentlyHoveringOver.Remove(component);
			player.LeftHand.hoverRemoveObject = component;
		}
		notebookBack.GetComponent<MeshRenderer>().material = notebookMaterials[0];
		notebookFront.GetComponent<MeshRenderer>().material = notebookMaterials[0];
		notebookRingBinder.GetComponent<MeshRenderer>().material = notebookMaterials[1];
		itemToRemove.gameObject.SetActive(value: false);
	}

	private IEnumerator RemoveStaticKit(NVRInteractable itemToRemove, float time, bool removeInstantly = false)
	{
		while (itemToRemove.AttachedHands.Count > 0)
		{
			yield return null;
		}
		if (!removeInstantly)
		{
			yield return Yield.WaitSeconds(0.5f);
		}
		Material[] array;
		for (float t = 1f; t > 0f; t -= Time.deltaTime / time)
		{
			array = exKitMaterials;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].SetFloat("_Dissolve", t);
			}
			yield return Yield.EndOfFrame;
		}
		array = exKitMaterials;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetFloat("_Dissolve", 0f);
		}
		itemToRemove.gameObject.SetActive(value: false);
	}

	private IEnumerator SwitchOffMainLight()
	{
		yield return Yield.WaitSeconds(2f);
		lightControllerMain.FlickerLights(1f, endOn: false);
		yield return Yield.WaitSeconds(1f);
		lightControllerMain.SwitchOffReflectionProbes();
		yield return Yield.WaitSeconds(0.5f);
		player.playerLight.PlayClick();
		playerLightFlicker.SwitchLight(switchOn: true);
		door.doorLocked = false;
	}

	public void TogglePlayerLight()
	{
		if (room_sideRoom.playerInRoom)
		{
			if (!foundCross)
			{
				cross.GetComponent<Rigidbody>().isKinematic = true;
				cross.transform.position = crossPosition.transform.position;
				cross.transform.rotation = crossPosition.transform.rotation;
			}
			UnityEngine.Debug.Log("Switch light on!");
			oilLighter.canTurnOnLight = true;
			player.playerLight.shouldLightBeOn = true;
			if (!oilLighter.isOn)
			{
				player.playerLight.PlayClick();
				playerLightFlicker.SwitchLight(switchOn: true);
			}
			else
			{
				oilLighter.TurnOnLight();
			}
			return;
		}
		if (!foundCross)
		{
			cross.transform.position = crossPosition.transform.position;
			cross.transform.rotation = crossPosition.transform.rotation;
			cross.GetComponent<Rigidbody>().isKinematic = false;
		}
		if (seenBellMove)
		{
			UnityEngine.Debug.Log("Turning off father bell");
			bellDead.SetActive(value: false);
			fatherBellRoaches.gameObject.SetActive(value: false);
		}
		else
		{
			bellDead.GetComponent<Animator>().SetTrigger("SeatDead");
		}
		UnityEngine.Debug.Log("Switch light off!");
		player.playerLight.shouldLightBeOn = false;
		if (oilLighter.isOn)
		{
			oilLighter.TurnOffLight();
		}
		else
		{
			player.playerLight.PlayClick();
			playerLightFlicker.SwitchLight(switchOn: false);
		}
		oilLighter.canTurnOnLight = false;
	}

	public override void BeginInteraction(NVRInteractable interactable)
	{
		if (interactable.gameObject == cross.gameObject)
		{
			crossInHand = true;
			if (!foundCross)
			{
				foundCross = true;
				ExorcismItem component = cross.GetComponent<ExorcismItem>();
				component.parentTransform = player.HandMenu.exKitScript.gameObject.transform;
				component.originalPos = new Vector3(0.001f, -0.0048f, -0.0013f);
				component.originalRot = Quaternion.Euler(0f, 0f, 0f);
				player.HandMenu.OpenStraightToExKit();
				staticExKit.SetActive(value: false);
				PlayWatchAlert(3f);
				StartCoroutine(CheckMenuOpen(interactable));
				component.inEnvironment = false;
				confessionWindDoor.StopMovement(0f);
			}
		}
		else if (interactable.gameObject == holyWater.gameObject && !foundHolyWater)
		{
			holyWater.GetComponent<HolyWater>().canSmash = true;
			if (!artifactUnlocked)
			{
				if (!foundFirstExKitItem)
				{
					foundFirstExKitItem = true;
					if (foundKit)
					{
						PlayWatchAlert(2f);
						StartCoroutine(CheckMenuOpen(interactable));
					}
					GameController.instance.audioController.PlayGoodSting(STINGS_GOOD.GOOD_CHOIR_STING_02, 0.6f);
				}
				else
				{
					if (foundKit)
					{
						PlayWatchAlert(2f);
						StartCoroutine(CheckMenuOpen(interactable));
					}
					GameController.instance.audioController.PlayGoodSting(STINGS_GOOD.GOOD_SOFT_STING_01, 0.4f);
				}
				foundHolyWaterInBowl = true;
			}
			if (foundKit)
			{
				player.HandMenu.OpenStraightToExKit();
			}
			foundHolyWater = true;
			ExorcismItem component2 = holyWater.GetComponent<ExorcismItem>();
			component2.parentTransform = player.HandMenu.exKitScript.caseDrawer.transform;
			component2.originalPos = new Vector3(0.0185f, 0.0088f, -0.0814f);
			component2.originalRot = Quaternion.Euler(90f, 0f, -180f);
			component2.inEnvironment = false;
			component2.SpawnSecondWater = true;
		}
		else if (interactable.gameObject == saltSprayer.gameObject && !foundSaltSprayer)
		{
			if (!foundFirstExKitItem)
			{
				foundFirstExKitItem = true;
				if (foundKit)
				{
					PlayWatchAlert(2f);
					StartCoroutine(CheckMenuOpen(interactable));
				}
				GameController.instance.audioController.PlayGoodSting(STINGS_GOOD.GOOD_CHOIR_STING_02, 0.6f);
			}
			else
			{
				if (foundKit)
				{
					PlayWatchAlert(2f);
					StartCoroutine(CheckMenuOpen(interactable));
				}
				GameController.instance.audioController.PlayGoodSting(STINGS_GOOD.GOOD_SOFT_STING_02, 0.4f);
			}
			if (foundKit)
			{
				player.HandMenu.OpenStraightToExKit();
			}
			StartCoroutine(SwitchOffMainLight());
			foundSaltSprayer = true;
			ExorcismItem component3 = saltSprayer.GetComponent<ExorcismItem>();
			component3.parentTransform = player.HandMenu.exKitScript.caseLid.transform;
			component3.originalPos = new Vector3(-0.0515f, 0.0111f, -0.0073f);
			component3.originalRot = Quaternion.Euler(83.55601f, 94.039f, -85.93501f);
			component3.inEnvironment = false;
		}
		else if (interactable.gameObject == lighter.gameObject && !foundLighter)
		{
			if (!foundFirstExKitItem)
			{
				foundFirstExKitItem = true;
				if (foundKit)
				{
					PlayWatchAlert(2f);
					StartCoroutine(CheckMenuOpen(interactable));
				}
				GameController.instance.audioController.PlayGoodSting(STINGS_GOOD.GOOD_CHOIR_STING_02, 0.6f);
			}
			else
			{
				if (foundKit)
				{
					PlayWatchAlert(2f);
					StartCoroutine(CheckMenuOpen(interactable));
				}
				GameController.instance.audioController.PlayGoodSting(STINGS_GOOD.GOOD_SOFT_STING_03, 0.4f);
			}
			if (foundKit)
			{
				player.HandMenu.OpenStraightToExKit();
			}
			foundLighter = true;
			ExorcismItem component4 = lighter.GetComponent<ExorcismItem>();
			component4.parentTransform = player.HandMenu.exKitScript.caseLid.transform;
			component4.originalPos = new Vector3(-0.1453f, 0.019f, -0.0253f);
			component4.originalRot = Quaternion.Euler(185.08f, -89.60699f, 85.572f);
			component4.inEnvironment = false;
		}
		else if (interactable.gameObject == notebook.gameObject && !foundNotebook && !artifactUnlocked)
		{
			player.HandMenu.OpenStraightToBook();
			foundNotebook = true;
			GameController.instance.player.HandMenu.bookScript.UpdateTexturesForLanguage();
			GameController.instance.audioController.PlayGoodSting(STINGS_GOOD.GOOD_STING_03, 0.6f);
			StartCoroutine(CheckMenuOpen(interactable));
			PlayWatchAlert();
		}
		else if (interactable.gameObject == staticExKit.gameObject && !foundKit)
		{
			player.HandMenu.OpenStraightToExKit();
			foundKit = true;
			GameController.instance.audioController.PlayGoodSting(STINGS_GOOD.GOOD_STING_01, 0.6f);
			GameController.instance.hintManager.RemoveHint(firstMarker);
			StartCoroutine(CheckMenuOpen(interactable));
			PlayWatchAlert();
		}
		else if (interactable.gameObject == secretPictureFrameHandle.gameObject && !foundPictureFrame)
		{
			if (!secretPictureFrameHandle.doorLocked)
			{
				foundPictureFrame = true;
				pictureFrameRoaches.gameObject.SetActive(value: true);
				pictureFrameRoaches.SetTrigger("PictureFrameRoachesTrigger");
			}
		}
		else if (interactable.gameObject == pazuzuStatue && !foundPazuzuStatue)
		{
			foundPazuzuStatue = true;
			underStatueRoaches1.gameObject.SetActive(value: true);
			underStatueRoaches2.gameObject.SetActive(value: true);
			underStatueRoaches1.SetTrigger("UnderStatueTrigger1");
			underStatueRoaches2.SetTrigger("UnderStatueTrigger2");
		}
		else if (interactable.gameObject == confessionDoorHandle)
		{
			openingConfessionDoor = true;
			confessionWindDoor.StopMovement(0f);
		}
		if (interactable.gameObject == artefact.holyWaterReward && !foundSourceOfTheNile)
		{
			if ((bool)artefact.holyWaterReward.GetComponent<BreakableObject>())
			{
				artefact.holyWaterReward.GetComponent<BreakableObject>().canSmash = true;
			}
			foundSourceOfTheNile = true;
			SaveManager.instance.MarkArtifactFound(ChapterID.CHAPEL);
			StartCoroutine(FoundSourceOfTheNileArtifact());
		}
	}

	public override void EndInteraction(NVRInteractable interactable)
	{
		if (interactable.gameObject == confessionDoorHandle)
		{
			openingConfessionDoor = false;
		}
	}

	public override void OnTriggerExit(Collider collider)
	{
		if (collider.gameObject == exitSideRoomTrigger.gameObject && exitSideRoom)
		{
			exitSideRoom = false;
		}
	}

	public override void OnTriggerEnter(Collider collider)
	{
		if (collider.gameObject == sideRoomTrigger.gameObject && !inSideRoom)
		{
			sideRoomTrigger.gameObject.SetActive(value: false);
			inSideRoom = true;
		}
		else if (collider.gameObject == exitSideRoomTrigger.gameObject && !exitSideRoom)
		{
			exitSideRoom = true;
		}
		else if (collider.gameObject == enterMainRoomTrigger.gameObject && crossInHand)
		{
			enterMainRoomTrigger.gameObject.SetActive(value: false);
		}
		else if (collider.gameObject == tapePlayer.gameObject)
		{
			tapePlayerController.PlayTape();
		}
		if (collider.gameObject == confessionHeadTrigger && !seenBellMove && !crossInHand)
		{
			seenBellMove = true;
			StartCoroutine(moveFatherBellAndAnimate());
		}
		if (collider.gameObject == pictureFrameButton && !pictureFrameButtonFound)
		{
			MeshRenderer[] array = allPictures;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].material = picturesBlood;
			}
			SecretPictureFrame();
			pictureFrameButtonFound = true;
			pictureFrameButton.gameObject.GetComponentInChildren<LightFlicker>().SwitchLight(switchOn: false);
			LockItems(activeState: true);
			cross.SetActive(value: true);
			UnityEngine.Debug.Log("CROSS TRUE");
		}
	}

	public override void OnSightTriggerStay(Collider other)
	{
		if (other.gameObject == statue && !seenStatue && Vector3.Distance(statue.transform.position, player.Head.gameObject.transform.position) < 4f)
		{
			seenStatue = true;
		}
		if (other.gameObject == movingBench && !lookingAtBench && Vector3.Distance(player.Head.transform.position, movingBench.transform.position) < 3.5f)
		{
			lookingAtBench = true;
		}
		if (other.gameObject == hymmBlockTrigger && !lookingAtHymnBoard && Vector3.Distance(player.Head.transform.position, hymmBlock.transform.position) < distanceToHymboard)
		{
			lookingAtHymnBoard = true;
		}
	}

	public override void OnSightTriggerEnter(Collider other)
	{
		if (lookingAtStageCollider.activeInHierarchy && other.gameObject == lookingAtStageCollider)
		{
			facingStage = true;
		}
		if (lookingAtCandlesCollider.activeInHierarchy && other.gameObject == lookingAtCandlesCollider)
		{
			facingCandles = true;
		}
		if (lookingAtConfessionCollider.activeInHierarchy && other.gameObject == lookingAtConfessionCollider)
		{
			facingConfession = true;
		}
		if (lookingAtNaiveCollider.activeInHierarchy && other.gameObject == lookingAtNaiveCollider)
		{
			facingNaive = true;
		}
		if (lookingAwayFromMaryCollider.activeInHierarchy && other.gameObject == lookingAwayFromMaryCollider && exitSideRoom)
		{
			canSeeMary = false;
		}
	}

	private void ArtifactUnlocked()
	{
		artifactUnlocked = true;
		if (!foundHolyWater)
		{
			player.HandMenu.SwapOutHolyWater();
			holyWater.transform.position = artefact.holyWaterReward.transform.position;
			holyWater.transform.rotation = artefact.holyWaterReward.transform.rotation;
			holyWater.transform.parent = artefact.holyWaterReward.transform.parent;
			holyWater.GetComponent<Rigidbody>().isKinematic = true;
			artefact.holyWaterReward.SetActive(value: false);
			artefact.holyWaterReward = holyWater;
		}
	}

	private IEnumerator FoundSourceOfTheNileArtifact()
	{
		GameController.instance.audioController.PlayGoodSting(STINGS_GOOD.GOOD_CHOIR_STING_03, 0.75f);
		player.HandMenu.bookScript.updateMaxPage(14);
		player.HandMenu.OpenStraightToBookForArtefact(ArtefactType.SOURCE_OF_NILE, NotebookPages.Q14);
		player.HandMenu.SwapOutHolyWater();
		foundNotebook = true;
		StartCoroutine(CheckMenuOpen(notebook.GetComponent<NVRInteractableItem>()));
		yield return Yield.WaitSeconds(2f);
		PlayWatchAlert();
		if (foundHolyWaterInBowl)
		{
			StartCoroutine(RemoveArtifactFromUserHand());
		}
	}

	private IEnumerator RemoveArtifactFromUserHand()
	{
		float counter = 0f;
		bool inHand = false;
		while (!player.HandMenu.bookScript.isActiveItem)
		{
			if (player.LeftHand.IsInteracting && player.LeftHand.CurrentlyInteracting.gameObject == artefact.holyWaterReward)
			{
				inHand = true;
			}
			if (player.RightHand.IsInteracting && player.RightHand.CurrentlyInteracting.gameObject == artefact.holyWaterReward)
			{
				inHand = true;
			}
			if (inHand)
			{
				counter = 0f;
				inHand = false;
			}
			else
			{
				counter += 1f;
			}
			if (counter > 2f)
			{
				break;
			}
			yield return Yield.WaitSeconds(1f);
		}
		if (player.LeftHand.IsInteracting)
		{
			if (player.LeftHand.CurrentlyInteracting != null && player.LeftHand.CurrentlyInteracting.gameObject == artefact.holyWaterReward)
			{
				LeanTween.alpha(artefact.holyWaterReward, 0f, 1f);
				player.LeftHand.ForceDropItem();
				yield return Yield.EndOfFrame;
				artefact.holyWaterReward.SetActive(value: false);
				player.LeftHand.CurrentlyInteracting = null;
				yield return Yield.EndOfFrame;
				player.LeftHand.CurrentlyHoveringOver.Remove(artefact.holyWaterReward.GetComponent<NVRInteractableItem>());
			}
		}
		else if (player.RightHand.IsInteracting)
		{
			if (player.RightHand.CurrentlyInteracting != null && player.RightHand.CurrentlyInteracting.gameObject == artefact.holyWaterReward)
			{
				LeanTween.alpha(artefact.holyWaterReward, 0f, 1f);
				player.RightHand.ForceDropItem();
				yield return Yield.EndOfFrame;
				artefact.holyWaterReward.SetActive(value: false);
				player.RightHand.CurrentlyInteracting = null;
				yield return Yield.EndOfFrame;
				player.RightHand.CurrentlyHoveringOver.Remove(artefact.holyWaterReward.GetComponent<NVRInteractableItem>());
			}
		}
		else
		{
			LeanTween.alpha(artefact.holyWaterReward, 0f, 0.5f);
			yield return Yield.WaitSeconds(0.5f);
			artefact.holyWaterReward.SetActive(value: false);
		}
		if (!GameController.instance.player.LeftHand.IsInteracting)
		{
			GameController.instance.player.LeftHand.SetAnimation("IdleBool");
		}
		if (!GameController.instance.player.RightHand.IsInteracting)
		{
			GameController.instance.player.RightHand.SetAnimation("IdleBool");
		}
	}

	private IEnumerator moveFatherBellAndAnimate()
	{
		bellDead.GetComponent<Animator>().SetTrigger("SeatScare");
		GameController.instance.audioController.PlayBadSting(STINGS_BAD.BAD_STING_03, 0.4f);
		saltSprayer.GetComponent<ExorcismItem>().saltScript.Fire();
		yield return Yield.WaitSeconds(1f);
		fatherBellRoaches.gameObject.SetActive(value: true);
		fatherBellRoaches.SetTrigger("FatherBellTrigger");
	}

	private void AimCross()
	{
		ExorcismItem component = cross.GetComponent<ExorcismItem>();
		if ((bool)component.AttachedHand)
		{
			float num = Mathf.Clamp(Vector3.Angle(cross.transform.position - crossTarget.transform.position, -cross.transform.up), 0f, 45f) / 45f;
			component.AttachedHand.TriggerHapticPulse(5f * (1f - num));
		}
	}

	public void OnConfessionalDoorOpen()
	{
		confessionalDoorAdditionalBlocks.SetActive(value: false);
		if (player.boundDetection.outOfBounds)
		{
			player.boundDetection.TurnOffOOB(fadeScreen: false, enableMovement: true);
		}
	}

	private void PlayWatchAlert(float delayTime = 0f)
	{
		if (delayTime == 0f)
		{
			player.watch.WatchHintWithSFX(3f, SFXAlertType.ALERT);
		}
		else
		{
			StartCoroutine(WatchAlertDelay(delayTime));
		}
	}

	private IEnumerator WatchAlertDelay(float delayTime)
	{
		yield return Yield.WaitSeconds(delayTime);
		player.watch.WatchHintWithSFX(3f, SFXAlertType.ALERT);
	}

	private void PlayWatchAlertInfo()
	{
		player.watch.WatchHintWithSFX(1f, SFXAlertType.INFO);
	}

	private void PopulateKit()
	{
		StartCoroutine(PopulateKitRoutine());
	}

	private IEnumerator PopulateKitRoutine()
	{
		if (!foundLighter)
		{
			foundLighter = true;
			ExorcismItem component = lighter.GetComponent<ExorcismItem>();
			component.parentTransform = player.HandMenu.exKitScript.caseLid.transform;
			component.originalPos = new Vector3(-0.1453f, 0.019f, -0.0253f);
			component.originalRot = Quaternion.Euler(185.08f, -89.60699f, 85.572f);
			lighter.GetComponent<Rigidbody>().isKinematic = false;
			lighter.GetComponent<Rigidbody>().useGravity = true;
			component.RespawnItem(0f);
			component.inEnvironment = false;
		}
		if (!foundHolyWater)
		{
			foundHolyWater = true;
			ExorcismItem component2 = holyWater.GetComponent<ExorcismItem>();
			component2.parentTransform = player.HandMenu.exKitScript.caseDrawer.transform;
			component2.originalPos = new Vector3(0.0185f, 0.0088f, -0.0814f);
			component2.originalRot = Quaternion.Euler(90f, 0f, -180f);
			component2.RespawnItem(0f);
			component2.inEnvironment = false;
			holyWater.GetComponent<HolyWater>().canSmash = true;
			holyWater.transform.parent = null;
			player.HandMenu.exKitScript.water2.GetComponent<ExorcismItem>().inKit = true;
			player.HandMenu.exKitScript.water2.GetComponent<ExorcismItem>().inEnvironment = false;
		}
		if (!foundSaltSprayer)
		{
			foundSaltSprayer = true;
			ExorcismItem component3 = saltSprayer.GetComponent<ExorcismItem>();
			component3.parentTransform = player.HandMenu.exKitScript.caseLid.transform;
			component3.originalPos = new Vector3(-0.0515f, 0.0111f, -0.0073f);
			component3.originalRot = Quaternion.Euler(83.55601f, 94.039f, -85.93501f);
			component3.RespawnItem(0f);
			component3.inEnvironment = false;
		}
		if (!foundCross)
		{
			foundCross = true;
			cross.SetActive(value: true);
			while (!crucifixPlacedInScene)
			{
				yield return Yield.WaitSeconds(0.5f);
			}
			ExorcismItem component4 = cross.GetComponent<ExorcismItem>();
			component4.parentTransform = player.HandMenu.exKitScript.gameObject.transform;
			component4.originalPos = new Vector3(0.001f, -0.0048f, -0.0013f);
			component4.originalRot = Quaternion.Euler(0f, 0f, 0f);
			component4.RespawnItem(0f);
			component4.inEnvironment = false;
		}
		yield return Yield.WaitSeconds(0.1f);
		GameController.instance.blockLoad = false;
	}

	private void RestartLevel()
	{
		StartCoroutine(RestartLevelRoutine());
	}

	private IEnumerator RestartLevelRoutine()
	{
		player.screenFX.Fade(UnityEngine.Color.black, 3f);
		yield return Yield.WaitSeconds(3f);
		player.MoveToSafeZone();
	}

	public void ExitToPrecinct()
	{
		bool playedTapes = false;
		bool completedKit = false;
		PicoLight.enabled = false;
		if (tapePlayerController.playedTape2 || tapePlayerController.playedTape3)
		{
			playedTapes = true;
		}
		if (foundCross && foundHolyWater && foundLighter && foundSaltSprayer && foundKit)
		{
			completedKit = true;
		}
		GameController.instance.levelCompletionManager.SetLevelCompletionForChapel(playedTapes, completedKit, SaveManager.instance.HasFoundArtifact(ChapterID.CHAPEL), completedLevel: false);
		player.screenFX.Fade(UnityEngine.Color.black, 3f);
		GameController.instance.audioController.SnapMute(3f);
		GameController.instance.boundDetection.SwitchOffOOB();
		GameController.instance.GoToSpecificScene(SCENES.PRECINCT);
	}

	public void ResetProgress()
	{
		player.screenFX.Fade(UnityEngine.Color.black, 1f);
		PopulateKit();
	}

	private void OnDestroy()
	{
		EventManager.StopListening(EventManager.AvailableEvents.IntroComplete.ToString(), IntroCompleted);
		EventManager.StopListening(EventManager.AvailableEvents.ArtifactUnlocked.ToString(), ArtifactUnlocked);
		EventManager.StopListening(EventManager.AvailableEvents.BlockingLoad.ToString(), PopulateKit);
		EventManager.StopListening(EventManager.AvailableEvents.ExitLevelToPrecint.ToString(), ExitToPrecinct);
		EventManager.StopListening(EventManager.AvailableEvents.BrokenObject.ToString(), BreakObject);
	}

	private void DebugCommands()
	{
		if (Input.GetKeyDown(KeyCode.Return))
		{
			StartCoroutine(interactiveDoor.OpenHandle());
		}
	}
}
public class MorgueScene : InteractionManager
{
	private bool introComplete;

	private NVRPlayer player;

	private LightFlicker playerLightFlicker;

	private Camera playerCamera;

	private Light PicoLight;

	private int debugCount;

	[Header("General")]
	[SerializeField]
	private GameObject playerStartPosition;

	[SerializeField]
	private GameObject thirdFloorPlayerStartPosition;

	[SerializeField]
	private GameObject[] changeLayerObjects;

	private SaltSprayer saltSprayer;

	private OilLighter oilLighter;

	[Space]
	[Header("Rooms")]
	[SerializeField]
	private Room firstFloor_0;

	[SerializeField]
	private Room firstFloor_1;

	[SerializeField]
	private Room elevatorRoom;

	[SerializeField]
	private Room secondFloor_0;

	[SerializeField]
	private Room thirdFloor_0;

	[SerializeField]
	private Room thirdFloor_1;

	[SerializeField]
	private GameObject elevatorShaft;

	[Space]
	[Header("Spatial Audio Sources")]
	[SerializeField]
	private AudioScript floatingAudio_01;

	[SerializeField]
	private AudioScript floatingAudio_02;

	[SerializeField]
	private Transform[] floatingAudioPoint;

	[SerializeField]
	private AudioClip[] floatingAudioClip;

	[SerializeField]
	private AudioSource[] firstFloorFoley;

	[SerializeField]
	private AudioSource[] secondFloorFoley;

	[SerializeField]
	private AudioSource[] thirdFloorFoley;

	[SerializeField]
	private AudioScript playerStereoAudio_01;

	[SerializeField]
	private AudioScript playerStereoAudio_02;

	[SerializeField]
	private AudioClip playerSineClip;

	[SerializeField]
	private AudioSource elevatorFoley;

	[Space]
	[Header("Voice Over")]
	[SerializeField]
	private AudioScript baalFloat_Spatial;

	[SerializeField]
	private AudioScript baalFloat_Stereo;

	[SerializeField]
	private AudioClip[] voBaal;

	private int baalVOTauntIndex = 15;

	[SerializeField]
	private AudioClip[] voBaalPlayerDodged;

	private int voBaalDodgedIndex;

	[SerializeField]
	private Transform[] baalFloatingAudioPoint;

	[Space]
	[Header("Music")]
	[SerializeField]
	private AudioClip musicBedLow;

	[SerializeField]
	private AudioClip musicBedHeavy;

	[SerializeField]
	private AudioClip musicBrassHit;

	[SerializeField]
	private AudioClip musicBuild20sec;

	[SerializeField]
	private AudioClip musicBuild30sec;

	[SerializeField]
	private AudioClip musicHighLoop;

	[SerializeField]
	private AudioClip musicCarouselBuild;

	[SerializeField]
	private AudioClip musicBaalHeartbeat;

	[SerializeField]
	private AudioClip musicBaalFightLoop;

	[SerializeField]
	private AudioClip musicLoopHigh;

	[SerializeField]
	private AudioClip musicOutToPrecinct;

	private float audioSyncLoopTime;

	[Space]
	[Header("Fade In")]
	[SerializeField]
	private TextMeshProUGUI chapterName;

	[SerializeField]
	private TextMeshProUGUI chapterNumber;

	[Space]
	[Header("Elevator")]
	[SerializeField]
	private Elevator elevator;

	[SerializeField]
	private InteractiveDoor elevatorGate;

	[SerializeField]
	private GameObject largeGateCollider;

	[SerializeField]
	private GameObject elevatorGateOOB;

	[SerializeField]
	private LadderRelease ladderRelease;

	[SerializeField]
	private NVRInteractableItem ladderGrabPoint;

	[HideInInspector]
	private bool grabbedTheLadder;

	[SerializeField]
	private AudioClip ladderClimbAudioClip;

	[SerializeField]
	private GameObject elevatorSecondFloorStartPosition;

	[SerializeField]
	private GameObject elevatorSecondFloorWalkway;

	[SerializeField]
	private AudioClip elevatorFoleyLoud;

	[SerializeField]
	private GameObject plankCrackTrigger;

	[SerializeField]
	private Animator plankAnimator;

	[SerializeField]
	private GameObject firstFloorElevatorNavBlocker;

	private bool playedPlankCrack;

	[Space]
	[Header("FirstFloor")]
	[SerializeField]
	private Beacon beacon;

	[SerializeField]
	private PuzzleBoxArtifact puzzleboxArtifact;

	[SerializeField]
	private Dictaphone dictaphone;

	[SerializeField]
	private GameObject emergencyExitTrigger;

	[SerializeField]
	private bool triggeredEmergencyExit;

	[SerializeField]
	private Animator emergencyExitAnimator;

	[SerializeField]
	private GameObject firstFloorCockroachTrigger;

	[SerializeField]
	private GameObject firstFloorCockroaches;

	[SerializeField]
	private GameObject firstFloorElevatorSfxTrigger;

	[SerializeField]
	private AudioScript firstFloorLiftFoley;

	[SerializeField]
	private GameObject firstFloorLiftShaftTrigger;

	private bool inFirstFloorElevatorSfxTrigger;

	[Space]
	[Header("SecondFloor")]
	[SerializeField]
	private bool isFloorPowerOn;

	[SerializeField]
	private bool inSideRoom;

	[SerializeField]
	private GameObject sideRoomTrigger;

	[SerializeField]
	private bool fuseboxOpen;

	[SerializeField]
	private bool fuseboxLeaverPulled;

	[SerializeField]
	private ParticleSystem fuseBoxParticles;

	[SerializeField]
	private AudioScript powerGeneratorAudio;

	[SerializeField]
	private AudioClip powerGenUpClip;

	[SerializeField]
	private AudioClip powerGenLoopClip;

	[SerializeField]
	private GameObject playerHeadParticle;

	[SerializeField]
	private HingeJoint fanHingeJoint;

	[SerializeField]
	private AutopsyLight autopsyLight;

	[SerializeField]
	private DigitalCamera digitalCamera;

	[SerializeField]
	private Animator corpseBodyBagAnimator;

	[SerializeField]
	private GameObject corpseBodyBagTrigger;

	[SerializeField]
	private GameObject bodyBagLayDownTrigger;

	[SerializeField]
	private bool seenCorpseBodyBag;

	[SerializeField]
	private bool seenBodyBagDrop;

	[SerializeField]
	private GameObject roomDivider;

	[SerializeField]
	private Transform roomDividerEndPos;

	[SerializeField]
	private GameObject fusebox;

	[SerializeField]
	private InteractiveDoor sideRoomDoor;

	[SerializeField]
	private InteractiveDoor fuseboxDoor;

	[SerializeField]
	private NVRInteractableItem fuseboxLeaver;

	[SerializeField]
	private GameObject hopkinsTrigger;

	[SerializeField]
	private bool inHopkinsTriggerArea;

	[SerializeField]
	private GameObject hopkinsSightTrigger;

	[SerializeField]
	private bool inHopkinsSightTriggerArea;

	[SerializeField]
	private Animator hopkinsAnimator;

	[SerializeField]
	private GameObject shutter;

	[SerializeField]
	private Printer printer;

	[SerializeField]
	private TabletComputer tabletComputer;

	[SerializeField]
	private IDScanner idScanner;

	[SerializeField]
	private bool inChickenTriggerAreaMorgue;

	[SerializeField]
	private GameObject chickenTriggerMorgue;

	[SerializeField]
	private GameObject chickenTriggerMorgueSkippedTrigger_1;

	[SerializeField]
	private GameObject chickenTriggerMorgueSkippedTrigger_2;

	[SerializeField]
	private bool inChickenSightTriggerAreaMorgue;

	[SerializeField]
	private GameObject chickenSightTriggerMorgue;

	[SerializeField]
	private Animator chickenAnimator;

	[SerializeField]
	private ParticleSystem chickenFeatherSlab;

	[SerializeField]
	private GameObject chicken;

	[SerializeField]
	private SkinnedMeshRenderer chickenMesh;

	[SerializeField]
	private GameObject sinkRoaches;

	[SerializeField]
	private Animator showerVinesAnimator;

	[SerializeField]
	private GameObject showerTrigger;

	[SerializeField]
	private bool inShowerTriggerArea;

	[SerializeField]
	private GameObject showerSightTrigger;

	[SerializeField]
	private bool inShowerSightTriggerArea;

	[SerializeField]
	private GameObject showerRoaches;

	[SerializeField]
	private GameObject deskRoaches;

	[SerializeField]
	private GameObject elevatorHazmat;

	[SerializeField]
	private AudioClip insectSoundClip;

	[SerializeField]
	private GameObject tapHot;

	[SerializeField]
	private GameObject tapCold;

	[SerializeField]
	private SinkRoaches roaches;

	private bool ranSinkRoaches;

	[Space]
	[Header("ThirdFloor")]
	[SerializeField]
	private LightFlicker corridorLight01;

	[SerializeField]
	private LightFlicker corridorLight02;

	[SerializeField]
	private LightFlicker corridorLight03;

	[SerializeField]
	private LightFlicker corridorLight04;

	[SerializeField]
	private GameObject corridorTrigger;

	[SerializeField]
	private Animator corridorSwayAnim;

	[SerializeField]
	private InteractiveDoor morgueDoorLeft;

	[SerializeField]
	private InteractiveDoor morgueDoorRight;

	[SerializeField]
	private GameObject morgueDoorParentObject;

	[SerializeField]
	private Material blackVeinHandMaterial;

	[SerializeField]
	private Material standardHandMaterial;

	[SerializeField]
	private GameObject morgueDrainSightTrigger;

	[SerializeField]
	private Rigidbody finchCross;

	[SerializeField]
	private bool lookedAtMorgueDrain;

	[SerializeField]
	private Animator morgueDrainAnimator;

	private bool alertToSaltSpray = true;

	[SerializeField]
	private Material[] morgueBlendMaterial;

	[SerializeField]
	private GameObject vineSetCeiling;

	[SerializeField]
	private GameObject vineSetFloor;

	[SerializeField]
	private GameObject mainArenaTrigger;

	[SerializeField]
	private GameObject mainArenaNavCarveTrigger;

	[SerializeField]
	private GameObject mainArenaNavCarve;

	[SerializeField]
	private GameObject finch;

	[SerializeField]
	private GameObject[] allChickens;

	[SerializeField]
	private GameObject chickenTriggerArea;

	[SerializeField]
	private Animator chickenScareAnimator;

	[SerializeField]
	private ParticleSystem chickenScareParticles;

	[SerializeField]
	private Animator finchAnimator;

	[SerializeField]
	private GameObject baalParticleTrail;

	private Animator baalParticleTrailAnim;

	[SerializeField]
	private AudioScript fanFoley;

	[SerializeField]
	private ParticleSystem baalParticleSystem;

	[SerializeField]
	private GameObject finalExorcismPosition;

	[SerializeField]
	private GameObject chenHazmatSuit;

	[SerializeField]
	private GameObject chenHazmatStanding;

	[SerializeField]
	private GameObject chenHazmatSightTrigger;

	[SerializeField]
	private GameObject baalTransitionPose;

	[SerializeField]
	private GameObject baalTransitionPoseChen;

	[SerializeField]
	private Corpse baalOutburstDeadBody;

	[SerializeField]
	private GameObject deadBodyRiseupTriggerArea;

	[SerializeField]
	private GameObject deadBodyRiseupSightTrigger;

	[SerializeField]
	private GameObject carouselPosition;

	[SerializeField]
	private GameObject deadBodyTrolley;

	[SerializeField]
	private Corpse mainDeadBody;

	[SerializeField]
	private Animator carouselAnimator;

	[SerializeField]
	private Corpse[] deadBodies;

	[SerializeField]
	private Baal baal;

	[SerializeField]
	private AudioClip bodySitupClip;

	[SerializeField]
	private Material puddleMaterial;

	[SerializeField]
	private GameObject baalRoaches;

	[SerializeField]
	private ParticleSystem releaseParticles;

	[SerializeField]
	private AudioClip corpseReactGoodClip;

	[SerializeField]
	private AudioClip corpseReactBadClip;

	[SerializeField]
	private AudioClip[] corpseScoffClips;

	private bool runFlickerRoutine;

	private bool lookedAtChenHazmatTrigger;

	private bool baalOnHisKnees;

	[Space]
	[Header("Exoricsm Items")]
	[HideInInspector]
	private bool crossSelected;

	[HideInInspector]
	private bool crossCharged;

	[HideInInspector]
	private GameObject cross;

	[HideInInspector]
	private TuneController tuneCross;

	[HideInInspector]
	private ExorcismItem interactableCross;

	[HideInInspector]
	private bool exorcismComplete;

	[SerializeField]
	private GameObject baalTarget;

	[SerializeField]
	private GameObject[] baalTargetLocations;

	[SerializeField]
	private GameObject chenExorcismTarget;

	[SerializeField]
	private GameObject[] chenExorcismTargetLocations;

	[Space]
	[Header("Misc")]
	[HideInInspector]
	private int bodiesExorcisedCount;

	[HideInInspector]
	private bool inMainArena;

	[HideInInspector]
	private bool inNavCarveArea;

	[HideInInspector]
	private bool inDeadbodyRiseupArea;

	[HideInInspector]
	private bool lookingAtDeadbodyRiseup;

	[HideInInspector]
	private bool hasBeenAttacked;

	[HideInInspector]
	private bool enteredFinalCorridor;

	private AudioSource[] allAudio;

	private float endSlowMoTime = 0.25f;

	[SerializeField]
	private ParticleSystem baalFinaleFlames;

	[SerializeField]
	private LightFlicker baalFlameLight;

	[Space]
	[Header("Sting Rules")]
	[HideInInspector]
	private bool touchedHammer;

	[SerializeField]
	private GameObject notebook01;

	[HideInInspector]
	private bool touchedNotebook01;

	[SerializeField]
	private GameObject letter;

	[HideInInspector]
	private bool touchedNotebook02;

	[Space]
	[Header("Artefact")]
	[SerializeField]
	private GameObject artefact;

	[SerializeField]
	private Animator upgradeAnimator;

	private bool foundAretfact;

	[Space]
	[Header("Achievements")]
	[SerializeField]
	private GameObject bellsCoverNote;

	[SerializeField]
	private bool foundBellsCoverNote;

	[SerializeField]
	private bool notHitByBaal = true;

	[SerializeField]
	private bool researachedTheDisease;

	[SerializeField]
	private GameObject[] diseasedObject;

	[SerializeField]
	private bool playedWithTheDisease;

	[Space]
	[Header("DEBUG")]
	[SerializeField]
	private Transform finalePlayerPos;

	private void Start()
	{
		EventManager.StartListening(EventManager.AvailableEvents.IntroComplete.ToString(), IntroCompleted);
		EventManager.StartListening(EventManager.AvailableEvents.ExitLevelToPrecint.ToString(), ExitToPrecinct);
		EventManager.StartListening(EventManager.AvailableEvents.RestartScene.ToString(), RestartLevel);
		EventManager.StartListening(EventManager.AvailableEvents.ResetProgress.ToString(), ResetProgress);
		player = GameController.instance.player;
		playerCamera = player.Head.GetComponentInChildren<Camera>();
		GameController.instance.audioController.SnapMute(0f);
		player.screenFX.Fade(UnityEngine.Color.black, 0f);
		playerLightFlicker = player.playerLight.GetComponent<LightFlicker>();
		PicoLight = player.PicoLight.GetComponent<Light>();
		player.playerLight.GetComponent<Light>().enabled = true;
		player.playerLight.enabled = true;
		playerLightFlicker.light.enabled = true;
		playerLightFlicker.SwitchLight(switchOn: false);
		playerLightFlicker.light.shadows = LightShadows.None;
		playerLightFlicker.ResetIntensity();
		player.playerLight.EnableRay(enable: false);
		PicoLight.enabled = true;
		player.movement.DisableEverything();
		player.SetPosition(playerStartPosition);
		player.PicoLight.SetActive(value: true);
		saltSprayer = player.HandMenu.exKitScript.salt.GetComponent<SaltSprayer>();
		oilLighter = player.HandMenu.exKitScript.candle.GetComponent<OilLighter>();
		oilLighter.canTurnOnLight = false;
		cross = player.HandMenu.exKitScript.cross;
		tuneCross = cross.GetComponent<TuneController>();
		tuneCross.SetSpotLightEnabled(enabled: true);
		tuneCross.SetPointLightEnabled(enabled: true);
		interactableCross = cross.GetComponent<ExorcismItem>();
		float[] array = new float[32];
		array[14] = 8f;
		playerCamera.layerCullDistances = array;
		GameObject[] array2 = changeLayerObjects;
		for (int i = 0; i < array2.Length; i++)
		{
			array2[i].SetLayer(SortingLayer.NameToID("Default"));
		}
		allAudio = UnityEngine.Object.FindObjectsOfType(typeof(AudioSource)) as AudioSource[];
		StartCoroutine(Master());
	}

	private void IntroCompleted()
	{
		introComplete = true;
	}

	public void Update()
	{
	}

	private IEnumerator Master()
	{
		yield return StartCoroutine(SceneSetup());
		yield return StartCoroutine(FadeInScene());
		yield return StartCoroutine(FirstFloor());
		yield return StartCoroutine(FirstFloorLadderRelease());
		yield return StartCoroutine(LadderToSecondFloor());
		yield return StartCoroutine(SecondFloor());
		yield return StartCoroutine(SecondFloorFusebox());
		yield return StartCoroutine(SecondFloorDictaphone());
		yield return StartCoroutine(SecondFloorIDBadge());
		yield return StartCoroutine(LiftToThirdFloor());
		yield return StartCoroutine(ThirdFloorFinalCorridor());
		yield return StartCoroutine(ThirdFloorFindFinchsBody());
		yield return StartCoroutine(ThirdFloorDeadBodysRise());
		yield return StartCoroutine(ThirdFloorFinalExorcism());
		yield return StartCoroutine(FadeOutScene());
	}

	private IEnumerator SceneSetup()
	{
		baalParticleTrailAnim = baalParticleTrail.GetComponent<Animator>();
		baalFlameLight.SwitchLight(switchOn: false);
		firstFloor_0.associatedParentGameObject.SetActive(value: false);
		firstFloor_0.UpdateColliders(enabled: false);
		firstFloor_1.associatedParentGameObject.SetActive(value: false);
		firstFloor_1.UpdateColliders(enabled: true);
		elevatorRoom.associatedParentGameObject.SetActive(value: false);
		secondFloor_0.associatedParentGameObject.SetActive(value: false);
		thirdFloor_0.associatedParentGameObject.SetActive(value: false);
		thirdFloor_1.associatedParentGameObject.SetActive(value: false);
		thirdFloor_1.UpdateColliders(enabled: true);
		elevatorShaft.SetActive(value: false);
		fuseboxLeaver.enabled = false;
		mainArenaTrigger.SetActive(value: false);
		mainArenaNavCarveTrigger.SetActive(value: false);
		corpseBodyBagTrigger.SetActive(value: false);
		elevator.elevatorLight.SwitchLight(switchOn: false);
		chickenTriggerMorgue.SetActive(value: false);
		chickenTriggerMorgueSkippedTrigger_1.SetActive(value: false);
		chickenTriggerMorgueSkippedTrigger_2.SetActive(value: false);
		baalTransitionPose.SetActive(value: false);
		baalTransitionPoseChen.SetActive(value: false);
		baal.gameObject.SetActive(value: false);
		corridorTrigger.SetActive(value: false);
		fanHingeJoint.useMotor = false;
		morgueDrainSightTrigger.SetActive(value: false);
		deadBodyRiseupTriggerArea.SetActive(value: false);
		deadBodyRiseupSightTrigger.SetActive(value: false);
		mainArenaNavCarve.SetActive(value: false);
		chenHazmatStanding.SetActive(value: false);
		chickenScareAnimator.enabled = false;
		chenHazmatSightTrigger.SetActive(value: false);
		firstFloorLiftShaftTrigger.SetActive(value: false);
		bodyBagLayDownTrigger.SetActive(value: false);
		for (int i = 0; i < firstFloorFoley.Length; i++)
		{
			firstFloorFoley[i].Play();
		}
		GameController.instance.currentRoom = firstFloor_0;
		firstFloor_0.UpdateColliders(enabled: false);
		firstFloor_0.associatedParentGameObject.SetActive(value: true);
		firstFloor_0.playerInRoom = true;
		firstFloor_1.UpdateColliders(enabled: true);
		firstFloor_1.associatedParentGameObject.SetActive(value: false);
		firstFloor_1.playerInRoom = false;
		yield return new WaitForSeconds(0.25f);
	}

	private IEnumerator FadeInScene()
	{
		player.HandMenu.BookInMenu(active: true);
		player.HandMenu.KitInMenu(active: true);
		yield return Yield.EndOfFrame;
		player.LeftHand.SwapOutHandMaterial(standardHandMaterial);
		player.RightHand.SwapOutHandMaterial(standardHandMaterial);
		yield return Yield.EndOfFrame;
		while (!introComplete)
		{
			yield return null;
		}
		SaveManager.instance.MarkChapterStarted(ChapterID.MORGUE);
		EventManager.TriggerEvent(EventManager.AvailableEvents.SwitchedScenes.ToString());
		firstFloor_0.associatedParentGameObject.SetActive(value: true);
		elevator.MoveElevator(0);
		yield return Yield.EndOfFrame;
		player.SetPosition(playerStartPosition);
		chapterName.transform.parent.gameObject.SetActive(value: true);
		player.movement.EnableEverything();
		player.playerLight.PlayClick();
		playerLightFlicker.SetHighIntensity(0.9f);
		playerLightFlicker.StartBurst(1f, finishOn: true);
		yield return Yield.WaitSeconds(1f);
		oilLighter.canTurnOnLight = true;
		player.playerLight.shouldLightBeOn = true;
		yield return Yield.WaitSeconds(4f);
		GameController.instance.audioController.SnapAllOpen(3f);
		player.screenFX.Fade(UnityEngine.Color.clear, 4f);
		yield return Yield.WaitSeconds(2f);
		GameController.instance.boundDetection.SwitchOnOOB();
		yield return Yield.EndOfFrame;
		if (SaveManager.instance.HasFoundArtifact(ChapterID.MORGUE))
		{
			puzzleboxArtifact.SetArtifactRevealed();
		}
		chapterName.CrossFadeAlpha(0f, 3f, ignoreTimeScale: false);
		chapterNumber.CrossFadeAlpha(0f, 3f, ignoreTimeScale: false);
		yield return Yield.EndOfFrame;
	}

	private IEnumerator FirstFloor()
	{
		GameController.instance.hintManager.AddHint(ladderRelease.hammer);
		GameController.instance.hintManager.AddHint(ladderRelease.gameObject);
		beacon.PlayAlertLoop();
		while (!triggeredEmergencyExit)
		{
			yield return Yield.EndOfFixedUpdate;
		}
		playerStereoAudio_01.FadeIn(musicBedLow, 0.5f, 1f, loop: true);
		yield return Yield.WaitSeconds(1.5f);
		emergencyExitAnimator.SetTrigger("Door_Bang");
		floatingAudio_01.transform.position = floatingAudioPoint[0].position;
		floatingAudio_01.Play(floatingAudioClip[0], 1.2f);
	}

	private IEnumerator FirstFloorLadderRelease()
	{
		while (!ladderRelease.smashedGlass)
		{
			yield return Yield.EndOfFrame;
		}
		GameController.instance.hintManager.RemoveHint(ladderRelease.hammer);
		GameController.instance.hintManager.RemoveHint(ladderRelease.gameObject);
		floatingAudio_01.transform.position = floatingAudioPoint[1].position;
		floatingAudio_01.Play(floatingAudioClip[1]);
		playerStereoAudio_01.FadeVolumeIn(1.25f, 0.8f);
		yield return Yield.WaitSeconds(1f);
		LeanTween.moveLocalZ(elevatorGate.transform.parent.gameObject, -0.25f, 1f).setEase(LeanTweenType.easeOutExpo);
		floatingAudio_02.transform.position = floatingAudioPoint[2].position;
		floatingAudio_02.Play(floatingAudioClip[2]);
		largeGateCollider.SetActive(value: false);
		elevatorGate.UnlockDoor();
		while (elevatorGate.transform.parent.localPosition.z > -0.3f)
		{
			yield return Yield.EndOfFrame;
		}
		yield return Yield.WaitSeconds(2f);
		floatingAudio_02.transform.position = floatingAudioPoint[2].position;
		floatingAudio_02.Play(floatingAudioClip[18]);
		ladderRelease.ReleaseLadder();
		firstFloorLiftShaftTrigger.SetActive(value: true);
	}

	private IEnumerator LadderToSecondFloor()
	{
		while (!grabbedTheLadder)
		{
			yield return Yield.WaitSeconds(0.3f);
		}
		beacon.StopAlertLoop();
		player.movement.DisableEverything();
		ladderRelease.LockLadderInPosition();
		yield return Yield.EndOfFrame;
		player.screenFX.Fade(UnityEngine.Color.black, 0.5f);
		yield return Yield.WaitSeconds(0.5f);
		GameController.instance.currentRoom.SwitchOffOOB();
		GameController.instance.currentRoom = secondFloor_0;
		firstFloor_0.UpdateColliders(enabled: true);
		firstFloor_0.associatedParentGameObject.SetActive(value: false);
		firstFloor_0.playerInRoom = false;
		firstFloor_1.UpdateColliders(enabled: true);
		firstFloor_1.associatedParentGameObject.SetActive(value: false);
		firstFloor_1.playerInRoom = false;
		secondFloor_0.UpdateColliders(enabled: false);
		secondFloor_0.associatedParentGameObject.SetActive(value: true);
		secondFloor_0.playerInRoom = true;
		GameController.instance.audioController.persistentMusicPlayer.Play(ladderClimbAudioClip, 0.8f);
		elevator.MoveElevator(0);
		elevatorSecondFloorWalkway.SetActive(value: true);
		player.movement.ForceTeleport(elevatorSecondFloorStartPosition.transform.position);
		yield return Yield.EndOfFrame;
		for (int i = 0; i < firstFloorFoley.Length; i++)
		{
			firstFloorFoley[i].Stop();
		}
		yield return Yield.EndOfFrame;
		for (int j = 0; j < secondFloorFoley.Length; j++)
		{
			secondFloorFoley[j].Play();
		}
		floatingAudio_01.transform.position = floatingAudioPoint[3].position;
		floatingAudio_01.PlayLoop(floatingAudioClip[3]);
		player.playerLight.SetRange(3.5f);
		Camera componentInChildren = player.Head.GetComponentInChildren<Camera>();
		float[] array = new float[32];
		array[14] = 5f;
		componentInChildren.layerCullDistances = array;
		UnityEngine.Color color = default(UnityEngine.Color);
		color.r = 0.68f;
		color.g = 1f;
		color.b = 0.85f;
		player.playerLight.SetColour(color);
		yield return Yield.WaitSeconds(4f);
		playerHeadParticle.transform.position = player.Head.transform.position;
		playerHeadParticle.transform.rotation = player.Head.transform.rotation;
		playerHeadParticle.transform.SetParent(player.Head.transform);
		player.screenFX.Fade(UnityEngine.Color.clear, 0.5f);
		yield return Yield.WaitSeconds(0.5f);
		player.movement.EnableEverything();
		GameController.instance.currentRoom.SwitchOnOOB();
		GameController.instance.hintManager.AddHint(fuseboxDoor);
	}

	private IEnumerator SecondFloor()
	{
		chickenTriggerMorgue.SetActive(value: true);
		chickenSightTriggerMorgue.SetActive(value: true);
		chickenTriggerMorgueSkippedTrigger_1.SetActive(value: true);
		chickenTriggerMorgueSkippedTrigger_2.SetActive(value: true);
		yield return new WaitForEndOfFrame();
	}

	private IEnumerator ChickenScareAttack()
	{
		chickenTriggerArea.SetActive(value: false);
		chickenScareAnimator.enabled = true;
		chickenScareParticles.Play();
		floatingAudio_01.transform.position = floatingAudioPoint[12].position;
		floatingAudio_01.Play(floatingAudioClip[12]);
		chickenScareAnimator.SetTrigger("Attack");
		yield return Yield.WaitSeconds(3.2f);
		chickenScareAnimator.enabled = false;
		StartCoroutine(AlertPlayerToSaltSprayRoutine(5f));
	}

	private IEnumerator ChickenFlyOff(bool disableMesh)
	{
		if (disableMesh)
		{
			chickenMesh.enabled = false;
		}
		chickenAnimator.SetTrigger("FlyOff");
		floatingAudio_01.transform.position = floatingAudioPoint[4].position;
		floatingAudio_01.Play(floatingAudioClip[4]);
		GameController.instance.audioController.PlayBadSting(STINGS_BAD.BAD_SOFT_STING_01);
		chickenFeatherSlab.Play();
		yield return Yield.WaitSeconds(2.8f);
		chicken.SetActive(value: false);
	}

	private IEnumerator PullFuseboxLever()
	{
		LeanTween.rotateAround(fuseboxLeaver.gameObject, Vector3.forward, 180f, 0.25f).setEase(LeanTweenType.easeInQuart);
		yield return Yield.WaitSeconds(0.25f);
		fuseboxLeaver.EnableReparentOnDetach = true;
		fuseBoxParticles.Play();
		fuseboxLeaverPulled = true;
	}

	private IEnumerator SecondFloorFusebox()
	{
		while (!fuseboxOpen)
		{
			yield return Yield.EndOfFixedUpdate;
		}
		GameController.instance.hintManager.RemoveHint(fuseboxDoor);
		GameController.instance.hintManager.AddHint(fuseboxLeaver);
		GameController.instance.audioController.PlayGoodSting(STINGS_GOOD.GOOD_SOFT_STING_01, 0.3f);
		bodyBagLayDownTrigger.SetActive(value: true);
		fuseboxLeaver.enabled = true;
		while (!fuseboxLeaverPulled)
		{
			yield return Yield.EndOfFixedUpdate;
		}
		if (showerTrigger.activeInHierarchy)
		{
			showerTrigger.SetActive(value: false);
			showerSightTrigger.SetActive(value: false);
			showerVinesAnimator.SetTrigger("Disappear");
		}
		GameController.instance.hintManager.RemoveHint(fuseboxLeaver);
		GameController.instance.hintManager.AddHint(idScanner.gameObject);
		playerStereoAudio_02.Play(musicBuild20sec, 0.8f);
		if (chicken.activeInHierarchy)
		{
			chicken.SetActive(value: false);
		}
		yield return Yield.EndOfFrame;
		elevatorHazmat.SetActive(value: true);
		yield return Yield.EndOfFrame;
		floatingAudio_01.transform.position = floatingAudioPoint[5].position;
		floatingAudio_01.Play(floatingAudioClip[5]);
		fuseboxLeaver.enabled = false;
		roomDivider.transform.position = roomDividerEndPos.position;
		isFloorPowerOn = true;
		yield return Yield.EndOfFrame;
		dictaphone.SwitchDockOn();
		yield return Yield.EndOfFrame;
		StartCoroutine(QueuePowerClip());
		yield return Yield.WaitSeconds(0.5f);
		idScanner.PowerSwitchedOn();
		yield return Yield.WaitSeconds(1f);
		StartCoroutine(QueueShutterClip());
		LeanTween.moveLocalY(shutter, 0.116f, 0.4f);
		yield return Yield.WaitSeconds(0.4f);
		LeanTween.moveLocalY(shutter, 0.923f, 6f);
		fanHingeJoint.useMotor = true;
		fanHingeJoint.gameObject.GetComponent<AudioSource>().Play();
		yield return Yield.WaitSeconds(3f);
		corpseBodyBagAnimator.SetTrigger("Situp_Idle");
		floatingAudio_02.transform.position = floatingAudioPoint[7].position;
		floatingAudio_02.Play(floatingAudioClip[16]);
		yield return Yield.EndOfFrame;
		playerStereoAudio_02.FadeOut(3f);
		while (inSideRoom)
		{
			yield return Yield.EndOfFrame;
		}
		secondFloor_0.UpdateColliders(enabled: false);
		playerStereoAudio_01.FadeOut(3f);
		yield return Yield.EndOfFrame;
		yield return Yield.EndOfFrame;
		elevator.floor2Gate.SetActive(value: true);
		elevator.MoveElevator(1);
		yield return Yield.WaitSeconds(0.5f);
		tabletComputer.PowerButtonPressed();
		yield return Yield.WaitSeconds(0.5f);
		printer.PowerButtonPressed();
		yield return Yield.EndOfFrame;
	}

	private IEnumerator QueueShutterClip()
	{
		floatingAudio_01.transform.position = floatingAudioPoint[6].position;
		floatingAudio_01.FadeIn(floatingAudioClip[6], 0.5f, 3f, loop: true);
		yield return Yield.WaitSeconds(6.8f);
		floatingAudio_01.StopLoop();
	}

	private IEnumerator QueuePowerClip()
	{
		powerGeneratorAudio.Play(powerGenUpClip);
		yield return Yield.WaitSeconds(powerGenUpClip.length);
		powerGeneratorAudio.PlayLoop(powerGenLoopClip);
	}

	private IEnumerator SecondFloorDictaphone()
	{
		yield return Yield.WaitSeconds(1f);
	}

	private IEnumerator SecondFloorIDBadge()
	{
		while (!idScanner.elevatorAccessGranted)
		{
			yield return Yield.WaitSeconds(0.1f);
		}
		GameController.instance.hintManager.RemoveHint(idScanner.gameObject);
		corpseBodyBagTrigger.SetActive(value: true);
		elevator.SetAccessGranted(accessGranted: true);
		playerStereoAudio_01.FadeIn(musicBedHeavy, 0.8f, 3f, loop: true);
		while (elevator.isMoving)
		{
			yield return Yield.WaitSeconds(1f);
		}
		elevator.floor2Gate.SetActive(value: false);
	}

	private IEnumerator LiftToThirdFloor()
	{
		while (!elevator.insideLift)
		{
			yield return Yield.WaitSeconds(0.1f);
		}
		seenCorpseBodyBag = true;
		while (!elevator.floorSelected)
		{
			yield return Yield.EndOfFrame;
		}
		floatingAudio_01.transform.position = floatingAudioPoint[17].position;
		floatingAudio_01.Play(floatingAudioClip[20]);
		playerStereoAudio_01.FadeOut(2f);
		player.movement.DisableMovement();
		GameController.instance.currentRoom.SwitchOffOOB();
		elevatorFoley.clip = elevatorFoleyLoud;
		elevatorFoley.loop = true;
		elevatorFoley.Play();
		player.transform.parent = elevator.gameObject.transform;
		thirdFloor_0.associatedParentGameObject.SetActive(value: true);
		thirdFloor_0.UpdateColliders(enabled: false);
		yield return Yield.EndOfFrame;
		morgueBlendMaterial[0].SetFloat("_BlendMix", 0f);
		yield return Yield.EndOfFrame;
		morgueBlendMaterial[1].SetFloat("_BlendMix", 0f);
		yield return Yield.EndOfFrame;
		morgueBlendMaterial[2].SetFloat("_BlendMix", 0f);
		yield return Yield.EndOfFrame;
		LeanTween.moveLocalY(vineSetCeiling, 6f, 0f);
		yield return Yield.EndOfFrame;
		LeanTween.moveLocalY(vineSetFloor, -3f, 0f);
		elevator.floor.SetActive(value: true);
		yield return Yield.EndOfFrame;
		elevatorSecondFloorWalkway.SetActive(value: false);
		yield return Yield.EndOfFrame;
		elevator.MoveElevator(2, working: true);
		yield return Yield.EndOfFrame;
		player.playerLight.SetRange(5f);
		player.playerLight.shouldLightBeOn = false;
		if (oilLighter.isOn)
		{
			oilLighter.TurnOffLight();
			playerLightFlicker.SwitchLight(switchOn: true);
		}
		oilLighter.canTurnOnLight = false;
		yield return Yield.WaitSeconds(6f);
		seenBodyBagDrop = false;
		corpseBodyBagTrigger.SetActive(value: true);
		while (!seenBodyBagDrop)
		{
			yield return null;
		}
		playerLightFlicker.StartBurst(6f, finishOn: false);
		baalFloat_Spatial.transform.position = floatingAudioPoint[7].position;
		baalFloat_Spatial.Play(voBaal[0], 0.8f);
		HUD.Instance.PlaySubtitles(voBaal[0].name, hasPriority: true);
		yield return Yield.WaitSeconds(1f);
		corpseBodyBagAnimator.SetTrigger("Shimmy");
		yield return Yield.EndOfFrame;
		floatingAudio_01.transform.position = floatingAudioPoint[9].position;
		floatingAudio_01.PlayLoop(floatingAudioClip[9], 0.65f);
		yield return Yield.WaitSeconds(3f);
		elevator.MoveElevator(3, working: true);
		yield return Yield.WaitSeconds(1.1f);
		player.screenFX.Fade(UnityEngine.Color.black, 0.24f);
		yield return Yield.WaitSeconds(0.25f);
		secondFloor_0.associatedParentGameObject.SetActive(value: false);
		powerGeneratorAudio.StopLoop();
		yield return Yield.EndOfFrame;
		playerStereoAudio_01.FadeIn(playerSineClip, 1f, 2f, loop: true);
		player.playerLight.ResetRange();
		yield return Yield.WaitSeconds(2f);
		elevator.floor.SetActive(value: false);
		elevator.DisableParentedObjects();
		yield return Yield.EndOfFrame;
		player.transform.parent = GameController.instance.gameObject.transform;
		player.transform.parent = null;
		player.transform.localEulerAngles = new Vector3(0f, player.transform.localEulerAngles.y, 0f);
		yield return Yield.EndOfFrame;
		player.LeftHand.SwapOutHandMaterial(blackVeinHandMaterial);
		yield return Yield.EndOfFrame;
		player.RightHand.SwapOutHandMaterial(blackVeinHandMaterial);
		yield return Yield.EndOfFrame;
		blackVeinHandMaterial.SetFloat("_BlendMix", 0.1f);
		yield return Yield.EndOfFrame;
		for (int i = 0; i < secondFloorFoley.Length; i++)
		{
			secondFloorFoley[i].Stop();
		}
		for (int j = 0; j < thirdFloorFoley.Length; j++)
		{
			thirdFloorFoley[j].Play();
		}
		GameController.instance.currentRoom = thirdFloor_0;
		secondFloor_0.UpdateColliders(enabled: true);
		secondFloor_0.associatedParentGameObject.SetActive(value: false);
		secondFloor_0.playerInRoom = false;
		thirdFloor_0.UpdateColliders(enabled: false);
		thirdFloor_0.associatedParentGameObject.SetActive(value: true);
		thirdFloor_0.playerInRoom = true;
		thirdFloor_1.UpdateColliders(enabled: true);
		thirdFloor_1.associatedParentGameObject.SetActive(value: false);
		thirdFloor_1.playerInRoom = false;
		player.playerLight.ResetColour();
		yield return Yield.WaitSeconds(2f);
		player.screenFX.BlurScreen(enabled: true);
		player.screenFX.Fade(UnityEngine.Color.clear, 6f);
		baalFloat_Stereo.transform.position = baalFloatingAudioPoint[0].position;
		baalFloat_Stereo.Play(voBaal[1], 0.6f);
		HUD.Instance.PlaySubtitles(voBaal[1].name, hasPriority: true);
		yield return Yield.WaitSeconds(3f);
		GameController.instance.currentRoom.SwitchOnOOB();
		player.playerLight.shouldLightBeOn = true;
		if (oilLighter.isOn)
		{
			oilLighter.TurnOnLight();
		}
		else
		{
			playerLightFlicker.StartBurst(3f, finishOn: true);
		}
		oilLighter.canTurnOnLight = true;
		player.screenFX.BlurScreen(enabled: false, fade: true, 2f);
		playerStereoAudio_01.FadeOut(5f);
		player.movement.EnableMovement();
	}

	public void ThirdFloorDoorInteraction()
	{
		GameController.instance.currentRoom.SwitchOffOOB();
		GameController.instance.currentRoom = thirdFloor_1;
		secondFloor_0.UpdateColliders(enabled: true);
		secondFloor_0.associatedParentGameObject.SetActive(value: false);
		secondFloor_0.playerInRoom = false;
		thirdFloor_0.playerInRoom = false;
		thirdFloor_1.UpdateColliders(enabled: false);
		thirdFloor_1.associatedParentGameObject.SetActive(value: true);
		thirdFloor_1.playerInRoom = true;
		player.playerLight.SetRange(5f);
		GameController.instance.currentRoom.SwitchOnOOB();
	}

	private IEnumerator ThirdFloorFinalCorridor()
	{
		corridorTrigger.SetActive(value: true);
		while (!enteredFinalCorridor)
		{
			yield return null;
		}
		morgueDoorLeft.doorLocked = true;
		morgueDoorLeft.LockDoor();
		morgueDoorRight.doorLocked = true;
		morgueDoorRight.LockDoor();
		playerStereoAudio_01.FadeIn(playerSineClip, 1f, 4f, loop: true);
		yield return Yield.WaitSeconds(1f);
		playerStereoAudio_02.FadeIn(musicBedHeavy, 1f, 8f, loop: true);
		morgueDoorLeft.Rigidbody.isKinematic = true;
		morgueDoorRight.Rigidbody.isKinematic = true;
		corridorSwayAnim.gameObject.SetActive(value: true);
		corridorSwayAnim.SetTrigger("Sway");
		yield return Yield.WaitSeconds(2f);
		baalFloat_Stereo.transform.position = baalFloatingAudioPoint[1].position;
		baalFloat_Stereo.Play(voBaal[2], 0.6f);
		HUD.Instance.PlaySubtitles(voBaal[2].name, hasPriority: true);
		yield return Yield.WaitSeconds(6f);
		playerStereoAudio_01.FadeOut(4f);
		yield return Yield.WaitSeconds(4f);
		morgueDoorParentObject.transform.SetParent(null);
		morgueDoorLeft.UnlockDoor();
		morgueDoorLeft.doorLocked = false;
		morgueDoorRight.UnlockDoor();
		morgueDoorRight.doorLocked = false;
		mainArenaTrigger.SetActive(value: true);
		while (!inMainArena)
		{
			yield return null;
		}
		thirdFloor_0.UpdateColliders(enabled: true);
		thirdFloor_0.associatedParentGameObject.SetActive(value: false);
		GameController.instance.audioController.PlayBadSting(STINGS_BAD.BAD_SOFT_STING_02, 0.8f);
		floatingAudio_01.transform.position = floatingAudioPoint[10].position;
		floatingAudio_01.Play(floatingAudioClip[10]);
		LeanTween.moveLocal(deadBodyTrolley, new Vector3(2.033f, -0.01099968f, 1.207f), 0.45f);
		yield return Yield.WaitSeconds(0.5f);
		morgueDoorLeft.doorLocked = true;
		morgueDoorLeft.LockDoor();
		morgueDoorRight.doorLocked = true;
		morgueDoorRight.LockDoor();
		corridorSwayAnim.gameObject.SetActive(value: false);
		elevatorShaft.gameObject.SetActive(value: false);
		morgueDrainAnimator.SetTrigger("Shake");
		yield return Yield.EndOfFrame;
		floatingAudio_02.transform.position = floatingAudioPoint[11].position;
		floatingAudio_02.PlayLoop(floatingAudioClip[11], 0.3f);
		morgueDrainSightTrigger.SetActive(value: true);
		StartCoroutine(LookAtMorgueDrainRoutine());
	}

	private IEnumerator LookAtMorgueDrainRoutine()
	{
		while (!lookedAtMorgueDrain)
		{
			yield return Yield.WaitSeconds(0.5f);
		}
		GameController.instance.audioController.PlayBadSting(STINGS_BAD.BAD_STING_01, 0.6f);
		morgueDrainAnimator.SetTrigger("Scurry");
		yield return Yield.EndOfFrame;
		floatingAudio_02.transform.position = floatingAudioPoint[14].position;
		floatingAudio_02.Play(floatingAudioClip[14], 0.8f);
		yield return Yield.EndOfFrame;
		LeanTween.moveLocalY(vineSetCeiling, 3f, 8f).setEase(LeanTweenType.easeOutCubic);
		yield return Yield.EndOfFrame;
		LeanTween.moveLocalY(vineSetFloor, 0f, 8f).setEase(LeanTweenType.easeOutCubic);
		yield return Yield.WaitSeconds(2f);
		baalFloat_Stereo.transform.position = baalFloatingAudioPoint[2].position;
		baalFloat_Stereo.Play(voBaal[3], 0.6f);
		HUD.Instance.PlaySubtitles(voBaal[3].name, hasPriority: true);
		float blendMixValue = 0f;
		while (blendMixValue < 1f)
		{
			yield return Yield.EndOfFrame;
			blendMixValue += 0.05f;
			morgueBlendMaterial[0].SetFloat("_BlendMix", blendMixValue);
			morgueBlendMaterial[1].SetFloat("_BlendMix", blendMixValue);
			morgueBlendMaterial[2].SetFloat("_BlendMix", blendMixValue);
		}
	}

	private IEnumerator AlertPlayerToSaltSprayRoutine(float timeToAlert)
	{
		yield return Yield.WaitSeconds(timeToAlert);
		if (alertToSaltSpray)
		{
			player.HandMenu.OpenStraightToBook(NotebookPages.Q09);
			player.watch.WatchHintWithSFX(3f, SFXAlertType.ALERT);
			alertToSaltSpray = false;
		}
	}

	private IEnumerator ThirdFloorFindFinchsBody()
	{
		saltSprayer.currentTarget = finch;
		GameController.instance.hintManager.AddHint(finch);
		while (!saltSprayer.hitTarget)
		{
			yield return Yield.WaitSeconds(0.5f);
		}
		GameController.instance.hintManager.RemoveHint(finch);
		lookedAtMorgueDrain = true;
		alertToSaltSpray = false;
		finchAnimator.SetTrigger("SprayRelease");
		finchCross.isKinematic = false;
		floatingAudio_01.transform.position = floatingAudioPoint[13].position;
		floatingAudio_01.Play(floatingAudioClip[13], 0.5f);
		yield return Yield.WaitSeconds(3.3f);
		baalParticleTrail.SetActive(value: true);
		baalParticleTrailAnim.SetTrigger("FinchRelease");
		yield return Yield.WaitSeconds(8f);
		float blendMixValue = 0.1f;
		baalFloat_Stereo.transform.position = baalFloatingAudioPoint[3].position;
		baalFloat_Stereo.Play(voBaal[6], 0.6f);
		HUD.Instance.PlaySubtitles(voBaal[6].name, hasPriority: true);
		while (blendMixValue < 1f)
		{
			blendMixValue += 0.05f;
			blackVeinHandMaterial.SetFloat("_BlendMix", blendMixValue);
			yield return Yield.EndOfFrame;
		}
		mainArenaNavCarveTrigger.SetActive(value: true);
		inNavCarveArea = false;
		while (!inNavCarveArea)
		{
			yield return Yield.WaitSeconds(0.5f);
		}
		playerStereoAudio_01.FadeIn(musicHighLoop, 1f, 9f, loop: true);
		mainArenaNavCarve.SetActive(value: true);
		finch.SetActive(value: false);
		baalParticleTrailAnim.enabled = false;
		baalParticleSystem.Stop();
		deadBodyRiseupTriggerArea.SetActive(value: true);
		deadBodyRiseupSightTrigger.SetActive(value: true);
		while (!lookingAtDeadbodyRiseup)
		{
			yield return Yield.WaitSeconds(0.5f);
		}
		mainDeadBody.PlaySitUpAnimation();
		yield return Yield.EndOfFrame;
		floatingAudio_02.transform.position = floatingAudioPoint[10].position;
		floatingAudio_02.Play(bodySitupClip, 0.4f);
		yield return Yield.WaitSeconds(5f);
		deadBodyRiseupTriggerArea.SetActive(value: true);
		deadBodyRiseupSightTrigger.SetActive(value: true);
		lookingAtDeadbodyRiseup = false;
		while (!lookingAtDeadbodyRiseup)
		{
			yield return Yield.WaitSeconds(0.5f);
		}
		mainDeadBody.PlayRiseUpAnimation();
		player.playerLight.shouldLightBeOn = false;
		if (oilLighter.isOn)
		{
			oilLighter.TurnOffLight();
		}
		else
		{
			playerLightFlicker.StartBurst(2f, finishOn: false);
		}
		oilLighter.canTurnOnLight = false;
		for (int i = 0; i < allChickens.Length; i++)
		{
			allChickens[i].SetActive(value: false);
		}
		yield return Yield.WaitSeconds(4f);
		player.playerLight.shouldLightBeOn = true;
		playerLightFlicker.SetHighIntensity(0.9f);
		if (oilLighter.isOn)
		{
			oilLighter.TurnOnLight();
		}
		else
		{
			player.playerLight.PlayClick();
			playerLightFlicker.SwitchLight(switchOn: true);
		}
		oilLighter.canTurnOnLight = true;
		playerStereoAudio_01.StopLoop();
		playerStereoAudio_02.StopLoop();
		GameController.instance.audioController.PlayBadSting(STINGS_BAD.BAD_STING_05);
		carouselAnimator.SetTrigger("Set_Up");
		yield return Yield.EndOfFrame;
		mainDeadBody.GetComponent<BoxCollider>().enabled = true;
		for (int j = 0; j < deadBodies.Length; j++)
		{
			deadBodies[j].PlayFloatAnimation();
		}
		yield return Yield.WaitSeconds(1f);
		baalFloat_Stereo.transform.position = baalFloatingAudioPoint[4].position;
		baalFloat_Stereo.Play(voBaal[7], 0.6f);
		HUD.Instance.PlaySubtitles(voBaal[7].name, hasPriority: true);
		yield return Yield.WaitSeconds(1f);
	}

	private IEnumerator ThirdFloorDeadBodysRise()
	{
		bodiesExorcisedCount = 0;
		saltSprayer.hitTarget = false;
		saltSprayer.currentTarget = mainDeadBody.gameObject;
		saltSprayer.wrongTargets.Clear();
		saltSprayer.wrongTargets.Add(deadBodies[0].gameObject);
		saltSprayer.wrongTargets.Add(deadBodies[1].gameObject);
		saltSprayer.wrongTargets.Add(deadBodies[2].gameObject);
		saltSprayer.wrongTargets.Add(deadBodies[3].gameObject);
		saltSprayer.wrongTargets.Add(deadBodies[4].gameObject);
		StartCoroutine(RotateFloatingBodies());
		playerStereoAudio_01.FadeIn(musicHighLoop, 0.8f, 4f, loop: true);
		fanFoley.FadeVolumeOut(4f, 0.2f);
		while (bodiesExorcisedCount < 2)
		{
			yield return null;
		}
		baalOutburstDeadBody.PlayBaalOutburst();
		yield return Yield.WaitSeconds(2f);
		playerStereoAudio_01.StopLoop();
		fanFoley.StopLoop();
		for (int i = 0; i < thirdFloorFoley.Length; i++)
		{
			thirdFloorFoley[i].Stop();
		}
		GameController.instance.audioController.PlayBadSting(STINGS_BAD.BAD_STING_06);
		yield return Yield.WaitSeconds(1f);
		player.screenFX.Fade(UnityEngine.Color.black, 0.25f);
		yield return Yield.WaitSeconds(0.25f);
		playerStereoAudio_01.FadeIn(musicBaalHeartbeat, 1f, 3f, loop: true);
		playerStereoAudio_02.FadeIn(playerSineClip, 0.2f, 2f, loop: true);
		StartCoroutine(AudioSyncTimer(running: true));
		StopCoroutine(HandleFloatingBodyExorcism());
		StopCoroutine(RotateFloatingBodies());
		StopCoroutine(ThirdFloorExorciseFloatingBodies());
		chenHazmatSuit.SetActive(value: false);
		yield return Yield.EndOfFrame;
		chenHazmatStanding.SetActive(value: true);
		carouselAnimator.SetTrigger("Idle");
		yield return Yield.EndOfFrame;
		mainDeadBody.gameObject.SetActive(value: false);
		for (int j = 0; j < deadBodies.Length; j++)
		{
			deadBodies[j].gameObject.SetActive(value: false);
		}
		yield return Yield.WaitSeconds(4f);
		player.screenFX.Fade(UnityEngine.Color.clear, 0f);
		player.screenFX.BlurScreen(enabled: true);
		if (oilLighter.isOn)
		{
			oilLighter.TurnOffLight();
		}
		oilLighter.canTurnOnLight = false;
		player.playerLight.shouldLightBeOn = false;
		playerLightFlicker.SwitchLight(switchOn: true);
		playerLightFlicker.Fade(on: false, 3f);
		yield return Yield.WaitSeconds(4f);
		player.screenFX.SetBlur(1.6f);
		runFlickerRoutine = true;
		StartCoroutine(LightFadeRoutine());
	}

	private IEnumerator LightFadeRoutine()
	{
		while (runFlickerRoutine)
		{
			playerLightFlicker.lowIntensity = 0.25f;
			playerLightFlicker.SwitchLight(switchOn: true);
			playerLightFlicker.Fade(on: false, 3f);
			yield return Yield.WaitSeconds(4f);
			if (!runFlickerRoutine)
			{
				break;
			}
		}
	}

	private IEnumerator RotateFloatingBodies()
	{
		carouselAnimator.SetTrigger("Start_Carousel");
		yield return Yield.EndOfFrame;
		playerStereoAudio_02.Play(musicCarouselBuild);
		yield return Yield.WaitSeconds(12f);
		if (bodiesExorcisedCount == 0)
		{
			baalFloat_Spatial.transform.position = saltSprayer.currentTarget.transform.position + new Vector3(0f, 1f, 0f);
			baalFloat_Spatial.Play(voBaal[5]);
		}
		saltSprayer.currentTarget.GetComponentInParent<Corpse>().PlayParticles();
		yield return Yield.EndOfFrame;
		StartCoroutine(ThirdFloorExorciseFloatingBodies());
	}

	private IEnumerator ThirdFloorExorciseFloatingBodies()
	{
		while (!saltSprayer.hitTarget && !saltSprayer.hitWrongTarget)
		{
			yield return Yield.WaitSeconds(0.3f);
		}
		StartCoroutine(HandleFloatingBodyExorcism());
	}

	public IEnumerator HandleFloatingBodyExorcism()
	{
		if (saltSprayer.hitWrongTarget)
		{
			Corpse corpse = saltSprayer.wrongTargetHit.GetComponentInParent<Corpse>();
			corpse.PlayAttackAnimation();
			yield return Yield.EndOfFrame;
			if (!corpse.hasHitWithSaltSpray)
			{
				floatingAudio_02.transform.position = corpse.transform.position + new Vector3(0f, 1f, 0f);
				floatingAudio_02.Play(corpseScoffClips[UnityEngine.Random.Range(0, corpseScoffClips.Length)]);
			}
			yield return Yield.WaitSeconds(1.4f);
			int num = UnityEngine.Random.Range(8, 12);
			baalFloat_Spatial.transform.position = saltSprayer.currentTarget.transform.position + new Vector3(0f, 1f, 0f);
			baalFloat_Spatial.Play(voBaal[num]);
			HUD.Instance.PlaySubtitles(voBaal[num].name, hasPriority: true);
			yield return Yield.WaitSeconds(3f);
			saltSprayer.hitWrongTarget = false;
			saltSprayer.hitTarget = false;
			hasBeenAttacked = true;
			StartCoroutine(ThirdFloorExorciseFloatingBodies());
		}
		else if (saltSprayer.hitTarget)
		{
			bodiesExorcisedCount++;
			Corpse corpse = saltSprayer.currentTarget.GetComponentInParent<Corpse>();
			corpse.hasHitWithSaltSpray = true;
			saltSprayer.currentTarget.GetComponentInParent<Corpse>().StopParticles();
			floatingAudio_02.transform.position = corpse.gameObject.transform.position + new Vector3(0f, 1f, 0f);
			if (bodiesExorcisedCount == 1)
			{
				floatingAudio_02.Play(corpseReactGoodClip);
				releaseParticles.Play();
				yield return Yield.EndOfFrame;
			}
			else
			{
				floatingAudio_02.Play(corpseReactBadClip);
			}
			if (bodiesExorcisedCount < 2)
			{
				corpse.PlayExorcismAnimation();
				yield return Yield.EndOfFrame;
				corpse.PlayEjectionAnimation();
				yield return Yield.WaitSeconds(7.55f);
				saltSprayer.currentTarget = deadBodies[4].gameObject;
				saltSprayer.wrongTargets.Clear();
				saltSprayer.wrongTargets.Add(deadBodies[0].gameObject);
				saltSprayer.wrongTargets.Add(deadBodies[1].gameObject);
				saltSprayer.wrongTargets.Add(deadBodies[2].gameObject);
				saltSprayer.wrongTargets.Add(deadBodies[3].gameObject);
				saltSprayer.wrongTargets.Add(mainDeadBody.gameObject);
				yield return Yield.WaitSeconds(0.5f);
				saltSprayer.hitWrongTarget = false;
				saltSprayer.hitTarget = false;
				StartCoroutine(RotateFloatingBodies());
			}
		}
	}

	private IEnumerator AudioSyncTimer(bool running)
	{
		audioSyncLoopTime = 0f;
		while (running)
		{
			if (audioSyncLoopTime > 4f)
			{
				audioSyncLoopTime = 0f;
			}
			audioSyncLoopTime += Time.deltaTime;
			yield return null;
		}
	}

	private IEnumerator ThirdFloorFinalExorcismPartOne()
	{
		float exorcismDuration = 20f;
		float shakeCameraThresholdTime = 5f;
		tuneCross.StartTuning(baalTarget, baalTargetLocations, exorcismDuration, float.MaxValue, isSlowMo: false, 0.6f);
		yield return Yield.EndOfFrame;
		baal.SetThrowAudio(floatingAudio_02, baalFloatingAudioPoint[7]);
		baal.StartAttacking();
		tuneCross.SetPointLightEnabled(enabled: false);
		tuneCross.SetSpotLightEnabled(enabled: false);
		tuneCross.TheLight(isEnabled: true);
		player.screenFX.ShakeCamera();
		tuneCross.OverrideTuneSuccess = true;
		while (!tuneCross.tuneSuccess)
		{
			if (tuneCross.HoldTime > shakeCameraThresholdTime)
			{
				player.screenFX.cameraShakeAmount = 0.04f * (tuneCross.HoldTime - shakeCameraThresholdTime) / (exorcismDuration - shakeCameraThresholdTime);
			}
			else
			{
				player.screenFX.cameraShakeAmount = 0f;
			}
			yield return Yield.EndOfFrame;
		}
		baal.StopAttacking();
		baal.canHitPlayer = false;
		while (baal.BaalState == Baal.State.ATTACKING)
		{
			yield return Yield.EndOfFrame;
		}
		while (tuneCross.PauseCrossTuning)
		{
			yield return Yield.EndOfFrame;
		}
		yield return Yield.WaitSeconds(0.5f);
		baalOnHisKnees = true;
		baal.PlayWeakAnimation();
		yield return Yield.EndOfFrame;
		floatingAudio_02.transform.position = baalFloatingAudioPoint[6].position;
		floatingAudio_02.Play(voBaal[19]);
		baal.RunSpeechParticles();
		yield return Yield.EndOfFrame;
		HUD.Instance.PlaySubtitles(voBaal[19].name, hasPriority: true);
		player.playerLight.shouldLightBeOn = false;
		if (oilLighter.isOn)
		{
			oilLighter.TurnOffLight();
		}
		else
		{
			playerLightFlicker.StartBurst(4f, finishOn: false);
		}
		oilLighter.canTurnOnLight = false;
		yield return Yield.WaitSeconds(4f);
		tuneCross.SetSpotLightEnabled(enabled: true);
		tuneCross.RunTuneSuccess();
		tuneCross.OverrideTuneSuccess = false;
		tuneCross.OverrideHitSuccess = true;
		tuneCross.StartLightTarget(baal.gameObject);
		playerStereoAudio_01.FadeOut(1f);
		playerStereoAudio_02.FadeIn(musicLoopHigh, 1f, 6f, loop: true);
		yield return Yield.WaitSeconds(voBaal[19].length - 4f);
		baal.gameObject.SetLayer(11);
		bool playingBaalPainLoop = false;
		tuneCross.OverrideHitSuccess = false;
		while (!tuneCross.hitSuccess)
		{
			yield return Yield.EndOfFrame;
			if (!playingBaalPainLoop)
			{
				baalFloat_Spatial.FadeIn(voBaal[22], 1f, 1f, loop: true);
				playingBaalPainLoop = true;
			}
		}
		tuneCross.ShootBeam(withAudio: true, disableLight: false, keepLockedToHand: true, instant: true);
		playerStereoAudio_02.FadeOut(1f);
		player.screenFX.StopCameraShake();
		baal.PlayDeathAnimation();
		baalFloat_Spatial.transform.position = baalFloatingAudioPoint[6].position;
		baalFloat_Spatial.Play(voBaal[20]);
		baal.RunSpeechParticles();
		tuneCross.FadeLightTarget(2f);
		yield return Yield.WaitSeconds(2f);
		tuneCross.SetSpotLightEnabled(enabled: false);
		SlowTime(endSlowMoTime);
		GameController.instance.audioController.persistentMusicPlayer.m_AudioSource.pitch = 1f;
		baalFinaleFlames.Play();
		GameController.instance.audioController.persistentMusicPlayer.Play(musicOutToPrecinct);
		yield return Yield.WaitSeconds(0.5f);
		baal.baalHealth = Baal.Health.DEAD;
	}

	private IEnumerator BaalGrowlSpeechRoutine(float delay, bool fadeIn = false, float fadeInTime = 0f)
	{
		if (delay > 0f)
		{
			yield return Yield.WaitSeconds(delay);
		}
		if (!baalOnHisKnees)
		{
			baalFloat_Spatial.transform.position = baalFloatingAudioPoint[5].position;
			if (fadeIn)
			{
				baalFloat_Spatial.FadeIn(voBaal[21], 1f, fadeInTime, loop: true);
			}
			else
			{
				baalFloat_Spatial.PlayLoop(voBaal[21]);
			}
		}
	}

	private IEnumerator PlayerHitByBaalRoutine()
	{
		while (baal.baalHealth == Baal.Health.FULLHEALTH)
		{
			if (baal.playerHit)
			{
				baal.StopAttacking();
				baal.playerHit = false;
				notHitByBaal = false;
				baalFloat_Spatial.transform.position = baalFloatingAudioPoint[5].position;
				baalFloat_Spatial.Play(voBaal[baalVOTauntIndex]);
				yield return Yield.EndOfFrame;
				StartCoroutine(BaalGrowlSpeechRoutine(voBaal[baalVOTauntIndex].length));
				baal.RunSpeechParticles();
				yield return Yield.EndOfFrame;
				HUD.Instance.PlaySubtitles(voBaal[baalVOTauntIndex].name, hasPriority: true);
				baalVOTauntIndex++;
				if (baalVOTauntIndex == 18)
				{
					baalVOTauntIndex = 15;
				}
				tuneCross.HoldTime -= 5f;
				tuneCross.PauseCrossTuning = true;
				player.screenFX.Fade(UnityEngine.Color.black, 0f);
				playerLightFlicker.StartBurst(3f, finishOn: true);
				player.screenFX.BlurScreen(enabled: true);
				yield return Yield.EndOfFrame;
				player.screenFX.Fade(UnityEngine.Color.clear, 1f);
				yield return Yield.WaitSeconds(1f);
				player.screenFX.BlurScreen(enabled: false, fade: true, 3f);
				yield return Yield.WaitSeconds(3f);
				if (baal.canHitPlayer)
				{
					baal.StartAttacking();
				}
				yield return Yield.WaitSeconds(3f);
				tuneCross.PauseCrossTuning = false;
			}
			if (baal.playerDodged)
			{
				baal.playerDodged = false;
				baal.PlayGrowlIdleAnimation();
				yield return Yield.WaitSeconds(0.75f);
				baalFloat_Spatial.transform.position = baalFloatingAudioPoint[5].position;
				baalFloat_Spatial.Play(voBaalPlayerDodged[voBaalDodgedIndex]);
				StartCoroutine(BaalGrowlSpeechRoutine(voBaalPlayerDodged[voBaalDodgedIndex].length));
				voBaalDodgedIndex++;
				if (voBaalDodgedIndex == voBaalPlayerDodged.Length)
				{
					voBaalDodgedIndex = 0;
				}
			}
			yield return Yield.EndOfFrame;
		}
	}

	private IEnumerator ThirdFloorFinalExorcism()
	{
		while (!crossSelected)
		{
			yield return null;
		}
		puddleMaterial.SetFloat("_Dissolve", 0f);
		yield return Yield.EndOfFrame;
		chenHazmatSightTrigger.SetActive(value: true);
		lookedAtChenHazmatTrigger = false;
		while (!lookedAtChenHazmatTrigger)
		{
			yield return null;
		}
		playerStereoAudio_02.FadeOut(3f);
		interactableCross.LockToHand(isLocked: true);
		player.playerLight.shouldLightBeOn = false;
		if (oilLighter.isOn)
		{
			oilLighter.TurnOffLight();
		}
		oilLighter.canTurnOnLight = false;
		runFlickerRoutine = false;
		StopCoroutine(LightFadeRoutine());
		yield return Yield.EndOfFrame;
		playerLightFlicker.lowIntensity = 0f;
		playerLightFlicker.StartBurst(1f, finishOn: false);
		yield return Yield.EndOfFrame;
		baalFloat_Spatial.transform.position = baalFloatingAudioPoint[5].position;
		baalFloat_Spatial.Play(voBaal[13]);
		baal.RunSpeechParticles();
		HUD.Instance.PlaySubtitles(voBaal[13].name, hasPriority: true);
		player.screenFX.BlurScreen(enabled: false);
		yield return Yield.EndOfFrame;
		chenHazmatStanding.GetComponent<Animator>().SetTrigger("Fit");
		yield return Yield.WaitSeconds(1.5f);
		float time = musicBaalHeartbeat.length - audioSyncLoopTime;
		StopCoroutine(AudioSyncTimer(running: false));
		yield return Yield.WaitSeconds(time);
		playerStereoAudio_01.PlayLoop(musicBaalFightLoop);
		playerLightFlicker.SwitchLight(switchOn: true);
		playerLightFlicker.Fade(on: false, 3f);
		yield return Yield.WaitSeconds(3.5f);
		chenHazmatStanding.SetActive(value: false);
		yield return Yield.EndOfFrame;
		baalTransitionPoseChen.SetActive(value: true);
		yield return Yield.WaitSeconds(0.5f);
		playerLightFlicker.SwitchLight(switchOn: true);
		playerLightFlicker.Fade(on: false, 3f);
		yield return Yield.WaitSeconds(3.5f);
		baalTransitionPoseChen.SetActive(value: false);
		yield return Yield.EndOfFrame;
		baalTransitionPose.SetActive(value: true);
		yield return Yield.WaitSeconds(0.5f);
		StartCoroutine(BaalGrowlSpeechRoutine(0f, fadeIn: true, 4f));
		playerLightFlicker.SwitchLight(switchOn: true);
		playerLightFlicker.Fade(on: false, 3f);
		yield return Yield.WaitSeconds(3.5f);
		baalTransitionPose.SetActive(value: false);
		yield return Yield.EndOfFrame;
		baal.gameObject.SetActive(value: true);
		yield return Yield.WaitSeconds(0.5f);
		playerLightFlicker.SwitchLight(switchOn: true);
		playerLightFlicker.Fade(on: false, 3f);
		yield return Yield.WaitSeconds(4f);
		playerLightFlicker.SwitchLight(switchOn: true);
		yield return Yield.EndOfFrame;
		baalFloat_Spatial.transform.position = baalFloatingAudioPoint[6].position;
		baalFloat_Spatial.Play(voBaal[14]);
		baal.RunSpeechParticles();
		HUD.Instance.PlaySubtitles(voBaal[14].name, hasPriority: true);
		StartCoroutine(BaalGrowlSpeechRoutine(voBaal[14].length));
		yield return Yield.WaitSeconds(voBaal[14].length);
		StartCoroutine(ThirdFloorFinalExorcismPartOne());
		yield return StartCoroutine(PlayerHitByBaalRoutine());
		baal.StopDeathParticles();
		yield return Yield.EndOfFrame;
		LeanTween.moveLocalY(vineSetCeiling, 6f, 3f * endSlowMoTime);
		yield return Yield.EndOfFrame;
		LeanTween.moveLocalY(vineSetFloor, -3f, 3f * endSlowMoTime);
		yield return Yield.EndOfFrame;
		bool bringOnTheRoaches = true;
		morgueDrainAnimator.SetTrigger("Idle");
		yield return Yield.EndOfFrame;
		baalFlameLight.Fade(on: true, 1f * endSlowMoTime);
		float dissolveBlendDuration = 4f;
		for (float t = 0f; t < dissolveBlendDuration; t += Time.deltaTime)
		{
			float num = 1f / dissolveBlendDuration * t;
			float num2 = 1f - num;
			blackVeinHandMaterial.SetFloat("_BlendMix", num2);
			morgueBlendMaterial[0].SetFloat("_BlendMix", num2);
			morgueBlendMaterial[1].SetFloat("_BlendMix", num2);
			morgueBlendMaterial[2].SetFloat("_BlendMix", num2);
			puddleMaterial.SetFloat("_Dissolve", num);
			if (bringOnTheRoaches && num2 <= 0.8f)
			{
				baalRoaches.SetActive(value: true);
				baalFlameLight.Fade(on: false, 3f * endSlowMoTime);
				bringOnTheRoaches = false;
			}
			yield return Yield.EndOfFrame;
		}
		interactableCross.LockToHand(isLocked: false);
		interactableCross.respawnTimer = 0.5f * endSlowMoTime;
		if (player.LeftHand.CurrentlyInteracting == interactableCross)
		{
			player.LeftHand.ForceDropItem();
		}
		else if (player.RightHand.CurrentlyInteracting == interactableCross)
		{
			player.RightHand.ForceDropItem();
		}
		while (!interactableCross.inKit)
		{
			yield return Yield.WaitSeconds(0.1f);
		}
		interactableCross.respawnTimer = 5f;
		yield return Yield.WaitSeconds(6f * endSlowMoTime);
		baal.gameObject.SetActive(value: false);
	}

	private IEnumerator FadeOutScene()
	{
		GameController.instance.audioController.SnapMute(3f * endSlowMoTime);
		player.screenFX.Fade(UnityEngine.Color.black, 3f * endSlowMoTime);
		yield return Yield.WaitSeconds(4f * endSlowMoTime);
		player.screenFX.SetColourGradingAndFadeIn(ScreenFX.ColourGradingProfileID.DEFAULT, 0.5f * endSlowMoTime);
		StartCoroutine(ExitToPrecinctRoutine(levelComplete: true, notHitByBaal));
	}

	private void ResetProgress()
	{
		if (player.transform.parent == elevator.gameObject.transform)
		{
			player.transform.parent = GameController.instance.gameObject.transform;
			player.transform.parent = null;
		}
		player.playerLight.ResetRange();
		player.playerLight.ResetAngle();
		player.playerLight.ResetColour();
		playerHeadParticle.transform.SetParent(secondFloor_0.transform);
	}

	private IEnumerator FoundAretfact()
	{
		GameController.instance.audioController.PlayGoodSting(STINGS_GOOD.GOOD_CHOIR_STING_03, 0.75f);
		player.HandMenu.bookScript.updateMaxPage(14);
		player.HandMenu.OpenStraightToBookForArtefact(ArtefactType.CELTIC_CROSS, NotebookPages.Q14);
		player.HandMenu.UpgradeCross();
		upgradeAnimator.SetTrigger("DropClick");
		yield return new WaitForSeconds(2f);
		player.watch.WatchHintWithSFX(5f, SFXAlertType.ALERT);
		StartCoroutine(RemoveArtifactFromUserHand());
	}

	private IEnumerator RemoveArtifactFromUserHand()
	{
		float counter = 0f;
		bool inHand = false;
		while (!player.HandMenu.bookScript.isActiveItem)
		{
			if (player.LeftHand.IsInteracting && player.LeftHand.CurrentlyInteracting.gameObject == artefact)
			{
				inHand = true;
			}
			if (player.RightHand.IsInteracting && player.RightHand.CurrentlyInteracting.gameObject == artefact)
			{
				inHand = true;
			}
			if (inHand)
			{
				counter = 0f;
				inHand = false;
			}
			else
			{
				counter += 1f;
			}
			if (counter > 2f)
			{
				break;
			}
			yield return Yield.WaitSeconds(1f);
		}
		if (player.LeftHand.IsInteracting)
		{
			if (player.LeftHand.CurrentlyInteracting != null && player.LeftHand.CurrentlyInteracting.gameObject == artefact)
			{
				LeanTween.alpha(artefact, 0f, 1f);
				player.LeftHand.ForceDropItem();
				yield return Yield.EndOfFrame;
				artefact.SetActive(value: false);
				player.LeftHand.CurrentlyInteracting = null;
				yield return Yield.EndOfFrame;
				player.LeftHand.CurrentlyHoveringOver.Remove(artefact.GetComponent<NVRInteractableItem>());
			}
		}
		else
		{
			LeanTween.alpha(artefact, 0f, 0.5f);
			yield return Yield.WaitSeconds(0.5f);
			artefact.SetActive(value: false);
		}
		if (player.RightHand.IsInteracting)
		{
			if (player.RightHand.CurrentlyInteracting != null && player.RightHand.CurrentlyInteracting.gameObject == artefact)
			{
				LeanTween.alpha(artefact, 0f, 1f);
				player.RightHand.ForceDropItem();
				yield return Yield.EndOfFrame;
				artefact.SetActive(value: false);
				player.RightHand.CurrentlyInteracting = null;
				yield return Yield.EndOfFrame;
				player.RightHand.CurrentlyHoveringOver.Remove(artefact.GetComponent<NVRInteractableItem>());
				player.RightHand.CurrentlyHoveringOver.Remove(artefact.GetComponent<NVRInteractableItem>());
			}
		}
		else
		{
			LeanTween.alpha(artefact, 0f, 0.5f);
			yield return Yield.WaitSeconds(0.5f);
			artefact.SetActive(value: false);
		}
		if (!player.LeftHand.IsInteracting)
		{
			player.LeftHand.SetAnimation("IdleBool");
		}
		if (!player.RightHand.IsInteracting)
		{
			player.RightHand.SetAnimation("IdleBool");
		}
	}

	private void RestartLevel()
	{
		StartCoroutine(RestartLevelRoutine());
	}

	private IEnumerator RestartLevelRoutine()
	{
		player.screenFX.Fade(UnityEngine.Color.black, 3f);
		yield return Yield.WaitSeconds(3f);
		if (player.transform.parent == elevator.gameObject.transform)
		{
			player.transform.parent = GameController.instance.gameObject.transform;
			player.transform.parent = null;
		}
		playerHeadParticle.transform.SetParent(secondFloor_0.transform);
		GameController.instance.audioController.persistentMusicPlayer.StopLoop();
		SlowTime(1f);
		player.playerLight.ResetRange();
		player.playerLight.ResetAngle();
		player.playerLight.ResetColour();
		player.screenFX.BlurScreen(enabled: false);
		player.screenFX.SetColourGradingAndFadeIn(ScreenFX.ColourGradingProfileID.MORGUE, 0.5f);
		playerLightFlicker.light.range = 4.4f;
		player.LeftHand.SwapOutHandMaterial(standardHandMaterial);
		player.RightHand.SwapOutHandMaterial(standardHandMaterial);
		player.MoveToSafeZone();
	}

	private void ExitToPrecinct()
	{
		StartCoroutine(ExitToPrecinctRoutine(levelComplete: false, hitByBaal: false));
	}

	public IEnumerator ExitToPrecinctRoutine(bool levelComplete, bool hitByBaal)
	{
		if (Time.timeScale != 1f)
		{
			SlowTime(1f);
		}
		if (!levelComplete)
		{
			GameController.instance.audioController.SnapMute(1f);
			player.screenFX.Fade(UnityEngine.Color.black, 1f);
			yield return new WaitForSeconds(1f);
			player.screenFX.SetColourGradingAndFadeIn(ScreenFX.ColourGradingProfileID.DEFAULT, 0.5f);
			yield return Yield.WaitSeconds(0.5f);
			playerLightFlicker.light.range = 4.4f;
			if (player.transform.parent == elevator)
			{
				UnityEngine.Debug.Log("Player in elevator when quit");
			}
			GameController.instance.audioController.persistentMusicPlayer.StopLoop();
		}
		if (player.transform.parent == elevator.gameObject.transform)
		{
			player.transform.parent = GameController.instance.gameObject.transform;
			player.transform.parent = null;
		}
		if (digitalCamera.viewedAllImages && dictaphone.playedPart1 && dictaphone.playedPart2 && tabletComputer.labNote1Viewed && tabletComputer.labNote2Viewed && tabletComputer.labNote3Viewed && playedWithTheDisease)
		{
			researachedTheDisease = true;
		}
		player.playerLight.ResetRange();
		player.playerLight.ResetAngle();
		player.playerLight.ResetColour();
		PicoLight.enabled = false;
		float[] array = new float[32];
		array[14] = 8f;
		playerCamera.layerCullDistances = array;
		player.playerLight.ResetRange();
		GameController.instance.levelCompletionManager.SetLevelCompletionForMorgue(hitByBaal, researachedTheDisease, SaveManager.instance.HasFoundArtifact(ChapterID.MORGUE), levelComplete);
		yield return new WaitForSeconds(1f);
		player.screenFX.BlurScreen(enabled: false);
		playerHeadParticle.transform.SetParent(secondFloor_0.transform);
		player.LeftHand.SwapOutHandMaterial(standardHandMaterial);
		player.RightHand.SwapOutHandMaterial(standardHandMaterial);
		DynamicGI.UpdateEnvironment();
		RenderSettings.skybox = null;
		player.HandMenu.CloseMenu(hideHandsAfter: true);
		yield return new WaitForSeconds(1f);
		GameController.instance.boundDetection.SwitchOffOOB();
		GameController.instance.GoToSpecificScene(SCENES.PRECINCT, levelComplete);
	}

	private void SlowTime(float newTime, float fadeTime = 0f)
	{
		for (int i = 0; i < allAudio.Length; i++)
		{
			allAudio[i].pitch = newTime;
		}
		Time.timeScale = newTime;
	}

	public override GameObject GetCurrentLevelRoot()
	{
		if (firstFloor_0.playerInRoom)
		{
			return firstFloor_0.associatedParentGameObject;
		}
		if (firstFloor_1.playerInRoom)
		{
			return firstFloor_1.associatedParentGameObject;
		}
		if (secondFloor_0.playerInRoom || inSideRoom)
		{
			return secondFloor_0.associatedParentGameObject;
		}
		if (thirdFloor_0.playerInRoom)
		{
			return thirdFloor_0.associatedParentGameObject;
		}
		if (thirdFloor_1.playerInRoom)
		{
			return thirdFloor_1.associatedParentGameObject;
		}
		return null;
	}

	private void OnDestroy()
	{
		player.LeftHand.SwapOutHandMaterial(standardHandMaterial);
		player.RightHand.SwapOutHandMaterial(standardHandMaterial);
	}

	public override void BeginInteraction(NVRInteractable interactable)
	{
		if (interactable.gameObject == ladderGrabPoint.gameObject)
		{
			grabbedTheLadder = true;
		}
		else if (interactable.gameObject == fuseboxLeaver.gameObject)
		{
			fuseboxLeaver.enabled = false;
			fuseboxLeaver.CanAttach = false;
			StartCoroutine(PullFuseboxLever());
		}
		else if (interactable.gameObject == cross)
		{
			crossSelected = true;
			interactableCross.inEnvironment = false;
		}
		else if (interactable.gameObject == artefact && !foundAretfact)
		{
			foundAretfact = true;
			StartCoroutine(FoundAretfact());
			SaveManager.instance.MarkArtifactFound(ChapterID.MORGUE);
		}
		else if (ladderRelease.IsSmashableObject(interactable.gameObject) && !touchedHammer)
		{
			GameController.instance.audioController.PlayGoodSting(STINGS_GOOD.GOOD_SOFT_STING_02, 0.35f);
			touchedHammer = true;
		}
		else if (interactable.gameObject == notebook01.gameObject && !touchedNotebook01)
		{
			touchedNotebook01 = true;
			GameController.instance.audioController.PlayGoodSting(STINGS_GOOD.GOOD_STING_01, 0.15f);
		}
		else if ((interactable.gameObject == tapHot.gameObject || interactable.gameObject == tapCold.gameObject) && !ranSinkRoaches)
		{
			ranSinkRoaches = true;
			roaches.RunRoaches();
		}
		else if (interactable.gameObject == bellsCoverNote && !foundBellsCoverNote)
		{
			foundBellsCoverNote = true;
			GameController.instance.achievementManager.UnlockAchievement(AchievementID.OLD_FRIEND);
			GameController.instance.audioController.PlayGoodSting(STINGS_GOOD.GOOD_STING_02);
		}
		if (playedWithTheDisease)
		{
			return;
		}
		for (int i = 0; i < diseasedObject.Length; i++)
		{
			if (interactable.gameObject == diseasedObject[i])
			{
				playedWithTheDisease = true;
				break;
			}
		}
	}

	public override void EndInteraction(NVRInteractable interactable)
	{
		base.EndInteraction(interactable);
		if (interactable == fuseboxDoor)
		{
			fuseboxOpen = true;
		}
		else if (interactable.gameObject == cross)
		{
			crossSelected = false;
			interactableCross.inEnvironment = false;
		}
	}

	public override void OnTriggerEnter(Collider other)
	{
		if (other.gameObject == beacon.gameObject && !beacon.isPlaying)
		{
			beacon.PlayMessage();
		}
		else if (other.gameObject == mainArenaTrigger && !inMainArena)
		{
			inMainArena = true;
			mainArenaTrigger.SetActive(value: false);
		}
		else if (other.gameObject == mainArenaNavCarveTrigger && !inNavCarveArea)
		{
			inNavCarveArea = true;
			mainArenaNavCarveTrigger.SetActive(value: false);
		}
		else if (other.gameObject == deadBodyRiseupTriggerArea && !inDeadbodyRiseupArea)
		{
			inDeadbodyRiseupArea = true;
			deadBodyRiseupTriggerArea.SetActive(value: false);
		}
		else if (other.gameObject == sideRoomTrigger)
		{
			inSideRoom = true;
		}
		else if (other.gameObject == chickenTriggerMorgue)
		{
			inChickenTriggerAreaMorgue = true;
			if (inChickenTriggerAreaMorgue && inChickenSightTriggerAreaMorgue)
			{
				chickenTriggerMorgue.SetActive(value: false);
				chickenSightTriggerMorgue.SetActive(value: false);
				chickenTriggerMorgueSkippedTrigger_1.SetActive(value: false);
				chickenTriggerMorgueSkippedTrigger_2.SetActive(value: false);
				inChickenTriggerAreaMorgue = false;
				inChickenSightTriggerAreaMorgue = false;
				StartCoroutine(ChickenFlyOff(disableMesh: false));
			}
		}
		else if (other.gameObject == chickenTriggerMorgueSkippedTrigger_1 || other.gameObject == chickenTriggerMorgueSkippedTrigger_2)
		{
			chickenTriggerMorgue.SetActive(value: false);
			chickenSightTriggerMorgue.SetActive(value: false);
			chickenTriggerMorgueSkippedTrigger_1.SetActive(value: false);
			chickenTriggerMorgueSkippedTrigger_2.SetActive(value: false);
			inChickenTriggerAreaMorgue = false;
			inChickenSightTriggerAreaMorgue = false;
			StartCoroutine(ChickenFlyOff(disableMesh: true));
		}
		else if (other.gameObject == corridorTrigger && !enteredFinalCorridor)
		{
			enteredFinalCorridor = true;
			corridorTrigger.SetActive(value: false);
		}
		else if (other.gameObject == emergencyExitTrigger && !triggeredEmergencyExit)
		{
			triggeredEmergencyExit = true;
			emergencyExitTrigger.SetActive(value: false);
		}
		else if (other.gameObject == firstFloorCockroachTrigger)
		{
			firstFloorCockroachTrigger.SetActive(value: false);
			firstFloorCockroaches.SetActive(value: true);
		}
		else if (other.gameObject == chickenTriggerArea)
		{
			StartCoroutine(ChickenScareAttack());
		}
		else if (other.gameObject == showerTrigger)
		{
			inShowerTriggerArea = true;
			if (inShowerTriggerArea && inShowerSightTriggerArea)
			{
				showerTrigger.SetActive(value: false);
				showerSightTrigger.SetActive(value: false);
				showerVinesAnimator.SetTrigger("Disappear");
				floatingAudio_02.transform.position = floatingAudioPoint[15].position;
				floatingAudio_02.Play(floatingAudioClip[15], 0.3f);
				GameController.instance.audioController.PlayBadSting(STINGS_BAD.BAD_SOFT_STING_01, 0.6f);
			}
		}
		else if (other.gameObject == hopkinsTrigger)
		{
			inHopkinsTriggerArea = true;
			if (inHopkinsTriggerArea && inHopkinsSightTriggerArea)
			{
				hopkinsTrigger.SetActive(value: false);
				hopkinsSightTrigger.SetActive(value: false);
				hopkinsAnimator.SetTrigger("Scare");
				GameController.instance.audioController.PlayBadSting(STINGS_BAD.BAD_SOFT_STING_02);
			}
		}
		else if (other.gameObject == elevator.floorButtons.gameObject)
		{
			if (elevator.isWorking)
			{
				elevator.FloorButtonPressed();
			}
		}
		else if (other.gameObject == firstFloorElevatorSfxTrigger && !grabbedTheLadder)
		{
			inFirstFloorElevatorSfxTrigger = true;
			firstFloorLiftFoley.FadeVolumeIn(2f);
			playerStereoAudio_01.FadeVolumeIn(2f, 0.5f);
		}
		else if (other.gameObject == plankCrackTrigger)
		{
			plankCrackTrigger.SetActive(value: false);
			plankAnimator.SetTrigger("Crack");
			floatingAudio_02.transform.position = floatingAudioPoint[16].position;
			floatingAudio_02.Play(floatingAudioClip[19]);
		}
		else if (other.gameObject == firstFloorLiftShaftTrigger)
		{
			firstFloorLiftShaftTrigger.SetActive(value: false);
			playerStereoAudio_02.Play(musicBrassHit, 0.65f);
		}
		else if (other.gameObject == bodyBagLayDownTrigger)
		{
			bodyBagLayDownTrigger.SetActive(value: false);
			corpseBodyBagAnimator.SetTrigger("Situp_Down");
			floatingAudio_02.transform.position = floatingAudioPoint[7].position;
			floatingAudio_02.Play(floatingAudioClip[17]);
			secondFloor_0.UpdateColliders(enabled: false);
		}
	}

	public override void OnTriggerExit(Collider other)
	{
		if (other.gameObject == showerTrigger)
		{
			inShowerTriggerArea = false;
		}
		else if (other.gameObject == hopkinsTrigger)
		{
			inHopkinsTriggerArea = false;
		}
		else if (other.gameObject == chickenTriggerMorgue)
		{
			inChickenSightTriggerAreaMorgue = false;
		}
		else if (other.gameObject == firstFloorElevatorSfxTrigger && !grabbedTheLadder)
		{
			inFirstFloorElevatorSfxTrigger = false;
			firstFloorLiftFoley.FadeVolumeOut(2f, 0.05f);
			playerStereoAudio_01.FadeVolumeIn(2f, 0.2f);
		}
		else if (other.gameObject == sideRoomTrigger)
		{
			inSideRoom = false;
		}
	}

	public override void OnSightTriggerEnter(Collider other)
	{
		if (other.gameObject == corpseBodyBagTrigger)
		{
			if (!seenBodyBagDrop)
			{
				seenBodyBagDrop = true;
			}
			else if (!seenCorpseBodyBag)
			{
				corpseBodyBagAnimator.SetTrigger("Fit");
				floatingAudio_01.transform.position = floatingAudioPoint[8].position;
				floatingAudio_01.Play(floatingAudioClip[8], 0.5f);
			}
			corpseBodyBagTrigger.SetActive(value: false);
		}
		else if (other.gameObject == deadBodyRiseupSightTrigger)
		{
			lookingAtDeadbodyRiseup = true;
			deadBodyRiseupSightTrigger.SetActive(value: false);
		}
		else if (other.gameObject == showerSightTrigger)
		{
			inShowerSightTriggerArea = true;
			if (inShowerTriggerArea && inShowerSightTriggerArea)
			{
				showerTrigger.SetActive(value: false);
				showerSightTrigger.SetActive(value: false);
				showerVinesAnimator.SetTrigger("Disappear");
				floatingAudio_02.transform.position = floatingAudioPoint[15].position;
				floatingAudio_02.Play(floatingAudioClip[15], 0.3f);
				GameController.instance.audioController.PlayBadSting(STINGS_BAD.BAD_SOFT_STING_01, 0.6f);
			}
		}
		else if (other.gameObject == hopkinsSightTrigger)
		{
			inHopkinsSightTriggerArea = true;
			if (inHopkinsTriggerArea && inHopkinsSightTriggerArea)
			{
				hopkinsTrigger.SetActive(value: false);
				hopkinsSightTrigger.SetActive(value: false);
				hopkinsAnimator.SetTrigger("Scare");
				GameController.instance.audioController.PlayBadSting(STINGS_BAD.BAD_SOFT_STING_02);
			}
		}
		else if (other.gameObject == chickenSightTriggerMorgue)
		{
			inChickenSightTriggerAreaMorgue = true;
			if (inChickenTriggerAreaMorgue && inChickenSightTriggerAreaMorgue)
			{
				chickenTriggerMorgue.SetActive(value: false);
				chickenSightTriggerMorgue.SetActive(value: false);
				chickenTriggerMorgueSkippedTrigger_1.SetActive(value: false);
				chickenTriggerMorgueSkippedTrigger_2.SetActive(value: false);
				inChickenTriggerAreaMorgue = false;
				inChickenSightTriggerAreaMorgue = false;
				StartCoroutine(ChickenFlyOff(disableMesh: false));
			}
		}
		else if (other.gameObject == morgueDrainSightTrigger && !lookedAtMorgueDrain)
		{
			morgueDrainSightTrigger.SetActive(value: false);
			lookedAtMorgueDrain = true;
		}
		else if (other.gameObject == chenHazmatSightTrigger && !lookedAtChenHazmatTrigger)
		{
			chenHazmatSightTrigger.SetActive(value: false);
			lookedAtChenHazmatTrigger = true;
		}
	}

	public override void OnSightTriggerExit(Collider other)
	{
		if (other.gameObject == showerSightTrigger)
		{
			inShowerSightTriggerArea = false;
		}
		else if (other.gameObject == hopkinsSightTrigger)
		{
			inHopkinsSightTriggerArea = false;
		}
		else if (other.gameObject == chickenSightTriggerMorgue)
		{
			inChickenSightTriggerAreaMorgue = false;
		}
	}

	private void DebugCommands()
	{
		if (Input.GetKeyDown(KeyCode.Return))
		{
			if (!triggeredEmergencyExit)
			{
				UnityEngine.Debug.Log("Triggering Emergency exit");
				triggeredEmergencyExit = true;
			}
			else if (!ladderRelease.ladderReleased)
			{
				UnityEngine.Debug.Log("Releasing ladder");
				ladderRelease.SmashLadderRelease();
				LeanTween.moveLocalZ(elevatorGate.transform.parent.gameObject, -1f, 0f);
			}
			else if (!grabbedTheLadder)
			{
				UnityEngine.Debug.Log("Grabbing ladder");
				grabbedTheLadder = true;
			}
			else if (!fuseboxOpen)
			{
				UnityEngine.Debug.Log("Fusebox Open");
				fuseboxOpen = true;
			}
			else if (!isFloorPowerOn)
			{
				UnityEngine.Debug.Log("Turning on power");
				fuseboxLeaverPulled = true;
				isFloorPowerOn = true;
			}
			else if (!idScanner.elevatorAccessGranted)
			{
				UnityEngine.Debug.Log("Scanning ID Card");
				idScanner.elevatorAccessGranted = true;
			}
			else if (!elevator.floorSelected)
			{
				UnityEngine.Debug.Log("Third floor");
				elevator.FloorButtonPressed();
			}
			else if (!elevator.floorSelected)
			{
				UnityEngine.Debug.Log("Floor selected");
				elevator.floorSelected = true;
			}
			else if (!enteredFinalCorridor)
			{
				UnityEngine.Debug.Log("Entered final corridoor");
				enteredFinalCorridor = true;
			}
			else if (!inMainArena)
			{
				UnityEngine.Debug.Log("Entered main arena");
				player.SetPosition(finalePlayerPos.gameObject);
				inMainArena = true;
			}
			else if (!lookedAtMorgueDrain)
			{
				UnityEngine.Debug.Log("Looked at drain");
				lookedAtMorgueDrain = true;
			}
			else if (!saltSprayer.hitTarget)
			{
				UnityEngine.Debug.Log("Salt spray finch");
				saltSprayer.hitTarget = true;
			}
			else if (!inNavCarveArea)
			{
				UnityEngine.Debug.Log("In nav cavre area");
				player.SetPosition(finalePlayerPos.gameObject);
				inNavCarveArea = true;
			}
			else if (!inDeadbodyRiseupArea && !lookingAtDeadbodyRiseup)
			{
				UnityEngine.Debug.Log("Looking at corpses");
				inDeadbodyRiseupArea = true;
				lookingAtDeadbodyRiseup = true;
			}
			else if (!inMainArena)
			{
				UnityEngine.Debug.Log("In main area");
				inMainArena = true;
			}
			else if (!saltSprayer.hitWrongTarget)
			{
				UnityEngine.Debug.Log("Salt spray corspe");
				saltSprayer.wrongTargetHit = deadBodies[2].gameObject;
				saltSprayer.hitWrongTarget = true;
			}
			else if (!saltSprayer.hitTarget)
			{
				UnityEngine.Debug.Log("Salt spray target");
				saltSprayer.hitTarget = true;
			}
		}
	}
}
public class NurseryScene : InteractionManager
{
	private enum ExorcismType
	{
		BABY,
		MIRROR,
		ABYZU,
		FIRST_MANNEQUIN,
		SECOND_MANNEQUIN
	}

	private bool introComplete;

	private NVRPlayer player;

	private LightFlicker playerLightFlicker;

	private Light PicoLight;

	private int debugCount;

	[Header("General")]
	[SerializeField]
	private GameObject playerStartPosition;

	[SerializeField]
	private TextMeshProUGUI chapterName;

	[SerializeField]
	private TextMeshProUGUI chapterNumber;

	[SerializeField]
	private Material nightSkybox;

	[SerializeField]
	private OilLighterLookAt lighterLookAt;

	[SerializeField]
	private GameObject[] changeLayerObjects;

	[SerializeField]
	private ReflectionProbe[] reflectionProbes;

	private bool inSlowMo;

	private AudioSource[] allAudio;

	private OilLighter lighter;

	private Camera playerCamera;

	[SerializeField]
	private Shader questBurnShaderPart1;

	[SerializeField]
	private Shader questBurnShaderPart2;

	[SerializeField]
	private Shader questCheapBurnShaderPart1;

	[SerializeField]
	private Shader questCheapBurnShaderPart2;

	[SerializeField]
	private Material manniquinDissolveMat1;

	[SerializeField]
	private Material manniquinDissolveMat2;

	[Space]
	[Header("Rooms")]
	[SerializeField]
	private GameObject fakeBathRoom;

	[SerializeField]
	private GameObject mirrorworldRoom;

	[SerializeField]
	private GameObject mirrorworldBakedLightingRoom;

	[SerializeField]
	private GameObject mirrorworldNoneBakedLightingRoom;

	[SerializeField]
	private GameObject hellGateRoom;

	[SerializeField]
	private GameObject sunnyNurseryRoom;

	[SerializeField]
	private GameObject standardOOBsDownstairs;

	[SerializeField]
	private GameObject standardOOBsUpstairs;

	[Space]
	[SerializeField]
	private GameObject roomsParent;

	[SerializeField]
	private Room room_Downstairs;

	[SerializeField]
	private Room room_MainLoft;

	[SerializeField]
	private GameObject room_Closet;

	private bool inCloset;

	[SerializeField]
	private Room room_Mothers;

	[SerializeField]
	private Room room_Bathroom;

	[SerializeField]
	private Room room_MirrorWorld;

	[SerializeField]
	private Room room_NurseryDay;

	[Space]
	[SerializeField]
	private GameObject navBlock_Mirror;

	[SerializeField]
	private GameObject navBlock_MirrorBaked;

	[SerializeField]
	private GameObject navBlock_MirrorBack;

	[SerializeField]
	private GameObject navBlock_Nursery;

	[Space]
	[Header("Downstairs Room")]
	[SerializeField]
	private NVRInteractableItem downstairsDoorKnob;

	[SerializeField]
	private AstrolabeArtefact astrolabeArtefact;

	[SerializeField]
	private GameObject sacredEarth;

	private bool foundSacredEarth;

	[Space]
	[Header("Audio")]
	[SerializeField]
	private AudioScript floatingAudio01;

	[SerializeField]
	private AudioScript floatingAudio02;

	[SerializeField]
	private AudioScript floatingAudioWomen;

	[SerializeField]
	private AudioScript floatingAudioWomenFinal;

	[SerializeField]
	private AudioScript floatingAudioHusband;

	[SerializeField]
	private Transform[] floatingAudioPositions;

	[SerializeField]
	private Transform[] floatingAudioPositionsWomen;

	[SerializeField]
	private AudioScript babyMonitor;

	[SerializeField]
	private AudioScript motherCrySource;

	[SerializeField]
	private AudioScript bathDripSource;

	[SerializeField]
	private AudioScript maggotPictureSource;

	[SerializeField]
	private AudioScript doorHandleFlashbackSource;

	[Space]
	[SerializeField]
	private AudioClip womenShhClip;

	[SerializeField]
	private AudioClip womenChairClip;

	[SerializeField]
	private AudioClip womenChairClipCloser1;

	[SerializeField]
	private AudioClip womenChairClipCloser2;

	[SerializeField]
	private AudioClip[] womenSeenChairClip;

	[SerializeField]
	private AudioClip womenBathroomClip;

	[SerializeField]
	private AudioClip womenBathroomConvo1;

	[SerializeField]
	private AudioClip[] womenBathroomConvo2;

	[SerializeField]
	private AudioClip[] womenBathroomConvo3;

	[SerializeField]
	private AudioClip[] womenMirrorResponseClips;

	[SerializeField]
	private AudioClip womenCribDollResponse;

	[SerializeField]
	private AudioClip[] womenSnakeResponseClips;

	[SerializeField]
	private AudioClip womenExoBabyResponse;

	[SerializeField]
	private AudioClip womenExoDeath;

	[SerializeField]
	private AudioClip womenExoDeathNoooo;

	[Space]
	[SerializeField]
	private Transform[] floatingHusbandPositions;

	[SerializeField]
	private AudioClip husbandComeDownClip;

	[SerializeField]
	private AudioClip husbandNewsClip;

	[SerializeField]
	private AudioClip husbandPillsClip;

	[SerializeField]
	private AudioClip husbandParisClip;

	[SerializeField]
	private AudioClip husbandBathroomConvo1;

	[SerializeField]
	private AudioClip[] husbandBathroomConvo2;

	[SerializeField]
	private AudioClip husbandBathroomConvo3;

	[Space]
	[SerializeField]
	private AudioClip babyMonitorNoise;

	[SerializeField]
	private AudioClip babyMonitorWomen;

	[SerializeField]
	private AudioClip babyRoofClip;

	[SerializeField]
	private AudioClip babyCrawlClip;

	[SerializeField]
	private AudioClip babyChokeClip;

	[SerializeField]
	private AudioClip babyChokeMusicClip;

	[SerializeField]
	private AudioClip babyNeckCrackClip;

	[Space]
	[SerializeField]
	private AudioClip doorSlamClip;

	[SerializeField]
	private AudioClip rockingChairClip;

	[SerializeField]
	private AudioClip buildingBlockFallClip;

	[SerializeField]
	private AudioClip lightPopClip;

	[SerializeField]
	private AudioClip slidingClothesRackSFX;

	[SerializeField]
	private AudioClip knockingClip;

	[SerializeField]
	private AudioClip[] mirrorCrackClip;

	[SerializeField]
	private AudioClip mobileLoop;

	[SerializeField]
	private AudioClip mobileMirrorLoop;

	[SerializeField]
	private AudioClip maggotsLoop;

	[SerializeField]
	private AudioClip snakeSqueakClip;

	[SerializeField]
	private AudioClip lockedDoorClip;

	[SerializeField]
	private AudioClip motherCryLoop;

	[SerializeField]
	private AudioClip[] snakeSounds;

	[SerializeField]
	private AudioClip doorCreakClip;

	[SerializeField]
	private AudioClip doorCloseClip;

	[SerializeField]
	private AudioClip bathDrainClip;

	[SerializeField]
	private AudioClip wineSmashClip;

	[SerializeField]
	private AudioClip snakeSloshLoop;

	[SerializeField]
	private AudioClip mamaClip;

	[SerializeField]
	private AudioClip mirrorBreak;

	[SerializeField]
	private AudioClip ghostFoleyDoorHandleClip;

	[SerializeField]
	private AudioClip pazuzuHiss;

	[SerializeField]
	private AudioClip bathroomDoorUnlockClip;

	[SerializeField]
	private AudioClip secretDoorSlideClip;

	[Space]
	[SerializeField]
	private AudioScript musicPlayer;

	[SerializeField]
	private AudioClip music_CelloBed;

	[SerializeField]
	private AudioClip music_MumsRoomEnter;

	[SerializeField]
	private AudioClip music_MumsRoomBuild;

	[SerializeField]
	private AudioClip music_BathroomBuild;

	[SerializeField]
	private AudioClip music_BathroomReveal;

	[SerializeField]
	private AudioClip music_highwire03Build;

	[SerializeField]
	private AudioClip music_highwire03BuildDist;

	[SerializeField]
	private AudioClip music_lightBuild;

	[SerializeField]
	private AudioClip music_highwireHiss;

	[SerializeField]
	private AudioClip music_mirrorEntrySting;

	[SerializeField]
	private AudioClip music_endingPersist;

	[Space]
	[Header("Lights")]
	[SerializeField]
	private LightFlicker cribLight;

	[SerializeField]
	private LightFlicker mirrorCribLight;

	[SerializeField]
	private LightFlicker rockingChairLight;

	[SerializeField]
	private LightFlicker mirrorSpotLight;

	[Space]
	[Header("Nursery")]
	[SerializeField]
	private GameObject fakeCross;

	[SerializeField]
	private GameObject stairsTrigger;

	[SerializeField]
	private GameObject closetTrigger;

	[SerializeField]
	private InteractiveDoor stairsDoor;

	[SerializeField]
	private GameObject crib;

	[SerializeField]
	private GameObject cribSightTrigger;

	[SerializeField]
	private GameObject stairsSightTrigger;

	[SerializeField]
	private GameObject baby;

	[SerializeField]
	private Animator babyAnim;

	[SerializeField]
	private Renderer babyRenderer;

	[SerializeField]
	private Material babyGhostMat;

	[SerializeField]
	private Renderer babyEyeRenderer;

	[SerializeField]
	private GameObject babyInnerFace;

	[SerializeField]
	private GameObject lookAtTarget;

	[SerializeField]
	private GameObject cribSheet;

	[SerializeField]
	private GameObject cribSheetMessy;

	[SerializeField]
	private NVRInteractableItem babyDummy;

	[SerializeField]
	private Transform babyDummyPos;

	private bool onStairs;

	private bool seenCrib;

	private bool lookedAtDoor;

	private bool pianoNoiseCompleted;

	[Space]
	[Header("Investigate")]
	[SerializeField]
	private NVRInteractableItem popupBook;

	[SerializeField]
	private InteractiveDoor dollHouseFront;

	[SerializeField]
	private GameObject dollsHouseSightTrigger;

	[SerializeField]
	private NVRInteractableItem dollHouseTop;

	[SerializeField]
	private DollHouse dollHouse;

	[SerializeField]
	private GameObject closetPosterTrigger;

	[SerializeField]
	private GameObject toysnake;

	[SerializeField]
	private GameObject toySnakeTrigger;

	[SerializeField]
	private Piano toyPiano;

	[SerializeField]
	private GameObject closetClothes;

	[SerializeField]
	private GameObject closetClothesInteractablePivot;

	[SerializeField]
	private GameObject closetClothesSightTrigger;

	private bool lookingAtClothes;

	[SerializeField]
	private GameObject buildingBlocks;

	[SerializeField]
	private GameObject mobile;

	[SerializeField]
	private GameObject standingMirror;

	[Space]
	[SerializeField]
	private InteractiveDoor bathroomDoor;

	[SerializeField]
	private GameObject backBathroomWall;

	[SerializeField]
	private GameObject abyzuBathroom;

	[Space]
	[SerializeField]
	private GameObject[] petalHints;

	[SerializeField]
	private InteractiveDoor closetDoor;

	[SerializeField]
	private GameObject screen;

	[SerializeField]
	private GameObject chairSightTrigger;

	[SerializeField]
	private GameObject behindScreenTrigger;

	[SerializeField]
	private GameObject chairMannequin;

	[SerializeField]
	private Animator chairAnim;

	[SerializeField]
	private GameObject closetLightBulbFull;

	[SerializeField]
	private GameObject closetLightBulbBroken;

	[SerializeField]
	private GameObject secretDoorHide;

	[SerializeField]
	private GameObject secretDoorUnHide;

	[SerializeField]
	private NVRInteractableItem secretDoor;

	[SerializeField]
	private ReflectionProbe closetReflectionProbe;

	[SerializeField]
	private GameObject closetLightParticles;

	[SerializeField]
	private BoxCollider closetBoxCollider;

	[SerializeField]
	private GameObject awayFromChairTrigger;

	private bool foundBook;

	private bool foundDollHouse;

	private bool lookedAtFallingBlocks;

	private bool seenClostPoster;

	private bool seenBathroomAbyzu;

	private bool completedBathroomSetpiece;

	private bool seenEmptyChair;

	private bool behindScreen;

	private bool lookingForSecrets;

	[Space]
	[Header("Mothers Room")]
	[SerializeField]
	private SewingMachine sewingMachine;

	[SerializeField]
	private GameObject motherRoomStartPosition;

	[SerializeField]
	private GameObject posterTrigger;

	[SerializeField]
	private NVRInteractableItem motherPoster;

	[SerializeField]
	private Renderer posterRender;

	[SerializeField]
	private Maggot[] maggots;

	[SerializeField]
	private GameObject maggotGroup;

	[SerializeField]
	private Material posterNormalMat;

	[SerializeField]
	private Material posterGrossMat;

	private Material posterMat;

	private bool foundMachine;

	private bool seenPoster;

	private bool mothersRoomRoutine;

	[Space]
	[Header("Bathroom")]
	[SerializeField]
	private InteractiveDoor bathroomSideDoor;

	[SerializeField]
	private GameObject bathroomTrigger;

	[SerializeField]
	private GameObject bathroomWallSolid;

	[SerializeField]
	private GameObject bathroomWallDoor;

	[SerializeField]
	private GameObject bathroomSideDoorHide;

	[SerializeField]
	private NVRInteractableItem pregTest;

	[SerializeField]
	private NVRInteractableItem pregTestBox;

	[SerializeField]
	private GameObject snakeBathroom;

	[SerializeField]
	private NVRInteractableItem cabinetDoor;

	[SerializeField]
	private GameObject mirrorTrigger;

	[SerializeField]
	private GameObject awayFromMirrorTrigger;

	[SerializeField]
	private GameObject mirrorBroken;

	[SerializeField]
	private GameObject mirrorNormal;

	[SerializeField]
	private NVRInteractableItem pregTube;

	[SerializeField]
	private NVRInteractableItem booze;

	[SerializeField]
	private NVRInteractableItem razor1;

	[SerializeField]
	private NVRInteractableItem razor2;

	[SerializeField]
	private GameObject bathWater;

	[SerializeField]
	private GameObject bathWaterDrip;

	[SerializeField]
	private GameObject bathBloodDrip;

	[SerializeField]
	private NVRInteractableItem tapSink;

	[SerializeField]
	private NVRInteractableItem tapBath;

	[SerializeField]
	private GameObject tableNormal;

	[SerializeField]
	private GameObject tableSuicide;

	[SerializeField]
	private GameObject tableSuicideHint;

	[SerializeField]
	private NVRInteractableItem toilet;

	[SerializeField]
	private Material bloodyBathWaterMaterial;

	[SerializeField]
	private MeshRenderer[] bathMeshRenderer;

	private bool playerEnteredBathroom;

	private bool playerInMothersRoom;

	private bool foundPregTest;

	private bool foundPregTestBox;

	private bool foundPregTube;

	private bool foundRazor;

	private bool lookingInMirror;

	private bool lookingAwayFromMirror;

	private bool lookingAwayFromChair;

	private bool seenMaggots;

	private bool inExorciseBabyInMirrorArea;

	[Space]
	[Header("Mirror world")]
	[SerializeField]
	private GameObject playerStartPositionAfterPortal;

	[SerializeField]
	private GameObject exorciseBabyInMirrorTrigger;

	[SerializeField]
	private GameObject mirrorWorldBack;

	[SerializeField]
	private GameObject mirrorPortalTrigger;

	[SerializeField]
	private GameObject mirrorPortal;

	[SerializeField]
	private LayerMask mirrorWorldLayerMask;

	[SerializeField]
	private GameObject mirrorPortalTeleportTrigger;

	[SerializeField]
	private GameObject mirrorPortalNavBlock;

	[SerializeField]
	private PortalCamera mirrorPortalCameraScript;

	[SerializeField]
	private GameObject mirrorWorldOOBs;

	[SerializeField]
	private PortalCamera hellGatePortalCameraScript;

	[SerializeField]
	private GameObject hellPortal;

	[SerializeField]
	private GameObject mirrorTransitionTrigger;

	[SerializeField]
	private Transform crossMirrorPoint1;

	[SerializeField]
	private Transform crossMirrorPoint2;

	[SerializeField]
	private GameObject mirrorWorldStart;

	[SerializeField]
	private GameObject mirrorWorldCribBaby;

	[SerializeField]
	private Animator mirrorWorldCribBabyAnim;

	[SerializeField]
	private Renderer mirrorWorldCribBabyEyeRenderer;

	[SerializeField]
	private GameObject demonBaby;

	[SerializeField]
	private Animator demonBabyAnim;

	[SerializeField]
	private Transform demonBabyPos1;

	[SerializeField]
	private ParticleSystem demonBabyHideParticlesPos1;

	[SerializeField]
	private Transform demonBabyPos2;

	[SerializeField]
	private Transform demonBabyEndPos1;

	[SerializeField]
	private ParticleSystem demonBabyHideParticlesEndPos1;

	[SerializeField]
	private Transform demonBabyEndPos2;

	[SerializeField]
	private ParticleSystem demonBabyHideParticles;

	[SerializeField]
	private GameObject demonBabyTrigger1;

	[SerializeField]
	private GameObject demonBabyTrigger2;

	[SerializeField]
	private GameObject demonBabySightTrigger2;

	[SerializeField]
	private AudioScript mobileAudio;

	[SerializeField]
	private GameObject demonParticleMask;

	[SerializeField]
	private Transform babySitTransform;

	[SerializeField]
	private GameObject flippedObjects;

	[SerializeField]
	private GameObject wallToTurnOff;

	[SerializeField]
	private GameObject babySightTrigger;

	[SerializeField]
	private GameObject cribMirror1;

	[SerializeField]
	private GameObject cribMirror2;

	[SerializeField]
	private GameObject mannequinPath;

	[SerializeField]
	private GameObject mannequinBlock1;

	[SerializeField]
	private MeshRenderer mannequinBlock1Mesh;

	[SerializeField]
	private GameObject mannequinBlock2;

	[SerializeField]
	private MeshRenderer mannequinBlock2Mesh;

	[SerializeField]
	private ParticleSystem mannequinParticles1;

	[SerializeField]
	private ParticleSystem mannequinParticles2;

	[SerializeField]
	private GameObject mirrorBabyTrigger;

	[SerializeField]
	private Animator dollAnim;

	[SerializeField]
	private GameObject crossRemoval;

	[SerializeField]
	private GameObject babyExParticle;

	[SerializeField]
	private GameObject portalOOB;

	[SerializeField]
	private GameObject[] mirrorWorldOOB;

	[SerializeField]
	private AudioSource possesedCribBabyAudio;

	[SerializeField]
	private ParticleSystem particle_babyExPorgression01;

	[SerializeField]
	private ParticleSystem particle_babyExPorgression02;

	[SerializeField]
	private GameObject[] objectsToDisableAfterMirrorWorld;

	[SerializeField]
	private Transform mirrorWorldBakedPlayerStart;

	[SerializeField]
	private Transform babymirrorWorldBakedPosition;

	private bool inMirrorTrigger;

	private bool inPortalTrigger;

	private bool triggerDemonBaby1;

	private bool triggerDemonBaby2;

	private bool sightTriggerDemonBaby2;

	private bool lookingAtBabyInMirror;

	private bool seenMirrorTrigger1;

	private bool seenMirrorTrigger2;

	private bool cameraShake;

	private float shakeAmount = 0.01f;

	private UnityEngine.Color demonEyeColor = new UnityEngine.Color(0.6176471f, 0.4810882f, 0.2543252f);

	[Space]
	[Header("Exorcism")]
	[SerializeField]
	private GameObject exorcismTarget;

	[SerializeField]
	private GameObject[] exorcismTargetLocations;

	[SerializeField]
	private GameObject[] exorcismTargetLocationsAbyzu;

	[SerializeField]
	private GameObject[] exorcismTargetLocationsMirror;

	[SerializeField]
	private GameObject[] exorcismTargetLocationsFirstMannequin;

	[SerializeField]
	private GameObject[] exorcismTargetLocationsSecondMannequin;

	[SerializeField]
	private Transform babyFinalCribPos;

	[SerializeField]
	private SnakeController exorcismSnakes;

	[SerializeField]
	private GameObject abyzuReal;

	[SerializeField]
	private GameObject abyzuHell;

	[SerializeField]
	private GameObject abyzuSightTrigger;

	[SerializeField]
	private GameObject exorcismNavBlock;

	[SerializeField]
	private BabySounds babySound;

	[SerializeField]
	private GameObject abyzuRayTarget;

	[SerializeField]
	private Animator mirrorAnim;

	[SerializeField]
	private GameObject mirrorShards;

	[SerializeField]
	private ParticleSystem particleMirrorSmashAbyzou;

	[SerializeField]
	private Renderer hellBackground;

	[Space]
	[SerializeField]
	private WindZone hellWind;

	[SerializeField]
	private ParticleSystem hellSmokeFloor;

	[SerializeField]
	private ParticleSystem hellGateSmoke;

	[SerializeField]
	private ParticleSystem hellDust;

	private bool lookingAtAbyzu;

	private bool crossSelected;

	private GameObject cross;

	private TuneController tuneCross;

	private ExorcismItem interactableCross;

	private bool exorcismComplete;

	[Space]
	[Header("Snakes")]
	[SerializeField]
	private GameObject snake_Mannequin1;

	[SerializeField]
	private SkinnedMeshRenderer snake_Mannequin1Mesh;

	[SerializeField]
	private GameObject snake_Mannequin2;

	[SerializeField]
	private SkinnedMeshRenderer snake_Mannequin2Mesh;

	[SerializeField]
	private GameObject snake_Beam;

	[SerializeField]
	private SkinnedMeshRenderer snake_BeamMesh;

	[SerializeField]
	private GameObject snake_BabyNeck;

	[SerializeField]
	private SkinnedMeshRenderer snake_BabyNeckMesh;

	[SerializeField]
	private GameObject snake_MouthExit;

	[SerializeField]
	private SkinnedMeshRenderer snake_MouthExitMesh;

	[SerializeField]
	private GameObject snake_Poster1;

	[SerializeField]
	private GameObject snake_Poster2;

	[SerializeField]
	private GameObject snake_Bath;

	[Space]
	[Header("Finale")]
	[SerializeField]
	private GameObject sunnyStart;

	[SerializeField]
	private GameObject birdSong;

	[Space]
	[Header("Achievements")]
	private bool foundGhostedItems;

	private bool noSnakesinCrib;

	private bool triedToLeave;

	private bool dollsHouseAchievementUnlocked;

	private bool seenToiletPills;

	private bool enteredBathroomFirstTime;

	private bool turnedDollHouseLightOn;

	private List<NVRInteractable> LooseObjects = new List<NVRInteractable>();

	private void Start()
	{
		EventManager.StartListening(EventManager.AvailableEvents.IntroComplete.ToString(), IntroCompleted);
		EventManager.StartListening(EventManager.AvailableEvents.ExitLevelToPrecint.ToString(), ExitToPrecinct);
		EventManager.StartListening(EventManager.AvailableEvents.RestartScene.ToString(), RestartLevel);
		EventManager.StartListening(EventManager.AvailableEvents.ResetProgress.ToString(), ResetProgress);
		navBlock_Mirror.SetActive(value: false);
		navBlock_MirrorBaked.SetActive(value: false);
		mirrorPortalCameraScript.portalCamera.gameObject.SetActive(value: false);
		mirrorPortal.gameObject.SetActive(value: false);
		hellGatePortalCameraScript.portalCamera.gameObject.SetActive(value: false);
		player = GameController.instance.player;
		player.movement.DisableEverything();
		player.screenFX.Fade(UnityEngine.Color.black, 0f);
		player.screenFX.SetChapter3PostProcessingProfile();
		playerCamera = player.Head.GetComponentInChildren<Camera>();
		float[] array = new float[32];
		array[14] = 8f;
		playerCamera.layerCullDistances = array;
		cross = player.HandMenu.exKitScript.cross;
		tuneCross = cross.GetComponent<TuneController>();
		tuneCross.SetSpotLightEnabled(enabled: true);
		tuneCross.SetPointLightEnabled(enabled: true);
		interactableCross = cross.GetComponent<ExorcismItem>();
		lookAtTarget.transform.SetParent(player.Head.transform);
		lookAtTarget.transform.localPosition = Vector3.zero;
		babyEyeRenderer.sharedMaterial.SetColor("_EmissionColor", UnityEngine.Color.black);
		lighter = player.HandMenu.exKitScript.candle.GetComponent<OilLighter>();
		lighter.canTurnOnLight = false;
		RenderSettings.skybox = nightSkybox;
		DynamicGI.UpdateEnvironment();
		posterRender.material = posterGrossMat;
		mannequinBlock1Mesh.material.SetFloat("_Amount", 0f);
		mannequinBlock2Mesh.material.SetFloat("_Amount", 0f);
		snake_Mannequin1Mesh.material.SetFloat("_Amount", 0f);
		snake_Mannequin2Mesh.material.SetFloat("_Amount", 0f);
		snake_BeamMesh.material.SetFloat("_Amount", 0f);
		snake_MouthExitMesh.material.SetFloat("_Amount", 0f);
		snake_BabyNeckMesh.material.SetFloat("_Amount", 0f);
		posterMat = posterRender.material;
		posterMat.EnableKeyword("_AlbedoSlider");
		posterMat.SetFloat("_AlbedoSlider", 0f);
		mirrorworldRoom.SetActive(value: false);
		mirrorworldBakedLightingRoom.SetActive(value: false);
		mirrorworldNoneBakedLightingRoom.SetActive(value: false);
		hellGateRoom.SetActive(value: false);
		fakeBathRoom.SetActive(value: false);
		bathroomSideDoorHide.SetActive(value: false);
		booze.gameObject.SetActive(value: false);
		razor1.gameObject.SetActive(value: false);
		razor2.gameObject.SetActive(value: false);
		tableSuicide.SetActive(value: false);
		sunnyNurseryRoom.SetActive(value: false);
		bathroomWallDoor.SetActive(value: false);
		closetLightParticles.SetActive(value: false);
		toysnake.SetActive(value: false);
		chairMannequin.SetActive(value: false);
		closetPosterTrigger.SetActive(value: false);
		mirrorPortalTeleportTrigger.SetActive(value: false);
		lighterLookAt.gameObject.SetActive(value: true);
		closetClothesSightTrigger.SetActive(value: false);
		standardOOBsUpstairs.SetActive(value: false);
		mirrorWorldBack.SetActive(value: false);
		mirrorPortalTrigger.SetActive(value: false);
		if (chairAnim.enabled)
		{
			chairAnim.SetFloat("Speed", 0f);
			chairAnim.enabled = false;
		}
		playerLightFlicker = player.playerLight.GetComponent<LightFlicker>();
		PicoLight = player.PicoLight.GetComponent<Light>();
		player.playerLight.GetComponent<Light>().enabled = true;
		player.playerLight.enabled = true;
		playerLightFlicker.light.enabled = true;
		playerLightFlicker.SwitchLight(switchOn: false);
		playerLightFlicker.light.shadows = LightShadows.None;
		player.playerLight.EnableRay(enable: false);
		playerLightFlicker.ResetIntensity();
		PicoLight.enabled = true;
		standardOOBsDownstairs.SetActive(value: true);
		standardOOBsUpstairs.SetActive(value: false);
		secretDoorUnHide.SetActive(value: false);
		rockingChairLight.SetIntensity(0f);
		for (int i = 0; i < mirrorWorldOOB.Length; i++)
		{
			mirrorWorldOOB[i].SetActive(value: false);
		}
		if (mirrorShards.activeSelf)
		{
			mirrorShards.SetActive(value: false);
		}
		if (wallToTurnOff.activeSelf)
		{
			wallToTurnOff.SetActive(value: false);
		}
		StartCoroutine(Master());
	}

	public void Update()
	{
		if (mothersRoomRoutine)
		{
			if (room_Mothers.playerInRoom)
			{
				bathroomSideDoorHide.SetActive(value: true);
			}
			else
			{
				bathroomSideDoorHide.SetActive(value: false);
			}
		}
		if (mobileAudio.m_AudioSource.isPlaying)
		{
			mobile.transform.localEulerAngles += new Vector3(0f, 10f * Time.deltaTime, 0f);
		}
	}

	private void IntroCompleted()
	{
		introComplete = true;
	}

	private IEnumerator Master()
	{
		if (SaveManager.instance.HasFoundArtifact(ChapterID.NURSERY))
		{
			astrolabeArtefact.setArtifactRevealed();
		}
		GameController.instance.currentRoom = room_Downstairs;
		room_Bathroom.UpdateColliders(enabled: true);
		room_Bathroom.associatedParentGameObject.SetActive(value: false);
		room_Bathroom.playerInRoom = false;
		room_Bathroom.enabled = false;
		room_Closet.SetActive(value: false);
		room_Downstairs.UpdateColliders(enabled: false);
		room_Downstairs.associatedParentGameObject.SetActive(value: true);
		room_Downstairs.playerInRoom = true;
		room_Mothers.UpdateColliders(enabled: true);
		room_Mothers.associatedParentGameObject.SetActive(value: false);
		room_Mothers.playerInRoom = false;
		room_Mothers.enabled = false;
		room_MainLoft.UpdateColliders(enabled: true);
		room_MainLoft.associatedParentGameObject.SetActive(value: false);
		room_MainLoft.playerInRoom = false;
		room_MainLoft.enabled = false;
		player.SubtractFromLayerMask("MirrorWorld");
		player.SubtractFromLayerMask("MirrorWorldLighting");
		player.SubtractFromLayerMask("MirrorWorldInteractive");
		player.SubtractFromLayerMask("HellGateLighting");
		player.SubtractFromLayerMask("HellGateInteractive");
		yield return StartCoroutine(FadeInScene());
		yield return StartCoroutine(InvestigateNursery());
		yield return StartCoroutine(CribBaby());
		yield return StartCoroutine(Closet());
		yield return StartCoroutine(MothersRoom());
		yield return StartCoroutine(Bathroom());
		yield return StartCoroutine(IntoMirrorWorld());
		yield return StartCoroutine(FirstMannequinExorcism());
		yield return StartCoroutine(SecondMannequinExorcism());
		yield return StartCoroutine(BabyExorcism());
		yield return StartCoroutine(FinalExorcism());
		yield return StartCoroutine(FinalSetPiece());
		yield return StartCoroutine(FadeOutScene());
	}

	private IEnumerator FadeInScene()
	{
		player.HandMenu.BookInMenu(active: true);
		player.HandMenu.KitInMenu(active: true);
		while (!introComplete)
		{
			yield return null;
		}
		UnityEngine.Debug.Log("Fading in Nursery Scene");
		GameController.instance.audioController.SnapAllOpen(3f);
		babyMonitor.PlayLoop(babyMonitorWomen);
		SaveManager.instance.MarkChapterStarted(ChapterID.NURSERY);
		EventManager.TriggerEvent(EventManager.AvailableEvents.SwitchedScenes.ToString());
		player.SetPosition(playerStartPosition);
		chapterName.transform.parent.gameObject.SetActive(value: true);
		player.screenFX.Fade(UnityEngine.Color.clear, 3f);
		yield return Yield.WaitSeconds(3f);
		GameController.instance.boundDetection.SwitchOnOOB();
		chapterName.CrossFadeAlpha(0f, 3f, ignoreTimeScale: false);
		chapterNumber.CrossFadeAlpha(0f, 3f, ignoreTimeScale: false);
		player.movement.EnableEverything();
	}

	private IEnumerator InvestigateNursery()
	{
		UnityEngine.Debug.Log("Investigate Nursery");
		GameController.instance.hintManager.AddHint(stairsDoor);
		float timeoutTime = Time.time + 10f;
		bool timedOut = false;
		float audioTime = Time.time + babyMonitorNoise.length;
		bool toggle = true;
		closetPosterTrigger.SetActive(value: true);
		stairsTrigger.SetActive(value: true);
		while (!onStairs)
		{
			if (!timedOut && Time.time > timeoutTime)
			{
				timedOut = true;
				GameController.instance.audioController.persistentMusicPlayer.FadeOut(4f);
			}
			if (Time.time > audioTime)
			{
				if (toggle)
				{
					babyMonitor.PlayLoop(babyMonitorWomen);
					audioTime = Time.time + babyMonitorWomen.length;
					toggle = false;
				}
				else
				{
					babyMonitor.PlayLoop(babyMonitorNoise);
					audioTime = Time.time + babyMonitorNoise.length;
					toggle = true;
				}
			}
			yield return null;
		}
		GameController.instance.hintManager.RemoveHint(stairsDoor);
		if (!timedOut)
		{
			GameController.instance.audioController.persistentMusicPlayer.FadeOut(4f);
		}
		babyMonitor.FadeOut(3f);
		while (!room_MainLoft.playerInRoom)
		{
			yield return null;
		}
		standardOOBsDownstairs.SetActive(value: false);
		standardOOBsUpstairs.SetActive(value: true);
		yield return Yield.WaitSeconds(1f);
		dollsHouseSightTrigger.SetActive(value: true);
		GameController.instance.hintManager.AddHint(bathroomDoor);
		GameController.instance.hintManager.AddHint(cabinetDoor);
		GameController.instance.hintManager.AddHint(toilet);
		GameController.instance.hintManager.AddHint(dollHouseFront);
		GameController.instance.hintManager.AddHint(closetDoor);
		StartCoroutine(BathroomSetpiece());
		while (!foundDollHouse && !completedBathroomSetpiece)
		{
			yield return null;
		}
		pregTube.gameObject.SetLayer(16);
		buildingBlocks.SetActive(value: true);
		lookedAtFallingBlocks = false;
		demonBabyTrigger1.SetActive(value: true);
		while (!lookedAtFallingBlocks && !foundPregTube)
		{
			yield return null;
		}
		demonBabyTrigger1.SetActive(value: false);
		Vector3 vector = new Vector3(-3.23f, 0.62f, 6.71f);
		Collider[] array = Physics.OverlapSphere(vector, 1f);
		for (int i = 0; i < array.Length; i++)
		{
			Rigidbody component = array[i].GetComponent<Rigidbody>();
			if (component != null)
			{
				component.AddExplosionForce(8f, vector, 1f, 2f);
			}
		}
		while (!foundPregTube)
		{
			yield return null;
		}
		GameController.instance.hintManager.RemoveHint(dollHouseFront);
		floatingAudioHusband.gameObject.transform.position = floatingHusbandPositions[3].position;
		floatingAudioHusband.Play(husbandPillsClip);
		HUD.Instance.PlaySubtitles(husbandPillsClip.name, hasPriority: true);
		StartCoroutine(AbyzuBathroomSetpiece());
		yield return Yield.WaitSeconds(husbandPillsClip.length);
	}

	private IEnumerator AbyzuBathroomSetpiece()
	{
		fakeBathRoom.SetActive(value: true);
		backBathroomWall.SetActive(value: true);
		abyzuBathroom.SetActive(value: true);
		bathroomDoor.GetComponent<BoxCollider>().enabled = false;
		bathroomDoor.OpenDoor(-130f, 0f);
		GameController.instance.hintManager.AddHint(bathroomDoor);
		while (!seenBathroomAbyzu)
		{
			yield return null;
		}
		baby.SetActive(value: false);
		cribSheetMessy.SetActive(value: true);
		cribSheet.SetActive(value: false);
		yield return Yield.WaitSeconds(1.5f);
		GameController.instance.hintManager.RemoveHint(bathroomDoor);
		abyzuBathroom.GetComponent<Animator>().SetTrigger("BathroomDoorClose");
		yield return Yield.WaitSeconds(1.1f);
		bathroomDoor.CloseDoor(-178.8f, 0.5f, lockAfter: true, resetPosition: true);
		floatingAudioWomen.gameObject.transform.position = abyzuBathroom.transform.position + new Vector3(0f, 1.8f, 0f);
		floatingAudioWomen.Play(womenBathroomClip);
		floatingAudio01.gameObject.transform.position = bathroomDoor.transform.position;
		floatingAudio01.Play(doorSlamClip);
		yield return Yield.WaitSeconds(0.5f);
		bathroomDoor.GetComponent<BoxCollider>().enabled = true;
		abyzuBathroom.SetActive(value: false);
		fakeBathRoom.SetActive(value: true);
	}

	private IEnumerator BathroomSetpiece()
	{
		while (!room_Bathroom.playerInRoom)
		{
			yield return null;
		}
		StartCoroutine(LighterCheck());
		while (!foundPregTest)
		{
			yield return null;
		}
		GameController.instance.hintManager.RemoveHint(bathroomDoor);
		GameController.instance.hintManager.RemoveHint(cabinetDoor);
		GameController.instance.hintManager.RemoveHint(toilet);
		completedBathroomSetpiece = true;
		yield return Yield.WaitSeconds(husbandNewsClip.length);
	}

	private IEnumerator LighterCheck()
	{
		float hintTimer = Time.time + 15f;
		while (!lighter.isOn)
		{
			if (Time.time > hintTimer)
			{
				player.HandMenu.OpenStraightToBook(NotebookPages.Q08);
				player.watch.WatchHintWithSFX(5f, SFXAlertType.ALERT);
				break;
			}
			yield return null;
		}
	}

	private IEnumerator CribBaby()
	{
		UnityEngine.Debug.Log("Baby NOT in Crib");
		while (!seenBathroomAbyzu)
		{
			yield return null;
		}
		if (baby.activeInHierarchy)
		{
			baby.SetActive(value: false);
			cribSheet.SetActive(value: false);
			cribSheetMessy.SetActive(value: true);
		}
		GameController.instance.hintManager.AddHint(crib);
		mobileAudio.FadeIn(mobileLoop, 1f, 2f, loop: true);
		seenCrib = false;
		cribSightTrigger.SetActive(value: true);
		while (!seenCrib)
		{
			yield return null;
		}
		dollHouse.TurnOffLight();
		GameController.instance.hintManager.RemoveHint(crib);
		stairsDoor.CloseDoor(0f, 1f, lockAfter: true, resetPosition: true);
		room_Downstairs.UpdateColliders(enabled: true);
		dollHouseFront.CloseDoor(0f, 1f, lockAfter: false);
		chairAnim.enabled = true;
		chairMannequin.SetActive(value: true);
		chairAnim.SetFloat("Speed", 1f);
		StartCoroutine(KillMobileMusic(6f));
		yield return Yield.WaitSeconds(1.5f);
		GameController.instance.hintManager.AddHint(screen);
		rockingChairLight.Fade(on: true, 1f);
		floatingAudio01.gameObject.transform.position = floatingAudioPositions[1].position;
		floatingAudio01.PlayLoop(rockingChairClip, 0.6f);
		floatingAudioWomen.gameObject.transform.position = floatingAudioPositions[1].position;
		floatingAudioWomen.Play(womenChairClip);
		yield return Yield.WaitSeconds(womenChairClip.length);
	}

	private IEnumerator KillMobileMusic(float killTime)
	{
		for (float pitch = 1f; pitch > 0.01f; pitch -= Time.deltaTime / killTime)
		{
			mobileAudio.m_AudioSource.pitch = pitch;
			mobileAudio.m_AudioSource.volume = pitch;
			yield return null;
		}
		mobileAudio.StopLoop();
		mobileAudio.m_AudioSource.pitch = 1f;
		mobileAudio.m_AudioSource.volume = 1f;
	}

	private IEnumerator Closet()
	{
		UnityEngine.Debug.Log("Closet");
		inCloset = false;
		behindScreenTrigger.SetActive(value: true);
		chairSightTrigger.SetActive(value: true);
		float delay = 8f;
		float delayTime = Time.time + delay;
		bool playFirstClip = true;
		while (!seenEmptyChair)
		{
			if (Time.time > delayTime)
			{
				if (playFirstClip)
				{
					floatingAudioWomen.Play(womenChairClipCloser1, 0.7f);
					HUD.Instance.PlaySubtitles(womenChairClipCloser1.name, hasPriority: true);
					playFirstClip = false;
					delay = 12f;
					delayTime = Time.time + delay;
				}
				else
				{
					floatingAudioWomen.Play(womenChairClipCloser2, 0.7f);
					HUD.Instance.PlaySubtitles(womenChairClipCloser1.name, hasPriority: true);
					playFirstClip = true;
					delayTime = Time.time + delay;
				}
			}
			yield return null;
		}
		secretDoorHide.SetActive(value: false);
		secretDoorUnHide.SetActive(value: true);
		secretDoor.enabled = false;
		GameController.instance.audioController.PlayBadSting(STINGS_BAD.BAD_SOFT_STING_03);
		GameController.instance.audioController.persistentMusicPlayer.FadeIn(music_CelloBed, 0.1f, 3f, loop: true);
		closetClothes.SetActive(value: false);
		GameController.instance.hintManager.RemoveHint(screen);
		while (floatingAudioWomen.m_AudioSource.isPlaying)
		{
			yield return null;
		}
		yield return Yield.WaitSeconds(3f);
		floatingAudio01.FadeOut(2f);
		chairAnim.SetTrigger("Stand");
		floatingAudioWomen.Play(womenSeenChairClip[0], 0.6f);
		HUD.Instance.PlaySubtitles(womenSeenChairClip[0].name, hasPriority: true);
		lookingForSecrets = true;
		yield return Yield.WaitSeconds(womenSeenChairClip[0].length);
		room_Mothers.associatedParentGameObject.SetActive(value: true);
		floatingAudio01.gameObject.transform.position = closetDoor.transform.position;
		floatingAudioWomenFinal.gameObject.transform.position = closetDoor.transform.position;
		floatingAudioWomenFinal.Play(womenSeenChairClip[1], 0.6f);
		awayFromChairTrigger.SetActive(value: true);
		closetClothesSightTrigger.SetActive(value: true);
		StartCoroutine(removeAbyzouShadow());
		if (closetDoor.transform.parent.eulerAngles.y < 330f)
		{
			closetDoor.GetComponentInParent<Rigidbody>().AddForce(new Vector3(15f, 0f, 0f), ForceMode.Impulse);
			floatingAudio01.Play(doorCreakClip);
		}
		else
		{
			closetDoor.GetComponentInParent<Rigidbody>().AddForce(new Vector3(0f, 0f, 15f), ForceMode.Impulse);
			floatingAudio01.Play(doorCreakClip);
		}
		floatingAudio01.gameObject.transform.position = floatingAudioPositions[2].position;
		while (!inCloset)
		{
			yield return null;
		}
		NVRInteractableItem[] clothes = closetClothesInteractablePivot.GetComponentsInChildren<NVRInteractableItem>();
		NVRInteractableItem[] array = clothes;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].CanAttach = false;
		}
		while (!lookingAtClothes)
		{
			yield return Yield.EndOfFrame;
		}
		closetClothesSightTrigger.SetActive(value: false);
		yield return Yield.WaitSeconds(0.1f);
		LeanTween.moveLocalZ(closetClothesInteractablePivot, 1.895f, slidingClothesRackSFX.length).setEase(LeanTweenType.easeOutQuint);
		floatingAudio01.gameObject.transform.position = floatingAudioPositions[2].position;
		floatingAudio01.Play(slidingClothesRackSFX);
		yield return Yield.WaitSeconds(slidingClothesRackSFX.length);
		array = clothes;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].CanAttach = true;
		}
		cribLight.light.shadowResolution = LightShadowResolution.Low;
		GameController.instance.audioController.persistentMusicPlayer.FadeVolumeIn(1f, 0.3f);
		chairMannequin.SetActive(value: false);
		secretDoor.enabled = true;
	}

	private IEnumerator removeAbyzouShadow()
	{
		while (!lookingAwayFromChair)
		{
			yield return null;
		}
		if (rockingChairLight.gameObject.activeInHierarchy)
		{
			rockingChairLight.Fade(on: false, 0.3f);
		}
		else
		{
			rockingChairLight.gameObject.SetActive(value: false);
		}
		chairMannequin.SetActive(value: false);
	}

	private IEnumerator ShowPetals()
	{
		float delay = 2f;
		GameObject[] array = petalHints;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(value: true);
			yield return Yield.WaitSeconds(delay);
		}
	}

	private IEnumerator MothersRoom()
	{
		UnityEngine.Debug.Log("Mothers Room");
		room_Mothers.associatedParentGameObject.SetActive(value: true);
		mothersRoomRoutine = true;
		GameController.instance.hintManager.AddHint(secretDoor);
		while (!room_Mothers.playerInRoom)
		{
			yield return null;
		}
		musicPlayer.Play(music_MumsRoomEnter, 0.6f);
		GameController.instance.audioController.persistentMusicPlayer.FadeOut(5f);
		GameController.instance.hintManager.RemoveHint(secretDoor);
		GameController.instance.hintManager.AddHint(motherPoster);
		floatingAudioHusband.gameObject.transform.position = floatingAudioPositions[11].position;
		floatingAudioWomenFinal.gameObject.transform.position = floatingAudioPositions[10].position;
		while (Vector3.Distance(player.Head.transform.position, posterTrigger.transform.position) > 1.5f)
		{
			yield return null;
		}
		motherCrySource.SetMixerChannel(AudioScript.MixerChannel.effects);
		motherCrySource.FadeIn(motherCryLoop, 0.45f, 2f, loop: true);
		maggotPictureSource.FadeIn(maggotsLoop, 0.05f, 1f, loop: true);
		lighterLookAt.gameObject.SetActive(value: true);
		NVRInteractableItem lighterInteractable = lighter.gameObject.GetComponent<NVRInteractableItem>();
		while (!lighterLookAt.hoveringOverPoster || !lighter.isOn || !lighterInteractable.IsAttached)
		{
			yield return null;
		}
		GameController.instance.hintManager.RemoveHint(motherPoster);
		lighter.infiniteMode = true;
		musicPlayer.FadeOut(2f);
		GameController.instance.audioController.persistentMusicPlayer.Play(music_MumsRoomBuild);
		floatingAudioHusband.Play(husbandBathroomConvo1, 0.8f);
		floatingAudioWomenFinal.Play(womenBathroomConvo1, 0.5f);
		StartCoroutine(BlendPoster(18f));
		float snakeTime = Time.time + 8f;
		float handle1Time = Time.time + 12f;
		float handle2Time = Time.time + 14.5f;
		float finishTime = Time.time + 27f;
		LeanTween.moveLocalY(maggotGroup, 0.001f, 14f);
		maggotPictureSource.FadeVolumeIn(14f, 0.6f);
		while (Time.time < snakeTime)
		{
			yield return null;
		}
		snake_Poster2.SetActive(value: true);
		snake_Poster1.SetActive(value: true);
		while (Time.time < handle1Time)
		{
			yield return null;
		}
		floatingAudioHusband.transform.position = floatingAudioPositions[7].position;
		doorHandleFlashbackSource.PlayOne(ghostFoleyDoorHandleClip);
		HUD.Instance.PlaySubtitles(ghostFoleyDoorHandleClip.name, hasPriority: true);
		while (Time.time < handle2Time)
		{
			yield return null;
		}
		doorHandleFlashbackSource.PlayOne(ghostFoleyDoorHandleClip);
		HUD.Instance.PlaySubtitles(ghostFoleyDoorHandleClip.name, hasPriority: true);
		while (Time.time < finishTime)
		{
			yield return null;
		}
		lighter.DisableLighter(disable: true);
		yield return Yield.WaitSeconds(0.95f);
		lighter.infiniteMode = false;
		maggotPictureSource.StopLoop();
		yield return Yield.WaitSeconds(0.5f);
		maggotGroup.SetActive(value: false);
		posterRender.material = posterNormalMat;
		lighter.DisableLighter(disable: false);
		bathroomSideDoor.UnlockDoor();
		mothersRoomRoutine = false;
	}

	private IEnumerator BlendPoster(float time)
	{
		for (float t = 0f; t < 1f; t += Time.deltaTime / time)
		{
			posterMat.SetFloat("_AlbedoSlider", t);
			yield return null;
		}
		posterMat.SetFloat("_AlbedoSlider", 1f);
	}

	private IEnumerator Bathroom()
	{
		UnityEngine.Debug.Log("Bathroom");
		GameController.instance.hintManager.AddHint(bathroomSideDoor);
		floatingAudioWomen.gameObject.transform.position = floatingAudioPositions[13].position;
		floatingAudioWomenFinal.gameObject.transform.position = floatingAudioPositions[13].position;
		bathroomWallSolid.SetActive(value: false);
		yield return null;
		bathroomWallDoor.SetActive(value: true);
		pregTest.gameObject.SetActive(value: false);
		pregTestBox.gameObject.SetActive(value: false);
		bathroomSideDoorHide.SetActive(value: true);
		bathWaterDrip.SetActive(value: true);
		bathWater.SetActive(value: true);
		booze.gameObject.SetActive(value: true);
		razor1.gameObject.SetActive(value: true);
		razor2.gameObject.SetActive(value: true);
		tableSuicide.SetActive(value: true);
		dollHouse.TurnOffLight();
		bathroomTrigger.SetActive(value: true);
		while (!playerEnteredBathroom)
		{
			if (room_Mothers.playerInRoom && !player.boundDetection.outOfBounds)
			{
				playerInMothersRoom = true;
			}
			else if (room_MainLoft.playerInRoom && !player.boundDetection.outOfBounds)
			{
				playerInMothersRoom = false;
			}
			yield return null;
		}
		GameController.instance.hintManager.RemoveHint(bathroomSideDoor);
		GameController.instance.audioController.PlayBadSting(STINGS_BAD.BAD_SOFT_STING_02);
		motherCrySource.SetMixerChannel(AudioScript.MixerChannel.sfx);
		bathroomSideDoor.CloseDoor(0f, 0.2f);
		yield return Yield.WaitSeconds(0.2f);
		bathroomSideDoor.ManuallyUpdateOOBs();
		bathroomDoor.CloseDoor(-178.8f, 0.2f);
		yield return Yield.WaitSeconds(0.2f);
		bathroomDoor.ManuallyUpdateOOBs();
		pregTube.gameObject.SetActive(value: false);
		standingMirror.SetActive(value: false);
		lighter.infiniteMode = true;
		StartCoroutine(LoopingConvo());
		GameController.instance.hintManager.AddHint(tableSuicideHint);
		while (!foundRazor)
		{
			yield return null;
		}
		GameController.instance.hintManager.RemoveHint(tableSuicideHint);
		motherCrySource.StopLoop();
		bathWaterDrip.SetActive(value: false);
		yield return Yield.WaitSeconds(1f);
		floatingAudio01.gameObject.transform.position = tableSuicide.transform.position;
		floatingAudio01.Play(wineSmashClip);
		yield return Yield.WaitSeconds(1f);
		musicPlayer.Play(music_BathroomReveal);
		bathBloodDrip.SetActive(value: true);
		StartCoroutine(ChangeBathWater(8f));
		yield return Yield.WaitSeconds(1f);
		floatingAudioHusband.Play(husbandBathroomConvo3);
		HUD.Instance.PlaySubtitles(husbandBathroomConvo3.name, hasPriority: true);
		yield return Yield.WaitSeconds(3f);
		LeanTween.move(floatingAudioHusband.gameObject, bathBloodDrip.transform.position, 2f);
		yield return Yield.WaitSeconds(3f);
		snake_Bath.SetActive(value: true);
		yield return null;
		snake_Bath.GetComponent<SnakeMovement>().snakeAudio.PlayLoop(snakeSloshLoop);
		yield return Yield.WaitSeconds(16f);
		bathBloodDrip.SetActive(value: false);
		snake_Bath.GetComponent<SnakeMovement>().snakeAudio.FadeOut(2f);
		LeanTween.moveY(snake_Bath, snake_Bath.transform.position.y - 0.17f, bathDrainClip.length - 2f);
		StartCoroutine(RemoveSnake(bathDrainClip.length - 2f));
		LeanTween.moveY(bathWater, bathWater.transform.position.y - 0.1002f, bathDrainClip.length);
		bathDripSource.Play(bathDrainClip);
		yield return Yield.WaitSeconds(2f);
		floatingAudioWomenFinal.Play(womenBathroomConvo3[0], 0.7f);
		HUD.Instance.PlaySubtitles(womenBathroomConvo3[0].name, hasPriority: true);
		yield return Yield.WaitSeconds(6.5f);
		Renderer rend = bathWater.GetComponent<Renderer>();
		UnityEngine.Color col = rend.material.color;
		for (float alpha = 1f; alpha > 0.01f; alpha -= Time.deltaTime / 1.5f)
		{
			col.a = alpha;
			rend.material.color = col;
			yield return null;
		}
		yield return Yield.WaitSeconds(0.5f);
		bathWater.SetActive(value: false);
		lighter.infiniteMode = false;
		dollHouse.ChangeState(3);
		dollHouseFront.OpenDoorInstant(-150f);
		bathroomDoor.UnlockDoor();
		bathroomDoor.PlayClip(bathroomDoorUnlockClip, 1f);
		yield return null;
		floatingAudioWomenFinal.Play(womenBathroomConvo3[1], 0.7f);
	}

	private IEnumerator RemoveSnake(float removeAfterTime)
	{
		yield return Yield.WaitSeconds(removeAfterTime);
		snake_Bath.SetActive(value: false);
	}

	private IEnumerator LoopingConvo()
	{
		float delay = 14f;
		while (!foundRazor)
		{
			floatingAudioHusband.Play(husbandBathroomConvo2[0]);
			HUD.Instance.PlaySubtitles(husbandBathroomConvo2[0].name, hasPriority: true);
			yield return Yield.WaitSeconds(husbandBathroomConvo2[0].length + 6f);
			if (!foundRazor)
			{
				floatingAudioWomenFinal.Play(womenBathroomConvo2[0], 0.6f);
				yield return Yield.WaitSeconds(womenBathroomConvo2[0].length + 6f);
				if (!foundRazor)
				{
					floatingAudioHusband.Play(husbandBathroomConvo2[1]);
					yield return Yield.WaitSeconds(husbandBathroomConvo2[1].length + delay);
					if (!foundRazor)
					{
						floatingAudioWomenFinal.Play(womenBathroomConvo2[1], 0.6f);
						yield return Yield.WaitSeconds(womenBathroomConvo2[1].length + delay);
						if (!foundRazor)
						{
							floatingAudioHusband.Play(husbandBathroomConvo2[2]);
							yield return Yield.WaitSeconds(husbandBathroomConvo2[2].length + delay);
							if (!foundRazor)
							{
								floatingAudioWomenFinal.Play(womenBathroomConvo2[2], 0.6f);
								yield return Yield.WaitSeconds(womenBathroomConvo2[2].length + delay);
								if (!foundRazor)
								{
									floatingAudioHusband.Play(husbandBathroomConvo2[3]);
									yield return Yield.WaitSeconds(husbandBathroomConvo2[3].length + delay);
									if (!foundRazor)
									{
										floatingAudioWomenFinal.Play(womenBathroomConvo2[3], 0.6f);
										yield return Yield.WaitSeconds(womenBathroomConvo2[3].length + delay);
										if (foundRazor)
										{
											break;
										}
										continue;
									}
									break;
								}
								break;
							}
							break;
						}
						break;
					}
					break;
				}
				break;
			}
			break;
		}
	}

	private IEnumerator ChangeBathWater(float time)
	{
		Renderer rend = bathWater.GetComponent<Renderer>();
		UnityEngine.Color col = rend.material.color;
		for (float alpha = 0f; alpha < 1f; alpha += Time.deltaTime / time)
		{
			col.a = alpha;
			rend.material.color = col;
			yield return null;
		}
		for (int i = 0; i < bathMeshRenderer.Length; i++)
		{
			bathMeshRenderer[i].material = bloodyBathWaterMaterial;
		}
	}

	private IEnumerator IntoMirrorWorld()
	{
		UnityEngine.Debug.Log("Mirror World");
		baby.SetActive(value: false);
		cribSheet.SetActive(value: false);
		cribSheetMessy.SetActive(value: true);
		Vector3 localPosition = mobile.transform.localPosition;
		localPosition.y = 3.1f;
		mobile.transform.localPosition = localPosition;
		GameController.instance.hintManager.AddHint(mirrorPortal);
		mirrorPortal.SetActive(value: true);
		mirrorworldNoneBakedLightingRoom.SetActive(value: true);
		mirrorworldRoom.SetActive(value: true);
		navBlock_MirrorBack.SetActive(value: true);
		exorciseBabyInMirrorTrigger.SetActive(value: true);
		mirrorWorldCribBaby.transform.position = babySitTransform.position;
		mirrorWorldCribBaby.transform.rotation = babySitTransform.rotation;
		mirrorWorldCribBaby.SetActive(value: true);
		mirrorWorldCribBabyAnim.SetTrigger("SitIdle");
		mirrorWorldCribBabyEyeRenderer.sharedMaterial.SetColor("_EmissionColor", demonEyeColor);
		mirrorPortalCameraScript.portalCamera.gameObject.SetActive(value: true);
		mirrorPortalCameraScript.setStandardLayerMask();
		babySightTrigger.SetActive(value: true);
		mirrorBabyTrigger.SetActive(value: true);
		crossSelected = false;
		inExorciseBabyInMirrorArea = false;
		while (GameController.instance.currentRoom == room_Bathroom)
		{
			yield return Yield.WaitSeconds(0.1f);
		}
		lighter.canTurnOnLight = false;
		if (lighter.isOn)
		{
			lighter.TurnOffLight();
		}
		bathroomDoor.LockDoor();
		mobileAudio.PlayLoop(mobileMirrorLoop);
		while (!lookingAtBabyInMirror || !crossSelected || !inExorciseBabyInMirrorArea)
		{
			yield return null;
		}
		GameController.instance.audioController.persistentMusicPlayer.FadeIn(music_highwire03BuildDist, 0.8f, 5f, loop: true);
		StartCoroutine(KillMobileMusic(5f));
		interactableCross.LockToHand(isLocked: true);
		tuneCross.SetSpotLightEnabled(enabled: false);
		StartCoroutine(PerformExorcism(ExorcismType.MIRROR));
		exorcismComplete = false;
		while (!exorcismComplete)
		{
			yield return null;
		}
		floatingAudioWomenFinal.Play(womenSnakeResponseClips[3]);
		HUD.Instance.PlaySubtitles(womenSnakeResponseClips[3].name, hasPriority: true);
		StartCoroutine(ShakeCamera());
		shakeAmount = 0.01f;
		babySightTrigger.SetActive(value: false);
		mirrorBabyTrigger.SetActive(value: false);
		mirrorWorldCribBabyAnim.SetTrigger("SitHeadTurn");
		floatingAudio01.transform.position = mirrorPortal.transform.position;
		floatingAudio01.PlayOne(babyNeckCrackClip, 0.9f);
		mirrorCribLight.StartBurst(9f, finishOn: false);
		demonParticleMask.GetComponent<ParticleSystem>().Play();
		yield return Yield.WaitSeconds(6f);
		StartCoroutine(FadeBabyEyes(2.75f));
		yield return Yield.WaitSeconds(1.75f);
		tuneCross.keepTheLightOn = true;
		interactableCross.LockToHand(isLocked: false);
		if (cross.activeInHierarchy)
		{
			if (player.LeftHand.CurrentlyInteracting == interactableCross)
			{
				player.LeftHand.ForceDropItem();
			}
			else if (player.RightHand.CurrentlyInteracting == interactableCross)
			{
				player.RightHand.ForceDropItem();
			}
			cameraShake = false;
			GameController.instance.audioController.persistentMusicPlayer.StopLoop();
			GameController.instance.audioController.PlayBadSting(STINGS_BAD.BAD_STING_05);
			interactableCross.CanAttach = false;
			interactableCross.inEnvironment = true;
			float time = 0.15f;
			LeanTween.move(interactableCross.gameObject, crossMirrorPoint1, time);
			yield return Yield.WaitSeconds(time);
			Rigidbody component = fakeCross.GetComponent<Rigidbody>();
			component.isKinematic = false;
			component.AddForce(new Vector3(-3f, 0f, 3f), ForceMode.Impulse);
			crossRemoval.transform.position = crossMirrorPoint1.position;
			crossRemoval.SetActive(value: true);
			yield return Yield.WaitSeconds(1.35f);
			tuneCross.keepTheLightOn = false;
			tuneCross.FadeLightTarget();
			fakeCross.transform.position = interactableCross.gameObject.transform.position;
			fakeCross.transform.rotation = interactableCross.gameObject.transform.rotation;
			interactableCross.gameObject.SetActive(value: false);
			fakeCross.SetActive(value: true);
		}
		tuneCross.TheLight(isEnabled: false);
		tuneCross.AreaLight(active: true);
		mirrorWorldCribBaby.SetActive(value: false);
		mirrorPortalTrigger.SetActive(value: true);
		mirrorPortalTeleportTrigger.SetActive(value: true);
		mirrorPortalNavBlock.SetActive(value: false);
		yield return Yield.WaitSeconds(1f);
		portalOOB.SetActive(value: true);
		floatingAudioWomenFinal.gameObject.transform.position = mirrorPortal.transform.position;
		floatingAudioWomenFinal.Play(womenMirrorResponseClips[0]);
		GameController.instance.audioController.persistentMusicPlayer.PlayLoop(music_highwire03Build, 0f);
		while (!inPortalTrigger)
		{
			if (inExorciseBabyInMirrorArea)
			{
				float num = Mathf.Clamp01(Vector3.Distance(player.Head.transform.position, mirrorPortal.transform.position));
				GameController.instance.audioController.persistentMusicPlayer.m_AudioSource.volume = 1f - num;
			}
			yield return null;
		}
		player.screenFX.Fade(UnityEngine.Color.black, 0f);
		player.mainCamera.cullingMask = mirrorWorldLayerMask;
		player.movement.DisableMovement();
		lighter.canTurnOnLight = true;
		if (lighter.isOn)
		{
			lighter.TurnOnLight();
		}
		GameController.instance.boundDetection.SwitchOffOOB();
		standardOOBsUpstairs.SetActive(value: false);
		mirrorWorldOOBs.SetActive(value: true);
		room_MainLoft.gameObject.SetActive(value: false);
		room_MirrorWorld.gameObject.SetActive(value: true);
		GameController.instance.currentRoom = room_MirrorWorld;
		room_MirrorWorld.UpdateColliders(enabled: false);
		room_MirrorWorld.associatedParentGameObject.SetActive(value: true);
		room_MirrorWorld.playerInRoom = true;
		room_MainLoft.UpdateColliders(enabled: false);
		room_MainLoft.associatedParentGameObject.SetActive(value: true);
		room_MainLoft.playerInRoom = false;
		mirrorPortalTrigger.SetActive(value: false);
		mirrorPortalTeleportTrigger.SetActive(value: false);
		player.SetPosition(playerStartPositionAfterPortal);
		GameObject[] array = objectsToDisableAfterMirrorWorld;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(value: false);
		}
		navBlock_MirrorBack.SetActive(value: false);
		exorciseBabyInMirrorTrigger.SetActive(value: false);
		for (int j = 0; j < mirrorWorldOOB.Length; j++)
		{
			mirrorWorldOOB[j].SetActive(value: true);
		}
		musicPlayer.PlayOne(music_mirrorEntrySting);
		yield return Yield.WaitSeconds(2f);
		portalOOB.SetActive(value: false);
		GameController.instance.hintManager.RemoveHint(mirrorPortal);
		foreach (NVRInteractable looseObject in LooseObjects)
		{
			if (!(player.LeftHand.CurrentlyInteracting == looseObject) && !(player.RightHand.CurrentlyInteracting == looseObject))
			{
				looseObject.gameObject.SetActive(value: false);
			}
		}
		mirrorWorldBack.SetActive(value: true);
		wallToTurnOff.SetActive(value: true);
		floatingAudio02.FadeOut(1f);
		DynamicGI.UpdateEnvironment();
		navBlock_Mirror.SetActive(value: true);
		navBlock_Nursery.SetActive(value: false);
		room_Bathroom.associatedParentGameObject.SetActive(value: false);
		room_Closet.SetActive(value: false);
		room_Mothers.associatedParentGameObject.SetActive(value: false);
		room_MainLoft.associatedParentGameObject.SetActive(value: false);
		room_Bathroom.gameObject.SetActive(value: false);
		room_Closet.gameObject.SetActive(value: false);
		room_Downstairs.gameObject.SetActive(value: false);
		room_Mothers.gameObject.SetActive(value: false);
		if (room_Downstairs.associatedParentGameObject.activeInHierarchy)
		{
			room_Downstairs.associatedParentGameObject.SetActive(value: true);
		}
		hellPortal.SetActive(value: true);
		mirrorPortal.SetActive(value: false);
		interactableCross.CanAttach = true;
		interactableCross.gameObject.transform.position = fakeCross.transform.position;
		interactableCross.gameObject.transform.rotation = fakeCross.transform.rotation;
		fakeCross.SetActive(value: false);
		tuneCross.TheLightFull();
		interactableCross.gameObject.SetActive(value: true);
		player.screenFX.Fade(UnityEngine.Color.clear, 0.3f);
		yield return Yield.WaitSeconds(0.3f);
		player.movement.EnableMovement();
		GameController.instance.boundDetection.SwitchOnOOB();
		GameController.instance.audioController.persistentMusicPlayer.StopLoop();
		while (interactableCross.inEnvironment)
		{
			yield return null;
		}
		while (!crossSelected)
		{
			yield return null;
		}
		tuneCross.TheLight(isEnabled: false);
		interactableCross.LockToHand(isLocked: true);
		lighter.canTurnOnLight = false;
		if (lighter.isOn)
		{
			lighter.TurnOffLight();
		}
		GameController.instance.hintManager.AddHint(cribMirror1);
		seenCrib = false;
		cribSightTrigger.SetActive(value: true);
		cribSightTrigger.transform.position = cribMirror1.transform.position;
		while (!seenCrib)
		{
			yield return null;
		}
		flippedObjects.SetActive(value: true);
		wallToTurnOff.SetActive(value: false);
		mannequinPath.SetActive(value: true);
		yield return Yield.WaitSeconds(0.75f);
		dollAnim.SetTrigger("Look");
		yield return Yield.WaitSeconds(1.25f);
		GameController.instance.audioController.PlayBadSting(STINGS_BAD.BAD_SOFT_STING_02, 0.8f);
		yield return Yield.WaitSeconds(0.5f);
		floatingAudio01.transform.position = floatingAudioPositions[12].position;
		floatingAudio01.Play(mamaClip, 0.3f);
		yield return Yield.WaitSeconds(1.5f);
		floatingAudioWomen.transform.position = demonBabyPos1.position + new Vector3(0f, 1.5f, 0f);
		floatingAudioWomen.Play(womenCribDollResponse);
		GameController.instance.hintManager.RemoveHint(cribMirror1);
	}

	private IEnumerator BabysFirstScamper()
	{
		demonBabyHideParticlesPos1.gameObject.SetActive(value: true);
		yield return Yield.WaitSeconds(0.5f);
		demonBabyAnim.SetTrigger("Crawl");
		LeanTween.move(demonBaby, demonBabyEndPos1, 3f);
		yield return Yield.WaitSeconds(2.5f);
		demonBabyHideParticlesEndPos1.gameObject.SetActive(value: true);
		yield return Yield.WaitSeconds(0.5f);
		demonBaby.SetActive(value: false);
	}

	private IEnumerator FirstMannequinExorcism()
	{
		UnityEngine.Debug.Log("First Mannequin Exorcism");
		mirrorWorldCribBabyEyeRenderer.sharedMaterial.SetColor("_EmissionColor", demonEyeColor);
		demonBaby.SetActive(value: true);
		demonBaby.transform.position = demonBabyPos1.position;
		demonBaby.transform.rotation = demonBabyPos1.rotation;
		triggerDemonBaby1 = false;
		demonBabyTrigger1.SetActive(value: true);
		while (!triggerDemonBaby1)
		{
			yield return null;
		}
		floatingAudio01.gameObject.transform.position = demonBabyPos1.position;
		floatingAudio01.gameObject.transform.parent = demonBaby.transform;
		floatingAudio01.Play(babyCrawlClip, 0.8f);
		StartCoroutine(BabysFirstScamper());
		snake_Mannequin1.SetActive(value: true);
		exorcismComplete = false;
		StartCoroutine(PerformExorcism(ExorcismType.FIRST_MANNEQUIN));
		GameController.instance.hintManager.AddHint(mannequinBlock1);
		while (!exorcismComplete)
		{
			yield return null;
		}
		GameController.instance.hintManager.RemoveHint(mannequinBlock1);
		floatingAudio02.transform.position = mannequinBlock1.transform.position + new Vector3(0f, 1f, 0f);
		floatingAudio02.Play(pazuzuHiss);
		GameController.instance.audioController.persistentMusicPlayer.FadeIn(music_highwire03Build, 0.2f, 5f, loop: true);
		StartCoroutine(Dissolve(3, 1f, 1.5f, snake_Mannequin1));
		yield return Yield.WaitSeconds(2.6f);
		mannequinBlock1Mesh.material = manniquinDissolveMat1;
		StartCoroutine(Dissolve(1, 3.25f, 0.75f, mannequinBlock1));
		yield return Yield.EndOfFrame;
		mannequinParticles1.transform.SetParent(mirrorworldNoneBakedLightingRoom.transform, worldPositionStays: true);
		mannequinParticles1.Play();
		yield return Yield.WaitSeconds(2f);
		tuneCross.FadeLightTarget(2f);
		yield return Yield.WaitSeconds(3f);
		mannequinBlock1.SetActive(value: false);
	}

	private IEnumerator SecondMannequinExorcism()
	{
		UnityEngine.Debug.Log("Second Mannequin Exorcism");
		snake_Mannequin2.SetActive(value: true);
		StartCoroutine(DemonBabySetPiece());
		exorcismComplete = false;
		StartCoroutine(PerformExorcism(ExorcismType.SECOND_MANNEQUIN));
		GameController.instance.hintManager.AddHint(mannequinBlock2);
		while (!exorcismComplete)
		{
			yield return null;
		}
		GameController.instance.hintManager.RemoveHint(mannequinBlock2);
		floatingAudio02.transform.position = mannequinBlock2.transform.position + new Vector3(0f, 1f, 0f);
		floatingAudio02.Play(pazuzuHiss);
		GameController.instance.audioController.persistentMusicPlayer.FadeVolumeIn(3f, 0.5f);
		mirrorWorldCribBaby.transform.position = babyFinalCribPos.position;
		mirrorWorldCribBaby.transform.rotation = babyFinalCribPos.rotation;
		mirrorWorldCribBaby.SetActive(value: true);
		mirrorWorldCribBabyEyeRenderer.sharedMaterial.SetColor("_EmissionColor", demonEyeColor);
		mirrorWorldCribBabyAnim.SetTrigger("LayPain");
		StartCoroutine(Dissolve(4, 1f, 1.5f, snake_Mannequin2));
		yield return Yield.WaitSeconds(2.6f);
		mannequinBlock2Mesh.material = manniquinDissolveMat2;
		StartCoroutine(Dissolve(2, 3.25f, 0.75f, mannequinBlock2));
		yield return Yield.EndOfFrame;
		mannequinParticles2.transform.SetParent(mirrorworldNoneBakedLightingRoom.transform, worldPositionStays: true);
		mannequinParticles2.Play();
		yield return Yield.WaitSeconds(2f);
		tuneCross.FadeLightTarget(2f);
		yield return Yield.WaitSeconds(3f);
		mannequinBlock2.SetActive(value: false);
	}

	private IEnumerator BabyExorcism()
	{
		UnityEngine.Debug.Log("Baby Exorcism");
		snake_BabyNeck.SetActive(value: true);
		exorcismComplete = false;
		StartCoroutine(PerformExorcism(ExorcismType.BABY));
		GameController.instance.hintManager.AddHint(cribMirror2);
		while (tuneCross.currentTuneTarget < 1)
		{
			yield return null;
		}
		StartCoroutine(ShakeCamera());
		shakeAmount = 0.005f;
		particle_babyExPorgression01.gameObject.SetActive(value: true);
		while (tuneCross.currentTuneTarget < 2)
		{
			yield return null;
		}
		shakeAmount = 0.01f;
		particle_babyExPorgression02.gameObject.SetActive(value: true);
		while (!exorcismComplete)
		{
			yield return null;
		}
		player.movement.DisableMovement();
		GameController.instance.hintManager.RemoveHint(cribMirror2);
		mannequinPath.SetActive(value: false);
		tuneCross.ShootBeam(withAudio: true, disableLight: true, keepLockedToHand: true);
		babySound.audioScript.Play(babyChokeClip);
		musicPlayer.PlayOne(babyChokeMusicClip);
		babyExParticle.SetActive(value: true);
		mirrorWorldCribBabyAnim.SetTrigger("LaySnake");
		yield return Yield.WaitSeconds(1.5f);
		snake_MouthExit.SetActive(value: true);
		GameController.instance.audioController.persistentMusicPlayer.FadeOut(0.5f);
		yield return Yield.WaitSeconds(0.5f);
		StartCoroutine(FadeBabyEyes(2.5f));
		yield return Yield.EndOfFrame;
		StartCoroutine(Dissolve(6, 1f, 1.5f, snake_BabyNeck));
		particle_babyExPorgression01.Stop();
		particle_babyExPorgression02.Stop();
		yield return Yield.WaitSeconds(2.6f);
		cameraShake = false;
		StartCoroutine(Dissolve(7, 1f, 1.5f, snake_MouthExit));
		yield return Yield.WaitSeconds(3f);
		UnityEngine.Color color = default(UnityEngine.Color);
		ColorUtility.TryParseHtmlString("#FBF6D8", out color);
		player.screenFX.Fade(color, 0.5f);
		player.screenFX.BlurScreen(enabled: true);
		particle_babyExPorgression01.gameObject.SetActive(value: false);
		particle_babyExPorgression02.gameObject.SetActive(value: false);
		hellGatePortalCameraScript.setStandardLayerMask();
		yield return Yield.WaitSeconds(0.5f);
		babyExParticle.SetActive(value: false);
		mirrorWorldCribBabyAnim.SetTrigger("LayCry");
		possesedCribBabyAudio.volume = 0.55f;
		tuneCross.StopBackground();
		tuneCross.StopSFX();
		tuneCross.StopLightTarget();
		tuneCross.TheLight(isEnabled: false);
	}

	private IEnumerator FadeBabyEyes(float time)
	{
		_ = demonEyeColor;
		for (float t = 1f; t > 0f; t -= Time.deltaTime / time)
		{
			UnityEngine.Color value = new UnityEngine.Color(t, t, t, t);
			mirrorWorldCribBabyEyeRenderer.sharedMaterial.SetColor("_EmissionColor", value);
			yield return null;
		}
		mirrorWorldCribBabyEyeRenderer.sharedMaterial.SetColor("_EmissionColor", new UnityEngine.Color(0f, 0f, 0f, 0f));
	}

	private IEnumerator DemonBabySetPiece()
	{
		demonBaby.SetActive(value: true);
		demonBaby.transform.position = demonBabyPos2.position;
		demonBaby.transform.rotation = demonBabyPos2.rotation;
		demonBabyAnim.SetTrigger("RoofIdle");
		bool playedHint = false;
		demonBabyTrigger2.SetActive(value: true);
		demonBabySightTrigger2.SetActive(value: true);
		while (!sightTriggerDemonBaby2 || !triggerDemonBaby2)
		{
			if (!playedHint)
			{
				floatingAudio01.Play(snakeSounds[1]);
			}
			yield return null;
		}
		floatingAudio01.Play(babyRoofClip, 0.8f);
		demonBabyAnim.SetTrigger("RoofLook");
		yield return Yield.WaitSeconds(2f);
		demonBabyAnim.SetTrigger("CrawlRun");
		LeanTween.move(demonBaby, demonBabyEndPos2, 1.4f);
		yield return Yield.WaitSeconds(0.4f);
		demonBabyHideParticles.gameObject.SetActive(value: true);
		yield return Yield.WaitSeconds(1f);
		floatingAudio01.gameObject.transform.parent = null;
		demonBaby.SetActive(value: false);
	}

	private IEnumerator FinalExorcism()
	{
		UnityEngine.Debug.Log("Final Exorcism");
		tuneCross.SetSpotLightEnabled(enabled: true);
		tuneCross.SetPointLightEnabled(enabled: false);
		mirrorworldBakedLightingRoom.SetActive(value: true);
		mirrorworldNoneBakedLightingRoom.SetActive(value: false);
		navBlock_MirrorBaked.SetActive(value: true);
		GameController.instance.boundDetection.SwitchOffOOB();
		player.movement.ForceTeleport(new Vector3(player.transform.position.x, mirrorWorldBakedPlayerStart.position.y, player.transform.position.z));
		mirrorWorldCribBaby.transform.parent = mirrorworldBakedLightingRoom.transform;
		mirrorWorldCribBaby.transform.localPosition = babymirrorWorldBakedPosition.localPosition;
		yield return Yield.EndOfFrame;
		yield return Yield.WaitSeconds(0.25f);
		player.movement.EnableMovement();
		player.screenFX.Fade(UnityEngine.Color.clear, 0.75f);
		player.screenFX.BlurScreen(enabled: false);
		exorcismNavBlock.SetActive(value: true);
		hellGateRoom.SetActive(value: true);
		floatingAudioWomenFinal.gameObject.transform.position = hellPortal.transform.position;
		floatingAudioWomenFinal.Play(womenExoBabyResponse);
		mirrorShards.SetActive(value: true);
		abyzuReal.SetActive(value: true);
		abyzuHell.SetActive(value: true);
		Animator abyzuRealAnim = abyzuReal.GetComponent<Animator>();
		Animator abyzuHellAnim = abyzuHell.GetComponent<Animator>();
		abyzuRealAnim.SetTrigger("MirrorWait");
		abyzuHellAnim.SetTrigger("MirrorWait");
		hellGatePortalCameraScript.gameObject.SetActive(value: true);
		hellGatePortalCameraScript.setStandardLayerMask();
		abyzuSightTrigger.SetActive(value: true);
		lookingAtAbyzu = false;
		while (!lookingAtAbyzu)
		{
			yield return null;
		}
		GameController.instance.audioController.persistentMusicPlayer.FadeIn(music_highwire03BuildDist, 0.75f, 3f, loop: true);
		floatingAudio01.transform.position = hellPortal.transform.position;
		tuneCross.TheLightFull();
		tuneCross.StartSnakeExorcism(0.6f);
		tuneCross.ShootBeam(withAudio: true, disableLight: false, keepLockedToHand: true);
		exorcismSnakes.StartSnakes();
		StartCoroutine(ShakeCamera());
		shakeAmount = 0.0075f;
		int voCount = 0;
		while (exorcismSnakes.snakesHit < 5)
		{
			if (voCount == 0 && exorcismSnakes.snakesHit == 1)
			{
				if (floatingAudioWomenFinal.IsPlaying())
				{
					floatingAudioWomenFinal.FadeOut(0.25f);
					yield return Yield.WaitSeconds(0.25f);
				}
				abyzuHellAnim.SetTrigger("MirrorSmashSingle");
				abyzuRealAnim.SetTrigger("MirrorSmashSingle");
				yield return Yield.WaitSeconds(0.75f);
				mirrorAnim.SetTrigger("Smash1");
				floatingAudio01.Play(mirrorCrackClip[0]);
				particleMirrorSmashAbyzou.Play();
				yield return Yield.WaitSeconds(1f);
				voCount++;
				floatingAudioWomenFinal.Play(womenSnakeResponseClips[0]);
			}
			if (voCount == 1 && exorcismSnakes.snakesHit == 2)
			{
				abyzuHellAnim.SetTrigger("MirrorSmashSingle");
				abyzuRealAnim.SetTrigger("MirrorSmashSingle");
				yield return Yield.WaitSeconds(0.75f);
				mirrorAnim.SetTrigger("Smash2");
				floatingAudio01.Play(mirrorCrackClip[1]);
				particleMirrorSmashAbyzou.Play();
				yield return Yield.WaitSeconds(1f);
				voCount++;
				if (!floatingAudioWomenFinal.IsPlaying())
				{
					floatingAudioWomenFinal.Play(womenSnakeResponseClips[1]);
				}
			}
			if (voCount == 2 && exorcismSnakes.snakesHit == 3)
			{
				shakeAmount = 0.01f;
				abyzuHellAnim.SetTrigger("MirrorSmashDouble");
				abyzuRealAnim.SetTrigger("MirrorSmashDouble");
				yield return Yield.WaitSeconds(0.75f);
				mirrorAnim.SetTrigger("Smash3");
				floatingAudio01.Play(mirrorCrackClip[2]);
				particleMirrorSmashAbyzou.Play();
				yield return Yield.WaitSeconds(1f);
				voCount++;
				if (!floatingAudioWomenFinal.IsPlaying())
				{
					floatingAudioWomenFinal.Play(womenSnakeResponseClips[2]);
				}
			}
			if (voCount == 3 && exorcismSnakes.snakesHit == 4)
			{
				abyzuHellAnim.SetTrigger("MirrorSmashDouble");
				yield return Yield.WaitSeconds(0.75f);
				mirrorAnim.SetTrigger("Smash4");
				floatingAudio01.Play(mirrorCrackClip[3]);
				particleMirrorSmashAbyzou.Play();
				yield return Yield.WaitSeconds(1f);
				_ = Time.time;
				voCount++;
				if (!floatingAudioWomenFinal.IsPlaying())
				{
					floatingAudioWomenFinal.Play(womenSnakeResponseClips[3]);
					HUD.Instance.PlaySubtitles(womenSnakeResponseClips[3].name, hasPriority: true);
				}
			}
			yield return null;
		}
		if (floatingAudioWomenFinal.IsPlaying())
		{
			floatingAudioWomenFinal.FadeOut(0.25f);
			yield return Yield.WaitSeconds(0.25f);
		}
		mirrorAnim.SetTrigger("Smash5");
		floatingAudio01.Play(mirrorCrackClip[4]);
		yield return Yield.WaitSeconds(1f);
		shakeAmount = 0.02f;
		abyzuHellAnim.SetTrigger("MirrorWalk");
		abyzuRealAnim.SetTrigger("MirrorWalk");
		float time = Time.time;
		floatingAudioWomenFinal.Play(womenExoDeath);
		exorcismSnakes.StopSnake();
		if (!exorcismSnakes.DidReachCrib())
		{
			noSnakesinCrib = true;
		}
		if (Time.time - time < 8.5f)
		{
			yield return Yield.WaitSeconds(Time.time - time);
		}
		StartCoroutine(PerformExorcism(ExorcismType.ABYZU));
		while (!crossSelected)
		{
			yield return null;
		}
		exorcismComplete = false;
		while (!exorcismComplete)
		{
			yield return null;
		}
		cameraShake = false;
		babySound.audioScript.FadeOut(1f);
		tuneCross.ShootBeam(withAudio: true, disableLight: true, keepLockedToHand: true);
		mirrorAnim.SetTrigger("SmashFinal");
		abyzuHellAnim.SetTrigger("MirrorFinal");
		abyzuRealAnim.SetTrigger("MirrorFinal");
		floatingAudio01.transform.position = mirrorAnim.transform.position;
		floatingAudio01.Play(mirrorBreak);
		floatingAudioWomenFinal.Play(womenExoDeathNoooo);
		for (float wind2 = 0f; wind2 < 1f; wind2 += Time.deltaTime / 2f)
		{
			hellWind.windMain = wind2;
			yield return null;
		}
		particleMirrorSmashAbyzou.Play();
		GameController.instance.audioController.persistentMusicPlayer.StopLoop();
		hellSmokeFloor.Stop();
		hellGateSmoke.Stop();
		hellDust.Stop();
		allAudio = UnityEngine.Object.FindObjectsOfType(typeof(AudioSource)) as AudioSource[];
		SlowTime(0.25f);
		inSlowMo = true;
		for (float wind2 = 1f; wind2 > 0f; wind2 -= Time.deltaTime / 1f)
		{
			hellBackground.material.SetColor("_EmissionColor", new UnityEngine.Color(wind2, wind2, wind2, wind2));
			yield return null;
		}
		abyzuReal.SetActive(value: false);
		abyzuHell.SetActive(value: false);
		yield return Yield.WaitSeconds(0.2f);
		player.screenFX.Fade(UnityEngine.Color.black, 0.75f);
		GameController.instance.audioController.SnapMute(0.75f);
		yield return Yield.WaitSeconds(0.75f);
		tuneCross.StopBackground();
		tuneCross.StopSFX();
		tuneCross.StopLightTarget();
		tuneCross.TheLight(isEnabled: false);
		SlowTime(1f);
		inSlowMo = false;
		interactableCross.LockToHand(isLocked: false);
		if (player.LeftHand.CurrentlyInteracting == interactableCross)
		{
			player.LeftHand.ForceDropItem();
		}
		else if (player.RightHand.CurrentlyInteracting == interactableCross)
		{
			player.RightHand.ForceDropItem();
		}
		interactableCross.respawnTimer = 0.5f;
		while (!interactableCross.inKit)
		{
			yield return Yield.WaitSeconds(0.1f);
		}
		interactableCross.respawnTimer = 5f;
		yield return Yield.WaitSeconds(0.5f);
	}

	private IEnumerator PerformExorcism(ExorcismType type)
	{
		while (interactableCross.AttachedHand == null)
		{
			yield return null;
		}
		tuneCross.TheLight(isEnabled: true);
		switch (type)
		{
		case ExorcismType.BABY:
			tuneCross.StartTuning(exorcismTarget, exorcismTargetLocations, 8f, 30f, isSlowMo: false, 0.6f, 1f);
			while (!tuneCross.tuneSuccess)
			{
				yield return null;
			}
			mirrorWorldCribBaby.SetLayer(11);
			tuneCross.StartLightTarget(mirrorWorldCribBaby);
			while (!tuneCross.hitSuccess)
			{
				yield return null;
			}
			exorcismComplete = true;
			break;
		case ExorcismType.MIRROR:
			tuneCross.StartTuning(exorcismTarget, exorcismTargetLocationsMirror, 5f, 30f, isSlowMo: false, 0.6f);
			while (!tuneCross.tuneSuccess)
			{
				yield return null;
			}
			exorcismComplete = true;
			break;
		case ExorcismType.FIRST_MANNEQUIN:
			tuneCross.StartTuning(exorcismTarget, exorcismTargetLocationsFirstMannequin, 5f, 30f, isSlowMo: false, 0.4f, 1.25f);
			while (!tuneCross.tuneSuccess)
			{
				yield return null;
			}
			tuneCross.StartLightTarget(playerStartPosition);
			exorcismComplete = true;
			break;
		case ExorcismType.SECOND_MANNEQUIN:
			tuneCross.StartTuning(exorcismTarget, exorcismTargetLocationsSecondMannequin, 5f, 30f, isSlowMo: false, 0.4f, 1.25f);
			while (!tuneCross.tuneSuccess)
			{
				yield return null;
			}
			tuneCross.StartLightTarget(playerStartPosition);
			exorcismComplete = true;
			break;
		case ExorcismType.ABYZU:
			tuneCross.StartTuning(exorcismTarget, exorcismTargetLocationsAbyzu, 5f, 30f, isSlowMo: false, 0.6f);
			while (!tuneCross.tuneSuccess)
			{
				yield return null;
			}
			abyzuRayTarget.SetLayer(11);
			tuneCross.StartLightTarget(abyzuRayTarget);
			while (!tuneCross.hitSuccess)
			{
				yield return null;
			}
			exorcismComplete = true;
			break;
		}
	}

	private IEnumerator FinalSetPiece()
	{
		UnityEngine.Debug.Log("Final Set Piece");
		GameController.instance.boundDetection.SwitchOffOOB();
		standardOOBsUpstairs.SetActive(value: false);
		room_NurseryDay.gameObject.SetActive(value: true);
		room_MirrorWorld.gameObject.SetActive(value: false);
		GameController.instance.currentRoom = room_NurseryDay;
		GameController.instance.currentRoom.SubtractFromLayerMask("NurseryInteractive", setCamera: false);
		room_NurseryDay.UpdateColliders(enabled: false);
		room_NurseryDay.associatedParentGameObject.SetActive(value: true);
		room_NurseryDay.playerInRoom = true;
		room_MirrorWorld.UpdateColliders(enabled: false);
		room_MirrorWorld.associatedParentGameObject.SetActive(value: false);
		room_MirrorWorld.playerInRoom = false;
		room_MainLoft.UpdateColliders(enabled: false);
		room_MainLoft.associatedParentGameObject.SetActive(value: false);
		room_MainLoft.playerInRoom = false;
		birdSong.SetActive(value: true);
		player.movement.ForceTeleport(sunnyStart.transform.position);
		player.movement.DisableMovement();
		hellGateRoom.SetActive(value: false);
		mirrorworldBakedLightingRoom.SetActive(value: false);
		mirrorworldRoom.SetActive(value: false);
		GameController.instance.audioController.SnapAllOpen(3f);
		GameController.instance.audioController.persistentMusicPlayer.Play(music_endingPersist);
		tuneCross.AreaLight(active: false);
		yield return Yield.WaitSeconds(3f);
		player.screenFX.Fade(UnityEngine.Color.clear, 3f);
		GameController.instance.boundDetection.SwitchOnOOB();
		yield return Yield.WaitSeconds(11f);
	}

	private IEnumerator FadeOutScene()
	{
		UnityEngine.Debug.Log("Fading out scene");
		if (foundPregTest && foundPregTube && foundRazor && foundBook && (bool)pregTestBox)
		{
			foundGhostedItems = true;
		}
		GameController.instance.levelCompletionManager.SetLevelCompletionForNursery(foundGhostedItems, noSnakesinCrib, SaveManager.instance.HasFoundArtifact(ChapterID.NURSERY), completedLevel: true);
		GameController.instance.audioController.SnapMute(3f);
		player.screenFX.Fade(UnityEngine.Color.black, 3f);
		yield return Yield.WaitSeconds(3f);
		player.screenFX.SetStandardPostProcessingProfile();
		player.movement.EnableMovement();
		RenderSettings.skybox = null;
		DynamicGI.UpdateEnvironment();
		GameController.instance.boundDetection.SwitchOffOOB();
		GameController.instance.GoToSpecificScene(SCENES.PRECINCT, completedPrev: true);
	}

	private IEnumerator ShakeCamera()
	{
		cameraShake = true;
		_ = UnityEngine.Random.insideUnitSphere * shakeAmount;
		while (cameraShake)
		{
			Vector3 random = UnityEngine.Random.insideUnitSphere * shakeAmount;
			if (cameraShake)
			{
				player.transform.localPosition = player.transform.localPosition + random;
				yield return Yield.WaitSeconds(0.05f);
				if (cameraShake)
				{
					player.transform.localPosition = player.transform.localPosition - random;
					continue;
				}
				break;
			}
			break;
		}
	}

	private IEnumerator Dissolve(int objectReference, float burnTime, float dissolveTime, GameObject objToDisable)
	{
		Renderer rend = objectReference switch
		{
			1 => mannequinBlock1Mesh, 
			2 => mannequinBlock2Mesh, 
			3 => snake_Mannequin1Mesh, 
			4 => snake_Mannequin2Mesh, 
			5 => snake_BeamMesh, 
			6 => snake_BabyNeckMesh, 
			_ => snake_MouthExitMesh, 
		};
		for (float t3 = 0f; t3 < burnTime; t3 += Time.deltaTime)
		{
			if (rend == mannequinBlock1Mesh || rend == mannequinBlock2Mesh)
			{
				rend.material.SetFloat("_Amount", 1f / burnTime * t3);
			}
			else
			{
				rend.material.SetFloat("_Amount", 0.95f / burnTime * t3);
			}
			yield return Yield.EndOfFrame;
		}
		if (rend == mannequinBlock1Mesh || rend == mannequinBlock2Mesh)
		{
			rend.material.shader = questCheapBurnShaderPart2;
			for (float t3 = 0f; t3 < dissolveTime; t3 += Time.deltaTime)
			{
				rend.material.SetFloat("_Amount", 0.78f - 0.78f / dissolveTime * t3);
				yield return Yield.EndOfFrame;
			}
		}
		else
		{
			rend.material.shader = questBurnShaderPart2;
			for (float t3 = 0f; t3 < dissolveTime; t3 += Time.deltaTime)
			{
				rend.material.SetFloat("_Amount", Mathf.Clamp(0.95f - 0.55f / dissolveTime * t3, 0.4f, 0.95f));
				yield return Yield.EndOfFrame;
			}
		}
		objToDisable.SetActive(value: false);
	}

	private IEnumerator GoThroughSecretDoor()
	{
		inCloset = false;
		player.movement.DisableEverything();
		player.screenFX.Fade(UnityEngine.Color.black, 0.5f);
		yield return Yield.WaitSeconds(0.5f);
		secretDoor.GetComponent<AudioScript>().PlayOne(secretDoorSlideClip, 0.8f);
		yield return Yield.WaitSeconds(0.5f);
		player.movement.boundsDetection.TurnOffOOB(fadeScreen: false, enableMovement: false);
		GameController.instance.currentRoom = room_Mothers;
		room_Closet.SetActive(value: false);
		room_Mothers.UpdateColliders(enabled: false);
		room_Mothers.associatedParentGameObject.SetActive(value: true);
		room_Mothers.playerInRoom = true;
		room_MainLoft.UpdateColliders(enabled: true);
		room_MainLoft.associatedParentGameObject.SetActive(value: false);
		room_MainLoft.playerInRoom = false;
		player.movement.ForceTeleport(motherRoomStartPosition.transform.position);
		secretDoor.enabled = false;
		room_Bathroom.UpdateColliders(enabled: true);
		yield return Yield.WaitSeconds(1f);
		player.screenFX.Fade(UnityEngine.Color.clear, 2f);
		player.movement.EnableEverythingDelayed(2f);
		yield return Yield.WaitSeconds(1.25f);
		GameController.instance.boundDetection.SwitchOnOOB();
	}

	private IEnumerator FoundAretfact()
	{
		GameController.instance.audioController.PlayGoodSting(STINGS_GOOD.GOOD_CHOIR_STING_03, 0.75f);
		player.HandMenu.bookScript.updateMaxPage(14);
		player.HandMenu.OpenStraightToBookForArtefact(ArtefactType.SACRED_GROUND, NotebookPages.Q14);
		player.HandMenu.UpgradeSaltSprayer();
		yield return Yield.WaitSeconds(2f);
		player.watch.WatchHintWithSFX(5f, SFXAlertType.ALERT);
		StartCoroutine(RemoveArtifactFromUserHand());
	}

	private IEnumerator RemoveArtifactFromUserHand()
	{
		float counter = 0f;
		bool inHand = false;
		while (!player.HandMenu.bookScript.isActiveItem)
		{
			if (player.LeftHand.IsInteracting && player.LeftHand.CurrentlyInteracting.gameObject == sacredEarth)
			{
				inHand = true;
			}
			if (player.RightHand.IsInteracting && player.RightHand.CurrentlyInteracting.gameObject == sacredEarth)
			{
				inHand = true;
			}
			if (inHand)
			{
				counter = 0f;
				inHand = false;
			}
			else
			{
				counter += 1f;
			}
			if (counter > 2f)
			{
				break;
			}
			yield return Yield.WaitSeconds(1f);
		}
		if (player.LeftHand.IsInteracting)
		{
			if (player.LeftHand.CurrentlyInteracting != null && player.LeftHand.CurrentlyInteracting.gameObject == sacredEarth)
			{
				LeanTween.alpha(sacredEarth, 0f, 1f);
				player.LeftHand.ForceDropItem();
				yield return Yield.EndOfFrame;
				sacredEarth.SetActive(value: false);
				player.LeftHand.CurrentlyInteracting = null;
				yield return Yield.EndOfFrame;
				player.LeftHand.CurrentlyHoveringOver.Remove(sacredEarth.GetComponent<NVRInteractableItem>());
			}
		}
		else if (player.RightHand.IsInteracting)
		{
			if (player.RightHand.CurrentlyInteracting != null && player.RightHand.CurrentlyInteracting.gameObject == sacredEarth)
			{
				LeanTween.alpha(sacredEarth, 0f, 1f);
				player.RightHand.ForceDropItem();
				yield return Yield.EndOfFrame;
				sacredEarth.SetActive(value: false);
				player.RightHand.CurrentlyInteracting = null;
				yield return Yield.EndOfFrame;
				player.RightHand.CurrentlyHoveringOver.Remove(sacredEarth.GetComponent<NVRInteractableItem>());
			}
		}
		else
		{
			LeanTween.alpha(sacredEarth, 0f, 0.5f);
			yield return Yield.WaitSeconds(0.5f);
			sacredEarth.SetActive(value: false);
		}
		if (!GameController.instance.player.LeftHand.IsInteracting)
		{
			GameController.instance.player.LeftHand.SetAnimation("IdleBool");
		}
		if (!GameController.instance.player.RightHand.IsInteracting)
		{
			GameController.instance.player.RightHand.SetAnimation("IdleBool");
		}
	}

	private IEnumerator PianoNoise()
	{
		pianoNoiseCompleted = true;
		yield return Yield.WaitSeconds(2f);
		floatingAudio01.gameObject.transform.position = floatingHusbandPositions[0].position;
		floatingAudio01.Play(husbandComeDownClip);
		HUD.Instance.PlaySubtitles(husbandComeDownClip.name, hasPriority: true);
		yield return Yield.WaitSeconds(15f + husbandComeDownClip.length);
		toyPiano.PianoHit();
	}

	public void DownstairsDoorInteraction()
	{
		if (foundRazor)
		{
			return;
		}
		if (room_Downstairs.playerInRoom)
		{
			standardOOBsUpstairs.SetActive(value: true);
			standardOOBsDownstairs.SetActive(value: false);
			room_MainLoft.enabled = true;
			room_Mothers.enabled = true;
			room_Bathroom.enabled = true;
			player.playerLight.shouldLightBeOn = true;
			if (lighter.isOn)
			{
				lighter.TurnOnLight();
			}
			else
			{
				player.playerLight.PlayClick();
				playerLightFlicker.SwitchLight(switchOn: true);
			}
			lighter.canTurnOnLight = true;
			room_Closet.SetActive(value: true);
		}
		else
		{
			standardOOBsUpstairs.SetActive(value: false);
			standardOOBsDownstairs.SetActive(value: true);
			room_MainLoft.enabled = false;
			room_Mothers.enabled = false;
			room_Bathroom.enabled = false;
			player.playerLight.shouldLightBeOn = false;
			if (lighter.isOn)
			{
				lighter.TurnOffLight();
			}
			else
			{
				player.playerLight.PlayClick();
				playerLightFlicker.SwitchLight(switchOn: false);
			}
			lighter.canTurnOnLight = false;
		}
	}

	public void BathroomDoorInteraction()
	{
		if (!foundRazor && !enteredBathroomFirstTime)
		{
			player.playerLight.shouldLightBeOn = false;
			if (lighter.isOn)
			{
				lighter.TurnOnLight();
			}
			else
			{
				player.playerLight.PlayClick();
				playerLightFlicker.SwitchLight(switchOn: false);
			}
			lighter.canTurnOnLight = true;
			enteredBathroomFirstTime = true;
		}
		if (foundPregTest && !turnedDollHouseLightOn)
		{
			dollHouse.ChangeState(2);
			dollHouse.TurnOnLight();
			dollHouseTop.transform.parent.localEulerAngles = new Vector3(0f, 0f, 160f);
			dollHouseTop.transform.parent.GetComponent<JointReset>().UpdateTransform(Quaternion.Euler(0f, 0f, 160f), dollHouseTop.transform.parent.localPosition);
			dollHouseFront.CloseDoor(0f, 1f, lockAfter: false);
			turnedDollHouseLightOn = true;
		}
		if (room_Bathroom.playerInRoom)
		{
			room_Closet.SetActive(value: true);
		}
		else
		{
			room_Closet.SetActive(value: false);
		}
	}

	private void ToggleMirrorWorld(bool on)
	{
		if (on)
		{
			playerCamera.cullingMask |= 1 << LayerMask.NameToLayer("MirrorWorld");
		}
		else
		{
			playerCamera.cullingMask = ~(1 << LayerMask.NameToLayer("MirrorWorld"));
		}
	}

	private IEnumerator HandleTeleportIntoPortal()
	{
		while (player.movement.isTeleporting)
		{
			yield return Yield.WaitSeconds(0.1f);
		}
		while (player.screenFX.isFading)
		{
			yield return Yield.WaitSeconds(0.1f);
		}
		inPortalTrigger = true;
	}

	private void SlowTime(float newTime, float fadeTime = 0f)
	{
		for (int i = 0; i < allAudio.Length; i++)
		{
			allAudio[i].pitch = newTime;
		}
		Time.timeScale = newTime;
	}

	public override void BeginInteraction(NVRInteractable interactable)
	{
		if (interactable.gameObject.tag != "Fixture" && interactable.GetType() != typeof(ExorcismItem))
		{
			LooseObjects.Add(interactable);
		}
		if (interactable == popupBook && !foundBook)
		{
			foundBook = true;
			GameController.instance.audioController.PlayGoodSting(STINGS_GOOD.GOOD_SOFT_STING_01, 0.8f);
			GameController.instance.hintManager.RemoveHint(popupBook);
			toysnake.SetActive(value: true);
			toySnakeTrigger.SetActive(value: true);
		}
		if (!dollsHouseAchievementUnlocked)
		{
			dollsHouseAchievementUnlocked = dollHouse.recordInteractable(interactable.gameObject);
		}
		if ((interactable == dollHouseFront || interactable == dollHouseTop) && !completedBathroomSetpiece && !pianoNoiseCompleted)
		{
			StartCoroutine(PianoNoise());
		}
		if ((interactable == pregTest || interactable == pregTestBox) && !foundPregTest)
		{
			foundPregTest = true;
			GameController.instance.audioController.PlayGoodSting(STINGS_GOOD.GOOD_SOFT_STING_02, 0.8f);
			floatingAudio01.gameObject.transform.position = floatingHusbandPositions[2].position;
			floatingAudio01.Play(husbandNewsClip);
			HUD.Instance.PlaySubtitles(husbandNewsClip.name, hasPriority: true);
		}
		else if (interactable == pregTestBox)
		{
			foundPregTestBox = true;
		}
		else if (interactable == pregTube && !foundPregTube)
		{
			foundPregTube = true;
			GameController.instance.audioController.PlayGoodSting(STINGS_GOOD.GOOD_STING_02, 0.4f);
		}
		else if ((interactable == razor1 || interactable == razor2) && !foundRazor)
		{
			foundRazor = true;
		}
		else if (interactable == secretDoor && lookingForSecrets)
		{
			GameController.instance.audioController.PlayBadSting(STINGS_BAD.BAD_SOFT_STING_03);
			lookingForSecrets = false;
			if (inCloset)
			{
				StartCoroutine(GoThroughSecretDoor());
			}
		}
		else if (interactable == downstairsDoorKnob && foundRazor)
		{
			GameController.instance.achievementManager.UnlockAchievement(AchievementID.COWARD);
		}
		else if (interactable.gameObject == sacredEarth && !foundSacredEarth)
		{
			foundSacredEarth = true;
			StartCoroutine(FoundAretfact());
			SaveManager.instance.MarkArtifactFound(ChapterID.NURSERY);
		}
		else if (interactable.gameObject == toilet.gameObject)
		{
			toilet.gameObject.GetComponent<Tap>().ToggleInteraction();
		}
		else if (interactable.gameObject == tapBath.gameObject)
		{
			tapBath.gameObject.GetComponent<Tap>().ToggleInteraction();
		}
		else if (interactable.gameObject == tapSink.gameObject)
		{
			tapSink.gameObject.GetComponent<Tap>().ToggleInteraction();
		}
		if (cross != null && interactable.gameObject == cross)
		{
			crossSelected = true;
			interactableCross.inEnvironment = false;
		}
	}

	public override void EndInteraction(NVRInteractable interactable)
	{
		if (cross != null && interactable.gameObject == cross)
		{
			crossSelected = false;
		}
		if (interactable == babyDummy && Vector3.Distance(babyDummy.transform.position, babyDummyPos.position) < 0.1f)
		{
			babyDummy.CanAttach = false;
			UnityEngine.Object.Destroy(babyDummy.Rigidbody);
			babyDummy.transform.position = babyDummyPos.position;
			babyDummy.transform.rotation = babyDummyPos.rotation;
			babyDummy.transform.parent = babyDummyPos;
		}
	}

	public override void OnTriggerEnter(Collider collider)
	{
		if (!onStairs && collider.gameObject == stairsTrigger)
		{
			onStairs = true;
			stairsTrigger.SetActive(value: false);
		}
		else if (collider.gameObject == closetTrigger)
		{
			inCloset = true;
		}
		else if (collider.gameObject == behindScreenTrigger)
		{
			behindScreen = true;
		}
		else if (collider.gameObject == bathroomTrigger && !playerEnteredBathroom && playerInMothersRoom)
		{
			playerEnteredBathroom = true;
			bathroomTrigger.SetActive(value: false);
		}
		else if ((bool)collider.gameObject == inMirrorTrigger && !mirrorTransitionTrigger)
		{
			inMirrorTrigger = true;
			mirrorTransitionTrigger.SetActive(value: false);
		}
		else if (collider.gameObject == mirrorPortalTrigger)
		{
			inPortalTrigger = true;
			mirrorPortalTrigger.SetActive(value: false);
			mirrorPortalTeleportTrigger.SetActive(value: false);
		}
		else if (collider.gameObject == mirrorPortalTeleportTrigger)
		{
			mirrorPortalTrigger.SetActive(value: false);
			mirrorPortalTeleportTrigger.SetActive(value: false);
			StartCoroutine(HandleTeleportIntoPortal());
		}
		else if (collider.gameObject == demonBabyTrigger2)
		{
			triggerDemonBaby2 = true;
		}
		else if (collider.gameObject == toySnakeTrigger)
		{
			floatingAudio01.gameObject.transform.position = floatingAudioPositions[9].position;
			floatingAudio01.Play(snakeSqueakClip);
			toySnakeTrigger.SetActive(value: false);
		}
		else if (collider.gameObject == exorciseBabyInMirrorTrigger)
		{
			inExorciseBabyInMirrorArea = true;
		}
		if (collider.gameObject == portalOOB)
		{
			player.screenFX.Fade(UnityEngine.Color.black, 0f);
		}
	}

	public override void OnTriggerExit(Collider collider)
	{
		if (collider.gameObject == behindScreenTrigger)
		{
			behindScreen = false;
		}
		else if (collider.gameObject == closetTrigger)
		{
			inCloset = false;
		}
		else if (collider.gameObject == demonBabyTrigger2)
		{
			triggerDemonBaby2 = false;
		}
		else if (collider.gameObject == exorciseBabyInMirrorTrigger)
		{
			inExorciseBabyInMirrorArea = false;
		}
	}

	public override void OnSightTriggerEnter(Collider other)
	{
		if (other.gameObject == stairsSightTrigger && !lookedAtDoor)
		{
			lookedAtDoor = true;
			stairsSightTrigger.SetActive(value: false);
		}
		else if (other.gameObject == awayFromMirrorTrigger && !lookingAwayFromMirror)
		{
			lookingAwayFromMirror = true;
			awayFromMirrorTrigger.SetActive(value: false);
		}
		else if (other.gameObject == abyzuSightTrigger && !lookingAtAbyzu)
		{
			lookingAtAbyzu = true;
			abyzuSightTrigger.SetActive(value: false);
		}
		else if (other.gameObject == babySightTrigger)
		{
			seenMirrorTrigger1 = true;
			if (seenMirrorTrigger2)
			{
				lookingAtBabyInMirror = true;
			}
		}
		else if (other.gameObject == closetPosterTrigger && !seenClostPoster && inCloset)
		{
			seenClostPoster = true;
			closetPosterTrigger.SetActive(value: false);
			floatingAudio01.gameObject.transform.position = floatingHusbandPositions[1].position;
			floatingAudio01.Play(husbandParisClip);
			GameController.instance.hintManager.RemoveHint(closetDoor);
		}
		else if (other.gameObject == backBathroomWall && !seenBathroomAbyzu)
		{
			seenBathroomAbyzu = true;
			backBathroomWall.SetActive(value: false);
		}
		else if (other.gameObject == demonBabyTrigger1 && !triggerDemonBaby1)
		{
			triggerDemonBaby1 = true;
			demonBabyTrigger1.SetActive(value: false);
		}
		else if (other.gameObject == awayFromChairTrigger && !lookingAwayFromChair)
		{
			lookingAwayFromChair = true;
			awayFromChairTrigger.SetActive(value: false);
		}
		else if (other.gameObject == closetClothesSightTrigger)
		{
			lookingAtClothes = true;
		}
	}

	public override void OnSightTriggerStay(Collider other)
	{
		if (other.gameObject == cribSightTrigger && !seenCrib && Vector3.Distance(cribSightTrigger.transform.position, player.Head.gameObject.transform.position) < 1.25f)
		{
			seenCrib = true;
			cribSightTrigger.SetActive(value: false);
		}
		else if (other.gameObject == mirrorTrigger && !lookingInMirror && Vector3.Distance(mirrorTrigger.transform.position, player.Head.gameObject.transform.position) < 1f)
		{
			lookingInMirror = true;
			mirrorTrigger.SetActive(value: false);
		}
		else if (other.gameObject == chairSightTrigger && !seenEmptyChair && behindScreen)
		{
			seenEmptyChair = true;
			behindScreenTrigger.SetActive(value: false);
			chairSightTrigger.SetActive(value: false);
		}
		else if (other.gameObject == mirrorBabyTrigger)
		{
			seenMirrorTrigger2 = true;
			if (seenMirrorTrigger1)
			{
				lookingAtBabyInMirror = true;
			}
		}
		else if (other.gameObject == demonBabySightTrigger2 && !sightTriggerDemonBaby2)
		{
			sightTriggerDemonBaby2 = true;
			demonBabySightTrigger2.SetActive(value: false);
		}
		else if (other.gameObject == dollsHouseSightTrigger && Vector3.Distance(dollsHouseSightTrigger.transform.position, player.Head.gameObject.transform.position) < 1f && !foundDollHouse)
		{
			foundDollHouse = true;
			UnityEngine.Debug.Log("Found Dolls House");
			GameController.instance.hintManager.RemoveHint(dollHouseFront);
		}
		if ((bool)other.gameObject == triggerDemonBaby1 && !lookedAtFallingBlocks && Vector3.Distance(player.Head.transform.position, demonBabyTrigger1.transform.position) < 4f)
		{
			lookedAtFallingBlocks = true;
		}
	}

	public override void OnSightTriggerExit(Collider other)
	{
		if (other.gameObject == babySightTrigger)
		{
			seenMirrorTrigger1 = false;
		}
		else if (other.gameObject == mirrorBabyTrigger)
		{
			seenMirrorTrigger2 = false;
		}
		else if (other.gameObject == closetClothesSightTrigger)
		{
			lookingAtClothes = false;
		}
	}

	private void RestartLevel()
	{
		StartCoroutine(RestartLevelRoutine());
	}

	private IEnumerator RestartLevelRoutine()
	{
		lighter.infiniteMode = false;
		tuneCross.AreaLight(active: false);
		tuneCross.StopBackground();
		tuneCross.StopSFX();
		tuneCross.StopLightTarget();
		tuneCross.TheLight(isEnabled: false);
		player.fishEyeFX.strengthX = 0f;
		player.fishEyeFX.enabled = false;
		if (inSlowMo)
		{
			SlowTime(1f);
		}
		interactableCross.CanAttach = true;
		interactableCross.gameObject.SetActive(value: true);
		interactableCross.LockToHand(isLocked: false);
		if (player.LeftHand.CurrentlyInteracting == interactableCross)
		{
			player.LeftHand.ForceDropItem();
		}
		else if (player.RightHand.CurrentlyInteracting == interactableCross)
		{
			player.RightHand.ForceDropItem();
		}
		StartCoroutine(interactableCross.RespawnItem(0.1f));
		GameController.instance.audioController.persistentMusicPlayer.StopLoop();
		if (interactableCross.inEnvironment)
		{
			interactableCross.inEnvironment = false;
			UnityEngine.Object.DontDestroyOnLoad(cross);
		}
		player.screenFX.Fade(UnityEngine.Color.black, 3f);
		yield return Yield.WaitSeconds(3f);
		player.MoveToSafeZone();
		player.ResetCullingMask();
	}

	public void ExitToPrecinct()
	{
		StartCoroutine(ExitToPrecinctRoutine());
	}

	public IEnumerator ExitToPrecinctRoutine()
	{
		lighter.infiniteMode = false;
		tuneCross.AreaLight(active: false);
		tuneCross.StopBackground();
		tuneCross.StopSFX();
		tuneCross.StopLightTarget();
		tuneCross.TheLight(isEnabled: false);
		PicoLight.enabled = false;
		player.fishEyeFX.strengthX = 0f;
		player.fishEyeFX.enabled = false;
		if (inSlowMo)
		{
			SlowTime(1f);
		}
		fakeCross.SetActive(value: false);
		interactableCross.CanAttach = true;
		interactableCross.gameObject.SetActive(value: true);
		interactableCross.LockToHand(isLocked: false);
		if (player.LeftHand.CurrentlyInteracting == interactableCross)
		{
			player.LeftHand.ForceDropItem();
		}
		else if (player.RightHand.CurrentlyInteracting == interactableCross)
		{
			player.RightHand.ForceDropItem();
		}
		interactableCross.respawnTimer = 0.5f;
		yield return Yield.WaitSeconds(0.5f);
		if (foundPregTest && foundPregTube && foundRazor && foundBook && (bool)pregTestBox)
		{
			foundGhostedItems = true;
		}
		RenderSettings.skybox = null;
		DynamicGI.UpdateEnvironment();
		GameController.instance.audioController.persistentMusicPlayer.StopLoop();
		if (interactableCross.inEnvironment)
		{
			interactableCross.inEnvironment = false;
			UnityEngine.Object.DontDestroyOnLoad(cross);
		}
		GameController.instance.levelCompletionManager.SetLevelCompletionForNursery(foundGhostedItems, noSnakesinCrib, SaveManager.instance.HasFoundArtifact(ChapterID.NURSERY), completedLevel: false);
		GameController.instance.audioController.SnapMute(3f);
		player.screenFX.Fade(UnityEngine.Color.black, 3f);
		yield return Yield.WaitSeconds(3f);
		player.screenFX.SetStandardPostProcessingProfile();
		player.ResetCullingMask();
		GameController.instance.boundDetection.SwitchOffOOB();
		GameController.instance.GoToSpecificScene(SCENES.PRECINCT);
	}

	private void ResetProgress()
	{
		lighter.infiniteMode = false;
		tuneCross.AreaLight(active: false);
		tuneCross.StopBackground();
		tuneCross.StopSFX();
		tuneCross.StopLightTarget();
		tuneCross.TheLight(isEnabled: false);
		player.fishEyeFX.strengthX = 0f;
		player.fishEyeFX.enabled = false;
		player.ResetCullingMask();
		if (interactableCross.inEnvironment)
		{
			interactableCross.inEnvironment = false;
			UnityEngine.Object.DontDestroyOnLoad(cross);
		}
	}

	private void OnDestroy()
	{
		EventManager.StopListening(EventManager.AvailableEvents.IntroComplete.ToString(), IntroCompleted);
		EventManager.StopListening(EventManager.AvailableEvents.ExitLevelToPrecint.ToString(), ExitToPrecinct);
		EventManager.StopListening(EventManager.AvailableEvents.RestartScene.ToString(), RestartLevel);
	}

	private void DebugCommands()
	{
		if (Input.GetKeyDown(KeyCode.O))
		{
			stairsDoor.OpenDoor(113f, 3f);
			bathroomDoor.OpenDoor(287f, 3f);
			bathroomSideDoor.OpenDoor(-130f, 3f);
		}
		else if (Input.GetKeyDown(KeyCode.C))
		{
			stairsDoor.CloseDoor(0f, 3f, lockAfter: false, resetPosition: true);
			bathroomDoor.CloseDoor(180f, 3f, lockAfter: false, resetPosition: true);
			bathroomSideDoor.CloseDoor(0f, 3f, lockAfter: false, resetPosition: true);
		}
		if (Input.GetKeyDown(KeyCode.H))
		{
			ToggleMirrorWorld(on: false);
		}
		else if (Input.GetKeyDown(KeyCode.S))
		{
			ToggleMirrorWorld(on: true);
		}
	}
}
public class OnboardingScene : InteractionManager
{
	private NVRPlayer player;

	private int debugCount;

	[Header("General")]
	[SerializeField]
	private GameObject playerStartPosition;

	[Space]
	[Header("Rooms")]
	[SerializeField]
	private Room mainRoom;

	[Space]
	[Header("Flow")]
	[SerializeField]
	private AudioScript speakerAudio;

	[SerializeField]
	private InteractiveDoor doorHandle;

	[SerializeField]
	private AudioScript doorAudioScript;

	[SerializeField]
	private AudioClip doorOpen;

	[SerializeField]
	private bool watchHintFired;

	[Space]
	[Header("Audio")]
	[SerializeField]
	private AudioClip welcomeVo;

	[SerializeField]
	private AudioClip menuVo;

	[SerializeField]
	private AudioClip openedMenuVo;

	[Space]
	[SerializeField]
	private Material boardMaterial;

	[SerializeField]
	private Texture boardQuest;

	[SerializeField]
	private Texture boardAltQuest;

	private bool alternateBoard;

	private bool exited;

	private bool movementUIVisible = true;

	private bool waitForPSVR;

	private void Start()
	{
		EventManager.StartListening(EventManager.AvailableEvents.ExitLevelToPrecint.ToString(), ExitToPrecinct);
		player = GameController.instance.player;
		player.SetPosition(playerStartPosition);
		if (player.movement != null)
		{
			player.movement.DisableEverything();
		}
		GameController.instance.hintManager.AddHint(doorHandle);
		player.screenFX.Fade(UnityEngine.Color.black, 0f);
		GameController.instance.audioController.SnapMute(0f);
		player.HandMenu.exKitScript.candle.GetComponent<ExorcismItem>().ForceSnapBack();
		StartCoroutine(Master());
	}

	private void Update()
	{
		if (player.HandMenu.IsActive)
		{
			if (watchHintFired)
			{
				watchHintFired = false;
				if ((bool)player.watch)
				{
					player.watch.CancelWatchHintWithSFX();
				}
				speakerAudio.PlayInQueue(openedMenuVo);
				HUD.Instance.PlaySubtitles(openedMenuVo.name, hasPriority: false);
			}
			if (movementUIVisible)
			{
				if (!player.RightHand.IsPrimary)
				{
					player.RightHand.movementUI.SetActive(value: false);
				}
				else
				{
					player.LeftHand.movementUI.SetActive(value: false);
				}
				movementUIVisible = false;
			}
		}
		else if (!movementUIVisible)
		{
			if (!player.RightHand.IsPrimary)
			{
				player.RightHand.movementUI.SetActive(value: true);
			}
			else
			{
				player.LeftHand.movementUI.SetActive(value: true);
			}
			movementUIVisible = true;
		}
		if ((ControlsManager.instance.menuButtonDown || ControlsManager.instance.secondaryMenuButtonDown) && !player.HandMenu.itemActive)
		{
			ToggleWhiteboard();
		}
	}

	private IEnumerator Master()
	{
		yield return StartCoroutine(FadeInScene());
		yield return LaunchTitles();
	}

	private IEnumerator FadeInScene()
	{
		boardQuest = GameController.instance.translator.GetTexture(boardQuest.name);
		boardMaterial.mainTexture = boardQuest;
		player.HandMenu.BookInMenu(active: false);
		player.HandMenu.KitInMenu(active: false);
		player.HandMenu.exKitScript.candle.GetComponent<OilLighter>().canTurnOnLight = false;
		GameController.instance.audioController.SnapAllOpen(3f);
		player.LeftHand.ToggleMovementUI();
		player.RightHand.ToggleMovementUI();
		player.LeftHand.ResetHandMaterial();
		player.RightHand.ResetHandMaterial();
		player.screenFX.Fade(UnityEngine.Color.clear, 3f);
		yield return Yield.WaitSeconds(3f);
		GameController.instance.currentRoom = mainRoom;
		GameController.instance.boundDetection.SwitchOnOOB();
		EventManager.TriggerEvent(EventManager.AvailableEvents.SwitchedScenes.ToString());
		player.movement.EnableEverything();
		StartCoroutine(OnBoardMenu());
		while (!exited)
		{
			yield return null;
		}
	}

	private IEnumerator OnBoardMenu()
	{
		speakerAudio.Play(welcomeVo);
		HUD.Instance.PlaySubtitles(welcomeVo.name, hasPriority: true);
		yield return Yield.WaitSeconds(welcomeVo.length);
		player.watch.WatchHintWithSFXStayLit(SFXAlertType.ALERT);
		yield return Yield.WaitSeconds(1f);
		speakerAudio.Play(menuVo);
		HUD.Instance.PlaySubtitles(menuVo.name, hasPriority: true);
		watchHintFired = true;
	}

	private IEnumerator LaunchTitles()
	{
		GameController.instance.hintManager.RemoveHint(doorHandle);
		StopCoroutine("OnBoardMenu");
		if ((bool)player.watch)
		{
			player.watch.CancelWatchHintWithSFX();
		}
		movementUIVisible = true;
		player.LeftHand.movementUI.SetActive(value: false);
		player.RightHand.movementUI.SetActive(value: false);
		player.screenFX.Fade(UnityEngine.Color.black, 3f);
		doorAudioScript.Play(doorOpen, 0.8f);
		GameController.instance.audioController.SnapMute(3f);
		yield return Yield.WaitSeconds(3f);
		GameController.instance.currentRoom = null;
		GameController.instance.boundDetection.SwitchOffOOB();
		GameController.instance.GoToSpecificScene(SCENES.TITLES);
	}

	private void OnDisable()
	{
		if ((bool)player.watch)
		{
			player.watch.CancelWatchHintWithSFX();
		}
	}

	private void ToggleWhiteboard()
	{
		alternateBoard = !alternateBoard;
		if (alternateBoard)
		{
			boardAltQuest = GameController.instance.translator.GetTexture(boardAltQuest.name);
			boardMaterial.mainTexture = boardAltQuest;
		}
		else
		{
			boardQuest = GameController.instance.translator.GetTexture(boardQuest.name);
			boardMaterial.mainTexture = boardQuest;
		}
	}

	public override void BeginInteraction(NVRInteractable interactable)
	{
		if (interactable.gameObject == doorHandle.gameObject)
		{
			exited = true;
		}
	}

	public void ExitToPrecinct()
	{
		GameController.instance.currentRoom = null;
		GameController.instance.boundDetection.SwitchOffOOB();
		GameController.instance.GoToSpecificScene(SCENES.PRECINCT);
	}
}
public class PersistentScene : MonoBehaviour
{
	private NVRPlayer player;

	private ScreenFX screenFX;

	[SerializeField]
	private SCENES sceneToLoad = SCENES.ONBOARDING;

	[Space]
	[SerializeField]
	private GameObject loadingBox;

	[SerializeField]
	private IntroSequence intro;

	private void Start()
	{
		EventManager.StartListening(EventManager.AvailableEvents.IntroComplete.ToString(), IntroComplete);
		StartCoroutine(WaitForLoad());
	}

	private IEnumerator WaitForLoad()
	{
		while (!SaveManager.instance.savedDataLoaded)
		{
			yield return null;
		}
		while (!GameController.instance.player)
		{
			yield return null;
		}
		while (screenFX == null)
		{
			screenFX = GameController.instance.player.Head.GetComponentInChildren<ScreenFX>();
			yield return null;
		}
		while (!screenFX.isInitialised)
		{
			yield return null;
		}
		if (XRDevice.model.IndexOf("oculus", StringComparison.CurrentCultureIgnoreCase) != -1)
		{
			OVRManager.eyeTextureFormat = OVRManager.EyeTextureFormat.R11G11B10_FP;
		}
		yield return Yield.WaitSeconds(10f);
		screenFX.Fade(UnityEngine.Color.black, 0f);
		GameController.instance.player.mainCamera.enabled = true;
		GameController.instance.boundDetection.SwitchOffOOB();
		GameController.instance.GoToSpecificScene(sceneToLoad);
	}

	public void LoadNewScene(SCENES newScene, SCENES prevScene, bool completedPrev)
	{
		GameController.instance.translator.ResetTranslationObjects();
		if (newScene != SCENES.TITLES)
		{
			SubtitleManager.Instance.InitForScene(newScene);
		}
		EventManager.TriggerEvent(EventManager.AvailableEvents.StartedLoading.ToString());
		loadingBox.SetActive(value: true);
		intro.PlayIntro(newScene, prevScene, completedPrev);
	}

	private void IntroComplete()
	{
		loadingBox.SetActive(value: false);
	}
}
public class PrecinctScene : InteractionManager
{
	private bool introComplete;

	private NVRPlayer player;

	private int debugCount;

	private Light playerLight;

	private Light PicoLight;

	[Header("Chapters")]
	[SerializeField]
	private ChapterManager chapterManager;

	[Header("General")]
	[SerializeField]
	private GameObject playerStartPosition;

	[SerializeField]
	private GameObject playerReturnPosition;

	[SerializeField]
	private AudioScript chiefsRoomAudioScript;

	[SerializeField]
	private AudioClip[] chiefsGreeting;

	[SerializeField]
	private GameObject[] godRays;

	[SerializeField]
	private AudioScript musicPlayer;

	[SerializeField]
	private Room roomCorridor;

	[SerializeField]
	private Room roomOffice;

	[SerializeField]
	private Room roomEvidence;

	[Header("Intro")]
	[SerializeField]
	private CoffeeMachine coffee;

	[Header("Achievements")]
	[SerializeField]
	private GameObject peaSoup;

	[SerializeField]
	private GameObject mansBestFriend;

	[Space]
	[Header("Rooms")]
	[SerializeField]
	private GameObject officeRoomDoor;

	[SerializeField]
	private InteractiveDoor officeRoomDoorInteractive;

	[SerializeField]
	private GameObject chiefsRoomDoor;

	[Space]
	[Header("Chapter 1")]
	[SerializeField]
	private PoliceRadio policeRadio;

	[SerializeField]
	private GameObject policeRadioStartPosition;

	[SerializeField]
	private AudioClip musicBed;

	[SerializeField]
	private GameObject tapePlayer;

	[Space]
	[Header("Chapter 2")]
	[SerializeField]
	private NVRInteractableItem amulet;

	[SerializeField]
	private GameObject amuletTraget;

	[SerializeField]
	private ParticleSystem amuletParticle;

	[SerializeField]
	private GameObject amuletParticleComplete;

	[SerializeField]
	private Material amuletMaterial;

	[SerializeField]
	private AudioClip[] chapter2CTA;

	[SerializeField]
	private AudioScript wallSpeaker;

	[Space]
	[Header("Chapter 3")]
	[SerializeField]
	private GameObject audioReelAbyzou74;

	[SerializeField]
	private GameObject audioReel;

	[SerializeField]
	private AudioReel audioReelPlayer;

	[Space]
	[Header("Chapter 4")]
	[SerializeField]
	private VHSPlayer vhsPlayer;

	[SerializeField]
	private GameObject cdPlayer;

	[SerializeField]
	private AudioCdPlayer audioCdPlayer;

	[Space]
	[Header("Other")]
	[SerializeField]
	private BustArtifact bustArtefact;

	[SerializeField]
	private GameObject holyWater;

	[SerializeField]
	private GameObject[] holyWaterCaps;

	[SerializeField]
	private GameObject chessboardBreifcaseTop;

	[SerializeField]
	private Chessboard chessboard;

	[SerializeField]
	private GameObject oilReward;

	[SerializeField]
	private AstrolabeArtefact sacredEarthArtefact;

	[SerializeField]
	private GameObject sacredEarth;

	[SerializeField]
	private PuzzleBoxArtifact puzzleBoxArtifact;

	[SerializeField]
	private GameObject celticCross;

	[SerializeField]
	private Animator upgradeAnimator;

	[SerializeField]
	private Beacon beacon;

	[SerializeField]
	private ReflectionProbe[] reflectionProbes;

	private bool foundAmulet;

	private bool foundHolyWater;

	private bool foundAretfactUpgrade;

	private bool foundSacredEarth;

	private bool foundCelticCross;

	private bool crossSelected;

	private GameObject cross;

	private TuneController tuneCross;

	private ExorcismItem interactableCross;

	private bool exorcismComplete;

	private bool chiefsIgnoringYou;

	private bool loading;

	private int chiefsGreetingCount;

	private bool inIAP;

	private bool hovering;

	private ChapterID hoveringOverChapter;

	private float hoverElasped;

	private float hoverTime = 2f;

	private bool triggeringOnLeftHand;

	private bool hasCompletedChapel;

	private bool hasCompletedCell;

	private bool hasCompletedNursery;

	private bool hasCompletedMorgue;

	private bool hasCompletedTomb;

	private SaveManager saveManager;

	private void Start()
	{
		GameController.instance.audioController.SnapMute(0f);
		EventManager.StartListening(EventManager.AvailableEvents.IntroComplete.ToString(), IntroCompleted);
		EventManager.StartListening(EventManager.AvailableEvents.ChapelChapterCompleted.ToString(), ChapelChapterCompleted);
		EventManager.StartListening(EventManager.AvailableEvents.CellChapterCompleted.ToString(), CellChapterCompleted);
		EventManager.StartListening(EventManager.AvailableEvents.NurseryChapterCompleted.ToString(), NurseryChapterCompleted);
		EventManager.StartListening(EventManager.AvailableEvents.MorgueChapterCompleted.ToString(), MorgueChapterCompleted);
		EventManager.StartListening(EventManager.AvailableEvents.TombChapterCompleted.ToString(), TombChapterCompleted);
		player = GameController.instance.player;
		saveManager = SaveManager.instance;
		Camera componentInChildren = player.Head.GetComponentInChildren<Camera>();
		float[] array = new float[32];
		array[14] = 6f;
		componentInChildren.layerCullDistances = array;
		player.screenFX.Fade(UnityEngine.Color.black, 0f);
		player.movement.DisableEverything();
		for (int i = 0; i < godRays.Length; i++)
		{
			godRays[i].SetActive(value: true);
		}
		playerLight = player.playerLight.GetComponent<Light>();
		PicoLight = player.playerLight.GetComponent<Light>();
		playerLight.enabled = false;
		amuletMaterial.SetColor("_EmissionColor", new UnityEngine.Color(1f, 1f, 1f, 1f));
		StartCoroutine(Master());
	}

	private void ChapelChapterCompleted()
	{
		chapterManager.UpdateReportCheckmarks(ChapterID.CHAPEL);
	}

	private void CellChapterCompleted()
	{
		chapterManager.UpdateReportCheckmarks(ChapterID.CELL);
	}

	private void NurseryChapterCompleted()
	{
		chapterManager.UpdateReportCheckmarks(ChapterID.NURSERY);
	}

	private void MorgueChapterCompleted()
	{
		chapterManager.UpdateReportCheckmarks(ChapterID.MORGUE);
	}

	private void TombChapterCompleted()
	{
		chapterManager.UpdateReportCheckmarks(ChapterID.TOMB);
	}

	public void Update()
	{
		if (Input.GetKeyDown(KeyCode.N))
		{
			ResetRadioPosition();
		}
		if (hovering && !crossSelected)
		{
			chapterManager.chapterInteractVisualsLeft[(int)(hoveringOverChapter - 1)].fillAmount += Time.deltaTime / hoverTime;
			chapterManager.chapterInteractVisualsRight[(int)(hoveringOverChapter - 1)].fillAmount -= Time.deltaTime / hoverTime;
			if (player.LeftHand.IsHovering)
			{
				player.LeftHand.TriggerHapticPulse(5f * chapterManager.chapterInteractVisualsLeft[(int)(hoveringOverChapter - 1)].fillAmount);
			}
			if (player.RightHand.IsHovering)
			{
				player.RightHand.TriggerHapticPulse(5f * chapterManager.chapterInteractVisualsRight[(int)(hoveringOverChapter - 1)].fillAmount);
			}
			if (chapterManager.chapterInteractVisualsLeft[(int)(hoveringOverChapter - 1)].fillAmount * hoverTime >= hoverTime)
			{
				StartLevel((int)hoveringOverChapter);
			}
			return;
		}
		for (int i = 0; i < chapterManager.chapterInteractVisualsLeft.Length; i++)
		{
			if (chapterManager.chapterInteractVisualsLeft[i].fillAmount > 0f && !loading)
			{
				chapterManager.chapterInteractVisualsLeft[i].fillAmount -= Time.deltaTime;
				chapterManager.chapterInteractVisualsRight[i].fillAmount += Time.deltaTime;
			}
		}
	}

	private void StartLevel(int level)
	{
		PicoLight.enabled = false;
		StartCoroutine(StartLevelRoutine(level));
	}

	private IEnumerator StartLevelRoutine(int level)
	{
		loading = true;
		hovering = false;
		if (player.HandMenu.menuActive || player.HandMenu.itemActive)
		{
			player.HandMenu.exKitScript.CloseKit(instantly: true, ignoreAnimation: true);
			player.HandMenu.CloseMenu();
			player.HandMenu.LockMenu(locked: true);
		}
		yield return Yield.WaitSeconds(0.5f);
		officeRoomDoorInteractive.doorLocked = true;
		officeRoomDoorInteractive.LockDoor();
		saveManager.MarkChapterComplete(ChapterID.PRECINCT, ChapterStatus.COMPLETED, ChapterCompletionStatus.HUNDRED_PERCENT_COMPLETE);
		switch (level)
		{
		case 1:
			policeRadio.canInteract = true;
			policeRadio.PlayAlertMessages(1);
			GameController.instance.audioController.persistentMusicPlayer.PlayLoop(musicBed);
			break;
		case 2:
			StartCoroutine(gotoCellScene());
			break;
		case 3:
			StartCoroutine(gotoNureryScene());
			break;
		case 4:
			StartCoroutine(gotoMorgueScene());
			break;
		case 5:
			StartCoroutine(gotoTombScene());
			break;
		}
	}

	private void IntroCompleted()
	{
		introComplete = true;
	}

	private IEnumerator Master()
	{
		while (!introComplete)
		{
			yield return null;
		}
		foundHolyWater = saveManager.HasFoundArtifact(ChapterID.CHAPEL);
		foundAretfactUpgrade = saveManager.HasFoundArtifact(ChapterID.CELL);
		foundSacredEarth = saveManager.HasFoundArtifact(ChapterID.NURSERY);
		foundCelticCross = saveManager.HasFoundArtifact(ChapterID.MORGUE);
		hasCompletedChapel = saveManager.HasCompletedChapter(ChapterID.CHAPEL);
		hasCompletedCell = saveManager.HasCompletedChapter(ChapterID.CELL);
		hasCompletedNursery = saveManager.HasCompletedChapter(ChapterID.NURSERY);
		hasCompletedMorgue = saveManager.HasCompletedChapter(ChapterID.MORGUE);
		hasCompletedTomb = saveManager.HasCompletedChapter(ChapterID.TOMB);
		if (foundHolyWater)
		{
			bustArtefact.setArtifactRevealed();
		}
		else
		{
			NVRInteractableItem nVRInteractableItem = holyWater.AddComponent<NVRInteractableItem>();
			nVRInteractableItem.Rigidbody = holyWater.GetComponent<Rigidbody>();
			nVRInteractableItem.hideHands = true;
		}
		if (foundAretfactUpgrade)
		{
			Vector3 localEulerAngles = chessboardBreifcaseTop.transform.localEulerAngles;
			localEulerAngles.x = -90f;
			chessboard.setArtifactRevealed();
		}
		if (foundSacredEarth)
		{
			sacredEarthArtefact.setArtifactRevealed();
		}
		if (foundCelticCross)
		{
			puzzleBoxArtifact.SetArtifactRevealed();
		}
		if (hasCompletedChapel)
		{
			GameController.instance.currentRoom = roomOffice;
			roomOffice.UpdateColliders(enabled: false);
			roomOffice.associatedParentGameObject.SetActive(value: true);
			roomOffice.playerInRoom = true;
			roomCorridor.UpdateColliders(enabled: true);
			roomCorridor.associatedParentGameObject.SetActive(value: false);
			roomCorridor.playerInRoom = false;
			roomEvidence.UpdateColliders(enabled: true);
			roomEvidence.associatedParentGameObject.SetActive(value: false);
			roomEvidence.playerInRoom = false;
			player.SetPosition(playerReturnPosition);
		}
		else
		{
			GameController.instance.currentRoom = roomCorridor;
			GameController.instance.hintManager.AddHint(chapterManager.chapter1Button);
			roomOffice.UpdateColliders(enabled: true);
			roomOffice.associatedParentGameObject.SetActive(value: false);
			roomOffice.playerInRoom = false;
			roomCorridor.UpdateColliders(enabled: false);
			roomCorridor.associatedParentGameObject.SetActive(value: true);
			roomCorridor.playerInRoom = true;
			roomEvidence.UpdateColliders(enabled: true);
			roomEvidence.associatedParentGameObject.SetActive(value: false);
			roomEvidence.playerInRoom = false;
			player.SetPosition(playerStartPosition);
		}
		if (hasCompletedCell || hasCompletedChapel)
		{
			player.HandMenu.BookInMenu(active: true);
			player.HandMenu.KitInMenu(active: true);
		}
		if (!hasCompletedCell && hasCompletedChapel)
		{
			StartCoroutine(ChapterTwoClues());
		}
		ExorcismKit exKitScript = player.HandMenu.exKitScript;
		cross = exKitScript.cross;
		tuneCross = cross.GetComponent<TuneController>();
		interactableCross = cross.GetComponent<ExorcismItem>();
		yield return StartCoroutine(FadeInScene());
	}

	private IEnumerator FadeInScene()
	{
		GameController.instance.audioController.SnapAllOpen(3f);
		player.LeftHand.ResetHandMaterial();
		player.RightHand.ResetHandMaterial();
		player.HandMenu.exKitScript.candle.GetComponent<OilLighter>().canTurnOnLight = false;
		yield return Yield.WaitSeconds(3f);
		if (saveManager.GetChapterById(ChapterID.CHAPEL).chapterStatus > ChapterStatus.PLAYED_NOT_COMPLETED)
		{
			if (!hasCompletedCell || !hasCompletedNursery || !hasCompletedMorgue || !hasCompletedTomb)
			{
				int num = UnityEngine.Random.Range(0, chapter2CTA.Length);
				wallSpeaker.PlayOne(chapter2CTA[num], 0.8f);
				HUD.Instance.PlaySubtitles(chapter2CTA[0].name, hasPriority: true);
			}
			yield return Yield.WaitSeconds(3f);
			player.screenFX.Fade(UnityEngine.Color.clear, 3f);
		}
		else
		{
			coffee.PourSound();
			yield return Yield.WaitSeconds(10f);
			player.screenFX.Fade(UnityEngine.Color.clear, 3f);
		}
		GameController.instance.boundDetection.SwitchOnOOB();
		EventManager.TriggerEvent(EventManager.AvailableEvents.SwitchedScenes.ToString());
		sacredEarthArtefact.transform.parent = roomEvidence.associatedParentGameObject.transform;
		sacredEarthArtefact.gameObject.SetActive(value: true);
		coffee.HumSound();
		player.movement.EnableEverything();
	}

	public void ResetRadioPosition()
	{
		if (!policeRadio.interactiveItem.IsAttached)
		{
			policeRadio.interactiveItem.gameObject.transform.parent = policeRadioStartPosition.gameObject.transform.parent;
			policeRadio.interactiveItem.gameObject.transform.localPosition = policeRadioStartPosition.gameObject.transform.localPosition;
			policeRadio.interactiveItem.gameObject.transform.localEulerAngles = policeRadioStartPosition.gameObject.transform.localEulerAngles;
		}
	}

	private IEnumerator ChapterTwoClues()
	{
		while (true)
		{
			if (!crossSelected || Vector3.Distance(player.Head.gameObject.transform.position, amulet.gameObject.transform.position) > 2f)
			{
				yield return null;
				continue;
			}
			tuneCross.tuningUI.SetActive(value: true);
			StartCoroutine(PerformExorcism());
			while (true)
			{
				if (!exorcismComplete)
				{
					if (Vector3.Distance(player.Head.gameObject.transform.position, amulet.gameObject.transform.position) > 2f)
					{
						break;
					}
					yield return null;
					continue;
				}
				amuletParticle.Stop();
				tuneCross.tuningUI.SetActive(value: false);
				amuletMaterial.GetColor("_EmissionColor");
				for (float num = 1f; num > 0.1f; num -= Time.deltaTime)
				{
					UnityEngine.Color value = new UnityEngine.Color(num, num, num, num);
					amuletMaterial.SetColor("_EmissionColor", value);
				}
				GameController.instance.achievementManager.UnlockAchievement(AchievementID.TRAINING_WHEELS);
				GameController.instance.hintManager.AddHint(chapterManager.chapter2Button);
				yield break;
			}
			StopCoroutine("PerformExorcism");
			tuneCross.StopAll();
		}
	}

	private IEnumerator PerformExorcism()
	{
		tuneCross.tuneSuccess = false;
		while (!tuneCross.tuneSuccess)
		{
			while (interactableCross.AttachedHand == null)
			{
				yield return null;
			}
			tuneCross.TheLight(isEnabled: true);
			GameObject[] locations = new GameObject[1] { amulet.gameObject };
			tuneCross.StartTuning(amuletTraget, locations, 4f, 20f, isSlowMo: false, 0.6f);
			while (!tuneCross.tuneSuccess && !tuneCross.failed)
			{
				yield return null;
			}
		}
		tuneCross.StartLightTarget(amulet.gameObject);
		amulet.gameObject.SetLayer(11);
		while (!tuneCross.hitSuccess)
		{
			yield return null;
		}
		tuneCross.ShootBeam();
		yield return Yield.WaitSeconds(2f);
		amulet.gameObject.SetLayer(0);
		amuletParticleComplete.SetActive(value: true);
		GameController.instance.audioController.PlayBadSting(STINGS_BAD.BAD_STING_02);
		exorcismComplete = true;
	}

	public override void BeginInteraction(NVRInteractable interactable)
	{
		if (interactable != null && interactable.gameObject.transform.parent != null && interactable.gameObject.transform.parent.gameObject == chiefsRoomDoor.gameObject && !chiefsIgnoringYou)
		{
			if (chiefsGreetingCount <= chiefsGreeting.Length - 1)
			{
				if (!chiefsRoomAudioScript.m_AudioSource.isPlaying)
				{
					chiefsRoomAudioScript.Play(chiefsGreeting[chiefsGreetingCount]);
					chiefsGreetingCount++;
				}
			}
			else
			{
				chiefsGreetingCount = 0;
				chiefsIgnoringYou = true;
			}
		}
		if (cross != null && interactable.gameObject == cross)
		{
			crossSelected = true;
		}
		if (interactable.gameObject == holyWater && !foundHolyWater)
		{
			foundHolyWater = true;
			StartCoroutine(FoundAretfact(ChapterID.CHAPEL));
		}
		if (interactable.gameObject == oilReward && !foundAretfactUpgrade)
		{
			foundAretfactUpgrade = true;
			StartCoroutine(FoundAretfact(ChapterID.CELL));
		}
		if (interactable.gameObject == sacredEarth && !foundSacredEarth)
		{
			foundSacredEarth = true;
			StartCoroutine(FoundAretfact(ChapterID.NURSERY));
		}
		if (interactable.gameObject == celticCross && !foundCelticCross)
		{
			foundCelticCross = true;
			StartCoroutine(FoundAretfact(ChapterID.MORGUE));
		}
		if (interactable.gameObject == amulet && !foundAmulet)
		{
			foundAmulet = true;
			player.HandMenu.OpenStraightToBook(NotebookPages.Q06);
			player.watch.WatchHintWithSFX(3f, SFXAlertType.INFO);
		}
		if (interactable.gameObject == mansBestFriend)
		{
			GameController.instance.achievementManager.UnlockAchievement(AchievementID.MANS_BEST_FRIEND);
		}
		if (interactable.gameObject == peaSoup)
		{
			GameController.instance.achievementManager.UnlockAchievement(AchievementID.PUKE);
		}
	}

	public override void EndInteraction(NVRInteractable interactable)
	{
		if (cross != null && interactable.gameObject == cross)
		{
			crossSelected = false;
		}
		if (interactable.gameObject == holyWater)
		{
			holyWater.GetComponent<BreakableObject>().canSmash = true;
		}
	}

	private IEnumerator FoundAretfact(ChapterID chapterId)
	{
		GameController.instance.audioController.PlayGoodSting(STINGS_GOOD.GOOD_CHOIR_STING_03, 0.75f);
		player.HandMenu.bookScript.updateMaxPage(14);
		saveManager.MarkArtifactFound(chapterId);
		GameObject reward = null;
		switch (chapterId)
		{
		case ChapterID.CHAPEL:
		{
			player.HandMenu.OpenStraightToBookForArtefact(ArtefactType.SOURCE_OF_NILE, NotebookPages.Q14);
			player.HandMenu.SwapOutHolyWater();
			yield return Yield.WaitSeconds(2f);
			PlayWatchAlert();
			Chapter chapterById4 = saveManager.GetChapterById(chapterId);
			bool completionCheckmark10 = chapterById4.completionCheckmark2;
			bool completionCheckmark11 = chapterById4.completionCheckmark3;
			bool foundSourceOfTheNile = true;
			bool completionCheckmark12 = chapterById4.completionCheckmark1;
			GameController.instance.levelCompletionManager.SetLevelCompletionForChapel(completionCheckmark10, completionCheckmark11, foundSourceOfTheNile, completionCheckmark12);
			chapterManager.UpdateReportCheckmarks(chapterId);
			hasCompletedChapel = saveManager.HasCompletedChapter(ChapterID.CHAPEL);
			reward = holyWater;
			break;
		}
		case ChapterID.CELL:
		{
			player.HandMenu.OpenStraightToBookForArtefact(ArtefactType.LIGHTER_UPGRADE, NotebookPages.Q14);
			player.HandMenu.SwapOutLighterFuel();
			yield return Yield.WaitSeconds(2f);
			PlayWatchAlert();
			Chapter chapterById2 = saveManager.GetChapterById(chapterId);
			bool completionCheckmark4 = chapterById2.completionCheckmark2;
			bool completionCheckmark5 = chapterById2.completionCheckmark3;
			bool foundArtefact2 = true;
			bool completionCheckmark6 = chapterById2.completionCheckmark1;
			GameController.instance.levelCompletionManager.SetLevelCompletionForCell(completionCheckmark4, completionCheckmark5, foundArtefact2, completionCheckmark6);
			chapterManager.UpdateReportCheckmarks(chapterId);
			hasCompletedCell = saveManager.HasCompletedChapter(ChapterID.CELL);
			reward = chessboard.oilReward;
			break;
		}
		case ChapterID.NURSERY:
		{
			player.HandMenu.OpenStraightToBookForArtefact(ArtefactType.SACRED_GROUND, NotebookPages.Q14);
			player.HandMenu.UpgradeSaltSprayer();
			yield return Yield.WaitSeconds(2f);
			PlayWatchAlert();
			Chapter chapterById3 = saveManager.GetChapterById(chapterId);
			bool completionCheckmark7 = chapterById3.completionCheckmark2;
			bool completionCheckmark8 = chapterById3.completionCheckmark3;
			bool foundArtefact3 = true;
			bool completionCheckmark9 = chapterById3.completionCheckmark1;
			GameController.instance.levelCompletionManager.SetLevelCompletionForNursery(completionCheckmark7, completionCheckmark8, foundArtefact3, completionCheckmark9);
			chapterManager.UpdateReportCheckmarks(chapterId);
			hasCompletedNursery = saveManager.HasCompletedChapter(ChapterID.NURSERY);
			reward = sacredEarth;
			break;
		}
		case ChapterID.MORGUE:
		{
			player.HandMenu.OpenStraightToBookForArtefact(ArtefactType.CELTIC_CROSS, NotebookPages.Q14);
			player.HandMenu.UpgradeCross();
			upgradeAnimator.SetTrigger("DropClick");
			yield return Yield.WaitSeconds(2f);
			PlayWatchAlert();
			Chapter chapterById = saveManager.GetChapterById(chapterId);
			bool completionCheckmark = chapterById.completionCheckmark2;
			bool completionCheckmark2 = chapterById.completionCheckmark3;
			bool foundArtefact = true;
			bool completionCheckmark3 = chapterById.completionCheckmark1;
			GameController.instance.levelCompletionManager.SetLevelCompletionForMorgue(completionCheckmark2, completionCheckmark, foundArtefact, completionCheckmark3);
			chapterManager.UpdateReportCheckmarks(chapterId);
			hasCompletedMorgue = saveManager.HasCompletedChapter(ChapterID.MORGUE);
			reward = celticCross;
			break;
		}
		}
		yield return Yield.WaitSeconds(4f);
		player.watch.WatchHintWithSFX(5f, SFXAlertType.ALERT);
		if ((bool)reward)
		{
			StartCoroutine(RemoveArtifactFromUserHand(reward));
		}
	}

	private IEnumerator RemoveArtifactFromUserHand(GameObject reward)
	{
		float counter = 0f;
		bool inHand = false;
		while (!player.HandMenu.bookScript.isActiveItem)
		{
			if (player.LeftHand.IsInteracting && player.LeftHand.CurrentlyInteracting.gameObject == reward)
			{
				inHand = true;
			}
			if (player.RightHand.IsInteracting && player.RightHand.CurrentlyInteracting.gameObject == reward)
			{
				inHand = true;
			}
			if (inHand)
			{
				counter = 0f;
				inHand = false;
			}
			else
			{
				counter += Time.deltaTime;
			}
			if (counter > 1f)
			{
				break;
			}
			yield return Yield.EndOfFrame;
		}
		if (player.LeftHand.IsInteracting || player.RightHand.IsInteracting)
		{
			if (player.LeftHand.CurrentlyInteracting != null && player.LeftHand.CurrentlyInteracting.gameObject == reward)
			{
				LeanTween.alpha(reward, 0f, 1f);
				player.LeftHand.ForceDropItem();
				yield return Yield.EndOfFrame;
				reward.SetActive(value: false);
				if (reward == holyWater)
				{
					GameObject[] array = holyWaterCaps;
					for (int i = 0; i < array.Length; i++)
					{
						array[i].SetActive(value: false);
					}
				}
				player.LeftHand.CurrentlyInteracting = null;
				yield return Yield.EndOfFrame;
				player.LeftHand.CurrentlyHoveringOver.Remove(reward.GetComponent<NVRInteractableItem>());
				if (reward == bustArtefact.holyWaterReward)
				{
					GameController.instance.player.LeftHand.SetAnimation("IdleBool");
					player.HandRendersActive(showHands: true);
					if (player.HandMenu.IsActive)
					{
						player.HandRendersActive(showHands: false, onlySecondary: true);
					}
				}
			}
			if (player.RightHand.CurrentlyInteracting != null && player.RightHand.CurrentlyInteracting.gameObject == reward)
			{
				LeanTween.alpha(reward, 0f, 1f);
				player.RightHand.ForceDropItem();
				yield return Yield.EndOfFrame;
				reward.SetActive(value: false);
				if (reward == holyWater)
				{
					GameObject[] array = holyWaterCaps;
					for (int i = 0; i < array.Length; i++)
					{
						array[i].SetActive(value: false);
					}
				}
				player.RightHand.CurrentlyInteracting = null;
				yield return Yield.EndOfFrame;
				player.RightHand.CurrentlyHoveringOver.Remove(reward.GetComponent<NVRInteractableItem>());
				if (reward == bustArtefact.holyWaterReward)
				{
					GameController.instance.player.RightHand.SetAnimation("IdleBool");
					player.HandRendersActive(showHands: true);
					if (player.HandMenu.IsActive)
					{
						player.HandRendersActive(showHands: false, onlySecondary: true);
					}
				}
			}
		}
		else
		{
			LeanTween.alpha(reward, 0f, 0.5f);
			yield return Yield.WaitSeconds(0.5f);
			reward.SetActive(value: false);
			if (reward == holyWater)
			{
				GameObject[] array = holyWaterCaps;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].SetActive(value: false);
				}
			}
		}
		if (!GameController.instance.player.LeftHand.IsInteracting)
		{
			GameController.instance.player.LeftHand.SetAnimation("IdleBool");
		}
		if (!GameController.instance.player.RightHand.IsInteracting)
		{
			GameController.instance.player.RightHand.SetAnimation("IdleBool");
		}
	}

	public override void OnTriggerEnter(Collider collider)
	{
		if (!loading)
		{
			if (collider.gameObject == chapterManager.chapter1Button)
			{
				hovering = true;
				hoveringOverChapter = ChapterID.CHAPEL;
			}
			else if (collider.gameObject == chapterManager.chapter2Button)
			{
				hovering = true;
				hoveringOverChapter = ChapterID.CELL;
			}
			else if (collider.gameObject == chapterManager.chapter3Button)
			{
				hovering = true;
				hoveringOverChapter = ChapterID.NURSERY;
			}
			else if (collider.gameObject == chapterManager.chapter4Button)
			{
				hovering = true;
				hoveringOverChapter = ChapterID.MORGUE;
			}
			else if (collider.gameObject == chapterManager.chapter5Button)
			{
				hovering = true;
				hoveringOverChapter = ChapterID.TOMB;
			}
		}
		if (collider.gameObject == coffee.gameObject)
		{
			coffee.DispenseCoffee();
		}
		if (collider.gameObject == audioReel)
		{
			audioReelPlayer.ReelInteraction();
		}
		if (collider.gameObject == cdPlayer)
		{
			audioCdPlayer.ReelInteraction();
		}
		if (collider.gameObject == vhsPlayer.gameObject)
		{
			vhsPlayer.ReplayVideo();
		}
		if (collider.gameObject == beacon.gameObject && !beacon.isPlaying)
		{
			beacon.PlayMessage();
		}
		if (collider.gameObject == tapePlayer.gameObject && tapePlayer.GetComponentInParent<TapePlayer>().PlayTape())
		{
			Chapter chapterById = saveManager.GetChapterById(ChapterID.CHAPEL);
			bool playedTapes = true;
			bool completionCheckmark = chapterById.completionCheckmark3;
			bool completionCheckmark2 = chapterById.completionCheckmark4;
			bool completionCheckmark3 = chapterById.completionCheckmark1;
			GameController.instance.levelCompletionManager.SetLevelCompletionForChapel(playedTapes, completionCheckmark, completionCheckmark2, completionCheckmark3);
			chapterManager.UpdateReportCheckmarks(ChapterID.CHAPEL);
			hasCompletedChapel = saveManager.HasCompletedChapter(ChapterID.CHAPEL);
		}
	}

	public override void OnTriggerExit(Collider collider)
	{
		if ((bool)collider.gameObject == ((bool)chapterManager.chapter1Button || (bool)chapterManager.chapter2Button || (bool)chapterManager.chapter3Button || (bool)chapterManager.chapter4Button || (bool)chapterManager.chapter5Button))
		{
			hovering = false;
		}
		if (collider.gameObject == cdPlayer)
		{
			audioCdPlayer.StopInteraction();
		}
		if (collider.gameObject == audioReel)
		{
			audioReelPlayer.StopInteraction();
		}
	}

	private IEnumerator gotoCellScene()
	{
		GameController.instance.audioController.SnapMute(3f);
		yield return Yield.WaitSeconds(3f);
		player.screenFX.Fade(UnityEngine.Color.black, 2f);
		player.HandMenu.LockMenu(locked: false);
		GameController.instance.currentRoom = null;
		GameController.instance.boundDetection.SwitchOffOOB();
		GameController.instance.GoToSpecificScene(SCENES.CELL);
	}

	private IEnumerator gotoChurchScene()
	{
		player.screenFX.Fade(UnityEngine.Color.black, 2f);
		GameController.instance.audioController.SnapMute(3f);
		yield return Yield.WaitSeconds(3f);
		player.HandMenu.LockMenu(locked: false);
		GameController.instance.currentRoom = null;
		GameController.instance.boundDetection.SwitchOffOOB();
		GameController.instance.GoToSpecificScene(SCENES.CHAPEL);
	}

	private IEnumerator gotoNureryScene()
	{
		player.screenFX.Fade(UnityEngine.Color.black, 2f);
		GameController.instance.audioController.SnapMute(3f);
		yield return Yield.WaitSeconds(3f);
		player.HandMenu.LockMenu(locked: false);
		GameController.instance.currentRoom = null;
		GameController.instance.boundDetection.SwitchOffOOB();
		GameController.instance.GoToSpecificScene(SCENES.NURSERY);
	}

	private IEnumerator gotoMorgueScene()
	{
		player.screenFX.Fade(UnityEngine.Color.black, 2f);
		GameController.instance.audioController.SnapMute(3f);
		yield return Yield.WaitSeconds(3f);
		player.HandMenu.LockMenu(locked: false);
		GameController.instance.currentRoom = null;
		GameController.instance.boundDetection.SwitchOffOOB();
		GameController.instance.GoToSpecificScene(SCENES.MORGUE);
	}

	private IEnumerator gotoTombScene()
	{
		player.screenFX.Fade(UnityEngine.Color.black, 2f);
		GameController.instance.audioController.SnapMute(3f);
		yield return Yield.WaitSeconds(3f);
		player.HandMenu.LockMenu(locked: false);
		GameController.instance.currentRoom = null;
		GameController.instance.boundDetection.SwitchOffOOB();
		GameController.instance.GoToSpecificScene(SCENES.TOMB);
	}

	private void PlayWatchAlert(float delayTime = 0f)
	{
		if (delayTime == 0f)
		{
			player.watch.WatchHintWithSFX(3f, SFXAlertType.ALERT);
		}
		else
		{
			StartCoroutine(WatchAlertDelay(delayTime));
		}
	}

	private IEnumerator WatchAlertDelay(float delayTime)
	{
		yield return Yield.WaitSeconds(delayTime);
		player.watch.WatchHintWithSFX(3f, SFXAlertType.ALERT);
	}

	private void PlayWatchAlertInfo()
	{
		player.watch.WatchHintWithSFX(1f, SFXAlertType.INFO);
	}

	private void DebugCommands()
	{
	}
}
public class ProfileScene : InteractionManager
{
	private enum SceneMode
	{
		PROFILE,
		LANGUAGE
	}

	private NVRPlayer player;

	private ScreenFX screenEffects;

	[SerializeField]
	private GameObject profilePicker;

	[SerializeField]
	private NVRInteractable deleteOrCalibrateButton;

	[SerializeField]
	private TextMeshPro deleteOrCalibrateLabel;

	[SerializeField]
	private NVRInteractable continueOrStartButton;

	[SerializeField]
	private TextMeshPro continueOrStartLabel;

	[SerializeField]
	private NVRInteractable previousButton;

	[SerializeField]
	private NVRInteractable nextButton;

	[SerializeField]
	private GameObject badge;

	[SerializeField]
	private TextMeshPro slotLabel;

	[SerializeField]
	private NVRInteractable switchLanguageButton;

	[SerializeField]
	private TextMeshPro switchLanguageLabel;

	[SerializeField]
	private GameObject languagePicker;

	[SerializeField]
	private NVRInteractable previousLanguageButton;

	[SerializeField]
	private NVRInteractable nextLanguageButton;

	[SerializeField]
	private TextMeshPro languageLabel;

	[SerializeField]
	private NVRInteractable selectButton;

	[SerializeField]
	private TextMeshPro selectLabel;

	[SerializeField]
	private NVRInteractable switchProfileButton;

	[SerializeField]
	private TextMeshPro switchProfileLabel;

	private int currentLanguageNumber;

	private int currentSlotNumber = 1;

	private int maxSlotNumber = 3;

	private int maxLanguageNumber;

	private Translator translator;

	private bool usingDS4Controller;

	private SceneMode sceneMode;

	private Light playerLight;

	private void Start()
	{
		player = GameObject.FindGameObjectWithTag("Player").GetComponent<NVRPlayer>();
		playerLight = GameObject.Find("Player/PlayerLight").GetComponent<Light>();
		playerLight.enabled = false;
		screenEffects = player.Head.GetComponentInChildren<ScreenFX>();
		usingDS4Controller = ControlsManager.instance.usingDS4Controller;
		maxLanguageNumber = Enum.GetNames(typeof(GameLanguage)).Length - 1;
		if (sceneMode == SceneMode.PROFILE)
		{
			UpdateProfileDisplayInformation();
		}
		else
		{
			UpdateLanguageDisplayInformation();
		}
		StartCoroutine(FadeInScene());
	}

	private IEnumerator FadeInScene()
	{
		if (XRSettings.loadedDeviceName != "Oculus")
		{
			player.screenFX.Fade(UnityEngine.Color.clear, 3f);
		}
		yield return null;
	}

	private void Update()
	{
	}

	private void OnEnable()
	{
	}

	private void OnDisable()
	{
	}

	private void UpdateProfileDisplayInformation()
	{
		bool flag = SaveManager.instance.DoesExist(currentSlotNumber);
		string text = translator.TranslateText("Slot") + " " + translator.TranslateText(currentSlotNumber.ToString());
		slotLabel.text = text;
		if (GameController.instance.gameState == GameController.GameState.PROFILE)
		{
			if (flag)
			{
				deleteOrCalibrateButton.gameObject.SetActive(value: true);
				deleteOrCalibrateLabel.text = translator.TranslateText("Delete");
				continueOrStartLabel.text = translator.TranslateText("Continue");
			}
			else
			{
				deleteOrCalibrateButton.gameObject.SetActive(value: false);
				continueOrStartLabel.text = translator.TranslateText("Start");
			}
		}
		else if (GameController.instance.gameState == GameController.GameState.GAME)
		{
			if (flag)
			{
				if (currentSlotNumber == SaveManager.instance.currentSavedGameSlot)
				{
					deleteOrCalibrateButton.gameObject.SetActive(value: true);
					deleteOrCalibrateLabel.text = translator.TranslateText("Calibrate");
					continueOrStartLabel.text = translator.TranslateText("Resume");
				}
				else
				{
					deleteOrCalibrateButton.gameObject.SetActive(value: false);
					deleteOrCalibrateLabel.text = translator.TranslateText("Calibrate");
					continueOrStartLabel.text = translator.TranslateText("Start");
				}
			}
			else
			{
				deleteOrCalibrateButton.gameObject.SetActive(value: false);
				deleteOrCalibrateLabel.text = translator.TranslateText("Calibrate");
				continueOrStartLabel.text = translator.TranslateText("Start");
			}
		}
		if (currentSlotNumber + 1 > maxSlotNumber)
		{
			nextButton.gameObject.SetActive(value: false);
		}
		else
		{
			nextButton.gameObject.SetActive(value: true);
		}
		if (currentSlotNumber - 1 <= 0)
		{
			previousButton.gameObject.SetActive(value: false);
		}
		else
		{
			previousButton.gameObject.SetActive(value: true);
		}
	}

	private void UpdateLanguageDisplayInformation()
	{
		languageLabel.text = PreferenceManager.instance.GetLanguageFromEnum(currentLanguageNumber);
		if (currentLanguageNumber + 1 > maxLanguageNumber)
		{
			nextLanguageButton.gameObject.SetActive(value: false);
		}
		else
		{
			nextLanguageButton.gameObject.SetActive(value: true);
		}
		if (currentLanguageNumber - 1 < 0)
		{
			previousLanguageButton.gameObject.SetActive(value: false);
		}
		else
		{
			previousLanguageButton.gameObject.SetActive(value: true);
		}
	}

	public override void OnPointerStay(Collider collider)
	{
		if (!usingDS4Controller)
		{
			if (!ControlsManager.instance.primaryTriggerButtonUp && !ControlsManager.instance.secondaryTriggerButtonUp)
			{
				return;
			}
			if (sceneMode == SceneMode.PROFILE)
			{
				if (collider.gameObject == nextButton.gameObject)
				{
					nextButtonPressed();
				}
				else if (collider.gameObject == previousButton.gameObject)
				{
					previousButtonPressed();
				}
				else if (collider.gameObject == deleteOrCalibrateButton.gameObject)
				{
					deleteOrCalibrateButtonPressed();
				}
				else if (collider.gameObject == continueOrStartButton.gameObject)
				{
					continueOrStartButtonPressed();
				}
				else if (collider.gameObject == switchLanguageButton.gameObject)
				{
					switchLanguageButtonPressed();
				}
			}
			else if (collider.gameObject == nextLanguageButton.gameObject)
			{
				nextLanguageButtonPressed();
			}
			else if (collider.gameObject == previousLanguageButton.gameObject)
			{
				previousLanguageButtonPressed();
			}
			else if (collider.gameObject == selectButton.gameObject)
			{
				selectButtonPressed();
			}
			else if (collider.gameObject == switchProfileButton.gameObject)
			{
				switchProfileButtonPressed();
			}
		}
		else
		{
			if (!ControlsManager.instance.ds4CalibrateButtonDown)
			{
				return;
			}
			if (sceneMode == SceneMode.PROFILE)
			{
				if (collider.gameObject == nextButton.gameObject)
				{
					nextButtonPressed();
				}
				else if (collider.gameObject == previousButton.gameObject)
				{
					previousButtonPressed();
				}
				else if (collider.gameObject == deleteOrCalibrateButton.gameObject)
				{
					deleteOrCalibrateButtonPressed();
				}
				else if (collider.gameObject == continueOrStartButton.gameObject)
				{
					continueOrStartButtonPressed();
				}
				else if (collider.gameObject == switchLanguageButton.gameObject)
				{
					switchLanguageButtonPressed();
				}
			}
			else if (collider.gameObject == nextLanguageButton.gameObject)
			{
				nextLanguageButtonPressed();
			}
			else if (collider.gameObject == previousLanguageButton.gameObject)
			{
				previousLanguageButtonPressed();
			}
			else if (collider.gameObject == deleteOrCalibrateButton.gameObject)
			{
				deleteOrCalibrateButtonPressed();
			}
			else if (collider.gameObject == selectButton.gameObject)
			{
				selectButtonPressed();
			}
			else if (collider.gameObject == switchProfileButton.gameObject)
			{
				switchProfileButtonPressed();
			}
		}
	}

	public void continueOrStartButtonPressed()
	{
		if (SaveManager.instance.DoesExist(currentSlotNumber))
		{
			SaveManager.instance.Load(currentSlotNumber);
		}
		else
		{
			SaveManager.instance.CreateNewProfile(currentSlotNumber);
		}
	}

	public void selectButtonPressed()
	{
		GameLanguage languageFromInt = PreferenceManager.instance.GetLanguageFromInt(currentLanguageNumber);
		PreferenceManager.instance.SetInt(PlayerPreferences.GAME_LANGUAGE.ToString(), (int)languageFromInt);
		switchProfileButtonPressed();
	}

	public void switchLanguageButtonPressed()
	{
		sceneMode = SceneMode.LANGUAGE;
		profilePicker.SetActive(value: false);
		languagePicker.SetActive(value: true);
		currentLanguageNumber = 0;
		UpdateLanguageDisplayInformation();
	}

	public void switchProfileButtonPressed()
	{
		sceneMode = SceneMode.PROFILE;
		profilePicker.SetActive(value: true);
		languagePicker.SetActive(value: false);
		currentSlotNumber = 1;
		UpdateProfileDisplayInformation();
	}

	public void deleteOrCalibrateButtonPressed()
	{
		if (SaveManager.instance.DoesExist(currentSlotNumber))
		{
			if (GameController.instance.gameState == GameController.GameState.PROFILE)
			{
				SaveManager.instance.Delete(currentSlotNumber);
				UpdateProfileDisplayInformation();
			}
			else if (GameController.instance.gameState == GameController.GameState.GAME)
			{
				GameController.instance.GoToSpecificScene(SCENES.CALIBRATION);
			}
		}
	}

	public void nextButtonPressed()
	{
		if (currentSlotNumber + 1 <= maxSlotNumber)
		{
			currentSlotNumber++;
			UpdateProfileDisplayInformation();
		}
	}

	public void previousButtonPressed()
	{
		if (currentSlotNumber - 1 > 0)
		{
			currentSlotNumber--;
			UpdateProfileDisplayInformation();
		}
	}

	public void nextLanguageButtonPressed()
	{
		if (currentLanguageNumber + 1 <= maxLanguageNumber)
		{
			currentLanguageNumber++;
			UpdateLanguageDisplayInformation();
		}
	}

	public void previousLanguageButtonPressed()
	{
		if (currentLanguageNumber - 1 >= 0)
		{
			currentLanguageNumber--;
			UpdateLanguageDisplayInformation();
		}
	}

	public void OnGameSaved()
	{
		GameController.instance.GotoNextScene();
	}

	public void OnPreferencesLoaded()
	{
		GameController.instance.GotoNextScene();
	}

	public void OnGameDeleted()
	{
		UpdateProfileDisplayInformation();
	}
}
public class TemplateScript : InteractionManager
{
	private bool introComplete;

	private NVRPlayer player;

	private LightFlicker playerLightFlicker;

	private int debugCount;

	[Header("General")]
	[SerializeField]
	private GameObject playerStartPosition;

	[SerializeField]
	private GameObject[] changeLayerObjects;

	[Space]
	[Header("Rooms")]
	[SerializeField]
	private GameObject mainRoom;

	[Space]
	[Header("Fade In")]
	[SerializeField]
	private TextMeshProUGUI chapterName;

	[SerializeField]
	private TextMeshProUGUI chapterNumber;

	[Space]
	[Header("Exorcism")]
	[SerializeField]
	private GameObject exorcismTarget;

	[SerializeField]
	private GameObject[] exorcismTargetLocations;

	private bool crossSelected;

	private GameObject cross;

	private TuneController tuneCross;

	private ExorcismItem interactableCross;

	private bool exorcismComplete;

	private void Start()
	{
		EventManager.StartListening(EventManager.AvailableEvents.IntroComplete.ToString(), IntroCompleted);
		EventManager.StartListening(EventManager.AvailableEvents.ExitLevelToPrecint.ToString(), ExitToPrecinct);
		EventManager.StartListening(EventManager.AvailableEvents.RestartScene.ToString(), ExitToPrecinct);
		player = GameController.instance.player;
		player.movement.DisableEverything();
		player.screenFX.Fade(UnityEngine.Color.black, 0f);
		playerLightFlicker = player.playerLight.GetComponent<LightFlicker>();
		playerLightFlicker.light.enabled = true;
		playerLightFlicker.SwitchLight(switchOn: false);
		player.playerLight.EnableRay(enable: false);
		playerLightFlicker.ResetIntensity();
		GameObject[] array = changeLayerObjects;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetLayer(0);
		}
		cross = player.HandMenu.exKitScript.cross;
		tuneCross = cross.GetComponent<TuneController>();
		interactableCross = cross.GetComponent<ExorcismItem>();
		StartCoroutine(Master());
	}

	private void IntroCompleted()
	{
		introComplete = true;
	}

	public void Update()
	{
	}

	private IEnumerator Master()
	{
		yield return StartCoroutine(FadeInScene());
		yield return StartCoroutine(Exorcism());
		yield return StartCoroutine(FadeOutScene());
	}

	private IEnumerator FadeInScene()
	{
		player.HandMenu.BookInMenu(active: true);
		player.HandMenu.KitInMenu(active: true);
		while (!introComplete)
		{
			yield return null;
		}
		player.SetPosition(playerStartPosition);
		GameController.instance.audioController.SnapAllOpen(3f);
		SaveManager.instance.MarkChapterStarted(ChapterID.CHAPEL);
		EventManager.TriggerEvent(EventManager.AvailableEvents.SwitchedScenes.ToString());
		chapterName.transform.parent.gameObject.SetActive(value: true);
		player.screenFX.Fade(UnityEngine.Color.clear, 4f);
		yield return Yield.WaitSeconds(3f);
		chapterName.CrossFadeAlpha(0f, 3f, ignoreTimeScale: false);
		chapterNumber.CrossFadeAlpha(0f, 3f, ignoreTimeScale: false);
		player.movement.EnableEverything();
	}

	private IEnumerator Exorcism()
	{
		UnityEngine.Debug.Log("Final Exorcism");
		while (!crossSelected)
		{
			yield return null;
		}
		interactableCross.LockToHand(isLocked: true);
		StartCoroutine(PerformExorcism());
		while (!exorcismComplete)
		{
			yield return null;
		}
	}

	private IEnumerator PerformExorcism()
	{
		while (interactableCross.AttachedHand == null)
		{
			yield return null;
		}
		tuneCross.TheLight(isEnabled: true);
		tuneCross.StartTuning(exorcismTarget, exorcismTargetLocations, 5f, 30f, isSlowMo: false, 0.5f);
		while (!tuneCross.tuneSuccess)
		{
			yield return null;
		}
		while (!tuneCross.hitSuccess)
		{
			yield return null;
		}
		exorcismComplete = true;
	}

	private IEnumerator FadeOutScene()
	{
		GameController.instance.audioController.SnapMute(0.25f);
		yield return Yield.WaitSeconds(2f);
		player.screenFX.BlurScreen(enabled: false);
		GameController.instance.GoToSpecificScene(SCENES.PRECINCT, completedPrev: true);
	}

	public override void BeginInteraction(NVRInteractable interactable)
	{
		if (cross != null && interactable.gameObject == cross)
		{
			crossSelected = true;
		}
	}

	public override void EndInteraction(NVRInteractable interactable)
	{
		if (cross != null && interactable.gameObject == cross)
		{
			crossSelected = false;
		}
	}

	public override void OnTriggerEnter(Collider collider)
	{
	}

	public override void OnSightTriggerEnter(Collider other)
	{
	}

	public void ExitToPrecinct()
	{
		GameController.instance.audioController.SnapMute(3f);
		GameController.instance.GoToSpecificScene(SCENES.PRECINCT);
	}

	private void OnDestroy()
	{
		EventManager.StopListening(EventManager.AvailableEvents.IntroComplete.ToString(), IntroCompleted);
		EventManager.StopListening(EventManager.AvailableEvents.ExitLevelToPrecint.ToString(), ExitToPrecinct);
		EventManager.StopListening(EventManager.AvailableEvents.RestartScene.ToString(), ExitToPrecinct);
	}

	private void DebugCommands()
	{
		Input.GetKeyDown(KeyCode.Return);
	}

	private IEnumerator SkipIntercom()
	{
		yield return null;
	}
}
public class TitlesScene : MonoBehaviour
{
	private NVRPlayer player;

	private Light playerLight;

	[Header("General")]
	[SerializeField]
	private GameObject playerStartPosition;

	[SerializeField]
	private HintManager hintManager;

	[SerializeField]
	private Light redLight;

	[SerializeField]
	private ParticleSystem dustParticles;

	[Space]
	[Header("Titles")]
	[SerializeField]
	private UnityEngine.UI.Image img;

	[SerializeField]
	private Sprite title00;

	[SerializeField]
	private Sprite title01;

	[SerializeField]
	private Sprite title02;

	[SerializeField]
	private Sprite title03;

	[SerializeField]
	private Sprite title04;

	[SerializeField]
	private TextMeshProUGUI titleTranslation;

	[Space]
	[Header("Sound")]
	[SerializeField]
	private AudioScript musicScript;

	[SerializeField]
	private AudioClip sting;

	private float waitTime = 2f;

	private void Start()
	{
		player = GameObject.FindGameObjectWithTag("Player").GetComponent<NVRPlayer>();
		player.SetPosition(playerStartPosition);
		if (player.movement != null)
		{
			player.movement.DisableEverything();
		}
		player.screenFX.Fade(UnityEngine.Color.black, 0f);
		GameController.instance.audioController.SnapMute(0f);
		playerLight = GameObject.Find("Player/Pvr_UnitySDK/PlayerLight").GetComponent<Light>();
		playerLight.enabled = false;
		img.CrossFadeAlpha(0f, 0f, ignoreTimeScale: true);
		redLight.enabled = false;
		dustParticles.Stop();
		titleTranslation.gameObject.SetActive(value: false);
		StartCoroutine(RunTitles());
	}

	private IEnumerator RunTitles()
	{
		GameController.instance.audioController.SnapAllOpen(1.5f);
		musicScript.Play(sting);
		player.screenFX.Fade(UnityEngine.Color.clear, 2f);
		musicScript.Play(sting);
		img.sprite = title00;
		img.CrossFadeAlpha(1f, waitTime, ignoreTimeScale: true);
		img.rectTransform.localScale = new Vector3(0.7f, 0.7f, 0.7f);
		yield return Yield.WaitSeconds(waitTime * 1.5f);
		img.CrossFadeAlpha(0f, waitTime, ignoreTimeScale: true);
		yield return Yield.WaitSeconds(waitTime * 1f);
		img.sprite = title01;
		img.rectTransform.localScale = new Vector3(1.2f, 1.2f, 1.2f);
		img.CrossFadeAlpha(1f, waitTime, ignoreTimeScale: true);
		yield return Yield.WaitSeconds(waitTime * 1.5f);
		img.CrossFadeAlpha(0f, waitTime, ignoreTimeScale: true);
		yield return Yield.WaitSeconds(waitTime * 1f);
		img.sprite = title02;
		img.rectTransform.localScale = new Vector3(1f, 1f, 1f);
		img.CrossFadeAlpha(1f, waitTime, ignoreTimeScale: true);
		yield return Yield.WaitSeconds(waitTime * 1.45f);
		img.CrossFadeAlpha(0f, waitTime, ignoreTimeScale: true);
		yield return Yield.WaitSeconds(waitTime * 1f);
		img.sprite = title03;
		img.rectTransform.localScale = new Vector3(1f, 1f, 1f);
		img.CrossFadeAlpha(1f, waitTime, ignoreTimeScale: true);
		yield return Yield.WaitSeconds(waitTime * 1.4f);
		img.CrossFadeAlpha(0f, waitTime, ignoreTimeScale: true);
		yield return Yield.WaitSeconds(waitTime * 2f);
		dustParticles.Play();
		redLight.enabled = true;
		img.sprite = title04;
		img.rectTransform.localScale = new Vector3(1.6f, 1.6f, 1.6f);
		img.CrossFadeAlpha(1f, 0f, ignoreTimeScale: true);
		if (GameController.instance.translator.Language != 0)
		{
			StartCoroutine(FadeTranslationText(enabled: true, 0f));
			titleTranslation.gameObject.SetActive(value: true);
		}
		yield return Yield.WaitSeconds(waitTime * 4f);
		img.CrossFadeAlpha(0f, waitTime, ignoreTimeScale: true);
		if (GameController.instance.translator.Language != 0)
		{
			StartCoroutine(FadeTranslationText(enabled: false, 2f));
		}
		yield return Yield.WaitSeconds(waitTime * 1.5f);
		GameController.instance.audioController.SnapMute(3f);
		player.screenFX.Fade(UnityEngine.Color.black, 3f);
		yield return Yield.WaitSeconds(waitTime * 1.5f);
		player.HandMenu.LockMenu(locked: false);
		GameController.instance.GoToSpecificScene(SCENES.PRECINCT);
	}

	private IEnumerator FadeTranslationText(bool enabled, float time)
	{
		UnityEngine.Color col = titleTranslation.color;
		if (time != 0f)
		{
			titleTranslation.color = new UnityEngine.Color(col.r, col.g, col.b, (!enabled) ? 1 : 0);
			for (float counter = 0f; counter < time; counter += Time.deltaTime)
			{
				float num = 1f / time * counter;
				titleTranslation.color = new UnityEngine.Color(col.r, col.g, col.b, enabled ? num : (1f - num));
				yield return Yield.EndOfFrame;
			}
		}
		else
		{
			titleTranslation.color = new UnityEngine.Color(col.r, col.g, col.b, enabled ? 1 : 0);
		}
	}
}
public class TombScene : InteractionManager
{
	[Serializable]
	public class AchievementItemStruct
	{
		public GameObject achievementObject;

		public bool completed;
	}

	private bool introComplete;

	private NVRPlayer player;

	private LightFlicker playerLightFlicker;

	private Camera playerCamera;

	private Light PicoLight;

	private int debugCount;

	[Header("General")]
	[SerializeField]
	private GameObject playerStartPosition;

	[SerializeField]
	private GameObject playerStartLake;

	[SerializeField]
	private GameObject playerStartPodium;

	[SerializeField]
	private GameObject[] changeLayerObjects;

	[SerializeField]
	private OilLighterLookAtC5 oilLighterLookAt;

	[SerializeField]
	private ReflectionProbe arenaTunnelProbe;

	private OilLighter lighter;

	private SaltSprayer saltSprayer;

	public bool crossSelected;

	public bool crossCharged;

	private GameObject cross;

	private TuneController tuneCross;

	private ExorcismItem interactableCross;

	[Space]
	[Header("General")]
	[SerializeField]
	private TombFloatingAudioManager tombFloatingAudioManager;

	[SerializeField]
	private PlayerPositionalAudioManager playerPositionalAudioManager;

	[SerializeField]
	private AudioScript playerPositionalAudioScript;

	[SerializeField]
	private TorchManager torchManager;

	private bool pickedUpFirstTorch;

	[Space]
	[Header("Areas/Rooms")]
	[SerializeField]
	private Room caveRoom;

	[SerializeField]
	private Room caveMazeConnectorRoom;

	[SerializeField]
	private Room centralMazeRoom;

	[SerializeField]
	private Room mazeRoute1Room;

	[SerializeField]
	private Room mazeRoute2Room;

	[SerializeField]
	private Room cellRoom;

	[SerializeField]
	private Room mazeRoute3Room;

	[SerializeField]
	private Room chapelRoom;

	[SerializeField]
	private Room arenaRoom;

	[SerializeField]
	private GameObject arenaMercury;

	private float arenaMercuryInitalYPos;

	[Space]
	[Header("Fade In")]
	[SerializeField]
	private TextMeshProUGUI chapterName;

	[SerializeField]
	private TextMeshProUGUI chapterNumber;

	[Space]
	[Header("Inital Cave")]
	[SerializeField]
	public BatSwarm caveBatSwarm;

	[SerializeField]
	private GameObject pulley;

	[SerializeField]
	private MazeEntranceDoor mazeEntranceDoor;

	[SerializeField]
	private GameObject firstTorch;

	[Space]
	[Header("Maze")]
	[SerializeField]
	private MazeController maze;

	private bool mazeCompleted;

	[SerializeField]
	private GameObject caveMazeConnectorBlockingTrigger;

	[SerializeField]
	private GameObject caveMazeConnectorBlocker;

	[SerializeField]
	private GameObject caveMazeConnectorTorch;

	[SerializeField]
	private BatSwarm mazeCaveBatSwarm;

	[SerializeField]
	private BatSwarm mazeCorridoorBatSwarm;

	[SerializeField]
	private MazeCell cell;

	[SerializeField]
	private MazeChapel chapel;

	[SerializeField]
	private InteractiveDoor chapelExitDoor;

	[SerializeField]
	private GameObject bridgeNavBlock;

	[SerializeField]
	private Transform playerWellParent;

	[SerializeField]
	private GameObject bridge;

	[SerializeField]
	private UltimateVRRope bridgeRope;

	private bool snappedRope;

	private bool canInteractWithBridgeRope;

	private bool lightFading;

	private bool lightFadingRoute2;

	[SerializeField]
	private GameObject deadEndPicLight;

	[SerializeField]
	private GameObject deadEndPicDark;

	[SerializeField]
	private UltimateVRRope centralWellRope;

	[SerializeField]
	private CandleSet miniShrineCandles;

	[SerializeField]
	private ParticleSystem miniShrineParticles;

	[SerializeField]
	private GameObject wellRopeInteractable;

	[SerializeField]
	private GameObject tunnelRopeHintObject;

	[SerializeField]
	private AudioScript routeExitAudioScript;

	[SerializeField]
	private AudioClip routeExitAudioClip;

	[SerializeField]
	private ParticleSystem route1ExitParticles;

	[SerializeField]
	private GameObject route1Blocker;

	[SerializeField]
	private ParticleSystem route2_3ExitParticles;

	private bool requiresLighterHint;

	private bool isInCellCentre;

	private bool hasInteractedChapelExitDoor;

	private bool hasHoveredChapelExitDoor;

	private bool openedChapelExitDoor;

	private bool teleportedToLake;

	private bool sprayedFatherBell;

	private bool grabbedMazeWellRope;

	private bool canInteractWithCentralWellRope;

	[Space]
	[Header("Arena Cave")]
	[SerializeField]
	private Boat boat;

	private bool interactedWithRope;

	[SerializeField]
	private GameObject lookAtObjectForPaz;

	[Space]
	[Header("Finale")]
	[SerializeField]
	private Pazuzu pazuzu;

	[SerializeField]
	private GameObject pazuzuHips;

	[SerializeField]
	private GameObject podiumNavMeshBlock;

	[SerializeField]
	private GameObject podiumFireNavMeshBlock;

	[SerializeField]
	private GameObject podiumGrabPoint;

	[SerializeField]
	private ParticleSystem podiumFire;

	[SerializeField]
	private LightFlicker podiumFireLight;

	[SerializeField]
	private ParticleSystem pazDarknessParticles;

	[SerializeField]
	private FireObstacleC5 podiumFireCollider;

	[SerializeField]
	private PazDarkness pazDarkness;

	[SerializeField]
	private Transform floatingAudioArenaPoint;

	[SerializeField]
	private Material podiumBurnMat;

	[SerializeField]
	public GameObject lightBeams;

	[SerializeField]
	public GameObject lightCrack;

	private bool hasGrabbedPodium;

	public bool hasSeenPazuzuAttack1;

	public bool hasSeenPazuzuAttack2;

	public bool seenPazuzuPossession;

	public bool seenPazuzuDeath;

	[Space]
	[Header("Arena Lighting")]
	[SerializeField]
	public Light arenaSpotLight;

	[SerializeField]
	public Light arenaAmbientLight;

	[SerializeField]
	public float ambientLightTargetRange;

	[SerializeField]
	private Renderer podiumRenderer;

	[SerializeField]
	private Texture2D podiumEmSymbol;

	[SerializeField]
	private Texture2D podiumEmCrack;

	[SerializeField]
	public Texture2D arenaSpotLightCookieLarge;

	[SerializeField]
	public Texture2D arenaSpotLightCrackSmall;

	[SerializeField]
	public Texture2D arenaSpotLightCrackLarge;

	[SerializeField]
	public Material lightCrackMat;

	[Space]
	[Header("Area Triggers")]
	[SerializeField]
	private GameObject centralMazeLightTrigger;

	[SerializeField]
	private GameObject mazeRoute1LightTrigger;

	[SerializeField]
	private GameObject mazeRoute1Part1CaveTrigger;

	[SerializeField]
	private GameObject mazeRoute1Part1EndTrigger;

	[SerializeField]
	private GameObject mazeRoute1Part2EndTrigger;

	[SerializeField]
	private GameObject mazeRoute1Part3EndTrigger;

	[SerializeField]
	private GameObject mazeRoute1ExitTrigger;

	[SerializeField]
	private GameObject mazeRoute2LightTrigger;

	[SerializeField]
	private GameObject mazeRoute2ExitLeftTrigger;

	[SerializeField]
	private GameObject mazeRoute2ExitRightTrigger;

	[SerializeField]
	private GameObject mazeRoute3ExitLeftTrigger;

	[SerializeField]
	private GameObject mazeRoute3ExitRightTrigger;

	[SerializeField]
	private GameObject caveDoorCloseTrigger;

	[SerializeField]
	private GameObject mazeRoute3LightTrigger;

	[SerializeField]
	private GameObject mazeRoute3MaryWhisperTrigger;

	[SerializeField]
	private GameObject mazeRoute3MaryTurnOffTrigger;

	[SerializeField]
	private GameObject mazeDisableChapelTrigger;

	[SerializeField]
	private GameObject cellEntranceAreaTrigger;

	[SerializeField]
	private GameObject cellCentreAreaTrigger;

	[SerializeField]
	private GameObject cellEntranceWallAreaTrigger;

	[SerializeField]
	private GameObject cellCloseExitDoorTrigger;

	[SerializeField]
	private GameObject cellCloseExitDoorFailsafeTrigger;

	[SerializeField]
	private GameObject cellCaveCentreTrigger;

	[SerializeField]
	private GameObject chapelAreaTrigger;

	[SerializeField]
	private GameObject chapelCloseExitDoorFailsafeTrigger;

	[SerializeField]
	private GameObject chapelExitDoorAreaTrigger;

	[SerializeField]
	private GameObject chapelExitTrigger;

	[SerializeField]
	private GameObject chapelEntranceTrigger;

	[SerializeField]
	private GameObject caveBatsTrigger;

	[SerializeField]
	private GameObject mazeCaveBatsTrigger;

	[SerializeField]
	private GameObject mazeCorridoorBatsTrigger;

	[SerializeField]
	private GameObject musicMazeBedTrigger;

	[SerializeField]
	private GameObject musicMazeBedCellTrigger;

	[SerializeField]
	private GameObject musicMaze2BuildTrigger;

	[SerializeField]
	private GameObject musicMaze3BuildTrigger;

	[SerializeField]
	private GameObject musicBedMinimalTrigger;

	[SerializeField]
	private GameObject voFatherBellLostTapeTrigger;

	[SerializeField]
	private GameObject musicFinaleBuildTrigger;

	[SerializeField]
	private GameObject deadEndTrigger1;

	[SerializeField]
	private GameObject deadEndTrigger2;

	[SerializeField]
	private GameObject deadEndTrigger3;

	[SerializeField]
	private GameObject rockEchoMaze;

	[SerializeField]
	private GameObject pazShadow01Trigger;

	private bool inCellCaveCentreTrigger;

	private bool inMaryAreaTrigger;

	private bool inCellEntranceAreaTrigger;

	private bool inCellEntranceWallAreaTrigger;

	private bool inChapelAreaTrigger;

	private bool inPazDarkness01Trigger;

	private bool inChapelExitDoorAreaTrigger;

	private bool lookedAtChapelExitDoor;

	private bool deactivatedCellEntranceDoor;

	private bool deactivatedCellExitDoor;

	private bool inPazShadowRoute2Trigger;

	private bool inCloseCellDoorAreaTrigger;

	private bool inChapelCloseExitAreaTrigger;

	private bool lookingAtMazeRoute2Or3ExitSightTrigger;

	private bool lookingAtMazeRoute1ExitSightTrigger;

	[Space]
	[Header("Sight Triggers")]
	[SerializeField]
	private GameObject cellEntranceSightTrigger;

	[SerializeField]
	private GameObject cellEntranceWallSightTrigger;

	[SerializeField]
	private GameObject cellExitWallSightTrigger;

	[SerializeField]
	private GameObject cellWallSightTriggerRight;

	[SerializeField]
	private GameObject cellWallSightTriggerLeft;

	[SerializeField]
	private GameObject cellCrossSightTrigger;

	[SerializeField]
	private GameObject cellCloseExitSightTrigger;

	[SerializeField]
	private GameObject mazeMarySightTrigger;

	[SerializeField]
	private GameObject mazeMaryLookingAwaySightTrigger;

	[SerializeField]
	private GameObject pazShadow01SightTrigger;

	[SerializeField]
	private GameObject pazShadowRoute2SightTrigger;

	[SerializeField]
	private GameObject chapelSightTrigger;

	[SerializeField]
	private GameObject chapelBookCaseSightTrigger;

	[SerializeField]
	private GameObject chapelChairSightTrigger;

	[SerializeField]
	private GameObject chapelExitDoorSightTrigger;

	[SerializeField]
	private GameObject chapelPigManSightTrigger;

	[SerializeField]
	private GameObject chapelCloseExitDoorSightTrigger;

	[SerializeField]
	public GameObject pazuzuAttack1SightTrigger;

	[SerializeField]
	public GameObject pazuzuAttack2SightTrigger;

	[SerializeField]
	public GameObject pazuzuEmergeTrigger;

	[SerializeField]
	public GameObject pazuzuWeakenedSightTrigger;

	[SerializeField]
	public GameObject mazeRoute2Or3ExitSightTrigger;

	[SerializeField]
	public GameObject mazeRoute1ExitSightTrigger;

	private bool lookingAwayFromMary;

	private bool seenPazuzuShadowTrigger;

	[Space]
	[Header("Audio")]
	[SerializeField]
	private AudioScript foleyCave;

	[SerializeField]
	private AudioClip foleyCaveClip;

	[SerializeField]
	private AudioScript foleyMaze;

	[SerializeField]
	private AudioClip foleyMazeClip;

	[SerializeField]
	private AudioClip[] floatingClips;

	[SerializeField]
	private Transform[] floatingPoints;

	[SerializeField]
	private Transform[] arenaFloatingAudio;

	private AudioSource[] allAudio;

	[SerializeField]
	public AudioScript musicStem01;

	[SerializeField]
	public AudioScript musicStem02;

	[SerializeField]
	public AudioScript musicStem03;

	[SerializeField]
	private AudioScript arenaFireAudio;

	[SerializeField]
	public AudioScript fallingRockLoopAudio;

	[Space]
	[Header("AudioClips")]
	[SerializeField]
	private AudioClip musicBed;

	[SerializeField]
	private AudioClip musicBedMinimal;

	[SerializeField]
	private AudioClip musicBedPerc;

	[SerializeField]
	public AudioClip musicBuildSiren;

	[SerializeField]
	public AudioClip musicBuildLight;

	[SerializeField]
	public AudioClip musicBuildWhipsers;

	[SerializeField]
	private AudioClip musicBuildBoat;

	[SerializeField]
	private AudioClip arenaFireLoopClip;

	[SerializeField]
	private AudioClip arenaFireDouceClip;

	[SerializeField]
	public AudioClip earthquakeClip;

	[SerializeField]
	private AudioClip musicStingBassDrop;

	[SerializeField]
	private AudioClip musicDrums01;

	[SerializeField]
	public AudioClip musicDrums02;

	[SerializeField]
	public AudioClip musicDrums03;

	[SerializeField]
	private AudioClip pazVOFightTaunt;

	[SerializeField]
	public AudioClip fallingRockLoopClip;

	[SerializeField]
	public AudioClip musicBuildHighwire;

	[SerializeField]
	public AudioClip musicPlayoutFinale;

	[SerializeField]
	public AudioClip voPazGrowlLoop;

	[SerializeField]
	public AudioClip musicPazEnter;

	[SerializeField]
	private AudioClip rockClimbTransition;

	[SerializeField]
	private AudioClip sandDropSFX;

	[SerializeField]
	private AudioClip[] windForTorches;

	[Space]
	[Header("Lightbeam Colors")]
	[SerializeField]
	private UnityEngine.Color lightBeamColorStart;

	[SerializeField]
	public UnityEngine.Color lightBeamColorEnd;

	[Space]
	[Header("Achievements")]
	[SerializeField]
	private AchievementItemStruct[] allBonesOfTheDead;

	[HideInInspector]
	private bool foundAllBones;

	[SerializeField]
	private AchievementItemStruct[] allCandlesAndFires;

	[HideInInspector]
	private bool litAllFiresAndCandles;

	[HideInInspector]
	private bool smashedGlassOnHead;

	[HideInInspector]
	private bool noDeadEnds = true;

	[HideInInspector]
	private bool noHints = true;

	private const float kOilLighterHintTime = 90f;

	private const float kHolyWaterHintTime = 90f;

	private const float kSaltSprayHintTime = 35f;

	private const float kBellVOCrossHintTime = 5f;

	private Coroutine exKitHintRoutine;

	private bool debugSetOffset1;

	private bool debugSetOffset2;

	[Space]
	[Space]
	[Header("DEBUG")]
	[SerializeField]
	private GameObject debugPlayerMazeCentreLocation;

	[SerializeField]
	private GameObject debugPlayerOutsideCell;

	[SerializeField]
	private GameObject debugPlayerOutsideChapel;

	private bool debugHasLookedAtBridge;

	private bool debugHasFinishedCell;

	private bool debugHasFinishedChapel;

	private bool usingEditorDebug;

	private void Start()
	{
		EventManager.StartListening(EventManager.AvailableEvents.IntroComplete.ToString(), IntroCompleted);
		EventManager.StartListening(EventManager.AvailableEvents.SmashedGlassOffFatherBell.ToString(), smashedGlassOffFatherBell);
		EventManager.StartListening(EventManager.AvailableEvents.ExitLevelToPrecint.ToString(), ExitToPrecinct);
		EventManager.StartListening(EventManager.AvailableEvents.RestartScene.ToString(), RestartLevel);
		EventManager.StartListening(EventManager.AvailableEvents.ResetProgress.ToString(), ResetProgress);
		player = GameController.instance.player;
		playerCamera = player.Head.GetComponentInChildren<Camera>();
		player.SetPosition(playerStartPosition);
		if ((bool)player.movement)
		{
			player.movement.DisableEverything();
		}
		GameController.instance.audioController.SnapMute(0f);
		if ((bool)player.screenFX)
		{
			player.screenFX.Fade(UnityEngine.Color.black, 0f);
		}
		if ((bool)player.fishEyeFX)
		{
			player.fishEyeFX.enabled = false;
		}
		playerLightFlicker = player.playerLight.GetComponent<LightFlicker>();
		PicoLight = player.PicoLight.GetComponent<Light>();
		player.playerLight.GetComponent<Light>().enabled = true;
		player.playerLight.enabled = true;
		playerLightFlicker.light.enabled = true;
		playerLightFlicker.SwitchLight(switchOn: false);
		playerLightFlicker.light.shadows = LightShadows.None;
		player.playerLight.EnableRay(enable: false);
		player.playerLight.SetRange(6f);
		player.playerLight.SetAngle(120f);
		player.playerLight.RemovePlayerLightCookie();
		player.PicoLight.SetActive(value: true);
		PicoLight.enabled = true;
		foleyCave.transform.position = player.Head.transform.position;
		foleyCave.transform.parent = player.Head.transform;
		foleyMaze.transform.position = player.Head.transform.position;
		foleyMaze.transform.parent = player.Head.transform;
		lighter = player.HandMenu.exKitScript.candle.GetComponent<OilLighter>();
		lighter.canTurnOnLight = false;
		saltSprayer = player.HandMenu.exKitScript.salt.GetComponent<SaltSprayer>();
		cross = player.HandMenu.exKitScript.cross;
		tuneCross = cross.GetComponent<TuneController>();
		tuneCross.SetSpotLightEnabled(enabled: true);
		tuneCross.SetPointLightEnabled(enabled: true);
		interactableCross = cross.GetComponent<ExorcismItem>();
		float[] array = new float[32];
		array[14] = 15f;
		playerCamera.layerCullDistances = array;
		lightCrackMat.mainTexture = arenaSpotLightCrackSmall;
		player.mainCamera.farClipPlane = 1000f;
		GameObject[] array2 = changeLayerObjects;
		for (int i = 0; i < array2.Length; i++)
		{
			array2[i].SetLayer(SortingLayer.NameToID("Default"));
		}
		allAudio = UnityEngine.Object.FindObjectsOfType(typeof(AudioSource)) as AudioSource[];
		StartCoroutine(Master());
	}

	private void IntroCompleted()
	{
		introComplete = true;
	}

	public void Update()
	{
	}

	private IEnumerator Master()
	{
		GameController.instance.currentRoom = caveRoom;
		caveRoom.UpdateColliders(enabled: false);
		caveRoom.associatedParentGameObject.SetActive(value: true);
		caveRoom.playerInRoom = true;
		caveMazeConnectorRoom.UpdateColliders(enabled: false);
		caveMazeConnectorRoom.associatedParentGameObject.SetActive(value: true);
		caveMazeConnectorRoom.playerInRoom = false;
		centralMazeRoom.UpdateColliders(enabled: true);
		centralMazeRoom.associatedParentGameObject.SetActive(value: false);
		centralMazeRoom.playerInRoom = false;
		mazeRoute1Room.UpdateColliders(enabled: true);
		mazeRoute1Room.associatedParentGameObject.SetActive(value: false);
		mazeRoute1Room.playerInRoom = false;
		mazeRoute2Room.UpdateColliders(enabled: true);
		mazeRoute2Room.associatedParentGameObject.SetActive(value: false);
		mazeRoute2Room.playerInRoom = false;
		cellRoom.UpdateColliders(enabled: true);
		cellRoom.associatedParentGameObject.SetActive(value: false);
		cellRoom.playerInRoom = false;
		mazeRoute3Room.UpdateColliders(enabled: true);
		mazeRoute3Room.associatedParentGameObject.SetActive(value: false);
		mazeRoute3Room.playerInRoom = false;
		chapelRoom.UpdateColliders(enabled: true);
		chapelRoom.associatedParentGameObject.SetActive(value: false);
		chapelRoom.playerInRoom = false;
		arenaRoom.associatedParentGameObject.SetActive(value: false);
		pazDarkness.gameObject.SetActive(value: false);
		yield return StartCoroutine(SceneSetup());
		yield return StartCoroutine(FadeInScene());
		yield return StartCoroutine(MazeRoutine());
		yield return StartCoroutine(MazeToLakeRoutine());
		yield return StartCoroutine(ArenaRoutine());
		yield return StartCoroutine(FinaleRoutine());
		yield return StartCoroutine(FadeOutScene());
	}

	private IEnumerator SceneSetup()
	{
		yield return Yield.WaitSeconds(4f);
		bridgeNavBlock.SetActive(value: true);
		pazuzu.gameObject.SetActive(value: false);
		caveBatsTrigger.SetActive(value: true);
		caveMazeConnectorTorch.SetActive(value: false);
		caveMazeConnectorBlocker.SetActive(value: false);
		mazeRoute3MaryWhisperTrigger.SetActive(value: false);
		mazeRoute3MaryTurnOffTrigger.SetActive(value: false);
		mazeMarySightTrigger.SetActive(value: false);
		mazeMaryLookingAwaySightTrigger.SetActive(value: false);
		pazShadow01SightTrigger.SetActive(value: false);
		pazShadowRoute2SightTrigger.SetActive(value: false);
		caveDoorCloseTrigger.SetActive(value: true);
		cellEntranceAreaTrigger.SetActive(value: false);
		cellCentreAreaTrigger.SetActive(value: false);
		cellCloseExitDoorTrigger.SetActive(value: false);
		cellCloseExitSightTrigger.SetActive(value: false);
		cellCloseExitDoorFailsafeTrigger.SetActive(value: false);
		mazeDisableChapelTrigger.SetActive(value: false);
		cellCaveCentreTrigger.SetActive(value: false);
		cellCrossSightTrigger.SetActive(value: false);
		cellEntranceWallAreaTrigger.SetActive(value: false);
		cellEntranceSightTrigger.SetActive(value: false);
		cellEntranceWallSightTrigger.SetActive(value: false);
		cellExitWallSightTrigger.SetActive(value: false);
		cellWallSightTriggerLeft.SetActive(value: false);
		cellWallSightTriggerRight.SetActive(value: false);
		chapelSightTrigger.SetActive(value: false);
		chapelAreaTrigger.SetActive(value: false);
		mazeCaveBatsTrigger.SetActive(value: false);
		mazeCorridoorBatsTrigger.SetActive(value: false);
		deadEndTrigger1.SetActive(value: false);
		deadEndTrigger2.SetActive(value: true);
		deadEndTrigger3.SetActive(value: true);
		deadEndPicLight.SetActive(value: true);
		deadEndPicDark.SetActive(value: false);
		tombFloatingAudioManager.whisperAudioContainer[6].trigger.SetActive(value: true);
		chapelChairSightTrigger.SetActive(value: false);
		chapelBookCaseSightTrigger.SetActive(value: false);
		chapelExitDoorAreaTrigger.SetActive(value: false);
		chapelExitDoorSightTrigger.SetActive(value: false);
		chapelPigManSightTrigger.SetActive(value: false);
		chapelCloseExitDoorFailsafeTrigger.SetActive(value: false);
		chapelCloseExitDoorSightTrigger.SetActive(value: false);
		chapelExitTrigger.SetActive(value: false);
		pazuzuAttack1SightTrigger.SetActive(value: false);
		pazuzuAttack2SightTrigger.SetActive(value: false);
		lookAtObjectForPaz.transform.position = player.Head.transform.position;
		lookAtObjectForPaz.transform.parent = player.Head.transform;
		arenaSpotLight.gameObject.SetActive(value: false);
		arenaAmbientLight.gameObject.SetActive(value: false);
		podiumNavMeshBlock.gameObject.SetActive(value: false);
		arenaTunnelProbe.gameObject.SetActive(value: false);
		podiumFireNavMeshBlock.gameObject.SetActive(value: true);
		musicMazeBedTrigger.SetActive(value: false);
		musicMaze2BuildTrigger.SetActive(value: false);
		musicMaze3BuildTrigger.SetActive(value: false);
		musicBedMinimalTrigger.SetActive(value: false);
		player.HandMenu.BookInMenu(active: true);
		player.HandMenu.KitInMenu(active: true);
		chapel.exitDoor.OnHovering.AddListener(delegate
		{
			OnHoverMazeExitDoor();
		});
		miniShrineCandles.OnLightCallback = MiniShrineLightCandleSet;
		podiumRenderer.sharedMaterial.SetTexture("_EmissionMap", podiumEmSymbol);
		podiumRenderer.sharedMaterial.SetColor("_EmissionColor", UnityEngine.Color.white);
		pazuzuEmergeTrigger.SetActive(value: false);
		mazeRoute1ExitTrigger.SetActive(value: false);
		mazeRoute2ExitLeftTrigger.SetActive(value: false);
		mazeRoute2ExitRightTrigger.SetActive(value: false);
		mazeRoute3ExitLeftTrigger.SetActive(value: false);
		mazeRoute3ExitRightTrigger.SetActive(value: false);
		mazeEntranceDoor.navmeshObstacleInCave.SetActive(value: false);
		arenaMercuryInitalYPos = arenaMercury.transform.position.y;
		arenaMercury.transform.position = new Vector3(arenaMercury.transform.position.x, 100f, arenaMercury.transform.position.z);
		yield return new WaitForSeconds(0.25f);
	}

	private IEnumerator FadeInScene()
	{
		while (!introComplete)
		{
			yield return null;
		}
		SaveManager.instance.MarkChapterStarted(ChapterID.TOMB);
		playerLightFlicker = player.playerLight.GetComponent<LightFlicker>();
		playerLightFlicker.SetHighIntensity(0.9f);
		foleyCave.PlayLoop(foleyCaveClip);
		GameController.instance.audioController.SnapAllOpen(3f);
		yield return Yield.WaitSeconds(4f);
		if ((bool)player.screenFX)
		{
			player.screenFX.Fade(UnityEngine.Color.clear, 3f);
		}
		OilLighter component = player.HandMenu.exKitScript.candle.GetComponent<OilLighter>();
		component.TogglePlayerLightingLayer(on: false);
		player.playerLight.shouldLightBeOn = true;
		if (component.isOn)
		{
			component.TurnOnLight();
		}
		else
		{
			playerLightFlicker.StartBurst(0.5f, finishOn: true);
		}
		component.canTurnOnLight = true;
		yield return Yield.WaitSeconds(0.5f);
		player.HandMenu.playerLightsDisable = true;
		GameController.instance.boundDetection.SwitchOnOOB();
		EventManager.TriggerEvent(EventManager.AvailableEvents.SwitchedScenes.ToString());
		yield return Yield.WaitSeconds(3f);
		chapterName.CrossFadeAlpha(0f, 3f, ignoreTimeScale: false);
		chapterNumber.CrossFadeAlpha(0f, 3f, ignoreTimeScale: false);
		player.movement.EnableEverything();
	}

	private IEnumerator MazeRoutine()
	{
		GameController.instance.hintManager.AddHint(mazeEntranceDoor.pulley);
		while (!mazeEntranceDoor.open)
		{
			yield return Yield.WaitSeconds(0.5f);
		}
		GameController.instance.hintManager.RemoveHint(mazeEntranceDoor.pulley);
		musicBedMinimalTrigger.SetActive(value: true);
		NVRInteractableItem lighterInteractable = lighter.gameObject.GetComponent<NVRInteractableItem>();
		while ((!oilLighterLookAt.hoveringOverBridge || !lighter.isOn || !lighterInteractable.IsAttached) && !debugHasLookedAtBridge)
		{
			yield return Yield.EndOfFrame;
		}
		maze.mazeBridge.SetActive(value: true);
		if (exKitHintRoutine != null)
		{
			StopCoroutine(exKitHintRoutine);
		}
		torchManager.SetGhostLayerEnabled();
		CancelExKitHint();
		deadEndTrigger1.SetActive(value: true);
		tombFloatingAudioManager.whisperAudioContainer[6].trigger.SetActive(value: true);
		mazeCaveBatsTrigger.SetActive(value: true);
		mazeCorridoorBatsTrigger.SetActive(value: true);
		bridgeNavBlock.SetActive(value: false);
		cellEntranceAreaTrigger.SetActive(value: true);
		cellEntranceSightTrigger.SetActive(value: true);
		musicMaze2BuildTrigger.SetActive(value: true);
		while (cell.doorLocked)
		{
			yield return Yield.WaitSeconds(0.5f);
		}
		GameController.instance.hintManager.AddHint(cell.cellEntranceDoor);
		yield return Yield.WaitSeconds(3.5f);
		cellCentreAreaTrigger.SetActive(value: true);
		cellExitWallSightTrigger.SetActive(value: true);
		while (!cell.IsCellCave())
		{
			yield return Yield.WaitSeconds(0.5f);
		}
		cellCentreAreaTrigger.SetActive(value: false);
		yield return Yield.WaitSeconds(2.5f);
		cellCaveCentreTrigger.SetActive(value: true);
		cellCrossSightTrigger.SetActive(value: true);
		while (!cell.hasCellCaveWhispersFinished)
		{
			yield return Yield.WaitSeconds(0.5f);
		}
		cellCrossSightTrigger.SetActive(value: true);
		exKitHintRoutine = StartCoroutine(ExKitItemHint(NotebookPages.Q07, 90f));
		while (cell.crossFireCollider.IsOnFire)
		{
			yield return Yield.WaitSeconds(0.5f);
		}
		if (exKitHintRoutine != null)
		{
			StopCoroutine(exKitHintRoutine);
		}
		CancelExKitHint();
		while (!cell.hasCellCaveFinished)
		{
			yield return Yield.WaitSeconds(0.5f);
		}
		cellCloseExitDoorTrigger.SetActive(value: true);
		cellCloseExitSightTrigger.SetActive(value: true);
		cellCloseExitDoorFailsafeTrigger.SetActive(value: true);
		chapelAreaTrigger.SetActive(value: true);
		chapelSightTrigger.SetActive(value: true);
		musicMaze3BuildTrigger.SetActive(value: true);
		GameController.instance.hintManager.AddHint(chapel.fatherBellDead);
		saltSprayer.currentTarget = chapel.fatherBellDead;
		while (!saltSprayer.hitTarget)
		{
			yield return Yield.WaitSeconds(0.5f);
		}
		if (exKitHintRoutine != null)
		{
			StopCoroutine(exKitHintRoutine);
		}
		sprayedFatherBell = true;
		CancelExKitHint();
		GameController.instance.hintManager.RemoveHint(chapel.fatherBellDead);
		chapel.RunChapel();
		while (chapel.isRunningCoroutine)
		{
			yield return Yield.WaitSeconds(0.5f);
		}
		chapelBookCaseSightTrigger.SetActive(value: true);
		chapelExitDoorAreaTrigger.SetActive(value: true);
		chapelExitDoorSightTrigger.SetActive(value: true);
		while (!chapel.thrownBooks)
		{
			yield return Yield.WaitSeconds(0.5f);
		}
		lookedAtChapelExitDoor = false;
		GameController.instance.hintManager.AddHint(chapelExitDoor);
		chapelExitDoorSightTrigger.SetActive(value: true);
		while (!chapel.thrownChair)
		{
			yield return Yield.WaitSeconds(0.5f);
		}
		lookedAtChapelExitDoor = false;
		chapelExitDoorAreaTrigger.SetActive(value: false);
		chapelExitDoorSightTrigger.SetActive(value: false);
		chapelPigManSightTrigger.SetActive(value: true);
		while (!chapel.pigManAttackedPlayer)
		{
			yield return Yield.WaitSeconds(0.5f);
		}
		while (!openedChapelExitDoor)
		{
			yield return Yield.EndOfFrame;
		}
		GameController.instance.hintManager.RemoveHint(chapelExitDoor);
		chapelCloseExitDoorFailsafeTrigger.SetActive(value: true);
		chapelCloseExitDoorSightTrigger.SetActive(value: true);
		chapelExitTrigger.SetActive(value: true);
		musicStem03.FadeIn(musicBedPerc, 1f, 6f, loop: true);
		UnityEngine.Debug.Log("Hitting maze center");
		mazeCompleted = true;
		maze.OpenWell();
		GameController.instance.hintManager.AddHint(wellRopeInteractable);
		canInteractWithCentralWellRope = true;
		if (Application.isEditor)
		{
			debugHasFinishedChapel = true;
		}
	}

	public void EnteredCell()
	{
		centralMazeRoom.associatedParentGameObject.SetActive(value: false);
		maze.SwitchRoute(MazeController.MazeState.ROUTE2_CELL);
	}

	public void ExitedCell()
	{
		cell.ceilingLight.SwitchLight(switchOn: false);
		mazeRoute2ExitLeftTrigger.SetActive(value: true);
		mazeRoute2ExitRightTrigger.SetActive(value: true);
		SwitchOnPlayerLight();
		maze.SwitchRoute(MazeController.MazeState.ROUTE2_P2);
		centralMazeRoom.associatedParentGameObject.SetActive(value: true);
	}

	public void EnteredChapel()
	{
		SwitchOffPlayerLight();
		centralMazeRoom.associatedParentGameObject.SetActive(value: false);
		maze.SwitchRoute(MazeController.MazeState.ROUTE3_CHAPEL);
	}

	public void ExitedChapel()
	{
		SwitchOnPlayerLight();
		mazeRoute3ExitLeftTrigger.SetActive(value: true);
		mazeRoute3ExitRightTrigger.SetActive(value: true);
		maze.SwitchRoute(MazeController.MazeState.ROUTE3_P2);
		centralMazeRoom.associatedParentGameObject.SetActive(value: true);
	}

	private void SwitchOffPlayerLight()
	{
		OilLighter component = player.HandMenu.exKitScript.candle.GetComponent<OilLighter>();
		player.playerLight.shouldLightBeOn = false;
		if (component.isOn)
		{
			component.TurnOffLight();
		}
		else if (playerLightFlicker.light.intensity > 0f)
		{
			playerLightFlicker.StartBurst(0.25f, finishOn: false);
		}
		component.canTurnOnLight = false;
	}

	private void SwitchOnPlayerLight()
	{
		_ = player.HandMenu.exKitScript;
		player.playerLight.shouldLightBeOn = true;
		if (lighter.isOn)
		{
			lighter.TurnOnLight();
		}
		else if (playerLightFlicker.light.intensity == 0f)
		{
			playerLightFlicker.StartBurst(0.5f, finishOn: true);
		}
		lighter.canTurnOnLight = true;
	}

	private IEnumerator MazeToLakeRoutine()
	{
		UnityEngine.Debug.Log("Waiting on maze to lake!");
		canInteractWithCentralWellRope = true;
		while (!grabbedMazeWellRope)
		{
			yield return Yield.EndOfFrame;
		}
		GameController.instance.boundDetection.SwitchOffOOB();
		GameController.instance.currentRoom = arenaRoom;
		AudioScript audio = AudioScriptContainer.Instance.audioScripts[1];
		audio.transform.position = floatingPoints[2].position;
		audio.Play(floatingClips[2]);
		player.screenFX.Fade(UnityEngine.Color.black, 1f);
		yield return Yield.WaitSeconds(1f);
		player.movement.DisableMovement();
		mazeRoute1Room.associatedParentGameObject.SetActive(value: false);
		mazeRoute1Room.gameObject.SetActive(value: false);
		mazeRoute2Room.associatedParentGameObject.SetActive(value: false);
		mazeRoute2Room.gameObject.SetActive(value: false);
		mazeRoute3Room.associatedParentGameObject.SetActive(value: false);
		mazeRoute3Room.gameObject.SetActive(value: false);
		caveMazeConnectorRoom.associatedParentGameObject.SetActive(value: false);
		caveMazeConnectorRoom.gameObject.SetActive(value: false);
		GameController.instance.boundDetection.SwitchOnOOB();
		arenaRoom.SwitchOffOOB();
		if (!debugSetOffset1)
		{
			debugSetOffset1 = true;
			player.transform.parent = playerWellParent.transform;
			player.transform.localPosition = Vector3.zero;
			yield return Yield.EndOfFrame;
			Vector3 vector = player.transform.position - player.Head.transform.position;
			player.transform.position += new Vector3(vector.x, 0f, vector.z);
		}
		yield return Yield.WaitSeconds(2f);
		LeanTween.moveLocalY(player.gameObject, -5.5f, 9f);
		player.screenFX.Fade(UnityEngine.Color.clear, 1.5f);
		yield return Yield.WaitSeconds(0.5f);
		audio.transform.position = player.Head.transform.position;
		audio.Play(floatingClips[3]);
		yield return Yield.WaitSeconds(1.5f);
		player.screenFX.Fade(UnityEngine.Color.black, 1f);
		yield return Yield.WaitSeconds(3f);
		player.screenFX.Fade(UnityEngine.Color.clear, 1.5f);
		yield return Yield.WaitSeconds(0.5f);
		audio.transform.position = player.Head.transform.position;
		audio.Play(floatingClips[4]);
		musicStem03.FadeVolumeOut(3f, 0.5f);
		yield return Yield.WaitSeconds(1.5f);
		player.screenFX.Fade(UnityEngine.Color.black, 1f);
		yield return Yield.WaitSeconds(1f);
		SwitchOffPlayerLight();
		torchManager.canIgniteOnRespawn = true;
		Torch torch2 = null;
		if ((bool)player.LeftHand.CurrentlyInteracting)
		{
			torch2 = player.LeftHand.CurrentlyInteracting.GetComponent<Torch>();
			if ((bool)torch2)
			{
				torch2.lockedToHand = true;
			}
			else
			{
				torchManager.SetTempRespawnDuration(0f);
			}
		}
		if ((bool)player.RightHand.CurrentlyInteracting)
		{
			torch2 = player.RightHand.CurrentlyInteracting.GetComponent<Torch>();
			if ((bool)torch2)
			{
				torch2.lockedToHand = true;
			}
			else
			{
				torchManager.SetTempRespawnDuration(0f);
			}
		}
		yield return Yield.WaitSeconds(2f);
		arenaRoom.associatedParentGameObject.SetActive(value: true);
		arenaMercury.transform.position = new Vector3(arenaMercury.transform.position.x, arenaMercuryInitalYPos, arenaMercury.transform.position.z);
		arenaTunnelProbe.gameObject.SetActive(value: true);
		podiumFireLight.SwitchLight(switchOn: false);
		if (!torch2)
		{
			torchManager.IgniteTorches(playAudio: true);
			torchManager.RemoveTempRespawnDuration();
		}
		if (!debugSetOffset2)
		{
			debugSetOffset2 = true;
			Quaternion quaternion = playerStartLake.transform.rotation * Quaternion.Inverse(player.Head.transform.localRotation);
			player.transform.rotation = Quaternion.Euler(0f, quaternion.eulerAngles.y, 0f);
			playerWellParent.transform.position = playerStartLake.transform.position;
			player.transform.localPosition = Vector3.zero;
			yield return Yield.EndOfFrame;
			Vector3 vector2 = player.transform.position - player.Head.transform.position;
			player.transform.position += new Vector3(vector2.x, 0f, vector2.z);
			yield return Yield.EndOfFrame;
			player.transform.parent = null;
		}
		GameController.instance.hintManager.AddHint(tunnelRopeHintObject);
		player.screenFX.Fade(UnityEngine.Color.clear, 4f);
		player.mainCamera.farClipPlane = 1000f;
		yield return Yield.WaitSeconds(4f);
		centralMazeRoom.associatedParentGameObject.SetActive(value: false);
		centralMazeRoom.gameObject.SetActive(value: false);
		boat.canInteract = true;
		if ((bool)torch2)
		{
			torch2.lockedToHand = false;
		}
		player.movement.EnableMovement();
		player.movement.rotationEnabled = true;
		player.screenFX.isFading = false;
		while (!interactedWithRope)
		{
			yield return Yield.EndOfFrame;
		}
		arenaFireAudio.PlayLoop(arenaFireLoopClip);
		GameController.instance.hintManager.AddHint(podiumGrabPoint);
		while (!hasGrabbedPodium)
		{
			yield return Yield.EndOfFrame;
		}
		GameController.instance.hintManager.RemoveHint(podiumGrabPoint);
		player.movement.DisableEverything();
		player.screenFX.Fade(UnityEngine.Color.black, 0.5f);
		AudioScript obj = AudioScriptContainer.Instance.audioScripts[0];
		obj.transform.position = floatingPoints[3].position;
		obj.Play(rockClimbTransition);
		yield return Yield.WaitSeconds(0.5f);
		musicStem01.FadeIn(musicBuildSiren, 0.2f, 4f, loop: true);
		StartCoroutine(ExtinguishTorchesWithSFX(AudioScriptContainer.Instance.audioScripts[2], floatingPoints[6], windForTorches[0]));
		torch2 = null;
		if ((bool)player.LeftHand.CurrentlyInteracting)
		{
			torch2 = player.LeftHand.CurrentlyInteracting.GetComponent<Torch>();
			if ((bool)torch2)
			{
				player.LeftHand.ForceDropItem();
			}
		}
		if ((bool)player.RightHand.CurrentlyInteracting)
		{
			torch2 = player.RightHand.CurrentlyInteracting.GetComponent<Torch>();
			if ((bool)torch2)
			{
				player.RightHand.ForceDropItem();
			}
		}
		player.SetPosition(playerStartPodium);
		yield return Yield.WaitSeconds(3f);
		if ((bool)torch2)
		{
			torch2.gameObject.SetActive(value: false);
		}
		player.screenFX.Fade(UnityEngine.Color.clear, 0.5f);
		yield return Yield.WaitSeconds(0.5f);
		player.movement.EnableEverything();
	}

	private IEnumerator ArenaRoutine()
	{
		podiumNavMeshBlock.SetActive(value: true);
		exKitHintRoutine = StartCoroutine(ExKitItemHint(NotebookPages.Q07, 90f));
		podiumFireCollider.active = true;
		while (podiumFireCollider.IsOnFire)
		{
			yield return Yield.EndOfFrame;
		}
		if (exKitHintRoutine != null)
		{
			StopCoroutine(exKitHintRoutine);
		}
		musicStem01.FadeVolumeIn(5f);
		CancelExKitHint();
		podiumFireNavMeshBlock.gameObject.SetActive(value: false);
		AudioScript obj = AudioScriptContainer.Instance.audioScripts[0];
		obj.transform.position = arenaFireAudio.transform.position;
		obj.Play(arenaFireDouceClip, 0.5f);
		arenaFireAudio.FadeOut(0.5f);
		podiumFire.Stop();
		StartCoroutine(FadePodiumFireSeal(5f));
		podiumFireLight.Fade(on: false, 5f);
		yield return Yield.WaitSeconds(3f);
		foleyMaze.FadeOut(1.5f);
		player.screenFX.Fade(UnityEngine.Color.black, 2f);
		SwitchOffPlayerLight();
		musicStem03.PlayOne(musicStingBassDrop);
		yield return Yield.WaitSeconds(1.75f);
		musicStem01.FadeOut(1f);
		yield return Yield.WaitSeconds(0.25f);
		player.HandMenu.CloseMenu(hideHandsAfter: true);
		player.HandMenu.LockMenu(locked: true);
		player.HandRendersActive(showHands: false);
		player.movement.DisableMovement();
		pazDarknessParticles.gameObject.SetActive(value: false);
		pazDarkness.gameObject.SetActive(value: true);
		player.SetPosition(pazDarkness.playerStartPos);
		player.screenFX.Fade(UnityEngine.Color.clear, 2f);
		foleyCave.SetMixerChannel(AudioScript.MixerChannel.effects);
		foleyCave.FadeIn(foleyCaveClip, 1f, 0.5f, loop: true);
		arenaTunnelProbe.gameObject.SetActive(value: false);
		yield return Yield.WaitSeconds(1f);
		player.HandRendersActive(showHands: false);
		yield return Yield.WaitSeconds(1f);
		musicStem02.PlayLoop(musicBuildLight);
		pazDarkness.RunPazFromDarkness();
		while (!pazDarkness.hasRunPazDarknessRoutine)
		{
			yield return Yield.EndOfFrame;
		}
		player.screenFX.cameraShakeAmount = 0.005f;
		player.screenFX.ShakeCamera();
		musicStem02.FadeOut(5f);
		fallingRockLoopAudio.Play(earthquakeClip);
		musicStem03.FadeIn(musicBuildSiren, 0.3f, 6f, loop: true);
		yield return Yield.WaitSeconds(3f);
		player.screenFX.cameraShakeAmount = 0.01f;
		foleyCave.FadeOut(3f);
		yield return Yield.WaitSeconds(3f);
		player.screenFX.Fade(UnityEngine.Color.black, 1f);
		yield return Yield.WaitSeconds(1f);
		player.SetPosition(playerStartPodium);
		pazDarkness.gameObject.SetActive(value: false);
		player.screenFX.cameraShakeAmount = 0.02f;
		yield return Yield.WaitSeconds(1f);
		podiumRenderer.sharedMaterial.SetTexture("_EmissionMap", podiumEmCrack);
		podiumRenderer.sharedMaterial.SetColor("_EmissionColor", UnityEngine.Color.white);
		lightCrack.SetActive(value: true);
		pazuzu.rockFall01.Play();
		pazuzu.rockFall02.Play();
		pazuzu.rockFall03.Play();
		player.screenFX.Fade(UnityEngine.Color.clear, 2f);
		player.HandMenu.LockMenu(locked: false);
		player.HandRendersActive(showHands: true);
		player.movement.EnableEverything();
		yield return Yield.WaitSeconds(1f);
		musicStem02.FadeIn(musicDrums01, 1f, 6f, loop: true);
		yield return Yield.WaitSeconds(1f);
		StartCoroutine(FadeInLightRange(arenaAmbientLight, 0f, ambientLightTargetRange, 4f));
		float startingCamShake = player.screenFX.cameraShakeAmount;
		for (float t = 0f; t < 6f; t += Time.deltaTime)
		{
			player.screenFX.cameraShakeAmount = startingCamShake - startingCamShake / 6f * t;
			if (t > 2f && pazuzu.rockFall03.isPlaying)
			{
				pazuzu.rockFall03.Stop();
			}
			if (t > 4f && pazuzu.rockFall02.isPlaying)
			{
				pazuzu.rockFall02.Stop();
			}
			yield return Yield.EndOfFrame;
		}
		pazuzu.rockFall01.Stop();
		player.screenFX.StopCameraShake();
		if (usingEditorDebug)
		{
			UnityEngine.Debug.Log("Using Debug to start next coroutine");
			StartCoroutine(FinaleRoutine());
		}
	}

	public IEnumerator FadeInLightRange(Light light, float startRange, float targetRange, float duration)
	{
		light.gameObject.SetActive(value: true);
		light.range = startRange;
		for (float t = 0f; t < duration; t += Time.deltaTime)
		{
			light.range = targetRange / duration * t + startRange;
			yield return Yield.EndOfFrame;
		}
	}

	public IEnumerator FadeInLightSpotAngle(Light light, float startSpotAngle, float targetSpotAngle, float duration)
	{
		light.gameObject.SetActive(value: true);
		light.spotAngle = startSpotAngle;
		UnityEngine.Debug.Log("Light set active, moving into for loop");
		for (float t = 0f; t < duration; t += Time.deltaTime)
		{
			UnityEngine.Debug.Log("entered for loop for angle fade in");
			light.spotAngle = targetSpotAngle / duration * t + startSpotAngle;
			yield return Yield.EndOfFrame;
		}
		UnityEngine.Debug.Log("Spot angle faded in. Moving on to Finale routine");
	}

	private IEnumerator FinaleRoutine()
	{
		UnityEngine.Debug.Log("Started Finale");
		pazuzu.gameObject.SetActive(value: true);
		float counter = 0f;
		bool playedBellHint = false;
		if (!player.LeftHand.IsInteracting)
		{
			player.LeftHand.SetAnimation("IdleBool");
			player.LeftHand.CurrentHandState = HandState.Idle;
			player.LeftHand.CurrentlyHoveringOver.Clear();
		}
		if (!player.RightHand.IsInteracting)
		{
			player.RightHand.SetAnimation("IdleBool");
			player.RightHand.CurrentHandState = HandState.Idle;
			player.RightHand.CurrentlyHoveringOver.Clear();
		}
		while (!crossSelected)
		{
			if (!playedBellHint)
			{
				if (counter > 5f)
				{
					AudioScript obj = AudioScriptContainer.Instance.audioScripts[2];
					obj.transform.position = arenaFloatingAudio[1].position;
					obj.Play(pazuzu.fatherBellHintClips[0]);
					HUD.Instance.PlaySubtitles(pazuzu.fatherBellHintClips[0].name, hasPriority: true);
					playedBellHint = true;
				}
				counter += Time.deltaTime;
			}
			yield return Yield.EndOfFrame;
		}
		interactableCross.LockToHand(isLocked: true);
		fallingRockLoopAudio.FadeVolumeOut(3.9f, 0.6f);
		musicStem02.FadeOut(9.9f);
		AudioScript obj2 = AudioScriptContainer.Instance.audioScripts[3];
		obj2.transform.position = arenaFloatingAudio[2].position;
		obj2.Play(pazVOFightTaunt);
		HUD.Instance.PlaySubtitles(pazVOFightTaunt.name, hasPriority: true);
		yield return Yield.WaitSeconds(4f);
		player.screenFX.ShakeCamera();
		yield return Yield.WaitSeconds(6f);
		musicStem02.PlayLoop(musicDrums02);
		yield return StartCoroutine(pazuzu.ExorcismPart1());
		yield return StartCoroutine(pazuzu.ExorcismPart2());
		yield return StartCoroutine(pazuzu.ExorcismPart3());
		yield return StartCoroutine(pazuzu.ExorcismPart4());
		if (usingEditorDebug)
		{
			StartCoroutine(FadeOutScene());
		}
	}

	public void SlowTime(float newTime)
	{
		for (int i = 0; i < allAudio.Length; i++)
		{
			allAudio[i].pitch = Mathf.Clamp(newTime, 0.3f, 1f);
		}
		Time.timeScale = newTime;
	}

	public override void BeginInteraction(NVRInteractable interactable)
	{
		if (interactable.gameObject.layer == LayerMask.NameToLayer("Rope"))
		{
			if (boat.canInteract && interactable.gameObject.tag == "RopeBoat")
			{
				boat.BeginInteraction(interactable);
				interactedWithRope = true;
				GameController.instance.hintManager.RemoveHint(tunnelRopeHintObject);
			}
			else if (!snappedRope && canInteractWithBridgeRope)
			{
				StartCoroutine(BreakBridgeRope());
				snappedRope = true;
				canInteractWithBridgeRope = false;
			}
		}
		else if (interactable.gameObject == wellRopeInteractable && !grabbedMazeWellRope && canInteractWithCentralWellRope)
		{
			grabbedMazeWellRope = true;
			canInteractWithCentralWellRope = false;
			GameController.instance.hintManager.RemoveHint(wellRopeInteractable);
		}
		else if (interactable.gameObject == pulley)
		{
			mazeEntranceDoor.BeginInteraction(interactable);
		}
		else if (interactable.gameObject == cross)
		{
			crossSelected = true;
			interactableCross.inEnvironment = false;
		}
		else if (interactable.gameObject == podiumGrabPoint && !hasGrabbedPodium)
		{
			hasGrabbedPodium = true;
			podiumFire.gameObject.SetActive(value: true);
			podiumFireLight.SwitchLight(switchOn: true);
		}
		else if (interactable.gameObject == chapelExitDoor.gameObject && sprayedFatherBell && !openedChapelExitDoor)
		{
			if (chapel.pigManAttackedPlayer)
			{
				maze.mazeRoute2AfterChapel.SetActive(value: true);
				openedChapelExitDoor = true;
			}
		}
		else if (interactable == cell.cellEntranceDoor && !cell.doorLocked)
		{
			GameController.instance.hintManager.RemoveHint(cell.cellEntranceDoor);
		}
		if (!(interactable.gameObject.tag == "AchievementItem") || foundAllBones)
		{
			return;
		}
		bool flag = true;
		for (int i = 0; i < allBonesOfTheDead.Length; i++)
		{
			AchievementItemStruct achievementItemStruct = allBonesOfTheDead[i];
			if (interactable.gameObject == achievementItemStruct.achievementObject)
			{
				achievementItemStruct.completed = true;
			}
			if (!achievementItemStruct.completed)
			{
				flag = false;
			}
		}
		if (flag)
		{
			foundAllBones = true;
			GameController.instance.achievementManager.UnlockAchievement(AchievementID.LOST_LAMB);
		}
	}

	private void smashedGlassOffFatherBell()
	{
		if (!smashedGlassOnHead)
		{
			smashedGlassOnHead = true;
			GameController.instance.achievementManager.UnlockAchievement(AchievementID.NO_RESPECT);
		}
	}

	public override void EndInteraction(NVRInteractable interactable)
	{
		if (interactable.gameObject.layer == LayerMask.NameToLayer("Rope") && boat.canInteract && interactable.gameObject.tag == "RopeBoat")
		{
			boat.EndInteraction();
		}
		else if (interactable.gameObject == cross)
		{
			crossSelected = false;
			interactableCross.inEnvironment = false;
		}
		else if (interactable.gameObject == pulley && mazeEntranceDoor.ShouldEndInteraction)
		{
			mazeEntranceDoor.EndInteraction();
		}
	}

	public void OnHoverMazeExitDoor()
	{
		if (sprayedFatherBell && chapel.thrownChair && chapel.thrownBooks && !chapel.isRunningCoroutine && !hasHoveredChapelExitDoor)
		{
			if (player.LeftHand.CurrentlyHoveringOver.ContainsKey(chapelExitDoor))
			{
				player.LeftHand.hoverRemoveObject = chapelExitDoor;
			}
			if (player.RightHand.CurrentlyHoveringOver.ContainsKey(chapelExitDoor))
			{
				player.RightHand.hoverRemoveObject = chapelExitDoor;
			}
			chapel.SetRedRoom(redRoomEnabled: true);
			hasHoveredChapelExitDoor = true;
		}
	}

	private IEnumerator CloseMazeDoor()
	{
		caveDoorCloseTrigger.SetActive(value: false);
		GameController.instance.boundDetection.SwitchOffOOB();
		GameController.instance.player.movement.DisableEverything();
		yield return StartCoroutine(ExtinguishTorchesWithSFX(AudioScriptContainer.Instance.audioScripts[2], floatingPoints[5], windForTorches[1]));
		yield return StartCoroutine(mazeEntranceDoor.ShutRoutine(caveRoom, caveMazeConnectorRoom, centralMazeRoom, maze));
		foleyCave.FadeOut(2f);
		foleyMaze.FadeIn(foleyMazeClip, 1f, 2f, loop: true);
	}

	public override void OnTriggerEnter(Collider collider)
	{
		if (collider.gameObject == centralMazeLightTrigger)
		{
			SwitchOffPlayerLight();
		}
		else if (collider.gameObject == mazeRoute1LightTrigger)
		{
			SwitchOnPlayerLight();
		}
		else if (!(collider.gameObject == mazeRoute2LightTrigger))
		{
			_ = collider.gameObject == mazeRoute3LightTrigger;
		}
		if (collider.gameObject == caveDoorCloseTrigger)
		{
			caveDoorCloseTrigger.SetActive(value: false);
			StartCoroutine(CloseMazeDoor());
		}
		else if (collider.gameObject == caveMazeConnectorBlockingTrigger)
		{
			caveMazeConnectorBlockingTrigger.SetActive(value: false);
			float[] array = new float[32];
			array[14] = 8f;
			playerCamera.layerCullDistances = array;
			caveMazeConnectorBlocker.SetActive(value: true);
		}
		else if (collider.gameObject == mazeRoute1Part1CaveTrigger)
		{
			maze.mazeCave.SetActive(value: true);
		}
		else if (collider.gameObject == mazeRoute1Part1EndTrigger)
		{
			SwitchOffPlayerLight();
			player.HandMenu.exKitScript.candle.GetComponent<OilLighter>().canTurnOnLight = false;
			mazeRoute1Part1EndTrigger.SetActive(value: false);
			canInteractWithBridgeRope = true;
			StartCoroutine(LighterHint());
			centralMazeRoom.associatedParentGameObject.SetActive(value: false);
			maze.SwitchRoute(MazeController.MazeState.ROUTE1_P2);
		}
		else if (collider.gameObject == mazeRoute1Part2EndTrigger)
		{
			SwitchOnPlayerLight();
			OilLighter component = player.HandMenu.exKitScript.candle.GetComponent<OilLighter>();
			component.canTurnOnLight = true;
			if (component.isOn)
			{
				component.TurnOnLight();
			}
			mazeRoute1Part2EndTrigger.SetActive(value: false);
			maze.SwitchRoute(MazeController.MazeState.ROUTE1_P3);
		}
		else if (collider.gameObject == mazeRoute1Part3EndTrigger)
		{
			mazeRoute1Part3EndTrigger.SetActive(value: false);
			maze.mazeRoute1Part3Blocker.SetActive(value: true);
			maze.mazeRoute1Part1.SetActive(value: false);
			maze.mazeRoute1Part2.SetActive(value: false);
			maze.mazeRoute2EntranceBlocker.SetActive(value: false);
			centralMazeRoom.associatedParentGameObject.SetActive(value: true);
			maze.mazeRoute1Room.floorOOB = maze.mazeRoute1ExitFloorOOB;
			mazeRoute1ExitTrigger.SetActive(value: true);
		}
		else if (collider.gameObject == mazeRoute1ExitTrigger)
		{
			mazeRoute1ExitTrigger.SetActive(value: false);
			maze.mazeRoute1Part1.SetActive(value: false);
			maze.mazeRoute1Part2.SetActive(value: false);
			maze.mazeRoute1Part3.SetActive(value: false);
			maze.SwitchRoute(MazeController.MazeState.ROUTE2_P1);
			StartCoroutine(BlockMazeRouteExit(MazeController.MazeState.ROUTE1_P3));
		}
		else if (collider.gameObject == mazeRoute2ExitLeftTrigger || collider.gameObject == mazeRoute2ExitRightTrigger)
		{
			mazeRoute2ExitLeftTrigger.SetActive(value: false);
			mazeRoute2ExitRightTrigger.SetActive(value: false);
			StartCoroutine(BlockMazeRouteExit(MazeController.MazeState.ROUTE2_P2));
			maze.SwitchRoute(MazeController.MazeState.ROUTE3_P1);
		}
		else if (collider.gameObject == mazeRoute3ExitLeftTrigger || collider.gameObject == mazeRoute3ExitRightTrigger)
		{
			mazeRoute3ExitLeftTrigger.SetActive(value: false);
			mazeRoute3ExitRightTrigger.SetActive(value: false);
			StartCoroutine(BlockMazeRouteExit(MazeController.MazeState.ROUTE3_P2));
			maze.SwitchRoute(MazeController.MazeState.CENTRE_WELL);
		}
		else if (collider.gameObject == cellEntranceAreaTrigger)
		{
			maze.mazeRoute2EntranceBlocker.SetActive(value: true);
			SwitchOffPlayerLight();
			cellRoom.associatedParentGameObject.SetActive(value: true);
			inCellEntranceAreaTrigger = true;
		}
		else if (collider.gameObject == cellEntranceWallAreaTrigger)
		{
			inCellEntranceWallAreaTrigger = true;
		}
		else if (collider.gameObject == cellCaveCentreTrigger)
		{
			inCellCaveCentreTrigger = true;
		}
		else if (collider.gameObject == cellCentreAreaTrigger)
		{
			isInCellCentre = true;
		}
		else if (collider.gameObject == chapelEntranceTrigger)
		{
			chapelEntranceTrigger.SetActive(value: false);
			chapel.StartFatherBellTape();
			musicStem01.FadeOut(4f);
			musicStem02.FadeOut(4f);
		}
		else if (collider.gameObject == chapelExitTrigger)
		{
			BlockChapel();
		}
		else if (collider.gameObject == cellCloseExitDoorTrigger)
		{
			BlockCell();
		}
		else if (collider.gameObject == cellCloseExitDoorFailsafeTrigger)
		{
			BlockCell();
		}
		else if (collider.gameObject == chapelCloseExitDoorFailsafeTrigger)
		{
			BlockChapel();
		}
		else if (collider.gameObject == chapelAreaTrigger)
		{
			inChapelAreaTrigger = true;
			chapelAreaTrigger.SetActive(value: false);
			chapelSightTrigger.SetActive(value: false);
			chapelAreaTrigger.SetActive(value: false);
			chapel.BlockEntrance();
			exKitHintRoutine = StartCoroutine(ExKitItemHint(NotebookPages.Q09, 35f));
			chapel.StartFatherBellTape();
			musicStem01.FadeOut(4f);
			musicStem02.FadeOut(4f);
		}
		else if (collider.gameObject == chapelExitDoorAreaTrigger)
		{
			inChapelExitDoorAreaTrigger = true;
		}
		else if (collider.gameObject == caveBatsTrigger)
		{
			caveBatsTrigger.SetActive(value: false);
			caveBatSwarm.StartSwarm();
		}
		else if (collider.gameObject == mazeCaveBatsTrigger)
		{
			mazeCaveBatsTrigger.SetActive(value: false);
			mazeCaveBatSwarm.StartSwarm();
		}
		else if (collider.gameObject == mazeCorridoorBatsTrigger)
		{
			mazeCorridoorBatsTrigger.SetActive(value: false);
			mazeCorridoorBatSwarm.StartSwarm();
		}
		else if (collider.gameObject == musicMazeBedTrigger)
		{
			musicMazeBedTrigger.SetActive(value: false);
			musicStem02.FadeOut(3f);
			musicStem01.FadeIn(musicBed, 1f, 6f, loop: true);
		}
		else if (collider.gameObject == musicBedMinimalTrigger)
		{
			musicBedMinimalTrigger.SetActive(value: false);
			musicStem02.FadeIn(musicBedMinimal, 1f, 5f, loop: true);
		}
		else if (collider.gameObject == musicMazeBedCellTrigger)
		{
			musicMazeBedCellTrigger.SetActive(value: false);
			musicStem01.FadeIn(musicBed, 1f, 6f, loop: true);
		}
		else if (collider.gameObject == musicMaze2BuildTrigger)
		{
			musicMaze2BuildTrigger.SetActive(value: false);
			musicStem02.FadeIn(musicBuildBoat, 0.8f, 5f, loop: true);
		}
		else if (collider.gameObject == musicMaze3BuildTrigger)
		{
			musicMaze3BuildTrigger.SetActive(value: false);
			musicStem02.FadeIn(musicBuildLight, 0.8f, 5f, loop: true);
		}
		else if (collider.gameObject == voFatherBellLostTapeTrigger)
		{
			voFatherBellLostTapeTrigger.SetActive(value: false);
			boat.PlayVOClip();
		}
		else if (collider.gameObject == musicFinaleBuildTrigger)
		{
			musicFinaleBuildTrigger.SetActive(value: false);
			musicStem03.FadeOut(10f);
			musicStem01.FadeIn(musicBuildBoat, 1f, 12f, loop: true);
		}
		else if (collider.gameObject == mazeRoute3MaryWhisperTrigger)
		{
			inMaryAreaTrigger = true;
			if (lookingAwayFromMary && mazeMaryLookingAwaySightTrigger.activeInHierarchy)
			{
				mazeMarySightTrigger.SetActive(value: true);
				mazeRoute3MaryWhisperTrigger.SetActive(value: false);
				mazeMaryLookingAwaySightTrigger.SetActive(value: false);
				AudioScript obj = AudioScriptContainer.Instance.audioScripts[0];
				obj.transform.position = floatingPoints[1].position;
				obj.Play(floatingClips[1], 1.5f);
			}
		}
		else if (collider.gameObject == mazeRoute3MaryTurnOffTrigger)
		{
			mazeMarySightTrigger.SetActive(value: false);
			mazeRoute3MaryWhisperTrigger.SetActive(value: false);
			mazeMaryLookingAwaySightTrigger.SetActive(value: false);
			inMaryAreaTrigger = false;
			lookingAwayFromMary = false;
		}
		else if (collider.gameObject == pazShadow01Trigger)
		{
			inPazDarkness01Trigger = true;
		}
		else if (collider.gameObject.tag == "DeadEnd")
		{
			noDeadEnds = false;
		}
		else if (!playerPositionalAudioManager.PlayIfTriggered(collider.gameObject, disableTrigger: true) && tombFloatingAudioManager != null)
		{
			tombFloatingAudioManager.PlayIfTriggered(collider.gameObject, disableTrigger: true, FloatingPointAudioManager.FloatingPointAudioPlayType.PLAY_ONE, 0, 1f);
		}
	}

	public override void OnTriggerExit(Collider collider)
	{
		if (collider.gameObject == cellEntranceAreaTrigger)
		{
			inCellEntranceAreaTrigger = false;
		}
		else if (collider.gameObject == cellCaveCentreTrigger)
		{
			inCellCaveCentreTrigger = false;
		}
		else if (collider.gameObject == cellEntranceWallAreaTrigger)
		{
			inCellEntranceWallAreaTrigger = false;
		}
		else if (collider.gameObject == cellCentreAreaTrigger)
		{
			isInCellCentre = false;
		}
		else if (collider.gameObject == chapelExitDoorAreaTrigger)
		{
			inChapelExitDoorAreaTrigger = false;
		}
		else if (collider.gameObject == chapelAreaTrigger)
		{
			inChapelAreaTrigger = false;
		}
		else if (collider.gameObject == mazeRoute3MaryWhisperTrigger)
		{
			inMaryAreaTrigger = false;
		}
		else if (collider.gameObject == cellCloseExitDoorTrigger)
		{
			inCloseCellDoorAreaTrigger = false;
		}
		else if (collider.gameObject == chapelExitTrigger)
		{
			inChapelCloseExitAreaTrigger = false;
		}
	}

	public override void OnSightTriggerEnter(Collider other)
	{
		if (other.gameObject == chapelPigManSightTrigger && hasHoveredChapelExitDoor)
		{
			chapelPigManSightTrigger.SetActive(value: false);
			chapel.RunPigMan();
		}
		else if (other.gameObject == pazuzuEmergeTrigger && pazuzu.canDeathBeSeen)
		{
			pazuzuEmergeTrigger.SetActive(value: false);
			pazuzu.hasSeenDeath = true;
		}
		else if (other.gameObject == pazDarkness.pazSightTrigger)
		{
			pazDarkness.pazSightTrigger.SetActive(value: false);
		}
		else if (other.gameObject == pazuzuAttack1SightTrigger && !hasSeenPazuzuAttack1)
		{
			pazuzuAttack1SightTrigger.SetActive(value: false);
			hasSeenPazuzuAttack1 = true;
		}
		else if (other.gameObject == pazuzuAttack2SightTrigger && !hasSeenPazuzuAttack2)
		{
			pazuzuAttack2SightTrigger.SetActive(value: false);
			hasSeenPazuzuAttack2 = true;
		}
		else if (other.gameObject == mazeMarySightTrigger)
		{
			mazeMarySightTrigger.SetActive(value: false);
		}
		else if (other.gameObject == pazuzu.gameObject && !seenPazuzuPossession)
		{
			seenPazuzuPossession = true;
		}
		else if (other.gameObject == pazuzuWeakenedSightTrigger)
		{
			pazuzuWeakenedSightTrigger.SetActive(value: false);
			pazuzu.hasSeenPazHurt = true;
		}
		else if (other.gameObject == mazeRoute2Or3ExitSightTrigger)
		{
			lookingAtMazeRoute2Or3ExitSightTrigger = true;
		}
		else if (other.gameObject == mazeRoute1ExitSightTrigger)
		{
			lookingAtMazeRoute1ExitSightTrigger = true;
		}
	}

	public override void OnSightTriggerExit(Collider other)
	{
		if (other.gameObject == mazeMaryLookingAwaySightTrigger)
		{
			lookingAwayFromMary = false;
		}
		else if (other.gameObject == mazeRoute2Or3ExitSightTrigger)
		{
			lookingAtMazeRoute2Or3ExitSightTrigger = false;
		}
		else if (other.gameObject == mazeRoute1ExitSightTrigger)
		{
			lookingAtMazeRoute1ExitSightTrigger = false;
		}
	}

	public override void OnSightTriggerStay(Collider other)
	{
		if (other.gameObject == cellEntranceSightTrigger)
		{
			if (inCellEntranceAreaTrigger)
			{
				cell.RunFlamingCellRoutine();
				cellEntranceAreaTrigger.SetActive(value: false);
				cellEntranceSightTrigger.SetActive(value: false);
				musicStem01.StopLoop();
				musicStem02.StopLoop();
			}
		}
		else if (other.gameObject == cellExitWallSightTrigger)
		{
			if (isInCellCentre)
			{
				if (!deactivatedCellEntranceDoor)
				{
					cell.DeactivateEntranceDoor();
					cellEntranceWallSightTrigger.SetActive(value: true);
					cellEntranceWallAreaTrigger.SetActive(value: true);
					cellExitWallSightTrigger.SetActive(value: false);
					deactivatedCellEntranceDoor = true;
				}
				else if (!deactivatedCellExitDoor && deactivatedCellEntranceDoor)
				{
					cell.SetRockWall(MazeCell.CellFace.BACK, enabled: true);
					cellExitWallSightTrigger.SetActive(value: false);
					cellWallSightTriggerLeft.SetActive(value: true);
					cellWallSightTriggerRight.SetActive(value: true);
					deactivatedCellExitDoor = true;
				}
			}
		}
		else if (other.gameObject == cellEntranceWallSightTrigger)
		{
			if (inCellEntranceWallAreaTrigger)
			{
				cell.SetRockWall(MazeCell.CellFace.FRONT, enabled: true);
				cell.SetRockWall(MazeCell.CellFace.FLOOR, enabled: true);
				cell.SetRockWall(MazeCell.CellFace.ROOF, enabled: true);
				cellEntranceWallSightTrigger.SetActive(value: false);
				cellEntranceWallAreaTrigger.SetActive(value: false);
				cellExitWallSightTrigger.SetActive(value: true);
			}
		}
		else if (other.gameObject == cellWallSightTriggerRight)
		{
			cellWallSightTriggerRight.SetActive(value: false);
			cell.SetRockWall(MazeCell.CellFace.LEFT, enabled: true);
		}
		else if (other.gameObject == cellWallSightTriggerLeft)
		{
			cellWallSightTriggerLeft.SetActive(value: false);
			cell.SetRockWall(MazeCell.CellFace.RIGHT, enabled: true);
		}
		else if (other.gameObject == cellCrossSightTrigger)
		{
			if (inCellCaveCentreTrigger)
			{
				cellCrossSightTrigger.SetActive(value: false);
				if (!cell.hasCellCaveWhispersFinished)
				{
					cell.RunWhispers();
				}
				else
				{
					cell.RunPrisionerOnCross();
				}
			}
		}
		else if (other.gameObject == chapelExitDoorSightTrigger && inChapelExitDoorAreaTrigger && !lookedAtChapelExitDoor)
		{
			lookedAtChapelExitDoor = true;
			chapel.SetRedRoom(redRoomEnabled: true);
			if (!chapel.thrownChair && chapel.thrownBooks)
			{
				StartCoroutine(EnableSightTrigger(7f, chapelChairSightTrigger));
				chapel.RunChairLift();
			}
		}
		else if (other.gameObject == pazDarkness.pazSightTrigger && pazDarkness.pazSightTrigger.activeInHierarchy)
		{
			pazDarkness.pazSightTrigger.SetActive(value: false);
		}
		else if (other.gameObject == chapelChairSightTrigger && lookedAtChapelExitDoor)
		{
			chapelChairSightTrigger.SetActive(value: false);
			chapel.RunThrowChair(player.Head.transform.position);
		}
		else if (other.gameObject == chapelBookCaseSightTrigger)
		{
			chapelBookCaseSightTrigger.SetActive(value: false);
			chapel.RunThrowBooks();
		}
		else if (other.gameObject == chapelSightTrigger && inChapelAreaTrigger)
		{
			chapelSightTrigger.SetActive(value: false);
			chapelAreaTrigger.SetActive(value: false);
			chapel.BlockEntrance();
			exKitHintRoutine = StartCoroutine(ExKitItemHint(NotebookPages.Q09, 35f));
		}
		else if (other.gameObject == mazeMaryLookingAwaySightTrigger)
		{
			lookingAwayFromMary = true;
			if (inMaryAreaTrigger && mazeRoute3MaryWhisperTrigger.activeInHierarchy)
			{
				mazeMarySightTrigger.SetActive(value: true);
				mazeRoute3MaryWhisperTrigger.SetActive(value: false);
				mazeMaryLookingAwaySightTrigger.SetActive(value: false);
				AudioScript obj = AudioScriptContainer.Instance.audioScripts[0];
				obj.transform.position = floatingPoints[1].position;
				obj.Play(floatingClips[1], 1.5f);
			}
		}
		else if (other.gameObject == pazuzu.currentSightTrigger)
		{
			pazuzu.hitSightTrigger = true;
			pazuzu.currentSightTrigger.SetActive(value: false);
		}
		else if (other.gameObject == cellCloseExitSightTrigger)
		{
			if (inCloseCellDoorAreaTrigger)
			{
				BlockCell();
			}
		}
		else if (other.gameObject == chapelCloseExitDoorSightTrigger && inChapelCloseExitAreaTrigger)
		{
			BlockChapel();
		}
	}

	private IEnumerator BlockMazeRouteExit(MazeController.MazeState mazeState)
	{
		switch (mazeState)
		{
		case MazeController.MazeState.ROUTE1_P3:
			routeExitAudioScript.Play(routeExitAudioClip);
			player.screenFX.cameraShakeAmount = 0.005f;
			player.screenFX.ShakeCamera();
			if (lookingAtMazeRoute1ExitSightTrigger)
			{
				player.screenFX.Fade(UnityEngine.Color.black, 0.2f);
				yield return Yield.WaitSeconds(0.4f);
				player.screenFX.Fade(UnityEngine.Color.clear, 0.2f);
				yield return Yield.WaitSeconds(0.4f);
				player.screenFX.Fade(UnityEngine.Color.black, 0.4f);
				yield return Yield.WaitSeconds(0.4f);
				maze.mazeRoute1ExitBlocker.SetActive(value: true);
				route1Blocker.SetActive(value: true);
				yield return Yield.WaitSeconds(0.2f);
				player.screenFX.Fade(UnityEngine.Color.clear, 0.75f);
				route1ExitParticles.Play();
				yield return Yield.WaitSeconds(0.2f);
			}
			else
			{
				maze.mazeRoute1ExitBlocker.SetActive(value: true);
				route1Blocker.SetActive(value: true);
				route1ExitParticles.Play();
				yield return Yield.WaitSeconds(0.2f);
			}
			mazeRoute1ExitSightTrigger.SetActive(value: false);
			player.screenFX.StopCameraShake();
			break;
		case MazeController.MazeState.ROUTE2_P2:
			routeExitAudioScript.Play(routeExitAudioClip);
			player.screenFX.cameraShakeAmount = 0.005f;
			player.screenFX.ShakeCamera();
			if (lookingAtMazeRoute2Or3ExitSightTrigger)
			{
				player.screenFX.Fade(UnityEngine.Color.black, 0.1f);
				yield return Yield.WaitSeconds(0.3f);
				player.screenFX.Fade(UnityEngine.Color.clear, 0.4f);
				yield return Yield.WaitSeconds(0.4f);
				player.screenFX.Fade(UnityEngine.Color.black, 0.3f);
				yield return Yield.WaitSeconds(0.5f);
				maze.mazeRoute2ExitBlocker.SetActive(value: true);
				yield return Yield.WaitSeconds(0.2f);
				player.screenFX.Fade(UnityEngine.Color.clear, 0.75f);
				route2_3ExitParticles.Play();
				yield return Yield.WaitSeconds(0.2f);
			}
			else
			{
				maze.mazeRoute2ExitBlocker.SetActive(value: true);
				route2_3ExitParticles.Play();
				yield return Yield.WaitSeconds(0.2f);
			}
			player.screenFX.StopCameraShake();
			break;
		case MazeController.MazeState.ROUTE3_P2:
			routeExitAudioScript.Play(routeExitAudioClip);
			player.screenFX.cameraShakeAmount = 0.005f;
			player.screenFX.ShakeCamera();
			if (lookingAtMazeRoute2Or3ExitSightTrigger)
			{
				player.screenFX.Fade(UnityEngine.Color.black, 0.3f);
				yield return Yield.WaitSeconds(0.4f);
				player.screenFX.Fade(UnityEngine.Color.clear, 0.1f);
				yield return Yield.WaitSeconds(0.4f);
				player.screenFX.Fade(UnityEngine.Color.black, 0.5f);
				yield return Yield.WaitSeconds(0.3f);
				maze.mazeRoute3ExitBlocker.SetActive(value: true);
				yield return Yield.WaitSeconds(0.2f);
				player.screenFX.Fade(UnityEngine.Color.clear, 0.75f);
				route2_3ExitParticles.Play();
				yield return Yield.WaitSeconds(0.2f);
			}
			else
			{
				maze.mazeRoute3ExitBlocker.SetActive(value: true);
				route2_3ExitParticles.Play();
				yield return Yield.WaitSeconds(0.2f);
			}
			mazeRoute2Or3ExitSightTrigger.SetActive(value: false);
			player.screenFX.StopCameraShake();
			break;
		default:
			yield return Yield.WaitSeconds(0.1f);
			break;
		}
	}

	private void BlockChapel()
	{
		chapelCloseExitDoorSightTrigger.SetActive(value: false);
		chapelExitTrigger.SetActive(value: false);
		chapelCloseExitDoorFailsafeTrigger.SetActive(value: false);
		mazeDisableChapelTrigger.SetActive(value: true);
		chapel.CloseExitDoor();
	}

	private void BlockCell()
	{
		cellCloseExitDoorTrigger.SetActive(value: false);
		cellCloseExitSightTrigger.SetActive(value: false);
		cellCloseExitDoorFailsafeTrigger.SetActive(value: false);
		cell.CloseExitDoor();
	}

	private IEnumerator EnableSightTrigger(float waitTime, GameObject trigger)
	{
		yield return Yield.WaitSeconds(waitTime);
		trigger.SetActive(value: true);
	}

	private IEnumerator ExtinguishTorchesWithSFX(AudioScript audioScript, Transform floatingPoint, AudioClip clip)
	{
		audioScript.transform.position = floatingPoint.position;
		audioScript.Play(clip);
		yield return Yield.WaitSeconds(0.33f);
		torchManager.canIgniteOnRespawn = false;
		torchManager.ExtinguishTorches(playAudio: true);
	}

	private void MiniShrineLightCandleSet()
	{
		StartCoroutine(MiniShrineLightCandleSetRoutine());
	}

	private IEnumerator MiniShrineLightCandleSetRoutine()
	{
		AudioScript audioScript = AudioScriptContainer.Instance.audioScripts[2];
		audioScript.transform.position = miniShrineParticles.transform.position;
		audioScript.FadeIn(floatingClips[5], 0.8f, 1.25f, loop: true);
		deadEndPicLight.SetActive(value: false);
		deadEndPicDark.SetActive(value: true);
		AudioScript obj = AudioScriptContainer.Instance.audioScripts[3];
		obj.transform.position = miniShrineParticles.transform.position;
		obj.Play(sandDropSFX, 0.7f);
		yield return Yield.WaitSeconds(2.25f);
		GameController.instance.audioController.PlayBadSting(STINGS_BAD.BAD_SOFT_STING_03, 0.6f);
		yield return Yield.WaitSeconds(0.5f);
		audioScript.FadeOut(3f);
	}

	private IEnumerator BreakBridgeRope()
	{
		AudioScript obj = AudioScriptContainer.Instance.audioScripts[0];
		obj.transform.position = floatingPoints[0].position;
		obj.Play(floatingClips[0]);
		yield return Yield.WaitSeconds(1f);
		GameController.instance.audioController.PlayBadSting(STINGS_BAD.BAD_SOFT_STING_03, 0.8f);
		if (player.LeftHand.CurrentlyInteracting != null && player.LeftHand.CurrentlyInteracting.gameObject.layer == LayerMask.NameToLayer("Rope"))
		{
			player.LeftHand.ForceDropItem();
		}
		if (player.RightHand.CurrentlyInteracting != null && player.RightHand.CurrentlyInteracting.gameObject.layer == LayerMask.NameToLayer("Rope"))
		{
			player.RightHand.ForceDropItem();
		}
		bridgeRope.BreakRopeAtNode(0);
	}

	private IEnumerator LighterHint()
	{
		float hintTimer = 0f;
		while (!lighter.isOn)
		{
			if (hintTimer > 90f)
			{
				player.HandMenu.OpenStraightToBook(NotebookPages.Q08);
				player.watch.WatchHintWithSFX(5f, SFXAlertType.ALERT);
				break;
			}
			hintTimer += Time.deltaTime;
			yield return Yield.EndOfFrame;
		}
	}

	private IEnumerator ExKitItemHint(NotebookPages page, float timeToAlert)
	{
		yield return Yield.WaitSeconds(timeToAlert);
		noHints = false;
		player.HandMenu.OpenStraightToBook(page);
		player.watch.WatchHintWithSFX(5f, SFXAlertType.ALERT);
	}

	private void CancelExKitHint()
	{
		if ((bool)player.watch)
		{
			player.watch.CancelWatchHint();
			player.watch.CancelWatchHintWithSFX();
			player.HandMenu.CancelStraightToKit();
			player.HandMenu.CancelStraightToBook();
		}
	}

	private IEnumerator FadePodiumFireSeal(float time)
	{
		for (float counter = 0f; counter < time; counter += Time.deltaTime)
		{
			float num = 1f - counter / time;
			podiumRenderer.sharedMaterial.SetColor("_EmissionColor", new UnityEngine.Color(num, num, num));
			yield return Yield.EndOfFrame;
		}
	}

	private IEnumerator FadeOutScene()
	{
		if (Time.timeScale != 1f)
		{
			GameController.instance.audioController.SnapMute(0.5f);
			player.screenFX.Fade(UnityEngine.Color.black, 0.5f);
			yield return new WaitForSeconds(0.5f);
			player.screenFX.SetColourGradingAndFadeIn(ScreenFX.ColourGradingProfileID.DEFAULT, 0.5f);
			yield return new WaitForSeconds(0.5f);
			SlowTime(1f);
		}
		else
		{
			GameController.instance.audioController.SnapMute(2f);
			player.screenFX.Fade(UnityEngine.Color.black, 2f);
			yield return new WaitForSeconds(2f);
			player.screenFX.SetColourGradingAndFadeIn(ScreenFX.ColourGradingProfileID.DEFAULT, 2f);
			yield return new WaitForSeconds(0.5f);
		}
		player.screenFX.BlurScreen(enabled: false);
		player.playerLight.ResetRange();
		player.playerLight.ResetAngle();
		player.playerLight.ResetColour();
		player.playerLight.SetStandardPlayerLightCookie();
		player.HandMenu.exKitScript.candle.GetComponent<OilLighter>().TogglePlayerLightingLayer(on: true);
		player.HandMenu.playerLightsDisable = false;
		UnityEngine.Color color = default(UnityEngine.Color);
		color.r = 1f;
		color.g = 0.8980392f;
		color.b = 0.772549f;
		arenaAmbientLight.color = color;
		tuneCross.ResetWindRadius();
		lookAtObjectForPaz.transform.parent = null;
		playerPositionalAudioScript.transform.parent = null;
		foleyCave.transform.parent = null;
		foleyMaze.transform.parent = null;
		GameController.instance.levelCompletionManager.SetLevelCompletionForTomb(noHints, pazuzu.exorcisedCrackInTime, noDeadEnds, completedLevel: true);
		yield return new WaitForSeconds(1f);
		player.transform.parent = GameController.instance.transform;
		yield return Yield.EndOfFrame;
		player.transform.parent = null;
		player.fishEyeFX.strengthX = 0f;
		player.fishEyeFX.enabled = false;
		player.playerAudio.SetMixerChannel(AudioScript.MixerChannel.sfx);
		GameController.instance.boundDetection.SwitchOffOOB();
		GameController.instance.GoToSpecificScene(SCENES.PRECINCT, completedPrev: true);
	}

	public void ExitToPrecinct()
	{
		StartCoroutine(ExitToPrecinctRoutine());
	}

	public IEnumerator ExitToPrecinctRoutine()
	{
		SlowTime(1f);
		player.mainCamera.farClipPlane = 1000f;
		tuneCross.ResetWindRadius();
		lookAtObjectForPaz.transform.parent = null;
		playerPositionalAudioScript.transform.parent = null;
		foleyCave.transform.parent = null;
		foleyMaze.transform.parent = null;
		tuneCross.AreaLight(active: false);
		tuneCross.StopBackground();
		tuneCross.StopSFX();
		tuneCross.StopLightTarget();
		tuneCross.TheLight(isEnabled: false);
		player.movement.overrideMovementEnabled = false;
		PicoLight.enabled = false;
		player.transform.parent = GameController.instance.transform;
		yield return Yield.EndOfFrame;
		player.transform.parent = null;
		player.transform.rotation = new Quaternion(player.transform.rotation.x, player.transform.rotation.y, 0f, player.transform.rotation.w);
		player.fishEyeFX.strengthX = 0f;
		player.fishEyeFX.enabled = false;
		player.HandMenu.playerLightsDisable = false;
		interactableCross.CanAttach = true;
		interactableCross.gameObject.SetActive(value: true);
		interactableCross.LockToHand(isLocked: false);
		if (player.LeftHand.CurrentlyInteracting == interactableCross)
		{
			player.LeftHand.ForceDropItem();
		}
		else if (player.RightHand.CurrentlyInteracting == interactableCross)
		{
			player.RightHand.ForceDropItem();
		}
		interactableCross.respawnTimer = 0.5f;
		yield return Yield.WaitSeconds(0.5f);
		RenderSettings.skybox = null;
		DynamicGI.UpdateEnvironment();
		GameController.instance.audioController.persistentMusicPlayer.StopLoop();
		GameController.instance.levelCompletionManager.SetLevelCompletionForTomb(noHints: false, pazuzu.exorcisedCrackInTime, noDeadEnds: false, completedLevel: false);
		GameController.instance.audioController.SnapMute(3f);
		player.screenFX.Fade(UnityEngine.Color.black, 3f);
		yield return Yield.WaitSeconds(3f);
		player.playerLight.ResetRange();
		player.playerLight.ResetAngle();
		player.playerLight.ResetColour();
		player.playerLight.SetStandardPlayerLightCookie();
		player.HandMenu.exKitScript.candle.GetComponent<OilLighter>().TogglePlayerLightingLayer(on: true);
		UnityEngine.Color color = default(UnityEngine.Color);
		color.r = 1f;
		color.g = 0.8980392f;
		color.b = 0.772549f;
		arenaAmbientLight.color = color;
		yield return Yield.WaitSeconds(0.5f);
		GameController.instance.boundDetection.SwitchOffOOB();
		GameController.instance.GoToSpecificScene(SCENES.PRECINCT);
	}

	private void RestartLevel()
	{
		StartCoroutine(RestartLevelRoutine());
	}

	private IEnumerator RestartLevelRoutine()
	{
		player.screenFX.Fade(UnityEngine.Color.black, 3f);
		yield return Yield.WaitSeconds(3f);
		tuneCross.ResetWindRadius();
		tuneCross.AreaLight(active: false);
		tuneCross.StopBackground();
		tuneCross.StopSFX();
		tuneCross.StopLightTarget();
		tuneCross.TheLight(isEnabled: false);
		player.movement.overrideMovementEnabled = false;
		StartCoroutine(ResetPlayerRoutine());
		player.fishEyeFX.strengthX = 0f;
		player.fishEyeFX.enabled = false;
		player.mainCamera.farClipPlane = 1000f;
		player.playerLight.ResetRange();
		player.playerLight.ResetAngle();
		player.playerLight.ResetColour();
		player.playerLight.SetStandardPlayerLightCookie();
		player.HandMenu.exKitScript.candle.GetComponent<OilLighter>().TogglePlayerLightingLayer(on: true);
		player.HandMenu.playerLightsDisable = false;
		UnityEngine.Color color = default(UnityEngine.Color);
		color.r = 1f;
		color.g = 0.8980392f;
		color.b = 0.772549f;
		arenaAmbientLight.color = color;
		SlowTime(1f);
		GameController.instance.audioController.persistentMusicPlayer.StopLoop();
		if (interactableCross.inEnvironment)
		{
			interactableCross.inEnvironment = false;
			UnityEngine.Object.DontDestroyOnLoad(cross);
		}
		player.MoveToSafeZone();
	}

	private void ResetProgress()
	{
		tuneCross.ResetWindRadius();
		tuneCross.AreaLight(active: false);
		tuneCross.StopBackground();
		tuneCross.StopSFX();
		tuneCross.StopLightTarget();
		tuneCross.TheLight(isEnabled: false);
		player.movement.overrideMovementEnabled = false;
		StartCoroutine(ResetPlayerRoutine());
		player.fishEyeFX.strengthX = 0f;
		player.fishEyeFX.enabled = false;
		player.playerLight.ResetRange();
		player.playerLight.ResetAngle();
		player.playerLight.ResetColour();
		player.HandMenu.exKitScript.candle.GetComponent<OilLighter>().TogglePlayerLightingLayer(on: true);
		player.HandMenu.playerLightsDisable = false;
		UnityEngine.Color color = default(UnityEngine.Color);
		color.r = 1f;
		color.g = 0.8980392f;
		color.b = 0.772549f;
		arenaAmbientLight.color = color;
		player.playerLight.SetStandardPlayerLightCookie();
		SlowTime(1f);
	}

	private IEnumerator ResetPlayerRoutine()
	{
		player.transform.parent = HUD.Instance.transform;
		yield return Yield.EndOfFrame;
		player.transform.parent = null;
		player.transform.rotation = new Quaternion(player.transform.rotation.x, player.transform.rotation.y, 0f, player.transform.rotation.w);
		yield return Yield.EndOfFrame;
	}
}
public class SceneTranslator : MonoBehaviour
{
	[Serializable]
	public class TextMeshTranslationJSON
	{
		[NonSerialized]
		public const string DEFAULT = "TRANSLATION NOT FOUND";

		public string SC;

		public string JP;

		public string ES;

		public string GetTranslation(GameLanguage lan)
		{
			return lan switch
			{
				GameLanguage.ES => ES, 
				GameLanguage.SC => SC, 
				_ => "TRANSLATION NOT FOUND", 
			};
		}
	}

	[Serializable]
	public class TextMeshLineJSON
	{
		public string englishText;

		public TextMeshTranslationJSON translations;
	}

	[Serializable]
	public class TranslationContainerJSON
	{
		public TextMeshLineJSON[] container;
	}

	[Serializable]
	public class TranslationAssets
	{
		public GameLanguage langauge;

		public TMP_FontAsset fontTextMesh;

		public Font fontUnity;

		public Sprite[] images;

		public Texture[] textures;
	}

	[Serializable]
	public class LanguageFontAsset
	{
		public SubtitleLanguage langauge;

		public TMP_FontAsset font;
	}

	[SerializeField]
	private TranslationAssets[] translationAssets;

	private GameLanguage[] changeFontLangauges = new GameLanguage[0];

	private List<TranslationObject> _sceneTranslationObjects = new List<TranslationObject>();

	private TranslationContainerJSON _textMeshTranslations;

	private TranslationContainerJSON _phoneTranslations;

	private GameLanguage _lan;

	public GameLanguage Language
	{
		get
		{
			return _lan;
		}
		set
		{
			if (_lan == value)
			{
				return;
			}
			_lan = value;
			PreferenceManager.instance.SetInt(PlayerPreferences.GAME_LANGUAGE.ToString(), (int)_lan);
			GameController.instance.player.HandMenu.bookScript.UpdateTexturesForLanguage();
			foreach (TranslationObject sceneTranslationObject in _sceneTranslationObjects)
			{
				if (sceneTranslationObject.canTranslate)
				{
					sceneTranslationObject.SetTranslation();
				}
			}
		}
	}

	private void Start()
	{
		_lan = (GameLanguage)PreferenceManager.instance.GetInt(PlayerPreferences.GAME_LANGUAGE.ToString(), 0);
		TextAsset textAsset = Resources.Load("TextMesh_Translations") as TextAsset;
		_textMeshTranslations = (TranslationContainerJSON)JsonUtility.FromJson(textAsset.text, typeof(TranslationContainerJSON));
		textAsset = Resources.Load("TextMesh_Phone_Translations") as TextAsset;
		_phoneTranslations = (TranslationContainerJSON)JsonUtility.FromJson(textAsset.text, typeof(TranslationContainerJSON));
	}

	public void AddTranslationObject(TranslationObject obj)
	{
		_sceneTranslationObjects.Add(obj);
	}

	public void ResetTranslationObjects()
	{
		_sceneTranslationObjects.RemoveAll((TranslationObject item) => !item.persistent);
	}

	public void SetTextMesh(TextMeshProUGUI textMesh, string englishText, TMP_FontAsset originalFont, bool isPhone = false)
	{
		textMesh.font = GetFontAsset(_lan, originalFont);
		if (_lan == GameLanguage.EN || _textMeshTranslations == null)
		{
			textMesh.text = englishText;
			return;
		}
		TextMeshLineJSON textMeshLineJSON = (isPhone ? Array.Find(_phoneTranslations.container, (TextMeshLineJSON e) => e.englishText == englishText.ToLower().Trim()) : Array.Find(_textMeshTranslations.container, (TextMeshLineJSON e) => e.englishText == englishText.ToLower().Trim()));
		if (textMeshLineJSON == null)
		{
			UnityEngine.Debug.LogError("No translation text found for [" + textMesh.gameObject.name + "] with english text [" + englishText.ToLower().Trim() + "]");
			textMesh.font = GetFontAsset(_lan, textMesh.font);
			textMesh.text = englishText;
			return;
		}
		textMesh.text = textMeshLineJSON.translations.GetTranslation(_lan);
		if (textMesh.text == "TRANSLATION NOT FOUND")
		{
			UnityEngine.Debug.LogError("Text mesh line [" + englishText + "] on gameobject [" + textMesh.gameObject.name + "] has no translation for langauge [" + _lan.ToString() + "]");
		}
	}

	public void SetUIText(Text text, string englishText, Font originalFont, bool isPhone = false)
	{
		text.font = GetFontAsset(_lan, originalFont);
		if (_lan == GameLanguage.EN || _textMeshTranslations == null)
		{
			text.text = englishText;
			return;
		}
		TextMeshLineJSON textMeshLineJSON = (isPhone ? Array.Find(_phoneTranslations.container, (TextMeshLineJSON e) => e.englishText == englishText.ToLower().Trim()) : Array.Find(_textMeshTranslations.container, (TextMeshLineJSON e) => e.englishText == englishText.ToLower().Trim()));
		if (textMeshLineJSON == null)
		{
			UnityEngine.Debug.LogError("No translation text found for [" + text.gameObject.name + "] with english text [" + englishText.ToLower().Trim() + "]");
			text.font = GetFontAsset(_lan, text.font);
			text.text = englishText;
			return;
		}
		text.text = textMeshLineJSON.translations.GetTranslation(_lan);
		if (text.text == "TRANSLATION NOT FOUND")
		{
			UnityEngine.Debug.LogError("Unity UI text line [" + englishText + "] on gameobject [" + text.gameObject.name + "] has no translation for langauge [" + _lan.ToString() + "]");
		}
	}

	public string GetTextTranslation(string englishText, bool isPhone = false)
	{
		if (_textMeshTranslations == null)
		{
			return englishText;
		}
		TextMeshLineJSON textMeshLineJSON = (isPhone ? Array.Find(_phoneTranslations.container, (TextMeshLineJSON e) => e.englishText == englishText.ToLower().Trim()) : Array.Find(_textMeshTranslations.container, (TextMeshLineJSON e) => e.englishText == englishText.ToLower().Trim()));
		if (textMeshLineJSON == null)
		{
			UnityEngine.Debug.LogError("No translation text found for [" + englishText.ToLower() + "]");
			return englishText;
		}
		string translation = textMeshLineJSON.translations.GetTranslation(_lan);
		if (translation == "TRANSLATION NOT FOUND")
		{
			return englishText;
		}
		return translation;
	}

	public void SetEmmisiveTexture(Renderer renderer)
	{
		if ((bool)renderer)
		{
			renderer.material.SetTexture("_EmissionMap", GetTexture(renderer.material.GetTexture("_EmissionMap").name));
		}
	}

	public void SetTexture(Renderer renderer)
	{
		if ((bool)renderer)
		{
			renderer.material.mainTexture = GetTexture(renderer.material.mainTexture.name) ?? renderer.material.mainTexture;
		}
	}

	public void SetTexture(RawImage rawImage)
	{
		if ((bool)rawImage)
		{
			rawImage.texture = GetTexture(rawImage.texture.name) ?? rawImage.texture;
		}
	}

	public void SetSprite(SpriteRenderer renderer)
	{
		if ((bool)renderer)
		{
			renderer.sprite = GetSprite(renderer.sprite.name) ?? renderer.sprite;
		}
	}

	public void SetSprite(UnityEngine.UI.Image image)
	{
		if ((bool)image)
		{
			image.sprite = GetSprite(image.sprite.name) ?? image.sprite;
		}
	}

	public Sprite GetSprite(string name)
	{
		string fullname = GetTranslationName(name);
		Sprite sprite = Array.Find(GetTranslationAssets(_lan).images, (Sprite e) => e.name == fullname);
		if (sprite == null)
		{
			UnityEngine.Debug.LogError("No translation sprite found for '" + name + "' missing '" + fullname + "' from array.");
			return null;
		}
		return sprite;
	}

	public Texture GetTexture(string name)
	{
		string fullname = GetTranslationName(name);
		Texture texture = Array.Find(GetTranslationAssets(_lan).textures, (Texture e) => e.name == fullname);
		if (texture == null)
		{
			UnityEngine.Debug.LogError("No translation texture found for '" + name + "' missing '" + fullname + "' from array.");
			return null;
		}
		return texture;
	}

	private string GetTranslationName(string name)
	{
		return name.Substring(0, name.LastIndexOf("_")) + "_" + _lan.ToString().ToLower();
	}

	private TranslationAssets GetTranslationAssets(GameLanguage language)
	{
		return Array.Find(translationAssets, (TranslationAssets e) => e.langauge == language);
	}

	private TMP_FontAsset GetFontAsset(GameLanguage language, TMP_FontAsset originalFont)
	{
		if (Array.IndexOf(changeFontLangauges, language) == -1)
		{
			return originalFont;
		}
		return Array.Find(translationAssets, (TranslationAssets e) => e.langauge == language).fontTextMesh;
	}

	private Font GetFontAsset(GameLanguage language, Font originalFont)
	{
		if (Array.IndexOf(changeFontLangauges, language) == -1)
		{
			return originalFont;
		}
		return Array.Find(translationAssets, (TranslationAssets e) => e.langauge == language).fontUnity;
	}
}
public class SewingMachine : MonoBehaviour
{
	public enum speed
	{
		Slow,
		Medium,
		Fast
	}

	public GameObject needle;

	public GameObject topSpool;

	public bool machineOn = true;

	public speed machineSpeed;

	private Vector3 needleStartPosition;

	public float slowSpeed = 0.75f;

	public float mediumSpeed = 2f;

	public float fastSpeed = 20f;

	[SerializeField]
	private AudioScript audioScript;

	[SerializeField]
	private AudioClip audioClip;

	[SerializeField]
	private AudioClip switchClip;

	public GameObject onButton;

	private float playTime;

	private float delay = 51f;

	[Space]
	[SerializeField]
	private Room closet;

	[SerializeField]
	private Room mums;

	private void Start()
	{
		needleStartPosition = needle.transform.position;
	}

	private void Update()
	{
		if (machineOn)
		{
			if (Time.time > playTime && !audioScript.IsPlaying())
			{
				audioScript.Play(audioClip, 0.7f);
				playTime = Time.time + delay + audioClip.length;
			}
			switch (machineSpeed)
			{
			case speed.Slow:
				needle.transform.position = needleStartPosition + new Vector3(0f, Mathf.Sin(Time.time * slowSpeed) * 0.02f, 0f);
				topSpool.transform.localEulerAngles = new Vector3(0f, topSpool.transform.localEulerAngles.y + Time.deltaTime * slowSpeed, 0f);
				break;
			case speed.Medium:
				needle.transform.position = needleStartPosition + new Vector3(0f, Mathf.Sin(Time.time * mediumSpeed) * 0.02f, 0f);
				topSpool.transform.localEulerAngles = new Vector3(0f, topSpool.transform.localEulerAngles.y + Time.deltaTime * mediumSpeed, 0f);
				break;
			case speed.Fast:
				needle.transform.position = needleStartPosition + new Vector3(0f, Mathf.Sin(Time.time * fastSpeed) * 0.02f, 0f);
				topSpool.transform.localEulerAngles = new Vector3(0f, topSpool.transform.localEulerAngles.y + Time.deltaTime * fastSpeed, 0f);
				break;
			}
			if ((closet.playerInRoom || mums.playerInRoom) && audioScript.mixerChannel != 0)
			{
				audioScript.SetMixerChannel(AudioScript.MixerChannel.sfx);
			}
			else if (!closet.playerInRoom && !mums.playerInRoom)
			{
				audioScript.SetMixerChannel(AudioScript.MixerChannel.effects);
			}
		}
	}

	public void TurnOn()
	{
		machineOn = true;
		audioScript.Play(audioClip, 0.7f);
		playTime = Time.time + delay + audioClip.length;
		onButton.transform.parent.localEulerAngles = new Vector3(0f, -12f, 0f);
		audioScript.PlayOne(switchClip);
	}

	public void TurnOff()
	{
		machineOn = false;
		audioScript.FadeOut(0f);
		onButton.transform.parent.localEulerAngles = Vector3.zero;
		audioScript.PlayOne(switchClip);
	}
}
public class ShaderSwitcher : MonoBehaviour
{
	[SerializeField]
	public SkinnedMeshRenderer[] skinnedMeshRenderers;

	public void SwitchShaders(string newShaderName)
	{
		Shader shader = Shader.Find(newShaderName);
		for (int i = 0; i < skinnedMeshRenderers.Length; i++)
		{
			SkinnedMeshRenderer skinnedMeshRenderer = skinnedMeshRenderers[i];
			for (int j = 0; j < skinnedMeshRenderer.materials.Length; j++)
			{
				skinnedMeshRenderer.materials[j].shader = shader;
			}
		}
	}
}
public class SinkRoaches : MonoBehaviour
{
	[SerializeField]
	private GameObject roaches;

	[SerializeField]
	private ParticleSystem dripParticle;

	[SerializeField]
	private AudioScriptPooled audioScript;

	[SerializeField]
	private AudioClip audioClip;

	private void Start()
	{
		roaches.SetActive(value: false);
	}

	public void RunRoaches()
	{
		roaches.SetActive(value: true);
		dripParticle.Play();
		audioScript.Play(audioClip);
	}
}
[ExecuteInEditMode]
public class SkinnedMeshBaker : MonoBehaviour
{
	public bool doBake;

	public SkinnedMeshRenderer meshToBake;

	public GameObject mesh;
}
public class SlideAudio : SoundObject
{
	[Space]
	[Header("Slide Audio")]
	[SerializeField]
	private AudioClip movementClip;

	[SerializeField]
	private float maxSlideVol = 1f;

	[SerializeField]
	private bool questTeleportingDoor;

	private bool playing;

	private Rigidbody rb;

	private AudioScript slideAudio;

	private new void Start()
	{
		base.Start();
		rb = GetComponent<Rigidbody>();
		GameObject gameObject = new GameObject("Slide Audio");
		gameObject.transform.position = base.gameObject.transform.position;
		gameObject.transform.parent = base.gameObject.transform;
		slideAudio = gameObject.AddComponent<AudioScript>();
		if ((bool)movementClip)
		{
			slideAudio.PlayLoop(movementClip, maxSlideVol);
		}
		slideAudio.m_AudioSource.volume = 0f;
	}

	private void Update()
	{
		if (movementClip != null && !questTeleportingDoor)
		{
			if (!slideAudio.m_AudioSource.isPlaying)
			{
				slideAudio.PlayLoop(movementClip, maxSlideVol);
			}
			float num = rb.velocity.magnitude;
			if (num < 0f)
			{
				num *= -1f;
			}
			slideAudio.m_AudioSource.volume = Mathf.Clamp(num * 2f, 0f, maxSlideVol);
		}
	}

	public void PlaySlideAudioWithFade(float duration)
	{
		StartCoroutine(PlaySlideAudioWithFadeRoutine(duration));
	}

	private IEnumerator PlaySlideAudioWithFadeRoutine(float duration)
	{
		if (!slideAudio.m_AudioSource.isPlaying)
		{
			slideAudio.PlayLoop(movementClip, maxSlideVol);
		}
		for (float counter = 0f; counter < duration; counter += Time.deltaTime)
		{
			float volume = Mathf.Clamp(1f - (1f - counter / duration), 0f, maxSlideVol);
			slideAudio.m_AudioSource.volume = volume;
			yield return Yield.WaitSeconds(Time.deltaTime);
		}
		slideAudio.m_AudioSource.Stop();
	}
}
public class SnakeController : MonoBehaviour
{
	[Serializable]
	public struct Snake
	{
		public GameObject parentObj;

		public GameObject snakeObj;

		public SnakeMovement movement;

		public GameObject exorcismTarget;

		public Renderer matRender;

		public ParticleSystem particleSnakeDeath;

		public ParticleSystem particleMirrorBreak;

		public bool reachedTheCrib;

		[HideInInspector]
		public float heldTime;

		[HideInInspector]
		public bool active;
	}

	[HideInInspector]
	public float holdTime = 3f;

	[HideInInspector]
	public float tuneAt = 30f;

	[HideInInspector]
	public float percentage = 0.5f;

	[Space]
	[SerializeField]
	private Snake[] snakePool;

	private bool exorcismInProgress;

	private float delayBetweenSnakes = 3f;

	private float randomness = 1.25f;

	private int index;

	[HideInInspector]
	public int snakesHit;

	private GameObject cross;

	private TuneController tuneCross;

	private ExorcismItem interactableCross;

	private float highTuneValue;

	private float nextStartTime;

	private void Start()
	{
		cross = GameController.instance.player.HandMenu.exKitScript.cross;
		tuneCross = cross.GetComponent<TuneController>();
		interactableCross = cross.GetComponent<ExorcismItem>();
		for (int i = 0; i < snakePool.Length; i++)
		{
			snakePool[i].heldTime = 0f;
			snakePool[i].active = false;
			snakePool[i].matRender.material.SetFloat("_Amount", 0f);
		}
		nextStartTime = 0f;
	}

	public void StartSnakes()
	{
		exorcismInProgress = true;
		nextStartTime = Time.time + 0.5f;
	}

	public void StopSnake()
	{
		exorcismInProgress = false;
		for (int i = 0; i < snakePool.Length; i++)
		{
			if (snakePool[i].parentObj.activeSelf)
			{
				snakePool[i].movement.ResetPath(snakePool[i].parentObj, snakePool[i].matRender);
			}
		}
		nextStartTime = 0f;
	}

	private void Update()
	{
		if (!exorcismInProgress)
		{
			return;
		}
		if (nextStartTime == 0f)
		{
			nextStartTime = Time.time + delayBetweenSnakes;
		}
		else if (Time.time > nextStartTime)
		{
			if (!snakePool[index].parentObj.activeSelf)
			{
				snakePool[index].parentObj.SetActive(value: true);
				snakePool[index].particleMirrorBreak.Play();
				StartCoroutine(ActivationDelay(index));
			}
			nextStartTime = 0f;
			index = (index + 1) % snakePool.Length;
		}
		highTuneValue = 0f;
		for (int i = 0; i < snakePool.Length; i++)
		{
			if (snakePool[i].active)
			{
				CompareVectors(i);
			}
		}
		new UnityEngine.Color(highTuneValue, highTuneValue, highTuneValue, 1f);
		if (tuneCross.upgraded)
		{
			tuneCross.crossUpgradeMaterial.SetColor("_EmissionColor", UnityEngine.Color.white);
		}
		else
		{
			tuneCross.crossStandardMaterial.SetColor("_EmissionColor", UnityEngine.Color.white);
		}
		if ((bool)interactableCross.AttachedHand)
		{
			if (highTuneValue > percentage)
			{
				interactableCross.AttachedHand.TriggerHapticPulse(5f);
			}
			else
			{
				interactableCross.AttachedHand.TriggerHapticPulse(highTuneValue * 5f);
			}
		}
	}

	private IEnumerator ActivationDelay(int i)
	{
		yield return Yield.WaitSeconds(3f);
		snakePool[i].active = true;
	}

	private void CompareVectors(int i)
	{
		Vector3 from = cross.transform.position - snakePool[i].exorcismTarget.transform.position;
		float num = 1f - Mathf.Clamp(Vector3.Angle(from, -cross.transform.up), 0f, tuneAt) / tuneAt;
		if (num > highTuneValue)
		{
			highTuneValue = num;
		}
		if (!(num > percentage))
		{
			return;
		}
		if (snakePool[i].heldTime > holdTime)
		{
			snakesHit++;
			if (snakesHit < 3)
			{
				tuneAt -= 2.5f;
			}
			percentage += 0.05f;
			ResetSnake(i);
			snakePool[i].particleSnakeDeath.Play();
			tuneCross.ShootBeam(withAudio: false, disableLight: false);
		}
		snakePool[i].heldTime += Time.deltaTime;
	}

	public void ResetSnake(PathMagic path)
	{
		for (int i = 0; i < snakePool.Length; i++)
		{
			if (snakePool[i].movement.waypoint == path.target)
			{
				snakePool[i].reachedTheCrib = true;
				ResetSnake(i);
				break;
			}
		}
	}

	private void ResetSnake(int i)
	{
		snakePool[i].active = false;
		snakePool[i].heldTime = 0f;
		snakePool[i].movement.ResetPath(snakePool[i].parentObj, snakePool[i].matRender);
	}

	public bool DidReachCrib()
	{
		bool result = false;
		for (int i = 0; i < snakePool.Length; i++)
		{
			if (snakePool[i].reachedTheCrib)
			{
				result = true;
			}
		}
		return result;
	}
}
public class SnakeMovement : MonoBehaviour
{
	[SerializeField]
	private Shader questBurnShaderPart1;

	[SerializeField]
	private Shader questBurnShaderPart2;

	[SerializeField]
	private List<GameObject> bodyParts = new List<GameObject>();

	public Transform waypoint;

	public PathMagic path;

	[SerializeField]
	private float speed = 10f;

	[SerializeField]
	private bool canMove;

	private float maxDist;

	private bool block;

	private Vector3[] resetPos;

	private Vector3[] resetRot;

	private Vector3 rotOffset;

	[HideInInspector]
	public AudioScript snakeAudio;

	[SerializeField]
	private AudioClip hissClip;

	private bool hissing;

	private void Awake()
	{
		snakeAudio = bodyParts[0].AddComponent<AudioScript>();
	}

	private void Start()
	{
		maxDist = Vector3.Distance(bodyParts[0].transform.position, bodyParts[1].transform.position);
		speed = 1f / speed;
		resetPos = new Vector3[bodyParts.Count];
		resetRot = new Vector3[bodyParts.Count];
		for (int i = 0; i < bodyParts.Count; i++)
		{
			resetPos[i] = bodyParts[i].transform.position;
			resetRot[i] = bodyParts[i].transform.eulerAngles;
		}
		rotOffset = new Vector3(0f, 0f, 0f);
	}

	private void Update()
	{
		if (canMove)
		{
			if (!block && Vector3.Distance(bodyParts[0].transform.position, waypoint.transform.position) > 0.05f)
			{
				StartCoroutine(MoveSnake());
			}
			if (!hissing)
			{
				StartCoroutine(Hiss());
			}
		}
	}

	private IEnumerator MoveSnake()
	{
		block = true;
		for (int num = bodyParts.Count - 1; num > 0; num--)
		{
			LeanTween.move(bodyParts[num], bodyParts[num - 1].transform.position, speed);
			LeanTween.rotate(bodyParts[num], bodyParts[num - 1].transform.eulerAngles, speed);
		}
		LeanTween.move(bodyParts[0], bodyParts[0].transform.position + (waypoint.transform.position - bodyParts[0].transform.position).normalized * maxDist, speed);
		bodyParts[0].transform.LookAt(waypoint);
		bodyParts[0].transform.localEulerAngles += rotOffset;
		yield return Yield.WaitSeconds(speed);
		block = false;
	}

	private IEnumerator Hiss()
	{
		hissing = true;
		yield return Yield.WaitSeconds(UnityEngine.Random.Range(5f, 10f));
		if (canMove && (bool)snakeAudio && (bool)hissClip)
		{
			snakeAudio.PlayOne(hissClip);
			yield return Yield.WaitSeconds(hissClip.length);
		}
		hissing = false;
	}

	private void OnEnable()
	{
		canMove = true;
		path.gameObject.SetActive(value: true);
		path.CurrentPos = 0f;
		path.Play();
		block = false;
	}

	public void DestinationReached()
	{
		base.gameObject.SetActive(value: false);
	}

	public void ResetPath(GameObject parent, Renderer rend)
	{
		StopAllCoroutines();
		block = true;
		path.Stop();
		canMove = false;
		path.gameObject.SetActive(value: false);
		if (base.gameObject.activeInHierarchy)
		{
			StartCoroutine(ResetSnake(parent, rend));
		}
	}

	private IEnumerator ResetSnake(GameObject parent, Renderer rend)
	{
		StartCoroutine(Dissolve(rend, 1f, 2f, on: false));
		yield return Yield.WaitSeconds(3f);
		for (int i = 0; i < bodyParts.Count; i++)
		{
			LeanTween.move(bodyParts[i], resetPos[i], speed * 2f);
			LeanTween.rotate(bodyParts[i], resetRot[i], speed * 2f);
		}
		yield return Yield.WaitSeconds(speed * 2f);
		StartCoroutine(Dissolve(rend, 0f, 0f, on: true));
		yield return null;
		parent.SetActive(value: false);
	}

	private IEnumerator Dissolve(Renderer rend, float burnTime, float dissolveTime, bool on)
	{
		if (dissolveTime == 0f)
		{
			rend.material.shader = questBurnShaderPart1;
			if (on)
			{
				rend.material.SetFloat("_Amount", 0f);
			}
			else
			{
				rend.material.SetFloat("_Amount", 1f);
			}
			yield break;
		}
		rend.material.shader = questBurnShaderPart1;
		for (float t2 = 0f; t2 < burnTime; t2 += Time.deltaTime)
		{
			rend.material.SetFloat("_Amount", 0.95f / burnTime * t2);
			yield return Yield.EndOfFrame;
		}
		rend.material.shader = questBurnShaderPart2;
		for (float t2 = 0f; t2 < dissolveTime; t2 += Time.deltaTime)
		{
			rend.material.SetFloat("_Amount", Mathf.Clamp(0.95f - 0.55f / dissolveTime * t2, 0.4f, 0.95f));
			yield return Yield.EndOfFrame;
		}
	}

	public void TransitionPath(PathMagic newPath)
	{
		newPath.Stop();
		newPath.target = waypoint;
		newPath.Play();
	}

	public void OffsetRotation(float rot)
	{
		StartCoroutine(UpdateOffset(rot));
	}

	private IEnumerator UpdateOffset(float newRot)
	{
		float current = rotOffset.z;
		float dif = newRot - current;
		for (float t = 0f; t < 1f; t += Time.deltaTime / 0.5f)
		{
			rotOffset.z = current + dif * t;
			yield return null;
		}
	}
}
public class SparkEmitter : MonoBehaviour
{
	private NVRPlayer playerHead;

	[SerializeField]
	private AudioClip sparkSfx;

	[SerializeField]
	private AudioClip gasSfx;

	[SerializeField]
	private AudioScript audioScript;

	[SerializeField]
	private ParticleSystem particle;

	[SerializeField]
	private bool randomDelay;

	private bool playing;

	private bool active;

	private void Start()
	{
		audioScript = GetComponent<AudioScript>();
		particle = GetComponent<ParticleSystem>();
		playerHead = GameObject.Find("Player").GetComponent<NVRPlayer>();
	}

	public void PlaySparks()
	{
		active = true;
	}

	public void StopSparks()
	{
		active = false;
	}

	private IEnumerator FireParticle()
	{
		playing = true;
		if (randomDelay)
		{
			yield return Yield.WaitSeconds(UnityEngine.Random.Range(3f, 10f));
		}
		audioScript.PlayOne(sparkSfx);
		particle.Play();
		playing = false;
	}

	public void PlayOnce()
	{
		StartCoroutine(FireParticle());
	}

	public void loopSound(bool loopingActive)
	{
		if (loopingActive)
		{
			audioScript.PlayLoop(gasSfx, 0.8f);
		}
		else
		{
			audioScript.StopLoop();
		}
	}

	private void Update()
	{
		if (active)
		{
			base.transform.LookAt(playerHead.Head.transform);
			if (!playing)
			{
				StartCoroutine(FireParticle());
			}
		}
	}
}
public class SplashObject : MonoBehaviour
{
	private AudioScriptPooled audioScript;

	public const string SPLASH_TAG = "SplashTrigger";

	[SerializeField]
	private AudioClip splashSoundSoft;

	[SerializeField]
	private AudioClip splashSoundHard;

	[SerializeField]
	private Rigidbody body;

	private void Start()
	{
		if (!base.gameObject.GetComponent<AudioScriptPooled>())
		{
			audioScript = base.gameObject.AddComponent<AudioScriptPooled>();
		}
		else
		{
			audioScript = base.gameObject.GetComponent<AudioScriptPooled>();
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.tag == "SplashTrigger")
		{
			PlaySound();
			body.velocity = new Vector3(0f, body.velocity.y, 0f);
		}
	}

	private void OnTriggerExit(Collider other)
	{
		_ = other.tag == "SplashTrigger";
	}

	public void PlaySound()
	{
		float num = Mathf.Abs(body.velocity.magnitude);
		if (num > 0f)
		{
			if (audioScript != null)
			{
				audioScript.SetMixerChannel(AudioScript.MixerChannel.sfx);
			}
			else
			{
				audioScript.SetMixerChannel(AudioScript.MixerChannel.sfx);
			}
			if (splashSoundSoft != null && num > 0.1f && num < 0.5f)
			{
				audioScript.PlayOneShot(splashSoundSoft);
			}
			else if (splashSoundHard != null && num >= 0.5f)
			{
				audioScript.PlayOneShot(splashSoundHard);
			}
		}
	}
}
public class Store : MonoBehaviour
{
}
public class HUD : MonoBehaviour
{
	[SerializeField]
	private SceneTranslator.LanguageFontAsset[] subtitleFonts;

	[SerializeField]
	private GameObject subsCanvas;

	[SerializeField]
	private TextMeshProUGUI subsTextHolder;

	[SerializeField]
	private Transform followPoint;

	public static HUD Instance;

	private const float kFollowSpeed = 6.5f;

	private float fadeTime = 0.35f;

	private bool block;

	private bool _playing;

	private bool _playingLowPriority;

	private bool _shouldUpdateFont;

	private SubtitleLanguage _currentLanguage;

	private void Start()
	{
		Instance = this;
		UnityEngine.Object.DontDestroyOnLoad(Instance);
		SetSubsLanguage((SubtitleLanguage)PlayerPrefs.GetInt(PlayerPreferences.SUBTITLE_LANGUAGE.ToString(), 0));
		subsTextHolder.text = string.Empty;
	}

	public void DisplayNotEntitledErrorMessage()
	{
		subsTextHolder.text = GameController.instance.translator.GetTextTranslation("You are not entitled to run this game, if you believe this to be an error please contact support@exorcistlegion.com");
	}

	public void DisplayClosingAppErrorMessage()
	{
		subsTextHolder.text = GameController.instance.translator.GetTextTranslation("The game will now close");
	}

	private void FixedUpdate()
	{
		base.transform.position = Vector3.Lerp(base.transform.position, followPoint.position, Time.deltaTime * 6.5f);
		base.transform.rotation = Quaternion.Lerp(base.transform.rotation, followPoint.rotation, Time.deltaTime * 6.5f);
	}

	public void SetSubsLanguage(SubtitleLanguage lan)
	{
		if (lan == _currentLanguage)
		{
			return;
		}
		PlayerPrefs.SetInt(PlayerPreferences.SUBTITLE_LANGUAGE.ToString(), (int)lan);
		if (lan != 0)
		{
			if (_playing)
			{
				_shouldUpdateFont = true;
			}
			else
			{
				subsTextHolder.font = Array.Find(subtitleFonts, (SceneTranslator.LanguageFontAsset e) => e.langauge == lan).font;
			}
		}
		else
		{
			KillSubtitles();
		}
		_currentLanguage = lan;
	}

	public void PlaySubtitles(string clipName, GameObject canvas, TextMeshProUGUI text)
	{
		if (_currentLanguage != 0)
		{
			StopAllCoroutines();
			subsCanvas = canvas;
			subsTextHolder = text;
			StartCoroutine(PlaySubtitlesRoutine(clipName));
		}
	}

	public void PlaySubtitles(string clipName, bool hasPriority)
	{
		if ((hasPriority || !_playing) && _currentLanguage != 0)
		{
			_playingLowPriority = !hasPriority;
			subsTextHolder.text = string.Empty;
			StopAllCoroutines();
			_playing = false;
			StartCoroutine(PlaySubtitlesRoutine(clipName));
		}
	}

	public void KillSubtitlesIfLowPriority()
	{
		if (_playingLowPriority)
		{
			StopAllCoroutines();
			subsCanvas.SetActive(value: false);
			_playing = false;
			subsTextHolder.text = string.Empty;
		}
	}

	public void KillSubtitles()
	{
		StopAllCoroutines();
		subsCanvas.SetActive(value: false);
		_playing = false;
		_playingLowPriority = false;
		subsTextHolder.text = string.Empty;
	}

	private IEnumerator PlaySubtitlesRoutine(string clipName)
	{
		if (_playing)
		{
			yield break;
		}
		subsCanvas.SetActive(value: true);
		_playing = true;
		float delay = 0f;
		LanguageJSON dialogue = SubtitleManager.Instance.GetDialogue(clipName, out delay, _currentLanguage);
		yield return new WaitForSeconds(delay);
		DialogueLineJSON[] lines = dialogue.lines;
		for (int i = 0; i < lines.Length; i++)
		{
			DialogueLineJSON dialogueLineJSON = lines[i];
			subsTextHolder.text = dialogueLineJSON.text;
			yield return new WaitForSeconds(dialogueLineJSON.duration);
		}
		if (_shouldUpdateFont)
		{
			_shouldUpdateFont = false;
			subsTextHolder.font = Array.Find(subtitleFonts, (SceneTranslator.LanguageFontAsset e) => e.langauge == _currentLanguage).font;
		}
		subsTextHolder.text = string.Empty;
		_playing = false;
		_playingLowPriority = false;
		subsCanvas.SetActive(value: false);
	}
}
public class Switch : MonoBehaviour
{
	public enum SwitchStates
	{
		ON,
		OFF
	}

	private SwitchStates switchState = SwitchStates.OFF;

	private bool active;

	private void OnTriggerEnter(Collider other)
	{
		if (!active)
		{
			StartCoroutine(ToggleSwitch());
		}
	}

	private IEnumerator ToggleSwitch()
	{
		active = true;
		if (switchState == SwitchStates.ON)
		{
			switchState = SwitchStates.OFF;
			LeanTween.rotateZ(base.gameObject, base.transform.rotation.x - 30f, 0.2f);
		}
		else
		{
			switchState = SwitchStates.ON;
			LeanTween.rotateZ(base.gameObject, base.transform.rotation.x + 30f, 0.2f);
		}
		yield return Yield.WaitSeconds(1f);
		active = false;
	}
}
public class TabletComputer : MonoBehaviour
{
	[SerializeField]
	public Printer printer;

	[Space]
	[Header("Textures and Materials")]
	[SerializeField]
	public Renderer screen;

	[SerializeField]
	public Texture bootScreenTexture;

	[SerializeField]
	public Texture bootScreenTwoTexture;

	[SerializeField]
	public Texture menuScreenTexture;

	[SerializeField]
	public Texture medicalRecordsTexture;

	[SerializeField]
	public Texture medicalRecords1ViewTexture;

	[SerializeField]
	public Texture medicalRecords2ViewTexture;

	[SerializeField]
	public Texture medicalRecords3ViewTexture;

	[SerializeField]
	public Texture medicalRecords4ViewTexture;

	[SerializeField]
	public Texture medicalRecords5ViewTexture;

	[SerializeField]
	public Texture labNotesTexture;

	[SerializeField]
	public Texture labNote1ViewTexture;

	[SerializeField]
	public bool labNote1Viewed;

	[SerializeField]
	public Texture labNote2ViewTexture;

	[SerializeField]
	public bool labNote2Viewed;

	[SerializeField]
	public Texture labNote3ViewTexture;

	[SerializeField]
	public bool labNote3Viewed;

	[Space]
	[Header("Screens")]
	[SerializeField]
	public GameObject fadeScreen;

	[SerializeField]
	public GameObject menuScreen;

	[SerializeField]
	public GameObject medicalRecordsScreen;

	[SerializeField]
	public GameObject medicalRecordsViewScreen;

	[SerializeField]
	public GameObject labNotesScreen;

	[SerializeField]
	public GameObject labNoteViewScreen;

	[Space]
	[Header("Audio")]
	[SerializeField]
	private AudioScriptPooled audioScript;

	[SerializeField]
	private AudioClip clipComputerUnlock;

	[SerializeField]
	private AudioClip clipComputerButton;

	[SerializeField]
	private float buttonVolume = 0.65f;

	[SerializeField]
	private AudioClip clipComputerCorrect;

	[SerializeField]
	private AudioClip clipComputerFail;

	[HideInInspector]
	public bool isPoweredOn;

	[HideInInspector]
	private int currentMedicalRecordNumber = -1;

	private void Start()
	{
		isPoweredOn = false;
		base.gameObject.SetLayer(LayerMask.NameToLayer("Lighting02"));
		Texture texture = GameController.instance.translator.GetTexture(bootScreenTexture.name);
		screen.material.SetTexture("_EmissionMap", texture ? texture : bootScreenTexture);
		screen.material.SetColor("_EmissionColor", UnityEngine.Color.black);
		fadeScreen.SetActive(value: false);
		menuScreen.SetActive(value: false);
		medicalRecordsScreen.SetActive(value: false);
		medicalRecordsViewScreen.SetActive(value: false);
		labNotesScreen.SetActive(value: false);
		labNoteViewScreen.SetActive(value: false);
	}

	private void Update()
	{
	}

	public void PowerButtonPressed()
	{
		if (isPoweredOn)
		{
			base.gameObject.SetLayer(LayerMask.NameToLayer("Lighting02"));
			screen.material.SetColor("_EmissionColor", UnityEngine.Color.black);
			isPoweredOn = false;
			return;
		}
		base.gameObject.SetLayer(LayerMask.NameToLayer("PointerInteractableTrigger"));
		isPoweredOn = true;
		screen.material.SetColor("_EmissionColor", UnityEngine.Color.white);
		Texture texture = GameController.instance.translator.GetTexture(bootScreenTexture.name);
		screen.material.SetTexture("_EmissionMap", texture ? texture : bootScreenTexture);
		StartCoroutine(BootUp());
	}

	private IEnumerator BootUp()
	{
		yield return Yield.WaitSeconds(1f);
		audioScript.Play(clipComputerCorrect);
		yield return StartCoroutine(ShowFadeOverlay());
		Texture texture = GameController.instance.translator.GetTexture(bootScreenTwoTexture.name);
		screen.material.SetTexture("_EmissionMap", texture ? texture : bootScreenTwoTexture);
		yield return Yield.WaitSeconds(1f);
		yield return StartCoroutine(ShowFadeOverlay());
		texture = GameController.instance.translator.GetTexture(menuScreenTexture.name);
		screen.material.SetTexture("_EmissionMap", texture ? texture : menuScreenTexture);
		menuScreen.SetActive(value: true);
		yield return Yield.EndOfFrame;
		yield return StartCoroutine(HideFadeOverlay());
	}

	public void MenuMedicalRecordsButtonPressed()
	{
		StartCoroutine(MenuMedicalRecordsButtonPressedRoutine());
	}

	private IEnumerator MenuMedicalRecordsButtonPressedRoutine()
	{
		audioScript.Play(clipComputerButton, buttonVolume);
		yield return StartCoroutine(ShowFadeOverlay());
		yield return Yield.EndOfFrame;
		menuScreen.SetActive(value: false);
		Texture texture = GameController.instance.translator.GetTexture(medicalRecordsTexture.name);
		screen.material.SetTexture("_EmissionMap", texture ? texture : medicalRecordsTexture);
		medicalRecordsScreen.SetActive(value: true);
		yield return Yield.EndOfFrame;
		yield return StartCoroutine(HideFadeOverlay());
	}

	public void MenuLabNotesButtonPressed()
	{
		StartCoroutine(MenuLabNotesButtonPressedRoutine());
	}

	private IEnumerator MenuLabNotesButtonPressedRoutine()
	{
		audioScript.Play(clipComputerButton, buttonVolume);
		yield return StartCoroutine(ShowFadeOverlay());
		yield return Yield.EndOfFrame;
		menuScreen.SetActive(value: false);
		Texture texture = GameController.instance.translator.GetTexture(labNotesTexture.name);
		screen.material.SetTexture("_EmissionMap", texture ? texture : labNotesTexture);
		labNotesScreen.SetActive(value: true);
		yield return Yield.EndOfFrame;
		yield return StartCoroutine(HideFadeOverlay());
	}

	public void MedicalRecordsBackButtonPressed()
	{
		StartCoroutine(MedicalRecordsBackButtonPressedRoutine());
	}

	private IEnumerator MedicalRecordsBackButtonPressedRoutine()
	{
		audioScript.Play(clipComputerButton, buttonVolume);
		yield return StartCoroutine(ShowFadeOverlay());
		yield return Yield.EndOfFrame;
		medicalRecordsScreen.SetActive(value: false);
		Texture texture = GameController.instance.translator.GetTexture(menuScreenTexture.name);
		screen.material.SetTexture("_EmissionMap", texture ? texture : menuScreenTexture);
		menuScreen.SetActive(value: true);
		yield return Yield.EndOfFrame;
		yield return StartCoroutine(HideFadeOverlay());
	}

	public void MedicalRecordsSelectButtonPressed(int recordNumber)
	{
		currentMedicalRecordNumber = recordNumber;
		StartCoroutine(MedicalRecordsSelectButtonPressedRoutine(recordNumber));
	}

	private IEnumerator MedicalRecordsSelectButtonPressedRoutine(int recordNumber)
	{
		yield return StartCoroutine(ShowFadeOverlay());
		audioScript.Play(clipComputerButton, buttonVolume);
		yield return Yield.EndOfFrame;
		medicalRecordsScreen.SetActive(value: false);
		switch (recordNumber)
		{
		case 0:
		{
			Texture texture = GameController.instance.translator.GetTexture(medicalRecords1ViewTexture.name);
			screen.material.SetTexture("_EmissionMap", texture ? texture : medicalRecords1ViewTexture);
			break;
		}
		case 1:
		{
			Texture texture = GameController.instance.translator.GetTexture(medicalRecords2ViewTexture.name);
			screen.material.SetTexture("_EmissionMap", texture ? texture : medicalRecords2ViewTexture);
			break;
		}
		case 2:
		{
			Texture texture = GameController.instance.translator.GetTexture(medicalRecords3ViewTexture.name);
			screen.material.SetTexture("_EmissionMap", texture ? texture : medicalRecords3ViewTexture);
			break;
		}
		case 3:
		{
			Texture texture = GameController.instance.translator.GetTexture(medicalRecords4ViewTexture.name);
			screen.material.SetTexture("_EmissionMap", texture ? texture : medicalRecords4ViewTexture);
			break;
		}
		case 4:
		{
			Texture texture = GameController.instance.translator.GetTexture(medicalRecords5ViewTexture.name);
			screen.material.SetTexture("_EmissionMap", texture ? texture : medicalRecords5ViewTexture);
			break;
		}
		default:
		{
			Texture texture = GameController.instance.translator.GetTexture(medicalRecords1ViewTexture.name);
			screen.material.SetTexture("_EmissionMap", texture ? texture : medicalRecords1ViewTexture);
			break;
		}
		}
		medicalRecordsViewScreen.SetActive(value: true);
		yield return Yield.EndOfFrame;
		yield return StartCoroutine(HideFadeOverlay());
	}

	public void MedicalRecordsViewBackButtonPressed()
	{
		currentMedicalRecordNumber = -1;
		StartCoroutine(MedicalRecordsViewBackButtonPressedRoutine());
	}

	private IEnumerator MedicalRecordsViewBackButtonPressedRoutine()
	{
		audioScript.Play(clipComputerButton, buttonVolume);
		yield return StartCoroutine(ShowFadeOverlay());
		yield return Yield.EndOfFrame;
		medicalRecordsViewScreen.SetActive(value: false);
		Texture texture = GameController.instance.translator.GetTexture(medicalRecordsTexture.name);
		screen.material.SetTexture("_EmissionMap", texture ? texture : medicalRecordsTexture);
		medicalRecordsScreen.SetActive(value: true);
		yield return Yield.EndOfFrame;
		yield return StartCoroutine(HideFadeOverlay());
	}

	public void MedicalRecordsViewPrintButtonPressed()
	{
		StartCoroutine(MedicalRecordsViewPrintButtonPressedRoutine());
	}

	private IEnumerator MedicalRecordsViewPrintButtonPressedRoutine()
	{
		if (printer.isPoweredOn && currentMedicalRecordNumber != -1)
		{
			if (printer.CanPrintKeycard() && !printer.HasPrintedKeycard(currentMedicalRecordNumber))
			{
				audioScript.PlayOneShot(clipComputerButton, buttonVolume);
				printer.PrintKeycard(currentMedicalRecordNumber);
			}
			else
			{
				audioScript.PlayOneShot(clipComputerFail);
			}
		}
		yield return Yield.EndOfFrame;
	}

	public void LabNotesBackButtonPressed()
	{
		StartCoroutine(LabNotesBackButtonPressedRoutine());
	}

	private IEnumerator LabNotesBackButtonPressedRoutine()
	{
		audioScript.Play(clipComputerButton, buttonVolume);
		yield return StartCoroutine(ShowFadeOverlay());
		yield return Yield.EndOfFrame;
		labNotesScreen.SetActive(value: false);
		Texture texture = GameController.instance.translator.GetTexture(menuScreenTexture.name);
		screen.material.SetTexture("_EmissionMap", texture ? texture : menuScreenTexture);
		menuScreen.SetActive(value: true);
		yield return Yield.EndOfFrame;
		yield return StartCoroutine(HideFadeOverlay());
	}

	public void LabNotesSelectButtonPressed(int noteNumber)
	{
		StartCoroutine(LabNotesSelectButtonPressedRoutine(noteNumber));
	}

	private IEnumerator LabNotesSelectButtonPressedRoutine(int noteNumber)
	{
		audioScript.Play(clipComputerButton, buttonVolume);
		yield return StartCoroutine(ShowFadeOverlay());
		yield return Yield.EndOfFrame;
		labNotesScreen.SetActive(value: false);
		switch (noteNumber)
		{
		case 0:
		{
			labNote1Viewed = true;
			Texture texture = GameController.instance.translator.GetTexture(labNote1ViewTexture.name);
			screen.material.SetTexture("_EmissionMap", texture ? texture : labNote1ViewTexture);
			break;
		}
		case 1:
		{
			labNote2Viewed = true;
			Texture texture = GameController.instance.translator.GetTexture(labNote2ViewTexture.name);
			screen.material.SetTexture("_EmissionMap", texture ? texture : labNote2ViewTexture);
			break;
		}
		case 2:
		{
			labNote3Viewed = true;
			Texture texture = GameController.instance.translator.GetTexture(labNote3ViewTexture.name);
			screen.material.SetTexture("_EmissionMap", texture ? texture : labNote3ViewTexture);
			break;
		}
		default:
		{
			Texture texture = GameController.instance.translator.GetTexture(labNote1ViewTexture.name);
			screen.material.SetTexture("_EmissionMap", texture ? texture : labNote1ViewTexture);
			break;
		}
		}
		labNoteViewScreen.SetActive(value: true);
		yield return Yield.EndOfFrame;
		yield return StartCoroutine(HideFadeOverlay());
	}

	public void LabNoteViewBackButtonPressed()
	{
		StartCoroutine(LabNoteViewBackButtonPressedRoutine());
	}

	private IEnumerator LabNoteViewBackButtonPressedRoutine()
	{
		audioScript.Play(clipComputerButton, buttonVolume);
		yield return StartCoroutine(ShowFadeOverlay());
		yield return Yield.EndOfFrame;
		labNoteViewScreen.SetActive(value: false);
		Texture texture = GameController.instance.translator.GetTexture(labNotesTexture.name);
		screen.material.SetTexture("_EmissionMap", texture ? texture : labNotesTexture);
		labNotesScreen.SetActive(value: true);
		yield return Yield.EndOfFrame;
		yield return StartCoroutine(HideFadeOverlay());
	}

	private IEnumerator ShowFadeOverlay()
	{
		yield return Yield.EndOfFrame;
	}

	private IEnumerator HideFadeOverlay()
	{
		yield return Yield.EndOfFrame;
	}

	private void OnTriggerEnter(Collider other)
	{
	}
}
public class Tap : MonoBehaviour
{
	public enum TapType
	{
		TAP,
		FLUSH
	}

	public enum Axis
	{
		X,
		Y,
		Z
	}

	[Serializable]
	public struct TapRotate
	{
		public GameObject tap;

		public Axis rotateAxis;

		public float rotateTo;

		[HideInInspector]
		public float origionalRotation;
	}

	[SerializeField]
	private TapType type;

	[Space]
	[SerializeField]
	private TapRotate[] taps;

	[Space]
	[SerializeField]
	private ParticleSystem particles;

	[SerializeField]
	private float animTime;

	[Space]
	[SerializeField]
	private AudioScript audio;

	[SerializeField]
	private AudioClip tapSound;

	[SerializeField]
	private AudioClip liquidSound;

	[SerializeField]
	private AudioClip flushSound;

	private bool isOn;

	[Space]
	public bool canTurnOn = true;

	private bool flushing;

	private void Start()
	{
		for (int i = 0; i < taps.Length; i++)
		{
			if (taps[i].rotateAxis == Axis.X)
			{
				taps[i].origionalRotation = taps[i].tap.transform.eulerAngles.x;
			}
			if (taps[i].rotateAxis == Axis.Y)
			{
				taps[i].origionalRotation = taps[i].tap.transform.eulerAngles.y;
			}
			if (taps[i].rotateAxis == Axis.Z)
			{
				taps[i].origionalRotation = taps[i].tap.transform.eulerAngles.z;
			}
		}
	}

	public void TurnOn()
	{
		isOn = true;
		StopAllCoroutines();
		for (int i = 0; i < taps.Length; i++)
		{
			LeanTween.cancel(taps[i].tap);
		}
		StartCoroutine(TurnOnRoutine());
	}

	private IEnumerator TurnOnRoutine()
	{
		if ((bool)audio && (bool)tapSound)
		{
			audio.PlayOne(tapSound);
		}
		for (int i = 0; i < taps.Length; i++)
		{
			if (taps[i].rotateAxis == Axis.X)
			{
				LeanTween.rotateX(taps[i].tap, taps[i].rotateTo, animTime).setEaseInOutSine();
			}
			if (taps[i].rotateAxis == Axis.Y)
			{
				LeanTween.rotateY(taps[i].tap, taps[i].rotateTo, animTime).setEaseInOutSine();
			}
			if (taps[i].rotateAxis == Axis.Z)
			{
				LeanTween.rotateZ(taps[i].tap, taps[i].rotateTo, animTime).setEaseInOutSine();
			}
		}
		yield return Yield.WaitSeconds(animTime);
		particles.Play();
		if ((bool)audio && (bool)liquidSound)
		{
			audio.PlayLoop(liquidSound);
		}
	}

	public void TurnOff()
	{
		isOn = false;
		StopAllCoroutines();
		for (int i = 0; i < taps.Length; i++)
		{
			LeanTween.cancel(taps[i].tap);
		}
		particles.Stop();
		if ((bool)audio && (bool)liquidSound)
		{
			audio.StopLoop();
		}
		for (int j = 0; j < taps.Length; j++)
		{
			if (taps[j].rotateAxis == Axis.X)
			{
				LeanTween.rotateX(taps[j].tap, taps[j].origionalRotation, animTime).setEaseInOutSine();
			}
			if (taps[j].rotateAxis == Axis.Y)
			{
				LeanTween.rotateY(taps[j].tap, taps[j].origionalRotation, animTime).setEaseInOutSine();
			}
			if (taps[j].rotateAxis == Axis.Z)
			{
				LeanTween.rotateZ(taps[j].tap, taps[j].origionalRotation, animTime).setEaseInOutSine();
			}
		}
	}

	private IEnumerator Flush()
	{
		flushing = true;
		for (int i = 0; i < taps.Length; i++)
		{
			if (taps[i].rotateAxis == Axis.X)
			{
				LeanTween.rotateX(taps[i].tap, taps[i].rotateTo, animTime).setEaseInOutSine();
			}
			if (taps[i].rotateAxis == Axis.Y)
			{
				LeanTween.rotateY(taps[i].tap, taps[i].rotateTo, animTime).setEaseInOutSine();
			}
			if (taps[i].rotateAxis == Axis.Z)
			{
				LeanTween.rotateZ(taps[i].tap, taps[i].rotateTo, animTime).setEaseInOutSine();
			}
		}
		yield return Yield.WaitSeconds(animTime);
		if ((bool)particles)
		{
			particles.Play();
		}
		for (int j = 0; j < taps.Length; j++)
		{
			if (taps[j].rotateAxis == Axis.X)
			{
				LeanTween.rotateX(taps[j].tap, taps[j].origionalRotation, animTime).setEaseInOutSine();
			}
			if (taps[j].rotateAxis == Axis.Y)
			{
				LeanTween.rotateY(taps[j].tap, taps[j].origionalRotation, animTime).setEaseInOutSine();
			}
			if (taps[j].rotateAxis == Axis.Z)
			{
				LeanTween.rotateZ(taps[j].tap, taps[j].origionalRotation, animTime).setEaseInOutSine();
			}
		}
		if ((bool)audio && (bool)flushSound)
		{
			audio.Play(flushSound);
			yield return Yield.WaitSeconds(flushSound.length);
		}
		else
		{
			yield return Yield.WaitSeconds(3f);
		}
		if ((bool)particles)
		{
			particles.Stop();
		}
		flushing = false;
	}

	public void ToggleInteraction()
	{
		if (type == TapType.TAP)
		{
			if (canTurnOn)
			{
				if (isOn)
				{
					TurnOff();
				}
				else
				{
					TurnOn();
				}
			}
		}
		else if (type == TapType.FLUSH && !flushing)
		{
			StartCoroutine(Flush());
		}
	}
}
public class TapePlayer : MonoBehaviour
{
	[SerializeField]
	private Renderer ledLight;

	[SerializeField]
	private GameObject buttonPlay;

	[SerializeField]
	private GameObject tapePlayerLid;

	[SerializeField]
	private GameObject tapePosition;

	[SerializeField]
	private AudioClip switchOffSound;

	private bool alertLightActive;

	private bool lightOn = true;

	private float startPosPlayButton;

	[Space]
	[SerializeField]
	private GameObject tape1;

	[SerializeField]
	private GameObject tape2;

	[SerializeField]
	private GameObject tape3;

	[Space]
	[SerializeField]
	private AudioClip tapePlayerClip1;

	[SerializeField]
	private AudioClip tapePlayerClip2;

	[SerializeField]
	private AudioClip tapePlayerClip3;

	[Space]
	[SerializeField]
	private AudioClip tapeSpeakerClip1;

	[SerializeField]
	private AudioClip tapeSpeakerClip2;

	[SerializeField]
	private AudioClip tapeSpeakerClip3;

	private GameObject tapeInPlayer;

	public bool tapePlaying;

	public bool playedTape2;

	public bool playedTape3;

	[Space]
	[SerializeField]
	private GameObject respawnPoint;

	[SerializeField]
	private AudioScript tapeSpeakerMainHall;

	[SerializeField]
	private AudioScript tapePlayerScript;

	private Coroutine playCoroutine;

	private Coroutine lightCorountine;

	private NVRInteractableItem tape1Item;

	private NVRInteractableItem tape2Item;

	private NVRInteractableItem tape3Item;

	private void Start()
	{
		startPosPlayButton = buttonPlay.transform.localPosition.y;
		AlertLight(setActive: true);
		if ((bool)tape1)
		{
			tape1Item = tape1.GetComponent<NVRInteractableItem>();
		}
		if ((bool)tape2)
		{
			tape2Item = tape2.GetComponent<NVRInteractableItem>();
		}
		if ((bool)tape3)
		{
			tape3Item = tape3.GetComponent<NVRInteractableItem>();
		}
	}

	private void PlayButtonDown(float time)
	{
		LeanTween.rotateLocal(buttonPlay, new Vector3(25f, 0f, 0f), time);
		LeanTween.moveLocalY(buttonPlay, 0.02f, time);
		LeanTween.rotateLocal(tapePlayerLid, new Vector3(0f, 0f, 0f), time);
		AlertLight(setActive: true, solidLight: true);
	}

	private void PlayButtonUp(float time)
	{
		LeanTween.rotateLocal(buttonPlay, new Vector3(0f, 0f, 0f), time);
		LeanTween.moveLocalY(buttonPlay, startPosPlayButton, time);
		LeanTween.rotateLocal(tapePlayerLid, new Vector3(-25f, 0f, 0f), time);
		AlertLight(setActive: true);
	}

	public bool PlayTape()
	{
		if (!tapePlaying && (bool)tapeInPlayer)
		{
			tapeInPlayer.GetComponent<NVRInteractableItem>().CanAttach = false;
			playCoroutine = StartCoroutine(PlayTapeRoutine());
			if (tapeInPlayer == tape1 || tapeInPlayer == tape2)
			{
				return true;
			}
		}
		return false;
	}

	private IEnumerator PlayTapeRoutine()
	{
		tapePlaying = true;
		PlayButtonDown(0.25f);
		yield return Yield.WaitSeconds(0.25f);
		if (tapeInPlayer == tape1)
		{
			tapePlayerScript.Play(tapePlayerClip1);
			HUD.Instance.PlaySubtitles(tapePlayerClip1.name, hasPriority: true);
			if ((bool)tapeSpeakerMainHall)
			{
				tapeSpeakerMainHall.Play(tapeSpeakerClip1);
			}
			yield return Yield.WaitSeconds(tapePlayerClip1.length);
		}
		else if (tapeInPlayer == tape2)
		{
			playedTape2 = true;
			tapePlayerScript.Play(tapePlayerClip2);
			HUD.Instance.PlaySubtitles(tapePlayerClip2.name, hasPriority: true);
			if ((bool)tapeSpeakerMainHall)
			{
				tapeSpeakerMainHall.Play(tapeSpeakerClip2);
			}
			yield return Yield.WaitSeconds(tapePlayerClip2.length);
		}
		else if (tapeInPlayer == tape3)
		{
			playedTape3 = true;
			tapePlayerScript.Play(tapePlayerClip3);
			HUD.Instance.PlaySubtitles(tapePlayerClip3.name, hasPriority: true);
			if ((bool)tapeSpeakerMainHall)
			{
				tapeSpeakerMainHall.Play(tapeSpeakerClip3);
			}
			yield return Yield.WaitSeconds(tapePlayerClip3.length);
		}
		yield return Yield.WaitSeconds(1f);
		PlayButtonUp(0.25f);
		yield return Yield.WaitSeconds(0.25f);
		RespawnTape();
		yield return Yield.WaitSeconds(1f);
		tapePlaying = false;
	}

	public void stopTape()
	{
		if (tapePlaying)
		{
			StopCoroutine(playCoroutine);
			tapePlayerScript.FadeOut(0.25f);
			if ((bool)tapeSpeakerMainHall)
			{
				tapeSpeakerMainHall.FadeOut(0.25f);
			}
			PlayButtonUp(0.25f);
			RespawnTape();
			tapePlaying = false;
			tapePlayerScript.PlayOne(switchOffSound);
		}
	}

	private void RespawnTape()
	{
		if ((bool)tapeInPlayer)
		{
			tapeInPlayer.transform.position = respawnPoint.transform.position;
			tapeInPlayer.transform.rotation = respawnPoint.transform.rotation;
			tapeInPlayer.GetComponent<NVRInteractableItem>().CanAttach = true;
			tapeInPlayer.GetComponent<Rigidbody>().isKinematic = false;
			tapeInPlayer = null;
		}
	}

	public void AlertLight(bool setActive, bool solidLight = false)
	{
		if (lightCorountine != null)
		{
			StopCoroutine(lightCorountine);
		}
		if (setActive && !solidLight)
		{
			lightCorountine = StartCoroutine(AlertLightRoutine());
			return;
		}
		if (setActive && solidLight)
		{
			lightCorountine = StartCoroutine(AlertLightRoutine(solidLight: true));
			return;
		}
		StopCoroutine(lightCorountine);
		alertLightActive = false;
		lightOn = false;
		ledLight.enabled = false;
	}

	private IEnumerator AlertLightRoutine(bool solidLight = false)
	{
		WaitForSeconds lightWait = new WaitForSeconds(1f);
		alertLightActive = true;
		if (!solidLight)
		{
			while (alertLightActive)
			{
				lightOn = !lightOn;
				ledLight.enabled = lightOn;
				yield return lightWait;
			}
		}
		else
		{
			lightOn = true;
			ledLight.enabled = true;
			yield return lightWait;
		}
	}

	private void SwapTapes(GameObject tape)
	{
		RespawnTape();
		tape.transform.position = tapePosition.transform.position;
		tape.transform.rotation = tapePosition.transform.rotation;
		tapeInPlayer = tape;
		tapeInPlayer.GetComponent<Rigidbody>().isKinematic = true;
		tapeInPlayer.GetComponent<NVRInteractableItem>().CanAttach = false;
	}

	private void OnTriggerStay(Collider other)
	{
		if (tapePlaying)
		{
			return;
		}
		if (other.gameObject == tape1)
		{
			if (!tape1Item.AttachedHand)
			{
				SwapTapes(tape1);
			}
		}
		else if (other.gameObject == tape2)
		{
			if (!tape2Item.AttachedHand)
			{
				SwapTapes(tape2);
			}
		}
		else if (other.gameObject == tape3 && !tape3Item.AttachedHand)
		{
			SwapTapes(tape3);
		}
	}
}
public class TileWobbler : MonoBehaviour
{
	private float speed = 1f;

	private float amount = 1f;

	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class TombFloatingAudioManager : FloatingPointAudioManager
{
	[Serializable]
	public struct FloatingPointAudioContainer
	{
		public GameObject trigger;

		public AudioScript audioScript;

		public bool hasSubTrack;

		public FloatingPointAudio[] floatingPointAudioClips;
	}

	[Header("Area Trigger Floating Audio")]
	[SerializeField]
	public FloatingPointAudioContainer[] whisperAudioContainer;

	[SerializeField]
	public FloatingPointAudioContainer[] sandAudioContainer;

	[SerializeField]
	public ParticleSystem sandParticles;

	public void Start()
	{
		sandParticles.gameObject.SetActive(value: false);
	}

	public bool PlayIfTriggered(GameObject obj, bool disableTrigger, FloatingPointAudioPlayType playType, int clipPosition = 0, float volume = 0.8f, float delay = 0f)
	{
		FloatingPointAudioContainer[] array = whisperAudioContainer;
		for (int i = 0; i < array.Length; i++)
		{
			FloatingPointAudioContainer audio = array[i];
			if ((bool)audio.trigger && audio.trigger == obj)
			{
				audio.trigger.SetActive(!disableTrigger);
				Play(audio, playType, clipPosition, volume, delay);
				if (audio.hasSubTrack)
				{
					HUD.Instance.PlaySubtitles(audio.floatingPointAudioClips[0].audioClip.name, hasPriority: true);
				}
				return true;
			}
		}
		array = sandAudioContainer;
		for (int i = 0; i < array.Length; i++)
		{
			FloatingPointAudioContainer audio2 = array[i];
			if ((bool)audio2.trigger && audio2.trigger == obj)
			{
				audio2.trigger.SetActive(!disableTrigger);
				Play(audio2, playType, clipPosition, volume, delay);
				return true;
			}
		}
		return false;
	}

	private void Play(FloatingPointAudioContainer audio, FloatingPointAudioPlayType playType, int clipPosition = 0, float volume = 0.8f, float delay = 0f)
	{
		base.Play(audio.audioScript, playType, audio.floatingPointAudioClips, clipPosition, volume, delay);
	}
}
public class Torch : NVRInteractableItem
{
	public static string EXTINGUISH_TAG = "TorchExtinguishTrigger";

	[Space]
	[Header("Torch Specific")]
	[SerializeField]
	private float respawnTime;

	[SerializeField]
	private float flamesRotationSpeed;

	[SerializeField]
	private float sparksRotationSpeed;

	[SerializeField]
	private float speedAdjust;

	[SerializeField]
	private float speedThreshold;

	[SerializeField]
	private TorchTrigger torchTrigger;

	[SerializeField]
	private Renderer rend;

	public Transform startLocation;

	[SerializeField]
	private Light pointLight;

	[SerializeField]
	private GameObject fire;

	[SerializeField]
	private AudioClip douseAudioClip;

	[SerializeField]
	private AudioClip lightAudioClip;

	[SerializeField]
	private AudioClip loopingAudioClip;

	[SerializeField]
	private AudioClip lowLoopingAudioClip;

	[SerializeField]
	private ParticleSystem[] fireParticles;

	private ParticleSystem.MinMaxCurve[] _lifetimeCurves;

	[SerializeField]
	private AudioScript loopingAudioScript;

	[SerializeField]
	private AudioScript lowLoopingAudioScript;

	[SerializeField]
	private AudioScriptPooled oneshotAudioScript;

	[HideInInspector]
	public bool ignited = true;

	[HideInInspector]
	public bool inHand;

	[HideInInspector]
	public bool inHolder = true;

	private bool _useTempRespawnTime;

	private float _tempRespawnTime;

	private const float kBurnGradientAmount = 0.19f;

	private float _respawnTimer;

	private Quaternion _prevRot;

	private Vector3 _prevPos;

	private Quaternion _windRotation;

	[HideInInspector]
	public Vector3 startPos;

	[HideInInspector]
	public Quaternion startRot;

	[HideInInspector]
	public UnityEvent RespawnCallback;

	public float RespawnTime
	{
		get
		{
			return _tempRespawnTime;
		}
		set
		{
			_useTempRespawnTime = true;
			_tempRespawnTime = value;
		}
	}

	public bool UseTempRespawn
	{
		set
		{
			_useTempRespawnTime = value;
		}
	}

	protected override void Start()
	{
		base.Start();
		fire.SetActive(value: true);
		_lifetimeCurves = new ParticleSystem.MinMaxCurve[fireParticles.Length];
		for (int i = 0; i < fireParticles.Length; i++)
		{
			_lifetimeCurves[i] = fireParticles[i].main.startLifetime;
		}
		startPos = base.transform.localPosition;
		startRot = base.transform.localRotation;
	}

	public void AddLayerCullingMask(string layerName)
	{
		pointLight.cullingMask |= 1 << LayerMask.NameToLayer(layerName);
	}

	private IEnumerator PlayTorchAudio(bool on)
	{
		if (on)
		{
			oneshotAudioScript.PlayOneShot(lightAudioClip, 0.4f);
			yield return Yield.WaitSeconds(0.7f);
			loopingAudioScript.PlayLoop(loopingAudioClip, 0.4f);
			lowLoopingAudioScript.PlayLoop(lowLoopingAudioClip, 0f);
		}
		else
		{
			loopingAudioScript.StopLoop();
			lowLoopingAudioScript.StopLoop();
			yield return Yield.WaitSeconds(0.1f);
			oneshotAudioScript.PlayOneShot(douseAudioClip, 0.4f);
		}
	}

	protected override void Update()
	{
		base.Update();
		if (ignited && !inHolder)
		{
			if (Vector3.Distance(fire.transform.position, _prevPos) < speedThreshold)
			{
				fire.transform.rotation = Quaternion.Lerp(fire.transform.rotation, Quaternion.Euler(0f, 0f, 0f), Time.deltaTime * flamesRotationSpeed);
			}
			else
			{
				Quaternion rotation = Quaternion.LookRotation((fire.transform.position - _prevPos).normalized * -1f);
				fire.transform.rotation = rotation;
			}
			_prevPos = fire.transform.position;
			float num = Mathf.Clamp(Mathf.Abs(Rigidbody.velocity.magnitude), 1f, 10f);
			for (int i = 0; i < fireParticles.Length; i++)
			{
				ParticleSystem.MainModule main = fireParticles[i].main;
				main.startLifetime = new ParticleSystem.MinMaxCurve(_lifetimeCurves[i].constantMin * 1f / num, _lifetimeCurves[i].constantMax * 1f / num);
			}
			float volume = Mathf.Clamp(Mathf.Abs(Rigidbody.velocity.magnitude / 10f), 0f, 1f);
			lowLoopingAudioScript.m_AudioSource.volume = volume;
		}
		else
		{
			fire.transform.rotation = Quaternion.Euler(0f, 0f, 0f);
			lowLoopingAudioScript.m_AudioSource.volume = 0f;
		}
		if (!inHolder && !inHand)
		{
			if (_useTempRespawnTime)
			{
				if (_respawnTimer > _tempRespawnTime)
				{
					StartCoroutine(RespawnTorchRoutine());
					_useTempRespawnTime = false;
					UnityEngine.Debug.Log("Respawning Torch");
				}
			}
			else if (_respawnTimer > respawnTime)
			{
				StartCoroutine(RespawnTorchRoutine());
				UnityEngine.Debug.Log("Respawning Torch");
			}
		}
		_respawnTimer = (inHand ? 0f : (_respawnTimer + Time.deltaTime));
	}

	private IEnumerator RespawnTorchRoutine()
	{
		_respawnTimer = 0f;
		CanAttach = false;
		PutBack();
		if (RespawnCallback != null)
		{
			RespawnCallback.Invoke();
		}
		yield return Yield.EndOfFrame;
	}

	public void PutBack()
	{
		for (int i = 0; i < fireParticles.Length; i++)
		{
			ParticleSystem.MainModule main = fireParticles[i].main;
			main.startLifetime = new ParticleSystem.MinMaxCurve(_lifetimeCurves[i].constantMin, _lifetimeCurves[i].constantMax);
		}
		inHolder = true;
		Rigidbody.isKinematic = true;
		base.transform.parent = startLocation;
		base.transform.localPosition = startPos;
		base.transform.localRotation = startRot;
	}

	public void SetMaterial(Material mat)
	{
		rend.materials = new Material[2]
		{
			mat,
			rend.materials[1]
		};
	}

	public void Ignite(bool playAudio)
	{
		ignited = true;
		ParticleSystem[] array = fireParticles;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].Play();
		}
		if (playAudio && base.isActiveAndEnabled)
		{
			StartCoroutine(PlayTorchAudio(on: true));
		}
		pointLight.enabled = true;
		pointLight.gameObject.SetActive(value: true);
	}

	public void Extinguish(bool playAudio)
	{
		ignited = false;
		ParticleSystem[] array = fireParticles;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].Stop();
		}
		if (playAudio && base.isActiveAndEnabled)
		{
			StartCoroutine(PlayTorchAudio(on: false));
		}
		pointLight.enabled = false;
		pointLight.gameObject.SetActive(value: false);
	}

	public override void BeginInteraction(NVRHand hand, bool runBeginInteractionCallback = true)
	{
		inHand = true;
		inHolder = false;
		base.BeginInteraction(hand, runBeginInteractionCallback);
	}

	public override void EndInteraction(NVRHand hand)
	{
		inHand = false;
		base.EndInteraction(hand);
	}
}
public class TorchManager : MonoBehaviour
{
	[SerializeField]
	private Torch[] torches;

	[SerializeField]
	private float distanceCheck;

	[SerializeField]
	private Material standardMat;

	[SerializeField]
	private Material burnMat;

	[HideInInspector]
	public bool canIgniteOnRespawn = true;

	public void Start()
	{
		Torch[] array = torches;
		foreach (Torch obj in array)
		{
			obj.CanAttach = true;
			obj.OnBeginInteraction.AddListener(DisableAllTorches);
			obj.RespawnCallback.AddListener(EnableAllTorches);
			obj.Ignite(playAudio: true);
		}
	}

	private void Update()
	{
		Torch[] array = torches;
		foreach (Torch torch in array)
		{
			if (!torch.ignited || torch.inHand || torch.inHolder)
			{
				continue;
			}
			Torch[] array2 = torches;
			foreach (Torch torch2 in array2)
			{
				if (Vector3.Distance(torch.transform.position, torch2.startLocation.position) < distanceCheck)
				{
					UnityEngine.Debug.Log("Adding torch back to holder.");
					Transform startLocation = torch.startLocation;
					Vector3 startPos = torch.startPos;
					Quaternion startRot = torch.startRot;
					torch.startLocation = torch2.startLocation;
					torch.startPos = torch2.startPos;
					torch.startRot = torch2.startRot;
					torch2.startLocation = startLocation;
					torch2.startPos = startPos;
					torch2.startRot = startRot;
					torch.PutBack();
					torch2.PutBack();
					EnableAllTorches();
					break;
				}
			}
		}
	}

	public void SetGhostLayerEnabled()
	{
		Torch[] array = torches;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].AddLayerCullingMask("Ghost");
		}
	}

	public void SetTempRespawnDuration(float duration)
	{
		Torch[] array = torches;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].RespawnTime = duration;
		}
	}

	public void RemoveTempRespawnDuration()
	{
		Torch[] array = torches;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].UseTempRespawn = false;
		}
	}

	public void ExtinguishTorches(bool playAudio)
	{
		Torch[] array = torches;
		foreach (Torch obj in array)
		{
			obj.Extinguish(playAudio);
			obj.SetMaterial(standardMat);
		}
	}

	public void IgniteTorches(bool playAudio)
	{
		Torch[] array = torches;
		foreach (Torch obj in array)
		{
			obj.Ignite(playAudio);
			obj.SetMaterial(burnMat);
		}
	}

	private void EnableAllTorches()
	{
		Torch[] array = torches;
		foreach (Torch torch in array)
		{
			torch.gameObject.SetActive(value: true);
			if (canIgniteOnRespawn)
			{
				torch.Ignite(playAudio: true);
				torch.SetMaterial(burnMat);
			}
			else
			{
				torch.Extinguish(playAudio: false);
				torch.SetMaterial(standardMat);
			}
			torch.CanAttach = true;
		}
	}

	private void DisableAllTorches()
	{
		Torch[] array = torches;
		foreach (Torch torch in array)
		{
			if (torch.AttachedHand == null)
			{
				torch.CanAttach = false;
				torch.Extinguish(playAudio: false);
				torch.SetMaterial(standardMat);
				torch.gameObject.SetActive(value: false);
			}
		}
	}
}
public class TorchTrigger : MonoBehaviour
{
	private void OnTriggerEnter(Collider other)
	{
		if (other.tag == CandleSet.CANDLE_TAG)
		{
			other.GetComponent<CandleSet>().SetEnabled(enabled: true);
		}
		else if (other.tag == Campfire.FIRE_TAG)
		{
			other.GetComponent<Campfire>().SetEnabled(enabled: true);
		}
		else if (other.tag == Torch.EXTINGUISH_TAG)
		{
			Respawn(GetComponentInParent<Torch>(), playAudio: false);
		}
		else if (other.tag == "SplashTrigger")
		{
			base.gameObject.GetComponentInParent<SplashObject>().PlaySound();
			Respawn(GetComponentInParent<Torch>(), playAudio: true);
		}
	}

	private void Respawn(Torch torch, bool playAudio)
	{
		torch.Extinguish(playAudio);
		torch.RespawnTime = 2f;
	}
}
public class TranslationObject : MonoBehaviour
{
	public bool uiImage;

	public bool uiText;

	public bool rawImage;

	public bool material;

	public bool emmsiveMaterial;

	public bool textMesh;

	public bool sprite;

	[Space]
	[Header("Is Persistent Object")]
	public bool persistent;

	public bool phone;

	private RawImage _rawImage;

	private Renderer _renderer;

	private TextMeshProUGUI _textMesh;

	private UnityEngine.UI.Image _image;

	private SpriteRenderer _sprite;

	private Text _uiText;

	private string _englishTextMeshText = string.Empty;

	private TMP_FontAsset _originalTextMeshFont;

	private string _englishUnityUIText = string.Empty;

	private Font _originalUnityUIFont;

	[HideInInspector]
	public bool canTranslate = true;

	private void Start()
	{
		if (!uiImage && !material && !textMesh && !sprite && !rawImage && !uiText && !emmsiveMaterial)
		{
			UnityEngine.Debug.LogWarning("TranslationObject defined on " + base.gameObject.name + " but no usages defined. Are you sure this is correct?!");
		}
		else
		{
			Init();
		}
	}

	public void Init()
	{
		GameController.instance.translator.AddTranslationObject(this);
		SetTranslation();
	}

	public void SetTranslation()
	{
		if (uiImage)
		{
			if (!_image)
			{
				_image = GetComponent<UnityEngine.UI.Image>();
			}
			if ((bool)_image)
			{
				GameController.instance.translator.SetSprite(_image);
			}
			else
			{
				UnityEngine.Debug.LogError("No Image found on the object '" + base.gameObject.name + "' for translation!");
			}
		}
		if (rawImage)
		{
			if (!_rawImage)
			{
				_rawImage = GetComponent<RawImage>();
			}
			if ((bool)_rawImage)
			{
				GameController.instance.translator.SetTexture(_rawImage);
			}
			else
			{
				UnityEngine.Debug.LogError("No material found on the object '" + base.gameObject.name + "' for translation!");
			}
		}
		if (material)
		{
			if (!_renderer)
			{
				_renderer = GetComponent<Renderer>();
			}
			if ((bool)_renderer)
			{
				GameController.instance.translator.SetTexture(_renderer);
			}
			else
			{
				UnityEngine.Debug.LogError("No material found on the object '" + base.gameObject.name + "' for translation!");
			}
		}
		if (emmsiveMaterial)
		{
			if (!_renderer)
			{
				_renderer = GetComponent<Renderer>();
			}
			if ((bool)_renderer)
			{
				GameController.instance.translator.SetEmmisiveTexture(_renderer);
			}
			else
			{
				UnityEngine.Debug.LogError("No EMMISIVE texture found on the object '" + base.gameObject.name + "' for translation!");
			}
		}
		if (sprite)
		{
			if (!_sprite)
			{
				_sprite = GetComponent<SpriteRenderer>();
			}
			if ((bool)_sprite)
			{
				GameController.instance.translator.SetSprite(_sprite);
			}
			else
			{
				UnityEngine.Debug.LogError("No Sprite Renderer found on the object '" + base.gameObject.name + "' for translation!");
			}
		}
		if (textMesh)
		{
			if (!_textMesh)
			{
				_textMesh = GetComponent<TextMeshProUGUI>();
				if (_textMesh == null)
				{
					UnityEngine.Debug.Log(base.gameObject.name);
				}
				_englishTextMeshText = _textMesh.text;
				_originalTextMeshFont = _textMesh.font;
			}
			if ((bool)_textMesh)
			{
				GameController.instance.translator.SetTextMesh(_textMesh, _englishTextMeshText, _originalTextMeshFont, phone);
			}
			else
			{
				UnityEngine.Debug.LogError("No Text Mesh found on the object '" + base.gameObject.name + "' for translation!");
			}
			if (GameController.instance.translator.Language == GameLanguage.SC && phone)
			{
				_textMesh.fontSize = 6f;
			}
			if (GameController.instance.translator.Language != GameLanguage.SC && phone)
			{
				_textMesh.fontSize = 4.2f;
			}
		}
		if (uiText)
		{
			if (!_uiText)
			{
				_uiText = GetComponent<Text>();
				_englishUnityUIText = _uiText.text;
				_originalUnityUIFont = _uiText.font;
			}
			if ((bool)_uiText)
			{
				GameController.instance.translator.SetUIText(_uiText, _englishUnityUIText, _originalUnityUIFont, phone);
			}
			else
			{
				UnityEngine.Debug.LogError("No Unity UI Text found on the object '" + base.gameObject.name + "' for translation!");
			}
		}
	}
}
public class TriggerOverrideParent : NVRTrigger
{
	[SerializeField]
	private Transform parent;

	public override void TriggerEnter(NVRInteractableItem item)
	{
		if (!item.GetComponent<ExorcismItem>())
		{
			item.OriginalParent = parent;
		}
	}

	public override void TriggerEnd(NVRInteractableItem item)
	{
	}

	public override void TriggerStay(NVRInteractableItem item)
	{
	}
}
public class TriggerParent : NVRTrigger
{
	public override void TriggerEnter(NVRInteractableItem item)
	{
		if (!item.GetComponent<ExorcismItem>())
		{
			item.transform.parent = base.transform;
		}
	}

	public override void TriggerEnd(NVRInteractableItem item)
	{
		if (!item.GetComponent<ExorcismItem>())
		{
			item.transform.parent = item.OriginalParent;
		}
	}

	public override void TriggerStay(NVRInteractableItem item)
	{
	}
}
public class TV_TextureVideo : MonoBehaviour
{
	[SerializeField]
	private int uvAnimationTileX = 4;

	[SerializeField]
	private int uvAnimationTileY = 4;

	[SerializeField]
	private Renderer materialRender;

	[SerializeField]
	private Texture2D screenContentAtlas;

	[SerializeField]
	private AudioScript audioScript;

	[SerializeField]
	private AudioClip audioClip;

	[SerializeField]
	private AudioScript voiceInYourHeadScript;

	[SerializeField]
	private AudioClip voiceInYourHead;

	[SerializeField]
	private UnityEngine.Color altColor = new UnityEngine.Color(0.5f, 0.25f, 0.5f, 1f);

	[SerializeField]
	private CCTVScanlines cctvScanlines;

	private Vector2 offset = Vector2.zero;

	private int currentFrame;

	private bool runningRefresh;

	public bool isPlaying;

	private void Start()
	{
		SwitchOff();
	}

	public void Play()
	{
		StartCoroutine(PlayVideo());
	}

	private IEnumerator PlayVideo()
	{
		isPlaying = true;
		SwitchOn();
		audioScript.PlayOne(audioClip);
		HUD.Instance.PlaySubtitles(audioClip.name, hasPriority: true);
		yield return Yield.WaitSeconds(5f);
		StartCoroutine(Refresh(2f));
		SetImage(1);
		yield return Yield.WaitSeconds(6f);
		SetImage(2);
		yield return Yield.WaitSeconds(4f);
		SetImage(1, addFlicker: true);
		yield return Yield.WaitSeconds(6f);
		SetImage(4);
		yield return Yield.WaitSeconds(2f);
		SetImage(5, addFlicker: true);
		yield return Yield.WaitSeconds(6f);
		SetImage(1);
		yield return Yield.WaitSeconds(11f);
		SetImage(7);
		yield return Yield.WaitSeconds(10f);
		SetImage(8, addFlicker: true);
		yield return Yield.WaitSeconds(5f);
		SetImage(6, addFlicker: true);
		yield return Yield.WaitSeconds(4f);
		SetImage(8);
		yield return Yield.WaitSeconds(6f);
		SetImage(7, addFlicker: true);
		yield return Yield.WaitSeconds(4f);
		SetImage(6);
		yield return Yield.WaitSeconds(4f);
		runningRefresh = false;
		SetImage(0, addFlicker: true);
		yield return Yield.WaitSeconds(4.5f);
		StartCoroutine(Refresh(2f));
		SetImage(1);
		yield return Yield.WaitSeconds(9f);
		SetImage(1);
		yield return Yield.WaitSeconds(5f);
		SetImage(1);
		yield return Yield.WaitSeconds(2f);
		SetImage(1);
		yield return Yield.WaitSeconds(2f);
		SetImage(9, addFlicker: true);
		yield return Yield.WaitSeconds(7f);
		SetImage(9);
		yield return Yield.WaitSeconds(6f);
		SetImage(9);
		yield return Yield.WaitSeconds(6f);
		SetImage(10, addFlicker: true);
		yield return Yield.WaitSeconds(6f);
		SetImage(11);
		yield return Yield.WaitSeconds(4f);
		SetImage(12, addFlicker: true);
		yield return Yield.WaitSeconds(12f);
		SetImage(13, addFlicker: true);
		yield return Yield.WaitSeconds(8f);
		SetImage(14);
		yield return Yield.WaitSeconds(3f);
		SetImage(15);
		runningRefresh = false;
		Transform transform = GameController.instance.player.Head.transform;
		voiceInYourHeadScript.transform.parent = transform;
		voiceInYourHeadScript.transform.position = new Vector3(0f, 0f, transform.position.z - 0.5f);
		HUD.Instance.PlaySubtitles(voiceInYourHead.name, hasPriority: true);
		voiceInYourHeadScript.Play(voiceInYourHead);
		StartCoroutine(DetachPlayerSpartialRoutine());
		yield return Yield.WaitSeconds(7f);
		SwitchOff();
	}

	private IEnumerator DetachPlayerSpartialRoutine()
	{
		yield return Yield.WaitSeconds(voiceInYourHead.length);
		voiceInYourHeadScript.transform.parent = null;
	}

	private IEnumerator Refresh(float rate = 1f)
	{
		runningRefresh = true;
		while (runningRefresh)
		{
			materialRender.sharedMaterial.SetColor("_EmissionColor", altColor);
			yield return Yield.WaitSeconds(0.05f);
			materialRender.sharedMaterial.SetColor("_EmissionColor", UnityEngine.Color.white);
			yield return Yield.WaitSeconds(0.95f);
		}
	}

	private void SwitchOn(int frameIndex = 0)
	{
		SetImage(frameIndex);
		materialRender.sharedMaterial.SetColor("_Color", UnityEngine.Color.white);
		materialRender.sharedMaterial.SetColor("_EmissionColor", UnityEngine.Color.white);
		if (cctvScanlines != null)
		{
			cctvScanlines.SetScanlines(enable: true);
		}
	}

	private void SwitchOff()
	{
		isPlaying = false;
		materialRender.sharedMaterial.SetColor("_Color", UnityEngine.Color.black);
		materialRender.sharedMaterial.SetColor("_EmissionColor", UnityEngine.Color.black);
		if (cctvScanlines != null)
		{
			cctvScanlines.SetScanlines(enable: false);
		}
	}

	private void SetImage(int frameNumber, bool addFlicker = false)
	{
		currentFrame = frameNumber;
		frameNumber %= uvAnimationTileX * uvAnimationTileY;
		Vector2 value = new Vector2(1f / (float)uvAnimationTileX, 1f / (float)uvAnimationTileY);
		materialRender.sharedMaterial.SetTextureScale("_MainTex", value);
		float num = frameNumber % uvAnimationTileX;
		float num2 = frameNumber / uvAnimationTileX;
		offset = new Vector2(num * value.x, 1f - value.y - num2 * value.y);
		if (addFlicker)
		{
			float num3 = UnityEngine.Random.Range(-0.03f, 0.01f);
			StartCoroutine(AnimateFlicker(offset.y));
			offset = new Vector2(offset.x, offset.y + num3);
		}
		else
		{
			materialRender.sharedMaterial.SetTextureOffset("_MainTex", offset);
		}
	}

	private IEnumerator AnimateFlicker(float targetOffset)
	{
		for (float i = 0f; i < 3f; i += Time.deltaTime)
		{
			offset = new Vector2(offset.x, offset.y + 0.005f * Time.deltaTime);
			materialRender.sharedMaterial.SetTextureOffset("_MainTex", offset);
			yield return Yield.EndOfFrame;
		}
	}

	private void OnDisable()
	{
		materialRender.sharedMaterial.SetColor("_Color", UnityEngine.Color.black);
		materialRender.sharedMaterial.SetColor("_EmissionColor", UnityEngine.Color.black);
	}
}
public class VHSPlayer : MonoBehaviour
{
	[SerializeField]
	private GameObject vhs;

	[SerializeField]
	private GameObject vhsFlap;

	[SerializeField]
	private Transform vhsSnapPoint;

	[SerializeField]
	private Transform vhsEndPoint;

	[SerializeField]
	public TV_TextureVideo tvset;

	[SerializeField]
	private AudioScriptPooled audioScript;

	[SerializeField]
	private AudioClip loadTapeClip;

	private bool interacting;

	private bool vhsInserted;

	private void Start()
	{
	}

	public void OnTriggerEnter(Collider other)
	{
		if (other.gameObject == vhs)
		{
			vhs.GetComponent<NVRInteractableItem>().CanAttach = false;
			vhs.GetComponent<Rigidbody>().isKinematic = true;
			StartCoroutine(MoveVHS());
		}
	}

	public void ReplayVideo()
	{
		if (!tvset.isPlaying && vhsInserted)
		{
			tvset.Play();
		}
	}

	private IEnumerator MoveVHS()
	{
		LeanTween.rotateLocal(vhsFlap, new Vector3(0f, 0f, 90f), 0.5f);
		yield return Yield.WaitSeconds(0.3f);
		LeanTween.move(vhs, vhsSnapPoint.position, 0.5f);
		LeanTween.rotate(vhs, vhsSnapPoint.eulerAngles, 0.5f);
		yield return Yield.WaitSeconds(0.5f);
		audioScript.Play(loadTapeClip);
		LeanTween.move(vhs, vhsEndPoint, 1.5f);
		yield return Yield.WaitSeconds(1.5f);
		LeanTween.rotateLocal(vhsFlap, new Vector3(0f, 0f, 0f), 0.5f);
		yield return Yield.WaitSeconds(0.5f);
		vhsInserted = true;
		tvset.Play();
	}

	private void Update()
	{
	}
}
public class WaterDripParticle : MonoBehaviour
{
	[SerializeField]
	private AudioSource dripPlayer;

	private void Start()
	{
	}

	private void OnParticleCollision(GameObject other)
	{
		dripPlayer.Play();
	}
}
public class WheelChair : SoundObject
{
	[SerializeField]
	private AudioClip movementClip;

	private AudioScriptPooled wheelAudio;

	private bool playing;

	protected Rigidbody rb;

	protected override void Start()
	{
		base.Start();
		rb = GetComponent<Rigidbody>();
		wheelAudio = base.gameObject.AddComponent<AudioScriptPooled>();
	}

	private void Update()
	{
		if (!(movementClip != null))
		{
			return;
		}
		float num = rb.velocity.magnitude;
		if (num < 0f)
		{
			num *= -1f;
		}
		if (num > 0.1f)
		{
			if (!playing)
			{
				wheelAudio.PlayLoop(movementClip, num);
				playing = true;
			}
			wheelAudio.SetVolume(Mathf.Clamp(num, 0.1f, 1f));
		}
		else
		{
			wheelAudio.StopLoop();
			playing = false;
		}
	}
}
public class WindyDoor : MonoBehaviour
{
	[SerializeField]
	private bool active;

	[SerializeField]
	private float rotateTime = 0.3f;

	[SerializeField]
	private Vector3 rotateTo;

	[SerializeField]
	private GameObject doorToMove;

	[Space]
	private AudioScript audioScript;

	[SerializeField]
	private AudioClip bangClip;

	private Vector3 origionalRotation;

	private bool isMoving;

	private void Start()
	{
		origionalRotation = doorToMove.transform.eulerAngles;
		if ((bool)base.gameObject.GetComponent<AudioScript>())
		{
			audioScript = base.gameObject.GetComponent<AudioScript>();
		}
		else
		{
			audioScript = base.gameObject.AddComponent<AudioScript>();
		}
	}

	private void Update()
	{
		if (active && !isMoving)
		{
			StartCoroutine(Movement());
		}
	}

	private IEnumerator Movement()
	{
		isMoving = true;
		float rotateTimeRandom = rotateTime * UnityEngine.Random.Range(1f, 1.25f);
		LeanTween.rotate(doorToMove, rotateTo, rotateTimeRandom * 2f).setEaseOutQuart();
		yield return Yield.WaitSeconds(0.5f + UnityEngine.Random.Range(0.25f, 3f));
		LeanTween.rotate(doorToMove, origionalRotation, rotateTimeRandom).setEaseInQuart();
		yield return Yield.WaitSeconds(rotateTime);
		if ((bool)audioScript && (bool)bangClip)
		{
			audioScript.Play(bangClip, UnityEngine.Random.Range(0.2f, 0.5f));
		}
		isMoving = false;
	}

	public void StopMovement(float time)
	{
		StopAllCoroutines();
		LeanTween.cancel(doorToMove);
		active = false;
	}

	public void StartMovement()
	{
		active = true;
	}
}
public class RotateAround : MonoBehaviour
{
	public Transform rot_center;

	private void Start()
	{
	}

	private void Update()
	{
		base.transform.RotateAround(rot_center.position, Vector3.up, 0.25f);
	}
}
public class BezierCurve : MonoBehaviour
{
	[SerializeField]
	private UnityEngine.Color curveColor = UnityEngine.Color.green;

	[SerializeField]
	private UnityEngine.Color startPointColor = UnityEngine.Color.red;

	[SerializeField]
	private UnityEngine.Color endPointColor = UnityEngine.Color.blue;

	[SerializeField]
	private int sampling = 25;

	[SerializeField]
	[HideInInspector]
	private List<BezierPoint> keyPoints = new List<BezierPoint>();

	[SerializeField]
	[Range(0f, 1f)]
	private float normalizedTime = 0.5f;

	public int Sampling
	{
		get
		{
			return sampling;
		}
		set
		{
			sampling = value;
		}
	}

	public List<BezierPoint> KeyPoints => keyPoints;

	public int KeyPointsCount => KeyPoints.Count;

	public BezierPoint AddKeyPoint()
	{
		return AddKeyPointAt(KeyPointsCount);
	}

	public BezierPoint AddKeyPointAt(int index)
	{
		BezierPoint component = new GameObject("Point " + KeyPoints.Count, typeof(BezierPoint)).GetComponent<BezierPoint>();
		component.Curve = this;
		component.transform.parent = base.transform;
		component.transform.localRotation = Quaternion.identity;
		if (KeyPointsCount == 0 || KeyPointsCount == 1)
		{
			component.LocalPosition = Vector3.zero;
		}
		else if (index == 0)
		{
			component.Position = (KeyPoints[0].Position - KeyPoints[1].Position).normalized + KeyPoints[0].Position;
		}
		else if (index == KeyPointsCount)
		{
			component.Position = (KeyPoints[index - 1].Position - KeyPoints[index - 2].Position).normalized + KeyPoints[index - 1].Position;
		}
		else
		{
			component.Position = GetPointOnCubicCurve(0.5f, KeyPoints[index - 1], KeyPoints[index]);
		}
		KeyPoints.Insert(index, component);
		return component;
	}

	public bool RemoveKeyPointAt(int index)
	{
		if (KeyPointsCount < 2)
		{
			return false;
		}
		BezierPoint bezierPoint = KeyPoints[index];
		KeyPoints.RemoveAt(index);
		UnityEngine.Object.Destroy(bezierPoint.gameObject);
		return true;
	}

	public Vector3 GetPoint(float time)
	{
		GetCubicSegment(time, out var startPoint, out var endPoint, out var timeRelativeToSegment);
		return GetPointOnCubicCurve(timeRelativeToSegment, startPoint, endPoint);
	}

	public Quaternion GetRotation(float time, Vector3 up)
	{
		GetCubicSegment(time, out var startPoint, out var endPoint, out var timeRelativeToSegment);
		return GetRotationOnCubicCurve(timeRelativeToSegment, up, startPoint, endPoint);
	}

	public Vector3 GetTangent(float time)
	{
		GetCubicSegment(time, out var startPoint, out var endPoint, out var timeRelativeToSegment);
		return GetTangentOnCubicCurve(timeRelativeToSegment, startPoint, endPoint);
	}

	public Vector3 GetBinormal(float time, Vector3 up)
	{
		GetCubicSegment(time, out var startPoint, out var endPoint, out var timeRelativeToSegment);
		return GetBinormalOnCubicCurve(timeRelativeToSegment, up, startPoint, endPoint);
	}

	public Vector3 GetNormal(float time, Vector3 up)
	{
		GetCubicSegment(time, out var startPoint, out var endPoint, out var timeRelativeToSegment);
		return GetNormalOnCubicCurve(timeRelativeToSegment, up, startPoint, endPoint);
	}

	public float GetApproximateLength()
	{
		float num = 0f;
		int num2 = Sampling / (KeyPointsCount - 1) + 1;
		for (int i = 0; i < KeyPointsCount - 1; i++)
		{
			num += GetApproximateLengthOfCubicCurve(KeyPoints[i], KeyPoints[i + 1], num2);
		}
		return num;
	}

	public void GetCubicSegment(float time, out BezierPoint startPoint, out BezierPoint endPoint, out float timeRelativeToSegment)
	{
		startPoint = null;
		endPoint = null;
		timeRelativeToSegment = 0f;
		float num = 0f;
		float num2 = 0f;
		float approximateLength = GetApproximateLength();
		int num3 = Sampling / (KeyPointsCount - 1) + 1;
		for (int i = 0; i < KeyPointsCount - 1; i++)
		{
			num = GetApproximateLengthOfCubicCurve(KeyPoints[i], KeyPoints[i + 1], num3) / approximateLength;
			if (num + num2 > time)
			{
				startPoint = KeyPoints[i];
				endPoint = KeyPoints[i + 1];
				break;
			}
			num2 += num;
		}
		if (endPoint == null)
		{
			startPoint = KeyPoints[KeyPointsCount - 2];
			endPoint = KeyPoints[KeyPointsCount - 1];
			num2 -= num;
		}
		timeRelativeToSegment = (time - num2) / num;
	}

	public static Vector3 GetPointOnCubicCurve(float time, BezierPoint startPoint, BezierPoint endPoint)
	{
		return GetPointOnCubicCurve(time, startPoint.Position, endPoint.Position, startPoint.RightHandlePosition, endPoint.LeftHandlePosition);
	}

	public static Vector3 GetPointOnCubicCurve(float time, Vector3 startPosition, Vector3 endPosition, Vector3 startTangent, Vector3 endTangent)
	{
		float num = 1f - time;
		float num2 = time * time;
		float num3 = num * num;
		float num4 = num3 * num;
		float num5 = num2 * time;
		return num4 * startPosition + 3f * num3 * time * startTangent + 3f * num * num2 * endTangent + num5 * endPosition;
	}

	public static Quaternion GetRotationOnCubicCurve(float time, Vector3 up, BezierPoint startPoint, BezierPoint endPoint)
	{
		return GetRotationOnCubicCurve(time, up, startPoint.Position, endPoint.Position, startPoint.RightHandlePosition, endPoint.LeftHandlePosition);
	}

	public static Quaternion GetRotationOnCubicCurve(float time, Vector3 up, Vector3 startPosition, Vector3 endPosition, Vector3 startTangent, Vector3 endTangent)
	{
		Vector3 tangentOnCubicCurve = GetTangentOnCubicCurve(time, startPosition, endPosition, startTangent, endTangent);
		Vector3 normalOnCubicCurve = GetNormalOnCubicCurve(time, up, startPosition, endPosition, startTangent, endTangent);
		return Quaternion.LookRotation(tangentOnCubicCurve, normalOnCubicCurve);
	}

	public static Vector3 GetTangentOnCubicCurve(float time, BezierPoint startPoint, BezierPoint endPoint)
	{
		return GetTangentOnCubicCurve(time, startPoint.Position, endPoint.Position, startPoint.RightHandlePosition, endPoint.LeftHandlePosition);
	}

	public static Vector3 GetTangentOnCubicCurve(float time, Vector3 startPosition, Vector3 endPosition, Vector3 startTangent, Vector3 endTangent)
	{
		float num = 1f - time;
		float num2 = num * num;
		float num3 = time * time;
		return ((0f - num2) * startPosition + num * (num - 2f * time) * startTangent - time * (time - 2f * num) * endTangent + num3 * endPosition).normalized;
	}

	public static Vector3 GetBinormalOnCubicCurve(float time, Vector3 up, BezierPoint startPoint, BezierPoint endPoint)
	{
		return GetBinormalOnCubicCurve(time, up, startPoint.Position, endPoint.Position, startPoint.RightHandlePosition, endPoint.LeftHandlePosition);
	}

	public static Vector3 GetBinormalOnCubicCurve(float time, Vector3 up, Vector3 startPosition, Vector3 endPosition, Vector3 startTangent, Vector3 endTangent)
	{
		Vector3 tangentOnCubicCurve = GetTangentOnCubicCurve(time, startPosition, endPosition, startTangent, endTangent);
		return Vector3.Cross(up, tangentOnCubicCurve).normalized;
	}

	public static Vector3 GetNormalOnCubicCurve(float time, Vector3 up, BezierPoint startPoint, BezierPoint endPoint)
	{
		return GetNormalOnCubicCurve(time, up, startPoint.Position, endPoint.Position, startPoint.RightHandlePosition, endPoint.LeftHandlePosition);
	}

	public static Vector3 GetNormalOnCubicCurve(float time, Vector3 up, Vector3 startPosition, Vector3 endPosition, Vector3 startTangent, Vector3 endTangent)
	{
		Vector3 tangentOnCubicCurve = GetTangentOnCubicCurve(time, startPosition, endPosition, startTangent, endTangent);
		Vector3 binormalOnCubicCurve = GetBinormalOnCubicCurve(time, up, startPosition, endPosition, startTangent, endTangent);
		return Vector3.Cross(tangentOnCubicCurve, binormalOnCubicCurve).normalized;
	}

	public static float GetApproximateLengthOfCubicCurve(BezierPoint startPoint, BezierPoint endPoint, int sampling)
	{
		return GetApproximateLengthOfCubicCurve(startPoint.Position, endPoint.Position, startPoint.RightHandlePosition, endPoint.LeftHandlePosition, sampling);
	}

	public static float GetApproximateLengthOfCubicCurve(Vector3 startPosition, Vector3 endPosition, Vector3 startTangent, Vector3 endTangent, int sampling)
	{
		float num = 0f;
		Vector3 a = GetPointOnCubicCurve(0f, startPosition, endPosition, startTangent, endTangent);
		for (int i = 0; i < sampling; i++)
		{
			Vector3 pointOnCubicCurve = GetPointOnCubicCurve((float)(i + 1) / (float)sampling, startPosition, endPosition, startTangent, endTangent);
			num += Vector3.Distance(a, pointOnCubicCurve);
			a = pointOnCubicCurve;
		}
		return num;
	}

	public LTBezierPath GetLeanTweenPath()
	{
		List<Vector3> list = new List<Vector3>();
		for (int i = 0; i < keyPoints.Count; i++)
		{
			if (i + 1 < keyPoints.Count)
			{
				BezierPoint bezierPoint = keyPoints[i];
				BezierPoint bezierPoint2 = keyPoints[i + 1];
				list.Add(bezierPoint.LocalPosition);
				list.Add(bezierPoint.RightHandleLocalPosition);
				list.Add(bezierPoint2.LocalPosition);
				list.Add(bezierPoint2.LeftHandleLocalPosition);
			}
		}
		return new LTBezierPath(list.ToArray());
	}

	protected virtual void OnDrawGizmos()
	{
		if (KeyPointsCount > 1)
		{
			Vector3 from = GetPoint(0f);
			for (int i = 0; i < Sampling; i++)
			{
				float time = (float)(i + 1) / (float)Sampling;
				Vector3 point = GetPoint(time);
				Gizmos.color = curveColor;
				Gizmos.DrawLine(from, point);
				from = point;
			}
			Gizmos.color = startPointColor;
			Gizmos.DrawSphere(KeyPoints[0].Position, 0.05f);
			Gizmos.color = endPointColor;
			Gizmos.DrawSphere(KeyPoints[KeyPointsCount - 1].Position, 0.05f);
			Vector3 point2 = GetPoint(normalizedTime);
			Gizmos.color = UnityEngine.Color.yellow;
			Gizmos.DrawSphere(point2, 0.025f);
			Vector3 tangent = GetTangent(normalizedTime);
			Gizmos.color = UnityEngine.Color.blue;
			Gizmos.DrawLine(point2, point2 + tangent / 2f);
			Vector3 binormal = GetBinormal(normalizedTime, Vector3.up);
			Gizmos.color = UnityEngine.Color.red;
			Gizmos.DrawLine(point2, point2 + binormal / 2f);
			Vector3 normal = GetNormal(normalizedTime, Vector3.up);
			Gizmos.color = UnityEngine.Color.green;
			Gizmos.DrawLine(point2, point2 + normal / 2f);
		}
	}
}
public class BezierPoint : MonoBehaviour
{
	public enum HandleType
	{
		Connected,
		Broken
	}

	[SerializeField]
	private BezierCurve curve;

	[SerializeField]
	private HandleType handleType;

	[SerializeField]
	private Vector3 leftHandleLocalPosition = new Vector3(-0.5f, 0f, 0f);

	[SerializeField]
	private Vector3 rightHandleLocalPosition = new Vector3(0.5f, 0f, 0f);

	public BezierCurve Curve
	{
		get
		{
			return curve;
		}
		set
		{
			curve = value;
		}
	}

	public HandleType HandleStyle
	{
		get
		{
			return handleType;
		}
		set
		{
			handleType = value;
		}
	}

	public Vector3 Position
	{
		get
		{
			return base.transform.position;
		}
		set
		{
			base.transform.position = value;
		}
	}

	public Vector3 LocalPosition
	{
		get
		{
			return base.transform.localPosition;
		}
		set
		{
			base.transform.localPosition = value;
		}
	}

	public Vector3 LeftHandleLocalPosition
	{
		get
		{
			return leftHandleLocalPosition;
		}
		set
		{
			leftHandleLocalPosition = value;
			if (handleType == HandleType.Connected)
			{
				rightHandleLocalPosition = -value;
			}
		}
	}

	public Vector3 RightHandleLocalPosition
	{
		get
		{
			return rightHandleLocalPosition;
		}
		set
		{
			rightHandleLocalPosition = value;
			if (handleType == HandleType.Connected)
			{
				leftHandleLocalPosition = -value;
			}
		}
	}

	public Vector3 LeftHandlePosition
	{
		get
		{
			return base.transform.TransformPoint(LeftHandleLocalPosition);
		}
		set
		{
			LeftHandleLocalPosition = base.transform.InverseTransformPoint(value);
		}
	}

	public Vector3 RightHandlePosition
	{
		get
		{
			return base.transform.TransformPoint(RightHandleLocalPosition);
		}
		set
		{
			RightHandleLocalPosition = base.transform.InverseTransformPoint(value);
		}
	}
}
public class UnluckDistanceDisabler : MonoBehaviour
{
	public int _distanceDisable = 1000;

	public Transform _distanceFrom;

	public bool _distanceFromMainCam;

	public float _disableCheckInterval = 10f;

	public float _enableCheckInterval = 1f;

	public bool _disableOnStart;

	public void Start()
	{
		if (_distanceFromMainCam)
		{
			_distanceFrom = Camera.main.transform;
		}
		InvokeRepeating("CheckDisable", _disableCheckInterval + UnityEngine.Random.value * _disableCheckInterval, _disableCheckInterval);
		InvokeRepeating("CheckEnable", _enableCheckInterval + UnityEngine.Random.value * _enableCheckInterval, _enableCheckInterval);
		Invoke("DisableOnStart", 0.01f);
	}

	public void DisableOnStart()
	{
		if (_disableOnStart)
		{
			base.gameObject.SetActive(value: false);
		}
	}

	public void CheckDisable()
	{
		if (base.gameObject.activeInHierarchy && (base.transform.position - _distanceFrom.position).sqrMagnitude > (float)(_distanceDisable * _distanceDisable))
		{
			base.gameObject.SetActive(value: false);
		}
	}

	public void CheckEnable()
	{
		if (!base.gameObject.activeInHierarchy && (base.transform.position - _distanceFrom.position).sqrMagnitude < (float)(_distanceDisable * _distanceDisable))
		{
			base.gameObject.SetActive(value: true);
		}
	}
}
[AddComponentMenu("Camera-Control/Smooth Mouse Orbit - Unluck Software")]
public class SmoothCameraOrbit : MonoBehaviour
{
	public Transform target;

	public Vector3 targetOffset;

	public float distance = 5f;

	public float maxDistance = 20f;

	public float minDistance = 0.6f;

	public float xSpeed = 200f;

	public float ySpeed = 200f;

	public int yMinLimit = -80;

	public int yMaxLimit = 80;

	public int zoomRate = 40;

	public float panSpeed = 0.3f;

	public float zoomDampening = 5f;

	public float autoRotate = 1f;

	public float autoRotateSpeed = 0.1f;

	private float xDeg;

	private float yDeg;

	private float currentDistance;

	private float desiredDistance;

	private Quaternion currentRotation;

	private Quaternion desiredRotation;

	private Quaternion rotation;

	private Vector3 position;

	private float idleTimer;

	private float idleSmooth;

	private void Start()
	{
		Init();
	}

	private void OnEnable()
	{
		Init();
	}

	public void Init()
	{
		if (!target)
		{
			GameObject gameObject = new GameObject("Cam Target");
			gameObject.transform.position = base.transform.position + base.transform.forward * distance;
			target = gameObject.transform;
		}
		currentDistance = distance;
		desiredDistance = distance;
		position = base.transform.position;
		rotation = base.transform.rotation;
		currentRotation = base.transform.rotation;
		desiredRotation = base.transform.rotation;
		xDeg = Vector3.Angle(Vector3.right, base.transform.right);
		yDeg = Vector3.Angle(Vector3.up, base.transform.up);
		position = target.position - (rotation * Vector3.forward * currentDistance + targetOffset);
	}

	private void LateUpdate()
	{
		if (Input.GetMouseButton(2) && Input.GetKey(KeyCode.LeftAlt) && Input.GetKey(KeyCode.LeftControl))
		{
			desiredDistance -= Input.GetAxis("Mouse Y") * 0.02f * (float)zoomRate * 0.125f * Mathf.Abs(desiredDistance);
		}
		else if (Input.GetMouseButton(0))
		{
			xDeg += Input.GetAxis("Mouse X") * xSpeed * 0.02f;
			yDeg -= Input.GetAxis("Mouse Y") * ySpeed * 0.02f;
			yDeg = ClampAngle(yDeg, yMinLimit, yMaxLimit);
			desiredRotation = Quaternion.Euler(yDeg, xDeg, 0f);
			currentRotation = base.transform.rotation;
			rotation = Quaternion.Lerp(currentRotation, desiredRotation, 0.02f * zoomDampening);
			base.transform.rotation = rotation;
			idleTimer = 0f;
			idleSmooth = 0f;
		}
		else
		{
			idleTimer += 0.02f;
			if (idleTimer > autoRotate && autoRotate > 0f)
			{
				idleSmooth += (0.02f + idleSmooth) * 0.005f;
				idleSmooth = Mathf.Clamp(idleSmooth, 0f, 1f);
				xDeg += xSpeed * Time.deltaTime * idleSmooth * autoRotateSpeed;
			}
			yDeg = ClampAngle(yDeg, yMinLimit, yMaxLimit);
			desiredRotation = Quaternion.Euler(yDeg, xDeg, 0f);
			currentRotation = base.transform.rotation;
			rotation = Quaternion.Lerp(currentRotation, desiredRotation, 0.02f * zoomDampening * 2f);
			base.transform.rotation = rotation;
		}
		desiredDistance -= Input.GetAxis("Mouse ScrollWheel") * 0.02f * (float)zoomRate * Mathf.Abs(desiredDistance);
		desiredDistance = Mathf.Clamp(desiredDistance, minDistance, maxDistance);
		currentDistance = Mathf.Lerp(currentDistance, desiredDistance, 0.02f * zoomDampening);
		position = target.position - (rotation * Vector3.forward * currentDistance + targetOffset);
		base.transform.position = position;
	}

	private static float ClampAngle(float angle, float min, float max)
	{
		if (angle < -360f)
		{
			angle += 360f;
		}
		if (angle > 360f)
		{
			angle -= 360f;
		}
		return Mathf.Clamp(angle, min, max);
	}
}
public class FlockChild : MonoBehaviour
{
	[HideInInspector]
	public FlockController _spawner;

	[HideInInspector]
	public Vector3 _wayPoint;

	public float _speed;

	[HideInInspector]
	public bool _dived = true;

	[HideInInspector]
	public float _stuckCounter;

	[HideInInspector]
	public float _damping;

	[HideInInspector]
	public bool _soar = true;

	[HideInInspector]
	public bool _landing;

	[HideInInspector]
	public float _targetSpeed;

	[HideInInspector]
	public bool _move = true;

	public GameObject _model;

	public Transform _modelT;

	[HideInInspector]
	public float _avoidValue;

	[HideInInspector]
	public float _avoidDistance;

	private float _soarTimer;

	private bool _instantiated;

	private static int _updateNextSeed;

	private int _updateSeed = -1;

	[HideInInspector]
	public bool _avoid = true;

	public Transform _thisT;

	public Vector3 _landingPosOffset;

	public void Start()
	{
		FindRequiredComponents();
		Wander(0f);
		SetRandomScale();
		_thisT.position = findWaypoint();
		RandomizeStartAnimationFrame();
		InitAvoidanceValues();
		_speed = _spawner._minSpeed;
		_spawner._activeChildren += 1f;
		_instantiated = true;
		if (_spawner._updateDivisor > 1)
		{
			int num = _spawner._updateDivisor - 1;
			_updateNextSeed++;
			_updateSeed = _updateNextSeed;
			_updateNextSeed %= num;
		}
	}

	public void Update()
	{
		if (_spawner._updateDivisor <= 1 || _spawner._updateCounter == _updateSeed)
		{
			SoarTimeLimit();
			CheckForDistanceToWaypoint();
			RotationBasedOnWaypointOrAvoidance();
			LimitRotationOfModel();
		}
	}

	public void OnDisable()
	{
		CancelInvoke();
		_spawner._activeChildren -= 1f;
	}

	public void OnEnable()
	{
		if (_instantiated)
		{
			_spawner._activeChildren += 1f;
			if (_landing)
			{
				_model.GetComponent<Animation>().Play(_spawner._idleAnimation);
			}
			else
			{
				_model.GetComponent<Animation>().Play(_spawner._flapAnimation);
			}
		}
	}

	public void FindRequiredComponents()
	{
		if (_thisT == null)
		{
			_thisT = base.transform;
		}
		if (_model == null)
		{
			_model = _thisT.Find("Model").gameObject;
		}
		if (_modelT == null)
		{
			_modelT = _model.transform;
		}
	}

	public void RandomizeStartAnimationFrame()
	{
		foreach (AnimationState item in _model.GetComponent<Animation>())
		{
			item.time = UnityEngine.Random.value * item.length;
		}
	}

	public void InitAvoidanceValues()
	{
		_avoidValue = UnityEngine.Random.Range(0.3f, 0.1f);
		if (_spawner._birdAvoidDistanceMax != _spawner._birdAvoidDistanceMin)
		{
			_avoidDistance = UnityEngine.Random.Range(_spawner._birdAvoidDistanceMax, _spawner._birdAvoidDistanceMin);
		}
		else
		{
			_avoidDistance = _spawner._birdAvoidDistanceMin;
		}
	}

	public void SetRandomScale()
	{
		float num = UnityEngine.Random.Range(_spawner._minScale, _spawner._maxScale);
		_thisT.localScale = new Vector3(num, num, num);
	}

	public void SoarTimeLimit()
	{
		if (_soar && _spawner._soarMaxTime > 0f)
		{
			if (_soarTimer > _spawner._soarMaxTime)
			{
				Flap();
				_soarTimer = 0f;
			}
			else
			{
				_soarTimer += _spawner._newDelta;
			}
		}
	}

	public void CheckForDistanceToWaypoint()
	{
		if (!_landing && (_thisT.position - _wayPoint).magnitude < _spawner._waypointDistance + _stuckCounter)
		{
			Wander(0f);
			_stuckCounter = 0f;
		}
		else if (!_landing)
		{
			_stuckCounter += _spawner._newDelta;
		}
		else
		{
			_stuckCounter = 0f;
		}
	}

	public void RotationBasedOnWaypointOrAvoidance()
	{
		Vector3 vector = _wayPoint - _thisT.position;
		if (_targetSpeed > -1f && vector != Vector3.zero)
		{
			Quaternion b = Quaternion.LookRotation(vector);
			_thisT.rotation = Quaternion.Slerp(_thisT.rotation, b, _spawner._newDelta * _damping);
		}
		if (_spawner._childTriggerPos && (_thisT.position - _spawner._posBuffer).magnitude < 1f)
		{
			_spawner.SetFlockRandomPosition();
		}
		_speed = Mathf.Lerp(_speed, _targetSpeed, _spawner._newDelta * 2.5f);
		if (_move)
		{
			_thisT.position += _thisT.forward * _speed * _spawner._newDelta;
			if (_avoid && _spawner._birdAvoid)
			{
				Avoidance();
			}
		}
	}

	public bool Avoidance()
	{
		RaycastHit hitInfo = default(RaycastHit);
		Vector3 forward = _modelT.forward;
		bool result = false;
		Quaternion identity = Quaternion.identity;
		Vector3 zero = Vector3.zero;
		Vector3 zero2 = Vector3.zero;
		zero2 = _thisT.position;
		identity = _thisT.rotation;
		zero = _thisT.rotation.eulerAngles;
		if (Physics.Raycast(_thisT.position, forward + _modelT.right * _avoidValue, out hitInfo, _avoidDistance, _spawner._avoidanceMask))
		{
			zero.y -= (float)_spawner._birdAvoidHorizontalForce * _spawner._newDelta * _damping;
			identity.eulerAngles = zero;
			_thisT.rotation = identity;
			result = true;
		}
		else if (Physics.Raycast(_thisT.position, forward + _modelT.right * (0f - _avoidValue), out hitInfo, _avoidDistance, _spawner._avoidanceMask))
		{
			zero.y += (float)_spawner._birdAvoidHorizontalForce * _spawner._newDelta * _damping;
			identity.eulerAngles = zero;
			_thisT.rotation = identity;
			result = true;
		}
		if (_spawner._birdAvoidDown && !_landing && Physics.Raycast(_thisT.position, -Vector3.up, out hitInfo, _avoidDistance, _spawner._avoidanceMask))
		{
			zero.x -= (float)_spawner._birdAvoidVerticalForce * _spawner._newDelta * _damping;
			identity.eulerAngles = zero;
			_thisT.rotation = identity;
			zero2.y += (float)_spawner._birdAvoidVerticalForce * _spawner._newDelta * 0.01f;
			_thisT.position = zero2;
			result = true;
		}
		else if (_spawner._birdAvoidUp && !_landing && Physics.Raycast(_thisT.position, Vector3.up, out hitInfo, _avoidDistance, _spawner._avoidanceMask))
		{
			zero.x += (float)_spawner._birdAvoidVerticalForce * _spawner._newDelta * _damping;
			identity.eulerAngles = zero;
			_thisT.rotation = identity;
			zero2.y -= (float)_spawner._birdAvoidVerticalForce * _spawner._newDelta * 0.01f;
			_thisT.position = zero2;
			result = true;
		}
		return result;
	}

	public void LimitRotationOfModel()
	{
		Quaternion identity = Quaternion.identity;
		Vector3 zero = Vector3.zero;
		identity = _modelT.localRotation;
		zero = identity.eulerAngles;
		if ((((_soar && _spawner._flatSoar) || (_spawner._flatFly && !_soar)) && _wayPoint.y > _thisT.position.y) || _landing)
		{
			zero.x = Mathf.LerpAngle(_modelT.localEulerAngles.x, 0f - _thisT.localEulerAngles.x, _spawner._newDelta * 1.75f);
			identity.eulerAngles = zero;
			_modelT.localRotation = identity;
		}
		else
		{
			zero.x = Mathf.LerpAngle(_modelT.localEulerAngles.x, 0f, _spawner._newDelta * 1.75f);
			identity.eulerAngles = zero;
			_modelT.localRotation = identity;
		}
	}

	public void Wander(float delay)
	{
		if (!_landing)
		{
			_damping = UnityEngine.Random.Range(_spawner._minDamping, _spawner._maxDamping);
			_targetSpeed = UnityEngine.Random.Range(_spawner._minSpeed, _spawner._maxSpeed);
			Invoke("SetRandomMode", delay);
		}
	}

	public void SetRandomMode()
	{
		CancelInvoke("SetRandomMode");
		if (!_dived && UnityEngine.Random.value < _spawner._soarFrequency)
		{
			Soar();
		}
		else if (!_dived && UnityEngine.Random.value < _spawner._diveFrequency)
		{
			Dive();
		}
		else
		{
			Flap();
		}
	}

	public void Flap()
	{
		if (_move)
		{
			if (_model != null)
			{
				_model.GetComponent<Animation>().CrossFade(_spawner._flapAnimation, 0.5f);
			}
			_soar = false;
			animationSpeed();
			_wayPoint = findWaypoint();
			_dived = false;
		}
	}

	public Vector3 findWaypoint()
	{
		Vector3 zero = Vector3.zero;
		zero.x = UnityEngine.Random.Range(0f - _spawner._spawnSphere, _spawner._spawnSphere) + _spawner._posBuffer.x;
		zero.z = UnityEngine.Random.Range(0f - _spawner._spawnSphereDepth, _spawner._spawnSphereDepth) + _spawner._posBuffer.z;
		zero.y = UnityEngine.Random.Range(0f - _spawner._spawnSphereHeight, _spawner._spawnSphereHeight) + _spawner._posBuffer.y;
		return zero;
	}

	public void Soar()
	{
		if (_move)
		{
			_model.GetComponent<Animation>().CrossFade(_spawner._soarAnimation, 1.5f);
			_wayPoint = findWaypoint();
			_soar = true;
		}
	}

	public void Dive()
	{
		if (_spawner._soarAnimation != null)
		{
			_model.GetComponent<Animation>().CrossFade(_spawner._soarAnimation, 1.5f);
		}
		else
		{
			foreach (AnimationState item in _model.GetComponent<Animation>())
			{
				if (_thisT.position.y < _wayPoint.y + 25f)
				{
					item.speed = 0.1f;
				}
			}
		}
		_wayPoint = findWaypoint();
		_wayPoint.y -= _spawner._diveValue;
		_dived = true;
	}

	public void animationSpeed()
	{
		foreach (AnimationState item in _model.GetComponent<Animation>())
		{
			if (!_dived && !_landing)
			{
				item.speed = UnityEngine.Random.Range(_spawner._minAnimationSpeed, _spawner._maxAnimationSpeed);
			}
			else
			{
				item.speed = _spawner._maxAnimationSpeed;
			}
		}
	}
}
[RequireComponent(typeof(AudioSource))]
public class FlockChildSound : MonoBehaviour
{
	public AudioClip[] _idleSounds;

	public float _idleSoundRandomChance = 0.05f;

	public AudioClip[] _flightSounds;

	public float _flightSoundRandomChance = 0.05f;

	public AudioClip[] _scareSounds;

	public float _pitchMin = 0.85f;

	public float _pitchMax = 1f;

	public float _volumeMin = 0.6f;

	public float _volumeMax = 0.8f;

	private FlockChild _flockChild;

	private AudioSource _audio;

	private bool _hasLanded;

	public void Start()
	{
		_flockChild = GetComponent<FlockChild>();
		_audio = GetComponent<AudioSource>();
		InvokeRepeating("PlayRandomSound", UnityEngine.Random.value + 1f, 1f);
		if (_scareSounds.Length != 0)
		{
			InvokeRepeating("ScareSound", 1f, 0.01f);
		}
	}

	public void PlayRandomSound()
	{
		if (base.gameObject.activeInHierarchy)
		{
			if (!_audio.isPlaying && _flightSounds.Length != 0 && _flightSoundRandomChance > UnityEngine.Random.value && !_flockChild._landing)
			{
				_audio.clip = _flightSounds[UnityEngine.Random.Range(0, _flightSounds.Length)];
				_audio.pitch = UnityEngine.Random.Range(_pitchMin, _pitchMax);
				_audio.volume = UnityEngine.Random.Range(_volumeMin, _volumeMax);
				_audio.Play();
			}
			else if (!_audio.isPlaying && _idleSounds.Length != 0 && _idleSoundRandomChance > UnityEngine.Random.value && _flockChild._landing)
			{
				_audio.clip = _idleSounds[UnityEngine.Random.Range(0, _idleSounds.Length)];
				_audio.pitch = UnityEngine.Random.Range(_pitchMin, _pitchMax);
				_audio.volume = UnityEngine.Random.Range(_volumeMin, _volumeMax);
				_audio.Play();
				_hasLanded = true;
			}
		}
	}

	public void ScareSound()
	{
		if (base.gameObject.activeInHierarchy && _hasLanded && !_flockChild._landing && _idleSoundRandomChance * 2f > UnityEngine.Random.value)
		{
			_audio.clip = _scareSounds[UnityEngine.Random.Range(0, _scareSounds.Length)];
			_audio.volume = UnityEngine.Random.Range(_volumeMin, _volumeMax);
			_audio.PlayDelayed(UnityEngine.Random.value * 0.2f);
			_hasLanded = false;
		}
	}
}
public class FlockController : MonoBehaviour
{
	public FlockChild _childPrefab;

	public int _childAmount = 250;

	public bool _slowSpawn;

	public float _spawnSphere = 3f;

	public float _spawnSphereHeight = 3f;

	public float _spawnSphereDepth = -1f;

	public float _minSpeed = 6f;

	public float _maxSpeed = 10f;

	public float _minScale = 0.7f;

	public float _maxScale = 1f;

	public float _soarFrequency;

	public string _soarAnimation = "Soar";

	public string _flapAnimation = "Flap";

	public string _idleAnimation = "Idle";

	public float _diveValue = 7f;

	public float _diveFrequency = 0.5f;

	public float _minDamping = 1f;

	public float _maxDamping = 2f;

	public float _waypointDistance = 1f;

	public float _minAnimationSpeed = 2f;

	public float _maxAnimationSpeed = 4f;

	public float _randomPositionTimer = 10f;

	public float _positionSphere = 25f;

	public float _positionSphereHeight = 25f;

	public float _positionSphereDepth = -1f;

	public bool _childTriggerPos;

	public bool _forceChildWaypoints;

	public float _forcedRandomDelay = 1.5f;

	public bool _flatFly;

	public bool _flatSoar;

	public bool _birdAvoid;

	public int _birdAvoidHorizontalForce = 1000;

	public bool _birdAvoidDown;

	public bool _birdAvoidUp;

	public int _birdAvoidVerticalForce = 300;

	public float _birdAvoidDistanceMax = 4.5f;

	public float _birdAvoidDistanceMin = 5f;

	public float _soarMaxTime;

	public LayerMask _avoidanceMask = -1;

	public List<FlockChild> _roamers;

	public Vector3 _posBuffer;

	public int _updateDivisor = 1;

	public float _newDelta;

	public int _updateCounter;

	public float _activeChildren;

	public bool _groupChildToNewTransform;

	public Transform _groupTransform;

	public string _groupName = "";

	public bool _groupChildToFlock;

	public Vector3 _startPosOffset;

	public Transform _thisT;

	public void Start()
	{
		_thisT = base.transform;
		if (_positionSphereDepth == -1f)
		{
			_positionSphereDepth = _positionSphere;
		}
		if (_spawnSphereDepth == -1f)
		{
			_spawnSphereDepth = _spawnSphere;
		}
		_posBuffer = _thisT.position + _startPosOffset;
		if (!_slowSpawn)
		{
			AddChild(_childAmount);
		}
		if (_randomPositionTimer > 0f)
		{
			InvokeRepeating("SetFlockRandomPosition", _randomPositionTimer, _randomPositionTimer);
		}
	}

	public void AddChild(int amount)
	{
		if (_groupChildToNewTransform)
		{
			InstantiateGroup();
		}
		for (int i = 0; i < amount; i++)
		{
			FlockChild flockChild = UnityEngine.Object.Instantiate(_childPrefab);
			flockChild._spawner = this;
			_roamers.Add(flockChild);
			AddChildToParent(flockChild.transform);
		}
	}

	public void AddChildToParent(Transform obj)
	{
		if (_groupChildToFlock)
		{
			obj.parent = base.transform;
		}
		else if (_groupChildToNewTransform)
		{
			obj.parent = _groupTransform;
		}
	}

	public void RemoveChild(int amount)
	{
		for (int i = 0; i < amount; i++)
		{
			FlockChild flockChild = _roamers[_roamers.Count - 1];
			_roamers.RemoveAt(_roamers.Count - 1);
			UnityEngine.Object.Destroy(flockChild.gameObject);
		}
	}

	public void Update()
	{
		if (_activeChildren > 0f)
		{
			if (_updateDivisor > 1)
			{
				_updateCounter++;
				_updateCounter %= _updateDivisor;
				_newDelta = Time.deltaTime * (float)_updateDivisor;
			}
			else
			{
				_newDelta = Time.deltaTime;
			}
		}
		UpdateChildAmount();
	}

	public void InstantiateGroup()
	{
		if (!(_groupTransform != null))
		{
			GameObject gameObject = new GameObject();
			_groupTransform = gameObject.transform;
			_groupTransform.position = _thisT.position;
			if (_groupName != "")
			{
				gameObject.name = _groupName;
			}
			else
			{
				gameObject.name = _thisT.name + " Fish Container";
			}
		}
	}

	public void UpdateChildAmount()
	{
		if (_childAmount >= 0 && _childAmount < _roamers.Count)
		{
			RemoveChild(1);
		}
		else if (_childAmount > _roamers.Count)
		{
			AddChild(1);
		}
	}

	public void OnDrawGizmos()
	{
		if (_thisT == null)
		{
			_thisT = base.transform;
		}
		if (!Application.isPlaying && _posBuffer != _thisT.position + _startPosOffset)
		{
			_posBuffer = _thisT.position + _startPosOffset;
		}
		if (_positionSphereDepth == -1f)
		{
			_positionSphereDepth = _positionSphere;
		}
		if (_spawnSphereDepth == -1f)
		{
			_spawnSphereDepth = _spawnSphere;
		}
		Gizmos.color = UnityEngine.Color.blue;
		Gizmos.DrawWireCube(_posBuffer, new Vector3(_spawnSphere * 2f, _spawnSphereHeight * 2f, _spawnSphereDepth * 2f));
		Gizmos.color = UnityEngine.Color.cyan;
		Gizmos.DrawWireCube(_thisT.position, new Vector3(_positionSphere * 2f + _spawnSphere * 2f, _positionSphereHeight * 2f + _spawnSphereHeight * 2f, _positionSphereDepth * 2f + _spawnSphereDepth * 2f));
	}

	public void SetFlockRandomPosition()
	{
		Vector3 zero = Vector3.zero;
		zero.x = UnityEngine.Random.Range(0f - _positionSphere, _positionSphere) + _thisT.position.x;
		zero.z = UnityEngine.Random.Range(0f - _positionSphereDepth, _positionSphereDepth) + _thisT.position.z;
		zero.y = UnityEngine.Random.Range(0f - _positionSphereHeight, _positionSphereHeight) + _thisT.position.y;
		_posBuffer = zero;
		if (_forceChildWaypoints)
		{
			for (int i = 0; i < _roamers.Count; i++)
			{
				_roamers[i].Wander(UnityEngine.Random.value * _forcedRandomDelay);
			}
		}
	}

	public void destroyBirds()
	{
		for (int i = 0; i < _roamers.Count; i++)
		{
			UnityEngine.Object.Destroy(_roamers[i].gameObject);
		}
		_childAmount = 0;
		_roamers.Clear();
	}
}
public class FlockScare : MonoBehaviour
{
	public LandingSpotController[] landingSpotControllers;

	public float scareInterval = 0.1f;

	public float distanceToScare = 2f;

	public int checkEveryNthLandingSpot = 1;

	public int InvokeAmounts = 1;

	private int lsc;

	private int ls;

	private LandingSpotController currentController;

	private void CheckProximityToLandingSpots()
	{
		IterateLandingSpots();
		if (currentController._activeLandingSpots > 0 && CheckDistanceToLandingSpot(landingSpotControllers[lsc]))
		{
			landingSpotControllers[lsc].ScareAll();
		}
		Invoke("CheckProximityToLandingSpots", scareInterval);
	}

	private void IterateLandingSpots()
	{
		ls += checkEveryNthLandingSpot;
		currentController = landingSpotControllers[lsc];
		int childCount = currentController.transform.childCount;
		if (ls > childCount - 1)
		{
			ls -= childCount;
			if (lsc < landingSpotControllers.Length - 1)
			{
				lsc++;
			}
			else
			{
				lsc = 0;
			}
		}
	}

	private bool CheckDistanceToLandingSpot(LandingSpotController lc)
	{
		Transform child = lc.transform.GetChild(ls);
		if (child.GetComponent<LandingSpot>().landingChild != null && (child.position - base.transform.position).sqrMagnitude < distanceToScare * distanceToScare)
		{
			return true;
		}
		return false;
	}

	private void Invoker()
	{
		for (int i = 0; i < InvokeAmounts; i++)
		{
			float num = scareInterval / (float)InvokeAmounts * (float)i;
			Invoke("CheckProximityToLandingSpots", scareInterval + num);
		}
	}

	private void OnEnable()
	{
		CancelInvoke("CheckProximityToLandingSpots");
		if (landingSpotControllers.Length != 0)
		{
			Invoker();
		}
	}

	private void OnDisable()
	{
		CancelInvoke("CheckProximityToLandingSpots");
	}
}
public class FlockWaypointTrigger : MonoBehaviour
{
	public float _timer = 1f;

	public FlockChild _flockChild;

	public void Start()
	{
		if (_flockChild == null)
		{
			_flockChild = base.transform.parent.GetComponent<FlockChild>();
		}
		float num = UnityEngine.Random.Range(_timer, _timer * 3f);
		InvokeRepeating("Trigger", num, num);
	}

	public void Trigger()
	{
		_flockChild.Wander(0f);
	}
}
public class LandingButtons : MonoBehaviour
{
	public LandingSpotController _landingSpotController;

	public FlockController _flockController;

	public float hSliderValue = 250f;

	public void OnGUI()
	{
		GUI.Label(new Rect(20f, 20f, 125f, 18f), "Landing Spots: " + _landingSpotController.transform.childCount);
		if (GUI.Button(new Rect(20f, 40f, 125f, 18f), "Scare All"))
		{
			_landingSpotController.ScareAll();
		}
		if (GUI.Button(new Rect(20f, 60f, 125f, 18f), "Land In Reach"))
		{
			_landingSpotController.LandAll();
		}
		if (GUI.Button(new Rect(20f, 80f, 125f, 18f), "Land Instant"))
		{
			StartCoroutine(_landingSpotController.InstantLand(0.01f));
		}
		if (GUI.Button(new Rect(20f, 100f, 125f, 18f), "Destroy"))
		{
			_flockController.destroyBirds();
		}
		GUI.Label(new Rect(20f, 120f, 125f, 18f), "Bird Amount: " + _flockController._childAmount);
		_flockController._childAmount = (int)GUI.HorizontalSlider(new Rect(20f, 140f, 125f, 18f), _flockController._childAmount, 0f, 250f);
	}
}
public class LandingSpot : MonoBehaviour
{
	[HideInInspector]
	public FlockChild landingChild;

	[HideInInspector]
	public bool landing;

	private int lerpCounter;

	[HideInInspector]
	public LandingSpotController _controller;

	private bool _idle;

	public Transform _thisT;

	public bool _gotcha;

	public void Start()
	{
		if (_thisT == null)
		{
			_thisT = base.transform;
		}
		if (_controller == null)
		{
			_controller = _thisT.parent.GetComponent<LandingSpotController>();
		}
		if (_controller._autoCatchDelay.x > 0f)
		{
			StartCoroutine(GetFlockChild(_controller._autoCatchDelay.x, _controller._autoCatchDelay.y));
		}
	}

	public void OnDrawGizmos()
	{
		if (_thisT == null)
		{
			_thisT = base.transform;
		}
		if (_controller == null)
		{
			_controller = _thisT.parent.GetComponent<LandingSpotController>();
		}
		Gizmos.color = UnityEngine.Color.yellow;
		if (landingChild != null && landing)
		{
			Gizmos.DrawLine(_thisT.position, landingChild._thisT.position);
		}
		if (_thisT.rotation.eulerAngles.x != 0f || _thisT.rotation.eulerAngles.z != 0f)
		{
			_thisT.eulerAngles = new Vector3(0f, _thisT.eulerAngles.y, 0f);
		}
		Gizmos.DrawCube(new Vector3(_thisT.position.x, _thisT.position.y, _thisT.position.z), new Vector3(0.2f, 0.2f, 0.2f));
		Gizmos.DrawCube(_thisT.position + _thisT.forward * 0.2f, new Vector3(0.1f, 0.1f, 0.1f));
		Gizmos.color = new UnityEngine.Color(1f, 1f, 0f, 0.05f);
		Gizmos.DrawWireSphere(_thisT.position, _controller._maxBirdDistance);
	}

	public void LateUpdate()
	{
		if (landingChild == null)
		{
			_gotcha = false;
			_idle = false;
			lerpCounter = 0;
		}
		else if (_gotcha)
		{
			landingChild.transform.position = _thisT.position + landingChild._landingPosOffset;
			RotateBird();
		}
		else
		{
			if (!_controller._flock.gameObject.activeInHierarchy || !landing || !(landingChild != null))
			{
				return;
			}
			if (!landingChild.gameObject.activeInHierarchy)
			{
				Invoke("ReleaseFlockChild", 0f);
			}
			float num = Vector3.Distance(landingChild._thisT.position, _thisT.position + landingChild._landingPosOffset);
			if (num < 5f && num > 0.5f)
			{
				if (_controller._soarLand)
				{
					landingChild._model.GetComponent<Animation>().CrossFade(landingChild._spawner._soarAnimation, 0.5f);
					if (num < 2f)
					{
						landingChild._model.GetComponent<Animation>().CrossFade(landingChild._spawner._flapAnimation, 0.5f);
					}
				}
				landingChild._targetSpeed = landingChild._spawner._maxSpeed * _controller._landingSpeedModifier;
				landingChild._wayPoint = _thisT.position + landingChild._landingPosOffset;
				landingChild._damping = _controller._landingTurnSpeedModifier;
				landingChild._avoid = false;
			}
			else if (num <= 0.5f)
			{
				landingChild._wayPoint = _thisT.position + landingChild._landingPosOffset;
				if (num < _controller._snapLandDistance && !_idle)
				{
					_idle = true;
					landingChild._model.GetComponent<Animation>().CrossFade(landingChild._spawner._idleAnimation, 0.55f);
				}
				if (num > _controller._snapLandDistance)
				{
					landingChild._targetSpeed = landingChild._spawner._minSpeed * _controller._landingSpeedModifier;
					landingChild._thisT.position += (_thisT.position + landingChild._landingPosOffset - landingChild._thisT.position) * Time.deltaTime * landingChild._speed * _controller._landingSpeedModifier * 2f;
				}
				else
				{
					_gotcha = true;
				}
				landingChild._move = false;
				RotateBird();
			}
			else
			{
				landingChild._wayPoint = _thisT.position + landingChild._landingPosOffset;
			}
			landingChild._damping += 0.01f;
		}
	}

	public void RotateBird()
	{
		if (!_controller._randomRotate || !_idle)
		{
			lerpCounter++;
			Quaternion rotation = landingChild._thisT.rotation;
			Vector3 eulerAngles = rotation.eulerAngles;
			eulerAngles.y = Mathf.LerpAngle(landingChild._thisT.rotation.eulerAngles.y, _thisT.rotation.eulerAngles.y, (float)lerpCounter * Time.deltaTime * _controller._landedRotateSpeed);
			rotation.eulerAngles = eulerAngles;
			landingChild._thisT.rotation = rotation;
		}
	}

	public IEnumerator GetFlockChild(float minDelay, float maxDelay)
	{
		yield return Yield.WaitSeconds(UnityEngine.Random.Range(minDelay, maxDelay));
		if (!_controller._flock.gameObject.activeInHierarchy || !(landingChild == null))
		{
			yield break;
		}
		FlockChild flockChild = null;
		for (int i = 0; i < _controller._flock._roamers.Count; i++)
		{
			FlockChild flockChild2 = _controller._flock._roamers[i];
			if (flockChild2._landing || flockChild2._dived)
			{
				continue;
			}
			if (!_controller._onlyBirdsAbove)
			{
				if (flockChild == null && _controller._maxBirdDistance > Vector3.Distance(flockChild2._thisT.position, _thisT.position) && _controller._minBirdDistance < Vector3.Distance(flockChild2._thisT.position, _thisT.position))
				{
					flockChild = flockChild2;
					if (!_controller._takeClosest)
					{
						break;
					}
				}
				else if (flockChild != null && Vector3.Distance(flockChild._thisT.position, _thisT.position) > Vector3.Distance(flockChild2._thisT.position, _thisT.position))
				{
					flockChild = flockChild2;
				}
			}
			else if (flockChild == null && flockChild2._thisT.position.y > _thisT.position.y && _controller._maxBirdDistance > Vector3.Distance(flockChild2._thisT.position, _thisT.position) && _controller._minBirdDistance < Vector3.Distance(flockChild2._thisT.position, _thisT.position))
			{
				flockChild = flockChild2;
				if (!_controller._takeClosest)
				{
					break;
				}
			}
			else if (flockChild != null && flockChild2._thisT.position.y > _thisT.position.y && Vector3.Distance(flockChild._thisT.position, _thisT.position) > Vector3.Distance(flockChild2._thisT.position, _thisT.position))
			{
				flockChild = flockChild2;
			}
		}
		if (flockChild != null)
		{
			landingChild = flockChild;
			landing = true;
			landingChild._landing = true;
			if (_controller._autoDismountDelay.x > 0f)
			{
				Invoke("ReleaseFlockChild", UnityEngine.Random.Range(_controller._autoDismountDelay.x, _controller._autoDismountDelay.y));
			}
			_controller._activeLandingSpots++;
		}
		else if (_controller._autoCatchDelay.x > 0f)
		{
			StartCoroutine(GetFlockChild(_controller._autoCatchDelay.x, _controller._autoCatchDelay.y));
		}
	}

	public void InstantLand()
	{
		if (!_controller._flock.gameObject.activeInHierarchy || !(landingChild == null))
		{
			return;
		}
		FlockChild flockChild = null;
		for (int i = 0; i < _controller._flock._roamers.Count; i++)
		{
			FlockChild flockChild2 = _controller._flock._roamers[i];
			if (!flockChild2._landing && !flockChild2._dived)
			{
				flockChild = flockChild2;
			}
		}
		if (flockChild != null)
		{
			landingChild = flockChild;
			landing = true;
			_controller._activeLandingSpots++;
			landingChild._landing = true;
			landingChild._thisT.position = _thisT.position;
			landingChild._model.GetComponent<Animation>().Play(landingChild._spawner._idleAnimation);
			landingChild._thisT.Rotate(Vector3.up, UnityEngine.Random.Range(0f, 360f));
			if (_controller._autoDismountDelay.x > 0f)
			{
				Invoke("ReleaseFlockChild", UnityEngine.Random.Range(_controller._autoDismountDelay.x, _controller._autoDismountDelay.y));
			}
		}
		else if (_controller._autoCatchDelay.x > 0f)
		{
			StartCoroutine(GetFlockChild(_controller._autoCatchDelay.x, _controller._autoCatchDelay.y));
		}
	}

	public void ReleaseFlockChild()
	{
		if (_controller._flock.gameObject.activeInHierarchy && landingChild != null)
		{
			_gotcha = false;
			lerpCounter = 0;
			if (_controller._featherPS != null)
			{
				_controller._featherPS.position = landingChild._thisT.position;
				_controller._featherPS.GetComponent<ParticleSystem>().Emit(UnityEngine.Random.Range(0, 3));
			}
			landing = false;
			_idle = false;
			landingChild._avoid = true;
			landingChild._damping = landingChild._spawner._maxDamping;
			landingChild._model.GetComponent<Animation>().CrossFade(landingChild._spawner._flapAnimation, 0.2f);
			landingChild._dived = true;
			landingChild._speed = 0f;
			landingChild._move = true;
			landingChild._landing = false;
			landingChild.Flap();
			landingChild._wayPoint = new Vector3(landingChild._wayPoint.x, _thisT.position.y + 10f, landingChild._wayPoint.z);
			if (_controller._autoCatchDelay.x > 0f)
			{
				StartCoroutine(GetFlockChild(_controller._autoCatchDelay.x + 0.1f, _controller._autoCatchDelay.y + 0.1f));
			}
			landingChild = null;
			_controller._activeLandingSpots--;
		}
	}
}
public class LandingSpotController : MonoBehaviour
{
	public bool _randomRotate = true;

	public Vector2 _autoCatchDelay = new Vector2(10f, 20f);

	public Vector2 _autoDismountDelay = new Vector2(10f, 20f);

	public float _maxBirdDistance = 20f;

	public float _minBirdDistance = 5f;

	public bool _takeClosest;

	public FlockController _flock;

	public bool _landOnStart;

	public bool _soarLand = true;

	public bool _onlyBirdsAbove;

	public float _landingSpeedModifier = 0.5f;

	public float _landingTurnSpeedModifier = 5f;

	public Transform _featherPS;

	public Transform _thisT;

	public int _activeLandingSpots;

	public float _snapLandDistance = 0.1f;

	public float _landedRotateSpeed = 0.01f;

	public void Start()
	{
		if (_thisT == null)
		{
			_thisT = base.transform;
		}
		if (_flock == null)
		{
			_flock = (FlockController)UnityEngine.Object.FindObjectOfType(typeof(FlockController));
			UnityEngine.Debug.Log(string.Concat(this, " has no assigned FlockController, a random FlockController has been assigned"));
		}
		if (_landOnStart)
		{
			StartCoroutine(InstantLandOnStart(0.1f));
		}
	}

	public void ScareAll()
	{
		ScareAll(0f, 1f);
	}

	public void ScareAll(float minDelay, float maxDelay)
	{
		for (int i = 0; i < _thisT.childCount; i++)
		{
			if (_thisT.GetChild(i).GetComponent<LandingSpot>() != null)
			{
				_thisT.GetChild(i).GetComponent<LandingSpot>().Invoke("ReleaseFlockChild", UnityEngine.Random.Range(minDelay, maxDelay));
			}
		}
	}

	public void LandAll()
	{
		for (int i = 0; i < _thisT.childCount; i++)
		{
			if (_thisT.GetChild(i).GetComponent<LandingSpot>() != null)
			{
				LandingSpot component = _thisT.GetChild(i).GetComponent<LandingSpot>();
				StartCoroutine(component.GetFlockChild(0f, 2f));
			}
		}
	}

	public IEnumerator InstantLandOnStart(float delay)
	{
		yield return Yield.WaitSeconds(delay);
		for (int i = 0; i < _thisT.childCount; i++)
		{
			if (_thisT.GetChild(i).GetComponent<LandingSpot>() != null)
			{
				_thisT.GetChild(i).GetComponent<LandingSpot>().InstantLand();
			}
		}
	}

	public IEnumerator InstantLand(float delay)
	{
		yield return Yield.WaitSeconds(delay);
		for (int i = 0; i < _thisT.childCount; i++)
		{
			if (_thisT.GetChild(i).GetComponent<LandingSpot>() != null)
			{
				_thisT.GetChild(i).GetComponent<LandingSpot>().InstantLand();
			}
		}
	}
}
public class AnimatedTextureUV : MonoBehaviour
{
	public int uvAnimationTileX = 24;

	public int uvAnimationTileY = 1;

	public float framesPerSecond = 10f;

	private Renderer materialRender;

	private int manualIndex;

	private float manualTimer;

	private void Start()
	{
		materialRender = base.gameObject.GetComponent<Renderer>();
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.C))
		{
			RenderNextImage();
		}
		if (manualTimer > 0f)
		{
			manualTimer -= Time.deltaTime;
			return;
		}
		if (materialRender == null)
		{
			materialRender = base.gameObject.GetComponent<Renderer>();
		}
		int num = (int)(Time.time * framesPerSecond) % (uvAnimationTileX * uvAnimationTileY);
		Vector2 value = new Vector2(1f / (float)uvAnimationTileX, 1f / (float)uvAnimationTileY);
		float num2 = num % uvAnimationTileX;
		float num3 = num / uvAnimationTileX;
		Vector2 value2 = new Vector2(num2 * value.x, 1f - value.y - num3 * value.y);
		materialRender.sharedMaterial.SetTextureOffset("_MainTex", value2);
		materialRender.sharedMaterial.SetTextureScale("_MainTex", value);
	}

	public void RenderNextImage()
	{
		manualTimer = 10f;
		if (materialRender == null)
		{
			materialRender = base.gameObject.GetComponent<Renderer>();
		}
		manualIndex++;
		if (manualIndex >= 4)
		{
			manualIndex = 0;
		}
		Vector2 value = new Vector2(1f / (float)uvAnimationTileX, 1f / (float)uvAnimationTileY);
		float num = manualIndex % uvAnimationTileX;
		float num2 = manualIndex / uvAnimationTileX;
		Vector2 value2 = new Vector2(num * value.x, 1f - value.y - num2 * value.y);
		materialRender.sharedMaterial.SetTextureOffset("_MainTex", value2);
		materialRender.sharedMaterial.SetTextureScale("_MainTex", value);
	}
}
public class AudioScript : MonoBehaviour
{
	[HideInInspector]
	private struct QueuedAudio
	{
		public AudioClip m_AudioSource;

		public float m_Vol;

		public QueuedAudio(AudioClip audioSource, float vol)
		{
			m_AudioSource = audioSource;
			m_Vol = vol;
		}
	}

	public enum MixerChannel
	{
		sfx,
		music,
		master,
		foley,
		vo,
		directional,
		collisionDull,
		collisionBright,
		persistent,
		spatial,
		spatialLowpass,
		effects
	}

	private AudioController audioController;

	public AudioSource m_AudioSource;

	public ArrayList m_AudioSourceQueue = new ArrayList();

	[HideInInspector]
	public AudioMixer mainMixer;

	[HideInInspector]
	public AudioMixer spatialMixer;

	public bool is3D = true;

	public float amount3D = 1f;

	public MixerChannel mixerChannel;

	[Space]
	[SerializeField]
	private bool loopWhilstActive;

	[SerializeField]
	private AudioClip loopClip;

	[SerializeField]
	private float volume = 0.6f;

	public virtual void Awake()
	{
		if (!base.gameObject.GetComponent<AudioSource>())
		{
			m_AudioSource = base.gameObject.AddComponent<AudioSource>();
		}
		else
		{
			m_AudioSource = base.gameObject.GetComponent<AudioSource>();
		}
	}

	public virtual void Start()
	{
		if (is3D)
		{
			m_AudioSource.spatialBlend = amount3D;
		}
		m_AudioSource.playOnAwake = false;
		if (loopWhilstActive && loopClip != null)
		{
			PlayLoop(loopClip, volume);
		}
		SetMixerChannel(mixerChannel);
	}

	public void SetMixerChannel(MixerChannel channel)
	{
		mixerChannel = channel;
		mainMixer = GameController.instance.audioController.mainMixer;
		spatialMixer = GameController.instance.audioController.oculusSpatialMixer;
		if (mixerChannel == MixerChannel.music)
		{
			m_AudioSource.outputAudioMixerGroup = mainMixer.FindMatchingGroups("Music")[0];
		}
		else if (mixerChannel == MixerChannel.sfx)
		{
			m_AudioSource.outputAudioMixerGroup = mainMixer.FindMatchingGroups("Sfx")[0];
		}
		else if (mixerChannel == MixerChannel.master)
		{
			m_AudioSource.outputAudioMixerGroup = mainMixer.FindMatchingGroups("Master")[0];
		}
		else if (mixerChannel == MixerChannel.foley)
		{
			m_AudioSource.outputAudioMixerGroup = mainMixer.FindMatchingGroups("Foley")[0];
		}
		else if (mixerChannel == MixerChannel.vo)
		{
			m_AudioSource.outputAudioMixerGroup = mainMixer.FindMatchingGroups("VO")[0];
		}
		else if (mixerChannel == MixerChannel.directional)
		{
			m_AudioSource.outputAudioMixerGroup = mainMixer.FindMatchingGroups("Directional")[0];
		}
		else if (mixerChannel == MixerChannel.collisionDull)
		{
			m_AudioSource.outputAudioMixerGroup = mainMixer.FindMatchingGroups("CollisionDull")[0];
		}
		else if (mixerChannel == MixerChannel.collisionBright)
		{
			m_AudioSource.outputAudioMixerGroup = mainMixer.FindMatchingGroups("CollisionBright")[0];
		}
		else if (mixerChannel == MixerChannel.persistent)
		{
			m_AudioSource.outputAudioMixerGroup = mainMixer.FindMatchingGroups("Persistent")[0];
		}
		else if (mixerChannel == MixerChannel.spatial)
		{
			m_AudioSource.outputAudioMixerGroup = spatialMixer.FindMatchingGroups("Spatial")[0];
		}
		else if (mixerChannel == MixerChannel.spatialLowpass)
		{
			m_AudioSource.outputAudioMixerGroup = spatialMixer.FindMatchingGroups("SpatialLowpass")[0];
		}
		else if (mixerChannel == MixerChannel.effects)
		{
			m_AudioSource.outputAudioMixerGroup = mainMixer.FindMatchingGroups("Effects")[0];
		}
	}

	public virtual void PlayOne(AudioClip m_Clip, float vol = 1f)
	{
		m_AudioSource.PlayOneShot(m_Clip, vol);
	}

	public virtual void Play(AudioClip m_Clip, float vol = 1f)
	{
		if (m_AudioSource == null)
		{
			UnityEngine.Debug.LogError("No m_AudioSource on: " + base.gameObject.name);
			return;
		}
		m_AudioSource.Stop();
		m_AudioSource.clip = m_Clip;
		m_AudioSource.loop = false;
		m_AudioSource.volume = vol;
		m_AudioSource.time = 0f;
		m_AudioSource.Play();
	}

	public void PlayFromTime(AudioClip m_Clip, float time, float vol = 1f)
	{
		m_AudioSource.Stop();
		m_AudioSource.clip = m_Clip;
		m_AudioSource.loop = false;
		m_AudioSource.volume = vol;
		m_AudioSource.time = time;
		m_AudioSource.Play();
	}

	public void PlayInQueue(AudioClip m_Clip, float vol = 1f)
	{
		if (!m_AudioSource.isPlaying)
		{
			m_AudioSource.Stop();
			m_AudioSource.clip = m_Clip;
			m_AudioSource.loop = false;
			m_AudioSource.volume = vol;
			m_AudioSource.time = 0f;
			m_AudioSource.Play();
		}
		else if (m_AudioSourceQueue.Count == 0)
		{
			StartCoroutine(PlayQueue(m_Clip, vol));
		}
		else
		{
			QueuedAudio queuedAudio = new QueuedAudio(m_Clip, vol);
			m_AudioSourceQueue.Add(queuedAudio);
		}
	}

	private IEnumerator PlayQueue(AudioClip m_Clip, float vol = 1f)
	{
		QueuedAudio queuedAudio = new QueuedAudio(m_Clip, vol);
		m_AudioSourceQueue.Add(queuedAudio);
		while (m_AudioSourceQueue.Count > 0)
		{
			while (m_AudioSource.isPlaying)
			{
				yield return Yield.EndOfFrame;
			}
			if (m_AudioSourceQueue.Count > 0)
			{
				queuedAudio = (QueuedAudio)m_AudioSourceQueue[0];
				Play(queuedAudio.m_AudioSource, queuedAudio.m_Vol);
				m_AudioSourceQueue.RemoveAt(0);
			}
			yield return Yield.EndOfFrame;
		}
	}

	public void ClearPlayQueue()
	{
		m_AudioSourceQueue = new ArrayList();
	}

	public bool IsPlaying()
	{
		return m_AudioSource.isPlaying;
	}

	public bool IsPlayingClip(AudioClip audioClip)
	{
		if (m_AudioSource.isPlaying)
		{
			return m_AudioSource.clip == audioClip;
		}
		return false;
	}

	public void PlayLoop(AudioClip m_Clip, float vol = 1f)
	{
		m_AudioSource.Stop();
		m_AudioSource.clip = m_Clip;
		m_AudioSource.loop = true;
		m_AudioSource.volume = vol;
		m_AudioSource.time = 0f;
		m_AudioSource.Play();
	}

	public void StopLoop()
	{
		if (m_AudioSource != null)
		{
			StopAllCoroutines();
			m_AudioSource.Stop();
			m_AudioSource.loop = false;
		}
	}

	public void FadeIn(AudioClip m_clip, float vol, float time, bool loop, float playFrom = 0f)
	{
		StartCoroutine(FadeAudioIn(m_clip, vol, time, loop, playFrom));
	}

	public void FadeOut(float time)
	{
		if (m_AudioSource != null)
		{
			StopCoroutine("FadeAudioIn");
			StartCoroutine(FadeAudioOut(time));
		}
	}

	private IEnumerator FadeAudioIn(AudioClip m_clip, float vol, float time, bool loop, float playFrom)
	{
		m_AudioSource.loop = loop;
		m_AudioSource.clip = m_clip;
		m_AudioSource.volume = 0f;
		m_AudioSource.time = playFrom;
		m_AudioSource.Play();
		float i = 0f;
		float step = vol / time;
		while (i < vol)
		{
			i += step * Time.deltaTime;
			m_AudioSource.volume = i;
			yield return null;
		}
	}

	private IEnumerator FadeAudioOut(float time)
	{
		float i = m_AudioSource.volume;
		float step = m_AudioSource.volume / time;
		while (i > 0f)
		{
			i -= step * Time.deltaTime;
			m_AudioSource.volume = i;
			yield return null;
		}
		m_AudioSource.Stop();
		m_AudioSource.loop = false;
	}

	public void FadeVolumeIn(float time, float vol = 1f)
	{
		StopCoroutine("FadeVolOut");
		StartCoroutine(FadeVolIn(time, vol));
	}

	public void FadeVolumeOut(float time, float vol = 0f)
	{
		StopCoroutine("FadeVolIn");
		StartCoroutine(FadeVolOut(time, vol));
	}

	private IEnumerator FadeVolIn(float time, float vol)
	{
		float i = m_AudioSource.volume;
		float step = vol / time;
		while (i < vol)
		{
			i += step * Time.deltaTime;
			m_AudioSource.volume = i;
			yield return null;
		}
	}

	private IEnumerator FadeVolOut(float time, float vol)
	{
		float i = m_AudioSource.volume;
		float step = (m_AudioSource.volume - vol) / time;
		while (i > vol)
		{
			i -= step * Time.deltaTime;
			m_AudioSource.volume = i;
			yield return null;
		}
	}

	private void OnEnable()
	{
		if (loopWhilstActive && loopClip != null)
		{
			PlayLoop(loopClip, volume);
		}
	}
}
public class AudioScriptPooled : MonoBehaviour
{
	[Space]
	[Header("Audio Source Settings")]
	[SerializeField]
	private AudioScript.MixerChannel channel;

	[SerializeField]
	private AudioSourceSettings settings;

	[Space]
	[Header("On Enable Settings")]
	[SerializeField]
	private bool loopWhilstActive;

	[SerializeField]
	private AudioClip loopClip;

	public AudioSource tempSource;

	public bool requestSource = true;

	public void SetMixerChannel(AudioScript.MixerChannel channel)
	{
		if ((!requestSource && !(tempSource == null)) || GetAudioSource())
		{
			AudioMixer mainMixer = GameController.instance.audioController.mainMixer;
			AudioMixer oculusSpatialMixer = GameController.instance.audioController.oculusSpatialMixer;
			switch (channel)
			{
			case AudioScript.MixerChannel.music:
				tempSource.outputAudioMixerGroup = mainMixer.FindMatchingGroups("Music")[0];
				break;
			case AudioScript.MixerChannel.sfx:
				tempSource.outputAudioMixerGroup = mainMixer.FindMatchingGroups("Sfx")[0];
				break;
			case AudioScript.MixerChannel.master:
				tempSource.outputAudioMixerGroup = mainMixer.FindMatchingGroups("Master")[0];
				break;
			case AudioScript.MixerChannel.foley:
				tempSource.outputAudioMixerGroup = mainMixer.FindMatchingGroups("Foley")[0];
				break;
			case AudioScript.MixerChannel.vo:
				tempSource.outputAudioMixerGroup = mainMixer.FindMatchingGroups("VO")[0];
				break;
			case AudioScript.MixerChannel.directional:
				tempSource.outputAudioMixerGroup = mainMixer.FindMatchingGroups("Directional")[0];
				break;
			case AudioScript.MixerChannel.collisionDull:
				tempSource.outputAudioMixerGroup = mainMixer.FindMatchingGroups("CollisionDull")[0];
				break;
			case AudioScript.MixerChannel.collisionBright:
				tempSource.outputAudioMixerGroup = mainMixer.FindMatchingGroups("CollisionBright")[0];
				break;
			case AudioScript.MixerChannel.persistent:
				tempSource.outputAudioMixerGroup = mainMixer.FindMatchingGroups("Persistent")[0];
				break;
			case AudioScript.MixerChannel.spatial:
				tempSource.outputAudioMixerGroup = oculusSpatialMixer.FindMatchingGroups("Spatial")[0];
				break;
			case AudioScript.MixerChannel.spatialLowpass:
				tempSource.outputAudioMixerGroup = oculusSpatialMixer.FindMatchingGroups("SpatialLowpass")[0];
				break;
			case AudioScript.MixerChannel.effects:
				tempSource.outputAudioMixerGroup = mainMixer.FindMatchingGroups("Effects")[0];
				break;
			}
			this.channel = channel;
		}
	}

	private bool GetAudioSource()
	{
		GameController.instance.audioSourcePool.RequestAudioSource(settings, base.transform, out tempSource, this);
		if (tempSource == null)
		{
			return false;
		}
		SetMixerChannel(channel);
		return true;
	}

	public void PlayOneShot(AudioClip clip, float vol = 1f, float pitch = 1f)
	{
		if ((!requestSource && !(tempSource == null)) || GetAudioSource())
		{
			tempSource.volume = vol;
			tempSource.pitch = pitch;
			tempSource.PlayOneShot(clip, vol);
		}
	}

	public void Play(AudioClip clip, float vol = 1f, float pitch = 1f)
	{
		if ((!requestSource && !(tempSource == null)) || GetAudioSource())
		{
			tempSource.Stop();
			tempSource.pitch = pitch;
			tempSource.clip = clip;
			tempSource.loop = false;
			tempSource.volume = vol;
			tempSource.time = 0f;
			tempSource.Play();
		}
	}

	public void PlayFromTime(AudioClip clip, float time, float vol = 1f)
	{
		if ((!requestSource && !(tempSource == null)) || GetAudioSource())
		{
			tempSource.Stop();
			tempSource.clip = clip;
			tempSource.loop = false;
			tempSource.volume = vol;
			tempSource.Play();
			tempSource.time = time;
		}
	}

	public bool IsPlaying()
	{
		if ((requestSource || tempSource == null) && !GetAudioSource())
		{
			return false;
		}
		if (!(tempSource == null))
		{
			return tempSource.isPlaying;
		}
		return false;
	}

	public void PlayLoop(AudioClip clip, float vol = 1f)
	{
		if ((!requestSource && !(tempSource == null)) || GetAudioSource())
		{
			tempSource.Stop();
			tempSource.clip = clip;
			tempSource.loop = true;
			tempSource.volume = vol;
			tempSource.time = 0f;
			tempSource.Play();
		}
	}

	public void StopLoop()
	{
		if (tempSource != null)
		{
			StopAllCoroutines();
			tempSource.Stop();
			tempSource.loop = false;
		}
	}

	public void FadeIn(AudioClip clip, float vol, float time, bool loop)
	{
		StartCoroutine(FadeAudioIn(clip, vol, time, loop));
	}

	public void FadeOut(float time)
	{
		if (tempSource != null)
		{
			StopCoroutine("FadeAudioIn");
			StartCoroutine(FadeAudioOut(time));
		}
	}

	private IEnumerator FadeAudioIn(AudioClip m_clip, float vol, float time, bool loop)
	{
		if ((!requestSource && !(tempSource == null)) || GetAudioSource())
		{
			tempSource.loop = loop;
			tempSource.clip = m_clip;
			tempSource.volume = 0f;
			tempSource.Play();
			float i = 0f;
			float step = vol / time;
			while (i < vol)
			{
				i += step * Time.deltaTime;
				tempSource.volume = i;
				yield return null;
			}
		}
	}

	private IEnumerator FadeAudioOut(float time)
	{
		float i = tempSource.volume;
		float step = tempSource.volume / time;
		while (i > 0f)
		{
			i -= step * Time.deltaTime;
			tempSource.volume = i;
			yield return null;
		}
		tempSource.Stop();
		tempSource.loop = false;
	}

	public void FadeVolumeIn(float time, float vol = 1f)
	{
		StopCoroutine("FadeVolOut");
		StartCoroutine(FadeVolIn(time, vol));
	}

	public void FadeVolumeOut(float time, float vol = 0f)
	{
		StopCoroutine("FadeVolIn");
		StartCoroutine(FadeVolOut(time, vol));
	}

	private IEnumerator FadeVolIn(float time, float vol)
	{
		if ((!requestSource && !(tempSource == null)) || GetAudioSource())
		{
			float i = tempSource.volume;
			float step = vol / time;
			while (i < vol)
			{
				i += step * Time.deltaTime;
				tempSource.volume = i;
				yield return null;
			}
		}
	}

	private IEnumerator FadeVolOut(float time, float vol)
	{
		if ((!requestSource && !(tempSource == null)) || GetAudioSource())
		{
			float i = tempSource.volume;
			float step = (tempSource.volume - vol) / time;
			while (i > vol)
			{
				i -= step * Time.deltaTime;
				tempSource.volume = i;
				yield return null;
			}
		}
	}

	public void SetVolume(float vol)
	{
		if ((!requestSource && !(tempSource == null)) || GetAudioSource())
		{
			tempSource.volume = vol;
		}
	}

	private void OnEnable()
	{
		if (loopWhilstActive && loopClip != null)
		{
			PlayLoop(loopClip, settings.volume);
		}
	}
}
[Serializable]
public class AudioSourceSettings
{
	[Range(0f, 256f)]
	public int priority = 128;

	[Range(0f, 1f)]
	public float volume = 1f;

	[Range(-3f, 3f)]
	public float pitch = 1f;

	[Range(-1f, 1f)]
	public float stereoPan;

	[Range(0f, 1f)]
	public float spatialBlend = 1f;

	[Range(0f, 1.1f)]
	public float reverbZoneMix = 1f;
}
public class AudioSourcePoolManager : MonoBehaviour
{
	public class ASPoolObj : MonoBehaviour
	{
		public AudioSource source;

		public bool isPooled = true;

		private bool _quitting;

		private void OnDestroy()
		{
			if (!_quitting)
			{
				UnityEngine.Debug.LogWarning("You're attempting to destroy an object that has a pooled audio source attached to it: this is wrong! Destroyed parent of audio source = [" + base.transform.parent.name + "]");
			}
		}

		private void OnApplicationQuit()
		{
			shutdown = true;
		}
	}

	private List<ASPoolObj> _audioPool = new List<ASPoolObj>();

	public int BASE_POOL_SIZE;

	public bool isDynamic = true;

	private bool _canPlaySFX;

	protected static bool shutdown;

	public bool CanPlaySFX => _canPlaySFX;

	private void Awake()
	{
		Init();
	}

	private void Init()
	{
		for (int i = 0; i < BASE_POOL_SIZE; i++)
		{
			ASPoolObj aSPoolObj = ExpandPool(runtimeExpand: false);
			aSPoolObj.isPooled = true;
			aSPoolObj.gameObject.SetActive(value: false);
			aSPoolObj.transform.parent = base.transform;
		}
		EventManager.StartListening(EventManager.AvailableEvents.StartedLoading.ToString(), CheckCanPlaySFX);
		UnityEngine.Debug.Log("Created audio pool with " + (isDynamic ? "dyanmic" : "static") + " size of " + _audioPool.Count);
	}

	private void CheckCanPlaySFX()
	{
		_canPlaySFX = false;
		StartCoroutine(CheckCanPlaySFXRoutine());
	}

	private IEnumerator CheckCanPlaySFXRoutine()
	{
		AudioMixer mixer = GameController.instance.audioController.mainMixer;
		float sfxVol = -80f;
		while (sfxVol <= -10f)
		{
			mixer.GetFloat("SFX_Vol", out sfxVol);
			yield return Yield.WaitSeconds(0.1f);
		}
		_canPlaySFX = true;
	}

	public void RequestAudioSource(AudioSourceSettings settings, Transform parent, out AudioSource audioScriptSource, AudioScriptPooled audioScript)
	{
		ASPoolObj aSPoolObj = null;
		for (int i = 0; i < _audioPool.Count; i++)
		{
			if (_audioPool[i] == null)
			{
				UnityEngine.Debug.LogWarning("Destroyed a ASPoolObj reference - attempting to recreate it.");
				_audioPool[i] = new GameObject("AudioPoolObj").AddComponent<ASPoolObj>();
				_audioPool[i].source = _audioPool[i].gameObject.AddComponent<AudioSource>();
				_audioPool[i].source.playOnAwake = false;
				_audioPool[i].isPooled = true;
				_audioPool[i].gameObject.SetActive(value: false);
				_audioPool[i].transform.parent = base.transform;
			}
			if (_audioPool[i].isPooled)
			{
				_audioPool[i].isPooled = false;
				aSPoolObj = _audioPool[i];
				break;
			}
		}
		if (aSPoolObj == null)
		{
			if (!isDynamic)
			{
				audioScriptSource = null;
				return;
			}
			aSPoolObj = ExpandPool(runtimeExpand: true);
			aSPoolObj.isPooled = false;
		}
		aSPoolObj.transform.parent = parent;
		aSPoolObj.transform.localPosition = Vector3.zero;
		if (settings == null)
		{
			settings = new AudioSourceSettings();
		}
		aSPoolObj.source.priority = settings.priority;
		aSPoolObj.source.volume = settings.volume;
		aSPoolObj.source.pitch = settings.pitch;
		aSPoolObj.source.panStereo = settings.stereoPan;
		aSPoolObj.source.spatialBlend = settings.spatialBlend;
		aSPoolObj.source.reverbZoneMix = settings.reverbZoneMix;
		aSPoolObj.source.time = 0f;
		aSPoolObj.gameObject.SetActive(value: true);
		audioScript.requestSource = false;
		audioScriptSource = aSPoolObj.source;
		StartCoroutine(AddBackToPoolRoutine(aSPoolObj, audioScript));
	}

	private ASPoolObj ExpandPool(bool runtimeExpand)
	{
		ASPoolObj aSPoolObj = new GameObject("AudioPoolObj").AddComponent<ASPoolObj>();
		aSPoolObj.source = aSPoolObj.gameObject.AddComponent<AudioSource>();
		aSPoolObj.source.playOnAwake = false;
		_audioPool.Add(aSPoolObj);
		if (runtimeExpand)
		{
			UnityEngine.Debug.Log("Expanding audio source pool, new size = " + _audioPool.Count);
		}
		return aSPoolObj;
	}

	private IEnumerator AddBackToPoolRoutine(ASPoolObj obj, AudioScriptPooled audioScript)
	{
		yield return Yield.WaitSeconds(0.1f);
		while (obj != null && obj.source.isPlaying)
		{
			yield return Yield.EndOfFrame;
		}
		if (obj != null)
		{
			obj.transform.parent = base.transform;
			obj.transform.localPosition = Vector3.zero;
			obj.isPooled = true;
			obj.gameObject.SetActive(value: false);
		}
		audioScript.requestSource = true;
		audioScript.tempSource = null;
	}

	public void ForceAllAudioBackToPool()
	{
		foreach (ASPoolObj item in _audioPool)
		{
			if ((bool)item)
			{
				item.transform.parent = base.transform;
				item.transform.localPosition = Vector3.zero;
				item.isPooled = true;
				item.gameObject.SetActive(value: false);
			}
		}
	}
}
public class BoundDetection : MonoBehaviour
{
	private int oobColliderCount;

	private NVRPlayer player;

	[HideInInspector]
	public bool outOfBounds;

	private bool outOfReach;

	private bool outOfObject;

	[SerializeField]
	private float resetTime = 3f;

	private float timer;

	private bool locoOff;

	private bool oobEnabled;

	private void Start()
	{
		player = GameController.instance.player;
		player.visual_OOB.SetActive(value: false);
	}

	public void SwitchOnOOB()
	{
		TurnOffOOB(fadeScreen: false, enableMovement: false);
		oobEnabled = true;
		if (GameController.instance.currentRoom != null)
		{
			GameController.instance.currentRoom.SwitchOnOOB();
		}
	}

	public void SwitchOffOOB()
	{
		TurnOffOOB(fadeScreen: false, enableMovement: false);
		oobEnabled = false;
		if (GameController.instance.currentRoom != null)
		{
			GameController.instance.currentRoom.SwitchOffOOB();
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (!oobEnabled)
		{
			return;
		}
		if (other.gameObject.tag == "OutOfBounds")
		{
			if (player != null)
			{
				oobColliderCount++;
				timer = 0f;
				player.screenFX.Fade(UnityEngine.Color.black, 0f);
				if (player.movement != null)
				{
					player.movement.DisableEverything();
				}
				locoOff = true;
				outOfBounds = true;
			}
		}
		else if (other.gameObject.tag == "OutOfReach")
		{
			if (player != null)
			{
				outOfReach = true;
				player.screenFX.PeripheralFade(1f);
			}
		}
		else if (other.gameObject.tag == "OutOfObject" && player != null)
		{
			outOfObject = true;
			player.screenFX.BlurScreen(enabled: true);
		}
	}

	private void OnTriggerStay(Collider other)
	{
		if (!oobEnabled)
		{
			return;
		}
		if (other.gameObject.tag == "OutOfBounds")
		{
			if (!(player != null))
			{
				return;
			}
			outOfBounds = true;
			if (player.screenFader.color != UnityEngine.Color.black)
			{
				player.screenFX.Fade(UnityEngine.Color.black, 0f);
			}
			if (!locoOff)
			{
				if (player.movement != null)
				{
					player.movement.DisableEverything();
				}
				locoOff = true;
			}
			timer += Time.deltaTime;
			if (timer >= resetTime)
			{
				player.visual_OOB.SetActive(value: true);
			}
		}
		else if (other.gameObject.tag == "OutOfReach")
		{
			outOfReach = true;
		}
		else if (other.gameObject.tag == "OutOfObject")
		{
			outOfObject = true;
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (!oobEnabled)
		{
			return;
		}
		if (other.gameObject.tag == "OutOfBounds")
		{
			oobColliderCount--;
			if (oobColliderCount < 0)
			{
				oobColliderCount = 0;
			}
			if (oobColliderCount == 0)
			{
				outOfBounds = false;
				player.visual_OOB.SetActive(value: false);
				player.screenFX.Fade(UnityEngine.Color.clear, 0f);
				player.movement.EnableEverything();
				locoOff = false;
			}
		}
		else if (other.gameObject.tag == "OutOfReach")
		{
			outOfReach = false;
			player.screenFX.PeripheralFade(0f);
		}
		else if (other.gameObject.tag == "OutOfObject")
		{
			outOfObject = false;
			player.screenFX.BlurScreen(enabled: false);
		}
	}

	public void TurnOffOOB(bool fadeScreen, bool enableMovement)
	{
		oobColliderCount = 0;
		outOfBounds = false;
		player.visual_OOB.SetActive(value: false);
		locoOff = false;
		if (fadeScreen)
		{
			player.screenFX.Fade(UnityEngine.Color.clear, 0f);
		}
		if (enableMovement)
		{
			player.movement.EnableEverything();
		}
	}
}
public class BreakableObject : SoundObject
{
	[SerializeField]
	private GameObject[] ownObjects;

	[SerializeField]
	private GameObject[] fragments;

	[SerializeField]
	public Transform fragmentsParent;

	[SerializeField]
	protected float power = 100f;

	[SerializeField]
	private GameObject particleSmash;

	[SerializeField]
	private AudioClip smashSound;

	public float smashVel = 5f;

	private AudioScriptPooled smashAudioScript;

	private Rigidbody rigidBody;

	protected Vector3 storedVelocity;

	public bool triggersAchievement;

	public GameObject smashAgainstAchievementObject;

	public EventManager.AvailableEvents eventToTrigger = EventManager.AvailableEvents.BrokenObject;

	public bool canSmash = true;

	public bool canSmashInHand;

	public bool removeSelf = true;

	public bool hasSmashed;

	private NVRInteractableItem interactable;

	private new void Start()
	{
		base.Start();
		smashAudioScript = base.gameObject.AddComponent<AudioScriptPooled>();
		rigidBody = GetComponent<Rigidbody>();
		interactable = GetComponent<NVRInteractableItem>();
	}

	private void Update()
	{
		storedVelocity = rigidBody.velocity;
	}

	protected override void OnCollisionEnter(Collision collision)
	{
		if (!hasSmashed)
		{
			if (collision.gameObject.name == "Head" || collision.gameObject.name == "CenterEyePoint" || (!canSmashInHand && (bool)interactable && (bool)interactable.AttachedHand) || !(collision.relativeVelocity.magnitude > smashVel) || !canSmash)
			{
				return;
			}
			if ((bool)interactable)
			{
				interactable.CanAttach = !removeSelf;
				NVRPlayer player = GameController.instance.player;
				if (interactable.AttachedHand == GameController.instance.player.RightHand)
				{
					player.RightHand.ForceDropItem();
					player.RightHand.CurrentlyInteracting = null;
					player.RightHand.CurrentlyHoveringOver.Remove(interactable);
				}
				if (interactable.AttachedHand == GameController.instance.player.LeftHand)
				{
					player.LeftHand.ForceDropItem();
					player.LeftHand.CurrentlyInteracting = null;
					player.LeftHand.CurrentlyHoveringOver.Remove(interactable);
				}
			}
			if (smashAgainstAchievementObject != null)
			{
				if (collision.gameObject == smashAgainstAchievementObject && triggersAchievement && !hasSmashed)
				{
					EventManager.TriggerEvent(eventToTrigger.ToString());
				}
			}
			else if (triggersAchievement && !hasSmashed)
			{
				EventManager.TriggerEvent(eventToTrigger.ToString());
			}
			hasSmashed = true;
			if ((bool)smashSound)
			{
				smashAudioScript.SetMixerChannel(AudioScript.MixerChannel.sfx);
				smashAudioScript.Play(smashSound);
			}
			if ((bool)particleSmash)
			{
				particleSmash.SetActive(value: true);
				particleSmash.transform.SetParent(null);
			}
			if (removeSelf)
			{
				base.transform.DetachChildren();
			}
			GameObject[] array = fragments;
			foreach (GameObject gameObject in array)
			{
				gameObject.SetActive(value: true);
				Vector3 force = Vector3.Reflect(storedVelocity, collision.contacts[0].normal) * power;
				if (!gameObject.GetComponent<Rigidbody>())
				{
					gameObject.AddComponent<Rigidbody>();
				}
				gameObject.GetComponent<Rigidbody>().AddForce(force);
				if ((bool)fragmentsParent)
				{
					gameObject.transform.parent = fragmentsParent;
				}
			}
			if (ownObjects.Length != 0)
			{
				for (int j = 0; j < ownObjects.Length; j++)
				{
					ownObjects[j].SetActive(value: false);
				}
			}
			if (removeSelf)
			{
				base.gameObject.SetActive(value: false);
			}
			else
			{
				UnityEngine.Object.Destroy(this);
			}
		}
		else if (collisionActive && GameController.instance.audioSourcePool.CanPlaySFX)
		{
			PlaySound(collision);
		}
	}
}
public class ControlsManager : MonoBehaviour
{
	[SerializeField]
	private NVRHand rightHand;

	[SerializeField]
	private NVRHand leftHand;

	private NVRHand primaryHand;

	private NVRHand secondaryHand;

	private float triggerThreshold = 0.2f;

	public static ControlsManager instance;

	public bool usingDS4Controller;

	private Vector2 PicoRotation;

	public bool isInitilised;

	private NVRButtons saveButton = NVRButtons.A;

	private NVRButtons loadButton = NVRButtons.B;

	public NVRButtons continuePrimary = NVRButtons.A;

	public NVRButtons continueSecondary = NVRButtons.A;

	public NVRButtons calibratePrimary = NVRButtons.Trigger;

	public NVRButtons calibrateSecondary = NVRButtons.Trigger;

	public NVRButtons calibrateDS4 = NVRButtons.TriggerRight;

	public NVRButtons pickupPrimary = NVRButtons.Trigger;

	public NVRButtons pickupSecondary = NVRButtons.Trigger;

	private bool lockPickupPrimary;

	private bool lockPickupSecondary;

	private int frameCountPickupP = -1;

	private int frameCountPickupS = -1;

	public NVRButtons triggerPrimary = NVRButtons.Trigger;

	public NVRButtons triggerSecondary = NVRButtons.Trigger;

	private bool lockTriggerPrimary;

	private bool lockTriggerSecondary;

	private int frameCountTriggerP = -1;

	private int frameCountTriggerS = -1;

	public NVRButtons menuButton = NVRButtons.Y;

	public NVRButtons secondaryMenuButton = NVRButtons.ApplicationMenu;

	public NVRButtons teleportButton = NVRButtons.Touchpad;

	private bool lockTeleport;

	private int frameCountTeleport;

	public NVRButtons interactButton = NVRButtons.Touchpad;

	public NVRButtons crouchButton = NVRButtons.Touchpad;

	public NVRButtons forwardButton = NVRButtons.DPad_Up;

	public NVRButtons backwardButton = NVRButtons.DPad_Down;

	public NVRButtons leftButton = NVRButtons.DPad_Left;

	public NVRButtons rightButton = NVRButtons.DPad_Right;

	public NVRButtons moveAxisButton = NVRButtons.Touchpad;

	public NVRButtons profileButton = NVRButtons.B;

	public NVRButtons rotateRight = NVRButtons.DPad_Right;

	public Vector2 swipePosition;

	public NVRButtons rotateLeft = NVRButtons.DPad_Left;

	public NVRButtons rotateMenuLeft = NVRButtons.DPad_Left;

	public NVRButtons rotateMenuRight = NVRButtons.DPad_Right;

	public bool saveButtonDown
	{
		get
		{
			if (isInitilised)
			{
				return secondaryHand.Inputs[saveButton].PressDownA;
			}
			return false;
		}
	}

	public bool loadButtonDown
	{
		get
		{
			if (isInitilised)
			{
				return secondaryHand.Inputs[loadButton].PressDownB;
			}
			return false;
		}
	}

	public bool primaryContinueButtonDown
	{
		get
		{
			if (isInitilised)
			{
				return primaryHand.Inputs[continuePrimary].PressDownX;
			}
			return false;
		}
	}

	public bool secondaryContinueButtonDown
	{
		get
		{
			if (isInitilised)
			{
				return secondaryHand.Inputs[continueSecondary].PressDownA;
			}
			return false;
		}
	}

	public bool primaryCalibrateButtonDown
	{
		get
		{
			if (isInitilised)
			{
				return primaryHand.Inputs[calibratePrimary].SingleAxisLeftDown;
			}
			return false;
		}
	}

	public bool secondaryCalibrateButtonDown
	{
		get
		{
			if (isInitilised)
			{
				return secondaryHand.Inputs[calibrateSecondary].SingleAxisRightDown;
			}
			return false;
		}
	}

	public bool ds4CalibrateButtonDown
	{
		get
		{
			if (isInitilised)
			{
				return primaryHand.Inputs[calibrateDS4].SingleAxisLeftDown;
			}
			return false;
		}
	}

	public bool primaryPickupButtonDown
	{
		get
		{
			if (Application.isEditor)
			{
				return Input.GetKeyDown(KeyCode.Z);
			}
			if (isInitilised)
			{
				if (!primaryHand.IsLeft)
				{
					return primaryHand.Inputs[pickupPrimary].SingleAxisRightDown;
				}
				return primaryHand.Inputs[pickupPrimary].SingleAxisLeftDown;
			}
			return false;
		}
	}

	public bool secondaryPickupButtonDown
	{
		get
		{
			if (Application.isEditor)
			{
				return Input.GetKeyDown(KeyCode.X);
			}
			if (isInitilised)
			{
				if (!secondaryHand.IsRight)
				{
					return secondaryHand.Inputs[pickupSecondary].SingleAxisLeftDown;
				}
				return secondaryHand.Inputs[pickupPrimary].SingleAxisRightDown;
			}
			return false;
		}
	}

	public bool primaryPickupButtonUp
	{
		get
		{
			if (Application.isEditor)
			{
				return Input.GetKeyUp(KeyCode.Z);
			}
			if (isInitilised)
			{
				if (!primaryHand.IsLeft)
				{
					return primaryHand.Inputs[pickupPrimary].SingleAxisRightUp;
				}
				return primaryHand.Inputs[pickupPrimary].SingleAxisLeftUp;
			}
			return false;
		}
	}

	public bool secondaryPickupButtonUp
	{
		get
		{
			if (Application.isEditor)
			{
				return Input.GetKeyUp(KeyCode.X);
			}
			if (isInitilised)
			{
				if (!secondaryHand.IsRight)
				{
					return secondaryHand.Inputs[pickupSecondary].SingleAxisLeftUp;
				}
				return secondaryHand.Inputs[pickupSecondary].SingleAxisRightUp;
			}
			return false;
		}
	}

	public bool primaryPickupButtonHold
	{
		get
		{
			if (Application.isEditor)
			{
				return Input.GetKey(KeyCode.Z);
			}
			if (isInitilised)
			{
				if (!primaryHand.IsLeft)
				{
					return primaryHand.Inputs[pickupPrimary].IsPressedTriggerRight;
				}
				return primaryHand.Inputs[pickupPrimary].IsPressedTriggerLeft;
			}
			return false;
		}
	}

	public bool secondaryPickupButtonHold
	{
		get
		{
			if (Application.isEditor)
			{
				return Input.GetKey(KeyCode.Z);
			}
			if (isInitilised)
			{
				if (!secondaryHand.IsRight)
				{
					return secondaryHand.Inputs[pickupSecondary].IsPressedTriggerLeft;
				}
				return secondaryHand.Inputs[pickupSecondary].IsPressedTriggerRight;
			}
			return false;
		}
	}

	public bool primaryTriggerButtonDown
	{
		get
		{
			if (Application.isEditor)
			{
				return Input.GetKeyDown(KeyCode.Z);
			}
			if (isInitilised)
			{
				if (!primaryHand.IsLeft)
				{
					return primaryHand.Inputs[triggerPrimary].SingleAxisRightDown;
				}
				return primaryHand.Inputs[triggerPrimary].SingleAxisLeftDown;
			}
			return false;
		}
	}

	public bool secondaryTriggerButtonDown
	{
		get
		{
			if (Application.isEditor)
			{
				return Input.GetKeyDown(KeyCode.X);
			}
			if (isInitilised)
			{
				if (!secondaryHand.IsRight)
				{
					return secondaryHand.Inputs[triggerSecondary].SingleAxisLeftDown;
				}
				return secondaryHand.Inputs[triggerSecondary].SingleAxisRightDown;
			}
			return false;
		}
	}

	public bool primaryTriggerButtonUp
	{
		get
		{
			if (Application.isEditor)
			{
				return Input.GetKeyUp(KeyCode.Z);
			}
			if (isInitilised)
			{
				if (!primaryHand.IsLeft)
				{
					return primaryHand.Inputs[triggerPrimary].SingleAxisRightUp;
				}
				return primaryHand.Inputs[triggerPrimary].SingleAxisLeftUp;
			}
			return false;
		}
	}

	public bool secondaryTriggerButtonUp
	{
		get
		{
			if (Application.isEditor)
			{
				return Input.GetKeyUp(KeyCode.X);
			}
			if (isInitilised)
			{
				if (!secondaryHand.IsRight)
				{
					return secondaryHand.Inputs[triggerSecondary].SingleAxisLeftUp;
				}
				return secondaryHand.Inputs[triggerSecondary].SingleAxisRightUp;
			}
			return false;
		}
	}

	public bool primaryTriggerButtonHold
	{
		get
		{
			if (isInitilised)
			{
				return primaryHand.Inputs[triggerPrimary].IsPressedTriggerRight;
			}
			return false;
		}
	}

	public bool secondaryTriggerButtonHold
	{
		get
		{
			if (isInitilised)
			{
				return secondaryHand.Inputs[triggerSecondary].IsPressedTriggerLeft;
			}
			return false;
		}
	}

	public bool menuButtonDown
	{
		get
		{
			if (Application.isEditor)
			{
				return Input.GetKeyDown(KeyCode.P);
			}
			if (isInitilised)
			{
				if (!usingDS4Controller)
				{
					return secondaryHand.Inputs[menuButton].PressDownApp;
				}
				return primaryHand.Inputs[menuButton].PressDownApp;
			}
			return false;
		}
	}

	public bool secondaryMenuButtonDown
	{
		get
		{
			if (Application.isEditor)
			{
				return Input.GetKeyDown(KeyCode.O);
			}
			if (isInitilised)
			{
				return secondaryHand.Inputs[secondaryMenuButton].PressDownApp;
			}
			return false;
		}
	}

	public bool menuButtonHold
	{
		get
		{
			if (isInitilised)
			{
				if (!usingDS4Controller)
				{
					return secondaryHand.Inputs[menuButton].IsPressedAppLeft;
				}
				return primaryHand.Inputs[menuButton].IsPressedAppLeft;
			}
			return false;
		}
	}

	public bool secondaryMenuButtonHold
	{
		get
		{
			if (isInitilised)
			{
				return secondaryHand.Inputs[secondaryMenuButton].IsPressedAppRight;
			}
			return false;
		}
	}

	public bool menuButtonUp
	{
		get
		{
			if (Application.isEditor)
			{
				return Input.GetKeyDown(KeyCode.P);
			}
			if (isInitilised)
			{
				if (!usingDS4Controller)
				{
					return secondaryHand.Inputs[menuButton].PressUpApp;
				}
				return primaryHand.Inputs[menuButton].PressUpApp;
			}
			return false;
		}
	}

	public bool secondaryMenuButtonUp
	{
		get
		{
			if (Application.isEditor)
			{
				return Input.GetKeyDown(KeyCode.O);
			}
			if (isInitilised)
			{
				return secondaryHand.Inputs[secondaryMenuButton].PressUpApp;
			}
			return false;
		}
	}

	public bool teleportButtonDown
	{
		get
		{
			if (isInitilised)
			{
				if (secondaryHand.Player.CurrentIntegrationType == NVRSDKIntegrations.Pico)
				{
					return secondaryHand.Inputs[teleportButton].PressDownB;
				}
				return false;
			}
			return false;
		}
	}

	public bool teleportButtonUp
	{
		get
		{
			if (isInitilised)
			{
				if (secondaryHand.Player.CurrentIntegrationType == NVRSDKIntegrations.Pico)
				{
					return secondaryHand.Inputs[teleportButton].PressUpB;
				}
				return false;
			}
			return false;
		}
	}

	public bool teleportButtonHold
	{
		get
		{
			if (isInitilised)
			{
				return secondaryHand.Inputs[teleportButton].IsPressedB;
			}
			return false;
		}
	}

	public bool interactPrimaryDown
	{
		get
		{
			if (isInitilised)
			{
				if (!(primaryHand.IsLeft ? primaryHand.Inputs[interactButton].GripLeftDown : primaryHand.Inputs[interactButton].GripRightDown))
				{
					return false;
				}
				if (primaryHand.Player.CurrentIntegrationType != NVRSDKIntegrations.SteamVR)
				{
					return true;
				}
				return primaryHand.Inputs[NVRButtons.Axis0].AxisLeft.y > 0f;
			}
			return false;
		}
	}

	public bool interactSecondaryDown
	{
		get
		{
			if (isInitilised)
			{
				if (!(secondaryHand.IsRight ? secondaryHand.Inputs[interactButton].GripRightDown : secondaryHand.Inputs[interactButton].GripLeftDown))
				{
					return false;
				}
				if (secondaryHand.Player.CurrentIntegrationType != NVRSDKIntegrations.SteamVR)
				{
					return true;
				}
				return secondaryHand.Inputs[NVRButtons.Axis0].AxisRight.y > 0f;
			}
			return false;
		}
	}

	public bool interactPrimaryUp
	{
		get
		{
			if (isInitilised)
			{
				if (!primaryHand.IsLeft)
				{
					return primaryHand.Inputs[interactButton].GripRightUp;
				}
				return primaryHand.Inputs[interactButton].GripLeftUp;
			}
			return false;
		}
	}

	public bool interactSecondaryUp
	{
		get
		{
			if (isInitilised)
			{
				if (!secondaryHand.IsRight)
				{
					return secondaryHand.Inputs[interactButton].GripLeftUp;
				}
				return secondaryHand.Inputs[interactButton].GripRightUp;
			}
			return false;
		}
	}

	public bool interactPrimaryHold
	{
		get
		{
			if (isInitilised)
			{
				return primaryHand.Inputs[interactButton].IsPressedGripRight;
			}
			return false;
		}
	}

	public bool interactSecondaryHold
	{
		get
		{
			if (isInitilised)
			{
				return secondaryHand.Inputs[interactButton].IsPressedGripLeft;
			}
			return false;
		}
	}

	public bool crouchButtonDown
	{
		get
		{
			if (isInitilised)
			{
				if (primaryHand.Player.CurrentIntegrationType == NVRSDKIntegrations.Pico)
				{
					return primaryHand.Inputs[crouchButton].PressDownA;
				}
				return false;
			}
			return false;
		}
	}

	public bool crouchButtonUp
	{
		get
		{
			if (isInitilised)
			{
				return primaryHand.Inputs[crouchButton].PressUpA;
			}
			return false;
		}
	}

	public bool crouchButtonHold
	{
		get
		{
			if (isInitilised)
			{
				return primaryHand.Inputs[crouchButton].IsPressedA;
			}
			return false;
		}
	}

	public bool forwardButtonHold
	{
		get
		{
			_ = isInitilised;
			return false;
		}
	}

	public bool backwardButtonHold
	{
		get
		{
			_ = isInitilised;
			return false;
		}
	}

	public bool leftButtonHold
	{
		get
		{
			_ = isInitilised;
			return false;
		}
	}

	public bool rightButtonHold
	{
		get
		{
			_ = isInitilised;
			return false;
		}
	}

	public Vector2 moveAxisHold
	{
		get
		{
			if (Application.isEditor)
			{
				Vector2 vector = default(Vector2);
				if (Input.GetKey(KeyCode.W))
				{
					vector += Vector2.up;
				}
				if (Input.GetKey(KeyCode.S))
				{
					vector += Vector2.down;
				}
				if (Input.GetKey(KeyCode.D))
				{
					vector += Vector2.right;
				}
				if (Input.GetKey(KeyCode.A))
				{
					vector += Vector2.left;
				}
				return vector.normalized;
			}
			if (isInitilised)
			{
				if (!secondaryHand.IsLeft)
				{
					return primaryHand.Inputs[NVRButtons.Axis0].AxisLeft;
				}
				return secondaryHand.Inputs[NVRButtons.Axis0].AxisLeft;
			}
			return Vector2.zero;
		}
	}

	public bool profileButtonDown
	{
		get
		{
			if (isInitilised)
			{
				return primaryHand.Inputs[profileButton].PressDownB;
			}
			return false;
		}
	}

	public bool rotateRightDown
	{
		get
		{
			if (isInitilised)
			{
				if (secondaryHand.Player.CurrentIntegrationType == NVRSDKIntegrations.Pico)
				{
					PicoRotation = Controller.UPvr_GetAxis2D(1);
					if (PicoRotation[0] > 0f)
					{
						return true;
					}
				}
				return false;
			}
			return false;
		}
	}

	public bool rotateRightUp
	{
		get
		{
			_ = isInitilised;
			return false;
		}
	}

	public bool rotateRightHold
	{
		get
		{
			if (isInitilised)
			{
				if (secondaryHand.Player.CurrentIntegrationType == NVRSDKIntegrations.Pico)
				{
					PicoRotation = Controller.UPvr_GetAxis2D(1);
					if (PicoRotation[0] > 0f)
					{
						return true;
					}
				}
				return false;
			}
			return false;
		}
	}

	public bool rotateLeftDown
	{
		get
		{
			if (isInitilised)
			{
				if (secondaryHand.Player.CurrentIntegrationType == NVRSDKIntegrations.Pico)
				{
					PicoRotation = Controller.UPvr_GetAxis2D(1);
					if (PicoRotation[0] < 0f)
					{
						return true;
					}
				}
				return false;
			}
			return false;
		}
	}

	public bool rotateLeftUp
	{
		get
		{
			_ = isInitilised;
			return false;
		}
	}

	public bool rotateLeftHold
	{
		get
		{
			if (isInitilised)
			{
				if (secondaryHand.Player.CurrentIntegrationType == NVRSDKIntegrations.Pico)
				{
					PicoRotation = Controller.UPvr_GetAxis2D(1);
					if (PicoRotation[0] < 0f)
					{
						return true;
					}
				}
				return false;
			}
			return false;
		}
	}

	public bool swipeHold
	{
		get
		{
			_ = isInitilised;
			return false;
		}
	}

	public bool rotateMenuLeftDown
	{
		get
		{
			if (isInitilised)
			{
				if (secondaryHand.Player.CurrentIntegrationType == NVRSDKIntegrations.Pico)
				{
					PicoRotation = Controller.UPvr_GetAxis2D(0);
					if (PicoRotation[0] < 0f)
					{
						return true;
					}
				}
				return false;
			}
			return false;
		}
	}

	public bool rotateMenuRightDown
	{
		get
		{
			if (isInitilised)
			{
				if (secondaryHand.Player.CurrentIntegrationType == NVRSDKIntegrations.Pico)
				{
					PicoRotation = Controller.UPvr_GetAxis2D(0);
					if (PicoRotation[0] > 0f)
					{
						return true;
					}
				}
				return false;
			}
			return false;
		}
	}

	public bool confirmPSVR => false;

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
		else if (instance != this)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
	}

	private void Start()
	{
		StartCoroutine(Init());
	}

	public IEnumerator Init()
	{
		while (!rightHand.isInitilised && !leftHand.isInitilised)
		{
			yield return Yield.WaitSeconds(0.5f);
			MonoBehaviour.print(rightHand.gameObject.name);
			MonoBehaviour.print(leftHand.gameObject.name);
		}
		while (!rightHand.InputDevice.inputDeviceInit && !leftHand.InputDevice.inputDeviceInit)
		{
			yield return Yield.WaitSeconds(0.5f);
		}
		if (PreferenceManager.instance.GetInt(PlayerPreferences.PRIMARY_HAND.ToString()) == 1)
		{
			primaryHand = rightHand;
			secondaryHand = leftHand;
		}
		else
		{
			primaryHand = leftHand;
			secondaryHand = rightHand;
		}
		if (GameController.instance.player.CurrentIntegrationType == NVRSDKIntegrations.Oculus)
		{
			saveButton = NVRButtons.X;
			loadButton = NVRButtons.B;
			pickupPrimary = NVRButtons.Trigger;
			pickupSecondary = NVRButtons.Trigger;
			menuButton = NVRButtons.Y;
			teleportButton = NVRButtons.A;
			crouchButton = NVRButtons.A;
			forwardButton = NVRButtons.DPad_Up;
			backwardButton = NVRButtons.DPad_Down;
			leftButton = NVRButtons.DPad_Left;
			rightButton = NVRButtons.DPad_Right;
			profileButton = NVRButtons.B;
			rotateRight = NVRButtons.DPad_Right;
			rotateLeft = NVRButtons.DPad_Left;
			moveAxisButton = NVRButtons.Touchpad;
			rotateMenuLeft = NVRButtons.DPad_Left;
			rotateMenuRight = NVRButtons.DPad_Right;
			interactButton = NVRButtons.Touchpad;
			triggerPrimary = NVRButtons.Trigger;
			triggerSecondary = NVRButtons.Trigger;
			ChangeInteractButton();
		}
		else if (GameController.instance.player.CurrentIntegrationType == NVRSDKIntegrations.OculusQuest)
		{
			saveButton = NVRButtons.X;
			loadButton = NVRButtons.B;
			pickupPrimary = NVRButtons.Grip;
			pickupSecondary = NVRButtons.Grip;
			menuButton = NVRButtons.Y;
			teleportButton = NVRButtons.A;
			crouchButton = NVRButtons.A;
			forwardButton = NVRButtons.DPad_Up;
			backwardButton = NVRButtons.DPad_Down;
			leftButton = NVRButtons.DPad_Left;
			rightButton = NVRButtons.DPad_Right;
			profileButton = NVRButtons.B;
			rotateRight = NVRButtons.DPad_Right;
			rotateLeft = NVRButtons.DPad_Left;
			moveAxisButton = NVRButtons.Touchpad;
			rotateMenuLeft = NVRButtons.DPad_Left;
			rotateMenuRight = NVRButtons.DPad_Right;
			interactButton = NVRButtons.Touchpad;
			triggerPrimary = NVRButtons.Trigger;
			triggerSecondary = NVRButtons.Trigger;
			ChangeInteractButton();
		}
		else if (GameController.instance.player.CurrentIntegrationType == NVRSDKIntegrations.SteamVR)
		{
			if (XRDevice.model.IndexOf("oculus", StringComparison.CurrentCultureIgnoreCase) != -1)
			{
				saveButton = NVRButtons.X;
				loadButton = NVRButtons.B;
				pickupPrimary = NVRButtons.Trigger;
				pickupSecondary = NVRButtons.Trigger;
				menuButton = NVRButtons.Y;
				teleportButton = NVRButtons.X;
				crouchButton = NVRButtons.A;
				forwardButton = NVRButtons.DPad_Up;
				backwardButton = NVRButtons.DPad_Down;
				leftButton = NVRButtons.DPad_Left;
				rightButton = NVRButtons.DPad_Right;
				profileButton = NVRButtons.B;
				rotateRight = NVRButtons.Touchpad;
				rotateLeft = NVRButtons.Touchpad;
				moveAxisButton = NVRButtons.Touchpad;
				rotateMenuLeft = NVRButtons.Touchpad;
				rotateMenuRight = NVRButtons.Touchpad;
				interactButton = NVRButtons.Touchpad;
				triggerPrimary = NVRButtons.Trigger;
				triggerSecondary = NVRButtons.Trigger;
				ChangeInteractButton();
			}
			else
			{
				saveButton = NVRButtons.Y;
				loadButton = NVRButtons.X;
				pickupPrimary = NVRButtons.Trigger;
				pickupSecondary = NVRButtons.Trigger;
				menuButton = NVRButtons.ApplicationMenu;
				teleportButton = NVRButtons.Touchpad;
				crouchButton = NVRButtons.Touchpad;
				forwardButton = NVRButtons.Touchpad;
				backwardButton = NVRButtons.Touchpad;
				leftButton = NVRButtons.Touchpad;
				rightButton = NVRButtons.Touchpad;
				profileButton = NVRButtons.System;
				rotateRight = NVRButtons.Touchpad;
				rotateLeft = NVRButtons.Touchpad;
				moveAxisButton = NVRButtons.Touchpad;
				rotateMenuLeft = NVRButtons.Touchpad;
				rotateMenuRight = NVRButtons.Touchpad;
				interactButton = NVRButtons.Touchpad;
				triggerPrimary = NVRButtons.Trigger;
				triggerSecondary = NVRButtons.Trigger;
				ChangeInteractButton();
			}
		}
		else if (GameController.instance.player.CurrentIntegrationType == NVRSDKIntegrations.PSVR)
		{
			if (usingDS4Controller)
			{
				saveButton = NVRButtons.X;
				loadButton = NVRButtons.B;
				pickupPrimary = NVRButtons.TriggerRight;
				pickupSecondary = NVRButtons.TriggerLeft;
				menuButton = NVRButtons.Y;
				teleportButton = NVRButtons.DPad_Down;
				crouchButton = NVRButtons.B;
				forwardButton = NVRButtons.X;
				backwardButton = NVRButtons.A;
				leftButton = NVRButtons.A;
				rightButton = NVRButtons.B;
				profileButton = NVRButtons.Y;
				rotateRight = NVRButtons.StickRight;
				rotateLeft = NVRButtons.StickRight;
				continuePrimary = NVRButtons.A;
				continueSecondary = NVRButtons.A;
				calibratePrimary = NVRButtons.Trigger;
				calibrateSecondary = NVRButtons.Trigger;
				calibrateDS4 = NVRButtons.A;
				moveAxisButton = NVRButtons.StickLeft;
				rotateMenuLeft = NVRButtons.StickLeft;
				rotateMenuRight = NVRButtons.StickLeft;
				interactButton = NVRButtons.StickPressRight;
				triggerPrimary = NVRButtons.TriggerRight;
				triggerSecondary = NVRButtons.TriggerLeft;
			}
			else
			{
				saveButton = NVRButtons.X;
				loadButton = NVRButtons.B;
				pickupPrimary = NVRButtons.Trigger;
				pickupSecondary = NVRButtons.Trigger;
				menuButton = NVRButtons.Y;
				teleportButton = NVRButtons.A;
				crouchButton = NVRButtons.B;
				forwardButton = NVRButtons.X;
				backwardButton = NVRButtons.A;
				leftButton = NVRButtons.A;
				rightButton = NVRButtons.B;
				profileButton = NVRButtons.Y;
				rotateRight = NVRButtons.Y;
				rotateLeft = NVRButtons.X;
				continuePrimary = NVRButtons.A;
				continueSecondary = NVRButtons.A;
				calibratePrimary = NVRButtons.Trigger;
				calibrateSecondary = NVRButtons.Trigger;
				calibrateDS4 = NVRButtons.A;
				moveAxisButton = NVRButtons.StickLeft;
				rotateMenuLeft = NVRButtons.A;
				rotateMenuRight = NVRButtons.B;
				interactButton = NVRButtons.StickPress;
				triggerPrimary = NVRButtons.Trigger;
				triggerSecondary = NVRButtons.Trigger;
			}
		}
		else if (GameController.instance.player.CurrentIntegrationType == NVRSDKIntegrations.Pico)
		{
			saveButton = NVRButtons.X;
			loadButton = NVRButtons.B;
			pickupPrimary = NVRButtons.Grip;
			pickupSecondary = NVRButtons.Grip;
			menuButton = NVRButtons.Y;
			teleportButton = NVRButtons.A;
			crouchButton = NVRButtons.A;
			forwardButton = NVRButtons.DPad_Up;
			backwardButton = NVRButtons.DPad_Down;
			leftButton = NVRButtons.DPad_Left;
			rightButton = NVRButtons.DPad_Right;
			profileButton = NVRButtons.B;
			rotateRight = NVRButtons.DPad_Right;
			rotateLeft = NVRButtons.DPad_Left;
			moveAxisButton = NVRButtons.Touchpad;
			rotateMenuLeft = NVRButtons.DPad_Left;
			rotateMenuRight = NVRButtons.DPad_Right;
			interactButton = NVRButtons.Touchpad;
			triggerPrimary = NVRButtons.Trigger;
			triggerSecondary = NVRButtons.Trigger;
			ChangeInteractButton();
		}
		isInitilised = true;
	}

	private void Update()
	{
	}

	public void SetHands()
	{
		if (rightHand.IsPrimary)
		{
			primaryHand = rightHand;
			secondaryHand = leftHand;
		}
		else
		{
			primaryHand = leftHand;
			secondaryHand = rightHand;
		}
	}

	public void ChangeInteractButton()
	{
		if (PreferenceManager.instance.GetInt(PlayerPreferences.INTERACT_BUTTON.ToString()) == 1)
		{
			if (primaryHand.Player.CurrentIntegrationType == NVRSDKIntegrations.SteamVR)
			{
				pickupPrimary = NVRButtons.Grip;
				pickupSecondary = NVRButtons.Grip;
			}
			else
			{
				pickupPrimary = NVRButtons.Grip;
				pickupSecondary = NVRButtons.Grip;
			}
		}
		else if (primaryHand.Player.CurrentIntegrationType == NVRSDKIntegrations.SteamVR)
		{
			pickupPrimary = NVRButtons.Trigger;
			pickupSecondary = NVRButtons.Trigger;
		}
		else
		{
			pickupPrimary = NVRButtons.Trigger;
			pickupSecondary = NVRButtons.Trigger;
		}
	}
}
public class EventManager : MonoBehaviour
{
	public enum AvailableEvents
	{
		SwitchedScenes,
		StartedLoading,
		IntroComplete,
		IAPSuccess,
		IAPSteamSuccess,
		ArtifactUnlocked,
		ChapterPurchased,
		BlockingLoad,
		ExitLevelToPrecint,
		ExitGame,
		RestartScene,
		BrokenObject,
		ChapelChapterCompleted,
		CellChapterCompleted,
		NurseryChapterCompleted,
		MorgueChapterCompleted,
		TombChapterCompleted,
		SmashedGlassOffFatherBell,
		ResetProgress,
		LeavingScene
	}

	private Dictionary<string, UnityEvent> eventDictionary;

	private static EventManager eventManager;

	public static EventManager instance
	{
		get
		{
			if (!eventManager)
			{
				eventManager = UnityEngine.Object.FindObjectOfType(typeof(EventManager)) as EventManager;
				if ((bool)eventManager)
				{
					eventManager.Init();
				}
			}
			return eventManager;
		}
	}

	private void Init()
	{
		if (eventDictionary == null)
		{
			eventDictionary = new Dictionary<string, UnityEvent>();
		}
	}

	public static void StartListening(string eventName, UnityAction listener)
	{
		UnityEvent value = null;
		if (instance.eventDictionary.TryGetValue(eventName, out value))
		{
			value.AddListener(listener);
			return;
		}
		value = new UnityEvent();
		value.AddListener(listener);
		instance.eventDictionary.Add(eventName, value);
	}

	public static void StopListening(string eventName, UnityAction listener)
	{
		if (!(eventManager == null))
		{
			UnityEvent value = null;
			if (instance.eventDictionary.TryGetValue(eventName, out value))
			{
				value.RemoveListener(listener);
			}
		}
	}

	public static void TriggerEvent(string eventName)
	{
		UnityEvent value = null;
		if (instance.eventDictionary.TryGetValue(eventName, out value))
		{
			value.Invoke();
		}
	}
}
public class FloatingPointAudioManager : MonoBehaviour
{
	public enum FloatingPointAudioPlayType
	{
		PLAY_ONE,
		PLAY_ALL,
		LOOP_ONE
	}

	public enum FloatingPointAudioFadeType
	{
		NONE,
		FADE_IN,
		FADE_OUT,
		FADE_BOTH
	}

	[Serializable]
	public struct FloatingPointAudio
	{
		public Transform transform;

		public AudioClip audioClip;

		public FloatingPointAudioFadeType fadeType;

		public float volume;

		public float fadeInTime;

		public float fadeOutTime;

		public Transform[] movePoints;

		public bool HasPath()
		{
			if (movePoints != null && movePoints.Length != 0)
			{
				return true;
			}
			return false;
		}
	}

	public virtual void Play(AudioScript audioScript, FloatingPointAudioPlayType playType, FloatingPointAudio[] floatingPointAudioArray, int clipPosition = 0, float baseVolume = 0.8f, float delay = 0f)
	{
		switch (playType)
		{
		case FloatingPointAudioPlayType.PLAY_ONE:
		{
			FloatingPointAudio floatingPointAudio2 = floatingPointAudioArray[clipPosition];
			PlayOne(audioScript, floatingPointAudio2, baseVolume, delay);
			break;
		}
		case FloatingPointAudioPlayType.PLAY_ALL:
			PlayAll(audioScript, floatingPointAudioArray, baseVolume, delay);
			break;
		case FloatingPointAudioPlayType.LOOP_ONE:
		{
			FloatingPointAudio floatingPointAudio = floatingPointAudioArray[clipPosition];
			PlayLoopOne(audioScript, floatingPointAudio, baseVolume, delay);
			break;
		}
		}
	}

	private void PlayOne(AudioScript audioScript, FloatingPointAudio floatingPointAudio, float baseVolume, float delay)
	{
		StartCoroutine(PlayOneRoutine(audioScript, floatingPointAudio, baseVolume, delay));
	}

	private IEnumerator PlayOneRoutine(AudioScript audioScript, FloatingPointAudio floatingPointAudio, float baseVolume, float delay)
	{
		if (delay > 0f)
		{
			yield return Yield.WaitSeconds(delay);
		}
		audioScript.gameObject.transform.position = floatingPointAudio.transform.position;
		audioScript.gameObject.transform.rotation = floatingPointAudio.transform.rotation;
		StartCoroutine(FollowPath(audioScript, floatingPointAudio));
		switch (floatingPointAudio.fadeType)
		{
		case FloatingPointAudioFadeType.NONE:
			if (floatingPointAudio.volume > 0f)
			{
				audioScript.Play(floatingPointAudio.audioClip, floatingPointAudio.volume);
			}
			else
			{
				audioScript.Play(floatingPointAudio.audioClip, baseVolume);
			}
			break;
		case FloatingPointAudioFadeType.FADE_IN:
			if (floatingPointAudio.volume > 0f)
			{
				audioScript.FadeIn(floatingPointAudio.audioClip, floatingPointAudio.volume, floatingPointAudio.fadeInTime, loop: false);
			}
			else
			{
				audioScript.FadeIn(floatingPointAudio.audioClip, baseVolume, floatingPointAudio.fadeInTime, loop: false);
			}
			break;
		case FloatingPointAudioFadeType.FADE_OUT:
			if (floatingPointAudio.volume > 0f)
			{
				audioScript.Play(floatingPointAudio.audioClip, floatingPointAudio.volume);
			}
			else
			{
				audioScript.Play(floatingPointAudio.audioClip, baseVolume);
			}
			yield return Yield.WaitSeconds(floatingPointAudio.audioClip.length - floatingPointAudio.fadeOutTime);
			audioScript.FadeOut(floatingPointAudio.fadeOutTime);
			break;
		case FloatingPointAudioFadeType.FADE_BOTH:
			if (floatingPointAudio.volume > 0f)
			{
				audioScript.FadeIn(floatingPointAudio.audioClip, floatingPointAudio.volume, floatingPointAudio.fadeInTime, loop: false);
			}
			else
			{
				audioScript.FadeIn(floatingPointAudio.audioClip, baseVolume, floatingPointAudio.fadeInTime, loop: false);
			}
			yield return Yield.WaitSeconds(floatingPointAudio.audioClip.length - floatingPointAudio.fadeOutTime);
			audioScript.FadeOut(floatingPointAudio.fadeOutTime);
			break;
		}
	}

	private void PlayAll(AudioScript audioScript, FloatingPointAudio[] floatingPointAudioArray, float baseVolume, float delay)
	{
		StartCoroutine(PlayAllRoutine(audioScript, floatingPointAudioArray, baseVolume, delay));
	}

	private IEnumerator PlayAllRoutine(AudioScript audioScript, FloatingPointAudio[] floatingPointAudioArray, float baseVolume, float delay)
	{
		if (delay > 0f)
		{
			yield return Yield.WaitSeconds(delay);
		}
		for (int i = 0; i < floatingPointAudioArray.Length; i++)
		{
			FloatingPointAudio floatingPointAudio = floatingPointAudioArray[i];
			audioScript.gameObject.transform.position = floatingPointAudio.transform.position;
			audioScript.gameObject.transform.rotation = floatingPointAudio.transform.rotation;
			StartCoroutine(FollowPath(audioScript, floatingPointAudio));
			if (floatingPointAudio.volume > 0f)
			{
				audioScript.Play(floatingPointAudio.audioClip, floatingPointAudio.volume);
			}
			else
			{
				audioScript.Play(floatingPointAudio.audioClip, baseVolume);
			}
			yield return Yield.WaitSeconds(floatingPointAudio.audioClip.length);
		}
	}

	private void PlayLoopOne(AudioScript audioScript, FloatingPointAudio floatingPointAudio, float baseVolume, float delay)
	{
		StartCoroutine(PlayLoopOneRoutine(audioScript, floatingPointAudio, baseVolume, delay));
	}

	private IEnumerator PlayLoopOneRoutine(AudioScript audioScript, FloatingPointAudio floatingPointAudio, float baseVolume, float delay)
	{
		if (delay > 0f)
		{
			yield return Yield.WaitSeconds(delay);
		}
		audioScript.gameObject.transform.position = floatingPointAudio.transform.position;
		audioScript.gameObject.transform.rotation = floatingPointAudio.transform.rotation;
		StartCoroutine(FollowPath(audioScript, floatingPointAudio));
		if (floatingPointAudio.volume > 0f)
		{
			audioScript.PlayLoop(floatingPointAudio.audioClip, floatingPointAudio.volume);
		}
		else
		{
			audioScript.PlayLoop(floatingPointAudio.audioClip, baseVolume);
		}
	}

	private IEnumerator FollowPath(AudioScript audioScript, FloatingPointAudio floatingPointAudio)
	{
		if (floatingPointAudio.HasPath())
		{
			float totalDistance = Vector3.Distance(floatingPointAudio.transform.position, floatingPointAudio.movePoints[0].position);
			for (int j = 1; j < floatingPointAudio.movePoints.Length; j++)
			{
				totalDistance += Vector3.Distance(floatingPointAudio.movePoints[j - 1].position, floatingPointAudio.movePoints[j].position);
			}
			int i = 0;
			while (i < floatingPointAudio.movePoints.Length)
			{
				float num = ((i != 0) ? Vector3.Distance(floatingPointAudio.movePoints[i - 1].position, floatingPointAudio.movePoints[i].position) : Vector3.Distance(floatingPointAudio.transform.position, floatingPointAudio.movePoints[0].position));
				float time = floatingPointAudio.audioClip.length * num / totalDistance;
				LeanTween.move(audioScript.gameObject, floatingPointAudio.movePoints[i], time);
				yield return Yield.WaitSeconds(time);
				int num2 = i + 1;
				i = num2;
			}
		}
	}
}
public class HandPointer : MonoBehaviour
{
	public float distanceToObject = 5f;

	public Transform fingerPos;

	public Animator anim;

	private LineRenderer lr;

	private Button currentButton;

	private Collider currentCollider;

	private NVRHand parentHand;

	private int pointerInteractableTriggerLayer;

	private int rayCastLayerMask;

	private bool pointing;

	private bool active;

	private float currentDistanceCheck = 5f;

	private void OnEnable()
	{
		SceneManager.sceneLoaded += OnLevelFinishedLoading;
	}

	private void OnDisable()
	{
		SceneManager.sceneLoaded -= OnLevelFinishedLoading;
	}

	private void Start()
	{
		lr = GetComponent<LineRenderer>();
		anim = GetComponentInChildren<Animator>();
		currentButton = null;
		rayCastLayerMask = 1 << LayerMask.NameToLayer("PointerInteractableTrigger");
		currentCollider = null;
		parentHand = base.gameObject.GetComponent<NVRHand>();
		lr.enabled = true;
		lr.SetPosition(0, fingerPos.position);
		lr.SetPosition(1, fingerPos.position);
	}

	private void Update()
	{
		if (!active)
		{
			return;
		}
		if (anim == null)
		{
			GetComponentInChildren<Animator>();
		}
		if (parentHand.handAnimator.GetBool("FistBool") || parentHand.IsInteracting)
		{
			if (pointing)
			{
				lr.enabled = false;
			}
			return;
		}
		lr.SetPosition(0, fingerPos.position);
		if (Physics.Raycast(fingerPos.position, fingerPos.forward, out var hitInfo, distanceToObject, rayCastLayerMask, QueryTriggerInteraction.Ignore))
		{
			if (!pointing)
			{
				HandPointerDistanceCheck componentInParent = hitInfo.collider.gameObject.GetComponentInParent<HandPointerDistanceCheck>();
				if ((bool)componentInParent)
				{
					currentDistanceCheck = componentInParent.distanceForUse;
					if (hitInfo.distance <= componentInParent.distanceForUse)
					{
						pointing = true;
						lr.enabled = true;
						parentHand.SetAnimation("PointBool");
					}
					else
					{
						pointing = false;
						lr.SetPosition(1, fingerPos.position);
						parentHand.SetAnimation("IdleBool");
					}
				}
				else
				{
					pointing = true;
					lr.enabled = true;
					parentHand.SetAnimation("PointBool");
				}
			}
			if (!pointing)
			{
				return;
			}
			if (hitInfo.distance > currentDistanceCheck)
			{
				currentDistanceCheck = 5f;
				pointing = false;
				lr.SetPosition(1, fingerPos.position);
				parentHand.SetAnimation("IdleBool");
				return;
			}
			lr.SetPosition(1, hitInfo.point);
			if (hitInfo.collider.gameObject.GetComponent<NVRInteractableItem>() != null)
			{
				Collider collider = hitInfo.collider;
				if (parentHand != null)
				{
					if (currentCollider != null)
					{
						if (collider == currentCollider)
						{
							parentHand.OnPointerStay(currentCollider);
						}
						else
						{
							parentHand.OnPointerExit(currentCollider);
							currentCollider = collider;
							parentHand.OnPointerEnter(currentCollider);
						}
					}
					else
					{
						currentCollider = collider;
						parentHand.OnPointerEnter(currentCollider);
					}
				}
			}
			else if (currentCollider != null)
			{
				parentHand.OnPointerExit(currentCollider);
				currentCollider = null;
			}
			Button component = hitInfo.collider.GetComponent<Button>();
			if (component != null)
			{
				UnityEngine.UI.Image component2;
				if (currentButton != null)
				{
					if (currentButton != component)
					{
						component2 = currentButton.GetComponent<UnityEngine.UI.Image>();
						if (component2 != null)
						{
							component2.color = currentButton.colors.normalColor;
						}
						currentButton = component;
					}
				}
				else
				{
					currentButton = component;
				}
				component2 = currentButton.GetComponent<UnityEngine.UI.Image>();
				if (component2 != null)
				{
					component2.color = currentButton.colors.highlightedColor;
				}
				if (ControlsManager.instance.primaryTriggerButtonDown)
				{
					currentButton.onClick.Invoke();
				}
			}
			else if (currentButton != null)
			{
				UnityEngine.UI.Image component2 = currentButton.GetComponent<UnityEngine.UI.Image>();
				if (component2 != null)
				{
					component2.color = currentButton.colors.normalColor;
				}
				currentButton = null;
			}
			return;
		}
		if (pointing)
		{
			pointing = false;
			parentHand.SetAnimation("IdleBool");
		}
		if (lr.enabled)
		{
			if (currentCollider != null)
			{
				parentHand.OnPointerExit(currentCollider);
				currentCollider = null;
			}
			if (currentButton != null)
			{
				UnityEngine.UI.Image component2 = currentButton.GetComponent<UnityEngine.UI.Image>();
				if (component2 != null)
				{
					component2.color = currentButton.colors.normalColor;
				}
				currentButton = null;
			}
		}
		lr.SetPosition(1, fingerPos.position);
		distanceToObject = 5f;
		currentDistanceCheck = 5f;
	}

	public void SwapHands(bool isPrimary)
	{
		if (isPrimary)
		{
			active = true;
		}
		else
		{
			active = false;
		}
	}

	public void ToggleLR()
	{
	}

	private void OnLevelFinishedLoading(Scene scene, LoadSceneMode mode)
	{
		switch (GameController.instance.gameState)
		{
		case GameController.GameState.SPLASH:
			if (parentHand != null)
			{
				_ = parentHand.IsLeft;
			}
			break;
		case GameController.GameState.PROFILE:
		case GameController.GameState.CALLIBRATION:
		case GameController.GameState.ONBOARDING:
		case GameController.GameState.TITLES:
		case GameController.GameState.MENU:
		case GameController.GameState.GAME:
		case GameController.GameState.PAUSED:
			break;
		}
	}
}
public class InteractiveDoor : NVRInteractableItem
{
	private enum HandleType
	{
		LEVER,
		KNOB,
		STATIC
	}

	private enum Axis
	{
		X,
		Y,
		Z
	}

	public bool doorLocked;

	[SerializeField]
	private AudioClip openClip;

	[SerializeField]
	private AudioClip lockedClip;

	[Range(0f, 1f)]
	[SerializeField]
	private float openVolume = 0.7f;

	[SerializeField]
	private HandleType typeOfHandle = HandleType.STATIC;

	[SerializeField]
	private Axis rotateAxis = Axis.Z;

	[SerializeField]
	private float animTime = 0.3f;

	[SerializeField]
	private float rotateBy = -45f;

	[SerializeField]
	private float lockedAnimTime = 0.5f;

	[SerializeField]
	private float lockedRotateBy = -10f;

	private AudioScript audioScript;

	private Transform originalTransform;

	private RigidbodyConstraints storedConstraints;

	[SerializeField]
	private Room room1;

	[SerializeField]
	private Room[] additionalRoom1;

	[SerializeField]
	public Transform room1StartPos;

	[SerializeField]
	private Room room2;

	[SerializeField]
	private Room[] additionalRoom2;

	[SerializeField]
	public Transform room2StartPos;

	private Transform originalDoorTransform;

	public bool doorOpen;

	private float doorDistThreshold = 0.025f;

	private bool switchingRooms;

	[SerializeField]
	private DoorSfx doorSfx;

	[SerializeField]
	private SlideAudio doorSlideSfx;

	[SerializeField]
	private bool teleportPlayer;

	[SerializeField]
	private bool playSlamSfxAfterTeleport = true;

	[SerializeField]
	private bool lockDoorAfterUsed;

	[SerializeField]
	private GameObject[] objectsToDisableAfterTeleport;

	private new void Start()
	{
		base.gameObject.tag = "Fixture";
		hideHands = true;
		base.Start();
		if ((bool)openClip || (bool)lockedClip)
		{
			if ((bool)base.gameObject.GetComponent<AudioScript>())
			{
				audioScript = base.gameObject.GetComponent<AudioScript>();
			}
			else
			{
				audioScript = base.gameObject.AddComponent<AudioScript>();
			}
		}
		if (doorLocked)
		{
			LockDoor();
		}
		else
		{
			DropDistance = 1f;
		}
		originalTransform = base.gameObject.transform;
		originalDoorTransform = base.gameObject.transform.parent.transform;
		ReparentToRoomOnDetach = false;
	}

	public void PlayClip(AudioClip clip, float vol)
	{
		audioScript.Play(clip, vol);
	}

	protected override void FixedUpdate()
	{
		if (doorLocked)
		{
			return;
		}
		base.FixedUpdate();
		if (Vector3.Distance(base.transform.position, origionalPosition) > doorDistThreshold)
		{
			if (!doorOpen)
			{
				doorOpen = true;
				UpdateOOBs();
			}
		}
		else if (doorOpen)
		{
			doorOpen = false;
			UpdateOOBs();
		}
	}

	public void UpdateOOBs()
	{
		if ((bool)room1 && (bool)room2)
		{
			if (doorOpen)
			{
				room1.UpdateColliders(enabled: false);
				room2.UpdateColliders(enabled: false);
			}
			else if (room1.playerInRoom)
			{
				room1.UpdateColliders(enabled: false);
				room2.UpdateColliders(enabled: true);
				room2.playerInRoom = false;
				GameController.instance.currentRoom = room1;
			}
			else if (room2.playerInRoom)
			{
				room1.UpdateColliders(enabled: true);
				room1.playerInRoom = false;
				room2.UpdateColliders(enabled: false);
				GameController.instance.currentRoom = room2;
			}
			else
			{
				room1.UpdateColliders(enabled: false);
				room2.UpdateColliders(enabled: false);
			}
		}
	}

	public void ManuallyUpdateOOBs()
	{
		if ((bool)room1 && (bool)room2)
		{
			if (room1.playerInRoom)
			{
				room1.UpdateColliders(enabled: false);
				room2.UpdateColliders(enabled: true);
				room2.playerInRoom = false;
				GameController.instance.currentRoom = room1;
			}
			else if (room2.playerInRoom)
			{
				room1.UpdateColliders(enabled: true);
				room1.playerInRoom = false;
				room2.UpdateColliders(enabled: false);
				GameController.instance.currentRoom = room2;
			}
			else
			{
				room1.UpdateColliders(enabled: false);
				room2.UpdateColliders(enabled: false);
			}
		}
	}

	public override void BeginInteraction(NVRHand hand, bool runBeginInteractionCallback = true)
	{
		if (teleportPlayer)
		{
			base.BeginInteraction(hand, runBeginInteractionCallback: false);
		}
		else
		{
			base.BeginInteraction(hand, runBeginInteractionCallback: true);
		}
		if (!switchingRooms)
		{
			if (doorLocked)
			{
				StartCoroutine(LockedHandle());
			}
			else
			{
				StartCoroutine(OpenHandle());
			}
		}
	}

	public override void EndInteraction(NVRHand hand)
	{
		base.EndInteraction(hand);
		if (!hand.CurrentlyHoveringOver.ContainsKey(this))
		{
			hand.SetAnimation("IdleBool");
		}
		if (!doorLocked && !teleportPlayer)
		{
			StartCoroutine(CloseHandle());
		}
		else
		{
			Rigidbody.isKinematic = true;
		}
	}

	public IEnumerator OpenHandle()
	{
		if (teleportPlayer)
		{
			switchingRooms = true;
		}
		if ((bool)openClip)
		{
			audioScript.PlayOne(openClip, openVolume);
		}
		NVRPlayer player = GameController.instance.player;
		if (teleportPlayer)
		{
			player.movement.DisableEverything();
		}
		if (typeOfHandle != HandleType.STATIC)
		{
			if (rotateAxis == Axis.X)
			{
				LeanTween.rotateX(base.gameObject, rotateBy, animTime).setEaseInOutSine();
			}
			else if (rotateAxis == Axis.Y)
			{
				LeanTween.rotateY(base.gameObject, rotateBy, animTime).setEaseInOutSine();
			}
			else if (rotateAxis == Axis.Z)
			{
				LeanTween.rotateZ(base.gameObject, rotateBy, animTime).setEaseInOutSine();
			}
			yield return Yield.WaitSeconds(animTime);
		}
		if (teleportPlayer)
		{
			player.screenFX.Fade(UnityEngine.Color.black, 0.5f);
			GameController.instance.boundDetection.SwitchOffOOB();
			yield return Yield.WaitSeconds(0.5f);
			if (room1.playerInRoom)
			{
				SetRooms1Active(active: false);
				SetRooms2Active(active: true);
				player.movement.ForceTeleport(room2StartPos.position);
			}
			else
			{
				SetRooms1Active(active: true);
				SetRooms2Active(active: false);
				player.movement.ForceTeleport(room1StartPos.position);
			}
			if (OnBeginInteraction != null)
			{
				OnBeginInteraction.Invoke();
			}
			if ((bool)doorSfx)
			{
				doorSfx.PlayDoorCreakWithFade(0.75f);
			}
			else if ((bool)doorSlideSfx)
			{
				doorSlideSfx.PlaySlideAudioWithFade(0.75f);
			}
			StartCoroutine(CloseHandle());
			yield return Yield.WaitSeconds(1f);
			ManuallyUpdateOOBs();
			player.movement.boundsDetection.TurnOffOOB(fadeScreen: false, enableMovement: false);
			player.screenFX.Fade(UnityEngine.Color.clear, 2f);
			player.movement.EnableEverythingDelayed(2f);
			if (lockDoorAfterUsed)
			{
				doorLocked = true;
			}
			yield return Yield.WaitSeconds(1.25f);
			if (playSlamSfxAfterTeleport)
			{
				if ((bool)doorSfx)
				{
					doorSfx.PlayDoorSlam(1f);
					yield return Yield.WaitSeconds(doorSfx.sfxSlamShut.length);
				}
				else if ((bool)doorSlideSfx && (bool)lockedClip)
				{
					audioScript.Play(lockedClip);
					yield return Yield.WaitSeconds(lockedClip.length);
				}
			}
			GameController.instance.boundDetection.SwitchOnOOB();
		}
		switchingRooms = false;
		GameObject[] array = objectsToDisableAfterTeleport;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(value: false);
		}
	}

	public void SetRooms1Active(bool active)
	{
		if ((bool)room1.associatedParentGameObject)
		{
			room1.associatedParentGameObject.SetActive(active);
		}
		Room[] array = additionalRoom1;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].associatedParentGameObject.SetActive(active);
		}
		GameController.instance.currentRoom = room1;
	}

	public void SetRooms2Active(bool active)
	{
		if ((bool)room2.associatedParentGameObject)
		{
			room2.associatedParentGameObject.SetActive(active);
		}
		Room[] array = additionalRoom2;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].associatedParentGameObject.SetActive(active);
		}
		GameController.instance.currentRoom = room2;
	}

	private IEnumerator CloseHandle()
	{
		if (typeOfHandle != HandleType.STATIC)
		{
			if (rotateAxis == Axis.X)
			{
				LeanTween.rotateX(base.gameObject, 0f, animTime).setEaseInOutSine();
			}
			if (rotateAxis == Axis.Y)
			{
				LeanTween.rotateY(base.gameObject, 0f, animTime).setEaseInOutSine();
			}
			if (rotateAxis == Axis.Z)
			{
				LeanTween.rotateZ(base.gameObject, 0f, animTime).setEaseInOutSine();
			}
			yield return Yield.WaitSeconds(animTime);
		}
	}

	private IEnumerator LockedHandle()
	{
		if ((bool)lockedClip)
		{
			audioScript.PlayOne(lockedClip, 0.7f);
		}
		if (typeOfHandle != HandleType.STATIC)
		{
			if (rotateAxis == Axis.X)
			{
				LeanTween.rotateX(base.gameObject, lockedRotateBy, lockedAnimTime * 0.5f).setEaseInOutSine();
			}
			if (rotateAxis == Axis.Y)
			{
				LeanTween.rotateY(base.gameObject, lockedRotateBy, lockedAnimTime * 0.5f).setEaseInOutSine();
			}
			if (rotateAxis == Axis.Z)
			{
				LeanTween.rotateZ(base.gameObject, lockedRotateBy, lockedAnimTime * 0.5f).setEaseInOutSine();
			}
			yield return Yield.WaitSeconds(lockedAnimTime * 0.5f);
			if (rotateAxis == Axis.X)
			{
				LeanTween.rotateX(base.gameObject, 0f, lockedAnimTime * 0.5f).setEaseInOutSine();
			}
			if (rotateAxis == Axis.Y)
			{
				LeanTween.rotateY(base.gameObject, 0f, lockedAnimTime * 0.5f).setEaseInOutSine();
			}
			if (rotateAxis == Axis.Z)
			{
				LeanTween.rotateZ(base.gameObject, 0f, lockedAnimTime * 0.5f).setEaseInOutSine();
			}
			yield return Yield.WaitSeconds(lockedAnimTime * 0.5f);
		}
	}

	public void UnlockDoor()
	{
		if (!teleportPlayer)
		{
			Rigidbody.isKinematic = false;
		}
		doorLocked = false;
		DropDistance = 1f;
	}

	public void LockDoor()
	{
		doorLocked = true;
		Rigidbody.isKinematic = true;
		DropDistance = 0.1f;
	}

	public void CloseDoor(float yRot = 0f, float time = 1f, bool lockAfter = true, bool resetPosition = false)
	{
		StartCoroutine(TweenDoorClosed(yRot, time, lockAfter, resetPosition));
	}

	private IEnumerator TweenDoorClosed(float yRot, float time, bool lockAfter, bool resetPosition)
	{
		LeanTween.rotateLocal(base.gameObject.transform.parent.gameObject, new Vector3(0f, yRot, 0f), time).setEaseInQuint();
		yield return Yield.WaitSeconds(time);
		if (lockAfter)
		{
			LockDoor();
		}
		if (resetPosition)
		{
			base.gameObject.transform.parent.gameObject.transform.localPosition = originalDoorTransform.localPosition;
		}
	}

	public void OpenDoor(float yRot = 0f, float time = 1f)
	{
		StartCoroutine(TweenDoorOpen(yRot, time));
	}

	public void OpenDoorInstant(float yRot = 0f, float time = 1f)
	{
		LeanTween.rotateLocal(base.gameObject.transform.parent.gameObject, new Vector3(0f, yRot, 0f), time).setEaseInQuint();
	}

	private IEnumerator TweenDoorOpen(float yRot, float time)
	{
		LeanTween.rotateLocal(base.gameObject.transform.parent.gameObject, new Vector3(0f, yRot, 0f), time).setEaseInQuint();
		yield return Yield.WaitSeconds(time);
	}
}
public class InteractiveLeaver : NVRInteractableItem
{
	private enum Axis
	{
		X,
		Y,
		Z
	}

	[SerializeField]
	private Axis rotateAxis = Axis.Z;

	private AudioScript audioScript;

	private Transform originalTransform;

	private RigidbodyConstraints storedConstraints;

	public bool doorOpen;

	private new void Start()
	{
		hideHands = true;
		base.Start();
		originalTransform = base.gameObject.transform;
	}

	public override void BeginInteraction(NVRHand hand, bool runBeginInteractionCallback = true)
	{
		base.BeginInteraction(hand, runBeginInteractionCallback);
	}

	public override void EndInteraction(NVRHand hand)
	{
		base.EndInteraction(hand);
	}
}
public class Locomotion : MonoBehaviour
{
	public enum RotationFades
	{
		ON,
		OFF
	}

	public enum RotationSpeeds
	{
		SLOW,
		MEDIUM,
		FAST
	}

	public enum RotationOptions
	{
		THIRTY,
		FORTYFIVE,
		NINETY,
		FREE
	}

	public enum CrouchOptions
	{
		SNAP,
		SMOOTH
	}

	public enum MovementSpeeds
	{
		SLOW,
		MEDIUM,
		FAST
	}

	private NVRPlayer player;

	private GameObject playArea;

	private Renderer playAreaRender;

	public BoundDetection boundsDetection;

	public bool overrideMovementEnabled;

	public bool teleportEnabled;

	private bool hideWarningUI;

	public bool teleporterActive;

	public bool isTeleporting;

	private bool isRotating;

	private bool isCrouching;

	private bool crouchMovement;

	public bool rotationEnabled;

	public RotationOptions rotationOption = RotationOptions.NINETY;

	public RotationFades rotationFade;

	public RotationSpeeds rotationSpeed = RotationSpeeds.MEDIUM;

	private float[] rotationValues = new float[4] { 30f, 45f, 90f, 1f };

	private float[] rotationFadeValues = new float[4] { 0.05f, 0.07f, 0.15f, 0.01f };

	private float[] rotationSpeedValues = new float[3] { 0.2f, 0.4f, 1f };

	private ScreenFX screenFX;

	public bool freeMoveEnabled;

	public MovementSpeeds movementSpeed = MovementSpeeds.MEDIUM;

	private float[] playerSpeeds = new float[3] { 1f, 1.3f, 1.6f };

	public bool crouchEnabled;

	public CrouchOptions crouchOption;

	private float playerHeight;

	private float crouchHeight;

	private float currentSmoothCrouchOffset;

	private Vector2 swipePosition;

	private float swipeTime;

	private bool swipeRight;

	private bool swipeLeft;

	private bool seated;

	private float seatedHeight;

	private bool leaveUIOn;

	private float roomScale;

	private AudioClip teleportSound;

	private AudioClip[] footStepsWood;

	private AudioClip[] footStepsConcrete;

	private AudioClip[] footStepsCarpet;

	private AudioClip[] footStepsWoodPlank;

	private AudioClip[] footStepsHollowMetal;

	private AudioClip[] footstepsDirtSand;

	private AudioScript audioFootsteps;

	private bool footStepPlaying;

	private int audioIndex;

	private float volume = 0.15f;

	private GameObject lastHitFloor;

	private LayerMask rayMask;

	private bool menuOpen;

	private bool isInitialised;

	private Vector3 heightOffset = new Vector3(0f, 0.05f, 0f);

	private bool hittingPortal;

	public Vector3 CrouchHeight
	{
		get
		{
			if (crouchMovement)
			{
				if (isCrouching)
				{
					return new Vector3(0f, currentSmoothCrouchOffset, 0f);
				}
				return new Vector3(0f, crouchHeight, 0f) + new Vector3(0f, currentSmoothCrouchOffset, 0f);
			}
			if (isCrouching)
			{
				return new Vector3(0f, crouchHeight, 0f);
			}
			return Vector3.zero;
		}
	}

	private void Start()
	{
		StartCoroutine(StartRoutine());
	}

	private IEnumerator StartRoutine()
	{
		while (!SaveManager.instance.savedDataLoaded)
		{
			yield return null;
		}
		while (!GameController.instance.player)
		{
			yield return null;
		}
		EnableEverything();
		player = GameController.instance.player;
		boundsDetection = player.Head.GetComponentInChildren<BoundDetection>();
		screenFX = GetComponent<ScreenFX>();
		if (PreferenceManager.instance.GetInt(PlayerPreferences.HIDE_WARNING_UI.ToString()) == 1)
		{
			hideWarningUI = true;
		}
		else
		{
			hideWarningUI = false;
		}
		playerHeight = 1.66f;
		crouchHeight = playerHeight * -0.3f;
		seatedHeight = playerHeight * 0.2f;
		seated = false;
		if (seated)
		{
			player.gameObject.transform.position = new Vector3(player.gameObject.transform.position.x, player.gameObject.transform.position.y + seatedHeight, player.gameObject.transform.position.z) - heightOffset;
		}
		teleportSound = Resources.Load<AudioClip>("TeleportSound");
		footStepsWood = Resources.LoadAll<AudioClip>("Footsteps/Wood");
		footStepsConcrete = Resources.LoadAll<AudioClip>("Footsteps/Concrete");
		footStepsCarpet = Resources.LoadAll<AudioClip>("Footsteps/Carpet");
		footStepsWoodPlank = Resources.LoadAll<AudioClip>("Footsteps/WoodenPlank");
		footStepsHollowMetal = Resources.LoadAll<AudioClip>("Footsteps/MetalHollow");
		footstepsDirtSand = Resources.LoadAll<AudioClip>("Footsteps/DirtSand");
		audioFootsteps = base.gameObject.AddComponent<AudioScript>();
		audioFootsteps.is3D = false;
		rayMask = 7340032;
		EventManager.StartListening(EventManager.AvailableEvents.StartedLoading.ToString(), CancelTeleport);
		StartCoroutine(SetupPlatformVisuals());
	}

	private IEnumerator SetupPlatformVisuals()
	{
		if (player.CurrentIntegrationType == NVRSDKIntegrations.SteamVR)
		{
			if (GameController.instance.isUsingAnOculus())
			{
				playArea = player.locoVisual_PlayAreaRift;
				float timeoutCheck = 3f;
				RoomScaleOculus roomScaleScript = new RoomScaleOculus();
				while (!roomScaleScript.init && timeoutCheck > 0f)
				{
					roomScaleScript.CalcRoomScale();
					timeoutCheck -= 0.5f;
					yield return null;
				}
				roomScale = roomScaleScript.GetScale();
				if (!roomScaleScript.init)
				{
					roomScale = 1.5f;
				}
				playArea.transform.localScale = new Vector3(playArea.transform.localScale.x * roomScale, playArea.transform.localScale.y, playArea.transform.localScale.z * roomScale);
				player.locoVisual_PlayAreaQuest.SetActive(value: false);
				player.locoVisual_PlayAreaVive.SetActive(value: false);
				player.locoVisual_PlayAreaPSVR.SetActive(value: false);
				player.locoVisual_PlayAreaPico.SetActive(value: false);
			}
			else
			{
				playArea = player.locoVisual_PlayAreaVive;
				float timeoutCheck = 3f;
				RoomScaleVive roomScaleScript2 = new RoomScaleVive();
				while (!roomScaleScript2.init && timeoutCheck > 0f)
				{
					roomScaleScript2.CalcRoomScale();
					timeoutCheck -= 0.5f;
					yield return null;
				}
				roomScale = roomScaleScript2.GetScale();
				if (!roomScaleScript2.init)
				{
					roomScale = 1.5f;
				}
				playArea.transform.localScale = new Vector3(playArea.transform.localScale.x * roomScale, playArea.transform.localScale.y, playArea.transform.localScale.z * roomScale);
				player.locoVisual_PlayAreaQuest.SetActive(value: false);
				player.locoVisual_PlayAreaRift.SetActive(value: false);
				player.locoVisual_PlayAreaPSVR.SetActive(value: false);
				player.locoVisual_PlayAreaPico.SetActive(value: false);
			}
		}
		else if (player.CurrentIntegrationType == NVRSDKIntegrations.Oculus)
		{
			playArea = player.locoVisual_PlayAreaRift;
			float timeoutCheck = 3f;
			RoomScaleOculus roomScaleScript = new RoomScaleOculus();
			while (!roomScaleScript.init && timeoutCheck > 0f)
			{
				roomScaleScript.CalcRoomScale();
				timeoutCheck -= 0.5f;
				yield return null;
			}
			roomScale = roomScaleScript.GetScale();
			if (!roomScaleScript.init)
			{
				roomScale = 1.5f;
			}
			playArea.transform.localScale = new Vector3(playArea.transform.localScale.x * roomScale, playArea.transform.localScale.y, playArea.transform.localScale.z * roomScale);
			player.locoVisual_PlayAreaQuest.SetActive(value: false);
			player.locoVisual_PlayAreaVive.SetActive(value: false);
			player.locoVisual_PlayAreaPSVR.SetActive(value: false);
			player.locoVisual_PlayAreaPico.SetActive(value: false);
		}
		else if (player.CurrentIntegrationType == NVRSDKIntegrations.OculusQuest)
		{
			playArea = player.locoVisual_PlayAreaQuest;
			float timeoutCheck = 3f;
			RoomScaleOculusQuest roomScaleScript4 = new RoomScaleOculusQuest();
			while (!roomScaleScript4.init && timeoutCheck > 0f)
			{
				roomScaleScript4.CalcRoomScale();
				timeoutCheck -= 0.5f;
				yield return null;
			}
			roomScale = roomScaleScript4.GetScale();
			if (!roomScaleScript4.init)
			{
				roomScale = 1.5f;
			}
			playArea.transform.localScale = new Vector3(playArea.transform.localScale.x * roomScale, playArea.transform.localScale.y, playArea.transform.localScale.z * roomScale);
			player.locoVisual_PlayAreaRift.SetActive(value: false);
			player.locoVisual_PlayAreaVive.SetActive(value: false);
			player.locoVisual_PlayAreaPSVR.SetActive(value: false);
			player.locoVisual_PlayAreaPico.SetActive(value: false);
		}
		else if (player.CurrentIntegrationType == NVRSDKIntegrations.PSVR)
		{
			playArea = player.locoVisual_PlayAreaPSVR;
			roomScale = 1.9f;
			playArea.transform.localScale = new Vector3(playArea.transform.localScale.x * roomScale, playArea.transform.localScale.y, playArea.transform.localScale.z * roomScale);
			player.locoVisual_PlayAreaQuest.SetActive(value: false);
			player.locoVisual_PlayAreaRift.SetActive(value: false);
			player.locoVisual_PlayAreaVive.SetActive(value: false);
			player.locoVisual_PlayAreaPico.SetActive(value: false);
		}
		else if (player.CurrentIntegrationType == NVRSDKIntegrations.Pico)
		{
			playArea = player.locoVisual_PlayAreaPico;
			player.locoVisual_PlayAreaQuest.SetActive(value: false);
			player.locoVisual_PlayAreaVive.SetActive(value: false);
			player.locoVisual_PlayAreaPSVR.SetActive(value: false);
			player.locoVisual_PlayAreaRift.SetActive(value: false);
		}
		playAreaRender = playArea.GetComponent<Renderer>();
		playAreaRender.sharedMaterial.SetColor("_EmissionColor", UnityEngine.Color.clear);
		if (leaveUIOn)
		{
			player.locoVisual.transform.position = player.gameObject.transform.position + heightOffset;
		}
		else
		{
			player.locoVisual.SetActive(value: false);
		}
		isInitialised = true;
		SetFromPrefs();
	}

	private void Update()
	{
		if (isInitialised && !player.screenFX.isFading && crouchEnabled && (!menuOpen || player.CurrentIntegrationType != NVRSDKIntegrations.PSVR || ControlsManager.instance.usingDS4Controller))
		{
			CrouchMovement();
		}
	}

	private void FixedUpdate()
	{
		if (isInitialised)
		{
			if (player.HandMenu == null)
			{
				menuOpen = false;
			}
			else if (!player.HandMenu.IsActive)
			{
				menuOpen = false;
			}
			else
			{
				menuOpen = true;
			}
			player.locoVisual_PlayCenter.transform.position = player.transform.position + heightOffset - CrouchHeight;
			PlayerLocomotion();
			UpdateUI();
		}
	}

	private void PlayerLocomotion()
	{
		if (player.screenFX.isFading || isTeleporting || isRotating)
		{
			return;
		}
		if (!overrideMovementEnabled)
		{
			if (freeMoveEnabled && !menuOpen)
			{
				FreeMovement();
			}
			if (teleportEnabled && !menuOpen)
			{
				TeleportMovement();
			}
		}
		if (rotationEnabled)
		{
			RotateMovement();
		}
	}

	private void TeleportMovement()
	{
		if (ControlsManager.instance.teleportButtonDown)
		{
			StartLocomotion();
		}
		if (!teleporterActive)
		{
			return;
		}
		if (base.transform.localEulerAngles.x < 345f && base.transform.localEulerAngles.x > 270f)
		{
			player.locoVisual_Head.SetActive(value: false);
			if (!leaveUIOn)
			{
				player.locoVisual.SetActive(value: false);
			}
			if (ControlsManager.instance.teleportButtonUp)
			{
				teleporterActive = false;
				playArea.transform.position = player.gameObject.transform.position + heightOffset;
			}
			return;
		}
		player.locoVisual_Head.SetActive(value: true);
		player.locoVisual.SetActive(value: true);
		Vector3 direction = base.transform.forward - base.transform.up * 0.5f;
		if (Physics.Raycast(base.transform.position, direction, out var hitInfo, 50f, rayMask))
		{
			if (hitInfo.collider != null && hitInfo.collider.gameObject.tag == "Portal")
			{
				hittingPortal = true;
			}
			else if (hitInfo.collider != null && hitInfo.collider.gameObject.tag == "Floor")
			{
				hittingPortal = false;
				if (NavMesh.SamplePosition(hitInfo.point, out var hit, 10f, -1))
				{
					player.locoVisual_Head.transform.position = hit.position;
					Vector3 vector = new Vector3((player.gameObject.transform.position - base.transform.position).x, -0.01f, (player.gameObject.transform.position - base.transform.position).z);
					playArea.transform.position = player.locoVisual_Head.transform.position + vector + heightOffset;
				}
				player.locoVisual_Head.transform.eulerAngles = new Vector3(0f, base.transform.eulerAngles.y + 180f, 0f);
				lastHitFloor = hitInfo.collider.gameObject;
			}
		}
		if (ControlsManager.instance.teleportButtonUp && !hittingPortal)
		{
			StartCoroutine(TeleportPlayer(player.locoVisual_Head.transform.position, forced: false));
		}
		else if (ControlsManager.instance.teleportButtonUp && hittingPortal)
		{
			screenFX.Fade(UnityEngine.Color.black, 0f);
			player.locoVisual_Head.SetActive(value: false);
			if (!leaveUIOn)
			{
				player.locoVisual.SetActive(value: false);
			}
			StartCoroutine(TeleportPlayer(player.locoVisual_Head.transform.position, forced: true));
		}
	}

	public void CancelTeleport()
	{
		if (isInitialised)
		{
			teleporterActive = false;
			player.locoVisual_Head.SetActive(value: false);
			if (!leaveUIOn)
			{
				player.locoVisual.SetActive(value: false);
			}
			playArea.transform.position = player.gameObject.transform.position + heightOffset;
			if ((bool)playAreaRender)
			{
				playAreaRender.sharedMaterial.SetColor("_EmissionColor", new UnityEngine.Color(0f, 0f, 0f, 0f));
				UnityEngine.Color color = playAreaRender.sharedMaterial.color;
				color.a = 0f;
				playAreaRender.sharedMaterial.color = color;
			}
		}
	}

	private void FreeMovement()
	{
		Vector2 vector = ControlsManager.instance.moveAxisHold.normalized;
		UnityEngine.Debug.LogError("Debug: " + vector);
		if (ControlsManager.instance.usingDS4Controller)
		{
			vector = new Vector2(vector.x, 0f - vector.y);
		}
		vector *= playerSpeeds[(int)movementSpeed] * Time.deltaTime;
		Vector3 vector2 = new Vector3(base.transform.position.x, player.transform.position.y, base.transform.position.z) + heightOffset;
		if (vector.y < 0f)
		{
			vector.y *= 0.55f;
		}
		vector2 += new Vector3(base.transform.forward.x, 0f, base.transform.forward.z) * vector.y;
		vector2 += new Vector3(base.transform.right.x, 0f, base.transform.right.z) * vector.x * 0.7f;
		if (!(vector2 != new Vector3(base.transform.position.x, player.transform.position.y, base.transform.position.z) + heightOffset) || !Physics.Raycast(base.transform.position, vector2 - base.transform.position, out var hitInfo, 50f, rayMask))
		{
			return;
		}
		player.locoVisual_Head.transform.position = hitInfo.point;
		if (hitInfo.collider != null && hitInfo.collider.gameObject.tag == "Floor")
		{
			if (NavMesh.SamplePosition(hitInfo.point, out var hit, 1f, -1))
			{
				player.transform.position = hit.position - heightOffset + new Vector3((player.transform.position - base.transform.position).x, 0f, (player.transform.position - base.transform.position).z);
			}
			if (teleporterActive)
			{
				CancelTeleport();
			}
			player.locoVisual_Head.transform.eulerAngles = new Vector3(0f, base.transform.eulerAngles.y + 180f, 0f);
			if (seated)
			{
				player.transform.position = new Vector3(player.gameObject.transform.position.x, player.transform.position.y + seatedHeight, player.transform.position.z) - heightOffset;
			}
			player.transform.position += CrouchHeight;
			if (crouchMovement)
			{
				KeepObjectInHand();
			}
			lastHitFloor = hitInfo.collider.gameObject;
			if (!footStepPlaying)
			{
				StartCoroutine(FootStepDelay(1.5f - ControlsManager.instance.moveAxisHold.magnitude));
			}
		}
	}

	private void CrouchMovement()
	{
		if (!ControlsManager.instance.crouchButtonDown || crouchMovement)
		{
			return;
		}
		if (isCrouching)
		{
			UnityEngine.Debug.Log("Uncrouch Player");
			isCrouching = false;
			if (crouchOption == CrouchOptions.SNAP)
			{
				crouchMovement = false;
				player.transform.position = new Vector3(player.transform.position.x, player.transform.position.y - crouchHeight, player.transform.position.z);
				KeepObjectInHand();
			}
			else
			{
				crouchMovement = true;
				currentSmoothCrouchOffset = 0f;
				StartCoroutine(CrouchPlayer(player.transform.position.y - crouchHeight));
			}
		}
		else
		{
			UnityEngine.Debug.Log("Crouch Player");
			isCrouching = true;
			if (crouchOption == CrouchOptions.SNAP)
			{
				crouchMovement = false;
				player.transform.position = new Vector3(player.transform.position.x, player.transform.position.y + crouchHeight, player.transform.position.z);
				KeepObjectInHand();
			}
			else
			{
				crouchMovement = true;
				currentSmoothCrouchOffset = 0f;
				StartCoroutine(CrouchPlayer(player.transform.position.y + crouchHeight));
			}
		}
	}

	private void RotateMovement()
	{
		if (rotationOption == RotationOptions.FREE)
		{
			if (ControlsManager.instance.rotateRightHold)
			{
				if (teleporterActive)
				{
					CancelTeleport();
				}
				player.gameObject.transform.RotateAround(base.transform.position, Vector3.up, rotationSpeedValues[(int)rotationSpeed]);
			}
			else if (ControlsManager.instance.rotateLeftHold)
			{
				if (teleporterActive)
				{
					CancelTeleport();
				}
				player.gameObject.transform.RotateAround(base.transform.position, Vector3.up, 0f - rotationSpeedValues[(int)rotationSpeed]);
			}
		}
		else if (XRSettings.loadedDeviceName == "OpenVR" && XRDevice.model.IndexOf("oculus", StringComparison.CurrentCultureIgnoreCase) == -1)
		{
			if (!swipeLeft && !swipeRight)
			{
				if (ControlsManager.instance.rotateLeftHold)
				{
					swipeRight = true;
					swipeTime = 0f;
				}
				else if (ControlsManager.instance.rotateRightHold)
				{
					swipeLeft = true;
					swipeTime = 0f;
				}
			}
			if (swipeRight || swipeLeft)
			{
				if (ControlsManager.instance.swipeHold)
				{
					swipePosition = ControlsManager.instance.swipePosition;
				}
				swipeTime += Time.deltaTime;
				if (swipeTime > 0.5f)
				{
					swipeLeft = false;
					swipeRight = false;
					swipeTime = 0f;
				}
			}
			if (swipeRight)
			{
				if (ControlsManager.instance.rotateRightUp && swipePosition.x > 0f)
				{
					swipeRight = false;
					if (teleporterActive)
					{
						CancelTeleport();
					}
					StartCoroutine(RotatePlayer(rotationValues[(int)rotationOption]));
				}
			}
			else if (swipeLeft && ControlsManager.instance.rotateLeftUp && swipePosition.x < 0f)
			{
				swipeLeft = false;
				if (teleporterActive)
				{
					CancelTeleport();
				}
				StartCoroutine(RotatePlayer(0f - rotationValues[(int)rotationOption]));
			}
		}
		else if (ControlsManager.instance.rotateRightDown)
		{
			if (teleporterActive)
			{
				CancelTeleport();
			}
			StartCoroutine(RotatePlayer(rotationValues[(int)rotationOption]));
		}
		else if (ControlsManager.instance.rotateLeftDown)
		{
			if (teleporterActive)
			{
				CancelTeleport();
			}
			StartCoroutine(RotatePlayer(0f - rotationValues[(int)rotationOption]));
		}
	}

	private void UpdateUI()
	{
		if (!isTeleporting)
		{
			float num = 0f;
			num = ((!teleporterActive) ? Mathf.Clamp(Vector3.Distance(player.locoVisual_PlayCenter.transform.position, new Vector3(player.Head.transform.position.x, player.locoVisual_PlayCenter.transform.position.y, player.Head.transform.position.z)), 0f, roomScale / 2f) : Mathf.Clamp(Vector3.Distance(player.locoVisual_PlayCenter.transform.position, player.locoVisual_Head.transform.position), 0f, roomScale / 2f));
			if (num > 0.01f)
			{
				float num2 = Mathf.Clamp((num - 0.5f) / (roomScale / 2f - 0.5f), 0f, 1f);
				playAreaRender.sharedMaterial.SetColor("_EmissionColor", new UnityEngine.Color(num2, num2, num2, num2));
				UnityEngine.Color color = playAreaRender.sharedMaterial.color;
				color.a = num2;
				playAreaRender.sharedMaterial.color = color;
			}
		}
	}

	public void HideWarningUI()
	{
		if (PreferenceManager.instance.GetInt(PlayerPreferences.HIDE_WARNING_UI.ToString()) == 1)
		{
			hideWarningUI = true;
		}
		else
		{
			hideWarningUI = false;
		}
	}

	public void ForceTeleport(Vector3 target)
	{
		StartCoroutine(TeleportPlayer(target, forced: true));
	}

	private IEnumerator TeleportPlayer(Vector3 target, bool forced)
	{
		isTeleporting = true;
		teleporterActive = false;
		if (!forced)
		{
			float dist = Vector2.Distance(new Vector2(base.transform.position.x, base.transform.position.z), new Vector2(player.locoVisual_Head.transform.position.x, player.locoVisual_Head.transform.position.z));
			screenFX.Fade(UnityEngine.Color.black, 0.2f);
			WaitForSeconds footStepWait = new WaitForSeconds(0.4f);
			audioFootsteps.PlayOne(teleportSound, 0.2f);
			if (dist < 1.25f)
			{
				yield return Yield.WaitSeconds(0.3f);
				player.gameObject.transform.position = target - heightOffset + new Vector3((player.gameObject.transform.position - base.transform.position).x, 0f, (player.gameObject.transform.position - base.transform.position).z);
				KeepObjectInHand();
			}
			else
			{
				yield return Yield.WaitSeconds(0.15f);
				PlayFootStep(volume);
				yield return footStepWait;
				PlayFootStep(volume);
				player.gameObject.transform.position = target - heightOffset + new Vector3((player.gameObject.transform.position - base.transform.position).x, 0f, (player.gameObject.transform.position - base.transform.position).z);
				KeepObjectInHand();
				if (dist > 2.5f)
				{
					yield return footStepWait;
					PlayFootStep(volume);
				}
				if (dist > 3.75f)
				{
					yield return footStepWait;
					PlayFootStep(volume);
				}
				if (dist > 7.5f)
				{
					yield return footStepWait;
					PlayFootStep(volume);
				}
			}
		}
		else
		{
			player.gameObject.transform.position = target - heightOffset + new Vector3((player.gameObject.transform.position - base.transform.position).x, 0f, (player.gameObject.transform.position - base.transform.position).z);
			KeepObjectInHand();
		}
		if (seated)
		{
			player.gameObject.transform.position = new Vector3(player.gameObject.transform.position.x, player.gameObject.transform.position.y + seatedHeight, player.gameObject.transform.position.z);
			KeepObjectInHand();
		}
		player.transform.position += CrouchHeight;
		if (!leaveUIOn)
		{
			player.locoVisual.SetActive(value: false);
		}
		else
		{
			player.locoVisual_Head.SetActive(value: false);
			playArea.transform.position = player.gameObject.transform.position + heightOffset;
		}
		player.playerLight.TeleportMovement();
		if (!forced && !boundsDetection.outOfBounds)
		{
			screenFX.Fade(UnityEngine.Color.clear, 0.2f);
			yield return Yield.WaitSeconds(0.2f);
		}
		player.locoVisual_Head.transform.position = target;
		isTeleporting = false;
	}

	private void PlayFootStep(float vol)
	{
		if (!lastHitFloor)
		{
			return;
		}
		FloorTag component = lastHitFloor.GetComponent<FloorTag>();
		if ((bool)component)
		{
			if (component.type == FloorType.WOOD)
			{
				audioFootsteps.PlayOne(footStepsWood[UnityEngine.Random.Range(0, footStepsWood.Length)], vol);
			}
			else if (component.type == FloorType.CONCRETE)
			{
				audioFootsteps.PlayOne(footStepsConcrete[UnityEngine.Random.Range(0, footStepsConcrete.Length)], vol);
			}
			else if (component.type == FloorType.CARPET)
			{
				audioFootsteps.PlayOne(footStepsCarpet[UnityEngine.Random.Range(0, footStepsCarpet.Length)], vol);
			}
			else if (component.type == FloorType.WOODPLANK)
			{
				audioFootsteps.PlayOne(footStepsWoodPlank[UnityEngine.Random.Range(0, footStepsWoodPlank.Length)], vol);
			}
			else if (component.type == FloorType.METALHOLLOW)
			{
				audioFootsteps.PlayOne(footStepsHollowMetal[UnityEngine.Random.Range(0, footStepsHollowMetal.Length)], vol);
			}
			else if (component.type == FloorType.DIRTSAND)
			{
				audioFootsteps.PlayOne(footstepsDirtSand[UnityEngine.Random.Range(0, footstepsDirtSand.Length)], vol);
			}
		}
		else
		{
			audioFootsteps.PlayOne(footStepsWood[UnityEngine.Random.Range(0, footStepsWood.Length)], vol);
		}
	}

	private IEnumerator RotatePlayer(float rotation)
	{
		isRotating = true;
		_ = player.gameObject.transform.rotation;
		Quaternion.Euler(player.gameObject.transform.eulerAngles + new Vector3(0f, rotation, 0f));
		if (rotationFade == RotationFades.ON)
		{
			screenFX.Fade(UnityEngine.Color.black, rotationFadeValues[(int)rotationOption]);
		}
		yield return Yield.WaitSeconds(rotationFadeValues[(int)rotationOption]);
		for (float t = 0f; t < 1f; t += Time.deltaTime / rotationFadeValues[(int)rotationOption])
		{
			player.gameObject.transform.RotateAround(base.transform.position, Vector3.up, rotation * t);
			base.transform.Rotate(Vector3.up, rotation * t);
			rotation -= rotation * t;
			KeepObjectInHand();
			yield return Yield.EndOfFrame;
		}
		player.gameObject.transform.RotateAround(base.transform.position, Vector3.up, rotation);
		base.transform.Rotate(Vector3.up, rotation);
		KeepObjectInHand();
		yield return Yield.WaitSeconds(rotationFadeValues[(int)rotationOption]);
		if (rotationFade == RotationFades.ON)
		{
			screenFX.Fade(UnityEngine.Color.clear, rotationFadeValues[(int)rotationOption]);
		}
		yield return Yield.WaitSeconds(rotationFadeValues[(int)rotationOption]);
		isRotating = false;
	}

	private IEnumerator FadePeripheral(float from, float to, float time)
	{
		for (float t = 0f; t < 1f; t += Time.deltaTime / time)
		{
			screenFX.PeripheralFade(Mathf.Lerp(from, to, t));
			yield return Yield.EndOfFrame;
		}
		screenFX.PeripheralFade(to);
	}

	private IEnumerator CrouchPlayer(float height)
	{
		currentSmoothCrouchOffset = 0f;
		StartCoroutine(FadePeripheral(0f, 0.65f, 0.05f));
		yield return Yield.WaitSeconds(0.05f);
		float dif = height - player.transform.position.y;
		float currentHeight = player.transform.position.y;
		for (float t = 0f; t < 1f; t += Time.deltaTime / 0.1f)
		{
			currentSmoothCrouchOffset = dif * t;
			player.transform.position = new Vector3(player.transform.position.x, currentHeight + dif * t, player.transform.position.z);
			yield return Yield.EndOfFrame;
		}
		if (currentSmoothCrouchOffset < 0f)
		{
			currentSmoothCrouchOffset = crouchHeight;
		}
		else
		{
			currentSmoothCrouchOffset = 0f - crouchHeight;
		}
		player.transform.position = new Vector3(player.transform.position.x, height, player.transform.position.z);
		KeepObjectInHand();
		StartCoroutine(FadePeripheral(0.65f, 0f, 0.05f));
		yield return Yield.WaitSeconds(0.05f);
		crouchMovement = false;
		currentSmoothCrouchOffset = 0f;
	}

	private void KeepObjectInHand()
	{
		if (player.LeftHand.IsInteracting && player.LeftHand.CurrentlyInteracting.gameObject.tag != "Fixture")
		{
			player.LeftHand.CurrentlyInteracting.Rigidbody.MovePosition(player.LeftHand.transform.position);
		}
		if (player.RightHand.IsInteracting && player.RightHand.CurrentlyInteracting.gameObject.tag != "Fixture")
		{
			player.RightHand.CurrentlyInteracting.Rigidbody.MovePosition(player.RightHand.transform.position);
		}
	}

	private IEnumerator FootStepDelay(float time)
	{
		footStepPlaying = true;
		PlayFootStep(volume + (time - 0.5f) / 5f - 0.1f);
		yield return Yield.WaitSeconds(time);
		footStepPlaying = false;
	}

	public void StartLocomotion()
	{
		teleporterActive = true;
		player.locoVisual.SetActive(value: true);
		player.locoVisual_Head.SetActive(value: true);
	}

	public void DisableMovement()
	{
		UnityEngine.Debug.LogError("Debug: DisableMovement");
		CancelTeleport();
		freeMoveEnabled = false;
		teleportEnabled = false;
	}

	public void DisableEverything()
	{
		UnityEngine.Debug.LogError("Debug: DisableEverything");
		DisableMovement();
		crouchEnabled = false;
		rotationEnabled = false;
	}

	public void EnableMovement()
	{
		switch (PreferenceManager.instance.GetInt(PlayerPreferences.MOVEMENT_TYPE.ToString()))
		{
		case 1:
			freeMoveEnabled = true;
			break;
		case 0:
			teleportEnabled = true;
			break;
		case 2:
			freeMoveEnabled = true;
			teleportEnabled = true;
			break;
		}
	}

	public void EnableEverythingDelayed(float delay)
	{
		StartCoroutine(EnableEverythingDelayedRoutine(delay));
	}

	private IEnumerator EnableEverythingDelayedRoutine(float delay)
	{
		if (delay > 0f)
		{
			yield return Yield.WaitSeconds(delay);
		}
		EnableEverything();
	}

	public void EnableEverything()
	{
		EnableMovement();
		if (PreferenceManager.instance.GetInt(PlayerPreferences.CROUCH.ToString()) != 2)
		{
			crouchEnabled = true;
		}
		if (PreferenceManager.instance.GetInt(PlayerPreferences.ROTATION_AMOUNT.ToString()) != 0)
		{
			rotationEnabled = true;
		}
	}

	private void SetFromPrefs()
	{
		SetMovementType();
		SetMoveSpeed();
		SetRotationMode();
		SetRotationSpeed();
		SetRotationFade();
		SetCrouch();
		SetShowUI();
	}

	public void SetMovementType()
	{
		switch (PreferenceManager.instance.GetInt(PlayerPreferences.MOVEMENT_TYPE.ToString()))
		{
		case 1:
			freeMoveEnabled = true;
			teleportEnabled = false;
			break;
		case 0:
			freeMoveEnabled = false;
			teleportEnabled = true;
			break;
		case 2:
			freeMoveEnabled = true;
			teleportEnabled = true;
			break;
		}
	}

	public void SetMoveSpeed()
	{
		switch (PreferenceManager.instance.GetInt(PlayerPreferences.FREE_MOVE_SPEED.ToString()))
		{
		case 0:
			movementSpeed = MovementSpeeds.SLOW;
			break;
		case 1:
			movementSpeed = MovementSpeeds.MEDIUM;
			break;
		case 2:
			movementSpeed = MovementSpeeds.FAST;
			break;
		}
	}

	public void SetRotationMode()
	{
		int @int = PreferenceManager.instance.GetInt(PlayerPreferences.ROTATION_AMOUNT.ToString());
		if (@int == 0)
		{
			rotationEnabled = false;
			return;
		}
		if (!rotationEnabled)
		{
			rotationEnabled = true;
		}
		switch (@int)
		{
		case 1:
			rotationOption = RotationOptions.THIRTY;
			break;
		case 2:
			rotationOption = RotationOptions.FORTYFIVE;
			break;
		case 3:
			rotationOption = RotationOptions.NINETY;
			break;
		case 4:
			rotationOption = RotationOptions.FREE;
			break;
		}
	}

	public void SetRotationSpeed()
	{
		switch (PreferenceManager.instance.GetInt(PlayerPreferences.FREE_ROTATION_SPEED.ToString()))
		{
		case 0:
			rotationSpeed = RotationSpeeds.SLOW;
			break;
		case 1:
			rotationSpeed = RotationSpeeds.MEDIUM;
			break;
		case 2:
			rotationSpeed = RotationSpeeds.FAST;
			break;
		}
	}

	public void SetRotationFade()
	{
		switch (PreferenceManager.instance.GetInt(PlayerPreferences.ROTATION_FADE.ToString()))
		{
		case 0:
			rotationFade = RotationFades.ON;
			break;
		case 1:
			rotationFade = RotationFades.OFF;
			break;
		}
	}

	public void SetCrouch()
	{
		int @int = PreferenceManager.instance.GetInt(PlayerPreferences.CROUCH.ToString());
		if (@int == 2)
		{
			crouchEnabled = false;
			if (isCrouching)
			{
				isCrouching = false;
				player.transform.position = new Vector3(player.transform.position.x, player.transform.position.y - crouchHeight, player.transform.position.z);
			}
			return;
		}
		if (!crouchEnabled)
		{
			crouchEnabled = true;
		}
		switch (@int)
		{
		case 0:
			crouchOption = CrouchOptions.SNAP;
			break;
		case 1:
			crouchOption = CrouchOptions.SMOOTH;
			break;
		}
	}

	public void SetShowUI()
	{
		switch (PreferenceManager.instance.GetInt(PlayerPreferences.POSITION_GUIDE.ToString()))
		{
		case 0:
			leaveUIOn = true;
			player.locoVisual_PlayCenter.SetActive(value: true);
			player.locoVisual.SetActive(value: true);
			player.locoVisual_Head.SetActive(value: false);
			player.locoVisual.transform.position = player.gameObject.transform.position + heightOffset;
			break;
		case 1:
			leaveUIOn = false;
			player.locoVisual_PlayCenter.SetActive(value: false);
			player.locoVisual.SetActive(value: false);
			break;
		}
	}

	private void DebugKeys()
	{
		if (Input.GetKeyDown(KeyCode.Alpha1))
		{
			freeMoveEnabled = false;
			teleportEnabled = true;
		}
		else if (Input.GetKeyDown(KeyCode.Alpha2))
		{
			freeMoveEnabled = true;
			teleportEnabled = false;
		}
		else if (Input.GetKeyDown(KeyCode.Alpha3))
		{
			rotationOption = RotationOptions.FREE;
		}
		else if (Input.GetKeyDown(KeyCode.Alpha4))
		{
			if (seated)
			{
				player.gameObject.transform.position = new Vector3(player.gameObject.transform.position.x, player.gameObject.transform.position.y - seatedHeight, player.gameObject.transform.position.z);
			}
			seated = false;
		}
		else if (Input.GetKeyDown(KeyCode.Alpha5))
		{
			if (!seated)
			{
				player.gameObject.transform.position = new Vector3(player.gameObject.transform.position.x, player.gameObject.transform.position.y + seatedHeight, player.gameObject.transform.position.z);
			}
			seated = true;
		}
		else if (Input.GetKeyDown(KeyCode.F))
		{
			rotationSpeed = RotationSpeeds.SLOW;
		}
		else if (Input.GetKeyDown(KeyCode.G))
		{
			rotationSpeed = RotationSpeeds.MEDIUM;
		}
		else if (Input.GetKeyDown(KeyCode.H))
		{
			rotationSpeed = RotationSpeeds.FAST;
		}
		else if (Input.GetKeyDown(KeyCode.A))
		{
			rotationOption = RotationOptions.THIRTY;
		}
		else if (Input.GetKeyDown(KeyCode.S))
		{
			rotationOption = RotationOptions.FORTYFIVE;
		}
		else if (Input.GetKeyDown(KeyCode.D))
		{
			rotationOption = RotationOptions.NINETY;
		}
		else if (Input.GetKeyDown(KeyCode.Q))
		{
			movementSpeed = MovementSpeeds.SLOW;
		}
		else if (Input.GetKeyDown(KeyCode.E))
		{
			movementSpeed = MovementSpeeds.MEDIUM;
		}
		else if (Input.GetKeyDown(KeyCode.W))
		{
			movementSpeed = MovementSpeeds.FAST;
		}
	}
}
public enum PlayerPreferences
{
	PLAYER_HEIGHT,
	CALIBRATED,
	MOVEMENT_TYPE,
	FREE_MOVE_SPEED,
	ROTATION_AMOUNT,
	FREE_ROTATION_SPEED,
	ROTATION_FADE,
	CROUCH,
	SUBTITLE_LANGUAGE,
	AUDIO_LANGUAGE,
	PRIMARY_HAND,
	GRIP,
	POSITION_GUIDE,
	BUTTON_HINTS,
	GAME_LANGUAGE,
	INTERACT_BUTTON,
	SAVED_DATA_VERSION,
	HAS_SEEN_HOLYWATER_UI,
	HAS_SEEN_LIGHTER_UI,
	HAS_SEEN_SALTSPRAYER_UI,
	HAS_SEEN_MENU_UI,
	HAS_SEEN_PHONE_UI,
	HAS_SEEN_RADIO_UI,
	HIDE_WARNING_UI
}
public enum MovementTypes
{
	TELEPORT,
	FREE,
	BOTH
}
public enum FreeMoveSpeed
{
	SLOW,
	MED,
	FAST
}
public enum RotationAmount
{
	OFF,
	THIRTY,
	FORTYFIVE,
	NINETY,
	FREE
}
public enum FreeRotationSpeed
{
	SLOW,
	MED,
	FAST
}
public enum RotationFade
{
	ON,
	OFF
}
public enum Crouch
{
	SNAP,
	SMOOTH,
	OFF
}
public enum GameLanguage
{
	EN,
	ES,
	SC
}
public enum SubtitleLanguage
{
	OFF,
	EN,
	ES,
	SC
}
public enum AudioLanguage
{
	EN,
	ES
}
public enum PrimaryHand
{
	LEFT,
	RIGHT
}
public enum Grip
{
	TOGGLE,
	HOLD
}
public enum PositionGuide
{
	SHOW,
	HIDE
}
public enum WarningUI
{
	SHOW,
	HIDE
}
public enum ButtonHints
{
	ALWAYS_ON,
	STANDARD,
	OFF
}
public enum InteractButtons
{
	TRIGGER,
	GRIP
}
internal static class PlayerPreferencesTextExtender
{
	public static string AsText(this PlayerPreferences preference)
	{
		return preference switch
		{
			PlayerPreferences.PLAYER_HEIGHT => "PLAYER_HEIGHT", 
			PlayerPreferences.CALIBRATED => "CALIBRATED", 
			PlayerPreferences.MOVEMENT_TYPE => "MOVEMENT_TYPE", 
			PlayerPreferences.FREE_MOVE_SPEED => "FREE_MOVE_SPEED", 
			PlayerPreferences.ROTATION_AMOUNT => "ROTATION_AMOUNT", 
			PlayerPreferences.FREE_ROTATION_SPEED => "FREE_ROTATION_SPEED", 
			PlayerPreferences.ROTATION_FADE => "ROTATION_FADE", 
			PlayerPreferences.CROUCH => "CROUCH", 
			PlayerPreferences.SUBTITLE_LANGUAGE => "SUBTITLE_LANGUAGE", 
			PlayerPreferences.AUDIO_LANGUAGE => "AUDIO_LANGUAGE", 
			PlayerPreferences.PRIMARY_HAND => "PRIMARY_HAND", 
			PlayerPreferences.GRIP => "GRIP", 
			PlayerPreferences.POSITION_GUIDE => "POSITION_GUIDE", 
			PlayerPreferences.BUTTON_HINTS => "BUTTON_HINTS", 
			PlayerPreferences.GAME_LANGUAGE => "GAME_LANGUAGE", 
			_ => "", 
		};
	}
}
public class PreferenceManager : MonoBehaviour
{
	public static PreferenceManager instance = null;

	public bool preferencesInitialised;

	private Hashtable playerPrefsHashtable = new Hashtable();

	private static bool hashTableChanged = false;

	private const string PARAMETERS_SEPERATOR = ";";

	private const string KEY_VALUE_SEPERATOR = ":";

	private static string[] seperators = new string[2] { ";", ":" };

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
		else if (instance != this)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
	}

	public bool HasKey(string key)
	{
		return playerPrefsHashtable.ContainsKey(key);
	}

	public void SetString(string key, string value)
	{
		if (!playerPrefsHashtable.ContainsKey(key))
		{
			playerPrefsHashtable.Add(key, value);
		}
		else
		{
			playerPrefsHashtable[key] = value;
		}
		hashTableChanged = true;
	}

	public void SetInt(string key, int value)
	{
		if (!playerPrefsHashtable.ContainsKey(key))
		{
			playerPrefsHashtable.Add(key, value);
		}
		else
		{
			playerPrefsHashtable[key] = value;
		}
		hashTableChanged = true;
	}

	public void SetFloat(string key, float value)
	{
		if (!playerPrefsHashtable.ContainsKey(key))
		{
			playerPrefsHashtable.Add(key, value);
		}
		else
		{
			playerPrefsHashtable[key] = value;
		}
		hashTableChanged = true;
	}

	public void SetBool(string key, bool value)
	{
		if (!playerPrefsHashtable.ContainsKey(key))
		{
			playerPrefsHashtable.Add(key, value);
		}
		else
		{
			playerPrefsHashtable[key] = value;
		}
		hashTableChanged = true;
	}

	public void SetLong(string key, long value)
	{
		if (!playerPrefsHashtable.ContainsKey(key))
		{
			playerPrefsHashtable.Add(key, value);
		}
		else
		{
			playerPrefsHashtable[key] = value;
		}
		hashTableChanged = true;
	}

	public string GetString(string key)
	{
		if (playerPrefsHashtable.ContainsKey(key))
		{
			return playerPrefsHashtable[key].ToString();
		}
		return null;
	}

	public string GetString(string key, string defaultValue)
	{
		if (playerPrefsHashtable.ContainsKey(key))
		{
			return playerPrefsHashtable[key].ToString();
		}
		playerPrefsHashtable.Add(key, defaultValue);
		hashTableChanged = true;
		return defaultValue;
	}

	public int GetInt(string key)
	{
		if (playerPrefsHashtable.ContainsKey(key) && playerPrefsHashtable[key] != null)
		{
			return (int)playerPrefsHashtable[key];
		}
		return 0;
	}

	public int GetInt(string key, int defaultValue)
	{
		if (playerPrefsHashtable.ContainsKey(key))
		{
			return (int)playerPrefsHashtable[key];
		}
		playerPrefsHashtable.Add(key, defaultValue);
		hashTableChanged = true;
		return defaultValue;
	}

	public long GetLong(string key)
	{
		if (playerPrefsHashtable.ContainsKey(key))
		{
			return (long)playerPrefsHashtable[key];
		}
		return 0L;
	}

	public long GetLong(string key, long defaultValue)
	{
		if (playerPrefsHashtable.ContainsKey(key))
		{
			return (long)playerPrefsHashtable[key];
		}
		playerPrefsHashtable.Add(key, defaultValue);
		hashTableChanged = true;
		return defaultValue;
	}

	public float GetFloat(string key)
	{
		if (playerPrefsHashtable.ContainsKey(key))
		{
			return (float)playerPrefsHashtable[key];
		}
		return 0f;
	}

	public float GetFloat(string key, float defaultValue)
	{
		if (playerPrefsHashtable.ContainsKey(key))
		{
			return (float)playerPrefsHashtable[key];
		}
		playerPrefsHashtable.Add(key, defaultValue);
		hashTableChanged = true;
		return defaultValue;
	}

	public bool GetBool(string key)
	{
		if (playerPrefsHashtable.ContainsKey(key))
		{
			return (bool)playerPrefsHashtable[key];
		}
		return false;
	}

	public bool GetBool(string key, bool defaultValue)
	{
		if (playerPrefsHashtable.ContainsKey(key))
		{
			return (bool)playerPrefsHashtable[key];
		}
		playerPrefsHashtable.Add(key, defaultValue);
		hashTableChanged = true;
		return defaultValue;
	}

	public void DeleteKey(string key)
	{
		playerPrefsHashtable.Remove(key);
	}

	public void DeleteAll()
	{
		playerPrefsHashtable.Clear();
		playerPrefsHashtable = new Hashtable();
	}

	public bool InitialiseWithDefaultPlatformPreferences(NVRSDKIntegrations currentIntegration)
	{
		playerPrefsHashtable = new Hashtable();
		switch (currentIntegration)
		{
		case NVRSDKIntegrations.Oculus:
			SetInt(PlayerPreferences.AUDIO_LANGUAGE.ToString(), 0);
			SetInt(PlayerPreferences.CROUCH.ToString(), 1);
			SetInt(PlayerPreferences.FREE_MOVE_SPEED.ToString(), 1);
			SetInt(PlayerPreferences.FREE_ROTATION_SPEED.ToString(), 1);
			SetInt(PlayerPreferences.GRIP.ToString(), 1);
			SetInt(PlayerPreferences.POSITION_GUIDE.ToString(), 1);
			SetInt(PlayerPreferences.PRIMARY_HAND.ToString(), 1);
			SetInt(PlayerPreferences.ROTATION_AMOUNT.ToString(), 3);
			SetInt(PlayerPreferences.ROTATION_FADE.ToString(), 0);
			SetInt(PlayerPreferences.SUBTITLE_LANGUAGE.ToString(), 0);
			SetInt(PlayerPreferences.MOVEMENT_TYPE.ToString(), 2);
			SetInt(PlayerPreferences.INTERACT_BUTTON.ToString(), 0);
			SetBool(PlayerPreferences.HAS_SEEN_HOLYWATER_UI.ToString(), value: false);
			SetBool(PlayerPreferences.HAS_SEEN_LIGHTER_UI.ToString(), value: false);
			SetBool(PlayerPreferences.HAS_SEEN_SALTSPRAYER_UI.ToString(), value: false);
			SetBool(PlayerPreferences.HAS_SEEN_MENU_UI.ToString(), value: false);
			SetBool(PlayerPreferences.HAS_SEEN_PHONE_UI.ToString(), value: false);
			SetBool(PlayerPreferences.HAS_SEEN_RADIO_UI.ToString(), value: false);
			SetInt(PlayerPreferences.HIDE_WARNING_UI.ToString(), 0);
			break;
		case NVRSDKIntegrations.OculusQuest:
			SetInt(PlayerPreferences.AUDIO_LANGUAGE.ToString(), 0);
			SetInt(PlayerPreferences.CROUCH.ToString(), 1);
			SetInt(PlayerPreferences.FREE_MOVE_SPEED.ToString(), 1);
			SetInt(PlayerPreferences.FREE_ROTATION_SPEED.ToString(), 1);
			SetInt(PlayerPreferences.GRIP.ToString(), 1);
			SetInt(PlayerPreferences.POSITION_GUIDE.ToString(), 1);
			SetInt(PlayerPreferences.PRIMARY_HAND.ToString(), 1);
			SetInt(PlayerPreferences.ROTATION_AMOUNT.ToString(), 3);
			SetInt(PlayerPreferences.ROTATION_FADE.ToString(), 0);
			SetInt(PlayerPreferences.SUBTITLE_LANGUAGE.ToString(), 0);
			SetInt(PlayerPreferences.MOVEMENT_TYPE.ToString(), 2);
			SetInt(PlayerPreferences.INTERACT_BUTTON.ToString(), 1);
			SetBool(PlayerPreferences.HAS_SEEN_HOLYWATER_UI.ToString(), value: false);
			SetBool(PlayerPreferences.HAS_SEEN_LIGHTER_UI.ToString(), value: false);
			SetBool(PlayerPreferences.HAS_SEEN_SALTSPRAYER_UI.ToString(), value: false);
			SetBool(PlayerPreferences.HAS_SEEN_MENU_UI.ToString(), value: false);
			SetBool(PlayerPreferences.HAS_SEEN_PHONE_UI.ToString(), value: false);
			SetBool(PlayerPreferences.HAS_SEEN_RADIO_UI.ToString(), value: false);
			SetInt(PlayerPreferences.HIDE_WARNING_UI.ToString(), 0);
			break;
		case NVRSDKIntegrations.PSVR:
			SetInt(PlayerPreferences.AUDIO_LANGUAGE.ToString(), 0);
			SetInt(PlayerPreferences.CROUCH.ToString(), 1);
			SetInt(PlayerPreferences.FREE_MOVE_SPEED.ToString(), 1);
			SetInt(PlayerPreferences.FREE_ROTATION_SPEED.ToString(), 1);
			SetInt(PlayerPreferences.GRIP.ToString(), 1);
			SetInt(PlayerPreferences.POSITION_GUIDE.ToString(), 1);
			SetInt(PlayerPreferences.PRIMARY_HAND.ToString(), 1);
			SetInt(PlayerPreferences.ROTATION_AMOUNT.ToString(), 3);
			SetInt(PlayerPreferences.ROTATION_FADE.ToString(), 0);
			SetInt(PlayerPreferences.SUBTITLE_LANGUAGE.ToString(), 0);
			SetInt(PlayerPreferences.MOVEMENT_TYPE.ToString(), 0);
			SetInt(PlayerPreferences.INTERACT_BUTTON.ToString(), 0);
			SetBool(PlayerPreferences.HAS_SEEN_HOLYWATER_UI.ToString(), value: false);
			SetBool(PlayerPreferences.HAS_SEEN_LIGHTER_UI.ToString(), value: false);
			SetBool(PlayerPreferences.HAS_SEEN_SALTSPRAYER_UI.ToString(), value: false);
			SetBool(PlayerPreferences.HAS_SEEN_MENU_UI.ToString(), value: false);
			SetBool(PlayerPreferences.HAS_SEEN_PHONE_UI.ToString(), value: false);
			SetBool(PlayerPreferences.HAS_SEEN_RADIO_UI.ToString(), value: false);
			SetInt(PlayerPreferences.HIDE_WARNING_UI.ToString(), 0);
			break;
		case NVRSDKIntegrations.SteamVR:
			if (XRDevice.model.IndexOf("oculus", StringComparison.CurrentCultureIgnoreCase) != -1)
			{
				SetInt(PlayerPreferences.AUDIO_LANGUAGE.ToString(), 0);
				SetInt(PlayerPreferences.CROUCH.ToString(), 1);
				SetInt(PlayerPreferences.FREE_MOVE_SPEED.ToString(), 1);
				SetInt(PlayerPreferences.FREE_ROTATION_SPEED.ToString(), 1);
				SetInt(PlayerPreferences.GRIP.ToString(), 1);
				SetInt(PlayerPreferences.POSITION_GUIDE.ToString(), 1);
				SetInt(PlayerPreferences.PRIMARY_HAND.ToString(), 1);
				SetInt(PlayerPreferences.ROTATION_AMOUNT.ToString(), 3);
				SetInt(PlayerPreferences.ROTATION_FADE.ToString(), 0);
				SetInt(PlayerPreferences.SUBTITLE_LANGUAGE.ToString(), 0);
				SetInt(PlayerPreferences.MOVEMENT_TYPE.ToString(), 2);
				SetInt(PlayerPreferences.INTERACT_BUTTON.ToString(), 0);
				SetBool(PlayerPreferences.HAS_SEEN_HOLYWATER_UI.ToString(), value: false);
				SetBool(PlayerPreferences.HAS_SEEN_LIGHTER_UI.ToString(), value: false);
				SetBool(PlayerPreferences.HAS_SEEN_SALTSPRAYER_UI.ToString(), value: false);
				SetBool(PlayerPreferences.HAS_SEEN_MENU_UI.ToString(), value: false);
				SetBool(PlayerPreferences.HAS_SEEN_PHONE_UI.ToString(), value: false);
				SetBool(PlayerPreferences.HAS_SEEN_RADIO_UI.ToString(), value: false);
				SetInt(PlayerPreferences.HIDE_WARNING_UI.ToString(), 0);
			}
			else
			{
				SetInt(PlayerPreferences.AUDIO_LANGUAGE.ToString(), 0);
				SetInt(PlayerPreferences.CROUCH.ToString(), 2);
				SetInt(PlayerPreferences.FREE_MOVE_SPEED.ToString(), 1);
				SetInt(PlayerPreferences.FREE_ROTATION_SPEED.ToString(), 1);
				SetInt(PlayerPreferences.GRIP.ToString(), 1);
				SetInt(PlayerPreferences.POSITION_GUIDE.ToString(), 0);
				SetInt(PlayerPreferences.PRIMARY_HAND.ToString(), 1);
				SetInt(PlayerPreferences.ROTATION_AMOUNT.ToString(), 3);
				SetInt(PlayerPreferences.ROTATION_FADE.ToString(), 0);
				SetInt(PlayerPreferences.SUBTITLE_LANGUAGE.ToString(), 0);
				SetInt(PlayerPreferences.MOVEMENT_TYPE.ToString(), 2);
				SetInt(PlayerPreferences.INTERACT_BUTTON.ToString(), 0);
				SetBool(PlayerPreferences.HAS_SEEN_HOLYWATER_UI.ToString(), value: false);
				SetBool(PlayerPreferences.HAS_SEEN_LIGHTER_UI.ToString(), value: false);
				SetBool(PlayerPreferences.HAS_SEEN_SALTSPRAYER_UI.ToString(), value: false);
				SetBool(PlayerPreferences.HAS_SEEN_MENU_UI.ToString(), value: false);
				SetBool(PlayerPreferences.HAS_SEEN_PHONE_UI.ToString(), value: false);
				SetBool(PlayerPreferences.HAS_SEEN_RADIO_UI.ToString(), value: false);
				SetInt(PlayerPreferences.HIDE_WARNING_UI.ToString(), 1);
			}
			break;
		case NVRSDKIntegrations.Pico:
			SetInt(PlayerPreferences.AUDIO_LANGUAGE.ToString(), 0);
			SetInt(PlayerPreferences.CROUCH.ToString(), 1);
			SetInt(PlayerPreferences.FREE_MOVE_SPEED.ToString(), 1);
			SetInt(PlayerPreferences.FREE_ROTATION_SPEED.ToString(), 1);
			SetInt(PlayerPreferences.GRIP.ToString(), 1);
			SetInt(PlayerPreferences.POSITION_GUIDE.ToString(), 1);
			SetInt(PlayerPreferences.PRIMARY_HAND.ToString(), 1);
			SetInt(PlayerPreferences.ROTATION_AMOUNT.ToString(), 3);
			SetInt(PlayerPreferences.ROTATION_FADE.ToString(), 0);
			SetInt(PlayerPreferences.SUBTITLE_LANGUAGE.ToString(), 0);
			SetInt(PlayerPreferences.MOVEMENT_TYPE.ToString(), 2);
			SetInt(PlayerPreferences.INTERACT_BUTTON.ToString(), 1);
			SetBool(PlayerPreferences.HAS_SEEN_HOLYWATER_UI.ToString(), value: false);
			SetBool(PlayerPreferences.HAS_SEEN_LIGHTER_UI.ToString(), value: false);
			SetBool(PlayerPreferences.HAS_SEEN_SALTSPRAYER_UI.ToString(), value: false);
			SetBool(PlayerPreferences.HAS_SEEN_MENU_UI.ToString(), value: false);
			SetBool(PlayerPreferences.HAS_SEEN_PHONE_UI.ToString(), value: false);
			SetBool(PlayerPreferences.HAS_SEEN_RADIO_UI.ToString(), value: false);
			SetInt(PlayerPreferences.HIDE_WARNING_UI.ToString(), 0);
			SetInt(PlayerPreferences.GAME_LANGUAGE.ToString(), (int)GetLanguageFromSystem());
			break;
		}
		preferencesInitialised = true;
		return preferencesInitialised;
	}

	public GameLanguage GetLanguageFromSystem()
	{
		switch (Application.systemLanguage)
		{
		case SystemLanguage.English:
			return GameLanguage.EN;
		case SystemLanguage.Spanish:
			return GameLanguage.ES;
		case SystemLanguage.Chinese:
		case SystemLanguage.ChineseSimplified:
		case SystemLanguage.ChineseTraditional:
			return GameLanguage.SC;
		default:
			return GameLanguage.EN;
		}
	}

	public string GetLanguageFromEnum(int gameLanguage)
	{
		return gameLanguage switch
		{
			0 => "English", 
			1 => "Spanish", 
			2 => "Chinese", 
			_ => "English", 
		};
	}

	public GameLanguage GetLanguageFromInt(int gameLanguage)
	{
		return gameLanguage switch
		{
			0 => GameLanguage.EN, 
			1 => GameLanguage.ES, 
			2 => GameLanguage.SC, 
			_ => GameLanguage.EN, 
		};
	}

	public byte[] playerPreferencesToByteArray()
	{
		new Dictionary<string, string>();
		string value = Serialize();
		MemoryStream memoryStream = new MemoryStream();
		StreamWriter streamWriter = new StreamWriter(memoryStream);
		streamWriter.Write(value);
		streamWriter.Close();
		return memoryStream.GetBuffer();
	}

	public bool playerPreferencesFromByteArray(byte[] preferenceByteArray, NVRSDKIntegrations currentIntegration)
	{
		try
		{
			playerPrefsHashtable = new Hashtable();
			string serializedInput = new StreamReader(new MemoryStream(preferenceByteArray)).ReadToEnd();
			Deserialize(serializedInput);
			return true;
		}
		catch (Exception)
		{
			return false;
		}
	}

	private string Serialize()
	{
		IDictionaryEnumerator enumerator = playerPrefsHashtable.GetEnumerator();
		StringBuilder stringBuilder = new StringBuilder();
		bool flag = true;
		while (enumerator.MoveNext())
		{
			if (!flag)
			{
				stringBuilder.Append(" ");
				stringBuilder.Append(";");
				stringBuilder.Append(" ");
			}
			stringBuilder.Append(EscapeNonSeperators(enumerator.Key.ToString(), seperators));
			stringBuilder.Append(" ");
			stringBuilder.Append(":");
			stringBuilder.Append(" ");
			stringBuilder.Append(EscapeNonSeperators(enumerator.Value.ToString(), seperators));
			stringBuilder.Append(" ");
			stringBuilder.Append(":");
			stringBuilder.Append(" ");
			stringBuilder.Append(enumerator.Value.GetType());
			flag = false;
		}
		return stringBuilder.ToString();
	}

	private void Deserialize(string serializedInput)
	{
		string[] array = serializedInput.Split(new string[1] { " ; " }, StringSplitOptions.RemoveEmptyEntries);
		for (int i = 0; i < array.Length; i++)
		{
			string[] array2 = array[i].Split(new string[1] { " : " }, StringSplitOptions.None);
			playerPrefsHashtable.Add(DeEscapeNonSeperators(array2[0], seperators), GetTypeValue(array2[2], DeEscapeNonSeperators(array2[1], seperators)));
			if (array2.Length > 3)
			{
				UnityEngine.Debug.LogWarning("PreferenceManager::Deserialize() parameterContent has " + array2.Length + " elements");
			}
		}
	}

	public string EscapeNonSeperators(string inputToEscape, string[] seperators)
	{
		inputToEscape = inputToEscape.Replace("\\", "\\\\");
		for (int i = 0; i < seperators.Length; i++)
		{
			inputToEscape = inputToEscape.Replace(seperators[i], "\\" + seperators[i]);
		}
		return inputToEscape;
	}

	public string DeEscapeNonSeperators(string inputToDeEscape, string[] seperators)
	{
		for (int i = 0; i < seperators.Length; i++)
		{
			inputToDeEscape = inputToDeEscape.Replace("\\" + seperators[i], seperators[i]);
		}
		inputToDeEscape = inputToDeEscape.Replace("\\\\", "\\");
		return inputToDeEscape;
	}

	private object GetTypeValue(string typeName, string value)
	{
		switch (typeName)
		{
		case "System.String":
			return value.ToString();
		case "System.Int32":
			return Convert.ToInt32(value);
		case "System.Boolean":
			return Convert.ToBoolean(value);
		case "System.Single":
			return Convert.ToSingle(value);
		case "System.Int64":
			return Convert.ToInt64(value);
		default:
			UnityEngine.Debug.LogError("Unsupported type: " + typeName);
			return null;
		}
	}
}
public class SaveManager : MonoBehaviour
{
	[SerializeField]
	private NVRPlayer player;

	private const int kSaveDataMaxSize = 5242880;

	public GameData savedGameData;

	public static SaveManager instance;

	public int currentSavedGameSlot;

	public bool savedDataLoaded;

	public bool savedDataIsDirty;

	public bool offlineMode;

	public bool cloudsaveAvailable;

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
		else if (instance != this)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
	}

	private void OnEnable()
	{
	}

	private void Start()
	{
		if (DoesPicoSavedDataExist(currentSavedGameSlot))
		{
			LoadPicoSavedData(currentSavedGameSlot);
			return;
		}
		CreateNewProfile(currentSavedGameSlot);
		savedDataLoaded = true;
	}

	private IEnumerator StartUpRoutine()
	{
		yield return Yield.WaitSeconds(0.5f);
	}

	private void Update()
	{
	}

	private IEnumerator CheckInternetConnection(Action<bool> action)
	{
		WWW www = new WWW("http://www.google.com/");
		yield return www;
		if (www.error != null)
		{
			action(obj: false);
		}
		else
		{
			action(obj: true);
		}
	}

	public void Save(int slotNumber)
	{
		currentSavedGameSlot = slotNumber;
		SavePicoGameData(slotNumber);
	}

	public void Load(int slotNumber)
	{
		currentSavedGameSlot = slotNumber;
		LoadPicoSavedData(slotNumber);
	}

	public bool DoesExist(int slotNumber)
	{
		return DoesPicoSavedDataExist(slotNumber);
	}

	public void Delete(int slotNumber)
	{
		DeletePicoSavedData(slotNumber);
	}

	public void CreateNewProfile(int slotNumber)
	{
		UnityEngine.Debug.Log("Creating new profile");
		Delete(slotNumber);
		savedGameData = new GameData();
		bool num = savedGameData.InitialiseWithData();
		PlayerPrefs.DeleteAll();
		PreferenceManager.instance.DeleteAll();
		bool flag = PreferenceManager.instance.InitialiseWithDefaultPlatformPreferences(player.DetermineCurrentIntegration(logOutput: false));
		if (num && flag)
		{
			Save(slotNumber);
		}
	}

	public void ResetProgress()
	{
		StartCoroutine(ResetProgressRoutine());
	}

	private IEnumerator ResetProgressRoutine()
	{
		Delete(currentSavedGameSlot);
		yield return Yield.WaitSeconds(1f);
		savedGameData = new GameData();
		bool saveDataCreated = savedGameData.InitialiseWithData();
		PlayerPrefs.DeleteAll();
		PreferenceManager.instance.DeleteAll();
		yield return Yield.WaitSeconds(1f);
		bool flag = PreferenceManager.instance.InitialiseWithDefaultPlatformPreferences(player.DetermineCurrentIntegration(logOutput: false));
		if (saveDataCreated && flag)
		{
			EventManager.TriggerEvent(EventManager.AvailableEvents.ResetProgress.ToString());
			player.HandMenu.exKitScript.ResetItemUpgrades();
			player.HandMenu.bookScript.resetBook();
			player.HandMenu.phoneScript.reloadForReset();
			Save(currentSavedGameSlot);
			GameController.instance.translator.ResetTranslationObjects();
			GameController.instance.IAP.UpdateAvailablePurchaseInformation();
			HUD.Instance.KillSubtitles();
			GameController.instance.GoToSpecificScene(SCENES.ONBOARDING);
		}
	}

	public GameData GetCurrentGameData()
	{
		return savedGameData;
	}

	public Chapter[] GetCurrentGameDataChapters()
	{
		return savedGameData.gameChapters;
	}

	public Chapter GetSavedChapterByID(ChapterID chapterID)
	{
		Chapter[] gameChapters = savedGameData.gameChapters;
		foreach (Chapter chapter in gameChapters)
		{
			if (chapterID == chapter.chapterID)
			{
				return chapter;
			}
		}
		return null;
	}

	public bool ownsChapter(ChapterID chapterId)
	{
		return GetChapterById(chapterId)?.purchased ?? false;
	}

	public bool isChapterAvailable(ChapterID chapterId)
	{
		return GetChapterById(chapterId)?.available ?? false;
	}

	public void MarkChapterPurchased(ChapterID chapterId)
	{
		Chapter chapterById = GetChapterById(chapterId);
		if (chapterById != null)
		{
			chapterById.purchased = true;
			chapterById.chapterStatus = ChapterStatus.OWNED_NOT_PLAYED;
			chapterById.chapterCompletionStatus = ChapterCompletionStatus.BLANK;
			savedDataIsDirty = true;
		}
	}

	public void MarkChapterStarted(ChapterID chapterId)
	{
		Chapter chapterById = GetChapterById(chapterId);
		if (chapterById != null)
		{
			chapterById.started = true;
			savedDataIsDirty = true;
		}
	}

	public void MarkArtifactFound(ChapterID chapterId)
	{
		Chapter chapterById = GetChapterById(chapterId);
		if (chapterById != null)
		{
			chapterById.artifactComplete = true;
			savedDataIsDirty = true;
		}
	}

	public bool HasFoundArtifact(ChapterID chapterId)
	{
		return GetChapterById(chapterId)?.artifactComplete ?? false;
	}

	public void MarkChapterComplete(ChapterID chapterId, ChapterStatus chapterStatus, ChapterCompletionStatus chapterCompletionStatus)
	{
		Chapter chapterById = GetChapterById(chapterId);
		if (chapterById != null)
		{
			chapterById.completed = true;
			chapterById.chapterStatus = chapterStatus;
			chapterById.chapterCompletionStatus = chapterCompletionStatus;
			savedDataIsDirty = true;
		}
	}

	public bool HasCompletedChapter(ChapterID chapterId)
	{
		Chapter chapterById = GetChapterById(chapterId);
		if (chapterById != null)
		{
			if (chapterById.chapterStatus == ChapterStatus.COMPLETED || chapterById.chapterStatus == ChapterStatus.PLAYED_NOT_COMPLETED)
			{
				return true;
			}
			return false;
		}
		return false;
	}

	public Chapter GetChapterById(ChapterID chapterId)
	{
		if (savedGameData != null && savedGameData.gameChapters != null)
		{
			for (int i = 0; i < savedGameData.gameChapters.Length; i++)
			{
				Chapter chapter = savedGameData.gameChapters[i];
				if (chapter.chapterID == chapterId)
				{
					return chapter;
				}
			}
		}
		return null;
	}

	public void SavePicoGameData(int currentSavedGameSlot)
	{
		UnityEngine.Debug.Log("Saving data");
		List<byte[]> list = savedGameData.ConvertChaptersToData();
		byte[] item = PreferenceManager.instance.playerPreferencesToByteArray();
		List<byte[]> list2 = new List<byte[]> { item };
		foreach (byte[] item2 in list)
		{
			list2.Add(item2);
		}
		UnityEngine.Debug.Log("Number of chapters to be saved : " + list2.Count);
		BinaryFormatter binaryFormatter = new BinaryFormatter();
		MemoryStream memoryStream = new MemoryStream();
		binaryFormatter.Serialize(memoryStream, list2);
		memoryStream.ToArray();
		UnityEngine.Debug.Log("Saving in offline mode");
		FileStream fileStream = File.Create(Application.persistentDataPath + "/savedGame.gd");
		binaryFormatter.Serialize(fileStream, list2);
		fileStream.Close();
	}

	public void LoadPicoSavedData(int currentSavedGameSlot)
	{
		UnityEngine.Debug.Log("In offline mode or cloud save unavailable");
		if (!DoesExist(currentSavedGameSlot))
		{
			return;
		}
		UnityEngine.Debug.Log("Local saved game exists");
		BinaryFormatter binaryFormatter = new BinaryFormatter();
		FileStream serializationStream = new FileStream(Application.persistentDataPath + "/savedGame.gd", FileMode.Open);
		List<byte[]> list = binaryFormatter.Deserialize(serializationStream) as List<byte[]>;
		savedGameData = new GameData();
		UnityEngine.Debug.Log("Deleting all preferences");
		bool flag = PreferenceManager.instance.playerPreferencesFromByteArray(list[0], player.CurrentIntegrationType);
		UnityEngine.Debug.Log("Preferences loaded");
		bool flag2 = true;
		for (int i = 1; i < list.Count; i++)
		{
			if (!savedGameData.ConvertDataToChapters(list[i], list.Count))
			{
				flag2 = false;
			}
		}
		if (flag2 && flag)
		{
			savedDataLoaded = true;
			UnityEngine.Debug.Log("All chapter data loaded successfully");
			return;
		}
		savedDataLoaded = false;
		UnityEngine.Debug.Log("All chapter data not loaded");
		CreateNewProfile(currentSavedGameSlot);
		savedDataLoaded = true;
	}

	private void DeletePicoSavedData(int currentSavedGameSlot)
	{
		File.Delete(Application.persistentDataPath + "/savedGame.gd");
		PreferenceManager.instance.DeleteAll();
	}

	private bool DoesPicoSavedDataExist(int currentSavedGameSlot)
	{
		UnityEngine.Debug.Log("Checking if save exists in offline mode");
		return File.Exists(Application.persistentDataPath + "/savedGame.gd");
	}

	private void OnDestroy()
	{
		if (savedDataLoaded)
		{
			Save(currentSavedGameSlot);
		}
	}
}
public class ScreenFX : MonoBehaviour
{
	[Serializable]
	public enum ColourGradingProfileID
	{
		DEFAULT,
		PRECINCT,
		CHAPEL,
		CELL,
		NURSERY,
		MORGUE,
		MORGUE_BLUE,
		TOMB,
		TOMB_YELLOW
	}

	[Serializable]
	public class ColourGradingProfiles
	{
		public ColourGradingProfileID colourGradingProfileID;

		public UnityEngine.Color colourFilter = UnityEngine.Color.white;

		public float hueShift;

		public float saturation = -20f;

		public float brightnesss;

		public float contrast;

		public float postExposure;
	}

	public enum FadeType
	{
		FADE_IN,
		FADE_OUT
	}

	[SerializeField]
	private VignetteAndChromaticAberration vignette;

	[SerializeField]
	private BlurOptimized blur;

	[SerializeField]
	private ColourGradingProfiles[] colourGradingProfileCollection;

	private float fadeTime = 2f;

	public bool isInitialised;

	private NVRPlayer player;

	public bool isFading;

	public bool isFadingBlur;

	private bool isCameraShaking;

	private bool isFadingLUT;

	[HideInInspector]
	public float cameraShakeAmount;

	[SerializeField]
	private Material fadeMaterial;

	private void Awake()
	{
		if (!isInitialised)
		{
			MeshFilter meshFilter = base.gameObject.GetComponent<MeshFilter>();
			if (meshFilter == null)
			{
				meshFilter = base.gameObject.AddComponent<MeshFilter>();
			}
			MeshRenderer meshRenderer = base.gameObject.GetComponent<MeshRenderer>();
			if (meshRenderer == null)
			{
				meshRenderer = base.gameObject.AddComponent<MeshRenderer>();
			}
			meshRenderer.enabled = true;
			Mesh mesh2 = (meshFilter.mesh = new Mesh());
			meshRenderer.material = fadeMaterial;
			Vector3[] array = new Vector3[4];
			float num = 2f;
			float num2 = 2f;
			float z = 1f;
			array[0] = new Vector3(0f - num, 0f - num2, z);
			array[1] = new Vector3(num, 0f - num2, z);
			array[2] = new Vector3(0f - num, num2, z);
			array[3] = new Vector3(num, num2, z);
			mesh2.vertices = array;
			mesh2.triangles = new int[6] { 0, 2, 1, 2, 3, 1 };
			mesh2.normals = new Vector3[4]
			{
				-Vector3.forward,
				-Vector3.forward,
				-Vector3.forward,
				-Vector3.forward
			};
			mesh2.uv = new Vector2[4]
			{
				new Vector2(0f, 0f),
				new Vector2(1f, 0f),
				new Vector2(0f, 1f),
				new Vector2(1f, 1f)
			};
		}
	}

	private void Start()
	{
		player = GameController.instance.player;
		SetStandardPostProcessingProfile();
	}

	public void SetStandardPostProcessingProfile()
	{
		isInitialised = true;
	}

	public void SetChapter3PostProcessingProfile()
	{
	}

	public void ShakeCamera(float shakeLevel = 0f)
	{
		StopCoroutine(ShakeCameraRoutine());
		cameraShakeAmount = shakeLevel;
		isCameraShaking = true;
		StartCoroutine(ShakeCameraRoutine());
	}

	public void StopCameraShake()
	{
		isCameraShaking = false;
		StopCoroutine(ShakeCameraRoutine());
	}

	private IEnumerator ShakeCameraRoutine()
	{
		_ = UnityEngine.Random.insideUnitSphere * cameraShakeAmount;
		while (isCameraShaking)
		{
			Vector3 random = UnityEngine.Random.insideUnitSphere * cameraShakeAmount;
			player.transform.localPosition = player.transform.localPosition + random;
			yield return Yield.WaitSeconds(0.05f);
			player.transform.localPosition = player.transform.localPosition - random;
		}
	}

	public void Fade(UnityEngine.Color newColor, float duration)
	{
		StartCoroutine(FadeScreen(newColor, duration));
	}

	private IEnumerator FadeScreen(UnityEngine.Color newColor, float duration)
	{
		isFading = true;
		if (duration > 0.01f)
		{
			UnityEngine.Color currentColor = fadeMaterial.color;
			UnityEngine.Color dif = newColor - currentColor;
			for (float t = 0f; t < 1f; t += Time.deltaTime / duration)
			{
				fadeMaterial.color = currentColor + dif * t;
				yield return new WaitForEndOfFrame();
			}
			fadeMaterial.color = newColor;
		}
		else
		{
			fadeMaterial.color = newColor;
		}
		isFading = false;
	}

	public void BlurScreen(bool enabled, bool fade = false, float fadeDuration = 0.5f)
	{
		if (!fade)
		{
			if (enabled)
			{
				blur.downsample = 0;
				blur.blurSize = 0f;
				blur.blurIterations = 0;
				blur.blurType = BlurOptimized.BlurType.StandardGauss;
			}
			else
			{
				blur.downsample = 1;
				blur.blurSize = 2f;
				blur.blurIterations = 2;
				blur.blurType = BlurOptimized.BlurType.StandardGauss;
			}
		}
		else
		{
			StartCoroutine(FadeBlur(fadeDuration, enabled));
		}
	}

	private IEnumerator FadeBlur(float duration, bool finishOn)
	{
		if (isFadingBlur)
		{
			yield break;
		}
		isFadingBlur = true;
		if (!(duration > 0.01f))
		{
			yield break;
		}
		if (finishOn)
		{
			blur.downsample = 1;
			blur.blurIterations = 2;
			blur.blurType = BlurOptimized.BlurType.StandardGauss;
			for (float t = 2f; t > 0.1f; t -= Time.deltaTime)
			{
				blur.blurSize = t;
				yield return Yield.EndOfFrame;
			}
		}
		else
		{
			blur.downsample = 0;
			blur.blurIterations = 0;
			blur.blurType = BlurOptimized.BlurType.StandardGauss;
			for (float t = 0.1f; t < 2f; t += Time.deltaTime)
			{
				blur.blurSize = t;
				yield return Yield.EndOfFrame;
			}
		}
		isFadingBlur = false;
	}

	public void SetBlur(float fStop)
	{
		blur.downsample = 1;
		blur.blurSize = fStop;
		blur.blurIterations = 2;
		blur.blurType = BlurOptimized.BlurType.StandardGauss;
	}

	public void DisableColourGrading()
	{
	}

	public void EnableColorGrading()
	{
	}

	public void SetColourGradingAndFadeIn(ColourGradingProfileID colourGradingProfileID, float duration)
	{
	}

	public void FadeOutColourGrading(ColourGradingProfileID colourGradingProfileID, float duration)
	{
	}

	private IEnumerator FadeColourGradingRoutine(ColourGradingProfiles colourGradingProfiles, float duration, FadeType type)
	{
		yield return new WaitForEndOfFrame();
	}

	public void PeripheralFade(float intensity)
	{
	}

	public void FreeRotationPeripheralFade(float intensity)
	{
	}

	public void FreeMovementPeripheralFade(float intensity)
	{
	}

	private void OnApplicationQuit()
	{
		fadeMaterial.color = new UnityEngine.Color(1f, 1f, 1f, 0f);
	}
}
public class SightTrigger : InteractionManager
{
	private InteractionManager manager;

	private void Start()
	{
		EventManager.StartListening(EventManager.AvailableEvents.SwitchedScenes.ToString(), UpdateManager);
	}

	private new void OnTriggerEnter(Collider other)
	{
		if (manager != null)
		{
			manager.OnSightTriggerEnter(other);
		}
	}

	private new void OnTriggerExit(Collider other)
	{
		if (manager != null)
		{
			manager.OnSightTriggerExit(other);
		}
	}

	private new void OnTriggerStay(Collider other)
	{
		if (manager != null)
		{
			manager.OnSightTriggerStay(other);
		}
	}

	private void UpdateManager()
	{
		while (manager == null)
		{
			manager = GameObject.Find("Scene").GetComponent<InteractionManager>();
		}
	}
}
public class SoundObject : MonoBehaviour
{
	protected AudioScriptPooled audioScript;

	[SerializeField]
	protected AudioClip collisionSoundSoft;

	[SerializeField]
	protected AudioClip collisionSoundHard;

	public float maxVol = 1f;

	private float minVolume = 0.1f;

	private float maxVelocity = 5f;

	public bool randomPitch = true;

	[SerializeField]
	private float lowPitchRange = 0.8f;

	[SerializeField]
	private float highPitchRange = 1.2f;

	private float velToVol = 0.18f;

	private float velocityClipSplit = 10f;

	public bool collisionActive = true;

	protected virtual void Start()
	{
		if (!base.gameObject.GetComponent<AudioScriptPooled>())
		{
			audioScript = base.gameObject.AddComponent<AudioScriptPooled>();
		}
		else
		{
			audioScript = base.gameObject.GetComponent<AudioScriptPooled>();
		}
	}

	protected virtual void OnCollisionEnter(Collision collision)
	{
		if (!(collision.gameObject.name == "Head") && !(collision.gameObject.name == "CenterEyePoint") && collisionActive && GameController.instance.audioSourcePool.CanPlaySFX)
		{
			PlaySound(collision);
		}
	}

	protected void PlaySound(Collision collision)
	{
		float pitch = (randomPitch ? UnityEngine.Random.Range(lowPitchRange, highPitchRange) : 1f);
		float num = Mathf.Clamp(collision.relativeVelocity.magnitude * velToVol, 0.1f, maxVol);
		if ((bool)collision.collider.GetComponent<SoundObject>())
		{
			num /= 2f;
		}
		float magnitude = collision.relativeVelocity.magnitude;
		if (!(magnitude > 0f))
		{
			return;
		}
		SoundType component = collision.gameObject.GetComponent<SoundType>();
		if (component != null)
		{
			if (component.GetSoundType() == SoundType.SOUNDTYPES.BRIGHT)
			{
				audioScript.SetMixerChannel(AudioScript.MixerChannel.collisionBright);
			}
			else if (component.GetSoundType() == SoundType.SOUNDTYPES.DULL)
			{
				audioScript.SetMixerChannel(AudioScript.MixerChannel.collisionDull);
			}
		}
		else if (audioScript != null)
		{
			audioScript.SetMixerChannel(AudioScript.MixerChannel.sfx);
		}
		else
		{
			audioScript.SetMixerChannel(AudioScript.MixerChannel.sfx);
		}
		if (magnitude < velocityClipSplit && collisionSoundSoft != null)
		{
			audioScript.PlayOneShot(collisionSoundSoft, num, pitch);
		}
		else if (collisionSoundHard != null)
		{
			audioScript.PlayOneShot(collisionSoundHard, num, pitch);
		}
	}

	protected void PlaySound(Collision collision, AudioClip sound)
	{
		UnityEngine.Debug.Log("Playing sound on " + base.gameObject.name);
		float pitch = (randomPitch ? UnityEngine.Random.Range(lowPitchRange, highPitchRange) : 1f);
		float num = Mathf.Clamp(collision.relativeVelocity.magnitude * velToVol, 0.1f, maxVol);
		if ((bool)collision.collider.GetComponent<SoundObject>())
		{
			num /= 2f;
		}
		SoundType component = collision.gameObject.GetComponent<SoundType>();
		if (component != null)
		{
			if (component.GetSoundType() == SoundType.SOUNDTYPES.BRIGHT)
			{
				audioScript.SetMixerChannel(AudioScript.MixerChannel.collisionBright);
			}
			else if (component.GetSoundType() == SoundType.SOUNDTYPES.DULL)
			{
				audioScript.SetMixerChannel(AudioScript.MixerChannel.collisionDull);
			}
		}
		else
		{
			audioScript.SetMixerChannel(AudioScript.MixerChannel.sfx);
		}
		audioScript.PlayOneShot(sound, num, pitch);
	}
}
public class SoundType : MonoBehaviour
{
	public enum SOUNDTYPES
	{
		DULL,
		BRIGHT
	}

	[SerializeField]
	private SOUNDTYPES type = SOUNDTYPES.BRIGHT;

	public SOUNDTYPES GetSoundType()
	{
		return type;
	}
}
[Serializable]
public class TranslateDictionary
{
	[Serializable]
	public struct KeyPair
	{
		public string key;

		public string value;
	}

	public KeyPair[] KeyPairs;

	public static TranslateDictionary CreateFromJSON(string jsonString)
	{
		return JsonUtility.FromJson<TranslateDictionary>(jsonString);
	}
}
public class Translator : MonoBehaviour
{
	private Dictionary<string, string> translations = new Dictionary<string, string>();

	private string language;

	public void Initialise(string languagePreference)
	{
		if (translations.Count > 0)
		{
			translations.Clear();
		}
		language = languagePreference;
		PopulateDictionary();
	}

	public void PopulateDictionary()
	{
		TranslateDictionary.KeyPair[] keyPairs = TranslateDictionary.CreateFromJSON(File.ReadAllText(Application.dataPath + "/StreamingAssets/Translations/" + language + ".json")).KeyPairs;
		for (int i = 0; i < keyPairs.Length; i++)
		{
			TranslateDictionary.KeyPair keyPair = keyPairs[i];
			translations.Add(keyPair.key, keyPair.value);
		}
	}

	public string TranslateText(string text)
	{
		if (translations != null)
		{
			if (translations.ContainsKey(text.ToLower()))
			{
				return translations[text.ToLower()];
			}
			return text;
		}
		return text;
	}

	public string TranslateImage(string image)
	{
		return image + "_" + language;
	}
}
public class AdditiveLoadingTest : MonoBehaviour
{
	private int nextLevel;

	private void Start()
	{
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.L))
		{
			LoadLevel();
		}
	}

	private void LoadLevel()
	{
		nextLevel++;
		switch (nextLevel)
		{
		case 1:
			SceneManager.LoadScene("MiddleScene", LoadSceneMode.Additive);
			break;
		case 2:
			SceneManager.UnloadSceneAsync("MiddleScene");
			SceneManager.LoadScene("EndScene", LoadSceneMode.Additive);
			break;
		}
	}
}
public class ArtifactsScene : InteractionManager
{
	private NVRPlayer player;

	private Locomotion playerMovement;

	private Light playerLight;

	private ScreenFX screenEffects;

	[SerializeField]
	private GameObject playerStartPosition;

	private void Start()
	{
		UnityEngine.Debug.LogError("Artifact scene");
		player = GameObject.FindGameObjectWithTag("Player").GetComponent<NVRPlayer>();
		player.transform.position = new Vector3(playerStartPosition.transform.position.x, player.transform.position.y, playerStartPosition.transform.position.z);
		player.transform.eulerAngles = playerStartPosition.transform.eulerAngles;
		playerMovement = player.Head.GetComponent<Locomotion>();
		screenEffects = player.Head.GetComponentInChildren<ScreenFX>();
		screenEffects.Fade(UnityEngine.Color.black, 0.1f);
		playerLight = GameObject.Find("Player/PlayerLight").GetComponent<Light>();
		playerLight.enabled = false;
		StartCoroutine(Master());
	}

	private IEnumerator Master()
	{
		yield return StartCoroutine(FadeInScene());
	}

	private IEnumerator FadeInScene()
	{
		GameController.instance.audioController.SnapAllOpen(3f);
		screenEffects.Fade(UnityEngine.Color.clear, 3f);
		yield return Yield.WaitSeconds(3f);
		playerMovement.EnableEverything();
	}

	private void Update()
	{
	}

	public override void BeginInteraction(NVRInteractable interactable)
	{
	}

	public override void OnTriggerEnter(Collider collider)
	{
	}

	public override void OnSightTriggerEnter(Collider other)
	{
	}
}
public class ChessPiece : MonoBehaviour
{
	public List<GameObject> currentlyColliding = new List<GameObject>();

	private bool piecePlaced;

	private GameObject placedLocation;

	private Rigidbody rg;

	private Collider col;

	private void Start()
	{
		rg = GetComponent<Rigidbody>();
		col = GetComponent<Collider>();
	}

	private void OnTriggerEnter(Collider other)
	{
		if ((bool)other.GetComponentInParent<Chessboard>() && other.transform.parent.name == "Colliders" && !currentlyColliding.Contains(other.gameObject))
		{
			currentlyColliding.Add(other.gameObject);
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if ((bool)other.GetComponentInParent<Chessboard>() && other.transform.parent.name == "Colliders" && currentlyColliding.Contains(other.gameObject))
		{
			currentlyColliding.Remove(other.gameObject);
		}
	}

	public void SetChessPiece()
	{
		if (currentlyColliding.Count > 0)
		{
			GameObject gameObject = currentlyColliding[0];
			if (gameObject.GetComponentInParent<Chessboard>().CheckPlacementOpen(gameObject))
			{
				base.transform.position = gameObject.transform.position;
				base.transform.rotation = Quaternion.identity;
				placedLocation = gameObject;
				piecePlaced = true;
				rg.useGravity = false;
				rg.isKinematic = true;
				col.isTrigger = true;
				base.transform.parent = gameObject.GetComponentInParent<Chessboard>().chessBoardCompartment.transform;
			}
		}
	}

	public void PickupChessPiece()
	{
		if (piecePlaced)
		{
			placedLocation.GetComponentInParent<Chessboard>().RemovePlacedPiece(placedLocation);
			piecePlaced = false;
			placedLocation = null;
			rg.isKinematic = false;
			rg.useGravity = true;
			col.isTrigger = false;
		}
	}

	private void Update()
	{
	}
}
public class InstanceTest : MonoBehaviour
{
	public int count = 10;

	public GameObject prefab;

	public GameObject parentTo;

	public Vector3 range;

	private void Start()
	{
		for (int i = 0; i < count; i++)
		{
			GameObject obj = UnityEngine.Object.Instantiate(prefab);
			obj.transform.position = GetRandomPosition();
			obj.transform.localScale = GetRandomScale();
			obj.transform.eulerAngles = GetRandomRotation();
			obj.transform.parent = parentTo.transform;
		}
	}

	private void Update()
	{
		parentTo.transform.RotateAround(parentTo.transform.position, Vector3.up, 1f);
	}

	private Vector3 GetRandomScale()
	{
		float num = UnityEngine.Random.Range(0.5f, 1f);
		return new Vector3(num, num, num);
	}

	private Vector3 GetRandomPosition()
	{
		return new Vector3(UnityEngine.Random.Range(0f - range.x, range.x), UnityEngine.Random.Range(0f - range.y, range.y), UnityEngine.Random.Range(0f - range.z, range.z));
	}

	private Vector3 GetRandomRotation()
	{
		return new Vector3(UnityEngine.Random.Range(-180, 180), UnityEngine.Random.Range(-180, 180), UnityEngine.Random.Range(-180, 180));
	}
}
public class LocomotionTest : MonoBehaviour
{
	public GameObject door;

	private void Start()
	{
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.UpArrow))
		{
			door.SetActive(value: true);
		}
		else if (Input.GetKeyDown(KeyCode.DownArrow))
		{
			door.SetActive(value: false);
		}
	}
}
public class BoundDetectionTest : MonoBehaviour
{
	private GameObject playerHead;

	public GameObject img;

	private void Start()
	{
		playerHead = GameObject.Find("Player/Head");
	}

	private void OnTriggerEnter(Collider other)
	{
		_ = other.gameObject == playerHead;
	}

	private void OnTriggerExit(Collider other)
	{
		_ = other.gameObject == playerHead;
	}
}
[Serializable]
public class TextObject
{
	[Serializable]
	public struct TextLine
	{
		public string text;

		public float waitTime;
	}

	public TextLine[] dialog;

	public static TextObject CreateFromJSON(string jsonString)
	{
		return JsonUtility.FromJson<TextObject>(jsonString);
	}
}
public class TuneController : MonoBehaviour
{
	private GameObject[] tuneTargetLocations;

	private GameObject targetObject;

	[HideInInspector]
	public int currentTuneTarget;

	private NVRHand hand;

	public ExorcismItem interactable;

	private NVRPlayer player;

	[Range(0f, 180f)]
	[SerializeField]
	private float startTuningAt = 30f;

	[SerializeField]
	public GameObject tuningUI;

	private float tuneValue;

	private bool tune;

	[SerializeField]
	private GameObject theLight;

	[SerializeField]
	private LightFlicker flicker;

	[SerializeField]
	private WindZone windZone;

	private float windZoneOriginalRadius;

	public LightFlicker crossShapeLight;

	private GameObject lightTarget;

	[SerializeField]
	private ParticleSystem particlesTune;

	[HideInInspector]
	public ParticleSystem extraParticlesTune;

	[SerializeField]
	private ParticleSystem particlesTuneComplete;

	[SerializeField]
	private GameObject hitTargetShot;

	[SerializeField]
	private LightFlicker hologramLight;

	private float timeLimit;

	private float holdTime;

	public float holdTimeVar;

	private float tunePercentage;

	[HideInInspector]
	public bool hitSuccess;

	[HideInInspector]
	public bool failed;

	[HideInInspector]
	public bool tuneSuccess;

	[HideInInspector]
	public bool hittingTarget;

	private bool castLight;

	[SerializeField]
	private Material jesusGlowMat;

	[Header("Audio")]
	[SerializeField]
	private AudioScript crossAudioBackground;

	[SerializeField]
	private AudioScript crossAudioSFX;

	[SerializeField]
	private AudioClip earthquakeClip;

	[SerializeField]
	private AudioClip tuneBuildClip;

	[SerializeField]
	private AudioClip hitTargetClip;

	[SerializeField]
	private AudioClip tunedClip;

	private float randomX;

	private float randomZ;

	private bool hapticFeedbackLoop;

	public bool keepTheLightOn;

	private int layerMask = 2048;

	private float exorcismDistance = 100f;

	[Space]
	[SerializeField]
	private GameObject areaLight;

	[Space]
	[Header("Cross Upgrade")]
	[SerializeField]
	public Material crossStandardMaterial;

	[SerializeField]
	public Material crossStandardFadeMaterial;

	[SerializeField]
	public Material crossUpgradeMaterial;

	[SerializeField]
	public Material crossUpgradeFadeMaterial;

	[SerializeField]
	private MeshRenderer crossBrassRenderer;

	[SerializeField]
	private MeshRenderer crossRenderer;

	public bool upgraded;

	private bool pauseCrossTune;

	private bool pauseHapticFeedback;

	private bool overrideTuneSuccess;

	private bool overrideHitSuccess;

	private bool pauseCrossLightAndAudio;

	public float HoldTime
	{
		get
		{
			return holdTime;
		}
		set
		{
			holdTime = value;
			if (holdTime < 0f)
			{
				holdTime = 0f;
			}
			UnityEngine.Debug.Log("New tune hold time: " + holdTime);
		}
	}

	public bool PauseCrossTuning
	{
		get
		{
			return pauseCrossTune;
		}
		set
		{
			pauseCrossTune = value;
		}
	}

	public bool PauseHapticFeedback
	{
		get
		{
			return pauseHapticFeedback;
		}
		set
		{
			pauseHapticFeedback = value;
		}
	}

	public bool OverrideTuneSuccess
	{
		get
		{
			return overrideTuneSuccess;
		}
		set
		{
			overrideTuneSuccess = value;
		}
	}

	public bool OverrideHitSuccess
	{
		get
		{
			return overrideHitSuccess;
		}
		set
		{
			overrideHitSuccess = value;
		}
	}

	public bool PauseCrossLightAndAudio
	{
		get
		{
			return pauseCrossLightAndAudio;
		}
		set
		{
			pauseCrossLightAndAudio = value;
			if (pauseCrossLightAndAudio)
			{
				crossAudioSFX.FadeVolumeOut(0.25f);
			}
		}
	}

	public bool IsTuningOnTarget
	{
		get
		{
			float num = tunePercentage + holdTime / holdTimeVar * 0.1f;
			if (tuneValue > num)
			{
				return Vector3.Distance(base.gameObject.transform.position, tuneTargetLocations[currentTuneTarget].transform.position) < exorcismDistance;
			}
			return false;
		}
	}

	public void SetPointLightEnabled(bool enabled)
	{
		flicker.gameObject.SetActive(enabled);
	}

	public void SetSpotLightEnabled(bool enabled)
	{
		crossShapeLight.gameObject.SetActive(enabled);
	}

	private void Start()
	{
		player = GameController.instance.player;
		interactable = GetComponent<ExorcismItem>();
		upgraded = SaveManager.instance.HasFoundArtifact(ChapterID.MORGUE);
		windZoneOriginalRadius = windZone.radius;
		if (upgraded)
		{
			UpgradeCross(upgrade: true);
		}
		else
		{
			UpgradeCross(upgrade: false);
		}
		theLight.SetActive(value: false);
		tuningUI.SetActive(value: false);
		hitTargetShot.SetActive(value: false);
	}

	public void UpgradeCross(bool upgrade)
	{
		upgraded = upgrade;
		if (upgrade)
		{
			crossUpgradeMaterial.SetColor("_EmissionColor", UnityEngine.Color.black);
			crossRenderer.material = crossUpgradeMaterial;
			crossBrassRenderer.material = crossUpgradeMaterial;
		}
		else
		{
			crossStandardMaterial.SetColor("_EmissionColor", UnityEngine.Color.black);
			crossRenderer.material = crossStandardMaterial;
			crossBrassRenderer.material = crossStandardMaterial;
		}
	}

	public void TheLight(bool isEnabled)
	{
		UnityEngine.Debug.Log("The Light isEnabled = " + isEnabled);
		theLight.SetActive(isEnabled);
		if (!isEnabled)
		{
			if (upgraded)
			{
				crossUpgradeMaterial.SetColor("_EmissionColor", UnityEngine.Color.black);
			}
			else
			{
				crossStandardMaterial.SetColor("_EmissionColor", UnityEngine.Color.black);
			}
		}
	}

	public void TheLightFull()
	{
		theLight.SetActive(value: true);
		if (upgraded)
		{
			crossUpgradeMaterial.SetColor("_EmissionColor", UnityEngine.Color.white);
		}
		else
		{
			crossStandardMaterial.SetColor("_EmissionColor", UnityEngine.Color.white);
		}
	}

	private void Update()
	{
		if ((interactable.AttachedHand == null || interactable.inKit) && !failed)
		{
			failed = true;
			tuningUI.SetActive(value: false);
			if (keepTheLightOn)
			{
				tune = false;
				StopSFX();
				StopBackground();
				StopCoroutine("FireLightRay");
				ControlHaptic(runLoop: false);
			}
			else
			{
				StopAll();
			}
		}
		else if (targetObject != null)
		{
			Vector3 vector = base.transform.TransformDirection(Vector3.up);
			UnityEngine.Debug.DrawRay(base.transform.position, vector, UnityEngine.Color.green);
			if (Physics.Raycast(base.transform.position, vector, out var hitInfo, 15f, layerMask))
			{
				if (hitInfo.collider.gameObject == targetObject.gameObject)
				{
					hittingTarget = true;
				}
				else
				{
					hittingTarget = false;
				}
			}
			else
			{
				hittingTarget = false;
			}
		}
		if (tune)
		{
			CompareVectors();
			timeLimit -= Time.deltaTime;
		}
	}

	private void CompareVectors()
	{
		Vector3 from = base.transform.position - targetObject.transform.position;
		tuneValue = 1f - Mathf.Clamp(Vector3.Angle(from, -base.gameObject.transform.up), 0f, startTuningAt) / startTuningAt;
		if (!pauseCrossLightAndAudio)
		{
			UnityEngine.Color value = new UnityEngine.Color(tuneValue, tuneValue, tuneValue, 1f);
			new UnityEngine.Color(tuneValue, tuneValue, tuneValue, 1f);
			if (upgraded)
			{
				crossUpgradeMaterial.SetColor("_EmissionColor", value);
			}
			else
			{
				crossStandardMaterial.SetColor("_EmissionColor", value);
			}
		}
		float num = tunePercentage + holdTime / holdTimeVar * 0.1f;
		if ((bool)crossAudioBackground)
		{
			crossAudioBackground.m_AudioSource.volume = Mathf.Clamp01(holdTime / holdTimeVar) * 0.7f;
		}
		if ((bool)crossAudioSFX && !pauseCrossLightAndAudio)
		{
			if (!crossAudioSFX.m_AudioSource.isPlaying)
			{
				crossAudioSFX.PlayLoop(tuneBuildClip);
			}
			crossAudioSFX.m_AudioSource.volume = Mathf.Clamp(tuneValue, 0.2f, 1f);
		}
		hologramLight.SetIntensity(1f - Mathf.Clamp(Vector3.Angle(from, -base.gameObject.transform.up), 0f, hologramLight.light.spotAngle) / hologramLight.light.spotAngle);
		int num2 = (int)(holdTime / holdTimeVar * 200f);
		ParticleSystem.EmissionModule emission = particlesTune.emission;
		emission.rateOverTime = new ParticleSystem.MinMaxCurve(num2 / 2, num2);
		if ((bool)extraParticlesTune)
		{
			ParticleSystem.EmissionModule emission2 = extraParticlesTune.emission;
			emission2.rateOverTime = new ParticleSystem.MinMaxCurve(num2 / 2, num2);
		}
		if (!tuneSuccess)
		{
			if (tuneValue > num && Vector3.Distance(base.gameObject.transform.position, tuneTargetLocations[currentTuneTarget].transform.position) < exorcismDistance)
			{
				if ((bool)interactable.AttachedHand && !pauseHapticFeedback)
				{
					interactable.AttachedHand.TriggerHapticPulse(5f);
				}
				if (holdTime > holdTimeVar)
				{
					UnityEngine.Debug.Log("TUNE CONTROLLER SUCCESSFUL");
					tuneSuccess = true;
					if (!overrideTuneSuccess)
					{
						RunTuneSuccess();
					}
				}
				else if (holdTime / holdTimeVar > (float)(currentTuneTarget + 1) * (1f / (float)tuneTargetLocations.Length))
				{
					currentTuneTarget++;
					LeanTween.move(targetObject.transform.parent.gameObject, tuneTargetLocations[currentTuneTarget].transform.position, 1f);
				}
				if (!pauseCrossTune)
				{
					holdTime += Time.deltaTime;
				}
			}
			else if ((bool)interactable.AttachedHand && !pauseHapticFeedback)
			{
				interactable.AttachedHand.TriggerHapticPulse(tuneValue * 5f);
			}
		}
		else if ((bool)interactable.AttachedHand && !pauseHapticFeedback)
		{
			interactable.AttachedHand.TriggerHapticPulse(5f);
		}
	}

	public void RunTuneSuccess()
	{
		StopTuning();
		interactable.LockToHand(isLocked: true);
		hologramLight.Fade(on: false, 1f);
	}

	public void StartTuning(GameObject target, GameObject[] locations, float holdTimeParam, float maxTime, bool isSlowMo, float basePercentage = 0.8f, float dist = 100f, bool reposition = true)
	{
		failed = false;
		hitSuccess = false;
		tuneSuccess = false;
		timeLimit = maxTime;
		holdTime = 0f;
		tune = true;
		exorcismDistance = dist;
		targetObject = target;
		tuneTargetLocations = locations;
		currentTuneTarget = 0;
		tunePercentage = basePercentage;
		if (reposition)
		{
			targetObject.transform.parent.position = tuneTargetLocations[0].transform.position;
		}
		particlesTune.gameObject.SetActive(value: true);
		particlesTune.Play();
		if ((bool)extraParticlesTune)
		{
			extraParticlesTune.gameObject.SetActive(value: true);
			extraParticlesTune.Play();
		}
		flicker.light.range = 0.5f;
		particlesTuneComplete.Stop();
		particlesTuneComplete.gameObject.SetActive(value: false);
		hologramLight.gameObject.SetActive(value: true);
		hologramLight.SwitchLight(switchOn: false);
		holdTimeVar = holdTimeParam;
		if (isSlowMo)
		{
			holdTimeVar *= 0.25f;
			crossAudioBackground.m_AudioSource.pitch = 1f;
			crossAudioSFX.m_AudioSource.pitch = 1f;
		}
		if ((bool)crossAudioBackground && (bool)earthquakeClip)
		{
			crossAudioBackground.PlayLoop(earthquakeClip, 0f);
		}
		if ((bool)crossAudioSFX && (bool)tuneBuildClip)
		{
			crossAudioSFX.PlayLoop(tuneBuildClip, 0f);
		}
	}

	public void StopTuning()
	{
		if (failed)
		{
			TheLight(isEnabled: false);
		}
		tune = false;
		particlesTune.Stop();
		if ((bool)extraParticlesTune)
		{
			extraParticlesTune.Stop();
		}
	}

	public void StopBackground()
	{
		crossAudioBackground.StopLoop();
	}

	public void FadeBackground(float fadeTime)
	{
		crossAudioBackground.FadeOut(fadeTime);
	}

	public void StopSFX()
	{
		crossAudioSFX.StopLoop();
	}

	public void FadeSFX(float fadeTime)
	{
		crossAudioSFX.FadeOut(fadeTime);
	}

	public void StartLightTarget(GameObject target, bool isSlowMo = false)
	{
		if (tuneSuccess && !overrideTuneSuccess)
		{
			castLight = true;
			lightTarget = target;
			StartCoroutine(FireLightRay());
		}
	}

	public void StopAll()
	{
		StopTuning();
		StopLightTarget();
		StopBackground();
		StopSFX();
	}

	public void StopLightTarget(bool fadeOut = false)
	{
		castLight = false;
		if (fadeOut)
		{
			crossAudioBackground.FadeOut(1f);
			crossAudioSFX.FadeOut(1f);
		}
		else
		{
			crossAudioBackground.StopLoop();
			crossAudioSFX.StopLoop();
		}
		TheLight(isEnabled: false);
		StopCoroutine("FireLightRay");
		ControlHaptic(runLoop: false);
		if (upgraded)
		{
			crossUpgradeMaterial.SetColor("_EmissionColor", UnityEngine.Color.black);
		}
		else
		{
			crossStandardMaterial.SetColor("_EmissionColor", UnityEngine.Color.black);
		}
	}

	public void FadeLightTarget(float fadeTime = 1f)
	{
		StartCoroutine(FadeLightTarget(UnityEngine.Color.white, UnityEngine.Color.black, fadeTime));
	}

	private IEnumerator FadeLightTarget(UnityEngine.Color fromColour, UnityEngine.Color toColour, float fadeTime)
	{
		castLight = false;
		StopCoroutine("FireLightRay");
		particlesTuneComplete.Stop();
		ControlHaptic(runLoop: false, fadeOut: true, fadeTime);
		for (float crossBrightness = 1.5f; crossBrightness > 0f; crossBrightness -= Time.deltaTime / fadeTime)
		{
			if (crossBrightness <= 1f)
			{
				fromColour = new UnityEngine.Color(crossBrightness, crossBrightness, crossBrightness, 1f);
				crossAudioBackground.m_AudioSource.volume = crossBrightness;
				crossAudioSFX.m_AudioSource.volume = crossBrightness;
				if (upgraded)
				{
					crossUpgradeMaterial.SetColor("_EmissionColor", fromColour);
				}
				else
				{
					crossStandardMaterial.SetColor("_EmissionColor", fromColour);
				}
			}
			crossShapeLight.light.intensity = crossBrightness;
			yield return null;
		}
		UnityEngine.Debug.Log("Finished Fade on cross");
		TheLight(isEnabled: false);
		StopTuning();
	}

	private IEnumerator FireLightRay()
	{
		if (upgraded)
		{
			crossUpgradeMaterial.SetColor("_EmissionColor", UnityEngine.Color.white);
		}
		else
		{
			crossStandardMaterial.SetColor("_EmissionColor", UnityEngine.Color.white);
		}
		particlesTuneComplete.gameObject.SetActive(value: true);
		particlesTuneComplete.Play();
		if ((bool)crossAudioSFX && (bool)tunedClip)
		{
			crossAudioSFX.PlayOne(tunedClip);
		}
		while (castLight && (bool)lightTarget)
		{
			if (!overrideHitSuccess)
			{
				Vector3 direction = base.transform.TransformDirection(Vector3.up);
				if ((bool)interactable.AttachedHand)
				{
					interactable.AttachedHand.TriggerHapticPulse(5f);
				}
				if (Physics.Raycast(base.transform.position, direction, out var hitInfo, 15f, layerMask) && hitInfo.collider.gameObject == lightTarget)
				{
					hitSuccess = true;
					break;
				}
			}
			yield return null;
		}
	}

	public void ShootBeam(bool withAudio = true, bool disableLight = true, bool keepLockedToHand = false, bool instant = false)
	{
		StartCoroutine(ShootBeamRoutine(withAudio, disableLight, keepLockedToHand, instant));
	}

	private IEnumerator ShootBeamRoutine(bool withAudio, bool disableLight, bool keepLockedToHand, bool instant)
	{
		if (withAudio)
		{
			if (!instant)
			{
				yield return new WaitForSecondsRealtime(2f);
			}
			if ((bool)crossAudioSFX && (bool)hitTargetClip)
			{
				crossAudioSFX.PlayOne(hitTargetClip);
			}
			hitTargetShot.SetActive(value: true);
			ControlHaptic(runLoop: false);
			yield return new WaitForSecondsRealtime(2f);
			if (disableLight)
			{
				StopLightTarget(fadeOut: true);
			}
			hitTargetShot.SetActive(value: false);
			if (!keepLockedToHand)
			{
				interactable.LockToHand(isLocked: false);
			}
		}
		else
		{
			hitTargetShot.SetActive(value: true);
			yield return new WaitForSecondsRealtime(2f);
			hitTargetShot.SetActive(value: false);
		}
	}

	private void ControlHaptic(bool runLoop, bool fadeOut = false, float fadeTime = 1f)
	{
		if (runLoop)
		{
			hapticFeedbackLoop = true;
			StartCoroutine(RunHapticLoop());
			return;
		}
		hapticFeedbackLoop = false;
		if (fadeOut)
		{
			StartCoroutine(FadeHapticLoop(fadeTime));
		}
	}

	private IEnumerator FadeHapticLoop(float fadeTime)
	{
		float counter = 0f;
		float hapticLevel = 5f;
		while (counter < fadeTime)
		{
			counter += Time.deltaTime;
			hapticLevel = Mathf.Lerp(hapticLevel, 0f, counter / fadeTime);
			if ((bool)interactable.AttachedHand)
			{
				interactable.AttachedHand.TriggerHapticPulse(hapticLevel);
			}
			yield return null;
		}
	}

	private IEnumerator RunHapticLoop()
	{
		while (hapticFeedbackLoop)
		{
			if ((bool)interactable.AttachedHand)
			{
				interactable.AttachedHand.TriggerHapticPulse(5f);
			}
			yield return null;
		}
	}

	public void UpdateExorcismDistance(float dist)
	{
		exorcismDistance = dist;
	}

	public void AreaLight(bool active)
	{
		areaLight.SetActive(active);
		if (active)
		{
			jesusGlowMat.SetColor("_EmissionColor", new Color32(161, 159, 135, 235));
		}
		else
		{
			jesusGlowMat.SetColor("_EmissionColor", UnityEngine.Color.black);
		}
	}

	public void StartSnakeExorcism(float volume)
	{
		crossAudioBackground.FadeIn(earthquakeClip, volume, 1f, loop: true);
		crossShapeLight.light.intensity = 1.5f;
	}

	public void ShowMirrorWorldLight()
	{
		if (upgraded)
		{
			crossUpgradeMaterial.SetColor("_EmissionColor", UnityEngine.Color.white);
		}
		else
		{
			crossStandardMaterial.SetColor("_EmissionColor", UnityEngine.Color.white);
		}
	}

	public void HideMirrorWorldLight()
	{
		if (upgraded)
		{
			crossUpgradeMaterial.SetColor("_EmissionColor", UnityEngine.Color.black);
		}
		else
		{
			crossStandardMaterial.SetColor("_EmissionColor", UnityEngine.Color.black);
		}
	}

	public void SetWindRadius(float radius)
	{
		windZone.radius = radius;
	}

	public void ResetWindRadius()
	{
		windZone.radius = windZoneOriginalRadius;
	}

	public void SetStandardShader()
	{
		if (upgraded)
		{
			crossRenderer.material = crossUpgradeMaterial;
			crossBrassRenderer.material = crossUpgradeMaterial;
		}
		else
		{
			crossRenderer.material = crossStandardMaterial;
			crossBrassRenderer.material = crossStandardMaterial;
		}
	}

	public void SetDissolveShader()
	{
		if (upgraded)
		{
			crossRenderer.material = crossUpgradeFadeMaterial;
			crossBrassRenderer.material = crossUpgradeFadeMaterial;
		}
		else
		{
			crossRenderer.material = crossStandardFadeMaterial;
			crossBrassRenderer.material = crossStandardFadeMaterial;
		}
	}

	public IEnumerator StartFadeOut(float time)
	{
		for (float t = 1f; t > 0f; t -= Time.deltaTime / time)
		{
			crossRenderer.material.SetFloat("_Dissolve", t);
			crossBrassRenderer.material.SetFloat("_Dissolve", t);
			yield return null;
		}
		yield return null;
	}
}
public class VRDeviceNames
{
	public const string None = "None";

	public const string Unknown = "Unknown";

	public const string Oculus = "Oculus";

	public const string PlayStationVR = "PlayStationVR";
}
public static class Yield
{
	private static WaitForEndOfFrame _eof = new WaitForEndOfFrame();

	private static WaitForFixedUpdate _fu = new WaitForFixedUpdate();

	private static Dictionary<float, WaitForSeconds> _wfs = new Dictionary<float, WaitForSeconds>();

	private static Dictionary<float, WaitForSecondsRealtime> _wfsr = new Dictionary<float, WaitForSecondsRealtime>();

	public static WaitForEndOfFrame EndOfFrame => _eof;

	public static WaitForFixedUpdate EndOfFixedUpdate => _fu;

	public static WaitForSeconds WaitSeconds(float time)
	{
		if (!_wfs.ContainsKey(time))
		{
			_wfs.Add(time, new WaitForSeconds(time));
		}
		return _wfs[time];
	}
}
[Serializable]
public class LightControlBehaviour : PlayableBehaviour
{
	public UnityEngine.Color color = UnityEngine.Color.white;

	public float intensity = 1f;

	public float bounceIntensity = 1f;

	public float range = 10f;
}
[Serializable]
public class LightControlClip : PlayableAsset, ITimelineClipAsset
{
	public LightControlBehaviour template = new LightControlBehaviour();

	public ClipCaps clipCaps => ClipCaps.Blending;

	public override Playable CreatePlayable(PlayableGraph graph, GameObject owner)
	{
		return ScriptPlayable<LightControlBehaviour>.Create(graph, template);
	}
}
public class LightControlMixerBehaviour : PlayableBehaviour
{
	private UnityEngine.Color m_DefaultColor;

	private float m_DefaultIntensity;

	private float m_DefaultBounceIntensity;

	private float m_DefaultRange;

	private Light m_TrackBinding;

	private bool m_FirstFrameHappened;

	public override void ProcessFrame(Playable playable, FrameData info, object playerData)
	{
		m_TrackBinding = playerData as Light;
		if (m_TrackBinding == null)
		{
			return;
		}
		if (!m_FirstFrameHappened)
		{
			m_DefaultColor = m_TrackBinding.color;
			m_DefaultIntensity = m_TrackBinding.intensity;
			m_DefaultBounceIntensity = m_TrackBinding.bounceIntensity;
			m_DefaultRange = m_TrackBinding.range;
			m_FirstFrameHappened = true;
		}
		int inputCount = playable.GetInputCount();
		UnityEngine.Color clear = UnityEngine.Color.clear;
		float num = 0f;
		float num2 = 0f;
		float num3 = 0f;
		float num4 = 0f;
		float num5 = 0f;
		int num6 = 0;
		for (int i = 0; i < inputCount; i++)
		{
			float inputWeight = playable.GetInputWeight(i);
			LightControlBehaviour behaviour = ((ScriptPlayable<LightControlBehaviour>)playable.GetInput(i)).GetBehaviour();
			clear += behaviour.color * inputWeight;
			num += behaviour.intensity * inputWeight;
			num2 += behaviour.bounceIntensity * inputWeight;
			num3 += behaviour.range * inputWeight;
			num4 += inputWeight;
			if (inputWeight > num5)
			{
				num5 = inputWeight;
			}
			if (!Mathf.Approximately(inputWeight, 0f))
			{
				num6++;
			}
		}
		m_TrackBinding.color = clear + m_DefaultColor * (1f - num4);
		m_TrackBinding.intensity = num + m_DefaultIntensity * (1f - num4);
		m_TrackBinding.bounceIntensity = num2 + m_DefaultBounceIntensity * (1f - num4);
		m_TrackBinding.range = num3 + m_DefaultRange * (1f - num4);
		if (num6 != 1)
		{
			_ = 1f - num4;
		}
	}

	public override void OnGraphStop(Playable playable)
	{
		m_TrackBinding.color = m_DefaultColor;
		m_TrackBinding.intensity = m_DefaultIntensity;
		m_TrackBinding.bounceIntensity = m_DefaultBounceIntensity;
		m_TrackBinding.range = m_DefaultRange;
		m_FirstFrameHappened = false;
	}
}
[TrackColor(0.9454092f, 0.9779412f, 0.3883002f)]
[TrackClipType(typeof(LightControlClip))]
[TrackBindingType(typeof(Light))]
public class LightControlTrack : TrackAsset
{
	public override Playable CreateTrackMixer(PlayableGraph graph, GameObject go, int inputCount)
	{
		return ScriptPlayable<LightControlMixerBehaviour>.Create(graph, inputCount);
	}

	public override void GatherProperties(PlayableDirector director, IPropertyCollector driver)
	{
		base.GatherProperties(director, driver);
	}
}
[Serializable]
public class NavMeshAgentControlBehaviour : PlayableBehaviour
{
	public Transform destination;

	public bool destinationSet;

	public override void OnGraphStart(Playable playable)
	{
		destinationSet = false;
	}
}
[Serializable]
public class NavMeshAgentControlClip : PlayableAsset, ITimelineClipAsset
{
	public ExposedReference<Transform> destination;

	[HideInInspector]
	public NavMeshAgentControlBehaviour template = new NavMeshAgentControlBehaviour();

	public ClipCaps clipCaps => ClipCaps.None;

	public override Playable CreatePlayable(PlayableGraph graph, GameObject owner)
	{
		ScriptPlayable<NavMeshAgentControlBehaviour> scriptPlayable = ScriptPlayable<NavMeshAgentControlBehaviour>.Create(graph, template);
		scriptPlayable.GetBehaviour().destination = destination.Resolve(graph.GetResolver());
		return scriptPlayable;
	}
}
public class NavMeshAgentControlMixerBehaviour : PlayableBehaviour
{
	public override void ProcessFrame(Playable playable, FrameData info, object playerData)
	{
		NavMeshAgent navMeshAgent = playerData as NavMeshAgent;
		if (!navMeshAgent)
		{
			return;
		}
		int inputCount = playable.GetInputCount();
		for (int i = 0; i < inputCount; i++)
		{
			float inputWeight = playable.GetInputWeight(i);
			NavMeshAgentControlBehaviour behaviour = ((ScriptPlayable<NavMeshAgentControlBehaviour>)playable.GetInput(i)).GetBehaviour();
			if (inputWeight > 0.5f && !behaviour.destinationSet && (bool)behaviour.destination && navMeshAgent.isOnNavMesh)
			{
				navMeshAgent.SetDestination(behaviour.destination.position);
				behaviour.destinationSet = true;
			}
		}
	}
}
[TrackColor(0.855f, 0.8623f, 0.87f)]
[TrackClipType(typeof(NavMeshAgentControlClip))]
[TrackBindingType(typeof(NavMeshAgent))]
public class NavMeshAgentControlTrack : TrackAsset
{
	public override Playable CreateTrackMixer(PlayableGraph graph, GameObject go, int inputCount)
	{
		return ScriptPlayable<NavMeshAgentControlMixerBehaviour>.Create(graph, inputCount);
	}
}
[Serializable]
public class ScreenFaderBehaviour : PlayableBehaviour
{
	public UnityEngine.Color color = UnityEngine.Color.black;
}
[Serializable]
public class ScreenFaderClip : PlayableAsset, ITimelineClipAsset
{
	public ScreenFaderBehaviour template = new ScreenFaderBehaviour();

	public ClipCaps clipCaps => ClipCaps.Blending;

	public override Playable CreatePlayable(PlayableGraph graph, GameObject owner)
	{
		return ScriptPlayable<ScreenFaderBehaviour>.Create(graph, template);
	}
}
public class ScreenFaderMixerBehaviour : PlayableBehaviour
{
	private UnityEngine.Color m_DefaultColor;

	private UnityEngine.UI.Image m_TrackBinding;

	private bool m_FirstFrameHappened;

	public override void ProcessFrame(Playable playable, FrameData info, object playerData)
	{
		m_TrackBinding = playerData as UnityEngine.UI.Image;
		if (m_TrackBinding == null)
		{
			return;
		}
		if (!m_FirstFrameHappened)
		{
			m_DefaultColor = m_TrackBinding.color;
			m_FirstFrameHappened = true;
		}
		int inputCount = playable.GetInputCount();
		UnityEngine.Color clear = UnityEngine.Color.clear;
		float num = 0f;
		float num2 = 0f;
		int num3 = 0;
		for (int i = 0; i < inputCount; i++)
		{
			float inputWeight = playable.GetInputWeight(i);
			ScreenFaderBehaviour behaviour = ((ScriptPlayable<ScreenFaderBehaviour>)playable.GetInput(i)).GetBehaviour();
			clear += behaviour.color * inputWeight;
			num += inputWeight;
			if (inputWeight > num2)
			{
				num2 = inputWeight;
			}
			if (!Mathf.Approximately(inputWeight, 0f))
			{
				num3++;
			}
		}
		m_TrackBinding.color = clear + m_DefaultColor * (1f - num);
		if (num3 != 1)
		{
			_ = 1f - num;
		}
	}

	public override void OnGraphStop(Playable playable)
	{
		m_TrackBinding.color = m_DefaultColor;
		m_FirstFrameHappened = false;
	}
}
[TrackColor(0.875f, 0.5944853f, 0.1737132f)]
[TrackClipType(typeof(ScreenFaderClip))]
[TrackBindingType(typeof(UnityEngine.UI.Image))]
public class ScreenFaderTrack : TrackAsset
{
	public override Playable CreateTrackMixer(PlayableGraph graph, GameObject go, int inputCount)
	{
		return ScriptPlayable<ScreenFaderMixerBehaviour>.Create(graph, inputCount);
	}

	public override void GatherProperties(PlayableDirector director, IPropertyCollector driver)
	{
		base.GatherProperties(director, driver);
	}
}
[Serializable]
public class TextSwitcherBehaviour : PlayableBehaviour
{
	public UnityEngine.Color color = UnityEngine.Color.white;

	public int fontSize = 14;

	public string text;
}
[Serializable]
public class TextSwitcherClip : PlayableAsset, ITimelineClipAsset
{
	public TextSwitcherBehaviour template = new TextSwitcherBehaviour();

	public ClipCaps clipCaps => ClipCaps.Blending;

	public override Playable CreatePlayable(PlayableGraph graph, GameObject owner)
	{
		return ScriptPlayable<TextSwitcherBehaviour>.Create(graph, template);
	}
}
public class TextSwitcherMixerBehaviour : PlayableBehaviour
{
	private UnityEngine.Color m_DefaultColor;

	private int m_DefaultFontSize;

	private string m_DefaultText;

	private Text m_TrackBinding;

	private bool m_FirstFrameHappened;

	public override void ProcessFrame(Playable playable, FrameData info, object playerData)
	{
		m_TrackBinding = playerData as Text;
		if (m_TrackBinding == null)
		{
			return;
		}
		if (!m_FirstFrameHappened)
		{
			m_DefaultColor = m_TrackBinding.color;
			m_DefaultFontSize = m_TrackBinding.fontSize;
			m_DefaultText = m_TrackBinding.text;
			m_FirstFrameHappened = true;
		}
		int inputCount = playable.GetInputCount();
		UnityEngine.Color clear = UnityEngine.Color.clear;
		float num = 0f;
		float num2 = 0f;
		float num3 = 0f;
		int num4 = 0;
		for (int i = 0; i < inputCount; i++)
		{
			float inputWeight = playable.GetInputWeight(i);
			TextSwitcherBehaviour behaviour = ((ScriptPlayable<TextSwitcherBehaviour>)playable.GetInput(i)).GetBehaviour();
			clear += behaviour.color * inputWeight;
			num += (float)behaviour.fontSize * inputWeight;
			num2 += inputWeight;
			if (inputWeight > num3)
			{
				m_TrackBinding.text = behaviour.text;
				num3 = inputWeight;
			}
			if (!Mathf.Approximately(inputWeight, 0f))
			{
				num4++;
			}
		}
		m_TrackBinding.color = clear + m_DefaultColor * (1f - num2);
		m_TrackBinding.fontSize = Mathf.RoundToInt(num + (float)m_DefaultFontSize * (1f - num2));
		if (num4 != 1 && 1f - num2 > num3)
		{
			m_TrackBinding.text = m_DefaultText;
		}
	}

	public override void OnGraphStop(Playable playable)
	{
		m_TrackBinding.color = m_DefaultColor;
		m_TrackBinding.fontSize = m_DefaultFontSize;
		m_TrackBinding.text = m_DefaultText;
		m_FirstFrameHappened = false;
	}
}
[TrackColor(0.1394896f, 0.4411765f, 0.3413077f)]
[TrackClipType(typeof(TextSwitcherClip))]
[TrackBindingType(typeof(Text))]
public class TextSwitcherTrack : TrackAsset
{
	public override Playable CreateTrackMixer(PlayableGraph graph, GameObject go, int inputCount)
	{
		return ScriptPlayable<TextSwitcherMixerBehaviour>.Create(graph, inputCount);
	}

	public override void GatherProperties(PlayableDirector director, IPropertyCollector driver)
	{
		base.GatherProperties(director, driver);
	}
}
[Serializable]
public class TimeDilationBehaviour : PlayableBehaviour
{
	public float timeScale = 1f;
}
[Serializable]
public class TimeDilationClip : PlayableAsset, ITimelineClipAsset
{
	public TimeDilationBehaviour template = new TimeDilationBehaviour();

	public ClipCaps clipCaps => ClipCaps.Extrapolation | ClipCaps.Blending;

	public override Playable CreatePlayable(PlayableGraph graph, GameObject owner)
	{
		return ScriptPlayable<TimeDilationBehaviour>.Create(graph, template);
	}
}
public class TimeDilationMixerBehaviour : PlayableBehaviour
{
	private float m_OldTimeScale = 1f;

	public override void OnGraphStart(Playable playable)
	{
		m_OldTimeScale = Time.timeScale;
	}

	public override void ProcessFrame(Playable playable, FrameData info, object playerData)
	{
		int inputCount = playable.GetInputCount();
		float num = 0f;
		float num2 = 0f;
		for (int i = 0; i < inputCount; i++)
		{
			float inputWeight = playable.GetInputWeight(i);
			num2 += inputWeight;
			TimeDilationBehaviour behaviour = ((ScriptPlayable<TimeDilationBehaviour>)playable.GetInput(i)).GetBehaviour();
			num += inputWeight * behaviour.timeScale;
		}
		Time.timeScale = num + m_OldTimeScale * (1f - num2);
	}

	public override void OnGraphStop(Playable playable)
	{
		Time.timeScale = m_OldTimeScale;
	}
}
[TrackColor(0.855f, 0.8623f, 0.87f)]
[TrackClipType(typeof(TimeDilationClip))]
public class TimeDilationTrack : TrackAsset
{
	public override Playable CreateTrackMixer(PlayableGraph graph, GameObject go, int inputCount)
	{
		return ScriptPlayable<TimeDilationMixerBehaviour>.Create(graph, inputCount);
	}
}
[Serializable]
public class TransformTweenBehaviour : PlayableBehaviour
{
	public enum TweenType
	{
		Linear,
		Deceleration,
		Harmonic,
		Custom
	}

	public Transform startLocation;

	public Transform endLocation;

	public bool tweenPosition = true;

	public bool tweenRotation = true;

	public TweenType tweenType;

	public float customStartingSpeed;

	public float customEndingSpeed;

	public float inverseDuration;

	public Vector3 startingPosition;

	public Quaternion startingRotation;

	public AnimationCurve currentCurve;

	private AnimationCurve m_LinearCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	private AnimationCurve m_DecelerationCurve = new AnimationCurve(new Keyframe(0f, 0f, -(float)Math.PI / 2f, (float)Math.PI / 2f), new Keyframe(1f, 1f, 0f, 0f));

	private AnimationCurve m_HarmonicCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	private AnimationCurve m_CustomCurve;

	private const float k_RightAngleInRads = (float)Math.PI / 2f;

	public override void OnGraphStart(Playable playable)
	{
		double duration = playable.GetDuration();
		if (Mathf.Approximately((float)duration, 0f))
		{
			throw new UnityException("A TransformTween cannot have a duration of zero.");
		}
		inverseDuration = 1f / (float)duration;
		m_CustomCurve = new AnimationCurve(new Keyframe(0f, 0f, (0f - customStartingSpeed) * ((float)Math.PI / 2f), customStartingSpeed * ((float)Math.PI / 2f)), new Keyframe(1f, 1f, customEndingSpeed * ((float)Math.PI / 2f), customEndingSpeed * ((float)Math.PI / 2f)));
		switch (tweenType)
		{
		case TweenType.Linear:
			currentCurve = m_LinearCurve;
			break;
		case TweenType.Deceleration:
			currentCurve = m_DecelerationCurve;
			break;
		case TweenType.Harmonic:
			currentCurve = m_HarmonicCurve;
			break;
		case TweenType.Custom:
			currentCurve = m_CustomCurve;
			break;
		}
		if ((bool)startLocation)
		{
			startingPosition = startLocation.position;
			startingRotation = startLocation.rotation;
		}
	}
}
[Serializable]
public class TransformTweenClip : PlayableAsset, ITimelineClipAsset
{
	public TransformTweenBehaviour template = new TransformTweenBehaviour();

	public ExposedReference<Transform> startLocation;

	public ExposedReference<Transform> endLocation;

	public ClipCaps clipCaps => ClipCaps.Blending;

	public override Playable CreatePlayable(PlayableGraph graph, GameObject owner)
	{
		ScriptPlayable<TransformTweenBehaviour> scriptPlayable = ScriptPlayable<TransformTweenBehaviour>.Create(graph, template);
		TransformTweenBehaviour behaviour = scriptPlayable.GetBehaviour();
		behaviour.startLocation = startLocation.Resolve(graph.GetResolver());
		behaviour.endLocation = endLocation.Resolve(graph.GetResolver());
		return scriptPlayable;
	}
}
public class TransformTweenMixerBehaviour : PlayableBehaviour
{
	private bool m_FirstFrameHappened;

	public override void ProcessFrame(Playable playable, FrameData info, object playerData)
	{
		Transform transform = playerData as Transform;
		if (transform == null)
		{
			return;
		}
		Vector3 position = transform.position;
		Quaternion rotation = transform.rotation;
		int inputCount = playable.GetInputCount();
		float num = 0f;
		float num2 = 0f;
		Vector3 zero = Vector3.zero;
		Quaternion quaternion = new Quaternion(0f, 0f, 0f, 0f);
		for (int i = 0; i < inputCount; i++)
		{
			ScriptPlayable<TransformTweenBehaviour> playable2 = (ScriptPlayable<TransformTweenBehaviour>)playable.GetInput(i);
			TransformTweenBehaviour behaviour = playable2.GetBehaviour();
			if (behaviour.endLocation == null)
			{
				continue;
			}
			float inputWeight = playable.GetInputWeight(i);
			if (!m_FirstFrameHappened && !behaviour.startLocation)
			{
				behaviour.startingPosition = position;
				behaviour.startingRotation = rotation;
				m_FirstFrameHappened = true;
			}
			float time = (float)(playable2.GetTime() * (double)behaviour.inverseDuration);
			float t = behaviour.currentCurve.Evaluate(time);
			if (behaviour.tweenPosition)
			{
				num += inputWeight;
				zero += Vector3.Lerp(behaviour.startingPosition, behaviour.endLocation.position, t) * inputWeight;
			}
			if (behaviour.tweenRotation)
			{
				num2 += inputWeight;
				Quaternion rotation2 = Quaternion.Lerp(behaviour.startingRotation, behaviour.endLocation.rotation, t);
				rotation2 = NormalizeQuaternion(rotation2);
				if (Quaternion.Dot(quaternion, rotation2) < 0f)
				{
					rotation2 = ScaleQuaternion(rotation2, -1f);
				}
				rotation2 = ScaleQuaternion(rotation2, inputWeight);
				quaternion = AddQuaternions(quaternion, rotation2);
			}
		}
		zero += position * (1f - num);
		Quaternion second = ScaleQuaternion(rotation, 1f - num2);
		quaternion = AddQuaternions(quaternion, second);
		transform.position = zero;
		transform.rotation = quaternion;
	}

	private static Quaternion AddQuaternions(Quaternion first, Quaternion second)
	{
		first.w += second.w;
		first.x += second.x;
		first.y += second.y;
		first.z += second.z;
		return first;
	}

	private static Quaternion ScaleQuaternion(Quaternion rotation, float multiplier)
	{
		rotation.w *= multiplier;
		rotation.x *= multiplier;
		rotation.y *= multiplier;
		rotation.z *= multiplier;
		return rotation;
	}

	private static float QuaternionMagnitude(Quaternion rotation)
	{
		return Mathf.Sqrt(Quaternion.Dot(rotation, rotation));
	}

	private static Quaternion NormalizeQuaternion(Quaternion rotation)
	{
		float num = QuaternionMagnitude(rotation);
		if (num > 0f)
		{
			return ScaleQuaternion(rotation, 1f / num);
		}
		UnityEngine.Debug.LogWarning("Cannot normalize a quaternion with zero magnitude.");
		return Quaternion.identity;
	}
}
[TrackColor(0.855f, 0.8623f, 0.87f)]
[TrackClipType(typeof(TransformTweenClip))]
[TrackBindingType(typeof(Transform))]
public class TransformTweenTrack : TrackAsset
{
	public override Playable CreateTrackMixer(PlayableGraph graph, GameObject go, int inputCount)
	{
		return ScriptPlayable<TransformTweenMixerBehaviour>.Create(graph, inputCount);
	}

	public override void GatherProperties(PlayableDirector director, IPropertyCollector driver)
	{
		base.GatherProperties(director, driver);
	}
}
[ExecuteInEditMode]
public class EnableDepthInForwardCamera : MonoBehaviour
{
	private void OnEnable()
	{
		if (GetComponent<Camera>().depthTextureMode == DepthTextureMode.None)
		{
			GetComponent<Camera>().depthTextureMode = DepthTextureMode.Depth;
		}
	}

	private void Update()
	{
	}
}
[ExecuteInEditMode]
public class FoggyLight : MonoBehaviour
{
	public enum BlendModeEnum
	{
		Additive,
		AlphaBlended
	}

	public BlendModeEnum BlendMode;

	public bool ApplyTonemap = true;

	private UnityEngine.Component FogVolumeComponent;

	public UnityEngine.Color PointLightColor = UnityEngine.Color.white;

	private Vector3 Position;

	[Range(0f, 8f)]
	public float PointLightIntensity = 1f;

	[Range(0f, 20f)]
	public float FoggyLightIntensity = 1f;

	public float PointLightExponent = 5f;

	public float Offset = -2f;

	[Range(1f, 40f)]
	public float IntersectionRange = 2f;

	public int DrawOrder = 1;

	public bool AttatchLight;

	private Light AttachedLight;

	private Material FoggyLightMaterial;

	[SerializeField]
	private GameObject FogVolumeContainer;

	public bool InsideFogVolume;

	public Material GetMaterial()
	{
		return FoggyLightMaterial;
	}

	private void CreateMaterial()
	{
		if (!FoggyLightMaterial)
		{
			FoggyLightMaterial = new Material(Shader.Find("Hidden/FoggyLight"));
			FoggyLightMaterial.name = base.name.ToString() + " Material";
			base.gameObject.GetComponent<Renderer>().sharedMaterial = FoggyLightMaterial;
			FoggyLightMaterial.hideFlags = HideFlags.HideAndDontSave;
		}
	}

	private void Start()
	{
	}

	private void OnEnable()
	{
		CreateMaterial();
	}

	private void OnWillRenderObject()
	{
		GetComponent<Renderer>().sortingOrder = DrawOrder;
		Position = base.gameObject.transform.position;
		PointLightExponent = Mathf.Max(1f, PointLightExponent);
		Position = base.gameObject.transform.position;
		GetComponent<Renderer>().sharedMaterial.SetColor("PointLightColor", PointLightColor);
		if ((bool)FogVolumeContainer && InsideFogVolume)
		{
			if (!FogVolumeComponent)
			{
				FogVolumeComponent = FogVolumeContainer.GetComponent("FogVolume");
			}
			FoggyLightMaterial.EnableKeyword("_FOG_CONTAINER");
			float value = (float)FogVolumeComponent.GetType().GetMethod("GetVisibility").Invoke(FogVolumeComponent, null);
			GetComponent<Renderer>().sharedMaterial.SetFloat("_Visibility", value);
		}
		else
		{
			FoggyLightMaterial.DisableKeyword("_FOG_CONTAINER");
		}
		if (ApplyTonemap)
		{
			FoggyLightMaterial.EnableKeyword("TONEMAP");
		}
		else
		{
			FoggyLightMaterial.DisableKeyword("TONEMAP");
		}
		FoggyLightMaterial.SetVector("PointLightPosition", Position);
		FoggyLightMaterial.SetFloat("PointLightIntensity", PointLightIntensity * FoggyLightIntensity);
		FoggyLightMaterial.SetFloat("PointLightExponent", PointLightExponent);
		FoggyLightMaterial.SetFloat("Offset", Offset);
		FoggyLightMaterial.SetFloat("IntersectionRange", IntersectionRange);
		if (AttatchLight)
		{
			if (!base.gameObject.GetComponent<Light>())
			{
				base.gameObject.AddComponent<Light>();
				base.gameObject.GetComponent<Light>().shadows = LightShadows.Hard;
			}
			AttachedLight = base.gameObject.GetComponent<Light>();
			if ((bool)AttachedLight)
			{
				AttachedLight.intensity = PointLightIntensity / 2f;
				AttachedLight.color = PointLightColor;
				AttachedLight.enabled = true;
			}
		}
		else if ((bool)AttachedLight)
		{
			AttachedLight.enabled = false;
		}
		BlendValues(BlendMode);
	}

	private void BlendValues(BlendModeEnum BlendMode)
	{
		switch (BlendMode)
		{
		case BlendModeEnum.Additive:
			FoggyLightMaterial.EnableKeyword("_ADDITIVE");
			FoggyLightMaterial.SetInt("_SrcBlend", 1);
			FoggyLightMaterial.SetInt("_DstBlend", 1);
			break;
		case BlendModeEnum.AlphaBlended:
			FoggyLightMaterial.DisableKeyword("_ADDITIVE");
			FoggyLightMaterial.SetInt("_SrcBlend", 5);
			FoggyLightMaterial.SetInt("_DstBlend", 10);
			break;
		}
	}
}
public class FoggyLightsOrbits : MonoBehaviour
{
	public float SpinSpeed = 50f;

	private float X;

	private float Y;

	private float Z;

	[Range(0f, 1f)]
	public float _ColorSpeed = 1f;

	private float ColorSpeed;

	private Vector3 RandomRangeXYZ;

	private float Opacity;

	private void Start()
	{
		Opacity = base.transform.GetChild(0).GetComponent<FoggyLight>().PointLightColor.a;
		RandomRangeXYZ.x = UnityEngine.Random.Range(0f, 1f);
		RandomRangeXYZ.y = UnityEngine.Random.Range(0f, 1f);
		RandomRangeXYZ.z = UnityEngine.Random.Range(0f, 1f);
	}

	private void Update()
	{
		ColorSpeed += Time.deltaTime * _ColorSpeed;
		base.transform.Rotate(0f, Time.deltaTime * SpinSpeed, 0f);
		X = Mathf.Sin(ColorSpeed * RandomRangeXYZ.x) * 0.5f + 0.5f;
		Y = Mathf.Sin(ColorSpeed * RandomRangeXYZ.y) * 0.5f + 0.5f;
		Z = Mathf.Sin(ColorSpeed * RandomRangeXYZ.z) * 0.5f + 0.5f;
		UnityEngine.Color pointLightColor = new UnityEngine.Color(X, Y, Z, Opacity);
		base.transform.GetChild(0).GetComponent<FoggyLight>().PointLightColor = pointLightColor;
	}
}
public class HauntedDemonicDoll : MonoBehaviour
{
	private enum iterationsName
	{
		neckTurn,
		_return,
		subtleLaugh,
		neckturn02,
		_return2,
		seek,
		demonicMov
	}

	[SerializeField]
	private AudioClip[] sounds;

	private AudioSource _audioSource;

	private int _iterations;

	private int neckTurn = Animator.StringToHash("Look right");

	private int neckBack = Animator.StringToHash("Return");

	private int evilLaugh = Animator.StringToHash("Subtle Laugh");

	private int lookLeft = Animator.StringToHash("Look left");

	private int neckBack2 = Animator.StringToHash("Return from look left");

	private int seek = Animator.StringToHash("Seek");

	private int demonicMov = Animator.StringToHash("Creepy Movement");

	private void Awake()
	{
		_audioSource = GetComponent<AudioSource>();
	}

	private void Start()
	{
		StartCoroutine(_mecanimSound());
	}

	private IEnumerator _mecanimSound()
	{
		Animator thisAnim = GetComponent<Animator>();
		while (true)
		{
			switch (_iterations)
			{
			case 0:
				yield return StartCoroutine(_msc(thisAnim, neckTurn));
				break;
			case 1:
				yield return StartCoroutine(_msc(thisAnim, neckBack));
				break;
			case 2:
				yield return StartCoroutine(_msc(thisAnim, evilLaugh));
				break;
			case 3:
				yield return StartCoroutine(_msc(thisAnim, lookLeft));
				break;
			case 4:
				yield return StartCoroutine(_msc(thisAnim, neckBack2));
				break;
			case 5:
				yield return StartCoroutine(_msc(thisAnim, seek));
				break;
			case 6:
				yield return StartCoroutine(_msc(thisAnim, demonicMov));
				break;
			}
			yield return null;
		}
	}

	private IEnumerator _msc(Animator thisAnim, int clip)
	{
		if (_iterations == 0)
		{
			while (thisAnim.GetCurrentAnimatorStateInfo(0).shortNameHash != clip || GetComponent<AudioSource>().isPlaying)
			{
				yield return null;
			}
			_audioSource.clip = sounds[0];
			_audioSource.Play();
			yield return Yield.WaitSeconds(_audioSource.clip.length);
			_audioSource.Stop();
			yield return StartCoroutine(__nextIteration());
		}
		else if (_iterations == 1)
		{
			yield return Yield.WaitSeconds(1.55f);
			if (_audioSource.clip != sounds[1])
			{
				_audioSource.clip = sounds[1];
			}
			_audioSource.Play();
			yield return Yield.WaitSeconds(_audioSource.clip.length);
			yield return StartCoroutine(__nextIteration());
		}
		else if (_iterations == 2)
		{
			yield return Yield.WaitSeconds(0.6f);
			_audioSource.clip = sounds[2];
			_audioSource.volume = 0.5f;
			_audioSource.Play();
			UnityEngine.Debug.Log("Laugh");
			yield return Yield.WaitSeconds(_audioSource.clip.length);
			_audioSource.Stop();
			yield return StartCoroutine(__nextIteration());
		}
		else if (_iterations == 3)
		{
			_audioSource.clip = sounds[0];
			_audioSource.volume = 1f;
			_audioSource.Play();
			yield return Yield.WaitSeconds(_audioSource.clip.length);
			_audioSource.Stop();
			yield return StartCoroutine(__nextIteration());
		}
		else if (_iterations == 4)
		{
			yield return Yield.WaitSeconds(1.55f);
			if (_audioSource.clip != sounds[1])
			{
				_audioSource.clip = sounds[1];
			}
			_audioSource.Play();
			yield return Yield.WaitSeconds(_audioSource.clip.length);
			_audioSource.Stop();
			yield return StartCoroutine(__nextIteration());
		}
		else if (_iterations == 5)
		{
			if (_audioSource.clip != sounds[3])
			{
				_audioSource.clip = sounds[3];
			}
			_audioSource.Play();
			yield return Yield.WaitSeconds(_audioSource.clip.length);
			_audioSource.Stop();
			yield return StartCoroutine(__nextIteration());
		}
		else if (_iterations == 6)
		{
			yield return Yield.WaitSeconds(1f);
			if (_audioSource.clip != sounds[4])
			{
				_audioSource.clip = sounds[4];
			}
			_audioSource.Play();
			yield return Yield.WaitSeconds(_audioSource.clip.length);
			_audioSource.Stop();
			yield return StartCoroutine(__nextIteration());
		}
	}

	private IEnumerator __nextIteration()
	{
		if (_iterations == 6)
		{
			_iterations = 0;
		}
		else
		{
			_iterations++;
		}
		yield return null;
	}
}
public class OldGUIExamplesCS : MonoBehaviour
{
	public Texture2D grumpy;

	public Texture2D beauty;

	private float w;

	private float h;

	private LTRect buttonRect1;

	private LTRect buttonRect2;

	private LTRect buttonRect3;

	private LTRect buttonRect4;

	private LTRect grumpyRect;

	private LTRect beautyTileRect;

	private void Start()
	{
		w = Screen.width;
		h = Screen.height;
		buttonRect1 = new LTRect(0.1f * w, 0.8f * h, 0.2f * w, 0.14f * h);
		buttonRect2 = new LTRect(1.2f * w, 0.8f * h, 0.2f * w, 0.14f * h);
		buttonRect3 = new LTRect(0.35f * w, 0f * h, 0.3f * w, 0.2f * h, 0f);
		buttonRect4 = new LTRect(0f * w, 0.4f * h, 0.3f * w, 0.2f * h, 1f, 15f);
		grumpyRect = new LTRect(0.5f * w - (float)grumpy.width * 0.5f, 0.5f * h - (float)grumpy.height * 0.5f, grumpy.width, grumpy.height);
		beautyTileRect = new LTRect(0f, 0f, 1f, 1f);
		LeanTween.move(buttonRect2, new Vector2(0.55f * w, buttonRect2.rect.y), 0.7f).setEase(LeanTweenType.easeOutQuad);
	}

	public void catMoved()
	{
		UnityEngine.Debug.Log("cat moved...");
	}

	private void OnGUI()
	{
		GUI.DrawTexture(grumpyRect.rect, grumpy);
		if (GUI.Button(new Rect(0f * w, 0f * h, 0.2f * w, 0.14f * h), "Move Cat") && !LeanTween.isTweening(grumpyRect))
		{
			Vector2 to = new Vector2(grumpyRect.rect.x, grumpyRect.rect.y);
			LeanTween.move(grumpyRect, new Vector2(1f * (float)Screen.width - (float)grumpy.width, 0f * (float)Screen.height), 1f).setEase(LeanTweenType.easeOutBounce).setOnComplete(catMoved);
			LeanTween.move(grumpyRect, to, 1f).setDelay(1f).setEase(LeanTweenType.easeOutBounce);
		}
		if (GUI.Button(buttonRect1.rect, "Scale Centered"))
		{
			LeanTween.scale(buttonRect1, new Vector2(buttonRect1.rect.width, buttonRect1.rect.height) * 1.2f, 0.25f).setEase(LeanTweenType.easeOutQuad);
			LeanTween.move(buttonRect1, new Vector2(buttonRect1.rect.x - buttonRect1.rect.width * 0.1f, buttonRect1.rect.y - buttonRect1.rect.height * 0.1f), 0.25f).setEase(LeanTweenType.easeOutQuad);
		}
		if (GUI.Button(buttonRect2.rect, "Scale"))
		{
			LeanTween.scale(buttonRect2, new Vector2(buttonRect2.rect.width, buttonRect2.rect.height) * 1.2f, 0.25f).setEase(LeanTweenType.easeOutBounce);
		}
		if (GUI.Button(new Rect(0.76f * w, 0.53f * h, 0.2f * w, 0.14f * h), "Flip Tile"))
		{
			LeanTween.move(beautyTileRect, new Vector2(0f, beautyTileRect.rect.y + 1f), 1f).setEase(LeanTweenType.easeOutBounce);
		}
		GUI.DrawTextureWithTexCoords(new Rect(0.8f * w, 0.5f * h - (float)beauty.height * 0.5f, (float)beauty.width * 0.5f, (float)beauty.height * 0.5f), beauty, beautyTileRect.rect);
		if (GUI.Button(buttonRect3.rect, "Alpha"))
		{
			LeanTween.alpha(buttonRect3, 0f, 1f).setEase(LeanTweenType.easeOutQuad);
			LeanTween.alpha(buttonRect3, 1f, 1f).setDelay(1f).setEase(LeanTweenType.easeInQuad);
			LeanTween.alpha(grumpyRect, 0f, 1f).setEase(LeanTweenType.easeOutQuad);
			LeanTween.alpha(grumpyRect, 1f, 1f).setDelay(1f).setEase(LeanTweenType.easeInQuad);
		}
		GUI.color = new UnityEngine.Color(1f, 1f, 1f, 1f);
		if (GUI.Button(buttonRect4.rect, "Rotate"))
		{
			LeanTween.rotate(buttonRect4, 150f, 1f).setEase(LeanTweenType.easeOutElastic);
			LeanTween.rotate(buttonRect4, 0f, 1f).setDelay(1f).setEase(LeanTweenType.easeOutElastic);
		}
		GUI.matrix = Matrix4x4.identity;
	}
}
public class TestingPunch : MonoBehaviour
{
	public AnimationCurve exportCurve;

	public float overShootValue = 1f;

	private LTDescr descr;

	private void Start()
	{
		UnityEngine.Debug.Log("exported curve:" + curveToString(exportCurve));
	}

	private void Update()
	{
		LeanTween.dtManual = Time.deltaTime;
		if (Input.GetKeyDown(KeyCode.Q))
		{
			LeanTween.moveLocalX(base.gameObject, 5f, 1f).setOnComplete((Action)delegate
			{
				UnityEngine.Debug.Log("on complete move local X");
			}).setOnCompleteOnStart(isOn: true);
			GameObject gameObject = GameObject.Find("DirectionalLight");
			Light lt = gameObject.GetComponent<Light>();
			LeanTween.value(lt.gameObject, lt.intensity, 0f, 1.5f).setEase(LeanTweenType.linear).setLoopPingPong()
				.setRepeat(-1)
				.setOnUpdate(delegate(float val)
				{
					lt.intensity = val;
				});
		}
		if (Input.GetKeyDown(KeyCode.S))
		{
			MonoBehaviour.print("scale punch!");
			tweenStatically(base.gameObject);
			LeanTween.scale(base.gameObject, new Vector3(1.15f, 1.15f, 1.15f), 0.6f);
			LeanTween.rotateAround(base.gameObject, Vector3.forward, -360f, 0.3f).setOnComplete((Action)delegate
			{
				LeanTween.rotateAround(base.gameObject, Vector3.forward, -360f, 0.4f).setOnComplete((Action)delegate
				{
					LeanTween.scale(base.gameObject, new Vector3(1f, 1f, 1f), 0.1f);
					LeanTween.value(base.gameObject, (Action<float>)delegate
					{
					}, 0f, 1f, 0.3f).setDelay(1f);
				});
			});
		}
		if (Input.GetKeyDown(KeyCode.T))
		{
			Vector3[] to = new Vector3[4]
			{
				new Vector3(-1f, 0f, 0f),
				new Vector3(0f, 0f, 0f),
				new Vector3(4f, 0f, 0f),
				new Vector3(20f, 0f, 0f)
			};
			descr = LeanTween.move(base.gameObject, to, 15f).setOrientToPath(doesOrient: true).setDirection(1f)
				.setOnComplete((Action)delegate
				{
					UnityEngine.Debug.Log("move path finished");
				});
		}
		if (Input.GetKeyDown(KeyCode.Y))
		{
			descr.setDirection(0f - descr.direction);
		}
		if (Input.GetKeyDown(KeyCode.R))
		{
			LeanTween.rotateAroundLocal(base.gameObject, base.transform.forward, -80f, 5f).setPoint(new Vector3(1.25f, 0f, 0f));
			MonoBehaviour.print("rotate punch!");
		}
		if (Input.GetKeyDown(KeyCode.M))
		{
			MonoBehaviour.print("move punch!");
			Time.timeScale = 0.25f;
			float start = Time.realtimeSinceStartup;
			LeanTween.moveX(base.gameObject, 1f, 1f).setOnComplete(destroyOnComp).setOnCompleteParam(base.gameObject)
				.setOnComplete((Action)delegate
				{
					float realtimeSinceStartup = Time.realtimeSinceStartup;
					float num = realtimeSinceStartup - start;
					UnityEngine.Debug.Log("start:" + start + " end:" + realtimeSinceStartup + " diff:" + num + " x:" + base.gameObject.transform.position.x);
				})
				.setEase(LeanTweenType.easeInBack)
				.setOvershoot(overShootValue)
				.setPeriod(0.3f);
		}
		if (Input.GetKeyDown(KeyCode.C))
		{
			LeanTween.color(base.gameObject, new UnityEngine.Color(1f, 0f, 0f, 0.5f), 1f);
			LeanTween.color(to: new UnityEngine.Color(UnityEngine.Random.Range(0f, 1f), 0f, UnityEngine.Random.Range(0f, 1f), 0f), gameObject: GameObject.Find("LCharacter"), time: 4f).setLoopPingPong(1).setEase(LeanTweenType.easeOutBounce);
		}
		if (Input.GetKeyDown(KeyCode.E))
		{
			LeanTween.delayedCall(base.gameObject, 0.3f, delayedMethod).setRepeat(4).setOnCompleteOnRepeat(isOn: true)
				.setOnCompleteParam("hi");
		}
		if (Input.GetKeyDown(KeyCode.V))
		{
			LeanTween.value(base.gameObject, updateColor, new UnityEngine.Color(1f, 0f, 0f, 1f), UnityEngine.Color.blue, 4f);
		}
		if (Input.GetKeyDown(KeyCode.P))
		{
			LeanTween.delayedCall(0.05f, enterMiniGameStart).setOnCompleteParam(new object[1] { string.Concat(5) });
		}
		if (Input.GetKeyDown(KeyCode.U))
		{
			LeanTween.value(base.gameObject, delegate(Vector2 val)
			{
				base.transform.position = new Vector3(val.x, base.transform.position.y, base.transform.position.z);
			}, new Vector2(0f, 0f), new Vector2(5f, 100f), 1f).setEase(LeanTweenType.easeOutBounce);
			GameObject i = GameObject.Find("LCharacter");
			UnityEngine.Debug.Log("x:" + i.transform.position.x + " y:" + i.transform.position.y);
			LeanTween.value(i, new Vector2(i.transform.position.x, i.transform.position.y), new Vector2(i.transform.position.x, i.transform.position.y + 5f), 1f).setOnUpdate(delegate(Vector2 val)
			{
				UnityEngine.Debug.Log("tweening vec2 val:" + val);
				i.transform.position = new Vector3(val.x, val.y, base.transform.position.z);
			});
		}
	}

	private static void tweenStatically(GameObject gameObject)
	{
		UnityEngine.Debug.Log("Starting to tween...");
		LeanTween.value(gameObject, delegate(float val)
		{
			UnityEngine.Debug.Log("tweening val:" + val);
		}, 0f, 1f, 1f);
	}

	private void enterMiniGameStart(object val)
	{
		int num = int.Parse((string)((object[])val)[0]);
		UnityEngine.Debug.Log("level:" + num);
	}

	private void updateColor(UnityEngine.Color c)
	{
		GameObject.Find("LCharacter").GetComponent<Renderer>().material.color = c;
	}

	private void delayedMethod(object myVal)
	{
		string text = myVal as string;
		UnityEngine.Debug.Log("delayed call:" + Time.time + " myVal:" + text);
	}

	private void destroyOnComp(object p)
	{
		UnityEngine.Object.Destroy((GameObject)p);
	}

	private string curveToString(AnimationCurve curve)
	{
		string text = "";
		for (int i = 0; i < curve.length; i++)
		{
			text = text + "new Keyframe(" + curve[i].time + "f, " + curve[i].value + "f)";
			if (i < curve.length - 1)
			{
				text += ", ";
			}
		}
		return "new AnimationCurve( " + text + " )";
	}
}
public class TestingRigidbodyCS : MonoBehaviour
{
	private GameObject ball1;

	private void Start()
	{
		ball1 = GameObject.Find("Sphere1");
		LeanTween.rotateAround(ball1, Vector3.forward, -90f, 1f);
		LeanTween.move(ball1, new Vector3(2f, 0f, 7f), 1f).setDelay(1f).setRepeat(-1);
	}

	private void Update()
	{
	}
}
public class GeneralAdvancedTechniques : MonoBehaviour
{
	public GameObject avatarRecursive;

	public GameObject avatar2dRecursive;

	public RectTransform wingPersonPanel;

	public RectTransform textField;

	public GameObject avatarMove;

	public Transform[] movePts;

	public GameObject[] avatarSpeed;

	public GameObject[] avatarSpeed2;

	private Vector3[] circleSm = new Vector3[32]
	{
		new Vector3(16f, 0f, 0f),
		new Vector3(14.56907f, 8.009418f, 0f),
		new Vector3(15.96541f, 4.638379f, 0f),
		new Vector3(11.31371f, 11.31371f, 0f),
		new Vector3(11.31371f, 11.31371f, 0f),
		new Vector3(4.638379f, 15.96541f, 0f),
		new Vector3(8.009416f, 14.56908f, 0f),
		new Vector3(-6.993822E-07f, 16f, 0f),
		new Vector3(-6.993822E-07f, 16f, 0f),
		new Vector3(-8.009419f, 14.56907f, 0f),
		new Vector3(-4.63838f, 15.9654f, 0f),
		new Vector3(-11.31371f, 11.31371f, 0f),
		new Vector3(-11.31371f, 11.31371f, 0f),
		new Vector3(-15.9654f, 4.63838f, 0f),
		new Vector3(-14.56908f, 8.009415f, 0f),
		new Vector3(-16f, -1.398764E-06f, 0f),
		new Vector3(-16f, -1.398764E-06f, 0f),
		new Vector3(-14.56907f, -8.009418f, 0f),
		new Vector3(-15.9654f, -4.638382f, 0f),
		new Vector3(-11.31371f, -11.31371f, 0f),
		new Vector3(-11.31371f, -11.31371f, 0f),
		new Vector3(-4.638381f, -15.9654f, 0f),
		new Vector3(-8.009413f, -14.56908f, 0f),
		new Vector3(1.907981E-07f, -16f, 0f),
		new Vector3(1.907981E-07f, -16f, 0f),
		new Vector3(8.00942f, -14.56907f, 0f),
		new Vector3(4.638381f, -15.9654f, 0f),
		new Vector3(11.31371f, -11.3137f, 0f),
		new Vector3(11.31371f, -11.3137f, 0f),
		new Vector3(15.96541f, -4.638378f, 0f),
		new Vector3(14.56907f, -8.009418f, 0f),
		new Vector3(16f, 2.797529E-06f, 0f)
	};

	private Vector3[] circleLrg = new Vector3[32]
	{
		new Vector3(25f, 0f, 0f),
		new Vector3(22.76418f, 12.51472f, 0f),
		new Vector3(24.94595f, 7.247467f, 0f),
		new Vector3(17.67767f, 17.67767f, 0f),
		new Vector3(17.67767f, 17.67767f, 0f),
		new Vector3(7.247467f, 24.94595f, 0f),
		new Vector3(12.51471f, 22.76418f, 0f),
		new Vector3(-1.092785E-06f, 25f, 0f),
		new Vector3(-1.092785E-06f, 25f, 0f),
		new Vector3(-12.51472f, 22.76418f, 0f),
		new Vector3(-7.247468f, 24.94594f, 0f),
		new Vector3(-17.67767f, 17.67767f, 0f),
		new Vector3(-17.67767f, 17.67767f, 0f),
		new Vector3(-24.94594f, 7.247468f, 0f),
		new Vector3(-22.76418f, 12.51471f, 0f),
		new Vector3(-25f, -2.185569E-06f, 0f),
		new Vector3(-25f, -2.185569E-06f, 0f),
		new Vector3(-22.76418f, -12.51472f, 0f),
		new Vector3(-24.94594f, -7.247472f, 0f),
		new Vector3(-17.67767f, -17.67767f, 0f),
		new Vector3(-17.67767f, -17.67767f, 0f),
		new Vector3(-7.247469f, -24.94594f, 0f),
		new Vector3(-12.51471f, -22.76418f, 0f),
		new Vector3(2.98122E-07f, -25f, 0f),
		new Vector3(2.98122E-07f, -25f, 0f),
		new Vector3(12.51472f, -22.76418f, 0f),
		new Vector3(7.24747f, -24.94594f, 0f),
		new Vector3(17.67768f, -17.67766f, 0f),
		new Vector3(17.67768f, -17.67766f, 0f),
		new Vector3(24.94595f, -7.247465f, 0f),
		new Vector3(22.76418f, -12.51472f, 0f),
		new Vector3(25f, 4.371139E-06f, 0f)
	};

	private void Start()
	{
		LeanTween.alpha(avatarRecursive, 0f, 1f).setRecursive(useRecursion: true).setLoopPingPong();
		LeanTween.alpha(avatar2dRecursive, 0f, 1f).setRecursive(useRecursion: true).setLoopPingPong();
		LeanTween.alpha(wingPersonPanel, 0f, 1f).setRecursive(useRecursion: true).setLoopPingPong();
		LeanTween.value(avatarMove, 0f, (float)movePts.Length - 1f, 5f).setOnUpdate(delegate(float val)
		{
			int num = (int)Mathf.Floor(val);
			int num2 = ((num < movePts.Length - 1) ? (num + 1) : num);
			float num3 = val - (float)num;
			Vector3 vector = movePts[num2].position - movePts[num].position;
			avatarMove.transform.position = movePts[num].position + vector * num3;
		}).setEase(LeanTweenType.easeInOutExpo)
			.setLoopPingPong();
		for (int i = 0; i < movePts.Length; i++)
		{
			LeanTween.moveY(movePts[i].gameObject, movePts[i].position.y + 1.5f, 1f).setDelay((float)i * 0.2f).setLoopPingPong();
		}
		for (int j = 0; j < avatarSpeed.Length; j++)
		{
			LeanTween.moveLocalZ(avatarSpeed[j], (float)(j + 1) * 5f, 1f).setSpeed(6f).setEase(LeanTweenType.easeInOutExpo)
				.setLoopPingPong();
		}
		for (int k = 0; k < avatarSpeed2.Length; k++)
		{
			LeanTween.moveLocal(avatarSpeed2[k], (k == 0) ? circleSm : circleLrg, 1f).setSpeed(20f).setRepeat(-1);
		}
	}
}
public class GeneralBasicCS : MonoBehaviour
{
	public GameObject prefabAvatar;

	private void Start()
	{
		GameObject obj = GameObject.Find("AvatarRotate");
		GameObject gameObject = GameObject.Find("AvatarScale");
		GameObject gameObject2 = GameObject.Find("AvatarMove");
		LeanTween.rotateAround(obj, Vector3.forward, 360f, 5f);
		LeanTween.scale(gameObject, new Vector3(1.7f, 1.7f, 1.7f), 5f).setEase(LeanTweenType.easeOutBounce);
		LeanTween.moveX(gameObject, gameObject.transform.position.x + 5f, 5f).setEase(LeanTweenType.easeOutBounce);
		LeanTween.move(gameObject2, gameObject2.transform.position + new Vector3(-9f, 0f, 1f), 2f).setEase(LeanTweenType.easeInQuad);
		LeanTween.move(gameObject2, gameObject2.transform.position + new Vector3(-6f, 0f, 1f), 2f).setDelay(3f);
		LeanTween.scale(gameObject, new Vector3(0.2f, 0.2f, 0.2f), 1f).setDelay(7f).setEase(LeanTweenType.easeInOutCirc)
			.setLoopPingPong(3);
		LeanTween.delayedCall(base.gameObject, 0.2f, advancedExamples);
	}

	private void advancedExamples()
	{
		LeanTween.delayedCall(base.gameObject, 14f, (Action)delegate
		{
			for (int i = 0; i < 10; i++)
			{
				GameObject rotator = new GameObject("rotator" + i);
				rotator.transform.position = new Vector3(10.2f, 2.85f, 0f);
				GameObject obj = UnityEngine.Object.Instantiate(prefabAvatar, Vector3.zero, prefabAvatar.transform.rotation);
				obj.transform.parent = rotator.transform;
				obj.transform.localPosition = new Vector3(0f, 1.5f, 2.5f * (float)i);
				obj.transform.localScale = new Vector3(0f, 0f, 0f);
				LeanTween.scale(obj, new Vector3(0.65f, 0.65f, 0.65f), 1f).setDelay((float)i * 0.2f).setEase(LeanTweenType.easeOutBack);
				float num = LeanTween.tau / 10f * (float)i;
				float r = Mathf.Sin(num + LeanTween.tau * 0f / 3f) * 0.5f + 0.5f;
				float g = Mathf.Sin(num + LeanTween.tau * 1f / 3f) * 0.5f + 0.5f;
				float b = Mathf.Sin(num + LeanTween.tau * 2f / 3f) * 0.5f + 0.5f;
				UnityEngine.Color to = new UnityEngine.Color(r, g, b);
				LeanTween.color(obj, to, 0.3f).setDelay(1.2f + (float)i * 0.4f);
				LeanTween.moveZ(obj, 0f, 0.3f).setDelay(1.2f + (float)i * 0.4f).setEase(LeanTweenType.easeSpring)
					.setOnComplete((Action)delegate
					{
						LeanTween.rotateAround(rotator, Vector3.forward, -1080f, 12f);
					});
				LeanTween.moveLocalY(obj, 4f, 1.2f).setDelay(5f + (float)i * 0.2f).setLoopPingPong(1)
					.setEase(LeanTweenType.easeInOutQuad);
				LeanTween.alpha(obj, 0f, 0.6f).setDelay(9.2f + (float)i * 0.4f).setDestroyOnComplete(doesDestroy: true)
					.setOnComplete((Action)delegate
					{
						UnityEngine.Object.Destroy(rotator);
					});
			}
		}).setOnCompleteOnStart(isOn: true).setRepeat(-1);
	}
}
public class GeneralBasics2dCS : MonoBehaviour
{
	public Texture2D dudeTexture;

	public GameObject prefabParticles;

	private void Start()
	{
		GameObject gameObject = createSpriteDude("avatarRotate", new Vector3(-2.51208f, 10.7119f, -14.37754f));
		GameObject obj = createSpriteDude("avatarScale", new Vector3(2.51208f, 10.2119f, -14.37754f));
		GameObject gameObject2 = createSpriteDude("avatarMove", new Vector3(-3.1208f, 7.100643f, -14.37754f));
		LeanTween.rotateAround(gameObject, Vector3.forward, -360f, 5f);
		LeanTween.scale(obj, new Vector3(1.7f, 1.7f, 1.7f), 5f).setEase(LeanTweenType.easeOutBounce);
		LeanTween.moveX(obj, obj.transform.position.x + 1f, 5f).setEase(LeanTweenType.easeOutBounce);
		LeanTween.move(gameObject2, gameObject2.transform.position + new Vector3(1.7f, 0f, 0f), 2f).setEase(LeanTweenType.easeInQuad);
		LeanTween.move(gameObject2, gameObject2.transform.position + new Vector3(2f, -1f, 0f), 2f).setDelay(3f);
		LeanTween.scale(obj, new Vector3(0.2f, 0.2f, 0.2f), 1f).setDelay(7f).setEase(LeanTweenType.easeInOutCirc)
			.setLoopPingPong(3);
		LeanTween.delayedCall(base.gameObject, 0.2f, advancedExamples);
	}

	private GameObject createSpriteDude(string name, Vector3 pos, bool hasParticles = true)
	{
		GameObject gameObject = new GameObject(name);
		SpriteRenderer spriteRenderer = gameObject.AddComponent<SpriteRenderer>();
		gameObject.GetComponent<SpriteRenderer>().color = new UnityEngine.Color(0f, 0.70980394f, 1f);
		spriteRenderer.sprite = Sprite.Create(dudeTexture, new Rect(0f, 0f, 256f, 256f), new Vector2(0.5f, 0f), 256f);
		gameObject.transform.position = pos;
		if (hasParticles)
		{
			GameObject obj = UnityEngine.Object.Instantiate(prefabParticles, Vector3.zero, prefabParticles.transform.rotation);
			obj.transform.parent = gameObject.transform;
			obj.transform.localPosition = prefabParticles.transform.position;
		}
		return gameObject;
	}

	private void advancedExamples()
	{
		LeanTween.delayedCall(base.gameObject, 14f, (Action)delegate
		{
			for (int i = 0; i < 10; i++)
			{
				GameObject rotator = new GameObject("rotator" + i);
				rotator.transform.position = new Vector3(2.71208f, 7.100643f, -12.37754f);
				GameObject obj = createSpriteDude("dude" + i, new Vector3(-2.51208f, 7.100643f, -14.37754f), hasParticles: false);
				obj.transform.parent = rotator.transform;
				obj.transform.localPosition = new Vector3(0f, 0.5f, 0.5f * (float)i);
				obj.transform.localScale = new Vector3(0f, 0f, 0f);
				LeanTween.scale(obj, new Vector3(0.65f, 0.65f, 0.65f), 1f).setDelay((float)i * 0.2f).setEase(LeanTweenType.easeOutBack);
				float num = LeanTween.tau / 10f * (float)i;
				float r = Mathf.Sin(num + LeanTween.tau * 0f / 3f) * 0.5f + 0.5f;
				float g = Mathf.Sin(num + LeanTween.tau * 1f / 3f) * 0.5f + 0.5f;
				float b = Mathf.Sin(num + LeanTween.tau * 2f / 3f) * 0.5f + 0.5f;
				UnityEngine.Color to = new UnityEngine.Color(r, g, b);
				LeanTween.color(obj, to, 0.3f).setDelay(1.2f + (float)i * 0.4f);
				LeanTween.moveLocalZ(obj, -2f, 0.3f).setDelay(1.2f + (float)i * 0.4f).setEase(LeanTweenType.easeSpring)
					.setOnComplete((Action)delegate
					{
						LeanTween.rotateAround(rotator, Vector3.forward, -1080f, 12f);
					});
				LeanTween.moveLocalY(obj, 1.17f, 1.2f).setDelay(5f + (float)i * 0.2f).setLoopPingPong(1)
					.setEase(LeanTweenType.easeInOutQuad);
				LeanTween.alpha(obj, 0f, 0.6f).setDelay(9.2f + (float)i * 0.4f).setDestroyOnComplete(doesDestroy: true)
					.setOnComplete((Action)delegate
					{
						UnityEngine.Object.Destroy(rotator);
					});
			}
		}).setOnCompleteOnStart(isOn: true).setRepeat(-1);
	}
}
public class GeneralCameraShake : MonoBehaviour
{
	private GameObject avatarBig;

	private float jumpIter = 9.5f;

	private AudioClip boomAudioClip;

	private void Start()
	{
		avatarBig = GameObject.Find("AvatarBig");
		AnimationCurve volume = new AnimationCurve(new Keyframe(8.130963E-06f, 0.06526042f, 0f, -1f), new Keyframe(0.0007692695f, 2.449077f, 9.078861f, 9.078861f), new Keyframe(0.01541314f, 0.9343268f, -40f, -40f), new Keyframe(0.05169491f, 0.03835937f, -0.08621139f, -0.08621139f));
		AnimationCurve frequency = new AnimationCurve(new Keyframe(0f, 0.003005181f, 0f, 0f), new Keyframe(0.01507768f, 0.002227979f, 0f, 0f));
		boomAudioClip = LeanAudio.createAudio(volume, frequency, LeanAudio.options().setVibrato(new Vector3[1]
		{
			new Vector3(0.1f, 0f, 0f)
		}));
		bigGuyJump();
	}

	private void bigGuyJump()
	{
		float height = Mathf.PerlinNoise(jumpIter, 0f) * 10f;
		height = height * height * 0.3f;
		LeanTween.moveY(avatarBig, height, 1f).setEase(LeanTweenType.easeInOutQuad).setOnComplete((Action)delegate
		{
			LeanTween.moveY(avatarBig, 0f, 0.27f).setEase(LeanTweenType.easeInQuad).setOnComplete((Action)delegate
			{
				LeanTween.cancel(base.gameObject);
				float num = height * 0.2f;
				float time = 0.42f;
				float time2 = 1.6f;
				LTDescr shakeTween = LeanTween.rotateAroundLocal(base.gameObject, Vector3.right, num, time).setEase(LeanTweenType.easeShake).setLoopClamp()
					.setRepeat(-1);
				LeanTween.value(base.gameObject, num, 0f, time2).setOnUpdate(delegate(float val)
				{
					shakeTween.setTo(Vector3.right * val);
				}).setEase(LeanTweenType.easeOutQuad);
				GameObject[] array = GameObject.FindGameObjectsWithTag("Respawn");
				for (int i = 0; i < array.Length; i++)
				{
					array[i].GetComponent<Rigidbody>().AddForce(Vector3.up * 100f * height);
				}
				array = GameObject.FindGameObjectsWithTag("GameController");
				foreach (GameObject obj in array)
				{
					float z = obj.transform.eulerAngles.z;
					z = ((z > 0f && z < 180f) ? 1 : (-1));
					obj.GetComponent<Rigidbody>().AddForce(new Vector3(z, 0f, 0f) * 15f * height);
				}
				LeanAudio.play(boomAudioClip, base.transform.position, height * 0.2f);
				LeanTween.delayedCall(2f, bigGuyJump);
			});
		});
		jumpIter += 5.2f;
	}
}
public class GeneralEasingTypes : MonoBehaviour
{
	public float lineDrawScale = 10f;

	public AnimationCurve animationCurve;

	private string[] easeTypes = new string[35]
	{
		"EaseLinear", "EaseAnimationCurve", "EaseSpring", "EaseInQuad", "EaseOutQuad", "EaseInOutQuad", "EaseInCubic", "EaseOutCubic", "EaseInOutCubic", "EaseInQuart",
		"EaseOutQuart", "EaseInOutQuart", "EaseInQuint", "EaseOutQuint", "EaseInOutQuint", "EaseInSine", "EaseOutSine", "EaseInOutSine", "EaseInExpo", "EaseOutExpo",
		"EaseInOutExpo", "EaseInCirc", "EaseOutCirc", "EaseInOutCirc", "EaseInBounce", "EaseOutBounce", "EaseInOutBounce", "EaseInBack", "EaseOutBack", "EaseInOutBack",
		"EaseInElastic", "EaseOutElastic", "EaseInOutElastic", "EasePunch", "EaseShake"
	};

	private void Start()
	{
		demoEaseTypes();
	}

	private void demoEaseTypes()
	{
		for (int i = 0; i < easeTypes.Length; i++)
		{
			string text = easeTypes[i];
			Transform obj1 = GameObject.Find(text).transform.Find("Line");
			float obj1val = 0f;
			LTDescr lTDescr = LeanTween.value(obj1.gameObject, 0f, 1f, 5f).setOnUpdate(delegate(float val)
			{
				Vector3 localPosition = obj1.localPosition;
				localPosition.x = obj1val * lineDrawScale;
				localPosition.y = val * lineDrawScale;
				obj1.localPosition = localPosition;
				obj1val += Time.deltaTime / 5f;
				if (obj1val > 1f)
				{
					obj1val = 0f;
				}
			});
			if (text.IndexOf("AnimationCurve") >= 0)
			{
				lTDescr.setEase(animationCurve);
			}
			else
			{
				lTDescr.GetType().GetMethod("set" + text).Invoke(lTDescr, null);
			}
			if (text.IndexOf("EasePunch") >= 0)
			{
				lTDescr.setScale(1f);
			}
			else if (text.IndexOf("EaseOutBounce") >= 0)
			{
				lTDescr.setOvershoot(2f);
			}
		}
		LeanTween.delayedCall(base.gameObject, 10f, resetLines);
		LeanTween.delayedCall(base.gameObject, 10.1f, demoEaseTypes);
	}

	private void resetLines()
	{
		for (int i = 0; i < easeTypes.Length; i++)
		{
			GameObject.Find(easeTypes[i]).transform.Find("Line").localPosition = new Vector3(0f, 0f, 0f);
		}
	}
}
public class GeneralEventsListenersCS : MonoBehaviour
{
	public enum MyEvents
	{
		CHANGE_COLOR,
		JUMP,
		LENGTH
	}

	private Vector3 towardsRotation;

	private float turnForLength = 0.5f;

	private float turnForIter;

	private UnityEngine.Color fromColor;

	private void Awake()
	{
		LeanTween.LISTENERS_MAX = 100;
		LeanTween.EVENTS_MAX = 2;
		fromColor = GetComponent<Renderer>().material.color;
	}

	private void Start()
	{
		LeanTween.addListener(base.gameObject, 0, changeColor);
		LeanTween.addListener(base.gameObject, 1, jumpUp);
	}

	private void jumpUp(LTEvent e)
	{
		GetComponent<Rigidbody>().AddRelativeForce(Vector3.forward * 300f);
	}

	private void changeColor(LTEvent e)
	{
		float num = Vector3.Distance(((Transform)e.data).position, base.transform.position);
		LeanTween.value(to: new UnityEngine.Color(UnityEngine.Random.Range(0f, 1f), 0f, UnityEngine.Random.Range(0f, 1f)), gameObject: base.gameObject, from: fromColor, time: 0.8f).setLoopPingPong(1).setDelay(num * 0.05f)
			.setOnUpdate(delegate(UnityEngine.Color col)
			{
				GetComponent<Renderer>().material.color = col;
			});
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (collision.gameObject.layer != 2)
		{
			towardsRotation = new Vector3(0f, UnityEngine.Random.Range(-180, 180), 0f);
		}
	}

	private void OnCollisionStay(Collision collision)
	{
		if (collision.gameObject.layer != 2)
		{
			turnForIter = 0f;
			turnForLength = UnityEngine.Random.Range(0.5f, 1.5f);
		}
	}

	private void FixedUpdate()
	{
		if (turnForIter < turnForLength)
		{
			GetComponent<Rigidbody>().MoveRotation(GetComponent<Rigidbody>().rotation * Quaternion.Euler(towardsRotation * Time.deltaTime));
			turnForIter += Time.deltaTime;
		}
		GetComponent<Rigidbody>().AddRelativeForce(Vector3.forward * 4.5f);
	}

	private void OnMouseDown()
	{
		if (Input.GetKey(KeyCode.J))
		{
			LeanTween.dispatchEvent(1);
		}
		else
		{
			LeanTween.dispatchEvent(0, base.transform);
		}
	}
}
public class GeneralSequencer : MonoBehaviour
{
	public GameObject avatar1;

	public GameObject star;

	public GameObject dustCloudPrefab;

	public float speedScale = 1f;

	public void Start()
	{
		LTSeq lTSeq = LeanTween.sequence();
		lTSeq.append(LeanTween.moveY(avatar1, avatar1.transform.localPosition.y + 6f, 1f).setEaseOutQuad());
		lTSeq.insert(LeanTween.alpha(star, 0f, 1f));
		lTSeq.insert(LeanTween.scale(star, Vector3.one * 3f, 1f));
		lTSeq.append(LeanTween.rotateAround(avatar1, Vector3.forward, 360f, 0.6f).setEaseInBack());
		lTSeq.append(LeanTween.moveY(avatar1, avatar1.transform.localPosition.y, 1f).setEaseInQuad());
		lTSeq.append(delegate
		{
			for (int i = 0; (float)i < 50f; i++)
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(dustCloudPrefab);
				gameObject.transform.parent = avatar1.transform;
				gameObject.transform.localPosition = new Vector3(UnityEngine.Random.Range(-2f, 2f), 0f, 0f);
				gameObject.transform.eulerAngles = new Vector3(0f, 0f, UnityEngine.Random.Range(0f, 360f));
				Vector3 to = new Vector3(gameObject.transform.localPosition.x, UnityEngine.Random.Range(2f, 4f), UnityEngine.Random.Range(-10f, 10f));
				LeanTween.moveLocal(gameObject, to, 3f * speedScale).setEaseOutCirc();
				LeanTween.rotateAround(gameObject, Vector3.forward, 720f, 3f * speedScale).setEaseOutCirc();
				LeanTween.alpha(gameObject, 0f, 3f * speedScale).setEaseOutCirc().setDestroyOnComplete(doesDestroy: true);
			}
		});
		lTSeq.setScale(speedScale);
	}
}
public class GeneralSimpleUiCS : MonoBehaviour
{
	public RectTransform button;

	private void Start()
	{
		UnityEngine.Debug.Log("For better examples see the 4.6_Examples folder!");
		if (button == null)
		{
			UnityEngine.Debug.LogError("Button not assigned! Create a new button via Hierarchy->Create->UI->Button. Then assign it to the button variable");
			return;
		}
		LeanTween.value(button.gameObject, button.anchoredPosition, new Vector2(200f, 100f), 1f).setOnUpdate(delegate(Vector2 val)
		{
			button.anchoredPosition = val;
		});
		LeanTween.value(base.gameObject, 1f, 0.5f, 1f).setOnUpdate(delegate(float volume)
		{
			UnityEngine.Debug.Log("volume:" + volume);
		});
		LeanTween.value(base.gameObject, base.gameObject.transform.position, base.gameObject.transform.position + new Vector3(0f, 1f, 0f), 1f).setOnUpdate(delegate(Vector3 val)
		{
			base.gameObject.transform.position = val;
		});
		LeanTween.value(base.gameObject, UnityEngine.Color.red, UnityEngine.Color.green, 1f).setOnUpdate(delegate(UnityEngine.Color val)
		{
			((UnityEngine.UI.Image)button.gameObject.GetComponent(typeof(UnityEngine.UI.Image))).color = val;
		});
		LeanTween.move(button, new Vector3(200f, -100f, 0f), 1f).setDelay(1f);
		LeanTween.rotateAround(button, Vector3.forward, 90f, 1f).setDelay(2f);
		LeanTween.scale(button, button.localScale * 2f, 1f).setDelay(3f);
		LeanTween.rotateAround(button, Vector3.forward, -90f, 1f).setDelay(4f).setEase(LeanTweenType.easeInOutElastic);
	}
}
public class GeneralUISpaceCS : MonoBehaviour
{
	public RectTransform mainWindow;

	public RectTransform mainParagraphText;

	public RectTransform mainTitleText;

	public RectTransform mainButton1;

	public RectTransform mainButton2;

	public RectTransform pauseRing1;

	public RectTransform pauseRing2;

	public RectTransform pauseWindow;

	public RectTransform chatWindow;

	public RectTransform chatRect;

	public Sprite[] chatSprites;

	public RectTransform chatBar1;

	public RectTransform chatBar2;

	public Text chatText;

	public RectTransform rawImageRect;

	private void Start()
	{
		mainWindow.localScale = Vector3.zero;
		LeanTween.scale(mainWindow, new Vector3(1f, 1f, 1f), 0.6f).setEase(LeanTweenType.easeOutBack);
		LeanTween.alphaCanvas(mainWindow.GetComponent<CanvasGroup>(), 0f, 1f).setDelay(2f).setLoopPingPong()
			.setRepeat(2);
		mainParagraphText.anchoredPosition3D += new Vector3(0f, -10f, 0f);
		LeanTween.textAlpha(mainParagraphText, 0f, 0.6f).setFrom(0f).setDelay(0f);
		LeanTween.textAlpha(mainParagraphText, 1f, 0.6f).setEase(LeanTweenType.easeOutQuad).setDelay(0.6f);
		LeanTween.move(mainParagraphText, mainParagraphText.anchoredPosition3D + new Vector3(0f, 10f, 0f), 0.6f).setEase(LeanTweenType.easeOutQuad).setDelay(0.6f);
		LeanTween.textColor(mainTitleText, new UnityEngine.Color(0.52156866f, 29f / 51f, 0.8745098f), 0.6f).setEase(LeanTweenType.easeOutQuad).setDelay(0.6f)
			.setLoopPingPong()
			.setRepeat(-1);
		LeanTween.textAlpha(mainButton2, 1f, 2f).setFrom(0f).setDelay(0f)
			.setEase(LeanTweenType.easeOutQuad);
		LeanTween.alpha(mainButton2, 1f, 2f).setFrom(0f).setDelay(0f)
			.setEase(LeanTweenType.easeOutQuad);
		LeanTween.size(mainButton1, mainButton1.sizeDelta * 1.1f, 0.5f).setDelay(3f).setEaseInOutCirc()
			.setRepeat(6)
			.setLoopPingPong();
		pauseWindow.anchoredPosition3D += new Vector3(0f, 200f, 0f);
		LeanTween.moveY(pauseWindow, pauseWindow.anchoredPosition3D.y + -200f, 0.6f).setEase(LeanTweenType.easeOutSine).setDelay(0.6f);
		RectTransform component = pauseWindow.Find("PauseText").GetComponent<RectTransform>();
		LeanTween.moveZ(component, component.anchoredPosition3D.z - 80f, 1.5f).setEase(LeanTweenType.punch).setDelay(2f);
		LeanTween.rotateAroundLocal(pauseRing1, Vector3.forward, 360f, 12f).setRepeat(-1);
		LeanTween.rotateAroundLocal(pauseRing2, Vector3.forward, -360f, 22f).setRepeat(-1);
		chatWindow.RotateAround(chatWindow.position, Vector3.up, -180f);
		LeanTween.rotateAround(chatWindow, Vector3.up, 180f, 2f).setEase(LeanTweenType.easeOutElastic).setDelay(1.2f);
		LeanTween.play(chatRect, chatSprites).setLoopPingPong();
		LeanTween.color(chatBar2, new UnityEngine.Color(0.972549f, 0.2627451f, 36f / 85f, 0.5f), 1.2f).setEase(LeanTweenType.easeInQuad).setLoopPingPong()
			.setDelay(1.2f);
		LeanTween.scale(chatBar2, new Vector2(1f, 0.7f), 1.2f).setEase(LeanTweenType.easeInQuad).setLoopPingPong();
		string origText = chatText.text;
		chatText.text = "";
		LeanTween.value(base.gameObject, 0f, origText.Length, 6f).setEase(LeanTweenType.easeOutQuad).setOnUpdate(delegate(float val)
		{
			chatText.text = origText.Substring(0, Mathf.RoundToInt(val));
		})
			.setLoopClamp()
			.setDelay(2f);
		LeanTween.alpha(rawImageRect, 0f, 1f).setLoopPingPong();
	}
}
public class LogoCinematic : MonoBehaviour
{
	public GameObject lean;

	public GameObject tween;

	private void Awake()
	{
	}

	private void Start()
	{
		tween.transform.localPosition += -Vector3.right * 15f;
		LeanTween.moveLocalX(tween, tween.transform.localPosition.x + 15f, 0.4f).setEase(LeanTweenType.linear).setDelay(0f)
			.setOnComplete(playBoom);
		tween.transform.RotateAround(tween.transform.position, Vector3.forward, -30f);
		LeanTween.rotateAround(tween, Vector3.forward, 30f, 0.4f).setEase(LeanTweenType.easeInQuad).setDelay(0.4f)
			.setOnComplete(playBoom);
		lean.transform.position += Vector3.up * 5.1f;
		LeanTween.moveY(lean, lean.transform.position.y - 5.1f, 0.6f).setEase(LeanTweenType.easeInQuad).setDelay(0.6f)
			.setOnComplete(playBoom);
	}

	private void playBoom()
	{
		AnimationCurve volume = new AnimationCurve(new Keyframe(0f, 1.163155f, 0f, -1f), new Keyframe(0.3098361f, 0f, 0f, 0f), new Keyframe(0.5f, 0.003524712f, 0f, 0f));
		AnimationCurve frequency = new AnimationCurve(new Keyframe(0.000819672f, 0.007666667f, 0f, 0f), new Keyframe(0.01065573f, 0.002424242f, 0f, 0f), new Keyframe(0.02704918f, 0.007454545f, 0f, 0f), new Keyframe(0.03770492f, 0.002575758f, 0f, 0f), new Keyframe(0.052459f, 0.007090909f, 0f, 0f), new Keyframe(0.06885245f, 0.002939394f, 0f, 0f), new Keyframe(0.0819672f, 0.006727273f, 0f, 0f), new Keyframe(0.1040983f, 0.003181818f, 0f, 0f), new Keyframe(0.1188525f, 0.006212121f, 0f, 0f), new Keyframe(0.145082f, 0.004151515f, 0f, 0f), new Keyframe(0.1893443f, 0.005636364f, 0f, 0f));
		LeanAudio.play(LeanAudio.createAudio(volume, frequency, LeanAudio.options().setVibrato(new Vector3[1]
		{
			new Vector3(0.1f, 0f, 0f)
		}).setFrequency(11025)));
	}
}
public class PathBezier2d : MonoBehaviour
{
	public Transform[] cubes;

	public GameObject dude1;

	public GameObject dude2;

	private LTBezierPath visualizePath;

	private void Start()
	{
		Vector3[] array = new Vector3[4]
		{
			cubes[0].position,
			cubes[1].position,
			cubes[2].position,
			cubes[3].position
		};
		visualizePath = new LTBezierPath(array);
		LeanTween.move(dude1, array, 10f).setOrientToPath2d(doesOrient2d: true);
		LeanTween.moveLocal(dude2, array, 10f).setOrientToPath2d(doesOrient2d: true);
	}

	private void OnDrawGizmos()
	{
		Gizmos.color = UnityEngine.Color.red;
		if (visualizePath != null)
		{
			visualizePath.gizmoDraw();
		}
	}
}
public class ExampleSpline : MonoBehaviour
{
	public Transform[] trans;

	private LTSpline spline;

	private GameObject ltLogo;

	private GameObject ltLogo2;

	private float iter;

	private void Start()
	{
		spline = new LTSpline(new Vector3[5]
		{
			trans[0].position,
			trans[1].position,
			trans[2].position,
			trans[3].position,
			trans[4].position
		});
		ltLogo = GameObject.Find("LeanTweenLogo1");
		ltLogo2 = GameObject.Find("LeanTweenLogo2");
		LeanTween.moveSpline(ltLogo2, spline.pts, 1f).setEase(LeanTweenType.easeInOutQuad).setLoopPingPong()
			.setOrientToPath(doesOrient: true);
		LeanTween.moveSpline(ltLogo2, new Vector3[5]
		{
			Vector3.zero,
			Vector3.zero,
			new Vector3(1f, 1f, 1f),
			new Vector3(2f, 1f, 1f),
			new Vector3(2f, 1f, 1f)
		}, 1.5f).setUseEstimatedTime(useEstimatedTime: true);
	}

	private void Update()
	{
		ltLogo.transform.position = spline.point(iter);
		iter += Time.deltaTime * 0.1f;
		if (iter > 1f)
		{
			iter = 0f;
		}
	}

	private void OnDrawGizmos()
	{
		if (spline != null)
		{
			spline.gizmoDraw();
		}
	}
}
public class PathSpline2d : MonoBehaviour
{
	public Transform[] cubes;

	public GameObject dude1;

	public GameObject dude2;

	private LTSpline visualizePath;

	private void Start()
	{
		Vector3[] array = new Vector3[5]
		{
			cubes[0].position,
			cubes[1].position,
			cubes[2].position,
			cubes[3].position,
			cubes[4].position
		};
		visualizePath = new LTSpline(array);
		LeanTween.moveSpline(dude1, array, 10f).setOrientToPath2d(doesOrient2d: true).setSpeed(2f);
		LeanTween.moveSplineLocal(dude2, array, 10f).setOrientToPath2d(doesOrient2d: true).setSpeed(2f);
	}

	private void OnDrawGizmos()
	{
		Gizmos.color = UnityEngine.Color.red;
		if (visualizePath != null)
		{
			visualizePath.gizmoDraw();
		}
	}
}
public class PathSplineEndlessCS : MonoBehaviour
{
	public GameObject trackTrailRenderers;

	public GameObject car;

	public GameObject carInternal;

	public GameObject[] cubes;

	private int cubesIter;

	public GameObject[] trees;

	private int treesIter;

	public float randomIterWidth = 0.1f;

	private LTSpline track;

	private List<Vector3> trackPts = new List<Vector3>();

	private int zIter;

	private float carIter;

	private float carAdd;

	private int trackMaxItems = 15;

	private int trackIter = 1;

	private float pushTrackAhead;

	private float randomIter;

	private void Start()
	{
		for (int i = 0; i < 4; i++)
		{
			addRandomTrackPoint();
		}
		refreshSpline();
		LeanTween.value(base.gameObject, 0f, 0.3f, 2f).setOnUpdate(delegate(float val)
		{
			pushTrackAhead = val;
		});
	}

	private void Update()
	{
		if (trackPts[trackPts.Count - 1].z - base.transform.position.z < 200f)
		{
			addRandomTrackPoint();
			refreshSpline();
		}
		track.place(car.transform, carIter);
		carIter += carAdd * Time.deltaTime;
		track.place(trackTrailRenderers.transform, carIter + pushTrackAhead);
		float axis = Input.GetAxis("Horizontal");
		if (Input.anyKeyDown)
		{
			if (axis < 0f && trackIter > 0)
			{
				trackIter--;
				playSwish();
			}
			else if (axis > 0f && trackIter < 2)
			{
				trackIter++;
				playSwish();
			}
			LeanTween.moveLocalX(carInternal, (float)(trackIter - 1) * 6f, 0.3f).setEase(LeanTweenType.easeOutBack);
		}
	}

	private GameObject objectQueue(GameObject[] arr, ref int lastIter)
	{
		lastIter = ((lastIter < arr.Length - 1) ? (lastIter + 1) : 0);
		arr[lastIter].transform.localScale = Vector3.one;
		arr[lastIter].transform.rotation = Quaternion.identity;
		return arr[lastIter];
	}

	private void addRandomTrackPoint()
	{
		float num = Mathf.PerlinNoise(0f, randomIter);
		randomIter += randomIterWidth;
		Vector3 vector = new Vector3((num - 0.5f) * 20f, 0f, (float)zIter * 40f);
		objectQueue(cubes, ref cubesIter).transform.position = vector;
		GameObject obj = objectQueue(trees, ref treesIter);
		float num2 = ((zIter % 2 == 0) ? (-15f) : 15f);
		obj.transform.position = new Vector3(vector.x + num2, 0f, (float)zIter * 40f);
		LeanTween.rotateAround(obj, Vector3.forward, 0f, 1f).setFrom((zIter % 2 == 0) ? 180f : (-180f)).setEase(LeanTweenType.easeOutBack);
		trackPts.Add(vector);
		if (trackPts.Count > trackMaxItems)
		{
			trackPts.RemoveAt(0);
		}
		zIter++;
	}

	private void refreshSpline()
	{
		track = new LTSpline(trackPts.ToArray());
		carIter = track.ratioAtPoint(car.transform.position);
		carAdd = 40f / track.distance;
	}

	private void playSwish()
	{
		AnimationCurve volume = new AnimationCurve(new Keyframe(0f, 0.005464481f, 1.83897f, 0f), new Keyframe(0.1114856f, 2.281785f, 0f, 0f), new Keyframe(0.2482903f, 2.271654f, 0f, 0f), new Keyframe(0.3f, 0.01670286f, 0f, 0f));
		AnimationCurve frequency = new AnimationCurve(new Keyframe(0f, 0.00136725f, 0f, 0f), new Keyframe(0.1482391f, 0.005405405f, 0f, 0f), new Keyframe(0.2650336f, 0.002480127f, 0f, 0f));
		LeanAudio.play(LeanAudio.createAudio(volume, frequency, LeanAudio.options().setVibrato(new Vector3[1]
		{
			new Vector3(0.2f, 0.5f, 0f)
		}).setWaveNoise()
			.setWaveNoiseScale(1000f)));
	}
}
public class PathSplinePerformanceCS : MonoBehaviour
{
	public GameObject trackTrailRenderers;

	public GameObject car;

	public GameObject carInternal;

	public float circleLength = 10f;

	public float randomRange = 1f;

	public int trackNodes = 30;

	public float carSpeed = 30f;

	public float tracerSpeed = 2f;

	private LTSpline track;

	private int trackIter = 1;

	private float carAdd;

	private float trackPosition;

	private void Start()
	{
		Application.targetFrameRate = 240;
		List<Vector3> list = new List<Vector3>();
		float num = 0f;
		int num2 = trackNodes + 1;
		for (int i = 0; i < num2; i++)
		{
			float x = Mathf.Cos(num * ((float)Math.PI / 180f)) * circleLength + UnityEngine.Random.Range(0f, randomRange);
			float z = Mathf.Sin(num * ((float)Math.PI / 180f)) * circleLength + UnityEngine.Random.Range(0f, randomRange);
			list.Add(new Vector3(x, 1f, z));
			num += 360f / (float)trackNodes;
		}
		list[0] = list[list.Count - 1];
		list.Add(list[1]);
		list.Add(list[2]);
		track = new LTSpline(list.ToArray());
		carAdd = carSpeed / track.distance;
		tracerSpeed = track.distance / (carSpeed * 1.2f);
		LeanTween.moveSpline(trackTrailRenderers, track, tracerSpeed).setOrientToPath(doesOrient: true).setRepeat(-1);
	}

	private void Update()
	{
		float axis = Input.GetAxis("Horizontal");
		if (Input.anyKeyDown)
		{
			if (axis < 0f && trackIter > 0)
			{
				trackIter--;
				playSwish();
			}
			else if (axis > 0f && trackIter < 2)
			{
				trackIter++;
				playSwish();
			}
			LeanTween.moveLocalX(carInternal, (float)(trackIter - 1) * 6f, 0.3f).setEase(LeanTweenType.easeOutBack);
		}
		track.place(car.transform, trackPosition);
		trackPosition += Time.deltaTime * carAdd;
		if (trackPosition > 1f)
		{
			trackPosition = 0f;
		}
	}

	private void OnDrawGizmos()
	{
		if (track != null)
		{
			track.drawGizmo(UnityEngine.Color.red);
		}
	}

	private void playSwish()
	{
		AnimationCurve volume = new AnimationCurve(new Keyframe(0f, 0.005464481f, 1.83897f, 0f), new Keyframe(0.1114856f, 2.281785f, 0f, 0f), new Keyframe(0.2482903f, 2.271654f, 0f, 0f), new Keyframe(0.3f, 0.01670286f, 0f, 0f));
		AnimationCurve frequency = new AnimationCurve(new Keyframe(0f, 0.00136725f, 0f, 0f), new Keyframe(0.1482391f, 0.005405405f, 0f, 0f), new Keyframe(0.2650336f, 0.002480127f, 0f, 0f));
		LeanAudio.play(LeanAudio.createAudio(volume, frequency, LeanAudio.options().setVibrato(new Vector3[1]
		{
			new Vector3(0.2f, 0.5f, 0f)
		}).setWaveNoise()
			.setWaveNoiseScale(1000f)));
	}
}
public class PathSplines : MonoBehaviour
{
	public Transform[] trans;

	private LTSpline cr;

	private GameObject avatar1;

	private float iter;

	private void OnEnable()
	{
		cr = new LTSpline(new Vector3[5]
		{
			trans[0].position,
			trans[1].position,
			trans[2].position,
			trans[3].position,
			trans[4].position
		});
	}

	private void Start()
	{
		avatar1 = GameObject.Find("Avatar1");
		LeanTween.move(avatar1, cr, 6.5f).setOrientToPath(doesOrient: true).setRepeat(1)
			.setOnComplete((Action)delegate
			{
				Vector3[] to = new Vector3[5]
				{
					trans[4].position,
					trans[3].position,
					trans[2].position,
					trans[1].position,
					trans[0].position
				};
				LeanTween.moveSpline(avatar1, to, 6.5f);
			})
			.setEase(LeanTweenType.easeOutQuad);
	}

	private void Update()
	{
		iter += Time.deltaTime * 0.07f;
		if (iter > 1f)
		{
			iter = 0f;
		}
	}

	private void OnDrawGizmos()
	{
		if (cr == null)
		{
			OnEnable();
		}
		Gizmos.color = UnityEngine.Color.red;
		if (cr != null)
		{
			cr.gizmoDraw();
		}
	}
}
public class PathSplineTrackCS : MonoBehaviour
{
	public GameObject car;

	public GameObject carInternal;

	public GameObject trackTrailRenderers;

	public Transform[] trackOnePoints;

	private LTSpline track;

	private int trackIter = 1;

	private float trackPosition;

	private void Start()
	{
		track = new LTSpline(new Vector3[7]
		{
			trackOnePoints[0].position,
			trackOnePoints[1].position,
			trackOnePoints[2].position,
			trackOnePoints[3].position,
			trackOnePoints[4].position,
			trackOnePoints[5].position,
			trackOnePoints[6].position
		});
		LeanTween.moveSpline(trackTrailRenderers, track, 2f).setOrientToPath(doesOrient: true).setRepeat(-1);
	}

	private void Update()
	{
		float axis = Input.GetAxis("Horizontal");
		if (Input.anyKeyDown)
		{
			if (axis < 0f && trackIter > 0)
			{
				trackIter--;
				playSwish();
			}
			else if (axis > 0f && trackIter < 2)
			{
				trackIter++;
				playSwish();
			}
			LeanTween.moveLocalX(carInternal, (float)(trackIter - 1) * 6f, 0.3f).setEase(LeanTweenType.easeOutBack);
		}
		track.place(car.transform, trackPosition);
		trackPosition += Time.deltaTime * 0.03f;
		if (trackPosition < 0f)
		{
			trackPosition = 1f;
		}
		else if (trackPosition > 1f)
		{
			trackPosition = 0f;
		}
	}

	private void OnDrawGizmos()
	{
		LTSpline.drawGizmo(trackOnePoints, UnityEngine.Color.red);
	}

	private void playSwish()
	{
		AnimationCurve volume = new AnimationCurve(new Keyframe(0f, 0.005464481f, 1.83897f, 0f), new Keyframe(0.1114856f, 2.281785f, 0f, 0f), new Keyframe(0.2482903f, 2.271654f, 0f, 0f), new Keyframe(0.3f, 0.01670286f, 0f, 0f));
		AnimationCurve frequency = new AnimationCurve(new Keyframe(0f, 0.00136725f, 0f, 0f), new Keyframe(0.1482391f, 0.005405405f, 0f, 0f), new Keyframe(0.2650336f, 0.002480127f, 0f, 0f));
		LeanAudio.play(LeanAudio.createAudio(volume, frequency, LeanAudio.options().setVibrato(new Vector3[1]
		{
			new Vector3(0.2f, 0.5f, 0f)
		}).setWaveNoise()
			.setWaveNoiseScale(1000f)));
	}
}
public class TestingAllCS : MonoBehaviour
{
	public delegate void NextFunc();

	public enum TimingType
	{
		SteadyNormalTime,
		IgnoreTimeScale,
		HalfTimeScale,
		VariableTimeScale,
		Length
	}

	public AnimationCurve customAnimationCurve;

	public Transform pt1;

	public Transform pt2;

	public Transform pt3;

	public Transform pt4;

	public Transform pt5;

	private int exampleIter;

	private string[] exampleFunctions = new string[14]
	{
		"updateValue3Example", "loopTestClamp", "loopTestPingPong", "moveOnACurveExample", "customTweenExample", "moveExample", "rotateExample", "scaleExample", "updateValueExample", "delayedCallExample",
		"alphaExample", "moveLocalExample", "rotateAroundExample", "colorExample"
	};

	public bool useEstimatedTime = true;

	private GameObject ltLogo;

	private TimingType timingType;

	private int descrTimeScaleChangeId;

	private Vector3 origin;

	private void Awake()
	{
	}

	private void Start()
	{
		ltLogo = GameObject.Find("LeanTweenLogo");
		LeanTween.delayedCall(1f, cycleThroughExamples);
		origin = ltLogo.transform.position;
	}

	private void pauseNow()
	{
		Time.timeScale = 0f;
		UnityEngine.Debug.Log("pausing");
	}

	private void OnGUI()
	{
		string text = (useEstimatedTime ? "useEstimatedTime" : ("timeScale:" + Time.timeScale));
		GUI.Label(new Rect(0.03f * (float)Screen.width, 0.03f * (float)Screen.height, 0.5f * (float)Screen.width, 0.3f * (float)Screen.height), text);
	}

	private void endlessCallback()
	{
		UnityEngine.Debug.Log("endless");
	}

	private void cycleThroughExamples()
	{
		if (exampleIter == 0)
		{
			int num = (int)(timingType + 1);
			if (num > 4)
			{
				num = 0;
			}
			timingType = (TimingType)num;
			useEstimatedTime = timingType == TimingType.IgnoreTimeScale;
			Time.timeScale = (useEstimatedTime ? 0f : 1f);
			if (timingType == TimingType.HalfTimeScale)
			{
				Time.timeScale = 0.5f;
			}
			if (timingType == TimingType.VariableTimeScale)
			{
				descrTimeScaleChangeId = LeanTween.value(base.gameObject, 0.01f, 10f, 3f).setOnUpdate(delegate(float val)
				{
					Time.timeScale = val;
				}).setEase(LeanTweenType.easeInQuad)
					.setUseEstimatedTime(useEstimatedTime: true)
					.setRepeat(-1)
					.id;
			}
			else
			{
				UnityEngine.Debug.Log("cancel variable time");
				LeanTween.cancel(descrTimeScaleChangeId);
			}
		}
		base.gameObject.BroadcastMessage(exampleFunctions[exampleIter]);
		float delayTime = 1.1f;
		LeanTween.delayedCall(base.gameObject, delayTime, cycleThroughExamples).setUseEstimatedTime(useEstimatedTime);
		exampleIter = ((exampleIter + 1 < exampleFunctions.Length) ? (exampleIter + 1) : 0);
	}

	public void updateValue3Example()
	{
		UnityEngine.Debug.Log("updateValue3Example Time:" + Time.time);
		LeanTween.value(base.gameObject, updateValue3ExampleCallback, new Vector3(0f, 270f, 0f), new Vector3(30f, 270f, 180f), 0.5f).setEase(LeanTweenType.easeInBounce).setRepeat(2)
			.setLoopPingPong()
			.setOnUpdateVector3(updateValue3ExampleUpdate)
			.setUseEstimatedTime(useEstimatedTime);
	}

	public void updateValue3ExampleUpdate(Vector3 val)
	{
	}

	public void updateValue3ExampleCallback(Vector3 val)
	{
		ltLogo.transform.eulerAngles = val;
	}

	public void loopTestClamp()
	{
		UnityEngine.Debug.Log("loopTestClamp Time:" + Time.time);
		GameObject obj = GameObject.Find("Cube1");
		obj.transform.localScale = new Vector3(1f, 1f, 1f);
		LeanTween.scaleZ(obj, 4f, 1f).setEase(LeanTweenType.easeOutElastic).setRepeat(7)
			.setLoopClamp()
			.setUseEstimatedTime(useEstimatedTime);
	}

	public void loopTestPingPong()
	{
		UnityEngine.Debug.Log("loopTestPingPong Time:" + Time.time);
		GameObject obj = GameObject.Find("Cube2");
		obj.transform.localScale = new Vector3(1f, 1f, 1f);
		LeanTween.scaleY(obj, 4f, 1f).setEase(LeanTweenType.easeOutQuad).setLoopPingPong(4)
			.setUseEstimatedTime(useEstimatedTime);
	}

	public void colorExample()
	{
		LeanTween.color(GameObject.Find("LCharacter"), new UnityEngine.Color(1f, 0f, 0f, 0.5f), 0.5f).setEase(LeanTweenType.easeOutBounce).setRepeat(2)
			.setLoopPingPong()
			.setUseEstimatedTime(useEstimatedTime);
	}

	public void moveOnACurveExample()
	{
		UnityEngine.Debug.Log("moveOnACurveExample Time:" + Time.time);
		Vector3[] to = new Vector3[8] { origin, pt1.position, pt2.position, pt3.position, pt3.position, pt4.position, pt5.position, origin };
		LeanTween.move(ltLogo, to, 1f).setEase(LeanTweenType.easeOutQuad).setOrientToPath(doesOrient: true)
			.setUseEstimatedTime(useEstimatedTime);
	}

	public void customTweenExample()
	{
		UnityEngine.Debug.Log(string.Concat("customTweenExample starting pos:", ltLogo.transform.position, " origin:", origin));
		LeanTween.moveX(ltLogo, -10f, 0.5f).setEase(customAnimationCurve).setUseEstimatedTime(useEstimatedTime);
		LeanTween.moveX(ltLogo, 0f, 0.5f).setEase(customAnimationCurve).setDelay(0.5f)
			.setUseEstimatedTime(useEstimatedTime);
	}

	public void moveExample()
	{
		UnityEngine.Debug.Log("moveExample");
		LeanTween.move(ltLogo, new Vector3(-2f, -1f, 0f), 0.5f).setUseEstimatedTime(useEstimatedTime);
		LeanTween.move(ltLogo, origin, 0.5f).setDelay(0.5f).setUseEstimatedTime(useEstimatedTime);
	}

	public void rotateExample()
	{
		UnityEngine.Debug.Log("rotateExample");
		Hashtable hashtable = new Hashtable();
		hashtable.Add("yo", 5.0);
		LeanTween.rotate(ltLogo, new Vector3(0f, 360f, 0f), 1f).setEase(LeanTweenType.easeOutQuad).setOnComplete(rotateFinished)
			.setOnCompleteParam(hashtable)
			.setOnUpdate(rotateOnUpdate)
			.setUseEstimatedTime(useEstimatedTime);
	}

	public void rotateOnUpdate(float val)
	{
	}

	public void rotateFinished(object hash)
	{
		Hashtable hashtable = hash as Hashtable;
		UnityEngine.Debug.Log("rotateFinished hash:" + hashtable["yo"]);
	}

	public void scaleExample()
	{
		UnityEngine.Debug.Log("scaleExample");
		Vector3 localScale = ltLogo.transform.localScale;
		LeanTween.scale(ltLogo, new Vector3(localScale.x + 0.2f, localScale.y + 0.2f, localScale.z + 0.2f), 1f).setEase(LeanTweenType.easeOutBounce).setUseEstimatedTime(useEstimatedTime);
	}

	public void updateValueExample()
	{
		UnityEngine.Debug.Log("updateValueExample");
		Hashtable hashtable = new Hashtable();
		hashtable.Add("message", "hi");
		LeanTween.value(base.gameObject, (Action<float, object>)updateValueExampleCallback, ltLogo.transform.eulerAngles.y, 270f, 1f).setEase(LeanTweenType.easeOutElastic).setOnUpdateParam(hashtable)
			.setUseEstimatedTime(useEstimatedTime);
	}

	public void updateValueExampleCallback(float val, object hash)
	{
		Vector3 eulerAngles = ltLogo.transform.eulerAngles;
		eulerAngles.y = val;
		ltLogo.transform.eulerAngles = eulerAngles;
	}

	public void delayedCallExample()
	{
		UnityEngine.Debug.Log("delayedCallExample");
		LeanTween.delayedCall(0.5f, delayedCallExampleCallback).setUseEstimatedTime(useEstimatedTime);
	}

	public void delayedCallExampleCallback()
	{
		UnityEngine.Debug.Log("Delayed function was called");
		Vector3 localScale = ltLogo.transform.localScale;
		LeanTween.scale(ltLogo, new Vector3(localScale.x - 0.2f, localScale.y - 0.2f, localScale.z - 0.2f), 0.5f).setEase(LeanTweenType.easeInOutCirc).setUseEstimatedTime(useEstimatedTime);
	}

	public void alphaExample()
	{
		UnityEngine.Debug.Log("alphaExample");
		GameObject obj = GameObject.Find("LCharacter");
		LeanTween.alpha(obj, 0f, 0.5f).setUseEstimatedTime(useEstimatedTime);
		LeanTween.alpha(obj, 1f, 0.5f).setDelay(0.5f).setUseEstimatedTime(useEstimatedTime);
	}

	public void moveLocalExample()
	{
		UnityEngine.Debug.Log("moveLocalExample");
		GameObject obj = GameObject.Find("LCharacter");
		Vector3 localPosition = obj.transform.localPosition;
		LeanTween.moveLocal(obj, new Vector3(0f, 2f, 0f), 0.5f).setUseEstimatedTime(useEstimatedTime);
		LeanTween.moveLocal(obj, localPosition, 0.5f).setDelay(0.5f).setUseEstimatedTime(useEstimatedTime);
	}

	public void rotateAroundExample()
	{
		UnityEngine.Debug.Log("rotateAroundExample");
		LeanTween.rotateAround(GameObject.Find("LCharacter"), Vector3.up, 360f, 1f).setUseEstimatedTime(useEstimatedTime);
	}

	public void loopPause()
	{
		LeanTween.pause(GameObject.Find("Cube1"));
	}

	public void loopResume()
	{
		LeanTween.resume(GameObject.Find("Cube1"));
	}

	public void punchTest()
	{
		LeanTween.moveX(ltLogo, 7f, 1f).setEase(LeanTweenType.punch).setUseEstimatedTime(useEstimatedTime);
	}
}
public class BakeTexturesAtRuntime : MonoBehaviour
{
	public GameObject target;

	private float elapsedTime;

	private MB3_TextureBaker.CreateAtlasesCoroutineResult result = new MB3_TextureBaker.CreateAtlasesCoroutineResult();

	private void OnGUI()
	{
		GUILayout.Label("Time to bake textures: " + elapsedTime);
		if (GUILayout.Button("Combine textures & build combined mesh all at once"))
		{
			MB3_MeshBaker componentInChildren = target.GetComponentInChildren<MB3_MeshBaker>();
			MB3_TextureBaker component = target.GetComponent<MB3_TextureBaker>();
			component.textureBakeResults = ScriptableObject.CreateInstance<MB2_TextureBakeResults>();
			component.resultMaterial = new Material(Shader.Find("Diffuse"));
			float realtimeSinceStartup = Time.realtimeSinceStartup;
			component.CreateAtlases();
			elapsedTime = Time.realtimeSinceStartup - realtimeSinceStartup;
			componentInChildren.ClearMesh();
			componentInChildren.textureBakeResults = component.textureBakeResults;
			componentInChildren.AddDeleteGameObjects(component.GetObjectsToCombine().ToArray(), null, disableRendererInSource: true);
			componentInChildren.Apply();
		}
		if (GUILayout.Button("Combine textures & build combined mesh using coroutine"))
		{
			UnityEngine.Debug.Log("Starting to bake textures on frame " + Time.frameCount);
			MB3_TextureBaker component2 = target.GetComponent<MB3_TextureBaker>();
			component2.textureBakeResults = ScriptableObject.CreateInstance<MB2_TextureBakeResults>();
			component2.resultMaterial = new Material(Shader.Find("Diffuse"));
			component2.onBuiltAtlasesSuccess = OnBuiltAtlasesSuccess;
			StartCoroutine(component2.CreateAtlasesCoroutine(null, result));
		}
	}

	private void OnBuiltAtlasesSuccess()
	{
		UnityEngine.Debug.Log("Calling success callback. baking meshes");
		MB3_MeshBaker componentInChildren = target.GetComponentInChildren<MB3_MeshBaker>();
		MB3_TextureBaker component = target.GetComponent<MB3_TextureBaker>();
		if (result.isFinished && result.success)
		{
			componentInChildren.ClearMesh();
			componentInChildren.textureBakeResults = component.textureBakeResults;
			componentInChildren.AddDeleteGameObjects(component.GetObjectsToCombine().ToArray(), null, disableRendererInSource: true);
			componentInChildren.Apply();
		}
		UnityEngine.Debug.Log("Completed baking textures on frame " + Time.frameCount);
	}
}
public class MB_BatchPrepareObjectsForDynamicBatchingDescription : MonoBehaviour
{
	private void OnGUI()
	{
		GUILayout.Label("This scene is set up to create a combined material and meshes with adjusted UVs so \n objects can share a material and be batched by Unity's static/dynamic batching.\n This scene has added a BatchPrefabBaker component to a Mesh and Material Baker which \n  can bake many prefabs (each of which can have several renderers) in one click.\n The batching tool accepts prefab assets instead of scene objects. \n");
	}
}
public class MB_SwapShirts : MonoBehaviour
{
	public MB3_MeshBaker meshBaker;

	public Renderer[] clothingAndBodyPartsBareTorso;

	public Renderer[] clothingAndBodyPartsBareTorsoDamagedArm;

	public Renderer[] clothingAndBodyPartsHoodie;

	private void Start()
	{
		GameObject[] array = new GameObject[clothingAndBodyPartsBareTorso.Length];
		for (int i = 0; i < clothingAndBodyPartsBareTorso.Length; i++)
		{
			array[i] = clothingAndBodyPartsBareTorso[i].gameObject;
		}
		meshBaker.ClearMesh();
		meshBaker.AddDeleteGameObjects(array, null, disableRendererInSource: true);
		meshBaker.Apply();
	}

	private void OnGUI()
	{
		if (GUILayout.Button("Wear Hoodie"))
		{
			ChangeOutfit(clothingAndBodyPartsHoodie);
		}
		if (GUILayout.Button("Bare Torso"))
		{
			ChangeOutfit(clothingAndBodyPartsBareTorso);
		}
		if (GUILayout.Button("Damaged Arm"))
		{
			ChangeOutfit(clothingAndBodyPartsBareTorsoDamagedArm);
		}
	}

	private void ChangeOutfit(Renderer[] outfit)
	{
		List<GameObject> list = new List<GameObject>();
		foreach (GameObject item in meshBaker.meshCombiner.GetObjectsInCombined())
		{
			Renderer component = item.GetComponent<Renderer>();
			bool flag = false;
			for (int i = 0; i < outfit.Length; i++)
			{
				if (component == outfit[i])
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				list.Add(component.gameObject);
				UnityEngine.Debug.Log("Removing " + component.gameObject);
			}
		}
		List<GameObject> list2 = new List<GameObject>();
		for (int j = 0; j < outfit.Length; j++)
		{
			if (!meshBaker.meshCombiner.GetObjectsInCombined().Contains(outfit[j].gameObject))
			{
				list2.Add(outfit[j].gameObject);
				UnityEngine.Debug.Log("Adding " + outfit[j].gameObject);
			}
		}
		meshBaker.AddDeleteGameObjects(list2.ToArray(), list.ToArray(), disableRendererInSource: true);
		meshBaker.Apply();
	}
}
public class MB_PrepareObjectsForDynamicBatchingDescription : MonoBehaviour
{
	private void OnGUI()
	{
		GUILayout.Label("This scene creates a combined material and meshes with adjusted UVs so objects \n can share a material and be batched by Unity's static/dynamic batching.\n Output has been set to 'bakeMeshAssetsInPlace' on the Mesh Baker\n Position, Scale and Rotation will be baked into meshes so place them appropriately.\n Dynamic batching requires objects with uniform scale. You can fix non-uniform scale here\n After baking you need to duplicate your source prefab assets and replace the  \n meshes and materials with the generated ones.\n");
	}
}
public class MB_DynamicAddDeleteExample : MonoBehaviour
{
	public GameObject prefab;

	private List<GameObject> objsInCombined = new List<GameObject>();

	private MB3_MultiMeshBaker mbd;

	private GameObject[] objs;

	private float GaussianValue()
	{
		float num;
		float num3;
		do
		{
			num = 2f * UnityEngine.Random.Range(0f, 1f) - 1f;
			float num2 = 2f * UnityEngine.Random.Range(0f, 1f) - 1f;
			num3 = num * num + num2 * num2;
		}
		while (num3 >= 1f);
		num3 = Mathf.Sqrt(-2f * Mathf.Log(num3) / num3);
		return num * num3;
	}

	private void Start()
	{
		mbd = GetComponentInChildren<MB3_MultiMeshBaker>();
		int num = 10;
		GameObject[] array = new GameObject[num * num];
		for (int i = 0; i < num; i++)
		{
			for (int j = 0; j < num; j++)
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(prefab);
				array[i * num + j] = gameObject.GetComponentInChildren<MeshRenderer>().gameObject;
				float num2 = UnityEngine.Random.Range(-4f, 4f);
				float num3 = UnityEngine.Random.Range(-4f, 4f);
				gameObject.transform.position = new Vector3(3f * (float)i + num2, 0f, 3f * (float)j + num3);
				float y = UnityEngine.Random.Range(0, 360);
				gameObject.transform.rotation = Quaternion.Euler(0f, y, 0f);
				Vector3 localScale = Vector3.one + Vector3.one * GaussianValue() * 0.15f;
				gameObject.transform.localScale = localScale;
				if ((i * num + j) % 3 == 0)
				{
					objsInCombined.Add(array[i * num + j]);
				}
			}
		}
		mbd.AddDeleteGameObjects(array, null, disableRendererInSource: true);
		mbd.Apply();
		objs = objsInCombined.ToArray();
		StartCoroutine(largeNumber());
	}

	private IEnumerator largeNumber()
	{
		while (true)
		{
			yield return new WaitForSeconds(1.5f);
			mbd.AddDeleteGameObjects(null, objs, disableRendererInSource: true);
			mbd.Apply();
			yield return new WaitForSeconds(1.5f);
			mbd.AddDeleteGameObjects(objs, null, disableRendererInSource: true);
			mbd.Apply();
		}
	}

	private void OnGUI()
	{
		GUILayout.Label("Dynamically instantiates game objects. \nRepeatedly adds and removes some of them\n from the combined mesh.");
	}
}
public class MB_Example : MonoBehaviour
{
	public MB3_MeshBaker meshbaker;

	public GameObject[] objsToCombine;

	private void Start()
	{
		meshbaker.AddDeleteGameObjects(objsToCombine, null, disableRendererInSource: true);
		meshbaker.Apply();
	}

	private void LateUpdate()
	{
		meshbaker.UpdateGameObjects(objsToCombine);
		meshbaker.Apply(triangles: false, vertices: true, normals: true, tangents: true, uvs: false, uv2: false, uv3: false, uv4: false, colors: false);
	}

	private void OnGUI()
	{
		GUILayout.Label("Dynamically updates the vertices, normals and tangents in combined mesh every frame.\nThis is similar to dynamic batching. It is not recommended to do this every frame.\nAlso consider baking the mesh renderer objects into a skinned mesh renderer\nThe skinned mesh approach is faster for objects that need to move independently of each other every frame.");
	}
}
public class MB_ExampleMover : MonoBehaviour
{
	public int axis;

	private void Update()
	{
		Vector3 position = new Vector3(5f, 5f, 5f);
		position[axis] *= Mathf.Sin(Time.time);
		base.transform.position = position;
	}
}
public class MB_ExampleSkinnedMeshDescription : MonoBehaviour
{
	private void OnGUI()
	{
		GUILayout.Label("Mesh Renderer objects have been baked into a skinned mesh. Each source object\n is still in the scene (with renderer disabled) and becomes a bone. Any scripts, animations,\n or physics that affect the invisible source objects will be visible in the\nSkinned Mesh. This approach is more efficient than either dynamic batching or updating every frame \n for many small objects that constantly and independently move. \n With this approach pay attention to the SkinnedMeshRenderer Bounds and Animation Culling\nsettings. You may need to write your own script to manage/update these or your object may vanish or stop animating.\n You can update the combined mesh at runtime as objects are added and deleted from the scene.");
	}
}
public class MB_SkinnedMeshSceneController : MonoBehaviour
{
	public GameObject swordPrefab;

	public GameObject hatPrefab;

	public GameObject glassesPrefab;

	public GameObject workerPrefab;

	public GameObject targetCharacter;

	public MB3_MeshBaker skinnedMeshBaker;

	private GameObject swordInstance;

	private GameObject glassesInstance;

	private GameObject hatInstance;

	private void Start()
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(workerPrefab);
		gameObject.transform.position = new Vector3(1.31f, 0.985f, -0.25f);
		Animation component = gameObject.GetComponent<Animation>();
		component.wrapMode = WrapMode.Loop;
		component.cullingType = AnimationCullingType.AlwaysAnimate;
		component.Play("run");
		GameObject[] gos = new GameObject[1] { gameObject.GetComponentInChildren<SkinnedMeshRenderer>().gameObject };
		skinnedMeshBaker.AddDeleteGameObjects(gos, null, disableRendererInSource: true);
		skinnedMeshBaker.Apply();
	}

	private void OnGUI()
	{
		if (GUILayout.Button("Add/Remove Sword"))
		{
			if (swordInstance == null)
			{
				Transform parent = SearchHierarchyForBone(targetCharacter.transform, "RightHandAttachPoint");
				swordInstance = UnityEngine.Object.Instantiate(swordPrefab);
				swordInstance.transform.parent = parent;
				swordInstance.transform.localPosition = Vector3.zero;
				swordInstance.transform.localRotation = Quaternion.identity;
				swordInstance.transform.localScale = Vector3.one;
				GameObject[] gos = new GameObject[1] { swordInstance.GetComponentInChildren<MeshRenderer>().gameObject };
				skinnedMeshBaker.AddDeleteGameObjects(gos, null, disableRendererInSource: true);
				skinnedMeshBaker.Apply();
			}
			else if (skinnedMeshBaker.CombinedMeshContains(swordInstance.GetComponentInChildren<MeshRenderer>().gameObject))
			{
				GameObject[] deleteGOs = new GameObject[1] { swordInstance.GetComponentInChildren<MeshRenderer>().gameObject };
				skinnedMeshBaker.AddDeleteGameObjects(null, deleteGOs, disableRendererInSource: true);
				skinnedMeshBaker.Apply();
				UnityEngine.Object.Destroy(swordInstance);
				swordInstance = null;
			}
		}
		if (GUILayout.Button("Add/Remove Hat"))
		{
			if (hatInstance == null)
			{
				Transform parent2 = SearchHierarchyForBone(targetCharacter.transform, "HeadAttachPoint");
				hatInstance = UnityEngine.Object.Instantiate(hatPrefab);
				hatInstance.transform.parent = parent2;
				hatInstance.transform.localPosition = Vector3.zero;
				hatInstance.transform.localRotation = Quaternion.identity;
				hatInstance.transform.localScale = Vector3.one;
				GameObject[] gos2 = new GameObject[1] { hatInstance.GetComponentInChildren<MeshRenderer>().gameObject };
				skinnedMeshBaker.AddDeleteGameObjects(gos2, null, disableRendererInSource: true);
				skinnedMeshBaker.Apply();
			}
			else if (skinnedMeshBaker.CombinedMeshContains(hatInstance.GetComponentInChildren<MeshRenderer>().gameObject))
			{
				GameObject[] deleteGOs2 = new GameObject[1] { hatInstance.GetComponentInChildren<MeshRenderer>().gameObject };
				skinnedMeshBaker.AddDeleteGameObjects(null, deleteGOs2, disableRendererInSource: true);
				skinnedMeshBaker.Apply();
				UnityEngine.Object.Destroy(hatInstance);
				hatInstance = null;
			}
		}
		if (GUILayout.Button("Add/Remove Glasses"))
		{
			if (glassesInstance == null)
			{
				Transform parent3 = SearchHierarchyForBone(targetCharacter.transform, "NoseAttachPoint");
				glassesInstance = UnityEngine.Object.Instantiate(glassesPrefab);
				glassesInstance.transform.parent = parent3;
				glassesInstance.transform.localPosition = Vector3.zero;
				glassesInstance.transform.localRotation = Quaternion.identity;
				glassesInstance.transform.localScale = Vector3.one;
				GameObject[] gos3 = new GameObject[1] { glassesInstance.GetComponentInChildren<MeshRenderer>().gameObject };
				skinnedMeshBaker.AddDeleteGameObjects(gos3, null, disableRendererInSource: true);
				skinnedMeshBaker.Apply();
			}
			else if (skinnedMeshBaker.CombinedMeshContains(glassesInstance.GetComponentInChildren<MeshRenderer>().gameObject))
			{
				GameObject[] deleteGOs3 = new GameObject[1] { glassesInstance.GetComponentInChildren<MeshRenderer>().gameObject };
				skinnedMeshBaker.AddDeleteGameObjects(null, deleteGOs3, disableRendererInSource: true);
				skinnedMeshBaker.Apply();
				UnityEngine.Object.Destroy(glassesInstance);
				glassesInstance = null;
			}
		}
	}

	public Transform SearchHierarchyForBone(Transform current, string name)
	{
		if (current.name.Equals(name))
		{
			return current;
		}
		for (int i = 0; i < current.childCount; i++)
		{
			Transform transform = SearchHierarchyForBone(current.GetChild(i), name);
			if (transform != null)
			{
				return transform;
			}
		}
		return null;
	}
}
public class MB2_TestShowHide : MonoBehaviour
{
	public MB3_MeshBaker mb;

	public GameObject[] objs;

	private void Update()
	{
		if (Time.frameCount == 100)
		{
			mb.ShowHide(null, objs);
			mb.ApplyShowHide();
			UnityEngine.Debug.Log("should have disappeared");
		}
		if (Time.frameCount == 200)
		{
			mb.ShowHide(objs, null);
			mb.ApplyShowHide();
			UnityEngine.Debug.Log("should show");
		}
	}
}
public class MB2_TestUpdate : MonoBehaviour
{
	public MB3_MeshBaker meshbaker;

	public MB3_MultiMeshBaker multiMeshBaker;

	public GameObject[] objsToMove;

	public GameObject objWithChangingUVs;

	private Vector2[] uvs;

	private Mesh m;

	private void Start()
	{
		meshbaker.AddDeleteGameObjects(objsToMove, null, disableRendererInSource: true);
		meshbaker.AddDeleteGameObjects(new GameObject[1] { objWithChangingUVs }, null, disableRendererInSource: true);
		MeshFilter component = objWithChangingUVs.GetComponent<MeshFilter>();
		m = component.sharedMesh;
		uvs = m.uv;
		meshbaker.Apply();
		multiMeshBaker.AddDeleteGameObjects(objsToMove, null, disableRendererInSource: true);
		multiMeshBaker.AddDeleteGameObjects(new GameObject[1] { objWithChangingUVs }, null, disableRendererInSource: true);
		component = objWithChangingUVs.GetComponent<MeshFilter>();
		m = component.sharedMesh;
		uvs = m.uv;
		multiMeshBaker.Apply();
	}

	private void LateUpdate()
	{
		meshbaker.UpdateGameObjects(objsToMove, recalcBounds: false);
		Vector2[] uv = m.uv;
		for (int i = 0; i < uv.Length; i++)
		{
			uv[i] = Mathf.Sin(Time.time) * uvs[i];
		}
		m.uv = uv;
		meshbaker.UpdateGameObjects(new GameObject[1] { objWithChangingUVs }, recalcBounds: true, updateVertices: true, updateNormals: true, updateTangents: true, updateUV: true);
		meshbaker.Apply(triangles: false, vertices: true, normals: true, tangents: true, uvs: true, uv2: false, uv3: false, uv4: false, colors: false);
		multiMeshBaker.UpdateGameObjects(objsToMove, recalcBounds: false);
		uv = m.uv;
		for (int j = 0; j < uv.Length; j++)
		{
			uv[j] = Mathf.Sin(Time.time) * uvs[j];
		}
		m.uv = uv;
		multiMeshBaker.UpdateGameObjects(new GameObject[1] { objWithChangingUVs }, recalcBounds: true, updateVertices: true, updateNormals: true, updateTangents: true, updateUV: true);
		multiMeshBaker.Apply(triangles: false, vertices: true, normals: true, tangents: true, uvs: true, uv2: false, uv3: false, uv4: false, colors: false);
	}
}
public class MB3_TestAddingRemovingSkinnedMeshes : MonoBehaviour
{
	public MB3_MeshBaker meshBaker;

	public GameObject[] g;

	private void Start()
	{
		StartCoroutine(TestScript());
	}

	private IEnumerator TestScript()
	{
		UnityEngine.Debug.Log("Test 1 adding 0,1,2");
		GameObject[] gos = new GameObject[3]
		{
			g[0],
			g[1],
			g[2]
		};
		meshBaker.AddDeleteGameObjects(gos, null, disableRendererInSource: true);
		meshBaker.Apply();
		meshBaker.meshCombiner.CheckIntegrity();
		yield return new WaitForSeconds(3f);
		UnityEngine.Debug.Log("Test 2 remove 1 and add 3,4,5");
		GameObject[] deleteGOs = new GameObject[1] { g[1] };
		gos = new GameObject[3]
		{
			g[3],
			g[4],
			g[5]
		};
		meshBaker.AddDeleteGameObjects(gos, deleteGOs, disableRendererInSource: true);
		meshBaker.Apply();
		meshBaker.meshCombiner.CheckIntegrity();
		yield return new WaitForSeconds(3f);
		UnityEngine.Debug.Log("Test 3 remove 0,2,5 and add 1");
		deleteGOs = new GameObject[3]
		{
			g[3],
			g[4],
			g[5]
		};
		gos = new GameObject[1] { g[1] };
		meshBaker.AddDeleteGameObjects(gos, deleteGOs, disableRendererInSource: true);
		meshBaker.Apply();
		meshBaker.meshCombiner.CheckIntegrity();
		yield return new WaitForSeconds(3f);
		UnityEngine.Debug.Log("Test 3 remove all remaining");
		deleteGOs = new GameObject[3]
		{
			g[0],
			g[1],
			g[2]
		};
		meshBaker.AddDeleteGameObjects(null, deleteGOs, disableRendererInSource: true);
		meshBaker.Apply();
		meshBaker.meshCombiner.CheckIntegrity();
		yield return new WaitForSeconds(3f);
		UnityEngine.Debug.Log("Test 3 add all");
		meshBaker.AddDeleteGameObjects(g, null, disableRendererInSource: true);
		meshBaker.Apply();
		meshBaker.meshCombiner.CheckIntegrity();
		yield return new WaitForSeconds(1f);
		UnityEngine.Debug.Log("Done");
	}
}
public class MB3_TestBakeAllWithSameMaterial : MonoBehaviour
{
	public GameObject[] listOfObjsToCombineGood;

	public GameObject[] listOfObjsToCombineBad;

	private void Start()
	{
		testCombine();
	}

	private void testCombine()
	{
		MB3_MeshCombinerSingle mB3_MeshCombinerSingle = new MB3_MeshCombinerSingle();
		UnityEngine.Debug.Log("About to bake 1");
		mB3_MeshCombinerSingle.AddDeleteGameObjects(listOfObjsToCombineGood, null);
		mB3_MeshCombinerSingle.Apply();
		mB3_MeshCombinerSingle.UpdateGameObjects(listOfObjsToCombineGood);
		mB3_MeshCombinerSingle.Apply();
		mB3_MeshCombinerSingle.AddDeleteGameObjects(null, listOfObjsToCombineGood);
		mB3_MeshCombinerSingle.Apply();
		UnityEngine.Debug.Log("Did bake 1");
		UnityEngine.Debug.Log("About to bake 2 should get error that one material doesn't match");
		mB3_MeshCombinerSingle.AddDeleteGameObjects(listOfObjsToCombineBad, null);
		mB3_MeshCombinerSingle.Apply();
		UnityEngine.Debug.Log("Did bake 2");
		UnityEngine.Debug.Log("Doing same with multi mesh combiner");
		MB3_MultiMeshCombiner mB3_MultiMeshCombiner = new MB3_MultiMeshCombiner();
		UnityEngine.Debug.Log("About to bake 3");
		mB3_MultiMeshCombiner.AddDeleteGameObjects(listOfObjsToCombineGood, null);
		mB3_MultiMeshCombiner.Apply();
		mB3_MultiMeshCombiner.UpdateGameObjects(listOfObjsToCombineGood);
		mB3_MultiMeshCombiner.Apply();
		mB3_MultiMeshCombiner.AddDeleteGameObjects(null, listOfObjsToCombineGood);
		mB3_MultiMeshCombiner.Apply();
		UnityEngine.Debug.Log("Did bake 3");
		UnityEngine.Debug.Log("About to bake 4  should get error that one material doesn't match");
		mB3_MultiMeshCombiner.AddDeleteGameObjects(listOfObjsToCombineBad, null);
		mB3_MultiMeshCombiner.Apply();
		UnityEngine.Debug.Log("Did bake 4");
	}
}
public class MB3_TestRenderTextureTestHarness : MonoBehaviour
{
	public Texture2D input;

	public bool doColor;

	public Color32 color;

	public Texture2D Create3x3Tex()
	{
		Texture2D texture2D = new Texture2D(3, 3, TextureFormat.ARGB32, mipChain: false);
		Color32[] array = new Color32[texture2D.width * texture2D.height];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = color;
		}
		texture2D.SetPixels32(array);
		texture2D.Apply();
		return texture2D;
	}

	public Texture2D Create3x3Clone()
	{
		Texture2D texture2D = new Texture2D(3, 3, TextureFormat.ARGB32, mipChain: false);
		Color32[] pixels = new Color32[9]
		{
			new Color32(54, 54, 201, byte.MaxValue),
			new Color32(128, 37, 218, byte.MaxValue),
			new Color32(201, 54, 201, byte.MaxValue),
			new Color32(37, 128, 218, byte.MaxValue),
			new Color32(128, 128, byte.MaxValue, byte.MaxValue),
			new Color32(218, 128, 218, byte.MaxValue),
			new Color32(54, 201, 201, byte.MaxValue),
			new Color32(128, 218, 218, byte.MaxValue),
			new Color32(201, 201, 201, byte.MaxValue)
		};
		texture2D.SetPixels32(pixels);
		texture2D.Apply();
		return texture2D;
	}

	public static void TestRender(Texture2D input, Texture2D output)
	{
		int num = 1;
		ShaderTextureProperty[] array = new ShaderTextureProperty[1]
		{
			new ShaderTextureProperty("_BumpMap", norm: false)
		};
		int width = input.width;
		int height = input.height;
		int padding = 0;
		Rect[] rects = new Rect[1]
		{
			new Rect(0f, 0f, 1f, 1f)
		};
		List<MB_TexSet> list = new List<MB_TexSet>();
		MB_TexSet item = new MB_TexSet(new MeshBakerMaterialTexture[1]
		{
			new MeshBakerMaterialTexture(input)
		}, Vector2.zero, Vector2.one, MB_TextureTilingTreatment.considerUVs);
		list.Add(item);
		GameObject obj = new GameObject("MBrenderAtlasesGO");
		MB3_AtlasPackerRenderTexture mB3_AtlasPackerRenderTexture = obj.AddComponent<MB3_AtlasPackerRenderTexture>();
		obj.AddComponent<Camera>();
		for (int i = 0; i < num; i++)
		{
			Texture2D texture2D = null;
			UnityEngine.Debug.Log("About to render " + array[i].name + " isNormal=" + array[i].isNormalMap);
			mB3_AtlasPackerRenderTexture.LOG_LEVEL = MB2_LogLevel.trace;
			mB3_AtlasPackerRenderTexture.width = width;
			mB3_AtlasPackerRenderTexture.height = height;
			mB3_AtlasPackerRenderTexture.padding = padding;
			mB3_AtlasPackerRenderTexture.rects = rects;
			mB3_AtlasPackerRenderTexture.textureSets = list;
			mB3_AtlasPackerRenderTexture.indexOfTexSetToRender = i;
			mB3_AtlasPackerRenderTexture.isNormalMap = array[i].isNormalMap;
			texture2D = mB3_AtlasPackerRenderTexture.OnRenderAtlas(null);
			UnityEngine.Debug.Log("Created atlas " + array[i].name + " w=" + texture2D.width + " h=" + texture2D.height + " id=" + texture2D.GetInstanceID());
			UnityEngine.Debug.Log(string.Concat("Color ", texture2D.GetPixel(5, 5), " ", UnityEngine.Color.red));
			byte[] bytes = texture2D.EncodeToPNG();
			File.WriteAllBytes(Application.dataPath + "/_Experiment/red.png", bytes);
		}
	}
}
public class MB3_KMeansClustering
{
	private class DataPoint
	{
		public Vector3 center;

		public GameObject gameObject;

		public int Cluster;

		public DataPoint(GameObject go)
		{
			gameObject = go;
			center = go.transform.position;
			if (go.GetComponent<Renderer>() == null)
			{
				UnityEngine.Debug.LogError("Object does not have a renderer " + go);
			}
		}
	}

	private List<DataPoint> _normalizedDataToCluster = new List<DataPoint>();

	private Vector3[] _clusters = new Vector3[0];

	private int _numberOfClusters;

	public MB3_KMeansClustering(List<GameObject> gos, int numClusters)
	{
		for (int i = 0; i < gos.Count; i++)
		{
			if (gos[i] != null)
			{
				DataPoint item = new DataPoint(gos[i]);
				_normalizedDataToCluster.Add(item);
			}
			else
			{
				UnityEngine.Debug.LogWarning($"Object {i} in list of objects to cluster was null.");
			}
		}
		if (numClusters <= 0)
		{
			UnityEngine.Debug.LogError("Number of clusters must be posititve.");
			numClusters = 1;
		}
		if (_normalizedDataToCluster.Count <= numClusters)
		{
			UnityEngine.Debug.LogError("There must be fewer clusters than objects to cluster");
			numClusters = _normalizedDataToCluster.Count - 1;
		}
		_numberOfClusters = numClusters;
		if (_numberOfClusters <= 0)
		{
			_numberOfClusters = 1;
		}
		_clusters = new Vector3[_numberOfClusters];
	}

	private void InitializeCentroids()
	{
		for (int i = 0; i < _numberOfClusters; i++)
		{
			_normalizedDataToCluster[i].Cluster = i;
		}
		for (int j = _numberOfClusters; j < _normalizedDataToCluster.Count; j++)
		{
			_normalizedDataToCluster[j].Cluster = UnityEngine.Random.Range(0, _numberOfClusters);
		}
	}

	private bool UpdateDataPointMeans(bool force)
	{
		if (AnyAreEmpty(_normalizedDataToCluster) && !force)
		{
			return false;
		}
		Vector3[] array = new Vector3[_numberOfClusters];
		int[] array2 = new int[_numberOfClusters];
		for (int i = 0; i < _normalizedDataToCluster.Count; i++)
		{
			int cluster = _normalizedDataToCluster[i].Cluster;
			array[cluster] += _normalizedDataToCluster[i].center;
			array2[cluster]++;
		}
		for (int j = 0; j < _numberOfClusters; j++)
		{
			_clusters[j] = array[j] / array2[j];
		}
		return true;
	}

	private bool AnyAreEmpty(List<DataPoint> data)
	{
		int[] array = new int[_numberOfClusters];
		for (int i = 0; i < _normalizedDataToCluster.Count; i++)
		{
			array[_normalizedDataToCluster[i].Cluster]++;
		}
		for (int j = 0; j < array.Length; j++)
		{
			if (array[j] == 0)
			{
				return true;
			}
		}
		return false;
	}

	private bool UpdateClusterMembership()
	{
		bool flag = false;
		float[] array = new float[_numberOfClusters];
		for (int i = 0; i < _normalizedDataToCluster.Count; i++)
		{
			for (int j = 0; j < _numberOfClusters; j++)
			{
				array[j] = ElucidanDistance(_normalizedDataToCluster[i], _clusters[j]);
			}
			int num = MinIndex(array);
			if (num != _normalizedDataToCluster[i].Cluster)
			{
				flag = true;
				_normalizedDataToCluster[i].Cluster = num;
			}
		}
		if (!flag)
		{
			return false;
		}
		return true;
	}

	private float ElucidanDistance(DataPoint dataPoint, Vector3 mean)
	{
		return Vector3.Distance(dataPoint.center, mean);
	}

	private int MinIndex(float[] distances)
	{
		int result = 0;
		double num = distances[0];
		for (int i = 0; i < distances.Length; i++)
		{
			if ((double)distances[i] < num)
			{
				num = distances[i];
				result = i;
			}
		}
		return result;
	}

	public List<Renderer> GetCluster(int idx, out Vector3 mean, out float size)
	{
		if (idx < 0 || idx >= _numberOfClusters)
		{
			UnityEngine.Debug.LogError("idx is out of bounds");
			mean = Vector3.zero;
			size = 1f;
			return new List<Renderer>();
		}
		UpdateDataPointMeans(force: true);
		List<Renderer> list = new List<Renderer>();
		mean = _clusters[idx];
		float num = 0f;
		for (int i = 0; i < _normalizedDataToCluster.Count; i++)
		{
			if (_normalizedDataToCluster[i].Cluster == idx)
			{
				float num2 = Vector3.Distance(mean, _normalizedDataToCluster[i].center);
				if (num2 > num)
				{
					num = num2;
				}
				list.Add(_normalizedDataToCluster[i].gameObject.GetComponent<Renderer>());
			}
		}
		mean = _clusters[idx];
		size = num;
		return list;
	}

	public void Cluster()
	{
		bool flag = true;
		bool flag2 = true;
		InitializeCentroids();
		int num = _normalizedDataToCluster.Count * 1000;
		int num2 = 0;
		while (flag2 && flag && num2 < num)
		{
			num2++;
			flag2 = UpdateDataPointMeans(force: false);
			flag = UpdateClusterMembership();
		}
	}
}
public class MB_TextureCombinerRenderTexture
{
	public MB2_LogLevel LOG_LEVEL = MB2_LogLevel.info;

	private Material mat;

	private RenderTexture _destinationTexture;

	private Camera myCamera;

	private int _padding;

	private bool _isNormalMap;

	private bool _fixOutOfBoundsUVs;

	private bool _doRenderAtlas;

	private Rect[] rs;

	private List<MB_TexSet> textureSets;

	private int indexOfTexSetToRender;

	private ShaderTextureProperty _texPropertyName;

	private MB3_TextureCombinerNonTextureProperties _resultMaterialTextureBlender;

	private Texture2D targTex;

	public Texture2D DoRenderAtlas(GameObject gameObject, int width, int height, int padding, Rect[] rss, List<MB_TexSet> textureSetss, int indexOfTexSetToRenders, ShaderTextureProperty texPropertyname, MB3_TextureCombinerNonTextureProperties resultMaterialTextureBlender, bool isNormalMap, bool fixOutOfBoundsUVs, bool considerNonTextureProperties, MB3_TextureCombiner texCombiner, MB2_LogLevel LOG_LEV)
	{
		LOG_LEVEL = LOG_LEV;
		textureSets = textureSetss;
		indexOfTexSetToRender = indexOfTexSetToRenders;
		_texPropertyName = texPropertyname;
		_padding = padding;
		_isNormalMap = isNormalMap;
		_fixOutOfBoundsUVs = fixOutOfBoundsUVs;
		_resultMaterialTextureBlender = resultMaterialTextureBlender;
		rs = rss;
		Shader shader = ((!_isNormalMap) ? Shader.Find("MeshBaker/AlbedoShader") : Shader.Find("MeshBaker/NormalMapShader"));
		if (shader == null)
		{
			UnityEngine.Debug.LogError("Could not find shader for RenderTexture. Try reimporting mesh baker");
			return null;
		}
		mat = new Material(shader);
		_destinationTexture = new RenderTexture(width, height, 24, RenderTextureFormat.ARGB32);
		_destinationTexture.filterMode = FilterMode.Point;
		myCamera = gameObject.GetComponent<Camera>();
		myCamera.orthographic = true;
		myCamera.orthographicSize = height >> 1;
		myCamera.aspect = (float)width / (float)height;
		myCamera.targetTexture = _destinationTexture;
		myCamera.clearFlags = CameraClearFlags.Color;
		Transform component = myCamera.GetComponent<Transform>();
		component.localPosition = new Vector3((float)width / 2f, (float)height / 2f, 3f);
		component.localRotation = Quaternion.Euler(0f, 180f, 180f);
		_doRenderAtlas = true;
		if (LOG_LEVEL >= MB2_LogLevel.debug)
		{
			UnityEngine.Debug.Log(string.Format("Begin Camera.Render destTex w={0} h={1} camPos={2} camSize={3} camAspect={4}", width, height, component.localPosition, myCamera.orthographicSize, myCamera.aspect.ToString("f5")));
		}
		myCamera.Render();
		_doRenderAtlas = false;
		MB_Utility.Destroy(mat);
		MB_Utility.Destroy(_destinationTexture);
		if (LOG_LEVEL >= MB2_LogLevel.debug)
		{
			UnityEngine.Debug.Log("Finished Camera.Render ");
		}
		Texture2D result = targTex;
		targTex = null;
		return result;
	}

	public void OnRenderObject()
	{
		if (!_doRenderAtlas)
		{
			return;
		}
		Stopwatch stopwatch = new Stopwatch();
		stopwatch.Start();
		for (int i = 0; i < rs.Length; i++)
		{
			MeshBakerMaterialTexture meshBakerMaterialTexture = textureSets[i].ts[indexOfTexSetToRender];
			Texture2D texture2D = meshBakerMaterialTexture.GetTexture2D();
			if (LOG_LEVEL >= MB2_LogLevel.trace && texture2D != null)
			{
				UnityEngine.Debug.Log(string.Concat("Added ", texture2D, " to atlas w=", texture2D.width, " h=", texture2D.height, " offset=", meshBakerMaterialTexture.matTilingRect.min, " scale=", meshBakerMaterialTexture.matTilingRect.size, " rect=", rs[i], " padding=", _padding));
			}
			CopyScaledAndTiledToAtlas(textureSets[i], meshBakerMaterialTexture, textureSets[i].obUVoffset, textureSets[i].obUVscale, rs[i], _texPropertyName, _resultMaterialTextureBlender);
		}
		stopwatch.Stop();
		stopwatch.Start();
		if (LOG_LEVEL >= MB2_LogLevel.debug)
		{
			UnityEngine.Debug.Log("Total time for Graphics.DrawTexture calls " + stopwatch.ElapsedMilliseconds.ToString("f5"));
		}
		if (LOG_LEVEL >= MB2_LogLevel.debug)
		{
			UnityEngine.Debug.Log("Copying RenderTexture to Texture2D. destW" + _destinationTexture.width + " destH" + _destinationTexture.height);
		}
		Texture2D texture2D2 = new Texture2D(_destinationTexture.width, _destinationTexture.height, TextureFormat.ARGB32, mipChain: true);
		RenderTexture active = RenderTexture.active;
		RenderTexture.active = _destinationTexture;
		int num = Mathf.CeilToInt((float)_destinationTexture.width / 512f);
		int num2 = Mathf.CeilToInt((float)_destinationTexture.height / 512f);
		if (num == 0 || num2 == 0)
		{
			if (LOG_LEVEL >= MB2_LogLevel.trace)
			{
				UnityEngine.Debug.Log("Copying all in one shot");
			}
			texture2D2.ReadPixels(new Rect(0f, 0f, _destinationTexture.width, _destinationTexture.height), 0, 0, recalculateMipMaps: true);
		}
		else
		{
			if (LOG_LEVEL >= MB2_LogLevel.trace)
			{
				UnityEngine.Debug.Log("Not OpenGL copying blocks");
			}
			for (int j = 0; j < num; j++)
			{
				for (int k = 0; k < num2; k++)
				{
					int num3 = j * 512;
					int num4 = _destinationTexture.height - 512 - k * 512;
					texture2D2.ReadPixels(new Rect(num3, num4, 512f, 512f), j * 512, k * 512, recalculateMipMaps: true);
				}
			}
		}
		RenderTexture.active = active;
		texture2D2.Apply();
		if (LOG_LEVEL >= MB2_LogLevel.trace)
		{
			UnityEngine.Debug.Log("TempTexture ");
			if (texture2D2.height <= 16 && texture2D2.width <= 16)
			{
				_printTexture(texture2D2);
			}
		}
		myCamera.targetTexture = null;
		RenderTexture.active = null;
		targTex = texture2D2;
		if (LOG_LEVEL >= MB2_LogLevel.debug)
		{
			UnityEngine.Debug.Log("Total time to copy RenderTexture to Texture2D " + stopwatch.ElapsedMilliseconds.ToString("f5"));
		}
	}

	private Color32 ConvertNormalFormatFromUnity_ToStandard(Color32 c)
	{
		Vector3 zero = Vector3.zero;
		zero.x = (float)(int)c.a * 2f - 1f;
		zero.y = (float)(int)c.g * 2f - 1f;
		zero.z = Mathf.Sqrt(1f - zero.x * zero.x - zero.y * zero.y);
		Color32 result = default(Color32);
		result.a = 1;
		result.r = (byte)((zero.x + 1f) * 0.5f);
		result.g = (byte)((zero.y + 1f) * 0.5f);
		result.b = (byte)((zero.z + 1f) * 0.5f);
		return result;
	}

	private bool IsOpenGL()
	{
		return SystemInfo.graphicsDeviceVersion.StartsWith("OpenGL");
	}

	private void CopyScaledAndTiledToAtlas(MB_TexSet texSet, MeshBakerMaterialTexture source, Vector2 obUVoffset, Vector2 obUVscale, Rect rec, ShaderTextureProperty texturePropertyName, MB3_TextureCombinerNonTextureProperties resultMatTexBlender)
	{
		Rect rect = rec;
		myCamera.backgroundColor = resultMatTexBlender.GetColorForTemporaryTexture(texSet.matsAndGOs.mats[0].mat, texturePropertyName);
		rect.y = 1f - (rect.y + rect.height);
		rect.x *= _destinationTexture.width;
		rect.y *= _destinationTexture.height;
		rect.width *= _destinationTexture.width;
		rect.height *= _destinationTexture.height;
		Rect rect2 = rect;
		rect2.x -= _padding;
		rect2.y -= _padding;
		rect2.width += _padding * 2;
		rect2.height += _padding * 2;
		Rect screenRect = default(Rect);
		Rect rect3 = texSet.ts[indexOfTexSetToRender].GetEncapsulatingSamplingRect().GetRect();
		_ = _fixOutOfBoundsUVs;
		Texture2D texture2D = source.GetTexture2D();
		TextureWrapMode wrapMode = texture2D.wrapMode;
		if (rect3.width == 1f && rect3.height == 1f && rect3.x == 0f && rect3.y == 0f)
		{
			texture2D.wrapMode = TextureWrapMode.Clamp;
		}
		else
		{
			texture2D.wrapMode = TextureWrapMode.Repeat;
		}
		if (LOG_LEVEL >= MB2_LogLevel.trace)
		{
			UnityEngine.Debug.Log(string.Concat("DrawTexture tex=", texture2D.name, " destRect=", rect, " srcRect=", rect3, " Mat=", mat));
		}
		Rect sourceRect = default(Rect);
		sourceRect.x = rect3.x;
		sourceRect.y = rect3.y + 1f - 1f / (float)texture2D.height;
		sourceRect.width = rect3.width;
		sourceRect.height = 1f / (float)texture2D.height;
		screenRect.x = rect.x;
		screenRect.y = rect2.y;
		screenRect.width = rect.width;
		screenRect.height = _padding;
		RenderTexture active = RenderTexture.active;
		RenderTexture.active = _destinationTexture;
		Graphics.DrawTexture(screenRect, texture2D, sourceRect, 0, 0, 0, 0, mat);
		sourceRect.x = rect3.x;
		sourceRect.y = rect3.y;
		sourceRect.width = rect3.width;
		sourceRect.height = 1f / (float)texture2D.height;
		screenRect.x = rect.x;
		screenRect.y = rect.y + rect.height;
		screenRect.width = rect.width;
		screenRect.height = _padding;
		Graphics.DrawTexture(screenRect, texture2D, sourceRect, 0, 0, 0, 0, mat);
		sourceRect.x = rect3.x;
		sourceRect.y = rect3.y;
		sourceRect.width = 1f / (float)texture2D.width;
		sourceRect.height = rect3.height;
		screenRect.x = rect2.x;
		screenRect.y = rect.y;
		screenRect.width = _padding;
		screenRect.height = rect.height;
		Graphics.DrawTexture(screenRect, texture2D, sourceRect, 0, 0, 0, 0, mat);
		sourceRect.x = rect3.x + 1f - 1f / (float)texture2D.width;
		sourceRect.y = rect3.y;
		sourceRect.width = 1f / (float)texture2D.width;
		sourceRect.height = rect3.height;
		screenRect.x = rect.x + rect.width;
		screenRect.y = rect.y;
		screenRect.width = _padding;
		screenRect.height = rect.height;
		Graphics.DrawTexture(screenRect, texture2D, sourceRect, 0, 0, 0, 0, mat);
		sourceRect.x = rect3.x;
		sourceRect.y = rect3.y + 1f - 1f / (float)texture2D.height;
		sourceRect.width = 1f / (float)texture2D.width;
		sourceRect.height = 1f / (float)texture2D.height;
		screenRect.x = rect2.x;
		screenRect.y = rect2.y;
		screenRect.width = _padding;
		screenRect.height = _padding;
		Graphics.DrawTexture(screenRect, texture2D, sourceRect, 0, 0, 0, 0, mat);
		sourceRect.x = rect3.x + 1f - 1f / (float)texture2D.width;
		sourceRect.y = rect3.y + 1f - 1f / (float)texture2D.height;
		sourceRect.width = 1f / (float)texture2D.width;
		sourceRect.height = 1f / (float)texture2D.height;
		screenRect.x = rect.x + rect.width;
		screenRect.y = rect2.y;
		screenRect.width = _padding;
		screenRect.height = _padding;
		Graphics.DrawTexture(screenRect, texture2D, sourceRect, 0, 0, 0, 0, mat);
		sourceRect.x = rect3.x;
		sourceRect.y = rect3.y;
		sourceRect.width = 1f / (float)texture2D.width;
		sourceRect.height = 1f / (float)texture2D.height;
		screenRect.x = rect2.x;
		screenRect.y = rect.y + rect.height;
		screenRect.width = _padding;
		screenRect.height = _padding;
		Graphics.DrawTexture(screenRect, texture2D, sourceRect, 0, 0, 0, 0, mat);
		sourceRect.x = rect3.x + 1f - 1f / (float)texture2D.width;
		sourceRect.y = rect3.y;
		sourceRect.width = 1f / (float)texture2D.width;
		sourceRect.height = 1f / (float)texture2D.height;
		screenRect.x = rect.x + rect.width;
		screenRect.y = rect.y + rect.height;
		screenRect.width = _padding;
		screenRect.height = _padding;
		Graphics.DrawTexture(screenRect, texture2D, sourceRect, 0, 0, 0, 0, mat);
		Graphics.DrawTexture(rect, texture2D, rect3, 0, 0, 0, 0, mat);
		RenderTexture.active = active;
		texture2D.wrapMode = wrapMode;
	}

	private void _printTexture(Texture2D t)
	{
		if (t.width * t.height > 100)
		{
			UnityEngine.Debug.Log("Not printing texture too large.");
			return;
		}
		try
		{
			Color32[] pixels = t.GetPixels32();
			string text = "";
			for (int i = 0; i < t.height; i++)
			{
				for (int j = 0; j < t.width; j++)
				{
					text = string.Concat(text, pixels[i * t.width + j], ", ");
				}
				text += "\n";
			}
			UnityEngine.Debug.Log(text);
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.Log("Could not print texture. texture may not be readable." + ex.ToString());
		}
	}
}
[ExecuteInEditMode]
public class MB3_AtlasPackerRenderTexture : MonoBehaviour
{
	private MB_TextureCombinerRenderTexture fastRenderer;

	private bool _doRenderAtlas;

	public int width;

	public int height;

	public int padding;

	public bool isNormalMap;

	public bool fixOutOfBoundsUVs;

	public bool considerNonTextureProperties;

	public MB3_TextureCombinerNonTextureProperties resultMaterialTextureBlender;

	public Rect[] rects;

	public Texture2D tex1;

	public List<MB_TexSet> textureSets;

	public int indexOfTexSetToRender;

	public ShaderTextureProperty texPropertyName;

	public MB2_LogLevel LOG_LEVEL = MB2_LogLevel.info;

	public Texture2D testTex;

	public Material testMat;

	public Texture2D OnRenderAtlas(MB3_TextureCombiner combiner)
	{
		fastRenderer = new MB_TextureCombinerRenderTexture();
		_doRenderAtlas = true;
		Texture2D result = fastRenderer.DoRenderAtlas(base.gameObject, width, height, padding, rects, textureSets, indexOfTexSetToRender, texPropertyName, resultMaterialTextureBlender, isNormalMap, fixOutOfBoundsUVs, considerNonTextureProperties, combiner, LOG_LEVEL);
		_doRenderAtlas = false;
		return result;
	}

	private void OnRenderObject()
	{
		if (_doRenderAtlas)
		{
			fastRenderer.OnRenderObject();
			_doRenderAtlas = false;
		}
	}
}
[Serializable]
public class MB_AtlasesAndRects
{
	public Texture2D[] atlases;

	[NonSerialized]
	public List<MB_MaterialAndUVRect> mat2rect_map;

	public string[] texPropertyNames;
}
[Serializable]
public class MB_MultiMaterial
{
	public Material combinedMaterial;

	public bool considerMeshUVs;

	public List<Material> sourceMaterials = new List<Material>();
}
[Serializable]
public class MB_MaterialAndUVRect
{
	public Material material;

	public Rect atlasRect;

	public string srcObjName;

	public bool allPropsUseSameTiling = true;

	[FormerlySerializedAs("sourceMaterialTiling")]
	public Rect allPropsUseSameTiling_sourceMaterialTiling;

	[FormerlySerializedAs("samplingEncapsulatinRect")]
	public Rect allPropsUseSameTiling_samplingEncapsulatinRect;

	public Rect propsUseDifferntTiling_srcUVsamplingRect;

	public MB_TextureTilingTreatment tilingTreatment = MB_TextureTilingTreatment.unknown;

	public MB_MaterialAndUVRect(Material mat, Rect destRect, bool allPropsUseSameTiling, Rect sourceMaterialTiling, Rect samplingEncapsulatingRect, Rect srcUVsamplingRect, MB_TextureTilingTreatment treatment, string objName)
	{
		material = mat;
		atlasRect = destRect;
		tilingTreatment = treatment;
		this.allPropsUseSameTiling = allPropsUseSameTiling;
		allPropsUseSameTiling_sourceMaterialTiling = sourceMaterialTiling;
		allPropsUseSameTiling_samplingEncapsulatinRect = samplingEncapsulatingRect;
		propsUseDifferntTiling_srcUVsamplingRect = srcUVsamplingRect;
		srcObjName = objName;
	}

	public override int GetHashCode()
	{
		return material.GetInstanceID() ^ allPropsUseSameTiling_samplingEncapsulatinRect.GetHashCode() ^ propsUseDifferntTiling_srcUVsamplingRect.GetHashCode();
	}

	public override bool Equals(object obj)
	{
		if (!(obj is MB_MaterialAndUVRect))
		{
			return false;
		}
		MB_MaterialAndUVRect mB_MaterialAndUVRect = (MB_MaterialAndUVRect)obj;
		if (material == mB_MaterialAndUVRect.material && allPropsUseSameTiling_samplingEncapsulatinRect == mB_MaterialAndUVRect.allPropsUseSameTiling_samplingEncapsulatinRect && allPropsUseSameTiling_sourceMaterialTiling == mB_MaterialAndUVRect.allPropsUseSameTiling_sourceMaterialTiling && allPropsUseSameTiling == mB_MaterialAndUVRect.allPropsUseSameTiling)
		{
			return propsUseDifferntTiling_srcUVsamplingRect == mB_MaterialAndUVRect.propsUseDifferntTiling_srcUVsamplingRect;
		}
		return false;
	}

	public Rect GetEncapsulatingRect()
	{
		if (allPropsUseSameTiling)
		{
			return allPropsUseSameTiling_samplingEncapsulatinRect;
		}
		return propsUseDifferntTiling_srcUVsamplingRect;
	}

	public Rect GetMaterialTilingRect()
	{
		if (allPropsUseSameTiling)
		{
			return allPropsUseSameTiling_sourceMaterialTiling;
		}
		return new Rect(0f, 0f, 1f, 1f);
	}
}
public class MB2_TextureBakeResults : ScriptableObject
{
	public class Material2AtlasRectangleMapper
	{
		private MB2_TextureBakeResults tbr;

		private int[] numTimesMatAppearsInAtlas;

		private MB_MaterialAndUVRect[] matsAndSrcUVRect;

		public Material2AtlasRectangleMapper(MB2_TextureBakeResults res)
		{
			tbr = res;
			matsAndSrcUVRect = res.materialsAndUVRects;
			numTimesMatAppearsInAtlas = new int[matsAndSrcUVRect.Length];
			for (int i = 0; i < matsAndSrcUVRect.Length; i++)
			{
				if (numTimesMatAppearsInAtlas[i] > 1)
				{
					continue;
				}
				int num = 1;
				for (int j = i + 1; j < matsAndSrcUVRect.Length; j++)
				{
					if (matsAndSrcUVRect[i].material == matsAndSrcUVRect[j].material)
					{
						num++;
					}
				}
				numTimesMatAppearsInAtlas[i] = num;
				if (num <= 1)
				{
					continue;
				}
				for (int k = i + 1; k < matsAndSrcUVRect.Length; k++)
				{
					if (matsAndSrcUVRect[i].material == matsAndSrcUVRect[k].material)
					{
						numTimesMatAppearsInAtlas[k] = num;
					}
				}
			}
		}

		public bool TryMapMaterialToUVRect(Material mat, Mesh m, int submeshIdx, int idxInResultMats, MB3_MeshCombinerSingle.MeshChannelsCache meshChannelCache, Dictionary<int, MB_Utility.MeshAnalysisResult[]> meshAnalysisCache, out MB_TextureTilingTreatment tilingTreatment, out Rect rectInAtlas, out Rect encapsulatingRectOut, out Rect sourceMaterialTilingOut, ref string errorMsg, MB2_LogLevel logLevel)
		{
			if (tbr.version < VERSION)
			{
				UpgradeToCurrentVersion(tbr);
			}
			tilingTreatment = MB_TextureTilingTreatment.unknown;
			if (tbr.materialsAndUVRects.Length == 0)
			{
				errorMsg = "The 'Texture Bake Result' needs to be re-baked to be compatible with this version of Mesh Baker. Please re-bake using the MB3_TextureBaker.";
				rectInAtlas = default(Rect);
				encapsulatingRectOut = default(Rect);
				sourceMaterialTilingOut = default(Rect);
				return false;
			}
			if (mat == null)
			{
				rectInAtlas = default(Rect);
				encapsulatingRectOut = default(Rect);
				sourceMaterialTilingOut = default(Rect);
				errorMsg = $"Mesh {m.name} Had no material on submesh {submeshIdx} cannot map to a material in the atlas";
				return false;
			}
			if (submeshIdx >= m.subMeshCount)
			{
				errorMsg = "Submesh index is greater than the number of submeshes";
				rectInAtlas = default(Rect);
				encapsulatingRectOut = default(Rect);
				sourceMaterialTilingOut = default(Rect);
				return false;
			}
			int num = -1;
			for (int i = 0; i < matsAndSrcUVRect.Length; i++)
			{
				if (mat == matsAndSrcUVRect[i].material)
				{
					num = i;
					break;
				}
			}
			if (num == -1)
			{
				rectInAtlas = default(Rect);
				encapsulatingRectOut = default(Rect);
				sourceMaterialTilingOut = default(Rect);
				errorMsg = $"Material {mat.name} could not be found in the Texture Bake Result";
				return false;
			}
			if (!tbr.resultMaterials[idxInResultMats].considerMeshUVs)
			{
				if (numTimesMatAppearsInAtlas[num] != 1)
				{
					UnityEngine.Debug.LogError("There is a problem with this TextureBakeResults. FixOutOfBoundsUVs is false and a material appears more than once.");
				}
				MB_MaterialAndUVRect mB_MaterialAndUVRect = matsAndSrcUVRect[num];
				rectInAtlas = mB_MaterialAndUVRect.atlasRect;
				tilingTreatment = mB_MaterialAndUVRect.tilingTreatment;
				encapsulatingRectOut = mB_MaterialAndUVRect.GetEncapsulatingRect();
				sourceMaterialTilingOut = mB_MaterialAndUVRect.GetMaterialTilingRect();
				return true;
			}
			if (!meshAnalysisCache.TryGetValue(m.GetInstanceID(), out var value))
			{
				value = new MB_Utility.MeshAnalysisResult[m.subMeshCount];
				for (int j = 0; j < m.subMeshCount; j++)
				{
					MB_Utility.hasOutOfBoundsUVs(meshChannelCache.GetUv0Raw(m), m, ref value[j], j);
				}
				meshAnalysisCache.Add(m.GetInstanceID(), value);
			}
			bool flag = false;
			Rect rect = new Rect(0f, 0f, 0f, 0f);
			Rect rect2 = new Rect(0f, 0f, 0f, 0f);
			if (logLevel >= MB2_LogLevel.trace)
			{
				UnityEngine.Debug.Log(string.Format("Trying to find a rectangle in atlas capable of holding tiled sampling rect for mesh {0} using material {1} meshUVrect={2}", m, mat, value[submeshIdx].uvRect.ToString("f5")));
			}
			for (int k = num; k < matsAndSrcUVRect.Length; k++)
			{
				MB_MaterialAndUVRect mB_MaterialAndUVRect2 = matsAndSrcUVRect[k];
				if (!(mB_MaterialAndUVRect2.material == mat))
				{
					continue;
				}
				if (mB_MaterialAndUVRect2.allPropsUseSameTiling)
				{
					rect = mB_MaterialAndUVRect2.allPropsUseSameTiling_samplingEncapsulatinRect;
					rect2 = mB_MaterialAndUVRect2.allPropsUseSameTiling_sourceMaterialTiling;
				}
				else
				{
					rect = mB_MaterialAndUVRect2.propsUseDifferntTiling_srcUVsamplingRect;
					rect2 = new Rect(0f, 0f, 1f, 1f);
				}
				if (IsMeshAndMaterialRectEnclosedByAtlasRect(mB_MaterialAndUVRect2.tilingTreatment, value[submeshIdx].uvRect, rect2, rect, logLevel))
				{
					if (logLevel >= MB2_LogLevel.trace)
					{
						UnityEngine.Debug.Log(string.Concat("Found rect in atlas capable of containing tiled sampling rect for mesh ", m, " at idx=", k));
					}
					num = k;
					flag = true;
					break;
				}
			}
			if (flag)
			{
				MB_MaterialAndUVRect mB_MaterialAndUVRect3 = matsAndSrcUVRect[num];
				rectInAtlas = mB_MaterialAndUVRect3.atlasRect;
				tilingTreatment = mB_MaterialAndUVRect3.tilingTreatment;
				encapsulatingRectOut = mB_MaterialAndUVRect3.GetEncapsulatingRect();
				sourceMaterialTilingOut = mB_MaterialAndUVRect3.GetMaterialTilingRect();
				return true;
			}
			rectInAtlas = default(Rect);
			encapsulatingRectOut = default(Rect);
			sourceMaterialTilingOut = default(Rect);
			errorMsg = $"Could not find a tiled rectangle in the atlas capable of containing the uv and material tiling on mesh {m.name} for material {mat}. Was this mesh included when atlases were baked?";
			return false;
		}

		private void UpgradeToCurrentVersion(MB2_TextureBakeResults tbr)
		{
			if (tbr.version < 3252)
			{
				for (int i = 0; i < tbr.materialsAndUVRects.Length; i++)
				{
					tbr.materialsAndUVRects[i].allPropsUseSameTiling = true;
				}
			}
		}
	}

	public int version;

	public MB_MaterialAndUVRect[] materialsAndUVRects;

	public MB_MultiMaterial[] resultMaterials;

	public bool doMultiMaterial;

	public static int VERSION => 3252;

	public MB2_TextureBakeResults()
	{
		version = VERSION;
	}

	private void OnEnable()
	{
		if (version < 3251)
		{
			for (int i = 0; i < materialsAndUVRects.Length; i++)
			{
				materialsAndUVRects[i].allPropsUseSameTiling = true;
			}
		}
		version = VERSION;
	}

	public static MB2_TextureBakeResults CreateForMaterialsOnRenderer(GameObject[] gos, List<Material> matsOnTargetRenderer)
	{
		HashSet<Material> hashSet = new HashSet<Material>(matsOnTargetRenderer);
		for (int i = 0; i < gos.Length; i++)
		{
			if (gos[i] == null)
			{
				UnityEngine.Debug.LogError($"Game object {i} in list of objects to add was null");
				return null;
			}
			Material[] gOMaterials = MB_Utility.GetGOMaterials(gos[i]);
			if (gOMaterials.Length == 0)
			{
				UnityEngine.Debug.LogError($"Game object {i} in list of objects to add no renderer");
				return null;
			}
			for (int j = 0; j < gOMaterials.Length; j++)
			{
				if (!hashSet.Contains(gOMaterials[j]))
				{
					hashSet.Add(gOMaterials[j]);
				}
			}
		}
		Material[] array = new Material[hashSet.Count];
		hashSet.CopyTo(array);
		MB2_TextureBakeResults mB2_TextureBakeResults = (MB2_TextureBakeResults)ScriptableObject.CreateInstance(typeof(MB2_TextureBakeResults));
		List<MB_MaterialAndUVRect> list = new List<MB_MaterialAndUVRect>();
		for (int k = 0; k < array.Length; k++)
		{
			if (array[k] != null)
			{
				MB_MaterialAndUVRect item = new MB_MaterialAndUVRect(array[k], new Rect(0f, 0f, 1f, 1f), allPropsUseSameTiling: true, new Rect(0f, 0f, 1f, 1f), new Rect(0f, 0f, 1f, 1f), new Rect(0f, 0f, 0f, 0f), MB_TextureTilingTreatment.none, "");
				if (!list.Contains(item))
				{
					list.Add(item);
				}
			}
		}
		mB2_TextureBakeResults.resultMaterials = new MB_MultiMaterial[list.Count];
		for (int l = 0; l < list.Count; l++)
		{
			mB2_TextureBakeResults.resultMaterials[l] = new MB_MultiMaterial();
			List<Material> list2 = new List<Material>();
			list2.Add(list[l].material);
			mB2_TextureBakeResults.resultMaterials[l].sourceMaterials = list2;
			mB2_TextureBakeResults.resultMaterials[l].combinedMaterial = list[l].material;
			mB2_TextureBakeResults.resultMaterials[l].considerMeshUVs = false;
		}
		if (array.Length == 1)
		{
			mB2_TextureBakeResults.doMultiMaterial = false;
		}
		else
		{
			mB2_TextureBakeResults.doMultiMaterial = true;
		}
		mB2_TextureBakeResults.materialsAndUVRects = list.ToArray();
		return mB2_TextureBakeResults;
	}

	public bool DoAnyResultMatsUseConsiderMeshUVs()
	{
		if (resultMaterials == null)
		{
			return false;
		}
		for (int i = 0; i < resultMaterials.Length; i++)
		{
			if (resultMaterials[i].considerMeshUVs)
			{
				return true;
			}
		}
		return false;
	}

	public bool ContainsMaterial(Material m)
	{
		for (int i = 0; i < materialsAndUVRects.Length; i++)
		{
			if (materialsAndUVRects[i].material == m)
			{
				return true;
			}
		}
		return false;
	}

	public string GetDescription()
	{
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.Append("Shaders:\n");
		HashSet<Shader> hashSet = new HashSet<Shader>();
		if (materialsAndUVRects != null)
		{
			for (int i = 0; i < materialsAndUVRects.Length; i++)
			{
				if (materialsAndUVRects[i].material != null)
				{
					hashSet.Add(materialsAndUVRects[i].material.shader);
				}
			}
		}
		foreach (Shader item in hashSet)
		{
			stringBuilder.Append("  ").Append(item.name).AppendLine();
		}
		stringBuilder.Append("Materials:\n");
		if (materialsAndUVRects != null)
		{
			for (int j = 0; j < materialsAndUVRects.Length; j++)
			{
				if (materialsAndUVRects[j].material != null)
				{
					stringBuilder.Append("  ").Append(materialsAndUVRects[j].material.name).AppendLine();
				}
			}
		}
		return stringBuilder.ToString();
	}

	public static bool IsMeshAndMaterialRectEnclosedByAtlasRect(MB_TextureTilingTreatment tilingTreatment, Rect uvR, Rect sourceMaterialTiling, Rect samplingEncapsulatinRect, MB2_LogLevel logLevel)
	{
		Rect rect = default(Rect);
		rect = MB3_UVTransformUtility.CombineTransforms(ref uvR, ref sourceMaterialTiling);
		if (logLevel >= MB2_LogLevel.trace && logLevel >= MB2_LogLevel.trace)
		{
			UnityEngine.Debug.Log("IsMeshAndMaterialRectEnclosedByAtlasRect Rect in atlas uvR=" + uvR.ToString("f5") + " sourceMaterialTiling=" + sourceMaterialTiling.ToString("f5") + "Potential Rect (must fit in encapsulating) " + rect.ToString("f5") + " encapsulating=" + samplingEncapsulatinRect.ToString("f5") + " tilingTreatment=" + tilingTreatment);
		}
		switch (tilingTreatment)
		{
		case MB_TextureTilingTreatment.edgeToEdgeX:
			if (MB3_UVTransformUtility.LineSegmentContainsShifted(samplingEncapsulatinRect.y, samplingEncapsulatinRect.height, rect.y, rect.height))
			{
				return true;
			}
			break;
		case MB_TextureTilingTreatment.edgeToEdgeY:
			if (MB3_UVTransformUtility.LineSegmentContainsShifted(samplingEncapsulatinRect.x, samplingEncapsulatinRect.width, rect.x, rect.width))
			{
				return true;
			}
			break;
		case MB_TextureTilingTreatment.edgeToEdgeXY:
			return true;
		default:
			if (MB3_UVTransformUtility.RectContainsShifted(ref samplingEncapsulatinRect, ref rect))
			{
				return true;
			}
			break;
		}
		return false;
	}
}
public class MB2_UpdateSkinnedMeshBoundsFromBones : MonoBehaviour
{
	private SkinnedMeshRenderer smr;

	private Transform[] bones;

	private void Start()
	{
		smr = GetComponent<SkinnedMeshRenderer>();
		if (smr == null)
		{
			UnityEngine.Debug.LogError("Need to attach MB2_UpdateSkinnedMeshBoundsFromBones script to an object with a SkinnedMeshRenderer component attached.");
			return;
		}
		bones = smr.bones;
		bool updateWhenOffscreen = smr.updateWhenOffscreen;
		smr.updateWhenOffscreen = true;
		smr.updateWhenOffscreen = updateWhenOffscreen;
	}

	private void Update()
	{
		if (smr != null)
		{
			MB3_MeshCombiner.UpdateSkinnedMeshApproximateBoundsFromBonesStatic(bones, smr);
		}
	}
}
public class MB2_UpdateSkinnedMeshBoundsFromBounds : MonoBehaviour
{
	public List<GameObject> objects;

	private SkinnedMeshRenderer smr;

	private void Start()
	{
		smr = GetComponent<SkinnedMeshRenderer>();
		if (smr == null)
		{
			UnityEngine.Debug.LogError("Need to attach MB2_UpdateSkinnedMeshBoundsFromBounds script to an object with a SkinnedMeshRenderer component attached.");
			return;
		}
		if (objects == null || objects.Count == 0)
		{
			UnityEngine.Debug.LogWarning("The MB2_UpdateSkinnedMeshBoundsFromBounds had no Game Objects. It should have the same list of game objects that the MeshBaker does.");
			smr = null;
			return;
		}
		for (int i = 0; i < objects.Count; i++)
		{
			if (objects[i] == null || objects[i].GetComponent<Renderer>() == null)
			{
				UnityEngine.Debug.LogError("The list of objects had nulls or game objects without a renderer attached at position " + i);
				smr = null;
				return;
			}
		}
		bool updateWhenOffscreen = smr.updateWhenOffscreen;
		smr.updateWhenOffscreen = true;
		smr.updateWhenOffscreen = updateWhenOffscreen;
	}

	private void Update()
	{
		if (smr != null && objects != null)
		{
			MB3_MeshCombiner.UpdateSkinnedMeshApproximateBoundsFromBoundsStatic(objects, smr);
		}
	}
}
public class MB3_BatchPrefabBaker : MonoBehaviour
{
	[Serializable]
	public class MB3_PrefabBakerRow
	{
		public GameObject sourcePrefab;

		public GameObject resultPrefab;
	}

	public MB2_LogLevel LOG_LEVEL = MB2_LogLevel.info;

	public MB3_PrefabBakerRow[] prefabRows;

	public string outputPrefabFolder;
}
public class MB3_BoneWeightCopier : MonoBehaviour
{
	public GameObject inputGameObject;

	public GameObject outputPrefab;

	public float radius = 0.01f;

	public SkinnedMeshRenderer seamMesh;

	public string outputFolder;
}
public class MB3_DisableHiddenAnimations : MonoBehaviour
{
	public List<Animation> animationsToCull = new List<Animation>();

	private void Start()
	{
		if (GetComponent<SkinnedMeshRenderer>() == null)
		{
			UnityEngine.Debug.LogError("The MB3_CullHiddenAnimations script was placed on and object " + base.name + " which has no SkinnedMeshRenderer attached");
		}
	}

	private void OnBecameVisible()
	{
		for (int i = 0; i < animationsToCull.Count; i++)
		{
			if (animationsToCull[i] != null)
			{
				animationsToCull[i].enabled = true;
			}
		}
	}

	private void OnBecameInvisible()
	{
		for (int i = 0; i < animationsToCull.Count; i++)
		{
			if (animationsToCull[i] != null)
			{
				animationsToCull[i].enabled = false;
			}
		}
	}
}
public class MB3_MeshBaker : MB3_MeshBakerCommon
{
	[SerializeField]
	protected MB3_MeshCombinerSingle _meshCombiner = new MB3_MeshCombinerSingle();

	public override MB3_MeshCombiner meshCombiner => _meshCombiner;

	public void BuildSceneMeshObject()
	{
		_meshCombiner.BuildSceneMeshObject();
	}

	public virtual bool ShowHide(GameObject[] gos, GameObject[] deleteGOs)
	{
		return _meshCombiner.ShowHideGameObjects(gos, deleteGOs);
	}

	public virtual void ApplyShowHide()
	{
		_meshCombiner.ApplyShowHide();
	}

	public override bool AddDeleteGameObjects(GameObject[] gos, GameObject[] deleteGOs, bool disableRendererInSource)
	{
		_meshCombiner.name = base.name + "-mesh";
		return _meshCombiner.AddDeleteGameObjects(gos, deleteGOs, disableRendererInSource);
	}

	public override bool AddDeleteGameObjectsByID(GameObject[] gos, int[] deleteGOinstanceIDs, bool disableRendererInSource)
	{
		_meshCombiner.name = base.name + "-mesh";
		return _meshCombiner.AddDeleteGameObjectsByID(gos, deleteGOinstanceIDs, disableRendererInSource);
	}
}
public abstract class MB3_MeshBakerCommon : MB3_MeshBakerRoot
{
	public List<GameObject> objsToMesh;

	public bool useObjsToMeshFromTexBaker = true;

	public bool clearBuffersAfterBake = true;

	public string bakeAssetsInPlaceFolderPath;

	[HideInInspector]
	public GameObject resultPrefab;

	public abstract MB3_MeshCombiner meshCombiner { get; }

	public override MB2_TextureBakeResults textureBakeResults
	{
		get
		{
			return meshCombiner.textureBakeResults;
		}
		set
		{
			meshCombiner.textureBakeResults = value;
		}
	}

	public override List<GameObject> GetObjectsToCombine()
	{
		if (useObjsToMeshFromTexBaker)
		{
			MB3_TextureBaker component = base.gameObject.GetComponent<MB3_TextureBaker>();
			if (component == null)
			{
				component = base.gameObject.transform.parent.GetComponent<MB3_TextureBaker>();
			}
			if (component != null)
			{
				return component.GetObjectsToCombine();
			}
			UnityEngine.Debug.LogWarning("Use Objects To Mesh From Texture Baker was checked but no texture baker");
			return new List<GameObject>();
		}
		if (objsToMesh == null)
		{
			objsToMesh = new List<GameObject>();
		}
		return objsToMesh;
	}

	public void EnableDisableSourceObjectRenderers(bool show)
	{
		for (int i = 0; i < GetObjectsToCombine().Count; i++)
		{
			GameObject gameObject = GetObjectsToCombine()[i];
			if (!(gameObject != null))
			{
				continue;
			}
			Renderer renderer = MB_Utility.GetRenderer(gameObject);
			if (renderer != null)
			{
				renderer.enabled = show;
			}
			LODGroup componentInParent = renderer.GetComponentInParent<LODGroup>();
			if (!(componentInParent != null))
			{
				continue;
			}
			bool flag = true;
			LOD[] lODs = componentInParent.GetLODs();
			for (int j = 0; j < lODs.Length; j++)
			{
				for (int k = 0; k < lODs[j].renderers.Length; k++)
				{
					if (lODs[j].renderers[k] != renderer)
					{
						flag = false;
						break;
					}
				}
			}
			if (flag)
			{
				componentInParent.enabled = show;
			}
		}
	}

	public virtual void ClearMesh()
	{
		meshCombiner.ClearMesh();
	}

	public virtual void DestroyMesh()
	{
		meshCombiner.DestroyMesh();
	}

	public virtual void DestroyMeshEditor(MB2_EditorMethodsInterface editorMethods)
	{
		meshCombiner.DestroyMeshEditor(editorMethods);
	}

	public virtual int GetNumObjectsInCombined()
	{
		return meshCombiner.GetNumObjectsInCombined();
	}

	public virtual int GetNumVerticesFor(GameObject go)
	{
		return meshCombiner.GetNumVerticesFor(go);
	}

	public MB3_TextureBaker GetTextureBaker()
	{
		MB3_TextureBaker component = GetComponent<MB3_TextureBaker>();
		if (component != null)
		{
			return component;
		}
		if (base.transform.parent != null)
		{
			return base.transform.parent.GetComponent<MB3_TextureBaker>();
		}
		return null;
	}

	public abstract bool AddDeleteGameObjects(GameObject[] gos, GameObject[] deleteGOs, bool disableRendererInSource = true);

	public abstract bool AddDeleteGameObjectsByID(GameObject[] gos, int[] deleteGOinstanceIDs, bool disableRendererInSource = true);

	public virtual void Apply(MB3_MeshCombiner.GenerateUV2Delegate uv2GenerationMethod = null)
	{
		meshCombiner.name = base.name + "-mesh";
		meshCombiner.Apply(uv2GenerationMethod);
	}

	public virtual void Apply(bool triangles, bool vertices, bool normals, bool tangents, bool uvs, bool uv2, bool uv3, bool uv4, bool colors, bool bones = false, bool blendShapesFlag = false, MB3_MeshCombiner.GenerateUV2Delegate uv2GenerationMethod = null)
	{
		meshCombiner.name = base.name + "-mesh";
		meshCombiner.Apply(triangles, vertices, normals, tangents, uvs, uv2, uv3, uv4, colors, bones, blendShapesFlag, uv2GenerationMethod);
	}

	public virtual bool CombinedMeshContains(GameObject go)
	{
		return meshCombiner.CombinedMeshContains(go);
	}

	public virtual void UpdateGameObjects(GameObject[] gos, bool recalcBounds = true, bool updateVertices = true, bool updateNormals = true, bool updateTangents = true, bool updateUV = false, bool updateUV1 = false, bool updateUV2 = false, bool updateColors = false, bool updateSkinningInfo = false)
	{
		meshCombiner.name = base.name + "-mesh";
		meshCombiner.UpdateGameObjects(gos, recalcBounds, updateVertices, updateNormals, updateTangents, updateUV, updateUV1, updateUV2, updateColors, updateSkinningInfo);
	}

	public virtual void UpdateSkinnedMeshApproximateBounds()
	{
		if (_ValidateForUpdateSkinnedMeshBounds())
		{
			meshCombiner.UpdateSkinnedMeshApproximateBounds();
		}
	}

	public virtual void UpdateSkinnedMeshApproximateBoundsFromBones()
	{
		if (_ValidateForUpdateSkinnedMeshBounds())
		{
			meshCombiner.UpdateSkinnedMeshApproximateBoundsFromBones();
		}
	}

	public virtual void UpdateSkinnedMeshApproximateBoundsFromBounds()
	{
		if (_ValidateForUpdateSkinnedMeshBounds())
		{
			meshCombiner.UpdateSkinnedMeshApproximateBoundsFromBounds();
		}
	}

	protected virtual bool _ValidateForUpdateSkinnedMeshBounds()
	{
		if (meshCombiner.outputOption == MB2_OutputOptions.bakeMeshAssetsInPlace)
		{
			UnityEngine.Debug.LogWarning("Can't UpdateSkinnedMeshApproximateBounds when output type is bakeMeshAssetsInPlace");
			return false;
		}
		if (meshCombiner.resultSceneObject == null)
		{
			UnityEngine.Debug.LogWarning("Result Scene Object does not exist. No point in calling UpdateSkinnedMeshApproximateBounds.");
			return false;
		}
		if (meshCombiner.resultSceneObject.GetComponentInChildren<SkinnedMeshRenderer>() == null)
		{
			UnityEngine.Debug.LogWarning("No SkinnedMeshRenderer on result scene object.");
			return false;
		}
		return true;
	}
}
public class MB3_MeshBakerGrouper : MonoBehaviour
{
	public enum ClusterType
	{
		none,
		grid,
		pie,
		agglomerative
	}

	public MB3_MeshBakerGrouperCore grouper;

	public ClusterType clusterType;

	public GrouperData data = new GrouperData();

	[HideInInspector]
	public Bounds sourceObjectBounds = new Bounds(Vector3.zero, Vector3.one);

	private void OnDrawGizmosSelected()
	{
		if (grouper == null)
		{
			grouper = CreateGrouper(clusterType, data);
		}
		if (grouper.d == null)
		{
			grouper.d = data;
		}
		grouper.DrawGizmos(sourceObjectBounds);
	}

	public MB3_MeshBakerGrouperCore CreateGrouper(ClusterType t, GrouperData data)
	{
		if (t == ClusterType.grid)
		{
			grouper = new MB3_MeshBakerGrouperGrid(data);
		}
		if (t == ClusterType.pie)
		{
			grouper = new MB3_MeshBakerGrouperPie(data);
		}
		if (t == ClusterType.agglomerative)
		{
			MB3_TextureBaker component = GetComponent<MB3_TextureBaker>();
			List<GameObject> gos = ((!(component != null)) ? new List<GameObject>() : component.GetObjectsToCombine());
			grouper = new MB3_MeshBakerGrouperCluster(data, gos);
		}
		if (t == ClusterType.none)
		{
			grouper = new MB3_MeshBakerGrouperNone(data);
		}
		return grouper;
	}
}
public abstract class MB3_MeshBakerRoot : MonoBehaviour
{
	public class ZSortObjects
	{
		public class Item
		{
			public GameObject go;

			public Vector3 point;
		}

		public class ItemComparer : IComparer<Item>
		{
			public int Compare(Item a, Item b)
			{
				return (int)Mathf.Sign(b.point.z - a.point.z);
			}
		}

		public Vector3 sortAxis;

		public void SortByDistanceAlongAxis(List<GameObject> gos)
		{
			if (sortAxis == Vector3.zero)
			{
				UnityEngine.Debug.LogError("The sort axis cannot be the zero vector.");
				return;
			}
			UnityEngine.Debug.Log("Z sorting meshes along axis numObjs=" + gos.Count);
			List<Item> list = new List<Item>();
			Quaternion quaternion = Quaternion.FromToRotation(sortAxis, Vector3.forward);
			for (int i = 0; i < gos.Count; i++)
			{
				if (gos[i] != null)
				{
					Item item = new Item();
					item.point = gos[i].transform.position;
					item.go = gos[i];
					item.point = quaternion * item.point;
					list.Add(item);
				}
			}
			list.Sort(new ItemComparer());
			for (int j = 0; j < gos.Count; j++)
			{
				gos[j] = list[j].go;
			}
		}
	}

	public static bool DO_INTEGRITY_CHECKS;

	public Vector3 sortAxis;

	[HideInInspector]
	public abstract MB2_TextureBakeResults textureBakeResults { get; set; }

	public virtual List<GameObject> GetObjectsToCombine()
	{
		return null;
	}

	public static bool DoCombinedValidate(MB3_MeshBakerRoot mom, MB_ObjsToCombineTypes objToCombineType, MB2_EditorMethodsInterface editorMethods, MB2_ValidationLevel validationLevel)
	{
		if (mom.textureBakeResults == null)
		{
			UnityEngine.Debug.LogError("Need to set Texture Bake Result on " + mom);
			return false;
		}
		if (mom is MB3_MeshBakerCommon)
		{
			MB3_TextureBaker textureBaker = ((MB3_MeshBakerCommon)mom).GetTextureBaker();
			if (textureBaker != null && textureBaker.textureBakeResults != mom.textureBakeResults)
			{
				UnityEngine.Debug.LogWarning("Texture Bake Result on this component is not the same as the Texture Bake Result on the MB3_TextureBaker.");
			}
		}
		Dictionary<int, MB_Utility.MeshAnalysisResult> dictionary = null;
		if (validationLevel == MB2_ValidationLevel.robust)
		{
			dictionary = new Dictionary<int, MB_Utility.MeshAnalysisResult>();
		}
		List<GameObject> objectsToCombine = mom.GetObjectsToCombine();
		for (int i = 0; i < objectsToCombine.Count; i++)
		{
			GameObject gameObject = objectsToCombine[i];
			if (gameObject == null)
			{
				UnityEngine.Debug.LogError("The list of objects to combine contains a null at position." + i + " Select and use [shift] delete to remove");
				return false;
			}
			for (int j = i + 1; j < objectsToCombine.Count; j++)
			{
				if (objectsToCombine[i] == objectsToCombine[j])
				{
					UnityEngine.Debug.LogError("The list of objects to combine contains duplicates at " + i + " and " + j);
					return false;
				}
			}
			if (MB_Utility.GetGOMaterials(gameObject).Length == 0)
			{
				UnityEngine.Debug.LogError(string.Concat("Object ", gameObject, " in the list of objects to be combined does not have a material"));
				return false;
			}
			Mesh mesh = MB_Utility.GetMesh(gameObject);
			if (mesh == null)
			{
				UnityEngine.Debug.LogError(string.Concat("Object ", gameObject, " in the list of objects to be combined does not have a mesh"));
				return false;
			}
			if (mesh != null && !Application.isEditor && Application.isPlaying && mom.textureBakeResults.doMultiMaterial && validationLevel >= MB2_ValidationLevel.robust)
			{
				if (!dictionary.TryGetValue(mesh.GetInstanceID(), out var value))
				{
					MB_Utility.doSubmeshesShareVertsOrTris(mesh, ref value);
					dictionary.Add(mesh.GetInstanceID(), value);
				}
				if (value.hasOverlappingSubmeshVerts)
				{
					UnityEngine.Debug.LogWarning(string.Concat("Object ", objectsToCombine[i], " in the list of objects to combine has overlapping submeshes (submeshes share vertices). If the UVs associated with the shared vertices are important then this bake may not work. If you are using multiple materials then this object can only be combined with objects that use the exact same set of textures (each atlas contains one texture). There may be other undesirable side affects as well. Mesh Master, available in the asset store can fix overlapping submeshes."));
				}
			}
		}
		List<GameObject> list = objectsToCombine;
		if (mom is MB3_MeshBaker)
		{
			list = mom.GetObjectsToCombine();
			if (list == null || list.Count == 0)
			{
				UnityEngine.Debug.LogError("No meshes to combine. Please assign some meshes to combine.");
				return false;
			}
			if (mom is MB3_MeshBaker && ((MB3_MeshBaker)mom).meshCombiner.renderType == MB_RenderType.skinnedMeshRenderer && !editorMethods.ValidateSkinnedMeshes(list))
			{
				return false;
			}
		}
		editorMethods?.CheckPrefabTypes(objToCombineType, objectsToCombine);
		return true;
	}
}
public class MB3_MultiMeshBaker : MB3_MeshBakerCommon
{
	[SerializeField]
	protected MB3_MultiMeshCombiner _meshCombiner = new MB3_MultiMeshCombiner();

	public override MB3_MeshCombiner meshCombiner => _meshCombiner;

	public override bool AddDeleteGameObjects(GameObject[] gos, GameObject[] deleteGOs, bool disableRendererInSource)
	{
		if (_meshCombiner.resultSceneObject == null)
		{
			_meshCombiner.resultSceneObject = new GameObject("CombinedMesh-" + base.name);
		}
		meshCombiner.name = base.name + "-mesh";
		return _meshCombiner.AddDeleteGameObjects(gos, deleteGOs, disableRendererInSource);
	}

	public override bool AddDeleteGameObjectsByID(GameObject[] gos, int[] deleteGOs, bool disableRendererInSource)
	{
		if (_meshCombiner.resultSceneObject == null)
		{
			_meshCombiner.resultSceneObject = new GameObject("CombinedMesh-" + base.name);
		}
		meshCombiner.name = base.name + "-mesh";
		return _meshCombiner.AddDeleteGameObjectsByID(gos, deleteGOs, disableRendererInSource);
	}
}
public class MB3_TextureBaker : MB3_MeshBakerRoot
{
	public delegate void OnCombinedTexturesCoroutineSuccess();

	public delegate void OnCombinedTexturesCoroutineFail();

	public class CreateAtlasesCoroutineResult
	{
		public bool success = true;

		public bool isFinished;
	}

	public MB2_LogLevel LOG_LEVEL = MB2_LogLevel.info;

	[SerializeField]
	protected MB2_TextureBakeResults _textureBakeResults;

	[SerializeField]
	protected int _atlasPadding = 1;

	[SerializeField]
	protected int _maxAtlasSize = 4096;

	[SerializeField]
	protected bool _useMaxAtlasWidthOverride;

	[SerializeField]
	protected int _maxAtlasWidthOverride = 4096;

	[SerializeField]
	protected bool _useMaxAtlasHeightOverride;

	[SerializeField]
	protected int _maxAtlasHeightOverride = 4096;

	[SerializeField]
	protected bool _resizePowerOfTwoTextures;

	[SerializeField]
	protected bool _fixOutOfBoundsUVs;

	[SerializeField]
	protected int _maxTilingBakeSize = 1024;

	[SerializeField]
	protected MB2_PackingAlgorithmEnum _packingAlgorithm = MB2_PackingAlgorithmEnum.MeshBakerTexturePacker;

	[SerializeField]
	protected bool _meshBakerTexturePackerForcePowerOfTwo = true;

	[SerializeField]
	protected List<ShaderTextureProperty> _customShaderProperties = new List<ShaderTextureProperty>();

	[SerializeField]
	protected List<string> _customShaderPropNames_Depricated = new List<string>();

	[SerializeField]
	protected bool _doMultiMaterial;

	[SerializeField]
	protected bool _doMultiMaterialSplitAtlasesIfTooBig = true;

	[SerializeField]
	protected bool _doMultiMaterialSplitAtlasesIfOBUVs = true;

	[SerializeField]
	protected Material _resultMaterial;

	[SerializeField]
	protected bool _considerNonTextureProperties;

	[SerializeField]
	protected bool _doSuggestTreatment = true;

	private CreateAtlasesCoroutineResult _coroutineResult;

	public MB_MultiMaterial[] resultMaterials = new MB_MultiMaterial[0];

	public List<GameObject> objsToMesh;

	public OnCombinedTexturesCoroutineSuccess onBuiltAtlasesSuccess;

	public OnCombinedTexturesCoroutineFail onBuiltAtlasesFail;

	public MB_AtlasesAndRects[] OnCombinedTexturesCoroutineAtlasesAndRects;

	public override MB2_TextureBakeResults textureBakeResults
	{
		get
		{
			return _textureBakeResults;
		}
		set
		{
			_textureBakeResults = value;
		}
	}

	public virtual int atlasPadding
	{
		get
		{
			return _atlasPadding;
		}
		set
		{
			_atlasPadding = value;
		}
	}

	public virtual int maxAtlasSize
	{
		get
		{
			return _maxAtlasSize;
		}
		set
		{
			_maxAtlasSize = value;
		}
	}

	public virtual bool useMaxAtlasWidthOverride
	{
		get
		{
			return _useMaxAtlasWidthOverride;
		}
		set
		{
			_useMaxAtlasWidthOverride = value;
		}
	}

	public virtual int maxAtlasWidthOverride
	{
		get
		{
			return _maxAtlasWidthOverride;
		}
		set
		{
			_maxAtlasWidthOverride = value;
		}
	}

	public virtual bool useMaxAtlasHeightOverride
	{
		get
		{
			return _useMaxAtlasHeightOverride;
		}
		set
		{
			_useMaxAtlasHeightOverride = value;
		}
	}

	public virtual int maxAtlasHeightOverride
	{
		get
		{
			return _maxAtlasHeightOverride;
		}
		set
		{
			_maxAtlasHeightOverride = value;
		}
	}

	public virtual bool resizePowerOfTwoTextures
	{
		get
		{
			return _resizePowerOfTwoTextures;
		}
		set
		{
			_resizePowerOfTwoTextures = value;
		}
	}

	public virtual bool fixOutOfBoundsUVs
	{
		get
		{
			return _fixOutOfBoundsUVs;
		}
		set
		{
			_fixOutOfBoundsUVs = value;
		}
	}

	public virtual int maxTilingBakeSize
	{
		get
		{
			return _maxTilingBakeSize;
		}
		set
		{
			_maxTilingBakeSize = value;
		}
	}

	public virtual MB2_PackingAlgorithmEnum packingAlgorithm
	{
		get
		{
			return _packingAlgorithm;
		}
		set
		{
			_packingAlgorithm = value;
		}
	}

	public bool meshBakerTexturePackerForcePowerOfTwo
	{
		get
		{
			return _meshBakerTexturePackerForcePowerOfTwo;
		}
		set
		{
			_meshBakerTexturePackerForcePowerOfTwo = value;
		}
	}

	public virtual List<ShaderTextureProperty> customShaderProperties
	{
		get
		{
			return _customShaderProperties;
		}
		set
		{
			_customShaderProperties = value;
		}
	}

	public virtual List<string> customShaderPropNames
	{
		get
		{
			return _customShaderPropNames_Depricated;
		}
		set
		{
			_customShaderPropNames_Depricated = value;
		}
	}

	public virtual bool doMultiMaterial
	{
		get
		{
			return _doMultiMaterial;
		}
		set
		{
			_doMultiMaterial = value;
		}
	}

	public virtual bool doMultiMaterialSplitAtlasesIfTooBig
	{
		get
		{
			return _doMultiMaterialSplitAtlasesIfTooBig;
		}
		set
		{
			_doMultiMaterialSplitAtlasesIfTooBig = value;
		}
	}

	public virtual bool doMultiMaterialSplitAtlasesIfOBUVs
	{
		get
		{
			return _doMultiMaterialSplitAtlasesIfOBUVs;
		}
		set
		{
			_doMultiMaterialSplitAtlasesIfOBUVs = value;
		}
	}

	public virtual Material resultMaterial
	{
		get
		{
			return _resultMaterial;
		}
		set
		{
			_resultMaterial = value;
		}
	}

	public bool considerNonTextureProperties
	{
		get
		{
			return _considerNonTextureProperties;
		}
		set
		{
			_considerNonTextureProperties = value;
		}
	}

	public bool doSuggestTreatment
	{
		get
		{
			return _doSuggestTreatment;
		}
		set
		{
			_doSuggestTreatment = value;
		}
	}

	public CreateAtlasesCoroutineResult CoroutineResult => _coroutineResult;

	public override List<GameObject> GetObjectsToCombine()
	{
		if (objsToMesh == null)
		{
			objsToMesh = new List<GameObject>();
		}
		return objsToMesh;
	}

	public MB_AtlasesAndRects[] CreateAtlases()
	{
		return CreateAtlases(null);
	}

	public IEnumerator CreateAtlasesCoroutine(ProgressUpdateDelegate progressInfo, CreateAtlasesCoroutineResult coroutineResult, bool saveAtlasesAsAssets = false, MB2_EditorMethodsInterface editorMethods = null, float maxTimePerFrame = 0.01f)
	{
		MBVersionConcrete mBVersionConcrete = new MBVersionConcrete();
		if (!MB3_TextureCombiner._RunCorutineWithoutPauseIsRunning && (mBVersionConcrete.GetMajorVersion() < 5 || (mBVersionConcrete.GetMajorVersion() == 5 && mBVersionConcrete.GetMinorVersion() < 3)))
		{
			UnityEngine.Debug.LogError("Running the texture combiner as a coroutine only works in Unity 5.3 and higher");
			coroutineResult.success = false;
			yield break;
		}
		OnCombinedTexturesCoroutineAtlasesAndRects = null;
		if (maxTimePerFrame <= 0f)
		{
			UnityEngine.Debug.LogError("maxTimePerFrame must be a value greater than zero");
			coroutineResult.isFinished = true;
			yield break;
		}
		MB2_ValidationLevel validationLevel = (Application.isPlaying ? MB2_ValidationLevel.quick : MB2_ValidationLevel.robust);
		if (!MB3_MeshBakerRoot.DoCombinedValidate(this, MB_ObjsToCombineTypes.dontCare, null, validationLevel))
		{
			coroutineResult.isFinished = true;
			yield break;
		}
		if (_doMultiMaterial && !_ValidateResultMaterials())
		{
			coroutineResult.isFinished = true;
			yield break;
		}
		if (!_doMultiMaterial)
		{
			if (_resultMaterial == null)
			{
				UnityEngine.Debug.LogError("Combined Material is null please create and assign a result material.");
				coroutineResult.isFinished = true;
				yield break;
			}
			Shader shader = _resultMaterial.shader;
			for (int j = 0; j < objsToMesh.Count; j++)
			{
				Material[] gOMaterials = MB_Utility.GetGOMaterials(objsToMesh[j]);
				foreach (Material material in gOMaterials)
				{
					if (material != null && material.shader != shader)
					{
						UnityEngine.Debug.LogWarning(string.Concat("Game object ", objsToMesh[j], " does not use shader ", shader, " it may not have the required textures. If not small solid color textures will be generated."));
					}
				}
			}
		}
		MB3_TextureCombiner combiner = CreateAndConfigureTextureCombiner();
		combiner.saveAtlasesAsAssets = saveAtlasesAsAssets;
		int num = 1;
		if (_doMultiMaterial)
		{
			num = resultMaterials.Length;
		}
		OnCombinedTexturesCoroutineAtlasesAndRects = new MB_AtlasesAndRects[num];
		for (int l = 0; l < OnCombinedTexturesCoroutineAtlasesAndRects.Length; l++)
		{
			OnCombinedTexturesCoroutineAtlasesAndRects[l] = new MB_AtlasesAndRects();
		}
		for (int i = 0; i < OnCombinedTexturesCoroutineAtlasesAndRects.Length; i++)
		{
			List<Material> allowedMaterialsFilter = null;
			Material combinedMaterial;
			if (_doMultiMaterial)
			{
				allowedMaterialsFilter = resultMaterials[i].sourceMaterials;
				combinedMaterial = resultMaterials[i].combinedMaterial;
				combiner.fixOutOfBoundsUVs = resultMaterials[i].considerMeshUVs;
			}
			else
			{
				combinedMaterial = _resultMaterial;
			}
			MB3_TextureCombiner.CombineTexturesIntoAtlasesCoroutineResult coroutineResult2 = new MB3_TextureCombiner.CombineTexturesIntoAtlasesCoroutineResult();
			yield return combiner.CombineTexturesIntoAtlasesCoroutine(progressInfo, OnCombinedTexturesCoroutineAtlasesAndRects[i], combinedMaterial, objsToMesh, allowedMaterialsFilter, editorMethods, coroutineResult2, maxTimePerFrame);
			coroutineResult.success = coroutineResult2.success;
			if (!coroutineResult.success)
			{
				coroutineResult.isFinished = true;
				yield break;
			}
		}
		unpackMat2RectMap(textureBakeResults);
		textureBakeResults.doMultiMaterial = _doMultiMaterial;
		if (_doMultiMaterial)
		{
			textureBakeResults.resultMaterials = resultMaterials;
		}
		else
		{
			MB_MultiMaterial[] array = new MB_MultiMaterial[1]
			{
				new MB_MultiMaterial()
			};
			array[0].combinedMaterial = _resultMaterial;
			array[0].considerMeshUVs = _fixOutOfBoundsUVs;
			array[0].sourceMaterials = new List<Material>();
			for (int m = 0; m < textureBakeResults.materialsAndUVRects.Length; m++)
			{
				array[0].sourceMaterials.Add(textureBakeResults.materialsAndUVRects[m].material);
			}
			textureBakeResults.resultMaterials = array;
		}
		MB3_MeshBakerCommon[] componentsInChildren = GetComponentsInChildren<MB3_MeshBakerCommon>();
		for (int n = 0; n < componentsInChildren.Length; n++)
		{
			componentsInChildren[n].textureBakeResults = textureBakeResults;
		}
		if (LOG_LEVEL >= MB2_LogLevel.info)
		{
			UnityEngine.Debug.Log("Created Atlases");
		}
		coroutineResult.isFinished = true;
		if (coroutineResult.success && onBuiltAtlasesSuccess != null)
		{
			onBuiltAtlasesSuccess();
		}
		if (!coroutineResult.success && onBuiltAtlasesFail != null)
		{
			onBuiltAtlasesFail();
		}
	}

	public MB_AtlasesAndRects[] CreateAtlases(ProgressUpdateDelegate progressInfo, bool saveAtlasesAsAssets = false, MB2_EditorMethodsInterface editorMethods = null)
	{
		MB_AtlasesAndRects[] array = null;
		try
		{
			_coroutineResult = new CreateAtlasesCoroutineResult();
			MB3_TextureCombiner.RunCorutineWithoutPause(CreateAtlasesCoroutine(progressInfo, _coroutineResult, saveAtlasesAsAssets, editorMethods, 1000f), 0);
			if (_coroutineResult.success && textureBakeResults != null)
			{
				array = OnCombinedTexturesCoroutineAtlasesAndRects;
			}
		}
		catch (Exception message)
		{
			UnityEngine.Debug.LogError(message);
		}
		finally
		{
			if (saveAtlasesAsAssets && array != null)
			{
				foreach (MB_AtlasesAndRects mB_AtlasesAndRects in array)
				{
					if (mB_AtlasesAndRects == null || mB_AtlasesAndRects.atlases == null)
					{
						continue;
					}
					for (int j = 0; j < mB_AtlasesAndRects.atlases.Length; j++)
					{
						if (mB_AtlasesAndRects.atlases[j] != null)
						{
							if (editorMethods != null)
							{
								editorMethods.Destroy(mB_AtlasesAndRects.atlases[j]);
							}
							else
							{
								MB_Utility.Destroy(mB_AtlasesAndRects.atlases[j]);
							}
						}
					}
				}
			}
		}
		return array;
	}

	private void unpackMat2RectMap(MB2_TextureBakeResults tbr)
	{
		List<Material> list = new List<Material>();
		List<MB_MaterialAndUVRect> list2 = new List<MB_MaterialAndUVRect>();
		List<Rect> list3 = new List<Rect>();
		for (int i = 0; i < OnCombinedTexturesCoroutineAtlasesAndRects.Length; i++)
		{
			List<MB_MaterialAndUVRect> mat2rect_map = OnCombinedTexturesCoroutineAtlasesAndRects[i].mat2rect_map;
			if (mat2rect_map != null)
			{
				for (int j = 0; j < mat2rect_map.Count; j++)
				{
					list2.Add(mat2rect_map[j]);
					list.Add(mat2rect_map[j].material);
					list3.Add(mat2rect_map[j].atlasRect);
				}
			}
		}
		tbr.version = MB2_TextureBakeResults.VERSION;
		tbr.materialsAndUVRects = list2.ToArray();
	}

	public MB3_TextureCombiner CreateAndConfigureTextureCombiner()
	{
		return new MB3_TextureCombiner
		{
			LOG_LEVEL = LOG_LEVEL,
			atlasPadding = _atlasPadding,
			maxAtlasSize = _maxAtlasSize,
			maxAtlasHeightOverride = _maxAtlasHeightOverride,
			maxAtlasWidthOverride = _maxAtlasWidthOverride,
			useMaxAtlasHeightOverride = _useMaxAtlasHeightOverride,
			useMaxAtlasWidthOverride = _useMaxAtlasWidthOverride,
			customShaderPropNames = _customShaderProperties,
			fixOutOfBoundsUVs = _fixOutOfBoundsUVs,
			maxTilingBakeSize = _maxTilingBakeSize,
			packingAlgorithm = _packingAlgorithm,
			meshBakerTexturePackerForcePowerOfTwo = _meshBakerTexturePackerForcePowerOfTwo,
			resizePowerOfTwoTextures = _resizePowerOfTwoTextures,
			considerNonTextureProperties = _considerNonTextureProperties
		};
	}

	public static void ConfigureNewMaterialToMatchOld(Material newMat, Material original)
	{
		if (original == null)
		{
			UnityEngine.Debug.LogWarning(string.Concat("Original material is null, could not copy properties to ", newMat, ". Setting shader to ", newMat.shader));
			return;
		}
		newMat.shader = original.shader;
		newMat.CopyPropertiesFromMaterial(original);
		ShaderTextureProperty[] shaderTexPropertyNames = MB3_TextureCombinerPipeline.shaderTexPropertyNames;
		for (int i = 0; i < shaderTexPropertyNames.Length; i++)
		{
			Vector2 one = Vector2.one;
			Vector2 zero = Vector2.zero;
			if (newMat.HasProperty(shaderTexPropertyNames[i].name))
			{
				newMat.SetTextureOffset(shaderTexPropertyNames[i].name, zero);
				newMat.SetTextureScale(shaderTexPropertyNames[i].name, one);
			}
		}
	}

	private string PrintSet(HashSet<Material> s)
	{
		StringBuilder stringBuilder = new StringBuilder();
		foreach (Material item in s)
		{
			stringBuilder.Append(string.Concat(item, ","));
		}
		return stringBuilder.ToString();
	}

	private bool _ValidateResultMaterials()
	{
		HashSet<Material> hashSet = new HashSet<Material>();
		for (int i = 0; i < objsToMesh.Count; i++)
		{
			if (!(objsToMesh[i] != null))
			{
				continue;
			}
			Material[] gOMaterials = MB_Utility.GetGOMaterials(objsToMesh[i]);
			for (int j = 0; j < gOMaterials.Length; j++)
			{
				if (gOMaterials[j] != null)
				{
					hashSet.Add(gOMaterials[j]);
				}
			}
		}
		HashSet<Material> hashSet2 = new HashSet<Material>();
		for (int k = 0; k < resultMaterials.Length; k++)
		{
			MB_MultiMaterial mB_MultiMaterial = resultMaterials[k];
			if (mB_MultiMaterial.combinedMaterial == null)
			{
				UnityEngine.Debug.LogError("Combined Material is null please create and assign a result material.");
				return false;
			}
			Shader shader = mB_MultiMaterial.combinedMaterial.shader;
			for (int l = 0; l < mB_MultiMaterial.sourceMaterials.Count; l++)
			{
				if (mB_MultiMaterial.sourceMaterials[l] == null)
				{
					UnityEngine.Debug.LogError("There are null entries in the list of Source Materials");
					return false;
				}
				if (shader != mB_MultiMaterial.sourceMaterials[l].shader)
				{
					UnityEngine.Debug.LogWarning(string.Concat("Source material ", mB_MultiMaterial.sourceMaterials[l], " does not use shader ", shader, " it may not have the required textures. If not empty textures will be generated."));
				}
				if (hashSet2.Contains(mB_MultiMaterial.sourceMaterials[l]))
				{
					UnityEngine.Debug.LogError(string.Concat("A Material ", mB_MultiMaterial.sourceMaterials[l], " appears more than once in the list of source materials in the source material to combined mapping. Each source material must be unique."));
					return false;
				}
				hashSet2.Add(mB_MultiMaterial.sourceMaterials[l]);
			}
		}
		if (hashSet.IsProperSubsetOf(hashSet2))
		{
			hashSet2.ExceptWith(hashSet);
			UnityEngine.Debug.LogWarning("There are materials in the mapping that are not used on your source objects: " + PrintSet(hashSet2));
		}
		if (resultMaterials != null && resultMaterials.Length != 0 && hashSet2.IsProperSubsetOf(hashSet))
		{
			hashSet.ExceptWith(hashSet2);
			UnityEngine.Debug.LogError("There are materials on the objects to combine that are not in the mapping: " + PrintSet(hashSet));
			return false;
		}
		return true;
	}
}
public class NewBehaviourScript : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}
[AddComponentMenu("Camera-Control/Mouse Look")]
public class MouseLook : MonoBehaviour
{
	public enum RotationAxes
	{
		MouseXAndY,
		MouseX,
		MouseY
	}

	public RotationAxes axes;

	public float sensitivityX = 15f;

	public float sensitivityY = 15f;

	public float minimumX = -360f;

	public float maximumX = 360f;

	public float minimumY = -60f;

	public float maximumY = 60f;

	private float rotationY;

	private void Update()
	{
		if (axes == RotationAxes.MouseXAndY)
		{
			float y = base.transform.localEulerAngles.y + Input.GetAxis("Mouse X") * sensitivityX;
			rotationY += Input.GetAxis("Mouse Y") * sensitivityY;
			rotationY = Mathf.Clamp(rotationY, minimumY, maximumY);
			base.transform.localEulerAngles = new Vector3(0f - rotationY, y, 0f);
		}
		else if (axes == RotationAxes.MouseX)
		{
			base.transform.Rotate(0f, Input.GetAxis("Mouse X") * sensitivityX, 0f);
		}
		else
		{
			rotationY += Input.GetAxis("Mouse Y") * sensitivityY;
			rotationY = Mathf.Clamp(rotationY, minimumY, maximumY);
			base.transform.localEulerAngles = new Vector3(0f - rotationY, base.transform.localEulerAngles.y, 0f);
		}
	}

	private void Start()
	{
		if ((bool)GetComponent<Rigidbody>())
		{
			GetComponent<Rigidbody>().freezeRotation = true;
		}
	}
}
public struct ReflectionSnapshot
{
	public AudioMixerSnapshot mixerSnapshot;

	public float fadeTime;
}
public class ONSPReflectionZone : MonoBehaviour
{
	public AudioMixerSnapshot mixerSnapshot;

	public float fadeTime;

	private static Stack<ReflectionSnapshot> snapshotList = new Stack<ReflectionSnapshot>();

	private static ReflectionSnapshot currentSnapshot = default(ReflectionSnapshot);

	private void Start()
	{
	}

	private void Update()
	{
	}

	private void OnTriggerEnter(Collider other)
	{
		if (CheckForAudioListener(other.gameObject))
		{
			PushCurrentMixerShapshot();
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (CheckForAudioListener(other.gameObject))
		{
			PopCurrentMixerSnapshot();
		}
	}

	private bool CheckForAudioListener(GameObject gameObject)
	{
		if (gameObject.GetComponentInChildren<AudioListener>() != null)
		{
			return true;
		}
		return false;
	}

	private void PushCurrentMixerShapshot()
	{
		ReflectionSnapshot item = currentSnapshot;
		snapshotList.Push(item);
		SetReflectionValues();
	}

	private void PopCurrentMixerSnapshot()
	{
		ReflectionSnapshot mss = snapshotList.Pop();
		SetReflectionValues(ref mss);
	}

	private void SetReflectionValues()
	{
		if (mixerSnapshot != null)
		{
			UnityEngine.Debug.Log("Setting off snapshot " + mixerSnapshot.name);
			mixerSnapshot.TransitionTo(fadeTime);
			currentSnapshot.mixerSnapshot = mixerSnapshot;
			currentSnapshot.fadeTime = fadeTime;
		}
		else
		{
			UnityEngine.Debug.Log("Mixer snapshot not set - Please ensure play area has at least one encompassing snapshot.");
		}
	}

	private void SetReflectionValues(ref ReflectionSnapshot mss)
	{
		if (mss.mixerSnapshot != null)
		{
			UnityEngine.Debug.Log("Setting off snapshot " + mss.mixerSnapshot.name);
			mss.mixerSnapshot.TransitionTo(mss.fadeTime);
			currentSnapshot.mixerSnapshot = mss.mixerSnapshot;
			currentSnapshot.fadeTime = mss.fadeTime;
		}
		else
		{
			UnityEngine.Debug.Log("Mixer snapshot not set - Please ensure play area has at least one encompassing snapshot.");
		}
	}
}
public class OculusSpatializerUnity : MonoBehaviour
{
	public delegate void AudioRaycastCallback(Vector3 origin, Vector3 direction, out Vector3 point, out Vector3 normal, IntPtr data);

	public LayerMask layerMask = -1;

	public bool visualizeRoom = true;

	private bool roomVisualizationInitialized;

	public int raysPerSecond = 256;

	public float roomInterpSpeed = 0.9f;

	public float maxWallDistance = 50f;

	public int rayCacheSize = 512;

	public bool dynamicReflectionsEnabled = true;

	private AudioRaycastCallback _raycastCallback;

	private float particleSize = 0.2f;

	private float particleOffset = 0.1f;

	private GameObject room;

	private Renderer[] wallRenderer = new Renderer[6];

	private float[] dims = new float[3] { 1f, 1f, 1f };

	private float[] coefs = new float[6];

	private const int HIT_COUNT = 2048;

	private Vector3[] points = new Vector3[2048];

	private Vector3[] normals = new Vector3[2048];

	private ParticleSystem sys;

	private ParticleSystem.Particle[] particles = new ParticleSystem.Particle[2048];

	private static LayerMask gLayerMask = -1;

	private const string strOSP = "AudioPluginOculusSpatializer";

	private static Vector3 swapHandedness(Vector3 vec)
	{
		return new Vector3(vec.x, vec.y, 0f - vec.z);
	}

	private static void AudioRaycast(Vector3 origin, Vector3 direction, out Vector3 point, out Vector3 normal, IntPtr data)
	{
		point = Vector3.zero;
		normal = Vector3.zero;
		if (Physics.Raycast(swapHandedness(origin), swapHandedness(direction), out var hitInfo, 1000f, gLayerMask.value))
		{
			point = swapHandedness(hitInfo.point);
			normal = swapHandedness(hitInfo.normal);
		}
	}

	private void Start()
	{
		_raycastCallback = AudioRaycast;
		OSP_Unity_AssignRaycastCallback(_raycastCallback, IntPtr.Zero);
	}

	private void OnDestroy()
	{
		OSP_Unity_AssignRaycastCallback(IntPtr.Zero, IntPtr.Zero);
	}

	private void Update()
	{
		if (dynamicReflectionsEnabled)
		{
			OSP_Unity_AssignRaycastCallback(_raycastCallback, IntPtr.Zero);
		}
		else
		{
			OSP_Unity_AssignRaycastCallback(IntPtr.Zero, IntPtr.Zero);
		}
		OSP_Unity_SetDynamicRoomRaysPerSecond(raysPerSecond);
		OSP_Unity_SetDynamicRoomInterpSpeed(roomInterpSpeed);
		OSP_Unity_SetDynamicRoomMaxWallDistance(maxWallDistance);
		OSP_Unity_SetDynamicRoomRaysRayCacheSize(rayCacheSize);
		gLayerMask = layerMask;
		OSP_Unity_UpdateRoomModel(1f);
		if (!visualizeRoom)
		{
			return;
		}
		if (!roomVisualizationInitialized)
		{
			inititalizeRoomVisualization();
			roomVisualizationInitialized = true;
		}
		OSP_Unity_GetRoomDimensions(dims, coefs, out var position);
		position.z *= -1f;
		Vector3 vector = new Vector3(dims[0], dims[1], dims[2]);
		float sqrMagnitude = vector.sqrMagnitude;
		if (!float.IsNaN(sqrMagnitude) && 0f < sqrMagnitude && sqrMagnitude < 1000000f)
		{
			base.transform.localScale = vector * 0.999f;
		}
		base.transform.position = position;
		OSP_Unity_GetRaycastHits(points, normals, 2048);
		for (int i = 0; i < 2048; i++)
		{
			if (points[i] == Vector3.zero)
			{
				points[i].y = -10000f;
			}
			points[i].z *= -1f;
			normals[i].z *= -1f;
			particles[i].position = points[i] + normals[i] * particleOffset;
			if (normals[i] != Vector3.zero)
			{
				particles[i].rotation3D = Quaternion.LookRotation(normals[i]).eulerAngles;
			}
			particles[i].startSize = particleSize;
			particles[i].startColor = new UnityEngine.Color(0.8156863f, 0.14901961f, 58f / 85f, 1f);
		}
		for (int j = 0; j < 6; j++)
		{
			UnityEngine.Color value = UnityEngine.Color.Lerp(UnityEngine.Color.red, UnityEngine.Color.green, coefs[j]);
			wallRenderer[j].material.SetColor("_TintColor", value);
		}
		sys.SetParticles(particles, particles.Length);
	}

	private void inititalizeRoomVisualization()
	{
		UnityEngine.Debug.Log("Oculus Audio dynamic room estimation visualization enabled");
		base.transform.position = Vector3.zero;
		GameObject gameObject = new GameObject("DecalManager");
		gameObject.transform.parent = base.transform;
		sys = gameObject.AddComponent<ParticleSystem>();
		ParticleSystem.MainModule main = sys.main;
		main.simulationSpace = ParticleSystemSimulationSpace.World;
		main.loop = false;
		main.playOnAwake = false;
		ParticleSystem.EmissionModule emission = sys.emission;
		emission.enabled = false;
		ParticleSystem.ShapeModule shape = sys.shape;
		shape.enabled = false;
		ParticleSystemRenderer component = sys.GetComponent<ParticleSystemRenderer>();
		component.renderMode = ParticleSystemRenderMode.Mesh;
		component.material.shader = Shader.Find("Particles/Additive");
		Texture2D texture2D = new Texture2D(64, 64);
		for (int i = 0; i < 32; i++)
		{
			for (int j = 0; j < 32; j++)
			{
				float num = 32 - i;
				float num2 = 32 - j;
				float num3 = Mathf.Sqrt(num * num + num2 * num2);
				float num4 = 2f * num3 / 32f;
				float a = ((num3 < 32f) ? Mathf.Clamp01(Mathf.Sin((float)Math.PI * 2f * num4)) : 0f);
				UnityEngine.Color color = new UnityEngine.Color(1f, 1f, 1f, a);
				texture2D.SetPixel(i, j, color);
				texture2D.SetPixel(64 - i, j, color);
				texture2D.SetPixel(i, 64 - j, color);
				texture2D.SetPixel(64 - i, 64 - j, color);
			}
		}
		texture2D.Apply();
		component.material.mainTexture = texture2D;
		Mesh mesh = new Mesh();
		mesh.name = "ParticleQuad";
		mesh.vertices = new Vector3[4]
		{
			new Vector3(-0.5f, -0.5f, 0f),
			new Vector3(0.5f, -0.5f, 0f),
			new Vector3(0.5f, 0.5f, 0f),
			new Vector3(-0.5f, 0.5f, 0f)
		};
		mesh.uv = new Vector2[4]
		{
			new Vector2(0f, 0f),
			new Vector2(0f, 1f),
			new Vector2(1f, 1f),
			new Vector2(1f, 0f)
		};
		mesh.triangles = new int[6] { 0, 1, 2, 0, 2, 3 };
		mesh.RecalculateNormals();
		component.mesh = mesh;
		sys.Emit(2048);
		room = new GameObject("RoomVisualizer");
		room.transform.parent = base.transform;
		room.transform.localPosition = Vector3.zero;
		Texture2D texture2D2 = new Texture2D(32, 32);
		UnityEngine.Color color2 = new UnityEngine.Color(0f, 0f, 0f, 0f);
		for (int k = 0; k < 32; k++)
		{
			for (int l = 0; l < 32; l++)
			{
				texture2D2.SetPixel(k, l, color2);
			}
		}
		for (int m = 0; m < 32; m++)
		{
			UnityEngine.Color color3 = UnityEngine.Color.white * 0.125f;
			texture2D2.SetPixel(8, m, color3);
			texture2D2.SetPixel(m, 8, color3);
			texture2D2.SetPixel(24, m, color3);
			texture2D2.SetPixel(m, 24, color3);
			color3 *= 2f;
			texture2D2.SetPixel(16, m, color3);
			texture2D2.SetPixel(m, 16, color3);
			color3 *= 2f;
			texture2D2.SetPixel(0, m, color3);
			texture2D2.SetPixel(m, 0, color3);
		}
		texture2D2.Apply();
		for (int n = 0; n < 6; n++)
		{
			Mesh mesh2 = new Mesh();
			mesh2.name = "Plane" + n;
			Vector3[] array = new Vector3[4];
			int num5 = n / 2;
			int num6 = ((n % 2 == 0) ? 1 : (-1));
			for (int num7 = 0; num7 < 4; num7++)
			{
				array[num7][num5] = (float)num6 * 0.5f;
				array[num7][(num5 + 1) % 3] = 0.5f * (float)((num7 == 1 || num7 == 2) ? 1 : (-1));
				array[num7][(num5 + 2) % 3] = 0.5f * (float)((num7 == 2 || num7 == 3) ? 1 : (-1));
			}
			mesh2.vertices = array;
			mesh2.uv = new Vector2[4]
			{
				new Vector2(0f, 0f),
				new Vector2(0f, 1f),
				new Vector2(1f, 1f),
				new Vector2(1f, 0f)
			};
			mesh2.triangles = new int[6] { 0, 1, 2, 0, 2, 3 };
			mesh2.RecalculateNormals();
			GameObject obj = new GameObject("Wall_" + n);
			obj.AddComponent<MeshFilter>().mesh = mesh2;
			MeshRenderer meshRenderer = obj.AddComponent<MeshRenderer>();
			wallRenderer[n] = meshRenderer;
			meshRenderer.material.shader = Shader.Find("Particles/Additive");
			meshRenderer.material.mainTexture = texture2D2;
			meshRenderer.material.mainTextureScale = new Vector2(8f, 8f);
			obj.transform.parent = room.transform;
			room.transform.localPosition = Vector3.zero;
		}
	}

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_AssignRaycastCallback(MulticastDelegate callback, IntPtr data);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_AssignRaycastCallback(IntPtr callback, IntPtr data);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_SetDynamicRoomRaysPerSecond(int RaysPerSecond);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_SetDynamicRoomInterpSpeed(float InterpSpeed);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_SetDynamicRoomMaxWallDistance(float MaxWallDistance);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_SetDynamicRoomRaysRayCacheSize(int RayCacheSize);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_UpdateRoomModel(float wetLevel);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_GetRoomDimensions(float[] roomDimensions, float[] reflectionsCoefs, out Vector3 position);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_GetRaycastHits(Vector3[] points, Vector3[] normals, int length);
}
public class ONSPAmbisonicsNative : MonoBehaviour
{
	public enum ovrAmbisonicsNativeStatus
	{
		Uninitialized = -1,
		NotEnabled,
		Success,
		StreamError,
		ProcessError,
		MaxStatValue
	}

	private static int numFOAChannels = 4;

	private static int paramVSpeakerMode = 6;

	private static int paramAmbiStat = 7;

	private ovrAmbisonicsNativeStatus currentStatus = ovrAmbisonicsNativeStatus.Uninitialized;

	[SerializeField]
	private bool useVirtualSpeakers;

	public bool UseVirtualSpeakers
	{
		get
		{
			return useVirtualSpeakers;
		}
		set
		{
			useVirtualSpeakers = value;
		}
	}

	private void OnEnable()
	{
		AudioSource component = GetComponent<AudioSource>();
		currentStatus = ovrAmbisonicsNativeStatus.Uninitialized;
		if (component == null)
		{
			UnityEngine.Debug.Log("Ambisonic ERROR: AudioSource does not exist.");
			return;
		}
		if (component.spatialize)
		{
			UnityEngine.Debug.Log("Ambisonic WARNING: Turning spatialize field off for Ambisonic sources.");
			component.spatialize = false;
		}
		if (component.clip == null)
		{
			UnityEngine.Debug.Log("Ambisonic ERROR: AudioSource does not contain an audio clip.");
		}
		else if (component.clip.channels != numFOAChannels)
		{
			UnityEngine.Debug.Log("Ambisonic ERROR: AudioSource clip does not have correct number of channels.");
		}
	}

	private void Update()
	{
		AudioSource component = GetComponent<AudioSource>();
		if (component == null)
		{
			return;
		}
		if (useVirtualSpeakers)
		{
			component.SetAmbisonicDecoderFloat(paramVSpeakerMode, 1f);
		}
		else
		{
			component.SetAmbisonicDecoderFloat(paramVSpeakerMode, 0f);
		}
		float value = 0f;
		component.GetAmbisonicDecoderFloat(paramAmbiStat, out value);
		ovrAmbisonicsNativeStatus ovrAmbisonicsNativeStatus = (ovrAmbisonicsNativeStatus)value;
		if (ovrAmbisonicsNativeStatus != currentStatus)
		{
			switch (ovrAmbisonicsNativeStatus)
			{
			case ovrAmbisonicsNativeStatus.NotEnabled:
				UnityEngine.Debug.Log("Ambisonic Native: Ambisonic not enabled on clip. Check clip field and turn it on");
				break;
			case ovrAmbisonicsNativeStatus.Uninitialized:
				UnityEngine.Debug.Log("Ambisonic Native: Stream uninitialized");
				break;
			case ovrAmbisonicsNativeStatus.Success:
				UnityEngine.Debug.Log("Ambisonic Native: Stream successfully initialized and playing/playable");
				break;
			case ovrAmbisonicsNativeStatus.StreamError:
				UnityEngine.Debug.Log("Ambisonic Native WARNING: Stream error (bad input format?)");
				break;
			case ovrAmbisonicsNativeStatus.ProcessError:
				UnityEngine.Debug.Log("Ambisonic Native WARNING: Stream process error (check default speaker setup)");
				break;
			}
		}
		currentStatus = ovrAmbisonicsNativeStatus;
	}
}
public class ONSPAudioSource : MonoBehaviour
{
	private enum Parameters
	{
		P_GAIN,
		P_USEINVSQR,
		P_NEAR,
		P_FAR,
		P_RADIUS,
		P_DISABLE_RFL,
		P_VSPEAKERMODE,
		P_AMBISTAT,
		P_READONLY_GLOBAL_RFL_ENABLED,
		P_READONLY_NUM_VOICES,
		P_SENDLEVEL,
		P_NUM
	}

	public const string strONSPS = "AudioPluginOculusSpatializer";

	[SerializeField]
	private bool enableSpatialization = true;

	[SerializeField]
	private float gain;

	[SerializeField]
	private bool useInvSqr;

	[SerializeField]
	private float near = 1f;

	[SerializeField]
	private float far = 10f;

	[SerializeField]
	private float volumetricRadius;

	[SerializeField]
	private float reverbSend;

	[SerializeField]
	private bool enableRfl;

	private static ONSPAudioSource RoomReflectionGizmoAS;

	public bool EnableSpatialization
	{
		get
		{
			return enableSpatialization;
		}
		set
		{
			enableSpatialization = value;
		}
	}

	public float Gain
	{
		get
		{
			return gain;
		}
		set
		{
			gain = Mathf.Clamp(value, 0f, 24f);
		}
	}

	public bool UseInvSqr
	{
		get
		{
			return useInvSqr;
		}
		set
		{
			useInvSqr = value;
		}
	}

	public float Near
	{
		get
		{
			return near;
		}
		set
		{
			near = Mathf.Clamp(value, 0f, 1000000f);
		}
	}

	public float Far
	{
		get
		{
			return far;
		}
		set
		{
			far = Mathf.Clamp(value, 0f, 1000000f);
		}
	}

	public float VolumetricRadius
	{
		get
		{
			return volumetricRadius;
		}
		set
		{
			volumetricRadius = Mathf.Clamp(value, 0f, 1000f);
		}
	}

	public float ReverbSend
	{
		get
		{
			return reverbSend;
		}
		set
		{
			reverbSend = Mathf.Clamp(value, -60f, 20f);
		}
	}

	public bool EnableRfl
	{
		get
		{
			return enableRfl;
		}
		set
		{
			enableRfl = value;
		}
	}

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern void ONSP_GetGlobalRoomReflectionValues(ref bool reflOn, ref bool reverbOn, ref float width, ref float height, ref float length);

	private void Awake()
	{
		AudioSource source = GetComponent<AudioSource>();
		SetParameters(ref source);
	}

	private void Start()
	{
	}

	private void Update()
	{
		AudioSource source = GetComponent<AudioSource>();
		if (!Application.isPlaying || AudioListener.pause || !source.isPlaying || !source.isActiveAndEnabled)
		{
			source.spatialize = false;
		}
		else
		{
			SetParameters(ref source);
		}
	}

	public void SetParameters(ref AudioSource source)
	{
		source.spatialize = enableSpatialization;
		source.SetSpatializerFloat(0, gain);
		if (useInvSqr)
		{
			source.SetSpatializerFloat(1, 1f);
		}
		else
		{
			source.SetSpatializerFloat(1, 0f);
		}
		source.SetSpatializerFloat(2, near);
		source.SetSpatializerFloat(3, far);
		source.SetSpatializerFloat(4, volumetricRadius);
		if (enableRfl)
		{
			source.SetSpatializerFloat(5, 0f);
		}
		else
		{
			source.SetSpatializerFloat(5, 1f);
		}
		source.SetSpatializerFloat(10, reverbSend);
	}

	private void OnDrawGizmos()
	{
		if (RoomReflectionGizmoAS == null)
		{
			RoomReflectionGizmoAS = this;
		}
		UnityEngine.Color color = default(UnityEngine.Color);
		color.r = 1f;
		color.g = 0.5f;
		color.b = 0f;
		color.a = 1f;
		Gizmos.color = color;
		Gizmos.DrawWireSphere(base.transform.position, Near);
		color.a = 0.1f;
		Gizmos.color = color;
		Gizmos.DrawSphere(base.transform.position, Near);
		color.r = 1f;
		color.g = 0f;
		color.b = 0f;
		color.a = 1f;
		Gizmos.color = UnityEngine.Color.red;
		Gizmos.DrawWireSphere(base.transform.position, Far);
		color.a = 0.1f;
		Gizmos.color = color;
		Gizmos.DrawSphere(base.transform.position, Far);
		color.r = 1f;
		color.g = 0f;
		color.b = 1f;
		color.a = 1f;
		Gizmos.color = color;
		Gizmos.DrawWireSphere(base.transform.position, VolumetricRadius);
		color.a = 0.1f;
		Gizmos.color = color;
		Gizmos.DrawSphere(base.transform.position, VolumetricRadius);
		if (RoomReflectionGizmoAS == this)
		{
			bool reflOn = false;
			bool reverbOn = false;
			float width = 1f;
			float height = 1f;
			float length = 1f;
			ONSP_GetGlobalRoomReflectionValues(ref reflOn, ref reverbOn, ref width, ref height, ref length);
			if (Camera.main != null && reflOn)
			{
				color = (Gizmos.color = ((!reverbOn) ? UnityEngine.Color.cyan : UnityEngine.Color.white));
				Gizmos.DrawWireCube(Camera.main.transform.position, new Vector3(width, height, length));
				color.a = 0.1f;
				Gizmos.color = color;
				Gizmos.DrawCube(Camera.main.transform.position, new Vector3(width, height, length));
			}
		}
	}

	private void OnDestroy()
	{
		if (RoomReflectionGizmoAS == this)
		{
			RoomReflectionGizmoAS = null;
		}
	}
}
public class ONSPProfiler : MonoBehaviour
{
	public bool profilerEnabled;

	private const int DEFAULT_PORT = 2121;

	public int port = 2121;

	public const string strONSPS = "AudioPluginOculusSpatializer";

	private void Start()
	{
		Application.runInBackground = true;
	}

	private void Update()
	{
		if (port < 0 || port > 65535)
		{
			port = 2121;
		}
		ONSP_SetProfilerPort(port);
		ONSP_SetProfilerEnabled(profilerEnabled);
	}

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int ONSP_SetProfilerEnabled(bool enabled);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int ONSP_SetProfilerPort(int port);
}
public class ONSPPropagationGeometry : MonoBehaviour
{
	private struct MeshMaterial
	{
		public MeshFilter meshFilter;

		public ONSPPropagationMaterial[] materials;
	}

	private struct TerrainMaterial
	{
		public Terrain terrain;

		public ONSPPropagationMaterial[] materials;
	}

	public string filePathRelative;

	public bool fileEnabled;

	public bool includeChildMeshes = true;

	private IntPtr geometryHandle = IntPtr.Zero;

	public static int OSPSuccess = 0;

	private static int terrainDecimation = 4;

	public string filePath => Application.streamingAssetsPath + "/" + filePathRelative;

	private void Awake()
	{
		CreatePropagationGeometry();
	}

	private void CreatePropagationGeometry()
	{
		AudioSettings.GetConfiguration();
		if (PropIFace.CreateAudioGeometry(out geometryHandle) != OSPSuccess)
		{
			throw new Exception("Unable to create geometry handle");
		}
		if (filePath != null && filePath.Length != 0 && fileEnabled && Application.isPlaying)
		{
			if (!ReadFile())
			{
				UnityEngine.Debug.Log("Failed to read file, attempting to regenerate audio geometry");
				UploadGeometry();
			}
		}
		else
		{
			UploadGeometry();
		}
	}

	private void Update()
	{
		if (!(geometryHandle == IntPtr.Zero))
		{
			Matrix4x4 localToWorldMatrix = base.transform.localToWorldMatrix;
			float[] matrix4x = new float[16]
			{
				localToWorldMatrix[0, 0],
				localToWorldMatrix[1, 0],
				0f - localToWorldMatrix[2, 0],
				localToWorldMatrix[3, 0],
				localToWorldMatrix[0, 1],
				localToWorldMatrix[1, 1],
				0f - localToWorldMatrix[2, 1],
				localToWorldMatrix[3, 1],
				localToWorldMatrix[0, 2],
				localToWorldMatrix[1, 2],
				0f - localToWorldMatrix[2, 2],
				localToWorldMatrix[3, 2],
				localToWorldMatrix[0, 3],
				localToWorldMatrix[1, 3],
				0f - localToWorldMatrix[2, 3],
				localToWorldMatrix[3, 3]
			};
			PropIFace.AudioGeometrySetTransform(geometryHandle, matrix4x);
		}
	}

	private void OnDestroy()
	{
		if (geometryHandle != IntPtr.Zero && PropIFace.DestroyAudioGeometry(geometryHandle) != OSPSuccess)
		{
			throw new Exception("Unable to destroy geometry");
		}
		geometryHandle = IntPtr.Zero;
	}

	private static void traverseMeshHierarchy(GameObject obj, ONSPPropagationMaterial[] currentMaterials, bool includeChildren, List<MeshMaterial> meshMaterials, List<TerrainMaterial> terrainMaterials, bool ignoreStatic)
	{
		if (!obj.activeInHierarchy)
		{
			return;
		}
		MeshFilter[] components = obj.GetComponents<MeshFilter>();
		Terrain[] components2 = obj.GetComponents<Terrain>();
		ONSPPropagationMaterial[] components3 = obj.GetComponents<ONSPPropagationMaterial>();
		if (components3 != null && components3.Length != 0)
		{
			int num = components3.Length;
			if (currentMaterials != null)
			{
				num = Math.Max(num, currentMaterials.Length);
			}
			ONSPPropagationMaterial[] array = new ONSPPropagationMaterial[num];
			if (currentMaterials != null)
			{
				for (int i = components3.Length; i < num; i++)
				{
					array[i] = currentMaterials[i];
				}
			}
			currentMaterials = array;
			for (int j = 0; j < components3.Length; j++)
			{
				currentMaterials[j] = components3[j];
			}
		}
		MeshFilter[] array2 = components;
		foreach (MeshFilter meshFilter in array2)
		{
			Mesh sharedMesh = meshFilter.sharedMesh;
			if (!(sharedMesh == null))
			{
				if (ignoreStatic && !sharedMesh.isReadable)
				{
					UnityEngine.Debug.Log("Mesh: " + meshFilter.gameObject.name + " not readable, cannot be static.");
					continue;
				}
				MeshMaterial item = default(MeshMaterial);
				item.meshFilter = meshFilter;
				item.materials = currentMaterials;
				meshMaterials.Add(item);
			}
		}
		Terrain[] array3 = components2;
		foreach (Terrain terrain in array3)
		{
			TerrainMaterial item2 = default(TerrainMaterial);
			item2.terrain = terrain;
			item2.materials = currentMaterials;
			terrainMaterials.Add(item2);
		}
		if (!includeChildren)
		{
			return;
		}
		foreach (Transform item3 in obj.transform)
		{
			if (item3.GetComponent<ONSPPropagationGeometry>() == null)
			{
				traverseMeshHierarchy(item3.gameObject, currentMaterials, includeChildren, meshMaterials, terrainMaterials, ignoreStatic);
			}
		}
	}

	private int uploadMesh(IntPtr geometryHandle, GameObject meshObject, Matrix4x4 worldToLocal, bool ignoreStatic)
	{
		List<MeshMaterial> list = new List<MeshMaterial>();
		List<TerrainMaterial> list2 = new List<TerrainMaterial>();
		traverseMeshHierarchy(meshObject, null, includeChildMeshes, list, list2, ignoreStatic);
		int num = 0;
		uint num2 = 0u;
		int num3 = 0;
		int num4 = 0;
		foreach (MeshMaterial item in list)
		{
			Mesh sharedMesh = item.meshFilter.sharedMesh;
			num4 += sharedMesh.subMeshCount;
			num += sharedMesh.vertexCount;
			for (int i = 0; i < sharedMesh.subMeshCount; i++)
			{
				MeshTopology topology = sharedMesh.GetTopology(i);
				if (topology == MeshTopology.Triangles || topology == MeshTopology.Quads)
				{
					uint indexCount = sharedMesh.GetIndexCount(i);
					num2 += indexCount;
					switch (topology)
					{
					case MeshTopology.Triangles:
						num3 += (int)indexCount / 3;
						break;
					case MeshTopology.Quads:
						num3 += (int)indexCount / 4;
						break;
					}
				}
			}
		}
		foreach (TerrainMaterial item2 in list2)
		{
			TerrainData terrainData = item2.terrain.terrainData;
			int heightmapWidth = terrainData.heightmapWidth;
			int heightmapHeight = terrainData.heightmapHeight;
			int num5 = (heightmapWidth - 1) / terrainDecimation + 1;
			int num6 = (heightmapHeight - 1) / terrainDecimation + 1;
			int num7 = num5 * num6;
			int num8 = (num5 - 1) * (num6 - 1) * 6;
			num4++;
			num += num7;
			num2 += (uint)num8;
			num3 += num8 / 3;
		}
		List<Vector3> list3 = new List<Vector3>();
		List<int> list4 = new List<int>();
		MeshGroup[] array = new MeshGroup[num4];
		float[] array2 = new float[num * 3];
		int[] array3 = new int[num2];
		int num9 = 0;
		int num10 = 0;
		int num11 = 0;
		foreach (MeshMaterial item3 in list)
		{
			MeshFilter meshFilter = item3.meshFilter;
			Mesh sharedMesh2 = meshFilter.sharedMesh;
			Matrix4x4 matrix4x = worldToLocal * meshFilter.gameObject.transform.localToWorldMatrix;
			list3.Clear();
			sharedMesh2.GetVertices(list3);
			int count = list3.Count;
			for (int j = 0; j < count; j++)
			{
				Vector3 vector = matrix4x.MultiplyPoint3x4(list3[j]);
				int num12 = (num9 + j) * 3;
				array2[num12] = vector.x;
				array2[num12 + 1] = vector.y;
				array2[num12 + 2] = vector.z;
			}
			for (int k = 0; k < sharedMesh2.subMeshCount; k++)
			{
				MeshTopology topology2 = sharedMesh2.GetTopology(k);
				if (topology2 != 0 && topology2 != MeshTopology.Quads)
				{
					continue;
				}
				list4.Clear();
				sharedMesh2.GetIndices(list4, k);
				int count2 = list4.Count;
				for (int l = 0; l < count2; l++)
				{
					array3[num10 + l] = list4[l] + num9;
				}
				switch (topology2)
				{
				case MeshTopology.Triangles:
					array[num11 + k].faceType = FaceType.TRIANGLES;
					array[num11 + k].faceCount = (UIntPtr)(ulong)(count2 / 3);
					break;
				case MeshTopology.Quads:
					array[num11 + k].faceType = FaceType.QUADS;
					array[num11 + k].faceCount = (UIntPtr)(ulong)(count2 / 4);
					break;
				}
				array[num11 + k].indexOffset = (UIntPtr)(ulong)num10;
				if (item3.materials != null && item3.materials.Length != 0)
				{
					int num13 = k;
					if (num13 >= item3.materials.Length)
					{
						num13 = item3.materials.Length - 1;
					}
					item3.materials[num13].StartInternal();
					array[num11 + k].material = item3.materials[num13].materialHandle;
				}
				else
				{
					array[num11 + k].material = IntPtr.Zero;
				}
				num10 += count2;
			}
			num9 += count;
			num11 += sharedMesh2.subMeshCount;
		}
		foreach (TerrainMaterial item4 in list2)
		{
			TerrainData terrainData2 = item4.terrain.terrainData;
			Matrix4x4 matrix4x2 = worldToLocal * item4.terrain.gameObject.transform.localToWorldMatrix;
			int heightmapWidth2 = terrainData2.heightmapWidth;
			int heightmapHeight2 = terrainData2.heightmapHeight;
			float[,] heights = terrainData2.GetHeights(0, 0, heightmapWidth2, heightmapHeight2);
			Vector3 size = terrainData2.size;
			size = new Vector3(size.x / (float)(heightmapWidth2 - 1) * (float)terrainDecimation, size.y, size.z / (float)(heightmapHeight2 - 1) * (float)terrainDecimation);
			int num14 = (heightmapWidth2 - 1) / terrainDecimation + 1;
			int num15 = (heightmapHeight2 - 1) / terrainDecimation + 1;
			int num16 = num14 * num15;
			int num17 = (num14 - 1) * (num15 - 1) * 2;
			array[num11].faceType = FaceType.TRIANGLES;
			array[num11].faceCount = (UIntPtr)(ulong)num17;
			array[num11].indexOffset = (UIntPtr)(ulong)num10;
			if (item4.materials != null && item4.materials.Length != 0)
			{
				item4.materials[0].StartInternal();
				array[num11].material = item4.materials[0].materialHandle;
			}
			else
			{
				array[num11].material = IntPtr.Zero;
			}
			for (int m = 0; m < num15; m++)
			{
				for (int n = 0; n < num14; n++)
				{
					int num18 = (num9 + m * num14 + n) * 3;
					Vector3 vector2 = matrix4x2.MultiplyPoint3x4(Vector3.Scale(size, new Vector3(m, heights[n * terrainDecimation, m * terrainDecimation], n)));
					array2[num18] = vector2.x;
					array2[num18 + 1] = vector2.y;
					array2[num18 + 2] = vector2.z;
				}
			}
			for (int num19 = 0; num19 < num15 - 1; num19++)
			{
				for (int num20 = 0; num20 < num14 - 1; num20++)
				{
					array3[num10] = num9 + num19 * num14 + num20;
					array3[num10 + 1] = num9 + (num19 + 1) * num14 + num20;
					array3[num10 + 2] = num9 + num19 * num14 + num20 + 1;
					array3[num10 + 3] = num9 + (num19 + 1) * num14 + num20;
					array3[num10 + 4] = num9 + (num19 + 1) * num14 + num20 + 1;
					array3[num10 + 5] = num9 + num19 * num14 + num20 + 1;
					num10 += 6;
				}
			}
			num9 += num16;
			num11++;
		}
		return PropIFace.AudioGeometryUploadMeshArrays(geometryHandle, array2, num, array3, array3.Length, array, array.Length);
	}

	public void UploadGeometry()
	{
		if (uploadMesh(geometryHandle, base.gameObject, base.gameObject.transform.worldToLocalMatrix, ignoreStatic: true) != OSPSuccess)
		{
			throw new Exception("Unable to upload audio mesh geometry");
		}
	}

	public bool ReadFile()
	{
		if (filePath == null || filePath.Length == 0)
		{
			UnityEngine.Debug.Log("Invalid mesh file path");
			return false;
		}
		if (PropIFace.AudioGeometryReadMeshFile(geometryHandle, filePath) != OSPSuccess)
		{
			UnityEngine.Debug.Log("Error reading mesh file " + filePath);
			return false;
		}
		return true;
	}
}
public sealed class ONSPPropagationMaterial : MonoBehaviour
{
	public enum Preset
	{
		Custom,
		AcousticTile,
		Brick,
		BrickPainted,
		Carpet,
		CarpetHeavy,
		CarpetHeavyPadded,
		CeramicTile,
		Concrete,
		ConcreteRough,
		ConcreteBlock,
		ConcreteBlockPainted,
		Curtain,
		Foliage,
		Glass,
		GlassHeavy,
		Grass,
		Gravel,
		GypsumBoard,
		PlasterOnBrick,
		PlasterOnConcreteBlock,
		Soil,
		SoundProof,
		Snow,
		Steel,
		Water,
		WoodThin,
		WoodThick,
		WoodFloor,
		WoodOnConcrete
	}

	[Serializable]
	public sealed class Point
	{
		public float frequency;

		public float data;

		public Point(float frequency = 0f, float data = 0f)
		{
			this.frequency = frequency;
			this.data = data;
		}

		public static implicit operator Point(Vector2 v)
		{
			return new Point(v.x, v.y);
		}

		public static implicit operator Vector2(Point point)
		{
			return new Vector2(point.frequency, point.data);
		}
	}

	[Serializable]
	public sealed class Spectrum
	{
		public int selection = int.MaxValue;

		public List<Point> points = new List<Point>();

		public float this[float f]
		{
			get
			{
				if (points.Count > 0)
				{
					Point point = new Point(float.MinValue);
					Point point2 = new Point(float.MaxValue);
					foreach (Point point3 in points)
					{
						if (point3.frequency < f)
						{
							if (point3.frequency > point.frequency)
							{
								point = point3;
							}
						}
						else if (point3.frequency < point2.frequency)
						{
							point2 = point3;
						}
					}
					if (point.frequency == float.MinValue)
					{
						point.data = points.OrderBy((Point p) => p.frequency).First().data;
					}
					if (point2.frequency == float.MaxValue)
					{
						point2.data = points.OrderBy((Point p) => p.frequency).Last().data;
					}
					return point.data + (f - point.frequency) * (point2.data - point.data) / (point2.frequency - point.frequency);
				}
				return 0f;
			}
		}
	}

	public IntPtr materialHandle = IntPtr.Zero;

	[Tooltip("Absorption")]
	public Spectrum absorption = new Spectrum();

	[Tooltip("Transmission")]
	public Spectrum transmission = new Spectrum();

	[Tooltip("Scattering")]
	public Spectrum scattering = new Spectrum();

	[SerializeField]
	private Preset preset_;

	public Preset preset
	{
		get
		{
			return preset_;
		}
		set
		{
			SetPreset(value);
			preset_ = value;
		}
	}

	private void Start()
	{
		StartInternal();
	}

	public void StartInternal()
	{
		if (!(materialHandle != IntPtr.Zero))
		{
			if (PropIFace.CreateAudioMaterial(out materialHandle) != ONSPPropagationGeometry.OSPSuccess)
			{
				throw new Exception("Unable to create internal audio material");
			}
			UploadMaterial();
		}
	}

	private void OnDestroy()
	{
		DestroyInternal();
	}

	public void DestroyInternal()
	{
		if (materialHandle != IntPtr.Zero)
		{
			PropIFace.DestroyAudioMaterial(materialHandle);
			materialHandle = IntPtr.Zero;
		}
	}

	public void UploadMaterial()
	{
		if (materialHandle == IntPtr.Zero)
		{
			return;
		}
		PropIFace.AudioMaterialReset(materialHandle, MaterialProperty.ABSORPTION);
		foreach (Point point in absorption.points)
		{
			PropIFace.AudioMaterialSetFrequency(materialHandle, MaterialProperty.ABSORPTION, point.frequency, point.data);
		}
		PropIFace.AudioMaterialReset(materialHandle, MaterialProperty.TRANSMISSION);
		foreach (Point point2 in transmission.points)
		{
			PropIFace.AudioMaterialSetFrequency(materialHandle, MaterialProperty.TRANSMISSION, point2.frequency, point2.data);
		}
		PropIFace.AudioMaterialReset(materialHandle, MaterialProperty.SCATTERING);
		foreach (Point point3 in scattering.points)
		{
			PropIFace.AudioMaterialSetFrequency(materialHandle, MaterialProperty.SCATTERING, point3.frequency, point3.data);
		}
	}

	public void SetPreset(Preset preset)
	{
		ONSPPropagationMaterial material = this;
		switch (preset)
		{
		case Preset.AcousticTile:
			AcousticTile(ref material);
			break;
		case Preset.Brick:
			Brick(ref material);
			break;
		case Preset.BrickPainted:
			BrickPainted(ref material);
			break;
		case Preset.Carpet:
			Carpet(ref material);
			break;
		case Preset.CarpetHeavy:
			CarpetHeavy(ref material);
			break;
		case Preset.CarpetHeavyPadded:
			CarpetHeavyPadded(ref material);
			break;
		case Preset.CeramicTile:
			CeramicTile(ref material);
			break;
		case Preset.Concrete:
			Concrete(ref material);
			break;
		case Preset.ConcreteRough:
			ConcreteRough(ref material);
			break;
		case Preset.ConcreteBlock:
			ConcreteBlock(ref material);
			break;
		case Preset.ConcreteBlockPainted:
			ConcreteBlockPainted(ref material);
			break;
		case Preset.Curtain:
			Curtain(ref material);
			break;
		case Preset.Foliage:
			Foliage(ref material);
			break;
		case Preset.Glass:
			Glass(ref material);
			break;
		case Preset.GlassHeavy:
			GlassHeavy(ref material);
			break;
		case Preset.Grass:
			Grass(ref material);
			break;
		case Preset.Gravel:
			Gravel(ref material);
			break;
		case Preset.GypsumBoard:
			GypsumBoard(ref material);
			break;
		case Preset.PlasterOnBrick:
			PlasterOnBrick(ref material);
			break;
		case Preset.PlasterOnConcreteBlock:
			PlasterOnConcreteBlock(ref material);
			break;
		case Preset.Soil:
			Soil(ref material);
			break;
		case Preset.SoundProof:
			SoundProof(ref material);
			break;
		case Preset.Snow:
			Snow(ref material);
			break;
		case Preset.Steel:
			Steel(ref material);
			break;
		case Preset.Water:
			Water(ref material);
			break;
		case Preset.WoodThin:
			WoodThin(ref material);
			break;
		case Preset.WoodThick:
			WoodThick(ref material);
			break;
		case Preset.WoodFloor:
			WoodFloor(ref material);
			break;
		case Preset.WoodOnConcrete:
			WoodOnConcrete(ref material);
			break;
		case Preset.Custom:
			break;
		}
	}

	private static void AcousticTile(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.5f),
			new Point(250f, 0.7f),
			new Point(500f, 0.6f),
			new Point(1000f, 0.7f),
			new Point(2000f, 0.7f),
			new Point(4000f, 0.5f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.15f),
			new Point(500f, 0.2f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.25f),
			new Point(4000f, 0.3f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.05f),
			new Point(250f, 0.04f),
			new Point(500f, 0.03f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.005f),
			new Point(4000f, 0.002f)
		};
	}

	private static void Brick(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.02f),
			new Point(250f, 0.02f),
			new Point(500f, 0.03f),
			new Point(1000f, 0.04f),
			new Point(2000f, 0.05f),
			new Point(4000f, 0.07f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.25f),
			new Point(500f, 0.3f),
			new Point(1000f, 0.35f),
			new Point(2000f, 0.4f),
			new Point(4000f, 0.45f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.025f),
			new Point(250f, 0.019f),
			new Point(500f, 0.01f),
			new Point(1000f, 0.0045f),
			new Point(2000f, 0.0018f),
			new Point(4000f, 0.00089f)
		};
	}

	private static void BrickPainted(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.01f),
			new Point(500f, 0.02f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.02f),
			new Point(4000f, 0.03f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.15f),
			new Point(250f, 0.15f),
			new Point(500f, 0.2f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.2f),
			new Point(4000f, 0.25f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.025f),
			new Point(250f, 0.019f),
			new Point(500f, 0.01f),
			new Point(1000f, 0.0045f),
			new Point(2000f, 0.0018f),
			new Point(4000f, 0.00089f)
		};
	}

	private static void Carpet(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.05f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.45f),
			new Point(4000f, 0.65f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.15f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.3f),
			new Point(4000f, 0.45f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void CarpetHeavy(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.02f),
			new Point(250f, 0.06f),
			new Point(500f, 0.14f),
			new Point(1000f, 0.37f),
			new Point(2000f, 0.48f),
			new Point(4000f, 0.63f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.15f),
			new Point(500f, 0.2f),
			new Point(1000f, 0.25f),
			new Point(2000f, 0.35f),
			new Point(4000f, 0.5f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void CarpetHeavyPadded(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.08f),
			new Point(250f, 0.24f),
			new Point(500f, 0.57f),
			new Point(1000f, 0.69f),
			new Point(2000f, 0.71f),
			new Point(4000f, 0.73f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.15f),
			new Point(500f, 0.2f),
			new Point(1000f, 0.25f),
			new Point(2000f, 0.35f),
			new Point(4000f, 0.5f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void CeramicTile(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.01f),
			new Point(500f, 0.01f),
			new Point(1000f, 0.01f),
			new Point(2000f, 0.02f),
			new Point(4000f, 0.02f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.12f),
			new Point(500f, 0.14f),
			new Point(1000f, 0.16f),
			new Point(2000f, 0.18f),
			new Point(4000f, 0.2f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void Concrete(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.01f),
			new Point(500f, 0.02f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.02f),
			new Point(4000f, 0.02f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.11f),
			new Point(500f, 0.12f),
			new Point(1000f, 0.13f),
			new Point(2000f, 0.14f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void ConcreteRough(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.02f),
			new Point(500f, 0.04f),
			new Point(1000f, 0.06f),
			new Point(2000f, 0.08f),
			new Point(4000f, 0.1f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.12f),
			new Point(500f, 0.15f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.25f),
			new Point(4000f, 0.3f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void ConcreteBlock(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.36f),
			new Point(250f, 0.44f),
			new Point(500f, 0.31f),
			new Point(1000f, 0.29f),
			new Point(2000f, 0.39f),
			new Point(4000f, 0.21f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.12f),
			new Point(500f, 0.15f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.3f),
			new Point(4000f, 0.4f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.02f),
			new Point(250f, 0.01f),
			new Point(500f, 0.0063f),
			new Point(1000f, 0.0035f),
			new Point(2000f, 0.00011f),
			new Point(4000f, 0.00063f)
		};
	}

	private static void ConcreteBlockPainted(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.05f),
			new Point(500f, 0.06f),
			new Point(1000f, 0.07f),
			new Point(2000f, 0.09f),
			new Point(4000f, 0.08f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.11f),
			new Point(500f, 0.13f),
			new Point(1000f, 0.15f),
			new Point(2000f, 0.16f),
			new Point(4000f, 0.2f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.02f),
			new Point(250f, 0.01f),
			new Point(500f, 0.0063f),
			new Point(1000f, 0.0035f),
			new Point(2000f, 0.00011f),
			new Point(4000f, 0.00063f)
		};
	}

	private static void Curtain(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.07f),
			new Point(250f, 0.31f),
			new Point(500f, 0.49f),
			new Point(1000f, 0.75f),
			new Point(2000f, 0.7f),
			new Point(4000f, 0.6f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.15f),
			new Point(500f, 0.2f),
			new Point(1000f, 0.3f),
			new Point(2000f, 0.4f),
			new Point(4000f, 0.5f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.42f),
			new Point(250f, 0.39f),
			new Point(500f, 0.21f),
			new Point(1000f, 0.14f),
			new Point(2000f, 0.079f),
			new Point(4000f, 0.045f)
		};
	}

	private static void Foliage(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.03f),
			new Point(250f, 0.06f),
			new Point(500f, 0.11f),
			new Point(1000f, 0.17f),
			new Point(2000f, 0.27f),
			new Point(4000f, 0.31f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.3f),
			new Point(500f, 0.4f),
			new Point(1000f, 0.5f),
			new Point(2000f, 0.7f),
			new Point(4000f, 0.8f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.9f),
			new Point(250f, 0.9f),
			new Point(500f, 0.9f),
			new Point(1000f, 0.8f),
			new Point(2000f, 0.5f),
			new Point(4000f, 0.3f)
		};
	}

	private static void Glass(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.35f),
			new Point(250f, 0.25f),
			new Point(500f, 0.18f),
			new Point(1000f, 0.12f),
			new Point(2000f, 0.07f),
			new Point(4000f, 0.05f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.05f),
			new Point(250f, 0.05f),
			new Point(500f, 0.05f),
			new Point(1000f, 0.05f),
			new Point(2000f, 0.05f),
			new Point(4000f, 0.05f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.125f),
			new Point(250f, 0.089f),
			new Point(500f, 0.05f),
			new Point(1000f, 0.028f),
			new Point(2000f, 0.022f),
			new Point(4000f, 0.079f)
		};
	}

	private static void GlassHeavy(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.18f),
			new Point(250f, 0.06f),
			new Point(500f, 0.04f),
			new Point(1000f, 0.03f),
			new Point(2000f, 0.02f),
			new Point(4000f, 0.02f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.05f),
			new Point(250f, 0.05f),
			new Point(500f, 0.05f),
			new Point(1000f, 0.05f),
			new Point(2000f, 0.05f),
			new Point(4000f, 0.05f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.056f),
			new Point(250f, 0.039f),
			new Point(500f, 0.028f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.032f),
			new Point(4000f, 0.014f)
		};
	}

	private static void Grass(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.11f),
			new Point(250f, 0.26f),
			new Point(500f, 0.6f),
			new Point(1000f, 0.69f),
			new Point(2000f, 0.92f),
			new Point(4000f, 0.99f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.3f),
			new Point(250f, 0.3f),
			new Point(500f, 0.4f),
			new Point(1000f, 0.5f),
			new Point(2000f, 0.6f),
			new Point(4000f, 0.7f)
		};
		material.transmission.points = new List<Point>();
	}

	private static void Gravel(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.25f),
			new Point(250f, 0.6f),
			new Point(500f, 0.65f),
			new Point(1000f, 0.7f),
			new Point(2000f, 0.75f),
			new Point(4000f, 0.8f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.3f),
			new Point(500f, 0.4f),
			new Point(1000f, 0.5f),
			new Point(2000f, 0.6f),
			new Point(4000f, 0.7f)
		};
		material.transmission.points = new List<Point>();
	}

	private static void GypsumBoard(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.29f),
			new Point(250f, 0.1f),
			new Point(500f, 0.05f),
			new Point(1000f, 0.04f),
			new Point(2000f, 0.07f),
			new Point(4000f, 0.09f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.11f),
			new Point(500f, 0.12f),
			new Point(1000f, 0.13f),
			new Point(2000f, 0.14f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.035f),
			new Point(250f, 0.0125f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0025f),
			new Point(2000f, 0.0013f),
			new Point(4000f, 0.0032f)
		};
	}

	private static void PlasterOnBrick(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.02f),
			new Point(500f, 0.02f),
			new Point(1000f, 0.03f),
			new Point(2000f, 0.04f),
			new Point(4000f, 0.05f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.25f),
			new Point(500f, 0.3f),
			new Point(1000f, 0.35f),
			new Point(2000f, 0.4f),
			new Point(4000f, 0.45f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.025f),
			new Point(250f, 0.019f),
			new Point(500f, 0.01f),
			new Point(1000f, 0.0045f),
			new Point(2000f, 0.0018f),
			new Point(4000f, 0.00089f)
		};
	}

	private static void PlasterOnConcreteBlock(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.12f),
			new Point(250f, 0.09f),
			new Point(500f, 0.07f),
			new Point(1000f, 0.05f),
			new Point(2000f, 0.05f),
			new Point(4000f, 0.04f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.25f),
			new Point(500f, 0.3f),
			new Point(1000f, 0.35f),
			new Point(2000f, 0.4f),
			new Point(4000f, 0.45f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.02f),
			new Point(250f, 0.01f),
			new Point(500f, 0.0063f),
			new Point(1000f, 0.0035f),
			new Point(2000f, 0.00011f),
			new Point(4000f, 0.00063f)
		};
	}

	private static void Soil(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.15f),
			new Point(250f, 0.25f),
			new Point(500f, 0.4f),
			new Point(1000f, 0.55f),
			new Point(2000f, 0.6f),
			new Point(4000f, 0.6f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.2f),
			new Point(500f, 0.25f),
			new Point(1000f, 0.4f),
			new Point(2000f, 0.55f),
			new Point(4000f, 0.7f)
		};
		material.transmission.points = new List<Point>();
	}

	private static void SoundProof(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(1000f, 1f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(1000f)
		};
		material.transmission.points = new List<Point>();
	}

	private static void Snow(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.45f),
			new Point(250f, 0.75f),
			new Point(500f, 0.9f),
			new Point(1000f, 0.95f),
			new Point(2000f, 0.95f),
			new Point(4000f, 0.95f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.3f),
			new Point(500f, 0.4f),
			new Point(1000f, 0.5f),
			new Point(2000f, 0.6f),
			new Point(4000f, 0.75f)
		};
		material.transmission.points = new List<Point>();
	}

	private static void Steel(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.05f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.07f),
			new Point(4000f, 0.02f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.1f),
			new Point(4000f, 0.1f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.25f),
			new Point(250f, 0.2f),
			new Point(500f, 0.17f),
			new Point(1000f, 0.089f),
			new Point(2000f, 0.089f),
			new Point(4000f, 0.0056f)
		};
	}

	private static void Water(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.01f),
			new Point(500f, 0.01f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.02f),
			new Point(4000f, 0.03f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.07f),
			new Point(2000f, 0.05f),
			new Point(4000f, 0.05f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.03f),
			new Point(250f, 0.03f),
			new Point(500f, 0.03f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.015f),
			new Point(4000f, 0.01f)
		};
	}

	private static void WoodThin(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.42f),
			new Point(250f, 0.21f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.08f),
			new Point(2000f, 0.06f),
			new Point(4000f, 0.06f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.1f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.125f),
			new Point(500f, 0.079f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.089f),
			new Point(4000f, 0.05f)
		};
	}

	private static void WoodThick(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.19f),
			new Point(250f, 0.14f),
			new Point(500f, 0.09f),
			new Point(1000f, 0.06f),
			new Point(2000f, 0.06f),
			new Point(4000f, 0.05f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.1f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.035f),
			new Point(250f, 0.028f),
			new Point(500f, 0.028f),
			new Point(1000f, 0.028f),
			new Point(2000f, 0.011f),
			new Point(4000f, 0.0071f)
		};
	}

	private static void WoodFloor(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.15f),
			new Point(250f, 0.11f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.07f),
			new Point(2000f, 0.06f),
			new Point(4000f, 0.07f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.1f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.071f),
			new Point(250f, 0.025f),
			new Point(500f, 0.0158f),
			new Point(1000f, 0.0056f),
			new Point(2000f, 0.0035f),
			new Point(4000f, 0.0016f)
		};
	}

	private static void WoodOnConcrete(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.04f),
			new Point(250f, 0.04f),
			new Point(500f, 0.07f),
			new Point(1000f, 0.06f),
			new Point(2000f, 0.06f),
			new Point(4000f, 0.07f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.1f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}
}
public class ONSPVersion : MonoBehaviour
{
	public const string strONSPS = "AudioPluginOculusSpatializer";

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern void ONSP_GetVersion(ref int Major, ref int Minor, ref int Patch);

	private void Awake()
	{
		int Major = 0;
		int Minor = 0;
		int Patch = 0;
		ONSP_GetVersion(ref Major, ref Minor, ref Patch);
		UnityEngine.Debug.Log($"ONSP Version: {Major:F0}.{Minor:F0}.{Patch:F0}");
	}

	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class Control : MonoBehaviour
{
	public PathMagicAnimator pma;

	private void Start()
	{
	}

	private void Update()
	{
		pma.VelocityBias = Input.GetAxis("Horizontal") / 2f;
	}
}
public class VelociraptorController : MonoBehaviour
{
	private Transform thisTransform;

	private Animator anim;

	private Vector3 lastPos;

	private void Start()
	{
		thisTransform = base.transform;
		anim = GetComponent<Animator>();
		lastPos = thisTransform.position;
	}

	private void Update()
	{
		float num = 1f / Time.deltaTime * (lastPos - thisTransform.position).magnitude;
		anim.SetFloat("Velocity", num);
		UnityEngine.Debug.Log(num);
		lastPos = thisTransform.position;
	}
}
[RequireComponent(typeof(PathMagic))]
public class GotoWaypoint : MonoBehaviour
{
	public int requestedWaypoint;

	private PathMagic pathMagic;

	private int lastRequestedWaypoint = -1;

	private float lastRequestedPos;

	private void Start()
	{
		pathMagic = GetComponent<PathMagic>();
		requestedWaypoint = 0;
	}

	private void Update()
	{
		if (lastRequestedWaypoint != requestedWaypoint)
		{
			lastRequestedWaypoint = requestedWaypoint;
			lastRequestedPos = ComputePosForWaypoint(pathMagic, lastRequestedWaypoint);
		}
		pathMagic.CurrentPos = Mathf.Lerp(pathMagic.CurrentPos, lastRequestedPos, 0.1f);
	}

	private float CalcPosForWaypointIndex(PathMagic pm, int index)
	{
		return (float)index / ((float)pm.waypoints.Length - (pm.loop ? 0f : 1f));
	}

	public float ComputePosForWaypoint(PathMagic pm, int waypoint)
	{
		float num = 0f;
		float num2 = 0.0001f;
		if (!pm.presampledPath)
		{
			return CalcPosForWaypointIndex(pm, waypoint);
		}
		int num3 = 0;
		while (pm.WaypointSamples[num3] != waypoint)
		{
			num += pm.SamplesDistances[num3++];
		}
		num /= pm.TotalDistance;
		float num4 = num;
		pm.sampledPositionAndRotationAndVelocityAndWaypointAtPos(num4, out var position, out var rotation, out var velocity, out var waypoint2);
		float num5;
		do
		{
			num5 = Vector3.Distance(position, pm.Waypoints[waypoint].Position);
			num4 += num2;
			if (num4 > 1f)
			{
				num4 = 1f;
			}
			pm.sampledPositionAndRotationAndVelocityAndWaypointAtPos(num4, out position, out rotation, out velocity, out waypoint2);
		}
		while (Vector3.Distance(position, pm.Waypoints[waypoint].Position) <= num5 && num4 < 1f);
		return num4;
	}
}
public class PicoCameraRig : MonoBehaviour
{
	public bool usePerEyeCameras;

	public bool useFixedUpdateForTracking;

	protected bool _skipUpdate;

	protected readonly string trackingSpaceName = "TrackingSpace";

	protected readonly string trackerAnchorName = "TrackerAnchor";

	protected readonly string leftEyeAnchorName = "LeftEyeAnchor";

	protected readonly string centerEyeAnchorName = "CenterEyeAnchor";

	protected readonly string rightEyeAnchorName = "RightEyeAnchor";

	protected readonly string leftHandAnchorName = "LeftHandAnchor";

	protected readonly string rightHandAnchorName = "RightHandAnchor";

	protected readonly string leftControllerAnchorName = "LeftControllerAnchor";

	protected readonly string rightControllerAnchorName = "RightControllerAnchor";

	protected Camera _centerEyeCamera;

	protected Camera _leftEyeCamera;

	protected Camera _rightEyeCamera;

	public Camera leftEyeCamera
	{
		get
		{
			if (!usePerEyeCameras)
			{
				return _centerEyeCamera;
			}
			return _leftEyeCamera;
		}
	}

	public Camera rightEyeCamera
	{
		get
		{
			if (!usePerEyeCameras)
			{
				return _centerEyeCamera;
			}
			return _rightEyeCamera;
		}
	}

	public Transform trackingSpace { get; private set; }

	public Transform leftEyeAnchor { get; private set; }

	public Transform centerEyeAnchor { get; private set; }

	public Transform rightEyeAnchor { get; private set; }

	public Transform leftHandAnchor { get; private set; }

	public Transform rightHandAnchor { get; private set; }

	public Transform leftControllerAnchor { get; private set; }

	public Transform rightControllerAnchor { get; private set; }

	public Transform trackerAnchor { get; private set; }

	private void Awake()
	{
		SetHeight();
	}

	private void SetHeight()
	{
		PlayerPrefs.SetInt("Calibrated", 0);
		PlayerPrefs.SetFloat("PlayerHeight", 1.66f);
		if (PlayerPrefs.GetInt("Calibrated", 0) > 0)
		{
			float @float = PlayerPrefs.GetFloat("PlayerHeight");
			UnityEngine.Debug.LogError("Setting player height to calibrated:" + @float);
			Vector3 localPosition = base.gameObject.transform.localPosition;
			localPosition.y = @float;
			base.gameObject.transform.localPosition = localPosition;
		}
		else
		{
			Vector3 localPosition2 = base.gameObject.transform.localPosition;
			localPosition2.y = 1.66f;
			base.gameObject.transform.localPosition = localPosition2;
			UnityEngine.Debug.LogError("Setting player height to default: 1.66m");
		}
	}

	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class AchievementSample : MonoBehaviour
{
	public Text dataOutput;

	public InputField getDefinitionsByNameInputField;

	public InputField getProgressByNameInputField;

	public InputField unLockInputField;

	public InputField addCountInputField;

	public InputField addFieldsInputField;

	private void Start()
	{
		AchievementCore.RegisterNetwork();
	}

	private void OnDestroy()
	{
		AchievementCore.UnRegisterNetwork();
	}

	private void OnApplicationPause(bool pause)
	{
		if (!pause)
		{
			printOutputLine("Achievement Init");
			achievementInit();
		}
	}

	private void Update()
	{
		Request.RunCallbacks();
	}

	public void AsyncInitialize()
	{
		dataOutput.text = "> ";
		printOutputLine("AsyncInitialize");
		achievementInit();
	}

	public void GetDefinitionsByName()
	{
		dataOutput.text = "> ";
		printOutputLine("GetDefinitionsByName");
		string text = getDefinitionsByNameInputField.text;
		if (text != "")
		{
			string[] achievementNames = text.Split(',');
			getAchievementDefinition(achievementNames);
			getDefinitionsByNameInputField.text = "";
		}
		else
		{
			printOutputLine("Invalid Command");
		}
	}

	public void GetProgressByName()
	{
		dataOutput.text = "> ";
		printOutputLine("GetProgressByName");
		string text = getProgressByNameInputField.text;
		if (text != "")
		{
			string[] achievementNames = text.Split(',');
			getAchievementProgress(achievementNames);
			getProgressByNameInputField.text = "";
		}
		else
		{
			printOutputLine("Invalid Command");
		}
	}

	public void GetAllDefinitions()
	{
		dataOutput.text = "> ";
		printOutputLine("GetAllDefinitions");
		getAchievementAllDefinition();
	}

	public void GetAllProgress()
	{
		dataOutput.text = "> ";
		printOutputLine("GetAllProgress");
		getAchievementAllProgress();
	}

	public void UnLock()
	{
		dataOutput.text = "> ";
		printOutputLine("UnLock");
		string text = unLockInputField.text;
		if (text != "")
		{
			unlockAchievement(text);
			unLockInputField.text = "";
		}
		else
		{
			printOutputLine("Invalid Command");
		}
	}

	public void AddCount()
	{
		dataOutput.text = "> ";
		printOutputLine("AddCount");
		string text = addCountInputField.text;
		if (text != "")
		{
			string[] array = text.Split(',');
			if (array.Length > 1)
			{
				try
				{
					Convert.ToInt64(array[1]);
				}
				catch (Exception)
				{
					printOutputLine("Invalid Command");
					throw;
				}
				addCountAchievement(array[0], array[1]);
				addCountInputField.text = "";
			}
			else
			{
				printOutputLine("Invalid Command");
			}
		}
		else
		{
			printOutputLine("Invalid Command");
		}
	}

	public void AddFields()
	{
		dataOutput.text = "> ";
		printOutputLine("AddFields");
		string text = addFieldsInputField.text;
		if (text != "")
		{
			string[] array = text.Split(',');
			if (array.Length > 1)
			{
				addFieldsAchievement(array[0], array[1]);
				addFieldsInputField.text = "";
			}
			else
			{
				printOutputLine("Invalid Command");
			}
		}
		else
		{
			printOutputLine("Invalid Command");
		}
	}

	private void achievementInit()
	{
		Pvr_UnitySDKAPI.Achievement.Achievements.Init().OnComplete(initAchievementCallback);
	}

	private void getAchievementAllDefinition()
	{
		Pvr_UnitySDKAPI.Achievement.Achievements.GetAllDefinitions().OnComplete(achievementAllDefinitionCallback);
	}

	private void getAchievementAllProgress()
	{
		Pvr_UnitySDKAPI.Achievement.Achievements.GetAllProgress().OnComplete(achievementAllProgressCallback);
	}

	private void addFieldsAchievement(string achievementName, string fields)
	{
		Pvr_UnitySDKAPI.Achievement.Achievements.AddFields(achievementName, fields).OnComplete(achievementFieldsCallback);
	}

	private void addCountAchievement(string achievementName, string count)
	{
		Pvr_UnitySDKAPI.Achievement.Achievements.AddCount(achievementName, Convert.ToInt64(count)).OnComplete(achievementCountCallback);
	}

	private void unlockAchievement(string achievementName)
	{
		Pvr_UnitySDKAPI.Achievement.Achievements.Unlock(achievementName).OnComplete(achievementUnlockCallback);
	}

	private void getAchievementProgress(string[] achievementNames)
	{
		Pvr_UnitySDKAPI.Achievement.Achievements.GetProgressByName(achievementNames).OnComplete(achievementProgressCallback);
	}

	private void getAchievementDefinition(string[] achievementNames)
	{
		Pvr_UnitySDKAPI.Achievement.Achievements.GetDefinitionsByName(achievementNames).OnComplete(achievementDefinitionCallback);
	}

	private void printOutputLine(string newLine)
	{
		dataOutput.text = "> " + newLine + Environment.NewLine + dataOutput.text;
	}

	private void achievementAllDefinitionCallback(Pvr_Message<Pvr_AchievementDefinitionList> msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Received achievement definitions success");
			Pvr_AchievementDefinitionList achievementDefinitions = msg.GetAchievementDefinitions();
			if (achievementDefinitions.HasNextPage)
			{
				Pvr_UnitySDKAPI.Achievement.Achievements.GetNextAchievementDefinitionListPage(achievementDefinitions).OnComplete(achievementAllDefinitionCallback);
			}
			{
				foreach (Pvr_AchievementDefinition item in achievementDefinitions)
				{
					printOutputLine("Bitfield Name: " + item.Name.ToString());
					switch (item.Type)
					{
					case AchievementType.Simple:
						printOutputLine("Achievement Type: Simple");
						break;
					case AchievementType.Bitfield:
						printOutputLine("Achievement Type: Bitfield");
						printOutputLine("Bitfield Length: " + item.BitfieldLength);
						printOutputLine("Target: " + item.Target);
						break;
					case AchievementType.Count:
						printOutputLine("Achievement Type: Count");
						printOutputLine("Target: " + item.Target);
						break;
					default:
						printOutputLine("Achievement Type: Unknown");
						break;
					}
					printOutputLine("Bitfield Title: " + item.Title.ToString());
					printOutputLine("Bitfield Description: " + item.Description.ToString());
					printOutputLine("Bitfield UnlockedDescription: " + item.UnlockedDescription.ToString());
					printOutputLine("Bitfield UnlockedIcon: " + item.UnlockedIcon.ToString());
					printOutputLine("Bitfield LockedIcon: " + item.LockedIcon.ToString());
					printOutputLine("Bitfield IsSecrect: " + item.IsSecrect);
				}
				return;
			}
		}
		printOutputLine("Received achievement definitions error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementAllProgressCallback(Pvr_Message<Pvr_AchievementProgressList> msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Received achievement progress success");
			Pvr_AchievementProgressList achievementProgressList = msg.GetAchievementProgressList();
			if (achievementProgressList.HasNextPage)
			{
				Pvr_UnitySDKAPI.Achievement.Achievements.GetNextAchievementProgressListPage(achievementProgressList).OnComplete(achievementAllProgressCallback);
			}
			{
				foreach (Pvr_AchievementProgress item in achievementProgressList)
				{
					printOutputLine("Current Name: " + item.Name.ToString());
					if (item.IsUnlocked)
					{
						printOutputLine("Achievement Unlocked");
					}
					else
					{
						printOutputLine("Achievement Locked");
					}
					printOutputLine("Current Bitfield: " + item.Bitfield.ToString());
					printOutputLine("Current Count: " + item.Count);
					printOutputLine("Current UnlockTime: " + item.UnlockTime.ToString());
				}
				return;
			}
		}
		printOutputLine("Received achievement progress error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementFieldsCallback(Pvr_Message msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Achievement fields added.");
			return;
		}
		printOutputLine("Received achievement fields add error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementCountCallback(Pvr_Message msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Achievement count added.");
			return;
		}
		printOutputLine("Received achievement count add error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementUnlockCallback(Pvr_Message msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Achievement unlocked");
			return;
		}
		printOutputLine("Received achievement unlock error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementProgressCallback(Pvr_Message<Pvr_AchievementProgressList> msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Received achievement progress success");
			{
				foreach (Pvr_AchievementProgress achievementProgress in msg.GetAchievementProgressList())
				{
					if (achievementProgress.IsUnlocked)
					{
						printOutputLine("Achievement Unlocked");
					}
					else
					{
						printOutputLine("Achievement Locked");
					}
					printOutputLine("Current Bitfield: " + achievementProgress.Bitfield.ToString());
					printOutputLine("Current Count: " + achievementProgress.Count);
				}
				return;
			}
		}
		printOutputLine("Received achievement progress error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementDefinitionCallback(Pvr_Message<Pvr_AchievementDefinitionList> msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Received achievement definitions success");
			{
				foreach (Pvr_AchievementDefinition achievementDefinition in msg.GetAchievementDefinitions())
				{
					switch (achievementDefinition.Type)
					{
					case AchievementType.Simple:
						printOutputLine("Achievement Type: Simple");
						break;
					case AchievementType.Bitfield:
						printOutputLine("Achievement Type: Bitfield");
						printOutputLine("Bitfield Length: " + achievementDefinition.BitfieldLength);
						printOutputLine("Target: " + achievementDefinition.Target);
						break;
					case AchievementType.Count:
						printOutputLine("Achievement Type: Count");
						printOutputLine("Target: " + achievementDefinition.Target);
						break;
					default:
						printOutputLine("Achievement Type: Unknown");
						break;
					}
				}
				return;
			}
		}
		printOutputLine("Received achievement definitions error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void initAchievementCallback(Pvr_Message msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Received init success");
			return;
		}
		printOutputLine("Received init error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void LoginCallback(string LoginInfo)
	{
		UnityEngine.Debug.Log("Received loginCallback:" + LoginInfo);
		printOutputLine("Received loginCallback: " + LoginInfo);
	}
}
public class Pvr_Controller : MonoBehaviour
{
	public enum UserHandNess
	{
		Right,
		Left
	}

	public enum GazeType
	{
		Never,
		DuringMotion,
		Always
	}

	public enum ControllerAxis
	{
		Controller,
		Wrist,
		Elbow,
		Shoulder
	}

	public GameObject controller0;

	public GameObject controller1;

	private static UserHandNess handness;

	public ControllerAxis Axis;

	public GazeType Gazetype;

	[Range(0f, 0.2f)]
	public float ElbowHeight;

	[Range(0f, 0.2f)]
	public float ElbowDepth;

	[Range(0f, 30f)]
	public float PointerTiltAngle = 15f;

	private float mouseX;

	private float mouseY;

	private float mouseZ;

	private Vector3[] inputDirection = new Vector3[2];

	public static Vector3 pointerPosition { get; set; }

	public static Quaternion pointerRotation { get; set; }

	public static Vector3 elbowPosition { get; set; }

	public static Quaternion elbowRotation { get; set; }

	public static Vector3 wristPosition { get; set; }

	public static Quaternion wristRotation { get; set; }

	public static Vector3 shoulderPosition { get; set; }

	public static Quaternion shoulderRotation { get; set; }

	private void Awake()
	{
		Pvr_ControllerManager.PvrServiceStartSuccessEvent += ServiceStartSuccess;
		Pvr_ControllerManager.SetControllerAbilityEvent += CheckControllerState;
		Pvr_ControllerManager.ChangeMainControllerCallBackEvent += MainControllerChanged;
		Pvr_ControllerManager.ChangeHandNessCallBackEvent += HandnessChanged;
	}

	private void Start()
	{
		handness = Controller.UPvr_GetHandNess();
		if (handness == (UserHandNess)(-1))
		{
			handness = UserHandNess.Right;
		}
	}

	private void OnDestroy()
	{
		Pvr_ControllerManager.PvrServiceStartSuccessEvent -= ServiceStartSuccess;
		Pvr_ControllerManager.SetControllerAbilityEvent -= CheckControllerState;
		Pvr_ControllerManager.ChangeMainControllerCallBackEvent -= MainControllerChanged;
		Pvr_ControllerManager.ChangeHandNessCallBackEvent -= HandnessChanged;
	}

	private void MainControllerChanged(string index)
	{
		RefreshHandness();
	}

	private void HandnessChanged(string index)
	{
		RefreshHandness();
	}

	private void ServiceStartSuccess()
	{
		RefreshHandness();
	}

	private void RefreshHandness()
	{
		handness = Controller.UPvr_GetHandNess();
		if (Controller.UPvr_GetMainHandNess() == 1)
		{
			ChangeHandNess();
		}
	}

	private void OnApplicationPause(bool pause)
	{
		if (!pause)
		{
			if (controller0 != null)
			{
				controller0.transform.localScale = Vector3.zero;
			}
			if (controller1 != null)
			{
				controller1.transform.localScale = Vector3.zero;
			}
		}
		Invoke("ShowController", 0.1f * Time.timeScale);
	}

	private void ShowController()
	{
		if (controller0 != null)
		{
			controller0.transform.localScale = Vector3.one;
		}
		if (controller1 != null)
		{
			controller1.transform.localScale = Vector3.one;
		}
	}

	private void CheckControllerState(string data)
	{
		bool num = Convert.ToBoolean(Convert.ToInt16(data.Substring(4, 1)));
		short num2 = Convert.ToInt16(data.Substring(0, 1));
		if (num && num2 == 1)
		{
			RefreshHandness();
		}
	}

	private void Update()
	{
		if (Pvr_UnitySDKManager.SDK.ControllerOnlyrot)
		{
			DoUpdateControler0();
			DoUpdateControler1();
			UpdateControlloerRay();
			return;
		}
		if (Controller.UPvr_GetPreferenceDevice() == 1)
		{
			DoUpdateControler0();
			DoUpdateControler1();
			UpdateControlloerRay();
			return;
		}
		if (controller0 != null)
		{
			controller0.transform.localRotation = Controller.UPvr_GetControllerQUA(0);
			controller0.transform.localPosition = Controller.UPvr_GetControllerPOS(0);
			UpdateControlloerRay(update0: true, update1: false);
		}
		if (controller1 != null)
		{
			controller1.transform.localRotation = Controller.UPvr_GetControllerQUA(1);
			controller1.transform.localPosition = Controller.UPvr_GetControllerPOS(1);
			UpdateControlloerRay(update0: false);
		}
	}

	public static void ChangeHandNess()
	{
		handness = ((handness == UserHandNess.Right) ? UserHandNess.Left : UserHandNess.Right);
	}

	private void DoUpdateControler0()
	{
		SetArmParaToSo((int)handness, (int)Gazetype, ElbowHeight, ElbowDepth, PointerTiltAngle);
		CalcArmModelfromSo(0);
		UpdateControllerDataSO(0);
	}

	private void DoUpdateControler1()
	{
		int hand = ((handness != UserHandNess.Left) ? 1 : 0);
		SetArmParaToSo(hand, (int)Gazetype, ElbowHeight, ElbowDepth, PointerTiltAngle);
		CalcArmModelfromSo(1);
		UpdateControllerDataSO(1);
	}

	private void UpdateControlloerRay(bool update0 = true, bool update1 = true)
	{
		if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
		{
			if (update0 && controller0 != null)
			{
				controller0.GetComponent<Pvr_ControllerModuleInit>().UpdateRay();
			}
			if (update1 && controller1 != null)
			{
				controller1.GetComponent<Pvr_ControllerModuleInit>().UpdateRay();
			}
		}
	}

	private Quaternion UpdateSimulatedFrameParams()
	{
		if (Input.GetKey(KeyCode.LeftShift))
		{
			mouseX += Input.GetAxis("Mouse X") * 5f;
			if (mouseX <= -180f)
			{
				mouseX += 360f;
			}
			else if (mouseX > 180f)
			{
				mouseX -= 360f;
			}
			mouseY -= Input.GetAxis("Mouse Y") * 2.4f;
			mouseY = Mathf.Clamp(mouseY, -80f, 80f);
		}
		else if (Input.GetKey(KeyCode.RightShift))
		{
			mouseZ += Input.GetAxis("Mouse X") * 5f;
			mouseZ = Mathf.Clamp(mouseZ, -80f, 80f);
		}
		return Quaternion.Euler(mouseY, mouseX, mouseZ);
	}

	private void SetArmParaToSo(int hand, int gazeType, float elbowHeight, float elbowDepth, float pointerTiltAngle)
	{
		Controller.UPvr_SetArmModelParameters(hand, gazeType, elbowHeight, elbowDepth, pointerTiltAngle);
	}

	private void CalcArmModelfromSo(int hand)
	{
		float[] array = new float[4];
		float[] array2 = new float[4];
		float[] array3 = new float[3];
		Quaternion quaternion = default(Quaternion);
		quaternion = Controller.UPvr_GetControllerQUA(hand);
		Vector3 vector = Controller.UPvr_GetAngularVelocity(hand);
		array2[0] = quaternion.x;
		array2[1] = quaternion.y;
		array2[2] = quaternion.z;
		array2[3] = quaternion.w;
		array3[0] = vector.x;
		array3[1] = vector.y;
		array3[2] = vector.z;
		if (Gazetype == GazeType.DuringMotion)
		{
			Vector3 b = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation * Vector3.forward;
			b.y = 0f;
			b.Normalize();
			float t = Mathf.Clamp((vector.magnitude - 0.2f) / 45f, 0f, 0.1f);
			inputDirection[hand] = Vector3.Slerp(inputDirection[hand], b, t);
			if (Controller.UPvr_GetKeyLongPressed(hand, Pvr_KeyCode.HOME))
			{
				inputDirection[hand] = default(Vector3);
			}
			Quaternion quaternion2 = Quaternion.FromToRotation(Vector3.forward, inputDirection[hand]);
			array[0] = quaternion2.x;
			array[1] = quaternion2.y;
			array[2] = quaternion2.z;
			array[3] = quaternion2.w;
		}
		else
		{
			array[0] = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.x;
			array[1] = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.y;
			array[2] = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.z;
			array[3] = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.w;
		}
		Controller.UPvr_CalcArmModelParameters(array, array2, array3);
	}

	public void UpdateControllerDataSO(int hand)
	{
		float[] array = new float[4];
		float[] array2 = new float[3];
		Vector3 vector;
		Quaternion localRotation;
		switch (Axis)
		{
		case ControllerAxis.Controller:
			Controller.UPvr_GetPointerPose(array, array2);
			pointerPosition = new Vector3(array2[0], array2[1], array2[2]);
			pointerRotation = new Quaternion(array[0], array[1], array[2], array[3]);
			vector = pointerPosition;
			localRotation = pointerRotation;
			break;
		case ControllerAxis.Wrist:
			Controller.UPvr_GetWristPose(array, array2);
			wristPosition = new Vector3(array2[0], array2[1], array2[2]);
			wristRotation = new Quaternion(array[0], array[1], array[2], array[3]);
			vector = wristPosition;
			localRotation = wristRotation;
			break;
		case ControllerAxis.Elbow:
			Controller.UPvr_GetElbowPose(array, array2);
			elbowPosition = new Vector3(array2[0], array2[1], array2[2]);
			elbowRotation = new Quaternion(array[0], array[1], array[2], array[3]);
			vector = elbowPosition;
			localRotation = elbowRotation;
			break;
		case ControllerAxis.Shoulder:
			Controller.UPvr_GetShoulderPose(array, array2);
			shoulderPosition = new Vector3(array2[0], array2[1], array2[2]);
			shoulderRotation = new Quaternion(array[0], array[1], array[2], array[3]);
			vector = shoulderPosition;
			localRotation = shoulderRotation;
			break;
		default:
			throw new Exception("Invalid FromJoint.");
		}
		if (hand == 0)
		{
			if (controller0 != null)
			{
				if (!Pvr_UnitySDKManager.SDK.HmdOnlyrot)
				{
					controller0.transform.localPosition = vector + Pvr_UnitySDKSensor.Instance.HeadPose.Position;
				}
				else if (Pvr_UnitySDKManager.SDK.TrackingOrigin == TrackingOrigin.FloorLevel)
				{
					controller0.transform.localPosition = vector + Pvr_UnitySDKSensor.Instance.HeadPose.Position;
				}
				else
				{
					controller0.transform.localPosition = vector;
				}
				controller0.transform.localRotation = localRotation;
			}
		}
		else if (controller1 != null)
		{
			if (!Pvr_UnitySDKManager.SDK.HmdOnlyrot)
			{
				controller1.transform.localPosition = vector + Pvr_UnitySDKSensor.Instance.HeadPose.Position;
			}
			else if (Pvr_UnitySDKManager.SDK.TrackingOrigin == TrackingOrigin.FloorLevel)
			{
				controller1.transform.localPosition = vector + Pvr_UnitySDKSensor.Instance.HeadPose.Position;
			}
			else
			{
				controller1.transform.localPosition = vector;
			}
			controller1.transform.localRotation = localRotation;
		}
	}
}
public class Pvr_ControllerDemo : MonoBehaviour
{
	public GameObject HeadSetController;

	public GameObject controller0;

	public GameObject controller1;

	public GameObject cube;

	private Ray ray;

	private GameObject currentController;

	private Transform lastHit;

	private Transform currentHit;

	[SerializeField]
	private Material normat;

	[SerializeField]
	private Material gazemat;

	[SerializeField]
	private Material clickmat;

	private bool noClick;

	private GameObject referenceObj;

	public float rayDefaultLength = 4f;

	private bool isHasController;

	private bool headcontrolmode;

	private RaycastHit hit;

	private GameObject rayLine;

	private GameObject dot;

	private Transform dragObj;

	private float disX;

	private float disY;

	private float disZ;

	private void Start()
	{
		ray = default(Ray);
		hit = default(RaycastHit);
		if (Pvr_UnitySDKManager.SDK.isHasController)
		{
			Pvr_ControllerManager.PvrServiceStartSuccessEvent += ServiceStartSuccess;
			Pvr_ControllerManager.SetControllerStateChangedEvent += ControllerStateListener;
			Pvr_ControllerManager.ControllerStatusChangeEvent += CheckControllerStateForGoblin;
			isHasController = true;
		}
		referenceObj = new GameObject("ReferenceObj");
	}

	private void OnDestroy()
	{
		if (isHasController)
		{
			Pvr_ControllerManager.PvrServiceStartSuccessEvent -= ServiceStartSuccess;
			Pvr_ControllerManager.SetControllerStateChangedEvent -= ControllerStateListener;
			Pvr_ControllerManager.ControllerStatusChangeEvent -= CheckControllerStateForGoblin;
		}
	}

	private void Update()
	{
		if (HeadSetController.activeSelf)
		{
			HeadSetController.transform.parent.localRotation = Quaternion.Euler(Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.eulerAngles.x, Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.eulerAngles.y, 0f);
			HeadSetController.transform.parent.localPosition = Pvr_UnitySDKSensor.Instance.HeadPose.Position;
			ray.direction = HeadSetController.transform.position - HeadSetController.transform.parent.parent.Find("Head").position;
			ray.origin = HeadSetController.transform.parent.parent.Find("Head").position;
			if (Physics.Raycast(ray, out hit))
			{
				if (HeadSetController.name == "SightPointer")
				{
					HeadSetController.transform.localScale = new Vector3(0.09f, 0.09f, 0.09f);
				}
				currentHit = hit.transform;
				if (currentHit != null && lastHit != null && currentHit != lastHit && (bool)lastHit.GetComponent<Pvr_UIGraphicRaycaster>() && lastHit.transform.gameObject.activeInHierarchy && lastHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled)
				{
					lastHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled = false;
				}
				if (currentHit != null && lastHit != null && currentHit == lastHit && (bool)currentHit.GetComponent<Pvr_UIGraphicRaycaster>() && !currentHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled)
				{
					currentHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled = true;
				}
				if (1 << hit.transform.gameObject.layer == LayerMask.GetMask("Water") && !noClick)
				{
					hit.transform.GetComponent<Renderer>().material = gazemat;
				}
				lastHit = hit.transform;
				if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
				{
					HeadSetController.transform.position = hit.point;
					HeadSetController.transform.position -= (hit.point - HeadSetController.transform.parent.parent.Find("Head").position).normalized * 0.02f;
					float num = 0.008f * hit.distance / 4f;
					Mathf.Clamp(num, 0.002f, 0.008f);
					HeadSetController.transform.localScale = new Vector3(num, num, 1f);
				}
			}
			else
			{
				if (HeadSetController.name == "SightPointer")
				{
					HeadSetController.transform.localScale = Vector3.zero;
				}
				if (lastHit != null && 1 << lastHit.transform.gameObject.layer == LayerMask.GetMask("Water"))
				{
					lastHit.transform.GetComponent<Renderer>().material = normat;
				}
				currentHit = null;
				noClick = false;
				if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
				{
					HeadSetController.transform.position = HeadSetController.transform.parent.parent.Find("Head").position + ray.direction.normalized * (0.5f + rayDefaultLength);
					HeadSetController.transform.localScale = new Vector3(0.008f, 0.008f, 1f);
				}
			}
			if ((Input.GetKeyDown(KeyCode.JoystickButton0) || Input.GetMouseButtonDown(0)) && lastHit != null && 1 << lastHit.transform.gameObject.layer == LayerMask.GetMask("Water") && currentHit != null)
			{
				lastHit.transform.GetComponent<Renderer>().material = clickmat;
				noClick = true;
			}
			return;
		}
		if (currentController != null)
		{
			ray.direction = currentController.transform.forward - currentController.transform.up * 0.25f;
			ray.origin = currentController.transform.Find("start").position;
			if (Physics.Raycast(ray, out hit))
			{
				currentHit = hit.transform;
				if (currentHit != null && lastHit != null && currentHit != lastHit && (bool)lastHit.GetComponent<Pvr_UIGraphicRaycaster>() && lastHit.transform.gameObject.activeInHierarchy && lastHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled)
				{
					lastHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled = false;
				}
				if (currentHit != null && lastHit != null && currentHit == lastHit && (bool)currentHit.GetComponent<Pvr_UIGraphicRaycaster>() && !currentHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled)
				{
					currentHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled = true;
				}
				if (1 << hit.transform.gameObject.layer == LayerMask.GetMask("Water"))
				{
					if (!noClick)
					{
						hit.transform.GetComponent<Renderer>().material = gazemat;
					}
					if (Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.TOUCHPAD) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TOUCHPAD) || Input.GetMouseButtonDown(0))
					{
						referenceObj.transform.position = hit.point;
						disX = hit.transform.position.x - referenceObj.transform.position.x;
						disY = hit.transform.position.y - referenceObj.transform.position.y;
						dragObj = hit.transform;
					}
					if ((Controller.UPvr_GetKey(0, Pvr_KeyCode.TOUCHPAD) || Controller.UPvr_GetKey(1, Pvr_KeyCode.TOUCHPAD) || Input.GetMouseButton(0)) && hit.transform == dragObj.transform)
					{
						referenceObj.transform.position = new Vector3(hit.point.x, hit.point.y, hit.transform.position.z);
						dragObj.position = new Vector3(referenceObj.transform.position.x + disX, referenceObj.transform.position.y + disY, hit.transform.position.z);
					}
				}
				lastHit = hit.transform;
				currentController.transform.Find("dot").position = hit.point;
				if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
				{
					float num2 = 0.178f * currentController.transform.Find("dot").localPosition.z / 3.3f;
					Mathf.Clamp(num2, 0.05f, 0.178f);
					currentController.transform.Find("dot").localScale = new Vector3(num2, num2, 1f);
				}
			}
			else
			{
				if (lastHit != null && 1 << lastHit.transform.gameObject.layer == LayerMask.GetMask("Water"))
				{
					lastHit.transform.GetComponent<Renderer>().material = normat;
				}
				currentHit = null;
				noClick = false;
				if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
				{
					currentController.transform.Find("dot").localScale = new Vector3(0.178f, 0.178f, 1f);
				}
			}
		}
		if ((Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.TOUCHPAD) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TOUCHPAD) || Input.GetMouseButtonDown(0)) && lastHit != null && 1 << lastHit.transform.gameObject.layer == LayerMask.GetMask("Water") && currentHit != null)
		{
			lastHit.transform.GetComponent<Renderer>().material = clickmat;
			noClick = true;
		}
	}

	private void ServiceStartSuccess()
	{
		if (Controller.UPvr_GetControllerState(0) == ControllerState.Connected || Controller.UPvr_GetControllerState(1) == ControllerState.Connected)
		{
			HeadSetController.SetActive(value: false);
		}
		else
		{
			HeadSetController.SetActive(value: true);
		}
		if (Controller.UPvr_GetMainHandNess() == 0)
		{
			currentController = controller0;
		}
		if (Controller.UPvr_GetMainHandNess() == 1)
		{
			currentController = controller1;
		}
	}

	private void ControllerStateListener(string data)
	{
		if (Controller.UPvr_GetControllerState(0) == ControllerState.Connected || Controller.UPvr_GetControllerState(1) == ControllerState.Connected)
		{
			HeadSetController.SetActive(value: false);
		}
		else
		{
			HeadSetController.SetActive(value: true);
		}
		if (Controller.UPvr_GetMainHandNess() == 0)
		{
			currentController = controller0;
		}
		if (Controller.UPvr_GetMainHandNess() == 1)
		{
			currentController = controller1;
		}
	}

	private void CheckControllerStateForGoblin(string state)
	{
		HeadSetController.SetActive(Convert.ToInt16(state) != 1);
	}

	public void SwitchControlMode()
	{
	}
}
public class Pvr_ControllerEventsExamples : MonoBehaviour
{
	private void Start()
	{
		if (!(GetComponent<Pvr_UIPointer>() == null))
		{
			GetComponent<Pvr_UIPointer>().UIPointerElementEnter += UIPointerElementEnter;
			GetComponent<Pvr_UIPointer>().UIPointerElementExit += UIPointerElementExit;
			GetComponent<Pvr_UIPointer>().UIPointerElementClick += UIPointerElementClick;
			GetComponent<Pvr_UIPointer>().UIPointerElementDragStart += UIPointerElementDragStart;
			GetComponent<Pvr_UIPointer>().UIPointerElementDragEnd += UIPointerElementDragEnd;
		}
	}

	private void UIPointerElementEnter(object sender, UIPointerEventArgs e)
	{
		PLOG.I("UI Pointer entered" + e.currentTarget.name);
	}

	private void UIPointerElementExit(object sender, UIPointerEventArgs e)
	{
		PLOG.I("UI Pointer exited" + e.currentTarget.name);
	}

	private void UIPointerElementClick(object sender, UIPointerEventArgs e)
	{
		PLOG.I("UI Pointer clicked" + e.currentTarget.name);
	}

	private void UIPointerElementDragStart(object sender, UIPointerEventArgs e)
	{
		PLOG.I("UI Pointer started dragging" + e.currentTarget.name);
	}

	private void UIPointerElementDragEnd(object sender, UIPointerEventArgs e)
	{
		PLOG.I("UI Pointer stopped dragging" + e.currentTarget.name);
	}
}
public class Pvr_ControllerInit : MonoBehaviour
{
	private ControllerVariety Variety;

	private bool isCustomModel;

	[SerializeField]
	private GameObject goblin;

	[SerializeField]
	private GameObject g2;

	[SerializeField]
	private GameObject neo2L;

	[SerializeField]
	private GameObject neo2R;

	[SerializeField]
	private GameObject neo3L;

	[SerializeField]
	private GameObject neo3R;

	[SerializeField]
	private Material standardMat;

	[SerializeField]
	private Material unlitMat;

	private int controllerType = -1;

	[HideInInspector]
	public bool loadModelSuccess;

	private int systemOrUnity;

	private JsonData curControllerData;

	private string modelName = "";

	private string texFormat = "";

	private string prePath = "";

	private string modelFilePath = "/system/media/PvrRes/controller/";

	private const string goblinTexbasePath = "Controller/controller1/controller1";

	private const string g2TexbasePath = "Controller/controller3/controller3";

	private const string neo2TexbasePath = "Controller/controller4/controller4";

	private const string neo3TexbasePath = "Controller/controller5/controller5";

	private void Awake()
	{
		Render.UPvr_GetIntConfig(15, ref systemOrUnity);
		Variety = base.transform.GetComponentInParent<Pvr_ControllerModuleInit>().Variety;
		isCustomModel = base.transform.GetComponentInParent<Pvr_ControllerModuleInit>().IsCustomModel;
		if (!isCustomModel)
		{
			Pvr_ControllerManager.PvrServiceStartSuccessEvent += ServiceStartSuccess;
			Pvr_ControllerManager.SetControllerAbilityEvent += CheckControllerStateOfAbility;
			Pvr_ControllerManager.ControllerStatusChangeEvent += CheckControllerStateForGoblin;
		}
	}

	private void OnDestroy()
	{
		Pvr_ControllerManager.PvrServiceStartSuccessEvent -= ServiceStartSuccess;
		Pvr_ControllerManager.SetControllerAbilityEvent -= CheckControllerStateOfAbility;
		Pvr_ControllerManager.ControllerStatusChangeEvent -= CheckControllerStateForGoblin;
	}

	private void OnApplicationPause(bool pause)
	{
		if (pause)
		{
			DestroyLocalController();
		}
	}

	private void ServiceStartSuccess()
	{
		int num = Controller.UPvr_GetDeviceType();
		if (controllerType != num && num != 0)
		{
			controllerType = num;
		}
		LoadResFromJson();
		if (Pvr_ControllerManager.controllerlink.neoserviceStarted)
		{
			if (Variety == ControllerVariety.Controller0)
			{
				if (Pvr_ControllerManager.controllerlink.controller0Connected)
				{
					StartCoroutine(RefreshController(0));
				}
				else
				{
					DestroyLocalController();
				}
			}
			if (Variety == ControllerVariety.Controller1)
			{
				if (Pvr_ControllerManager.controllerlink.controller1Connected)
				{
					StartCoroutine(RefreshController(1));
				}
				else
				{
					DestroyLocalController();
				}
			}
		}
		if (Pvr_ControllerManager.controllerlink.goblinserviceStarted && Variety == ControllerVariety.Controller0)
		{
			if (Pvr_ControllerManager.controllerlink.controller0Connected)
			{
				StartCoroutine(RefreshController(0));
			}
			else
			{
				DestroyLocalController();
			}
		}
	}

	private void LoadResFromJson()
	{
		string text = Pvr_UnitySDKAPI.System.UPvr_GetObjectOrArray("config.controller", 7);
		if (text != null)
		{
			JsonData jsonData = JsonMapper.ToObject(text);
			if (controllerType >= 0 && jsonData.Count >= controllerType)
			{
				curControllerData = jsonData[controllerType - 1];
				modelFilePath = (string)curControllerData["base_path"];
				modelName = (string)curControllerData["model_name"] + "_sys";
			}
		}
		else
		{
			PLOG.E("PvrLog LoadJsonFromSystem Error");
		}
	}

	private void CheckControllerStateForGoblin(string state)
	{
		int num = Controller.UPvr_GetDeviceType();
		if (Variety != 0)
		{
			return;
		}
		if (Convert.ToInt16(state) == 1)
		{
			if (controllerType != num)
			{
				DestroySysController();
				controllerType = num;
			}
			StartCoroutine(RefreshController(0));
		}
		else
		{
			DestroyLocalController();
		}
	}

	private void CheckControllerStateOfAbility(string data)
	{
		bool num = Convert.ToBoolean(Convert.ToInt16(data.Substring(4, 1)));
		short num2 = Convert.ToInt16(data.Substring(0, 1));
		int num3 = Controller.UPvr_GetDeviceType();
		if (num)
		{
			controllerType = num3;
			switch (num2)
			{
			case 0:
				if (Variety == ControllerVariety.Controller0)
				{
					StartCoroutine(RefreshController(0));
				}
				break;
			case 1:
				if (Variety == ControllerVariety.Controller1)
				{
					StartCoroutine(RefreshController(1));
				}
				break;
			}
			return;
		}
		switch (num2)
		{
		case 0:
			if (Variety == ControllerVariety.Controller0)
			{
				DestroyLocalController();
			}
			break;
		case 1:
			if (Variety == ControllerVariety.Controller1)
			{
				DestroyLocalController();
			}
			break;
		}
	}

	private void DestroyLocalController()
	{
		foreach (Transform item in base.transform)
		{
			UnityEngine.Object.Destroy(item.gameObject);
			loadModelSuccess = false;
		}
	}

	private void DestroySysController()
	{
		foreach (Transform item in base.transform)
		{
			if (item.name == modelName)
			{
				UnityEngine.Object.Destroy(item.gameObject);
				loadModelSuccess = false;
			}
		}
	}

	private IEnumerator RefreshController(int id)
	{
		yield return null;
		yield return null;
		if (Controller.UPvr_GetControllerState(id) != ControllerState.Connected)
		{
			yield break;
		}
		if (systemOrUnity == 0)
		{
			LoadControllerFromPrefab();
			if (!loadModelSuccess)
			{
				LoadControllerFromSystem(id);
			}
		}
		else
		{
			bool flag = false;
			foreach (Transform item in base.transform)
			{
				if (item.name == modelName)
				{
					flag = true;
				}
			}
			if (!flag)
			{
				LoadControllerFromSystem(id);
				if (!loadModelSuccess)
				{
					LoadControllerFromPrefab();
				}
			}
			else
			{
				base.transform.Find(modelName).gameObject.SetActive(value: true);
			}
		}
		Pvr_ToolTips.RefreshTips();
		PLOG.I("PvrLog Controller Refresh Success");
	}

	private void LoadControllerFromPrefab()
	{
		switch (controllerType)
		{
		case 1:
		{
			Pvr_ControllerVisual pvr_ControllerVisual3 = UnityEngine.Object.Instantiate(goblin, base.transform, worldPositionStays: false).AddComponent<Pvr_ControllerVisual>();
			pvr_ControllerVisual3.currentDevice = ControllerDevice.Goblin;
			LoadTexture(pvr_ControllerVisual3, "Controller/controller1/controller1", fromRes: true);
			loadModelSuccess = true;
			break;
		}
		case 3:
		{
			Pvr_ControllerVisual pvr_ControllerVisual2 = UnityEngine.Object.Instantiate(g2, base.transform, worldPositionStays: false).AddComponent<Pvr_ControllerVisual>();
			pvr_ControllerVisual2.currentDevice = ControllerDevice.G2;
			LoadTexture(pvr_ControllerVisual2, "Controller/controller3/controller3", fromRes: true);
			loadModelSuccess = true;
			break;
		}
		case 4:
		{
			Pvr_ControllerVisual pvr_ControllerVisual4 = UnityEngine.Object.Instantiate((Variety == ControllerVariety.Controller0) ? neo2L : neo2R, base.transform, worldPositionStays: false).AddComponent<Pvr_ControllerVisual>();
			pvr_ControllerVisual4.currentDevice = ControllerDevice.Neo2;
			LoadTexture(pvr_ControllerVisual4, "Controller/controller4/controller4", fromRes: true);
			loadModelSuccess = true;
			break;
		}
		case 5:
		{
			Pvr_ControllerVisual pvr_ControllerVisual = UnityEngine.Object.Instantiate((Variety == ControllerVariety.Controller0) ? neo3L : neo3R, base.transform, worldPositionStays: false).AddComponent<Pvr_ControllerVisual>();
			pvr_ControllerVisual.currentDevice = ControllerDevice.Neo3;
			LoadTexture(pvr_ControllerVisual, "Controller/controller5/controller5", fromRes: true);
			loadModelSuccess = true;
			break;
		}
		default:
			loadModelSuccess = false;
			break;
		}
	}

	private void LoadControllerFromSystem(int id)
	{
		string text = controllerType.ToString() + id + ".obj";
		string text2 = modelFilePath + text;
		if (!File.Exists(text2))
		{
			PLOG.I("PvrLog Obj File does not exist==" + text2);
			return;
		}
		GameObject gameObject = new GameObject();
		gameObject.name = modelName;
		gameObject.AddComponent<MeshFilter>().mesh = Pvr_ObjImporter.Instance.ImportFile(text2);
		gameObject.transform.SetParent(base.transform);
		gameObject.transform.localPosition = Vector3.zero;
		gameObject.AddComponent<MeshRenderer>().material = (((int)curControllerData["material_type"] == 0) ? standardMat : unlitMat);
		loadModelSuccess = true;
		Pvr_ControllerVisual pvr_ControllerVisual = gameObject.AddComponent<Pvr_ControllerVisual>();
		switch (controllerType)
		{
		case 1:
			pvr_ControllerVisual.currentDevice = ControllerDevice.Goblin;
			break;
		case 3:
			pvr_ControllerVisual.currentDevice = ControllerDevice.G2;
			break;
		case 4:
			pvr_ControllerVisual.currentDevice = ControllerDevice.Neo2;
			break;
		case 5:
			pvr_ControllerVisual.currentDevice = ControllerDevice.Neo3;
			break;
		default:
			pvr_ControllerVisual.currentDevice = ControllerDevice.NewController;
			break;
		}
		pvr_ControllerVisual.variety = Variety;
		LoadTexture(pvr_ControllerVisual, controllerType.ToString() + id, fromRes: false);
		gameObject.transform.localRotation = Quaternion.Euler(new Vector3(0f, 180f, 0f));
		gameObject.transform.localScale = new Vector3(-0.01f, 0.01f, 0.01f);
	}

	private void LoadTexture(Pvr_ControllerVisual visual, string controllerName, bool fromRes)
	{
		if (fromRes)
		{
			texFormat = "";
			prePath = controllerName;
		}
		else
		{
			texFormat = "." + (string)curControllerData["tex_format"];
			prePath = modelFilePath + controllerName;
		}
		string filepath = prePath + "_idle" + texFormat;
		visual.m_idle = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_app" + texFormat;
		visual.m_app = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_home" + texFormat;
		visual.m_home = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_touch" + texFormat;
		visual.m_touchpad = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_volume_down" + texFormat;
		visual.m_volDn = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_volume_up" + texFormat;
		visual.m_volUp = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_trigger" + texFormat;
		visual.m_trigger = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_a" + texFormat;
		visual.m_a = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_b" + texFormat;
		visual.m_b = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_x" + texFormat;
		visual.m_x = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_y" + texFormat;
		visual.m_y = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_grip" + texFormat;
		visual.m_grip = LoadOneTexture(filepath, fromRes);
	}

	private Texture2D LoadOneTexture(string filepath, bool fromRes)
	{
		if (fromRes)
		{
			return Resources.Load<Texture2D>(filepath);
		}
		int width = (int)curControllerData["tex_width"];
		int height = (int)curControllerData["tex_height"];
		Texture2D texture2D = new Texture2D(width, height);
		texture2D.LoadImage(ReadPNG(filepath));
		return texture2D;
	}

	private byte[] ReadPNG(string path)
	{
		FileStream fileStream = new FileStream(path, FileMode.Open, FileAccess.Read);
		fileStream.Seek(0L, SeekOrigin.Begin);
		byte[] array = new byte[fileStream.Length];
		fileStream.Read(array, 0, (int)fileStream.Length);
		fileStream.Close();
		fileStream.Dispose();
		fileStream = null;
		return array;
	}
}
public class Pvr_ControllerLink
{
	public AndroidJavaClass javaHummingbirdClass;

	public AndroidJavaClass javaPico2ReceiverClass;

	public AndroidJavaClass javaserviceClass;

	public AndroidJavaClass javavractivityclass;

	public AndroidJavaClass javaCVClass;

	public AndroidJavaObject activity;

	public string gameobjname = "";

	public bool picoDevice;

	public string hummingBirdMac;

	public int hummingBirdRSSI;

	public bool goblinserviceStarted;

	public bool neoserviceStarted;

	public bool controller0Connected;

	public bool controller1Connected;

	public int mainHandID;

	public Pvr_Controller.UserHandNess handness;

	public int controllerType;

	public ControllerHand Controller0;

	public ControllerHand Controller1;

	public int platFormType = -1;

	public int trackingmode = -1;

	public int systemProp = -1;

	public int enablehand6dofbyhead = -1;

	public bool switchHomeKey = true;

	private int iPhoneHMDModeEnabled;

	private float[] hbPoseData = new float[4];

	private float[] sensorData = new float[28];

	private int[] keyData = new int[134];

	private int[] neo3TouchValue = new int[15];

	private float[] fixedState = new float[7] { 0f, 0f, 0f, 1f, 0f, 0f, 0f };

	private float[] neoposeData = new float[7] { 0f, 0f, 0f, 1f, 0f, 0f, 0f };

	private int[] goblinKeyArray = new int[47];

	private int[] neoKeyArray = new int[67];

	private int[] neotriggerV = new int[9];

	private float[] velocity = new float[3];

	private float[] angularVelocity = new float[3];

	private float[] acceData = new float[3];

	public Pvr_ControllerLink(string name)
	{
		gameobjname = name;
		hummingBirdMac = "";
		hummingBirdRSSI = 0;
		UnityEngine.Debug.Log("PvrLog Controller GameObject:" + gameobjname);
		StartHummingBirdService();
		Controller0 = new ControllerHand();
		Controller0.Position = new Vector3(0f, Pvr_UnitySDKSensor.Instance.HeadPose.Position.y, 0f) + new Vector3(-0.1f, -0.3f, 0.3f);
		Controller1 = new ControllerHand();
		Controller1.Position = new Vector3(0f, Pvr_UnitySDKSensor.Instance.HeadPose.Position.y, 0f) + new Vector3(0.1f, -0.3f, 0.3f);
	}

	private void StartHummingBirdService()
	{
		try
		{
			AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
			activity = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
			javaHummingbirdClass = new AndroidJavaClass("com.picovr.picovrlib.hummingbirdclient.HbClientActivity");
			javaCVClass = new AndroidJavaClass("com.picovr.picovrlib.cvcontrollerclient.ControllerClient");
			javavractivityclass = new AndroidJavaClass("com.psmart.vrlib.VrActivity");
			javaserviceClass = new AndroidJavaClass("com.picovr.picovrlib.hummingbirdclient.UnityClient");
			Pvr_UnitySDKAPI.System.Pvr_SetInitActivity(activity.GetRawObject(), javaHummingbirdClass.GetRawClass());
			Render.UPvr_GetIntConfig(4, ref platFormType);
			UnityEngine.Debug.Log("PvrLog platform" + platFormType);
			Render.UPvr_GetIntConfig(5, ref trackingmode);
			UnityEngine.Debug.Log("PvrLog trackingmode" + trackingmode);
			systemProp = GetSysproc();
			UnityEngine.Debug.Log("PvrLog systemProp" + systemProp);
			Render.UPvr_GetIntConfig(7, ref enablehand6dofbyhead);
			UnityEngine.Debug.Log("PvrLog enablehand6dofbyhead" + enablehand6dofbyhead);
			if (trackingmode == 0 || trackingmode == 1 || ((trackingmode == 3 || trackingmode == 5 || trackingmode == 6) && (systemProp == 1 || systemProp == 3)))
			{
				picoDevice = platFormType != 0;
				javaPico2ReceiverClass = new AndroidJavaClass("com.picovr.picovrlib.hummingbirdclient.HbClientReceiver");
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaPico2ReceiverClass, "startReceiver", activity, gameobjname);
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "setPlatformType", platFormType);
			}
			else
			{
				picoDevice = true;
				SetGameObjectToJar(gameobjname);
			}
			Render.UPvr_GetIntConfig(16, ref iPhoneHMDModeEnabled);
			if (iPhoneHMDModeEnabled == 1)
			{
				BindService();
			}
			else if (IsServiceExisted())
			{
				BindService();
			}
		}
		catch (AndroidJavaException ex)
		{
			PLOG.E("ConnectToAndriod--catch" + ex.Message);
		}
	}

	public bool IsServiceExisted()
	{
		bool result = false;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaserviceClass, "isServiceExisted", activity, trackingmode);
		UnityEngine.Debug.Log("PvrLog ServiceExisted ?" + result);
		return result;
	}

	public void SetGameObjectToJar(string name)
	{
		UnityEngine.Debug.Log("PvrLog SetGameObjectToJar " + name);
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setGameObjectCallback", name);
	}

	public void BindService()
	{
		UnityEngine.Debug.Log("PvrLog Bind Service");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaserviceClass, "bindService", activity, trackingmode);
	}

	public void UnBindService()
	{
		UnityEngine.Debug.Log("PvrLog UnBind Service");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaserviceClass, "unbindService", activity, trackingmode);
	}

	public void StopLark2Receiver()
	{
		UnityEngine.Debug.Log("PvrLog StopLark2Receiver");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaPico2ReceiverClass, "stopReceiver", activity);
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaPico2ReceiverClass, "stopOnBootReceiver", activity);
	}

	public void StartLark2Receiver()
	{
		UnityEngine.Debug.Log("PvrLog StartLark2Receiver");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaPico2ReceiverClass, "startReceiver", activity, gameobjname);
	}

	public void StopLark2Service()
	{
		UnityEngine.Debug.Log("PvrLog StopLark2Service");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaPico2ReceiverClass, "stopReceiver", activity);
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "unbindHbService", activity);
	}

	public void StartLark2Service()
	{
		UnityEngine.Debug.Log("PvrLog StartLark2Service");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaPico2ReceiverClass, "startReceiver", activity, gameobjname);
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "bindHbService", activity);
	}

	public int getHandness()
	{
		int result = -1;
		if (iPhoneHMDModeEnabled == 0)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javavractivityclass, "getPvrHandness", activity);
		}
		else
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getHbHandednessInSP");
		}
		PLOG.I("PvrLog GetHandness =" + result);
		return result;
	}

	public void setHandness(int hand)
	{
		PLOG.I("PvrLog SetHandness =" + hand);
		if (iPhoneHMDModeEnabled == 1)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "setHbHandednessInSP", hand);
		}
	}

	public void StartScan()
	{
		PLOG.I("PvrLog ScanHBController");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "scanHbDevice", true);
	}

	public void StopScan()
	{
		PLOG.I("PvrLog StopScanHBController");
		if (iPhoneHMDModeEnabled == 0)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "scanHbDevice", false);
		}
	}

	public int GetSysproc()
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaserviceClass, "getSysproc");
		PLOG.I("PvrLog GetSysproc" + result);
		return result;
	}

	public void ResetController(int num)
	{
		UnityEngine.Debug.Log("PvrLog ResetController" + num);
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "resetControllerSensorState", num);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "resetHbSensorState");
		}
	}

	public void ConnectBLE()
	{
		UnityEngine.Debug.Log("PvrLog ConnectHBController" + hummingBirdMac);
		if (hummingBirdMac != "")
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "connectHbController", hummingBirdMac);
		}
	}

	public void DisConnectBLE()
	{
		UnityEngine.Debug.Log("PvrLog DisConnectHBController");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "disconnectHbController");
	}

	public bool StartUpgrade()
	{
		UnityEngine.Debug.Log("PvrLog StartUpgradeHBController");
		bool result = false;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "startUpgrade");
		return result;
	}

	public void setBinPath(string path, bool isasset)
	{
		UnityEngine.Debug.Log("PvrLog setBinPath" + path + isasset);
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "setBinPath", path, isasset);
	}

	public string GetBLEImageType()
	{
		string result = "";
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getBLEImageType");
		}
		UnityEngine.Debug.Log("PvrLog GetBLEImageType" + result);
		return result;
	}

	public long GetBLEVersion()
	{
		long result = 0L;
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getBLEVersion");
		}
		UnityEngine.Debug.Log("PvrLog GetBLEVersion" + result);
		return result;
	}

	public string GetFileImageType()
	{
		string result = "";
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getFileImageType");
		}
		UnityEngine.Debug.Log("PvrLog GetFileImageType" + result);
		return result;
	}

	public long GetFileVersion()
	{
		long result = 0L;
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getFileVersion");
		}
		UnityEngine.Debug.Log("PvrLog GetFileVersion" + result);
		return result;
	}

	public int GetControllerConnectionState(int num)
	{
		int result = -1;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerConnectionState", num);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getHbConnectionState");
		}
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog GetControllerState:" + num + "state:" + result);
		}
		return result;
	}

	public void RebackToLauncher()
	{
		UnityEngine.Debug.Log("PvrLog RebackToLauncher");
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "startLauncher");
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "startLauncher");
		}
	}

	public void TurnUpVolume()
	{
		UnityEngine.Debug.Log("PvrLog TurnUpVolume");
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "turnUpVolume", activity);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "turnUpVolume", activity);
		}
	}

	public void TurnDownVolume()
	{
		UnityEngine.Debug.Log("PvrLog TurnDownVolume");
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "turnDownVolume", activity);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "turnDownVolume", activity);
		}
	}

	public float[] GetHBControllerPoseData()
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref hbPoseData, javaHummingbirdClass, "getHBSensorPose");
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog HBControllerData" + hbPoseData[0] + "," + hbPoseData[1] + "," + hbPoseData[2] + "," + hbPoseData[3]);
		}
		return hbPoseData;
	}

	public float[] GetControllerSensorData()
	{
		if (enablehand6dofbyhead == 1)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref sensorData, javaCVClass, "getControllerDataInfoBySharmem", Pvr_UnitySDKManager.SDK.headData);
		}
		else
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref sensorData, javaCVClass, "getControllerDataInfoBySharmem");
		}
		return sensorData;
	}

	public int[] GetControllerKeyData()
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref keyData, javaCVClass, "getDoubleControllerKeyEventUnityExtBySharmem");
		return keyData;
	}

	public int[] GetNeo3TouchData(int hand)
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref neo3TouchValue, javaCVClass, "getControllerTouchEvent", hand);
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog Neo3Touch hand:" + hand + "-" + neo3TouchValue[0] + neo3TouchValue[1] + neo3TouchValue[2] + neo3TouchValue[3] + neo3TouchValue[4] + "," + neo3TouchValue[5] + neo3TouchValue[6] + neo3TouchValue[7] + neo3TouchValue[8] + neo3TouchValue[9] + "," + neo3TouchValue[10] + neo3TouchValue[11] + neo3TouchValue[12] + neo3TouchValue[13] + neo3TouchValue[14]);
		}
		return neo3TouchValue;
	}

	public int GetNeo3GripValue(int hand)
	{
		int result = 0;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerGripValue", hand);
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog Neo3GripValue:" + result);
		}
		return result;
	}

	public float[] GetControllerFixedSensorState(int hand)
	{
		if (trackingmode == 2 || trackingmode == 3)
		{
			return fixedState;
		}
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref fixedState, javaCVClass, "getControllerFixedSensorState", hand);
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog GetControllerFixedSensorState " + hand + "Rotation:" + fixedState[0] + "," + fixedState[1] + "," + fixedState[2] + "," + fixedState[3] + "Position:" + fixedState[4] + "," + fixedState[5] + "," + fixedState[6]);
		}
		return fixedState;
	}

	public float[] GetCvControllerPoseData(int hand)
	{
		if (enablehand6dofbyhead == 1)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref neoposeData, javaCVClass, "getControllerSensorState", hand, Pvr_UnitySDKManager.SDK.headData);
		}
		else
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref neoposeData, javaCVClass, "getControllerSensorState", hand);
		}
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog CVControllerData :" + neoposeData[0] + "," + neoposeData[1] + "," + neoposeData[2] + "," + neoposeData[3] + "," + neoposeData[4] + "," + neoposeData[5] + "," + neoposeData[6]);
		}
		return neoposeData;
	}

	public int[] GetHBControllerKeyData()
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref goblinKeyArray, javaHummingbirdClass, "getHBKeyEventUnityExt");
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog HBControllerKey" + goblinKeyArray[0] + goblinKeyArray[1] + goblinKeyArray[2] + goblinKeyArray[3] + goblinKeyArray[4] + "," + goblinKeyArray[5] + goblinKeyArray[6] + goblinKeyArray[7] + goblinKeyArray[8] + goblinKeyArray[9] + "," + goblinKeyArray[10] + goblinKeyArray[11] + goblinKeyArray[12] + goblinKeyArray[13] + goblinKeyArray[14] + "," + goblinKeyArray[15] + goblinKeyArray[16] + goblinKeyArray[17] + goblinKeyArray[18] + goblinKeyArray[19] + "," + goblinKeyArray[20] + goblinKeyArray[21] + goblinKeyArray[22] + goblinKeyArray[23] + goblinKeyArray[24] + "," + goblinKeyArray[25] + goblinKeyArray[26] + goblinKeyArray[27] + goblinKeyArray[28] + goblinKeyArray[29] + "," + goblinKeyArray[30] + goblinKeyArray[31] + goblinKeyArray[32] + goblinKeyArray[33] + goblinKeyArray[34] + "," + goblinKeyArray[35] + goblinKeyArray[36] + goblinKeyArray[37] + goblinKeyArray[38] + goblinKeyArray[39] + "," + goblinKeyArray[40] + goblinKeyArray[41] + goblinKeyArray[42] + goblinKeyArray[43] + goblinKeyArray[44] + "," + goblinKeyArray[45] + goblinKeyArray[46]);
		}
		return goblinKeyArray;
	}

	public int GetHBKeyValue()
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getTriggerKeyEvent");
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog GoblinControllerTriggerKey:" + result);
		}
		return result;
	}

	public int[] GetCvControllerKeyData(int hand)
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref neoKeyArray, javaCVClass, "getControllerKeyEventUnityExt", hand);
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog CVControllerKey hand:" + hand + "-" + neoKeyArray[0] + neoKeyArray[1] + neoKeyArray[2] + neoKeyArray[3] + neoKeyArray[4] + "," + neoKeyArray[5] + neoKeyArray[6] + neoKeyArray[7] + neoKeyArray[8] + neoKeyArray[9] + "," + neoKeyArray[10] + neoKeyArray[11] + neoKeyArray[12] + neoKeyArray[13] + neoKeyArray[14] + "," + neoKeyArray[15] + neoKeyArray[16] + neoKeyArray[17] + neoKeyArray[18] + neoKeyArray[19] + "," + neoKeyArray[20] + neoKeyArray[21] + neoKeyArray[22] + neoKeyArray[23] + neoKeyArray[24] + "," + neoKeyArray[25] + neoKeyArray[26] + neoKeyArray[27] + neoKeyArray[28] + neoKeyArray[29] + "," + neoKeyArray[30] + neoKeyArray[31] + neoKeyArray[32] + neoKeyArray[33] + neoKeyArray[34] + "," + neoKeyArray[35] + neoKeyArray[36] + neoKeyArray[37] + neoKeyArray[38] + neoKeyArray[39] + "," + neoKeyArray[40] + neoKeyArray[41] + neoKeyArray[42] + neoKeyArray[43] + neoKeyArray[44] + "," + neoKeyArray[45] + neoKeyArray[46] + neoKeyArray[47] + neoKeyArray[48] + neoKeyArray[49] + "," + neoKeyArray[50] + neoKeyArray[51] + neoKeyArray[52] + neoKeyArray[53] + neoKeyArray[54] + "," + neoKeyArray[55] + neoKeyArray[56] + neoKeyArray[57] + neoKeyArray[58] + neoKeyArray[59] + "," + neoKeyArray[60] + neoKeyArray[61] + neoKeyArray[62] + neoKeyArray[63] + neoKeyArray[64] + "," + neoKeyArray[65] + neoKeyArray[66]);
		}
		return neoKeyArray;
	}

	public int GetCVTriggerValue(int hand)
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref neotriggerV, javaCVClass, "getControllerKeyEvent", hand);
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog CVTriggerValue " + neotriggerV[7]);
		}
		return neotriggerV[7];
	}

	public void AutoConnectHbController(int scanTimeMs)
	{
		PLOG.I("PvrLog AutoConnectHbController" + scanTimeMs);
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "autoConnectHbController", scanTimeMs, gameobjname);
	}

	public void StartControllerThread(int headSensorState, int handSensorState)
	{
		if (BoundarySystem.UPvr_IsBoundaryEnable())
		{
			headSensorState = 1;
			handSensorState = 1;
		}
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "startControllerThread", headSensorState, handSensorState);
		UnityEngine.Debug.Log("PvrLog StartControllerThread" + headSensorState + handSensorState);
	}

	public void StopControllerThread(int headSensorState, int handSensorState)
	{
		if (BoundarySystem.UPvr_IsBoundaryEnable())
		{
			headSensorState = 1;
			handSensorState = 1;
		}
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "stopControllerThread", headSensorState, handSensorState);
		UnityEngine.Debug.Log("PvrLog StopControllerThread" + headSensorState + handSensorState);
	}

	public void SetUnityVersionToJar(string version)
	{
		if (trackingmode == 4 || trackingmode == 5 || trackingmode == 6)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setUnityVersion", version);
		}
		UnityEngine.Debug.Log("PvrLog SetUnityVersionToJar" + version);
	}

	public Vector3 GetVelocity(int num)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref velocity, javaCVClass, "getControllerLinearVelocity", num);
		}
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog Velocity" + velocity[0] + "," + velocity[1] + "," + velocity[2]);
		}
		return new Vector3(velocity[0], velocity[1], 0f - velocity[2]);
	}

	public Vector3 GetAngularVelocity(int num)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref angularVelocity, javaCVClass, "getControllerAngularVelocity", num);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref angularVelocity, javaHummingbirdClass, "getHbAngularVelocity");
		}
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog Gyro:" + angularVelocity[0] + "," + angularVelocity[1] + "," + angularVelocity[2]);
		}
		return new Vector3(0f, 0f, 0f);
	}

	public Vector3 GetAcceleration(int num)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref acceData, javaCVClass, "getControllerAcceleration", num);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref acceData, javaHummingbirdClass, "getHbAcceleration");
		}
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog Acce:" + acceData[0] + acceData[1] + acceData[2]);
		}
		return new Vector3(0f, 0f, 0f);
	}

	public string GetConnectedDeviceMac()
	{
		string result = "";
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getConnectedDeviceMac");
		}
		PLOG.I("PvrLog ConnectedDeviceMac:" + result);
		return result;
	}

	public void VibrateNeo2Controller(float strength, int time, int hand)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "vibrateCV2ControllerStrength", strength, time, hand);
		}
		PLOG.I("PvrLog VibrateNeo2Controller:" + strength + time + hand);
	}

	public int GetMainControllerIndex()
	{
		int result = 0;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getMainControllerIndex");
		}
		PLOG.I("PvrLog GetMainControllerIndex:" + result);
		return result;
	}

	public void SetMainController(int index)
	{
		PLOG.I("PvrLog SetMainController:" + index);
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setMainController", index);
		}
	}

	public void ResetHeadSensorForController()
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "resetHeadSensorForController");
		}
		PLOG.I("PvrLog ResetHeadSensorForController:");
	}

	public void GetDeviceVersion(int deviceType)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "getDeviceVersion", deviceType);
		}
		PLOG.I("PvrLog GetDeviceVersion:" + deviceType);
	}

	public void GetControllerSnCode(int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "getControllerSnCode", controllerSerialNum);
		}
		PLOG.I("PvrLog GetControllerSnCode:" + controllerSerialNum);
	}

	public void SetControllerUnbind(int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setControllerUnbind", controllerSerialNum);
		}
		PLOG.I("PvrLog SetControllerUnbind:" + controllerSerialNum);
	}

	public void SetStationRestart()
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setStationRestart");
		}
		PLOG.I("PvrLog SetStationRestart");
	}

	public void StartStationOtaUpdate()
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "startStationOtaUpdate");
		}
		PLOG.I("PvrLog StartStationOtaUpdate");
	}

	public void StartControllerOtaUpdate(int mode, int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "startControllerOtaUpdate", mode, controllerSerialNum);
		}
		PLOG.I("PvrLog StartControllerOtaUpdate" + mode + controllerSerialNum);
	}

	public void EnterPairMode(int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "enterPairMode", controllerSerialNum);
		}
		PLOG.I("PvrLog EnterPairMode" + controllerSerialNum);
	}

	public void SetControllerShutdown(int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setControllerShutdown", controllerSerialNum);
		}
		PLOG.I("PvrLog SetControllerShutdown" + controllerSerialNum);
	}

	public int GetStationPairState()
	{
		int result = -1;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getStationPairState");
		}
		PLOG.I("PvrLog StationPairState" + result);
		return result;
	}

	public int GetStationOtaUpdateProgress()
	{
		int result = -1;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getStationOtaUpdateProgress");
		}
		PLOG.I("PvrLog StationOtaUpdateProgress" + result);
		return result;
	}

	public int GetControllerOtaUpdateProgress()
	{
		int result = -1;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerOtaUpdateProgress");
		}
		PLOG.I("PvrLog ControllerOtaUpdateProgress" + result);
		return result;
	}

	public void GetControllerVersionAndSN(int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "getControllerVersionAndSN", controllerSerialNum);
		}
		PLOG.I("PvrLog GetControllerVersionAndSN" + controllerSerialNum);
	}

	public void GetControllerUniqueID()
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "getControllerUniqueID");
		}
		PLOG.I("PvrLog GetControllerUniqueID");
	}

	public void InterruptStationPairMode()
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "interruptStationPairMode");
		}
		PLOG.I("PvrLog InterruptStationPairMode");
	}

	public int GetControllerAbility(int controllerSerialNum)
	{
		int result = -1;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerAbility", controllerSerialNum);
		}
		PLOG.I("PvrLog ControllerAbility:" + result);
		return result;
	}

	public void SwitchHomeKey(bool state)
	{
		PLOG.I("PvrLog SwitchHomeKey:" + state);
		switchHomeKey = state;
	}

	public void SetBootReconnect()
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "setBootReconnect");
		PLOG.I("PvrLog SetBootReconnect");
	}

	public int GetTemperature()
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getTemperature");
		PLOG.I("PvrLog Temperature:" + result);
		return result;
	}

	public int GetDeviceType()
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getDeviceType");
		PLOG.I("PvrLog DeviceType:" + result);
		return result;
	}

	public int GetControllerType()
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getControllerType");
		return result;
	}

	public string GetHummingBird2SN()
	{
		string result = "";
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getHummingBird2SN");
		PLOG.I("PvrLog HummingBird2SN:" + result);
		return result;
	}

	public string GetControllerVersion()
	{
		string result = "";
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getControllerVersion");
		PLOG.I("PvrLog ControllerVersion:" + result);
		return result;
	}

	public bool IsEnbleTrigger()
	{
		bool result = false;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "isEnbleTrigger");
		PLOG.I("PvrLog IsEnbleTrigger:" + result);
		return result;
	}

	public void StartCV2PairingMode(int devicetype)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "startCV2PairingMode", devicetype);
		}
		PLOG.I("PvrLog StartCV2PairingMode:" + devicetype);
	}

	public void StopCV2PairingMode(int devicetype)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "stopCV2PairingMode", devicetype);
		}
		PLOG.I("PvrLog StopCV2PairingMode:" + devicetype);
	}

	public int GetControllerBindingState(int id)
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerBindingState", id);
		PLOG.I("PvrLog getControllerBindingState:" + result);
		return result;
	}

	public void setIsEnbleHomeKey(bool state)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setIsEnbleHomeKey", state);
		}
		PLOG.I("PvrLog setIsEnbleHomeKey:" + state);
	}

	public int getControllerSensorStatus(int id)
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerSensorStatus", id);
		PLOG.I("PvrLog getControllerSensorStatus:" + result);
		return result;
	}
}
public class Pvr_ControllerManager : MonoBehaviour
{
	public delegate void PvrServiceStartSuccess();

	public delegate void PvrControllerStateChanged(string data);

	public delegate void ChangeMainControllerCallBack(string index);

	public delegate void ChangeHandNessCallBack(string index);

	public delegate void SetHbServiceBindState();

	public delegate void ControllerThreadStartedCallback();

	public delegate void SetControllerServiceBindState();

	public delegate void ControllerStatusChange(string isconnect);

	public delegate void SetControllerAbility(string data);

	public delegate void SetControllerStateChanged(string data);

	public delegate void SetHbControllerMac(string mac);

	public delegate void ControllerDeviceVersionCallback(string data);

	public delegate void ControllerSnCodeCallback(string data);

	public delegate void ControllerUnbindCallback(string status);

	public delegate void ControllerStationStatusCallback(string status);

	public delegate void ControllerStationBusyCallback(string status);

	public delegate void ControllerOtaStartCodeCallback(string data);

	public delegate void ControllerDeviceVersionAndSNCallback(string data);

	public delegate void ControllerUniqueIDCallback(string data);

	public delegate void ControllerCombinedKeyUnbindCallback(string data);

	private static Pvr_ControllerManager instance;

	public static Pvr_ControllerLink controllerlink;

	private float cTime = 1f;

	private bool stopConnect;

	public Text toast;

	private bool controllerServicestate;

	private float disConnectTime;

	public bool LengthAdaptiveRay;

	private float[] sensorData = new float[28];

	private int[] keyData = new int[134];

	private float[] g2SensorData = new float[4];

	private int[] g2KeyData = new int[47];

	private int keyOffset;

	private int rotControllerMode = 1;

	public static Pvr_ControllerManager Instance
	{
		get
		{
			if (instance == null)
			{
				instance = UnityEngine.Object.FindObjectOfType<Pvr_ControllerManager>();
			}
			if (instance == null)
			{
				GameObject obj = new GameObject("GameObject");
				instance = obj.AddComponent<Pvr_ControllerManager>();
				obj.transform.localPosition = Vector3.zero;
			}
			return instance;
		}
	}

	public static event PvrServiceStartSuccess PvrServiceStartSuccessEvent;

	public static event PvrControllerStateChanged PvrControllerStateChangedEvent;

	public static event ChangeMainControllerCallBack ChangeMainControllerCallBackEvent;

	public static event ChangeHandNessCallBack ChangeHandNessCallBackEvent;

	public static event SetHbServiceBindState SetHbServiceBindStateEvent;

	public static event ControllerThreadStartedCallback ControllerThreadStartedCallbackEvent;

	public static event SetControllerServiceBindState SetControllerServiceBindStateEvent;

	public static event ControllerStatusChange ControllerStatusChangeEvent;

	public static event SetControllerAbility SetControllerAbilityEvent;

	public static event SetControllerStateChanged SetControllerStateChangedEvent;

	public static event SetHbControllerMac SetHbControllerMacEvent;

	public static event ControllerDeviceVersionCallback ControllerDeviceVersionCallbackEvent;

	public static event ControllerSnCodeCallback ControllerSnCodeCallbackEvent;

	public static event ControllerUnbindCallback ControllerUnbindCallbackEvent;

	public static event ControllerStationStatusCallback ControllerStationStatusCallbackEvent;

	public static event ControllerStationBusyCallback ControllerStationBusyCallbackEvent;

	public static event ControllerOtaStartCodeCallback ControllerOtaStartCodeCallbackEvent;

	public static event ControllerDeviceVersionAndSNCallback ControllerDeviceVersionAndSNCallbackEvent;

	public static event ControllerUniqueIDCallback ControllerUniqueIDCallbackEvent;

	public static event ControllerCombinedKeyUnbindCallback ControllerCombinedKeyUnbindCallbackEvent;

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
		if (instance != this)
		{
			PLOG.E("instance object should be a singleton.");
			return;
		}
		if (controllerlink == null)
		{
			controllerlink = new Pvr_ControllerLink(base.gameObject.name);
			return;
		}
		controllerlink.SetGameObjectToJar(base.gameObject.name);
		BindService();
	}

	private void Start()
	{
		if (controllerlink.trackingmode < 2)
		{
			Invoke("CheckControllerService", 10f);
		}
		Render.UPvr_GetIntConfig(23, ref rotControllerMode);
	}

	private void Update()
	{
		if (controllerlink.neoserviceStarted)
		{
			sensorData = controllerlink.GetControllerSensorData();
			keyData = controllerlink.GetControllerKeyData();
			if (controllerlink.controller0Connected)
			{
				if (Pvr_UnitySDKManager.SDK.ShowVideoSeethrough)
				{
					sensorData[2] = 0f - sensorData[2];
					sensorData[3] = 0f - sensorData[3];
					controllerlink.Controller0.Rotation.Set(sensorData[0], sensorData[1], sensorData[2], sensorData[3]);
					if (rotControllerMode == 0)
					{
						controllerlink.Controller0.Rotation *= Quaternion.Euler(34f, 0f, 0f);
					}
					controllerlink.Controller0.Position.Set(sensorData[4] / 1000f, sensorData[5] / 1000f, (0f - sensorData[6]) / 1000f);
				}
				else
				{
					controllerlink.Controller0.Rotation.Set(sensorData[7], sensorData[8], sensorData[9], sensorData[10]);
					if (rotControllerMode == 0)
					{
						controllerlink.Controller0.Rotation *= Quaternion.Euler(34f, 0f, 0f);
					}
					controllerlink.Controller0.Position.Set(sensorData[11] / 1000f, sensorData[12] / 1000f, (0f - sensorData[13]) / 1000f);
				}
				if (!controllerlink.Controller0.isShowBoundary)
				{
					if (controllerlink.getControllerSensorStatus(0) == 0)
					{
						Sensor.UPvr_SetReinPosition(sensorData[0], sensorData[1], sensorData[2], sensorData[3], sensorData[4], sensorData[5], sensorData[6], 0, valid: false, 0);
					}
					else
					{
						controllerlink.Controller0.isShowBoundary = true;
						Sensor.UPvr_SetReinPosition(sensorData[0], sensorData[1], sensorData[2], sensorData[3], sensorData[4], sensorData[5], sensorData[6], 0, valid: true, Convert.ToInt32(Convert.ToString(keyData[35]) + Convert.ToString(keyData[15]) + "00", 2));
					}
				}
				else
				{
					Sensor.UPvr_SetReinPosition(sensorData[0], sensorData[1], sensorData[2], sensorData[3], sensorData[4], sensorData[5], sensorData[6], 0, valid: true, Convert.ToInt32(Convert.ToString(keyData[35]) + Convert.ToString(keyData[15]) + "00", 2));
				}
				TransformData(controllerlink.Controller0, 0, keyData);
			}
			else
			{
				Sensor.UPvr_SetReinPosition(sensorData[0], sensorData[1], sensorData[2], sensorData[3], sensorData[4], sensorData[5], sensorData[6], 0, valid: false, 0);
			}
			if (controllerlink.controller1Connected)
			{
				if (Pvr_UnitySDKManager.SDK.ShowVideoSeethrough)
				{
					sensorData[16] = 0f - sensorData[16];
					sensorData[17] = 0f - sensorData[17];
					controllerlink.Controller1.Rotation.Set(sensorData[14], sensorData[15], sensorData[16], sensorData[17]);
					if (rotControllerMode == 0)
					{
						controllerlink.Controller1.Rotation *= Quaternion.Euler(34f, 0f, 0f);
					}
					controllerlink.Controller1.Position.Set(sensorData[18] / 1000f, sensorData[19] / 1000f, (0f - sensorData[20]) / 1000f);
				}
				else
				{
					controllerlink.Controller1.Rotation.Set(sensorData[21], sensorData[22], sensorData[23], sensorData[24]);
					if (rotControllerMode == 0)
					{
						controllerlink.Controller1.Rotation *= Quaternion.Euler(34f, 0f, 0f);
					}
					controllerlink.Controller1.Position.Set(sensorData[25] / 1000f, sensorData[26] / 1000f, (0f - sensorData[27]) / 1000f);
				}
				if (!controllerlink.Controller1.isShowBoundary)
				{
					if (controllerlink.getControllerSensorStatus(1) == 0)
					{
						Sensor.UPvr_SetReinPosition(sensorData[14], sensorData[15], sensorData[16], sensorData[17], sensorData[18], sensorData[19], sensorData[20], 1, valid: false, 0);
					}
					else
					{
						controllerlink.Controller1.isShowBoundary = true;
						Sensor.UPvr_SetReinPosition(sensorData[14], sensorData[15], sensorData[16], sensorData[17], sensorData[18], sensorData[19], sensorData[20], 1, valid: true, Convert.ToInt32(Convert.ToString(keyData[102]) + Convert.ToString(keyData[82]) + "00", 2));
					}
				}
				else
				{
					Sensor.UPvr_SetReinPosition(sensorData[14], sensorData[15], sensorData[16], sensorData[17], sensorData[18], sensorData[19], sensorData[20], 1, valid: true, Convert.ToInt32(Convert.ToString(keyData[102]) + Convert.ToString(keyData[82]) + "00", 2));
				}
				TransformData(controllerlink.Controller1, 1, keyData);
			}
			else
			{
				Sensor.UPvr_SetReinPosition(sensorData[14], sensorData[15], sensorData[16], sensorData[17], sensorData[18], sensorData[19], sensorData[20], 1, valid: false, 0);
			}
		}
		if (controllerlink.goblinserviceStarted && controllerlink.controller0Connected)
		{
			g2SensorData = controllerlink.GetHBControllerPoseData();
			controllerlink.Controller0.Rotation.Set(g2SensorData[0], g2SensorData[1], g2SensorData[2], g2SensorData[3]);
			g2KeyData = controllerlink.GetHBControllerKeyData();
			TransformData(controllerlink.Controller0, 0, g2KeyData);
		}
		SetSystemKey();
	}

	private void OnApplicationPause(bool pause)
	{
		int headSensorState = ((!Pvr_UnitySDKManager.SDK.HmdOnlyrot) ? 1 : 0);
		int handSensorState = ((!Pvr_UnitySDKManager.SDK.ControllerOnlyrot) ? 1 : 0);
		if (pause)
		{
			if (controllerlink.neoserviceStarted)
			{
				controllerlink.SetGameObjectToJar("");
				controllerlink.StopControllerThread(headSensorState, handSensorState);
			}
			if (controllerlink.goblinserviceStarted)
			{
				controllerlink.StopLark2Receiver();
			}
			return;
		}
		controllerlink.Controller0 = new ControllerHand();
		controllerlink.Controller1 = new ControllerHand();
		if (controllerlink.neoserviceStarted)
		{
			controllerlink.SetGameObjectToJar(base.gameObject.name);
			controllerlink.SetUnityVersionToJar("2.8.9.12");
			controllerlink.StartControllerThread(headSensorState, handSensorState);
		}
		if (controllerlink.goblinserviceStarted)
		{
			controllerlink.StartLark2Receiver();
			controllerlink.controller0Connected = GetControllerConnectionState(0) == 1;
			controllerlink.controllerType = controllerlink.GetControllerType();
			controllerlink.handness = (Pvr_Controller.UserHandNess)controllerlink.getHandness();
			if (Pvr_ControllerManager.PvrServiceStartSuccessEvent != null)
			{
				Pvr_ControllerManager.PvrServiceStartSuccessEvent();
			}
		}
	}

	private void OnDestroy()
	{
		controllerlink.UnBindService();
		Sensor.UPvr_SetReinPosition(0f, 0f, 0f, 1f, 0f, 0f, 0f, 0, valid: false, 0);
		Sensor.UPvr_SetReinPosition(0f, 0f, 0f, 1f, 0f, 0f, 0f, 1, valid: false, 0);
	}

	private void OnApplicationQuit()
	{
		int headSensorState = ((!Pvr_UnitySDKManager.SDK.HmdOnlyrot) ? 1 : 0);
		int handSensorState = ((!Pvr_UnitySDKManager.SDK.ControllerOnlyrot) ? 1 : 0);
		if (controllerlink.neoserviceStarted)
		{
			controllerlink.SetGameObjectToJar("");
			controllerlink.StopControllerThread(headSensorState, handSensorState);
		}
	}

	public void StopLark2Service()
	{
		if (controllerlink != null)
		{
			controllerlink.StopLark2Service();
		}
	}

	public Vector3 GetAngularVelocity(int num)
	{
		if (controllerlink != null)
		{
			return controllerlink.GetAngularVelocity(num);
		}
		return new Vector3(0f, 0f, 0f);
	}

	public Vector3 GetAcceleration(int num)
	{
		if (controllerlink != null)
		{
			return controllerlink.GetAcceleration(num);
		}
		return new Vector3(0f, 0f, 0f);
	}

	public void BindService()
	{
		if (controllerlink != null)
		{
			controllerlink.BindService();
		}
	}

	public void StartScan()
	{
		if (controllerlink != null)
		{
			controllerlink.StartScan();
		}
	}

	public void StopScan()
	{
		if (controllerlink != null)
		{
			controllerlink.StopScan();
		}
	}

	public void ResetController(int num)
	{
		if (controllerlink != null)
		{
			controllerlink.ResetController(num);
		}
	}

	public static int GetControllerConnectionState(int num)
	{
		return controllerlink.GetControllerConnectionState(num);
	}

	public void ConnectBLE()
	{
		if (controllerlink != null)
		{
			controllerlink.ConnectBLE();
		}
	}

	public void DisConnectBLE()
	{
		if (controllerlink != null)
		{
			controllerlink.DisConnectBLE();
		}
	}

	public void SetBinPath(string path, bool isAsset)
	{
		if (controllerlink != null)
		{
			controllerlink.setBinPath(path, isAsset);
		}
	}

	public void StartUpgrade()
	{
		if (controllerlink != null)
		{
			controllerlink.StartUpgrade();
		}
	}

	public static string GetBLEImageType()
	{
		return controllerlink.GetBLEImageType();
	}

	public static long GetBLEVersion()
	{
		return controllerlink.GetBLEVersion();
	}

	public static string GetFileImageType()
	{
		return controllerlink.GetFileImageType();
	}

	public static long GetFileVersion()
	{
		return controllerlink.GetFileVersion();
	}

	public static void AutoConnectHbController(int scans)
	{
		if (controllerlink != null)
		{
			controllerlink.AutoConnectHbController(scans);
		}
	}

	public static string GetConnectedDeviceMac()
	{
		string result = "";
		if (controllerlink != null)
		{
			result = controllerlink.GetConnectedDeviceMac();
		}
		return result;
	}

	public void setHbControllerMac(string mac)
	{
		PLOG.I("PvrLog HBMacRSSI" + mac);
		controllerlink.hummingBirdMac = mac.Substring(0, 17);
		controllerlink.hummingBirdRSSI = Convert.ToInt16(mac.Remove(0, 18));
		if (Pvr_ControllerManager.SetHbControllerMacEvent != null)
		{
			Pvr_ControllerManager.SetHbControllerMacEvent(mac.Substring(0, 17));
		}
	}

	public int GetControllerRSSI()
	{
		return controllerlink.hummingBirdRSSI;
	}

	public void setHbServiceBindState(string state)
	{
		PLOG.I("PvrLog HBBindCallBack" + state);
		controllerServicestate = true;
		if (Convert.ToInt16(state) == 0)
		{
			Invoke("BindService", 0.5f);
			controllerlink.goblinserviceStarted = false;
		}
		else if (Convert.ToInt16(state) == 1)
		{
			controllerlink.goblinserviceStarted = true;
			controllerlink.controller0Connected = GetControllerConnectionState(0) == 1;
			controllerlink.controllerType = controllerlink.GetControllerType();
			controllerlink.handness = (Pvr_Controller.UserHandNess)controllerlink.getHandness();
			if (Pvr_ControllerManager.SetHbServiceBindStateEvent != null)
			{
				Pvr_ControllerManager.SetHbServiceBindStateEvent();
			}
			if (Pvr_ControllerManager.PvrServiceStartSuccessEvent != null)
			{
				Pvr_ControllerManager.PvrServiceStartSuccessEvent();
			}
		}
	}

	public void setControllerServiceBindState(string state)
	{
		PLOG.I("PvrLog CVBindCallBack" + state);
		if (Convert.ToInt16(state) == 0)
		{
			Invoke("BindService", 0.5f);
			controllerlink.neoserviceStarted = false;
		}
		else if (Convert.ToInt16(state) == 1)
		{
			controllerlink.SetUnityVersionToJar("2.8.9.12");
			controllerlink.neoserviceStarted = true;
			int headSensorState = ((!Pvr_UnitySDKManager.SDK.HmdOnlyrot) ? 1 : 0);
			int handSensorState = ((!Pvr_UnitySDKManager.SDK.ControllerOnlyrot) ? 1 : 0);
			controllerlink.StartControllerThread(headSensorState, handSensorState);
			if (Pvr_ControllerManager.SetControllerServiceBindStateEvent != null)
			{
				Pvr_ControllerManager.SetControllerServiceBindStateEvent();
			}
		}
	}

	public void setHbControllerConnectState(string isconnect)
	{
		PLOG.I("PvrLog HBControllerConnect" + isconnect);
		controllerlink.controller0Connected = Convert.ToInt16(isconnect) == 1;
		if (!controllerlink.controller0Connected)
		{
			controllerlink.Controller0 = new ControllerHand();
		}
		else
		{
			ResetController(0);
			controllerlink.controllerType = controllerlink.GetControllerType();
			controllerlink.handness = (Pvr_Controller.UserHandNess)controllerlink.getHandness();
		}
		stopConnect = false;
		if (Pvr_ControllerManager.ControllerStatusChangeEvent != null)
		{
			Pvr_ControllerManager.ControllerStatusChangeEvent(isconnect);
		}
		if (Pvr_ControllerManager.PvrControllerStateChangedEvent != null)
		{
			Pvr_ControllerManager.PvrControllerStateChangedEvent(isconnect);
		}
	}

	public void setControllerStateChanged(string state)
	{
		PLOG.I("PvrLog CVControllerStateChanged" + state);
		int num = Convert.ToInt16(state.Substring(0, 1));
		if (num == 0)
		{
			controllerlink.controller0Connected = Convert.ToBoolean(Convert.ToInt16(state.Substring(2, 1)));
			if (!controllerlink.controller0Connected)
			{
				controllerlink.Controller0 = new ControllerHand();
				controllerlink.Controller0.Position = new Vector3(0f, Pvr_UnitySDKSensor.Instance.HeadPose.Position.y, 0f) + new Vector3(-0.1f, -0.3f, 0.3f);
			}
		}
		else
		{
			controllerlink.controller1Connected = Convert.ToBoolean(Convert.ToInt16(state.Substring(2, 1)));
			if (!controllerlink.controller1Connected)
			{
				controllerlink.Controller1 = new ControllerHand();
				controllerlink.Controller1.Position = new Vector3(0f, Pvr_UnitySDKSensor.Instance.HeadPose.Position.y, 0f) + new Vector3(0.1f, -0.3f, 0.3f);
			}
		}
		if (Convert.ToBoolean(Convert.ToInt16(state.Substring(2, 1))))
		{
			controllerlink.controllerType = controllerlink.GetControllerType();
			controllerlink.ResetController(num);
		}
		controllerlink.handness = (Pvr_Controller.UserHandNess)controllerlink.getHandness();
		controllerlink.mainHandID = controllerlink.GetMainControllerIndex();
		if (Pvr_ControllerManager.SetControllerStateChangedEvent != null)
		{
			Pvr_ControllerManager.SetControllerStateChangedEvent(state);
		}
		if (Pvr_ControllerManager.PvrControllerStateChangedEvent != null)
		{
			Pvr_ControllerManager.PvrControllerStateChangedEvent(state);
		}
	}

	public void setControllerAbility(string data)
	{
		PLOG.I("PvrLog setControllerAbility" + data);
		if (Pvr_ControllerManager.SetControllerAbilityEvent != null)
		{
			Pvr_ControllerManager.SetControllerAbilityEvent(data);
		}
	}

	public void controllerThreadStartedCallback()
	{
		PLOG.I("PvrLog ThreadStartSuccess");
		GetCVControllerState();
		if (Pvr_ControllerManager.ControllerThreadStartedCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerThreadStartedCallbackEvent();
		}
		if (Pvr_ControllerManager.PvrServiceStartSuccessEvent != null)
		{
			Pvr_ControllerManager.PvrServiceStartSuccessEvent();
		}
	}

	public void controllerDeviceVersionCallback(string data)
	{
		PLOG.I("PvrLog VersionCallBack" + data);
		if (Pvr_ControllerManager.ControllerDeviceVersionCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerDeviceVersionCallbackEvent(data);
		}
	}

	public void controllerSnCodeCallback(string data)
	{
		PLOG.I("PvrLog SNCodeCallBack" + data);
		if (Pvr_ControllerManager.ControllerSnCodeCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerSnCodeCallbackEvent(data);
		}
	}

	public void controllerUnbindCallback(string status)
	{
		PLOG.I("PvrLog ControllerUnBindCallBack" + status);
		if (Pvr_ControllerManager.ControllerUnbindCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerUnbindCallbackEvent(status);
		}
	}

	public void controllerStationStatusCallback(string status)
	{
		PLOG.I("PvrLog StationStatusCallBack" + status);
		if (Pvr_ControllerManager.ControllerStationStatusCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerStationStatusCallbackEvent(status);
		}
	}

	public void controllerStationBusyCallback(string status)
	{
		PLOG.I("PvrLog StationBusyCallBack" + status);
		if (Pvr_ControllerManager.ControllerStationBusyCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerStationBusyCallbackEvent(status);
		}
	}

	public void controllerOTAStartCodeCallback(string data)
	{
		PLOG.I("PvrLog OTAUpdateCallBack" + data);
		if (Pvr_ControllerManager.ControllerOtaStartCodeCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerOtaStartCodeCallbackEvent(data);
		}
	}

	public void controllerDeviceVersionAndSNCallback(string data)
	{
		PLOG.I("PvrLog DeviceVersionAndSNCallback" + data);
		if (Pvr_ControllerManager.ControllerDeviceVersionAndSNCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerDeviceVersionAndSNCallbackEvent(data);
		}
	}

	public void controllerUniqueIDCallback(string data)
	{
		PLOG.I("PvrLog controllerUniqueIDCallback" + data);
		if (Pvr_ControllerManager.ControllerUniqueIDCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerUniqueIDCallbackEvent(data);
		}
	}

	public void controllerCombinedKeyUnbindCallback(string controllerSerialNum)
	{
		if (Pvr_ControllerManager.ControllerCombinedKeyUnbindCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerCombinedKeyUnbindCallbackEvent(controllerSerialNum);
		}
	}

	public void setupdateFailed()
	{
	}

	public void setupdateSuccess()
	{
	}

	public void setupdateProgress(string progress)
	{
	}

	public void setHbAutoConnectState(string state)
	{
		PLOG.I("PvrLog HBAutoConnectState" + state);
		controllerServicestate = true;
		if (Convert.ToInt16(state) == 0 && GetControllerConnectionState(0) == 0)
		{
			ShowToast(2);
		}
		if (Convert.ToInt16(state) == 2)
		{
			ShowToast(3);
		}
	}

	public void callbackControllerServiceState(string state)
	{
		PLOG.I("PvrLog HBServiceState" + state);
		controllerServicestate = true;
		if (Convert.ToInt16(state) == 0)
		{
			ShowToast(0);
		}
		if (Convert.ToInt16(state) == 1)
		{
			BindService();
		}
		if (Convert.ToInt16(state) == 2)
		{
			ShowToast(1);
		}
	}

	public void changeMainControllerCallback(string index)
	{
		PLOG.I("PvrLog MainControllerCallBack" + index);
		controllerlink.mainHandID = Convert.ToInt16(index);
		if (Pvr_ControllerManager.ChangeMainControllerCallBackEvent != null)
		{
			Pvr_ControllerManager.ChangeMainControllerCallBackEvent(index);
		}
	}

	public void changeHandnessCallback(string index)
	{
		PLOG.I("PvrLog changeHandnessCallback" + index);
		controllerlink.handness = (Pvr_Controller.UserHandNess)Convert.ToInt16(index);
		if (Pvr_ControllerManager.ChangeHandNessCallBackEvent != null)
		{
			Pvr_ControllerManager.ChangeHandNessCallBackEvent(index);
		}
	}

	private void ShowToast(int type)
	{
		if (toast != null)
		{
			switch (type)
			{
			case 0:
				toast.text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("servicetip0");
				Invoke("HideToast", 5f);
				break;
			case 1:
				toast.text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("servicetip1");
				Invoke("HideToast", 5f);
				break;
			case 2:
				toast.text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("servicetip2");
				AutoConnectHbController(6000);
				Invoke("HideToast", 5f);
				break;
			case 3:
				toast.text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("servicetip3");
				AutoConnectHbController(6000);
				Invoke("HideToast", 5f);
				break;
			case 4:
				toast.text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("servicetip4");
				Invoke("HideToast", 10f);
				break;
			}
		}
	}

	private void HideToast()
	{
		if (toast != null)
		{
			toast.text = "";
		}
	}

	private void CheckControllerService()
	{
		if (!controllerServicestate)
		{
			ShowToast(4);
		}
	}

	private void GetCVControllerState()
	{
		int controllerConnectionState = GetControllerConnectionState(0);
		int controllerConnectionState2 = GetControllerConnectionState(1);
		PLOG.I("PvrLog CVconnect" + controllerConnectionState + controllerConnectionState2);
		if (controllerConnectionState == -1 && controllerConnectionState2 == -1)
		{
			Invoke("GetCVControllerState", 0.02f);
		}
		if (controllerConnectionState != -1 && controllerConnectionState2 != -1)
		{
			controllerlink.controller0Connected = controllerConnectionState == 1;
			controllerlink.controller1Connected = controllerConnectionState2 == 1;
			if (!controllerlink.controller0Connected && controllerlink.controller1Connected && controllerlink.GetMainControllerIndex() == 0)
			{
				Controller.UPvr_SetMainHandNess(1);
			}
			if (controllerlink.controller0Connected || controllerlink.controller1Connected)
			{
				controllerlink.controllerType = controllerlink.GetControllerType();
			}
			controllerlink.mainHandID = controllerlink.GetMainControllerIndex();
			controllerlink.handness = (Pvr_Controller.UserHandNess)controllerlink.getHandness();
		}
	}

	private void SetSystemKey()
	{
		if (controllerlink.switchHomeKey && (Controller.UPvr_GetKeyLongPressed(0, Pvr_KeyCode.HOME) || Controller.UPvr_GetKeyLongPressed(1, Pvr_KeyCode.HOME)))
		{
			if (Pvr_UnitySDKManager.SDK.HmdOnlyrot)
			{
				Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 0);
			}
			else if (controllerlink.trackingmode == 0 || controllerlink.trackingmode == 1)
			{
				Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
			}
			else
			{
				Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
			}
			if (Pvr_UnitySDKManager.SDK.ControllerOnlyrot || (controllerlink.controller0Connected && Controller.UPvr_GetControllerPOS(0).Equals(Vector3.zero)) || (controllerlink.controller1Connected && Controller.UPvr_GetControllerPOS(1).Equals(Vector3.zero)))
			{
				if (Controller.UPvr_GetKeyLongPressed(0, Pvr_KeyCode.HOME))
				{
					ResetController(0);
				}
				if (Controller.UPvr_GetKeyLongPressed(1, Pvr_KeyCode.HOME))
				{
					ResetController(1);
				}
			}
		}
		if (controllerlink.picoDevice)
		{
			if (controllerlink.switchHomeKey && (Controller.UPvr_GetKeyClick(0, Pvr_KeyCode.HOME) || (Controller.UPvr_GetKeyClick(1, Pvr_KeyCode.HOME) && !stopConnect)))
			{
				controllerlink.RebackToLauncher();
			}
			if (Controller.UPvr_GetKeyClick(0, Pvr_KeyCode.VOLUMEUP) || Controller.UPvr_GetKeyClick(1, Pvr_KeyCode.VOLUMEUP))
			{
				controllerlink.TurnUpVolume();
			}
			if (Controller.UPvr_GetKeyClick(0, Pvr_KeyCode.VOLUMEDOWN) || Controller.UPvr_GetKeyClick(1, Pvr_KeyCode.VOLUMEDOWN))
			{
				controllerlink.TurnDownVolume();
			}
			if (!Controller.UPvr_GetKey(0, Pvr_KeyCode.VOLUMEUP) && !Controller.UPvr_GetKey(0, Pvr_KeyCode.VOLUMEDOWN) && !Controller.UPvr_GetKey(1, Pvr_KeyCode.VOLUMEUP) && !Controller.UPvr_GetKey(1, Pvr_KeyCode.VOLUMEDOWN))
			{
				cTime = 1f;
			}
			if (Controller.UPvr_GetKey(0, Pvr_KeyCode.VOLUMEUP) || Controller.UPvr_GetKey(1, Pvr_KeyCode.VOLUMEUP))
			{
				cTime -= Time.deltaTime;
				if (cTime <= 0f)
				{
					cTime = 0.2f;
					controllerlink.TurnUpVolume();
				}
			}
			if (!Controller.UPvr_GetKey(0, Pvr_KeyCode.HOME) && !Controller.UPvr_GetKey(1, Pvr_KeyCode.HOME) && (Controller.UPvr_GetKey(0, Pvr_KeyCode.VOLUMEDOWN) || Controller.UPvr_GetKey(1, Pvr_KeyCode.VOLUMEDOWN)))
			{
				cTime -= Time.deltaTime;
				if (cTime <= 0f)
				{
					cTime = 0.2f;
					controllerlink.TurnDownVolume();
				}
			}
		}
		if (controllerlink.goblinserviceStarted && Controller.UPvr_GetKey(0, Pvr_KeyCode.HOME) && Controller.UPvr_GetKey(0, Pvr_KeyCode.VOLUMEDOWN) && !stopConnect)
		{
			disConnectTime += Time.deltaTime;
			if ((double)disConnectTime > 1.0)
			{
				DisConnectBLE();
				controllerlink.hummingBirdMac = "";
				stopConnect = true;
				disConnectTime = 0f;
			}
		}
	}

	private void TransformData(ControllerHand hand, int handId, int[] data)
	{
		keyOffset = ((handId == 1) ? 67 : 0);
		hand.TouchPadPosition.x = data[keyOffset];
		hand.TouchPadPosition.y = data[5 + keyOffset];
		TransSingleKey(hand.Home, 10 + keyOffset, data);
		TransSingleKey(hand.App, 15 + keyOffset, data);
		TransSingleKey(hand.Touch, 20 + keyOffset, data);
		TransSingleKey(hand.VolumeUp, 25 + keyOffset, data);
		TransSingleKey(hand.VolumeDown, 30 + keyOffset, data);
		TransSingleKey(hand.Trigger, 35 + keyOffset, data);
		if (controllerlink.goblinserviceStarted && !controllerlink.neoserviceStarted)
		{
			hand.TriggerNum = controllerlink.GetHBKeyValue();
		}
		if (!controllerlink.goblinserviceStarted && controllerlink.neoserviceStarted)
		{
			hand.TriggerNum = controllerlink.GetCVTriggerValue(handId);
		}
		hand.Battery = data[40 + keyOffset];
		if (data.Length == 47)
		{
			hand.SwipeDirection = (SwipeDirection)data[45];
			hand.TouchPadClick = (TouchPadClick)data[46];
		}
		else
		{
			switch (handId)
			{
			case 0:
				TransSingleKey(hand.X, 45 + keyOffset, data);
				TransSingleKey(hand.Y, 50 + keyOffset, data);
				TransSingleKey(hand.Left, 60 + keyOffset, data);
				break;
			case 1:
				TransSingleKey(hand.A, 45 + keyOffset, data);
				TransSingleKey(hand.B, 50 + keyOffset, data);
				TransSingleKey(hand.Right, 55 + keyOffset, data);
				break;
			}
			hand.SwipeDirection = (SwipeDirection)data[65 + keyOffset];
			hand.TouchPadClick = (TouchPadClick)data[66 + keyOffset];
		}
		hand.GripValue = controllerlink.GetNeo3GripValue(handId);
		TransformTouchData(hand, handId, controllerlink.GetNeo3TouchData(handId));
	}

	private void TransSingleKey(PvrControllerKey key, int beginIndex, int[] data)
	{
		key.State = Convert.ToBoolean(data[beginIndex]);
		key.PressedDown = Convert.ToBoolean(data[beginIndex + 1]);
		key.PressedUp = Convert.ToBoolean(data[beginIndex + 2]);
		key.LongPressed = Convert.ToBoolean(data[beginIndex + 3]);
		key.Click = Convert.ToBoolean(data[beginIndex + 4]);
	}

	private void TransformTouchData(ControllerHand hand, int handId, int[] data)
	{
		switch (handId)
		{
		case 0:
			TransSingleTouchValue(hand.X, 0, data);
			TransSingleTouchValue(hand.Y, 3, data);
			break;
		case 1:
			TransSingleTouchValue(hand.A, 0, data);
			TransSingleTouchValue(hand.B, 3, data);
			break;
		}
		TransSingleTouchValue(hand.Touch, 6, data);
		TransSingleTouchValue(hand.Trigger, 9, data);
		TransSingleTouchValue(hand.Thumbrest, 12, data);
	}

	private void TransSingleTouchValue(PvrControllerKey key, int beginIndex, int[] data)
	{
		key.Touch = Convert.ToBoolean(data[beginIndex]);
		key.TouchDown = Convert.ToBoolean(data[beginIndex + 1]);
		key.TouchUp = Convert.ToBoolean(data[beginIndex + 2]);
	}
}
public class Pvr_ControllerModuleInit : MonoBehaviour
{
	public ControllerVariety Variety;

	public bool IsCustomModel;

	[SerializeField]
	private GameObject dot;

	[SerializeField]
	private GameObject rayLine;

	[SerializeField]
	private GameObject controller;

	private bool moduleState = true;

	private void Awake()
	{
		Pvr_ControllerManager.PvrServiceStartSuccessEvent += ServiceStartSuccess;
		Pvr_ControllerManager.PvrControllerStateChangedEvent += ControllerStateChanged;
		Pvr_ControllerManager.ChangeMainControllerCallBackEvent += MainControllerIDChanged;
		if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
		{
			rayLine = base.transform.GetComponentInChildren<LineRenderer>(includeInactive: true).gameObject;
			rayLine.GetComponent<LineRenderer>().startWidth = 0.003f;
			rayLine.GetComponent<LineRenderer>().endWidth = 0.0015f;
		}
	}

	private void OnDestroy()
	{
		Pvr_ControllerManager.PvrServiceStartSuccessEvent -= ServiceStartSuccess;
		Pvr_ControllerManager.PvrControllerStateChangedEvent -= ControllerStateChanged;
		Pvr_ControllerManager.ChangeMainControllerCallBackEvent -= MainControllerIDChanged;
	}

	private void ServiceStartSuccess()
	{
		RefreshRay();
	}

	private void ControllerStateChanged(string data)
	{
		if (Pvr_ControllerManager.controllerlink.controller0Connected || Pvr_ControllerManager.controllerlink.controller1Connected)
		{
			moduleState = true;
			controller.transform.localScale = Vector3.one;
		}
		RefreshRay();
	}

	private void MainControllerIDChanged(string data)
	{
		RefreshRay();
	}

	private void RefreshRay()
	{
		if (Variety == ControllerVariety.Controller0)
		{
			StartCoroutine(ShowOrHideRay(0));
		}
		if (Variety == ControllerVariety.Controller1)
		{
			StartCoroutine(ShowOrHideRay(1));
		}
	}

	private IEnumerator ShowOrHideRay(int id)
	{
		yield return null;
		yield return null;
		if (moduleState)
		{
			bool active = Controller.UPvr_GetMainHandNess() == id && Controller.UPvr_GetControllerState(id) == ControllerState.Connected;
			dot.SetActive(active);
			rayLine.SetActive(active);
		}
	}

	public void ForceHideOrShow(bool state)
	{
		dot.SetActive(state);
		rayLine.SetActive(state);
		controller.transform.localScale = (state ? Vector3.one : Vector3.zero);
		moduleState = state;
	}

	public void UpdateRay()
	{
		if (!Pvr_ControllerManager.Instance.LengthAdaptiveRay)
		{
			return;
		}
		bool flag = false;
		flag = ((Pvr_ControllerManager.controllerlink.controller0Connected || Pvr_ControllerManager.controllerlink.controller1Connected) ? true : false);
		if (flag && rayLine != null && rayLine.gameObject.activeSelf)
		{
			if (Controller.UPvr_GetDeviceType() == 1)
			{
				rayLine.GetComponent<LineRenderer>().SetPosition(0, base.transform.TransformPoint(0f, 0f, 0.058f));
			}
			else
			{
				rayLine.GetComponent<LineRenderer>().SetPosition(0, base.transform.TransformPoint(0f, 0.009f, 0.055f));
			}
			rayLine.GetComponent<LineRenderer>().SetPosition(1, dot.transform.position);
		}
	}
}
public class Pvr_ControllerPower : MonoBehaviour
{
	[SerializeField]
	private Sprite power1;

	[SerializeField]
	private Sprite power2;

	[SerializeField]
	private Sprite power3;

	[SerializeField]
	private Sprite power4;

	[SerializeField]
	private Sprite power5;

	[HideInInspector]
	public ControllerVariety variety;

	[HideInInspector]
	public ControllerDevice currentDevice;

	private UnityEngine.UI.Image powerImage;

	private int powerValue;

	private float power;

	private void Start()
	{
		powerImage = base.transform.GetComponent<UnityEngine.UI.Image>();
		powerValue = -1;
		variety = base.transform.GetComponentInParent<Pvr_ControllerModuleInit>().Variety;
		currentDevice = base.transform.GetComponentInParent<Pvr_ControllerVisual>().currentDevice;
	}

	private void Update()
	{
		RefreshPower((variety != 0) ? 1 : 0);
	}

	private void RefreshPower(int hand)
	{
		if (powerValue != Controller.UPvr_GetControllerPower(hand))
		{
			switch (Controller.UPvr_GetControllerPower(hand))
			{
			case 1:
				powerImage.sprite = power1;
				powerImage.color = UnityEngine.Color.red;
				break;
			case 2:
				powerImage.sprite = power2;
				powerImage.color = UnityEngine.Color.white;
				break;
			case 3:
				powerImage.sprite = power3;
				powerImage.color = UnityEngine.Color.white;
				break;
			case 4:
				powerImage.sprite = power4;
				powerImage.color = UnityEngine.Color.white;
				break;
			case 5:
				powerImage.sprite = power5;
				powerImage.color = UnityEngine.Color.white;
				break;
			default:
				powerImage.sprite = power1;
				powerImage.color = UnityEngine.Color.white;
				break;
			}
			powerValue = Controller.UPvr_GetControllerPower(hand);
		}
	}
}
public class Pvr_ControllerVisual : MonoBehaviour
{
	public ControllerDevice currentDevice;

	public Texture2D m_idle;

	public Texture2D m_app;

	public Texture2D m_home;

	public Texture2D m_touchpad;

	public Texture2D m_volUp;

	public Texture2D m_volDn;

	public Texture2D m_trigger;

	public Texture2D m_a;

	public Texture2D m_b;

	public Texture2D m_x;

	public Texture2D m_y;

	public Texture2D m_grip;

	private Renderer controllerRenderMat;

	[HideInInspector]
	public ControllerVariety variety;

	private void Awake()
	{
		controllerRenderMat = GetComponent<Renderer>();
	}

	private void Start()
	{
		variety = base.transform.GetComponentInParent<Pvr_ControllerModuleInit>().Variety;
	}

	private void Update()
	{
		ChangeKeyEffects((variety != 0) ? 1 : 0);
	}

	private void ChangeKeyEffects(int hand)
	{
		if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.TOUCHPAD))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_touchpad);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.APP))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_app);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.HOME))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_home);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.VOLUMEUP))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_volUp);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.VOLUMEDOWN))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_volDn);
		}
		else if (Controller.UPvr_GetControllerTriggerValue(hand) > 0 || Controller.UPvr_GetKey(hand, Pvr_KeyCode.TRIGGER))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_trigger);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.X))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_x);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.Y))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_y);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.A))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_a);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.B))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_b);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.Left) || Controller.UPvr_GetKey(hand, Pvr_KeyCode.Right))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_grip);
		}
		else if (controllerRenderMat.material.GetTexture("_MainTex") != m_idle)
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_idle);
		}
	}
}
public class Pvr_ToolTips : MonoBehaviour
{
	public enum TipBtn
	{
		app,
		touchpad,
		home,
		volup,
		voldown,
		trigger,
		grip
	}

	private ControllerDevice currentDevice;

	private float tipsAlpha;

	public static Pvr_ToolTips tooltips;

	public void ChangeTipsText(TipBtn tip, string key)
	{
		switch (tip)
		{
		case TipBtn.app:
			base.transform.Find("apptip/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.touchpad:
			base.transform.Find("touchtip/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.home:
			base.transform.Find("hometip/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.volup:
			base.transform.Find("volup/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.voldown:
			base.transform.Find("voldown/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.trigger:
			base.transform.Find("triggertip/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.grip:
			base.transform.Find("grip/btn/Text").GetComponent<Text>().text = key;
			break;
		}
	}

	private void Awake()
	{
		tooltips = base.transform.GetComponent<Pvr_ToolTips>();
	}

	private void Update()
	{
		switch (currentDevice)
		{
		case ControllerDevice.Goblin:
		case ControllerDevice.G2:
			tipsAlpha = (330f - base.transform.parent.parent.parent.localRotation.eulerAngles.x) / 45f;
			if (base.transform.parent.parent.parent.localRotation.eulerAngles.x >= 270f && base.transform.parent.parent.parent.localRotation.eulerAngles.x <= 330f)
			{
				tipsAlpha = Mathf.Max(0f, tipsAlpha);
				tipsAlpha = ((tipsAlpha > 1f) ? 1f : tipsAlpha);
			}
			else
			{
				tipsAlpha = 0f;
			}
			GetComponent<CanvasGroup>().alpha = tipsAlpha;
			break;
		case ControllerDevice.Neo2:
		case ControllerDevice.Neo3:
			tipsAlpha = (330f - base.transform.parent.parent.parent.localRotation.eulerAngles.x) / 45f;
			if (base.transform.parent.parent.parent.localRotation.eulerAngles.x >= 270f && base.transform.parent.parent.parent.localRotation.eulerAngles.x <= 330f)
			{
				tipsAlpha = Mathf.Max(0f, tipsAlpha);
				tipsAlpha = ((tipsAlpha > 1f) ? 1f : tipsAlpha);
			}
			else
			{
				tipsAlpha = 0f;
			}
			GetComponent<CanvasGroup>().alpha = tipsAlpha;
			break;
		case ControllerDevice.Neo:
			break;
		}
	}

	private void LoadTextFromJson()
	{
		currentDevice = base.transform.GetComponentInParent<Pvr_ControllerVisual>().currentDevice;
		base.transform.Find("apptip/btn/Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("apptip");
		base.transform.Find("touchtip/btn/Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("touchtip");
		base.transform.Find("hometip/btn/Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("hometip");
		Transform transform = base.transform.Find("volup/btn/Text");
		if (transform != null)
		{
			transform.GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("voluptip");
		}
		Transform transform2 = base.transform.Find("voldown/btn/Text");
		if (transform2 != null)
		{
			transform2.GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("voldowntip");
		}
		Transform transform3 = base.transform.Find("triggertip/btn/Text");
		if (transform3 != null)
		{
			transform3.GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("triggertip");
		}
		Transform transform4 = base.transform.Find("grip/btn/Text");
		if (transform4 != null)
		{
			transform4.GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("griptip");
		}
	}

	public static void RefreshTips()
	{
		if (tooltips != null)
		{
			tooltips.LoadTextFromJson();
		}
	}
}
public class Pvr_TouchPadScroll : MonoBehaviour
{
	private ScrollRect scrollRect;

	private bool isHoving;

	private int mainHand;

	private SwipeDirection direction;

	private Vector2 currPos;

	private Vector2 tarPos;

	private float lerpSpeed = 10f;

	private Transform tranViewport;

	private float ignoreDis = 3f;

	private Vector2 lastTouchDownPos;

	private Vector2 lastTouchUpPos;

	private bool isTouching;

	private bool isClosed = true;

	private Vector2 vecOrigin = Vector2.zero;

	private Vector2 vecOriginNeo2 = new Vector2(128f, 128f);

	private void Awake()
	{
		scrollRect = base.gameObject.GetComponent<ScrollRect>();
		tranViewport = base.transform.Find("Viewport");
	}

	private void Update()
	{
		Process();
		UpdateTargetPos();
		UpdatePos();
	}

	private bool IsControllerConnect()
	{
		mainHand = Controller.UPvr_GetMainHandNess();
		if (mainHand == 0 && Pvr_ControllerManager.controllerlink.controller0Connected)
		{
			return true;
		}
		if (mainHand == 1 && Pvr_ControllerManager.controllerlink.controller1Connected)
		{
			return true;
		}
		return false;
	}

	private void UpdateTargetPos()
	{
		if (Controller.UPvr_GetKey(0, Pvr_KeyCode.TOUCHPAD) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TOUCHPAD))
		{
			ResetParameter();
		}
		else if (isHoving)
		{
			if (Pvr_ControllerManager.controllerlink.GetControllerType() == 3)
			{
				ComputeTouchPos();
			}
			else
			{
				ComputeRockerPos();
			}
			if ((currPos - tarPos).sqrMagnitude <= 10f)
			{
				isClosed = true;
			}
		}
	}

	private void ComputeTouchPos()
	{
		mainHand = Controller.UPvr_GetMainHandNess();
		currPos = scrollRect.content.localPosition;
		Vector2 vector = vecOrigin;
		if (mainHand == 0 && Pvr_ControllerManager.controllerlink.controller0Connected)
		{
			vector = Controller.UPvr_GetTouchPadPosition(mainHand);
		}
		if (mainHand == 1 && Pvr_ControllerManager.controllerlink.controller1Connected)
		{
			vector = Controller.UPvr_GetTouchPadPosition(mainHand);
		}
		if ((vector - vecOrigin).sqrMagnitude >= 1f)
		{
			if (!isTouching)
			{
				lastTouchDownPos = vector;
				isTouching = true;
			}
			lastTouchUpPos.x = vector.x;
			if (Mathf.Abs(lastTouchUpPos.x - lastTouchDownPos.x) > ignoreDis)
			{
				Vector2 vector2 = new Vector2((lastTouchUpPos.x - lastTouchDownPos.x) * 10f, 0f);
				lastTouchDownPos.x = lastTouchUpPos.x;
				if (isClosed)
				{
					tarPos = currPos + vector2;
					isClosed = false;
				}
				else
				{
					tarPos += vector2;
				}
			}
		}
		else
		{
			lastTouchDownPos = vecOrigin;
			lastTouchUpPos = vecOrigin;
			isTouching = false;
			if ((double)scrollRect.horizontalScrollbar.value >= 0.999 || (double)scrollRect.horizontalScrollbar.value <= 0.0001)
			{
				isClosed = true;
			}
		}
	}

	private void ComputeRockerPos()
	{
		mainHand = Controller.UPvr_GetMainHandNess();
		currPos = scrollRect.content.localPosition;
		Vector2 vector = vecOriginNeo2;
		if (mainHand == 0 && Pvr_ControllerManager.controllerlink.controller0Connected)
		{
			vector = Controller.UPvr_GetTouchPadPosition(mainHand);
		}
		if (mainHand == 1 && Pvr_ControllerManager.controllerlink.controller1Connected)
		{
			vector = Controller.UPvr_GetTouchPadPosition(mainHand);
		}
		if (VerifyNeo2TouchValid(vector) && (vector - vecOriginNeo2).sqrMagnitude >= 1f)
		{
			if (!isTouching)
			{
				lastTouchDownPos = vector;
				isTouching = true;
			}
			lastTouchUpPos.x = vector.x;
			if (Mathf.Abs(lastTouchUpPos.x - lastTouchDownPos.x) > ignoreDis)
			{
				Vector2 vector2 = new Vector2((lastTouchUpPos.x - lastTouchDownPos.x) * 10f, 0f);
				lastTouchDownPos.x = lastTouchUpPos.x;
				if (isClosed)
				{
					tarPos = currPos + vector2;
					isClosed = false;
				}
				else
				{
					tarPos += vector2;
				}
			}
		}
		else
		{
			lastTouchDownPos = vecOriginNeo2;
			lastTouchUpPos = vecOriginNeo2;
			isTouching = false;
			if ((double)scrollRect.horizontalScrollbar.value >= 0.999 || (double)scrollRect.horizontalScrollbar.value <= 0.0001)
			{
				isClosed = true;
			}
		}
	}

	private bool VerifyNeo2TouchValid(Vector2 nowTouchPos)
	{
		if (nowTouchPos.x > vecOriginNeo2.x && nowTouchPos.x > lastTouchDownPos.x)
		{
			return true;
		}
		if (nowTouchPos.x < vecOriginNeo2.x && nowTouchPos.x < lastTouchDownPos.x)
		{
			return true;
		}
		return false;
	}

	private void UpdatePos()
	{
		if (Controller.UPvr_GetKey(0, Pvr_KeyCode.TOUCHPAD) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TOUCHPAD))
		{
			ResetParameter();
		}
		else if (!isClosed && IsControllerConnect())
		{
			if ((double)scrollRect.horizontalScrollbar.value >= 0.9999 && tarPos.x <= currPos.x)
			{
				isClosed = true;
				return;
			}
			if ((double)scrollRect.horizontalScrollbar.value <= 0.0001 && tarPos.x >= currPos.x)
			{
				isClosed = true;
				return;
			}
			currPos.x = Mathf.Lerp(currPos.x, tarPos.x, lerpSpeed * Time.deltaTime);
			currPos.y = Mathf.Lerp(currPos.y, tarPos.y, lerpSpeed * Time.deltaTime);
			scrollRect.content.localPosition = currPos;
		}
	}

	private void ResetParameter()
	{
		currPos = scrollRect.content.localPosition;
		tarPos = scrollRect.content.localPosition;
		isClosed = true;
	}

	private void Process()
	{
		for (int i = 0; i < Pvr_InputModule.pointers.Count; i++)
		{
			Pvr_UIPointer pvr_UIPointer = Pvr_InputModule.pointers[i];
			if (pvr_UIPointer.gameObject.activeInHierarchy && pvr_UIPointer.enabled)
			{
				isHoving = IsHovering(pvr_UIPointer);
			}
		}
	}

	private bool IsHovering(Pvr_UIPointer pointer)
	{
		if (!IsControllerConnect())
		{
			return false;
		}
		foreach (GameObject item in pointer.pointerEventData.hovered)
		{
			if (FindTree(item.transform))
			{
				mainHand = Controller.UPvr_GetMainHandNess();
				if (mainHand == 0 && Pvr_ControllerManager.controllerlink.controller0Connected)
				{
					return true;
				}
				if (mainHand == 1 && Pvr_ControllerManager.controllerlink.controller1Connected)
				{
					return true;
				}
			}
		}
		return false;
	}

	private bool FindTree(Transform tran)
	{
		if (tran == base.transform || tran == tranViewport)
		{
			return true;
		}
		if (tran.IsChildOf(tranViewport))
		{
			return true;
		}
		return false;
	}
}
public class Pvr_TouchVisual : MonoBehaviour
{
	[HideInInspector]
	public ControllerDevice currentDevice;

	[HideInInspector]
	public ControllerVariety variety;

	private MeshRenderer touchRenderer;

	private void Start()
	{
		variety = base.transform.GetComponentInParent<Pvr_ControllerModuleInit>().Variety;
		currentDevice = GetComponentInParent<Pvr_ControllerVisual>().currentDevice;
		touchRenderer = GetComponent<MeshRenderer>();
	}

	private void Update()
	{
		ChangeEffects((variety != 0) ? 1 : 0);
	}

	private void ChangeEffects(int hand)
	{
		ControllerDevice controllerDevice = currentDevice;
		if (controllerDevice == ControllerDevice.G2)
		{
			if (Controller.UPvr_IsTouching(0))
			{
				touchRenderer.enabled = true;
				base.transform.localPosition = new Vector3(1.3f - Controller.UPvr_GetTouchPadPosition(hand).x * 0.01f, 1.6f, -1.7f - Controller.UPvr_GetTouchPadPosition(hand).y * 0.01f);
			}
			else
			{
				touchRenderer.enabled = false;
			}
		}
	}
}
public class DemoController : MonoBehaviour
{
	public delegate void showLoadingEventHandler();

	private Callback callback;

	private GameObject msg;

	private Pvr_UnitySDKManager picoVrManager;

	private string currentOrderID;

	public GameObject loading;

	public GameObject BG;

	public GameObject InputPanel;

	public static showLoadingEventHandler showLoading;

	private void Awake()
	{
		UnityEngine.Debug.Log(loading.name);
		UnityEngine.Debug.Log(BG.name);
		showLoading = (showLoadingEventHandler)Delegate.Combine(showLoading, new showLoadingEventHandler(StopLoading));
		InputManager.doEnter = (InputManager.doEnterEventHandler)Delegate.Combine(InputManager.doEnter, new InputManager.doEnterEventHandler(DoPayByCode));
		currentOrderID = "";
	}

	private void Start()
	{
		msg = GameObject.Find("MassageInfo");
		InitDelegate();
		callback = new Callback();
		picoVrManager = GameObject.Find("Pvr_UnitySDK").GetComponent<Pvr_UnitySDKManager>();
		InputPanel.SetActive(value: false);
	}

	private void Update()
	{
		if (picoVrManager != null && (Input.GetKeyDown(KeyCode.Y) || Input.GetKeyDown(KeyCode.Joystick1Button2)))
		{
			UnityEngine.Debug.Log("update");
			Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
		}
		if (Input.GetKeyDown(KeyCode.Joystick1Button1) || Input.GetKeyDown(KeyCode.Escape))
		{
			if (InputPanel.activeInHierarchy)
			{
				InputPanel.SetActive(value: false);
			}
			else
			{
				Application.Quit();
			}
		}
	}

	private void InitDelegate()
	{
		foreach (string item in new ArrayList { "Login", "GetUserAPI", "PayOne", "PayCode", "QueryOrder" })
		{
			GameObject btnObj = GameObject.Find(item);
			btnObj.GetComponent<Button>().onClick.AddListener(delegate
			{
				OnClick(btnObj);
			});
		}
	}

	private void OnClick(GameObject btnObj)
	{
		switch (btnObj.name)
		{
		case "Login":
			StartLoading();
			LoginSDK.Login();
			break;
		case "PayOne":
			CommonDic.getInstance().setParameters("subject", "game");
			CommonDic.getInstance().setParameters("body", "gamePay");
			CommonDic.getInstance().setParameters("order_id", getRamdomTestOrderID());
			CommonDic.getInstance().setParameters("total", "1");
			CommonDic.getInstance().setParameters("goods_tag", "game");
			CommonDic.getInstance().setParameters("notify_url", "www.picovr.com");
			CommonDic.getInstance().setParameters("pay_code", "");
			StartLoading();
			PicoPaymentSDK.Pay(CommonDic.getInstance().PayOrderString());
			break;
		case "PayCode":
			InputPanel.SetActive(value: true);
			break;
		case "QueryOrder":
			StartLoading();
			PicoPaymentSDK.QueryOrder(currentOrderID);
			break;
		case "GetUserAPI":
			StartLoading();
			LoginSDK.GetUserAPI();
			break;
		}
	}

	public string getRamdomTestOrderID()
	{
		currentOrderID = (UnityEngine.Random.value * 65535f).ToString();
		return currentOrderID;
	}

	private void StartLoading()
	{
		loading.SetActive(value: true);
		BG.SetActive(value: true);
	}

	public void StopLoading()
	{
		if ((bool)loading && (bool)BG)
		{
			loading.SetActive(value: false);
			BG.SetActive(value: false);
		}
		else
		{
			UnityEngine.Debug.LogError("用户自定义，非演示demo");
		}
	}

	public void DoPayByCode()
	{
		CommonDic.getInstance().setParameters("subject", "game");
		CommonDic.getInstance().setParameters("body", "gamePay");
		CommonDic.getInstance().setParameters("order_id", getRamdomTestOrderID());
		CommonDic.getInstance().setParameters("total", "0");
		CommonDic.getInstance().setParameters("goods_tag", "game");
		CommonDic.getInstance().setParameters("notify_url", "www.picovr.com");
		CommonDic.getInstance().setParameters("pay_code", GameObject.Find("CodeText").GetComponent<Text>().text);
		UnityEngine.Debug.Log("商品码支付" + GameObject.Find("CodeText").GetComponent<Text>().text);
		StartLoading();
		GameObject.Find("CodeText").GetComponent<Text>().text = "";
		InputPanel.SetActive(value: false);
		PicoPaymentSDK.Pay(CommonDic.getInstance().PayOrderString());
	}

	private bool VerifyLocalToken()
	{
		if (CommonDic.getInstance().access_token.Equals(""))
		{
			GameObject.Find("MassageInfo").GetComponent<Text>().text = "{code:exception,msg:请先登录}";
			currentOrderID = "";
			StopLoading();
			return false;
		}
		return true;
	}
}
public class LoadingRatation : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
		base.gameObject.transform.Rotate(new Vector3(0f, 0f, -4f));
	}
}
public class InputManager : MonoBehaviour
{
	public delegate void doEnterEventHandler();

	public static doEnterEventHandler doEnter;

	private StringBuilder sb = new StringBuilder();

	private ArrayList btnsName = new ArrayList();

	private GameObject enter;

	private void Awake()
	{
		InitKeyBoard();
	}

	private void Start()
	{
	}

	private void Update()
	{
	}

	private void InitKeyBoard()
	{
		btnsName.Add("1");
		btnsName.Add("2");
		btnsName.Add("3");
		btnsName.Add("4");
		btnsName.Add("5");
		btnsName.Add("6");
		btnsName.Add("7");
		btnsName.Add("8");
		btnsName.Add("9");
		btnsName.Add("0");
		btnsName.Add("Q");
		btnsName.Add("W");
		btnsName.Add("E");
		btnsName.Add("R");
		btnsName.Add("T");
		btnsName.Add("Y");
		btnsName.Add("U");
		btnsName.Add("I");
		btnsName.Add("O");
		btnsName.Add("P");
		btnsName.Add("A");
		btnsName.Add("S");
		btnsName.Add("D");
		btnsName.Add("F");
		btnsName.Add("G");
		btnsName.Add("H");
		btnsName.Add("J");
		btnsName.Add("K");
		btnsName.Add("L");
		btnsName.Add("Z");
		btnsName.Add("X");
		btnsName.Add("C");
		btnsName.Add("V");
		btnsName.Add("B");
		btnsName.Add("N");
		btnsName.Add("M");
		btnsName.Add("Clear");
		btnsName.Add("Capslock");
		btnsName.Add("Enter");
		foreach (string item in btnsName)
		{
			GameObject btnObj = GameObject.Find(item);
			btnObj.GetComponent<Button>().onClick.AddListener(delegate
			{
				OnClick(btnObj);
			});
		}
		enter = GameObject.Find("Enter");
		enter.SetActive(sb.Length > 0);
	}

	private void OnClick(GameObject btnObj)
	{
		if (btnObj.name.Equals("Capslock"))
		{
			if (GameObject.Find("Q").transform.GetChild(0).GetComponent<Text>().text.Equals("Q"))
			{
				DoCapslock(IsUpper: true);
			}
			else
			{
				DoCapslock(IsUpper: false);
			}
		}
		else if (btnObj.name.Equals("Clear"))
		{
			GameObject.Find("CodeText").GetComponent<Text>().text = "";
			ClearBuffer();
		}
		else if (btnObj.name.Equals("Enter"))
		{
			ClearBuffer();
			doEnter();
		}
		else
		{
			EnterChar(btnObj.transform.GetChild(0).GetComponent<Text>().text);
		}
	}

	private void EnterChar(string s)
	{
		sb.Append(s);
		GameObject.Find("CodeText").GetComponent<Text>().text = sb.ToString();
		enter.SetActive(sb.Length > 0);
	}

	private void DoCapslock(bool IsUpper)
	{
		if (IsUpper)
		{
			foreach (string item in btnsName)
			{
				Text component = GameObject.Find(item).transform.GetChild(0).GetComponent<Text>();
				component.text = component.text.ToLower();
			}
			return;
		}
		foreach (string item2 in btnsName)
		{
			Text component2 = GameObject.Find(item2).transform.GetChild(0).GetComponent<Text>();
			component2.text = component2.text.ToUpper();
		}
	}

	private void ClearBuffer()
	{
		sb.Remove(0, sb.Length);
		enter.SetActive(sb.Length > 0);
	}
}
public class Callback : MonoBehaviour
{
	private static string IS_SUCCESS = "isSuccess";

	private static string MSG = "msg";

	private static string CODE = "code";

	public void LoginCallback(string LoginInfo)
	{
		JsonData jsonData = JsonMapper.ToObject(LoginInfo);
		SetMassage(LoginInfo);
		DemoController.showLoading();
		if (jsonData[IS_SUCCESS] != null)
		{
			CommonDic.getInstance().isSuccess = jsonData[IS_SUCCESS].ToString();
		}
		if (jsonData[MSG] != null)
		{
			CommonDic.getInstance().loginMsg = jsonData[MSG].ToString();
		}
		UnityEngine.Debug.Log("调用login回调:" + LoginInfo);
	}

	public void QueryOrPayCallback(string queryOrPayInfo)
	{
		JsonData jsonData = JsonMapper.ToObject(queryOrPayInfo);
		if (jsonData[CODE] != null)
		{
			CommonDic.getInstance().code = jsonData["code"].ToString();
		}
		if (jsonData[MSG] != null)
		{
			CommonDic.getInstance().msg = jsonData["msg"].ToString();
		}
		if (jsonData != null)
		{
			CommonDic.getInstance().order_info = jsonData[1].ToString();
		}
		SetMassage(queryOrPayInfo);
		DemoController.showLoading();
		UnityEngine.Debug.Log("调用pay回调:" + queryOrPayInfo);
	}

	public void UserInfoCallback(string userInfo)
	{
		CommonDic.getInstance().user_info = userInfo;
		SetMassage(userInfo);
		DemoController.showLoading();
		UnityEngine.Debug.Log("调用userInfo回调:" + userInfo);
	}

	public void SetMassage(string massage)
	{
		if (!GetCurrentGameObject().Equals(null))
		{
			GetCurrentGameObject().GetComponent<Text>().text = massage;
		}
		else
		{
			UnityEngine.Debug.LogError("无接收该Message的控件");
		}
	}

	public GameObject GetCurrentGameObject()
	{
		return GameObject.Find("MassageInfo");
	}

	public void ActivityForResultCallback(string activity)
	{
		PicoPaymentSDK.jo.Call("authCallback", activity);
	}
}
public class CommonDic
{
	private static CommonDic dic;

	private static Dictionary<string, string> mydic;

	private string _app_ID;

	private string _app_Key;

	private string _user_token;

	private string _access_token = "";

	private string _open_id;

	private string _refresh_token;

	private string _expires_in;

	private string _user_info;

	private string _subject;

	private string _body;

	private string _order_id;

	private string _total;

	private string _goods_tag;

	private string _notify_url;

	private string _trade_type;

	private string _pay_code = "";

	private string _order_info;

	private string _code;

	private string _msg = "null";

	private string _merchant_ID;

	private string _payKey;

	private string _isSuucess;

	private string _loginMsg;

	public string subject
	{
		get
		{
			return _subject;
		}
		set
		{
			_subject = value;
		}
	}

	public string body
	{
		get
		{
			return _body;
		}
		set
		{
			_body = value;
		}
	}

	public string order_id
	{
		get
		{
			return _order_id;
		}
		set
		{
			_order_id = value;
		}
	}

	public string total
	{
		get
		{
			return _total;
		}
		set
		{
			_total = value;
		}
	}

	public string goods_tag
	{
		get
		{
			return _goods_tag;
		}
		set
		{
			_goods_tag = value;
		}
	}

	public string notify_url
	{
		get
		{
			return _notify_url;
		}
		set
		{
			_notify_url = value;
		}
	}

	public string pay_code
	{
		get
		{
			return _pay_code;
		}
		set
		{
			_pay_code = value;
		}
	}

	public string trade_type
	{
		get
		{
			return _trade_type;
		}
		set
		{
			_trade_type = value;
		}
	}

	public string user_token
	{
		get
		{
			return _user_token;
		}
		set
		{
			_user_token = value;
		}
	}

	public string access_token
	{
		get
		{
			return _access_token;
		}
		set
		{
			_access_token = value;
		}
	}

	public string open_id
	{
		get
		{
			return _open_id;
		}
		set
		{
			_open_id = value;
		}
	}

	public string refresh_token
	{
		get
		{
			return _refresh_token;
		}
		set
		{
			_refresh_token = value;
		}
	}

	public string expires_in
	{
		get
		{
			return _expires_in;
		}
		set
		{
			_expires_in = value;
		}
	}

	public string isSuccess
	{
		get
		{
			return _isSuucess;
		}
		set
		{
			_isSuucess = value;
		}
	}

	public string loginMsg
	{
		get
		{
			return _loginMsg;
		}
		set
		{
			_loginMsg = value;
		}
	}

	public string user_info
	{
		get
		{
			return _user_info;
		}
		set
		{
			_user_info = value;
		}
	}

	public string order_info
	{
		get
		{
			return _order_info;
		}
		set
		{
			_order_info = value;
		}
	}

	public string code
	{
		get
		{
			return _code;
		}
		set
		{
			_code = value;
		}
	}

	public string msg
	{
		get
		{
			return _msg;
		}
		set
		{
			_msg = value;
		}
	}

	public string app_ID
	{
		get
		{
			return _app_ID;
		}
		set
		{
			_app_ID = value;
		}
	}

	public string app_Key
	{
		get
		{
			return _app_Key;
		}
		set
		{
			_app_Key = value;
		}
	}

	public string merchant_ID
	{
		get
		{
			return _merchant_ID;
		}
		set
		{
			_merchant_ID = value;
		}
	}

	public string paykey
	{
		get
		{
			return _payKey;
		}
		set
		{
			_payKey = value;
		}
	}

	public static CommonDic getInstance()
	{
		if (dic == null)
		{
			dic = new CommonDic();
		}
		if (mydic == null)
		{
			mydic = new Dictionary<string, string>();
			InitDicData(mydic);
		}
		return dic;
	}

	public Dictionary<string, string> getDic()
	{
		return mydic;
	}

	public void setParameters(string name, string value)
	{
		if (name.Equals("subject"))
		{
			subject = value;
		}
		if (name.Equals("body"))
		{
			body = value;
		}
		if (name.Equals("order_id"))
		{
			order_id = value;
		}
		if (name.Equals("total"))
		{
			total = value;
		}
		if (name.Equals("goods_tag"))
		{
			goods_tag = value;
		}
		if (name.Equals("notify_url"))
		{
			notify_url = value;
		}
		if (name.Equals("trade_type"))
		{
			trade_type = value;
		}
		if (name.Equals("pay_code"))
		{
			pay_code = value;
		}
	}

	public string PayOrderString()
	{
		return JsonMapper.ToJson(getInstance());
	}

	public static void InitDicData(Dictionary<string, string> mydic)
	{
		mydic.Add("00000", "网络异常");
		mydic.Add("10000", "登录成功");
		mydic.Add("10001", "用户未登陆");
		mydic.Add("10002", "请输入正确金额");
		mydic.Add("10003", "登陆过期，请重新登陆");
		mydic.Add("11000", "商户验证成功");
		mydic.Add("11001", "商户验证失败");
		mydic.Add("11002", "用户验证参数错误或请求过期");
		mydic.Add("11003", "商户未验证");
		mydic.Add("12000", "支付成功");
		mydic.Add("12001", "支付失败");
		mydic.Add("12003", "P币不足");
		mydic.Add("12004", "余额可用");
		mydic.Add("13000", "生成订单");
		mydic.Add("13001", "获取数据失败");
		mydic.Add("13002", "生成订单失败");
		mydic.Add("14000", "查询订单成功");
		mydic.Add("14001", "订单不存在/有误");
		mydic.Add("14002", "用户取消支付操作");
		mydic.Add("15000", "未输入商品信息");
		mydic.Add("15001", "未输入预付ID");
		mydic.Add("15002", "请输入Pico支付订单号或商户订单号");
		mydic.Add("NOAUTH", "商户无此接口权限");
		mydic.Add("SYSTEMERROR", "系统错误");
		mydic.Add("APP_ID_NOT_EXIST", "APP_ID不存在");
		mydic.Add("MCHID_NOT_EXIST", "MCHID不存在");
		mydic.Add("APP_ID_MCHID_NOT_MATCH", "app_id和mch_id不匹配ID");
		mydic.Add("LACK_PARAMS", "缺少参数");
		mydic.Add("SIGNERROR", "签名错误");
		mydic.Add("NO_DATA", "没有查询到数据");
	}
}
public class LoginSDK
{
	public static void Login()
	{
		PicoPaymentSDK.Login();
	}

	public static void GetUserAPI()
	{
		PicoPaymentSDK.GetUserAPI();
	}
}
public class PicoPaymentSDK
{
	private static AndroidJavaObject _jo = new AndroidJavaObject("com.pico.loginpaysdk.UnityInterface");

	public static AndroidJavaObject jo
	{
		get
		{
			return _jo;
		}
		set
		{
			_jo = value;
		}
	}

	public static void Login()
	{
		AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		jo.Call("init", @static);
		jo.Call("authSSO");
	}

	public static void Pay(string payOrderJson)
	{
		AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		jo.Call("init", @static);
		jo.Call("pay", payOrderJson);
	}

	public static void QueryOrder(string orderId)
	{
		AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		jo.Call("init", @static);
		jo.Call("queryOrder", orderId);
	}

	public static void GetUserAPI()
	{
		AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		jo.Call("init", @static);
		jo.Call("getUserAPI");
	}
}
public class Pvr_ToBService : MonoBehaviour
{
	public Text deviceInfoText;

	private void Awake()
	{
		InitToBService();
	}

	private void Start()
	{
		BindToBService();
	}

	private void OnDestory()
	{
		UnBindToBService();
	}

	private void InitToBService()
	{
		ToBService.UPvr_InitToBService();
		ToBService.UPvr_SetUnityObjectName(base.name);
	}

	private void BindToBService()
	{
		ToBService.UPvr_BindToBService();
	}

	private void UnBindToBService()
	{
		ToBService.UPvr_UnBindToBService();
	}

	private void BoolCallback(string value)
	{
		if (ToBService.BoolCallback != null)
		{
			ToBService.BoolCallback(bool.Parse(value));
		}
		ToBService.BoolCallback = null;
	}

	private void IntCallback(string value)
	{
		if (ToBService.IntCallback != null)
		{
			ToBService.IntCallback(int.Parse(value));
		}
		ToBService.IntCallback = null;
	}

	private void LongCallback(string value)
	{
		if (ToBService.LongCallback != null)
		{
			ToBService.LongCallback(int.Parse(value));
		}
		ToBService.LongCallback = null;
	}

	public void StateGetDeviceInfo()
	{
		string text = ToBService.UPvr_StateGetDeviceInfo(PBS_SystemInfoEnum.PUI_VERSION);
		deviceInfoText.text = "PUI_VERSION:" + text;
	}

	public void ControlSetDeviceAction()
	{
		ToBService.UPvr_ControlSetDeviceAction(PBS_DeviceControlEnum.DEVICE_CONTROL_SHUTDOWN, ControlSetDeviceActionCallBack);
	}

	private void ControlSetDeviceActionCallBack(int value)
	{
		UnityEngine.Debug.Log("ControlSetDeviceActionCallBack : " + value);
	}

	public void AppManager()
	{
		ToBService.UPvr_ControlAPPManger(PBS_PackageControlEnum.PACKAGE_SILENCE_UNINSTALL, "com.pico.ipd.test", AppManagerCallBack);
	}

	private void AppManagerCallBack(int value)
	{
		UnityEngine.Debug.Log("AppManagerCallBack : " + value);
	}
}
public class PLOG : MonoBehaviour
{
	public static int logLevel;

	public static void getConfigTraceLevel()
	{
		Render.UPvr_GetIntConfig(6, ref logLevel);
	}

	public static void D(string msg)
	{
		if (logLevel > 2)
		{
			UnityEngine.Debug.Log(msg);
		}
	}

	public static void I(string msg)
	{
		if (logLevel > 1)
		{
			UnityEngine.Debug.Log(msg);
		}
	}

	public static void W(string msg)
	{
		if (logLevel > 0)
		{
			UnityEngine.Debug.LogWarning(msg);
		}
	}

	public static void E(string msg)
	{
		UnityEngine.Debug.LogError(msg);
	}
}
public class CPicoSDKSettingAsset : ScriptableObject
{
	public bool IgnoreSDKSetting;

	public bool DontshowBuildWaring;

	public bool AppIDChecked;
}
[Serializable]
public class Pvr_UnitySDKProjectSetting : ScriptableObject
{
	public RenderTextureAntiAliasing rtAntiAlising;

	public RenderTextureDepth rtBitDepth;

	public RenderTextureFormat rtFormat;

	public bool usedefaultRenderTexture;

	public Vector2 customRTSize;

	public bool usedefaultfps;

	public int customfps;

	public bool usesinglepass;

	public bool usecontentprotect;

	public static Pvr_UnitySDKProjectSetting GetProjectConfig()
	{
		return Resources.Load<Pvr_UnitySDKProjectSetting>("ProjectSetting");
	}
}
public sealed class Pvr_UnitySDKPlatformSetting : ScriptableObject
{
	public enum simulationType
	{
		Null,
		Invalid,
		Valid
	}

	[SerializeField]
	private bool entitlementchecksimulation;

	[SerializeField]
	private bool startTimeEntitlementCheck;

	[SerializeField]
	public string appID;

	public List<string> deviceSN = new List<string>();

	private static Pvr_UnitySDKPlatformSetting instance;

	public static bool Entitlementchecksimulation
	{
		get
		{
			return Instance.entitlementchecksimulation;
		}
		set
		{
			if (Instance.entitlementchecksimulation != value)
			{
				Instance.entitlementchecksimulation = value;
			}
		}
	}

	public static bool StartTimeEntitlementCheck
	{
		get
		{
			return Instance.startTimeEntitlementCheck;
		}
		set
		{
			if (Instance.startTimeEntitlementCheck != value)
			{
				Instance.startTimeEntitlementCheck = value;
			}
		}
	}

	public static Pvr_UnitySDKPlatformSetting Instance
	{
		get
		{
			if (instance == null)
			{
				instance = Resources.Load<Pvr_UnitySDKPlatformSetting>("PlatformSettings");
			}
			return instance;
		}
		set
		{
			instance = value;
		}
	}
}
public class Pvr_UnitySDKManager : MonoBehaviour
{
	public delegate void EntitlementCheckResult(int ReturnValue);

	public static PlatForm platform;

	private static Pvr_UnitySDKManager sdk;

	[HideInInspector]
	public float EyesAspect = 1f;

	[HideInInspector]
	public int posStatus;

	[HideInInspector]
	public bool ismirroring;

	[HideInInspector]
	public Vector3 resetBasePos;

	[HideInInspector]
	public int trackingmode = -1;

	[HideInInspector]
	public int systemprop = -1;

	[HideInInspector]
	public bool systemFPS;

	[HideInInspector]
	public float[] headData = new float[7];

	[SerializeField]
	private bool rotfoldout;

	[SerializeField]
	private bool hmdOnlyrot;

	[SerializeField]
	private bool controllerOnlyrot;

	[SerializeField]
	private TrackingOrigin trackingOrigin;

	public bool ResetTrackerOnLoad;

	[HideInInspector]
	public Vector3 leftEyeOffset;

	[HideInInspector]
	public Vector3 rightEyeOffset;

	[HideInInspector]
	public Rect leftEyeRect;

	[HideInInspector]
	public Rect rightEyeRect;

	[HideInInspector]
	public Matrix4x4 leftEyeView;

	[HideInInspector]
	public Matrix4x4 rightEyeView;

	[HideInInspector]
	public Pvr_UnitySDKEditor pvr_UnitySDKEditor;

	[SerializeField]
	private bool vrModeEnabled = true;

	[HideInInspector]
	public Material Eyematerial;

	[HideInInspector]
	public Material Middlematerial;

	[HideInInspector]
	public bool newPicovrTriggered;

	[SerializeField]
	private bool showFPS;

	[HideInInspector]
	public Vector3 neckOffset = new Vector3(0f, 0.075f, 0.0805f);

	[SerializeField]
	private bool pVRNeck = true;

	[HideInInspector]
	public bool UseCustomNeckPara;

	[HideInInspector]
	public bool onResume;

	[HideInInspector]
	public bool isEnterVRMode;

	public bool isHasController;

	public Pvr_UnitySDKConfigProfile pvr_UnitySDKConfig;

	private GameObject calltoast;

	private GameObject msgtoast;

	private GameObject lowhmdBatterytoast;

	private GameObject lowphoneBatterytoast;

	private GameObject LowPhoneHealthtoast;

	private GameObject LowcontrollerBatterytoast;

	private bool lowControllerpowerstate;

	private float controllerpowershowtime;

	private bool UseToast = true;

	private int iPhoneHMDModeEnabled;

	private GameObject G3LiteTips;

	[SerializeField]
	private bool monoscopic;

	private bool mIsAndroid7;

	public static Func<bool> eventEnterVRMode;

	[HideInInspector]
	public bool ShowVideoSeethrough;

	public int SystemDebugFFRLevel = -1;

	public int SystemFFRLevel = -1;

	public int AppCheckResult = 100;

	public Action longPressHomeKeyAction;

	public static Pvr_UnitySDKManager SDK
	{
		get
		{
			if (sdk == null)
			{
				sdk = UnityEngine.Object.FindObjectOfType<Pvr_UnitySDKManager>();
			}
			return sdk;
		}
	}

	public bool Rotfoldout
	{
		get
		{
			return rotfoldout;
		}
		set
		{
			if (value != rotfoldout)
			{
				rotfoldout = value;
			}
		}
	}

	public bool HmdOnlyrot
	{
		get
		{
			return hmdOnlyrot;
		}
		set
		{
			if (value != hmdOnlyrot)
			{
				hmdOnlyrot = value;
			}
		}
	}

	public bool ControllerOnlyrot
	{
		get
		{
			return controllerOnlyrot;
		}
		set
		{
			if (value != controllerOnlyrot)
			{
				controllerOnlyrot = value;
			}
		}
	}

	public TrackingOrigin TrackingOrigin
	{
		get
		{
			return trackingOrigin;
		}
		set
		{
			if (value != trackingOrigin)
			{
				trackingOrigin = value;
				Sensor.UPvr_SetTrackingOriginType(value);
			}
		}
	}

	[HideInInspector]
	public bool VRModeEnabled
	{
		get
		{
			return vrModeEnabled;
		}
		set
		{
			if (value != vrModeEnabled)
			{
				vrModeEnabled = value;
			}
		}
	}

	[HideInInspector]
	public bool picovrTriggered { get; set; }

	public bool ShowFPS
	{
		get
		{
			return showFPS;
		}
		set
		{
			if (value != showFPS)
			{
				showFPS = value;
			}
		}
	}

	public bool PVRNeck
	{
		get
		{
			return pVRNeck;
		}
		set
		{
			if (value != pVRNeck)
			{
				pVRNeck = value;
			}
		}
	}

	[HideInInspector]
	public bool Monoscopic
	{
		get
		{
			return monoscopic;
		}
		set
		{
			if (value != monoscopic)
			{
				monoscopic = value;
				Render.UPvr_SetMonoMode(monoscopic);
			}
		}
	}

	public static event EntitlementCheckResult EntitlementCheckResultEvent;

	public void ChangeDefaultCustomRtSize(int w, int h)
	{
		Pvr_UnitySDKProjectSetting.GetProjectConfig().customRTSize = new Vector2(w, h);
	}

	public Vector3 EyeOffset(Eye eye)
	{
		if (eye != 0)
		{
			return rightEyeOffset;
		}
		return leftEyeOffset;
	}

	public Rect EyeRect(Eye eye)
	{
		if (eye != 0)
		{
			return rightEyeRect;
		}
		return leftEyeRect;
	}

	private bool SDKManagerInit()
	{
		if (SDKManagerInitConfigProfile())
		{
			mIsAndroid7 = SystemInfo.operatingSystem.Contains("Android OS 7.");
			PLOG.I("Android 7 = " + mIsAndroid7);
			if (SDKManagerInitCoreAbility())
			{
				return true;
			}
			return false;
		}
		return false;
	}

	private bool SDKManagerInitCoreAbility()
	{
		Sensor.UPvr_SetTrackingOriginType(trackingOrigin);
		Render.UPvr_SetMonoMode(monoscopic);
		if (Pvr_UnitySDKRender.Instance == null)
		{
			PLOG.I("pvr_UnitySDKRender init failed");
		}
		if (Pvr_UnitySDKSensor.Instance == null)
		{
			PLOG.I("pvr_UnitySDKSensor init failed");
		}
		Pvr_UnitySDKAPI.System.UPvr_StartHomeKeyReceiver(base.gameObject.name);
		return true;
	}

	public void smsReceivedCallback(string msg)
	{
		PLOG.I("PvrLog MSG" + msg);
		JsonData jsonData = JsonMapper.ToObject(msg);
		string text = "";
		if (msg.Contains("messageSender"))
		{
			text = (string)jsonData["messageSender"];
		}
		string text2 = "";
		if (msg.Contains("messageAdr"))
		{
			text2 = (string)jsonData["messageAdr"];
			if (text2.Substring(0, 3) == "+82")
			{
				text2 = "0" + text2.Remove(0, 3);
				text2 = TransformNumber(text2);
			}
			else if (text2.Substring(0, 1) != "+")
			{
				text2 = TransformNumber(text2);
			}
		}
		if (UseToast)
		{
			msgtoast.transform.Find("number").GetComponent<Text>().text = text2;
			msgtoast.transform.Find("name").GetComponent<Text>().text = text;
			if (text.Length == 0)
			{
				msgtoast.transform.Find("number").transform.localPosition = new Vector3(0f, 0f, 0f);
			}
			else
			{
				msgtoast.transform.Find("number").transform.localPosition = new Vector3(60f, 0f, 0f);
			}
			StartCoroutine(ToastManager(2, state: true, 0f));
			StartCoroutine(ToastManager(2, state: false, 5f));
		}
	}

	public void phoneStateCallback(string state)
	{
		PLOG.I("PvrLog phone" + state);
		JsonData jsonData = JsonMapper.ToObject(state);
		string text = "";
		if (state.Contains("phoneNumber"))
		{
			text = (string)jsonData["phoneNumber"];
			if (text.Substring(0, 3) == "+82")
			{
				text = "0" + text.Remove(0, 3);
				text = TransformNumber(text);
			}
			else if (text.Substring(0, 1) != "+")
			{
				text = TransformNumber(text);
			}
		}
		string text2 = "";
		if (state.Contains("contactName"))
		{
			text2 = (string)jsonData["contactName"];
		}
		if (UseToast)
		{
			calltoast.transform.Find("number").GetComponent<Text>().text = text;
			calltoast.transform.Find("name").GetComponent<Text>().text = text2;
			if (text2.Length == 0)
			{
				calltoast.transform.Find("number").transform.localPosition = new Vector3(0f, 0f, 0f);
			}
			else
			{
				calltoast.transform.Find("number").transform.localPosition = new Vector3(60f, 0f, 0f);
			}
			StartCoroutine(ToastManager(1, state: true, 0f));
			StartCoroutine(ToastManager(1, state: false, 5f));
		}
	}

	public void phoneBatteryStateCallback(string state)
	{
		PLOG.I("PvrLog phoneBatteryState" + state);
		JsonData jsonData = JsonMapper.ToObject(state);
		string value = "";
		if (state.Contains("phoneBatteryLevel"))
		{
			value = (string)jsonData["phoneBatteryLevel"];
		}
		string value2 = "";
		if (state.Contains("phoneBatteryHealth"))
		{
			value2 = (string)jsonData["phoneBatteryHealth"];
		}
		if (!UseToast)
		{
			return;
		}
		if (Convert.ToInt16(value) <= 5)
		{
			if (!lowhmdBatterytoast.activeSelf)
			{
				StartCoroutine(ToastManager(4, state: true, 0f));
				StartCoroutine(ToastManager(4, state: false, 3f));
			}
			else
			{
				StartCoroutine(ToastManager(4, state: true, 5f));
				StartCoroutine(ToastManager(4, state: false, 8f));
			}
		}
		if (Convert.ToInt16(value2) == 3)
		{
			StartCoroutine(ToastManager(5, state: true, 0f));
			StartCoroutine(ToastManager(5, state: false, 5f));
		}
	}

	public void hmdLowBatteryCallback(string level)
	{
		PLOG.I("PvrLog hmdLowBatteryCallback" + level);
		if (UseToast)
		{
			if (!lowphoneBatterytoast.activeSelf)
			{
				StartCoroutine(ToastManager(3, state: true, 0f));
				StartCoroutine(ToastManager(3, state: false, 3f));
			}
			else
			{
				StartCoroutine(ToastManager(3, state: true, 5f));
				StartCoroutine(ToastManager(3, state: false, 8f));
			}
		}
	}

	private string TransformNumber(string number)
	{
		if (number.Length == 11)
		{
			string text = number.Substring(0, 3);
			string text2 = number.Substring(3, 4);
			string text3 = number.Substring(7, 4);
			number = text + "-" + text2 + "-" + text3;
		}
		else if (number.Length == 10)
		{
			if (number.Substring(1, 1) == "1")
			{
				string text4 = number.Substring(0, 3);
				string text5 = number.Substring(3, 3);
				string text6 = number.Substring(6, 4);
				number = text4 + "-" + text5 + "-" + text6;
			}
			else
			{
				string text7 = number.Substring(0, 2);
				string text8 = number.Substring(2, 4);
				string text9 = number.Substring(6, 4);
				number = text7 + "-" + text8 + "-" + text9;
			}
		}
		else if (number.Length == 9)
		{
			if (number.Substring(1, 1) == "2")
			{
				string text10 = number.Substring(0, 2);
				string text11 = number.Substring(2, 3);
				string text12 = number.Substring(5, 4);
				number = text10 + "-" + text11 + "-" + text12;
			}
			else
			{
				number = "+82" + number.Remove(0, 1);
			}
		}
		return number;
	}

	public void onHmdOrientationReseted()
	{
	}

	private IEnumerator ToastManager(int type, bool state, float time)
	{
		yield return new WaitForSeconds(time);
		switch (type)
		{
		case 1:
			calltoast.SetActive(state);
			break;
		case 2:
			msgtoast.SetActive(state);
			break;
		case 3:
			lowhmdBatterytoast.SetActive(state);
			break;
		case 4:
			lowphoneBatterytoast.SetActive(state);
			break;
		case 5:
			LowPhoneHealthtoast.SetActive(state);
			break;
		case 6:
			LowcontrollerBatterytoast.SetActive(state);
			break;
		}
	}

	private void CheckControllerStateForG2(string state)
	{
		if (iPhoneHMDModeEnabled == 1 && Convert.ToBoolean(Convert.ToInt16(state)) && Controller.UPvr_GetControllerPower(0) == 0 && Pvr_ControllerManager.controllerlink.Controller0.Rotation.eulerAngles != Vector3.zero)
		{
			StartCoroutine(ToastManager(6, state: true, 0f));
			StartCoroutine(ToastManager(6, state: false, 3f));
		}
	}

	public void notificationCallback(string data)
	{
		JsonData jsonData = JsonMapper.ToObject(data);
		if (G3LiteTips == null)
		{
			G3LiteTips = UnityEngine.Object.Instantiate(Resources.Load("Prefabs/G3LiteTips") as GameObject, base.transform.Find("Head"), worldPositionStays: false);
		}
		JsonData jsonData2 = JsonMapper.ToObject(jsonData["str"].ToString());
		switch ((int)jsonData["type"])
		{
		case 0:
			SetProperty(0, jsonData2, "Sms");
			break;
		case 1:
			SetProperty(1, jsonData2, "Call");
			break;
		case 2:
			SetProperty(2, jsonData2, "Warnning");
			break;
		case 3:
			SetProperty(3, jsonData2, "Warnning");
			break;
		case 4:
			SetProperty(4, jsonData2, "Warnning");
			break;
		case 5:
		{
			Transform transform = G3LiteTips.transform.Find("Onlyimage");
			SetBaseProperty(transform, jsonData2["General"], "");
			SetImageProperty(transform, jsonData2["General"], "");
			transform.gameObject.SetActive(value: true);
			StartCoroutine(G3TipsManager(transform.gameObject, (int)jsonData2["General"]["time"]));
			break;
		}
		case -1:
			break;
		}
	}

	private Sprite LoadSprite(Vector2 size, string filepath)
	{
		int width = (int)size.x;
		int height = (int)size.y;
		Texture2D texture2D = new Texture2D(width, height);
		texture2D.LoadImage(ReadTex(filepath));
		return Sprite.Create(texture2D, new Rect(0f, 0f, texture2D.width, texture2D.height), new Vector2(0.5f, 0.5f));
	}

	private byte[] ReadTex(string path)
	{
		if (path == "")
		{
			return new byte[0];
		}
		FileStream fileStream = new FileStream(path, FileMode.Open, FileAccess.Read);
		fileStream.Seek(0L, SeekOrigin.Begin);
		byte[] array = new byte[fileStream.Length];
		fileStream.Read(array, 0, (int)fileStream.Length);
		fileStream.Close();
		fileStream.Dispose();
		fileStream = null;
		return array;
	}

	private void SetProperty(int type, JsonData data, string value)
	{
		Transform trans = G3LiteTips.transform.Find(value);
		SetBaseProperty(trans, data, "");
		SetImageProperty(trans, data, "");
		trans.gameObject.SetActive(value: true);
		StartCoroutine(G3TipsManager(trans.gameObject, (int)data["time"]));
		Transform transform = trans.transform.Find("icon");
		SetBaseProperty(transform, data, "icon_");
		SetImageProperty(transform, data, "icon_");
		Transform transform2 = trans.transform.Find("title");
		SetBaseProperty(transform2, data, "title_");
		SetTextProperty(transform2, data, "title_");
		if (type != 1)
		{
			Transform transform3 = trans.transform.Find("details");
			SetBaseProperty(transform3, data, "details_");
			SetTextProperty(transform3, data, "details_");
			Transform transform4 = trans.transform.Find("image1");
			SetBaseProperty(transform4, data, "image1_");
			SetImageProperty(transform4, data, "image1_");
		}
		if (type == 0 || type == 1)
		{
			Transform transform5 = trans.transform.Find("explain");
			SetBaseProperty(transform5, data, "explain_");
			SetTextProperty(transform5, data, "explain_");
			Transform transform6 = trans.transform.Find("source");
			SetBaseProperty(transform6, data, "source_");
			SetTextProperty(transform6, data, "source_");
		}
		if (type == 0)
		{
			Transform transform7 = trans.transform.Find("time");
			SetBaseProperty(transform7, data, "system_time_");
			SetTextProperty(transform7, data, "system_time_");
		}
		Transform transform8 = trans.transform.Find("Button");
		SetBaseProperty(transform8, data, "button_");
		SetImageProperty(transform8, data, "button_");
		transform8.GetComponent<Button>().onClick.AddListener(delegate
		{
			StartCoroutine(G3TipsManager(trans.gameObject, 0f));
		});
		Transform transform9 = transform8.transform.Find("Text");
		SetBaseProperty(transform9, data, "button_text_");
		SetTextProperty(transform9, data, "button_text_");
	}

	private void SetBaseProperty(Transform trans, JsonData data, string value)
	{
		string prop_name = value + "pos";
		string prop_name2 = value + "angles";
		string prop_name3 = value + "size";
		string prop_name4 = value + "scale";
		trans.GetComponent<RectTransform>().anchoredPosition3D = new Vector3(JsonToFloat(data[prop_name][0]), JsonToFloat(data[prop_name][1]), JsonToFloat(data[prop_name][2]));
		trans.GetComponent<RectTransform>().eulerAngles = new Vector3(JsonToFloat(data[prop_name2][0]), JsonToFloat(data[prop_name2][1]), JsonToFloat(data[prop_name2][2]));
		trans.GetComponent<RectTransform>().sizeDelta = new Vector2(JsonToFloat(data[prop_name3][0]), JsonToFloat(data[prop_name3][1]));
		trans.GetComponent<RectTransform>().localScale = new Vector3(JsonToFloat(data[prop_name4][0]), JsonToFloat(data[prop_name4][1]), JsonToFloat(data[prop_name4][2]));
	}

	private void SetImageProperty(Transform image, JsonData data, string value)
	{
		string prop_name = value + "sprite";
		string prop_name2 = value + "color";
		string prop_name3 = value + "size";
		image.GetComponent<UnityEngine.UI.Image>().sprite = LoadSprite(new Vector2(JsonToFloat(data[prop_name3][0]), JsonToFloat(data[prop_name3][1])), (string)data[prop_name]);
		image.GetComponent<UnityEngine.UI.Image>().color = new UnityEngine.Color(JsonToFloat(data[prop_name2][0]), JsonToFloat(data[prop_name2][1]), JsonToFloat(data[prop_name2][2]), JsonToFloat(data[prop_name2][3]));
	}

	private void SetTextProperty(Transform text, JsonData data, string value)
	{
		string prop_name = value + "color";
		string prop_name2 = value + "font_size";
		string prop_name3 = value + "font_style";
		string prop_name4 = value + "text";
		text.GetComponent<Text>().text = (string)data[prop_name4];
		text.GetComponent<Text>().color = new UnityEngine.Color(JsonToFloat(data[prop_name][0]), JsonToFloat(data[prop_name][1]), JsonToFloat(data[prop_name][2]), JsonToFloat(data[prop_name][3]));
		text.GetComponent<Text>().fontSize = (int)data[prop_name2];
		text.GetComponent<Text>().fontStyle = (FontStyle)(int)data[prop_name3];
	}

	private IEnumerator G3TipsManager(GameObject tip, float time)
	{
		yield return new WaitForSeconds(time);
		tip.SetActive(value: false);
	}

	private float JsonToFloat(JsonData data)
	{
		return Convert.ToSingle((string)data);
	}

	private bool SDKManagerInitFPS()
	{
		Transform[] componentsInChildren = GetComponentsInChildren<Transform>(includeInactive: true);
		GameObject gameObject = null;
		Transform[] array = componentsInChildren;
		foreach (Transform transform in array)
		{
			if (transform.gameObject.name == "FPS")
			{
				gameObject = transform.gameObject;
			}
		}
		if (gameObject != null)
		{
			if (systemFPS)
			{
				gameObject.SetActive(value: true);
				return true;
			}
			int res = 0;
			Render.UPvr_GetIntConfig(10, ref res);
			if (Convert.ToBoolean(res))
			{
				gameObject.SetActive(value: true);
				return true;
			}
			if (ShowFPS)
			{
				gameObject.SetActive(value: true);
				return true;
			}
			return false;
		}
		return false;
	}

	private bool SDKManagerInitConfigProfile()
	{
		pvr_UnitySDKConfig = Pvr_UnitySDKConfigProfile.Default;
		return true;
	}

	private bool SDKManagerInitEditor()
	{
		if (pvr_UnitySDKEditor == null)
		{
			pvr_UnitySDKEditor = base.gameObject.AddComponent<Pvr_UnitySDKEditor>();
		}
		else
		{
			pvr_UnitySDKEditor = null;
			pvr_UnitySDKEditor = base.gameObject.AddComponent<Pvr_UnitySDKEditor>();
		}
		return true;
	}

	private bool SDKManagerInitPara()
	{
		return true;
	}

	public void SDKManagerLongHomeKey()
	{
		if (Pvr_UnitySDKSensor.Instance == null)
		{
			return;
		}
		if (isHasController)
		{
			if (Controller.UPvr_GetControllerState(0) == ControllerState.Connected || Controller.UPvr_GetControllerState(1) == ControllerState.Connected)
			{
				Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(0, 1);
			}
			else
			{
				Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
			}
		}
		else
		{
			Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
		}
	}

	private void setLongHomeKey()
	{
		if (sdk.HmdOnlyrot)
		{
			if (Pvr_UnitySDKSensor.Instance != null)
			{
				PLOG.I(Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor() ? "Long Home Key to Reset Sensor Success!" : "Long Home Key to Reset Sensor Failed!");
			}
			return;
		}
		if (trackingmode == 4 || trackingmode == 5 || trackingmode == 6)
		{
			Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
		}
		else
		{
			if (trackingmode == 2 || trackingmode == 3)
			{
				if (isHasController && (Controller.UPvr_GetControllerState(0) == ControllerState.Connected || Controller.UPvr_GetControllerState(1) == ControllerState.Connected))
				{
					Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(0, 1);
				}
				else
				{
					Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
				}
			}
			if (trackingmode == 0 || trackingmode == 1)
			{
				Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
			}
		}
		if (longPressHomeKeyAction != null)
		{
			longPressHomeKeyAction();
		}
	}

	public void verifyAPPCallback(string code)
	{
		UnityEngine.Debug.Log("PvrLog verifyAPPCallback" + code);
		AppCheckResult = Convert.ToInt32(code);
		if (Pvr_UnitySDKManager.EntitlementCheckResultEvent != null)
		{
			Pvr_UnitySDKManager.EntitlementCheckResultEvent(AppCheckResult);
		}
	}

	public void IpdRefreshCallBack(string ipd)
	{
		UnityEngine.Debug.Log("PvrLog IpdRefreshCallBack");
		Pvr_UnitySDKEye[] eyes = Pvr_UnitySDKEyeManager.Instance.Eyes;
		for (int i = 0; i < eyes.Length; i++)
		{
			eyes[i].RefreshCameraPosition(Convert.ToSingle(ipd));
		}
	}

	private void Awake()
	{
		UnityEngine.Debug.Log("DISFT Unity Version:" + Application.unityVersion);
		UnityEngine.Debug.Log("DISFT Customize NeckOffset:" + neckOffset);
		UnityEngine.Debug.Log("DISFT MSAA :" + Pvr_UnitySDKProjectSetting.GetProjectConfig().rtAntiAlising);
		if (GraphicsSettings.renderPipelineAsset != null)
		{
			UnityEngine.Debug.Log("DISFT LWRP = Enable");
		}
		UnityEngine.Debug.Log("DISFT Content Proctect :" + Pvr_UnitySDKProjectSetting.GetProjectConfig().usecontentprotect);
		int res = 0;
		LoadIsMirroringValue();
		if (!ismirroring)
		{
			Render.UPvr_GetIntConfig(18, ref res);
			if (res == 1)
			{
				UnityEngine.Debug.Log("DISFT ScreenOrientation.Portrait = Enable");
				Screen.orientation = ScreenOrientation.Portrait;
			}
		}
		else
		{
			Render.UPvr_GetIntConfig(19, ref res);
			Screen.orientation = ((res == 0) ? ScreenOrientation.Portrait : ScreenOrientation.LandscapeLeft);
		}
		new AndroidJavaClass("com.psmart.vrlib.VrActivity");
		new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		Pvr_ControllerManager pvr_ControllerManager = UnityEngine.Object.FindObjectOfType<Pvr_ControllerManager>();
		isHasController = pvr_ControllerManager != null;
		PLOG.getConfigTraceLevel();
		Render.UPvr_GetIntConfig(5, ref trackingmode);
		Application.targetFrameRate = 61;
		int res2 = 0;
		Render.UPvr_GetIntConfig(3, ref res2);
		if (res2 == 0)
		{
			SDK.HmdOnlyrot = true;
		}
		int res3 = -1;
		Render.UPvr_GetIntConfig(9, ref res3);
		float res4 = 0f;
		Render.UPvr_GetFloatConfig(6, ref res4);
		Application.targetFrameRate = ((res3 > 0) ? res3 : ((int)res4));
		if (!Pvr_UnitySDKProjectSetting.GetProjectConfig().usedefaultfps)
		{
			if ((float)Pvr_UnitySDKProjectSetting.GetProjectConfig().customfps <= res4)
			{
				Application.targetFrameRate = Pvr_UnitySDKProjectSetting.GetProjectConfig().customfps;
			}
			else
			{
				Application.targetFrameRate = (int)res4;
			}
		}
		UnityEngine.Debug.Log("DISFT Customize FPS :" + Application.targetFrameRate);
		if (!UseCustomNeckPara)
		{
			float res5 = 0f;
			float res6 = 0f;
			float res7 = 0f;
			int configsenum = 4;
			int configsenum2 = 5;
			Render.UPvr_GetFloatConfig(3, ref res5);
			Render.UPvr_GetFloatConfig(configsenum, ref res6);
			Render.UPvr_GetFloatConfig(configsenum2, ref res7);
			if (res5 != 0f || res6 != 0f || res7 != 0f)
			{
				neckOffset = new Vector3(res5, res6, res7);
			}
		}
		Render.UPvr_GetIntConfig(16, ref iPhoneHMDModeEnabled);
		Pvr_ControllerManager.ControllerStatusChangeEvent += CheckControllerStateForG2;
		InitUI();
		RefreshTextByLanguage();
	}

	private IEnumerator Start()
	{
		if (SDKManagerInit())
		{
			PLOG.I("SDK Init success.");
		}
		else
		{
			PLOG.E("SDK Init Failed.");
			Application.Quit();
		}
		if (Pvr_UnitySDKRender.Instance != null)
		{
			Pvr_UnitySDKRender.Instance.ReInit();
		}
		SDKManagerInitFPS();
		if (Pvr_UnitySDKPlatformSetting.StartTimeEntitlementCheck)
		{
			if (PlatformSettings.UPvr_IsCurrentDeviceValid() != Pvr_UnitySDKPlatformSetting.simulationType.Valid)
			{
				UnityEngine.Debug.Log("DISFT Entitlement Check Simulation DO NOT PASS");
				string appID = Pvr_UnitySDKPlatformSetting.Instance.appID;
				UnityEngine.Debug.Log("DISFT Start-time Entitlement Check Enable");
				PLOG.I("DISFT Start-time Entitlement Check APPID :" + appID);
			}
			else
			{
				UnityEngine.Debug.Log("DISFT Entitlement Check Simulation PASS");
			}
		}
		yield return StartCoroutine(InitRenderThreadRoutine());
	}

	private IEnumerator InitRenderThreadRoutine()
	{
		PLOG.I("InitRenderThreadRoutine begin");
		int i = 0;
		while (i < 2)
		{
			yield return null;
			int num = i + 1;
			i = num;
		}
		UnityEngine.Debug.Log("InitRenderThreadRoutine after a wait");
		if (Pvr_UnitySDKRender.Instance != null)
		{
			Pvr_UnitySDKRender.Instance.IssueRenderThread();
		}
		else
		{
			UnityEngine.Debug.Log("InitRenderThreadRoutine pvr_UnitySDKRender == null");
		}
		UnityEngine.Debug.Log("InitRenderThreadRoutine end");
	}

	private void Update()
	{
		if (isHasController && iPhoneHMDModeEnabled == 1 && Controller.UPvr_GetControllerPower(0) == 0 && Pvr_ControllerManager.controllerlink.controller0Connected && Pvr_ControllerManager.controllerlink.Controller0.Rotation.eulerAngles != Vector3.zero)
		{
			if (!lowControllerpowerstate)
			{
				StartCoroutine(ToastManager(6, state: true, 0f));
				StartCoroutine(ToastManager(6, state: false, 3f));
				lowControllerpowerstate = true;
			}
			controllerpowershowtime += Time.deltaTime;
			if (controllerpowershowtime >= 3600f)
			{
				lowControllerpowerstate = false;
				controllerpowershowtime = 0f;
			}
		}
		if (Input.touchCount == 1 && Input.touches[0].phase == TouchPhase.Began)
		{
			newPicovrTriggered = true;
		}
		if (Input.GetKeyDown(KeyCode.JoystickButton0))
		{
			newPicovrTriggered = true;
		}
		if (Pvr_UnitySDKSensor.Instance != null)
		{
			Pvr_UnitySDKSensor.Instance.SensorUpdate();
		}
		picovrTriggered = newPicovrTriggered;
		newPicovrTriggered = false;
	}

	private void OnDestroy()
	{
		if (sdk == this)
		{
			sdk = null;
		}
		RenderTexture.active = null;
		Resources.UnloadUnusedAssets();
		GC.Collect();
		Pvr_ControllerManager.ControllerStatusChangeEvent -= CheckControllerStateForG2;
	}

	private void OnEnable()
	{
		if (sdk == null)
		{
			sdk = this;
		}
		else if (sdk != this)
		{
			sdk = this;
		}
	}

	private void OnDisable()
	{
		StopAllCoroutines();
	}

	private void OnPause()
	{
		Pvr_UnitySDKAPI.System.UPvr_StopHomeKeyReceiver();
		LeaveVRMode();
		if (Pvr_UnitySDKSensor.Instance != null)
		{
			Pvr_UnitySDKSensor.Instance.StopUnitySDKSensor();
		}
	}

	private void OnApplicationPause(bool pause)
	{
		bool flag = pause;
		UnityEngine.Debug.Log("OnApplicationPause-------------------------" + (flag ? "true" : "false"));
		if (Pvr_UnitySDKAPI.System.UPvr_IsPicoActivity() && !Pvr_UnitySDKRender.Instance.isShellMode)
		{
			bool flag2 = Pvr_UnitySDKAPI.System.UPvr_GetMainActivityPauseStatus();
			UnityEngine.Debug.Log("OnApplicationPause-------------------------Activity Pause State:" + flag2);
			pause = flag2;
		}
		if (flag == pause)
		{
			if (pause)
			{
				onResume = false;
				OnPause();
			}
			else
			{
				onResume = true;
				GL.InvalidateState();
				StartCoroutine(OnResume());
			}
		}
		else if (pause)
		{
			UnityEngine.Debug.Log("OnApplicationPause-------------------------Activity pause Unity resume");
			GL.InvalidateState();
			StartCoroutine(OnResume());
			onResume = false;
			OnPause();
		}
		else
		{
			UnityEngine.Debug.Log("OnApplicationPause-------------------------Activity resume Unity pause");
			OnPause();
			onResume = true;
			GL.InvalidateState();
			StartCoroutine(OnResume());
		}
	}

	public void EnterVRMode()
	{
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.Resume);
		isEnterVRMode = true;
		if (eventEnterVRMode != null)
		{
			eventEnterVRMode();
		}
	}

	public void LeaveVRMode()
	{
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.Pause);
		isEnterVRMode = false;
	}

	public void SixDofForceQuit()
	{
		Application.Quit();
	}

	private void InitUI()
	{
		if (iPhoneHMDModeEnabled == 1)
		{
			Transform transform = UnityEngine.Object.Instantiate(Resources.Load("Prefabs/flamingo2Tips") as GameObject, base.transform.Find("Head"), worldPositionStays: false).transform;
			calltoast = transform.Find("Call").gameObject;
			msgtoast = transform.Find("Msg").gameObject;
			lowhmdBatterytoast = transform.Find("LowHmdBattery").gameObject;
			lowphoneBatterytoast = transform.Find("LowPhoneBattery").gameObject;
			LowPhoneHealthtoast = transform.Find("LowPhoneHealth").gameObject;
			LowcontrollerBatterytoast = transform.Find("LowControllerBattery").gameObject;
		}
	}

	private void RefreshTextByLanguage()
	{
		if (msgtoast != null)
		{
			msgtoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("msgtoast0");
			msgtoast.transform.Find("string").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("msgtoast1");
			calltoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("calltoast0");
			calltoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("calltoast1");
			lowhmdBatterytoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("lowhmdBatterytoast");
			lowphoneBatterytoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("lowphoneBatterytoast");
			LowPhoneHealthtoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("LowPhoneHealthtoast");
			LowcontrollerBatterytoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("LowcontrollerBatterytoast");
		}
	}

	private void LoadIsMirroringValue()
	{
		AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		AndroidJavaObject androidJavaObject = @static.Call<AndroidJavaObject>("getPackageManager", Array.Empty<object>());
		string text = @static.Call<string>("getPackageName", Array.Empty<object>());
		AndroidJavaObject androidJavaObject2 = androidJavaObject.Call<AndroidJavaObject>("getApplicationInfo", new object[2] { text, 128 }).Get<AndroidJavaObject>("metaData");
		ismirroring = Convert.ToBoolean(androidJavaObject2.Call<int>("getInt", new object[2] { "bypass_presentation", 0 }));
	}

	private IEnumerator OnResume()
	{
		int ability6dof = 0;
		Render.UPvr_GetIntConfig(3, ref ability6dof);
		RefreshTextByLanguage();
		if (Pvr_UnitySDKSensor.Instance != null)
		{
			Pvr_UnitySDKSensor.Instance.StartUnitySDKSensor();
			int res = -1;
			Render.UPvr_GetIntConfig(8, ref res);
			if (res != 1)
			{
				int res2 = -1;
				Render.UPvr_GetIntConfig(11, ref res2);
				if (res2 != 8)
				{
					Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
				}
			}
		}
		if (Pvr_UnitySDKAPI.System.UPvr_IsPicoActivity())
		{
			PLOG.I("onresume set monoPresentation success ?-------------" + Pvr_UnitySDKAPI.System.UPvr_SetMonoPresentation());
			PLOG.I("onresume presentation existed ?-------------" + Pvr_UnitySDKAPI.System.UPvr_IsPresentationExisted());
		}
		for (int j = 0; j < Pvr_UnitySDKEyeManager.Instance.Eyes.Length; j++)
		{
			Pvr_UnitySDKEyeManager.Instance.Eyes[j].RefreshCameraPosition(Pvr_UnitySDKAPI.System.UPvr_GetIPD());
		}
		int waitNum = 15;
		Render.UPvr_GetIntConfig(20, ref waitNum);
		int resetNum = 10;
		Render.UPvr_GetIntConfig(21, ref resetNum);
		for (int i = 0; i < waitNum; i++)
		{
			if (i == resetNum && ResetTrackerOnLoad && ability6dof == 1)
			{
				UnityEngine.Debug.Log("Reset Tracker OnLoad");
				Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
			}
			yield return null;
		}
		EnterVRMode();
		Pvr_UnitySDKAPI.System.UPvr_StartHomeKeyReceiver(base.gameObject.name);
		Pvr_UnitySDKEye.setLevel = false;
		if (longPressHomeKeyAction != null)
		{
			longPressHomeKeyAction();
		}
		if (Render.UPvr_GetIntSysProc("pvrsist.foveation.level", ref SystemDebugFFRLevel))
		{
			Render.SetFoveatedRenderingLevel((EFoveationLevel)SystemDebugFFRLevel);
			UnityEngine.Debug.Log("DISFT OnResume Get System Debug ffr level is : " + SystemDebugFFRLevel);
		}
		else
		{
			UnityEngine.Debug.Log("DISFT OnResume Get System Debug ffr level Error,ffr level is : " + SystemDebugFFRLevel);
		}
		if (SystemDebugFFRLevel == -1)
		{
			Render.UPvr_GetIntConfig(22, ref SystemFFRLevel);
			if (SystemFFRLevel != -1)
			{
				Render.SetFoveatedRenderingLevel((EFoveationLevel)SystemFFRLevel);
				UnityEngine.Debug.Log("DISFT OnResume Get System ffr level is : " + SystemFFRLevel);
			}
		}
	}
}
public class QuitGame : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Escape))
		{
			Application.Quit();
		}
	}
}
public class Pvr_UnityEyeMask : MonoBehaviour
{
	private class EyeMaskData
	{
		public Eye eyeSide;

		public Camera camera;

		public CommandBuffer cmdBuf;
	}

	private Shader eyeMaskShader;

	private Material eyeMaskMaterial;

	private Mesh eyeMaskMeshLeft;

	private Mesh eyeMaskMeshRight;

	private Mesh eyeMaskMeshBoth;

	private float zDir = -1f;

	private UnityEngine.Color eyeMaskColor = UnityEngine.Color.black;

	private List<EyeMaskData> cameraDataList = new List<EyeMaskData>();

	private void Awake()
	{
		UnityEngine.Debug.Log("DISFT EyeMask = Enable");
		if (SystemInfo.graphicsDeviceType == GraphicsDeviceType.OpenGLES3 || SystemInfo.graphicsDeviceType == GraphicsDeviceType.OpenGLES2)
		{
			zDir = -1f;
		}
		else if (SystemInfo.usesReversedZBuffer)
		{
			zDir = 1f;
		}
		else
		{
			zDir = 0f;
		}
	}

	private void OnEnable()
	{
		if (eyeMaskShader == null)
		{
			eyeMaskShader = Shader.Find("Pvr_UnitySDK/Pvr_EyeMask");
		}
		if (eyeMaskMaterial == null && eyeMaskShader != null)
		{
			eyeMaskMaterial = new Material(eyeMaskShader);
			eyeMaskMaterial.SetColor("_Color", eyeMaskColor);
		}
		if (eyeMaskMaterial == null)
		{
			base.enabled = false;
			UnityEngine.Debug.LogWarning("EyeMask materil is null or EyeMask shader not found!");
		}
		else
		{
			PrepareCameras();
			Camera.onPreRender = (Camera.CameraCallback)Delegate.Combine(Camera.onPreRender, new Camera.CameraCallback(OnCustomPreRender));
			CreateCommandBuffer();
		}
	}

	private void OnDisable()
	{
		Camera.onPreRender = (Camera.CameraCallback)Delegate.Remove(Camera.onPreRender, new Camera.CameraCallback(OnCustomPreRender));
		foreach (EyeMaskData cameraData in cameraDataList)
		{
			if (cameraData.camera != null && cameraData.cmdBuf != null)
			{
				RemoveCameraCommandBuffer(cameraData);
			}
		}
		CleanEyeMask();
	}

	private void CreateCommandBuffer()
	{
		if (VerifyCommadBuffer())
		{
			return;
		}
		if (eyeMaskMeshLeft == null || eyeMaskMeshRight == null)
		{
			eyeMaskMeshLeft = GetStencilMesh(Eye.LeftEye);
			eyeMaskMeshRight = GetStencilMesh(Eye.RightEye);
			if (eyeMaskMeshLeft == null || eyeMaskMeshRight == null)
			{
				UnityEngine.Debug.LogWarning("Stencil Mesh is not exist, disable EyeMask.");
				base.enabled = false;
				return;
			}
		}
		foreach (EyeMaskData cameraData in cameraDataList)
		{
			if (cameraData.eyeSide == Eye.LeftEye)
			{
				CommandBuffer commandBuffer = new CommandBuffer();
				commandBuffer.name = "EyeMaskLeft";
				commandBuffer.DrawMesh(eyeMaskMeshLeft, Matrix4x4.identity, eyeMaskMaterial, 0, 0);
				cameraData.cmdBuf = commandBuffer;
			}
			else if (cameraData.eyeSide == Eye.RightEye)
			{
				CommandBuffer commandBuffer2 = new CommandBuffer();
				commandBuffer2.name = "EyeMaskRight";
				commandBuffer2.DrawMesh(eyeMaskMeshRight, Matrix4x4.identity, eyeMaskMaterial, 0, 0);
				cameraData.cmdBuf = commandBuffer2;
			}
			else if (cameraData.eyeSide == Eye.BothEye)
			{
				if (eyeMaskMeshBoth == null)
				{
					eyeMaskMeshBoth = GetStencilMeshBoth(eyeMaskMeshLeft, eyeMaskMeshRight);
					float value = Mathf.Max(Mathf.Abs(eyeMaskMeshLeft.bounds.max.x), Mathf.Abs(eyeMaskMeshRight.bounds.min.x));
					eyeMaskMaterial.SetFloat("_MeshOffsetX", value);
				}
				CommandBuffer commandBuffer3 = new CommandBuffer();
				commandBuffer3.name = "EyeMaskBoth";
				commandBuffer3.DrawMesh(eyeMaskMeshBoth, Matrix4x4.identity, eyeMaskMaterial, 0, 1);
				cameraData.cmdBuf = commandBuffer3;
			}
		}
	}

	private void OnCustomPreRender(Camera cam)
	{
		if (!VerifyCommadBuffer())
		{
			UnityEngine.Debug.LogWarning("Verify CommandBuffer failed!");
			return;
		}
		foreach (EyeMaskData cameraData in cameraDataList)
		{
			if (!(cameraData.camera != cam))
			{
				RemoveCameraCommandBuffer(cameraData);
				AddCameraCommandBuffer(cameraData);
			}
		}
	}

	private Mesh GetStencilMesh(Eye eyeSide)
	{
		int vertexCount = 0;
		int triangleCount = 0;
		IntPtr vertexDataPtr = IntPtr.Zero;
		IntPtr indexDataPtr = IntPtr.Zero;
		Render.UPvr_GetStencilMesh((int)eyeSide, ref vertexCount, ref triangleCount, ref vertexDataPtr, ref indexDataPtr);
		if (vertexCount <= 0 || triangleCount <= 0 || vertexDataPtr == IntPtr.Zero || indexDataPtr == IntPtr.Zero)
		{
			return null;
		}
		Vector3[] array = new Vector3[vertexCount];
		int[] array2 = new int[triangleCount * 3];
		float[] array3 = new float[vertexCount * 3];
		int[] array4 = new int[triangleCount * 3];
		Marshal.Copy(vertexDataPtr, array3, 0, vertexCount * 3);
		Marshal.Copy(indexDataPtr, array4, 0, triangleCount * 3);
		for (int i = 0; i < vertexCount; i++)
		{
			array[i] = new Vector3(array3[3 * i], array3[3 * i + 1], zDir);
		}
		for (int j = 0; j < triangleCount; j++)
		{
			array2[3 * j] = array4[3 * j + 2];
			array2[3 * j + 1] = array4[3 * j + 1];
			array2[3 * j + 2] = array4[3 * j];
		}
		Mesh mesh = new Mesh();
		mesh.name = "EyeMaskMesh";
		mesh.vertices = array;
		mesh.SetIndices(array2, MeshTopology.Triangles, 0);
		return mesh;
	}

	private Mesh GetStencilMeshBoth(Mesh leftMesh, Mesh rightMesh)
	{
		float num = Mathf.Max(Mathf.Abs(leftMesh.bounds.max.x), Mathf.Abs(rightMesh.bounds.min.x));
		Mesh mesh = new Mesh();
		mesh.name = "EyeMaskBoth";
		CombineInstance combineInstance = default(CombineInstance);
		combineInstance.mesh = leftMesh;
		Matrix4x4 identity = Matrix4x4.identity;
		identity.SetTRS(Vector3.left * num, Quaternion.identity, Vector3.one);
		combineInstance.transform = identity;
		CombineInstance combineInstance2 = default(CombineInstance);
		combineInstance2.mesh = rightMesh;
		Matrix4x4 identity2 = Matrix4x4.identity;
		identity2.SetTRS(Vector3.right * num, Quaternion.identity, Vector3.one);
		combineInstance2.transform = identity2;
		CombineInstance[] combine = new CombineInstance[2] { combineInstance, combineInstance2 };
		mesh.CombineMeshes(combine);
		return mesh;
	}

	private bool VerifyCommadBuffer()
	{
		if (cameraDataList == null || cameraDataList.Count <= 0)
		{
			return false;
		}
		foreach (EyeMaskData cameraData in cameraDataList)
		{
			if (cameraData == null || cameraData.cmdBuf == null)
			{
				return false;
			}
		}
		return true;
	}

	private void PrepareCameras()
	{
		cameraDataList.Clear();
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			if (Pvr_UnitySDKEyeManager.Instance.BothEyeCamera == null)
			{
				UnityEngine.Debug.LogWarning("BothEye Camera is null!");
				return;
			}
			EyeMaskData eyeMaskData = new EyeMaskData();
			eyeMaskData.eyeSide = Eye.BothEye;
			eyeMaskData.camera = Pvr_UnitySDKEyeManager.Instance.BothEyeCamera;
			cameraDataList.Add(eyeMaskData);
		}
		else if (Pvr_UnitySDKEyeManager.Instance.LeftEyeCamera == null || Pvr_UnitySDKEyeManager.Instance.RightEyeCamera == null)
		{
			UnityEngine.Debug.LogWarning("LeftEye or RightEye Camera is null!");
		}
		else
		{
			EyeMaskData eyeMaskData2 = new EyeMaskData();
			eyeMaskData2.eyeSide = Eye.LeftEye;
			eyeMaskData2.camera = Pvr_UnitySDKEyeManager.Instance.LeftEyeCamera;
			eyeMaskData2.cmdBuf = null;
			cameraDataList.Add(eyeMaskData2);
			EyeMaskData eyeMaskData3 = new EyeMaskData();
			eyeMaskData3.eyeSide = Eye.RightEye;
			eyeMaskData3.camera = Pvr_UnitySDKEyeManager.Instance.RightEyeCamera;
			eyeMaskData3.cmdBuf = null;
			cameraDataList.Add(eyeMaskData3);
		}
	}

	private void AddCameraCommandBuffer(EyeMaskData data)
	{
		data.camera.AddCommandBuffer(CameraEvent.BeforeForwardOpaque, data.cmdBuf);
	}

	private void RemoveCameraCommandBuffer(EyeMaskData data)
	{
		data.camera.RemoveCommandBuffer(CameraEvent.BeforeForwardOpaque, data.cmdBuf);
	}

	private void CleanEyeMask()
	{
		cameraDataList.Clear();
		eyeMaskMeshLeft = null;
		eyeMaskMeshRight = null;
		eyeMaskMeshBoth = null;
		eyeMaskShader = null;
		eyeMaskMaterial = null;
	}
}
[RequireComponent(typeof(Camera))]
public class Pvr_UnitySDKEye : MonoBehaviour
{
	public static List<Pvr_UnitySDKEye> Instances = new List<Pvr_UnitySDKEye>();

	public Eye eyeSide;

	private int eyeCameraOriginCullingMask;

	private CameraClearFlags eyeCameraOriginClearFlag;

	private UnityEngine.Color eyeCameraOriginBackgroundColor;

	private int lastBoundaryState;

	private Matrix4x4 realProj = Matrix4x4.identity;

	private const int bufferSize = 3;

	private int IDIndex;

	private RenderEventType eventType;

	private int previousId;

	public static bool setLevel = false;

	private Material mat_Vignette;

	public Camera eyecamera { get; private set; }

	private void Awake()
	{
		Instances.Add(this);
		eyecamera = GetComponent<Camera>();
	}

	private void Start()
	{
		Setup(eyeSide);
		SetupUpdate();
		if (eyecamera != null)
		{
			eyeCameraOriginCullingMask = eyecamera.cullingMask;
			eyeCameraOriginClearFlag = eyecamera.clearFlags;
			eyeCameraOriginBackgroundColor = eyecamera.backgroundColor;
		}
	}

	private void Update()
	{
		if (!(eyecamera != null) || !eyecamera.enabled)
		{
			return;
		}
		int num = BoundarySystem.UPvr_GetSeeThroughState();
		if (num == lastBoundaryState)
		{
			return;
		}
		switch (num)
		{
		case 2:
			eyeCameraOriginCullingMask = eyecamera.cullingMask;
			eyeCameraOriginClearFlag = eyecamera.clearFlags;
			eyeCameraOriginBackgroundColor = eyecamera.backgroundColor;
			eyecamera.cullingMask = 0;
			eyecamera.clearFlags = CameraClearFlags.Color;
			eyecamera.backgroundColor = UnityEngine.Color.black;
			break;
		case 1:
			if (lastBoundaryState == 2)
			{
				if (eyecamera.cullingMask == 0)
				{
					eyecamera.cullingMask = eyeCameraOriginCullingMask;
				}
				if (eyecamera.clearFlags == CameraClearFlags.Color)
				{
					eyecamera.clearFlags = eyeCameraOriginClearFlag;
				}
				if (eyecamera.backgroundColor == UnityEngine.Color.black)
				{
					eyecamera.backgroundColor = eyeCameraOriginBackgroundColor;
				}
			}
			break;
		default:
			if (lastBoundaryState == 2 || lastBoundaryState == 1)
			{
				if (eyecamera.cullingMask == 0)
				{
					eyecamera.cullingMask = eyeCameraOriginCullingMask;
				}
				if (eyecamera.clearFlags == CameraClearFlags.Color)
				{
					eyecamera.clearFlags = eyeCameraOriginClearFlag;
				}
				if (eyecamera.backgroundColor == UnityEngine.Color.black)
				{
					eyecamera.backgroundColor = eyeCameraOriginBackgroundColor;
				}
			}
			break;
		}
		lastBoundaryState = num;
	}

	private void OnEnable()
	{
		if (GraphicsSettings.renderPipelineAsset != null)
		{
			UnityEngine.Experimental.Rendering.RenderPipeline.beginCameraRendering += MyPreRender;
		}
	}

	private void OnDisable()
	{
		if (GraphicsSettings.renderPipelineAsset != null)
		{
			UnityEngine.Experimental.Rendering.RenderPipeline.beginCameraRendering -= MyPreRender;
		}
	}

	private void OnDestroy()
	{
		Instances.Remove(this);
	}

	public void MyPreRender(Camera camera)
	{
		if (!(camera.gameObject != base.gameObject))
		{
			OnPreRender();
		}
	}

	public void MyPreRender(ScriptableRenderContext context, Camera camera)
	{
		if (!(camera.gameObject != base.gameObject))
		{
			OnPreRender();
		}
	}

	public void MyPostRender(ScriptableRenderContext context, Camera camera)
	{
		if (!(camera.gameObject != base.gameObject))
		{
			OnPostRender();
		}
	}

	private void OnPreRender()
	{
		if (!eyecamera.enabled)
		{
			return;
		}
		if (Pvr_UnitySDKRender.Instance.StereoRendering != null)
		{
			if (Pvr_UnitySDKRender.Instance.isSwitchSDK)
			{
				return;
			}
			Pvr_UnitySDKRender.Instance.StereoRendering.OnSDKPreRender();
		}
		SetFFRParameter();
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.BeginEye);
	}

	private void OnPostRender()
	{
		if (!eyecamera.enabled)
		{
			return;
		}
		Pvr_UnitySDKAPI.System.UPvr_UnityEventData(Pvr_UnitySDKAPI.System.UPvr_GetEyeBufferData(Pvr_UnitySDKRender.Instance.eyeTextureIds[IDIndex]));
		Pvr_UnitySDKPluginEvent.Issue(eventType);
		if (Pvr_UnitySDKRender.Instance.StereoRendering != null)
		{
			if (Pvr_UnitySDKRender.Instance.isSwitchSDK)
			{
				return;
			}
			Pvr_UnitySDKRender.Instance.StereoRendering.OnSDKPostRender();
		}
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.EndEye);
	}

	public void EyeRender()
	{
		SetupUpdate();
		if (Pvr_UnitySDKRender.Instance.eyeTextures[IDIndex] != null)
		{
			Pvr_UnitySDKRender.Instance.eyeTextures[IDIndex].DiscardContents();
			eyecamera.targetTexture = Pvr_UnitySDKRender.Instance.eyeTextures[IDIndex];
		}
	}

	private void Setup(Eye eyeSide)
	{
		eyecamera = GetComponent<Camera>();
		switch (eyeSide)
		{
		case Eye.LeftEye:
		case Eye.RightEye:
			base.transform.localPosition = Pvr_UnitySDKManager.SDK.EyeOffset(eyeSide);
			break;
		case Eye.BothEye:
			base.transform.localPosition = Vector3.zero;
			break;
		}
		eyecamera.aspect = Pvr_UnitySDKManager.SDK.EyesAspect;
		eyecamera.rect = new Rect(0f, 0f, 1f, 1f);
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.MultiPass)
		{
			eventType = ((eyeSide == Eye.LeftEye) ? RenderEventType.LeftEyeEndFrame : RenderEventType.RightEyeEndFrame);
		}
		else
		{
			eventType = RenderEventType.BothEyeEndFrame;
		}
	}

	private void SetupUpdate()
	{
		if (eyeSide == Eye.LeftEye || eyeSide == Eye.RightEye)
		{
			eyecamera.enabled = !Pvr_UnitySDKManager.SDK.Monoscopic && Pvr_UnitySDKRender.Instance.StereoRenderPath != StereoRenderingPathPico.SinglePass;
		}
		else if (eyeSide == Eye.BothEye)
		{
			eyecamera.enabled = Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass;
		}
		eyecamera.fieldOfView = Pvr_UnitySDKRender.Instance.EyeVFoV;
		eyecamera.aspect = Pvr_UnitySDKManager.SDK.EyesAspect;
		if (eyeSide == Eye.LeftEye || eyeSide == Eye.RightEye)
		{
			IDIndex = Pvr_UnitySDKRender.Instance.currEyeTextureIdx + (int)eyeSide * 3;
		}
		else if (eyeSide == Eye.BothEye)
		{
			IDIndex = Pvr_UnitySDKRender.Instance.currEyeTextureIdx;
			Pvr_UnitySDKRender.Instance.isSwitchSDK = Pvr_UnitySDKRender.Instance.lastEyeTextureIdx == Pvr_UnitySDKRender.Instance.currEyeTextureIdx;
			Pvr_UnitySDKRender.Instance.lastEyeTextureIdx = Pvr_UnitySDKRender.Instance.currEyeTextureIdx;
		}
	}

	public void RefreshCameraPosition(float ipd)
	{
		Pvr_UnitySDKManager.SDK.leftEyeOffset = new Vector3((0f - ipd) / 2f, 0f, 0f);
		Pvr_UnitySDKManager.SDK.rightEyeOffset = new Vector3(ipd / 2f, 0f, 0f);
		if (eyeSide == Eye.LeftEye || eyeSide == Eye.RightEye)
		{
			base.transform.localPosition = Pvr_UnitySDKManager.SDK.EyeOffset(eyeSide);
		}
		else if (eyeSide == Eye.BothEye)
		{
			eyecamera.stereoSeparation = ipd;
		}
	}

	private void DrawVignetteLine()
	{
		if (null == mat_Vignette)
		{
			mat_Vignette = new Material(Shader.Find("Diffuse"));
			if (null == mat_Vignette)
			{
				return;
			}
		}
		GL.PushMatrix();
		mat_Vignette.SetPass(0);
		GL.LoadOrtho();
		vignette();
		GL.PopMatrix();
	}

	private void vignette()
	{
		GL.Begin(7);
		GL.Color(UnityEngine.Color.black);
		GL.Vertex3(0f, 1f, 0f);
		GL.Vertex3(1f, 1f, 0f);
		GL.Vertex3(1f, 0.995f, 0f);
		GL.Vertex3(0f, 0.995f, 0f);
		GL.Vertex3(0f, 0f, 0f);
		GL.Vertex3(0f, 0.005f, 0f);
		GL.Vertex3(1f, 0.005f, 0f);
		GL.Vertex3(1f, 0f, 0f);
		GL.Vertex(new Vector3(0f, 1f, 0f));
		GL.Vertex(new Vector3(0.005f, 1f, 0f));
		GL.Vertex(new Vector3(0.005f, 0f, 0f));
		GL.Vertex(new Vector3(0f, 0f, 0f));
		GL.Vertex(new Vector3(0.995f, 1f, 0f));
		GL.Vertex(new Vector3(1f, 1f, 0f));
		GL.Vertex(new Vector3(1f, 0f, 0f));
		GL.Vertex(new Vector3(0.995f, 0f, 0f));
		GL.End();
	}

	private void SetFFRParameter()
	{
		Vector3 vector = Vector3.zero;
		if (Pvr_UnitySDKManager.SDK.isEnterVRMode && Pvr_UnitySDKEyeManager.supportEyeTracking && Pvr_UnitySDKEyeManager.Instance.EyeTracking)
		{
			vector = Pvr_UnitySDKAPI.System.UPvr_getEyeTrackingPos();
		}
		int textureId = Pvr_UnitySDKRender.Instance.eyeTextureIds[IDIndex];
		Render.UPvr_SetFoveationResource(textureId, previousId, vector.x, vector.y);
		previousId = textureId;
	}
}
public class Pvr_UnitySDKEyeManager : MonoBehaviour
{
	private static Pvr_UnitySDKEyeManager instance;

	private Pvr_UnitySDKEye[] eyes;

	[HideInInspector]
	public Camera LeftEyeCamera;

	[HideInInspector]
	public Camera RightEyeCamera;

	[HideInInspector]
	public Camera MonoEyeCamera;

	[HideInInspector]
	public Camera BothEyeCamera;

	private int MonoEyeTextureID;

	private readonly int WaitSplashScreenFrames = 3;

	private int frameNum;

	[SerializeField]
	[HideInInspector]
	private bool foveatedRendering;

	[SerializeField]
	[HideInInspector]
	private EFoveationLevel foveationLevel;

	private int eyeTextureId;

	private RenderEventType eventType = RenderEventType.LeftEyeEndFrame;

	private Pvr_UnitySDKEyeOverlay compositeLayer;

	private int overlayLayerDepth = 1;

	private int underlayLayerDepth;

	private bool isHeadLocked;

	private int layerFlags;

	[HideInInspector]
	public bool EyeTracking;

	[HideInInspector]
	public Vector3 eyePoint;

	private EyeTrackingData eyePoseData;

	[HideInInspector]
	public static bool supportEyeTracking;

	[Tooltip("If true, specific color gradient when switching scenes.")]
	public bool screenFade;

	[Tooltip("Define the duration of screen fade.")]
	public float fadeTime = 5f;

	[Tooltip("Define the color of screen fade.")]
	public UnityEngine.Color fadeColor = new UnityEngine.Color(0f, 0f, 0f, 1f);

	public int renderQueue = 5000;

	private MeshRenderer fadeMeshRenderer;

	private MeshFilter fadeMeshFilter;

	private Material fadeMaterial;

	private float elapsedTime;

	private bool isFading;

	private float currentAlpha;

	private float nowFadeAlpha;

	public static Pvr_UnitySDKEyeManager Instance
	{
		get
		{
			if (instance == null)
			{
				PLOG.E("Pvr_UnitySDKEyeManager instance is not init yet...");
			}
			return instance;
		}
	}

	public Pvr_UnitySDKEye[] Eyes
	{
		get
		{
			if (eyes == null)
			{
				eyes = Pvr_UnitySDKEye.Instances.ToArray();
			}
			return eyes;
		}
	}

	[HideInInspector]
	public bool FoveatedRendering
	{
		get
		{
			return foveatedRendering;
		}
		set
		{
			if (value == foveatedRendering)
			{
				return;
			}
			foveatedRendering = value;
			if (Application.isPlaying)
			{
				Render.UPvr_EnableFoveation(enable: true);
				if (!foveatedRendering)
				{
					Render.SetFoveatedRenderingLevel((EFoveationLevel)(-1));
				}
			}
		}
	}

	[HideInInspector]
	public EFoveationLevel FoveationLevel
	{
		get
		{
			return foveationLevel;
		}
		set
		{
			if (value != foveationLevel)
			{
				foveationLevel = value;
			}
		}
	}

	private void SetCameraEnableEditor()
	{
		MonoEyeCamera.enabled = !Pvr_UnitySDKManager.SDK.VRModeEnabled || Pvr_UnitySDKManager.SDK.Monoscopic;
		for (int i = 0; i < Eyes.Length; i++)
		{
			if (Eyes[i].eyeSide == Eye.LeftEye || Eyes[i].eyeSide == Eye.RightEye)
			{
				Eyes[i].eyecamera.enabled = Pvr_UnitySDKManager.SDK.VRModeEnabled;
			}
			else if (Eyes[i].eyeSide == Eye.BothEye)
			{
				Eyes[i].eyecamera.enabled = false;
			}
		}
	}

	private void SetCamerasEnableByStereoRendering()
	{
		MonoEyeCamera.enabled = Pvr_UnitySDKManager.SDK.Monoscopic && Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.MultiPass;
	}

	private void SetupMonoCamera()
	{
		base.transform.localPosition = Vector3.zero;
		MonoEyeCamera.aspect = Pvr_UnitySDKManager.SDK.EyesAspect;
		MonoEyeCamera.rect = new Rect(0f, 0f, 1f, 1f);
	}

	private void SetupUpdate()
	{
		MonoEyeCamera.fieldOfView = Pvr_UnitySDKRender.Instance.EyeVFoV;
		MonoEyeCamera.aspect = Pvr_UnitySDKManager.SDK.EyesAspect;
		MonoEyeTextureID = Pvr_UnitySDKRender.Instance.currEyeTextureIdx;
	}

	private void MonoEyeRender()
	{
		SetupUpdate();
		if (Pvr_UnitySDKRender.Instance.eyeTextures[MonoEyeTextureID] != null)
		{
			Pvr_UnitySDKRender.Instance.eyeTextures[MonoEyeTextureID].DiscardContents();
			MonoEyeCamera.targetTexture = Pvr_UnitySDKRender.Instance.eyeTextures[MonoEyeTextureID];
		}
	}

	private void Awake()
	{
		if (MonoEyeCamera == null)
		{
			MonoEyeCamera = GetComponent<Camera>();
		}
		if (LeftEyeCamera == null)
		{
			LeftEyeCamera = base.gameObject.transform.Find("LeftEye").GetComponent<Camera>();
		}
		if (RightEyeCamera == null)
		{
			RightEyeCamera = base.gameObject.transform.Find("RightEye").GetComponent<Camera>();
		}
		if (BothEyeCamera == null)
		{
			BothEyeCamera = base.gameObject.transform.Find("BothEye").GetComponent<Camera>();
		}
		if (BothEyeCamera != null)
		{
			BothEyeCamera.transform.GetComponent<Pvr_UnitySDKEye>().eyeSide = Eye.BothEye;
		}
		CreateFadeMesh();
		SetCurrentAlpha(0f);
		Render.UPvr_EnableFoveation(enable: true);
		if (foveatedRendering)
		{
			Render.SetFoveatedRenderingLevel(foveationLevel);
		}
		else
		{
			Render.SetFoveatedRenderingLevel((EFoveationLevel)(-1));
		}
		Pvr_UnitySDKManager.eventEnterVRMode = (Func<bool>)Delegate.Combine(Pvr_UnitySDKManager.eventEnterVRMode, new Func<bool>(SetEyeTrackingMode));
	}

	private void OnEnable()
	{
		if (instance == null)
		{
			instance = this;
		}
		else if (instance != this)
		{
			instance = this;
		}
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			Pvr_UnitySDKRender.Instance.StereoRendering.InitEye(BothEyeCamera);
		}
		foreach (Pvr_UnitySDKEyeOverlay instance in Pvr_UnitySDKEyeOverlay.Instances)
		{
			instance.RefreshCamera();
			if (instance.overlayType == Pvr_UnitySDKEyeOverlay.OverlayType.Overlay)
			{
				if (instance.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Cylinder)
				{
					UnityEngine.Debug.Log("DISFT Cylinder OverLay = Enable");
				}
				if (instance.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Equirect)
				{
					UnityEngine.Debug.Log("DISFT 360 OverLay= Enable");
				}
				if (instance.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Quad)
				{
					UnityEngine.Debug.Log("DISFT 2D OverLay= Enable");
				}
			}
			if (instance.overlayType == Pvr_UnitySDKEyeOverlay.OverlayType.Underlay)
			{
				UnityEngine.Debug.Log("DISFT UnderLay= Enable");
			}
		}
		GfxDeviceAdvanceFrameGLES();
		StartCoroutine("EndOfFrame");
		if (screenFade)
		{
			StartCoroutine(ScreenFade(1f, 0f));
		}
	}

	private void Start()
	{
		SetCamerasEnableByStereoRendering();
		SetupMonoCamera();
	}

	private void Update()
	{
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			for (int i = 0; i < Eyes.Length; i++)
			{
				if (Eyes[i].isActiveAndEnabled && Eyes[i].eyeSide == Eye.BothEye)
				{
					Eyes[i].EyeRender();
				}
			}
		}
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath != 0)
		{
			return;
		}
		if (!Pvr_UnitySDKManager.SDK.Monoscopic)
		{
			for (int j = 0; j < Eyes.Length; j++)
			{
				if (Eyes[j].isActiveAndEnabled && Eyes[j].eyeSide != Eye.BothEye)
				{
					Eyes[j].EyeRender();
				}
			}
		}
		else
		{
			MonoEyeRender();
		}
	}

	private void OnPause()
	{
		Pvr_UnitySDKManager.eventEnterVRMode = (Func<bool>)Delegate.Remove(Pvr_UnitySDKManager.eventEnterVRMode, new Func<bool>(SetEyeTrackingMode));
	}

	private void OnDisable()
	{
		StopAllCoroutines();
	}

	private void OnDestroy()
	{
		DestoryFadeMesh();
	}

	private void OnPostRender()
	{
		long data = Pvr_UnitySDKAPI.System.UPvr_GetEyeBufferData(Pvr_UnitySDKRender.Instance.eyeTextureIds[Pvr_UnitySDKRender.Instance.currEyeTextureIdx]);
		Pvr_UnitySDKAPI.System.UPvr_UnityEventData(data);
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.LeftEyeEndFrame);
		Pvr_UnitySDKAPI.System.UPvr_UnityEventData(data);
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.RightEyeEndFrame);
	}

	private IEnumerator EndOfFrame()
	{
		while (true)
		{
			yield return new WaitForEndOfFrame();
			if (!Pvr_UnitySDKManager.SDK.isEnterVRMode)
			{
				GL.Clear(clearDepth: false, clearColor: true, UnityEngine.Color.black);
			}
			if (Pvr_UnitySDKRender.Instance.isFirstStartup && frameNum == WaitSplashScreenFrames)
			{
				Pvr_UnitySDKAPI.System.UPvr_RemovePlatformLogo();
				if (Pvr_UnitySDKManager.SDK.ResetTrackerOnLoad)
				{
					UnityEngine.Debug.Log("Reset Tracker OnLoad");
					Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
				}
				Pvr_UnitySDKAPI.System.UPvr_StartVRModel();
				Pvr_UnitySDKRender.Instance.isFirstStartup = false;
			}
			else if (Pvr_UnitySDKRender.Instance.isFirstStartup && frameNum < WaitSplashScreenFrames)
			{
				PLOG.I("frameNum:" + frameNum);
				frameNum++;
			}
			if (GraphicsSettings.renderPipelineAsset != null)
			{
				for (int i = 0; i < Eyes.Length; i++)
				{
					if (!Eyes[i].isActiveAndEnabled || !Eyes[i].eyecamera.enabled)
					{
						continue;
					}
					switch (Eyes[i].eyeSide)
					{
					case Eye.LeftEye:
						eyeTextureId = Pvr_UnitySDKRender.Instance.eyeTextureIds[Pvr_UnitySDKRender.Instance.currEyeTextureIdx];
						eventType = RenderEventType.LeftEyeEndFrame;
						break;
					case Eye.RightEye:
						if (!Pvr_UnitySDKManager.SDK.Monoscopic)
						{
							eyeTextureId = Pvr_UnitySDKRender.Instance.eyeTextureIds[Pvr_UnitySDKRender.Instance.currEyeTextureIdx + 3];
						}
						else
						{
							eyeTextureId = Pvr_UnitySDKRender.Instance.eyeTextureIds[Pvr_UnitySDKRender.Instance.currEyeTextureIdx];
						}
						eventType = RenderEventType.RightEyeEndFrame;
						break;
					case Eye.BothEye:
						eyeTextureId = Pvr_UnitySDKRender.Instance.eyeTextureIds[Pvr_UnitySDKRender.Instance.currEyeTextureIdx];
						eventType = RenderEventType.BothEyeEndFrame;
						break;
					}
					Pvr_UnitySDKAPI.System.UPvr_UnityEventData(Pvr_UnitySDKAPI.System.UPvr_GetEyeBufferData(eyeTextureId));
					Pvr_UnitySDKPluginEvent.Issue(eventType);
					Pvr_UnitySDKPluginEvent.Issue(RenderEventType.EndEye);
				}
			}
			int num = BoundarySystem.UPvr_GetSeeThroughState();
			if (Pvr_UnitySDKEyeOverlay.Instances.Count > 0 && num != 2)
			{
				overlayLayerDepth = 1;
				underlayLayerDepth = 0;
				Pvr_UnitySDKEyeOverlay.Instances.Sort();
				for (int j = 0; j < Pvr_UnitySDKEyeOverlay.Instances.Count; j++)
				{
					compositeLayer = Pvr_UnitySDKEyeOverlay.Instances[j];
					if (!compositeLayer.isActiveAndEnabled || (compositeLayer.layerTextures[0] == null && compositeLayer.layerTextures[1] == null && !compositeLayer.isExternalAndroidSurface) || (compositeLayer.layerTransform != null && !compositeLayer.layerTransform.gameObject.activeSelf))
					{
						continue;
					}
					layerFlags = 0;
					if (compositeLayer.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Quad || compositeLayer.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Cylinder)
					{
						if (compositeLayer.overlayType == Pvr_UnitySDKEyeOverlay.OverlayType.Overlay)
						{
							isHeadLocked = false;
							if (compositeLayer.layerTransform != null && compositeLayer.layerTransform.parent == base.transform)
							{
								isHeadLocked = true;
							}
							if (compositeLayer.isExternalAndroidSurface)
							{
								layerFlags |= 1;
								CreateExternalSurface(compositeLayer, overlayLayerDepth);
							}
							Render.UPvr_SetOverlayModelViewMatrix((int)compositeLayer.overlayType, (int)compositeLayer.overlayShape, compositeLayer.layerTextureIds[0], 0, overlayLayerDepth, isHeadLocked, layerFlags, compositeLayer.MVMatrixs[0], compositeLayer.ModelScales[0], compositeLayer.ModelRotations[0], compositeLayer.ModelTranslations[0], compositeLayer.CameraRotations[0], compositeLayer.CameraTranslations[0], compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
							Render.UPvr_SetOverlayModelViewMatrix((int)compositeLayer.overlayType, (int)compositeLayer.overlayShape, compositeLayer.layerTextureIds[1], 1, overlayLayerDepth, isHeadLocked, layerFlags, compositeLayer.MVMatrixs[1], compositeLayer.ModelScales[1], compositeLayer.ModelRotations[1], compositeLayer.ModelTranslations[1], compositeLayer.CameraRotations[1], compositeLayer.CameraTranslations[1], compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
							overlayLayerDepth++;
						}
						else if (compositeLayer.overlayType == Pvr_UnitySDKEyeOverlay.OverlayType.Underlay)
						{
							if (compositeLayer.isExternalAndroidSurface)
							{
								layerFlags |= 1;
								CreateExternalSurface(compositeLayer, underlayLayerDepth);
							}
							Render.UPvr_SetOverlayModelViewMatrix((int)compositeLayer.overlayType, (int)compositeLayer.overlayShape, compositeLayer.layerTextureIds[0], 0, underlayLayerDepth, isHeadLocked: false, layerFlags, compositeLayer.MVMatrixs[0], compositeLayer.ModelScales[0], compositeLayer.ModelRotations[0], compositeLayer.ModelTranslations[0], compositeLayer.CameraRotations[0], compositeLayer.CameraTranslations[0], compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
							Render.UPvr_SetOverlayModelViewMatrix((int)compositeLayer.overlayType, (int)compositeLayer.overlayShape, compositeLayer.layerTextureIds[1], 1, underlayLayerDepth, isHeadLocked: false, layerFlags, compositeLayer.MVMatrixs[1], compositeLayer.ModelScales[1], compositeLayer.ModelRotations[1], compositeLayer.ModelTranslations[1], compositeLayer.CameraRotations[1], compositeLayer.CameraTranslations[1], compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
							underlayLayerDepth++;
						}
					}
					else if (compositeLayer.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Equirect)
					{
						if (compositeLayer.isExternalAndroidSurface)
						{
							layerFlags |= 1;
							CreateExternalSurface(compositeLayer, 0);
						}
						Render.UPvr_SetupLayerData(0, 0, compositeLayer.layerTextureIds[0], (int)compositeLayer.overlayShape, layerFlags, compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
						Render.UPvr_SetupLayerData(0, 1, compositeLayer.layerTextureIds[1], (int)compositeLayer.overlayShape, layerFlags, compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
					}
				}
			}
			Pvr_UnitySDKAPI.System.UPvr_UnityEventData(Pvr_UnitySDKAPI.System.UPvr_GetEyeBufferData(0));
			Pvr_UnitySDKPluginEvent.Issue(RenderEventType.TimeWarp);
			Pvr_UnitySDKRender.Instance.currEyeTextureIdx = Pvr_UnitySDKRender.Instance.nextEyeTextureIdx;
			Pvr_UnitySDKRender.Instance.nextEyeTextureIdx = (Pvr_UnitySDKRender.Instance.nextEyeTextureIdx + 1) % 3;
		}
	}

	private void CreateExternalSurface(Pvr_UnitySDKEyeOverlay overlayInstance, int layerDepth)
	{
		if (overlayInstance.externalAndroidSurfaceObject == IntPtr.Zero)
		{
			overlayInstance.externalAndroidSurfaceObject = Render.UPvr_CreateLayerAndroidSurface((int)overlayInstance.overlayType, layerDepth);
			UnityEngine.Debug.LogFormat("CreateExternalSurface: Overlay Type:{0}, LayerDepth:{1}, SurfaceObject:{2}", overlayInstance.overlayType, layerDepth, overlayInstance.externalAndroidSurfaceObject);
			if (overlayInstance.externalAndroidSurfaceObject != IntPtr.Zero && overlayInstance.externalAndroidSurfaceObjectCreated != null)
			{
				overlayInstance.externalAndroidSurfaceObjectCreated();
			}
		}
	}

	public bool SetEyeTrackingMode()
	{
		supportEyeTracking = (Pvr_UnitySDKAPI.System.UPvr_GetTrackingMode() & 4) != 0;
		bool result = false;
		if (EyeTracking && supportEyeTracking)
		{
			result = Pvr_UnitySDKAPI.System.UPvr_setTrackingMode(6);
		}
		UnityEngine.Debug.Log("SetEyeTrackingMode EyeTracking " + EyeTracking + " supportEyeTracking " + supportEyeTracking + " result " + result);
		return result;
	}

	public Vector3 GetEyeTrackingPos()
	{
		if (!Instance.EyeTracking)
		{
			return Vector3.zero;
		}
		bool flag = Pvr_UnitySDKAPI.System.UPvr_getEyeTrackingData(ref eyePoseData);
		if (!flag)
		{
			PLOG.E("UPvr_getEyeTrackingData failed " + flag);
			return Vector3.zero;
		}
		EyeDeviceInfo deviceInfo = GetDeviceInfo();
		Vector3 zero = Vector3.zero;
		zero.x = 0.5f * (deviceInfo.targetFrustumLeft.right - deviceInfo.targetFrustumLeft.left);
		zero.y = 0.5f * (deviceInfo.targetFrustumLeft.top - deviceInfo.targetFrustumLeft.bottom);
		zero.z = deviceInfo.targetFrustumLeft.near;
		Vector3 foveatedGazeDirection = eyePoseData.foveatedGazeDirection;
		float num = Vector3.Dot(foveatedGazeDirection, Vector3.forward);
		if (num > float.Epsilon)
		{
			eyePoint = foveatedGazeDirection * (zero.z / num);
			eyePoint.x /= zero.x;
			eyePoint.y /= zero.y;
		}
		return eyePoint;
	}

	private EyeDeviceInfo GetDeviceInfo()
	{
		float num = Mathf.Tan(Pvr_UnitySDKRender.Instance.EyeVFoV / 2f * ((float)Math.PI / 180f));
		float num2 = Mathf.Tan(Pvr_UnitySDKRender.Instance.EyeHFoV / 2f * ((float)Math.PI / 180f));
		EyeDeviceInfo result = default(EyeDeviceInfo);
		result.targetFrustumLeft.left = 0f - LeftEyeCamera.nearClipPlane * num2;
		result.targetFrustumLeft.right = LeftEyeCamera.nearClipPlane * num2;
		result.targetFrustumLeft.top = LeftEyeCamera.nearClipPlane * num;
		result.targetFrustumLeft.bottom = 0f - LeftEyeCamera.nearClipPlane * num;
		result.targetFrustumLeft.near = LeftEyeCamera.nearClipPlane;
		result.targetFrustumLeft.far = LeftEyeCamera.farClipPlane;
		result.targetFrustumRight.left = 0f - RightEyeCamera.nearClipPlane * num2;
		result.targetFrustumRight.right = RightEyeCamera.nearClipPlane * num2;
		result.targetFrustumRight.top = RightEyeCamera.nearClipPlane * num;
		result.targetFrustumRight.bottom = 0f - RightEyeCamera.nearClipPlane * num;
		result.targetFrustumRight.near = RightEyeCamera.nearClipPlane;
		result.targetFrustumRight.far = RightEyeCamera.farClipPlane;
		return result;
	}

	private void CreateFadeMesh()
	{
		fadeMaterial = new Material(Shader.Find("Pvr_UnitySDK/Fade"));
		fadeMeshFilter = base.gameObject.AddComponent<MeshFilter>();
		fadeMeshRenderer = base.gameObject.AddComponent<MeshRenderer>();
		Mesh mesh = new Mesh();
		fadeMeshFilter.mesh = mesh;
		Vector3[] array = new Vector3[4];
		float num = 2f;
		float num2 = 2f;
		float z = 1f;
		array[0] = new Vector3(0f - num, 0f - num2, z);
		array[1] = new Vector3(num, 0f - num2, z);
		array[2] = new Vector3(0f - num, num2, z);
		array[3] = new Vector3(num, num2, z);
		mesh.vertices = array;
		mesh.triangles = new int[6] { 0, 2, 1, 2, 3, 1 };
		mesh.normals = new Vector3[4]
		{
			-Vector3.forward,
			-Vector3.forward,
			-Vector3.forward,
			-Vector3.forward
		};
		mesh.uv = new Vector2[4]
		{
			new Vector2(0f, 0f),
			new Vector2(1f, 0f),
			new Vector2(0f, 1f),
			new Vector2(1f, 1f)
		};
	}

	private void DestoryFadeMesh()
	{
		if (fadeMeshRenderer != null)
		{
			UnityEngine.Object.Destroy(fadeMeshRenderer);
		}
		if (fadeMaterial != null)
		{
			UnityEngine.Object.Destroy(fadeMaterial);
		}
		if (fadeMeshFilter != null)
		{
			UnityEngine.Object.Destroy(fadeMeshFilter);
		}
	}

	public void SetCurrentAlpha(float alpha)
	{
		currentAlpha = alpha;
		SetMaterialAlpha();
	}

	private IEnumerator ScreenFade(float startAlpha, float endAlpha)
	{
		float elapsedTime = 0f;
		while (elapsedTime < fadeTime)
		{
			elapsedTime += Time.deltaTime;
			nowFadeAlpha = Mathf.Lerp(startAlpha, endAlpha, Mathf.Clamp01(elapsedTime / fadeTime));
			SetMaterialAlpha();
			yield return new WaitForEndOfFrame();
		}
	}

	private void SetMaterialAlpha()
	{
		UnityEngine.Color color = fadeColor;
		color.a = Mathf.Max(currentAlpha, nowFadeAlpha);
		isFading = color.a > 0f;
		if (fadeMaterial != null)
		{
			fadeMaterial.color = color;
			fadeMaterial.renderQueue = renderQueue;
			fadeMeshRenderer.material = fadeMaterial;
			fadeMeshRenderer.enabled = isFading;
		}
	}

	public bool GfxDeviceAdvanceFrameGLES()
	{
		return false;
	}
}
public class Pvr_UnitySDKEyeOverlay : MonoBehaviour, IComparable<Pvr_UnitySDKEyeOverlay>
{
	public delegate void ExternalAndroidSurfaceObjectCreated();

	public enum OverlayShape
	{
		Quad,
		Cylinder,
		Equirect
	}

	public enum OverlayType
	{
		Overlay,
		Underlay
	}

	public enum OverlayTexFilterMode
	{
		NotCare,
		Nearest,
		Linear,
		Nearest_Mipmap_Nearest,
		Linear_Mipmap_Nearest,
		Nearest_Mipmap_Linear,
		Linear_Mipmap_Linear
	}

	public static List<Pvr_UnitySDKEyeOverlay> Instances = new List<Pvr_UnitySDKEyeOverlay>();

	public int layerIndex;

	public OverlayType overlayType;

	public OverlayShape overlayShape;

	public Transform layerTransform;

	public Texture[] layerTextures = new Texture[2];

	public int[] layerTextureIds = new int[2];

	public Matrix4x4[] MVMatrixs = new Matrix4x4[2];

	public Vector3[] ModelScales = new Vector3[2];

	public Quaternion[] ModelRotations = new Quaternion[2];

	public Vector3[] ModelTranslations = new Vector3[2];

	public Quaternion[] CameraRotations = new Quaternion[2];

	public Vector3[] CameraTranslations = new Vector3[2];

	public Camera[] layerEyeCamera = new Camera[2];

	public bool overrideColorScaleAndOffset;

	public Vector4 colorScale = Vector4.one;

	public Vector4 colorOffset = Vector4.zero;

	private Vector4 overlayLayerColorScaleDefault = Vector4.one;

	private Vector4 overlayLayerColorOffsetDefault = Vector4.zero;

	public bool isExternalAndroidSurface;

	public IntPtr externalAndroidSurfaceObject = IntPtr.Zero;

	public ExternalAndroidSurfaceObjectCreated externalAndroidSurfaceObjectCreated;

	public int CompareTo(Pvr_UnitySDKEyeOverlay other)
	{
		return layerIndex.CompareTo(other.layerIndex);
	}

	private void Awake()
	{
		Instances.Add(this);
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.BothEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.BothEyeCamera;
		}
		else if (Pvr_UnitySDKManager.SDK.Monoscopic)
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.MonoEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.MonoEyeCamera;
		}
		else
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.LeftEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.RightEyeCamera;
		}
		layerTransform = GetComponent<Transform>();
		if (layerTransform != null)
		{
			MeshRenderer component = layerTransform.GetComponent<MeshRenderer>();
			if (component != null)
			{
				component.enabled = false;
			}
		}
		InitializeBuffer();
	}

	private void LateUpdate()
	{
		UpdateCoords();
	}

	private void OnDestroy()
	{
		Instances.Remove(this);
	}

	public void RefreshCamera()
	{
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.BothEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.BothEyeCamera;
		}
		else if (Pvr_UnitySDKManager.SDK.Monoscopic)
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.MonoEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.MonoEyeCamera;
		}
		else
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.LeftEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.RightEyeCamera;
		}
	}

	private void InitializeBuffer()
	{
		OverlayShape overlayShape = this.overlayShape;
		if ((uint)overlayShape > 2u)
		{
			return;
		}
		for (int i = 0; i < layerTextureIds.Length; i++)
		{
			if (layerTextures[i] != null)
			{
				layerTextureIds[i] = layerTextures[i].GetNativeTexturePtr().ToInt32();
			}
			else
			{
				UnityEngine.Debug.LogWarning($"{(Eye)i} Texture is null!");
			}
		}
	}

	private void UpdateCoords()
	{
		if (layerTransform == null || !layerTransform.gameObject.activeSelf || layerEyeCamera[0] == null || layerEyeCamera[1] == null)
		{
			return;
		}
		for (int i = 0; i < MVMatrixs.Length; i++)
		{
			if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
			{
				Matrix4x4[] stereoWorldToCameraMat = Pvr_UnitySDKSinglePass.GetStereoWorldToCameraMat();
				MVMatrixs[i] = stereoWorldToCameraMat[i] * layerTransform.localToWorldMatrix;
			}
			else
			{
				MVMatrixs[i] = layerEyeCamera[i].worldToCameraMatrix * layerTransform.localToWorldMatrix;
			}
			ModelScales[i] = layerTransform.localScale;
			ModelRotations[i] = layerTransform.rotation;
			ModelTranslations[i] = layerTransform.position;
			CameraRotations[i] = layerEyeCamera[i].transform.rotation;
			CameraTranslations[i] = layerEyeCamera[i].transform.position;
		}
	}

	public void SetTexture(Texture texture)
	{
		for (int i = 0; i < layerTextures.Length; i++)
		{
			layerTextures[i] = texture;
		}
		InitializeBuffer();
	}

	public void SetLayerColorScaleAndOffset(Vector4 scale, Vector4 offset)
	{
		colorScale = scale;
		colorOffset = offset;
	}

	public Vector4 GetLayerColorScale()
	{
		if (!overrideColorScaleAndOffset)
		{
			return overlayLayerColorScaleDefault;
		}
		return colorScale;
	}

	public Vector4 GetLayerColorOffset()
	{
		if (!overrideColorScaleAndOffset)
		{
			return overlayLayerColorOffsetDefault;
		}
		return colorOffset;
	}
}
public class Pvr_UnitySDKRender
{
	private static Pvr_UnitySDKRender instance;

	public AndroidJavaObject activity;

	public static AndroidJavaClass javaVrActivityClass;

	public static AndroidJavaClass javaSysActivityClass;

	public static AndroidJavaClass javaserviceClass;

	public static AndroidJavaClass javaVrActivityLongReceiver;

	public static AndroidJavaClass javaVrActivityClientClass;

	private bool canConnecttoActivity;

	private bool isInitrenderThread = true;

	private string model;

	private Vector2 prefinger1 = new Vector2(0f, 0f);

	private Vector2 prefinger2 = new Vector2(0f, 0f);

	public int eyeTextureCount = 6;

	public RenderTexture[] eyeTextures;

	public int[] eyeTextureIds;

	public int currEyeTextureIdx;

	public int nextEyeTextureIdx = 1;

	public int lastEyeTextureIdx;

	public bool isSwitchSDK;

	public int RenderviewNumber;

	public bool isFirstStartup = true;

	public bool isShellMode;

	private StereoRenderingPathPico stereoRenderPath;

	private float rtScaleFactor = 1f;

	private float eyeVFov = 90f;

	private float eyeHFov = 90f;

	public static Pvr_UnitySDKRender Instance
	{
		get
		{
			if (instance == null)
			{
				instance = new Pvr_UnitySDKRender();
			}
			return instance;
		}
		set
		{
			instance = value;
		}
	}

	public StereoRenderingPathPico StereoRenderPath => stereoRenderPath;

	public SDKStereoRendering StereoRendering { get; private set; }

	public float RtScaleFactor
	{
		get
		{
			return rtScaleFactor;
		}
		set
		{
			if (value != rtScaleFactor)
			{
				rtScaleFactor = value;
				ReCreateEyeBuffer();
			}
		}
	}

	public float EyeVFoV
	{
		get
		{
			return eyeVFov;
		}
		set
		{
			if (value != eyeVFov)
			{
				eyeVFov = value;
			}
		}
	}

	public float EyeHFoV
	{
		get
		{
			return eyeHFov;
		}
		set
		{
			if (value != eyeHFov)
			{
				eyeHFov = value;
			}
		}
	}

	public Pvr_UnitySDKRender()
	{
		if (!canConnecttoActivity)
		{
			ConnectToAndriod();
			PLOG.I("PvrLog Init Render Ability Success!");
			isInitrenderThread = false;
		}
		Init();
	}

	public void ConnectToAndriod()
	{
		try
		{
			UnityEngine.Debug.Log("PvrLog SDK Version :  " + Pvr_UnitySDKAPI.System.UPvr_GetSDKVersion().ToString() + "  Unity Script Version :" + Pvr_UnitySDKAPI.System.UPvr_GetUnitySDKVersion().ToString());
			AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
			activity = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
			javaVrActivityClass = new AndroidJavaClass("com.psmart.vrlib.VrActivity");
			javaserviceClass = new AndroidJavaClass("com.picovr.picovrlib.hummingbirdclient.UnityClient");
			javaVrActivityLongReceiver = new AndroidJavaClass("com.psmart.vrlib.HomeKeyReceiver");
			javaSysActivityClass = new AndroidJavaClass("com.psmart.aosoperation.SysActivity");
			javaVrActivityClientClass = new AndroidJavaClass("com.psmart.vrlib.PvrClient");
			Pvr_UnitySDKAPI.System.Pvr_SetInitActivity(activity.GetRawObject(), javaVrActivityClass.GetRawClass());
			model = javaVrActivityClass.CallStatic<string>("Pvr_GetBuildModel", Array.Empty<object>());
			double[] result = new double[5];
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaVrActivityClass, "getDPIParameters", activity);
			int res = -1;
			Render.UPvr_GetIntConfig(4, ref res);
			string result2 = "";
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result2, javaserviceClass, "getSysproc", "persist.pvr.debug.appfps");
			if (result2 != "")
			{
				Pvr_UnitySDKManager.SDK.systemFPS = Convert.ToBoolean(Convert.ToInt16(result2));
			}
			if (res == 0)
			{
				Render.UPvr_ChangeScreenParameters(model, (int)result[0], (int)result[1], result[2], result[3], result[4]);
				Screen.sleepTimeout = -1;
			}
			if (Pvr_UnitySDKAPI.System.UPvr_IsPicoActivity())
			{
				UnityEngine.Debug.Log("ConnectToAndriod set monoPresentation success ?-------------" + Pvr_UnitySDKAPI.System.UPvr_SetMonoPresentation());
				UnityEngine.Debug.Log("ConnectToAndriod presentation existed ?-------------" + Pvr_UnitySDKAPI.System.UPvr_IsPresentationExisted());
			}
			isShellMode = GetIsShellMode();
			UnityEngine.Debug.Log("ConnectToAndriod isShellMode ?-------------" + isShellMode);
		}
		catch (AndroidJavaException ex)
		{
			PLOG.E("ConnectToAndriod--catch" + ex.Message);
		}
		canConnecttoActivity = true;
	}

	public void Init()
	{
		if (InitRenderAbility())
		{
			UnityEngine.Debug.Log("PvrLog Init Render Ability Success!");
			isInitrenderThread = false;
		}
		else
		{
			UnityEngine.Debug.Log("PvrLog Init Render Ability Failed!");
		}
	}

	private bool InitRenderAbility()
	{
		if (UpdateRenderParaFrame() && CreateEyeBuffer())
		{
			float num = Pvr_UnitySDKAPI.System.UPvr_GetIPD();
			Pvr_UnitySDKManager.SDK.leftEyeOffset = new Vector3((0f - num) / 2f, 0f, 0f);
			Pvr_UnitySDKManager.SDK.rightEyeOffset = new Vector3(num / 2f, 0f, 0f);
			return true;
		}
		return false;
	}

	private bool UpdateRenderParaFrame()
	{
		EyeVFoV = GetEyeVFOV();
		EyeHFoV = GetEyeHFOV();
		Pvr_UnitySDKManager.SDK.EyesAspect = EyeHFoV / EyeVFoV;
		return true;
	}

	private bool CreateEyeBuffer()
	{
		Vector2 eyeBufferResolution = GetEyeBufferResolution();
		if (isFirstStartup)
		{
			InitSinglePass();
			Pvr_UnitySDKAPI.System.UPvr_SetSinglePassDepthBufferWidthHeight((int)eyeBufferResolution.x, (int)eyeBufferResolution.y);
		}
		eyeTextures = new RenderTexture[eyeTextureCount];
		eyeTextureIds = new int[eyeTextureCount];
		for (int i = 0; i < eyeTextureCount; i++)
		{
			if (null == eyeTextures[i])
			{
				try
				{
					ConfigureEyeBuffer(i, eyeBufferResolution);
				}
				catch (Exception ex)
				{
					PLOG.E("ConfigureEyeBuffer ERROR " + ex.Message);
					throw;
				}
			}
			if (!eyeTextures[i].IsCreated())
			{
				eyeTextures[i].Create();
				eyeTextureIds[i] = eyeTextures[i].GetNativeTexturePtr().ToInt32();
			}
			eyeTextureIds[i] = eyeTextures[i].GetNativeTexturePtr().ToInt32();
		}
		return true;
	}

	private void InitSinglePass()
	{
		bool flag = true;
		if (GraphicsSettings.renderPipelineAsset != null)
		{
			flag = false;
			if (!BoundarySystem.UPvr_EnableLWRP(enable: true))
			{
				UnityEngine.Debug.Log("UPvr_EnableLWRP return false");
			}
			Vector2 eyeBufferResolution = GetEyeBufferResolution();
			if (!BoundarySystem.UPvr_SetViewportSize((int)eyeBufferResolution.x, (int)eyeBufferResolution.y))
			{
				UnityEngine.Debug.Log("UPvr_SetViewportSize return false");
			}
		}
		if (Pvr_UnitySDKProjectSetting.GetProjectConfig().usesinglepass)
		{
			bool flag2 = false;
			if (flag)
			{
				flag2 = Pvr_UnitySDKAPI.System.UPvr_EnableSinglePass(enable: true);
			}
			if (flag2)
			{
				StereoRendering = new Pvr_UnitySDKSinglePass();
				stereoRenderPath = StereoRenderingPathPico.SinglePass;
				eyeTextureCount = 3;
			}
			UnityEngine.Debug.Log("EnableSinglePass supportSinglePass " + flag + " result " + flag2);
		}
	}

	public float GetEyeVFOV()
	{
		float res = 102f;
		try
		{
			Render.UPvr_GetFloatConfig(1, ref res);
			if (res <= 0f)
			{
				res = 102f;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("GetEyeVFOV ERROR! " + ex.Message);
			throw;
		}
		return res;
	}

	public float GetEyeHFOV()
	{
		float res = 102f;
		try
		{
			Render.UPvr_GetFloatConfig(2, ref res);
			if (res <= 0f)
			{
				res = 102f;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("GetEyeHFOV ERROR! " + ex.Message);
			throw;
		}
		return res;
	}

	private void ConfigureEyeBuffer(int eyeTextureIndex, Vector2 resolution)
	{
		int width = (int)resolution.x;
		int height = (int)resolution.y;
		eyeTextures[eyeTextureIndex] = new RenderTexture(width, height, (int)Pvr_UnitySDKProjectSetting.GetProjectConfig().rtBitDepth, Pvr_UnitySDKProjectSetting.GetProjectConfig().rtFormat);
		if (StereoRenderPath == StereoRenderingPathPico.MultiPass)
		{
			eyeTextures[eyeTextureIndex].anisoLevel = 0;
			eyeTextures[eyeTextureIndex].antiAliasing = Mathf.Max(QualitySettings.antiAliasing, (int)Pvr_UnitySDKProjectSetting.GetProjectConfig().rtAntiAlising);
			UnityEngine.Debug.Log("MultiPass ConfigureEyeBuffer eyeTextureIndex " + eyeTextureIndex);
		}
		else if (StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			eyeTextures[eyeTextureIndex].useMipMap = false;
			eyeTextures[eyeTextureIndex].wrapMode = TextureWrapMode.Clamp;
			eyeTextures[eyeTextureIndex].filterMode = FilterMode.Bilinear;
			eyeTextures[eyeTextureIndex].anisoLevel = 1;
			eyeTextures[eyeTextureIndex].dimension = TextureDimension.Tex2DArray;
			eyeTextures[eyeTextureIndex].volumeDepth = 2;
			UnityEngine.Debug.Log("SinglePass ConfigureEyeBuffer eyeTextureIndex " + eyeTextureIndex);
		}
		eyeTextures[eyeTextureIndex].Create();
		if (eyeTextures[eyeTextureIndex].IsCreated())
		{
			eyeTextureIds[eyeTextureIndex] = eyeTextures[eyeTextureIndex].GetNativeTexturePtr().ToInt32();
			UnityEngine.Debug.Log("eyeTextureIndex : " + eyeTextureIndex);
		}
	}

	public bool ReCreateEyeBuffer()
	{
		if (!Pvr_UnitySDKProjectSetting.GetProjectConfig().usedefaultRenderTexture)
		{
			for (int i = 0; i < eyeTextureCount; i++)
			{
				if (eyeTextures[i] != null)
				{
					eyeTextures[i].Release();
				}
			}
			Array.Clear(eyeTextures, 0, eyeTextures.Length);
			return CreateEyeBuffer();
		}
		return false;
	}

	public void ReInit()
	{
		if (canConnecttoActivity && isInitrenderThread)
		{
			Init();
		}
	}

	public void IssueRenderThread()
	{
		if (canConnecttoActivity && !isInitrenderThread)
		{
			switch (QualitySettings.activeColorSpace)
			{
			case ColorSpace.Gamma:
				Render.UPvr_SetColorspaceType(0);
				break;
			case ColorSpace.Linear:
				Render.UPvr_SetColorspaceType(1);
				break;
			}
			Pvr_UnitySDKPluginEvent.Issue(RenderEventType.InitRenderThread);
			isInitrenderThread = true;
			if (StereoRendering != null)
			{
				StereoRendering.OnSDKRenderInited();
			}
			UnityEngine.Debug.Log("PvrLog IssueRenderThread end");
		}
		else
		{
			PLOG.I("PvrLog IssueRenderThread  canConnecttoActivity = " + canConnecttoActivity);
		}
	}

	private void AutoAdpatForPico1s()
	{
		Vector2 position = Input.touches[0].position;
		Vector2 position2 = Input.touches[1].position;
		if (Vector2.Distance(prefinger1, position) > 2f && Vector2.Distance(prefinger2, position2) > 2f)
		{
			float midH = (Input.touches[0].position.x + Input.touches[1].position.x) / (float)Screen.width - 1f;
			float midV = (Input.touches[0].position.y + Input.touches[1].position.y) / (float)Screen.height - 1f;
			Render.UPvr_SetRatio(midH, midV);
		}
		prefinger1 = position;
		prefinger2 = position2;
	}

	public Vector2 GetEyeBufferResolution()
	{
		int res = 1024;
		int res2 = 1024;
		if (Pvr_UnitySDKProjectSetting.GetProjectConfig().usedefaultRenderTexture)
		{
			try
			{
				Render.UPvr_GetIntConfig(0, ref res);
				Render.UPvr_GetIntConfig(1, ref res2);
			}
			catch (Exception ex)
			{
				PLOG.E("GetEyeBufferResolution ERROR! " + ex.Message);
				throw;
			}
		}
		else
		{
			res = (int)(Pvr_UnitySDKProjectSetting.GetProjectConfig().customRTSize.x * RtScaleFactor);
			res2 = (int)(Pvr_UnitySDKProjectSetting.GetProjectConfig().customRTSize.y * RtScaleFactor);
		}
		Vector2 vector = new Vector2(res, res2);
		UnityEngine.Debug.Log(string.Concat("DISFT Customize RenderTexture:", vector, ", scaleFactor: ", RtScaleFactor));
		return vector;
	}

	public bool GetUsePredictedMatrix()
	{
		return true;
	}

	public bool GetIsShellMode()
	{
		if (activity == null)
		{
			return false;
		}
		using (AndroidJavaObject androidJavaObject = activity.Call<AndroidJavaObject>("getPackageManager", Array.Empty<object>()).Call<AndroidJavaObject>("getApplicationInfo", new object[2]
		{
			activity.Call<string>("getPackageName", Array.Empty<object>()),
			128
		}))
		{
			AndroidJavaObject androidJavaObject2 = androidJavaObject.Get<AndroidJavaObject>("metaData");
			if (androidJavaObject2 != null)
			{
				if (androidJavaObject2.Call<int>("getInt", new object[1] { "shell_mode" }) == 1)
				{
					return true;
				}
				return false;
			}
		}
		return false;
	}
}
public class Pvr_UnitySDKSinglePass : SDKStereoRendering
{
	private static Camera bothCamera;

	private Matrix4x4[] unity_StereoMatrixP = new Matrix4x4[2];

	private Matrix4x4[] unity_StereoMatrixInvP = new Matrix4x4[2];

	private static Matrix4x4[] unity_StereoWorldToCamera = new Matrix4x4[2];

	private Matrix4x4[] unity_StereoCameraToWorld = new Matrix4x4[2];

	private Matrix4x4[] unity_StereoMatrixVP = new Matrix4x4[2];

	private Vector3[] eyesOffset = new Vector3[2];

	private static Matrix4x4[] eyesOffsetMatrix = new Matrix4x4[2];

	private CommandBuffer commandBufferBeforeForwardOpaque;

	private CommandBuffer commandBufferBeforeSkybox;

	private CommandBuffer commandBufferAfterSkybox;

	public override void InitEye(Camera eye)
	{
		bothCamera = eye;
		bothCamera.stereoSeparation = 0.0625f;
		bothCamera.stereoConvergence = 0f;
		bothCamera.allowHDR = false;
		bothCamera.allowDynamicResolution = false;
		SetEyesPosition();
		SetEyeProjection();
		Pvr_UnitySDKSensor.EyeFovChanged = (Action)Delegate.Combine(Pvr_UnitySDKSensor.EyeFovChanged, new Action(SetEyeProjection));
		UnityEngine.Debug.Log("SinglePass Init success! CameraName = " + eye.transform.name + " eye.eyeSide " + eye.GetComponent<Pvr_UnitySDKEye>().eyeSide);
	}

	public override void OnSDKRenderInited()
	{
		OnSDKRenderInited_SinglePass();
	}

	public override void OnSDKPreRender()
	{
		SinglePassPreRender();
	}

	public override void OnSDKPostRender()
	{
		SwitchKeywordAndDeviceView(enable: false);
	}

	public void OnSDKRenderInited_SinglePass()
	{
		Shader.SetGlobalVectorArray("unity_StereoScaleOffset", new Vector4[2]
		{
			new Vector4(1f, 1f, 0f, 0f),
			new Vector4(1f, 1f, 0.5f, 0f)
		});
		SetAntiAliasing();
		UnityEngine.Debug.Log("OnSDKRenderInited_SinglePass");
	}

	private void SetAntiAliasing()
	{
		int num = Mathf.Max(QualitySettings.antiAliasing, (int)Pvr_UnitySDKProjectSetting.GetProjectConfig().rtAntiAlising);
		Pvr_UnitySDKAPI.System.UPvr_SetAntiAliasing(num);
		UnityEngine.Debug.Log("SetAntiAliasing  antiAliasing = " + num);
	}

	public void SetEyesPosition()
	{
		float res = 0.0625f;
		int configsenum = 0;
		if (Render.UPvr_GetFloatConfig(configsenum, ref res) != 0)
		{
			PLOG.E("Cannot get ipd");
			res = 0.0625f;
		}
		bothCamera.stereoSeparation = res;
		Vector3 vector = new Vector3((0f - res) / 2f, 0f, 0f);
		Vector3 vector2 = new Vector3(res / 2f, 0f, 0f);
		Vector3 vector3 = (vector + vector2) / 2f;
		bothCamera.transform.localPosition = vector3;
		bothCamera.transform.localRotation = Quaternion.identity;
		Vector3 vector4 = vector - vector3;
		Vector3 vector5 = vector2 - vector3;
		eyesOffset[0] = vector4;
		eyesOffset[1] = vector5;
		eyesOffsetMatrix[0] = Matrix4x4.TRS(vector4, Quaternion.identity, Vector3.one);
		eyesOffsetMatrix[1] = Matrix4x4.TRS(vector5, Quaternion.identity, Vector3.one);
	}

	public void SetEyeProjection()
	{
		Matrix4x4 projection = GetProjection(bothCamera.nearClipPlane, bothCamera.farClipPlane);
		Matrix4x4 projection2 = GetProjection(bothCamera.nearClipPlane, bothCamera.farClipPlane);
		SetStereoProjectionMatrix(projection, projection2);
	}

	private static Matrix4x4 GetProjection(float near, float far)
	{
		if (near < 0.01f)
		{
			near = 0.01f;
		}
		if (far < 0.02f)
		{
			far = 0.02f;
		}
		_ = Matrix4x4.identity;
		return MakeProjection(near, far);
	}

	public static Matrix4x4 MakeProjection(float n, float f)
	{
		Vector2 eyeBufferResolution = Pvr_UnitySDKRender.Instance.GetEyeBufferResolution();
		float num = Mathf.Tan(Pvr_UnitySDKRender.Instance.EyeVFoV / 2f * ((float)Math.PI / 180f));
		float num2 = 1f / num;
		Matrix4x4 zero = Matrix4x4.zero;
		zero[0, 0] = num2 / (eyeBufferResolution.x / eyeBufferResolution.y);
		zero[1, 1] = num2;
		zero[2, 2] = (0f - (f + n)) / (f - n);
		zero[2, 3] = -2f * f * n / (f - n);
		zero[3, 2] = -1f;
		return zero;
	}

	public void SetStereoProjectionMatrix(Matrix4x4 left, Matrix4x4 right)
	{
		unity_StereoMatrixP[0] = left;
		unity_StereoMatrixInvP[0] = left.inverse;
		unity_StereoMatrixP[1] = right;
		unity_StereoMatrixInvP[1] = right.inverse;
	}

	private void SwitchKeywordAndDeviceView(bool enable)
	{
		if (enable)
		{
			Shader.EnableKeyword("STEREO_MULTIVIEW_ON");
			Shader.EnableKeyword("UNITY_SINGLE_PASS_STEREO");
			XRSettings.showDeviceView = false;
		}
		else
		{
			XRSettings.showDeviceView = true;
			Shader.DisableKeyword("UNITY_SINGLE_PASS_STEREO");
			Shader.DisableKeyword("STEREO_MULTIVIEW_ON");
		}
	}

	public static Matrix4x4[] GetStereoWorldToCameraMat()
	{
		Matrix4x4 worldToCameraMatrix = bothCamera.worldToCameraMatrix;
		unity_StereoWorldToCamera[0] = eyesOffsetMatrix[0].inverse * worldToCameraMatrix;
		unity_StereoWorldToCamera[1] = eyesOffsetMatrix[1].inverse * worldToCameraMatrix;
		return unity_StereoWorldToCamera;
	}

	public void SinglePassPreRender()
	{
		SwitchKeywordAndDeviceView(enable: true);
		Shader.SetGlobalMatrixArray("unity_StereoCameraProjection", unity_StereoMatrixP);
		Shader.SetGlobalMatrixArray("unity_StereoCameraInvProjection", unity_StereoMatrixInvP);
		Shader.SetGlobalMatrixArray("unity_StereoMatrixP", unity_StereoMatrixP);
		Matrix4x4 worldToCameraMatrix = bothCamera.worldToCameraMatrix;
		Matrix4x4 cameraToWorldMatrix = bothCamera.cameraToWorldMatrix;
		unity_StereoCameraToWorld[0] = cameraToWorldMatrix * eyesOffsetMatrix[0];
		unity_StereoCameraToWorld[1] = cameraToWorldMatrix * eyesOffsetMatrix[1];
		Shader.SetGlobalMatrixArray("unity_StereoCameraToWorld", unity_StereoCameraToWorld);
		unity_StereoWorldToCamera[0] = eyesOffsetMatrix[0].inverse * worldToCameraMatrix;
		unity_StereoWorldToCamera[1] = eyesOffsetMatrix[1].inverse * worldToCameraMatrix;
		Shader.SetGlobalMatrixArray("unity_StereoWorldToCamera", unity_StereoWorldToCamera);
		Vector4[] values = new Vector4[2]
		{
			bothCamera.transform.position + eyesOffset[0],
			bothCamera.transform.position + eyesOffset[1]
		};
		Shader.SetGlobalVectorArray("unity_StereoWorldSpaceCameraPos", values);
		Shader.SetGlobalMatrixArray("unity_StereoMatrixV", unity_StereoWorldToCamera);
		Shader.SetGlobalMatrixArray("unity_StereoMatrixInvV", unity_StereoCameraToWorld);
		unity_StereoMatrixVP[0] = unity_StereoMatrixP[0] * unity_StereoWorldToCamera[0];
		unity_StereoMatrixVP[1] = unity_StereoMatrixP[1] * unity_StereoWorldToCamera[1];
		Shader.SetGlobalMatrixArray("unity_StereoMatrixVP", unity_StereoMatrixVP);
		SetRenderTextureWithDepth();
		SetCommandBuffers();
	}

	private void SetCommandBuffers()
	{
		if (commandBufferBeforeForwardOpaque == null)
		{
			commandBufferBeforeForwardOpaque = new CommandBuffer();
			Pvr_UnitySDKPluginEvent.SetSinglePassBeforeForwardOpaque(commandBufferBeforeForwardOpaque);
			commandBufferBeforeForwardOpaque.ClearRenderTarget(clearDepth: true, clearColor: true, bothCamera.backgroundColor);
			commandBufferBeforeForwardOpaque.name = "SinglePassPrepare";
		}
		bothCamera.RemoveCommandBuffer(CameraEvent.BeforeForwardOpaque, commandBufferBeforeForwardOpaque);
		bothCamera.AddCommandBuffer(CameraEvent.BeforeForwardOpaque, commandBufferBeforeForwardOpaque);
		if (commandBufferAfterSkybox == null)
		{
			commandBufferAfterSkybox = new CommandBuffer();
		}
		bothCamera.RemoveCommandBuffer(CameraEvent.AfterSkybox, commandBufferAfterSkybox);
		commandBufferAfterSkybox.Clear();
		commandBufferAfterSkybox.SetGlobalMatrixArray("unity_StereoMatrixVP", unity_StereoMatrixVP);
		commandBufferAfterSkybox.name = "SinglePassAfterSkyBox";
		bothCamera.AddCommandBuffer(CameraEvent.AfterSkybox, commandBufferAfterSkybox);
		if (commandBufferBeforeSkybox == null)
		{
			commandBufferBeforeSkybox = new CommandBuffer();
		}
		Matrix4x4 transpose = (Matrix4x4.LookAt(Vector3.zero, bothCamera.transform.forward, bothCamera.transform.up) * Matrix4x4.Scale(new Vector3(1f, 1f, -1f))).transpose;
		Matrix4x4 matrix4x = unity_StereoMatrixP[0];
		Matrix4x4 matrix4x2 = unity_StereoMatrixP[1];
		matrix4x.m22 = -1f;
		matrix4x2.m22 = -1f;
		Matrix4x4[] values = new Matrix4x4[2]
		{
			matrix4x * transpose,
			matrix4x2 * transpose
		};
		bothCamera.RemoveCommandBuffer(CameraEvent.BeforeSkybox, commandBufferBeforeSkybox);
		commandBufferBeforeSkybox.Clear();
		commandBufferBeforeSkybox.SetGlobalMatrixArray("unity_StereoMatrixVP", values);
		commandBufferBeforeSkybox.name = "SinglePassAfterSkybox";
		bothCamera.AddCommandBuffer(CameraEvent.BeforeSkybox, commandBufferBeforeSkybox);
	}

	private void SetRenderTextureWithDepth()
	{
		Pvr_UnitySDKAPI.System.UPvr_SetCurrentRenderTexture((uint)Pvr_UnitySDKRender.Instance.eyeTextureIds[Pvr_UnitySDKRender.Instance.currEyeTextureIdx]);
	}
}
public abstract class SDKStereoRendering
{
	public abstract void InitEye(Camera eye);

	public abstract void OnSDKRenderInited();

	public abstract void OnSDKPreRender();

	public abstract void OnSDKPostRender();
}
public class HighlightAtGaze : MonoBehaviour
{
	public UnityEngine.Color HighlightColor = UnityEngine.Color.red;

	public float AnimationTime = 0.1f;

	private Renderer myRenderer;

	private UnityEngine.Color originalColor;

	private UnityEngine.Color targetColor;

	private EyeTrackingGazeRay gazeRay;

	private void Start()
	{
		myRenderer = GetComponent<Renderer>();
		originalColor = myRenderer.material.color;
		targetColor = originalColor;
	}

	private void Update()
	{
		Pvr_UnitySDKAPI.System.UPvr_getEyeTrackingGazeRay(ref gazeRay);
		if (Physics.Raycast(new Ray(gazeRay.Origin, gazeRay.Direction), out var hitInfo))
		{
			if (hitInfo.transform.name == base.transform.name)
			{
				if (targetColor != HighlightColor)
				{
					targetColor = HighlightColor;
				}
			}
			else if (targetColor != originalColor)
			{
				targetColor = originalColor;
			}
		}
		else if (targetColor != originalColor)
		{
			targetColor = originalColor;
		}
		myRenderer.material.color = UnityEngine.Color.Lerp(myRenderer.material.color, targetColor, Time.deltaTime * (1f / AnimationTime));
	}
}
public class RayVisualizer : MonoBehaviour
{
	private LineRenderer _line;

	private EyeTrackingGazeRay gazeRay;

	private void Start()
	{
		_line = base.gameObject.GetComponent<LineRenderer>();
		_line.startWidth = 0.002f;
		_line.endWidth = 0.002f;
	}

	private void Update()
	{
		Matrix4x4 matrix = Pvr_UnitySDKSensor.Instance.HeadPose.Matrix;
		Pvr_UnitySDKAPI.System.UPvr_getEyeTrackingGazeRay(ref gazeRay);
		_line.SetPosition(0, matrix.MultiplyPoint(new Vector3(0f, -0.05f, 0.2f)));
		_line.SetPosition(1, gazeRay.Origin + gazeRay.Direction * 20f);
	}
}
public class GetSeeThroughImage : MonoBehaviour
{
	public RawImage viewImage_left;

	public RawImage viewImage_right;

	private int width;

	private int height;

	private RenderTexture cameraTex_left;

	private RenderTexture cameraTex_right;

	private bool cameraPreview;

	private void Start()
	{
		CreateTexture();
	}

	private void Update()
	{
		if (Input.GetKey(KeyCode.JoystickButton0))
		{
			DrawTexture();
		}
	}

	private void OnDestory()
	{
		if (cameraPreview)
		{
			cameraPreview = false;
			BoundarySystem.UPvr_StopCameraFrame();
		}
	}

	private void CreateTexture()
	{
		width = 600;
		height = 600;
		BoundarySystem.UPvr_BoundarySetCameraImageRect(width, height);
		cameraTex_left = new RenderTexture(width, height, 24, RenderTextureFormat.Default);
		cameraTex_right = new RenderTexture(width, height, 24, RenderTextureFormat.Default);
		cameraTex_left.Create();
		cameraTex_right.Create();
		viewImage_left.texture = cameraTex_left;
		viewImage_right.texture = cameraTex_right;
	}

	private void DrawTexture()
	{
		if (!cameraPreview)
		{
			cameraPreview = true;
			BoundarySystem.UPvr_StartCameraFrame();
		}
		BoundarySystem.UPvr_BoundaryGetSeeThroughData(0, cameraTex_left);
		BoundarySystem.UPvr_BoundaryGetSeeThroughData(1, cameraTex_right);
	}
}
public class OverlayExternalSurfaceDemo : MonoBehaviour
{
	public string movieName;

	public Pvr_UnitySDKEyeOverlay.OverlayType overlayType;

	public Pvr_UnitySDKEyeOverlay.OverlayShape overlayShape;

	private Pvr_UnitySDKEyeOverlay overlay;

	private const string TAG = "[ExternalSurface]>>>>>>";

	private void Awake()
	{
		overlay = GetComponent<Pvr_UnitySDKEyeOverlay>();
		if (overlay == null)
		{
			UnityEngine.Debug.LogError("[ExternalSurface]>>>>>>Overlay is null!");
			overlay = base.gameObject.AddComponent<Pvr_UnitySDKEyeOverlay>();
		}
		overlay.overlayType = overlayType;
		overlay.overlayShape = overlayShape;
		overlay.isExternalAndroidSurface = true;
	}

	private void Start()
	{
		if (!string.IsNullOrEmpty(movieName))
		{
			StartPlay(Application.streamingAssetsPath + "/" + movieName, null);
		}
	}

	private void StartPlay(string moviePath, string licenceUrl)
	{
		if (moviePath != string.Empty)
		{
			if (overlay.isExternalAndroidSurface)
			{
				Pvr_UnitySDKEyeOverlay.ExternalAndroidSurfaceObjectCreated externalAndroidSurfaceObjectCreated = delegate
				{
					UnityEngine.Debug.Log("[ExternalSurface]>>>>>>SurfaceObject created callback is Invoke().");
				};
				if (overlay.externalAndroidSurfaceObject == IntPtr.Zero)
				{
					UnityEngine.Debug.Log("[ExternalSurface]>>>>>>Register surfaceObject crreated callback");
					overlay.externalAndroidSurfaceObjectCreated = externalAndroidSurfaceObjectCreated;
				}
				else
				{
					UnityEngine.Debug.Log("[ExternalSurface]>>>>>>SurfaceObject is already created! Invoke callback");
					externalAndroidSurfaceObjectCreated();
				}
			}
		}
		else
		{
			UnityEngine.Debug.LogError("[ExternalSurface]>>>>>>Movie path is null!");
		}
	}
}
public class MoveCylinder : MonoBehaviour
{
	private Vector3 startingPosition;

	private Quaternion startingRotation;

	private void Start()
	{
		startingPosition = base.transform.localPosition;
		startingRotation = base.transform.rotation;
	}

	public void Reset()
	{
		base.transform.localPosition = startingPosition;
		base.transform.rotation = startingRotation;
	}
}
[RequireComponent(typeof(Collider))]
public class MoveSphere : MonoBehaviour
{
	private Vector3 startingPosition;

	private void Start()
	{
		startingPosition = base.transform.localPosition;
		SetGazedAt(gazedAt: false);
		base.gameObject.GetComponent<Rigidbody>().AddForce(Vector3.right * 120f);
	}

	private void OnTriggerEnter(Collider other)
	{
	}

	public void SetGazedAt(bool gazedAt)
	{
		GetComponent<Renderer>().material.color = (gazedAt ? UnityEngine.Color.yellow : UnityEngine.Color.blue);
	}

	public void Reset()
	{
		base.transform.localPosition = startingPosition;
		SetGazedAt(gazedAt: false);
		base.gameObject.GetComponent<Rigidbody>().Sleep();
		base.gameObject.GetComponent<Rigidbody>().AddForce(Vector3.right * 120f);
	}

	public void TeleportRandomly()
	{
		Vector3 onUnitSphere = UnityEngine.Random.onUnitSphere;
		onUnitSphere.y = Mathf.Clamp(onUnitSphere.y, 0.5f, 1f);
		float num = 2f * UnityEngine.Random.value + 1.5f;
		base.transform.localPosition = onUnitSphere * num;
	}
}
public class Resetbutton : MonoBehaviour
{
	public void DemoResetTracking()
	{
		if (Pvr_UnitySDKSensor.Instance != null)
		{
			Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
		}
	}
}
public class UserEntitlementCheck : MonoBehaviour
{
	private void OnEnable()
	{
		Pvr_UnitySDKManager.EntitlementCheckResultEvent += HandelEntitlementCheckResult;
	}

	private void OnDisable()
	{
		Pvr_UnitySDKManager.EntitlementCheckResultEvent -= HandelEntitlementCheckResult;
	}

	private void HandelEntitlementCheckResult(int resultCode)
	{
		UnityEngine.Debug.Log("The User Entitlement Check Result is :" + resultCode);
		switch (resultCode)
		{
		case 0:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: success");
			break;
		case -1:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: invalid params");
			break;
		case -2:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: service not exist");
			break;
		case -3:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: bind failed");
			break;
		case -4:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: exception");
			break;
		case -5:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: timeout");
			break;
		case 10:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: missing package name");
			break;
		case 11:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: missing appid");
			break;
		case 13:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: appid and package name not match");
			break;
		case 20:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: not login");
			break;
		case 21:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: not pay");
			break;
		case 31:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: invalid sn");
			break;
		default:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: unknown");
			break;
		}
	}
}
public class Pvr_UnitySDKHeadTrack : MonoBehaviour
{
	[Tooltip("If true, head tracking will affect the rotation of each Pvr_UnitySDK's cameras.")]
	public bool trackRotation = true;

	[Tooltip("If true, head tracking will affect the position of each Pvr_UnitySDK's cameras.")]
	public bool trackPosition = true;

	public Transform target;

	private bool updated;

	private bool dataClock;

	public Ray Gaze
	{
		get
		{
			UpdateHead();
			return new Ray(base.transform.position, base.transform.forward);
		}
	}

	private void Update()
	{
		updated = false;
		UpdateHead();
	}

	private void UpdateHead()
	{
		if (updated)
		{
			return;
		}
		updated = true;
		if (Pvr_UnitySDKManager.SDK == null)
		{
			return;
		}
		if (trackRotation)
		{
			Quaternion orientation = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation;
			if (target == null)
			{
				base.transform.localRotation = orientation;
			}
			else
			{
				base.transform.rotation = orientation * target.rotation;
			}
		}
		else
		{
			Quaternion orientation2 = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation;
			if (target == null)
			{
				base.transform.localRotation = Quaternion.identity;
			}
			else
			{
				base.transform.rotation = orientation2 * target.rotation;
			}
		}
		if (trackPosition)
		{
			Vector3 position = Pvr_UnitySDKSensor.Instance.HeadPose.Position;
			if (target == null)
			{
				base.transform.localPosition = position;
			}
			else
			{
				base.transform.position = target.position + target.rotation * position;
			}
		}
	}
}
public class Pvr_UnitySDKPose
{
	protected static readonly Matrix4x4 flipZ = Matrix4x4.Scale(new Vector3(1f, 1f, -1f));

	public Matrix4x4 RightHandedMatrix => flipZ * Matrix * flipZ;

	public Vector3 Position { get; protected set; }

	public Quaternion Orientation { get; protected set; }

	public Matrix4x4 Matrix { get; protected set; }

	public Pvr_UnitySDKPose(Matrix4x4 matrix)
	{
		Set(matrix);
	}

	public Pvr_UnitySDKPose(Vector3 position, Quaternion orientation)
	{
		Set(position, orientation);
	}

	public void Set(Vector3 position, Quaternion orientation)
	{
		Position = position;
		Orientation = orientation;
		Matrix = Matrix4x4.TRS(position, orientation, Vector3.one);
	}

	protected void Set(Matrix4x4 matrix)
	{
		Matrix = matrix;
		Position = matrix.GetColumn(3);
		Orientation = Quaternion.LookRotation(matrix.GetColumn(2), matrix.GetColumn(1));
	}

	private Quaternion NormalizeQuaternion(ref Quaternion q)
	{
		float num = 0f;
		for (int i = 0; i < 4; i++)
		{
			num += q[i] * q[i];
		}
		float num2 = 1f / Mathf.Sqrt(num);
		for (int j = 0; j < 4; j++)
		{
			q[j] *= num2;
		}
		return q;
	}
}
public class Pvr_UnitySDKSensor
{
	public delegate void Enter3DofModel();

	public delegate void Exit3DofModel();

	private static Pvr_UnitySDKSensor instance;

	private bool SensorStart;

	private bool SensorInit;

	private Quaternion UnityQuaternion = Quaternion.identity;

	private Vector3 UnityPosition = Vector3.zero;

	private Sensorindex sensorIndex;

	private bool dofClock;

	public static Action EyeFovChanged;

	public Pvr_UnitySDKPose HeadPose;

	private float vfov = 102f;

	private float hfov = 102f;

	private float w;

	private float x;

	private float y;

	private float z;

	private float px;

	private float py;

	private float pz;

	public static Pvr_UnitySDKSensor Instance
	{
		get
		{
			if (instance == null)
			{
				instance = new Pvr_UnitySDKSensor();
			}
			return instance;
		}
		set
		{
			instance = value;
		}
	}

	public static event Enter3DofModel Enter3DofModelEvent;

	public static event Exit3DofModel Exit3DofModelEvent;

	public Pvr_UnitySDKSensor()
	{
		Init();
	}

	public void Init()
	{
		InitUnitySDK6DofSensor();
		SensorInit = InitUnitySDKSensor();
		SensorStart = StartUnitySDKSensor();
		HeadPose = new Pvr_UnitySDKPose(Vector3.zero, Quaternion.identity);
	}

	public void SensorUpdate()
	{
		if (GetUnitySDKSensorState())
		{
			HeadPose.Set(UnityPosition, UnityQuaternion);
		}
	}

	public bool InitUnitySDKSensor()
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_Init((int)sensorIndex) == 0)
			{
				result = true;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("InitUnitySDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool InitUnitySDK6DofSensor()
	{
		bool result = false;
		try
		{
			int res = 0;
			Render.UPvr_GetIntConfig(3, ref res);
			if (res == 1)
			{
				if (Sensor.UPvr_Enable6DofModule(!Pvr_UnitySDKManager.SDK.HmdOnlyrot) == 0 && !Pvr_UnitySDKManager.SDK.HmdOnlyrot)
				{
					result = true;
					Pvr_UnitySDKManager.SDK.PVRNeck = false;
				}
			}
			else
			{
				UnityEngine.Debug.LogWarning("This platform does not support 6 Dof !");
			}
		}
		catch (Exception ex)
		{
			PLOG.E("InitUnity6DofSDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool StartUnitySDKSensor()
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_StartSensor((int)sensorIndex) == 0)
			{
				result = true;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("StartUnitySDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool StopUnitySDKSensor()
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_StopSensor((int)sensorIndex) == 0)
			{
				result = true;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("StopUnitySDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool ResetUnitySDKSensor()
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_ResetSensor((int)sensorIndex) == 0)
			{
				result = true;
				PLOG.E("ResetUnitySDKSensor OK! ");
			}
		}
		catch (Exception ex)
		{
			PLOG.E("ResetUnitySDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool OptionalResetUnitySDKSensor(int resetRot, int resetPos)
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_OptionalResetSensor((int)sensorIndex, resetRot, resetPos) == 0)
			{
				result = true;
				UnityEngine.Debug.Log("PvrLog OptionalResetUnitySDKSensor OK!" + resetRot + resetPos);
			}
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogError("OptionalResetUnitySDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool GetUnitySDKSensorState()
	{
		bool result = false;
		if (SensorInit && SensorStart)
		{
			try
			{
				int num = -1;
				if (Pvr_UnitySDKManager.SDK.ShowVideoSeethrough)
				{
					Pvr_BoundarySystem.Instance.CameraFramePtr = Pvr_BoundaryAPI.UPvr_GetCameraData_Ext();
					num = Pvr_BoundaryAPI.UPvr_GetMainSensorStateExt(ref x, ref y, ref z, ref w, ref px, ref py, ref pz, ref vfov, ref hfov, ref Pvr_UnitySDKRender.Instance.RenderviewNumber);
				}
				else
				{
					num = Sensor.UPvr_GetMainSensorState(ref x, ref y, ref z, ref w, ref px, ref py, ref pz, ref vfov, ref hfov, ref Pvr_UnitySDKRender.Instance.RenderviewNumber);
				}
				Pvr_UnitySDKManager.SDK.posStatus = Sensor.UPvr_Get6DofSensorQualityStatus();
				if (num == 0)
				{
					if (!Convert.ToBoolean(Pvr_UnitySDKManager.SDK.posStatus & 2))
					{
						if (!dofClock)
						{
							if (Pvr_UnitySDKSensor.Enter3DofModelEvent != null)
							{
								Pvr_UnitySDKSensor.Enter3DofModelEvent();
							}
							dofClock = true;
						}
					}
					else if (dofClock)
					{
						if (Pvr_UnitySDKSensor.Exit3DofModelEvent != null)
						{
							Pvr_UnitySDKSensor.Exit3DofModelEvent();
						}
						dofClock = false;
					}
					RefreshHeadData(x, y, z, w, px, py, pz);
					UnityQuaternion.Set(x, y, 0f - z, 0f - w);
					if (Pvr_UnitySDKRender.Instance.EyeVFoV != vfov)
					{
						Pvr_UnitySDKRender.Instance.EyeVFoV = vfov;
						if (EyeFovChanged != null)
						{
							EyeFovChanged();
						}
					}
					Pvr_UnitySDKRender.Instance.EyeHFoV = hfov;
					Pvr_UnitySDKManager.SDK.EyesAspect = hfov / vfov;
					result = true;
					if (Pvr_UnitySDKManager.SDK.HmdOnlyrot)
					{
						if (Pvr_UnitySDKManager.SDK.PVRNeck)
						{
							if (Pvr_UnitySDKManager.SDK.TrackingOrigin == TrackingOrigin.FloorLevel)
							{
								UnityPosition.Set(0f, py, 0f);
								UnityPosition += UnityQuaternion * Pvr_UnitySDKManager.SDK.neckOffset - Pvr_UnitySDKManager.SDK.neckOffset.y * Vector3.up;
							}
							else
							{
								UnityPosition = UnityQuaternion * Pvr_UnitySDKManager.SDK.neckOffset - Pvr_UnitySDKManager.SDK.neckOffset.y * Vector3.up;
							}
						}
					}
					else
					{
						UnityPosition.Set(px, py, 0f - pz);
					}
					if (PLOG.logLevel > 2)
					{
						PLOG.D("posStatus=" + Pvr_UnitySDKManager.SDK.posStatus);
						PLOG.D("PvrLog 6DoFHeadRotation:" + x + "," + y + "," + (0f - z) + "," + (0f - w) + ",Position:" + px + "," + py + "," + (0f - pz) + ",eulerAngles:" + UnityQuaternion.eulerAngles);
					}
				}
				if (num == -1)
				{
					PLOG.I("PvrLog Sensor update --- GetUnitySDKSensorState  -1 ");
				}
			}
			catch (Exception ex)
			{
				PLOG.E("GetUnitySDKSensorState ERROR! " + ex.Message);
				throw;
			}
		}
		return result;
	}

	public bool GetUnitySDKPSensorState()
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_ResetSensor((int)sensorIndex) == 0)
			{
				result = true;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("GetUnitySDKPSensorState ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	private void RefreshHeadData(float x, float y, float z, float w, float px, float py, float pz)
	{
		Pvr_UnitySDKManager.SDK.headData[0] = x;
		Pvr_UnitySDKManager.SDK.headData[1] = y;
		Pvr_UnitySDKManager.SDK.headData[2] = z;
		Pvr_UnitySDKManager.SDK.headData[3] = w;
		Pvr_UnitySDKManager.SDK.headData[4] = px;
		Pvr_UnitySDKManager.SDK.headData[5] = py;
		Pvr_UnitySDKManager.SDK.headData[6] = pz;
	}
}
public class CLoadingAsset : ScriptableObject
{
	public int SplashScreenType;

	public List<Texture2D> splashImage = new List<Texture2D>();

	public Texture2D Inside_background;

	public bool UseSplashText;

	public string DefaultText;

	public string ChineseText;

	public string EnglishText;

	public string JapaneseText;

	public string KoreanText;

	public string FontSize;

	public UnityEngine.Color FontColor;

	public string TextHeight;

	public bool UseCarousel;

	public int SplashTextAlignment;
}
[Serializable]
public class Pvr_UnitySDKConfigProfile
{
	public struct Lenses
	{
		public float separation;

		public float offset;

		public float distance;

		public int alignment;

		public const int AlignTop = -1;

		public const int AlignCenter = 0;

		public const int AlignBottom = 1;
	}

	public struct MaxFOV
	{
		public float upper;

		public float lower;

		public float inner;

		public float outer;
	}

	public struct Distortion
	{
		public float k1;

		public float k2;

		public float k3;

		public float k4;

		public float k5;

		public float k6;

		public float distort(float r)
		{
			return 0f;
		}

		public float distort(float r, float dist)
		{
			float num = r * dist * 1000f;
			return (k1 * Mathf.Pow(num, 5f) + k2 * Mathf.Pow(num, 4f) + k3 * Mathf.Pow(num, 3f) + k4 * Mathf.Pow(num, 2f) + k5 * num + k6) / 1000f / dist;
		}

		public float diatortInv(float radious)
		{
			return 0f;
		}
	}

	public struct Device
	{
		public Lenses devLenses;

		public MaxFOV devMaxFov;

		public Distortion devDistortion;

		public Distortion devDistortionInv;
	}

	public static readonly Device SimulateDevice = new Device
	{
		devLenses = 
		{
			separation = 0.062f,
			offset = 0f,
			distance = 0.0403196f,
			alignment = 0
		},
		devMaxFov = 
		{
			upper = 40f,
			lower = 40f,
			inner = 40f,
			outer = 40f
		},
		devDistortion = 
		{
			k1 = 2.333E-06f,
			k2 = -0.000126f,
			k3 = 0.002978f,
			k4 = -0.02615f,
			k5 = 1.089f,
			k6 = -0.0337f
		},
		devDistortionInv = 
		{
			k1 = 1.342E-08f,
			k2 = 1.665E-06f,
			k3 = -0.0002797f,
			k4 = 0.001166f,
			k5 = 0.9945f,
			k6 = 0.004805f
		}
	};

	public Device device;

	public static readonly Pvr_UnitySDKConfigProfile Default = new Pvr_UnitySDKConfigProfile
	{
		device = SimulateDevice
	};

	public Pvr_UnitySDKConfigProfile Clone()
	{
		return new Pvr_UnitySDKConfigProfile
		{
			device = device
		};
	}

	public static Pvr_UnitySDKConfigProfile GetPicoProfile()
	{
		return new Pvr_UnitySDKConfigProfile
		{
			device = SimulateDevice
		};
	}

	public float[] GetLeftEyeVisibleTanAngles(float width, float height)
	{
		float val = (float)Math.Tan((double)(0f - device.devMaxFov.outer) * Math.PI / 180.0);
		float val2 = (float)Math.Tan((double)device.devMaxFov.upper * Math.PI / 180.0);
		float val3 = (float)Math.Tan((double)device.devMaxFov.inner * Math.PI / 180.0);
		float val4 = (float)Math.Tan((double)(0f - device.devMaxFov.lower) * Math.PI / 180.0);
		float num = width / 4f;
		float num2 = height / 2f;
		float num3 = device.devLenses.separation / 2f - num;
		float num4 = 0f;
		float distance = device.devLenses.distance;
		float val5 = device.devDistortion.distort((num3 - num) / distance, device.devLenses.distance);
		float val6 = device.devDistortion.distort((num4 + num2) / distance, device.devLenses.distance);
		float val7 = device.devDistortion.distort((num3 + num) / distance, device.devLenses.distance);
		float val8 = device.devDistortion.distort((num4 - num) / distance, device.devLenses.distance);
		float num5 = Math.Max(val, val5);
		float num6 = Math.Min(val2, val6);
		float num7 = Math.Min(val3, val7);
		float num8 = Math.Max(val4, val8);
		return new float[4] { num5, num6, num7, num8 };
	}

	public float[] GetLeftEyeNoLensTanAngles(float width, float height)
	{
		float val = device.devDistortionInv.distort((float)Math.Tan((double)(0f - device.devMaxFov.outer) * Math.PI / 180.0), device.devLenses.distance);
		float val2 = device.devDistortionInv.distort((float)Math.Tan((double)device.devMaxFov.upper * Math.PI / 180.0), device.devLenses.distance);
		float val3 = device.devDistortionInv.distort((float)Math.Tan((double)device.devMaxFov.inner * Math.PI / 180.0), device.devLenses.distance);
		float val4 = device.devDistortionInv.distort((float)Math.Tan((double)(0f - device.devMaxFov.lower) * Math.PI / 180.0), device.devLenses.distance);
		float num = width / 4f;
		float num2 = height / 2f;
		float num3 = device.devLenses.separation / 2f - num;
		float num4 = 0f;
		float distance = device.devLenses.distance;
		float val5 = (num3 - num) / distance;
		float val6 = (num4 + num2) / distance;
		float val7 = (num3 + num) / distance;
		float val8 = (num4 - num) / distance;
		float num5 = Math.Min(val, val5);
		float num6 = Math.Min(val2, val6);
		float num7 = Math.Min(val3, val7);
		float num8 = Math.Max(val4, val8);
		return new float[4] { num5, num6, num7, num8 };
	}

	public Rect GetLeftEyeVisibleScreenRect(float[] undistortedFrustum, float width, float height)
	{
		float distance = device.devLenses.distance;
		float num = (width - device.devLenses.separation) / 2f;
		float num2 = height / 2f;
		float num3 = (undistortedFrustum[0] * distance + num) / width;
		float num4 = (undistortedFrustum[1] * distance + num2) / height;
		float num5 = (undistortedFrustum[2] * distance + num) / width;
		float num6 = (undistortedFrustum[3] * distance + num2) / height;
		return new Rect(num3, num6, num5 - num3, num4 - num6);
	}
}
[RequireComponent(typeof(Text))]
public class Pvr_UnitySDKFPS : MonoBehaviour
{
	public Text fpsText;

	private float updateInterval = 0.5f;

	private float accum;

	private int frames;

	private float timeLeft;

	private string strFps;

	private void Update()
	{
		if (fpsText != null)
		{
			ShowFps();
		}
	}

	private void ShowFps()
	{
		timeLeft -= Time.unscaledDeltaTime;
		accum += Time.unscaledDeltaTime;
		frames++;
		if ((double)timeLeft <= 0.0)
		{
			float num = (float)frames / accum;
			strFps = $"FPS: {num:f0}";
			fpsText.text = strFps;
			timeLeft += updateInterval;
			accum = 0f;
			frames = 0;
		}
	}
}
public class Pvr_GazeFuse : MonoBehaviour
{
	public GameObject gazeGameObject;

	private UnityEngine.UI.Image image;

	private void Start()
	{
		image = GetComponent<UnityEngine.UI.Image>();
	}

	private void Update()
	{
		if (gazeGameObject == null || Pvr_GazeInputModule.gazeGameObject == gazeGameObject)
		{
			FuseAmountChanged(Pvr_GazeInputModule.gazeFraction);
		}
	}

	private void FuseAmountChanged(float fuseAmount)
	{
		if (image != null)
		{
			image.fillAmount = fuseAmount;
		}
	}
}
public class Pvr_GazeInputModule : PointerInputModule
{
	public enum Mode
	{
		Click,
		Gaze
	}

	public Mode mode;

	[Header("Click Settings")]
	public string ClickInputName = "Submit";

	[Header("Gaze Settings")]
	public float GazeTimeInSeconds = 2f;

	public RaycastResult CurrentRaycast;

	private PointerEventData pointerEventData;

	private GameObject currentLookAtHandler;

	private float currentLookAtHandlerClickTime;

	public static float gazeFraction { get; private set; }

	public static GameObject gazeGameObject { get; private set; }

	public override void Process()
	{
		HandleLook();
		HandleSelection();
	}

	private void HandleLook()
	{
		if (pointerEventData == null)
		{
			pointerEventData = new PointerEventData(base.eventSystem);
		}
		pointerEventData.position = new Vector2(Screen.width / 2, Screen.height / 2);
		pointerEventData.delta = Vector2.zero;
		List<RaycastResult> list = new List<RaycastResult>();
		base.eventSystem.RaycastAll(pointerEventData, list);
		RaycastResult currentRaycast = (pointerEventData.pointerCurrentRaycast = BaseInputModule.FindFirstRaycast(list));
		CurrentRaycast = currentRaycast;
		ProcessMove(pointerEventData);
	}

	private void HandleSelection()
	{
		gazeFraction = 0f;
		if (pointerEventData.pointerEnter != null)
		{
			GameObject eventHandler = ExecuteEvents.GetEventHandler<IPointerClickHandler>(pointerEventData.pointerEnter);
			if (currentLookAtHandler != eventHandler)
			{
				gazeGameObject = (currentLookAtHandler = eventHandler);
				currentLookAtHandlerClickTime = Time.realtimeSinceStartup + GazeTimeInSeconds;
			}
			if (mode == Mode.Gaze && currentLookAtHandler != null)
			{
				gazeFraction = Mathf.Clamp01(1f - (currentLookAtHandlerClickTime - Time.realtimeSinceStartup) / GazeTimeInSeconds);
			}
			if ((currentLookAtHandler != null && mode == Mode.Gaze && Time.realtimeSinceStartup > currentLookAtHandlerClickTime) || (mode == Mode.Click && Input.GetButtonDown(ClickInputName)))
			{
				_ = EventSystem.current.currentSelectedGameObject != null;
				EventSystem.current.SetSelectedGameObject(currentLookAtHandler);
				gazeFraction = 0f;
				ExecuteEvents.ExecuteHierarchy(currentLookAtHandler, pointerEventData, ExecuteEvents.pointerClickHandler);
				currentLookAtHandlerClickTime = float.MaxValue;
				ExecuteEvents.ExecuteHierarchy(EventSystem.current.currentSelectedGameObject, pointerEventData, ExecuteEvents.deselectHandler);
			}
		}
		else
		{
			gazeGameObject = (currentLookAtHandler = null);
		}
	}
}
[RequireComponent(typeof(Pvr_GazeInputModule))]
public class Pvr_GazeInputModuleCrosshair : MonoBehaviour
{
	public static bool DisplayCrosshair = true;

	[Tooltip("Crosshair GameObject attached to your VR Camera")]
	public Transform Crosshair;

	private Pvr_GazeInputModule gazeInputModule;

	private Vector3 CrosshairOriginalScale;

	private float CrosshairOriginalDistance;

	private void Awake()
	{
		gazeInputModule = GetComponent<Pvr_GazeInputModule>();
	}

	private void Start()
	{
		CrosshairOriginalScale = Crosshair.localScale;
		CrosshairOriginalDistance = Crosshair.localPosition.z;
		Crosshair.gameObject.SetActive(value: false);
	}

	private void Update()
	{
		Crosshair.gameObject.SetActive(DisplayCrosshair);
		if (DisplayCrosshair)
		{
			float crossHairAtDistance = CrosshairOriginalDistance;
			if (gazeInputModule.CurrentRaycast.isValid)
			{
				crossHairAtDistance = gazeInputModule.CurrentRaycast.distance * 0.8f - 0.5f;
			}
			SetCrossHairAtDistance(crossHairAtDistance);
		}
	}

	private void SetCrossHairAtDistance(float dist)
	{
		Vector3 localPosition = Crosshair.localPosition;
		Crosshair.localPosition = new Vector3(localPosition.x, localPosition.y, dist);
		Crosshair.localScale = CrosshairOriginalScale * dist;
	}
}
public enum RenderEventType
{
	InitRenderThread = 1024,
	Pause,
	Resume,
	LeftEyeEndFrame,
	RightEyeEndFrame,
	TimeWarp,
	ResetVrModeParms,
	ShutdownRenderThread,
	BeginEye,
	EndEye,
	BoundaryRenderLeft,
	BoundaryRenderRight,
	BothEyeEndFrame,
	CameraFrameLeft,
	CameraFrameRight,
	StartCameraFrame,
	StopCameraFrame
}
public static class Pvr_UnitySDKPluginEvent
{
	private delegate void RenderEventDelegate(int eventId);

	private const uint IS_DATA_FLAG = 2147483648u;

	private const uint DATA_POS_MASK = 1073741824u;

	private const int DATA_POS_SHIFT = 30;

	private const uint EVENT_TYPE_MASK = 1056899072u;

	private const int EVENT_TYPE_SHIFT = 17;

	private const uint PAYLOAD_MASK = 65535u;

	private const int PAYLOAD_SHIFT = 16;

	private static RenderEventDelegate SetSinglePassBeforeForwardOpaqueHandle = SetSinglePassBeforeForwardOpaque;

	private static IntPtr SetSinglePassBeforeForwardOpaquePtr = Marshal.GetFunctionPointerForDelegate(SetSinglePassBeforeForwardOpaqueHandle);

	public static void Issue(RenderEventType eventType)
	{
		GL.IssuePluginEvent(Pvr_UnitySDKAPI.System.GetRenderEventFunc(), (int)eventType);
	}

	private static int EncodeType(int eventType)
	{
		return eventType & 0x7FFFFFFF;
	}

	private static int EncodeData(int eventId, int eventData, int pos)
	{
		return int.MinValue | ((pos << 30) & 0x40000000) | ((eventId << 17) & 0x3EFF0000) | ((eventData >>> pos * 16) & 0xFFFF);
	}

	private static int DecodeData(int eventData)
	{
		uint num = (uint)(eventData & 0x40000000) >> 30;
		return (eventData & 0xFFFF) << (int)(16 * num);
	}

	[MonoPInvokeCallback(typeof(RenderEventDelegate))]
	private static void SetSinglePassBeforeForwardOpaque(int eventId)
	{
		Pvr_UnitySDKAPI.System.UPvr_SinglePassBeforeForwardOpaque();
	}

	public static void SetSinglePassBeforeForwardOpaque(CommandBuffer cmd)
	{
		cmd.IssuePluginEvent(SetSinglePassBeforeForwardOpaquePtr, 0);
	}
}
public class Pvr_UnitySDKSightInputModule : BaseInputModule
{
	[Tooltip("Optional object to place at raycast intersections as a 3D cursor. Be sure it is on a layer that raycasts will ignore.")]
	public GameObject cursor;

	public int trigger;

	[HideInInspector]
	public float clickTime = 0.1f;

	[HideInInspector]
	public Vector2 hotspot = new Vector2(0.5f, 0.5f);

	private PointerEventData pointerData;

	public override bool ShouldActivateModule()
	{
		if (!base.ShouldActivateModule())
		{
			return false;
		}
		return Pvr_UnitySDKManager.SDK.VRModeEnabled;
	}

	public override void DeactivateModule()
	{
		base.DeactivateModule();
		if (pointerData != null)
		{
			HandlePendingClick();
			HandlePointerExitAndEnter(pointerData, null);
			pointerData = null;
		}
		base.eventSystem.SetSelectedGameObject(null, GetBaseEventData());
		if (cursor != null)
		{
			cursor.SetActive(value: false);
		}
	}

	public override bool IsPointerOverGameObject(int pointerId)
	{
		if (pointerData != null)
		{
			return pointerData.pointerEnter != null;
		}
		return false;
	}

	public override void Process()
	{
		CastRayFromGaze();
		UpdateCurrentObject();
		PlaceCursor();
		HandlePendingClick();
		HandleTrigger();
	}

	private void CastRayFromGaze()
	{
		if (pointerData == null)
		{
			pointerData = new PointerEventData(base.eventSystem);
		}
		pointerData.Reset();
		pointerData.position = new Vector2(hotspot.x * (float)Screen.width, hotspot.y * (float)Screen.height);
		base.eventSystem.RaycastAll(pointerData, m_RaycastResultCache);
		pointerData.pointerCurrentRaycast = BaseInputModule.FindFirstRaycast(m_RaycastResultCache);
		m_RaycastResultCache.Clear();
	}

	private void UpdateCurrentObject()
	{
		GameObject gameObject = pointerData.pointerCurrentRaycast.gameObject;
		HandlePointerExitAndEnter(pointerData, gameObject);
		if (ExecuteEvents.GetEventHandler<ISelectHandler>(gameObject) == base.eventSystem.currentSelectedGameObject)
		{
			ExecuteEvents.Execute(base.eventSystem.currentSelectedGameObject, GetBaseEventData(), ExecuteEvents.updateSelectedHandler);
		}
		else
		{
			base.eventSystem.SetSelectedGameObject(null, pointerData);
		}
	}

	private void PlaceCursor()
	{
		if (!(cursor == null))
		{
			GameObject gameObject = pointerData.pointerCurrentRaycast.gameObject;
			cursor.SetActive(gameObject != null);
			if (cursor.activeInHierarchy)
			{
				Camera enterEventCamera = pointerData.enterEventCamera;
				float num = pointerData.pointerCurrentRaycast.distance + enterEventCamera.nearClipPlane - 0.1f;
				cursor.transform.position = enterEventCamera.transform.position + enterEventCamera.transform.forward * num;
			}
		}
	}

	private void HandlePendingClick()
	{
		if (pointerData.eligibleForClick && (Pvr_UnitySDKManager.SDK.picovrTriggered || !(Time.unscaledTime - pointerData.clickTime < clickTime)))
		{
			ExecuteEvents.Execute(pointerData.pointerPress, pointerData, ExecuteEvents.pointerUpHandler);
			ExecuteEvents.Execute(pointerData.pointerPress, pointerData, ExecuteEvents.pointerClickHandler);
			pointerData.pointerPress = null;
			pointerData.rawPointerPress = null;
			pointerData.eligibleForClick = false;
			pointerData.clickCount = 0;
		}
	}

	private void HandleTrigger()
	{
		if (Pvr_UnitySDKManager.SDK.picovrTriggered)
		{
			GameObject gameObject = pointerData.pointerCurrentRaycast.gameObject;
			if (!(gameObject == null) && !(ExecuteEvents.GetEventHandler<IPointerClickHandler>(gameObject) == null))
			{
				pointerData.pointerPress = ExecuteEvents.GetEventHandler<IPointerClickHandler>(gameObject);
				pointerData.pressPosition = pointerData.position;
				pointerData.pointerPressRaycast = pointerData.pointerCurrentRaycast;
				pointerData.pointerPress = ExecuteEvents.ExecuteHierarchy(gameObject, pointerData, ExecuteEvents.pointerDownHandler) ?? ExecuteEvents.GetEventHandler<IPointerClickHandler>(gameObject);
				pointerData.rawPointerPress = gameObject;
				pointerData.eligibleForClick = true;
				pointerData.clickCount = 1;
				pointerData.clickTime = Time.unscaledTime;
			}
		}
	}
}
public class Pvr_ObjImporter
{
	private static Pvr_ObjImporter _instance;

	private List<int> triangles;

	private List<Vector3> vertices;

	private List<Vector2> uv;

	private List<Vector3> normals;

	private List<PvrVector3Int> faceData;

	private List<int> intArray;

	private const int MIN_POW_10 = -16;

	private const int MAX_POW_10 = 16;

	private const int NUM_POWS_10 = 33;

	private static readonly float[] pow10 = GenerateLookupTable();

	public static Pvr_ObjImporter Instance => _instance ?? (_instance = new Pvr_ObjImporter());

	public Mesh ImportFile(string filePath)
	{
		triangles = new List<int>();
		vertices = new List<Vector3>();
		uv = new List<Vector2>();
		normals = new List<Vector3>();
		faceData = new List<PvrVector3Int>();
		intArray = new List<int>();
		LoadMeshData(filePath);
		Vector3[] array = new Vector3[faceData.Count];
		Vector2[] array2 = new Vector2[faceData.Count];
		Vector3[] array3 = new Vector3[faceData.Count];
		for (int i = 0; i < faceData.Count; i++)
		{
			array[i] = vertices[faceData[i].x - 1];
			if (faceData[i].y >= 1)
			{
				array2[i] = uv[faceData[i].y - 1];
			}
			if (faceData[i].z >= 1)
			{
				array3[i] = normals[faceData[i].z - 1];
			}
		}
		Mesh mesh = new Mesh();
		mesh.vertices = array;
		mesh.uv = array2;
		mesh.normals = array3;
		mesh.triangles = triangles.ToArray();
		mesh.RecalculateBounds();
		return mesh;
	}

	private void LoadMeshData(string fileName)
	{
		StringBuilder stringBuilder = new StringBuilder();
		string text = File.ReadAllText(fileName);
		int num = 0;
		string text2 = null;
		int num2 = 0;
		StringBuilder sbInt = new StringBuilder();
		for (int i = 0; i < text.Length; i++)
		{
			if (text[i] != '\n')
			{
				continue;
			}
			stringBuilder.Remove(0, stringBuilder.Length);
			stringBuilder.Append(text, num + 1, i - num);
			num = i;
			if (stringBuilder[0] == 'o' && stringBuilder[1] == ' ')
			{
				sbInt.Remove(0, sbInt.Length);
				for (int j = 2; j < stringBuilder.Length; j++)
				{
					text2 += stringBuilder[j];
				}
			}
			else if (stringBuilder[0] == 'v' && stringBuilder[1] == ' ')
			{
				int start = 2;
				vertices.Add(new Vector3(GetFloat(stringBuilder, ref start, ref sbInt), GetFloat(stringBuilder, ref start, ref sbInt), GetFloat(stringBuilder, ref start, ref sbInt)));
			}
			else if (stringBuilder[0] == 'v' && stringBuilder[1] == 't' && stringBuilder[2] == ' ')
			{
				int start2 = 3;
				uv.Add(new Vector2(GetFloat(stringBuilder, ref start2, ref sbInt), GetFloat(stringBuilder, ref start2, ref sbInt)));
			}
			else if (stringBuilder[0] == 'v' && stringBuilder[1] == 'n' && stringBuilder[2] == ' ')
			{
				int start3 = 3;
				normals.Add(new Vector3(GetFloat(stringBuilder, ref start3, ref sbInt), GetFloat(stringBuilder, ref start3, ref sbInt), GetFloat(stringBuilder, ref start3, ref sbInt)));
			}
			else if (stringBuilder[0] == 'f' && stringBuilder[1] == ' ')
			{
				int start4 = 2;
				int num3 = 1;
				intArray.Clear();
				int num4 = 0;
				while (start4 < stringBuilder.Length && char.IsDigit(stringBuilder[start4]))
				{
					faceData.Add(new PvrVector3Int(GetInt(stringBuilder, ref start4, ref sbInt), GetInt(stringBuilder, ref start4, ref sbInt), GetInt(stringBuilder, ref start4, ref sbInt)));
					num3++;
					intArray.Add(num2);
					num2++;
				}
				num4 += num3;
				for (num3 = 1; num3 + 2 < num4; num3++)
				{
					triangles.Add(intArray[0]);
					triangles.Add(intArray[num3]);
					triangles.Add(intArray[num3 + 1]);
				}
			}
		}
	}

	private float GetFloat(StringBuilder sb, ref int start, ref StringBuilder sbFloat)
	{
		sbFloat.Remove(0, sbFloat.Length);
		while (start < sb.Length && (char.IsDigit(sb[start]) || sb[start] == '-' || sb[start] == '.'))
		{
			sbFloat.Append(sb[start]);
			start++;
		}
		start++;
		return ParseFloat(sbFloat);
	}

	private int GetInt(StringBuilder sb, ref int start, ref StringBuilder sbInt)
	{
		sbInt.Remove(0, sbInt.Length);
		while (start < sb.Length && char.IsDigit(sb[start]))
		{
			sbInt.Append(sb[start]);
			start++;
		}
		start++;
		return IntParseFast(sbInt);
	}

	private static float[] GenerateLookupTable()
	{
		float[] array = new float[320];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = (float)(i / 33) * Mathf.Pow(10f, i % 33 + -16);
		}
		return array;
	}

	private float ParseFloat(StringBuilder value)
	{
		float num = 0f;
		bool flag = false;
		int length = value.Length;
		int num2 = value.Length;
		for (int num3 = length - 1; num3 >= 0; num3--)
		{
			if (value[num3] == '.')
			{
				num2 = num3;
				break;
			}
		}
		int num4 = 16 + num2;
		for (int i = 0; i < num2; i++)
		{
			if (i != num2 && value[i] != '-')
			{
				num += pow10[(value[i] - 48) * 33 + num4 - i - 1];
			}
			else if (value[i] == '-')
			{
				flag = true;
			}
		}
		for (int j = num2 + 1; j < length; j++)
		{
			if (j != num2)
			{
				num += pow10[(value[j] - 48) * 33 + num4 - j];
			}
		}
		if (flag)
		{
			num = 0f - num;
		}
		return num;
	}

	private int IntParseFast(StringBuilder value)
	{
		int num = 0;
		for (int i = 0; i < value.Length; i++)
		{
			num = 10 * num + (value[i] - 48);
		}
		return num;
	}
}
public sealed class PvrVector3Int
{
	public int x { get; set; }

	public int y { get; set; }

	public int z { get; set; }

	public PvrVector3Int()
	{
	}

	public PvrVector3Int(int x, int y, int z)
	{
		this.x = x;
		this.y = y;
		this.z = z;
	}
}
public class Pvr_EnumFlags : PropertyAttribute
{
}
public enum ConfirmBtn
{
	App = 1,
	TouchPad = 2,
	Trigger = 4
}
public class Pvr_InputModule : PointerInputModule
{
	public static List<Pvr_UIPointer> pointers = new List<Pvr_UIPointer>();

	[Pvr_EnumFlags]
	public ConfirmBtn confirmBtn = ConfirmBtn.TouchPad;

	private List<RaycastResult> rayCasts = new List<RaycastResult>();

	private RaycastResult rayCastResult;

	public virtual void Initialise()
	{
		pointers.Clear();
	}

	public static void AddPoint(Pvr_UIPointer point)
	{
		if (!pointers.Contains(point))
		{
			pointers.Add(point);
		}
	}

	public static void RemovePoint(Pvr_UIPointer point)
	{
		if (pointers.Contains(point))
		{
			pointers.Remove(point);
		}
	}

	public override void Process()
	{
		if (Pvr_UnitySDKManager.SDK.isHasController)
		{
			if ((confirmBtn & ConfirmBtn.App) == ConfirmBtn.App)
			{
				Pvr_UIPointer.AppBtnValue = Controller.UPvr_GetKey(Pvr_ControllerManager.controllerlink.mainHandID, Pvr_KeyCode.APP);
			}
			if ((confirmBtn & ConfirmBtn.TouchPad) == ConfirmBtn.TouchPad)
			{
				Pvr_UIPointer.TouchBtnValue = Controller.UPvr_GetKey(Pvr_ControllerManager.controllerlink.mainHandID, Pvr_KeyCode.TOUCHPAD);
			}
			if ((confirmBtn & ConfirmBtn.Trigger) == ConfirmBtn.Trigger)
			{
				Pvr_UIPointer.TriggerBtnValue = Controller.UPvr_GetKey(Pvr_ControllerManager.controllerlink.mainHandID, Pvr_KeyCode.TRIGGER);
			}
		}
		for (int i = 0; i < pointers.Count; i++)
		{
			Pvr_UIPointer pvr_UIPointer = pointers[i];
			if (pvr_UIPointer.gameObject.activeInHierarchy && pvr_UIPointer.enabled)
			{
				List<RaycastResult> results = new List<RaycastResult>();
				if (pvr_UIPointer.PointerActive())
				{
					results = CheckRaycasts(pvr_UIPointer);
				}
				Hover(pvr_UIPointer, results);
				Click(pvr_UIPointer, results);
				Drag(pvr_UIPointer, results);
			}
		}
	}

	protected virtual List<RaycastResult> CheckRaycasts(Pvr_UIPointer pointer)
	{
		rayCastResult.worldPosition = pointer.GetOriginPosition();
		rayCastResult.worldNormal = pointer.GetOriginForward();
		pointer.pointerEventData.pointerCurrentRaycast = rayCastResult;
		base.eventSystem.RaycastAll(pointer.pointerEventData, rayCasts);
		return rayCasts;
	}

	protected virtual bool CheckTransformTree(Transform target, Transform source)
	{
		if (target == null)
		{
			return false;
		}
		if (target.Equals(source))
		{
			return true;
		}
		return CheckTransformTree(target.transform.parent, source);
	}

	protected virtual bool NoValidCollision(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		if (results.Count != 0)
		{
			return !CheckTransformTree(results[0].gameObject.transform, pointer.pointerEventData.pointerEnter.transform);
		}
		return true;
	}

	protected virtual bool IsHovering(Pvr_UIPointer pointer)
	{
		foreach (GameObject item in pointer.pointerEventData.hovered)
		{
			if ((bool)pointer.pointerEventData.pointerEnter && (bool)item && CheckTransformTree(item.transform, pointer.pointerEventData.pointerEnter.transform))
			{
				return true;
			}
		}
		return false;
	}

	protected virtual bool ValidElement(GameObject obj)
	{
		Pvr_UICanvas componentInParent = obj.GetComponentInParent<Pvr_UICanvas>();
		if (!componentInParent || !componentInParent.enabled)
		{
			return false;
		}
		return true;
	}

	protected virtual void CheckPointerHoverClick(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		if (pointer.hoverDurationTimer > 0f)
		{
			pointer.hoverDurationTimer -= Time.deltaTime;
		}
		if (pointer.canClickOnHover && pointer.hoverDurationTimer <= 0f)
		{
			pointer.canClickOnHover = false;
			ClickOnDown(pointer, results, forceClick: true);
		}
	}

	protected virtual void Hover(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		if ((bool)pointer.pointerEventData.pointerEnter)
		{
			CheckPointerHoverClick(pointer, results);
			if (!ValidElement(pointer.pointerEventData.pointerEnter))
			{
				pointer.pointerEventData.pointerEnter = null;
				return;
			}
			if (NoValidCollision(pointer, results))
			{
				ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerEnter, pointer.pointerEventData, ExecuteEvents.pointerExitHandler);
				pointer.pointerEventData.hovered.Remove(pointer.pointerEventData.pointerEnter);
				pointer.pointerEventData.pointerEnter = null;
			}
			if (results.Count <= 0 || !(pointer.pointerEventData.pointerEnter != results[0].gameObject))
			{
				return;
			}
			{
				foreach (RaycastResult result in results)
				{
					if (!ValidElement(result.gameObject))
					{
						continue;
					}
					GameObject gameObject = ExecuteEvents.ExecuteHierarchy(result.gameObject, pointer.pointerEventData, ExecuteEvents.pointerEnterHandler);
					if (gameObject != null)
					{
						Selectable component = gameObject.GetComponent<Selectable>();
						if ((bool)component)
						{
							Navigation navigation = default(Navigation);
							navigation.mode = Navigation.Mode.None;
							component.navigation = navigation;
						}
						pointer.pointerEventData.hovered.Remove(pointer.pointerEventData.pointerEnter);
						pointer.OnUIPointerElementEnter(pointer.SetUIPointerEvent(result, gameObject, pointer.hoveringElement));
						pointer.hoveringElement = gameObject;
						pointer.pointerEventData.pointerCurrentRaycast = result;
						pointer.pointerEventData.pointerEnter = gameObject;
						pointer.pointerEventData.hovered.Add(pointer.pointerEventData.pointerEnter);
						break;
					}
					if (result.gameObject != pointer.hoveringElement)
					{
						pointer.OnUIPointerElementEnter(pointer.SetUIPointerEvent(result, result.gameObject, pointer.hoveringElement));
					}
					pointer.hoveringElement = result.gameObject;
				}
				return;
			}
		}
		foreach (RaycastResult result2 in results)
		{
			if (!ValidElement(result2.gameObject))
			{
				continue;
			}
			GameObject gameObject2 = ExecuteEvents.ExecuteHierarchy(result2.gameObject, pointer.pointerEventData, ExecuteEvents.pointerEnterHandler);
			if (gameObject2 != null)
			{
				Selectable component2 = gameObject2.GetComponent<Selectable>();
				if ((bool)component2)
				{
					Navigation navigation2 = default(Navigation);
					navigation2.mode = Navigation.Mode.None;
					component2.navigation = navigation2;
				}
				pointer.OnUIPointerElementEnter(pointer.SetUIPointerEvent(result2, gameObject2, pointer.hoveringElement));
				pointer.hoveringElement = gameObject2;
				pointer.pointerEventData.pointerCurrentRaycast = result2;
				pointer.pointerEventData.pointerEnter = gameObject2;
				pointer.pointerEventData.hovered.Add(pointer.pointerEventData.pointerEnter);
				break;
			}
			if (result2.gameObject != pointer.hoveringElement)
			{
				pointer.OnUIPointerElementEnter(pointer.SetUIPointerEvent(result2, result2.gameObject, pointer.hoveringElement));
			}
			pointer.hoveringElement = result2.gameObject;
		}
		if ((bool)pointer.hoveringElement && results.Count == 0)
		{
			pointer.OnUIPointerElementExit(pointer.SetUIPointerEvent(default(RaycastResult), null, pointer.hoveringElement));
			pointer.hoveringElement = null;
		}
	}

	protected virtual void Click(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		switch (pointer.clickMethod)
		{
		case Pvr_UIPointer.ClickMethods.ClickOnButtonUp:
			ClickOnUp(pointer, results);
			break;
		case Pvr_UIPointer.ClickMethods.ClickOnButtonDown:
			ClickOnDown(pointer, results);
			break;
		}
	}

	protected virtual void ClickOnUp(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		pointer.pointerEventData.eligibleForClick = pointer.ValidClick(checkLastClick: false);
		if (!AttemptClick(pointer))
		{
			IsEligibleClick(pointer, results);
		}
	}

	protected virtual void ClickOnDown(Pvr_UIPointer pointer, List<RaycastResult> results, bool forceClick = false)
	{
		pointer.pointerEventData.eligibleForClick = forceClick || pointer.ValidClick(checkLastClick: true);
		if (IsEligibleClick(pointer, results))
		{
			pointer.pointerEventData.eligibleForClick = false;
			AttemptClick(pointer);
		}
	}

	protected virtual bool IsEligibleClick(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		if (pointer.pointerEventData.eligibleForClick)
		{
			foreach (RaycastResult result in results)
			{
				if (ValidElement(result.gameObject))
				{
					GameObject gameObject = ExecuteEvents.ExecuteHierarchy(result.gameObject, pointer.pointerEventData, ExecuteEvents.pointerDownHandler);
					if (gameObject != null)
					{
						pointer.pointerEventData.pressPosition = pointer.pointerEventData.position;
						pointer.pointerEventData.pointerPressRaycast = result;
						pointer.pointerEventData.pointerPress = gameObject;
						return true;
					}
				}
			}
		}
		return false;
	}

	protected virtual bool AttemptClick(Pvr_UIPointer pointer)
	{
		if ((bool)pointer.pointerEventData.pointerPress)
		{
			if (!ValidElement(pointer.pointerEventData.pointerPress))
			{
				pointer.pointerEventData.pointerPress = null;
				return true;
			}
			if (pointer.pointerEventData.eligibleForClick)
			{
				if (!IsHovering(pointer))
				{
					ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerPress, pointer.pointerEventData, ExecuteEvents.pointerUpHandler);
					pointer.pointerEventData.pointerPress = null;
				}
			}
			else
			{
				pointer.OnUIPointerElementClick(pointer.SetUIPointerEvent(pointer.pointerEventData.pointerPressRaycast, pointer.pointerEventData.pointerPress));
				ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerPress, pointer.pointerEventData, ExecuteEvents.pointerClickHandler);
				ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerPress, pointer.pointerEventData, ExecuteEvents.pointerUpHandler);
				pointer.pointerEventData.pointerPress = null;
			}
			return true;
		}
		return false;
	}

	protected virtual void Drag(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		pointer.pointerEventData.dragging = pointer.IsSelectionButtonPressed() && pointer.pointerEventData.delta != Vector2.zero;
		if ((bool)pointer.pointerEventData.pointerDrag)
		{
			if (!ValidElement(pointer.pointerEventData.pointerDrag))
			{
				pointer.pointerEventData.pointerDrag = null;
				return;
			}
			if (pointer.pointerEventData.dragging)
			{
				if (IsHovering(pointer))
				{
					ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerDrag, pointer.pointerEventData, ExecuteEvents.dragHandler);
				}
				return;
			}
			ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerDrag, pointer.pointerEventData, ExecuteEvents.dragHandler);
			ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerDrag, pointer.pointerEventData, ExecuteEvents.endDragHandler);
			foreach (RaycastResult result in results)
			{
				ExecuteEvents.ExecuteHierarchy(result.gameObject, pointer.pointerEventData, ExecuteEvents.dropHandler);
			}
			pointer.pointerEventData.pointerDrag = null;
		}
		else
		{
			if (!pointer.pointerEventData.dragging)
			{
				return;
			}
			foreach (RaycastResult result2 in results)
			{
				if (ValidElement(result2.gameObject))
				{
					ExecuteEvents.ExecuteHierarchy(result2.gameObject, pointer.pointerEventData, ExecuteEvents.initializePotentialDrag);
					ExecuteEvents.ExecuteHierarchy(result2.gameObject, pointer.pointerEventData, ExecuteEvents.beginDragHandler);
					GameObject gameObject = ExecuteEvents.ExecuteHierarchy(result2.gameObject, pointer.pointerEventData, ExecuteEvents.dragHandler);
					if (gameObject != null)
					{
						pointer.pointerEventData.pointerDrag = gameObject;
						break;
					}
				}
			}
		}
	}
}
public class Pvr_UICanvas : MonoBehaviour
{
	public bool clickOnPointerCollision;

	public float autoActivateWithinDistance;

	protected BoxCollider canvasBoxCollider;

	protected Rigidbody canvasRigidBody;

	protected Coroutine draggablePanelCreation;

	protected const string CANVAS_DRAGGABLE_PANEL = "UICANVAS_DRAGGABLE_PANEL";

	protected virtual void OnEnable()
	{
		SetupCanvas();
	}

	protected virtual void OnDisable()
	{
		RemoveCanvas();
	}

	protected virtual void OnDestroy()
	{
		RemoveCanvas();
	}

	protected virtual void SetupCanvas()
	{
		Canvas component = GetComponent<Canvas>();
		if ((bool)component && component.renderMode == RenderMode.WorldSpace)
		{
			RectTransform component2 = component.GetComponent<RectTransform>();
			Vector2 sizeDelta = component2.sizeDelta;
			GraphicRaycaster component3 = component.gameObject.GetComponent<GraphicRaycaster>();
			Pvr_UIGraphicRaycaster pvr_UIGraphicRaycaster = component.gameObject.GetComponent<Pvr_UIGraphicRaycaster>();
			if (!pvr_UIGraphicRaycaster)
			{
				pvr_UIGraphicRaycaster = component.gameObject.AddComponent<Pvr_UIGraphicRaycaster>();
			}
			if ((bool)component3 && component3.enabled)
			{
				pvr_UIGraphicRaycaster.ignoreReversedGraphics = component3.ignoreReversedGraphics;
				pvr_UIGraphicRaycaster.blockingObjects = component3.blockingObjects;
				component3.enabled = false;
			}
			if (!component.gameObject.GetComponent<BoxCollider>())
			{
				float z = 0.1f / component2.localScale.z;
				canvasBoxCollider = component.gameObject.AddComponent<BoxCollider>();
				canvasBoxCollider.size = new Vector3(sizeDelta.x, sizeDelta.y, z);
				canvasBoxCollider.isTrigger = true;
			}
			if (!component.gameObject.GetComponent<Rigidbody>())
			{
				canvasRigidBody = component.gameObject.AddComponent<Rigidbody>();
				canvasRigidBody.isKinematic = true;
			}
			draggablePanelCreation = StartCoroutine(CreateDraggablePanel(component, sizeDelta));
		}
	}

	protected virtual IEnumerator CreateDraggablePanel(Canvas canvas, Vector2 canvasSize)
	{
		if ((bool)canvas && !canvas.transform.Find("UICANVAS_DRAGGABLE_PANEL"))
		{
			yield return null;
			GameObject obj = new GameObject("UICANVAS_DRAGGABLE_PANEL", typeof(RectTransform));
			obj.AddComponent<LayoutElement>().ignoreLayout = true;
			obj.AddComponent<UnityEngine.UI.Image>().color = UnityEngine.Color.clear;
			obj.AddComponent<EventTrigger>();
			obj.transform.SetParent(canvas.transform);
			obj.GetComponent<RectTransform>().sizeDelta = canvasSize;
			obj.transform.localPosition = Vector3.zero;
			obj.transform.localRotation = Quaternion.identity;
			obj.transform.localScale = Vector3.one;
			obj.transform.SetAsFirstSibling();
		}
	}

	protected virtual void RemoveCanvas()
	{
		Canvas component = GetComponent<Canvas>();
		if ((bool)component)
		{
			GraphicRaycaster component2 = component.gameObject.GetComponent<GraphicRaycaster>();
			Pvr_UIGraphicRaycaster component3 = component.gameObject.GetComponent<Pvr_UIGraphicRaycaster>();
			if ((bool)component3)
			{
				UnityEngine.Object.Destroy(component3);
			}
			if ((bool)component2 && !component2.enabled)
			{
				component2.enabled = true;
			}
			if ((bool)canvasBoxCollider)
			{
				UnityEngine.Object.Destroy(canvasBoxCollider);
			}
			if ((bool)canvasRigidBody)
			{
				UnityEngine.Object.Destroy(canvasRigidBody);
			}
			StopCoroutine(draggablePanelCreation);
			Transform transform = component.transform.Find("UICANVAS_DRAGGABLE_PANEL");
			if ((bool)transform)
			{
				UnityEngine.Object.Destroy(transform.gameObject);
			}
		}
	}
}
public struct UIDraggableItemEventArgs
{
	public GameObject target;
}
public delegate void UIDraggableItemEventHandler(object sender, UIDraggableItemEventArgs e);
public class Pvr_UIDraggableItem : MonoBehaviour, IBeginDragHandler, IEventSystemHandler, IDragHandler, IEndDragHandler
{
	public bool restrictToDropZone;

	public bool restrictToOriginalCanvas;

	public float moveOffset = 0.1f;

	[HideInInspector]
	public GameObject validDropZone;

	protected RectTransform dragTransform;

	protected Vector3 startPosition;

	protected Quaternion startRotation;

	protected GameObject startDropZone;

	protected Transform startParent;

	protected Canvas startCanvas;

	protected CanvasGroup canvasGroup;

	protected Pvr_InputModule currentInputmodule;

	public event UIDraggableItemEventHandler DraggableItemDropped;

	public event UIDraggableItemEventHandler DraggableItemReset;

	public virtual void OnDraggableItemDropped(UIDraggableItemEventArgs e)
	{
		if (this.DraggableItemDropped != null)
		{
			this.DraggableItemDropped(this, e);
		}
	}

	public virtual void OnDraggableItemReset(UIDraggableItemEventArgs e)
	{
		if (this.DraggableItemReset != null)
		{
			this.DraggableItemReset(this, e);
		}
	}

	public void OnBeginDrag(PointerEventData eventData)
	{
		startPosition = base.transform.position;
		startRotation = base.transform.rotation;
		startParent = base.transform.parent;
		startCanvas = GetComponentInParent<Canvas>();
		canvasGroup.blocksRaycasts = false;
		if (restrictToDropZone)
		{
			startDropZone = GetComponentInParent<Pvr_UIDropZone>().gameObject;
			validDropZone = startDropZone;
		}
		SetDragPosition(eventData);
		Pvr_UIPointer pointer = GetPointer();
		if (pointer != null)
		{
			pointer.OnUIPointerElementDragStart(pointer.SetUIPointerEvent(pointer.pointerEventData.pointerPressRaycast, base.gameObject));
		}
	}

	public void OnDrag(PointerEventData eventData)
	{
		SetDragPosition(eventData);
	}

	public void OnEndDrag(PointerEventData eventData)
	{
		canvasGroup.blocksRaycasts = true;
		dragTransform = null;
		base.transform.position += base.transform.forward * moveOffset;
		bool flag = true;
		if (restrictToDropZone)
		{
			if (validDropZone != null && validDropZone != startDropZone)
			{
				base.transform.SetParent(validDropZone.transform);
			}
			else
			{
				ResetElement();
				flag = false;
			}
		}
		Canvas canvas = ((eventData.pointerEnter != null) ? eventData.pointerEnter.GetComponentInParent<Canvas>() : null);
		if (restrictToOriginalCanvas && canvas != null && canvas != startCanvas)
		{
			ResetElement();
			flag = false;
		}
		if (canvas == null)
		{
			ResetElement();
			flag = false;
		}
		if (flag)
		{
			Pvr_UIPointer pointer = GetPointer();
			if (pointer != null)
			{
				pointer.OnUIPointerElementDragEnd(pointer.SetUIPointerEvent(pointer.pointerEventData.pointerPressRaycast, base.gameObject));
			}
			OnDraggableItemDropped(SetEventPayload(validDropZone));
		}
		validDropZone = null;
		startParent = null;
		startCanvas = null;
	}

	protected virtual void OnEnable()
	{
		canvasGroup = GetComponent<CanvasGroup>();
		if (restrictToDropZone && GetComponentInParent<Pvr_UIDropZone>() == null)
		{
			base.enabled = false;
		}
		currentInputmodule = UnityEngine.Object.FindObjectOfType<Pvr_InputModule>();
	}

	protected virtual Pvr_UIPointer GetPointer()
	{
		foreach (Pvr_UIPointer pointer in Pvr_InputModule.pointers)
		{
			if (pointer.gameObject.activeInHierarchy && (bool)pointer)
			{
				return pointer;
			}
		}
		return null;
	}

	protected virtual void SetDragPosition(PointerEventData eventData)
	{
		if (eventData.pointerEnter != null && eventData.pointerEnter.transform as RectTransform != null)
		{
			dragTransform = eventData.pointerEnter.transform as RectTransform;
		}
		if (dragTransform != null && RectTransformUtility.ScreenPointToWorldPointInRectangle(dragTransform, eventData.position, eventData.pressEventCamera, out var worldPoint))
		{
			base.transform.position = worldPoint - base.transform.forward * moveOffset;
			base.transform.rotation = dragTransform.rotation;
		}
	}

	protected virtual void ResetElement()
	{
		base.transform.position = startPosition;
		base.transform.rotation = startRotation;
		base.transform.SetParent(startParent);
		OnDraggableItemReset(SetEventPayload(startParent.gameObject));
	}

	protected virtual UIDraggableItemEventArgs SetEventPayload(GameObject target)
	{
		UIDraggableItemEventArgs result = default(UIDraggableItemEventArgs);
		result.target = target;
		return result;
	}
}
public class Pvr_UIDropZone : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler
{
	protected Pvr_UIDraggableItem droppableItem;

	public void OnPointerEnter(PointerEventData eventData)
	{
		if ((bool)eventData.pointerDrag)
		{
			Pvr_UIDraggableItem component = eventData.pointerDrag.GetComponent<Pvr_UIDraggableItem>();
			if ((bool)component && component.restrictToDropZone)
			{
				component.validDropZone = base.gameObject;
				droppableItem = component;
			}
		}
	}

	public void OnPointerExit(PointerEventData eventData)
	{
		if ((bool)droppableItem)
		{
			droppableItem.validDropZone = null;
		}
		droppableItem = null;
	}
}
public class Pvr_UIGraphicRaycaster : GraphicRaycaster
{
	protected Canvas currentCanvas;

	protected Vector2 lastKnownPosition;

	protected const float UI_CONTROL_OFFSET = 1E-05f;

	[NonSerialized]
	private static List<RaycastResult> s_RaycastResults = new List<RaycastResult>();

	protected virtual Canvas canvas
	{
		get
		{
			if (currentCanvas != null)
			{
				return currentCanvas;
			}
			currentCanvas = base.gameObject.GetComponent<Canvas>();
			return currentCanvas;
		}
	}

	public override void Raycast(PointerEventData eventData, List<RaycastResult> resultAppendList)
	{
		if (!(canvas == null))
		{
			Raycast(ray: new Ray(eventData.pointerCurrentRaycast.worldPosition, eventData.pointerCurrentRaycast.worldNormal), canvas: canvas, eventCamera: eventCamera, results: ref s_RaycastResults);
			SetNearestRaycast(ref eventData, ref resultAppendList, ref s_RaycastResults);
			s_RaycastResults.Clear();
		}
	}

	protected virtual void SetNearestRaycast(ref PointerEventData eventData, ref List<RaycastResult> resultAppendList, ref List<RaycastResult> raycastResults)
	{
		RaycastResult? raycastResult = null;
		for (int i = 0; i < raycastResults.Count; i++)
		{
			RaycastResult raycastResult2 = raycastResults[i];
			raycastResult2.index = resultAppendList.Count;
			if (!raycastResult.HasValue || raycastResult2.distance < raycastResult.Value.distance)
			{
				raycastResult = raycastResult2;
			}
			resultAppendList.Add(raycastResult2);
		}
		if (raycastResult.HasValue)
		{
			eventData.position = raycastResult.Value.screenPosition;
			eventData.delta = eventData.position - lastKnownPosition;
			lastKnownPosition = eventData.position;
			eventData.pointerCurrentRaycast = raycastResult.Value;
		}
	}

	protected virtual float GetHitDistance(Ray ray)
	{
		float result = float.MaxValue;
		if (canvas.renderMode != 0 && base.blockingObjects != 0)
		{
			float num = Vector3.Distance(ray.origin, canvas.transform.position);
			if (base.blockingObjects == BlockingObjects.ThreeD || base.blockingObjects == BlockingObjects.All)
			{
				Physics.Raycast(ray, out var hitInfo, num);
				if ((bool)hitInfo.collider)
				{
					result = hitInfo.distance;
				}
			}
			if (base.blockingObjects == BlockingObjects.TwoD || base.blockingObjects == BlockingObjects.All)
			{
				RaycastHit2D raycastHit2D = Physics2D.Raycast(ray.origin, ray.direction, num);
				if (raycastHit2D.collider != null)
				{
					result = raycastHit2D.fraction * num;
				}
			}
		}
		return result;
	}

	protected virtual void Raycast(Canvas canvas, Camera eventCamera, Ray ray, ref List<RaycastResult> results)
	{
		float hitDistance = GetHitDistance(ray);
		IList<Graphic> graphicsForCanvas = GraphicRegistry.GetGraphicsForCanvas(canvas);
		for (int i = 0; i < graphicsForCanvas.Count; i++)
		{
			Graphic graphic = graphicsForCanvas[i];
			if (graphic.depth == -1 || !graphic.raycastTarget)
			{
				continue;
			}
			Transform transform = graphic.transform;
			Vector3 forward = transform.forward;
			float num = Vector3.Dot(forward, transform.position - ray.origin) / Vector3.Dot(forward, ray.direction);
			if (!(num < 0f) && !(num - 1E-05f > hitDistance))
			{
				Vector3 point = ray.GetPoint(num);
				Vector2 vector = eventCamera.WorldToScreenPoint(point);
				if (RectTransformUtility.RectangleContainsScreenPoint(graphic.rectTransform, vector, eventCamera) && graphic.Raycast(vector, eventCamera))
				{
					RaycastResult raycastResult = default(RaycastResult);
					raycastResult.gameObject = graphic.gameObject;
					raycastResult.module = this;
					raycastResult.distance = num;
					raycastResult.screenPosition = vector;
					raycastResult.worldPosition = point;
					raycastResult.depth = graphic.depth;
					raycastResult.sortingLayer = canvas.sortingLayerID;
					raycastResult.sortingOrder = canvas.sortingOrder;
					RaycastResult item = raycastResult;
					results.Add(item);
				}
			}
		}
		results.Sort((RaycastResult g1, RaycastResult g2) => g2.depth.CompareTo(g1.depth));
	}
}
public struct UIPointerEventArgs
{
	public bool isActive;

	public GameObject currentTarget;

	public GameObject previousTarget;

	public RaycastResult raycastResult;
}
public delegate void UIPointerEventHandler(object sender, UIPointerEventArgs e);
public class Pvr_UIPointer : MonoBehaviour
{
	public enum ClickMethods
	{
		ClickOnButtonUp,
		ClickOnButtonDown
	}

	public ClickMethods clickMethod;

	[HideInInspector]
	public bool collisionClick;

	[HideInInspector]
	public bool pressToDrag;

	[HideInInspector]
	public GameObject autoActivatingCanvas;

	[HideInInspector]
	public PointerEventData pointerEventData;

	[HideInInspector]
	public GameObject hoveringElement;

	[HideInInspector]
	public float hoverDurationTimer;

	[HideInInspector]
	public bool canClickOnHover;

	public Transform pointerOriginTransform;

	protected bool pointerClicked;

	protected bool beamEnabledState;

	protected bool lastPointerPressState;

	protected bool lastPointerClickState;

	protected GameObject currentTarget;

	protected EventSystem cachedEventSystem;

	protected Pvr_InputModule cachedVRInputModule;

	protected Transform originalPointerOriginTransform;

	public static bool TouchBtnValue;

	public static bool AppBtnValue;

	public static bool TriggerBtnValue;

	public event UIPointerEventHandler UIPointerElementEnter;

	public event UIPointerEventHandler UIPointerElementExit;

	public event UIPointerEventHandler UIPointerElementClick;

	public event UIPointerEventHandler UIPointerElementDragStart;

	public event UIPointerEventHandler UIPointerElementDragEnd;

	public virtual bool PointerActive()
	{
		return true;
	}

	public virtual bool IsSelectionButtonPressed()
	{
		if (!Input.GetMouseButton(0) && !Input.GetKey(KeyCode.JoystickButton0) && !TouchBtnValue && !AppBtnValue)
		{
			return TriggerBtnValue;
		}
		return true;
	}

	public virtual Vector3 GetOriginPosition()
	{
		if (!pointerOriginTransform)
		{
			return base.transform.position;
		}
		return pointerOriginTransform.position;
	}

	public virtual Vector3 GetOriginForward()
	{
		if (!pointerOriginTransform)
		{
			return base.transform.forward;
		}
		return pointerOriginTransform.forward;
	}

	public virtual bool ValidClick(bool checkLastClick, bool lastClickState = false)
	{
		bool result = (collisionClick ? collisionClick : IsSelectionButtonPressed());
		if (!checkLastClick)
		{
			return result;
		}
		return result;
	}

	protected virtual void ResetHoverTimer()
	{
		hoverDurationTimer = 0f;
		canClickOnHover = false;
	}

	public virtual void OnUIPointerElementEnter(UIPointerEventArgs e)
	{
		if (e.currentTarget != currentTarget)
		{
			ResetHoverTimer();
		}
		currentTarget = e.currentTarget;
		if (this.UIPointerElementEnter != null)
		{
			this.UIPointerElementEnter(this, e);
		}
	}

	public virtual void OnUIPointerElementExit(UIPointerEventArgs e)
	{
		if (e.previousTarget == currentTarget)
		{
			ResetHoverTimer();
		}
		if (this.UIPointerElementExit != null)
		{
			this.UIPointerElementExit(this, e);
		}
	}

	public virtual void OnUIPointerElementClick(UIPointerEventArgs e)
	{
		if (e.currentTarget == currentTarget)
		{
			ResetHoverTimer();
		}
		if (this.UIPointerElementClick != null)
		{
			this.UIPointerElementClick(this, e);
		}
	}

	public virtual void OnUIPointerElementDragStart(UIPointerEventArgs e)
	{
		if (this.UIPointerElementDragStart != null)
		{
			this.UIPointerElementDragStart(this, e);
		}
	}

	public virtual void OnUIPointerElementDragEnd(UIPointerEventArgs e)
	{
		if (this.UIPointerElementDragEnd != null)
		{
			this.UIPointerElementDragEnd(this, e);
		}
	}

	public virtual UIPointerEventArgs SetUIPointerEvent(RaycastResult currentRaycastResult, GameObject currentTarget, GameObject lastTarget = null)
	{
		UIPointerEventArgs result = default(UIPointerEventArgs);
		result.isActive = PointerActive();
		result.currentTarget = currentTarget;
		result.previousTarget = lastTarget;
		result.raycastResult = currentRaycastResult;
		return result;
	}

	protected virtual void Awake()
	{
		originalPointerOriginTransform = pointerOriginTransform;
	}

	protected virtual void OnEnable()
	{
		pointerOriginTransform = originalPointerOriginTransform;
		ConfigureEventSystem();
		pointerClicked = false;
		lastPointerPressState = false;
		lastPointerClickState = false;
		beamEnabledState = false;
	}

	protected virtual void OnDisable()
	{
		Pvr_InputModule.RemovePoint(this);
	}

	protected virtual void ConfigureEventSystem()
	{
		if (!cachedEventSystem)
		{
			cachedEventSystem = UnityEngine.Object.FindObjectOfType<EventSystem>();
		}
		if (!cachedVRInputModule)
		{
			cachedVRInputModule = cachedEventSystem.GetComponent<Pvr_InputModule>();
		}
		if ((bool)cachedEventSystem && (bool)cachedVRInputModule && pointerEventData == null)
		{
			pointerEventData = new PointerEventData(cachedEventSystem);
		}
		Pvr_InputModule.AddPoint(this);
	}
}
[ExecuteInEditMode]
public class Pvr_UnitySDKEditor : MonoBehaviour
{
	private bool vrModeEnabled = true;

	private float mouseX;

	private float mouseY;

	private float mouseZ;

	private float neckModelScale;

	private bool autoUntiltHead;

	private static readonly Vector3 neckOffset = new Vector3(0f, 0.075f, 0.0805f);

	[HideInInspector]
	public Matrix4x4 headView;

	[HideInInspector]
	public Matrix4x4 leftEyeUndistortedProj;

	[HideInInspector]
	public Matrix4x4 rightEyeUndistortedProj;

	[HideInInspector]
	public Matrix4x4 leftEyeProj;

	[HideInInspector]
	public Matrix4x4 rightEyeProj;

	private const float TOUCH_TIME_LIMIT = 0.2f;

	private float touchStartTime;

	public Matrix4x4 UndistortedProjection(Eye eye)
	{
		if (eye != 0)
		{
			return rightEyeUndistortedProj;
		}
		return leftEyeUndistortedProj;
	}

	public Matrix4x4 Projection(Eye eye)
	{
		if (eye != 0)
		{
			return rightEyeProj;
		}
		return leftEyeProj;
	}

	private void Awake()
	{
		InitEyePara();
		InitEditorSensorPara();
	}

	private void Update()
	{
		SimulateInput();
		Pvr_UnitySDKManager.SDK.picovrTriggered = Pvr_UnitySDKManager.SDK.newPicovrTriggered;
		Pvr_UnitySDKManager.SDK.newPicovrTriggered = false;
	}

	public void InitEyePara()
	{
		ComputeEyesFromProfile();
		InitForEye(ref Pvr_UnitySDKManager.SDK.Eyematerial, ref Pvr_UnitySDKManager.SDK.Middlematerial);
		if (Pvr_UnitySDKRender.Instance == null)
		{
			PLOG.I("pvr_UnitySDKRender init failed");
		}
		if (Pvr_UnitySDKSensor.Instance == null)
		{
			PLOG.I("pvr_UnitySDKSensor init failed");
		}
		FovAdjust();
	}

	private void InitEditorSensorPara()
	{
		Pvr_UnitySDKManager.SDK.picovrTriggered = Pvr_UnitySDKManager.SDK.newPicovrTriggered;
		Pvr_UnitySDKManager.SDK.newPicovrTriggered = false;
	}

	public static Matrix4x4 MakeProjection(float l, float t, float r, float b, float n, float f)
	{
		Matrix4x4 zero = Matrix4x4.zero;
		zero[0, 0] = 2f * n / (r - l);
		zero[1, 1] = 2f * n / (t - b);
		zero[0, 2] = (r + l) / (r - l);
		zero[1, 2] = (t + b) / (t - b);
		zero[2, 2] = (n + f) / (n - f);
		zero[2, 3] = 2f * n * f / (n - f);
		zero[3, 2] = -1f;
		return zero;
	}

	public bool UpdateStatesensor()
	{
		UpdateSimulatedSensor();
		return true;
	}

	public void ComputeEyesFromProfile()
	{
		Vector2 vector = new Vector2(0.11f, 0.062f);
		Pvr_UnitySDKManager.SDK.leftEyeView = Matrix4x4.identity;
		Pvr_UnitySDKManager.SDK.leftEyeView[0, 3] = (0f - Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.device.devLenses.separation) / 2f;
		float[] leftEyeVisibleTanAngles = Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.GetLeftEyeVisibleTanAngles(vector.x, vector.y);
		leftEyeProj = MakeProjection(leftEyeVisibleTanAngles[0], leftEyeVisibleTanAngles[1], leftEyeVisibleTanAngles[2], leftEyeVisibleTanAngles[3], 1f, 1000f);
		leftEyeVisibleTanAngles = Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.GetLeftEyeNoLensTanAngles(vector.x, vector.y);
		leftEyeUndistortedProj = MakeProjection(leftEyeVisibleTanAngles[0], leftEyeVisibleTanAngles[1], leftEyeVisibleTanAngles[2], leftEyeVisibleTanAngles[3], 1f, 1000f);
		Pvr_UnitySDKManager.SDK.leftEyeRect = Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.GetLeftEyeVisibleScreenRect(leftEyeVisibleTanAngles, vector.x, vector.y);
		Pvr_UnitySDKManager.SDK.rightEyeView = Pvr_UnitySDKManager.SDK.leftEyeView;
		Pvr_UnitySDKManager.SDK.rightEyeView[0, 3] *= -1f;
		rightEyeProj = leftEyeProj;
		rightEyeProj[0, 2] *= -1f;
		rightEyeUndistortedProj = leftEyeUndistortedProj;
		rightEyeUndistortedProj[0, 2] *= -1f;
		Rect leftEyeRect = new Rect(0f, 0f, 0.5f, 1f);
		Rect rightEyeRect = new Rect(0.5f, 0f, 0.5f, 1f);
		Pvr_UnitySDKManager.SDK.leftEyeRect = leftEyeRect;
		Pvr_UnitySDKManager.SDK.rightEyeRect = rightEyeRect;
		Pvr_UnitySDKManager.SDK.leftEyeOffset = new Vector3((0f - Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.device.devLenses.separation) / 2f, 0f, 0f);
		Pvr_UnitySDKManager.SDK.rightEyeOffset = new Vector3(Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.device.devLenses.separation / 2f, 0f, 0f);
	}

	public bool ResetUnitySDKSensor()
	{
		mouseX = (mouseY = (mouseZ = 0f));
		return true;
	}

	private void SimulateInput()
	{
		if (Input.GetMouseButtonDown(0) && (Input.GetKey(KeyCode.LeftAlt) || Input.GetKey(KeyCode.RightAlt)))
		{
			EnableVEmodel();
		}
		if (Input.GetMouseButtonDown(0))
		{
			touchStartTime = Time.time;
		}
		else if (Input.GetMouseButtonUp(0))
		{
			if (Time.time - touchStartTime <= 0.2f)
			{
				Pvr_UnitySDKManager.SDK.newPicovrTriggered = true;
			}
			touchStartTime = 0f;
		}
		UpdateSimulatedSensor();
	}

	private void FovAdjust()
	{
		Pvr_UnitySDKRender.Instance.EyeVFoV = 2f * Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.device.devMaxFov.upper;
	}

	private Rect RectAdjust(Rect eyeRect)
	{
		Rect result = new Rect(0f, 0f, 0.5f, 1f);
		result.width *= 2f * eyeRect.width;
		result.x = eyeRect.x + 2f * result.x * eyeRect.width;
		result.height *= eyeRect.height;
		result.y = eyeRect.y + result.y * eyeRect.height;
		return result;
	}

	private void UpdateSimulatedSensor()
	{
		bool flag = false;
		if (Input.GetKey(KeyCode.LeftAlt) || Input.GetKey(KeyCode.RightAlt))
		{
			mouseX += Input.GetAxis("Mouse X") * 5f;
			if (mouseX <= -180f)
			{
				mouseX += 360f;
			}
			else if (mouseX > 180f)
			{
				mouseX -= 360f;
			}
			mouseY -= Input.GetAxis("Mouse Y") * 2.4f;
			mouseY = Mathf.Clamp(mouseY, -91f, 91f);
		}
		else if (Input.GetKey(KeyCode.LeftControl) || Input.GetKey(KeyCode.RightControl))
		{
			flag = true;
			mouseZ += Input.GetAxis("Mouse X") * 5f;
			mouseZ = Mathf.Clamp(mouseZ, -91f, 91f);
		}
		if (!flag && autoUntiltHead)
		{
			mouseZ = Mathf.Lerp(mouseZ, 0f, Time.deltaTime / (Time.deltaTime + 0.1f));
		}
		Quaternion quaternion = Quaternion.Euler(mouseY, mouseX, mouseZ);
		Matrix4x4 matrix = Matrix4x4.TRS((quaternion * neckOffset - neckOffset.y * Vector3.up) * neckModelScale, quaternion, Vector3.one);
		Pvr_UnitySDKSensor.Instance.HeadPose = new Pvr_UnitySDKPose(matrix);
	}

	private void InitForEye(ref Material mat, ref Material mat1)
	{
		Shader shader = Shader.Find("Pvr_UnitySDK/Undistortion");
		Shader shader2 = Shader.Find("Pvr_UnitySDK/FillColor");
		if (shader == null || shader2 == null)
		{
			PLOG.E("Ths Shader Missing ！");
			return;
		}
		mat = new Material(shader);
		mat1 = new Material(shader2);
	}

	private void EnableVEmodel()
	{
		vrModeEnabled = !vrModeEnabled;
		Pvr_UnitySDKManager.SDK.VRModeEnabled = vrModeEnabled;
	}
}
public class Pvr_VolumePowerBrightness : MonoBehaviour
{
	private bool VolEnable;

	private bool BattEnable;

	public Text showResult;

	public Text setVolumnum;

	public Text setBrightnum;

	public string MusicPath;

	private void Awake()
	{
		InitBatteryVolClass();
		string startreceivre = base.gameObject.name;
		StartBatteryReceiver(startreceivre);
		StartAudioReceiver(startreceivre);
	}

	private void OnDisable()
	{
		if (VolEnable)
		{
			StopAudioReceiver();
		}
		if (BattEnable)
		{
			StopBatteryReceiver();
		}
	}

	public void GetMaxVolumeNumber()
	{
		int num = 0;
		num = VolumePowerBrightness.UPvr_GetMaxVolumeNumber();
		showResult.text = "Maximum volume: " + num;
	}

	public void GetCurrentVolumeNumber()
	{
		int num = 0;
		num = VolumePowerBrightness.UPvr_GetCurrentVolumeNumber();
		showResult.text = "Current volume：" + num;
	}

	public void VolumeUp()
	{
		if (!VolumePowerBrightness.UPvr_VolumeUp())
		{
			PLOG.E("VolumeUp Error");
		}
	}

	public void VolumeDown()
	{
		if (!VolumePowerBrightness.UPvr_VolumeDown())
		{
			PLOG.E("VolumeDown Error");
		}
	}

	public void SetVolumeNum()
	{
		int volume = new System.Random().Next(0, 15);
		setVolumnum.text = "Random number：" + volume;
		if (!VolumePowerBrightness.UPvr_SetVolumeNum(volume))
		{
			PLOG.E("SetVolumeNum Error");
		}
	}

	public void SetBrightness()
	{
		int brightness = new System.Random().Next(0, 255);
		setBrightnum.text = "Random number：" + brightness;
		if (!VolumePowerBrightness.UPvr_SetCommonBrightness(brightness))
		{
			PLOG.E("SetBrightness Error");
		}
	}

	public void GetCurrentBrightness()
	{
		int num = 0;
		num = VolumePowerBrightness.UPvr_GetCommonBrightness();
		showResult.text = "Current brightness：" + num;
	}

	public bool setAudio(string s)
	{
		PLOG.I(s.ToString());
		return true;
	}

	public bool setBattery(string s)
	{
		PLOG.I(s.ToString());
		return true;
	}

	private bool InitBatteryVolClass()
	{
		return VolumePowerBrightness.UPvr_InitBatteryVolClass();
	}

	private bool StartBatteryReceiver(string startreceivre)
	{
		BattEnable = VolumePowerBrightness.UPvr_StartBatteryReceiver(startreceivre);
		return BattEnable;
	}

	private bool StopBatteryReceiver()
	{
		return VolumePowerBrightness.UPvr_StopBatteryReceiver();
	}

	private bool StartAudioReceiver(string startreceivre)
	{
		VolEnable = VolumePowerBrightness.UPvr_StartAudioReceiver(startreceivre);
		return VolEnable;
	}

	private bool StopAudioReceiver()
	{
		return VolumePowerBrightness.UPvr_StopAudioReceiver();
	}
}
public class ARFoundationPlacement : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class ARKitPlacement : MonoBehaviour
{
	public Transform m_HitTransform;
}
public class ControllerGrabObject : MonoBehaviour
{
	private GameObject collidingObject;

	private GameObject objectInHand;

	public void OnTriggerEnter(Collider other)
	{
		SetCollidingObject(other);
	}

	public void OnTriggerStay(Collider other)
	{
		SetCollidingObject(other);
	}

	public void OnTriggerExit(Collider other)
	{
		if ((bool)collidingObject)
		{
			collidingObject = null;
		}
	}

	private void SetCollidingObject(Collider col)
	{
		if (!collidingObject && (bool)col.GetComponent<Rigidbody>())
		{
			collidingObject = col.gameObject;
		}
	}

	private void Update()
	{
	}

	private void GrabObject()
	{
		objectInHand = collidingObject;
		collidingObject = null;
		AddFixedJoint().connectedBody = objectInHand.GetComponent<Rigidbody>();
	}

	private FixedJoint AddFixedJoint()
	{
		FixedJoint fixedJoint = base.gameObject.AddComponent<FixedJoint>();
		fixedJoint.breakForce = 20000f;
		fixedJoint.breakTorque = 20000f;
		return fixedJoint;
	}

	private void ReleaseObject()
	{
	}
}
public class GearGrabObject : MonoBehaviour
{
	public GameObject reticle;

	private GameObject objectInHand;

	private float distanceToObject;

	private void Start()
	{
		HideReticle();
	}

	private void FixedUpdate()
	{
		RaycastHit hitInfo;
		if (objectInHand != null)
		{
			HideReticle();
			objectInHand.transform.position = Vector3.Lerp(objectInHand.transform.position, base.transform.forward * distanceToObject + base.transform.position, Time.deltaTime * 2f);
			objectInHand.transform.rotation = Quaternion.Lerp(objectInHand.transform.rotation, base.transform.rotation, Time.deltaTime * 2f);
		}
		else if (Physics.Raycast(base.transform.position, base.transform.forward, out hitInfo, 10f, ~LayerMask.NameToLayer("Ignore Raycast"), QueryTriggerInteraction.Ignore))
		{
			ShowRecticle(hitInfo);
		}
		else
		{
			HideReticle();
		}
	}

	private void HandleTouchHandler(object sender, EventArgs e)
	{
	}

	private void GrabObject(GameObject obj)
	{
		distanceToObject = base.transform.InverseTransformPoint(obj.transform.position).magnitude;
		objectInHand = obj;
		obj.GetComponent<Rigidbody>().isKinematic = true;
	}

	private void ReleaseObject()
	{
		objectInHand.GetComponent<Rigidbody>().isKinematic = false;
		objectInHand = null;
	}

	private void ShowRecticle(RaycastHit hit)
	{
		reticle.transform.position = hit.point - base.transform.forward * 0.05f;
		reticle.transform.rotation = Quaternion.FromToRotation(Vector3.forward, hit.normal);
		reticle.SetActive(value: true);
	}

	private void HideReticle()
	{
		reticle.SetActive(value: false);
	}
}
public class MovementLimiter : MonoBehaviour
{
	public Transform m_MoveTransform;

	private Quaternion oRotation;

	private Vector3 oPosition;

	private void Start()
	{
		oRotation = m_MoveTransform.rotation;
		oPosition = m_MoveTransform.position;
	}

	private void Update()
	{
		m_MoveTransform.rotation = oRotation;
		m_MoveTransform.position = new Vector3(oPosition.x, m_MoveTransform.position.y, oPosition.z);
	}
}
public class ThrowObject : MonoBehaviour
{
	public GameObject objectToThrow;

	public Vector3 force;

	private void Start()
	{
	}

	private void Update()
	{
		if (Input.GetMouseButtonDown(0))
		{
			Vector3 vector = base.transform.TransformDirection(new Vector3(0f, 0f, 2f));
			GameObject obj = UnityEngine.Object.Instantiate(objectToThrow, base.transform.position + vector, Quaternion.identity);
			obj.GetComponent<Rigidbody>().AddForce(base.transform.TransformDirection(force));
			obj.layer = base.gameObject.layer;
		}
	}
}
public class ARKitCameraRender : MonoBehaviour
{
	public Material m_ClearMaterial;

	private CommandBuffer m_VideoCommandBuffer;

	private bool bCommandBufferInitialized;

	public void Start()
	{
		bCommandBufferInitialized = false;
	}

	private void InitializeCommandBuffer()
	{
		m_VideoCommandBuffer = new CommandBuffer();
		m_VideoCommandBuffer.Blit(null, BuiltinRenderTextureType.CurrentActive, m_ClearMaterial);
		GetComponent<Camera>().AddCommandBuffer(CameraEvent.BeforeForwardOpaque, m_VideoCommandBuffer);
		bCommandBufferInitialized = true;
	}

	private void OnDestroy()
	{
		GetComponent<Camera>().RemoveCommandBuffer(CameraEvent.BeforeForwardOpaque, m_VideoCommandBuffer);
		bCommandBufferInitialized = false;
	}

	public void OnPreRender()
	{
		if (!bCommandBufferInitialized)
		{
			InitializeCommandBuffer();
		}
	}
}
public static class CameraExtensions
{
	public static void ClearCameraComponents(this Camera camera)
	{
		if ((bool)camera.GetComponent<AudioListener>())
		{
			UnityEngine.Object.Destroy(camera.GetComponent<AudioListener>());
		}
		if ((bool)camera.GetComponent<FlareLayer>())
		{
			UnityEngine.Object.Destroy(camera.GetComponent<FlareLayer>());
		}
		camera.gameObject.tag = "Untagged";
		camera.enabled = false;
	}

	public static void LayerCullingShow(this Camera cam, int layer)
	{
		cam.cullingMask |= 1 << layer;
	}

	public static void LayerCullingShowMask(this Camera cam, int layerMask)
	{
		cam.cullingMask |= layerMask;
	}

	public static void LayerCullingHide(this Camera cam, int layerMask)
	{
		cam.cullingMask &= ~(1 << layerMask);
	}

	public static void LayerCullingToggle(this Camera cam, int layerMask)
	{
		cam.cullingMask ^= layerMask;
	}

	public static bool LayerCullingIncludes(this Camera cam, int layerMask)
	{
		return (cam.cullingMask & layerMask) > 0;
	}

	public static Camera CameraForObject(this GameObject obj)
	{
		if ((bool)obj.GetComponent<Camera>())
		{
			return obj.GetComponent<Camera>();
		}
		if ((bool)obj.GetComponentInChildren<Camera>())
		{
			return obj.GetComponentInChildren<Camera>();
		}
		return null;
	}
}
public class Dimension : MonoBehaviour
{
	public Material customSkybox;

	[HideInInspector]
	public int layer;

	[Tooltip("This designates this dimension as the original dimension from which the experience will start.")]
	public bool initialWorld;

	[Tooltip("This forces the Dimension to only affect the layers during rendering (thus keeping things like raycasting intact). Warning: This will break the automatic physics adjustment that keeps you from hitting things in other dimensions.")]
	public bool forceKeepInitialLayers;

	[HideInInspector]
	public List<Portal> connectedPortals;

	[HideInInspector]
	public Camera cam;

	private Dictionary<int, int> layerSwitchedChildren;

	private bool mainCameraNeedsSetup = true;

	private void Awake()
	{
		connectedPortals = new List<Portal>();
		layer = LayerManager.Instance().CreateLayer(base.gameObject.name);
		LayerManager.definedDimensions.Add(this);
		Camera[] allCameras = Camera.allCameras;
		foreach (Camera camera in allCameras)
		{
			if (!(camera.tag != "PortalCamera"))
			{
				continue;
			}
			if (initialWorld)
			{
				camera.LayerCullingShow(layer);
				if ((bool)GameController.instance.currentRoom)
				{
					GameController.instance.currentRoom.AddToLayerMask(layer, setCamera: false);
				}
				UnityEngine.Debug.Log("SHOW Layer : " + layer + " on camera : " + camera.name);
				if ((bool)camera.GetComponent<Skybox>())
				{
					camera.GetComponent<Skybox>().material = customSkybox;
				}
			}
			else
			{
				camera.LayerCullingHide(layer);
				if ((bool)GameController.instance.currentRoom)
				{
					GameController.instance.currentRoom.SubtractFromLayerMask(layer, setCamera: false);
				}
				UnityEngine.Debug.Log("HIDE Layer : " + layer + " on camera : " + camera.name);
			}
		}
	}

	private void Start()
	{
	}

	private void Update()
	{
		if (!mainCameraNeedsSetup || Camera.main == null)
		{
			return;
		}
		if (initialWorld)
		{
			Camera.main.LayerCullingShow(layer);
			if ((bool)GameController.instance.currentRoom)
			{
				GameController.instance.currentRoom.AddToLayerMask(layer, setCamera: false);
			}
			UnityEngine.Debug.Log("SHOW Layer : " + layer + " on camera : " + Camera.main.name);
			Camera.main.gameObject.layer = layer;
			if ((bool)Camera.main.GetComponent<Skybox>())
			{
				Camera.main.GetComponent<Skybox>().material = customSkybox;
			}
		}
		else
		{
			Camera.main.LayerCullingHide(layer);
			if ((bool)GameController.instance.currentRoom)
			{
				GameController.instance.currentRoom.SubtractFromLayerMask(layer, setCamera: false);
			}
			UnityEngine.Debug.Log("HIDE Layer : " + layer + " on camera : " + Camera.main.name);
		}
		mainCameraNeedsSetup = false;
	}

	public void SwitchConnectingPortals()
	{
		foreach (Portal connectedPortal in connectedPortals)
		{
			if (connectedPortal.ToDimension() == this)
			{
				connectedPortal.SwitchPortalDimensions();
			}
		}
	}

	public void showChildrenWithTag(string tag)
	{
		if (tag == "" || tag == null)
		{
			return;
		}
		int num = LayerMask.NameToLayer("Default");
		Transform[] componentsInChildren = base.gameObject.GetComponentsInChildren<Transform>();
		foreach (Transform transform in componentsInChildren)
		{
			if (transform.CompareTag(tag))
			{
				transform.gameObject.layer = num;
			}
		}
	}

	public void PreRender()
	{
		if (!forceKeepInitialLayers)
		{
			return;
		}
		if (layerSwitchedChildren == null)
		{
			layerSwitchedChildren = new Dictionary<int, int>();
		}
		layerSwitchedChildren.Clear();
		int cullingMask = LayerMask.NameToLayer("Default");
		Transform[] componentsInChildren = base.gameObject.GetComponentsInChildren<Transform>();
		foreach (Transform transform in componentsInChildren)
		{
			layerSwitchedChildren.Add(transform.gameObject.GetInstanceID(), transform.gameObject.layer);
			transform.gameObject.layer = layer;
			if ((bool)transform.gameObject.GetComponent<Light>())
			{
				Light component = transform.gameObject.GetComponent<Light>();
				component.cullingMask = cullingMask;
				component.cullingMask |= 1 << layer;
			}
		}
	}

	public void PostRender()
	{
		if (forceKeepInitialLayers)
		{
			Transform[] componentsInChildren = base.gameObject.GetComponentsInChildren<Transform>();
			foreach (Transform transform in componentsInChildren)
			{
				int num = layerSwitchedChildren[transform.gameObject.GetInstanceID()];
				transform.gameObject.layer = num;
			}
		}
	}
}
public static class DimensionChanger
{
	public static void SwitchDimensions(GameObject obj, Dimension fromDimension, Dimension toDimension)
	{
		obj.layer = toDimension.layer;
		MeshRenderer[] componentsInChildren = obj.GetComponentsInChildren<MeshRenderer>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].gameObject.layer = toDimension.layer;
		}
		Transform parent = obj.transform.parent;
		if (parent != null && (bool)parent.GetComponent<CharacterController>())
		{
			parent.gameObject.layer = toDimension.layer;
		}
	}

	public static void SwitchCameraRender(Camera camera, int fromDimensionLayer, int toDimensionLayer, Material dimensionSkybox)
	{
		if (camera.tag != "PortalCamera")
		{
			camera.LayerCullingShow(toDimensionLayer);
			UnityEngine.Debug.Log("SHOW Layer : " + toDimensionLayer + " on camera : " + camera.name);
		}
		if ((bool)GameController.instance.currentRoom)
		{
			GameController.instance.currentRoom.AddToLayerMask(toDimensionLayer, setCamera: false);
		}
		if (camera.tag != "PortalCamera")
		{
			camera.LayerCullingHide(fromDimensionLayer);
			UnityEngine.Debug.Log("SHOW Layer : " + fromDimensionLayer + " on camera : " + camera.name);
		}
		if ((bool)GameController.instance.currentRoom)
		{
			GameController.instance.currentRoom.SubtractFromLayerMask(fromDimensionLayer, setCamera: false);
		}
		if ((bool)dimensionSkybox && (bool)camera.GetComponent<Skybox>())
		{
			camera.GetComponent<Skybox>().material = dimensionSkybox;
		}
	}
}
public class GearCameraRenderInfo : MonoBehaviour
{
	public bool toggle = true;

	public bool isLeftEye = true;

	private void OnPreRender()
	{
		Shader.SetGlobalInt("RenderingEye", isLeftEye ? 1 : 0);
		if (toggle)
		{
			isLeftEye = !isLeftEye;
		}
	}
}
public class LayerManager
{
	private static LayerManager instance = null;

	public List<string> definedLayers;

	public static List<Dimension> definedDimensions = new List<Dimension>();

	private static int totalLayerNum = 31;

	public static LayerManager Instance()
	{
		if (instance == null)
		{
			instance = new LayerManager();
			instance.definedLayers = new List<string>();
		}
		return instance;
	}

	public int CreateLayer(string name)
	{
		definedLayers.Add(name);
		for (int i = 0; i < definedLayers.Count; i++)
		{
			for (int j = 0; j < definedLayers.Count; j++)
			{
				if (i != j)
				{
					Physics.IgnoreLayerCollision(totalLayerNum - i - 1, totalLayerNum - j - 1);
				}
			}
		}
		return totalLayerNum - definedLayers.Count;
	}
}
public class MainCameraLayerManager : MonoBehaviour
{
	private void OnPreCull()
	{
		foreach (Dimension definedDimension in LayerManager.definedDimensions)
		{
			definedDimension.PreRender();
		}
	}

	private void OnPostRender()
	{
		foreach (Dimension definedDimension in LayerManager.definedDimensions)
		{
			definedDimension.PostRender();
		}
	}
}
[RequireComponent(typeof(MeshFilter))]
public class MeshDeformer : MonoBehaviour
{
	protected Mesh deformingMesh;

	protected Vector3[] originalVertices;

	protected Vector3[] displacedVertices;

	public bool lockXEdges;

	public bool lockYEdges;

	public bool lockZEdges;

	private void Start()
	{
		deformingMesh = GetComponent<MeshFilter>().mesh;
		originalVertices = deformingMesh.vertices;
		displacedVertices = new Vector3[originalVertices.Length];
		for (int i = 0; i < originalVertices.Length; i++)
		{
			displacedVertices[i] = originalVertices[i];
		}
	}

	public void ClearDeformingForce()
	{
		for (int i = 0; i < originalVertices.Length; i++)
		{
			displacedVertices[i] = originalVertices[i];
		}
		deformingMesh.vertices = displacedVertices;
		deformingMesh.RecalculateNormals();
	}

	public void AddDeformingForce(Vector3 point, float force)
	{
		point = base.transform.InverseTransformPoint(point);
		for (int i = 0; i < displacedVertices.Length; i++)
		{
			AddForceToVertex(i, point, force);
		}
		deformingMesh.vertices = displacedVertices;
		deformingMesh.RecalculateNormals();
	}

	public virtual void AddDeformingForce(Vector3 point, float force, bool direction)
	{
		AddDeformingForce(point, force);
	}

	protected virtual void AddForceToVertex(int i, Vector3 point, float force)
	{
		if ((!lockXEdges || (originalVertices[i].x != -0.5f && originalVertices[i].x != 0.5f)) && (!lockYEdges || (originalVertices[i].y != -0.5f && originalVertices[i].y != 0.5f)) && (!lockZEdges || (originalVertices[i].z != -0.5f && originalVertices[i].z != 0.5f)))
		{
			Vector3 vector = originalVertices[i] - point;
			vector = new Vector3(vector.x * base.transform.localScale.x, vector.y * base.transform.localScale.y, vector.z * base.transform.localScale.z);
			float num = Mathf.Max(Mathf.Abs(force) - vector.magnitude, 0f);
			Vector3 vector2 = vector.normalized * num;
			vector2 = new Vector3(vector2.x / base.transform.localScale.x, vector2.y / base.transform.localScale.y, vector2.z / base.transform.localScale.z);
			displacedVertices[i] = originalVertices[i] + vector2;
		}
	}
}
public class MeshDeformerInput : MonoBehaviour
{
	public float force = 10f;

	public float forceOffset = 0.1f;

	private void Update()
	{
		if (Input.GetMouseButton(0))
		{
			HandleInput();
		}
	}

	private void HandleInput()
	{
		if (Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out var hitInfo))
		{
			MeshDeformer component = hitInfo.collider.GetComponent<MeshDeformer>();
			if ((bool)component)
			{
				Vector3 point = hitInfo.point;
				point += hitInfo.normal * forceOffset;
				component.AddDeformingForce(point, force);
			}
		}
	}
}
public class PlaneMeshDeformer : MeshDeformer
{
	private bool direction;

	public override void AddDeformingForce(Vector3 point, float force, bool direction)
	{
		this.direction = direction;
		AddDeformingForce(point, force);
	}

	protected override void AddForceToVertex(int i, Vector3 point, float force)
	{
		if ((!lockXEdges || (originalVertices[i].x != -0.5f && originalVertices[i].x != 0.5f)) && (!lockYEdges || (originalVertices[i].y != -0.5f && originalVertices[i].y != 0.5f)) && (!lockZEdges || (originalVertices[i].z != -0.5f && originalVertices[i].z != 0.5f)))
		{
			Vector3 vector = originalVertices[i] - point;
			vector = new Vector3(vector.x * base.transform.localScale.x, vector.y * base.transform.localScale.y, vector.z * base.transform.localScale.z);
			float num = Mathf.Max(Mathf.Abs(force) - vector.magnitude, 0.2f);
			Vector3 vector2 = new Vector3(0f, 0f, (float)((!direction) ? 1 : (-1)) * num / base.transform.localScale.z);
			displacedVertices[i] = originalVertices[i] + vector2;
		}
	}
}
internal enum TriggerAxis
{
	X,
	Y,
	Z
}
public class Portal : MonoBehaviour
{
	[Tooltip("The \"From\" dimension for this portal.")]
	public Dimension dimension1;

	[Tooltip("The \"To\" dimension for this portal.")]
	public Dimension dimension2;

	public Dimension[] otherDimension2;

	[Tooltip("Increase this value to increase quality. Lower this value to increase performance. Default is 1.")]
	public float renderQuality = 1f;

	[Tooltip("The maximum distance at which the portal begins to deform away from the main camera to avoid clipping.")]
	public float maximumDeformRange = 1f;

	[Tooltip("The power with which the portal deforms away from the camera. If you see a flicker as you pass through, increase this variable.")]
	public float deformPower = 0.5f;

	[Tooltip("The portal deforms away from rigidbodies, but if you give them a tag and set it here, it will ignore them. This is really good for the Vive Controllers.")]
	public string ignoreRigidbodyTag;

	[Tooltip("This mask defines the parts of the scene that are visible in all dimensions. Always set the layers individually, don't use Everything.")]
	public LayerMask alwaysVisibleMask;

	[Tooltip("Oblique Projection clips the camera exactly to the portal rectangle. This is really good if you've got nearby objects. Unfortunately, it also screws with the skybox on Gear VR.")]
	public bool enableObliqueProjection;

	[TextArea]
	[Tooltip(" ")]
	public string Notes = "Hover over each variable to get tooltips with more information on what they do. Quick Tip: Don't set the visible mask to Everything. Select each option you want to be always visible.";

	private Camera mainCamera;

	private Camera rightCamera;

	private float minimumDeformRangeSquared;

	private bool isDeforming;

	private Renderer meshRenderer;

	private MeshFilter meshFilter;

	private MeshDeformer meshDeformer;

	private bool triggerZDirection;

	private List<PortalTransitionObject> transitionObjects = new List<PortalTransitionObject>();

	private Camera renderCam;

	private Skybox camSkybox;

	private RenderTexture leftTexture;

	private RenderTexture rightTexture;

	private float portalSwitchDistance = 0.03f;

	[HideInInspector]
	public bool playerPassedThroughPortal;

	[HideInInspector]
	public bool playerTeleportingThroughPortal;

	[HideInInspector]
	public bool portalEnabled;

	public bool dimensionSwitched { get; private set; }

	private void Awake()
	{
		UnityEngine.Debug.Log("This build is set up to run with Open VR (Rift / Gear VR). To enable another headset or run without VR please edit your settings in Window -> Portal State Manager.");
		Shader.SetGlobalInt("OpenVRRender", 1);
	}

	private void Start()
	{
		meshRenderer = GetComponent<Renderer>();
		meshFilter = GetComponent<MeshFilter>();
		meshDeformer = GetComponent<MeshDeformer>();
		OVRCameraRig oVRCameraRig = UnityEngine.Object.FindObjectOfType<OVRCameraRig>();
		mainCamera = oVRCameraRig.leftEyeCamera;
		rightCamera = oVRCameraRig.rightEyeCamera;
		base.gameObject.layer = FromDimension().layer;
		dimension1.connectedPortals.Add(this);
		dimension2.connectedPortals.Add(this);
		dimension1.showChildrenWithTag(ignoreRigidbodyTag);
		dimension2.showChildrenWithTag(ignoreRigidbodyTag);
		Dimension[] array = otherDimension2;
		foreach (Dimension obj in array)
		{
			obj.connectedPortals.Add(this);
			obj.showChildrenWithTag(ignoreRigidbodyTag);
		}
		minimumDeformRangeSquared = maximumDeformRange * maximumDeformRange;
		triggerZDirection = base.transform.InverseTransformPoint(mainCamera.transform.position).z > 0f;
		if (!mainCamera.GetComponent<MainCameraLayerManager>())
		{
			mainCamera.gameObject.AddComponent<MainCameraLayerManager>();
		}
	}

	private void OnDestroy()
	{
		if (renderCam != null)
		{
			UnityEngine.Object.Destroy(renderCam.gameObject);
			renderCam = null;
		}
		if (leftTexture != null)
		{
			UnityEngine.Object.Destroy(leftTexture);
		}
		if (rightTexture != null)
		{
			UnityEngine.Object.Destroy(rightTexture);
		}
	}

	public void SwitchDimensions()
	{
		Dimension[] array = otherDimension2;
		foreach (Dimension dimension in array)
		{
			DimensionChanger.SwitchCameraRender(mainCamera, FromDimension().layer, dimension.layer, dimension.customSkybox);
			DimensionChanger.SwitchDimensions(mainCamera.gameObject, FromDimension(), dimension);
		}
		DimensionChanger.SwitchCameraRender(mainCamera, FromDimension().layer, ToDimension().layer, ToDimension().customSkybox);
		DimensionChanger.SwitchDimensions(mainCamera.gameObject, FromDimension(), ToDimension());
		if (rightCamera != null)
		{
			DimensionChanger.SwitchCameraRender(rightCamera, FromDimension().layer, ToDimension().layer, ToDimension().customSkybox);
			DimensionChanger.SwitchDimensions(rightCamera.gameObject, FromDimension(), ToDimension());
			array = otherDimension2;
			foreach (Dimension dimension2 in array)
			{
				DimensionChanger.SwitchCameraRender(rightCamera, FromDimension().layer, dimension2.layer, dimension2.customSkybox);
				DimensionChanger.SwitchDimensions(rightCamera.gameObject, FromDimension(), dimension2);
			}
		}
		ToDimension().SwitchConnectingPortals();
		array = otherDimension2;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SwitchConnectingPortals();
		}
		playerPassedThroughPortal = true;
		GameController.instance.player.screenFX.Fade(UnityEngine.Color.black, 0f);
	}

	private void OnWillRenderObject()
	{
		if (!leftTexture)
		{
			Vector2 vector = new Vector2(mainCamera.pixelWidth, mainCamera.pixelHeight);
			leftTexture = new RenderTexture((int)(vector.x * renderQuality), (int)(vector.y * renderQuality), 16);
			rightTexture = new RenderTexture((int)(vector.x * renderQuality), (int)(vector.y * renderQuality), 16);
			renderCam = new GameObject(base.gameObject.name + " render camera", typeof(Camera), typeof(Skybox)).GetComponent<Camera>();
			SetupRenderCameraForAR();
			renderCam.name = base.gameObject.name + " render camera";
			renderCam.tag = "Untagged";
			if ((bool)renderCam.GetComponent<Skybox>())
			{
				camSkybox = renderCam.GetComponent<Skybox>();
			}
			else
			{
				renderCam.gameObject.AddComponent<Skybox>();
				camSkybox = renderCam.GetComponent<Skybox>();
			}
			renderCam.GetComponent<Camera>().ClearCameraComponents();
			renderCam.hideFlags = HideFlags.HideInHierarchy;
			renderCam.enabled = false;
		}
		if ((bool)ToDimension().customSkybox)
		{
			camSkybox.material = ToDimension().customSkybox;
		}
		if ((bool)meshRenderer)
		{
			meshRenderer.material.SetFloat("_RecursiveRender", (base.gameObject.layer != Camera.current.gameObject.layer) ? 1 : 0);
		}
	}

	private void SetupRenderCameraForAR()
	{
	}

	private void RenderPortal(Camera camera)
	{
		if (!enableObliqueProjection && (bool)meshRenderer)
		{
			Vector3 vector = base.transform.position - camera.transform.position;
			renderCam.nearClipPlane = Mathf.Max(vector.magnitude - meshRenderer.bounds.size.magnitude, 0.01f);
		}
		if (camera.stereoEnabled)
		{
			RenderOpenVR(camera);
		}
		else
		{
			RenderMono(camera);
		}
	}

	private void RenderSteamVR(Camera camera)
	{
	}

	private void RenderOpenVR(Camera camera)
	{
		Transform trackingSpace = UnityEngine.Object.FindObjectOfType<OVRCameraRig>().trackingSpace;
		Vector3 camPosition = trackingSpace.TransformPoint(InputTracking.GetLocalPosition(XRNode.LeftEye));
		Vector3 camPosition2 = trackingSpace.TransformPoint(InputTracking.GetLocalPosition(XRNode.RightEye));
		Quaternion camRotation = trackingSpace.transform.rotation * InputTracking.GetLocalRotation(XRNode.LeftEye);
		Quaternion camRotation2 = trackingSpace.transform.rotation * InputTracking.GetLocalRotation(XRNode.RightEye);
		RenderPlane(renderCam, leftTexture, camPosition, camRotation, camera.projectionMatrix);
		meshRenderer.material.SetTexture("_LeftTex", leftTexture);
		RenderPlane(renderCam, rightTexture, camPosition2, camRotation2, camera.projectionMatrix);
		meshRenderer.material.SetTexture("_RightTex", rightTexture);
	}

	private void RenderMono(Camera camera)
	{
		RenderTexture renderTexture = leftTexture;
		RenderPlane(renderCam, renderTexture, camera.transform.position, camera.transform.rotation, camera.projectionMatrix);
		if ((bool)meshRenderer)
		{
			meshRenderer.material.SetTexture("_LeftTex", renderTexture);
			meshRenderer.material.SetFloat("_RecursiveRender", 1f);
		}
	}

	protected void RenderPlane(Camera portalCamera, RenderTexture targetTexture, Vector3 camPosition, Quaternion camRotation, Matrix4x4 camProjectionMatrix)
	{
		portalCamera.transform.position = camPosition;
		portalCamera.transform.rotation = camRotation;
		portalCamera.targetTexture = targetTexture;
		portalCamera.ResetWorldToCameraMatrix();
		Vector3 position = base.transform.position;
		Vector3 forward = base.transform.forward;
		bool flag = base.transform.InverseTransformPoint(portalCamera.transform.position).z < 0f;
		Vector4 clipPlane = CameraSpacePlane(portalCamera, position, forward, flag ? 1f : (-1f));
		Matrix4x4 projection = camProjectionMatrix;
		if (enableObliqueProjection)
		{
			CalculateObliqueMatrix(ref projection, clipPlane);
		}
		portalCamera.projectionMatrix = projection;
		portalCamera.enabled = false;
		portalCamera.cullingMask = 0;
		portalCamera.LayerCullingShow(ToDimension().layer);
		portalCamera.LayerCullingShowMask(alwaysVisibleMask);
		portalCamera.farClipPlane = mainCamera.farClipPlane;
		portalCamera.nearClipPlane = mainCamera.nearClipPlane;
		portalCamera.orthographic = mainCamera.orthographic;
		portalCamera.fieldOfView = mainCamera.fieldOfView;
		portalCamera.aspect = mainCamera.aspect;
		portalCamera.orthographicSize = mainCamera.orthographicSize;
		portalCamera.Render();
		portalCamera.targetTexture = null;
	}

	private static void CalculateObliqueMatrix(ref Matrix4x4 projection, Vector4 clipPlane)
	{
		Vector4 b = projection.inverse * new Vector4(sgn(clipPlane.x), sgn(clipPlane.y), 1f, 1f);
		Vector4 vector = clipPlane * (2f / Vector4.Dot(clipPlane, b));
		projection[2] = vector.x - projection[3];
		projection[6] = vector.y - projection[7];
		projection[10] = vector.z - projection[11];
		projection[14] = vector.w - projection[15];
	}

	private Vector4 CameraSpacePlane(Camera cam, Vector3 pos, Vector3 normal, float sideSign)
	{
		Vector3 point = pos + normal * portalSwitchDistance * ((!triggerZDirection) ? 1 : (-1));
		Matrix4x4 worldToCameraMatrix = cam.worldToCameraMatrix;
		Vector3 lhs = worldToCameraMatrix.MultiplyPoint(point);
		Vector3 rhs = worldToCameraMatrix.MultiplyVector(normal).normalized * sideSign;
		return new Vector4(rhs.x, rhs.y, rhs.z, 0f - Vector3.Dot(lhs, rhs));
	}

	private static float sgn(float a)
	{
		if (a > 0f)
		{
			return 1f;
		}
		if (a < 0f)
		{
			return -1f;
		}
		return 0f;
	}

	private void Update()
	{
		if (mainCamera.gameObject.layer != FromDimension().layer)
		{
			return;
		}
		Vector3 size = meshFilter.mesh.bounds.size;
		if (Mathf.Pow(base.transform.InverseTransformDirection(mainCamera.transform.position - base.transform.position).z, 2f) <= minimumDeformRangeSquared && Mathf.Abs(base.transform.InverseTransformDirection(mainCamera.transform.position - base.transform.position).x) <= size.x * base.transform.lossyScale.x / 2f && Mathf.Abs(base.transform.InverseTransformDirection(mainCamera.transform.position - base.transform.position).y) <= size.y * base.transform.lossyScale.y / 2f && portalEnabled)
		{
			DeformPortalWithTransform(mainCamera.transform);
		}
		else if (isDeforming)
		{
			isDeforming = false;
			if ((bool)meshDeformer)
			{
				meshDeformer.ClearDeformingForce();
			}
		}
		CheckForTransitionObjects();
	}

	private void DeformPortalWithTransform(Transform otherTransform)
	{
		Vector3 vector = base.transform.InverseTransformPoint(otherTransform.position);
		if (vector.z > 0f != triggerZDirection && Mathf.Abs(vector.z) > portalSwitchDistance)
		{
			triggerZDirection = vector.z > 0f;
			if (isDeforming)
			{
				SwitchDimensions();
			}
		}
		if ((bool)meshDeformer)
		{
			meshDeformer.AddDeformingForce(otherTransform.position, deformPower, triggerZDirection);
		}
		isDeforming = true;
	}

	public void SwitchPortalDimensions()
	{
		dimensionSwitched = !dimensionSwitched;
		base.gameObject.layer = FromDimension().layer;
	}

	private void CheckForTransitionObjects()
	{
		Vector3 size = meshFilter.mesh.bounds.size;
		PortalTransitionObject[] array = UnityEngine.Object.FindObjectsOfType<PortalTransitionObject>();
		foreach (PortalTransitionObject portalTransitionObject in array)
		{
			if (Mathf.Pow(base.transform.InverseTransformDirection(portalTransitionObject.transform.position - base.transform.position).z, 2f) <= minimumDeformRangeSquared && Mathf.Abs(base.transform.InverseTransformDirection(portalTransitionObject.transform.position - base.transform.position).x) <= size.x * base.transform.lossyScale.x / 2f && Mathf.Abs(base.transform.InverseTransformDirection(portalTransitionObject.transform.position - base.transform.position).y) <= size.y * base.transform.lossyScale.y / 2f)
			{
				HandleTransition(portalTransitionObject);
			}
			else if (transitionObjects.Contains(portalTransitionObject))
			{
				transitionObjects.Remove(portalTransitionObject);
				if (transitionObjects.Count == 0 && !isDeforming && (bool)meshDeformer)
				{
					meshDeformer.ClearDeformingForce();
				}
			}
		}
	}

	private void HandleTransition(PortalTransitionObject transitionObject)
	{
		if (!transitionObjects.Contains(transitionObject) && transitionObject.gameObject.CameraForObject() != mainCamera && (ignoreRigidbodyTag == "" || !transitionObject.gameObject.CompareTag(ignoreRigidbodyTag)))
		{
			transitionObject.triggerZDirection = base.transform.InverseTransformPoint(transitionObject.transform.position).z > 0f;
			transitionObjects.Add(transitionObject);
		}
		Vector3 position = base.transform.InverseTransformPoint(transitionObject.transform.position);
		if (position.z > 0f != transitionObject.triggerZDirection)
		{
			if (transitionObject.gameObject.layer == FromDimension().layer)
			{
				DimensionChanger.SwitchDimensions(transitionObject.gameObject, FromDimension(), ToDimension());
			}
			else
			{
				DimensionChanger.SwitchDimensions(transitionObject.gameObject, ToDimension(), FromDimension());
			}
			transitionObject.triggerZDirection = !transitionObject.triggerZDirection;
		}
		if (!isDeforming)
		{
			Vector3 point = transitionObject.transform.position;
			if (Mathf.Abs(position.z) < maximumDeformRange)
			{
				position.z += (triggerZDirection ? maximumDeformRange : (0f - maximumDeformRange));
				point = base.transform.TransformPoint(position);
			}
			if ((bool)meshDeformer)
			{
				meshDeformer.AddDeformingForce(point, deformPower);
			}
		}
	}

	public Dimension ToDimension()
	{
		if (dimensionSwitched)
		{
			return dimension1;
		}
		return dimension2;
	}

	public Dimension FromDimension()
	{
		if (dimensionSwitched)
		{
			return dimension2;
		}
		return dimension1;
	}

	public void TeleportToOtherDimension()
	{
		StartCoroutine(TeleportToOtherDimensionRoutine());
	}

	private IEnumerator TeleportToOtherDimensionRoutine()
	{
		GameController.instance.player.screenFX.Fade(UnityEngine.Color.black, 0f);
		playerTeleportingThroughPortal = true;
		SwitchDimensions();
		yield return null;
	}
}
public class PortalTransitionObject : MonoBehaviour
{
	public bool triggerZDirection;
}
internal enum Direction
{
	Up,
	Down,
	West,
	East,
	North,
	South
}
public class SubdividedCube : MonoBehaviour
{
	private MeshFilter meshFilter;

	private Mesh mesh;

	private List<Vector3> verticies = new List<Vector3>();

	private List<int> triangles = new List<int>();

	private int squareCount;

	[Range(0f, 4f)]
	public int divisions;

	public void Awake()
	{
		RenderCube();
	}

	public Vector3[] GetCorners()
	{
		return new Vector3[5]
		{
			base.transform.TransformVector(new Vector3(-0.5f, 0.5f, 0f)),
			base.transform.TransformPoint(new Vector3(0.5f, 0.5f, 0f)),
			base.transform.TransformPoint(new Vector3(-0.5f, -0.5f, 0f)),
			base.transform.TransformPoint(new Vector3(0.5f, -0.5f, 0f)),
			base.transform.TransformPoint(new Vector3(0f, 0f, 0f))
		};
	}

	public void RenderCube()
	{
		if (meshFilter == null)
		{
			meshFilter = GetComponent<MeshFilter>();
			mesh = new Mesh();
		}
		float num = 1f / (float)(divisions + 1);
		for (int i = 0; i < divisions + 1; i++)
		{
			for (int j = 0; j < divisions + 1; j++)
			{
				for (int k = 0; k < 1; k++)
				{
					float x = (float)i * num - 0.5f;
					float y = (float)j * num - 0.5f;
					float z = (0f - num) / 2f;
					if (i == 0)
					{
						AddSquare(x, y, z, num, Direction.West);
					}
					if (i == divisions)
					{
						AddSquare(x, y, z, num, Direction.East);
					}
					if (j == 0)
					{
						AddSquare(x, y, z, num, Direction.Down);
					}
					if (j == divisions)
					{
						AddSquare(x, y, z, num, Direction.Up);
					}
					if (k == 0)
					{
						AddSquare(x, y, z, num, Direction.South);
					}
					if (k == 0)
					{
						AddSquare(x, y, z, num, Direction.North);
					}
				}
			}
		}
		UpdateMesh();
	}

	private void AddSquare(float x, float y, float z, float size, Direction direction)
	{
		switch (direction)
		{
		case Direction.Up:
		case Direction.Down:
			AddFaceForTopBottom(x, y, z, size, direction);
			break;
		case Direction.North:
		case Direction.South:
			AddFaceForNorthSouth(x, y, z, size, direction);
			break;
		case Direction.West:
		case Direction.East:
			AddFaceForWestEast(x, y, z, size, direction);
			break;
		}
		squareCount++;
	}

	private void AddFaceForTopBottom(float x, float y, float z, float size, Direction direction)
	{
		if (direction == Direction.Up)
		{
			y += size;
		}
		verticies.Add(new Vector3(x, y, z + size));
		verticies.Add(new Vector3(x + size, y, z + size));
		verticies.Add(new Vector3(x + size, y, z));
		verticies.Add(new Vector3(x, y, z));
		AddLatestTriangles(direction != Direction.Up);
	}

	private void AddFaceForWestEast(float x, float y, float z, float size, Direction direction)
	{
		if (direction == Direction.East)
		{
			x += size;
		}
		verticies.Add(new Vector3(x, y + size, z));
		verticies.Add(new Vector3(x, y + size, z + size));
		verticies.Add(new Vector3(x, y, z + size));
		verticies.Add(new Vector3(x, y, z));
		AddLatestTriangles(direction != Direction.East);
	}

	private void AddFaceForNorthSouth(float x, float y, float z, float size, Direction direction)
	{
		if (direction == Direction.North)
		{
			z += size;
		}
		verticies.Add(new Vector3(x, y + size, z));
		verticies.Add(new Vector3(x + size, y + size, z));
		verticies.Add(new Vector3(x + size, y, z));
		verticies.Add(new Vector3(x, y, z));
		AddLatestTriangles(direction != Direction.South);
	}

	private void AddLatestTriangles(bool clockwise)
	{
		if (clockwise)
		{
			triangles.Add(squareCount * 4);
			triangles.Add(squareCount * 4 + 1);
			triangles.Add(squareCount * 4 + 2);
			triangles.Add(squareCount * 4);
			triangles.Add(squareCount * 4 + 2);
			triangles.Add(squareCount * 4 + 3);
		}
		else
		{
			triangles.Add(squareCount * 4 + 2);
			triangles.Add(squareCount * 4 + 1);
			triangles.Add(squareCount * 4);
			triangles.Add(squareCount * 4 + 3);
			triangles.Add(squareCount * 4 + 2);
			triangles.Add(squareCount * 4);
		}
	}

	private void UpdateMesh()
	{
		mesh.Clear();
		mesh.vertices = verticies.ToArray();
		mesh.triangles = triangles.ToArray();
		mesh.RecalculateNormals();
		verticies.Clear();
		triangles.Clear();
		squareCount = 0;
		meshFilter.sharedMesh = mesh;
	}
}
public class PSVR_Controller : MonoBehaviour
{
	public enum TrackedDevicesType
	{
		DualShock4 = 1,
		Aim = 2,
		Move = 4,
		None = 0
	}

	public int handle = -1;

	public Vector3 position = Vector3.zero;

	public Quaternion orientation = Quaternion.Euler(0f, 180f, 0f);

	public TrackedDevicesType trackedDevicesType;

	public Texture2D PadTrackerCursorTexture;

	private GameObject trackerobject;

	private float handHeight;

	private void Start()
	{
		UnityEngine.Debug.LogError("Adding PSVR_Controller script");
		handHeight = PlayerPrefs.GetFloat("PlayerHeight") * 0.92f;
	}

	private void Update()
	{
	}
}
public class PSVRCameraRig : MonoBehaviour
{
	private void Awake()
	{
		SetHeight();
	}

	private void SetHeight()
	{
		PlayerPrefs.SetInt("Calibrated", 0);
		PlayerPrefs.SetFloat("PlayerHeight", 1.66f);
		if (PlayerPrefs.GetInt("Calibrated", 0) > 0)
		{
			float @float = PlayerPrefs.GetFloat("PlayerHeight");
			UnityEngine.Debug.LogError("SETTING PLAYER HEIGHT TO CALIBRATED: " + @float);
			Vector3 localPosition = base.gameObject.transform.localPosition;
			localPosition.y = @float;
			base.gameObject.transform.localPosition = localPosition;
		}
		else
		{
			Vector3 localPosition2 = base.gameObject.transform.localPosition;
			localPosition2.y = 1.66f;
			base.gameObject.transform.localPosition = localPosition2;
			UnityEngine.Debug.LogError("SETTING PLAYER HEIGHT TO DEFAULT 1.66m");
		}
	}

	private void Start()
	{
	}

	private void Update()
	{
	}
}
[ImageEffectAllowedInSceneView]
[ExecuteInEditMode]
public class NGSS_ContactShadows : MonoBehaviour
{
	public Light mainDirectionalLight;

	public Shader contactShadowsShader;

	[Header("SHADOWS SETTINGS")]
	public bool noiseFilter;

	[Range(0f, 3f)]
	public float shadowsSoftness = 1f;

	[Range(1f, 4f)]
	public float shadowsDistance = 2f;

	[Range(0.1f, 4f)]
	public float shadowsFade = 1f;

	[Range(0f, 2f)]
	public float shadowsOffset = 0.325f;

	[Range(0f, 1f)]
	public float rayWidth = 0.1f;

	[Range(16f, 128f)]
	public int raySamples = 64;

	private CommandBuffer blendShadowsCB;

	private CommandBuffer computeShadowsCB;

	private bool isInitialized;

	private Camera _mCamera;

	private Material _mMaterial;

	private Camera mCamera
	{
		get
		{
			if (_mCamera == null)
			{
				_mCamera = GetComponent<Camera>();
				if (_mCamera == null)
				{
					_mCamera = Camera.main;
				}
				if (_mCamera == null)
				{
					UnityEngine.Debug.LogError("NGSS Error: No MainCamera found, please provide one.", this);
				}
				else
				{
					_mCamera.depthTextureMode |= DepthTextureMode.Depth;
				}
			}
			return _mCamera;
		}
	}

	private Material mMaterial
	{
		get
		{
			if (_mMaterial == null)
			{
				if (contactShadowsShader == null)
				{
					Shader.Find("Hidden/NGSS_ContactShadows");
				}
				_mMaterial = new Material(contactShadowsShader);
				if (_mMaterial == null)
				{
					UnityEngine.Debug.LogWarning("NGSS Warning: can't find NGSS_ContactShadows shader, make sure it's on your project.", this);
					base.enabled = false;
					return null;
				}
			}
			return _mMaterial;
		}
	}

	private void AddCommandBuffers()
	{
		computeShadowsCB = new CommandBuffer
		{
			name = "NGSS ContactShadows: Compute"
		};
		blendShadowsCB = new CommandBuffer
		{
			name = "NGSS ContactShadows: Mix"
		};
		bool flag = mCamera.actualRenderingPath == RenderingPath.Forward;
		CommandBuffer[] commandBuffers;
		if ((bool)mCamera)
		{
			commandBuffers = mCamera.GetCommandBuffers(flag ? CameraEvent.AfterDepthTexture : CameraEvent.BeforeLighting);
			for (int i = 0; i < commandBuffers.Length; i++)
			{
				if (commandBuffers[i].name == computeShadowsCB.name)
				{
					return;
				}
			}
			mCamera.AddCommandBuffer(flag ? CameraEvent.AfterDepthTexture : CameraEvent.BeforeLighting, computeShadowsCB);
		}
		if (!mainDirectionalLight)
		{
			return;
		}
		commandBuffers = mainDirectionalLight.GetCommandBuffers(LightEvent.AfterScreenspaceMask);
		for (int i = 0; i < commandBuffers.Length; i++)
		{
			if (commandBuffers[i].name == blendShadowsCB.name)
			{
				return;
			}
		}
		mainDirectionalLight.AddCommandBuffer(LightEvent.AfterScreenspaceMask, blendShadowsCB);
	}

	private void RemoveCommandBuffers()
	{
		_mMaterial = null;
		bool flag = mCamera.actualRenderingPath == RenderingPath.Forward;
		if ((bool)mCamera)
		{
			mCamera.RemoveCommandBuffer(flag ? CameraEvent.AfterDepthTexture : CameraEvent.BeforeLighting, computeShadowsCB);
		}
		if ((bool)mainDirectionalLight)
		{
			mainDirectionalLight.RemoveCommandBuffer(LightEvent.AfterScreenspaceMask, blendShadowsCB);
		}
		isInitialized = false;
	}

	private void Init()
	{
		if (!isInitialized && !(mainDirectionalLight == null))
		{
			if (mCamera.renderingPath == RenderingPath.UsePlayerSettings || mCamera.renderingPath == RenderingPath.VertexLit)
			{
				UnityEngine.Debug.LogWarning("Please set your camera rendering path to either Forward or Deferred and re-enable this component.", this);
				base.enabled = false;
				return;
			}
			AddCommandBuffers();
			int num = Shader.PropertyToID("NGSS_ContactShadowRT");
			int num2 = Shader.PropertyToID("NGSS_DepthSourceRT");
			computeShadowsCB.GetTemporaryRT(num, -1, -1, 0, FilterMode.Bilinear, RenderTextureFormat.R8);
			computeShadowsCB.GetTemporaryRT(num2, -1, -1, 0, FilterMode.Point, RenderTextureFormat.RFloat);
			computeShadowsCB.Blit(num, num2, mMaterial, 0);
			computeShadowsCB.Blit(num2, num, mMaterial, 1);
			computeShadowsCB.Blit(num, num2, mMaterial, 2);
			blendShadowsCB.Blit(BuiltinRenderTextureType.CurrentActive, BuiltinRenderTextureType.CurrentActive, mMaterial, 3);
			computeShadowsCB.SetGlobalTexture("NGSS_ContactShadowsTexture", num2);
			isInitialized = true;
		}
	}

	private bool IsNotSupported()
	{
		if (SystemInfo.graphicsDeviceType != GraphicsDeviceType.Direct3D9 && SystemInfo.graphicsDeviceType != GraphicsDeviceType.OpenGLES2 && SystemInfo.graphicsDeviceType != GraphicsDeviceType.PlayStationMobile && SystemInfo.graphicsDeviceType != GraphicsDeviceType.PlayStationVita)
		{
			return SystemInfo.graphicsDeviceType == GraphicsDeviceType.N3DS;
		}
		return true;
	}

	private void OnEnable()
	{
		if (IsNotSupported())
		{
			UnityEngine.Debug.LogWarning("Unsupported graphics API, NGSS requires at least SM3.0 or higher and DX9 is not supported.", this);
			base.enabled = false;
		}
		else
		{
			Init();
		}
	}

	private void OnDisable()
	{
		if (isInitialized)
		{
			RemoveCommandBuffers();
		}
	}

	private void OnApplicationQuit()
	{
		if (isInitialized)
		{
			RemoveCommandBuffers();
		}
	}

	private void OnPreRender()
	{
		Init();
		if (isInitialized && !(mainDirectionalLight == null))
		{
			mMaterial.SetVector("LightDir", mCamera.transform.InverseTransformDirection(mainDirectionalLight.transform.forward));
			mMaterial.SetFloat("ShadowsOpacity", 1f - mainDirectionalLight.shadowStrength);
			mMaterial.SetFloat("ShadowsSoftness", shadowsSoftness);
			mMaterial.SetFloat("ShadowsDistance", shadowsDistance);
			mMaterial.SetFloat("ShadowsFade", shadowsFade);
			mMaterial.SetFloat("ShadowsBias", shadowsOffset * 0.02f);
			mMaterial.SetFloat("RayWidth", rayWidth);
			mMaterial.SetInt("RaySamples", raySamples);
			if (noiseFilter)
			{
				mMaterial.EnableKeyword("NGSS_CONTACT_SHADOWS_USE_NOISE");
			}
			else
			{
				mMaterial.DisableKeyword("NGSS_CONTACT_SHADOWS_USE_NOISE");
			}
		}
	}
}
[RequireComponent(typeof(Light))]
[ExecuteInEditMode]
public class NGSS_Directional : MonoBehaviour
{
	public enum SAMPLER_COUNT
	{
		SAMPLERS_16,
		SAMPLERS_25,
		SAMPLERS_32,
		SAMPLERS_64
	}

	[Header("MAIN SETTINGS")]
	[Tooltip("If false, NGSS Directional shadows replacement will be removed from Graphics settings when OnDisable is called in this component.")]
	public bool KEEP_NGSS_ONDISABLE = true;

	[Header("OPTIMIZATION")]
	[Tooltip("Optimize shadows performance by skipping fragments that are either 100% lit or 100% shadowed. Some macro noisy artefacts can be seen if shadows are too soft or sampling amount is below 64.")]
	public bool EARLY_BAILOUT_OPTIMIZATION = true;

	[Tooltip("Recommended values: Mobile = 16, Consoles = 25, Desktop VR = 32, Desktop High = 64")]
	public SAMPLER_COUNT SAMPLERS_COUNT = SAMPLER_COUNT.SAMPLERS_64;

	[Header("SOFTNESS")]
	[Tooltip("Overall softness for both PCF and PCSS shadows.")]
	[Range(0f, 2f)]
	public float GLOBAL_SOFTNESS = 1f;

	[Header("CASCADES")]
	[Tooltip("Blends cascades at seams intersection.\nAdditional overhead required for this option.")]
	public bool CASCADES_BLENDING = true;

	[Tooltip("Blends cascades at seams intersection.\nAdditional overhead required for this option.")]
	[Range(0f, 2f)]
	public float CASCADES_BLENDING_VALUE = 1f;

	[Header("NOISE")]
	[Tooltip("If disabled, noise will be computed normally.\nIf enabled, noise will be computed statically from an internal screen-space texture.")]
	public bool NOISE_STATIC;

	[Tooltip("Amount of noise. The higher the value the more Noise.")]
	[Range(0f, 2f)]
	public float NOISE_SCALE_VALUE = 1f;

	[Header("PCSS")]
	[Tooltip("PCSS Requires inline sampling and SM3.5, only available in Unity 2017.\nIt provides Area Light like soft-shadows.\nDisable it if you are looking for PCF filtering (uniform soft-shadows) which runs with SM3.0.")]
	public bool PCSS_ENABLED = true;

	[Tooltip("PCSS softness when shadows is close to caster.")]
	[Range(0f, 2f)]
	public float PCSS_SOFTNESS_MIN = 1f;

	[Tooltip("PCSS softness when shadows is far from caster.")]
	[Range(0f, 2f)]
	public float PCSS_SOFTNESS_MAX = 1f;

	private bool isInitialized;

	private bool isGraphicSet;

	private void OnDisable()
	{
		isInitialized = false;
		if (!KEEP_NGSS_ONDISABLE && isGraphicSet)
		{
			isGraphicSet = false;
			GraphicsSettings.SetCustomShader(BuiltinShaderType.ScreenSpaceShadows, Shader.Find("Hidden/Internal-ScreenSpaceShadows"));
			GraphicsSettings.SetShaderMode(BuiltinShaderType.ScreenSpaceShadows, BuiltinShaderMode.UseBuiltin);
		}
	}

	private void OnEnable()
	{
		if (IsNotSupported())
		{
			UnityEngine.Debug.LogWarning("Unsupported graphics API, NGSS requires at least SM3.0 or higher and DX9 is not supported.", this);
			base.enabled = false;
		}
		else
		{
			Init();
		}
	}

	private void Init()
	{
		if (!isInitialized)
		{
			if (!isGraphicSet)
			{
				GraphicsSettings.SetShaderMode(BuiltinShaderType.ScreenSpaceShadows, BuiltinShaderMode.UseCustom);
				GraphicsSettings.SetCustomShader(BuiltinShaderType.ScreenSpaceShadows, Shader.Find("Hidden/NGSS_Directional"));
				isGraphicSet = true;
			}
			isInitialized = true;
		}
	}

	private bool IsNotSupported()
	{
		if (SystemInfo.graphicsDeviceType != GraphicsDeviceType.Direct3D9 && SystemInfo.graphicsDeviceType != GraphicsDeviceType.OpenGLES2 && SystemInfo.graphicsDeviceType != GraphicsDeviceType.PlayStationMobile && SystemInfo.graphicsDeviceType != GraphicsDeviceType.PlayStationVita)
		{
			return SystemInfo.graphicsDeviceType == GraphicsDeviceType.N3DS;
		}
		return true;
	}

	private void Update()
	{
		if (NOISE_STATIC)
		{
			Shader.EnableKeyword("NGSS_NOISE_STATIC_DIR");
		}
		else
		{
			Shader.DisableKeyword("NGSS_NOISE_STATIC_DIR");
		}
		if (CASCADES_BLENDING && QualitySettings.shadowCascades > 1)
		{
			Shader.EnableKeyword("NGSS_USE_CASCADE_BLENDING");
			Shader.SetGlobalFloat("NGSS_CASCADE_BLEND_DISTANCE", CASCADES_BLENDING_VALUE * 0.125f);
		}
		else
		{
			Shader.DisableKeyword("NGSS_USE_CASCADE_BLENDING");
		}
		if (EARLY_BAILOUT_OPTIMIZATION)
		{
			Shader.EnableKeyword("NGSS_USE_EARLY_BAILOUT_OPTIMIZATION_DIR");
		}
		else
		{
			Shader.DisableKeyword("NGSS_USE_EARLY_BAILOUT_OPTIMIZATION_DIR");
		}
		Shader.SetGlobalFloat("NGSS_POISSON_SAMPLING_NOISE_DIR", NOISE_SCALE_VALUE / 0.01f);
		Shader.SetGlobalFloat("NGSS_STATIC_NOISE_MOBILE_VALUE", NOISE_SCALE_VALUE * 0.5f);
		Shader.SetGlobalFloat("NGSS_PCSS_GLOBAL_SOFTNESS", GLOBAL_SOFTNESS / (QualitySettings.shadowDistance * 0.66f));
		Shader.SetGlobalFloat("NGSS_PCSS_GLOBAL_SOFTNESS_MOBILE", 1f - GLOBAL_SOFTNESS * 75f / QualitySettings.shadowDistance);
		if (PCSS_ENABLED)
		{
			Shader.EnableKeyword("NGSS_PCSS_FILTER_DIR");
		}
		else
		{
			Shader.DisableKeyword("NGSS_PCSS_FILTER_DIR");
		}
		float num = PCSS_SOFTNESS_MIN * 0.05f;
		float num2 = PCSS_SOFTNESS_MAX * 0.25f;
		Shader.SetGlobalFloat("NGSS_PCSS_FILTER_DIR_MIN", (num > num2) ? num2 : num);
		Shader.SetGlobalFloat("NGSS_PCSS_FILTER_DIR_MAX", (num2 < num) ? num : num2);
		Shader.DisableKeyword("DIR_POISSON_64");
		Shader.DisableKeyword("DIR_POISSON_32");
		Shader.DisableKeyword("DIR_POISSON_25");
		Shader.DisableKeyword("DIR_POISSON_16");
		Shader.EnableKeyword((SAMPLERS_COUNT == SAMPLER_COUNT.SAMPLERS_64) ? "DIR_POISSON_64" : ((SAMPLERS_COUNT == SAMPLER_COUNT.SAMPLERS_32) ? "DIR_POISSON_32" : ((SAMPLERS_COUNT == SAMPLER_COUNT.SAMPLERS_25) ? "DIR_POISSON_25" : "DIR_POISSON_16")));
	}
}
[ExecuteInEditMode]
public class NGSS_NoiseTexture : MonoBehaviour
{
	public Texture noiseTex;

	[Range(0f, 1f)]
	public float noiseScale = 1f;

	private bool isTextureSet;

	private void Update()
	{
		Shader.SetGlobalFloat("NGSS_NOISE_TEXTURE_SCALE", noiseScale);
		if (!isTextureSet && !(noiseTex == null))
		{
			Shader.SetGlobalTexture("NGSS_NOISE_TEXTURE", noiseTex);
			isTextureSet = true;
		}
	}
}
public class RFX4_AudioCurves : MonoBehaviour
{
	public AnimationCurve AudioCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public bool IsLoop;

	private bool canUpdate;

	private float startTime;

	private AudioSource audioSource;

	private float startVolume;

	private void Awake()
	{
		audioSource = GetComponent<AudioSource>();
		startVolume = audioSource.volume;
		audioSource.volume = AudioCurve.Evaluate(0f);
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float volume = AudioCurve.Evaluate(num / GraphTimeMultiplier) * startVolume;
			audioSource.volume = volume;
		}
		if (num >= GraphTimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}
}
public class RFX4_LightCurves : MonoBehaviour
{
	public AnimationCurve LightCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public float GraphIntensityMultiplier = 1f;

	public bool IsLoop;

	[HideInInspector]
	public bool canUpdate;

	private float startTime;

	private Light lightSource;

	private void Awake()
	{
		lightSource = GetComponent<Light>();
		lightSource.intensity = LightCurve.Evaluate(0f);
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float intensity = LightCurve.Evaluate(num / GraphTimeMultiplier) * GraphIntensityMultiplier;
			lightSource.intensity = intensity;
		}
		if (num >= GraphTimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}
}
public class RFX4_PhysicsForceCurves : MonoBehaviour
{
	public float ForceRadius = 5f;

	public float ForceMultiplier = 1f;

	public AnimationCurve ForceCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public ForceMode ForceMode;

	public float GraphTimeMultiplier = 1f;

	public float GraphIntensityMultiplier = 1f;

	public bool IsLoop;

	public float DestoryDistance = -1f;

	public bool UseDistanceScale;

	public AnimationCurve DistanceScaleCurve = AnimationCurve.EaseInOut(1f, 1f, 1f, 1f);

	public bool UseUPVector;

	public AnimationCurve DragCurve = AnimationCurve.EaseInOut(0f, 0f, 0f, 1f);

	public float DragGraphTimeMultiplier = -1f;

	public float DragGraphIntensityMultiplier = -1f;

	public string AffectedName;

	[HideInInspector]
	public float forceAdditionalMultiplier = 1f;

	private bool canUpdate;

	private float startTime;

	private Transform t;

	private void Awake()
	{
		t = base.transform;
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
		forceAdditionalMultiplier = 1f;
	}

	private void FixedUpdate()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float num2 = ForceCurve.Evaluate(num / GraphTimeMultiplier) * GraphIntensityMultiplier;
			Collider[] array = Physics.OverlapSphere(t.position, ForceRadius);
			foreach (Collider collider in array)
			{
				Rigidbody component = collider.GetComponent<Rigidbody>();
				if (!(component == null) && (AffectedName.Length <= 0 || collider.name.Contains(AffectedName)))
				{
					Vector3 vector;
					float num3;
					if (UseUPVector)
					{
						vector = Vector3.up;
						num3 = 1f - Mathf.Clamp01(collider.transform.position.y - t.position.y);
						num3 *= 1f - (collider.transform.position - t.position).magnitude / ForceRadius;
					}
					else
					{
						vector = collider.transform.position - t.position;
						num3 = 1f - vector.magnitude / ForceRadius;
					}
					if (UseDistanceScale)
					{
						collider.transform.localScale = DistanceScaleCurve.Evaluate(num3) * collider.transform.localScale;
					}
					if (DestoryDistance > 0f && vector.magnitude < DestoryDistance)
					{
						UnityEngine.Object.Destroy(collider.gameObject);
					}
					component.AddForce(vector.normalized * num3 * ForceMultiplier * num2 * forceAdditionalMultiplier, ForceMode);
					if (DragGraphTimeMultiplier > 0f)
					{
						component.drag = DragCurve.Evaluate(num / DragGraphTimeMultiplier) * DragGraphIntensityMultiplier;
						component.angularDrag = component.drag / 10f;
					}
				}
			}
		}
		if (num >= GraphTimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}

	private void OnDrawGizmosSelected()
	{
		Gizmos.color = UnityEngine.Color.yellow;
		Gizmos.DrawWireSphere(base.transform.position, ForceRadius);
	}
}
public class RFX4_ScaleCurves : MonoBehaviour
{
	public AnimationCurve FloatCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public float GraphIntensityMultiplier = 1f;

	public bool IsLoop;

	private bool canUpdate;

	private float startTime;

	private Transform t;

	private int nameId;

	private Projector proj;

	private Vector3 startScale;

	private void Awake()
	{
		t = GetComponent<Transform>();
		startScale = t.localScale;
		t.localScale = Vector3.zero;
		proj = GetComponent<Projector>();
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
		t.localScale = Vector3.zero;
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float num2 = FloatCurve.Evaluate(num / GraphTimeMultiplier) * GraphIntensityMultiplier;
			t.localScale = num2 * startScale;
			if (proj != null)
			{
				proj.orthographicSize = num2;
			}
		}
		if (num >= GraphTimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}
}
public class RFX4_ShaderColorGradient : MonoBehaviour
{
	public RFX4_ShaderProperties ShaderColorProperty;

	public Gradient Color = new Gradient();

	public float TimeMultiplier = 1f;

	public bool IsLoop;

	public bool UseSharedMaterial;

	[HideInInspector]
	public float HUE = -1f;

	[HideInInspector]
	public bool canUpdate;

	private Material mat;

	private int propertyID;

	private float startTime;

	private UnityEngine.Color startColor;

	private bool isInitialized;

	private string shaderProperty;

	private void Start()
	{
		Init();
	}

	private void Init()
	{
		shaderProperty = ShaderColorProperty.ToString();
		startTime = Time.time;
		canUpdate = true;
		Renderer component = GetComponent<Renderer>();
		if (component == null)
		{
			Projector component2 = GetComponent<Projector>();
			if (component2 != null)
			{
				if (!component2.material.name.EndsWith("(Instance)"))
				{
					component2.material = new Material(component2.material)
					{
						name = component2.material.name + " (Instance)"
					};
				}
				mat = component2.material;
			}
		}
		else if (!UseSharedMaterial)
		{
			mat = component.material;
		}
		else
		{
			mat = component.sharedMaterial;
		}
		if (mat == null)
		{
			canUpdate = false;
			return;
		}
		if (!mat.HasProperty(shaderProperty))
		{
			canUpdate = false;
			return;
		}
		if (mat.HasProperty(shaderProperty))
		{
			propertyID = Shader.PropertyToID(shaderProperty);
		}
		startColor = mat.GetColor(propertyID);
		UnityEngine.Color color = Color.Evaluate(0f);
		mat.SetColor(propertyID, color * startColor);
		isInitialized = true;
	}

	private void OnEnable()
	{
		if (isInitialized)
		{
			startTime = Time.time;
			canUpdate = true;
		}
	}

	private void Update()
	{
		if (mat == null)
		{
			return;
		}
		float num = Time.time - startTime;
		if (canUpdate)
		{
			UnityEngine.Color color = Color.Evaluate(num / TimeMultiplier);
			if (HUE > -0.9f)
			{
				color = RFX4_ColorHelper.ConvertRGBColorByHUE(color, HUE);
				startColor = RFX4_ColorHelper.ConvertRGBColorByHUE(startColor, HUE);
			}
			mat.SetColor(propertyID, color * startColor);
		}
		if (num >= TimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}

	private void OnDisable()
	{
		if (!(mat == null))
		{
			if (UseSharedMaterial)
			{
				mat.SetColor(propertyID, startColor);
			}
			mat.SetColor(propertyID, startColor);
		}
	}
}
public class RFX4_ShaderFloatCurve : MonoBehaviour
{
	public RFX4_ShaderProperties ShaderFloatProperty = RFX4_ShaderProperties._Cutoff;

	public AnimationCurve FloatCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public float GraphIntensityMultiplier = 1f;

	public bool IsLoop;

	public bool UseSharedMaterial;

	private bool canUpdate;

	private float startTime;

	private Material mat;

	private float startFloat;

	private int propertyID;

	private string shaderProperty;

	private bool isInitialized;

	private void Awake()
	{
		Renderer component = GetComponent<Renderer>();
		if (component == null)
		{
			Projector component2 = GetComponent<Projector>();
			if (component2 != null)
			{
				if (!UseSharedMaterial)
				{
					if (!component2.material.name.EndsWith("(Instance)"))
					{
						component2.material = new Material(component2.material)
						{
							name = component2.material.name + " (Instance)"
						};
					}
					mat = component2.material;
				}
				else
				{
					mat = component2.material;
				}
			}
		}
		else if (!UseSharedMaterial)
		{
			mat = component.material;
		}
		else
		{
			mat = component.sharedMaterial;
		}
		shaderProperty = ShaderFloatProperty.ToString();
		if (mat.HasProperty(shaderProperty))
		{
			propertyID = Shader.PropertyToID(shaderProperty);
		}
		startFloat = mat.GetFloat(propertyID);
		float value = FloatCurve.Evaluate(0f) * GraphIntensityMultiplier;
		mat.SetFloat(propertyID, value);
		isInitialized = true;
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
		if (isInitialized)
		{
			float value = FloatCurve.Evaluate(0f) * GraphIntensityMultiplier;
			mat.SetFloat(propertyID, value);
		}
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float value = FloatCurve.Evaluate(num / GraphTimeMultiplier) * GraphIntensityMultiplier;
			mat.SetFloat(propertyID, value);
		}
		if (num >= GraphTimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}

	private void OnDisable()
	{
		if (UseSharedMaterial)
		{
			mat.SetFloat(propertyID, startFloat);
		}
	}

	private void OnDestroy()
	{
		if (!UseSharedMaterial)
		{
			if (mat != null)
			{
				UnityEngine.Object.DestroyImmediate(mat);
			}
			mat = null;
		}
	}
}
public enum RFX4_ShaderProperties
{
	_TintColor,
	_Cutoff,
	_Color,
	_EmissionColor,
	_MaskPow,
	_Cutout,
	_Speed,
	_BumpAmt
}
public class RFX4_WindCurves : MonoBehaviour
{
	public AnimationCurve WindCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public float GraphIntensityMultiplier = 1f;

	public bool IsLoop;

	private bool canUpdate;

	private float startTime;

	private WindZone windZone;

	private void Awake()
	{
		windZone = GetComponent<WindZone>();
		windZone.windMain = WindCurve.Evaluate(0f);
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float windMain = WindCurve.Evaluate(num / GraphTimeMultiplier) * GraphIntensityMultiplier;
			windZone.windMain = windMain;
		}
		if (num >= GraphTimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}
}
public class RFX4_EffectSettingColor : MonoBehaviour
{
	public UnityEngine.Color Color = UnityEngine.Color.red;

	private UnityEngine.Color previousColor;

	private void OnEnable()
	{
		UpdateColor();
	}

	private void Update()
	{
		if (previousColor != Color)
		{
			UpdateColor();
		}
	}

	private void UpdateColor()
	{
		RFX4_TransformMotion componentInChildren = GetComponentInChildren<RFX4_TransformMotion>(includeInactive: true);
		RFX4_RaycastCollision componentInChildren2 = GetComponentInChildren<RFX4_RaycastCollision>(includeInactive: true);
		float h = RFX4_ColorHelper.ColorToHSV(Color).H;
		RFX4_ColorHelper.ChangeObjectColorByHUE(base.gameObject, h);
		if (componentInChildren != null)
		{
			componentInChildren.HUE = h;
		}
		if (componentInChildren2 != null)
		{
			componentInChildren2.HUE = h;
		}
		previousColor = Color;
	}
}
public class RFX4_EffectSettingPhysxForce : MonoBehaviour
{
	public float ForceMultiplier = 1f;

	private void Start()
	{
	}

	private void Update()
	{
		RFX4_TransformMotion componentInChildren = GetComponentInChildren<RFX4_TransformMotion>(includeInactive: true);
		if (componentInChildren != null)
		{
			foreach (GameObject collidedInstance in componentInChildren.CollidedInstances)
			{
				RFX4_PhysicsForceCurves component = collidedInstance.GetComponent<RFX4_PhysicsForceCurves>();
				if (component != null)
				{
					component.forceAdditionalMultiplier = ForceMultiplier;
				}
			}
		}
		RFX4_PhysicsForceCurves[] componentsInChildren = GetComponentsInChildren<RFX4_PhysicsForceCurves>();
		foreach (RFX4_PhysicsForceCurves rFX4_PhysicsForceCurves in componentsInChildren)
		{
			if (rFX4_PhysicsForceCurves != null)
			{
				rFX4_PhysicsForceCurves.forceAdditionalMultiplier = ForceMultiplier;
			}
		}
	}
}
public class RFX4_EffectSettingProjectile : MonoBehaviour
{
	public float FlyDistanceForProjectiles = 30f;

	public float SpeedMultiplier = 1f;

	public LayerMask CollidesWith = -1;

	private float startSpeed;

	private const string particlesAdditionalName = "Distance";

	private void Awake()
	{
		RFX4_TransformMotion componentInChildren = GetComponentInChildren<RFX4_TransformMotion>(includeInactive: true);
		if (componentInChildren != null)
		{
			startSpeed = componentInChildren.Speed;
		}
	}

	private void OnEnable()
	{
		RFX4_TransformMotion componentInChildren = GetComponentInChildren<RFX4_TransformMotion>(includeInactive: true);
		if (componentInChildren != null)
		{
			componentInChildren.Distance = FlyDistanceForProjectiles;
			componentInChildren.CollidesWith = CollidesWith;
			componentInChildren.Speed = startSpeed * SpeedMultiplier;
		}
		RFX4_RaycastCollision componentInChildren2 = GetComponentInChildren<RFX4_RaycastCollision>(includeInactive: true);
		if (componentInChildren2 != null)
		{
			componentInChildren2.RaycastDistance = FlyDistanceForProjectiles;
		}
		ParticleSystem[] componentsInChildren = GetComponentsInChildren<ParticleSystem>();
		foreach (ParticleSystem particleSystem in componentsInChildren)
		{
			if (particleSystem.name.Contains("Distance"))
			{
				particleSystem.GetComponent<ParticleSystemRenderer>().lengthScale = FlyDistanceForProjectiles / particleSystem.main.startSize.constantMax;
			}
		}
	}
}
public class RFX4_EffectSettingVisible : MonoBehaviour
{
	public bool IsActive = true;

	public float FadeOutTime = 3f;

	private bool previousActiveStatus;

	private const string rendererAdditionalName = "Loop";

	private string[] colorProperties = new string[8] { "_TintColor", "_Color", "_EmissionColor", "_BorderColor", "_ReflectColor", "_RimColor", "_MainColor", "_CoreColor" };

	private float alpha;

	private void Start()
	{
	}

	private void Update()
	{
		if (IsActive)
		{
			alpha += Time.deltaTime;
		}
		else
		{
			alpha -= Time.deltaTime;
		}
		alpha = Mathf.Clamp01(alpha);
		if (!IsActive)
		{
			Renderer[] componentsInChildren = GetComponentsInChildren<Renderer>();
			foreach (Renderer renderer in componentsInChildren)
			{
				if (renderer.GetComponent<ParticleSystem>() != null || !renderer.name.Contains("Loop"))
				{
					continue;
				}
				Material material = renderer.material;
				RFX4_ShaderColorGradient component = renderer.GetComponent<RFX4_ShaderColorGradient>();
				if (component != null)
				{
					component.canUpdate = false;
				}
				string[] array = colorProperties;
				foreach (string text in array)
				{
					if (material.HasProperty(text))
					{
						UnityEngine.Color color = material.GetColor(text);
						color.a = alpha;
						material.SetColor(text, color);
					}
				}
			}
			Projector[] componentsInChildren2 = GetComponentsInChildren<Projector>();
			foreach (Projector projector in componentsInChildren2)
			{
				if (!projector.name.Contains("Loop"))
				{
					continue;
				}
				if (!projector.material.name.EndsWith("(Instance)"))
				{
					projector.material = new Material(projector.material)
					{
						name = projector.material.name + " (Instance)"
					};
				}
				Material material2 = projector.material;
				RFX4_ShaderColorGradient component2 = projector.GetComponent<RFX4_ShaderColorGradient>();
				if (component2 != null)
				{
					component2.canUpdate = false;
				}
				string[] array = colorProperties;
				foreach (string text2 in array)
				{
					if (material2.HasProperty(text2))
					{
						UnityEngine.Color color2 = material2.GetColor(text2);
						color2.a = alpha;
						material2.SetColor(text2, color2);
					}
				}
			}
			ParticleSystem[] componentsInChildren3 = GetComponentsInChildren<ParticleSystem>(includeInactive: true);
			foreach (ParticleSystem particleSystem in componentsInChildren3)
			{
				if (particleSystem != null)
				{
					particleSystem.Stop();
				}
			}
			Light[] componentsInChildren4 = GetComponentsInChildren<Light>(includeInactive: true);
			for (int k = 0; k < componentsInChildren4.Length; k++)
			{
				if (componentsInChildren4[k].isActiveAndEnabled)
				{
					RFX4_LightCurves component3 = componentsInChildren4[k].GetComponent<RFX4_LightCurves>();
					if (component3 != null)
					{
						componentsInChildren4[k].intensity = alpha * component3.GraphIntensityMultiplier;
						component3.canUpdate = false;
					}
					else
					{
						componentsInChildren4[k].intensity = alpha;
					}
				}
			}
		}
		if (IsActive && !previousActiveStatus)
		{
			Transform[] componentsInChildren5 = base.gameObject.GetComponentsInChildren<Transform>();
			foreach (Transform obj in componentsInChildren5)
			{
				obj.gameObject.SetActive(value: false);
				obj.gameObject.SetActive(value: true);
			}
		}
		previousActiveStatus = IsActive;
	}
}
public class RFX4_CollisionPropertyDeactiavtion : MonoBehaviour
{
	public float DeactivateTimeDelay = 1f;

	private float startTime;

	private WindZone windZone;

	private ParticleSystem ps;

	private ParticleSystem.CollisionModule collisionModule;

	private void Awake()
	{
		ps = GetComponent<ParticleSystem>();
		collisionModule = ps.collision;
	}

	private void OnEnable()
	{
		startTime = Time.time;
		collisionModule.enabled = true;
	}

	private void Update()
	{
		if (Time.time - startTime >= DeactivateTimeDelay)
		{
			collisionModule.enabled = false;
		}
	}
}
[RequireComponent(typeof(ParticleSystem))]
public class RFX4_ParticleCollisionHandler : MonoBehaviour
{
	public GameObject[] EffectsOnCollision;

	public float Offset;

	public float DestroyTimeDelay = 5f;

	public bool UseWorldSpacePosition;

	private ParticleSystem part;

	private List<ParticleCollisionEvent> collisionEvents = new List<ParticleCollisionEvent>();

	private ParticleSystem ps;

	private void Start()
	{
		part = GetComponent<ParticleSystem>();
	}

	private void OnParticleCollision(GameObject other)
	{
		int num = part.GetCollisionEvents(other, collisionEvents);
		for (int i = 0; i < num; i++)
		{
			GameObject[] effectsOnCollision = EffectsOnCollision;
			for (int j = 0; j < effectsOnCollision.Length; j++)
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(effectsOnCollision[j], collisionEvents[i].intersection + collisionEvents[i].normal * Offset, default(Quaternion));
				gameObject.transform.LookAt(collisionEvents[i].intersection + collisionEvents[i].normal);
				if (!UseWorldSpacePosition)
				{
					gameObject.transform.parent = base.transform;
				}
				UnityEngine.Object.Destroy(gameObject, DestroyTimeDelay);
			}
		}
	}
}
[RequireComponent(typeof(ParticleSystem))]
public class RFX4_ParticleLight : MonoBehaviour
{
	public float LightIntencityMultiplayer = 1f;

	public LightShadows Shadows;

	private ParticleSystem ps;

	private ParticleSystem.Particle[] particles;

	private Light[] lights;

	private int lightLimit = 20;

	private void Start()
	{
		ps = GetComponent<ParticleSystem>();
		ParticleSystem.MainModule main = ps.main;
		if (main.maxParticles > lightLimit)
		{
			main.maxParticles = lightLimit;
		}
		particles = new ParticleSystem.Particle[main.maxParticles];
		lights = new Light[main.maxParticles];
		for (int i = 0; i < lights.Length; i++)
		{
			GameObject gameObject = new GameObject();
			lights[i] = gameObject.AddComponent<Light>();
			lights[i].transform.parent = base.transform;
			lights[i].intensity = 0f;
			lights[i].shadows = Shadows;
		}
	}

	private void Update()
	{
		int num = ps.GetParticles(particles);
		for (int i = 0; i < num; i++)
		{
			lights[i].gameObject.SetActive(value: true);
			lights[i].transform.position = particles[i].position;
			lights[i].color = particles[i].GetCurrentColor(ps);
			lights[i].range = particles[i].GetCurrentSize(ps);
			lights[i].intensity = (float)(int)particles[i].GetCurrentColor(ps).a / 255f * LightIntencityMultiplayer;
		}
		for (int j = num; j < particles.Length; j++)
		{
			lights[j].gameObject.SetActive(value: false);
		}
	}
}
[RequireComponent(typeof(ParticleSystem))]
public class RFX4_ParticleTrail : MonoBehaviour
{
	public GameObject Target;

	public Vector2 DefaultSizeMultiplayer = Vector2.one;

	public float VertexLifeTime = 2f;

	public float TrailLifeTime = 2f;

	public bool UseShaderMaterial;

	public Material TrailMaterial;

	public bool UseColorOverLifeTime;

	public Gradient ColorOverLifeTime = new Gradient();

	public float ColorLifeTime = 1f;

	public bool UseUvAnimation;

	public int TilesX = 4;

	public int TilesY = 4;

	public int FPS = 30;

	public bool IsLoop = true;

	[Range(0.001f, 1f)]
	public float MinVertexDistance = 0.01f;

	public bool GetVelocityFromParticleSystem;

	public float Gravity = 0.01f;

	public Vector3 Force = new Vector3(0f, 0.01f, 0f);

	public float InheritVelocity;

	public float Drag = 0.01f;

	[Range(0.001f, 10f)]
	public float Frequency = 1f;

	[Range(0.001f, 10f)]
	public float OffsetSpeed = 0.5f;

	public bool RandomTurbulenceOffset;

	[Range(0.001f, 10f)]
	public float Amplitude = 2f;

	public float TurbulenceStrength = 0.1f;

	public AnimationCurve VelocityByDistance = AnimationCurve.EaseInOut(0f, 1f, 1f, 1f);

	public float AproximatedFlyDistance = -1f;

	public bool SmoothCurves = true;

	private Dictionary<int, LineRenderer> dict = new Dictionary<int, LineRenderer>();

	private ParticleSystem ps;

	private ParticleSystem.Particle[] particles;

	private TrailRenderer[] trails;

	private UnityEngine.Color psColor;

	private Transform targetT;

	private int layer;

	private bool isLocalSpace = true;

	private Transform t;

	private void OnEnable()
	{
		if (Target != null)
		{
			targetT = Target.transform;
		}
		ps = GetComponent<ParticleSystem>();
		t = base.transform;
		isLocalSpace = ps.main.simulationSpace == ParticleSystemSimulationSpace.Local;
		particles = new ParticleSystem.Particle[ps.main.maxParticles];
		if (TrailMaterial != null)
		{
			psColor = TrailMaterial.GetColor(TrailMaterial.HasProperty("_TintColor") ? "_TintColor" : "_Color");
		}
		layer = base.gameObject.layer;
		Update();
	}

	private void ClearTrails()
	{
		TrailRenderer[] array = trails;
		foreach (TrailRenderer trailRenderer in array)
		{
			if (trailRenderer != null)
			{
				UnityEngine.Object.Destroy(trailRenderer.gameObject);
			}
		}
		trails = null;
	}

	private void Update()
	{
		if (dict.Count > 10)
		{
			RemoveEmptyTrails();
		}
		int num = ps.GetParticles(particles);
		for (int i = 0; i < num; i++)
		{
			int hashCode = particles[i].rotation3D.GetHashCode();
			if (!dict.ContainsKey(hashCode))
			{
				GameObject gameObject = new GameObject(hashCode.ToString());
				gameObject.transform.parent = base.transform;
				gameObject.transform.position = ps.transform.position;
				if (TrailLifeTime > 1E-05f)
				{
					UnityEngine.Object.Destroy(gameObject, TrailLifeTime + VertexLifeTime);
				}
				gameObject.layer = layer;
				LineRenderer lineRenderer = gameObject.AddComponent<LineRenderer>();
				lineRenderer.startWidth = 0f;
				lineRenderer.endWidth = 0f;
				lineRenderer.sharedMaterial = TrailMaterial;
				lineRenderer.useWorldSpace = false;
				if (UseColorOverLifeTime)
				{
					RFX4_ShaderColorGradient rFX4_ShaderColorGradient = gameObject.AddComponent<RFX4_ShaderColorGradient>();
					rFX4_ShaderColorGradient.Color = ColorOverLifeTime;
					rFX4_ShaderColorGradient.TimeMultiplier = ColorLifeTime;
				}
				if (UseUvAnimation)
				{
					RFX4_UVAnimation rFX4_UVAnimation = gameObject.AddComponent<RFX4_UVAnimation>();
					rFX4_UVAnimation.TilesX = TilesX;
					rFX4_UVAnimation.TilesY = TilesY;
					rFX4_UVAnimation.FPS = FPS;
					rFX4_UVAnimation.IsLoop = IsLoop;
				}
				dict.Add(hashCode, lineRenderer);
				continue;
			}
			LineRenderer lineRenderer2 = dict[hashCode];
			if (!(lineRenderer2 == null))
			{
				if (!lineRenderer2.useWorldSpace)
				{
					lineRenderer2.useWorldSpace = true;
					InitTrailRenderer(lineRenderer2.gameObject);
				}
				Vector2 vector = DefaultSizeMultiplayer * particles[i].GetCurrentSize(ps);
				lineRenderer2.startWidth = vector.y;
				lineRenderer2.endWidth = vector.x;
				if (Target != null)
				{
					float num2 = 1f - particles[i].remainingLifetime / particles[i].startLifetime;
					Vector3 a = Vector3.Lerp(particles[i].position, targetT.position, num2);
					lineRenderer2.transform.position = Vector3.Lerp(a, targetT.position, Time.deltaTime * num2);
				}
				else
				{
					lineRenderer2.transform.position = (isLocalSpace ? ps.transform.TransformPoint(particles[i].position) : particles[i].position);
				}
				lineRenderer2.transform.rotation = t.rotation;
				Color32 currentColor = particles[i].GetCurrentColor(ps);
				UnityEngine.Color endColor = (lineRenderer2.startColor = psColor * currentColor);
				lineRenderer2.endColor = endColor;
			}
		}
		ps.SetParticles(particles, num);
	}

	private void InitTrailRenderer(GameObject go)
	{
		RFX4_TrailRenderer rFX4_TrailRenderer = go.AddComponent<RFX4_TrailRenderer>();
		rFX4_TrailRenderer.Amplitude = Amplitude;
		rFX4_TrailRenderer.Drag = Drag;
		rFX4_TrailRenderer.Gravity = Gravity;
		rFX4_TrailRenderer.Force = Force;
		rFX4_TrailRenderer.Frequency = Frequency;
		rFX4_TrailRenderer.InheritVelocity = InheritVelocity;
		rFX4_TrailRenderer.VertexLifeTime = VertexLifeTime;
		rFX4_TrailRenderer.TrailLifeTime = TrailLifeTime;
		rFX4_TrailRenderer.MinVertexDistance = MinVertexDistance;
		rFX4_TrailRenderer.OffsetSpeed = OffsetSpeed;
		rFX4_TrailRenderer.SmoothCurves = SmoothCurves;
		rFX4_TrailRenderer.AproximatedFlyDistance = AproximatedFlyDistance;
		rFX4_TrailRenderer.VelocityByDistance = VelocityByDistance;
		rFX4_TrailRenderer.RandomTurbulenceOffset = RandomTurbulenceOffset;
		rFX4_TrailRenderer.TurbulenceStrength = TurbulenceStrength;
	}

	private void RemoveEmptyTrails()
	{
		for (int i = 0; i < dict.Count; i++)
		{
			KeyValuePair<int, LineRenderer> keyValuePair = dict.ElementAt(i);
			if (keyValuePair.Value == null)
			{
				dict.Remove(keyValuePair.Key);
			}
		}
	}

	private void OnDisable()
	{
		foreach (KeyValuePair<int, LineRenderer> item in dict)
		{
			if (item.Value != null)
			{
				UnityEngine.Object.Destroy(item.Value.gameObject);
			}
		}
		dict.Clear();
	}
}
[ExecuteInEditMode]
[RequireComponent(typeof(ParticleSystem))]
public class RFX4_Turbulence : MonoBehaviour
{
	public enum MoveMethodEnum
	{
		Position,
		Velocity,
		RelativePosition
	}

	public enum PerfomanceEnum
	{
		High,
		Low
	}

	public float TurbulenceStrenght = 1f;

	public bool TurbulenceByTime;

	public float TimeDelay;

	public AnimationCurve TurbulenceStrengthByTime = AnimationCurve.EaseInOut(1f, 1f, 1f, 1f);

	public Vector3 Frequency = new Vector3(1f, 1f, 1f);

	public Vector3 OffsetSpeed = new Vector3(0.5f, 0.5f, 0.5f);

	public Vector3 Amplitude = new Vector3(5f, 5f, 5f);

	public Vector3 GlobalForce;

	public bool UseGlobalOffset = true;

	public MoveMethodEnum MoveMethod;

	public PerfomanceEnum Perfomance;

	public float ThreshholdSpeed;

	public AnimationCurve VelocityByDistance = AnimationCurve.EaseInOut(0f, 1f, 1f, 1f);

	public float AproximatedFlyDistance = -1f;

	private float lastStopTime;

	private Vector3 currentOffset;

	private float deltaTime;

	private float deltaTimeLastUpdateOffset;

	private ParticleSystem.Particle[] particleArray;

	private ParticleSystem particleSys;

	private float time;

	private int currentSplit;

	private float fpsTime;

	private int FPS;

	private int splitUpdate = 2;

	private PerfomanceEnum perfomanceOldSettings;

	private bool skipFrame;

	private Transform t;

	private float currentDelay;

	private void Start()
	{
		t = base.transform;
		particleSys = GetComponent<ParticleSystem>();
		if (particleArray == null || particleArray.Length < particleSys.main.maxParticles)
		{
			particleArray = new ParticleSystem.Particle[particleSys.main.maxParticles];
		}
		perfomanceOldSettings = Perfomance;
		UpdatePerfomanceSettings();
	}

	private void OnEnable()
	{
		currentDelay = 0f;
	}

	private void Update()
	{
		if (!Application.isPlaying)
		{
			deltaTime = Time.realtimeSinceStartup - lastStopTime;
			lastStopTime = Time.realtimeSinceStartup;
		}
		else
		{
			deltaTime = Time.deltaTime;
		}
		currentDelay += deltaTime;
		if (currentDelay < TimeDelay)
		{
			return;
		}
		if (!UseGlobalOffset)
		{
			currentOffset += OffsetSpeed * deltaTime;
		}
		else if (Application.isPlaying)
		{
			currentOffset = OffsetSpeed * Time.time;
		}
		else
		{
			currentOffset = OffsetSpeed * Time.realtimeSinceStartup;
		}
		if (Perfomance != perfomanceOldSettings)
		{
			perfomanceOldSettings = Perfomance;
			UpdatePerfomanceSettings();
		}
		time += deltaTime;
		if (QualitySettings.vSyncCount == 2)
		{
			UpdateTurbulence();
		}
		else if (QualitySettings.vSyncCount == 1)
		{
			if (Perfomance == PerfomanceEnum.Low)
			{
				if (skipFrame)
				{
					UpdateTurbulence();
				}
				skipFrame = !skipFrame;
			}
			if (Perfomance == PerfomanceEnum.High)
			{
				UpdateTurbulence();
			}
		}
		else if (QualitySettings.vSyncCount == 0)
		{
			if (time >= fpsTime)
			{
				time = 0f;
				UpdateTurbulence();
				deltaTimeLastUpdateOffset = 0f;
			}
			else
			{
				deltaTimeLastUpdateOffset += deltaTime;
			}
		}
	}

	private void UpdatePerfomanceSettings()
	{
		if (Perfomance == PerfomanceEnum.High)
		{
			FPS = 80;
			splitUpdate = 2;
		}
		if (Perfomance == PerfomanceEnum.Low)
		{
			FPS = 40;
			splitUpdate = 2;
		}
		fpsTime = 1f / (float)FPS;
	}

	private void UpdateTurbulence()
	{
		int particles = particleSys.GetParticles(particleArray);
		int num = 1;
		int num2;
		int num3;
		if (splitUpdate > 1)
		{
			num2 = particles / splitUpdate * currentSplit;
			num3 = Mathf.CeilToInt((float)particles * 1f / (float)splitUpdate * ((float)currentSplit + 1f));
			num = splitUpdate;
		}
		else
		{
			num2 = 0;
			num3 = particles;
		}
		for (int i = num2; i < num3; i++)
		{
			ParticleSystem.Particle particle = particleArray[i];
			float num4 = 1f;
			if (TurbulenceByTime)
			{
				num4 = TurbulenceStrengthByTime.Evaluate(1f - particle.remainingLifetime / particle.startLifetime);
			}
			if (ThreshholdSpeed > 1E-07f && num4 < ThreshholdSpeed)
			{
				return;
			}
			Vector3 position = particle.position;
			position.x /= Frequency.x + 1E-07f;
			position.y /= Frequency.y + 1E-07f;
			position.z /= Frequency.z + 1E-07f;
			Vector3 vector = default(Vector3);
			float num5 = deltaTime + deltaTimeLastUpdateOffset;
			vector.x = (Mathf.PerlinNoise(position.z - currentOffset.z, position.y - currentOffset.y) * 2f - 1f) * Amplitude.x * num5;
			vector.y = (Mathf.PerlinNoise(position.x - currentOffset.x, position.z - currentOffset.z) * 2f - 1f) * Amplitude.y * num5;
			vector.z = (Mathf.PerlinNoise(position.y - currentOffset.y, position.x - currentOffset.x) * 2f - 1f) * Amplitude.z * num5;
			float num6 = TurbulenceStrenght * num4 * (float)num;
			float num7 = 1f;
			float num8 = Mathf.Abs((particle.position - t.position).magnitude);
			if (AproximatedFlyDistance > 0f)
			{
				num7 = VelocityByDistance.Evaluate(Mathf.Clamp01(num8 / AproximatedFlyDistance));
			}
			vector *= num6;
			if (MoveMethod == MoveMethodEnum.Position)
			{
				particleArray[i].position += vector * num7;
			}
			if (MoveMethod == MoveMethodEnum.Velocity)
			{
				particleArray[i].velocity += vector * num7;
			}
			if (MoveMethod == MoveMethodEnum.RelativePosition)
			{
				particleArray[i].position += vector * particleArray[i].velocity.magnitude;
				particleArray[i].velocity = particleArray[i].velocity * 0.85f + vector.normalized * 0.15f * num7 + GlobalForce * num7;
			}
		}
		particleSys.SetParticles(particleArray, particles);
		currentSplit++;
		if (currentSplit >= splitUpdate)
		{
			currentSplit = 0;
		}
	}
}
public class RFX4_CameraShake : MonoBehaviour
{
	public AnimationCurve ShakeCurve = AnimationCurve.EaseInOut(0f, 1f, 1f, 0f);

	public float Duration = 2f;

	public float Speed = 22f;

	public float Magnitude = 1f;

	public float DistanceForce = 100f;

	public float RotationDamper = 2f;

	public bool IsEnabled = true;

	private bool isPlaying;

	[HideInInspector]
	public bool canUpdate;

	private void PlayShake()
	{
		StopAllCoroutines();
		StartCoroutine(Shake());
	}

	private void Update()
	{
		if (isPlaying && IsEnabled)
		{
			isPlaying = false;
			PlayShake();
		}
	}

	private void OnEnable()
	{
		isPlaying = true;
		if (UnityEngine.Object.FindObjectsOfType(typeof(RFX4_CameraShake)) is RFX4_CameraShake[] array)
		{
			RFX4_CameraShake[] array2 = array;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i].canUpdate = false;
			}
		}
		canUpdate = true;
	}

	private IEnumerator Shake()
	{
		float elapsed = 0f;
		Transform camT = Camera.main.transform;
		Vector3 originalCamRotation = camT.rotation.eulerAngles;
		Vector3 direction = (base.transform.position - camT.position).normalized;
		float time = 0f;
		float randomStart = UnityEngine.Random.Range(-1000f, 1000f);
		float distanceDamper = 1f - Mathf.Clamp01((camT.position - base.transform.position).magnitude / DistanceForce);
		Vector3 oldRotation = Vector3.zero;
		while (elapsed < Duration && canUpdate)
		{
			elapsed += Time.deltaTime;
			float num = elapsed / Duration;
			float num2 = ShakeCurve.Evaluate(num) * distanceDamper;
			time += Time.deltaTime * num2;
			camT.position -= direction * Time.deltaTime * Mathf.Sin(time * Speed) * num2 * Magnitude / 2f;
			float num3 = randomStart + Speed * num / 10f;
			float num4 = Mathf.PerlinNoise(num3, 0f) * 2f - 1f;
			float num5 = Mathf.PerlinNoise(1000f + num3, num3 + 1000f) * 2f - 1f;
			float num6 = Mathf.PerlinNoise(0f, num3) * 2f - 1f;
			if (Quaternion.Euler(originalCamRotation + oldRotation) != camT.rotation)
			{
				originalCamRotation = camT.rotation.eulerAngles;
			}
			oldRotation = Mathf.Sin(time * Speed) * num2 * Magnitude * new Vector3(0.5f + num5, 0.3f + num4, 0.3f + num6) * RotationDamper;
			camT.rotation = Quaternion.Euler(originalCamRotation + oldRotation);
			yield return null;
		}
	}
}
public static class RFX4_ColorHelper
{
	public struct HSBColor
	{
		public float H;

		public float S;

		public float B;

		public float A;

		public HSBColor(float h, float s, float b, float a)
		{
			H = h;
			S = s;
			B = b;
			A = a;
		}
	}

	private const float TOLERANCE = 0.0001f;

	private static string[] colorProperties = new string[8] { "_TintColor", "_Color", "_EmissionColor", "_BorderColor", "_ReflectColor", "_RimColor", "_MainColor", "_CoreColor" };

	public static HSBColor ColorToHSV(UnityEngine.Color color)
	{
		HSBColor result = new HSBColor(0f, 0f, 0f, color.a);
		float r = color.r;
		float g = color.g;
		float b = color.b;
		float num = Mathf.Max(r, Mathf.Max(g, b));
		if (num <= 0f)
		{
			return result;
		}
		float num2 = Mathf.Min(r, Mathf.Min(g, b));
		float num3 = num - num2;
		if (num > num2)
		{
			if (Math.Abs(g - num) < 0.0001f)
			{
				result.H = (b - r) / num3 * 60f + 120f;
			}
			else if (Math.Abs(b - num) < 0.0001f)
			{
				result.H = (r - g) / num3 * 60f + 240f;
			}
			else if (b > g)
			{
				result.H = (g - b) / num3 * 60f + 360f;
			}
			else
			{
				result.H = (g - b) / num3 * 60f;
			}
			if (result.H < 0f)
			{
				result.H += 360f;
			}
		}
		else
		{
			result.H = 0f;
		}
		result.H *= 0.0027777778f;
		result.S = num3 / num * 1f;
		result.B = num;
		return result;
	}

	public static UnityEngine.Color HSVToColor(HSBColor hsbColor)
	{
		float value = hsbColor.B;
		float value2 = hsbColor.B;
		float value3 = hsbColor.B;
		if (Math.Abs(hsbColor.S) > 0.0001f)
		{
			float b = hsbColor.B;
			float num = hsbColor.B * hsbColor.S;
			float num2 = hsbColor.B - num;
			float num3 = hsbColor.H * 360f;
			if (num3 < 60f)
			{
				value = b;
				value2 = num3 * num / 60f + num2;
				value3 = num2;
			}
			else if (num3 < 120f)
			{
				value = (0f - (num3 - 120f)) * num / 60f + num2;
				value2 = b;
				value3 = num2;
			}
			else if (num3 < 180f)
			{
				value = num2;
				value2 = b;
				value3 = (num3 - 120f) * num / 60f + num2;
			}
			else if (num3 < 240f)
			{
				value = num2;
				value2 = (0f - (num3 - 240f)) * num / 60f + num2;
				value3 = b;
			}
			else if (num3 < 300f)
			{
				value = (num3 - 240f) * num / 60f + num2;
				value2 = num2;
				value3 = b;
			}
			else if (num3 <= 360f)
			{
				value = b;
				value2 = num2;
				value3 = (0f - (num3 - 360f)) * num / 60f + num2;
			}
			else
			{
				value = 0f;
				value2 = 0f;
				value3 = 0f;
			}
		}
		return new UnityEngine.Color(Mathf.Clamp01(value), Mathf.Clamp01(value2), Mathf.Clamp01(value3), hsbColor.A);
	}

	public static UnityEngine.Color ConvertRGBColorByHUE(UnityEngine.Color rgbColor, float hue)
	{
		float num = ColorToHSV(rgbColor).B;
		if (num < 0.0001f)
		{
			num = 0.0001f;
		}
		HSBColor hsbColor = ColorToHSV(rgbColor / num);
		hsbColor.H = hue;
		UnityEngine.Color result = HSVToColor(hsbColor) * num;
		result.a = rgbColor.a;
		return result;
	}

	public static void ChangeObjectColorByHUE(GameObject go, float hue)
	{
		Renderer[] componentsInChildren = go.GetComponentsInChildren<Renderer>(includeInactive: true);
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			Material material = componentsInChildren[i].material;
			if (material == null)
			{
				continue;
			}
			string[] array = colorProperties;
			foreach (string name in array)
			{
				if (material.HasProperty(name))
				{
					setMatHUEColor(material, name, hue);
				}
			}
		}
		SkinnedMeshRenderer[] componentsInChildren2 = go.GetComponentsInChildren<SkinnedMeshRenderer>(includeInactive: true);
		for (int i = 0; i < componentsInChildren2.Length; i++)
		{
			Material material2 = componentsInChildren2[i].material;
			if (material2 == null)
			{
				continue;
			}
			string[] array = colorProperties;
			foreach (string name2 in array)
			{
				if (material2.HasProperty(name2))
				{
					setMatHUEColor(material2, name2, hue);
				}
			}
		}
		Projector[] componentsInChildren3 = go.GetComponentsInChildren<Projector>(includeInactive: true);
		foreach (Projector projector in componentsInChildren3)
		{
			if (!projector.material.name.EndsWith("(Instance)"))
			{
				projector.material = new Material(projector.material)
				{
					name = projector.material.name + " (Instance)"
				};
			}
			Material material3 = projector.material;
			if (material3 == null)
			{
				continue;
			}
			string[] array = colorProperties;
			foreach (string name3 in array)
			{
				if (material3.HasProperty(name3))
				{
					projector.material = setMatHUEColor(material3, name3, hue);
				}
			}
		}
		Light[] componentsInChildren4 = go.GetComponentsInChildren<Light>(includeInactive: true);
		foreach (Light obj in componentsInChildren4)
		{
			HSBColor hsbColor = ColorToHSV(obj.color);
			hsbColor.H = hue;
			obj.color = HSVToColor(hsbColor);
		}
		ParticleSystem[] componentsInChildren5 = go.GetComponentsInChildren<ParticleSystem>(includeInactive: true);
		foreach (ParticleSystem obj2 in componentsInChildren5)
		{
			ParticleSystem.MainModule main = obj2.main;
			HSBColor hsbColor2 = ColorToHSV(obj2.main.startColor.color);
			hsbColor2.H = hue;
			main.startColor = HSVToColor(hsbColor2);
		}
		RFX4_ParticleTrail[] componentsInChildren6 = go.GetComponentsInChildren<RFX4_ParticleTrail>(includeInactive: true);
		foreach (RFX4_ParticleTrail rFX4_ParticleTrail in componentsInChildren6)
		{
			Material trailMaterial = rFX4_ParticleTrail.TrailMaterial;
			if (trailMaterial == null)
			{
				continue;
			}
			trailMaterial = (rFX4_ParticleTrail.TrailMaterial = new Material(rFX4_ParticleTrail.TrailMaterial));
			string[] array = colorProperties;
			foreach (string name4 in array)
			{
				if (trailMaterial.HasProperty(name4))
				{
					setMatHUEColor(trailMaterial, name4, hue);
				}
			}
		}
		RFX4_ShaderColorGradient[] componentsInChildren7 = go.GetComponentsInChildren<RFX4_ShaderColorGradient>(includeInactive: true);
		for (int i = 0; i < componentsInChildren7.Length; i++)
		{
			componentsInChildren7[i].HUE = hue;
		}
	}

	private static Material setMatHUEColor(Material mat, string name, float hueColor)
	{
		UnityEngine.Color value = ConvertRGBColorByHUE(mat.GetColor(name), hueColor);
		mat.SetColor(name, value);
		return mat;
	}

	private static Material setMatAlphaColor(Material mat, string name, float alpha)
	{
		UnityEngine.Color color = mat.GetColor(name);
		color.a = alpha;
		mat.SetColor(name, color);
		return mat;
	}
}
public class RFX4_CopyPosition : MonoBehaviour
{
	public Transform CopiedTransform;

	private Transform t;

	private void Start()
	{
		t = base.transform;
	}

	private void Update()
	{
		t.position = CopiedTransform.position;
	}
}
public class RFX4_DeactivateByTime : MonoBehaviour
{
	public float DeactivateTime = 3f;

	private bool canUpdateState;

	private void OnEnable()
	{
		canUpdateState = true;
	}

	private void Update()
	{
		if (canUpdateState)
		{
			canUpdateState = false;
			Invoke("DeactivateThis", DeactivateTime);
		}
	}

	private void DeactivateThis()
	{
		base.gameObject.SetActive(value: false);
	}
}
public class RFX4_DeactivateRigidbodyByTime : MonoBehaviour
{
	public float TimeDelayToDeactivate = 6f;

	private void OnEnable()
	{
		Rigidbody component = GetComponent<Rigidbody>();
		component.isKinematic = false;
		component.detectCollisions = true;
		Invoke("Deactivate", TimeDelayToDeactivate);
	}

	private void Deactivate()
	{
		Rigidbody component = GetComponent<Rigidbody>();
		component.isKinematic = true;
		component.detectCollisions = false;
	}
}
public class RFX4_DemoReactivation : MonoBehaviour
{
	public float ReactivationTime = 5f;

	public GameObject Effect;

	private void Start()
	{
		InvokeRepeating("Reactivate", 0f, ReactivationTime);
	}

	private void Reactivate()
	{
		Effect.SetActive(value: false);
		Effect.SetActive(value: true);
	}
}
[ExecuteInEditMode]
[RequireComponent(typeof(Camera))]
[AddComponentMenu("KriptoFX/RFX4_BloomAndDistortion")]
[ImageEffectAllowedInSceneView]
public class RFX4_DistortionAndBloom : MonoBehaviour
{
	[Range(0.05f, 1f)]
	[Tooltip("Camera render texture resolution")]
	public float RenderTextureResolutoinFactor = 0.25f;

	public bool UseBloom = true;

	[Range(0.1f, 3f)]
	[Tooltip("Filters out pixels under this level of brightness.")]
	public float Threshold = 2f;

	[SerializeField]
	[Range(0f, 1f)]
	[Tooltip("Makes transition between under/over-threshold gradual.")]
	public float SoftKnee;

	[Range(1f, 7f)]
	[Tooltip("Changes extent of veiling effects in A screen resolution-independent fashion.")]
	public float Radius = 7f;

	[Tooltip("Blend factor of the result image.")]
	public float Intensity = 1f;

	[Tooltip("Controls filter quality and buffer resolution.")]
	public bool HighQuality;

	[Tooltip("Reduces flashing noise with an additional filter.")]
	public bool AntiFlicker;

	private const string shaderName = "Hidden/KriptoFX/PostEffects/RFX4_Bloom";

	private const string shaderAdditiveName = "Hidden/KriptoFX/PostEffects/RFX4_BloomAdditive";

	private RenderTexture source;

	private RenderTexture destination;

	private int previuosFrameWidth;

	private int previuosFrameHeight;

	private float previousScale;

	private Camera _cameraInstance;

	private Material m_Material;

	private Material m_MaterialAdditive;

	private const int kMaxIterations = 16;

	private readonly RenderTexture[] m_blurBuffer1 = new RenderTexture[16];

	private readonly RenderTexture[] m_blurBuffer2 = new RenderTexture[16];

	public Material mat
	{
		get
		{
			if (m_Material == null)
			{
				m_Material = CheckShaderAndCreateMaterial(Shader.Find("Hidden/KriptoFX/PostEffects/RFX4_Bloom"));
			}
			return m_Material;
		}
	}

	public Material matAdditive
	{
		get
		{
			if (m_MaterialAdditive == null)
			{
				m_MaterialAdditive = CheckShaderAndCreateMaterial(Shader.Find("Hidden/KriptoFX/PostEffects/RFX4_BloomAdditive"));
				m_MaterialAdditive.renderQueue = 3900;
			}
			return m_MaterialAdditive;
		}
	}

	public static Material CheckShaderAndCreateMaterial(Shader s)
	{
		if (s == null || !s.isSupported)
		{
			return null;
		}
		return new Material(s)
		{
			hideFlags = HideFlags.DontSave
		};
	}

	private void OnDisable()
	{
		if (m_Material != null)
		{
			UnityEngine.Object.DestroyImmediate(m_Material);
		}
		m_Material = null;
		if (m_MaterialAdditive != null)
		{
			UnityEngine.Object.DestroyImmediate(m_MaterialAdditive);
		}
		m_MaterialAdditive = null;
		if (_cameraInstance != null)
		{
			_cameraInstance.gameObject.SetActive(value: false);
		}
	}

	private void OnDestroy()
	{
		if (_cameraInstance != null)
		{
			UnityEngine.Object.DestroyImmediate(_cameraInstance.gameObject);
		}
	}

	private void OnGUI()
	{
		if (Event.current.type.Equals(EventType.Repaint) && UseBloom && destination != null)
		{
			Graphics.DrawTexture(new Rect(0f, 0f, Screen.width, Screen.height), destination, matAdditive);
		}
	}

	private void Start()
	{
		InitializeRenderTarget();
	}

	private void LateUpdate()
	{
		if (previuosFrameWidth != Screen.width || previuosFrameHeight != Screen.height || Mathf.Abs(previousScale - RenderTextureResolutoinFactor) > 0.01f)
		{
			InitializeRenderTarget();
			previuosFrameWidth = Screen.width;
			previuosFrameHeight = Screen.height;
			previousScale = RenderTextureResolutoinFactor;
		}
		Shader.EnableKeyword("DISTORT_OFF");
		UpdateCameraCopy();
		if (UseBloom)
		{
			UpdateBloom();
		}
		Shader.SetGlobalTexture("_GrabTextureMobile", source);
		Shader.SetGlobalFloat("_GrabTextureMobileScale", RenderTextureResolutoinFactor);
		Shader.DisableKeyword("DISTORT_OFF");
	}

	private void InitializeRenderTarget()
	{
		int num = (int)((float)Screen.width * RenderTextureResolutoinFactor);
		int num2 = (int)((float)Screen.height * RenderTextureResolutoinFactor);
		source = new RenderTexture(num, num2, 16, RenderTextureFormat.DefaultHDR);
		if (UseBloom)
		{
			destination = new RenderTexture(((double)RenderTextureResolutoinFactor > 0.99) ? num : (num / 2), ((double)RenderTextureResolutoinFactor > 0.99) ? num2 : (num2 / 2), 0, RenderTextureFormat.ARGB32);
		}
	}

	private void UpdateBloom()
	{
		bool isMobilePlatform = Application.isMobilePlatform;
		if (source == null)
		{
			return;
		}
		int num = source.width;
		int num2 = source.height;
		if (!HighQuality)
		{
			num /= 2;
			num2 /= 2;
		}
		RenderTextureFormat format = (isMobilePlatform ? RenderTextureFormat.Default : RenderTextureFormat.DefaultHDR);
		float num3 = Mathf.Log(num2, 2f) + Radius - 8f;
		int num4 = (int)num3;
		int num5 = Mathf.Clamp(num4, 1, 16);
		float num6 = Mathf.GammaToLinearSpace(Threshold);
		mat.SetFloat("_Threshold", num6);
		float num7 = num6 * SoftKnee + 1E-05f;
		Vector3 vector = new Vector3(num6 - num7, num7 * 2f, 0.25f / num7);
		mat.SetVector("_Curve", vector);
		bool flag = !HighQuality && AntiFlicker;
		mat.SetFloat("_PrefilterOffs", flag ? (-0.5f) : 0f);
		mat.SetFloat("_SampleScale", 0.5f + num3 - (float)num4);
		mat.SetFloat("_Intensity", Mathf.Max(0f, Intensity));
		RenderTexture temporary = RenderTexture.GetTemporary(num, num2, 0, format);
		Graphics.Blit(source, temporary, mat, AntiFlicker ? 1 : 0);
		RenderTexture renderTexture = temporary;
		for (int i = 0; i < num5; i++)
		{
			m_blurBuffer1[i] = RenderTexture.GetTemporary(renderTexture.width / 2, renderTexture.height / 2, 0, format);
			Graphics.Blit(renderTexture, m_blurBuffer1[i], mat, (i == 0) ? (AntiFlicker ? 3 : 2) : 4);
			renderTexture = m_blurBuffer1[i];
		}
		for (int num8 = num5 - 2; num8 >= 0; num8--)
		{
			RenderTexture renderTexture2 = m_blurBuffer1[num8];
			mat.SetTexture("_BaseTex", renderTexture2);
			m_blurBuffer2[num8] = RenderTexture.GetTemporary(renderTexture2.width, renderTexture2.height, 0, format);
			Graphics.Blit(renderTexture, m_blurBuffer2[num8], mat, HighQuality ? 6 : 5);
			renderTexture = m_blurBuffer2[num8];
		}
		destination.DiscardContents();
		Graphics.Blit(renderTexture, destination, mat, HighQuality ? 8 : 7);
		for (int j = 0; j < 16; j++)
		{
			if (m_blurBuffer1[j] != null)
			{
				RenderTexture.ReleaseTemporary(m_blurBuffer1[j]);
			}
			if (m_blurBuffer2[j] != null)
			{
				RenderTexture.ReleaseTemporary(m_blurBuffer2[j]);
			}
			m_blurBuffer1[j] = null;
			m_blurBuffer2[j] = null;
		}
		RenderTexture.ReleaseTemporary(temporary);
	}

	private void InitializeCameraCopy()
	{
		if (_cameraInstance != null)
		{
			_cameraInstance.gameObject.SetActive(value: true);
		}
		GameObject gameObject = GameObject.Find("RenderTextureCamera");
		if (gameObject == null)
		{
			GameObject gameObject2 = new GameObject("RenderTextureCamera");
			gameObject2.transform.parent = Camera.main.transform;
			_cameraInstance = gameObject2.AddComponent<Camera>();
			_cameraInstance.CopyFrom(Camera.main);
			_cameraInstance.clearFlags = Camera.main.clearFlags;
			_cameraInstance.depth--;
			_cameraInstance.allowHDR = true;
			_cameraInstance.targetTexture = source;
			Shader.SetGlobalTexture("_GrabTextureMobile", source);
			Shader.SetGlobalFloat("_GrabTextureMobileScale", RenderTextureResolutoinFactor);
			_cameraInstance.Render();
		}
		else
		{
			_cameraInstance = gameObject.GetComponent<Camera>();
		}
	}

	private void UpdateCameraCopy()
	{
		Camera current = Camera.current;
		if (current != null && current.name == "SceneCamera")
		{
			if (source != null)
			{
				source.DiscardContents();
			}
			current.targetTexture = source;
			current.Render();
			current.targetTexture = null;
			return;
		}
		current = Camera.main;
		bool allowHDR = current.allowHDR;
		if (source != null)
		{
			source.DiscardContents();
		}
		current.allowHDR = true;
		current.targetTexture = source;
		current.Render();
		current.allowHDR = allowHDR;
		current.targetTexture = null;
	}
}
public class RFX4_EffectEvent : MonoBehaviour
{
	public GameObject CharacterEffect;

	public Transform CharacterAttachPoint;

	public GameObject CharacterEffect2;

	public Transform CharacterAttachPoint2;

	public GameObject Effect;

	public Transform AttachPoint;

	public GameObject AdditionalEffect;

	public Transform AdditionalEffectAttachPoint;

	private void OnEnable()
	{
		if (Effect != null)
		{
			Effect.SetActive(value: false);
		}
		if (AdditionalEffect != null)
		{
			AdditionalEffect.SetActive(value: false);
		}
		if (CharacterEffect != null)
		{
			CharacterEffect.SetActive(value: false);
		}
		if (CharacterEffect2 != null)
		{
			CharacterEffect2.SetActive(value: false);
		}
	}

	public void ActivateEffect()
	{
		if (!(Effect == null))
		{
			Effect.SetActive(value: true);
		}
	}

	public void ActivateAdditionalEffect()
	{
		if (!(AdditionalEffect == null))
		{
			AdditionalEffect.SetActive(value: true);
		}
	}

	public void ActivateCharacterEffect()
	{
		if (!(CharacterEffect == null))
		{
			CharacterEffect.SetActive(value: true);
		}
	}

	public void ActivateCharacterEffect2()
	{
		if (!(CharacterEffect2 == null))
		{
			CharacterEffect2.SetActive(value: true);
		}
	}

	private void LateUpdate()
	{
		if (Effect != null && AttachPoint != null)
		{
			Effect.transform.position = AttachPoint.position;
		}
		if (AdditionalEffect != null && AdditionalEffectAttachPoint != null)
		{
			AdditionalEffect.transform.position = AdditionalEffectAttachPoint.position;
		}
		if (CharacterEffect != null && CharacterAttachPoint != null)
		{
			CharacterEffect.transform.position = CharacterAttachPoint.position;
		}
		if (CharacterEffect2 != null && CharacterAttachPoint2 != null)
		{
			CharacterEffect2.transform.position = CharacterAttachPoint2.position;
		}
	}
}
[RequireComponent(typeof(Renderer))]
[ExecuteInEditMode]
public class RFX4_MaterialQueue : MonoBehaviour
{
	[Tooltip("Background=1000, Geometry=2000, AlphaTest=2450, Transparent=3000, Overlay=4000")]
	public int queue = 2000;

	public int[] queues;

	private void Start()
	{
		Renderer component = GetComponent<Renderer>();
		if ((bool)component && (bool)component.sharedMaterial && queues != null)
		{
			component.sharedMaterial.renderQueue = queue;
			for (int i = 0; i < queues.Length && i < component.sharedMaterials.Length; i++)
			{
				component.sharedMaterials[i].renderQueue = queues[i];
			}
		}
	}

	private void OnValidate()
	{
		Start();
	}

	private void Update()
	{
		if (!Application.isPlaying)
		{
			Start();
		}
	}
}
public class RFX4_OnEnableResetTransform : MonoBehaviour
{
	private Transform t;

	private Vector3 startPosition;

	private Quaternion startRotation;

	private Vector3 startScale;

	private bool isInitialized;

	private void OnEnable()
	{
		if (!isInitialized)
		{
			isInitialized = true;
			t = base.transform;
			startPosition = t.position;
			startRotation = t.rotation;
			startScale = t.localScale;
		}
		else
		{
			t.position = startPosition;
			t.rotation = startRotation;
			t.localScale = startScale;
		}
	}

	private void OnDisable()
	{
		if (!isInitialized)
		{
			isInitialized = true;
			t = base.transform;
			startPosition = t.position;
			startRotation = t.rotation;
			startScale = t.localScale;
		}
		else
		{
			t.position = startPosition;
			t.rotation = startRotation;
			t.localScale = startScale;
		}
	}
}
public class RFX4_PhysXSetImpulse : MonoBehaviour
{
	public float Force = 1f;

	public ForceMode ForceMode;

	private Rigidbody rig;

	private Transform t;

	private void Start()
	{
		rig = GetComponent<Rigidbody>();
		t = base.transform;
	}

	private void FixedUpdate()
	{
		if (rig != null)
		{
			rig.AddForce(t.forward * Force, ForceMode);
		}
	}

	private void OnDisable()
	{
		if (rig != null)
		{
			rig.velocity = Vector3.zero;
		}
	}
}
public class RFX4_RaycastCollision : MonoBehaviour
{
	public float RaycastDistance = 100f;

	public GameObject[] Effects;

	public float Offset;

	public float TimeDelay;

	public float DestroyTime = 3f;

	public bool UsePivotPosition;

	public bool UseNormalRotation = true;

	public bool IsWorldSpace = true;

	public bool RealTimeUpdateRaycast;

	public bool DestroyAfterDisabling;

	[HideInInspector]
	public float HUE = -1f;

	[HideInInspector]
	public List<GameObject> CollidedInstances = new List<GameObject>();

	private bool isInitialized;

	private bool canUpdate;

	private void Start()
	{
		isInitialized = true;
		if (TimeDelay < 0.001f)
		{
			UpdateRaycast();
		}
		else
		{
			Invoke("LateEnable", TimeDelay);
		}
	}

	private void OnEnable()
	{
		CollidedInstances.Clear();
		if (isInitialized)
		{
			if (TimeDelay < 0.001f)
			{
				UpdateRaycast();
			}
			else
			{
				Invoke("LateEnable", TimeDelay);
			}
		}
	}

	private void OnDisable()
	{
		if (!DestroyAfterDisabling)
		{
			return;
		}
		foreach (GameObject collidedInstance in CollidedInstances)
		{
			UnityEngine.Object.Destroy(collidedInstance);
		}
	}

	private void Update()
	{
		if (canUpdate)
		{
			UpdateRaycast();
		}
	}

	private void LateEnable()
	{
		UpdateRaycast();
	}

	private void UpdateRaycast()
	{
		if (Physics.Raycast(base.transform.position, base.transform.forward, out var hitInfo, RaycastDistance))
		{
			Vector3 position = ((!UsePivotPosition) ? (hitInfo.point + hitInfo.normal * Offset) : hitInfo.transform.position);
			if (CollidedInstances.Count == 0)
			{
				GameObject[] effects = Effects;
				for (int i = 0; i < effects.Length; i++)
				{
					GameObject gameObject = UnityEngine.Object.Instantiate(effects[i], position, default(Quaternion));
					CollidedInstances.Add(gameObject);
					if (HUE > -0.9f)
					{
						RFX4_ColorHelper.ChangeObjectColorByHUE(gameObject, HUE);
					}
					if (!IsWorldSpace)
					{
						gameObject.transform.parent = base.transform;
					}
					if (UseNormalRotation)
					{
						gameObject.transform.LookAt(hitInfo.point + hitInfo.normal);
					}
					if (DestroyTime > 0.0001f)
					{
						UnityEngine.Object.Destroy(gameObject, DestroyTime);
					}
				}
			}
			else
			{
				foreach (GameObject collidedInstance in CollidedInstances)
				{
					if (!(collidedInstance == null))
					{
						collidedInstance.transform.position = position;
						if (UseNormalRotation)
						{
							collidedInstance.transform.LookAt(hitInfo.point + hitInfo.normal);
						}
					}
				}
			}
		}
		if (RealTimeUpdateRaycast)
		{
			canUpdate = true;
		}
	}

	private void OnDrawGizmosSelected()
	{
		Gizmos.color = UnityEngine.Color.blue;
		Gizmos.DrawLine(base.transform.position, base.transform.position + base.transform.forward * RaycastDistance);
	}
}
public class RFX4_ReplaceMaterialByTime : MonoBehaviour
{
	public Material ReplacementMaterial;

	public float TimeDelay = 1f;

	public bool ChangeShadow = true;

	private bool isInitialized;

	private Material mat;

	private MeshRenderer mshRend;

	private void Start()
	{
		isInitialized = true;
		mshRend = GetComponent<MeshRenderer>();
		mat = mshRend.sharedMaterial;
		Invoke("ReplaceObject", TimeDelay);
	}

	private void OnEnable()
	{
		if (isInitialized)
		{
			mshRend.sharedMaterial = mat;
			Invoke("ReplaceObject", TimeDelay);
		}
	}

	private void ReplaceObject()
	{
		mshRend.sharedMaterial = ReplacementMaterial;
	}
}
public class RFX4_ReplaceModelOnCollision : MonoBehaviour
{
	public GameObject PhysicsObjects;

	private bool isCollided;

	private Transform t;

	private void OnCollisionEnter(Collision collision)
	{
		if (!isCollided)
		{
			isCollided = true;
			PhysicsObjects.SetActive(value: true);
			MeshRenderer component = GetComponent<MeshRenderer>();
			if (component != null)
			{
				component.enabled = false;
			}
			Rigidbody component2 = GetComponent<Rigidbody>();
			component2.isKinematic = true;
			component2.detectCollisions = false;
		}
	}

	private void OnEnable()
	{
		isCollided = false;
		PhysicsObjects.SetActive(value: false);
		MeshRenderer component = GetComponent<MeshRenderer>();
		if (component != null)
		{
			component.enabled = true;
		}
		Rigidbody component2 = GetComponent<Rigidbody>();
		component2.isKinematic = false;
		component2.detectCollisions = true;
	}
}
public class RFX4_RotateAround : MonoBehaviour
{
	public Vector3 Offset = Vector3.forward;

	public Vector3 RotateVector = Vector3.forward;

	public float LifeTime = 1f;

	private Transform t;

	private float currentTime;

	private Quaternion rotation;

	private void Start()
	{
		t = base.transform;
		rotation = t.rotation;
	}

	private void OnEnable()
	{
		currentTime = 0f;
		if (t != null)
		{
			t.rotation = rotation;
		}
	}

	private void Update()
	{
		if (!(currentTime >= LifeTime) || !(LifeTime > 0.0001f))
		{
			currentTime += Time.deltaTime;
			t.Rotate(RotateVector * Time.deltaTime);
		}
	}
}
public class RFX4_StartDelay : MonoBehaviour
{
	public GameObject ActivatedGameObject;

	public float Delay = 1f;

	private void OnEnable()
	{
		ActivatedGameObject.SetActive(value: false);
		Invoke("ActivateGO", Delay);
	}

	private void ActivateGO()
	{
		ActivatedGameObject.SetActive(value: true);
	}

	private void OnDisable()
	{
		CancelInvoke("ActivateGO");
	}
}
public enum RFX4_TextureShaderProperties
{
	_MainTex,
	_DistortTex,
	_Mask,
	_Cutout,
	_CutoutTex,
	_Bump,
	_BumpTex,
	_EmissionTex
}
public class RFX4_TornadoParticles : MonoBehaviour
{
	public Material TornadoMaterial;

	private ParticleSystem.Particle[] particleArray;

	private ParticleSystem particleSys;

	private Light myLight;

	private Vector4 _twistScale;

	private int materialID = -1;

	private void Start()
	{
		particleSys = GetComponent<ParticleSystem>();
		myLight = GetComponent<Light>();
		if (particleSys != null)
		{
			particleArray = new ParticleSystem.Particle[particleSys.main.maxParticles];
		}
		if (TornadoMaterial.HasProperty("_TwistScale"))
		{
			materialID = Shader.PropertyToID("_TwistScale");
		}
		else
		{
			UnityEngine.Debug.Log(TornadoMaterial.name + " not have property twist");
		}
		if (materialID != -1)
		{
			_twistScale = TornadoMaterial.GetVector(materialID);
		}
	}

	private void Update()
	{
		if (particleSys != null)
		{
			int particles = particleSys.GetParticles(particleArray);
			for (int i = 0; i < particles; i++)
			{
				Vector3 position = particleArray[i].position;
				float num = (position.y - base.transform.position.y) * _twistScale.y;
				position.x = Mathf.Sin(Time.time * _twistScale.z + position.y * _twistScale.x) * num;
				position.z = Mathf.Sin(Time.time * _twistScale.z + position.y * _twistScale.x + 1.57075f) * num;
				particleArray[i].position = position;
				particleSys.SetParticles(particleArray, particles);
			}
		}
		if (myLight != null)
		{
			Vector3 localPosition = base.transform.localPosition;
			float num2 = localPosition.y * _twistScale.y;
			localPosition.x = Mathf.Sin(Time.time * _twistScale.z + localPosition.y * _twistScale.x) * num2;
			localPosition.z = Mathf.Sin(Time.time * _twistScale.z + localPosition.y * _twistScale.x + 1.57075f) * num2;
			base.transform.localPosition = localPosition;
		}
	}
}
[RequireComponent(typeof(LineRenderer))]
public class RFX4_TrailRenderer : MonoBehaviour
{
	public float VertexLifeTime = 2f;

	public float TrailLifeTime = 2f;

	[Range(0.001f, 1f)]
	public float MinVertexDistance = 0.01f;

	public float Gravity = 0.01f;

	public Vector3 Force = new Vector3(0f, 0f, 0f);

	public float InheritVelocity;

	public float Drag = 0.01f;

	[Range(0.001f, 10f)]
	public float Frequency = 1f;

	[Range(0.001f, 10f)]
	public float OffsetSpeed = 0.5f;

	public bool RandomTurbulenceOffset;

	[Range(0.001f, 10f)]
	public float Amplitude = 2f;

	public float TurbulenceStrength = 0.1f;

	public AnimationCurve VelocityByDistance = AnimationCurve.EaseInOut(0f, 1f, 1f, 1f);

	public float AproximatedFlyDistance = -1f;

	public bool SmoothCurves;

	private LineRenderer lineRenderer;

	private List<Vector3> positions;

	private List<float> currentTimes;

	private List<Vector3> velocities;

	[HideInInspector]
	public float currentLifeTime;

	private Transform t;

	private Vector3 prevPosition;

	private Vector3 startPosition;

	private List<Vector3> controlPoints = new List<Vector3>();

	private int curveCount;

	private const float MinimumSqrDistance = 0.01f;

	private const float DivisionThreshold = -0.99f;

	private const float SmoothCurvesScale = 0.5f;

	private float currentVelocity;

	private float turbulenceRandomOffset;

	private bool isInitialized;

	private void Start()
	{
		Init();
		isInitialized = true;
	}

	private void OnEnable()
	{
		if (isInitialized)
		{
			Init();
		}
	}

	private void Init()
	{
		positions = new List<Vector3>();
		currentTimes = new List<float>();
		velocities = new List<Vector3>();
		currentLifeTime = 0f;
		curveCount = 0;
		currentVelocity = 0f;
		t = base.transform;
		prevPosition = t.position;
		startPosition = t.position;
		lineRenderer = GetComponent<LineRenderer>();
		lineRenderer.positionCount = 0;
		lineRenderer.startColor = UnityEngine.Color.white;
		lineRenderer.endColor = UnityEngine.Color.white;
		positions.Add(t.position);
		currentTimes.Add(currentLifeTime);
		velocities.Add(Vector3.zero);
		turbulenceRandomOffset = (RandomTurbulenceOffset ? (UnityEngine.Random.Range(0f, 10000f) / 1000f) : 0f);
	}

	private void Update()
	{
		UpdatePositionsCount();
		UpdateForce();
		UpdateImpulse();
		UpdateVelocity();
		int lastDeletedIndex = GetLastDeletedIndex();
		RemovePositionsBeforeIndex(lastDeletedIndex);
		if (SmoothCurves && positions.Count > 2)
		{
			InterpolateBezier(positions, 0.5f);
			List<Vector3> drawingPoints = GetDrawingPoints();
			lineRenderer.positionCount = drawingPoints.Count;
			lineRenderer.SetPositions(drawingPoints.ToArray());
		}
		else
		{
			lineRenderer.positionCount = positions.Count;
			lineRenderer.SetPositions(positions.ToArray());
		}
	}

	private int GetLastDeletedIndex()
	{
		int result = -1;
		int count = currentTimes.Count;
		for (int i = 1; i < count; i++)
		{
			currentTimes[i] -= Time.deltaTime;
			if (currentTimes[i] <= 0f)
			{
				result = i;
			}
		}
		return result;
	}

	private void UpdatePositionsCount()
	{
		if (!(TrailLifeTime > 0.0001f) || !(currentLifeTime > TrailLifeTime))
		{
			currentLifeTime += Time.deltaTime;
			Vector3 vector = ((positions.Count != 0) ? positions[positions.Count - 1] : Vector3.zero);
			if (Mathf.Abs((t.position - vector).magnitude) > MinVertexDistance && positions.Count > 0)
			{
				AddInterpolatedPositions(vector, t.position);
			}
		}
	}

	private void AddInterpolatedPositions(Vector3 start, Vector3 end)
	{
		int num = (int)((start - end).magnitude / MinVertexDistance);
		float num2 = currentTimes.LastOrDefault();
		Vector3 zero = Vector3.zero;
		for (int i = 1; i <= num - 1; i++)
		{
			Vector3 item = start + (end - start) * i * 1f / num;
			float item2 = num2 + (VertexLifeTime - num2) * (float)i * 1f / (float)num;
			positions.Add(item);
			currentTimes.Add(item2);
			velocities.Add(zero);
		}
	}

	private void RemovePositionsBeforeIndex(int lastDeletedIndex)
	{
		if (lastDeletedIndex != -1)
		{
			if (positions.Count - lastDeletedIndex == 1)
			{
				positions.Clear();
				currentTimes.Clear();
				velocities.Clear();
			}
			else
			{
				positions.RemoveRange(0, lastDeletedIndex);
				currentTimes.RemoveRange(0, lastDeletedIndex);
				velocities.RemoveRange(0, lastDeletedIndex);
			}
		}
	}

	private void UpdateForce()
	{
		if (positions.Count < 1)
		{
			return;
		}
		Vector3 vector = Gravity * Vector3.down * Time.deltaTime;
		Vector3 vector2 = t.rotation * Force * Time.deltaTime;
		for (int i = 0; i < positions.Count; i++)
		{
			Vector3 zero = Vector3.zero;
			if (TurbulenceStrength > 1E-06f)
			{
				Vector3 vector3 = positions[i] / Frequency;
				float num = (Time.time + turbulenceRandomOffset) * OffsetSpeed;
				vector3 -= num * Vector3.one;
				zero.x += (Mathf.PerlinNoise(vector3.z, vector3.y) * 2f - 1f) * Amplitude * Time.deltaTime * TurbulenceStrength / 10f;
				zero.y += (Mathf.PerlinNoise(vector3.x, vector3.z) * 2f - 1f) * Amplitude * Time.deltaTime * TurbulenceStrength / 10f;
				zero.z += (Mathf.PerlinNoise(vector3.y, vector3.x) * 2f - 1f) * Amplitude * Time.deltaTime * TurbulenceStrength / 10f;
			}
			Vector3 vector4 = vector + vector2 + zero;
			if (AproximatedFlyDistance > 0.01f)
			{
				float num2 = Mathf.Abs((positions[i] - startPosition).magnitude);
				vector4 *= VelocityByDistance.Evaluate(Mathf.Clamp01(num2 / AproximatedFlyDistance));
			}
			velocities[i] += vector4;
		}
	}

	private void UpdateImpulse()
	{
		if (velocities.Count != 0)
		{
			currentVelocity = (t.position - prevPosition).magnitude / Time.deltaTime;
			Vector3 normalized = (t.position - prevPosition).normalized;
			prevPosition = t.position;
			velocities[velocities.Count - 1] += currentVelocity * InheritVelocity * normalized * Time.deltaTime;
		}
	}

	private void UpdateVelocity()
	{
		if (velocities.Count == 0)
		{
			return;
		}
		int count = positions.Count;
		for (int i = 0; i < count; i++)
		{
			if (Drag > 1E-05f)
			{
				velocities[i] -= Drag * velocities[i] * Time.deltaTime;
			}
			if (velocities[i].magnitude < 1E-05f)
			{
				velocities[i] = Vector3.zero;
			}
			positions[i] += velocities[i] * Time.deltaTime;
		}
	}

	public void InterpolateBezier(List<Vector3> segmentPoints, float scale)
	{
		controlPoints.Clear();
		if (segmentPoints.Count < 2)
		{
			return;
		}
		for (int i = 0; i < segmentPoints.Count; i++)
		{
			if (i == 0)
			{
				Vector3 vector = segmentPoints[i];
				Vector3 vector2 = segmentPoints[i + 1] - vector;
				Vector3 item = vector + scale * vector2;
				controlPoints.Add(vector);
				controlPoints.Add(item);
			}
			else if (i == segmentPoints.Count - 1)
			{
				Vector3 vector3 = segmentPoints[i - 1];
				Vector3 vector4 = segmentPoints[i];
				Vector3 vector5 = vector4 - vector3;
				Vector3 item2 = vector4 - scale * vector5;
				controlPoints.Add(item2);
				controlPoints.Add(vector4);
			}
			else
			{
				Vector3 vector6 = segmentPoints[i - 1];
				Vector3 vector7 = segmentPoints[i];
				Vector3 vector8 = segmentPoints[i + 1];
				Vector3 normalized = (vector8 - vector6).normalized;
				Vector3 item3 = vector7 - scale * normalized * (vector7 - vector6).magnitude;
				Vector3 item4 = vector7 + scale * normalized * (vector8 - vector7).magnitude;
				controlPoints.Add(item3);
				controlPoints.Add(vector7);
				controlPoints.Add(item4);
			}
		}
		curveCount = (controlPoints.Count - 1) / 3;
	}

	public List<Vector3> GetDrawingPoints()
	{
		List<Vector3> list = new List<Vector3>();
		for (int i = 0; i < curveCount; i++)
		{
			List<Vector3> list2 = FindDrawingPoints(i);
			if (i != 0)
			{
				list2.RemoveAt(0);
			}
			list.AddRange(list2);
		}
		return list;
	}

	private List<Vector3> FindDrawingPoints(int curveIndex)
	{
		List<Vector3> list = new List<Vector3>();
		Vector3 item = CalculateBezierPoint(curveIndex, 0f);
		Vector3 item2 = CalculateBezierPoint(curveIndex, 1f);
		list.Add(item);
		list.Add(item2);
		FindDrawingPoints(curveIndex, 0f, 1f, list, 1);
		return list;
	}

	private int FindDrawingPoints(int curveIndex, float t0, float t1, List<Vector3> pointList, int insertionIndex)
	{
		Vector3 vector = CalculateBezierPoint(curveIndex, t0);
		Vector3 vector2 = CalculateBezierPoint(curveIndex, t1);
		if ((vector - vector2).sqrMagnitude < 0.01f)
		{
			return 0;
		}
		float num = (t0 + t1) / 2f;
		Vector3 vector3 = CalculateBezierPoint(curveIndex, num);
		Vector3 normalized = (vector - vector3).normalized;
		Vector3 normalized2 = (vector2 - vector3).normalized;
		if (Vector3.Dot(normalized, normalized2) > -0.99f || Mathf.Abs(num - 0.5f) < 0.0001f)
		{
			int num2 = 0;
			num2 += FindDrawingPoints(curveIndex, t0, num, pointList, insertionIndex);
			pointList.Insert(insertionIndex + num2, vector3);
			num2++;
			return num2 + FindDrawingPoints(curveIndex, num, t1, pointList, insertionIndex + num2);
		}
		return 0;
	}

	public Vector3 CalculateBezierPoint(int curveIndex, float t)
	{
		int num = curveIndex * 3;
		Vector3 p = controlPoints[num];
		Vector3 p2 = controlPoints[num + 1];
		Vector3 p3 = controlPoints[num + 2];
		Vector3 p4 = controlPoints[num + 3];
		return CalculateBezierPoint(t, p, p2, p3, p4);
	}

	private Vector3 CalculateBezierPoint(float t, Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3)
	{
		float num = 1f - t;
		float num2 = t * t;
		float num3 = num * num;
		float num4 = num3 * num;
		float num5 = num2 * t;
		return num4 * p0 + 3f * num3 * t * p1 + 3f * num * num2 * p2 + num5 * p3;
	}
}
public class RFX4_TransformMotion : MonoBehaviour
{
	public enum RFX4_SimulationSpace
	{
		Local,
		World
	}

	public class RFX4_CollisionInfo : EventArgs
	{
		public RaycastHit Hit;
	}

	public float Distance = 30f;

	public float Speed = 1f;

	public float Dampeen;

	public float MinSpeed = 1f;

	public float TimeDelay;

	public LayerMask CollidesWith = -1;

	public GameObject[] EffectsOnCollision;

	public float CollisionOffset;

	public float DestroyTimeDelay = 5f;

	public bool CollisionEffectInWorldSpace = true;

	public GameObject[] DeactivatedObjectsOnCollision;

	[HideInInspector]
	public float HUE = -1f;

	[HideInInspector]
	public List<GameObject> CollidedInstances;

	private Vector3 startPositionLocal;

	private Transform t;

	private Vector3 oldPos;

	private bool isCollided;

	private bool isOutDistance;

	private Quaternion startQuaternion;

	private float currentSpeed;

	private float currentDelay;

	private const float RayCastTolerance = 0.3f;

	private bool isInitialized;

	private bool dropFirstFrameForFixUnityBugWithParticles;

	public event EventHandler<RFX4_CollisionInfo> CollisionEnter;

	private void Start()
	{
		t = base.transform;
		startQuaternion = t.rotation;
		startPositionLocal = t.localPosition;
		oldPos = t.TransformPoint(startPositionLocal);
		Initialize();
		isInitialized = true;
	}

	private void OnEnable()
	{
		if (isInitialized)
		{
			Initialize();
		}
	}

	private void OnDisable()
	{
		if (isInitialized)
		{
			Initialize();
		}
	}

	private void Initialize()
	{
		isCollided = false;
		isOutDistance = false;
		currentSpeed = Speed;
		currentDelay = 0f;
		startQuaternion = t.rotation;
		t.localPosition = startPositionLocal;
		oldPos = t.TransformPoint(startPositionLocal);
		OnCollisionDeactivateBehaviour(active: true);
		dropFirstFrameForFixUnityBugWithParticles = true;
	}

	private void Update()
	{
		if (!dropFirstFrameForFixUnityBugWithParticles)
		{
			UpdateWorldPosition();
		}
		else
		{
			dropFirstFrameForFixUnityBugWithParticles = false;
		}
	}

	private void UpdateWorldPosition()
	{
		currentDelay += Time.deltaTime;
		if (!(currentDelay < TimeDelay))
		{
			Vector3 vector = Vector3.zero;
			Vector3 vector2 = Vector3.zero;
			if (!isCollided && !isOutDistance)
			{
				currentSpeed = Mathf.Clamp(currentSpeed - Speed * Dampeen * Time.deltaTime, MinSpeed, Speed);
				Vector3 vector3 = Vector3.forward * currentSpeed * Time.deltaTime;
				vector = t.localRotation * vector3;
				vector2 = startQuaternion * vector3;
			}
			float magnitude = (t.localPosition + vector - startPositionLocal).magnitude;
			if (!isCollided && Physics.Raycast(t.position, t.forward, out var hitInfo, 10f, CollidesWith) && vector.magnitude + 0.3f > hitInfo.distance)
			{
				isCollided = true;
				t.position = hitInfo.point;
				oldPos = t.position;
				OnCollisionBehaviour(hitInfo);
				OnCollisionDeactivateBehaviour(active: false);
			}
			else if (!isOutDistance && magnitude > Distance)
			{
				isOutDistance = true;
				t.localPosition = startPositionLocal + t.localRotation * Vector3.forward * Distance;
				oldPos = t.position;
			}
			else
			{
				t.position = oldPos + vector2;
				oldPos = t.position;
			}
		}
	}

	private void OnCollisionBehaviour(RaycastHit hit)
	{
		this.CollisionEnter?.Invoke(this, new RFX4_CollisionInfo
		{
			Hit = hit
		});
		CollidedInstances.Clear();
		GameObject[] effectsOnCollision = EffectsOnCollision;
		for (int i = 0; i < effectsOnCollision.Length; i++)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(effectsOnCollision[i], hit.point + hit.normal * CollisionOffset, default(Quaternion));
			CollidedInstances.Add(gameObject);
			if (HUE > -0.9f)
			{
				RFX4_ColorHelper.ChangeObjectColorByHUE(gameObject, HUE);
			}
			gameObject.transform.LookAt(hit.point + hit.normal + hit.normal * CollisionOffset);
			if (!CollisionEffectInWorldSpace)
			{
				gameObject.transform.parent = base.transform;
			}
			UnityEngine.Object.Destroy(gameObject, DestroyTimeDelay);
		}
	}

	private void OnCollisionDeactivateBehaviour(bool active)
	{
		GameObject[] deactivatedObjectsOnCollision = DeactivatedObjectsOnCollision;
		for (int i = 0; i < deactivatedObjectsOnCollision.Length; i++)
		{
			deactivatedObjectsOnCollision[i].SetActive(active);
		}
	}

	private void OnDrawGizmosSelected()
	{
		if (!Application.isPlaying)
		{
			t = base.transform;
			Gizmos.color = UnityEngine.Color.blue;
			Gizmos.DrawLine(t.position, t.position + t.forward * Distance);
		}
	}
}
public class RFX4_UVAnimation : MonoBehaviour
{
	public int TilesX = 4;

	public int TilesY = 4;

	public int FPS = 30;

	public int StartFrameOffset;

	public bool IsLoop = true;

	public float StartDelay;

	public bool IsReverse;

	public bool IsInterpolateFrames;

	public RFX4_TextureShaderProperties[] TextureNames = new RFX4_TextureShaderProperties[1];

	public AnimationCurve FrameOverTime = AnimationCurve.Linear(0f, 1f, 1f, 1f);

	private int count;

	private Renderer currentRenderer;

	private Projector projector;

	private Material instanceMaterial;

	private float animationStartTime;

	private bool canUpdate;

	private int previousIndex;

	private int totalFrames;

	private float currentInterpolatedTime;

	private int currentIndex;

	private Vector2 size;

	private bool isInitialized;

	private void OnEnable()
	{
		if (isInitialized)
		{
			InitDefaultVariables();
		}
	}

	private void Start()
	{
		InitDefaultVariables();
		isInitialized = true;
	}

	private void Update()
	{
		if (canUpdate)
		{
			UpdateMaterial();
			SetSpriteAnimation();
			if (IsInterpolateFrames)
			{
				SetSpriteAnimationIterpolated();
			}
		}
	}

	private void InitDefaultVariables()
	{
		InitializeMaterial();
		totalFrames = TilesX * TilesY;
		previousIndex = 0;
		canUpdate = true;
		count = TilesY * TilesX;
		Vector3 zero = Vector3.zero;
		StartFrameOffset -= StartFrameOffset / count * count;
		size = new Vector2(1f / (float)TilesX, 1f / (float)TilesY);
		animationStartTime = Time.time;
		if (instanceMaterial != null)
		{
			RFX4_TextureShaderProperties[] textureNames = TextureNames;
			for (int i = 0; i < textureNames.Length; i++)
			{
				RFX4_TextureShaderProperties rFX4_TextureShaderProperties = textureNames[i];
				instanceMaterial.SetTextureScale(rFX4_TextureShaderProperties.ToString(), size);
				instanceMaterial.SetTextureOffset(rFX4_TextureShaderProperties.ToString(), zero);
			}
		}
	}

	private void InitializeMaterial()
	{
		currentRenderer = GetComponent<Renderer>();
		if (currentRenderer == null)
		{
			projector = GetComponent<Projector>();
			if (projector != null)
			{
				if (!projector.material.name.EndsWith("(Instance)"))
				{
					projector.material = new Material(projector.material)
					{
						name = projector.material.name + " (Instance)"
					};
				}
				instanceMaterial = projector.material;
			}
		}
		else
		{
			instanceMaterial = currentRenderer.material;
		}
	}

	private void UpdateMaterial()
	{
		if (currentRenderer == null)
		{
			if (projector != null)
			{
				if (!projector.material.name.EndsWith("(Instance)"))
				{
					projector.material = new Material(projector.material)
					{
						name = projector.material.name + " (Instance)"
					};
				}
				instanceMaterial = projector.material;
			}
		}
		else
		{
			instanceMaterial = currentRenderer.material;
		}
	}

	private void SetSpriteAnimation()
	{
		int num = (int)((Time.time - animationStartTime) * (float)FPS);
		num %= totalFrames;
		if (!IsLoop && num < previousIndex)
		{
			canUpdate = false;
			return;
		}
		if (IsInterpolateFrames && num != previousIndex)
		{
			currentInterpolatedTime = 0f;
		}
		previousIndex = num;
		if (IsReverse)
		{
			num = totalFrames - num - 1;
		}
		int num2 = num % TilesX;
		int num3 = num / TilesX;
		float x = (float)num2 * size.x;
		float y = 1f - size.y - (float)num3 * size.y;
		Vector2 value = new Vector2(x, y);
		if (instanceMaterial != null)
		{
			RFX4_TextureShaderProperties[] textureNames = TextureNames;
			for (int i = 0; i < textureNames.Length; i++)
			{
				RFX4_TextureShaderProperties rFX4_TextureShaderProperties = textureNames[i];
				instanceMaterial.SetTextureScale(rFX4_TextureShaderProperties.ToString(), size);
				instanceMaterial.SetTextureOffset(rFX4_TextureShaderProperties.ToString(), value);
			}
		}
	}

	private void SetSpriteAnimationIterpolated()
	{
		currentInterpolatedTime += Time.deltaTime;
		int num = previousIndex + 1;
		if (num == totalFrames)
		{
			num = previousIndex;
		}
		if (IsReverse)
		{
			num = totalFrames - num - 1;
		}
		int num2 = num % TilesX;
		int num3 = num / TilesX;
		float x = (float)num2 * size.x;
		float y = 1f - size.y - (float)num3 * size.y;
		Vector2 vector = new Vector2(x, y);
		if (instanceMaterial != null)
		{
			instanceMaterial.SetVector("_Tex_NextFrame", new Vector4(size.x, size.y, vector.x, vector.y));
			instanceMaterial.SetFloat("InterpolationValue", Mathf.Clamp01(currentInterpolatedTime * (float)FPS));
		}
	}
}
public class RFX4_UVScroll : MonoBehaviour
{
	public Vector2 UvScrollMultiplier = new Vector2(1f, 0f);

	public RFX4_TextureShaderProperties TextureName;

	private Vector2 uvOffset = Vector2.zero;

	private Material mat;

	private void Start()
	{
		Renderer component = GetComponent<Renderer>();
		if (component == null)
		{
			Projector component2 = GetComponent<Projector>();
			if (component2 != null)
			{
				if (!component2.material.name.EndsWith("(Instance)"))
				{
					component2.material = new Material(component2.material)
					{
						name = component2.material.name + " (Instance)"
					};
				}
				mat = component2.material;
			}
		}
		else
		{
			mat = component.material;
		}
	}

	private void Update()
	{
		uvOffset += UvScrollMultiplier * Time.deltaTime;
		if (mat != null)
		{
			mat.SetTextureOffset(TextureName.ToString(), uvOffset);
		}
	}
}
public class FullPlaneGUI : MonoBehaviour
{
	public RealWaterSpeedManager speedManager;

	public RealWaterNormalMap WaterPlane;

	public GUIStyle Title;

	public GameObject plane;

	public GameObject refractionPlane;

	public GameObject botPlane;

	public GameObject botRefractionPlane;

	public Texture2D x256;

	public Texture2D x360;

	public Texture2D x512;

	public GUIStyle Normal;

	public RealWaterCollider[] colliders = new RealWaterCollider[6];

	private float inputForce = 1f;

	private float inputForcePrev = 1f;

	private float native_width = 1920f;

	private float native_height = 1080f;

	private void OnGUI()
	{
		float x = (float)Screen.width / native_width;
		float y = (float)Screen.height / native_height;
		GUI.matrix = Matrix4x4.TRS(new Vector3(0f, 0f, 0f), Quaternion.identity, new Vector3(x, y, 1f));
		GUI.depth = 10;
		GUI.Box(new Rect(38.399998f, 54f, 729.6f, 432f), "");
		GUI.Label(new Rect(57.6f, 75.6f, 288f, 43.2f), "RealWater Settings", Title);
		GUI.Label(new Rect(57.6f, 140.4f, 288f, 151.2f), "Image Size: (" + WaterPlane.GetRows() + "x" + WaterPlane.GetCols() + ")", Normal);
		if (GUI.Button(new Rect(57.6f, 172.8f, 115.2f, 43.2f), "256x256"))
		{
			WaterPlane.normalMap = x256;
			WaterPlane.Reset();
			plane.GetComponent<Renderer>().material.SetTexture("_DetailNormalMap", x256);
			botPlane.GetComponent<Renderer>().material.SetTexture("_DetailNormalMap", x256);
			botRefractionPlane.GetComponent<Renderer>().material.SetTexture("_BumpMap", x256);
			refractionPlane.GetComponent<Renderer>().material.SetTexture("_BumpMap", x256);
		}
		if (GUI.Button(new Rect(192f, 172.8f, 115.2f, 43.2f), "360x360"))
		{
			WaterPlane.normalMap = x360;
			WaterPlane.Reset();
			plane.GetComponent<Renderer>().material.SetTexture("_DetailNormalMap", x360);
			botPlane.GetComponent<Renderer>().material.SetTexture("_DetailNormalMap", x360);
			botRefractionPlane.GetComponent<Renderer>().material.SetTexture("_BumpMap", x360);
			refractionPlane.GetComponent<Renderer>().material.SetTexture("_BumpMap", x360);
		}
		if (GUI.Button(new Rect(326.4f, 172.8f, 115.2f, 43.2f), "512x512"))
		{
			WaterPlane.normalMap = x512;
			WaterPlane.Reset();
			plane.GetComponent<Renderer>().material.SetTexture("_DetailNormalMap", x512);
			botPlane.GetComponent<Renderer>().material.SetTexture("_DetailNormalMap", x512);
			botRefractionPlane.GetComponent<Renderer>().material.SetTexture("_BumpMap", x512);
			refractionPlane.GetComponent<Renderer>().material.SetTexture("_BumpMap", x512);
		}
		GUI.Label(new Rect(57.6f, 237.6f, 288f, 43.2f), "Speed: " + speedManager.Speed.ToString("F0") + " ", Normal);
		speedManager.Speed = GUI.HorizontalSlider(new Rect(211.2f, 246.24f, 288f, 32.399998f), speedManager.Speed, 0f, 50f);
		GUI.Label(new Rect(57.6f, 280.8f, 288f, 43.2f), "Damping: " + WaterPlane.Damping.ToString("F2"), Normal);
		WaterPlane.Damping = GUI.HorizontalSlider(new Rect(211.2f, 285.12f, 288f, 32.399998f), WaterPlane.Damping, 0.8f, 0.99f);
		GUI.Label(new Rect(57.6f, 324f, 288f, 43.2f), "Input Force: " + inputForce.ToString("F1"), Normal);
		inputForce = GUI.HorizontalSlider(new Rect(230.4f, 329.4f, 288f, 32.399998f), inputForce, 0.1f, 1f);
		if (inputForcePrev != inputForce)
		{
			for (int i = 0; i < 6; i++)
			{
				colliders[i].InputForce = inputForce;
			}
			inputForcePrev = inputForce;
		}
		GUI.Label(new Rect(57.6f, 367.2f, 288f, 43.2f), "Obstructions: ", Normal);
		WaterPlane.obstructionSettings.ObstructionsEnabled = GUI.Toggle(new Rect(268.8f, 367.74f, 60.288f, 32.399998f), WaterPlane.obstructionSettings.ObstructionsEnabled, "");
		GUI.Label(new Rect(57.6f, 410.4f, 288f, 43.2f), "Obstruction Texture: ", Normal);
		WaterPlane.obstructionTextureSettings.ObstructionTexturesEnabled = GUI.Toggle(new Rect(268.8f, 410.94f, 60.288f, 32.399998f), WaterPlane.obstructionTextureSettings.ObstructionTexturesEnabled, "");
	}
}
public class RefractionScroll : MonoBehaviour
{
	public Vector2 bumpMap1Speed;

	private Vector2 bumpMap1UV;

	private Renderer rend;

	private void Start()
	{
		bumpMap1Speed /= 10f;
		rend = GetComponent<Renderer>();
	}

	private void Update()
	{
		bumpMap1UV.x = Time.time * bumpMap1Speed.x;
		bumpMap1UV.y = Time.time * bumpMap1Speed.y;
		rend.material.SetTextureOffset("_AltMap", bumpMap1UV);
	}
}
public class SurfaceScroll : MonoBehaviour
{
	public Vector2 bumpMap1Speed;

	private Vector2 bumpMap1UV;

	private Renderer rend;

	private void Start()
	{
		bumpMap1Speed /= 10f;
		rend = GetComponent<Renderer>();
	}

	private void Update()
	{
		bumpMap1UV.x = Time.time * bumpMap1Speed.x;
		bumpMap1UV.y = Time.time * bumpMap1Speed.y;
		rend.material.SetTextureOffset("_MainTex", bumpMap1UV);
	}
}
public class Underwater : MonoBehaviour
{
	public float underwaterLevel = 7f;

	public UnityEngine.Color fogCol;

	public float density;

	public bool audio = true;

	public AudioClip above;

	public AudioClip below;

	public AudioSource ammbientSource;

	private bool defaultFog;

	private UnityEngine.Color defaultFogColor;

	private float defaultFogDensity;

	private Material noSkybox;

	private bool aboveWater = true;

	private bool belowWater;

	private void Start()
	{
		defaultFog = RenderSettings.fog;
		defaultFogColor = RenderSettings.fogColor;
		defaultFogDensity = RenderSettings.fogDensity;
	}

	private void Update()
	{
		if (base.transform.position.y < underwaterLevel)
		{
			RenderSettings.fog = true;
			RenderSettings.fogColor = fogCol;
			RenderSettings.fogDensity = density;
			GetComponent<BlurOptimized>().enabled = true;
			if (aboveWater && audio)
			{
				GetComponent<AudioSource>().Stop();
				GetComponent<AudioSource>().clip = below;
				GetComponent<AudioSource>().volume = 1f;
				ammbientSource.Pause();
				GetComponent<AudioSource>().Play();
			}
			aboveWater = false;
			belowWater = true;
		}
		else
		{
			RenderSettings.fog = defaultFog;
			RenderSettings.fogColor = defaultFogColor;
			RenderSettings.fogDensity = defaultFogDensity;
			GetComponent<BlurOptimized>().enabled = false;
			if (belowWater && audio)
			{
				GetComponent<AudioSource>().Stop();
				GetComponent<AudioSource>().clip = above;
				GetComponent<AudioSource>().volume = 0.07f;
				ammbientSource.Play();
				GetComponent<AudioSource>().Play();
			}
			belowWater = false;
			aboveWater = true;
		}
	}
}
public class QualitySetting : MonoBehaviour
{
	public RealWater WaterPlane;

	private float native_width = 1920f;

	private float native_height = 1080f;

	private void OnGUI()
	{
		float x = (float)Screen.width / native_width;
		float y = (float)Screen.height / native_height;
		GUI.matrix = Matrix4x4.TRS(new Vector3(0f, 0f, 0f), Quaternion.identity, new Vector3(x, y, 1f));
		if (GUI.Button(new Rect(57.6f, 172.8f, 96f, 43.2f), "V.Low"))
		{
			WaterPlane.quality = RealWater.Quality.VeryLow;
			WaterPlane.Reset();
			WaterPlane.InputSmoothingSettings.BlurRadius = 0;
			WaterPlane.InputSmoothingSettings.SmoothingLevel = 3;
		}
		if (GUI.Button(new Rect(172.8f, 172.8f, 96f, 43.2f), "Low"))
		{
			WaterPlane.quality = RealWater.Quality.Low;
			WaterPlane.Reset();
			WaterPlane.InputSmoothingSettings.BlurRadius = 1;
			WaterPlane.InputSmoothingSettings.SmoothingLevel = 3;
		}
		if (GUI.Button(new Rect(288f, 172.8f, 96f, 43.2f), "Med"))
		{
			WaterPlane.quality = RealWater.Quality.Medium;
			WaterPlane.Reset();
			WaterPlane.InputSmoothingSettings.BlurRadius = 2;
			WaterPlane.InputSmoothingSettings.SmoothingLevel = 3;
		}
		if (GUI.Button(new Rect(403.19998f, 172.8f, 96f, 43.2f), "High"))
		{
			WaterPlane.quality = RealWater.Quality.High;
			WaterPlane.Reset();
			WaterPlane.InputSmoothingSettings.BlurRadius = 2;
			WaterPlane.InputSmoothingSettings.SmoothingLevel = 3;
		}
		if (GUI.Button(new Rect(518.4f, 172.8f, 96f, 43.2f), "V.High"))
		{
			WaterPlane.quality = RealWater.Quality.VeryHigh;
			WaterPlane.Reset();
			WaterPlane.InputSmoothingSettings.BlurRadius = 3;
			WaterPlane.InputSmoothingSettings.SmoothingLevel = 3;
		}
		if (GUI.Button(new Rect(633.60004f, 172.8f, 105.6f, 43.2f), "Extreme"))
		{
			WaterPlane.quality = RealWater.Quality.Extreme;
			WaterPlane.Reset();
			WaterPlane.InputSmoothingSettings.BlurRadius = 4;
			WaterPlane.InputSmoothingSettings.SmoothingLevel = 3;
		}
	}
}
public class RainSetting : MonoBehaviour
{
	public GUIStyle Normal;

	public RealWater WaterPlane;

	private float native_width = 1920f;

	private float native_height = 1080f;

	private void OnGUI()
	{
		float x = (float)Screen.width / native_width;
		float y = (float)Screen.height / native_height;
		GUI.matrix = Matrix4x4.TRS(new Vector3(0f, 0f, 0f), Quaternion.identity, new Vector3(x, y, 1f));
		GUI.depth = 1;
		GUI.Label(new Rect(57.6f, 248.40001f, 288f, 43.2f), "Rain", Normal);
		bool rainEnabled = GUI.Toggle(new Rect(115.2f, 253.8f, 57.6f, 32.399998f), WaterPlane.RainSettings.RainEnabled, " ");
		WaterPlane.RainSettings.RainEnabled = rainEnabled;
		if (WaterPlane.RainSettings.RainEnabled)
		{
			GUI.Label(new Rect(326.4f, 270f, 153.59999f, 43.2f), "Rain Speed:", Normal);
			GUI.Label(new Rect(326.4f, 324f, 153.59999f, 43.2f), "Rain Force:", Normal);
			WaterPlane.RainSettings.RainSpeed = GUI.HorizontalSlider(new Rect(470.40002f, 278.63998f, 288f, 32.399998f), WaterPlane.RainSettings.RainSpeed, 1f, 30f);
			WaterPlane.RainSettings.RainForce = GUI.HorizontalSlider(new Rect(470.40002f, 336.96002f, 288f, 32.399998f), WaterPlane.RainSettings.RainForce, 0.01f, 1f);
		}
	}
}
public class SpeedSetting : MonoBehaviour
{
	public GUIStyle Normal;

	public RealWaterSpeedManager speedManager;

	private float native_width = 1920f;

	private float native_height = 1080f;

	private void OnGUI()
	{
		float x = (float)Screen.width / native_width;
		float y = (float)Screen.height / native_height;
		GUI.matrix = Matrix4x4.TRS(new Vector3(0f, 0f, 0f), Quaternion.identity, new Vector3(x, y, 1f));
		GUI.Label(new Rect(57.6f, 453.59998f, 288f, 43.2f), "Speed: ", Normal);
		speedManager.Speed = GUI.HorizontalSlider(new Rect(153.59999f, 462.24f, 288f, 32.399998f), speedManager.Speed, 0f, 100f);
	}
}
public class WaveHeightSetting : MonoBehaviour
{
	public GUIStyle Normal;

	public RealWater WaterPlane;

	private float native_width = 1920f;

	private float native_height = 1080f;

	private void OnGUI()
	{
		float x = (float)Screen.width / native_width;
		float y = (float)Screen.height / native_height;
		GUI.matrix = Matrix4x4.TRS(new Vector3(0f, 0f, 0f), Quaternion.identity, new Vector3(x, y, 1f));
		GUI.Label(new Rect(57.6f, 399.6f, 288f, 43.2f), "Wave height: ", Normal);
		WaterPlane.WaveHeight = GUI.HorizontalSlider(new Rect(230.4f, 410.4f, 288f, 32.399998f), WaterPlane.WaveHeight, -0.1f, -5f);
	}
}
[AddComponentMenu("Camera-Control/Mouse Orbit with zoom")]
public class MouseOrbit : MonoBehaviour
{
	public bool AllowRotation = true;

	public bool clickToRotate;

	public Transform target;

	public float distance = 5f;

	public float xSpeed = 120f;

	public float ySpeed = 120f;

	public float yMinLimit = -20f;

	public float yMaxLimit = 80f;

	public float distanceMin = 0.5f;

	public float distanceMax = 15f;

	public float XInit;

	public float YInit = 60f;

	private float x;

	private float y;

	public static bool rightclicked;

	[HideInInspector]
	public int i;

	public void Start()
	{
		x = XInit;
		y = YInit;
		i = 0;
		if ((bool)GetComponent<Rigidbody>())
		{
			GetComponent<Rigidbody>().freezeRotation = true;
		}
	}

	private void LateUpdate()
	{
		if (AllowRotation)
		{
			rightclicked = Input.GetMouseButton(1);
		}
		if (i == 0)
		{
			x += Input.GetAxis("Mouse X") * xSpeed * distance * 0.02f;
			y -= Input.GetAxis("Mouse Y") * ySpeed * 0.02f;
			y = ClampAngle(y, yMinLimit, yMaxLimit);
			Quaternion quaternion = Quaternion.Euler(y, x, 0f);
			distance = Mathf.Clamp(distance - Input.GetAxis("Mouse ScrollWheel") * 5f, distanceMin, distanceMax);
			Vector3 vector = new Vector3(0f, 0f, 0f - distance);
			Vector3 position = quaternion * vector + target.position;
			base.transform.rotation = quaternion;
			base.transform.position = position;
			i = 1;
		}
		else if (clickToRotate)
		{
			if ((bool)target && rightclicked)
			{
				x += Input.GetAxis("Mouse X") * xSpeed * distance * 0.02f;
				y -= Input.GetAxis("Mouse Y") * ySpeed * 0.02f;
				y = ClampAngle(y, yMinLimit, yMaxLimit);
				Quaternion quaternion2 = Quaternion.Euler(y, x, 0f);
				distance = Mathf.Clamp(distance - Input.GetAxis("Mouse ScrollWheel") * 5f, distanceMin, distanceMax);
				Vector3 vector2 = new Vector3(0f, 0f, 0f - distance);
				Vector3 position2 = quaternion2 * vector2 + target.position;
				base.transform.rotation = quaternion2;
				base.transform.position = position2;
			}
		}
		else if ((bool)target && !rightclicked)
		{
			x += Input.GetAxis("Mouse X") * xSpeed * distance * 0.02f;
			y -= Input.GetAxis("Mouse Y") * ySpeed * 0.02f;
			y = ClampAngle(y, yMinLimit, yMaxLimit);
			Quaternion quaternion3 = Quaternion.Euler(y, x, 0f);
			distance = Mathf.Clamp(distance - Input.GetAxis("Mouse ScrollWheel") * 5f, distanceMin, distanceMax);
			Vector3 vector3 = new Vector3(0f, 0f, 0f - distance);
			Vector3 position3 = quaternion3 * vector3 + target.position;
			base.transform.rotation = quaternion3;
			base.transform.position = position3;
		}
	}

	public static float ClampAngle(float angle, float min, float max)
	{
		if (angle < -360f)
		{
			angle += 360f;
		}
		if (angle > 360f)
		{
			angle -= 360f;
		}
		return Mathf.Clamp(angle, min, max);
	}
}
public class SimpleBuoyancy : MonoBehaviour
{
	public float waterLevel;

	public float floatHeight;

	public Vector3 buoyancyCentreOffset;

	public float bounceDamp;

	private Vector3 actionPoint;

	private float forceFactor;

	private Vector3 uplift;

	private void FixedUpdate()
	{
		actionPoint = base.transform.position + base.transform.TransformDirection(buoyancyCentreOffset);
		forceFactor = 1f - (actionPoint.y - waterLevel) / floatHeight;
		if (forceFactor > 0f)
		{
			uplift = -Physics.gravity * (forceFactor - GetComponent<Rigidbody>().velocity.y * bounceDamp);
			GetComponent<Rigidbody>().AddForceAtPosition(uplift, actionPoint);
		}
	}
}
public class MiscGUI : MonoBehaviour
{
	public GUIStyle SubTitle;

	public RealWater WaterPlane;

	private float native_width = 1920f;

	private float native_height = 1080f;

	private void OnGUI()
	{
		float x = (float)Screen.width / native_width;
		float y = (float)Screen.height / native_height;
		GUI.matrix = Matrix4x4.TRS(new Vector3(0f, 0f, 0f), Quaternion.identity, new Vector3(x, y, 1f));
		GUI.depth = 10;
		GUI.Box(new Rect(38.399998f, 32.399998f, 729.6f, 540f), "");
		GUI.Label(new Rect(57.6f, 108f, 288f, 151.2f), string.Concat("Quality: ", WaterPlane.quality, " (", WaterPlane.GetRows(), "x", WaterPlane.GetCols(), ")"), SubTitle);
	}
}
[RequireComponent(typeof(GUITexture))]
public class ForcedReset : MonoBehaviour
{
	private void Update()
	{
		if (CrossPlatformInputManager.GetButtonDown("ResetObject"))
		{
			Application.LoadLevelAsync(Application.loadedLevelName);
		}
	}
}
public class CollisionNodeDescription : MonoBehaviour
{
	public GUIStyle Style;

	public RealWater WaterPlane;

	private float native_width = 1920f;

	private float native_height = 1080f;

	private void OnGUI()
	{
		float x = (float)Screen.width / native_width;
		float y = (float)Screen.height / native_height;
		GUI.matrix = Matrix4x4.TRS(new Vector3(0f, 0f, 0f), Quaternion.identity, new Vector3(x, y, 1f));
		GUI.depth = 10;
		GUI.Box(new Rect(38.399998f, 32.399998f, 576f, 108f), "");
		GUI.Label(new Rect(57.6f, 43.2f, 288f, 151.2f), "White = Normal Water Collider \n\nGray = Collision Nodes ", Style);
	}
}
public class LargePlaneGui : MonoBehaviour
{
	public GUIStyle SubTitle;

	public RealWaterCollider Controller1;

	public RealWaterSpeedManager speedManager;

	public RealWaterNormalMap WaterPlane;

	public GUIStyle Normal;

	public GUIStyle Title;

	private float inputForce = 0.717f;

	private float inputForcePrev = 0.717f;

	private float native_width = 1920f;

	private float native_height = 1080f;

	private void OnGUI()
	{
		float x = (float)Screen.width / native_width;
		float y = (float)Screen.height / native_height;
		GUI.matrix = Matrix4x4.TRS(new Vector3(0f, 0f, 0f), Quaternion.identity, new Vector3(x, y, 1f));
		GUI.depth = 10;
		GUI.Box(new Rect(38.399998f, 81f, 729.6f, 324f), "");
		GUI.Label(new Rect(57.6f, 97.200005f, 288f, 43.2f), "RealWater Settings", Title);
		GUI.Label(new Rect(57.6f, 162f, 288f, 43.2f), "Damping: " + WaterPlane.Damping.ToString("F2"), Normal);
		WaterPlane.Damping = GUI.HorizontalSlider(new Rect(211.2f, 166.31999f, 288f, 32.399998f), WaterPlane.Damping, 0.8f, 0.99f);
		GUI.Label(new Rect(57.6f, 205.2f, 288f, 43.2f), "Speed: " + speedManager.Speed.ToString("F0"), Normal);
		speedManager.Speed = GUI.HorizontalSlider(new Rect(211.2f, 209.52f, 288f, 32.399998f), speedManager.Speed, 10f, 100f);
		GUI.Label(new Rect(57.6f, 248.40001f, 288f, 43.2f), "Simulation Area: " + WaterPlane.simulationSettings.simSize.ToString("F0") + "x" + WaterPlane.simulationSettings.simSize.ToString("F0"), Normal);
		WaterPlane.simulationSettings.simSize = (int)GUI.HorizontalSlider(new Rect(326.4f, 252.72f, 288f, 32.399998f), WaterPlane.simulationSettings.simSize, 90f, 300f);
		GUI.Label(new Rect(57.6f, 291.6f, 288f, 43.2f), "Input Force: " + Controller1.InputForce.ToString("F2"), Normal);
		inputForce = GUI.HorizontalSlider(new Rect(230.4f, 295.91998f, 288f, 32.399998f), Controller1.InputForce, 0.1f, 1f);
		if (inputForcePrev != inputForce)
		{
			Controller1.InputForce = inputForce;
			inputForcePrev = inputForce;
		}
		GUI.Label(new Rect(57.6f, 334.8f, 288f, 43.2f), "Obstruction Texture: ", Normal);
		WaterPlane.obstructionTextureSettings.ObstructionTexturesEnabled = GUI.Toggle(new Rect(268.8f, 334.8f, 60.288f, 32.399998f), WaterPlane.obstructionTextureSettings.ObstructionTexturesEnabled, "");
	}
}
public class AddCollider : MonoBehaviour
{
	public Transform Sphere;

	public RealWaterSpeedManager SpeedManager;

	private float native_width = 1920f;

	private float native_height = 1080f;

	private void OnGUI()
	{
		float x = (float)Screen.width / native_width;
		float y = (float)Screen.height / native_height;
		GUI.matrix = Matrix4x4.TRS(new Vector3(0f, 0f, 0f), Quaternion.identity, new Vector3(x, y, 1f));
		if (GUI.Button(new Rect(57.6f, 324f, 288f, 43.2f), "Add Sphere"))
		{
			UnityEngine.Object.Instantiate(Sphere, new Vector3(22f, 5f, 20f), Quaternion.identity);
			SpeedManager.FindColliders();
		}
	}
}
public class RealWaterCollisionNode : MonoBehaviour
{
	public enum Objecttype
	{
		RigidBody,
		CharacterController
	}

	[HideInInspector]
	public float XCoord;

	[HideInInspector]
	public float YCoord;

	[HideInInspector]
	public bool Colliding;

	[HideInInspector]
	public int HitPlaneID;

	[HideInInspector]
	public bool CheckWaterCollision = true;

	public GameObject ParentCollider;

	[Tooltip("Is the collider a Rigidbody or a Character controller?")]
	public Objecttype ObjectType;

	[Tooltip("Force Multiplier")]
	[Range(0.01f, 1f)]
	public float InputForce = 1f;

	[Tooltip("Only check for collisions if the collider velocity exceeds this value")]
	public float VelocityLimit = 0.05f;

	[Tooltip("Raycast origin position offset.")]
	public Vector3 RaycastOffset;

	public float RaycastLength = 1f;

	[Tooltip("Extrapolates between input points, allows for smoother more consistent input.")]
	public bool ExtrapolateInput = true;

	[Tooltip("Disables the visibility check so water collider will always check for collisions even when not visible.")]
	public bool FirstPersonMode;

	[Tooltip("Enables collision logging and ray drawing in the inspector. Also removes the velocity limitation.Very useful for Setup.")]
	public bool DebugMode;

	[HideInInspector]
	public float collisionCheckFrequency = 60f;

	private bool IsCharController;

	private bool IsRigidbody;

	private CharacterController controller;

	private RaycastHit Hit;

	private int BaseForce = 18000000;

	[HideInInspector]
	public bool Visible = true;

	private bool FirstPoint = true;

	private bool FirstClick = true;

	private int x1;

	private int x2;

	private int y1;

	private int y2;

	private int Plane1;

	private int Plane2;

	public static bool Reseting;

	private int deltax;

	private int deltay;

	private int xinc1;

	private int xinc2;

	private int yinc1;

	private int yinc2;

	private int denominator;

	private int numerator;

	private int numadd;

	private int NumberOfPoints;

	private float ZPositionCurrent;

	private float XPositionCurrent;

	private float ZPositionPrevious;

	private float XPositionPrevious;

	private bool FirstRun = true;

	private void Start()
	{
		switch (ObjectType)
		{
		case Objecttype.CharacterController:
			IsCharController = true;
			controller = ParentCollider.GetComponent<CharacterController>();
			break;
		case Objecttype.RigidBody:
			IsRigidbody = true;
			break;
		}
		if (DebugMode)
		{
			VelocityLimit = -1f;
		}
		if (!FirstPersonMode && !DebugMode)
		{
			InvokeRepeating("VisibilityCheck", 0.001f, 0.2f);
		}
		InvokeRepeating("PositionCheck1", 0.001f, 1f / 30f);
	}

	private void Update()
	{
		if (Reseting)
		{
			FirstClick = true;
		}
		ZPositionCurrent = ParentCollider.gameObject.transform.position.z;
		XPositionCurrent = ParentCollider.gameObject.transform.position.x;
	}

	private void PositionCheck1()
	{
		ZPositionPrevious = Mathf.Round(base.transform.position.z * 10f) / 10f;
		XPositionPrevious = Mathf.Round(base.transform.position.x * 10f) / 10f;
		Invoke("PositionCheck2", 1f);
	}

	private void PositionCheck2()
	{
		ZPositionCurrent = Mathf.Round(base.transform.position.z * 10f) / 10f;
		XPositionCurrent = Mathf.Round(base.transform.position.x * 10f) / 10f;
		if (ZPositionCurrent == ZPositionPrevious && XPositionCurrent == XPositionPrevious)
		{
			CheckWaterCollision = false;
		}
		else
		{
			CheckWaterCollision = true;
		}
	}

	private void OnDisable()
	{
		CancelInvoke();
		RealWaterSpeedManager realWaterSpeedManager = UnityEngine.Object.FindObjectOfType(typeof(RealWaterSpeedManager)) as RealWaterSpeedManager;
		if (realWaterSpeedManager != null)
		{
			realWaterSpeedManager.FindCollisionNodes();
		}
	}

	private void OnEnable()
	{
		if (!FirstRun)
		{
			RealWaterSpeedManager realWaterSpeedManager = UnityEngine.Object.FindObjectOfType(typeof(RealWaterSpeedManager)) as RealWaterSpeedManager;
			if (realWaterSpeedManager != null)
			{
				realWaterSpeedManager.FindCollisionNodes();
			}
			if (!FirstPersonMode && !DebugMode)
			{
				InvokeRepeating("VisibilityCheck", 0.001f, 0.2f);
			}
			InvokeRepeating("PositionCheck1", 0.001f, 1f / 30f);
		}
		else
		{
			FirstRun = false;
		}
	}

	private void VisibilityCheck()
	{
		if (!ParentCollider.GetComponent<Renderer>().isVisible && !DebugMode)
		{
			CancelInvoke("PositionCheck1");
			CancelInvoke("CheckForCollisions");
			Visible = false;
		}
		else if (!Visible && ParentCollider.GetComponent<Renderer>().isVisible)
		{
			InvokeRepeating("CheckForCollisions", 0.005f, 1f / collisionCheckFrequency);
			InvokeRepeating("PositionCheck1", 0.001f, 1f / 30f);
			FirstClick = true;
			Visible = true;
		}
	}

	public void CheckForCollisions()
	{
		if (CheckWaterCollision)
		{
			if (IsRigidbody)
			{
				if (Physics.Raycast(base.transform.position + RaycastOffset, Vector3.down, out Hit, RaycastLength))
				{
					if (DebugMode)
					{
						MonoBehaviour.print(Hit.collider.gameObject.name);
					}
					if (Hit.collider.gameObject.name == "RealWater Plane")
					{
						if (ParentCollider.GetComponent<Rigidbody>().velocity.magnitude > VelocityLimit)
						{
							XCoord = Hit.textureCoord.x;
							YCoord = Hit.textureCoord.y;
							int rows = Hit.collider.gameObject.GetComponent<RealWaterInterface>().GetRows();
							int cols = Hit.collider.gameObject.GetComponent<RealWaterInterface>().GetCols();
							int bR = Hit.collider.gameObject.GetComponent<RealWaterInterface>().GetBR();
							float num = YCoord * ((float)rows + 1f);
							float num2 = XCoord * ((float)cols + 1f);
							if ((int)num2 > bR + 1 && (int)num2 < cols - bR + 1 && (int)num < rows - (bR + 2) && (int)num > bR + 1)
							{
								if (ExtrapolateInput)
								{
									if (!FirstClick)
									{
										if (FirstPoint)
										{
											x1 = (int)num;
											y1 = (int)num2;
											Plane1 = Hit.collider.GetInstanceID();
										}
										else
										{
											x2 = (int)num;
											y2 = (int)num2;
											Plane2 = Hit.collider.GetInstanceID();
										}
										if (Plane1 == Plane2)
										{
											BresenhamLineAlgorithm(x1, x2, y1, y2);
										}
										FirstPoint = !FirstPoint;
									}
									else
									{
										x1 = (int)num;
										y1 = (int)num2;
										x2 = (int)num;
										y2 = (int)num2;
										FirstClick = false;
									}
								}
								else
								{
									Hit.collider.gameObject.GetComponent<RealWaterInterface>().DisturbBufferAt((int)num, (int)num2, (int)(18000000f * InputForce), ambient: false);
								}
							}
							else
							{
								FirstClick = true;
							}
						}
					}
					else
					{
						FirstClick = true;
					}
				}
				else
				{
					FirstClick = true;
				}
			}
			else if (IsCharController)
			{
				if (Physics.Raycast(base.transform.position + RaycastOffset, Vector3.down, out Hit, RaycastLength))
				{
					if (DebugMode)
					{
						MonoBehaviour.print(Hit.collider.gameObject.name);
					}
					if (Hit.collider.gameObject.name == "RealWater Plane")
					{
						if (controller.velocity.magnitude > VelocityLimit)
						{
							XCoord = Hit.textureCoord.x;
							YCoord = Hit.textureCoord.y;
							int rows2 = Hit.collider.gameObject.GetComponent<RealWaterInterface>().GetRows();
							int cols2 = Hit.collider.gameObject.GetComponent<RealWaterInterface>().GetCols();
							int bR2 = Hit.collider.gameObject.GetComponent<RealWaterInterface>().GetBR();
							float num3 = YCoord * ((float)rows2 + 1f);
							float num4 = XCoord * ((float)cols2 + 1f);
							if ((int)num4 > bR2 + 1 && (int)num4 < cols2 - bR2 + 1 && (int)num3 < rows2 - (bR2 + 2) && (int)num3 > bR2 + 1)
							{
								if (ExtrapolateInput)
								{
									if (!FirstClick)
									{
										if (FirstPoint)
										{
											x1 = (int)num3;
											y1 = (int)num4;
											Plane1 = Hit.collider.GetInstanceID();
										}
										else
										{
											x2 = (int)num3;
											y2 = (int)num4;
											Plane2 = Hit.collider.GetInstanceID();
										}
										if (Plane1 == Plane2)
										{
											BresenhamLineAlgorithm(x1, x2, y1, y2);
										}
										FirstPoint = !FirstPoint;
									}
									else
									{
										x1 = (int)num3;
										y1 = (int)num4;
										x2 = (int)num3;
										y2 = (int)num4;
										FirstClick = false;
									}
								}
								else
								{
									Hit.collider.gameObject.GetComponent<RealWaterInterface>().DisturbBufferAt((int)num3, (int)num4, (int)(18000000f * InputForce), ambient: false);
								}
							}
							else
							{
								FirstClick = true;
							}
						}
					}
					else
					{
						FirstClick = true;
					}
				}
				else
				{
					FirstClick = true;
				}
			}
		}
		if (DebugMode)
		{
			UnityEngine.Debug.DrawRay(base.transform.position + RaycastOffset, Vector3.down.normalized * RaycastLength, UnityEngine.Color.red, 0.01f, depthTest: false);
		}
	}

	private void BresenhamLineAlgorithm(int x1, int x2, int y1, int y2)
	{
		int num = x2 - x1;
		int num2 = y2 - y1;
		int num3;
		int num4;
		if (num >= 0)
		{
			num3 = 1;
			num4 = 1;
		}
		else
		{
			num3 = -1;
			num4 = -1;
		}
		int num5;
		int num6;
		if (num2 >= 0)
		{
			num5 = 1;
			num6 = 1;
		}
		else
		{
			num5 = -1;
			num6 = -1;
		}
		num = Mathf.Abs(num);
		num2 = Mathf.Abs(num2);
		int num7;
		int num8;
		int num9;
		int num10;
		if (num >= num2)
		{
			num3 = 0;
			num6 = 0;
			num7 = num;
			num8 = num / 2;
			num9 = num2;
			num10 = num;
		}
		else
		{
			num4 = 0;
			num5 = 0;
			num7 = num2;
			num8 = num2 / 2;
			num9 = num;
			num10 = num2;
		}
		int num11 = x1;
		int num12 = y1;
		for (int i = 0; i <= num10; i++)
		{
			Hit.collider.gameObject.GetComponent<RealWaterInterface>().DisturbBufferAt(num11, num12, (int)(18000000f * InputForce), ambient: false);
			num8 += num9;
			if (num8 >= num7)
			{
				num8 -= num7;
				num11 += num3;
				num12 += num5;
			}
			num11 += num4;
			num12 += num6;
		}
	}
}
public class BresenhamLineDrawer
{
	private int baseForce = 18000000;

	public void DrawLine(int x1, int x2, int y1, int y2, RaycastHit hit, float inputForce)
	{
		int num = x2 - x1;
		int num2 = y2 - y1;
		int num3;
		int num4;
		if (num >= 0)
		{
			num3 = 1;
			num4 = 1;
		}
		else
		{
			num3 = -1;
			num4 = -1;
		}
		int num5;
		int num6;
		if (num2 >= 0)
		{
			num5 = 1;
			num6 = 1;
		}
		else
		{
			num5 = -1;
			num6 = -1;
		}
		num = Mathf.Abs(num);
		num2 = Mathf.Abs(num2);
		int num7;
		int num8;
		int num9;
		int num10;
		if (num >= num2)
		{
			num3 = 0;
			num6 = 0;
			num7 = num;
			num8 = num / 2;
			num9 = num2;
			num10 = num;
		}
		else
		{
			num4 = 0;
			num5 = 0;
			num7 = num2;
			num8 = num2 / 2;
			num9 = num;
			num10 = num2;
		}
		int num11 = x1;
		int num12 = y1;
		for (int i = 0; i <= num10; i++)
		{
			hit.collider.gameObject.GetComponent<RealWaterInterface>().DisturbBufferAt(num11, num12, (int)((float)baseForce * inputForce), ambient: false);
			num8 += num9;
			if (num8 >= num7)
			{
				num8 -= num7;
				num11 += num3;
				num12 += num5;
			}
			num11 += num4;
			num12 += num6;
		}
	}
}
public class CrouchDetection : MonoBehaviour
{
	public RealWaterCollider Collider;

	[Tooltip("The crouch key you are using.")]
	public string CrouchKeyIdentifier = "c";

	private void Update()
	{
		if (Input.GetKey(CrouchKeyIdentifier))
		{
			Collider.SetCrouching(val: true);
			Collider.SetCheckCollisions(val: false);
			Collider.Reset();
		}
		if (Input.GetKeyUp(CrouchKeyIdentifier))
		{
			Collider.SetCrouching(val: false);
			Collider.SetCheckCollisions(val: true);
			Collider.Reset();
		}
	}
}
public class FPSCapper : MonoBehaviour
{
	[Range(60f, 240f)]
	public int FramerateCap = 60;

	public bool UnlockFPS;

	[Tooltip("Set to true to change Framerate Cap during runtime.")]
	public bool Reset;

	private void Start()
	{
		if (UnlockFPS)
		{
			Application.targetFrameRate = 0;
		}
		else
		{
			Application.targetFrameRate = FramerateCap;
		}
	}

	private void Update()
	{
		if (Reset)
		{
			if (UnlockFPS)
			{
				Application.targetFrameRate = 0;
			}
			else
			{
				Application.targetFrameRate = FramerateCap;
			}
		}
		Reset = false;
	}
}
public static class InterfaceHelper
{
	private static Dictionary<Type, List<Type>> _interfaceToComponentMapping;

	private static Type[] _allTypes;

	static InterfaceHelper()
	{
		InitInterfaceToComponentMapping();
	}

	private static void InitInterfaceToComponentMapping()
	{
		_interfaceToComponentMapping = new Dictionary<Type, List<Type>>();
		_allTypes = GetAllTypes();
		Type[] allTypes = _allTypes;
		foreach (Type type in allTypes)
		{
			if (!type.IsInterface)
			{
				continue;
			}
			string text = type.ToString().ToLower();
			if (text.Contains("unity") || text.Contains("system.") || text.Contains("mono.") || text.Contains("mono.") || text.Contains("icsharpcode.") || text.Contains("nsubstitute") || text.Contains("nunit.") || text.Contains("microsoft.") || text.Contains("boo.") || text.Contains("serializ") || text.Contains("json") || text.Contains("log.") || text.Contains("logging") || text.Contains("test") || text.Contains("editor") || text.Contains("debug"))
			{
				continue;
			}
			IList<Type> typesInheritedFromInterface = GetTypesInheritedFromInterface(type);
			if (typesInheritedFromInterface.Count <= 0)
			{
				continue;
			}
			List<Type> list = new List<Type>();
			foreach (Type item in typesInheritedFromInterface)
			{
				if (!item.IsInterface && (typeof(UnityEngine.Component) == item || item.IsSubclassOf(typeof(UnityEngine.Component))) && !list.Contains(item))
				{
					list.Add(item);
				}
			}
			_interfaceToComponentMapping.Add(type, list);
		}
	}

	private static Type[] GetAllTypes()
	{
		List<Type> list = new List<Type>();
		Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
		foreach (Assembly assembly in assemblies)
		{
			list.AddRange(assembly.GetTypes());
		}
		return list.ToArray();
	}

	private static IEnumerable<Type> GetTypesInheritedFromInterface<T>() where T : class
	{
		return GetTypesInheritedFromInterface(typeof(T));
	}

	private static IList<Type> GetTypesInheritedFromInterface(Type type)
	{
		if (_allTypes == null)
		{
			_allTypes = GetAllTypes();
		}
		List<Type> list = new List<Type>();
		Type[] allTypes = _allTypes;
		foreach (Type type2 in allTypes)
		{
			if (type.IsAssignableFrom(type2) && type2.IsSubclassOf(typeof(UnityEngine.Component)))
			{
				list.Add(type2);
			}
		}
		return list;
	}

	public static T[] FindObjects<T>(bool firstOnly = false) where T : class
	{
		List<T> list = new List<T>();
		List<Type> list2 = _interfaceToComponentMapping[typeof(T)];
		if (list2 == null || list2.Count <= 0)
		{
			UnityEngine.Debug.LogError("No descendants found for type " + typeof(T));
			return null;
		}
		foreach (Type item2 in list2)
		{
			UnityEngine.Object[] array = ((!firstOnly) ? UnityEngine.Object.FindObjectsOfType(item2) : new UnityEngine.Object[1] { UnityEngine.Object.FindObjectOfType(item2) });
			if (array == null || array.Length == 0)
			{
				continue;
			}
			List<T> list3 = new List<T>();
			UnityEngine.Object[] array2 = array;
			foreach (UnityEngine.Object @object in array2)
			{
				if (!(@object is T item))
				{
					UnityEngine.Debug.LogError(string.Concat("Unable to cast '", @object.GetType(), "' to '", typeof(T), "'"));
				}
				else
				{
					list3.Add(item);
				}
			}
			list.AddRange(list3);
		}
		T[] array3 = new T[list.Count];
		list.CopyTo(array3, 0);
		return array3;
	}

	public static T FindObject<T>() where T : class
	{
		return FindObjects<T>()[0];
	}

	public static IList<T> GetInterfaceComponents<T>(this UnityEngine.Component component, bool firstOnly = false) where T : class
	{
		List<Type> list = _interfaceToComponentMapping[typeof(T)];
		if (list == null || list.Count <= 0)
		{
			UnityEngine.Debug.LogError("No descendants found for type " + typeof(T));
			return null;
		}
		List<T> list2 = new List<T>();
		foreach (Type item2 in list)
		{
			UnityEngine.Component[] array = ((!firstOnly) ? component.GetComponents(item2) : new UnityEngine.Component[1] { component.GetComponent(item2) });
			if (array == null || array.Length == 0)
			{
				continue;
			}
			List<T> list3 = new List<T>();
			UnityEngine.Component[] array2 = array;
			foreach (UnityEngine.Component component2 in array2)
			{
				if (!(component2 is T item))
				{
					UnityEngine.Debug.LogError(string.Concat("Unable to cast '", component2.GetType(), "' to '", typeof(T), "'"));
				}
				else
				{
					list3.Add(item);
				}
			}
			list2.AddRange(list3);
		}
		return list2;
	}

	public static T GetInterfaceComponent<T>(this UnityEngine.Component component) where T : class
	{
		return component.GetInterfaceComponents<T>(firstOnly: true)[0];
	}
}
[RequireComponent(typeof(MeshFilter))]
public class ReverseNormals : MonoBehaviour
{
	private void Start()
	{
		MeshFilter meshFilter = GetComponent(typeof(MeshFilter)) as MeshFilter;
		if (!(meshFilter != null))
		{
			return;
		}
		Mesh mesh = meshFilter.mesh;
		Vector3[] normals = mesh.normals;
		for (int i = 0; i < normals.Length; i++)
		{
			normals[i] = -normals[i];
		}
		mesh.normals = normals;
		for (int j = 0; j < mesh.subMeshCount; j++)
		{
			int[] triangles = mesh.GetTriangles(j);
			for (int k = 0; k < triangles.Length; k += 3)
			{
				int num = triangles[k];
				triangles[k] = triangles[k + 1];
				triangles[k + 1] = num;
			}
			mesh.SetTriangles(triangles, j);
		}
	}
}
public class RealWater : MonoBehaviour, RealWaterInterface
{
	public enum Quality
	{
		VeryLow,
		Low,
		Medium,
		High,
		VeryHigh,
		Extreme
	}

	public enum Shape
	{
		Square,
		Rectangular
	}

	public Quality quality;

	public Shape shape;

	[Tooltip("If enabled the simulation will stop and start depending on whether the main input is colliding with the plane or not.")]
	public AmbientSettings AmbientSettings;

	public InputSmoothingSettings InputSmoothingSettings;

	public ObstructionSettings ObstructionSettings;

	public ObstructionTextureSettings ObstructionTextureSettings;

	public IndentTextureSettings IndentTextureSettings;

	public RainSettings RainSettings;

	public CollisionCullingSettings collisionCullingSettings;

	[Tooltip("Whether to recalculate mesh normals every simulation step.")]
	public bool CalculateNormals = true;

	[Tooltip("Whether to calculate tangents for the mesh (Only enable if needed, big performance hit!).")]
	public bool CalculateTangents;

	[Tooltip("Wave dissipation multiplier (Higher values-> Less dissipation).")]
	[Range(0.9f, 0.999f)]
	public float Damping = 0.97f;

	[Tooltip("Scaling factor applied to wave height.")]
	[Range(-12f, 12f)]
	public float WaveHeight = -2f;

	[Tooltip("Need to Manually assign these if not using a prefab or if using custom Meshes")]
	public Meshes Meshes;

	private int[] buffer1;

	private int[] buffer2;

	private int[] bufferCurrent;

	private int[] buffer1Amb;

	private int[] buffer2Amb;

	private int[] bufferCurrentAmb;

	private TextureScanner textureScanner;

	private int columns;

	private int rows;

	private int baseForce = 18000000;

	private Mesh waterMesh;

	private bool buffer1Current = true;

	private int verticesArrayLength;

	private RealWaterMouseInput inputManager;

	private Vector3[] vertices;

	private bool allowInput = true;

	private float simulationSpeed;

	private float ambientTimer;

	private bool visible = true;

	private bool ambientStopped;

	private bool ready;

	private bool indentScanned;

	private Renderer rend;

	private bool paused = true;

	private int[] obstructedPositions;

	private int obstructionCounter;

	private int[] obstructedTexturePositions;

	private int[] obstructionTextureColumns;

	private int[] obstructionTextureRows;

	private int obstructionTextureCounter;

	private bool obstructionsScanned;

	private bool obstructionTextuReScanned;

	private int[] indentTextureColumns;

	private int[] indentTextureRows;

	private float[] indentTextureGrayscaleValues;

	private int indentTextureCounter;

	private float ambientSpeedCurrent;

	private float rainSpeedCurrent;

	private bool obstructionTexturesEnabledCurrent;

	private bool obstructionsEnabledCurrent;

	private void Start()
	{
		AssignMesh();
		if (CalculateTangents)
		{
			TangentSolver(waterMesh);
		}
		initializeVariables();
		if (ObstructionSettings.ObstructionsEnabled)
		{
			ObstructionDetection();
		}
		if (ObstructionTextureSettings.ObstructionTexturesEnabled)
		{
			ProcessObstructionTexture();
		}
		if (IndentTextureSettings.IndentTextureEnabled)
		{
			ProcessIndentTexture();
		}
		if (AmbientSettings.AmbientMode)
		{
			InitializeAmbientMode();
			return;
		}
		InvokeRepeating("VariableChangeCheck", 0.001f, 1f / 30f);
		InvokeRepeating("RainDrops", 0.003f, 1f / RainSettings.RainSpeed);
		InvokeRepeating("VisibilityCheck", 0.001f, 0.2f);
	}

	private void Update()
	{
		if (ambientTimer < AmbientSettings.AmbientStartRuntime && ready)
		{
			ambientTimer += Time.deltaTime;
		}
	}

	private void AssignMesh()
	{
		switch (shape)
		{
		case Shape.Square:
			switch (quality)
			{
			case Quality.VeryLow:
				if (Meshes.VeryLow != null)
				{
					GetComponent<MeshFilter>().mesh = Meshes.VeryLow;
				}
				else
				{
					UnityEngine.Debug.LogError("Mesh(Very Low) not assigned, please stop the game and assign mesh in the inspector");
				}
				break;
			case Quality.Low:
				if (Meshes.Low != null)
				{
					GetComponent<MeshFilter>().mesh = Meshes.Low;
				}
				else
				{
					UnityEngine.Debug.LogError("Mesh(Low) not assigned, please stop the game and assign mesh in the inspector");
				}
				break;
			case Quality.Medium:
				if (Meshes.Medium != null)
				{
					GetComponent<MeshFilter>().mesh = Meshes.Medium;
				}
				else
				{
					UnityEngine.Debug.LogError("Mesh(Medium) not assigned, please stop the game and assign mesh in the inspector");
				}
				break;
			case Quality.High:
				if (Meshes.High != null)
				{
					GetComponent<MeshFilter>().mesh = Meshes.High;
				}
				else
				{
					UnityEngine.Debug.LogError("Mesh(High) not assigned, please stop the game and assign mesh in the inspector");
				}
				break;
			case Quality.VeryHigh:
				if (Meshes.VeryHigh != null)
				{
					GetComponent<MeshFilter>().mesh = Meshes.VeryHigh;
				}
				else
				{
					UnityEngine.Debug.LogError("Mesh(VeryHigh) not assigned, please stop the game and assign mesh in the inspector");
				}
				break;
			case Quality.Extreme:
				if (Meshes.Extreme != null)
				{
					GetComponent<MeshFilter>().mesh = Meshes.Extreme;
				}
				else
				{
					UnityEngine.Debug.LogError("Mesh(Extreme) not assigned, please stop the game and assign mesh in the inspector");
				}
				break;
			}
			break;
		case Shape.Rectangular:
			switch (quality)
			{
			case Quality.VeryLow:
				if (Meshes.VeryLow_Rect != null)
				{
					GetComponent<MeshFilter>().mesh = Meshes.VeryLow_Rect;
				}
				else
				{
					UnityEngine.Debug.LogError("Mesh(Very Low_Rect) not assigned, please stop the game and assign mesh in the inspector");
				}
				break;
			case Quality.Low:
				if (Meshes.Low_Rect != null)
				{
					GetComponent<MeshFilter>().mesh = Meshes.Low_Rect;
				}
				else
				{
					UnityEngine.Debug.LogError("Mesh(Low_Rect) not assigned, please stop the game and assign mesh in the inspector");
				}
				break;
			case Quality.Medium:
				if (Meshes.Medium_Rect != null)
				{
					GetComponent<MeshFilter>().mesh = Meshes.Medium_Rect;
				}
				else
				{
					UnityEngine.Debug.LogError("Mesh(Medium_Rect) not assigned, please stop the game and assign mesh in the inspector");
				}
				break;
			case Quality.High:
				if (Meshes.High_Rect != null)
				{
					GetComponent<MeshFilter>().mesh = Meshes.High_Rect;
				}
				else
				{
					UnityEngine.Debug.LogError("Mesh(High_Rect) not assigned, please stop the game and assign mesh in the inspector");
				}
				break;
			case Quality.VeryHigh:
				if (Meshes.VeryHigh_Rect != null)
				{
					GetComponent<MeshFilter>().mesh = Meshes.VeryHigh_Rect;
				}
				else
				{
					UnityEngine.Debug.LogError("Mesh(VeryHigh_Rect) not assigned, please stop the game and assign mesh in the inspector");
				}
				break;
			case Quality.Extreme:
				if (Meshes.Extreme_Rect != null)
				{
					GetComponent<MeshFilter>().mesh = Meshes.Extreme_Rect;
				}
				else
				{
					UnityEngine.Debug.LogError("Mesh(Extreme_Rect) not assigned, please stop the game and assign mesh in the inspector");
				}
				break;
			}
			break;
		}
		string[] array = Regex.Split(GetComponent<MeshFilter>().mesh.name, "\\D+");
		int num = 0;
		string[] array2 = array;
		for (int i = 0; i < array2.Length; i++)
		{
			if (int.TryParse(array2[i], out var result))
			{
				switch (num)
				{
				case 0:
					columns = result;
					break;
				case 1:
					rows = result;
					break;
				}
				num++;
			}
		}
		waterMesh = ((MeshFilter)GetComponent(typeof(MeshFilter))).mesh;
	}

	private void initializeVariables()
	{
		inputManager = UnityEngine.Object.FindObjectOfType(typeof(RealWaterMouseInput)) as RealWaterMouseInput;
		rend = GetComponent<Renderer>();
		vertices = waterMesh.vertices;
		verticesArrayLength = vertices.Length;
		buffer1 = new int[verticesArrayLength];
		buffer2 = new int[verticesArrayLength];
		buffer1Amb = new int[verticesArrayLength];
		buffer2Amb = new int[verticesArrayLength];
		bufferCurrentAmb = buffer1Amb;
		bufferCurrent = buffer1;
		rainSpeedCurrent = RainSettings.RainSpeed;
		obstructionTexturesEnabledCurrent = ObstructionTextureSettings.ObstructionTexturesEnabled;
		textureScanner = new TextureScanner(rows, columns);
		ambientTimer = 0f;
		AmbientSettings.AmbientModeInitial = AmbientSettings.AmbientMode;
		visible = true;
	}

	public void Pause()
	{
		CancelInvoke("MainLoop");
		CancelInvoke("VariableChangeCheck");
		CancelInvoke("RainDrops");
		CancelInvoke("SetObstructionTexture");
		CancelInvoke("SetObstructions");
		for (int i = 0; i < verticesArrayLength; i++)
		{
			buffer1[i] = 0;
			buffer2[i] = 0;
			vertices[i].y = 0f;
		}
		waterMesh.vertices = vertices;
		if (CalculateNormals)
		{
			waterMesh.RecalculateNormals();
		}
		paused = true;
	}

	public void Play()
	{
		if (paused)
		{
			InvokeRepeating("MainLoop", 0.001f, 1f / simulationSpeed);
			if (ObstructionTextureSettings.ObstructionTexturesEnabled && ObstructionTextureSettings.SetRate == ObstructionTextureSettings.setRate.Half)
			{
				InvokeRepeating("SetObstructionTexture", 0.008f, 1f / (simulationSpeed * 0.55f));
			}
			else if (ObstructionTextureSettings.ObstructionTexturesEnabled && ObstructionTextureSettings.SetRate == ObstructionTextureSettings.setRate.Full)
			{
				InvokeRepeating("SetObstructionTexture", 0.008f, 1f / simulationSpeed);
			}
			if (ObstructionSettings.ObstructionsEnabled && ObstructionSettings.SetRate == ObstructionSettings.setRate.Half)
			{
				InvokeRepeating("SetObstructions", 0.003f, 1f / (simulationSpeed * 0.55f));
			}
			else if (ObstructionSettings.ObstructionsEnabled && ObstructionSettings.SetRate == ObstructionSettings.setRate.Full)
			{
				InvokeRepeating("SetObstructions", 0.003f, 1f / simulationSpeed);
			}
			obstructionsEnabledCurrent = ObstructionSettings.ObstructionsEnabled;
			obstructionTexturesEnabledCurrent = ObstructionTextureSettings.ObstructionTexturesEnabled;
			InvokeRepeating("VariableChangeCheck", 0.001f, 1f / 30f);
			InvokeRepeating("RainDrops", 0.003f, 1f / RainSettings.RainSpeed);
			paused = false;
			visible = true;
		}
	}

	public void ObstructionDetection()
	{
		List<int> list = new List<int>();
		Vector3 center = rend.bounds.center;
		float num = rend.bounds.size.x / 2f;
		float num2 = rend.bounds.size.z / 2f;
		float num3 = center[0] - num;
		float num4 = center[0] + num;
		float num5 = center[2] + num2;
		float num6 = center[2] - num2;
		float num7 = (num4 - num3) / (float)(columns + 1);
		float num8 = (num5 - num6) / (float)(rows + 1);
		float y = center[1];
		for (float num9 = num3; num9 < num4; num9 += num7)
		{
			for (float num10 = num6; num10 < num5; num10 += num8)
			{
				Vector3 vector = new Vector3(num9, y, num10);
				if (Physics.Raycast(vector + Vector3.up * ObstructionSettings.heightCuttoff, Vector3.down, out var hitInfo, ObstructionSettings.heightCuttoff) && hitInfo.collider.gameObject.name != "RealWater Plane" && hitInfo.collider.gameObject.GetComponent<RealWaterCollider>() == null && !hitInfo.collider.gameObject.name.Contains("RW-NonOb") && hitInfo.collider.gameObject.GetComponent<Camera>() == null && Physics.Raycast(vector + Vector3.up * 0.01f, Vector3.down, out var hitInfo2, 0.01f) && hitInfo2.collider.gameObject.name == "RealWater Plane")
				{
					int num11 = (int)(hitInfo2.textureCoord.x * (float)columns);
					int item = (int)(hitInfo2.textureCoord.y * (float)rows) * (columns + 1) + num11;
					list.Add(item);
					obstructionCounter++;
				}
			}
		}
		obstructedPositions = list.ToArray();
		list.Clear();
		list.TrimExcess();
		obstructionsScanned = true;
	}

	public void ProcessObstructionTexture()
	{
		bool flag = true;
		if (ObstructionTextureSettings.ObstructionTexture != null)
		{
			try
			{
				ObstructionTextureSettings.ObstructionTexture.GetPixel(0, 0);
			}
			catch (UnityException ex)
			{
				if (ex.Message.StartsWith("Texture '" + ObstructionTextureSettings.ObstructionTexture.name + "' is not readable"))
				{
					UnityEngine.Debug.LogError("Please enable read/write for Obstruction Texture: [" + ObstructionTextureSettings.ObstructionTexture.name + "]");
					flag = false;
				}
			}
			if (flag)
			{
				textureScanner.setTexture(ObstructionTextureSettings.ObstructionTexture);
				textureScanner.setGSCuttOff(ObstructionTextureSettings.GrayScaleCuttoff);
				obstructionTextuReScanned = textureScanner.ProcessTexture();
				obstructionTextureColumns = textureScanner.getCols();
				obstructionTextureRows = textureScanner.getRows();
				obstructionTextureCounter = textureScanner.getCount();
				obstructedTexturePositions = new int[obstructionTextureCounter];
				for (int i = 0; i < obstructionTextureCounter; i++)
				{
					obstructedTexturePositions[i] = obstructionTextureRows[i] * columns + obstructionTextureColumns[i];
				}
			}
		}
		else
		{
			obstructionTextuReScanned = true;
			UnityEngine.Debug.LogError("No Obstruction Texture Assigned");
		}
	}

	public void ProcessIndentTexture()
	{
		bool flag = true;
		if (IndentTextureSettings.IndentTexture != null)
		{
			try
			{
				IndentTextureSettings.IndentTexture.GetPixel(0, 0);
			}
			catch (UnityException ex)
			{
				if (ex.Message.StartsWith("Texture '" + IndentTextureSettings.IndentTexture.name + "' is not readable"))
				{
					UnityEngine.Debug.LogError("Please enable read/write for Indent Texture: [" + IndentTextureSettings.IndentTexture.name + "]");
					flag = false;
				}
			}
			if (flag)
			{
				textureScanner.setTexture(IndentTextureSettings.IndentTexture);
				textureScanner.setGSCuttOff(IndentTextureSettings.GrayScaleCuttoff);
				indentScanned = textureScanner.ProcessTexture();
				indentTextureColumns = textureScanner.getCols();
				indentTextureRows = textureScanner.getRows();
				indentTextureGrayscaleValues = textureScanner.getGrayscaleValues();
				indentTextureCounter = textureScanner.getCount();
			}
		}
		else
		{
			indentScanned = true;
			UnityEngine.Debug.LogError("No Indent Texture Assigned");
		}
	}

	private void InitializeAmbientMode()
	{
		for (int i = 0; i < AmbientSettings.AmbientWaveIntensity; i++)
		{
			DisturbBufferAt(UnityEngine.Random.Range(12, rows - 11), UnityEngine.Random.Range(12, columns - 11), baseForce, ambient: true);
		}
		AmbientSettings.AmbientModeInitial = true;
		ambientSpeedCurrent = AmbientSettings.AmbientSpeed;
		if (!AmbientSettings.Interactive)
		{
			InvokeRepeating("AmbientMainLoop", 0.001f, 1f / AmbientSettings.AmbientSpeed);
			allowInput = false;
		}
		else
		{
			InvokeRepeating("RainDrops", 0.003f, 1f / RainSettings.RainSpeed);
			RainDrops();
		}
		SetPaused(val: false);
		InvokeRepeating("VariableChangeCheck", 0.001f, 1f / 30f);
		InvokeRepeating("VisibilityCheck", 0.001f, 0.2f);
	}

	private void VisibilityCheck()
	{
		if (!GetComponent<Renderer>().isVisible && ready)
		{
			if (!AmbientSettings.AmbientModeInitial)
			{
				CancelInvoke("MainLoop");
			}
			else if (ambientTimer > AmbientSettings.AmbientStartRuntime)
			{
				if (!AmbientSettings.Interactive)
				{
					CancelInvoke("AmbientMainLoop");
				}
				else
				{
					CancelInvoke("AmbientMainLoopInteractive");
				}
				ambientStopped = true;
			}
			CancelInvoke("VariableChangeCheck");
			CancelInvoke("RainDrops");
			CancelInvoke("SetObstructionTexture");
			CancelInvoke("SetObstructions");
			visible = false;
		}
		else
		{
			if (visible || !GetComponent<Renderer>().isVisible || !ready || paused)
			{
				return;
			}
			if (!AmbientSettings.AmbientModeInitial)
			{
				InvokeRepeating("MainLoop", 0.001f, 1f / simulationSpeed);
			}
			else if (ambientStopped && AmbientSettings.AmbientModeInitial && AmbientSettings.Interactive)
			{
				InvokeRepeating("AmbientMainLoopInteractive", 0.001f, 1f / simulationSpeed);
			}
			else if (ambientStopped && AmbientSettings.AmbientModeInitial && !AmbientSettings.Interactive)
			{
				InvokeRepeating("AmbientMainLoop", 0.001f, 1f / AmbientSettings.AmbientSpeed);
			}
			ambientStopped = false;
			InvokeRepeating("RainDrops", 0.003f, 1f / RainSettings.RainSpeed);
			if (!AmbientSettings.AmbientModeInitial || (AmbientSettings.AmbientModeInitial && AmbientSettings.Interactive))
			{
				if (ObstructionTextureSettings.ObstructionTexturesEnabled && ObstructionTextureSettings.SetRate == ObstructionTextureSettings.setRate.Half)
				{
					InvokeRepeating("SetObstructionTexture", 0.008f, 1f / (simulationSpeed * 0.55f));
				}
				else if (ObstructionTextureSettings.ObstructionTexturesEnabled && ObstructionTextureSettings.SetRate == ObstructionTextureSettings.setRate.Full)
				{
					InvokeRepeating("SetObstructionTexture", 0.008f, 1f / simulationSpeed);
				}
			}
			else if (ObstructionTextureSettings.ObstructionTexturesEnabled)
			{
				InvokeRepeating("SetObstructionTexture", 0.003f, 1f / (AmbientSettings.AmbientSpeed * 0.55f));
			}
			if (ObstructionSettings.ObstructionsEnabled && ObstructionSettings.SetRate == ObstructionSettings.setRate.Half)
			{
				if (!AmbientSettings.AmbientModeInitial || (AmbientSettings.AmbientModeInitial && AmbientSettings.Interactive))
				{
					InvokeRepeating("SetObstructions", 0.003f, 1f / (simulationSpeed * 0.55f));
				}
			}
			else if (ObstructionSettings.ObstructionsEnabled && ObstructionSettings.SetRate == ObstructionSettings.setRate.Full && (!AmbientSettings.AmbientModeInitial || (AmbientSettings.AmbientModeInitial && AmbientSettings.Interactive)))
			{
				InvokeRepeating("SetObstructions", 0.003f, 1f / simulationSpeed);
			}
			obstructionsEnabledCurrent = ObstructionSettings.ObstructionsEnabled;
			obstructionTexturesEnabledCurrent = ObstructionTextureSettings.ObstructionTexturesEnabled;
			InvokeRepeating("VariableChangeCheck", 0.001f, 1f / 30f);
			visible = true;
		}
	}

	public void MainLoop()
	{
		if (buffer1Current)
		{
			HugoEliasFilter(buffer2, buffer1);
			bufferCurrent = buffer1;
		}
		else
		{
			HugoEliasFilter(buffer1, buffer2);
			bufferCurrent = buffer2;
		}
		for (int i = 0; i < verticesArrayLength; i++)
		{
			if (InputSmoothingSettings.ClampBuffer && !IndentTextureSettings.IndentTextureEnabled)
			{
				bufferCurrent[i] = (int)Mathf.Clamp(bufferCurrent[i], (float)(-baseForce) * InputSmoothingSettings.Clamping, (float)baseForce * InputSmoothingSettings.Clamping);
			}
			else if (InputSmoothingSettings.ClampBuffer && IndentTextureSettings.DepthSettings.IndentDepth < 0f)
			{
				bufferCurrent[i] = (int)Mathf.Clamp(bufferCurrent[i], (float)baseForce * IndentTextureSettings.DepthSettings.IndentDepth, (float)baseForce * InputSmoothingSettings.Clamping);
			}
			else if (InputSmoothingSettings.ClampBuffer && IndentTextureSettings.DepthSettings.IndentDepth > 0f)
			{
				bufferCurrent[i] = (int)Mathf.Clamp(bufferCurrent[i], (float)(-baseForce) * ((float)baseForce * InputSmoothingSettings.Clamping), (float)baseForce * IndentTextureSettings.DepthSettings.IndentDepth);
			}
			vertices[i].y = (float)bufferCurrent[i] * 1E-07f * WaveHeight;
		}
		waterMesh.vertices = vertices;
		if (CalculateNormals)
		{
			waterMesh.RecalculateNormals();
		}
		if (IndentTextureSettings.IndentTextureEnabled)
		{
			IndentTextureFunct();
		}
		buffer1Current = !buffer1Current;
	}

	private void AmbientMainLoop()
	{
		if (buffer1Current)
		{
			AmbientHugoEliasFilter(buffer2Amb, buffer1Amb);
			bufferCurrentAmb = buffer1Amb;
		}
		else
		{
			AmbientHugoEliasFilter(buffer1Amb, buffer2Amb);
			bufferCurrentAmb = buffer2Amb;
		}
		for (int i = 0; i < verticesArrayLength; i++)
		{
			if (InputSmoothingSettings.ClampBuffer)
			{
				bufferCurrentAmb[i] = (int)Mathf.Clamp(bufferCurrentAmb[i], (float)(-baseForce) * InputSmoothingSettings.Clamping, (float)baseForce * InputSmoothingSettings.Clamping);
			}
			vertices[i].y = (float)bufferCurrentAmb[i] * 1E-07f * AmbientSettings.WaveHeight;
		}
		waterMesh.vertices = vertices;
		if (CalculateNormals)
		{
			waterMesh.RecalculateNormals();
		}
		buffer1Current = !buffer1Current;
	}

	private void AmbientMainLoopInteractive()
	{
		if (buffer1Current)
		{
			HugoEliasFilter(buffer2, buffer1);
			bufferCurrent = buffer1;
			AmbientHugoEliasFilter(buffer2Amb, buffer1Amb);
			bufferCurrentAmb = buffer1Amb;
		}
		else
		{
			HugoEliasFilter(buffer1, buffer2);
			bufferCurrent = buffer2;
			AmbientHugoEliasFilter(buffer1Amb, buffer2Amb);
			bufferCurrentAmb = buffer2Amb;
		}
		for (int i = 0; i < verticesArrayLength; i++)
		{
			if (InputSmoothingSettings.ClampBuffer && !IndentTextureSettings.IndentTextureEnabled)
			{
				bufferCurrent[i] = (int)Mathf.Clamp(bufferCurrent[i], (float)(-baseForce) * InputSmoothingSettings.Clamping, (float)baseForce * InputSmoothingSettings.Clamping);
			}
			else if (InputSmoothingSettings.ClampBuffer && IndentTextureSettings.DepthSettings.IndentDepth < 0f)
			{
				bufferCurrent[i] = (int)Mathf.Clamp(bufferCurrent[i], (float)baseForce * IndentTextureSettings.DepthSettings.IndentDepth, (float)baseForce * InputSmoothingSettings.Clamping);
			}
			else if (InputSmoothingSettings.ClampBuffer && IndentTextureSettings.DepthSettings.IndentDepth > 0f)
			{
				bufferCurrent[i] = (int)Mathf.Clamp(bufferCurrent[i], (float)(-baseForce) * ((float)baseForce * InputSmoothingSettings.Clamping), (float)baseForce * IndentTextureSettings.DepthSettings.IndentDepth);
			}
			if (InputSmoothingSettings.ClampBuffer)
			{
				bufferCurrentAmb[i] = (int)Mathf.Clamp(bufferCurrentAmb[i], (float)(-baseForce) * InputSmoothingSettings.Clamping, (float)baseForce * InputSmoothingSettings.Clamping);
			}
			vertices[i].y = (float)bufferCurrent[i] * 1E-07f * WaveHeight + (float)bufferCurrentAmb[i] * 1E-07f * AmbientSettings.WaveHeight;
		}
		waterMesh.vertices = vertices;
		if (CalculateNormals)
		{
			waterMesh.RecalculateNormals();
		}
		if (IndentTextureSettings.IndentTextureEnabled)
		{
			IndentTextureFunct();
		}
		buffer1Current = !buffer1Current;
	}

	private void VariableChangeCheck()
	{
		if (rainSpeedCurrent != RainSettings.RainSpeed)
		{
			CancelInvoke("RainDrops");
			InvokeRepeating("RainDrops", 0.0001f, 1f / RainSettings.RainSpeed);
			rainSpeedCurrent = RainSettings.RainSpeed;
		}
		if (obstructionTexturesEnabledCurrent != ObstructionTextureSettings.ObstructionTexturesEnabled)
		{
			if (!AmbientSettings.AmbientModeInitial || (AmbientSettings.AmbientModeInitial && AmbientSettings.Interactive))
			{
				if (ObstructionTextureSettings.ObstructionTexturesEnabled && ObstructionTextureSettings.SetRate == ObstructionTextureSettings.setRate.Half)
				{
					InvokeRepeating("SetObstructionTexture", 0.003f, 1f / (simulationSpeed * 0.55f));
				}
				else if (ObstructionTextureSettings.ObstructionTexturesEnabled && ObstructionTextureSettings.SetRate == ObstructionTextureSettings.setRate.Full)
				{
					InvokeRepeating("SetObstructionTexture", 0.003f, 1f / simulationSpeed);
				}
			}
			else if (ObstructionTextureSettings.ObstructionTexturesEnabled)
			{
				InvokeRepeating("SetObstructionTexture", 0.003f, 1f / (AmbientSettings.AmbientSpeed * 0.55f));
			}
			if (!ObstructionTextureSettings.ObstructionTexturesEnabled)
			{
				CancelInvoke("SetObstructionTexture");
			}
			obstructionTexturesEnabledCurrent = ObstructionTextureSettings.ObstructionTexturesEnabled;
		}
		if (obstructionsEnabledCurrent != ObstructionSettings.ObstructionsEnabled)
		{
			if (ObstructionSettings.ObstructionsEnabled && ObstructionSettings.SetRate == ObstructionSettings.setRate.Half)
			{
				if (!AmbientSettings.AmbientModeInitial || (AmbientSettings.AmbientModeInitial && AmbientSettings.Interactive))
				{
					InvokeRepeating("SetObstructions", 0.003f, 1f / (simulationSpeed * 0.55f));
				}
			}
			else if (ObstructionSettings.ObstructionsEnabled && ObstructionSettings.SetRate == ObstructionSettings.setRate.Full)
			{
				if (!AmbientSettings.AmbientModeInitial || (AmbientSettings.AmbientModeInitial && AmbientSettings.Interactive))
				{
					InvokeRepeating("SetObstructions", 0.003f, 1f / simulationSpeed);
				}
			}
			else if (!ObstructionSettings.ObstructionsEnabled)
			{
				CancelInvoke("SetObstructions");
			}
			obstructionsEnabledCurrent = ObstructionSettings.ObstructionsEnabled;
		}
		if (AmbientSettings.AmbientModeInitial && !AmbientSettings.Interactive && ambientSpeedCurrent != AmbientSettings.AmbientSpeed)
		{
			CancelInvoke("AmbientMainLoop");
			InvokeRepeating("AmbientMainLoop", 0.0001f, 1f / AmbientSettings.AmbientSpeed);
			CancelInvoke("SetObstructionTexture");
			if (ObstructionTextureSettings.ObstructionTexturesEnabled)
			{
				InvokeRepeating("SetObstructionTexture", 0.003f, 1f / (AmbientSettings.AmbientSpeed * 0.55f));
			}
			ambientSpeedCurrent = AmbientSettings.AmbientSpeed;
		}
	}

	private void RainDrops()
	{
		if (RainSettings.RainEnabled && simulationSpeed != 0f)
		{
			int row = UnityEngine.Random.Range(InputSmoothingSettings.BlurRadius + 2, rows - (InputSmoothingSettings.BlurRadius + 2));
			int column = UnityEngine.Random.Range(InputSmoothingSettings.BlurRadius + 2, columns - (InputSmoothingSettings.BlurRadius + 1));
			if (RainSettings.RandomRainForce)
			{
				RainSettings.RainForce = UnityEngine.Random.Range(0.01f, 1f);
			}
			DisturbBufferAt(row, column, (int)((float)baseForce * RainSettings.RainForce), ambient: false);
		}
	}

	public void DisturbBufferAt(int row, int column, int force, bool ambient)
	{
		int num;
		int[] array;
		if (ambient)
		{
			num = 10;
			array = bufferCurrentAmb;
		}
		else
		{
			num = InputSmoothingSettings.BlurRadius;
			array = bufferCurrent;
		}
		if (!allowInput)
		{
			return;
		}
		int num2 = row * (columns + 1) + column;
		array[num2] = force;
		if (!InputSmoothingSettings.SmoothingEnabled)
		{
			return;
		}
		for (int i = 0; i < InputSmoothingSettings.SmoothingLevel; i++)
		{
			for (int j = row - num; j <= row + num; j++)
			{
				for (int k = column - num; k <= column + num; k++)
				{
					array[j * (columns + 1) + k] = (array[(j - 2) * (columns + 1) + (k - 2)] + 4 * array[(j - 2) * (columns + 1) + (k - 1)] + 7 * array[(j - 2) * (columns + 1) + k] + 4 * array[(j - 2) * (columns + 1) + (k + 1)] + array[(j - 2) * (columns + 1) + (k + 2)] + 4 * array[(j - 1) * (columns + 1) + (k - 2)] + 16 * array[(j - 1) * (columns + 1) + (k - 1)] + 26 * array[(j - 1) * (columns + 1) + k] + 16 * array[(j - 1) * (columns + 1) + (k + 1)] + 4 * array[(j - 1) * (columns + 1) + (k + 2)] + 7 * array[j * (columns + 1) + (k - 2)] + 26 * array[j * (columns + 1) + (k - 1)] + 41 * array[j * (columns + 1) + k] + 26 * array[j * (columns + 1) + (k + 1)] + 7 * array[j * (columns + 1) + (k + 2)] + 4 * array[(j + 1) * (columns + 1) + (k - 2)] + 16 * array[(j + 1) * (columns + 1) + (k - 1)] + 26 * array[(j + 1) * (columns + 1) + k] + 16 * array[(j + 1) * (columns + 1) + (k + 1)] + 4 * array[(j + 1) * (columns + 1) + (k + 2)] + array[(j + 2) * (columns + 1) + (k - 2)] + 4 * array[(j + 2) * (columns + 1) + (k - 1)] + 7 * array[(j + 2) * (columns + 1) + k] + 4 * array[(j + 2) * (columns + 1) + (k + 1)] + array[(j + 2) * (columns + 1) + (k + 2)]) / 273;
				}
			}
		}
	}

	private void HugoEliasFilter(int[] previousBuffer, int[] currentBuffer)
	{
		for (int i = columns + 1; i < verticesArrayLength - (columns + 1); i++)
		{
			currentBuffer[i] = (previousBuffer[i - 1] + previousBuffer[i + 1] + previousBuffer[i - (columns + 1)] + previousBuffer[i + (columns + 1)]) / 2 - currentBuffer[i];
			currentBuffer[i] = (int)((float)currentBuffer[i] * Damping);
		}
		for (int j = 0; j < rows; j++)
		{
			int num = j * (columns + 1);
			currentBuffer[num] = 0;
		}
	}

	private void AmbientHugoEliasFilter(int[] previousBuffer, int[] currentBuffer)
	{
		for (int i = columns + 1; i < verticesArrayLength - (columns + 1); i++)
		{
			currentBuffer[i] = (previousBuffer[i - 1] + previousBuffer[i + 1] + previousBuffer[i - (columns + 1)] + previousBuffer[i + (columns + 1)]) / 2 - currentBuffer[i];
		}
	}

	public void SetObstructions()
	{
		if (!obstructionsScanned)
		{
			ObstructionDetection();
		}
		for (int i = 0; i < obstructionCounter; i++)
		{
			bufferCurrent[obstructedPositions[i]] = 0;
		}
	}

	public void SetObstructionTexture()
	{
		if (!obstructionTextuReScanned)
		{
			ProcessObstructionTexture();
		}
		if (ObstructionTextureSettings.ReScan)
		{
			obstructionTextureCounter = 0;
			ProcessObstructionTexture();
		}
		ObstructionTextureSettings.ReScan = false;
		if (ObstructionTextureSettings.useAppearanceModifiers)
		{
			for (int i = 0; i < obstructionTextureCounter; i++)
			{
				int num;
				int num2;
				if (ObstructionTextureSettings.Appearance.FlipImage)
				{
					num = rows - (int)((float)obstructionTextureRows[i] * ObstructionTextureSettings.Appearance.RowScale) + ObstructionTextureSettings.Appearance.RowOffset;
					num2 = columns - (int)((float)obstructionTextureColumns[i] * ObstructionTextureSettings.Appearance.ColScale) + ObstructionTextureSettings.Appearance.ColOffset;
				}
				else
				{
					num = (int)((float)obstructionTextureRows[i] * ObstructionTextureSettings.Appearance.RowScale) + ObstructionTextureSettings.Appearance.RowOffset;
					num2 = (int)((float)obstructionTextureColumns[i] * ObstructionTextureSettings.Appearance.ColScale) + ObstructionTextureSettings.Appearance.ColOffset;
				}
				if (num2 > 0 && num2 < columns && num > 0 && num < rows)
				{
					int num3 = num * (columns + 1) + num2;
					bufferCurrent[num3] = 0;
					if (AmbientSettings.AmbientModeInitial)
					{
						bufferCurrentAmb[num3] = 0;
					}
				}
			}
		}
		else
		{
			for (int j = 0; j < obstructionTextureCounter; j++)
			{
				bufferCurrent[obstructedTexturePositions[j]] = 0;
			}
		}
	}

	public void Reset()
	{
		RealWaterCollider.reseting = true;
		CancelInvoke("MainLoop");
		CancelInvoke("AmbientMainLoop");
		CancelInvoke("AmbientMainLoopInteractive");
		CancelInvoke("SetObstructions");
		CancelInvoke("SetObstructionTexture");
		CancelInvoke("VisibilityCheck");
		CancelInvoke("VariableChangeCheck");
		obstructionCounter = 0;
		obstructionTextureCounter = 0;
		indentTextureCounter = 0;
		indentScanned = false;
		obstructionsScanned = false;
		obstructionTextuReScanned = false;
		AssignMesh();
		if (CalculateTangents)
		{
			TangentSolver(waterMesh);
		}
		initializeVariables();
		if (ObstructionSettings.ObstructionsEnabled)
		{
			ObstructionDetection();
			if (ObstructionSettings.ObstructionsEnabled && ObstructionSettings.SetRate == ObstructionSettings.setRate.Half && !AmbientSettings.AmbientModeInitial)
			{
				InvokeRepeating("SetObstructions", 0.003f, 1f / (simulationSpeed * 0.55f));
			}
			if (ObstructionSettings.ObstructionsEnabled && ObstructionSettings.SetRate == ObstructionSettings.setRate.Full && !AmbientSettings.AmbientModeInitial)
			{
				InvokeRepeating("SetObstructions", 0.003f, 1f / simulationSpeed);
			}
		}
		if (ObstructionTextureSettings.ObstructionTexturesEnabled)
		{
			ProcessObstructionTexture();
			if (!AmbientSettings.AmbientModeInitial)
			{
				if (ObstructionTextureSettings.ObstructionTexturesEnabled && ObstructionTextureSettings.SetRate == ObstructionTextureSettings.setRate.Half)
				{
					InvokeRepeating("SetObstructionTexture", 0.003f, 1f / (simulationSpeed * 0.55f));
				}
				if (ObstructionTextureSettings.ObstructionTexturesEnabled && ObstructionTextureSettings.SetRate == ObstructionTextureSettings.setRate.Full)
				{
					InvokeRepeating("SetObstructionTexture", 0.003f, 1f / simulationSpeed);
				}
			}
			else if (ObstructionTextureSettings.ObstructionTexturesEnabled)
			{
				InvokeRepeating("SetObstructionTexture", 0.003f, 1f / (AmbientSettings.AmbientSpeed * 0.55f));
			}
		}
		if (IndentTextureSettings.IndentTextureEnabled)
		{
			ProcessIndentTexture();
		}
		if (inputManager != null)
		{
			inputManager.Reset();
		}
		allowInput = true;
		if (AmbientSettings.AmbientMode)
		{
			ambientStopped = false;
			ambientTimer = 0f;
			InitializeAmbientMode();
			if (AmbientSettings.Interactive)
			{
				InvokeRepeating("AmbientMainLoopInteractive", 0.001f, 1f / simulationSpeed);
			}
		}
		else
		{
			InvokeRepeating("MainLoop", 0.001f, 1f / simulationSpeed);
			InvokeRepeating("VisibilityCheck", 0.001f, 0.2f);
			InvokeRepeating("VariableChangeCheck", 0.001f, 1f / 30f);
		}
		StartCoroutine("ColliderResetDelay");
	}

	private IEnumerator ColliderResetDelay()
	{
		yield return new WaitForSeconds(0.1f);
		RealWaterCollider.reseting = false;
	}

	private void IndentTextureFunct()
	{
		if (!indentScanned)
		{
			ProcessIndentTexture();
		}
		if (IndentTextureSettings.ReScan)
		{
			indentTextureCounter = 0;
			ProcessIndentTexture();
		}
		IndentTextureSettings.ReScan = false;
		int num = baseForce;
		UnityEngine.Debug.Log("harry 0");
		for (int i = 0; i < indentTextureCounter; i++)
		{
			int num2;
			int num3;
			if (IndentTextureSettings.Appearance.FlipImage)
			{
				num2 = rows - (int)((float)indentTextureRows[i] * IndentTextureSettings.Appearance.RowScale + (float)IndentTextureSettings.Appearance.RowOffset);
				num3 = columns - (int)((float)indentTextureColumns[i] * IndentTextureSettings.Appearance.ColScale + (float)IndentTextureSettings.Appearance.ColOffset);
			}
			else
			{
				num2 = (int)((float)indentTextureRows[i] * IndentTextureSettings.Appearance.RowScale + (float)IndentTextureSettings.Appearance.RowOffset);
				num3 = (int)((float)indentTextureColumns[i] * IndentTextureSettings.Appearance.ColScale + (float)IndentTextureSettings.Appearance.ColOffset);
			}
			int num4 = num2 * (columns + 1) + num3;
			if (IndentTextureSettings.DepthSettings.Proportionality == DepthSettings.proportionality.None)
			{
				num = (int)((float)baseForce * IndentTextureSettings.DepthSettings.IndentDepth);
			}
			else if (IndentTextureSettings.DepthSettings.Proportionality == DepthSettings.proportionality.Normal)
			{
				num = (int)((float)baseForce * IndentTextureSettings.DepthSettings.IndentDepth * indentTextureGrayscaleValues[i]);
			}
			else if (IndentTextureSettings.DepthSettings.Proportionality == DepthSettings.proportionality.Inverse)
			{
				num = (int)((float)baseForce * IndentTextureSettings.DepthSettings.IndentDepth * (1f - indentTextureGrayscaleValues[i]));
			}
			if (IndentTextureSettings.SmoothingEnabled && num3 > InputSmoothingSettings.BlurRadius + 1 && num3 < columns - InputSmoothingSettings.BlurRadius + 1 && num2 < rows - (InputSmoothingSettings.BlurRadius + 2) && num2 > InputSmoothingSettings.BlurRadius + 1)
			{
				bufferCurrent[num4] = num;
				for (int j = 0; j < 1; j++)
				{
					for (int k = num2; k <= num2; k++)
					{
						for (int l = num3; l <= num3; l++)
						{
							bufferCurrent[k * (columns + 1) + l] = (bufferCurrent[(k - 2) * (columns + 1) + (l - 2)] + 4 * bufferCurrent[(k - 2) * (columns + 1) + (l - 1)] + 7 * bufferCurrent[(k - 2) * (columns + 1) + l] + 4 * bufferCurrent[(k - 2) * (columns + 1) + (l + 1)] + bufferCurrent[(k - 2) * (columns + 1) + (l + 2)] + 4 * bufferCurrent[(k - 1) * (columns + 1) + (l - 2)] + 16 * bufferCurrent[(k - 1) * (columns + 1) + (l - 1)] + 26 * bufferCurrent[(k - 1) * (columns + 1) + l] + 16 * bufferCurrent[(k - 1) * (columns + 1) + (l + 1)] + 4 * bufferCurrent[(k - 1) * (columns + 1) + (l + 2)] + 7 * bufferCurrent[k * (columns + 1) + (l - 2)] + 26 * bufferCurrent[k * (columns + 1) + (l - 1)] + 41 * bufferCurrent[k * (columns + 1) + l] + 26 * bufferCurrent[k * (columns + 1) + (l + 1)] + 7 * bufferCurrent[k * (columns + 1) + (l + 2)] + 4 * bufferCurrent[(k + 1) * (columns + 1) + (l - 2)] + 16 * bufferCurrent[(k + 1) * (columns + 1) + (l - 1)] + 26 * bufferCurrent[(k + 1) * (columns + 1) + l] + 16 * bufferCurrent[(k + 1) * (columns + 1) + (l + 1)] + 4 * bufferCurrent[(k + 1) * (columns + 1) + (l + 2)] + bufferCurrent[(k + 2) * (columns + 1) + (l - 2)] + 4 * bufferCurrent[(k + 2) * (columns + 1) + (l - 1)] + 7 * bufferCurrent[(k + 2) * (columns + 1) + l] + 4 * bufferCurrent[(k + 2) * (columns + 1) + (l + 1)] + bufferCurrent[(k + 2) * (columns + 1) + (l + 2)]) / 273;
						}
					}
				}
			}
			else if (!IndentTextureSettings.SmoothingEnabled && num3 > 0 && num3 < columns && num2 > 0 && num2 < rows)
			{
				bufferCurrent[num4] = num;
			}
		}
		if (IndentTextureSettings.RecalculateBounds)
		{
			waterMesh.RecalculateBounds();
		}
	}

	public void SetSpeed(float s)
	{
		simulationSpeed = s;
	}

	public float GetSpeed()
	{
		return simulationSpeed;
	}

	public int GetCols()
	{
		return columns;
	}

	public int GetRows()
	{
		return rows;
	}

	public bool GetVisibility()
	{
		return visible;
	}

	public void SetReady(bool val)
	{
		ready = val;
	}

	public void SetInputPos(Vector2 pos)
	{
	}

	public ObstructionTextureSettings GetObstructionTextureSettings()
	{
		return ObstructionTextureSettings;
	}

	public ObstructionSettings GetObstructionSettings()
	{
		return ObstructionSettings;
	}

	public bool GetPaused()
	{
		return paused;
	}

	public bool getIsLarge()
	{
		return false;
	}

	public float GetExitPauseDelay()
	{
		return collisionCullingSettings.exitPauseDelay;
	}

	public float GetInterPlanePauseDelay()
	{
		return collisionCullingSettings.interPlanePauseDelay;
	}

	public void SetExitPauseDelay(float val)
	{
		collisionCullingSettings.exitPauseDelay = val;
	}

	public void SetInterPlanePauseDelay(float val)
	{
		collisionCullingSettings.interPlanePauseDelay = val;
	}

	public bool IsFullPlaneSim()
	{
		return true;
	}

	public bool GetCollisionCulling()
	{
		return collisionCullingSettings.collisionCulling;
	}

	public void SetCollisionCulling(bool val)
	{
		collisionCullingSettings.collisionCulling = val;
	}

	public void SetPaused(bool val)
	{
		paused = val;
	}

	public bool GetAmbientMode()
	{
		return AmbientSettings.AmbientMode;
	}

	public bool GetInteractiveAmbientMode()
	{
		return AmbientSettings.Interactive;
	}

	public void EnableObstructions(bool val)
	{
		ObstructionSettings.ObstructionsEnabled = val;
	}

	public ObstructionSettings.setRate GetObstructionSetRate()
	{
		return ObstructionSettings.SetRate;
	}

	public void SetObstructionSetRate(ObstructionSettings.setRate rate)
	{
		ObstructionSettings.SetRate = rate;
	}

	public void EnableObstructionTexture(bool val)
	{
		ObstructionTextureSettings.ObstructionTexturesEnabled = val;
	}

	public void SetObstructionTextureTo(Texture2D img)
	{
		ObstructionTextureSettings.ObstructionTexture = img;
		ObstructionTextureSettings.ReScan = true;
	}

	public ObstructionTextureSettings.setRate GetObstructionTextureSetRate()
	{
		return ObstructionTextureSettings.SetRate;
	}

	public void SetObstructionTextureSetRate(ObstructionTextureSettings.setRate rate)
	{
		ObstructionTextureSettings.SetRate = rate;
	}

	public void SetObstructionTextureAppearance(Appearance settings)
	{
		ObstructionTextureSettings.Appearance = settings;
	}

	public int GetSmoothingLevel()
	{
		return InputSmoothingSettings.SmoothingLevel;
	}

	public void SetSmoothingLevel(int val)
	{
		InputSmoothingSettings.SmoothingLevel = val;
	}

	public int GetBR()
	{
		return InputSmoothingSettings.BlurRadius;
	}

	public void SetBR(int val)
	{
		InputSmoothingSettings.BlurRadius = val;
	}

	public float GetDamping()
	{
		return Damping;
	}

	public void SetDamping(float val)
	{
		Damping = val;
	}

	private static void TangentSolver(Mesh theMesh)
	{
		int vertexCount = theMesh.vertexCount;
		Vector3[] array = theMesh.vertices;
		Vector3[] normals = theMesh.normals;
		Vector2[] uv = theMesh.uv;
		int[] triangles = theMesh.triangles;
		int num = triangles.Length / 3;
		Vector4[] array2 = new Vector4[vertexCount];
		Vector3[] array3 = new Vector3[vertexCount];
		Vector3[] array4 = new Vector3[vertexCount];
		int num2 = 0;
		for (int i = 0; i < num; i++)
		{
			int num3 = triangles[num2];
			int num4 = triangles[num2 + 1];
			int num5 = triangles[num2 + 2];
			Vector3 vector = array[num3];
			Vector3 vector2 = array[num4];
			Vector3 vector3 = array[num5];
			Vector2 vector4 = uv[num3];
			Vector2 vector5 = uv[num4];
			Vector2 vector6 = uv[num5];
			float num6 = vector2.x - vector.x;
			float num7 = vector3.x - vector.x;
			float num8 = vector2.y - vector.y;
			float num9 = vector3.y - vector.y;
			float num10 = vector2.z - vector.z;
			float num11 = vector3.z - vector.z;
			float num12 = vector5.x - vector4.x;
			float num13 = vector6.x - vector4.x;
			float num14 = vector5.y - vector4.y;
			float num15 = vector6.y - vector4.y;
			float num16 = 1f / (num12 * num15 - num13 * num14);
			Vector3 vector7 = new Vector3((num15 * num6 - num14 * num7) * num16, (num15 * num8 - num14 * num9) * num16, (num15 * num10 - num14 * num11) * num16);
			Vector3 vector8 = new Vector3((num12 * num7 - num13 * num6) * num16, (num12 * num9 - num13 * num8) * num16, (num12 * num11 - num13 * num10) * num16);
			array3[num3] += vector7;
			array3[num4] += vector7;
			array3[num5] += vector7;
			array4[num3] += vector8;
			array4[num4] += vector8;
			array4[num5] += vector8;
			num2 += 3;
		}
		for (int j = 0; j < vertexCount; j++)
		{
			Vector3 normal = normals[j];
			Vector3 tangent = array3[j];
			Vector3.OrthoNormalize(ref normal, ref tangent);
			array2[j].x = tangent.x;
			array2[j].y = tangent.y;
			array2[j].z = tangent.z;
			array2[j].w = ((Vector3.Dot(Vector3.Cross(normal, tangent), array4[j]) < 0f) ? (-1f) : 1f);
		}
		theMesh.tangents = array2;
	}
}
public class RealWaterCollider : MonoBehaviour
{
	public enum Objecttype
	{
		RigidBody,
		CharacterController
	}

	private float xCoord;

	private float YCoord;

	[Tooltip("If true this input will be used for collision culling and as the center of normal map mode simulations. You should only have one per scene!")]
	public bool mainInput;

	[Tooltip("Is the collider a Rigidbody or a Character controller?")]
	public Objecttype ObjectType;

	[Tooltip("Force Multiplier")]
	[Range(0.01f, 10f)]
	public float InputForce = 1f;

	[Tooltip("Only check for collisions if the collider velocity exceeds this value")]
	public float VelocityLimit = 0.05f;

	[Tooltip("Raycast origin position offset.")]
	public Vector3 RaycastOffset;

	public float RaycastLength = 1f;

	[Tooltip("Extrapolates between input points, allows for smoother more consistent input.")]
	public bool ExtrapolateInput = true;

	[Tooltip("Disables the visibility check so water collider will always check for collisions even when not visible.")]
	public bool FirstPersonMode;

	[Tooltip("Enables collision logging and ray drawing in the inspector. Also removes the velocity limitation.Very useful for Setup.")]
	public bool DebugMode;

	[Tooltip("Ensures input position of RealWaterNormal map instances is updated frequently enough to prevent errors with fade algorithm at low speeds (<~10).")]
	public bool lowSpeedMode;

	public Renderer rend;

	private float zPositionCurrent;

	private float xPositionCurrent;

	private float zPositionPrevious;

	private float xPositionPrevious;

	private bool checkWaterCollision = true;

	private bool crouching;

	private RWInput rwInput = new RWInput();

	private BresenhamLineDrawer lineDrawer = new BresenhamLineDrawer();

	private bool firstRun = true;

	private float collisionCheckFrequency = 60f;

	private bool isCharController;

	private bool isRigidbody;

	private CharacterController controller;

	private RaycastHit hit;

	private int baseForce = 18000000;

	private bool visible = true;

	private RealWaterInterface previousPlane;

	public static bool reseting;

	private void Start()
	{
		switch (ObjectType)
		{
		case Objecttype.CharacterController:
			isCharController = true;
			controller = GetComponent<CharacterController>();
			break;
		case Objecttype.RigidBody:
			isRigidbody = true;
			break;
		}
		if (!rend)
		{
			rend = GetComponent<Renderer>();
		}
		if (DebugMode)
		{
			VelocityLimit = -1f;
		}
		else
		{
			InvokeRepeating("PositionCheck1", 0.001f, 1f / 30f);
		}
		if (!FirstPersonMode && !DebugMode)
		{
			InvokeRepeating("VisibilityCheck", 0.001f, 0.2f);
		}
		if (mainInput && lowSpeedMode)
		{
			InvokeRepeating("LowSpeedInputPositionSet", 0.001f, 1f / 30f);
		}
	}

	private void Update()
	{
		if (reseting)
		{
			Reset();
		}
	}

	public void Reset()
	{
		rwInput.SetFirstInput(val: true);
	}

	private void LowSpeedInputPositionSet()
	{
		if (Physics.Raycast(base.transform.position + RaycastOffset, Vector3.down, out var hitInfo, RaycastLength) && hitInfo.collider.gameObject.name == "RealWater Plane")
		{
			xCoord = hitInfo.textureCoord.x;
			YCoord = hitInfo.textureCoord.y;
			int rows = hitInfo.collider.gameObject.GetComponent<RealWaterInterface>().GetRows();
			int cols = hitInfo.collider.gameObject.GetComponent<RealWaterInterface>().GetCols();
			int num = (int)(YCoord * (float)rows);
			int num2 = (int)(xCoord * (float)cols);
			if (!hitInfo.collider.gameObject.GetComponent<RealWaterInterface>().IsFullPlaneSim())
			{
				hitInfo.collider.gameObject.GetComponent<RealWaterInterface>().SetInputPos(new Vector2(num, num2));
			}
		}
	}

	private void PositionCheck1()
	{
		zPositionPrevious = Mathf.Round(base.transform.position.z * 10f) / 10f;
		xPositionPrevious = Mathf.Round(base.transform.position.x * 10f) / 10f;
		Invoke("PositionCheck2", 1f);
	}

	private void PositionCheck2()
	{
		zPositionCurrent = Mathf.Round(base.transform.position.z * 10f) / 10f;
		xPositionCurrent = Mathf.Round(base.transform.position.x * 10f) / 10f;
		if (isRigidbody)
		{
			if (Mathf.Round(GetComponent<Rigidbody>().velocity.y) == 0f)
			{
				if (zPositionCurrent == zPositionPrevious && xPositionCurrent == xPositionPrevious)
				{
					checkWaterCollision = false;
				}
				else if (!crouching)
				{
					checkWaterCollision = true;
				}
			}
			else
			{
				checkWaterCollision = true;
			}
		}
		else
		{
			if (!isCharController)
			{
				return;
			}
			if (Mathf.Round(controller.velocity.y) == 0f)
			{
				if (zPositionCurrent == zPositionPrevious && xPositionCurrent == xPositionPrevious)
				{
					checkWaterCollision = false;
				}
				else if (!crouching)
				{
					checkWaterCollision = true;
				}
			}
			else
			{
				checkWaterCollision = true;
			}
		}
	}

	private void VisibilityCheck()
	{
		if (rend.isVisible && !DebugMode)
		{
			CancelInvoke("CheckForCollisions");
			CancelInvoke("PositionCheck1");
			visible = false;
		}
		else if (rend.isVisible)
		{
			InvokeRepeating("CheckForCollisions", 0.005f, 1f / collisionCheckFrequency);
			InvokeRepeating("PositionCheck1", 0.001f, 1f / 30f);
			rwInput.SetFirstInput(val: true);
			visible = true;
		}
	}

	private void OnDisable()
	{
		CancelInvoke();
		RealWaterSpeedManager realWaterSpeedManager = UnityEngine.Object.FindObjectOfType(typeof(RealWaterSpeedManager)) as RealWaterSpeedManager;
		if (realWaterSpeedManager != null)
		{
			realWaterSpeedManager.FindColliders();
		}
		rwInput.SetFirstInput(val: true);
	}

	private void OnEnable()
	{
		if (!firstRun)
		{
			RealWaterSpeedManager realWaterSpeedManager = UnityEngine.Object.FindObjectOfType(typeof(RealWaterSpeedManager)) as RealWaterSpeedManager;
			if (realWaterSpeedManager != null)
			{
				realWaterSpeedManager.FindColliders();
			}
			if (!FirstPersonMode && !DebugMode)
			{
				InvokeRepeating("VisibilityCheck", 0.001f, 0.2f);
			}
			if (!crouching)
			{
				checkWaterCollision = true;
			}
			InvokeRepeating("PositionCheck1", 0.001f, 1f / 30f);
		}
		else
		{
			firstRun = false;
		}
	}

	private void CheckForCollisions()
	{
		if (!checkWaterCollision)
		{
			return;
		}
		if (Physics.Raycast(base.transform.position + RaycastOffset, Vector3.down, out var hitInfo, 100f) && hitInfo.collider.gameObject.name == "RealWater Plane")
		{
			xCoord = hitInfo.textureCoord.x;
			YCoord = hitInfo.textureCoord.y;
			int rows = hitInfo.collider.gameObject.GetComponent<RealWaterInterface>().GetRows();
			int cols = hitInfo.collider.gameObject.GetComponent<RealWaterInterface>().GetCols();
			int num = (int)(YCoord * (float)rows);
			int num2 = (int)(xCoord * (float)cols);
			if (!hitInfo.collider.gameObject.GetComponent<RealWaterInterface>().IsFullPlaneSim())
			{
				hitInfo.collider.gameObject.GetComponent<RealWaterInterface>().SetInputPos(new Vector2(num, num2));
			}
		}
		if (DebugMode)
		{
			UnityEngine.Debug.DrawRay(base.transform.position + RaycastOffset, Vector3.down.normalized * RaycastLength, UnityEngine.Color.red, 0.01f, depthTest: false);
		}
		if (Physics.Raycast(base.transform.position + RaycastOffset, Vector3.down, out hit, RaycastLength))
		{
			if (hit.collider.gameObject.name == "RealWater Plane")
			{
				if (mainInput && previousPlane != null)
				{
					((MonoBehaviour)previousPlane).CancelInvoke("Pause");
					if (previousPlane.GetPaused() && hit.collider.gameObject.GetComponent<RealWaterInterface>().GetCollisionCulling() && !hit.collider.gameObject.GetComponent<RealWaterInterface>().GetAmbientMode())
					{
						hit.collider.gameObject.GetComponent<RealWaterInterface>().Play();
					}
				}
				if (isRigidbody)
				{
					if (GetComponent<Rigidbody>().velocity.magnitude > VelocityLimit)
					{
						ProcessCollision();
					}
					else
					{
						rwInput.SetFirstInput(val: true);
					}
				}
				else if (controller.velocity.magnitude > VelocityLimit)
				{
					ProcessCollision();
				}
				else
				{
					rwInput.SetFirstInput(val: true);
				}
				if (previousPlane == null)
				{
					previousPlane = hit.collider.gameObject.GetComponent<RealWaterInterface>();
				}
				else if (previousPlane != hit.collider.gameObject.GetComponent<RealWaterInterface>() && mainInput && previousPlane.GetCollisionCulling() && !previousPlane.GetAmbientMode() && mainInput)
				{
					((MonoBehaviour)previousPlane).Invoke("Pause", previousPlane.GetInterPlanePauseDelay());
					previousPlane = hit.collider.gameObject.GetComponent<RealWaterInterface>();
				}
				else
				{
					previousPlane = hit.collider.gameObject.GetComponent<RealWaterInterface>();
				}
			}
			else if (previousPlane != null)
			{
				rwInput.SetFirstInput(val: true);
				if (!previousPlane.GetPaused() && mainInput && !previousPlane.GetAmbientMode() && previousPlane.GetCollisionCulling() && mainInput)
				{
					((MonoBehaviour)previousPlane).Invoke("Pause", previousPlane.GetExitPauseDelay());
				}
			}
		}
		else
		{
			rwInput.SetFirstInput(val: true);
			if (previousPlane != null && !previousPlane.GetPaused() && mainInput && !previousPlane.GetAmbientMode() && previousPlane.GetCollisionCulling() && mainInput)
			{
				((MonoBehaviour)previousPlane).Invoke("Pause", previousPlane.GetExitPauseDelay());
			}
		}
	}

	private void ProcessCollision()
	{
		xCoord = hit.textureCoord.x;
		YCoord = hit.textureCoord.y;
		int rows = hit.collider.gameObject.GetComponent<RealWaterInterface>().GetRows();
		int cols = hit.collider.gameObject.GetComponent<RealWaterInterface>().GetCols();
		int bR = hit.collider.gameObject.GetComponent<RealWaterInterface>().GetBR();
		int num = (int)(YCoord * (float)rows);
		int num2 = (int)(xCoord * (float)cols);
		bool visibility = hit.collider.gameObject.GetComponent<RealWaterInterface>().GetVisibility();
		bool paused = hit.collider.gameObject.GetComponent<RealWaterInterface>().GetPaused();
		if (mainInput && !hit.collider.gameObject.GetComponent<RealWaterInterface>().IsFullPlaneSim())
		{
			hit.collider.gameObject.GetComponent<RealWaterInterface>().SetInputPos(new Vector2(num, num2));
		}
		if (!paused && visibility && num2 > bR + 1 && num2 < cols - bR + 1 && num < rows - (bR + 2) && num > bR + 2)
		{
			if (ExtrapolateInput)
			{
				if (!rwInput.GetFirstInput())
				{
					if (rwInput.GetFirstPoint())
					{
						rwInput.SetX1(num);
						rwInput.SetY1(num2);
						rwInput.SetPlane1(hit.collider.GetInstanceID());
					}
					else
					{
						rwInput.SetX2(num);
						rwInput.SetY2(num2);
						rwInput.SetPlane2(hit.collider.GetInstanceID());
					}
					if (rwInput.GetPlane1() == rwInput.GetPlane2())
					{
						lineDrawer.DrawLine(rwInput.GetX1(), rwInput.GetX2(), rwInput.GetY1(), rwInput.GetY2(), hit, InputForce);
					}
					rwInput.SetFirstPoint(!rwInput.GetFirstPoint());
				}
				else
				{
					rwInput.SetX1(num);
					rwInput.SetY1(num2);
					rwInput.SetX2(num);
					rwInput.SetY2(num2);
					rwInput.SetFirstInput(val: false);
				}
			}
			else
			{
				hit.collider.gameObject.GetComponent<RealWaterInterface>().DisturbBufferAt(num, num2, (int)(18000000f * InputForce), ambient: false);
			}
		}
		else
		{
			rwInput.SetFirstInput(val: true);
		}
	}

	public bool GetCrouching()
	{
		return crouching;
	}

	public void SetCrouching(bool val)
	{
		crouching = val;
	}

	public bool GetCheckCollisions()
	{
		return checkWaterCollision;
	}

	public void SetCheckCollisions(bool val)
	{
		checkWaterCollision = val;
	}

	public float GetCollisionFrequency()
	{
		return collisionCheckFrequency;
	}

	public void SetCollisionFrequency(float val)
	{
		collisionCheckFrequency = val;
	}

	public bool GetVisibility()
	{
		return visible;
	}
}
public interface RealWaterInterface
{
	void MainLoop();

	void DisturbBufferAt(int row, int column, int force, bool ambient);

	void Reset();

	void Pause();

	void Play();

	void SetObstructions();

	void SetObstructionTexture();

	void SetSpeed(float s);

	float GetSpeed();

	int GetCols();

	int GetRows();

	bool GetVisibility();

	void SetReady(bool val);

	void SetInputPos(Vector2 pos);

	void EnableObstructionTexture(bool val);

	void SetObstructionTextureTo(Texture2D img);

	ObstructionSettings.setRate GetObstructionSetRate();

	void SetObstructionSetRate(ObstructionSettings.setRate rate);

	ObstructionTextureSettings.setRate GetObstructionTextureSetRate();

	void SetObstructionTextureSetRate(ObstructionTextureSettings.setRate rate);

	void SetObstructionTextureAppearance(Appearance settings);

	void EnableObstructions(bool val);

	ObstructionTextureSettings GetObstructionTextureSettings();

	ObstructionSettings GetObstructionSettings();

	float GetDamping();

	void SetDamping(float val);

	bool GetPaused();

	bool IsFullPlaneSim();

	void SetPaused(bool val);

	float GetExitPauseDelay();

	float GetInterPlanePauseDelay();

	void SetExitPauseDelay(float val);

	void SetInterPlanePauseDelay(float val);

	bool GetCollisionCulling();

	void SetCollisionCulling(bool val);

	bool GetAmbientMode();

	bool GetInteractiveAmbientMode();

	int GetSmoothingLevel();

	void SetSmoothingLevel(int val);

	int GetBR();

	void SetBR(int val);
}
public class RealWaterMouseInput : MonoBehaviour
{
	[Tooltip("Force multiplier applied to all touch and mouse inputs.")]
	[Range(0.01f, 1f)]
	public float InputForce = 1f;

	[Tooltip("Enables multi touch input to RealWater planes for supported devices (max 10 simultaneous inputs).")]
	public bool MultiTouchInput;

	[Tooltip("Maximum number of simultaneous touch inputs to the plane. Large numbers of concurrent touches may decrease performance.")]
	[Range(1f, 10f)]
	public int MaxTouches = 3;

	[Tooltip("Extrapolates between input points, allows for smoother more consistent input")]
	public bool ExtrapolateInput = true;

	private bool checkForInput = true;

	private float inputChangeCheckFrequency = 2000f;

	private RaycastHit hit;

	private RWInput[] touches = new RWInput[10];

	private RWInput mouse = new RWInput();

	private BresenhamLineDrawer lineDrawer = new BresenhamLineDrawer();

	private void Start()
	{
		InvokeRepeating("InputChangeDetection", 0.003f, 1f / inputChangeCheckFrequency);
		for (int i = 0; i < 10; i++)
		{
			touches[i] = new RWInput();
		}
	}

	public bool GetCheckInput()
	{
		return checkForInput;
	}

	public void SetCheckCollisions(bool val)
	{
		checkForInput = val;
	}

	private void InputChangeDetection()
	{
		if (Input.GetMouseButtonUp(0))
		{
			mouse.SetFirstInput(val: true);
		}
		if (!MultiTouchInput || !ExtrapolateInput)
		{
			return;
		}
		Touch[] array = Input.touches;
		for (int i = 0; i < array.Length; i++)
		{
			Touch touch = array[i];
			if (touch.phase == TouchPhase.Ended || touch.phase == TouchPhase.Began)
			{
				for (int j = 0; j < 10; j++)
				{
					touches[j].SetFirstInput(val: true);
				}
			}
		}
	}

	public void CheckInput()
	{
		if (!MultiTouchInput)
		{
			if (!Input.GetMouseButton(0) || !checkForInput)
			{
				return;
			}
			if (Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out hit) && hit.collider.gameObject.name == "RealWater Plane")
			{
				float num = hit.collider.gameObject.GetComponent<RealWaterInterface>().GetRows();
				float num2 = hit.collider.gameObject.GetComponent<RealWaterInterface>().GetCols();
				float speed = hit.collider.gameObject.GetComponent<RealWaterInterface>().GetSpeed();
				int num3 = (int)(hit.textureCoord.x * num2);
				int num4 = (int)(hit.textureCoord.y * num);
				int bR = hit.collider.gameObject.GetComponent<RealWaterInterface>().GetBR();
				bool paused = hit.collider.gameObject.GetComponent<RealWaterInterface>().GetPaused();
				if (speed != 0f && num3 > bR + 1 && (float)num3 < num2 - (float)bR + 1f && (float)num4 < num - (float)(bR + 2) && num4 > bR + 2 && !paused)
				{
					if (ExtrapolateInput)
					{
						if (!mouse.GetFirstInput())
						{
							if (mouse.GetFirstPoint())
							{
								mouse.SetX1(num4);
								mouse.SetY1(num3);
								mouse.SetPlane1(hit.collider.GetInstanceID());
							}
							else
							{
								mouse.SetX2(num4);
								mouse.SetY2(num3);
								mouse.SetPlane2(hit.collider.GetInstanceID());
							}
							if (mouse.GetPlane1() == mouse.GetPlane2())
							{
								lineDrawer.DrawLine(mouse.GetX1(), mouse.GetX2(), mouse.GetY1(), mouse.GetY2(), hit, InputForce);
							}
							mouse.SetFirstPoint(!mouse.GetFirstPoint());
						}
						else
						{
							mouse.SetX1(num4);
							mouse.SetY1(num3);
							mouse.SetX2(num4);
							mouse.SetY2(num3);
							mouse.SetFirstInput(val: false);
						}
					}
					else
					{
						hit.collider.gameObject.GetComponent<RealWaterInterface>().DisturbBufferAt(num4, num3, (int)(18000000f * InputForce), ambient: false);
					}
				}
				else
				{
					mouse.SetFirstInput(val: true);
				}
			}
			else
			{
				mouse.SetFirstInput(val: true);
			}
			return;
		}
		int num5 = 0;
		if (Input.touchCount <= 0 || !checkForInput)
		{
			return;
		}
		Touch[] array = Input.touches;
		foreach (Touch touch in array)
		{
			if (num5 >= MaxTouches)
			{
				break;
			}
			if (Physics.Raycast(Camera.main.ScreenPointToRay(touch.position), out hit) && hit.collider.gameObject.name == "RealWater Plane")
			{
				float num6 = hit.collider.gameObject.GetComponent<RealWaterInterface>().GetRows();
				float num7 = hit.collider.gameObject.GetComponent<RealWaterInterface>().GetCols();
				int num8 = (int)(hit.textureCoord.x * num7);
				int num9 = (int)(hit.textureCoord.y * num6);
				int bR2 = hit.collider.gameObject.GetComponent<RealWaterInterface>().GetBR();
				if (num8 > bR2 + 1 && (float)num8 < num7 - (float)bR2 + 1f && (float)num9 < num6 - (float)(bR2 + 2) && num9 > bR2 + 1)
				{
					if (ExtrapolateInput)
					{
						if (!touches[num5].GetFirstInput())
						{
							if (touches[num5].GetFirstPoint())
							{
								touches[num5].SetX1(num9);
								touches[num5].SetY1(num8);
								touches[num5].SetPlane1(hit.collider.GetInstanceID());
							}
							else
							{
								touches[num5].SetX2(num9);
								touches[num5].SetY2(num8);
								touches[num5].SetPlane2(hit.collider.GetInstanceID());
							}
							if (touches[num5].GetPlane1() == touches[num5].GetPlane2())
							{
								lineDrawer.DrawLine(touches[num5].GetX1(), touches[num5].GetX2(), touches[num5].GetY1(), touches[num5].GetY2(), hit, InputForce);
							}
							touches[num5].SetFirstPoint(!touches[num5].GetFirstPoint());
						}
						else
						{
							touches[num5].SetX1(num9);
							touches[num5].SetY1(num8);
							touches[num5].SetX2(num9);
							touches[num5].SetY2(num8);
							touches[num5].SetFirstInput(val: false);
						}
					}
					else
					{
						hit.collider.gameObject.GetComponent<RealWaterInterface>().DisturbBufferAt(num9, num8, (int)(18000000f * InputForce), ambient: false);
					}
				}
				else
				{
					touches[num5].SetFirstInput(val: true);
				}
			}
			else
			{
				touches[num5].SetFirstInput(val: true);
			}
			num5++;
		}
		num5 = 0;
	}

	public void Reset()
	{
		mouse.SetFirstInput(val: true);
		for (int i = 0; i < 10; i++)
		{
			touches[i].SetFirstInput(val: true);
		}
	}
}
public class RealWaterNormalMap : MonoBehaviour, RealWaterInterface
{
	[Tooltip("The texture on which to draw the simulation).")]
	public Texture2D normalMap;

	public SimulationSettings simulationSettings;

	public FadeSettings fadeSettings;

	public InputSmoothingSettings inputSmoothingSettings;

	public ObstructionSettings obstructionSettings;

	public ObstructionTextureSettings obstructionTextureSettings;

	[Tooltip("Wave dissipation multiplier (Higher values-> Less dissipation).")]
	[Range(0.7f, 0.999f)]
	public float Damping = 0.97f;

	private int[] buffer1;

	private int[] buffer2;

	private int[] bufferCurrent;

	private TextureScanner textureScanner;

	private int columns;

	private int rows;

	private int baseForce = 18000000;

	private bool buffer1Current = true;

	private bool buffer1CurrentAmb = true;

	private int arrayLength;

	private RealWaterMouseInput inputManager;

	private Vector3[] vertices;

	private bool allowInput = true;

	private float simulationSpeed;

	private bool visible = true;

	private bool ready;

	private Renderer rend;

	private bool paused = true;

	private int obstructionCounter;

	private int[] obstructionTextureColumns;

	private int[] obstructionTextureRows;

	private int[] obstructedTexturePositions;

	private int[] obstructedPositions;

	private int obstructionTextureCounter;

	private bool obstructionsScanned;

	private bool obstructionTextuReScanned;

	private bool obstructionTexturesEnabledCurrent;

	private bool obstructionsEnabledCurrent;

	private int rowStart;

	private int rowEnd;

	private int colStart;

	private int colEnd;

	private Vector2 inputPosition;

	private Vector2 inputPositionPrev;

	private bool up;

	private bool down;

	private bool left;

	private bool right;

	private void Start()
	{
		initializeVariables();
		if (obstructionSettings.ObstructionsEnabled)
		{
			ObstructionDetection();
		}
		if (obstructionTextureSettings.ObstructionTexturesEnabled)
		{
			ProcessObstructionTexture();
		}
		InvokeRepeating("VariableChangeCheck", 0.001f, 1f / 30f);
		InvokeRepeating("Fade", 0.0001f, 1f / fadeSettings.fadeRate);
		if (simulationSettings.fullPlaneSimulation)
		{
			initFullPlaneSim();
		}
		InvokeRepeating("VisibilityCheck", 0.001f, 0.2f);
	}

	private void initializeVariables()
	{
		inputManager = UnityEngine.Object.FindObjectOfType(typeof(RealWaterMouseInput)) as RealWaterMouseInput;
		rend = GetComponent<Renderer>();
		rowStart = 1;
		rowEnd = 1;
		colStart = 1;
		colEnd = 1;
		if (normalMap != null)
		{
			try
			{
				normalMap.GetPixel(0, 0);
			}
			catch (UnityException ex)
			{
				if (ex.Message.StartsWith("Texture '" + normalMap.name + "' is not readable"))
				{
					UnityEngine.Debug.LogError("Please enable read/write for Normal Map: [" + normalMap.name + "]");
					paused = true;
					simulationSettings.collisionCulling = false;
				}
			}
		}
		else
		{
			UnityEngine.Debug.LogError("No normal map assigned!");
			paused = true;
			simulationSettings.collisionCulling = false;
		}
		arrayLength = normalMap.GetPixels().Length;
		buffer1 = new int[arrayLength];
		buffer2 = new int[arrayLength];
		Color32[] array = new Color32[arrayLength];
		columns = normalMap.width;
		rows = normalMap.height;
		bufferCurrent = buffer1;
		obstructionTexturesEnabledCurrent = obstructionTextureSettings.ObstructionTexturesEnabled;
		visible = true;
		for (int i = 0; i < arrayLength; i++)
		{
			array[i] = new Color32(127, 127, 127, 127);
		}
		normalMap.SetPixels32(array);
		normalMap.Apply();
		textureScanner = new TextureScanner(rows, columns);
	}

	private void initFullPlaneSim()
	{
		inputPosition = new Vector2(columns / 2, rows / 2);
		simulationSettings.adaptiveSimulationSettings.useAdaptivePosition = false;
		if (rows < columns)
		{
			simulationSettings.simSize = columns;
		}
		else
		{
			simulationSettings.simSize = rows;
		}
	}

	public void Pause()
	{
		CancelInvoke("MainLoop");
		CancelInvoke("Fade");
		CancelInvoke("VariableChangeCheck");
		CancelInvoke("SetObstructionTexture");
		CancelInvoke("SetObstructions");
		Color32[] array = new Color32[(colEnd - colStart) * (rowEnd - rowStart)];
		for (int i = colStart; i < colEnd; i++)
		{
			for (int j = rowStart; j < rowEnd; j++)
			{
				int num = (j - 1) * columns + i - 1;
				int num2 = (j - rowStart) * (colEnd - colStart) + i - colStart;
				buffer1[num] = 0;
				buffer2[num] = 0;
				bufferCurrent[num] = 0;
				array[num2] = new Color32(127, 127, 127, 127);
			}
		}
		normalMap.SetPixels32(colStart, rowStart, colEnd - colStart, rowEnd - rowStart, array);
		Fade();
		normalMap.Apply(updateMipmaps: false);
		paused = true;
	}

	public void Play()
	{
		if (paused)
		{
			InvokeRepeating("MainLoop", 0.001f, 1f / simulationSpeed);
			InvokeRepeating("Fade", 0.0001f, 1f / fadeSettings.fadeRate);
			if (obstructionTextureSettings.ObstructionTexturesEnabled && obstructionTextureSettings.SetRate == ObstructionTextureSettings.setRate.Half)
			{
				InvokeRepeating("SetObstructionTexture", 0.008f, 1f / (simulationSpeed * 0.55f));
			}
			else if (obstructionTextureSettings.ObstructionTexturesEnabled && obstructionTextureSettings.SetRate == ObstructionTextureSettings.setRate.Full)
			{
				InvokeRepeating("SetObstructionTexture", 0.008f, 1f / simulationSpeed);
			}
			if (obstructionSettings.ObstructionsEnabled && obstructionSettings.SetRate == ObstructionSettings.setRate.Half)
			{
				InvokeRepeating("SetObstructions", 0.003f, 1f / (simulationSpeed * 0.55f));
			}
			else if (obstructionSettings.ObstructionsEnabled && obstructionSettings.SetRate == ObstructionSettings.setRate.Full)
			{
				InvokeRepeating("SetObstructions", 0.003f, 1f / simulationSpeed);
			}
			obstructionsEnabledCurrent = obstructionSettings.ObstructionsEnabled;
			obstructionTexturesEnabledCurrent = obstructionTextureSettings.ObstructionTexturesEnabled;
			InvokeRepeating("VariableChangeCheck", 0.001f, 1f / 30f);
			paused = false;
			visible = true;
		}
	}

	public void ObstructionDetection()
	{
		List<int> list = new List<int>();
		Vector3 center = rend.bounds.center;
		float num = rend.bounds.size.x / 2f;
		float num2 = rend.bounds.size.z / 2f;
		float num3 = center[0] - num;
		float num4 = center[0] + num;
		float num5 = center[2] + num2;
		float num6 = center[2] - num2;
		float num7 = (num4 - num3) / (float)(columns + 1);
		float num8 = (num5 - num6) / (float)(rows + 1);
		float y = center[1];
		for (float num9 = num3; num9 < num4; num9 += num7)
		{
			for (float num10 = num6; num10 < num5; num10 += num8)
			{
				Vector3 vector = new Vector3(num9, y, num10);
				if (Physics.Raycast(vector + Vector3.up * obstructionSettings.heightCuttoff, Vector3.down, out var hitInfo, obstructionSettings.heightCuttoff) && hitInfo.collider.gameObject.name != "RealWater Plane" && hitInfo.collider.gameObject.GetComponent<RealWaterCollider>() == null && !hitInfo.collider.gameObject.name.Contains("RW-NonOb") && hitInfo.collider.gameObject.GetComponent<Camera>() == null && Physics.Raycast(vector + Vector3.up * 0.01f, Vector3.down, out var hitInfo2, 0.01f) && hitInfo2.collider.gameObject.name == "RealWater Plane")
				{
					int num11 = (int)(hitInfo2.textureCoord.x * (float)columns);
					int item = (int)(hitInfo2.textureCoord.y * (float)rows) * columns + num11;
					list.Add(item);
					obstructionCounter++;
				}
			}
		}
		obstructedPositions = list.ToArray();
		list.Clear();
		list.TrimExcess();
		obstructionsScanned = true;
	}

	public void ProcessObstructionTexture()
	{
		bool flag = true;
		if (obstructionTextureSettings.ObstructionTexture != null)
		{
			try
			{
				obstructionTextureSettings.ObstructionTexture.GetPixel(0, 0);
			}
			catch (UnityException ex)
			{
				if (ex.Message.StartsWith("Texture '" + obstructionTextureSettings.ObstructionTexture.name + "' is not readable"))
				{
					UnityEngine.Debug.LogError("Please enable read/write for Obstruction Texture: [" + obstructionTextureSettings.ObstructionTexture.name + "]");
					flag = false;
				}
			}
			if (flag)
			{
				textureScanner.setTexture(obstructionTextureSettings.ObstructionTexture);
				textureScanner.setGSCuttOff(obstructionTextureSettings.GrayScaleCuttoff);
				obstructionTextuReScanned = textureScanner.ProcessTexture();
				obstructionTextureColumns = textureScanner.getCols();
				obstructionTextureRows = textureScanner.getRows();
				obstructionTextureCounter = textureScanner.getCount();
				obstructedTexturePositions = new int[obstructionTextureCounter];
				for (int i = 0; i < obstructionTextureCounter; i++)
				{
					obstructedTexturePositions[i] = obstructionTextureRows[i] * columns + obstructionTextureColumns[i];
				}
			}
		}
		else
		{
			obstructionTextuReScanned = true;
			UnityEngine.Debug.LogError("No Obstruction Texture Assigned");
		}
	}

	private void VisibilityCheck()
	{
		if (!GetComponent<Renderer>().isVisible && ready)
		{
			CancelInvoke("MainLoop");
			CancelInvoke("VariableChangeCheck");
			CancelInvoke("SetObstructionTexture");
			CancelInvoke("SetObstructions");
			CancelInvoke("Fade");
			visible = false;
		}
		else if (!visible && GetComponent<Renderer>().isVisible && ready && !paused)
		{
			InvokeRepeating("MainLoop", 0.001f, 1f / simulationSpeed);
			InvokeRepeating("Fade", 0.0001f, 1f / fadeSettings.fadeRate);
			if (obstructionTextureSettings.ObstructionTexturesEnabled && obstructionTextureSettings.SetRate == ObstructionTextureSettings.setRate.Half)
			{
				InvokeRepeating("SetObstructionTexture", 0.008f, 1f / (simulationSpeed * 0.55f));
			}
			else if (obstructionTextureSettings.ObstructionTexturesEnabled && obstructionTextureSettings.SetRate == ObstructionTextureSettings.setRate.Full)
			{
				InvokeRepeating("SetObstructionTexture", 0.008f, 1f / simulationSpeed);
			}
			if (obstructionSettings.ObstructionsEnabled && obstructionSettings.SetRate == ObstructionSettings.setRate.Half)
			{
				InvokeRepeating("SetObstructions", 0.003f, 1f / (simulationSpeed * 0.55f));
			}
			else if (obstructionSettings.ObstructionsEnabled && obstructionSettings.SetRate == ObstructionSettings.setRate.Full)
			{
				InvokeRepeating("SetObstructions", 0.003f, 1f / simulationSpeed);
			}
			obstructionsEnabledCurrent = obstructionSettings.ObstructionsEnabled;
			obstructionTexturesEnabledCurrent = obstructionTextureSettings.ObstructionTexturesEnabled;
			InvokeRepeating("VariableChangeCheck", 0.001f, 1f / 30f);
			visible = true;
		}
	}

	public void MainLoop()
	{
		if (buffer1Current)
		{
			HugoEliasFilter(buffer2, buffer1);
			bufferCurrent = buffer1;
		}
		else
		{
			HugoEliasFilter(buffer1, buffer2);
			bufferCurrent = buffer2;
		}
		Color32[] array = new Color32[(colEnd - colStart) * (rowEnd - rowStart)];
		for (int i = colStart; i < colEnd; i++)
		{
			for (int j = rowStart; j < rowEnd; j++)
			{
				int num = (j - 1) * columns + i - 1;
				int num2 = (j - rowStart) * (colEnd - colStart) + i - colStart;
				if (inputSmoothingSettings.ClampBuffer)
				{
					bufferCurrent[num] = (int)Mathf.Clamp(bufferCurrent[num], (float)(-baseForce) * inputSmoothingSettings.Clamping, (float)baseForce * inputSmoothingSettings.Clamping);
				}
				byte b = (byte)(((float)(bufferCurrent[num] / 2) / ((float)baseForce * inputSmoothingSettings.Clamping) + 0.5f) * 255f);
				array[num2] = new Color32(b, b, b, b);
			}
		}
		normalMap.SetPixels32(colStart, rowStart, colEnd - colStart, rowEnd - rowStart, array);
		normalMap.Apply(updateMipmaps: false);
		buffer1Current = !buffer1Current;
	}

	private void Fade()
	{
		int num = simulationSettings.simSize / 2;
		int num2 = (int)inputPosition[1];
		int num3 = (int)inputPosition[0];
		rowStart = Mathf.Clamp(num3 - num, 2, rows - 1);
		rowEnd = Mathf.Clamp(num3 + num, 2, rows - 1);
		colStart = Mathf.Clamp(num2 - num, 2, columns - 1);
		colEnd = Mathf.Clamp(num2 + num, 2, columns - 1);
		int num4 = Mathf.Clamp(colStart - fadeSettings.fadeSize, 1, columns);
		int num5 = Mathf.Clamp(colEnd + fadeSettings.fadeSize, 1, columns);
		int num6 = Mathf.Clamp(rowStart - fadeSettings.fadeSize, 1, rows);
		int num7 = Mathf.Clamp(rowEnd + fadeSettings.fadeSize, 1, rows);
		int num8 = (num5 - num4) * (rowStart - num6);
		int num9 = (num5 - num4) * (num7 - rowEnd);
		int num10 = (colStart - num4) * (num7 - num6);
		int num11 = (num5 - colEnd) * (num7 - num6);
		Color32[] array = new Color32[num8];
		Color32[] array2 = new Color32[num9];
		Color32[] array3 = new Color32[num10];
		Color32[] array4 = new Color32[num11];
		for (int i = num4; i < num5; i++)
		{
			for (int j = num6; j < rowStart; j++)
			{
				int num12 = (j - 1) * columns + i - 1;
				int num13 = (j - num6) * (num5 - num4) + i - num4;
				buffer1[num12] = 0;
				buffer2[num12] = 0;
				bufferCurrent[num12] = 0;
				array[num13] = new Color32(127, 127, 127, 127);
			}
			for (int k = rowEnd; k < num7; k++)
			{
				int num14 = (k - 1) * columns + i - 1;
				int num15 = (k - rowEnd) * (num5 - num4) + i - num4;
				buffer1[num14] = 0;
				buffer2[num14] = 0;
				bufferCurrent[num14] = 0;
				array2[num15] = new Color32(127, 127, 127, 127);
			}
		}
		for (int l = num6; l < num7; l++)
		{
			for (int m = num4; m < colStart; m++)
			{
				int num16 = (l - 1) * columns + m - 1;
				int num17 = (l - num6) * (colStart - num4) + m - num4;
				buffer1[num16] = 0;
				buffer2[num16] = 0;
				bufferCurrent[num16] = 0;
				array3[num17] = new Color32(127, 127, 127, 127);
			}
			for (int n = colEnd; n < num5; n++)
			{
				int num18 = (l - 1) * columns + n - 1;
				int num19 = (l - num6) * (num5 - colEnd) + n - colEnd;
				buffer1[num18] = 0;
				buffer2[num18] = 0;
				bufferCurrent[num18] = 0;
				array4[num19] = new Color32(127, 127, 127, 127);
			}
		}
		normalMap.SetPixels32(num4, num6, num5 - num4, rowStart - num6, array);
		normalMap.SetPixels32(num4, rowEnd, num5 - num4, num7 - rowEnd, array2);
		normalMap.SetPixels32(num4, num6, colStart - num4, num7 - num6, array3);
		normalMap.SetPixels32(colEnd, num6, num5 - colEnd, num7 - num6, array4);
	}

	private void VariableChangeCheck()
	{
		if (obstructionTexturesEnabledCurrent != obstructionTextureSettings.ObstructionTexturesEnabled)
		{
			if (obstructionTextureSettings.ObstructionTexturesEnabled && obstructionTextureSettings.SetRate == ObstructionTextureSettings.setRate.Half)
			{
				InvokeRepeating("SetObstructionTexture", 0.003f, 1f / (simulationSpeed * 0.55f));
			}
			else if (obstructionTextureSettings.ObstructionTexturesEnabled && obstructionTextureSettings.SetRate == ObstructionTextureSettings.setRate.Full)
			{
				InvokeRepeating("SetObstructionTexture", 0.003f, 1f / simulationSpeed);
			}
			if (!obstructionTextureSettings.ObstructionTexturesEnabled)
			{
				CancelInvoke("SetObstructionTexture");
			}
			obstructionTexturesEnabledCurrent = obstructionTextureSettings.ObstructionTexturesEnabled;
		}
		if (obstructionsEnabledCurrent != obstructionSettings.ObstructionsEnabled)
		{
			if (obstructionSettings.ObstructionsEnabled && obstructionSettings.SetRate == ObstructionSettings.setRate.Half)
			{
				InvokeRepeating("SetObstructions", 0.003f, 1f / (simulationSpeed * 0.55f));
			}
			else if (obstructionSettings.ObstructionsEnabled && obstructionSettings.SetRate == ObstructionSettings.setRate.Full)
			{
				InvokeRepeating("SetObstructions", 0.003f, 1f / simulationSpeed);
			}
			else if (!obstructionSettings.ObstructionsEnabled)
			{
				CancelInvoke("SetObstructions");
			}
			obstructionsEnabledCurrent = obstructionSettings.ObstructionsEnabled;
		}
	}

	public void DisturbBufferAt(int row, int column, int force, bool ambient)
	{
		if (!allowInput)
		{
			return;
		}
		int num = row * columns + column;
		bufferCurrent[num] = force;
		if (!inputSmoothingSettings.SmoothingEnabled)
		{
			return;
		}
		for (int i = 0; i < inputSmoothingSettings.SmoothingLevel; i++)
		{
			for (int j = row - inputSmoothingSettings.BlurRadius; j <= row + inputSmoothingSettings.BlurRadius; j++)
			{
				for (int k = column - inputSmoothingSettings.BlurRadius; k <= column + inputSmoothingSettings.BlurRadius; k++)
				{
					bufferCurrent[(j - 1) * columns + k - 1] = (bufferCurrent[(j - 3) * columns + (k - 2) - 1] + 4 * bufferCurrent[(j - 3) * columns + (k - 1) - 1] + 7 * bufferCurrent[(j - 3) * columns + k - 1] + 4 * bufferCurrent[(j - 3) * columns + (k + 1) - 1] + bufferCurrent[(j - 3) * columns + (k + 2) - 1] + 4 * bufferCurrent[(j - 2) * columns + (k - 2) - 1] + 16 * bufferCurrent[(j - 2) * columns + (k - 1) - 1] + 26 * bufferCurrent[(j - 2) * columns + k - 1] + 16 * bufferCurrent[(j - 2) * columns + (k + 1) - 1] + 4 * bufferCurrent[(j - 2) * columns + (k + 2) - 1] + 7 * bufferCurrent[(j - 1) * columns + (k - 2) - 1] + 26 * bufferCurrent[(j - 1) * columns + (k - 1) - 1] + 41 * bufferCurrent[(j - 1) * columns + k - 1] + 26 * bufferCurrent[(j - 1) * columns + (k + 1) - 1] + 7 * bufferCurrent[(j - 1) * columns + (k + 2) - 1] + 4 * bufferCurrent[j * columns + (k - 2) - 1] + 16 * bufferCurrent[j * columns + (k - 1) - 1] + 26 * bufferCurrent[j * columns + k - 1] + 16 * bufferCurrent[j * columns + (k + 1) - 1] + 4 * bufferCurrent[j * columns + (k + 2) - 1] + bufferCurrent[(j + 1) * columns + (k - 2) - 1] + 4 * bufferCurrent[(j + 1) * columns + (k - 1) - 1] + 7 * bufferCurrent[(j + 1) * columns + k - 1] + 4 * bufferCurrent[(j + 1) * columns + (k + 1) - 1] + bufferCurrent[(j + 1) * columns + (k + 2) - 1]) / 273;
				}
			}
		}
	}

	private void HugoEliasFilter(int[] previousBuffer, int[] currentBuffer)
	{
		int num = simulationSettings.simSize / 2;
		int num2 = (int)inputPosition[1];
		int num3 = (int)inputPosition[0];
		if (simulationSettings.adaptiveSimulationSettings.useAdaptivePosition)
		{
			if ((int)inputPosition[1] < (int)inputPositionPrev[1] - simulationSettings.adaptiveSimulationSettings.adaptiveTollerance)
			{
				num2 = (int)Mathf.Clamp(inputPosition[1] + (float)simulationSettings.adaptiveSimulationSettings.adaptiveOffset, 2f, columns - 1);
				right = true;
				left = false;
			}
			else if ((int)inputPosition[1] <= (int)inputPositionPrev[1] + simulationSettings.adaptiveSimulationSettings.adaptiveTollerance)
			{
				num2 = (right ? ((int)Mathf.Clamp(inputPosition[1] + (float)simulationSettings.adaptiveSimulationSettings.adaptiveOffset, 2f, columns - 1)) : ((!left) ? ((int)inputPosition[1]) : ((int)Mathf.Clamp(inputPosition[1] - (float)simulationSettings.adaptiveSimulationSettings.adaptiveOffset, 2f, columns - 1))));
			}
			else
			{
				num2 = (int)Mathf.Clamp(inputPosition[1] - (float)simulationSettings.adaptiveSimulationSettings.adaptiveOffset, 2f, columns - 1);
				left = true;
				right = false;
			}
			if ((int)inputPosition[0] < (int)inputPositionPrev[0] - simulationSettings.adaptiveSimulationSettings.adaptiveTollerance)
			{
				num3 = (int)Mathf.Clamp(inputPosition[0] + (float)simulationSettings.adaptiveSimulationSettings.adaptiveOffset, 2f, rows - 1);
				up = true;
				down = false;
			}
			else if ((int)inputPosition[0] <= (int)inputPositionPrev[0] + simulationSettings.adaptiveSimulationSettings.adaptiveTollerance)
			{
				num3 = (up ? ((int)Mathf.Clamp(inputPosition[0] + (float)simulationSettings.adaptiveSimulationSettings.adaptiveOffset, 2f, rows - 1)) : ((!down) ? ((int)inputPosition[0]) : ((int)Mathf.Clamp(inputPosition[0] - (float)simulationSettings.adaptiveSimulationSettings.adaptiveOffset, 2f, rows - 1))));
			}
			else
			{
				num3 = (int)Mathf.Clamp(inputPosition[0] - (float)simulationSettings.adaptiveSimulationSettings.adaptiveOffset, 2f, rows - 1);
				down = true;
				up = false;
			}
		}
		rowStart = Mathf.Clamp(num3 - num, 2, rows - 1);
		rowEnd = Mathf.Clamp(num3 + num, 2, rows - 1);
		colStart = Mathf.Clamp(num2 - num, 2, columns - 1);
		colEnd = Mathf.Clamp(num2 + num, 2, columns - 1);
		for (int i = colStart; i < colEnd; i++)
		{
			for (int j = rowStart; j < rowEnd; j++)
			{
				int num4 = (j - 1) * columns + i - 1;
				currentBuffer[num4] = (previousBuffer[num4 - 1] + previousBuffer[num4 + 1] + previousBuffer[num4 - columns] + previousBuffer[num4 + columns]) / 2 - currentBuffer[num4];
				currentBuffer[num4] = (int)((float)currentBuffer[num4] * Damping);
			}
		}
		inputPositionPrev = inputPosition;
	}

	public void SetObstructions()
	{
		if (!obstructionsScanned)
		{
			ObstructionDetection();
		}
		int num = rowStart * columns + colStart;
		int num2 = rowEnd * columns + colEnd;
		for (int i = 0; i < obstructionCounter; i++)
		{
			int num3 = obstructedPositions[i];
			if (num3 <= num2 && num3 >= num)
			{
				bufferCurrent[num3] = 0;
			}
		}
	}

	public void SetObstructionTexture()
	{
		if (!obstructionTextuReScanned)
		{
			ProcessObstructionTexture();
		}
		if (obstructionTextureSettings.ReScan)
		{
			obstructionTextureCounter = 0;
			ProcessObstructionTexture();
		}
		obstructionTextureSettings.ReScan = false;
		int num = rowStart * columns + colStart;
		int num2 = rowEnd * columns + colEnd;
		if (obstructionTextureSettings.useAppearanceModifiers)
		{
			for (int i = 0; i < obstructionTextureCounter; i++)
			{
				int num3;
				int num4;
				if (obstructionTextureSettings.Appearance.FlipImage)
				{
					num3 = rows - (int)((float)obstructionTextureRows[i] * obstructionTextureSettings.Appearance.RowScale) + obstructionTextureSettings.Appearance.RowOffset;
					num4 = columns - (int)((float)obstructionTextureColumns[i] * obstructionTextureSettings.Appearance.ColScale) + obstructionTextureSettings.Appearance.ColOffset;
				}
				else
				{
					num3 = (int)((float)obstructionTextureRows[i] * obstructionTextureSettings.Appearance.RowScale) + obstructionTextureSettings.Appearance.RowOffset;
					num4 = (int)((float)obstructionTextureColumns[i] * obstructionTextureSettings.Appearance.ColScale) + obstructionTextureSettings.Appearance.ColOffset;
				}
				if (num4 > 0 && num4 < columns && num3 > 0 && num3 < rows)
				{
					int num5 = num3 * columns + num4;
					if (num5 <= num2 && num5 >= num)
					{
						bufferCurrent[num5] = 0;
					}
				}
			}
			return;
		}
		for (int j = 0; j < obstructionTextureCounter; j++)
		{
			int num6 = obstructedTexturePositions[j];
			if (num6 <= num2 && num6 >= num)
			{
				bufferCurrent[num6] = 0;
			}
		}
	}

	public void Reset()
	{
		RealWaterCollider.reseting = true;
		CancelInvoke("MainLoop");
		CancelInvoke("SetObstructions");
		CancelInvoke("SetObstructionTexture");
		CancelInvoke("VariableChangeCheck");
		CancelInvoke("Fade");
		obstructionCounter = 0;
		obstructionTextureCounter = 0;
		obstructionsScanned = false;
		obstructionTextuReScanned = false;
		initializeVariables();
		if (simulationSettings.fullPlaneSimulation)
		{
			initFullPlaneSim();
		}
		if (obstructionSettings.ObstructionsEnabled)
		{
			ObstructionDetection();
			if (!simulationSettings.collisionCulling)
			{
				if (obstructionSettings.ObstructionsEnabled && obstructionSettings.SetRate == ObstructionSettings.setRate.Half)
				{
					InvokeRepeating("SetObstructions", 0.003f, 1f / (simulationSpeed * 0.55f));
				}
				if (obstructionSettings.ObstructionsEnabled && obstructionSettings.SetRate == ObstructionSettings.setRate.Full)
				{
					InvokeRepeating("SetObstructions", 0.003f, 1f / simulationSpeed);
				}
			}
		}
		if (obstructionTextureSettings.ObstructionTexturesEnabled)
		{
			ProcessObstructionTexture();
			if (!simulationSettings.collisionCulling)
			{
				if (obstructionTextureSettings.ObstructionTexturesEnabled && obstructionTextureSettings.SetRate == ObstructionTextureSettings.setRate.Half)
				{
					InvokeRepeating("SetObstructionTexture", 0.003f, 1f / (simulationSpeed * 0.55f));
				}
				if (obstructionTextureSettings.ObstructionTexturesEnabled && obstructionTextureSettings.SetRate == ObstructionTextureSettings.setRate.Full)
				{
					InvokeRepeating("SetObstructionTexture", 0.003f, 1f / simulationSpeed);
				}
			}
		}
		if (inputManager != null)
		{
			inputManager.Reset();
		}
		if (!simulationSettings.collisionCulling)
		{
			InvokeRepeating("MainLoop", 0.001f, 1f / simulationSpeed);
			InvokeRepeating("VariableChangeCheck", 0.001f, 1f / 30f);
			InvokeRepeating("Fade", 0.0001f, 1f / fadeSettings.fadeRate);
		}
		else
		{
			paused = true;
		}
		StartCoroutine("ColliderResetDelay");
	}

	private IEnumerator ColliderResetDelay()
	{
		yield return new WaitForSeconds(0.1f);
		RealWaterCollider.reseting = false;
	}

	public void SetSpeed(float s)
	{
		simulationSpeed = s;
	}

	public float GetSpeed()
	{
		return simulationSpeed;
	}

	public int GetCols()
	{
		return columns;
	}

	public int GetRows()
	{
		return rows;
	}

	public bool GetVisibility()
	{
		return visible;
	}

	public void SetReady(bool val)
	{
		ready = val;
	}

	public void SetInputPos(Vector2 pos)
	{
		inputPosition = pos;
	}

	public ObstructionTextureSettings GetObstructionTextureSettings()
	{
		return obstructionTextureSettings;
	}

	public ObstructionSettings GetObstructionSettings()
	{
		return obstructionSettings;
	}

	public bool GetPaused()
	{
		return paused;
	}

	public bool getIsLarge()
	{
		return true;
	}

	public float GetExitPauseDelay()
	{
		return simulationSettings.exitPauseDelay;
	}

	public float GetInterPlanePauseDelay()
	{
		return simulationSettings.interPlanePauseDelay;
	}

	public void SetExitPauseDelay(float val)
	{
		simulationSettings.exitPauseDelay = val;
	}

	public void SetInterPlanePauseDelay(float val)
	{
		simulationSettings.interPlanePauseDelay = val;
	}

	public bool IsFullPlaneSim()
	{
		return simulationSettings.fullPlaneSimulation;
	}

	public void SetPaused(bool val)
	{
		paused = val;
	}

	public bool GetCollisionCulling()
	{
		return simulationSettings.collisionCulling;
	}

	public void SetCollisionCulling(bool val)
	{
		simulationSettings.collisionCulling = val;
	}

	public bool GetAmbientMode()
	{
		return false;
	}

	public bool GetInteractiveAmbientMode()
	{
		return false;
	}

	public void EnableObstructions(bool val)
	{
		obstructionSettings.ObstructionsEnabled = val;
	}

	public ObstructionSettings.setRate GetObstructionSetRate()
	{
		return obstructionSettings.SetRate;
	}

	public void SetObstructionSetRate(ObstructionSettings.setRate rate)
	{
		obstructionSettings.SetRate = rate;
	}

	public void EnableObstructionTexture(bool val)
	{
		obstructionTextureSettings.ObstructionTexturesEnabled = val;
	}

	public void SetObstructionTextureTo(Texture2D img)
	{
		obstructionTextureSettings.ObstructionTexture = img;
		obstructionTextureSettings.ReScan = true;
	}

	public ObstructionTextureSettings.setRate GetObstructionTextureSetRate()
	{
		return obstructionTextureSettings.SetRate;
	}

	public void SetObstructionTextureSetRate(ObstructionTextureSettings.setRate rate)
	{
		obstructionTextureSettings.SetRate = rate;
	}

	public void SetObstructionTextureAppearance(Appearance settings)
	{
		obstructionTextureSettings.Appearance = settings;
	}

	public int GetSmoothingLevel()
	{
		return inputSmoothingSettings.SmoothingLevel;
	}

	public void SetSmoothingLevel(int val)
	{
		inputSmoothingSettings.SmoothingLevel = val;
	}

	public int GetBR()
	{
		return inputSmoothingSettings.BlurRadius;
	}

	public void SetBR(int val)
	{
		inputSmoothingSettings.BlurRadius = val;
	}

	public float GetDamping()
	{
		return Damping;
	}

	public void SetDamping(float val)
	{
		Damping = val;
	}
}
public class RealWaterSpeedManager : MonoBehaviour
{
	[Tooltip("The simulation speed of all instances of RealWater in this scene.")]
	[Range(0f, 120f)]
	public float Speed = 60f;

	[Tooltip("The mouse/touch input manager for this scene (if using one).")]
	public RealWaterMouseInput MouseInputManager;

	[Tooltip("Set to true if using collision nodes [BETA]")]
	public bool FindCollisionNodes_BETA;

	private RealWaterInterface[] realWaterPlanes;

	private RealWaterCollider[] realWaterColliders;

	private RealWaterCollisionNode[] realWaterCollisionNodes;

	private int numberOfPlanes;

	private int numberOfColliders;

	private int numberOfCollisionNodes;

	private float speedStored;

	private void Start()
	{
		FindPlanes();
		FindColliders();
		if (FindCollisionNodes_BETA)
		{
			FindCollisionNodes();
		}
		if (MouseInputManager != null)
		{
			MouseInputManager.InvokeRepeating("CheckInput", 0.001f, 1f / Speed);
		}
		speedStored = Speed;
		InvokeRepeating("SpeedChangeCheck", 0.0001f, 1f / 60f);
	}

	private void SpeedChangeCheck()
	{
		if (Speed == speedStored)
		{
			return;
		}
		for (int i = 0; i < numberOfPlanes; i++)
		{
			realWaterPlanes[i].SetSpeed(Speed);
			((MonoBehaviour)realWaterPlanes[i]).CancelInvoke("MainLoop");
			((MonoBehaviour)realWaterPlanes[i]).CancelInvoke("AmbientMainLoopInteractive");
			if (realWaterPlanes[i].GetVisibility() && Speed != 0f && !realWaterPlanes[i].GetAmbientMode() && !realWaterPlanes[i].GetPaused())
			{
				((MonoBehaviour)realWaterPlanes[i]).InvokeRepeating("MainLoop", 0.001f, 1f / Speed);
			}
			else if (realWaterPlanes[i].GetAmbientMode() && realWaterPlanes[i].GetInteractiveAmbientMode())
			{
				((MonoBehaviour)realWaterPlanes[i]).InvokeRepeating("AmbientMainLoopInteractive", 0.001f, 1f / Speed);
			}
		}
		if (MouseInputManager != null)
		{
			MouseInputManager.CancelInvoke("CheckInput");
		}
		if (MouseInputManager != null && Speed != 0f)
		{
			MouseInputManager.InvokeRepeating("CheckInput", 0.001f, 1f / Speed);
		}
		for (int j = 0; j < numberOfColliders; j++)
		{
			realWaterColliders[j].CancelInvoke("CheckForCollisions");
			realWaterColliders[j].Reset();
			realWaterColliders[j].SetCollisionFrequency(Speed);
			if (realWaterColliders[j].GetVisibility() && Speed != 0f)
			{
				realWaterColliders[j].InvokeRepeating("CheckForCollisions", 0.001f, 1f / Speed);
			}
		}
		for (int k = 0; k < numberOfCollisionNodes; k++)
		{
			realWaterCollisionNodes[k].CancelInvoke("CheckForCollisions");
			realWaterCollisionNodes[k].collisionCheckFrequency = Speed;
			realWaterCollisionNodes[k].InvokeRepeating("CheckForCollisions", 0.001f, 1f / Speed);
		}
		for (int l = 0; l < numberOfPlanes; l++)
		{
			if (realWaterPlanes[l].GetVisibility() && Speed != 0f)
			{
				if (!realWaterPlanes[l].GetAmbientMode() || (realWaterPlanes[l].GetAmbientMode() && realWaterPlanes[l].GetInteractiveAmbientMode()))
				{
					((MonoBehaviour)realWaterPlanes[l]).CancelInvoke("SetobstructionTexture");
				}
				if (realWaterPlanes[l].GetObstructionTextureSettings().ObstructionTexturesEnabled && realWaterPlanes[l].GetObstructionTextureSettings().SetRate == ObstructionTextureSettings.setRate.Half && (!realWaterPlanes[l].GetAmbientMode() || (realWaterPlanes[l].GetAmbientMode() && realWaterPlanes[l].GetInteractiveAmbientMode())))
				{
					((MonoBehaviour)realWaterPlanes[l]).InvokeRepeating("SetobstructionTexture", 0.003f, 1f / (Speed * 0.55f));
				}
				if (realWaterPlanes[l].GetObstructionTextureSettings().ObstructionTexturesEnabled && realWaterPlanes[l].GetObstructionTextureSettings().SetRate == ObstructionTextureSettings.setRate.Full && (!realWaterPlanes[l].GetAmbientMode() || (realWaterPlanes[l].GetAmbientMode() && realWaterPlanes[l].GetInteractiveAmbientMode())))
				{
					((MonoBehaviour)realWaterPlanes[l]).InvokeRepeating("SetobstructionTexture", 0.003f, 1f / Speed);
				}
				((MonoBehaviour)realWaterPlanes[l]).CancelInvoke("SetObstructions");
				if (realWaterPlanes[l].GetObstructionSettings().ObstructionsEnabled && realWaterPlanes[l].GetObstructionSettings().SetRate == ObstructionSettings.setRate.Half && (!realWaterPlanes[l].GetAmbientMode() || (realWaterPlanes[l].GetAmbientMode() && realWaterPlanes[l].GetInteractiveAmbientMode())))
				{
					((MonoBehaviour)realWaterPlanes[l]).InvokeRepeating("SetObstructions", 0.003f, 1f / (Speed * 0.55f));
				}
				if (realWaterPlanes[l].GetObstructionSettings().ObstructionsEnabled && realWaterPlanes[l].GetObstructionSettings().SetRate == ObstructionSettings.setRate.Full && (!realWaterPlanes[l].GetAmbientMode() || (realWaterPlanes[l].GetAmbientMode() && realWaterPlanes[l].GetInteractiveAmbientMode())))
				{
					((MonoBehaviour)realWaterPlanes[l]).InvokeRepeating("SetObstructions", 0.003f, 1f / Speed);
				}
			}
		}
		speedStored = Speed;
	}

	public void FindPlanes()
	{
		realWaterPlanes = InterfaceHelper.FindObjects<RealWaterInterface>();
		numberOfPlanes = realWaterPlanes.Length;
		for (int i = 0; i < numberOfPlanes; i++)
		{
			((MonoBehaviour)realWaterPlanes[i]).CancelInvoke("MainLoop");
			realWaterPlanes[i].SetSpeed(Speed);
			if (realWaterPlanes[i].GetVisibility() && !realWaterPlanes[i].GetCollisionCulling() && !realWaterPlanes[i].GetAmbientMode())
			{
				((MonoBehaviour)realWaterPlanes[i]).InvokeRepeating("MainLoop", 0.001f, 1f / Speed);
				realWaterPlanes[i].SetPaused(val: false);
			}
			else if (realWaterPlanes[i].GetAmbientMode() && realWaterPlanes[i].GetInteractiveAmbientMode())
			{
				((MonoBehaviour)realWaterPlanes[i]).Invoke("InitializeAmbientMode", 0.0001f);
				((MonoBehaviour)realWaterPlanes[i]).InvokeRepeating("AmbientMainLoopInteractive", 0.001f, 1f / Speed);
				realWaterPlanes[i].SetPaused(val: false);
			}
			realWaterPlanes[i].SetReady(val: true);
		}
	}

	public void FindColliders()
	{
		realWaterColliders = UnityEngine.Object.FindObjectsOfType(typeof(RealWaterCollider)) as RealWaterCollider[];
		numberOfColliders = realWaterColliders.Length;
		int num = 0;
		for (int i = 0; i < numberOfColliders; i++)
		{
			realWaterColliders[i].CancelInvoke("CheckForCollisions");
			if (realWaterColliders[i].mainInput)
			{
				num++;
			}
			realWaterColliders[i].SetCollisionFrequency(Speed);
			if (realWaterColliders[i].GetVisibility())
			{
				realWaterColliders[i].InvokeRepeating("CheckForCollisions", 0.001f, 1f / Speed);
			}
		}
		if (num > 1)
		{
			UnityEngine.Debug.LogError("There is more than one Main Input water collider present in this scene. This may cause problems.");
		}
	}

	public void FindCollisionNodes()
	{
		realWaterCollisionNodes = UnityEngine.Object.FindObjectsOfType(typeof(RealWaterCollisionNode)) as RealWaterCollisionNode[];
		numberOfCollisionNodes = realWaterCollisionNodes.Length;
		for (int i = 0; i < numberOfCollisionNodes; i++)
		{
			realWaterCollisionNodes[i].CancelInvoke("CheckForCollisions");
			realWaterCollisionNodes[i].collisionCheckFrequency = Speed;
			realWaterCollisionNodes[i].InvokeRepeating("CheckForCollisions", 0.001f, 1f / Speed);
		}
	}
}
public class RWInput
{
	private bool firstPoint = true;

	private bool firstInput = true;

	private int x1;

	private int x2;

	private int y1;

	private int y2;

	private int plane1;

	private int plane2;

	public bool GetFirstPoint()
	{
		return firstPoint;
	}

	public void SetFirstPoint(bool val)
	{
		firstPoint = val;
	}

	public bool GetFirstInput()
	{
		return firstInput;
	}

	public void SetFirstInput(bool val)
	{
		firstInput = val;
	}

	public int GetX1()
	{
		return x1;
	}

	public void SetX1(int x)
	{
		x1 = x;
	}

	public int GetX2()
	{
		return x2;
	}

	public void SetX2(int x)
	{
		x2 = x;
	}

	public int GetY1()
	{
		return y1;
	}

	public void SetY1(int y)
	{
		y1 = y;
	}

	public int GetY2()
	{
		return y2;
	}

	public void SetY2(int y)
	{
		y2 = y;
	}

	public int GetPlane1()
	{
		return plane1;
	}

	public void SetPlane1(int val)
	{
		plane1 = val;
	}

	public int GetPlane2()
	{
		return plane2;
	}

	public void SetPlane2(int val)
	{
		plane2 = val;
	}
}
[Serializable]
public class AmbientSettings
{
	public bool AmbientMode;

	public bool Interactive;

	[HideInInspector]
	public bool AmbientModeInitial;

	[Tooltip("Scaling factor applied to wave height.")]
	[Range(-12f, 12f)]
	public float WaveHeight = -0.25f;

	[Tooltip("The number of drops to make at the start of the simulation.")]
	[Range(1f, 450f)]
	public int AmbientWaveIntensity = 14;

	[Tooltip("How long to run the simulation for even when not visible, prevents initial disturbances from being seen")]
	[Range(1E-06f, 10f)]
	public float AmbientStartRuntime = 10f;

	[Range(0f, 100f)]
	public float AmbientSpeed = 50f;
}
[Serializable]
public class InputSmoothingSettings
{
	public bool SmoothingEnabled = true;

	[Tooltip("Number of times to run the smoothing algorithm")]
	[Range(1f, 10f)]
	public int SmoothingLevel = 3;

	[Tooltip("The size of the area around the input position to be smoothed.")]
	[Range(0f, 10f)]
	public int BlurRadius = 3;

	[Tooltip("Whether or not to cap the max wave height. Greatly improves simulation stability if enabled.")]
	public bool ClampBuffer = true;

	[Tooltip("The level of Buffer Clamping")]
	[Range(0.05f, 0.3f)]
	public float Clamping = 0.1f;
}
[Serializable]
public class ObstructionSettings
{
	public enum setRate
	{
		Half,
		Full
	}

	[Tooltip("Whether to check for and set obstructions.")]
	public bool ObstructionsEnabled = true;

	[Tooltip("How high above the plane to raycast down to detect obstructions. May need to lower if you have a roof above the plane")]
	[Range(1f, 1000f)]
	public float heightCuttoff = 25f;

	[Tooltip("How often to apply obstructions. Half speed has better performance but may not look as good in some situations.")]
	public setRate SetRate;
}
[Serializable]
public class Appearance
{
	[Tooltip("Flips the image 180 degrees.")]
	public bool FlipImage;

	[Range(0.1f, 1f)]
	public float RowScale = 1f;

	[Range(0.1f, 1f)]
	public float ColScale = 1f;

	[Range(-500f, 500f)]
	public int RowOffset;

	[Range(-500f, 500f)]
	public int ColOffset;
}
[Serializable]
public class ObstructionTextureSettings
{
	public enum setRate
	{
		Half,
		Full
	}

	public Texture2D ObstructionTexture;

	[Tooltip("Whether to scan in the obstruction texture and set obstructions.")]
	public bool ObstructionTexturesEnabled;

	[Tooltip("How often to apply obstructions. Half speed has better performance but may not look as good in some situations.")]
	public setRate SetRate;

	[Tooltip("ReScans the Obstruction texture. This is needed for changes in image and GrayScaleCuttoff to take effect.")]
	public bool ReScan;

	[Tooltip("The grayscale value of a pixel necessary for it to count as an obstruction.")]
	[Range(0f, 0.99f)]
	public float GrayScaleCuttoff = 0.5f;

	public bool useAppearanceModifiers;

	[Tooltip("These settings CAN be changed in real time..")]
	public Appearance Appearance;
}
[Serializable]
public class DepthSettings
{
	public enum proportionality
	{
		Normal,
		Inverse,
		None
	}

	[Tooltip("Changes the depth/height of the indents IDEPENDANTLY of wave height. However, High values will cause instability when using smoothing, and so in these cases you will have to alter the wave height instead.")]
	[Range(-5f, 5f)]
	public float IndentDepth = -0.5f;

	[Tooltip("Whether indent depth should be proportional (Lighter-> more force) or inversely proportional Darker-> more force) to grayscale value.")]
	public proportionality Proportionality;
}
[Serializable]
public class IndentTextureSettings
{
	public Texture2D IndentTexture;

	[Tooltip("Whether to scan in the indent texture and set indents.")]
	public bool IndentTextureEnabled;

	[Tooltip("ReScans the Indent texture. This is needed for changes in image, GrayScaleCuttoff and Resolution to take effect.")]
	public bool ReScan;

	[Tooltip("Recalculates the mesh bounds each simulation step. May need if using High indent depth to prevent the mesh from disappearing at certain angles.")]
	public bool RecalculateBounds;

	[Tooltip("The grayscale value of a pixel necessary for it to count as an indent.")]
	[Range(0f, 1f)]
	public float GrayScaleCuttoff = 0.5f;

	[Tooltip("These settings CAN be changed in real time..")]
	public DepthSettings DepthSettings;

	[Tooltip("These settings CAN be changed in real time..")]
	public Appearance Appearance;

	[Tooltip("Using smoothing algorithm when indenting the mesh can have a High performance cost.")]
	public bool SmoothingEnabled;
}
[Serializable]
public class RainSettings
{
	public bool RainEnabled;

	[Tooltip("Whether each rain drop should have a random force.")]
	public bool RandomRainForce;

	[Tooltip("Number of rain drops per second.")]
	[Range(1f, 60f)]
	public float RainSpeed = 30f;

	[Tooltip("Force multiplier for Rain drops when not using random force.")]
	[Range(0.01f, 1f)]
	public float RainForce = 0.5f;
}
[Serializable]
public class Meshes
{
	public Mesh VeryLow;

	public Mesh Low;

	public Mesh Medium;

	public Mesh High;

	public Mesh VeryHigh;

	public Mesh Extreme;

	public Mesh VeryLow_Rect;

	public Mesh Low_Rect;

	public Mesh Medium_Rect;

	public Mesh High_Rect;

	public Mesh VeryHigh_Rect;

	public Mesh Extreme_Rect;
}
[Serializable]
public class AdaptiveSimulationSettings
{
	[Tooltip("If enabled the position of the simulation zone will attempt to adapt to the direction of movement of the main input.")]
	public bool useAdaptivePosition;

	[Tooltip("How much of a position offset to apply to the simulation zone.")]
	public int adaptiveOffset = 50;

	[Tooltip("The minimum change in collision position to count as movement.")]
	public int adaptiveTollerance;
}
[Serializable]
public class SimulationSettings
{
	[Tooltip("If enabled the simulation will constantly run on the entire plane. Enable with caution, has a big performance hit for large planes.")]
	public bool fullPlaneSimulation;

	[Tooltip("The size of the area around the main input to simulate.")]
	public int simSize = 196;

	[Tooltip("If enabled the simulation will stop and start depending on whether the main input is colliding with the plane or not.")]
	public bool collisionCulling = true;

	[Tooltip("The length of time to wait before stopping the simulation after collision culling has been triggered by colliding with something other than a water plane.")]
	[Range(0f, 10f)]
	public float exitPauseDelay = 2f;

	[Tooltip("The length of time to wait before stopping the simulation after collision culling has been triggered by colliding with a different water plane.")]
	[Range(0f, 10f)]
	public float interPlanePauseDelay = 2f;

	public AdaptiveSimulationSettings adaptiveSimulationSettings;
}
[Serializable]
public class CollisionCullingSettings
{
	[Tooltip("If enabled the simulation will stop and start depending on whether the main input is colliding with the plane or not.")]
	public bool collisionCulling;

	[Tooltip("The length of time to wait before stopping the simulation after collision culling has been triggered by colliding with something other than a water plane.")]
	[Range(0f, 10f)]
	public float exitPauseDelay = 2f;

	[Tooltip("The length of time to wait before stopping the simulation after collision culling has been triggered by colliding with a different water plane.")]
	[Range(0f, 10f)]
	public float interPlanePauseDelay = 2f;
}
[Serializable]
public class FadeSettings
{
	[Tooltip("Size of the area around the simulation zone to fade wave height to zero.")]
	public int fadeSize = 50;

	[Tooltip("How often to fade the area around the simulation zone.")]
	public float fadeRate = 5f;
}
public class TextureScanner
{
	private Texture2D img;

	private int cols;

	private int rows;

	private float gSCuttOff;

	private int[] detectedCols;

	private int[] detectedRows;

	private float[] grayScaleValues;

	private int counter;

	public TextureScanner(int r, int c)
	{
		rows = r;
		cols = c;
	}

	public void setTexture(Texture2D tex)
	{
		img = tex;
	}

	public void setGSCuttOff(float gCut)
	{
		gSCuttOff = gCut;
	}

	public int getCount()
	{
		return counter;
	}

	public int[] getCols()
	{
		return detectedCols;
	}

	public int[] getRows()
	{
		return detectedRows;
	}

	public float[] getGrayscaleValues()
	{
		return grayScaleValues;
	}

	public bool ProcessTexture()
	{
		List<int> list = new List<int>();
		List<int> list2 = new List<int>();
		List<float> list3 = new List<float>();
		counter = 0;
		float num = 1f / (float)(cols + 1);
		float num2 = 1f / (float)(rows + 1);
		for (float num3 = 0f; num3 <= 1f; num3 += num)
		{
			for (float num4 = 0f; num4 <= 1f; num4 += num2)
			{
				float grayscale = img.GetPixelBilinear(num3, num4).grayscale;
				if (grayscale <= gSCuttOff)
				{
					float num5 = (float)cols * num3;
					float num6 = (float)rows * num4;
					if (counter == 0)
					{
						list.Add((int)num5);
						list2.Add((int)num6);
						list3.Add(grayscale);
						counter++;
					}
					else if (num5 != (float)list[counter - 1] && num6 != (float)list2[counter - 1])
					{
						list.Add((int)num5);
						list2.Add((int)num6);
						list3.Add(grayscale);
						counter++;
					}
				}
			}
		}
		detectedCols = list.ToArray();
		detectedRows = list2.ToArray();
		grayScaleValues = list3.ToArray();
		list.Clear();
		list2.Clear();
		list3.Clear();
		list.TrimExcess();
		list2.TrimExcess();
		list3.TrimExcess();
		return true;
	}
}
public class RotateGameObject : MonoBehaviour
{
	public float rot_speed_x;

	public float rot_speed_y;

	public float rot_speed_z;

	public bool local;

	private void Start()
	{
	}

	private void FixedUpdate()
	{
		if (local)
		{
			base.transform.RotateAroundLocal(base.transform.up, Time.fixedDeltaTime * rot_speed_x);
		}
		else
		{
			base.transform.Rotate(Time.fixedDeltaTime * new Vector3(rot_speed_x, rot_speed_y, rot_speed_z), Space.World);
		}
	}
}
public class BonesOnlyBlendSystem : BlendSystem
{
	public override void OnVariableChanged()
	{
		isReady = true;
	}
}
[Serializable]
public class GestureInstance
{
	[SerializeField]
	public string gesture;

	[SerializeField]
	public AnimationClip clip;

	[SerializeField]
	public string triggerName;

	public GestureInstance(string gesture, AnimationClip clip, string triggerName)
	{
		this.gesture = gesture;
		this.clip = clip;
		this.triggerName = triggerName;
	}

	public bool IsValid(Animator animator)
	{
		for (int i = 0; i < animator.parameters.Length; i++)
		{
			if (animator.parameters[i].name == triggerName)
			{
				return true;
			}
		}
		return false;
	}
}
public class SimplePlayerController : MonoBehaviour
{
	public float MovementSpeed;

	public float MouseSensitivity;

	public Rigidbody rb;

	public GameObject cam;

	private void Start()
	{
	}

	private void Update()
	{
		if (Input.GetKey(KeyCode.Escape))
		{
			Cursor.lockState = CursorLockMode.None;
		}
		else
		{
			Cursor.lockState = CursorLockMode.Locked;
		}
		if (Cursor.lockState == CursorLockMode.Locked)
		{
			cam.transform.eulerAngles += new Vector3((0f - MouseSensitivity) * Input.GetAxis("Mouse Y"), MouseSensitivity * Input.GetAxis("Mouse X"), 0f);
		}
		Vector3 forward = cam.transform.forward;
		forward.y = 0f;
		forward = forward.normalized;
		Vector3 right = cam.transform.right;
		right.y = 0f;
		right = right.normalized;
		if (Input.GetKey(KeyCode.W))
		{
			rb.MovePosition(base.transform.position + forward * MovementSpeed);
		}
		else if (Input.GetKey(KeyCode.S))
		{
			rb.MovePosition(base.transform.position - forward * MovementSpeed);
		}
		if (Input.GetKey(KeyCode.A))
		{
			rb.MovePosition(base.transform.position - right * MovementSpeed);
		}
		else if (Input.GetKey(KeyCode.D))
		{
			rb.MovePosition(base.transform.position + right * MovementSpeed);
		}
	}

	public void PortalCameraCorrect(Transform target)
	{
		base.transform.position = target.position;
		cam.transform.rotation = target.rotation;
	}
}
public class SeamlessPortalsConfig : MonoBehaviour
{
	public enum ColliderTypes
	{
		Auto,
		UserDefined
	}

	public enum AxisList
	{
		x,
		y,
		z
	}

	public enum ObjectType
	{
		PlayerCamera,
		CameraParent,
		TargetTransform
	}

	public Texture2D editorImage;

	public Camera Cam_Player;

	public Camera Cam_PortalB;

	public Camera Cam_PortalA;

	public GameObject GO_PortalA;

	public GameObject GO_PortalB;

	public Material Mat_PortalA;

	public Material Mat_PortalB;

	public bool CullPortalChildren;

	public ColliderTypes ColliderMode;

	public BoxCollider Col_PortalA;

	public BoxCollider Col_PortalB;

	public bool inPortalA;

	public bool inPortalB;

	public AxisList PortalForwardAxis;

	public ObjectType TeleportObject;

	public GameObject tpObject;

	public bool tpoTeleported;

	public GameObject PortalObject;

	public List<GameObject> CamCorrectGameObjects = new List<GameObject>();

	public string CamCorrectFunctionName = "PortalCameraCorrect";

	public bool UpdateFOV;

	public float ClippingPlaneOffset = 0.05f;

	public GameObject[] ViewCube_PortalA = new GameObject[2];

	public GameObject[] ViewCube_PortalB = new GameObject[2];

	public float ViewCubeOffset = 0.05f;

	public float ViewCubeDepth = 0.3f;

	public bool[] CubeActive_PortalA = new bool[2];

	public bool[] CubeActive_PortalB = new bool[2];

	public BoxCollider[] ViewCubeCollider_PortalA;

	public BoxCollider[] ViewCubeCollider_PortalB;

	public MeshRenderer MR_PortalA;

	public MeshRenderer MR_PortalB;

	public MeshRenderer[] ViewCubeMR_PortalA = new MeshRenderer[2];

	public MeshRenderer[] ViewCubeMR_PortalB = new MeshRenderer[2];

	public Vector3 ViewCubeVector_PortalA;

	public Vector3 ViewCubeVector_PortalB;

	public bool AllowTeleport = true;

	public bool HardColliders;

	public bool ERROR;

	public BoxCollider Box_A;

	public BoxCollider Box_B;

	public bool DrawAxisTest;

	private void Start()
	{
		ViewCube_PortalA = new GameObject[2];
		ViewCube_PortalB = new GameObject[2];
		CubeActive_PortalA = new bool[2];
		CubeActive_PortalB = new bool[2];
		ViewCubeCollider_PortalA = new BoxCollider[2];
		ViewCubeCollider_PortalB = new BoxCollider[2];
		ViewCubeMR_PortalA = new MeshRenderer[2];
		ViewCubeMR_PortalB = new MeshRenderer[2];
		PortalObject = new GameObject("Portal Object");
		GameObject gameObject = new GameObject("Cam_PortalA");
		GameObject gameObject2 = new GameObject("Cam_PortalB");
		Cam_PortalA = gameObject.AddComponent<Camera>();
		Cam_PortalB = gameObject2.AddComponent<Camera>();
		if (GO_PortalA != null)
		{
			gameObject.transform.parent = GO_PortalA.transform;
			if (GO_PortalB != null)
			{
				gameObject2.transform.parent = GO_PortalB.transform;
				gameObject2.transform.parent = GO_PortalB.transform;
				Cam_PortalA.nearClipPlane = 0.01f;
				Cam_PortalB.nearClipPlane = 0.01f;
				if (LayerMask.NameToLayer("PortalA") != -1)
				{
					GO_PortalA.layer = LayerMask.NameToLayer("PortalA");
					if (CullPortalChildren)
					{
						for (int i = 0; i < GO_PortalA.transform.childCount; i++)
						{
							GO_PortalA.transform.GetChild(i).gameObject.layer = LayerMask.NameToLayer("PortalA");
						}
					}
					Cam_PortalA.cullingMask += ~(1 << LayerMask.NameToLayer("PortalA"));
					Cam_PortalB.cullingMask += ~(1 << LayerMask.NameToLayer("PortalA"));
					if (LayerMask.NameToLayer("PortalB") != -1)
					{
						GO_PortalB.layer = LayerMask.NameToLayer("PortalB");
						if (CullPortalChildren)
						{
							for (int j = 0; j < GO_PortalB.transform.childCount; j++)
							{
								GO_PortalB.transform.GetChild(j).gameObject.layer = LayerMask.NameToLayer("PortalB");
							}
						}
						Cam_PortalA.cullingMask += ~(1 << LayerMask.NameToLayer("PortalB"));
						Cam_PortalB.cullingMask += ~(1 << LayerMask.NameToLayer("PortalB"));
						if (GO_PortalA.GetComponent<MeshRenderer>() != null)
						{
							Mat_PortalA = GO_PortalA.GetComponent<MeshRenderer>().material;
							if (GO_PortalB.GetComponent<MeshRenderer>() != null)
							{
								Mat_PortalB = GO_PortalB.GetComponent<MeshRenderer>().material;
								Cam_PortalB.targetTexture = new RenderTexture(Screen.width, Screen.height, 24);
								Cam_PortalA.targetTexture = new RenderTexture(Screen.width, Screen.height, 24);
								Mat_PortalA.mainTexture = Cam_PortalA.targetTexture;
								Mat_PortalB.mainTexture = Cam_PortalB.targetTexture;
								if (ColliderMode == ColliderTypes.Auto)
								{
									if (!(GO_PortalA.GetComponent<BoxCollider>() != null))
									{
										UnityEngine.Debug.LogWarning("[SEAMLESS PORTALS] Colliders are set to 'auto' but the PortalA GameObject has no BoxCollider (other collider types are not compatible)", GO_PortalA);
										ERROR = true;
										return;
									}
									Box_A = GO_PortalA.GetComponent<BoxCollider>();
									if (!(GO_PortalB.GetComponent<BoxCollider>() != null))
									{
										UnityEngine.Debug.LogWarning("[SEAMLESS PORTALS] Colliders are set to 'auto' but the PortalB GameObject has no BoxCollider (other collider types are not compatible)", GO_PortalB);
										ERROR = true;
										return;
									}
									Box_B = GO_PortalA.GetComponent<BoxCollider>();
								}
								else if (ColliderMode == ColliderTypes.UserDefined)
								{
									if (Box_A == null)
									{
										UnityEngine.Debug.LogWarning("[SEAMLESS PORTALS] Colliders are set to 'user defined' but no BoxCollider has been defined for PortalA (other collider types are not compatible)", this);
										ERROR = true;
										return;
									}
									if (Box_B == null)
									{
										UnityEngine.Debug.LogWarning("[SEAMLESS PORTALS] Colliders are set to 'user defined' but no BoxCollider has been defined for PortalB (other collider types are not compatible)", this);
										ERROR = true;
										return;
									}
								}
								GameObject gameObject3 = new GameObject("Col_PortalA");
								Col_PortalA = gameObject3.AddComponent<BoxCollider>();
								gameObject3.transform.SetPositionAndRotation(Box_A.transform.TransformPoint(Box_A.center), Box_A.transform.rotation);
								gameObject3.transform.parent = GO_PortalA.transform;
								SetGlobalScale(gameObject3.transform, Vector3.Scale(Box_A.size, Box_A.transform.lossyScale));
								Col_PortalA.isTrigger = true;
								Box_A.enabled = false;
								GameObject gameObject4 = new GameObject("Col_PortalB");
								Col_PortalB = gameObject4.AddComponent<BoxCollider>();
								gameObject4.transform.SetPositionAndRotation(GO_PortalB.transform.TransformPoint(Box_B.center), GO_PortalB.transform.rotation);
								Col_PortalB.transform.parent = GO_PortalB.transform;
								SetGlobalScale(gameObject4.transform, Vector3.Scale(Box_B.size, Box_B.transform.lossyScale));
								Col_PortalB.isTrigger = true;
								Box_B.enabled = false;
								if (Cam_Player != null)
								{
									Cam_PortalB.fieldOfView = Cam_Player.fieldOfView;
									Cam_PortalA.fieldOfView = Cam_Player.fieldOfView;
									Cam_PortalA.depth = Cam_Player.depth - 1f;
									Cam_PortalB.depth = Cam_Player.depth - 1f;
									Bounds bounds = default(Bounds);
									Bounds bounds2 = default(Bounds);
									if (GO_PortalA.GetComponent<MeshFilter>() != null)
									{
										bounds = GO_PortalA.GetComponent<MeshFilter>().mesh.bounds;
										if (GO_PortalB.GetComponent<MeshFilter>() != null)
										{
											bounds2 = GO_PortalB.GetComponent<MeshFilter>().mesh.bounds;
											switch (PortalForwardAxis)
											{
											case AxisList.x:
												ViewCube_PortalA[0] = Create5SideInvertedCube(GO_PortalA, GO_PortalA.transform.position, GO_PortalA.transform.right, GO_PortalA.transform.up, new Vector3(0.99f * bounds.size.z * GO_PortalA.transform.lossyScale.z, 0.99f * bounds.size.y * GO_PortalA.transform.lossyScale.y, ViewCubeDepth + bounds.size.x * GO_PortalA.transform.lossyScale.x), ViewCubeOffset, "ViewCube_PortalA0");
												ViewCube_PortalB[0] = Create5SideInvertedCube(GO_PortalB, GO_PortalB.transform.position, GO_PortalB.transform.right, GO_PortalB.transform.up, new Vector3(0.99f * bounds2.size.z * GO_PortalB.transform.lossyScale.z, 0.99f * bounds2.size.y * GO_PortalB.transform.lossyScale.y, ViewCubeDepth + bounds2.size.x * GO_PortalB.transform.lossyScale.x), ViewCubeOffset, "ViewCube_PortalB0");
												ViewCube_PortalA[1] = Create5SideInvertedCube(GO_PortalA, GO_PortalA.transform.position, -GO_PortalA.transform.right, GO_PortalA.transform.up, new Vector3(0.99f * bounds.size.z * GO_PortalA.transform.lossyScale.z, 0.99f * bounds.size.y * GO_PortalA.transform.lossyScale.y, ViewCubeDepth + bounds.size.x * GO_PortalA.transform.lossyScale.x), ViewCubeOffset, "ViewCube_PortalA1");
												ViewCube_PortalB[1] = Create5SideInvertedCube(GO_PortalB, GO_PortalB.transform.position, -GO_PortalB.transform.right, GO_PortalB.transform.up, new Vector3(0.99f * bounds2.size.z * GO_PortalB.transform.lossyScale.z, 0.99f * bounds2.size.y * GO_PortalB.transform.lossyScale.y, ViewCubeDepth + bounds2.size.x * GO_PortalB.transform.lossyScale.x), ViewCubeOffset, "ViewCube_PortalB1");
												break;
											case AxisList.y:
												ViewCube_PortalA[0] = Create5SideInvertedCube(GO_PortalA, GO_PortalA.transform.position, GO_PortalA.transform.up, GO_PortalA.transform.right, new Vector3(0.99f * bounds.size.z * GO_PortalA.transform.lossyScale.z, 0.99f * bounds.size.x * GO_PortalA.transform.lossyScale.x, ViewCubeDepth + bounds.size.y * GO_PortalA.transform.lossyScale.y), ViewCubeOffset, "ViewCube_PortalA0");
												ViewCube_PortalB[0] = Create5SideInvertedCube(GO_PortalB, GO_PortalB.transform.position, GO_PortalB.transform.up, GO_PortalB.transform.right, new Vector3(0.99f * bounds2.size.z * GO_PortalB.transform.lossyScale.z, 0.99f * bounds2.size.x * GO_PortalB.transform.lossyScale.x, ViewCubeDepth + bounds2.size.y * GO_PortalB.transform.lossyScale.y), ViewCubeOffset, "ViewCube_PortalB0");
												ViewCube_PortalA[1] = Create5SideInvertedCube(GO_PortalA, GO_PortalA.transform.position, -GO_PortalA.transform.up, GO_PortalA.transform.right, new Vector3(0.99f * bounds.size.z * GO_PortalA.transform.lossyScale.z, 0.99f * bounds.size.x * GO_PortalA.transform.lossyScale.x, ViewCubeDepth + bounds.size.y * GO_PortalA.transform.lossyScale.y), ViewCubeOffset, "ViewCube_PortalA1");
												ViewCube_PortalB[1] = Create5SideInvertedCube(GO_PortalB, GO_PortalB.transform.position, -GO_PortalB.transform.up, GO_PortalB.transform.right, new Vector3(0.99f * bounds2.size.z * GO_PortalB.transform.lossyScale.z, 0.99f * bounds2.size.x * GO_PortalB.transform.lossyScale.x, ViewCubeDepth + bounds2.size.y * GO_PortalB.transform.lossyScale.y), ViewCubeOffset, "ViewCube_PortalB1");
												break;
											case AxisList.z:
												ViewCube_PortalA[0] = Create5SideInvertedCube(GO_PortalA, GO_PortalA.transform.position, GO_PortalA.transform.forward, GO_PortalA.transform.up, new Vector3(0.99f * bounds.size.x * GO_PortalA.transform.lossyScale.x, 0.99f * bounds.size.y * GO_PortalA.transform.lossyScale.y, ViewCubeDepth + bounds.size.z * GO_PortalA.transform.lossyScale.z), ViewCubeOffset, "ViewCube_PortalA0");
												ViewCube_PortalB[0] = Create5SideInvertedCube(GO_PortalB, GO_PortalB.transform.position, GO_PortalB.transform.forward, GO_PortalB.transform.up, new Vector3(0.99f * bounds2.size.x * GO_PortalB.transform.lossyScale.x, 0.99f * bounds2.size.y * GO_PortalB.transform.lossyScale.y, ViewCubeDepth + bounds2.size.z * GO_PortalB.transform.lossyScale.z), ViewCubeOffset, "ViewCube_PortalB0");
												ViewCube_PortalA[1] = Create5SideInvertedCube(GO_PortalA, GO_PortalA.transform.position, -GO_PortalA.transform.forward, GO_PortalA.transform.up, new Vector3(0.99f * bounds.size.x * GO_PortalA.transform.lossyScale.x, 0.99f * bounds.size.y * GO_PortalA.transform.lossyScale.y, ViewCubeDepth + bounds.size.z * GO_PortalA.transform.lossyScale.z), ViewCubeOffset, "ViewCube_PortalA1");
												ViewCube_PortalB[1] = Create5SideInvertedCube(GO_PortalB, GO_PortalB.transform.position, -GO_PortalB.transform.forward, GO_PortalB.transform.up, new Vector3(0.99f * bounds2.size.x * GO_PortalB.transform.lossyScale.x, 0.99f * bounds2.size.y * GO_PortalB.transform.lossyScale.y, ViewCubeDepth + bounds2.size.z * GO_PortalB.transform.lossyScale.z), ViewCubeOffset, "ViewCube_PortalB1");
												break;
											}
											ViewCubeCollider_PortalA[0] = ViewCube_PortalA[0].GetComponent<BoxCollider>();
											ViewCubeCollider_PortalB[0] = ViewCube_PortalB[0].GetComponent<BoxCollider>();
											ViewCubeCollider_PortalA[1] = ViewCube_PortalA[1].GetComponent<BoxCollider>();
											ViewCubeCollider_PortalB[1] = ViewCube_PortalB[1].GetComponent<BoxCollider>();
											ViewCubeMR_PortalA[0] = ViewCube_PortalA[0].GetComponent<MeshRenderer>();
											ViewCubeMR_PortalB[0] = ViewCube_PortalB[0].GetComponent<MeshRenderer>();
											ViewCubeMR_PortalA[1] = ViewCube_PortalA[1].GetComponent<MeshRenderer>();
											ViewCubeMR_PortalB[1] = ViewCube_PortalB[1].GetComponent<MeshRenderer>();
											if (GO_PortalA.GetComponent<MeshRenderer>() != null)
											{
												MR_PortalA = GO_PortalA.GetComponent<MeshRenderer>();
												if (GO_PortalB.GetComponent<MeshRenderer>() != null)
												{
													MR_PortalB = GO_PortalB.GetComponent<MeshRenderer>();
													return;
												}
												UnityEngine.Debug.LogWarning("[SEAMLESS PORTALS] The PortalB GameObject has no MeshRenderer component", GO_PortalB);
												ERROR = true;
											}
											else
											{
												UnityEngine.Debug.LogWarning("[SEAMLESS PORTALS] The PortalA GameObject has no MeshRenderer component", GO_PortalA);
												ERROR = true;
											}
										}
										else
										{
											UnityEngine.Debug.LogWarning("[SEAMLESS PORTALS] The PortalB GameObject has no MeshFilter component", GO_PortalB);
											ERROR = true;
										}
									}
									else
									{
										UnityEngine.Debug.LogWarning("[SEAMLESS PORTALS] The PortalA GameObject has no MeshFilter component", GO_PortalA);
										ERROR = true;
									}
								}
								else
								{
									UnityEngine.Debug.LogWarning("[SEAMLESS PORTALS] Player camera not set", this);
									ERROR = true;
								}
							}
							else
							{
								UnityEngine.Debug.LogWarning("[SEAMLESS PORTALS] PortalB GameObject has no mesh renderer", GO_PortalB);
								ERROR = true;
							}
						}
						else
						{
							UnityEngine.Debug.LogWarning("[SEAMLESS PORTALS] PortalA GameObject has no mesh renderer", GO_PortalA);
							ERROR = true;
						}
					}
					else
					{
						UnityEngine.Debug.LogWarning("[SEAMLESS PORTALS] No 'PortalB' layer exists, please add it");
						ERROR = true;
					}
				}
				else
				{
					UnityEngine.Debug.LogWarning("[SEAMLESS PORTALS] No 'PortalA' layer exists, please add it");
					ERROR = true;
				}
			}
			else
			{
				UnityEngine.Debug.LogWarning("[SEAMLESS PORTALS] PortalB GameObject not set", this);
				ERROR = true;
			}
		}
		else
		{
			UnityEngine.Debug.LogWarning("[SEAMLESS PORTALS] PortalA GameObject not set", this);
			ERROR = true;
		}
	}

	public static void SetGlobalScale(Transform transform, Vector3 globalScale)
	{
		transform.localScale = Vector3.one;
		transform.localScale = new Vector3(globalScale.x / transform.lossyScale.x, globalScale.y / transform.lossyScale.y, globalScale.z / transform.lossyScale.z);
	}

	private void LateUpdate()
	{
		if (ERROR)
		{
			return;
		}
		Col_PortalA.isTrigger = !HardColliders;
		Col_PortalB.isTrigger = !HardColliders;
		CubeActive_PortalA[0] = ColliderContainsPoint(ViewCube_PortalA[0].transform, Cam_Player.transform.position, ViewCubeCollider_PortalA[0].enabled);
		CubeActive_PortalB[0] = ColliderContainsPoint(ViewCube_PortalB[0].transform, Cam_Player.transform.position, ViewCubeCollider_PortalB[0].enabled);
		CubeActive_PortalA[1] = ColliderContainsPoint(ViewCube_PortalA[1].transform, Cam_Player.transform.position, ViewCubeCollider_PortalA[1].enabled);
		CubeActive_PortalB[1] = ColliderContainsPoint(ViewCube_PortalB[1].transform, Cam_Player.transform.position, ViewCubeCollider_PortalB[1].enabled);
		if (inPortalA)
		{
			CubeActive_PortalA[0] = false;
			CubeActive_PortalA[1] = false;
		}
		if (inPortalB)
		{
			CubeActive_PortalB[0] = false;
			CubeActive_PortalB[1] = false;
		}
		ViewCubeMR_PortalA[0].enabled = CubeActive_PortalA[0];
		ViewCubeMR_PortalB[0].enabled = CubeActive_PortalB[0];
		ViewCubeMR_PortalA[1].enabled = CubeActive_PortalA[1];
		ViewCubeMR_PortalB[1].enabled = CubeActive_PortalB[1];
		if (CubeActive_PortalA[0] || CubeActive_PortalA[1])
		{
			MR_PortalA.enabled = false;
		}
		else
		{
			MR_PortalA.enabled = true;
		}
		if (CubeActive_PortalB[0] || CubeActive_PortalB[1])
		{
			MR_PortalB.enabled = false;
		}
		else
		{
			MR_PortalB.enabled = true;
		}
		Vector3 vector = GO_PortalA.transform.position - Cam_Player.transform.position;
		Vector3 vector2 = GO_PortalB.transform.position - Cam_Player.transform.position;
		GameObject gameObject = ((!(vector.sqrMagnitude < vector2.sqrMagnitude)) ? GO_PortalB : GO_PortalA);
		if ((!CubeActive_PortalA[0] && !CubeActive_PortalA[1] && !CubeActive_PortalB[0] && !CubeActive_PortalB[1]) || inPortalA)
		{
			Vector3 cL = gameObject.transform.InverseTransformPoint(Cam_Player.transform.position);
			int activeViewCubeIndex = GetActiveViewCubeIndex(cL);
			ViewCubeCollider_PortalA[activeViewCubeIndex].enabled = false;
			ViewCubeCollider_PortalA[1 - activeViewCubeIndex].enabled = true;
			if (!inPortalA)
			{
				Vector3 position = GO_PortalA.transform.InverseTransformPoint(Col_PortalA.transform.position);
				switch (PortalForwardAxis)
				{
				case AxisList.x:
					position.x = Mathf.Abs(position.x) * Mathf.Sign(0f - cL.x);
					break;
				case AxisList.y:
					position.y = Mathf.Abs(position.y) * Mathf.Sign(0f - cL.y);
					break;
				case AxisList.z:
					position.z = Mathf.Abs(position.z) * Mathf.Sign(0f - cL.z);
					break;
				}
				Col_PortalA.transform.position = GO_PortalA.transform.TransformPoint(position);
			}
		}
		if ((!CubeActive_PortalA[0] && !CubeActive_PortalA[1] && !CubeActive_PortalB[0] && !CubeActive_PortalB[1]) || inPortalB)
		{
			Vector3 cL2 = gameObject.transform.InverseTransformPoint(Cam_Player.transform.position);
			int activeViewCubeIndex2 = GetActiveViewCubeIndex(cL2);
			ViewCubeCollider_PortalB[activeViewCubeIndex2].enabled = false;
			ViewCubeCollider_PortalB[1 - activeViewCubeIndex2].enabled = true;
			if (!inPortalB)
			{
				Vector3 position2 = GO_PortalB.transform.InverseTransformPoint(Col_PortalB.transform.position);
				switch (PortalForwardAxis)
				{
				case AxisList.x:
					position2.x = Mathf.Abs(position2.x) * Mathf.Sign(0f - cL2.x);
					break;
				case AxisList.y:
					position2.y = Mathf.Abs(position2.y) * Mathf.Sign(0f - cL2.y);
					break;
				case AxisList.z:
					position2.z = Mathf.Abs(position2.z) * Mathf.Sign(0f - cL2.z);
					break;
				}
				Col_PortalB.transform.position = GO_PortalB.transform.TransformPoint(position2);
			}
		}
		if (UpdateFOV)
		{
			Cam_PortalB.fieldOfView = Cam_Player.fieldOfView;
			Cam_PortalA.fieldOfView = Cam_Player.fieldOfView;
		}
		switch (TeleportObject)
		{
		case ObjectType.PlayerCamera:
			tpObject = Cam_Player.transform.gameObject;
			break;
		case ObjectType.CameraParent:
			tpObject = Cam_Player.transform.parent.gameObject;
			break;
		case ObjectType.TargetTransform:
			tpObject = PortalObject;
			break;
		}
		if (!tpoTeleported)
		{
			PortalObject.transform.SetPositionAndRotation(Cam_Player.transform.position, Cam_Player.transform.rotation);
		}
		if (ColliderContainsPoint(Col_PortalA.transform, Cam_Player.transform.position, Enabled: true) && !inPortalA && AllowTeleport)
		{
			ViewCubeMR_PortalA[0].enabled = false;
			ViewCubeMR_PortalA[1].enabled = false;
			Vector4 clipPlane = CameraSpacePlane(Cam_PortalA, GO_PortalB.transform.position, -PortalNormal(GO_PortalB, Cam_PortalA, PortalForwardAxis), ClippingPlaneOffset);
			Cam_PortalA.projectionMatrix = Cam_Player.CalculateObliqueMatrix(clipPlane);
			Vector4 clipPlane2 = CameraSpacePlane(Cam_PortalB, GO_PortalA.transform.position, -PortalNormal(GO_PortalA, Cam_PortalB, PortalForwardAxis), ClippingPlaneOffset);
			Cam_PortalB.projectionMatrix = Cam_Player.CalculateObliqueMatrix(clipPlane2);
			tpObject.transform.rotation = GO_PortalB.transform.rotation * Quaternion.Inverse(GO_PortalA.transform.rotation) * Cam_Player.transform.rotation;
			Vector3 a = GO_PortalA.transform.InverseTransformPoint(Cam_Player.transform.position);
			a = Vector3.Scale(a, DivideVectors(GO_PortalA.transform.lossyScale, GO_PortalB.transform.lossyScale));
			tpObject.transform.position = GO_PortalB.transform.TransformPoint(a);
			inPortalB = true;
			if (TeleportObject == ObjectType.TargetTransform)
			{
				tpoTeleported = true;
				foreach (GameObject camCorrectGameObject in CamCorrectGameObjects)
				{
					camCorrectGameObject.SendMessage(CamCorrectFunctionName, tpObject.transform);
				}
				tpoTeleported = false;
			}
		}
		else if (!ColliderContainsPoint(Col_PortalA.transform, Cam_Player.transform.position, Enabled: true) && inPortalA && AllowTeleport)
		{
			inPortalA = false;
			Vector3 vector3 = gameObject.transform.InverseTransformPoint(Cam_Player.transform.position);
			Vector3 position3 = GO_PortalA.transform.InverseTransformPoint(Col_PortalA.transform.position);
			switch (PortalForwardAxis)
			{
			case AxisList.x:
				position3.x = Mathf.Abs(position3.x) * Mathf.Sign(0f - vector3.x);
				break;
			case AxisList.y:
				position3.y = Mathf.Abs(position3.y) * Mathf.Sign(0f - vector3.y);
				break;
			case AxisList.z:
				position3.z = Mathf.Abs(position3.z) * Mathf.Sign(0f - vector3.z);
				break;
			}
			Col_PortalA.transform.position = GO_PortalA.transform.TransformPoint(position3);
		}
		else if (ColliderContainsPoint(Col_PortalB.transform, Cam_Player.transform.position, Enabled: true) && !inPortalB && AllowTeleport)
		{
			ViewCubeMR_PortalB[0].enabled = false;
			ViewCubeMR_PortalB[1].enabled = false;
			Vector4 clipPlane3 = CameraSpacePlane(Cam_PortalA, GO_PortalB.transform.position, -PortalNormal(GO_PortalB, Cam_PortalA, PortalForwardAxis), ClippingPlaneOffset);
			Cam_PortalA.projectionMatrix = Cam_Player.CalculateObliqueMatrix(clipPlane3);
			Vector4 clipPlane4 = CameraSpacePlane(Cam_PortalB, GO_PortalA.transform.position, -PortalNormal(GO_PortalA, Cam_PortalB, PortalForwardAxis), ClippingPlaneOffset);
			Cam_PortalB.projectionMatrix = Cam_Player.CalculateObliqueMatrix(clipPlane4);
			tpObject.transform.rotation = GO_PortalA.transform.rotation * Quaternion.Inverse(GO_PortalB.transform.rotation) * Cam_Player.transform.rotation;
			Vector3 a2 = GO_PortalB.transform.InverseTransformPoint(Cam_Player.transform.position);
			a2 = Vector3.Scale(a2, DivideVectors(GO_PortalB.transform.lossyScale, GO_PortalA.transform.lossyScale));
			tpObject.transform.position = GO_PortalA.transform.TransformPoint(a2);
			inPortalA = true;
			if (TeleportObject == ObjectType.TargetTransform)
			{
				tpoTeleported = true;
				foreach (GameObject camCorrectGameObject2 in CamCorrectGameObjects)
				{
					camCorrectGameObject2.SendMessage(CamCorrectFunctionName, tpObject.transform);
				}
				tpoTeleported = false;
			}
		}
		else if (!ColliderContainsPoint(Col_PortalB.transform, Cam_Player.transform.position, Enabled: true) && inPortalB && AllowTeleport)
		{
			inPortalB = false;
			if (!inPortalB)
			{
				Vector3 vector4 = gameObject.transform.InverseTransformPoint(Cam_Player.transform.position);
				Vector3 position4 = GO_PortalB.transform.InverseTransformPoint(Col_PortalB.transform.position);
				switch (PortalForwardAxis)
				{
				case AxisList.x:
					position4.x = Mathf.Abs(position4.x) * Mathf.Sign(0f - vector4.x);
					break;
				case AxisList.y:
					position4.y = Mathf.Abs(position4.y) * Mathf.Sign(0f - vector4.y);
					break;
				case AxisList.z:
					position4.z = Mathf.Abs(position4.z) * Mathf.Sign(0f - vector4.z);
					break;
				}
				Col_PortalB.transform.position = GO_PortalB.transform.TransformPoint(position4);
			}
		}
		Vector3 a3 = GO_PortalB.transform.InverseTransformPoint(Cam_Player.transform.position);
		Quaternion quaternion = Quaternion.Inverse(GO_PortalB.transform.rotation) * Cam_Player.transform.rotation;
		a3 = Vector3.Scale(a3, DivideVectors(GO_PortalB.transform.lossyScale, GO_PortalA.transform.lossyScale));
		Cam_PortalB.transform.SetPositionAndRotation(GO_PortalA.transform.TransformPoint(a3), GO_PortalA.transform.rotation * quaternion);
		a3 = GO_PortalA.transform.InverseTransformPoint(Cam_Player.transform.position);
		quaternion = Quaternion.Inverse(GO_PortalA.transform.rotation) * Cam_Player.transform.rotation;
		a3 = Vector3.Scale(a3, DivideVectors(GO_PortalA.transform.lossyScale, GO_PortalB.transform.lossyScale));
		Cam_PortalA.transform.SetPositionAndRotation(GO_PortalB.transform.TransformPoint(a3), GO_PortalB.transform.rotation * quaternion);
		if (!CubeActive_PortalA[0] && !CubeActive_PortalA[1] && !inPortalA && !inPortalB)
		{
			Vector4 clipPlane5 = CameraSpacePlane(Cam_PortalA, GO_PortalB.transform.position, PortalNormal(GO_PortalB, Cam_PortalA, PortalForwardAxis), ClippingPlaneOffset);
			Cam_PortalA.projectionMatrix = Cam_Player.CalculateObliqueMatrix(clipPlane5);
		}
		else
		{
			Cam_PortalA.ResetProjectionMatrix();
		}
		if (!CubeActive_PortalB[0] && !CubeActive_PortalB[1] && !inPortalA && !inPortalB)
		{
			Vector4 clipPlane6 = CameraSpacePlane(Cam_PortalB, GO_PortalA.transform.position, PortalNormal(GO_PortalA, Cam_PortalB, PortalForwardAxis), ClippingPlaneOffset);
			Cam_PortalB.projectionMatrix = Cam_Player.CalculateObliqueMatrix(clipPlane6);
		}
		else
		{
			Cam_PortalB.ResetProjectionMatrix();
		}
	}

	private Vector3 DivideVectors(Vector3 Numerator, Vector3 Denominator)
	{
		Vector3 result = default(Vector3);
		if (Denominator.x != 0f)
		{
			result.x = Numerator.x / Denominator.x;
		}
		else
		{
			result.x = 0f;
		}
		if (Denominator.y != 0f)
		{
			result.y = Numerator.y / Denominator.y;
		}
		else
		{
			result.y = 0f;
		}
		if (Denominator.z != 0f)
		{
			result.z = Numerator.z / Denominator.z;
		}
		else
		{
			result.z = 0f;
		}
		return result;
	}

	private bool ColliderContainsPoint(Transform ColliderTransform, Vector3 Point, bool Enabled)
	{
		Vector3 vector = ColliderTransform.InverseTransformPoint(Point);
		if (Enabled && Mathf.Abs(vector.x) < 0.5f && Mathf.Abs(vector.y) < 0.5f && Mathf.Abs(vector.z) < 0.5f)
		{
			return true;
		}
		return false;
	}

	private Vector3 PortalNormal(GameObject portal, Camera camera, AxisList forwardAxis)
	{
		switch (forwardAxis)
		{
		case AxisList.x:
			if (Vector3.Angle(portal.transform.right, camera.transform.position - portal.transform.position) <= 90f)
			{
				return -portal.transform.right;
			}
			return portal.transform.right;
		case AxisList.y:
			if (Vector3.Angle(portal.transform.up, camera.transform.position - portal.transform.position) <= 90f)
			{
				return -portal.transform.up;
			}
			return portal.transform.up;
		case AxisList.z:
			if (Vector3.Angle(portal.transform.forward, camera.transform.position - portal.transform.position) <= 90f)
			{
				return -portal.transform.forward;
			}
			return portal.transform.forward;
		default:
			return Vector3.zero;
		}
	}

	private Vector4 CameraSpacePlane(Camera cam, Vector3 pos, Vector3 normal, float offset)
	{
		Vector3 point = pos - normal * offset;
		Matrix4x4 worldToCameraMatrix = cam.worldToCameraMatrix;
		Vector3 lhs = worldToCameraMatrix.MultiplyPoint(point);
		Vector3 normalized = worldToCameraMatrix.MultiplyVector(normal).normalized;
		return new Vector4(normalized.x, normalized.y, normalized.z, 0f - Vector3.Dot(lhs, normalized));
	}

	private GameObject Create5SideInvertedCube(GameObject portal, Vector3 pos, Vector3 direction, Vector3 upVector, Vector3 scale, float offset, string name)
	{
		GameObject gameObject = GameObject.CreatePrimitive(PrimitiveType.Cube);
		gameObject.name = name;
		gameObject.GetComponent<BoxCollider>().isTrigger = true;
		Mesh mesh = gameObject.GetComponent<MeshFilter>().mesh;
		Vector3[] vertices = new Vector3[24]
		{
			new Vector3(-0.5f, 0.5f, -0.5f),
			new Vector3(-0.5f, -0.5f, -0.5f),
			new Vector3(0.5f, -0.5f, -0.5f),
			new Vector3(0.5f, 0.5f, -0.5f),
			new Vector3(-0.5f, 0.5f, 0.5f),
			new Vector3(0.5f, 0.5f, 0.5f),
			new Vector3(0.5f, -0.5f, 0.5f),
			new Vector3(-0.5f, -0.5f, 0.5f),
			new Vector3(-0.5f, 0.5f, -0.5f),
			new Vector3(-0.5f, -0.5f, -0.5f),
			new Vector3(-0.5f, -0.5f, 0.5f),
			new Vector3(-0.5f, 0.5f, 0.5f),
			new Vector3(-0.5f, -0.5f, -0.5f),
			new Vector3(-0.5f, -0.5f, 0.5f),
			new Vector3(0.5f, -0.5f, 0.5f),
			new Vector3(0.5f, -0.5f, -0.5f),
			new Vector3(0.5f, -0.5f, -0.5f),
			new Vector3(0.5f, -0.5f, 0.5f),
			new Vector3(0.5f, 0.5f, 0.5f),
			new Vector3(0.5f, 0.5f, -0.5f),
			new Vector3(-0.5f, 0.5f, 0.5f),
			new Vector3(-0.5f, 0.5f, -0.5f),
			new Vector3(0.5f, 0.5f, -0.5f),
			new Vector3(0.5f, 0.5f, 0.5f)
		};
		int[] triangles = new int[36]
		{
			0, 1, 2, 0, 2, 3, 4, 5, 6, 4,
			6, 7, 8, 9, 10, 8, 10, 11, 12, 13,
			14, 12, 14, 15, 16, 17, 18, 16, 18, 19,
			20, 21, 22, 20, 22, 23
		};
		mesh.vertices = vertices;
		mesh.triangles = triangles;
		Vector3 vector = Vector3.zero;
		switch (PortalForwardAxis)
		{
		case AxisList.x:
			vector = portal.GetComponent<MeshFilter>().mesh.bounds.extents.x * portal.transform.lossyScale.x * direction;
			break;
		case AxisList.y:
			vector = portal.GetComponent<MeshFilter>().mesh.bounds.extents.y * portal.transform.lossyScale.y * direction;
			break;
		case AxisList.z:
			vector = portal.GetComponent<MeshFilter>().mesh.bounds.extents.z * portal.transform.lossyScale.z * direction;
			break;
		}
		gameObject.transform.SetPositionAndRotation(pos - direction * scale.z / 2f + vector + offset * direction, Quaternion.LookRotation(direction, upVector));
		gameObject.transform.RotateAround(gameObject.transform.position, gameObject.transform.up, 90f);
		gameObject.transform.localScale = new Vector3(scale.z, scale.y, scale.x);
		gameObject.transform.parent = portal.transform;
		Material material = new Material(portal.GetComponent<MeshRenderer>().material);
		material.SetTexture("_MaskTex", null);
		material.SetTexture("_BGTex", null);
		gameObject.GetComponent<MeshRenderer>().material = material;
		return gameObject;
	}

	private Vector3 NewColliderPosition(Vector3 c, Vector3 centre, Vector3 cL)
	{
		switch (PortalForwardAxis)
		{
		case AxisList.x:
			c.x = Mathf.Abs(centre.x) * Mathf.Sign(0f - cL.x);
			break;
		case AxisList.y:
			c.y = Mathf.Abs(centre.y) * Mathf.Sign(0f - cL.y);
			break;
		case AxisList.z:
			c.z = Mathf.Abs(centre.z) * Mathf.Sign(0f - cL.z);
			break;
		}
		return c;
	}

	private int GetActiveViewCubeIndex(Vector3 cL)
	{
		return PortalForwardAxis switch
		{
			AxisList.x => (int)(1f + Mathf.Sign(cL.x)) / 2, 
			AxisList.y => (int)(1f + Mathf.Sign(cL.y)) / 2, 
			AxisList.z => (int)(1f + Mathf.Sign(cL.z)) / 2, 
			_ => 0, 
		};
	}

	public void OnDrawGizmos()
	{
		if (DrawAxisTest)
		{
			if (PortalForwardAxis == AxisList.x)
			{
				UnityEngine.Color color = Gizmos.color;
				Gizmos.color = UnityEngine.Color.red;
				Gizmos.DrawRay(GO_PortalA.transform.position, GO_PortalA.transform.right * 3f);
				Gizmos.DrawRay(GO_PortalA.transform.position, -GO_PortalA.transform.right * 3f);
				Gizmos.DrawRay(GO_PortalB.transform.position, GO_PortalB.transform.right * 3f);
				Gizmos.DrawRay(GO_PortalB.transform.position, -GO_PortalB.transform.right * 3f);
				Gizmos.color = color;
			}
			if (PortalForwardAxis == AxisList.y)
			{
				UnityEngine.Color color2 = Gizmos.color;
				Gizmos.color = UnityEngine.Color.green;
				Gizmos.DrawRay(GO_PortalA.transform.position, GO_PortalA.transform.up * 3f);
				Gizmos.DrawRay(GO_PortalA.transform.position, -GO_PortalA.transform.up * 3f);
				Gizmos.DrawRay(GO_PortalB.transform.position, GO_PortalB.transform.up * 3f);
				Gizmos.DrawRay(GO_PortalB.transform.position, -GO_PortalB.transform.up * 3f);
				Gizmos.color = color2;
			}
			if (PortalForwardAxis == AxisList.z)
			{
				UnityEngine.Color color3 = Gizmos.color;
				Gizmos.color = UnityEngine.Color.blue;
				Gizmos.DrawRay(GO_PortalA.transform.position, GO_PortalA.transform.forward * 3f);
				Gizmos.DrawRay(GO_PortalA.transform.position, -GO_PortalA.transform.forward * 3f);
				Gizmos.DrawRay(GO_PortalB.transform.position, GO_PortalB.transform.forward * 3f);
				Gizmos.DrawRay(GO_PortalB.transform.position, -GO_PortalB.transform.forward * 3f);
				Gizmos.color = color3;
			}
		}
	}
}
public class ChatController : MonoBehaviour
{
	public TMP_InputField TMP_ChatInput;

	public TMP_Text TMP_ChatOutput;

	public Scrollbar ChatScrollbar;

	private void OnEnable()
	{
		TMP_ChatInput.onSubmit.AddListener(AddToChatOutput);
	}

	private void OnDisable()
	{
		TMP_ChatInput.onSubmit.RemoveListener(AddToChatOutput);
	}

	private void AddToChatOutput(string newText)
	{
		TMP_ChatInput.text = string.Empty;
		DateTime now = DateTime.Now;
		TMP_Text tMP_ChatOutput = TMP_ChatOutput;
		tMP_ChatOutput.text = tMP_ChatOutput.text + "[<#FFFF80>" + now.Hour.ToString("d2") + ":" + now.Minute.ToString("d2") + ":" + now.Second.ToString("d2") + "</color>] " + newText + "\n";
		TMP_ChatInput.ActivateInputField();
		ChatScrollbar.value = 0f;
	}
}
public class EnvMapAnimator : MonoBehaviour
{
	public Vector3 RotationSpeeds;

	private TMP_Text m_textMeshPro;

	private Material m_material;

	private void Awake()
	{
		m_textMeshPro = GetComponent<TMP_Text>();
		m_material = m_textMeshPro.fontSharedMaterial;
	}

	private IEnumerator Start()
	{
		Matrix4x4 matrix = default(Matrix4x4);
		while (true)
		{
			matrix.SetTRS(Vector3.zero, Quaternion.Euler(Time.time * RotationSpeeds.x, Time.time * RotationSpeeds.y, Time.time * RotationSpeeds.z), Vector3.one);
			m_material.SetMatrix("_EnvMatrix", matrix);
			yield return null;
		}
	}
}
public class DieTimer : MonoBehaviour
{
	public float SecondsToDie = 10f;

	private float m_fTimer;

	private void Start()
	{
		m_fTimer = 0f;
	}

	private void Update()
	{
		m_fTimer += Time.deltaTime;
		if (m_fTimer > SecondsToDie)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}
}
public class FPSObjectShooter : MonoBehaviour
{
	public GameObject Element;

	public float InitialSpeed = 1f;

	public float MouseSpeed = 0.3f;

	public float Scale = 1f;

	public float Mass = 1f;

	public float Life = 10f;

	private Vector3 m_v3MousePosition;

	private void Start()
	{
		m_v3MousePosition = Input.mousePosition;
	}

	private void Update()
	{
		if (Element != null && Input.GetKeyDown(KeyCode.Space))
		{
			GameObject obj = UnityEngine.Object.Instantiate(Element);
			obj.transform.position = base.transform.position;
			obj.transform.localScale = new Vector3(Scale, Scale, Scale);
			obj.GetComponent<Rigidbody>().mass = Mass;
			obj.GetComponent<Rigidbody>().solverIterations = 255;
			obj.GetComponent<Rigidbody>().AddForce(base.transform.forward * InitialSpeed, ForceMode.VelocityChange);
			obj.AddComponent<DieTimer>().SecondsToDie = Life;
		}
		if (Input.GetMouseButton(0) && !Input.GetMouseButtonDown(0))
		{
			base.transform.Rotate((0f - (Input.mousePosition.y - m_v3MousePosition.y)) * MouseSpeed, 0f, 0f);
			base.transform.RotateAround(base.transform.position, Vector3.up, (Input.mousePosition.x - m_v3MousePosition.x) * MouseSpeed);
		}
		m_v3MousePosition = Input.mousePosition;
	}
}
public class LogicBreakableRopes : MonoBehaviour
{
	public UltimateRope Rope1;

	public UltimateRope Rope2;

	private bool bBroken1;

	private bool bBroken2;

	private void Start()
	{
		bBroken1 = false;
		bBroken2 = false;
	}

	private void OnGUI()
	{
		LogicGlobal.GlobalGUI();
		GUILayout.Label("Breakable rope test (procedural rope and linkedobjects rope with breakable properties and notifications set)");
		GUILayout.Label("Move the mouse while holding down the left button to move the camera");
		GUILayout.Label("Use the spacebar to shoot balls and aim for the ropes to break them");
		UnityEngine.Color color = GUI.color;
		GUI.color = new UnityEngine.Color(255f, 0f, 0f);
		if (bBroken1)
		{
			GUILayout.Label("Rope 1 was broken");
		}
		if (bBroken2)
		{
			GUILayout.Label("Rope 2 was broken");
		}
		GUI.color = color;
	}

	private void OnRopeBreak(UltimateRope.RopeBreakEventInfo breakInfo)
	{
		if (breakInfo.rope == Rope1)
		{
			bBroken1 = true;
		}
		if (breakInfo.rope == Rope2)
		{
			bBroken2 = true;
		}
	}
}
public class LogicGlobal : MonoBehaviour
{
	private void Start()
	{
	}

	public static void GlobalGUI()
	{
		GUILayout.Label("Press 1-4 to select different sample scenes");
		GUILayout.Space(20f);
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Alpha1))
		{
			SceneManager.LoadScene(0);
		}
		if (Input.GetKeyDown(KeyCode.Alpha2))
		{
			SceneManager.LoadScene(1);
		}
		if (Input.GetKeyDown(KeyCode.Alpha3))
		{
			SceneManager.LoadScene(2);
		}
		if (Input.GetKeyDown(KeyCode.Alpha4))
		{
			SceneManager.LoadScene(3);
		}
	}
}
public class LogicLamp : MonoBehaviour
{
	private void OnGUI()
	{
		LogicGlobal.GlobalGUI();
		GUILayout.Label("Lamp rope physics test (procedural rope linked to a dynamic object)");
		GUILayout.Label("Move the mouse while holding down the left button to move the camera");
		GUILayout.Label("Use the spacebar to shoot balls and aim for the lamp to test the physics");
	}
}
public class LogicRopeWithCoil : MonoBehaviour
{
	public UltimateRope Rope;

	public float RopeExtensionSpeed;

	private float m_fRopeExtension;

	private void Start()
	{
		m_fRopeExtension = ((Rope != null) ? Rope.m_fCurrentExtension : 0f);
	}

	private void OnGUI()
	{
		LogicGlobal.GlobalGUI();
		GUILayout.Label("Rope test (Procedural rope with additional coil)");
		GUILayout.Label("Use the keys i and o to extend the rope");
	}

	private void Update()
	{
		if (Input.GetKey(KeyCode.O))
		{
			m_fRopeExtension += Time.deltaTime * RopeExtensionSpeed;
		}
		if (Input.GetKey(KeyCode.I))
		{
			m_fRopeExtension -= Time.deltaTime * RopeExtensionSpeed;
		}
		if (Rope != null)
		{
			m_fRopeExtension = Mathf.Clamp(m_fRopeExtension, 0f, Rope.ExtensibleLength);
			Rope.ExtendRope(UltimateRope.ERopeExtensionMode.LinearExtensionIncrement, m_fRopeExtension - Rope.m_fCurrentExtension);
		}
	}
}
public class LogicSimpleRopes : MonoBehaviour
{
	private void OnGUI()
	{
		LogicGlobal.GlobalGUI();
		GUILayout.Label("Simple persistent rope test (procedural rope and linkedobjects rope)");
		GUILayout.Label("Move the mouse while holding down the left button to move the camera");
		GUILayout.Label("Use the spacebar to shoot balls and aim for the ropes to test the physics");
	}
}
public class RopeMaxTensionHandler : MonoBehaviour
{
	[SerializeField]
	private float _lengthThreshold = 1.01f;

	[SerializeField]
	public string _maxTensionStartCallMethod = "";

	[SerializeField]
	public string _maxTensionEndCallMethod = "";

	[SerializeField]
	public string _maxTensionContinueCallMethod = "";

	[SerializeField]
	public GameObject _eventCallGameObject;

	[SerializeField]
	public bool _fixHaywire;

	[SerializeField]
	public bool _makeEndDynamicOnMaxTension;

	private UltimateRope _rope;

	private bool _started;

	private bool _dynamicEnd;

	private void Start()
	{
		_rope = GetComponent<UltimateRope>();
		_started = false;
		_dynamicEnd = false;
	}

	private void LateUpdate()
	{
		if (_rope != null && _rope.RopeStart != null && _rope.RopeNodes != null && _rope.RopeNodes.Count > 0 && _rope.RopeNodes[0].goNode != null && Vector3.Distance(_rope.RopeStart.transform.position, _rope.RopeNodes[0].goNode.transform.position) > _rope.RopeNodes[0].fLength * _lengthThreshold)
		{
			if (!_started)
			{
				_started = true;
				if (_eventCallGameObject != null && !string.IsNullOrEmpty(_maxTensionStartCallMethod))
				{
					_eventCallGameObject.SendMessage(_maxTensionStartCallMethod);
				}
			}
			else if (_eventCallGameObject != null && !string.IsNullOrEmpty(_maxTensionContinueCallMethod))
			{
				_eventCallGameObject.SendMessage(_maxTensionContinueCallMethod);
			}
			if (!_dynamicEnd && _makeEndDynamicOnMaxTension)
			{
				Rigidbody component = _rope.RopeNodes[0].goNode.GetComponent<Rigidbody>();
				if (component.isKinematic)
				{
					component.isKinematic = false;
					_dynamicEnd = true;
				}
				Vector3 normalized = (_rope.RopeNodes[0].goNode.transform.position - _rope.RopeStart.transform.position).normalized;
				component.transform.position = _rope.RopeStart.transform.position + normalized * _rope.RopeNodes[0].fLength;
			}
			if (_fixHaywire)
			{
				FixHaywire();
			}
		}
		if (_started)
		{
			_started = false;
			if (_eventCallGameObject != null && !string.IsNullOrEmpty(_maxTensionEndCallMethod))
			{
				_eventCallGameObject.SendMessage(_maxTensionEndCallMethod);
			}
		}
	}

	private void FixedUpdate()
	{
		if (_fixHaywire && _started)
		{
			FixHaywire();
		}
	}

	private void FixHaywire()
	{
		Vector3 position = _rope.RopeStart.transform.position;
		Vector3 position2 = _rope.RopeNodes[0].goNode.transform.position;
		Vector3 vector = _rope.RopeNodes[0].goNode.transform.position - _rope.RopeStart.transform.position;
		float magnitude = vector.magnitude;
		vector = vector.normalized;
		int num = _rope.RopeNodes[0].segmentLinks.Length;
		for (int i = 0; i < num; i++)
		{
			float num2 = (float)i / (float)num;
			if (i == num - 1)
			{
				float num3 = 1f / (float)num * _rope.RopeNodes[0].fLength / magnitude;
				num2 = 1f - num3;
			}
			_rope.RopeNodes[0].segmentLinks[i].transform.position = position + vector * num2 * magnitude;
			Quaternion rotation = Quaternion.LookRotation(position2 - position);
			_rope.RopeNodes[0].segmentLinks[i].transform.rotation = rotation;
		}
	}
}
public class RopePersistAttribute : Attribute
{
}
public static class RopePersistManager
{
	private class RopeData
	{
		public class TransformInfo
		{
			public GameObject goObject;

			public string strObjectName;

			public Transform tfParent;

			public Vector3 v3LocalPosition;

			public Quaternion qLocalOrientation;

			public Vector3 v3LocalScale;

			public bool bLinkMarkedKinematic;

			public bool bExtensibleKinematic;
		}

		public UltimateRope m_rope;

		public bool m_bDeleted;

		public Dictionary<string, object> m_hashFieldName2Value;

		public bool m_bSkin;

		public Vector3[] m_av3SkinVertices;

		public Vector2[] m_av2SkinMapping;

		public Vector4[] m_av4SkinTangents;

		public BoneWeight[] m_aSkinBoneWeights;

		public int[] m_anSkinTrianglesRope;

		public int[] m_anSkinTrianglesSections;

		public Matrix4x4[] m_amtxSkinBindPoses;

		public TransformInfo m_transformInfoRope;

		public TransformInfo[] m_aLinkTransformInfo;

		public TransformInfo m_transformInfoStart;

		public TransformInfo[] m_transformInfoSegments;

		public bool[][] m_aaJointsProcessed;

		public bool[][] m_aaJointsBroken;

		public RopeData(UltimateRope rope)
		{
			m_rope = rope;
			m_hashFieldName2Value = new Dictionary<string, object>();
			m_aLinkTransformInfo = new TransformInfo[rope.TotalLinks];
			m_transformInfoSegments = new TransformInfo[rope.RopeNodes.Count];
			m_bSkin = rope.GetComponent<SkinnedMeshRenderer>() != null;
			if (m_bSkin)
			{
				SkinnedMeshRenderer component = rope.GetComponent<SkinnedMeshRenderer>();
				Mesh sharedMesh = component.sharedMesh;
				int vertexCount = component.sharedMesh.vertexCount;
				int num = component.sharedMesh.GetTriangles(0).Length;
				int num2 = component.sharedMesh.GetTriangles(1).Length;
				m_av3SkinVertices = new Vector3[vertexCount];
				m_av2SkinMapping = new Vector2[vertexCount];
				m_av4SkinTangents = ((sharedMesh.tangents != null) ? new Vector4[sharedMesh.tangents.Length] : null);
				m_aSkinBoneWeights = new BoneWeight[vertexCount];
				m_anSkinTrianglesRope = new int[num];
				m_anSkinTrianglesSections = new int[num2];
				m_amtxSkinBindPoses = new Matrix4x4[component.sharedMesh.bindposes.Length];
				MakeSkinDeepCopy(sharedMesh.vertices, sharedMesh.uv, sharedMesh.tangents, sharedMesh.boneWeights, sharedMesh.GetTriangles(0), sharedMesh.GetTriangles(1), sharedMesh.bindposes, m_av3SkinVertices, m_av2SkinMapping, m_av4SkinTangents, m_aSkinBoneWeights, m_anSkinTrianglesRope, m_anSkinTrianglesSections, m_amtxSkinBindPoses);
			}
		}

		public static void MakeSkinDeepCopy(Vector3[] av3VerticesSource, Vector2[] av2MappingSource, Vector4[] av4TangentsSource, BoneWeight[] aBoneWeightsSource, int[] anTrianglesRopeSource, int[] anTrianglesSectionsSource, Matrix4x4[] aBindPosesSource, Vector3[] av3VerticesDestiny, Vector2[] av2MappingDestiny, Vector4[] av4TangentsDestiny, BoneWeight[] aBoneWeightsDestiny, int[] anTrianglesRopeDestiny, int[] anTrianglesSectionsDestiny, Matrix4x4[] aBindPosesDestiny)
		{
			int num = av3VerticesSource.Length;
			for (int i = 0; i < num; i++)
			{
				av3VerticesDestiny[i] = av3VerticesSource[i];
				av2MappingDestiny[i] = av2MappingSource[i];
				if (av4TangentsDestiny != null && av4TangentsSource != null && av4TangentsDestiny.Length == num && av4TangentsSource.Length == num)
				{
					av4TangentsDestiny[i] = av4TangentsSource[i];
				}
				aBoneWeightsDestiny[i] = aBoneWeightsSource[i];
			}
			for (int j = 0; j < anTrianglesRopeDestiny.Length; j++)
			{
				anTrianglesRopeDestiny[j] = anTrianglesRopeSource[j];
			}
			for (int k = 0; k < anTrianglesSectionsDestiny.Length; k++)
			{
				anTrianglesSectionsDestiny[k] = anTrianglesSectionsSource[k];
			}
			for (int l = 0; l < aBindPosesSource.Length; l++)
			{
				aBindPosesDestiny[l] = aBindPosesSource[l];
			}
		}
	}

	private static Dictionary<int, RopeData> s_hashInstanceID2RopeData;

	static RopePersistManager()
	{
		s_hashInstanceID2RopeData = new Dictionary<int, RopeData>();
	}

	private static RopeData.TransformInfo ComputeTransformInfo(UltimateRope rope, GameObject node, GameObject parent)
	{
		RopeData.TransformInfo transformInfo = new RopeData.TransformInfo();
		transformInfo.goObject = node;
		transformInfo.strObjectName = node.name;
		transformInfo.tfParent = ((parent == null) ? null : parent.transform);
		if (transformInfo.tfParent != null)
		{
			transformInfo.v3LocalPosition = transformInfo.tfParent.InverseTransformPoint(node.transform.position);
			transformInfo.qLocalOrientation = Quaternion.Inverse(transformInfo.tfParent.rotation) * node.transform.rotation;
		}
		else
		{
			transformInfo.v3LocalPosition = node.transform.position;
			transformInfo.qLocalOrientation = node.transform.rotation;
		}
		transformInfo.v3LocalScale = node.transform.localScale;
		UltimateRopeLink component = node.GetComponent<UltimateRopeLink>();
		if (component != null)
		{
			transformInfo.bExtensibleKinematic = component.ExtensibleKinematic;
			transformInfo.bLinkMarkedKinematic = node.GetComponent<Rigidbody>() != null && node.GetComponent<Rigidbody>().isKinematic;
		}
		else
		{
			transformInfo.bExtensibleKinematic = false;
			transformInfo.bLinkMarkedKinematic = false;
		}
		return transformInfo;
	}

	private static void SetTransformInfo(RopeData.TransformInfo transformInfo, GameObject node)
	{
		if (transformInfo.tfParent != null)
		{
			node.transform.position = transformInfo.tfParent.TransformPoint(transformInfo.v3LocalPosition);
			node.transform.rotation = transformInfo.tfParent.rotation * transformInfo.qLocalOrientation;
		}
		else
		{
			node.transform.position = transformInfo.v3LocalPosition;
			node.transform.rotation = transformInfo.qLocalOrientation;
		}
		node.transform.localScale = transformInfo.v3LocalScale;
	}
}
[ExecuteInEditMode]
public class UltimateRope : MonoBehaviour
{
	public enum ERopeType
	{
		Procedural,
		LinkedObjects,
		ImportBones
	}

	public enum EAxis
	{
		MinusX,
		MinusY,
		MinusZ,
		X,
		Y,
		Z
	}

	public enum EColliderType
	{
		None,
		Capsule,
		Box
	}

	public enum ERopeExtensionMode
	{
		CoilRotationIncrement,
		LinearExtensionIncrement
	}

	[Serializable]
	public class RopeNode
	{
		public GameObject goNode;

		public float fLength;

		public float fTotalLength;

		public int nNumLinks;

		public int nTotalLinks;

		public EColliderType eColliderType;

		public int nColliderSkip;

		public bool bFold;

		public bool bIsCoil;

		public bool bInitialOrientationInitialized;

		public Vector3 v3InitialLocalPos;

		public Quaternion qInitialLocalRot;

		public Vector3 v3InitialLocalScale;

		public bool m_bExtensionInitialized;

		public int m_nExtensionLinkIn;

		public int m_nExtensionLinkOut;

		public float m_fExtensionRemainingLength;

		public float m_fExtensionRemainderIn;

		public float m_fExtensionRemainderOut;

		public Vector3 m_v3LocalDirectionForward;

		public Vector3 m_v3LocalDirectionUp;

		public GameObject[] segmentLinks;

		public ConfigurableJoint[] linkJoints;

		public bool[] linkJointBreaksProcessed;

		public bool bSegmentBroken;

		public RopeNode()
		{
			goNode = null;
			fLength = 5f;
			fTotalLength = fLength;
			nNumLinks = 20;
			nTotalLinks = nNumLinks;
			eColliderType = EColliderType.Capsule;
			nColliderSkip = 1;
			bFold = true;
			bIsCoil = false;
			bInitialOrientationInitialized = false;
			linkJoints = new ConfigurableJoint[0];
			linkJointBreaksProcessed = new bool[0];
			bSegmentBroken = false;
		}
	}

	[Serializable]
	public class RopeBone
	{
		public GameObject goBone;

		public Transform tfParent;

		public Transform tfNonBoneParent;

		public bool bCreatedCollider;

		public bool bIsStatic;

		public float fLength;

		public bool bCreatedRigidbody;

		public int nOriginalLayer;

		public Vector3 v3OriginalLocalScale;

		public Vector3 v3OriginalLocalPos;

		public Quaternion qOriginalLocalRot;

		public RopeBone()
		{
			goBone = null;
			tfParent = null;
			tfNonBoneParent = null;
			bCreatedCollider = false;
			bIsStatic = false;
			fLength = 0f;
			bCreatedRigidbody = false;
			nOriginalLayer = 0;
		}
	}

	public class RopeBreakEventInfo
	{
		public UltimateRope rope;

		public GameObject link1;

		public GameObject link2;

		public Vector3 worldPos;

		public Vector3 localLink1Pos;

		public Vector3 localLink2Pos;
	}

	[RopePersist]
	public ERopeType RopeType;

	[RopePersist]
	public GameObject RopeStart;

	[RopePersist]
	public List<RopeNode> RopeNodes;

	[RopePersist]
	public int RopeLayer;

	[RopePersist]
	public PhysicMaterial RopePhysicsMaterial;

	[RopePersist]
	public float RopeDiameter = 0.1f;

	[RopePersist]
	public float RopeDiameterScaleX = 1f;

	[RopePersist]
	public float RopeDiameterScaleY = 1f;

	[RopePersist]
	public int RopeSegmentSides = 8;

	[RopePersist]
	public Material RopeMaterial;

	[RopePersist]
	public float RopeTextureTileMeters = 1f;

	[RopePersist]
	public Material RopeSectionMaterial;

	[RopePersist]
	public float RopeTextureSectionTileMeters = 1f;

	[RopePersist]
	public bool IsExtensible;

	[RopePersist]
	public float ExtensibleLength = 10f;

	[RopePersist]
	public bool HasACoil;

	[RopePersist]
	public GameObject CoilObject;

	[RopePersist]
	public EAxis CoilAxisRight = EAxis.X;

	[RopePersist]
	public EAxis CoilAxisUp = EAxis.Y;

	[RopePersist]
	public float CoilWidth = 0.5f;

	[RopePersist]
	public float CoilDiameter = 0.5f;

	[RopePersist]
	public int CoilNumBones = 50;

	[RopePersist]
	public GameObject LinkObject;

	[RopePersist]
	public EAxis LinkAxis = EAxis.Z;

	[RopePersist]
	public float LinkOffsetObject;

	[RopePersist]
	public float LinkTwistAngleStart;

	[RopePersist]
	public float LinkTwistAngleIncrement;

	[RopePersist]
	public GameObject BoneFirst;

	[RopePersist]
	public GameObject BoneLast;

	[RopePersist]
	public string BoneListNamesStatic;

	[RopePersist]
	public string BoneListNamesNoColliders;

	[RopePersist]
	public EAxis BoneAxis = EAxis.Z;

	[RopePersist]
	public EColliderType BoneColliderType = EColliderType.Capsule;

	[RopePersist]
	public float BoneColliderDiameter = 0.1f;

	[RopePersist]
	public int BoneColliderSkip;

	[RopePersist]
	public float BoneColliderLength = 1f;

	[RopePersist]
	public float BoneColliderOffset;

	[RopePersist]
	public float LinkMass = 1f;

	[RopePersist]
	public int LinkSolverIterationCount = 200;

	[RopePersist]
	public float LinkJointAngularXLimit = 120f;

	[RopePersist]
	public float LinkJointAngularYLimit = 120f;

	[RopePersist]
	public float LinkJointAngularZLimit = 120f;

	[RopePersist]
	public float LinkJointSpringValue = 20f;

	[RopePersist]
	public float LinkJointDamperValue;

	[RopePersist]
	public float LinkJointMaxForceValue = 20f;

	[RopePersist]
	public float LinkJointBreakForce = float.PositiveInfinity;

	[RopePersist]
	public float LinkJointBreakTorque = float.PositiveInfinity;

	[RopePersist]
	public bool LockStartEndInZAxis;

	[RopePersist]
	public bool SendEvents;

	[RopePersist]
	public GameObject EventsObjectReceiver;

	[RopePersist]
	public string OnBreakMethodName;

	[RopePersist]
	public bool PersistAfterPlayMode;

	[RopePersist]
	public bool EnablePrefabUsage;

	[RopePersist]
	public bool AutoRegenerate = true;

	[HideInInspector]
	[RopePersist]
	public bool Deleted = true;

	[HideInInspector]
	[RopePersist]
	public float[] LinkLengths;

	[HideInInspector]
	[RopePersist]
	public int TotalLinks;

	[HideInInspector]
	[RopePersist]
	public float TotalRopeLength;

	[HideInInspector]
	[RopePersist]
	public bool m_bRopeStartInitialOrientationInitialized;

	[HideInInspector]
	[RopePersist]
	public Vector3 m_v3InitialRopeStartLocalPos;

	[HideInInspector]
	[RopePersist]
	public Quaternion m_qInitialRopeStartLocalRot;

	[HideInInspector]
	[RopePersist]
	public Vector3 m_v3InitialRopeStartLocalScale;

	[HideInInspector]
	[RopePersist]
	public int m_nFirstNonCoilNode;

	[HideInInspector]
	[RopePersist]
	public float[] m_afCoilBoneRadiuses;

	[HideInInspector]
	[RopePersist]
	public float[] m_afCoilBoneAngles;

	[HideInInspector]
	[RopePersist]
	public float[] m_afCoilBoneX;

	[HideInInspector]
	[RopePersist]
	public float m_fCurrentCoilRopeRadius;

	[HideInInspector]
	[RopePersist]
	public float m_fCurrentCoilTurnsLeft;

	[HideInInspector]
	[RopePersist]
	public float m_fCurrentCoilLength;

	[HideInInspector]
	[RopePersist]
	public float m_fCurrentExtension;

	[HideInInspector]
	[RopePersist]
	public float m_fCurrentExtensionInput;

	[HideInInspector]
	[RopePersist]
	public RopeBone[] ImportedBones;

	[HideInInspector]
	[RopePersist]
	public bool m_bBonesAreImported;

	[HideInInspector]
	[RopePersist]
	public string m_strStatus;

	[HideInInspector]
	[RopePersist]
	public bool m_bLastStatusIsError = true;

	[HideInInspector]
	[RopePersist]
	public string m_strAssetFile = "";

	[HideInInspector]
	public string Status
	{
		get
		{
			return m_strStatus;
		}
		set
		{
			m_strStatus = value;
		}
	}

	private void Awake()
	{
		if (Application.isPlaying)
		{
			CreateRopeJoints(bCheckIfBroken: true);
			SetupRopeLinks();
			if (FirstNodeIsCoil())
			{
				RecomputeCoil();
			}
		}
	}

	private void Start()
	{
		m_fCurrentExtensionInput = m_fCurrentExtension;
	}

	private void OnGUI()
	{
	}

	private void Update()
	{
	}

	private void FixedUpdate()
	{
		if (RopeNodes == null || RopeNodes.Count == 0)
		{
			return;
		}
		int num = -1;
		if (RopeType == ERopeType.Procedural && (LinkJointBreakForce != float.PositiveInfinity || LinkJointBreakTorque != float.PositiveInfinity))
		{
			SkinnedMeshRenderer component = base.gameObject.GetComponent<SkinnedMeshRenderer>();
			if (component == null)
			{
				return;
			}
			Mesh sharedMesh = component.sharedMesh;
			int[] indices = null;
			int[] indices2 = null;
			int num2 = 0;
			for (int i = 0; i < RopeNodes.Count; i++)
			{
				RopeNode ropeNode = RopeNodes[i];
				if (ropeNode.bIsCoil)
				{
					num2 += ropeNode.segmentLinks.Length;
					continue;
				}
				for (int j = 0; j < ropeNode.linkJoints.Length; j++)
				{
					if (ropeNode.linkJoints[j] == null && !ropeNode.linkJointBreaksProcessed[j])
					{
						bool num3 = i == 0 && j == 0 && !FirstNodeIsCoil();
						bool flag = i == RopeNodes.Count - 1 && j == ropeNode.linkJoints.Length - 1;
						if (!num3 && !flag)
						{
							indices = sharedMesh.GetTriangles(0);
							indices2 = sharedMesh.GetTriangles(1);
							break;
						}
					}
				}
				if (indices != null && indices2 != null)
				{
					break;
				}
			}
			for (int k = 0; k < RopeNodes.Count; k++)
			{
				RopeNode ropeNode2 = RopeNodes[k];
				if (ropeNode2.bIsCoil)
				{
					num2 += ropeNode2.segmentLinks.Length;
					continue;
				}
				for (int l = 0; l < ropeNode2.linkJoints.Length; l++)
				{
					if (ropeNode2.linkJoints[l] == null && !ropeNode2.linkJointBreaksProcessed[l])
					{
						ropeNode2.linkJointBreaksProcessed[l] = true;
						bool flag2 = k == 0 && l == 0 && !FirstNodeIsCoil();
						bool flag3 = k == RopeNodes.Count - 1 && l == ropeNode2.linkJoints.Length - 1;
						if (!flag2 && !flag3)
						{
							FillLinkMeshIndicesRope(num2 - 1, TotalLinks, ref indices, bBreakable: true, bBrokenLink: true);
							FillLinkMeshIndicesSections(num2 - 1, TotalLinks, ref indices2, bBreakable: true, bBrokenLink: true);
							num = k;
						}
						if (SendEvents && EventsObjectReceiver != null && OnBreakMethodName.Length > 0)
						{
							RopeBreakEventInfo ropeBreakEventInfo = new RopeBreakEventInfo();
							ropeBreakEventInfo.rope = this;
							ropeBreakEventInfo.worldPos = ((l == ropeNode2.linkJoints.Length - 1) ? ropeNode2.goNode.transform.position : ropeNode2.segmentLinks[l].transform.position);
							ropeBreakEventInfo.link2 = ((l == ropeNode2.linkJoints.Length - 1) ? ropeNode2.goNode : ropeNode2.segmentLinks[l]);
							ropeBreakEventInfo.localLink2Pos = Vector3.zero;
							if (flag2)
							{
								ropeBreakEventInfo.link1 = RopeStart.gameObject;
								ropeBreakEventInfo.localLink1Pos = Vector3.zero;
							}
							else
							{
								if (l > 0)
								{
									ropeBreakEventInfo.link1 = ropeNode2.segmentLinks[l - 1];
								}
								else
								{
									ropeBreakEventInfo.link1 = RopeNodes[k - 1].goNode;
								}
								ropeBreakEventInfo.localLink1Pos = GetLinkAxisOffset(LinkLengths[num2 - 1]);
							}
							EventsObjectReceiver.SendMessage(OnBreakMethodName, ropeBreakEventInfo);
						}
					}
					if (l < ropeNode2.segmentLinks.Length)
					{
						num2++;
					}
				}
			}
			if (num != -1)
			{
				sharedMesh.SetTriangles(indices, 0);
				sharedMesh.SetTriangles(indices2, 1);
				Vector4[] array = null;
				if (sharedMesh.tangents != null && sharedMesh.tangents.Length == sharedMesh.vertexCount)
				{
					array = sharedMesh.tangents;
				}
				sharedMesh.RecalculateNormals();
				if (array != null)
				{
					sharedMesh.tangents = array;
				}
			}
		}
		else if (RopeType == ERopeType.LinkedObjects && (LinkJointBreakForce != float.PositiveInfinity || LinkJointBreakTorque != float.PositiveInfinity) && SendEvents)
		{
			int num4 = 0;
			for (int m = 0; m < RopeNodes.Count; m++)
			{
				RopeNode ropeNode3 = RopeNodes[m];
				if (ropeNode3.bIsCoil)
				{
					num4 += ropeNode3.segmentLinks.Length;
					continue;
				}
				for (int n = 0; n < ropeNode3.linkJoints.Length; n++)
				{
					if (ropeNode3.linkJoints[n] == null && !ropeNode3.linkJointBreaksProcessed[n])
					{
						ropeNode3.linkJointBreaksProcessed[n] = true;
						bool flag4 = m == 0 && n == 0 && !FirstNodeIsCoil();
						num = m;
						if (SendEvents && EventsObjectReceiver != null && OnBreakMethodName.Length > 0)
						{
							RopeBreakEventInfo ropeBreakEventInfo2 = new RopeBreakEventInfo();
							ropeBreakEventInfo2.rope = this;
							ropeBreakEventInfo2.worldPos = ((n == ropeNode3.linkJoints.Length - 1) ? ropeNode3.goNode.transform.position : ropeNode3.segmentLinks[n].transform.position);
							ropeBreakEventInfo2.link2 = ((n == ropeNode3.linkJoints.Length - 1) ? ropeNode3.goNode : ropeNode3.segmentLinks[n]);
							ropeBreakEventInfo2.localLink2Pos = Vector3.zero;
							if (flag4)
							{
								ropeBreakEventInfo2.link1 = RopeStart.gameObject;
								ropeBreakEventInfo2.localLink1Pos = Vector3.zero;
							}
							else
							{
								if (n > 0)
								{
									ropeBreakEventInfo2.link1 = ropeNode3.segmentLinks[n - 1];
								}
								else
								{
									ropeBreakEventInfo2.link1 = RopeNodes[m - 1].goNode;
								}
								ropeBreakEventInfo2.localLink1Pos = GetLinkAxisOffset(LinkLengths[num4 - 1]);
							}
							EventsObjectReceiver.SendMessage(OnBreakMethodName, ropeBreakEventInfo2);
						}
					}
					if (n < ropeNode3.segmentLinks.Length)
					{
						num4++;
					}
				}
			}
		}
		if (num == -1)
		{
			return;
		}
		RopeNode ropeNode4 = RopeNodes[num];
		ropeNode4.bSegmentBroken = true;
		for (int num5 = 0; num5 < ropeNode4.linkJoints.Length; num5++)
		{
			if (ropeNode4.linkJoints[num5] != null)
			{
				ropeNode4.linkJoints[num5].breakForce = float.PositiveInfinity;
				ropeNode4.linkJoints[num5].breakTorque = float.PositiveInfinity;
			}
		}
	}

	public void DeleteRope(bool bResetNodePositions = false, bool bDestroySkin = true)
	{
		DeleteRopeLinks();
		foreach (RopeNode ropeNode in RopeNodes)
		{
			ropeNode.bSegmentBroken = false;
			if (ropeNode.bInitialOrientationInitialized && bResetNodePositions)
			{
				ropeNode.goNode.transform.localPosition = ropeNode.v3InitialLocalPos;
				ropeNode.goNode.transform.localRotation = ropeNode.qInitialLocalRot;
				ropeNode.goNode.transform.localScale = ropeNode.v3InitialLocalScale;
			}
			ropeNode.bInitialOrientationInitialized = false;
			for (int i = 0; i < ropeNode.linkJoints.Length; i++)
			{
				if (ropeNode.linkJoints[i] != null)
				{
					UnityEngine.Object.DestroyImmediate(ropeNode.linkJoints[i]);
				}
			}
		}
		if (RopeStart != null && m_bRopeStartInitialOrientationInitialized && bResetNodePositions)
		{
			RopeStart.transform.localPosition = m_v3InitialRopeStartLocalPos;
			RopeStart.transform.localRotation = m_qInitialRopeStartLocalRot;
			RopeStart.transform.localScale = m_v3InitialRopeStartLocalScale;
		}
		m_bRopeStartInitialOrientationInitialized = false;
		if (ImportedBones != null)
		{
			RopeBone[] importedBones = ImportedBones;
			foreach (RopeBone ropeBone in importedBones)
			{
				if (ropeBone.goBone != null)
				{
					ropeBone.goBone.layer = ropeBone.nOriginalLayer;
					if (ropeBone.bCreatedCollider && ropeBone.goBone.GetComponent<Collider>() != null)
					{
						UnityEngine.Object.DestroyImmediate(ropeBone.goBone.GetComponent<Collider>());
					}
					if (ropeBone.bCreatedRigidbody && ropeBone.goBone.GetComponent<Rigidbody>() != null)
					{
						UnityEngine.Object.DestroyImmediate(ropeBone.goBone.GetComponent<Rigidbody>());
					}
				}
			}
			importedBones = ImportedBones;
			foreach (RopeBone ropeBone2 in importedBones)
			{
				if (ropeBone2.goBone != null)
				{
					if (ropeBone2.tfNonBoneParent != null)
					{
						ropeBone2.goBone.transform.parent = ropeBone2.tfNonBoneParent;
						ropeBone2.goBone.transform.localPosition = ropeBone2.v3OriginalLocalPos;
						ropeBone2.goBone.transform.localRotation = ropeBone2.qOriginalLocalRot;
					}
					ropeBone2.goBone.transform.parent = ropeBone2.tfParent;
					ropeBone2.goBone.transform.localScale = ropeBone2.v3OriginalLocalScale;
				}
			}
		}
		if (!Application.isEditor || !Application.isPlaying)
		{
			ImportedBones = null;
		}
		SkinnedMeshRenderer component = GetComponent<SkinnedMeshRenderer>();
		if ((bool)component)
		{
			UnityEngine.Object.DestroyImmediate(component.sharedMesh);
			if (bDestroySkin)
			{
				UnityEngine.Object.DestroyImmediate(component);
			}
		}
		CheckDelCoilNode();
		Deleted = true;
	}

	public void DeleteRopeLinks()
	{
		if (m_bBonesAreImported)
		{
			return;
		}
		if (CoilObject != null)
		{
			for (int i = 0; i < CoilObject.transform.childCount; i++)
			{
				Transform child = CoilObject.transform.GetChild(i);
				if (child.gameObject.GetComponent<UltimateRopeLink>() != null)
				{
					UnityEngine.Object.DestroyImmediate(child.gameObject);
					i--;
				}
			}
		}
		if (RopeStart != null)
		{
			for (int j = 0; j < RopeStart.transform.childCount; j++)
			{
				Transform child2 = RopeStart.transform.GetChild(j);
				if (child2.gameObject.GetComponent<UltimateRopeLink>() != null)
				{
					UnityEngine.Object.DestroyImmediate(child2.gameObject);
					j--;
				}
			}
		}
		for (int k = 0; k < base.transform.childCount; k++)
		{
			Transform child3 = base.transform.GetChild(k);
			if (child3.gameObject.GetComponent<UltimateRopeLink>() != null)
			{
				UnityEngine.Object.DestroyImmediate(child3.gameObject);
				k--;
			}
		}
		foreach (RopeNode ropeNode in RopeNodes)
		{
			if ((bool)ropeNode.goNode)
			{
				for (int l = 0; l < ropeNode.goNode.transform.childCount; l++)
				{
					Transform child4 = ropeNode.goNode.transform.GetChild(l);
					if (child4.gameObject.GetComponent<UltimateRopeLink>() != null)
					{
						UnityEngine.Object.DestroyImmediate(child4.gameObject);
						l--;
					}
				}
			}
			ropeNode.segmentLinks = null;
		}
	}

	public bool Regenerate(bool bResetNodePositions = false)
	{
		m_bLastStatusIsError = true;
		DeleteRope(bResetNodePositions, bDestroySkin: false);
		if (RopeType == ERopeType.Procedural || RopeType == ERopeType.LinkedObjects)
		{
			if (RopeStart == null)
			{
				Status = "A rope start GameObject needs to be specified";
				return false;
			}
			if (RopeNodes == null)
			{
				Status = "At least a rope node needs to be added";
				return false;
			}
			if (RopeNodes.Count == 0)
			{
				Status = "At least a rope node needs to be added";
				return false;
			}
			if (RopeType == ERopeType.Procedural && IsExtensible && HasACoil && CoilObject == null)
			{
				Status = "A coil object needs to be specified";
				return false;
			}
			if (RopeType == ERopeType.LinkedObjects && LinkObject == null)
			{
				Status = "A link object needs to be specified";
				return false;
			}
			for (int i = 0; i < RopeNodes.Count; i++)
			{
				if (RopeNodes[i].goNode == null)
				{
					Status = $"Rope segment {i} has unassigned Segment End property";
					return false;
				}
			}
		}
		float realtimeSinceStartup = Time.realtimeSinceStartup;
		List<RopeBone> outListImportedBones = null;
		if (RopeType == ERopeType.ImportBones)
		{
			Status = "";
			if (BoneFirst == null)
			{
				Status = "The first bone needs to be specified";
				return false;
			}
			if (BoneLast == null)
			{
				Status = "The last bone needs to be specified";
				return false;
			}
			if (!ParseBoneIndices(BoneListNamesStatic, out var outListBoneIndices, out var strErrorMessage))
			{
				Status = "Error parsing static bone list:\n" + strErrorMessage;
				return false;
			}
			if (!ParseBoneIndices(BoneListNamesNoColliders, out var outListBoneIndices2, out strErrorMessage))
			{
				Status = "Error parsing collider bone list:\n" + strErrorMessage;
				return false;
			}
			if (!BuildImportedBoneList(BoneFirst, BoneLast, outListBoneIndices, outListBoneIndices2, out outListImportedBones, out strErrorMessage))
			{
				Status = "Error building bone list:\n" + strErrorMessage;
				return false;
			}
		}
		base.gameObject.layer = RopeLayer;
		CheckAddCoilNode();
		if (!m_bRopeStartInitialOrientationInitialized && RopeStart != null)
		{
			m_v3InitialRopeStartLocalPos = RopeStart.transform.localPosition;
			m_qInitialRopeStartLocalRot = RopeStart.transform.localRotation;
			m_v3InitialRopeStartLocalScale = RopeStart.transform.localScale;
			m_bRopeStartInitialOrientationInitialized = true;
		}
		if (RopeType == ERopeType.Procedural || RopeType == ERopeType.LinkedObjects)
		{
			TotalLinks = 0;
			TotalRopeLength = 0f;
			for (int j = 0; j < RopeNodes.Count; j++)
			{
				RopeNode ropeNode = RopeNodes[j];
				if (!ropeNode.bInitialOrientationInitialized)
				{
					ropeNode.v3InitialLocalPos = ropeNode.goNode.transform.localPosition;
					ropeNode.qInitialLocalRot = ropeNode.goNode.transform.localRotation;
					ropeNode.v3InitialLocalScale = ropeNode.goNode.transform.localScale;
					ropeNode.bInitialOrientationInitialized = true;
				}
				if (ropeNode.nNumLinks < 1)
				{
					ropeNode.nNumLinks = 1;
				}
				if (ropeNode.fLength < 0f)
				{
					ropeNode.fLength = 0.001f;
				}
				ropeNode.nTotalLinks = ropeNode.nNumLinks;
				ropeNode.fTotalLength = ropeNode.fLength;
				GameObject gameObject = null;
				GameObject gameObject2 = null;
				if (FirstNodeIsCoil() && j == 0)
				{
					gameObject = CoilObject;
					gameObject2 = RopeStart;
				}
				else
				{
					gameObject = ((j == m_nFirstNonCoilNode) ? RopeStart : RopeNodes[j - 1].goNode);
					gameObject2 = RopeNodes[j].goNode;
				}
				ropeNode.m_v3LocalDirectionForward = gameObject.transform.InverseTransformDirection((gameObject2.transform.position - gameObject.transform.position).normalized);
				if (j == RopeNodes.Count - 1 && IsExtensible && ExtensibleLength > 0f)
				{
					ropeNode.nTotalLinks += (int)(ExtensibleLength / (ropeNode.fLength / (float)ropeNode.nNumLinks)) + 1;
					ropeNode.fTotalLength += ExtensibleLength;
					ropeNode.m_bExtensionInitialized = false;
					ropeNode.m_nExtensionLinkIn = ropeNode.nTotalLinks - ropeNode.nNumLinks;
					ropeNode.m_nExtensionLinkOut = ropeNode.m_nExtensionLinkIn - 1;
					ropeNode.m_fExtensionRemainingLength = ExtensibleLength;
					ropeNode.m_fExtensionRemainderIn = 0f;
					ropeNode.m_fExtensionRemainderOut = 0f;
					m_fCurrentExtension = 0f;
				}
				ropeNode.linkJoints = new ConfigurableJoint[ropeNode.nTotalLinks + 1];
				ropeNode.linkJointBreaksProcessed = new bool[ropeNode.nTotalLinks + 1];
				ropeNode.segmentLinks = new GameObject[ropeNode.nTotalLinks];
				if (FirstNodeIsCoil() && j == 0)
				{
					for (int k = 0; k < ropeNode.segmentLinks.Length; k++)
					{
						string text = "Coil Link " + k;
						ropeNode.segmentLinks[k] = new GameObject(text);
						ropeNode.segmentLinks[k].AddComponent<UltimateRopeLink>();
						ropeNode.segmentLinks[k].transform.parent = CoilObject.transform;
						ropeNode.segmentLinks[k].layer = RopeLayer;
					}
					if (CoilDiameter < 0f)
					{
						CoilDiameter = 0f;
					}
					if (CoilWidth < 0f)
					{
						CoilWidth = 0f;
					}
					SetupCoilBones(ExtensibleLength);
				}
				else
				{
					float num = ropeNode.fLength / (float)ropeNode.nNumLinks;
					float num2 = ((gameObject2.transform.position - gameObject.transform.position).magnitude - num) / (gameObject2.transform.position - gameObject.transform.position).magnitude;
					float num3 = ((RopeType == ERopeType.LinkedObjects) ? GetLinkedObjectScale(ropeNode.fLength, ropeNode.nNumLinks) : 1f);
					for (int l = 0; l < ropeNode.segmentLinks.Length; l++)
					{
						float num4 = (float)l / ((ropeNode.segmentLinks.Length == 1) ? 1f : ((float)ropeNode.segmentLinks.Length - 1f));
						string text2 = "Node " + j + " Link " + l;
						if (ropeNode.nTotalLinks > ropeNode.nNumLinks && l < ropeNode.nTotalLinks - ropeNode.nNumLinks)
						{
							text2 += " (extension)";
						}
						if (RopeType == ERopeType.Procedural)
						{
							ropeNode.segmentLinks[l] = new GameObject(text2);
						}
						else if (RopeType == ERopeType.LinkedObjects)
						{
							ropeNode.segmentLinks[l] = UnityEngine.Object.Instantiate(LinkObject);
							ropeNode.segmentLinks[l].name = text2;
						}
						ropeNode.segmentLinks[l].AddComponent<UltimateRopeLink>();
						if (Vector3.Distance(gameObject.transform.position, gameObject2.transform.position) < 0.001f)
						{
							ropeNode.segmentLinks[l].transform.position = gameObject.transform.position;
							ropeNode.segmentLinks[l].transform.rotation = gameObject.transform.rotation;
						}
						else
						{
							ropeNode.segmentLinks[l].transform.position = Vector3.Lerp(gameObject.transform.position, gameObject2.transform.position, num4 * num2);
							ropeNode.segmentLinks[l].transform.rotation = Quaternion.LookRotation((gameObject2.transform.position - gameObject.transform.position).normalized);
						}
						if (RopeType == ERopeType.LinkedObjects)
						{
							ropeNode.segmentLinks[l].transform.rotation *= GetLinkedObjectLocalRotation(LinkTwistAngleStart + LinkTwistAngleIncrement * (float)l);
							ropeNode.segmentLinks[l].transform.localScale = new Vector3(num3, num3, num3);
						}
						if (ropeNode.segmentLinks[l].GetComponent<Rigidbody>() == null)
						{
							ropeNode.segmentLinks[l].AddComponent<Rigidbody>();
						}
						ropeNode.segmentLinks[l].transform.parent = base.transform;
						ropeNode.segmentLinks[l].layer = RopeLayer;
					}
				}
				TotalLinks += ropeNode.segmentLinks.Length;
				TotalRopeLength += ropeNode.fTotalLength;
			}
			m_bBonesAreImported = false;
		}
		else if (RopeType == ERopeType.ImportBones)
		{
			TotalLinks = 0;
			TotalRopeLength = 0f;
			ImportedBones = outListImportedBones.ToArray();
			bool flag = false;
			if (RopeNodes != null && RopeNodes.Count != 0)
			{
				flag = true;
			}
			if (!flag)
			{
				RopeNodes = new List<RopeNode>();
				RopeNodes.Add(new RopeNode());
			}
			RopeNode ropeNode2 = RopeNodes[0];
			ropeNode2.nNumLinks = ImportedBones.Length;
			ropeNode2.nTotalLinks = ropeNode2.nNumLinks;
			ropeNode2.linkJoints = new ConfigurableJoint[ImportedBones.Length];
			ropeNode2.linkJointBreaksProcessed = new bool[ImportedBones.Length];
			ropeNode2.segmentLinks = new GameObject[ropeNode2.nTotalLinks];
			int num5 = 0;
			for (int m = 0; m < ImportedBones.Length; m++)
			{
				ropeNode2.segmentLinks[num5] = ImportedBones[m].goBone;
				if (ImportedBones[m].goBone.GetComponent<Rigidbody>() == null)
				{
					ImportedBones[m].goBone.AddComponent<Rigidbody>();
					ImportedBones[m].bCreatedRigidbody = true;
				}
				else
				{
					ImportedBones[m].bCreatedRigidbody = false;
				}
				ImportedBones[m].goBone.layer = RopeLayer;
				float num6 = 0f;
				num6 = ((num5 >= ImportedBones.Length - 1) ? 0f : Vector3.Distance(ImportedBones[m].goBone.transform.position, ImportedBones[m + 1].goBone.transform.position));
				TotalLinks += ropeNode2.segmentLinks.Length;
				TotalRopeLength += num6;
				ImportedBones[m].fLength = num6;
				num5++;
			}
			ropeNode2.fLength = TotalRopeLength;
			ropeNode2.fTotalLength = ropeNode2.fLength;
			ropeNode2.eColliderType = BoneColliderType;
			ropeNode2.nColliderSkip = BoneColliderSkip;
			m_bBonesAreImported = true;
		}
		if (RopeType == ERopeType.Procedural)
		{
			Transform[] array = new Transform[TotalLinks];
			Matrix4x4[] array2 = new Matrix4x4[TotalLinks];
			LinkLengths = new float[TotalLinks];
			int num7 = 0;
			for (int n = 0; n < RopeNodes.Count; n++)
			{
				RopeNode ropeNode3 = RopeNodes[n];
				for (int num8 = 0; num8 < ropeNode3.segmentLinks.Length; num8++)
				{
					array[num7] = ropeNode3.segmentLinks[num8].transform;
					array2[num7] = ropeNode3.segmentLinks[num8].transform.worldToLocalMatrix;
					if (ropeNode3.segmentLinks[num8].transform.parent != null)
					{
						array2[num7] *= base.transform.localToWorldMatrix;
					}
					LinkLengths[num7] = ropeNode3.fLength / (float)ropeNode3.nNumLinks;
					num7++;
				}
			}
			if (RopeDiameter < 0.01f)
			{
				RopeDiameter = 0.01f;
			}
			if (RopeDiameterScaleX < 0.01f)
			{
				RopeDiameterScaleX = 0.01f;
			}
			if (RopeDiameterScaleY < 0.01f)
			{
				RopeDiameterScaleY = 0.01f;
			}
			bool flag2 = LinkJointBreakForce != float.PositiveInfinity || LinkJointBreakTorque != float.PositiveInfinity;
			Mesh mesh = new Mesh();
			int num9 = (flag2 ? (TotalLinks * (RopeSegmentSides + 1) * 4) : ((TotalLinks + 1) * (RopeSegmentSides + 1) + (RopeSegmentSides + 1) * 2));
			int num10 = TotalLinks * RopeSegmentSides * 2;
			int num11 = (flag2 ? (TotalLinks * 2 * (RopeSegmentSides - 2)) : (2 * (RopeSegmentSides - 2)));
			Vector3[] array3 = new Vector3[num9];
			Vector2[] array4 = new Vector2[num9];
			Vector4[] array5 = new Vector4[num9];
			BoneWeight[] array6 = new BoneWeight[num9];
			int[] indices = new int[num10 * 3];
			int[] indices2 = new int[num11 * 3];
			if (flag2)
			{
				int num12 = 0;
				for (int num13 = 0; num13 < TotalLinks; num13++)
				{
					int num14 = num13;
					int num15 = num14;
					float num16 = 1f;
					float num17 = 1f - num16;
					FillLinkMeshIndicesRope(num13, TotalLinks, ref indices, flag2);
					FillLinkMeshIndicesSections(num13, TotalLinks, ref indices2, flag2);
					for (int num18 = 0; num18 < 4; num18++)
					{
						for (int num19 = 0; num19 < RopeSegmentSides + 1; num19++)
						{
							int num20 = ((num18 >= 2) ? 1 : 0);
							float num21 = (float)(num13 + num20) / (float)TotalLinks;
							float num22 = Mathf.Cos((float)num19 / (float)RopeSegmentSides * (float)Math.PI * 2f);
							float num23 = Mathf.Sin((float)num19 / (float)RopeSegmentSides * (float)Math.PI * 2f);
							array3[num12] = new Vector3(num22 * RopeDiameter * RopeDiameterScaleX * 0.5f, num23 * RopeDiameter * RopeDiameterScaleY * 0.5f, LinkLengths[num13] * (float)num20);
							array3[num12] = array[num14].TransformPoint(array3[num12]) * num16 + array[num15].TransformPoint(array3[num12]) * num17;
							array3[num12] = base.transform.InverseTransformPoint(array3[num12]);
							if (num18 == 0 || num18 == 3)
							{
								array4[num12] = new Vector2(Mathf.Clamp01((num22 + 1f) * 0.5f), Mathf.Clamp01((num23 + 1f) * 0.5f));
								array5[num12] = new Vector4(1f, 0f, 0f, 1f);
							}
							else
							{
								array4[num12] = new Vector2(num21 * TotalRopeLength * RopeTextureTileMeters, (float)num19 / (float)RopeSegmentSides);
								array5[num12] = new Vector4(0f, 0f, 1f, 1f);
							}
							array6[num12].boneIndex0 = num14;
							array6[num12].boneIndex1 = num15;
							array6[num12].weight0 = num16;
							array6[num12].weight1 = num17;
							num12++;
						}
					}
				}
			}
			else
			{
				int num24 = 0;
				FillLinkMeshIndicesSections(0, TotalLinks, ref indices2, flag2);
				for (int num25 = 0; num25 < TotalLinks + 1; num25++)
				{
					int num26 = ((num25 < TotalLinks) ? num25 : (TotalLinks - 1));
					int num27 = num26;
					float num28 = 1f;
					float num29 = 1f - num28;
					if (num25 < TotalLinks)
					{
						FillLinkMeshIndicesRope(num25, TotalLinks, ref indices, flag2);
					}
					bool flag3 = false;
					bool flag4 = false;
					int num30 = 1;
					if (num25 == 0)
					{
						num30++;
						flag3 = true;
					}
					if (num25 == TotalLinks)
					{
						num30++;
						flag4 = true;
					}
					for (int num31 = 0; num31 < num30; num31++)
					{
						for (int num32 = 0; num32 < RopeSegmentSides + 1; num32++)
						{
							float num33 = (float)num25 / (float)TotalLinks;
							float num34 = Mathf.Cos((float)num32 / (float)RopeSegmentSides * (float)Math.PI * 2f);
							float num35 = Mathf.Sin((float)num32 / (float)RopeSegmentSides * (float)Math.PI * 2f);
							array3[num24] = new Vector3(num34 * RopeDiameter * RopeDiameterScaleX * 0.5f, num35 * RopeDiameter * RopeDiameterScaleY * 0.5f, (!flag4) ? 0f : LinkLengths[TotalLinks - 1]);
							array3[num24] = array[num26].TransformPoint(array3[num24]) * num28 + array[num27].TransformPoint(array3[num24]) * num29;
							array3[num24] = base.transform.InverseTransformPoint(array3[num24]);
							if ((flag3 && num31 == 0) || (flag4 && num31 == num30 - 1))
							{
								array4[num24] = new Vector2(Mathf.Clamp01((num34 + 1f) * 0.5f), Mathf.Clamp01((num35 + 1f) * 0.5f));
								array5[num24] = new Vector4(1f, 0f, 0f, 1f);
							}
							else
							{
								array4[num24] = new Vector2(num33 * TotalRopeLength * RopeTextureTileMeters, (float)num32 / (float)RopeSegmentSides);
								array5[num24] = new Vector4(0f, 0f, 1f, 1f);
							}
							array6[num24].boneIndex0 = num26;
							array6[num24].boneIndex1 = num27;
							array6[num24].weight0 = num28;
							array6[num24].weight1 = num29;
							num24++;
						}
					}
				}
			}
			mesh.vertices = array3;
			mesh.uv = array4;
			mesh.boneWeights = array6;
			mesh.bindposes = array2;
			mesh.subMeshCount = 2;
			mesh.SetTriangles(indices, 0);
			mesh.SetTriangles(indices2, 1);
			mesh.RecalculateNormals();
			mesh.tangents = array5;
			SkinnedMeshRenderer obj = ((base.gameObject.GetComponent<SkinnedMeshRenderer>() != null) ? base.gameObject.GetComponent<SkinnedMeshRenderer>() : base.gameObject.AddComponent<SkinnedMeshRenderer>());
			obj.materials = new Material[2] { RopeMaterial, RopeSectionMaterial };
			obj.bones = array;
			obj.sharedMesh = mesh;
			obj.updateWhenOffscreen = true;
		}
		Deleted = false;
		if (Application.isPlaying)
		{
			CreateRopeJoints();
		}
		SetupRopeLinks();
		float realtimeSinceStartup2 = Time.realtimeSinceStartup;
		Status = $"Rope generated in {realtimeSinceStartup2 - realtimeSinceStartup} seconds";
		m_bLastStatusIsError = false;
		return true;
	}

	public bool IsLastStatusError()
	{
		return m_bLastStatusIsError;
	}

	public bool ChangeRopeDiameter(float fNewDiameter, float fNewScaleX, float fNewScaleY)
	{
		if (RopeType != 0)
		{
			return false;
		}
		SkinnedMeshRenderer component = base.gameObject.GetComponent<SkinnedMeshRenderer>();
		if (component == null)
		{
			return false;
		}
		RopeDiameter = fNewDiameter;
		RopeDiameterScaleX = fNewScaleX;
		RopeDiameterScaleY = fNewScaleY;
		if (RopeDiameter < 0.01f)
		{
			RopeDiameter = 0.01f;
		}
		if (RopeDiameterScaleX < 0.01f)
		{
			RopeDiameterScaleX = 0.01f;
		}
		if (RopeDiameterScaleY < 0.01f)
		{
			RopeDiameterScaleY = 0.01f;
		}
		bool flag = LinkJointBreakForce != float.PositiveInfinity || LinkJointBreakTorque != float.PositiveInfinity;
		Vector3[] vertices = component.sharedMesh.vertices;
		Matrix4x4[] bindposes = component.sharedMesh.bindposes;
		Vector2[] array = new Vector2[RopeSegmentSides + 1];
		for (int i = 0; i < RopeSegmentSides + 1; i++)
		{
			float num = Mathf.Cos((float)i / (float)RopeSegmentSides * (float)Math.PI * 2f);
			float num2 = Mathf.Sin((float)i / (float)RopeSegmentSides * (float)Math.PI * 2f);
			array[i] = new Vector2(num * RopeDiameter * RopeDiameterScaleX * 0.5f, num2 * RopeDiameter * RopeDiameterScaleY * 0.5f);
		}
		if (flag)
		{
			int num3 = 0;
			for (int j = 0; j < TotalLinks; j++)
			{
				int num4 = j;
				int num5 = num4;
				float num6 = 1f;
				float num7 = 1f - num6;
				bindposes[j] = component.bones[j].transform.worldToLocalMatrix;
				if (component.bones[j].transform.parent != null)
				{
					bindposes[j] *= base.transform.localToWorldMatrix;
				}
				for (int k = 0; k < 4; k++)
				{
					for (int l = 0; l < RopeSegmentSides + 1; l++)
					{
						int num8 = ((k >= 2) ? 1 : 0);
						vertices[num3] = new Vector3(array[l].x, array[l].y, LinkLengths[j] * (float)num8);
						vertices[num3] = component.bones[num4].TransformPoint(vertices[num3]) * num6 + component.bones[num5].TransformPoint(vertices[num3]) * num7;
						vertices[num3] = base.transform.InverseTransformPoint(vertices[num3]);
						num3++;
					}
				}
			}
		}
		else
		{
			int num9 = 0;
			for (int m = 0; m < TotalLinks + 1; m++)
			{
				int num10 = ((m < TotalLinks) ? m : (TotalLinks - 1));
				int num11 = num10;
				float num12 = 1f;
				float num13 = 1f - num12;
				bool flag2 = false;
				int num14 = 1;
				if (m == 0)
				{
					num14++;
				}
				if (m == TotalLinks)
				{
					num14++;
					flag2 = true;
				}
				if (m < TotalLinks)
				{
					bindposes[m] = component.bones[m].transform.worldToLocalMatrix;
					if (component.bones[m].transform.parent != null)
					{
						bindposes[m] *= base.transform.localToWorldMatrix;
					}
				}
				for (int n = 0; n < num14; n++)
				{
					for (int num15 = 0; num15 < RopeSegmentSides + 1; num15++)
					{
						vertices[num9] = new Vector3(array[num15].x, array[num15].y, (!flag2) ? 0f : LinkLengths[TotalLinks - 1]);
						vertices[num9] = component.bones[num10].TransformPoint(vertices[num9]) * num12 + component.bones[num11].TransformPoint(vertices[num9]) * num13;
						vertices[num9] = base.transform.InverseTransformPoint(vertices[num9]);
						num9++;
					}
				}
			}
		}
		component.sharedMesh.vertices = vertices;
		component.sharedMesh.bindposes = bindposes;
		SetupRopeLinks();
		return true;
	}

	public bool ChangeRopeSegmentSides(int nNewSegmentSides)
	{
		if (RopeType != 0)
		{
			return false;
		}
		SkinnedMeshRenderer component = base.gameObject.GetComponent<SkinnedMeshRenderer>();
		if (component == null)
		{
			return false;
		}
		RopeSegmentSides = nNewSegmentSides;
		if (RopeSegmentSides < 3)
		{
			RopeSegmentSides = 3;
		}
		bool flag = LinkJointBreakForce != float.PositiveInfinity || LinkJointBreakTorque != float.PositiveInfinity;
		Mesh mesh = new Mesh();
		int num = (flag ? (TotalLinks * (RopeSegmentSides + 1) * 4) : ((TotalLinks + 1) * (RopeSegmentSides + 1) + (RopeSegmentSides + 1) * 2));
		int num2 = TotalLinks * RopeSegmentSides * 2;
		int num3 = (flag ? (TotalLinks * 2 * (RopeSegmentSides - 2)) : (2 * (RopeSegmentSides - 2)));
		Vector3[] array = new Vector3[num];
		Vector2[] array2 = new Vector2[num];
		Vector4[] array3 = new Vector4[num];
		BoneWeight[] array4 = new BoneWeight[num];
		int[] indices = new int[num2 * 3];
		int[] indices2 = new int[num3 * 3];
		Matrix4x4[] bindposes = component.sharedMesh.bindposes;
		if (flag)
		{
			int num4 = 0;
			for (int i = 0; i < TotalLinks; i++)
			{
				int num5 = i;
				int num6 = num5;
				float num7 = 1f;
				float num8 = 1f - num7;
				bindposes[i] = component.bones[i].transform.worldToLocalMatrix;
				if (component.bones[i].transform.parent != null)
				{
					bindposes[i] *= base.transform.localToWorldMatrix;
				}
				FillLinkMeshIndicesRope(i, TotalLinks, ref indices, flag);
				FillLinkMeshIndicesSections(i, TotalLinks, ref indices2, flag);
				for (int j = 0; j < 4; j++)
				{
					for (int k = 0; k < RopeSegmentSides + 1; k++)
					{
						int num9 = ((j >= 2) ? 1 : 0);
						float num10 = (float)(i + num9) / (float)TotalLinks;
						float num11 = Mathf.Cos((float)k / (float)RopeSegmentSides * (float)Math.PI * 2f);
						float num12 = Mathf.Sin((float)k / (float)RopeSegmentSides * (float)Math.PI * 2f);
						array[num4] = new Vector3(num11 * RopeDiameter * RopeDiameterScaleX * 0.5f, num12 * RopeDiameter * RopeDiameterScaleY * 0.5f, LinkLengths[i] * (float)num9);
						array[num4] = component.bones[num5].TransformPoint(array[num4]) * num7 + component.bones[num6].TransformPoint(array[num4]) * num8;
						array[num4] = base.transform.InverseTransformPoint(array[num4]);
						if (j == 0 || j == 3)
						{
							array2[num4] = new Vector2(Mathf.Clamp01((num11 + 1f) * 0.5f), Mathf.Clamp01((num12 + 1f) * 0.5f));
							array3[num4] = new Vector4(1f, 0f, 0f, 1f);
						}
						else
						{
							array2[num4] = new Vector2(num10 * TotalRopeLength * RopeTextureTileMeters, (float)k / (float)RopeSegmentSides);
							array3[num4] = new Vector4(0f, 0f, 1f, 1f);
						}
						array4[num4].boneIndex0 = num5;
						array4[num4].boneIndex1 = num6;
						array4[num4].weight0 = num7;
						array4[num4].weight1 = num8;
						num4++;
					}
				}
			}
		}
		else
		{
			int num13 = 0;
			FillLinkMeshIndicesSections(0, TotalLinks, ref indices2, flag);
			for (int l = 0; l < TotalLinks + 1; l++)
			{
				int num14 = ((l < TotalLinks) ? l : (TotalLinks - 1));
				int num15 = num14;
				float num16 = 1f;
				float num17 = 1f - num16;
				if (l < TotalLinks)
				{
					FillLinkMeshIndicesRope(l, TotalLinks, ref indices, flag);
				}
				bool flag2 = false;
				bool flag3 = false;
				int num18 = 1;
				if (l == 0)
				{
					num18++;
					flag2 = true;
				}
				if (l == TotalLinks)
				{
					num18++;
					flag3 = true;
				}
				if (l < TotalLinks)
				{
					bindposes[l] = component.bones[l].transform.worldToLocalMatrix;
					if (component.bones[l].transform.parent != null)
					{
						bindposes[l] *= base.transform.localToWorldMatrix;
					}
				}
				for (int m = 0; m < num18; m++)
				{
					for (int n = 0; n < RopeSegmentSides + 1; n++)
					{
						float num19 = (float)l / (float)TotalLinks;
						float num20 = Mathf.Cos((float)n / (float)RopeSegmentSides * (float)Math.PI * 2f);
						float num21 = Mathf.Sin((float)n / (float)RopeSegmentSides * (float)Math.PI * 2f);
						array[num13] = new Vector3(num20 * RopeDiameter * RopeDiameterScaleX * 0.5f, num21 * RopeDiameter * RopeDiameterScaleY * 0.5f, (!flag3) ? 0f : LinkLengths[TotalLinks - 1]);
						array[num13] = component.bones[num14].TransformPoint(array[num13]) * num16 + component.bones[num15].TransformPoint(array[num13]) * num17;
						array[num13] = base.transform.InverseTransformPoint(array[num13]);
						if ((flag2 && m == 0) || (flag3 && m == num18 - 1))
						{
							array2[num13] = new Vector2(Mathf.Clamp01((num20 + 1f) * 0.5f), Mathf.Clamp01((num21 + 1f) * 0.5f));
							array3[num13] = new Vector4(1f, 0f, 0f, 1f);
						}
						else
						{
							array2[num13] = new Vector2(num19 * TotalRopeLength * RopeTextureTileMeters, (float)n / (float)RopeSegmentSides);
							array3[num13] = new Vector4(0f, 0f, 1f, 1f);
						}
						array4[num13].boneIndex0 = num14;
						array4[num13].boneIndex1 = num15;
						array4[num13].weight0 = num16;
						array4[num13].weight1 = num17;
						num13++;
					}
				}
			}
		}
		mesh.vertices = array;
		mesh.uv = array2;
		mesh.boneWeights = array4;
		mesh.bindposes = bindposes;
		mesh.subMeshCount = 2;
		mesh.SetTriangles(indices, 0);
		mesh.SetTriangles(indices2, 1);
		mesh.RecalculateNormals();
		mesh.tangents = array3;
		if (Application.isEditor && !Application.isPlaying)
		{
			UnityEngine.Object.DestroyImmediate(component.sharedMesh);
		}
		else
		{
			UnityEngine.Object.Destroy(component.sharedMesh);
		}
		component.sharedMesh = mesh;
		SetupRopeLinks();
		return true;
	}

	public void SetupRopeMaterials()
	{
		if (RopeType == ERopeType.Procedural)
		{
			SkinnedMeshRenderer component = base.gameObject.GetComponent<SkinnedMeshRenderer>();
			if (component != null)
			{
				component.materials = new Material[2] { RopeMaterial, RopeSectionMaterial };
			}
		}
	}

	public void SetupRopeLinks()
	{
		if (RopeNodes == null || RopeNodes.Count == 0 || Deleted || (RopeType == ERopeType.ImportBones && ImportedBones == null))
		{
			return;
		}
		base.gameObject.layer = RopeLayer;
		if (RopeDiameter < 0.01f)
		{
			RopeDiameter = 0.01f;
		}
		for (int i = 0; i < RopeNodes.Count; i++)
		{
			RopeNode ropeNode = RopeNodes[i];
			if (ropeNode.bIsCoil)
			{
				continue;
			}
			if (RopeType == ERopeType.ImportBones)
			{
				ropeNode.eColliderType = BoneColliderType;
				ropeNode.nColliderSkip = BoneColliderSkip;
			}
			float num = ropeNode.fLength / (float)ropeNode.nNumLinks;
			float linkDiameter = GetLinkDiameter();
			int nColliderSkip = ropeNode.nColliderSkip;
			float fValue = ((RopeType == ERopeType.Procedural) ? (num * 0.5f) : 0f);
			int num2 = 0;
			GameObject[] segmentLinks = ropeNode.segmentLinks;
			foreach (GameObject gameObject in segmentLinks)
			{
				if (!gameObject)
				{
					continue;
				}
				if ((bool)gameObject.GetComponent<Collider>())
				{
					UnityEngine.Object.DestroyImmediate(gameObject.GetComponent<Collider>());
				}
				bool flag = num2 % (nColliderSkip + 1) == 0;
				bool flag2 = gameObject.GetComponent<Rigidbody>() != null && gameObject.GetComponent<Rigidbody>().isKinematic;
				if (RopeType == ERopeType.ImportBones)
				{
					if (Mathf.Approximately(ImportedBones[num2].fLength, 0f))
					{
						flag = false;
					}
					else if (flag)
					{
						flag = ImportedBones[num2].bCreatedCollider;
					}
					num = ImportedBones[num2].fLength * BoneColliderLength;
					fValue = num * BoneColliderOffset;
					flag2 = ImportedBones[num2].bIsStatic;
				}
				if (flag)
				{
					switch (ropeNode.eColliderType)
					{
					case EColliderType.Capsule:
					{
						CapsuleCollider capsuleCollider = gameObject.AddComponent<CapsuleCollider>();
						capsuleCollider.material = RopePhysicsMaterial;
						capsuleCollider.center = GetLinkAxisOffset(fValue);
						capsuleCollider.radius = linkDiameter * 0.5f;
						capsuleCollider.height = num;
						capsuleCollider.direction = GetLinkAxisIndex();
						capsuleCollider.material = RopePhysicsMaterial;
						capsuleCollider.enabled = flag;
						break;
					}
					case EColliderType.Box:
					{
						BoxCollider boxCollider = gameObject.AddComponent<BoxCollider>();
						Vector3 v3CenterInOut = GetLinkAxisOffset(fValue);
						Vector3 v3SizeInOut = Vector3.zero;
						boxCollider.material = RopePhysicsMaterial;
						if (GetLinkBoxColliderCenterAndSize(num, linkDiameter, ref v3CenterInOut, ref v3SizeInOut))
						{
							boxCollider.center = v3CenterInOut;
							boxCollider.size = v3SizeInOut;
							boxCollider.enabled = flag;
						}
						else
						{
							boxCollider.enabled = false;
						}
						break;
					}
					}
				}
				if (gameObject.GetComponent<Collider>() != null)
				{
					gameObject.GetComponent<Collider>().enabled = !flag2;
				}
				Rigidbody obj = ((gameObject.GetComponent<Rigidbody>() != null) ? gameObject.GetComponent<Rigidbody>() : gameObject.AddComponent<Rigidbody>());
				obj.mass = LinkMass;
				obj.solverIterations = LinkSolverIterationCount;
				obj.isKinematic = flag2;
				gameObject.layer = RopeLayer;
				num2++;
			}
		}
	}

	public void SetupRopeJoints()
	{
		if (RopeNodes == null || RopeNodes.Count == 0 || Deleted || (RopeType == ERopeType.ImportBones && ImportedBones == null))
		{
			return;
		}
		foreach (RopeNode ropeNode6 in RopeNodes)
		{
			if (ropeNode6.segmentLinks == null)
			{
				return;
			}
		}
		int num = 0;
		Vector3[] array = new Vector3[TotalLinks];
		Quaternion[] array2 = new Quaternion[TotalLinks];
		Vector3 localPosition = ((RopeStart != null) ? RopeStart.transform.localPosition : Vector3.zero);
		Quaternion localRotation = ((RopeStart != null) ? RopeStart.transform.localRotation : Quaternion.identity);
		Vector3[] array3 = new Vector3[RopeNodes.Count];
		Quaternion[] array4 = new Quaternion[RopeNodes.Count];
		if (m_bRopeStartInitialOrientationInitialized && RopeStart != null)
		{
			RopeStart.transform.localPosition = m_v3InitialRopeStartLocalPos;
			RopeStart.transform.localRotation = m_qInitialRopeStartLocalRot;
		}
		for (int i = 0; i < RopeNodes.Count; i++)
		{
			RopeNode ropeNode = RopeNodes[i];
			if (ropeNode.bInitialOrientationInitialized && ropeNode.goNode != null)
			{
				array3[i] = ropeNode.goNode.transform.localPosition;
				array4[i] = ropeNode.goNode.transform.localRotation;
				ropeNode.goNode.transform.localPosition = ropeNode.v3InitialLocalPos;
				ropeNode.goNode.transform.localRotation = ropeNode.qInitialLocalRot;
			}
		}
		if (RopeType == ERopeType.Procedural || RopeType == ERopeType.LinkedObjects)
		{
			for (int j = 0; j < RopeNodes.Count; j++)
			{
				RopeNode ropeNode2 = RopeNodes[j];
				float z = ropeNode2.fLength / (float)ropeNode2.nNumLinks * (float)(ropeNode2.segmentLinks.Length - 1);
				for (int k = 0; k < ropeNode2.segmentLinks.Length; k++)
				{
					float t = (float)k / ((ropeNode2.segmentLinks.Length == 1) ? 1f : ((float)ropeNode2.segmentLinks.Length - 1f));
					array[num] = ropeNode2.segmentLinks[k].transform.position;
					array2[num] = ropeNode2.segmentLinks[k].transform.rotation;
					if (!ropeNode2.bIsCoil)
					{
						ropeNode2.segmentLinks[k].transform.position = Vector3.Lerp(new Vector3(0f, 0f, 0f), new Vector3(0f, 0f, z), t);
						ropeNode2.segmentLinks[k].transform.rotation = Quaternion.identity;
						if (RopeType == ERopeType.LinkedObjects)
						{
							ropeNode2.segmentLinks[k].transform.rotation *= GetLinkedObjectLocalRotation(LinkTwistAngleStart + LinkTwistAngleIncrement * (float)k);
						}
					}
					num++;
				}
			}
		}
		else if (RopeType == ERopeType.ImportBones)
		{
			for (int l = 0; l < ImportedBones.Length; l++)
			{
				array[l] = ImportedBones[l].goBone.transform.position;
				array2[l] = ImportedBones[l].goBone.transform.rotation;
				if (ImportedBones[l].tfNonBoneParent != null)
				{
					Transform parent = ImportedBones[l].goBone.transform.parent;
					ImportedBones[l].goBone.transform.parent = ImportedBones[l].tfNonBoneParent;
					ImportedBones[l].goBone.transform.localPosition = ImportedBones[l].v3OriginalLocalPos;
					ImportedBones[l].goBone.transform.localRotation = ImportedBones[l].qOriginalLocalRot;
					ImportedBones[l].goBone.transform.parent = parent;
					ImportedBones[l].goBone.transform.localScale = ImportedBones[l].v3OriginalLocalScale;
				}
			}
		}
		for (int m = 0; m < RopeNodes.Count; m++)
		{
			RopeNode ropeNode3 = RopeNodes[m];
			if (ropeNode3.bIsCoil)
			{
				continue;
			}
			ConfigurableJoint[] linkJoints = ropeNode3.linkJoints;
			foreach (ConfigurableJoint configurableJoint in linkJoints)
			{
				if ((bool)configurableJoint)
				{
					SetupJoint(configurableJoint);
				}
			}
			if ((RopeType == ERopeType.Procedural || RopeType == ERopeType.LinkedObjects) && ropeNode3.bInitialOrientationInitialized)
			{
				GameObject gameObject = ((m == m_nFirstNonCoilNode) ? RopeStart : RopeNodes[m - 1].goNode);
				GameObject goNode = RopeNodes[m].goNode;
				Vector3 vector = gameObject.transform.TransformDirection(ropeNode3.m_v3LocalDirectionForward);
				Vector3 upwards = gameObject.transform.TransformDirection(ropeNode3.m_v3LocalDirectionUp);
				ropeNode3.segmentLinks[0].transform.position = gameObject.transform.position;
				ropeNode3.segmentLinks[0].transform.rotation = Quaternion.LookRotation(vector, upwards);
				ropeNode3.segmentLinks[ropeNode3.segmentLinks.Length - 1].transform.position = goNode.transform.position - vector * (ropeNode3.fLength / (float)ropeNode3.nNumLinks);
				ropeNode3.segmentLinks[ropeNode3.segmentLinks.Length - 1].transform.rotation = Quaternion.LookRotation(vector, upwards);
				if (RopeType == ERopeType.LinkedObjects)
				{
					ropeNode3.segmentLinks[0].transform.rotation *= GetLinkedObjectLocalRotation(LinkTwistAngleStart);
					ropeNode3.segmentLinks[ropeNode3.segmentLinks.Length - 1].transform.rotation *= GetLinkedObjectLocalRotation(LinkTwistAngleStart + LinkTwistAngleIncrement * (float)(ropeNode3.segmentLinks.Length - 1));
				}
				if (ropeNode3.linkJoints[0] != null)
				{
					SetupJoint(ropeNode3.linkJoints[0]);
				}
				if (ropeNode3.linkJoints[ropeNode3.linkJoints.Length - 1] != null)
				{
					SetupJoint(ropeNode3.linkJoints[ropeNode3.linkJoints.Length - 1]);
				}
			}
		}
		num = 0;
		if (m_bRopeStartInitialOrientationInitialized && RopeStart != null)
		{
			RopeStart.transform.localPosition = localPosition;
			RopeStart.transform.localRotation = localRotation;
		}
		for (int num2 = 0; num2 < RopeNodes.Count; num2++)
		{
			RopeNode ropeNode4 = RopeNodes[num2];
			if (ropeNode4.bInitialOrientationInitialized && ropeNode4.goNode != null)
			{
				ropeNode4.goNode.transform.localPosition = array3[num2];
				ropeNode4.goNode.transform.localRotation = array4[num2];
			}
		}
		if (RopeType == ERopeType.Procedural || RopeType == ERopeType.LinkedObjects)
		{
			for (int num3 = 0; num3 < RopeNodes.Count; num3++)
			{
				RopeNode ropeNode5 = RopeNodes[num3];
				for (int num4 = 0; num4 < ropeNode5.segmentLinks.Length; num4++)
				{
					ropeNode5.segmentLinks[num4].transform.position = array[num];
					ropeNode5.segmentLinks[num4].transform.rotation = array2[num];
					num++;
				}
			}
		}
		else if (RopeType == ERopeType.ImportBones)
		{
			for (int num5 = 0; num5 < ImportedBones.Length; num5++)
			{
				ImportedBones[num5].goBone.transform.position = array[num5];
				ImportedBones[num5].goBone.transform.rotation = array2[num5];
			}
		}
	}

	public void CheckNeedsStartExitLockZ()
	{
		if (RopeType != 0)
		{
			return;
		}
		int num = 0;
		for (int i = 0; i < RopeNodes.Count; i++)
		{
			RopeNode ropeNode = RopeNodes[i];
			for (int j = 0; j < ropeNode.segmentLinks.Length; j++)
			{
				Transform transform = null;
				Transform transform2 = null;
				if (!FirstNodeIsCoil())
				{
					transform = ((i == m_nFirstNonCoilNode) ? RopeStart.transform : RopeNodes[i - 1].goNode.transform);
					transform2 = RopeNodes[i].goNode.transform;
				}
				if (transform != null && transform2 != null)
				{
					if (j == 0)
					{
						ropeNode.segmentLinks[j].transform.rotation = (LockStartEndInZAxis ? transform.rotation : Quaternion.LookRotation((transform2.position - transform.position).normalized));
						ropeNode.segmentLinks[j].transform.parent = (LockStartEndInZAxis ? transform : ropeNode.segmentLinks[j].transform.parent);
						ropeNode.segmentLinks[j].GetComponent<Rigidbody>().isKinematic = LockStartEndInZAxis || ropeNode.segmentLinks[j].GetComponent<Rigidbody>().isKinematic;
					}
					else if (j == ropeNode.segmentLinks.Length - 1)
					{
						ropeNode.segmentLinks[j].transform.position = (LockStartEndInZAxis ? (transform2.position - transform2.forward * LinkLengths[num]) : (transform2.position - (transform2.position - transform.position).normalized * LinkLengths[num]));
						ropeNode.segmentLinks[j].transform.rotation = (LockStartEndInZAxis ? transform2.rotation : Quaternion.LookRotation((transform2.position - transform.position).normalized));
						ropeNode.segmentLinks[j].transform.parent = (LockStartEndInZAxis ? transform2 : ropeNode.segmentLinks[j].transform.parent);
						ropeNode.segmentLinks[j].GetComponent<Rigidbody>().isKinematic = LockStartEndInZAxis || ropeNode.segmentLinks[j].GetComponent<Rigidbody>().isKinematic;
					}
				}
				num++;
			}
		}
	}

	public void FillLinkMeshIndicesRope(int nLinearLinkIndex, int nTotalLinks, ref int[] indices, bool bBreakable, bool bBrokenLink = false)
	{
		if (bBreakable)
		{
			int num = nLinearLinkIndex * RopeSegmentSides * 2;
			int num2 = nLinearLinkIndex * (RopeSegmentSides + 1) * 4 + (RopeSegmentSides + 1);
			int num3 = (RopeSegmentSides + 1) * 3;
			int num4 = ((!bBrokenLink && nLinearLinkIndex < nTotalLinks - 1) ? num3 : 0);
			for (int i = 0; i < RopeSegmentSides + 1; i++)
			{
				if (i < RopeSegmentSides)
				{
					int num5 = num2 + i;
					indices[num * 3 + 2] = num5;
					indices[num * 3 + 1] = num5 + num4 + (RopeSegmentSides + 1);
					indices[num * 3] = num5 + 1;
					indices[num * 3 + 5] = num5 + 1;
					indices[num * 3 + 4] = num5 + num4 + (RopeSegmentSides + 1);
					indices[num * 3 + 3] = num5 + num4 + (RopeSegmentSides + 1) + 1;
					num += 2;
				}
			}
			return;
		}
		int num6 = nLinearLinkIndex * RopeSegmentSides * 2;
		int num7 = nLinearLinkIndex * (RopeSegmentSides + 1) + (RopeSegmentSides + 1);
		for (int j = 0; j < RopeSegmentSides + 1; j++)
		{
			if (j < RopeSegmentSides)
			{
				int num8 = num7 + j;
				indices[num6 * 3 + 2] = num8;
				indices[num6 * 3 + 1] = num8 + RopeSegmentSides + 1;
				indices[num6 * 3] = num8 + 1;
				indices[num6 * 3 + 5] = num8 + 1;
				indices[num6 * 3 + 4] = num8 + RopeSegmentSides + 1;
				indices[num6 * 3 + 3] = num8 + 1 + RopeSegmentSides + 1;
				num6 += 2;
			}
		}
	}

	public void FillLinkMeshIndicesSections(int nLinearLinkIndex, int nTotalLinks, ref int[] indices, bool bBreakable, bool bBrokenLink = false)
	{
		if (bBreakable)
		{
			int num = nLinearLinkIndex * 2 * (RopeSegmentSides - 2);
			int num2 = nLinearLinkIndex * (RopeSegmentSides + 1) * 4;
			int num3 = (RopeSegmentSides + 1) * 2;
			for (int i = 0; i < RopeSegmentSides - 2; i++)
			{
				indices[num * 3] = num2;
				indices[num * 3 + 1] = num2 + (i + 2);
				indices[num * 3 + 2] = num2 + (i + 1);
				num++;
			}
			int num4 = ((!bBrokenLink && nLinearLinkIndex < nTotalLinks - 1) ? num3 : 0);
			for (int j = 0; j < RopeSegmentSides - 2; j++)
			{
				indices[num * 3 + 2] = num2 + (RopeSegmentSides + 1) * 3 + num4;
				indices[num * 3 + 1] = num2 + (RopeSegmentSides + 1) * 3 + num4 + (j + 2);
				indices[num * 3] = num2 + (RopeSegmentSides + 1) * 3 + num4 + (j + 1);
				num++;
			}
		}
		else
		{
			int num5 = 0;
			int num6 = 0;
			for (int k = 0; k < RopeSegmentSides - 2; k++)
			{
				indices[num5 * 3] = num6;
				indices[num5 * 3 + 1] = num6 + (k + 2);
				indices[num5 * 3 + 2] = num6 + (k + 1);
				num5++;
			}
			num6 = (TotalLinks + 1) * (RopeSegmentSides + 1) + (RopeSegmentSides + 1);
			for (int l = 0; l < RopeSegmentSides - 2; l++)
			{
				indices[num5 * 3 + 2] = num6;
				indices[num5 * 3 + 1] = num6 + (l + 2);
				indices[num5 * 3] = num6 + (l + 1);
				num5++;
			}
		}
	}

	public bool HasDynamicSegmentNodes()
	{
		if (RopeNodes == null)
		{
			return false;
		}
		if (RopeNodes.Count == 0)
		{
			return false;
		}
		foreach (RopeNode ropeNode in RopeNodes)
		{
			if ((bool)ropeNode.goNode && (bool)ropeNode.goNode.GetComponent<Rigidbody>() && !ropeNode.goNode.GetComponent<Rigidbody>().isKinematic)
			{
				return true;
			}
		}
		return false;
	}

	public void BeforeImportedBonesObjectRespawn()
	{
		if (ImportedBones == null)
		{
			return;
		}
		RopeBone[] importedBones = ImportedBones;
		foreach (RopeBone ropeBone in importedBones)
		{
			if (ropeBone.goBone != null)
			{
				ropeBone.goBone.transform.parent = ropeBone.tfParent;
			}
		}
	}

	public void AfterImportedBonesObjectRespawn()
	{
		if (ImportedBones == null)
		{
			return;
		}
		RopeBone[] importedBones = ImportedBones;
		foreach (RopeBone ropeBone in importedBones)
		{
			if (ropeBone.goBone != null)
			{
				ropeBone.goBone.transform.parent = (ropeBone.bIsStatic ? ropeBone.tfNonBoneParent : base.transform);
			}
		}
	}

	public void ExtendRope(ERopeExtensionMode eRopeExtensionMode, float fIncrement)
	{
		if (!IsExtensible)
		{
			UnityEngine.Debug.LogError("Rope can not be extended since the IsExtensible property has been marked as false");
			return;
		}
		if (eRopeExtensionMode == ERopeExtensionMode.CoilRotationIncrement && !FirstNodeIsCoil())
		{
			UnityEngine.Debug.LogError("Rope can not be extended through coil rotation since no coil is present");
			return;
		}
		float fLinearIncrement = ((eRopeExtensionMode == ERopeExtensionMode.LinearExtensionIncrement) ? fIncrement : 0f);
		float fCurrentCoilRopeRadius = m_fCurrentCoilRopeRadius;
		if (eRopeExtensionMode == ERopeExtensionMode.CoilRotationIncrement)
		{
			fLinearIncrement = m_fCurrentCoilRopeRadius * (fIncrement / 360f) * 2f * (float)Math.PI;
		}
		float num = ExtendRopeLinear(fLinearIncrement);
		float num2 = num * 360f / ((float)Math.PI * 2f * fCurrentCoilRopeRadius);
		if (!Mathf.Approximately(num, 0f) && FirstNodeIsCoil())
		{
			CoilObject.transform.Rotate(GetAxisVector(CoilAxisRight, 1f) * num2);
			SetupCoilBones(m_fCurrentCoilLength - num);
		}
	}

	public void RecomputeCoil()
	{
		SetupCoilBones(m_fCurrentCoilLength);
	}

	public GameObject BuildStaticMeshObject(out string strStatusMessage)
	{
		if (Application.isEditor && Application.isPlaying)
		{
			strStatusMessage = "Error: Rope can't be made static from the editor in play mode";
			return null;
		}
		if (RopeType == ERopeType.Procedural)
		{
			SkinnedMeshRenderer component = GetComponent<SkinnedMeshRenderer>();
			if (component == null)
			{
				strStatusMessage = "Error: Procedural rope has no skinned mesh renderer";
				return null;
			}
			Mesh sharedMesh = component.sharedMesh;
			Mesh mesh = new Mesh();
			int vertexCount = component.sharedMesh.vertexCount;
			int num = component.sharedMesh.GetTriangles(0).Length;
			int num2 = component.sharedMesh.GetTriangles(1).Length;
			Vector3[] vertices = sharedMesh.vertices;
			Vector2[] uv = sharedMesh.uv;
			Vector4[] tangents = sharedMesh.tangents;
			int[] triangles = sharedMesh.GetTriangles(0);
			int[] triangles2 = sharedMesh.GetTriangles(1);
			Vector3[] array = new Vector3[vertexCount];
			Vector2[] array2 = new Vector2[vertexCount];
			Vector4[] array3 = ((sharedMesh.tangents != null) ? new Vector4[sharedMesh.tangents.Length] : null);
			int[] array4 = new int[num];
			int[] array5 = new int[num2];
			BoneWeight[] boneWeights = sharedMesh.boneWeights;
			Matrix4x4[] bindposes = sharedMesh.bindposes;
			Transform[] bones = component.bones;
			Vector3 position = new Vector3(0f, 0f, 0f);
			for (int i = 0; i < vertexCount; i++)
			{
				BoneWeight boneWeight = boneWeights[i];
				array[i] = new Vector3(0f, 0f, 0f);
				if (Math.Abs(boneWeight.weight0) > 1E-05f)
				{
					Vector3 point = bindposes[boneWeight.boneIndex0].MultiplyPoint3x4(vertices[i]);
					array[i] += bones[boneWeight.boneIndex0].transform.localToWorldMatrix.MultiplyPoint3x4(point) * boneWeight.weight0;
				}
				if (Math.Abs(boneWeight.weight1) > 1E-05f)
				{
					Vector3 point = bindposes[boneWeight.boneIndex1].MultiplyPoint3x4(vertices[i]);
					array[i] += bones[boneWeight.boneIndex1].transform.localToWorldMatrix.MultiplyPoint3x4(point) * boneWeight.weight1;
				}
				if (Math.Abs(boneWeight.weight2) > 1E-05f)
				{
					Vector3 point = bindposes[boneWeight.boneIndex2].MultiplyPoint3x4(vertices[i]);
					array[i] += bones[boneWeight.boneIndex2].transform.localToWorldMatrix.MultiplyPoint3x4(point) * boneWeight.weight2;
				}
				if (Math.Abs(boneWeight.weight3) > 1E-05f)
				{
					Vector3 point = bindposes[boneWeight.boneIndex3].MultiplyPoint3x4(vertices[i]);
					array[i] += bones[boneWeight.boneIndex3].transform.localToWorldMatrix.MultiplyPoint3x4(point) * boneWeight.weight3;
				}
				position += array[i];
				array2[i] = uv[i];
				if (array3 != null && array3.Length == vertexCount)
				{
					array3[i] = tangents[i];
				}
			}
			if (vertexCount > 0)
			{
				position /= (float)vertexCount;
			}
			Vector3 position2 = base.transform.position;
			base.transform.position = position;
			for (int j = 0; j < vertexCount; j++)
			{
				array[j] = base.transform.InverseTransformPoint(array[j]);
			}
			base.transform.position = position2;
			for (int k = 0; k < num; k++)
			{
				array4[k] = triangles[k];
			}
			for (int l = 0; l < num2; l++)
			{
				array5[l] = triangles2[l];
			}
			mesh.vertices = array;
			mesh.uv = array2;
			mesh.subMeshCount = 2;
			mesh.SetTriangles(array4, 0);
			mesh.SetTriangles(array5, 1);
			mesh.RecalculateNormals();
			mesh.RecalculateBounds();
			if (array3 != null && array3.Length == vertexCount)
			{
				mesh.tangents = array3;
			}
			GameObject obj = new GameObject(base.gameObject.name + " (static)");
			obj.transform.position = position;
			obj.transform.rotation = base.transform.rotation;
			MeshFilter meshFilter = obj.AddComponent<MeshFilter>();
			MeshRenderer meshRenderer = obj.AddComponent<MeshRenderer>();
			meshFilter.sharedMesh = mesh;
			meshRenderer.sharedMaterials = new Material[2] { RopeMaterial, RopeSectionMaterial };
			obj.isStatic = true;
			MeshCollider meshCollider = obj.AddComponent<MeshCollider>();
			meshCollider.sharedMesh = mesh;
			meshCollider.convex = false;
			meshCollider.material = RopePhysicsMaterial;
			base.gameObject.SetActive(value: false);
			strStatusMessage = "Rope converted succesfully";
			return obj;
		}
		if (RopeType == ERopeType.LinkedObjects)
		{
			if (LinkObject == null)
			{
				strStatusMessage = "Error: LinkObject not specified. Can't continue.";
				return null;
			}
			Renderer component2 = LinkObject.GetComponent<Renderer>();
			MeshFilter component3 = LinkObject.GetComponent<MeshFilter>();
			if (component2 == null)
			{
				strStatusMessage = "Error: LinkObject has no Renderer. Can't continue.";
				return null;
			}
			if (component3 == null)
			{
				strStatusMessage = "Error: LinkObject has no Mesh Filter. Can't continue.";
				return null;
			}
			if (component3.sharedMesh == null)
			{
				strStatusMessage = "Error: LinkObject has no mesh. Can't continue.";
				return null;
			}
			Material[] array6 = new Material[component2.sharedMaterials.Length];
			for (int m = 0; m < component2.sharedMaterials.Length; m++)
			{
				array6[m] = component2.sharedMaterials[m];
			}
			List<CombineInstance> list = new List<CombineInstance>();
			for (int n = 0; n < RopeNodes.Count; n++)
			{
				RopeNode ropeNode = RopeNodes[n];
				for (int num3 = 0; num3 < ropeNode.segmentLinks.Length; num3++)
				{
					CombineInstance item = default(CombineInstance);
					item.mesh = component3.sharedMesh;
					item.transform = ropeNode.segmentLinks[num3].transform.localToWorldMatrix;
					list.Add(item);
				}
			}
			GameObject gameObject = new GameObject(base.gameObject.name + " (static)");
			MeshFilter meshFilter2 = gameObject.AddComponent<MeshFilter>();
			MeshRenderer meshRenderer2 = gameObject.AddComponent<MeshRenderer>();
			meshFilter2.sharedMesh = new Mesh();
			meshFilter2.sharedMesh.CombineMeshes(list.ToArray());
			meshRenderer2.sharedMaterials = array6;
			gameObject.isStatic = true;
			Vector3[] vertices2 = meshFilter2.sharedMesh.vertices;
			Vector3 zero = Vector3.zero;
			for (int num4 = 0; num4 < meshFilter2.sharedMesh.vertexCount; num4++)
			{
				vertices2[num4] = base.transform.TransformPoint(vertices2[num4]);
				zero += vertices2[num4];
			}
			if (meshFilter2.sharedMesh.vertexCount > 1)
			{
				zero /= (float)meshFilter2.sharedMesh.vertexCount;
			}
			gameObject.transform.position = zero;
			gameObject.transform.rotation = base.transform.rotation;
			for (int num5 = 0; num5 < meshFilter2.sharedMesh.vertexCount; num5++)
			{
				vertices2[num5] = gameObject.transform.InverseTransformPoint(vertices2[num5]);
			}
			meshFilter2.sharedMesh.vertices = vertices2;
			meshFilter2.sharedMesh.RecalculateBounds();
			MeshCollider meshCollider2 = gameObject.AddComponent<MeshCollider>();
			meshCollider2.sharedMesh = meshFilter2.sharedMesh;
			meshCollider2.convex = false;
			meshCollider2.material = RopePhysicsMaterial;
			base.gameObject.SetActive(value: false);
			strStatusMessage = "Rope converted succesfully";
			return gameObject;
		}
		if (RopeType == ERopeType.ImportBones)
		{
			strStatusMessage = "Error: ImportBones rope type not supported";
			return null;
		}
		strStatusMessage = "Error: Unknown rope type not supported";
		return null;
	}

	public void MoveNodeUp(int nNode)
	{
		if (RopeNodes != null && nNode > 0 && nNode < RopeNodes.Count)
		{
			RopeNode value = RopeNodes[nNode];
			RopeNodes[nNode] = RopeNodes[nNode - 1];
			RopeNodes[nNode - 1] = value;
		}
	}

	public void MoveNodeDown(int nNode)
	{
		if (RopeNodes != null && nNode >= 0 && nNode < RopeNodes.Count - 1)
		{
			RopeNode value = RopeNodes[nNode];
			RopeNodes[nNode] = RopeNodes[nNode + 1];
			RopeNodes[nNode + 1] = value;
		}
	}

	public void CreateNewNode(int nNode)
	{
		if (RopeNodes == null)
		{
			RopeNodes = new List<RopeNode>();
		}
		RopeNodes.Insert(nNode + 1, new RopeNode());
	}

	public void RemoveNode(int nNode)
	{
		if (RopeNodes != null)
		{
			RopeNodes.RemoveAt(nNode);
		}
	}

	public bool FirstNodeIsCoil()
	{
		if (RopeNodes != null && RopeNodes.Count > 0 && RopeNodes[0].bIsCoil)
		{
			return true;
		}
		return false;
	}

	private void CheckAddCoilNode()
	{
		if (RopeType != 0 || !IsExtensible || !HasACoil || !(CoilObject != null) || !RopeStart)
		{
			return;
		}
		if (!RopeNodes[0].bIsCoil)
		{
			RopeNodes.Insert(0, new RopeNode());
			if (CoilNumBones < 1)
			{
				CoilNumBones = 1;
			}
			RopeNodes[0].goNode = CoilObject;
			RopeNodes[0].fLength = ExtensibleLength;
			RopeNodes[0].fTotalLength = RopeNodes[0].fLength;
			RopeNodes[0].nNumLinks = CoilNumBones;
			RopeNodes[0].nTotalLinks = RopeNodes[0].nNumLinks;
			RopeNodes[0].eColliderType = EColliderType.None;
			RopeNodes[0].nColliderSkip = 0;
			RopeNodes[0].bFold = true;
			RopeNodes[0].bIsCoil = true;
			m_afCoilBoneRadiuses = new float[RopeNodes[0].nTotalLinks];
			m_afCoilBoneAngles = new float[RopeNodes[0].nTotalLinks];
			m_afCoilBoneX = new float[RopeNodes[0].nTotalLinks];
		}
		m_nFirstNonCoilNode = 1;
	}

	private void CheckDelCoilNode()
	{
		if (RopeNodes[0].bIsCoil)
		{
			RopeNodes.RemoveAt(0);
			m_afCoilBoneRadiuses = null;
			m_afCoilBoneAngles = null;
			m_afCoilBoneX = null;
		}
		m_nFirstNonCoilNode = 0;
	}

	private void CreateRopeJoints(bool bCheckIfBroken = false)
	{
		if (RopeNodes == null || RopeNodes.Count == 0 || Deleted || (RopeType == ERopeType.ImportBones && (ImportedBones == null || ImportedBones.Length == 0)))
		{
			return;
		}
		foreach (RopeNode ropeNode6 in RopeNodes)
		{
			if (ropeNode6.segmentLinks == null)
			{
				return;
			}
		}
		if (RopeStart != null && RopeStart.GetComponent<Rigidbody>() == null)
		{
			RopeStart.AddComponent<Rigidbody>();
			RopeStart.GetComponent<Rigidbody>().isKinematic = true;
		}
		for (int i = 0; i < RopeNodes.Count; i++)
		{
			RopeNode ropeNode = RopeNodes[i];
			if (ropeNode.goNode != null && ropeNode.goNode.GetComponent<Rigidbody>() == null)
			{
				ropeNode.goNode.AddComponent<Rigidbody>();
				ropeNode.goNode.GetComponent<Rigidbody>().isKinematic = true;
			}
		}
		int num = 0;
		int num2 = 0;
		Vector3[] array = new Vector3[TotalLinks];
		Quaternion[] array2 = new Quaternion[TotalLinks];
		Vector3 localPosition = ((RopeStart != null) ? RopeStart.transform.localPosition : Vector3.zero);
		Quaternion localRotation = ((RopeStart != null) ? RopeStart.transform.localRotation : Quaternion.identity);
		Vector3[] array3 = new Vector3[RopeNodes.Count];
		Quaternion[] array4 = new Quaternion[RopeNodes.Count];
		if (m_bRopeStartInitialOrientationInitialized && RopeStart != null)
		{
			RopeStart.transform.localPosition = m_v3InitialRopeStartLocalPos;
			RopeStart.transform.localRotation = m_qInitialRopeStartLocalRot;
		}
		for (int j = 0; j < RopeNodes.Count; j++)
		{
			RopeNode ropeNode2 = RopeNodes[j];
			if (ropeNode2.bInitialOrientationInitialized && ropeNode2.goNode != null)
			{
				array3[j] = ropeNode2.goNode.transform.localPosition;
				array4[j] = ropeNode2.goNode.transform.localRotation;
				ropeNode2.goNode.transform.localPosition = ropeNode2.v3InitialLocalPos;
				ropeNode2.goNode.transform.localRotation = ropeNode2.qInitialLocalRot;
			}
		}
		for (int k = 0; k < RopeNodes.Count; k++)
		{
			RopeNode ropeNode3 = RopeNodes[k];
			GameObject gameObject = null;
			GameObject gameObject2 = null;
			if (FirstNodeIsCoil() && k == 0)
			{
				gameObject = CoilObject;
				gameObject2 = RopeStart;
			}
			else if (RopeType == ERopeType.Procedural || RopeType == ERopeType.LinkedObjects)
			{
				gameObject = ((k == m_nFirstNonCoilNode) ? RopeStart : RopeNodes[k - 1].goNode);
				gameObject2 = RopeNodes[k].goNode;
				float num3 = Vector3.Distance(gameObject.transform.position, gameObject2.transform.position);
				if (num3 > RopeNodes[k].fLength)
				{
					UnityEngine.Debug.LogError("Rope \"" + base.name + "\" segment " + k + " has a length shorter than the distance between the start node \"" + gameObject.name + "\" and end node \"" + gameObject2.name + "\".\nSegment length is set to " + RopeNodes[k].fLength + " and node separation is " + num3 + ". Segment length should be larger than " + num3 + " or this segment will have buggy physics.");
				}
			}
			float num4 = ropeNode3.fLength / (float)ropeNode3.nNumLinks;
			float z = num4 * (float)(ropeNode3.segmentLinks.Length - 1);
			for (int l = 0; l < ropeNode3.segmentLinks.Length; l++)
			{
				if (RopeType == ERopeType.Procedural || RopeType == ERopeType.LinkedObjects)
				{
					float t = (float)l / ((ropeNode3.segmentLinks.Length == 1) ? 1f : ((float)ropeNode3.segmentLinks.Length - 1f));
					if (l == 0)
					{
						ropeNode3.m_v3LocalDirectionUp = gameObject.transform.InverseTransformDirection(ropeNode3.segmentLinks[l].transform.up);
					}
					Vector3 normalized = (gameObject2.transform.position - gameObject.transform.position).normalized;
					if (ropeNode3.nTotalLinks > ropeNode3.nNumLinks && !ropeNode3.m_bExtensionInitialized)
					{
						ropeNode3.segmentLinks[l].transform.rotation = Quaternion.LookRotation((gameObject2.transform.position - gameObject.transform.position).normalized);
						if (l < ropeNode3.m_nExtensionLinkIn)
						{
							ropeNode3.segmentLinks[l].transform.position = gameObject.transform.position;
							ropeNode3.segmentLinks[l].transform.parent = ((k > m_nFirstNonCoilNode) ? RopeNodes[k - 1].goNode.transform : RopeStart.transform);
							ropeNode3.segmentLinks[l].GetComponent<Rigidbody>().isKinematic = true;
							UltimateRopeLink component = ropeNode3.segmentLinks[l].GetComponent<UltimateRopeLink>();
							if (component != null)
							{
								component.ExtensibleKinematic = true;
							}
						}
						else
						{
							float t2 = (float)(l - ropeNode3.m_nExtensionLinkIn) / ((ropeNode3.nNumLinks > 1) ? ((float)(ropeNode3.nNumLinks - 1)) : 1f);
							ropeNode3.segmentLinks[l].transform.position = Vector3.Lerp(gameObject.transform.position + normalized * num4, gameObject2.transform.position - normalized * num4, t2);
							ropeNode3.segmentLinks[l].GetComponent<Rigidbody>().isKinematic = false;
							UltimateRopeLink component2 = ropeNode3.segmentLinks[l].GetComponent<UltimateRopeLink>();
							if (component2 != null)
							{
								component2.ExtensibleKinematic = false;
							}
						}
					}
					array[num2] = ropeNode3.segmentLinks[l].transform.position;
					array2[num2] = ropeNode3.segmentLinks[l].transform.rotation;
					ropeNode3.segmentLinks[l].transform.position = Vector3.Lerp(new Vector3(0f, 0f, 0f), new Vector3(0f, 0f, z), t);
					ropeNode3.segmentLinks[l].transform.rotation = Quaternion.identity;
					if (RopeType == ERopeType.LinkedObjects)
					{
						ropeNode3.segmentLinks[l].transform.rotation *= GetLinkedObjectLocalRotation(LinkTwistAngleStart + LinkTwistAngleIncrement * (float)l);
					}
					num2++;
				}
				else if (RopeType == ERopeType.ImportBones)
				{
					array[l] = ImportedBones[l].goBone.transform.position;
					array2[l] = ImportedBones[l].goBone.transform.rotation;
					if (ImportedBones[l].tfNonBoneParent != null)
					{
						Transform parent = ImportedBones[l].goBone.transform.parent;
						ImportedBones[l].goBone.transform.parent = ImportedBones[l].tfNonBoneParent;
						ImportedBones[l].goBone.transform.localPosition = ImportedBones[l].v3OriginalLocalPos;
						ImportedBones[l].goBone.transform.localRotation = ImportedBones[l].qOriginalLocalRot;
						ImportedBones[l].goBone.transform.parent = parent;
						ImportedBones[l].goBone.transform.localScale = ImportedBones[l].v3OriginalLocalScale;
					}
				}
				bool flag = !bCheckIfBroken || !ropeNode3.linkJointBreaksProcessed[l];
				if (RopeType == ERopeType.ImportBones)
				{
					bool flag2 = true;
					if (l > 0)
					{
						flag2 = !ImportedBones[l - 1].goBone.GetComponent<Rigidbody>().isKinematic;
					}
					if (!flag2 && ImportedBones[l].goBone.GetComponent<Rigidbody>().isKinematic)
					{
						flag = false;
					}
				}
				if (flag && l > 0 && !ropeNode3.bIsCoil)
				{
					ropeNode3.linkJoints[l] = CreateJoint(ropeNode3.segmentLinks[l], ropeNode3.segmentLinks[l - 1], ropeNode3.segmentLinks[l].transform.position);
					ropeNode3.linkJointBreaksProcessed[l] = false;
				}
				else
				{
					ropeNode3.linkJoints[l] = null;
				}
			}
			float num5 = ((RopeType == ERopeType.ImportBones) ? 0f : (((gameObject2.transform.position - gameObject.transform.position).magnitude - num4) / (gameObject2.transform.position - gameObject.transform.position).magnitude));
			if (num5 < 0f)
			{
				num5 = 0f;
			}
			for (int m = 0; m < ropeNode3.segmentLinks.Length; m++)
			{
				if (RopeType == ERopeType.Procedural || RopeType == ERopeType.LinkedObjects)
				{
					float num6 = (float)m / ((ropeNode3.segmentLinks.Length == 1) ? 1f : ((float)ropeNode3.segmentLinks.Length - 1f));
					if (Vector3.Distance(gameObject.transform.position, gameObject2.transform.position) < 0.001f)
					{
						ropeNode3.segmentLinks[m].transform.position = gameObject.transform.position;
						ropeNode3.segmentLinks[m].transform.rotation = gameObject.transform.rotation;
					}
					else
					{
						ropeNode3.segmentLinks[m].transform.position = Vector3.Lerp(gameObject.transform.position, gameObject2.transform.position, num6 * num5);
						ropeNode3.segmentLinks[m].transform.rotation = Quaternion.LookRotation((gameObject2.transform.position - gameObject.transform.position).normalized);
					}
					if (RopeType == ERopeType.LinkedObjects)
					{
						ropeNode3.segmentLinks[m].transform.rotation *= GetLinkedObjectLocalRotation(LinkTwistAngleStart + LinkTwistAngleIncrement * (float)m);
					}
				}
				num++;
			}
			if (RopeType == ERopeType.Procedural || RopeType == ERopeType.LinkedObjects)
			{
				if (!ropeNode3.bIsCoil)
				{
					if (!bCheckIfBroken || !ropeNode3.linkJointBreaksProcessed[0])
					{
						if (ropeNode3.nTotalLinks == ropeNode3.nNumLinks)
						{
							ropeNode3.linkJoints[0] = CreateJoint(ropeNode3.segmentLinks[0], gameObject, gameObject.transform.position);
							ropeNode3.linkJointBreaksProcessed[0] = false;
						}
						else
						{
							ropeNode3.linkJoints[0] = null;
							ropeNode3.linkJointBreaksProcessed[0] = true;
						}
					}
					else
					{
						ropeNode3.linkJoints[0] = null;
					}
					if (!bCheckIfBroken || !ropeNode3.linkJointBreaksProcessed[ropeNode3.segmentLinks.Length])
					{
						ropeNode3.linkJoints[ropeNode3.segmentLinks.Length] = CreateJoint(ropeNode3.segmentLinks[ropeNode3.segmentLinks.Length - 1], gameObject2, gameObject2.transform.position);
						ropeNode3.linkJointBreaksProcessed[ropeNode3.segmentLinks.Length] = false;
					}
					else
					{
						ropeNode3.linkJoints[ropeNode3.segmentLinks.Length] = null;
					}
				}
			}
			else if (RopeType == ERopeType.ImportBones)
			{
				ropeNode3.linkJointBreaksProcessed[0] = true;
			}
			if (ropeNode3.nTotalLinks > ropeNode3.nNumLinks && !ropeNode3.m_bExtensionInitialized)
			{
				ropeNode3.m_bExtensionInitialized = true;
			}
		}
		if (m_bRopeStartInitialOrientationInitialized && RopeStart != null)
		{
			RopeStart.transform.localPosition = localPosition;
			RopeStart.transform.localRotation = localRotation;
		}
		for (int n = 0; n < RopeNodes.Count; n++)
		{
			RopeNode ropeNode4 = RopeNodes[n];
			if (ropeNode4.bInitialOrientationInitialized && ropeNode4.goNode != null)
			{
				ropeNode4.goNode.transform.localPosition = array3[n];
				ropeNode4.goNode.transform.localRotation = array4[n];
			}
		}
		num2 = 0;
		if (RopeType == ERopeType.Procedural || RopeType == ERopeType.LinkedObjects)
		{
			for (int num7 = 0; num7 < RopeNodes.Count; num7++)
			{
				RopeNode ropeNode5 = RopeNodes[num7];
				for (int num8 = 0; num8 < ropeNode5.segmentLinks.Length; num8++)
				{
					ropeNode5.segmentLinks[num8].transform.position = array[num2];
					ropeNode5.segmentLinks[num8].transform.rotation = array2[num2];
					num2++;
				}
			}
		}
		else if (RopeType == ERopeType.ImportBones)
		{
			for (int num9 = 0; num9 < ImportedBones.Length; num9++)
			{
				ImportedBones[num9].goBone.transform.position = array[num9];
				ImportedBones[num9].goBone.transform.rotation = array2[num9];
			}
		}
		CheckNeedsStartExitLockZ();
	}

	private ConfigurableJoint CreateJoint(GameObject goObject, GameObject goConnectedTo, Vector3 v3Pivot)
	{
		ConfigurableJoint configurableJoint = goObject.AddComponent<ConfigurableJoint>();
		SetupJoint(configurableJoint);
		configurableJoint.connectedBody = goConnectedTo.GetComponent<Rigidbody>();
		configurableJoint.anchor = goObject.transform.InverseTransformPoint(v3Pivot);
		return configurableJoint;
	}

	private void SetupJoint(ConfigurableJoint joint)
	{
		SoftJointLimit softJointLimit = default(SoftJointLimit);
		softJointLimit.contactDistance = 0f;
		softJointLimit.bounciness = 0f;
		JointDrive jointDrive = default(JointDrive);
		jointDrive.positionSpring = LinkJointSpringValue;
		jointDrive.positionDamper = LinkJointDamperValue;
		jointDrive.maximumForce = LinkJointMaxForceValue;
		joint.axis = Vector3.right;
		joint.secondaryAxis = Vector3.up;
		joint.breakForce = LinkJointBreakForce;
		joint.breakTorque = LinkJointBreakTorque;
		joint.xMotion = ConfigurableJointMotion.Locked;
		joint.yMotion = ConfigurableJointMotion.Locked;
		joint.zMotion = ConfigurableJointMotion.Locked;
		joint.angularXMotion = ((!Mathf.Approximately(LinkJointAngularXLimit, 0f)) ? ConfigurableJointMotion.Limited : ConfigurableJointMotion.Locked);
		joint.angularYMotion = ((!Mathf.Approximately(LinkJointAngularYLimit, 0f)) ? ConfigurableJointMotion.Limited : ConfigurableJointMotion.Locked);
		joint.angularZMotion = ((!Mathf.Approximately(LinkJointAngularZLimit, 0f)) ? ConfigurableJointMotion.Limited : ConfigurableJointMotion.Locked);
		softJointLimit.limit = 0f - LinkJointAngularXLimit;
		joint.lowAngularXLimit = softJointLimit;
		softJointLimit.limit = LinkJointAngularXLimit;
		joint.highAngularXLimit = softJointLimit;
		softJointLimit.limit = LinkJointAngularYLimit;
		joint.angularYLimit = softJointLimit;
		softJointLimit.limit = LinkJointAngularZLimit;
		joint.angularZLimit = softJointLimit;
		joint.angularXDrive = jointDrive;
		joint.angularYZDrive = jointDrive;
	}

	private Vector3 GetAxisVector(EAxis eAxis, float fLength)
	{
		return eAxis switch
		{
			EAxis.X => new Vector3(fLength, 0f, 0f), 
			EAxis.Y => new Vector3(0f, fLength, 0f), 
			EAxis.Z => new Vector3(0f, 0f, fLength), 
			EAxis.MinusX => new Vector3(0f - fLength, 0f, 0f), 
			EAxis.MinusY => new Vector3(0f, 0f - fLength, 0f), 
			EAxis.MinusZ => new Vector3(0f, 0f, 0f - fLength), 
			_ => Vector3.zero, 
		};
	}

	private float ExtendRopeLinear(float fLinearIncrement)
	{
		if (fLinearIncrement > 0f && Mathf.Approximately(m_fCurrentExtension, ExtensibleLength))
		{
			return 0f;
		}
		if (fLinearIncrement < 0f && Mathf.Approximately(m_fCurrentExtension, 0f))
		{
			return 0f;
		}
		RopeNode ropeNode = RopeNodes[RopeNodes.Count - 1];
		bool flag = false;
		float fCurrentExtension = m_fCurrentExtension;
		float num = ropeNode.fLength / (float)ropeNode.nNumLinks;
		Transform transform = ((RopeNodes.Count - 1 > m_nFirstNonCoilNode) ? RopeNodes[RopeNodes.Count - 2].goNode.transform : RopeStart.transform);
		Vector3 vector = transform.TransformDirection(ropeNode.m_v3LocalDirectionForward);
		if (fLinearIncrement < 0f)
		{
			while (fLinearIncrement < 0f && ropeNode.m_nExtensionLinkIn > 0 && ropeNode.m_nExtensionLinkIn < ropeNode.segmentLinks.Length - 1 && !flag)
			{
				float num2 = Mathf.Max((0f - num) * 0.5f, fLinearIncrement);
				if (Mathf.Abs(num2) > m_fCurrentExtension)
				{
					num2 = 0f - m_fCurrentExtension;
					flag = true;
				}
				ropeNode.m_fExtensionRemainderIn += num2;
				if (ropeNode.m_fExtensionRemainderIn < 0f - num)
				{
					num2 += Mathf.Abs(ropeNode.m_fExtensionRemainderIn - (0f - num));
					ropeNode.segmentLinks[ropeNode.m_nExtensionLinkIn].transform.position = ropeNode.segmentLinks[ropeNode.m_nExtensionLinkIn - 1].transform.position;
					ropeNode.segmentLinks[ropeNode.m_nExtensionLinkIn].transform.rotation = ropeNode.segmentLinks[ropeNode.m_nExtensionLinkIn - 1].transform.rotation;
					SetExtensibleLinkToKinematic(ropeNode.segmentLinks[ropeNode.m_nExtensionLinkIn], bKinematic: true);
					ropeNode.segmentLinks[ropeNode.m_nExtensionLinkIn].transform.parent = transform;
					ropeNode.m_nExtensionLinkIn++;
					ropeNode.m_nExtensionLinkOut = ropeNode.m_nExtensionLinkIn - 1;
					ropeNode.m_fExtensionRemainderIn = 0f;
					ropeNode.m_fExtensionRemainderOut = 0f;
				}
				else
				{
					float t = (0f - ropeNode.m_fExtensionRemainderIn) / num;
					ropeNode.segmentLinks[ropeNode.m_nExtensionLinkIn].transform.position = transform.position + vector * (num + ropeNode.m_fExtensionRemainderIn);
					ropeNode.segmentLinks[ropeNode.m_nExtensionLinkIn].transform.rotation = Quaternion.Slerp(ropeNode.segmentLinks[ropeNode.m_nExtensionLinkIn].transform.rotation, ropeNode.segmentLinks[ropeNode.m_nExtensionLinkIn - 1].transform.rotation, t);
					SetExtensibleLinkToKinematic(ropeNode.segmentLinks[ropeNode.m_nExtensionLinkIn], bKinematic: true);
					ropeNode.segmentLinks[ropeNode.m_nExtensionLinkIn].transform.parent = transform;
					ropeNode.m_nExtensionLinkOut = ropeNode.m_nExtensionLinkIn;
					ropeNode.m_fExtensionRemainderOut = num + ropeNode.m_fExtensionRemainderIn;
				}
				fLinearIncrement -= num2;
				m_fCurrentExtension += num2;
			}
		}
		else if (fLinearIncrement > 0f)
		{
			while (fLinearIncrement > 0f && ropeNode.m_nExtensionLinkOut > 0 && ropeNode.m_nExtensionLinkOut < ropeNode.segmentLinks.Length - 1 && !flag)
			{
				float num3 = Mathf.Min(num * 0.5f, fLinearIncrement);
				if (m_fCurrentExtension + num3 > ExtensibleLength)
				{
					num3 = ExtensibleLength - m_fCurrentExtension;
					flag = true;
				}
				ropeNode.m_fExtensionRemainderOut += num3;
				if (ropeNode.m_fExtensionRemainderOut > num)
				{
					num3 -= ropeNode.m_fExtensionRemainderOut - num;
					SetExtensibleLinkToKinematic(ropeNode.segmentLinks[ropeNode.m_nExtensionLinkOut], bKinematic: false);
					ropeNode.segmentLinks[ropeNode.m_nExtensionLinkOut].transform.parent = base.transform;
					ropeNode.m_nExtensionLinkOut--;
					ropeNode.m_nExtensionLinkIn = ropeNode.m_nExtensionLinkOut + 1;
					ropeNode.m_fExtensionRemainderIn = 0f;
					ropeNode.m_fExtensionRemainderOut = 0f;
				}
				else
				{
					ropeNode.segmentLinks[ropeNode.m_nExtensionLinkOut].transform.position = transform.position + vector * ropeNode.m_fExtensionRemainderOut;
					ropeNode.m_nExtensionLinkIn = ropeNode.m_nExtensionLinkOut;
					ropeNode.m_fExtensionRemainderIn = 0f - num + ropeNode.m_fExtensionRemainderOut;
				}
				fLinearIncrement -= num3;
				m_fCurrentExtension += num3;
			}
		}
		return m_fCurrentExtension - fCurrentExtension;
	}

	private void SetExtensibleLinkToKinematic(GameObject link, bool bKinematic)
	{
		if (link.GetComponent<Rigidbody>().isKinematic == bKinematic)
		{
			return;
		}
		link.GetComponent<Rigidbody>().isKinematic = bKinematic;
		if (link.GetComponent<Collider>() != null)
		{
			link.GetComponent<Collider>().enabled = !bKinematic;
		}
		UltimateRopeLink component = link.GetComponent<UltimateRopeLink>();
		if (component != null)
		{
			component.ExtensibleKinematic = bKinematic;
		}
		ConfigurableJoint component2 = link.GetComponent<ConfigurableJoint>();
		if ((bool)component2)
		{
			if (bKinematic)
			{
				component2.breakForce = float.PositiveInfinity;
				component2.breakTorque = float.PositiveInfinity;
			}
			else
			{
				component2.breakForce = LinkJointBreakForce;
				component2.breakTorque = LinkJointBreakTorque;
			}
		}
	}

	private void SetupCoilBones(float fCoilLength)
	{
		float num = 0f;
		float num2 = CoilWidth * -0.5f + RopeDiameter * 0.5f;
		float num3 = CoilDiameter * 0.5f + RopeDiameter * 0.5f;
		float num4 = 0f;
		float num5 = 1f;
		float num6 = -1f;
		float num7 = Vector3.Distance(CoilObject.transform.position, RopeStart.transform.position) + CoilDiameter;
		float num8 = fCoilLength + num7;
		float num9 = 0f;
		float num10 = 0f;
		float num11 = 0f;
		int num12 = 0;
		RopeNode ropeNode = RopeNodes[0];
		Vector3 localPosition = ropeNode.goNode.transform.localPosition;
		Quaternion localRotation = ropeNode.goNode.transform.localRotation;
		Vector3 localScale = ropeNode.goNode.transform.localScale;
		if (ropeNode.bInitialOrientationInitialized)
		{
			ropeNode.goNode.transform.localPosition = ropeNode.v3InitialLocalPos;
			ropeNode.goNode.transform.localRotation = ropeNode.qInitialLocalRot;
			ropeNode.goNode.transform.localScale = ropeNode.v3InitialLocalScale;
		}
		Vector3 vector = -CoilObject.transform.TransformDirection(GetAxisVector(CoilAxisRight, 1f));
		Vector3 vector2 = CoilObject.transform.TransformDirection(GetAxisVector(CoilAxisUp, 1f));
		Quaternion rotation = Quaternion.LookRotation(Vector3.Cross(vector2, vector), vector2);
		ropeNode.goNode.transform.localPosition = localPosition;
		ropeNode.goNode.transform.localRotation = localRotation;
		ropeNode.goNode.transform.localScale = localScale;
		float num13 = (RopeNodes[0].fLength + num7) / (float)RopeNodes[0].nNumLinks;
		for (int i = 0; i < RopeNodes[0].segmentLinks.Length; i++)
		{
			m_afCoilBoneRadiuses[i] = num3;
			m_afCoilBoneAngles[i] = num4;
			m_afCoilBoneX[i] = num2;
			num9 = (CoilObject.transform.position + vector2 * num3 + vector * num2 - RopeStart.transform.position).magnitude;
			num += num13;
			num12++;
			float num14 = num8 - num9;
			if (num > num14)
			{
				num11 = num - num14;
				num10 = num4 - num11 / (num3 * (float)Math.PI * 2f) * 360f;
				m_fCurrentCoilRopeRadius = num3;
				m_fCurrentCoilTurnsLeft = num4 / 360f;
				break;
			}
			float num15 = num13 / (num3 * (float)Math.PI * 2f) * 360f;
			float num16 = num3 * (float)Math.PI * 2f / num13;
			num4 += num15;
			if (num6 > 0f)
			{
				num3 += RopeDiameter / num16;
				num6 -= num15;
			}
			else
			{
				num2 += RopeDiameter * num5 / num16;
			}
			if (num5 > 0f && num2 > CoilWidth * 0.5f - RopeDiameter * 0.5f)
			{
				num2 = CoilWidth * 0.5f - RopeDiameter * 0.5f;
				num6 = 360f;
				num5 = -1f;
			}
			if (num5 < 0f && num2 < CoilWidth * -0.5f + RopeDiameter * 0.5f)
			{
				num2 = CoilWidth * -0.5f + RopeDiameter * 0.5f;
				num6 = 360f;
				num5 = 1f;
			}
		}
		for (int j = 0; j < num12; j++)
		{
			m_afCoilBoneAngles[j] -= num10;
			RopeNodes[0].segmentLinks[j].transform.position = CoilObject.transform.position + vector2 * m_afCoilBoneRadiuses[j];
			RopeNodes[0].segmentLinks[j].transform.rotation = rotation;
			RopeNodes[0].segmentLinks[j].transform.RotateAround(CoilObject.transform.position, -vector, m_afCoilBoneAngles[j]);
			RopeNodes[0].segmentLinks[j].transform.position += vector * m_afCoilBoneX[j];
		}
		Vector3 vector3 = CoilObject.transform.position + vector2 * num3 + vector * num2;
		Vector3 normalized = (RopeStart.transform.position - vector3).normalized;
		num = (RopeNodes[0].segmentLinks[num12 - 1].transform.position - vector3).magnitude;
		float magnitude = (RopeStart.transform.position - vector3).magnitude;
		Quaternion rotation2 = Quaternion.LookRotation((RopeStart.transform.position - CoilObject.transform.position).normalized, vector2);
		for (int k = num12; k < RopeNodes[0].segmentLinks.Length; k++)
		{
			num += num13;
			if (num < magnitude)
			{
				RopeNodes[0].segmentLinks[k].transform.position = vector3 + normalized * num;
				RopeNodes[0].segmentLinks[k].transform.rotation = rotation2;
			}
			else
			{
				RopeNodes[0].segmentLinks[k].transform.position = RopeStart.transform.position;
				RopeNodes[0].segmentLinks[k].transform.rotation = rotation2;
			}
		}
		m_fCurrentCoilLength = fCoilLength;
	}

	private Quaternion GetLinkedObjectLocalRotation(float fTwistAngle = 0f)
	{
		if (LinkAxis == EAxis.X)
		{
			return Quaternion.LookRotation(Vector3.right) * Quaternion.AngleAxis(fTwistAngle, Vector3.right);
		}
		if (LinkAxis == EAxis.Y)
		{
			return Quaternion.LookRotation(Vector3.up) * Quaternion.AngleAxis(fTwistAngle, Vector3.up);
		}
		if (LinkAxis == EAxis.Z)
		{
			return Quaternion.LookRotation(Vector3.forward) * Quaternion.AngleAxis(fTwistAngle, Vector3.forward);
		}
		if (LinkAxis == EAxis.MinusX)
		{
			return Quaternion.LookRotation(-Vector3.right) * Quaternion.AngleAxis(fTwistAngle, -Vector3.right);
		}
		if (LinkAxis == EAxis.MinusY)
		{
			return Quaternion.LookRotation(-Vector3.up) * Quaternion.AngleAxis(fTwistAngle, -Vector3.up);
		}
		if (LinkAxis == EAxis.MinusZ)
		{
			return Quaternion.LookRotation(-Vector3.forward) * Quaternion.AngleAxis(fTwistAngle, -Vector3.forward);
		}
		return Quaternion.identity;
	}

	private float GetLinkedObjectScale(float fSegmentLength, int nNumLinks)
	{
		if (LinkObject == null)
		{
			return 0f;
		}
		MeshFilter component = LinkObject.GetComponent<MeshFilter>();
		if (component == null)
		{
			return 0f;
		}
		float num = 0f;
		if (RopeType == ERopeType.LinkedObjects)
		{
			if (LinkAxis == EAxis.X || LinkAxis == EAxis.MinusX)
			{
				num = component.sharedMesh.bounds.size.x;
			}
			if (LinkAxis == EAxis.Y || LinkAxis == EAxis.MinusY)
			{
				num = component.sharedMesh.bounds.size.y;
			}
			if (LinkAxis == EAxis.Z || LinkAxis == EAxis.MinusZ)
			{
				num = component.sharedMesh.bounds.size.z;
			}
		}
		return (fSegmentLength / (float)nNumLinks - LinkOffsetObject * (fSegmentLength / (float)(nNumLinks - 1))) / num;
	}

	private float GetLinkDiameter()
	{
		if (RopeType == ERopeType.Procedural)
		{
			return RopeDiameter;
		}
		if (RopeType == ERopeType.LinkedObjects)
		{
			if (LinkObject == null)
			{
				return 0f;
			}
			MeshFilter component = LinkObject.GetComponent<MeshFilter>();
			if (component == null)
			{
				return 0f;
			}
			float result = 0f;
			if (RopeType == ERopeType.LinkedObjects)
			{
				if (LinkAxis == EAxis.X || LinkAxis == EAxis.MinusX)
				{
					result = Mathf.Max(component.sharedMesh.bounds.size.y, component.sharedMesh.bounds.size.z);
				}
				if (LinkAxis == EAxis.Y || LinkAxis == EAxis.MinusY)
				{
					result = Mathf.Max(component.sharedMesh.bounds.size.x, component.sharedMesh.bounds.size.z);
				}
				if (LinkAxis == EAxis.Z || LinkAxis == EAxis.MinusZ)
				{
					result = Mathf.Max(component.sharedMesh.bounds.size.x, component.sharedMesh.bounds.size.y);
				}
			}
			return result;
		}
		if (RopeType == ERopeType.ImportBones)
		{
			return BoneColliderDiameter;
		}
		return 0f;
	}

	private Vector3 GetLinkAxisOffset(float fValue)
	{
		EAxis eAxis = EAxis.Z;
		if (RopeType == ERopeType.LinkedObjects)
		{
			eAxis = LinkAxis;
		}
		if (RopeType == ERopeType.ImportBones)
		{
			eAxis = BoneAxis;
		}
		return eAxis switch
		{
			EAxis.X => new Vector3(fValue, 0f, 0f), 
			EAxis.Y => new Vector3(0f, fValue, 0f), 
			EAxis.Z => new Vector3(0f, 0f, fValue), 
			EAxis.MinusX => new Vector3(0f - fValue, 0f, 0f), 
			EAxis.MinusY => new Vector3(0f, 0f - fValue, 0f), 
			EAxis.MinusZ => new Vector3(0f, 0f, 0f - fValue), 
			_ => new Vector3(0f, 0f, fValue), 
		};
	}

	private int GetLinkAxisIndex()
	{
		EAxis eAxis = EAxis.Z;
		if (RopeType == ERopeType.LinkedObjects)
		{
			eAxis = LinkAxis;
		}
		if (RopeType == ERopeType.ImportBones)
		{
			eAxis = BoneAxis;
		}
		switch (eAxis)
		{
		case EAxis.X:
			return 0;
		case EAxis.Y:
			return 1;
		case EAxis.Z:
			return 2;
		case EAxis.MinusX:
			return 0;
		case EAxis.MinusY:
			return 1;
		default:
			_ = 2;
			return 2;
		}
	}

	private bool GetLinkBoxColliderCenterAndSize(float fLinkLength, float fRopeDiameter, ref Vector3 v3CenterInOut, ref Vector3 v3SizeInOut)
	{
		if (RopeType == ERopeType.Procedural)
		{
			v3CenterInOut = Vector3.zero;
			v3SizeInOut = new Vector3(fRopeDiameter, fRopeDiameter, fLinkLength);
			return true;
		}
		if (RopeType == ERopeType.LinkedObjects)
		{
			MeshFilter component = LinkObject.GetComponent<MeshFilter>();
			if (component == null)
			{
				return false;
			}
			v3CenterInOut = component.sharedMesh.bounds.center;
			v3SizeInOut = component.sharedMesh.bounds.size;
			return true;
		}
		if (RopeType == ERopeType.ImportBones)
		{
			if (BoneAxis == EAxis.X)
			{
				v3SizeInOut = new Vector3(fLinkLength, fRopeDiameter, fRopeDiameter);
			}
			if (BoneAxis == EAxis.Y)
			{
				v3SizeInOut = new Vector3(fRopeDiameter, fLinkLength, fRopeDiameter);
			}
			if (BoneAxis == EAxis.Z)
			{
				v3SizeInOut = new Vector3(fRopeDiameter, fRopeDiameter, fLinkLength);
			}
			if (BoneAxis == EAxis.MinusX)
			{
				v3SizeInOut = new Vector3(fLinkLength, fRopeDiameter, fRopeDiameter);
			}
			if (BoneAxis == EAxis.MinusY)
			{
				v3SizeInOut = new Vector3(fRopeDiameter, fLinkLength, fRopeDiameter);
			}
			if (BoneAxis == EAxis.MinusZ)
			{
				v3SizeInOut = new Vector3(fRopeDiameter, fRopeDiameter, fLinkLength);
			}
			return true;
		}
		v3CenterInOut = Vector3.zero;
		v3SizeInOut = new Vector3(fRopeDiameter, fRopeDiameter, fLinkLength);
		return true;
	}

	private bool BuildImportedBoneList(GameObject goBoneFirst, GameObject goBoneLast, List<int> ListImportBonesStatic, List<int> ListImportBonesNoCollider, out List<RopeBone> outListImportedBones, out string strErrorMessage)
	{
		strErrorMessage = "";
		outListImportedBones = new List<RopeBone>();
		int num = 0;
		int num2 = 0;
		int num3 = 0;
		int num4 = 0;
		int num5 = goBoneFirst.name.Length - 1;
		while (num5 >= 0 && char.IsDigit(goBoneFirst.name[num5]))
		{
			num++;
			num5--;
		}
		if (num == 0)
		{
			strErrorMessage = "First bone name needs to end with digits in order to infer bone sequence";
			return false;
		}
		num3 = int.Parse(goBoneFirst.name.Substring(goBoneFirst.name.Length - num));
		int num6 = goBoneLast.name.Length - 1;
		while (num6 >= 0 && char.IsDigit(goBoneLast.name[num6]))
		{
			num2++;
			num6--;
		}
		if (num2 == 0)
		{
			strErrorMessage = "Last bone name needs to end with digits in order to infer bone sequence";
			return false;
		}
		num4 = int.Parse(goBoneLast.name.Substring(goBoneLast.name.Length - num2));
		string text = goBoneFirst.name.Substring(0, goBoneFirst.name.Length - num);
		string text2 = goBoneLast.name.Substring(0, goBoneLast.name.Length - num2);
		if (text != text2)
		{
			strErrorMessage = $"First bone name prefix ({text}) and last bone name prefix ({text2}) don't match";
			return false;
		}
		if (BoneFirst.transform.parent == null || BoneLast.transform.parent == null)
		{
			strErrorMessage = $"First and last bones need to share a common parent object";
			return false;
		}
		GameObject gameObject = (BoneLast.transform.IsChildOf(BoneFirst.transform) ? BoneFirst.transform.parent.gameObject : BoneLast.transform.parent.gameObject);
		if (BuildImportedBoneListTry(gameObject, text, num3, num4, num, num2, ListImportBonesStatic, ListImportBonesNoCollider, out outListImportedBones, ref strErrorMessage))
		{
			return true;
		}
		gameObject = gameObject.transform.root.gameObject;
		string text3 = $"Try1: {strErrorMessage}\nTry2: ";
		if (BuildImportedBoneListTry(gameObject, text, num3, num4, num, num2, ListImportBonesStatic, ListImportBonesNoCollider, out outListImportedBones, ref strErrorMessage))
		{
			return true;
		}
		strErrorMessage = text3 + strErrorMessage;
		return false;
	}

	private bool BuildImportedBoneListTry(GameObject goRoot, string strPrefix, int nIndexFirst, int nIndexLast, int nDigitsFirst, int nDigitsLast, List<int> ListImportBonesStatic, List<int> ListImportBonesNoCollider, out List<RopeBone> outListImportedBones, ref string strErrorMessage)
	{
		outListImportedBones = new List<RopeBone>();
		Dictionary<string, GameObject> outHashString2GameObjects = new Dictionary<string, GameObject>();
		if (!BuildBoneHashString2GameObject(goRoot, goRoot, ref outHashString2GameObjects, ref strErrorMessage))
		{
			return false;
		}
		Dictionary<GameObject, Transform> dictionary = new Dictionary<GameObject, Transform>();
		int num = ((nIndexFirst <= nIndexLast) ? 1 : (-1));
		for (int i = nIndexFirst; (num == 1) ? (i <= nIndexLast) : (i >= nIndexLast); i += num)
		{
			bool flag = false;
			for (int j = nDigitsFirst; j <= nDigitsLast; j++)
			{
				string key = strPrefix + i.ToString("D" + j);
				if (outHashString2GameObjects.ContainsKey(key))
				{
					RopeBone ropeBone = new RopeBone();
					ropeBone.goBone = outHashString2GameObjects[key];
					ropeBone.tfParent = ropeBone.goBone.transform.parent;
					ropeBone.bCreatedCollider = !ListImportBonesNoCollider.Contains(i);
					ropeBone.bIsStatic = ListImportBonesStatic.Contains(i);
					ropeBone.nOriginalLayer = ropeBone.goBone.layer;
					outListImportedBones.Add(ropeBone);
					dictionary.Add(ropeBone.goBone, ropeBone.goBone.transform);
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				strErrorMessage = $"Bone not found (bone number suffix {i}, trying to find below node {goRoot.name}'s hierarchy)";
				return false;
			}
		}
		foreach (RopeBone outListImportedBone in outListImportedBones)
		{
			Transform parent = outListImportedBone.goBone.transform.parent;
			while (parent != null && dictionary.ContainsKey(parent.gameObject))
			{
				parent = parent.parent;
			}
			if (parent == null)
			{
				parent = goRoot.transform;
			}
			dictionary[outListImportedBone.goBone] = parent;
		}
		foreach (RopeBone outListImportedBone2 in outListImportedBones)
		{
			Transform transform = dictionary[outListImportedBone2.goBone];
			GameObject gameObject = new GameObject();
			outListImportedBone2.v3OriginalLocalScale = outListImportedBone2.goBone.transform.localScale;
			gameObject.transform.position = outListImportedBone2.goBone.transform.position;
			gameObject.transform.rotation = outListImportedBone2.goBone.transform.rotation;
			gameObject.transform.parent = transform.transform;
			outListImportedBone2.v3OriginalLocalPos = gameObject.transform.localPosition;
			outListImportedBone2.qOriginalLocalRot = gameObject.transform.localRotation;
			outListImportedBone2.tfNonBoneParent = transform;
			UnityEngine.Object.DestroyImmediate(gameObject);
			if (outListImportedBone2.bIsStatic)
			{
				outListImportedBone2.goBone.transform.parent = transform;
			}
			else
			{
				outListImportedBone2.goBone.transform.parent = base.transform;
			}
		}
		return true;
	}

	private bool BuildBoneHashString2GameObject(GameObject goRoot, GameObject goCurrent, ref Dictionary<string, GameObject> outHashString2GameObjects, ref string strErrorMessage)
	{
		for (int i = 0; i < goCurrent.transform.childCount; i++)
		{
			GameObject goCurrent2 = goCurrent.transform.GetChild(i).gameObject;
			if (!BuildBoneHashString2GameObject(goRoot, goCurrent2, ref outHashString2GameObjects, ref strErrorMessage))
			{
				return false;
			}
		}
		if (outHashString2GameObjects.ContainsKey(goCurrent.name))
		{
			strErrorMessage = $"Bone name {goCurrent.name} is found more than once in GameObject {goRoot.name}'s hierarchy. The name must be unique.";
			return false;
		}
		outHashString2GameObjects.Add(goCurrent.name, goCurrent);
		return true;
	}

	private bool ParseBoneIndices(string strBoneList, out List<int> outListBoneIndices, out string strErrorMessage)
	{
		outListBoneIndices = new List<int>();
		strErrorMessage = "";
		if (strBoneList.Length == 0)
		{
			return true;
		}
		string[] array = strBoneList.Split(',');
		for (int i = 0; i < array.Length; i++)
		{
			string[] array2 = array[i].Split('-');
			if (array2.Length == 1)
			{
				int num = 0;
				try
				{
					num = int.Parse(array2[0]);
				}
				catch
				{
					strErrorMessage = "Field " + (i + 1) + " is invalid (error parsing number: " + array2[0] + ")";
					return false;
				}
				outListBoneIndices.Add(num);
				continue;
			}
			if (array2.Length == 2)
			{
				int num2 = 0;
				int num3 = 0;
				try
				{
					num2 = int.Parse(array2[0]);
				}
				catch
				{
					strErrorMessage = "Field " + (i + 1) + " is invalid (error parsing range start: " + array2[0] + ")";
					return false;
				}
				try
				{
					num3 = int.Parse(array2[1]);
				}
				catch
				{
					strErrorMessage = "Field " + (i + 1) + " is invalid (error parsing range end: " + array2[1] + ")";
					return false;
				}
				if (num3 < num2)
				{
					strErrorMessage = "Field " + (i + 1) + " has invalid range (" + num2 + " is greater than " + num3 + ")";
					return false;
				}
				for (int j = num2; j <= num3; j++)
				{
					outListBoneIndices.Add(j);
				}
				continue;
			}
			strErrorMessage = "Field " + (i + 1) + " has invalid range (field content: " + array[i] + ")";
			return false;
		}
		outListBoneIndices.Sort();
		List<int> list = new List<int>();
		int num4 = -1;
		foreach (int outListBoneIndex in outListBoneIndices)
		{
			if (outListBoneIndex != num4)
			{
				num4 = outListBoneIndex;
				list.Add(outListBoneIndex);
			}
		}
		outListBoneIndices = list;
		return true;
	}
}
public class UltimateRopeLink : MonoBehaviour
{
	public bool ExtensibleKinematic;
}
namespace TMPro
{
	[Serializable]
	public class TMP_DigitValidator : TMP_InputValidator
	{
		public override char Validate(ref string text, ref int pos, char ch)
		{
			if (ch >= '0' && ch <= '9')
			{
				pos++;
				return ch;
			}
			return '\0';
		}
	}
	public class TMP_TextEventHandler : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler
	{
		[Serializable]
		public class CharacterSelectionEvent : UnityEvent<char, int>
		{
		}

		[Serializable]
		public class WordSelectionEvent : UnityEvent<string, int, int>
		{
		}

		[Serializable]
		public class LineSelectionEvent : UnityEvent<string, int, int>
		{
		}

		[Serializable]
		public class LinkSelectionEvent : UnityEvent<string, string, int>
		{
		}

		[SerializeField]
		private CharacterSelectionEvent m_OnCharacterSelection = new CharacterSelectionEvent();

		[SerializeField]
		private WordSelectionEvent m_OnWordSelection = new WordSelectionEvent();

		[SerializeField]
		private LineSelectionEvent m_OnLineSelection = new LineSelectionEvent();

		[SerializeField]
		private LinkSelectionEvent m_OnLinkSelection = new LinkSelectionEvent();

		private TMP_Text m_TextComponent;

		private Camera m_Camera;

		private Canvas m_Canvas;

		private int m_selectedLink = -1;

		private int m_lastCharIndex = -1;

		private int m_lastWordIndex = -1;

		private int m_lastLineIndex = -1;

		public CharacterSelectionEvent onCharacterSelection
		{
			get
			{
				return m_OnCharacterSelection;
			}
			set
			{
				m_OnCharacterSelection = value;
			}
		}

		public WordSelectionEvent onWordSelection
		{
			get
			{
				return m_OnWordSelection;
			}
			set
			{
				m_OnWordSelection = value;
			}
		}

		public LineSelectionEvent onLineSelection
		{
			get
			{
				return m_OnLineSelection;
			}
			set
			{
				m_OnLineSelection = value;
			}
		}

		public LinkSelectionEvent onLinkSelection
		{
			get
			{
				return m_OnLinkSelection;
			}
			set
			{
				m_OnLinkSelection = value;
			}
		}

		private void Awake()
		{
			m_TextComponent = base.gameObject.GetComponent<TMP_Text>();
			if (m_TextComponent.GetType() == typeof(TextMeshProUGUI))
			{
				m_Canvas = base.gameObject.GetComponentInParent<Canvas>();
				if (m_Canvas != null)
				{
					if (m_Canvas.renderMode == RenderMode.ScreenSpaceOverlay)
					{
						m_Camera = null;
					}
					else
					{
						m_Camera = m_Canvas.worldCamera;
					}
				}
			}
			else
			{
				m_Camera = Camera.main;
			}
		}

		private void LateUpdate()
		{
			if (!TMP_TextUtilities.IsIntersectingRectTransform(m_TextComponent.rectTransform, Input.mousePosition, m_Camera))
			{
				return;
			}
			int num = TMP_TextUtilities.FindIntersectingCharacter(m_TextComponent, Input.mousePosition, m_Camera, visibleOnly: true);
			if (num != -1 && num != m_lastCharIndex)
			{
				m_lastCharIndex = num;
				SendOnCharacterSelection(m_TextComponent.textInfo.characterInfo[num].character, num);
			}
			int num2 = TMP_TextUtilities.FindIntersectingWord(m_TextComponent, Input.mousePosition, m_Camera);
			if (num2 != -1 && num2 != m_lastWordIndex)
			{
				m_lastWordIndex = num2;
				TMP_WordInfo tMP_WordInfo = m_TextComponent.textInfo.wordInfo[num2];
				SendOnWordSelection(tMP_WordInfo.GetWord(), tMP_WordInfo.firstCharacterIndex, tMP_WordInfo.characterCount);
			}
			int num3 = TMP_TextUtilities.FindIntersectingLine(m_TextComponent, Input.mousePosition, m_Camera);
			if (num3 != -1 && num3 != m_lastLineIndex)
			{
				m_lastLineIndex = num3;
				TMP_LineInfo tMP_LineInfo = m_TextComponent.textInfo.lineInfo[num3];
				char[] array = new char[tMP_LineInfo.characterCount];
				for (int i = 0; i < tMP_LineInfo.characterCount && i < m_TextComponent.textInfo.characterInfo.Length; i++)
				{
					array[i] = m_TextComponent.textInfo.characterInfo[i + tMP_LineInfo.firstCharacterIndex].character;
				}
				string line = new string(array);
				SendOnLineSelection(line, tMP_LineInfo.firstCharacterIndex, tMP_LineInfo.characterCount);
			}
			int num4 = TMP_TextUtilities.FindIntersectingLink(m_TextComponent, Input.mousePosition, m_Camera);
			if (num4 != -1 && num4 != m_selectedLink)
			{
				m_selectedLink = num4;
				TMP_LinkInfo tMP_LinkInfo = m_TextComponent.textInfo.linkInfo[num4];
				SendOnLinkSelection(tMP_LinkInfo.GetLinkID(), tMP_LinkInfo.GetLinkText(), num4);
			}
		}

		public void OnPointerEnter(PointerEventData eventData)
		{
		}

		public void OnPointerExit(PointerEventData eventData)
		{
		}

		private void SendOnCharacterSelection(char character, int characterIndex)
		{
			if (onCharacterSelection != null)
			{
				onCharacterSelection.Invoke(character, characterIndex);
			}
		}

		private void SendOnWordSelection(string word, int charIndex, int length)
		{
			if (onWordSelection != null)
			{
				onWordSelection.Invoke(word, charIndex, length);
			}
		}

		private void SendOnLineSelection(string line, int charIndex, int length)
		{
			if (onLineSelection != null)
			{
				onLineSelection.Invoke(line, charIndex, length);
			}
		}

		private void SendOnLinkSelection(string linkID, string linkText, int linkIndex)
		{
			if (onLinkSelection != null)
			{
				onLinkSelection.Invoke(linkID, linkText, linkIndex);
			}
		}
	}
}
namespace TMPro.Examples
{
	public class Benchmark01 : MonoBehaviour
	{
		public int BenchmarkType;

		public TMP_FontAsset TMProFont;

		public Font TextMeshFont;

		private TextMeshPro m_textMeshPro;

		private TextContainer m_textContainer;

		private TextMesh m_textMesh;

		private const string label01 = "The <#0050FF>count is: </color>{0}";

		private const string label02 = "The <color=#0050FF>count is: </color>";

		private Material m_material01;

		private Material m_material02;

		private IEnumerator Start()
		{
			if (BenchmarkType == 0)
			{
				m_textMeshPro = base.gameObject.AddComponent<TextMeshPro>();
				m_textMeshPro.autoSizeTextContainer = true;
				if (TMProFont != null)
				{
					m_textMeshPro.font = TMProFont;
				}
				m_textMeshPro.fontSize = 48f;
				m_textMeshPro.alignment = TextAlignmentOptions.Center;
				m_textMeshPro.extraPadding = true;
				m_textMeshPro.enableWordWrapping = false;
				m_material01 = m_textMeshPro.font.material;
				m_material02 = Resources.Load("Fonts & Materials/LiberationSans SDF - Drop Shadow", typeof(Material)) as Material;
			}
			else if (BenchmarkType == 1)
			{
				m_textMesh = base.gameObject.AddComponent<TextMesh>();
				if (TextMeshFont != null)
				{
					m_textMesh.font = TextMeshFont;
					m_textMesh.GetComponent<Renderer>().sharedMaterial = m_textMesh.font.material;
				}
				else
				{
					m_textMesh.font = Resources.Load("Fonts/ARIAL", typeof(Font)) as Font;
					m_textMesh.GetComponent<Renderer>().sharedMaterial = m_textMesh.font.material;
				}
				m_textMesh.fontSize = 48;
				m_textMesh.anchor = TextAnchor.MiddleCenter;
			}
			for (int i = 0; i <= 1000000; i++)
			{
				if (BenchmarkType == 0)
				{
					m_textMeshPro.SetText("The <#0050FF>count is: </color>{0}", i % 1000);
					if (i % 1000 == 999)
					{
						TextMeshPro textMeshPro = m_textMeshPro;
						Material fontSharedMaterial;
						if (!(m_textMeshPro.fontSharedMaterial == m_material01))
						{
							Material material2 = (m_textMeshPro.fontSharedMaterial = m_material01);
							fontSharedMaterial = material2;
						}
						else
						{
							Material material2 = (m_textMeshPro.fontSharedMaterial = m_material02);
							fontSharedMaterial = material2;
						}
						textMeshPro.fontSharedMaterial = fontSharedMaterial;
					}
				}
				else if (BenchmarkType == 1)
				{
					m_textMesh.text = "The <color=#0050FF>count is: </color>" + i % 1000;
				}
				yield return null;
			}
			yield return null;
		}
	}
	public class Benchmark01_UGUI : MonoBehaviour
	{
		public int BenchmarkType;

		public Canvas canvas;

		public TMP_FontAsset TMProFont;

		public Font TextMeshFont;

		private TextMeshProUGUI m_textMeshPro;

		private Text m_textMesh;

		private const string label01 = "The <#0050FF>count is: </color>";

		private const string label02 = "The <color=#0050FF>count is: </color>";

		private Material m_material01;

		private Material m_material02;

		private IEnumerator Start()
		{
			if (BenchmarkType == 0)
			{
				m_textMeshPro = base.gameObject.AddComponent<TextMeshProUGUI>();
				if (TMProFont != null)
				{
					m_textMeshPro.font = TMProFont;
				}
				m_textMeshPro.fontSize = 48f;
				m_textMeshPro.alignment = TextAlignmentOptions.Center;
				m_textMeshPro.extraPadding = true;
				m_material01 = m_textMeshPro.font.material;
				m_material02 = Resources.Load("Fonts & Materials/LiberationSans SDF - BEVEL", typeof(Material)) as Material;
			}
			else if (BenchmarkType == 1)
			{
				m_textMesh = base.gameObject.AddComponent<Text>();
				if (TextMeshFont != null)
				{
					m_textMesh.font = TextMeshFont;
				}
				m_textMesh.fontSize = 48;
				m_textMesh.alignment = TextAnchor.MiddleCenter;
			}
			for (int i = 0; i <= 1000000; i++)
			{
				if (BenchmarkType == 0)
				{
					m_textMeshPro.text = "The <#0050FF>count is: </color>" + i % 1000;
					if (i % 1000 == 999)
					{
						TextMeshProUGUI textMeshPro = m_textMeshPro;
						Material fontSharedMaterial;
						if (!(m_textMeshPro.fontSharedMaterial == m_material01))
						{
							Material material2 = (m_textMeshPro.fontSharedMaterial = m_material01);
							fontSharedMaterial = material2;
						}
						else
						{
							Material material2 = (m_textMeshPro.fontSharedMaterial = m_material02);
							fontSharedMaterial = material2;
						}
						textMeshPro.fontSharedMaterial = fontSharedMaterial;
					}
				}
				else if (BenchmarkType == 1)
				{
					m_textMesh.text = "The <color=#0050FF>count is: </color>" + i % 1000;
				}
				yield return null;
			}
			yield return null;
		}
	}
	public class Benchmark02 : MonoBehaviour
	{
		public int SpawnType;

		public int NumberOfNPC = 12;

		private TextMeshProFloatingText floatingText_Script;

		private void Start()
		{
			for (int i = 0; i < NumberOfNPC; i++)
			{
				if (SpawnType == 0)
				{
					GameObject gameObject = new GameObject();
					gameObject.transform.position = new Vector3(UnityEngine.Random.Range(-95f, 95f), 0.25f, UnityEngine.Random.Range(-95f, 95f));
					TextMeshPro textMeshPro = gameObject.AddComponent<TextMeshPro>();
					textMeshPro.autoSizeTextContainer = true;
					textMeshPro.rectTransform.pivot = new Vector2(0.5f, 0f);
					textMeshPro.alignment = TextAlignmentOptions.Bottom;
					textMeshPro.fontSize = 96f;
					textMeshPro.color = new Color32(byte.MaxValue, byte.MaxValue, 0, byte.MaxValue);
					textMeshPro.text = "!";
					floatingText_Script = gameObject.AddComponent<TextMeshProFloatingText>();
					floatingText_Script.SpawnType = 0;
				}
				else if (SpawnType == 1)
				{
					GameObject gameObject2 = new GameObject();
					gameObject2.transform.position = new Vector3(UnityEngine.Random.Range(-95f, 95f), 0.25f, UnityEngine.Random.Range(-95f, 95f));
					TextMesh textMesh = gameObject2.AddComponent<TextMesh>();
					textMesh.font = Resources.Load("Fonts/ARIAL", typeof(Font)) as Font;
					textMesh.GetComponent<Renderer>().sharedMaterial = textMesh.font.material;
					textMesh.anchor = TextAnchor.LowerCenter;
					textMesh.fontSize = 96;
					textMesh.color = new Color32(byte.MaxValue, byte.MaxValue, 0, byte.MaxValue);
					textMesh.text = "!";
					floatingText_Script = gameObject2.AddComponent<TextMeshProFloatingText>();
					floatingText_Script.SpawnType = 1;
				}
				else if (SpawnType == 2)
				{
					GameObject gameObject3 = new GameObject();
					gameObject3.AddComponent<Canvas>().worldCamera = Camera.main;
					gameObject3.transform.localScale = new Vector3(0.1f, 0.1f, 0.1f);
					gameObject3.transform.position = new Vector3(UnityEngine.Random.Range(-95f, 95f), 5f, UnityEngine.Random.Range(-95f, 95f));
					TextMeshProUGUI textMeshProUGUI = new GameObject().AddComponent<TextMeshProUGUI>();
					textMeshProUGUI.rectTransform.SetParent(gameObject3.transform, worldPositionStays: false);
					textMeshProUGUI.color = new Color32(byte.MaxValue, byte.MaxValue, 0, byte.MaxValue);
					textMeshProUGUI.alignment = TextAlignmentOptions.Bottom;
					textMeshProUGUI.fontSize = 96f;
					textMeshProUGUI.text = "!";
					floatingText_Script = gameObject3.AddComponent<TextMeshProFloatingText>();
					floatingText_Script.SpawnType = 0;
				}
			}
		}
	}
	public class Benchmark03 : MonoBehaviour
	{
		public int SpawnType;

		public int NumberOfNPC = 12;

		public Font TheFont;

		private void Awake()
		{
		}

		private void Start()
		{
			for (int i = 0; i < NumberOfNPC; i++)
			{
				if (SpawnType == 0)
				{
					GameObject obj = new GameObject();
					obj.transform.position = new Vector3(0f, 0f, 0f);
					TextMeshPro textMeshPro = obj.AddComponent<TextMeshPro>();
					textMeshPro.alignment = TextAlignmentOptions.Center;
					textMeshPro.fontSize = 96f;
					textMeshPro.text = "@";
					textMeshPro.color = new Color32(byte.MaxValue, byte.MaxValue, 0, byte.MaxValue);
				}
				else
				{
					GameObject obj2 = new GameObject();
					obj2.transform.position = new Vector3(0f, 0f, 0f);
					TextMesh textMesh = obj2.AddComponent<TextMesh>();
					textMesh.GetComponent<Renderer>().sharedMaterial = TheFont.material;
					textMesh.font = TheFont;
					textMesh.anchor = TextAnchor.MiddleCenter;
					textMesh.fontSize = 96;
					textMesh.color = new Color32(byte.MaxValue, byte.MaxValue, 0, byte.MaxValue);
					textMesh.text = "@";
				}
			}
		}
	}
	public class Benchmark04 : MonoBehaviour
	{
		public int SpawnType;

		public int MinPointSize = 12;

		public int MaxPointSize = 64;

		public int Steps = 4;

		private Transform m_Transform;

		private void Start()
		{
			m_Transform = base.transform;
			float num = 0f;
			float num3 = (Camera.main.orthographicSize = Screen.height / 2);
			float num4 = num3;
			float num5 = (float)Screen.width / (float)Screen.height;
			for (int i = MinPointSize; i <= MaxPointSize; i += Steps)
			{
				if (SpawnType == 0)
				{
					GameObject gameObject = new GameObject("Text - " + i + " Pts");
					if (num > num4 * 2f)
					{
						break;
					}
					gameObject.transform.position = m_Transform.position + new Vector3(num5 * (0f - num4) * 0.975f, num4 * 0.975f - num, 0f);
					TextMeshPro textMeshPro = gameObject.AddComponent<TextMeshPro>();
					textMeshPro.rectTransform.pivot = new Vector2(0f, 0.5f);
					textMeshPro.enableWordWrapping = false;
					textMeshPro.extraPadding = true;
					textMeshPro.isOrthographic = true;
					textMeshPro.fontSize = i;
					textMeshPro.text = i + " pts - Lorem ipsum dolor sit...";
					textMeshPro.color = new Color32(byte.MaxValue, byte.MaxValue, byte.MaxValue, byte.MaxValue);
					num += (float)i;
				}
			}
		}
	}
	public class CameraController : MonoBehaviour
	{
		public enum CameraModes
		{
			Follow,
			Isometric,
			Free
		}

		private Transform cameraTransform;

		private Transform dummyTarget;

		public Transform CameraTarget;

		public float FollowDistance = 30f;

		public float MaxFollowDistance = 100f;

		public float MinFollowDistance = 2f;

		public float ElevationAngle = 30f;

		public float MaxElevationAngle = 85f;

		public float MinElevationAngle;

		public float OrbitalAngle;

		public CameraModes CameraMode;

		public bool MovementSmoothing = true;

		public bool RotationSmoothing;

		private bool previousSmoothing;

		public float MovementSmoothingValue = 25f;

		public float RotationSmoothingValue = 5f;

		public float MoveSensitivity = 2f;

		private Vector3 currentVelocity = Vector3.zero;

		private Vector3 desiredPosition;

		private float mouseX;

		private float mouseY;

		private Vector3 moveVector;

		private float mouseWheel;

		private const string event_SmoothingValue = "Slider - Smoothing Value";

		private const string event_FollowDistance = "Slider - Camera Zoom";

		private void Awake()
		{
			if (QualitySettings.vSyncCount > 0)
			{
				Application.targetFrameRate = 60;
			}
			else
			{
				Application.targetFrameRate = -1;
			}
			if (Application.platform == RuntimePlatform.IPhonePlayer || Application.platform == RuntimePlatform.Android)
			{
				Input.simulateMouseWithTouches = false;
			}
			cameraTransform = base.transform;
			previousSmoothing = MovementSmoothing;
		}

		private void Start()
		{
			if (CameraTarget == null)
			{
				dummyTarget = new GameObject("Camera Target").transform;
				CameraTarget = dummyTarget;
			}
		}

		private void LateUpdate()
		{
			GetPlayerInput();
			if (CameraTarget != null)
			{
				if (CameraMode == CameraModes.Isometric)
				{
					desiredPosition = CameraTarget.position + Quaternion.Euler(ElevationAngle, OrbitalAngle, 0f) * new Vector3(0f, 0f, 0f - FollowDistance);
				}
				else if (CameraMode == CameraModes.Follow)
				{
					desiredPosition = CameraTarget.position + CameraTarget.TransformDirection(Quaternion.Euler(ElevationAngle, OrbitalAngle, 0f) * new Vector3(0f, 0f, 0f - FollowDistance));
				}
				if (MovementSmoothing)
				{
					cameraTransform.position = Vector3.SmoothDamp(cameraTransform.position, desiredPosition, ref currentVelocity, MovementSmoothingValue * Time.fixedDeltaTime);
				}
				else
				{
					cameraTransform.position = desiredPosition;
				}
				if (RotationSmoothing)
				{
					cameraTransform.rotation = Quaternion.Lerp(cameraTransform.rotation, Quaternion.LookRotation(CameraTarget.position - cameraTransform.position), RotationSmoothingValue * Time.deltaTime);
				}
				else
				{
					cameraTransform.LookAt(CameraTarget);
				}
			}
		}

		private void GetPlayerInput()
		{
			moveVector = Vector3.zero;
			mouseWheel = Input.GetAxis("Mouse ScrollWheel");
			float num = Input.touchCount;
			if (Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.RightShift) || num > 0f)
			{
				mouseWheel *= 10f;
				if (Input.GetKeyDown(KeyCode.I))
				{
					CameraMode = CameraModes.Isometric;
				}
				if (Input.GetKeyDown(KeyCode.F))
				{
					CameraMode = CameraModes.Follow;
				}
				if (Input.GetKeyDown(KeyCode.S))
				{
					MovementSmoothing = !MovementSmoothing;
				}
				if (Input.GetMouseButton(1))
				{
					mouseY = Input.GetAxis("Mouse Y");
					mouseX = Input.GetAxis("Mouse X");
					if (mouseY > 0.01f || mouseY < -0.01f)
					{
						ElevationAngle -= mouseY * MoveSensitivity;
						ElevationAngle = Mathf.Clamp(ElevationAngle, MinElevationAngle, MaxElevationAngle);
					}
					if (mouseX > 0.01f || mouseX < -0.01f)
					{
						OrbitalAngle += mouseX * MoveSensitivity;
						if (OrbitalAngle > 360f)
						{
							OrbitalAngle -= 360f;
						}
						if (OrbitalAngle < 0f)
						{
							OrbitalAngle += 360f;
						}
					}
				}
				if (num == 1f && Input.GetTouch(0).phase == TouchPhase.Moved)
				{
					Vector2 deltaPosition = Input.GetTouch(0).deltaPosition;
					if (deltaPosition.y > 0.01f || deltaPosition.y < -0.01f)
					{
						ElevationAngle -= deltaPosition.y * 0.1f;
						ElevationAngle = Mathf.Clamp(ElevationAngle, MinElevationAngle, MaxElevationAngle);
					}
					if (deltaPosition.x > 0.01f || deltaPosition.x < -0.01f)
					{
						OrbitalAngle += deltaPosition.x * 0.1f;
						if (OrbitalAngle > 360f)
						{
							OrbitalAngle -= 360f;
						}
						if (OrbitalAngle < 0f)
						{
							OrbitalAngle += 360f;
						}
					}
				}
				if (Input.GetMouseButton(0) && Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out var hitInfo, 300f, 23552))
				{
					if (hitInfo.transform == CameraTarget)
					{
						OrbitalAngle = 0f;
					}
					else
					{
						CameraTarget = hitInfo.transform;
						OrbitalAngle = 0f;
						MovementSmoothing = previousSmoothing;
					}
				}
				if (Input.GetMouseButton(2))
				{
					if (dummyTarget == null)
					{
						dummyTarget = new GameObject("Camera Target").transform;
						dummyTarget.position = CameraTarget.position;
						dummyTarget.rotation = CameraTarget.rotation;
						CameraTarget = dummyTarget;
						previousSmoothing = MovementSmoothing;
						MovementSmoothing = false;
					}
					else if (dummyTarget != CameraTarget)
					{
						dummyTarget.position = CameraTarget.position;
						dummyTarget.rotation = CameraTarget.rotation;
						CameraTarget = dummyTarget;
						previousSmoothing = MovementSmoothing;
						MovementSmoothing = false;
					}
					mouseY = Input.GetAxis("Mouse Y");
					mouseX = Input.GetAxis("Mouse X");
					moveVector = cameraTransform.TransformDirection(mouseX, mouseY, 0f);
					dummyTarget.Translate(-moveVector, Space.World);
				}
			}
			if (num == 2f)
			{
				Touch touch = Input.GetTouch(0);
				Touch touch2 = Input.GetTouch(1);
				Vector2 vector = touch.position - touch.deltaPosition;
				Vector2 vector2 = touch2.position - touch2.deltaPosition;
				float magnitude = (vector - vector2).magnitude;
				float magnitude2 = (touch.position - touch2.position).magnitude;
				float num2 = magnitude - magnitude2;
				if (num2 > 0.01f || num2 < -0.01f)
				{
					FollowDistance += num2 * 0.25f;
					FollowDistance = Mathf.Clamp(FollowDistance, MinFollowDistance, MaxFollowDistance);
				}
			}
			if (mouseWheel < -0.01f || mouseWheel > 0.01f)
			{
				FollowDistance -= mouseWheel * 5f;
				FollowDistance = Mathf.Clamp(FollowDistance, MinFollowDistance, MaxFollowDistance);
			}
		}
	}
	public class ObjectSpin : MonoBehaviour
	{
		public enum MotionType
		{
			Rotation,
			BackAndForth,
			Translation
		}

		public float SpinSpeed = 5f;

		public int RotationRange = 15;

		private Transform m_transform;

		private float m_time;

		private Vector3 m_prevPOS;

		private Vector3 m_initial_Rotation;

		private Vector3 m_initial_Position;

		private Color32 m_lightColor;

		private int frames;

		public MotionType Motion;

		private void Awake()
		{
			m_transform = base.transform;
			m_initial_Rotation = m_transform.rotation.eulerAngles;
			m_initial_Position = m_transform.position;
			Light component = GetComponent<Light>();
			m_lightColor = ((component != null) ? component.color : UnityEngine.Color.black);
		}

		private void Update()
		{
			if (Motion == MotionType.Rotation)
			{
				m_transform.Rotate(0f, SpinSpeed * Time.deltaTime, 0f);
				return;
			}
			if (Motion == MotionType.BackAndForth)
			{
				m_time += SpinSpeed * Time.deltaTime;
				m_transform.rotation = Quaternion.Euler(m_initial_Rotation.x, Mathf.Sin(m_time) * (float)RotationRange + m_initial_Rotation.y, m_initial_Rotation.z);
				return;
			}
			m_time += SpinSpeed * Time.deltaTime;
			float x = 15f * Mathf.Cos(m_time * 0.95f);
			float z = 10f;
			float y = 0f;
			m_transform.position = m_initial_Position + new Vector3(x, y, z);
			m_prevPOS = m_transform.position;
			frames++;
		}
	}
	public class ShaderPropAnimator : MonoBehaviour
	{
		private Renderer m_Renderer;

		private Material m_Material;

		public AnimationCurve GlowCurve;

		public float m_frame;

		private void Awake()
		{
			m_Renderer = GetComponent<Renderer>();
			m_Material = m_Renderer.material;
		}

		private void Start()
		{
			StartCoroutine(AnimateProperties());
		}

		private IEnumerator AnimateProperties()
		{
			m_frame = UnityEngine.Random.Range(0f, 1f);
			while (true)
			{
				float value = GlowCurve.Evaluate(m_frame);
				m_Material.SetFloat(ShaderUtilities.ID_GlowPower, value);
				m_frame += Time.deltaTime * UnityEngine.Random.Range(0.2f, 0.3f);
				yield return Yield.EndOfFrame;
			}
		}
	}
	public class SimpleScript : MonoBehaviour
	{
		private TextMeshPro m_textMeshPro;

		private const string label = "The <#0050FF>count is: </color>{0:2}";

		private float m_frame;

		private void Start()
		{
			m_textMeshPro = base.gameObject.AddComponent<TextMeshPro>();
			m_textMeshPro.autoSizeTextContainer = true;
			m_textMeshPro.fontSize = 48f;
			m_textMeshPro.alignment = TextAlignmentOptions.Center;
			m_textMeshPro.enableWordWrapping = false;
		}

		private void Update()
		{
			m_textMeshPro.SetText("The <#0050FF>count is: </color>{0:2}", m_frame % 1000f);
			m_frame += 1f * Time.deltaTime;
		}
	}
	public class SkewTextExample : MonoBehaviour
	{
		private TMP_Text m_TextComponent;

		public AnimationCurve VertexCurve = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(0.25f, 2f), new Keyframe(0.5f, 0f), new Keyframe(0.75f, 2f), new Keyframe(1f, 0f));

		public float CurveScale = 1f;

		public float ShearAmount = 1f;

		private void Awake()
		{
			m_TextComponent = base.gameObject.GetComponent<TMP_Text>();
		}

		private void Start()
		{
			StartCoroutine(WarpText());
		}

		private AnimationCurve CopyAnimationCurve(AnimationCurve curve)
		{
			return new AnimationCurve
			{
				keys = curve.keys
			};
		}

		private IEnumerator WarpText()
		{
			VertexCurve.preWrapMode = WrapMode.Once;
			VertexCurve.postWrapMode = WrapMode.Once;
			m_TextComponent.havePropertiesChanged = true;
			CurveScale *= 10f;
			float old_CurveScale = CurveScale;
			float old_ShearValue = ShearAmount;
			AnimationCurve old_curve = CopyAnimationCurve(VertexCurve);
			while (true)
			{
				if (!m_TextComponent.havePropertiesChanged && old_CurveScale == CurveScale && old_curve.keys[1].value == VertexCurve.keys[1].value && old_ShearValue == ShearAmount)
				{
					yield return null;
					continue;
				}
				old_CurveScale = CurveScale;
				old_curve = CopyAnimationCurve(VertexCurve);
				old_ShearValue = ShearAmount;
				m_TextComponent.ForceMeshUpdate();
				TMP_TextInfo textInfo = m_TextComponent.textInfo;
				int characterCount = textInfo.characterCount;
				if (characterCount == 0)
				{
					continue;
				}
				float x = m_TextComponent.bounds.min.x;
				float x2 = m_TextComponent.bounds.max.x;
				for (int i = 0; i < characterCount; i++)
				{
					if (textInfo.characterInfo[i].isVisible)
					{
						int vertexIndex = textInfo.characterInfo[i].vertexIndex;
						int materialReferenceIndex = textInfo.characterInfo[i].materialReferenceIndex;
						Vector3[] vertices = textInfo.meshInfo[materialReferenceIndex].vertices;
						Vector3 vector = new Vector2((vertices[vertexIndex].x + vertices[vertexIndex + 2].x) / 2f, textInfo.characterInfo[i].baseLine);
						vertices[vertexIndex] += -vector;
						vertices[vertexIndex + 1] += -vector;
						vertices[vertexIndex + 2] += -vector;
						vertices[vertexIndex + 3] += -vector;
						float num = ShearAmount * 0.01f;
						Vector3 vector2 = new Vector3(num * (textInfo.characterInfo[i].topRight.y - textInfo.characterInfo[i].baseLine), 0f, 0f);
						Vector3 vector3 = new Vector3(num * (textInfo.characterInfo[i].baseLine - textInfo.characterInfo[i].bottomRight.y), 0f, 0f);
						vertices[vertexIndex] += -vector3;
						vertices[vertexIndex + 1] += vector2;
						vertices[vertexIndex + 2] += vector2;
						vertices[vertexIndex + 3] += -vector3;
						float num2 = (vector.x - x) / (x2 - x);
						float num3 = num2 + 0.0001f;
						float y = VertexCurve.Evaluate(num2) * CurveScale;
						float y2 = VertexCurve.Evaluate(num3) * CurveScale;
						Vector3 lhs = new Vector3(1f, 0f, 0f);
						Vector3 rhs = new Vector3(num3 * (x2 - x) + x, y2) - new Vector3(vector.x, y);
						float num4 = Mathf.Acos(Vector3.Dot(lhs, rhs.normalized)) * 57.29578f;
						float z = ((Vector3.Cross(lhs, rhs).z > 0f) ? num4 : (360f - num4));
						Matrix4x4 matrix4x = Matrix4x4.TRS(new Vector3(0f, y, 0f), Quaternion.Euler(0f, 0f, z), Vector3.one);
						vertices[vertexIndex] = matrix4x.MultiplyPoint3x4(vertices[vertexIndex]);
						vertices[vertexIndex + 1] = matrix4x.MultiplyPoint3x4(vertices[vertexIndex + 1]);
						vertices[vertexIndex + 2] = matrix4x.MultiplyPoint3x4(vertices[vertexIndex + 2]);
						vertices[vertexIndex + 3] = matrix4x.MultiplyPoint3x4(vertices[vertexIndex + 3]);
						vertices[vertexIndex] += vector;
						vertices[vertexIndex + 1] += vector;
						vertices[vertexIndex + 2] += vector;
						vertices[vertexIndex + 3] += vector;
					}
				}
				m_TextComponent.UpdateVertexData();
				yield return null;
			}
		}
	}
	public class TeleType : MonoBehaviour
	{
		private string label01 = "Example <sprite=2> of using <sprite=7> <#ffa000>Graphics Inline</color> <sprite=5> with Text in <font=\"Bangers SDF\" material=\"Bangers SDF - Drop Shadow\">TextMesh<#40a0ff>Pro</color></font><sprite=0> and Unity<sprite=1>";

		private string label02 = "Example <sprite=2> of using <sprite=7> <#ffa000>Graphics Inline</color> <sprite=5> with Text in <font=\"Bangers SDF\" material=\"Bangers SDF - Drop Shadow\">TextMesh<#40a0ff>Pro</color></font><sprite=0> and Unity<sprite=2>";

		private TMP_Text m_textMeshPro;

		private void Awake()
		{
			m_textMeshPro = GetComponent<TMP_Text>();
			m_textMeshPro.text = label01;
			m_textMeshPro.enableWordWrapping = true;
			m_textMeshPro.alignment = TextAlignmentOptions.Top;
		}

		private IEnumerator Start()
		{
			m_textMeshPro.ForceMeshUpdate();
			int totalVisibleCharacters = m_textMeshPro.textInfo.characterCount;
			int counter = 0;
			while (true)
			{
				int num = counter % (totalVisibleCharacters + 1);
				m_textMeshPro.maxVisibleCharacters = num;
				if (num >= totalVisibleCharacters)
				{
					yield return Yield.WaitSeconds(1f);
					m_textMeshPro.text = label02;
					yield return Yield.WaitSeconds(1f);
					m_textMeshPro.text = label01;
					yield return Yield.WaitSeconds(1f);
				}
				counter++;
				yield return Yield.WaitSeconds(0.05f);
			}
		}
	}
	public class TextConsoleSimulator : MonoBehaviour
	{
		private TMP_Text m_TextComponent;

		private bool hasTextChanged;

		private void Awake()
		{
			m_TextComponent = base.gameObject.GetComponent<TMP_Text>();
		}

		private void Start()
		{
			StartCoroutine(RevealCharacters(m_TextComponent));
		}

		private void OnEnable()
		{
			TMPro_EventManager.TEXT_CHANGED_EVENT.Add(ON_TEXT_CHANGED);
		}

		private void OnDisable()
		{
			TMPro_EventManager.TEXT_CHANGED_EVENT.Remove(ON_TEXT_CHANGED);
		}

		private void ON_TEXT_CHANGED(UnityEngine.Object obj)
		{
			hasTextChanged = true;
		}

		private IEnumerator RevealCharacters(TMP_Text textComponent)
		{
			textComponent.ForceMeshUpdate();
			TMP_TextInfo textInfo = textComponent.textInfo;
			int totalVisibleCharacters = textInfo.characterCount;
			int visibleCount = 0;
			while (true)
			{
				if (hasTextChanged)
				{
					totalVisibleCharacters = textInfo.characterCount;
					hasTextChanged = false;
				}
				if (visibleCount > totalVisibleCharacters)
				{
					yield return Yield.WaitSeconds(1f);
					visibleCount = 0;
				}
				textComponent.maxVisibleCharacters = visibleCount;
				visibleCount++;
				yield return Yield.WaitSeconds(0f);
			}
		}

		private IEnumerator RevealWords(TMP_Text textComponent)
		{
			textComponent.ForceMeshUpdate();
			int totalWordCount = textComponent.textInfo.wordCount;
			int totalVisibleCharacters = textComponent.textInfo.characterCount;
			int counter = 0;
			int visibleCount = 0;
			while (true)
			{
				int num = counter % (totalWordCount + 1);
				if (num == 0)
				{
					visibleCount = 0;
				}
				else if (num < totalWordCount)
				{
					visibleCount = textComponent.textInfo.wordInfo[num - 1].lastCharacterIndex + 1;
				}
				else if (num == totalWordCount)
				{
					visibleCount = totalVisibleCharacters;
				}
				textComponent.maxVisibleCharacters = visibleCount;
				if (visibleCount >= totalVisibleCharacters)
				{
					yield return Yield.WaitSeconds(1f);
				}
				counter++;
				yield return Yield.WaitSeconds(0.1f);
			}
		}
	}
	public class TextMeshProFloatingText : MonoBehaviour
	{
		public Font TheFont;

		private GameObject m_floatingText;

		private TextMeshPro m_textMeshPro;

		private TextMesh m_textMesh;

		private Transform m_transform;

		private Transform m_floatingText_Transform;

		private Transform m_cameraTransform;

		private Vector3 lastPOS = Vector3.zero;

		private Quaternion lastRotation = Quaternion.identity;

		public int SpawnType;

		private void Awake()
		{
			m_transform = base.transform;
			m_floatingText = new GameObject(base.name + " floating text");
			m_cameraTransform = Camera.main.transform;
		}

		private void Start()
		{
			if (SpawnType == 0)
			{
				m_textMeshPro = m_floatingText.AddComponent<TextMeshPro>();
				m_textMeshPro.rectTransform.sizeDelta = new Vector2(3f, 3f);
				m_floatingText_Transform = m_floatingText.transform;
				m_floatingText_Transform.position = m_transform.position + new Vector3(0f, 15f, 0f);
				m_textMeshPro.alignment = TextAlignmentOptions.Center;
				m_textMeshPro.color = new Color32((byte)UnityEngine.Random.Range(0, 255), (byte)UnityEngine.Random.Range(0, 255), (byte)UnityEngine.Random.Range(0, 255), byte.MaxValue);
				m_textMeshPro.fontSize = 24f;
				m_textMeshPro.text = string.Empty;
				StartCoroutine(DisplayTextMeshProFloatingText());
			}
			else if (SpawnType == 1)
			{
				m_floatingText_Transform = m_floatingText.transform;
				m_floatingText_Transform.position = m_transform.position + new Vector3(0f, 15f, 0f);
				m_textMesh = m_floatingText.AddComponent<TextMesh>();
				m_textMesh.font = Resources.Load("Fonts/ARIAL", typeof(Font)) as Font;
				m_textMesh.GetComponent<Renderer>().sharedMaterial = m_textMesh.font.material;
				m_textMesh.color = new Color32((byte)UnityEngine.Random.Range(0, 255), (byte)UnityEngine.Random.Range(0, 255), (byte)UnityEngine.Random.Range(0, 255), byte.MaxValue);
				m_textMesh.anchor = TextAnchor.LowerCenter;
				m_textMesh.fontSize = 24;
				StartCoroutine(DisplayTextMeshFloatingText());
			}
			else
			{
				_ = SpawnType;
				_ = 2;
			}
		}

		public IEnumerator DisplayTextMeshProFloatingText()
		{
			float CountDuration = 2f;
			float starting_Count = UnityEngine.Random.Range(5f, 20f);
			float current_Count = starting_Count;
			Vector3 start_pos = m_floatingText_Transform.position;
			Color32 start_color = m_textMeshPro.color;
			float alpha = 255f;
			float fadeDuration = 3f / starting_Count * CountDuration;
			while (current_Count > 0f)
			{
				current_Count -= Time.deltaTime / CountDuration * starting_Count;
				if (current_Count <= 3f)
				{
					alpha = Mathf.Clamp(alpha - Time.deltaTime / fadeDuration * 255f, 0f, 255f);
				}
				m_textMeshPro.SetText("{0}", (int)current_Count);
				m_textMeshPro.color = new Color32(start_color.r, start_color.g, start_color.b, (byte)alpha);
				m_floatingText_Transform.position += new Vector3(0f, starting_Count * Time.deltaTime, 0f);
				if (!lastPOS.Compare(m_cameraTransform.position, 1000) || !lastRotation.Compare(m_cameraTransform.rotation, 1000))
				{
					lastPOS = m_cameraTransform.position;
					lastRotation = m_cameraTransform.rotation;
					m_floatingText_Transform.rotation = lastRotation;
					Vector3 vector = m_transform.position - lastPOS;
					m_transform.forward = new Vector3(vector.x, 0f, vector.z);
				}
				yield return Yield.EndOfFrame;
			}
			yield return Yield.WaitSeconds(UnityEngine.Random.Range(0.1f, 1f));
			m_floatingText_Transform.position = start_pos;
			StartCoroutine(DisplayTextMeshProFloatingText());
		}

		public IEnumerator DisplayTextMeshFloatingText()
		{
			float CountDuration = 2f;
			float starting_Count = UnityEngine.Random.Range(5f, 20f);
			float current_Count = starting_Count;
			Vector3 start_pos = m_floatingText_Transform.position;
			Color32 start_color = m_textMesh.color;
			float alpha = 255f;
			float fadeDuration = 3f / starting_Count * CountDuration;
			while (current_Count > 0f)
			{
				current_Count -= Time.deltaTime / CountDuration * starting_Count;
				if (current_Count <= 3f)
				{
					alpha = Mathf.Clamp(alpha - Time.deltaTime / fadeDuration * 255f, 0f, 255f);
				}
				m_textMesh.text = ((int)current_Count).ToString();
				m_textMesh.color = new Color32(start_color.r, start_color.g, start_color.b, (byte)alpha);
				m_floatingText_Transform.position += new Vector3(0f, starting_Count * Time.deltaTime, 0f);
				if (!lastPOS.Compare(m_cameraTransform.position, 1000) || !lastRotation.Compare(m_cameraTransform.rotation, 1000))
				{
					lastPOS = m_cameraTransform.position;
					lastRotation = m_cameraTransform.rotation;
					m_floatingText_Transform.rotation = lastRotation;
					Vector3 vector = m_transform.position - lastPOS;
					m_transform.forward = new Vector3(vector.x, 0f, vector.z);
				}
				yield return Yield.EndOfFrame;
			}
			yield return Yield.WaitSeconds(UnityEngine.Random.Range(0.1f, 1f));
			m_floatingText_Transform.position = start_pos;
			StartCoroutine(DisplayTextMeshFloatingText());
		}
	}
	public class TextMeshSpawner : MonoBehaviour
	{
		public int SpawnType;

		public int NumberOfNPC = 12;

		public Font TheFont;

		private TextMeshProFloatingText floatingText_Script;

		private void Awake()
		{
		}

		private void Start()
		{
			for (int i = 0; i < NumberOfNPC; i++)
			{
				if (SpawnType == 0)
				{
					GameObject gameObject = new GameObject();
					gameObject.transform.position = new Vector3(UnityEngine.Random.Range(-95f, 95f), 0.5f, UnityEngine.Random.Range(-95f, 95f));
					TextMeshPro textMeshPro = gameObject.AddComponent<TextMeshPro>();
					textMeshPro.fontSize = 96f;
					textMeshPro.text = "!";
					textMeshPro.color = new Color32(byte.MaxValue, byte.MaxValue, 0, byte.MaxValue);
					floatingText_Script = gameObject.AddComponent<TextMeshProFloatingText>();
					floatingText_Script.SpawnType = 0;
				}
				else
				{
					GameObject gameObject2 = new GameObject();
					gameObject2.transform.position = new Vector3(UnityEngine.Random.Range(-95f, 95f), 0.5f, UnityEngine.Random.Range(-95f, 95f));
					TextMesh textMesh = gameObject2.AddComponent<TextMesh>();
					textMesh.GetComponent<Renderer>().sharedMaterial = TheFont.material;
					textMesh.font = TheFont;
					textMesh.anchor = TextAnchor.LowerCenter;
					textMesh.fontSize = 96;
					textMesh.color = new Color32(byte.MaxValue, byte.MaxValue, 0, byte.MaxValue);
					textMesh.text = "!";
					floatingText_Script = gameObject2.AddComponent<TextMeshProFloatingText>();
					floatingText_Script.SpawnType = 1;
				}
			}
		}
	}
	public class TMP_ExampleScript_01 : MonoBehaviour
	{
		public enum objectType
		{
			TextMeshPro,
			TextMeshProUGUI
		}

		public objectType ObjectType;

		public bool isStatic;

		private TMP_Text m_text;

		private const string k_label = "The count is <#0080ff>{0}</color>";

		private int count;

		private void Awake()
		{
			if (ObjectType == objectType.TextMeshPro)
			{
				m_text = GetComponent<TextMeshPro>() ?? base.gameObject.AddComponent<TextMeshPro>();
			}
			else
			{
				m_text = GetComponent<TextMeshProUGUI>() ?? base.gameObject.AddComponent<TextMeshProUGUI>();
			}
			m_text.font = Resources.Load<TMP_FontAsset>("Fonts & Materials/Anton SDF");
			m_text.fontSharedMaterial = Resources.Load<Material>("Fonts & Materials/Anton SDF - Drop Shadow");
			m_text.fontSize = 120f;
			m_text.text = "A <#0080ff>simple</color> line of text.";
			Vector2 preferredValues = m_text.GetPreferredValues(float.PositiveInfinity, float.PositiveInfinity);
			m_text.rectTransform.sizeDelta = new Vector2(preferredValues.x, preferredValues.y);
		}

		private void Update()
		{
			if (!isStatic)
			{
				m_text.SetText("The count is <#0080ff>{0}</color>", count % 1000);
				count++;
			}
		}
	}
	public class TMP_FrameRateCounter : MonoBehaviour
	{
		public enum FpsCounterAnchorPositions
		{
			TopLeft,
			BottomLeft,
			TopRight,
			BottomRight
		}

		public float UpdateInterval = 5f;

		private float m_LastInterval;

		private int m_Frames;

		public FpsCounterAnchorPositions AnchorPosition = FpsCounterAnchorPositions.TopRight;

		private string htmlColorTag;

		private const string fpsLabel = "{0:2}</color> FPS \n{1:2} <#8080ff>MS";

		private TextMeshPro m_TextMeshPro;

		private Transform m_frameCounter_transform;

		private Camera m_camera;

		private FpsCounterAnchorPositions last_AnchorPosition;

		private void Awake()
		{
			if (base.enabled)
			{
				m_camera = Camera.main;
				Application.targetFrameRate = -1;
				GameObject gameObject = new GameObject("Frame Counter");
				m_TextMeshPro = gameObject.AddComponent<TextMeshPro>();
				m_TextMeshPro.font = Resources.Load("Fonts & Materials/LiberationSans SDF", typeof(TMP_FontAsset)) as TMP_FontAsset;
				m_TextMeshPro.fontSharedMaterial = Resources.Load("Fonts & Materials/LiberationSans SDF - Overlay", typeof(Material)) as Material;
				m_frameCounter_transform = gameObject.transform;
				m_frameCounter_transform.SetParent(m_camera.transform);
				m_frameCounter_transform.localRotation = Quaternion.identity;
				m_TextMeshPro.enableWordWrapping = false;
				m_TextMeshPro.fontSize = 24f;
				m_TextMeshPro.isOverlay = true;
				Set_FrameCounter_Position(AnchorPosition);
				last_AnchorPosition = AnchorPosition;
			}
		}

		private void Start()
		{
			m_LastInterval = Time.realtimeSinceStartup;
			m_Frames = 0;
		}

		private void Update()
		{
			if (AnchorPosition != last_AnchorPosition)
			{
				Set_FrameCounter_Position(AnchorPosition);
			}
			last_AnchorPosition = AnchorPosition;
			m_Frames++;
			float realtimeSinceStartup = Time.realtimeSinceStartup;
			if (realtimeSinceStartup > m_LastInterval + UpdateInterval)
			{
				float num = (float)m_Frames / (realtimeSinceStartup - m_LastInterval);
				float arg = 1000f / Mathf.Max(num, 1E-05f);
				if (num < 30f)
				{
					htmlColorTag = "<color=yellow>";
				}
				else if (num < 10f)
				{
					htmlColorTag = "<color=red>";
				}
				else
				{
					htmlColorTag = "<color=green>";
				}
				m_TextMeshPro.SetText(htmlColorTag + "{0:2}</color> FPS \n{1:2} <#8080ff>MS", num, arg);
				m_Frames = 0;
				m_LastInterval = realtimeSinceStartup;
			}
		}

		private void Set_FrameCounter_Position(FpsCounterAnchorPositions anchor_position)
		{
			m_TextMeshPro.margin = new Vector4(1f, 1f, 1f, 1f);
			switch (anchor_position)
			{
			case FpsCounterAnchorPositions.TopLeft:
				m_TextMeshPro.alignment = TextAlignmentOptions.TopLeft;
				m_TextMeshPro.rectTransform.pivot = new Vector2(0f, 1f);
				m_frameCounter_transform.position = m_camera.ViewportToWorldPoint(new Vector3(0f, 1f, 100f));
				break;
			case FpsCounterAnchorPositions.BottomLeft:
				m_TextMeshPro.alignment = TextAlignmentOptions.BottomLeft;
				m_TextMeshPro.rectTransform.pivot = new Vector2(0f, 0f);
				m_frameCounter_transform.position = m_camera.ViewportToWorldPoint(new Vector3(0f, 0f, 100f));
				break;
			case FpsCounterAnchorPositions.TopRight:
				m_TextMeshPro.alignment = TextAlignmentOptions.TopRight;
				m_TextMeshPro.rectTransform.pivot = new Vector2(1f, 1f);
				m_frameCounter_transform.position = m_camera.ViewportToWorldPoint(new Vector3(1f, 1f, 100f));
				break;
			case FpsCounterAnchorPositions.BottomRight:
				m_TextMeshPro.alignment = TextAlignmentOptions.BottomRight;
				m_TextMeshPro.rectTransform.pivot = new Vector2(1f, 0f);
				m_frameCounter_transform.position = m_camera.ViewportToWorldPoint(new Vector3(1f, 0f, 100f));
				break;
			}
		}
	}
	public class TMP_TextEventCheck : MonoBehaviour
	{
		public TMP_TextEventHandler TextEventHandler;

		private void OnEnable()
		{
			if (TextEventHandler != null)
			{
				TextEventHandler.onCharacterSelection.AddListener(OnCharacterSelection);
				TextEventHandler.onWordSelection.AddListener(OnWordSelection);
				TextEventHandler.onLineSelection.AddListener(OnLineSelection);
				TextEventHandler.onLinkSelection.AddListener(OnLinkSelection);
			}
		}

		private void OnDisable()
		{
			if (TextEventHandler != null)
			{
				TextEventHandler.onCharacterSelection.RemoveListener(OnCharacterSelection);
				TextEventHandler.onWordSelection.RemoveListener(OnWordSelection);
				TextEventHandler.onLineSelection.RemoveListener(OnLineSelection);
				TextEventHandler.onLinkSelection.RemoveListener(OnLinkSelection);
			}
		}

		private void OnCharacterSelection(char c, int index)
		{
			UnityEngine.Debug.Log("Character [" + c.ToString() + "] at Index: " + index + " has been selected.");
		}

		private void OnWordSelection(string word, int firstCharacterIndex, int length)
		{
			UnityEngine.Debug.Log("Word [" + word + "] with first character index of " + firstCharacterIndex + " and length of " + length + " has been selected.");
		}

		private void OnLineSelection(string lineText, int firstCharacterIndex, int length)
		{
			UnityEngine.Debug.Log("Line [" + lineText + "] with first character index of " + firstCharacterIndex + " and length of " + length + " has been selected.");
		}

		private void OnLinkSelection(string linkID, string linkText, int linkIndex)
		{
			UnityEngine.Debug.Log("Link Index: " + linkIndex + " with ID [" + linkID + "] and Text \"" + linkText + "\" has been selected.");
		}
	}
	[ExecuteInEditMode]
	public class TMP_TextInfoDebugTool : MonoBehaviour
	{
		public bool ShowCharacters;

		public bool ShowWords;

		public bool ShowLinks;

		public bool ShowLines;

		public bool ShowMeshBounds;

		public bool ShowTextBounds;

		[Space(10f)]
		[TextArea(2, 2)]
		public string ObjectStats;

		private TMP_Text m_TextComponent;

		private Transform m_Transform;
	}
	public class TMP_TextSelector_A : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler
	{
		private TextMeshPro m_TextMeshPro;

		private Camera m_Camera;

		private bool m_isHoveringObject;

		private int m_selectedLink = -1;

		private int m_lastCharIndex = -1;

		private int m_lastWordIndex = -1;

		private void Awake()
		{
			m_TextMeshPro = base.gameObject.GetComponent<TextMeshPro>();
			m_Camera = Camera.main;
			m_TextMeshPro.ForceMeshUpdate();
		}

		private void LateUpdate()
		{
			m_isHoveringObject = false;
			if (TMP_TextUtilities.IsIntersectingRectTransform(m_TextMeshPro.rectTransform, Input.mousePosition, Camera.main))
			{
				m_isHoveringObject = true;
			}
			if (!m_isHoveringObject)
			{
				return;
			}
			int num = TMP_TextUtilities.FindIntersectingCharacter(m_TextMeshPro, Input.mousePosition, Camera.main, visibleOnly: true);
			if (num != -1 && num != m_lastCharIndex && (Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.RightShift)))
			{
				m_lastCharIndex = num;
				int materialReferenceIndex = m_TextMeshPro.textInfo.characterInfo[num].materialReferenceIndex;
				int vertexIndex = m_TextMeshPro.textInfo.characterInfo[num].vertexIndex;
				Color32 color = new Color32((byte)UnityEngine.Random.Range(0, 255), (byte)UnityEngine.Random.Range(0, 255), (byte)UnityEngine.Random.Range(0, 255), byte.MaxValue);
				Color32[] colors = m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex].colors32;
				colors[vertexIndex] = color;
				colors[vertexIndex + 1] = color;
				colors[vertexIndex + 2] = color;
				colors[vertexIndex + 3] = color;
				m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex].mesh.colors32 = colors;
			}
			int num2 = TMP_TextUtilities.FindIntersectingLink(m_TextMeshPro, Input.mousePosition, m_Camera);
			if ((num2 == -1 && m_selectedLink != -1) || num2 != m_selectedLink)
			{
				m_selectedLink = -1;
			}
			if (num2 != -1 && num2 != m_selectedLink)
			{
				m_selectedLink = num2;
				TMP_LinkInfo tMP_LinkInfo = m_TextMeshPro.textInfo.linkInfo[num2];
				UnityEngine.Debug.Log("Link ID: \"" + tMP_LinkInfo.GetLinkID() + "\"   Link Text: \"" + tMP_LinkInfo.GetLinkText() + "\"");
				Vector3 worldPoint = Vector3.zero;
				RectTransformUtility.ScreenPointToWorldPointInRectangle(m_TextMeshPro.rectTransform, Input.mousePosition, m_Camera, out worldPoint);
				string linkID = tMP_LinkInfo.GetLinkID();
				if (!(linkID == "id_01"))
				{
					_ = linkID == "id_02";
				}
			}
			int num3 = TMP_TextUtilities.FindIntersectingWord(m_TextMeshPro, Input.mousePosition, Camera.main);
			if (num3 != -1 && num3 != m_lastWordIndex)
			{
				m_lastWordIndex = num3;
				TMP_WordInfo tMP_WordInfo = m_TextMeshPro.textInfo.wordInfo[num3];
				Vector3 position = m_TextMeshPro.transform.TransformPoint(m_TextMeshPro.textInfo.characterInfo[tMP_WordInfo.firstCharacterIndex].bottomLeft);
				position = Camera.main.WorldToScreenPoint(position);
				Color32[] colors2 = m_TextMeshPro.textInfo.meshInfo[0].colors32;
				Color32 color2 = new Color32((byte)UnityEngine.Random.Range(0, 255), (byte)UnityEngine.Random.Range(0, 255), (byte)UnityEngine.Random.Range(0, 255), byte.MaxValue);
				for (int i = 0; i < tMP_WordInfo.characterCount; i++)
				{
					int vertexIndex2 = m_TextMeshPro.textInfo.characterInfo[tMP_WordInfo.firstCharacterIndex + i].vertexIndex;
					colors2[vertexIndex2] = color2;
					colors2[vertexIndex2 + 1] = color2;
					colors2[vertexIndex2 + 2] = color2;
					colors2[vertexIndex2 + 3] = color2;
				}
				m_TextMeshPro.mesh.colors32 = colors2;
			}
		}

		public void OnPointerEnter(PointerEventData eventData)
		{
			UnityEngine.Debug.Log("OnPointerEnter()");
			m_isHoveringObject = true;
		}

		public void OnPointerExit(PointerEventData eventData)
		{
			UnityEngine.Debug.Log("OnPointerExit()");
			m_isHoveringObject = false;
		}
	}
	public class TMP_TextSelector_B : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler, IPointerClickHandler, IPointerUpHandler
	{
		public RectTransform TextPopup_Prefab_01;

		private RectTransform m_TextPopup_RectTransform;

		private TextMeshProUGUI m_TextPopup_TMPComponent;

		private const string k_LinkText = "You have selected link <#ffff00>";

		private const string k_WordText = "Word Index: <#ffff00>";

		private TextMeshProUGUI m_TextMeshPro;

		private Canvas m_Canvas;

		private Camera m_Camera;

		private bool isHoveringObject;

		private int m_selectedWord = -1;

		private int m_selectedLink = -1;

		private int m_lastIndex = -1;

		private Matrix4x4 m_matrix;

		private TMP_MeshInfo[] m_cachedMeshInfoVertexData;

		private void Awake()
		{
			m_TextMeshPro = base.gameObject.GetComponent<TextMeshProUGUI>();
			m_Canvas = base.gameObject.GetComponentInParent<Canvas>();
			if (m_Canvas.renderMode == RenderMode.ScreenSpaceOverlay)
			{
				m_Camera = null;
			}
			else
			{
				m_Camera = m_Canvas.worldCamera;
			}
			m_TextPopup_RectTransform = UnityEngine.Object.Instantiate(TextPopup_Prefab_01);
			m_TextPopup_RectTransform.SetParent(m_Canvas.transform, worldPositionStays: false);
			m_TextPopup_TMPComponent = m_TextPopup_RectTransform.GetComponentInChildren<TextMeshProUGUI>();
			m_TextPopup_RectTransform.gameObject.SetActive(value: false);
		}

		private void OnEnable()
		{
			TMPro_EventManager.TEXT_CHANGED_EVENT.Add(ON_TEXT_CHANGED);
		}

		private void OnDisable()
		{
			TMPro_EventManager.TEXT_CHANGED_EVENT.Remove(ON_TEXT_CHANGED);
		}

		private void ON_TEXT_CHANGED(UnityEngine.Object obj)
		{
			if (obj == m_TextMeshPro)
			{
				m_cachedMeshInfoVertexData = m_TextMeshPro.textInfo.CopyMeshInfoVertexData();
			}
		}

		private void LateUpdate()
		{
			if (isHoveringObject)
			{
				int num = TMP_TextUtilities.FindIntersectingCharacter(m_TextMeshPro, Input.mousePosition, m_Camera, visibleOnly: true);
				if (num == -1 || num != m_lastIndex)
				{
					RestoreCachedVertexAttributes(m_lastIndex);
					m_lastIndex = -1;
				}
				if (num != -1 && num != m_lastIndex && (Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.RightShift)))
				{
					m_lastIndex = num;
					int materialReferenceIndex = m_TextMeshPro.textInfo.characterInfo[num].materialReferenceIndex;
					int vertexIndex = m_TextMeshPro.textInfo.characterInfo[num].vertexIndex;
					Vector3[] vertices = m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex].vertices;
					Vector3 vector = (Vector2)((vertices[vertexIndex] + vertices[vertexIndex + 2]) / 2f);
					vertices[vertexIndex] -= vector;
					vertices[vertexIndex + 1] -= vector;
					vertices[vertexIndex + 2] -= vector;
					vertices[vertexIndex + 3] -= vector;
					float num2 = 1.5f;
					m_matrix = Matrix4x4.TRS(Vector3.zero, Quaternion.identity, Vector3.one * num2);
					vertices[vertexIndex] = m_matrix.MultiplyPoint3x4(vertices[vertexIndex]);
					vertices[vertexIndex + 1] = m_matrix.MultiplyPoint3x4(vertices[vertexIndex + 1]);
					vertices[vertexIndex + 2] = m_matrix.MultiplyPoint3x4(vertices[vertexIndex + 2]);
					vertices[vertexIndex + 3] = m_matrix.MultiplyPoint3x4(vertices[vertexIndex + 3]);
					vertices[vertexIndex] += vector;
					vertices[vertexIndex + 1] += vector;
					vertices[vertexIndex + 2] += vector;
					vertices[vertexIndex + 3] += vector;
					Color32 color = new Color32(byte.MaxValue, byte.MaxValue, 192, byte.MaxValue);
					Color32[] colors = m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex].colors32;
					colors[vertexIndex] = color;
					colors[vertexIndex + 1] = color;
					colors[vertexIndex + 2] = color;
					colors[vertexIndex + 3] = color;
					TMP_MeshInfo tMP_MeshInfo = m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex];
					int dst = vertices.Length - 4;
					tMP_MeshInfo.SwapVertexData(vertexIndex, dst);
					m_TextMeshPro.UpdateVertexData(TMP_VertexDataUpdateFlags.All);
				}
				int num3 = TMP_TextUtilities.FindIntersectingWord(m_TextMeshPro, Input.mousePosition, m_Camera);
				if (m_TextPopup_RectTransform != null && m_selectedWord != -1 && (num3 == -1 || num3 != m_selectedWord))
				{
					TMP_WordInfo tMP_WordInfo = m_TextMeshPro.textInfo.wordInfo[m_selectedWord];
					for (int i = 0; i < tMP_WordInfo.characterCount; i++)
					{
						int num4 = tMP_WordInfo.firstCharacterIndex + i;
						int materialReferenceIndex2 = m_TextMeshPro.textInfo.characterInfo[num4].materialReferenceIndex;
						int vertexIndex2 = m_TextMeshPro.textInfo.characterInfo[num4].vertexIndex;
						Color32[] colors2 = m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex2].colors32;
						colors2[vertexIndex2 + 3] = (colors2[vertexIndex2 + 2] = (colors2[vertexIndex2 + 1] = (colors2[vertexIndex2] = colors2[vertexIndex2].Tint(1.33333f))));
					}
					m_TextMeshPro.UpdateVertexData(TMP_VertexDataUpdateFlags.All);
					m_selectedWord = -1;
				}
				if (num3 != -1 && num3 != m_selectedWord && !Input.GetKey(KeyCode.LeftShift) && !Input.GetKey(KeyCode.RightShift))
				{
					m_selectedWord = num3;
					TMP_WordInfo tMP_WordInfo2 = m_TextMeshPro.textInfo.wordInfo[num3];
					for (int j = 0; j < tMP_WordInfo2.characterCount; j++)
					{
						int num5 = tMP_WordInfo2.firstCharacterIndex + j;
						int materialReferenceIndex3 = m_TextMeshPro.textInfo.characterInfo[num5].materialReferenceIndex;
						int vertexIndex3 = m_TextMeshPro.textInfo.characterInfo[num5].vertexIndex;
						Color32[] colors3 = m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex3].colors32;
						colors3[vertexIndex3 + 3] = (colors3[vertexIndex3 + 2] = (colors3[vertexIndex3 + 1] = (colors3[vertexIndex3] = colors3[vertexIndex3].Tint(0.75f))));
					}
					m_TextMeshPro.UpdateVertexData(TMP_VertexDataUpdateFlags.All);
				}
				int num6 = TMP_TextUtilities.FindIntersectingLink(m_TextMeshPro, Input.mousePosition, m_Camera);
				if ((num6 == -1 && m_selectedLink != -1) || num6 != m_selectedLink)
				{
					m_TextPopup_RectTransform.gameObject.SetActive(value: false);
					m_selectedLink = -1;
				}
				if (num6 == -1 || num6 == m_selectedLink)
				{
					return;
				}
				m_selectedLink = num6;
				TMP_LinkInfo tMP_LinkInfo = m_TextMeshPro.textInfo.linkInfo[num6];
				Vector3 worldPoint = Vector3.zero;
				RectTransformUtility.ScreenPointToWorldPointInRectangle(m_TextMeshPro.rectTransform, Input.mousePosition, m_Camera, out worldPoint);
				string linkID = tMP_LinkInfo.GetLinkID();
				if (!(linkID == "id_01"))
				{
					if (linkID == "id_02")
					{
						m_TextPopup_RectTransform.position = worldPoint;
						m_TextPopup_RectTransform.gameObject.SetActive(value: true);
						m_TextPopup_TMPComponent.text = "You have selected link <#ffff00> ID 02";
					}
				}
				else
				{
					m_TextPopup_RectTransform.position = worldPoint;
					m_TextPopup_RectTransform.gameObject.SetActive(value: true);
					m_TextPopup_TMPComponent.text = "You have selected link <#ffff00> ID 01";
				}
			}
			else if (m_lastIndex != -1)
			{
				RestoreCachedVertexAttributes(m_lastIndex);
				m_lastIndex = -1;
			}
		}

		public void OnPointerEnter(PointerEventData eventData)
		{
			isHoveringObject = true;
		}

		public void OnPointerExit(PointerEventData eventData)
		{
			isHoveringObject = false;
		}

		public void OnPointerClick(PointerEventData eventData)
		{
		}

		public void OnPointerUp(PointerEventData eventData)
		{
		}

		private void RestoreCachedVertexAttributes(int index)
		{
			if (index != -1 && index <= m_TextMeshPro.textInfo.characterCount - 1)
			{
				int materialReferenceIndex = m_TextMeshPro.textInfo.characterInfo[index].materialReferenceIndex;
				int vertexIndex = m_TextMeshPro.textInfo.characterInfo[index].vertexIndex;
				Vector3[] vertices = m_cachedMeshInfoVertexData[materialReferenceIndex].vertices;
				Vector3[] vertices2 = m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex].vertices;
				vertices2[vertexIndex] = vertices[vertexIndex];
				vertices2[vertexIndex + 1] = vertices[vertexIndex + 1];
				vertices2[vertexIndex + 2] = vertices[vertexIndex + 2];
				vertices2[vertexIndex + 3] = vertices[vertexIndex + 3];
				Color32[] colors = m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex].colors32;
				Color32[] colors2 = m_cachedMeshInfoVertexData[materialReferenceIndex].colors32;
				colors[vertexIndex] = colors2[vertexIndex];
				colors[vertexIndex + 1] = colors2[vertexIndex + 1];
				colors[vertexIndex + 2] = colors2[vertexIndex + 2];
				colors[vertexIndex + 3] = colors2[vertexIndex + 3];
				Vector2[] uvs = m_cachedMeshInfoVertexData[materialReferenceIndex].uvs0;
				Vector2[] uvs2 = m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex].uvs0;
				uvs2[vertexIndex] = uvs[vertexIndex];
				uvs2[vertexIndex + 1] = uvs[vertexIndex + 1];
				uvs2[vertexIndex + 2] = uvs[vertexIndex + 2];
				uvs2[vertexIndex + 3] = uvs[vertexIndex + 3];
				Vector2[] uvs3 = m_cachedMeshInfoVertexData[materialReferenceIndex].uvs2;
				Vector2[] uvs4 = m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex].uvs2;
				uvs4[vertexIndex] = uvs3[vertexIndex];
				uvs4[vertexIndex + 1] = uvs3[vertexIndex + 1];
				uvs4[vertexIndex + 2] = uvs3[vertexIndex + 2];
				uvs4[vertexIndex + 3] = uvs3[vertexIndex + 3];
				int num = (vertices.Length / 4 - 1) * 4;
				vertices2[num] = vertices[num];
				vertices2[num + 1] = vertices[num + 1];
				vertices2[num + 2] = vertices[num + 2];
				vertices2[num + 3] = vertices[num + 3];
				colors2 = m_cachedMeshInfoVertexData[materialReferenceIndex].colors32;
				Color32[] colors3 = m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex].colors32;
				colors3[num] = colors2[num];
				colors3[num + 1] = colors2[num + 1];
				colors3[num + 2] = colors2[num + 2];
				colors3[num + 3] = colors2[num + 3];
				uvs = m_cachedMeshInfoVertexData[materialReferenceIndex].uvs0;
				Vector2[] uvs5 = m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex].uvs0;
				uvs5[num] = uvs[num];
				uvs5[num + 1] = uvs[num + 1];
				uvs5[num + 2] = uvs[num + 2];
				uvs5[num + 3] = uvs[num + 3];
				uvs3 = m_cachedMeshInfoVertexData[materialReferenceIndex].uvs2;
				Vector2[] uvs6 = m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex].uvs2;
				uvs6[num] = uvs3[num];
				uvs6[num + 1] = uvs3[num + 1];
				uvs6[num + 2] = uvs3[num + 2];
				uvs6[num + 3] = uvs3[num + 3];
				m_TextMeshPro.UpdateVertexData(TMP_VertexDataUpdateFlags.All);
			}
		}
	}
	public class TMP_UiFrameRateCounter : MonoBehaviour
	{
		public enum FpsCounterAnchorPositions
		{
			TopLeft,
			BottomLeft,
			TopRight,
			BottomRight
		}

		public float UpdateInterval = 5f;

		private float m_LastInterval;

		private int m_Frames;

		public FpsCounterAnchorPositions AnchorPosition = FpsCounterAnchorPositions.TopRight;

		private string htmlColorTag;

		private const string fpsLabel = "{0:2}</color> FPS \n{1:2} <#8080ff>MS";

		private TextMeshProUGUI m_TextMeshPro;

		private RectTransform m_frameCounter_transform;

		private FpsCounterAnchorPositions last_AnchorPosition;

		private void Awake()
		{
			if (base.enabled)
			{
				Application.targetFrameRate = 120;
				GameObject gameObject = new GameObject("Frame Counter");
				m_frameCounter_transform = gameObject.AddComponent<RectTransform>();
				m_frameCounter_transform.SetParent(base.transform, worldPositionStays: false);
				m_TextMeshPro = gameObject.AddComponent<TextMeshProUGUI>();
				m_TextMeshPro.font = Resources.Load("Fonts & Materials/LiberationSans SDF", typeof(TMP_FontAsset)) as TMP_FontAsset;
				m_TextMeshPro.fontSharedMaterial = Resources.Load("Fonts & Materials/LiberationSans SDF - Overlay", typeof(Material)) as Material;
				m_TextMeshPro.enableWordWrapping = false;
				m_TextMeshPro.fontSize = 36f;
				m_TextMeshPro.isOverlay = true;
				Set_FrameCounter_Position(AnchorPosition);
				last_AnchorPosition = AnchorPosition;
			}
		}

		private void Start()
		{
			m_LastInterval = Time.realtimeSinceStartup;
			m_Frames = 0;
		}

		private void Update()
		{
			if (AnchorPosition != last_AnchorPosition)
			{
				Set_FrameCounter_Position(AnchorPosition);
			}
			last_AnchorPosition = AnchorPosition;
			m_Frames++;
			float realtimeSinceStartup = Time.realtimeSinceStartup;
			if (realtimeSinceStartup > m_LastInterval + UpdateInterval)
			{
				float num = (float)m_Frames / (realtimeSinceStartup - m_LastInterval);
				float arg = 1000f / Mathf.Max(num, 1E-05f);
				if (num < 30f)
				{
					htmlColorTag = "<color=yellow>";
				}
				else if (num < 10f)
				{
					htmlColorTag = "<color=red>";
				}
				else
				{
					htmlColorTag = "<color=green>";
				}
				m_TextMeshPro.SetText(htmlColorTag + "{0:2}</color> FPS \n{1:2} <#8080ff>MS", num, arg);
				m_Frames = 0;
				m_LastInterval = realtimeSinceStartup;
			}
		}

		private void Set_FrameCounter_Position(FpsCounterAnchorPositions anchor_position)
		{
			switch (anchor_position)
			{
			case FpsCounterAnchorPositions.TopLeft:
				m_TextMeshPro.alignment = TextAlignmentOptions.TopLeft;
				m_frameCounter_transform.pivot = new Vector2(0f, 1f);
				m_frameCounter_transform.anchorMin = new Vector2(0.01f, 0.99f);
				m_frameCounter_transform.anchorMax = new Vector2(0.01f, 0.99f);
				m_frameCounter_transform.anchoredPosition = new Vector2(0f, 1f);
				break;
			case FpsCounterAnchorPositions.BottomLeft:
				m_TextMeshPro.alignment = TextAlignmentOptions.BottomLeft;
				m_frameCounter_transform.pivot = new Vector2(0f, 0f);
				m_frameCounter_transform.anchorMin = new Vector2(0.01f, 0.01f);
				m_frameCounter_transform.anchorMax = new Vector2(0.01f, 0.01f);
				m_frameCounter_transform.anchoredPosition = new Vector2(0f, 0f);
				break;
			case FpsCounterAnchorPositions.TopRight:
				m_TextMeshPro.alignment = TextAlignmentOptions.TopRight;
				m_frameCounter_transform.pivot = new Vector2(1f, 1f);
				m_frameCounter_transform.anchorMin = new Vector2(0.99f, 0.99f);
				m_frameCounter_transform.anchorMax = new Vector2(0.99f, 0.99f);
				m_frameCounter_transform.anchoredPosition = new Vector2(1f, 1f);
				break;
			case FpsCounterAnchorPositions.BottomRight:
				m_TextMeshPro.alignment = TextAlignmentOptions.BottomRight;
				m_frameCounter_transform.pivot = new Vector2(1f, 0f);
				m_frameCounter_transform.anchorMin = new Vector2(0.99f, 0.01f);
				m_frameCounter_transform.anchorMax = new Vector2(0.99f, 0.01f);
				m_frameCounter_transform.anchoredPosition = new Vector2(1f, 0f);
				break;
			}
		}
	}
	public class TMPro_InstructionOverlay : MonoBehaviour
	{
		public enum FpsCounterAnchorPositions
		{
			TopLeft,
			BottomLeft,
			TopRight,
			BottomRight
		}

		public FpsCounterAnchorPositions AnchorPosition = FpsCounterAnchorPositions.BottomLeft;

		private const string instructions = "Camera Control - <#ffff00>Shift + RMB\n</color>Zoom - <#ffff00>Mouse wheel.";

		private TextMeshPro m_TextMeshPro;

		private TextContainer m_textContainer;

		private Transform m_frameCounter_transform;

		private Camera m_camera;

		private void Awake()
		{
			if (base.enabled)
			{
				m_camera = Camera.main;
				GameObject gameObject = new GameObject("Frame Counter");
				m_frameCounter_transform = gameObject.transform;
				m_frameCounter_transform.parent = m_camera.transform;
				m_frameCounter_transform.localRotation = Quaternion.identity;
				m_TextMeshPro = gameObject.AddComponent<TextMeshPro>();
				m_TextMeshPro.font = Resources.Load("Fonts & Materials/LiberationSans SDF", typeof(TMP_FontAsset)) as TMP_FontAsset;
				m_TextMeshPro.fontSharedMaterial = Resources.Load("Fonts & Materials/LiberationSans SDF - Overlay", typeof(Material)) as Material;
				m_TextMeshPro.fontSize = 30f;
				m_TextMeshPro.isOverlay = true;
				m_textContainer = gameObject.GetComponent<TextContainer>();
				Set_FrameCounter_Position(AnchorPosition);
				m_TextMeshPro.text = "Camera Control - <#ffff00>Shift + RMB\n</color>Zoom - <#ffff00>Mouse wheel.";
			}
		}

		private void Set_FrameCounter_Position(FpsCounterAnchorPositions anchor_position)
		{
			switch (anchor_position)
			{
			case FpsCounterAnchorPositions.TopLeft:
				m_textContainer.anchorPosition = TextContainerAnchors.TopLeft;
				m_frameCounter_transform.position = m_camera.ViewportToWorldPoint(new Vector3(0f, 1f, 100f));
				break;
			case FpsCounterAnchorPositions.BottomLeft:
				m_textContainer.anchorPosition = TextContainerAnchors.BottomLeft;
				m_frameCounter_transform.position = m_camera.ViewportToWorldPoint(new Vector3(0f, 0f, 100f));
				break;
			case FpsCounterAnchorPositions.TopRight:
				m_textContainer.anchorPosition = TextContainerAnchors.TopRight;
				m_frameCounter_transform.position = m_camera.ViewportToWorldPoint(new Vector3(1f, 1f, 100f));
				break;
			case FpsCounterAnchorPositions.BottomRight:
				m_textContainer.anchorPosition = TextContainerAnchors.BottomRight;
				m_frameCounter_transform.position = m_camera.ViewportToWorldPoint(new Vector3(1f, 0f, 100f));
				break;
			}
		}
	}
	public class VertexColorCycler : MonoBehaviour
	{
		private TMP_Text m_TextComponent;

		private void Awake()
		{
			m_TextComponent = GetComponent<TMP_Text>();
		}

		private void Start()
		{
			StartCoroutine(AnimateVertexColors());
		}

		private IEnumerator AnimateVertexColors()
		{
			TMP_TextInfo textInfo = m_TextComponent.textInfo;
			int currentCharacter = 0;
			_ = (Color32)m_TextComponent.color;
			while (true)
			{
				int characterCount = textInfo.characterCount;
				if (characterCount == 0)
				{
					yield return Yield.WaitSeconds(0.25f);
					continue;
				}
				int materialReferenceIndex = textInfo.characterInfo[currentCharacter].materialReferenceIndex;
				Color32[] colors = textInfo.meshInfo[materialReferenceIndex].colors32;
				int vertexIndex = textInfo.characterInfo[currentCharacter].vertexIndex;
				if (textInfo.characterInfo[currentCharacter].isVisible)
				{
					colors[vertexIndex + 3] = (colors[vertexIndex + 2] = (colors[vertexIndex + 1] = (colors[vertexIndex] = new Color32((byte)UnityEngine.Random.Range(0, 255), (byte)UnityEngine.Random.Range(0, 255), (byte)UnityEngine.Random.Range(0, 255), byte.MaxValue))));
					m_TextComponent.UpdateVertexData(TMP_VertexDataUpdateFlags.Colors32);
				}
				currentCharacter = (currentCharacter + 1) % characterCount;
				yield return Yield.WaitSeconds(0.05f);
			}
		}
	}
	public class VertexJitter : MonoBehaviour
	{
		private struct VertexAnim
		{
			public float angleRange;

			public float angle;

			public float speed;
		}

		public float AngleMultiplier = 1f;

		public float SpeedMultiplier = 1f;

		public float CurveScale = 1f;

		private TMP_Text m_TextComponent;

		private bool hasTextChanged;

		private void Awake()
		{
			m_TextComponent = GetComponent<TMP_Text>();
		}

		private void OnEnable()
		{
			TMPro_EventManager.TEXT_CHANGED_EVENT.Add(ON_TEXT_CHANGED);
		}

		private void OnDisable()
		{
			TMPro_EventManager.TEXT_CHANGED_EVENT.Remove(ON_TEXT_CHANGED);
		}

		private void Start()
		{
			StartCoroutine(AnimateVertexColors());
		}

		private void ON_TEXT_CHANGED(UnityEngine.Object obj)
		{
			if (obj == m_TextComponent)
			{
				hasTextChanged = true;
			}
		}

		private IEnumerator AnimateVertexColors()
		{
			m_TextComponent.ForceMeshUpdate();
			TMP_TextInfo textInfo = m_TextComponent.textInfo;
			int loopCount = 0;
			hasTextChanged = true;
			VertexAnim[] vertexAnim = new VertexAnim[1024];
			for (int i = 0; i < 1024; i++)
			{
				vertexAnim[i].angleRange = UnityEngine.Random.Range(10f, 25f);
				vertexAnim[i].speed = UnityEngine.Random.Range(1f, 3f);
			}
			TMP_MeshInfo[] cachedMeshInfo = textInfo.CopyMeshInfoVertexData();
			while (true)
			{
				if (hasTextChanged)
				{
					cachedMeshInfo = textInfo.CopyMeshInfoVertexData();
					hasTextChanged = false;
				}
				int characterCount = textInfo.characterCount;
				if (characterCount == 0)
				{
					yield return Yield.WaitSeconds(0.25f);
					continue;
				}
				for (int j = 0; j < characterCount; j++)
				{
					if (textInfo.characterInfo[j].isVisible)
					{
						VertexAnim vertexAnim2 = vertexAnim[j];
						int materialReferenceIndex = textInfo.characterInfo[j].materialReferenceIndex;
						int vertexIndex = textInfo.characterInfo[j].vertexIndex;
						Vector3[] vertices = cachedMeshInfo[materialReferenceIndex].vertices;
						Vector3 vector = (Vector2)((vertices[vertexIndex] + vertices[vertexIndex + 2]) / 2f);
						Vector3[] vertices2 = textInfo.meshInfo[materialReferenceIndex].vertices;
						vertices2[vertexIndex] = vertices[vertexIndex] - vector;
						vertices2[vertexIndex + 1] = vertices[vertexIndex + 1] - vector;
						vertices2[vertexIndex + 2] = vertices[vertexIndex + 2] - vector;
						vertices2[vertexIndex + 3] = vertices[vertexIndex + 3] - vector;
						vertexAnim2.angle = Mathf.SmoothStep(0f - vertexAnim2.angleRange, vertexAnim2.angleRange, Mathf.PingPong((float)loopCount / 25f * vertexAnim2.speed, 1f));
						Matrix4x4 matrix4x = Matrix4x4.TRS(new Vector3(UnityEngine.Random.Range(-0.25f, 0.25f), UnityEngine.Random.Range(-0.25f, 0.25f), 0f) * CurveScale, Quaternion.Euler(0f, 0f, UnityEngine.Random.Range(-5f, 5f) * AngleMultiplier), Vector3.one);
						vertices2[vertexIndex] = matrix4x.MultiplyPoint3x4(vertices2[vertexIndex]);
						vertices2[vertexIndex + 1] = matrix4x.MultiplyPoint3x4(vertices2[vertexIndex + 1]);
						vertices2[vertexIndex + 2] = matrix4x.MultiplyPoint3x4(vertices2[vertexIndex + 2]);
						vertices2[vertexIndex + 3] = matrix4x.MultiplyPoint3x4(vertices2[vertexIndex + 3]);
						vertices2[vertexIndex] += vector;
						vertices2[vertexIndex + 1] += vector;
						vertices2[vertexIndex + 2] += vector;
						vertices2[vertexIndex + 3] += vector;
						vertexAnim[j] = vertexAnim2;
					}
				}
				for (int k = 0; k < textInfo.meshInfo.Length; k++)
				{
					textInfo.meshInfo[k].mesh.vertices = textInfo.meshInfo[k].vertices;
					m_TextComponent.UpdateGeometry(textInfo.meshInfo[k].mesh, k);
				}
				loopCount++;
				yield return Yield.WaitSeconds(0.1f);
			}
		}
	}
	public class VertexShakeA : MonoBehaviour
	{
		public float AngleMultiplier = 1f;

		public float SpeedMultiplier = 1f;

		public float ScaleMultiplier = 1f;

		public float RotationMultiplier = 1f;

		private TMP_Text m_TextComponent;

		private bool hasTextChanged;

		private void Awake()
		{
			m_TextComponent = GetComponent<TMP_Text>();
		}

		private void OnEnable()
		{
			TMPro_EventManager.TEXT_CHANGED_EVENT.Add(ON_TEXT_CHANGED);
		}

		private void OnDisable()
		{
			TMPro_EventManager.TEXT_CHANGED_EVENT.Remove(ON_TEXT_CHANGED);
		}

		private void Start()
		{
			StartCoroutine(AnimateVertexColors());
		}

		private void ON_TEXT_CHANGED(UnityEngine.Object obj)
		{
			if ((bool)(obj = m_TextComponent))
			{
				hasTextChanged = true;
			}
		}

		private IEnumerator AnimateVertexColors()
		{
			m_TextComponent.ForceMeshUpdate();
			TMP_TextInfo textInfo = m_TextComponent.textInfo;
			Vector3[][] copyOfVertices = new Vector3[0][];
			hasTextChanged = true;
			while (true)
			{
				if (hasTextChanged)
				{
					if (copyOfVertices.Length < textInfo.meshInfo.Length)
					{
						copyOfVertices = new Vector3[textInfo.meshInfo.Length][];
					}
					for (int i = 0; i < textInfo.meshInfo.Length; i++)
					{
						int num = textInfo.meshInfo[i].vertices.Length;
						copyOfVertices[i] = new Vector3[num];
					}
					hasTextChanged = false;
				}
				if (textInfo.characterCount == 0)
				{
					yield return Yield.WaitSeconds(0.25f);
					continue;
				}
				int lineCount = textInfo.lineCount;
				for (int j = 0; j < lineCount; j++)
				{
					int firstCharacterIndex = textInfo.lineInfo[j].firstCharacterIndex;
					int lastCharacterIndex = textInfo.lineInfo[j].lastCharacterIndex;
					Vector3 vector = (textInfo.characterInfo[firstCharacterIndex].bottomLeft + textInfo.characterInfo[lastCharacterIndex].topRight) / 2f;
					Quaternion q = Quaternion.Euler(0f, 0f, UnityEngine.Random.Range(-0.25f, 0.25f) * RotationMultiplier);
					for (int k = firstCharacterIndex; k <= lastCharacterIndex; k++)
					{
						if (textInfo.characterInfo[k].isVisible)
						{
							int materialReferenceIndex = textInfo.characterInfo[k].materialReferenceIndex;
							int vertexIndex = textInfo.characterInfo[k].vertexIndex;
							Vector3[] vertices = textInfo.meshInfo[materialReferenceIndex].vertices;
							copyOfVertices[materialReferenceIndex][vertexIndex] = vertices[vertexIndex] - vector;
							copyOfVertices[materialReferenceIndex][vertexIndex + 1] = vertices[vertexIndex + 1] - vector;
							copyOfVertices[materialReferenceIndex][vertexIndex + 2] = vertices[vertexIndex + 2] - vector;
							copyOfVertices[materialReferenceIndex][vertexIndex + 3] = vertices[vertexIndex + 3] - vector;
							float num2 = UnityEngine.Random.Range(0.995f - 0.001f * ScaleMultiplier, 1.005f + 0.001f * ScaleMultiplier);
							Matrix4x4 matrix4x = Matrix4x4.TRS(Vector3.one, q, Vector3.one * num2);
							copyOfVertices[materialReferenceIndex][vertexIndex] = matrix4x.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex]);
							copyOfVertices[materialReferenceIndex][vertexIndex + 1] = matrix4x.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex + 1]);
							copyOfVertices[materialReferenceIndex][vertexIndex + 2] = matrix4x.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex + 2]);
							copyOfVertices[materialReferenceIndex][vertexIndex + 3] = matrix4x.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex + 3]);
							copyOfVertices[materialReferenceIndex][vertexIndex] += vector;
							copyOfVertices[materialReferenceIndex][vertexIndex + 1] += vector;
							copyOfVertices[materialReferenceIndex][vertexIndex + 2] += vector;
							copyOfVertices[materialReferenceIndex][vertexIndex + 3] += vector;
						}
					}
				}
				for (int l = 0; l < textInfo.meshInfo.Length; l++)
				{
					textInfo.meshInfo[l].mesh.vertices = copyOfVertices[l];
					m_TextComponent.UpdateGeometry(textInfo.meshInfo[l].mesh, l);
				}
				yield return Yield.WaitSeconds(0.1f);
			}
		}
	}
	public class VertexShakeB : MonoBehaviour
	{
		public float AngleMultiplier = 1f;

		public float SpeedMultiplier = 1f;

		public float CurveScale = 1f;

		private TMP_Text m_TextComponent;

		private bool hasTextChanged;

		private void Awake()
		{
			m_TextComponent = GetComponent<TMP_Text>();
		}

		private void OnEnable()
		{
			TMPro_EventManager.TEXT_CHANGED_EVENT.Add(ON_TEXT_CHANGED);
		}

		private void OnDisable()
		{
			TMPro_EventManager.TEXT_CHANGED_EVENT.Remove(ON_TEXT_CHANGED);
		}

		private void Start()
		{
			StartCoroutine(AnimateVertexColors());
		}

		private void ON_TEXT_CHANGED(UnityEngine.Object obj)
		{
			if ((bool)(obj = m_TextComponent))
			{
				hasTextChanged = true;
			}
		}

		private IEnumerator AnimateVertexColors()
		{
			m_TextComponent.ForceMeshUpdate();
			TMP_TextInfo textInfo = m_TextComponent.textInfo;
			Vector3[][] copyOfVertices = new Vector3[0][];
			hasTextChanged = true;
			while (true)
			{
				if (hasTextChanged)
				{
					if (copyOfVertices.Length < textInfo.meshInfo.Length)
					{
						copyOfVertices = new Vector3[textInfo.meshInfo.Length][];
					}
					for (int i = 0; i < textInfo.meshInfo.Length; i++)
					{
						int num = textInfo.meshInfo[i].vertices.Length;
						copyOfVertices[i] = new Vector3[num];
					}
					hasTextChanged = false;
				}
				if (textInfo.characterCount == 0)
				{
					yield return Yield.WaitSeconds(0.25f);
					continue;
				}
				int lineCount = textInfo.lineCount;
				for (int j = 0; j < lineCount; j++)
				{
					int firstCharacterIndex = textInfo.lineInfo[j].firstCharacterIndex;
					int lastCharacterIndex = textInfo.lineInfo[j].lastCharacterIndex;
					Vector3 vector = (textInfo.characterInfo[firstCharacterIndex].bottomLeft + textInfo.characterInfo[lastCharacterIndex].topRight) / 2f;
					Quaternion q = Quaternion.Euler(0f, 0f, UnityEngine.Random.Range(-0.25f, 0.25f));
					for (int k = firstCharacterIndex; k <= lastCharacterIndex; k++)
					{
						if (textInfo.characterInfo[k].isVisible)
						{
							int materialReferenceIndex = textInfo.characterInfo[k].materialReferenceIndex;
							int vertexIndex = textInfo.characterInfo[k].vertexIndex;
							Vector3[] vertices = textInfo.meshInfo[materialReferenceIndex].vertices;
							Vector3 vector2 = (vertices[vertexIndex] + vertices[vertexIndex + 2]) / 2f;
							copyOfVertices[materialReferenceIndex][vertexIndex] = vertices[vertexIndex] - vector2;
							copyOfVertices[materialReferenceIndex][vertexIndex + 1] = vertices[vertexIndex + 1] - vector2;
							copyOfVertices[materialReferenceIndex][vertexIndex + 2] = vertices[vertexIndex + 2] - vector2;
							copyOfVertices[materialReferenceIndex][vertexIndex + 3] = vertices[vertexIndex + 3] - vector2;
							float num2 = UnityEngine.Random.Range(0.95f, 1.05f);
							Matrix4x4 matrix4x = Matrix4x4.TRS(Vector3.one, Quaternion.identity, Vector3.one * num2);
							copyOfVertices[materialReferenceIndex][vertexIndex] = matrix4x.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex]);
							copyOfVertices[materialReferenceIndex][vertexIndex + 1] = matrix4x.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex + 1]);
							copyOfVertices[materialReferenceIndex][vertexIndex + 2] = matrix4x.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex + 2]);
							copyOfVertices[materialReferenceIndex][vertexIndex + 3] = matrix4x.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex + 3]);
							copyOfVertices[materialReferenceIndex][vertexIndex] += vector2;
							copyOfVertices[materialReferenceIndex][vertexIndex + 1] += vector2;
							copyOfVertices[materialReferenceIndex][vertexIndex + 2] += vector2;
							copyOfVertices[materialReferenceIndex][vertexIndex + 3] += vector2;
							copyOfVertices[materialReferenceIndex][vertexIndex] -= vector;
							copyOfVertices[materialReferenceIndex][vertexIndex + 1] -= vector;
							copyOfVertices[materialReferenceIndex][vertexIndex + 2] -= vector;
							copyOfVertices[materialReferenceIndex][vertexIndex + 3] -= vector;
							matrix4x = Matrix4x4.TRS(Vector3.one, q, Vector3.one);
							copyOfVertices[materialReferenceIndex][vertexIndex] = matrix4x.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex]);
							copyOfVertices[materialReferenceIndex][vertexIndex + 1] = matrix4x.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex + 1]);
							copyOfVertices[materialReferenceIndex][vertexIndex + 2] = matrix4x.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex + 2]);
							copyOfVertices[materialReferenceIndex][vertexIndex + 3] = matrix4x.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex + 3]);
							copyOfVertices[materialReferenceIndex][vertexIndex] += vector;
							copyOfVertices[materialReferenceIndex][vertexIndex + 1] += vector;
							copyOfVertices[materialReferenceIndex][vertexIndex + 2] += vector;
							copyOfVertices[materialReferenceIndex][vertexIndex + 3] += vector;
						}
					}
				}
				for (int l = 0; l < textInfo.meshInfo.Length; l++)
				{
					textInfo.meshInfo[l].mesh.vertices = copyOfVertices[l];
					m_TextComponent.UpdateGeometry(textInfo.meshInfo[l].mesh, l);
				}
				yield return Yield.WaitSeconds(0.1f);
			}
		}
	}
	public class VertexZoom : MonoBehaviour
	{
		public float AngleMultiplier = 1f;

		public float SpeedMultiplier = 1f;

		public float CurveScale = 1f;

		private TMP_Text m_TextComponent;

		private bool hasTextChanged;

		private void Awake()
		{
			m_TextComponent = GetComponent<TMP_Text>();
		}

		private void OnEnable()
		{
			TMPro_EventManager.TEXT_CHANGED_EVENT.Add(ON_TEXT_CHANGED);
		}

		private void OnDisable()
		{
			TMPro_EventManager.TEXT_CHANGED_EVENT.Remove(ON_TEXT_CHANGED);
		}

		private void Start()
		{
			StartCoroutine(AnimateVertexColors());
		}

		private void ON_TEXT_CHANGED(UnityEngine.Object obj)
		{
			if (obj == m_TextComponent)
			{
				hasTextChanged = true;
			}
		}

		private IEnumerator AnimateVertexColors()
		{
			m_TextComponent.ForceMeshUpdate();
			TMP_TextInfo textInfo = m_TextComponent.textInfo;
			TMP_MeshInfo[] cachedMeshInfoVertexData = textInfo.CopyMeshInfoVertexData();
			List<float> modifiedCharScale = new List<float>();
			List<int> scaleSortingOrder = new List<int>();
			hasTextChanged = true;
			while (true)
			{
				if (hasTextChanged)
				{
					cachedMeshInfoVertexData = textInfo.CopyMeshInfoVertexData();
					hasTextChanged = false;
				}
				int characterCount = textInfo.characterCount;
				if (characterCount == 0)
				{
					yield return Yield.WaitSeconds(0.25f);
					continue;
				}
				modifiedCharScale.Clear();
				scaleSortingOrder.Clear();
				for (int i = 0; i < characterCount; i++)
				{
					if (textInfo.characterInfo[i].isVisible)
					{
						int materialReferenceIndex = textInfo.characterInfo[i].materialReferenceIndex;
						int vertexIndex = textInfo.characterInfo[i].vertexIndex;
						Vector3[] vertices = cachedMeshInfoVertexData[materialReferenceIndex].vertices;
						Vector3 vector = (Vector2)((vertices[vertexIndex] + vertices[vertexIndex + 2]) / 2f);
						Vector3[] vertices2 = textInfo.meshInfo[materialReferenceIndex].vertices;
						vertices2[vertexIndex] = vertices[vertexIndex] - vector;
						vertices2[vertexIndex + 1] = vertices[vertexIndex + 1] - vector;
						vertices2[vertexIndex + 2] = vertices[vertexIndex + 2] - vector;
						vertices2[vertexIndex + 3] = vertices[vertexIndex + 3] - vector;
						float num = UnityEngine.Random.Range(1f, 1.5f);
						modifiedCharScale.Add(num);
						scaleSortingOrder.Add(modifiedCharScale.Count - 1);
						Matrix4x4 matrix4x = Matrix4x4.TRS(new Vector3(0f, 0f, 0f), Quaternion.identity, Vector3.one * num);
						vertices2[vertexIndex] = matrix4x.MultiplyPoint3x4(vertices2[vertexIndex]);
						vertices2[vertexIndex + 1] = matrix4x.MultiplyPoint3x4(vertices2[vertexIndex + 1]);
						vertices2[vertexIndex + 2] = matrix4x.MultiplyPoint3x4(vertices2[vertexIndex + 2]);
						vertices2[vertexIndex + 3] = matrix4x.MultiplyPoint3x4(vertices2[vertexIndex + 3]);
						vertices2[vertexIndex] += vector;
						vertices2[vertexIndex + 1] += vector;
						vertices2[vertexIndex + 2] += vector;
						vertices2[vertexIndex + 3] += vector;
						Vector2[] uvs = cachedMeshInfoVertexData[materialReferenceIndex].uvs0;
						Vector2[] uvs2 = textInfo.meshInfo[materialReferenceIndex].uvs0;
						uvs2[vertexIndex] = uvs[vertexIndex];
						uvs2[vertexIndex + 1] = uvs[vertexIndex + 1];
						uvs2[vertexIndex + 2] = uvs[vertexIndex + 2];
						uvs2[vertexIndex + 3] = uvs[vertexIndex + 3];
						Color32[] colors = cachedMeshInfoVertexData[materialReferenceIndex].colors32;
						Color32[] colors2 = textInfo.meshInfo[materialReferenceIndex].colors32;
						colors2[vertexIndex] = colors[vertexIndex];
						colors2[vertexIndex + 1] = colors[vertexIndex + 1];
						colors2[vertexIndex + 2] = colors[vertexIndex + 2];
						colors2[vertexIndex + 3] = colors[vertexIndex + 3];
					}
				}
				for (int j = 0; j < textInfo.meshInfo.Length; j++)
				{
					scaleSortingOrder.Sort((int a, int b) => modifiedCharScale[a].CompareTo(modifiedCharScale[b]));
					textInfo.meshInfo[j].SortGeometry(scaleSortingOrder);
					textInfo.meshInfo[j].mesh.vertices = textInfo.meshInfo[j].vertices;
					textInfo.meshInfo[j].mesh.uv = textInfo.meshInfo[j].uvs0;
					textInfo.meshInfo[j].mesh.colors32 = textInfo.meshInfo[j].colors32;
					m_TextComponent.UpdateGeometry(textInfo.meshInfo[j].mesh, j);
				}
				yield return Yield.WaitSeconds(0.1f);
			}
		}
	}
	public class WarpTextExample : MonoBehaviour
	{
		private TMP_Text m_TextComponent;

		public AnimationCurve VertexCurve = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(0.25f, 2f), new Keyframe(0.5f, 0f), new Keyframe(0.75f, 2f), new Keyframe(1f, 0f));

		public float AngleMultiplier = 1f;

		public float SpeedMultiplier = 1f;

		public float CurveScale = 1f;

		private void Awake()
		{
			m_TextComponent = base.gameObject.GetComponent<TMP_Text>();
		}

		private void Start()
		{
			StartCoroutine(WarpText());
		}

		private AnimationCurve CopyAnimationCurve(AnimationCurve curve)
		{
			return new AnimationCurve
			{
				keys = curve.keys
			};
		}

		private IEnumerator WarpText()
		{
			VertexCurve.preWrapMode = WrapMode.Once;
			VertexCurve.postWrapMode = WrapMode.Once;
			m_TextComponent.havePropertiesChanged = true;
			CurveScale *= 10f;
			float old_CurveScale = CurveScale;
			AnimationCurve old_curve = CopyAnimationCurve(VertexCurve);
			while (true)
			{
				if (!m_TextComponent.havePropertiesChanged && old_CurveScale == CurveScale && old_curve.keys[1].value == VertexCurve.keys[1].value)
				{
					yield return null;
					continue;
				}
				old_CurveScale = CurveScale;
				old_curve = CopyAnimationCurve(VertexCurve);
				m_TextComponent.ForceMeshUpdate();
				TMP_TextInfo textInfo = m_TextComponent.textInfo;
				int characterCount = textInfo.characterCount;
				if (characterCount == 0)
				{
					continue;
				}
				float x = m_TextComponent.bounds.min.x;
				float x2 = m_TextComponent.bounds.max.x;
				for (int i = 0; i < characterCount; i++)
				{
					if (textInfo.characterInfo[i].isVisible)
					{
						int vertexIndex = textInfo.characterInfo[i].vertexIndex;
						int materialReferenceIndex = textInfo.characterInfo[i].materialReferenceIndex;
						Vector3[] vertices = textInfo.meshInfo[materialReferenceIndex].vertices;
						Vector3 vector = new Vector2((vertices[vertexIndex].x + vertices[vertexIndex + 2].x) / 2f, textInfo.characterInfo[i].baseLine);
						vertices[vertexIndex] += -vector;
						vertices[vertexIndex + 1] += -vector;
						vertices[vertexIndex + 2] += -vector;
						vertices[vertexIndex + 3] += -vector;
						float num = (vector.x - x) / (x2 - x);
						float num2 = num + 0.0001f;
						float y = VertexCurve.Evaluate(num) * CurveScale;
						float y2 = VertexCurve.Evaluate(num2) * CurveScale;
						Vector3 lhs = new Vector3(1f, 0f, 0f);
						Vector3 rhs = new Vector3(num2 * (x2 - x) + x, y2) - new Vector3(vector.x, y);
						float num3 = Mathf.Acos(Vector3.Dot(lhs, rhs.normalized)) * 57.29578f;
						float z = ((Vector3.Cross(lhs, rhs).z > 0f) ? num3 : (360f - num3));
						Matrix4x4 matrix4x = Matrix4x4.TRS(new Vector3(0f, y, 0f), Quaternion.Euler(0f, 0f, z), Vector3.one);
						vertices[vertexIndex] = matrix4x.MultiplyPoint3x4(vertices[vertexIndex]);
						vertices[vertexIndex + 1] = matrix4x.MultiplyPoint3x4(vertices[vertexIndex + 1]);
						vertices[vertexIndex + 2] = matrix4x.MultiplyPoint3x4(vertices[vertexIndex + 2]);
						vertices[vertexIndex + 3] = matrix4x.MultiplyPoint3x4(vertices[vertexIndex + 3]);
						vertices[vertexIndex] += vector;
						vertices[vertexIndex + 1] += vector;
						vertices[vertexIndex + 2] += vector;
						vertices[vertexIndex + 3] += vector;
					}
				}
				m_TextComponent.UpdateVertexData();
				yield return Yield.WaitSeconds(0.025f);
			}
		}
	}
}
namespace RootMotion
{
	public class CameraController : MonoBehaviour
	{
		[Serializable]
		public enum UpdateMode
		{
			Update,
			FixedUpdate,
			LateUpdate
		}

		public Transform target;

		public Transform rotationSpace;

		public UpdateMode updateMode = UpdateMode.LateUpdate;

		public bool lockCursor = true;

		public bool smoothFollow;

		public float followSpeed = 10f;

		public float distance = 10f;

		public float minDistance = 4f;

		public float maxDistance = 10f;

		public float zoomSpeed = 10f;

		public float zoomSensitivity = 1f;

		public float rotationSensitivity = 3.5f;

		public float yMinLimit = -20f;

		public float yMaxLimit = 80f;

		public Vector3 offset = new Vector3(0f, 1.5f, 0.5f);

		public bool rotateAlways = true;

		public bool rotateOnLeftButton;

		public bool rotateOnRightButton;

		public bool rotateOnMiddleButton;

		private Vector3 targetDistance;

		private Vector3 position;

		private Quaternion rotation = Quaternion.identity;

		private Vector3 smoothPosition;

		private Camera cam;

		private Quaternion r = Quaternion.identity;

		private Vector3 lastUp;

		public float x { get; private set; }

		public float y { get; private set; }

		public float distanceTarget { get; private set; }

		private float zoomAdd
		{
			get
			{
				float axis = Input.GetAxis("Mouse ScrollWheel");
				if (axis > 0f)
				{
					return 0f - zoomSensitivity;
				}
				if (axis < 0f)
				{
					return zoomSensitivity;
				}
				return 0f;
			}
		}

		protected virtual void Awake()
		{
			Vector3 eulerAngles = base.transform.eulerAngles;
			x = eulerAngles.y;
			y = eulerAngles.x;
			distanceTarget = distance;
			smoothPosition = base.transform.position;
			cam = GetComponent<Camera>();
			lastUp = ((rotationSpace != null) ? rotationSpace.up : Vector3.up);
		}

		protected virtual void Update()
		{
			if (updateMode == UpdateMode.Update)
			{
				UpdateTransform();
			}
		}

		protected virtual void FixedUpdate()
		{
			if (updateMode == UpdateMode.FixedUpdate)
			{
				UpdateTransform();
			}
		}

		protected virtual void LateUpdate()
		{
			UpdateInput();
			if (updateMode == UpdateMode.LateUpdate)
			{
				UpdateTransform();
			}
		}

		public void UpdateInput()
		{
			if (!(target == null) && cam.enabled)
			{
				Cursor.lockState = (lockCursor ? CursorLockMode.Locked : CursorLockMode.None);
				Cursor.visible = !lockCursor;
				if (rotateAlways || (rotateOnLeftButton && Input.GetMouseButton(0)) || (rotateOnRightButton && Input.GetMouseButton(1)) || (rotateOnMiddleButton && Input.GetMouseButton(2)))
				{
					x += Input.GetAxis("Mouse X") * rotationSensitivity;
					y = ClampAngle(y - Input.GetAxis("Mouse Y") * rotationSensitivity, yMinLimit, yMaxLimit);
				}
				distanceTarget = Mathf.Clamp(distanceTarget + zoomAdd, minDistance, maxDistance);
			}
		}

		public void UpdateTransform()
		{
			UpdateTransform(Time.deltaTime);
		}

		public void UpdateTransform(float deltaTime)
		{
			if (!(target == null) && cam.enabled)
			{
				distance += (distanceTarget - distance) * zoomSpeed * deltaTime;
				rotation = Quaternion.AngleAxis(x, Vector3.up) * Quaternion.AngleAxis(y, Vector3.right);
				if (rotationSpace != null)
				{
					r = Quaternion.FromToRotation(lastUp, rotationSpace.up) * r;
					rotation = r * rotation;
					lastUp = rotationSpace.up;
				}
				if (!smoothFollow)
				{
					smoothPosition = target.position;
				}
				else
				{
					smoothPosition = Vector3.Lerp(smoothPosition, target.position, deltaTime * followSpeed);
				}
				position = smoothPosition + rotation * (offset - Vector3.forward * distance);
				base.transform.position = position;
				base.transform.rotation = rotation;
			}
		}

		private float ClampAngle(float angle, float min, float max)
		{
			if (angle < -360f)
			{
				angle += 360f;
			}
			if (angle > 360f)
			{
				angle -= 360f;
			}
			return Mathf.Clamp(angle, min, max);
		}
	}
	public class CameraControllerFPS : MonoBehaviour
	{
		public float rotationSensitivity = 3f;

		public float yMinLimit = -89f;

		public float yMaxLimit = 89f;

		private float x;

		private float y;

		private void Awake()
		{
			Vector3 eulerAngles = base.transform.eulerAngles;
			x = eulerAngles.y;
			y = eulerAngles.x;
		}

		public void LateUpdate()
		{
			Cursor.lockState = CursorLockMode.Locked;
			x += Input.GetAxis("Mouse X") * rotationSensitivity;
			y = ClampAngle(y - Input.GetAxis("Mouse Y") * rotationSensitivity, yMinLimit, yMaxLimit);
			base.transform.rotation = Quaternion.AngleAxis(x, Vector3.up) * Quaternion.AngleAxis(y, Vector3.right);
		}

		private float ClampAngle(float angle, float min, float max)
		{
			if (angle < -360f)
			{
				angle += 360f;
			}
			if (angle > 360f)
			{
				angle -= 360f;
			}
			return Mathf.Clamp(angle, min, max);
		}
	}
	[Serializable]
	public enum Axis
	{
		X,
		Y,
		Z
	}
	public class AxisTools
	{
		public static Vector3 ToVector3(Axis axis)
		{
			return axis switch
			{
				Axis.X => Vector3.right, 
				Axis.Y => Vector3.up, 
				_ => Vector3.forward, 
			};
		}

		public static Axis ToAxis(Vector3 v)
		{
			float num = Mathf.Abs(v.x);
			float num2 = Mathf.Abs(v.y);
			float num3 = Mathf.Abs(v.z);
			Axis result = Axis.X;
			if (num2 > num && num2 > num3)
			{
				result = Axis.Y;
			}
			if (num3 > num && num3 > num2)
			{
				result = Axis.Z;
			}
			return result;
		}

		public static Axis GetAxisToPoint(Transform t, Vector3 worldPosition)
		{
			Vector3 axisVectorToPoint = GetAxisVectorToPoint(t, worldPosition);
			if (axisVectorToPoint == Vector3.right)
			{
				return Axis.X;
			}
			if (axisVectorToPoint == Vector3.up)
			{
				return Axis.Y;
			}
			return Axis.Z;
		}

		public static Axis GetAxisToDirection(Transform t, Vector3 direction)
		{
			Vector3 axisVectorToDirection = GetAxisVectorToDirection(t, direction);
			if (axisVectorToDirection == Vector3.right)
			{
				return Axis.X;
			}
			if (axisVectorToDirection == Vector3.up)
			{
				return Axis.Y;
			}
			return Axis.Z;
		}

		public static Vector3 GetAxisVectorToPoint(Transform t, Vector3 worldPosition)
		{
			return GetAxisVectorToDirection(t, worldPosition - t.position);
		}

		public static Vector3 GetAxisVectorToDirection(Transform t, Vector3 direction)
		{
			direction = direction.normalized;
			Vector3 result = Vector3.right;
			float num = Mathf.Abs(Vector3.Dot(Vector3.Normalize(t.right), direction));
			float num2 = Mathf.Abs(Vector3.Dot(Vector3.Normalize(t.up), direction));
			if (num2 > num)
			{
				result = Vector3.up;
			}
			float num3 = Mathf.Abs(Vector3.Dot(Vector3.Normalize(t.forward), direction));
			if (num3 > num && num3 > num2)
			{
				result = Vector3.forward;
			}
			return result;
		}
	}
	[Serializable]
	public class BipedLimbOrientations
	{
		[Serializable]
		public class LimbOrientation
		{
			public Vector3 upperBoneForwardAxis;

			public Vector3 lowerBoneForwardAxis;

			public Vector3 lastBoneLeftAxis;

			public LimbOrientation(Vector3 upperBoneForwardAxis, Vector3 lowerBoneForwardAxis, Vector3 lastBoneLeftAxis)
			{
				this.upperBoneForwardAxis = upperBoneForwardAxis;
				this.lowerBoneForwardAxis = lowerBoneForwardAxis;
				this.lastBoneLeftAxis = lastBoneLeftAxis;
			}
		}

		public LimbOrientation leftArm;

		public LimbOrientation rightArm;

		public LimbOrientation leftLeg;

		public LimbOrientation rightLeg;

		public static BipedLimbOrientations UMA => new BipedLimbOrientations(new LimbOrientation(Vector3.forward, Vector3.forward, Vector3.forward), new LimbOrientation(Vector3.forward, Vector3.forward, Vector3.back), new LimbOrientation(Vector3.forward, Vector3.forward, Vector3.down), new LimbOrientation(Vector3.forward, Vector3.forward, Vector3.down));

		public static BipedLimbOrientations MaxBiped => new BipedLimbOrientations(new LimbOrientation(Vector3.down, Vector3.down, Vector3.down), new LimbOrientation(Vector3.down, Vector3.down, Vector3.up), new LimbOrientation(Vector3.up, Vector3.up, Vector3.back), new LimbOrientation(Vector3.up, Vector3.up, Vector3.back));

		public BipedLimbOrientations(LimbOrientation leftArm, LimbOrientation rightArm, LimbOrientation leftLeg, LimbOrientation rightLeg)
		{
			this.leftArm = leftArm;
			this.rightArm = rightArm;
			this.leftLeg = leftLeg;
			this.rightLeg = rightLeg;
		}
	}
	public static class BipedNaming
	{
		[Serializable]
		public enum BoneType
		{
			Unassigned,
			Spine,
			Head,
			Arm,
			Leg,
			Tail,
			Eye
		}

		[Serializable]
		public enum BoneSide
		{
			Center,
			Left,
			Right
		}

		public static string[] typeLeft = new string[9] { " L ", "_L_", "-L-", " l ", "_l_", "-l-", "Left", "left", "CATRigL" };

		public static string[] typeRight = new string[9] { " R ", "_R_", "-R-", " r ", "_r_", "-r-", "Right", "right", "CATRigR" };

		public static string[] typeSpine = new string[16]
		{
			"Spine", "spine", "Pelvis", "pelvis", "Root", "root", "Torso", "torso", "Body", "body",
			"Hips", "hips", "Neck", "neck", "Chest", "chest"
		};

		public static string[] typeHead = new string[2] { "Head", "head" };

		public static string[] typeArm = new string[10] { "Arm", "arm", "Hand", "hand", "Wrist", "Wrist", "Elbow", "elbow", "Palm", "palm" };

		public static string[] typeLeg = new string[16]
		{
			"Leg", "leg", "Thigh", "thigh", "Calf", "calf", "Femur", "femur", "Knee", "knee",
			"Foot", "foot", "Ankle", "ankle", "Hip", "hip"
		};

		public static string[] typeTail = new string[2] { "Tail", "tail" };

		public static string[] typeEye = new string[2] { "Eye", "eye" };

		public static string[] typeExclude = new string[6] { "Nub", "Dummy", "dummy", "Tip", "IK", "Mesh" };

		public static string[] typeExcludeSpine = new string[2] { "Head", "head" };

		public static string[] typeExcludeHead = new string[2] { "Top", "End" };

		public static string[] typeExcludeArm = new string[19]
		{
			"Collar", "collar", "Clavicle", "clavicle", "Finger", "finger", "Index", "index", "Mid", "mid",
			"Pinky", "pinky", "Ring", "Thumb", "thumb", "Adjust", "adjust", "Twist", "twist"
		};

		public static string[] typeExcludeLeg = new string[7] { "Toe", "toe", "Platform", "Adjust", "adjust", "Twist", "twist" };

		public static string[] typeExcludeTail = new string[0];

		public static string[] typeExcludeEye = new string[6] { "Lid", "lid", "Brow", "brow", "Lash", "lash" };

		public static string[] pelvis = new string[4] { "Pelvis", "pelvis", "Hip", "hip" };

		public static string[] hand = new string[6] { "Hand", "hand", "Wrist", "wrist", "Palm", "palm" };

		public static string[] foot = new string[4] { "Foot", "foot", "Ankle", "ankle" };

		public static Transform[] GetBonesOfType(BoneType boneType, Transform[] bones)
		{
			Transform[] array = new Transform[0];
			foreach (Transform transform in bones)
			{
				if (transform != null && GetBoneType(transform.name) == boneType)
				{
					Array.Resize(ref array, array.Length + 1);
					array[array.Length - 1] = transform;
				}
			}
			return array;
		}

		public static Transform[] GetBonesOfSide(BoneSide boneSide, Transform[] bones)
		{
			Transform[] array = new Transform[0];
			foreach (Transform transform in bones)
			{
				if (transform != null && GetBoneSide(transform.name) == boneSide)
				{
					Array.Resize(ref array, array.Length + 1);
					array[array.Length - 1] = transform;
				}
			}
			return array;
		}

		public static Transform[] GetBonesOfTypeAndSide(BoneType boneType, BoneSide boneSide, Transform[] bones)
		{
			Transform[] bonesOfType = GetBonesOfType(boneType, bones);
			return GetBonesOfSide(boneSide, bonesOfType);
		}

		public static Transform GetFirstBoneOfTypeAndSide(BoneType boneType, BoneSide boneSide, Transform[] bones)
		{
			Transform[] bonesOfTypeAndSide = GetBonesOfTypeAndSide(boneType, boneSide, bones);
			if (bonesOfTypeAndSide.Length == 0)
			{
				return null;
			}
			return bonesOfTypeAndSide[0];
		}

		public static Transform GetNamingMatch(Transform[] transforms, params string[][] namings)
		{
			foreach (Transform transform in transforms)
			{
				bool flag = true;
				foreach (string[] namingConvention in namings)
				{
					if (!matchesNaming(transform.name, namingConvention))
					{
						flag = false;
						break;
					}
				}
				if (flag)
				{
					return transform;
				}
			}
			return null;
		}

		public static BoneType GetBoneType(string boneName)
		{
			if (isSpine(boneName))
			{
				return BoneType.Spine;
			}
			if (isHead(boneName))
			{
				return BoneType.Head;
			}
			if (isArm(boneName))
			{
				return BoneType.Arm;
			}
			if (isLeg(boneName))
			{
				return BoneType.Leg;
			}
			if (isTail(boneName))
			{
				return BoneType.Tail;
			}
			if (isEye(boneName))
			{
				return BoneType.Eye;
			}
			return BoneType.Unassigned;
		}

		public static BoneSide GetBoneSide(string boneName)
		{
			if (isLeft(boneName))
			{
				return BoneSide.Left;
			}
			if (isRight(boneName))
			{
				return BoneSide.Right;
			}
			return BoneSide.Center;
		}

		public static Transform GetBone(Transform[] transforms, BoneType boneType, BoneSide boneSide = BoneSide.Center, params string[][] namings)
		{
			return GetNamingMatch(GetBonesOfTypeAndSide(boneType, boneSide, transforms), namings);
		}

		private static bool isLeft(string boneName)
		{
			if (!matchesNaming(boneName, typeLeft) && !(lastLetter(boneName) == "L"))
			{
				return firstLetter(boneName) == "L";
			}
			return true;
		}

		private static bool isRight(string boneName)
		{
			if (!matchesNaming(boneName, typeRight) && !(lastLetter(boneName) == "R"))
			{
				return firstLetter(boneName) == "R";
			}
			return true;
		}

		private static bool isSpine(string boneName)
		{
			if (matchesNaming(boneName, typeSpine))
			{
				return !excludesNaming(boneName, typeExcludeSpine);
			}
			return false;
		}

		private static bool isHead(string boneName)
		{
			if (matchesNaming(boneName, typeHead))
			{
				return !excludesNaming(boneName, typeExcludeHead);
			}
			return false;
		}

		private static bool isArm(string boneName)
		{
			if (matchesNaming(boneName, typeArm))
			{
				return !excludesNaming(boneName, typeExcludeArm);
			}
			return false;
		}

		private static bool isLeg(string boneName)
		{
			if (matchesNaming(boneName, typeLeg))
			{
				return !excludesNaming(boneName, typeExcludeLeg);
			}
			return false;
		}

		private static bool isTail(string boneName)
		{
			if (matchesNaming(boneName, typeTail))
			{
				return !excludesNaming(boneName, typeExcludeTail);
			}
			return false;
		}

		private static bool isEye(string boneName)
		{
			if (matchesNaming(boneName, typeEye))
			{
				return !excludesNaming(boneName, typeExcludeEye);
			}
			return false;
		}

		private static bool isTypeExclude(string boneName)
		{
			return matchesNaming(boneName, typeExclude);
		}

		private static bool matchesNaming(string boneName, string[] namingConvention)
		{
			if (excludesNaming(boneName, typeExclude))
			{
				return false;
			}
			foreach (string value in namingConvention)
			{
				if (boneName.Contains(value))
				{
					return true;
				}
			}
			return false;
		}

		private static bool excludesNaming(string boneName, string[] namingConvention)
		{
			foreach (string value in namingConvention)
			{
				if (boneName.Contains(value))
				{
					return true;
				}
			}
			return false;
		}

		private static bool matchesLastLetter(string boneName, string[] namingConvention)
		{
			foreach (string letter in namingConvention)
			{
				if (LastLetterIs(boneName, letter))
				{
					return true;
				}
			}
			return false;
		}

		private static bool LastLetterIs(string boneName, string letter)
		{
			return boneName.Substring(boneName.Length - 1, 1) == letter;
		}

		private static string firstLetter(string boneName)
		{
			if (boneName.Length > 0)
			{
				return boneName.Substring(0, 1);
			}
			return "";
		}

		private static string lastLetter(string boneName)
		{
			if (boneName.Length > 0)
			{
				return boneName.Substring(boneName.Length - 1, 1);
			}
			return "";
		}
	}
	[Serializable]
	public class BipedReferences
	{
		public struct AutoDetectParams
		{
			public bool legsParentInSpine;

			public bool includeEyes;

			public static AutoDetectParams Default => new AutoDetectParams(legsParentInSpine: true, includeEyes: true);

			public AutoDetectParams(bool legsParentInSpine, bool includeEyes)
			{
				this.legsParentInSpine = legsParentInSpine;
				this.includeEyes = includeEyes;
			}
		}

		public Transform root;

		public Transform pelvis;

		public Transform leftThigh;

		public Transform leftCalf;

		public Transform leftFoot;

		public Transform rightThigh;

		public Transform rightCalf;

		public Transform rightFoot;

		public Transform leftUpperArm;

		public Transform leftForearm;

		public Transform leftHand;

		public Transform rightUpperArm;

		public Transform rightForearm;

		public Transform rightHand;

		public Transform head;

		public Transform[] spine = new Transform[0];

		public Transform[] eyes = new Transform[0];

		public virtual bool isFilled
		{
			get
			{
				if (root == null)
				{
					return false;
				}
				if (pelvis == null)
				{
					return false;
				}
				if (leftThigh == null || leftCalf == null || leftFoot == null)
				{
					return false;
				}
				if (rightThigh == null || rightCalf == null || rightFoot == null)
				{
					return false;
				}
				if (leftUpperArm == null || leftForearm == null || leftHand == null)
				{
					return false;
				}
				if (rightUpperArm == null || rightForearm == null || rightHand == null)
				{
					return false;
				}
				Transform[] array = spine;
				for (int i = 0; i < array.Length; i++)
				{
					if (array[i] == null)
					{
						return false;
					}
				}
				array = eyes;
				for (int i = 0; i < array.Length; i++)
				{
					if (array[i] == null)
					{
						return false;
					}
				}
				return true;
			}
		}

		public bool isEmpty => IsEmpty(includeRoot: true);

		public virtual bool IsEmpty(bool includeRoot)
		{
			if (includeRoot && root != null)
			{
				return false;
			}
			if (pelvis != null || head != null)
			{
				return false;
			}
			if (leftThigh != null || leftCalf != null || leftFoot != null)
			{
				return false;
			}
			if (rightThigh != null || rightCalf != null || rightFoot != null)
			{
				return false;
			}
			if (leftUpperArm != null || leftForearm != null || leftHand != null)
			{
				return false;
			}
			if (rightUpperArm != null || rightForearm != null || rightHand != null)
			{
				return false;
			}
			Transform[] array = spine;
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i] != null)
				{
					return false;
				}
			}
			array = eyes;
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i] != null)
				{
					return false;
				}
			}
			return true;
		}

		public virtual bool Contains(Transform t, bool ignoreRoot = false)
		{
			if (!ignoreRoot && root == t)
			{
				return true;
			}
			if (pelvis == t)
			{
				return true;
			}
			if (leftThigh == t)
			{
				return true;
			}
			if (leftCalf == t)
			{
				return true;
			}
			if (leftFoot == t)
			{
				return true;
			}
			if (rightThigh == t)
			{
				return true;
			}
			if (rightCalf == t)
			{
				return true;
			}
			if (rightFoot == t)
			{
				return true;
			}
			if (leftUpperArm == t)
			{
				return true;
			}
			if (leftForearm == t)
			{
				return true;
			}
			if (leftHand == t)
			{
				return true;
			}
			if (rightUpperArm == t)
			{
				return true;
			}
			if (rightForearm == t)
			{
				return true;
			}
			if (rightHand == t)
			{
				return true;
			}
			if (head == t)
			{
				return true;
			}
			Transform[] array = spine;
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i] == t)
				{
					return true;
				}
			}
			array = eyes;
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i] == t)
				{
					return true;
				}
			}
			return false;
		}

		public static bool AutoDetectReferences(ref BipedReferences references, Transform root, AutoDetectParams autoDetectParams)
		{
			if (references == null)
			{
				references = new BipedReferences();
			}
			references.root = root;
			Animator component = root.GetComponent<Animator>();
			if (component != null && component.isHuman)
			{
				AssignHumanoidReferences(ref references, component, autoDetectParams);
				return true;
			}
			DetectReferencesByNaming(ref references, root, autoDetectParams);
			Warning.logged = false;
			if (!references.isFilled)
			{
				Warning.Log("BipedReferences contains one or more missing Transforms.", root, logInEditMode: true);
				return false;
			}
			string errorMessage = "";
			if (SetupError(references, ref errorMessage))
			{
				Warning.Log(errorMessage, references.root, logInEditMode: true);
				return false;
			}
			if (SetupWarning(references, ref errorMessage))
			{
				Warning.Log(errorMessage, references.root, logInEditMode: true);
			}
			return true;
		}

		public static void DetectReferencesByNaming(ref BipedReferences references, Transform root, AutoDetectParams autoDetectParams)
		{
			if (references == null)
			{
				references = new BipedReferences();
			}
			Transform[] componentsInChildren = root.GetComponentsInChildren<Transform>();
			DetectLimb(BipedNaming.BoneType.Arm, BipedNaming.BoneSide.Left, ref references.leftUpperArm, ref references.leftForearm, ref references.leftHand, componentsInChildren);
			DetectLimb(BipedNaming.BoneType.Arm, BipedNaming.BoneSide.Right, ref references.rightUpperArm, ref references.rightForearm, ref references.rightHand, componentsInChildren);
			DetectLimb(BipedNaming.BoneType.Leg, BipedNaming.BoneSide.Left, ref references.leftThigh, ref references.leftCalf, ref references.leftFoot, componentsInChildren);
			DetectLimb(BipedNaming.BoneType.Leg, BipedNaming.BoneSide.Right, ref references.rightThigh, ref references.rightCalf, ref references.rightFoot, componentsInChildren);
			references.head = BipedNaming.GetBone(componentsInChildren, BipedNaming.BoneType.Head, BipedNaming.BoneSide.Center);
			references.pelvis = BipedNaming.GetNamingMatch(componentsInChildren, BipedNaming.pelvis);
			if ((references.pelvis == null || !Hierarchy.IsAncestor(references.leftThigh, references.pelvis)) && references.leftThigh != null)
			{
				references.pelvis = references.leftThigh.parent;
			}
			if (references.leftUpperArm != null && references.rightUpperArm != null && references.pelvis != null && references.leftThigh != null)
			{
				Transform firstCommonAncestor = Hierarchy.GetFirstCommonAncestor(references.leftUpperArm, references.rightUpperArm);
				if (firstCommonAncestor != null)
				{
					Transform[] array = new Transform[1] { firstCommonAncestor };
					Hierarchy.AddAncestors(array[0], references.pelvis, ref array);
					references.spine = new Transform[0];
					for (int num = array.Length - 1; num > -1; num--)
					{
						if (AddBoneToSpine(array[num], ref references, autoDetectParams))
						{
							Array.Resize(ref references.spine, references.spine.Length + 1);
							references.spine[references.spine.Length - 1] = array[num];
						}
					}
					if (references.head == null)
					{
						for (int i = 0; i < firstCommonAncestor.childCount; i++)
						{
							Transform child = firstCommonAncestor.GetChild(i);
							if (!Hierarchy.ContainsChild(child, references.leftUpperArm) && !Hierarchy.ContainsChild(child, references.rightUpperArm))
							{
								references.head = child;
								break;
							}
						}
					}
				}
			}
			Transform[] bonesOfType = BipedNaming.GetBonesOfType(BipedNaming.BoneType.Eye, componentsInChildren);
			references.eyes = new Transform[0];
			if (!autoDetectParams.includeEyes)
			{
				return;
			}
			for (int j = 0; j < bonesOfType.Length; j++)
			{
				if (AddBoneToEyes(bonesOfType[j], ref references, autoDetectParams))
				{
					Array.Resize(ref references.eyes, references.eyes.Length + 1);
					references.eyes[references.eyes.Length - 1] = bonesOfType[j];
				}
			}
		}

		public static void AssignHumanoidReferences(ref BipedReferences references, Animator animator, AutoDetectParams autoDetectParams)
		{
			if (references == null)
			{
				references = new BipedReferences();
			}
			if (!(animator == null) && animator.isHuman)
			{
				references.spine = new Transform[0];
				references.eyes = new Transform[0];
				references.head = animator.GetBoneTransform(HumanBodyBones.Head);
				references.leftThigh = animator.GetBoneTransform(HumanBodyBones.LeftUpperLeg);
				references.leftCalf = animator.GetBoneTransform(HumanBodyBones.LeftLowerLeg);
				references.leftFoot = animator.GetBoneTransform(HumanBodyBones.LeftFoot);
				references.rightThigh = animator.GetBoneTransform(HumanBodyBones.RightUpperLeg);
				references.rightCalf = animator.GetBoneTransform(HumanBodyBones.RightLowerLeg);
				references.rightFoot = animator.GetBoneTransform(HumanBodyBones.RightFoot);
				references.leftUpperArm = animator.GetBoneTransform(HumanBodyBones.LeftUpperArm);
				references.leftForearm = animator.GetBoneTransform(HumanBodyBones.LeftLowerArm);
				references.leftHand = animator.GetBoneTransform(HumanBodyBones.LeftHand);
				references.rightUpperArm = animator.GetBoneTransform(HumanBodyBones.RightUpperArm);
				references.rightForearm = animator.GetBoneTransform(HumanBodyBones.RightLowerArm);
				references.rightHand = animator.GetBoneTransform(HumanBodyBones.RightHand);
				references.pelvis = animator.GetBoneTransform(HumanBodyBones.Hips);
				AddBoneToHierarchy(ref references.spine, animator.GetBoneTransform(HumanBodyBones.Spine));
				AddBoneToHierarchy(ref references.spine, animator.GetBoneTransform(HumanBodyBones.Chest));
				if (references.leftUpperArm != null && !IsNeckBone(animator.GetBoneTransform(HumanBodyBones.Neck), references.leftUpperArm))
				{
					AddBoneToHierarchy(ref references.spine, animator.GetBoneTransform(HumanBodyBones.Neck));
				}
				if (autoDetectParams.includeEyes)
				{
					AddBoneToHierarchy(ref references.eyes, animator.GetBoneTransform(HumanBodyBones.LeftEye));
					AddBoneToHierarchy(ref references.eyes, animator.GetBoneTransform(HumanBodyBones.RightEye));
				}
			}
		}

		public static bool SetupError(BipedReferences references, ref string errorMessage)
		{
			if (!references.isFilled)
			{
				errorMessage = "BipedReferences contains one or more missing Transforms.";
				return true;
			}
			if (LimbError(references.leftThigh, references.leftCalf, references.leftFoot, ref errorMessage))
			{
				return true;
			}
			if (LimbError(references.rightThigh, references.rightCalf, references.rightFoot, ref errorMessage))
			{
				return true;
			}
			if (LimbError(references.leftUpperArm, references.leftForearm, references.leftHand, ref errorMessage))
			{
				return true;
			}
			if (LimbError(references.rightUpperArm, references.rightForearm, references.rightHand, ref errorMessage))
			{
				return true;
			}
			if (SpineError(references, ref errorMessage))
			{
				return true;
			}
			if (EyesError(references, ref errorMessage))
			{
				return true;
			}
			return false;
		}

		public static bool SetupWarning(BipedReferences references, ref string warningMessage)
		{
			if (LimbWarning(references.leftThigh, references.leftCalf, references.leftFoot, ref warningMessage))
			{
				return true;
			}
			if (LimbWarning(references.rightThigh, references.rightCalf, references.rightFoot, ref warningMessage))
			{
				return true;
			}
			if (LimbWarning(references.leftUpperArm, references.leftForearm, references.leftHand, ref warningMessage))
			{
				return true;
			}
			if (LimbWarning(references.rightUpperArm, references.rightForearm, references.rightHand, ref warningMessage))
			{
				return true;
			}
			if (SpineWarning(references, ref warningMessage))
			{
				return true;
			}
			if (EyesWarning(references, ref warningMessage))
			{
				return true;
			}
			if (RootHeightWarning(references, ref warningMessage))
			{
				return true;
			}
			if (FacingAxisWarning(references, ref warningMessage))
			{
				return true;
			}
			return false;
		}

		private static bool IsNeckBone(Transform bone, Transform leftUpperArm)
		{
			if (leftUpperArm.parent != null && leftUpperArm.parent == bone)
			{
				return false;
			}
			if (Hierarchy.IsAncestor(leftUpperArm, bone))
			{
				return false;
			}
			return true;
		}

		private static bool AddBoneToEyes(Transform bone, ref BipedReferences references, AutoDetectParams autoDetectParams)
		{
			if (references.head != null && !Hierarchy.IsAncestor(bone, references.head))
			{
				return false;
			}
			if (bone.GetComponent<SkinnedMeshRenderer>() != null)
			{
				return false;
			}
			return true;
		}

		private static bool AddBoneToSpine(Transform bone, ref BipedReferences references, AutoDetectParams autoDetectParams)
		{
			if (bone == references.root)
			{
				return false;
			}
			if (bone == references.leftThigh.parent && !autoDetectParams.legsParentInSpine)
			{
				return false;
			}
			if (references.pelvis != null)
			{
				if (bone == references.pelvis)
				{
					return false;
				}
				if (Hierarchy.IsAncestor(references.pelvis, bone))
				{
					return false;
				}
			}
			return true;
		}

		private static void DetectLimb(BipedNaming.BoneType boneType, BipedNaming.BoneSide boneSide, ref Transform firstBone, ref Transform secondBone, ref Transform lastBone, Transform[] transforms)
		{
			Transform[] bonesOfTypeAndSide = BipedNaming.GetBonesOfTypeAndSide(boneType, boneSide, transforms);
			if (bonesOfTypeAndSide.Length >= 3)
			{
				if (bonesOfTypeAndSide.Length == 3)
				{
					firstBone = bonesOfTypeAndSide[0];
					secondBone = bonesOfTypeAndSide[1];
					lastBone = bonesOfTypeAndSide[2];
				}
				if (bonesOfTypeAndSide.Length > 3)
				{
					firstBone = bonesOfTypeAndSide[0];
					secondBone = bonesOfTypeAndSide[2];
					lastBone = bonesOfTypeAndSide[bonesOfTypeAndSide.Length - 1];
				}
			}
		}

		private static void AddBoneToHierarchy(ref Transform[] bones, Transform transform)
		{
			if (!(transform == null))
			{
				Array.Resize(ref bones, bones.Length + 1);
				bones[bones.Length - 1] = transform;
			}
		}

		private static bool LimbError(Transform bone1, Transform bone2, Transform bone3, ref string errorMessage)
		{
			if (bone1 == null)
			{
				errorMessage = "Bone 1 of a BipedReferences limb is null.";
				return true;
			}
			if (bone2 == null)
			{
				errorMessage = "Bone 2 of a BipedReferences limb is null.";
				return true;
			}
			if (bone3 == null)
			{
				errorMessage = "Bone 3 of a BipedReferences limb is null.";
				return true;
			}
			UnityEngine.Object[] objects = new Transform[3] { bone1, bone2, bone3 };
			Transform transform = (Transform)Hierarchy.ContainsDuplicate(objects);
			if (transform != null)
			{
				errorMessage = transform.name + " is represented multiple times in the same BipedReferences limb.";
				return true;
			}
			if (bone2.position == bone1.position)
			{
				errorMessage = "Second bone's position equals first bone's position in the biped's limb.";
				return true;
			}
			if (bone3.position == bone2.position)
			{
				errorMessage = "Third bone's position equals second bone's position in the biped's limb.";
				return true;
			}
			if (!Hierarchy.HierarchyIsValid(new Transform[3] { bone1, bone2, bone3 }))
			{
				errorMessage = "BipedReferences limb hierarchy is invalid. Bone transforms in a limb do not belong to the same ancestry. Please make sure the bones are parented to each other. Bones: " + bone1.name + ", " + bone2.name + ", " + bone3.name;
				return true;
			}
			return false;
		}

		private static bool LimbWarning(Transform bone1, Transform bone2, Transform bone3, ref string warningMessage)
		{
			if (Vector3.Cross(bone2.position - bone1.position, bone3.position - bone1.position) == Vector3.zero)
			{
				warningMessage = "BipedReferences limb is completely stretched out in the initial pose. IK solver can not calculate the default bend plane for the limb. Please make sure you character's limbs are at least slightly bent in the initial pose. First bone: " + bone1.name + ", second bone: " + bone2.name + ".";
				return true;
			}
			return false;
		}

		private static bool SpineError(BipedReferences references, ref string errorMessage)
		{
			if (references.spine.Length == 0)
			{
				return false;
			}
			for (int i = 0; i < references.spine.Length; i++)
			{
				if (references.spine[i] == null)
				{
					errorMessage = "BipedReferences spine bone at index " + i + " is null.";
					return true;
				}
			}
			UnityEngine.Object[] objects = references.spine;
			Transform transform = (Transform)Hierarchy.ContainsDuplicate(objects);
			if (transform != null)
			{
				errorMessage = transform.name + " is represented multiple times in BipedReferences spine.";
				return true;
			}
			if (!Hierarchy.HierarchyIsValid(references.spine))
			{
				errorMessage = "BipedReferences spine hierarchy is invalid. Bone transforms in the spine do not belong to the same ancestry. Please make sure the bones are parented to each other.";
				return true;
			}
			for (int j = 0; j < references.spine.Length; j++)
			{
				bool flag = false;
				if (j == 0 && references.spine[j].position == references.pelvis.position)
				{
					flag = true;
				}
				if (j != 0 && references.spine.Length > 1 && references.spine[j].position == references.spine[j - 1].position)
				{
					flag = true;
				}
				if (flag)
				{
					errorMessage = "Biped's spine bone nr " + j + " position is the same as it's parent spine/pelvis bone's position. Please remove this bone from the spine.";
					return true;
				}
			}
			return false;
		}

		private static bool SpineWarning(BipedReferences references, ref string warningMessage)
		{
			return false;
		}

		private static bool EyesError(BipedReferences references, ref string errorMessage)
		{
			if (references.eyes.Length == 0)
			{
				return false;
			}
			for (int i = 0; i < references.eyes.Length; i++)
			{
				if (references.eyes[i] == null)
				{
					errorMessage = "BipedReferences eye bone at index " + i + " is null.";
					return true;
				}
			}
			UnityEngine.Object[] objects = references.eyes;
			Transform transform = (Transform)Hierarchy.ContainsDuplicate(objects);
			if (transform != null)
			{
				errorMessage = transform.name + " is represented multiple times in BipedReferences eyes.";
				return true;
			}
			return false;
		}

		private static bool EyesWarning(BipedReferences references, ref string warningMessage)
		{
			return false;
		}

		private static bool RootHeightWarning(BipedReferences references, ref string warningMessage)
		{
			if (references.head == null)
			{
				return false;
			}
			float verticalOffset = GetVerticalOffset(references.head.position, references.leftFoot.position, references.root.rotation);
			if (GetVerticalOffset(references.root.position, references.leftFoot.position, references.root.rotation) / verticalOffset > 0.2f)
			{
				warningMessage = "Biped's root Transform's position should be at ground level relative to the character (at the character's feet not at it's pelvis).";
				return true;
			}
			return false;
		}

		private static bool FacingAxisWarning(BipedReferences references, ref string warningMessage)
		{
			Vector3 vector = references.rightHand.position - references.leftHand.position;
			Vector3 vector2 = references.rightFoot.position - references.leftFoot.position;
			float num = Vector3.Dot(vector.normalized, references.root.right);
			float num2 = Vector3.Dot(vector2.normalized, references.root.right);
			if (num < 0f || num2 < 0f)
			{
				warningMessage = "Biped does not seem to be facing it's forward axis. Please make sure that in the initial pose the character is facing towards the positive Z axis of the Biped root gameobject.";
				return true;
			}
			return false;
		}

		private static float GetVerticalOffset(Vector3 p1, Vector3 p2, Quaternion rotation)
		{
			return (Quaternion.Inverse(rotation) * (p1 - p2)).y;
		}
	}
	public class Comments : MonoBehaviour
	{
		[Multiline]
		public string text;
	}
	public class DemoGUIMessage : MonoBehaviour
	{
		public string text;

		public UnityEngine.Color color = UnityEngine.Color.white;

		private void OnGUI()
		{
			GUI.color = color;
			GUILayout.Label(text);
			GUI.color = UnityEngine.Color.white;
		}
	}
	public class Hierarchy
	{
		public static bool HierarchyIsValid(Transform[] bones)
		{
			for (int i = 1; i < bones.Length; i++)
			{
				if (!IsAncestor(bones[i], bones[i - 1]))
				{
					return false;
				}
			}
			return true;
		}

		public static UnityEngine.Object ContainsDuplicate(UnityEngine.Object[] objects)
		{
			for (int i = 0; i < objects.Length; i++)
			{
				for (int j = 0; j < objects.Length; j++)
				{
					if (i != j && objects[i] == objects[j])
					{
						return objects[i];
					}
				}
			}
			return null;
		}

		public static bool IsAncestor(Transform transform, Transform ancestor)
		{
			if (transform == null)
			{
				return true;
			}
			if (ancestor == null)
			{
				return true;
			}
			if (transform.parent == null)
			{
				return false;
			}
			if (transform.parent == ancestor)
			{
				return true;
			}
			return IsAncestor(transform.parent, ancestor);
		}

		public static bool ContainsChild(Transform transform, Transform child)
		{
			if (transform == child)
			{
				return true;
			}
			Transform[] componentsInChildren = transform.GetComponentsInChildren<Transform>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				if (componentsInChildren[i] == child)
				{
					return true;
				}
			}
			return false;
		}

		public static void AddAncestors(Transform transform, Transform blocker, ref Transform[] array)
		{
			if (transform.parent != null && transform.parent != blocker)
			{
				if (transform.parent.position != transform.position && transform.parent.position != blocker.position)
				{
					Array.Resize(ref array, array.Length + 1);
					array[array.Length - 1] = transform.parent;
				}
				AddAncestors(transform.parent, blocker, ref array);
			}
		}

		public static Transform GetAncestor(Transform transform, int minChildCount)
		{
			if (transform == null)
			{
				return null;
			}
			if (transform.parent != null)
			{
				if (transform.parent.childCount >= minChildCount)
				{
					return transform.parent;
				}
				return GetAncestor(transform.parent, minChildCount);
			}
			return null;
		}

		public static Transform GetFirstCommonAncestor(Transform t1, Transform t2)
		{
			if (t1 == null)
			{
				return null;
			}
			if (t2 == null)
			{
				return null;
			}
			if (t1.parent == null)
			{
				return null;
			}
			if (t2.parent == null)
			{
				return null;
			}
			if (IsAncestor(t2, t1.parent))
			{
				return t1.parent;
			}
			return GetFirstCommonAncestor(t1.parent, t2);
		}

		public static Transform GetFirstCommonAncestor(Transform[] transforms)
		{
			if (transforms == null)
			{
				UnityEngine.Debug.LogWarning("Transforms is null.");
				return null;
			}
			if (transforms.Length == 0)
			{
				UnityEngine.Debug.LogWarning("Transforms.Length is 0.");
				return null;
			}
			for (int i = 0; i < transforms.Length; i++)
			{
				if (transforms[i] == null)
				{
					return null;
				}
				if (IsCommonAncestor(transforms[i], transforms))
				{
					return transforms[i];
				}
			}
			return GetFirstCommonAncestorRecursive(transforms[0], transforms);
		}

		public static Transform GetFirstCommonAncestorRecursive(Transform transform, Transform[] transforms)
		{
			if (transform == null)
			{
				UnityEngine.Debug.LogWarning("Transform is null.");
				return null;
			}
			if (transforms == null)
			{
				UnityEngine.Debug.LogWarning("Transforms is null.");
				return null;
			}
			if (transforms.Length == 0)
			{
				UnityEngine.Debug.LogWarning("Transforms.Length is 0.");
				return null;
			}
			if (IsCommonAncestor(transform, transforms))
			{
				return transform;
			}
			if (transform.parent == null)
			{
				return null;
			}
			return GetFirstCommonAncestorRecursive(transform.parent, transforms);
		}

		public static bool IsCommonAncestor(Transform transform, Transform[] transforms)
		{
			if (transform == null)
			{
				UnityEngine.Debug.LogWarning("Transform is null.");
				return false;
			}
			for (int i = 0; i < transforms.Length; i++)
			{
				if (transforms[i] == null)
				{
					UnityEngine.Debug.Log("Transforms[" + i + "] is null.");
					return false;
				}
				if (!IsAncestor(transforms[i], transform) && transforms[i] != transform)
				{
					return false;
				}
			}
			return true;
		}
	}
	[Serializable]
	public enum InterpolationMode
	{
		None,
		InOutCubic,
		InOutQuintic,
		InOutSine,
		InQuintic,
		InQuartic,
		InCubic,
		InQuadratic,
		InElastic,
		InElasticSmall,
		InElasticBig,
		InSine,
		InBack,
		OutQuintic,
		OutQuartic,
		OutCubic,
		OutInCubic,
		OutInQuartic,
		OutElastic,
		OutElasticSmall,
		OutElasticBig,
		OutSine,
		OutBack,
		OutBackCubic,
		OutBackQuartic,
		BackInCubic,
		BackInQuartic
	}
	public class Interp
	{
		public static float Float(float t, InterpolationMode mode)
		{
			float num = 0f;
			return mode switch
			{
				InterpolationMode.None => None(t, 0f, 1f), 
				InterpolationMode.InOutCubic => InOutCubic(t, 0f, 1f), 
				InterpolationMode.InOutQuintic => InOutQuintic(t, 0f, 1f), 
				InterpolationMode.InQuintic => InQuintic(t, 0f, 1f), 
				InterpolationMode.InQuartic => InQuartic(t, 0f, 1f), 
				InterpolationMode.InCubic => InCubic(t, 0f, 1f), 
				InterpolationMode.InQuadratic => InQuadratic(t, 0f, 1f), 
				InterpolationMode.OutQuintic => OutQuintic(t, 0f, 1f), 
				InterpolationMode.OutQuartic => OutQuartic(t, 0f, 1f), 
				InterpolationMode.OutCubic => OutCubic(t, 0f, 1f), 
				InterpolationMode.OutInCubic => OutInCubic(t, 0f, 1f), 
				InterpolationMode.OutInQuartic => OutInCubic(t, 0f, 1f), 
				InterpolationMode.BackInCubic => BackInCubic(t, 0f, 1f), 
				InterpolationMode.BackInQuartic => BackInQuartic(t, 0f, 1f), 
				InterpolationMode.OutBackCubic => OutBackCubic(t, 0f, 1f), 
				InterpolationMode.OutBackQuartic => OutBackQuartic(t, 0f, 1f), 
				InterpolationMode.OutElasticSmall => OutElasticSmall(t, 0f, 1f), 
				InterpolationMode.OutElasticBig => OutElasticBig(t, 0f, 1f), 
				InterpolationMode.InElasticSmall => InElasticSmall(t, 0f, 1f), 
				InterpolationMode.InElasticBig => InElasticBig(t, 0f, 1f), 
				InterpolationMode.InSine => InSine(t, 0f, 1f), 
				InterpolationMode.OutSine => OutSine(t, 0f, 1f), 
				InterpolationMode.InOutSine => InOutSine(t, 0f, 1f), 
				InterpolationMode.InElastic => OutElastic(t, 0f, 1f), 
				InterpolationMode.OutElastic => OutElastic(t, 0f, 1f), 
				InterpolationMode.InBack => InBack(t, 0f, 1f), 
				InterpolationMode.OutBack => OutBack(t, 0f, 1f), 
				_ => 0f, 
			};
		}

		public static Vector3 V3(Vector3 v1, Vector3 v2, float t, InterpolationMode mode)
		{
			float num = Float(t, mode);
			return (1f - num) * v1 + num * v2;
		}

		public static float LerpValue(float value, float target, float increaseSpeed, float decreaseSpeed)
		{
			if (value == target)
			{
				return target;
			}
			if (value < target)
			{
				return Mathf.Clamp(value + Time.deltaTime * increaseSpeed, float.NegativeInfinity, target);
			}
			return Mathf.Clamp(value - Time.deltaTime * decreaseSpeed, target, float.PositiveInfinity);
		}

		private static float None(float t, float b, float c)
		{
			return b + c * t;
		}

		private static float InOutCubic(float t, float b, float c)
		{
			float num = t * t;
			float num2 = num * t;
			return b + c * (-2f * num2 + 3f * num);
		}

		private static float InOutQuintic(float t, float b, float c)
		{
			float num = t * t;
			float num2 = num * t;
			return b + c * (6f * num2 * num + -15f * num * num + 10f * num2);
		}

		private static float InQuintic(float t, float b, float c)
		{
			float num = t * t;
			float num2 = num * t;
			return b + c * (num2 * num);
		}

		private static float InQuartic(float t, float b, float c)
		{
			float num = t * t;
			return b + c * (num * num);
		}

		private static float InCubic(float t, float b, float c)
		{
			float num = t * t * t;
			return b + c * num;
		}

		private static float InQuadratic(float t, float b, float c)
		{
			float num = t * t;
			return b + c * num;
		}

		private static float OutQuintic(float t, float b, float c)
		{
			float num = t * t;
			float num2 = num * t;
			return b + c * (num2 * num + -5f * num * num + 10f * num2 + -10f * num + 5f * t);
		}

		private static float OutQuartic(float t, float b, float c)
		{
			float num = t * t;
			float num2 = num * t;
			return b + c * (-1f * num * num + 4f * num2 + -6f * num + 4f * t);
		}

		private static float OutCubic(float t, float b, float c)
		{
			float num = t * t;
			float num2 = num * t;
			return b + c * (num2 + -3f * num + 3f * t);
		}

		private static float OutInCubic(float t, float b, float c)
		{
			float num = t * t;
			float num2 = num * t;
			return b + c * (4f * num2 + -6f * num + 3f * t);
		}

		private static float OutInQuartic(float t, float b, float c)
		{
			float num = t * t;
			float num2 = num * t;
			return b + c * (6f * num2 + -9f * num + 4f * t);
		}

		private static float BackInCubic(float t, float b, float c)
		{
			float num = t * t;
			float num2 = num * t;
			return b + c * (4f * num2 + -3f * num);
		}

		private static float BackInQuartic(float t, float b, float c)
		{
			float num = t * t;
			float num2 = num * t;
			return b + c * (2f * num * num + 2f * num2 + -3f * num);
		}

		private static float OutBackCubic(float t, float b, float c)
		{
			float num = t * t;
			float num2 = num * t;
			return b + c * (4f * num2 + -9f * num + 6f * t);
		}

		private static float OutBackQuartic(float t, float b, float c)
		{
			float num = t * t;
			float num2 = num * t;
			return b + c * (-2f * num * num + 10f * num2 + -15f * num + 8f * t);
		}

		private static float OutElasticSmall(float t, float b, float c)
		{
			float num = t * t;
			float num2 = num * t;
			return b + c * (33f * num2 * num + -106f * num * num + 126f * num2 + -67f * num + 15f * t);
		}

		private static float OutElasticBig(float t, float b, float c)
		{
			float num = t * t;
			float num2 = num * t;
			return b + c * (56f * num2 * num + -175f * num * num + 200f * num2 + -100f * num + 20f * t);
		}

		private static float InElasticSmall(float t, float b, float c)
		{
			float num = t * t;
			float num2 = num * t;
			return b + c * (33f * num2 * num + -59f * num * num + 32f * num2 + -5f * num);
		}

		private static float InElasticBig(float t, float b, float c)
		{
			float num = t * t;
			float num2 = num * t;
			return b + c * (56f * num2 * num + -105f * num * num + 60f * num2 + -10f * num);
		}

		private static float InSine(float t, float b, float c)
		{
			c -= b;
			return (0f - c) * Mathf.Cos(t / 1f * ((float)Math.PI / 2f)) + c + b;
		}

		private static float OutSine(float t, float b, float c)
		{
			c -= b;
			return c * Mathf.Sin(t / 1f * ((float)Math.PI / 2f)) + b;
		}

		private static float InOutSine(float t, float b, float c)
		{
			c -= b;
			return (0f - c) / 2f * (Mathf.Cos((float)Math.PI * t / 1f) - 1f) + b;
		}

		private static float InElastic(float t, float b, float c)
		{
			c -= b;
			float num = 1f;
			float num2 = num * 0.3f;
			float num3 = 0f;
			float num4 = 0f;
			if (t == 0f)
			{
				return b;
			}
			if ((t /= num) == 1f)
			{
				return b + c;
			}
			if (num4 == 0f || num4 < Mathf.Abs(c))
			{
				num4 = c;
				num3 = num2 / 4f;
			}
			else
			{
				num3 = num2 / ((float)Math.PI * 2f) * Mathf.Asin(c / num4);
			}
			return 0f - num4 * Mathf.Pow(2f, 10f * (t -= 1f)) * Mathf.Sin((t * num - num3) * ((float)Math.PI * 2f) / num2) + b;
		}

		private static float OutElastic(float t, float b, float c)
		{
			c -= b;
			float num = 1f;
			float num2 = num * 0.3f;
			float num3 = 0f;
			float num4 = 0f;
			if (t == 0f)
			{
				return b;
			}
			if ((t /= num) == 1f)
			{
				return b + c;
			}
			if (num4 == 0f || num4 < Mathf.Abs(c))
			{
				num4 = c;
				num3 = num2 / 4f;
			}
			else
			{
				num3 = num2 / ((float)Math.PI * 2f) * Mathf.Asin(c / num4);
			}
			return num4 * Mathf.Pow(2f, -10f * t) * Mathf.Sin((t * num - num3) * ((float)Math.PI * 2f) / num2) + c + b;
		}

		private static float InBack(float t, float b, float c)
		{
			c -= b;
			t /= 1f;
			float num = 1.70158f;
			return c * t * t * ((num + 1f) * t - num) + b;
		}

		private static float OutBack(float t, float b, float c)
		{
			float num = 1.70158f;
			c -= b;
			t = t / 1f - 1f;
			return c * (t * t * ((num + 1f) * t + num) + 1f) + b;
		}
	}
	public class LargeHeader : PropertyAttribute
	{
		public string name;

		public string color = "white";

		public LargeHeader(string name)
		{
			this.name = name;
			color = "white";
		}

		public LargeHeader(string name, string color)
		{
			this.name = name;
			this.color = color;
		}
	}
	public static class LayerMaskExtensions
	{
		public static bool Contains(LayerMask mask, int layer)
		{
			return (int)mask == ((int)mask | (1 << layer));
		}

		public static LayerMask Create(params string[] layerNames)
		{
			return NamesToMask(layerNames);
		}

		public static LayerMask Create(params int[] layerNumbers)
		{
			return LayerNumbersToMask(layerNumbers);
		}

		public static LayerMask NamesToMask(params string[] layerNames)
		{
			LayerMask layerMask = 0;
			foreach (string layerName in layerNames)
			{
				layerMask = (int)layerMask | (1 << LayerMask.NameToLayer(layerName));
			}
			return layerMask;
		}

		public static LayerMask LayerNumbersToMask(params int[] layerNumbers)
		{
			LayerMask layerMask = 0;
			foreach (int num in layerNumbers)
			{
				layerMask = (int)layerMask | (1 << num);
			}
			return layerMask;
		}

		public static LayerMask Inverse(this LayerMask original)
		{
			return ~(int)original;
		}

		public static LayerMask AddToMask(this LayerMask original, params string[] layerNames)
		{
			return (int)original | (int)NamesToMask(layerNames);
		}

		public static LayerMask RemoveFromMask(this LayerMask original, params string[] layerNames)
		{
			return ~((int)(LayerMask)(~(int)original) | (int)NamesToMask(layerNames));
		}

		public static string[] MaskToNames(this LayerMask original)
		{
			List<string> list = new List<string>();
			for (int i = 0; i < 32; i++)
			{
				int num = 1 << i;
				if (((int)original & num) == num)
				{
					string text = LayerMask.LayerToName(i);
					if (!string.IsNullOrEmpty(text))
					{
						list.Add(text);
					}
				}
			}
			return list.ToArray();
		}

		public static int[] MaskToNumbers(this LayerMask original)
		{
			List<int> list = new List<int>();
			for (int i = 0; i < 32; i++)
			{
				int num = 1 << i;
				if (((int)original & num) == num)
				{
					list.Add(i);
				}
			}
			return list.ToArray();
		}

		public static string MaskToString(this LayerMask original)
		{
			return original.MaskToString(", ");
		}

		public static string MaskToString(this LayerMask original, string delimiter)
		{
			return string.Join(delimiter, original.MaskToNames());
		}
	}
	public static class QuaTools
	{
		public static Quaternion Lerp(Quaternion fromRotation, Quaternion toRotation, float weight)
		{
			if (weight <= 0f)
			{
				return fromRotation;
			}
			if (weight >= 1f)
			{
				return toRotation;
			}
			return Quaternion.Lerp(fromRotation, toRotation, weight);
		}

		public static Quaternion Slerp(Quaternion fromRotation, Quaternion toRotation, float weight)
		{
			if (weight <= 0f)
			{
				return fromRotation;
			}
			if (weight >= 1f)
			{
				return toRotation;
			}
			return Quaternion.Slerp(fromRotation, toRotation, weight);
		}

		public static Quaternion LinearBlend(Quaternion q, float weight)
		{
			if (weight <= 0f)
			{
				return Quaternion.identity;
			}
			if (weight >= 1f)
			{
				return q;
			}
			return Quaternion.Lerp(Quaternion.identity, q, weight);
		}

		public static Quaternion SphericalBlend(Quaternion q, float weight)
		{
			if (weight <= 0f)
			{
				return Quaternion.identity;
			}
			if (weight >= 1f)
			{
				return q;
			}
			return Quaternion.Slerp(Quaternion.identity, q, weight);
		}

		public static Quaternion FromToAroundAxis(Vector3 fromDirection, Vector3 toDirection, Vector3 axis)
		{
			Quaternion quaternion = Quaternion.FromToRotation(fromDirection, toDirection);
			float angle = 0f;
			Vector3 axis2 = Vector3.zero;
			quaternion.ToAngleAxis(out angle, out axis2);
			if (Vector3.Dot(axis2, axis) < 0f)
			{
				angle = 0f - angle;
			}
			return Quaternion.AngleAxis(angle, axis);
		}

		public static Quaternion RotationToLocalSpace(Quaternion space, Quaternion rotation)
		{
			return Quaternion.Inverse(Quaternion.Inverse(space) * rotation);
		}

		public static Quaternion FromToRotation(Quaternion from, Quaternion to)
		{
			if (to == from)
			{
				return Quaternion.identity;
			}
			return to * Quaternion.Inverse(from);
		}

		public static Vector3 GetAxis(Vector3 v)
		{
			Vector3 vector = Vector3.right;
			bool flag = false;
			float num = Vector3.Dot(v, Vector3.right);
			float num2 = Mathf.Abs(num);
			if (num < 0f)
			{
				flag = true;
			}
			float num3 = Vector3.Dot(v, Vector3.up);
			float num4 = Mathf.Abs(num3);
			if (num4 > num2)
			{
				num2 = num4;
				vector = Vector3.up;
				flag = num3 < 0f;
			}
			float num5 = Vector3.Dot(v, Vector3.forward);
			num4 = Mathf.Abs(num5);
			if (num4 > num2)
			{
				vector = Vector3.forward;
				flag = num5 < 0f;
			}
			if (flag)
			{
				vector = -vector;
			}
			return vector;
		}

		public static Quaternion ClampRotation(Quaternion rotation, float clampWeight, int clampSmoothing)
		{
			if (clampWeight >= 1f)
			{
				return Quaternion.identity;
			}
			if (clampWeight <= 0f)
			{
				return rotation;
			}
			float num = Quaternion.Angle(Quaternion.identity, rotation);
			float num2 = 1f - num / 180f;
			float num3 = Mathf.Clamp(1f - (clampWeight - num2) / (1f - num2), 0f, 1f);
			float num4 = Mathf.Clamp(num2 / clampWeight, 0f, 1f);
			for (int i = 0; i < clampSmoothing; i++)
			{
				num4 = Mathf.Sin(num4 * (float)Math.PI * 0.5f);
			}
			return Quaternion.Slerp(Quaternion.identity, rotation, num4 * num3);
		}

		public static float ClampAngle(float angle, float clampWeight, int clampSmoothing)
		{
			if (clampWeight >= 1f)
			{
				return 0f;
			}
			if (clampWeight <= 0f)
			{
				return angle;
			}
			float num = 1f - Mathf.Abs(angle) / 180f;
			float num2 = Mathf.Clamp(1f - (clampWeight - num) / (1f - num), 0f, 1f);
			float num3 = Mathf.Clamp(num / clampWeight, 0f, 1f);
			for (int i = 0; i < clampSmoothing; i++)
			{
				num3 = Mathf.Sin(num3 * (float)Math.PI * 0.5f);
			}
			return Mathf.Lerp(0f, angle, num3 * num2);
		}

		public static Quaternion MatchRotation(Quaternion targetRotation, Vector3 targetforwardAxis, Vector3 targetUpAxis, Vector3 forwardAxis, Vector3 upAxis)
		{
			Quaternion rotation = Quaternion.LookRotation(forwardAxis, upAxis);
			Quaternion quaternion = Quaternion.LookRotation(targetforwardAxis, targetUpAxis);
			return targetRotation * quaternion * Quaternion.Inverse(rotation);
		}
	}
	public abstract class Singleton<T> : MonoBehaviour where T : Singleton<T>
	{
		private static T sInstance;

		public static T instance => sInstance;

		protected virtual void Awake()
		{
			if (sInstance != null)
			{
				UnityEngine.Debug.LogError(base.name + "error: already initialized", this);
			}
			sInstance = (T)this;
		}
	}
	public class SolverManager : MonoBehaviour
	{
		[Tooltip("If true, will fix all the Transforms used by the solver to their initial state in each Update. This prevents potential problems with unanimated bones and animator culling with a small cost of performance. Not recommended for CCD and FABRIK solvers.")]
		public bool fixTransforms = true;

		private Animator animator;

		private Animation legacy;

		private bool updateFrame;

		private bool componentInitiated;

		private bool skipSolverUpdate;

		private bool animatePhysics
		{
			get
			{
				if (animator != null)
				{
					return animator.updateMode == AnimatorUpdateMode.AnimatePhysics;
				}
				if (legacy != null)
				{
					return legacy.animatePhysics;
				}
				return false;
			}
		}

		private bool isAnimated
		{
			get
			{
				if (!(animator != null))
				{
					return legacy != null;
				}
				return true;
			}
		}

		public void Disable()
		{
			UnityEngine.Debug.Log("IK.Disable() is deprecated. Use enabled = false instead", base.transform);
			base.enabled = false;
		}

		protected virtual void InitiateSolver()
		{
		}

		protected virtual void UpdateSolver()
		{
		}

		protected virtual void FixTransforms()
		{
		}

		private void OnDisable()
		{
			if (Application.isPlaying)
			{
				Initiate();
			}
		}

		private void Start()
		{
			Initiate();
		}

		private void Initiate()
		{
			if (!componentInitiated)
			{
				FindAnimatorRecursive(base.transform, findInChildren: true);
				InitiateSolver();
				componentInitiated = true;
			}
		}

		private void Update()
		{
			if (!skipSolverUpdate && !animatePhysics && fixTransforms)
			{
				FixTransforms();
			}
		}

		private void FindAnimatorRecursive(Transform t, bool findInChildren)
		{
			if (isAnimated)
			{
				return;
			}
			animator = t.GetComponent<Animator>();
			legacy = t.GetComponent<Animation>();
			if (!isAnimated)
			{
				if (animator == null && findInChildren)
				{
					animator = t.GetComponentInChildren<Animator>();
				}
				if (legacy == null && findInChildren)
				{
					legacy = t.GetComponentInChildren<Animation>();
				}
				if (!isAnimated && t.parent != null)
				{
					FindAnimatorRecursive(t.parent, findInChildren: false);
				}
			}
		}

		private void FixedUpdate()
		{
			if (skipSolverUpdate)
			{
				skipSolverUpdate = false;
			}
			updateFrame = true;
			if (animatePhysics && fixTransforms)
			{
				FixTransforms();
			}
		}

		private void LateUpdate()
		{
			if (!skipSolverUpdate)
			{
				if (!animatePhysics)
				{
					updateFrame = true;
				}
				if (updateFrame)
				{
					updateFrame = false;
					UpdateSolver();
				}
			}
		}

		public void UpdateSolverExternal()
		{
			if (base.enabled)
			{
				skipSolverUpdate = true;
				UpdateSolver();
			}
		}
	}
	public class TriggerEventBroadcaster : MonoBehaviour
	{
		public GameObject target;

		private void OnTriggerEnter(Collider collider)
		{
			if (target != null)
			{
				target.SendMessage("OnTriggerEnter", collider, SendMessageOptions.DontRequireReceiver);
			}
		}

		private void OnTriggerStay(Collider collider)
		{
			if (target != null)
			{
				target.SendMessage("OnTriggerStay", collider, SendMessageOptions.DontRequireReceiver);
			}
		}

		private void OnTriggerExit(Collider collider)
		{
			if (target != null)
			{
				target.SendMessage("OnTriggerExit", collider, SendMessageOptions.DontRequireReceiver);
			}
		}
	}
	public static class V3Tools
	{
		public static Vector3 Lerp(Vector3 fromVector, Vector3 toVector, float weight)
		{
			if (weight <= 0f)
			{
				return fromVector;
			}
			if (weight >= 1f)
			{
				return toVector;
			}
			return Vector3.Lerp(fromVector, toVector, weight);
		}

		public static Vector3 Slerp(Vector3 fromVector, Vector3 toVector, float weight)
		{
			if (weight <= 0f)
			{
				return fromVector;
			}
			if (weight >= 1f)
			{
				return toVector;
			}
			return Vector3.Slerp(fromVector, toVector, weight);
		}

		public static Vector3 ExtractVertical(Vector3 v, Vector3 verticalAxis, float weight)
		{
			if (weight == 0f)
			{
				return Vector3.zero;
			}
			return Vector3.Project(v, verticalAxis) * weight;
		}

		public static Vector3 ExtractHorizontal(Vector3 v, Vector3 normal, float weight)
		{
			if (weight == 0f)
			{
				return Vector3.zero;
			}
			Vector3 tangent = v;
			Vector3.OrthoNormalize(ref normal, ref tangent);
			return Vector3.Project(v, tangent) * weight;
		}

		public static Vector3 ClampDirection(Vector3 direction, Vector3 normalDirection, float clampWeight, int clampSmoothing, out bool changed)
		{
			changed = false;
			if (clampWeight <= 0f)
			{
				return direction;
			}
			if (clampWeight >= 1f)
			{
				changed = true;
				return normalDirection;
			}
			float num = Vector3.Angle(normalDirection, direction);
			float num2 = 1f - num / 180f;
			if (num2 > clampWeight)
			{
				return direction;
			}
			changed = true;
			float num3 = ((clampWeight > 0f) ? Mathf.Clamp(1f - (clampWeight - num2) / (1f - num2), 0f, 1f) : 1f);
			float num4 = ((clampWeight > 0f) ? Mathf.Clamp(num2 / clampWeight, 0f, 1f) : 1f);
			for (int i = 0; i < clampSmoothing; i++)
			{
				num4 = Mathf.Sin(num4 * (float)Math.PI * 0.5f);
			}
			return Vector3.Slerp(normalDirection, direction, num4 * num3);
		}

		public static Vector3 ClampDirection(Vector3 direction, Vector3 normalDirection, float clampWeight, int clampSmoothing, out float clampValue)
		{
			clampValue = 1f;
			if (clampWeight <= 0f)
			{
				return direction;
			}
			if (clampWeight >= 1f)
			{
				return normalDirection;
			}
			float num = Vector3.Angle(normalDirection, direction);
			float num2 = 1f - num / 180f;
			if (num2 > clampWeight)
			{
				clampValue = 0f;
				return direction;
			}
			float num3 = ((clampWeight > 0f) ? Mathf.Clamp(1f - (clampWeight - num2) / (1f - num2), 0f, 1f) : 1f);
			float num4 = ((clampWeight > 0f) ? Mathf.Clamp(num2 / clampWeight, 0f, 1f) : 1f);
			for (int i = 0; i < clampSmoothing; i++)
			{
				num4 = Mathf.Sin(num4 * (float)Math.PI * 0.5f);
			}
			float num5 = num4 * num3;
			clampValue = 1f - num5;
			return Vector3.Slerp(normalDirection, direction, num5);
		}

		public static Vector3 LineToPlane(Vector3 origin, Vector3 direction, Vector3 planeNormal, Vector3 planePoint)
		{
			float num = Vector3.Dot(planePoint - origin, planeNormal);
			float num2 = Vector3.Dot(direction, planeNormal);
			if (num2 == 0f)
			{
				return Vector3.zero;
			}
			float num3 = num / num2;
			return origin + direction.normalized * num3;
		}

		public static Vector3 PointToPlane(Vector3 point, Vector3 planePosition, Vector3 planeNormal)
		{
			if (planeNormal == Vector3.up)
			{
				return new Vector3(point.x, planePosition.y, point.z);
			}
			Vector3 tangent = point - planePosition;
			Vector3 normal = planeNormal;
			Vector3.OrthoNormalize(ref normal, ref tangent);
			return planePosition + Vector3.Project(point - planePosition, tangent);
		}
	}
	public static class Warning
	{
		public delegate void Logger(string message);

		public static bool logged;

		public static void Log(string message, Logger logger, bool logInEditMode = false)
		{
			if ((logInEditMode || Application.isPlaying) && !logged)
			{
				logger?.Invoke(message);
				logged = true;
			}
		}

		public static void Log(string message, Transform context, bool logInEditMode = false)
		{
			if ((logInEditMode || Application.isPlaying) && !logged)
			{
				UnityEngine.Debug.LogWarning(message, context);
				logged = true;
			}
		}
	}
}
namespace RootMotion.FinalIK
{
	[HelpURL("http://www.root-motion.com/finalikdox/html/page2.html")]
	[AddComponentMenu("Scripts/RootMotion.FinalIK/IK/Biped IK")]
	public class BipedIK : SolverManager
	{
		public BipedReferences references = new BipedReferences();

		public BipedIKSolvers solvers = new BipedIKSolvers();

		[ContextMenu("User Manual")]
		private void OpenUserManual()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/page2.html");
		}

		[ContextMenu("Scrpt Reference")]
		private void OpenScriptReference()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/class_root_motion_1_1_final_i_k_1_1_biped_i_k.html");
		}

		[ContextMenu("Support Group")]
		private void SupportGroup()
		{
			Application.OpenURL("https://groups.google.com/forum/#!forum/final-ik");
		}

		[ContextMenu("Asset Store Thread")]
		private void ASThread()
		{
			Application.OpenURL("http://forum.unity3d.com/threads/final-ik-full-body-ik-aim-look-at-fabrik-ccd-ik-1-0-released.222685/");
		}

		public float GetIKPositionWeight(AvatarIKGoal goal)
		{
			return GetGoalIK(goal).GetIKPositionWeight();
		}

		public float GetIKRotationWeight(AvatarIKGoal goal)
		{
			return GetGoalIK(goal).GetIKRotationWeight();
		}

		public void SetIKPositionWeight(AvatarIKGoal goal, float weight)
		{
			GetGoalIK(goal).SetIKPositionWeight(weight);
		}

		public void SetIKRotationWeight(AvatarIKGoal goal, float weight)
		{
			GetGoalIK(goal).SetIKRotationWeight(weight);
		}

		public void SetIKPosition(AvatarIKGoal goal, Vector3 IKPosition)
		{
			GetGoalIK(goal).SetIKPosition(IKPosition);
		}

		public void SetIKRotation(AvatarIKGoal goal, Quaternion IKRotation)
		{
			GetGoalIK(goal).SetIKRotation(IKRotation);
		}

		public Vector3 GetIKPosition(AvatarIKGoal goal)
		{
			return GetGoalIK(goal).GetIKPosition();
		}

		public Quaternion GetIKRotation(AvatarIKGoal goal)
		{
			return GetGoalIK(goal).GetIKRotation();
		}

		public void SetLookAtWeight(float weight, float bodyWeight, float headWeight, float eyesWeight, float clampWeight, float clampWeightHead, float clampWeightEyes)
		{
			solvers.lookAt.SetLookAtWeight(weight, bodyWeight, headWeight, eyesWeight, clampWeight, clampWeightHead, clampWeightEyes);
		}

		public void SetLookAtPosition(Vector3 lookAtPosition)
		{
			solvers.lookAt.SetIKPosition(lookAtPosition);
		}

		public void SetSpinePosition(Vector3 spinePosition)
		{
			solvers.spine.SetIKPosition(spinePosition);
		}

		public void SetSpineWeight(float weight)
		{
			solvers.spine.SetIKPositionWeight(weight);
		}

		public IKSolverLimb GetGoalIK(AvatarIKGoal goal)
		{
			return goal switch
			{
				AvatarIKGoal.LeftFoot => solvers.leftFoot, 
				AvatarIKGoal.RightFoot => solvers.rightFoot, 
				AvatarIKGoal.LeftHand => solvers.leftHand, 
				AvatarIKGoal.RightHand => solvers.rightHand, 
				_ => null, 
			};
		}

		public void InitiateBipedIK()
		{
			InitiateSolver();
		}

		public void UpdateBipedIK()
		{
			UpdateSolver();
		}

		public void SetToDefaults()
		{
			IKSolverLimb[] limbs = solvers.limbs;
			foreach (IKSolverLimb obj in limbs)
			{
				obj.SetIKPositionWeight(0f);
				obj.SetIKRotationWeight(0f);
				obj.bendModifier = IKSolverLimb.BendModifier.Animation;
				obj.bendModifierWeight = 1f;
			}
			solvers.leftHand.maintainRotationWeight = 0f;
			solvers.rightHand.maintainRotationWeight = 0f;
			solvers.spine.SetIKPositionWeight(0f);
			solvers.spine.tolerance = 0f;
			solvers.spine.maxIterations = 2;
			solvers.spine.useRotationLimits = false;
			solvers.aim.SetIKPositionWeight(0f);
			solvers.aim.tolerance = 0f;
			solvers.aim.maxIterations = 2;
			SetLookAtWeight(0f, 0.5f, 1f, 1f, 0.5f, 0.7f, 0.5f);
		}

		protected override void FixTransforms()
		{
			solvers.lookAt.FixTransforms();
			for (int i = 0; i < solvers.limbs.Length; i++)
			{
				solvers.limbs[i].FixTransforms();
			}
		}

		protected override void InitiateSolver()
		{
			string errorMessage = "";
			if (BipedReferences.SetupError(references, ref errorMessage))
			{
				Warning.Log(errorMessage, references.root);
				return;
			}
			solvers.AssignReferences(references);
			if (solvers.spine.bones.Length > 1)
			{
				solvers.spine.Initiate(base.transform);
			}
			solvers.lookAt.Initiate(base.transform);
			solvers.aim.Initiate(base.transform);
			IKSolverLimb[] limbs = solvers.limbs;
			for (int i = 0; i < limbs.Length; i++)
			{
				limbs[i].Initiate(base.transform);
			}
			solvers.pelvis.Initiate(references.pelvis);
		}

		protected override void UpdateSolver()
		{
			for (int i = 0; i < solvers.limbs.Length; i++)
			{
				solvers.limbs[i].MaintainBend();
				solvers.limbs[i].MaintainRotation();
			}
			solvers.pelvis.Update();
			if (solvers.spine.bones.Length > 1)
			{
				solvers.spine.Update();
			}
			solvers.aim.Update();
			solvers.lookAt.Update();
			for (int j = 0; j < solvers.limbs.Length; j++)
			{
				solvers.limbs[j].Update();
			}
		}

		public void LogWarning(string message)
		{
			Warning.Log(message, base.transform);
		}
	}
	[Serializable]
	public class BipedIKSolvers
	{
		public IKSolverLimb leftFoot = new IKSolverLimb(AvatarIKGoal.LeftFoot);

		public IKSolverLimb rightFoot = new IKSolverLimb(AvatarIKGoal.RightFoot);

		public IKSolverLimb leftHand = new IKSolverLimb(AvatarIKGoal.LeftHand);

		public IKSolverLimb rightHand = new IKSolverLimb(AvatarIKGoal.RightHand);

		public IKSolverFABRIK spine = new IKSolverFABRIK();

		public IKSolverLookAt lookAt = new IKSolverLookAt();

		public IKSolverAim aim = new IKSolverAim();

		public Constraints pelvis = new Constraints();

		private IKSolverLimb[] _limbs;

		private IKSolver[] _ikSolvers;

		public IKSolverLimb[] limbs
		{
			get
			{
				if (_limbs == null || (_limbs != null && _limbs.Length != 4))
				{
					_limbs = new IKSolverLimb[4] { leftFoot, rightFoot, leftHand, rightHand };
				}
				return _limbs;
			}
		}

		public IKSolver[] ikSolvers
		{
			get
			{
				if (_ikSolvers == null || (_ikSolvers != null && _ikSolvers.Length != 7))
				{
					_ikSolvers = new IKSolver[7] { leftFoot, rightFoot, leftHand, rightHand, spine, lookAt, aim };
				}
				return _ikSolvers;
			}
		}

		public void AssignReferences(BipedReferences references)
		{
			leftHand.SetChain(references.leftUpperArm, references.leftForearm, references.leftHand, references.root);
			rightHand.SetChain(references.rightUpperArm, references.rightForearm, references.rightHand, references.root);
			leftFoot.SetChain(references.leftThigh, references.leftCalf, references.leftFoot, references.root);
			rightFoot.SetChain(references.rightThigh, references.rightCalf, references.rightFoot, references.root);
			spine.SetChain(references.spine, references.root);
			lookAt.SetChain(references.spine, references.head, references.eyes, references.root);
			aim.SetChain(references.spine, references.root);
			leftFoot.goal = AvatarIKGoal.LeftFoot;
			rightFoot.goal = AvatarIKGoal.RightFoot;
			leftHand.goal = AvatarIKGoal.LeftHand;
			rightHand.goal = AvatarIKGoal.RightHand;
		}
	}
	[Serializable]
	public abstract class Constraint
	{
		public Transform transform;

		public float weight;

		public bool isValid => transform != null;

		public abstract void UpdateConstraint();
	}
	[Serializable]
	public class ConstraintPosition : Constraint
	{
		public Vector3 position;

		public override void UpdateConstraint()
		{
			if (!(weight <= 0f) && base.isValid)
			{
				transform.position = Vector3.Lerp(transform.position, position, weight);
			}
		}

		public ConstraintPosition()
		{
		}

		public ConstraintPosition(Transform transform)
		{
			base.transform = transform;
		}
	}
	[Serializable]
	public class ConstraintPositionOffset : Constraint
	{
		public Vector3 offset;

		private Vector3 defaultLocalPosition;

		private Vector3 lastLocalPosition;

		private bool initiated;

		private bool positionChanged => transform.localPosition != lastLocalPosition;

		public override void UpdateConstraint()
		{
			if (!(weight <= 0f) && base.isValid)
			{
				if (!initiated)
				{
					defaultLocalPosition = transform.localPosition;
					lastLocalPosition = transform.localPosition;
					initiated = true;
				}
				if (positionChanged)
				{
					defaultLocalPosition = transform.localPosition;
				}
				transform.localPosition = defaultLocalPosition;
				transform.position += offset * weight;
				lastLocalPosition = transform.localPosition;
			}
		}

		public ConstraintPositionOffset()
		{
		}

		public ConstraintPositionOffset(Transform transform)
		{
			base.transform = transform;
		}
	}
	[Serializable]
	public class ConstraintRotation : Constraint
	{
		public Quaternion rotation;

		public override void UpdateConstraint()
		{
			if (!(weight <= 0f) && base.isValid)
			{
				transform.rotation = Quaternion.Slerp(transform.rotation, rotation, weight);
			}
		}

		public ConstraintRotation()
		{
		}

		public ConstraintRotation(Transform transform)
		{
			base.transform = transform;
		}
	}
	[Serializable]
	public class ConstraintRotationOffset : Constraint
	{
		public Quaternion offset;

		private Quaternion defaultRotation;

		private Quaternion defaultLocalRotation;

		private Quaternion lastLocalRotation;

		private Quaternion defaultTargetLocalRotation;

		private bool initiated;

		private bool rotationChanged => transform.localRotation != lastLocalRotation;

		public override void UpdateConstraint()
		{
			if (!(weight <= 0f) && base.isValid)
			{
				if (!initiated)
				{
					defaultLocalRotation = transform.localRotation;
					lastLocalRotation = transform.localRotation;
					initiated = true;
				}
				if (rotationChanged)
				{
					defaultLocalRotation = transform.localRotation;
				}
				transform.localRotation = defaultLocalRotation;
				transform.rotation = Quaternion.Slerp(transform.rotation, offset, weight);
				lastLocalRotation = transform.localRotation;
			}
		}

		public ConstraintRotationOffset()
		{
		}

		public ConstraintRotationOffset(Transform transform)
		{
			base.transform = transform;
		}
	}
	[Serializable]
	public class Constraints
	{
		public Transform transform;

		public Transform target;

		public Vector3 positionOffset;

		public Vector3 position;

		[Range(0f, 1f)]
		public float positionWeight;

		public Vector3 rotationOffset;

		public Vector3 rotation;

		[Range(0f, 1f)]
		public float rotationWeight;

		public bool IsValid()
		{
			return transform != null;
		}

		public void Initiate(Transform transform)
		{
			this.transform = transform;
			position = transform.position;
			rotation = transform.eulerAngles;
		}

		public void Update()
		{
			if (IsValid())
			{
				if (target != null)
				{
					position = target.position;
				}
				transform.position += positionOffset;
				if (positionWeight > 0f)
				{
					transform.position = Vector3.Lerp(transform.position, position, positionWeight);
				}
				if (target != null)
				{
					rotation = target.eulerAngles;
				}
				transform.rotation = Quaternion.Euler(rotationOffset) * transform.rotation;
				if (rotationWeight > 0f)
				{
					transform.rotation = Quaternion.Slerp(transform.rotation, Quaternion.Euler(rotation), rotationWeight);
				}
			}
		}
	}
	[Serializable]
	public class Finger
	{
		[Tooltip("Master Weight for the finger.")]
		[Range(0f, 1f)]
		public float weight = 1f;

		[Tooltip("The first bone of the finger.")]
		public Transform bone1;

		[Tooltip("The second bone of the finger.")]
		public Transform bone2;

		[Tooltip("The (optional) third bone of the finger. This can be ignored for thumbs.")]
		public Transform bone3;

		[Tooltip("The fingertip object. If your character doesn't have tip bones, you can create an empty GameObject and parent it to the last bone in the finger. Place it to the tip of the finger.")]
		public Transform tip;

		[Tooltip("The IK target (optional, can use IKPosition and IKRotation directly).")]
		public Transform target;

		private IKSolverLimb solver;

		private Quaternion bone3RelativeToTarget;

		private Vector3 bone3DefaultLocalPosition;

		private Quaternion bone3DefaultLocalRotation;

		public bool initiated { get; private set; }

		public Vector3 IKPosition
		{
			get
			{
				return solver.IKPosition;
			}
			set
			{
				solver.IKPosition = value;
			}
		}

		public Quaternion IKRotation
		{
			get
			{
				return solver.IKRotation;
			}
			set
			{
				solver.IKRotation = value;
			}
		}

		public bool IsValid(ref string errorMessage)
		{
			if (bone1 == null || bone2 == null || tip == null)
			{
				errorMessage = "One of the bones in the Finger Rig is null, can not initiate solvers.";
				return false;
			}
			return true;
		}

		public void Initiate(Transform hand, int index)
		{
			initiated = false;
			string errorMessage = string.Empty;
			if (!IsValid(ref errorMessage))
			{
				Warning.Log(errorMessage, hand);
				return;
			}
			solver = new IKSolverLimb();
			solver.IKPositionWeight = weight;
			solver.bendModifier = IKSolverLimb.BendModifier.Target;
			solver.bendModifierWeight = 1f;
			IKPosition = tip.position;
			IKRotation = tip.rotation;
			if (bone3 != null)
			{
				bone3RelativeToTarget = Quaternion.Inverse(IKRotation) * bone3.rotation;
				bone3DefaultLocalPosition = bone3.localPosition;
				bone3DefaultLocalRotation = bone3.localRotation;
			}
			solver.SetChain(bone1, bone2, tip, hand);
			solver.Initiate(hand);
			initiated = true;
		}

		public void FixTransforms()
		{
			if (initiated)
			{
				solver.FixTransforms();
				if (bone3 != null)
				{
					bone3.localPosition = bone3DefaultLocalPosition;
					bone3.localRotation = bone3DefaultLocalRotation;
				}
			}
		}

		public void Update(float masterWeight)
		{
			if (!initiated)
			{
				return;
			}
			float num = weight * masterWeight;
			if (num <= 0f)
			{
				return;
			}
			solver.target = target;
			if (target != null)
			{
				IKPosition = target.position;
				IKRotation = target.rotation;
			}
			if (bone3 != null)
			{
				if (num >= 1f)
				{
					bone3.rotation = IKRotation * bone3RelativeToTarget;
				}
				else
				{
					bone3.rotation = Quaternion.Lerp(bone3.rotation, IKRotation * bone3RelativeToTarget, num);
				}
			}
			solver.IKPositionWeight = num;
			solver.Update();
		}
	}
	public class FingerRig : SolverManager
	{
		[Tooltip("The master weight for all fingers.")]
		[Range(0f, 1f)]
		public float weight = 1f;

		public Finger[] fingers = new Finger[0];

		public bool initiated { get; private set; }

		public bool IsValid(ref string errorMessage)
		{
			Finger[] array = fingers;
			for (int i = 0; i < array.Length; i++)
			{
				if (!array[i].IsValid(ref errorMessage))
				{
					return false;
				}
			}
			return true;
		}

		[ContextMenu("Auto-detect")]
		public void AutoDetect()
		{
			fingers = new Finger[0];
			for (int i = 0; i < base.transform.childCount; i++)
			{
				Transform[] array = new Transform[0];
				AddChildrenRecursive(base.transform.GetChild(i), ref array);
				if (array.Length == 3 || array.Length == 4)
				{
					Finger finger = new Finger();
					finger.bone1 = array[0];
					finger.bone2 = array[1];
					if (array.Length == 3)
					{
						finger.tip = array[2];
					}
					else
					{
						finger.bone3 = array[2];
						finger.tip = array[3];
					}
					finger.weight = 1f;
					Array.Resize(ref fingers, fingers.Length + 1);
					fingers[fingers.Length - 1] = finger;
				}
			}
		}

		public void AddFinger(Transform bone1, Transform bone2, Transform bone3, Transform tip, Transform target = null)
		{
			Finger finger = new Finger();
			finger.bone1 = bone1;
			finger.bone2 = bone2;
			finger.bone3 = bone3;
			finger.tip = tip;
			finger.target = target;
			Array.Resize(ref fingers, fingers.Length + 1);
			fingers[fingers.Length - 1] = finger;
			initiated = false;
			finger.Initiate(base.transform, fingers.Length - 1);
			if (fingers[fingers.Length - 1].initiated)
			{
				initiated = true;
			}
		}

		public void RemoveFinger(int index)
		{
			if ((float)index < 0f || index >= fingers.Length)
			{
				Warning.Log("RemoveFinger index out of bounds.", base.transform);
				return;
			}
			if (fingers.Length == 1)
			{
				fingers = new Finger[0];
				return;
			}
			Finger[] array = new Finger[fingers.Length - 1];
			int num = 0;
			for (int i = 0; i < fingers.Length; i++)
			{
				if (i != index)
				{
					array[num] = fingers[i];
					num++;
				}
			}
			fingers = array;
		}

		private void AddChildrenRecursive(Transform parent, ref Transform[] array)
		{
			Array.Resize(ref array, array.Length + 1);
			array[array.Length - 1] = parent;
			if (parent.childCount == 1)
			{
				AddChildrenRecursive(parent.GetChild(0), ref array);
			}
		}

		protected override void InitiateSolver()
		{
			initiated = true;
			for (int i = 0; i < fingers.Length; i++)
			{
				fingers[i].Initiate(base.transform, i);
				if (!fingers[i].initiated)
				{
					initiated = false;
				}
			}
		}

		public void UpdateFingerSolvers()
		{
			if (!(weight <= 0f))
			{
				Finger[] array = fingers;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].Update(weight);
				}
			}
		}

		public void FixFingerTransforms()
		{
			Finger[] array = fingers;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].FixTransforms();
			}
		}

		protected override void UpdateSolver()
		{
			UpdateFingerSolvers();
		}

		protected override void FixTransforms()
		{
			FixFingerTransforms();
		}
	}
	public abstract class Grounder : MonoBehaviour
	{
		public delegate void GrounderDelegate();

		[Tooltip("The master weight. Use this to fade in/out the grounding effect.")]
		[Range(0f, 1f)]
		public float weight = 1f;

		[Tooltip("The Grounding solver. Not to confuse with IK solvers.")]
		public Grounding solver = new Grounding();

		public GrounderDelegate OnPreGrounder;

		public GrounderDelegate OnPostGrounder;

		protected bool initiated;

		public abstract void ResetPosition();

		protected Vector3 GetSpineOffsetTarget()
		{
			Vector3 zero = Vector3.zero;
			for (int i = 0; i < solver.legs.Length; i++)
			{
				zero += GetLegSpineBendVector(solver.legs[i]);
			}
			return zero;
		}

		protected void LogWarning(string message)
		{
			Warning.Log(message, base.transform);
		}

		private Vector3 GetLegSpineBendVector(Grounding.Leg leg)
		{
			Vector3 legSpineTangent = GetLegSpineTangent(leg);
			float num = (Vector3.Dot(solver.root.forward, legSpineTangent.normalized) + 1f) * 0.5f;
			float magnitude = (leg.IKPosition - leg.transform.position).magnitude;
			return legSpineTangent * magnitude * num;
		}

		private Vector3 GetLegSpineTangent(Grounding.Leg leg)
		{
			Vector3 tangent = leg.transform.position - solver.root.position;
			if (!solver.rotateSolver || solver.root.up == Vector3.up)
			{
				return new Vector3(tangent.x, 0f, tangent.z);
			}
			Vector3 normal = solver.root.up;
			Vector3.OrthoNormalize(ref normal, ref tangent);
			return tangent;
		}

		protected abstract void OpenUserManual();

		protected abstract void OpenScriptReference();
	}
	[HelpURL("http://www.root-motion.com/finalikdox/html/page11.html")]
	[AddComponentMenu("Scripts/RootMotion.FinalIK/Grounder/Grounder Biped")]
	public class GrounderBipedIK : Grounder
	{
		[Tooltip("The BipedIK componet.")]
		public BipedIK ik;

		[Tooltip("The amount of spine bending towards upward slopes.")]
		public float spineBend = 7f;

		[Tooltip("The interpolation speed of spine bending.")]
		public float spineSpeed = 3f;

		private Transform[] feet = new Transform[2];

		private Quaternion[] footRotations = new Quaternion[2];

		private Vector3 animatedPelvisLocalPosition;

		private Vector3 solvedPelvisLocalPosition;

		private Vector3 spineOffset;

		private float lastWeight;

		[ContextMenu("User Manual")]
		protected override void OpenUserManual()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/page11.html");
		}

		[ContextMenu("Scrpt Reference")]
		protected override void OpenScriptReference()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/class_root_motion_1_1_final_i_k_1_1_grounder_biped_i_k.html");
		}

		public override void ResetPosition()
		{
			solver.Reset();
			spineOffset = Vector3.zero;
		}

		private bool IsReadyToInitiate()
		{
			if (ik == null)
			{
				return false;
			}
			if (!ik.solvers.leftFoot.initiated)
			{
				return false;
			}
			if (!ik.solvers.rightFoot.initiated)
			{
				return false;
			}
			return true;
		}

		private void Update()
		{
			weight = Mathf.Clamp(weight, 0f, 1f);
			if (!(weight <= 0f) && !initiated && IsReadyToInitiate())
			{
				Initiate();
			}
		}

		private void Initiate()
		{
			feet = new Transform[2];
			footRotations = new Quaternion[2];
			feet[0] = ik.references.leftFoot;
			feet[1] = ik.references.rightFoot;
			footRotations[0] = Quaternion.identity;
			footRotations[1] = Quaternion.identity;
			IKSolverFABRIK spine = ik.solvers.spine;
			spine.OnPreUpdate = (IKSolver.UpdateDelegate)Delegate.Combine(spine.OnPreUpdate, new IKSolver.UpdateDelegate(OnSolverUpdate));
			IKSolverLimb rightFoot = ik.solvers.rightFoot;
			rightFoot.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Combine(rightFoot.OnPostUpdate, new IKSolver.UpdateDelegate(OnPostSolverUpdate));
			animatedPelvisLocalPosition = ik.references.pelvis.localPosition;
			solver.Initiate(ik.references.root, feet);
			initiated = true;
		}

		private void OnDisable()
		{
			if (initiated)
			{
				ik.solvers.leftFoot.IKPositionWeight = 0f;
				ik.solvers.rightFoot.IKPositionWeight = 0f;
			}
		}

		private void OnSolverUpdate()
		{
			if (!base.enabled)
			{
				return;
			}
			if (weight <= 0f)
			{
				if (lastWeight <= 0f)
				{
					return;
				}
				OnDisable();
			}
			lastWeight = weight;
			if (OnPreGrounder != null)
			{
				OnPreGrounder();
			}
			if (ik.references.pelvis.localPosition != solvedPelvisLocalPosition)
			{
				animatedPelvisLocalPosition = ik.references.pelvis.localPosition;
			}
			else
			{
				ik.references.pelvis.localPosition = animatedPelvisLocalPosition;
			}
			solver.Update();
			ik.references.pelvis.position += solver.pelvis.IKOffset * weight;
			SetLegIK(ik.solvers.leftFoot, 0);
			SetLegIK(ik.solvers.rightFoot, 1);
			if (spineBend != 0f && ik.references.spine.Length != 0)
			{
				spineSpeed = Mathf.Clamp(spineSpeed, 0f, spineSpeed);
				Vector3 vector = GetSpineOffsetTarget() * weight;
				spineOffset = Vector3.Lerp(spineOffset, vector * spineBend, Time.deltaTime * spineSpeed);
				Quaternion rotation = ik.references.leftUpperArm.rotation;
				Quaternion rotation2 = ik.references.rightUpperArm.rotation;
				Vector3 up = solver.up;
				Quaternion quaternion = Quaternion.FromToRotation(up, up + spineOffset);
				ik.references.spine[0].rotation = quaternion * ik.references.spine[0].rotation;
				ik.references.leftUpperArm.rotation = rotation;
				ik.references.rightUpperArm.rotation = rotation2;
			}
			if (OnPostGrounder != null)
			{
				OnPostGrounder();
			}
		}

		private void SetLegIK(IKSolverLimb limb, int index)
		{
			footRotations[index] = feet[index].rotation;
			limb.IKPosition = solver.legs[index].IKPosition;
			limb.IKPositionWeight = weight;
		}

		private void OnPostSolverUpdate()
		{
			if (!(weight <= 0f) && base.enabled)
			{
				for (int i = 0; i < feet.Length; i++)
				{
					feet[i].rotation = Quaternion.Slerp(Quaternion.identity, solver.legs[i].rotationOffset, weight) * footRotations[i];
				}
				solvedPelvisLocalPosition = ik.references.pelvis.localPosition;
			}
		}

		private void OnDestroy()
		{
			if (initiated && ik != null)
			{
				IKSolverFABRIK spine = ik.solvers.spine;
				spine.OnPreUpdate = (IKSolver.UpdateDelegate)Delegate.Remove(spine.OnPreUpdate, new IKSolver.UpdateDelegate(OnSolverUpdate));
				IKSolverLimb rightFoot = ik.solvers.rightFoot;
				rightFoot.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Remove(rightFoot.OnPostUpdate, new IKSolver.UpdateDelegate(OnPostSolverUpdate));
			}
		}
	}
	[HelpURL("https://www.youtube.com/watch?v=9MiZiaJorws&index=6&list=PLVxSIA1OaTOu8Nos3CalXbJ2DrKnntMv6")]
	[AddComponentMenu("Scripts/RootMotion.FinalIK/Grounder/Grounder Full Body Biped")]
	public class GrounderFBBIK : Grounder
	{
		[Serializable]
		public class SpineEffector
		{
			[Tooltip("The type of the effector.")]
			public FullBodyBipedEffector effectorType;

			[Tooltip("The weight of horizontal bend offset towards the slope.")]
			public float horizontalWeight = 1f;

			[Tooltip("The vertical bend offset weight.")]
			public float verticalWeight;
		}

		[Tooltip("Reference to the FBBIK componet.")]
		public FullBodyBipedIK ik;

		[Tooltip("The amount of spine bending towards upward slopes.")]
		public float spineBend = 2f;

		[Tooltip("The interpolation speed of spine bending.")]
		public float spineSpeed = 3f;

		public SpineEffector[] spine = new SpineEffector[0];

		private Transform[] feet = new Transform[2];

		private Vector3 spineOffset;

		private bool firstSolve;

		[ContextMenu("TUTORIAL VIDEO")]
		private void OpenTutorial()
		{
			Application.OpenURL("https://www.youtube.com/watch?v=9MiZiaJorws&index=6&list=PLVxSIA1OaTOu8Nos3CalXbJ2DrKnntMv6");
		}

		[ContextMenu("User Manual")]
		protected override void OpenUserManual()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/page11.html");
		}

		[ContextMenu("Scrpt Reference")]
		protected override void OpenScriptReference()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/class_root_motion_1_1_final_i_k_1_1_grounder_f_b_b_i_k.html");
		}

		public override void ResetPosition()
		{
			solver.Reset();
			spineOffset = Vector3.zero;
		}

		private bool IsReadyToInitiate()
		{
			if (ik == null)
			{
				return false;
			}
			if (!ik.solver.initiated)
			{
				return false;
			}
			return true;
		}

		private void Update()
		{
			firstSolve = true;
			weight = Mathf.Clamp(weight, 0f, 1f);
			if (!(weight <= 0f) && !initiated && IsReadyToInitiate())
			{
				Initiate();
			}
		}

		private void FixedUpdate()
		{
			firstSolve = true;
		}

		private void LateUpdate()
		{
			firstSolve = true;
		}

		private void Initiate()
		{
			ik.solver.leftLegMapping.maintainRotationWeight = 1f;
			ik.solver.rightLegMapping.maintainRotationWeight = 1f;
			feet = new Transform[2];
			feet[0] = ik.solver.leftFootEffector.bone;
			feet[1] = ik.solver.rightFootEffector.bone;
			IKSolverFullBodyBiped iKSolverFullBodyBiped = ik.solver;
			iKSolverFullBodyBiped.OnPreUpdate = (IKSolver.UpdateDelegate)Delegate.Combine(iKSolverFullBodyBiped.OnPreUpdate, new IKSolver.UpdateDelegate(OnSolverUpdate));
			solver.Initiate(ik.references.root, feet);
			initiated = true;
		}

		private void OnSolverUpdate()
		{
			if (!firstSolve)
			{
				return;
			}
			firstSolve = false;
			if (!base.enabled || weight <= 0f)
			{
				return;
			}
			if (OnPreGrounder != null)
			{
				OnPreGrounder();
			}
			solver.Update();
			ik.references.pelvis.position += solver.pelvis.IKOffset * weight;
			SetLegIK(ik.solver.leftFootEffector, solver.legs[0]);
			SetLegIK(ik.solver.rightFootEffector, solver.legs[1]);
			if (spineBend != 0f)
			{
				spineSpeed = Mathf.Clamp(spineSpeed, 0f, spineSpeed);
				Vector3 vector = GetSpineOffsetTarget() * weight;
				spineOffset = Vector3.Lerp(spineOffset, vector * spineBend, Time.deltaTime * spineSpeed);
				Vector3 vector2 = ik.references.root.up * spineOffset.magnitude;
				for (int i = 0; i < spine.Length; i++)
				{
					ik.solver.GetEffector(spine[i].effectorType).positionOffset += spineOffset * spine[i].horizontalWeight + vector2 * spine[i].verticalWeight;
				}
			}
			if (OnPostGrounder != null)
			{
				OnPostGrounder();
			}
		}

		private void SetLegIK(IKEffector effector, Grounding.Leg leg)
		{
			effector.positionOffset += (leg.IKPosition - effector.bone.position) * weight;
			effector.bone.rotation = Quaternion.Slerp(Quaternion.identity, leg.rotationOffset, weight) * effector.bone.rotation;
		}

		private void OnDrawGizmosSelected()
		{
			if (ik == null)
			{
				ik = GetComponent<FullBodyBipedIK>();
			}
			if (ik == null)
			{
				ik = GetComponentInParent<FullBodyBipedIK>();
			}
			if (ik == null)
			{
				ik = GetComponentInChildren<FullBodyBipedIK>();
			}
		}

		private void OnDestroy()
		{
			if (initiated && ik != null)
			{
				IKSolverFullBodyBiped iKSolverFullBodyBiped = ik.solver;
				iKSolverFullBodyBiped.OnPreUpdate = (IKSolver.UpdateDelegate)Delegate.Remove(iKSolverFullBodyBiped.OnPreUpdate, new IKSolver.UpdateDelegate(OnSolverUpdate));
			}
		}
	}
	[HelpURL("http://www.root-motion.com/finalikdox/html/page11.html")]
	[AddComponentMenu("Scripts/RootMotion.FinalIK/Grounder/Grounder IK")]
	public class GrounderIK : Grounder
	{
		public IK[] legs;

		[Tooltip("The pelvis transform. Common ancestor of all the legs.")]
		public Transform pelvis;

		[Tooltip("The root Transform of the character, with the rigidbody and the collider.")]
		public Transform characterRoot;

		[Tooltip("The weight of rotating the character root to the ground normal (range: 0 - 1).")]
		[Range(0f, 1f)]
		public float rootRotationWeight;

		[Tooltip("The speed of rotating the character root to the ground normal (range: 0 - inf).")]
		public float rootRotationSpeed = 5f;

		[Tooltip("The maximum angle of root rotation (range: 0 - 90).")]
		public float maxRootRotationAngle = 45f;

		private Transform[] feet = new Transform[0];

		private Quaternion[] footRotations = new Quaternion[0];

		private Vector3 animatedPelvisLocalPosition;

		private Vector3 solvedPelvisLocalPosition;

		private int solvedFeet;

		private bool solved;

		private float lastWeight;

		[ContextMenu("User Manual")]
		protected override void OpenUserManual()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/page11.html");
		}

		[ContextMenu("Scrpt Reference")]
		protected override void OpenScriptReference()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/class_root_motion_1_1_final_i_k_1_1_grounder_i_k.html");
		}

		public override void ResetPosition()
		{
			solver.Reset();
		}

		private bool IsReadyToInitiate()
		{
			if (pelvis == null)
			{
				return false;
			}
			if (legs.Length == 0)
			{
				return false;
			}
			IK[] array = legs;
			foreach (IK iK in array)
			{
				if (iK == null)
				{
					return false;
				}
				if (iK is FullBodyBipedIK)
				{
					LogWarning("GrounderIK does not support FullBodyBipedIK, use CCDIK, FABRIK, LimbIK or TrigonometricIK instead. If you want to use FullBodyBipedIK, use the GrounderFBBIK component.");
					return false;
				}
				if (iK is FABRIKRoot)
				{
					LogWarning("GrounderIK does not support FABRIKRoot, use CCDIK, FABRIK, LimbIK or TrigonometricIK instead.");
					return false;
				}
				if (iK is AimIK)
				{
					LogWarning("GrounderIK does not support AimIK, use CCDIK, FABRIK, LimbIK or TrigonometricIK instead.");
					return false;
				}
			}
			return true;
		}

		private void OnDisable()
		{
			if (!initiated)
			{
				return;
			}
			for (int i = 0; i < legs.Length; i++)
			{
				if (legs[i] != null)
				{
					legs[i].GetIKSolver().IKPositionWeight = 0f;
				}
			}
		}

		private void Update()
		{
			weight = Mathf.Clamp(weight, 0f, 1f);
			if (weight <= 0f)
			{
				return;
			}
			solved = false;
			if (initiated)
			{
				rootRotationWeight = Mathf.Clamp(rootRotationWeight, 0f, 1f);
				rootRotationSpeed = Mathf.Clamp(rootRotationSpeed, 0f, rootRotationSpeed);
				if (characterRoot != null && rootRotationSpeed > 0f && rootRotationWeight > 0f)
				{
					Vector3 vector = solver.GetLegsPlaneNormal();
					if (rootRotationWeight < 1f)
					{
						vector = Vector3.Slerp(Vector3.up, vector, rootRotationWeight);
					}
					Quaternion b = Quaternion.RotateTowards(Quaternion.FromToRotation(base.transform.up, Vector3.up) * characterRoot.rotation, Quaternion.FromToRotation(base.transform.up, vector) * characterRoot.rotation, maxRootRotationAngle);
					characterRoot.rotation = Quaternion.Lerp(characterRoot.rotation, b, Time.deltaTime * rootRotationSpeed);
				}
			}
			else if (IsReadyToInitiate())
			{
				Initiate();
			}
		}

		private void Initiate()
		{
			feet = new Transform[legs.Length];
			footRotations = new Quaternion[legs.Length];
			for (int i = 0; i < feet.Length; i++)
			{
				footRotations[i] = Quaternion.identity;
			}
			for (int j = 0; j < legs.Length; j++)
			{
				IKSolver.Point[] points = legs[j].GetIKSolver().GetPoints();
				feet[j] = points[points.Length - 1].transform;
				IKSolver iKSolver = legs[j].GetIKSolver();
				iKSolver.OnPreUpdate = (IKSolver.UpdateDelegate)Delegate.Combine(iKSolver.OnPreUpdate, new IKSolver.UpdateDelegate(OnSolverUpdate));
				IKSolver iKSolver2 = legs[j].GetIKSolver();
				iKSolver2.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Combine(iKSolver2.OnPostUpdate, new IKSolver.UpdateDelegate(OnPostSolverUpdate));
			}
			animatedPelvisLocalPosition = pelvis.localPosition;
			solver.Initiate(base.transform, feet);
			for (int k = 0; k < legs.Length; k++)
			{
				if (legs[k] is LegIK)
				{
					solver.legs[k].invertFootCenter = true;
				}
			}
			initiated = true;
		}

		private void OnSolverUpdate()
		{
			if (!base.enabled)
			{
				return;
			}
			if (weight <= 0f)
			{
				if (lastWeight <= 0f)
				{
					return;
				}
				OnDisable();
			}
			lastWeight = weight;
			if (!solved)
			{
				if (OnPreGrounder != null)
				{
					OnPreGrounder();
				}
				if (pelvis.localPosition != solvedPelvisLocalPosition)
				{
					animatedPelvisLocalPosition = pelvis.localPosition;
				}
				else
				{
					pelvis.localPosition = animatedPelvisLocalPosition;
				}
				solver.Update();
				for (int i = 0; i < legs.Length; i++)
				{
					SetLegIK(i);
				}
				pelvis.position += solver.pelvis.IKOffset * weight;
				solved = true;
				solvedFeet = 0;
				if (OnPostGrounder != null)
				{
					OnPostGrounder();
				}
			}
		}

		private void SetLegIK(int index)
		{
			footRotations[index] = feet[index].rotation;
			if (legs[index] is LegIK)
			{
				(legs[index].GetIKSolver() as IKSolverLeg).IKRotation = Quaternion.Slerp(Quaternion.identity, solver.legs[index].rotationOffset, weight) * footRotations[index];
				(legs[index].GetIKSolver() as IKSolverLeg).IKRotationWeight = 1f;
			}
			legs[index].GetIKSolver().IKPosition = solver.legs[index].IKPosition;
			legs[index].GetIKSolver().IKPositionWeight = weight;
		}

		private void OnPostSolverUpdate()
		{
			if (weight <= 0f || !base.enabled)
			{
				return;
			}
			solvedFeet++;
			if (solvedFeet >= feet.Length)
			{
				for (int i = 0; i < feet.Length; i++)
				{
					feet[i].rotation = Quaternion.Slerp(Quaternion.identity, solver.legs[i].rotationOffset, weight) * footRotations[i];
				}
				solvedPelvisLocalPosition = pelvis.localPosition;
			}
		}

		private void OnDestroy()
		{
			if (!initiated)
			{
				return;
			}
			IK[] array = legs;
			foreach (IK iK in array)
			{
				if (iK != null)
				{
					IKSolver iKSolver = iK.GetIKSolver();
					iKSolver.OnPreUpdate = (IKSolver.UpdateDelegate)Delegate.Remove(iKSolver.OnPreUpdate, new IKSolver.UpdateDelegate(OnSolverUpdate));
					IKSolver iKSolver2 = iK.GetIKSolver();
					iKSolver2.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Remove(iKSolver2.OnPostUpdate, new IKSolver.UpdateDelegate(OnPostSolverUpdate));
				}
			}
		}
	}
	[HelpURL("http://www.root-motion.com/finalikdox/html/page11.html")]
	[AddComponentMenu("Scripts/RootMotion.FinalIK/Grounder/Grounder Quadruped")]
	public class GrounderQuadruped : Grounder
	{
		public struct Foot
		{
			public IKSolver solver;

			public Transform transform;

			public Quaternion rotation;

			public Grounding.Leg leg;

			public Foot(IKSolver solver, Transform transform)
			{
				this.solver = solver;
				this.transform = transform;
				leg = null;
				rotation = transform.rotation;
			}
		}

		[Tooltip("The Grounding solver for the forelegs.")]
		public Grounding forelegSolver = new Grounding();

		[Tooltip("The weight of rotating the character root to the ground angle (range: 0 - 1).")]
		[Range(0f, 1f)]
		public float rootRotationWeight = 0.5f;

		[Tooltip("The maximum angle of rotating the quadruped downwards (going downhill, range: -90 - 0).")]
		[Range(-90f, 0f)]
		public float minRootRotation = -25f;

		[Tooltip("The maximum angle of rotating the quadruped upwards (going uphill, range: 0 - 90).")]
		[Range(0f, 90f)]
		public float maxRootRotation = 45f;

		[Tooltip("The speed of interpolating the character root rotation (range: 0 - inf).")]
		public float rootRotationSpeed = 5f;

		[Tooltip("The maximum IK offset for the legs (range: 0 - inf).")]
		public float maxLegOffset = 0.5f;

		[Tooltip("The maximum IK offset for the forelegs (range: 0 - inf).")]
		public float maxForeLegOffset = 0.5f;

		[Tooltip("The weight of maintaining the head's rotation as it was before solving the Grounding (range: 0 - 1).")]
		[Range(0f, 1f)]
		public float maintainHeadRotationWeight = 0.5f;

		[Tooltip("The root Transform of the character, with the rigidbody and the collider.")]
		public Transform characterRoot;

		[Tooltip("The pelvis transform. Common ancestor of both legs and the spine.")]
		public Transform pelvis;

		[Tooltip("The last bone in the spine that is the common parent for both forelegs.")]
		public Transform lastSpineBone;

		[Tooltip("The head (optional, if you intend to maintain it's rotation).")]
		public Transform head;

		public IK[] legs;

		public IK[] forelegs;

		[HideInInspector]
		public Vector3 gravity = Vector3.down;

		private Foot[] feet = new Foot[0];

		private Vector3 animatedPelvisLocalPosition;

		private Quaternion animatedPelvisLocalRotation;

		private Quaternion animatedHeadLocalRotation;

		private Vector3 solvedPelvisLocalPosition;

		private Quaternion solvedPelvisLocalRotation;

		private Quaternion solvedHeadLocalRotation;

		private int solvedFeet;

		private bool solved;

		private float angle;

		private Transform forefeetRoot;

		private Quaternion headRotation;

		private float lastWeight;

		[ContextMenu("User Manual")]
		protected override void OpenUserManual()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/page11.html");
		}

		[ContextMenu("Scrpt Reference")]
		protected override void OpenScriptReference()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/class_root_motion_1_1_final_i_k_1_1_grounder_quadruped.html");
		}

		public override void ResetPosition()
		{
			solver.Reset();
			forelegSolver.Reset();
		}

		private bool IsReadyToInitiate()
		{
			if (pelvis == null)
			{
				return false;
			}
			if (lastSpineBone == null)
			{
				return false;
			}
			if (legs.Length == 0)
			{
				return false;
			}
			if (forelegs.Length == 0)
			{
				return false;
			}
			if (characterRoot == null)
			{
				return false;
			}
			if (!IsReadyToInitiateLegs(legs))
			{
				return false;
			}
			if (!IsReadyToInitiateLegs(forelegs))
			{
				return false;
			}
			return true;
		}

		private bool IsReadyToInitiateLegs(IK[] ikComponents)
		{
			foreach (IK iK in ikComponents)
			{
				if (iK == null)
				{
					return false;
				}
				if (iK is FullBodyBipedIK)
				{
					LogWarning("GrounderIK does not support FullBodyBipedIK, use CCDIK, FABRIK, LimbIK or TrigonometricIK instead. If you want to use FullBodyBipedIK, use the GrounderFBBIK component.");
					return false;
				}
				if (iK is FABRIKRoot)
				{
					LogWarning("GrounderIK does not support FABRIKRoot, use CCDIK, FABRIK, LimbIK or TrigonometricIK instead.");
					return false;
				}
				if (iK is AimIK)
				{
					LogWarning("GrounderIK does not support AimIK, use CCDIK, FABRIK, LimbIK or TrigonometricIK instead.");
					return false;
				}
			}
			return true;
		}

		private void OnDisable()
		{
			if (!initiated)
			{
				return;
			}
			for (int i = 0; i < feet.Length; i++)
			{
				if (feet[i].solver != null)
				{
					feet[i].solver.IKPositionWeight = 0f;
				}
			}
		}

		private void Update()
		{
			weight = Mathf.Clamp(weight, 0f, 1f);
			if (!(weight <= 0f))
			{
				solved = false;
				if (!initiated && IsReadyToInitiate())
				{
					Initiate();
				}
			}
		}

		private void Initiate()
		{
			feet = new Foot[legs.Length + forelegs.Length];
			Transform[] array = InitiateFeet(legs, ref feet, 0);
			Transform[] array2 = InitiateFeet(forelegs, ref feet, legs.Length);
			animatedPelvisLocalPosition = pelvis.localPosition;
			animatedPelvisLocalRotation = pelvis.localRotation;
			if (head != null)
			{
				animatedHeadLocalRotation = head.localRotation;
			}
			forefeetRoot = new GameObject().transform;
			forefeetRoot.parent = base.transform;
			forefeetRoot.name = "Forefeet Root";
			solver.Initiate(base.transform, array);
			forelegSolver.Initiate(forefeetRoot, array2);
			for (int i = 0; i < array.Length; i++)
			{
				feet[i].leg = solver.legs[i];
			}
			for (int j = 0; j < array2.Length; j++)
			{
				feet[j + legs.Length].leg = forelegSolver.legs[j];
			}
			initiated = true;
		}

		private Transform[] InitiateFeet(IK[] ikComponents, ref Foot[] f, int indexOffset)
		{
			Transform[] array = new Transform[ikComponents.Length];
			for (int i = 0; i < ikComponents.Length; i++)
			{
				IKSolver.Point[] points = ikComponents[i].GetIKSolver().GetPoints();
				f[i + indexOffset] = new Foot(ikComponents[i].GetIKSolver(), points[points.Length - 1].transform);
				array[i] = f[i + indexOffset].transform;
				IKSolver iKSolver = f[i + indexOffset].solver;
				iKSolver.OnPreUpdate = (IKSolver.UpdateDelegate)Delegate.Combine(iKSolver.OnPreUpdate, new IKSolver.UpdateDelegate(OnSolverUpdate));
				IKSolver iKSolver2 = f[i + indexOffset].solver;
				iKSolver2.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Combine(iKSolver2.OnPostUpdate, new IKSolver.UpdateDelegate(OnPostSolverUpdate));
			}
			return array;
		}

		private void LateUpdate()
		{
			if (!(weight <= 0f))
			{
				rootRotationWeight = Mathf.Clamp(rootRotationWeight, 0f, 1f);
				minRootRotation = Mathf.Clamp(minRootRotation, -90f, maxRootRotation);
				maxRootRotation = Mathf.Clamp(maxRootRotation, minRootRotation, 90f);
				rootRotationSpeed = Mathf.Clamp(rootRotationSpeed, 0f, rootRotationSpeed);
				maxLegOffset = Mathf.Clamp(maxLegOffset, 0f, maxLegOffset);
				maxForeLegOffset = Mathf.Clamp(maxForeLegOffset, 0f, maxForeLegOffset);
				maintainHeadRotationWeight = Mathf.Clamp(maintainHeadRotationWeight, 0f, 1f);
				RootRotation();
			}
		}

		private void RootRotation()
		{
			if (!(rootRotationWeight <= 0f) && !(rootRotationSpeed <= 0f))
			{
				solver.rotateSolver = true;
				forelegSolver.rotateSolver = true;
				Vector3 tangent = characterRoot.forward;
				Vector3 normal = -gravity;
				Vector3.OrthoNormalize(ref normal, ref tangent);
				Quaternion quaternion = Quaternion.LookRotation(tangent, -gravity);
				Vector3 vector = forelegSolver.rootHit.point - solver.rootHit.point;
				Vector3 vector2 = Quaternion.Inverse(quaternion) * vector;
				float num = Mathf.Atan2(vector2.y, vector2.z) * 57.29578f;
				num = Mathf.Clamp(num * rootRotationWeight, minRootRotation, maxRootRotation);
				angle = Mathf.Lerp(angle, num, Time.deltaTime * rootRotationSpeed);
				characterRoot.rotation = Quaternion.Slerp(characterRoot.rotation, Quaternion.AngleAxis(0f - angle, characterRoot.right) * quaternion, weight);
			}
		}

		private void OnSolverUpdate()
		{
			if (!base.enabled)
			{
				return;
			}
			if (weight <= 0f)
			{
				if (lastWeight <= 0f)
				{
					return;
				}
				OnDisable();
			}
			lastWeight = weight;
			if (solved)
			{
				return;
			}
			if (OnPreGrounder != null)
			{
				OnPreGrounder();
			}
			if (pelvis.localPosition != solvedPelvisLocalPosition)
			{
				animatedPelvisLocalPosition = pelvis.localPosition;
			}
			else
			{
				pelvis.localPosition = animatedPelvisLocalPosition;
			}
			if (pelvis.localRotation != solvedPelvisLocalRotation)
			{
				animatedPelvisLocalRotation = pelvis.localRotation;
			}
			else
			{
				pelvis.localRotation = animatedPelvisLocalRotation;
			}
			if (head != null)
			{
				if (head.localRotation != solvedHeadLocalRotation)
				{
					animatedHeadLocalRotation = head.localRotation;
				}
				else
				{
					head.localRotation = animatedHeadLocalRotation;
				}
			}
			for (int i = 0; i < feet.Length; i++)
			{
				feet[i].rotation = feet[i].transform.rotation;
			}
			if (head != null)
			{
				headRotation = head.rotation;
			}
			UpdateForefeetRoot();
			solver.Update();
			forelegSolver.Update();
			pelvis.position += solver.pelvis.IKOffset * weight;
			Vector3 fromDirection = lastSpineBone.position - pelvis.position;
			Vector3 toDirection = lastSpineBone.position + forelegSolver.root.up * Mathf.Clamp(forelegSolver.pelvis.heightOffset, float.NegativeInfinity, 0f) - solver.root.up * solver.pelvis.heightOffset - pelvis.position;
			Quaternion b = Quaternion.FromToRotation(fromDirection, toDirection);
			pelvis.rotation = Quaternion.Slerp(Quaternion.identity, b, weight) * pelvis.rotation;
			for (int j = 0; j < feet.Length; j++)
			{
				SetFootIK(feet[j], (j < 2) ? maxLegOffset : maxForeLegOffset);
			}
			solved = true;
			solvedFeet = 0;
			if (OnPostGrounder != null)
			{
				OnPostGrounder();
			}
		}

		private void UpdateForefeetRoot()
		{
			Vector3 zero = Vector3.zero;
			for (int i = 0; i < forelegSolver.legs.Length; i++)
			{
				zero += forelegSolver.legs[i].transform.position;
			}
			zero /= (float)forelegs.Length;
			Vector3 vector = zero - base.transform.position;
			Vector3 normal = base.transform.up;
			Vector3 tangent = vector;
			Vector3.OrthoNormalize(ref normal, ref tangent);
			forefeetRoot.position = base.transform.position + tangent.normalized * vector.magnitude;
		}

		private void SetFootIK(Foot foot, float maxOffset)
		{
			Vector3 vector = foot.leg.IKPosition - foot.transform.position;
			foot.solver.IKPosition = foot.transform.position + Vector3.ClampMagnitude(vector, maxOffset);
			foot.solver.IKPositionWeight = weight;
		}

		private void OnPostSolverUpdate()
		{
			if (weight <= 0f || !base.enabled)
			{
				return;
			}
			solvedFeet++;
			if (solvedFeet >= feet.Length)
			{
				for (int i = 0; i < feet.Length; i++)
				{
					feet[i].transform.rotation = Quaternion.Slerp(Quaternion.identity, feet[i].leg.rotationOffset, weight) * feet[i].rotation;
				}
				if (head != null)
				{
					head.rotation = Quaternion.Lerp(head.rotation, headRotation, maintainHeadRotationWeight * weight);
				}
				solvedPelvisLocalPosition = pelvis.localPosition;
				solvedPelvisLocalRotation = pelvis.localRotation;
				if (head != null)
				{
					solvedHeadLocalRotation = head.localRotation;
				}
			}
		}

		private void OnDestroy()
		{
			if (initiated)
			{
				DestroyLegs(legs);
				DestroyLegs(forelegs);
			}
		}

		private void DestroyLegs(IK[] ikComponents)
		{
			foreach (IK iK in ikComponents)
			{
				if (iK != null)
				{
					IKSolver iKSolver = iK.GetIKSolver();
					iKSolver.OnPreUpdate = (IKSolver.UpdateDelegate)Delegate.Remove(iKSolver.OnPreUpdate, new IKSolver.UpdateDelegate(OnSolverUpdate));
					IKSolver iKSolver2 = iK.GetIKSolver();
					iKSolver2.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Remove(iKSolver2.OnPostUpdate, new IKSolver.UpdateDelegate(OnPostSolverUpdate));
				}
			}
		}
	}
	[Serializable]
	public class Grounding
	{
		[Serializable]
		public enum Quality
		{
			Fastest,
			Simple,
			Best
		}

		public class Leg
		{
			public Quaternion rotationOffset = Quaternion.identity;

			public bool invertFootCenter;

			private Grounding grounding;

			private float lastTime;

			private float deltaTime;

			private Vector3 lastPosition;

			private Quaternion toHitNormal;

			private Quaternion r;

			private RaycastHit heelHit;

			private Vector3 up = Vector3.up;

			public bool isGrounded { get; private set; }

			public Vector3 IKPosition { get; private set; }

			public bool initiated { get; private set; }

			public float heightFromGround { get; private set; }

			public Vector3 velocity { get; private set; }

			public Transform transform { get; private set; }

			public float IKOffset { get; private set; }

			public float stepHeightFromGround => Mathf.Clamp(heightFromGround, 0f - grounding.maxStep, grounding.maxStep);

			private float rootYOffset => grounding.GetVerticalOffset(transform.position, grounding.root.position - up * grounding.heightOffset);

			public void Initiate(Grounding grounding, Transform transform)
			{
				initiated = false;
				this.grounding = grounding;
				this.transform = transform;
				up = Vector3.up;
				IKPosition = transform.position;
				rotationOffset = Quaternion.identity;
				initiated = true;
				OnEnable();
			}

			public void OnEnable()
			{
				if (initiated)
				{
					lastPosition = transform.position;
					lastTime = Time.deltaTime;
				}
			}

			public void Reset()
			{
				lastPosition = transform.position;
				lastTime = Time.deltaTime;
				IKOffset = 0f;
				IKPosition = transform.position;
				rotationOffset = Quaternion.identity;
			}

			public void Process()
			{
				if (!initiated || grounding.maxStep <= 0f)
				{
					return;
				}
				deltaTime = Time.time - lastTime;
				lastTime = Time.time;
				if (deltaTime == 0f)
				{
					return;
				}
				up = grounding.up;
				heightFromGround = float.PositiveInfinity;
				velocity = (transform.position - lastPosition) / deltaTime;
				velocity = grounding.Flatten(velocity);
				lastPosition = transform.position;
				Vector3 vector = velocity * grounding.prediction;
				if (grounding.footRadius <= 0f)
				{
					grounding.quality = Quality.Fastest;
				}
				switch (grounding.quality)
				{
				case Quality.Fastest:
				{
					RaycastHit raycastHit3 = GetRaycastHit(vector);
					SetFootToPoint(raycastHit3.normal, raycastHit3.point);
					break;
				}
				case Quality.Simple:
				{
					heelHit = GetRaycastHit(Vector3.zero);
					Vector3 vector2 = grounding.GetFootCenterOffset();
					if (invertFootCenter)
					{
						vector2 = -vector2;
					}
					RaycastHit raycastHit = GetRaycastHit(vector2 + vector);
					RaycastHit raycastHit2 = GetRaycastHit(grounding.root.right * grounding.footRadius * 0.5f);
					Vector3 vector3 = Vector3.Cross(raycastHit.point - heelHit.point, raycastHit2.point - heelHit.point).normalized;
					if (Vector3.Dot(vector3, up) < 0f)
					{
						vector3 = -vector3;
					}
					SetFootToPlane(vector3, heelHit.point, heelHit.point);
					break;
				}
				case Quality.Best:
				{
					heelHit = GetRaycastHit(invertFootCenter ? (-grounding.GetFootCenterOffset()) : Vector3.zero);
					RaycastHit capsuleHit = GetCapsuleHit(vector);
					SetFootToPlane(capsuleHit.normal, capsuleHit.point, heelHit.point);
					break;
				}
				}
				isGrounded = heightFromGround < grounding.maxStep;
				float num = stepHeightFromGround;
				if (!grounding.rootGrounded)
				{
					num = 0f;
				}
				IKOffset = Interp.LerpValue(IKOffset, num, grounding.footSpeed, grounding.footSpeed);
				IKOffset = Mathf.Lerp(IKOffset, num, deltaTime * grounding.footSpeed);
				float verticalOffset = grounding.GetVerticalOffset(transform.position, grounding.root.position);
				float num2 = Mathf.Clamp(grounding.maxStep - verticalOffset, 0f, grounding.maxStep);
				IKOffset = Mathf.Clamp(IKOffset, 0f - num2, IKOffset);
				RotateFoot();
				IKPosition = transform.position - up * IKOffset;
				float footRotationWeight = grounding.footRotationWeight;
				rotationOffset = ((footRotationWeight >= 1f) ? r : Quaternion.Slerp(Quaternion.identity, r, footRotationWeight));
			}

			private RaycastHit GetCapsuleHit(Vector3 offsetFromHeel)
			{
				RaycastHit hitInfo = default(RaycastHit);
				Vector3 vector = grounding.GetFootCenterOffset();
				if (invertFootCenter)
				{
					vector = -vector;
				}
				Vector3 vector2 = transform.position + vector;
				hitInfo.point = vector2 - up * grounding.maxStep * 2f;
				hitInfo.normal = up;
				Vector3 vector3 = vector2 + grounding.maxStep * up;
				Vector3 point = vector3 + offsetFromHeel;
				if (Physics.CapsuleCast(vector3, point, grounding.footRadius, -up, out hitInfo, grounding.maxStep * 3f, grounding.layers) && float.IsNaN(hitInfo.point.x))
				{
					hitInfo.point = vector2 - up * grounding.maxStep * 2f;
					hitInfo.normal = up;
				}
				return hitInfo;
			}

			private RaycastHit GetRaycastHit(Vector3 offsetFromHeel)
			{
				RaycastHit hitInfo = default(RaycastHit);
				Vector3 vector = transform.position + offsetFromHeel;
				hitInfo.point = vector - up * grounding.maxStep * 2f;
				hitInfo.normal = up;
				if (grounding.maxStep <= 0f)
				{
					return hitInfo;
				}
				Physics.Raycast(vector + grounding.maxStep * up, -up, out hitInfo, grounding.maxStep * 3f, grounding.layers);
				return hitInfo;
			}

			private Vector3 RotateNormal(Vector3 normal)
			{
				if (grounding.quality == Quality.Best)
				{
					return normal;
				}
				return Vector3.RotateTowards(up, normal, grounding.maxFootRotationAngle * ((float)Math.PI / 180f), deltaTime);
			}

			private void SetFootToPoint(Vector3 normal, Vector3 point)
			{
				toHitNormal = Quaternion.FromToRotation(up, RotateNormal(normal));
				heightFromGround = GetHeightFromGround(point);
			}

			private void SetFootToPlane(Vector3 planeNormal, Vector3 planePoint, Vector3 heelHitPoint)
			{
				planeNormal = RotateNormal(planeNormal);
				toHitNormal = Quaternion.FromToRotation(up, planeNormal);
				Vector3 hitPoint = V3Tools.LineToPlane(transform.position + up * grounding.maxStep, -up, planeNormal, planePoint);
				heightFromGround = GetHeightFromGround(hitPoint);
				float max = GetHeightFromGround(heelHitPoint);
				heightFromGround = Mathf.Clamp(heightFromGround, float.NegativeInfinity, max);
			}

			private float GetHeightFromGround(Vector3 hitPoint)
			{
				return grounding.GetVerticalOffset(transform.position, hitPoint) - rootYOffset;
			}

			private void RotateFoot()
			{
				Quaternion rotationOffsetTarget = GetRotationOffsetTarget();
				r = Quaternion.Slerp(r, rotationOffsetTarget, deltaTime * grounding.footRotationSpeed);
			}

			private Quaternion GetRotationOffsetTarget()
			{
				if (grounding.maxFootRotationAngle <= 0f)
				{
					return Quaternion.identity;
				}
				if (grounding.maxFootRotationAngle >= 180f)
				{
					return toHitNormal;
				}
				return Quaternion.RotateTowards(Quaternion.identity, toHitNormal, grounding.maxFootRotationAngle);
			}
		}

		public class Pelvis
		{
			private Grounding grounding;

			private Vector3 lastRootPosition;

			private float damperF;

			private bool initiated;

			private float lastTime;

			public Vector3 IKOffset { get; private set; }

			public float heightOffset { get; private set; }

			public void Initiate(Grounding grounding)
			{
				this.grounding = grounding;
				initiated = true;
				OnEnable();
			}

			public void Reset()
			{
				lastRootPosition = grounding.root.transform.position;
				lastTime = Time.deltaTime;
				IKOffset = Vector3.zero;
				heightOffset = 0f;
			}

			public void OnEnable()
			{
				if (initiated)
				{
					lastRootPosition = grounding.root.transform.position;
					lastTime = Time.time;
				}
			}

			public void Process(float lowestOffset, float highestOffset, bool isGrounded)
			{
				if (!initiated)
				{
					return;
				}
				float num = Time.time - lastTime;
				lastTime = Time.time;
				if (!(num <= 0f))
				{
					float b = lowestOffset + highestOffset;
					if (!grounding.rootGrounded)
					{
						b = 0f;
					}
					heightOffset = Mathf.Lerp(heightOffset, b, num * grounding.pelvisSpeed);
					Vector3 p = grounding.root.position - lastRootPosition;
					lastRootPosition = grounding.root.position;
					damperF = Interp.LerpValue(damperF, isGrounded ? 1f : 0f, 1f, 10f);
					heightOffset -= grounding.GetVerticalOffset(p, Vector3.zero) * grounding.pelvisDamper * damperF;
					IKOffset = grounding.up * heightOffset;
				}
			}
		}

		[Tooltip("Layers to ground the character to. Make sure to exclude the layer of the character controller.")]
		public LayerMask layers;

		[Tooltip("Max step height. Maximum vertical distance of Grounding from the root of the character.")]
		public float maxStep = 0.5f;

		[Tooltip("The height offset of the root.")]
		public float heightOffset;

		[Tooltip("The speed of moving the feet up/down.")]
		public float footSpeed = 2.5f;

		[Tooltip("CapsuleCast radius. Should match approximately with the size of the feet.")]
		public float footRadius = 0.15f;

		[Tooltip("Offset of the foot center along character forward axis.")]
		[HideInInspector]
		public float footCenterOffset;

		[Tooltip("Amount of velocity based prediction of the foot positions.")]
		public float prediction = 0.05f;

		[Tooltip("Weight of rotating the feet to the ground normal offset.")]
		[Range(0f, 1f)]
		public float footRotationWeight = 1f;

		[Tooltip("Speed of slerping the feet to their grounded rotations.")]
		public float footRotationSpeed = 7f;

		[Tooltip("Max Foot Rotation Angle. Max angular offset from the foot's rotation.")]
		[Range(0f, 90f)]
		public float maxFootRotationAngle = 45f;

		[Tooltip("If true, solver will rotate with the character root so the character can be grounded for example to spherical planets. For performance reasons leave this off unless needed.")]
		public bool rotateSolver;

		[Tooltip("The speed of moving the character up/down.")]
		public float pelvisSpeed = 5f;

		[Tooltip("Used for smoothing out vertical pelvis movement (range 0 - 1).")]
		[Range(0f, 1f)]
		public float pelvisDamper;

		[Tooltip("The weight of lowering the pelvis to the lowest foot.")]
		public float lowerPelvisWeight = 1f;

		[Tooltip("The weight of lifting the pelvis to the highest foot. This is useful when you don't want the feet to go too high relative to the body when crouching.")]
		public float liftPelvisWeight;

		[Tooltip("The radius of the spherecast from the root that determines whether the character root is grounded.")]
		public float rootSphereCastRadius = 0.1f;

		[Tooltip("The raycasting quality. Fastest is a single raycast per foot, Simple is three raycasts, Best is one raycast and a capsule cast per foot.")]
		public Quality quality = Quality.Best;

		private bool initiated;

		public Leg[] legs { get; private set; }

		public Pelvis pelvis { get; private set; }

		public bool isGrounded { get; private set; }

		public Transform root { get; private set; }

		public RaycastHit rootHit { get; private set; }

		public bool rootGrounded => rootHit.distance < maxStep * 2f;

		public Vector3 up
		{
			get
			{
				if (!useRootRotation)
				{
					return Vector3.up;
				}
				return root.up;
			}
		}

		private bool useRootRotation
		{
			get
			{
				if (!rotateSolver)
				{
					return false;
				}
				if (root.up == Vector3.up)
				{
					return false;
				}
				return true;
			}
		}

		public RaycastHit GetRootHit(float maxDistanceMlp = 10f)
		{
			RaycastHit hitInfo = default(RaycastHit);
			Vector3 vector = up;
			Vector3 zero = Vector3.zero;
			Leg[] array = legs;
			foreach (Leg leg in array)
			{
				zero += leg.transform.position;
			}
			zero /= (float)legs.Length;
			hitInfo.point = zero - vector * maxStep * 10f;
			float num = maxDistanceMlp + 1f;
			hitInfo.distance = maxStep * num;
			if (maxStep <= 0f)
			{
				return hitInfo;
			}
			if (quality != Quality.Best)
			{
				Physics.Raycast(zero + vector * maxStep, -vector, out hitInfo, maxStep * num, layers);
			}
			else
			{
				Physics.SphereCast(zero + vector * maxStep, rootSphereCastRadius, -up, out hitInfo, maxStep * num, layers);
			}
			return hitInfo;
		}

		public bool IsValid(ref string errorMessage)
		{
			if (root == null)
			{
				errorMessage = "Root transform is null. Can't initiate Grounding.";
				return false;
			}
			if (legs == null)
			{
				errorMessage = "Grounding legs is null. Can't initiate Grounding.";
				return false;
			}
			if (pelvis == null)
			{
				errorMessage = "Grounding pelvis is null. Can't initiate Grounding.";
				return false;
			}
			if (legs.Length == 0)
			{
				errorMessage = "Grounding has 0 legs. Can't initiate Grounding.";
				return false;
			}
			return true;
		}

		public void Initiate(Transform root, Transform[] feet)
		{
			this.root = root;
			initiated = false;
			rootHit = default(RaycastHit);
			if (legs == null)
			{
				legs = new Leg[feet.Length];
			}
			if (legs.Length != feet.Length)
			{
				legs = new Leg[feet.Length];
			}
			for (int i = 0; i < feet.Length; i++)
			{
				if (legs[i] == null)
				{
					legs[i] = new Leg();
				}
			}
			if (pelvis == null)
			{
				pelvis = new Pelvis();
			}
			string errorMessage = string.Empty;
			if (!IsValid(ref errorMessage))
			{
				Warning.Log(errorMessage, root);
			}
			else if (Application.isPlaying)
			{
				for (int j = 0; j < feet.Length; j++)
				{
					legs[j].Initiate(this, feet[j]);
				}
				pelvis.Initiate(this);
				initiated = true;
			}
		}

		public void Update()
		{
			if (!initiated)
			{
				return;
			}
			if ((int)layers == 0)
			{
				LogWarning("Grounding layers are set to nothing. Please add a ground layer.");
			}
			maxStep = Mathf.Clamp(maxStep, 0f, maxStep);
			footRadius = Mathf.Clamp(footRadius, 0.0001f, maxStep);
			pelvisDamper = Mathf.Clamp(pelvisDamper, 0f, 1f);
			rootSphereCastRadius = Mathf.Clamp(rootSphereCastRadius, 0.0001f, rootSphereCastRadius);
			maxFootRotationAngle = Mathf.Clamp(maxFootRotationAngle, 0f, 90f);
			prediction = Mathf.Clamp(prediction, 0f, prediction);
			footSpeed = Mathf.Clamp(footSpeed, 0f, footSpeed);
			rootHit = GetRootHit();
			float num = float.NegativeInfinity;
			float num2 = float.PositiveInfinity;
			isGrounded = false;
			Leg[] array = legs;
			foreach (Leg leg in array)
			{
				leg.Process();
				if (leg.IKOffset > num)
				{
					num = leg.IKOffset;
				}
				if (leg.IKOffset < num2)
				{
					num2 = leg.IKOffset;
				}
				if (leg.isGrounded)
				{
					isGrounded = true;
				}
			}
			pelvis.Process((0f - num) * lowerPelvisWeight, (0f - num2) * liftPelvisWeight, isGrounded);
		}

		public Vector3 GetLegsPlaneNormal()
		{
			if (!initiated)
			{
				return Vector3.up;
			}
			Vector3 vector = up;
			Vector3 vector2 = vector;
			for (int i = 0; i < legs.Length; i++)
			{
				Vector3 vector3 = legs[i].IKPosition - root.position;
				Vector3 normal = vector;
				Vector3 tangent = vector3;
				Vector3.OrthoNormalize(ref normal, ref tangent);
				vector2 = Quaternion.FromToRotation(tangent, vector3) * vector2;
			}
			return vector2;
		}

		public void Reset()
		{
			if (Application.isPlaying)
			{
				pelvis.Reset();
				Leg[] array = legs;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].Reset();
				}
			}
		}

		public void LogWarning(string message)
		{
			Warning.Log(message, root);
		}

		public float GetVerticalOffset(Vector3 p1, Vector3 p2)
		{
			if (useRootRotation)
			{
				return (Quaternion.Inverse(root.rotation) * (p1 - p2)).y;
			}
			return p1.y - p2.y;
		}

		public Vector3 Flatten(Vector3 v)
		{
			if (useRootRotation)
			{
				Vector3 tangent = v;
				Vector3 normal = root.up;
				Vector3.OrthoNormalize(ref normal, ref tangent);
				return Vector3.Project(v, tangent);
			}
			v.y = 0f;
			return v;
		}

		public Vector3 GetFootCenterOffset()
		{
			return root.forward * footRadius + root.forward * footCenterOffset;
		}
	}
	[HelpURL("https://www.youtube.com/watch?v=wT8fViZpLmQ&index=3&list=PLVxSIA1OaTOu8Nos3CalXbJ2DrKnntMv6")]
	[AddComponentMenu("Scripts/RootMotion.FinalIK/IK/Aim IK")]
	public class AimIK : IK
	{
		public IKSolverAim solver = new IKSolverAim();

		[ContextMenu("User Manual")]
		protected override void OpenUserManual()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/page1.html");
		}

		[ContextMenu("Scrpt Reference")]
		protected override void OpenScriptReference()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/class_root_motion_1_1_final_i_k_1_1_aim_i_k.html");
		}

		[ContextMenu("TUTORIAL VIDEO")]
		private void OpenSetupTutorial()
		{
			Application.OpenURL("https://www.youtube.com/watch?v=wT8fViZpLmQ");
		}

		[ContextMenu("Support Group")]
		private void SupportGroup()
		{
			Application.OpenURL("https://groups.google.com/forum/#!forum/final-ik");
		}

		[ContextMenu("Asset Store Thread")]
		private void ASThread()
		{
			Application.OpenURL("http://forum.unity3d.com/threads/final-ik-full-body-ik-aim-look-at-fabrik-ccd-ik-1-0-released.222685/");
		}

		public override IKSolver GetIKSolver()
		{
			return solver;
		}
	}
	[HelpURL("http://www.root-motion.com/finalikdox/html/page3.html")]
	[AddComponentMenu("Scripts/RootMotion.FinalIK/IK/CCD IK")]
	public class CCDIK : IK
	{
		public IKSolverCCD solver = new IKSolverCCD();

		[ContextMenu("User Manual")]
		protected override void OpenUserManual()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/page3.html");
		}

		[ContextMenu("Scrpt Reference")]
		protected override void OpenScriptReference()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/class_root_motion_1_1_final_i_k_1_1_c_c_d_i_k.html");
		}

		[ContextMenu("Support Group")]
		private void SupportGroup()
		{
			Application.OpenURL("https://groups.google.com/forum/#!forum/final-ik");
		}

		[ContextMenu("Asset Store Thread")]
		private void ASThread()
		{
			Application.OpenURL("http://forum.unity3d.com/threads/final-ik-full-body-ik-aim-look-at-fabrik-ccd-ik-1-0-released.222685/");
		}

		public override IKSolver GetIKSolver()
		{
			return solver;
		}
	}
	[HelpURL("http://www.root-motion.com/finalikdox/html/page4.html")]
	[AddComponentMenu("Scripts/RootMotion.FinalIK/IK/FABRIK")]
	public class FABRIK : IK
	{
		public IKSolverFABRIK solver = new IKSolverFABRIK();

		[ContextMenu("User Manual")]
		protected override void OpenUserManual()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/page4.html");
		}

		[ContextMenu("Scrpt Reference")]
		protected override void OpenScriptReference()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/class_root_motion_1_1_final_i_k_1_1_f_a_b_r_i_k.html");
		}

		[ContextMenu("Support Group")]
		private void SupportGroup()
		{
			Application.OpenURL("https://groups.google.com/forum/#!forum/final-ik");
		}

		[ContextMenu("Asset Store Thread")]
		private void ASThread()
		{
			Application.OpenURL("http://forum.unity3d.com/threads/final-ik-full-body-ik-aim-look-at-fabrik-ccd-ik-1-0-released.222685/");
		}

		public override IKSolver GetIKSolver()
		{
			return solver;
		}
	}
	[HelpURL("http://www.root-motion.com/finalikdox/html/page5.html")]
	[AddComponentMenu("Scripts/RootMotion.FinalIK/IK/FABRIK Root")]
	public class FABRIKRoot : IK
	{
		public IKSolverFABRIKRoot solver = new IKSolverFABRIKRoot();

		[ContextMenu("User Manual")]
		protected override void OpenUserManual()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/page5.html");
		}

		[ContextMenu("Scrpt Reference")]
		protected override void OpenScriptReference()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/class_root_motion_1_1_final_i_k_1_1_f_a_b_r_i_k_root.html");
		}

		[ContextMenu("Support Group")]
		private void SupportGroup()
		{
			Application.OpenURL("https://groups.google.com/forum/#!forum/final-ik");
		}

		[ContextMenu("Asset Store Thread")]
		private void ASThread()
		{
			Application.OpenURL("http://forum.unity3d.com/threads/final-ik-full-body-ik-aim-look-at-fabrik-ccd-ik-1-0-released.222685/");
		}

		public override IKSolver GetIKSolver()
		{
			return solver;
		}
	}
	[HelpURL("https://www.youtube.com/watch?v=7__IafZGwvI&index=1&list=PLVxSIA1OaTOu8Nos3CalXbJ2DrKnntMv6")]
	[AddComponentMenu("Scripts/RootMotion.FinalIK/IK/Full Body Biped IK")]
	public class FullBodyBipedIK : IK
	{
		public BipedReferences references = new BipedReferences();

		public IKSolverFullBodyBiped solver = new IKSolverFullBodyBiped();

		[ContextMenu("User Manual")]
		protected override void OpenUserManual()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/page6.html");
		}

		[ContextMenu("Scrpt Reference")]
		protected override void OpenScriptReference()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/class_root_motion_1_1_final_i_k_1_1_full_body_biped_i_k.html");
		}

		[ContextMenu("TUTORIAL VIDEO (SETUP)")]
		private void OpenSetupTutorial()
		{
			Application.OpenURL("https://www.youtube.com/watch?v=7__IafZGwvI");
		}

		[ContextMenu("TUTORIAL VIDEO (INSPECTOR)")]
		private void OpenInspectorTutorial()
		{
			Application.OpenURL("https://www.youtube.com/watch?v=tgRMsTphjJo");
		}

		[ContextMenu("Support Group")]
		private void SupportGroup()
		{
			Application.OpenURL("https://groups.google.com/forum/#!forum/final-ik");
		}

		[ContextMenu("Asset Store Thread")]
		private void ASThread()
		{
			Application.OpenURL("http://forum.unity3d.com/threads/final-ik-full-body-ik-aim-look-at-fabrik-ccd-ik-1-0-released.222685/");
		}

		public void SetReferences(BipedReferences references, Transform rootNode)
		{
			this.references = references;
			solver.SetToReferences(this.references, rootNode);
		}

		public override IKSolver GetIKSolver()
		{
			return solver;
		}

		public bool ReferencesError(ref string errorMessage)
		{
			if (BipedReferences.SetupError(references, ref errorMessage))
			{
				return true;
			}
			if (references.spine.Length == 0)
			{
				errorMessage = "References has no spine bones assigned, can not initiate the solver.";
				return true;
			}
			if (solver.rootNode == null)
			{
				errorMessage = "Root Node bone is null, can not initiate the solver.";
				return true;
			}
			if (solver.rootNode != references.pelvis)
			{
				bool flag = false;
				for (int i = 0; i < references.spine.Length; i++)
				{
					if (solver.rootNode == references.spine[i])
					{
						flag = true;
						break;
					}
				}
				if (!flag)
				{
					errorMessage = "The Root Node has to be one of the bones in the Spine or the Pelvis, can not initiate the solver.";
					return true;
				}
			}
			return false;
		}

		public bool ReferencesWarning(ref string warningMessage)
		{
			if (BipedReferences.SetupWarning(references, ref warningMessage))
			{
				return true;
			}
			Vector3 vector = references.rightUpperArm.position - references.leftUpperArm.position;
			Vector3 vector2 = solver.rootNode.position - references.leftUpperArm.position;
			if (Vector3.Dot(vector.normalized, vector2.normalized) > 0.95f)
			{
				warningMessage = "The root node, the left upper arm and the right upper arm bones should ideally form a triangle that is as close to equilateral as possible. Currently the root node bone seems to be very close to the line between the left upper arm and the right upper arm bones. This might cause unwanted behaviour like the spine turning upside down when pulled by a hand effector.Please set the root node bone to be one of the lower bones in the spine.";
				return true;
			}
			Vector3 vector3 = references.rightThigh.position - references.leftThigh.position;
			Vector3 vector4 = solver.rootNode.position - references.leftThigh.position;
			if (Vector3.Dot(vector3.normalized, vector4.normalized) > 0.95f)
			{
				warningMessage = "The root node, the left thigh and the right thigh bones should ideally form a triangle that is as close to equilateral as possible. Currently the root node bone seems to be very close to the line between the left thigh and the right thigh bones. This might cause unwanted behaviour like the hip turning upside down when pulled by an effector.Please set the root node bone to be one of the higher bones in the spine.";
				return true;
			}
			return false;
		}

		[ContextMenu("Reinitiate")]
		private void Reinitiate()
		{
			SetReferences(references, solver.rootNode);
		}

		[ContextMenu("Auto-detect References")]
		private void AutoDetectReferences()
		{
			references = new BipedReferences();
			BipedReferences.AutoDetectReferences(ref references, base.transform, new BipedReferences.AutoDetectParams(legsParentInSpine: true, includeEyes: false));
			solver.rootNode = IKSolverFullBodyBiped.DetectRootNodeBone(references);
			solver.SetToReferences(references, solver.rootNode);
		}
	}
	public abstract class IK : SolverManager
	{
		public abstract IKSolver GetIKSolver();

		protected override void UpdateSolver()
		{
			if (!GetIKSolver().initiated)
			{
				InitiateSolver();
			}
			if (GetIKSolver().initiated)
			{
				GetIKSolver().Update();
			}
		}

		protected override void InitiateSolver()
		{
			if (!GetIKSolver().initiated)
			{
				GetIKSolver().Initiate(base.transform);
			}
		}

		protected override void FixTransforms()
		{
			if (GetIKSolver().initiated)
			{
				GetIKSolver().FixTransforms();
			}
		}

		protected abstract void OpenUserManual();

		protected abstract void OpenScriptReference();
	}
	public class IKExecutionOrder : MonoBehaviour
	{
		[Tooltip("The IK components, assign in the order in which you wish to update them.")]
		public IK[] IKComponents;

		[Tooltip("Optional. Assign it if you are using 'Animate Physics' as the Update Mode.")]
		public Animator animator;

		private bool fixedFrame;

		private bool animatePhysics
		{
			get
			{
				if (animator == null)
				{
					return false;
				}
				return animator.updateMode == AnimatorUpdateMode.AnimatePhysics;
			}
		}

		private void Start()
		{
			for (int i = 0; i < IKComponents.Length; i++)
			{
				IKComponents[i].enabled = false;
			}
		}

		private void Update()
		{
			if (!animatePhysics)
			{
				FixTransforms();
			}
		}

		private void FixedUpdate()
		{
			fixedFrame = true;
			if (animatePhysics)
			{
				FixTransforms();
			}
		}

		private void LateUpdate()
		{
			if (!animatePhysics || fixedFrame)
			{
				for (int i = 0; i < IKComponents.Length; i++)
				{
					IKComponents[i].GetIKSolver().Update();
				}
				fixedFrame = false;
			}
		}

		private void FixTransforms()
		{
			for (int i = 0; i < IKComponents.Length; i++)
			{
				if (IKComponents[i].fixTransforms)
				{
					IKComponents[i].GetIKSolver().FixTransforms();
				}
			}
		}
	}
	[AddComponentMenu("Scripts/RootMotion.FinalIK/IK/Leg IK")]
	public class LegIK : IK
	{
		public IKSolverLeg solver = new IKSolverLeg();

		[ContextMenu("User Manual")]
		protected override void OpenUserManual()
		{
			UnityEngine.Debug.Log("No User Manual page for this component yet, sorry.");
		}

		[ContextMenu("Scrpt Reference")]
		protected override void OpenScriptReference()
		{
			UnityEngine.Debug.Log("No Script Reference for this component yet, sorry.");
		}

		[ContextMenu("Support Group")]
		private void SupportGroup()
		{
			Application.OpenURL("https://groups.google.com/forum/#!forum/final-ik");
		}

		[ContextMenu("Asset Store Thread")]
		private void ASThread()
		{
			Application.OpenURL("http://forum.unity3d.com/threads/final-ik-full-body-ik-aim-look-at-fabrik-ccd-ik-1-0-released.222685/");
		}

		public override IKSolver GetIKSolver()
		{
			return solver;
		}
	}
	[HelpURL("http://www.root-motion.com/finalikdox/html/page7.html")]
	[AddComponentMenu("Scripts/RootMotion.FinalIK/IK/Limb IK")]
	public class LimbIK : IK
	{
		public IKSolverLimb solver = new IKSolverLimb();

		[ContextMenu("User Manual")]
		protected override void OpenUserManual()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/page7.html");
		}

		[ContextMenu("Scrpt Reference")]
		protected override void OpenScriptReference()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/class_root_motion_1_1_final_i_k_1_1_limb_i_k.html");
		}

		[ContextMenu("Support Group")]
		private void SupportGroup()
		{
			Application.OpenURL("https://groups.google.com/forum/#!forum/final-ik");
		}

		[ContextMenu("Asset Store Thread")]
		private void ASThread()
		{
			Application.OpenURL("http://forum.unity3d.com/threads/final-ik-full-body-ik-aim-look-at-fabrik-ccd-ik-1-0-released.222685/");
		}

		public override IKSolver GetIKSolver()
		{
			return solver;
		}
	}
	[HelpURL("http://www.root-motion.com/finalikdox/html/page8.html")]
	[AddComponentMenu("Scripts/RootMotion.FinalIK/IK/Look At IK")]
	public class LookAtIK : IK
	{
		public IKSolverLookAt solver = new IKSolverLookAt();

		[ContextMenu("User Manual")]
		protected override void OpenUserManual()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/page8.html");
		}

		[ContextMenu("Scrpt Reference")]
		protected override void OpenScriptReference()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/class_root_motion_1_1_final_i_k_1_1_look_at_i_k.html");
		}

		[ContextMenu("Support Group")]
		private void SupportGroup()
		{
			Application.OpenURL("https://groups.google.com/forum/#!forum/final-ik");
		}

		[ContextMenu("Asset Store Thread")]
		private void ASThread()
		{
			Application.OpenURL("http://forum.unity3d.com/threads/final-ik-full-body-ik-aim-look-at-fabrik-ccd-ik-1-0-released.222685/");
		}

		public override IKSolver GetIKSolver()
		{
			return solver;
		}
	}
	[HelpURL("http://www.root-motion.com/finalikdox/html/page9.html")]
	[AddComponentMenu("Scripts/RootMotion.FinalIK/IK/Trigonometric IK")]
	public class TrigonometricIK : IK
	{
		public IKSolverTrigonometric solver = new IKSolverTrigonometric();

		[ContextMenu("User Manual")]
		protected override void OpenUserManual()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/page9.html");
		}

		[ContextMenu("Scrpt Reference")]
		protected override void OpenScriptReference()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/class_root_motion_1_1_final_i_k_1_1_trigonometric_i_k.html");
		}

		[ContextMenu("Support Group")]
		private void SupportGroup()
		{
			Application.OpenURL("https://groups.google.com/forum/#!forum/final-ik");
		}

		[ContextMenu("Asset Store Thread")]
		private void ASThread()
		{
			Application.OpenURL("http://forum.unity3d.com/threads/final-ik-full-body-ik-aim-look-at-fabrik-ccd-ik-1-0-released.222685/");
		}

		public override IKSolver GetIKSolver()
		{
			return solver;
		}
	}
	[AddComponentMenu("Scripts/RootMotion.FinalIK/IK/VR IK")]
	public class VRIK : IK
	{
		[Serializable]
		public class References
		{
			public Transform root;

			public Transform pelvis;

			public Transform spine;

			public Transform chest;

			public Transform neck;

			public Transform head;

			public Transform leftShoulder;

			public Transform leftUpperArm;

			public Transform leftForearm;

			public Transform leftHand;

			public Transform rightShoulder;

			public Transform rightUpperArm;

			public Transform rightForearm;

			public Transform rightHand;

			public Transform leftThigh;

			public Transform leftCalf;

			public Transform leftFoot;

			public Transform leftToes;

			public Transform rightThigh;

			public Transform rightCalf;

			public Transform rightFoot;

			public Transform rightToes;

			public bool isFilled
			{
				get
				{
					if (root == null || pelvis == null || spine == null || head == null || leftUpperArm == null || leftForearm == null || leftHand == null || rightUpperArm == null || rightForearm == null || rightHand == null || leftThigh == null || leftCalf == null || leftFoot == null || rightThigh == null || rightCalf == null || rightFoot == null)
					{
						return false;
					}
					return true;
				}
			}

			public bool isEmpty
			{
				get
				{
					if (root != null || pelvis != null || spine != null || chest != null || neck != null || head != null || leftShoulder != null || leftUpperArm != null || leftForearm != null || leftHand != null || rightShoulder != null || rightUpperArm != null || rightForearm != null || rightHand != null || leftThigh != null || leftCalf != null || leftFoot != null || leftToes != null || rightThigh != null || rightCalf != null || rightFoot != null || rightToes != null)
					{
						return false;
					}
					return true;
				}
			}

			public Transform[] GetTransforms()
			{
				return new Transform[22]
				{
					root, pelvis, spine, chest, neck, head, leftShoulder, leftUpperArm, leftForearm, leftHand,
					rightShoulder, rightUpperArm, rightForearm, rightHand, leftThigh, leftCalf, leftFoot, leftToes, rightThigh, rightCalf,
					rightFoot, rightToes
				};
			}

			public static bool AutoDetectReferences(Transform root, out References references)
			{
				references = new References();
				Animator componentInChildren = root.GetComponentInChildren<Animator>();
				if (componentInChildren == null || !componentInChildren.isHuman)
				{
					UnityEngine.Debug.LogWarning("VRIK needs a Humanoid Animator to auto-detect biped references. Please assign references manually.");
					return false;
				}
				references.root = root;
				references.pelvis = componentInChildren.GetBoneTransform(HumanBodyBones.Hips);
				references.spine = componentInChildren.GetBoneTransform(HumanBodyBones.Spine);
				references.chest = componentInChildren.GetBoneTransform(HumanBodyBones.Chest);
				references.neck = componentInChildren.GetBoneTransform(HumanBodyBones.Neck);
				references.head = componentInChildren.GetBoneTransform(HumanBodyBones.Head);
				references.leftShoulder = componentInChildren.GetBoneTransform(HumanBodyBones.LeftShoulder);
				references.leftUpperArm = componentInChildren.GetBoneTransform(HumanBodyBones.LeftUpperArm);
				references.leftForearm = componentInChildren.GetBoneTransform(HumanBodyBones.LeftLowerArm);
				references.leftHand = componentInChildren.GetBoneTransform(HumanBodyBones.LeftHand);
				references.rightShoulder = componentInChildren.GetBoneTransform(HumanBodyBones.RightShoulder);
				references.rightUpperArm = componentInChildren.GetBoneTransform(HumanBodyBones.RightUpperArm);
				references.rightForearm = componentInChildren.GetBoneTransform(HumanBodyBones.RightLowerArm);
				references.rightHand = componentInChildren.GetBoneTransform(HumanBodyBones.RightHand);
				references.leftThigh = componentInChildren.GetBoneTransform(HumanBodyBones.LeftUpperLeg);
				references.leftCalf = componentInChildren.GetBoneTransform(HumanBodyBones.LeftLowerLeg);
				references.leftFoot = componentInChildren.GetBoneTransform(HumanBodyBones.LeftFoot);
				references.leftToes = componentInChildren.GetBoneTransform(HumanBodyBones.LeftToes);
				references.rightThigh = componentInChildren.GetBoneTransform(HumanBodyBones.RightUpperLeg);
				references.rightCalf = componentInChildren.GetBoneTransform(HumanBodyBones.RightLowerLeg);
				references.rightFoot = componentInChildren.GetBoneTransform(HumanBodyBones.RightFoot);
				references.rightToes = componentInChildren.GetBoneTransform(HumanBodyBones.RightToes);
				return true;
			}
		}

		[ContextMenuItem("Auto-detect References", "AutoDetectReferences")]
		[Tooltip("Bone mapping. Right-click on the component header and select 'Auto-detect References' of fill in manually if not a Humanoid character.")]
		public References references = new References();

		[Tooltip("The VRIK solver.")]
		public IKSolverVR solver = new IKSolverVR();

		[ContextMenu("User Manual")]
		protected override void OpenUserManual()
		{
			UnityEngine.Debug.Log("Sorry, VRIK User Manual is not finished yet.");
		}

		[ContextMenu("Scrpt Reference")]
		protected override void OpenScriptReference()
		{
			UnityEngine.Debug.Log("Sorry, VRIK Script reference is not finished yet.");
		}

		[ContextMenu("TUTORIAL VIDEO (STEAMVR SETUP)")]
		private void OpenSetupTutorial()
		{
			Application.OpenURL("https://www.youtube.com/watch?v=6Pfx7lYQiIA&feature=youtu.be");
		}

		[ContextMenu("Auto-detect References")]
		public void AutoDetectReferences()
		{
			References.AutoDetectReferences(base.transform, out references);
		}

		[ContextMenu("Guess Hand Orientations")]
		public void GuessHandOrientations()
		{
			solver.GuessHandOrientations(references, onlyIfZero: false);
		}

		public override IKSolver GetIKSolver()
		{
			return solver;
		}

		protected override void InitiateSolver()
		{
			if (references.isEmpty)
			{
				AutoDetectReferences();
			}
			if (references.isFilled)
			{
				solver.SetToReferences(references);
			}
			base.InitiateSolver();
		}
	}
	[Serializable]
	public class FABRIKChain
	{
		public FABRIK ik;

		[Range(0f, 1f)]
		public float pull = 1f;

		[Range(0f, 1f)]
		public float pin = 1f;

		public int[] children = new int[0];

		public bool IsValid(ref string message)
		{
			if (ik == null)
			{
				message = "IK unassigned in FABRIKChain.";
				return false;
			}
			if (!ik.solver.IsValid(ref message))
			{
				return false;
			}
			return true;
		}

		public void Initiate()
		{
			ik.enabled = false;
		}

		public void Stage1(FABRIKChain[] chain)
		{
			for (int i = 0; i < children.Length; i++)
			{
				chain[children[i]].Stage1(chain);
			}
			if (children.Length == 0)
			{
				ik.solver.SolveForward(ik.solver.GetIKPosition());
			}
			else
			{
				ik.solver.SolveForward(GetCentroid(chain));
			}
		}

		public void Stage2(Vector3 rootPosition, FABRIKChain[] chain)
		{
			ik.solver.SolveBackward(rootPosition);
			for (int i = 0; i < children.Length; i++)
			{
				chain[children[i]].Stage2(ik.solver.bones[ik.solver.bones.Length - 1].transform.position, chain);
			}
		}

		private Vector3 GetCentroid(FABRIKChain[] chain)
		{
			Vector3 iKPosition = ik.solver.GetIKPosition();
			if (pin >= 1f)
			{
				return iKPosition;
			}
			float num = 0f;
			for (int i = 0; i < children.Length; i++)
			{
				num += chain[children[i]].pull;
			}
			if (num <= 0f)
			{
				return iKPosition;
			}
			if (num < 1f)
			{
				num = 1f;
			}
			Vector3 vector = iKPosition;
			for (int j = 0; j < children.Length; j++)
			{
				Vector3 vector2 = chain[children[j]].ik.solver.bones[0].solverPosition - iKPosition;
				float num2 = chain[children[j]].pull / num;
				vector += vector2 * num2;
			}
			if (pin <= 0f)
			{
				return vector;
			}
			return vector + (iKPosition - vector) * pin;
		}
	}
	public class FBBIKArmBending : MonoBehaviour
	{
		public FullBodyBipedIK ik;

		public Vector3 bendDirectionOffsetLeft;

		public Vector3 bendDirectionOffsetRight;

		public Vector3 characterSpaceBendOffsetLeft;

		public Vector3 characterSpaceBendOffsetRight;

		private Quaternion leftHandTargetRotation;

		private Quaternion rightHandTargetRotation;

		private bool initiated;

		private void LateUpdate()
		{
			if (!(ik == null))
			{
				if (!initiated)
				{
					IKSolverFullBodyBiped solver = ik.solver;
					solver.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Combine(solver.OnPostUpdate, new IKSolver.UpdateDelegate(OnPostFBBIK));
					initiated = true;
				}
				if (ik.solver.leftHandEffector.target != null)
				{
					Vector3 left = Vector3.left;
					ik.solver.leftArmChain.bendConstraint.direction = ik.solver.leftHandEffector.target.rotation * left + ik.solver.leftHandEffector.target.rotation * bendDirectionOffsetLeft + ik.transform.rotation * characterSpaceBendOffsetLeft;
					ik.solver.leftArmChain.bendConstraint.weight = 1f;
				}
				if (ik.solver.rightHandEffector.target != null)
				{
					Vector3 right = Vector3.right;
					ik.solver.rightArmChain.bendConstraint.direction = ik.solver.rightHandEffector.target.rotation * right + ik.solver.rightHandEffector.target.rotation * bendDirectionOffsetRight + ik.transform.rotation * characterSpaceBendOffsetRight;
					ik.solver.rightArmChain.bendConstraint.weight = 1f;
				}
			}
		}

		private void OnPostFBBIK()
		{
			if (!(ik == null))
			{
				if (ik.solver.leftHandEffector.target != null)
				{
					ik.references.leftHand.rotation = ik.solver.leftHandEffector.target.rotation;
				}
				if (ik.solver.rightHandEffector.target != null)
				{
					ik.references.rightHand.rotation = ik.solver.rightHandEffector.target.rotation;
				}
			}
		}

		private void OnDestroy()
		{
			if (ik != null)
			{
				IKSolverFullBodyBiped solver = ik.solver;
				solver.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Remove(solver.OnPostUpdate, new IKSolver.UpdateDelegate(OnPostFBBIK));
			}
		}
	}
	public class FBBIKHeadEffector : MonoBehaviour
	{
		[Serializable]
		public class BendBone
		{
			[Tooltip("Assign spine and/or neck bones.")]
			public Transform transform;

			[Tooltip("The weight of rotating this bone.")]
			[Range(0f, 1f)]
			public float weight = 0.5f;

			private Quaternion defaultLocalRotation = Quaternion.identity;

			public BendBone()
			{
			}

			public BendBone(Transform transform, float weight)
			{
				this.transform = transform;
				this.weight = weight;
			}

			public void StoreDefaultLocalState()
			{
				defaultLocalRotation = transform.localRotation;
			}

			public void FixTransforms()
			{
				transform.localRotation = defaultLocalRotation;
			}
		}

		[Tooltip("Reference to the FBBIK component.")]
		public FullBodyBipedIK ik;

		[LargeHeader("Position")]
		[Tooltip("Master weight for positioning the head.")]
		[Range(0f, 1f)]
		public float positionWeight = 1f;

		[Tooltip("The weight of moving the body along with the head")]
		[Range(0f, 1f)]
		public float bodyWeight = 0.8f;

		[Tooltip("The weight of moving the thighs along with the head")]
		[Range(0f, 1f)]
		public float thighWeight = 0.8f;

		[Tooltip("If false, hands will not pull the head away if they are too far. Disabling this will improve performance significantly.")]
		public bool handsPullBody = true;

		[LargeHeader("Rotation")]
		[Tooltip("The weight of rotating the head bone after solving")]
		[Range(0f, 1f)]
		public float rotationWeight;

		[Tooltip("Clamping the rotation of the body")]
		[Range(0f, 1f)]
		public float bodyClampWeight = 0.5f;

		[Tooltip("Clamping the rotation of the head")]
		[Range(0f, 1f)]
		public float headClampWeight = 0.5f;

		[Tooltip("The master weight of bending/twisting the spine to the rotation of the head effector. This is similar to CCD, but uses the rotation of the head effector not the position.")]
		[Range(0f, 1f)]
		public float bendWeight = 1f;

		[Tooltip("The bones to use for bending.")]
		public BendBone[] bendBones = new BendBone[0];

		[LargeHeader("CCD")]
		[Tooltip("Optional. The master weight of the CCD (Cyclic Coordinate Descent) IK effect that bends the spine towards the head effector before FBBIK solves.")]
		[Range(0f, 1f)]
		public float CCDWeight = 1f;

		[Tooltip("The weight of rolling the bones in towards the target")]
		[Range(0f, 1f)]
		public float roll;

		[Tooltip("Smoothing the CCD effect.")]
		[Range(0f, 1000f)]
		public float damper = 500f;

		[Tooltip("Bones to use for the CCD pass. Assign spine and/or neck bones.")]
		public Transform[] CCDBones = new Transform[0];

		[LargeHeader("Stretching")]
		[Tooltip("Stretching the spine/neck to help reach the target. This is useful for making sure the head stays locked relative to the VR headset. NB! Stretching is done after FBBIK has solved so if you have the hand effectors pinned and spine bones included in the 'Stretch Bones', the hands might become offset from their target positions.")]
		[Range(0f, 1f)]
		public float postStretchWeight = 1f;

		[Tooltip("Stretch magnitude limit.")]
		public float maxStretch = 0.1f;

		[Tooltip("If > 0, dampers the stretching effect.")]
		public float stretchDamper;

		[Tooltip("If true, will fix head position to this Transform no matter what. Good for making sure the head will not budge away from the VR headset")]
		public bool fixHead;

		[Tooltip("Bones to use for stretching. The more bones you add, the less noticable the effect.")]
		public Transform[] stretchBones = new Transform[0];

		[LargeHeader("Chest Direction")]
		public Vector3 chestDirection = Vector3.forward;

		[Range(0f, 1f)]
		public float chestDirectionWeight = 1f;

		public Transform[] chestBones = new Transform[0];

		public IKSolver.UpdateDelegate OnPostHeadEffectorFK;

		private Vector3 offset;

		private Vector3 headToBody;

		private Vector3 shoulderCenterToHead;

		private Vector3 headToLeftThigh;

		private Vector3 headToRightThigh;

		private Vector3 leftShoulderPos;

		private Vector3 rightShoulderPos;

		private float shoulderDist;

		private float leftShoulderDist;

		private float rightShoulderDist;

		private Quaternion chestRotation;

		private Quaternion headRotationRelativeToRoot;

		private Quaternion[] ccdDefaultLocalRotations = new Quaternion[0];

		private Vector3 headLocalPosition;

		private Quaternion headLocalRotation;

		private Vector3[] stretchLocalPositions = new Vector3[0];

		private Quaternion[] stretchLocalRotations = new Quaternion[0];

		private Vector3[] chestLocalPositions = new Vector3[0];

		private Quaternion[] chestLocalRotations = new Quaternion[0];

		private int bendBonesCount;

		private int ccdBonesCount;

		private int stretchBonesCount;

		private int chestBonesCount;

		private void Awake()
		{
			IKSolverFullBodyBiped solver = ik.solver;
			solver.OnPreRead = (IKSolver.UpdateDelegate)Delegate.Combine(solver.OnPreRead, new IKSolver.UpdateDelegate(OnPreRead));
			IKSolverFullBodyBiped solver2 = ik.solver;
			solver2.OnPreIteration = (IKSolver.IterationDelegate)Delegate.Combine(solver2.OnPreIteration, new IKSolver.IterationDelegate(Iterate));
			IKSolverFullBodyBiped solver3 = ik.solver;
			solver3.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Combine(solver3.OnPostUpdate, new IKSolver.UpdateDelegate(OnPostUpdate));
			IKSolverFullBodyBiped solver4 = ik.solver;
			solver4.OnStoreDefaultLocalState = (IKSolver.UpdateDelegate)Delegate.Combine(solver4.OnStoreDefaultLocalState, new IKSolver.UpdateDelegate(OnStoreDefaultLocalState));
			IKSolverFullBodyBiped solver5 = ik.solver;
			solver5.OnFixTransforms = (IKSolver.UpdateDelegate)Delegate.Combine(solver5.OnFixTransforms, new IKSolver.UpdateDelegate(OnFixTransforms));
			headRotationRelativeToRoot = Quaternion.Inverse(ik.references.root.rotation) * ik.references.head.rotation;
		}

		private void OnStoreDefaultLocalState()
		{
			BendBone[] array = bendBones;
			for (int i = 0; i < array.Length; i++)
			{
				array[i]?.StoreDefaultLocalState();
			}
			ccdDefaultLocalRotations = new Quaternion[CCDBones.Length];
			for (int j = 0; j < CCDBones.Length; j++)
			{
				if (CCDBones[j] != null)
				{
					ccdDefaultLocalRotations[j] = CCDBones[j].localRotation;
				}
			}
			headLocalPosition = ik.references.head.localPosition;
			headLocalRotation = ik.references.head.localRotation;
			stretchLocalPositions = new Vector3[stretchBones.Length];
			stretchLocalRotations = new Quaternion[stretchBones.Length];
			for (int k = 0; k < stretchBones.Length; k++)
			{
				if (stretchBones[k] != null)
				{
					stretchLocalPositions[k] = stretchBones[k].localPosition;
					stretchLocalRotations[k] = stretchBones[k].localRotation;
				}
			}
			chestLocalPositions = new Vector3[chestBones.Length];
			chestLocalRotations = new Quaternion[chestBones.Length];
			for (int l = 0; l < chestBones.Length; l++)
			{
				if (chestBones[l] != null)
				{
					chestLocalPositions[l] = chestBones[l].localPosition;
					chestLocalRotations[l] = chestBones[l].localRotation;
				}
			}
			bendBonesCount = bendBones.Length;
			ccdBonesCount = CCDBones.Length;
			stretchBonesCount = stretchBones.Length;
			chestBonesCount = chestBones.Length;
		}

		private void OnFixTransforms()
		{
			if (!ik.enabled)
			{
				return;
			}
			BendBone[] array = bendBones;
			for (int i = 0; i < array.Length; i++)
			{
				array[i]?.FixTransforms();
			}
			for (int j = 0; j < CCDBones.Length; j++)
			{
				if (CCDBones[j] != null)
				{
					CCDBones[j].localRotation = ccdDefaultLocalRotations[j];
				}
			}
			ik.references.head.localPosition = headLocalPosition;
			ik.references.head.localRotation = headLocalRotation;
			for (int k = 0; k < stretchBones.Length; k++)
			{
				if (stretchBones[k] != null)
				{
					stretchBones[k].localPosition = stretchLocalPositions[k];
					stretchBones[k].localRotation = stretchLocalRotations[k];
				}
			}
			for (int l = 0; l < chestBones.Length; l++)
			{
				if (chestBones[l] != null)
				{
					chestBones[l].localPosition = chestLocalPositions[l];
					chestBones[l].localRotation = chestLocalRotations[l];
				}
			}
		}

		private void OnPreRead()
		{
			if (base.enabled && ik.enabled && base.gameObject.activeInHierarchy && ik.solver.iterations != 0)
			{
				ik.solver.FABRIKPass = handsPullBody;
				if (bendBonesCount != bendBones.Length || ccdBonesCount != CCDBones.Length || stretchBonesCount != stretchBones.Length || chestBonesCount != chestBones.Length)
				{
					OnStoreDefaultLocalState();
				}
				ChestDirection();
				SpineBend();
				CCDPass();
				offset = base.transform.position - ik.references.head.position;
				shoulderDist = Vector3.Distance(ik.references.leftUpperArm.position, ik.references.rightUpperArm.position);
				leftShoulderDist = Vector3.Distance(ik.references.head.position, ik.references.leftUpperArm.position);
				rightShoulderDist = Vector3.Distance(ik.references.head.position, ik.references.rightUpperArm.position);
				headToBody = ik.solver.rootNode.position - ik.references.head.position;
				headToLeftThigh = ik.references.leftThigh.position - ik.references.head.position;
				headToRightThigh = ik.references.rightThigh.position - ik.references.head.position;
				leftShoulderPos = ik.references.leftUpperArm.position + offset * bodyWeight;
				rightShoulderPos = ik.references.rightUpperArm.position + offset * bodyWeight;
				chestRotation = Quaternion.LookRotation(ik.references.head.position - ik.references.leftUpperArm.position, ik.references.rightUpperArm.position - ik.references.leftUpperArm.position);
				if (OnPostHeadEffectorFK != null)
				{
					OnPostHeadEffectorFK();
				}
			}
		}

		private void SpineBend()
		{
			float num = bendWeight * ik.solver.IKPositionWeight;
			if (num <= 0f || bendBones.Length == 0)
			{
				return;
			}
			Quaternion rotation = base.transform.rotation * Quaternion.Inverse(ik.references.root.rotation * headRotationRelativeToRoot);
			rotation = QuaTools.ClampRotation(rotation, bodyClampWeight, 2);
			float num2 = 1f / (float)bendBones.Length;
			for (int i = 0; i < bendBones.Length; i++)
			{
				if (bendBones[i].transform != null)
				{
					bendBones[i].transform.rotation = Quaternion.Lerp(Quaternion.identity, rotation, num2 * bendBones[i].weight * num) * bendBones[i].transform.rotation;
				}
			}
		}

		private void CCDPass()
		{
			float num = CCDWeight * ik.solver.IKPositionWeight;
			if (!(num <= 0f))
			{
				for (int num2 = CCDBones.Length - 1; num2 > -1; num2--)
				{
					Quaternion quaternion = Quaternion.FromToRotation(ik.references.head.position - CCDBones[num2].position, base.transform.position - CCDBones[num2].position) * CCDBones[num2].rotation;
					float num3 = Mathf.Lerp((CCDBones.Length - num2) / CCDBones.Length, 1f, roll);
					float num4 = Quaternion.Angle(Quaternion.identity, quaternion);
					num4 = Mathf.Lerp(0f, num4, (damper - num4) / damper);
					CCDBones[num2].rotation = Quaternion.RotateTowards(CCDBones[num2].rotation, quaternion, num4 * num * num3);
				}
			}
		}

		private void Iterate(int iteration)
		{
			if (base.enabled && ik.enabled && base.gameObject.activeInHierarchy && ik.solver.iterations != 0)
			{
				leftShoulderPos = base.transform.position + (leftShoulderPos - base.transform.position).normalized * leftShoulderDist;
				rightShoulderPos = base.transform.position + (rightShoulderPos - base.transform.position).normalized * rightShoulderDist;
				Solve(ref leftShoulderPos, ref rightShoulderPos, shoulderDist);
				LerpSolverPosition(ik.solver.leftShoulderEffector, leftShoulderPos, positionWeight * ik.solver.IKPositionWeight, ik.solver.leftShoulderEffector.positionOffset);
				LerpSolverPosition(ik.solver.rightShoulderEffector, rightShoulderPos, positionWeight * ik.solver.IKPositionWeight, ik.solver.rightShoulderEffector.positionOffset);
				Quaternion to = Quaternion.LookRotation(base.transform.position - leftShoulderPos, rightShoulderPos - leftShoulderPos);
				Quaternion quaternion = QuaTools.FromToRotation(chestRotation, to);
				Vector3 vector = quaternion * headToBody;
				LerpSolverPosition(ik.solver.bodyEffector, base.transform.position + vector, positionWeight * ik.solver.IKPositionWeight, ik.solver.bodyEffector.positionOffset - ik.solver.pullBodyOffset);
				Quaternion quaternion2 = Quaternion.Lerp(Quaternion.identity, quaternion, thighWeight);
				Vector3 vector2 = quaternion2 * headToLeftThigh;
				Vector3 vector3 = quaternion2 * headToRightThigh;
				LerpSolverPosition(ik.solver.leftThighEffector, base.transform.position + vector2, positionWeight * ik.solver.IKPositionWeight, ik.solver.bodyEffector.positionOffset - ik.solver.pullBodyOffset + ik.solver.leftThighEffector.positionOffset);
				LerpSolverPosition(ik.solver.rightThighEffector, base.transform.position + vector3, positionWeight * ik.solver.IKPositionWeight, ik.solver.bodyEffector.positionOffset - ik.solver.pullBodyOffset + ik.solver.rightThighEffector.positionOffset);
			}
		}

		private void OnPostUpdate()
		{
			if (base.enabled && ik.enabled && base.gameObject.activeInHierarchy)
			{
				PostStretching();
				Quaternion rotation = QuaTools.FromToRotation(ik.references.head.rotation, base.transform.rotation);
				rotation = QuaTools.ClampRotation(rotation, headClampWeight, 2);
				ik.references.head.rotation = Quaternion.Lerp(Quaternion.identity, rotation, rotationWeight * ik.solver.IKPositionWeight) * ik.references.head.rotation;
			}
		}

		private void ChestDirection()
		{
			float num = chestDirectionWeight * ik.solver.IKPositionWeight;
			if (num <= 0f)
			{
				return;
			}
			bool changed = false;
			chestDirection = V3Tools.ClampDirection(chestDirection, ik.references.root.forward, 0.45f, 2, out changed);
			if (!(chestDirection == Vector3.zero))
			{
				Quaternion b = Quaternion.FromToRotation(ik.references.root.forward, chestDirection);
				b = Quaternion.Lerp(Quaternion.identity, b, num * (1f / (float)chestBones.Length));
				Transform[] array = chestBones;
				foreach (Transform transform in array)
				{
					transform.rotation = b * transform.rotation;
				}
			}
		}

		private void PostStretching()
		{
			float num = postStretchWeight * ik.solver.IKPositionWeight;
			if (num > 0f)
			{
				Vector3 vector = Vector3.ClampMagnitude(base.transform.position - ik.references.head.position, maxStretch);
				vector *= num;
				stretchDamper = Mathf.Max(stretchDamper, 0f);
				if (stretchDamper > 0f)
				{
					vector /= (1f + vector.magnitude) * (1f + stretchDamper);
				}
				for (int i = 0; i < stretchBones.Length; i++)
				{
					if (stretchBones[i] != null)
					{
						stretchBones[i].position += vector / stretchBones.Length;
					}
				}
			}
			if (fixHead && ik.solver.IKPositionWeight > 0f)
			{
				ik.references.head.position = base.transform.position;
			}
		}

		private void LerpSolverPosition(IKEffector effector, Vector3 position, float weight, Vector3 offset)
		{
			effector.GetNode(ik.solver).solverPosition = Vector3.Lerp(effector.GetNode(ik.solver).solverPosition, position + offset, weight);
		}

		private void Solve(ref Vector3 pos1, ref Vector3 pos2, float nominalDistance)
		{
			Vector3 vector = pos2 - pos1;
			float magnitude = vector.magnitude;
			if (magnitude != nominalDistance && magnitude != 0f)
			{
				float num = 1f;
				num *= 1f - nominalDistance / magnitude;
				Vector3 vector2 = vector * num * 0.5f;
				pos1 += vector2;
				pos2 -= vector2;
			}
		}

		private void OnDestroy()
		{
			if (ik != null)
			{
				IKSolverFullBodyBiped solver = ik.solver;
				solver.OnPreRead = (IKSolver.UpdateDelegate)Delegate.Remove(solver.OnPreRead, new IKSolver.UpdateDelegate(OnPreRead));
				IKSolverFullBodyBiped solver2 = ik.solver;
				solver2.OnPreIteration = (IKSolver.IterationDelegate)Delegate.Remove(solver2.OnPreIteration, new IKSolver.IterationDelegate(Iterate));
				IKSolverFullBodyBiped solver3 = ik.solver;
				solver3.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Remove(solver3.OnPostUpdate, new IKSolver.UpdateDelegate(OnPostUpdate));
				IKSolverFullBodyBiped solver4 = ik.solver;
				solver4.OnStoreDefaultLocalState = (IKSolver.UpdateDelegate)Delegate.Remove(solver4.OnStoreDefaultLocalState, new IKSolver.UpdateDelegate(OnStoreDefaultLocalState));
				IKSolverFullBodyBiped solver5 = ik.solver;
				solver5.OnFixTransforms = (IKSolver.UpdateDelegate)Delegate.Remove(solver5.OnFixTransforms, new IKSolver.UpdateDelegate(OnFixTransforms));
			}
		}
	}
	[Serializable]
	public class FBIKChain
	{
		[Serializable]
		public class ChildConstraint
		{
			public float pushElasticity;

			public float pullElasticity;

			[SerializeField]
			private Transform bone1;

			[SerializeField]
			private Transform bone2;

			private float crossFade;

			private float inverseCrossFade;

			private int chain1Index;

			private int chain2Index;

			public float nominalDistance { get; private set; }

			public bool isRigid { get; private set; }

			public ChildConstraint(Transform bone1, Transform bone2, float pushElasticity = 0f, float pullElasticity = 0f)
			{
				this.bone1 = bone1;
				this.bone2 = bone2;
				this.pushElasticity = pushElasticity;
				this.pullElasticity = pullElasticity;
			}

			public void Initiate(IKSolverFullBody solver)
			{
				chain1Index = solver.GetChainIndex(bone1);
				chain2Index = solver.GetChainIndex(bone2);
				OnPreSolve(solver);
			}

			public void OnPreSolve(IKSolverFullBody solver)
			{
				nominalDistance = Vector3.Distance(solver.chain[chain1Index].nodes[0].transform.position, solver.chain[chain2Index].nodes[0].transform.position);
				isRigid = pushElasticity <= 0f && pullElasticity <= 0f;
				if (isRigid)
				{
					float num = solver.chain[chain1Index].pull - solver.chain[chain2Index].pull;
					crossFade = 1f - (0.5f + num * 0.5f);
				}
				else
				{
					crossFade = 0.5f;
				}
				inverseCrossFade = 1f - crossFade;
			}

			public void Solve(IKSolverFullBody solver)
			{
				if (pushElasticity >= 1f && pullElasticity >= 1f)
				{
					return;
				}
				Vector3 vector = solver.chain[chain2Index].nodes[0].solverPosition - solver.chain[chain1Index].nodes[0].solverPosition;
				float magnitude = vector.magnitude;
				if (magnitude != nominalDistance && magnitude != 0f)
				{
					float num = 1f;
					if (!isRigid)
					{
						float num2 = ((magnitude > nominalDistance) ? pullElasticity : pushElasticity);
						num = 1f - num2;
					}
					num *= 1f - nominalDistance / magnitude;
					Vector3 vector2 = vector * num;
					solver.chain[chain1Index].nodes[0].solverPosition += vector2 * crossFade;
					solver.chain[chain2Index].nodes[0].solverPosition -= vector2 * inverseCrossFade;
				}
			}
		}

		[Serializable]
		public enum Smoothing
		{
			None,
			Exponential,
			Cubic
		}

		[Range(0f, 1f)]
		public float pin;

		[Range(0f, 1f)]
		public float pull = 1f;

		[Range(0f, 1f)]
		public float push;

		[Range(-1f, 1f)]
		public float pushParent;

		[Range(0f, 1f)]
		public float reach = 0.1f;

		public Smoothing reachSmoothing = Smoothing.Exponential;

		public Smoothing pushSmoothing = Smoothing.Exponential;

		public IKSolver.Node[] nodes = new IKSolver.Node[0];

		public int[] children = new int[0];

		public ChildConstraint[] childConstraints = new ChildConstraint[0];

		public IKConstraintBend bendConstraint = new IKConstraintBend();

		private float rootLength;

		private bool initiated;

		private float length;

		private float distance;

		private IKSolver.Point p;

		private float reachForce;

		private float pullParentSum;

		private float[] crossFades;

		private float sqrMag1;

		private float sqrMag2;

		private float sqrMagDif;

		private const float maxLimbLength = 0.99999f;

		public FBIKChain()
		{
		}

		public FBIKChain(float pin, float pull, params Transform[] nodeTransforms)
		{
			this.pin = pin;
			this.pull = pull;
			SetNodes(nodeTransforms);
			children = new int[0];
		}

		public void SetNodes(params Transform[] boneTransforms)
		{
			nodes = new IKSolver.Node[boneTransforms.Length];
			for (int i = 0; i < boneTransforms.Length; i++)
			{
				nodes[i] = new IKSolver.Node(boneTransforms[i]);
			}
		}

		public int GetNodeIndex(Transform boneTransform)
		{
			for (int i = 0; i < nodes.Length; i++)
			{
				if (nodes[i].transform == boneTransform)
				{
					return i;
				}
			}
			return -1;
		}

		public bool IsValid(ref string message)
		{
			if (nodes.Length == 0)
			{
				message = "FBIK chain contains no nodes.";
				return false;
			}
			IKSolver.Node[] array = nodes;
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i].transform == null)
				{
					message = "Node transform is null in FBIK chain.";
					return false;
				}
			}
			return true;
		}

		public void Initiate(IKSolverFullBody solver)
		{
			initiated = false;
			IKSolver.Node[] array = nodes;
			foreach (IKSolver.Node obj in array)
			{
				obj.solverPosition = obj.transform.position;
			}
			CalculateBoneLengths(solver);
			ChildConstraint[] array2 = childConstraints;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i].Initiate(solver);
			}
			if (nodes.Length == 3)
			{
				bendConstraint.SetBones(nodes[0].transform, nodes[1].transform, nodes[2].transform);
				bendConstraint.Initiate(solver);
			}
			crossFades = new float[children.Length];
			initiated = true;
		}

		public void ReadPose(IKSolverFullBody solver, bool fullBody)
		{
			if (!initiated)
			{
				return;
			}
			for (int i = 0; i < nodes.Length; i++)
			{
				nodes[i].solverPosition = nodes[i].transform.position + nodes[i].offset;
			}
			CalculateBoneLengths(solver);
			if (!fullBody)
			{
				return;
			}
			for (int j = 0; j < childConstraints.Length; j++)
			{
				childConstraints[j].OnPreSolve(solver);
			}
			if (children.Length != 0)
			{
				float num = nodes[nodes.Length - 1].effectorPositionWeight;
				for (int k = 0; k < children.Length; k++)
				{
					num += solver.chain[children[k]].nodes[0].effectorPositionWeight * solver.chain[children[k]].pull;
				}
				num = Mathf.Clamp(num, 1f, float.PositiveInfinity);
				for (int l = 0; l < children.Length; l++)
				{
					crossFades[l] = solver.chain[children[l]].nodes[0].effectorPositionWeight * solver.chain[children[l]].pull / num;
				}
			}
			pullParentSum = 0f;
			for (int m = 0; m < children.Length; m++)
			{
				pullParentSum += solver.chain[children[m]].pull;
			}
			pullParentSum = Mathf.Clamp(pullParentSum, 1f, float.PositiveInfinity);
			if (nodes.Length == 3)
			{
				reachForce = reach * Mathf.Clamp(nodes[2].effectorPositionWeight, 0f, 1f);
			}
			else
			{
				reachForce = 0f;
			}
			if (push > 0f && nodes.Length > 1)
			{
				distance = Vector3.Distance(nodes[0].transform.position, nodes[nodes.Length - 1].transform.position);
			}
		}

		private void CalculateBoneLengths(IKSolverFullBody solver)
		{
			length = 0f;
			for (int i = 0; i < nodes.Length - 1; i++)
			{
				nodes[i].length = Vector3.Distance(nodes[i].transform.position, nodes[i + 1].transform.position);
				length += nodes[i].length;
				if (nodes[i].length == 0f)
				{
					Warning.Log("Bone " + nodes[i].transform.name + " - " + nodes[i + 1].transform.name + " length is zero, can not solve.", nodes[i].transform);
					return;
				}
			}
			for (int j = 0; j < children.Length; j++)
			{
				solver.chain[children[j]].rootLength = (solver.chain[children[j]].nodes[0].transform.position - nodes[nodes.Length - 1].transform.position).magnitude;
				if (solver.chain[children[j]].rootLength == 0f)
				{
					return;
				}
			}
			if (nodes.Length == 3)
			{
				sqrMag1 = nodes[0].length * nodes[0].length;
				sqrMag2 = nodes[1].length * nodes[1].length;
				sqrMagDif = sqrMag1 - sqrMag2;
			}
		}

		public void Reach(IKSolverFullBody solver)
		{
			if (!initiated)
			{
				return;
			}
			for (int i = 0; i < children.Length; i++)
			{
				solver.chain[children[i]].Reach(solver);
			}
			if (reachForce <= 0f)
			{
				return;
			}
			Vector3 vector = nodes[2].solverPosition - nodes[0].solverPosition;
			if (!(vector == Vector3.zero))
			{
				float magnitude = vector.magnitude;
				Vector3 vector2 = vector / magnitude * length;
				float num = Mathf.Clamp(magnitude / length, 1f - reachForce, 1f + reachForce) - 1f;
				num = Mathf.Clamp(num + reachForce, -1f, 1f);
				switch (reachSmoothing)
				{
				case Smoothing.Exponential:
					num *= num;
					break;
				case Smoothing.Cubic:
					num *= num * num;
					break;
				}
				Vector3 vector3 = vector2 * Mathf.Clamp(num, 0f, magnitude);
				nodes[0].solverPosition += vector3 * (1f - nodes[0].effectorPositionWeight);
				nodes[2].solverPosition += vector3;
			}
		}

		public Vector3 Push(IKSolverFullBody solver)
		{
			Vector3 zero = Vector3.zero;
			for (int i = 0; i < children.Length; i++)
			{
				zero += solver.chain[children[i]].Push(solver) * solver.chain[children[i]].pushParent;
			}
			nodes[nodes.Length - 1].solverPosition += zero;
			if (nodes.Length < 2)
			{
				return Vector3.zero;
			}
			if (push <= 0f)
			{
				return Vector3.zero;
			}
			Vector3 vector = nodes[2].solverPosition - nodes[0].solverPosition;
			float magnitude = vector.magnitude;
			if (magnitude == 0f)
			{
				return Vector3.zero;
			}
			float num = 1f - magnitude / distance;
			if (num <= 0f)
			{
				return Vector3.zero;
			}
			switch (pushSmoothing)
			{
			case Smoothing.Exponential:
				num *= num;
				break;
			case Smoothing.Cubic:
				num *= num * num;
				break;
			}
			Vector3 vector2 = -vector * num * push;
			nodes[0].solverPosition += vector2;
			return vector2;
		}

		public void SolveTrigonometric(IKSolverFullBody solver, bool calculateBendDirection = false)
		{
			if (!initiated)
			{
				return;
			}
			for (int i = 0; i < children.Length; i++)
			{
				solver.chain[children[i]].SolveTrigonometric(solver, calculateBendDirection);
			}
			if (nodes.Length == 3)
			{
				Vector3 vector = nodes[2].solverPosition - nodes[0].solverPosition;
				float magnitude = vector.magnitude;
				if (magnitude != 0f)
				{
					float num = Mathf.Clamp(magnitude, 0f, length * 0.99999f);
					Vector3 direction = vector / magnitude * num;
					Vector3 bendDirection = ((calculateBendDirection && bendConstraint.initiated) ? bendConstraint.GetDir(solver) : (nodes[1].solverPosition - nodes[0].solverPosition));
					Vector3 dirToBendPoint = GetDirToBendPoint(direction, bendDirection, num);
					nodes[1].solverPosition = nodes[0].solverPosition + dirToBendPoint;
				}
			}
		}

		public void Stage1(IKSolverFullBody solver)
		{
			for (int i = 0; i < children.Length; i++)
			{
				solver.chain[children[i]].Stage1(solver);
			}
			if (children.Length == 0)
			{
				ForwardReach(nodes[nodes.Length - 1].solverPosition);
				return;
			}
			Vector3 solverPosition = nodes[nodes.Length - 1].solverPosition;
			SolveChildConstraints(solver);
			for (int j = 0; j < children.Length; j++)
			{
				Vector3 vector = solver.chain[children[j]].nodes[0].solverPosition;
				if (solver.chain[children[j]].rootLength > 0f)
				{
					vector = SolveFABRIKJoint(nodes[nodes.Length - 1].solverPosition, solver.chain[children[j]].nodes[0].solverPosition, solver.chain[children[j]].rootLength);
				}
				if (pullParentSum > 0f)
				{
					solverPosition += (vector - nodes[nodes.Length - 1].solverPosition) * (solver.chain[children[j]].pull / pullParentSum);
				}
			}
			ForwardReach(Vector3.Lerp(solverPosition, nodes[nodes.Length - 1].solverPosition, pin));
		}

		public void Stage2(IKSolverFullBody solver, Vector3 position)
		{
			BackwardReach(position);
			int num = Mathf.Clamp(solver.iterations, 2, 4);
			if (childConstraints.Length != 0)
			{
				for (int i = 0; i < num; i++)
				{
					SolveConstraintSystems(solver);
				}
			}
			for (int j = 0; j < children.Length; j++)
			{
				solver.chain[children[j]].Stage2(solver, nodes[nodes.Length - 1].solverPosition);
			}
		}

		public void SolveConstraintSystems(IKSolverFullBody solver)
		{
			SolveChildConstraints(solver);
			for (int i = 0; i < children.Length; i++)
			{
				SolveLinearConstraint(nodes[nodes.Length - 1], solver.chain[children[i]].nodes[0], crossFades[i], solver.chain[children[i]].rootLength);
			}
		}

		private Vector3 SolveFABRIKJoint(Vector3 pos1, Vector3 pos2, float length)
		{
			return pos2 + (pos1 - pos2).normalized * length;
		}

		protected Vector3 GetDirToBendPoint(Vector3 direction, Vector3 bendDirection, float directionMagnitude)
		{
			float num = (directionMagnitude * directionMagnitude + sqrMagDif) / 2f / directionMagnitude;
			float y = (float)Math.Sqrt(Mathf.Clamp(sqrMag1 - num * num, 0f, float.PositiveInfinity));
			if (direction == Vector3.zero)
			{
				return Vector3.zero;
			}
			return Quaternion.LookRotation(direction, bendDirection) * new Vector3(0f, y, num);
		}

		private void SolveChildConstraints(IKSolverFullBody solver)
		{
			for (int i = 0; i < childConstraints.Length; i++)
			{
				childConstraints[i].Solve(solver);
			}
		}

		private void SolveLinearConstraint(IKSolver.Node node1, IKSolver.Node node2, float crossFade, float distance)
		{
			Vector3 vector = node2.solverPosition - node1.solverPosition;
			float magnitude = vector.magnitude;
			if (distance != magnitude && magnitude != 0f)
			{
				Vector3 vector2 = vector * (1f - distance / magnitude);
				node1.solverPosition += vector2 * crossFade;
				node2.solverPosition -= vector2 * (1f - crossFade);
			}
		}

		public void ForwardReach(Vector3 position)
		{
			nodes[nodes.Length - 1].solverPosition = position;
			for (int num = nodes.Length - 2; num > -1; num--)
			{
				nodes[num].solverPosition = SolveFABRIKJoint(nodes[num].solverPosition, nodes[num + 1].solverPosition, nodes[num].length);
			}
		}

		private void BackwardReach(Vector3 position)
		{
			if (rootLength > 0f)
			{
				position = SolveFABRIKJoint(nodes[0].solverPosition, position, rootLength);
			}
			nodes[0].solverPosition = position;
			for (int i = 1; i < nodes.Length; i++)
			{
				nodes[i].solverPosition = SolveFABRIKJoint(nodes[i].solverPosition, nodes[i - 1].solverPosition, nodes[i - 1].length);
			}
		}
	}
	[Serializable]
	public class IKConstraintBend
	{
		public Transform bone1;

		public Transform bone2;

		public Transform bone3;

		public Transform bendGoal;

		public Vector3 direction = Vector3.right;

		public Quaternion rotationOffset;

		[Range(0f, 1f)]
		public float weight;

		public Vector3 defaultLocalDirection;

		public Vector3 defaultChildDirection;

		[NonSerialized]
		public float clampF = 0.505f;

		private int chainIndex1;

		private int nodeIndex1;

		private int chainIndex2;

		private int nodeIndex2;

		private int chainIndex3;

		private int nodeIndex3;

		public bool initiated { get; private set; }

		public bool IsValid(IKSolverFullBody solver, Warning.Logger logger)
		{
			if (bone1 == null || bone2 == null || bone3 == null)
			{
				logger?.Invoke("Bend Constraint contains a null reference.");
				return false;
			}
			if (solver.GetPoint(bone1) == null)
			{
				logger?.Invoke("Bend Constraint is referencing to a bone '" + bone1.name + "' that does not excist in the Node Chain.");
				return false;
			}
			if (solver.GetPoint(bone2) == null)
			{
				logger?.Invoke("Bend Constraint is referencing to a bone '" + bone2.name + "' that does not excist in the Node Chain.");
				return false;
			}
			if (solver.GetPoint(bone3) == null)
			{
				logger?.Invoke("Bend Constraint is referencing to a bone '" + bone3.name + "' that does not excist in the Node Chain.");
				return false;
			}
			return true;
		}

		public IKConstraintBend()
		{
		}

		public IKConstraintBend(Transform bone1, Transform bone2, Transform bone3)
		{
			SetBones(bone1, bone2, bone3);
		}

		public void SetBones(Transform bone1, Transform bone2, Transform bone3)
		{
			this.bone1 = bone1;
			this.bone2 = bone2;
			this.bone3 = bone3;
		}

		public void Initiate(IKSolverFullBody solver)
		{
			solver.GetChainAndNodeIndexes(bone1, out chainIndex1, out nodeIndex1);
			solver.GetChainAndNodeIndexes(bone2, out chainIndex2, out nodeIndex2);
			solver.GetChainAndNodeIndexes(bone3, out chainIndex3, out nodeIndex3);
			direction = OrthoToBone1(solver, OrthoToLimb(solver, bone2.position - bone1.position));
			defaultLocalDirection = Quaternion.Inverse(bone1.rotation) * direction;
			Vector3 vector = Vector3.Cross((bone3.position - bone1.position).normalized, direction);
			defaultChildDirection = Quaternion.Inverse(bone3.rotation) * vector;
			initiated = true;
		}

		public void SetLimbOrientation(Vector3 upper, Vector3 lower, Vector3 last)
		{
			if (upper == Vector3.zero)
			{
				UnityEngine.Debug.LogError("Attempting to set limb orientation to Vector3.zero axis");
			}
			if (lower == Vector3.zero)
			{
				UnityEngine.Debug.LogError("Attempting to set limb orientation to Vector3.zero axis");
			}
			if (last == Vector3.zero)
			{
				UnityEngine.Debug.LogError("Attempting to set limb orientation to Vector3.zero axis");
			}
			defaultLocalDirection = upper.normalized;
			defaultChildDirection = last.normalized;
		}

		public void LimitBend(float solverWeight, float positionWeight)
		{
			if (initiated)
			{
				Vector3 vector = bone1.rotation * -defaultLocalDirection;
				Vector3 fromDirection = bone3.position - bone2.position;
				bool changed = false;
				Vector3 toDirection = V3Tools.ClampDirection(fromDirection, vector, clampF * solverWeight, 0, out changed);
				Quaternion rotation = bone3.rotation;
				if (changed)
				{
					Quaternion quaternion = Quaternion.FromToRotation(fromDirection, toDirection);
					bone2.rotation = quaternion * bone2.rotation;
				}
				if (positionWeight > 0f)
				{
					Vector3 normal = bone2.position - bone1.position;
					Vector3 tangent = bone3.position - bone2.position;
					Vector3.OrthoNormalize(ref normal, ref tangent);
					Quaternion quaternion2 = Quaternion.FromToRotation(tangent, vector);
					bone2.rotation = Quaternion.Lerp(bone2.rotation, quaternion2 * bone2.rotation, positionWeight * solverWeight);
				}
				if (changed || positionWeight > 0f)
				{
					bone3.rotation = rotation;
				}
			}
		}

		public Vector3 GetDir(IKSolverFullBody solver)
		{
			if (!initiated)
			{
				return Vector3.zero;
			}
			float num = weight * solver.IKPositionWeight;
			if (bendGoal != null)
			{
				Vector3 vector = bendGoal.position - solver.GetNode(chainIndex1, nodeIndex1).solverPosition;
				if (vector != Vector3.zero)
				{
					direction = vector;
				}
			}
			if (num >= 1f)
			{
				return direction.normalized;
			}
			Vector3 vector2 = solver.GetNode(chainIndex3, nodeIndex3).solverPosition - solver.GetNode(chainIndex1, nodeIndex1).solverPosition;
			Vector3 vector3 = Quaternion.FromToRotation(bone3.position - bone1.position, vector2) * (bone2.position - bone1.position);
			if (solver.GetNode(chainIndex3, nodeIndex3).effectorRotationWeight > 0f)
			{
				Vector3 b = -Vector3.Cross(vector2, solver.GetNode(chainIndex3, nodeIndex3).solverRotation * defaultChildDirection);
				vector3 = Vector3.Lerp(vector3, b, solver.GetNode(chainIndex3, nodeIndex3).effectorRotationWeight);
			}
			if (rotationOffset != Quaternion.identity)
			{
				vector3 = Quaternion.FromToRotation(rotationOffset * vector2, vector2) * rotationOffset * vector3;
			}
			if (num <= 0f)
			{
				return vector3;
			}
			return Vector3.Lerp(vector3, direction.normalized, num);
		}

		private Vector3 OrthoToLimb(IKSolverFullBody solver, Vector3 tangent)
		{
			Vector3 normal = solver.GetNode(chainIndex3, nodeIndex3).solverPosition - solver.GetNode(chainIndex1, nodeIndex1).solverPosition;
			Vector3.OrthoNormalize(ref normal, ref tangent);
			return tangent;
		}

		private Vector3 OrthoToBone1(IKSolverFullBody solver, Vector3 tangent)
		{
			Vector3 normal = solver.GetNode(chainIndex2, nodeIndex2).solverPosition - solver.GetNode(chainIndex1, nodeIndex1).solverPosition;
			Vector3.OrthoNormalize(ref normal, ref tangent);
			return tangent;
		}
	}
	[Serializable]
	public class IKEffector
	{
		public Transform bone;

		public Transform target;

		[Range(0f, 1f)]
		public float positionWeight;

		[Range(0f, 1f)]
		public float rotationWeight;

		public Vector3 position = Vector3.zero;

		public Quaternion rotation = Quaternion.identity;

		public Vector3 positionOffset;

		public bool effectChildNodes = true;

		[Range(0f, 1f)]
		public float maintainRelativePositionWeight;

		public Transform[] childBones = new Transform[0];

		public Transform planeBone1;

		public Transform planeBone2;

		public Transform planeBone3;

		public Quaternion planeRotationOffset = Quaternion.identity;

		private float posW;

		private float rotW;

		private Vector3[] localPositions = new Vector3[0];

		private bool usePlaneNodes;

		private Quaternion animatedPlaneRotation = Quaternion.identity;

		private Vector3 animatedPosition;

		private bool firstUpdate;

		private int chainIndex = -1;

		private int nodeIndex = -1;

		private int plane1ChainIndex;

		private int plane1NodeIndex = -1;

		private int plane2ChainIndex = -1;

		private int plane2NodeIndex = -1;

		private int plane3ChainIndex = -1;

		private int plane3NodeIndex = -1;

		private int[] childChainIndexes = new int[0];

		private int[] childNodeIndexes = new int[0];

		public bool isEndEffector { get; private set; }

		public IKSolver.Node GetNode(IKSolverFullBody solver)
		{
			return solver.chain[chainIndex].nodes[nodeIndex];
		}

		public void PinToBone(float positionWeight, float rotationWeight)
		{
			position = bone.position;
			this.positionWeight = Mathf.Clamp(positionWeight, 0f, 1f);
			rotation = bone.rotation;
			this.rotationWeight = Mathf.Clamp(rotationWeight, 0f, 1f);
		}

		public IKEffector()
		{
		}

		public IKEffector(Transform bone, Transform[] childBones)
		{
			this.bone = bone;
			this.childBones = childBones;
		}

		public bool IsValid(IKSolver solver, ref string message)
		{
			if (bone == null)
			{
				message = "IK Effector bone is null.";
				return false;
			}
			if (solver.GetPoint(bone) == null)
			{
				message = "IK Effector is referencing to a bone '" + bone.name + "' that does not excist in the Node Chain.";
				return false;
			}
			Transform[] array = childBones;
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i] == null)
				{
					message = "IK Effector contains a null reference.";
					return false;
				}
			}
			array = childBones;
			foreach (Transform transform in array)
			{
				if (solver.GetPoint(transform) == null)
				{
					message = "IK Effector is referencing to a bone '" + transform.name + "' that does not excist in the Node Chain.";
					return false;
				}
			}
			if (planeBone1 != null && solver.GetPoint(planeBone1) == null)
			{
				message = "IK Effector is referencing to a bone '" + planeBone1.name + "' that does not excist in the Node Chain.";
				return false;
			}
			if (planeBone2 != null && solver.GetPoint(planeBone2) == null)
			{
				message = "IK Effector is referencing to a bone '" + planeBone2.name + "' that does not excist in the Node Chain.";
				return false;
			}
			if (planeBone3 != null && solver.GetPoint(planeBone3) == null)
			{
				message = "IK Effector is referencing to a bone '" + planeBone3.name + "' that does not excist in the Node Chain.";
				return false;
			}
			return true;
		}

		public void Initiate(IKSolverFullBody solver)
		{
			position = bone.position;
			rotation = bone.rotation;
			animatedPlaneRotation = Quaternion.identity;
			solver.GetChainAndNodeIndexes(bone, out chainIndex, out nodeIndex);
			childChainIndexes = new int[childBones.Length];
			childNodeIndexes = new int[childBones.Length];
			for (int i = 0; i < childBones.Length; i++)
			{
				solver.GetChainAndNodeIndexes(childBones[i], out childChainIndexes[i], out childNodeIndexes[i]);
			}
			localPositions = new Vector3[childBones.Length];
			usePlaneNodes = false;
			if (planeBone1 != null)
			{
				solver.GetChainAndNodeIndexes(planeBone1, out plane1ChainIndex, out plane1NodeIndex);
				if (planeBone2 != null)
				{
					solver.GetChainAndNodeIndexes(planeBone2, out plane2ChainIndex, out plane2NodeIndex);
					if (planeBone3 != null)
					{
						solver.GetChainAndNodeIndexes(planeBone3, out plane3ChainIndex, out plane3NodeIndex);
						usePlaneNodes = true;
					}
				}
				isEndEffector = true;
			}
			else
			{
				isEndEffector = false;
			}
		}

		public void ResetOffset(IKSolverFullBody solver)
		{
			solver.GetNode(chainIndex, nodeIndex).offset = Vector3.zero;
			for (int i = 0; i < childChainIndexes.Length; i++)
			{
				solver.GetNode(childChainIndexes[i], childNodeIndexes[i]).offset = Vector3.zero;
			}
		}

		public void SetToTarget()
		{
			if (!(target == null))
			{
				position = target.position;
				rotation = target.rotation;
			}
		}

		public void OnPreSolve(IKSolverFullBody solver)
		{
			positionWeight = Mathf.Clamp(positionWeight, 0f, 1f);
			rotationWeight = Mathf.Clamp(rotationWeight, 0f, 1f);
			maintainRelativePositionWeight = Mathf.Clamp(maintainRelativePositionWeight, 0f, 1f);
			posW = positionWeight * solver.IKPositionWeight;
			rotW = rotationWeight * solver.IKPositionWeight;
			solver.GetNode(chainIndex, nodeIndex).effectorPositionWeight = posW;
			solver.GetNode(chainIndex, nodeIndex).effectorRotationWeight = rotW;
			solver.GetNode(chainIndex, nodeIndex).solverRotation = rotation;
			if (float.IsInfinity(positionOffset.x) || float.IsInfinity(positionOffset.y) || float.IsInfinity(positionOffset.z))
			{
				UnityEngine.Debug.LogError("Invalid IKEffector.positionOffset (contains Infinity)! Please make sure not to set IKEffector.positionOffset to infinite values.", bone);
			}
			if (float.IsNaN(positionOffset.x) || float.IsNaN(positionOffset.y) || float.IsNaN(positionOffset.z))
			{
				UnityEngine.Debug.LogError("Invalid IKEffector.positionOffset (contains NaN)! Please make sure not to set IKEffector.positionOffset to NaN values.", bone);
			}
			if (positionOffset.sqrMagnitude > 1E+10f)
			{
				UnityEngine.Debug.LogError("Additive effector positionOffset detected in Full Body IK (extremely large value). Make sure you are not circularily adding to effector positionOffset each frame.", bone);
			}
			if (float.IsInfinity(position.x) || float.IsInfinity(position.y) || float.IsInfinity(position.z))
			{
				UnityEngine.Debug.LogError("Invalid IKEffector.position (contains Infinity)!");
			}
			solver.GetNode(chainIndex, nodeIndex).offset += positionOffset * solver.IKPositionWeight;
			if (effectChildNodes && solver.iterations > 0)
			{
				for (int i = 0; i < childBones.Length; i++)
				{
					localPositions[i] = childBones[i].transform.position - bone.transform.position;
					solver.GetNode(childChainIndexes[i], childNodeIndexes[i]).offset += positionOffset * solver.IKPositionWeight;
				}
			}
			if (usePlaneNodes && maintainRelativePositionWeight > 0f)
			{
				animatedPlaneRotation = Quaternion.LookRotation(planeBone2.position - planeBone1.position, planeBone3.position - planeBone1.position);
			}
			firstUpdate = true;
		}

		public void OnPostWrite()
		{
			positionOffset = Vector3.zero;
		}

		private Quaternion GetPlaneRotation(IKSolverFullBody solver)
		{
			Vector3 solverPosition = solver.GetNode(plane1ChainIndex, plane1NodeIndex).solverPosition;
			Vector3 solverPosition2 = solver.GetNode(plane2ChainIndex, plane2NodeIndex).solverPosition;
			Vector3 solverPosition3 = solver.GetNode(plane3ChainIndex, plane3NodeIndex).solverPosition;
			Vector3 vector = solverPosition2 - solverPosition;
			Vector3 upwards = solverPosition3 - solverPosition;
			if (vector == Vector3.zero)
			{
				Warning.Log("Make sure you are not placing 2 or more FBBIK effectors of the same chain to exactly the same position.", bone);
				return Quaternion.identity;
			}
			return Quaternion.LookRotation(vector, upwards);
		}

		public void Update(IKSolverFullBody solver)
		{
			if (firstUpdate)
			{
				animatedPosition = bone.position + solver.GetNode(chainIndex, nodeIndex).offset;
				firstUpdate = false;
			}
			solver.GetNode(chainIndex, nodeIndex).solverPosition = Vector3.Lerp(GetPosition(solver, out planeRotationOffset), position, posW);
			if (effectChildNodes)
			{
				for (int i = 0; i < childBones.Length; i++)
				{
					solver.GetNode(childChainIndexes[i], childNodeIndexes[i]).solverPosition = Vector3.Lerp(solver.GetNode(childChainIndexes[i], childNodeIndexes[i]).solverPosition, solver.GetNode(chainIndex, nodeIndex).solverPosition + localPositions[i], posW);
				}
			}
		}

		private Vector3 GetPosition(IKSolverFullBody solver, out Quaternion planeRotationOffset)
		{
			planeRotationOffset = Quaternion.identity;
			if (!isEndEffector)
			{
				return solver.GetNode(chainIndex, nodeIndex).solverPosition;
			}
			if (maintainRelativePositionWeight <= 0f)
			{
				return animatedPosition;
			}
			Vector3 vector = bone.position;
			Vector3 vector2 = vector - planeBone1.position;
			planeRotationOffset = GetPlaneRotation(solver) * Quaternion.Inverse(animatedPlaneRotation);
			vector = solver.GetNode(plane1ChainIndex, plane1NodeIndex).solverPosition + planeRotationOffset * vector2;
			planeRotationOffset = Quaternion.Lerp(Quaternion.identity, planeRotationOffset, maintainRelativePositionWeight);
			return Vector3.Lerp(animatedPosition, vector + solver.GetNode(chainIndex, nodeIndex).offset, maintainRelativePositionWeight);
		}
	}
	[Serializable]
	public class IKMapping
	{
		[Serializable]
		public class BoneMap
		{
			public Transform transform;

			public int chainIndex = -1;

			public int nodeIndex = -1;

			public Vector3 defaultLocalPosition;

			public Quaternion defaultLocalRotation;

			public Vector3 localSwingAxis;

			public Vector3 localTwistAxis;

			public Vector3 planePosition;

			public Vector3 ikPosition;

			public Quaternion defaultLocalTargetRotation;

			private Quaternion maintainRotation;

			public float length;

			public Quaternion animatedRotation;

			private Transform planeBone1;

			private Transform planeBone2;

			private Transform planeBone3;

			private int plane1ChainIndex = -1;

			private int plane1NodeIndex = -1;

			private int plane2ChainIndex = -1;

			private int plane2NodeIndex = -1;

			private int plane3ChainIndex = -1;

			private int plane3NodeIndex = -1;

			public Vector3 swingDirection => transform.rotation * localSwingAxis;

			public bool isNodeBone => nodeIndex != -1;

			private Quaternion lastAnimatedTargetRotation
			{
				get
				{
					if (planeBone1.position == planeBone3.position)
					{
						return Quaternion.identity;
					}
					return Quaternion.LookRotation(planeBone2.position - planeBone1.position, planeBone3.position - planeBone1.position);
				}
			}

			public void Initiate(Transform transform, IKSolverFullBody solver)
			{
				this.transform = transform;
				solver.GetChainAndNodeIndexes(transform, out chainIndex, out nodeIndex);
			}

			public void StoreDefaultLocalState()
			{
				defaultLocalPosition = transform.localPosition;
				defaultLocalRotation = transform.localRotation;
			}

			public void FixTransform(bool position)
			{
				if (position)
				{
					transform.localPosition = defaultLocalPosition;
				}
				transform.localRotation = defaultLocalRotation;
			}

			public void SetLength(BoneMap nextBone)
			{
				length = Vector3.Distance(transform.position, nextBone.transform.position);
			}

			public void SetLocalSwingAxis(BoneMap swingTarget)
			{
				SetLocalSwingAxis(swingTarget, this);
			}

			public void SetLocalSwingAxis(BoneMap bone1, BoneMap bone2)
			{
				localSwingAxis = Quaternion.Inverse(transform.rotation) * (bone1.transform.position - bone2.transform.position);
			}

			public void SetLocalTwistAxis(Vector3 twistDirection, Vector3 normalDirection)
			{
				Vector3.OrthoNormalize(ref normalDirection, ref twistDirection);
				localTwistAxis = Quaternion.Inverse(transform.rotation) * twistDirection;
			}

			public void SetPlane(IKSolverFullBody solver, Transform planeBone1, Transform planeBone2, Transform planeBone3)
			{
				this.planeBone1 = planeBone1;
				this.planeBone2 = planeBone2;
				this.planeBone3 = planeBone3;
				solver.GetChainAndNodeIndexes(planeBone1, out plane1ChainIndex, out plane1NodeIndex);
				solver.GetChainAndNodeIndexes(planeBone2, out plane2ChainIndex, out plane2NodeIndex);
				solver.GetChainAndNodeIndexes(planeBone3, out plane3ChainIndex, out plane3NodeIndex);
				UpdatePlane(rotation: true, position: true);
			}

			public void UpdatePlane(bool rotation, bool position)
			{
				Quaternion rotation2 = lastAnimatedTargetRotation;
				if (rotation)
				{
					defaultLocalTargetRotation = QuaTools.RotationToLocalSpace(transform.rotation, rotation2);
				}
				if (position)
				{
					planePosition = Quaternion.Inverse(rotation2) * (transform.position - planeBone1.position);
				}
			}

			public void SetIKPosition()
			{
				ikPosition = transform.position;
			}

			public void MaintainRotation()
			{
				maintainRotation = transform.rotation;
			}

			public void SetToIKPosition()
			{
				transform.position = ikPosition;
			}

			public void FixToNode(IKSolverFullBody solver, float weight, IKSolver.Node fixNode = null)
			{
				if (fixNode == null)
				{
					fixNode = solver.GetNode(chainIndex, nodeIndex);
				}
				if (weight >= 1f)
				{
					transform.position = fixNode.solverPosition;
				}
				else
				{
					transform.position = Vector3.Lerp(transform.position, fixNode.solverPosition, weight);
				}
			}

			public Vector3 GetPlanePosition(IKSolverFullBody solver)
			{
				return solver.GetNode(plane1ChainIndex, plane1NodeIndex).solverPosition + GetTargetRotation(solver) * planePosition;
			}

			public void PositionToPlane(IKSolverFullBody solver)
			{
				transform.position = GetPlanePosition(solver);
			}

			public void RotateToPlane(IKSolverFullBody solver, float weight)
			{
				Quaternion quaternion = GetTargetRotation(solver) * defaultLocalTargetRotation;
				if (weight >= 1f)
				{
					transform.rotation = quaternion;
				}
				else
				{
					transform.rotation = Quaternion.Lerp(transform.rotation, quaternion, weight);
				}
			}

			public void Swing(Vector3 swingTarget, float weight)
			{
				Swing(swingTarget, transform.position, weight);
			}

			public void Swing(Vector3 pos1, Vector3 pos2, float weight)
			{
				Quaternion quaternion = Quaternion.FromToRotation(transform.rotation * localSwingAxis, pos1 - pos2) * transform.rotation;
				if (weight >= 1f)
				{
					transform.rotation = quaternion;
				}
				else
				{
					transform.rotation = Quaternion.Lerp(transform.rotation, quaternion, weight);
				}
			}

			public void Twist(Vector3 twistDirection, Vector3 normalDirection, float weight)
			{
				Vector3.OrthoNormalize(ref normalDirection, ref twistDirection);
				Quaternion quaternion = Quaternion.FromToRotation(transform.rotation * localTwistAxis, twistDirection) * transform.rotation;
				if (weight >= 1f)
				{
					transform.rotation = quaternion;
				}
				else
				{
					transform.rotation = Quaternion.Lerp(transform.rotation, quaternion, weight);
				}
			}

			public void RotateToMaintain(float weight)
			{
				if (!(weight <= 0f))
				{
					transform.rotation = Quaternion.Lerp(transform.rotation, maintainRotation, weight);
				}
			}

			public void RotateToEffector(IKSolverFullBody solver, float weight)
			{
				if (!isNodeBone)
				{
					return;
				}
				float num = weight * solver.GetNode(chainIndex, nodeIndex).effectorRotationWeight;
				if (!(num <= 0f))
				{
					if (num >= 1f)
					{
						transform.rotation = solver.GetNode(chainIndex, nodeIndex).solverRotation;
					}
					else
					{
						transform.rotation = Quaternion.Lerp(transform.rotation, solver.GetNode(chainIndex, nodeIndex).solverRotation, num);
					}
				}
			}

			private Quaternion GetTargetRotation(IKSolverFullBody solver)
			{
				Vector3 solverPosition = solver.GetNode(plane1ChainIndex, plane1NodeIndex).solverPosition;
				Vector3 solverPosition2 = solver.GetNode(plane2ChainIndex, plane2NodeIndex).solverPosition;
				Vector3 solverPosition3 = solver.GetNode(plane3ChainIndex, plane3NodeIndex).solverPosition;
				if (solverPosition == solverPosition3)
				{
					return Quaternion.identity;
				}
				return Quaternion.LookRotation(solverPosition2 - solverPosition, solverPosition3 - solverPosition);
			}
		}

		public virtual bool IsValid(IKSolver solver, ref string message)
		{
			return true;
		}

		public virtual void Initiate(IKSolverFullBody solver)
		{
		}

		protected bool BoneIsValid(Transform bone, IKSolver solver, ref string message, Warning.Logger logger = null)
		{
			if (bone == null)
			{
				message = "IKMappingLimb contains a null reference.";
				logger?.Invoke(message);
				return false;
			}
			if (solver.GetPoint(bone) == null)
			{
				message = "IKMappingLimb is referencing to a bone '" + bone.name + "' that does not excist in the Node Chain.";
				logger?.Invoke(message);
				return false;
			}
			return true;
		}

		protected Vector3 SolveFABRIKJoint(Vector3 pos1, Vector3 pos2, float length)
		{
			return pos2 + (pos1 - pos2).normalized * length;
		}
	}
	[Serializable]
	public class IKMappingBone : IKMapping
	{
		public Transform bone;

		[Range(0f, 1f)]
		public float maintainRotationWeight = 1f;

		private BoneMap boneMap = new BoneMap();

		public override bool IsValid(IKSolver solver, ref string message)
		{
			if (!base.IsValid(solver, ref message))
			{
				return false;
			}
			if (bone == null)
			{
				message = "IKMappingBone's bone is null.";
				return false;
			}
			return true;
		}

		public IKMappingBone()
		{
		}

		public IKMappingBone(Transform bone)
		{
			this.bone = bone;
		}

		public void StoreDefaultLocalState()
		{
			boneMap.StoreDefaultLocalState();
		}

		public void FixTransforms()
		{
			boneMap.FixTransform(position: false);
		}

		public override void Initiate(IKSolverFullBody solver)
		{
			if (boneMap == null)
			{
				boneMap = new BoneMap();
			}
			boneMap.Initiate(bone, solver);
		}

		public void ReadPose()
		{
			boneMap.MaintainRotation();
		}

		public void WritePose(float solverWeight)
		{
			boneMap.RotateToMaintain(solverWeight * maintainRotationWeight);
		}
	}
	[Serializable]
	public class IKMappingLimb : IKMapping
	{
		[Serializable]
		public enum BoneMapType
		{
			Parent,
			Bone1,
			Bone2,
			Bone3
		}

		public Transform parentBone;

		public Transform bone1;

		public Transform bone2;

		public Transform bone3;

		[Range(0f, 1f)]
		public float maintainRotationWeight;

		[Range(0f, 1f)]
		public float weight = 1f;

		private BoneMap boneMapParent = new BoneMap();

		private BoneMap boneMap1 = new BoneMap();

		private BoneMap boneMap2 = new BoneMap();

		private BoneMap boneMap3 = new BoneMap();

		public override bool IsValid(IKSolver solver, ref string message)
		{
			if (!base.IsValid(solver, ref message))
			{
				return false;
			}
			if (!BoneIsValid(bone1, solver, ref message))
			{
				return false;
			}
			if (!BoneIsValid(bone2, solver, ref message))
			{
				return false;
			}
			if (!BoneIsValid(bone3, solver, ref message))
			{
				return false;
			}
			return true;
		}

		public BoneMap GetBoneMap(BoneMapType boneMap)
		{
			switch (boneMap)
			{
			case BoneMapType.Parent:
				if (parentBone == null)
				{
					Warning.Log("This limb does not have a parent (shoulder) bone", bone1);
				}
				return boneMapParent;
			case BoneMapType.Bone1:
				return boneMap1;
			case BoneMapType.Bone2:
				return boneMap2;
			default:
				return boneMap3;
			}
		}

		public void SetLimbOrientation(Vector3 upper, Vector3 lower)
		{
			boneMap1.defaultLocalTargetRotation = Quaternion.Inverse(Quaternion.Inverse(bone1.rotation) * Quaternion.LookRotation(bone2.position - bone1.position, bone1.rotation * -upper));
			boneMap2.defaultLocalTargetRotation = Quaternion.Inverse(Quaternion.Inverse(bone2.rotation) * Quaternion.LookRotation(bone3.position - bone2.position, bone2.rotation * -lower));
		}

		public IKMappingLimb()
		{
		}

		public IKMappingLimb(Transform bone1, Transform bone2, Transform bone3, Transform parentBone = null)
		{
			SetBones(bone1, bone2, bone3, parentBone);
		}

		public void SetBones(Transform bone1, Transform bone2, Transform bone3, Transform parentBone = null)
		{
			this.bone1 = bone1;
			this.bone2 = bone2;
			this.bone3 = bone3;
			this.parentBone = parentBone;
		}

		public void StoreDefaultLocalState()
		{
			if (parentBone != null)
			{
				boneMapParent.StoreDefaultLocalState();
			}
			boneMap1.StoreDefaultLocalState();
			boneMap2.StoreDefaultLocalState();
			boneMap3.StoreDefaultLocalState();
		}

		public void FixTransforms()
		{
			if (parentBone != null)
			{
				boneMapParent.FixTransform(position: false);
			}
			boneMap1.FixTransform(position: true);
			boneMap2.FixTransform(position: false);
			boneMap3.FixTransform(position: false);
		}

		public override void Initiate(IKSolverFullBody solver)
		{
			if (boneMapParent == null)
			{
				boneMapParent = new BoneMap();
			}
			if (boneMap1 == null)
			{
				boneMap1 = new BoneMap();
			}
			if (boneMap2 == null)
			{
				boneMap2 = new BoneMap();
			}
			if (boneMap3 == null)
			{
				boneMap3 = new BoneMap();
			}
			if (parentBone != null)
			{
				boneMapParent.Initiate(parentBone, solver);
			}
			boneMap1.Initiate(bone1, solver);
			boneMap2.Initiate(bone2, solver);
			boneMap3.Initiate(bone3, solver);
			boneMap1.SetPlane(solver, boneMap1.transform, boneMap2.transform, boneMap3.transform);
			boneMap2.SetPlane(solver, boneMap2.transform, boneMap3.transform, boneMap1.transform);
			if (parentBone != null)
			{
				boneMapParent.SetLocalSwingAxis(boneMap1);
			}
		}

		public void ReadPose()
		{
			boneMap1.UpdatePlane(rotation: true, position: true);
			boneMap2.UpdatePlane(rotation: true, position: false);
			weight = Mathf.Clamp(weight, 0f, 1f);
			boneMap3.MaintainRotation();
		}

		public void WritePose(IKSolverFullBody solver, bool fullBody)
		{
			if (weight <= 0f)
			{
				return;
			}
			if (fullBody)
			{
				if (parentBone != null)
				{
					boneMapParent.Swing(solver.GetNode(boneMap1.chainIndex, boneMap1.nodeIndex).solverPosition, weight);
				}
				boneMap1.FixToNode(solver, weight);
			}
			boneMap1.RotateToPlane(solver, weight);
			boneMap2.RotateToPlane(solver, weight);
			boneMap3.RotateToMaintain(maintainRotationWeight * weight * solver.IKPositionWeight);
			boneMap3.RotateToEffector(solver, weight);
		}
	}
	[Serializable]
	public class IKMappingSpine : IKMapping
	{
		public Transform[] spineBones;

		public Transform leftUpperArmBone;

		public Transform rightUpperArmBone;

		public Transform leftThighBone;

		public Transform rightThighBone;

		[Range(1f, 3f)]
		public int iterations = 3;

		[Range(0f, 1f)]
		public float twistWeight = 1f;

		private int rootNodeIndex;

		private BoneMap[] spine = new BoneMap[0];

		private BoneMap leftUpperArm = new BoneMap();

		private BoneMap rightUpperArm = new BoneMap();

		private BoneMap leftThigh = new BoneMap();

		private BoneMap rightThigh = new BoneMap();

		private bool useFABRIK;

		public override bool IsValid(IKSolver solver, ref string message)
		{
			if (!base.IsValid(solver, ref message))
			{
				return false;
			}
			Transform[] array = spineBones;
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i] == null)
				{
					message = "Spine bones contains a null reference.";
					return false;
				}
			}
			int num = 0;
			for (int j = 0; j < spineBones.Length; j++)
			{
				if (solver.GetPoint(spineBones[j]) != null)
				{
					num++;
				}
			}
			if (num == 0)
			{
				message = "IKMappingSpine does not contain any nodes.";
				return false;
			}
			if (leftUpperArmBone == null)
			{
				message = "IKMappingSpine is missing the left upper arm bone.";
				return false;
			}
			if (rightUpperArmBone == null)
			{
				message = "IKMappingSpine is missing the right upper arm bone.";
				return false;
			}
			if (leftThighBone == null)
			{
				message = "IKMappingSpine is missing the left thigh bone.";
				return false;
			}
			if (rightThighBone == null)
			{
				message = "IKMappingSpine is missing the right thigh bone.";
				return false;
			}
			if (solver.GetPoint(leftUpperArmBone) == null)
			{
				message = "Full Body IK is missing the left upper arm node.";
				return false;
			}
			if (solver.GetPoint(rightUpperArmBone) == null)
			{
				message = "Full Body IK is missing the right upper arm node.";
				return false;
			}
			if (solver.GetPoint(leftThighBone) == null)
			{
				message = "Full Body IK is missing the left thigh node.";
				return false;
			}
			if (solver.GetPoint(rightThighBone) == null)
			{
				message = "Full Body IK is missing the right thigh node.";
				return false;
			}
			return true;
		}

		public IKMappingSpine()
		{
		}

		public IKMappingSpine(Transform[] spineBones, Transform leftUpperArmBone, Transform rightUpperArmBone, Transform leftThighBone, Transform rightThighBone)
		{
			SetBones(spineBones, leftUpperArmBone, rightUpperArmBone, leftThighBone, rightThighBone);
		}

		public void SetBones(Transform[] spineBones, Transform leftUpperArmBone, Transform rightUpperArmBone, Transform leftThighBone, Transform rightThighBone)
		{
			this.spineBones = spineBones;
			this.leftUpperArmBone = leftUpperArmBone;
			this.rightUpperArmBone = rightUpperArmBone;
			this.leftThighBone = leftThighBone;
			this.rightThighBone = rightThighBone;
		}

		public void StoreDefaultLocalState()
		{
			for (int i = 0; i < spine.Length; i++)
			{
				spine[i].StoreDefaultLocalState();
			}
		}

		public void FixTransforms()
		{
			for (int i = 0; i < spine.Length; i++)
			{
				spine[i].FixTransform(i == 0 || i == spine.Length - 1);
			}
		}

		public override void Initiate(IKSolverFullBody solver)
		{
			if (iterations <= 0)
			{
				iterations = 3;
			}
			if (spine == null || spine.Length != spineBones.Length)
			{
				spine = new BoneMap[spineBones.Length];
			}
			rootNodeIndex = -1;
			for (int i = 0; i < spineBones.Length; i++)
			{
				if (spine[i] == null)
				{
					spine[i] = new BoneMap();
				}
				spine[i].Initiate(spineBones[i], solver);
				if (spine[i].isNodeBone)
				{
					rootNodeIndex = i;
				}
			}
			if (leftUpperArm == null)
			{
				leftUpperArm = new BoneMap();
			}
			if (rightUpperArm == null)
			{
				rightUpperArm = new BoneMap();
			}
			if (leftThigh == null)
			{
				leftThigh = new BoneMap();
			}
			if (rightThigh == null)
			{
				rightThigh = new BoneMap();
			}
			leftUpperArm.Initiate(leftUpperArmBone, solver);
			rightUpperArm.Initiate(rightUpperArmBone, solver);
			leftThigh.Initiate(leftThighBone, solver);
			rightThigh.Initiate(rightThighBone, solver);
			for (int j = 0; j < spine.Length; j++)
			{
				spine[j].SetIKPosition();
			}
			spine[0].SetPlane(solver, spine[rootNodeIndex].transform, leftThigh.transform, rightThigh.transform);
			for (int k = 0; k < spine.Length - 1; k++)
			{
				spine[k].SetLength(spine[k + 1]);
				spine[k].SetLocalSwingAxis(spine[k + 1]);
				spine[k].SetLocalTwistAxis(leftUpperArm.transform.position - rightUpperArm.transform.position, spine[k + 1].transform.position - spine[k].transform.position);
			}
			spine[spine.Length - 1].SetPlane(solver, spine[rootNodeIndex].transform, leftUpperArm.transform, rightUpperArm.transform);
			spine[spine.Length - 1].SetLocalSwingAxis(leftUpperArm, rightUpperArm);
			useFABRIK = UseFABRIK();
		}

		private bool UseFABRIK()
		{
			if (spine.Length > 3)
			{
				return true;
			}
			if (rootNodeIndex != 1)
			{
				return true;
			}
			return false;
		}

		public void ReadPose()
		{
			spine[0].UpdatePlane(rotation: true, position: true);
			for (int i = 0; i < spine.Length - 1; i++)
			{
				spine[i].SetLength(spine[i + 1]);
				spine[i].SetLocalSwingAxis(spine[i + 1]);
				spine[i].SetLocalTwistAxis(leftUpperArm.transform.position - rightUpperArm.transform.position, spine[i + 1].transform.position - spine[i].transform.position);
			}
			spine[spine.Length - 1].UpdatePlane(rotation: true, position: true);
			spine[spine.Length - 1].SetLocalSwingAxis(leftUpperArm, rightUpperArm);
		}

		public void WritePose(IKSolverFullBody solver)
		{
			Vector3 planePosition = spine[0].GetPlanePosition(solver);
			Vector3 solverPosition = solver.GetNode(spine[rootNodeIndex].chainIndex, spine[rootNodeIndex].nodeIndex).solverPosition;
			Vector3 planePosition2 = spine[spine.Length - 1].GetPlanePosition(solver);
			if (useFABRIK)
			{
				Vector3 vector = solver.GetNode(spine[rootNodeIndex].chainIndex, spine[rootNodeIndex].nodeIndex).solverPosition - spine[rootNodeIndex].transform.position;
				for (int i = 0; i < spine.Length; i++)
				{
					spine[i].ikPosition = spine[i].transform.position + vector;
				}
				for (int j = 0; j < iterations; j++)
				{
					ForwardReach(planePosition2);
					BackwardReach(planePosition);
					spine[rootNodeIndex].ikPosition = solverPosition;
				}
			}
			else
			{
				spine[0].ikPosition = planePosition;
				spine[rootNodeIndex].ikPosition = solverPosition;
			}
			spine[spine.Length - 1].ikPosition = planePosition2;
			MapToSolverPositions(solver);
		}

		public void ForwardReach(Vector3 position)
		{
			spine[spineBones.Length - 1].ikPosition = position;
			for (int num = spine.Length - 2; num > -1; num--)
			{
				spine[num].ikPosition = SolveFABRIKJoint(spine[num].ikPosition, spine[num + 1].ikPosition, spine[num].length);
			}
		}

		private void BackwardReach(Vector3 position)
		{
			spine[0].ikPosition = position;
			for (int i = 1; i < spine.Length; i++)
			{
				spine[i].ikPosition = SolveFABRIKJoint(spine[i].ikPosition, spine[i - 1].ikPosition, spine[i - 1].length);
			}
		}

		private void MapToSolverPositions(IKSolverFullBody solver)
		{
			spine[0].SetToIKPosition();
			spine[0].RotateToPlane(solver, 1f);
			for (int i = 1; i < spine.Length - 1; i++)
			{
				spine[i].Swing(spine[i + 1].ikPosition, 1f);
				if (twistWeight > 0f)
				{
					float num = (float)i / ((float)spine.Length - 2f);
					Vector3 solverPosition = solver.GetNode(leftUpperArm.chainIndex, leftUpperArm.nodeIndex).solverPosition;
					Vector3 solverPosition2 = solver.GetNode(rightUpperArm.chainIndex, rightUpperArm.nodeIndex).solverPosition;
					spine[i].Twist(solverPosition - solverPosition2, spine[i + 1].ikPosition - spine[i].transform.position, num * twistWeight);
				}
			}
			spine[spine.Length - 1].SetToIKPosition();
			spine[spine.Length - 1].RotateToPlane(solver, 1f);
		}
	}
	[Serializable]
	public abstract class IKSolver
	{
		[Serializable]
		public class Point
		{
			public Transform transform;

			[Range(0f, 1f)]
			public float weight = 1f;

			public Vector3 solverPosition;

			public Quaternion solverRotation = Quaternion.identity;

			public Vector3 defaultLocalPosition;

			public Quaternion defaultLocalRotation;

			public void StoreDefaultLocalState()
			{
				defaultLocalPosition = transform.localPosition;
				defaultLocalRotation = transform.localRotation;
			}

			public void FixTransform()
			{
				if (transform.localPosition != defaultLocalPosition)
				{
					transform.localPosition = defaultLocalPosition;
				}
				if (transform.localRotation != defaultLocalRotation)
				{
					transform.localRotation = defaultLocalRotation;
				}
			}

			public void UpdateSolverPosition()
			{
				solverPosition = transform.position;
			}

			public void UpdateSolverLocalPosition()
			{
				solverPosition = transform.localPosition;
			}

			public void UpdateSolverState()
			{
				solverPosition = transform.position;
				solverRotation = transform.rotation;
			}

			public void UpdateSolverLocalState()
			{
				solverPosition = transform.localPosition;
				solverRotation = transform.localRotation;
			}
		}

		[Serializable]
		public class Bone : Point
		{
			public float length;

			public float sqrMag;

			public Vector3 axis = -Vector3.right;

			private RotationLimit _rotationLimit;

			private bool isLimited = true;

			public RotationLimit rotationLimit
			{
				get
				{
					if (!isLimited)
					{
						return null;
					}
					if (_rotationLimit == null)
					{
						_rotationLimit = transform.GetComponent<RotationLimit>();
					}
					isLimited = _rotationLimit != null;
					return _rotationLimit;
				}
				set
				{
					_rotationLimit = value;
					isLimited = value != null;
				}
			}

			public void Swing(Vector3 swingTarget, float weight = 1f)
			{
				if (!(weight <= 0f))
				{
					Quaternion quaternion = Quaternion.FromToRotation(transform.rotation * axis, swingTarget - transform.position);
					if (weight >= 1f)
					{
						transform.rotation = quaternion * transform.rotation;
					}
					else
					{
						transform.rotation = Quaternion.Lerp(Quaternion.identity, quaternion, weight) * transform.rotation;
					}
				}
			}

			public static void SolverSwing(Bone[] bones, int index, Vector3 swingTarget, float weight = 1f)
			{
				if (weight <= 0f)
				{
					return;
				}
				Quaternion quaternion = Quaternion.FromToRotation(bones[index].solverRotation * bones[index].axis, swingTarget - bones[index].solverPosition);
				if (weight >= 1f)
				{
					for (int i = index; i < bones.Length; i++)
					{
						bones[i].solverRotation = quaternion * bones[i].solverRotation;
					}
				}
				else
				{
					for (int j = index; j < bones.Length; j++)
					{
						bones[j].solverRotation = Quaternion.Lerp(Quaternion.identity, quaternion, weight) * bones[j].solverRotation;
					}
				}
			}

			public void Swing2D(Vector3 swingTarget, float weight = 1f)
			{
				if (!(weight <= 0f))
				{
					Vector3 vector = transform.rotation * axis;
					Vector3 vector2 = swingTarget - transform.position;
					float current = Mathf.Atan2(vector.x, vector.y) * 57.29578f;
					float target = Mathf.Atan2(vector2.x, vector2.y) * 57.29578f;
					transform.rotation = Quaternion.AngleAxis(Mathf.DeltaAngle(current, target) * weight, Vector3.back) * transform.rotation;
				}
			}

			public void SetToSolverPosition()
			{
				transform.position = solverPosition;
			}

			public Bone()
			{
			}

			public Bone(Transform transform)
			{
				base.transform = transform;
			}

			public Bone(Transform transform, float weight)
			{
				base.transform = transform;
				base.weight = weight;
			}
		}

		[Serializable]
		public class Node : Point
		{
			public float length;

			public float effectorPositionWeight;

			public float effectorRotationWeight;

			public Vector3 offset;

			public Node()
			{
			}

			public Node(Transform transform)
			{
				base.transform = transform;
			}

			public Node(Transform transform, float weight)
			{
				base.transform = transform;
				base.weight = weight;
			}
		}

		public delegate void UpdateDelegate();

		public delegate void IterationDelegate(int i);

		[HideInInspector]
		public Vector3 IKPosition;

		[Tooltip("The positional or the master weight of the solver.")]
		[Range(0f, 1f)]
		public float IKPositionWeight = 1f;

		public UpdateDelegate OnPreInitiate;

		public UpdateDelegate OnPostInitiate;

		public UpdateDelegate OnPreUpdate;

		public UpdateDelegate OnPostUpdate;

		protected bool firstInitiation = true;

		[SerializeField]
		[HideInInspector]
		protected Transform root;

		public bool initiated { get; private set; }

		public bool IsValid()
		{
			string message = string.Empty;
			return IsValid(ref message);
		}

		public abstract bool IsValid(ref string message);

		public void Initiate(Transform root)
		{
			if (OnPreInitiate != null)
			{
				OnPreInitiate();
			}
			if (root == null)
			{
				UnityEngine.Debug.LogError("Initiating IKSolver with null root Transform.");
			}
			this.root = root;
			initiated = false;
			string message = string.Empty;
			if (!IsValid(ref message))
			{
				Warning.Log(message, root);
				return;
			}
			OnInitiate();
			StoreDefaultLocalState();
			initiated = true;
			firstInitiation = false;
			if (OnPostInitiate != null)
			{
				OnPostInitiate();
			}
		}

		public void Update()
		{
			if (OnPreUpdate != null)
			{
				OnPreUpdate();
			}
			if (firstInitiation)
			{
				Initiate(root);
			}
			if (initiated)
			{
				OnUpdate();
				if (OnPostUpdate != null)
				{
					OnPostUpdate();
				}
			}
		}

		public virtual Vector3 GetIKPosition()
		{
			return IKPosition;
		}

		public void SetIKPosition(Vector3 position)
		{
			IKPosition = position;
		}

		public float GetIKPositionWeight()
		{
			return IKPositionWeight;
		}

		public void SetIKPositionWeight(float weight)
		{
			IKPositionWeight = Mathf.Clamp(weight, 0f, 1f);
		}

		public Transform GetRoot()
		{
			return root;
		}

		public abstract Point[] GetPoints();

		public abstract Point GetPoint(Transform transform);

		public abstract void FixTransforms();

		public abstract void StoreDefaultLocalState();

		protected abstract void OnInitiate();

		protected abstract void OnUpdate();

		protected void LogWarning(string message)
		{
			Warning.Log(message, root, logInEditMode: true);
		}

		public static Transform ContainsDuplicateBone(Bone[] bones)
		{
			for (int i = 0; i < bones.Length; i++)
			{
				for (int j = 0; j < bones.Length; j++)
				{
					if (i != j && bones[i].transform == bones[j].transform)
					{
						return bones[i].transform;
					}
				}
			}
			return null;
		}

		public static bool HierarchyIsValid(Bone[] bones)
		{
			for (int i = 1; i < bones.Length; i++)
			{
				if (!Hierarchy.IsAncestor(bones[i].transform, bones[i - 1].transform))
				{
					return false;
				}
			}
			return true;
		}

		protected static float PreSolveBones(ref Bone[] bones)
		{
			float num = 0f;
			for (int i = 0; i < bones.Length; i++)
			{
				bones[i].solverPosition = bones[i].transform.position;
				bones[i].solverRotation = bones[i].transform.rotation;
			}
			for (int j = 0; j < bones.Length; j++)
			{
				if (j < bones.Length - 1)
				{
					bones[j].sqrMag = (bones[j + 1].solverPosition - bones[j].solverPosition).sqrMagnitude;
					bones[j].length = Mathf.Sqrt(bones[j].sqrMag);
					num += bones[j].length;
					bones[j].axis = Quaternion.Inverse(bones[j].solverRotation) * (bones[j + 1].solverPosition - bones[j].solverPosition);
				}
				else
				{
					bones[j].sqrMag = 0f;
					bones[j].length = 0f;
				}
			}
			return num;
		}
	}
	[Serializable]
	public class IKSolverAim : IKSolverHeuristic
	{
		public Transform transform;

		public Vector3 axis = Vector3.forward;

		public Vector3 poleAxis = Vector3.up;

		public Vector3 polePosition;

		[Range(0f, 1f)]
		public float poleWeight;

		public Transform poleTarget;

		[Range(0f, 1f)]
		public float clampWeight = 0.1f;

		[Range(0f, 2f)]
		public int clampSmoothing = 2;

		public IterationDelegate OnPreIteration;

		private float step;

		private Vector3 clampedIKPosition;

		private RotationLimit transformLimit;

		private Transform lastTransform;

		public Vector3 transformAxis => transform.rotation * axis;

		public Vector3 transformPoleAxis => transform.rotation * poleAxis;

		protected override int minBones => 1;

		protected override Vector3 localDirection => bones[0].transform.InverseTransformDirection(bones[bones.Length - 1].transform.forward);

		public float GetAngle()
		{
			return Vector3.Angle(transformAxis, IKPosition - transform.position);
		}

		protected override void OnInitiate()
		{
			if ((firstInitiation || !Application.isPlaying) && transform != null)
			{
				IKPosition = transform.position + transformAxis * 3f;
				polePosition = transform.position + transformPoleAxis * 3f;
			}
			for (int i = 0; i < bones.Length; i++)
			{
				if (bones[i].rotationLimit != null)
				{
					bones[i].rotationLimit.Disable();
				}
			}
			step = 1f / (float)bones.Length;
			if (Application.isPlaying)
			{
				axis = axis.normalized;
			}
		}

		protected override void OnUpdate()
		{
			if (axis == Vector3.zero)
			{
				if (!Warning.logged)
				{
					LogWarning("IKSolverAim axis is Vector3.zero.");
				}
				return;
			}
			if (poleAxis == Vector3.zero && poleWeight > 0f)
			{
				if (!Warning.logged)
				{
					LogWarning("IKSolverAim poleAxis is Vector3.zero.");
				}
				return;
			}
			if (target != null)
			{
				IKPosition = target.position;
			}
			if (poleTarget != null)
			{
				polePosition = poleTarget.position;
			}
			if (XY)
			{
				IKPosition.z = bones[0].transform.position.z;
			}
			if (IKPositionWeight <= 0f)
			{
				return;
			}
			IKPositionWeight = Mathf.Clamp(IKPositionWeight, 0f, 1f);
			if (transform != lastTransform)
			{
				transformLimit = transform.GetComponent<RotationLimit>();
				if (transformLimit != null)
				{
					transformLimit.enabled = false;
				}
				lastTransform = transform;
			}
			if (transformLimit != null)
			{
				transformLimit.Apply();
			}
			if (transform == null)
			{
				if (!Warning.logged)
				{
					LogWarning("Aim Transform unassigned in Aim IK solver. Please Assign a Transform (lineal descendant to the last bone in the spine) that you want to be aimed at IKPosition");
				}
				return;
			}
			clampWeight = Mathf.Clamp(clampWeight, 0f, 1f);
			clampedIKPosition = GetClampedIKPosition();
			Vector3 b = clampedIKPosition - transform.position;
			b = Vector3.Slerp(transformAxis * b.magnitude, b, IKPositionWeight);
			clampedIKPosition = transform.position + b;
			for (int i = 0; i < maxIterations && (i < 1 || !(tolerance > 0f) || !(GetAngle() < tolerance)); i++)
			{
				lastLocalDirection = localDirection;
				if (OnPreIteration != null)
				{
					OnPreIteration(i);
				}
				Solve();
			}
			lastLocalDirection = localDirection;
		}

		private void Solve()
		{
			for (int i = 0; i < bones.Length - 1; i++)
			{
				RotateToTarget(clampedIKPosition, bones[i], step * (float)(i + 1) * IKPositionWeight * bones[i].weight);
			}
			RotateToTarget(clampedIKPosition, bones[bones.Length - 1], IKPositionWeight * bones[bones.Length - 1].weight);
		}

		private Vector3 GetClampedIKPosition()
		{
			if (clampWeight <= 0f)
			{
				return IKPosition;
			}
			if (clampWeight >= 1f)
			{
				return transform.position + transformAxis * (IKPosition - transform.position).magnitude;
			}
			float num = Vector3.Angle(transformAxis, IKPosition - transform.position);
			float num2 = 1f - num / 180f;
			float num3 = ((clampWeight > 0f) ? Mathf.Clamp(1f - (clampWeight - num2) / (1f - num2), 0f, 1f) : 1f);
			float num4 = ((clampWeight > 0f) ? Mathf.Clamp(num2 / clampWeight, 0f, 1f) : 1f);
			for (int i = 0; i < clampSmoothing; i++)
			{
				num4 = Mathf.Sin(num4 * (float)Math.PI * 0.5f);
			}
			return transform.position + Vector3.Slerp(transformAxis * 10f, IKPosition - transform.position, num4 * num3);
		}

		private void RotateToTarget(Vector3 targetPosition, Bone bone, float weight)
		{
			if (XY)
			{
				if (weight >= 0f)
				{
					Vector3 vector = transformAxis;
					Vector3 vector2 = targetPosition - transform.position;
					float current = Mathf.Atan2(vector.x, vector.y) * 57.29578f;
					float num = Mathf.Atan2(vector2.x, vector2.y) * 57.29578f;
					bone.transform.rotation = Quaternion.AngleAxis(Mathf.DeltaAngle(current, num), Vector3.back) * bone.transform.rotation;
				}
			}
			else
			{
				if (weight >= 0f)
				{
					Quaternion quaternion = Quaternion.FromToRotation(transformAxis, targetPosition - transform.position);
					if (weight >= 1f)
					{
						bone.transform.rotation = quaternion * bone.transform.rotation;
					}
					else
					{
						bone.transform.rotation = Quaternion.Lerp(Quaternion.identity, quaternion, weight) * bone.transform.rotation;
					}
				}
				if (poleWeight > 0f)
				{
					Vector3 tangent = polePosition - transform.position;
					Vector3 normal = transformAxis;
					Vector3.OrthoNormalize(ref normal, ref tangent);
					Quaternion b = Quaternion.FromToRotation(transformPoleAxis, tangent);
					bone.transform.rotation = Quaternion.Lerp(Quaternion.identity, b, weight * poleWeight) * bone.transform.rotation;
				}
			}
			if (useRotationLimits && bone.rotationLimit != null)
			{
				bone.rotationLimit.Apply();
			}
		}
	}
	[Serializable]
	public class IKSolverCCD : IKSolverHeuristic
	{
		public IterationDelegate OnPreIteration;

		public void FadeOutBoneWeights()
		{
			if (bones.Length >= 2)
			{
				bones[0].weight = 1f;
				float num = 1f / (float)(bones.Length - 1);
				for (int i = 1; i < bones.Length; i++)
				{
					bones[i].weight = num * (float)(bones.Length - 1 - i);
				}
			}
		}

		protected override void OnInitiate()
		{
			if (firstInitiation || !Application.isPlaying)
			{
				IKPosition = bones[bones.Length - 1].transform.position;
			}
			InitiateBones();
		}

		protected override void OnUpdate()
		{
			if (IKPositionWeight <= 0f)
			{
				return;
			}
			IKPositionWeight = Mathf.Clamp(IKPositionWeight, 0f, 1f);
			if (target != null)
			{
				IKPosition = target.position;
			}
			if (XY)
			{
				IKPosition.z = bones[0].transform.position.z;
			}
			Vector3 vector = ((maxIterations > 1) ? GetSingularityOffset() : Vector3.zero);
			for (int i = 0; i < maxIterations && (!(vector == Vector3.zero) || i < 1 || !(tolerance > 0f) || !(base.positionOffset < tolerance * tolerance)); i++)
			{
				lastLocalDirection = localDirection;
				if (OnPreIteration != null)
				{
					OnPreIteration(i);
				}
				Solve(IKPosition + ((i == 0) ? vector : Vector3.zero));
			}
			lastLocalDirection = localDirection;
		}

		private void Solve(Vector3 targetPosition)
		{
			if (XY)
			{
				for (int num = bones.Length - 2; num > -1; num--)
				{
					float num2 = bones[num].weight * IKPositionWeight;
					if (num2 > 0f)
					{
						Vector3 vector = bones[bones.Length - 1].transform.position - bones[num].transform.position;
						Vector3 vector2 = targetPosition - bones[num].transform.position;
						float current = Mathf.Atan2(vector.x, vector.y) * 57.29578f;
						float num3 = Mathf.Atan2(vector2.x, vector2.y) * 57.29578f;
						bones[num].transform.rotation = Quaternion.AngleAxis(Mathf.DeltaAngle(current, num3) * num2, Vector3.back) * bones[num].transform.rotation;
					}
					if (useRotationLimits && bones[num].rotationLimit != null)
					{
						bones[num].rotationLimit.Apply();
					}
				}
				return;
			}
			for (int num4 = bones.Length - 2; num4 > -1; num4--)
			{
				float num5 = bones[num4].weight * IKPositionWeight;
				if (num5 > 0f)
				{
					Vector3 fromDirection = bones[bones.Length - 1].transform.position - bones[num4].transform.position;
					Vector3 toDirection = targetPosition - bones[num4].transform.position;
					Quaternion quaternion = Quaternion.FromToRotation(fromDirection, toDirection) * bones[num4].transform.rotation;
					if (num5 >= 1f)
					{
						bones[num4].transform.rotation = quaternion;
					}
					else
					{
						bones[num4].transform.rotation = Quaternion.Lerp(bones[num4].transform.rotation, quaternion, num5);
					}
				}
				if (useRotationLimits && bones[num4].rotationLimit != null)
				{
					bones[num4].rotationLimit.Apply();
				}
			}
		}
	}
	[Serializable]
	public class IKSolverFABRIK : IKSolverHeuristic
	{
		public IterationDelegate OnPreIteration;

		private bool[] limitedBones = new bool[0];

		private Vector3[] solverLocalPositions = new Vector3[0];

		protected override bool boneLengthCanBeZero => false;

		public void SolveForward(Vector3 position)
		{
			if (!base.initiated)
			{
				if (!Warning.logged)
				{
					LogWarning("Trying to solve uninitiated FABRIK chain.");
				}
			}
			else
			{
				OnPreSolve();
				ForwardReach(position);
			}
		}

		public void SolveBackward(Vector3 position)
		{
			if (!base.initiated)
			{
				if (!Warning.logged)
				{
					LogWarning("Trying to solve uninitiated FABRIK chain.");
				}
			}
			else
			{
				BackwardReach(position);
				OnPostSolve();
			}
		}

		public override Vector3 GetIKPosition()
		{
			if (target != null)
			{
				return target.position;
			}
			return IKPosition;
		}

		protected override void OnInitiate()
		{
			if (firstInitiation || !Application.isPlaying)
			{
				IKPosition = bones[bones.Length - 1].transform.position;
			}
			for (int i = 0; i < bones.Length; i++)
			{
				bones[i].solverPosition = bones[i].transform.position;
				bones[i].solverRotation = bones[i].transform.rotation;
			}
			limitedBones = new bool[bones.Length];
			solverLocalPositions = new Vector3[bones.Length];
			InitiateBones();
			for (int j = 0; j < bones.Length; j++)
			{
				solverLocalPositions[j] = Quaternion.Inverse(GetParentSolverRotation(j)) * (bones[j].transform.position - GetParentSolverPosition(j));
			}
		}

		protected override void OnUpdate()
		{
			if (IKPositionWeight <= 0f)
			{
				return;
			}
			IKPositionWeight = Mathf.Clamp(IKPositionWeight, 0f, 1f);
			OnPreSolve();
			if (target != null)
			{
				IKPosition = target.position;
			}
			if (XY)
			{
				IKPosition.z = bones[0].transform.position.z;
			}
			Vector3 vector = ((maxIterations > 1) ? GetSingularityOffset() : Vector3.zero);
			for (int i = 0; i < maxIterations && (!(vector == Vector3.zero) || i < 1 || !(tolerance > 0f) || !(base.positionOffset < tolerance * tolerance)); i++)
			{
				lastLocalDirection = localDirection;
				if (OnPreIteration != null)
				{
					OnPreIteration(i);
				}
				Solve(IKPosition + ((i == 0) ? vector : Vector3.zero));
			}
			OnPostSolve();
		}

		private Vector3 SolveJoint(Vector3 pos1, Vector3 pos2, float length)
		{
			if (XY)
			{
				pos1.z = pos2.z;
			}
			return pos2 + (pos1 - pos2).normalized * length;
		}

		private void OnPreSolve()
		{
			chainLength = 0f;
			for (int i = 0; i < bones.Length; i++)
			{
				bones[i].solverPosition = bones[i].transform.position;
				bones[i].solverRotation = bones[i].transform.rotation;
				if (i < bones.Length - 1)
				{
					bones[i].length = (bones[i].transform.position - bones[i + 1].transform.position).magnitude;
					bones[i].axis = Quaternion.Inverse(bones[i].transform.rotation) * (bones[i + 1].transform.position - bones[i].transform.position);
					chainLength += bones[i].length;
				}
				if (useRotationLimits)
				{
					solverLocalPositions[i] = Quaternion.Inverse(GetParentSolverRotation(i)) * (bones[i].transform.position - GetParentSolverPosition(i));
				}
			}
		}

		private void OnPostSolve()
		{
			if (!useRotationLimits)
			{
				MapToSolverPositions();
			}
			else
			{
				MapToSolverPositionsLimited();
			}
			lastLocalDirection = localDirection;
		}

		private void Solve(Vector3 targetPosition)
		{
			ForwardReach(targetPosition);
			BackwardReach(bones[0].transform.position);
		}

		private void ForwardReach(Vector3 position)
		{
			bones[bones.Length - 1].solverPosition = Vector3.Lerp(bones[bones.Length - 1].solverPosition, position, IKPositionWeight);
			for (int i = 0; i < limitedBones.Length; i++)
			{
				limitedBones[i] = false;
			}
			for (int num = bones.Length - 2; num > -1; num--)
			{
				bones[num].solverPosition = SolveJoint(bones[num].solverPosition, bones[num + 1].solverPosition, bones[num].length);
				LimitForward(num, num + 1);
			}
			LimitForward(0, 0);
		}

		private void SolverMove(int index, Vector3 offset)
		{
			for (int i = index; i < bones.Length; i++)
			{
				bones[i].solverPosition += offset;
			}
		}

		private void SolverRotate(int index, Quaternion rotation, bool recursive)
		{
			for (int i = index; i < bones.Length; i++)
			{
				bones[i].solverRotation = rotation * bones[i].solverRotation;
				if (!recursive)
				{
					break;
				}
			}
		}

		private void SolverRotateChildren(int index, Quaternion rotation)
		{
			for (int i = index + 1; i < bones.Length; i++)
			{
				bones[i].solverRotation = rotation * bones[i].solverRotation;
			}
		}

		private void SolverMoveChildrenAroundPoint(int index, Quaternion rotation)
		{
			for (int i = index + 1; i < bones.Length; i++)
			{
				Vector3 vector = bones[i].solverPosition - bones[index].solverPosition;
				bones[i].solverPosition = bones[index].solverPosition + rotation * vector;
			}
		}

		private Quaternion GetParentSolverRotation(int index)
		{
			if (index > 0)
			{
				return bones[index - 1].solverRotation;
			}
			if (bones[0].transform.parent == null)
			{
				return Quaternion.identity;
			}
			return bones[0].transform.parent.rotation;
		}

		private Vector3 GetParentSolverPosition(int index)
		{
			if (index > 0)
			{
				return bones[index - 1].solverPosition;
			}
			if (bones[0].transform.parent == null)
			{
				return Vector3.zero;
			}
			return bones[0].transform.parent.position;
		}

		private Quaternion GetLimitedRotation(int index, Quaternion q, out bool changed)
		{
			changed = false;
			Quaternion parentSolverRotation = GetParentSolverRotation(index);
			Quaternion localRotation = Quaternion.Inverse(parentSolverRotation) * q;
			Quaternion limitedLocalRotation = bones[index].rotationLimit.GetLimitedLocalRotation(localRotation, out changed);
			if (!changed)
			{
				return q;
			}
			return parentSolverRotation * limitedLocalRotation;
		}

		private void LimitForward(int rotateBone, int limitBone)
		{
			if (!useRotationLimits || bones[limitBone].rotationLimit == null)
			{
				return;
			}
			Vector3 solverPosition = bones[bones.Length - 1].solverPosition;
			for (int i = rotateBone; i < bones.Length - 1 && !limitedBones[i]; i++)
			{
				Quaternion rotation = Quaternion.FromToRotation(bones[i].solverRotation * bones[i].axis, bones[i + 1].solverPosition - bones[i].solverPosition);
				SolverRotate(i, rotation, recursive: false);
			}
			bool changed = false;
			Quaternion limitedRotation = GetLimitedRotation(limitBone, bones[limitBone].solverRotation, out changed);
			if (changed)
			{
				if (limitBone < bones.Length - 1)
				{
					Quaternion rotation2 = QuaTools.FromToRotation(bones[limitBone].solverRotation, limitedRotation);
					bones[limitBone].solverRotation = limitedRotation;
					SolverRotateChildren(limitBone, rotation2);
					SolverMoveChildrenAroundPoint(limitBone, rotation2);
					Quaternion rotation3 = Quaternion.FromToRotation(bones[bones.Length - 1].solverPosition - bones[rotateBone].solverPosition, solverPosition - bones[rotateBone].solverPosition);
					SolverRotate(rotateBone, rotation3, recursive: true);
					SolverMoveChildrenAroundPoint(rotateBone, rotation3);
					SolverMove(rotateBone, solverPosition - bones[bones.Length - 1].solverPosition);
				}
				else
				{
					bones[limitBone].solverRotation = limitedRotation;
				}
			}
			limitedBones[limitBone] = true;
		}

		private void BackwardReach(Vector3 position)
		{
			if (useRotationLimits)
			{
				BackwardReachLimited(position);
			}
			else
			{
				BackwardReachUnlimited(position);
			}
		}

		private void BackwardReachUnlimited(Vector3 position)
		{
			bones[0].solverPosition = position;
			for (int i = 1; i < bones.Length; i++)
			{
				bones[i].solverPosition = SolveJoint(bones[i].solverPosition, bones[i - 1].solverPosition, bones[i - 1].length);
			}
		}

		private void BackwardReachLimited(Vector3 position)
		{
			bones[0].solverPosition = position;
			for (int i = 0; i < bones.Length - 1; i++)
			{
				Vector3 vector = SolveJoint(bones[i + 1].solverPosition, bones[i].solverPosition, bones[i].length);
				Quaternion quaternion = Quaternion.FromToRotation(bones[i].solverRotation * bones[i].axis, vector - bones[i].solverPosition) * bones[i].solverRotation;
				if (bones[i].rotationLimit != null)
				{
					bool changed = false;
					quaternion = GetLimitedRotation(i, quaternion, out changed);
				}
				Quaternion rotation = QuaTools.FromToRotation(bones[i].solverRotation, quaternion);
				bones[i].solverRotation = quaternion;
				SolverRotateChildren(i, rotation);
				bones[i + 1].solverPosition = bones[i].solverPosition + bones[i].solverRotation * solverLocalPositions[i + 1];
			}
			for (int j = 0; j < bones.Length; j++)
			{
				bones[j].solverRotation = Quaternion.LookRotation(bones[j].solverRotation * Vector3.forward, bones[j].solverRotation * Vector3.up);
			}
		}

		private void MapToSolverPositions()
		{
			bones[0].transform.position = bones[0].solverPosition;
			for (int i = 0; i < bones.Length - 1; i++)
			{
				if (XY)
				{
					bones[i].Swing2D(bones[i + 1].solverPosition);
				}
				else
				{
					bones[i].Swing(bones[i + 1].solverPosition);
				}
			}
		}

		private void MapToSolverPositionsLimited()
		{
			for (int i = 0; i < bones.Length; i++)
			{
				bones[i].transform.position = bones[i].solverPosition;
				if (i < bones.Length - 1)
				{
					bones[i].transform.rotation = bones[i].solverRotation;
				}
			}
		}
	}
	[Serializable]
	public class IKSolverFABRIKRoot : IKSolver
	{
		public int iterations = 4;

		[Range(0f, 1f)]
		public float rootPin;

		public FABRIKChain[] chains = new FABRIKChain[0];

		private bool zeroWeightApplied;

		private bool[] isRoot;

		private Vector3 rootDefaultPosition;

		public override bool IsValid(ref string message)
		{
			if (chains.Length == 0)
			{
				message = "IKSolverFABRIKRoot contains no chains.";
				return false;
			}
			FABRIKChain[] array = chains;
			for (int i = 0; i < array.Length; i++)
			{
				if (!array[i].IsValid(ref message))
				{
					return false;
				}
			}
			for (int j = 0; j < chains.Length; j++)
			{
				for (int k = 0; k < chains.Length; k++)
				{
					if (j != k && chains[j].ik == chains[k].ik)
					{
						message = chains[j].ik.name + " is represented more than once in IKSolverFABRIKRoot chain.";
						return false;
					}
				}
			}
			for (int l = 0; l < chains.Length; l++)
			{
				for (int m = 0; m < chains[l].children.Length; m++)
				{
					int num = chains[l].children[m];
					if (num < 0)
					{
						message = chains[l].ik.name + "IKSolverFABRIKRoot chain at index " + l + " has invalid children array. Child index is < 0.";
						return false;
					}
					if (num == l)
					{
						message = chains[l].ik.name + "IKSolverFABRIKRoot chain at index " + l + " has invalid children array. Child index is referencing to itself.";
						return false;
					}
					if (num >= chains.Length)
					{
						message = chains[l].ik.name + "IKSolverFABRIKRoot chain at index " + l + " has invalid children array. Child index > number of chains";
						return false;
					}
					for (int n = 0; n < chains.Length; n++)
					{
						if (num != n)
						{
							continue;
						}
						for (int num2 = 0; num2 < chains[n].children.Length; num2++)
						{
							if (chains[n].children[num2] == l)
							{
								message = "Circular parenting. " + chains[n].ik.name + " already has " + chains[l].ik.name + " listed as it's child.";
								return false;
							}
						}
					}
					for (int num3 = 0; num3 < chains[l].children.Length; num3++)
					{
						if (m != num3 && chains[l].children[num3] == num)
						{
							message = "Chain number " + num + " is represented more than once in the children of " + chains[l].ik.name;
							return false;
						}
					}
				}
			}
			return true;
		}

		public override void StoreDefaultLocalState()
		{
			rootDefaultPosition = root.localPosition;
			for (int i = 0; i < chains.Length; i++)
			{
				chains[i].ik.solver.StoreDefaultLocalState();
			}
		}

		public override void FixTransforms()
		{
			root.localPosition = rootDefaultPosition;
			for (int i = 0; i < chains.Length; i++)
			{
				chains[i].ik.solver.FixTransforms();
			}
		}

		protected override void OnInitiate()
		{
			for (int i = 0; i < chains.Length; i++)
			{
				chains[i].Initiate();
			}
			isRoot = new bool[chains.Length];
			for (int j = 0; j < chains.Length; j++)
			{
				isRoot[j] = IsRoot(j);
			}
		}

		private bool IsRoot(int index)
		{
			for (int i = 0; i < chains.Length; i++)
			{
				for (int j = 0; j < chains[i].children.Length; j++)
				{
					if (chains[i].children[j] == index)
					{
						return false;
					}
				}
			}
			return true;
		}

		protected override void OnUpdate()
		{
			if (IKPositionWeight <= 0f && zeroWeightApplied)
			{
				return;
			}
			IKPositionWeight = Mathf.Clamp(IKPositionWeight, 0f, 1f);
			for (int i = 0; i < chains.Length; i++)
			{
				chains[i].ik.solver.IKPositionWeight = IKPositionWeight;
			}
			if (IKPositionWeight <= 0f)
			{
				zeroWeightApplied = true;
				return;
			}
			zeroWeightApplied = false;
			for (int j = 0; j < iterations; j++)
			{
				for (int k = 0; k < chains.Length; k++)
				{
					if (isRoot[k])
					{
						chains[k].Stage1(chains);
					}
				}
				Vector3 centroid = GetCentroid();
				root.position = centroid;
				for (int l = 0; l < chains.Length; l++)
				{
					if (isRoot[l])
					{
						chains[l].Stage2(centroid, chains);
					}
				}
			}
		}

		public override Point[] GetPoints()
		{
			Point[] array = new Point[0];
			for (int i = 0; i < chains.Length; i++)
			{
				AddPointsToArray(ref array, chains[i]);
			}
			return array;
		}

		public override Point GetPoint(Transform transform)
		{
			Point point = null;
			for (int i = 0; i < chains.Length; i++)
			{
				point = chains[i].ik.solver.GetPoint(transform);
				if (point != null)
				{
					return point;
				}
			}
			return null;
		}

		private void AddPointsToArray(ref Point[] array, FABRIKChain chain)
		{
			Point[] points = chain.ik.solver.GetPoints();
			Array.Resize(ref array, array.Length + points.Length);
			int num = 0;
			for (int i = array.Length - points.Length; i < array.Length; i++)
			{
				array[i] = points[num];
				num++;
			}
		}

		private Vector3 GetCentroid()
		{
			Vector3 position = root.position;
			if (rootPin >= 1f)
			{
				return position;
			}
			float num = 0f;
			for (int i = 0; i < chains.Length; i++)
			{
				if (isRoot[i])
				{
					num += chains[i].pull;
				}
			}
			for (int j = 0; j < chains.Length; j++)
			{
				if (isRoot[j] && num > 0f)
				{
					position += (chains[j].ik.solver.bones[0].solverPosition - root.position) * (chains[j].pull / Mathf.Clamp(num, 1f, num));
				}
			}
			return Vector3.Lerp(position, root.position, rootPin);
		}
	}
	[Serializable]
	public class IKSolverFullBody : IKSolver
	{
		[Range(0f, 10f)]
		public int iterations = 4;

		public FBIKChain[] chain = new FBIKChain[0];

		public IKEffector[] effectors = new IKEffector[0];

		public IKMappingSpine spineMapping = new IKMappingSpine();

		public IKMappingBone[] boneMappings = new IKMappingBone[0];

		public IKMappingLimb[] limbMappings = new IKMappingLimb[0];

		public bool FABRIKPass = true;

		public UpdateDelegate OnPreRead;

		public UpdateDelegate OnPreSolve;

		public IterationDelegate OnPreIteration;

		public IterationDelegate OnPostIteration;

		public UpdateDelegate OnPreBend;

		public UpdateDelegate OnPostSolve;

		public UpdateDelegate OnStoreDefaultLocalState;

		public UpdateDelegate OnFixTransforms;

		public IKEffector GetEffector(Transform t)
		{
			for (int i = 0; i < effectors.Length; i++)
			{
				if (effectors[i].bone == t)
				{
					return effectors[i];
				}
			}
			return null;
		}

		public FBIKChain GetChain(Transform transform)
		{
			int chainIndex = GetChainIndex(transform);
			if (chainIndex == -1)
			{
				return null;
			}
			return chain[chainIndex];
		}

		public int GetChainIndex(Transform transform)
		{
			for (int i = 0; i < chain.Length; i++)
			{
				for (int j = 0; j < chain[i].nodes.Length; j++)
				{
					if (chain[i].nodes[j].transform == transform)
					{
						return i;
					}
				}
			}
			return -1;
		}

		public Node GetNode(int chainIndex, int nodeIndex)
		{
			return chain[chainIndex].nodes[nodeIndex];
		}

		public void GetChainAndNodeIndexes(Transform transform, out int chainIndex, out int nodeIndex)
		{
			chainIndex = GetChainIndex(transform);
			if (chainIndex == -1)
			{
				nodeIndex = -1;
			}
			else
			{
				nodeIndex = chain[chainIndex].GetNodeIndex(transform);
			}
		}

		public override Point[] GetPoints()
		{
			int num = 0;
			for (int i = 0; i < chain.Length; i++)
			{
				num += chain[i].nodes.Length;
			}
			Point[] array = new Point[num];
			int num2 = 0;
			for (int j = 0; j < chain.Length; j++)
			{
				for (int k = 0; k < chain[j].nodes.Length; k++)
				{
					array[num2] = chain[j].nodes[k];
				}
			}
			return array;
		}

		public override Point GetPoint(Transform transform)
		{
			for (int i = 0; i < chain.Length; i++)
			{
				for (int j = 0; j < chain[i].nodes.Length; j++)
				{
					if (chain[i].nodes[j].transform == transform)
					{
						return chain[i].nodes[j];
					}
				}
			}
			return null;
		}

		public override bool IsValid(ref string message)
		{
			if (chain == null)
			{
				message = "FBIK chain is null, can't initiate solver.";
				return false;
			}
			if (chain.Length == 0)
			{
				message = "FBIK chain length is 0, can't initiate solver.";
				return false;
			}
			for (int i = 0; i < chain.Length; i++)
			{
				if (!chain[i].IsValid(ref message))
				{
					return false;
				}
			}
			IKEffector[] array = effectors;
			for (int j = 0; j < array.Length; j++)
			{
				if (!array[j].IsValid(this, ref message))
				{
					return false;
				}
			}
			if (!spineMapping.IsValid(this, ref message))
			{
				return false;
			}
			IKMappingLimb[] array2 = limbMappings;
			for (int j = 0; j < array2.Length; j++)
			{
				if (!array2[j].IsValid(this, ref message))
				{
					return false;
				}
			}
			IKMappingBone[] array3 = boneMappings;
			for (int j = 0; j < array3.Length; j++)
			{
				if (!array3[j].IsValid(this, ref message))
				{
					return false;
				}
			}
			return true;
		}

		public override void StoreDefaultLocalState()
		{
			spineMapping.StoreDefaultLocalState();
			for (int i = 0; i < limbMappings.Length; i++)
			{
				limbMappings[i].StoreDefaultLocalState();
			}
			for (int j = 0; j < boneMappings.Length; j++)
			{
				boneMappings[j].StoreDefaultLocalState();
			}
			if (OnStoreDefaultLocalState != null)
			{
				OnStoreDefaultLocalState();
			}
		}

		public override void FixTransforms()
		{
			if (!(IKPositionWeight <= 0f))
			{
				spineMapping.FixTransforms();
				for (int i = 0; i < limbMappings.Length; i++)
				{
					limbMappings[i].FixTransforms();
				}
				for (int j = 0; j < boneMappings.Length; j++)
				{
					boneMappings[j].FixTransforms();
				}
				if (OnFixTransforms != null)
				{
					OnFixTransforms();
				}
			}
		}

		protected override void OnInitiate()
		{
			for (int i = 0; i < chain.Length; i++)
			{
				chain[i].Initiate(this);
			}
			IKEffector[] array = effectors;
			for (int j = 0; j < array.Length; j++)
			{
				array[j].Initiate(this);
			}
			spineMapping.Initiate(this);
			IKMappingBone[] array2 = boneMappings;
			for (int j = 0; j < array2.Length; j++)
			{
				array2[j].Initiate(this);
			}
			IKMappingLimb[] array3 = limbMappings;
			for (int j = 0; j < array3.Length; j++)
			{
				array3[j].Initiate(this);
			}
		}

		protected override void OnUpdate()
		{
			if (IKPositionWeight <= 0f)
			{
				for (int i = 0; i < effectors.Length; i++)
				{
					effectors[i].positionOffset = Vector3.zero;
				}
			}
			else if (chain.Length != 0)
			{
				IKPositionWeight = Mathf.Clamp(IKPositionWeight, 0f, 1f);
				if (OnPreRead != null)
				{
					OnPreRead();
				}
				ReadPose();
				if (OnPreSolve != null)
				{
					OnPreSolve();
				}
				Solve();
				if (OnPostSolve != null)
				{
					OnPostSolve();
				}
				WritePose();
				for (int j = 0; j < effectors.Length; j++)
				{
					effectors[j].OnPostWrite();
				}
			}
		}

		protected virtual void ReadPose()
		{
			for (int i = 0; i < chain.Length; i++)
			{
				if (chain[i].bendConstraint.initiated)
				{
					chain[i].bendConstraint.LimitBend(IKPositionWeight, GetEffector(chain[i].nodes[2].transform).positionWeight);
				}
			}
			for (int j = 0; j < effectors.Length; j++)
			{
				effectors[j].ResetOffset(this);
			}
			for (int k = 0; k < effectors.Length; k++)
			{
				effectors[k].OnPreSolve(this);
			}
			for (int l = 0; l < chain.Length; l++)
			{
				chain[l].ReadPose(this, iterations > 0);
			}
			if (iterations > 0)
			{
				spineMapping.ReadPose();
				for (int m = 0; m < boneMappings.Length; m++)
				{
					boneMappings[m].ReadPose();
				}
			}
			for (int n = 0; n < limbMappings.Length; n++)
			{
				limbMappings[n].ReadPose();
			}
		}

		protected virtual void Solve()
		{
			if (iterations > 0)
			{
				for (int i = 0; i < ((!FABRIKPass) ? 1 : iterations); i++)
				{
					if (OnPreIteration != null)
					{
						OnPreIteration(i);
					}
					for (int j = 0; j < effectors.Length; j++)
					{
						if (effectors[j].isEndEffector)
						{
							effectors[j].Update(this);
						}
					}
					if (FABRIKPass)
					{
						chain[0].Push(this);
						if (FABRIKPass)
						{
							chain[0].Reach(this);
						}
						for (int k = 0; k < effectors.Length; k++)
						{
							if (!effectors[k].isEndEffector)
							{
								effectors[k].Update(this);
							}
						}
					}
					chain[0].SolveTrigonometric(this);
					if (FABRIKPass)
					{
						chain[0].Stage1(this);
						for (int l = 0; l < effectors.Length; l++)
						{
							if (!effectors[l].isEndEffector)
							{
								effectors[l].Update(this);
							}
						}
						chain[0].Stage2(this, chain[0].nodes[0].solverPosition);
					}
					if (OnPostIteration != null)
					{
						OnPostIteration(i);
					}
				}
			}
			if (OnPreBend != null)
			{
				OnPreBend();
			}
			for (int m = 0; m < effectors.Length; m++)
			{
				if (effectors[m].isEndEffector)
				{
					effectors[m].Update(this);
				}
			}
			ApplyBendConstraints();
		}

		protected virtual void ApplyBendConstraints()
		{
			chain[0].SolveTrigonometric(this, calculateBendDirection: true);
		}

		protected virtual void WritePose()
		{
			if (IKPositionWeight <= 0f)
			{
				return;
			}
			if (iterations > 0)
			{
				spineMapping.WritePose(this);
				for (int i = 0; i < boneMappings.Length; i++)
				{
					boneMappings[i].WritePose(IKPositionWeight);
				}
			}
			for (int j = 0; j < limbMappings.Length; j++)
			{
				limbMappings[j].WritePose(this, iterations > 0);
			}
		}
	}
	[Serializable]
	public enum FullBodyBipedEffector
	{
		Body,
		LeftShoulder,
		RightShoulder,
		LeftThigh,
		RightThigh,
		LeftHand,
		RightHand,
		LeftFoot,
		RightFoot
	}
	[Serializable]
	public enum FullBodyBipedChain
	{
		LeftArm,
		RightArm,
		LeftLeg,
		RightLeg
	}
	[Serializable]
	public class IKSolverFullBodyBiped : IKSolverFullBody
	{
		public Transform rootNode;

		[Range(0f, 1f)]
		public float spineStiffness = 0.5f;

		[Range(-1f, 1f)]
		public float pullBodyVertical = 0.5f;

		[Range(-1f, 1f)]
		public float pullBodyHorizontal;

		private Vector3 offset;

		public IKEffector bodyEffector => GetEffector(FullBodyBipedEffector.Body);

		public IKEffector leftShoulderEffector => GetEffector(FullBodyBipedEffector.LeftShoulder);

		public IKEffector rightShoulderEffector => GetEffector(FullBodyBipedEffector.RightShoulder);

		public IKEffector leftThighEffector => GetEffector(FullBodyBipedEffector.LeftThigh);

		public IKEffector rightThighEffector => GetEffector(FullBodyBipedEffector.RightThigh);

		public IKEffector leftHandEffector => GetEffector(FullBodyBipedEffector.LeftHand);

		public IKEffector rightHandEffector => GetEffector(FullBodyBipedEffector.RightHand);

		public IKEffector leftFootEffector => GetEffector(FullBodyBipedEffector.LeftFoot);

		public IKEffector rightFootEffector => GetEffector(FullBodyBipedEffector.RightFoot);

		public FBIKChain leftArmChain => chain[1];

		public FBIKChain rightArmChain => chain[2];

		public FBIKChain leftLegChain => chain[3];

		public FBIKChain rightLegChain => chain[4];

		public IKMappingLimb leftArmMapping => limbMappings[0];

		public IKMappingLimb rightArmMapping => limbMappings[1];

		public IKMappingLimb leftLegMapping => limbMappings[2];

		public IKMappingLimb rightLegMapping => limbMappings[3];

		public IKMappingBone headMapping => boneMappings[0];

		public Vector3 pullBodyOffset { get; private set; }

		public void SetChainWeights(FullBodyBipedChain c, float pull, float reach = 0f)
		{
			GetChain(c).pull = pull;
			GetChain(c).reach = reach;
		}

		public void SetEffectorWeights(FullBodyBipedEffector effector, float positionWeight, float rotationWeight)
		{
			GetEffector(effector).positionWeight = Mathf.Clamp(positionWeight, 0f, 1f);
			GetEffector(effector).rotationWeight = Mathf.Clamp(rotationWeight, 0f, 1f);
		}

		public FBIKChain GetChain(FullBodyBipedChain c)
		{
			return c switch
			{
				FullBodyBipedChain.LeftArm => chain[1], 
				FullBodyBipedChain.RightArm => chain[2], 
				FullBodyBipedChain.LeftLeg => chain[3], 
				FullBodyBipedChain.RightLeg => chain[4], 
				_ => null, 
			};
		}

		public FBIKChain GetChain(FullBodyBipedEffector effector)
		{
			return effector switch
			{
				FullBodyBipedEffector.Body => chain[0], 
				FullBodyBipedEffector.LeftShoulder => chain[1], 
				FullBodyBipedEffector.RightShoulder => chain[2], 
				FullBodyBipedEffector.LeftThigh => chain[3], 
				FullBodyBipedEffector.RightThigh => chain[4], 
				FullBodyBipedEffector.LeftHand => chain[1], 
				FullBodyBipedEffector.RightHand => chain[2], 
				FullBodyBipedEffector.LeftFoot => chain[3], 
				FullBodyBipedEffector.RightFoot => chain[4], 
				_ => null, 
			};
		}

		public IKEffector GetEffector(FullBodyBipedEffector effector)
		{
			return effector switch
			{
				FullBodyBipedEffector.Body => effectors[0], 
				FullBodyBipedEffector.LeftShoulder => effectors[1], 
				FullBodyBipedEffector.RightShoulder => effectors[2], 
				FullBodyBipedEffector.LeftThigh => effectors[3], 
				FullBodyBipedEffector.RightThigh => effectors[4], 
				FullBodyBipedEffector.LeftHand => effectors[5], 
				FullBodyBipedEffector.RightHand => effectors[6], 
				FullBodyBipedEffector.LeftFoot => effectors[7], 
				FullBodyBipedEffector.RightFoot => effectors[8], 
				_ => null, 
			};
		}

		public IKEffector GetEndEffector(FullBodyBipedChain c)
		{
			return c switch
			{
				FullBodyBipedChain.LeftArm => effectors[5], 
				FullBodyBipedChain.RightArm => effectors[6], 
				FullBodyBipedChain.LeftLeg => effectors[7], 
				FullBodyBipedChain.RightLeg => effectors[8], 
				_ => null, 
			};
		}

		public IKMappingLimb GetLimbMapping(FullBodyBipedChain chain)
		{
			return chain switch
			{
				FullBodyBipedChain.LeftArm => limbMappings[0], 
				FullBodyBipedChain.RightArm => limbMappings[1], 
				FullBodyBipedChain.LeftLeg => limbMappings[2], 
				FullBodyBipedChain.RightLeg => limbMappings[3], 
				_ => null, 
			};
		}

		public IKMappingLimb GetLimbMapping(FullBodyBipedEffector effector)
		{
			return effector switch
			{
				FullBodyBipedEffector.LeftShoulder => limbMappings[0], 
				FullBodyBipedEffector.RightShoulder => limbMappings[1], 
				FullBodyBipedEffector.LeftThigh => limbMappings[2], 
				FullBodyBipedEffector.RightThigh => limbMappings[3], 
				FullBodyBipedEffector.LeftHand => limbMappings[0], 
				FullBodyBipedEffector.RightHand => limbMappings[1], 
				FullBodyBipedEffector.LeftFoot => limbMappings[2], 
				FullBodyBipedEffector.RightFoot => limbMappings[3], 
				_ => null, 
			};
		}

		public IKMappingSpine GetSpineMapping()
		{
			return spineMapping;
		}

		public IKMappingBone GetHeadMapping()
		{
			return boneMappings[0];
		}

		public IKConstraintBend GetBendConstraint(FullBodyBipedChain limb)
		{
			return limb switch
			{
				FullBodyBipedChain.LeftArm => chain[1].bendConstraint, 
				FullBodyBipedChain.RightArm => chain[2].bendConstraint, 
				FullBodyBipedChain.LeftLeg => chain[3].bendConstraint, 
				FullBodyBipedChain.RightLeg => chain[4].bendConstraint, 
				_ => null, 
			};
		}

		public override bool IsValid(ref string message)
		{
			if (!base.IsValid(ref message))
			{
				return false;
			}
			if (rootNode == null)
			{
				message = "Root Node bone is null. FBBIK will not initiate.";
				return false;
			}
			if (chain.Length != 5 || chain[0].nodes.Length != 1 || chain[1].nodes.Length != 3 || chain[2].nodes.Length != 3 || chain[3].nodes.Length != 3 || chain[4].nodes.Length != 3 || effectors.Length != 9 || limbMappings.Length != 4)
			{
				message = "Invalid FBBIK setup. Please right-click on the component header and select 'Reinitiate'.";
				return false;
			}
			return true;
		}

		public void SetToReferences(BipedReferences references, Transform rootNode = null)
		{
			root = references.root;
			if (rootNode == null)
			{
				rootNode = DetectRootNodeBone(references);
			}
			this.rootNode = rootNode;
			if (chain == null || chain.Length != 5)
			{
				chain = new FBIKChain[5];
			}
			for (int i = 0; i < chain.Length; i++)
			{
				if (chain[i] == null)
				{
					chain[i] = new FBIKChain();
				}
			}
			chain[0].pin = 0f;
			chain[0].SetNodes(rootNode);
			chain[0].children = new int[4] { 1, 2, 3, 4 };
			chain[1].SetNodes(references.leftUpperArm, references.leftForearm, references.leftHand);
			chain[2].SetNodes(references.rightUpperArm, references.rightForearm, references.rightHand);
			chain[3].SetNodes(references.leftThigh, references.leftCalf, references.leftFoot);
			chain[4].SetNodes(references.rightThigh, references.rightCalf, references.rightFoot);
			if (effectors.Length != 9)
			{
				effectors = new IKEffector[9]
				{
					new IKEffector(),
					new IKEffector(),
					new IKEffector(),
					new IKEffector(),
					new IKEffector(),
					new IKEffector(),
					new IKEffector(),
					new IKEffector(),
					new IKEffector()
				};
			}
			effectors[0].bone = rootNode;
			effectors[0].childBones = new Transform[2] { references.leftThigh, references.rightThigh };
			effectors[1].bone = references.leftUpperArm;
			effectors[2].bone = references.rightUpperArm;
			effectors[3].bone = references.leftThigh;
			effectors[4].bone = references.rightThigh;
			effectors[5].bone = references.leftHand;
			effectors[6].bone = references.rightHand;
			effectors[7].bone = references.leftFoot;
			effectors[8].bone = references.rightFoot;
			effectors[5].planeBone1 = references.leftUpperArm;
			effectors[5].planeBone2 = references.rightUpperArm;
			effectors[5].planeBone3 = rootNode;
			effectors[6].planeBone1 = references.rightUpperArm;
			effectors[6].planeBone2 = references.leftUpperArm;
			effectors[6].planeBone3 = rootNode;
			effectors[7].planeBone1 = references.leftThigh;
			effectors[7].planeBone2 = references.rightThigh;
			effectors[7].planeBone3 = rootNode;
			effectors[8].planeBone1 = references.rightThigh;
			effectors[8].planeBone2 = references.leftThigh;
			effectors[8].planeBone3 = rootNode;
			chain[0].childConstraints = new FBIKChain.ChildConstraint[4]
			{
				new FBIKChain.ChildConstraint(references.leftUpperArm, references.rightThigh, 0f, 1f),
				new FBIKChain.ChildConstraint(references.rightUpperArm, references.leftThigh, 0f, 1f),
				new FBIKChain.ChildConstraint(references.leftUpperArm, references.rightUpperArm),
				new FBIKChain.ChildConstraint(references.leftThigh, references.rightThigh)
			};
			Transform[] array = new Transform[references.spine.Length + 1];
			array[0] = references.pelvis;
			for (int j = 0; j < references.spine.Length; j++)
			{
				array[j + 1] = references.spine[j];
			}
			if (spineMapping == null)
			{
				spineMapping = new IKMappingSpine();
				spineMapping.iterations = 3;
			}
			spineMapping.SetBones(array, references.leftUpperArm, references.rightUpperArm, references.leftThigh, references.rightThigh);
			int num = ((references.head != null) ? 1 : 0);
			if (boneMappings.Length != num)
			{
				boneMappings = new IKMappingBone[num];
				for (int k = 0; k < boneMappings.Length; k++)
				{
					boneMappings[k] = new IKMappingBone();
				}
				if (num == 1)
				{
					boneMappings[0].maintainRotationWeight = 0f;
				}
			}
			if (boneMappings.Length != 0)
			{
				boneMappings[0].bone = references.head;
			}
			if (limbMappings.Length != 4)
			{
				limbMappings = new IKMappingLimb[4]
				{
					new IKMappingLimb(),
					new IKMappingLimb(),
					new IKMappingLimb(),
					new IKMappingLimb()
				};
				limbMappings[2].maintainRotationWeight = 1f;
				limbMappings[3].maintainRotationWeight = 1f;
			}
			limbMappings[0].SetBones(references.leftUpperArm, references.leftForearm, references.leftHand, GetLeftClavicle(references));
			limbMappings[1].SetBones(references.rightUpperArm, references.rightForearm, references.rightHand, GetRightClavicle(references));
			limbMappings[2].SetBones(references.leftThigh, references.leftCalf, references.leftFoot);
			limbMappings[3].SetBones(references.rightThigh, references.rightCalf, references.rightFoot);
			if (Application.isPlaying)
			{
				Initiate(references.root);
			}
		}

		public static Transform DetectRootNodeBone(BipedReferences references)
		{
			if (!references.isFilled)
			{
				return null;
			}
			if (references.spine.Length < 1)
			{
				return null;
			}
			int num = references.spine.Length;
			if (num == 1)
			{
				return references.spine[0];
			}
			Vector3 vector = Vector3.Lerp(references.leftThigh.position, references.rightThigh.position, 0.5f);
			Vector3 onNormal = Vector3.Lerp(references.leftUpperArm.position, references.rightUpperArm.position, 0.5f) - vector;
			float magnitude = onNormal.magnitude;
			if (references.spine.Length < 2)
			{
				return references.spine[0];
			}
			int num2 = 0;
			for (int i = 1; i < num; i++)
			{
				Vector3 vector2 = Vector3.Project(references.spine[i].position - vector, onNormal);
				if (Vector3.Dot(vector2.normalized, onNormal.normalized) > 0f && vector2.magnitude / magnitude < 0.5f)
				{
					num2 = i;
				}
			}
			return references.spine[num2];
		}

		public void SetLimbOrientations(BipedLimbOrientations o)
		{
			SetLimbOrientation(FullBodyBipedChain.LeftArm, o.leftArm);
			SetLimbOrientation(FullBodyBipedChain.RightArm, o.rightArm);
			SetLimbOrientation(FullBodyBipedChain.LeftLeg, o.leftLeg);
			SetLimbOrientation(FullBodyBipedChain.RightLeg, o.rightLeg);
		}

		private void SetLimbOrientation(FullBodyBipedChain chain, BipedLimbOrientations.LimbOrientation limbOrientation)
		{
			if (chain == FullBodyBipedChain.LeftArm || chain == FullBodyBipedChain.RightArm)
			{
				GetBendConstraint(chain).SetLimbOrientation(-limbOrientation.upperBoneForwardAxis, -limbOrientation.lowerBoneForwardAxis, -limbOrientation.lastBoneLeftAxis);
				GetLimbMapping(chain).SetLimbOrientation(-limbOrientation.upperBoneForwardAxis, -limbOrientation.lowerBoneForwardAxis);
			}
			else
			{
				GetBendConstraint(chain).SetLimbOrientation(limbOrientation.upperBoneForwardAxis, limbOrientation.lowerBoneForwardAxis, limbOrientation.lastBoneLeftAxis);
				GetLimbMapping(chain).SetLimbOrientation(limbOrientation.upperBoneForwardAxis, limbOrientation.lowerBoneForwardAxis);
			}
		}

		private static Transform GetLeftClavicle(BipedReferences references)
		{
			if (references.leftUpperArm == null)
			{
				return null;
			}
			if (!Contains(references.spine, references.leftUpperArm.parent))
			{
				return references.leftUpperArm.parent;
			}
			return null;
		}

		private static Transform GetRightClavicle(BipedReferences references)
		{
			if (references.rightUpperArm == null)
			{
				return null;
			}
			if (!Contains(references.spine, references.rightUpperArm.parent))
			{
				return references.rightUpperArm.parent;
			}
			return null;
		}

		private static bool Contains(Transform[] array, Transform transform)
		{
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i] == transform)
				{
					return true;
				}
			}
			return false;
		}

		protected override void ReadPose()
		{
			for (int i = 0; i < effectors.Length; i++)
			{
				effectors[i].SetToTarget();
			}
			PullBody();
			float pushElasticity = Mathf.Clamp(1f - spineStiffness, 0f, 1f);
			chain[0].childConstraints[0].pushElasticity = pushElasticity;
			chain[0].childConstraints[1].pushElasticity = pushElasticity;
			base.ReadPose();
		}

		private void PullBody()
		{
			if (iterations >= 1 && (pullBodyVertical != 0f || pullBodyHorizontal != 0f))
			{
				Vector3 bodyOffset = GetBodyOffset();
				pullBodyOffset = V3Tools.ExtractVertical(bodyOffset, root.up, pullBodyVertical) + V3Tools.ExtractHorizontal(bodyOffset, root.up, pullBodyHorizontal);
				bodyEffector.positionOffset += pullBodyOffset;
			}
		}

		private Vector3 GetBodyOffset()
		{
			Vector3 vector = Vector3.zero + GetHandBodyPull(leftHandEffector, leftArmChain, Vector3.zero) * Mathf.Clamp(leftHandEffector.positionWeight, 0f, 1f);
			return vector + GetHandBodyPull(rightHandEffector, rightArmChain, vector) * Mathf.Clamp(rightHandEffector.positionWeight, 0f, 1f);
		}

		private Vector3 GetHandBodyPull(IKEffector effector, FBIKChain arm, Vector3 offset)
		{
			Vector3 vector = effector.position - (arm.nodes[0].transform.position + offset);
			float num = arm.nodes[0].length + arm.nodes[1].length;
			float magnitude = vector.magnitude;
			if (magnitude < num)
			{
				return Vector3.zero;
			}
			float num2 = magnitude - num;
			return vector / magnitude * num2;
		}

		protected override void ApplyBendConstraints()
		{
			if (iterations > 0)
			{
				chain[1].bendConstraint.rotationOffset = leftHandEffector.planeRotationOffset;
				chain[2].bendConstraint.rotationOffset = rightHandEffector.planeRotationOffset;
				chain[3].bendConstraint.rotationOffset = leftFootEffector.planeRotationOffset;
				chain[4].bendConstraint.rotationOffset = rightFootEffector.planeRotationOffset;
			}
			else
			{
				offset = Vector3.Lerp(effectors[0].positionOffset, effectors[0].position - (effectors[0].bone.position + effectors[0].positionOffset), effectors[0].positionWeight);
				for (int i = 0; i < 5; i++)
				{
					effectors[i].GetNode(this).solverPosition += offset;
				}
			}
			base.ApplyBendConstraints();
		}

		protected override void WritePose()
		{
			if (iterations == 0)
			{
				spineMapping.spineBones[0].position += offset;
			}
			base.WritePose();
		}
	}
	[Serializable]
	public class IKSolverHeuristic : IKSolver
	{
		public Transform target;

		public float tolerance;

		public int maxIterations = 4;

		public bool useRotationLimits = true;

		public bool XY;

		public Bone[] bones = new Bone[0];

		protected Vector3 lastLocalDirection;

		protected float chainLength;

		protected virtual int minBones => 2;

		protected virtual bool boneLengthCanBeZero => true;

		protected virtual bool allowCommonParent => false;

		protected virtual Vector3 localDirection => bones[0].transform.InverseTransformDirection(bones[bones.Length - 1].transform.position - bones[0].transform.position);

		protected float positionOffset => Vector3.SqrMagnitude(localDirection - lastLocalDirection);

		public bool SetChain(Transform[] hierarchy, Transform root)
		{
			if (bones == null || bones.Length != hierarchy.Length)
			{
				bones = new Bone[hierarchy.Length];
			}
			for (int i = 0; i < hierarchy.Length; i++)
			{
				if (bones[i] == null)
				{
					bones[i] = new Bone();
				}
				bones[i].transform = hierarchy[i];
			}
			Initiate(root);
			return base.initiated;
		}

		public void AddBone(Transform bone)
		{
			Transform[] array = new Transform[bones.Length + 1];
			for (int i = 0; i < bones.Length; i++)
			{
				array[i] = bones[i].transform;
			}
			array[array.Length - 1] = bone;
			SetChain(array, root);
		}

		public override void StoreDefaultLocalState()
		{
			for (int i = 0; i < bones.Length; i++)
			{
				bones[i].StoreDefaultLocalState();
			}
		}

		public override void FixTransforms()
		{
			if (!(IKPositionWeight <= 0f))
			{
				for (int i = 0; i < bones.Length; i++)
				{
					bones[i].FixTransform();
				}
			}
		}

		public override bool IsValid(ref string message)
		{
			if (bones.Length == 0)
			{
				message = "IK chain has no Bones.";
				return false;
			}
			if (bones.Length < minBones)
			{
				message = "IK chain has less than " + minBones + " Bones.";
				return false;
			}
			Bone[] array = bones;
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i].transform == null)
				{
					message = "One of the Bones is null.";
					return false;
				}
			}
			Transform transform = IKSolver.ContainsDuplicateBone(bones);
			if (transform != null)
			{
				message = transform.name + " is represented multiple times in the Bones.";
				return false;
			}
			if (!allowCommonParent && !IKSolver.HierarchyIsValid(bones))
			{
				message = "Invalid bone hierarchy detected. IK requires for it's bones to be parented to each other in descending order.";
				return false;
			}
			if (!boneLengthCanBeZero)
			{
				for (int j = 0; j < bones.Length - 1; j++)
				{
					if ((bones[j].transform.position - bones[j + 1].transform.position).magnitude == 0f)
					{
						message = "Bone " + j + " length is zero.";
						return false;
					}
				}
			}
			return true;
		}

		public override Point[] GetPoints()
		{
			return bones;
		}

		public override Point GetPoint(Transform transform)
		{
			for (int i = 0; i < bones.Length; i++)
			{
				if (bones[i].transform == transform)
				{
					return bones[i];
				}
			}
			return null;
		}

		protected override void OnInitiate()
		{
		}

		protected override void OnUpdate()
		{
		}

		protected void InitiateBones()
		{
			chainLength = 0f;
			for (int i = 0; i < bones.Length; i++)
			{
				if (i < bones.Length - 1)
				{
					bones[i].length = (bones[i].transform.position - bones[i + 1].transform.position).magnitude;
					chainLength += bones[i].length;
					Vector3 position = bones[i + 1].transform.position;
					bones[i].axis = Quaternion.Inverse(bones[i].transform.rotation) * (position - bones[i].transform.position);
					if (bones[i].rotationLimit != null)
					{
						if (XY && !(bones[i].rotationLimit is RotationLimitHinge))
						{
							Warning.Log("Only Hinge Rotation Limits should be used on 2D IK solvers.", bones[i].transform);
						}
						bones[i].rotationLimit.Disable();
					}
				}
				else
				{
					bones[i].axis = Quaternion.Inverse(bones[i].transform.rotation) * (bones[bones.Length - 1].transform.position - bones[0].transform.position);
				}
			}
		}

		protected Vector3 GetSingularityOffset()
		{
			if (!SingularityDetected())
			{
				return Vector3.zero;
			}
			Vector3 normalized = (IKPosition - bones[0].transform.position).normalized;
			Vector3 rhs = new Vector3(normalized.y, normalized.z, normalized.x);
			if (useRotationLimits && bones[bones.Length - 2].rotationLimit != null && bones[bones.Length - 2].rotationLimit is RotationLimitHinge)
			{
				rhs = bones[bones.Length - 2].transform.rotation * bones[bones.Length - 2].rotationLimit.axis;
			}
			return Vector3.Cross(normalized, rhs) * bones[bones.Length - 2].length * 0.5f;
		}

		private bool SingularityDetected()
		{
			if (!base.initiated)
			{
				return false;
			}
			Vector3 vector = bones[bones.Length - 1].transform.position - bones[0].transform.position;
			Vector3 vector2 = IKPosition - bones[0].transform.position;
			float magnitude = vector.magnitude;
			float magnitude2 = vector2.magnitude;
			if (magnitude < magnitude2)
			{
				return false;
			}
			if (magnitude < chainLength - bones[bones.Length - 2].length * 0.1f)
			{
				return false;
			}
			if (magnitude == 0f)
			{
				return false;
			}
			if (magnitude2 == 0f)
			{
				return false;
			}
			if (magnitude2 > magnitude)
			{
				return false;
			}
			if (Vector3.Dot(vector / magnitude, vector2 / magnitude2) < 0.999f)
			{
				return false;
			}
			return true;
		}
	}
	[Serializable]
	public class IKSolverLeg : IKSolver
	{
		[Range(0f, 1f)]
		public float IKRotationWeight = 1f;

		public Quaternion IKRotation = Quaternion.identity;

		public Point pelvis = new Point();

		public Point thigh = new Point();

		public Point calf = new Point();

		public Point foot = new Point();

		public Point toe = new Point();

		public IKSolverVR.Leg leg = new IKSolverVR.Leg();

		public Vector3 heelOffset;

		private Vector3[] positions = new Vector3[6];

		private Quaternion[] rotations = new Quaternion[6];

		public override bool IsValid(ref string message)
		{
			if (pelvis.transform == null || thigh.transform == null || calf.transform == null || foot.transform == null || toe.transform == null)
			{
				message = "Please assign all bone slots of the Leg IK solver.";
				return false;
			}
			UnityEngine.Object[] objects = new Transform[5] { pelvis.transform, thigh.transform, calf.transform, foot.transform, toe.transform };
			Transform transform = (Transform)Hierarchy.ContainsDuplicate(objects);
			if (transform != null)
			{
				message = transform.name + " is represented multiple times in the LegIK.";
				return false;
			}
			return true;
		}

		public bool SetChain(Transform pelvis, Transform thigh, Transform calf, Transform foot, Transform toe, Transform root)
		{
			this.pelvis.transform = pelvis;
			this.thigh.transform = thigh;
			this.calf.transform = calf;
			this.foot.transform = foot;
			this.toe.transform = toe;
			Initiate(root);
			return base.initiated;
		}

		public override Point[] GetPoints()
		{
			return new Point[5] { pelvis, thigh, calf, foot, toe };
		}

		public override Point GetPoint(Transform transform)
		{
			if (pelvis.transform == transform)
			{
				return pelvis;
			}
			if (thigh.transform == transform)
			{
				return thigh;
			}
			if (calf.transform == transform)
			{
				return calf;
			}
			if (foot.transform == transform)
			{
				return foot;
			}
			if (toe.transform == transform)
			{
				return toe;
			}
			return null;
		}

		public override void StoreDefaultLocalState()
		{
			thigh.StoreDefaultLocalState();
			calf.StoreDefaultLocalState();
			foot.StoreDefaultLocalState();
			toe.StoreDefaultLocalState();
		}

		public override void FixTransforms()
		{
			thigh.FixTransform();
			calf.FixTransform();
			foot.FixTransform();
			toe.FixTransform();
		}

		protected override void OnInitiate()
		{
			IKPosition = toe.transform.position;
			IKRotation = toe.transform.rotation;
			Read();
		}

		protected override void OnUpdate()
		{
			Read();
			Solve();
			Write();
		}

		private void Solve()
		{
			leg.heelPositionOffset += heelOffset;
			leg.PreSolve();
			leg.ApplyOffsets();
			leg.Solve();
			leg.ResetOffsets();
		}

		private void Read()
		{
			leg.IKPosition = IKPosition;
			leg.positionWeight = IKPositionWeight;
			leg.IKRotation = IKRotation;
			leg.rotationWeight = IKRotationWeight;
			positions[0] = root.position;
			positions[1] = pelvis.transform.position;
			positions[2] = thigh.transform.position;
			positions[3] = calf.transform.position;
			positions[4] = foot.transform.position;
			positions[5] = toe.transform.position;
			rotations[0] = root.rotation;
			rotations[1] = pelvis.transform.rotation;
			rotations[2] = thigh.transform.rotation;
			rotations[3] = calf.transform.rotation;
			rotations[4] = foot.transform.rotation;
			rotations[5] = toe.transform.rotation;
			leg.Read(positions, rotations, hasChest: false, hasNeck: false, hasShoulders: false, hasToes: true, 1, 2);
		}

		private void Write()
		{
			leg.Write(ref positions, ref rotations);
			thigh.transform.rotation = rotations[2];
			calf.transform.rotation = rotations[3];
			foot.transform.rotation = rotations[4];
			toe.transform.rotation = rotations[5];
		}
	}
	[Serializable]
	public class IKSolverLimb : IKSolverTrigonometric
	{
		[Serializable]
		public enum BendModifier
		{
			Animation,
			Target,
			Parent,
			Arm,
			Goal
		}

		[Serializable]
		public struct AxisDirection
		{
			public Vector3 direction;

			public Vector3 axis;

			public float dot;

			public AxisDirection(Vector3 direction, Vector3 axis)
			{
				this.direction = direction.normalized;
				this.axis = axis.normalized;
				dot = 0f;
			}
		}

		public AvatarIKGoal goal;

		public BendModifier bendModifier;

		[Range(0f, 1f)]
		public float maintainRotationWeight;

		[Range(0f, 1f)]
		public float bendModifierWeight = 1f;

		public Transform bendGoal;

		private bool maintainBendFor1Frame;

		private bool maintainRotationFor1Frame;

		private Quaternion defaultRootRotation;

		private Quaternion parentDefaultRotation;

		private Quaternion bone3RotationBeforeSolve;

		private Quaternion maintainRotation;

		private Quaternion bone3DefaultRotation;

		private Vector3 _bendNormal;

		private Vector3 animationNormal;

		private AxisDirection[] axisDirectionsLeft = new AxisDirection[4];

		private AxisDirection[] axisDirectionsRight = new AxisDirection[4];

		private AxisDirection[] axisDirections
		{
			get
			{
				if (goal == AvatarIKGoal.LeftHand)
				{
					return axisDirectionsLeft;
				}
				return axisDirectionsRight;
			}
		}

		public void MaintainRotation()
		{
			if (base.initiated)
			{
				maintainRotation = bone3.transform.rotation;
				maintainRotationFor1Frame = true;
			}
		}

		public void MaintainBend()
		{
			if (base.initiated)
			{
				animationNormal = bone1.GetBendNormalFromCurrentRotation();
				maintainBendFor1Frame = true;
			}
		}

		protected override void OnInitiateVirtual()
		{
			defaultRootRotation = root.rotation;
			if (bone1.transform.parent != null)
			{
				parentDefaultRotation = Quaternion.Inverse(defaultRootRotation) * bone1.transform.parent.rotation;
			}
			if (bone3.rotationLimit != null)
			{
				bone3.rotationLimit.Disable();
			}
			bone3DefaultRotation = bone3.transform.rotation;
			Vector3 vector = Vector3.Cross(bone2.transform.position - bone1.transform.position, bone3.transform.position - bone2.transform.position);
			if (vector != Vector3.zero)
			{
				bendNormal = vector;
			}
			animationNormal = bendNormal;
			StoreAxisDirections(ref axisDirectionsLeft);
			StoreAxisDirections(ref axisDirectionsRight);
		}

		protected override void OnUpdateVirtual()
		{
			if (IKPositionWeight > 0f)
			{
				bendModifierWeight = Mathf.Clamp(bendModifierWeight, 0f, 1f);
				maintainRotationWeight = Mathf.Clamp(maintainRotationWeight, 0f, 1f);
				_bendNormal = bendNormal;
				bendNormal = GetModifiedBendNormal();
			}
			if (maintainRotationWeight * IKPositionWeight > 0f)
			{
				bone3RotationBeforeSolve = (maintainRotationFor1Frame ? maintainRotation : bone3.transform.rotation);
				maintainRotationFor1Frame = false;
			}
		}

		protected override void OnPostSolveVirtual()
		{
			if (IKPositionWeight > 0f)
			{
				bendNormal = _bendNormal;
			}
			if (maintainRotationWeight * IKPositionWeight > 0f)
			{
				bone3.transform.rotation = Quaternion.Slerp(bone3.transform.rotation, bone3RotationBeforeSolve, maintainRotationWeight * IKPositionWeight);
			}
		}

		public IKSolverLimb()
		{
		}

		public IKSolverLimb(AvatarIKGoal goal)
		{
			this.goal = goal;
		}

		private void StoreAxisDirections(ref AxisDirection[] axisDirections)
		{
			axisDirections[0] = new AxisDirection(Vector3.zero, new Vector3(-1f, 0f, 0f));
			axisDirections[1] = new AxisDirection(new Vector3(0.5f, 0f, -0.2f), new Vector3(-0.5f, -1f, 1f));
			axisDirections[2] = new AxisDirection(new Vector3(-0.5f, -1f, -0.2f), new Vector3(0f, 0.5f, -1f));
			axisDirections[3] = new AxisDirection(new Vector3(-0.5f, -0.5f, 1f), new Vector3(-1f, -1f, -1f));
		}

		private Vector3 GetModifiedBendNormal()
		{
			float num = bendModifierWeight;
			if (num <= 0f)
			{
				return bendNormal;
			}
			switch (bendModifier)
			{
			case BendModifier.Animation:
				if (!maintainBendFor1Frame)
				{
					MaintainBend();
				}
				maintainBendFor1Frame = false;
				return Vector3.Lerp(bendNormal, animationNormal, num);
			case BendModifier.Parent:
			{
				if (bone1.transform.parent == null)
				{
					return bendNormal;
				}
				Quaternion quaternion = bone1.transform.parent.rotation * Quaternion.Inverse(parentDefaultRotation);
				return Quaternion.Slerp(Quaternion.identity, quaternion * Quaternion.Inverse(defaultRootRotation), num) * bendNormal;
			}
			case BendModifier.Target:
			{
				Quaternion b = IKRotation * Quaternion.Inverse(bone3DefaultRotation);
				return Quaternion.Slerp(Quaternion.identity, b, num) * bendNormal;
			}
			case BendModifier.Arm:
			{
				if (bone1.transform.parent == null)
				{
					return bendNormal;
				}
				if (goal == AvatarIKGoal.LeftFoot || goal == AvatarIKGoal.RightFoot)
				{
					if (!Warning.logged)
					{
						LogWarning("Trying to use the 'Arm' bend modifier on a leg.");
					}
					return bendNormal;
				}
				Vector3 normalized = (IKPosition - bone1.transform.position).normalized;
				normalized = Quaternion.Inverse(bone1.transform.parent.rotation * Quaternion.Inverse(parentDefaultRotation)) * normalized;
				if (goal == AvatarIKGoal.LeftHand)
				{
					normalized.x = 0f - normalized.x;
				}
				for (int i = 1; i < axisDirections.Length; i++)
				{
					axisDirections[i].dot = Mathf.Clamp(Vector3.Dot(axisDirections[i].direction, normalized), 0f, 1f);
					axisDirections[i].dot = Interp.Float(axisDirections[i].dot, InterpolationMode.InOutQuintic);
				}
				Vector3 vector2 = axisDirections[0].axis;
				for (int j = 1; j < axisDirections.Length; j++)
				{
					vector2 = Vector3.Slerp(vector2, axisDirections[j].axis, axisDirections[j].dot);
				}
				if (goal == AvatarIKGoal.LeftHand)
				{
					vector2.x = 0f - vector2.x;
					vector2 = -vector2;
				}
				Vector3 vector3 = bone1.transform.parent.rotation * Quaternion.Inverse(parentDefaultRotation) * vector2;
				if (num >= 1f)
				{
					return vector3;
				}
				return Vector3.Lerp(bendNormal, vector3, num);
			}
			case BendModifier.Goal:
			{
				if (bendGoal == null)
				{
					if (!Warning.logged)
					{
						LogWarning("Trying to use the 'Goal' Bend Modifier, but the Bend Goal is unassigned.");
					}
					return bendNormal;
				}
				Vector3 vector = Vector3.Cross(bendGoal.position - bone1.transform.position, IKPosition - bone1.transform.position);
				if (vector == Vector3.zero)
				{
					return bendNormal;
				}
				if (num >= 1f)
				{
					return vector;
				}
				return Vector3.Lerp(bendNormal, vector, num);
			}
			default:
				return bendNormal;
			}
		}
	}
	[Serializable]
	public class IKSolverLookAt : IKSolver
	{
		[Serializable]
		public class LookAtBone : Bone
		{
			public Vector3 forward => transform.rotation * axis;

			public LookAtBone()
			{
			}

			public LookAtBone(Transform transform)
			{
				base.transform = transform;
			}

			public void Initiate(Transform root)
			{
				if (!(transform == null))
				{
					axis = Quaternion.Inverse(transform.rotation) * root.forward;
				}
			}

			public void LookAt(Vector3 direction, float weight)
			{
				Quaternion quaternion = Quaternion.FromToRotation(forward, direction);
				Quaternion rotation = transform.rotation;
				transform.rotation = Quaternion.Lerp(rotation, quaternion * rotation, weight);
			}
		}

		public Transform target;

		public LookAtBone[] spine = new LookAtBone[0];

		public LookAtBone head = new LookAtBone();

		public LookAtBone[] eyes = new LookAtBone[0];

		[Range(0f, 1f)]
		public float bodyWeight = 0.5f;

		[Range(0f, 1f)]
		public float headWeight = 0.5f;

		[Range(0f, 1f)]
		public float eyesWeight = 1f;

		[Range(0f, 1f)]
		public float clampWeight = 0.5f;

		[Range(0f, 1f)]
		public float clampWeightHead = 0.5f;

		[Range(0f, 1f)]
		public float clampWeightEyes = 0.5f;

		[Range(0f, 2f)]
		public int clampSmoothing = 2;

		public AnimationCurve spineWeightCurve = new AnimationCurve(new Keyframe(0f, 0.3f), new Keyframe(1f, 1f));

		private Vector3[] spineForwards = new Vector3[0];

		private Vector3[] headForwards = new Vector3[1];

		private Vector3[] eyeForward = new Vector3[1];

		private bool spineIsValid
		{
			get
			{
				if (spine == null)
				{
					return false;
				}
				if (spine.Length == 0)
				{
					return true;
				}
				for (int i = 0; i < spine.Length; i++)
				{
					if (spine[i] == null || spine[i].transform == null)
					{
						return false;
					}
				}
				return true;
			}
		}

		private bool spineIsEmpty => spine.Length == 0;

		private bool headIsValid
		{
			get
			{
				if (head == null)
				{
					return false;
				}
				return true;
			}
		}

		private bool headIsEmpty => head.transform == null;

		private bool eyesIsValid
		{
			get
			{
				if (eyes == null)
				{
					return false;
				}
				if (eyes.Length == 0)
				{
					return true;
				}
				for (int i = 0; i < eyes.Length; i++)
				{
					if (eyes[i] == null || eyes[i].transform == null)
					{
						return false;
					}
				}
				return true;
			}
		}

		private bool eyesIsEmpty => eyes.Length == 0;

		public void SetLookAtWeight(float weight)
		{
			IKPositionWeight = Mathf.Clamp(weight, 0f, 1f);
		}

		public void SetLookAtWeight(float weight, float bodyWeight)
		{
			IKPositionWeight = Mathf.Clamp(weight, 0f, 1f);
			this.bodyWeight = Mathf.Clamp(bodyWeight, 0f, 1f);
		}

		public void SetLookAtWeight(float weight, float bodyWeight, float headWeight)
		{
			IKPositionWeight = Mathf.Clamp(weight, 0f, 1f);
			this.bodyWeight = Mathf.Clamp(bodyWeight, 0f, 1f);
			this.headWeight = Mathf.Clamp(headWeight, 0f, 1f);
		}

		public void SetLookAtWeight(float weight, float bodyWeight, float headWeight, float eyesWeight)
		{
			IKPositionWeight = Mathf.Clamp(weight, 0f, 1f);
			this.bodyWeight = Mathf.Clamp(bodyWeight, 0f, 1f);
			this.headWeight = Mathf.Clamp(headWeight, 0f, 1f);
			this.eyesWeight = Mathf.Clamp(eyesWeight, 0f, 1f);
		}

		public void SetLookAtWeight(float weight, float bodyWeight, float headWeight, float eyesWeight, float clampWeight)
		{
			IKPositionWeight = Mathf.Clamp(weight, 0f, 1f);
			this.bodyWeight = Mathf.Clamp(bodyWeight, 0f, 1f);
			this.headWeight = Mathf.Clamp(headWeight, 0f, 1f);
			this.eyesWeight = Mathf.Clamp(eyesWeight, 0f, 1f);
			this.clampWeight = Mathf.Clamp(clampWeight, 0f, 1f);
			clampWeightHead = this.clampWeight;
			clampWeightEyes = this.clampWeight;
		}

		public void SetLookAtWeight(float weight, float bodyWeight = 0f, float headWeight = 1f, float eyesWeight = 0.5f, float clampWeight = 0.5f, float clampWeightHead = 0.5f, float clampWeightEyes = 0.3f)
		{
			IKPositionWeight = Mathf.Clamp(weight, 0f, 1f);
			this.bodyWeight = Mathf.Clamp(bodyWeight, 0f, 1f);
			this.headWeight = Mathf.Clamp(headWeight, 0f, 1f);
			this.eyesWeight = Mathf.Clamp(eyesWeight, 0f, 1f);
			this.clampWeight = Mathf.Clamp(clampWeight, 0f, 1f);
			this.clampWeightHead = Mathf.Clamp(clampWeightHead, 0f, 1f);
			this.clampWeightEyes = Mathf.Clamp(clampWeightEyes, 0f, 1f);
		}

		public override void StoreDefaultLocalState()
		{
			for (int i = 0; i < spine.Length; i++)
			{
				spine[i].StoreDefaultLocalState();
			}
			for (int j = 0; j < eyes.Length; j++)
			{
				eyes[j].StoreDefaultLocalState();
			}
			if (head != null && head.transform != null)
			{
				head.StoreDefaultLocalState();
			}
		}

		public override void FixTransforms()
		{
			if (!(IKPositionWeight <= 0f))
			{
				for (int i = 0; i < spine.Length; i++)
				{
					spine[i].FixTransform();
				}
				for (int j = 0; j < eyes.Length; j++)
				{
					eyes[j].FixTransform();
				}
				if (head != null && head.transform != null)
				{
					head.FixTransform();
				}
			}
		}

		public override bool IsValid(ref string message)
		{
			if (!spineIsValid)
			{
				message = "IKSolverLookAt spine setup is invalid. Can't initiate solver.";
				return false;
			}
			if (!headIsValid)
			{
				message = "IKSolverLookAt head transform is null. Can't initiate solver.";
				return false;
			}
			if (!eyesIsValid)
			{
				message = "IKSolverLookAt eyes setup is invalid. Can't initiate solver.";
				return false;
			}
			if (spineIsEmpty && headIsEmpty && eyesIsEmpty)
			{
				message = "IKSolverLookAt eyes setup is invalid. Can't initiate solver.";
				return false;
			}
			Bone[] bones = spine;
			Transform transform = IKSolver.ContainsDuplicateBone(bones);
			if (transform != null)
			{
				message = transform.name + " is represented multiple times in a single IK chain. Can't initiate solver.";
				return false;
			}
			bones = eyes;
			Transform transform2 = IKSolver.ContainsDuplicateBone(bones);
			if (transform2 != null)
			{
				message = transform2.name + " is represented multiple times in a single IK chain. Can't initiate solver.";
				return false;
			}
			return true;
		}

		public override Point[] GetPoints()
		{
			Point[] array = new Point[spine.Length + eyes.Length + ((head.transform != null) ? 1 : 0)];
			for (int i = 0; i < spine.Length; i++)
			{
				array[i] = spine[i];
			}
			int num = 0;
			for (int j = spine.Length; j < array.Length; j++)
			{
				array[j] = eyes[num];
				num++;
			}
			if (head.transform != null)
			{
				array[array.Length - 1] = head;
			}
			return array;
		}

		public override Point GetPoint(Transform transform)
		{
			LookAtBone[] array = spine;
			foreach (LookAtBone lookAtBone in array)
			{
				if (lookAtBone.transform == transform)
				{
					return lookAtBone;
				}
			}
			array = eyes;
			foreach (LookAtBone lookAtBone2 in array)
			{
				if (lookAtBone2.transform == transform)
				{
					return lookAtBone2;
				}
			}
			if (head.transform == transform)
			{
				return head;
			}
			return null;
		}

		public bool SetChain(Transform[] spine, Transform head, Transform[] eyes, Transform root)
		{
			SetBones(spine, ref this.spine);
			this.head = new LookAtBone(head);
			SetBones(eyes, ref this.eyes);
			Initiate(root);
			return base.initiated;
		}

		protected override void OnInitiate()
		{
			if (firstInitiation || !Application.isPlaying)
			{
				if (spine.Length != 0)
				{
					IKPosition = spine[spine.Length - 1].transform.position + root.forward * 3f;
				}
				else if (head.transform != null)
				{
					IKPosition = head.transform.position + root.forward * 3f;
				}
				else if (eyes.Length != 0 && eyes[0].transform != null)
				{
					IKPosition = eyes[0].transform.position + root.forward * 3f;
				}
			}
			LookAtBone[] array = spine;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].Initiate(root);
			}
			if (head != null)
			{
				head.Initiate(root);
			}
			array = eyes;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].Initiate(root);
			}
			if (spineForwards == null || spineForwards.Length != spine.Length)
			{
				spineForwards = new Vector3[spine.Length];
			}
			if (headForwards == null)
			{
				headForwards = new Vector3[1];
			}
			if (eyeForward == null)
			{
				eyeForward = new Vector3[1];
			}
		}

		protected override void OnUpdate()
		{
			if (!(IKPositionWeight <= 0f))
			{
				IKPositionWeight = Mathf.Clamp(IKPositionWeight, 0f, 1f);
				if (target != null)
				{
					IKPosition = target.position;
				}
				SolveSpine();
				SolveHead();
				SolveEyes();
			}
		}

		private void SolveSpine()
		{
			if (!(bodyWeight <= 0f) && !spineIsEmpty)
			{
				Vector3 normalized = (IKPosition - spine[spine.Length - 1].transform.position).normalized;
				GetForwards(ref spineForwards, spine[0].forward, normalized, spine.Length, clampWeight);
				for (int i = 0; i < spine.Length; i++)
				{
					spine[i].LookAt(spineForwards[i], bodyWeight * IKPositionWeight);
				}
			}
		}

		private void SolveHead()
		{
			if (!(headWeight <= 0f) && !headIsEmpty)
			{
				Vector3 vector = ((spine.Length != 0 && spine[spine.Length - 1].transform != null) ? spine[spine.Length - 1].forward : head.forward);
				Vector3 normalized = Vector3.Lerp(vector, (IKPosition - head.transform.position).normalized, headWeight * IKPositionWeight).normalized;
				GetForwards(ref headForwards, vector, normalized, 1, clampWeightHead);
				head.LookAt(headForwards[0], headWeight * IKPositionWeight);
			}
		}

		private void SolveEyes()
		{
			if (!(eyesWeight <= 0f) && !eyesIsEmpty)
			{
				for (int i = 0; i < eyes.Length; i++)
				{
					Vector3 baseForward = ((head.transform != null) ? head.forward : eyes[i].forward);
					GetForwards(ref eyeForward, baseForward, (IKPosition - eyes[i].transform.position).normalized, 1, clampWeightEyes);
					eyes[i].LookAt(eyeForward[0], eyesWeight * IKPositionWeight);
				}
			}
		}

		private Vector3[] GetForwards(ref Vector3[] forwards, Vector3 baseForward, Vector3 targetForward, int bones, float clamp)
		{
			if (clamp >= 1f || IKPositionWeight <= 0f)
			{
				for (int i = 0; i < forwards.Length; i++)
				{
					forwards[i] = baseForward;
				}
				return forwards;
			}
			float num = Vector3.Angle(baseForward, targetForward);
			float num2 = 1f - num / 180f;
			float num3 = ((clamp > 0f) ? Mathf.Clamp(1f - (clamp - num2) / (1f - num2), 0f, 1f) : 1f);
			float num4 = ((clamp > 0f) ? Mathf.Clamp(num2 / clamp, 0f, 1f) : 1f);
			for (int j = 0; j < clampSmoothing; j++)
			{
				num4 = Mathf.Sin(num4 * (float)Math.PI * 0.5f);
			}
			if (forwards.Length == 1)
			{
				forwards[0] = Vector3.Slerp(baseForward, targetForward, num4 * num3);
			}
			else
			{
				float num5 = 1f / (float)(forwards.Length - 1);
				for (int k = 0; k < forwards.Length; k++)
				{
					forwards[k] = Vector3.Slerp(baseForward, targetForward, spineWeightCurve.Evaluate(num5 * (float)k) * num4 * num3);
				}
			}
			return forwards;
		}

		private void SetBones(Transform[] array, ref LookAtBone[] bones)
		{
			if (array == null)
			{
				bones = new LookAtBone[0];
				return;
			}
			if (bones.Length != array.Length)
			{
				bones = new LookAtBone[array.Length];
			}
			for (int i = 0; i < array.Length; i++)
			{
				if (bones[i] == null)
				{
					bones[i] = new LookAtBone(array[i]);
				}
				else
				{
					bones[i].transform = array[i];
				}
			}
		}
	}
	[Serializable]
	public class IKSolverTrigonometric : IKSolver
	{
		[Serializable]
		public class TrigonometricBone : Bone
		{
			private Quaternion targetToLocalSpace;

			private Vector3 defaultLocalBendNormal;

			public void Initiate(Vector3 childPosition, Vector3 bendNormal)
			{
				Quaternion rotation = Quaternion.LookRotation(childPosition - transform.position, bendNormal);
				targetToLocalSpace = QuaTools.RotationToLocalSpace(transform.rotation, rotation);
				defaultLocalBendNormal = Quaternion.Inverse(transform.rotation) * bendNormal;
			}

			public Quaternion GetRotation(Vector3 direction, Vector3 bendNormal)
			{
				return Quaternion.LookRotation(direction, bendNormal) * targetToLocalSpace;
			}

			public Vector3 GetBendNormalFromCurrentRotation()
			{
				return transform.rotation * defaultLocalBendNormal;
			}
		}

		public Transform target;

		[Range(0f, 1f)]
		public float IKRotationWeight = 1f;

		public Quaternion IKRotation = Quaternion.identity;

		public Vector3 bendNormal = Vector3.right;

		public TrigonometricBone bone1 = new TrigonometricBone();

		public TrigonometricBone bone2 = new TrigonometricBone();

		public TrigonometricBone bone3 = new TrigonometricBone();

		protected Vector3 weightIKPosition;

		protected bool directHierarchy = true;

		public void SetBendGoalPosition(Vector3 goalPosition, float weight)
		{
			if (!base.initiated || weight <= 0f)
			{
				return;
			}
			Vector3 vector = Vector3.Cross(goalPosition - bone1.transform.position, IKPosition - bone1.transform.position);
			if (vector != Vector3.zero)
			{
				if (weight >= 1f)
				{
					bendNormal = vector;
				}
				else
				{
					bendNormal = Vector3.Lerp(bendNormal, vector, weight);
				}
			}
		}

		public void SetBendPlaneToCurrent()
		{
			if (base.initiated)
			{
				Vector3 vector = Vector3.Cross(bone2.transform.position - bone1.transform.position, bone3.transform.position - bone2.transform.position);
				if (vector != Vector3.zero)
				{
					bendNormal = vector;
				}
			}
		}

		public void SetIKRotation(Quaternion rotation)
		{
			IKRotation = rotation;
		}

		public void SetIKRotationWeight(float weight)
		{
			IKRotationWeight = Mathf.Clamp(weight, 0f, 1f);
		}

		public Quaternion GetIKRotation()
		{
			return IKRotation;
		}

		public float GetIKRotationWeight()
		{
			return IKRotationWeight;
		}

		public override Point[] GetPoints()
		{
			return new Point[3] { bone1, bone2, bone3 };
		}

		public override Point GetPoint(Transform transform)
		{
			if (bone1.transform == transform)
			{
				return bone1;
			}
			if (bone2.transform == transform)
			{
				return bone2;
			}
			if (bone3.transform == transform)
			{
				return bone3;
			}
			return null;
		}

		public override void StoreDefaultLocalState()
		{
			bone1.StoreDefaultLocalState();
			bone2.StoreDefaultLocalState();
			bone3.StoreDefaultLocalState();
		}

		public override void FixTransforms()
		{
			bone1.FixTransform();
			bone2.FixTransform();
			bone3.FixTransform();
		}

		public override bool IsValid(ref string message)
		{
			if (bone1.transform == null || bone2.transform == null || bone3.transform == null)
			{
				message = "Please assign all Bones to the IK solver.";
				return false;
			}
			UnityEngine.Object[] objects = new Transform[3] { bone1.transform, bone2.transform, bone3.transform };
			Transform transform = (Transform)Hierarchy.ContainsDuplicate(objects);
			if (transform != null)
			{
				message = transform.name + " is represented multiple times in the Bones.";
				return false;
			}
			if (bone1.transform.position == bone2.transform.position)
			{
				message = "first bone position is the same as second bone position.";
				return false;
			}
			if (bone2.transform.position == bone3.transform.position)
			{
				message = "second bone position is the same as third bone position.";
				return false;
			}
			return true;
		}

		public bool SetChain(Transform bone1, Transform bone2, Transform bone3, Transform root)
		{
			this.bone1.transform = bone1;
			this.bone2.transform = bone2;
			this.bone3.transform = bone3;
			Initiate(root);
			return base.initiated;
		}

		public static void Solve(Transform bone1, Transform bone2, Transform bone3, Vector3 targetPosition, Vector3 bendNormal, float weight)
		{
			if (weight <= 0f)
			{
				return;
			}
			targetPosition = Vector3.Lerp(bone3.position, targetPosition, weight);
			Vector3 vector = targetPosition - bone1.position;
			float magnitude = vector.magnitude;
			if (magnitude != 0f)
			{
				float sqrMagnitude = (bone2.position - bone1.position).sqrMagnitude;
				float sqrMagnitude2 = (bone3.position - bone2.position).sqrMagnitude;
				Vector3 bendDirection = Vector3.Cross(vector, bendNormal);
				Vector3 directionToBendPoint = GetDirectionToBendPoint(vector, magnitude, bendDirection, sqrMagnitude, sqrMagnitude2);
				Quaternion quaternion = Quaternion.FromToRotation(bone2.position - bone1.position, directionToBendPoint);
				if (weight < 1f)
				{
					quaternion = Quaternion.Lerp(Quaternion.identity, quaternion, weight);
				}
				bone1.rotation = quaternion * bone1.rotation;
				Quaternion quaternion2 = Quaternion.FromToRotation(bone3.position - bone2.position, targetPosition - bone2.position);
				if (weight < 1f)
				{
					quaternion2 = Quaternion.Lerp(Quaternion.identity, quaternion2, weight);
				}
				bone2.rotation = quaternion2 * bone2.rotation;
			}
		}

		private static Vector3 GetDirectionToBendPoint(Vector3 direction, float directionMag, Vector3 bendDirection, float sqrMag1, float sqrMag2)
		{
			float num = (directionMag * directionMag + (sqrMag1 - sqrMag2)) / 2f / directionMag;
			float y = (float)Math.Sqrt(Mathf.Clamp(sqrMag1 - num * num, 0f, float.PositiveInfinity));
			if (direction == Vector3.zero)
			{
				return Vector3.zero;
			}
			return Quaternion.LookRotation(direction, bendDirection) * new Vector3(0f, y, num);
		}

		protected override void OnInitiate()
		{
			if (bendNormal == Vector3.zero)
			{
				bendNormal = Vector3.right;
			}
			OnInitiateVirtual();
			IKPosition = bone3.transform.position;
			IKRotation = bone3.transform.rotation;
			InitiateBones();
			directHierarchy = IsDirectHierarchy();
		}

		private bool IsDirectHierarchy()
		{
			if (bone3.transform.parent != bone2.transform)
			{
				return false;
			}
			if (bone2.transform.parent != bone1.transform)
			{
				return false;
			}
			return true;
		}

		private void InitiateBones()
		{
			bone1.Initiate(bone2.transform.position, bendNormal);
			bone2.Initiate(bone3.transform.position, bendNormal);
			SetBendPlaneToCurrent();
		}

		protected override void OnUpdate()
		{
			IKPositionWeight = Mathf.Clamp(IKPositionWeight, 0f, 1f);
			IKRotationWeight = Mathf.Clamp(IKRotationWeight, 0f, 1f);
			if (target != null)
			{
				IKPosition = target.position;
				IKRotation = target.rotation;
			}
			OnUpdateVirtual();
			if (IKPositionWeight > 0f)
			{
				if (!directHierarchy)
				{
					bone1.Initiate(bone2.transform.position, bendNormal);
					bone2.Initiate(bone3.transform.position, bendNormal);
				}
				bone1.sqrMag = (bone2.transform.position - bone1.transform.position).sqrMagnitude;
				bone2.sqrMag = (bone3.transform.position - bone2.transform.position).sqrMagnitude;
				if (bendNormal == Vector3.zero && !Warning.logged)
				{
					LogWarning("IKSolverTrigonometric Bend Normal is Vector3.zero.");
				}
				weightIKPosition = Vector3.Lerp(bone3.transform.position, IKPosition, IKPositionWeight);
				Vector3 vector = Vector3.Lerp(bone1.GetBendNormalFromCurrentRotation(), bendNormal, IKPositionWeight);
				Vector3 vector2 = Vector3.Lerp(bone2.transform.position - bone1.transform.position, GetBendDirection(weightIKPosition, vector), IKPositionWeight);
				if (vector2 == Vector3.zero)
				{
					vector2 = bone2.transform.position - bone1.transform.position;
				}
				bone1.transform.rotation = bone1.GetRotation(vector2, vector);
				bone2.transform.rotation = bone2.GetRotation(weightIKPosition - bone2.transform.position, bone2.GetBendNormalFromCurrentRotation());
			}
			if (IKRotationWeight > 0f)
			{
				bone3.transform.rotation = Quaternion.Slerp(bone3.transform.rotation, IKRotation, IKRotationWeight);
			}
			OnPostSolveVirtual();
		}

		protected virtual void OnInitiateVirtual()
		{
		}

		protected virtual void OnUpdateVirtual()
		{
		}

		protected virtual void OnPostSolveVirtual()
		{
		}

		protected Vector3 GetBendDirection(Vector3 IKPosition, Vector3 bendNormal)
		{
			Vector3 vector = IKPosition - bone1.transform.position;
			if (vector == Vector3.zero)
			{
				return Vector3.zero;
			}
			float sqrMagnitude = vector.sqrMagnitude;
			float num = (float)Math.Sqrt(sqrMagnitude);
			float num2 = (sqrMagnitude + bone1.sqrMag - bone2.sqrMag) / 2f / num;
			float y = (float)Math.Sqrt(Mathf.Clamp(bone1.sqrMag - num2 * num2, 0f, float.PositiveInfinity));
			Vector3 upwards = Vector3.Cross(vector, bendNormal);
			return Quaternion.LookRotation(vector, upwards) * new Vector3(0f, y, num2);
		}
	}
	[Serializable]
	public class IKSolverVR : IKSolver
	{
		[Serializable]
		public class Arm : BodyPart
		{
			[Serializable]
			public enum ShoulderRotationMode
			{
				YawPitch,
				FromTo
			}

			[Tooltip("The hand target")]
			public Transform target;

			[Tooltip("The elbow will be bent towards this Transform if 'Bend Goal Weight' > 0.")]
			public Transform bendGoal;

			[Tooltip("Positional weight of the hand target.")]
			[Range(0f, 1f)]
			public float positionWeight = 1f;

			[Tooltip("Rotational weight of the hand target")]
			[Range(0f, 1f)]
			public float rotationWeight = 1f;

			[Tooltip("Different techniques for shoulder bone rotation.")]
			public ShoulderRotationMode shoulderRotationMode;

			[Tooltip("The weight of shoulder rotation")]
			[Range(0f, 1f)]
			public float shoulderRotationWeight = 1f;

			[Tooltip("If greater than 0, will bend the elbow towards the 'Bend Goal' Transform.")]
			[Range(0f, 1f)]
			public float bendGoalWeight;

			[Tooltip("Angular offset of the elbow bending direction.")]
			[Range(-180f, 180f)]
			public float swivelOffset;

			[Tooltip("Local axis of the hand bone that points from the wrist towards the palm. Used for defining hand bone orientation.")]
			public Vector3 wristToPalmAxis = Vector3.zero;

			[Tooltip("Local axis of the hand bone that points from the palm towards the thumb. Used for defining hand bone orientation.")]
			public Vector3 palmToThumbAxis = Vector3.zero;

			[NonSerialized]
			[HideInInspector]
			public Vector3 IKPosition;

			[NonSerialized]
			[HideInInspector]
			public Quaternion IKRotation = Quaternion.identity;

			[NonSerialized]
			[HideInInspector]
			public Vector3 bendDirection = Vector3.back;

			[NonSerialized]
			[HideInInspector]
			public Vector3 handPositionOffset;

			private bool hasShoulder;

			private Vector3 chestForwardAxis;

			private Vector3 chestUpAxis;

			private Quaternion chestRotation = Quaternion.identity;

			private Vector3 chestForward;

			private Vector3 chestUp;

			private Quaternion forearmRelToUpperArm = Quaternion.identity;

			private const float yawOffsetAngle = 45f;

			private const float pitchOffsetAngle = -30f;

			public Vector3 position { get; private set; }

			public Quaternion rotation { get; private set; }

			private VirtualBone shoulder => bones[0];

			private VirtualBone upperArm => bones[1];

			private VirtualBone forearm => bones[2];

			private VirtualBone hand => bones[3];

			protected override void OnRead(Vector3[] positions, Quaternion[] rotations, bool hasChest, bool hasNeck, bool hasShoulders, bool hasToes, int rootIndex, int index)
			{
				Vector3 vector = positions[index];
				Quaternion quaternion = rotations[index];
				Vector3 vector2 = positions[index + 1];
				Quaternion quaternion2 = rotations[index + 1];
				Vector3 vector3 = positions[index + 2];
				Quaternion quaternion3 = rotations[index + 2];
				Vector3 iKPosition = positions[index + 3];
				Quaternion iKRotation = rotations[index + 3];
				if (!initiated)
				{
					IKPosition = iKPosition;
					IKRotation = iKRotation;
					rotation = IKRotation;
					hasShoulder = hasShoulders;
					bones = new VirtualBone[hasShoulder ? 4 : 3];
					if (hasShoulder)
					{
						bones[0] = new VirtualBone(vector, quaternion);
						bones[1] = new VirtualBone(vector2, quaternion2);
						bones[2] = new VirtualBone(vector3, quaternion3);
						bones[3] = new VirtualBone(iKPosition, iKRotation);
					}
					else
					{
						bones[0] = new VirtualBone(vector2, quaternion2);
						bones[1] = new VirtualBone(vector3, quaternion3);
						bones[2] = new VirtualBone(iKPosition, iKRotation);
					}
					chestForwardAxis = Quaternion.Inverse(rootRotation) * (rotations[0] * Vector3.forward);
					chestUpAxis = Quaternion.Inverse(rootRotation) * (rotations[0] * Vector3.up);
				}
				if (hasShoulder)
				{
					bones[0].Read(vector, quaternion);
					bones[1].Read(vector2, quaternion2);
					bones[2].Read(vector3, quaternion3);
					bones[3].Read(iKPosition, iKRotation);
				}
				else
				{
					bones[0].Read(vector2, quaternion2);
					bones[1].Read(vector3, quaternion3);
					bones[2].Read(iKPosition, iKRotation);
				}
			}

			public override void PreSolve()
			{
				if (target != null)
				{
					IKPosition = target.position;
					IKRotation = target.rotation;
				}
				position = V3Tools.Lerp(hand.solverPosition, IKPosition, positionWeight);
				rotation = QuaTools.Lerp(hand.solverRotation, IKRotation, rotationWeight);
				shoulder.axis = shoulder.axis.normalized;
				forearmRelToUpperArm = Quaternion.Inverse(upperArm.solverRotation) * forearm.solverRotation;
			}

			public override void ApplyOffsets()
			{
				position += handPositionOffset;
			}

			public void Solve(bool isLeft)
			{
				chestRotation = Quaternion.LookRotation(rootRotation * chestForwardAxis, rootRotation * chestUpAxis);
				chestForward = chestRotation * Vector3.forward;
				chestUp = chestRotation * Vector3.up;
				if (hasShoulder && shoulderRotationWeight > 0f)
				{
					switch (shoulderRotationMode)
					{
					case ShoulderRotationMode.YawPitch:
					{
						Vector3 normalized = (position - shoulder.solverPosition).normalized;
						float num3 = (isLeft ? 45f : (-45f));
						Quaternion quaternion2 = Quaternion.AngleAxis((isLeft ? (-90f) : 90f) + num3, chestUp) * chestRotation;
						Vector3 lhs = Quaternion.Inverse(quaternion2) * normalized;
						float num4 = Mathf.Atan2(lhs.x, lhs.z) * 57.29578f;
						float f = Vector3.Dot(lhs, Vector3.up);
						f = 1f - Mathf.Abs(f);
						num4 *= f;
						num4 -= num3;
						num4 = DamperValue(num4, -45f - num3, 45f - num3, 0.7f);
						Vector3 fromDirection = shoulder.solverRotation * shoulder.axis;
						Vector3 toDirection = quaternion2 * (Quaternion.AngleAxis(num4, Vector3.up) * Vector3.forward);
						Quaternion quaternion3 = Quaternion.FromToRotation(fromDirection, toDirection);
						quaternion2 = Quaternion.AngleAxis(isLeft ? (-90f) : 90f, chestUp) * chestRotation;
						quaternion2 = Quaternion.AngleAxis(isLeft ? (-30f) : 30f, chestForward) * quaternion2;
						normalized = position - (shoulder.solverPosition + chestRotation * (isLeft ? Vector3.right : Vector3.left) * base.mag);
						lhs = Quaternion.Inverse(quaternion2) * normalized;
						float num5 = Mathf.Atan2(lhs.y, lhs.z) * 57.29578f;
						num5 -= -30f;
						num5 = DamperValue(num5, -15f, 75f);
						Quaternion b2 = Quaternion.AngleAxis(0f - num5, quaternion2 * Vector3.right) * quaternion3;
						if (shoulderRotationWeight * positionWeight < 1f)
						{
							b2 = Quaternion.Lerp(Quaternion.identity, b2, shoulderRotationWeight * positionWeight);
						}
						VirtualBone.RotateBy(bones, b2);
						VirtualBone.SolveTrigonometric(bones, 1, 2, 3, position, GetBendNormal(position - upperArm.solverPosition), positionWeight);
						float angle = Mathf.Clamp(num5 * 2f * positionWeight, 0f, 180f);
						shoulder.solverRotation = Quaternion.AngleAxis(angle, shoulder.solverRotation * (isLeft ? shoulder.axis : (-shoulder.axis))) * shoulder.solverRotation;
						upperArm.solverRotation = Quaternion.AngleAxis(angle, upperArm.solverRotation * (isLeft ? upperArm.axis : (-upperArm.axis))) * upperArm.solverRotation;
						break;
					}
					case ShoulderRotationMode.FromTo:
					{
						Quaternion solverRotation = shoulder.solverRotation;
						Quaternion b = Quaternion.FromToRotation((upperArm.solverPosition - shoulder.solverPosition).normalized + chestForward, position - shoulder.solverPosition);
						b = Quaternion.Slerp(Quaternion.identity, b, 0.5f * shoulderRotationWeight * positionWeight);
						VirtualBone.RotateBy(bones, b);
						VirtualBone.SolveTrigonometric(bones, 0, 2, 3, position, Vector3.Cross(forearm.solverPosition - shoulder.solverPosition, hand.solverPosition - shoulder.solverPosition), 0.5f * shoulderRotationWeight * positionWeight);
						VirtualBone.SolveTrigonometric(bones, 1, 2, 3, position, GetBendNormal(position - upperArm.solverPosition), positionWeight);
						Quaternion quaternion = Quaternion.Inverse(Quaternion.LookRotation(chestUp, chestForward));
						Vector3 vector = quaternion * (solverRotation * shoulder.axis);
						Vector3 vector2 = quaternion * (shoulder.solverRotation * shoulder.axis);
						float current = Mathf.Atan2(vector.x, vector.z) * 57.29578f;
						float num = Mathf.Atan2(vector2.x, vector2.z) * 57.29578f;
						float num2 = Mathf.DeltaAngle(current, num);
						if (isLeft)
						{
							num2 = 0f - num2;
						}
						num2 = Mathf.Clamp(num2 * 2f * positionWeight, 0f, 180f);
						shoulder.solverRotation = Quaternion.AngleAxis(num2, shoulder.solverRotation * (isLeft ? shoulder.axis : (-shoulder.axis))) * shoulder.solverRotation;
						upperArm.solverRotation = Quaternion.AngleAxis(num2, upperArm.solverRotation * (isLeft ? upperArm.axis : (-upperArm.axis))) * upperArm.solverRotation;
						break;
					}
					}
				}
				else
				{
					VirtualBone.SolveTrigonometric(bones, 1, 2, 3, position, GetBendNormal(position - upperArm.solverPosition), positionWeight);
				}
				Quaternion quaternion4 = upperArm.solverRotation * forearmRelToUpperArm;
				Quaternion quaternion5 = Quaternion.FromToRotation(quaternion4 * forearm.axis, hand.solverPosition - forearm.solverPosition);
				RotateTo(forearm, quaternion5 * quaternion4, positionWeight);
				if (rotationWeight >= 1f)
				{
					hand.solverRotation = rotation;
				}
				else if (rotationWeight > 0f)
				{
					hand.solverRotation = Quaternion.Lerp(hand.solverRotation, rotation, rotationWeight);
				}
			}

			public override void ResetOffsets()
			{
				handPositionOffset = Vector3.zero;
			}

			public override void Write(ref Vector3[] solvedPositions, ref Quaternion[] solvedRotations)
			{
				if (hasShoulder)
				{
					solvedRotations[index] = shoulder.solverRotation;
				}
				solvedRotations[index + 1] = upperArm.solverRotation;
				solvedRotations[index + 2] = forearm.solverRotation;
				solvedRotations[index + 3] = hand.solverRotation;
			}

			private float DamperValue(float value, float min, float max, float weight = 1f)
			{
				float num = max - min;
				if (weight < 1f)
				{
					float num2 = max - num * 0.5f;
					float num3 = value - num2;
					num3 *= 0.5f;
					value = num2 + num3;
				}
				value -= min;
				float t = Interp.Float(Mathf.Clamp(value / num, 0f, 1f), InterpolationMode.InOutQuintic);
				return Mathf.Lerp(min, max, t);
			}

			private Vector3 GetBendNormal(Vector3 dir)
			{
				if (bendGoal != null)
				{
					bendDirection = bendGoal.position - bones[0].solverPosition;
				}
				if (bendGoalWeight < 1f)
				{
					Vector3 vector = bones[0].solverRotation * bones[0].axis;
					Vector3 down = Vector3.down;
					Vector3 toDirection = Quaternion.Inverse(chestRotation) * dir.normalized + Vector3.forward;
					Vector3 vector2 = Quaternion.FromToRotation(down, toDirection) * Vector3.back;
					Vector3 fromDirection = Quaternion.Inverse(chestRotation) * vector;
					toDirection = Quaternion.Inverse(chestRotation) * dir;
					vector2 = Quaternion.FromToRotation(fromDirection, toDirection) * vector2;
					vector2 = chestRotation * vector2;
					vector2 += vector;
					vector2 -= rotation * wristToPalmAxis;
					vector2 -= rotation * palmToThumbAxis * 0.5f;
					if (bendGoalWeight > 0f)
					{
						vector2 = Vector3.Slerp(vector2, bendDirection, bendGoalWeight);
					}
					if (swivelOffset != 0f)
					{
						vector2 = Quaternion.AngleAxis(swivelOffset, -dir) * vector2;
					}
					return Vector3.Cross(vector2, dir);
				}
				return Vector3.Cross(bendDirection, dir);
			}

			private void Visualize(VirtualBone bone1, VirtualBone bone2, VirtualBone bone3, UnityEngine.Color color)
			{
				UnityEngine.Debug.DrawLine(bone1.solverPosition, bone2.solverPosition, color);
				UnityEngine.Debug.DrawLine(bone2.solverPosition, bone3.solverPosition, color);
			}
		}

		[Serializable]
		public abstract class BodyPart
		{
			[HideInInspector]
			public VirtualBone[] bones = new VirtualBone[0];

			protected bool initiated;

			protected Vector3 rootPosition;

			protected Quaternion rootRotation = Quaternion.identity;

			protected int index = -1;

			public float sqrMag { get; private set; }

			public float mag { get; private set; }

			protected abstract void OnRead(Vector3[] positions, Quaternion[] rotations, bool hasChest, bool hasNeck, bool hasShoulders, bool hasToes, int rootIndex, int index);

			public abstract void PreSolve();

			public abstract void Write(ref Vector3[] solvedPositions, ref Quaternion[] solvedRotations);

			public abstract void ApplyOffsets();

			public abstract void ResetOffsets();

			public void Read(Vector3[] positions, Quaternion[] rotations, bool hasChest, bool hasNeck, bool hasShoulders, bool hasToes, int rootIndex, int index)
			{
				this.index = index;
				rootPosition = positions[rootIndex];
				rootRotation = rotations[rootIndex];
				OnRead(positions, rotations, hasChest, hasNeck, hasShoulders, hasToes, rootIndex, index);
				mag = VirtualBone.PreSolve(ref bones);
				sqrMag = mag * mag;
				initiated = true;
			}

			public void MovePosition(Vector3 position)
			{
				Vector3 vector = position - bones[0].solverPosition;
				VirtualBone[] array = bones;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].solverPosition += vector;
				}
			}

			public void MoveRotation(Quaternion rotation)
			{
				Quaternion rotation2 = QuaTools.FromToRotation(bones[0].solverRotation, rotation);
				VirtualBone.RotateAroundPoint(bones, 0, bones[0].solverPosition, rotation2);
			}

			public void Translate(Vector3 position, Quaternion rotation)
			{
				MovePosition(position);
				MoveRotation(rotation);
			}

			public void TranslateRoot(Vector3 newRootPos, Quaternion newRootRot)
			{
				Vector3 vector = newRootPos - rootPosition;
				rootPosition = newRootPos;
				VirtualBone[] array = bones;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].solverPosition += vector;
				}
				Quaternion rotation = QuaTools.FromToRotation(rootRotation, newRootRot);
				rootRotation = newRootRot;
				VirtualBone.RotateAroundPoint(bones, 0, newRootPos, rotation);
			}

			public void RotateTo(VirtualBone bone, Quaternion rotation, float weight = 1f)
			{
				if (weight <= 0f)
				{
					return;
				}
				Quaternion quaternion = QuaTools.FromToRotation(bone.solverRotation, rotation);
				if (weight < 1f)
				{
					quaternion = Quaternion.Slerp(Quaternion.identity, quaternion, weight);
				}
				for (int i = 0; i < bones.Length; i++)
				{
					if (bones[i] == bone)
					{
						VirtualBone.RotateAroundPoint(bones, i, bones[i].solverPosition, quaternion);
						break;
					}
				}
			}

			public void Visualize(UnityEngine.Color color)
			{
				for (int i = 0; i < bones.Length - 1; i++)
				{
					UnityEngine.Debug.DrawLine(bones[i].solverPosition, bones[i + 1].solverPosition, color);
				}
			}

			public void Visualize()
			{
				Visualize(UnityEngine.Color.white);
			}
		}

		[Serializable]
		public class Footstep
		{
			public float stepSpeed = 3f;

			public Vector3 characterSpaceOffset;

			public Vector3 position;

			public Quaternion rotation = Quaternion.identity;

			public Quaternion stepToRootRot = Quaternion.identity;

			public bool isSupportLeg;

			public Vector3 stepFrom;

			public Vector3 stepTo;

			public Quaternion stepFromRot = Quaternion.identity;

			public Quaternion stepToRot = Quaternion.identity;

			private Quaternion footRelativeToRoot = Quaternion.identity;

			private float supportLegW;

			private float supportLegWV;

			public bool isStepping => stepProgress < 1f;

			public float stepProgress { get; private set; }

			public Footstep(Quaternion rootRotation, Vector3 footPosition, Quaternion footRotation, Vector3 characterSpaceOffset)
			{
				this.characterSpaceOffset = characterSpaceOffset;
				Reset(rootRotation, footPosition, footRotation);
			}

			public void Reset(Quaternion rootRotation, Vector3 footPosition, Quaternion footRotation)
			{
				position = footPosition;
				rotation = footRotation;
				stepFrom = position;
				stepTo = position;
				stepFromRot = rotation;
				stepToRot = rotation;
				stepToRootRot = rootRotation;
				stepProgress = 1f;
				footRelativeToRoot = Quaternion.Inverse(rootRotation) * rotation;
			}

			public void StepTo(Vector3 p, Quaternion rootRotation)
			{
				stepFrom = position;
				stepTo = p;
				stepFromRot = rotation;
				stepToRootRot = rootRotation;
				stepToRot = rootRotation * footRelativeToRoot;
				stepProgress = 0f;
			}

			public void UpdateStepping(Vector3 p, Quaternion rootRotation, float speed)
			{
				stepTo = Vector3.Lerp(stepTo, p, Time.deltaTime * speed);
				stepToRot = Quaternion.Lerp(stepToRot, rootRotation * footRelativeToRoot, Time.deltaTime * speed);
				stepToRootRot = stepToRot * Quaternion.Inverse(footRelativeToRoot);
			}

			public void UpdateStanding(Quaternion rootRotation, float minAngle, float speed)
			{
				if (!(speed <= 0f) && !(minAngle >= 180f))
				{
					Quaternion quaternion = rootRotation * footRelativeToRoot;
					float num = Quaternion.Angle(rotation, quaternion);
					if (num > minAngle)
					{
						rotation = Quaternion.RotateTowards(rotation, quaternion, Mathf.Min(Time.deltaTime * speed * (1f - supportLegW), num - minAngle));
					}
				}
			}

			public void Update(InterpolationMode interpolation, UnityEvent onStep)
			{
				float target = (isSupportLeg ? 1f : 0f);
				supportLegW = Mathf.SmoothDamp(supportLegW, target, ref supportLegWV, 0.2f);
				if (isStepping)
				{
					stepProgress = Mathf.MoveTowards(stepProgress, 1f, Time.deltaTime * stepSpeed);
					if (stepProgress >= 1f)
					{
						onStep.Invoke();
					}
					float t = Interp.Float(stepProgress, interpolation);
					position = Vector3.Lerp(stepFrom, stepTo, t);
					rotation = Quaternion.Lerp(stepFromRot, stepToRot, t);
				}
			}
		}

		[Serializable]
		public class Leg : BodyPart
		{
			[Tooltip("The toe/foot target.")]
			public Transform target;

			[Tooltip("The knee will be bent towards this Transform if 'Bend Goal Weight' > 0.")]
			public Transform bendGoal;

			[Tooltip("Positional weight of the toe/foot target.")]
			[Range(0f, 1f)]
			public float positionWeight;

			[Tooltip("Rotational weight of the toe/foot target.")]
			[Range(0f, 1f)]
			public float rotationWeight;

			[Tooltip("If greater than 0, will bend the knee towards the 'Bend Goal' Transform.")]
			[Range(0f, 1f)]
			public float bendGoalWeight;

			[Tooltip("Angular offset of the knee bending direction.")]
			[Range(-180f, 180f)]
			public float swivelOffset;

			[NonSerialized]
			[HideInInspector]
			public Vector3 IKPosition;

			[NonSerialized]
			[HideInInspector]
			public Quaternion IKRotation = Quaternion.identity;

			[NonSerialized]
			[HideInInspector]
			public Vector3 footPositionOffset;

			[NonSerialized]
			[HideInInspector]
			public Vector3 heelPositionOffset;

			[NonSerialized]
			[HideInInspector]
			public Quaternion footRotationOffset = Quaternion.identity;

			[NonSerialized]
			[HideInInspector]
			public float currentMag;

			private Vector3 footPosition;

			private Quaternion footRotation = Quaternion.identity;

			private Vector3 bendNormal;

			private Quaternion calfRelToThigh = Quaternion.identity;

			public Vector3 position { get; private set; }

			public Quaternion rotation { get; private set; }

			public bool hasToes { get; private set; }

			public VirtualBone thigh => bones[0];

			private VirtualBone calf => bones[1];

			private VirtualBone foot => bones[2];

			private VirtualBone toes => bones[3];

			public VirtualBone lastBone => bones[bones.Length - 1];

			public Vector3 thighRelativeToPelvis { get; private set; }

			protected override void OnRead(Vector3[] positions, Quaternion[] rotations, bool hasChest, bool hasNeck, bool hasShoulders, bool hasToes, int rootIndex, int index)
			{
				Vector3 vector = positions[index];
				Quaternion quaternion = rotations[index];
				Vector3 vector2 = positions[index + 1];
				Quaternion quaternion2 = rotations[index + 1];
				Vector3 iKPosition = positions[index + 2];
				Quaternion iKRotation = rotations[index + 2];
				Vector3 iKPosition2 = positions[index + 3];
				Quaternion iKRotation2 = rotations[index + 3];
				if (!initiated)
				{
					this.hasToes = hasToes;
					bones = new VirtualBone[hasToes ? 4 : 3];
					if (hasToes)
					{
						bones[0] = new VirtualBone(vector, quaternion);
						bones[1] = new VirtualBone(vector2, quaternion2);
						bones[2] = new VirtualBone(iKPosition, iKRotation);
						bones[3] = new VirtualBone(iKPosition2, iKRotation2);
						IKPosition = iKPosition2;
						IKRotation = iKRotation2;
					}
					else
					{
						bones[0] = new VirtualBone(vector, quaternion);
						bones[1] = new VirtualBone(vector2, quaternion2);
						bones[2] = new VirtualBone(iKPosition, iKRotation);
						IKPosition = iKPosition;
						IKRotation = iKRotation;
					}
					rotation = IKRotation;
				}
				if (hasToes)
				{
					bones[0].Read(vector, quaternion);
					bones[1].Read(vector2, quaternion2);
					bones[2].Read(iKPosition, iKRotation);
					bones[3].Read(iKPosition2, iKRotation2);
				}
				else
				{
					bones[0].Read(vector, quaternion);
					bones[1].Read(vector2, quaternion2);
					bones[2].Read(iKPosition, iKRotation);
				}
			}

			public override void PreSolve()
			{
				if (target != null)
				{
					IKPosition = target.position;
					IKRotation = target.rotation;
				}
				footPosition = foot.solverPosition;
				footRotation = foot.solverRotation;
				position = lastBone.solverPosition;
				rotation = lastBone.solverRotation;
				if (rotationWeight > 0f)
				{
					ApplyRotationOffset(QuaTools.FromToRotation(rotation, IKRotation), rotationWeight);
				}
				if (positionWeight > 0f)
				{
					ApplyPositionOffset(IKPosition - position, positionWeight);
				}
				thighRelativeToPelvis = Quaternion.Inverse(rootRotation) * (thigh.solverPosition - rootPosition);
				calfRelToThigh = Quaternion.Inverse(thigh.solverRotation) * calf.solverRotation;
				bendNormal = Vector3.Cross(calf.solverPosition - thigh.solverPosition, foot.solverPosition - calf.solverPosition);
			}

			public override void ApplyOffsets()
			{
				ApplyPositionOffset(footPositionOffset, 1f);
				ApplyRotationOffset(footRotationOffset, 1f);
				Quaternion quaternion = Quaternion.FromToRotation(footPosition - position, footPosition + heelPositionOffset - position);
				footPosition = position + quaternion * (footPosition - position);
				footRotation = quaternion * footRotation;
				float num = 0f;
				if (bendGoal != null && bendGoalWeight > 0f)
				{
					Vector3 vector = Vector3.Cross(bendGoal.position - thigh.solverPosition, foot.solverPosition - thigh.solverPosition);
					Vector3 vector2 = Quaternion.Inverse(Quaternion.LookRotation(bendNormal, thigh.solverPosition - foot.solverPosition)) * vector;
					num = Mathf.Atan2(vector2.x, vector2.z) * 57.29578f * bendGoalWeight;
				}
				float num2 = swivelOffset + num;
				if (num2 != 0f)
				{
					bendNormal = Quaternion.AngleAxis(num2, thigh.solverPosition - lastBone.solverPosition) * bendNormal;
					thigh.solverRotation = Quaternion.AngleAxis(0f - num2, thigh.solverRotation * thigh.axis) * thigh.solverRotation;
				}
			}

			private void ApplyPositionOffset(Vector3 offset, float weight)
			{
				if (!(weight <= 0f))
				{
					offset *= weight;
					footPosition += offset;
					position += offset;
				}
			}

			private void ApplyRotationOffset(Quaternion offset, float weight)
			{
				if (!(weight <= 0f))
				{
					if (weight < 1f)
					{
						offset = Quaternion.Lerp(Quaternion.identity, offset, weight);
					}
					footRotation = offset * footRotation;
					rotation = offset * rotation;
					bendNormal = offset * bendNormal;
					footPosition = position + offset * (footPosition - position);
				}
			}

			public void Solve()
			{
				VirtualBone.SolveTrigonometric(bones, 0, 1, 2, footPosition, bendNormal, 1f);
				RotateTo(foot, footRotation);
				if (hasToes)
				{
					Vector3 vector = Vector3.Cross(foot.solverPosition - thigh.solverPosition, toes.solverPosition - foot.solverPosition);
					VirtualBone.SolveTrigonometric(bones, 0, 2, 3, position, vector, 1f);
					Quaternion quaternion = thigh.solverRotation * calfRelToThigh;
					Quaternion quaternion2 = Quaternion.FromToRotation(quaternion * calf.axis, foot.solverPosition - calf.solverPosition);
					RotateTo(calf, quaternion2 * quaternion);
					toes.solverRotation = rotation;
				}
			}

			public override void Write(ref Vector3[] solvedPositions, ref Quaternion[] solvedRotations)
			{
				solvedRotations[index] = thigh.solverRotation;
				solvedRotations[index + 1] = calf.solverRotation;
				solvedRotations[index + 2] = foot.solverRotation;
				if (hasToes)
				{
					solvedRotations[index + 3] = toes.solverRotation;
				}
			}

			public override void ResetOffsets()
			{
				footPositionOffset = Vector3.zero;
				footRotationOffset = Quaternion.identity;
				heelPositionOffset = Vector3.zero;
			}
		}

		[Serializable]
		public class Locomotion
		{
			[Tooltip("Used for blending in/out of procedural locomotion.")]
			[Range(0f, 1f)]
			public float weight = 1f;

			[Tooltip("Tries to maintain this distance between the legs.")]
			public float footDistance = 0.3f;

			[Tooltip("Makes a step only if step target position is at least this far from the current footstep or the foot does not reach the current footstep anymore or footstep angle is past the 'Angle Threshold'.")]
			public float stepThreshold = 0.4f;

			[Tooltip("Makes a step only if step target position is at least 'Step Threshold' far from the current footstep or the foot does not reach the current footstep anymore or footstep angle is past this value.")]
			public float angleThreshold = 60f;

			[Tooltip("Multiplies angle of the center of mass - center of pressure vector. Larger value makes the character step sooner if losing balance.")]
			public float comAngleMlp = 1f;

			[Tooltip("Maximum magnitude of head/hand target velocity used in prediction.")]
			public float maxVelocity = 0.4f;

			[Tooltip("The amount of head/hand target velocity prediction.")]
			public float velocityFactor = 0.4f;

			[Tooltip("How much can a leg be extended before it is forced to step to another position? 1 means fully stretched.")]
			[Range(0.9f, 1f)]
			public float maxLegStretch = 1f;

			[Tooltip("The speed of lerping the root of the character towards the horizontal mid-point of the footsteps.")]
			public float rootSpeed = 20f;

			[Tooltip("The speed of steps.")]
			public float stepSpeed = 3f;

			[Tooltip("The height of the foot by normalized step progress (0 - 1).")]
			public AnimationCurve stepHeight;

			[Tooltip("The height offset of the heel by normalized step progress (0 - 1).")]
			public AnimationCurve heelHeight;

			[Tooltip("Rotates the foot while the leg is not stepping to relax the twist rotation of the leg if ideal rotation is past this angle.")]
			[Range(0f, 180f)]
			public float relaxLegTwistMinAngle = 20f;

			[Tooltip("The speed of rotating the foot while the leg is not stepping to relax the twist rotation of the leg.")]
			public float relaxLegTwistSpeed = 400f;

			[Tooltip("Interpolation mode of the step.")]
			public InterpolationMode stepInterpolation = InterpolationMode.InOutSine;

			[Tooltip("Offset for the approximated center of mass.")]
			public Vector3 offset;

			[HideInInspector]
			public bool blockingEnabled;

			[HideInInspector]
			public LayerMask blockingLayers;

			[HideInInspector]
			public float raycastRadius = 0.2f;

			[HideInInspector]
			public float raycastHeight = 0.2f;

			[Tooltip("Called when the left foot has finished a step.")]
			public UnityEvent onLeftFootstep = new UnityEvent();

			[Tooltip("Called when the right foot has finished a step")]
			public UnityEvent onRightFootstep = new UnityEvent();

			private Footstep[] footsteps = new Footstep[0];

			private Vector3 lastComPosition;

			private Vector3 comVelocity;

			private int leftFootIndex;

			private int rightFootIndex;

			public Vector3 centerOfMass { get; private set; }

			public Vector3 leftFootstepPosition => footsteps[0].position;

			public Vector3 rightFootstepPosition => footsteps[1].position;

			public Quaternion leftFootstepRotation => footsteps[0].rotation;

			public Quaternion rightFootstepRotation => footsteps[1].rotation;

			public void Initiate(Vector3[] positions, Quaternion[] rotations, bool hasToes)
			{
				leftFootIndex = (hasToes ? 17 : 16);
				rightFootIndex = (hasToes ? 21 : 20);
				footsteps = new Footstep[2]
				{
					new Footstep(rotations[0], positions[leftFootIndex], rotations[leftFootIndex], footDistance * Vector3.left),
					new Footstep(rotations[0], positions[rightFootIndex], rotations[rightFootIndex], footDistance * Vector3.right)
				};
			}

			public void Reset(Vector3[] positions, Quaternion[] rotations)
			{
				lastComPosition = Vector3.Lerp(positions[1], positions[5], 0.25f) + rotations[0] * offset;
				comVelocity = Vector3.zero;
				footsteps[0].Reset(rotations[0], positions[leftFootIndex], rotations[leftFootIndex]);
				footsteps[1].Reset(rotations[0], positions[rightFootIndex], rotations[rightFootIndex]);
			}

			public void AddDeltaRotation(Quaternion delta, Vector3 pivot)
			{
				Vector3 vector = lastComPosition - pivot;
				lastComPosition = pivot + delta * vector;
				Footstep[] array = footsteps;
				foreach (Footstep footstep in array)
				{
					footstep.rotation = delta * footstep.rotation;
					footstep.stepFromRot = delta * footstep.stepFromRot;
					footstep.stepToRot = delta * footstep.stepToRot;
					footstep.stepToRootRot = delta * footstep.stepToRootRot;
					Vector3 vector2 = footstep.position - pivot;
					footstep.position = pivot + delta * vector2;
					Vector3 vector3 = footstep.stepFrom - pivot;
					footstep.stepFrom = pivot + delta * vector3;
					Vector3 vector4 = footstep.stepTo - pivot;
					footstep.stepTo = pivot + delta * vector4;
				}
			}

			public void AddDeltaPosition(Vector3 delta)
			{
				lastComPosition += delta;
				Footstep[] array = footsteps;
				foreach (Footstep obj in array)
				{
					obj.position += delta;
					obj.stepFrom += delta;
					obj.stepTo += delta;
				}
			}

			public void Solve(VirtualBone rootBone, Spine spine, Leg leftLeg, Leg rightLeg, Arm leftArm, Arm rightArm, int supportLegIndex, out Vector3 leftFootPosition, out Vector3 rightFootPosition, out Quaternion leftFootRotation, out Quaternion rightFootRotation, out float leftFootOffset, out float rightFootOffset, out float leftHeelOffset, out float rightHeelOffset)
			{
				if (weight <= 0f)
				{
					leftFootPosition = Vector3.zero;
					rightFootPosition = Vector3.zero;
					leftFootRotation = Quaternion.identity;
					rightFootRotation = Quaternion.identity;
					leftFootOffset = 0f;
					rightFootOffset = 0f;
					leftHeelOffset = 0f;
					rightHeelOffset = 0f;
					return;
				}
				Vector3 vector = rootBone.solverRotation * Vector3.up;
				Vector3 vector2 = spine.pelvis.solverPosition + spine.pelvis.solverRotation * leftLeg.thighRelativeToPelvis;
				Vector3 vector3 = spine.pelvis.solverPosition + spine.pelvis.solverRotation * rightLeg.thighRelativeToPelvis;
				footsteps[0].characterSpaceOffset = footDistance * Vector3.left;
				footsteps[1].characterSpaceOffset = footDistance * Vector3.right;
				Vector3 faceDirection = spine.faceDirection;
				Vector3 vector4 = V3Tools.ExtractVertical(faceDirection, vector, 1f);
				Quaternion quaternion = Quaternion.LookRotation(faceDirection - vector4, vector);
				float num = 1f;
				float num2 = 1f;
				float num3 = 0.2f;
				float num4 = num + num2 + 2f * num3;
				centerOfMass = Vector3.zero;
				centerOfMass += spine.pelvis.solverPosition * num;
				centerOfMass += spine.head.solverPosition * num2;
				centerOfMass += leftArm.position * num3;
				centerOfMass += rightArm.position * num3;
				centerOfMass /= num4;
				centerOfMass += rootBone.solverRotation * offset;
				comVelocity = ((Time.deltaTime > 0f) ? ((centerOfMass - lastComPosition) / Time.deltaTime) : Vector3.zero);
				lastComPosition = centerOfMass;
				comVelocity = Vector3.ClampMagnitude(comVelocity, maxVelocity) * velocityFactor;
				Vector3 vector5 = centerOfMass + comVelocity;
				Vector3 vector6 = V3Tools.PointToPlane(spine.pelvis.solverPosition, rootBone.solverPosition, vector);
				Vector3 vector7 = V3Tools.PointToPlane(vector5, rootBone.solverPosition, vector);
				Vector3 vector8 = Vector3.Lerp(footsteps[0].position, footsteps[1].position, 0.5f);
				float num5 = Vector3.Angle(vector5 - vector8, rootBone.solverRotation * Vector3.up) * comAngleMlp;
				for (int i = 0; i < footsteps.Length; i++)
				{
					footsteps[i].isSupportLeg = supportLegIndex == i;
				}
				for (int j = 0; j < footsteps.Length; j++)
				{
					if (footsteps[j].isStepping)
					{
						Vector3 vector9 = vector7 + rootBone.solverRotation * footsteps[j].characterSpaceOffset;
						if (!StepBlocked(footsteps[j].stepFrom, vector9, rootBone.solverPosition))
						{
							footsteps[j].UpdateStepping(vector9, quaternion, 10f);
						}
					}
					else
					{
						footsteps[j].UpdateStanding(quaternion, relaxLegTwistMinAngle, relaxLegTwistSpeed);
					}
				}
				if (CanStep())
				{
					int num6 = -1;
					float num7 = float.NegativeInfinity;
					for (int k = 0; k < footsteps.Length; k++)
					{
						if (footsteps[k].isStepping)
						{
							continue;
						}
						Vector3 vector10 = vector7 + rootBone.solverRotation * footsteps[k].characterSpaceOffset;
						float num8 = ((k == 0) ? leftLeg.mag : rightLeg.mag);
						Vector3 b = ((k == 0) ? vector2 : vector3);
						float num9 = Vector3.Distance(footsteps[k].position, b);
						bool flag = false;
						if (num9 >= num8 * maxLegStretch)
						{
							vector10 = vector6 + rootBone.solverRotation * footsteps[k].characterSpaceOffset;
							flag = true;
						}
						bool flag2 = false;
						for (int l = 0; l < footsteps.Length; l++)
						{
							if (l != k && !flag)
							{
								if (!(Vector3.Distance(footsteps[k].position, footsteps[l].position) < 0.25f) || !((footsteps[k].position - vector10).sqrMagnitude < (footsteps[l].position - vector10).sqrMagnitude))
								{
									flag2 = GetLineSphereCollision(footsteps[k].position, vector10, footsteps[l].position, 0.25f);
								}
								if (flag2)
								{
									break;
								}
							}
						}
						float num10 = Quaternion.Angle(quaternion, footsteps[k].stepToRootRot);
						if (flag2 && !(num10 > angleThreshold))
						{
							continue;
						}
						float num11 = Vector3.Distance(footsteps[k].position, vector10);
						float num12 = Mathf.Lerp(stepThreshold, stepThreshold * 0.1f, num5 * 0.015f);
						if (flag)
						{
							num12 *= 0.5f;
						}
						if (k == 0)
						{
							num12 *= 0.9f;
						}
						if (!StepBlocked(footsteps[k].position, vector10, rootBone.solverPosition) && (num11 > num12 || num10 > angleThreshold))
						{
							float num13 = 0f;
							num13 -= num11;
							if (num13 > num7)
							{
								num6 = k;
								num7 = num13;
							}
						}
					}
					if (num6 != -1)
					{
						Vector3 p = vector7 + rootBone.solverRotation * footsteps[num6].characterSpaceOffset;
						footsteps[num6].stepSpeed = UnityEngine.Random.Range(stepSpeed, stepSpeed * 1.5f);
						footsteps[num6].StepTo(p, quaternion);
					}
				}
				footsteps[0].Update(stepInterpolation, onLeftFootstep);
				footsteps[1].Update(stepInterpolation, onRightFootstep);
				leftFootPosition = footsteps[0].position;
				rightFootPosition = footsteps[1].position;
				leftFootPosition = V3Tools.PointToPlane(leftFootPosition, leftLeg.lastBone.readPosition, vector);
				rightFootPosition = V3Tools.PointToPlane(rightFootPosition, rightLeg.lastBone.readPosition, vector);
				leftFootOffset = stepHeight.Evaluate(footsteps[0].stepProgress);
				rightFootOffset = stepHeight.Evaluate(footsteps[1].stepProgress);
				leftHeelOffset = heelHeight.Evaluate(footsteps[0].stepProgress);
				rightHeelOffset = heelHeight.Evaluate(footsteps[1].stepProgress);
				leftFootRotation = footsteps[0].rotation;
				rightFootRotation = footsteps[1].rotation;
			}

			private bool StepBlocked(Vector3 fromPosition, Vector3 toPosition, Vector3 rootPosition)
			{
				if ((int)blockingLayers == -1 || !blockingEnabled)
				{
					return false;
				}
				Vector3 vector = fromPosition;
				vector.y = rootPosition.y + raycastHeight + raycastRadius;
				Vector3 direction = toPosition - vector;
				direction.y = 0f;
				RaycastHit hitInfo;
				if (raycastRadius <= 0f)
				{
					return Physics.Raycast(vector, direction, out hitInfo, direction.magnitude, blockingLayers);
				}
				return Physics.SphereCast(vector, raycastRadius, direction, out hitInfo, direction.magnitude, blockingLayers);
			}

			private bool CanStep()
			{
				Footstep[] array = footsteps;
				foreach (Footstep footstep in array)
				{
					if (footstep.isStepping && footstep.stepProgress < 0.8f)
					{
						return false;
					}
				}
				return true;
			}

			private static bool GetLineSphereCollision(Vector3 lineStart, Vector3 lineEnd, Vector3 sphereCenter, float sphereRadius)
			{
				Vector3 forward = lineEnd - lineStart;
				Vector3 vector = sphereCenter - lineStart;
				float num = vector.magnitude - sphereRadius;
				if (num > forward.magnitude)
				{
					return false;
				}
				Vector3 vector2 = Quaternion.Inverse(Quaternion.LookRotation(forward, vector)) * vector;
				if (vector2.z < 0f)
				{
					return num < 0f;
				}
				return vector2.y - sphereRadius < 0f;
			}
		}

		[Serializable]
		public class Spine : BodyPart
		{
			[Tooltip("The head target.")]
			public Transform headTarget;

			[Tooltip("The pelvis target, useful with seated rigs.")]
			public Transform pelvisTarget;

			[Tooltip("Positional weight of the head target.")]
			[Range(0f, 1f)]
			public float positionWeight = 1f;

			[Tooltip("Rotational weight of the head target.")]
			[Range(0f, 1f)]
			public float rotationWeight = 1f;

			[Tooltip("Positional weight of the pelvis target.")]
			[Range(0f, 1f)]
			public float pelvisPositionWeight;

			[Tooltip("Rotational weight of the pelvis target.")]
			[Range(0f, 1f)]
			public float pelvisRotationWeight;

			[Tooltip("If 'Chest Goal Weight' is greater than 0, the chest will be turned towards this Transform.")]
			public Transform chestGoal;

			[Tooltip("Rotational weight of the chest target.")]
			[Range(0f, 1f)]
			public float chestGoalWeight;

			[Tooltip("Minimum height of the head from the root of the character.")]
			public float minHeadHeight = 0.8f;

			[Tooltip("Determines how much the body will follow the position of the head.")]
			[Range(0f, 1f)]
			public float bodyPosStiffness = 0.55f;

			[Tooltip("Determines how much the body will follow the rotation of the head.")]
			[Range(0f, 1f)]
			public float bodyRotStiffness = 0.1f;

			[Tooltip("Determines how much the chest will rotate to the rotation of the head.")]
			[FormerlySerializedAs("chestRotationWeight")]
			[Range(0f, 1f)]
			public float neckStiffness = 0.2f;

			[Tooltip("Clamps chest rotation.")]
			[Range(0f, 1f)]
			public float chestClampWeight = 0.5f;

			[Tooltip("Clamps head rotation.")]
			[Range(0f, 1f)]
			public float headClampWeight = 0.6f;

			[Tooltip("How much will the pelvis maintain it's animated position?")]
			[Range(0f, 1f)]
			public float maintainPelvisPosition = 0.2f;

			[Tooltip("Will automatically rotate the root of the character if the head target has turned past this angle.")]
			[Range(0f, 180f)]
			public float maxRootAngle = 25f;

			[NonSerialized]
			[HideInInspector]
			public Vector3 IKPositionHead;

			[NonSerialized]
			[HideInInspector]
			public Quaternion IKRotationHead = Quaternion.identity;

			[NonSerialized]
			[HideInInspector]
			public Vector3 IKPositionPelvis;

			[NonSerialized]
			[HideInInspector]
			public Quaternion IKRotationPelvis = Quaternion.identity;

			[NonSerialized]
			[HideInInspector]
			public Vector3 goalPositionChest;

			[NonSerialized]
			[HideInInspector]
			public Vector3 pelvisPositionOffset;

			[NonSerialized]
			[HideInInspector]
			public Vector3 chestPositionOffset;

			[NonSerialized]
			[HideInInspector]
			public Vector3 headPositionOffset;

			[NonSerialized]
			[HideInInspector]
			public Quaternion pelvisRotationOffset = Quaternion.identity;

			[NonSerialized]
			[HideInInspector]
			public Quaternion chestRotationOffset = Quaternion.identity;

			[NonSerialized]
			[HideInInspector]
			public Quaternion headRotationOffset = Quaternion.identity;

			[NonSerialized]
			[HideInInspector]
			public Vector3 faceDirection;

			[NonSerialized]
			[HideInInspector]
			public Vector3 locomotionHeadPositionOffset;

			[NonSerialized]
			[HideInInspector]
			public Vector3 headPosition;

			private Quaternion headRotation = Quaternion.identity;

			private Quaternion anchorRelativeToHead = Quaternion.identity;

			private Quaternion pelvisRelativeRotation = Quaternion.identity;

			private Quaternion chestRelativeRotation = Quaternion.identity;

			private Vector3 headDeltaPosition;

			private Quaternion pelvisDeltaRotation = Quaternion.identity;

			private Quaternion chestTargetRotation = Quaternion.identity;

			private int pelvisIndex;

			private int spineIndex = 1;

			private int chestIndex = -1;

			private int neckIndex = -1;

			private int headIndex = -1;

			private float length;

			private bool hasChest;

			private bool hasNeck;

			private float headHeight;

			private float sizeMlp;

			private Vector3 chestForward;

			public VirtualBone pelvis => bones[pelvisIndex];

			public VirtualBone firstSpineBone => bones[spineIndex];

			public VirtualBone chest
			{
				get
				{
					if (hasChest)
					{
						return bones[chestIndex];
					}
					return bones[spineIndex];
				}
			}

			private VirtualBone neck => bones[neckIndex];

			public VirtualBone head => bones[headIndex];

			public Quaternion anchorRotation { get; private set; }

			protected override void OnRead(Vector3[] positions, Quaternion[] rotations, bool hasChest, bool hasNeck, bool hasShoulders, bool hasToes, int rootIndex, int index)
			{
				Vector3 vector = positions[index];
				Quaternion quaternion = rotations[index];
				Vector3 vector2 = positions[index + 1];
				Quaternion quaternion2 = rotations[index + 1];
				Vector3 vector3 = positions[index + 2];
				Quaternion quaternion3 = rotations[index + 2];
				Vector3 position = positions[index + 3];
				Quaternion rotation = rotations[index + 3];
				Vector3 vector4 = positions[index + 4];
				Quaternion quaternion4 = rotations[index + 4];
				if (!hasChest)
				{
					vector3 = vector2;
					quaternion3 = quaternion2;
				}
				if (!initiated)
				{
					this.hasChest = hasChest;
					this.hasNeck = hasNeck;
					headHeight = V3Tools.ExtractVertical(vector4 - positions[0], rotations[0] * Vector3.up, 1f).magnitude;
					int num = 3;
					if (hasChest)
					{
						num++;
					}
					if (hasNeck)
					{
						num++;
					}
					bones = new VirtualBone[num];
					chestIndex = ((!hasChest) ? 1 : 2);
					neckIndex = 1;
					if (hasChest)
					{
						neckIndex++;
					}
					if (hasNeck)
					{
						neckIndex++;
					}
					headIndex = 2;
					if (hasChest)
					{
						headIndex++;
					}
					if (hasNeck)
					{
						headIndex++;
					}
					bones[0] = new VirtualBone(vector, quaternion);
					bones[1] = new VirtualBone(vector2, quaternion2);
					if (hasChest)
					{
						bones[chestIndex] = new VirtualBone(vector3, quaternion3);
					}
					if (hasNeck)
					{
						bones[neckIndex] = new VirtualBone(position, rotation);
					}
					bones[headIndex] = new VirtualBone(vector4, quaternion4);
					pelvisRotationOffset = Quaternion.identity;
					chestRotationOffset = Quaternion.identity;
					headRotationOffset = Quaternion.identity;
					anchorRelativeToHead = Quaternion.Inverse(quaternion4) * rotations[0];
					pelvisRelativeRotation = Quaternion.Inverse(quaternion4) * quaternion;
					chestRelativeRotation = Quaternion.Inverse(quaternion4) * quaternion3;
					chestForward = Quaternion.Inverse(quaternion3) * (rotations[0] * Vector3.forward);
					faceDirection = rotations[0] * Vector3.forward;
					IKPositionHead = vector4;
					IKRotationHead = quaternion4;
					IKPositionPelvis = vector;
					IKRotationPelvis = quaternion;
					goalPositionChest = vector3 + rotations[0] * Vector3.forward;
				}
				bones[0].Read(vector, quaternion);
				bones[1].Read(vector2, quaternion2);
				if (hasChest)
				{
					bones[chestIndex].Read(vector3, quaternion3);
				}
				if (hasNeck)
				{
					bones[neckIndex].Read(position, rotation);
				}
				bones[headIndex].Read(vector4, quaternion4);
				float num2 = Vector3.Distance(vector, vector4);
				sizeMlp = num2 / 0.7f;
			}

			public override void PreSolve()
			{
				if (headTarget != null)
				{
					IKPositionHead = headTarget.position;
					IKRotationHead = headTarget.rotation;
				}
				if (chestGoal != null)
				{
					goalPositionChest = chestGoal.position;
				}
				if (pelvisTarget != null)
				{
					IKPositionPelvis = pelvisTarget.position;
					IKRotationPelvis = pelvisTarget.rotation;
				}
				headPosition = V3Tools.Lerp(head.solverPosition, IKPositionHead, positionWeight);
				headRotation = QuaTools.Lerp(head.solverRotation, IKRotationHead, rotationWeight);
			}

			public override void ApplyOffsets()
			{
				headPosition += headPositionOffset;
				Vector3 vector = rootRotation * Vector3.up;
				if (vector == Vector3.up)
				{
					headPosition.y = Math.Max(rootPosition.y + minHeadHeight, headPosition.y);
				}
				else
				{
					Vector3 vector2 = headPosition - rootPosition;
					Vector3 vector3 = V3Tools.ExtractHorizontal(vector2, vector, 1f);
					Vector3 vector4 = vector2 - vector3;
					if (Vector3.Dot(vector4, vector) > 0f)
					{
						if (vector4.magnitude < minHeadHeight)
						{
							vector4 = vector4.normalized * minHeadHeight;
						}
					}
					else
					{
						vector4 = -vector4.normalized * minHeadHeight;
					}
					headPosition = rootPosition + vector3 + vector4;
				}
				headRotation = headRotationOffset * headRotation;
				headDeltaPosition = headPosition - head.solverPosition;
				pelvisDeltaRotation = QuaTools.FromToRotation(pelvis.solverRotation, headRotation * pelvisRelativeRotation);
				anchorRotation = headRotation * anchorRelativeToHead;
			}

			private void CalculateChestTargetRotation(VirtualBone rootBone, Arm[] arms)
			{
				chestTargetRotation = headRotation * chestRelativeRotation;
				AdjustChestByHands(ref chestTargetRotation, arms);
				faceDirection = Vector3.Cross(anchorRotation * Vector3.right, rootBone.readRotation * Vector3.up) + anchorRotation * Vector3.forward;
			}

			public void Solve(VirtualBone rootBone, Leg[] legs, Arm[] arms)
			{
				CalculateChestTargetRotation(rootBone, arms);
				if (maxRootAngle < 180f)
				{
					Vector3 vector = Quaternion.Inverse(rootBone.solverRotation) * faceDirection;
					float num = Mathf.Atan2(vector.x, vector.z) * 57.29578f;
					float angle = 0f;
					float num2 = 25f;
					if (num > num2)
					{
						angle = num - num2;
					}
					if (num < 0f - num2)
					{
						angle = num + num2;
					}
					rootBone.solverRotation = Quaternion.AngleAxis(angle, rootBone.readRotation * Vector3.up) * rootBone.solverRotation;
				}
				Vector3 solverPosition = pelvis.solverPosition;
				TranslatePelvis(legs, headDeltaPosition, pelvisDeltaRotation);
				VirtualBone.SolveFABRIK(bones, Vector3.Lerp(pelvis.solverPosition, solverPosition, maintainPelvisPosition) + pelvisPositionOffset - chestPositionOffset, headPosition - chestPositionOffset, 1f, 1f, 1, base.mag);
				Bend(bones, pelvisIndex, chestIndex, chestTargetRotation, chestRotationOffset, chestClampWeight, uniformWeight: false, neckStiffness);
				if (chestGoalWeight > 0f)
				{
					Quaternion targetRotation = Quaternion.FromToRotation(bones[chestIndex].solverRotation * chestForward, goalPositionChest - bones[chestIndex].solverPosition) * bones[chestIndex].solverRotation;
					Bend(bones, pelvisIndex, chestIndex, targetRotation, chestRotationOffset, chestClampWeight, uniformWeight: false, chestGoalWeight);
				}
				InverseTranslateToHead(legs, limited: false, useCurrentLegMag: false, Vector3.zero, 1f);
				VirtualBone.SolveFABRIK(bones, Vector3.Lerp(pelvis.solverPosition, solverPosition, maintainPelvisPosition) + pelvisPositionOffset - chestPositionOffset, headPosition - chestPositionOffset, 1f, 1f, 1, base.mag);
				Bend(bones, neckIndex, headIndex, headRotation, headClampWeight, uniformWeight: true, 1f);
				SolvePelvis();
			}

			private void SolvePelvis()
			{
				if (pelvisPositionWeight > 0f)
				{
					Quaternion solverRotation = head.solverRotation;
					Vector3 vector = (IKPositionPelvis + pelvisPositionOffset - pelvis.solverPosition) * pelvisPositionWeight;
					VirtualBone[] array = bones;
					for (int i = 0; i < array.Length; i++)
					{
						array[i].solverPosition += vector;
					}
					Vector3 bendNormal = anchorRotation * Vector3.right;
					if (hasChest && hasNeck)
					{
						VirtualBone.SolveTrigonometric(bones, pelvisIndex, spineIndex, headIndex, headPosition, bendNormal, pelvisPositionWeight * 0.6f);
						VirtualBone.SolveTrigonometric(bones, spineIndex, chestIndex, headIndex, headPosition, bendNormal, pelvisPositionWeight * 0.6f);
						VirtualBone.SolveTrigonometric(bones, chestIndex, neckIndex, headIndex, headPosition, bendNormal, pelvisPositionWeight * 1f);
					}
					else if (hasChest && !hasNeck)
					{
						VirtualBone.SolveTrigonometric(bones, pelvisIndex, spineIndex, headIndex, headPosition, bendNormal, pelvisPositionWeight * 0.75f);
						VirtualBone.SolveTrigonometric(bones, spineIndex, chestIndex, headIndex, headPosition, bendNormal, pelvisPositionWeight * 1f);
					}
					else if (!hasChest && hasNeck)
					{
						VirtualBone.SolveTrigonometric(bones, pelvisIndex, spineIndex, headIndex, headPosition, bendNormal, pelvisPositionWeight * 0.75f);
						VirtualBone.SolveTrigonometric(bones, spineIndex, neckIndex, headIndex, headPosition, bendNormal, pelvisPositionWeight * 1f);
					}
					else if (!hasNeck && !hasChest)
					{
						VirtualBone.SolveTrigonometric(bones, pelvisIndex, spineIndex, headIndex, headPosition, bendNormal, pelvisPositionWeight);
					}
					head.solverRotation = solverRotation;
				}
			}

			public override void Write(ref Vector3[] solvedPositions, ref Quaternion[] solvedRotations)
			{
				solvedPositions[index] = bones[0].solverPosition;
				solvedRotations[index] = bones[0].solverRotation;
				solvedRotations[index + 1] = bones[1].solverRotation;
				if (hasChest)
				{
					solvedRotations[index + 2] = bones[chestIndex].solverRotation;
				}
				if (hasNeck)
				{
					solvedRotations[index + 3] = bones[neckIndex].solverRotation;
				}
				solvedRotations[index + 4] = bones[headIndex].solverRotation;
			}

			public override void ResetOffsets()
			{
				pelvisPositionOffset = Vector3.zero;
				chestPositionOffset = Vector3.zero;
				headPositionOffset = locomotionHeadPositionOffset;
				pelvisRotationOffset = Quaternion.identity;
				chestRotationOffset = Quaternion.identity;
				headRotationOffset = Quaternion.identity;
			}

			private void AdjustChestByHands(ref Quaternion chestTargetRotation, Arm[] arms)
			{
				Quaternion quaternion = Quaternion.Inverse(anchorRotation);
				Vector3 vector = quaternion * (arms[0].position - headPosition) / sizeMlp;
				Vector3 vector2 = quaternion * (arms[1].position - headPosition) / sizeMlp;
				Vector3 forward = Vector3.forward;
				forward.x += vector.x * Mathf.Abs(vector.x);
				forward.x += vector.z * Mathf.Abs(vector.z);
				forward.x += vector2.x * Mathf.Abs(vector2.x);
				forward.x -= vector2.z * Mathf.Abs(vector2.z);
				forward.x *= 5f;
				Quaternion quaternion2 = Quaternion.FromToRotation(Vector3.forward, forward);
				chestTargetRotation = quaternion2 * chestTargetRotation;
				Vector3 up = Vector3.up;
				up.x += vector.y;
				up.x -= vector2.y;
				up.x *= 0.5f;
				quaternion2 = Quaternion.FromToRotation(Vector3.up, anchorRotation * up);
				chestTargetRotation = quaternion2 * chestTargetRotation;
			}

			public void InverseTranslateToHead(Leg[] legs, bool limited, bool useCurrentLegMag, Vector3 offset, float w)
			{
				Vector3 vector = pelvis.solverPosition + (headPosition + offset - head.solverPosition) * w * (1f - pelvisPositionWeight);
				MovePosition(limited ? LimitPelvisPosition(legs, vector, useCurrentLegMag) : vector);
			}

			private void TranslatePelvis(Leg[] legs, Vector3 deltaPosition, Quaternion deltaRotation)
			{
				Vector3 solverPosition = head.solverPosition;
				deltaRotation = QuaTools.ClampRotation(deltaRotation, chestClampWeight, 2);
				Quaternion a = Quaternion.Slerp(Quaternion.identity, deltaRotation, bodyRotStiffness);
				a = Quaternion.Slerp(a, QuaTools.FromToRotation(pelvis.solverRotation, IKRotationPelvis), pelvisRotationWeight);
				VirtualBone.RotateAroundPoint(bones, 0, pelvis.solverPosition, pelvisRotationOffset * a);
				deltaPosition -= head.solverPosition - solverPosition;
				Vector3 vector = rootRotation * Vector3.forward;
				vector.y = 0f;
				float num = deltaPosition.y * 0.35f * headHeight;
				deltaPosition += vector * num;
				MovePosition(LimitPelvisPosition(legs, pelvis.solverPosition + deltaPosition * bodyPosStiffness, useCurrentLegMag: false));
			}

			private Vector3 LimitPelvisPosition(Leg[] legs, Vector3 pelvisPosition, bool useCurrentLegMag, int it = 2)
			{
				if (useCurrentLegMag)
				{
					Leg[] array = legs;
					foreach (Leg leg in array)
					{
						leg.currentMag = Vector3.Distance(leg.thigh.solverPosition, leg.lastBone.solverPosition);
					}
				}
				for (int j = 0; j < it; j++)
				{
					Leg[] array = legs;
					foreach (Leg leg2 in array)
					{
						Vector3 vector = pelvisPosition - pelvis.solverPosition;
						Vector3 vector2 = leg2.thigh.solverPosition + vector;
						Vector3 vector3 = vector2 - leg2.position;
						float maxLength = (useCurrentLegMag ? leg2.currentMag : leg2.mag);
						Vector3 vector4 = leg2.position + Vector3.ClampMagnitude(vector3, maxLength);
						pelvisPosition += vector4 - vector2;
					}
				}
				return pelvisPosition;
			}

			private void Bend(VirtualBone[] bones, int firstIndex, int lastIndex, Quaternion targetRotation, float clampWeight, bool uniformWeight, float w)
			{
				if (w <= 0f || bones.Length == 0)
				{
					return;
				}
				int num = lastIndex + 1 - firstIndex;
				if (num < 1)
				{
					return;
				}
				Quaternion rotation = QuaTools.FromToRotation(bones[lastIndex].solverRotation, targetRotation);
				rotation = QuaTools.ClampRotation(rotation, clampWeight, 2);
				float num2 = (uniformWeight ? (1f / (float)num) : 0f);
				for (int i = firstIndex; i < lastIndex + 1; i++)
				{
					if (!uniformWeight)
					{
						num2 = Mathf.Clamp((i - firstIndex + 1) / num, 0f, 1f);
					}
					VirtualBone.RotateAroundPoint(bones, i, bones[i].solverPosition, Quaternion.Slerp(Quaternion.identity, rotation, num2 * w));
				}
			}

			private void Bend(VirtualBone[] bones, int firstIndex, int lastIndex, Quaternion targetRotation, Quaternion rotationOffset, float clampWeight, bool uniformWeight, float w)
			{
				if (w <= 0f || bones.Length == 0)
				{
					return;
				}
				int num = lastIndex + 1 - firstIndex;
				if (num < 1)
				{
					return;
				}
				Quaternion rotation = QuaTools.FromToRotation(bones[lastIndex].solverRotation, targetRotation);
				rotation = QuaTools.ClampRotation(rotation, clampWeight, 2);
				float num2 = (uniformWeight ? (1f / (float)num) : 0f);
				for (int i = firstIndex; i < lastIndex + 1; i++)
				{
					if (!uniformWeight)
					{
						num2 = Mathf.Clamp((i - firstIndex + 1) / num, 0f, 1f);
					}
					VirtualBone.RotateAroundPoint(bones, i, bones[i].solverPosition, Quaternion.Slerp(Quaternion.Slerp(Quaternion.identity, rotationOffset, num2), rotation, num2 * w));
				}
			}
		}

		[Serializable]
		public enum PositionOffset
		{
			Pelvis,
			Chest,
			Head,
			LeftHand,
			RightHand,
			LeftFoot,
			RightFoot,
			LeftHeel,
			RightHeel
		}

		[Serializable]
		public enum RotationOffset
		{
			Pelvis,
			Chest,
			Head
		}

		[Serializable]
		public class VirtualBone
		{
			public Vector3 readPosition;

			public Quaternion readRotation;

			public Vector3 solverPosition;

			public Quaternion solverRotation;

			public float length;

			public float sqrMag;

			public Vector3 axis;

			public VirtualBone(Vector3 position, Quaternion rotation)
			{
				Read(position, rotation);
			}

			public void Read(Vector3 position, Quaternion rotation)
			{
				readPosition = position;
				readRotation = rotation;
				solverPosition = position;
				solverRotation = rotation;
			}

			public static void SwingRotation(VirtualBone[] bones, int index, Vector3 swingTarget, float weight = 1f)
			{
				if (!(weight <= 0f))
				{
					Quaternion quaternion = Quaternion.FromToRotation(bones[index].solverRotation * bones[index].axis, swingTarget - bones[index].solverPosition);
					if (weight < 1f)
					{
						quaternion = Quaternion.Lerp(Quaternion.identity, quaternion, weight);
					}
					for (int i = index; i < bones.Length; i++)
					{
						bones[i].solverRotation = quaternion * bones[i].solverRotation;
					}
				}
			}

			public static float PreSolve(ref VirtualBone[] bones)
			{
				float num = 0f;
				for (int i = 0; i < bones.Length; i++)
				{
					if (i < bones.Length - 1)
					{
						bones[i].sqrMag = (bones[i + 1].solverPosition - bones[i].solverPosition).sqrMagnitude;
						bones[i].length = Mathf.Sqrt(bones[i].sqrMag);
						num += bones[i].length;
						bones[i].axis = Quaternion.Inverse(bones[i].solverRotation) * (bones[i + 1].solverPosition - bones[i].solverPosition);
					}
					else
					{
						bones[i].sqrMag = 0f;
						bones[i].length = 0f;
					}
				}
				return num;
			}

			public static void RotateAroundPoint(VirtualBone[] bones, int index, Vector3 point, Quaternion rotation)
			{
				for (int i = index; i < bones.Length; i++)
				{
					if (bones[i] != null)
					{
						Vector3 vector = bones[i].solverPosition - point;
						bones[i].solverPosition = point + rotation * vector;
						bones[i].solverRotation = rotation * bones[i].solverRotation;
					}
				}
			}

			public static void RotateBy(VirtualBone[] bones, int index, Quaternion rotation)
			{
				for (int i = index; i < bones.Length; i++)
				{
					if (bones[i] != null)
					{
						Vector3 vector = bones[i].solverPosition - bones[index].solverPosition;
						bones[i].solverPosition = bones[index].solverPosition + rotation * vector;
						bones[i].solverRotation = rotation * bones[i].solverRotation;
					}
				}
			}

			public static void RotateBy(VirtualBone[] bones, Quaternion rotation)
			{
				for (int i = 0; i < bones.Length; i++)
				{
					if (bones[i] != null)
					{
						if (i > 0)
						{
							Vector3 vector = bones[i].solverPosition - bones[0].solverPosition;
							bones[i].solverPosition = bones[0].solverPosition + rotation * vector;
						}
						bones[i].solverRotation = rotation * bones[i].solverRotation;
					}
				}
			}

			public static void RotateTo(VirtualBone[] bones, int index, Quaternion rotation)
			{
				Quaternion rotation2 = QuaTools.FromToRotation(bones[index].solverRotation, rotation);
				RotateAroundPoint(bones, index, bones[index].solverPosition, rotation2);
			}

			public static void SolveTrigonometric(VirtualBone[] bones, int first, int second, int third, Vector3 targetPosition, Vector3 bendNormal, float weight)
			{
				if (weight <= 0f)
				{
					return;
				}
				targetPosition = Vector3.Lerp(bones[third].solverPosition, targetPosition, weight);
				Vector3 vector = targetPosition - bones[first].solverPosition;
				float sqrMagnitude = vector.sqrMagnitude;
				if (sqrMagnitude != 0f)
				{
					float directionMag = Mathf.Sqrt(sqrMagnitude);
					float sqrMagnitude2 = (bones[second].solverPosition - bones[first].solverPosition).sqrMagnitude;
					float sqrMagnitude3 = (bones[third].solverPosition - bones[second].solverPosition).sqrMagnitude;
					Vector3 bendDirection = Vector3.Cross(vector, bendNormal);
					Vector3 directionToBendPoint = GetDirectionToBendPoint(vector, directionMag, bendDirection, sqrMagnitude2, sqrMagnitude3);
					Quaternion quaternion = Quaternion.FromToRotation(bones[second].solverPosition - bones[first].solverPosition, directionToBendPoint);
					if (weight < 1f)
					{
						quaternion = Quaternion.Lerp(Quaternion.identity, quaternion, weight);
					}
					RotateAroundPoint(bones, first, bones[first].solverPosition, quaternion);
					Quaternion quaternion2 = Quaternion.FromToRotation(bones[third].solverPosition - bones[second].solverPosition, targetPosition - bones[second].solverPosition);
					if (weight < 1f)
					{
						quaternion2 = Quaternion.Lerp(Quaternion.identity, quaternion2, weight);
					}
					RotateAroundPoint(bones, second, bones[second].solverPosition, quaternion2);
				}
			}

			private static Vector3 GetDirectionToBendPoint(Vector3 direction, float directionMag, Vector3 bendDirection, float sqrMag1, float sqrMag2)
			{
				float num = (directionMag * directionMag + (sqrMag1 - sqrMag2)) / 2f / directionMag;
				float y = (float)Math.Sqrt(Mathf.Clamp(sqrMag1 - num * num, 0f, float.PositiveInfinity));
				if (direction == Vector3.zero)
				{
					return Vector3.zero;
				}
				return Quaternion.LookRotation(direction, bendDirection) * new Vector3(0f, y, num);
			}

			public static void SolveFABRIK(VirtualBone[] bones, Vector3 startPosition, Vector3 targetPosition, float weight, float minNormalizedTargetDistance, int iterations, float length)
			{
				if (weight <= 0f)
				{
					return;
				}
				if (minNormalizedTargetDistance > 0f)
				{
					Vector3 vector = targetPosition - startPosition;
					float magnitude = vector.magnitude;
					targetPosition = startPosition + vector / magnitude * Mathf.Max(length * minNormalizedTargetDistance, magnitude);
				}
				for (int i = 0; i < iterations; i++)
				{
					bones[bones.Length - 1].solverPosition = Vector3.Lerp(bones[bones.Length - 1].solverPosition, targetPosition, weight);
					for (int num = bones.Length - 2; num > -1; num--)
					{
						bones[num].solverPosition = SolveFABRIKJoint(bones[num].solverPosition, bones[num + 1].solverPosition, bones[num].length);
					}
					bones[0].solverPosition = startPosition;
					for (int j = 1; j < bones.Length; j++)
					{
						bones[j].solverPosition = SolveFABRIKJoint(bones[j].solverPosition, bones[j - 1].solverPosition, bones[j - 1].length);
					}
				}
				for (int k = 0; k < bones.Length - 1; k++)
				{
					SwingRotation(bones, k, bones[k + 1].solverPosition);
				}
			}

			private static Vector3 SolveFABRIKJoint(Vector3 pos1, Vector3 pos2, float length)
			{
				return pos2 + (pos1 - pos2).normalized * length;
			}

			public static void SolveCCD(VirtualBone[] bones, Vector3 targetPosition, float weight, int iterations)
			{
				if (weight <= 0f)
				{
					return;
				}
				for (int i = 0; i < iterations; i++)
				{
					for (int num = bones.Length - 2; num > -1; num--)
					{
						Vector3 fromDirection = bones[bones.Length - 1].solverPosition - bones[num].solverPosition;
						Vector3 toDirection = targetPosition - bones[num].solverPosition;
						Quaternion quaternion = Quaternion.FromToRotation(fromDirection, toDirection);
						if (weight >= 1f)
						{
							RotateBy(bones, num, quaternion);
						}
						else
						{
							RotateBy(bones, num, Quaternion.Lerp(Quaternion.identity, quaternion, weight));
						}
					}
				}
			}
		}

		private Transform[] solverTransforms = new Transform[0];

		private bool hasChest;

		private bool hasNeck;

		private bool hasShoulders;

		private bool hasToes;

		private Vector3[] readPositions = new Vector3[0];

		private Quaternion[] readRotations = new Quaternion[0];

		private Vector3[] solvedPositions = new Vector3[2];

		private Quaternion[] solvedRotations = new Quaternion[22];

		private Vector3 defaultPelvisLocalPosition;

		private Quaternion[] defaultLocalRotations = new Quaternion[21];

		private Vector3 rootV;

		private Vector3 rootVelocity;

		private Vector3 bodyOffset;

		private int supportLegIndex;

		[Tooltip("If true, will keep the toes planted even if head target is out of reach.")]
		public bool plantFeet = true;

		[Tooltip("The spine solver.")]
		public Spine spine = new Spine();

		[Tooltip("The left arm solver.")]
		public Arm leftArm = new Arm();

		[Tooltip("The right arm solver.")]
		public Arm rightArm = new Arm();

		[Tooltip("The left leg solver.")]
		public Leg leftLeg = new Leg();

		[Tooltip("The right leg solver.")]
		public Leg rightLeg = new Leg();

		[Tooltip("The procedural locomotion solver.")]
		public Locomotion locomotion = new Locomotion();

		private Leg[] legs = new Leg[2];

		private Arm[] arms = new Arm[2];

		private Vector3 headPosition;

		private Vector3 headDeltaPosition;

		private Vector3 raycastOriginPelvis;

		private Vector3 lastOffset;

		private Vector3 debugPos1;

		private Vector3 debugPos2;

		private Vector3 debugPos3;

		private Vector3 debugPos4;

		[HideInInspector]
		public VirtualBone rootBone { get; private set; }

		public void SetToReferences(VRIK.References references)
		{
			if (!references.isFilled)
			{
				UnityEngine.Debug.LogError("Invalid references, one or more Transforms are missing.");
				return;
			}
			solverTransforms = references.GetTransforms();
			hasChest = solverTransforms[3] != null;
			hasNeck = solverTransforms[4] != null;
			hasShoulders = solverTransforms[6] != null && solverTransforms[10] != null;
			hasToes = solverTransforms[17] != null && solverTransforms[21] != null;
			readPositions = new Vector3[solverTransforms.Length];
			readRotations = new Quaternion[solverTransforms.Length];
			DefaultAnimationCurves();
			GuessHandOrientations(references, onlyIfZero: true);
		}

		public void GuessHandOrientations(VRIK.References references, bool onlyIfZero)
		{
			if (!references.isFilled)
			{
				UnityEngine.Debug.LogWarning("VRIK References are not filled in, can not guess hand orientations. Right-click on VRIK header and slect 'Guess Hand Orientations' when you have filled in the References.");
				return;
			}
			if (leftArm.wristToPalmAxis == Vector3.zero || !onlyIfZero)
			{
				leftArm.wristToPalmAxis = GuessWristToPalmAxis(references.leftHand, references.leftForearm);
			}
			if (leftArm.palmToThumbAxis == Vector3.zero || !onlyIfZero)
			{
				leftArm.palmToThumbAxis = GuessPalmToThumbAxis(references.leftHand, references.leftForearm);
			}
			if (rightArm.wristToPalmAxis == Vector3.zero || !onlyIfZero)
			{
				rightArm.wristToPalmAxis = GuessWristToPalmAxis(references.rightHand, references.rightForearm);
			}
			if (rightArm.palmToThumbAxis == Vector3.zero || !onlyIfZero)
			{
				rightArm.palmToThumbAxis = GuessPalmToThumbAxis(references.rightHand, references.rightForearm);
			}
		}

		public void DefaultAnimationCurves()
		{
			if (locomotion.stepHeight == null)
			{
				locomotion.stepHeight = new AnimationCurve();
			}
			if (locomotion.heelHeight == null)
			{
				locomotion.heelHeight = new AnimationCurve();
			}
			if (locomotion.stepHeight.keys.Length == 0)
			{
				locomotion.stepHeight.keys = GetSineKeyframes(0.03f);
			}
			if (locomotion.heelHeight.keys.Length == 0)
			{
				locomotion.heelHeight.keys = GetSineKeyframes(0.03f);
			}
		}

		public void AddPositionOffset(PositionOffset positionOffset, Vector3 value)
		{
			switch (positionOffset)
			{
			case PositionOffset.Pelvis:
				spine.pelvisPositionOffset += value;
				break;
			case PositionOffset.Chest:
				spine.chestPositionOffset += value;
				break;
			case PositionOffset.Head:
				spine.headPositionOffset += value;
				break;
			case PositionOffset.LeftHand:
				leftArm.handPositionOffset += value;
				break;
			case PositionOffset.RightHand:
				rightArm.handPositionOffset += value;
				break;
			case PositionOffset.LeftFoot:
				leftLeg.footPositionOffset += value;
				break;
			case PositionOffset.RightFoot:
				rightLeg.footPositionOffset += value;
				break;
			case PositionOffset.LeftHeel:
				leftLeg.heelPositionOffset += value;
				break;
			case PositionOffset.RightHeel:
				rightLeg.heelPositionOffset += value;
				break;
			}
		}

		public void AddRotationOffset(RotationOffset rotationOffset, Vector3 value)
		{
			AddRotationOffset(rotationOffset, Quaternion.Euler(value));
		}

		public void AddRotationOffset(RotationOffset rotationOffset, Quaternion value)
		{
			switch (rotationOffset)
			{
			case RotationOffset.Pelvis:
				spine.pelvisRotationOffset = value * spine.pelvisRotationOffset;
				break;
			case RotationOffset.Chest:
				spine.chestRotationOffset = value * spine.chestRotationOffset;
				break;
			case RotationOffset.Head:
				spine.headRotationOffset = value * spine.headRotationOffset;
				break;
			}
		}

		public void AddPlatformMotion(Vector3 deltaPosition, Quaternion deltaRotation, Vector3 platformPivot)
		{
			locomotion.AddDeltaPosition(deltaPosition);
			raycastOriginPelvis += deltaPosition;
			locomotion.AddDeltaRotation(deltaRotation, platformPivot);
			spine.faceDirection = deltaRotation * spine.faceDirection;
		}

		public void Reset()
		{
			if (base.initiated)
			{
				UpdateSolverTransforms();
				Read(readPositions, readRotations, hasChest, hasNeck, hasShoulders, hasToes);
				spine.faceDirection = rootBone.readRotation * Vector3.forward;
				locomotion.Reset(readPositions, readRotations);
				raycastOriginPelvis = spine.pelvis.readPosition;
			}
		}

		public override void StoreDefaultLocalState()
		{
			defaultPelvisLocalPosition = solverTransforms[1].localPosition;
			for (int i = 1; i < solverTransforms.Length; i++)
			{
				if (solverTransforms[i] != null)
				{
					defaultLocalRotations[i - 1] = solverTransforms[i].localRotation;
				}
			}
		}

		public override void FixTransforms()
		{
			solverTransforms[1].localPosition = defaultPelvisLocalPosition;
			for (int i = 1; i < solverTransforms.Length; i++)
			{
				if (solverTransforms[i] != null)
				{
					solverTransforms[i].localRotation = defaultLocalRotations[i - 1];
				}
			}
		}

		public override Point[] GetPoints()
		{
			UnityEngine.Debug.LogError("GetPoints() is not applicable to IKSolverVR.");
			return null;
		}

		public override Point GetPoint(Transform transform)
		{
			UnityEngine.Debug.LogError("GetPoint is not applicable to IKSolverVR.");
			return null;
		}

		public override bool IsValid(ref string message)
		{
			if (solverTransforms == null || solverTransforms.Length == 0)
			{
				message = "Trying to initiate IKSolverVR with invalid bone references.";
				return false;
			}
			if (leftArm.wristToPalmAxis == Vector3.zero)
			{
				message = "Left arm 'Wrist To Palm Axis' needs to be set in VRIK. Please select the hand bone, set it to the axis that points from the wrist towards the palm. If the arrow points away from the palm, axis must be negative.";
				return false;
			}
			if (rightArm.wristToPalmAxis == Vector3.zero)
			{
				message = "Right arm 'Wrist To Palm Axis' needs to be set in VRIK. Please select the hand bone, set it to the axis that points from the wrist towards the palm. If the arrow points away from the palm, axis must be negative.";
				return false;
			}
			if (leftArm.palmToThumbAxis == Vector3.zero)
			{
				message = "Left arm 'Palm To Thumb Axis' needs to be set in VRIK. Please select the hand bone, set it to the axis that points from the palm towards the thumb. If the arrow points away from the thumb, axis must be negative.";
				return false;
			}
			if (rightArm.palmToThumbAxis == Vector3.zero)
			{
				message = "Right arm 'Palm To Thumb Axis' needs to be set in VRIK. Please select the hand bone, set it to the axis that points from the palm towards the thumb. If the arrow points away from the thumb, axis must be negative.";
				return false;
			}
			return true;
		}

		private Vector3 GetNormal(Transform[] transforms)
		{
			Vector3 zero = Vector3.zero;
			Vector3 zero2 = Vector3.zero;
			for (int i = 0; i < transforms.Length; i++)
			{
				zero2 += transforms[i].position;
			}
			zero2 /= (float)transforms.Length;
			for (int j = 0; j < transforms.Length - 1; j++)
			{
				zero += Vector3.Cross(transforms[j].position - zero2, transforms[j + 1].position - zero2).normalized;
			}
			return zero;
		}

		private Vector3 GuessWristToPalmAxis(Transform hand, Transform forearm)
		{
			Vector3 vector = forearm.position - hand.position;
			Vector3 vector2 = AxisTools.ToVector3(AxisTools.GetAxisToDirection(hand, vector));
			if (Vector3.Dot(vector, hand.rotation * vector2) > 0f)
			{
				vector2 = -vector2;
			}
			return vector2;
		}

		private Vector3 GuessPalmToThumbAxis(Transform hand, Transform forearm)
		{
			if (hand.childCount == 0)
			{
				UnityEngine.Debug.LogWarning("Hand " + hand.name + " does not have any fingers, VRIK can not guess the hand bone's orientation. Please assign 'Wrist To Palm Axis' and 'Palm To Thumb Axis' manually for both arms in VRIK settings.", hand);
				return Vector3.zero;
			}
			float num = float.PositiveInfinity;
			int index = 0;
			for (int i = 0; i < hand.childCount; i++)
			{
				float num2 = Vector3.SqrMagnitude(hand.GetChild(i).position - hand.position);
				if (num2 < num)
				{
					num = num2;
					index = i;
				}
			}
			Vector3 vector = Vector3.Cross(Vector3.Cross(hand.position - forearm.position, hand.GetChild(index).position - hand.position), hand.position - forearm.position);
			Vector3 vector2 = AxisTools.ToVector3(AxisTools.GetAxisToDirection(hand, vector));
			if (Vector3.Dot(vector, hand.rotation * vector2) < 0f)
			{
				vector2 = -vector2;
			}
			return vector2;
		}

		private static Keyframe[] GetSineKeyframes(float mag)
		{
			Keyframe[] array = new Keyframe[3];
			array[0].time = 0f;
			array[0].value = 0f;
			array[1].time = 0.5f;
			array[1].value = mag;
			array[2].time = 1f;
			array[2].value = 0f;
			return array;
		}

		private void UpdateSolverTransforms()
		{
			for (int i = 0; i < solverTransforms.Length; i++)
			{
				if (solverTransforms[i] != null)
				{
					readPositions[i] = solverTransforms[i].position;
					readRotations[i] = solverTransforms[i].rotation;
				}
			}
		}

		protected override void OnInitiate()
		{
			UpdateSolverTransforms();
			Read(readPositions, readRotations, hasChest, hasNeck, hasShoulders, hasToes);
		}

		protected override void OnUpdate()
		{
			if (IKPositionWeight > 0f)
			{
				UpdateSolverTransforms();
				Read(readPositions, readRotations, hasChest, hasNeck, hasShoulders, hasToes);
				Solve();
				Write();
				WriteTransforms();
			}
		}

		private void WriteTransforms()
		{
			for (int i = 0; i < solverTransforms.Length; i++)
			{
				if (solverTransforms[i] != null)
				{
					if (i < 2)
					{
						solverTransforms[i].position = V3Tools.Lerp(solverTransforms[i].position, GetPosition(i), IKPositionWeight);
					}
					solverTransforms[i].rotation = QuaTools.Lerp(solverTransforms[i].rotation, GetRotation(i), IKPositionWeight);
				}
			}
		}

		private void Read(Vector3[] positions, Quaternion[] rotations, bool hasChest, bool hasNeck, bool hasShoulders, bool hasToes)
		{
			if (rootBone == null)
			{
				rootBone = new VirtualBone(positions[0], rotations[0]);
			}
			else
			{
				rootBone.Read(positions[0], rotations[0]);
			}
			spine.Read(positions, rotations, hasChest, hasNeck, hasShoulders, hasToes, 0, 1);
			leftArm.Read(positions, rotations, hasChest, hasNeck, hasShoulders, hasToes, hasChest ? 3 : 2, 6);
			rightArm.Read(positions, rotations, hasChest, hasNeck, hasShoulders, hasToes, hasChest ? 3 : 2, 10);
			leftLeg.Read(positions, rotations, hasChest, hasNeck, hasShoulders, hasToes, 1, 14);
			rightLeg.Read(positions, rotations, hasChest, hasNeck, hasShoulders, hasToes, 1, 18);
			for (int i = 0; i < rotations.Length; i++)
			{
				if (i < 2)
				{
					solvedPositions[i] = positions[i];
				}
				solvedRotations[i] = rotations[i];
			}
			if (!base.initiated)
			{
				legs = new Leg[2] { leftLeg, rightLeg };
				arms = new Arm[2] { leftArm, rightArm };
				locomotion.Initiate(positions, rotations, hasToes);
				raycastOriginPelvis = spine.pelvis.readPosition;
				spine.faceDirection = readRotations[0] * Vector3.forward;
			}
		}

		private void Solve()
		{
			spine.PreSolve();
			Arm[] array = arms;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].PreSolve();
			}
			Leg[] array2 = legs;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i].PreSolve();
			}
			array = arms;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].ApplyOffsets();
			}
			spine.ApplyOffsets();
			spine.Solve(rootBone, legs, arms);
			if (spine.pelvisPositionWeight > 0f && plantFeet)
			{
				Warning.Log("If VRIK 'Pelvis Position Weight' is > 0, 'Plant Feet' should be disabled to improve performance and stability.", root);
			}
			if (locomotion.weight > 0f)
			{
				Vector3 leftFootPosition = Vector3.zero;
				Vector3 rightFootPosition = Vector3.zero;
				Quaternion leftFootRotation = Quaternion.identity;
				Quaternion rightFootRotation = Quaternion.identity;
				float leftFootOffset = 0f;
				float rightFootOffset = 0f;
				float leftHeelOffset = 0f;
				float rightHeelOffset = 0f;
				locomotion.Solve(rootBone, spine, leftLeg, rightLeg, leftArm, rightArm, supportLegIndex, out leftFootPosition, out rightFootPosition, out leftFootRotation, out rightFootRotation, out leftFootOffset, out rightFootOffset, out leftHeelOffset, out rightHeelOffset);
				leftFootPosition += root.up * leftFootOffset;
				rightFootPosition += root.up * rightFootOffset;
				leftLeg.footPositionOffset += (leftFootPosition - leftLeg.lastBone.solverPosition) * IKPositionWeight * (1f - leftLeg.positionWeight) * locomotion.weight;
				rightLeg.footPositionOffset += (rightFootPosition - rightLeg.lastBone.solverPosition) * IKPositionWeight * (1f - rightLeg.positionWeight) * locomotion.weight;
				leftLeg.heelPositionOffset += root.up * leftHeelOffset * locomotion.weight;
				rightLeg.heelPositionOffset += root.up * rightHeelOffset * locomotion.weight;
				Quaternion b = QuaTools.FromToRotation(leftLeg.lastBone.solverRotation, leftFootRotation);
				Quaternion b2 = QuaTools.FromToRotation(rightLeg.lastBone.solverRotation, rightFootRotation);
				b = Quaternion.Lerp(Quaternion.identity, b, IKPositionWeight * (1f - leftLeg.rotationWeight) * locomotion.weight);
				b2 = Quaternion.Lerp(Quaternion.identity, b2, IKPositionWeight * (1f - rightLeg.rotationWeight) * locomotion.weight);
				leftLeg.footRotationOffset = b * leftLeg.footRotationOffset;
				rightLeg.footRotationOffset = b2 * rightLeg.footRotationOffset;
				Vector3 point = Vector3.Lerp(leftLeg.position + leftLeg.footPositionOffset, rightLeg.position + rightLeg.footPositionOffset, 0.5f);
				point = V3Tools.PointToPlane(point, rootBone.solverPosition, root.up);
				rootVelocity += (point - rootBone.solverPosition) * Time.deltaTime * 10f;
				Vector3 vector = V3Tools.ExtractVertical(rootVelocity, root.up, 1f);
				rootVelocity -= vector;
				Vector3 a = rootBone.solverPosition + rootVelocity * Time.deltaTime * 2f * locomotion.weight;
				a = Vector3.Lerp(a, point, Time.deltaTime * locomotion.rootSpeed * locomotion.weight);
				rootBone.solverPosition = a;
				float num = leftFootOffset + rightFootOffset;
				bodyOffset = Vector3.Lerp(bodyOffset, root.up * num, Time.deltaTime * 3f);
				bodyOffset = Vector3.Lerp(Vector3.zero, bodyOffset, locomotion.weight);
			}
			array2 = legs;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i].ApplyOffsets();
			}
			if (!plantFeet)
			{
				spine.InverseTranslateToHead(legs, limited: false, useCurrentLegMag: false, bodyOffset, 1f);
				array2 = legs;
				for (int i = 0; i < array2.Length; i++)
				{
					array2[i].TranslateRoot(spine.pelvis.solverPosition, spine.pelvis.solverRotation);
				}
				array2 = legs;
				for (int i = 0; i < array2.Length; i++)
				{
					array2[i].Solve();
				}
			}
			else
			{
				for (int j = 0; j < 2; j++)
				{
					spine.InverseTranslateToHead(legs, limited: true, j == 0, bodyOffset, 1f);
					array2 = legs;
					for (int i = 0; i < array2.Length; i++)
					{
						array2[i].TranslateRoot(spine.pelvis.solverPosition, spine.pelvis.solverRotation);
					}
					array2 = legs;
					for (int i = 0; i < array2.Length; i++)
					{
						array2[i].Solve();
					}
				}
			}
			for (int k = 0; k < arms.Length; k++)
			{
				arms[k].TranslateRoot(spine.chest.solverPosition, spine.chest.solverRotation);
				arms[k].Solve(k == 0);
			}
			spine.ResetOffsets();
			array2 = legs;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i].ResetOffsets();
			}
			array = arms;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].ResetOffsets();
			}
			spine.pelvisPositionOffset += GetPelvisOffset();
			spine.chestPositionOffset += spine.pelvisPositionOffset;
			Write();
			supportLegIndex = -1;
			float num2 = float.PositiveInfinity;
			for (int l = 0; l < legs.Length; l++)
			{
				float num3 = Vector3.SqrMagnitude(legs[l].lastBone.solverPosition - legs[l].bones[0].solverPosition);
				if (num3 < num2)
				{
					supportLegIndex = l;
					num2 = num3;
				}
			}
		}

		private Vector3 GetPosition(int index)
		{
			if (index >= 2)
			{
				UnityEngine.Debug.LogError("Can only get root and pelvis positions from IKSolverVR. GetPosition index out of range.");
			}
			return solvedPositions[index];
		}

		private Quaternion GetRotation(int index)
		{
			return solvedRotations[index];
		}

		private void Write()
		{
			solvedPositions[0] = rootBone.solverPosition;
			solvedRotations[0] = rootBone.solverRotation;
			spine.Write(ref solvedPositions, ref solvedRotations);
			Leg[] array = legs;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].Write(ref solvedPositions, ref solvedRotations);
			}
			Arm[] array2 = arms;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i].Write(ref solvedPositions, ref solvedRotations);
			}
		}

		private Vector3 GetPelvisOffset()
		{
			if (locomotion.weight <= 0f)
			{
				return Vector3.zero;
			}
			if ((int)locomotion.blockingLayers == -1)
			{
				return Vector3.zero;
			}
			Vector3 vector = raycastOriginPelvis;
			vector.y = spine.pelvis.solverPosition.y;
			Vector3 vector2 = spine.pelvis.readPosition;
			vector2.y = spine.pelvis.solverPosition.y;
			Vector3 direction = vector2 - vector;
			RaycastHit hitInfo;
			if (locomotion.raycastRadius <= 0f)
			{
				if (Physics.Raycast(vector, direction, out hitInfo, direction.magnitude * 1.1f, locomotion.blockingLayers))
				{
					vector2 = hitInfo.point;
				}
			}
			else if (Physics.SphereCast(vector, locomotion.raycastRadius * 1.1f, direction, out hitInfo, direction.magnitude, locomotion.blockingLayers))
			{
				vector2 = vector + direction.normalized * hitInfo.distance / 1.1f;
			}
			Vector3 vector3 = spine.pelvis.solverPosition;
			direction = vector3 - vector2;
			if (locomotion.raycastRadius <= 0f)
			{
				if (Physics.Raycast(vector2, direction, out hitInfo, direction.magnitude, locomotion.blockingLayers))
				{
					vector3 = hitInfo.point;
				}
			}
			else if (Physics.SphereCast(vector2, locomotion.raycastRadius, direction, out hitInfo, direction.magnitude, locomotion.blockingLayers))
			{
				vector3 = vector2 + direction.normalized * hitInfo.distance;
			}
			lastOffset = Vector3.Lerp(lastOffset, Vector3.zero, Time.deltaTime * 3f);
			vector3 += Vector3.ClampMagnitude(lastOffset, 0.75f);
			vector3.y = spine.pelvis.solverPosition.y;
			lastOffset = Vector3.Lerp(lastOffset, vector3 - spine.pelvis.solverPosition, Time.deltaTime * 15f);
			return lastOffset;
		}
	}
	public class TwistRelaxer : MonoBehaviour
	{
		[Tooltip("The weight of relaxing the twist of this Transform")]
		[Range(0f, 1f)]
		public float weight = 1f;

		[Tooltip("If 0.5, this Transform will be twisted half way from parent to child. If 1, the twist angle will be locked to the child and will rotate with along with it.")]
		[Range(0f, 1f)]
		public float parentChildCrossfade = 0.5f;

		private Vector3 twistAxis = Vector3.right;

		private Vector3 axis = Vector3.forward;

		private Vector3 axisRelativeToParentDefault;

		private Vector3 axisRelativeToChildDefault;

		private Transform parent;

		private Transform child;

		public void Relax()
		{
			if (!(weight <= 0f))
			{
				Vector3 a = parent.rotation * axisRelativeToParentDefault;
				Vector3 b = child.rotation * axisRelativeToChildDefault;
				Vector3 vector = Vector3.Slerp(a, b, parentChildCrossfade);
				vector = Quaternion.Inverse(Quaternion.LookRotation(base.transform.rotation * axis, base.transform.rotation * twistAxis)) * vector;
				float num = Mathf.Atan2(vector.x, vector.z) * 57.29578f;
				Quaternion rotation = child.rotation;
				base.transform.rotation = Quaternion.AngleAxis(num * weight, base.transform.rotation * twistAxis) * base.transform.rotation;
				child.rotation = rotation;
			}
		}

		private void Start()
		{
			parent = base.transform.parent;
			if (base.transform.childCount == 0)
			{
				UnityEngine.Debug.LogError("The Transform of a TwistRelaxer has no children. Can not use TwistRelaxer on that bone.");
				return;
			}
			child = base.transform.GetChild(0);
			twistAxis = base.transform.InverseTransformDirection(child.position - base.transform.position);
			axis = new Vector3(twistAxis.y, twistAxis.z, twistAxis.x);
			Vector3 vector = base.transform.rotation * axis;
			axisRelativeToParentDefault = Quaternion.Inverse(parent.rotation) * vector;
			axisRelativeToChildDefault = Quaternion.Inverse(child.rotation) * vector;
		}

		private void LateUpdate()
		{
			Relax();
		}
	}
	[Serializable]
	public class InteractionEffector
	{
		private Poser poser;

		private IKEffector effector;

		private float timer;

		private float length;

		private float weight;

		private float fadeInSpeed;

		private float defaultPositionWeight;

		private float defaultRotationWeight;

		private float defaultPull;

		private float defaultReach;

		private float defaultPush;

		private float defaultPushParent;

		private float resetTimer;

		private bool positionWeightUsed;

		private bool rotationWeightUsed;

		private bool pullUsed;

		private bool reachUsed;

		private bool pushUsed;

		private bool pushParentUsed;

		private bool pickedUp;

		private bool defaults;

		private bool pickUpOnPostFBBIK;

		private Vector3 pickUpPosition;

		private Vector3 pausePositionRelative;

		private Quaternion pickUpRotation;

		private Quaternion pauseRotationRelative;

		private InteractionTarget interactionTarget;

		private Transform target;

		private List<bool> triggered = new List<bool>();

		private InteractionSystem interactionSystem;

		private bool started;

		public FullBodyBipedEffector effectorType { get; private set; }

		public bool isPaused { get; private set; }

		public InteractionObject interactionObject { get; private set; }

		public bool inInteraction => interactionObject != null;

		public float progress
		{
			get
			{
				if (!inInteraction)
				{
					return 0f;
				}
				if (length == 0f)
				{
					return 0f;
				}
				return timer / length;
			}
		}

		public InteractionEffector(FullBodyBipedEffector effectorType)
		{
			this.effectorType = effectorType;
		}

		public void Initiate(InteractionSystem interactionSystem)
		{
			this.interactionSystem = interactionSystem;
			if (effector == null)
			{
				effector = interactionSystem.ik.solver.GetEffector(effectorType);
				poser = effector.bone.GetComponent<Poser>();
			}
			StoreDefaults();
		}

		private void StoreDefaults()
		{
			defaultPositionWeight = interactionSystem.ik.solver.GetEffector(effectorType).positionWeight;
			defaultRotationWeight = interactionSystem.ik.solver.GetEffector(effectorType).rotationWeight;
			defaultPull = interactionSystem.ik.solver.GetChain(effectorType).pull;
			defaultReach = interactionSystem.ik.solver.GetChain(effectorType).reach;
			defaultPush = interactionSystem.ik.solver.GetChain(effectorType).push;
			defaultPushParent = interactionSystem.ik.solver.GetChain(effectorType).pushParent;
		}

		public bool ResetToDefaults(float speed)
		{
			if (inInteraction)
			{
				return false;
			}
			if (isPaused)
			{
				return false;
			}
			if (defaults)
			{
				return false;
			}
			resetTimer = Mathf.Clamp(resetTimer -= Time.deltaTime * speed, 0f, 1f);
			if (effector.isEndEffector)
			{
				if (pullUsed)
				{
					interactionSystem.ik.solver.GetChain(effectorType).pull = Mathf.Lerp(defaultPull, interactionSystem.ik.solver.GetChain(effectorType).pull, resetTimer);
				}
				if (reachUsed)
				{
					interactionSystem.ik.solver.GetChain(effectorType).reach = Mathf.Lerp(defaultReach, interactionSystem.ik.solver.GetChain(effectorType).reach, resetTimer);
				}
				if (pushUsed)
				{
					interactionSystem.ik.solver.GetChain(effectorType).push = Mathf.Lerp(defaultPush, interactionSystem.ik.solver.GetChain(effectorType).push, resetTimer);
				}
				if (pushParentUsed)
				{
					interactionSystem.ik.solver.GetChain(effectorType).pushParent = Mathf.Lerp(defaultPushParent, interactionSystem.ik.solver.GetChain(effectorType).pushParent, resetTimer);
				}
			}
			if (positionWeightUsed)
			{
				effector.positionWeight = Mathf.Lerp(defaultPositionWeight, effector.positionWeight, resetTimer);
			}
			if (rotationWeightUsed)
			{
				effector.rotationWeight = Mathf.Lerp(defaultRotationWeight, effector.rotationWeight, resetTimer);
			}
			if (resetTimer <= 0f)
			{
				pullUsed = false;
				reachUsed = false;
				pushUsed = false;
				pushParentUsed = false;
				positionWeightUsed = false;
				rotationWeightUsed = false;
				defaults = true;
			}
			return true;
		}

		public bool Pause()
		{
			if (!inInteraction)
			{
				return false;
			}
			isPaused = true;
			pausePositionRelative = target.InverseTransformPoint(effector.position);
			pauseRotationRelative = Quaternion.Inverse(target.rotation) * effector.rotation;
			if (interactionSystem.OnInteractionPause != null)
			{
				interactionSystem.OnInteractionPause(effectorType, interactionObject);
			}
			return true;
		}

		public bool Resume()
		{
			if (!inInteraction)
			{
				return false;
			}
			isPaused = false;
			if (interactionSystem.OnInteractionResume != null)
			{
				interactionSystem.OnInteractionResume(effectorType, interactionObject);
			}
			return true;
		}

		public bool Start(InteractionObject interactionObject, string tag, float fadeInTime, bool interrupt)
		{
			if (!inInteraction)
			{
				effector.position = effector.bone.position;
				effector.rotation = effector.bone.rotation;
			}
			else if (!interrupt)
			{
				return false;
			}
			target = interactionObject.GetTarget(effectorType, tag);
			if (target == null)
			{
				return false;
			}
			interactionTarget = target.GetComponent<InteractionTarget>();
			this.interactionObject = interactionObject;
			if (interactionSystem.OnInteractionStart != null)
			{
				interactionSystem.OnInteractionStart(effectorType, interactionObject);
			}
			interactionObject.OnStartInteraction(interactionSystem);
			triggered.Clear();
			for (int i = 0; i < interactionObject.events.Length; i++)
			{
				triggered.Add(item: false);
			}
			if (poser != null)
			{
				if (poser.poseRoot == null)
				{
					poser.weight = 0f;
				}
				if (interactionTarget != null)
				{
					poser.poseRoot = target.transform;
				}
				else
				{
					poser.poseRoot = null;
				}
				poser.AutoMapping();
			}
			positionWeightUsed = interactionObject.CurveUsed(InteractionObject.WeightCurve.Type.PositionWeight);
			rotationWeightUsed = interactionObject.CurveUsed(InteractionObject.WeightCurve.Type.RotationWeight);
			pullUsed = interactionObject.CurveUsed(InteractionObject.WeightCurve.Type.Pull);
			reachUsed = interactionObject.CurveUsed(InteractionObject.WeightCurve.Type.Reach);
			pushUsed = interactionObject.CurveUsed(InteractionObject.WeightCurve.Type.Push);
			pushParentUsed = interactionObject.CurveUsed(InteractionObject.WeightCurve.Type.PushParent);
			StoreDefaults();
			timer = 0f;
			weight = 0f;
			fadeInSpeed = ((fadeInTime > 0f) ? (1f / fadeInTime) : 1000f);
			length = interactionObject.length;
			isPaused = false;
			pickedUp = false;
			pickUpPosition = Vector3.zero;
			pickUpRotation = Quaternion.identity;
			if (interactionTarget != null)
			{
				interactionTarget.RotateTo(effector.bone.position);
			}
			started = true;
			return true;
		}

		public void Update(Transform root, float speed)
		{
			if (!inInteraction)
			{
				if (started)
				{
					isPaused = false;
					pickedUp = false;
					defaults = false;
					resetTimer = 1f;
					started = false;
				}
				return;
			}
			if (interactionTarget != null && !interactionTarget.rotateOnce)
			{
				interactionTarget.RotateTo(effector.bone.position);
			}
			if (isPaused)
			{
				effector.position = target.TransformPoint(pausePositionRelative);
				effector.rotation = target.rotation * pauseRotationRelative;
				interactionObject.Apply(interactionSystem.ik.solver, effectorType, interactionTarget, timer, weight);
				return;
			}
			timer += Time.deltaTime * speed * ((interactionTarget != null) ? interactionTarget.interactionSpeedMlp : 1f);
			weight = Mathf.Clamp(weight + Time.deltaTime * fadeInSpeed * speed, 0f, 1f);
			bool pickUp = false;
			bool pause = false;
			TriggerUntriggeredEvents(checkTime: true, out pickUp, out pause);
			Vector3 b = (pickedUp ? pickUpPosition : target.position);
			Quaternion b2 = (pickedUp ? pickUpRotation : target.rotation);
			effector.position = Vector3.Lerp(effector.bone.position, b, weight);
			effector.rotation = Quaternion.Lerp(effector.bone.rotation, b2, weight);
			interactionObject.Apply(interactionSystem.ik.solver, effectorType, interactionTarget, timer, weight);
			if (pickUp)
			{
				PickUp(root);
			}
			if (pause)
			{
				Pause();
			}
			float value = interactionObject.GetValue(InteractionObject.WeightCurve.Type.PoserWeight, interactionTarget, timer);
			if (poser != null)
			{
				poser.weight = Mathf.Lerp(poser.weight, value, weight);
			}
			else if (value > 0f)
			{
				Warning.Log("InteractionObject " + interactionObject.name + " has a curve/multipler for Poser Weight, but the bone of effector " + effectorType.ToString() + " has no HandPoser/GenericPoser attached.", effector.bone);
			}
			if (timer >= length)
			{
				Stop();
			}
		}

		private void TriggerUntriggeredEvents(bool checkTime, out bool pickUp, out bool pause)
		{
			pickUp = false;
			pause = false;
			for (int i = 0; i < triggered.Count; i++)
			{
				if (triggered[i] || (checkTime && !(interactionObject.events[i].time < timer)))
				{
					continue;
				}
				interactionObject.events[i].Activate(effector.bone);
				if (interactionObject.events[i].pickUp)
				{
					if (timer >= interactionObject.events[i].time)
					{
						timer = interactionObject.events[i].time;
					}
					pickUp = true;
				}
				if (interactionObject.events[i].pause)
				{
					if (timer >= interactionObject.events[i].time)
					{
						timer = interactionObject.events[i].time;
					}
					pause = true;
				}
				if (interactionSystem.OnInteractionEvent != null)
				{
					interactionSystem.OnInteractionEvent(effectorType, interactionObject, interactionObject.events[i]);
				}
				triggered[i] = true;
			}
		}

		private void PickUp(Transform root)
		{
			pickUpPosition = effector.position;
			pickUpRotation = effector.rotation;
			pickUpOnPostFBBIK = true;
			pickedUp = true;
			Rigidbody component = interactionObject.targetsRoot.GetComponent<Rigidbody>();
			if (component != null)
			{
				if (!component.isKinematic)
				{
					component.isKinematic = true;
				}
				if (root.GetComponent<Collider>() != null)
				{
					Collider[] componentsInChildren = interactionObject.targetsRoot.GetComponentsInChildren<Collider>();
					foreach (Collider collider in componentsInChildren)
					{
						if (!collider.isTrigger)
						{
							Physics.IgnoreCollision(root.GetComponent<Collider>(), collider);
						}
					}
				}
			}
			if (interactionSystem.OnInteractionPickUp != null)
			{
				interactionSystem.OnInteractionPickUp(effectorType, interactionObject);
			}
		}

		public bool Stop()
		{
			if (!inInteraction)
			{
				return false;
			}
			bool pickUp = false;
			bool pause = false;
			TriggerUntriggeredEvents(checkTime: false, out pickUp, out pause);
			if (interactionSystem.OnInteractionStop != null)
			{
				interactionSystem.OnInteractionStop(effectorType, interactionObject);
			}
			if (interactionTarget != null)
			{
				interactionTarget.ResetRotation();
			}
			interactionObject = null;
			weight = 0f;
			timer = 0f;
			isPaused = false;
			target = null;
			defaults = false;
			resetTimer = 1f;
			if (poser != null && !pickedUp)
			{
				poser.weight = 0f;
			}
			pickedUp = false;
			started = false;
			return true;
		}

		public void OnPostFBBIK()
		{
			if (inInteraction)
			{
				float num = interactionObject.GetValue(InteractionObject.WeightCurve.Type.RotateBoneWeight, interactionTarget, timer) * weight;
				if (num > 0f)
				{
					Quaternion b = (pickedUp ? pickUpRotation : effector.rotation);
					Quaternion quaternion = Quaternion.Slerp(effector.bone.rotation, b, num * num);
					effector.bone.localRotation = Quaternion.Inverse(effector.bone.parent.rotation) * quaternion;
				}
				if (pickUpOnPostFBBIK)
				{
					Vector3 position = effector.bone.position;
					effector.bone.position = pickUpPosition;
					interactionObject.targetsRoot.parent = effector.bone;
					effector.bone.position = position;
					pickUpOnPostFBBIK = false;
				}
			}
		}
	}
	[Serializable]
	public class InteractionLookAt
	{
		[Tooltip("(Optional) reference to the LookAtIK component that will be used to make the character look at the objects that it is interacting with.")]
		public LookAtIK ik;

		[Tooltip("Interpolation speed of the LookAtIK target.")]
		public float lerpSpeed = 5f;

		[Tooltip("Interpolation speed of the LookAtIK weight.")]
		public float weightSpeed = 1f;

		[HideInInspector]
		public bool isPaused;

		private Transform lookAtTarget;

		private float stopLookTime;

		private float weight;

		private bool firstFBBIKSolve;

		public void Look(Transform target, float time)
		{
			if (!(ik == null))
			{
				if (ik.solver.IKPositionWeight <= 0f)
				{
					ik.solver.IKPosition = ik.solver.GetRoot().position + ik.solver.GetRoot().forward * 3f;
				}
				lookAtTarget = target;
				stopLookTime = time;
			}
		}

		public void Update()
		{
			if (ik == null)
			{
				return;
			}
			if (ik.enabled)
			{
				ik.enabled = false;
			}
			if (!(lookAtTarget == null))
			{
				if (isPaused)
				{
					stopLookTime += Time.deltaTime;
				}
				float num = ((Time.time < stopLookTime) ? weightSpeed : (0f - weightSpeed));
				weight = Mathf.Clamp(weight + num * Time.deltaTime, 0f, 1f);
				ik.solver.IKPositionWeight = Interp.Float(weight, InterpolationMode.InOutQuintic);
				ik.solver.IKPosition = Vector3.Lerp(ik.solver.IKPosition, lookAtTarget.position, lerpSpeed * Time.deltaTime);
				if (weight <= 0f)
				{
					lookAtTarget = null;
				}
				firstFBBIKSolve = true;
			}
		}

		public void SolveSpine()
		{
			if (!(ik == null) && firstFBBIKSolve)
			{
				float headWeight = ik.solver.headWeight;
				float eyesWeight = ik.solver.eyesWeight;
				ik.solver.headWeight = 0f;
				ik.solver.eyesWeight = 0f;
				ik.solver.Update();
				ik.solver.headWeight = headWeight;
				ik.solver.eyesWeight = eyesWeight;
			}
		}

		public void SolveHead()
		{
			if (!(ik == null) && firstFBBIKSolve)
			{
				float bodyWeight = ik.solver.bodyWeight;
				ik.solver.bodyWeight = 0f;
				ik.solver.Update();
				ik.solver.bodyWeight = bodyWeight;
				firstFBBIKSolve = false;
			}
		}
	}
	[HelpURL("https://www.youtube.com/watch?v=r5jiZnsDH3M")]
	[AddComponentMenu("Scripts/RootMotion.FinalIK/Interaction System/Interaction Object")]
	public class InteractionObject : MonoBehaviour
	{
		[Serializable]
		public class InteractionEvent
		{
			[Tooltip("The time of the event since interaction start.")]
			public float time;

			[Tooltip("If true, the interaction will be paused on this event. The interaction can be resumed by InteractionSystem.ResumeInteraction() or InteractionSystem.ResumeAll;")]
			public bool pause;

			[Tooltip("If true, the object will be parented to the effector bone on this event. Note that picking up like this can be done by only a single effector at a time. If you wish to pick up an object with both hands, see the Interaction PickUp2Handed demo scene.")]
			public bool pickUp;

			[Tooltip("The animations called on this event.")]
			public AnimatorEvent[] animations;

			[Tooltip("The messages sent on this event using GameObject.SendMessage().")]
			public Message[] messages;

			public void Activate(Transform t)
			{
				AnimatorEvent[] array = animations;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].Activate(pickUp);
				}
				Message[] array2 = messages;
				for (int i = 0; i < array2.Length; i++)
				{
					array2[i].Send(t);
				}
			}
		}

		[Serializable]
		public class Message
		{
			[Tooltip("The name of the function called.")]
			public string function;

			[Tooltip("The recipient game object.")]
			public GameObject recipient;

			private const string empty = "";

			public void Send(Transform t)
			{
				if (!(recipient == null) && !(function == string.Empty) && !(function == ""))
				{
					recipient.SendMessage(function, t, SendMessageOptions.RequireReceiver);
				}
			}
		}

		[Serializable]
		public class AnimatorEvent
		{
			[Tooltip("The Animator component that will receive the AnimatorEvents.")]
			public Animator animator;

			[Tooltip("The Animation component that will receive the AnimatorEvents (Legacy).")]
			public Animation animation;

			[Tooltip("The name of the animation state.")]
			public string animationState;

			[Tooltip("The crossfading time.")]
			public float crossfadeTime = 0.3f;

			[Tooltip("The layer of the animation state (if using Legacy, the animation state will be forced to this layer).")]
			public int layer;

			[Tooltip("Should the animation always start from 0 normalized time?")]
			public bool resetNormalizedTime;

			private const string empty = "";

			public void Activate(bool pickUp)
			{
				if (animator != null)
				{
					if (pickUp)
					{
						animator.applyRootMotion = false;
					}
					Activate(animator);
				}
				if (animation != null)
				{
					Activate(animation);
				}
			}

			private void Activate(Animator animator)
			{
				if (!(animationState == ""))
				{
					if (resetNormalizedTime)
					{
						animator.CrossFade(animationState, crossfadeTime, layer, 0f);
					}
					else
					{
						animator.CrossFade(animationState, crossfadeTime, layer);
					}
				}
			}

			private void Activate(Animation animation)
			{
				if (!(animationState == ""))
				{
					if (resetNormalizedTime)
					{
						animation[animationState].normalizedTime = 0f;
					}
					animation[animationState].layer = layer;
					animation.CrossFade(animationState, crossfadeTime);
				}
			}
		}

		[Serializable]
		public class WeightCurve
		{
			[Serializable]
			public enum Type
			{
				PositionWeight,
				RotationWeight,
				PositionOffsetX,
				PositionOffsetY,
				PositionOffsetZ,
				Pull,
				Reach,
				RotateBoneWeight,
				Push,
				PushParent,
				PoserWeight
			}

			[Tooltip("The type of the curve (InteractionObject.WeightCurve.Type).")]
			public Type type;

			[Tooltip("The weight curve.")]
			public AnimationCurve curve;

			public float GetValue(float timer)
			{
				return curve.Evaluate(timer);
			}
		}

		[Serializable]
		public class Multiplier
		{
			[Tooltip("The curve type to multiply.")]
			public WeightCurve.Type curve;

			[Tooltip("The multiplier of the curve's value.")]
			public float multiplier = 1f;

			[Tooltip("The resulting value will be applied to this channel.")]
			public WeightCurve.Type result;

			public float GetValue(WeightCurve weightCurve, float timer)
			{
				return weightCurve.GetValue(timer) * multiplier;
			}
		}

		[Tooltip("If the Interaction System has a 'Look At' LookAtIK component assigned, will use it to make the character look at the specified Transform. If unassigned, will look at this GameObject.")]
		public Transform otherLookAtTarget;

		[Tooltip("The root Transform of the InteractionTargets. If null, will use this GameObject. GetComponentsInChildren<InteractionTarget>() will be used at initiation to find all InteractionTargets associated with this InteractionObject.")]
		public Transform otherTargetsRoot;

		[Tooltip("If assigned, all PositionOffset channels will be applied in the rotation space of this Transform. If not, they will be in the rotation space of the character.")]
		public Transform positionOffsetSpace;

		public WeightCurve[] weightCurves;

		public Multiplier[] multipliers;

		public InteractionEvent[] events;

		private InteractionTarget[] targets = new InteractionTarget[0];

		public float length { get; private set; }

		public InteractionSystem lastUsedInteractionSystem { get; private set; }

		public Transform lookAtTarget
		{
			get
			{
				if (otherLookAtTarget != null)
				{
					return otherLookAtTarget;
				}
				return base.transform;
			}
		}

		public Transform targetsRoot
		{
			get
			{
				if (otherTargetsRoot != null)
				{
					return otherTargetsRoot;
				}
				return base.transform;
			}
		}

		[ContextMenu("TUTORIAL VIDEO (PART 1: BASICS)")]
		private void OpenTutorial1()
		{
			Application.OpenURL("https://www.youtube.com/watch?v=r5jiZnsDH3M");
		}

		[ContextMenu("TUTORIAL VIDEO (PART 2: PICKING UP...)")]
		private void OpenTutorial2()
		{
			Application.OpenURL("https://www.youtube.com/watch?v=eP9-zycoHLk");
		}

		[ContextMenu("TUTORIAL VIDEO (PART 3: ANIMATION)")]
		private void OpenTutorial3()
		{
			Application.OpenURL("https://www.youtube.com/watch?v=sQfB2RcT1T4&index=14&list=PLVxSIA1OaTOu8Nos3CalXbJ2DrKnntMv6");
		}

		[ContextMenu("TUTORIAL VIDEO (PART 4: TRIGGERS)")]
		private void OpenTutorial4()
		{
			Application.OpenURL("https://www.youtube.com/watch?v=-TDZpNjt2mk&index=15&list=PLVxSIA1OaTOu8Nos3CalXbJ2DrKnntMv6");
		}

		[ContextMenu("Support Group")]
		private void SupportGroup()
		{
			Application.OpenURL("https://groups.google.com/forum/#!forum/final-ik");
		}

		[ContextMenu("Asset Store Thread")]
		private void ASThread()
		{
			Application.OpenURL("http://forum.unity3d.com/threads/final-ik-full-body-ik-aim-look-at-fabrik-ccd-ik-1-0-released.222685/");
		}

		public void Initiate()
		{
			for (int i = 0; i < weightCurves.Length; i++)
			{
				if (weightCurves[i].curve.length > 0)
				{
					float time = weightCurves[i].curve.keys[weightCurves[i].curve.length - 1].time;
					length = Mathf.Clamp(length, time, length);
				}
			}
			for (int j = 0; j < events.Length; j++)
			{
				length = Mathf.Clamp(length, events[j].time, length);
			}
			targets = targetsRoot.GetComponentsInChildren<InteractionTarget>();
		}

		public InteractionTarget GetTarget(FullBodyBipedEffector effectorType, InteractionSystem interactionSystem)
		{
			InteractionTarget[] array;
			if (interactionSystem.tag == string.Empty || interactionSystem.tag == "")
			{
				array = targets;
				foreach (InteractionTarget interactionTarget in array)
				{
					if (interactionTarget.effectorType == effectorType)
					{
						return interactionTarget;
					}
				}
				return null;
			}
			array = targets;
			foreach (InteractionTarget interactionTarget2 in array)
			{
				if (interactionTarget2.effectorType == effectorType && interactionTarget2.tag == interactionSystem.tag)
				{
					return interactionTarget2;
				}
			}
			return null;
		}

		public bool CurveUsed(WeightCurve.Type type)
		{
			WeightCurve[] array = weightCurves;
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i].type == type)
				{
					return true;
				}
			}
			Multiplier[] array2 = multipliers;
			for (int i = 0; i < array2.Length; i++)
			{
				if (array2[i].result == type)
				{
					return true;
				}
			}
			return false;
		}

		public InteractionTarget[] GetTargets()
		{
			return targets;
		}

		public Transform GetTarget(FullBodyBipedEffector effectorType, string tag)
		{
			if (tag == string.Empty || tag == "")
			{
				return GetTarget(effectorType);
			}
			for (int i = 0; i < targets.Length; i++)
			{
				if (targets[i].effectorType == effectorType && targets[i].tag == tag)
				{
					return targets[i].transform;
				}
			}
			return base.transform;
		}

		public void OnStartInteraction(InteractionSystem interactionSystem)
		{
			lastUsedInteractionSystem = interactionSystem;
		}

		public void Apply(IKSolverFullBodyBiped solver, FullBodyBipedEffector effector, InteractionTarget target, float timer, float weight)
		{
			for (int i = 0; i < weightCurves.Length; i++)
			{
				float num = ((target == null) ? 1f : target.GetValue(weightCurves[i].type));
				Apply(solver, effector, weightCurves[i].type, weightCurves[i].GetValue(timer), weight * num);
			}
			for (int j = 0; j < multipliers.Length; j++)
			{
				if (multipliers[j].curve == multipliers[j].result && !Warning.logged)
				{
					Warning.Log("InteractionObject Multiplier 'Curve' " + multipliers[j].curve.ToString() + "and 'Result' are the same.", base.transform);
				}
				int weightCurveIndex = GetWeightCurveIndex(multipliers[j].curve);
				if (weightCurveIndex != -1)
				{
					float num2 = ((target == null) ? 1f : target.GetValue(multipliers[j].result));
					Apply(solver, effector, multipliers[j].result, multipliers[j].GetValue(weightCurves[weightCurveIndex], timer), weight * num2);
				}
				else if (!Warning.logged)
				{
					Warning.Log("InteractionObject Multiplier curve " + multipliers[j].curve.ToString() + "does not exist.", base.transform);
				}
			}
		}

		public float GetValue(WeightCurve.Type weightCurveType, InteractionTarget target, float timer)
		{
			int weightCurveIndex = GetWeightCurveIndex(weightCurveType);
			if (weightCurveIndex != -1)
			{
				float num = ((target == null) ? 1f : target.GetValue(weightCurveType));
				return weightCurves[weightCurveIndex].GetValue(timer) * num;
			}
			for (int i = 0; i < multipliers.Length; i++)
			{
				if (multipliers[i].result == weightCurveType)
				{
					int weightCurveIndex2 = GetWeightCurveIndex(multipliers[i].curve);
					if (weightCurveIndex2 != -1)
					{
						float num2 = ((target == null) ? 1f : target.GetValue(multipliers[i].result));
						return multipliers[i].GetValue(weightCurves[weightCurveIndex2], timer) * num2;
					}
				}
			}
			return 0f;
		}

		private void Awake()
		{
			Initiate();
		}

		private void Apply(IKSolverFullBodyBiped solver, FullBodyBipedEffector effector, WeightCurve.Type type, float value, float weight)
		{
			switch (type)
			{
			case WeightCurve.Type.PositionWeight:
				solver.GetEffector(effector).positionWeight = Mathf.Lerp(solver.GetEffector(effector).positionWeight, value, weight);
				break;
			case WeightCurve.Type.RotationWeight:
				solver.GetEffector(effector).rotationWeight = Mathf.Lerp(solver.GetEffector(effector).rotationWeight, value, weight);
				break;
			case WeightCurve.Type.PositionOffsetX:
				solver.GetEffector(effector).position += ((positionOffsetSpace != null) ? positionOffsetSpace.rotation : solver.GetRoot().rotation) * Vector3.right * value * weight;
				break;
			case WeightCurve.Type.PositionOffsetY:
				solver.GetEffector(effector).position += ((positionOffsetSpace != null) ? positionOffsetSpace.rotation : solver.GetRoot().rotation) * Vector3.up * value * weight;
				break;
			case WeightCurve.Type.PositionOffsetZ:
				solver.GetEffector(effector).position += ((positionOffsetSpace != null) ? positionOffsetSpace.rotation : solver.GetRoot().rotation) * Vector3.forward * value * weight;
				break;
			case WeightCurve.Type.Pull:
				solver.GetChain(effector).pull = Mathf.Lerp(solver.GetChain(effector).pull, value, weight);
				break;
			case WeightCurve.Type.Reach:
				solver.GetChain(effector).reach = Mathf.Lerp(solver.GetChain(effector).reach, value, weight);
				break;
			case WeightCurve.Type.Push:
				solver.GetChain(effector).push = Mathf.Lerp(solver.GetChain(effector).push, value, weight);
				break;
			case WeightCurve.Type.PushParent:
				solver.GetChain(effector).pushParent = Mathf.Lerp(solver.GetChain(effector).pushParent, value, weight);
				break;
			case WeightCurve.Type.RotateBoneWeight:
				break;
			}
		}

		private Transform GetTarget(FullBodyBipedEffector effectorType)
		{
			for (int i = 0; i < targets.Length; i++)
			{
				if (targets[i].effectorType == effectorType)
				{
					return targets[i].transform;
				}
			}
			return base.transform;
		}

		private int GetWeightCurveIndex(WeightCurve.Type weightCurveType)
		{
			for (int i = 0; i < weightCurves.Length; i++)
			{
				if (weightCurves[i].type == weightCurveType)
				{
					return i;
				}
			}
			return -1;
		}

		private int GetMultiplierIndex(WeightCurve.Type weightCurveType)
		{
			for (int i = 0; i < multipliers.Length; i++)
			{
				if (multipliers[i].result == weightCurveType)
				{
					return i;
				}
			}
			return -1;
		}

		[ContextMenu("User Manual")]
		private void OpenUserManual()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/page10.html");
		}

		[ContextMenu("Scrpt Reference")]
		private void OpenScriptReference()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/class_root_motion_1_1_final_i_k_1_1_interaction_object.html");
		}
	}
	[HelpURL("https://www.youtube.com/watch?v=r5jiZnsDH3M")]
	[AddComponentMenu("Scripts/RootMotion.FinalIK/Interaction System/Interaction System")]
	public class InteractionSystem : MonoBehaviour
	{
		public delegate void InteractionDelegate(FullBodyBipedEffector effectorType, InteractionObject interactionObject);

		public delegate void InteractionEventDelegate(FullBodyBipedEffector effectorType, InteractionObject interactionObject, InteractionObject.InteractionEvent interactionEvent);

		[Tooltip("If not empty, only the targets with the specified tag will be used by this Interaction System.")]
		public string targetTag = "";

		[Tooltip("The fade in time of the interaction.")]
		public float fadeInTime = 0.3f;

		[Tooltip("The master speed for all interactions.")]
		public float speed = 1f;

		[Tooltip("If > 0, lerps all the FBBIK channels used by the Interaction System back to their default or initial values when not in interaction.")]
		public float resetToDefaultsSpeed = 1f;

		[Header("Triggering")]
		[Tooltip("The collider that registers OnTriggerEnter and OnTriggerExit events with InteractionTriggers.")]
		[FormerlySerializedAs("collider")]
		public Collider characterCollider;

		[Tooltip("Will be used by Interaction Triggers that need the camera's position. Assign the first person view character camera.")]
		[FormerlySerializedAs("camera")]
		public Transform FPSCamera;

		[Tooltip("The layers that will be raycasted from the camera (along camera.forward). All InteractionTrigger look at target colliders should be included.")]
		public LayerMask camRaycastLayers;

		[Tooltip("Max distance of raycasting from the camera.")]
		public float camRaycastDistance = 1f;

		private List<InteractionTrigger> inContact = new List<InteractionTrigger>();

		private List<int> bestRangeIndexes = new List<int>();

		public InteractionDelegate OnInteractionStart;

		public InteractionDelegate OnInteractionPause;

		public InteractionDelegate OnInteractionPickUp;

		public InteractionDelegate OnInteractionResume;

		public InteractionDelegate OnInteractionStop;

		public InteractionEventDelegate OnInteractionEvent;

		public RaycastHit raycastHit;

		[Space(10f)]
		[Tooltip("Reference to the FBBIK component.")]
		[SerializeField]
		private FullBodyBipedIK fullBody;

		[Tooltip("Handles looking at the interactions.")]
		public InteractionLookAt lookAt = new InteractionLookAt();

		private InteractionEffector[] interactionEffectors = new InteractionEffector[9]
		{
			new InteractionEffector(FullBodyBipedEffector.Body),
			new InteractionEffector(FullBodyBipedEffector.LeftFoot),
			new InteractionEffector(FullBodyBipedEffector.LeftHand),
			new InteractionEffector(FullBodyBipedEffector.LeftShoulder),
			new InteractionEffector(FullBodyBipedEffector.LeftThigh),
			new InteractionEffector(FullBodyBipedEffector.RightFoot),
			new InteractionEffector(FullBodyBipedEffector.RightHand),
			new InteractionEffector(FullBodyBipedEffector.RightShoulder),
			new InteractionEffector(FullBodyBipedEffector.RightThigh)
		};

		private bool initiated;

		private Collider lastCollider;

		private Collider c;

		public bool inInteraction
		{
			get
			{
				if (!IsValid(log: true))
				{
					return false;
				}
				for (int i = 0; i < interactionEffectors.Length; i++)
				{
					if (interactionEffectors[i].inInteraction && !interactionEffectors[i].isPaused)
					{
						return true;
					}
				}
				return false;
			}
		}

		public FullBodyBipedIK ik
		{
			get
			{
				return fullBody;
			}
			set
			{
				fullBody = value;
			}
		}

		public List<InteractionTrigger> triggersInRange { get; private set; }

		[ContextMenu("TUTORIAL VIDEO (PART 1: BASICS)")]
		private void OpenTutorial1()
		{
			Application.OpenURL("https://www.youtube.com/watch?v=r5jiZnsDH3M");
		}

		[ContextMenu("TUTORIAL VIDEO (PART 2: PICKING UP...)")]
		private void OpenTutorial2()
		{
			Application.OpenURL("https://www.youtube.com/watch?v=eP9-zycoHLk");
		}

		[ContextMenu("TUTORIAL VIDEO (PART 3: ANIMATION)")]
		private void OpenTutorial3()
		{
			Application.OpenURL("https://www.youtube.com/watch?v=sQfB2RcT1T4&index=14&list=PLVxSIA1OaTOu8Nos3CalXbJ2DrKnntMv6");
		}

		[ContextMenu("TUTORIAL VIDEO (PART 4: TRIGGERS)")]
		private void OpenTutorial4()
		{
			Application.OpenURL("https://www.youtube.com/watch?v=-TDZpNjt2mk&index=15&list=PLVxSIA1OaTOu8Nos3CalXbJ2DrKnntMv6");
		}

		[ContextMenu("Support Group")]
		private void SupportGroup()
		{
			Application.OpenURL("https://groups.google.com/forum/#!forum/final-ik");
		}

		[ContextMenu("Asset Store Thread")]
		private void ASThread()
		{
			Application.OpenURL("http://forum.unity3d.com/threads/final-ik-full-body-ik-aim-look-at-fabrik-ccd-ik-1-0-released.222685/");
		}

		public bool IsInInteraction(FullBodyBipedEffector effectorType)
		{
			if (!IsValid(log: true))
			{
				return false;
			}
			for (int i = 0; i < interactionEffectors.Length; i++)
			{
				if (interactionEffectors[i].effectorType == effectorType)
				{
					if (interactionEffectors[i].inInteraction)
					{
						return !interactionEffectors[i].isPaused;
					}
					return false;
				}
			}
			return false;
		}

		public bool IsPaused(FullBodyBipedEffector effectorType)
		{
			if (!IsValid(log: true))
			{
				return false;
			}
			for (int i = 0; i < interactionEffectors.Length; i++)
			{
				if (interactionEffectors[i].effectorType == effectorType)
				{
					if (interactionEffectors[i].inInteraction)
					{
						return interactionEffectors[i].isPaused;
					}
					return false;
				}
			}
			return false;
		}

		public bool IsPaused()
		{
			if (!IsValid(log: true))
			{
				return false;
			}
			for (int i = 0; i < interactionEffectors.Length; i++)
			{
				if (interactionEffectors[i].inInteraction && interactionEffectors[i].isPaused)
				{
					return true;
				}
			}
			return false;
		}

		public bool IsInSync()
		{
			if (!IsValid(log: true))
			{
				return false;
			}
			for (int i = 0; i < interactionEffectors.Length; i++)
			{
				if (!interactionEffectors[i].isPaused)
				{
					continue;
				}
				for (int j = 0; j < interactionEffectors.Length; j++)
				{
					if (j != i && interactionEffectors[j].inInteraction && !interactionEffectors[j].isPaused)
					{
						return false;
					}
				}
			}
			return true;
		}

		public bool StartInteraction(FullBodyBipedEffector effectorType, InteractionObject interactionObject, bool interrupt)
		{
			if (!IsValid(log: true))
			{
				return false;
			}
			if (interactionObject == null)
			{
				return false;
			}
			for (int i = 0; i < interactionEffectors.Length; i++)
			{
				if (interactionEffectors[i].effectorType == effectorType)
				{
					return interactionEffectors[i].Start(interactionObject, targetTag, fadeInTime, interrupt);
				}
			}
			return false;
		}

		public bool PauseInteraction(FullBodyBipedEffector effectorType)
		{
			if (!IsValid(log: true))
			{
				return false;
			}
			for (int i = 0; i < interactionEffectors.Length; i++)
			{
				if (interactionEffectors[i].effectorType == effectorType)
				{
					return interactionEffectors[i].Pause();
				}
			}
			return false;
		}

		public bool ResumeInteraction(FullBodyBipedEffector effectorType)
		{
			if (!IsValid(log: true))
			{
				return false;
			}
			for (int i = 0; i < interactionEffectors.Length; i++)
			{
				if (interactionEffectors[i].effectorType == effectorType)
				{
					return interactionEffectors[i].Resume();
				}
			}
			return false;
		}

		public bool StopInteraction(FullBodyBipedEffector effectorType)
		{
			if (!IsValid(log: true))
			{
				return false;
			}
			for (int i = 0; i < interactionEffectors.Length; i++)
			{
				if (interactionEffectors[i].effectorType == effectorType)
				{
					return interactionEffectors[i].Stop();
				}
			}
			return false;
		}

		public void PauseAll()
		{
			if (IsValid(log: true))
			{
				for (int i = 0; i < interactionEffectors.Length; i++)
				{
					interactionEffectors[i].Pause();
				}
			}
		}

		public void ResumeAll()
		{
			if (IsValid(log: true))
			{
				for (int i = 0; i < interactionEffectors.Length; i++)
				{
					interactionEffectors[i].Resume();
				}
			}
		}

		public void StopAll()
		{
			for (int i = 0; i < interactionEffectors.Length; i++)
			{
				interactionEffectors[i].Stop();
			}
		}

		public InteractionObject GetInteractionObject(FullBodyBipedEffector effectorType)
		{
			if (!IsValid(log: true))
			{
				return null;
			}
			for (int i = 0; i < interactionEffectors.Length; i++)
			{
				if (interactionEffectors[i].effectorType == effectorType)
				{
					return interactionEffectors[i].interactionObject;
				}
			}
			return null;
		}

		public float GetProgress(FullBodyBipedEffector effectorType)
		{
			if (!IsValid(log: true))
			{
				return 0f;
			}
			for (int i = 0; i < interactionEffectors.Length; i++)
			{
				if (interactionEffectors[i].effectorType == effectorType)
				{
					return interactionEffectors[i].progress;
				}
			}
			return 0f;
		}

		public float GetMinActiveProgress()
		{
			if (!IsValid(log: true))
			{
				return 0f;
			}
			float num = 1f;
			for (int i = 0; i < interactionEffectors.Length; i++)
			{
				if (interactionEffectors[i].inInteraction)
				{
					float progress = interactionEffectors[i].progress;
					if (progress > 0f && progress < num)
					{
						num = progress;
					}
				}
			}
			return num;
		}

		public bool TriggerInteraction(int index, bool interrupt)
		{
			if (!IsValid(log: true))
			{
				return false;
			}
			if (!TriggerIndexIsValid(index))
			{
				return false;
			}
			bool result = true;
			InteractionTrigger.Range range = triggersInRange[index].ranges[bestRangeIndexes[index]];
			for (int i = 0; i < range.interactions.Length; i++)
			{
				for (int j = 0; j < range.interactions[i].effectors.Length; j++)
				{
					if (!StartInteraction(range.interactions[i].effectors[j], range.interactions[i].interactionObject, interrupt))
					{
						result = false;
					}
				}
			}
			return result;
		}

		public bool TriggerInteraction(int index, bool interrupt, out InteractionObject interactionObject)
		{
			interactionObject = null;
			if (!IsValid(log: true))
			{
				return false;
			}
			if (!TriggerIndexIsValid(index))
			{
				return false;
			}
			bool result = true;
			InteractionTrigger.Range range = triggersInRange[index].ranges[bestRangeIndexes[index]];
			for (int i = 0; i < range.interactions.Length; i++)
			{
				for (int j = 0; j < range.interactions[i].effectors.Length; j++)
				{
					interactionObject = range.interactions[i].interactionObject;
					if (!StartInteraction(range.interactions[i].effectors[j], interactionObject, interrupt))
					{
						result = false;
					}
				}
			}
			return result;
		}

		public bool TriggerInteraction(int index, bool interrupt, out InteractionTarget interactionTarget)
		{
			interactionTarget = null;
			if (!IsValid(log: true))
			{
				return false;
			}
			if (!TriggerIndexIsValid(index))
			{
				return false;
			}
			bool result = true;
			InteractionTrigger.Range range = triggersInRange[index].ranges[bestRangeIndexes[index]];
			for (int i = 0; i < range.interactions.Length; i++)
			{
				for (int j = 0; j < range.interactions[i].effectors.Length; j++)
				{
					InteractionObject interactionObject = range.interactions[i].interactionObject;
					Transform target = interactionObject.GetTarget(range.interactions[i].effectors[j], base.tag);
					if (target != null)
					{
						interactionTarget = target.GetComponent<InteractionTarget>();
					}
					if (!StartInteraction(range.interactions[i].effectors[j], interactionObject, interrupt))
					{
						result = false;
					}
				}
			}
			return result;
		}

		public InteractionTrigger.Range GetClosestInteractionRange()
		{
			if (!IsValid(log: true))
			{
				return null;
			}
			int closestTriggerIndex = GetClosestTriggerIndex();
			if (closestTriggerIndex < 0 || closestTriggerIndex >= triggersInRange.Count)
			{
				return null;
			}
			return triggersInRange[closestTriggerIndex].ranges[bestRangeIndexes[closestTriggerIndex]];
		}

		public InteractionObject GetClosestInteractionObjectInRange()
		{
			InteractionTrigger.Range closestInteractionRange = GetClosestInteractionRange();
			if (closestInteractionRange == null)
			{
				return null;
			}
			return closestInteractionRange.interactions[0].interactionObject;
		}

		public InteractionTarget GetClosestInteractionTargetInRange()
		{
			InteractionTrigger.Range closestInteractionRange = GetClosestInteractionRange();
			if (closestInteractionRange == null)
			{
				return null;
			}
			return closestInteractionRange.interactions[0].interactionObject.GetTarget(closestInteractionRange.interactions[0].effectors[0], this);
		}

		public InteractionObject[] GetClosestInteractionObjectsInRange()
		{
			InteractionTrigger.Range closestInteractionRange = GetClosestInteractionRange();
			if (closestInteractionRange == null)
			{
				return new InteractionObject[0];
			}
			InteractionObject[] array = new InteractionObject[closestInteractionRange.interactions.Length];
			for (int i = 0; i < closestInteractionRange.interactions.Length; i++)
			{
				array[i] = closestInteractionRange.interactions[i].interactionObject;
			}
			return array;
		}

		public InteractionTarget[] GetClosestInteractionTargetsInRange()
		{
			InteractionTrigger.Range closestInteractionRange = GetClosestInteractionRange();
			if (closestInteractionRange == null)
			{
				return new InteractionTarget[0];
			}
			List<InteractionTarget> list = new List<InteractionTarget>();
			InteractionTrigger.Range.Interaction[] interactions = closestInteractionRange.interactions;
			foreach (InteractionTrigger.Range.Interaction interaction in interactions)
			{
				FullBodyBipedEffector[] effectors = interaction.effectors;
				foreach (FullBodyBipedEffector effectorType in effectors)
				{
					list.Add(interaction.interactionObject.GetTarget(effectorType, this));
				}
			}
			return list.ToArray();
		}

		public bool TriggerEffectorsReady(int index)
		{
			if (!IsValid(log: true))
			{
				return false;
			}
			if (!TriggerIndexIsValid(index))
			{
				return false;
			}
			for (int i = 0; i < triggersInRange[index].ranges.Length; i++)
			{
				InteractionTrigger.Range range = triggersInRange[index].ranges[i];
				for (int j = 0; j < range.interactions.Length; j++)
				{
					for (int k = 0; k < range.interactions[j].effectors.Length; k++)
					{
						if (IsInInteraction(range.interactions[j].effectors[k]))
						{
							return false;
						}
					}
				}
				for (int l = 0; l < range.interactions.Length; l++)
				{
					for (int m = 0; m < range.interactions[l].effectors.Length; m++)
					{
						if (!IsPaused(range.interactions[l].effectors[m]))
						{
							continue;
						}
						for (int n = 0; n < range.interactions[l].effectors.Length; n++)
						{
							if (n != m && !IsPaused(range.interactions[l].effectors[n]))
							{
								return false;
							}
						}
					}
				}
			}
			return true;
		}

		public InteractionTrigger.Range GetTriggerRange(int index)
		{
			if (!IsValid(log: true))
			{
				return null;
			}
			if (index < 0 || index >= bestRangeIndexes.Count)
			{
				Warning.Log("Index out of range.", base.transform);
				return null;
			}
			return triggersInRange[index].ranges[bestRangeIndexes[index]];
		}

		public int GetClosestTriggerIndex()
		{
			if (!IsValid(log: true))
			{
				return -1;
			}
			if (triggersInRange.Count == 0)
			{
				return -1;
			}
			if (triggersInRange.Count == 1)
			{
				return 0;
			}
			int result = -1;
			float num = float.PositiveInfinity;
			for (int i = 0; i < triggersInRange.Count; i++)
			{
				if (triggersInRange[i] != null)
				{
					float num2 = Vector3.SqrMagnitude(triggersInRange[i].transform.position - base.transform.position);
					if (num2 < num)
					{
						result = i;
						num = num2;
					}
				}
			}
			return result;
		}

		protected virtual void Start()
		{
			if (fullBody == null)
			{
				fullBody = GetComponent<FullBodyBipedIK>();
			}
			if (fullBody == null)
			{
				Warning.Log("InteractionSystem can not find a FullBodyBipedIK component", base.transform);
				return;
			}
			IKSolverFullBodyBiped solver = fullBody.solver;
			solver.OnPreUpdate = (IKSolver.UpdateDelegate)Delegate.Combine(solver.OnPreUpdate, new IKSolver.UpdateDelegate(OnPreFBBIK));
			IKSolverFullBodyBiped solver2 = fullBody.solver;
			solver2.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Combine(solver2.OnPostUpdate, new IKSolver.UpdateDelegate(OnPostFBBIK));
			OnInteractionStart = (InteractionDelegate)Delegate.Combine(OnInteractionStart, new InteractionDelegate(LookAtInteraction));
			OnInteractionPause = (InteractionDelegate)Delegate.Combine(OnInteractionPause, new InteractionDelegate(InteractionPause));
			OnInteractionResume = (InteractionDelegate)Delegate.Combine(OnInteractionResume, new InteractionDelegate(InteractionResume));
			OnInteractionStop = (InteractionDelegate)Delegate.Combine(OnInteractionStop, new InteractionDelegate(InteractionStop));
			InteractionEffector[] array = interactionEffectors;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].Initiate(this);
			}
			triggersInRange = new List<InteractionTrigger>();
			c = GetComponent<Collider>();
			UpdateTriggerEventBroadcasting();
			initiated = true;
		}

		private void InteractionPause(FullBodyBipedEffector effector, InteractionObject interactionObject)
		{
			lookAt.isPaused = true;
		}

		private void InteractionResume(FullBodyBipedEffector effector, InteractionObject interactionObject)
		{
			lookAt.isPaused = false;
		}

		private void InteractionStop(FullBodyBipedEffector effector, InteractionObject interactionObject)
		{
			lookAt.isPaused = false;
		}

		private void LookAtInteraction(FullBodyBipedEffector effector, InteractionObject interactionObject)
		{
			lookAt.Look(interactionObject.lookAtTarget, Time.time + interactionObject.length * 0.5f);
		}

		public void OnTriggerEnter(Collider c)
		{
			if (!(fullBody == null))
			{
				InteractionTrigger component = c.GetComponent<InteractionTrigger>();
				if (!(component == null) && !inContact.Contains(component))
				{
					inContact.Add(component);
				}
			}
		}

		public void OnTriggerExit(Collider c)
		{
			if (!(fullBody == null))
			{
				InteractionTrigger component = c.GetComponent<InteractionTrigger>();
				if (!(component == null))
				{
					inContact.Remove(component);
				}
			}
		}

		private bool ContactIsInRange(int index, out int bestRangeIndex)
		{
			bestRangeIndex = -1;
			if (!IsValid(log: true))
			{
				return false;
			}
			if (index < 0 || index >= inContact.Count)
			{
				Warning.Log("Index out of range.", base.transform);
				return false;
			}
			if (inContact[index] == null)
			{
				Warning.Log("The InteractionTrigger in the list 'inContact' has been destroyed", base.transform);
				return false;
			}
			bestRangeIndex = inContact[index].GetBestRangeIndex(base.transform, FPSCamera, raycastHit);
			if (bestRangeIndex == -1)
			{
				return false;
			}
			return true;
		}

		private void OnDrawGizmosSelected()
		{
			if (!Application.isPlaying)
			{
				if (fullBody == null)
				{
					fullBody = GetComponent<FullBodyBipedIK>();
				}
				if (characterCollider == null)
				{
					characterCollider = GetComponent<Collider>();
				}
			}
		}

		private void Update()
		{
			if (fullBody == null)
			{
				return;
			}
			UpdateTriggerEventBroadcasting();
			Raycasting();
			triggersInRange.Clear();
			bestRangeIndexes.Clear();
			for (int i = 0; i < inContact.Count; i++)
			{
				int bestRangeIndex = -1;
				if (inContact[i] != null && inContact[i].gameObject.activeInHierarchy && inContact[i].enabled && ContactIsInRange(i, out bestRangeIndex))
				{
					triggersInRange.Add(inContact[i]);
					bestRangeIndexes.Add(bestRangeIndex);
				}
			}
			lookAt.Update();
		}

		private void Raycasting()
		{
			if ((int)camRaycastLayers != -1 && !(FPSCamera == null))
			{
				Physics.Raycast(FPSCamera.position, FPSCamera.forward, out raycastHit, camRaycastDistance, camRaycastLayers);
			}
		}

		private void UpdateTriggerEventBroadcasting()
		{
			if (characterCollider == null)
			{
				characterCollider = c;
			}
			if (characterCollider != null && characterCollider != c)
			{
				if (characterCollider.GetComponent<TriggerEventBroadcaster>() == null)
				{
					characterCollider.gameObject.AddComponent<TriggerEventBroadcaster>().target = base.gameObject;
				}
				if (lastCollider != null && lastCollider != c && lastCollider != characterCollider)
				{
					TriggerEventBroadcaster component = lastCollider.GetComponent<TriggerEventBroadcaster>();
					if (component != null)
					{
						UnityEngine.Object.Destroy(component);
					}
				}
			}
			lastCollider = characterCollider;
		}

		private void LateUpdate()
		{
			if (!(fullBody == null))
			{
				for (int i = 0; i < interactionEffectors.Length; i++)
				{
					interactionEffectors[i].Update(base.transform, speed);
				}
				for (int j = 0; j < interactionEffectors.Length; j++)
				{
					interactionEffectors[j].ResetToDefaults(resetToDefaultsSpeed * speed);
				}
			}
		}

		private void OnPreFBBIK()
		{
			if (base.enabled && !(fullBody == null))
			{
				lookAt.SolveSpine();
			}
		}

		private void OnPostFBBIK()
		{
			if (base.enabled && !(fullBody == null))
			{
				for (int i = 0; i < interactionEffectors.Length; i++)
				{
					interactionEffectors[i].OnPostFBBIK();
				}
				lookAt.SolveHead();
			}
		}

		private void OnDestroy()
		{
			if (!(fullBody == null))
			{
				IKSolverFullBodyBiped solver = fullBody.solver;
				solver.OnPreUpdate = (IKSolver.UpdateDelegate)Delegate.Remove(solver.OnPreUpdate, new IKSolver.UpdateDelegate(OnPreFBBIK));
				IKSolverFullBodyBiped solver2 = fullBody.solver;
				solver2.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Remove(solver2.OnPostUpdate, new IKSolver.UpdateDelegate(OnPostFBBIK));
				OnInteractionStart = (InteractionDelegate)Delegate.Remove(OnInteractionStart, new InteractionDelegate(LookAtInteraction));
				OnInteractionPause = (InteractionDelegate)Delegate.Remove(OnInteractionPause, new InteractionDelegate(InteractionPause));
				OnInteractionResume = (InteractionDelegate)Delegate.Remove(OnInteractionResume, new InteractionDelegate(InteractionResume));
				OnInteractionStop = (InteractionDelegate)Delegate.Remove(OnInteractionStop, new InteractionDelegate(InteractionStop));
			}
		}

		private bool IsValid(bool log)
		{
			if (fullBody == null)
			{
				if (log)
				{
					Warning.Log("FBBIK is null. Will not update the InteractionSystem", base.transform);
				}
				return false;
			}
			if (!initiated)
			{
				if (log)
				{
					Warning.Log("The InteractionSystem has not been initiated yet.", base.transform);
				}
				return false;
			}
			return true;
		}

		private bool TriggerIndexIsValid(int index)
		{
			if (index < 0 || index >= triggersInRange.Count)
			{
				Warning.Log("Index out of range.", base.transform);
				return false;
			}
			if (triggersInRange[index] == null)
			{
				Warning.Log("The InteractionTrigger in the list 'inContact' has been destroyed", base.transform);
				return false;
			}
			return true;
		}

		[ContextMenu("User Manual")]
		private void OpenUserManual()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/page10.html");
		}

		[ContextMenu("Scrpt Reference")]
		private void OpenScriptReference()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/class_root_motion_1_1_final_i_k_1_1_interaction_system.html");
		}
	}
	[HelpURL("https://www.youtube.com/watch?v=r5jiZnsDH3M")]
	[AddComponentMenu("Scripts/RootMotion.FinalIK/Interaction System/Interaction Target")]
	public class InteractionTarget : MonoBehaviour
	{
		[Serializable]
		public class Multiplier
		{
			[Tooltip("The curve type (InteractionObject.WeightCurve.Type).")]
			public InteractionObject.WeightCurve.Type curve;

			[Tooltip("Multiplier of the curve's value.")]
			public float multiplier;
		}

		[Tooltip("The type of the FBBIK effector.")]
		public FullBodyBipedEffector effectorType;

		[Tooltip("InteractionObject weight curve multipliers for this effector target.")]
		public Multiplier[] multipliers;

		[Tooltip("The interaction speed multiplier for this effector. This can be used to make interactions faster/slower for specific effectors.")]
		public float interactionSpeedMlp = 1f;

		[Tooltip("The pivot to twist/swing this interaction target about. For symmetric objects that can be interacted with from a certain angular range.")]
		public Transform pivot;

		[Tooltip("The axis of twisting the interaction target (blue line).")]
		public Vector3 twistAxis = Vector3.up;

		[Tooltip("The weight of twisting the interaction target towards the effector bone in the start of the interaction.")]
		public float twistWeight = 1f;

		[Tooltip("The weight of swinging the interaction target towards the effector bone in the start of the interaction. Swing is defined as a 3-DOF rotation around any axis, while twist is only around the twist axis.")]
		public float swingWeight;

		[Tooltip("If true, will twist/swing around the pivot only once at the start of the interaction. If false, will continue rotating throuout the whole interaction.")]
		public bool rotateOnce = true;

		private Quaternion defaultLocalRotation;

		private Transform lastPivot;

		[ContextMenu("TUTORIAL VIDEO (PART 1: BASICS)")]
		private void OpenTutorial1()
		{
			Application.OpenURL("https://www.youtube.com/watch?v=r5jiZnsDH3M");
		}

		[ContextMenu("TUTORIAL VIDEO (PART 2: PICKING UP...)")]
		private void OpenTutorial2()
		{
			Application.OpenURL("https://www.youtube.com/watch?v=eP9-zycoHLk");
		}

		[ContextMenu("TUTORIAL VIDEO (PART 3: ANIMATION)")]
		private void OpenTutorial3()
		{
			Application.OpenURL("https://www.youtube.com/watch?v=sQfB2RcT1T4&index=14&list=PLVxSIA1OaTOu8Nos3CalXbJ2DrKnntMv6");
		}

		[ContextMenu("TUTORIAL VIDEO (PART 4: TRIGGERS)")]
		private void OpenTutorial4()
		{
			Application.OpenURL("https://www.youtube.com/watch?v=-TDZpNjt2mk&index=15&list=PLVxSIA1OaTOu8Nos3CalXbJ2DrKnntMv6");
		}

		[ContextMenu("Support Group")]
		private void SupportGroup()
		{
			Application.OpenURL("https://groups.google.com/forum/#!forum/final-ik");
		}

		[ContextMenu("Asset Store Thread")]
		private void ASThread()
		{
			Application.OpenURL("http://forum.unity3d.com/threads/final-ik-full-body-ik-aim-look-at-fabrik-ccd-ik-1-0-released.222685/");
		}

		public float GetValue(InteractionObject.WeightCurve.Type curveType)
		{
			for (int i = 0; i < multipliers.Length; i++)
			{
				if (multipliers[i].curve == curveType)
				{
					return multipliers[i].multiplier;
				}
			}
			return 1f;
		}

		public void ResetRotation()
		{
			if (pivot != null)
			{
				pivot.localRotation = defaultLocalRotation;
			}
		}

		public void RotateTo(Vector3 position)
		{
			if (!(pivot == null))
			{
				if (pivot != lastPivot)
				{
					defaultLocalRotation = pivot.localRotation;
					lastPivot = pivot;
				}
				pivot.localRotation = defaultLocalRotation;
				if (twistWeight > 0f)
				{
					Vector3 tangent = base.transform.position - pivot.position;
					Vector3 vector = pivot.rotation * twistAxis;
					Vector3 normal = vector;
					Vector3.OrthoNormalize(ref normal, ref tangent);
					normal = vector;
					Vector3 tangent2 = position - pivot.position;
					Vector3.OrthoNormalize(ref normal, ref tangent2);
					Quaternion b = QuaTools.FromToAroundAxis(tangent, tangent2, vector);
					pivot.rotation = Quaternion.Lerp(Quaternion.identity, b, twistWeight) * pivot.rotation;
				}
				if (swingWeight > 0f)
				{
					Quaternion b2 = Quaternion.FromToRotation(base.transform.position - pivot.position, position - pivot.position);
					pivot.rotation = Quaternion.Lerp(Quaternion.identity, b2, swingWeight) * pivot.rotation;
				}
			}
		}

		[ContextMenu("User Manual")]
		private void OpenUserManual()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/page10.html");
		}

		[ContextMenu("Scrpt Reference")]
		private void OpenScriptReference()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/class_root_motion_1_1_final_i_k_1_1_interaction_target.html");
		}
	}
	[HelpURL("https://www.youtube.com/watch?v=-TDZpNjt2mk&index=15&list=PLVxSIA1OaTOu8Nos3CalXbJ2DrKnntMv6")]
	[AddComponentMenu("Scripts/RootMotion.FinalIK/Interaction System/Interaction Trigger")]
	public class InteractionTrigger : MonoBehaviour
	{
		[Serializable]
		public class CharacterPosition
		{
			[Tooltip("If false, will not care where the character stands, as long as it is in contact with the trigger collider.")]
			public bool use;

			[Tooltip("The offset of the character's position relative to the trigger in XZ plane. Y position of the character is unlimited as long as it is contact with the collider.")]
			public Vector2 offset;

			[Tooltip("Angle offset from the default forward direction.")]
			[Range(-180f, 180f)]
			public float angleOffset;

			[Tooltip("Max angular offset of the character's forward from the direction of this trigger.")]
			[Range(0f, 180f)]
			public float maxAngle = 45f;

			[Tooltip("Max offset of the character's position from this range's center.")]
			public float radius = 0.5f;

			[Tooltip("If true, will rotate the trigger around it's Y axis relative to the position of the character, so the object can be interacted with from all sides.")]
			public bool orbit;

			[Tooltip("Fixes the Y axis of the trigger to Vector3.up. This makes the trigger symmetrical relative to the object. For example a gun will be able to be picked up from the same direction relative to the barrel no matter which side the gun is resting on.")]
			public bool fixYAxis;

			public Vector3 offset3D => new Vector3(offset.x, 0f, offset.y);

			public Vector3 direction3D => Quaternion.AngleAxis(angleOffset, Vector3.up) * Vector3.forward;

			public bool IsInRange(Transform character, Transform trigger, out float error)
			{
				error = 0f;
				if (!use)
				{
					return true;
				}
				error = 180f;
				if (radius <= 0f)
				{
					return false;
				}
				if (maxAngle <= 0f)
				{
					return false;
				}
				Vector3 forward = trigger.forward;
				if (fixYAxis)
				{
					forward.y = 0f;
				}
				if (forward == Vector3.zero)
				{
					return false;
				}
				Vector3 normal = (fixYAxis ? Vector3.up : trigger.up);
				Quaternion quaternion = Quaternion.LookRotation(forward, normal);
				Vector3 vector = trigger.position + quaternion * offset3D;
				Vector3 vector2 = (orbit ? trigger.position : vector);
				Vector3 tangent = character.position - vector2;
				Vector3.OrthoNormalize(ref normal, ref tangent);
				tangent *= Vector3.Project(character.position - vector2, tangent).magnitude;
				if (orbit)
				{
					float magnitude = offset.magnitude;
					float magnitude2 = tangent.magnitude;
					if (magnitude2 < magnitude - radius || magnitude2 > magnitude + radius)
					{
						return false;
					}
				}
				else if (tangent.magnitude > radius)
				{
					return false;
				}
				Vector3 tangent2 = quaternion * direction3D;
				Vector3.OrthoNormalize(ref normal, ref tangent2);
				if (orbit)
				{
					Vector3 vector3 = vector - trigger.position;
					if (vector3 == Vector3.zero)
					{
						vector3 = Vector3.forward;
					}
					tangent = Quaternion.Inverse(Quaternion.LookRotation(vector3, normal)) * tangent;
					tangent2 = Quaternion.AngleAxis(Mathf.Atan2(tangent.x, tangent.z) * 57.29578f, normal) * tangent2;
				}
				float num = Vector3.Angle(tangent2, character.forward);
				if (num > maxAngle)
				{
					return false;
				}
				error = num / maxAngle * 180f;
				return true;
			}
		}

		[Serializable]
		public class CameraPosition
		{
			[Tooltip("What the camera should be looking at to trigger the interaction?")]
			public Collider lookAtTarget;

			[Tooltip("The direction from the lookAtTarget towards the camera (in lookAtTarget's space).")]
			public Vector3 direction = -Vector3.forward;

			[Tooltip("Max distance from the lookAtTarget to the camera.")]
			public float maxDistance = 0.5f;

			[Tooltip("Max angle between the direction and the direction towards the camera.")]
			[Range(0f, 180f)]
			public float maxAngle = 45f;

			[Tooltip("Fixes the Y axis of the trigger to Vector3.up. This makes the trigger symmetrical relative to the object.")]
			public bool fixYAxis;

			public Quaternion GetRotation()
			{
				Vector3 forward = lookAtTarget.transform.forward;
				if (fixYAxis)
				{
					forward.y = 0f;
				}
				if (forward == Vector3.zero)
				{
					return Quaternion.identity;
				}
				Vector3 upwards = (fixYAxis ? Vector3.up : lookAtTarget.transform.up);
				return Quaternion.LookRotation(forward, upwards);
			}

			public bool IsInRange(Transform raycastFrom, RaycastHit hit, Transform trigger, out float error)
			{
				error = 0f;
				if (lookAtTarget == null)
				{
					return true;
				}
				error = 180f;
				if (raycastFrom == null)
				{
					return false;
				}
				if (hit.collider != lookAtTarget)
				{
					return false;
				}
				if (hit.distance > maxDistance)
				{
					return false;
				}
				if (direction == Vector3.zero)
				{
					return false;
				}
				if (maxDistance <= 0f)
				{
					return false;
				}
				if (maxAngle <= 0f)
				{
					return false;
				}
				Vector3 to = GetRotation() * direction;
				float num = Vector3.Angle(raycastFrom.position - hit.point, to);
				if (num > maxAngle)
				{
					return false;
				}
				error = num / maxAngle * 180f;
				return true;
			}
		}

		[Serializable]
		public class Range
		{
			[Serializable]
			public class Interaction
			{
				[Tooltip("The InteractionObject to interact with.")]
				public InteractionObject interactionObject;

				[Tooltip("The effectors to interact with.")]
				public FullBodyBipedEffector[] effectors;
			}

			[HideInInspector]
			[SerializeField]
			public string name;

			[HideInInspector]
			[SerializeField]
			public bool show = true;

			[Tooltip("The range for the character's position and rotation.")]
			public CharacterPosition characterPosition;

			[Tooltip("The range for the character camera's position and rotation.")]
			public CameraPosition cameraPosition;

			[Tooltip("Definitions of the interactions associated with this range.")]
			public Interaction[] interactions;

			public bool IsInRange(Transform character, Transform raycastFrom, RaycastHit raycastHit, Transform trigger, out float maxError)
			{
				maxError = 0f;
				float error = 0f;
				float error2 = 0f;
				if (!characterPosition.IsInRange(character, trigger, out error))
				{
					return false;
				}
				if (!cameraPosition.IsInRange(raycastFrom, raycastHit, trigger, out error2))
				{
					return false;
				}
				maxError = Mathf.Max(error, error2);
				return true;
			}
		}

		[Tooltip("The valid ranges of the character's and/or it's camera's position for triggering interaction when the character is in contact with the collider of this trigger.")]
		public Range[] ranges = new Range[0];

		[ContextMenu("TUTORIAL VIDEO")]
		private void OpenTutorial4()
		{
			Application.OpenURL("https://www.youtube.com/watch?v=-TDZpNjt2mk&index=15&list=PLVxSIA1OaTOu8Nos3CalXbJ2DrKnntMv6");
		}

		[ContextMenu("Support Group")]
		private void SupportGroup()
		{
			Application.OpenURL("https://groups.google.com/forum/#!forum/final-ik");
		}

		[ContextMenu("Asset Store Thread")]
		private void ASThread()
		{
			Application.OpenURL("http://forum.unity3d.com/threads/final-ik-full-body-ik-aim-look-at-fabrik-ccd-ik-1-0-released.222685/");
		}

		private void Start()
		{
		}

		public int GetBestRangeIndex(Transform character, Transform raycastFrom, RaycastHit raycastHit)
		{
			if (GetComponent<Collider>() == null)
			{
				Warning.Log("Using the InteractionTrigger requires a Collider component.", base.transform);
				return -1;
			}
			int result = -1;
			float num = 180f;
			float maxError = 0f;
			for (int i = 0; i < ranges.Length; i++)
			{
				if (ranges[i].IsInRange(character, raycastFrom, raycastHit, base.transform, out maxError) && maxError <= num)
				{
					num = maxError;
					result = i;
				}
			}
			return result;
		}
	}
	public class GenericPoser : Poser
	{
		[Serializable]
		public class Map
		{
			public Transform bone;

			public Transform target;

			private Vector3 defaultLocalPosition;

			private Quaternion defaultLocalRotation;

			public Map(Transform bone, Transform target)
			{
				this.bone = bone;
				this.target = target;
				StoreDefaultState();
			}

			public void StoreDefaultState()
			{
				defaultLocalPosition = bone.localPosition;
				defaultLocalRotation = bone.localRotation;
			}

			public void FixTransform()
			{
				bone.localPosition = defaultLocalPosition;
				bone.localRotation = defaultLocalRotation;
			}

			public void Update(float localRotationWeight, float localPositionWeight)
			{
				bone.localRotation = Quaternion.Lerp(bone.localRotation, target.localRotation, localRotationWeight);
				bone.localPosition = Vector3.Lerp(bone.localPosition, target.localPosition, localPositionWeight);
			}
		}

		public Map[] maps;

		[ContextMenu("Auto-Mapping")]
		public override void AutoMapping()
		{
			if (poseRoot == null)
			{
				maps = new Map[0];
				return;
			}
			maps = new Map[0];
			Transform[] componentsInChildren = base.transform.GetComponentsInChildren<Transform>();
			Transform[] componentsInChildren2 = poseRoot.GetComponentsInChildren<Transform>();
			for (int i = 1; i < componentsInChildren.Length; i++)
			{
				Transform targetNamed = GetTargetNamed(componentsInChildren[i].name, componentsInChildren2);
				if (targetNamed != null)
				{
					Array.Resize(ref maps, maps.Length + 1);
					maps[maps.Length - 1] = new Map(componentsInChildren[i], targetNamed);
				}
			}
			StoreDefaultState();
		}

		protected override void InitiatePoser()
		{
			StoreDefaultState();
		}

		protected override void UpdatePoser()
		{
			if (!(weight <= 0f) && (!(localPositionWeight <= 0f) || !(localRotationWeight <= 0f)) && !(poseRoot == null))
			{
				float num = localRotationWeight * weight;
				float num2 = localPositionWeight * weight;
				for (int i = 0; i < maps.Length; i++)
				{
					maps[i].Update(num, num2);
				}
			}
		}

		protected override void FixPoserTransforms()
		{
			for (int i = 0; i < maps.Length; i++)
			{
				maps[i].FixTransform();
			}
		}

		private void StoreDefaultState()
		{
			for (int i = 0; i < maps.Length; i++)
			{
				maps[i].StoreDefaultState();
			}
		}

		private Transform GetTargetNamed(string tName, Transform[] array)
		{
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i].name == tName)
				{
					return array[i];
				}
			}
			return null;
		}
	}
	public class HandPoser : Poser
	{
		private Transform _poseRoot;

		private Transform[] children;

		private Transform[] poseChildren;

		private Vector3[] defaultLocalPositions;

		private Quaternion[] defaultLocalRotations;

		public override void AutoMapping()
		{
			if (poseRoot == null)
			{
				poseChildren = new Transform[0];
			}
			else
			{
				poseChildren = poseRoot.GetComponentsInChildren<Transform>();
			}
			_poseRoot = poseRoot;
		}

		protected override void InitiatePoser()
		{
			children = GetComponentsInChildren<Transform>();
			StoreDefaultState();
		}

		protected override void FixPoserTransforms()
		{
			for (int i = 0; i < children.Length; i++)
			{
				children[i].localPosition = defaultLocalPositions[i];
				children[i].localRotation = defaultLocalRotations[i];
			}
		}

		protected override void UpdatePoser()
		{
			if (weight <= 0f || (localPositionWeight <= 0f && localRotationWeight <= 0f))
			{
				return;
			}
			if (_poseRoot != poseRoot)
			{
				AutoMapping();
			}
			if (poseRoot == null)
			{
				return;
			}
			if (children.Length != poseChildren.Length)
			{
				Warning.Log("Number of children does not match with the pose", base.transform);
				return;
			}
			float t = localRotationWeight * weight;
			float t2 = localPositionWeight * weight;
			for (int i = 0; i < children.Length; i++)
			{
				if (children[i] != base.transform)
				{
					children[i].localRotation = Quaternion.Lerp(children[i].localRotation, poseChildren[i].localRotation, t);
					children[i].localPosition = Vector3.Lerp(children[i].localPosition, poseChildren[i].localPosition, t2);
				}
			}
		}

		private void StoreDefaultState()
		{
			defaultLocalPositions = new Vector3[children.Length];
			defaultLocalRotations = new Quaternion[children.Length];
			for (int i = 0; i < children.Length; i++)
			{
				defaultLocalPositions[i] = children[i].localPosition;
				defaultLocalRotations[i] = children[i].localRotation;
			}
		}
	}
	public abstract class Poser : SolverManager
	{
		public Transform poseRoot;

		[Range(0f, 1f)]
		public float weight = 1f;

		[Range(0f, 1f)]
		public float localRotationWeight = 1f;

		[Range(0f, 1f)]
		public float localPositionWeight;

		private bool initiated;

		public abstract void AutoMapping();

		protected abstract void InitiatePoser();

		protected abstract void UpdatePoser();

		protected abstract void FixPoserTransforms();

		protected override void UpdateSolver()
		{
			if (!initiated)
			{
				InitiateSolver();
			}
			if (initiated)
			{
				UpdatePoser();
			}
		}

		protected override void InitiateSolver()
		{
			if (!initiated)
			{
				InitiatePoser();
				initiated = true;
			}
		}

		protected override void FixTransforms()
		{
			if (initiated)
			{
				FixPoserTransforms();
			}
		}
	}
	[RequireComponent(typeof(Animator))]
	public class RagdollUtility : MonoBehaviour
	{
		public class Rigidbone
		{
			public Rigidbody r;

			public Transform t;

			public Collider collider;

			public Joint joint;

			public Rigidbody c;

			public bool updateAnchor;

			public Vector3 deltaPosition;

			public Quaternion deltaRotation;

			public float deltaTime;

			public Vector3 lastPosition;

			public Quaternion lastRotation;

			public Rigidbone(Rigidbody r)
			{
				this.r = r;
				t = r.transform;
				joint = t.GetComponent<Joint>();
				collider = t.GetComponent<Collider>();
				if (joint != null)
				{
					c = joint.connectedBody;
					updateAnchor = c != null;
				}
				lastPosition = t.position;
				lastRotation = t.rotation;
			}

			public void RecordVelocity()
			{
				deltaPosition = t.position - lastPosition;
				lastPosition = t.position;
				deltaRotation = QuaTools.FromToRotation(lastRotation, t.rotation);
				lastRotation = t.rotation;
				deltaTime = Time.deltaTime;
			}

			public void WakeUp(float velocityWeight, float angularVelocityWeight)
			{
				if (updateAnchor)
				{
					joint.connectedAnchor = t.InverseTransformPoint(c.position);
				}
				r.isKinematic = false;
				if (velocityWeight != 0f)
				{
					r.velocity = deltaPosition / deltaTime * velocityWeight;
				}
				if (angularVelocityWeight != 0f)
				{
					float angle = 0f;
					Vector3 axis = Vector3.zero;
					deltaRotation.ToAngleAxis(out angle, out axis);
					angle *= (float)Math.PI / 180f;
					angle /= deltaTime;
					axis *= angle * angularVelocityWeight;
					r.angularVelocity = Vector3.ClampMagnitude(axis, r.maxAngularVelocity);
				}
				r.WakeUp();
			}
		}

		public class Child
		{
			public Transform t;

			public Vector3 localPosition;

			public Quaternion localRotation;

			public Child(Transform transform)
			{
				t = transform;
				localPosition = t.localPosition;
				localRotation = t.localRotation;
			}

			public void FixTransform(float weight)
			{
				if (!(weight <= 0f))
				{
					if (weight >= 1f)
					{
						t.localPosition = localPosition;
						t.localRotation = localRotation;
					}
					else
					{
						t.localPosition = Vector3.Lerp(t.localPosition, localPosition, weight);
						t.localRotation = Quaternion.Lerp(t.localRotation, localRotation, weight);
					}
				}
			}

			public void StoreLocalState()
			{
				localPosition = t.localPosition;
				localRotation = t.localRotation;
			}
		}

		[Tooltip("If you have multiple IK components, then this should be the one that solves last each frame.")]
		public IK ik;

		[Tooltip("How long does it take to blend from ragdoll to animation?")]
		public float ragdollToAnimationTime = 0.2f;

		[Tooltip("If true, IK can be used on top of physical ragdoll simulation.")]
		public bool applyIkOnRagdoll;

		[Tooltip("How much velocity transfer from animation to ragdoll?")]
		public float applyVelocity = 1f;

		[Tooltip("How much angular velocity to transfer from animation to ragdoll?")]
		public float applyAngularVelocity = 1f;

		private Animator animator;

		private Rigidbone[] rigidbones = new Rigidbone[0];

		private Child[] children = new Child[0];

		private bool enableRagdollFlag;

		private AnimatorUpdateMode animatorUpdateMode;

		private IK[] allIKComponents = new IK[0];

		private bool[] fixTransforms = new bool[0];

		private float ragdollWeight;

		private float ragdollWeightV;

		private bool fixedFrame;

		private bool[] disabledIKComponents = new bool[0];

		private bool isRagdoll
		{
			get
			{
				if (!rigidbones[0].r.isKinematic)
				{
					return !animator.enabled;
				}
				return false;
			}
		}

		private bool ikUsed
		{
			get
			{
				if (ik == null)
				{
					return false;
				}
				if (ik.enabled && ik.GetIKSolver().IKPositionWeight > 0f)
				{
					return true;
				}
				IK[] array = allIKComponents;
				foreach (IK iK in array)
				{
					if (iK.enabled && iK.GetIKSolver().IKPositionWeight > 0f)
					{
						return true;
					}
				}
				return false;
			}
		}

		public void EnableRagdoll()
		{
			if (!isRagdoll)
			{
				StopAllCoroutines();
				enableRagdollFlag = true;
			}
		}

		public void DisableRagdoll()
		{
			if (isRagdoll)
			{
				StoreLocalState();
				StopAllCoroutines();
				StartCoroutine(DisableRagdollSmooth());
			}
		}

		public void Start()
		{
			animator = GetComponent<Animator>();
			allIKComponents = GetComponentsInChildren<IK>();
			disabledIKComponents = new bool[allIKComponents.Length];
			fixTransforms = new bool[allIKComponents.Length];
			if (ik != null)
			{
				IKSolver iKSolver = ik.GetIKSolver();
				iKSolver.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Combine(iKSolver.OnPostUpdate, new IKSolver.UpdateDelegate(AfterLastIK));
			}
			Rigidbody[] componentsInChildren = GetComponentsInChildren<Rigidbody>();
			int num = ((componentsInChildren[0].gameObject == base.gameObject) ? 1 : 0);
			rigidbones = new Rigidbone[(num == 0) ? componentsInChildren.Length : (componentsInChildren.Length - 1)];
			for (int i = 0; i < rigidbones.Length; i++)
			{
				rigidbones[i] = new Rigidbone(componentsInChildren[i + num]);
			}
			Transform[] componentsInChildren2 = GetComponentsInChildren<Transform>();
			children = new Child[componentsInChildren2.Length - 1];
			for (int j = 0; j < children.Length; j++)
			{
				children[j] = new Child(componentsInChildren2[j + 1]);
			}
		}

		private IEnumerator DisableRagdollSmooth()
		{
			for (int i = 0; i < rigidbones.Length; i++)
			{
				rigidbones[i].r.isKinematic = true;
			}
			for (int j = 0; j < allIKComponents.Length; j++)
			{
				allIKComponents[j].fixTransforms = fixTransforms[j];
				if (disabledIKComponents[j])
				{
					allIKComponents[j].enabled = true;
				}
			}
			animator.updateMode = animatorUpdateMode;
			animator.enabled = true;
			while (ragdollWeight > 0f)
			{
				ragdollWeight = Mathf.SmoothDamp(ragdollWeight, 0f, ref ragdollWeightV, ragdollToAnimationTime);
				if (ragdollWeight < 0.001f)
				{
					ragdollWeight = 0f;
				}
				yield return null;
			}
			yield return null;
		}

		private void Update()
		{
			if (!isRagdoll)
			{
				return;
			}
			if (!applyIkOnRagdoll)
			{
				bool flag = false;
				for (int i = 0; i < allIKComponents.Length; i++)
				{
					if (allIKComponents[i].enabled)
					{
						flag = true;
						break;
					}
				}
				if (flag)
				{
					for (int j = 0; j < allIKComponents.Length; j++)
					{
						disabledIKComponents[j] = false;
					}
				}
				for (int k = 0; k < allIKComponents.Length; k++)
				{
					if (allIKComponents[k].enabled)
					{
						allIKComponents[k].enabled = false;
						disabledIKComponents[k] = true;
					}
				}
				return;
			}
			bool flag2 = false;
			for (int l = 0; l < allIKComponents.Length; l++)
			{
				if (disabledIKComponents[l])
				{
					flag2 = true;
					break;
				}
			}
			if (!flag2)
			{
				return;
			}
			for (int m = 0; m < allIKComponents.Length; m++)
			{
				if (disabledIKComponents[m])
				{
					allIKComponents[m].enabled = true;
				}
			}
			for (int n = 0; n < allIKComponents.Length; n++)
			{
				disabledIKComponents[n] = false;
			}
		}

		private void FixedUpdate()
		{
			if (isRagdoll && applyIkOnRagdoll)
			{
				FixTransforms(1f);
			}
			fixedFrame = true;
		}

		private void LateUpdate()
		{
			if (animator.updateMode != AnimatorUpdateMode.AnimatePhysics || (animator.updateMode == AnimatorUpdateMode.AnimatePhysics && fixedFrame))
			{
				AfterAnimation();
			}
			fixedFrame = false;
			if (!ikUsed)
			{
				OnFinalPose();
			}
		}

		private void AfterLastIK()
		{
			if (ikUsed)
			{
				OnFinalPose();
			}
		}

		private void AfterAnimation()
		{
			if (isRagdoll)
			{
				StoreLocalState();
			}
			else
			{
				FixTransforms(ragdollWeight);
			}
		}

		private void OnFinalPose()
		{
			if (!isRagdoll)
			{
				RecordVelocities();
			}
			if (enableRagdollFlag)
			{
				RagdollEnabler();
			}
		}

		private void RagdollEnabler()
		{
			StoreLocalState();
			for (int i = 0; i < allIKComponents.Length; i++)
			{
				disabledIKComponents[i] = false;
			}
			if (!applyIkOnRagdoll)
			{
				for (int j = 0; j < allIKComponents.Length; j++)
				{
					if (allIKComponents[j].enabled)
					{
						allIKComponents[j].enabled = false;
						disabledIKComponents[j] = true;
					}
				}
			}
			animatorUpdateMode = animator.updateMode;
			animator.updateMode = AnimatorUpdateMode.AnimatePhysics;
			animator.enabled = false;
			for (int k = 0; k < rigidbones.Length; k++)
			{
				rigidbones[k].WakeUp(applyVelocity, applyAngularVelocity);
			}
			for (int l = 0; l < fixTransforms.Length; l++)
			{
				fixTransforms[l] = allIKComponents[l].fixTransforms;
				allIKComponents[l].fixTransforms = false;
			}
			ragdollWeight = 1f;
			ragdollWeightV = 0f;
			enableRagdollFlag = false;
		}

		private void RecordVelocities()
		{
			Rigidbone[] array = rigidbones;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].RecordVelocity();
			}
		}

		private void StoreLocalState()
		{
			Child[] array = children;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].StoreLocalState();
			}
		}

		private void FixTransforms(float weight)
		{
			Child[] array = children;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].FixTransform(weight);
			}
		}

		private void OnDestroy()
		{
			if (ik != null)
			{
				IKSolver iKSolver = ik.GetIKSolver();
				iKSolver.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Remove(iKSolver.OnPostUpdate, new IKSolver.UpdateDelegate(AfterLastIK));
			}
		}
	}
	public abstract class RotationLimit : MonoBehaviour
	{
		public Vector3 axis = Vector3.forward;

		[HideInInspector]
		public Quaternion defaultLocalRotation;

		private bool initiated;

		private bool applicationQuit;

		private bool defaultLocalRotationSet;

		public Vector3 secondaryAxis => new Vector3(axis.y, axis.z, axis.x);

		public Vector3 crossAxis => Vector3.Cross(axis, secondaryAxis);

		public void SetDefaultLocalRotation()
		{
			defaultLocalRotation = base.transform.localRotation;
			defaultLocalRotationSet = true;
		}

		public Quaternion GetLimitedLocalRotation(Quaternion localRotation, out bool changed)
		{
			if (!initiated)
			{
				Awake();
			}
			Quaternion quaternion = Quaternion.Inverse(defaultLocalRotation) * localRotation;
			Quaternion quaternion2 = LimitRotation(quaternion);
			changed = quaternion2 != quaternion;
			if (!changed)
			{
				return localRotation;
			}
			return defaultLocalRotation * quaternion2;
		}

		public bool Apply()
		{
			bool changed = false;
			base.transform.localRotation = GetLimitedLocalRotation(base.transform.localRotation, out changed);
			return changed;
		}

		public void Disable()
		{
			if (initiated)
			{
				base.enabled = false;
				return;
			}
			Awake();
			base.enabled = false;
		}

		protected abstract Quaternion LimitRotation(Quaternion rotation);

		private void Awake()
		{
			if (!defaultLocalRotationSet)
			{
				SetDefaultLocalRotation();
			}
			if (axis == Vector3.zero)
			{
				UnityEngine.Debug.LogError("Axis is Vector3.zero.");
			}
			initiated = true;
		}

		private void LateUpdate()
		{
			Apply();
		}

		public void LogWarning(string message)
		{
			Warning.Log(message, base.transform);
		}

		protected static Quaternion Limit1DOF(Quaternion rotation, Vector3 axis)
		{
			return Quaternion.FromToRotation(rotation * axis, axis) * rotation;
		}

		protected static Quaternion LimitTwist(Quaternion rotation, Vector3 axis, Vector3 orthoAxis, float twistLimit)
		{
			twistLimit = Mathf.Clamp(twistLimit, 0f, 180f);
			if (twistLimit >= 180f)
			{
				return rotation;
			}
			Vector3 normal = rotation * axis;
			Vector3 tangent = orthoAxis;
			Vector3.OrthoNormalize(ref normal, ref tangent);
			Vector3 tangent2 = rotation * orthoAxis;
			Vector3.OrthoNormalize(ref normal, ref tangent2);
			Quaternion quaternion = Quaternion.FromToRotation(tangent2, tangent) * rotation;
			if (twistLimit <= 0f)
			{
				return quaternion;
			}
			return Quaternion.RotateTowards(quaternion, rotation, twistLimit);
		}

		protected static float GetOrthogonalAngle(Vector3 v1, Vector3 v2, Vector3 normal)
		{
			Vector3.OrthoNormalize(ref normal, ref v1);
			Vector3.OrthoNormalize(ref normal, ref v2);
			return Vector3.Angle(v1, v2);
		}
	}
	[HelpURL("http://www.root-motion.com/finalikdox/html/page12.html")]
	[AddComponentMenu("Scripts/RootMotion.FinalIK/Rotation Limits/Rotation Limit Angle")]
	public class RotationLimitAngle : RotationLimit
	{
		[Range(0f, 180f)]
		public float limit = 45f;

		[Range(0f, 180f)]
		public float twistLimit = 180f;

		[ContextMenu("User Manual")]
		private void OpenUserManual()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/page12.html");
		}

		[ContextMenu("Scrpt Reference")]
		private void OpenScriptReference()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/class_root_motion_1_1_final_i_k_1_1_rotation_limit_angle.html");
		}

		[ContextMenu("Support Group")]
		private void SupportGroup()
		{
			Application.OpenURL("https://groups.google.com/forum/#!forum/final-ik");
		}

		[ContextMenu("Asset Store Thread")]
		private void ASThread()
		{
			Application.OpenURL("http://forum.unity3d.com/threads/final-ik-full-body-ik-aim-look-at-fabrik-ccd-ik-1-0-released.222685/");
		}

		protected override Quaternion LimitRotation(Quaternion rotation)
		{
			return RotationLimit.LimitTwist(LimitSwing(rotation), axis, base.secondaryAxis, twistLimit);
		}

		private Quaternion LimitSwing(Quaternion rotation)
		{
			if (axis == Vector3.zero)
			{
				return rotation;
			}
			if (rotation == Quaternion.identity)
			{
				return rotation;
			}
			if (limit >= 180f)
			{
				return rotation;
			}
			Vector3 vector = rotation * axis;
			Quaternion to = Quaternion.FromToRotation(axis, vector);
			Quaternion quaternion = Quaternion.RotateTowards(Quaternion.identity, to, limit);
			return Quaternion.FromToRotation(vector, quaternion * axis) * rotation;
		}
	}
	[HelpURL("http://www.root-motion.com/finalikdox/html/page12.html")]
	[AddComponentMenu("Scripts/RootMotion.FinalIK/Rotation Limits/Rotation Limit Hinge")]
	public class RotationLimitHinge : RotationLimit
	{
		public bool useLimits = true;

		public float min = -45f;

		public float max = 90f;

		[HideInInspector]
		public float zeroAxisDisplayOffset;

		private Quaternion lastRotation = Quaternion.identity;

		private float lastAngle;

		[ContextMenu("User Manual")]
		private void OpenUserManual()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/page12.html");
		}

		[ContextMenu("Scrpt Reference")]
		private void OpenScriptReference()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/class_root_motion_1_1_final_i_k_1_1_rotation_limit_hinge.html");
		}

		[ContextMenu("Support Group")]
		private void SupportGroup()
		{
			Application.OpenURL("https://groups.google.com/forum/#!forum/final-ik");
		}

		[ContextMenu("Asset Store Thread")]
		private void ASThread()
		{
			Application.OpenURL("http://forum.unity3d.com/threads/final-ik-full-body-ik-aim-look-at-fabrik-ccd-ik-1-0-released.222685/");
		}

		protected override Quaternion LimitRotation(Quaternion rotation)
		{
			lastRotation = LimitHinge(rotation);
			return lastRotation;
		}

		private Quaternion LimitHinge(Quaternion rotation)
		{
			if (min == 0f && max == 0f && useLimits)
			{
				return Quaternion.AngleAxis(0f, axis);
			}
			Quaternion quaternion = RotationLimit.Limit1DOF(rotation, axis);
			if (!useLimits)
			{
				return quaternion;
			}
			Quaternion quaternion2 = quaternion * Quaternion.Inverse(lastRotation);
			float num = Quaternion.Angle(Quaternion.identity, quaternion2);
			Vector3 vector = new Vector3(axis.z, axis.x, axis.y);
			Vector3 rhs = Vector3.Cross(vector, axis);
			if (Vector3.Dot(quaternion2 * vector, rhs) > 0f)
			{
				num = 0f - num;
			}
			lastAngle = Mathf.Clamp(lastAngle + num, min, max);
			return Quaternion.AngleAxis(lastAngle, axis);
		}
	}
	[HelpURL("http://www.root-motion.com/finalikdox/html/page12.html")]
	[AddComponentMenu("Scripts/RootMotion.FinalIK/Rotation Limits/Rotation Limit Polygonal")]
	public class RotationLimitPolygonal : RotationLimit
	{
		[Serializable]
		public class ReachCone
		{
			public Vector3[] tetrahedron;

			public float volume;

			public Vector3 S;

			public Vector3 B;

			public Vector3 o => tetrahedron[0];

			public Vector3 a => tetrahedron[1];

			public Vector3 b => tetrahedron[2];

			public Vector3 c => tetrahedron[3];

			public bool isValid => volume > 0f;

			public ReachCone(Vector3 _o, Vector3 _a, Vector3 _b, Vector3 _c)
			{
				tetrahedron = new Vector3[4];
				tetrahedron[0] = _o;
				tetrahedron[1] = _a;
				tetrahedron[2] = _b;
				tetrahedron[3] = _c;
				volume = 0f;
				S = Vector3.zero;
				B = Vector3.zero;
			}

			public void Calculate()
			{
				Vector3 lhs = Vector3.Cross(a, b);
				volume = Vector3.Dot(lhs, c) / 6f;
				S = Vector3.Cross(a, b).normalized;
				B = Vector3.Cross(b, c).normalized;
			}
		}

		[Serializable]
		public class LimitPoint
		{
			public Vector3 point;

			public float tangentWeight;

			public LimitPoint()
			{
				point = Vector3.forward;
				tangentWeight = 1f;
			}
		}

		[Range(0f, 180f)]
		public float twistLimit = 180f;

		[Range(0f, 3f)]
		public int smoothIterations;

		[SerializeField]
		[HideInInspector]
		public LimitPoint[] points;

		[SerializeField]
		[HideInInspector]
		public Vector3[] P;

		[SerializeField]
		[HideInInspector]
		public ReachCone[] reachCones = new ReachCone[0];

		[ContextMenu("User Manual")]
		private void OpenUserManual()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/page12.html");
		}

		[ContextMenu("Scrpt Reference")]
		private void OpenScriptReference()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/class_root_motion_1_1_final_i_k_1_1_rotation_limit_polygonal.html");
		}

		[ContextMenu("Support Group")]
		private void SupportGroup()
		{
			Application.OpenURL("https://groups.google.com/forum/#!forum/final-ik");
		}

		[ContextMenu("Asset Store Thread")]
		private void ASThread()
		{
			Application.OpenURL("http://forum.unity3d.com/threads/final-ik-full-body-ik-aim-look-at-fabrik-ccd-ik-1-0-released.222685/");
		}

		public void SetLimitPoints(LimitPoint[] points)
		{
			if (points.Length < 3)
			{
				LogWarning("The polygon must have at least 3 Limit Points.");
				return;
			}
			this.points = points;
			BuildReachCones();
		}

		protected override Quaternion LimitRotation(Quaternion rotation)
		{
			if (reachCones.Length == 0)
			{
				Start();
			}
			return RotationLimit.LimitTwist(LimitSwing(rotation), axis, base.secondaryAxis, twistLimit);
		}

		private void Start()
		{
			if (points.Length < 3)
			{
				ResetToDefault();
			}
			for (int i = 0; i < reachCones.Length; i++)
			{
				if (!reachCones[i].isValid)
				{
					if (smoothIterations <= 0)
					{
						int num = 0;
						num = ((i < reachCones.Length - 1) ? (i + 1) : 0);
						LogWarning("Reach Cone {point " + i + ", point " + num + ", Origin} has negative volume. Make sure Axis vector is in the reachable area and the polygon is convex.");
					}
					else
					{
						LogWarning("One of the Reach Cones in the polygon has negative volume. Make sure Axis vector is in the reachable area and the polygon is convex.");
					}
				}
			}
			axis = axis.normalized;
		}

		public void ResetToDefault()
		{
			points = new LimitPoint[4];
			for (int i = 0; i < points.Length; i++)
			{
				points[i] = new LimitPoint();
			}
			Quaternion quaternion = Quaternion.AngleAxis(45f, Vector3.right);
			Quaternion quaternion2 = Quaternion.AngleAxis(45f, Vector3.up);
			points[0].point = quaternion * quaternion2 * axis;
			points[1].point = Quaternion.Inverse(quaternion) * quaternion2 * axis;
			points[2].point = Quaternion.Inverse(quaternion) * Quaternion.Inverse(quaternion2) * axis;
			points[3].point = quaternion * Quaternion.Inverse(quaternion2) * axis;
			BuildReachCones();
		}

		public void BuildReachCones()
		{
			smoothIterations = Mathf.Clamp(smoothIterations, 0, 3);
			P = new Vector3[points.Length];
			for (int i = 0; i < points.Length; i++)
			{
				P[i] = points[i].point.normalized;
			}
			for (int j = 0; j < smoothIterations; j++)
			{
				P = SmoothPoints();
			}
			reachCones = new ReachCone[P.Length];
			for (int k = 0; k < reachCones.Length - 1; k++)
			{
				reachCones[k] = new ReachCone(Vector3.zero, axis.normalized, P[k], P[k + 1]);
			}
			reachCones[P.Length - 1] = new ReachCone(Vector3.zero, axis.normalized, P[P.Length - 1], P[0]);
			for (int l = 0; l < reachCones.Length; l++)
			{
				reachCones[l].Calculate();
			}
		}

		private Vector3[] SmoothPoints()
		{
			Vector3[] array = new Vector3[P.Length * 2];
			float scalar = GetScalar(P.Length);
			for (int i = 0; i < array.Length; i += 2)
			{
				array[i] = PointToTangentPlane(P[i / 2], 1f);
			}
			for (int j = 1; j < array.Length; j += 2)
			{
				Vector3 vector = Vector3.zero;
				Vector3 zero = Vector3.zero;
				Vector3 vector2 = Vector3.zero;
				if (j > 1 && j < array.Length - 2)
				{
					vector = array[j - 2];
					vector2 = array[j + 1];
				}
				else if (j == 1)
				{
					vector = array[array.Length - 2];
					vector2 = array[j + 1];
				}
				else if (j == array.Length - 1)
				{
					vector = array[j - 2];
					vector2 = array[0];
				}
				zero = ((j >= array.Length - 1) ? array[0] : array[j + 1]);
				int num = array.Length / points.Length;
				array[j] = 0.5f * (array[j - 1] + zero) + scalar * points[j / num].tangentWeight * (zero - vector) + scalar * points[j / num].tangentWeight * (array[j - 1] - vector2);
			}
			for (int k = 0; k < array.Length; k++)
			{
				array[k] = TangentPointToSphere(array[k], 1f);
			}
			return array;
		}

		private float GetScalar(int k)
		{
			if (k <= 3)
			{
				return 0.1667f;
			}
			return k switch
			{
				4 => 0.1036f, 
				5 => 0.085f, 
				6 => 0.0773f, 
				7 => 0.07f, 
				_ => 0.0625f, 
			};
		}

		private Vector3 PointToTangentPlane(Vector3 p, float r)
		{
			float num = Vector3.Dot(axis, p);
			float num2 = 2f * r * r / (r * r + num);
			return num2 * p + (1f - num2) * -axis;
		}

		private Vector3 TangentPointToSphere(Vector3 q, float r)
		{
			float num = Vector3.Dot(q - axis, q - axis);
			float num2 = 4f * r * r / (4f * r * r + num);
			return num2 * q + (1f - num2) * -axis;
		}

		private Quaternion LimitSwing(Quaternion rotation)
		{
			if (rotation == Quaternion.identity)
			{
				return rotation;
			}
			Vector3 vector = rotation * axis;
			int reachCone = GetReachCone(vector);
			if (reachCone == -1)
			{
				if (!Warning.logged)
				{
					LogWarning("RotationLimitPolygonal reach cones are invalid.");
				}
				return rotation;
			}
			if (Vector3.Dot(reachCones[reachCone].B, vector) > 0f)
			{
				return rotation;
			}
			Vector3 rhs = Vector3.Cross(axis, vector);
			vector = Vector3.Cross(-reachCones[reachCone].B, rhs);
			return Quaternion.FromToRotation(rotation * axis, vector) * rotation;
		}

		private int GetReachCone(Vector3 L)
		{
			float num = Vector3.Dot(reachCones[0].S, L);
			for (int i = 0; i < reachCones.Length; i++)
			{
				float num2 = num;
				num = ((i >= reachCones.Length - 1) ? Vector3.Dot(reachCones[0].S, L) : Vector3.Dot(reachCones[i + 1].S, L));
				if (num2 >= 0f && num < 0f)
				{
					return i;
				}
			}
			return -1;
		}
	}
	[HelpURL("http://www.root-motion.com/finalikdox/html/page12.html")]
	[AddComponentMenu("Scripts/RootMotion.FinalIK/Rotation Limits/Rotation Limit Spline")]
	public class RotationLimitSpline : RotationLimit
	{
		[Range(0f, 180f)]
		public float twistLimit = 180f;

		[SerializeField]
		[HideInInspector]
		public AnimationCurve spline;

		[ContextMenu("User Manual")]
		private void OpenUserManual()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/page12.html");
		}

		[ContextMenu("Scrpt Reference")]
		private void OpenScriptReference()
		{
			Application.OpenURL("http://www.root-motion.com/finalikdox/html/class_root_motion_1_1_final_i_k_1_1_rotation_limit_spline.html");
		}

		[ContextMenu("Support Group")]
		private void SupportGroup()
		{
			Application.OpenURL("https://groups.google.com/forum/#!forum/final-ik");
		}

		[ContextMenu("Asset Store Thread")]
		private void ASThread()
		{
			Application.OpenURL("http://forum.unity3d.com/threads/final-ik-full-body-ik-aim-look-at-fabrik-ccd-ik-1-0-released.222685/");
		}

		public void SetSpline(Keyframe[] keyframes)
		{
			spline.keys = keyframes;
		}

		protected override Quaternion LimitRotation(Quaternion rotation)
		{
			return RotationLimit.LimitTwist(LimitSwing(rotation), axis, base.secondaryAxis, twistLimit);
		}

		public Quaternion LimitSwing(Quaternion rotation)
		{
			if (axis == Vector3.zero)
			{
				return rotation;
			}
			if (rotation == Quaternion.identity)
			{
				return rotation;
			}
			Vector3 vector = rotation * axis;
			float num = RotationLimit.GetOrthogonalAngle(vector, base.secondaryAxis, axis);
			if (Vector3.Dot(vector, base.crossAxis) < 0f)
			{
				num = 180f + (180f - num);
			}
			float maxDegreesDelta = spline.Evaluate(num);
			Quaternion to = Quaternion.FromToRotation(axis, vector);
			Quaternion quaternion = Quaternion.RotateTowards(Quaternion.identity, to, maxDegreesDelta);
			return Quaternion.FromToRotation(vector, quaternion * axis) * rotation;
		}
	}
	public class AimPoser : MonoBehaviour
	{
		[Serializable]
		public class Pose
		{
			public bool visualize = true;

			public string name;

			public Vector3 direction;

			public float yaw = 75f;

			public float pitch = 45f;

			private float angleBuffer;

			public bool IsInDirection(Vector3 d)
			{
				if (direction == Vector3.zero)
				{
					return false;
				}
				if (yaw <= 0f || pitch <= 0f)
				{
					return false;
				}
				if (yaw < 180f)
				{
					Vector3 vector = new Vector3(direction.x, 0f, direction.z);
					if (vector == Vector3.zero)
					{
						vector = Vector3.forward;
					}
					if (Vector3.Angle(new Vector3(d.x, 0f, d.z), vector) > yaw + angleBuffer)
					{
						return false;
					}
				}
				if (pitch >= 180f)
				{
					return true;
				}
				float num = Vector3.Angle(Vector3.up, direction);
				return Mathf.Abs(Vector3.Angle(Vector3.up, d) - num) < pitch + angleBuffer;
			}

			public void SetAngleBuffer(float value)
			{
				angleBuffer = value;
			}
		}

		public float angleBuffer = 5f;

		public Pose[] poses = new Pose[0];

		public Pose GetPose(Vector3 localDirection)
		{
			if (poses.Length == 0)
			{
				return null;
			}
			for (int i = 0; i < poses.Length - 1; i++)
			{
				if (poses[i].IsInDirection(localDirection))
				{
					return poses[i];
				}
			}
			return poses[poses.Length - 1];
		}

		public void SetPoseActive(Pose pose)
		{
			for (int i = 0; i < poses.Length; i++)
			{
				poses[i].SetAngleBuffer((poses[i] == pose) ? angleBuffer : 0f);
			}
		}
	}
	public class Amplifier : OffsetModifier
	{
		[Serializable]
		public class Body
		{
			[Serializable]
			public class EffectorLink
			{
				[Tooltip("Type of the FBBIK effector to use")]
				public FullBodyBipedEffector effector;

				[Tooltip("Weight of using this effector")]
				public float weight;
			}

			[Tooltip("The Transform that's motion we are reading.")]
			public Transform transform;

			[Tooltip("Amplify the 'transform's' position relative to this Transform.")]
			public Transform relativeTo;

			[Tooltip("Linking the body to effectors. One Body can be used to offset more than one effector.")]
			public EffectorLink[] effectorLinks;

			[Tooltip("Amplification magnitude along the up axis of the character.")]
			public float verticalWeight = 1f;

			[Tooltip("Amplification magnitude along the horizontal axes of the character.")]
			public float horizontalWeight = 1f;

			[Tooltip("Speed of the amplifier. 0 means instant.")]
			public float speed = 3f;

			private Vector3 lastRelativePos;

			private Vector3 smoothDelta;

			private bool firstUpdate;

			public void Update(IKSolverFullBodyBiped solver, float w, float deltaTime)
			{
				if (!(transform == null) && !(relativeTo == null))
				{
					Vector3 vector = relativeTo.InverseTransformDirection(transform.position - relativeTo.position);
					if (firstUpdate)
					{
						lastRelativePos = vector;
						firstUpdate = false;
					}
					Vector3 vector2 = (vector - lastRelativePos) / deltaTime;
					smoothDelta = ((speed <= 0f) ? vector2 : Vector3.Lerp(smoothDelta, vector2, deltaTime * speed));
					Vector3 v = relativeTo.TransformDirection(smoothDelta);
					Vector3 vector3 = V3Tools.ExtractVertical(v, solver.GetRoot().up, verticalWeight) + V3Tools.ExtractHorizontal(v, solver.GetRoot().up, horizontalWeight);
					for (int i = 0; i < effectorLinks.Length; i++)
					{
						solver.GetEffector(effectorLinks[i].effector).positionOffset += vector3 * w * effectorLinks[i].weight;
					}
					lastRelativePos = vector;
				}
			}

			private static Vector3 Multiply(Vector3 v1, Vector3 v2)
			{
				v1.x *= v2.x;
				v1.y *= v2.y;
				v1.z *= v2.z;
				return v1;
			}
		}

		[Tooltip("The amplified bodies.")]
		public Body[] bodies;

		protected override void OnModifyOffset()
		{
			if (!ik.fixTransforms)
			{
				if (!Warning.logged)
				{
					Warning.Log("Amplifier needs the Fix Transforms option of the FBBIK to be set to true. Otherwise it might amplify to infinity, should the animator of the character stop because of culling.", base.transform);
				}
				return;
			}
			Body[] array = bodies;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].Update(ik.solver, weight, base.deltaTime);
			}
		}
	}
	public class BodyTilt : OffsetModifier
	{
		[Tooltip("Speed of tilting")]
		public float tiltSpeed = 6f;

		[Tooltip("Sensitivity of tilting")]
		public float tiltSensitivity = 0.07f;

		[Tooltip("The OffsetPose components")]
		public OffsetPose poseLeft;

		[Tooltip("The OffsetPose components")]
		public OffsetPose poseRight;

		private float tiltAngle;

		private Vector3 lastForward;

		protected override void Start()
		{
			base.Start();
			lastForward = base.transform.forward;
		}

		protected override void OnModifyOffset()
		{
			Quaternion quaternion = Quaternion.FromToRotation(lastForward, base.transform.forward);
			float angle = 0f;
			Vector3 axis = Vector3.zero;
			quaternion.ToAngleAxis(out angle, out axis);
			if (axis.y > 0f)
			{
				angle = 0f - angle;
			}
			angle *= tiltSensitivity * 0.01f;
			angle /= base.deltaTime;
			angle = Mathf.Clamp(angle, -1f, 1f);
			tiltAngle = Mathf.Lerp(tiltAngle, angle, base.deltaTime * tiltSpeed);
			float num = Mathf.Abs(tiltAngle) / 1f;
			if (tiltAngle < 0f)
			{
				poseRight.Apply(ik.solver, num);
			}
			else
			{
				poseLeft.Apply(ik.solver, num);
			}
			lastForward = base.transform.forward;
		}
	}
	public class HitReaction : OffsetModifier
	{
		[Serializable]
		public abstract class HitPoint
		{
			[Tooltip("Just for visual clarity, not used at all")]
			public string name;

			[Tooltip("Linking this hit point to a collider")]
			public Collider collider;

			[Tooltip("Only used if this hit point gets hit when already processing another hit")]
			[SerializeField]
			private float crossFadeTime = 0.1f;

			private float length;

			private float crossFadeSpeed;

			private float lastTime;

			public bool inProgress => timer < length;

			protected float crossFader { get; private set; }

			protected float timer { get; private set; }

			protected Vector3 force { get; private set; }

			protected Vector3 point { get; private set; }

			public void Hit(Vector3 force, Vector3 point)
			{
				if (length == 0f)
				{
					length = GetLength();
				}
				if (length <= 0f)
				{
					UnityEngine.Debug.LogError("Hit Point WeightCurve length is zero.");
					return;
				}
				if (timer < 1f)
				{
					crossFader = 0f;
				}
				crossFadeSpeed = ((crossFadeTime > 0f) ? (1f / crossFadeTime) : 0f);
				CrossFadeStart();
				timer = 0f;
				this.force = force;
				this.point = point;
			}

			public void Apply(IKSolverFullBodyBiped solver, float weight)
			{
				float num = Time.time - lastTime;
				lastTime = Time.time;
				if (!(timer >= length))
				{
					timer = Mathf.Clamp(timer + num, 0f, length);
					if (crossFadeSpeed > 0f)
					{
						crossFader = Mathf.Clamp(crossFader + num * crossFadeSpeed, 0f, 1f);
					}
					else
					{
						crossFader = 1f;
					}
					OnApply(solver, weight);
				}
			}

			protected abstract float GetLength();

			protected abstract void CrossFadeStart();

			protected abstract void OnApply(IKSolverFullBodyBiped solver, float weight);
		}

		[Serializable]
		public class HitPointEffector : HitPoint
		{
			[Serializable]
			public class EffectorLink
			{
				[Tooltip("The FBBIK effector type")]
				public FullBodyBipedEffector effector;

				[Tooltip("The weight of this effector (could also be negative)")]
				public float weight;

				private Vector3 lastValue;

				private Vector3 current;

				public void Apply(IKSolverFullBodyBiped solver, Vector3 offset, float crossFader)
				{
					current = Vector3.Lerp(lastValue, offset * weight, crossFader);
					solver.GetEffector(effector).positionOffset += current;
				}

				public void CrossFadeStart()
				{
					lastValue = current;
				}
			}

			[Tooltip("Offset magnitude in the direction of the hit force")]
			public AnimationCurve offsetInForceDirection;

			[Tooltip("Offset magnitude in the direction of character.up")]
			public AnimationCurve offsetInUpDirection;

			[Tooltip("Linking this offset to the FBBIK effectors")]
			public EffectorLink[] effectorLinks;

			protected override float GetLength()
			{
				float num = ((offsetInForceDirection.keys.Length != 0) ? offsetInForceDirection.keys[offsetInForceDirection.length - 1].time : 0f);
				float min = ((offsetInUpDirection.keys.Length != 0) ? offsetInUpDirection.keys[offsetInUpDirection.length - 1].time : 0f);
				return Mathf.Clamp(num, min, num);
			}

			protected override void CrossFadeStart()
			{
				EffectorLink[] array = effectorLinks;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].CrossFadeStart();
				}
			}

			protected override void OnApply(IKSolverFullBodyBiped solver, float weight)
			{
				Vector3 vector = solver.GetRoot().up * base.force.magnitude;
				Vector3 offset = offsetInForceDirection.Evaluate(base.timer) * base.force + offsetInUpDirection.Evaluate(base.timer) * vector;
				offset *= weight;
				EffectorLink[] array = effectorLinks;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].Apply(solver, offset, base.crossFader);
				}
			}
		}

		[Serializable]
		public class HitPointBone : HitPoint
		{
			[Serializable]
			public class BoneLink
			{
				[Tooltip("Reference to the bone that this hit point rotates")]
				public Transform bone;

				[Tooltip("Weight of rotating the bone")]
				[Range(0f, 1f)]
				public float weight;

				private Quaternion lastValue = Quaternion.identity;

				private Quaternion current = Quaternion.identity;

				public void Apply(IKSolverFullBodyBiped solver, Quaternion offset, float crossFader)
				{
					current = Quaternion.Lerp(lastValue, Quaternion.Lerp(Quaternion.identity, offset, weight), crossFader);
					bone.rotation = current * bone.rotation;
				}

				public void CrossFadeStart()
				{
					lastValue = current;
				}
			}

			[Tooltip("The angle to rotate the bone around it's rigidbody's world center of mass")]
			public AnimationCurve aroundCenterOfMass;

			[Tooltip("Linking this hit point to bone(s)")]
			public BoneLink[] boneLinks;

			private Rigidbody rigidbody;

			protected override float GetLength()
			{
				if (aroundCenterOfMass.keys.Length == 0)
				{
					return 0f;
				}
				return aroundCenterOfMass.keys[aroundCenterOfMass.length - 1].time;
			}

			protected override void CrossFadeStart()
			{
				BoneLink[] array = boneLinks;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].CrossFadeStart();
				}
			}

			protected override void OnApply(IKSolverFullBodyBiped solver, float weight)
			{
				if (rigidbody == null)
				{
					rigidbody = collider.GetComponent<Rigidbody>();
				}
				if (rigidbody != null)
				{
					Vector3 axis = Vector3.Cross(base.force, base.point - rigidbody.worldCenterOfMass);
					Quaternion offset = Quaternion.AngleAxis(aroundCenterOfMass.Evaluate(base.timer) * weight, axis);
					BoneLink[] array = boneLinks;
					for (int i = 0; i < array.Length; i++)
					{
						array[i].Apply(solver, offset, base.crossFader);
					}
				}
			}
		}

		[Tooltip("Hit points for the FBBIK effectors")]
		public HitPointEffector[] effectorHitPoints;

		[Tooltip(" Hit points for bones without an effector, such as the head")]
		public HitPointBone[] boneHitPoints;

		public bool inProgress
		{
			get
			{
				HitPointEffector[] array = effectorHitPoints;
				for (int i = 0; i < array.Length; i++)
				{
					if (array[i].inProgress)
					{
						return true;
					}
				}
				HitPointBone[] array2 = boneHitPoints;
				for (int i = 0; i < array2.Length; i++)
				{
					if (array2[i].inProgress)
					{
						return true;
					}
				}
				return false;
			}
		}

		protected override void OnModifyOffset()
		{
			HitPointEffector[] array = effectorHitPoints;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].Apply(ik.solver, weight);
			}
			HitPointBone[] array2 = boneHitPoints;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i].Apply(ik.solver, weight);
			}
		}

		public void Hit(Collider collider, Vector3 force, Vector3 point)
		{
			if (ik == null)
			{
				UnityEngine.Debug.LogError("No IK assigned in HitReaction");
				return;
			}
			HitPointEffector[] array = effectorHitPoints;
			foreach (HitPointEffector hitPointEffector in array)
			{
				if (hitPointEffector.collider == collider)
				{
					hitPointEffector.Hit(force, point);
				}
			}
			HitPointBone[] array2 = boneHitPoints;
			foreach (HitPointBone hitPointBone in array2)
			{
				if (hitPointBone.collider == collider)
				{
					hitPointBone.Hit(force, point);
				}
			}
		}
	}
	public class HitReactionVRIK : OffsetModifierVRIK
	{
		[Serializable]
		public abstract class Offset
		{
			[Tooltip("Just for visual clarity, not used at all")]
			public string name;

			[Tooltip("Linking this hit point to a collider")]
			public Collider collider;

			[Tooltip("Only used if this hit point gets hit when already processing another hit")]
			[SerializeField]
			private float crossFadeTime = 0.1f;

			private float length;

			private float crossFadeSpeed;

			private float lastTime;

			protected float crossFader { get; private set; }

			protected float timer { get; private set; }

			protected Vector3 force { get; private set; }

			protected Vector3 point { get; private set; }

			public void Hit(Vector3 force, AnimationCurve[] curves, Vector3 point)
			{
				if (length == 0f)
				{
					length = GetLength(curves);
				}
				if (length <= 0f)
				{
					UnityEngine.Debug.LogError("Hit Point WeightCurve length is zero.");
					return;
				}
				if (timer < 1f)
				{
					crossFader = 0f;
				}
				crossFadeSpeed = ((crossFadeTime > 0f) ? (1f / crossFadeTime) : 0f);
				CrossFadeStart();
				timer = 0f;
				this.force = force;
				this.point = point;
			}

			public void Apply(VRIK ik, AnimationCurve[] curves, float weight)
			{
				float num = Time.time - lastTime;
				lastTime = Time.time;
				if (!(timer >= length))
				{
					timer = Mathf.Clamp(timer + num, 0f, length);
					if (crossFadeSpeed > 0f)
					{
						crossFader = Mathf.Clamp(crossFader + num * crossFadeSpeed, 0f, 1f);
					}
					else
					{
						crossFader = 1f;
					}
					OnApply(ik, curves, weight);
				}
			}

			protected abstract float GetLength(AnimationCurve[] curves);

			protected abstract void CrossFadeStart();

			protected abstract void OnApply(VRIK ik, AnimationCurve[] curves, float weight);
		}

		[Serializable]
		public class PositionOffset : Offset
		{
			[Serializable]
			public class PositionOffsetLink
			{
				[Tooltip("The FBBIK effector type")]
				public IKSolverVR.PositionOffset positionOffset;

				[Tooltip("The weight of this effector (could also be negative)")]
				public float weight;

				private Vector3 lastValue;

				private Vector3 current;

				public void Apply(VRIK ik, Vector3 offset, float crossFader)
				{
					current = Vector3.Lerp(lastValue, offset * weight, crossFader);
					ik.solver.AddPositionOffset(positionOffset, current);
				}

				public void CrossFadeStart()
				{
					lastValue = current;
				}
			}

			[Tooltip("Offset magnitude in the direction of the hit force")]
			public int forceDirCurveIndex;

			[Tooltip("Offset magnitude in the direction of character.up")]
			public int upDirCurveIndex = 1;

			[Tooltip("Linking this offset to the VRIK position offsets")]
			public PositionOffsetLink[] offsetLinks;

			protected override float GetLength(AnimationCurve[] curves)
			{
				float num = ((curves[forceDirCurveIndex].keys.Length != 0) ? curves[forceDirCurveIndex].keys[curves[forceDirCurveIndex].length - 1].time : 0f);
				float min = ((curves[upDirCurveIndex].keys.Length != 0) ? curves[upDirCurveIndex].keys[curves[upDirCurveIndex].length - 1].time : 0f);
				return Mathf.Clamp(num, min, num);
			}

			protected override void CrossFadeStart()
			{
				PositionOffsetLink[] array = offsetLinks;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].CrossFadeStart();
				}
			}

			protected override void OnApply(VRIK ik, AnimationCurve[] curves, float weight)
			{
				Vector3 vector = ik.transform.up * base.force.magnitude;
				Vector3 offset = curves[forceDirCurveIndex].Evaluate(base.timer) * base.force + curves[upDirCurveIndex].Evaluate(base.timer) * vector;
				offset *= weight;
				PositionOffsetLink[] array = offsetLinks;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].Apply(ik, offset, base.crossFader);
				}
			}
		}

		[Serializable]
		public class RotationOffset : Offset
		{
			[Serializable]
			public class RotationOffsetLink
			{
				[Tooltip("Reference to the bone that this hit point rotates")]
				public IKSolverVR.RotationOffset rotationOffset;

				[Tooltip("Weight of rotating the bone")]
				[Range(0f, 1f)]
				public float weight;

				private Quaternion lastValue = Quaternion.identity;

				private Quaternion current = Quaternion.identity;

				public void Apply(VRIK ik, Quaternion offset, float crossFader)
				{
					current = Quaternion.Lerp(lastValue, Quaternion.Lerp(Quaternion.identity, offset, weight), crossFader);
					ik.solver.AddRotationOffset(rotationOffset, current);
				}

				public void CrossFadeStart()
				{
					lastValue = current;
				}
			}

			[Tooltip("The angle to rotate the bone around it's rigidbody's world center of mass")]
			public int curveIndex;

			[Tooltip("Linking this hit point to bone(s)")]
			public RotationOffsetLink[] offsetLinks;

			private Rigidbody rigidbody;

			protected override float GetLength(AnimationCurve[] curves)
			{
				if (curves[curveIndex].keys.Length == 0)
				{
					return 0f;
				}
				return curves[curveIndex].keys[curves[curveIndex].length - 1].time;
			}

			protected override void CrossFadeStart()
			{
				RotationOffsetLink[] array = offsetLinks;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].CrossFadeStart();
				}
			}

			protected override void OnApply(VRIK ik, AnimationCurve[] curves, float weight)
			{
				if (collider == null)
				{
					UnityEngine.Debug.LogError("No collider assigned for a HitPointBone in the HitReaction component.");
					return;
				}
				if (rigidbody == null)
				{
					rigidbody = collider.GetComponent<Rigidbody>();
				}
				if (rigidbody != null)
				{
					Vector3 axis = Vector3.Cross(base.force, base.point - rigidbody.worldCenterOfMass);
					Quaternion offset = Quaternion.AngleAxis(curves[curveIndex].Evaluate(base.timer) * weight, axis);
					RotationOffsetLink[] array = offsetLinks;
					for (int i = 0; i < array.Length; i++)
					{
						array[i].Apply(ik, offset, base.crossFader);
					}
				}
			}
		}

		public AnimationCurve[] offsetCurves;

		[Tooltip("Hit points for the FBBIK effectors")]
		public PositionOffset[] positionOffsets;

		[Tooltip(" Hit points for bones without an effector, such as the head")]
		public RotationOffset[] rotationOffsets;

		protected override void OnModifyOffset()
		{
			PositionOffset[] array = positionOffsets;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].Apply(ik, offsetCurves, weight);
			}
			RotationOffset[] array2 = rotationOffsets;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i].Apply(ik, offsetCurves, weight);
			}
		}

		public void Hit(Collider collider, Vector3 force, Vector3 point)
		{
			if (ik == null)
			{
				UnityEngine.Debug.LogError("No IK assigned in HitReaction");
				return;
			}
			PositionOffset[] array = positionOffsets;
			foreach (PositionOffset positionOffset in array)
			{
				if (positionOffset.collider == collider)
				{
					positionOffset.Hit(force, offsetCurves, point);
				}
			}
			RotationOffset[] array2 = rotationOffsets;
			foreach (RotationOffset rotationOffset in array2)
			{
				if (rotationOffset.collider == collider)
				{
					rotationOffset.Hit(force, offsetCurves, point);
				}
			}
		}
	}
	public class Inertia : OffsetModifier
	{
		[Serializable]
		public class Body
		{
			[Serializable]
			public class EffectorLink
			{
				[Tooltip("Type of the FBBIK effector to use")]
				public FullBodyBipedEffector effector;

				[Tooltip("Weight of using this effector")]
				public float weight;
			}

			[Tooltip("The Transform to follow, can be any bone of the character")]
			public Transform transform;

			[Tooltip("Linking the body to effectors. One Body can be used to offset more than one effector")]
			public EffectorLink[] effectorLinks;

			[Tooltip("The speed to follow the Transform")]
			public float speed = 10f;

			[Tooltip("The acceleration, smaller values means lazyer following")]
			public float acceleration = 3f;

			[Tooltip("Matching target velocity")]
			[Range(0f, 1f)]
			public float matchVelocity;

			[Tooltip("gravity applied to the Body")]
			public float gravity;

			private Vector3 delta;

			private Vector3 lazyPoint;

			private Vector3 direction;

			private Vector3 lastPosition;

			private bool firstUpdate = true;

			public void Reset()
			{
				if (!(transform == null))
				{
					lazyPoint = transform.position;
					lastPosition = transform.position;
					direction = Vector3.zero;
				}
			}

			public void Update(IKSolverFullBodyBiped solver, float weight, float deltaTime)
			{
				if (!(transform == null))
				{
					if (firstUpdate)
					{
						Reset();
						firstUpdate = false;
					}
					direction = Vector3.Lerp(direction, (transform.position - lazyPoint) / deltaTime * 0.01f, deltaTime * acceleration);
					lazyPoint += direction * deltaTime * speed;
					delta = transform.position - lastPosition;
					lazyPoint += delta * matchVelocity;
					lazyPoint.y += gravity * deltaTime;
					EffectorLink[] array = effectorLinks;
					foreach (EffectorLink effectorLink in array)
					{
						solver.GetEffector(effectorLink.effector).positionOffset += (lazyPoint - transform.position) * effectorLink.weight * weight;
					}
					lastPosition = transform.position;
				}
			}
		}

		[Tooltip("The array of Bodies")]
		public Body[] bodies;

		[Tooltip("The array of OffsetLimits")]
		public OffsetLimits[] limits;

		public void ResetBodies()
		{
			lastTime = Time.time;
			Body[] array = bodies;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].Reset();
			}
		}

		protected override void OnModifyOffset()
		{
			Body[] array = bodies;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].Update(ik.solver, weight, base.deltaTime);
			}
			ApplyLimits(limits);
		}
	}
	public abstract class OffsetModifier : MonoBehaviour
	{
		[Serializable]
		public class OffsetLimits
		{
			[Tooltip("The effector type (this is just an enum)")]
			public FullBodyBipedEffector effector;

			[Tooltip("Spring force, if zero then this is a hard limit, if not, offset can exceed the limit.")]
			public float spring;

			[Tooltip("Which axes to limit the offset on?")]
			public bool x;

			[Tooltip("Which axes to limit the offset on?")]
			public bool y;

			[Tooltip("Which axes to limit the offset on?")]
			public bool z;

			[Tooltip("The limits")]
			public float minX;

			[Tooltip("The limits")]
			public float maxX;

			[Tooltip("The limits")]
			public float minY;

			[Tooltip("The limits")]
			public float maxY;

			[Tooltip("The limits")]
			public float minZ;

			[Tooltip("The limits")]
			public float maxZ;

			public void Apply(IKEffector e, Quaternion rootRotation)
			{
				Vector3 vector = Quaternion.Inverse(rootRotation) * e.positionOffset;
				if (spring <= 0f)
				{
					if (x)
					{
						vector.x = Mathf.Clamp(vector.x, minX, maxX);
					}
					if (y)
					{
						vector.y = Mathf.Clamp(vector.y, minY, maxY);
					}
					if (z)
					{
						vector.z = Mathf.Clamp(vector.z, minZ, maxZ);
					}
				}
				else
				{
					if (x)
					{
						vector.x = SpringAxis(vector.x, minX, maxX);
					}
					if (y)
					{
						vector.y = SpringAxis(vector.y, minY, maxY);
					}
					if (z)
					{
						vector.z = SpringAxis(vector.z, minZ, maxZ);
					}
				}
				e.positionOffset = rootRotation * vector;
			}

			private float SpringAxis(float value, float min, float max)
			{
				if (value > min && value < max)
				{
					return value;
				}
				if (value < min)
				{
					return Spring(value, min, negative: true);
				}
				return Spring(value, max, negative: false);
			}

			private float Spring(float value, float limit, bool negative)
			{
				float num = value - limit;
				float num2 = num * spring;
				if (negative)
				{
					return value + Mathf.Clamp(0f - num2, 0f, 0f - num);
				}
				return value - Mathf.Clamp(num2, 0f, num);
			}
		}

		[Tooltip("The master weight")]
		public float weight = 1f;

		[Tooltip("Reference to the FBBIK component")]
		public FullBodyBipedIK ik;

		protected float lastTime;

		protected float deltaTime => Time.time - lastTime;

		protected abstract void OnModifyOffset();

		protected virtual void Start()
		{
			StartCoroutine(Initiate());
		}

		private IEnumerator Initiate()
		{
			while (ik == null)
			{
				yield return null;
			}
			IKSolverFullBodyBiped solver = ik.solver;
			solver.OnPreUpdate = (IKSolver.UpdateDelegate)Delegate.Combine(solver.OnPreUpdate, new IKSolver.UpdateDelegate(ModifyOffset));
			lastTime = Time.time;
		}

		private void ModifyOffset()
		{
			if (base.enabled && !(weight <= 0f) && !(deltaTime <= 0f) && !(ik == null))
			{
				weight = Mathf.Clamp(weight, 0f, 1f);
				OnModifyOffset();
				lastTime = Time.time;
			}
		}

		protected void ApplyLimits(OffsetLimits[] limits)
		{
			foreach (OffsetLimits offsetLimits in limits)
			{
				offsetLimits.Apply(ik.solver.GetEffector(offsetLimits.effector), base.transform.rotation);
			}
		}

		protected virtual void OnDestroy()
		{
			if (ik != null)
			{
				IKSolverFullBodyBiped solver = ik.solver;
				solver.OnPreUpdate = (IKSolver.UpdateDelegate)Delegate.Remove(solver.OnPreUpdate, new IKSolver.UpdateDelegate(ModifyOffset));
			}
		}
	}
	public abstract class OffsetModifierVRIK : MonoBehaviour
	{
		[Tooltip("The master weight")]
		public float weight = 1f;

		[Tooltip("Reference to the VRIK component")]
		public VRIK ik;

		private float lastTime;

		protected float deltaTime => Time.time - lastTime;

		protected abstract void OnModifyOffset();

		protected virtual void Start()
		{
			StartCoroutine(Initiate());
		}

		private IEnumerator Initiate()
		{
			while (ik == null)
			{
				yield return null;
			}
			IKSolverVR solver = ik.solver;
			solver.OnPreUpdate = (IKSolver.UpdateDelegate)Delegate.Combine(solver.OnPreUpdate, new IKSolver.UpdateDelegate(ModifyOffset));
			lastTime = Time.time;
		}

		private void ModifyOffset()
		{
			if (base.enabled && !(weight <= 0f) && !(deltaTime <= 0f) && !(ik == null))
			{
				weight = Mathf.Clamp(weight, 0f, 1f);
				OnModifyOffset();
				lastTime = Time.time;
			}
		}

		protected virtual void OnDestroy()
		{
			if (ik != null)
			{
				IKSolverVR solver = ik.solver;
				solver.OnPreUpdate = (IKSolver.UpdateDelegate)Delegate.Remove(solver.OnPreUpdate, new IKSolver.UpdateDelegate(ModifyOffset));
			}
		}
	}
	public class OffsetPose : MonoBehaviour
	{
		[Serializable]
		public class EffectorLink
		{
			public FullBodyBipedEffector effector;

			public Vector3 offset;

			public Vector3 pin;

			public Vector3 pinWeight;

			public void Apply(IKSolverFullBodyBiped solver, float weight, Quaternion rotation)
			{
				solver.GetEffector(effector).positionOffset += rotation * offset * weight;
				Vector3 vector = solver.GetRoot().position + rotation * pin - solver.GetEffector(effector).bone.position;
				Vector3 vector2 = pinWeight * Mathf.Abs(weight);
				solver.GetEffector(effector).positionOffset = new Vector3(Mathf.Lerp(solver.GetEffector(effector).positionOffset.x, vector.x, vector2.x), Mathf.Lerp(solver.GetEffector(effector).positionOffset.y, vector.y, vector2.y), Mathf.Lerp(solver.GetEffector(effector).positionOffset.z, vector.z, vector2.z));
			}
		}

		public EffectorLink[] effectorLinks = new EffectorLink[0];

		public void Apply(IKSolverFullBodyBiped solver, float weight)
		{
			for (int i = 0; i < effectorLinks.Length; i++)
			{
				effectorLinks[i].Apply(solver, weight, solver.GetRoot().rotation);
			}
		}

		public void Apply(IKSolverFullBodyBiped solver, float weight, Quaternion rotation)
		{
			for (int i = 0; i < effectorLinks.Length; i++)
			{
				effectorLinks[i].Apply(solver, weight, rotation);
			}
		}
	}
	public class Recoil : OffsetModifier
	{
		[Serializable]
		public class RecoilOffset
		{
			[Serializable]
			public class EffectorLink
			{
				[Tooltip("Type of the FBBIK effector to use")]
				public FullBodyBipedEffector effector;

				[Tooltip("Weight of using this effector")]
				public float weight;
			}

			[Tooltip("Offset vector for the associated effector when doing recoil.")]
			public Vector3 offset;

			[Tooltip("When firing before the last recoil has faded, how much of the current recoil offset will be maintained?")]
			[Range(0f, 1f)]
			public float additivity = 1f;

			[Tooltip("Max additive recoil for automatic fire.")]
			public float maxAdditiveOffsetMag = 0.2f;

			[Tooltip("Linking this recoil offset to FBBIK effectors.")]
			public EffectorLink[] effectorLinks;

			private Vector3 additiveOffset;

			private Vector3 lastOffset;

			public void Start()
			{
				if (!(additivity <= 0f))
				{
					additiveOffset = Vector3.ClampMagnitude(lastOffset * additivity, maxAdditiveOffsetMag);
				}
			}

			public void Apply(IKSolverFullBodyBiped solver, Quaternion rotation, float masterWeight, float length, float timeLeft)
			{
				additiveOffset = Vector3.Lerp(Vector3.zero, additiveOffset, timeLeft / length);
				lastOffset = rotation * (offset * masterWeight) + rotation * additiveOffset;
				EffectorLink[] array = effectorLinks;
				foreach (EffectorLink effectorLink in array)
				{
					solver.GetEffector(effectorLink.effector).positionOffset += lastOffset * effectorLink.weight;
				}
			}
		}

		[Serializable]
		public enum Handedness
		{
			Right,
			Left
		}

		[Tooltip("Reference to the AimIK component. Optional, only used to getting the aiming direction.")]
		public AimIK aimIK;

		[Tooltip("Set this true if you are using IKExecutionOrder.cs or a custom script to force AimIK solve after FBBIK.")]
		public bool aimIKSolvedLast;

		[Tooltip("Which hand is holding the weapon?")]
		public Handedness handedness;

		[Tooltip("Check for 2-handed weapons.")]
		public bool twoHanded = true;

		[Tooltip("Weight curve for the recoil offsets. Recoil procedure is as long as this curve.")]
		public AnimationCurve recoilWeight;

		[Tooltip("How much is the magnitude randomized each time Recoil is called?")]
		public float magnitudeRandom = 0.1f;

		[Tooltip("How much is the rotation randomized each time Recoil is called?")]
		public Vector3 rotationRandom;

		[Tooltip("Rotating the primary hand bone for the recoil (in local space).")]
		public Vector3 handRotationOffset;

		[Tooltip("Time of blending in another recoil when doing automatic fire.")]
		public float blendTime;

		[Space(10f)]
		[Tooltip("FBBIK effector position offsets for the recoil (in aiming direction space).")]
		public RecoilOffset[] offsets;

		[HideInInspector]
		public Quaternion rotationOffset = Quaternion.identity;

		private float magnitudeMlp = 1f;

		private float endTime = -1f;

		private Quaternion handRotation;

		private Quaternion secondaryHandRelativeRotation;

		private Quaternion randomRotation;

		private float length = 1f;

		private bool initiated;

		private float blendWeight;

		private float w;

		private Quaternion primaryHandRotation = Quaternion.identity;

		private bool handRotationsSet;

		private Vector3 aimIKAxis;

		public bool isFinished => Time.time > endTime;

		private IKEffector primaryHandEffector
		{
			get
			{
				if (handedness == Handedness.Right)
				{
					return ik.solver.rightHandEffector;
				}
				return ik.solver.leftHandEffector;
			}
		}

		private IKEffector secondaryHandEffector
		{
			get
			{
				if (handedness == Handedness.Right)
				{
					return ik.solver.leftHandEffector;
				}
				return ik.solver.rightHandEffector;
			}
		}

		private Transform primaryHand => primaryHandEffector.bone;

		private Transform secondaryHand => secondaryHandEffector.bone;

		public void SetHandRotations(Quaternion leftHandRotation, Quaternion rightHandRotation)
		{
			if (handedness == Handedness.Left)
			{
				primaryHandRotation = leftHandRotation;
			}
			else
			{
				primaryHandRotation = rightHandRotation;
			}
			handRotationsSet = true;
		}

		public void Fire(float magnitude)
		{
			float num = magnitude * UnityEngine.Random.value * magnitudeRandom;
			magnitudeMlp = magnitude + num;
			randomRotation = Quaternion.Euler(rotationRandom * UnityEngine.Random.value);
			RecoilOffset[] array = offsets;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].Start();
			}
			if (Time.time < endTime)
			{
				blendWeight = 0f;
			}
			else
			{
				blendWeight = 1f;
			}
			Keyframe[] keys = recoilWeight.keys;
			length = keys[keys.Length - 1].time;
			endTime = Time.time + length;
		}

		protected override void OnModifyOffset()
		{
			if (aimIK != null)
			{
				aimIKAxis = aimIK.solver.axis;
			}
			if (Time.time >= endTime)
			{
				rotationOffset = Quaternion.identity;
				return;
			}
			if (!initiated && ik != null)
			{
				initiated = true;
				IKSolverFullBodyBiped solver = ik.solver;
				solver.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Combine(solver.OnPostUpdate, new IKSolver.UpdateDelegate(AfterFBBIK));
				if (aimIK != null)
				{
					IKSolverAim solver2 = aimIK.solver;
					solver2.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Combine(solver2.OnPostUpdate, new IKSolver.UpdateDelegate(AfterAimIK));
				}
			}
			blendTime = Mathf.Max(blendTime, 0f);
			if (blendTime > 0f)
			{
				blendWeight = Mathf.Min(blendWeight + Time.deltaTime * (1f / blendTime), 1f);
			}
			else
			{
				blendWeight = 1f;
			}
			float b = recoilWeight.Evaluate(length - (endTime - Time.time)) * magnitudeMlp;
			w = Mathf.Lerp(w, b, blendWeight);
			Quaternion quaternion = ((aimIK != null && !aimIKSolvedLast) ? Quaternion.LookRotation(aimIK.solver.IKPosition - aimIK.solver.transform.position, ik.references.root.up) : ik.references.root.rotation);
			quaternion = randomRotation * quaternion;
			RecoilOffset[] array = offsets;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].Apply(ik.solver, quaternion, w, length, endTime - Time.time);
			}
			if (!handRotationsSet)
			{
				primaryHandRotation = primaryHand.rotation;
			}
			handRotationsSet = false;
			rotationOffset = Quaternion.Lerp(Quaternion.identity, Quaternion.Euler(randomRotation * primaryHandRotation * handRotationOffset), w);
			handRotation = rotationOffset * primaryHandRotation;
			if (twoHanded)
			{
				Vector3 vector = Quaternion.Inverse(primaryHand.rotation) * (secondaryHand.position - primaryHand.position);
				secondaryHandRelativeRotation = Quaternion.Inverse(primaryHand.rotation) * secondaryHand.rotation;
				Vector3 vector2 = primaryHand.position + primaryHandEffector.positionOffset + handRotation * vector;
				secondaryHandEffector.positionOffset += vector2 - (secondaryHand.position + secondaryHandEffector.positionOffset);
			}
			if (aimIK != null && aimIKSolvedLast)
			{
				aimIK.solver.axis = Quaternion.Inverse(ik.references.root.rotation) * Quaternion.Inverse(rotationOffset) * aimIKAxis;
			}
		}

		private void AfterFBBIK()
		{
			if (!(Time.time >= endTime))
			{
				primaryHand.rotation = handRotation;
				if (twoHanded)
				{
					secondaryHand.rotation = primaryHand.rotation * secondaryHandRelativeRotation;
				}
			}
		}

		private void AfterAimIK()
		{
			if (aimIKSolvedLast)
			{
				aimIK.solver.axis = aimIKAxis;
			}
		}

		protected override void OnDestroy()
		{
			base.OnDestroy();
			if (ik != null && initiated)
			{
				IKSolverFullBodyBiped solver = ik.solver;
				solver.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Remove(solver.OnPostUpdate, new IKSolver.UpdateDelegate(AfterFBBIK));
				if (aimIK != null)
				{
					IKSolverAim solver2 = aimIK.solver;
					solver2.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Remove(solver2.OnPostUpdate, new IKSolver.UpdateDelegate(AfterAimIK));
				}
			}
		}
	}
	public class ShoulderRotator : MonoBehaviour
	{
		[Tooltip("Weight of shoulder rotation")]
		public float weight = 1.5f;

		[Tooltip("The greater the offset, the sooner the shoulder will start rotating")]
		public float offset = 0.2f;

		private FullBodyBipedIK ik;

		private bool skip;

		private void Start()
		{
			ik = GetComponent<FullBodyBipedIK>();
			IKSolverFullBodyBiped solver = ik.solver;
			solver.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Combine(solver.OnPostUpdate, new IKSolver.UpdateDelegate(RotateShoulders));
		}

		private void RotateShoulders()
		{
			if (!(ik == null) && !(ik.solver.IKPositionWeight <= 0f))
			{
				if (skip)
				{
					skip = false;
					return;
				}
				RotateShoulder(FullBodyBipedChain.LeftArm, weight, offset);
				RotateShoulder(FullBodyBipedChain.RightArm, weight, offset);
				skip = true;
				ik.solver.Update();
			}
		}

		private void RotateShoulder(FullBodyBipedChain chain, float weight, float offset)
		{
			Quaternion b = Quaternion.FromToRotation(GetParentBoneMap(chain).swingDirection, ik.solver.GetEndEffector(chain).position - GetParentBoneMap(chain).transform.position);
			Vector3 vector = ik.solver.GetEndEffector(chain).position - ik.solver.GetLimbMapping(chain).bone1.position;
			float num = ik.solver.GetChain(chain).nodes[0].length + ik.solver.GetChain(chain).nodes[1].length;
			float num2 = vector.magnitude / num - 1f + offset;
			num2 = Mathf.Clamp(num2 * weight, 0f, 1f);
			Quaternion quaternion = Quaternion.Lerp(Quaternion.identity, b, num2 * ik.solver.GetEndEffector(chain).positionWeight * ik.solver.IKPositionWeight);
			ik.solver.GetLimbMapping(chain).parentBone.rotation = quaternion * ik.solver.GetLimbMapping(chain).parentBone.rotation;
		}

		private IKMapping.BoneMap GetParentBoneMap(FullBodyBipedChain chain)
		{
			return ik.solver.GetLimbMapping(chain).GetBoneMap(IKMappingLimb.BoneMapType.Parent);
		}

		private void OnDestroy()
		{
			if (ik != null)
			{
				IKSolverFullBodyBiped solver = ik.solver;
				solver.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Remove(solver.OnPostUpdate, new IKSolver.UpdateDelegate(RotateShoulders));
			}
		}
	}
}
namespace RootMotion.Demos
{
	public class AimBoxing : MonoBehaviour
	{
		public AimIK aimIK;

		public Transform pin;

		private void LateUpdate()
		{
			aimIK.solver.transform.LookAt(pin.position);
			aimIK.solver.IKPosition = base.transform.position;
		}
	}
	public class SimpleAimingSystem : MonoBehaviour
	{
		[Tooltip("AimPoser is a tool that returns an animation name based on direction.")]
		public AimPoser aimPoser;

		[Tooltip("Reference to the AimIK component.")]
		public AimIK aim;

		[Tooltip("Reference to the LookAt component (only used for the head in this instance).")]
		public LookAtIK lookAt;

		[Tooltip("Reference to the Animator component.")]
		public Animator animator;

		[Tooltip("Time of cross-fading from pose to pose.")]
		public float crossfadeTime = 0.2f;

		[Tooltip("Will keep the aim target at a distance.")]
		public float minAimDistance = 0.5f;

		private AimPoser.Pose aimPose;

		private AimPoser.Pose lastPose;

		private void Start()
		{
			aim.enabled = false;
			lookAt.enabled = false;
		}

		private void LateUpdate()
		{
			if (aim.solver.target == null)
			{
				UnityEngine.Debug.LogWarning("AimIK and LookAtIK need to have their 'Target' value assigned.", base.transform);
			}
			Pose();
			aim.solver.Update();
			if (lookAt != null)
			{
				lookAt.solver.Update();
			}
		}

		private void Pose()
		{
			LimitAimTarget();
			Vector3 direction = aim.solver.target.position - aim.solver.bones[0].transform.position;
			Vector3 localDirection = base.transform.InverseTransformDirection(direction);
			aimPose = aimPoser.GetPose(localDirection);
			if (aimPose != lastPose)
			{
				aimPoser.SetPoseActive(aimPose);
				lastPose = aimPose;
			}
			AimPoser.Pose[] poses = aimPoser.poses;
			foreach (AimPoser.Pose pose in poses)
			{
				if (pose == aimPose)
				{
					DirectCrossFade(pose.name, 1f);
				}
				else
				{
					DirectCrossFade(pose.name, 0f);
				}
			}
		}

		private void LimitAimTarget()
		{
			Vector3 position = aim.solver.bones[0].transform.position;
			Vector3 vector = aim.solver.target.position - position;
			vector = vector.normalized * Mathf.Max(vector.magnitude, minAimDistance);
			aim.solver.target.position = position + vector;
		}

		private void DirectCrossFade(string state, float target)
		{
			float value = Mathf.MoveTowards(animator.GetFloat(state), target, Time.deltaTime * (1f / crossfadeTime));
			animator.SetFloat(state, value);
		}
	}
	public class TerrainOffset : MonoBehaviour
	{
		public AimIK aimIK;

		public Vector3 raycastOffset = new Vector3(0f, 2f, 1.5f);

		public LayerMask raycastLayers;

		public float min = -2f;

		public float max = 2f;

		public float lerpSpeed = 10f;

		private RaycastHit hit;

		private Vector3 offset;

		private void LateUpdate()
		{
			Vector3 vector = base.transform.rotation * raycastOffset;
			Vector3 groundHeightOffset = GetGroundHeightOffset(base.transform.position + vector);
			offset = Vector3.Lerp(offset, groundHeightOffset, Time.deltaTime * lerpSpeed);
			Vector3 vector2 = base.transform.position + new Vector3(vector.x, 0f, vector.z);
			aimIK.solver.transform.LookAt(vector2);
			aimIK.solver.IKPosition = vector2 + offset;
		}

		private Vector3 GetGroundHeightOffset(Vector3 worldPosition)
		{
			UnityEngine.Debug.DrawRay(worldPosition, Vector3.down * raycastOffset.y * 2f, UnityEngine.Color.green);
			if (Physics.Raycast(worldPosition, Vector3.down, out hit, raycastOffset.y * 2f))
			{
				return Mathf.Clamp(hit.point.y - base.transform.position.y, min, max) * Vector3.up;
			}
			return Vector3.zero;
		}
	}
	public class BipedIKvsAnimatorIK : MonoBehaviour
	{
		[LargeHeader("References")]
		public Animator animator;

		public BipedIK bipedIK;

		[LargeHeader("Look At")]
		public Transform lookAtTargetBiped;

		public Transform lookAtTargetAnimator;

		[Range(0f, 1f)]
		public float lookAtWeight = 1f;

		[Range(0f, 1f)]
		public float lookAtBodyWeight = 1f;

		[Range(0f, 1f)]
		public float lookAtHeadWeight = 1f;

		[Range(0f, 1f)]
		public float lookAtEyesWeight = 1f;

		[Range(0f, 1f)]
		public float lookAtClampWeight = 0.5f;

		[Range(0f, 1f)]
		public float lookAtClampWeightHead = 0.5f;

		[Range(0f, 1f)]
		public float lookAtClampWeightEyes = 0.5f;

		[LargeHeader("Foot")]
		public Transform footTargetBiped;

		public Transform footTargetAnimator;

		[Range(0f, 1f)]
		public float footPositionWeight;

		[Range(0f, 1f)]
		public float footRotationWeight;

		[LargeHeader("Hand")]
		public Transform handTargetBiped;

		public Transform handTargetAnimator;

		[Range(0f, 1f)]
		public float handPositionWeight;

		[Range(0f, 1f)]
		public float handRotationWeight;

		private void OnAnimatorIK(int layer)
		{
			animator.transform.rotation = bipedIK.transform.rotation;
			Vector3 vector = animator.transform.position - bipedIK.transform.position;
			lookAtTargetAnimator.position = lookAtTargetBiped.position + vector;
			bipedIK.SetLookAtPosition(lookAtTargetBiped.position);
			bipedIK.SetLookAtWeight(lookAtWeight, lookAtBodyWeight, lookAtHeadWeight, lookAtEyesWeight, lookAtClampWeight, lookAtClampWeightHead, lookAtClampWeightEyes);
			animator.SetLookAtPosition(lookAtTargetAnimator.position);
			animator.SetLookAtWeight(lookAtWeight, lookAtBodyWeight, lookAtHeadWeight, lookAtEyesWeight, lookAtClampWeight);
			footTargetAnimator.position = footTargetBiped.position + vector;
			footTargetAnimator.rotation = footTargetBiped.rotation;
			bipedIK.SetIKPosition(AvatarIKGoal.LeftFoot, footTargetBiped.position);
			bipedIK.SetIKRotation(AvatarIKGoal.LeftFoot, footTargetBiped.rotation);
			bipedIK.SetIKPositionWeight(AvatarIKGoal.LeftFoot, footPositionWeight);
			bipedIK.SetIKRotationWeight(AvatarIKGoal.LeftFoot, footRotationWeight);
			animator.SetIKPosition(AvatarIKGoal.LeftFoot, footTargetAnimator.position);
			animator.SetIKRotation(AvatarIKGoal.LeftFoot, footTargetAnimator.rotation);
			animator.SetIKPositionWeight(AvatarIKGoal.LeftFoot, footPositionWeight);
			animator.SetIKRotationWeight(AvatarIKGoal.LeftFoot, footRotationWeight);
			handTargetAnimator.position = handTargetBiped.position + vector;
			handTargetAnimator.rotation = handTargetBiped.rotation;
			bipedIK.SetIKPosition(AvatarIKGoal.LeftHand, handTargetBiped.position);
			bipedIK.SetIKRotation(AvatarIKGoal.LeftHand, handTargetBiped.rotation);
			bipedIK.SetIKPositionWeight(AvatarIKGoal.LeftHand, handPositionWeight);
			bipedIK.SetIKRotationWeight(AvatarIKGoal.LeftHand, handRotationWeight);
			animator.SetIKPosition(AvatarIKGoal.LeftHand, handTargetAnimator.position);
			animator.SetIKRotation(AvatarIKGoal.LeftHand, handTargetAnimator.rotation);
			animator.SetIKPositionWeight(AvatarIKGoal.LeftHand, handPositionWeight);
			animator.SetIKRotationWeight(AvatarIKGoal.LeftHand, handRotationWeight);
		}
	}
	public class MechSpider : MonoBehaviour
	{
		public LayerMask raycastLayers;

		public float scale = 1f;

		public Transform body;

		public MechSpiderLeg[] legs;

		public float legRotationWeight = 1f;

		public float rootPositionSpeed = 5f;

		public float rootRotationSpeed = 30f;

		public float breatheSpeed = 2f;

		public float breatheMagnitude = 0.2f;

		public float height = 3.5f;

		public float minHeight = 2f;

		public float raycastHeight = 10f;

		public float raycastDistance = 5f;

		private Vector3 lastPosition;

		private Vector3 defaultBodyLocalPosition;

		private float sine;

		private RaycastHit rootHit;

		private void Update()
		{
			Vector3 legsPlaneNormal = GetLegsPlaneNormal();
			Quaternion quaternion = Quaternion.FromToRotation(base.transform.up, legsPlaneNormal);
			base.transform.rotation = Quaternion.Slerp(base.transform.rotation, quaternion * base.transform.rotation, Time.deltaTime * rootRotationSpeed);
			Vector3 vector = Vector3.Project(GetLegCentroid() + base.transform.up * height * scale - base.transform.position, base.transform.up);
			base.transform.position += vector * Time.deltaTime * (rootPositionSpeed * scale);
			if (Physics.Raycast(base.transform.position + base.transform.up * raycastHeight * scale, -base.transform.up, out rootHit, raycastHeight * scale + raycastDistance * scale, raycastLayers))
			{
				rootHit.distance -= raycastHeight * scale + minHeight * scale;
				if (rootHit.distance < 0f)
				{
					Vector3 b = base.transform.position - base.transform.up * rootHit.distance;
					base.transform.position = Vector3.Lerp(base.transform.position, b, Time.deltaTime * rootPositionSpeed * scale);
				}
			}
			sine += Time.deltaTime * breatheSpeed;
			if (sine >= (float)Math.PI * 2f)
			{
				sine -= (float)Math.PI * 2f;
			}
			float num = Mathf.Sin(sine) * breatheMagnitude * scale;
			Vector3 vector2 = base.transform.up * num;
			body.transform.position = base.transform.position + vector2;
		}

		private Vector3 GetLegCentroid()
		{
			Vector3 zero = Vector3.zero;
			float num = 1f / (float)legs.Length;
			for (int i = 0; i < legs.Length; i++)
			{
				zero += legs[i].position * num;
			}
			return zero;
		}

		private Vector3 GetLegsPlaneNormal()
		{
			Vector3 vector = base.transform.up;
			if (legRotationWeight <= 0f)
			{
				return vector;
			}
			float t = 1f / Mathf.Lerp(legs.Length, 1f, legRotationWeight);
			for (int i = 0; i < legs.Length; i++)
			{
				Vector3 vector2 = legs[i].position - (base.transform.position - base.transform.up * height * scale);
				Vector3 normal = base.transform.up;
				Vector3 tangent = vector2;
				Vector3.OrthoNormalize(ref normal, ref tangent);
				Quaternion b = Quaternion.FromToRotation(tangent, vector2);
				b = Quaternion.Lerp(Quaternion.identity, b, t);
				vector = b * vector;
			}
			return vector;
		}
	}
	public class MechSpiderController : MonoBehaviour
	{
		public MechSpider mechSpider;

		public Transform cameraTransform;

		public float speed = 6f;

		public float turnSpeed = 30f;

		public Vector3 inputVector => new Vector3(Input.GetAxis("Horizontal"), 0f, Input.GetAxis("Vertical"));

		private void Update()
		{
			Vector3 tangent = cameraTransform.forward;
			Vector3 normal = base.transform.up;
			Vector3.OrthoNormalize(ref normal, ref tangent);
			Quaternion quaternion = Quaternion.LookRotation(tangent, base.transform.up);
			base.transform.Translate(quaternion * inputVector.normalized * Time.deltaTime * speed * mechSpider.scale, Space.World);
			base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, quaternion, Time.deltaTime * turnSpeed);
		}
	}
	public class MechSpiderLeg : MonoBehaviour
	{
		public MechSpider mechSpider;

		public MechSpiderLeg unSync;

		public Vector3 offset;

		public float minDelay = 0.2f;

		public float maxOffset = 1f;

		public float stepSpeed = 5f;

		public float footHeight = 0.15f;

		public float velocityPrediction = 0.2f;

		public float raycastFocus = 0.1f;

		public AnimationCurve yOffset;

		public ParticleSystem sand;

		private IK ik;

		private float stepProgress = 1f;

		private float lastStepTime;

		private Vector3 defaultPosition;

		private RaycastHit hit;

		public bool isStepping => stepProgress < 1f;

		public Vector3 position
		{
			get
			{
				return ik.GetIKSolver().GetIKPosition();
			}
			set
			{
				ik.GetIKSolver().SetIKPosition(value);
			}
		}

		private void Start()
		{
			ik = GetComponent<IK>();
			stepProgress = 1f;
			hit = default(RaycastHit);
			IKSolver.Point[] points = ik.GetIKSolver().GetPoints();
			position = points[points.Length - 1].transform.position;
			hit.point = position;
			defaultPosition = mechSpider.transform.InverseTransformPoint(position + offset * mechSpider.scale);
		}

		private Vector3 GetStepTarget(out bool stepFound, float focus, float distance)
		{
			stepFound = false;
			Vector3 vector = mechSpider.transform.TransformPoint(defaultPosition) + (hit.point - position) * velocityPrediction;
			Vector3 up = mechSpider.transform.up;
			Vector3 rhs = mechSpider.body.position - position;
			Vector3 axis = Vector3.Cross(up, rhs);
			up = Quaternion.AngleAxis(focus, axis) * up;
			if (Physics.Raycast(vector + up * mechSpider.raycastHeight * mechSpider.scale, -up, out hit, mechSpider.raycastHeight * mechSpider.scale + distance, mechSpider.raycastLayers))
			{
				stepFound = true;
			}
			return hit.point + mechSpider.transform.up * footHeight * mechSpider.scale;
		}

		private void Update()
		{
			if (!isStepping && !(Time.time < lastStepTime + minDelay) && (!(unSync != null) || !unSync.isStepping))
			{
				bool stepFound = false;
				Vector3 stepTarget = GetStepTarget(out stepFound, raycastFocus, mechSpider.raycastDistance * mechSpider.scale);
				if (!stepFound)
				{
					stepTarget = GetStepTarget(out stepFound, 0f - raycastFocus, mechSpider.raycastDistance * 3f * mechSpider.scale);
				}
				if (stepFound && !(Vector3.Distance(position, stepTarget) < maxOffset * mechSpider.scale * UnityEngine.Random.Range(0.9f, 1.2f)))
				{
					StopAllCoroutines();
					StartCoroutine(Step(position, stepTarget));
				}
			}
		}

		private IEnumerator Step(Vector3 stepStartPosition, Vector3 targetPosition)
		{
			stepProgress = 0f;
			while (stepProgress < 1f)
			{
				stepProgress += Time.deltaTime * stepSpeed;
				position = Vector3.Lerp(stepStartPosition, targetPosition, stepProgress);
				position += mechSpider.transform.up * yOffset.Evaluate(stepProgress) * mechSpider.scale;
				yield return null;
			}
			position = targetPosition;
			if (sand != null)
			{
				sand.transform.position = position - mechSpider.transform.up * footHeight * mechSpider.scale;
				sand.Emit(20);
			}
			lastStepTime = Time.time;
		}
	}
	public class MechSpiderParticles : MonoBehaviour
	{
		public MechSpiderController mechSpiderController;

		private ParticleSystem particles;

		private void Start()
		{
			particles = (ParticleSystem)GetComponent(typeof(ParticleSystem));
		}

		private void Update()
		{
			float magnitude = mechSpiderController.inputVector.magnitude;
			float constant = Mathf.Clamp(magnitude * 50f, 30f, 50f);
			ParticleSystem.EmissionModule emission = particles.emission;
			emission.rateOverTime = new ParticleSystem.MinMaxCurve(constant);
			ParticleSystem.MainModule main = particles.main;
			main.startColor = new UnityEngine.Color(particles.main.startColor.color.r, particles.main.startColor.color.g, particles.main.startColor.color.b, Mathf.Clamp(magnitude, 0.4f, 1f));
		}
	}
	public class AnimationWarping : OffsetModifier
	{
		[Serializable]
		public struct Warp
		{
			[Tooltip("Layer of the 'Animation State' in the Animator.")]
			public int animationLayer;

			[Tooltip("Name of the state in the Animator to warp.")]
			public string animationState;

			[Tooltip("Warping weight by normalized time of the animation state.")]
			public AnimationCurve weightCurve;

			[Tooltip("Animated point to warp from. This should be in character space so keep this Transform parented to the root of the character.")]
			public Transform warpFrom;

			[Tooltip("World space point to warp to.")]
			public Transform warpTo;

			[Tooltip("Which FBBIK effector to use?")]
			public FullBodyBipedEffector effector;
		}

		[Serializable]
		public enum EffectorMode
		{
			PositionOffset,
			Position
		}

		[Tooltip("Reference to the Animator component to use")]
		public Animator animator;

		[Tooltip("Using effector.positionOffset or effector.position with effector.positionWeight? The former will enable you to use effector.position for other things, the latter will weigh in the effectors, hence using Reach and Pull in the process.")]
		public EffectorMode effectorMode;

		[Space(10f)]
		[Tooltip("The array of warps, can have multiple simultaneous warps.")]
		public Warp[] warps;

		private EffectorMode lastMode;

		protected override void Start()
		{
			base.Start();
			lastMode = effectorMode;
		}

		public float GetWarpWeight(int warpIndex)
		{
			if (warpIndex < 0)
			{
				UnityEngine.Debug.LogError("Warp index out of range.");
				return 0f;
			}
			if (warpIndex >= warps.Length)
			{
				UnityEngine.Debug.LogError("Warp index out of range.");
				return 0f;
			}
			if (animator == null)
			{
				UnityEngine.Debug.LogError("Animator unassigned in AnimationWarping");
				return 0f;
			}
			AnimatorStateInfo currentAnimatorStateInfo = animator.GetCurrentAnimatorStateInfo(warps[warpIndex].animationLayer);
			if (!currentAnimatorStateInfo.IsName(warps[warpIndex].animationState))
			{
				return 0f;
			}
			return warps[warpIndex].weightCurve.Evaluate(currentAnimatorStateInfo.normalizedTime - (float)(int)currentAnimatorStateInfo.normalizedTime);
		}

		protected override void OnModifyOffset()
		{
			for (int i = 0; i < warps.Length; i++)
			{
				float warpWeight = GetWarpWeight(i);
				Vector3 vector = warps[i].warpTo.position - warps[i].warpFrom.position;
				switch (effectorMode)
				{
				case EffectorMode.PositionOffset:
					ik.solver.GetEffector(warps[i].effector).positionOffset += vector * warpWeight * weight;
					break;
				case EffectorMode.Position:
					ik.solver.GetEffector(warps[i].effector).position = ik.solver.GetEffector(warps[i].effector).bone.position + vector;
					ik.solver.GetEffector(warps[i].effector).positionWeight = weight * warpWeight;
					break;
				}
			}
			if (lastMode == EffectorMode.Position && effectorMode == EffectorMode.PositionOffset)
			{
				Warp[] array = warps;
				for (int j = 0; j < array.Length; j++)
				{
					Warp warp = array[j];
					ik.solver.GetEffector(warp.effector).positionWeight = 0f;
				}
			}
			lastMode = effectorMode;
		}

		private void OnDisable()
		{
			if (effectorMode == EffectorMode.Position)
			{
				Warp[] array = warps;
				for (int i = 0; i < array.Length; i++)
				{
					Warp warp = array[i];
					ik.solver.GetEffector(warp.effector).positionWeight = 0f;
				}
			}
		}
	}
	[RequireComponent(typeof(Animator))]
	public class AnimatorController3rdPerson : MonoBehaviour
	{
		public float rotateSpeed = 7f;

		public float blendSpeed = 10f;

		public float maxAngle = 90f;

		public float moveSpeed = 1.5f;

		public float rootMotionWeight;

		protected Animator animator;

		protected Vector3 moveBlend;

		protected Vector3 moveInput;

		protected Vector3 velocity;

		protected virtual void Start()
		{
			animator = GetComponent<Animator>();
		}

		private void OnAnimatorMove()
		{
			velocity = Vector3.Lerp(velocity, base.transform.rotation * Vector3.ClampMagnitude(moveInput, 1f) * moveSpeed, Time.deltaTime * blendSpeed);
			base.transform.position += Vector3.Lerp(velocity * Time.deltaTime, animator.deltaPosition, rootMotionWeight);
		}

		public virtual void Move(Vector3 moveInput, bool isMoving, Vector3 faceDirection, Vector3 aimTarget)
		{
			this.moveInput = moveInput;
			Vector3 vector = base.transform.InverseTransformDirection(faceDirection);
			float num = Mathf.Atan2(vector.x, vector.z) * 57.29578f;
			float num2 = num * Time.deltaTime * rotateSpeed;
			if (num > maxAngle)
			{
				num2 = Mathf.Clamp(num2, num - maxAngle, num2);
			}
			if (num < 0f - maxAngle)
			{
				num2 = Mathf.Clamp(num2, num2, num + maxAngle);
			}
			base.transform.Rotate(Vector3.up, num2);
			moveBlend = Vector3.Lerp(moveBlend, moveInput, Time.deltaTime * blendSpeed);
			animator.SetFloat("X", moveBlend.x);
			animator.SetFloat("Z", moveBlend.z);
			animator.SetBool("IsMoving", isMoving);
		}
	}
	[RequireComponent(typeof(AimIK))]
	[RequireComponent(typeof(FullBodyBipedIK))]
	public class AnimatorController3rdPersonIK : AnimatorController3rdPerson
	{
		[Range(0f, 1f)]
		public float headLookWeight = 1f;

		public Vector3 gunHoldOffset;

		public Vector3 leftHandOffset;

		public Recoil recoil;

		private AimIK aim;

		private FullBodyBipedIK ik;

		private Vector3 headLookAxis;

		private Vector3 leftHandPosRelToRightHand;

		private Quaternion leftHandRotRelToRightHand;

		private Vector3 aimTarget;

		private Quaternion rightHandRotation;

		protected override void Start()
		{
			base.Start();
			aim = GetComponent<AimIK>();
			ik = GetComponent<FullBodyBipedIK>();
			IKSolverFullBodyBiped solver = ik.solver;
			solver.OnPreRead = (IKSolver.UpdateDelegate)Delegate.Combine(solver.OnPreRead, new IKSolver.UpdateDelegate(OnPreRead));
			aim.enabled = false;
			ik.enabled = false;
			headLookAxis = ik.references.head.InverseTransformVector(ik.references.root.forward);
			animator.SetLayerWeight(1, 1f);
		}

		public override void Move(Vector3 moveInput, bool isMoving, Vector3 faceDirection, Vector3 aimTarget)
		{
			base.Move(moveInput, isMoving, faceDirection, aimTarget);
			this.aimTarget = aimTarget;
			Read();
			AimIK();
			FBBIK();
			HeadLookAt(aimTarget);
		}

		private void Read()
		{
			leftHandPosRelToRightHand = ik.references.rightHand.InverseTransformPoint(ik.references.leftHand.position);
			leftHandRotRelToRightHand = Quaternion.Inverse(ik.references.rightHand.rotation) * ik.references.leftHand.rotation;
		}

		private void AimIK()
		{
			aim.solver.IKPosition = aimTarget;
			aim.solver.Update();
		}

		private void FBBIK()
		{
			rightHandRotation = ik.references.rightHand.rotation;
			Vector3 vector = ik.references.rightHand.rotation * gunHoldOffset;
			ik.solver.rightHandEffector.positionOffset += vector;
			if (recoil != null)
			{
				recoil.SetHandRotations(rightHandRotation * leftHandRotRelToRightHand, rightHandRotation);
			}
			ik.solver.Update();
			if (recoil != null)
			{
				ik.references.rightHand.rotation = recoil.rotationOffset * rightHandRotation;
				ik.references.leftHand.rotation = recoil.rotationOffset * rightHandRotation * leftHandRotRelToRightHand;
			}
			else
			{
				ik.references.rightHand.rotation = rightHandRotation;
				ik.references.leftHand.rotation = rightHandRotation * leftHandRotRelToRightHand;
			}
		}

		private void OnPreRead()
		{
			Quaternion quaternion = ((recoil != null) ? (recoil.rotationOffset * rightHandRotation) : rightHandRotation);
			Vector3 vector = ik.references.rightHand.position + ik.solver.rightHandEffector.positionOffset + quaternion * leftHandPosRelToRightHand;
			ik.solver.leftHandEffector.positionOffset += vector - ik.references.leftHand.position - ik.solver.leftHandEffector.positionOffset + quaternion * leftHandOffset;
		}

		private void HeadLookAt(Vector3 lookAtTarget)
		{
			Quaternion b = Quaternion.FromToRotation(ik.references.head.rotation * headLookAxis, lookAtTarget - ik.references.head.position);
			ik.references.head.rotation = Quaternion.Lerp(Quaternion.identity, b, headLookWeight) * ik.references.head.rotation;
		}

		private void OnDestroy()
		{
			if (ik != null)
			{
				IKSolverFullBodyBiped solver = ik.solver;
				solver.OnPreRead = (IKSolver.UpdateDelegate)Delegate.Remove(solver.OnPreRead, new IKSolver.UpdateDelegate(OnPreRead));
			}
		}
	}
	[RequireComponent(typeof(FullBodyBipedIK))]
	public class CharacterAnimationThirdPersonIK : CharacterAnimationThirdPerson
	{
		private FullBodyBipedIK ik;

		protected override void Start()
		{
			base.Start();
			ik = GetComponent<FullBodyBipedIK>();
		}

		protected override void LateUpdate()
		{
			base.LateUpdate();
			if (!(Vector3.Angle(base.transform.up, Vector3.up) <= 0.01f))
			{
				Quaternion rotation = Quaternion.FromToRotation(base.transform.up, Vector3.up);
				RotateEffector(ik.solver.bodyEffector, rotation, 0.1f);
				RotateEffector(ik.solver.leftShoulderEffector, rotation, 0.2f);
				RotateEffector(ik.solver.rightShoulderEffector, rotation, 0.2f);
				RotateEffector(ik.solver.leftHandEffector, rotation, 0.1f);
				RotateEffector(ik.solver.rightHandEffector, rotation, 0.1f);
			}
		}

		private void RotateEffector(IKEffector effector, Quaternion rotation, float mlp)
		{
			Vector3 vector = effector.bone.position - base.transform.position;
			Vector3 vector2 = rotation * vector - vector;
			effector.positionOffset += vector2 * mlp;
		}
	}
	[RequireComponent(typeof(AnimatorController3rdPerson))]
	public class CharacterController3rdPerson : MonoBehaviour
	{
		[SerializeField]
		private CameraController cam;

		private AnimatorController3rdPerson animatorController;

		private static Vector3 inputVector => new Vector3(Input.GetAxis("Horizontal"), 0f, Input.GetAxis("Vertical"));

		private static Vector3 inputVectorRaw => new Vector3(Input.GetAxisRaw("Horizontal"), 0f, Input.GetAxisRaw("Vertical"));

		private void Start()
		{
			animatorController = GetComponent<AnimatorController3rdPerson>();
			cam.enabled = false;
		}

		private void LateUpdate()
		{
			cam.UpdateInput();
			cam.UpdateTransform();
			Vector3 moveInput = inputVector;
			bool isMoving = inputVector != Vector3.zero || inputVectorRaw != Vector3.zero;
			Vector3 forward = cam.transform.forward;
			Vector3 aimTarget = cam.transform.position + forward * 10f;
			animatorController.Move(moveInput, isMoving, forward, aimTarget);
		}
	}
	public class EffectorOffset : OffsetModifier
	{
		[Range(0f, 1f)]
		public float handsMaintainRelativePositionWeight;

		public Vector3 bodyOffset;

		public Vector3 leftShoulderOffset;

		public Vector3 rightShoulderOffset;

		public Vector3 leftThighOffset;

		public Vector3 rightThighOffset;

		public Vector3 leftHandOffset;

		public Vector3 rightHandOffset;

		public Vector3 leftFootOffset;

		public Vector3 rightFootOffset;

		protected override void OnModifyOffset()
		{
			ik.solver.leftHandEffector.maintainRelativePositionWeight = handsMaintainRelativePositionWeight;
			ik.solver.rightHandEffector.maintainRelativePositionWeight = handsMaintainRelativePositionWeight;
			ik.solver.bodyEffector.positionOffset += base.transform.rotation * bodyOffset * weight;
			ik.solver.leftShoulderEffector.positionOffset += base.transform.rotation * leftShoulderOffset * weight;
			ik.solver.rightShoulderEffector.positionOffset += base.transform.rotation * rightShoulderOffset * weight;
			ik.solver.leftThighEffector.positionOffset += base.transform.rotation * leftThighOffset * weight;
			ik.solver.rightThighEffector.positionOffset += base.transform.rotation * rightThighOffset * weight;
			ik.solver.leftHandEffector.positionOffset += base.transform.rotation * leftHandOffset * weight;
			ik.solver.rightHandEffector.positionOffset += base.transform.rotation * rightHandOffset * weight;
			ik.solver.leftFootEffector.positionOffset += base.transform.rotation * leftFootOffset * weight;
			ik.solver.rightFootEffector.positionOffset += base.transform.rotation * rightFootOffset * weight;
		}
	}
	public class ExplosionDemo : MonoBehaviour
	{
		public SimpleLocomotion character;

		public float forceMlp = 1f;

		public float upForce = 1f;

		public float weightFalloffSpeed = 1f;

		public AnimationCurve weightFalloff;

		public AnimationCurve explosionForceByDistance;

		public AnimationCurve scale;

		private float weight;

		private Vector3 defaultScale = Vector3.one;

		private Rigidbody r;

		private FullBodyBipedIK ik;

		private void Start()
		{
			defaultScale = base.transform.localScale;
			r = character.GetComponent<Rigidbody>();
			ik = character.GetComponent<FullBodyBipedIK>();
		}

		private void Update()
		{
			weight = Mathf.Clamp(weight - Time.deltaTime * weightFalloffSpeed, 0f, 1f);
			if (Input.GetKeyDown(KeyCode.E) && character.isGrounded)
			{
				ik.solver.IKPositionWeight = 1f;
				ik.solver.leftHandEffector.position = ik.solver.leftHandEffector.bone.position;
				ik.solver.rightHandEffector.position = ik.solver.rightHandEffector.bone.position;
				ik.solver.leftFootEffector.position = ik.solver.leftFootEffector.bone.position;
				ik.solver.rightFootEffector.position = ik.solver.rightFootEffector.bone.position;
				weight = 1f;
				Vector3 vector = r.position - base.transform.position;
				vector.y = 0f;
				float num = explosionForceByDistance.Evaluate(vector.magnitude);
				r.velocity = (vector.normalized + Vector3.up * upForce) * num * forceMlp;
			}
			if (weight < 0.5f && character.isGrounded)
			{
				weight = Mathf.Clamp(weight - Time.deltaTime * 3f, 0f, 1f);
			}
			SetEffectorWeights(weightFalloff.Evaluate(weight));
			base.transform.localScale = scale.Evaluate(weight) * defaultScale;
		}

		private void SetEffectorWeights(float w)
		{
			ik.solver.leftHandEffector.positionWeight = w;
			ik.solver.rightHandEffector.positionWeight = w;
			ik.solver.leftFootEffector.positionWeight = w;
			ik.solver.rightFootEffector.positionWeight = w;
		}
	}
	public class FBBIKSettings : MonoBehaviour
	{
		[Serializable]
		public class Limb
		{
			public FBIKChain.Smoothing reachSmoothing;

			public float maintainRelativePositionWeight;

			public float mappingWeight = 1f;

			public void Apply(FullBodyBipedChain chain, IKSolverFullBodyBiped solver)
			{
				solver.GetChain(chain).reachSmoothing = reachSmoothing;
				solver.GetEndEffector(chain).maintainRelativePositionWeight = maintainRelativePositionWeight;
				solver.GetLimbMapping(chain).weight = mappingWeight;
			}
		}

		public FullBodyBipedIK ik;

		public bool disableAfterStart;

		public Limb leftArm;

		public Limb rightArm;

		public Limb leftLeg;

		public Limb rightLeg;

		public float rootPin;

		public bool bodyEffectChildNodes = true;

		public void UpdateSettings()
		{
			if (!(ik == null))
			{
				leftArm.Apply(FullBodyBipedChain.LeftArm, ik.solver);
				rightArm.Apply(FullBodyBipedChain.RightArm, ik.solver);
				leftLeg.Apply(FullBodyBipedChain.LeftLeg, ik.solver);
				rightLeg.Apply(FullBodyBipedChain.RightLeg, ik.solver);
				ik.solver.chain[0].pin = rootPin;
				ik.solver.bodyEffector.effectChildNodes = bodyEffectChildNodes;
			}
		}

		private void Start()
		{
			UnityEngine.Debug.Log("FBBIKSettings is deprecated, you can now edit all the settings from the custom inspector of the FullBodyBipedIK component.");
			UpdateSettings();
			if (disableAfterStart)
			{
				base.enabled = false;
			}
		}

		private void Update()
		{
			UpdateSettings();
		}
	}
	public class FBIKBendGoal : MonoBehaviour
	{
		public FullBodyBipedIK ik;

		public FullBodyBipedChain chain;

		public float weight;

		private void Start()
		{
			UnityEngine.Debug.Log("FBIKBendGoal is deprecated, you can now a bend goal from the custom inspector of the FullBodyBipedIK component.");
		}

		private void Update()
		{
			if (!(ik == null))
			{
				ik.solver.GetBendConstraint(chain).bendGoal = base.transform;
				ik.solver.GetBendConstraint(chain).weight = weight;
			}
		}
	}
	public class FBIKBoxing : MonoBehaviour
	{
		[Tooltip("The target we want to hit")]
		public Transform target;

		[Tooltip("The pin Transform is used to reference the exact hit point in the animation (used by AimIK to aim the upper body to follow the target).In Legacy and Generic modes you can just create and position a reference point in your animating software and include it in the FBX. Then in Unity if you added a GameObject with the exact same name under the character's root, it would be animated to the required position.In Humanoid mode however, Mecanim loses track of any Transform that does not belong to the avatar, so in this case the pin point has to be manually set inside the Unity Editor.")]
		public Transform pin;

		[Tooltip("The Full Body Biped IK component")]
		public FullBodyBipedIK ik;

		[Tooltip("The Aim IK component. Aim IK is ust used for following the target slightly with the body.")]
		public AimIK aim;

		[Tooltip("The master weight")]
		public float weight;

		[Tooltip("The effector type of the punching hand")]
		public FullBodyBipedEffector effector;

		[Tooltip("Weight of aiming the body to follow the target")]
		public AnimationCurve aimWeight;

		private Animator animator;

		private void Start()
		{
			animator = GetComponent<Animator>();
		}

		private void LateUpdate()
		{
			float @float = animator.GetFloat("HitWeight");
			ik.solver.GetEffector(effector).position = target.position;
			ik.solver.GetEffector(effector).positionWeight = @float * weight;
			if (aim != null)
			{
				aim.solver.transform.LookAt(pin.position);
				aim.solver.IKPosition = target.position;
				aim.solver.IKPositionWeight = aimWeight.Evaluate(@float) * weight;
			}
		}
	}
	public class FBIKHandsOnProp : MonoBehaviour
	{
		public FullBodyBipedIK ik;

		public bool leftHanded;

		private void Awake()
		{
			IKSolverFullBodyBiped solver = ik.solver;
			solver.OnPreRead = (IKSolver.UpdateDelegate)Delegate.Combine(solver.OnPreRead, new IKSolver.UpdateDelegate(OnPreRead));
		}

		private void OnPreRead()
		{
			if (leftHanded)
			{
				HandsOnProp(ik.solver.leftHandEffector, ik.solver.rightHandEffector);
			}
			else
			{
				HandsOnProp(ik.solver.rightHandEffector, ik.solver.leftHandEffector);
			}
		}

		private void HandsOnProp(IKEffector mainHand, IKEffector otherHand)
		{
			Vector3 vector = otherHand.bone.position - mainHand.bone.position;
			Vector3 vector2 = Quaternion.Inverse(mainHand.bone.rotation) * vector;
			Vector3 vector3 = mainHand.bone.position + vector * 0.5f;
			Quaternion quaternion = Quaternion.Inverse(mainHand.bone.rotation) * otherHand.bone.rotation;
			Vector3 toDirection = otherHand.bone.position + otherHand.positionOffset - (mainHand.bone.position + mainHand.positionOffset);
			Vector3 vector4 = mainHand.bone.position + mainHand.positionOffset + vector * 0.5f;
			mainHand.position = mainHand.bone.position + mainHand.positionOffset + (vector4 - vector3);
			mainHand.positionWeight = 1f;
			Quaternion quaternion2 = Quaternion.FromToRotation(vector, toDirection);
			mainHand.rotation = quaternion2 * mainHand.bone.rotation;
			mainHand.rotationWeight = 1f;
			otherHand.position = mainHand.position + mainHand.rotation * vector2;
			otherHand.positionWeight = 1f;
			otherHand.rotation = mainHand.rotation * quaternion;
			otherHand.rotationWeight = 1f;
		}

		private void OnDestroy()
		{
			if (ik != null)
			{
				IKSolverFullBodyBiped solver = ik.solver;
				solver.OnPreRead = (IKSolver.UpdateDelegate)Delegate.Remove(solver.OnPreRead, new IKSolver.UpdateDelegate(OnPreRead));
			}
		}
	}
	public class FPSAiming : MonoBehaviour
	{
		[Range(0f, 1f)]
		public float aimWeight = 1f;

		[Range(0f, 1f)]
		public float sightWeight = 1f;

		[Range(0f, 180f)]
		public float maxAngle = 80f;

		[SerializeField]
		private bool animatePhysics;

		[SerializeField]
		private Transform gun;

		[SerializeField]
		private Transform gunTarget;

		[SerializeField]
		private FullBodyBipedIK ik;

		[SerializeField]
		private AimIK gunAim;

		[SerializeField]
		private CameraControllerFPS cam;

		[SerializeField]
		private Recoil recoil;

		[SerializeField]
		[Range(0f, 1f)]
		private float cameraRecoilWeight = 0.5f;

		private Vector3 gunTargetDefaultLocalPosition;

		private Quaternion gunTargetDefaultLocalRotation;

		private Vector3 camDefaultLocalPosition;

		private Vector3 camRelativeToGunTarget;

		private bool updateFrame;

		private void Start()
		{
			gunTargetDefaultLocalPosition = gunTarget.localPosition;
			gunTargetDefaultLocalRotation = gunTarget.localRotation;
			camDefaultLocalPosition = cam.transform.localPosition;
			cam.enabled = false;
			gunAim.enabled = false;
			ik.enabled = false;
			if (recoil != null && ik.solver.iterations == 0)
			{
				UnityEngine.Debug.LogWarning("FPSAiming with Recoil needs FBBIK solver iteration count to be at least 1 to maintain accuracy.");
			}
		}

		private void FixedUpdate()
		{
			updateFrame = true;
		}

		private void LateUpdate()
		{
			if (!animatePhysics)
			{
				updateFrame = true;
			}
			if (updateFrame)
			{
				updateFrame = false;
				cam.transform.localPosition = camDefaultLocalPosition;
				camRelativeToGunTarget = gunTarget.InverseTransformPoint(cam.transform.position);
				cam.LateUpdate();
				RotateCharacter();
				Aiming();
				LookDownTheSight();
			}
		}

		private void Aiming()
		{
			if (!(aimWeight <= 0f))
			{
				Quaternion rotation = cam.transform.rotation;
				gunAim.solver.IKPosition = cam.transform.position + cam.transform.forward * 10f;
				gunAim.solver.IKPositionWeight = aimWeight;
				gunAim.solver.Update();
				cam.transform.rotation = rotation;
			}
		}

		private void LookDownTheSight()
		{
			float t = aimWeight * sightWeight;
			gunTarget.position = Vector3.Lerp(gun.position, gunTarget.parent.TransformPoint(gunTargetDefaultLocalPosition), t);
			gunTarget.rotation = Quaternion.Lerp(gun.rotation, gunTarget.parent.rotation * gunTargetDefaultLocalRotation, t);
			Vector3 position = gun.InverseTransformPoint(ik.solver.leftHandEffector.bone.position);
			Vector3 position2 = gun.InverseTransformPoint(ik.solver.rightHandEffector.bone.position);
			Quaternion quaternion = Quaternion.Inverse(gun.rotation) * ik.solver.leftHandEffector.bone.rotation;
			Quaternion quaternion2 = Quaternion.Inverse(gun.rotation) * ik.solver.rightHandEffector.bone.rotation;
			float num = 1f;
			ik.solver.leftHandEffector.positionOffset += (gunTarget.TransformPoint(position) - (ik.solver.leftHandEffector.bone.position + ik.solver.leftHandEffector.positionOffset)) * num;
			ik.solver.rightHandEffector.positionOffset += (gunTarget.TransformPoint(position2) - (ik.solver.rightHandEffector.bone.position + ik.solver.rightHandEffector.positionOffset)) * num;
			ik.solver.headMapping.maintainRotationWeight = 1f;
			if (recoil != null)
			{
				recoil.SetHandRotations(gunTarget.rotation * quaternion, gunTarget.rotation * quaternion2);
			}
			ik.solver.Update();
			if (recoil != null)
			{
				ik.references.leftHand.rotation = recoil.rotationOffset * (gunTarget.rotation * quaternion);
				ik.references.rightHand.rotation = recoil.rotationOffset * (gunTarget.rotation * quaternion2);
			}
			else
			{
				ik.references.leftHand.rotation = gunTarget.rotation * quaternion;
				ik.references.rightHand.rotation = gunTarget.rotation * quaternion2;
			}
			cam.transform.position = Vector3.Lerp(cam.transform.position, Vector3.Lerp(gunTarget.TransformPoint(camRelativeToGunTarget), gun.transform.TransformPoint(camRelativeToGunTarget), cameraRecoilWeight), t);
		}

		private void RotateCharacter()
		{
			if (maxAngle >= 180f)
			{
				return;
			}
			if (maxAngle <= 0f)
			{
				base.transform.rotation = Quaternion.LookRotation(new Vector3(cam.transform.forward.x, 0f, cam.transform.forward.z));
				return;
			}
			Vector3 vector = base.transform.InverseTransformDirection(cam.transform.forward);
			float num = Mathf.Atan2(vector.x, vector.z) * 57.29578f;
			if (Mathf.Abs(num) > Mathf.Abs(maxAngle))
			{
				float angle = num - maxAngle;
				if (num < 0f)
				{
					angle = num + maxAngle;
				}
				base.transform.rotation = Quaternion.AngleAxis(angle, base.transform.up) * base.transform.rotation;
			}
		}
	}
	[RequireComponent(typeof(FPSAiming))]
	[RequireComponent(typeof(Animator))]
	public class FPSCharacter : MonoBehaviour
	{
		[Range(0f, 1f)]
		public float walkSpeed = 0.5f;

		private float sVel;

		private Animator animator;

		private FPSAiming FPSAiming;

		private void Start()
		{
			animator = GetComponent<Animator>();
			FPSAiming = GetComponent<FPSAiming>();
		}

		private void Update()
		{
			FPSAiming.sightWeight = Mathf.SmoothDamp(FPSAiming.sightWeight, Input.GetMouseButton(1) ? 1f : 0f, ref sVel, 0.1f);
			if (FPSAiming.sightWeight < 0.001f)
			{
				FPSAiming.sightWeight = 0f;
			}
			if (FPSAiming.sightWeight > 0.999f)
			{
				FPSAiming.sightWeight = 1f;
			}
			animator.SetFloat("Speed", walkSpeed);
		}

		private void OnGUI()
		{
			GUI.Label(new Rect(Screen.width - 210, 10f, 200f, 25f), "Hold RMB to aim down the sight");
		}
	}
	public class HitReactionTrigger : MonoBehaviour
	{
		[SerializeField]
		private HitReaction hitReaction;

		[SerializeField]
		private float hitForce = 1f;

		private string colliderName;

		private void Update()
		{
			if (Input.GetMouseButtonDown(0))
			{
				Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
				RaycastHit hitInfo = default(RaycastHit);
				if (Physics.Raycast(ray, out hitInfo, 100f))
				{
					hitReaction.Hit(hitInfo.collider, ray.direction * hitForce, hitInfo.point);
					colliderName = hitInfo.collider.name;
				}
			}
		}

		private void OnGUI()
		{
			GUILayout.Label("LMB to shoot the Dummy, RMB to rotate the camera.");
			if (colliderName != string.Empty)
			{
				GUILayout.Label("Last Bone Hit: " + colliderName);
			}
		}
	}
	public class HoldingHands : MonoBehaviour
	{
		public FullBodyBipedIK rightHandChar;

		public FullBodyBipedIK leftHandChar;

		public Transform rightHandTarget;

		public Transform leftHandTarget;

		public float crossFade;

		public float speed = 10f;

		private Quaternion rightHandRotation;

		private Quaternion leftHandRotation;

		private void Start()
		{
			rightHandRotation = Quaternion.Inverse(rightHandChar.solver.rightHandEffector.bone.rotation) * base.transform.rotation;
			leftHandRotation = Quaternion.Inverse(leftHandChar.solver.leftHandEffector.bone.rotation) * base.transform.rotation;
		}

		private void LateUpdate()
		{
			Vector3 b = Vector3.Lerp(rightHandChar.solver.rightHandEffector.bone.position, leftHandChar.solver.leftHandEffector.bone.position, crossFade);
			base.transform.position = Vector3.Lerp(base.transform.position, b, Time.deltaTime * speed);
			base.transform.rotation = Quaternion.Slerp(rightHandChar.solver.rightHandEffector.bone.rotation * rightHandRotation, leftHandChar.solver.leftHandEffector.bone.rotation * leftHandRotation, crossFade);
			rightHandChar.solver.rightHandEffector.position = rightHandTarget.position;
			rightHandChar.solver.rightHandEffector.rotation = rightHandTarget.rotation;
			leftHandChar.solver.leftHandEffector.position = leftHandTarget.position;
			leftHandChar.solver.leftHandEffector.rotation = leftHandTarget.rotation;
		}
	}
	public class InteractionC2CDemo : MonoBehaviour
	{
		public InteractionSystem character1;

		public InteractionSystem character2;

		public InteractionObject handShake;

		private void OnGUI()
		{
			if (GUILayout.Button("Shake Hands"))
			{
				character1.StartInteraction(FullBodyBipedEffector.RightHand, handShake, interrupt: true);
				character2.StartInteraction(FullBodyBipedEffector.RightHand, handShake, interrupt: true);
			}
		}

		private void LateUpdate()
		{
			Vector3 position = Vector3.Lerp(character1.ik.solver.rightHandEffector.bone.position, character2.ik.solver.rightHandEffector.bone.position, 0.5f);
			handShake.transform.position = position;
		}
	}
	public class InteractionDemo : MonoBehaviour
	{
		public InteractionSystem interactionSystem;

		public bool interrupt;

		public InteractionObject ball;

		public InteractionObject benchMain;

		public InteractionObject benchHands;

		public InteractionObject button;

		public InteractionObject cigarette;

		public InteractionObject door;

		private bool isSitting;

		private void OnGUI()
		{
			interrupt = GUILayout.Toggle(interrupt, "Interrupt");
			if (isSitting)
			{
				if (!interactionSystem.inInteraction && GUILayout.Button("Stand Up"))
				{
					interactionSystem.ResumeAll();
					isSitting = false;
				}
				return;
			}
			if (GUILayout.Button("Pick Up Ball"))
			{
				interactionSystem.StartInteraction(FullBodyBipedEffector.RightHand, ball, interrupt);
			}
			if (GUILayout.Button("Button Left Hand"))
			{
				interactionSystem.StartInteraction(FullBodyBipedEffector.LeftHand, button, interrupt);
			}
			if (GUILayout.Button("Button Right Hand"))
			{
				interactionSystem.StartInteraction(FullBodyBipedEffector.RightHand, button, interrupt);
			}
			if (GUILayout.Button("Put Out Cigarette"))
			{
				interactionSystem.StartInteraction(FullBodyBipedEffector.RightFoot, cigarette, interrupt);
			}
			if (GUILayout.Button("Open Door"))
			{
				interactionSystem.StartInteraction(FullBodyBipedEffector.LeftHand, door, interrupt);
			}
			if (!interactionSystem.inInteraction && GUILayout.Button("Sit Down"))
			{
				interactionSystem.StartInteraction(FullBodyBipedEffector.Body, benchMain, interrupt);
				interactionSystem.StartInteraction(FullBodyBipedEffector.LeftThigh, benchMain, interrupt);
				interactionSystem.StartInteraction(FullBodyBipedEffector.RightThigh, benchMain, interrupt);
				interactionSystem.StartInteraction(FullBodyBipedEffector.LeftFoot, benchMain, interrupt);
				interactionSystem.StartInteraction(FullBodyBipedEffector.LeftHand, benchHands, interrupt);
				interactionSystem.StartInteraction(FullBodyBipedEffector.RightHand, benchHands, interrupt);
				isSitting = true;
			}
		}
	}
	[RequireComponent(typeof(InteractionSystem))]
	public class InteractionSystemTestGUI : MonoBehaviour
	{
		[Tooltip("The object to interact to")]
		[SerializeField]
		private InteractionObject interactionObject;

		[Tooltip("The effectors to interact with")]
		[SerializeField]
		private FullBodyBipedEffector[] effectors;

		private InteractionSystem interactionSystem;

		private void Awake()
		{
			interactionSystem = GetComponent<InteractionSystem>();
		}

		private void OnGUI()
		{
			if (interactionSystem == null)
			{
				return;
			}
			if (GUILayout.Button("Start Interaction With " + interactionObject.name))
			{
				if (effectors.Length == 0)
				{
					UnityEngine.Debug.Log("Please select the effectors to interact with.");
				}
				FullBodyBipedEffector[] array = effectors;
				foreach (FullBodyBipedEffector effectorType in array)
				{
					interactionSystem.StartInteraction(effectorType, interactionObject, interrupt: true);
				}
			}
			if (effectors.Length != 0 && interactionSystem.IsPaused(effectors[0]) && GUILayout.Button("Resume Interaction With " + interactionObject.name))
			{
				interactionSystem.ResumeAll();
			}
		}
	}
	public class KissingRig : MonoBehaviour
	{
		[Serializable]
		public class Partner
		{
			public FullBodyBipedIK ik;

			public Transform mouth;

			public Transform mouthTarget;

			public Transform touchTargetLeftHand;

			public Transform touchTargetRightHand;

			public float bodyWeightHorizontal = 0.4f;

			public float bodyWeightVertical = 1f;

			public float neckRotationWeight = 0.3f;

			public float headTiltAngle = 10f;

			public Vector3 headTiltAxis;

			private Quaternion neckRotation;

			private Transform neck => ik.solver.spineMapping.spineBones[ik.solver.spineMapping.spineBones.Length - 1];

			public void Initiate()
			{
				ik.enabled = false;
			}

			public void Update(float weight)
			{
				ik.solver.leftShoulderEffector.positionWeight = weight;
				ik.solver.rightShoulderEffector.positionWeight = weight;
				ik.solver.leftHandEffector.positionWeight = weight;
				ik.solver.rightHandEffector.positionWeight = weight;
				ik.solver.leftHandEffector.rotationWeight = weight;
				ik.solver.rightHandEffector.rotationWeight = weight;
				ik.solver.bodyEffector.positionWeight = weight;
				InverseTransformEffector(FullBodyBipedEffector.LeftShoulder, mouth, mouthTarget.position, weight);
				InverseTransformEffector(FullBodyBipedEffector.RightShoulder, mouth, mouthTarget.position, weight);
				InverseTransformEffector(FullBodyBipedEffector.Body, mouth, mouthTarget.position, weight);
				ik.solver.bodyEffector.position = Vector3.Lerp(new Vector3(ik.solver.bodyEffector.position.x, ik.solver.bodyEffector.bone.position.y, ik.solver.bodyEffector.position.z), ik.solver.bodyEffector.position, bodyWeightVertical * weight);
				ik.solver.bodyEffector.position = Vector3.Lerp(new Vector3(ik.solver.bodyEffector.bone.position.x, ik.solver.bodyEffector.position.y, ik.solver.bodyEffector.bone.position.z), ik.solver.bodyEffector.position, bodyWeightHorizontal * weight);
				ik.solver.leftHandEffector.position = touchTargetLeftHand.position;
				ik.solver.rightHandEffector.position = touchTargetRightHand.position;
				ik.solver.leftHandEffector.rotation = touchTargetLeftHand.rotation;
				ik.solver.rightHandEffector.rotation = touchTargetRightHand.rotation;
				neckRotation = neck.rotation;
				ik.solver.Update();
				neck.rotation = Quaternion.Slerp(neck.rotation, neckRotation, neckRotationWeight * weight);
				ik.references.head.localRotation = Quaternion.AngleAxis(headTiltAngle * weight, headTiltAxis) * ik.references.head.localRotation;
			}

			private void InverseTransformEffector(FullBodyBipedEffector effector, Transform target, Vector3 targetPosition, float weight)
			{
				Vector3 vector = ik.solver.GetEffector(effector).bone.position - target.position;
				ik.solver.GetEffector(effector).position = Vector3.Lerp(ik.solver.GetEffector(effector).bone.position, targetPosition + vector, weight);
			}
		}

		public Partner partner1;

		public Partner partner2;

		public float weight;

		public int iterations = 3;

		private void Start()
		{
			partner1.Initiate();
			partner2.Initiate();
		}

		private void LateUpdate()
		{
			for (int i = 0; i < iterations; i++)
			{
				partner1.Update(weight);
				partner2.Update(weight);
			}
		}
	}
	public class MotionAbsorb : MonoBehaviour
	{
		[Serializable]
		public class Absorber
		{
			[Tooltip("The type of effector (hand, foot, shoulder...) - this is just an enum")]
			public FullBodyBipedEffector effector;

			[Tooltip("How much should motion be absorbed on this effector")]
			public float weight = 1f;

			public void SetToBone(IKSolverFullBodyBiped solver)
			{
				solver.GetEffector(effector).position = solver.GetEffector(effector).bone.position;
				solver.GetEffector(effector).rotation = solver.GetEffector(effector).bone.rotation;
			}

			public void SetEffectorWeights(IKSolverFullBodyBiped solver, float w)
			{
				solver.GetEffector(effector).positionWeight = w * weight;
				solver.GetEffector(effector).rotationWeight = w * weight;
			}
		}

		[Tooltip("Reference to the FBBIK component")]
		public FullBodyBipedIK ik;

		[Tooltip("Array containing the absorbers")]
		public Absorber[] absorbers;

		[Tooltip("The master weight")]
		public float weight = 1f;

		[Tooltip("Weight falloff curve (how fast will the effect reduce after impact)")]
		public AnimationCurve falloff;

		[Tooltip("How fast will the impact fade away. (if 1, effect lasts for 1 second)")]
		public float falloffSpeed = 1f;

		private float timer;

		private void OnCollisionEnter()
		{
			if (!(timer > 0f))
			{
				StartCoroutine(AbsorbMotion());
			}
		}

		private IEnumerator AbsorbMotion()
		{
			timer = 1f;
			for (int i = 0; i < absorbers.Length; i++)
			{
				absorbers[i].SetToBone(ik.solver);
			}
			while (timer > 0f)
			{
				timer -= Time.deltaTime * falloffSpeed;
				float num = falloff.Evaluate(timer);
				for (int j = 0; j < absorbers.Length; j++)
				{
					absorbers[j].SetEffectorWeights(ik.solver, num * weight);
				}
				yield return null;
			}
			yield return null;
		}
	}
	public class MotionAbsorbCharacter : MonoBehaviour
	{
		public Animator animator;

		public MotionAbsorb motionAbsorb;

		public Transform cube;

		public float cubeRandomPosition = 0.1f;

		public AnimationCurve motionAbsorbWeight;

		private Vector3 cubeDefaultPosition;

		private AnimatorStateInfo info;

		private Rigidbody cubeRigidbody;

		private void Start()
		{
			cubeDefaultPosition = cube.position;
			cubeRigidbody = cube.GetComponent<Rigidbody>();
		}

		private void Update()
		{
			info = animator.GetCurrentAnimatorStateInfo(0);
			motionAbsorb.weight = motionAbsorbWeight.Evaluate(info.normalizedTime - (float)(int)info.normalizedTime);
		}

		private void SwingStart()
		{
			cubeRigidbody.MovePosition(cubeDefaultPosition + UnityEngine.Random.insideUnitSphere * cubeRandomPosition);
			cubeRigidbody.MoveRotation(Quaternion.identity);
			cubeRigidbody.velocity = Vector3.zero;
			cubeRigidbody.angularVelocity = Vector3.zero;
		}
	}
	public class OffsetEffector : OffsetModifier
	{
		[Serializable]
		public class EffectorLink
		{
			public FullBodyBipedEffector effectorType;

			public float weightMultiplier = 1f;

			[HideInInspector]
			public Vector3 localPosition;
		}

		public EffectorLink[] effectorLinks;

		protected override void Start()
		{
			base.Start();
			EffectorLink[] array = effectorLinks;
			foreach (EffectorLink effectorLink in array)
			{
				effectorLink.localPosition = base.transform.InverseTransformPoint(ik.solver.GetEffector(effectorLink.effectorType).bone.position);
				if (effectorLink.effectorType == FullBodyBipedEffector.Body)
				{
					ik.solver.bodyEffector.effectChildNodes = false;
				}
			}
		}

		protected override void OnModifyOffset()
		{
			EffectorLink[] array = effectorLinks;
			foreach (EffectorLink effectorLink in array)
			{
				Vector3 vector = base.transform.TransformPoint(effectorLink.localPosition);
				ik.solver.GetEffector(effectorLink.effectorType).positionOffset += (vector - (ik.solver.GetEffector(effectorLink.effectorType).bone.position + ik.solver.GetEffector(effectorLink.effectorType).positionOffset)) * weight * effectorLink.weightMultiplier;
			}
		}
	}
	[RequireComponent(typeof(FullBodyBipedIK))]
	public class PendulumExample : MonoBehaviour
	{
		[Tooltip("The master weight of this script.")]
		[Range(0f, 1f)]
		public float weight = 1f;

		[Tooltip("Multiplier for the distance of the root to the target.")]
		public float hangingDistanceMlp = 1.3f;

		[Tooltip("Where does the root of the character land when weight is blended out?")]
		[HideInInspector]
		public Vector3 rootTargetPosition;

		[Tooltip("How is the root of the character rotated when weight is blended out?")]
		[HideInInspector]
		public Quaternion rootTargetRotation;

		[SerializeField]
		private Transform target;

		[SerializeField]
		private Transform leftHandTarget;

		[SerializeField]
		private Transform rightHandTarget;

		[SerializeField]
		private Transform leftFootTarget;

		[SerializeField]
		private Transform rightFootTarget;

		[SerializeField]
		private Transform pelvisTarget;

		[SerializeField]
		private Transform bodyTarget;

		[SerializeField]
		private Transform headTarget;

		[SerializeField]
		private Vector3 pelvisDownAxis = Vector3.right;

		private FullBodyBipedIK ik;

		private Quaternion rootRelativeToPelvis;

		private Vector3 pelvisToRoot;

		private float lastWeight;

		private void Start()
		{
			ik = GetComponent<FullBodyBipedIK>();
			Quaternion rotation = target.rotation;
			target.rotation = leftHandTarget.rotation;
			target.gameObject.AddComponent<FixedJoint>().connectedBody = leftHandTarget.GetComponent<Rigidbody>();
			target.GetComponent<Rigidbody>().MoveRotation(rotation);
			rootRelativeToPelvis = Quaternion.Inverse(pelvisTarget.rotation) * base.transform.rotation;
			pelvisToRoot = Quaternion.Inverse(ik.references.pelvis.rotation) * (base.transform.position - ik.references.pelvis.position);
			rootTargetPosition = base.transform.position;
			rootTargetRotation = base.transform.rotation;
			lastWeight = weight;
		}

		private void LateUpdate()
		{
			if (weight > 0f)
			{
				ik.solver.leftHandEffector.positionWeight = weight;
				ik.solver.leftHandEffector.rotationWeight = weight;
			}
			else
			{
				rootTargetPosition = base.transform.position;
				rootTargetRotation = base.transform.rotation;
				if (lastWeight > 0f)
				{
					ik.solver.leftHandEffector.positionWeight = 0f;
					ik.solver.leftHandEffector.rotationWeight = 0f;
				}
			}
			lastWeight = weight;
			if (!(weight <= 0f))
			{
				base.transform.position = Vector3.Lerp(rootTargetPosition, pelvisTarget.position + pelvisTarget.rotation * pelvisToRoot * hangingDistanceMlp, weight);
				base.transform.rotation = Quaternion.Lerp(rootTargetRotation, pelvisTarget.rotation * rootRelativeToPelvis, weight);
				ik.solver.leftHandEffector.position = leftHandTarget.position;
				ik.solver.leftHandEffector.rotation = leftHandTarget.rotation;
				Vector3 fromDirection = ik.references.pelvis.rotation * pelvisDownAxis;
				Quaternion b = Quaternion.FromToRotation(fromDirection, rightHandTarget.position - headTarget.position);
				ik.references.rightUpperArm.rotation = Quaternion.Lerp(Quaternion.identity, b, weight) * ik.references.rightUpperArm.rotation;
				Quaternion b2 = Quaternion.FromToRotation(fromDirection, leftFootTarget.position - bodyTarget.position);
				ik.references.leftThigh.rotation = Quaternion.Lerp(Quaternion.identity, b2, weight) * ik.references.leftThigh.rotation;
				Quaternion b3 = Quaternion.FromToRotation(fromDirection, rightFootTarget.position - bodyTarget.position);
				ik.references.rightThigh.rotation = Quaternion.Lerp(Quaternion.identity, b3, weight) * ik.references.rightThigh.rotation;
			}
		}
	}
	public abstract class PickUp2Handed : MonoBehaviour
	{
		[SerializeField]
		private int GUIspace;

		public InteractionSystem interactionSystem;

		public InteractionObject obj;

		public Transform pivot;

		public Transform holdPoint;

		public float pickUpTime = 0.3f;

		private float holdWeight;

		private float holdWeightVel;

		private Vector3 pickUpPosition;

		private Quaternion pickUpRotation;

		private bool holding => interactionSystem.IsPaused(FullBodyBipedEffector.LeftHand);

		private void OnGUI()
		{
			GUILayout.BeginHorizontal();
			GUILayout.Space(GUIspace);
			if (!holding)
			{
				if (GUILayout.Button("Pick Up " + obj.name))
				{
					interactionSystem.StartInteraction(FullBodyBipedEffector.LeftHand, obj, interrupt: false);
					interactionSystem.StartInteraction(FullBodyBipedEffector.RightHand, obj, interrupt: false);
				}
			}
			else if (GUILayout.Button("Drop " + obj.name))
			{
				interactionSystem.ResumeAll();
			}
			GUILayout.EndHorizontal();
		}

		protected abstract void RotatePivot();

		private void Start()
		{
			InteractionSystem obj = interactionSystem;
			obj.OnInteractionStart = (InteractionSystem.InteractionDelegate)Delegate.Combine(obj.OnInteractionStart, new InteractionSystem.InteractionDelegate(OnStart));
			InteractionSystem obj2 = interactionSystem;
			obj2.OnInteractionPause = (InteractionSystem.InteractionDelegate)Delegate.Combine(obj2.OnInteractionPause, new InteractionSystem.InteractionDelegate(OnPause));
			InteractionSystem obj3 = interactionSystem;
			obj3.OnInteractionResume = (InteractionSystem.InteractionDelegate)Delegate.Combine(obj3.OnInteractionResume, new InteractionSystem.InteractionDelegate(OnDrop));
		}

		private void OnPause(FullBodyBipedEffector effectorType, InteractionObject interactionObject)
		{
			if (effectorType == FullBodyBipedEffector.LeftHand && !(interactionObject != obj))
			{
				obj.transform.parent = interactionSystem.transform;
				Rigidbody component = obj.GetComponent<Rigidbody>();
				if (component != null)
				{
					component.isKinematic = true;
				}
				pickUpPosition = obj.transform.position;
				pickUpRotation = obj.transform.rotation;
				holdWeight = 0f;
				holdWeightVel = 0f;
			}
		}

		private void OnStart(FullBodyBipedEffector effectorType, InteractionObject interactionObject)
		{
			if (effectorType == FullBodyBipedEffector.LeftHand && !(interactionObject != obj))
			{
				RotatePivot();
				holdPoint.rotation = obj.transform.rotation;
			}
		}

		private void OnDrop(FullBodyBipedEffector effectorType, InteractionObject interactionObject)
		{
			if (effectorType == FullBodyBipedEffector.LeftHand && !(interactionObject != obj))
			{
				obj.transform.parent = null;
				if (obj.GetComponent<Rigidbody>() != null)
				{
					obj.GetComponent<Rigidbody>().isKinematic = false;
				}
			}
		}

		private void LateUpdate()
		{
			if (holding)
			{
				holdWeight = Mathf.SmoothDamp(holdWeight, 1f, ref holdWeightVel, pickUpTime);
				obj.transform.position = Vector3.Lerp(pickUpPosition, holdPoint.position, holdWeight);
				obj.transform.rotation = Quaternion.Lerp(pickUpRotation, holdPoint.rotation, holdWeight);
			}
		}

		private void OnDestroy()
		{
			if (!(interactionSystem == null))
			{
				InteractionSystem obj = interactionSystem;
				obj.OnInteractionStart = (InteractionSystem.InteractionDelegate)Delegate.Remove(obj.OnInteractionStart, new InteractionSystem.InteractionDelegate(OnStart));
				InteractionSystem obj2 = interactionSystem;
				obj2.OnInteractionPause = (InteractionSystem.InteractionDelegate)Delegate.Remove(obj2.OnInteractionPause, new InteractionSystem.InteractionDelegate(OnPause));
				InteractionSystem obj3 = interactionSystem;
				obj3.OnInteractionResume = (InteractionSystem.InteractionDelegate)Delegate.Remove(obj3.OnInteractionResume, new InteractionSystem.InteractionDelegate(OnDrop));
			}
		}
	}
	public class PickUpBox : PickUp2Handed
	{
		protected override void RotatePivot()
		{
			Vector3 normalized = (pivot.position - interactionSystem.transform.position).normalized;
			normalized.y = 0f;
			Vector3 axis = QuaTools.GetAxis(obj.transform.InverseTransformDirection(normalized));
			Vector3 axis2 = QuaTools.GetAxis(obj.transform.InverseTransformDirection(interactionSystem.transform.up));
			pivot.localRotation = Quaternion.LookRotation(axis, axis2);
		}
	}
	public class PickUpSphere : PickUp2Handed
	{
		protected override void RotatePivot()
		{
			Vector3 vector = Vector3.Lerp(interactionSystem.ik.solver.leftHandEffector.bone.position, interactionSystem.ik.solver.rightHandEffector.bone.position, 0.5f);
			Vector3 forward = obj.transform.position - vector;
			pivot.rotation = Quaternion.LookRotation(forward);
		}
	}
	public class RagdollUtilityDemo : MonoBehaviour
	{
		public RagdollUtility ragdollUtility;

		public Transform root;

		public Rigidbody pelvis;

		private void OnGUI()
		{
			GUILayout.Label(" Press R to switch to ragdoll. \n Weigh in one of the FBBIK effectors to make kinematic changes to the ragdoll pose.\n A to blend back to animation");
		}

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.R))
			{
				ragdollUtility.EnableRagdoll();
			}
			if (Input.GetKeyDown(KeyCode.A))
			{
				Vector3 vector = pelvis.position - root.position;
				root.position += vector;
				pelvis.transform.position -= vector;
				ragdollUtility.DisableRagdoll();
			}
		}
	}
	[RequireComponent(typeof(Recoil))]
	public class RecoilTest : MonoBehaviour
	{
		public float magnitude = 1f;

		private Recoil recoil;

		private void Start()
		{
			recoil = GetComponent<Recoil>();
		}

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.R) || Input.GetMouseButtonDown(0))
			{
				recoil.Fire(magnitude);
			}
		}

		private void OnGUI()
		{
			GUILayout.Label("Press R or LMB for procedural recoil.");
		}
	}
	public class ResetInteractionObject : MonoBehaviour
	{
		public float resetDelay = 1f;

		private Vector3 defaultPosition;

		private Quaternion defaultRotation;

		private Transform defaultParent;

		private Rigidbody r;

		private void Start()
		{
			defaultPosition = base.transform.position;
			defaultRotation = base.transform.rotation;
			defaultParent = base.transform.parent;
			r = GetComponent<Rigidbody>();
		}

		private void OnPickUp(Transform t)
		{
			StopAllCoroutines();
			StartCoroutine(ResetObject(Time.time + resetDelay));
		}

		private IEnumerator ResetObject(float resetTime)
		{
			while (Time.time < resetTime)
			{
				yield return null;
			}
			Poser component = base.transform.parent.GetComponent<Poser>();
			if (component != null)
			{
				component.poseRoot = null;
				component.weight = 0f;
			}
			base.transform.parent = defaultParent;
			base.transform.position = defaultPosition;
			base.transform.rotation = defaultRotation;
			if (r != null)
			{
				r.isKinematic = false;
			}
		}
	}
	[RequireComponent(typeof(Animator))]
	public class SoccerDemo : MonoBehaviour
	{
		private Animator animator;

		private Vector3 defaultPosition;

		private Quaternion defaultRotation;

		private void Start()
		{
			animator = GetComponent<Animator>();
			defaultPosition = base.transform.position;
			defaultRotation = base.transform.rotation;
			StartCoroutine(ResetDelayed());
		}

		private IEnumerator ResetDelayed()
		{
			while (true)
			{
				yield return Yield.WaitSeconds(3f);
				base.transform.position = defaultPosition;
				base.transform.rotation = defaultRotation;
				animator.CrossFade("SoccerKick", 0f, 0, 0f);
				yield return null;
			}
		}
	}
	public class TouchWalls : MonoBehaviour
	{
		[Serializable]
		public class EffectorLink
		{
			public bool enabled = true;

			public FullBodyBipedEffector effectorType;

			public InteractionObject interactionObject;

			public Transform spherecastFrom;

			public float spherecastRadius = 0.1f;

			public float minDistance = 0.3f;

			public LayerMask touchLayers;

			public float lerpSpeed = 10f;

			public float minSwitchTime = 0.2f;

			public float releaseDistance = 0.4f;

			public bool sliding;

			private Vector3 raycastDirectionLocal;

			private float raycastDistance;

			private bool inTouch;

			private RaycastHit hit;

			private Vector3 targetPosition;

			private Quaternion targetRotation;

			private bool initiated;

			private float nextSwitchTime;

			private float speedF;

			public void Initiate(InteractionSystem interactionSystem)
			{
				raycastDirectionLocal = spherecastFrom.InverseTransformDirection(interactionObject.transform.position - spherecastFrom.position);
				raycastDistance = Vector3.Distance(spherecastFrom.position, interactionObject.transform.position);
				interactionSystem.OnInteractionStart = (InteractionSystem.InteractionDelegate)Delegate.Combine(interactionSystem.OnInteractionStart, new InteractionSystem.InteractionDelegate(OnInteractionStart));
				interactionSystem.OnInteractionResume = (InteractionSystem.InteractionDelegate)Delegate.Combine(interactionSystem.OnInteractionResume, new InteractionSystem.InteractionDelegate(OnInteractionResume));
				interactionSystem.OnInteractionStop = (InteractionSystem.InteractionDelegate)Delegate.Combine(interactionSystem.OnInteractionStop, new InteractionSystem.InteractionDelegate(OnInteractionStop));
				hit.normal = Vector3.forward;
				targetPosition = interactionObject.transform.position;
				targetRotation = interactionObject.transform.rotation;
				initiated = true;
			}

			private bool FindWalls(Vector3 direction)
			{
				if (!enabled)
				{
					return false;
				}
				bool result = Physics.SphereCast(spherecastFrom.position, spherecastRadius, direction, out hit, raycastDistance, touchLayers);
				if (hit.distance < minDistance)
				{
					result = false;
				}
				return result;
			}

			public void Update(InteractionSystem interactionSystem)
			{
				if (!initiated)
				{
					return;
				}
				Vector3 vector = spherecastFrom.TransformDirection(raycastDirectionLocal);
				hit.point = spherecastFrom.position + vector;
				bool flag = FindWalls(vector);
				if (!inTouch)
				{
					if (flag && Time.time > nextSwitchTime)
					{
						interactionObject.transform.parent = null;
						interactionSystem.StartInteraction(effectorType, interactionObject, interrupt: true);
						nextSwitchTime = Time.time + minSwitchTime / interactionSystem.speed;
						targetPosition = hit.point;
						targetRotation = Quaternion.LookRotation(-hit.normal);
						interactionObject.transform.position = targetPosition;
						interactionObject.transform.rotation = targetRotation;
					}
				}
				else
				{
					if (!flag)
					{
						StopTouch(interactionSystem);
					}
					else if (!interactionSystem.IsPaused(effectorType) || sliding)
					{
						targetPosition = hit.point;
						targetRotation = Quaternion.LookRotation(-hit.normal);
					}
					if (Vector3.Distance(interactionObject.transform.position, hit.point) > releaseDistance)
					{
						if (flag)
						{
							targetPosition = hit.point;
							targetRotation = Quaternion.LookRotation(-hit.normal);
						}
						else
						{
							StopTouch(interactionSystem);
						}
					}
				}
				float b = ((!inTouch || (interactionSystem.IsPaused(effectorType) && interactionObject.transform.position == targetPosition)) ? 0f : 1f);
				speedF = Mathf.Lerp(speedF, b, Time.deltaTime * 3f * interactionSystem.speed);
				float t = Time.deltaTime * lerpSpeed * speedF * interactionSystem.speed;
				interactionObject.transform.position = Vector3.Lerp(interactionObject.transform.position, targetPosition, t);
				interactionObject.transform.rotation = Quaternion.Slerp(interactionObject.transform.rotation, targetRotation, t);
			}

			private void StopTouch(InteractionSystem interactionSystem)
			{
				interactionObject.transform.parent = interactionSystem.transform;
				nextSwitchTime = Time.time + minSwitchTime / interactionSystem.speed;
				if (interactionSystem.IsPaused(effectorType))
				{
					interactionSystem.ResumeInteraction(effectorType);
					return;
				}
				speedF = 0f;
				targetPosition = hit.point;
				targetRotation = Quaternion.LookRotation(-hit.normal);
			}

			private void OnInteractionStart(FullBodyBipedEffector effectorType, InteractionObject interactionObject)
			{
				if (effectorType == this.effectorType && !(interactionObject != this.interactionObject))
				{
					inTouch = true;
				}
			}

			private void OnInteractionResume(FullBodyBipedEffector effectorType, InteractionObject interactionObject)
			{
				if (effectorType == this.effectorType && !(interactionObject != this.interactionObject))
				{
					inTouch = false;
				}
			}

			private void OnInteractionStop(FullBodyBipedEffector effectorType, InteractionObject interactionObject)
			{
				if (effectorType == this.effectorType && !(interactionObject != this.interactionObject))
				{
					inTouch = false;
				}
			}

			public void Destroy(InteractionSystem interactionSystem)
			{
				if (initiated)
				{
					interactionSystem.OnInteractionStart = (InteractionSystem.InteractionDelegate)Delegate.Remove(interactionSystem.OnInteractionStart, new InteractionSystem.InteractionDelegate(OnInteractionStart));
					interactionSystem.OnInteractionResume = (InteractionSystem.InteractionDelegate)Delegate.Remove(interactionSystem.OnInteractionResume, new InteractionSystem.InteractionDelegate(OnInteractionResume));
					interactionSystem.OnInteractionStop = (InteractionSystem.InteractionDelegate)Delegate.Remove(interactionSystem.OnInteractionStop, new InteractionSystem.InteractionDelegate(OnInteractionStop));
				}
			}
		}

		public InteractionSystem interactionSystem;

		public EffectorLink[] effectorLinks;

		private void Start()
		{
			EffectorLink[] array = effectorLinks;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].Initiate(interactionSystem);
			}
		}

		private void FixedUpdate()
		{
			for (int i = 0; i < effectorLinks.Length; i++)
			{
				effectorLinks[i].Update(interactionSystem);
			}
		}

		private void OnDestroy()
		{
			if (interactionSystem != null)
			{
				for (int i = 0; i < effectorLinks.Length; i++)
				{
					effectorLinks[i].Destroy(interactionSystem);
				}
			}
		}
	}
	public class TransferMotion : MonoBehaviour
	{
		[Tooltip("The Transform to transfer motion to.")]
		public Transform to;

		[Tooltip("The amount of motion to transfer.")]
		[Range(0f, 1f)]
		public float transferMotion = 0.9f;

		private Vector3 lastPosition;

		private void OnEnable()
		{
			lastPosition = base.transform.position;
		}

		private void Update()
		{
			Vector3 vector = base.transform.position - lastPosition;
			to.position += vector * transferMotion;
			lastPosition = base.transform.position;
		}
	}
	public class TwoHandedProp : MonoBehaviour
	{
		[Tooltip("The left hand target parented to the right hand.")]
		public Transform leftHandTarget;

		private FullBodyBipedIK ik;

		private Vector3 targetPosRelativeToRight;

		private Quaternion targetRotRelativeToRight;

		private void Start()
		{
			ik = GetComponent<FullBodyBipedIK>();
			IKSolverFullBodyBiped solver = ik.solver;
			solver.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Combine(solver.OnPostUpdate, new IKSolver.UpdateDelegate(AfterFBBIK));
			ik.solver.leftHandEffector.positionWeight = 1f;
			ik.solver.rightHandEffector.positionWeight = 1f;
			if (ik.solver.rightHandEffector.target == null)
			{
				UnityEngine.Debug.LogError("Right Hand Effector needs a Target in this demo.");
			}
		}

		private void LateUpdate()
		{
			targetPosRelativeToRight = ik.references.rightHand.InverseTransformPoint(leftHandTarget.position);
			targetRotRelativeToRight = Quaternion.Inverse(ik.references.rightHand.rotation) * leftHandTarget.rotation;
			ik.solver.leftHandEffector.position = ik.solver.rightHandEffector.target.position + ik.solver.rightHandEffector.target.rotation * targetPosRelativeToRight;
			ik.solver.leftHandEffector.rotation = ik.solver.rightHandEffector.target.rotation * targetRotRelativeToRight;
		}

		private void AfterFBBIK()
		{
			ik.solver.leftHandEffector.bone.rotation = ik.solver.leftHandEffector.rotation;
			ik.solver.rightHandEffector.bone.rotation = ik.solver.rightHandEffector.rotation;
		}

		private void OnDestroy()
		{
			if (ik != null)
			{
				IKSolverFullBodyBiped solver = ik.solver;
				solver.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Remove(solver.OnPostUpdate, new IKSolver.UpdateDelegate(AfterFBBIK));
			}
		}
	}
	public class UserControlInteractions : UserControlThirdPerson
	{
		[SerializeField]
		private CharacterThirdPerson character;

		[SerializeField]
		private InteractionSystem interactionSystem;

		[SerializeField]
		private bool disableInputInInteraction = true;

		public float enableInputAtProgress = 0.8f;

		protected override void Update()
		{
			if (disableInputInInteraction && interactionSystem != null && (interactionSystem.inInteraction || interactionSystem.IsPaused()))
			{
				float minActiveProgress = interactionSystem.GetMinActiveProgress();
				if (minActiveProgress > 0f && minActiveProgress < enableInputAtProgress)
				{
					state.move = Vector3.zero;
					state.jump = false;
					return;
				}
			}
			base.Update();
		}

		private void OnGUI()
		{
			if (!character.onGround)
			{
				return;
			}
			if (interactionSystem.IsPaused() && interactionSystem.IsInSync())
			{
				GUILayout.Label("Press E to resume interaction");
				if (Input.GetKey(KeyCode.E))
				{
					interactionSystem.ResumeAll();
				}
				return;
			}
			int closestTriggerIndex = interactionSystem.GetClosestTriggerIndex();
			if (closestTriggerIndex != -1 && interactionSystem.TriggerEffectorsReady(closestTriggerIndex))
			{
				GUILayout.Label("Press E to start interaction");
				if (Input.GetKey(KeyCode.E))
				{
					interactionSystem.TriggerInteraction(closestTriggerIndex, interrupt: false);
				}
			}
		}
	}
	public class GrounderDemo : MonoBehaviour
	{
		public GameObject[] characters;

		private void OnGUI()
		{
			if (GUILayout.Button("Biped"))
			{
				Activate(0);
			}
			if (GUILayout.Button("Quadruped"))
			{
				Activate(1);
			}
			if (GUILayout.Button("Mech"))
			{
				Activate(2);
			}
			if (GUILayout.Button("Bot"))
			{
				Activate(3);
			}
		}

		public void Activate(int index)
		{
			for (int i = 0; i < characters.Length; i++)
			{
				characters[i].SetActive(i == index);
			}
		}
	}
	public class PlatformRotator : MonoBehaviour
	{
		public float maxAngle = 70f;

		public float switchRotationTime = 0.5f;

		public float random = 0.5f;

		public float rotationSpeed = 50f;

		public Vector3 movePosition;

		public float moveSpeed = 5f;

		public int characterLayer;

		private Quaternion defaultRotation;

		private Quaternion targetRotation;

		private Vector3 targetPosition;

		private Vector3 velocity;

		private Rigidbody r;

		private void Start()
		{
			defaultRotation = base.transform.rotation;
			targetPosition = base.transform.position + movePosition;
			r = GetComponent<Rigidbody>();
			StartCoroutine(SwitchRotation());
		}

		private void FixedUpdate()
		{
			r.MovePosition(Vector3.SmoothDamp(r.position, targetPosition, ref velocity, 1f, moveSpeed));
			if (Vector3.Distance(GetComponent<Rigidbody>().position, targetPosition) < 0.1f)
			{
				movePosition = -movePosition;
				targetPosition += movePosition;
			}
			r.MoveRotation(Quaternion.RotateTowards(r.rotation, targetRotation, rotationSpeed * Time.deltaTime));
		}

		private IEnumerator SwitchRotation()
		{
			while (true)
			{
				float angle = UnityEngine.Random.Range(0f - maxAngle, maxAngle);
				Vector3 onUnitSphere = UnityEngine.Random.onUnitSphere;
				targetRotation = Quaternion.AngleAxis(angle, onUnitSphere) * defaultRotation;
				yield return Yield.WaitSeconds(switchRotationTime + UnityEngine.Random.value * random);
			}
		}

		private void OnCollisionEnter(Collision collision)
		{
			if (collision.gameObject.layer == characterLayer)
			{
				CharacterThirdPerson component = collision.gameObject.GetComponent<CharacterThirdPerson>();
				if (!(component == null) && component.smoothPhysics)
				{
					component.smoothPhysics = false;
				}
			}
		}

		private void OnCollisionExit(Collision collision)
		{
			if (collision.gameObject.layer == characterLayer)
			{
				CharacterThirdPerson component = collision.gameObject.GetComponent<CharacterThirdPerson>();
				if (!(component == null))
				{
					component.smoothPhysics = true;
				}
			}
		}
	}
	public class BendGoal : MonoBehaviour
	{
		public LimbIK limbIK;

		[Range(0f, 1f)]
		public float weight = 1f;

		private void Start()
		{
			UnityEngine.Debug.Log("BendGoal is deprecated, you can now a bend goal from the custom inspector of the LimbIK component.");
		}

		private void LateUpdate()
		{
			if (!(limbIK == null))
			{
				limbIK.solver.SetBendGoalPosition(base.transform.position, weight);
			}
		}
	}
	public class Turret : MonoBehaviour
	{
		[Serializable]
		public class Part
		{
			public Transform transform;

			private RotationLimit rotationLimit;

			public void AimAt(Transform target)
			{
				transform.LookAt(target.position, transform.up);
				if (rotationLimit == null)
				{
					rotationLimit = transform.GetComponent<RotationLimit>();
					rotationLimit.Disable();
				}
				rotationLimit.Apply();
			}
		}

		public Transform target;

		public Part[] parts;

		private void Update()
		{
			Part[] array = parts;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].AimAt(target);
			}
		}
	}
	public class VRIKPlatform : MonoBehaviour
	{
		public VRIK ik;

		private Vector3 lastPosition;

		private Quaternion lastRotation = Quaternion.identity;

		private void Start()
		{
			lastPosition = base.transform.position;
			lastRotation = base.transform.rotation;
		}

		private void Update()
		{
			ik.solver.AddPlatformMotion(base.transform.position - lastPosition, base.transform.rotation * Quaternion.Inverse(lastRotation), base.transform.position);
			lastRotation = base.transform.rotation;
			lastPosition = base.transform.position;
		}
	}
	public abstract class CharacterAnimationBase : MonoBehaviour
	{
		public bool smoothFollow = true;

		public float smoothFollowSpeed = 20f;

		private Vector3 lastPosition;

		private Vector3 localPosition;

		private Quaternion localRotation;

		private Quaternion lastRotation;

		public virtual bool animationGrounded => true;

		public virtual Vector3 GetPivotPoint()
		{
			return base.transform.position;
		}

		public float GetAngleFromForward(Vector3 worldDirection)
		{
			Vector3 vector = base.transform.InverseTransformDirection(worldDirection);
			return Mathf.Atan2(vector.x, vector.z) * 57.29578f;
		}

		protected virtual void Start()
		{
			if (base.transform.parent.GetComponent<CharacterBase>() == null)
			{
				UnityEngine.Debug.LogWarning("Animation controllers should be parented to character controllers!", base.transform);
			}
			lastPosition = base.transform.position;
			localPosition = base.transform.parent.InverseTransformPoint(base.transform.position);
			lastRotation = base.transform.rotation;
			localRotation = Quaternion.Inverse(base.transform.parent.rotation) * base.transform.rotation;
		}

		protected virtual void LateUpdate()
		{
			if (smoothFollow)
			{
				base.transform.position = Vector3.Lerp(lastPosition, base.transform.parent.TransformPoint(localPosition), Time.deltaTime * smoothFollowSpeed);
				base.transform.rotation = Quaternion.Lerp(lastRotation, base.transform.parent.rotation * localRotation, Time.deltaTime * smoothFollowSpeed);
			}
			lastPosition = base.transform.position;
			lastRotation = base.transform.rotation;
		}
	}
	[RequireComponent(typeof(Animator))]
	public class CharacterAnimationSimple : CharacterAnimationBase
	{
		[SerializeField]
		private CharacterThirdPerson characterController;

		[SerializeField]
		private float pivotOffset;

		[SerializeField]
		private AnimationCurve moveSpeed;

		private Animator animator;

		protected override void Start()
		{
			base.Start();
			animator = GetComponentInChildren<Animator>();
		}

		public override Vector3 GetPivotPoint()
		{
			if (pivotOffset == 0f)
			{
				return base.transform.position;
			}
			return base.transform.position + base.transform.forward * pivotOffset;
		}

		private void Update()
		{
			float num = moveSpeed.Evaluate(characterController.animState.moveDirection.z);
			animator.SetFloat("Speed", num);
			characterController.Move(characterController.transform.forward * Time.deltaTime * num, Quaternion.identity);
		}
	}
	[RequireComponent(typeof(Animator))]
	public class CharacterAnimationThirdPerson : CharacterAnimationBase
	{
		public CharacterThirdPerson characterController;

		[SerializeField]
		private float turnSensitivity = 0.2f;

		[SerializeField]
		private float turnSpeed = 5f;

		[SerializeField]
		private float runCycleLegOffset = 0.2f;

		[Range(0.1f, 3f)]
		[SerializeField]
		private float animSpeedMultiplier = 1f;

		protected Animator animator;

		private Vector3 lastForward;

		private const string groundedDirectional = "Grounded Directional";

		private const string groundedStrafe = "Grounded Strafe";

		public override bool animationGrounded
		{
			get
			{
				if (!animator.GetCurrentAnimatorStateInfo(0).IsName("Grounded Directional"))
				{
					return animator.GetCurrentAnimatorStateInfo(0).IsName("Grounded Strafe");
				}
				return true;
			}
		}

		protected override void Start()
		{
			base.Start();
			animator = GetComponent<Animator>();
			lastForward = base.transform.forward;
		}

		public override Vector3 GetPivotPoint()
		{
			return animator.pivotPosition;
		}

		protected virtual void Update()
		{
			if (Time.deltaTime != 0f)
			{
				if (characterController.animState.jump)
				{
					float value = (float)((Mathf.Repeat(animator.GetCurrentAnimatorStateInfo(0).normalizedTime + runCycleLegOffset, 1f) < 0f) ? 1 : (-1)) * characterController.animState.moveDirection.z;
					animator.SetFloat("JumpLeg", value);
				}
				float num = 0f - GetAngleFromForward(lastForward);
				lastForward = base.transform.forward;
				num *= turnSensitivity * 0.01f;
				num = Mathf.Clamp(num / Time.deltaTime, -1f, 1f);
				animator.SetFloat("Turn", Mathf.Lerp(animator.GetFloat("Turn"), num, Time.deltaTime * turnSpeed));
				animator.SetFloat("Forward", characterController.animState.moveDirection.z);
				animator.SetFloat("Right", characterController.animState.moveDirection.x);
				animator.SetBool("Crouch", characterController.animState.crouch);
				animator.SetBool("OnGround", characterController.animState.onGround);
				animator.SetBool("IsStrafing", characterController.animState.isStrafing);
				if (!characterController.animState.onGround)
				{
					animator.SetFloat("Jump", characterController.animState.yVelocity);
				}
				if (characterController.animState.onGround && characterController.animState.moveDirection.z > 0f)
				{
					animator.speed = animSpeedMultiplier;
				}
				else
				{
					animator.speed = 1f;
				}
			}
		}

		private void OnAnimatorMove()
		{
			characterController.Move(animator.deltaPosition, animator.deltaRotation);
		}
	}
	[RequireComponent(typeof(Rigidbody))]
	[RequireComponent(typeof(CapsuleCollider))]
	public abstract class CharacterBase : MonoBehaviour
	{
		[Header("Base Parameters")]
		[Tooltip("If specified, will use the direction from the character to this Transform as the gravity vector instead of Physics.gravity. Physics.gravity.magnitude will be used as the magnitude of the gravity vector.")]
		public Transform gravityTarget;

		[Tooltip("Multiplies gravity applied to the character even if 'Individual Gravity' is unchecked.")]
		[SerializeField]
		protected float gravityMultiplier = 2f;

		[SerializeField]
		protected float airborneThreshold = 0.6f;

		[SerializeField]
		private float slopeStartAngle = 50f;

		[SerializeField]
		private float slopeEndAngle = 85f;

		[SerializeField]
		private float spherecastRadius = 0.1f;

		[SerializeField]
		private LayerMask groundLayers;

		private PhysicMaterial zeroFrictionMaterial;

		private PhysicMaterial highFrictionMaterial;

		protected Rigidbody r;

		protected const float half = 0.5f;

		protected float originalHeight;

		protected Vector3 originalCenter;

		protected CapsuleCollider capsule;

		public abstract void Move(Vector3 deltaPosition, Quaternion deltaRotation);

		protected Vector3 GetGravity()
		{
			if (gravityTarget != null)
			{
				return (gravityTarget.position - base.transform.position).normalized * Physics.gravity.magnitude;
			}
			return Physics.gravity;
		}

		protected virtual void Start()
		{
			capsule = GetComponent<Collider>() as CapsuleCollider;
			r = GetComponent<Rigidbody>();
			originalHeight = capsule.height;
			originalCenter = capsule.center;
			zeroFrictionMaterial = new PhysicMaterial();
			zeroFrictionMaterial.dynamicFriction = 0f;
			zeroFrictionMaterial.staticFriction = 0f;
			zeroFrictionMaterial.frictionCombine = PhysicMaterialCombine.Minimum;
			zeroFrictionMaterial.bounciness = 0f;
			zeroFrictionMaterial.bounceCombine = PhysicMaterialCombine.Minimum;
			highFrictionMaterial = new PhysicMaterial();
			r.constraints = RigidbodyConstraints.FreezeRotation;
		}

		protected virtual RaycastHit GetSpherecastHit()
		{
			Vector3 up = base.transform.up;
			Ray ray = new Ray(r.position + up * airborneThreshold, -up);
			RaycastHit hitInfo = new RaycastHit
			{
				point = base.transform.position - base.transform.transform.up * airborneThreshold,
				normal = base.transform.up
			};
			Physics.SphereCast(ray, spherecastRadius, out hitInfo, airborneThreshold * 2f, groundLayers);
			return hitInfo;
		}

		public float GetAngleFromForward(Vector3 worldDirection)
		{
			Vector3 vector = base.transform.InverseTransformDirection(worldDirection);
			return Mathf.Atan2(vector.x, vector.z) * 57.29578f;
		}

		protected void RigidbodyRotateAround(Vector3 point, Vector3 axis, float angle)
		{
			Quaternion quaternion = Quaternion.AngleAxis(angle, axis);
			Vector3 vector = base.transform.position - point;
			r.MovePosition(point + quaternion * vector);
			r.MoveRotation(quaternion * base.transform.rotation);
		}

		protected void ScaleCapsule(float mlp)
		{
			if (capsule.height != originalHeight * mlp)
			{
				capsule.height = Mathf.MoveTowards(capsule.height, originalHeight * mlp, Time.deltaTime * 4f);
				capsule.center = Vector3.MoveTowards(capsule.center, originalCenter * mlp, Time.deltaTime * 2f);
			}
		}

		protected void HighFriction()
		{
			capsule.material = highFrictionMaterial;
		}

		protected void ZeroFriction()
		{
			capsule.material = zeroFrictionMaterial;
		}

		protected float GetSlopeDamper(Vector3 velocity, Vector3 groundNormal)
		{
			float num = 90f - Vector3.Angle(velocity, groundNormal);
			num -= slopeStartAngle;
			float num2 = slopeEndAngle - slopeStartAngle;
			return 1f - Mathf.Clamp(num / num2, 0f, 1f);
		}
	}
	public class CharacterThirdPerson : CharacterBase
	{
		[Serializable]
		public enum MoveMode
		{
			Directional,
			Strafe
		}

		public struct AnimState
		{
			public Vector3 moveDirection;

			public bool jump;

			public bool crouch;

			public bool onGround;

			public bool isStrafing;

			public float yVelocity;
		}

		[Header("References")]
		public CharacterAnimationBase characterAnimation;

		public UserControlThirdPerson userControl;

		public CameraController cam;

		[Header("Movement")]
		public MoveMode moveMode;

		public bool smoothPhysics = true;

		public float smoothAccelerationTime = 0.2f;

		public float linearAccelerationSpeed = 3f;

		public float platformFriction = 7f;

		public float groundStickyEffect = 4f;

		public float maxVerticalVelocityOnGround = 3f;

		public float velocityToGroundTangentWeight;

		[Header("Rotation")]
		public bool lookInCameraDirection;

		public float turnSpeed = 5f;

		public float stationaryTurnSpeedMlp = 1f;

		[Header("Jumping and Falling")]
		public float airSpeed = 6f;

		public float airControl = 2f;

		public float jumpPower = 12f;

		public float jumpRepeatDelayTime;

		[Header("Wall Running")]
		[SerializeField]
		private LayerMask wallRunLayers;

		public float wallRunMaxLength = 1f;

		public float wallRunMinMoveMag = 0.6f;

		public float wallRunMinVelocityY = -1f;

		public float wallRunRotationSpeed = 1.5f;

		public float wallRunMaxRotationAngle = 70f;

		public float wallRunWeightSpeed = 5f;

		[Header("Crouching")]
		public float crouchCapsuleScaleMlp = 0.6f;

		public AnimState animState;

		protected Vector3 moveDirection;

		private Animator animator;

		private Vector3 normal;

		private Vector3 platformVelocity;

		private Vector3 platformAngularVelocity;

		private RaycastHit hit;

		private float jumpLeg;

		private float jumpEndTime;

		private float forwardMlp;

		private float groundDistance;

		private float lastAirTime;

		private float stickyForce;

		private Vector3 wallNormal = Vector3.up;

		private Vector3 moveDirectionVelocity;

		private float wallRunWeight;

		private float lastWallRunWeight;

		private Vector3 fixedDeltaPosition;

		private Quaternion fixedDeltaRotation;

		private bool fixedFrame;

		private float wallRunEndTime;

		private Vector3 gravity;

		private Vector3 verticalVelocity;

		private float velocityY;

		public bool onGround { get; private set; }

		protected override void Start()
		{
			base.Start();
			animator = GetComponent<Animator>();
			if (animator == null)
			{
				animator = characterAnimation.GetComponent<Animator>();
			}
			wallNormal = -gravity.normalized;
			onGround = true;
			animState.onGround = true;
			if (cam != null)
			{
				cam.enabled = false;
			}
		}

		private void OnAnimatorMove()
		{
			Move(animator.deltaPosition, animator.deltaRotation);
		}

		public override void Move(Vector3 deltaPosition, Quaternion deltaRotation)
		{
			fixedDeltaPosition += deltaPosition;
			fixedDeltaRotation *= deltaRotation;
		}

		private void FixedUpdate()
		{
			gravity = GetGravity();
			verticalVelocity = V3Tools.ExtractVertical(r.velocity, gravity, 1f);
			velocityY = verticalVelocity.magnitude;
			if (Vector3.Dot(verticalVelocity, gravity) > 0f)
			{
				velocityY = 0f - velocityY;
			}
			if (animator != null && animator.updateMode == AnimatorUpdateMode.AnimatePhysics)
			{
				smoothPhysics = false;
				characterAnimation.smoothFollow = false;
			}
			r.interpolation = (smoothPhysics ? RigidbodyInterpolation.Interpolate : RigidbodyInterpolation.None);
			characterAnimation.smoothFollow = smoothPhysics;
			MoveFixed(fixedDeltaPosition);
			fixedDeltaPosition = Vector3.zero;
			base.transform.rotation *= fixedDeltaRotation;
			fixedDeltaRotation = Quaternion.identity;
			Rotate();
			GroundCheck();
			if (userControl.state.move == Vector3.zero && groundDistance < airborneThreshold * 0.5f)
			{
				HighFriction();
			}
			else
			{
				ZeroFriction();
			}
			bool flag = onGround && userControl.state.move == Vector3.zero && r.velocity.magnitude < 0.5f && groundDistance < airborneThreshold * 0.5f;
			if (gravityTarget != null)
			{
				r.useGravity = false;
				if (!flag)
				{
					r.AddForce(gravity);
				}
			}
			if (flag)
			{
				r.useGravity = false;
				r.velocity = Vector3.zero;
			}
			else if (gravityTarget == null)
			{
				r.useGravity = true;
			}
			if (onGround)
			{
				animState.jump = Jump();
			}
			else
			{
				r.AddForce(gravity * gravityMultiplier);
			}
			ScaleCapsule(userControl.state.crouch ? crouchCapsuleScaleMlp : 1f);
			fixedFrame = true;
		}

		protected virtual void Update()
		{
			animState.onGround = onGround;
			animState.moveDirection = GetMoveDirection();
			animState.yVelocity = Mathf.Lerp(animState.yVelocity, velocityY, Time.deltaTime * 10f);
			animState.crouch = userControl.state.crouch;
			animState.isStrafing = moveMode == MoveMode.Strafe;
		}

		protected virtual void LateUpdate()
		{
			if (!(cam == null))
			{
				cam.UpdateInput();
				if (fixedFrame || r.interpolation != 0)
				{
					cam.UpdateTransform((r.interpolation == RigidbodyInterpolation.None) ? Time.fixedDeltaTime : Time.deltaTime);
					fixedFrame = false;
				}
			}
		}

		private void MoveFixed(Vector3 deltaPosition)
		{
			WallRun();
			Vector3 vector = deltaPosition / Time.deltaTime;
			vector += V3Tools.ExtractHorizontal(platformVelocity, gravity, 1f);
			if (onGround)
			{
				if (velocityToGroundTangentWeight > 0f)
				{
					Quaternion b = Quaternion.FromToRotation(base.transform.up, normal);
					vector = Quaternion.Lerp(Quaternion.identity, b, velocityToGroundTangentWeight) * vector;
				}
			}
			else
			{
				Vector3 b2 = V3Tools.ExtractHorizontal(userControl.state.move * airSpeed, gravity, 1f);
				vector = Vector3.Lerp(r.velocity, b2, Time.deltaTime * airControl);
			}
			if (onGround && Time.time > jumpEndTime)
			{
				r.velocity -= base.transform.up * stickyForce * Time.deltaTime;
			}
			Vector3 vector2 = V3Tools.ExtractVertical(r.velocity, gravity, 1f);
			Vector3 vector3 = V3Tools.ExtractHorizontal(vector, gravity, 1f);
			if (onGround && Vector3.Dot(vector2, gravity) < 0f)
			{
				vector2 = Vector3.ClampMagnitude(vector2, maxVerticalVelocityOnGround);
			}
			r.velocity = vector3 + vector2;
			float b3 = ((!onGround) ? 1f : GetSlopeDamper(-deltaPosition / Time.deltaTime, normal));
			forwardMlp = Mathf.Lerp(forwardMlp, b3, Time.deltaTime * 5f);
		}

		private void WallRun()
		{
			bool flag = CanWallRun();
			if (wallRunWeight > 0f && !flag)
			{
				wallRunEndTime = Time.time;
			}
			if (Time.time < wallRunEndTime + 0.5f)
			{
				flag = false;
			}
			wallRunWeight = Mathf.MoveTowards(wallRunWeight, flag ? 1f : 0f, Time.deltaTime * wallRunWeightSpeed);
			if (wallRunWeight <= 0f && lastWallRunWeight > 0f)
			{
				Vector3 forward = V3Tools.ExtractHorizontal(base.transform.forward, gravity, 1f);
				base.transform.rotation = Quaternion.LookRotation(forward, -gravity);
				wallNormal = -gravity.normalized;
			}
			lastWallRunWeight = wallRunWeight;
			if (!(wallRunWeight <= 0f))
			{
				if (onGround && velocityY < 0f)
				{
					r.velocity = V3Tools.ExtractHorizontal(r.velocity, gravity, 1f);
				}
				Vector3 vector = V3Tools.ExtractHorizontal(base.transform.forward, gravity, 1f);
				RaycastHit hitInfo = default(RaycastHit);
				hitInfo.normal = -gravity.normalized;
				Physics.Raycast(onGround ? base.transform.position : capsule.bounds.center, vector, out hitInfo, 3f, wallRunLayers);
				wallNormal = Vector3.Lerp(wallNormal, hitInfo.normal, Time.deltaTime * wallRunRotationSpeed);
				wallNormal = Vector3.RotateTowards(-gravity.normalized, wallNormal, wallRunMaxRotationAngle * ((float)Math.PI / 180f), 0f);
				Vector3 tangent = base.transform.forward;
				Vector3 vector2 = wallNormal;
				Vector3.OrthoNormalize(ref vector2, ref tangent);
				base.transform.rotation = Quaternion.Slerp(Quaternion.LookRotation(vector, -gravity), Quaternion.LookRotation(tangent, wallNormal), wallRunWeight);
			}
		}

		private bool CanWallRun()
		{
			if (Time.time < jumpEndTime - 0.1f)
			{
				return false;
			}
			if (Time.time > jumpEndTime - 0.1f + wallRunMaxLength)
			{
				return false;
			}
			if (velocityY < wallRunMinVelocityY)
			{
				return false;
			}
			if (userControl.state.move.magnitude < wallRunMinMoveMag)
			{
				return false;
			}
			return true;
		}

		private Vector3 GetMoveDirection()
		{
			switch (moveMode)
			{
			case MoveMode.Directional:
				moveDirection = Vector3.SmoothDamp(moveDirection, new Vector3(0f, 0f, userControl.state.move.magnitude), ref moveDirectionVelocity, smoothAccelerationTime);
				moveDirection = Vector3.MoveTowards(moveDirection, new Vector3(0f, 0f, userControl.state.move.magnitude), Time.deltaTime * linearAccelerationSpeed);
				return moveDirection * forwardMlp;
			case MoveMode.Strafe:
				moveDirection = Vector3.SmoothDamp(moveDirection, userControl.state.move, ref moveDirectionVelocity, smoothAccelerationTime);
				moveDirection = Vector3.MoveTowards(moveDirection, userControl.state.move, Time.deltaTime * linearAccelerationSpeed);
				return base.transform.InverseTransformDirection(moveDirection);
			default:
				return Vector3.zero;
			}
		}

		protected virtual void Rotate()
		{
			if (gravityTarget != null)
			{
				base.transform.rotation = Quaternion.FromToRotation(base.transform.up, base.transform.position - gravityTarget.position) * base.transform.rotation;
			}
			if (platformAngularVelocity != Vector3.zero)
			{
				base.transform.rotation = Quaternion.Euler(platformAngularVelocity) * base.transform.rotation;
			}
			float num = GetAngleFromForward(GetForwardDirection());
			if (userControl.state.move == Vector3.zero)
			{
				num *= (1.01f - Mathf.Abs(num) / 180f) * stationaryTurnSpeedMlp;
			}
			RigidbodyRotateAround(characterAnimation.GetPivotPoint(), base.transform.up, num * Time.deltaTime * turnSpeed);
		}

		private Vector3 GetForwardDirection()
		{
			bool flag = userControl.state.move != Vector3.zero;
			switch (moveMode)
			{
			case MoveMode.Directional:
				if (flag)
				{
					return userControl.state.move;
				}
				if (!lookInCameraDirection)
				{
					return base.transform.forward;
				}
				return userControl.state.lookPos - r.position;
			case MoveMode.Strafe:
				if (flag)
				{
					return userControl.state.lookPos - r.position;
				}
				if (!lookInCameraDirection)
				{
					return base.transform.forward;
				}
				return userControl.state.lookPos - r.position;
			default:
				return Vector3.zero;
			}
		}

		protected virtual bool Jump()
		{
			if (!userControl.state.jump)
			{
				return false;
			}
			if (userControl.state.crouch)
			{
				return false;
			}
			if (!characterAnimation.animationGrounded)
			{
				return false;
			}
			if (Time.time < lastAirTime + jumpRepeatDelayTime)
			{
				return false;
			}
			onGround = false;
			jumpEndTime = Time.time + 0.1f;
			Vector3 velocity = userControl.state.move * airSpeed;
			r.velocity = velocity;
			r.velocity += base.transform.up * jumpPower;
			return true;
		}

		private void GroundCheck()
		{
			Vector3 b = Vector3.zero;
			platformAngularVelocity = Vector3.zero;
			float num = 0f;
			hit = GetSpherecastHit();
			normal = base.transform.up;
			groundDistance = Vector3.Project(r.position - hit.point, base.transform.up).magnitude;
			if (Time.time > jumpEndTime && velocityY < jumpPower * 0.5f)
			{
				bool num2 = onGround;
				onGround = false;
				float num3 = ((!num2) ? (airborneThreshold * 0.5f) : airborneThreshold);
				float magnitude = V3Tools.ExtractHorizontal(r.velocity, gravity, 1f).magnitude;
				if (groundDistance < num3)
				{
					num = groundStickyEffect * magnitude * num3;
					if (hit.rigidbody != null)
					{
						b = hit.rigidbody.GetPointVelocity(hit.point);
						platformAngularVelocity = Vector3.Project(hit.rigidbody.angularVelocity, base.transform.up);
					}
					onGround = true;
				}
			}
			platformVelocity = Vector3.Lerp(platformVelocity, b, Time.deltaTime * platformFriction);
			stickyForce = num;
			if (!onGround)
			{
				lastAirTime = Time.time;
			}
		}
	}
	[RequireComponent(typeof(Animator))]
	public class SimpleLocomotion : MonoBehaviour
	{
		[Serializable]
		public enum RotationMode
		{
			Smooth,
			Linear
		}

		[Tooltip("The component that updates the camera.")]
		[SerializeField]
		private CameraController cameraController;

		[Tooltip("Acceleration of movement.")]
		[SerializeField]
		private float accelerationTime = 0.2f;

		[Tooltip("Turning speed.")]
		[SerializeField]
		private float turnTime = 0.2f;

		[Tooltip("If true, will run on left shift, if not will walk on left shift.")]
		[SerializeField]
		private bool walkByDefault = true;

		[Tooltip("Smooth or linear rotation.")]
		[SerializeField]
		private RotationMode rotationMode;

		[Tooltip("Procedural motion speed (if not using root motion).")]
		[SerializeField]
		private float moveSpeed = 3f;

		private Animator animator;

		private float speed;

		private float angleVel;

		private float speedVel;

		private Vector3 linearTargetDirection;

		private CharacterController characterController;

		public bool isGrounded { get; private set; }

		private void Start()
		{
			animator = GetComponent<Animator>();
			characterController = GetComponent<CharacterController>();
			cameraController.enabled = false;
		}

		private void Update()
		{
			isGrounded = base.transform.position.y < 0.1f;
			Rotate();
			Move();
		}

		private void LateUpdate()
		{
			cameraController.UpdateInput();
			cameraController.UpdateTransform();
		}

		private void Rotate()
		{
			if (!isGrounded)
			{
				return;
			}
			Vector3 inputVector = GetInputVector();
			if (inputVector == Vector3.zero)
			{
				return;
			}
			Vector3 forward = base.transform.forward;
			switch (rotationMode)
			{
			case RotationMode.Smooth:
			{
				Vector3 vector = cameraController.transform.rotation * inputVector;
				float current = Mathf.Atan2(forward.x, forward.z) * 57.29578f;
				float target = Mathf.Atan2(vector.x, vector.z) * 57.29578f;
				float angle = Mathf.SmoothDampAngle(current, target, ref angleVel, turnTime);
				base.transform.rotation = Quaternion.AngleAxis(angle, Vector3.up);
				break;
			}
			case RotationMode.Linear:
			{
				Vector3 inputVectorRaw = GetInputVectorRaw();
				if (inputVectorRaw != Vector3.zero)
				{
					linearTargetDirection = cameraController.transform.rotation * inputVectorRaw;
				}
				forward = Vector3.RotateTowards(forward, linearTargetDirection, Time.deltaTime * (1f / turnTime), 1f);
				forward.y = 0f;
				base.transform.rotation = Quaternion.LookRotation(forward);
				break;
			}
			}
		}

		private void Move()
		{
			float target = ((!walkByDefault) ? (Input.GetKey(KeyCode.LeftShift) ? 0.5f : 1f) : (Input.GetKey(KeyCode.LeftShift) ? 1f : 0.5f));
			speed = Mathf.SmoothDamp(speed, target, ref speedVel, accelerationTime);
			float num = GetInputVector().magnitude * speed;
			animator.SetFloat("Speed", num);
			if (!animator.hasRootMotion && isGrounded)
			{
				Vector3 vector = base.transform.forward * num * moveSpeed;
				if (characterController != null)
				{
					characterController.SimpleMove(vector);
				}
				else
				{
					base.transform.position += vector * Time.deltaTime;
				}
			}
		}

		private Vector3 GetInputVector()
		{
			Vector3 result = new Vector3(Input.GetAxis("Horizontal"), 0f, Input.GetAxis("Vertical"));
			result.z += Mathf.Abs(result.x) * 0.05f;
			result.x -= Mathf.Abs(result.z) * 0.05f;
			return result;
		}

		private Vector3 GetInputVectorRaw()
		{
			return new Vector3(Input.GetAxisRaw("Horizontal"), 0f, Input.GetAxisRaw("Vertical"));
		}
	}
	public class UserControlAI : UserControlThirdPerson
	{
		public Transform moveTarget;

		public float stoppingDistance = 0.5f;

		public float stoppingThreshold = 1.5f;

		protected override void Update()
		{
			float num = (walkByDefault ? 0.5f : 1f);
			Vector3 tangent = moveTarget.position - base.transform.position;
			float magnitude = tangent.magnitude;
			Vector3 normal = base.transform.up;
			Vector3.OrthoNormalize(ref normal, ref tangent);
			float num2 = ((state.move != Vector3.zero) ? stoppingDistance : (stoppingDistance * stoppingThreshold));
			state.move = ((magnitude > num2) ? (tangent * num) : Vector3.zero);
		}
	}
	public class UserControlThirdPerson : MonoBehaviour
	{
		public struct State
		{
			public Vector3 move;

			public Vector3 lookPos;

			public bool crouch;

			public bool jump;

			public int actionIndex;
		}

		public bool walkByDefault;

		public bool canCrouch = true;

		public bool canJump = true;

		public State state;

		protected Transform cam;

		private void Start()
		{
			cam = Camera.main.transform;
		}

		protected virtual void Update()
		{
			state.crouch = canCrouch && Input.GetKey(KeyCode.C);
			state.jump = canJump && Input.GetButton("Jump");
			float axisRaw = Input.GetAxisRaw("Horizontal");
			float axisRaw2 = Input.GetAxisRaw("Vertical");
			Vector3 tangent = cam.rotation * new Vector3(axisRaw, 0f, axisRaw2).normalized;
			if (tangent != Vector3.zero)
			{
				Vector3 normal = base.transform.up;
				Vector3.OrthoNormalize(ref normal, ref tangent);
				state.move = tangent;
			}
			else
			{
				state.move = Vector3.zero;
			}
			bool key = Input.GetKey(KeyCode.LeftShift);
			float num = ((!walkByDefault) ? (key ? 0.5f : 1f) : (key ? 1f : 0.5f));
			state.move *= num;
			state.lookPos = base.transform.position + cam.forward * 100f;
		}
	}
	public class ApplicationQuit : MonoBehaviour
	{
		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.Q) || Input.GetKeyDown(KeyCode.Escape))
			{
				Application.Quit();
			}
		}
	}
	public class SlowMo : MonoBehaviour
	{
		[SerializeField]
		private KeyCode[] keyCodes;

		[SerializeField]
		private bool mouse0;

		[SerializeField]
		private bool mouse1;

		[SerializeField]
		private float slowMoTimeScale = 0.3f;

		private void Update()
		{
			Time.timeScale = (IsSlowMotion() ? slowMoTimeScale : 1f);
		}

		private bool IsSlowMotion()
		{
			if (mouse0 && Input.GetMouseButton(0))
			{
				return true;
			}
			if (mouse1 && Input.GetMouseButton(1))
			{
				return true;
			}
			for (int i = 0; i < keyCodes.Length; i++)
			{
				if (Input.GetKey(keyCodes[i]))
				{
					return true;
				}
			}
			return false;
		}
	}
}
namespace RogoDigital
{
	[AddComponentMenu("Rogo Digital/Eye Controller")]
	public class EyeController : BlendSystemUser
	{
		public enum ControlMode
		{
			Classic,
			PoseBased
		}

		public enum Axis
		{
			X_Positive,
			X_Negative,
			Y_Positive,
			Y_Negative,
			Z_Positive,
			Z_Negative
		}

		public class BoneShapeInfo
		{
			private Transform bone;

			private Vector3 m_storedPosition;

			private Quaternion m_storedRotation;

			public Vector3 targetPosition;

			public Quaternion targetRotation;

			public Vector3 storedPosition
			{
				get
				{
					return m_storedPosition;
				}
				set
				{
					m_storedPosition = value;
					bone.localPosition = value;
				}
			}

			public Quaternion storedRotation
			{
				get
				{
					return m_storedRotation;
				}
				set
				{
					m_storedRotation = value;
					bone.localRotation = value;
				}
			}

			public BoneShapeInfo(BoneShape boneShape)
			{
				bone = boneShape.bone;
				m_storedPosition = boneShape.neutralPosition;
				m_storedRotation = Quaternion.Euler(boneShape.neutralRotation);
			}
		}

		public bool blinkingEnabled;

		public ControlMode blinkingControlMode;

		public Shape blinkingShape;

		[FormerlySerializedAs("leftEyeBlinkBlendshape")]
		public int leftEyeBlinkBlendable;

		[FormerlySerializedAs("rightEyeBlinkBlendshape")]
		public int rightEyeBlinkBlendable = 1;

		public float minimumBlinkGap = 1f;

		public float maximumBlinkGap = 4f;

		[FormerlySerializedAs("blinkSpeed")]
		public float blinkDuration = 0.14f;

		public bool randomLookingEnabled;

		public ControlMode lookingControlMode;

		public Shape lookingUpShape;

		public Shape lookingDownShape;

		public Shape lookingLeftShape;

		public Shape lookingRightShape;

		[SerializeField]
		[FormerlySerializedAs("leftEyeLookAtBone")]
		private Transform _leftEyeLookAtBone;

		[SerializeField]
		[FormerlySerializedAs("rightEyeLookAtBone")]
		private Transform _rightEyeLookAtBone;

		public Vector2 eyeRotationRangeX = new Vector2(-6.5f, 6.5f);

		public Vector2 eyeRotationRangeY = new Vector2(-17.2f, 17.2f);

		public Vector3 eyeLookOffset;

		public Axis eyeForwardAxis = Axis.Z_Positive;

		public float eyeTurnSpeed = 18f;

		public float minimumChangeDirectionGap = 2f;

		public float maximumChangeDirectionGap = 10f;

		public bool targetEnabled;

		public bool autoTarget;

		public string autoTargetTag = "EyeControllerTarget";

		public float autoTargetDistance = 10f;

		public Transform viewTarget;

		public float targetWeight = 1f;

		public bool boneUpdateAnimation;

		private float blinkTimer;

		private bool blinking;

		private bool _keepEyesClosed;

		private bool _asyncBlending;

		private Transform leftEyeDummy;

		private Transform rightEyeDummy;

		private Quaternion leftRotation;

		private Quaternion rightRotation;

		private Vector3[] axisOffsets = new Vector3[6]
		{
			new Vector3(0f, -90f, 0f),
			new Vector3(0f, 90f, 0f),
			new Vector3(90f, 0f, 0f),
			new Vector3(-90f, 0f, 0f),
			new Vector3(0f, 0f, 0f),
			new Vector3(0f, 180f, 0f)
		};

		private float lookTimer;

		private Quaternion randomAngle;

		private Vector2 randomBlend;

		private Transform target;

		private Quaternion leftTargetAngle;

		private Quaternion rightTargetAngle;

		private Transform[] markedTargets;

		private Dictionary<Transform, BoneShapeInfo> boneShapes;

		public bool keepEyesClosed
		{
			get
			{
				return _keepEyesClosed;
			}
			set
			{
				if (value)
				{
					if (_keepEyesClosed != value)
					{
						StartCoroutine(CloseEyes());
					}
				}
				else if (_keepEyesClosed != value)
				{
					StartCoroutine(OpenEyes());
				}
				_keepEyesClosed = value;
			}
		}

		public Transform LeftEyeLookAtBone
		{
			get
			{
				return _leftEyeLookAtBone;
			}
			set
			{
				if (!(_leftEyeLookAtBone == value))
				{
					_leftEyeLookAtBone = value;
					if (Application.isPlaying)
					{
						FixDummyHierarchy();
					}
				}
			}
		}

		public Transform RightEyeLookAtBone
		{
			get
			{
				return _rightEyeLookAtBone;
			}
			set
			{
				if (!(_rightEyeLookAtBone == value))
				{
					_rightEyeLookAtBone = value;
					if (Application.isPlaying)
					{
						FixDummyHierarchy();
					}
				}
			}
		}

		private void Start()
		{
			randomAngle = Quaternion.identity;
			leftTargetAngle = Quaternion.identity;
			rightTargetAngle = Quaternion.identity;
			if (LeftEyeLookAtBone != null && RightEyeLookAtBone != null)
			{
				leftRotation = LeftEyeLookAtBone.rotation;
				rightRotation = RightEyeLookAtBone.rotation;
			}
			if (targetEnabled && autoTarget)
			{
				FindTargets();
			}
			leftEyeDummy = new GameObject("Left Eye Dummy").transform;
			rightEyeDummy = new GameObject("Right Eye Dummy").transform;
			leftEyeDummy.gameObject.hideFlags = HideFlags.DontSave;
			rightEyeDummy.gameObject.hideFlags = HideFlags.DontSave;
			FixDummyHierarchy();
			boneShapes = new Dictionary<Transform, BoneShapeInfo>();
			if (blinkingControlMode == ControlMode.PoseBased)
			{
				foreach (BoneShape bone in blinkingShape.bones)
				{
					if (!boneShapes.ContainsKey(bone.bone))
					{
						boneShapes.Add(bone.bone, new BoneShapeInfo(bone));
					}
				}
			}
			if (lookingControlMode != ControlMode.PoseBased)
			{
				return;
			}
			foreach (BoneShape bone2 in lookingUpShape.bones)
			{
				if (!boneShapes.ContainsKey(bone2.bone))
				{
					boneShapes.Add(bone2.bone, new BoneShapeInfo(bone2));
				}
			}
			foreach (BoneShape bone3 in lookingDownShape.bones)
			{
				if (!boneShapes.ContainsKey(bone3.bone))
				{
					boneShapes.Add(bone3.bone, new BoneShapeInfo(bone3));
				}
			}
			foreach (BoneShape bone4 in lookingLeftShape.bones)
			{
				if (!boneShapes.ContainsKey(bone4.bone))
				{
					boneShapes.Add(bone4.bone, new BoneShapeInfo(bone4));
				}
			}
			foreach (BoneShape bone5 in lookingRightShape.bones)
			{
				if (!boneShapes.ContainsKey(bone5.bone))
				{
					boneShapes.Add(bone5.bone, new BoneShapeInfo(bone5));
				}
			}
		}

		private void LateUpdate()
		{
			if (blinkingEnabled && blendSystem != null && !keepEyesClosed && !_asyncBlending && blendSystem.isReady)
			{
				if (blinking)
				{
					float num = blinkDuration / 2f;
					if (blinkTimer < num)
					{
						if (blinkingControlMode == ControlMode.Classic)
						{
							blendSystem.SetBlendableValue(leftEyeBlinkBlendable, Mathf.Lerp(0f, 100f, blinkTimer / num));
							blendSystem.SetBlendableValue(rightEyeBlinkBlendable, Mathf.Lerp(0f, 100f, blinkTimer / num));
						}
						else if (blinkingControlMode == ControlMode.PoseBased)
						{
							for (int i = 0; i < blinkingShape.blendShapes.Count; i++)
							{
								blendSystem.SetBlendableValue(blinkingShape.blendShapes[i], Mathf.Lerp(0f, blinkingShape.weights[i], blinkTimer / num));
							}
							for (int j = 0; j < blinkingShape.bones.Count; j++)
							{
								if (boneUpdateAnimation)
								{
									Vector3 vector = Vector3.Lerp(boneShapes[blinkingShape.bones[j].bone].storedPosition, blinkingShape.bones[j].endPosition, blinkTimer / num) - blinkingShape.bones[j].neutralPosition;
									Vector3 vector2 = Vector3.Lerp(boneShapes[blinkingShape.bones[j].bone].storedRotation.eulerAngles, blinkingShape.bones[j].endRotation, blinkTimer / num) - blinkingShape.bones[j].neutralRotation;
									if (!blinkingShape.bones[j].lockPosition)
									{
										blinkingShape.bones[j].bone.localPosition += vector;
									}
									if (!blinkingShape.bones[j].lockRotation)
									{
										blinkingShape.bones[j].bone.localEulerAngles += vector2;
									}
								}
								else
								{
									if (!blinkingShape.bones[j].lockPosition)
									{
										blinkingShape.bones[j].bone.localPosition = Vector3.Lerp(boneShapes[blinkingShape.bones[j].bone].storedPosition, blinkingShape.bones[j].endPosition, blinkTimer / num);
									}
									if (!blinkingShape.bones[j].lockRotation)
									{
										blinkingShape.bones[j].bone.localEulerAngles = Vector3.Lerp(boneShapes[blinkingShape.bones[j].bone].storedRotation.eulerAngles, blinkingShape.bones[j].endRotation, blinkTimer / num);
									}
								}
							}
						}
					}
					else
					{
						if (blinkingControlMode == ControlMode.Classic)
						{
							blendSystem.SetBlendableValue(leftEyeBlinkBlendable, Mathf.Lerp(100f, 0f, (blinkTimer - num) / num));
							blendSystem.SetBlendableValue(rightEyeBlinkBlendable, Mathf.Lerp(100f, 0f, (blinkTimer - num) / num));
						}
						else if (blinkingControlMode == ControlMode.PoseBased)
						{
							for (int k = 0; k < blinkingShape.blendShapes.Count; k++)
							{
								blendSystem.SetBlendableValue(blinkingShape.blendShapes[k], Mathf.Lerp(blinkingShape.weights[k], 0f, (blinkTimer - num) / num));
							}
							for (int l = 0; l < blinkingShape.bones.Count; l++)
							{
								if (boneUpdateAnimation)
								{
									Vector3 vector3 = Vector3.Lerp(blinkingShape.bones[l].endPosition, boneShapes[blinkingShape.bones[l].bone].storedPosition, (blinkTimer - num) / num) - blinkingShape.bones[l].neutralPosition;
									Vector3 vector4 = Vector3.Lerp(blinkingShape.bones[l].endRotation, boneShapes[blinkingShape.bones[l].bone].storedRotation.eulerAngles, (blinkTimer - num) / num) - blinkingShape.bones[l].neutralRotation;
									if (!blinkingShape.bones[l].lockPosition)
									{
										blinkingShape.bones[l].bone.localPosition += vector3;
									}
									if (!blinkingShape.bones[l].lockRotation)
									{
										blinkingShape.bones[l].bone.localEulerAngles += vector4;
									}
								}
								else
								{
									if (!blinkingShape.bones[l].lockPosition)
									{
										blinkingShape.bones[l].bone.localPosition = Vector3.Lerp(blinkingShape.bones[l].endPosition, boneShapes[blinkingShape.bones[l].bone].storedPosition, (blinkTimer - num) / num);
									}
									if (!blinkingShape.bones[l].lockRotation)
									{
										blinkingShape.bones[l].bone.localEulerAngles = Vector3.Lerp(blinkingShape.bones[l].endRotation, boneShapes[blinkingShape.bones[l].bone].storedRotation.eulerAngles, (blinkTimer - num) / num);
									}
								}
							}
						}
						if (blinkTimer > blinkDuration)
						{
							blinking = false;
							blinkTimer = UnityEngine.Random.Range(minimumBlinkGap, maximumBlinkGap);
						}
					}
					blinkTimer += Time.deltaTime;
				}
				else if (blinkTimer <= 0f)
				{
					blinking = true;
					blinkTimer = 0f;
				}
				else
				{
					blinkTimer -= Time.deltaTime;
				}
			}
			if (targetEnabled && lookingControlMode != ControlMode.PoseBased && LeftEyeLookAtBone != null && RightEyeLookAtBone != null)
			{
				if (autoTarget)
				{
					try
					{
						float num2 = autoTargetDistance;
						target = null;
						for (int m = 0; m < markedTargets.Length; m++)
						{
							if (Vector3.Distance(base.transform.position, markedTargets[m].position) < num2)
							{
								num2 = Vector3.Distance(base.transform.position, markedTargets[m].position);
								target = markedTargets[m];
							}
						}
					}
					catch (NullReferenceException)
					{
						FindTargets();
					}
				}
				else
				{
					target = viewTarget;
				}
				if (target != null)
				{
					Vector3 vector5 = leftEyeDummy.parent.InverseTransformEulerAngle(Quaternion.LookRotation(target.position - leftEyeDummy.position).eulerAngles).ToNegativeEuler();
					Vector3 vector6 = rightEyeDummy.parent.InverseTransformEulerAngle(Quaternion.LookRotation(target.position - rightEyeDummy.position).eulerAngles).ToNegativeEuler();
					vector5 = new Vector3(Mathf.Clamp(vector5.x, eyeRotationRangeX.x, eyeRotationRangeX.y), Mathf.Clamp(vector5.y, eyeRotationRangeY.x, eyeRotationRangeY.y), 0f) + eyeLookOffset;
					vector6 = new Vector3(Mathf.Clamp(vector6.x, eyeRotationRangeX.x, eyeRotationRangeX.y), Mathf.Clamp(vector6.y, eyeRotationRangeY.x, eyeRotationRangeY.y), 0f) + eyeLookOffset;
					leftTargetAngle = Quaternion.Euler(leftEyeDummy.parent.TransformEulerAngle(vector5));
					rightTargetAngle = Quaternion.Euler(rightEyeDummy.parent.TransformEulerAngle(vector6));
				}
				else
				{
					targetWeight = 0f;
				}
			}
			else
			{
				targetWeight = 0f;
			}
			if (randomLookingEnabled && ((LeftEyeLookAtBone != null && RightEyeLookAtBone != null && lookingControlMode == ControlMode.Classic) || lookingControlMode == ControlMode.PoseBased))
			{
				if (lookTimer <= 0f)
				{
					lookTimer = UnityEngine.Random.Range(minimumChangeDirectionGap, maximumChangeDirectionGap);
					if (lookingControlMode == ControlMode.Classic)
					{
						randomAngle = Quaternion.Euler(UnityEngine.Random.Range(eyeRotationRangeX.x, eyeRotationRangeX.y), UnityEngine.Random.Range(eyeRotationRangeY.x, eyeRotationRangeY.y), 0f) * Quaternion.Euler(eyeLookOffset);
					}
					else if (lookingControlMode == ControlMode.PoseBased)
					{
						randomBlend = new Vector2(UnityEngine.Random.Range(-1f, 1f), UnityEngine.Random.Range(-1f, 1f));
					}
				}
				else
				{
					lookTimer -= Time.deltaTime;
				}
			}
			if ((!(LeftEyeLookAtBone != null) || !(RightEyeLookAtBone != null) || (!randomLookingEnabled && !targetEnabled)) && lookingControlMode != ControlMode.PoseBased)
			{
				return;
			}
			if (lookingControlMode == ControlMode.Classic)
			{
				leftEyeDummy.rotation = leftRotation;
				rightEyeDummy.rotation = rightRotation;
				Quaternion b = Quaternion.Lerp(leftEyeDummy.parent.rotation * randomAngle, leftTargetAngle, targetWeight);
				Quaternion b2 = Quaternion.Lerp(rightEyeDummy.parent.rotation * randomAngle, rightTargetAngle, targetWeight);
				leftEyeDummy.rotation = Quaternion.Lerp(leftEyeDummy.rotation, b, Time.deltaTime * eyeTurnSpeed);
				rightEyeDummy.rotation = Quaternion.Lerp(rightEyeDummy.rotation, b2, Time.deltaTime * eyeTurnSpeed);
				Transform leftEyeLookAtBone = LeftEyeLookAtBone;
				Vector3 localPosition = (RightEyeLookAtBone.localPosition = Vector3.zero);
				leftEyeLookAtBone.localPosition = localPosition;
				LeftEyeLookAtBone.localEulerAngles = axisOffsets[(int)eyeForwardAxis];
				RightEyeLookAtBone.localEulerAngles = axisOffsets[(int)eyeForwardAxis];
				leftRotation = leftEyeDummy.rotation;
				rightRotation = rightEyeDummy.rotation;
			}
			else
			{
				if (lookingControlMode != ControlMode.PoseBased)
				{
					return;
				}
				if (randomBlend.y >= 0f)
				{
					for (int n = 0; n < lookingUpShape.blendShapes.Count; n++)
					{
						if (blinkingControlMode == ControlMode.PoseBased)
						{
							if (!blinkingShape.blendShapes.Contains(lookingUpShape.blendShapes[n]) || (!blinking && !keepEyesClosed))
							{
								blendSystem.SetBlendableValue(lookingUpShape.blendShapes[n], Mathf.Lerp(blendSystem.GetBlendableValue(lookingUpShape.blendShapes[n]), Mathf.Lerp(0f, lookingUpShape.weights[n], randomBlend.y), Time.deltaTime * eyeTurnSpeed));
							}
						}
						else if ((leftEyeBlinkBlendable != lookingUpShape.blendShapes[n] && rightEyeBlinkBlendable != lookingUpShape.blendShapes[n]) || (!blinking && !keepEyesClosed))
						{
							blendSystem.SetBlendableValue(lookingUpShape.blendShapes[n], Mathf.Lerp(blendSystem.GetBlendableValue(lookingUpShape.blendShapes[n]), Mathf.Lerp(0f, lookingUpShape.weights[n], randomBlend.y), Time.deltaTime * eyeTurnSpeed));
						}
					}
					for (int num3 = 0; num3 < lookingUpShape.bones.Count; num3++)
					{
						if (blinkingControlMode == ControlMode.PoseBased && blinkingShape.HasBone(lookingUpShape.bones[num3].bone) && (blinking || keepEyesClosed))
						{
							continue;
						}
						Vector3 vector7 = Vector3.Lerp(lookingUpShape.bones[num3].neutralPosition, lookingUpShape.bones[num3].endPosition, randomBlend.y);
						Vector3 vector8 = Vector3LerpAngle(lookingUpShape.bones[num3].neutralRotation, lookingUpShape.bones[num3].endRotation, randomBlend.y);
						if (boneUpdateAnimation)
						{
							if (!lookingUpShape.bones[num3].lockPosition)
							{
								boneShapes[lookingUpShape.bones[num3].bone].targetPosition = lookingUpShape.bones[num3].bone.localPosition + (vector7 - lookingUpShape.bones[num3].neutralPosition);
							}
							if (!lookingUpShape.bones[num3].lockRotation)
							{
								boneShapes[lookingUpShape.bones[num3].bone].targetRotation = Quaternion.Euler(lookingUpShape.bones[num3].bone.localEulerAngles + (vector8 - lookingUpShape.bones[num3].neutralRotation));
							}
						}
						else
						{
							if (!lookingUpShape.bones[num3].lockPosition)
							{
								boneShapes[lookingUpShape.bones[num3].bone].targetPosition = vector7;
							}
							if (!lookingUpShape.bones[num3].lockRotation)
							{
								boneShapes[lookingUpShape.bones[num3].bone].targetRotation = Quaternion.Euler(vector8);
							}
						}
						if (!lookingUpShape.bones[num3].lockPosition)
						{
							boneShapes[lookingUpShape.bones[num3].bone].storedPosition = Vector3.Lerp(boneShapes[lookingUpShape.bones[num3].bone].storedPosition, boneShapes[lookingUpShape.bones[num3].bone].targetPosition, Time.deltaTime * eyeTurnSpeed);
						}
						if (!lookingUpShape.bones[num3].lockRotation)
						{
							boneShapes[lookingUpShape.bones[num3].bone].storedRotation = Quaternion.Lerp(boneShapes[lookingUpShape.bones[num3].bone].storedRotation, boneShapes[lookingUpShape.bones[num3].bone].targetRotation, Time.deltaTime * eyeTurnSpeed);
						}
					}
				}
				else
				{
					for (int num4 = 0; num4 < lookingDownShape.blendShapes.Count; num4++)
					{
						if (blinkingControlMode == ControlMode.PoseBased)
						{
							if (!blinkingShape.blendShapes.Contains(lookingDownShape.blendShapes[num4]) || (!blinking && !keepEyesClosed))
							{
								blendSystem.SetBlendableValue(lookingDownShape.blendShapes[num4], Mathf.Lerp(blendSystem.GetBlendableValue(lookingDownShape.blendShapes[num4]), Mathf.Lerp(0f, lookingDownShape.weights[num4], 0f - randomBlend.y), Time.deltaTime * eyeTurnSpeed));
							}
						}
						else if ((leftEyeBlinkBlendable != lookingDownShape.blendShapes[num4] && rightEyeBlinkBlendable != lookingDownShape.blendShapes[num4]) || (!blinking && !keepEyesClosed))
						{
							blendSystem.SetBlendableValue(lookingDownShape.blendShapes[num4], Mathf.Lerp(blendSystem.GetBlendableValue(lookingDownShape.blendShapes[num4]), Mathf.Lerp(0f, lookingDownShape.weights[num4], 0f - randomBlend.y), Time.deltaTime * eyeTurnSpeed));
						}
					}
					for (int num5 = 0; num5 < lookingDownShape.bones.Count; num5++)
					{
						if (blinkingControlMode == ControlMode.PoseBased && blinkingShape.HasBone(lookingDownShape.bones[num5].bone) && (blinking || keepEyesClosed))
						{
							continue;
						}
						Vector3 vector9 = Vector3.Lerp(lookingDownShape.bones[num5].neutralPosition, lookingDownShape.bones[num5].endPosition, 0f - randomBlend.y);
						Vector3 vector10 = Vector3LerpAngle(lookingDownShape.bones[num5].neutralRotation, lookingDownShape.bones[num5].endRotation, 0f - randomBlend.y);
						if (boneUpdateAnimation)
						{
							if (!lookingDownShape.bones[num5].lockPosition)
							{
								boneShapes[lookingDownShape.bones[num5].bone].targetPosition = lookingDownShape.bones[num5].bone.localPosition + (vector9 - lookingDownShape.bones[num5].neutralPosition);
							}
							if (!lookingDownShape.bones[num5].lockRotation)
							{
								boneShapes[lookingDownShape.bones[num5].bone].targetRotation = Quaternion.Euler(lookingDownShape.bones[num5].bone.localEulerAngles + (vector10 - lookingDownShape.bones[num5].neutralRotation));
							}
						}
						else
						{
							if (!lookingDownShape.bones[num5].lockPosition)
							{
								boneShapes[lookingDownShape.bones[num5].bone].targetPosition = vector9;
							}
							if (!lookingDownShape.bones[num5].lockRotation)
							{
								boneShapes[lookingDownShape.bones[num5].bone].targetRotation = Quaternion.Euler(vector10);
							}
						}
						if (!lookingDownShape.bones[num5].lockPosition)
						{
							boneShapes[lookingDownShape.bones[num5].bone].storedPosition = Vector3.Lerp(boneShapes[lookingDownShape.bones[num5].bone].storedPosition, boneShapes[lookingDownShape.bones[num5].bone].targetPosition, Time.deltaTime * eyeTurnSpeed);
						}
						if (!lookingDownShape.bones[num5].lockRotation)
						{
							boneShapes[lookingDownShape.bones[num5].bone].storedRotation = Quaternion.Lerp(boneShapes[lookingDownShape.bones[num5].bone].storedRotation, boneShapes[lookingDownShape.bones[num5].bone].targetRotation, Time.deltaTime * eyeTurnSpeed);
						}
					}
				}
				if (randomBlend.x >= 0f)
				{
					for (int num6 = 0; num6 < lookingRightShape.blendShapes.Count; num6++)
					{
						if (blinkingControlMode == ControlMode.PoseBased)
						{
							if (!blinkingShape.blendShapes.Contains(lookingRightShape.blendShapes[num6]) || (!blinking && !keepEyesClosed))
							{
								blendSystem.SetBlendableValue(lookingRightShape.blendShapes[num6], Mathf.Lerp(blendSystem.GetBlendableValue(lookingRightShape.blendShapes[num6]), Mathf.Lerp(0f, lookingRightShape.weights[num6], randomBlend.x), Time.deltaTime * eyeTurnSpeed));
							}
						}
						else if ((leftEyeBlinkBlendable != lookingRightShape.blendShapes[num6] && rightEyeBlinkBlendable != lookingRightShape.blendShapes[num6]) || (!blinking && !keepEyesClosed))
						{
							blendSystem.SetBlendableValue(lookingRightShape.blendShapes[num6], Mathf.Lerp(blendSystem.GetBlendableValue(lookingRightShape.blendShapes[num6]), Mathf.Lerp(0f, lookingRightShape.weights[num6], randomBlend.x), Time.deltaTime * eyeTurnSpeed));
						}
					}
					for (int num7 = 0; num7 < lookingRightShape.bones.Count; num7++)
					{
						if (blinkingControlMode != ControlMode.PoseBased || !blinkingShape.HasBone(lookingRightShape.bones[num7].bone) || (!blinking && !keepEyesClosed))
						{
							Vector3 vector11 = Vector3.Lerp(lookingRightShape.bones[num7].neutralPosition, lookingRightShape.bones[num7].endPosition, randomBlend.x) - lookingRightShape.bones[num7].neutralPosition;
							Vector3 vector12 = Vector3LerpAngle(lookingRightShape.bones[num7].neutralRotation, lookingRightShape.bones[num7].endRotation, randomBlend.x) - lookingRightShape.bones[num7].neutralRotation;
							if (!lookingRightShape.bones[num7].lockPosition)
							{
								boneShapes[lookingRightShape.bones[num7].bone].targetPosition = lookingRightShape.bones[num7].bone.localPosition + vector11;
							}
							if (!lookingRightShape.bones[num7].lockRotation)
							{
								boneShapes[lookingRightShape.bones[num7].bone].targetRotation = Quaternion.Euler(lookingRightShape.bones[num7].bone.localEulerAngles + vector12);
							}
							if (!lookingRightShape.bones[num7].lockPosition)
							{
								boneShapes[lookingRightShape.bones[num7].bone].storedPosition = Vector3.Lerp(boneShapes[lookingRightShape.bones[num7].bone].storedPosition, boneShapes[lookingRightShape.bones[num7].bone].targetPosition, Time.deltaTime * eyeTurnSpeed);
							}
							if (!lookingRightShape.bones[num7].lockRotation)
							{
								boneShapes[lookingRightShape.bones[num7].bone].storedRotation = Quaternion.Lerp(boneShapes[lookingRightShape.bones[num7].bone].storedRotation, boneShapes[lookingRightShape.bones[num7].bone].targetRotation, Time.deltaTime * eyeTurnSpeed);
							}
						}
					}
					return;
				}
				for (int num8 = 0; num8 < lookingLeftShape.blendShapes.Count; num8++)
				{
					if (blinkingControlMode == ControlMode.PoseBased)
					{
						if (!blinkingShape.blendShapes.Contains(lookingLeftShape.blendShapes[num8]) || (!blinking && !keepEyesClosed))
						{
							blendSystem.SetBlendableValue(lookingLeftShape.blendShapes[num8], Mathf.Lerp(blendSystem.GetBlendableValue(lookingRightShape.blendShapes[num8]), Mathf.Lerp(0f, lookingLeftShape.weights[num8], 0f - randomBlend.x), Time.deltaTime * eyeTurnSpeed));
						}
					}
					else if ((leftEyeBlinkBlendable != lookingLeftShape.blendShapes[num8] && rightEyeBlinkBlendable != lookingLeftShape.blendShapes[num8]) || (!blinking && !keepEyesClosed))
					{
						blendSystem.SetBlendableValue(lookingLeftShape.blendShapes[num8], Mathf.Lerp(blendSystem.GetBlendableValue(lookingRightShape.blendShapes[num8]), Mathf.Lerp(0f, lookingLeftShape.weights[num8], 0f - randomBlend.x), Time.deltaTime * eyeTurnSpeed));
					}
				}
				for (int num9 = 0; num9 < lookingLeftShape.bones.Count; num9++)
				{
					if (blinkingControlMode != ControlMode.PoseBased || !blinkingShape.HasBone(lookingLeftShape.bones[num9].bone) || (!blinking && !keepEyesClosed))
					{
						Vector3 vector13 = Vector3.Lerp(lookingLeftShape.bones[num9].neutralPosition, lookingLeftShape.bones[num9].endPosition, 0f - randomBlend.x) - lookingLeftShape.bones[num9].neutralPosition;
						Vector3 vector14 = Vector3LerpAngle(lookingLeftShape.bones[num9].neutralRotation, lookingLeftShape.bones[num9].endRotation, 0f - randomBlend.x) - lookingLeftShape.bones[num9].neutralRotation;
						if (!lookingLeftShape.bones[num9].lockPosition)
						{
							boneShapes[lookingLeftShape.bones[num9].bone].targetPosition = lookingLeftShape.bones[num9].bone.localPosition + vector13;
						}
						if (!lookingLeftShape.bones[num9].lockRotation)
						{
							boneShapes[lookingLeftShape.bones[num9].bone].targetRotation = Quaternion.Euler(lookingLeftShape.bones[num9].bone.localEulerAngles + vector14);
						}
						if (!lookingLeftShape.bones[num9].lockPosition)
						{
							boneShapes[lookingLeftShape.bones[num9].bone].storedPosition = Vector3.Lerp(boneShapes[lookingLeftShape.bones[num9].bone].storedPosition, boneShapes[lookingLeftShape.bones[num9].bone].targetPosition, Time.deltaTime * eyeTurnSpeed);
						}
						if (!lookingLeftShape.bones[num9].lockRotation)
						{
							boneShapes[lookingLeftShape.bones[num9].bone].storedRotation = Quaternion.Lerp(boneShapes[lookingLeftShape.bones[num9].bone].storedRotation, boneShapes[lookingLeftShape.bones[num9].bone].targetRotation, Time.deltaTime * eyeTurnSpeed);
						}
					}
				}
			}
		}

		private IEnumerator CloseEyes()
		{
			bool end = false;
			blinkTimer = 0f;
			_asyncBlending = true;
			while (!end)
			{
				if (blinkingControlMode == ControlMode.Classic)
				{
					blendSystem.SetBlendableValue(leftEyeBlinkBlendable, Mathf.Lerp(0f, 100f, blinkTimer / blinkDuration));
					blendSystem.SetBlendableValue(rightEyeBlinkBlendable, Mathf.Lerp(0f, 100f, blinkTimer / blinkDuration));
				}
				else
				{
					for (int i = 0; i < blinkingShape.blendShapes.Count; i++)
					{
						blendSystem.SetBlendableValue(blinkingShape.blendShapes[i], Mathf.Lerp(0f, 100f, blinkTimer / blinkDuration));
					}
					for (int j = 0; j < blinkingShape.bones.Count; j++)
					{
						if (boneUpdateAnimation)
						{
							Vector3 vector = Vector3.Lerp(blinkingShape.bones[j].neutralPosition, blinkingShape.bones[j].endPosition, blinkTimer / blinkDuration) - blinkingShape.bones[j].neutralPosition;
							Vector3 vector2 = Vector3.Lerp(blinkingShape.bones[j].neutralRotation, blinkingShape.bones[j].endRotation, blinkTimer / blinkDuration) - blinkingShape.bones[j].neutralRotation;
							if (!blinkingShape.bones[j].lockPosition)
							{
								blinkingShape.bones[j].bone.localPosition += vector;
							}
							if (!blinkingShape.bones[j].lockRotation)
							{
								blinkingShape.bones[j].bone.localEulerAngles += vector2;
							}
						}
						else
						{
							if (!blinkingShape.bones[j].lockPosition)
							{
								blinkingShape.bones[j].bone.localPosition = Vector3.Lerp(blinkingShape.bones[j].neutralPosition, blinkingShape.bones[j].endPosition, blinkTimer / blinkDuration);
							}
							if (!blinkingShape.bones[j].lockRotation)
							{
								blinkingShape.bones[j].bone.localEulerAngles = Vector3.Lerp(blinkingShape.bones[j].neutralRotation, blinkingShape.bones[j].endRotation, blinkTimer / blinkDuration);
							}
						}
					}
				}
				if (blinkTimer > blinkDuration)
				{
					end = true;
					_asyncBlending = false;
				}
				blinkTimer += Time.deltaTime;
				yield return null;
			}
		}

		private IEnumerator OpenEyes()
		{
			bool end = false;
			blinkTimer = 0f;
			_asyncBlending = true;
			while (!end)
			{
				if (blinkingControlMode == ControlMode.Classic)
				{
					blendSystem.SetBlendableValue(leftEyeBlinkBlendable, Mathf.Lerp(100f, 0f, blinkTimer / blinkDuration));
					blendSystem.SetBlendableValue(rightEyeBlinkBlendable, Mathf.Lerp(100f, 0f, blinkTimer / blinkDuration));
				}
				else
				{
					for (int i = 0; i < blinkingShape.blendShapes.Count; i++)
					{
						blendSystem.SetBlendableValue(blinkingShape.blendShapes[i], Mathf.Lerp(100f, 0f, blinkTimer / blinkDuration));
					}
					for (int j = 0; j < blinkingShape.bones.Count; j++)
					{
						if (boneUpdateAnimation)
						{
							Vector3 vector = Vector3.Lerp(blinkingShape.bones[j].endPosition, blinkingShape.bones[j].neutralPosition, blinkTimer / blinkDuration) - blinkingShape.bones[j].neutralPosition;
							Vector3 vector2 = Vector3.Lerp(blinkingShape.bones[j].endRotation, blinkingShape.bones[j].neutralRotation, blinkTimer / blinkDuration) - blinkingShape.bones[j].neutralRotation;
							if (!blinkingShape.bones[j].lockPosition)
							{
								blinkingShape.bones[j].bone.localPosition += vector;
							}
							if (!blinkingShape.bones[j].lockRotation)
							{
								blinkingShape.bones[j].bone.localEulerAngles += vector2;
							}
						}
						else
						{
							if (!blinkingShape.bones[j].lockPosition)
							{
								blinkingShape.bones[j].bone.localPosition = Vector3.Lerp(blinkingShape.bones[j].endPosition, blinkingShape.bones[j].neutralPosition, blinkTimer / blinkDuration);
							}
							if (!blinkingShape.bones[j].lockRotation)
							{
								blinkingShape.bones[j].bone.localEulerAngles = Vector3.Lerp(blinkingShape.bones[j].endRotation, blinkingShape.bones[j].neutralRotation, blinkTimer / blinkDuration);
							}
						}
					}
				}
				if (blinkTimer > blinkDuration)
				{
					end = true;
					_asyncBlending = false;
				}
				blinkTimer += Time.deltaTime;
				yield return null;
			}
		}

		private void FixDummyHierarchy()
		{
			if (LeftEyeLookAtBone == null || RightEyeLookAtBone == null)
			{
				return;
			}
			if (leftEyeDummy.childCount > 0)
			{
				for (int i = 0; i < leftEyeDummy.childCount; i++)
				{
					leftEyeDummy.GetChild(i).SetParent(leftEyeDummy.parent, worldPositionStays: true);
				}
			}
			if (rightEyeDummy.childCount > 0)
			{
				for (int j = 0; j < rightEyeDummy.childCount; j++)
				{
					rightEyeDummy.GetChild(j).SetParent(rightEyeDummy.parent, worldPositionStays: true);
				}
			}
			leftEyeDummy.SetParent(LeftEyeLookAtBone.parent, worldPositionStays: false);
			rightEyeDummy.SetParent(RightEyeLookAtBone.parent, worldPositionStays: false);
			leftEyeDummy.position = LeftEyeLookAtBone.position;
			leftEyeDummy.rotation = LeftEyeLookAtBone.rotation;
			rightEyeDummy.position = RightEyeLookAtBone.position;
			rightEyeDummy.rotation = RightEyeLookAtBone.rotation;
			LeftEyeLookAtBone.SetParent(leftEyeDummy, worldPositionStays: true);
			RightEyeLookAtBone.SetParent(rightEyeDummy, worldPositionStays: true);
		}

		public void FindTargets()
		{
			GameObject[] array = GameObject.FindGameObjectsWithTag(autoTargetTag);
			markedTargets = new Transform[array.Length];
			for (int i = 0; i < markedTargets.Length; i++)
			{
				markedTargets[i] = array[i].transform;
			}
		}

		public static Vector3 Vector3LerpAngle(Vector3 a, Vector3 b, float t)
		{
			return new Vector3(Mathf.LerpAngle(a.x, b.x, t), Mathf.LerpAngle(a.y, b.y, t), Mathf.LerpAngle(a.z, b.z, t));
		}

		public void SetLookAtAmount(float amount)
		{
			targetWeight = amount;
		}
	}
}
namespace RogoDigital.Lipsync
{
	[RequireComponent(typeof(BlendshapeManager))]
	public class AdvancedBlendshapeBlendSystem : BlendSystem
	{
		[SerializeField]
		private BlendshapeManager manager;

		public override void OnEnable()
		{
			blendableDisplayName = "Blend Shape";
			blendableDisplayNamePlural = "Blend Shapes";
			noBlendablesMessage = "Your chosen Skinned Mesh Renderer has no Blend Shapes defined.";
			notReadyMessage = "Skinned Mesh Renderer not set. The Blend Shape BlendSystem requires at least one Skinned Mesh Renderer.";
			if (manager == null)
			{
				if (base.gameObject.GetComponents<BlendshapeManager>().Length > 1)
				{
					manager = base.gameObject.AddComponent<BlendshapeManager>();
				}
				else
				{
					manager = base.gameObject.GetComponent<BlendshapeManager>();
				}
				manager.blendSystem = this;
			}
			else if (manager.blendSystem == null)
			{
				manager.blendSystem = this;
			}
			isReady = true;
			base.OnEnable();
		}

		public override string[] GetBlendables()
		{
			if (!isReady)
			{
				return null;
			}
			bool flag = false;
			string[] array = new string[manager.blendShapes.Length];
			if (base.blendableCount == 0)
			{
				flag = true;
			}
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = manager.blendShapes[i].name + " (" + i + ")";
				float currentValue = 0f;
				if (manager.blendShapes[i].mappings.Length != 0)
				{
					currentValue = manager.blendShapes[i].mappings[0].skinnedMeshRenderer.GetBlendShapeWeight(manager.blendShapes[i].mappings[0].blendShapeIndex);
				}
				if (flag)
				{
					AddBlendable(i, currentValue);
				}
			}
			return array;
		}

		public override void SetBlendableValue(int blendable, float value)
		{
			if (isReady && manager.blendShapes[blendable].mappings != null)
			{
				for (int i = 0; i < manager.blendShapes[blendable].mappings.Length; i++)
				{
					SetInternalValue(blendable, value);
					manager.blendShapes[blendable].mappings[i].skinnedMeshRenderer.SetBlendShapeWeight(manager.blendShapes[blendable].mappings[i].blendShapeIndex, value);
				}
			}
		}
	}
	public class BlendshapeBlendSystem : BlendSystem
	{
		public SkinnedMeshRenderer characterMesh;

		public SkinnedMeshRenderer[] optionalOtherMeshes;

		private bool wireframeVisible = true;

		public override void OnEnable()
		{
			blendableDisplayName = "Blend Shape";
			blendableDisplayNamePlural = "Blend Shapes";
			noBlendablesMessage = "Your chosen Skinned Mesh Renderer has no Blend Shapes defined.";
			notReadyMessage = "Skinned Mesh Renderer not set. The Blend Shape BlendSystem requires at least one Skinned Mesh Renderer.";
			base.OnEnable();
		}

		public override void SetBlendableValue(int blendable, float value)
		{
			if (!isReady || characterMesh == null)
			{
				return;
			}
			characterMesh.SetBlendShapeWeight(blendable, value);
			SetInternalValue(blendable, value);
			SkinnedMeshRenderer[] array = optionalOtherMeshes;
			foreach (SkinnedMeshRenderer skinnedMeshRenderer in array)
			{
				if (blendable < skinnedMeshRenderer.sharedMesh.blendShapeCount)
				{
					skinnedMeshRenderer.SetBlendShapeWeight(blendable, value);
				}
			}
		}

		public override string[] GetBlendables()
		{
			if (!isReady || characterMesh == null)
			{
				return null;
			}
			bool flag = false;
			string[] array = new string[characterMesh.sharedMesh.blendShapeCount];
			if (base.blendableCount == 0)
			{
				flag = true;
			}
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = characterMesh.sharedMesh.GetBlendShapeName(i) + " (" + i + ")";
				if (flag)
				{
					AddBlendable(i, characterMesh.GetBlendShapeWeight(i));
				}
			}
			return array;
		}

		public override void OnVariableChanged()
		{
			if (characterMesh != null)
			{
				isReady = true;
			}
			else
			{
				isReady = false;
			}
		}

		[BlendSystemButton("Toggle Wireframe")]
		public void ToggleWireframe()
		{
			if (characterMesh != null)
			{
				wireframeVisible = !wireframeVisible;
			}
		}
	}
	[Serializable]
	public class BlendshapeManager : MonoBehaviour
	{
		[Serializable]
		public struct AdvancedBlendShape
		{
			public string name;

			public BlendShapeMapping[] mappings;
		}

		[Serializable]
		public struct BlendShapeMapping
		{
			public SkinnedMeshRenderer skinnedMeshRenderer;

			public int blendShapeIndex;
		}

		[Space]
		public AdvancedBlendShape[] blendShapes = new AdvancedBlendShape[0];

		[HideInInspector]
		public AdvancedBlendshapeBlendSystem blendSystem;
	}
	[RequireComponent(typeof(SpriteManager))]
	public class SpriteBlendSystem : BlendSystem
	{
		[SerializeField]
		private SpriteManager manager;

		public override void OnEnable()
		{
			blendableDisplayName = "Sprite";
			blendableDisplayNamePlural = "Sprites";
			noBlendablesMessage = "No Sprites or Layers available. Add Sprites and Layers to the attached SpriteManager to use them.";
			notReadyMessage = "No renderers set up";
			if (manager == null)
			{
				if (base.gameObject.GetComponents<SpriteBlendSystem>().Length > 1)
				{
					manager = base.gameObject.AddComponent<SpriteManager>();
				}
				else
				{
					manager = base.gameObject.GetComponent<SpriteManager>();
				}
				manager.blendSystem = this;
			}
			else if (manager.blendSystem == null)
			{
				manager.blendSystem = this;
			}
			base.OnEnable();
		}

		public override void SetBlendableValue(int blendable, float value)
		{
			if (!isReady || manager.groups.Count == 0 || manager.availableSprites.Count == 0)
			{
				return;
			}
			int num = Mathf.FloorToInt(blendable / manager.availableSprites.Count);
			SpriteRenderer spriteRenderer = manager.groups[num].spriteRenderer;
			if (spriteRenderer == null)
			{
				return;
			}
			SetInternalValue(blendable, value);
			int index = 0;
			float num2 = 0f;
			for (int i = num * manager.availableSprites.Count; i < (num + 1) * manager.availableSprites.Count; i++)
			{
				float blendableValue = GetBlendableValue(i);
				if (blendableValue > num2)
				{
					num2 = blendableValue;
					index = i % manager.availableSprites.Count;
				}
			}
			if (num2 == 0f)
			{
				spriteRenderer.sprite = manager.groups[num].defaultSprite;
			}
			else if (spriteRenderer != null)
			{
				spriteRenderer.sprite = manager.availableSprites[index];
			}
		}

		public override string[] GetBlendables()
		{
			if (!isReady)
			{
				return null;
			}
			ClearBlendables();
			List<string> list = new List<string>();
			if (manager == null)
			{
				manager = GetComponent<SpriteManager>();
			}
			for (int i = 0; i < manager.groups.Count; i++)
			{
				if (manager.groups[i] == null)
				{
					continue;
				}
				for (int j = 0; j < manager.availableSprites.Count; j++)
				{
					if (manager.availableSprites[j] != null)
					{
						list.Add(manager.groups[i].groupName + "/" + manager.availableSprites[j].name + "(" + (i * manager.availableSprites.Count + j) + ")");
						AddBlendable(i, 0f);
					}
				}
			}
			return list.ToArray();
		}

		public override void OnVariableChanged()
		{
			isReady = true;
		}

		[BlendSystemButton("Show Help")]
		public void ShowHelp()
		{
			Application.OpenURL("http://updates.rogodigital.com/AssetStore/LipSync/spriteblendsystem.pdf");
		}
	}
	[Serializable]
	public class SpriteManager : MonoBehaviour
	{
		[Serializable]
		public class SpriteGroup
		{
			[SerializeField]
			public string groupName;

			[SerializeField]
			public SpriteRenderer spriteRenderer;

			[SerializeField]
			public Sprite defaultSprite;

			public SpriteGroup(string groupName)
			{
				this.groupName = groupName;
			}
		}

		[SerializeField]
		public List<Sprite> availableSprites = new List<Sprite>();

		[SerializeField]
		public List<SpriteGroup> groups = new List<SpriteGroup>();

		public SpriteBlendSystem blendSystem;
	}
	[RequireComponent(typeof(TextureOffsetManager))]
	public class TextureOffsetBlendSystem : BlendSystem
	{
		[SerializeField]
		private TextureOffsetManager manager;

		private Dictionary<int, int> groupLookup;

		private Dictionary<string, int> reverseGroupLookup;

		public override void OnEnable()
		{
			blendableDisplayName = "Texture Setting";
			blendableDisplayNamePlural = "Texture Settings";
			noBlendablesMessage = "No Texture Settings available. Add Texture Settings to the attached Texture Offset Manager to use them.";
			notReadyMessage = "No renderers set up";
			if (manager == null)
			{
				if (base.gameObject.GetComponents<TextureOffsetBlendSystem>().Length > 1)
				{
					manager = base.gameObject.AddComponent<TextureOffsetManager>();
				}
				else
				{
					manager = base.gameObject.GetComponent<TextureOffsetManager>();
				}
				manager.blendSystem = this;
			}
			else if (manager.blendSystem == null)
			{
				manager.blendSystem = this;
			}
			CacheGroups();
			base.OnEnable();
		}

		private void CacheGroups()
		{
			groupLookup = new Dictionary<int, int>();
			reverseGroupLookup = new Dictionary<string, int>();
			int num = 0;
			for (int i = 0; i < manager.materialGroups.Length; i++)
			{
				for (int j = 0; j < manager.materialGroups[i].textureSettings.Length; j++)
				{
					groupLookup.Add(num, i);
					reverseGroupLookup.Add(i.ToString() + j, num);
					UnityEngine.Debug.LogFormat("Cached {0} at index {1} as being in group {2} with a sub-index of {3}", manager.materialGroups[i].textureSettings[j].displayName, num, i, j);
					num++;
				}
			}
		}

		public override void SetBlendableValue(int blendable, float value)
		{
			if (!isReady || manager.materialGroups.Length == 0)
			{
				return;
			}
			if (base.blendableCount != groupLookup.Count)
			{
				CacheGroups();
			}
			int num = groupLookup[blendable];
			TextureOffsetManager.MaterialTextureGroup materialTextureGroup = manager.materialGroups[num];
			if (materialTextureGroup == null)
			{
				return;
			}
			SetInternalValue(blendable, value);
			int num2 = 0;
			float num3 = 0f;
			for (int i = 0; i < materialTextureGroup.textureSettings.Length; i++)
			{
				float blendableValue = GetBlendableValue(reverseGroupLookup[num.ToString() + i]);
				if (blendableValue > num3)
				{
					num3 = blendableValue;
					num2 = i;
				}
			}
			if (!materialTextureGroup.material)
			{
				return;
			}
			if (num3 == 0f)
			{
				if ((bool)materialTextureGroup.defaultTexture)
				{
					materialTextureGroup.material.SetTexture(materialTextureGroup.texturePropertyName, materialTextureGroup.defaultTexture);
					materialTextureGroup.material.SetTextureOffset(materialTextureGroup.texturePropertyName, materialTextureGroup.defaultTextureOffset);
					materialTextureGroup.material.SetTextureScale(materialTextureGroup.texturePropertyName, materialTextureGroup.defaultTextureScale);
				}
			}
			else if (materialTextureGroup != null && (bool)materialTextureGroup.textureSettings[num2].texture)
			{
				materialTextureGroup.material.SetTexture(materialTextureGroup.texturePropertyName, materialTextureGroup.textureSettings[num2].texture);
				materialTextureGroup.material.SetTextureOffset(materialTextureGroup.texturePropertyName, materialTextureGroup.textureSettings[num2].textureOffset);
				materialTextureGroup.material.SetTextureScale(materialTextureGroup.texturePropertyName, materialTextureGroup.textureSettings[num2].textureScale);
			}
		}

		public override string[] GetBlendables()
		{
			if (!isReady)
			{
				return null;
			}
			ClearBlendables();
			List<string> list = new List<string>();
			if (manager == null)
			{
				manager = GetComponent<TextureOffsetManager>();
			}
			int num = 0;
			for (int i = 0; i < manager.materialGroups.Length; i++)
			{
				if (manager.materialGroups[i] == null)
				{
					continue;
				}
				for (int j = 0; j < manager.materialGroups[i].textureSettings.Length; j++)
				{
					if (manager.materialGroups[i].textureSettings[j] != null)
					{
						list.Add(manager.materialGroups[i].displayName + "/" + manager.materialGroups[i].textureSettings[j].displayName + " (" + num + ")");
						AddBlendable(i, 0f);
						num++;
					}
				}
			}
			return list.ToArray();
		}

		public override void OnVariableChanged()
		{
			isReady = true;
		}
	}
	[Serializable]
	public class TextureOffsetManager : MonoBehaviour
	{
		[Serializable]
		public class MaterialTextureGroup
		{
			[SerializeField]
			public string displayName;

			[Space]
			[SerializeField]
			public Material material;

			[SerializeField]
			public string texturePropertyName;

			[Space]
			[SerializeField]
			public Texture2D defaultTexture;

			[SerializeField]
			public Vector2 defaultTextureOffset;

			[SerializeField]
			public Vector2 defaultTextureScale = Vector2.one;

			[Space]
			[SerializeField]
			public TextureSetting[] textureSettings;
		}

		[Serializable]
		public class TextureSetting
		{
			[SerializeField]
			public string displayName;

			[Space]
			[SerializeField]
			public Texture2D texture;

			[SerializeField]
			public Vector2 textureOffset;

			[SerializeField]
			public Vector2 textureScale = Vector2.one;
		}

		[SerializeField]
		public MaterialTextureGroup[] materialGroups = new MaterialTextureGroup[0];

		[HideInInspector]
		public TextureOffsetBlendSystem blendSystem;
	}
	[Serializable]
	public class Blendable
	{
		public int number;

		public float currentWeight;

		public Blendable(int number, float currentWeight)
		{
			this.number = number;
			this.currentWeight = currentWeight;
		}
	}
	[Obsolete("BlendshapePresets have been deprecated in favour of the new LipSyncPreset class in LipSync Pro 1.0.")]
	public class BlendshapePreset : ScriptableObject
	{
		[SerializeField]
		public List<PhonemeShape> phonemeShapes;

		[SerializeField]
		public List<EmotionShape> emotionShapes;
	}
	[ExecuteInEditMode]
	public class BlendSystem : MonoBehaviour
	{
		public delegate void BlendSystemGenericDelegate();

		[NonSerialized]
		public string blendableDisplayName = "Blendable";

		[NonSerialized]
		public string blendableDisplayNamePlural = "Blendables";

		[NonSerialized]
		public string noBlendablesMessage = "No Blendables found.";

		[NonSerialized]
		public string notReadyMessage = "Setup incomplete.";

		[NonSerialized]
		public float blendRangeLow;

		[NonSerialized]
		public float blendRangeHigh = 100f;

		[NonSerialized]
		public bool allowResyncing;

		public bool isReady;

		public BlendSystemUser[] users = new BlendSystemUser[0];

		public BlendSystemGenericDelegate onBlendablesChanged;

		[SerializeField]
		[HideInInspector]
		private List<Blendable> _blendables;

		public int blendableCount
		{
			get
			{
				if (_blendables == null)
				{
					_blendables = new List<Blendable>();
				}
				return _blendables.Count;
			}
		}

		public virtual void OnEnable()
		{
			base.hideFlags = HideFlags.HideInInspector;
			OnVariableChanged();
			GetBlendables();
		}

		public void Register(BlendSystemUser user)
		{
			List<BlendSystemUser> list = new List<BlendSystemUser>();
			for (int i = 0; i < users.Length; i++)
			{
				list.Add(users[i]);
			}
			if (list.Contains(user))
			{
				UnityEngine.Debug.LogError("Could not register " + user.GetType().Name + " component to " + GetType().Name + ". BlendSystemUser is already registered.");
			}
			else
			{
				list.Add(user);
				user.blendSystem = this;
			}
			users = list.ToArray();
		}

		public void Unregister(BlendSystemUser user)
		{
			List<BlendSystemUser> list = new List<BlendSystemUser>();
			for (int i = 0; i < users.Length; i++)
			{
				list.Add(users[i]);
			}
			if (list.Contains(user))
			{
				if (user != null)
				{
					user.blendSystem = null;
				}
				list.Remove(user);
			}
			users = list.ToArray();
			if (users.Length == 0)
			{
				OnBlendSystemRemoved();
				if (Application.isPlaying)
				{
					UnityEngine.Object.Destroy(this);
				}
				else
				{
					UnityEngine.Object.DestroyImmediate(this);
				}
			}
		}

		public virtual void SetBlendableValue(int blendable, float value)
		{
		}

		public float GetBlendableValue(int blendable)
		{
			if (_blendables == null)
			{
				_blendables = new List<Blendable>();
			}
			return _blendables[blendable].currentWeight;
		}

		public virtual void OnVariableChanged()
		{
		}

		public virtual void OnBlendSystemAdded()
		{
		}

		public virtual void OnBlendSystemRemoved()
		{
		}

		public virtual string[] GetBlendables()
		{
			return null;
		}

		public virtual void OnBlendableAddedToPose(int blendable)
		{
		}

		public virtual void OnBlendableRemovedFromPose(int blendable)
		{
		}

		public void AddBlendable(int blendable, float currentValue)
		{
			if (_blendables == null)
			{
				_blendables = new List<Blendable>();
			}
			_blendables.Insert(blendable, new Blendable(blendable, currentValue));
		}

		public void ClearBlendables()
		{
			_blendables = new List<Blendable>();
		}

		public void SetInternalValue(int blendable, float value)
		{
			if (_blendables == null)
			{
				_blendables = new List<Blendable>();
				GetBlendables();
			}
			_blendables[blendable].currentWeight = value;
		}
	}
	[AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]
	public class BlendSystemButton : Attribute
	{
		public struct Reference
		{
			public string displayName;

			public MethodInfo method;

			public Reference(string displayName, MethodInfo method)
			{
				this.displayName = displayName;
				this.method = method;
			}
		}

		public string displayName;

		public BlendSystemButton(string displayName)
		{
			this.displayName = displayName;
		}
	}
	public class BlendSystemUser : MonoBehaviour
	{
		public BlendSystem blendSystem;

		protected void OnDestroy()
		{
			blendSystem.Unregister(this);
		}

		protected void CleanUpBlendSystems()
		{
			BlendSystem[] components = GetComponents<BlendSystem>();
			for (int i = 0; i < components.Length; i++)
			{
				if (components[i].users == null)
				{
					continue;
				}
				for (int j = 0; j < components[i].users.Length; j++)
				{
					if (components[i].users[j] == this)
					{
						components[i].Unregister(this);
					}
				}
			}
		}
	}
	[Serializable]
	public class BoneShape
	{
		[SerializeField]
		public Transform bone;

		[SerializeField]
		public Vector3 endPosition;

		[SerializeField]
		public Vector3 endRotation;

		[SerializeField]
		public Vector3 endScale = Vector3.one;

		[SerializeField]
		public bool lockPosition;

		[SerializeField]
		public bool lockRotation;

		public Vector3 neutralPosition;

		public Vector3 neutralRotation;

		public Vector3 neutralScale = Vector3.one;

		public void SetNeutral()
		{
			if (bone != null)
			{
				neutralPosition = bone.localPosition;
				neutralRotation = bone.localEulerAngles;
				neutralScale = bone.localScale;
			}
		}

		public BoneShape(Transform bone, Vector3 endPosition, Vector3 endRotation, Vector3 endScale)
		{
			this.bone = bone;
			this.endPosition = endPosition;
			this.endRotation = endRotation;
			this.endScale = endScale;
		}

		public BoneShape(Transform bone, Vector3 endPosition, Vector3 endRotation)
		{
			this.bone = bone;
			this.endPosition = endPosition;
			this.endRotation = endRotation;
			endScale = bone.localScale;
		}

		public BoneShape()
		{
		}
	}
	[Serializable]
	public class EmotionMarker
	{
		[SerializeField]
		public string emotion;

		[SerializeField]
		public bool isMixer;

		[SerializeField]
		public EmotionMixer mixer;

		[SerializeField]
		public float startTime;

		[SerializeField]
		public float endTime;

		[SerializeField]
		public float blendInTime;

		[SerializeField]
		public float blendOutTime;

		[SerializeField]
		public bool blendToMarker;

		[SerializeField]
		public bool blendFromMarker;

		[SerializeField]
		public bool customBlendIn;

		[SerializeField]
		public bool customBlendOut;

		[SerializeField]
		public float intensity = 1f;

		[SerializeField]
		public bool continuousVariation;

		[SerializeField]
		public float variationFrequency = 0.5f;

		[SerializeField]
		public float intensityVariation = 0.35f;

		[SerializeField]
		public float blendableVariation = 0.1f;

		[SerializeField]
		public float bonePositionVariation = 0.1f;

		[SerializeField]
		public float boneRotationVariation = 0.1f;

		public bool invalid;

		public EmotionMarker(string emotion, float startTime, float endTime, float blendInTime, float blendOutTime, bool blendToMarker, bool blendFromMarker, bool customBlendIn, bool customBlendOut)
		{
			this.emotion = emotion;
			this.startTime = startTime;
			this.endTime = endTime;
			this.blendInTime = blendInTime;
			this.blendOutTime = blendOutTime;
			this.blendToMarker = blendToMarker;
			this.blendFromMarker = blendFromMarker;
			this.customBlendIn = customBlendIn;
			this.customBlendOut = customBlendOut;
		}

		public EmotionMarker(EmotionMixer mixer, float startTime, float endTime, float blendInTime, float blendOutTime, bool blendToMarker, bool blendFromMarker, bool customBlendIn, bool customBlendOut)
		{
			isMixer = true;
			this.mixer = mixer;
			this.startTime = startTime;
			this.endTime = endTime;
			this.blendInTime = blendInTime;
			this.blendOutTime = blendOutTime;
			this.blendToMarker = blendToMarker;
			this.blendFromMarker = blendFromMarker;
			this.customBlendIn = customBlendIn;
			this.customBlendOut = customBlendOut;
		}

		public EmotionMarker(string emotion, float startTime, float endTime, float blendInTime, float blendOutTime, bool blendToMarker, bool blendFromMarker, bool customBlendIn, bool customBlendOut, float intensity)
		{
			this.emotion = emotion;
			this.startTime = startTime;
			this.endTime = endTime;
			this.blendInTime = blendInTime;
			this.blendOutTime = blendOutTime;
			this.blendToMarker = blendToMarker;
			this.blendFromMarker = blendFromMarker;
			this.customBlendIn = customBlendIn;
			this.customBlendOut = customBlendOut;
			this.intensity = intensity;
		}

		public EmotionMarker CreateCopy()
		{
			return new EmotionMarker(emotion, startTime, endTime, blendInTime, blendOutTime, blendToMarker, blendFromMarker, customBlendIn, customBlendOut, intensity)
			{
				isMixer = isMixer,
				mixer = mixer,
				blendableVariation = blendableVariation,
				bonePositionVariation = bonePositionVariation,
				boneRotationVariation = boneRotationVariation,
				intensityVariation = intensityVariation,
				continuousVariation = continuousVariation
			};
		}
	}
	[Serializable]
	public class EmotionMixer
	{
		[Serializable]
		public struct EmotionComponent
		{
			public string emotion;

			public float weight;

			public EmotionComponent(string emotion, float weight)
			{
				this.emotion = emotion;
				this.weight = weight;
			}
		}

		public enum MixingMode
		{
			Normal,
			Additive
		}

		[SerializeField]
		public List<EmotionComponent> emotions;

		[SerializeField]
		public MixingMode mixingMode;

		public UnityEngine.Color displayColor;

		public EmotionMixer()
		{
			emotions = new List<EmotionComponent>();
			displayColor = new UnityEngine.Color(0f, 0f, 0f);
		}

		public EmotionShape GetShape(LipSync character)
		{
			EmotionShape emotionShape = new EmotionShape("Mixed");
			if (!character)
			{
				return emotionShape;
			}
			if (!character.blendSystem)
			{
				return emotionShape;
			}
			Dictionary<string, EmotionShape> dictionary = new Dictionary<string, EmotionShape>();
			foreach (EmotionShape emotion in character.emotions)
			{
				dictionary.Add(emotion.emotion, emotion);
			}
			for (int i = 0; i < emotions.Count; i++)
			{
				if (!dictionary.ContainsKey(emotions[i].emotion))
				{
					continue;
				}
				EmotionShape emotionShape2 = dictionary[emotions[i].emotion];
				for (int j = 0; j < emotionShape2.blendShapes.Count; j++)
				{
					if (emotionShape.blendShapes.Contains(emotionShape2.blendShapes[j]))
					{
						Mathf.Clamp(emotionShape.weights[emotionShape.blendShapes.IndexOf(emotionShape2.blendShapes[j])] += emotionShape2.weights[j] * emotions[i].weight, character.blendSystem.blendRangeLow, character.blendSystem.blendRangeHigh);
						continue;
					}
					emotionShape.blendShapes.Add(emotionShape2.blendShapes[j]);
					emotionShape.weights.Add(emotionShape2.weights[j] * emotions[i].weight);
				}
				for (int k = 0; k < emotionShape2.bones.Count; k++)
				{
					BoneShape boneShape = emotionShape2.bones[k];
					if (emotionShape.HasBone(boneShape.bone))
					{
						emotionShape.bones[emotionShape.IndexOfBone(boneShape.bone)].endPosition += boneShape.endPosition * emotions[i].weight;
						emotionShape.bones[emotionShape.IndexOfBone(boneShape.bone)].endRotation += boneShape.endRotation * emotions[i].weight;
					}
					else
					{
						emotionShape.bones.Add(new BoneShape(boneShape.bone, boneShape.endPosition * emotions[i].weight, boneShape.endRotation * emotions[i].weight));
					}
				}
			}
			return emotionShape;
		}

		public void SetWeight(int index, float weight)
		{
			SetWeight(index, weight, bypassMinChecks: false);
		}

		public void SetWeight(int index, float weight, bool bypassMinChecks)
		{
			if (mixingMode == MixingMode.Additive)
			{
				emotions[index] = new EmotionComponent(emotions[index].emotion, weight);
				return;
			}
			if (!bypassMinChecks)
			{
				weight = Mathf.Clamp(weight, 0.01f, 1f);
			}
			float num = 0f;
			float[] array = new float[emotions.Count];
			if (emotions.Count == 1)
			{
				emotions[index] = new EmotionComponent(emotions[index].emotion, 1f);
				return;
			}
			for (int i = 0; i < emotions.Count; i++)
			{
				array[i] = emotions[i].weight;
				if (i != index)
				{
					num += emotions[i].weight;
				}
			}
			emotions[index] = new EmotionComponent(emotions[index].emotion, weight);
			float num2 = num - (weight - array[index]);
			for (int j = 0; j < emotions.Count; j++)
			{
				if (j == index)
				{
					continue;
				}
				float num3 = num2 * (emotions[j].weight / num);
				if (num3 > 0.02f || bypassMinChecks)
				{
					emotions[j] = new EmotionComponent(emotions[j].emotion, num3);
					continue;
				}
				for (int k = 0; k < emotions.Count; k++)
				{
					emotions[k] = new EmotionComponent(emotions[k].emotion, array[k]);
				}
				break;
			}
		}
	}
	[Serializable]
	public class EmotionShape : Shape
	{
		[SerializeField]
		public string emotion;

		public EmotionShape(string eEmotion)
		{
			emotion = eEmotion;
			blendShapes = new List<int>();
			weights = new List<float>();
			bones = new List<BoneShape>();
		}
	}
	[Serializable]
	public class GestureMarker
	{
		[SerializeField]
		public string gesture;

		[SerializeField]
		public float time;

		public GestureMarker(string gesture, float time)
		{
			this.gesture = gesture;
			this.time = time;
		}

		public GestureMarker CreateCopy()
		{
			return new GestureMarker(gesture, time);
		}
	}
	public class LipSyncData : ScriptableObject
	{
		[SerializeField]
		public AudioClip clip;

		[SerializeField]
		public PhonemeMarker[] phonemeData;

		[SerializeField]
		public EmotionMarker[] emotionData;

		[SerializeField]
		public GestureMarker[] gestureData;

		[SerializeField]
		public float version;

		[SerializeField]
		public float length;

		[SerializeField]
		public string transcript;

		public LipSyncData()
		{
		}

		public LipSyncData(AudioClip clip, PhonemeMarker[] pData, EmotionMarker[] eData, GestureMarker[] gData)
		{
			this.clip = clip;
			phonemeData = pData;
			emotionData = eData;
			gestureData = gData;
			length = clip.length;
		}

		public LipSyncData(AudioClip clip, PhonemeMarker[] pData, EmotionMarker[] eData, GestureMarker[] gData, float length)
		{
			this.clip = clip;
			phonemeData = pData;
			emotionData = eData;
			gestureData = gData;
			this.length = length;
		}
	}
	public static class LipSyncExtensions
	{
		public static Transform FindDeepChild(this Transform aParent, string aName)
		{
			Transform transform = aParent.Find(aName);
			if (transform != null)
			{
				return transform;
			}
			foreach (Transform item in aParent)
			{
				transform = item.FindDeepChild(aName);
				if (transform != null)
				{
					return transform;
				}
			}
			return null;
		}

		public static Vector3 InverseTransformEulerAngle(this Transform transform, Vector3 eulerAngle)
		{
			return (eulerAngle - transform.eulerAngles).ToPositiveEuler();
		}

		public static Vector3 TransformEulerAngle(this Transform transform, Vector3 eulerAngle)
		{
			return ClampRange(eulerAngle + transform.eulerAngles);
		}

		public static Vector3 ToPositiveEuler(this Vector3 eulerAngle)
		{
			float num = eulerAngle.x;
			float num2 = eulerAngle.y;
			float num3 = eulerAngle.z;
			if (num < 0f)
			{
				num = 360f + num;
			}
			if (num2 < 0f)
			{
				num2 = 360f + num2;
			}
			if (num3 < 0f)
			{
				num3 = 360f + num3;
			}
			return new Vector3(num, num2, num3);
		}

		public static Vector3 ToNegativeEuler(this Vector3 eulerAngle)
		{
			float num = eulerAngle.x;
			float num2 = eulerAngle.y;
			float num3 = eulerAngle.z;
			if (num > 180f)
			{
				num -= 360f;
			}
			if (num2 > 180f)
			{
				num2 -= 360f;
			}
			if (num3 > 180f)
			{
				num3 -= 360f;
			}
			return new Vector3(num, num2, num3);
		}

		private static Vector3 ClampRange(Vector3 eulerAngle)
		{
			float num = eulerAngle.x;
			float num2 = eulerAngle.y;
			float num3 = eulerAngle.z;
			if (num > 360f)
			{
				num -= 360f;
			}
			if (num2 > 360f)
			{
				num2 -= 360f;
			}
			if (num3 > 360f)
			{
				num3 -= 360f;
			}
			return new Vector3(num, num2, num3).ToPositiveEuler();
		}

		public static EmotionMarker PreviousMarker(this List<EmotionMarker> list, EmotionMarker current)
		{
			int num = list.IndexOf(current) - 1;
			if (num >= 0)
			{
				return list[num];
			}
			return null;
		}

		public static EmotionMarker NextMarker(this List<EmotionMarker> list, EmotionMarker current)
		{
			int num = list.IndexOf(current) + 1;
			if (num < list.Count)
			{
				return list[num];
			}
			return null;
		}
	}
	public class LipSyncPreset : ScriptableObject
	{
		[Serializable]
		public struct PhonemeShapeInfo
		{
			[SerializeField]
			public string phonemeName;

			[SerializeField]
			[Obsolete("Please use PhonemeShapeInfo.phonemeName")]
			public Phoneme phoneme;

			[SerializeField]
			public BlendableInfo[] blendables;

			[SerializeField]
			public BoneInfo[] bones;
		}

		[Serializable]
		public struct EmotionShapeInfo
		{
			[SerializeField]
			public string emotion;

			[SerializeField]
			public BlendableInfo[] blendables;

			[SerializeField]
			public BoneInfo[] bones;
		}

		[Serializable]
		public struct BlendableInfo
		{
			[SerializeField]
			public int blendableNumber;

			[SerializeField]
			public string blendableName;

			[SerializeField]
			public float weight;
		}

		[Serializable]
		public struct BoneInfo
		{
			[SerializeField]
			public string path;

			[SerializeField]
			public string name;

			[SerializeField]
			public Vector3 localPosition;

			[SerializeField]
			public Vector3 localRotation;

			[SerializeField]
			public bool lockPosition;

			[SerializeField]
			public bool lockRotation;
		}

		[SerializeField]
		public PhonemeShapeInfo[] phonemeShapes;

		[SerializeField]
		public EmotionShapeInfo[] emotionShapes;

		public int FindBlendable(BlendableInfo blendable, BlendSystem blendSystem)
		{
			if (!string.IsNullOrEmpty(blendable.blendableName))
			{
				string text = blendable.blendableName;
				if (text.Contains("(" + blendable.blendableNumber + ")"))
				{
					string[] array = text.Split(new string[1] { "(" + blendable.blendableNumber + ")" }, StringSplitOptions.RemoveEmptyEntries);
					if (array.Length != 0)
					{
						text = array[0];
					}
				}
				string[] blendables = blendSystem.GetBlendables();
				for (int i = 0; i < blendables.Length; i++)
				{
					string text2 = blendables[i];
					if (text2.Contains("(" + i + ")"))
					{
						string[] array2 = text2.Split(new string[1] { "(" + i + ")" }, StringSplitOptions.RemoveEmptyEntries);
						if (array2.Length != 0)
						{
							text2 = array2[0];
						}
					}
					if (text2 == text)
					{
						return i;
					}
				}
			}
			if (blendable.blendableNumber < blendSystem.blendableCount)
			{
				if (!string.IsNullOrEmpty(blendable.blendableName) && blendable.blendableName != blendSystem.GetBlendables()[blendable.blendableNumber])
				{
					UnityEngine.Debug.LogWarning("[LipSync] Blendable " + blendable.blendableName + " used in the '" + base.name + "' preset couldn't be matched based on name, and the blendable at the same index in the " + blendSystem.GetType().Name + " has a different name. This may not be the shape you were expecting.");
				}
				return blendable.blendableNumber;
			}
			return -1;
		}

		public Transform FindBone(BoneInfo bone, Transform searchRoot)
		{
			Transform transform = searchRoot.Find(bone.path + bone.name);
			if (transform != null)
			{
				return transform;
			}
			return searchRoot.FindDeepChild(bone.name);
		}

		public void CreateFromShapes(PhonemeShape[] phonemes, EmotionShape[] emotions, BlendSystem blendSystem)
		{
			phonemeShapes = new PhonemeShapeInfo[phonemes.Length];
			emotionShapes = new EmotionShapeInfo[emotions.Length];
			for (int i = 0; i < phonemeShapes.Length; i++)
			{
				phonemeShapes[i] = default(PhonemeShapeInfo);
				phonemeShapes[i].phonemeName = phonemes[i].phonemeName;
				phonemeShapes[i].blendables = new BlendableInfo[phonemes[i].blendShapes.Count];
				for (int j = 0; j < phonemeShapes[i].blendables.Length; j++)
				{
					phonemeShapes[i].blendables[j].blendableNumber = phonemes[i].blendShapes[j];
					phonemeShapes[i].blendables[j].weight = phonemes[i].weights[j];
					if (blendSystem != null)
					{
						phonemeShapes[i].blendables[j].blendableName = blendSystem.GetBlendables()[phonemes[i].blendShapes[j]];
					}
				}
				phonemeShapes[i].bones = new BoneInfo[phonemes[i].bones.Count];
				for (int k = 0; k < phonemeShapes[i].bones.Length; k++)
				{
					phonemeShapes[i].bones[k].name = phonemes[i].bones[k].bone.name;
					phonemeShapes[i].bones[k].localPosition = phonemes[i].bones[k].endPosition;
					phonemeShapes[i].bones[k].localRotation = phonemes[i].bones[k].endRotation;
					phonemeShapes[i].bones[k].lockPosition = phonemes[i].bones[k].lockPosition;
					phonemeShapes[i].bones[k].lockRotation = phonemes[i].bones[k].lockRotation;
				}
			}
			for (int l = 0; l < emotionShapes.Length; l++)
			{
				emotionShapes[l] = default(EmotionShapeInfo);
				emotionShapes[l].emotion = emotions[l].emotion;
				emotionShapes[l].blendables = new BlendableInfo[emotions[l].blendShapes.Count];
				for (int m = 0; m < emotionShapes[l].blendables.Length; m++)
				{
					emotionShapes[l].blendables[m].blendableNumber = emotions[l].blendShapes[m];
					emotionShapes[l].blendables[m].weight = emotions[l].weights[m];
					if (blendSystem != null)
					{
						emotionShapes[l].blendables[m].blendableName = blendSystem.GetBlendables()[emotions[l].blendShapes[m]];
					}
				}
				emotionShapes[l].bones = new BoneInfo[emotions[l].bones.Count];
				for (int n = 0; n < emotionShapes[l].bones.Length; n++)
				{
					emotionShapes[l].bones[n].name = emotions[l].bones[n].bone.name;
					emotionShapes[l].bones[n].localPosition = emotions[l].bones[n].endPosition;
					emotionShapes[l].bones[n].localRotation = emotions[l].bones[n].endRotation;
					emotionShapes[l].bones[n].lockPosition = emotions[l].bones[n].lockPosition;
					emotionShapes[l].bones[n].lockRotation = emotions[l].bones[n].lockRotation;
				}
			}
		}
	}
	public class LipSyncProject : ScriptableObject
	{
		[SerializeField]
		public string[] emotions;

		[SerializeField]
		public UnityEngine.Color[] emotionColors;

		[SerializeField]
		public List<string> gestures = new List<string>();

		[SerializeField]
		public PhonemeSet phonemeSet;
	}
	[Serializable]
	public class PhonemeMarker
	{
		[SerializeField]
		[Obsolete("Use PhonemeMarker.phonemeNumber instead.")]
		public Phoneme phoneme;

		[SerializeField]
		public int phonemeNumber;

		[SerializeField]
		public float time;

		[SerializeField]
		public float intensity = 1f;

		[SerializeField]
		public bool sustain;

		[SerializeField]
		public bool useRandomness;

		[SerializeField]
		public float intensityRandomness = 0.1f;

		[SerializeField]
		public float blendableRandomness = 0.3f;

		[SerializeField]
		public float bonePositionRandomness = 0.3f;

		[SerializeField]
		public float boneRotationRandomness = 0.3f;

		public PhonemeMarker(int phonemeNumber, float time, float intensity, bool sustain)
		{
			this.phonemeNumber = phonemeNumber;
			this.time = time;
			this.intensity = intensity;
			this.sustain = sustain;
		}

		public PhonemeMarker(int phonemeNumber, float time)
		{
			this.phonemeNumber = phonemeNumber;
			this.time = time;
		}

		[Obsolete("Use int constructors instead.")]
		public PhonemeMarker(Phoneme phoneme, float time, float intensity, bool sustain)
		{
			this.phoneme = phoneme;
			this.time = time;
			this.intensity = intensity;
			this.sustain = sustain;
		}

		[Obsolete("Use int constructors instead.")]
		public PhonemeMarker(Phoneme phoneme, float time)
		{
			this.phoneme = phoneme;
			this.time = time;
		}

		public PhonemeMarker CreateCopy()
		{
			return new PhonemeMarker(phonemeNumber, time, intensity, sustain)
			{
				blendableRandomness = blendableRandomness,
				bonePositionRandomness = bonePositionRandomness,
				boneRotationRandomness = boneRotationRandomness,
				intensityRandomness = intensityRandomness,
				useRandomness = useRandomness
			};
		}
	}
	[Serializable]
	[CreateAssetMenu(fileName = "New Phoneme Set", menuName = "LipSync Pro/Phoneme Set")]
	public class PhonemeSet : ScriptableObject
	{
		[Serializable]
		public class PhonemeCollection
		{
			public List<string> phonemeNames;

			public int Length => phonemeNames.Count;

			public Phoneme this[int index] => new Phoneme(phonemeNames[index], index, Mathf.RoundToInt(Mathf.Pow(2f, index)));

			public PhonemeCollection()
			{
				phonemeNames = new List<string>();
			}
		}

		public struct Phoneme
		{
			public string name { get; private set; }

			public int number { get; private set; }

			public int flag { get; private set; }

			public Phoneme(string name, int number, int flag)
			{
				this = default(Phoneme);
				this.name = name;
				this.number = number;
				this.flag = flag;
			}
		}

		[SerializeField]
		public string scriptingName;

		[SerializeField]
		public PhonemeCollection phonemes = new PhonemeCollection();

		[SerializeField]
		public Texture2D[] guideImages;
	}
	[Serializable]
	public class PhonemeShape : Shape
	{
		[SerializeField]
		public string phonemeName;

		[SerializeField]
		[Obsolete("Use phonemeName instead.")]
		public Phoneme phoneme;

		public PhonemeShape(string phonemeName)
		{
			this.phonemeName = phonemeName;
			blendShapes = new List<int>();
			weights = new List<float>();
			bones = new List<BoneShape>();
		}

		[Obsolete("Use the new string constructor instead.")]
		public PhonemeShape(Phoneme ePhoneme)
		{
			phoneme = ePhoneme;
			blendShapes = new List<int>();
			weights = new List<float>();
			bones = new List<BoneShape>();
		}
	}
	[Serializable]
	public class Shape
	{
		[SerializeField]
		public List<int> blendShapes = new List<int>();

		[SerializeField]
		public List<string> blendableNames = new List<string>();

		[SerializeField]
		public List<float> weights = new List<float>();

		[SerializeField]
		public List<BoneShape> bones = new List<BoneShape>();

		[SerializeField]
		public bool verified = true;

		public bool HasBone(Transform bone)
		{
			for (int i = 0; i < bones.Count; i++)
			{
				if (bones[i].bone == bone)
				{
					return true;
				}
			}
			return false;
		}

		public int IndexOfBone(Transform bone)
		{
			for (int i = 0; i < bones.Count; i++)
			{
				if (bones[i].bone == bone)
				{
					return i;
				}
			}
			return -1;
		}
	}
	[Serializable]
	public class TransformAnimationCurve
	{
		public struct TransformKeyframe
		{
			public float time;

			public Quaternion rotation;

			public Vector3 position;

			public Vector3 scale;

			public float inTangent;

			public float outTangent;

			public TransformKeyframe(float time, Vector3 position, Quaternion rotation, Vector3 scale, float inTangent, float outTangent)
			{
				this.time = time;
				this.position = position;
				this.rotation = rotation;
				this.scale = scale;
				this.inTangent = inTangent;
				this.outTangent = outTangent;
			}
		}

		private AnimationCurve _posX;

		private AnimationCurve _posY;

		private AnimationCurve _posZ;

		private AnimationCurve _rotX;

		private AnimationCurve _rotY;

		private AnimationCurve _rotZ;

		private AnimationCurve _rotW;

		private AnimationCurve _scaleX;

		private AnimationCurve _scaleY;

		private AnimationCurve _scaleZ;

		public TransformKeyframe[] keys
		{
			get
			{
				List<TransformKeyframe> list = new List<TransformKeyframe>();
				Keyframe[] array = _posX.keys;
				Keyframe[] array2 = _posY.keys;
				Keyframe[] array3 = _posZ.keys;
				Keyframe[] array4 = _rotX.keys;
				Keyframe[] array5 = _rotY.keys;
				Keyframe[] array6 = _rotZ.keys;
				Keyframe[] array7 = _rotW.keys;
				Keyframe[] array8 = _scaleX.keys;
				Keyframe[] array9 = _scaleY.keys;
				Keyframe[] array10 = _scaleZ.keys;
				for (int i = 0; i < _posX.length; i++)
				{
					list.Add(new TransformKeyframe(array[i].time, new Vector3(array[i].value, array2[i].value, array3[i].value), new Quaternion(array4[i].value, array5[i].value, array6[i].value, array7[i].value), new Vector3(array8[i].value, array9[i].value, array10[i].value), array[i].inTangent, array[i].outTangent));
				}
				return list.ToArray();
			}
		}

		public int length => _posX.length;

		public WrapMode postWrapMode
		{
			get
			{
				return _posX.postWrapMode;
			}
			set
			{
				_posX.postWrapMode = value;
				_posY.postWrapMode = value;
				_posZ.postWrapMode = value;
				_rotX.postWrapMode = value;
				_rotY.postWrapMode = value;
				_rotZ.postWrapMode = value;
				_rotW.postWrapMode = value;
				_scaleX.postWrapMode = value;
				_scaleY.postWrapMode = value;
				_scaleZ.postWrapMode = value;
			}
		}

		public WrapMode preWrapMode
		{
			get
			{
				return _posX.preWrapMode;
			}
			set
			{
				_posX.preWrapMode = value;
				_posY.preWrapMode = value;
				_posZ.preWrapMode = value;
				_rotX.preWrapMode = value;
				_rotY.preWrapMode = value;
				_rotZ.preWrapMode = value;
				_rotW.preWrapMode = value;
				_scaleX.preWrapMode = value;
				_scaleY.preWrapMode = value;
				_scaleZ.preWrapMode = value;
			}
		}

		public int AddKey(float time, Vector3 position, Quaternion rotation, Vector3 scale, float inTangent, float outTangent)
		{
			int result = _posX.AddKey(new Keyframe(time, position.x, inTangent, outTangent));
			_posY.AddKey(new Keyframe(time, position.y, inTangent, outTangent));
			_posZ.AddKey(new Keyframe(time, position.z, inTangent, outTangent));
			Quaternion quaternion = Quaternion.Euler(CentreAngles(rotation.eulerAngles));
			_rotX.AddKey(new Keyframe(time, quaternion.x, inTangent, outTangent));
			_rotY.AddKey(new Keyframe(time, quaternion.y, inTangent, outTangent));
			_rotZ.AddKey(new Keyframe(time, quaternion.z, inTangent, outTangent));
			_rotW.AddKey(new Keyframe(time, quaternion.w, inTangent, outTangent));
			_scaleX.AddKey(new Keyframe(time, scale.x, inTangent, outTangent));
			_scaleY.AddKey(new Keyframe(time, scale.y, inTangent, outTangent));
			_scaleZ.AddKey(new Keyframe(time, scale.z, inTangent, outTangent));
			return result;
		}

		public int AddKey(float time, Vector3 position, Quaternion rotation, float inTangent, float outTangent)
		{
			int result = _posX.AddKey(new Keyframe(time, position.x, inTangent, outTangent));
			_posY.AddKey(new Keyframe(time, position.y, inTangent, outTangent));
			_posZ.AddKey(new Keyframe(time, position.z, inTangent, outTangent));
			Quaternion quaternion = Quaternion.Euler(CentreAngles(rotation.eulerAngles));
			_rotX.AddKey(new Keyframe(time, quaternion.x, inTangent, outTangent));
			_rotY.AddKey(new Keyframe(time, quaternion.y, inTangent, outTangent));
			_rotZ.AddKey(new Keyframe(time, quaternion.z, inTangent, outTangent));
			_rotW.AddKey(new Keyframe(time, quaternion.w, inTangent, outTangent));
			return result;
		}

		public int AddKey(float time, Quaternion rotation, float inTangent, float outTangent)
		{
			Quaternion quaternion = Quaternion.Euler(CentreAngles(rotation.eulerAngles));
			int result = _rotX.AddKey(new Keyframe(time, quaternion.x, inTangent, outTangent));
			_rotY.AddKey(new Keyframe(time, quaternion.y, inTangent, outTangent));
			_rotZ.AddKey(new Keyframe(time, quaternion.z, inTangent, outTangent));
			_rotW.AddKey(new Keyframe(time, quaternion.w, inTangent, outTangent));
			return result;
		}

		public int AddKey(float time, Vector3 position, float inTangent, float outTangent)
		{
			int result = _posX.AddKey(new Keyframe(time, position.x, inTangent, outTangent));
			_posY.AddKey(new Keyframe(time, position.y, inTangent, outTangent));
			_posZ.AddKey(new Keyframe(time, position.z, inTangent, outTangent));
			return result;
		}

		public int AddKey(float time, Vector3 position, Quaternion rotation, Vector3 scale)
		{
			int result = _posX.AddKey(time, position.x);
			_posY.AddKey(time, position.y);
			_posZ.AddKey(time, position.z);
			Quaternion quaternion = Quaternion.Euler(CentreAngles(rotation.eulerAngles));
			_rotX.AddKey(time, quaternion.x);
			_rotY.AddKey(time, quaternion.y);
			_rotZ.AddKey(time, quaternion.z);
			_rotW.AddKey(time, quaternion.w);
			_scaleX.AddKey(time, scale.x);
			_scaleY.AddKey(time, scale.y);
			_scaleZ.AddKey(time, scale.z);
			return result;
		}

		public int AddKey(float time, Vector3 position, Quaternion rotation)
		{
			int result = _posX.AddKey(time, position.x);
			_posY.AddKey(time, position.y);
			_posZ.AddKey(time, position.z);
			Quaternion quaternion = Quaternion.Euler(CentreAngles(rotation.eulerAngles));
			_rotX.AddKey(time, quaternion.x);
			_rotY.AddKey(time, quaternion.y);
			_rotZ.AddKey(time, quaternion.z);
			_rotW.AddKey(time, quaternion.w);
			return result;
		}

		public int AddKey(float time, Quaternion rotation)
		{
			Quaternion quaternion = Quaternion.Euler(CentreAngles(rotation.eulerAngles));
			int result = _rotX.AddKey(time, quaternion.x);
			_rotY.AddKey(time, quaternion.y);
			_rotZ.AddKey(time, quaternion.z);
			_rotW.AddKey(time, quaternion.w);
			return result;
		}

		public int AddKey(float time, Vector3 position)
		{
			int result = _posX.AddKey(time, position.x);
			_posY.AddKey(time, position.y);
			_posZ.AddKey(time, position.z);
			return result;
		}

		public int AddKey(TransformKeyframe keyframe)
		{
			int result = _posX.AddKey(new Keyframe(keyframe.time, keyframe.position.x, keyframe.inTangent, keyframe.outTangent));
			_posY.AddKey(new Keyframe(keyframe.time, keyframe.position.y, keyframe.inTangent, keyframe.outTangent));
			_posZ.AddKey(new Keyframe(keyframe.time, keyframe.position.z, keyframe.inTangent, keyframe.outTangent));
			Quaternion quaternion = Quaternion.Euler(CentreAngles(keyframe.rotation.eulerAngles));
			_rotX.AddKey(new Keyframe(keyframe.time, quaternion.x, keyframe.inTangent, keyframe.outTangent));
			_rotY.AddKey(new Keyframe(keyframe.time, quaternion.y, keyframe.inTangent, keyframe.outTangent));
			_rotZ.AddKey(new Keyframe(keyframe.time, quaternion.z, keyframe.inTangent, keyframe.outTangent));
			_rotW.AddKey(new Keyframe(keyframe.time, quaternion.w, keyframe.inTangent, keyframe.outTangent));
			return result;
		}

		public Vector3 EvaluateScale(float time)
		{
			float x = _scaleX.Evaluate(time);
			float y = _scaleY.Evaluate(time);
			float z = _scaleZ.Evaluate(time);
			return new Vector3(x, y, z);
		}

		public Vector3 EvaluatePosition(float time)
		{
			float x = _posX.Evaluate(time);
			float y = _posY.Evaluate(time);
			float z = _posZ.Evaluate(time);
			return new Vector3(x, y, z);
		}

		public Quaternion EvaluateRotation(float time)
		{
			float x = _rotX.Evaluate(time);
			float y = _rotY.Evaluate(time);
			float z = _rotZ.Evaluate(time);
			float w = _rotW.Evaluate(time);
			return new Quaternion(x, y, z, w);
		}

		public TransformAnimationCurve()
		{
			_posX = new AnimationCurve();
			_posY = new AnimationCurve();
			_posZ = new AnimationCurve();
			_scaleX = new AnimationCurve();
			_scaleY = new AnimationCurve();
			_scaleZ = new AnimationCurve();
			_rotX = new AnimationCurve();
			_rotY = new AnimationCurve();
			_rotZ = new AnimationCurve();
			_rotW = new AnimationCurve();
		}

		private Vector3 CentreAngles(Vector3 euler)
		{
			return euler.ToNegativeEuler();
		}

		public void FixQuaternionContinuity()
		{
			Keyframe[] array = _rotX.keys;
			Keyframe[] array2 = _rotY.keys;
			Keyframe[] array3 = _rotZ.keys;
			Keyframe[] array4 = _rotW.keys;
			if (array.Length == 0)
			{
				return;
			}
			Quaternion b = new Quaternion(array[0].value, array2[0].value, array3[0].value, array4[0].value);
			for (int i = 0; i < array.Length; i++)
			{
				Quaternion quaternion = new Quaternion(array[i].value, array2[i].value, array3[i].value, array4[i].value);
				if (Quaternion.Dot(quaternion, b) < 0f)
				{
					quaternion = Quaternion.Inverse(quaternion);
				}
				array[i].value = quaternion.x;
				array2[i].value = quaternion.y;
				array3[i].value = quaternion.z;
				array4[i].value = quaternion.w;
				b = quaternion;
			}
			_rotX.keys = array;
			_rotY.keys = array2;
			_rotZ.keys = array3;
			_rotW.keys = array4;
		}
	}
	[AddComponentMenu("Rogo Digital/LipSync Pro")]
	[DisallowMultipleComponent]
	[HelpURL("http://updates.rogodigital.com/lipsync-api/class_rogo_digital_1_1_lipsync_1_1_lip_sync.html")]
	public class LipSync : BlendSystemUser
	{
		public delegate void ResetDelegate();

		public enum AnimationTimingMode
		{
			AudioPlayback,
			CustomTimer,
			FixedFrameRate
		}

		public enum CurveGenerationMode
		{
			Tight,
			Loose
		}

		public AudioSource audioSource;

		public bool useBones;

		public bool boneUpdateAnimation;

		[SerializeField]
		public List<PhonemeShape> phonemes = new List<PhonemeShape>();

		[SerializeField]
		public List<EmotionShape> emotions = new List<EmotionShape>();

		public bool playOnAwake;

		public bool loop;

		public LipSyncData defaultClip;

		public float defaultDelay;

		public bool scaleAudioSpeed = true;

		[SerializeField]
		private AnimationTimingMode m_animationTimingMode;

		public int frameRate = 30;

		public float restTime = 0.2f;

		public float restHoldTime = 0.4f;

		public CurveGenerationMode phonemeCurveGenerationMode = CurveGenerationMode.Loose;

		public CurveGenerationMode emotionCurveGenerationMode;

		public bool keepEmotionWhenFinished;

		public Animator gesturesAnimator;

		public int gesturesLayer;

		public List<GestureInstance> gestures;

		public UnityEvent onFinishedPlaying;

		private AudioClip audioClip;

		private bool ready;

		private Dictionary<string, EmotionShape> emotionCache;

		private int currentFileID;

		private LipSyncData lastClip;

		private float emotionBlendTime;

		private float emotionTimer;

		private bool changingEmotion;

		private int customEmotion = -1;

		private float customTimer;

		private bool isDelaying;

		private List<PhonemeMarker> phonemeMarkers;

		private List<EmotionMarker> emotionMarkers;

		private List<GestureMarker> gestureMarkers;

		private float fileLength;

		private int nextGesture;

		private List<int> indexBlendables;

		public List<AnimationCurve> animCurves;

		private List<Transform> bones;

		private List<TransformAnimationCurve> boneCurves;

		private List<Vector3> boneNeutralPositions;

		private List<Vector3> boneNeutralScales;

		private List<Quaternion> boneNeutralRotations;

		public ResetDelegate reset;

		public float lastUsedVersion;

		public AnimationTimingMode animationTimingMode
		{
			get
			{
				return m_animationTimingMode;
			}
			set
			{
				m_animationTimingMode = value;
			}
		}

		public bool IsPlaying { get; private set; }

		public bool IsPaused { get; private set; }

		public bool IsStopping { get; private set; }

		public float CurrentTime
		{
			get
			{
				if (!IsPlaying)
				{
					return 0f;
				}
				if (animationTimingMode == AnimationTimingMode.AudioPlayback)
				{
					return audioSource.time;
				}
				return customTimer;
			}
		}

		private void Reset()
		{
			CleanUpBlendSystems();
			if (reset != null)
			{
				reset();
			}
		}

		private void Awake()
		{
			if (audioSource == null)
			{
				audioSource = GetComponent<AudioSource>();
			}
			if (audioSource == null)
			{
				UnityEngine.Debug.LogError("[LipSync - " + base.gameObject.name + "] No AudioSource specified or found.");
				return;
			}
			if (blendSystem == null)
			{
				UnityEngine.Debug.LogError("[LipSync - " + base.gameObject.name + "] No BlendSystem set.");
				return;
			}
			if (!blendSystem.isReady)
			{
				UnityEngine.Debug.LogError("[LipSync - " + base.gameObject.name + "] BlendSystem is not set up.");
				return;
			}
			ready = true;
			if (restTime < 0.1f)
			{
				UnityEngine.Debug.LogWarning("[LipSync - " + base.gameObject.name + "] Rest Time and/or Hold Time are lower than recommended and may cause animation errors. From LipSync 0.6, Rest Time is recommended to be 0.2 and Hold Time is recommended to be 0.1");
			}
			emotionCache = new Dictionary<string, EmotionShape>();
			foreach (EmotionShape emotion in emotions)
			{
				if (emotionCache.ContainsKey(emotion.emotion))
				{
					UnityEngine.Debug.LogWarning("[LipSync - " + base.gameObject.name + "] Project Settings contains more than 1 emotion called \"" + emotion.emotion + "\". Duplicates will be ignored.");
				}
				else
				{
					emotionCache.Add(emotion.emotion, emotion);
				}
			}
			if (gesturesAnimator != null)
			{
				foreach (GestureInstance gesture in gestures)
				{
					if (!gesture.IsValid(gesturesAnimator))
					{
						UnityEngine.Debug.LogWarning("[LipSync - " + base.gameObject.name + "] Animator does not contain a trigger called '" + gesture.triggerName + "'. This Gesture will be ignored.");
					}
				}
			}
			if (playOnAwake && defaultClip != null)
			{
				Play(defaultClip, defaultDelay);
			}
		}

		private void LateUpdate()
		{
			if ((!IsPlaying || IsPaused) && !changingEmotion && !IsStopping)
			{
				return;
			}
			if (scaleAudioSpeed && !changingEmotion)
			{
				audioSource.pitch = Time.timeScale;
			}
			if (isDelaying)
			{
				customTimer -= Time.deltaTime;
				if (customTimer <= 0f)
				{
					isDelaying = false;
				}
				return;
			}
			float num = 0f;
			if (IsPlaying || IsStopping)
			{
				if (animationTimingMode == AnimationTimingMode.AudioPlayback && audioClip != null && IsPlaying)
				{
					num = audioSource.time / audioClip.length;
				}
				else if (animationTimingMode == AnimationTimingMode.CustomTimer || (animationTimingMode == AnimationTimingMode.AudioPlayback && audioClip == null) || IsStopping)
				{
					customTimer += Time.deltaTime;
					num = customTimer / (IsStopping ? restHoldTime : fileLength);
				}
				else if (animationTimingMode == AnimationTimingMode.FixedFrameRate)
				{
					customTimer += 1f / (float)frameRate;
					num = customTimer / fileLength;
				}
				if (gestures.Count > 0 && nextGesture < gestureMarkers.Count && gesturesAnimator != null && !IsStopping && num >= gestureMarkers[nextGesture].time)
				{
					if (GetGesture(gestureMarkers[nextGesture].gesture) != null)
					{
						gesturesAnimator.SetTrigger(GetGesture(gestureMarkers[nextGesture].gesture).triggerName);
					}
					nextGesture++;
				}
			}
			else
			{
				emotionTimer += Time.deltaTime;
				num = emotionTimer / emotionBlendTime;
			}
			for (int i = 0; i < animCurves.Count; i++)
			{
				blendSystem.SetBlendableValue(indexBlendables[i], animCurves[i].Evaluate(num));
			}
			if (useBones && boneCurves != null)
			{
				for (int j = 0; j < boneCurves.Count; j++)
				{
					if (!boneUpdateAnimation)
					{
						bones[j].localPosition = boneCurves[j].EvaluatePosition(num);
						bones[j].localRotation = boneCurves[j].EvaluateRotation(num);
						bones[j].localScale = boneCurves[j].EvaluateScale(num);
						continue;
					}
					Vector3 vector = boneCurves[j].EvaluatePosition(num) - boneNeutralPositions[j];
					Vector3 vector2 = boneCurves[j].EvaluateRotation(num).eulerAngles - boneNeutralRotations[j].eulerAngles;
					Vector3 vector3 = boneCurves[j].EvaluateScale(num) - boneNeutralScales[j];
					bones[j].localPosition += vector;
					bones[j].localEulerAngles += vector2;
					bones[j].localScale += vector3;
				}
			}
			if (changingEmotion && num > 1f)
			{
				changingEmotion = false;
			}
			if (num >= 0.999f && !changingEmotion)
			{
				if (IsStopping)
				{
					IsStopping = false;
				}
				else if (loop)
				{
					onFinishedPlaying.Invoke();
					Stop(stopAudio: false);
					Play(lastClip);
				}
				else
				{
					Stop(stopAudio: false);
				}
			}
		}

		public void SetEmotion(string emotion, float blendTime)
		{
			if (IsPlaying || !ready || !base.enabled)
			{
				return;
			}
			EmotionShape emotionShape = null;
			if (emotion == "")
			{
				emotionShape = new EmotionShape("temp");
			}
			else
			{
				if (emotions.IndexOf(emotionCache[emotion]) == customEmotion)
				{
					return;
				}
				emotionShape = emotionCache[emotion];
			}
			animCurves = new List<AnimationCurve>();
			indexBlendables = new List<int>();
			if (useBones)
			{
				boneCurves = new List<TransformAnimationCurve>();
				bones = new List<Transform>();
			}
			for (int i = 0; i < emotionShape.blendShapes.Count; i++)
			{
				indexBlendables.Add(emotionShape.blendShapes[i]);
				animCurves.Add(new AnimationCurve());
			}
			if (useBones)
			{
				for (int j = 0; j < emotionShape.bones.Count; j++)
				{
					bones.Add(emotionShape.bones[j].bone);
					boneCurves.Add(new TransformAnimationCurve());
				}
			}
			if (customEmotion > -1)
			{
				for (int k = 0; k < emotions[customEmotion].blendShapes.Count; k++)
				{
					if (!indexBlendables.Contains(emotions[customEmotion].blendShapes[k]))
					{
						indexBlendables.Add(emotions[customEmotion].blendShapes[k]);
						animCurves.Add(new AnimationCurve());
					}
				}
				if (useBones)
				{
					for (int l = 0; l < emotions[customEmotion].bones.Count; l++)
					{
						if (!bones.Contains(emotions[customEmotion].bones[l].bone))
						{
							bones.Add(emotions[customEmotion].bones[l].bone);
							boneCurves.Add(new TransformAnimationCurve());
						}
					}
				}
			}
			if (customEmotion > -1)
			{
				for (int m = 0; m < emotions[customEmotion].blendShapes.Count; m++)
				{
					int index = indexBlendables.IndexOf(emotions[customEmotion].blendShapes[m]);
					animCurves[index].AddKey(new Keyframe(0f, blendSystem.GetBlendableValue(emotions[customEmotion].blendShapes[m]), 90f, 0f));
				}
				for (int n = 0; n < animCurves.Count; n++)
				{
					if (animCurves[n].keys.Length != 0)
					{
						if (emotionShape.blendShapes.Contains(indexBlendables[n]))
						{
							animCurves[n].AddKey(new Keyframe(1f, emotionShape.weights[emotionShape.blendShapes.IndexOf(indexBlendables[n])], 0f, 90f));
						}
						else
						{
							animCurves[n].AddKey(new Keyframe(1f, 0f, 0f, 90f));
						}
					}
					else
					{
						animCurves[n].AddKey(new Keyframe(0f, blendSystem.GetBlendableValue(indexBlendables[n]), 90f, 0f));
						int index2 = emotionShape.blendShapes.IndexOf(indexBlendables[n]);
						animCurves[n].AddKey(new Keyframe(1f, emotionShape.weights[index2], 0f, 90f));
					}
				}
				if (useBones && boneCurves != null)
				{
					for (int num = 0; num < emotions[customEmotion].bones.Count; num++)
					{
						int index3 = bones.IndexOf(emotions[customEmotion].bones[num].bone);
						boneCurves[index3].AddKey(0f, emotions[customEmotion].bones[num].bone.localPosition, emotions[customEmotion].bones[num].bone.localRotation, 90f, 0f);
					}
					for (int num2 = 0; num2 < boneCurves.Count; num2++)
					{
						if (boneCurves[num2].length > 0)
						{
							if (emotionShape.HasBone(bones[num2]))
							{
								boneCurves[num2].AddKey(1f, emotionShape.bones[emotionShape.IndexOfBone(bones[num2])].endPosition, Quaternion.Euler(emotionShape.bones[emotionShape.IndexOfBone(bones[num2])].endRotation), 0f, 90f);
							}
							else
							{
								boneCurves[num2].AddKey(1f, emotions[customEmotion].bones[emotions[customEmotion].IndexOfBone(bones[num2])].neutralPosition, Quaternion.Euler(emotions[customEmotion].bones[emotions[customEmotion].IndexOfBone(bones[num2])].neutralRotation), 0f, 90f);
							}
						}
						else
						{
							boneCurves[num2].AddKey(0f, bones[num2].localPosition, bones[num2].localRotation, 90f, 0f);
							int index4 = emotionShape.IndexOfBone(bones[num2]);
							boneCurves[num2].AddKey(1f, emotionShape.bones[index4].endPosition, Quaternion.Euler(emotionShape.bones[index4].endRotation), 0f, 90f);
						}
					}
				}
			}
			else
			{
				for (int num3 = 0; num3 < animCurves.Count; num3++)
				{
					animCurves[num3].AddKey(new Keyframe(0f, blendSystem.GetBlendableValue(indexBlendables[num3]), 90f, 0f));
					animCurves[num3].AddKey(new Keyframe(1f, emotionShape.weights[num3], 0f, 90f));
				}
				if (useBones && boneCurves != null)
				{
					for (int num4 = 0; num4 < boneCurves.Count; num4++)
					{
						boneCurves[num4].AddKey(0f, bones[num4].localPosition, bones[num4].localRotation, 90f, 0f);
						boneCurves[num4].AddKey(1f, emotionShape.bones[num4].endPosition, Quaternion.Euler(emotionShape.bones[num4].endRotation), 0f, 90f);
					}
				}
			}
			emotionTimer = 0f;
			emotionBlendTime = blendTime;
			customEmotion = emotions.IndexOf(emotionShape);
			changingEmotion = true;
		}

		public void ResetEmotion(float blendTime)
		{
			SetEmotion("", blendTime);
		}

		public void Play(LipSyncData dataFile, float delay)
		{
			if (!ready || !base.enabled)
			{
				return;
			}
			bool flag = true;
			if (dataFile.GetInstanceID() != currentFileID || customEmotion > -1)
			{
				flag = LoadData(dataFile);
			}
			if (!flag)
			{
				return;
			}
			ProcessData();
			if (gesturesAnimator != null && gestures != null)
			{
				if (gestures.Count > 0)
				{
					gesturesAnimator.SetLayerWeight(gesturesLayer, 1f);
				}
			}
			else if (dataFile.gestureData.Length != 0)
			{
				UnityEngine.Debug.Log("[LipSync - " + base.gameObject.name + "] Animator or Gestures are not set up. Gestures from this clip won't be played.");
			}
			IsPlaying = true;
			IsPaused = false;
			nextGesture = 0;
			IsStopping = false;
			if ((bool)audioClip && delay > 0f)
			{
				isDelaying = true;
				customTimer = delay;
			}
			else
			{
				isDelaying = false;
				customTimer = 0f;
			}
			if ((bool)audioClip && (bool)audioSource)
			{
				audioSource.PlayDelayed(delay);
			}
		}

		public void Play(LipSyncData dataFile)
		{
			Play(dataFile, 0f);
		}

		public void Play(TextAsset xmlFile, AudioClip clip, float delay)
		{
			if (ready && base.enabled)
			{
				LoadXML(xmlFile, clip);
				if (gesturesAnimator != null)
				{
					gesturesAnimator.SetLayerWeight(gesturesLayer, 1f);
				}
				IsPlaying = true;
				IsPaused = false;
				nextGesture = 0;
				IsStopping = false;
				ProcessData();
				if ((bool)audioClip && delay > 0f)
				{
					isDelaying = true;
					customTimer = delay;
				}
				else
				{
					isDelaying = false;
					customTimer = 0f;
				}
				audioSource.PlayDelayed(delay);
			}
		}

		public void Play(TextAsset xmlFile, AudioClip clip)
		{
			Play(xmlFile, clip, 0f);
		}

		public void PlayFromTime(LipSyncData dataFile, float delay, float time)
		{
			if (!ready || !base.enabled)
			{
				return;
			}
			bool flag = true;
			if (dataFile.GetInstanceID() != currentFileID || customEmotion > -1)
			{
				flag = LoadData(dataFile);
			}
			if (flag)
			{
				return;
			}
			if (time >= fileLength)
			{
				UnityEngine.Debug.LogError("[LipSync - " + base.gameObject.name + "] Couldn't play animation. Time parameter is greater than clip length.");
				return;
			}
			if (gesturesAnimator != null)
			{
				gesturesAnimator.SetLayerWeight(gesturesLayer, 1f);
			}
			IsPlaying = true;
			IsPaused = false;
			isDelaying = false;
			customTimer = 0f;
			nextGesture = 0;
			IsStopping = false;
			audioSource.Play();
			audioSource.time = time + delay;
		}

		public void PlayFromTime(LipSyncData dataFile, float time)
		{
			PlayFromTime(dataFile, 0f, time);
		}

		public void PlayFromTime(TextAsset xmlFile, AudioClip clip, float delay, float time)
		{
			if (!ready || !base.enabled)
			{
				return;
			}
			LoadXML(xmlFile, clip);
			if (time >= fileLength)
			{
				UnityEngine.Debug.LogError("[LipSync - " + base.gameObject.name + "] Couldn't play animation. Time parameter is greater than clip length.");
				return;
			}
			if (gesturesAnimator != null)
			{
				gesturesAnimator.SetLayerWeight(gesturesLayer, 1f);
			}
			IsPlaying = true;
			IsPaused = false;
			isDelaying = false;
			customTimer = 0f;
			nextGesture = 0;
			IsStopping = false;
			ProcessData();
			audioSource.Play();
			audioSource.time = time + delay;
		}

		public void PlayFromTime(TextAsset xmlFile, AudioClip clip, float time)
		{
			PlayFromTime(xmlFile, clip, 0f, time);
		}

		public void Pause()
		{
			if (IsPlaying && !IsPaused && base.enabled)
			{
				IsPaused = true;
				audioSource.Pause();
			}
		}

		public void Resume()
		{
			if (IsPlaying && IsPaused && base.enabled)
			{
				IsPaused = false;
				audioSource.UnPause();
			}
		}

		public void Stop(bool stopAudio)
		{
			if (!IsPlaying || !base.enabled)
			{
				return;
			}
			IsPlaying = false;
			IsPaused = false;
			isDelaying = false;
			IsStopping = true;
			customTimer = 0f;
			for (int i = 0; i < animCurves.Count; i++)
			{
				float value = animCurves[i].Evaluate(1f);
				float blendableValue = blendSystem.GetBlendableValue(indexBlendables[i]);
				animCurves[i] = new AnimationCurve(new Keyframe(0f, blendableValue), new Keyframe(1f, value));
			}
			if (useBones)
			{
				for (int j = 0; j < boneCurves.Count; j++)
				{
					Vector3 position = boneCurves[j].EvaluatePosition(1f);
					Vector3 scale = boneCurves[j].EvaluateScale(1f);
					Quaternion rotation = boneCurves[j].EvaluateRotation(1f);
					Vector3 localPosition = bones[j].localPosition;
					Vector3 localScale = bones[j].localScale;
					Quaternion localRotation = bones[j].localRotation;
					boneCurves[j] = new TransformAnimationCurve();
					boneCurves[j].AddKey(0f, localPosition, localRotation, localScale, 0f, 0f);
					boneCurves[j].AddKey(1f, position, rotation, scale, 0f, 0f);
				}
			}
			if (stopAudio)
			{
				audioSource.Stop();
			}
			onFinishedPlaying.Invoke();
		}

		public void PreviewAtTime(float time)
		{
			if (IsPlaying || !base.enabled || animCurves == null)
			{
				return;
			}
			if (indexBlendables == null || animCurves == null)
			{
				if (phonemeMarkers == null || emotionMarkers == null)
				{
					return;
				}
				ProcessData();
			}
			else if (indexBlendables.Count != animCurves.Count)
			{
				if (phonemeMarkers == null || emotionMarkers == null)
				{
					return;
				}
				ProcessData();
			}
			for (int i = 0; i < animCurves.Count; i++)
			{
				blendSystem.SetBlendableValue(indexBlendables[i], animCurves[i].Evaluate(time));
			}
			if (!useBones || boneCurves == null)
			{
				return;
			}
			for (int j = 0; j < boneCurves.Count; j++)
			{
				if (bones[j] != null)
				{
					bones[j].localPosition = boneCurves[j].EvaluatePosition(time);
				}
				if (bones[j] != null)
				{
					bones[j].localRotation = boneCurves[j].EvaluateRotation(time);
				}
			}
		}

		public void PreviewAudioAtTime(float time, float length)
		{
			if (!IsPlaying && (bool)audioSource && !audioSource.isPlaying)
			{
				audioSource.PlayOneShot(audioClip);
				if (time <= 1f)
				{
					audioSource.time = time * audioClip.length;
				}
				StartCoroutine(StopAudioSource(length));
			}
		}

		public void TempLoad(List<PhonemeMarker> pData, List<EmotionMarker> eData, AudioClip clip, float duration)
		{
			TempLoad(pData.ToArray(), eData.ToArray(), clip, duration);
		}

		public void TempLoad(PhonemeMarker[] pData, EmotionMarker[] eData, AudioClip clip, float duration)
		{
			if (!base.enabled)
			{
				return;
			}
			if (emotionCache == null)
			{
				emotionCache = new Dictionary<string, EmotionShape>();
				foreach (EmotionShape emotion in emotions)
				{
					emotionCache.Add(emotion.emotion, emotion);
				}
			}
			phonemeMarkers = new List<PhonemeMarker>();
			emotionMarkers = new List<EmotionMarker>();
			foreach (PhonemeMarker item in pData)
			{
				phonemeMarkers.Add(item);
			}
			foreach (EmotionMarker item2 in eData)
			{
				emotionMarkers.Add(item2);
			}
			phonemeMarkers.Sort(SortTime);
			audioClip = clip;
			fileLength = duration;
		}

		public void ProcessData()
		{
			if (base.enabled)
			{
				boneNeutralPositions = null;
				boneNeutralRotations = null;
				boneNeutralScales = null;
				List<Transform> list = null;
				List<TransformAnimationCurve> list2 = null;
				List<Transform> list3 = null;
				List<TransformAnimationCurve> list4 = null;
				List<int> list5 = new List<int>();
				List<AnimationCurve> list6 = new List<AnimationCurve>();
				List<int> list7 = new List<int>();
				List<AnimationCurve> list8 = new List<AnimationCurve>();
				Dictionary<int, float> dictionary = new Dictionary<int, float>();
				PhonemeShape phonemeShape = null;
				for (int i = 0; i < phonemes.Count; i++)
				{
					if (phonemes[i].phonemeName.ToLowerInvariant() == "rest")
					{
						phonemeShape = phonemes[i];
					}
				}
				indexBlendables = new List<int>();
				animCurves = new List<AnimationCurve>();
				phonemeMarkers.Sort(SortTime);
				if (useBones)
				{
					boneNeutralPositions = new List<Vector3>();
					boneNeutralRotations = new List<Quaternion>();
					boneNeutralScales = new List<Vector3>();
					bones = new List<Transform>();
					boneCurves = new List<TransformAnimationCurve>();
					list3 = new List<Transform>();
					list4 = new List<TransformAnimationCurve>();
					list = new List<Transform>();
					list2 = new List<TransformAnimationCurve>();
				}
				List<Shape> list9 = new List<Shape>();
				foreach (PhonemeMarker phonemeMarker2 in phonemeMarkers)
				{
					if (list9.Count == phonemes.Count)
					{
						break;
					}
					if (list9.Contains(phonemes[phonemeMarker2.phonemeNumber]))
					{
						continue;
					}
					list9.Add(phonemes[phonemeMarker2.phonemeNumber]);
					foreach (int blendShape in phonemes[phonemeMarker2.phonemeNumber].blendShapes)
					{
						if (!list7.Contains(blendShape))
						{
							AnimationCurve animationCurve = new AnimationCurve();
							animationCurve.postWrapMode = WrapMode.Once;
							list8.Add(animationCurve);
							list7.Add(blendShape);
						}
						if (!indexBlendables.Contains(blendShape))
						{
							AnimationCurve animationCurve2 = new AnimationCurve();
							animationCurve2.postWrapMode = WrapMode.Once;
							animCurves.Add(animationCurve2);
							indexBlendables.Add(blendShape);
						}
						if (!dictionary.ContainsKey(blendShape))
						{
							dictionary.Add(blendShape, 0f);
						}
					}
					if (!useBones || boneCurves == null)
					{
						continue;
					}
					foreach (BoneShape bone in phonemes[phonemeMarker2.phonemeNumber].bones)
					{
						if (!list3.Contains(bone.bone))
						{
							TransformAnimationCurve transformAnimationCurve = new TransformAnimationCurve();
							transformAnimationCurve.postWrapMode = WrapMode.Once;
							list4.Add(transformAnimationCurve);
							list3.Add(bone.bone);
						}
						if (!bones.Contains(bone.bone))
						{
							TransformAnimationCurve transformAnimationCurve2 = new TransformAnimationCurve();
							transformAnimationCurve2.postWrapMode = WrapMode.Once;
							boneCurves.Add(transformAnimationCurve2);
							bones.Add(bone.bone);
							boneNeutralPositions.Add(bone.neutralPosition);
							boneNeutralRotations.Add(Quaternion.Euler(bone.neutralRotation.ToNegativeEuler()));
							boneNeutralScales.Add(bone.neutralScale);
						}
					}
				}
				foreach (EmotionMarker emotionMarker7 in emotionMarkers)
				{
					if (emotionMarker7.isMixer)
					{
						for (int j = 0; j < emotionMarker7.mixer.emotions.Count; j++)
						{
							if (list9.Contains(emotionCache[emotionMarker7.mixer.emotions[j].emotion]) || !emotionCache.ContainsKey(emotionMarker7.mixer.emotions[j].emotion))
							{
								continue;
							}
							list9.Add(emotionCache[emotionMarker7.mixer.emotions[j].emotion]);
							foreach (int blendShape2 in emotionCache[emotionMarker7.mixer.emotions[j].emotion].blendShapes)
							{
								if (!list5.Contains(blendShape2))
								{
									AnimationCurve animationCurve3 = new AnimationCurve();
									animationCurve3.postWrapMode = WrapMode.Once;
									list6.Add(animationCurve3);
									list5.Add(blendShape2);
								}
								if (!indexBlendables.Contains(blendShape2))
								{
									AnimationCurve animationCurve4 = new AnimationCurve();
									animationCurve4.postWrapMode = WrapMode.Once;
									animCurves.Add(animationCurve4);
									indexBlendables.Add(blendShape2);
								}
								if (!dictionary.ContainsKey(blendShape2))
								{
									dictionary.Add(blendShape2, 0f);
								}
							}
							if (!useBones || boneCurves == null)
							{
								continue;
							}
							foreach (BoneShape bone2 in emotionCache[emotionMarker7.mixer.emotions[j].emotion].bones)
							{
								if (!list.Contains(bone2.bone))
								{
									TransformAnimationCurve transformAnimationCurve3 = new TransformAnimationCurve();
									transformAnimationCurve3.postWrapMode = WrapMode.Once;
									list2.Add(transformAnimationCurve3);
									list.Add(bone2.bone);
								}
								if (!bones.Contains(bone2.bone))
								{
									TransformAnimationCurve transformAnimationCurve4 = new TransformAnimationCurve();
									transformAnimationCurve4.postWrapMode = WrapMode.Once;
									boneCurves.Add(transformAnimationCurve4);
									bones.Add(bone2.bone);
									boneNeutralPositions.Add(bone2.neutralPosition);
									boneNeutralRotations.Add(Quaternion.Euler(bone2.neutralRotation.ToNegativeEuler()));
									boneNeutralScales.Add(bone2.neutralScale);
								}
							}
						}
						continue;
					}
					if (emotionCache.ContainsKey(emotionMarker7.emotion))
					{
						if (!emotionCache.ContainsKey(emotionMarker7.emotion) || list9.Contains(emotionCache[emotionMarker7.emotion]))
						{
							continue;
						}
						list9.Add(emotionCache[emotionMarker7.emotion]);
						foreach (int blendShape3 in emotionCache[emotionMarker7.emotion].blendShapes)
						{
							if (!list5.Contains(blendShape3))
							{
								AnimationCurve animationCurve5 = new AnimationCurve();
								animationCurve5.postWrapMode = WrapMode.Once;
								list6.Add(animationCurve5);
								list5.Add(blendShape3);
							}
							if (!indexBlendables.Contains(blendShape3))
							{
								AnimationCurve animationCurve6 = new AnimationCurve();
								animationCurve6.postWrapMode = WrapMode.Once;
								animCurves.Add(animationCurve6);
								indexBlendables.Add(blendShape3);
							}
							if (!dictionary.ContainsKey(blendShape3))
							{
								dictionary.Add(blendShape3, 0f);
							}
						}
						if (!useBones || boneCurves == null)
						{
							continue;
						}
						foreach (BoneShape bone3 in emotionCache[emotionMarker7.emotion].bones)
						{
							if (!list.Contains(bone3.bone))
							{
								TransformAnimationCurve transformAnimationCurve5 = new TransformAnimationCurve();
								transformAnimationCurve5.postWrapMode = WrapMode.Once;
								list2.Add(transformAnimationCurve5);
								list.Add(bone3.bone);
							}
							if (!bones.Contains(bone3.bone))
							{
								TransformAnimationCurve transformAnimationCurve6 = new TransformAnimationCurve();
								transformAnimationCurve6.postWrapMode = WrapMode.Once;
								boneCurves.Add(transformAnimationCurve6);
								bones.Add(bone3.bone);
								boneNeutralPositions.Add(bone3.neutralPosition);
								boneNeutralRotations.Add(Quaternion.Euler(bone3.neutralRotation.ToNegativeEuler()));
								boneNeutralScales.Add(bone3.neutralScale);
							}
						}
						continue;
					}
					emotionMarkers.Remove(emotionMarker7);
					break;
				}
				if (customEmotion > -1 && !list9.Contains(emotions[customEmotion]))
				{
					list9.Add(emotions[customEmotion]);
					foreach (int blendShape4 in emotions[customEmotion].blendShapes)
					{
						if (!list5.Contains(blendShape4))
						{
							AnimationCurve animationCurve7 = new AnimationCurve();
							animationCurve7.postWrapMode = WrapMode.Once;
							list6.Add(animationCurve7);
							list5.Add(blendShape4);
						}
						if (!indexBlendables.Contains(blendShape4))
						{
							AnimationCurve animationCurve8 = new AnimationCurve();
							animationCurve8.postWrapMode = WrapMode.Once;
							animCurves.Add(animationCurve8);
							indexBlendables.Add(blendShape4);
						}
						if (!dictionary.ContainsKey(blendShape4))
						{
							dictionary.Add(blendShape4, 0f);
						}
					}
					if (useBones && boneCurves != null)
					{
						foreach (BoneShape bone4 in emotions[customEmotion].bones)
						{
							if (!list.Contains(bone4.bone))
							{
								TransformAnimationCurve transformAnimationCurve7 = new TransformAnimationCurve();
								transformAnimationCurve7.postWrapMode = WrapMode.Once;
								list2.Add(transformAnimationCurve7);
								list.Add(bone4.bone);
							}
							if (!bones.Contains(bone4.bone))
							{
								TransformAnimationCurve transformAnimationCurve8 = new TransformAnimationCurve();
								transformAnimationCurve8.postWrapMode = WrapMode.Once;
								boneCurves.Add(transformAnimationCurve8);
								bones.Add(bone4.bone);
								boneNeutralPositions.Add(bone4.neutralPosition);
								boneNeutralRotations.Add(Quaternion.Euler(bone4.neutralRotation.ToNegativeEuler()));
								boneNeutralScales.Add(bone4.neutralScale);
							}
						}
					}
				}
				if (phonemeShape != null)
				{
					foreach (int blendShape5 in phonemeShape.blendShapes)
					{
						if (!list7.Contains(blendShape5))
						{
							AnimationCurve animationCurve9 = new AnimationCurve();
							animationCurve9.postWrapMode = WrapMode.Once;
							list8.Add(animationCurve9);
							list7.Add(blendShape5);
						}
						if (!indexBlendables.Contains(blendShape5))
						{
							AnimationCurve animationCurve10 = new AnimationCurve();
							animationCurve10.postWrapMode = WrapMode.Once;
							animCurves.Add(animationCurve10);
							indexBlendables.Add(blendShape5);
						}
						if (!dictionary.ContainsKey(blendShape5))
						{
							dictionary.Add(blendShape5, 0f);
						}
					}
					if (useBones && boneCurves != null)
					{
						foreach (BoneShape bone5 in phonemeShape.bones)
						{
							if (!list3.Contains(bone5.bone))
							{
								TransformAnimationCurve transformAnimationCurve9 = new TransformAnimationCurve();
								transformAnimationCurve9.postWrapMode = WrapMode.Once;
								list4.Add(transformAnimationCurve9);
								list3.Add(bone5.bone);
							}
							if (!bones.Contains(bone5.bone))
							{
								TransformAnimationCurve transformAnimationCurve10 = new TransformAnimationCurve();
								transformAnimationCurve10.postWrapMode = WrapMode.Once;
								boneCurves.Add(transformAnimationCurve10);
								bones.Add(bone5.bone);
								boneNeutralPositions.Add(bone5.neutralPosition);
								boneNeutralRotations.Add(Quaternion.Euler(bone5.neutralRotation.ToNegativeEuler()));
								boneNeutralScales.Add(bone5.neutralScale);
							}
						}
					}
				}
				for (int k = 0; k < indexBlendables.Count; k++)
				{
					if (phonemeShape != null)
					{
						if (phonemeShape.blendShapes.Contains(indexBlendables[k]))
						{
							dictionary[indexBlendables[k]] = phonemeShape.weights[phonemeShape.blendShapes.IndexOf(indexBlendables[k])];
						}
						else
						{
							dictionary[indexBlendables[k]] = 0f;
						}
					}
					else
					{
						dictionary[indexBlendables[k]] = 0f;
					}
				}
				if (useBones && boneCurves != null)
				{
					for (int l = 0; l < bones.Count; l++)
					{
						if (phonemeShape != null && phonemeShape.HasBone(bones[l]))
						{
							boneNeutralPositions[l] = phonemeShape.bones[phonemeShape.IndexOfBone(bones[l])].endPosition;
							boneNeutralRotations[l] = Quaternion.Euler(phonemeShape.bones[phonemeShape.IndexOfBone(bones[l])].endRotation);
							boneNeutralScales[l] = phonemeShape.bones[phonemeShape.IndexOfBone(bones[l])].endScale;
						}
					}
				}
				for (int m = 0; m < list8.Count; m++)
				{
					if (customEmotion == -1)
					{
						list8[m].AddKey(0f, dictionary[list7[m]]);
					}
					if (!keepEmotionWhenFinished)
					{
						list8[m].AddKey(1f, dictionary[list7[m]]);
					}
				}
				for (int n = 0; n < list6.Count; n++)
				{
					if (customEmotion > -1)
					{
						if (emotions[customEmotion].blendShapes.Contains(list5[n]))
						{
							list6[n].AddKey(0f, emotions[customEmotion].weights[emotions[customEmotion].blendShapes.IndexOf(list5[n])]);
						}
						else
						{
							list6[n].AddKey(0f, dictionary[list5[n]]);
						}
					}
					else
					{
						list6[n].AddKey(0f, dictionary[list5[n]]);
					}
					if (!keepEmotionWhenFinished)
					{
						list6[n].AddKey(1f, dictionary[list5[n]]);
					}
					else if (customEmotion > -1 && emotions[customEmotion].blendShapes.Contains(list5[n]))
					{
						list6[n].AddKey(1f, emotions[customEmotion].weights[emotions[customEmotion].blendShapes.IndexOf(list5[n])]);
					}
				}
				if (useBones && boneCurves != null)
				{
					for (int num = 0; num < list4.Count; num++)
					{
						if (customEmotion == -1)
						{
							list4[num].AddKey(0f, boneNeutralPositions[bones.IndexOf(list3[num])], boneNeutralRotations[bones.IndexOf(list3[num])], boneNeutralScales[bones.IndexOf(list3[num])], 0f, 0f);
						}
						if (!keepEmotionWhenFinished)
						{
							list4[num].AddKey(1f, boneNeutralPositions[bones.IndexOf(list3[num])], boneNeutralRotations[bones.IndexOf(list3[num])], boneNeutralScales[bones.IndexOf(list3[num])], 0f, 0f);
						}
					}
					for (int num2 = 0; num2 < list2.Count; num2++)
					{
						if (customEmotion > -1)
						{
							if (emotions[customEmotion].HasBone(list[num2]))
							{
								list2[num2].AddKey(0f, emotions[customEmotion].bones[emotions[customEmotion].IndexOfBone(list[num2])].endPosition, Quaternion.Euler(emotions[customEmotion].bones[emotions[customEmotion].IndexOfBone(list[num2])].endRotation), emotions[customEmotion].bones[emotions[customEmotion].IndexOfBone(list[num2])].endScale, 0f, 0f);
							}
							else
							{
								list2[num2].AddKey(0f, boneNeutralPositions[bones.IndexOf(list[num2])], boneNeutralRotations[bones.IndexOf(list[num2])], boneNeutralScales[bones.IndexOf(list[num2])], 0f, 0f);
							}
						}
						else
						{
							list2[num2].AddKey(0f, boneNeutralPositions[bones.IndexOf(list[num2])], boneNeutralRotations[bones.IndexOf(list[num2])], boneNeutralScales[bones.IndexOf(list[num2])], 0f, 0f);
						}
						if (!keepEmotionWhenFinished)
						{
							list2[num2].AddKey(1f, boneNeutralPositions[bones.IndexOf(list[num2])], boneNeutralRotations[bones.IndexOf(list[num2])], boneNeutralScales[bones.IndexOf(list[num2])], 0f, 0f);
						}
						else if (customEmotion > -1 && emotions[customEmotion].HasBone(list[num2]))
						{
							list2[num2].AddKey(1f, emotions[customEmotion].bones[emotions[customEmotion].IndexOfBone(list[num2])].endPosition, Quaternion.Euler(emotions[customEmotion].bones[emotions[customEmotion].IndexOfBone(list[num2])].endRotation), emotions[customEmotion].bones[emotions[customEmotion].IndexOfBone(list[num2])].endScale, 0f, 0f);
						}
					}
				}
				foreach (EmotionMarker emotionMarker8 in emotionMarkers)
				{
					EmotionShape emotionShape = null;
					int num3 = (emotionMarker8.continuousVariation ? Mathf.Clamp(Mathf.FloorToInt((emotionMarker8.endTime - emotionMarker8.startTime - (emotionMarker8.blendInTime - emotionMarker8.blendOutTime)) * fileLength / emotionMarker8.variationFrequency), 2, 128) : 2);
					float[] array = new float[num3];
					float[] array2 = new float[num3];
					float[] array3 = new float[num3];
					float[] array4 = new float[num3];
					for (int num4 = 0; num4 < num3; num4++)
					{
						if (emotionMarker8.continuousVariation)
						{
							array[num4] = UnityEngine.Random.Range(1f - emotionMarker8.intensityVariation / 2f, 1f + emotionMarker8.intensityVariation / 2f);
							continue;
						}
						array[num4] = 1f;
						array2[num4] = 1f;
						array3[num4] = 1f;
						array4[num4] = 1f;
					}
					emotionShape = ((!emotionMarker8.isMixer) ? emotionCache[emotionMarker8.emotion] : emotionMarker8.mixer.GetShape(this));
					for (int num5 = 0; num5 < list6.Count; num5++)
					{
						if (emotionShape.blendShapes.Contains(list5[num5]))
						{
							int index = emotionShape.blendShapes.IndexOf(list5[num5]);
							float value = dictionary[list5[num5]];
							float value2 = dictionary[list5[num5]];
							if (emotionMarker8.continuousVariation)
							{
								for (int num6 = 0; num6 < num3; num6++)
								{
									array2[num6] = UnityEngine.Random.Range(1f - emotionMarker8.blendableVariation / 2f, 1f + emotionMarker8.blendableVariation / 2f);
								}
							}
							if (emotionMarker8.blendFromMarker)
							{
								EmotionMarker emotionMarker = emotionMarkers[emotionMarkers.IndexOf(emotionMarker8) - 1];
								EmotionShape emotionShape2 = null;
								emotionShape2 = ((!emotionMarker.isMixer) ? emotionCache[emotionMarker.emotion] : emotionMarker.mixer.GetShape(this));
								if (emotionShape2.blendShapes.Contains(list5[num5]))
								{
									value = emotionShape2.weights[emotionShape2.blendShapes.IndexOf(list5[num5])] * emotionMarker.intensity;
								}
							}
							if (emotionMarker8.blendToMarker)
							{
								EmotionMarker emotionMarker2 = emotionMarkers[emotionMarkers.IndexOf(emotionMarker8) + 1];
								EmotionShape emotionShape3 = null;
								emotionShape3 = ((!emotionMarker2.isMixer) ? emotionCache[emotionMarker2.emotion] : emotionMarker2.mixer.GetShape(this));
								if (emotionShape3.blendShapes.Contains(list5[num5]))
								{
									value2 = emotionShape3.weights[emotionShape3.blendShapes.IndexOf(list5[num5])] * emotionMarker2.intensity;
								}
							}
							if (emotionCurveGenerationMode == CurveGenerationMode.Tight)
							{
								list6[num5].AddKey(new Keyframe(emotionMarker8.startTime, value, 0f, 0f));
								for (int num7 = 0; num7 < num3; num7++)
								{
									float time = Mathf.Lerp(emotionMarker8.startTime + emotionMarker8.blendInTime, emotionMarker8.endTime + emotionMarker8.blendOutTime, (float)num7 / (float)(num3 - 1));
									list6[num5].AddKey(new Keyframe(time, emotionShape.weights[index] * emotionMarker8.intensity * array[num7] * array2[num7], 0f, 0f));
								}
								list6[num5].AddKey(new Keyframe(emotionMarker8.endTime, value2, 0f, 0f));
							}
							else if (emotionCurveGenerationMode == CurveGenerationMode.Loose)
							{
								list6[num5].AddKey(emotionMarker8.startTime, value);
								for (int num8 = 0; num8 < num3; num8++)
								{
									float time2 = Mathf.Lerp(emotionMarker8.startTime + emotionMarker8.blendInTime, emotionMarker8.endTime + emotionMarker8.blendOutTime, (float)num8 / (float)(num3 - 1));
									list6[num5].AddKey(time2, emotionShape.weights[index] * emotionMarker8.intensity * array[num8] * array2[num8]);
								}
								list6[num5].AddKey(emotionMarker8.endTime, value2);
							}
							continue;
						}
						if (emotionCurveGenerationMode == CurveGenerationMode.Tight)
						{
							list6[num5].AddKey(new Keyframe(emotionMarker8.startTime + emotionMarker8.blendInTime, 0f, 0f, 0f));
							list6[num5].AddKey(new Keyframe(emotionMarker8.endTime + emotionMarker8.blendOutTime, 0f, 0f, 0f));
						}
						else if (emotionCurveGenerationMode == CurveGenerationMode.Loose)
						{
							list6[num5].AddKey(emotionMarker8.startTime + emotionMarker8.blendInTime, 0f);
							list6[num5].AddKey(emotionMarker8.endTime + emotionMarker8.blendOutTime, 0f);
						}
						if (!emotionMarker8.blendToMarker)
						{
							continue;
						}
						EmotionMarker emotionMarker3 = emotionMarkers[emotionMarkers.IndexOf(emotionMarker8) + 1];
						EmotionShape emotionShape4 = null;
						emotionShape4 = ((!emotionMarker3.isMixer) ? emotionCache[emotionMarker3.emotion] : emotionMarker3.mixer.GetShape(this));
						if (emotionShape4.blendShapes.Contains(list5[num5]))
						{
							if (emotionCurveGenerationMode == CurveGenerationMode.Tight)
							{
								list6[num5].AddKey(new Keyframe(emotionMarker8.endTime, emotionShape4.weights[emotionShape4.blendShapes.IndexOf(list5[num5])] * emotionMarker3.intensity, 0f, 0f));
							}
							else if (emotionCurveGenerationMode == CurveGenerationMode.Loose)
							{
								list6[num5].AddKey(emotionMarker8.endTime, emotionShape4.weights[emotionShape4.blendShapes.IndexOf(list5[num5])] * emotionMarker3.intensity);
							}
						}
					}
					if (!useBones || boneCurves == null)
					{
						continue;
					}
					for (int num9 = 0; num9 < list2.Count; num9++)
					{
						if (emotionShape.HasBone(list[num9]))
						{
							int index2 = emotionShape.IndexOfBone(list[num9]);
							if (emotionMarker8.continuousVariation)
							{
								for (int num10 = 0; num10 < num3; num10++)
								{
									array3[num10] = UnityEngine.Random.Range(1f - emotionMarker8.bonePositionVariation / 2f, 1f + emotionMarker8.bonePositionVariation / 2f);
									array4[num10] = UnityEngine.Random.Range(1f - emotionMarker8.boneRotationVariation / 2f, 1f + emotionMarker8.boneRotationVariation / 2f);
								}
							}
							Vector3 vector = emotionShape.bones[index2].neutralPosition;
							Quaternion quaternion = Quaternion.Euler(emotionShape.bones[index2].neutralRotation);
							Vector3 vector2 = emotionShape.bones[index2].neutralScale;
							Vector3 vector3 = emotionShape.bones[index2].neutralPosition;
							Quaternion quaternion2 = Quaternion.Euler(emotionShape.bones[index2].neutralRotation);
							Vector3 vector4 = emotionShape.bones[index2].neutralScale;
							if (emotionMarker8.blendFromMarker)
							{
								EmotionMarker emotionMarker4 = emotionMarkers[emotionMarkers.IndexOf(emotionMarker8) - 1];
								EmotionShape emotionShape5 = null;
								emotionShape5 = ((!emotionMarker4.isMixer) ? emotionCache[emotionMarker4.emotion] : emotionMarker4.mixer.GetShape(this));
								if (emotionShape5.HasBone(list[num9]))
								{
									vector = Vector3.Lerp(vector, emotionShape5.bones[emotionShape5.IndexOfBone(list[num9])].endPosition, emotionMarker4.intensity);
									quaternion = Quaternion.Slerp(quaternion, Quaternion.Euler(emotionShape5.bones[emotionShape5.IndexOfBone(list[num9])].endRotation), emotionMarker4.intensity);
									vector2 = Vector3.Lerp(vector2, emotionShape5.bones[emotionShape5.IndexOfBone(list[num9])].endScale, emotionMarker4.intensity);
								}
							}
							if (emotionMarker8.blendToMarker)
							{
								EmotionMarker emotionMarker5 = emotionMarkers[emotionMarkers.IndexOf(emotionMarker8) + 1];
								EmotionShape emotionShape6 = null;
								emotionShape6 = ((!emotionMarker5.isMixer) ? emotionCache[emotionMarker5.emotion] : emotionMarker5.mixer.GetShape(this));
								if (emotionShape6.HasBone(list[num9]))
								{
									vector3 = Vector3.Lerp(vector3, emotionShape6.bones[emotionShape6.IndexOfBone(list[num9])].endPosition, emotionMarker5.intensity);
									quaternion2 = Quaternion.Slerp(quaternion2, Quaternion.Euler(emotionShape6.bones[emotionShape6.IndexOfBone(list[num9])].endRotation), emotionMarker5.intensity);
									vector4 = Vector3.Lerp(vector4, emotionShape6.bones[emotionShape6.IndexOfBone(list[num9])].endScale, emotionMarker5.intensity);
								}
							}
							list2[num9].AddKey(emotionMarker8.startTime, vector, quaternion, vector2, 0f, 0f);
							for (int num11 = 0; num11 < num3; num11++)
							{
								float time3 = Mathf.Lerp(emotionMarker8.startTime + emotionMarker8.blendInTime, emotionMarker8.endTime + emotionMarker8.blendOutTime, (float)num11 / (float)(num3 - 1));
								list2[num9].AddKey(time3, Vector3.Lerp(emotionShape.bones[index2].neutralPosition, emotionShape.bones[index2].endPosition * array3[num11], emotionMarker8.intensity * array[num11]), Quaternion.Slerp(Quaternion.Euler(emotionShape.bones[index2].neutralRotation), Quaternion.Euler(emotionShape.bones[index2].endRotation * array4[num11]), emotionMarker8.intensity * array[num11]), Vector3.Lerp(emotionShape.bones[index2].neutralScale, emotionShape.bones[index2].endScale, emotionMarker8.intensity * array[num11]), 0f, 0f);
							}
							list2[num9].AddKey(emotionMarker8.endTime, vector3, quaternion2, vector4, 0f, 0f);
							continue;
						}
						list2[num9].AddKey(emotionMarker8.startTime + emotionMarker8.blendInTime, boneNeutralPositions[bones.IndexOf(list[num9])], boneNeutralRotations[bones.IndexOf(list[num9])], boneNeutralScales[bones.IndexOf(list[num9])], 0f, 0f);
						list2[num9].AddKey(emotionMarker8.endTime + emotionMarker8.blendOutTime, boneNeutralPositions[bones.IndexOf(list[num9])], boneNeutralRotations[bones.IndexOf(list[num9])], boneNeutralScales[bones.IndexOf(list[num9])], 0f, 0f);
						if (emotionMarker8.blendToMarker)
						{
							EmotionMarker emotionMarker6 = emotionMarkers[emotionMarkers.IndexOf(emotionMarker8) + 1];
							EmotionShape emotionShape7 = null;
							emotionShape7 = ((!emotionMarker6.isMixer) ? emotionCache[emotionMarker6.emotion] : emotionMarker6.mixer.GetShape(this));
							if (emotionShape7.HasBone(list[num9]))
							{
								BoneShape boneShape = emotionShape7.bones[emotionShape7.IndexOfBone(list[num9])];
								list2[num9].AddKey(emotionMarker8.endTime, Vector3.Lerp(boneShape.neutralPosition, boneShape.endPosition, emotionMarker6.intensity), Quaternion.Euler(Vector3.Lerp(boneShape.neutralRotation, boneShape.endRotation, emotionMarker6.intensity)), Vector3.Lerp(boneShape.neutralScale, boneShape.endScale, emotionMarker6.intensity), 0f, 0f);
							}
						}
					}
				}
				for (int num12 = 0; num12 < phonemeMarkers.Count; num12++)
				{
					PhonemeMarker phonemeMarker = phonemeMarkers[num12];
					PhonemeShape phonemeShape2 = phonemes[phonemeMarker.phonemeNumber];
					float num13 = 1f;
					float num14 = 1f;
					float num15 = 1f;
					float num16 = 1f;
					if (phonemeMarker.useRandomness)
					{
						num13 = UnityEngine.Random.Range(1f - phonemeMarker.intensityRandomness / 2f, 1f + phonemeMarker.intensityRandomness / 2f);
					}
					bool flag = false;
					if (!phonemeMarker.sustain)
					{
						if (num12 + 1 < phonemeMarkers.Count)
						{
							if (phonemeMarkers[num12 + 1].time > phonemeMarker.time + restTime / fileLength + restHoldTime / fileLength)
							{
								flag = true;
							}
						}
						else
						{
							flag = true;
						}
					}
					for (int num17 = 0; num17 < list8.Count; num17++)
					{
						if (phonemeShape2.blendShapes.Contains(list7[num17]))
						{
							int index3 = phonemeShape2.blendShapes.IndexOf(list7[num17]);
							if (phonemeMarker.useRandomness)
							{
								num14 = UnityEngine.Random.Range(1f - phonemeMarker.blendableRandomness / 2f, 1f + phonemeMarker.blendableRandomness / 2f);
							}
							if (phonemeCurveGenerationMode == CurveGenerationMode.Tight)
							{
								list8[num17].AddKey(new Keyframe(phonemeMarker.time, phonemeShape2.weights[index3] * phonemeMarker.intensity * num13 * num14, 0f, 0f));
								if (num12 == 0)
								{
									list8[num17].AddKey(new Keyframe(phonemeMarkers[num12].time - restHoldTime / fileLength, dictionary[list7[num17]], 0f, 0f));
								}
								if (flag)
								{
									list8[num17].AddKey(new Keyframe(phonemeMarker.time + restHoldTime / fileLength, phonemeShape2.weights[index3] * phonemeMarker.intensity * num13 * num14, 0f, 0f));
									list8[num17].AddKey(new Keyframe(phonemeMarker.time + restHoldTime / fileLength * 2f, dictionary[list7[num17]], 0f, 0f));
									if (num12 + 1 < phonemeMarkers.Count)
									{
										list8[num17].AddKey(new Keyframe(phonemeMarkers[num12 + 1].time - restHoldTime / fileLength, dictionary[list7[num17]], 0f, 0f));
									}
								}
							}
							else
							{
								if (phonemeCurveGenerationMode != CurveGenerationMode.Loose)
								{
									continue;
								}
								list8[num17].AddKey(phonemeMarker.time, phonemeShape2.weights[index3] * phonemeMarker.intensity);
								if (num12 == 0)
								{
									list8[num17].AddKey(phonemeMarkers[num12].time - restHoldTime / fileLength, dictionary[list7[num17]]);
								}
								if (flag)
								{
									list8[num17].AddKey(phonemeMarker.time + restHoldTime / fileLength, phonemeShape2.weights[index3] * phonemeMarker.intensity * num13 * num14);
									list8[num17].AddKey(phonemeMarker.time + restHoldTime / fileLength * 2f, dictionary[list7[num17]]);
									if (num12 + 1 < phonemeMarkers.Count)
									{
										list8[num17].AddKey(phonemeMarkers[num12 + 1].time - restHoldTime / fileLength, dictionary[list7[num17]]);
									}
								}
							}
							continue;
						}
						if (phonemeCurveGenerationMode == CurveGenerationMode.Tight)
						{
							list8[num17].AddKey(new Keyframe(phonemeMarker.time, dictionary[list7[num17]], 0f, 0f));
						}
						else if (phonemeCurveGenerationMode == CurveGenerationMode.Loose)
						{
							list8[num17].AddKey(phonemeMarker.time, dictionary[list7[num17]]);
						}
						if (flag && num12 + 1 < phonemeMarkers.Count)
						{
							if (phonemeCurveGenerationMode == CurveGenerationMode.Tight)
							{
								list8[num17].AddKey(new Keyframe(phonemeMarkers[num12 + 1].time - restHoldTime / fileLength, dictionary[list7[num17]], 0f, 0f));
							}
							else if (phonemeCurveGenerationMode == CurveGenerationMode.Loose)
							{
								list8[num17].AddKey(phonemeMarkers[num12 + 1].time - restHoldTime / fileLength, dictionary[list7[num17]]);
							}
						}
					}
					if (!useBones || boneCurves == null)
					{
						continue;
					}
					for (int num18 = 0; num18 < list4.Count; num18++)
					{
						if (phonemeShape2.HasBone(bones[num18]))
						{
							int index4 = phonemeShape2.IndexOfBone(bones[num18]);
							if (phonemeMarker.useRandomness)
							{
								num15 = UnityEngine.Random.Range(1f - phonemeMarker.bonePositionRandomness / 2f, 1f + phonemeMarker.bonePositionRandomness / 2f);
								num16 = UnityEngine.Random.Range(1f - phonemeMarker.boneRotationRandomness / 2f, 1f + phonemeMarker.boneRotationRandomness / 2f);
							}
							list4[num18].AddKey(phonemeMarker.time, Vector3.Lerp(phonemeShape2.bones[index4].neutralPosition, phonemeShape2.bones[index4].endPosition * num15, phonemeMarker.intensity * num13), Quaternion.Slerp(Quaternion.Euler(phonemeShape2.bones[index4].neutralRotation), Quaternion.Euler(phonemeShape2.bones[index4].endRotation * num16), phonemeMarker.intensity), Vector3.Lerp(phonemeShape2.bones[index4].neutralScale, phonemeShape2.bones[index4].endScale, phonemeMarker.intensity * num13), 0f, 0f);
							if (num12 == 0)
							{
								list4[num18].AddKey(phonemeMarkers[num12].time - restHoldTime / fileLength, boneNeutralPositions[num18], boneNeutralRotations[num18], boneNeutralScales[num18], 0f, 0f);
							}
							if (flag)
							{
								list4[num18].AddKey(phonemeMarker.time + restHoldTime / fileLength, boneNeutralPositions[num18], boneNeutralRotations[num18], boneNeutralScales[num18], 0f, 0f);
								if (num12 + 1 < phonemeMarkers.Count)
								{
									list4[num18].AddKey(phonemeMarkers[num12 + 1].time - restHoldTime / fileLength, boneNeutralPositions[num18], boneNeutralRotations[num18], boneNeutralScales[num18], 0f, 0f);
								}
							}
						}
						else
						{
							list4[num18].AddKey(phonemeMarker.time, boneNeutralPositions[num18], boneNeutralRotations[num18], boneNeutralScales[num18], 0f, 0f);
							if (flag && num12 + 1 < phonemeMarkers.Count)
							{
								list4[num18].AddKey(phonemeMarkers[num12 + 1].time - restHoldTime / fileLength, boneNeutralPositions[num18], boneNeutralRotations[num18], boneNeutralScales[num18], 0f, 0f);
							}
						}
					}
				}
				for (int num19 = 0; num19 < animCurves.Count; num19++)
				{
					if (list7.Contains(indexBlendables[num19]) && list5.Contains(indexBlendables[num19]))
					{
						int index5 = list7.IndexOf(indexBlendables[num19]);
						int index6 = list5.IndexOf(indexBlendables[num19]);
						for (int num20 = 0; num20 < list8[index5].keys.Length; num20++)
						{
							Keyframe key = list8[index5].keys[num20];
							animCurves[num19].AddKey(key);
						}
						for (int num21 = 0; num21 < list6[index6].keys.Length; num21++)
						{
							Keyframe key2 = list6[index6].keys[num21];
							animCurves[num19].AddKey(key2);
						}
					}
					else if (list7.Contains(indexBlendables[num19]))
					{
						int index7 = list7.IndexOf(indexBlendables[num19]);
						for (int num22 = 0; num22 < list8[index7].keys.Length; num22++)
						{
							Keyframe key3 = list8[index7].keys[num22];
							animCurves[num19].AddKey(key3);
						}
					}
					else
					{
						int index8 = list5.IndexOf(indexBlendables[num19]);
						for (int num23 = 0; num23 < list6[index8].keys.Length; num23++)
						{
							Keyframe key4 = list6[index8].keys[num23];
							animCurves[num19].AddKey(key4);
						}
					}
				}
				if (useBones && boneCurves != null)
				{
					for (int num24 = 0; num24 < boneCurves.Count; num24++)
					{
						if (list3.Contains(bones[num24]) && list.Contains(bones[num24]))
						{
							int index9 = list3.IndexOf(bones[num24]);
							int index10 = list.IndexOf(bones[num24]);
							TransformAnimationCurve.TransformKeyframe[] keys = list4[index9].keys;
							for (int num25 = 0; num25 < keys.Length; num25++)
							{
								TransformAnimationCurve.TransformKeyframe transformKeyframe = keys[num25];
								boneCurves[num24].AddKey(transformKeyframe.time, transformKeyframe.position, transformKeyframe.rotation, transformKeyframe.scale, 0f, 0f);
							}
							keys = list2[index10].keys;
							for (int num25 = 0; num25 < keys.Length; num25++)
							{
								TransformAnimationCurve.TransformKeyframe transformKeyframe2 = keys[num25];
								boneCurves[num24].AddKey(transformKeyframe2.time, transformKeyframe2.position, transformKeyframe2.rotation, transformKeyframe2.scale, 0f, 0f);
							}
						}
						else if (list3.Contains(bones[num24]))
						{
							int index11 = list3.IndexOf(bones[num24]);
							TransformAnimationCurve.TransformKeyframe[] keys = list4[index11].keys;
							for (int num25 = 0; num25 < keys.Length; num25++)
							{
								TransformAnimationCurve.TransformKeyframe transformKeyframe3 = keys[num25];
								boneCurves[num24].AddKey(transformKeyframe3.time, transformKeyframe3.position, transformKeyframe3.rotation, transformKeyframe3.scale, 0f, 0f);
							}
						}
						else
						{
							int index12 = list.IndexOf(bones[num24]);
							TransformAnimationCurve.TransformKeyframe[] keys = list2[index12].keys;
							for (int num25 = 0; num25 < keys.Length; num25++)
							{
								TransformAnimationCurve.TransformKeyframe transformKeyframe4 = keys[num25];
								boneCurves[num24].AddKey(transformKeyframe4.time, transformKeyframe4.position, transformKeyframe4.rotation, transformKeyframe4.scale, 0f, 0f);
							}
						}
					}
					foreach (TransformAnimationCurve boneCurf in boneCurves)
					{
						boneCurf.FixQuaternionContinuity();
					}
				}
			}
			if (customEmotion > -1)
			{
				ClearDataCache();
				customEmotion = -1;
			}
		}

		public void ClearDataCache()
		{
			currentFileID = 0;
		}

		private void FixEmotionBlends(ref List<EmotionMarker> data)
		{
			EmotionMarker[] data2 = data.ToArray();
			FixEmotionBlends(ref data2);
			data.Clear();
			EmotionMarker[] array = data2;
			foreach (EmotionMarker item in array)
			{
				data.Add(item);
			}
		}

		private void FixEmotionBlends(ref EmotionMarker[] data)
		{
			EmotionMarker[] array = data;
			foreach (EmotionMarker emotionMarker in array)
			{
				emotionMarker.blendFromMarker = false;
				emotionMarker.blendToMarker = false;
				if (!emotionMarker.customBlendIn)
				{
					emotionMarker.blendInTime = 0f;
				}
				if (!emotionMarker.customBlendOut)
				{
					emotionMarker.blendOutTime = 0f;
				}
				emotionMarker.invalid = false;
			}
			array = data;
			foreach (EmotionMarker emotionMarker2 in array)
			{
				EmotionMarker[] array2 = data;
				foreach (EmotionMarker emotionMarker3 in array2)
				{
					if (emotionMarker2 == emotionMarker3)
					{
						continue;
					}
					if (emotionMarker2.startTime > emotionMarker3.startTime && emotionMarker2.startTime < emotionMarker3.endTime)
					{
						if (emotionMarker2.customBlendIn)
						{
							emotionMarker2.customBlendIn = false;
							FixEmotionBlends(ref data);
							return;
						}
						emotionMarker2.blendFromMarker = true;
						if (emotionMarker2.endTime > emotionMarker3.startTime && emotionMarker2.endTime < emotionMarker3.endTime)
						{
							emotionMarker2.invalid = true;
						}
						else
						{
							emotionMarker2.blendInTime = emotionMarker3.endTime - emotionMarker2.startTime;
						}
					}
					if (emotionMarker2.endTime > emotionMarker3.startTime && emotionMarker2.endTime < emotionMarker3.endTime)
					{
						if (emotionMarker2.customBlendOut)
						{
							emotionMarker2.customBlendOut = false;
							FixEmotionBlends(ref data);
							return;
						}
						emotionMarker2.blendToMarker = true;
						if (emotionMarker2.startTime > emotionMarker3.startTime && emotionMarker2.startTime < emotionMarker3.endTime)
						{
							emotionMarker2.invalid = true;
						}
						else
						{
							emotionMarker2.blendOutTime = emotionMarker3.startTime - emotionMarker2.endTime;
						}
					}
				}
			}
		}

		private void LoadXML(TextAsset xmlFile, AudioClip linkedClip)
		{
			XmlDocument xmlDocument = new XmlDocument();
			xmlDocument.LoadXml(xmlFile.text);
			phonemeMarkers = new List<PhonemeMarker>();
			emotionMarkers = new List<EmotionMarker>();
			gestureMarkers = new List<GestureMarker>();
			audioClip = linkedClip;
			audioSource.clip = audioClip;
			if (float.Parse(ReadXML(xmlDocument, "LipSyncData", "version")) < 1.321f)
			{
				UnityEngine.Debug.LogError("Cannot load pre-1.321 XML file. Run the converter from Window/Rogo Digital/LipSync Pro/Update XML files.");
				return;
			}
			try
			{
				fileLength = float.Parse(ReadXML(xmlDocument, "LipSyncData", "length"));
				XmlNode xmlNode = xmlDocument.SelectSingleNode("//LipSyncData//phonemes");
				if (xmlNode != null)
				{
					XmlNodeList childNodes = xmlNode.ChildNodes;
					for (int i = 0; i < childNodes.Count; i++)
					{
						XmlNode xmlNode2 = childNodes[i];
						if (xmlNode2.LocalName == "marker")
						{
							int phonemeNumber = int.Parse(xmlNode2.Attributes["phonemeNumber"].Value);
							float time = float.Parse(xmlNode2.Attributes["time"].Value) / fileLength;
							float intensity = float.Parse(xmlNode2.Attributes["intensity"].Value);
							bool sustain = bool.Parse(xmlNode2.Attributes["sustain"].Value);
							phonemeMarkers.Add(new PhonemeMarker(phonemeNumber, time, intensity, sustain));
						}
					}
				}
				XmlNode xmlNode3 = xmlDocument.SelectSingleNode("//LipSyncData//emotions");
				if (xmlNode3 != null)
				{
					XmlNodeList childNodes2 = xmlNode3.ChildNodes;
					for (int j = 0; j < childNodes2.Count; j++)
					{
						XmlNode xmlNode4 = childNodes2[j];
						if (xmlNode4.LocalName == "marker")
						{
							string value = xmlNode4.Attributes["emotion"].Value;
							float startTime = float.Parse(xmlNode4.Attributes["start"].Value) / fileLength;
							float endTime = float.Parse(xmlNode4.Attributes["end"].Value) / fileLength;
							float blendInTime = float.Parse(xmlNode4.Attributes["blendIn"].Value);
							float blendOutTime = float.Parse(xmlNode4.Attributes["blendOut"].Value);
							bool blendToMarker = bool.Parse(xmlNode4.Attributes["blendToMarker"].Value);
							bool blendFromMarker = bool.Parse(xmlNode4.Attributes["blendFromMarker"].Value);
							bool customBlendIn = bool.Parse(xmlNode4.Attributes["customBlendIn"].Value);
							bool customBlendOut = bool.Parse(xmlNode4.Attributes["customBlendOut"].Value);
							float intensity2 = float.Parse(xmlNode4.Attributes["intensity"].Value);
							emotionMarkers.Add(new EmotionMarker(value, startTime, endTime, blendInTime, blendOutTime, blendToMarker, blendFromMarker, customBlendIn, customBlendOut, intensity2));
						}
					}
				}
				XmlNode xmlNode5 = xmlDocument.SelectSingleNode("//LipSyncData//gestures");
				if (xmlNode5 != null)
				{
					XmlNodeList childNodes3 = xmlNode5.ChildNodes;
					for (int k = 0; k < childNodes3.Count; k++)
					{
						XmlNode xmlNode6 = childNodes3[k];
						if (xmlNode6.LocalName == "marker")
						{
							string value2 = xmlNode6.Attributes["gesture"].Value;
							float time2 = float.Parse(xmlNode6.Attributes["time"].Value) / fileLength;
							gestureMarkers.Add(new GestureMarker(value2, time2));
						}
					}
				}
			}
			catch
			{
				UnityEngine.Debug.LogError("[LipSync - " + base.gameObject.name + "] Malformed XML file. See console for details. \nFor the sake of simplicity, LipSync Pro is unable to handle errors in XML files. The clip editor often can, however. Import this XML file into the clip editor and re-export to fix.");
			}
			phonemeMarkers.Sort(SortTime);
			gestureMarkers.Sort(SortTime);
		}

		private bool LoadData(LipSyncData dataFile)
		{
			if (dataFile.phonemeData.Length != 0 || dataFile.emotionData.Length != 0 || dataFile.gestureData.Length != 0)
			{
				audioClip = dataFile.clip;
				fileLength = dataFile.length;
				bool flag = false;
				if (dataFile.version < 1f)
				{
					flag = true;
					for (int i = 0; i < dataFile.emotionData.Length; i++)
					{
						if (dataFile.emotionData[i].blendFromMarker)
						{
							dataFile.emotionData[i].startTime -= dataFile.emotionData[i].blendInTime;
							dataFile.emotionData[i - 1].endTime += dataFile.emotionData[i].blendInTime;
						}
						else
						{
							dataFile.emotionData[i].customBlendIn = true;
						}
						if (dataFile.emotionData[i].blendToMarker)
						{
							dataFile.emotionData[i + 1].startTime -= dataFile.emotionData[i].blendOutTime;
							dataFile.emotionData[i].endTime += dataFile.emotionData[i].blendOutTime;
						}
						else
						{
							dataFile.emotionData[i].customBlendOut = true;
							dataFile.emotionData[i].blendOutTime = 0f - dataFile.emotionData[i].blendOutTime;
						}
					}
					FixEmotionBlends(ref dataFile.emotionData);
					if (dataFile.length == 0f)
					{
						fileLength = audioClip.length;
					}
				}
				if (dataFile.version < 1.3f)
				{
					flag = true;
					for (int j = 0; j < dataFile.phonemeData.Length; j++)
					{
						dataFile.phonemeData[j].phonemeNumber = (int)dataFile.phonemeData[j].phoneme;
					}
				}
				if (flag)
				{
					UnityEngine.Debug.LogWarning("[LipSync - " + base.gameObject.name + "] Loading data from an old format LipSyncData file. For better performance, open this clip in the Clip Editor and re-save to update.");
				}
				phonemeMarkers = new List<PhonemeMarker>();
				emotionMarkers = new List<EmotionMarker>();
				gestureMarkers = new List<GestureMarker>();
				PhonemeMarker[] phonemeData = dataFile.phonemeData;
				foreach (PhonemeMarker item in phonemeData)
				{
					phonemeMarkers.Add(item);
				}
				EmotionMarker[] emotionData = dataFile.emotionData;
				foreach (EmotionMarker item2 in emotionData)
				{
					emotionMarkers.Add(item2);
				}
				GestureMarker[] gestureData = dataFile.gestureData;
				foreach (GestureMarker item3 in gestureData)
				{
					gestureMarkers.Add(item3);
				}
				emotionMarkers.Sort(EmotionSort);
				phonemeMarkers.Sort(SortTime);
				gestureMarkers.Sort(SortTime);
				audioSource.clip = audioClip;
				currentFileID = dataFile.GetInstanceID();
				lastClip = dataFile;
				return true;
			}
			return false;
		}

		private IEnumerator StopAudioSource(float delay)
		{
			yield return new WaitForSeconds(delay);
			audioSource.Stop();
		}

		private GestureInstance GetGesture(string name)
		{
			for (int i = 0; i < gestures.Count; i++)
			{
				if (gestures[i].gesture == name)
				{
					return gestures[i];
				}
			}
			return null;
		}

		public LipSync()
		{
			lastUsedVersion = 1.42f;
		}

		public static int SortTime(PhonemeMarker a, PhonemeMarker b)
		{
			float time = a.time;
			float time2 = b.time;
			return time.CompareTo(time2);
		}

		public static int SortTime(GestureMarker a, GestureMarker b)
		{
			float time = a.time;
			float time2 = b.time;
			return time.CompareTo(time2);
		}

		private static int EmotionSort(EmotionMarker a, EmotionMarker b)
		{
			return a.startTime.CompareTo(b.startTime);
		}

		public static string ReadXML(XmlDocument xml, string parentElement, string elementName)
		{
			return xml.SelectSingleNode("//" + parentElement + "//" + elementName)?.InnerText;
		}
	}
	public enum Phoneme
	{
		AI,
		E,
		U,
		O,
		CDGKNRSThYZ,
		FV,
		L,
		MBP,
		WQ,
		Rest
	}
}
namespace UnityStandardAssets.CrossPlatformInput
{
	public class AxisTouchButton : MonoBehaviour, IPointerDownHandler, IEventSystemHandler, IPointerUpHandler
	{
		public string axisName = "Horizontal";

		public float axisValue = 1f;

		public float responseSpeed = 3f;

		public float returnToCentreSpeed = 3f;

		private AxisTouchButton m_PairedWith;

		private CrossPlatformInputManager.VirtualAxis m_Axis;

		private void OnEnable()
		{
			if (!CrossPlatformInputManager.AxisExists(axisName))
			{
				m_Axis = new CrossPlatformInputManager.VirtualAxis(axisName);
				CrossPlatformInputManager.RegisterVirtualAxis(m_Axis);
			}
			else
			{
				m_Axis = CrossPlatformInputManager.VirtualAxisReference(axisName);
			}
			FindPairedButton();
		}

		private void FindPairedButton()
		{
			if (!(UnityEngine.Object.FindObjectsOfType(typeof(AxisTouchButton)) is AxisTouchButton[] array))
			{
				return;
			}
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i].axisName == axisName && array[i] != this)
				{
					m_PairedWith = array[i];
				}
			}
		}

		private void OnDisable()
		{
			m_Axis.Remove();
		}

		public void OnPointerDown(PointerEventData data)
		{
			if (m_PairedWith == null)
			{
				FindPairedButton();
			}
			m_Axis.Update(Mathf.MoveTowards(m_Axis.GetValue, axisValue, responseSpeed * Time.deltaTime));
		}

		public void OnPointerUp(PointerEventData data)
		{
			m_Axis.Update(Mathf.MoveTowards(m_Axis.GetValue, 0f, responseSpeed * Time.deltaTime));
		}
	}
	public class ButtonHandler : MonoBehaviour
	{
		public string Name;

		private void OnEnable()
		{
		}

		public void SetDownState()
		{
			CrossPlatformInputManager.SetButtonDown(Name);
		}

		public void SetUpState()
		{
			CrossPlatformInputManager.SetButtonUp(Name);
		}

		public void SetAxisPositiveState()
		{
			CrossPlatformInputManager.SetAxisPositive(Name);
		}

		public void SetAxisNeutralState()
		{
			CrossPlatformInputManager.SetAxisZero(Name);
		}

		public void SetAxisNegativeState()
		{
			CrossPlatformInputManager.SetAxisNegative(Name);
		}

		public void Update()
		{
		}
	}
	public static class CrossPlatformInputManager
	{
		public enum ActiveInputMethod
		{
			Hardware,
			Touch
		}

		public class VirtualAxis
		{
			private float m_Value;

			public string name { get; private set; }

			public bool matchWithInputManager { get; private set; }

			public float GetValue => m_Value;

			public float GetValueRaw => m_Value;

			public VirtualAxis(string name)
				: this(name, matchToInputSettings: true)
			{
			}

			public VirtualAxis(string name, bool matchToInputSettings)
			{
				this.name = name;
				matchWithInputManager = matchToInputSettings;
			}

			public void Remove()
			{
				UnRegisterVirtualAxis(name);
			}

			public void Update(float value)
			{
				m_Value = value;
			}
		}

		public class VirtualButton
		{
			private int m_LastPressedFrame = -5;

			private int m_ReleasedFrame = -5;

			private bool m_Pressed;

			public string name { get; private set; }

			public bool matchWithInputManager { get; private set; }

			public bool GetButton => m_Pressed;

			public bool GetButtonDown => m_LastPressedFrame - Time.frameCount == -1;

			public bool GetButtonUp => m_ReleasedFrame == Time.frameCount - 1;

			public VirtualButton(string name)
				: this(name, matchToInputSettings: true)
			{
			}

			public VirtualButton(string name, bool matchToInputSettings)
			{
				this.name = name;
				matchWithInputManager = matchToInputSettings;
			}

			public void Pressed()
			{
				if (!m_Pressed)
				{
					m_Pressed = true;
					m_LastPressedFrame = Time.frameCount;
				}
			}

			public void Released()
			{
				m_Pressed = false;
				m_ReleasedFrame = Time.frameCount;
			}

			public void Remove()
			{
				UnRegisterVirtualButton(name);
			}
		}

		private static VirtualInput activeInput;

		private static VirtualInput s_TouchInput;

		private static VirtualInput s_HardwareInput;

		public static Vector3 mousePosition => activeInput.MousePosition();

		static CrossPlatformInputManager()
		{
			s_TouchInput = new MobileInput();
			s_HardwareInput = new StandaloneInput();
			activeInput = s_TouchInput;
		}

		public static void SwitchActiveInputMethod(ActiveInputMethod activeInputMethod)
		{
			switch (activeInputMethod)
			{
			case ActiveInputMethod.Hardware:
				activeInput = s_HardwareInput;
				break;
			case ActiveInputMethod.Touch:
				activeInput = s_TouchInput;
				break;
			}
		}

		public static bool AxisExists(string name)
		{
			return activeInput.AxisExists(name);
		}

		public static bool ButtonExists(string name)
		{
			return activeInput.ButtonExists(name);
		}

		public static void RegisterVirtualAxis(VirtualAxis axis)
		{
			activeInput.RegisterVirtualAxis(axis);
		}

		public static void RegisterVirtualButton(VirtualButton button)
		{
			activeInput.RegisterVirtualButton(button);
		}

		public static void UnRegisterVirtualAxis(string name)
		{
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}
			activeInput.UnRegisterVirtualAxis(name);
		}

		public static void UnRegisterVirtualButton(string name)
		{
			activeInput.UnRegisterVirtualButton(name);
		}

		public static VirtualAxis VirtualAxisReference(string name)
		{
			return activeInput.VirtualAxisReference(name);
		}

		public static float GetAxis(string name)
		{
			return GetAxis(name, raw: false);
		}

		public static float GetAxisRaw(string name)
		{
			return GetAxis(name, raw: true);
		}

		private static float GetAxis(string name, bool raw)
		{
			return activeInput.GetAxis(name, raw);
		}

		public static bool GetButton(string name)
		{
			return activeInput.GetButton(name);
		}

		public static bool GetButtonDown(string name)
		{
			return activeInput.GetButtonDown(name);
		}

		public static bool GetButtonUp(string name)
		{
			return activeInput.GetButtonUp(name);
		}

		public static void SetButtonDown(string name)
		{
			activeInput.SetButtonDown(name);
		}

		public static void SetButtonUp(string name)
		{
			activeInput.SetButtonUp(name);
		}

		public static void SetAxisPositive(string name)
		{
			activeInput.SetAxisPositive(name);
		}

		public static void SetAxisNegative(string name)
		{
			activeInput.SetAxisNegative(name);
		}

		public static void SetAxisZero(string name)
		{
			activeInput.SetAxisZero(name);
		}

		public static void SetAxis(string name, float value)
		{
			activeInput.SetAxis(name, value);
		}

		public static void SetVirtualMousePositionX(float f)
		{
			activeInput.SetVirtualMousePositionX(f);
		}

		public static void SetVirtualMousePositionY(float f)
		{
			activeInput.SetVirtualMousePositionY(f);
		}

		public static void SetVirtualMousePositionZ(float f)
		{
			activeInput.SetVirtualMousePositionZ(f);
		}
	}
	public class InputAxisScrollbar : MonoBehaviour
	{
		public string axis;

		private void Update()
		{
		}

		public void HandleInput(float value)
		{
			CrossPlatformInputManager.SetAxis(axis, value * 2f - 1f);
		}
	}
	public class Joystick : MonoBehaviour, IPointerDownHandler, IEventSystemHandler, IPointerUpHandler, IDragHandler
	{
		public enum AxisOption
		{
			Both,
			OnlyHorizontal,
			OnlyVertical
		}

		public int MovementRange = 100;

		public AxisOption axesToUse;

		public string horizontalAxisName = "Horizontal";

		public string verticalAxisName = "Vertical";

		private Vector3 m_StartPos;

		private bool m_UseX;

		private bool m_UseY;

		private CrossPlatformInputManager.VirtualAxis m_HorizontalVirtualAxis;

		private CrossPlatformInputManager.VirtualAxis m_VerticalVirtualAxis;

		private void OnEnable()
		{
			m_StartPos = base.transform.position;
			CreateVirtualAxes();
		}

		private void UpdateVirtualAxes(Vector3 value)
		{
			Vector3 vector = m_StartPos - value;
			vector.y = 0f - vector.y;
			vector /= (float)MovementRange;
			if (m_UseX)
			{
				m_HorizontalVirtualAxis.Update(0f - vector.x);
			}
			if (m_UseY)
			{
				m_VerticalVirtualAxis.Update(vector.y);
			}
		}

		private void CreateVirtualAxes()
		{
			m_UseX = axesToUse == AxisOption.Both || axesToUse == AxisOption.OnlyHorizontal;
			m_UseY = axesToUse == AxisOption.Both || axesToUse == AxisOption.OnlyVertical;
			if (m_UseX)
			{
				m_HorizontalVirtualAxis = new CrossPlatformInputManager.VirtualAxis(horizontalAxisName);
				CrossPlatformInputManager.RegisterVirtualAxis(m_HorizontalVirtualAxis);
			}
			if (m_UseY)
			{
				m_VerticalVirtualAxis = new CrossPlatformInputManager.VirtualAxis(verticalAxisName);
				CrossPlatformInputManager.RegisterVirtualAxis(m_VerticalVirtualAxis);
			}
		}

		public void OnDrag(PointerEventData data)
		{
			Vector3 zero = Vector3.zero;
			if (m_UseX)
			{
				int value = (int)(data.position.x - m_StartPos.x);
				value = Mathf.Clamp(value, -MovementRange, MovementRange);
				zero.x = value;
			}
			if (m_UseY)
			{
				int value2 = (int)(data.position.y - m_StartPos.y);
				value2 = Mathf.Clamp(value2, -MovementRange, MovementRange);
				zero.y = value2;
			}
			base.transform.position = new Vector3(m_StartPos.x + zero.x, m_StartPos.y + zero.y, m_StartPos.z + zero.z);
			UpdateVirtualAxes(base.transform.position);
		}

		public void OnPointerUp(PointerEventData data)
		{
			base.transform.position = m_StartPos;
			UpdateVirtualAxes(m_StartPos);
		}

		public void OnPointerDown(PointerEventData data)
		{
		}

		private void OnDisable()
		{
			if (m_UseX)
			{
				m_HorizontalVirtualAxis.Remove();
			}
			if (m_UseY)
			{
				m_VerticalVirtualAxis.Remove();
			}
		}
	}
	[ExecuteInEditMode]
	public class MobileControlRig : MonoBehaviour
	{
		private void OnEnable()
		{
			CheckEnableControlRig();
		}

		private void CheckEnableControlRig()
		{
			EnableControlRig(enabled: true);
		}

		private void EnableControlRig(bool enabled)
		{
			foreach (Transform item in base.transform)
			{
				item.gameObject.SetActive(enabled);
			}
		}
	}
	public class TiltInput : MonoBehaviour
	{
		public enum AxisOptions
		{
			ForwardAxis,
			SidewaysAxis
		}

		[Serializable]
		public class AxisMapping
		{
			public enum MappingType
			{
				NamedAxis,
				MousePositionX,
				MousePositionY,
				MousePositionZ
			}

			public MappingType type;

			public string axisName;
		}

		public AxisMapping mapping;

		public AxisOptions tiltAroundAxis;

		public float fullTiltAngle = 25f;

		public float centreAngleOffset;

		private CrossPlatformInputManager.VirtualAxis m_SteerAxis;

		private void OnEnable()
		{
			if (mapping.type == AxisMapping.MappingType.NamedAxis)
			{
				m_SteerAxis = new CrossPlatformInputManager.VirtualAxis(mapping.axisName);
				CrossPlatformInputManager.RegisterVirtualAxis(m_SteerAxis);
			}
		}

		private void Update()
		{
			float value = 0f;
			if (Input.acceleration != Vector3.zero)
			{
				switch (tiltAroundAxis)
				{
				case AxisOptions.ForwardAxis:
					value = Mathf.Atan2(Input.acceleration.x, 0f - Input.acceleration.y) * 57.29578f + centreAngleOffset;
					break;
				case AxisOptions.SidewaysAxis:
					value = Mathf.Atan2(Input.acceleration.z, 0f - Input.acceleration.y) * 57.29578f + centreAngleOffset;
					break;
				}
			}
			float num = Mathf.InverseLerp(0f - fullTiltAngle, fullTiltAngle, value) * 2f - 1f;
			switch (mapping.type)
			{
			case AxisMapping.MappingType.NamedAxis:
				m_SteerAxis.Update(num);
				break;
			case AxisMapping.MappingType.MousePositionX:
				CrossPlatformInputManager.SetVirtualMousePositionX(num * (float)Screen.width);
				break;
			case AxisMapping.MappingType.MousePositionY:
				CrossPlatformInputManager.SetVirtualMousePositionY(num * (float)Screen.width);
				break;
			case AxisMapping.MappingType.MousePositionZ:
				CrossPlatformInputManager.SetVirtualMousePositionZ(num * (float)Screen.width);
				break;
			}
		}

		private void OnDisable()
		{
			m_SteerAxis.Remove();
		}
	}
	[RequireComponent(typeof(UnityEngine.UI.Image))]
	public class TouchPad : MonoBehaviour, IPointerDownHandler, IEventSystemHandler, IPointerUpHandler
	{
		public enum AxisOption
		{
			Both,
			OnlyHorizontal,
			OnlyVertical
		}

		public enum ControlStyle
		{
			Absolute,
			Relative,
			Swipe
		}

		public AxisOption axesToUse;

		public ControlStyle controlStyle;

		public string horizontalAxisName = "Horizontal";

		public string verticalAxisName = "Vertical";

		public float Xsensitivity = 1f;

		public float Ysensitivity = 1f;

		private Vector3 m_StartPos;

		private Vector2 m_PreviousDelta;

		private Vector3 m_JoytickOutput;

		private bool m_UseX;

		private bool m_UseY;

		private CrossPlatformInputManager.VirtualAxis m_HorizontalVirtualAxis;

		private CrossPlatformInputManager.VirtualAxis m_VerticalVirtualAxis;

		private bool m_Dragging;

		private int m_Id = -1;

		private Vector2 m_PreviousTouchPos;

		private Vector3 m_Center;

		private UnityEngine.UI.Image m_Image;

		private void OnEnable()
		{
			CreateVirtualAxes();
			m_Image = GetComponent<UnityEngine.UI.Image>();
			m_Center = m_Image.transform.position;
		}

		private void CreateVirtualAxes()
		{
			m_UseX = axesToUse == AxisOption.Both || axesToUse == AxisOption.OnlyHorizontal;
			m_UseY = axesToUse == AxisOption.Both || axesToUse == AxisOption.OnlyVertical;
			if (m_UseX)
			{
				m_HorizontalVirtualAxis = new CrossPlatformInputManager.VirtualAxis(horizontalAxisName);
				CrossPlatformInputManager.RegisterVirtualAxis(m_HorizontalVirtualAxis);
			}
			if (m_UseY)
			{
				m_VerticalVirtualAxis = new CrossPlatformInputManager.VirtualAxis(verticalAxisName);
				CrossPlatformInputManager.RegisterVirtualAxis(m_VerticalVirtualAxis);
			}
		}

		private void UpdateVirtualAxes(Vector3 value)
		{
			value = value.normalized;
			if (m_UseX)
			{
				m_HorizontalVirtualAxis.Update(value.x);
			}
			if (m_UseY)
			{
				m_VerticalVirtualAxis.Update(value.y);
			}
		}

		public void OnPointerDown(PointerEventData data)
		{
			m_Dragging = true;
			m_Id = data.pointerId;
			if (controlStyle != 0)
			{
				m_Center = data.position;
			}
		}

		private void Update()
		{
			if (m_Dragging && Input.touchCount >= m_Id + 1 && m_Id != -1)
			{
				if (controlStyle == ControlStyle.Swipe)
				{
					m_Center = m_PreviousTouchPos;
					m_PreviousTouchPos = Input.touches[m_Id].position;
				}
				Vector2 normalized = new Vector2(Input.touches[m_Id].position.x - m_Center.x, Input.touches[m_Id].position.y - m_Center.y).normalized;
				normalized.x *= Xsensitivity;
				normalized.y *= Ysensitivity;
				UpdateVirtualAxes(new Vector3(normalized.x, normalized.y, 0f));
			}
		}

		public void OnPointerUp(PointerEventData data)
		{
			m_Dragging = false;
			m_Id = -1;
			UpdateVirtualAxes(Vector3.zero);
		}

		private void OnDisable()
		{
			if (CrossPlatformInputManager.AxisExists(horizontalAxisName))
			{
				CrossPlatformInputManager.UnRegisterVirtualAxis(horizontalAxisName);
			}
			if (CrossPlatformInputManager.AxisExists(verticalAxisName))
			{
				CrossPlatformInputManager.UnRegisterVirtualAxis(verticalAxisName);
			}
		}
	}
	public abstract class VirtualInput
	{
		protected Dictionary<string, CrossPlatformInputManager.VirtualAxis> m_VirtualAxes = new Dictionary<string, CrossPlatformInputManager.VirtualAxis>();

		protected Dictionary<string, CrossPlatformInputManager.VirtualButton> m_VirtualButtons = new Dictionary<string, CrossPlatformInputManager.VirtualButton>();

		protected List<string> m_AlwaysUseVirtual = new List<string>();

		public Vector3 virtualMousePosition { get; private set; }

		public bool AxisExists(string name)
		{
			return m_VirtualAxes.ContainsKey(name);
		}

		public bool ButtonExists(string name)
		{
			return m_VirtualButtons.ContainsKey(name);
		}

		public void RegisterVirtualAxis(CrossPlatformInputManager.VirtualAxis axis)
		{
			if (m_VirtualAxes.ContainsKey(axis.name))
			{
				UnityEngine.Debug.LogError("There is already a virtual axis named " + axis.name + " registered.");
				return;
			}
			m_VirtualAxes.Add(axis.name, axis);
			if (!axis.matchWithInputManager)
			{
				m_AlwaysUseVirtual.Add(axis.name);
			}
		}

		public void RegisterVirtualButton(CrossPlatformInputManager.VirtualButton button)
		{
			if (m_VirtualButtons.ContainsKey(button.name))
			{
				UnityEngine.Debug.LogError("There is already a virtual button named " + button.name + " registered.");
				return;
			}
			m_VirtualButtons.Add(button.name, button);
			if (!button.matchWithInputManager)
			{
				m_AlwaysUseVirtual.Add(button.name);
			}
		}

		public void UnRegisterVirtualAxis(string name)
		{
			if (m_VirtualAxes.ContainsKey(name))
			{
				m_VirtualAxes.Remove(name);
			}
		}

		public void UnRegisterVirtualButton(string name)
		{
			if (m_VirtualButtons.ContainsKey(name))
			{
				m_VirtualButtons.Remove(name);
			}
		}

		public CrossPlatformInputManager.VirtualAxis VirtualAxisReference(string name)
		{
			if (!m_VirtualAxes.ContainsKey(name))
			{
				return null;
			}
			return m_VirtualAxes[name];
		}

		public void SetVirtualMousePositionX(float f)
		{
			virtualMousePosition = new Vector3(f, virtualMousePosition.y, virtualMousePosition.z);
		}

		public void SetVirtualMousePositionY(float f)
		{
			virtualMousePosition = new Vector3(virtualMousePosition.x, f, virtualMousePosition.z);
		}

		public void SetVirtualMousePositionZ(float f)
		{
			virtualMousePosition = new Vector3(virtualMousePosition.x, virtualMousePosition.y, f);
		}

		public abstract float GetAxis(string name, bool raw);

		public abstract bool GetButton(string name);

		public abstract bool GetButtonDown(string name);

		public abstract bool GetButtonUp(string name);

		public abstract void SetButtonDown(string name);

		public abstract void SetButtonUp(string name);

		public abstract void SetAxisPositive(string name);

		public abstract void SetAxisNegative(string name);

		public abstract void SetAxisZero(string name);

		public abstract void SetAxis(string name, float value);

		public abstract Vector3 MousePosition();
	}
}
namespace UnityStandardAssets.CrossPlatformInput.PlatformSpecific
{
	public class MobileInput : VirtualInput
	{
		private void AddButton(string name)
		{
			CrossPlatformInputManager.RegisterVirtualButton(new CrossPlatformInputManager.VirtualButton(name));
		}

		private void AddAxes(string name)
		{
			CrossPlatformInputManager.RegisterVirtualAxis(new CrossPlatformInputManager.VirtualAxis(name));
		}

		public override float GetAxis(string name, bool raw)
		{
			if (!m_VirtualAxes.ContainsKey(name))
			{
				AddAxes(name);
			}
			return m_VirtualAxes[name].GetValue;
		}

		public override void SetButtonDown(string name)
		{
			if (!m_VirtualButtons.ContainsKey(name))
			{
				AddButton(name);
			}
			m_VirtualButtons[name].Pressed();
		}

		public override void SetButtonUp(string name)
		{
			if (!m_VirtualButtons.ContainsKey(name))
			{
				AddButton(name);
			}
			m_VirtualButtons[name].Released();
		}

		public override void SetAxisPositive(string name)
		{
			if (!m_VirtualAxes.ContainsKey(name))
			{
				AddAxes(name);
			}
			m_VirtualAxes[name].Update(1f);
		}

		public override void SetAxisNegative(string name)
		{
			if (!m_VirtualAxes.ContainsKey(name))
			{
				AddAxes(name);
			}
			m_VirtualAxes[name].Update(-1f);
		}

		public override void SetAxisZero(string name)
		{
			if (!m_VirtualAxes.ContainsKey(name))
			{
				AddAxes(name);
			}
			m_VirtualAxes[name].Update(0f);
		}

		public override void SetAxis(string name, float value)
		{
			if (!m_VirtualAxes.ContainsKey(name))
			{
				AddAxes(name);
			}
			m_VirtualAxes[name].Update(value);
		}

		public override bool GetButtonDown(string name)
		{
			if (m_VirtualButtons.ContainsKey(name))
			{
				return m_VirtualButtons[name].GetButtonDown;
			}
			AddButton(name);
			return m_VirtualButtons[name].GetButtonDown;
		}

		public override bool GetButtonUp(string name)
		{
			if (m_VirtualButtons.ContainsKey(name))
			{
				return m_VirtualButtons[name].GetButtonUp;
			}
			AddButton(name);
			return m_VirtualButtons[name].GetButtonUp;
		}

		public override bool GetButton(string name)
		{
			if (m_VirtualButtons.ContainsKey(name))
			{
				return m_VirtualButtons[name].GetButton;
			}
			AddButton(name);
			return m_VirtualButtons[name].GetButton;
		}

		public override Vector3 MousePosition()
		{
			return base.virtualMousePosition;
		}
	}
	public class StandaloneInput : VirtualInput
	{
		public override float GetAxis(string name, bool raw)
		{
			if (!raw)
			{
				return Input.GetAxis(name);
			}
			return Input.GetAxisRaw(name);
		}

		public override bool GetButton(string name)
		{
			return Input.GetButton(name);
		}

		public override bool GetButtonDown(string name)
		{
			return Input.GetButtonDown(name);
		}

		public override bool GetButtonUp(string name)
		{
			return Input.GetButtonUp(name);
		}

		public override void SetButtonDown(string name)
		{
			throw new Exception(" This is not possible to be called for standalone input. Please check your platform and code where this is called");
		}

		public override void SetButtonUp(string name)
		{
			throw new Exception(" This is not possible to be called for standalone input. Please check your platform and code where this is called");
		}

		public override void SetAxisPositive(string name)
		{
			throw new Exception(" This is not possible to be called for standalone input. Please check your platform and code where this is called");
		}

		public override void SetAxisNegative(string name)
		{
			throw new Exception(" This is not possible to be called for standalone input. Please check your platform and code where this is called");
		}

		public override void SetAxisZero(string name)
		{
			throw new Exception(" This is not possible to be called for standalone input. Please check your platform and code where this is called");
		}

		public override void SetAxis(string name, float value)
		{
			throw new Exception(" This is not possible to be called for standalone input. Please check your platform and code where this is called");
		}

		public override Vector3 MousePosition()
		{
			return Input.mousePosition;
		}
	}
}
namespace UnityStandardAssets.Utility
{
	public class DragRigidbody : MonoBehaviour
	{
		private const float k_Spring = 50f;

		private const float k_Damper = 5f;

		private const float k_Drag = 10f;

		private const float k_AngularDrag = 5f;

		private const float k_Distance = 0.2f;

		private const bool k_AttachToCenterOfMass = false;

		private SpringJoint m_SpringJoint;

		private void Update()
		{
			if (!Input.GetMouseButtonDown(0))
			{
				return;
			}
			Camera camera = FindCamera();
			RaycastHit hitInfo = default(RaycastHit);
			if (Physics.Raycast(camera.ScreenPointToRay(Input.mousePosition).origin, camera.ScreenPointToRay(Input.mousePosition).direction, out hitInfo, 100f, -5) && (bool)hitInfo.rigidbody && !hitInfo.rigidbody.isKinematic)
			{
				if (!m_SpringJoint)
				{
					GameObject gameObject = new GameObject("Rigidbody dragger");
					Rigidbody rigidbody = gameObject.AddComponent<Rigidbody>();
					m_SpringJoint = gameObject.AddComponent<SpringJoint>();
					rigidbody.isKinematic = true;
				}
				m_SpringJoint.transform.position = hitInfo.point;
				m_SpringJoint.anchor = Vector3.zero;
				m_SpringJoint.spring = 50f;
				m_SpringJoint.damper = 5f;
				m_SpringJoint.maxDistance = 0.2f;
				m_SpringJoint.connectedBody = hitInfo.rigidbody;
				StartCoroutine("DragObject", hitInfo.distance);
			}
		}

		private IEnumerator DragObject(float distance)
		{
			float oldDrag = m_SpringJoint.connectedBody.drag;
			float oldAngularDrag = m_SpringJoint.connectedBody.angularDrag;
			m_SpringJoint.connectedBody.drag = 10f;
			m_SpringJoint.connectedBody.angularDrag = 5f;
			Camera mainCamera = FindCamera();
			while (Input.GetMouseButton(0))
			{
				Ray ray = mainCamera.ScreenPointToRay(Input.mousePosition);
				m_SpringJoint.transform.position = ray.GetPoint(distance);
				yield return null;
			}
			if ((bool)m_SpringJoint.connectedBody)
			{
				m_SpringJoint.connectedBody.drag = oldDrag;
				m_SpringJoint.connectedBody.angularDrag = oldAngularDrag;
				m_SpringJoint.connectedBody = null;
			}
		}

		private Camera FindCamera()
		{
			if ((bool)GetComponent<Camera>())
			{
				return GetComponent<Camera>();
			}
			return Camera.main;
		}
	}
	public class ActivateTrigger : MonoBehaviour
	{
		public enum Mode
		{
			Trigger,
			Replace,
			Activate,
			Enable,
			Animate,
			Deactivate
		}

		public Mode action = Mode.Activate;

		public UnityEngine.Object target;

		public GameObject source;

		public int triggerCount = 1;

		public bool repeatTrigger;

		private void DoActivateTrigger()
		{
			triggerCount--;
			if (triggerCount != 0 && !repeatTrigger)
			{
				return;
			}
			UnityEngine.Object obj = target ?? base.gameObject;
			Behaviour behaviour = obj as Behaviour;
			GameObject gameObject = obj as GameObject;
			if (behaviour != null)
			{
				gameObject = behaviour.gameObject;
			}
			switch (action)
			{
			case Mode.Trigger:
				if (gameObject != null)
				{
					gameObject.BroadcastMessage("DoActivateTrigger");
				}
				break;
			case Mode.Replace:
				if (source != null && gameObject != null)
				{
					UnityEngine.Object.Instantiate(source, gameObject.transform.position, gameObject.transform.rotation);
					UnityEngine.Object.DestroyObject(gameObject);
				}
				break;
			case Mode.Activate:
				if (gameObject != null)
				{
					gameObject.SetActive(value: true);
				}
				break;
			case Mode.Enable:
				if (behaviour != null)
				{
					behaviour.enabled = true;
				}
				break;
			case Mode.Animate:
				if (gameObject != null)
				{
					gameObject.GetComponent<Animation>().Play();
				}
				break;
			case Mode.Deactivate:
				if (gameObject != null)
				{
					gameObject.SetActive(value: false);
				}
				break;
			}
		}

		private void OnTriggerEnter(Collider other)
		{
			DoActivateTrigger();
		}
	}
	public class AutoMobileShaderSwitch : MonoBehaviour
	{
		[Serializable]
		public class ReplacementDefinition
		{
			public Shader original;

			public Shader replacement;
		}

		[Serializable]
		public class ReplacementList
		{
			public ReplacementDefinition[] items = new ReplacementDefinition[0];
		}

		[SerializeField]
		private ReplacementList m_ReplacementList;

		private void OnEnable()
		{
			Renderer[] array = UnityEngine.Object.FindObjectsOfType<Renderer>();
			UnityEngine.Debug.Log(array.Length + " renderers");
			List<Material> list = new List<Material>();
			List<Material> list2 = new List<Material>();
			int num = 0;
			int num2 = 0;
			ReplacementDefinition[] items = m_ReplacementList.items;
			foreach (ReplacementDefinition replacementDefinition in items)
			{
				Renderer[] array2 = array;
				foreach (Renderer renderer in array2)
				{
					Material[] array3 = null;
					for (int k = 0; k < renderer.sharedMaterials.Length; k++)
					{
						Material material = renderer.sharedMaterials[k];
						if (material.shader == replacementDefinition.original)
						{
							if (array3 == null)
							{
								array3 = renderer.materials;
							}
							if (!list.Contains(material))
							{
								list.Add(material);
								Material material2 = UnityEngine.Object.Instantiate(material);
								material2.shader = replacementDefinition.replacement;
								list2.Add(material2);
								num++;
							}
							UnityEngine.Debug.Log("replacing " + renderer.gameObject.name + " renderer " + k + " with " + list2[list.IndexOf(material)].name);
							array3[k] = list2[list.IndexOf(material)];
							num2++;
						}
					}
					if (array3 != null)
					{
						renderer.materials = array3;
					}
				}
			}
			UnityEngine.Debug.Log(num2 + " material instances replaced");
			UnityEngine.Debug.Log(num + " materials replaced");
			for (int l = 0; l < list.Count; l++)
			{
				UnityEngine.Debug.Log(list[l].name + " (" + list[l].shader.name + ") replaced with " + list2[l].name + " (" + list2[l].shader.name + ")");
			}
		}
	}
	public class AutoMoveAndRotate : MonoBehaviour
	{
		[Serializable]
		public class Vector3andSpace
		{
			public Vector3 value;

			public Space space = Space.Self;
		}

		public Vector3andSpace moveUnitsPerSecond;

		public Vector3andSpace rotateDegreesPerSecond;

		public bool ignoreTimescale;

		private float m_LastRealTime;

		private void Start()
		{
			m_LastRealTime = Time.realtimeSinceStartup;
		}

		private void Update()
		{
			float num = Time.deltaTime;
			if (ignoreTimescale)
			{
				num = Time.realtimeSinceStartup - m_LastRealTime;
				m_LastRealTime = Time.realtimeSinceStartup;
			}
			base.transform.Translate(moveUnitsPerSecond.value * num, moveUnitsPerSecond.space);
			base.transform.Rotate(rotateDegreesPerSecond.value * num, moveUnitsPerSecond.space);
		}
	}
	public class CameraRefocus
	{
		public Camera Camera;

		public Vector3 Lookatpoint;

		public Transform Parent;

		private Vector3 m_OrigCameraPos;

		private bool m_Refocus;

		public CameraRefocus(Camera camera, Transform parent, Vector3 origCameraPos)
		{
			m_OrigCameraPos = origCameraPos;
			Camera = camera;
			Parent = parent;
		}

		public void ChangeCamera(Camera camera)
		{
			Camera = camera;
		}

		public void ChangeParent(Transform parent)
		{
			Parent = parent;
		}

		public void GetFocusPoint()
		{
			if (Physics.Raycast(Parent.transform.position + m_OrigCameraPos, Parent.transform.forward, out var hitInfo, 100f))
			{
				Lookatpoint = hitInfo.point;
				m_Refocus = true;
			}
			else
			{
				m_Refocus = false;
			}
		}

		public void SetFocusPoint()
		{
			if (m_Refocus)
			{
				Camera.transform.LookAt(Lookatpoint);
			}
		}
	}
	[Serializable]
	public class CurveControlledBob
	{
		public float HorizontalBobRange = 0.33f;

		public float VerticalBobRange = 0.33f;

		public AnimationCurve Bobcurve = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(0.5f, 1f), new Keyframe(1f, 0f), new Keyframe(1.5f, -1f), new Keyframe(2f, 0f));

		public float VerticaltoHorizontalRatio = 1f;

		private float m_CyclePositionX;

		private float m_CyclePositionY;

		private float m_BobBaseInterval;

		private Vector3 m_OriginalCameraPosition;

		private float m_Time;

		public void Setup(Camera camera, float bobBaseInterval)
		{
			m_BobBaseInterval = bobBaseInterval;
			m_OriginalCameraPosition = camera.transform.localPosition;
			m_Time = Bobcurve[Bobcurve.length - 1].time;
		}

		public Vector3 DoHeadBob(float speed)
		{
			float x = m_OriginalCameraPosition.x + Bobcurve.Evaluate(m_CyclePositionX) * HorizontalBobRange;
			float y = m_OriginalCameraPosition.y + Bobcurve.Evaluate(m_CyclePositionY) * VerticalBobRange;
			m_CyclePositionX += speed * Time.deltaTime / m_BobBaseInterval;
			m_CyclePositionY += speed * Time.deltaTime / m_BobBaseInterval * VerticaltoHorizontalRatio;
			if (m_CyclePositionX > m_Time)
			{
				m_CyclePositionX -= m_Time;
			}
			if (m_CyclePositionY > m_Time)
			{
				m_CyclePositionY -= m_Time;
			}
			return new Vector3(x, y, 0f);
		}
	}
	public class DynamicShadowSettings : MonoBehaviour
	{
		public Light sunLight;

		public float minHeight = 10f;

		public float minShadowDistance = 80f;

		public float minShadowBias = 1f;

		public float maxHeight = 1000f;

		public float maxShadowDistance = 10000f;

		public float maxShadowBias = 0.1f;

		public float adaptTime = 1f;

		private float m_SmoothHeight;

		private float m_ChangeSpeed;

		private float m_OriginalStrength = 1f;

		private void Start()
		{
			m_OriginalStrength = sunLight.shadowStrength;
		}

		private void Update()
		{
			Ray ray = new Ray(Camera.main.transform.position, -Vector3.up);
			float num = base.transform.position.y;
			if (Physics.Raycast(ray, out var hitInfo))
			{
				num = hitInfo.distance;
			}
			if (Mathf.Abs(num - m_SmoothHeight) > 1f)
			{
				m_SmoothHeight = Mathf.SmoothDamp(m_SmoothHeight, num, ref m_ChangeSpeed, adaptTime);
			}
			float num2 = Mathf.InverseLerp(minHeight, maxHeight, m_SmoothHeight);
			QualitySettings.shadowDistance = Mathf.Lerp(minShadowDistance, maxShadowDistance, num2);
			sunLight.shadowBias = Mathf.Lerp(minShadowBias, maxShadowBias, 1f - (1f - num2) * (1f - num2));
			sunLight.shadowStrength = Mathf.Lerp(m_OriginalStrength, 0f, num2);
		}
	}
	public class FollowTarget : MonoBehaviour
	{
		public Transform target;

		public Vector3 offset = new Vector3(0f, 7.5f, 0f);

		private void LateUpdate()
		{
			base.transform.position = target.position + offset;
		}
	}
	[Serializable]
	public class FOVKick
	{
		public Camera Camera;

		[HideInInspector]
		public float originalFov;

		public float FOVIncrease = 3f;

		public float TimeToIncrease = 1f;

		public float TimeToDecrease = 1f;

		public AnimationCurve IncreaseCurve;

		public void Setup(Camera camera)
		{
			CheckStatus(camera);
			Camera = camera;
			originalFov = camera.fieldOfView;
		}

		private void CheckStatus(Camera camera)
		{
			if (camera == null)
			{
				throw new Exception("FOVKick camera is null, please supply the camera to the constructor");
			}
			if (IncreaseCurve == null)
			{
				throw new Exception("FOVKick Increase curve is null, please define the curve for the field of view kicks");
			}
		}

		public void ChangeCamera(Camera camera)
		{
			Camera = camera;
		}

		public IEnumerator FOVKickUp()
		{
			float t = Mathf.Abs((Camera.fieldOfView - originalFov) / FOVIncrease);
			while (t < TimeToIncrease)
			{
				Camera.fieldOfView = originalFov + IncreaseCurve.Evaluate(t / TimeToIncrease) * FOVIncrease;
				t += Time.deltaTime;
				yield return new WaitForEndOfFrame();
			}
		}

		public IEnumerator FOVKickDown()
		{
			float t = Mathf.Abs((Camera.fieldOfView - originalFov) / FOVIncrease);
			while (t > 0f)
			{
				Camera.fieldOfView = originalFov + IncreaseCurve.Evaluate(t / TimeToDecrease) * FOVIncrease;
				t -= Time.deltaTime;
				yield return new WaitForEndOfFrame();
			}
			Camera.fieldOfView = originalFov;
		}
	}
	[RequireComponent(typeof(GUIText))]
	public class FPSCounter : MonoBehaviour
	{
		private const float fpsMeasurePeriod = 0.5f;

		private int m_FpsAccumulator;

		private float m_FpsNextPeriod;

		private int m_CurrentFps;

		private const string display = "{0} FPS";

		private GUIText m_GuiText;

		private void Start()
		{
			m_FpsNextPeriod = Time.realtimeSinceStartup + 0.5f;
			m_GuiText = GetComponent<GUIText>();
		}

		private void Update()
		{
			m_FpsAccumulator++;
			if (Time.realtimeSinceStartup > m_FpsNextPeriod)
			{
				m_CurrentFps = (int)((float)m_FpsAccumulator / 0.5f);
				m_FpsAccumulator = 0;
				m_FpsNextPeriod += 0.5f;
				m_GuiText.text = $"{m_CurrentFps} FPS";
			}
		}
	}
	[Serializable]
	public class LerpControlledBob
	{
		public float BobDuration;

		public float BobAmount;

		private float m_Offset;

		public float Offset()
		{
			return m_Offset;
		}

		public IEnumerator DoBobCycle()
		{
			float t2 = 0f;
			while (t2 < BobDuration)
			{
				m_Offset = Mathf.Lerp(0f, BobAmount, t2 / BobDuration);
				t2 += Time.deltaTime;
				yield return new WaitForFixedUpdate();
			}
			t2 = 0f;
			while (t2 < BobDuration)
			{
				m_Offset = Mathf.Lerp(BobAmount, 0f, t2 / BobDuration);
				t2 += Time.deltaTime;
				yield return new WaitForFixedUpdate();
			}
			m_Offset = 0f;
		}
	}
	public class ObjectResetter : MonoBehaviour
	{
		private Vector3 originalPosition;

		private Quaternion originalRotation;

		private List<Transform> originalStructure;

		private Rigidbody Rigidbody;

		private void Start()
		{
			originalStructure = new List<Transform>(GetComponentsInChildren<Transform>());
			originalPosition = base.transform.position;
			originalRotation = base.transform.rotation;
			Rigidbody = GetComponent<Rigidbody>();
		}

		public void DelayedReset(float delay)
		{
			StartCoroutine(ResetCoroutine(delay));
		}

		public IEnumerator ResetCoroutine(float delay)
		{
			yield return new WaitForSeconds(delay);
			Transform[] componentsInChildren = GetComponentsInChildren<Transform>();
			foreach (Transform transform in componentsInChildren)
			{
				if (!originalStructure.Contains(transform))
				{
					transform.parent = null;
				}
			}
			base.transform.position = originalPosition;
			base.transform.rotation = originalRotation;
			if ((bool)Rigidbody)
			{
				Rigidbody.velocity = Vector3.zero;
				Rigidbody.angularVelocity = Vector3.zero;
			}
			SendMessage("Reset");
		}
	}
	public class ParticleSystemDestroyer : MonoBehaviour
	{
		public float minDuration = 8f;

		public float maxDuration = 10f;

		private float m_MaxLifetime;

		private bool m_EarlyStop;

		private IEnumerator Start()
		{
			ParticleSystem[] systems = GetComponentsInChildren<ParticleSystem>();
			ParticleSystem[] array = systems;
			foreach (ParticleSystem particleSystem in array)
			{
				m_MaxLifetime = Mathf.Max(particleSystem.startLifetime, m_MaxLifetime);
			}
			float stopTime = Time.time + UnityEngine.Random.Range(minDuration, maxDuration);
			while (Time.time < stopTime || m_EarlyStop)
			{
				yield return null;
			}
			UnityEngine.Debug.Log("stopping " + base.name);
			array = systems;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].enableEmission = false;
			}
			BroadcastMessage("Extinguish", SendMessageOptions.DontRequireReceiver);
			yield return new WaitForSeconds(m_MaxLifetime);
			UnityEngine.Object.Destroy(base.gameObject);
		}

		public void Stop()
		{
			m_EarlyStop = true;
		}
	}
	public class PlatformSpecificContent : MonoBehaviour
	{
		private enum BuildTargetGroup
		{
			Standalone,
			Mobile
		}

		[SerializeField]
		private BuildTargetGroup m_BuildTargetGroup;

		[SerializeField]
		private GameObject[] m_Content = new GameObject[0];

		[SerializeField]
		private MonoBehaviour[] m_MonoBehaviours = new MonoBehaviour[0];

		[SerializeField]
		private bool m_ChildrenOfThisObject;

		private void OnEnable()
		{
			CheckEnableContent();
		}

		private void CheckEnableContent()
		{
			if (m_BuildTargetGroup == BuildTargetGroup.Mobile)
			{
				EnableContent(enabled: true);
			}
			else
			{
				EnableContent(enabled: false);
			}
		}

		private void EnableContent(bool enabled)
		{
			if (m_Content.Length != 0)
			{
				GameObject[] content = m_Content;
				foreach (GameObject gameObject in content)
				{
					if (gameObject != null)
					{
						gameObject.SetActive(enabled);
					}
				}
			}
			if (m_ChildrenOfThisObject)
			{
				foreach (Transform item in base.transform)
				{
					item.gameObject.SetActive(enabled);
				}
			}
			if (m_MonoBehaviours.Length != 0)
			{
				MonoBehaviour[] monoBehaviours = m_MonoBehaviours;
				for (int i = 0; i < monoBehaviours.Length; i++)
				{
					monoBehaviours[i].enabled = enabled;
				}
			}
		}
	}
	public class SimpleActivatorMenu : MonoBehaviour
	{
		public GUIText camSwitchButton;

		public GameObject[] objects;

		private int m_CurrentActiveObject;

		private void OnEnable()
		{
			m_CurrentActiveObject = 0;
			camSwitchButton.text = objects[m_CurrentActiveObject].name;
		}

		public void NextCamera()
		{
			int num = ((m_CurrentActiveObject + 1 < objects.Length) ? (m_CurrentActiveObject + 1) : 0);
			for (int i = 0; i < objects.Length; i++)
			{
				objects[i].SetActive(i == num);
			}
			m_CurrentActiveObject = num;
			camSwitchButton.text = objects[m_CurrentActiveObject].name;
		}
	}
	public class SimpleMouseRotator : MonoBehaviour
	{
		public Vector2 rotationRange = new Vector3(70f, 70f);

		public float rotationSpeed = 10f;

		public float dampingTime = 0.2f;

		public bool autoZeroVerticalOnMobile = true;

		public bool autoZeroHorizontalOnMobile;

		public bool relative = true;

		private Vector3 m_TargetAngles;

		private Vector3 m_FollowAngles;

		private Vector3 m_FollowVelocity;

		private Quaternion m_OriginalRotation;

		private void Start()
		{
			m_OriginalRotation = base.transform.localRotation;
		}

		private void Update()
		{
			base.transform.localRotation = m_OriginalRotation;
			if (relative)
			{
				float axis = CrossPlatformInputManager.GetAxis("Mouse X");
				float axis2 = CrossPlatformInputManager.GetAxis("Mouse Y");
				if (m_TargetAngles.y > 180f)
				{
					m_TargetAngles.y -= 360f;
					m_FollowAngles.y -= 360f;
				}
				if (m_TargetAngles.x > 180f)
				{
					m_TargetAngles.x -= 360f;
					m_FollowAngles.x -= 360f;
				}
				if (m_TargetAngles.y < -180f)
				{
					m_TargetAngles.y += 360f;
					m_FollowAngles.y += 360f;
				}
				if (m_TargetAngles.x < -180f)
				{
					m_TargetAngles.x += 360f;
					m_FollowAngles.x += 360f;
				}
				if (autoZeroHorizontalOnMobile)
				{
					m_TargetAngles.y = Mathf.Lerp((0f - rotationRange.y) * 0.5f, rotationRange.y * 0.5f, axis * 0.5f + 0.5f);
				}
				else
				{
					m_TargetAngles.y += axis * rotationSpeed;
				}
				if (autoZeroVerticalOnMobile)
				{
					m_TargetAngles.x = Mathf.Lerp((0f - rotationRange.x) * 0.5f, rotationRange.x * 0.5f, axis2 * 0.5f + 0.5f);
				}
				else
				{
					m_TargetAngles.x += axis2 * rotationSpeed;
				}
				m_TargetAngles.y = Mathf.Clamp(m_TargetAngles.y, (0f - rotationRange.y) * 0.5f, rotationRange.y * 0.5f);
				m_TargetAngles.x = Mathf.Clamp(m_TargetAngles.x, (0f - rotationRange.x) * 0.5f, rotationRange.x * 0.5f);
			}
			else
			{
				float axis = Input.mousePosition.x;
				float axis2 = Input.mousePosition.y;
				m_TargetAngles.y = Mathf.Lerp((0f - rotationRange.y) * 0.5f, rotationRange.y * 0.5f, axis / (float)Screen.width);
				m_TargetAngles.x = Mathf.Lerp((0f - rotationRange.x) * 0.5f, rotationRange.x * 0.5f, axis2 / (float)Screen.height);
			}
			m_FollowAngles = Vector3.SmoothDamp(m_FollowAngles, m_TargetAngles, ref m_FollowVelocity, dampingTime);
			base.transform.localRotation = m_OriginalRotation * Quaternion.Euler(0f - m_FollowAngles.x, m_FollowAngles.y, 0f);
		}
	}
	public class SmoothFollow : MonoBehaviour
	{
		[SerializeField]
		private Transform target;

		[SerializeField]
		private float distance = 10f;

		[SerializeField]
		private float height = 5f;

		[SerializeField]
		private float rotationDamping;

		[SerializeField]
		private float heightDamping;

		private void Start()
		{
		}

		private void LateUpdate()
		{
			if ((bool)target)
			{
				float y = target.eulerAngles.y;
				float b = target.position.y + height;
				float y2 = base.transform.eulerAngles.y;
				float y3 = base.transform.position.y;
				y2 = Mathf.LerpAngle(y2, y, rotationDamping * Time.deltaTime);
				y3 = Mathf.Lerp(y3, b, heightDamping * Time.deltaTime);
				Quaternion quaternion = Quaternion.Euler(0f, y2, 0f);
				base.transform.position = target.position;
				base.transform.position -= quaternion * Vector3.forward * distance;
				base.transform.position = new Vector3(base.transform.position.x, y3, base.transform.position.z);
				base.transform.LookAt(target);
			}
		}
	}
	public class TimedObjectActivator : MonoBehaviour
	{
		public enum Action
		{
			Activate,
			Deactivate,
			Destroy,
			ReloadLevel,
			Call
		}

		[Serializable]
		public class Entry
		{
			public GameObject target;

			public Action action;

			public float delay;
		}

		[Serializable]
		public class Entries
		{
			public Entry[] entries;
		}

		public Entries entries = new Entries();

		private void Awake()
		{
			Entry[] array = entries.entries;
			foreach (Entry entry in array)
			{
				switch (entry.action)
				{
				case Action.Activate:
					StartCoroutine(Activate(entry));
					break;
				case Action.Deactivate:
					StartCoroutine(Deactivate(entry));
					break;
				case Action.Destroy:
					UnityEngine.Object.Destroy(entry.target, entry.delay);
					break;
				case Action.ReloadLevel:
					StartCoroutine(ReloadLevel(entry));
					break;
				}
			}
		}

		private IEnumerator Activate(Entry entry)
		{
			yield return new WaitForSeconds(entry.delay);
			entry.target.SetActive(value: true);
		}

		private IEnumerator Deactivate(Entry entry)
		{
			yield return new WaitForSeconds(entry.delay);
			entry.target.SetActive(value: false);
		}

		private IEnumerator ReloadLevel(Entry entry)
		{
			yield return new WaitForSeconds(entry.delay);
			Application.LoadLevel(Application.loadedLevel);
		}
	}
	public class TimedObjectDestructor : MonoBehaviour
	{
		[SerializeField]
		private float m_TimeOut = 1f;

		[SerializeField]
		private bool m_DetachChildren;

		private void Awake()
		{
			Invoke("DestroyNow", m_TimeOut);
		}

		private void DestroyNow()
		{
			if (m_DetachChildren)
			{
				base.transform.DetachChildren();
			}
			UnityEngine.Object.DestroyObject(base.gameObject);
		}
	}
	public class WaypointCircuit : MonoBehaviour
	{
		[Serializable]
		public class WaypointList
		{
			public WaypointCircuit circuit;

			public Transform[] items = new Transform[0];
		}

		public struct RoutePoint
		{
			public Vector3 position;

			public Vector3 direction;

			public RoutePoint(Vector3 position, Vector3 direction)
			{
				this.position = position;
				this.direction = direction;
			}
		}

		public WaypointList waypointList = new WaypointList();

		[SerializeField]
		private bool smoothRoute = true;

		private int numPoints;

		private Vector3[] points;

		private float[] distances;

		public float editorVisualisationSubsteps = 100f;

		private int p0n;

		private int p1n;

		private int p2n;

		private int p3n;

		private float i;

		private Vector3 P0;

		private Vector3 P1;

		private Vector3 P2;

		private Vector3 P3;

		public float Length { get; private set; }

		public Transform[] Waypoints => waypointList.items;

		private void Awake()
		{
			if (Waypoints.Length > 1)
			{
				CachePositionsAndDistances();
			}
			numPoints = Waypoints.Length;
		}

		public RoutePoint GetRoutePoint(float dist)
		{
			Vector3 routePosition = GetRoutePosition(dist);
			return new RoutePoint(routePosition, (GetRoutePosition(dist + 0.1f) - routePosition).normalized);
		}

		public Vector3 GetRoutePosition(float dist)
		{
			int i = 0;
			if (Length == 0f)
			{
				Length = distances[distances.Length - 1];
			}
			for (dist = Mathf.Repeat(dist, Length); distances[i] < dist; i++)
			{
			}
			p1n = (i - 1 + numPoints) % numPoints;
			p2n = i;
			this.i = Mathf.InverseLerp(distances[p1n], distances[p2n], dist);
			if (smoothRoute)
			{
				p0n = (i - 2 + numPoints) % numPoints;
				p3n = (i + 1) % numPoints;
				p2n %= numPoints;
				P0 = points[p0n];
				P1 = points[p1n];
				P2 = points[p2n];
				P3 = points[p3n];
				return CatmullRom(P0, P1, P2, P3, this.i);
			}
			p1n = (i - 1 + numPoints) % numPoints;
			p2n = i;
			return Vector3.Lerp(points[p1n], points[p2n], this.i);
		}

		private Vector3 CatmullRom(Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3, float i)
		{
			return 0.5f * (2f * p1 + (-p0 + p2) * i + (2f * p0 - 5f * p1 + 4f * p2 - p3) * i * i + (-p0 + 3f * p1 - 3f * p2 + p3) * i * i * i);
		}

		private void CachePositionsAndDistances()
		{
			points = new Vector3[Waypoints.Length + 1];
			distances = new float[Waypoints.Length + 1];
			float num = 0f;
			for (int i = 0; i < points.Length; i++)
			{
				Transform transform = Waypoints[i % Waypoints.Length];
				Transform transform2 = Waypoints[(i + 1) % Waypoints.Length];
				if (transform != null && transform2 != null)
				{
					Vector3 position = transform.position;
					Vector3 position2 = transform2.position;
					points[i] = Waypoints[i % Waypoints.Length].position;
					distances[i] = num;
					num += (position - position2).magnitude;
				}
			}
		}

		private void OnDrawGizmos()
		{
			DrawGizmos(selected: false);
		}

		private void OnDrawGizmosSelected()
		{
			DrawGizmos(selected: true);
		}

		private void DrawGizmos(bool selected)
		{
			waypointList.circuit = this;
			if (Waypoints.Length <= 1)
			{
				return;
			}
			numPoints = Waypoints.Length;
			CachePositionsAndDistances();
			Length = distances[distances.Length - 1];
			Gizmos.color = (selected ? UnityEngine.Color.yellow : new UnityEngine.Color(1f, 1f, 0f, 0.5f));
			Vector3 from = Waypoints[0].position;
			if (smoothRoute)
			{
				for (float num = 0f; num < Length; num += Length / editorVisualisationSubsteps)
				{
					Vector3 routePosition = GetRoutePosition(num + 1f);
					Gizmos.DrawLine(from, routePosition);
					from = routePosition;
				}
				Gizmos.DrawLine(from, Waypoints[0].position);
			}
			else
			{
				for (int i = 0; i < Waypoints.Length; i++)
				{
					Vector3 position = Waypoints[(i + 1) % Waypoints.Length].position;
					Gizmos.DrawLine(from, position);
					from = position;
				}
			}
		}
	}
	public class WaypointProgressTracker : MonoBehaviour
	{
		public enum ProgressStyle
		{
			SmoothAlongRoute,
			PointToPoint
		}

		[SerializeField]
		private WaypointCircuit circuit;

		[SerializeField]
		private float lookAheadForTargetOffset = 5f;

		[SerializeField]
		private float lookAheadForTargetFactor = 0.1f;

		[SerializeField]
		private float lookAheadForSpeedOffset = 10f;

		[SerializeField]
		private float lookAheadForSpeedFactor = 0.2f;

		[SerializeField]
		private ProgressStyle progressStyle;

		[SerializeField]
		private float pointToPointThreshold = 4f;

		public Transform target;

		private float progressDistance;

		private int progressNum;

		private Vector3 lastPosition;

		private float speed;

		public WaypointCircuit.RoutePoint targetPoint { get; private set; }

		public WaypointCircuit.RoutePoint speedPoint { get; private set; }

		public WaypointCircuit.RoutePoint progressPoint { get; private set; }

		private void Start()
		{
			if (target == null)
			{
				target = new GameObject(base.name + " Waypoint Target").transform;
			}
			Reset();
		}

		public void Reset()
		{
			progressDistance = 0f;
			progressNum = 0;
			if (progressStyle == ProgressStyle.PointToPoint)
			{
				target.position = circuit.Waypoints[progressNum].position;
				target.rotation = circuit.Waypoints[progressNum].rotation;
			}
		}

		private void Update()
		{
			if (progressStyle == ProgressStyle.SmoothAlongRoute)
			{
				if (Time.deltaTime > 0f)
				{
					speed = Mathf.Lerp(speed, (lastPosition - base.transform.position).magnitude / Time.deltaTime, Time.deltaTime);
				}
				target.position = circuit.GetRoutePoint(progressDistance + lookAheadForTargetOffset + lookAheadForTargetFactor * speed).position;
				target.rotation = Quaternion.LookRotation(circuit.GetRoutePoint(progressDistance + lookAheadForSpeedOffset + lookAheadForSpeedFactor * speed).direction);
				progressPoint = circuit.GetRoutePoint(progressDistance);
				Vector3 lhs = progressPoint.position - base.transform.position;
				if (Vector3.Dot(lhs, progressPoint.direction) < 0f)
				{
					progressDistance += lhs.magnitude * 0.5f;
				}
				lastPosition = base.transform.position;
			}
			else
			{
				if ((target.position - base.transform.position).magnitude < pointToPointThreshold)
				{
					progressNum = (progressNum + 1) % circuit.Waypoints.Length;
				}
				target.position = circuit.Waypoints[progressNum].position;
				target.rotation = circuit.Waypoints[progressNum].rotation;
				progressPoint = circuit.GetRoutePoint(progressDistance);
				Vector3 lhs2 = progressPoint.position - base.transform.position;
				if (Vector3.Dot(lhs2, progressPoint.direction) < 0f)
				{
					progressDistance += lhs2.magnitude;
				}
				lastPosition = base.transform.position;
			}
		}

		private void OnDrawGizmos()
		{
			if (Application.isPlaying)
			{
				Gizmos.color = UnityEngine.Color.green;
				Gizmos.DrawLine(base.transform.position, target.position);
				Gizmos.DrawWireSphere(circuit.GetRoutePosition(progressDistance), 1f);
				Gizmos.color = UnityEngine.Color.yellow;
				Gizmos.DrawLine(target.position, target.position + target.forward);
			}
		}
	}
}
namespace UnityStandardAssets.Characters.ThirdPerson
{
	[RequireComponent(typeof(NavMeshAgent))]
	[RequireComponent(typeof(ThirdPersonCharacter))]
	public class AICharacterControl : MonoBehaviour
	{
		public Transform target;

		public NavMeshAgent agent { get; private set; }

		public ThirdPersonCharacter character { get; private set; }

		private void Start()
		{
			agent = GetComponentInChildren<NavMeshAgent>();
			character = GetComponent<ThirdPersonCharacter>();
			agent.updateRotation = false;
			agent.updatePosition = true;
		}

		private void Update()
		{
			if (target != null)
			{
				agent.SetDestination(target.position);
				character.Move(agent.desiredVelocity, crouch: false, jump: false);
			}
			else
			{
				character.Move(Vector3.zero, crouch: false, jump: false);
			}
		}

		public void SetTarget(Transform target)
		{
			this.target = target;
		}
	}
	[RequireComponent(typeof(Rigidbody))]
	[RequireComponent(typeof(CapsuleCollider))]
	[RequireComponent(typeof(Animator))]
	public class ThirdPersonCharacter : MonoBehaviour
	{
		[SerializeField]
		private float m_MovingTurnSpeed = 360f;

		[SerializeField]
		private float m_StationaryTurnSpeed = 180f;

		[SerializeField]
		private float m_JumpPower = 12f;

		[Range(1f, 4f)]
		[SerializeField]
		private float m_GravityMultiplier = 2f;

		[SerializeField]
		private float m_RunCycleLegOffset = 0.2f;

		[SerializeField]
		private float m_MoveSpeedMultiplier = 1f;

		[SerializeField]
		private float m_AnimSpeedMultiplier = 1f;

		[SerializeField]
		private float m_GroundCheckDistance = 0.1f;

		private Rigidbody m_Rigidbody;

		private Animator m_Animator;

		private bool m_IsGrounded;

		private float m_OrigGroundCheckDistance;

		private const float k_Half = 0.5f;

		private float m_TurnAmount;

		private float m_ForwardAmount;

		private Vector3 m_GroundNormal;

		private float m_CapsuleHeight;

		private Vector3 m_CapsuleCenter;

		private CapsuleCollider m_Capsule;

		private bool m_Crouching;

		private void Start()
		{
			m_Animator = GetComponent<Animator>();
			m_Rigidbody = GetComponent<Rigidbody>();
			m_Capsule = GetComponent<CapsuleCollider>();
			m_CapsuleHeight = m_Capsule.height;
			m_CapsuleCenter = m_Capsule.center;
			m_Rigidbody.constraints = RigidbodyConstraints.FreezeRotation;
			m_OrigGroundCheckDistance = m_GroundCheckDistance;
		}

		public void Move(Vector3 move, bool crouch, bool jump)
		{
			if (move.magnitude > 1f)
			{
				move.Normalize();
			}
			move = base.transform.InverseTransformDirection(move);
			CheckGroundStatus();
			move = Vector3.ProjectOnPlane(move, m_GroundNormal);
			m_TurnAmount = Mathf.Atan2(move.x, move.z);
			m_ForwardAmount = move.z;
			ApplyExtraTurnRotation();
			if (m_IsGrounded)
			{
				HandleGroundedMovement(crouch, jump);
			}
			else
			{
				HandleAirborneMovement();
			}
			ScaleCapsuleForCrouching(crouch);
			PreventStandingInLowHeadroom();
			UpdateAnimator(move);
		}

		private void ScaleCapsuleForCrouching(bool crouch)
		{
			if (m_IsGrounded && crouch)
			{
				if (!m_Crouching)
				{
					m_Capsule.height /= 2f;
					m_Capsule.center /= 2f;
					m_Crouching = true;
				}
			}
			else if (Physics.SphereCast(new Ray(m_Rigidbody.position + Vector3.up * m_Capsule.radius * 0.5f, Vector3.up), maxDistance: m_CapsuleHeight - m_Capsule.radius * 0.5f, radius: m_Capsule.radius * 0.5f))
			{
				m_Crouching = true;
			}
			else
			{
				m_Capsule.height = m_CapsuleHeight;
				m_Capsule.center = m_CapsuleCenter;
				m_Crouching = false;
			}
		}

		private void PreventStandingInLowHeadroom()
		{
			if (!m_Crouching && Physics.SphereCast(new Ray(m_Rigidbody.position + Vector3.up * m_Capsule.radius * 0.5f, Vector3.up), maxDistance: m_CapsuleHeight - m_Capsule.radius * 0.5f, radius: m_Capsule.radius * 0.5f))
			{
				m_Crouching = true;
			}
		}

		private void UpdateAnimator(Vector3 move)
		{
			m_Animator.SetFloat("Forward", m_ForwardAmount, 0.1f, Time.deltaTime);
			m_Animator.SetFloat("Turn", m_TurnAmount, 0.1f, Time.deltaTime);
			m_Animator.SetBool("Crouch", m_Crouching);
			m_Animator.SetBool("OnGround", m_IsGrounded);
			if (!m_IsGrounded)
			{
				m_Animator.SetFloat("Jump", m_Rigidbody.velocity.y);
			}
			float value = (float)((Mathf.Repeat(m_Animator.GetCurrentAnimatorStateInfo(0).normalizedTime + m_RunCycleLegOffset, 1f) < 0.5f) ? 1 : (-1)) * m_ForwardAmount;
			if (m_IsGrounded)
			{
				m_Animator.SetFloat("JumpLeg", value);
			}
			if (m_IsGrounded && move.magnitude > 0f)
			{
				m_Animator.speed = m_AnimSpeedMultiplier;
			}
			else
			{
				m_Animator.speed = 1f;
			}
		}

		private void HandleAirborneMovement()
		{
			Vector3 force = Physics.gravity * m_GravityMultiplier - Physics.gravity;
			m_Rigidbody.AddForce(force);
			m_GroundCheckDistance = ((m_Rigidbody.velocity.y < 0f) ? m_OrigGroundCheckDistance : 0.01f);
		}

		private void HandleGroundedMovement(bool crouch, bool jump)
		{
			if (jump && !crouch && m_Animator.GetCurrentAnimatorStateInfo(0).IsName("Grounded"))
			{
				m_Rigidbody.velocity = new Vector3(m_Rigidbody.velocity.x, m_JumpPower, m_Rigidbody.velocity.z);
				m_IsGrounded = false;
				m_Animator.applyRootMotion = false;
				m_GroundCheckDistance = 0.1f;
			}
		}

		private void ApplyExtraTurnRotation()
		{
			float num = Mathf.Lerp(m_StationaryTurnSpeed, m_MovingTurnSpeed, m_ForwardAmount);
			base.transform.Rotate(0f, m_TurnAmount * num * Time.deltaTime, 0f);
		}

		public void OnAnimatorMove()
		{
			if (m_IsGrounded && Time.deltaTime > 0f)
			{
				Vector3 velocity = m_Animator.deltaPosition * m_MoveSpeedMultiplier / Time.deltaTime;
				velocity.y = m_Rigidbody.velocity.y;
				m_Rigidbody.velocity = velocity;
			}
		}

		private void CheckGroundStatus()
		{
			if (Physics.Raycast(base.transform.position + Vector3.up * 0.1f, Vector3.down, out var hitInfo, m_GroundCheckDistance))
			{
				m_GroundNormal = hitInfo.normal;
				m_IsGrounded = true;
				m_Animator.applyRootMotion = true;
			}
			else
			{
				m_IsGrounded = false;
				m_GroundNormal = Vector3.up;
				m_Animator.applyRootMotion = false;
			}
		}
	}
	[RequireComponent(typeof(ThirdPersonCharacter))]
	public class ThirdPersonUserControl : MonoBehaviour
	{
		private ThirdPersonCharacter m_Character;

		private Transform m_Cam;

		private Vector3 m_CamForward;

		private Vector3 m_Move;

		private bool m_Jump;

		private void Start()
		{
			if (Camera.main != null)
			{
				m_Cam = Camera.main.transform;
			}
			else
			{
				UnityEngine.Debug.LogWarning("Warning: no main camera found. Third person character needs a Camera tagged \"MainCamera\", for camera-relative controls.");
			}
			m_Character = GetComponent<ThirdPersonCharacter>();
		}

		private void Update()
		{
			if (!m_Jump)
			{
				m_Jump = CrossPlatformInputManager.GetButtonDown("Jump");
			}
		}

		private void FixedUpdate()
		{
			float axis = CrossPlatformInputManager.GetAxis("Horizontal");
			float axis2 = CrossPlatformInputManager.GetAxis("Vertical");
			bool key = Input.GetKey(KeyCode.C);
			if (m_Cam != null)
			{
				m_CamForward = Vector3.Scale(m_Cam.forward, new Vector3(1f, 0f, 1f)).normalized;
				m_Move = axis2 * m_CamForward + axis * m_Cam.right;
			}
			else
			{
				m_Move = axis2 * Vector3.forward + axis * Vector3.right;
			}
			m_Character.Move(m_Move, key, m_Jump);
			m_Jump = false;
		}
	}
}
namespace UnityStandardAssets.Characters.FirstPerson
{
	[RequireComponent(typeof(CharacterController))]
	[RequireComponent(typeof(AudioSource))]
	public class FirstPersonController : MonoBehaviour
	{
		[SerializeField]
		private bool m_IsWalking;

		[SerializeField]
		private float m_WalkSpeed;

		[SerializeField]
		private float m_RunSpeed;

		[SerializeField]
		[Range(0f, 1f)]
		private float m_RunstepLenghten;

		[SerializeField]
		private float m_JumpSpeed;

		[SerializeField]
		private float m_StickToGroundForce;

		[SerializeField]
		private float m_GravityMultiplier;

		[SerializeField]
		private MouseLook m_MouseLook;

		[SerializeField]
		private bool m_UseFovKick;

		[SerializeField]
		private FOVKick m_FovKick = new FOVKick();

		[SerializeField]
		private bool m_UseHeadBob;

		[SerializeField]
		private CurveControlledBob m_HeadBob = new CurveControlledBob();

		[SerializeField]
		private LerpControlledBob m_JumpBob = new LerpControlledBob();

		[SerializeField]
		private float m_StepInterval;

		[SerializeField]
		private AudioClip[] m_FootstepSounds;

		[SerializeField]
		private AudioClip m_JumpSound;

		[SerializeField]
		private AudioClip m_LandSound;

		private Camera m_Camera;

		private bool m_Jump;

		private float m_YRotation;

		private Vector2 m_Input;

		private Vector3 m_MoveDir = Vector3.zero;

		private CharacterController m_CharacterController;

		private CollisionFlags m_CollisionFlags;

		private bool m_PreviouslyGrounded;

		private Vector3 m_OriginalCameraPosition;

		private float m_StepCycle;

		private float m_NextStep;

		private bool m_Jumping;

		private AudioSource m_AudioSource;

		private void Start()
		{
			m_CharacterController = GetComponent<CharacterController>();
			m_Camera = Camera.main;
			m_OriginalCameraPosition = m_Camera.transform.localPosition;
			m_FovKick.Setup(m_Camera);
			m_HeadBob.Setup(m_Camera, m_StepInterval);
			m_StepCycle = 0f;
			m_NextStep = m_StepCycle / 2f;
			m_Jumping = false;
			m_AudioSource = GetComponent<AudioSource>();
			m_MouseLook.Init(base.transform, m_Camera.transform);
		}

		private void Update()
		{
			RotateView();
			if (!m_Jump)
			{
				m_Jump = CrossPlatformInputManager.GetButtonDown("Jump");
			}
			if (!m_PreviouslyGrounded && m_CharacterController.isGrounded)
			{
				StartCoroutine(m_JumpBob.DoBobCycle());
				PlayLandingSound();
				m_MoveDir.y = 0f;
				m_Jumping = false;
			}
			if (!m_CharacterController.isGrounded && !m_Jumping && m_PreviouslyGrounded)
			{
				m_MoveDir.y = 0f;
			}
			m_PreviouslyGrounded = m_CharacterController.isGrounded;
		}

		private void PlayLandingSound()
		{
			m_AudioSource.clip = m_LandSound;
			m_AudioSource.Play();
			m_NextStep = m_StepCycle + 0.5f;
		}

		private void FixedUpdate()
		{
			GetInput(out var speed);
			Vector3 vector = base.transform.forward * m_Input.y + base.transform.right * m_Input.x;
			Physics.SphereCast(base.transform.position, m_CharacterController.radius, Vector3.down, out var hitInfo, m_CharacterController.height / 2f);
			vector = Vector3.ProjectOnPlane(vector, hitInfo.normal).normalized;
			m_MoveDir.x = vector.x * speed;
			m_MoveDir.z = vector.z * speed;
			if (m_CharacterController.isGrounded)
			{
				m_MoveDir.y = 0f - m_StickToGroundForce;
				if (m_Jump)
				{
					m_MoveDir.y = m_JumpSpeed;
					PlayJumpSound();
					m_Jump = false;
					m_Jumping = true;
				}
			}
			else
			{
				m_MoveDir += Physics.gravity * m_GravityMultiplier * Time.fixedDeltaTime;
			}
			m_CollisionFlags = m_CharacterController.Move(m_MoveDir * Time.fixedDeltaTime);
			ProgressStepCycle(speed);
			UpdateCameraPosition(speed);
		}

		private void PlayJumpSound()
		{
			m_AudioSource.clip = m_JumpSound;
			m_AudioSource.Play();
		}

		private void ProgressStepCycle(float speed)
		{
			if (m_CharacterController.velocity.sqrMagnitude > 0f && (m_Input.x != 0f || m_Input.y != 0f))
			{
				m_StepCycle += (m_CharacterController.velocity.magnitude + speed * (m_IsWalking ? 1f : m_RunstepLenghten)) * Time.fixedDeltaTime;
			}
			if (m_StepCycle > m_NextStep)
			{
				m_NextStep = m_StepCycle + m_StepInterval;
				PlayFootStepAudio();
			}
		}

		private void PlayFootStepAudio()
		{
			if (m_CharacterController.isGrounded)
			{
				int num = UnityEngine.Random.Range(1, m_FootstepSounds.Length);
				m_AudioSource.clip = m_FootstepSounds[num];
				m_AudioSource.PlayOneShot(m_AudioSource.clip);
				m_FootstepSounds[num] = m_FootstepSounds[0];
				m_FootstepSounds[0] = m_AudioSource.clip;
			}
		}

		private void UpdateCameraPosition(float speed)
		{
			if (m_UseHeadBob)
			{
				Vector3 localPosition;
				if (m_CharacterController.velocity.magnitude > 0f && m_CharacterController.isGrounded)
				{
					m_Camera.transform.localPosition = m_HeadBob.DoHeadBob(m_CharacterController.velocity.magnitude + speed * (m_IsWalking ? 1f : m_RunstepLenghten));
					localPosition = m_Camera.transform.localPosition;
					localPosition.y = m_Camera.transform.localPosition.y - m_JumpBob.Offset();
				}
				else
				{
					localPosition = m_Camera.transform.localPosition;
					localPosition.y = m_OriginalCameraPosition.y - m_JumpBob.Offset();
				}
				m_Camera.transform.localPosition = localPosition;
			}
		}

		private void GetInput(out float speed)
		{
			float axis = CrossPlatformInputManager.GetAxis("Horizontal");
			float axis2 = CrossPlatformInputManager.GetAxis("Vertical");
			bool isWalking = m_IsWalking;
			speed = (m_IsWalking ? m_WalkSpeed : m_RunSpeed);
			m_Input = new Vector2(axis, axis2);
			if (m_Input.sqrMagnitude > 1f)
			{
				m_Input.Normalize();
			}
			if (m_IsWalking != isWalking && m_UseFovKick && m_CharacterController.velocity.sqrMagnitude > 0f)
			{
				StopAllCoroutines();
				StartCoroutine((!m_IsWalking) ? m_FovKick.FOVKickUp() : m_FovKick.FOVKickDown());
			}
		}

		private void RotateView()
		{
			m_MouseLook.LookRotation(base.transform, m_Camera.transform);
		}

		private void OnControllerColliderHit(ControllerColliderHit hit)
		{
			Rigidbody attachedRigidbody = hit.collider.attachedRigidbody;
			if (m_CollisionFlags != CollisionFlags.Below && !(attachedRigidbody == null) && !attachedRigidbody.isKinematic)
			{
				attachedRigidbody.AddForceAtPosition(m_CharacterController.velocity * 0.1f, hit.point, ForceMode.Impulse);
			}
		}
	}
	public class HeadBob : MonoBehaviour
	{
		public Camera Camera;

		public CurveControlledBob motionBob = new CurveControlledBob();

		public LerpControlledBob jumpAndLandingBob = new LerpControlledBob();

		public RigidbodyFirstPersonController rigidbodyFirstPersonController;

		public float StrideInterval;

		[Range(0f, 1f)]
		public float RunningStrideLengthen;

		private bool m_PreviouslyGrounded;

		private Vector3 m_OriginalCameraPosition;

		private void Start()
		{
			motionBob.Setup(Camera, StrideInterval);
			m_OriginalCameraPosition = Camera.transform.localPosition;
		}

		private void Update()
		{
			Vector3 localPosition;
			if (rigidbodyFirstPersonController.Velocity.magnitude > 0f && rigidbodyFirstPersonController.Grounded)
			{
				Camera.transform.localPosition = motionBob.DoHeadBob(rigidbodyFirstPersonController.Velocity.magnitude * (rigidbodyFirstPersonController.Running ? RunningStrideLengthen : 1f));
				localPosition = Camera.transform.localPosition;
				localPosition.y = Camera.transform.localPosition.y - jumpAndLandingBob.Offset();
			}
			else
			{
				localPosition = Camera.transform.localPosition;
				localPosition.y = m_OriginalCameraPosition.y - jumpAndLandingBob.Offset();
			}
			Camera.transform.localPosition = localPosition;
			if (!m_PreviouslyGrounded && rigidbodyFirstPersonController.Grounded)
			{
				StartCoroutine(jumpAndLandingBob.DoBobCycle());
			}
			m_PreviouslyGrounded = rigidbodyFirstPersonController.Grounded;
		}
	}
	[Serializable]
	public class MouseLook
	{
		public float XSensitivity = 2f;

		public float YSensitivity = 2f;

		public bool clampVerticalRotation = true;

		public float MinimumX = -90f;

		public float MaximumX = 90f;

		public bool smooth;

		public float smoothTime = 5f;

		private Quaternion m_CharacterTargetRot;

		private Quaternion m_CameraTargetRot;

		public void Init(Transform character, Transform camera)
		{
			m_CharacterTargetRot = character.localRotation;
			m_CameraTargetRot = camera.localRotation;
		}

		public void LookRotation(Transform character, Transform camera)
		{
			float y = CrossPlatformInputManager.GetAxis("Mouse X") * XSensitivity;
			float num = CrossPlatformInputManager.GetAxis("Mouse Y") * YSensitivity;
			m_CharacterTargetRot *= Quaternion.Euler(0f, y, 0f);
			m_CameraTargetRot *= Quaternion.Euler(0f - num, 0f, 0f);
			if (clampVerticalRotation)
			{
				m_CameraTargetRot = ClampRotationAroundXAxis(m_CameraTargetRot);
			}
			if (smooth)
			{
				character.localRotation = Quaternion.Slerp(character.localRotation, m_CharacterTargetRot, smoothTime * Time.deltaTime);
				camera.localRotation = Quaternion.Slerp(camera.localRotation, m_CameraTargetRot, smoothTime * Time.deltaTime);
			}
			else
			{
				character.localRotation = m_CharacterTargetRot;
				camera.localRotation = m_CameraTargetRot;
			}
		}

		private Quaternion ClampRotationAroundXAxis(Quaternion q)
		{
			q.x /= q.w;
			q.y /= q.w;
			q.z /= q.w;
			q.w = 1f;
			float value = 114.59156f * Mathf.Atan(q.x);
			value = Mathf.Clamp(value, MinimumX, MaximumX);
			q.x = Mathf.Tan((float)Math.PI / 360f * value);
			return q;
		}
	}
	[RequireComponent(typeof(Rigidbody))]
	[RequireComponent(typeof(CapsuleCollider))]
	public class RigidbodyFirstPersonController : MonoBehaviour
	{
		[Serializable]
		public class MovementSettings
		{
			public float ForwardSpeed = 8f;

			public float BackwardSpeed = 4f;

			public float StrafeSpeed = 4f;

			public float RunMultiplier = 2f;

			public KeyCode RunKey = KeyCode.LeftShift;

			public float JumpForce = 30f;

			public AnimationCurve SlopeCurveModifier = new AnimationCurve(new Keyframe(-90f, 1f), new Keyframe(0f, 1f), new Keyframe(90f, 0f));

			[HideInInspector]
			public float CurrentTargetSpeed = 8f;

			public void UpdateDesiredTargetSpeed(Vector2 input)
			{
				if (!(input == Vector2.zero))
				{
					if (input.x > 0f || input.x < 0f)
					{
						CurrentTargetSpeed = StrafeSpeed;
					}
					if (input.y < 0f)
					{
						CurrentTargetSpeed = BackwardSpeed;
					}
					if (input.y > 0f)
					{
						CurrentTargetSpeed = ForwardSpeed;
					}
				}
			}
		}

		[Serializable]
		public class AdvancedSettings
		{
			public float groundCheckDistance = 0.01f;

			public float stickToGroundHelperDistance = 0.5f;

			public float slowDownRate = 20f;

			public bool airControl;
		}

		public Camera cam;

		public MovementSettings movementSettings = new MovementSettings();

		public MouseLook mouseLook = new MouseLook();

		public AdvancedSettings advancedSettings = new AdvancedSettings();

		private Rigidbody m_RigidBody;

		private CapsuleCollider m_Capsule;

		private float m_YRotation;

		private Vector3 m_GroundContactNormal;

		private bool m_Jump;

		private bool m_PreviouslyGrounded;

		private bool m_Jumping;

		private bool m_IsGrounded;

		public Vector3 Velocity => m_RigidBody.velocity;

		public bool Grounded => m_IsGrounded;

		public bool Jumping => m_Jumping;

		public bool Running => false;

		private void Start()
		{
			m_RigidBody = GetComponent<Rigidbody>();
			m_Capsule = GetComponent<CapsuleCollider>();
			mouseLook.Init(base.transform, cam.transform);
		}

		private void Update()
		{
			RotateView();
			if (CrossPlatformInputManager.GetButtonDown("Jump") && !m_Jump)
			{
				m_Jump = true;
			}
		}

		private void FixedUpdate()
		{
			GroundCheck();
			Vector2 input = GetInput();
			if ((Mathf.Abs(input.x) > float.Epsilon || Mathf.Abs(input.y) > float.Epsilon) && (advancedSettings.airControl || m_IsGrounded))
			{
				Vector3 vector = cam.transform.forward * input.y + cam.transform.right * input.x;
				vector = Vector3.ProjectOnPlane(vector, m_GroundContactNormal).normalized;
				vector.x *= movementSettings.CurrentTargetSpeed;
				vector.z *= movementSettings.CurrentTargetSpeed;
				vector.y *= movementSettings.CurrentTargetSpeed;
				if (m_RigidBody.velocity.sqrMagnitude < movementSettings.CurrentTargetSpeed * movementSettings.CurrentTargetSpeed)
				{
					m_RigidBody.AddForce(vector * SlopeMultiplier(), ForceMode.Impulse);
				}
			}
			if (m_IsGrounded)
			{
				m_RigidBody.drag = 5f;
				if (m_Jump)
				{
					m_RigidBody.drag = 0f;
					m_RigidBody.velocity = new Vector3(m_RigidBody.velocity.x, 0f, m_RigidBody.velocity.z);
					m_RigidBody.AddForce(new Vector3(0f, movementSettings.JumpForce, 0f), ForceMode.Impulse);
					m_Jumping = true;
				}
				if (!m_Jumping && Mathf.Abs(input.x) < float.Epsilon && Mathf.Abs(input.y) < float.Epsilon && m_RigidBody.velocity.magnitude < 1f)
				{
					m_RigidBody.Sleep();
				}
			}
			else
			{
				m_RigidBody.drag = 0f;
				if (m_PreviouslyGrounded && !m_Jumping)
				{
					StickToGroundHelper();
				}
			}
			m_Jump = false;
		}

		private float SlopeMultiplier()
		{
			float time = Vector3.Angle(m_GroundContactNormal, Vector3.up);
			return movementSettings.SlopeCurveModifier.Evaluate(time);
		}

		private void StickToGroundHelper()
		{
			if (Physics.SphereCast(base.transform.position, m_Capsule.radius, Vector3.down, out var hitInfo, m_Capsule.height / 2f - m_Capsule.radius + advancedSettings.stickToGroundHelperDistance) && Mathf.Abs(Vector3.Angle(hitInfo.normal, Vector3.up)) < 85f)
			{
				m_RigidBody.velocity = Vector3.ProjectOnPlane(m_RigidBody.velocity, hitInfo.normal);
			}
		}

		private Vector2 GetInput()
		{
			Vector2 vector = default(Vector2);
			vector.x = CrossPlatformInputManager.GetAxis("Horizontal");
			vector.y = CrossPlatformInputManager.GetAxis("Vertical");
			Vector2 vector2 = vector;
			movementSettings.UpdateDesiredTargetSpeed(vector2);
			return vector2;
		}

		private void RotateView()
		{
			if (!(Mathf.Abs(Time.timeScale) < float.Epsilon))
			{
				float y = base.transform.eulerAngles.y;
				mouseLook.LookRotation(base.transform, cam.transform);
				if (m_IsGrounded || advancedSettings.airControl)
				{
					Quaternion quaternion = Quaternion.AngleAxis(base.transform.eulerAngles.y - y, Vector3.up);
					m_RigidBody.velocity = quaternion * m_RigidBody.velocity;
				}
			}
		}

		private void GroundCheck()
		{
			m_PreviouslyGrounded = m_IsGrounded;
			if (Physics.SphereCast(base.transform.position, m_Capsule.radius, Vector3.down, out var hitInfo, m_Capsule.height / 2f - m_Capsule.radius + advancedSettings.groundCheckDistance))
			{
				m_IsGrounded = true;
				m_GroundContactNormal = hitInfo.normal;
			}
			else
			{
				m_IsGrounded = false;
				m_GroundContactNormal = Vector3.up;
			}
			if (!m_PreviouslyGrounded && m_IsGrounded && m_Jumping)
			{
				m_Jumping = false;
			}
		}
	}
}
namespace PlayStationVRExample
{
	public class VRPostReprojection : MonoBehaviour
	{
	}
}
namespace JBrothers.PreIntegratedSkinShader2
{
	public class PreIntegratedSkinProfile : ScriptableObject
	{
		public Vector4 gauss6_1;

		public Vector4 gauss6_2;

		public Vector4 gauss6_3;

		public Vector4 gauss6_4;

		public Vector4 gauss6_5;

		public Vector4 gauss6_6;

		[HideInInspector]
		[SerializeField]
		private Vector4 _PSSProfileHigh_weighths1_var1;

		[HideInInspector]
		[SerializeField]
		private Vector4 _PSSProfileHigh_weighths2_var2;

		[HideInInspector]
		[SerializeField]
		private Vector4 _PSSProfileHigh_weighths3_var3;

		[HideInInspector]
		[SerializeField]
		private Vector4 _PSSProfileHigh_weighths4_var4;

		[HideInInspector]
		[SerializeField]
		private Vector4 _PSSProfileHigh_weighths5_var5;

		[HideInInspector]
		[SerializeField]
		private Vector4 _PSSProfileHigh_weighths6_var6;

		[HideInInspector]
		[SerializeField]
		private Vector4 _PSSProfileHigh_sqrtvar1234;

		[HideInInspector]
		[SerializeField]
		private Vector4 _PSSProfileHigh_transl123_sqrtvar5;

		[HideInInspector]
		[SerializeField]
		private Vector4 _PSSProfileHigh_transl456_sqrtvar6;

		[HideInInspector]
		[SerializeField]
		private Vector4 _PSSProfileMedium_weighths1_var1;

		[HideInInspector]
		[SerializeField]
		private Vector4 _PSSProfileMedium_weighths2_var2;

		[HideInInspector]
		[SerializeField]
		private Vector4 _PSSProfileMedium_weighths3_var3;

		[HideInInspector]
		[SerializeField]
		private Vector4 _PSSProfileMedium_transl123;

		[HideInInspector]
		[SerializeField]
		private Vector4 _PSSProfileMedium_sqrtvar123;

		[HideInInspector]
		[SerializeField]
		private Vector4 _PSSProfileLow_weighths1_var1;

		[HideInInspector]
		[SerializeField]
		private Vector4 _PSSProfileLow_weighths2_var2;

		[HideInInspector]
		[SerializeField]
		private Vector4 _PSSProfileLow_sqrtvar12;

		[HideInInspector]
		[SerializeField]
		private Vector4 _PSSProfileLow_transl;

		[HideInInspector]
		public bool needsRenormalize = true;

		[HideInInspector]
		public bool needsRecalcDerived = true;

		[HideInInspector]
		public Texture2D referenceTexture;

		public void NormalizeOriginalWeights()
		{
			RecalculateDerived();
			gauss6_1.x = _PSSProfileHigh_weighths1_var1.x;
			gauss6_1.y = _PSSProfileHigh_weighths1_var1.y;
			gauss6_1.z = _PSSProfileHigh_weighths1_var1.z;
			gauss6_2.x = _PSSProfileHigh_weighths2_var2.x;
			gauss6_2.y = _PSSProfileHigh_weighths2_var2.y;
			gauss6_2.z = _PSSProfileHigh_weighths2_var2.z;
			gauss6_3.x = _PSSProfileHigh_weighths3_var3.x;
			gauss6_3.y = _PSSProfileHigh_weighths3_var3.y;
			gauss6_3.z = _PSSProfileHigh_weighths3_var3.z;
			gauss6_4.x = _PSSProfileHigh_weighths4_var4.x;
			gauss6_4.y = _PSSProfileHigh_weighths4_var4.y;
			gauss6_4.z = _PSSProfileHigh_weighths4_var4.z;
			gauss6_5.x = _PSSProfileHigh_weighths5_var5.x;
			gauss6_5.y = _PSSProfileHigh_weighths5_var5.y;
			gauss6_5.z = _PSSProfileHigh_weighths5_var5.z;
			gauss6_6.x = _PSSProfileHigh_weighths6_var6.x;
			gauss6_6.y = _PSSProfileHigh_weighths6_var6.y;
			gauss6_6.z = _PSSProfileHigh_weighths6_var6.z;
			needsRenormalize = false;
		}

		public void RecalculateDerived()
		{
			Vector3 zero = Vector3.zero;
			Vector3 vector = gauss6_1;
			Vector3 vector2 = gauss6_2;
			Vector3 vector3 = gauss6_3;
			Vector3 vector4 = gauss6_4;
			Vector3 vector5 = gauss6_5;
			Vector3 vector6 = gauss6_6;
			zero += vector;
			zero += vector2;
			zero += vector3;
			zero += vector4;
			zero += vector5;
			zero += vector6;
			vector.x /= zero.x;
			vector.y /= zero.y;
			vector.z /= zero.z;
			vector2.x /= zero.x;
			vector2.y /= zero.y;
			vector2.z /= zero.z;
			vector3.x /= zero.x;
			vector3.y /= zero.y;
			vector3.z /= zero.z;
			vector4.x /= zero.x;
			vector4.y /= zero.y;
			vector4.z /= zero.z;
			vector5.x /= zero.x;
			vector5.y /= zero.y;
			vector5.z /= zero.z;
			vector6.x /= zero.x;
			vector6.y /= zero.y;
			vector6.z /= zero.z;
			float grayscale = new UnityEngine.Color(vector.x, vector.y, vector.z).grayscale;
			float grayscale2 = new UnityEngine.Color(vector2.x, vector2.y, vector2.z).grayscale;
			float grayscale3 = new UnityEngine.Color(vector3.x, vector3.y, vector3.z).grayscale;
			float grayscale4 = new UnityEngine.Color(vector4.x, vector4.y, vector4.z).grayscale;
			float grayscale5 = new UnityEngine.Color(vector5.x, vector5.y, vector5.z).grayscale;
			float grayscale6 = new UnityEngine.Color(vector6.x, vector6.y, vector6.z).grayscale;
			_PSSProfileHigh_weighths1_var1 = new Vector4(vector.x, vector.y, vector.z, gauss6_1.w);
			_PSSProfileHigh_weighths2_var2 = new Vector4(vector2.x, vector2.y, vector2.z, gauss6_2.w);
			_PSSProfileHigh_weighths3_var3 = new Vector4(vector3.x, vector3.y, vector3.z, gauss6_3.w);
			_PSSProfileHigh_weighths4_var4 = new Vector4(vector4.x, vector4.y, vector4.z, gauss6_4.w);
			_PSSProfileHigh_weighths5_var5 = new Vector4(vector5.x, vector5.y, vector5.z, gauss6_5.w);
			_PSSProfileHigh_weighths6_var6 = new Vector4(vector6.x, vector6.y, vector6.z, gauss6_6.w);
			_PSSProfileMedium_weighths1_var1 = new Vector4(vector.x + vector2.x, vector.y + vector2.y, vector.z + vector2.z, (gauss6_1.w * grayscale + gauss6_2.w * grayscale2) / (grayscale + grayscale2));
			_PSSProfileMedium_weighths2_var2 = new Vector4(vector3.x + vector4.x, vector3.y + vector4.y, vector3.z + vector4.z, (gauss6_3.w * grayscale3 + gauss6_4.w * grayscale4) / (grayscale3 + grayscale4));
			_PSSProfileMedium_weighths3_var3 = new Vector4(vector5.x + vector6.x, vector5.y + vector6.y, vector5.z + vector6.z, (gauss6_5.w * grayscale5 + gauss6_6.w * grayscale6) / (grayscale5 + grayscale6));
			_PSSProfileLow_weighths1_var1 = new Vector4(vector.x + vector2.x + vector3.x, vector.y + vector2.y + vector3.y, vector.z + vector2.z + vector3.z, (gauss6_1.w * grayscale + gauss6_2.w * grayscale2 + gauss6_3.w * grayscale3) / (grayscale + grayscale2 + grayscale3));
			_PSSProfileLow_weighths2_var2 = new Vector4(vector4.x + vector5.x + vector6.x, vector4.y + vector5.y + vector6.y, vector4.z + vector5.z + vector6.z, (gauss6_4.w * grayscale4 + gauss6_5.w * grayscale5 + gauss6_6.w * grayscale6) / (grayscale4 + grayscale5 + grayscale6));
			_PSSProfileHigh_sqrtvar1234.x = Mathf.Sqrt(_PSSProfileHigh_weighths1_var1.w);
			_PSSProfileHigh_sqrtvar1234.y = Mathf.Sqrt(_PSSProfileHigh_weighths2_var2.w);
			_PSSProfileHigh_sqrtvar1234.z = Mathf.Sqrt(_PSSProfileHigh_weighths3_var3.w);
			_PSSProfileHigh_sqrtvar1234.w = Mathf.Sqrt(_PSSProfileHigh_weighths4_var4.w);
			_PSSProfileMedium_sqrtvar123.x = Mathf.Sqrt(_PSSProfileMedium_weighths1_var1.w);
			_PSSProfileMedium_sqrtvar123.y = Mathf.Sqrt(_PSSProfileMedium_weighths2_var2.w);
			_PSSProfileMedium_sqrtvar123.z = Mathf.Sqrt(_PSSProfileMedium_weighths3_var3.w);
			_PSSProfileLow_sqrtvar12.x = Mathf.Sqrt(_PSSProfileLow_weighths1_var1.w);
			_PSSProfileLow_sqrtvar12.y = Mathf.Sqrt(_PSSProfileLow_weighths2_var2.w);
			_PSSProfileHigh_transl123_sqrtvar5.w = Mathf.Sqrt(_PSSProfileHigh_weighths5_var5.w);
			_PSSProfileHigh_transl456_sqrtvar6.w = Mathf.Sqrt(_PSSProfileHigh_weighths6_var6.w);
			float num = -1.442695f;
			_PSSProfileHigh_transl123_sqrtvar5.x = num / gauss6_1.w;
			_PSSProfileHigh_transl123_sqrtvar5.y = num / gauss6_2.w;
			_PSSProfileHigh_transl123_sqrtvar5.z = num / gauss6_3.w;
			_PSSProfileHigh_transl456_sqrtvar6.x = num / gauss6_4.w;
			_PSSProfileHigh_transl456_sqrtvar6.y = num / gauss6_5.w;
			_PSSProfileHigh_transl456_sqrtvar6.z = num / gauss6_6.w;
			_PSSProfileMedium_transl123.x = num / _PSSProfileMedium_weighths1_var1.w;
			_PSSProfileMedium_transl123.y = num / _PSSProfileMedium_weighths2_var2.w;
			_PSSProfileMedium_transl123.z = num / _PSSProfileMedium_weighths3_var3.w;
			Vector3 vector7 = default(Vector3);
			vector7.x = gauss6_1.w * vector.x + gauss6_2.w * vector2.x + gauss6_3.w * vector3.x + gauss6_4.w * vector4.x + gauss6_5.w * vector5.x + gauss6_6.w * vector6.x;
			vector7.y = gauss6_1.w * vector.y + gauss6_2.w * vector2.y + gauss6_3.w * vector3.y + gauss6_4.w * vector4.y + gauss6_5.w * vector5.y + gauss6_6.w * vector6.y;
			vector7.z = gauss6_1.w * vector.z + gauss6_2.w * vector2.z + gauss6_3.w * vector3.z + gauss6_4.w * vector4.z + gauss6_5.w * vector5.z + gauss6_6.w * vector6.z;
			_PSSProfileLow_transl.x = num / vector7.x;
			_PSSProfileLow_transl.y = num / vector7.y;
			_PSSProfileLow_transl.z = num / vector7.z;
			needsRecalcDerived = false;
		}

		public void ApplyProfile(Material material)
		{
			ApplyProfile(material, noWarn: false);
		}

		public void ApplyProfile(Material material, bool noWarn)
		{
			if (needsRecalcDerived)
			{
				RecalculateDerived();
			}
			material.SetVector("_PSSProfileHigh_weighths1_var1", _PSSProfileHigh_weighths1_var1);
			material.SetVector("_PSSProfileHigh_weighths2_var2", _PSSProfileHigh_weighths2_var2);
			material.SetVector("_PSSProfileHigh_weighths3_var3", _PSSProfileHigh_weighths3_var3);
			material.SetVector("_PSSProfileHigh_weighths4_var4", _PSSProfileHigh_weighths4_var4);
			material.SetVector("_PSSProfileHigh_weighths5_var5", _PSSProfileHigh_weighths5_var5);
			material.SetVector("_PSSProfileHigh_weighths6_var6", _PSSProfileHigh_weighths6_var6);
			material.SetVector("_PSSProfileHigh_sqrtvar1234", _PSSProfileHigh_sqrtvar1234);
			material.SetVector("_PSSProfileHigh_transl123_sqrtvar5", _PSSProfileHigh_transl123_sqrtvar5);
			material.SetVector("_PSSProfileHigh_transl456_sqrtvar6", _PSSProfileHigh_transl456_sqrtvar6);
			material.SetVector("_PSSProfileMedium_weighths1_var1", _PSSProfileMedium_weighths1_var1);
			material.SetVector("_PSSProfileMedium_weighths2_var2", _PSSProfileMedium_weighths2_var2);
			material.SetVector("_PSSProfileMedium_weighths3_var3", _PSSProfileMedium_weighths3_var3);
			material.SetVector("_PSSProfileMedium_transl123", _PSSProfileMedium_transl123);
			material.SetVector("_PSSProfileMedium_sqrtvar123", _PSSProfileMedium_sqrtvar123);
			material.SetVector("_PSSProfileLow_weighths1_var1", _PSSProfileLow_weighths1_var1);
			material.SetVector("_PSSProfileLow_weighths2_var2", _PSSProfileLow_weighths2_var2);
			material.SetVector("_PSSProfileLow_sqrtvar12", _PSSProfileLow_sqrtvar12);
			material.SetVector("_PSSProfileLow_transl", _PSSProfileLow_transl);
		}
	}
}
namespace BoundarySystem_Ext
{
	internal static class Pvr_BoundaryAPI
	{
		private const string LibFileName = "Pvr_UnitySDK";

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_StartSDKBoundary();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_ShutdownSDKBoundary();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetMainSensorStateExt(ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz, ref float vfov, ref float hfov, ref int viewNumber);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr Pvr_GetCameraData_Ext();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_ResetVrModebyForce();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_ResumeBoundaryForSTS();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_PauseBoundaryForSTS();

		public static int UPvr_GetMainSensorStateExt(ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz, ref float vfov, ref float hfov, ref int viewNumber)
		{
			return Pvr_GetMainSensorStateExt(ref x, ref y, ref z, ref w, ref px, ref py, ref pz, ref vfov, ref hfov, ref viewNumber);
		}

		public static IntPtr UPvr_GetCameraData_Ext()
		{
			_ = IntPtr.Zero;
			return Pvr_GetCameraData_Ext();
		}

		public static bool UPvr_ResumeBoundaryForSTS()
		{
			return Pvr_ResumeBoundaryForSTS();
		}

		public static void UPvr_PauseBoundaryForSTS()
		{
			Pvr_PauseBoundaryForSTS();
		}

		public static IntPtr StructToIntPtr<T>(T info)
		{
			IntPtr intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(info));
			Marshal.StructureToPtr(info, intPtr, fDeleteOld: true);
			return intPtr;
		}

		public static T IntPtrToStruct<T>(IntPtr info)
		{
			return (T)Marshal.PtrToStructure(info, typeof(T));
		}
	}
	internal static class Pvr_SafeAreaAlgoAPI
	{
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		public delegate void SafeAreaCallback(IntPtr lineCollectionPtr, IntPtr safeAreaRectPtr);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		public delegate void SafeAreaCallbackShrink(IntPtr lineCollectionPtr, IntPtr safeAreaDetailRectPtr);

		public struct GSAPoint3i
		{
			public int x;

			public int y;

			public int z;
		}

		public struct GSALine
		{
			public IntPtr pointArray;

			public int pointCount;
		}

		public struct GSALineCollection
		{
			public IntPtr lineArray;

			public int lineCount;
		}

		public struct GSALegalData
		{
			public int overMaxRange;

			public int includeBigGrap;

			public int bigGapNum;

			public int centerOut;

			public int removeNarrow;

			public int overMaxRange_more;

			public int validShrinkArea;
		}

		public struct GSARect
		{
			public GSAPoint3i leftup;

			public GSAPoint3i leftdown;

			public GSAPoint3i rightup;

			public GSAPoint3i rightdown;

			public GSAPoint3i center;

			public uint width;

			public uint height;

			public int isLegal;

			public GSALegalData legalData;
		}

		private const string LibFileName = "SafetyArea";

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSAInit(int width, int height);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSAShutDown();

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSASetCallback(SafeAreaCallback cb);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSASetCallbackShrink(SafeAreaCallbackShrink cb);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSAUpDateData(IntPtr lineCollectionPtr);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSASetConfigFilePath(IntPtr configPath);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool GSAGetClosedAreaUpdateFlag();

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSALoadSafetyArea(IntPtr lineCollectionPtr);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern double GSABoundaryDetector(ref GSAPoint3i pointPtr);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSALoadSafetyArea2(IntPtr lineCollectionPtr, bool isPlayArea);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern double GSABoundaryDetector2(ref GSAPoint3i point, bool isPlayArea, ref GSAPoint3i closestPoint, ref GSAPoint3i normalDir);

		public static int Pvr_GSAInit(int width, int height)
		{
			return GSAInit(width, height);
		}

		public static int Pvr_GSASetCallback(SafeAreaCallback cb)
		{
			return GSASetCallback(cb);
		}

		public static int Pvr_GSASetCallbackShrink(SafeAreaCallbackShrink cb)
		{
			return GSASetCallbackShrink(cb);
		}

		public static int Pvr_GSAUpDateData(IntPtr lineCollectionPtr)
		{
			return GSAUpDateData(lineCollectionPtr);
		}

		public static bool Pvr_GSAGetClosedAreaUpdateFlag()
		{
			return GSAGetClosedAreaUpdateFlag();
		}

		public static int Pvr_GSASetConfigFilePath(string configPath)
		{
			int num = -1;
			IntPtr intPtr = Marshal.StringToHGlobalAnsi(configPath);
			num = GSASetConfigFilePath(intPtr);
			Marshal.FreeHGlobal(intPtr);
			return num;
		}

		public static int Pvr_GSALoadSafetyArea(IntPtr lineCollectionPtr)
		{
			return GSALoadSafetyArea(lineCollectionPtr);
		}

		public static double Pvr_GSABoundaryDetector(ref GSAPoint3i point)
		{
			return GSABoundaryDetector(ref point);
		}

		public static int Pvr_GSAShutDown()
		{
			return GSAShutDown();
		}

		public static int Pvr_GSALoadSafetyArea2(IntPtr lineCollectionPtr, bool isPlayArea)
		{
			return GSALoadSafetyArea2(lineCollectionPtr, isPlayArea);
		}

		public static double Pvr_GSABoundaryDetector2(ref GSAPoint3i point, bool isPlayArea, ref GSAPoint3i closestPoint, ref GSAPoint3i normalDir)
		{
			return GSABoundaryDetector2(ref point, isPlayArea, ref closestPoint, ref normalDir);
		}
	}
	public class Pvr_BoundarySystem
	{
		private static Pvr_BoundarySystem instance;

		public const int CameraImageWidth = 1280;

		public const int CameraImageHeight = 400;

		public IntPtr CameraFramePtr = IntPtr.Zero;

		public static Pvr_BoundarySystem Instance
		{
			get
			{
				if (instance == null)
				{
					instance = new Pvr_BoundarySystem();
				}
				return instance;
			}
		}

		public void OpenBoundary()
		{
			Pvr_BoundaryAPI.Pvr_StartSDKBoundary();
		}

		public void CloseBoundary()
		{
			Pvr_BoundaryAPI.Pvr_ShutdownSDKBoundary();
		}

		public void Reset6Dof()
		{
			Pvr_BoundaryAPI.Pvr_ResetVrModebyForce();
		}

		public float[] GetControllerFixedPoseData(int hand)
		{
			float[] result = new float[7] { 0f, 0f, 0f, 1f, 0f, 0f, 0f };
			if (Pvr_ControllerManager.controllerlink != null)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, Pvr_ControllerManager.controllerlink.javaCVClass, "getControllerFixedSensorState", hand);
			}
			result[2] = 0f - result[2];
			result[3] = 0f - result[3];
			return result;
		}
	}
	public class Pvr_SafeAreaAlgoModule
	{
		public struct ExtraInfo
		{
			public bool overMaxRange;

			public bool includeBigGap;

			public int bigGapNum;

			public bool centerOut;

			public bool removeNarrow;

			public bool overMaxRange_more;

			public int validShrinkArea;
		}

		public struct BoundaryPlayerArea
		{
			public Vector3 lowerleft;

			public Vector3 upperleft;

			public Vector3 upperRight;

			public Vector3 lowerRight;

			public Vector3 center;

			public uint width;

			public uint height;

			public bool isLegal;

			public ExtraInfo extraInfo;
		}

		public delegate void BoundarySystemCallback(BoundaryPlayerArea playAreaInfo, List<Vector3> boundaryPoints, List<List<Vector3>> unusedLines);

		public delegate void BoundarySystemCallbackShrink(List<Vector3> rectPoints, List<Vector3> boundaryPoints, List<List<Vector3>> unusedLines);

		private static Pvr_SafeAreaAlgoModule instance;

		private BoundarySystemCallback boundarySystemCallback;

		private BoundarySystemCallbackShrink boundarySystemCallbackShrink;

		public static Pvr_SafeAreaAlgoModule Instance
		{
			get
			{
				if (instance == null)
				{
					instance = new Pvr_SafeAreaAlgoModule();
				}
				return instance;
			}
		}

		public void RegisterCallBack(BoundarySystemCallback callback)
		{
			boundarySystemCallback = callback;
		}

		public void RegisterCallBackShrink(BoundarySystemCallbackShrink callback)
		{
			boundarySystemCallbackShrink = callback;
		}

		public bool Start()
		{
			int num = Pvr_SafeAreaAlgoAPI.Pvr_GSASetCallback(_SafeAreaCallback);
			int num2 = Pvr_SafeAreaAlgoAPI.Pvr_GSASetCallbackShrink(_SafeAreaCallbackShrink);
			if (num != 0 || num2 != 0)
			{
				UnityEngine.Debug.LogError("BoundarySystem register callback failed!");
				return false;
			}
			if (Pvr_SafeAreaAlgoAPI.Pvr_GSAInit(300, 300) != 0)
			{
				UnityEngine.Debug.LogError("BoundarySystem init failed!");
				return false;
			}
			return true;
		}

		public bool CommitNewLineData(bool isFistLine, Vector3[] points)
		{
			Pvr_SafeAreaAlgoAPI.GSALineCollection info = default(Pvr_SafeAreaAlgoAPI.GSALineCollection);
			info.lineCount = 2;
			Pvr_SafeAreaAlgoAPI.GSALine[] array = new Pvr_SafeAreaAlgoAPI.GSALine[2];
			if (isFistLine)
			{
				array[0].pointArray = IntPtr.Zero;
				array[0].pointCount = 0;
			}
			else
			{
				Pvr_SafeAreaAlgoAPI.GSAPoint3i[] arr = new Pvr_SafeAreaAlgoAPI.GSAPoint3i[1]
				{
					new Pvr_SafeAreaAlgoAPI.GSAPoint3i
					{
						x = 0,
						y = 0,
						z = 0
					}
				};
				array[0].pointArray = Marshal.UnsafeAddrOfPinnedArrayElement(arr, 0);
				array[0].pointCount = 1;
			}
			Pvr_SafeAreaAlgoAPI.GSAPoint3i[] array2 = new Pvr_SafeAreaAlgoAPI.GSAPoint3i[points.Length];
			for (int i = 0; i < points.Length; i++)
			{
				Pvr_SafeAreaAlgoAPI.GSAPoint3i gSAPoint3i = default(Pvr_SafeAreaAlgoAPI.GSAPoint3i);
				gSAPoint3i.x = (int)(points[i].x * 1000f);
				gSAPoint3i.y = (int)(points[i].y * 1000f);
				gSAPoint3i.z = (int)(points[i].z * 1000f);
				array2[i] = gSAPoint3i;
			}
			array[1].pointArray = Marshal.UnsafeAddrOfPinnedArrayElement(array2, 0);
			array[1].pointCount = array2.Length;
			info.lineArray = Marshal.UnsafeAddrOfPinnedArrayElement(array, 0);
			IntPtr intPtr = Pvr_BoundaryAPI.StructToIntPtr(info);
			int num = Pvr_SafeAreaAlgoAPI.Pvr_GSAUpDateData(intPtr);
			Marshal.FreeHGlobal(intPtr);
			if (num != 0)
			{
				UnityEngine.Debug.LogError("BoundarySystem commit new line data failed!");
				return false;
			}
			return true;
		}

		public bool Shutdown()
		{
			if (Pvr_SafeAreaAlgoAPI.Pvr_GSAShutDown() != 0)
			{
				UnityEngine.Debug.LogError("BoundarySystem shutdown failed!");
				return false;
			}
			return true;
		}

		public double QueryDistanceOfPoint(Vector3 point)
		{
			Pvr_SafeAreaAlgoAPI.GSAPoint3i point2 = default(Pvr_SafeAreaAlgoAPI.GSAPoint3i);
			point2.x = (int)(point.x * 1000f);
			point2.y = (int)(point.y * 1000f);
			point2.z = (int)(point.z * 1000f);
			return Pvr_SafeAreaAlgoAPI.Pvr_GSABoundaryDetector(ref point2) / 1000.0;
		}

		public double QueryDistanceOfPoint(Vector3 point, bool isPlayArea, ref Vector3 closestPoint, ref Vector3 normalDir)
		{
			Pvr_SafeAreaAlgoAPI.GSAPoint3i point2 = default(Pvr_SafeAreaAlgoAPI.GSAPoint3i);
			point2.x = (int)(point.x * 1000f);
			point2.y = (int)(point.y * 1000f);
			point2.z = (int)(point.z * 1000f);
			Pvr_SafeAreaAlgoAPI.GSAPoint3i closestPoint2 = default(Pvr_SafeAreaAlgoAPI.GSAPoint3i);
			Pvr_SafeAreaAlgoAPI.GSAPoint3i normalDir2 = default(Pvr_SafeAreaAlgoAPI.GSAPoint3i);
			double num = Pvr_SafeAreaAlgoAPI.Pvr_GSABoundaryDetector2(ref point2, isPlayArea, ref closestPoint2, ref normalDir2);
			closestPoint.x = (float)closestPoint2.x / 1000f;
			closestPoint.y = (float)closestPoint2.y / 1000f;
			closestPoint.z = (float)closestPoint2.z / 1000f;
			normalDir.x = (float)normalDir2.x / 1000f;
			normalDir.y = (float)normalDir2.y / 1000f;
			normalDir.z = (float)normalDir2.z / 1000f;
			return num / 1000.0;
		}

		[MonoPInvokeCallback(typeof(Pvr_SafeAreaAlgoAPI.SafeAreaCallback))]
		private static void _SafeAreaCallback(IntPtr lineCollectionPtr, IntPtr safeAreaRectPtr)
		{
			if (lineCollectionPtr == IntPtr.Zero || safeAreaRectPtr == IntPtr.Zero)
			{
				UnityEngine.Debug.LogError("BoundarySystem callback is inValid!");
			}
			else
			{
				if (instance.boundarySystemCallback == null)
				{
					return;
				}
				List<Vector3> boundaryPoints = new List<Vector3>();
				List<List<Vector3>> list = new List<List<Vector3>>();
				int num = Marshal.SizeOf(typeof(Pvr_SafeAreaAlgoAPI.GSALine));
				int num2 = Marshal.SizeOf(typeof(Pvr_SafeAreaAlgoAPI.GSAPoint3i));
				Pvr_SafeAreaAlgoAPI.GSALineCollection gSALineCollection = Pvr_BoundaryAPI.IntPtrToStruct<Pvr_SafeAreaAlgoAPI.GSALineCollection>(lineCollectionPtr);
				for (int i = 0; i < gSALineCollection.lineCount; i++)
				{
					Pvr_SafeAreaAlgoAPI.GSALine gSALine = (Pvr_SafeAreaAlgoAPI.GSALine)Marshal.PtrToStructure(new IntPtr(gSALineCollection.lineArray.ToInt64() + num * i), typeof(Pvr_SafeAreaAlgoAPI.GSALine));
					List<Vector3> list2 = new List<Vector3>();
					for (int j = 0; j < gSALine.pointCount; j++)
					{
						Pvr_SafeAreaAlgoAPI.GSAPoint3i gSAPoint3i = (Pvr_SafeAreaAlgoAPI.GSAPoint3i)Marshal.PtrToStructure(new IntPtr(gSALine.pointArray.ToInt64() + num2 * j), typeof(Pvr_SafeAreaAlgoAPI.GSAPoint3i));
						list2.Add(new Vector3((float)gSAPoint3i.x / 1000f, (float)gSAPoint3i.y / 1000f, (float)gSAPoint3i.z / 1000f));
					}
					if (i == 0)
					{
						boundaryPoints = list2;
					}
					else
					{
						list.Add(list2);
					}
				}
				Pvr_SafeAreaAlgoAPI.GSARect gSARect = Pvr_BoundaryAPI.IntPtrToStruct<Pvr_SafeAreaAlgoAPI.GSARect>(safeAreaRectPtr);
				BoundaryPlayerArea playAreaInfo = default(BoundaryPlayerArea);
				playAreaInfo.lowerleft = new Vector3((float)gSARect.leftup.x / 1000f, (float)gSARect.leftup.y / 1000f, (float)gSARect.leftup.z / 1000f);
				playAreaInfo.upperleft = new Vector3((float)gSARect.leftdown.x / 1000f, (float)gSARect.leftdown.y / 1000f, (float)gSARect.leftdown.z / 1000f);
				playAreaInfo.upperRight = new Vector3((float)gSARect.rightdown.x / 1000f, (float)gSARect.rightdown.y / 1000f, (float)gSARect.rightdown.z / 1000f);
				playAreaInfo.lowerRight = new Vector3((float)gSARect.rightup.x / 1000f, (float)gSARect.rightup.y / 1000f, (float)gSARect.rightup.z / 1000f);
				playAreaInfo.center = new Vector3((float)gSARect.center.x / 1000f, (float)gSARect.center.y / 1000f, (float)gSARect.center.z / 1000f);
				playAreaInfo.width = gSARect.width;
				playAreaInfo.height = gSARect.height;
				playAreaInfo.isLegal = ((gSARect.isLegal != 0) ? true : false);
				playAreaInfo.extraInfo.overMaxRange = ((gSARect.legalData.overMaxRange != 0) ? true : false);
				playAreaInfo.extraInfo.includeBigGap = ((gSARect.legalData.includeBigGrap != 0) ? true : false);
				playAreaInfo.extraInfo.bigGapNum = gSARect.legalData.bigGapNum;
				playAreaInfo.extraInfo.centerOut = ((gSARect.legalData.centerOut != 0) ? true : false);
				playAreaInfo.extraInfo.removeNarrow = ((gSARect.legalData.removeNarrow != 0) ? true : false);
				playAreaInfo.extraInfo.overMaxRange_more = ((gSARect.legalData.overMaxRange_more != 0) ? true : false);
				playAreaInfo.extraInfo.validShrinkArea = gSARect.legalData.validShrinkArea;
				instance.boundarySystemCallback(playAreaInfo, boundaryPoints, list);
			}
		}

		[MonoPInvokeCallback(typeof(Pvr_SafeAreaAlgoAPI.SafeAreaCallbackShrink))]
		private static void _SafeAreaCallbackShrink(IntPtr lineCollectionPtr, IntPtr safeAreaDetailRectPtr)
		{
			if (lineCollectionPtr == IntPtr.Zero || safeAreaDetailRectPtr == IntPtr.Zero)
			{
				UnityEngine.Debug.LogError("BoundarySystem callback is inValid!");
			}
			else
			{
				if (instance.boundarySystemCallbackShrink == null)
				{
					return;
				}
				List<Vector3> boundaryPoints = new List<Vector3>();
				List<List<Vector3>> list = new List<List<Vector3>>();
				int num = Marshal.SizeOf(typeof(Pvr_SafeAreaAlgoAPI.GSALine));
				int num2 = Marshal.SizeOf(typeof(Pvr_SafeAreaAlgoAPI.GSAPoint3i));
				Pvr_SafeAreaAlgoAPI.GSALineCollection gSALineCollection = Pvr_BoundaryAPI.IntPtrToStruct<Pvr_SafeAreaAlgoAPI.GSALineCollection>(lineCollectionPtr);
				for (int i = 0; i < gSALineCollection.lineCount; i++)
				{
					Pvr_SafeAreaAlgoAPI.GSALine gSALine = (Pvr_SafeAreaAlgoAPI.GSALine)Marshal.PtrToStructure(new IntPtr(gSALineCollection.lineArray.ToInt64() + num * i), typeof(Pvr_SafeAreaAlgoAPI.GSALine));
					List<Vector3> list2 = new List<Vector3>();
					for (int j = 0; j < gSALine.pointCount; j++)
					{
						Pvr_SafeAreaAlgoAPI.GSAPoint3i gSAPoint3i = (Pvr_SafeAreaAlgoAPI.GSAPoint3i)Marshal.PtrToStructure(new IntPtr(gSALine.pointArray.ToInt64() + num2 * j), typeof(Pvr_SafeAreaAlgoAPI.GSAPoint3i));
						list2.Add(new Vector3((float)gSAPoint3i.x / 1000f, (float)gSAPoint3i.y / 1000f, (float)gSAPoint3i.z / 1000f));
					}
					if (i == 0)
					{
						boundaryPoints = list2;
					}
					else
					{
						list.Add(list2);
					}
				}
				List<Vector3> list3 = new List<Vector3>();
				Pvr_SafeAreaAlgoAPI.GSALineCollection gSALineCollection2 = Pvr_BoundaryAPI.IntPtrToStruct<Pvr_SafeAreaAlgoAPI.GSALineCollection>(safeAreaDetailRectPtr);
				for (int k = 0; k < gSALineCollection2.lineCount; k++)
				{
					Pvr_SafeAreaAlgoAPI.GSALine gSALine2 = (Pvr_SafeAreaAlgoAPI.GSALine)Marshal.PtrToStructure(new IntPtr(gSALineCollection2.lineArray.ToInt64() + num * k), typeof(Pvr_SafeAreaAlgoAPI.GSALine));
					for (int l = 0; l < gSALine2.pointCount; l++)
					{
						Pvr_SafeAreaAlgoAPI.GSAPoint3i gSAPoint3i2 = (Pvr_SafeAreaAlgoAPI.GSAPoint3i)Marshal.PtrToStructure(new IntPtr(gSALine2.pointArray.ToInt64() + num2 * l), typeof(Pvr_SafeAreaAlgoAPI.GSAPoint3i));
						list3.Add(new Vector3((float)gSAPoint3i2.x / 1000f, (float)gSAPoint3i2.y / 1000f, (float)gSAPoint3i2.z / 1000f));
					}
				}
				instance.boundarySystemCallbackShrink(list3, boundaryPoints, list);
			}
		}
	}
}
namespace Pvr_UnitySDKAPI
{
	public class PvrControllerKey
	{
		public bool State;

		public bool PressedDown;

		public bool PressedUp;

		public bool LongPressed;

		public bool Click;

		public bool Touch;

		public bool TouchDown;

		public bool TouchUp;

		public PvrControllerKey()
		{
			State = false;
			PressedDown = false;
			PressedUp = false;
			LongPressed = false;
			Click = false;
			Touch = false;
			TouchDown = false;
			TouchUp = false;
		}
	}
	public class ControllerHand
	{
		public PvrControllerKey App;

		public PvrControllerKey Touch;

		public PvrControllerKey Home;

		public PvrControllerKey VolumeDown;

		public PvrControllerKey VolumeUp;

		public PvrControllerKey Trigger;

		public PvrControllerKey X;

		public PvrControllerKey Y;

		public PvrControllerKey A;

		public PvrControllerKey B;

		public PvrControllerKey Left;

		public PvrControllerKey Right;

		public PvrControllerKey Thumbrest;

		public Vector2 TouchPadPosition;

		public int TriggerNum;

		public int GripValue;

		public Quaternion Rotation;

		public Vector3 Position;

		public int Battery;

		public ControllerState ConnectState;

		public SwipeDirection SwipeDirection;

		public TouchPadClick TouchPadClick;

		public bool isShowBoundary;

		public ControllerHand()
		{
			App = new PvrControllerKey();
			Touch = new PvrControllerKey();
			Home = new PvrControllerKey();
			VolumeDown = new PvrControllerKey();
			VolumeUp = new PvrControllerKey();
			Trigger = new PvrControllerKey();
			A = new PvrControllerKey();
			B = new PvrControllerKey();
			X = new PvrControllerKey();
			Y = new PvrControllerKey();
			Left = new PvrControllerKey();
			Right = new PvrControllerKey();
			Thumbrest = new PvrControllerKey();
			TouchPadPosition = default(Vector2);
			Rotation = default(Quaternion);
			Position = default(Vector3);
			Battery = 0;
			TriggerNum = 0;
			GripValue = 0;
			ConnectState = ControllerState.Error;
			SwipeDirection = SwipeDirection.No;
			TouchPadClick = TouchPadClick.No;
			isShowBoundary = false;
		}
	}
	public enum ControllerState
	{
		Error = -1,
		DisConnected,
		Connected
	}
	public enum Pvr_KeyCode
	{
		APP = 1,
		TOUCHPAD,
		HOME,
		VOLUMEUP,
		VOLUMEDOWN,
		TRIGGER,
		A,
		B,
		X,
		Y,
		Left,
		Right,
		Thumbrest
	}
	public enum SwipeDirection
	{
		No,
		SwipeUp,
		SwipeDown,
		SwipeLeft,
		SwipeRight
	}
	public enum TouchPadClick
	{
		No,
		ClickUp,
		ClickDown,
		ClickLeft,
		ClickRight
	}
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	public struct Controller
	{
		public const string LibFileName = "Pvr_UnitySDK";

		public static Vector2 UPvr_GetTouchPadPosition(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition, 
				_ => new Vector2(0f, 0f), 
			};
		}

		public static float UPvr_GetAxis1D(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.TRIGGER => (float)Pvr_ControllerManager.controllerlink.Controller0.TriggerNum / 255f, 
					Pvr_KeyCode.Left => (float)Pvr_ControllerManager.controllerlink.Controller0.GripValue / 255f, 
					_ => 0f, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.TRIGGER => (float)Pvr_ControllerManager.controllerlink.Controller1.TriggerNum / 255f, 
					Pvr_KeyCode.Right => (float)Pvr_ControllerManager.controllerlink.Controller1.GripValue / 255f, 
					_ => 0f, 
				}, 
				_ => 0f, 
			};
		}

		public static Vector2 UPvr_GetAxis2D(int hand)
		{
			switch (hand)
			{
			case 0:
				if (Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition != Vector2.zero)
				{
					return new Vector2(Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.x / 128f - 1f, Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.y / 128f - 1f);
				}
				return Vector2.zero;
			case 1:
				if (Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition != Vector2.zero)
				{
					return new Vector2(Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.x / 128f - 1f, Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.y / 128f - 1f);
				}
				return Vector2.zero;
			default:
				return Vector2.zero;
			}
		}

		public static ControllerState UPvr_GetControllerState(int hand)
		{
			return hand switch
			{
				0 => (ControllerState)Convert.ToInt16(Pvr_ControllerManager.controllerlink.controller0Connected), 
				1 => (ControllerState)Convert.ToInt16(Pvr_ControllerManager.controllerlink.controller1Connected), 
				_ => ControllerState.Error, 
			};
		}

		public static Quaternion UPvr_GetControllerQUA(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.Rotation, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.Rotation, 
				_ => new Quaternion(0f, 0f, 0f, 1f), 
			};
		}

		public static Vector3 UPvr_GetControllerPOS(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.Position, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.Position, 
				_ => new Vector3(0f, 0f, 0f), 
			};
		}

		public static int UPvr_GetControllerTriggerValue(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.TriggerNum, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.TriggerNum, 
				_ => 0, 
			};
		}

		public static int UPvr_GetControllerPower(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.Battery, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.Battery, 
				_ => 0, 
			};
		}

		public static SwipeDirection UPvr_GetSwipeDirection(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.SwipeDirection, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.SwipeDirection, 
				_ => SwipeDirection.No, 
			};
		}

		public static TouchPadClick UPvr_GetTouchPadClick(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.TouchPadClick, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.TouchPadClick, 
				_ => TouchPadClick.No, 
			};
		}

		public static bool UPvr_GetKey(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller0.App.State, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller0.Home.State, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.State, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller0.VolumeUp.State, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller0.VolumeDown.State, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.State, 
					Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.State, 
					Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.State, 
					Pvr_KeyCode.Left => Pvr_ControllerManager.controllerlink.Controller0.Left.State, 
					_ => false, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller1.App.State, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller1.Home.State, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.State, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller1.VolumeUp.State, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller1.VolumeDown.State, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.State, 
					Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.State, 
					Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.State, 
					Pvr_KeyCode.Right => Pvr_ControllerManager.controllerlink.Controller1.Right.State, 
					_ => false, 
				}, 
				_ => false, 
			};
		}

		public static bool UPvr_GetKeyDown(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller0.App.PressedDown, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller0.Home.PressedDown, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.PressedDown, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller0.VolumeUp.PressedDown, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller0.VolumeDown.PressedDown, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.PressedDown, 
					Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.PressedDown, 
					Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.PressedDown, 
					Pvr_KeyCode.Left => Pvr_ControllerManager.controllerlink.Controller0.Left.PressedDown, 
					_ => false, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller1.App.PressedDown, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller1.Home.PressedDown, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.PressedDown, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller1.VolumeUp.PressedDown, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller1.VolumeDown.PressedDown, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.PressedDown, 
					Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.PressedDown, 
					Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.PressedDown, 
					Pvr_KeyCode.Right => Pvr_ControllerManager.controllerlink.Controller1.Right.PressedDown, 
					_ => false, 
				}, 
				_ => false, 
			};
		}

		public static bool UPvr_GetKeyUp(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller0.App.PressedUp, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller0.Home.PressedUp, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.PressedUp, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller0.VolumeUp.PressedUp, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller0.VolumeDown.PressedUp, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.PressedUp, 
					Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.PressedUp, 
					Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.PressedUp, 
					Pvr_KeyCode.Left => Pvr_ControllerManager.controllerlink.Controller0.Left.PressedUp, 
					_ => false, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller1.App.PressedUp, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller1.Home.PressedUp, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.PressedUp, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller1.VolumeUp.PressedUp, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller1.VolumeDown.PressedUp, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.PressedUp, 
					Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.PressedUp, 
					Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.PressedUp, 
					Pvr_KeyCode.Right => Pvr_ControllerManager.controllerlink.Controller1.Right.PressedUp, 
					_ => false, 
				}, 
				_ => false, 
			};
		}

		public static bool UPvr_GetTouch(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.Touch, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.Touch, 
					Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.Touch, 
					Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.Touch, 
					Pvr_KeyCode.Thumbrest => Pvr_ControllerManager.controllerlink.Controller0.Thumbrest.Touch, 
					_ => false, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.Touch, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.Touch, 
					Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.Touch, 
					Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.Touch, 
					Pvr_KeyCode.Thumbrest => Pvr_ControllerManager.controllerlink.Controller1.Thumbrest.Touch, 
					_ => false, 
				}, 
				_ => false, 
			};
		}

		public static bool UPvr_GetTouchDown(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.TouchDown, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.TouchDown, 
					Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.TouchDown, 
					Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.TouchDown, 
					Pvr_KeyCode.Thumbrest => Pvr_ControllerManager.controllerlink.Controller0.Thumbrest.TouchDown, 
					_ => false, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.TouchDown, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.TouchDown, 
					Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.TouchDown, 
					Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.TouchDown, 
					Pvr_KeyCode.Thumbrest => Pvr_ControllerManager.controllerlink.Controller1.Thumbrest.TouchDown, 
					_ => false, 
				}, 
				_ => false, 
			};
		}

		public static bool UPvr_GetTouchUp(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.TouchUp, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.TouchUp, 
					Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.TouchUp, 
					Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.TouchUp, 
					Pvr_KeyCode.Thumbrest => Pvr_ControllerManager.controllerlink.Controller0.Thumbrest.TouchUp, 
					_ => false, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.TouchUp, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.TouchUp, 
					Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.TouchUp, 
					Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.TouchUp, 
					Pvr_KeyCode.Thumbrest => Pvr_ControllerManager.controllerlink.Controller1.Thumbrest.TouchUp, 
					_ => false, 
				}, 
				_ => false, 
			};
		}

		public static bool UPvr_GetKeyClick(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller0.App.Click, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller0.Home.Click, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.Click, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller0.VolumeUp.Click, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller0.VolumeDown.Click, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.Click, 
					Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.Click, 
					Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.Click, 
					Pvr_KeyCode.Left => Pvr_ControllerManager.controllerlink.Controller0.Left.Click, 
					_ => false, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller1.App.Click, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller1.Home.Click, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.Click, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller1.VolumeUp.Click, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller1.VolumeDown.Click, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.Click, 
					Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.Click, 
					Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.Click, 
					Pvr_KeyCode.Right => Pvr_ControllerManager.controllerlink.Controller1.Right.Click, 
					_ => false, 
				}, 
				_ => false, 
			};
		}

		public static bool UPvr_GetKeyLongPressed(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller0.App.LongPressed, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller0.Home.LongPressed, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.LongPressed, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller0.VolumeUp.LongPressed, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller0.VolumeDown.LongPressed, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.LongPressed, 
					Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.LongPressed, 
					Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.LongPressed, 
					Pvr_KeyCode.Left => Pvr_ControllerManager.controllerlink.Controller0.Left.LongPressed, 
					_ => false, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller1.App.LongPressed, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller1.Home.LongPressed, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.LongPressed, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller1.VolumeUp.LongPressed, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller1.VolumeDown.LongPressed, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.LongPressed, 
					Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.LongPressed, 
					Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.LongPressed, 
					Pvr_KeyCode.Right => Pvr_ControllerManager.controllerlink.Controller1.Right.LongPressed, 
					_ => false, 
				}, 
				_ => false, 
			};
		}

		public static bool UPvr_IsTouching(int hand)
		{
			switch (hand)
			{
			case 0:
				if (!(Math.Abs(Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.x) > 0f))
				{
					return Math.Abs(Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.y) > 0f;
				}
				return true;
			case 1:
				if (!(Math.Abs(Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.x) > 0f))
				{
					return Math.Abs(Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.y) > 0f;
				}
				return true;
			default:
				return false;
			}
		}

		public static void UPvr_SetHandNess(Pvr_Controller.UserHandNess hand)
		{
			if (Pvr_ControllerManager.controllerlink.getHandness() != (int)hand)
			{
				Pvr_ControllerManager.controllerlink.setHandness((int)hand);
			}
		}

		public static Pvr_Controller.UserHandNess UPvr_GetHandNess()
		{
			return Pvr_ControllerManager.controllerlink.handness;
		}

		public static int UPvr_GetPreferenceDevice()
		{
			int trackingmode = Pvr_ControllerManager.controllerlink.trackingmode;
			int systemProp = Pvr_ControllerManager.controllerlink.systemProp;
			if (trackingmode == 0 || trackingmode == 1 || ((trackingmode == 3 || trackingmode == 5 || trackingmode == 6) && (systemProp == 1 || systemProp == 3)))
			{
				return 1;
			}
			return 2;
		}

		public static bool UPvr_IsEnbleTrigger()
		{
			return Pvr_ControllerManager.controllerlink.IsEnbleTrigger();
		}

		public static int UPvr_GetDeviceType()
		{
			return Pvr_ControllerManager.controllerlink.controllerType;
		}

		public static int UPvr_GetMainHandNess()
		{
			return Pvr_ControllerManager.controllerlink.mainHandID;
		}

		public static void UPvr_SetMainHandNess(int hand)
		{
			Pvr_ControllerManager.controllerlink.SetMainController(hand);
		}

		public static int UPvr_GetControllerAbility(int hand)
		{
			return Pvr_ControllerManager.controllerlink.GetControllerAbility(hand);
		}

		public static void UPvr_VibrateNeo2Controller(float strength, int time, int hand)
		{
			Pvr_ControllerManager.controllerlink.VibrateNeo2Controller(strength, time, hand);
		}

		public static int UPvr_GetControllerBindingState(int hand)
		{
			return Pvr_ControllerManager.controllerlink.GetControllerBindingState(hand);
		}

		public static Vector3 UPvr_GetVelocity(int hand)
		{
			return Pvr_ControllerManager.controllerlink.GetVelocity(hand);
		}

		public static Vector3 UPvr_GetAngularVelocity(int hand)
		{
			return Pvr_ControllerManager.controllerlink.GetAngularVelocity(hand);
		}

		public static Vector3 UPvr_GetAcceleration(int hand)
		{
			return Pvr_ControllerManager.controllerlink.GetAcceleration(hand);
		}

		public static void UPvr_ScanController()
		{
			Pvr_ControllerManager.controllerlink.StartScan();
		}

		public static void UPvr_StopScanController()
		{
			Pvr_ControllerManager.controllerlink.StopScan();
		}

		public static void UPvr_ConnectController(string mac)
		{
			if (mac != "")
			{
				Pvr_ControllerManager.controllerlink.hummingBirdMac = mac;
			}
			Pvr_ControllerManager.controllerlink.ConnectBLE();
		}

		public static void UPvr_DisConnectController()
		{
			Pvr_ControllerManager.controllerlink.DisConnectBLE();
		}

		public static void UPvr_ResetController(int hand)
		{
			Pvr_ControllerManager.controllerlink.ResetController(hand);
		}

		public static string UPvr_GetControllerVersion()
		{
			return Pvr_ControllerManager.controllerlink.GetControllerVersion();
		}

		public static void UPvr_GetDeviceVersion(int deviceType)
		{
			Pvr_ControllerManager.controllerlink.GetDeviceVersion(deviceType);
		}

		public static void UPvr_GetControllerSnCode(int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.GetControllerSnCode(controllerSerialNum);
		}

		public static void UPvr_SetControllerUnbind(int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.SetControllerUnbind(controllerSerialNum);
		}

		public static void UPvr_SetStationRestart()
		{
			Pvr_ControllerManager.controllerlink.SetStationRestart();
		}

		public static void UPvr_StartStationOtaUpdate()
		{
			Pvr_ControllerManager.controllerlink.StartStationOtaUpdate();
		}

		public static void UPvr_StartControllerOtaUpdate(int mode, int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.StartControllerOtaUpdate(mode, controllerSerialNum);
		}

		public static void UPvr_EnterPairMode(int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.EnterPairMode(controllerSerialNum);
		}

		public static void UPvr_SetControllerShutdown(int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.SetControllerShutdown(controllerSerialNum);
		}

		public static int UPvr_GetStationPairState()
		{
			return Pvr_ControllerManager.controllerlink.GetStationPairState();
		}

		public static int UPvr_GetStationOtaUpdateProgress()
		{
			return Pvr_ControllerManager.controllerlink.GetStationOtaUpdateProgress();
		}

		public static int UPvr_GetControllerOtaUpdateProgress()
		{
			return Pvr_ControllerManager.controllerlink.GetControllerOtaUpdateProgress();
		}

		public static void UPvr_GetControllerVersionAndSN(int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.GetControllerVersionAndSN(controllerSerialNum);
		}

		public static void UPvr_GetControllerUniqueID()
		{
			Pvr_ControllerManager.controllerlink.GetControllerUniqueID();
		}

		public void UPvr_InterruptStationPairMode()
		{
			Pvr_ControllerManager.controllerlink.InterruptStationPairMode();
		}

		public void UPvr_StartCV2PairingMode(int deviceType)
		{
			Pvr_ControllerManager.controllerlink.StartCV2PairingMode(deviceType);
		}

		public void UPvr_StopCV2PairingMode(int deviceType)
		{
			Pvr_ControllerManager.controllerlink.StopCV2PairingMode(deviceType);
		}

		public static void UPvr_SetArmModelParameters(int hand, int gazeType, float elbowHeight, float elbowDepth, float pointerTiltAngle)
		{
			Pvr_SetArmModelParameters(hand, gazeType, elbowHeight, elbowDepth, pointerTiltAngle);
		}

		public static void UPvr_CalcArmModelParameters(float[] headOrientation, float[] controllerOrientation, float[] controllerPrimary)
		{
			Pvr_CalcArmModelParameters(headOrientation, controllerOrientation, controllerPrimary);
		}

		public static void UPvr_GetPointerPose(float[] rotation, float[] position)
		{
			Pvr_GetPointerPose(rotation, position);
		}

		public static void UPvr_GetElbowPose(float[] rotation, float[] position)
		{
			Pvr_GetElbowPose(rotation, position);
		}

		public static void UPvr_GetWristPose(float[] rotation, float[] position)
		{
			Pvr_GetWristPose(rotation, position);
		}

		public static void UPvr_GetShoulderPose(float[] rotation, float[] position)
		{
			Pvr_GetShoulderPose(rotation, position);
		}

		public static void UPvr_IsEnbleHomeKey(bool state)
		{
			Pvr_ControllerManager.controllerlink.setIsEnbleHomeKey(state);
		}

		public static void UPvr_SwitchHomeKey(bool state)
		{
			Pvr_ControllerManager.controllerlink.SwitchHomeKey(state);
		}

		public static int UPvr_GetControllerSensorStatus(int id)
		{
			return Pvr_ControllerManager.controllerlink.getControllerSensorStatus(id);
		}

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_CalcArmModelParameters(float[] headOrientation, float[] controllerOrientation, float[] gyro);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_GetPointerPose(float[] rotation, float[] position);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_GetElbowPose(float[] rotation, float[] position);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_GetWristPose(float[] rotation, float[] position);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_GetShoulderPose(float[] rotation, float[] position);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetArmModelParameters(int hand, int gazeType, float elbowHeight, float elbowDepth, float pointerTiltAngle);
	}
	public enum ControllerVariety
	{
		Controller0,
		Controller1
	}
	public enum ControllerDevice
	{
		Goblin,
		Neo,
		G2,
		Neo2,
		Neo3,
		NewController
	}
	public enum PBS_SystemInfoEnum
	{
		ELECTRIC_QUANTITY,
		PUI_VERSION,
		EQUIPMENT_MODEL,
		EQUIPMENT_SN,
		CUSTOMER_SN,
		INTERNAL_STORAGE_SPACE_OF_THE_DEVICE,
		DEVICE_BLUETOOTH_STATUS,
		BLUETOOTH_NAME_CONNECTED,
		BLUETOOTH_MAC_ADDRESS,
		DEVICE_WIFI_STATUS,
		WIFI_NAME_CONNECTED,
		WLAN_MAC_ADDRESS,
		DEVICE_IP
	}
	public enum PBS_DeviceControlEnum
	{
		DEVICE_CONTROL_REBOOT,
		DEVICE_CONTROL_SHUTDOWN
	}
	public enum PBS_PackageControlEnum
	{
		PACKAGE_SILENCE_INSTALL,
		PACKAGE_SILENCE_UNINSTALL
	}
	public enum PBS_SwitchEnum
	{
		S_ON,
		S_OFF
	}
	public enum PBS_HomeEventEnum
	{
		SINGLE_CLICK,
		DOUBLE_CLICK,
		LONG_PRESS
	}
	public enum PBS_HomeFunctionEnum
	{
		VALUE_HOME_GO_TO_SETTING,
		VALUE_HOME_BACK,
		VALUE_HOME_RECENTER,
		VALUE_HOME_OPEN_APP,
		VALUE_HOME_DISABLE,
		VALUE_HOME_GO_TO_HOME,
		VALUE_HOME_SEND_BROADCAST,
		VALUE_HOME_CLEAN_MEMORY
	}
	public enum PBS_ScreenOffDelayTimeEnum
	{
		THREE = 3,
		TEN = 10,
		THIRTY = 30,
		SIXTY = 60,
		THREE_HUNDRED = 300,
		SIX_HUNDRED = 600,
		NEVER = -1
	}
	public enum PBS_SleepDelayTimeEnum
	{
		FIFTEEN = 15,
		THIRTY = 30,
		SIXTY = 60,
		THREE_HUNDRED = 300,
		SIX_HUNDRED = 600,
		ONE_THOUSAND_AND_EIGHT_HUNDRED = 1800,
		NEVER = -1
	}
	public enum PBS_SystemFunctionSwitchEnum
	{
		SFS_USB,
		SFS_AUTOSLEEP,
		SFS_SCREENON_CHARGING,
		SFS_OTG_CHARGING,
		SFS_RETURN_MENU_IN_2DMODE,
		SFS_COMBINATION_KEY,
		SFS_CALIBRATION_WITH_POWER_ON,
		SFS_SYSTEM_UPDATE,
		SFS_CAST_SERVICE,
		SFS_EYE_PROTECTION,
		SFS_SECURITY_ZONE_PERMANENTLY,
		SFS_GLOBAL_CALIBRATION,
		SFS_Auto_Calibration,
		SFS_USB_BOOT
	}
	public enum PBS_USBConfigModeEnum
	{
		MTP,
		CHARGE
	}
	public struct ToBService
	{
		public static Action<bool> BoolCallback;

		public static Action<int> IntCallback;

		public static Action<long> LongCallback;

		private static AndroidJavaClass unityPlayer;

		private static AndroidJavaObject currentActivity;

		private static AndroidJavaObject tobHelper;

		private static AndroidJavaClass tobHelperClass;

		public static void UPvr_InitToBService()
		{
			tobHelperClass = new AndroidJavaClass("com.pvr.tobservice.ToBServiceHelper");
			tobHelper = tobHelperClass.CallStatic<AndroidJavaObject>("getInstance", Array.Empty<object>());
			unityPlayer = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
			currentActivity = unityPlayer.GetStatic<AndroidJavaObject>("currentActivity");
		}

		public static void UPvr_SetUnityObjectName(string obj)
		{
			System.UPvr_CallMethod(tobHelper, "setUnityObjectName", obj);
		}

		public static void UPvr_BindToBService()
		{
			System.UPvr_CallMethod(tobHelper, "bindTobService", currentActivity);
		}

		public static void UPvr_UnBindToBService()
		{
			System.UPvr_CallMethod(tobHelper, "unBindTobService", currentActivity);
		}

		private static AndroidJavaObject GetEnumType(Enum enumType)
		{
			return new AndroidJavaClass("com.pvr.tobservice.enums" + enumType.GetType().ToString().Replace("Pvr_UnitySDKAPI", "")).GetStatic<AndroidJavaObject>(enumType.ToString());
		}

		public static string UPvr_StateGetDeviceInfo(PBS_SystemInfoEnum type)
		{
			string result = "";
			System.UPvr_CallMethod(ref result, tobHelper, "pbsStateGetDeviceInfo", GetEnumType(type), 0);
			return result;
		}

		public static void UPvr_ControlSetDeviceAction(PBS_DeviceControlEnum deviceControl, Action<int> callback)
		{
			if (callback != null)
			{
				IntCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsControlSetDeviceAction", GetEnumType(deviceControl), null);
		}

		public static void UPvr_ControlAPPManger(PBS_PackageControlEnum packageControl, string path, Action<int> callback)
		{
			if (callback != null)
			{
				IntCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsControlAPPManger", GetEnumType(packageControl), path, 0, null);
		}

		public static void UPvr_ControlSetAutoConnectWIFI(string ssid, string pwd, Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsControlSetAutoConnectWIFI", ssid, pwd, 0, null);
		}

		public static void UPvr_ControlClearAutoConnectWIFI(Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsControlClearAutoConnectWIFI", null);
		}

		public static void UPvr_PropertySetHomeKey(PBS_HomeEventEnum eventEnum, PBS_HomeFunctionEnum function, Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsPropertySetHomeKey", GetEnumType(eventEnum), GetEnumType(function), null);
		}

		public static void UPvr_PropertySetHomeKeyAll(PBS_HomeEventEnum eventEnum, PBS_HomeFunctionEnum function, int timesetup, string pkg, string className, Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsPropertySetHomeKeyAll", GetEnumType(eventEnum), GetEnumType(function), timesetup, pkg, className, null);
		}

		public static void UPvr_PropertyDisablePowerKey(bool isSingleTap, bool enable, Action<int> callback)
		{
			if (callback != null)
			{
				IntCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsPropertyDisablePowerKey", isSingleTap, enable, null);
		}

		public static void UPvr_PropertySetScreenOffDelay(PBS_ScreenOffDelayTimeEnum timeEnum, Action<int> callback)
		{
			if (callback != null)
			{
				IntCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsPropertySetScreenOffDelay", GetEnumType(timeEnum), null);
		}

		public static void UPvr_PropertySetSleepDelay(PBS_SleepDelayTimeEnum timeEnum)
		{
			System.UPvr_CallMethod(tobHelper, "pbsPropertySetSleepDelay", GetEnumType(timeEnum));
		}

		public static void UPvr_SwitchSystemFunction(PBS_SystemFunctionSwitchEnum systemFunction, PBS_SwitchEnum switchEnum)
		{
			System.UPvr_CallMethod(tobHelper, "pbsSwitchSystemFunction", GetEnumType(systemFunction), GetEnumType(switchEnum), 0);
		}

		public static void UPvr_SwitchSetUsbConfigurationOption(PBS_USBConfigModeEnum uSBConfigModeEnum)
		{
			System.UPvr_CallMethod(tobHelper, "pbsSwitchSetUsbConfigurationOption", GetEnumType(uSBConfigModeEnum), 0);
		}

		public static void UPvr_ScreenOn()
		{
			System.UPvr_CallMethod(tobHelper, "pbsScreenOn");
		}

		public static void UPvr_ScreenOff()
		{
			System.UPvr_CallMethod(tobHelper, "pbsScreenOff");
		}

		public static void UPvr_AcquireWakeLock()
		{
			System.UPvr_CallMethod(tobHelper, "pbsAcquireWakeLock");
		}

		public static void UPvr_ReleaseWakeLock()
		{
			System.UPvr_CallMethod(tobHelper, "pbsReleaseWakeLock");
		}

		public static void UPvr_EnableEnterKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsEnableEnterKey");
		}

		public static void UPvr_DisableEnterKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsDisableEnterKey");
		}

		public static void UPvr_EnableVolumeKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsEnableVolumeKey");
		}

		public static void UPvr_DisableVolumeKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsDisableVolumeKey");
		}

		public static void UPvr_EnableBackKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsEnableBackKey");
		}

		public static void UPvr_DisableBackKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsDisableBackKey");
		}

		public static void UPvr_WriteConfigFileToDataLocal(string path, string content, Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsWriteConfigFileToDataLocal", path, content, null);
		}

		public static void UPvr_ResetAllKeyToDefault(Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsResetAllKeyToDefault", null);
		}
	}
	public enum GlobalIntConfigs
	{
		EYE_TEXTURE_RESOLUTION0,
		EYE_TEXTURE_RESOLUTION1,
		SEENSOR_COUNT,
		ABILITY6DOF,
		PLATFORM_TYPE,
		TRACKING_MODE,
		LOG_LEVEL,
		ENBLE_HAND6DOF_BY_HEAD,
		ENBLE_6DOF_GLOBAL_TRACKING,
		TARGET_FRAME_RATE,
		iShowFPS,
		SensorMode,
		LOGICFLOW,
		EYE_TEXTURE_RES_HIGH,
		EYE_TEXTURE_RES_NORMAL,
		iCtrlModelLoadingPri,
		iPhoneHMDModeEnabled,
		isEnableBoundary,
		Enable_Activity_Rotation,
		GetDisplay_Orientation,
		GetWaitFrameNum,
		GetResetFrameNum,
		EnableFFRBYSYS,
		RotControllerMode
	}
	public enum GlobalFloatConfigs
	{
		IPD,
		VFOV,
		HFOV,
		NECK_MODEL_X,
		NECK_MODEL_Y,
		NECK_MODEL_Z,
		DISPLAY_REFRESH_RATE
	}
	public enum RenderTextureAntiAliasing
	{
		X_1 = 1,
		X_2 = 2,
		X_4 = 4,
		X_8 = 8
	}
	public enum PlatForm
	{
		Android = 1,
		IOS,
		Win,
		Notsupport
	}
	public enum RenderTextureDepth
	{
		BD_0 = 0,
		BD_16 = 16,
		BD_24 = 24
	}
	public enum RenderTextureLevel
	{
		Normal,
		High
	}
	public enum Sensorindex
	{
		Default,
		FirstSensor,
		SecondSensor
	}
	public enum Eye
	{
		LeftEye,
		RightEye,
		BothEye
	}
	public enum ResUtilsType
	{
		TYPE_TEXTSIZE,
		TYPE_COLOR,
		TYPE_TEXT,
		TYPE_FONT,
		TYPE_VALUE,
		TYPE_DRAWABLE,
		TYPE_OBJECT,
		TYPR_OBJECTARRAY
	}
	public enum TrackingOrigin
	{
		EyeLevel,
		FloorLevel,
		StageLevel
	}
	public enum EFoveationLevel
	{
		Low,
		Med,
		High,
		Top_High
	}
	public enum StereoRenderingPathPico
	{
		MultiPass,
		SinglePass
	}
	public enum pvrEyePoseStatus
	{
		kGazePointValid = 1,
		kGazeVectorValid = 2,
		kEyeOpennessValid = 4,
		kEyePupilDilationValid = 8,
		kEyePositionGuideValid = 0x10
	}
	public enum TrackingMode
	{
		PVR_TRACKING_MODE_ROTATION = 1,
		PVR_TRACKING_MODE_POSITION = 2,
		PVR_TRACKING_MODE_EYE = 4
	}
	public struct EyeTrackingData
	{
		public int leftEyePoseStatus;

		public int rightEyePoseStatus;

		public int combinedEyePoseStatus;

		public Vector3 leftEyeGazePoint;

		public Vector3 rightEyeGazePoint;

		public Vector3 combinedEyeGazePoint;

		public Vector3 leftEyeGazeVector;

		public Vector3 rightEyeGazeVector;

		public Vector3 combinedEyeGazeVector;

		public float leftEyeOpenness;

		public float rightEyeOpenness;

		public float leftEyePupilDilation;

		public float rightEyePupilDilation;

		public Vector3 leftEyePositionGuide;

		public Vector3 rightEyePositionGuide;

		public Vector3 foveatedGazeDirection;

		public int foveatedGazeTrackingState;

		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]
		public byte[] reserved;
	}
	public struct EyeTrackingGazeRay
	{
		public Vector3 Direction;

		public bool IsValid;

		public Vector3 Origin;
	}
	public struct EyeDeviceInfo
	{
		public ViewFrustum targetFrustumLeft;

		public ViewFrustum targetFrustumRight;
	}
	public struct ViewFrustum
	{
		public float left;

		public float right;

		public float top;

		public float bottom;

		public float near;

		public float far;
	}
	public struct EyeSetting
	{
		public Transform eyelocalPosition;

		public Rect eyeRect;

		public float eyeFov;

		public float eyeAspect;

		public Matrix4x4 eyeProjectionMatrix;

		public Shader eyeShader;
	}
	public struct Sensor
	{
		public const string LibFileName = "Pvr_UnitySDK";

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_Enable6DofModule(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_OptionalResetSensor(int index, int resetRot, int resetPos);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_Init(int index);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_StartSensor(int index);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_StopSensor(int index);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_ResetSensor(int index);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_ResetSensorAll(int index);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetSensorState(int index, ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetMainSensorState(ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz, ref float vfov, ref float hfov, ref int viewNumber);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetPsensorState();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetHmdPSensorStatus();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetSensorGyroscope(int index, ref float x, ref float y, ref float z);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetSensorMagnet(int index, ref float x, ref float y, ref float z);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_Get6DofSensorQualityStatus();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_Get6DofSafePanelFlag();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetReinPosition(float x, float y, float z, float w, float px, float py, float pz, int hand, bool valid, int key);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_SetTrackingOriginType(TrackingOrigin trackingOriginType);

		public static bool UPvr_Pvr_Get6DofSafePanelFlag()
		{
			return Pvr_Get6DofSafePanelFlag();
		}

		public static int UPvr_Init(int index)
		{
			return Pvr_Init(index);
		}

		public static void UPvr_InitPsensor()
		{
			Pvr_InitPsensor();
		}

		public static int UPvr_GetPsensorState()
		{
			int res = -1;
			Render.UPvr_GetIntConfig(4, ref res);
			if (res == 1)
			{
				return Pvr_GetPsensorState();
			}
			int num = Pvr_GetAndroidPsensorState();
			if (num != 0 && num != -1)
			{
				num = 1;
			}
			return num;
		}

		public static int UPvr_GetPSensorStatus()
		{
			return Pvr_GetHmdPSensorStatus();
		}

		public static void UPvr_UnregisterPsensor()
		{
			Pvr_UnregisterPsensor();
		}

		public static int UPvr_StartSensor(int index)
		{
			return Pvr_StartSensor(index);
		}

		public static int UPvr_StopSensor(int index)
		{
			return Pvr_StopSensor(index);
		}

		public static int UPvr_ResetSensor(int index)
		{
			Pvr_UnitySDKManager.SDK.resetBasePos = default(Vector3);
			return Pvr_ResetSensor(index);
		}

		public static int UPvr_OptionalResetSensor(int index, int resetRot, int resetPos)
		{
			return Pvr_OptionalResetSensor(index, resetRot, resetPos);
		}

		public static int UPvr_GetSensorState(int index, ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz)
		{
			return Pvr_GetSensorState(index, ref x, ref y, ref z, ref w, ref px, ref py, ref pz);
		}

		public static int UPvr_GetMainSensorState(ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz, ref float vfov, ref float hfov, ref int viewNumber)
		{
			return Pvr_GetMainSensorState(ref x, ref y, ref z, ref w, ref px, ref py, ref pz, ref vfov, ref hfov, ref viewNumber);
		}

		public static int UPvr_GetSensorGyroscope(int index, ref float x, ref float y, ref float z)
		{
			return Pvr_GetSensorGyroscope(index, ref x, ref y, ref z);
		}

		public static int UPvr_GetSensorMagnet(int index, ref float x, ref float y, ref float z)
		{
			return Pvr_GetSensorMagnet(index, ref x, ref y, ref z);
		}

		public static int UPvr_Get6DofSensorQualityStatus()
		{
			return Pvr_Get6DofSensorQualityStatus();
		}

		public static int UPvr_Enable6DofModule(bool enable)
		{
			return Pvr_Enable6DofModule(enable);
		}

		public static void Pvr_InitPsensor()
		{
			try
			{
				System.UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaSysActivityClass, "initPsensor", Pvr_UnitySDKRender.Instance.activity);
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
		}

		public static bool Pvr_IsHead6dofReset()
		{
			int res = 0;
			Render.UPvr_GetIntConfig(17, ref res);
			if (res > 0)
			{
				return false;
			}
			bool result = false;
			try
			{
				System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaSysActivityClass, "isHead6dofReset", Pvr_UnitySDKRender.Instance.activity);
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
			return result;
		}

		public static int Pvr_GetAndroidPsensorState()
		{
			int result = -1;
			try
			{
				System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaSysActivityClass, "getPsensorState");
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
			return result;
		}

		public static void Pvr_UnregisterPsensor()
		{
			try
			{
				System.UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaSysActivityClass, "unregisterListener");
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
		}

		public static int UPvr_ResetSensorAll(int index)
		{
			return Pvr_ResetSensorAll(index);
		}

		public static void UPvr_SetReinPosition(float x, float y, float z, float w, float px, float py, float pz, int hand, bool valid, int key)
		{
			if (PLOG.logLevel > 2)
			{
				PLOG.D("PvrLog UPvr_SetReinPosition" + x + y + z + w + px + py + pz + hand + valid.ToString() + key);
			}
			Pvr_SetReinPosition(x, y, z, w, px, py, pz, hand, valid, key);
		}

		public static bool UPvr_SetTrackingOriginType(TrackingOrigin trackingOriginType)
		{
			return Pvr_SetTrackingOriginType(trackingOriginType);
		}
	}
	public struct Render
	{
		public const string LibFileName = "Pvr_UnitySDK";

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_ChangeScreenParameters(string model, int width, int height, double xppi, double yppi, double densityDpi);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_SetRatio(float midH, float midV);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_SetPupillaryPoint(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr Pvr_GetSupportHMDTypes();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetCurrentHMDType([MarshalAs(UnmanagedType.LPStr)] string type);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetIntConfig(int configsenum, ref int res);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetFloatConfig(int configsenum, ref float res);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetupLayerData(int layerIndex, int sideMask, int textureId, int textureType, int layerFlags, float[] colorScaleAndOffset);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetupLayerCoords(int layerIndex, int sideMask, float[] lowerLeft, float[] lowerRight, float[] upperLeft, float[] upperRight);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetOverlayModelViewMatrix(int overlayType, int overlayShape, int texId, int eyeSide, int layerIndex, bool isHeadLocked, int layerFlags, float[] mvMatrix, float[] modelS, float[] modelR, float[] modelT, float[] cameraR, float[] cameraT, float[] colorScaleAndOffset);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_EnableFoveation(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetFoveationParameters(int textureId, int previousId, float focalPointX, float focalPointY, float foveationGainX, float foveationGainY, float foveationArea, float foveationMinimum);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetFoveationResource(int textureId, int previousId, float focalPointX, float focalPointY);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetFoveationParameters2(float foveationGainX, float foveationGainY, float foveationArea, float foveationMinimum);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetFoveationLevel(EFoveationLevel level);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern EFoveationLevel Pvr_GetFoveationLevel();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_GetIntSysProc(string property, ref int res);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetColorspaceType(int colorspaceType);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetCastingColorspaceType(int colorspaceType);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr Pvr_CreateLayerAndroidSurface(int layerType, int layerIndex);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr Pvr_GetLayerAndroidSurface(int layerType, int layerIndex);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetMonoMode(bool openMono);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_GetStencilMesh(int eye, ref int vertexCount, ref int triangleCount, ref IntPtr vertexData, ref IntPtr indexData);

		public static void UPvr_ChangeScreenParameters(string model, int width, int height, double xppi, double yppi, double densityDpi)
		{
			Pvr_ChangeScreenParameters(model, width, height, xppi, yppi, densityDpi);
		}

		public static int UPvr_SetRatio(float midH, float midV)
		{
			return Pvr_SetRatio(midH, midV);
		}

		public static void UPvr_EnableFoveation(bool enable)
		{
			if (Pvr_UnitySDKManager.SDK.SystemFFRLevel != -1 || Pvr_UnitySDKManager.SDK.SystemDebugFFRLevel != -1)
			{
				enable = true;
			}
			Pvr_EnableFoveation(enable);
		}

		[Obsolete("This API will be removed in later versions")]
		public static void UPvr_SetFoveationParameters(int textureId, int previousId, float focalPointX, float focalPointY, float foveationGainX, float foveationGainY, float foveationArea, float foveationMinimum)
		{
			Pvr_SetFoveationParameters(textureId, previousId, focalPointX, focalPointY, foveationGainX, foveationGainY, foveationArea, foveationMinimum);
		}

		public static void UPvr_SetFoveationResource(int textureId, int previousId, float focalPointX, float focalPointY)
		{
			Pvr_SetFoveationResource(textureId, previousId, focalPointX, focalPointY);
		}

		public static void SetFoveatedRenderingLevel(EFoveationLevel level)
		{
			if (Pvr_UnitySDKManager.SDK.SystemDebugFFRLevel != -1)
			{
				Pvr_SetFoveationLevel((EFoveationLevel)Pvr_UnitySDKManager.SDK.SystemDebugFFRLevel);
			}
			else if (Pvr_UnitySDKManager.SDK.SystemFFRLevel != -1)
			{
				Pvr_SetFoveationLevel((EFoveationLevel)Pvr_UnitySDKManager.SDK.SystemFFRLevel);
			}
			else
			{
				Pvr_SetFoveationLevel(level);
			}
		}

		public static EFoveationLevel GetFoveatedRenderingLevel()
		{
			return Pvr_GetFoveationLevel();
		}

		public static void SetFoveatedRenderingParameters(Vector2 ffrGainValue, float ffrAreaValue, float ffrMinimumValue)
		{
			if (Pvr_UnitySDKManager.SDK.SystemDebugFFRLevel != -1)
			{
				Pvr_SetFoveationLevel((EFoveationLevel)Pvr_UnitySDKManager.SDK.SystemDebugFFRLevel);
			}
			else if (Pvr_UnitySDKManager.SDK.SystemFFRLevel != -1)
			{
				Pvr_SetFoveationLevel((EFoveationLevel)Pvr_UnitySDKManager.SDK.SystemFFRLevel);
			}
			else
			{
				Pvr_SetFoveationParameters2(ffrGainValue.x, ffrGainValue.y, ffrAreaValue, ffrMinimumValue);
			}
		}

		public static bool UPvr_GetIntSysProc(string property, ref int res)
		{
			return Pvr_GetIntSysProc(property, ref res);
		}

		public static int UPvr_GetIntConfig(int configsenum, ref int res)
		{
			return Pvr_GetIntConfig(configsenum, ref res);
		}

		public static int UPvr_GetFloatConfig(int configsenum, ref float res)
		{
			return Pvr_GetFloatConfig(configsenum, ref res);
		}

		public static string UPvr_GetSupportHMDTypes()
		{
			IntPtr intPtr = Pvr_GetSupportHMDTypes();
			if (intPtr != IntPtr.Zero)
			{
				return Marshal.PtrToStringAnsi(intPtr);
			}
			return null;
		}

		public static void UPvr_SetCurrentHMDType(string type)
		{
			Pvr_SetCurrentHMDType(type);
		}

		public static void UPvr_SetupLayerData(int layerIndex, int sideMask, int textureId, int textureType, int layerFlags, Vector4 colorScale, Vector4 colorOffset)
		{
			Pvr_SetupLayerData(layerIndex, sideMask, textureId, textureType, layerFlags, new float[8] { colorScale.x, colorScale.y, colorScale.z, colorScale.w, colorOffset.x, colorOffset.y, colorOffset.z, colorOffset.w });
		}

		public static void UPvr_SetupLayerCoords(int layerIndex, int sideMask, float[] lowerLeft, float[] lowerRight, float[] upperLeft, float[] upperRight)
		{
			Pvr_SetupLayerCoords(layerIndex, sideMask, lowerLeft, lowerRight, upperLeft, upperRight);
		}

		public static void UPvr_SetOverlayModelViewMatrix(int overlayType, int overlayShape, int texId, int eyeSide, int layerIndex, bool isHeadLocked, int layerFlags, Matrix4x4 mvMatrix, Vector3 modelS, Quaternion modelR, Vector3 modelT, Quaternion cameraR, Vector3 cameraT, Vector4 colorScale, Vector4 colorOffset)
		{
			Pvr_SetOverlayModelViewMatrix(overlayType, overlayShape, texId, eyeSide, layerIndex, isHeadLocked, layerFlags, new float[16]
			{
				mvMatrix.m00, mvMatrix.m01, mvMatrix.m02, mvMatrix.m03, mvMatrix.m10, mvMatrix.m11, mvMatrix.m12, mvMatrix.m13, mvMatrix.m20, mvMatrix.m21,
				mvMatrix.m22, mvMatrix.m23, mvMatrix.m30, mvMatrix.m31, mvMatrix.m32, mvMatrix.m33
			}, new float[3] { modelS.x, modelS.y, modelS.z }, new float[4] { modelR.x, modelR.y, modelR.z, modelR.w }, new float[3] { modelT.x, modelT.y, modelT.z }, new float[4] { cameraR.x, cameraR.y, cameraR.z, cameraR.w }, new float[3] { cameraT.x, cameraT.y, cameraT.z }, new float[8] { colorScale.x, colorScale.y, colorScale.z, colorScale.w, colorOffset.x, colorOffset.y, colorOffset.z, colorOffset.w });
		}

		public static void UPvr_SetColorspaceType(int colorspaceType)
		{
			Pvr_SetColorspaceType(colorspaceType);
		}

		public static void UPvr_SetCastingColorspaceType(int colorspaceType)
		{
			Pvr_SetCastingColorspaceType(colorspaceType);
		}

		public static IntPtr UPvr_CreateLayerAndroidSurface(int layerType, int layerIndex)
		{
			return Pvr_CreateLayerAndroidSurface(layerType, layerIndex);
		}

		public static IntPtr UPvr_GetLayerAndroidSurface(int layerType, int layerIndex)
		{
			return Pvr_GetLayerAndroidSurface(layerType, layerIndex);
		}

		public static void UPvr_SetMonoMode(bool openMono)
		{
			Pvr_SetMonoMode(openMono);
		}

		public static void UPvr_GetStencilMesh(int eye, ref int vertexCount, ref int triangleCount, ref IntPtr vertexDataPtr, ref IntPtr indexDataPtr)
		{
			Pvr_GetStencilMesh(eye, ref vertexCount, ref triangleCount, ref vertexDataPtr, ref indexDataPtr);
		}
	}
	public struct System
	{
		public const string LibFileName = "Pvr_UnitySDK";

		public const string UnitySDKVersion = "2.8.9.12";

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_SetInitActivity(IntPtr activity, IntPtr vrActivityClass);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr Pvr_GetSDKVersion();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int Pvr_GetHmdHardwareVersion();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr Pvr_GetHmdFirmwareVersion();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr Pvr_GetHmdSerialNumber();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int PVR_GetHmdBatteryStatus();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern float PVR_GetHmdBatteryTemperature();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int PVR_SetHmdAudioStatus(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_GetEyeTrackingData(ref int leftEyePoseStatus, ref int rightEyePoseStatus, ref int combinedEyePoseStatus, ref float leftEyeGazePointX, ref float leftEyeGazePointY, ref float leftEyeGazePointZ, ref float rightEyeGazePointX, ref float rightEyeGazePointY, ref float rightEyeGazePointZ, ref float combinedEyeGazePointX, ref float combinedEyeGazePointY, ref float combinedEyeGazePointZ, ref float leftEyeGazeVectorX, ref float leftEyeGazeVectorY, ref float leftEyeGazeVectorZ, ref float rightEyeGazeVectorX, ref float rightEyeGazeVectorY, ref float rightEyeGazeVectorZ, ref float combinedEyeGazeVectorX, ref float combinedEyeGazeVectorY, ref float combinedEyeGazeVectorZ, ref float leftEyeOpenness, ref float rightEyeOpenness, ref float leftEyePupilDilation, ref float rightEyePupilDilation, ref float leftEyePositionGuideX, ref float leftEyePositionGuideY, ref float leftEyePositionGuideZ, ref float rightEyePositionGuideX, ref float rightEyePositionGuideY, ref float rightEyePositionGuideZ, ref float foveatedGazeDirectionX, ref float foveatedGazeDirectionY, ref float foveatedGazeDirectionZ, ref int foveatedGazeTrackingState);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_SetTrackingMode(int trackingMode);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int Pvr_GetTrackingMode();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr GetRenderEventFunc();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void UnityEventData(long data);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_EnableSinglePass(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_SetAntiAliasing(int antiAliasing);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_SinglePassBeforeForwardOpaque();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_SetCurrentRenderTexture(uint textureId);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_SetSinglePassDepthBufferWidthHeight(int width, int height);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int PVR_setPerformanceLevels(int cpuLevel, int gpuLevel);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_SetIPD(float distance);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern float Pvr_GetIPD();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_SetTrackingIPDEnabled(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_GetTrackingIPDEnabled();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_GetEyeTrackingAutoIPD(ref float autoIPD);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int PVR_GetHmdAudioStatus();

		public static bool UPvr_CallStaticMethod<T>(ref T result, AndroidJavaClass jclass, string name, params object[] args)
		{
			try
			{
				result = jclass.CallStatic<T>(name, args);
				return true;
			}
			catch (AndroidJavaException ex)
			{
				PLOG.E("Exception calling static method " + name + ": " + ex);
				return false;
			}
		}

		public static bool UPvr_CallStaticMethod(AndroidJavaObject jobj, string name, params object[] args)
		{
			try
			{
				jobj.CallStatic(name, args);
				return true;
			}
			catch (AndroidJavaException ex)
			{
				PLOG.E("CallStaticMethod  Exception calling activity method " + name + ": " + ex);
				return false;
			}
		}

		public static bool UPvr_CallMethod<T>(ref T result, AndroidJavaObject jobj, string name, params object[] args)
		{
			try
			{
				result = jobj.Call<T>(name, args);
				return true;
			}
			catch (AndroidJavaException ex)
			{
				PLOG.E("Exception calling activity method " + name + ": " + ex);
				return false;
			}
		}

		public static bool UPvr_CallMethod(AndroidJavaObject jobj, string name, params object[] args)
		{
			try
			{
				jobj.Call(name, args);
				return true;
			}
			catch (AndroidJavaException ex)
			{
				PLOG.E(" Exception calling activity method " + name + ": " + ex);
				return false;
			}
		}

		public static string UPvr_GetSDKVersion()
		{
			IntPtr intPtr = Pvr_GetSDKVersion();
			if (intPtr != IntPtr.Zero)
			{
				return Marshal.PtrToStringAnsi(intPtr);
			}
			return "";
		}

		public static string UPvr_GetUnitySDKVersion()
		{
			return "2.8.9.12";
		}

		public static string UPvr_GetDeviceMode()
		{
			return SystemInfo.deviceModel;
		}

		public static string UPvr_GetDeviceModel()
		{
			return SystemInfo.deviceModel;
		}

		public static string UPvr_GetDeviceSN()
		{
			string result = "UNKONWN";
			UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaSysActivityClass, "getDeviceSN");
			return result;
		}

		public static AndroidJavaObject UPvr_GetCurrentActivity()
		{
			return new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		}

		public static bool UPvr_SetMonoPresentation()
		{
			return UPvr_CallMethod(UPvr_GetCurrentActivity(), "Pvr_setMonoPresentation");
		}

		public static bool UPvr_IsPresentationExisted()
		{
			bool result = false;
			return UPvr_CallMethod(ref result, UPvr_GetCurrentActivity(), "Pvr_isPresentationExisted") && result;
		}

		public static bool UPvr_GetMainActivityPauseStatus()
		{
			bool result = false;
			return UPvr_CallMethod(ref result, UPvr_GetCurrentActivity(), "Pvr_getMainActivityPauseStatus") && result;
		}

		public static void UPvr_Sleep()
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaSysActivityClass, "Pvr_Sleep");
		}

		public static bool UPvr_StartHomeKeyReceiver(string startreceivre)
		{
			try
			{
				if (Pvr_UnitySDKRender.Instance != null)
				{
					UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityLongReceiver, "Pvr_StartReceiver", Pvr_UnitySDKRender.Instance.activity, startreceivre);
					PLOG.I("Start home key Receiver");
					return true;
				}
			}
			catch (Exception ex)
			{
				PLOG.E("Start home key  Receiver  Error :" + ex.ToString());
				return false;
			}
			return true;
		}

		public static bool UPvr_StopHomeKeyReceiver()
		{
			try
			{
				if (Pvr_UnitySDKRender.Instance != null)
				{
					UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityLongReceiver, "Pvr_StopReceiver", Pvr_UnitySDKRender.Instance.activity);
					PLOG.I("Stop home key Receiver");
					return true;
				}
			}
			catch (Exception ex)
			{
				PLOG.E("Stop home key Receiver Error :" + ex.ToString());
				return false;
			}
			return true;
		}

		public static void UPvr_StartVRModel()
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityClass, "startVRModel");
		}

		public static void UPvr_RemovePlatformLogo()
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityClass, "removePlatformLogo");
		}

		public static void UPvr_ShowPlatformLogo()
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityClass, "showPlatformLogo");
		}

		public static bool UPvr_IsPicoActivity()
		{
			bool result = false;
			return UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "isPicoActivity", UPvr_GetCurrentActivity()) && result;
		}

		public static void UPvr_StopVRModel()
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityClass, "stopVRModel");
		}

		public static string UPvr_GetCountryCode()
		{
			string result = "";
			UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getCountryCode", UPvr_GetCurrentActivity());
			return result;
		}

		public static bool UPvr_SetIPD(float distance)
		{
			bool flag = false;
			flag = Pvr_SetIPD(distance);
			if (flag)
			{
				for (int i = 0; i < Pvr_UnitySDKEyeManager.Instance.Eyes.Length; i++)
				{
					Pvr_UnitySDKEyeManager.Instance.Eyes[i].RefreshCameraPosition(distance);
				}
			}
			return flag;
		}

		public static float UPvr_GetIPD()
		{
			float num = Pvr_GetIPD();
			UnityEngine.Debug.Log("DISFT IPD:" + num);
			return num;
		}

		public static bool UPvr_SetTrackingIPDEnabled(bool enable)
		{
			return Pvr_SetTrackingIPDEnabled(enable);
		}

		public static bool UPvr_GetTrackingIPDEnabled()
		{
			return Pvr_GetTrackingIPDEnabled();
		}

		public static bool UPvr_GetEyeTrackingAutoIPD(ref float autoipd)
		{
			return Pvr_GetEyeTrackingAutoIPD(ref autoipd);
		}

		public static void UPvr_UnityEventData(long data)
		{
			UnityEventData(data);
		}

		public static long UPvr_GetEyeBufferData(int id)
		{
			return ((long)Pvr_UnitySDKRender.Instance.RenderviewNumber << 32) | id;
		}

		public static bool UPvr_checkDevice(string packagename)
		{
			bool result = false;
			UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "checkDevice", packagename, UPvr_GetCurrentActivity());
			return result;
		}

		public static int UPvr_GetHmdHardwareVersion()
		{
			return Pvr_GetHmdHardwareVersion();
		}

		public static string UPvr_GetHmdFirmwareVersion()
		{
			IntPtr intPtr = Pvr_GetHmdFirmwareVersion();
			if (intPtr != IntPtr.Zero)
			{
				return Marshal.PtrToStringAnsi(intPtr);
			}
			return "";
		}

		public static string UPvr_GetHmdSerialNumber()
		{
			IntPtr intPtr = Pvr_GetHmdSerialNumber();
			if (intPtr != IntPtr.Zero)
			{
				return Marshal.PtrToStringAnsi(intPtr);
			}
			return "";
		}

		public static int UPvr_GetHmdBatteryStatus()
		{
			return PVR_GetHmdBatteryStatus();
		}

		public static float UPvr_GetHmdBatteryTemperature()
		{
			return PVR_GetHmdBatteryTemperature();
		}

		public static int UPvr_SetHmdAudioStatus(bool enable)
		{
			return PVR_SetHmdAudioStatus(enable);
		}

		public static int UPvr_GetTrackingMode()
		{
			return Pvr_GetTrackingMode();
		}

		public static bool UPvr_setTrackingMode(int trackingMode)
		{
			return Pvr_SetTrackingMode(trackingMode);
		}

		public static bool UPvr_getEyeTrackingData(ref EyeTrackingData trackingData)
		{
			if (!Pvr_UnitySDKEyeManager.supportEyeTracking)
			{
				PLOG.E("The device is not supported");
				return false;
			}
			if (!Pvr_UnitySDKEyeManager.Instance.EyeTracking)
			{
				PLOG.E("Please Enable \"Pvr_UnitySDK/Head/Pvr_UnitySDKEyeManager.cs/EyeTracking\"option first.");
				return false;
			}
			bool result = Pvr_GetEyeTrackingData(ref trackingData.leftEyePoseStatus, ref trackingData.rightEyePoseStatus, ref trackingData.combinedEyePoseStatus, ref trackingData.leftEyeGazePoint.x, ref trackingData.leftEyeGazePoint.y, ref trackingData.leftEyeGazePoint.z, ref trackingData.rightEyeGazePoint.x, ref trackingData.rightEyeGazePoint.y, ref trackingData.rightEyeGazePoint.z, ref trackingData.combinedEyeGazePoint.x, ref trackingData.combinedEyeGazePoint.y, ref trackingData.combinedEyeGazePoint.z, ref trackingData.leftEyeGazeVector.x, ref trackingData.leftEyeGazeVector.y, ref trackingData.leftEyeGazeVector.z, ref trackingData.rightEyeGazeVector.x, ref trackingData.rightEyeGazeVector.y, ref trackingData.rightEyeGazeVector.z, ref trackingData.combinedEyeGazeVector.x, ref trackingData.combinedEyeGazeVector.y, ref trackingData.combinedEyeGazeVector.z, ref trackingData.leftEyeOpenness, ref trackingData.rightEyeOpenness, ref trackingData.leftEyePupilDilation, ref trackingData.rightEyePupilDilation, ref trackingData.leftEyePositionGuide.x, ref trackingData.leftEyePositionGuide.y, ref trackingData.leftEyePositionGuide.z, ref trackingData.rightEyePositionGuide.x, ref trackingData.rightEyePositionGuide.y, ref trackingData.rightEyePositionGuide.z, ref trackingData.foveatedGazeDirection.x, ref trackingData.foveatedGazeDirection.y, ref trackingData.foveatedGazeDirection.z, ref trackingData.foveatedGazeTrackingState);
			trackingData.leftEyeGazeVector.z = 0f - trackingData.leftEyeGazeVector.z;
			trackingData.rightEyeGazeVector.z = 0f - trackingData.rightEyeGazeVector.z;
			trackingData.combinedEyeGazeVector.z = 0f - trackingData.combinedEyeGazeVector.z;
			trackingData.leftEyeGazePoint.z = 0f - trackingData.leftEyeGazePoint.z;
			trackingData.rightEyeGazePoint.z = 0f - trackingData.rightEyeGazePoint.z;
			trackingData.combinedEyeGazePoint.z = 0f - trackingData.combinedEyeGazePoint.z;
			trackingData.foveatedGazeDirection.z = 0f - trackingData.foveatedGazeDirection.z;
			return result;
		}

		public static bool UPvr_getEyeTrackingGazeRay(ref EyeTrackingGazeRay gazeRay)
		{
			if (!Pvr_UnitySDKEyeManager.supportEyeTracking)
			{
				PLOG.E("The device is not supported");
				return false;
			}
			if (!Pvr_UnitySDKEyeManager.Instance.EyeTracking)
			{
				PLOG.E("Please Enable \"Pvr_UnitySDK/Head/Pvr_UnitySDKEyeManager.cs/EyeTracking\"option first.");
				return false;
			}
			EyeTrackingData trackingData = default(EyeTrackingData);
			UPvr_getEyeTrackingData(ref trackingData);
			gazeRay.IsValid = ((uint)trackingData.combinedEyePoseStatus & (true ? 1u : 0u)) != 0 && (trackingData.combinedEyePoseStatus & 2) != 0;
			if (gazeRay.IsValid)
			{
				gazeRay.Direction = trackingData.combinedEyeGazeVector;
				gazeRay.Origin = trackingData.combinedEyeGazePoint;
				gazeRay.Origin = Pvr_UnitySDKSensor.Instance.HeadPose.Matrix.MultiplyPoint(gazeRay.Origin);
				gazeRay.Direction = Pvr_UnitySDKSensor.Instance.HeadPose.Matrix.MultiplyVector(gazeRay.Direction);
				return true;
			}
			return false;
		}

		public static bool UPvr_getEyeTrackingGazeRayWorld(ref EyeTrackingGazeRay gazeRay)
		{
			if (!Pvr_UnitySDKEyeManager.supportEyeTracking)
			{
				PLOG.E("The device is not supported");
				return false;
			}
			if (!Pvr_UnitySDKEyeManager.Instance.EyeTracking)
			{
				PLOG.E("Please Enable \"Pvr_UnitySDK/Head/Pvr_UnitySDKEyeManager.cs/EyeTracking\"option first.");
				return false;
			}
			Transform transform = Pvr_UnitySDKEyeManager.Instance.transform;
			Matrix4x4 matrix4x = Matrix4x4.TRS(transform.position, transform.rotation, Vector3.one);
			EyeTrackingData trackingData = default(EyeTrackingData);
			UPvr_getEyeTrackingData(ref trackingData);
			gazeRay.IsValid = ((uint)trackingData.combinedEyePoseStatus & (true ? 1u : 0u)) != 0 && (trackingData.combinedEyePoseStatus & 2) != 0;
			if (gazeRay.IsValid)
			{
				gazeRay.Direction = trackingData.combinedEyeGazeVector;
				gazeRay.Origin = trackingData.combinedEyeGazePoint;
				gazeRay.Origin = matrix4x.MultiplyPoint(gazeRay.Origin);
				gazeRay.Direction = matrix4x.MultiplyVector(gazeRay.Direction);
				return true;
			}
			return false;
		}

		public static Vector3 UPvr_getEyeTrackingPos()
		{
			if (!Pvr_UnitySDKEyeManager.supportEyeTracking)
			{
				PLOG.E("The device is not supported");
				return Vector3.zero;
			}
			if (!Pvr_UnitySDKEyeManager.Instance.EyeTracking)
			{
				PLOG.E("Please Enable \"Pvr_UnitySDK/Head/Pvr_UnitySDKEyeManager.cs/EyeTracking\"option first.");
				return Vector3.zero;
			}
			return Pvr_UnitySDKEyeManager.Instance.GetEyeTrackingPos();
		}

		public static int UPvr_GetPhoneScreenBrightness()
		{
			int result = 0;
			UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClientClass, "Pvr_GetScreen_Brightness", UPvr_GetCurrentActivity());
			return result;
		}

		public static void UPvr_SetPhoneScreenBrightness(int level)
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityClientClass, "Pvr_setAPPScreen_Brightness", UPvr_GetCurrentActivity(), level);
		}

		public static bool UPvr_IsPicoDefaultActivity()
		{
			using (AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer"))
			{
				using AndroidJavaObject androidJavaObject = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
				if (androidJavaObject.Call<string>("getLocalClassName", Array.Empty<object>()) == "com.unity3d.player.UnityPlayerNativeActivityPico")
				{
					return true;
				}
			}
			return false;
		}

		public static bool UPvr_EnableSinglePass(bool enable)
		{
			return Pvr_EnableSinglePass(enable);
		}

		public static void UPvr_SetAntiAliasing(int antiAliasing)
		{
			Pvr_SetAntiAliasing(antiAliasing);
		}

		public static void UPvr_SinglePassBeforeForwardOpaque()
		{
			Pvr_SinglePassBeforeForwardOpaque();
		}

		public static void UPvr_SetCurrentRenderTexture(uint textureId)
		{
			Pvr_SetCurrentRenderTexture(textureId);
		}

		public static bool UPvr_SetSinglePassDepthBufferWidthHeight(int width, int height)
		{
			return Pvr_SetSinglePassDepthBufferWidthHeight(width, height);
		}

		public static int UPVR_setPerformanceLevels(int cpuLevel, int gpuLevel)
		{
			return PVR_setPerformanceLevels(cpuLevel, gpuLevel);
		}

		public static int UPvr_GetColorRes(string name)
		{
			int result = -1;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getColorRes", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetColorResError :" + ex.ToString());
			}
			return result;
		}

		public static int UPvr_GetConfigInt(string name)
		{
			int result = -1;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getConfigInt", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetConfigIntError :" + ex.ToString());
			}
			return result;
		}

		public static string UPvr_GetConfigString(string name)
		{
			string result = "";
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getConfigString", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetConfigStringError :" + ex.ToString());
			}
			return result;
		}

		public static string UPvr_GetDrawableLocation(string name)
		{
			string result = "";
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getDrawableLocation", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetDrawableLocationError :" + ex.ToString());
			}
			return result;
		}

		public static int UPvr_GetTextSize(string name)
		{
			int result = -1;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getTextSize", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetTextSizeError :" + ex.ToString());
			}
			return result;
		}

		public static string UPvr_GetLangString(string name)
		{
			string result = "";
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getLangString", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetLangStringError :" + ex.ToString());
			}
			return result;
		}

		public static string UPvr_GetStringValue(string id, int type)
		{
			string result = "";
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getStringValue", id, type);
			}
			catch (Exception ex)
			{
				PLOG.E("GetStringValueError :" + ex.ToString());
			}
			return result;
		}

		public static int UPvr_GetIntValue(string id, int type)
		{
			int result = -1;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getIntValue", id, type);
			}
			catch (Exception ex)
			{
				PLOG.E("GetIntValueError :" + ex.ToString());
			}
			return result;
		}

		public static float UPvr_GetFloatValue(string id)
		{
			float result = -1f;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getFloatValue", id);
			}
			catch (Exception ex)
			{
				PLOG.E("GetFloatValueError :" + ex.ToString());
			}
			return result;
		}

		public static string UPvr_GetObjectOrArray(string id, int type)
		{
			string result = "";
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getObjectOrArray", id, type);
			}
			catch (Exception ex)
			{
				PLOG.E("GetObjectOrArrayError :" + ex.ToString());
			}
			return result;
		}

		public static int UPvr_GetCharSpace(string id)
		{
			int result = -1;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getCharSpace", id);
			}
			catch (Exception ex)
			{
				PLOG.E("GetCharSpaceError :" + ex.ToString());
			}
			return result;
		}
	}
	public struct BoundarySystem
	{
		public enum BoundaryType
		{
			OuterBoundary,
			PlayArea
		}

		public struct BoundaryTestResult
		{
			public bool IsTriggering;

			public float ClosestDistance;

			public Vector3 ClosestPoint;

			public Vector3 ClosestPointNormal;
		}

		public enum BoundaryTrackingNode
		{
			HandLeft,
			HandRight,
			Head
		}

		public enum BoundaryTrackingState
		{
			PVR_NOREASON,
			PVRRELOCATION_IN_PROGRESS,
			PVRLOW_FEATURE_COUNT_ERROR,
			PVRLOW_LIGHT_ERROR,
			PVRBRIGHT_LIGHT_ERROR,
			PVRSTEREO_CAMERA_CALIBRATION_ERROR
		}

		public const string LibFileName = "Pvr_UnitySDK";

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern float Pvr_GetFloorHeight();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetSeeThroughState();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_BoundarySetSTBackground(bool value);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetTrackingState();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_GetFrameRateLimit();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_IsBoundaryEnable();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_BoundaryGetConfigured();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_BoundaryTestNode(int node, bool isPlayArea, ref bool isTriggering, ref float closestDistance, ref float px, ref float py, ref float pz, ref float nx, ref float ny, ref float nz);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_BoundaryTestPoint(float x, float y, float z, bool isPlayArea, ref bool isTriggering, ref float closestDistance, ref float px, ref float py, ref float pz, ref float nx, ref float ny, ref float nz);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_BoundaryGetGeometry(out IntPtr handle, bool isPlayArea);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_BoundaryGetDimensions(ref float x, ref float y, ref float z, bool isPlayArea);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_BoundaryGetEnabled();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_BoundarySetVisible(bool value);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_BoundaryGetVisible();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_EnableLWRP(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_SetViewportSize(int w, int h);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_BoundarySetSeeThroughVisible(bool value);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void PVR_SetCameraImageRect(int width, int height);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetGuardianSystemDisable(bool value);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetDialogState();

		public static float UPvr_GetFloorHeight()
		{
			return Pvr_GetFloorHeight();
		}

		public static int UPvr_GetSeeThroughState()
		{
			return Pvr_GetSeeThroughState();
		}

		public static void UPvr_EnableSeeThroughManual(bool enable)
		{
			Pvr_BoundarySetSTBackground(enable);
		}

		public static BoundaryTrackingState UPvr_GetTrackingState()
		{
			return (BoundaryTrackingState)Pvr_GetTrackingState();
		}

		public static bool UPvr_GetFrameRateLimit()
		{
			return Pvr_GetFrameRateLimit();
		}

		public static bool UPvr_IsBoundaryEnable()
		{
			return Pvr_IsBoundaryEnable();
		}

		public static bool UPvr_BoundaryGetConfigured()
		{
			return Pvr_BoundaryGetConfigured();
		}

		public static BoundaryTestResult UPvr_BoundaryTestNode(BoundaryTrackingNode node, BoundaryType boundaryType)
		{
			BoundaryTestResult result = default(BoundaryTestResult);
			bool num = Pvr_BoundaryTestNode((int)node, boundaryType == BoundaryType.PlayArea, ref result.IsTriggering, ref result.ClosestDistance, ref result.ClosestPoint.x, ref result.ClosestPoint.y, ref result.ClosestPoint.z, ref result.ClosestPointNormal.x, ref result.ClosestPointNormal.y, ref result.ClosestPointNormal.z);
			result.ClosestPoint.z = 0f - result.ClosestPoint.z;
			result.ClosestPointNormal.z = 0f - result.ClosestPointNormal.z;
			if (!num)
			{
				UnityEngine.Debug.LogError($"UPvr_BoundaryTestNode({node}, {boundaryType}) API call failed!");
			}
			return result;
		}

		public static BoundaryTestResult UPvr_BoundaryTestPoint(Vector3 point, BoundaryType boundaryType)
		{
			BoundaryTestResult result = default(BoundaryTestResult);
			if (!Pvr_BoundaryTestPoint(point.x, point.y, 0f - point.z, boundaryType == BoundaryType.PlayArea, ref result.IsTriggering, ref result.ClosestDistance, ref result.ClosestPoint.x, ref result.ClosestPoint.y, ref result.ClosestPoint.z, ref result.ClosestPointNormal.x, ref result.ClosestPointNormal.y, ref result.ClosestPointNormal.z))
			{
				UnityEngine.Debug.LogError($"UPvr_BoundaryTestPoint({point}, {boundaryType}) API call failed!");
			}
			return result;
		}

		public static Vector3[] UPvr_BoundaryGetGeometry(BoundaryType boundaryType)
		{
			IntPtr handle = IntPtr.Zero;
			int num = Pvr_BoundaryGetGeometry(out handle, boundaryType == BoundaryType.PlayArea);
			if (num <= 0)
			{
				UnityEngine.Debug.LogError("Boundary geometry point count is " + num);
				return null;
			}
			int num2 = num * 3;
			float[] array = new float[num2];
			Marshal.Copy(handle, array, 0, num2);
			Vector3[] array2 = new Vector3[num];
			for (int i = 0; i < num; i++)
			{
				array2[i] = new Vector3
				{
					x = array[3 * i],
					y = array[3 * i + 1],
					z = 0f - array[3 * i + 2]
				};
			}
			return array2;
		}

		public static Vector3 UPvr_BoundaryGetDimensions(BoundaryType boundaryType)
		{
			float x = 0f;
			float y = 0f;
			float z = 0f;
			Pvr_BoundaryGetDimensions(ref x, ref y, ref z, boundaryType == BoundaryType.PlayArea);
			return new Vector3(x, y, z);
		}

		public static bool UPvr_BoundaryGetEnabled()
		{
			return Pvr_BoundaryGetEnabled();
		}

		public static void UPvr_BoundarySetVisible(bool value)
		{
			Pvr_BoundarySetVisible(value);
		}

		public static bool UPvr_BoundaryGetVisible()
		{
			return Pvr_BoundaryGetVisible();
		}

		public static bool UPvr_EnableLWRP(bool enable)
		{
			return Pvr_EnableLWRP(enable);
		}

		public static bool UPvr_SetViewportSize(int width, int height)
		{
			return Pvr_SetViewportSize(width, height);
		}

		public static void UPvr_StartCameraFrame()
		{
			try
			{
				Pvr_UnitySDKPluginEvent.Issue(RenderEventType.StartCameraFrame);
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_StartCameraFrame :" + ex.ToString());
			}
		}

		public static void UPvr_StopCameraFrame()
		{
			try
			{
				Pvr_UnitySDKPluginEvent.Issue(RenderEventType.StopCameraFrame);
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_StopCameraFrame :" + ex.ToString());
			}
		}

		public static void UPvr_BoundaryGetSeeThroughData(int cameraIndex, RenderTexture renderTexture)
		{
			try
			{
				if (renderTexture.IsCreated())
				{
					System.UPvr_UnityEventData(renderTexture.GetNativeTexturePtr().ToInt32());
					switch (cameraIndex)
					{
					case 0:
						Pvr_UnitySDKPluginEvent.Issue(RenderEventType.CameraFrameLeft);
						break;
					case 1:
						Pvr_UnitySDKPluginEvent.Issue(RenderEventType.CameraFrameRight);
						break;
					}
				}
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_BoundaryGetSeeThroughDataError :" + ex.ToString());
			}
		}

		public static void UPvr_BoundarySetCameraImageRect(int width, int height)
		{
			try
			{
				PVR_SetCameraImageRect(width, height);
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_BoundarySetCameraImageRectError :" + ex.ToString());
			}
		}

		public static void UPvr_BoundarySetSeeThroughVisible(bool value)
		{
			try
			{
				Pvr_BoundarySetSeeThroughVisible(value);
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_BoundarySetSeeThroughVisibleError :" + ex.ToString());
			}
		}

		public static void UPvr_SetGuardianSystemDisable(bool value)
		{
			try
			{
				Pvr_SetGuardianSystemDisable(value);
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_SetGuardianSystemDisableError :" + ex.ToString());
			}
		}

		public static int UPvr_GetDialogState()
		{
			int result = 0;
			try
			{
				result = Pvr_GetDialogState();
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_GetDialogStateError :" + ex.ToString());
			}
			return result;
		}
	}
	public struct PlatformSettings
	{
		public static Pvr_UnitySDKPlatformSetting.simulationType UPvr_IsCurrentDeviceValid()
		{
			if (Pvr_UnitySDKPlatformSetting.Entitlementchecksimulation)
			{
				if (Pvr_UnitySDKPlatformSetting.Instance.deviceSN.Count <= 0)
				{
					UnityEngine.Debug.Log("DISFT Entitlement Check Simulation deviceSN is Null");
					return Pvr_UnitySDKPlatformSetting.simulationType.Null;
				}
				foreach (string item in Pvr_UnitySDKPlatformSetting.Instance.deviceSN)
				{
					if (System.UPvr_GetDeviceSN() == item)
					{
						return Pvr_UnitySDKPlatformSetting.simulationType.Valid;
					}
				}
				UnityEngine.Debug.Log("DISFT Entitlement Check Simulation deviceSN is Invalid");
				return Pvr_UnitySDKPlatformSetting.simulationType.Invalid;
			}
			UnityEngine.Debug.Log("DISFT Entitlement Check Simulation DO NOT Enable");
			return Pvr_UnitySDKPlatformSetting.simulationType.Invalid;
		}

		[Obsolete("This API will be removed in later versions")]
		public static bool UPvr_KeyEntitlementCheck(string publicKey)
		{
			bool result = false;
			try
			{
				System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "verifyAPP", System.UPvr_GetCurrentActivity(), "", publicKey);
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
			UnityEngine.Debug.Log("PvrLog UPvr_KeyEntitlementCheck" + result);
			return result;
		}

		public static int UPvr_GetHmdAudioStatus()
		{
			return System.PVR_GetHmdAudioStatus();
		}
	}
	public enum DeviceCommand
	{
		SET_PICO_NEO_HMD_BRIGHTNESS = 12,
		SET_PICO_NEO_HMD_SLEEPDELAY
	}
	public enum BrightnessLevel
	{
		VR_BRIGHTNESS_LEVEL_MIN = 1,
		VR_BRIGHTNESS_LEVEL_MAX = 100,
		VR_BRIGHTNESS_LEVEL_DOWN = 1000,
		VR_BRIGHTNESS_LEVEL_UP = 1001,
		VR_BRIGHTNESS_LEVEL_SCREEN_OFF = -100
	}
	public struct VolumePowerBrightness
	{
		public const string LibFileName = "Pvr_UnitySDK";

		public AndroidJavaObject activity;

		public static AndroidJavaClass javaSysActivityClass;

		private static AndroidJavaClass batteryjavaVrActivityClass;

		private static AndroidJavaClass volumejavaVrActivityClass;

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_SetInitActivity(IntPtr activity, IntPtr vrActivityClass);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_IsHmdExist();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetHmdScreenBrightness();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_SetHmdScreenBrightness(int brightness);

		public static bool UPvr_IsHmdExist()
		{
			return Pvr_IsHmdExist();
		}

		public static int UPvr_GetHmdScreenBrightness()
		{
			return Pvr_GetHmdScreenBrightness();
		}

		public static bool UPvr_SetHmdScreenBrightness(int brightness)
		{
			return Pvr_SetHmdScreenBrightness(brightness);
		}

		public static bool UPvr_SetCommonBrightness(int brightness)
		{
			bool flag = false;
			if (UPvr_IsHmdExist())
			{
				return UPvr_SetHmdScreenBrightness(brightness);
			}
			return UPvr_SetBrightness(brightness);
		}

		public static int UPvr_GetCommonBrightness()
		{
			int num = 0;
			if (UPvr_IsHmdExist())
			{
				return UPvr_GetHmdScreenBrightness();
			}
			return UPvr_GetCurrentBrightness();
		}

		public static int[] UPvr_GetScreenBrightnessLevel()
		{
			return Pvr_GetScreenBrightnessLevel();
		}

		public static void UPvr_SetScreenBrightnessLevel(int vrBrightness, int level)
		{
			Pvr_SetScreenBrightnessLevel(vrBrightness, level);
		}

		public static bool UPvr_SetDevicePropForUser(DeviceCommand deviceid, string number)
		{
			return setDevicePropForUser(deviceid, number);
		}

		public static string UPvr_GetDevicePropForUser(DeviceCommand deviceid)
		{
			return getDevicePropForUser(deviceid);
		}

		public static bool UPvr_InitBatteryClass()
		{
			try
			{
				if (javaSysActivityClass == null)
				{
					javaSysActivityClass = new AndroidJavaClass("com.psmart.aosoperation.SysActivity");
				}
				if (javaSysActivityClass != null && Pvr_UnitySDKRender.Instance.activity != null)
				{
					if (batteryjavaVrActivityClass == null)
					{
						batteryjavaVrActivityClass = new AndroidJavaClass("com.psmart.aosoperation.BatteryReceiver");
					}
					return true;
				}
				return false;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_InitBatteryVolClass()
		{
			try
			{
				javaSysActivityClass = new AndroidJavaClass("com.psmart.aosoperation.SysActivity");
				if (javaSysActivityClass != null && Pvr_UnitySDKRender.Instance.activity != null)
				{
					batteryjavaVrActivityClass = new AndroidJavaClass("com.psmart.aosoperation.BatteryReceiver");
					volumejavaVrActivityClass = new AndroidJavaClass("com.psmart.aosoperation.AudioReceiver");
					System.UPvr_CallStaticMethod(javaSysActivityClass, "Pvr_InitAudioDevice", Pvr_UnitySDKRender.Instance.activity);
					return true;
				}
				return false;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_StartBatteryReceiver(string startreceivre)
		{
			try
			{
				System.UPvr_CallStaticMethod(batteryjavaVrActivityClass, "Pvr_StartReceiver", Pvr_UnitySDKRender.Instance.activity, startreceivre);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_StopBatteryReceiver()
		{
			try
			{
				System.UPvr_CallStaticMethod(batteryjavaVrActivityClass, "Pvr_StopReceiver", Pvr_UnitySDKRender.Instance.activity);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_SetBrightness(int brightness)
		{
			try
			{
				System.UPvr_CallStaticMethod(javaSysActivityClass, "Pvr_SetScreen_Brightness", brightness, Pvr_UnitySDKRender.Instance.activity);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
				return false;
			}
		}

		public static int UPvr_GetCurrentBrightness()
		{
			int result = 0;
			try
			{
				System.UPvr_CallStaticMethod(ref result, javaSysActivityClass, "Pvr_GetScreen_Brightness", Pvr_UnitySDKRender.Instance.activity);
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
			}
			return result;
		}

		public static int[] Pvr_GetScreenBrightnessLevel()
		{
			int[] result = new int[1];
			try
			{
				System.UPvr_CallStaticMethod(ref result, javaSysActivityClass, "getScreenBrightnessLevel");
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
			}
			return result;
		}

		public static void Pvr_SetScreenBrightnessLevel(int vrBrightness, int level)
		{
			try
			{
				System.UPvr_CallStaticMethod(javaSysActivityClass, "setScreenBrightnessLevel", vrBrightness, level);
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
			}
		}

		public static bool UPvr_StartAudioReceiver(string startreceivre)
		{
			try
			{
				System.UPvr_CallStaticMethod(volumejavaVrActivityClass, "Pvr_StartReceiver", Pvr_UnitySDKRender.Instance.activity, startreceivre);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_StopAudioReceiver()
		{
			try
			{
				System.UPvr_CallStaticMethod(volumejavaVrActivityClass, "Pvr_StopReceiver", Pvr_UnitySDKRender.Instance.activity);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static int UPvr_GetMaxVolumeNumber()
		{
			int result = 0;
			try
			{
				System.UPvr_CallStaticMethod(ref result, javaSysActivityClass, "Pvr_GetMaxAudionumber");
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
			}
			return result;
		}

		public static int UPvr_GetCurrentVolumeNumber()
		{
			int result = 0;
			try
			{
				System.UPvr_CallStaticMethod(ref result, javaSysActivityClass, "Pvr_GetAudionumber");
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
			}
			return result;
		}

		public static bool UPvr_VolumeUp()
		{
			try
			{
				System.UPvr_CallStaticMethod(javaSysActivityClass, "Pvr_UpAudio");
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_VolumeDown()
		{
			try
			{
				System.UPvr_CallStaticMethod(javaSysActivityClass, "Pvr_DownAudio");
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_SetVolumeNum(int volume)
		{
			try
			{
				System.UPvr_CallStaticMethod(javaSysActivityClass, "Pvr_ChangeAudio", volume);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_SetAudio(string s)
		{
			return false;
		}

		public static bool UPvr_SetBattery(string s)
		{
			return false;
		}

		private static string getDevicePropForUser(DeviceCommand deviceid)
		{
			string result = "0";
			System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getDevicePropForUser", (int)deviceid);
			return result;
		}

		private static bool setDevicePropForUser(DeviceCommand deviceid, string number)
		{
			bool result = false;
			System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "setDevicePropForUser", (int)deviceid, number);
			return result;
		}
	}
}
namespace Pvr_UnitySDKAPI.Achievement
{
	public sealed class AchievementCore
	{
		private static bool IsPlatformInitialized = true;

		public static bool LogMessages = false;

		public static bool IsInitialized()
		{
			return IsPlatformInitialized;
		}

		public static void Initialize()
		{
		}

		public static void RegisterNetwork()
		{
			Pvr_AchievementAPI.RegisterNetwork();
		}

		public static void UnRegisterNetwork()
		{
			Pvr_AchievementAPI.UnRegisterNetwork();
		}
	}
	public static class Achievements
	{
		public static Pvr_Request<Pvr_AchievementUpdate> Init()
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementUpdate>(Pvr_AchievementAPI.Init());
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementUpdate> AddCount(string name, long count)
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementUpdate>(Pvr_AchievementAPI.pvr_Achievements_AddCount(name, count));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementUpdate> AddFields(string name, string fields)
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementUpdate>(Pvr_AchievementAPI.pvr_Achievements_AddFields(name, fields));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementDefinitionList> GetAllDefinitions()
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementDefinitionList>(Pvr_AchievementAPI.pvr_Achievements_GetAllDefinitions());
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementProgressList> GetAllProgress()
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementProgressList>(Pvr_AchievementAPI.pvr_Achievements_GetAllProgress());
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementDefinitionList> GetDefinitionsByName(string[] names)
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementDefinitionList>(Pvr_AchievementAPI.pvr_Achievements_GetDefinitionsByName(names, (names != null) ? names.Length : 0));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementProgressList> GetProgressByName(string[] names)
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementProgressList>(Pvr_AchievementAPI.pvr_Achievements_GetProgressByName(names, (names != null) ? names.Length : 0));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementUpdate> Unlock(string name)
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementUpdate>(Pvr_AchievementAPI.pvr_Achievements_Unlock(name));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementDefinitionList> GetNextAchievementDefinitionListPage(Pvr_AchievementDefinitionList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Platform.GetNextAchievementDefinitionListPage: List has no next page");
				return null;
			}
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementDefinitionList>(Pvr_AchievementAPI.pvr_HTTP_GetWithMessageType(list.NextUrl, Pvr_Message.MessageType.Achievements_GetNextAchievementDefinitionArrayPage));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementProgressList> GetNextAchievementProgressListPage(Pvr_AchievementProgressList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Platform.GetNextAchievementProgressListPage: List has no next page");
				return null;
			}
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementProgressList>(Pvr_AchievementAPI.pvr_HTTP_GetWithMessageType(list.NextUrl, Pvr_Message.MessageType.Achievements_GetNextAchievementProgressArrayPage));
			}
			return null;
		}
	}
	public enum AchievementType
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("SIMPLE")]
		Simple,
		[Description("BITFIELD")]
		Bitfield,
		[Description("COUNT")]
		Count
	}
	public class Pvr_AchievementAPI
	{
		private static AndroidJavaClass achievementAPI = new AndroidJavaClass("com.pico.achievenment.AchievementAPI");

		private static AndroidJavaClass definitionArrayHandle = new AndroidJavaClass("com.picovr.achievement.utils.pvrAchievementDefinitionArrayHandle");

		private static AndroidJavaClass definitionHandle = new AndroidJavaClass("com.picovr.achievement.utils.pvrAchievementDefinitionHandle");

		private static AndroidJavaClass progressArrayHandle = new AndroidJavaClass("com.picovr.achievement.utils.pvrAchievementProgressArrayHandle");

		private static AndroidJavaClass progressHandle = new AndroidJavaClass("com.picovr.achievement.utils.pvrAchievementProgressHandle");

		private static AndroidJavaClass updateHandle = new AndroidJavaClass("com.picovr.achievement.utils.pvrAchievementUpdateHandle");

		private static AndroidJavaObject errorHandle = new AndroidJavaObject("com.picovr.achievement.utils.pvrAchievementErrorHandle");

		private static AndroidJavaObject unityInterface = new AndroidJavaObject("com.pico.loginpaysdk.UnityInterface");

		private static string openId;

		private static string accessToken;

		private static string appId = Pvr_UnitySDKPlatformSetting.Instance.appID;

		internal static long Init()
		{
			AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
			unityInterface.Call("init", @static);
			unityInterface.Call("authSSO");
			AndroidJavaObject androidJavaObject = new AndroidJavaClass("com.pico.loginpaysdk.utils.PicoAccessTokenKeeper").CallStatic<AndroidJavaObject>("readAccessToken", new object[1] { @static });
			accessToken = androidJavaObject.Call<string>("getAccessToken", Array.Empty<object>());
			openId = androidJavaObject.Call<string>("getOpenId", Array.Empty<object>());
			return achievementAPI.CallStatic<long>("init", new object[3] { accessToken, openId, @static });
		}

		internal static void RegisterNetwork()
		{
			AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
			achievementAPI.CallStatic("registerNetwork", @static);
		}

		internal static void UnRegisterNetwork()
		{
			achievementAPI.CallStatic("unregisterNetwork");
		}

		internal static AndroidJavaObject PopMessage()
		{
			return achievementAPI.CallStatic<AndroidJavaObject>("pvr_PopMessage", Array.Empty<object>());
		}

		internal static string pvr_Error_GetMessage(AndroidJavaObject popMessage)
		{
			return errorHandle.CallStatic<string>("pvr_Error_GetMessage", new object[1] { popMessage });
		}

		internal static int pvr_Error_GetHttpCode(AndroidJavaObject popMessage)
		{
			return errorHandle.CallStatic<int>("pvr_Error_GetHttpCode", new object[1] { popMessage });
		}

		internal static int pvr_Error_GetCode(AndroidJavaObject popMessage)
		{
			return errorHandle.CallStatic<int>("pvr_Error_GetCode", new object[1] { popMessage });
		}

		internal static long pvr_Achievements_AddCount(string name, long count)
		{
			return achievementAPI.CallStatic<long>("pvr_Achievements_AddCount", new object[3] { name, count, accessToken });
		}

		internal static long pvr_Achievements_AddFields(string name, string fields)
		{
			return achievementAPI.CallStatic<long>("pvr_Achievements_AddFields", new object[3] { name, fields, accessToken });
		}

		internal static long pvr_Achievements_GetAllDefinitions()
		{
			AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
			return achievementAPI.CallStatic<long>("pvr_Achievements_GetAllDefinitions", new object[2] { appId, @static });
		}

		internal static long pvr_Achievements_GetAllProgress()
		{
			return achievementAPI.CallStatic<long>("pvr_Achievements_GetAllProgress", new object[1] { accessToken });
		}

		internal static long pvr_Achievements_GetDefinitionsByName(string[] names, int v)
		{
			AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
			return achievementAPI.CallStatic<long>("pvr_Achievements_GetDefinitionsByName", new object[2] { names, @static });
		}

		internal static long pvr_Achievements_GetProgressByName(string[] names, int v)
		{
			return achievementAPI.CallStatic<long>("pvr_Achievements_GetProgressByName", new object[2] { names, accessToken });
		}

		internal static long pvr_Achievements_Unlock(string name)
		{
			return achievementAPI.CallStatic<long>("pvr_Achievements_Unlock", new object[2] { name, accessToken });
		}

		internal static long pvr_HTTP_GetWithMessageType(string nextUrl, Pvr_Message.MessageType messageType)
		{
			long result = 0L;
			switch (messageType)
			{
			case Pvr_Message.MessageType.Achievements_GetNextAchievementDefinitionArrayPage:
			{
				AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
				result = achievementAPI.CallStatic<long>("pvr_Achievements_GetAllDefinitionsByUrl", new object[2] { nextUrl, @static });
				break;
			}
			case Pvr_Message.MessageType.Achievements_GetNextAchievementProgressArrayPage:
				result = achievementAPI.CallStatic<long>("pvr_Achievements_GetAllProgressByUrl", new object[1] { nextUrl });
				break;
			}
			return result;
		}

		internal static long pvr_Message_GetType(AndroidJavaObject popMessage)
		{
			return popMessage.Call<AndroidJavaObject>("getHandleType", Array.Empty<object>()).Call<long>("getIndex", Array.Empty<object>());
		}

		internal static bool pvr_Message_IsError(AndroidJavaObject popMessage)
		{
			return popMessage.Call<bool>("isMessage_IsError", Array.Empty<object>());
		}

		internal static long pvr_Message_GetRequestID(AndroidJavaObject popMessage)
		{
			return popMessage.Call<long>("getId", Array.Empty<object>());
		}

		internal static string pvr_Message_GetString(AndroidJavaObject popMessage)
		{
			return popMessage.Call<string>("getContent", Array.Empty<object>());
		}

		internal static bool pvr_AchievementUpdate_GetJustUnlocked(AndroidJavaObject popMessage)
		{
			return updateHandle.CallStatic<bool>("pvr_AchievementUpdate_GetJustUnlocked", new object[1] { popMessage });
		}

		internal static string pvr_AchievementUpdate_GetName(AndroidJavaObject popMessage)
		{
			return updateHandle.CallStatic<string>("pvr_AchievementUpdate_GetName", new object[1] { popMessage });
		}

		internal static int pvr_AchievementProgressArray_GetSize(AndroidJavaObject msg)
		{
			return progressArrayHandle.CallStatic<int>("pvr_AchievementProgressArray_GetSize", new object[1] { msg });
		}

		internal static AndroidJavaObject pvr_AchievementProgressArray_GetElement(AndroidJavaObject msg, int index)
		{
			return progressArrayHandle.CallStatic<AndroidJavaObject>("pvr_AchievementProgressArray_GetElement", new object[2] { msg, index });
		}

		internal static string pvr_AchievementProgressArray_GetNextUrl(AndroidJavaObject msg)
		{
			return progressArrayHandle.CallStatic<string>("pvr_AchievementProgressArray_GetNextUrl", new object[1] { msg });
		}

		internal static string pvr_AchievementProgress_GetBitfield(AndroidJavaObject msg)
		{
			return progressHandle.CallStatic<string>("pvr_AchievementProgress_GetBitfield", new object[1] { msg });
		}

		internal static long pvr_AchievementProgress_GetCount(AndroidJavaObject msg)
		{
			return progressHandle.CallStatic<long>("pvr_AchievementProgress_GetCount", new object[1] { msg });
		}

		internal static bool pvr_AchievementProgress_GetIsUnlocked(AndroidJavaObject msg)
		{
			return progressHandle.CallStatic<bool>("pvr_AchievementProgress_GetIsUnlocked", new object[1] { msg });
		}

		internal static string pvr_AchievementProgress_GetName(AndroidJavaObject msg)
		{
			return progressHandle.CallStatic<string>("pvr_AchievementProgress_GetName", new object[1] { msg });
		}

		internal static DateTime pvr_AchievementProgress_GetUnlockTime(AndroidJavaObject msg)
		{
			new DateTime(1970, 1, 1, 0, 0, 0, 0);
			return DateTimeFromNative(progressHandle.CallStatic<long>("pvr_AchievementProgress_GetUnlockTime", new object[1] { msg }));
		}

		internal static DateTime DateTimeFromNative(long seconds_since_the_one_true_epoch)
		{
			return new DateTime(1970, 1, 1, 0, 0, 0, 0).AddSeconds(seconds_since_the_one_true_epoch).ToLocalTime();
		}

		internal static int pvr_AchievementDefinitionArray_GetSize(AndroidJavaObject msg)
		{
			return definitionArrayHandle.CallStatic<int>("pvr_AchievementDefinitionArray_GetSize", new object[1] { msg });
		}

		internal static AndroidJavaObject pvr_AchievementDefinitionArray_GetElement(AndroidJavaObject msg, int index)
		{
			return definitionArrayHandle.CallStatic<AndroidJavaObject>("pvr_AchievementDefinitionArray_GetElement", new object[2] { msg, index });
		}

		internal static string pvr_AchievementDefinitionArray_GetNextUrl(AndroidJavaObject msg)
		{
			return definitionArrayHandle.CallStatic<string>("pvr_AchievementDefinitionArray_GetNextUrl", new object[1] { msg });
		}

		internal static AchievementType pvr_AchievementDefinition_GetType(AndroidJavaObject msg)
		{
			return (AchievementType)definitionHandle.CallStatic<AndroidJavaObject>("pvr_AchievementDefinition_GetType", new object[1] { msg }).Call<int>("getIndex", Array.Empty<object>());
		}

		internal static string pvr_AchievementDefinition_GetName(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetName", new object[1] { msg });
		}

		internal static int pvr_AchievementDefinition_GetBitfieldLength(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<int>("pvr_AchievementDefinition_GetBitfieldLength", new object[1] { msg });
		}

		internal static long pvr_AchievementDefinition_GetTarget(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<long>("pvr_AchievementDefinition_GetTarget", new object[1] { msg });
		}

		internal static string pvr_AchievementDefinition_GetTitle(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetTitle", new object[1] { msg });
		}

		internal static string pvr_AchievementDefinition_GetUnlockedDescription(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetUnlocked_description", new object[1] { msg });
		}

		internal static string pvr_AchievementDefinition_GetLockedIcon(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetLocked_image", new object[1] { msg });
		}

		internal static bool pvr_AchievementDefinition_GetIsSecrect(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<bool>("pvr_AchievementDefinition_GetIs_secret", new object[1] { msg });
		}

		internal static string pvr_AchievementDefinition_GetUnlockedIcon(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetUnlocked_image", new object[1] { msg });
		}

		internal static string pvr_AchievementDefinition_GetDescription(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetDescription", new object[1] { msg });
		}
	}
	public class Pvr_AchievementDefinition
	{
		public readonly AchievementType Type;

		public readonly string Name;

		public readonly int BitfieldLength;

		public readonly long Target;

		public readonly string Title;

		public readonly string Description;

		public readonly string UnlockedDescription;

		public readonly string UnlockedIcon;

		public readonly string LockedIcon;

		public readonly bool IsSecrect;

		public Pvr_AchievementDefinition(AndroidJavaObject msg)
		{
			Type = Pvr_AchievementAPI.pvr_AchievementDefinition_GetType(msg);
			Name = Pvr_AchievementAPI.pvr_AchievementDefinition_GetName(msg);
			BitfieldLength = Pvr_AchievementAPI.pvr_AchievementDefinition_GetBitfieldLength(msg);
			Target = Pvr_AchievementAPI.pvr_AchievementDefinition_GetTarget(msg);
			Title = Pvr_AchievementAPI.pvr_AchievementDefinition_GetTitle(msg);
			Description = Pvr_AchievementAPI.pvr_AchievementDefinition_GetDescription(msg);
			UnlockedDescription = Pvr_AchievementAPI.pvr_AchievementDefinition_GetUnlockedDescription(msg);
			UnlockedIcon = Pvr_AchievementAPI.pvr_AchievementDefinition_GetUnlockedIcon(msg);
			LockedIcon = Pvr_AchievementAPI.pvr_AchievementDefinition_GetLockedIcon(msg);
			IsSecrect = Pvr_AchievementAPI.pvr_AchievementDefinition_GetIsSecrect(msg);
		}
	}
	public class Pvr_AchievementDefinitionList : Pvr_DeserializableList<Pvr_AchievementDefinition>
	{
		public Pvr_AchievementDefinitionList(AndroidJavaObject msg)
		{
			int num = Pvr_AchievementAPI.pvr_AchievementDefinitionArray_GetSize(msg);
			data = new List<Pvr_AchievementDefinition>(num);
			for (int i = 0; i < num; i++)
			{
				data.Add(new Pvr_AchievementDefinition(Pvr_AchievementAPI.pvr_AchievementDefinitionArray_GetElement(msg, i)));
			}
			nextUrl = Pvr_AchievementAPI.pvr_AchievementDefinitionArray_GetNextUrl(msg);
		}
	}
	public class Pvr_AchievementProgress
	{
		public readonly string Bitfield;

		public readonly long Count;

		public readonly bool IsUnlocked;

		public readonly string Name;

		public readonly DateTime UnlockTime;

		public Pvr_AchievementProgress(AndroidJavaObject msg)
		{
			Bitfield = Pvr_AchievementAPI.pvr_AchievementProgress_GetBitfield(msg);
			Count = Pvr_AchievementAPI.pvr_AchievementProgress_GetCount(msg);
			IsUnlocked = Pvr_AchievementAPI.pvr_AchievementProgress_GetIsUnlocked(msg);
			Name = Pvr_AchievementAPI.pvr_AchievementProgress_GetName(msg);
			UnlockTime = Pvr_AchievementAPI.pvr_AchievementProgress_GetUnlockTime(msg);
		}
	}
	public class Pvr_AchievementProgressList : Pvr_DeserializableList<Pvr_AchievementProgress>
	{
		public Pvr_AchievementProgressList(AndroidJavaObject msg)
		{
			int num = Pvr_AchievementAPI.pvr_AchievementProgressArray_GetSize(msg);
			data = new List<Pvr_AchievementProgress>(num);
			for (int i = 0; i < num; i++)
			{
				data.Add(new Pvr_AchievementProgress(Pvr_AchievementAPI.pvr_AchievementProgressArray_GetElement(msg, i)));
			}
			nextUrl = Pvr_AchievementAPI.pvr_AchievementProgressArray_GetNextUrl(msg);
		}
	}
	public class Pvr_AchievementUpdate
	{
		public readonly bool JustUnlocked;

		public readonly string Name;

		public Pvr_AchievementUpdate(AndroidJavaObject msg)
		{
			JustUnlocked = Pvr_AchievementAPI.pvr_AchievementUpdate_GetJustUnlocked(msg);
			Name = Pvr_AchievementAPI.pvr_AchievementUpdate_GetName(msg);
		}
	}
	public class Pvr_DeserializableList<T> : IList<T>, ICollection<T>, IEnumerable<T>, IEnumerable
	{
		protected List<T> data;

		protected string nextUrl;

		protected string previousUrl;

		public int Count => data.Count;

		bool ICollection<T>.IsReadOnly => ((ICollection<T>)data).IsReadOnly;

		public T this[int index]
		{
			get
			{
				return data[index];
			}
			set
			{
				data[index] = value;
			}
		}

		public bool HasNextPage => !string.IsNullOrEmpty(NextUrl);

		public bool HasPreviousPage => !string.IsNullOrEmpty(PreviousUrl);

		public string NextUrl => nextUrl;

		public string PreviousUrl => previousUrl;

		public int IndexOf(T obj)
		{
			return data.IndexOf(obj);
		}

		public void Add(T item)
		{
			data.Add(item);
		}

		public void Clear()
		{
			data.Clear();
		}

		public bool Contains(T item)
		{
			return data.Contains(item);
		}

		public void CopyTo(T[] array, int arrayIndex)
		{
			data.CopyTo(array, arrayIndex);
		}

		public IEnumerator<T> GetEnumerator()
		{
			return data.GetEnumerator();
		}

		public void Insert(int index, T item)
		{
			data.Insert(index, item);
		}

		public bool Remove(T item)
		{
			return data.Remove(item);
		}

		public void RemoveAt(int index)
		{
			data.RemoveAt(index);
		}

		private IEnumerator GetEnumerator1()
		{
			return GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator1();
		}
	}
	public static class Pvr_Callback
	{
		private class RequestCallback
		{
			private Pvr_Message.Callback messageCallback;

			public RequestCallback()
			{
			}

			public RequestCallback(Pvr_Message.Callback callback)
			{
				messageCallback = callback;
			}

			public virtual void HandleMessage(Pvr_Message msg)
			{
				if (messageCallback != null)
				{
					messageCallback(msg);
				}
			}
		}

		private sealed class RequestCallback<T> : RequestCallback
		{
			private Pvr_Message<T>.Callback callback;

			public RequestCallback(Pvr_Message<T>.Callback callback)
			{
				this.callback = callback;
			}

			public override void HandleMessage(Pvr_Message msg)
			{
				if (callback != null)
				{
					if (msg is Pvr_Message<T>)
					{
						callback((Pvr_Message<T>)msg);
					}
					else
					{
						UnityEngine.Debug.LogError("Unable to handle message: " + msg.GetType());
					}
				}
			}
		}

		private static Dictionary<long, Request> requestIDsToRequests = new Dictionary<long, Request>();

		private static Dictionary<Pvr_Message.MessageType, RequestCallback> notificationCallbacks = new Dictionary<Pvr_Message.MessageType, RequestCallback>();

		internal static void AddRequest(Request request)
		{
			if (request.RequestID <= 2)
			{
				long requestID = request.RequestID;
				if ((ulong)requestID <= 2uL)
				{
					switch (requestID)
					{
					case 0L:
						UnityEngine.Debug.LogError("An PARAM_INVALIDE error occurred. Request failed.");
						return;
					case 1L:
						UnityEngine.Debug.LogError("An NETWORK_INVALIDE error occurred. Request failed.");
						return;
					case 2L:
						UnityEngine.Debug.LogError("An NOT_INTIALIZE error occurred. Request failed.");
						return;
					}
				}
				UnityEngine.Debug.LogError("An unknown error occurred. Request failed.");
			}
			else
			{
				requestIDsToRequests[request.RequestID] = request;
			}
		}

		internal static void RunCallbacks()
		{
			while (true)
			{
				Pvr_Message pvr_Message = Pvr_Message.PopMessage();
				if (pvr_Message != null)
				{
					HandleMessage(pvr_Message);
					continue;
				}
				break;
			}
		}

		internal static void RunLimitedCallbacks(uint limit)
		{
			for (int i = 0; i < limit; i++)
			{
				Pvr_Message pvr_Message = Pvr_Message.PopMessage();
				if (pvr_Message != null)
				{
					HandleMessage(pvr_Message);
					continue;
				}
				break;
			}
		}

		internal static void OnApplicationQuit()
		{
			requestIDsToRequests.Clear();
			notificationCallbacks.Clear();
		}

		internal static void HandleMessage(Pvr_Message msg)
		{
			if (msg.RequestID != 0L && requestIDsToRequests.TryGetValue(msg.RequestID, out var value))
			{
				try
				{
					value.HandleMessage(msg);
					return;
				}
				finally
				{
					requestIDsToRequests.Remove(msg.RequestID);
				}
			}
			if (notificationCallbacks.TryGetValue(msg.Type, out var value2))
			{
				value2.HandleMessage(msg);
			}
		}
	}
	public class Pvr_CallbackRunner : MonoBehaviour
	{
		public bool IsPersistantBetweenSceneLoads = true;

		private void Awake()
		{
			if (UnityEngine.Object.FindObjectOfType<Pvr_CallbackRunner>() != this)
			{
				UnityEngine.Debug.LogWarning("You only need one instance of CallbackRunner");
			}
			if (IsPersistantBetweenSceneLoads)
			{
				UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
			}
		}

		private void Update()
		{
			Request.RunCallbacks();
		}

		private void OnApplicationQuit()
		{
			Pvr_Callback.OnApplicationQuit();
		}
	}
	public abstract class Pvr_Message<T> : Pvr_Message
	{
		public new delegate void Callback(Pvr_Message<T> message);

		private T data;

		public T Data => data;

		public Pvr_Message(AndroidJavaObject msg)
			: base(msg)
		{
			if (!base.IsError)
			{
				data = GetDataFromMessage(msg);
			}
		}

		protected abstract T GetDataFromMessage(AndroidJavaObject msg);
	}
	public class Pvr_Message
	{
		public delegate void Callback(Pvr_Message message);

		public enum MessageType : uint
		{
			Unknown = 0u,
			Achievements_AddCount = 65495601u,
			Achievements_AddFields = 346693929u,
			Achievements_GetAllDefinitions = 64177549u,
			Achievements_GetAllProgress = 1335877149u,
			Achievements_GetDefinitionsByName = 1653670332u,
			Achievements_GetNextAchievementDefinitionArrayPage = 712888917u,
			Achievements_GetNextAchievementProgressArrayPage = 792913703u,
			Achievements_GetProgressByName = 354837425u,
			Achievements_Unlock = 1497156573u,
			Achievements_WriteAchievementProgress = 121027549u,
			Achievements_VerifyAccessToken = 53284924u
		}

		internal delegate Pvr_Message ExtraMessageTypesHandler(AndroidJavaObject messageHandle, MessageType message_type);

		private MessageType type;

		private long requestID;

		private Error error;

		public MessageType Type => type;

		public bool IsError => error != null;

		public long RequestID => requestID;

		internal static ExtraMessageTypesHandler HandleExtraMessageTypes { private get; set; }

		public Pvr_Message(AndroidJavaObject msg)
		{
			type = (MessageType)Pvr_AchievementAPI.pvr_Message_GetType(msg);
			bool num = Pvr_AchievementAPI.pvr_Message_IsError(msg);
			requestID = Pvr_AchievementAPI.pvr_Message_GetRequestID(msg);
			if (num)
			{
				error = new Error(Pvr_AchievementAPI.pvr_Error_GetCode(msg), Pvr_AchievementAPI.pvr_Error_GetMessage(msg), Pvr_AchievementAPI.pvr_Error_GetHttpCode(msg));
			}
			else if (AchievementCore.LogMessages)
			{
				string text = Pvr_AchievementAPI.pvr_Message_GetString(msg);
				if (text != null)
				{
					UnityEngine.Debug.Log(text);
				}
				else
				{
					UnityEngine.Debug.Log($"null message string {msg}");
				}
			}
		}

		public virtual Error GetError()
		{
			return error;
		}

		public virtual Pvr_AchievementDefinitionList GetAchievementDefinitions()
		{
			return null;
		}

		public virtual Pvr_AchievementProgressList GetAchievementProgressList()
		{
			return null;
		}

		public virtual Pvr_AchievementUpdate GetAchievementUpdate()
		{
			return null;
		}

		public virtual string GetString()
		{
			return null;
		}

		internal static Pvr_Message ParseMessageHandle(AndroidJavaObject messageHandle)
		{
			if (messageHandle == null)
			{
				return null;
			}
			Pvr_Message result = null;
			switch ((MessageType)Pvr_AchievementAPI.pvr_Message_GetType(messageHandle))
			{
			case MessageType.Achievements_GetAllDefinitions:
			case MessageType.Achievements_GetNextAchievementDefinitionArrayPage:
			case MessageType.Achievements_GetDefinitionsByName:
				result = new MessageWithAchievementDefinitions(messageHandle);
				break;
			case MessageType.Achievements_GetProgressByName:
			case MessageType.Achievements_GetNextAchievementProgressArrayPage:
			case MessageType.Achievements_GetAllProgress:
				result = new MessageWithAchievementProgressList(messageHandle);
				break;
			case MessageType.Achievements_VerifyAccessToken:
			case MessageType.Achievements_AddCount:
			case MessageType.Achievements_AddFields:
			case MessageType.Achievements_Unlock:
				result = new MessageWithAchievementUpdate(messageHandle);
				break;
			}
			return result;
		}

		public static Pvr_Message PopMessage()
		{
			return ParseMessageHandle(Pvr_AchievementAPI.PopMessage());
		}
	}
	public class MessageWithAchievementDefinitions : Pvr_Message<Pvr_AchievementDefinitionList>
	{
		public MessageWithAchievementDefinitions(AndroidJavaObject msg)
			: base(msg)
		{
		}

		public override Pvr_AchievementDefinitionList GetAchievementDefinitions()
		{
			return base.Data;
		}

		protected override Pvr_AchievementDefinitionList GetDataFromMessage(AndroidJavaObject msg)
		{
			return new Pvr_AchievementDefinitionList(msg);
		}
	}
	public class MessageWithAchievementProgressList : Pvr_Message<Pvr_AchievementProgressList>
	{
		public MessageWithAchievementProgressList(AndroidJavaObject msg)
			: base(msg)
		{
		}

		public override Pvr_AchievementProgressList GetAchievementProgressList()
		{
			return base.Data;
		}

		protected override Pvr_AchievementProgressList GetDataFromMessage(AndroidJavaObject msg)
		{
			return new Pvr_AchievementProgressList(msg);
		}
	}
	public class MessageWithAchievementUpdate : Pvr_Message<Pvr_AchievementUpdate>
	{
		public MessageWithAchievementUpdate(AndroidJavaObject msg)
			: base(msg)
		{
		}

		public override Pvr_AchievementUpdate GetAchievementUpdate()
		{
			return base.Data;
		}

		protected override Pvr_AchievementUpdate GetDataFromMessage(AndroidJavaObject msg)
		{
			return new Pvr_AchievementUpdate(msg);
		}
	}
	public class MessageWithString : Pvr_Message<string>
	{
		public MessageWithString(AndroidJavaObject msg)
			: base(msg)
		{
		}

		public override string GetString()
		{
			return base.Data;
		}

		protected override string GetDataFromMessage(AndroidJavaObject msg)
		{
			return Pvr_AchievementAPI.pvr_Message_GetString(msg);
		}
	}
	public class Error
	{
		public readonly int Code;

		public readonly int HttpCode;

		public readonly string Message;

		public Error(int code, string message, int httpCode)
		{
			Message = message;
			Code = code;
			HttpCode = httpCode;
		}
	}
	public sealed class Pvr_Request<T> : Request
	{
		private Pvr_Message<T>.Callback callback_;

		public Pvr_Request(long requestID)
			: base(requestID)
		{
		}

		public Pvr_Request<T> OnComplete(Pvr_Message<T>.Callback callback)
		{
			if (callback_ != null)
			{
				throw new UnityException("Attempted to attach multiple handlers to a Request.  This is not allowed.");
			}
			callback_ = callback;
			Pvr_Callback.AddRequest(this);
			return this;
		}

		public override void HandleMessage(Pvr_Message msg)
		{
			if (!(msg is Pvr_Message<T>))
			{
				UnityEngine.Debug.LogError("Unable to handle message: " + msg.GetType());
				return;
			}
			if (callback_ != null)
			{
				callback_((Pvr_Message<T>)msg);
				return;
			}
			throw new UnityException("Request with no handler.  This should never happen.");
		}
	}
	public class Request
	{
		private Pvr_Message.Callback callback_;

		public long RequestID { get; set; }

		public Request(long requestID)
		{
			RequestID = requestID;
		}

		public Request OnComplete(Pvr_Message.Callback callback)
		{
			callback_ = callback;
			Pvr_Callback.AddRequest(this);
			return this;
		}

		public virtual void HandleMessage(Pvr_Message msg)
		{
			if (callback_ != null)
			{
				callback_(msg);
				return;
			}
			throw new UnityException("Request with no handler.  This should never happen.");
		}

		public static void RunCallbacks(uint limit = 0u)
		{
			if (limit == 0)
			{
				Pvr_Callback.RunCallbacks();
			}
			else
			{
				Pvr_Callback.RunLimitedCallbacks(limit);
			}
		}
	}
}
namespace Jacovone
{
	[ExecuteInEditMode]
	public class DistributeOnPath : MonoBehaviour
	{
		public GameObject target;

		public int count;

		public float startingFrom;

		public float endTo;

		public PathMagic path;

		private void Awake()
		{
		}

		public void Generate()
		{
			if (count < 0)
			{
				count = 0;
			}
			List<GameObject> list = new List<GameObject>();
			for (int i = 0; i < count; i++)
			{
				if (i < base.transform.childCount)
				{
					list.Insert(i, base.transform.GetChild(i).gameObject);
					continue;
				}
				list.Insert(i, UnityEngine.Object.Instantiate(target));
				list[i].transform.parent = base.transform;
				list[i].transform.localScale = new Vector3(1f, 1f, 1f);
			}
			if (list.Count < base.transform.childCount)
			{
				for (int num = base.transform.childCount - 1; num >= list.Count; num--)
				{
					UnityEngine.Object.DestroyImmediate(base.transform.GetChild(num).gameObject);
				}
			}
			for (int j = 0; j < list.Count; j++)
			{
				float pos = startingFrom + 1f / (float)count * (float)j * (endTo - startingFrom);
				Vector3 position;
				Quaternion rotation;
				if (path.PresampledPath)
				{
					path.sampledPositionAndRotationAndVelocityAndWaypointAtPos(pos, out position, out rotation, out var _, out var _);
				}
				else
				{
					position = path.computePositionAtPos(pos);
					rotation = path.computeRotationAtPos(pos);
				}
				list[j].transform.position = path.transform.TransformPoint(position);
				list[j].transform.rotation = base.transform.rotation * rotation;
			}
		}
	}
	public class MathUtils
	{
		public static Quaternion QuaternionBezier(Quaternion p, Quaternion prevP, Quaternion nextP, Quaternion nextNextP, float stepPos)
		{
			Quaternion quaternion = QuaternionNormalize(Quaternion.Slerp(Quaternion.Slerp(prevP, p, 2f), nextP, 0.5f));
			Quaternion quaternion2 = QuaternionNormalize(Quaternion.Slerp(QuaternionNormalize(Quaternion.Slerp(Quaternion.Slerp(p, nextP, 2f), nextNextP, 0.5f)), nextP, 2f));
			Quaternion quaternion3 = Quaternion.Slerp(p, quaternion, stepPos);
			Quaternion a = Quaternion.Slerp(quaternion, quaternion2, stepPos);
			Quaternion b = Quaternion.Slerp(quaternion2, nextP, stepPos);
			Quaternion a2 = Quaternion.Slerp(quaternion3, quaternion3, stepPos);
			Quaternion b2 = Quaternion.Slerp(a, b, stepPos);
			return Quaternion.Slerp(a2, b2, stepPos);
		}

		public static Quaternion QuaternionNormalize(Quaternion q)
		{
			float num = Mathf.Sqrt(q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w);
			if (num > 0f)
			{
				q.x /= num;
				q.y /= num;
				q.z /= num;
				q.w /= num;
			}
			else
			{
				q.x = 0f;
				q.y = 0f;
				q.z = 0f;
				q.w = 1f;
			}
			return q;
		}

		public static Vector3 Vector3Bezier(Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3, float t)
		{
			float num = t * t;
			float num2 = t * num;
			float num3 = 1f - t;
			float num4 = num3 * num3;
			return num3 * num4 * p0 + 3f * num4 * t * p1 + 3f * num3 * num * p2 + num2 * p3;
		}

		public static float FloatBezier(float p0, float p1, float p2, float p3, float t)
		{
			float num = t * t;
			float num2 = t * num;
			float num3 = 1f - t;
			float num4 = num3 * num3;
			return num3 * num4 * p0 + 3f * num4 * t * p1 + 3f * num3 * num * p2 + num2 * p3;
		}
	}
	public class PathMagic : MonoBehaviour
	{
		[Serializable]
		public class WaypointChangedEvent : UnityEvent<int>
		{
		}

		public enum UpdateModeType
		{
			OnUpdate,
			OnFixedUpdate
		}

		public UnityEngine.Color pathColor = UnityEngine.Color.white;

		public Waypoint[] waypoints = new Waypoint[0];

		public Transform target;

		public bool disableOrientation;

		public Transform globalLookAt;

		public bool globalFollowPath;

		public float globalFollowPathBias = 0.001f;

		public UpdateModeType updateMode;

		public bool loop;

		public bool autoStart;

		public float velocityBias = 0.1f;

		public float currentPos;

		public bool isPlaying;

		public WaypointChangedEvent waypointChanged;

		public bool presampledPath;

		public int samplesNum = 100;

		private int _lastPassedWayponint;

		public Vector3[] positionSamples;

		public Quaternion[] rotationSamples;

		public float[] velocitySamples;

		public int[] waypointSamples;

		public float[] samplesDistances;

		public float totalDistance;

		public bool updateTransform = true;

		private float _lastVelocity = 1f;

		public Waypoint[] Waypoints
		{
			get
			{
				return waypoints;
			}
			set
			{
				waypoints = value;
				if (presampledPath)
				{
					UpdatePathSamples();
				}
				UpdateTarget();
			}
		}

		public Transform Target
		{
			get
			{
				return target;
			}
			set
			{
				target = value;
			}
		}

		public bool DisableOrientation
		{
			get
			{
				return disableOrientation;
			}
			set
			{
				disableOrientation = value;
			}
		}

		public Transform GlobalLookAt
		{
			get
			{
				return globalLookAt;
			}
			set
			{
				globalLookAt = value;
			}
		}

		public bool GlobalFollowPath
		{
			get
			{
				return globalFollowPath;
			}
			set
			{
				globalFollowPath = value;
			}
		}

		public float GlobalFollowPathBias
		{
			get
			{
				return globalFollowPathBias;
			}
			set
			{
				globalFollowPathBias = value;
			}
		}

		public UpdateModeType UpdateMode
		{
			get
			{
				return updateMode;
			}
			set
			{
				updateMode = value;
			}
		}

		public bool Loop
		{
			get
			{
				return loop;
			}
			set
			{
				loop = value;
			}
		}

		public bool AutoStart
		{
			get
			{
				return autoStart;
			}
			set
			{
				autoStart = value;
			}
		}

		public float VelocityBias
		{
			get
			{
				return velocityBias;
			}
			set
			{
				velocityBias = value;
			}
		}

		public float CurrentPos
		{
			get
			{
				return currentPos;
			}
			set
			{
				currentPos = value;
				UpdateTarget();
			}
		}

		public bool IsPlaying => isPlaying;

		public WaypointChangedEvent WaypointChanged
		{
			get
			{
				return waypointChanged;
			}
			set
			{
				waypointChanged = value;
			}
		}

		public bool PresampledPath => presampledPath;

		public int SamplesNum => samplesNum;

		public int LastPassedWayponint => _lastPassedWayponint;

		public Vector3[] PositionSamples => positionSamples;

		public Quaternion[] RotationSamples => rotationSamples;

		public float[] VelocitySamples => velocitySamples;

		public int[] WaypointSamples => waypointSamples;

		public float[] SamplesDistances => samplesDistances;

		public float TotalDistance => totalDistance;

		public bool UpdateTransform
		{
			get
			{
				return updateTransform;
			}
			set
			{
				updateTransform = value;
			}
		}

		private void OnEnable()
		{
		}

		private void OnDisable()
		{
		}

		private void Start()
		{
			if (presampledPath)
			{
				UpdatePathSamples();
			}
			if (Application.isPlaying)
			{
				isPlaying = autoStart;
			}
			else
			{
				isPlaying = false;
			}
		}

		private void Update()
		{
			if (updateMode == UpdateModeType.OnUpdate || !Application.isPlaying)
			{
				DoUpdate();
			}
		}

		private void FixedUpdate()
		{
			if (updateMode == UpdateModeType.OnFixedUpdate)
			{
				DoUpdate();
			}
		}

		private void DoUpdate()
		{
			if (waypoints.Length == 0 || !isPlaying)
			{
				return;
			}
			float num = 0.5f * velocityBias * _lastVelocity * (Application.isPlaying ? Time.deltaTime : 0.008f);
			currentPos += num;
			if (currentPos >= 1f)
			{
				if (loop)
				{
					currentPos -= 1f;
				}
				else
				{
					currentPos = 1f;
					Pause();
				}
			}
			else if (currentPos <= 0f)
			{
				if (loop)
				{
					currentPos += 1f;
				}
				else
				{
					currentPos = 0f;
					Pause();
				}
			}
			if (UpdateTransform || Application.isPlaying)
			{
				UpdateTarget();
			}
		}

		public void Play()
		{
			if (waypoints.Length != 0)
			{
				isPlaying = true;
			}
		}

		public void Pause()
		{
			if (waypoints.Length != 0)
			{
				isPlaying = false;
			}
		}

		public void Rewind()
		{
			if (waypoints.Length != 0)
			{
				currentPos = 0f;
			}
		}

		public void Stop()
		{
			if (waypoints.Length != 0)
			{
				isPlaying = false;
				currentPos = 0f;
				UpdateTarget(computePositionAtPos(currentPos), computeRotationAtPos(currentPos));
			}
		}

		public void sampledPositionAndRotationAndVelocityAndWaypointAtPos(float pos, out Vector3 position, out Quaternion rotation, out float velocity, out int waypoint)
		{
			float num = pos * totalDistance;
			float num2 = 0f;
			for (int i = 1; i < samplesNum; i++)
			{
				num2 += samplesDistances[i];
				if (!(num2 >= num))
				{
					continue;
				}
				float t = 1f - (num2 - num) / samplesDistances[i];
				position = Vector3.Lerp(positionSamples[i - 1], positionSamples[i], t);
				if (globalLookAt != null)
				{
					rotation = Quaternion.LookRotation(base.transform.InverseTransformPoint(globalLookAt.position) - position);
				}
				else
				{
					rotation = Quaternion.Lerp(rotationSamples[i - 1], rotationSamples[i], t);
				}
				velocity = Mathf.Lerp(velocitySamples[i - 1], velocitySamples[i], t);
				if (pos >= 1f)
				{
					if (loop)
					{
						waypoint = 0;
					}
					else
					{
						waypoint = waypoints.Length - 1;
					}
				}
				else
				{
					waypoint = waypointSamples[i - 1];
				}
				return;
			}
			position = positionSamples[samplesNum - 1];
			rotation = rotationSamples[samplesNum - 1];
			velocity = velocitySamples[samplesNum - 1];
			waypoint = waypoints.Length - 1;
		}

		public Quaternion computeRotationAtPos(float pos)
		{
			if (globalFollowPath)
			{
				return GetFaceForwardForPos(pos);
			}
			if (globalLookAt != null)
			{
				return Quaternion.LookRotation(base.transform.InverseTransformPoint(globalLookAt.position) - computePositionAtPos(pos));
			}
			if (waypoints.Length < 1)
			{
				return Quaternion.identity;
			}
			if (waypoints.Length == 1)
			{
				return GetWaypointRotation(0);
			}
			if (pos >= 1f)
			{
				if (loop)
				{
					return GetWaypointRotation(0);
				}
				return GetWaypointRotation(waypoints.Length - 1);
			}
			float num = 1f / (float)(waypoints.Length - ((!loop) ? 1 : 0));
			int waypointFromPos = GetWaypointFromPos(pos);
			float stepPos = (pos - (float)waypointFromPos * num) / num;
			Quaternion waypointRotation = GetWaypointRotation(waypointFromPos);
			Quaternion waypointRotation2 = GetWaypointRotation(waypointFromPos - 1);
			Quaternion waypointRotation3 = GetWaypointRotation(waypointFromPos + 1);
			Quaternion waypointRotation4 = GetWaypointRotation(waypointFromPos + 2);
			return MathUtils.QuaternionBezier(waypointRotation, waypointRotation2, waypointRotation3, waypointRotation4, stepPos);
		}

		public Quaternion GetWaypointRotation(int index)
		{
			if (index < 0)
			{
				index += waypoints.Length;
			}
			index %= waypoints.Length;
			if (!(waypoints[index].lookAt != null))
			{
				return Quaternion.Euler(waypoints[index].rotation);
			}
			return Quaternion.LookRotation(base.transform.InverseTransformPoint(waypoints[index].lookAt.position) - waypoints[index].position);
		}

		public Vector3 computePositionAtPos(float pos)
		{
			if (waypoints.Length < 1)
			{
				return Vector3.zero;
			}
			if (waypoints.Length == 1)
			{
				return waypoints[0].position;
			}
			if (waypoints.Length >= 1 && pos == 0f)
			{
				return waypoints[0].position;
			}
			if (pos >= 1f)
			{
				if (loop)
				{
					return waypoints[0].position;
				}
				return waypoints[waypoints.Length - 1].position;
			}
			float num = 1f / (float)(waypoints.Length - ((!loop) ? 1 : 0));
			int waypointFromPos = GetWaypointFromPos(pos);
			float t = (pos - (float)waypointFromPos * num) / num;
			return MathUtils.Vector3Bezier(waypoints[waypointFromPos % waypoints.Length].position, waypoints[waypointFromPos % waypoints.Length].outTangent + waypoints[waypointFromPos % waypoints.Length].position, waypoints[(waypointFromPos + 1) % waypoints.Length].inTangent + waypoints[(waypointFromPos + 1) % waypoints.Length].position, waypoints[(waypointFromPos + 1) % waypoints.Length].position, t);
		}

		public float computeVelocityAtPos(float pos)
		{
			if (waypoints.Length < 1)
			{
				return 1f;
			}
			if (waypoints.Length == 1)
			{
				return waypoints[0].velocity;
			}
			if (pos >= 1f)
			{
				if (loop)
				{
					return waypoints[0].velocity;
				}
				return waypoints[waypoints.Length - 1].velocity;
			}
			float num = 1f / (float)(waypoints.Length - ((!loop) ? 1 : 0));
			int waypointFromPos = GetWaypointFromPos(pos);
			float t = (pos - (float)waypointFromPos * num) / num;
			Waypoint waypoint = waypoints[waypointFromPos % waypoints.Length];
			Waypoint waypoint2 = waypoints[(waypointFromPos + 1) % waypoints.Length];
			return MathUtils.FloatBezier(p1: (waypoint.outVariation == Waypoint.VelocityVariation.Fast) ? waypoint2.velocity : ((waypoint.outVariation != Waypoint.VelocityVariation.Medium) ? waypoint.velocity : Mathf.Lerp(waypoint.velocity, waypoint2.velocity, 0.5f)), p2: (waypoint2.inVariation == Waypoint.VelocityVariation.Fast) ? waypoint.velocity : ((waypoint2.inVariation != Waypoint.VelocityVariation.Medium) ? waypoint2.velocity : Mathf.Lerp(waypoint.velocity, waypoint2.velocity, 0.5f)), p0: waypoint.velocity, p3: waypoint2.velocity, t: t);
		}

		public void UpdateTarget(Vector3 position, Quaternion rotation)
		{
			if (target != null)
			{
				target.position = base.transform.TransformPoint(position);
				if (!disableOrientation)
				{
					target.rotation = base.transform.rotation * rotation;
				}
			}
		}

		public void UpdateTarget()
		{
			Vector3 position = Vector3.zero;
			Quaternion rotation = Quaternion.identity;
			float velocity = 1f;
			int waypoint = 0;
			if (presampledPath)
			{
				sampledPositionAndRotationAndVelocityAndWaypointAtPos(currentPos, out position, out rotation, out velocity, out waypoint);
			}
			else
			{
				position = computePositionAtPos(currentPos);
				rotation = computeRotationAtPos(currentPos);
				velocity = computeVelocityAtPos(currentPos);
				waypoint = GetWaypointFromPos(currentPos);
			}
			_lastVelocity = velocity;
			UpdateTarget(position, rotation);
			if (waypoint != _lastPassedWayponint)
			{
				if (waypointChanged != null)
				{
					waypointChanged.Invoke(waypoint);
				}
				if (waypoints[waypoint].reached != null)
				{
					waypoints[waypoint].reached.Invoke();
				}
			}
			_lastPassedWayponint = waypoint;
		}

		public int GetCurrentWaypoint()
		{
			return GetWaypointFromPos(currentPos);
		}

		public int GetWaypointFromPos(float pos)
		{
			float num = 1f / (float)(waypoints.Length - ((!loop) ? 1 : 0));
			int num2 = Mathf.FloorToInt(pos / num) % waypoints.Length;
			if (num2 < 0)
			{
				num2 += waypoints.Length;
			}
			return num2;
		}

		public Quaternion GetFaceForwardForPos(float pos)
		{
			if (waypoints.Length <= 1)
			{
				return Quaternion.identity;
			}
			if (loop)
			{
				if (pos <= 0f)
				{
					pos = 1f + pos;
				}
				Vector3 vector = computePositionAtPos((pos + globalFollowPathBias) % 1f);
				Vector3 vector2 = computePositionAtPos(pos);
				return Quaternion.LookRotation(vector - vector2, Vector3.up);
			}
			float pos2 = Mathf.Clamp01(pos + globalFollowPathBias);
			Vector3 vector3 = computePositionAtPos(pos2);
			Vector3 vector4 = computePositionAtPos(pos);
			if (vector3 == vector4)
			{
				vector3 = waypoints[waypoints.Length - 1].outTangent;
				vector4 = waypoints[waypoints.Length - 1].inTangent;
			}
			return Quaternion.LookRotation(vector3 - vector4, Vector3.up);
		}

		public void UpdatePathSamples()
		{
			totalDistance = 0f;
			float num = 0f;
			positionSamples = new Vector3[samplesNum];
			rotationSamples = new Quaternion[samplesNum];
			samplesDistances = new float[samplesNum];
			velocitySamples = new float[samplesNum];
			waypointSamples = new int[samplesNum];
			if (waypoints.Length == 0)
			{
				return;
			}
			for (int i = 0; i < samplesNum - 1; i++)
			{
				positionSamples[i] = computePositionAtPos(num);
				rotationSamples[i] = computeRotationAtPos(num);
				velocitySamples[i] = computeVelocityAtPos(num);
				waypointSamples[i] = GetWaypointFromPos(num);
				if (i == 0)
				{
					samplesDistances[i] = 0f;
				}
				else
				{
					samplesDistances[i] = Vector3.Distance(positionSamples[i], positionSamples[i - 1]);
				}
				totalDistance += samplesDistances[i];
				num += 1f / ((float)samplesNum - 1f);
			}
			positionSamples[samplesNum - 1] = computePositionAtPos(loop ? 0f : 1f);
			rotationSamples[samplesNum - 1] = computeRotationAtPos(loop ? 0f : 1f);
			velocitySamples[samplesNum - 1] = computeVelocityAtPos(loop ? 0f : 1f);
			waypointSamples[samplesNum - 1] = GetWaypointFromPos(loop ? 0f : 1f);
			samplesDistances[samplesNum - 1] = Vector3.Distance(positionSamples[samplesNum - 1], positionSamples[samplesNum - 2]);
			totalDistance += samplesDistances[samplesNum - 1];
		}

		private void OnDrawGizmos()
		{
		}
	}
	public class PathMagicAnimator : MonoBehaviour
	{
		[Serializable]
		public class WaypointChangedEvent : UnityEvent<int>
		{
		}

		public enum UpdateModeType
		{
			OnUpdate,
			OnFixedUpdate
		}

		public PathMagic pathMagic;

		public Transform target;

		public UpdateModeType updateMode;

		public bool autoStart = true;

		public float velocityBias = 1f;

		public float currentPos;

		public bool isPlaying;

		public Transform globalLookAt;

		public bool disableOrientation;

		public bool globalFollowPath;

		public WaypointChangedEvent waypointChanged;

		private int _lastPassedWayponint;

		private float _lastVelocity = 1f;

		public PathMagic PathMagic
		{
			get
			{
				return pathMagic;
			}
			set
			{
				pathMagic = value;
			}
		}

		public Transform Target => target;

		public UpdateModeType UpdateMode
		{
			get
			{
				return updateMode;
			}
			set
			{
				updateMode = value;
			}
		}

		public bool AutoStart
		{
			get
			{
				return autoStart;
			}
			set
			{
				autoStart = value;
			}
		}

		public float VelocityBias
		{
			get
			{
				return velocityBias;
			}
			set
			{
				velocityBias = value;
			}
		}

		public float CurrentPos
		{
			get
			{
				return currentPos;
			}
			set
			{
				currentPos = value;
			}
		}

		public bool IsPlaying => isPlaying;

		public Transform GlobalLookAt
		{
			get
			{
				return globalLookAt;
			}
			set
			{
				globalLookAt = value;
			}
		}

		public bool DisableOrientation
		{
			get
			{
				return disableOrientation;
			}
			set
			{
				disableOrientation = value;
			}
		}

		public WaypointChangedEvent WaypointChanged
		{
			get
			{
				return waypointChanged;
			}
			set
			{
				waypointChanged = value;
			}
		}

		public int LastPassedWayponint => _lastPassedWayponint;

		private void OnEnable()
		{
			target = GetComponent<Transform>();
			isPlaying = false;
		}

		private void OnDisable()
		{
		}

		private void Start()
		{
			if (Application.isPlaying)
			{
				isPlaying = autoStart;
			}
			else
			{
				isPlaying = false;
			}
		}

		private void Update()
		{
			if (updateMode == UpdateModeType.OnUpdate || !Application.isPlaying)
			{
				DoUpdate();
			}
		}

		private void FixedUpdate()
		{
			if (updateMode == UpdateModeType.OnFixedUpdate)
			{
				DoUpdate();
			}
		}

		public void DoUpdate()
		{
			if (pathMagic == null || pathMagic.waypoints.Length == 0)
			{
				return;
			}
			Application.targetFrameRate = 60;
			if (!isPlaying)
			{
				return;
			}
			float num = 0.5f * velocityBias * _lastVelocity * (Application.isPlaying ? Time.deltaTime : 0.008f);
			currentPos += num;
			if (currentPos >= 1f)
			{
				if (pathMagic.loop)
				{
					currentPos -= 1f;
				}
				else
				{
					currentPos = 1f;
					Pause();
				}
			}
			else if (currentPos <= 0f)
			{
				if (pathMagic.loop)
				{
					currentPos += 1f;
				}
				else
				{
					currentPos = 0f;
					Pause();
				}
			}
			UpdateTarget();
		}

		public void Play()
		{
			if (pathMagic.waypoints.Length != 0)
			{
				_lastVelocity = pathMagic.waypoints[0].velocity;
				isPlaying = true;
			}
		}

		public void Pause()
		{
			if (pathMagic.waypoints.Length != 0)
			{
				isPlaying = false;
			}
		}

		public void Rewind()
		{
			if (pathMagic.waypoints.Length != 0)
			{
				currentPos = 0f;
			}
		}

		public void Stop()
		{
			if (pathMagic.waypoints.Length != 0)
			{
				isPlaying = false;
				currentPos = 0f;
				UpdateTarget(pathMagic.computePositionAtPos(currentPos), pathMagic.computeRotationAtPos(currentPos));
			}
		}

		public void UpdateTarget(Vector3 position, Quaternion rotation)
		{
			if (target != null)
			{
				target.position = pathMagic.transform.TransformPoint(position);
				if (!disableOrientation)
				{
					target.rotation = pathMagic.transform.rotation * rotation;
				}
			}
		}

		public void UpdateTarget()
		{
			Vector3 position = Vector3.zero;
			Quaternion rotation = Quaternion.identity;
			float velocity = 1f;
			int waypoint = 0;
			if (pathMagic.presampledPath)
			{
				pathMagic.sampledPositionAndRotationAndVelocityAndWaypointAtPos(currentPos, out position, out rotation, out velocity, out waypoint);
			}
			else
			{
				position = pathMagic.computePositionAtPos(currentPos);
				rotation = pathMagic.computeRotationAtPos(currentPos);
				velocity = pathMagic.computeVelocityAtPos(currentPos);
				waypoint = pathMagic.GetWaypointFromPos(currentPos);
			}
			if (globalFollowPath)
			{
				rotation = pathMagic.GetFaceForwardForPos(currentPos);
			}
			else if (globalLookAt != null)
			{
				rotation = Quaternion.LookRotation(pathMagic.transform.InverseTransformPoint(globalLookAt.position) - position);
			}
			_lastVelocity = velocity;
			UpdateTarget(position, rotation);
			if (waypoint != _lastPassedWayponint)
			{
				if (waypointChanged != null)
				{
					waypointChanged.Invoke(waypoint);
				}
				if (pathMagic.waypoints[waypoint].reached != null)
				{
					pathMagic.waypoints[waypoint].reached.Invoke();
				}
			}
			_lastPassedWayponint = waypoint;
		}
	}
	[RequireComponent(typeof(Rigidbody))]
	public class PathMagicJoint : MonoBehaviour
	{
		public PathMagic connectedPath;

		private Rigidbody _rb;

		private Transform _tr;

		public int precision1 = 100;

		public int precision2 = 200;

		public bool followPathOrientation;

		public bool motor;

		public int motorForce = 10;

		public int Precision1
		{
			get
			{
				return precision1;
			}
			set
			{
				precision2 = value;
			}
		}

		public int Precision2
		{
			get
			{
				return precision2;
			}
			set
			{
				precision2 = value;
			}
		}

		public bool FollowPathOrientation
		{
			get
			{
				return followPathOrientation;
			}
			set
			{
				followPathOrientation = value;
			}
		}

		public bool Motor
		{
			get
			{
				return motor;
			}
			set
			{
				motor = value;
			}
		}

		public int MotorForce
		{
			get
			{
				return motorForce;
			}
			set
			{
				motorForce = value;
			}
		}

		private void Awake()
		{
			_rb = GetComponent<Rigidbody>();
			_tr = GetComponent<Transform>();
		}

		private void FixedUpdate()
		{
			if (connectedPath == null)
			{
				return;
			}
			float pos = computePosAtMinDistance();
			_tr.position = GetPositionForPos(pos);
			if (followPathOrientation)
			{
				Vector3 position = Vector3.zero;
				Quaternion rotation = Quaternion.identity;
				float velocity = 1f;
				int waypoint = 0;
				if (connectedPath.presampledPath)
				{
					connectedPath.sampledPositionAndRotationAndVelocityAndWaypointAtPos(pos, out position, out rotation, out velocity, out waypoint);
				}
				else
				{
					rotation = connectedPath.computeRotationAtPos(pos);
				}
				if (!connectedPath.disableOrientation)
				{
					_tr.rotation = connectedPath.transform.rotation * rotation;
				}
			}
			Vector3 vector = connectedPath.GetFaceForwardForPos(pos) * Vector3.forward;
			vector = connectedPath.transform.TransformVector(vector);
			_rb.velocity = Vector3.Dot(_rb.velocity, vector) * vector;
			if (motor)
			{
				_rb.AddForce(vector * motorForce);
			}
		}

		private float computePosAtMinDistance()
		{
			if (connectedPath == null)
			{
				return 0f;
			}
			float num = float.MaxValue;
			float num2 = 1f / (float)Precision1;
			float num3 = 0f;
			for (int i = 0; i < precision1; i++)
			{
				float num4 = Vector3.Distance(GetPositionForPos((float)i * num2), _tr.position);
				if (num4 < num)
				{
					num3 = (float)i * num2;
					num = num4;
				}
			}
			float num5 = num3;
			for (float num6 = num5 - num2; num6 < num5 + num2; num6 += num2 / (float)precision2)
			{
				float num7 = Vector3.Distance(GetPositionForPos(num6), _tr.position);
				if (num7 < num)
				{
					num3 = num6;
					num = num7;
				}
			}
			return num3;
		}

		private Vector3 GetPositionForPos(float pos)
		{
			Vector3 position = Vector3.zero;
			Quaternion rotation = Quaternion.identity;
			if (pos < 0f)
			{
				pos = ((!connectedPath.loop) ? 0f : (1f + pos));
			}
			float velocity = 1f;
			int waypoint = 0;
			if (connectedPath.presampledPath)
			{
				connectedPath.sampledPositionAndRotationAndVelocityAndWaypointAtPos(pos, out position, out rotation, out velocity, out waypoint);
			}
			else
			{
				position = connectedPath.computePositionAtPos(pos);
			}
			return connectedPath.transform.TransformPoint(position);
		}
	}
	[Serializable]
	public class Waypoint
	{
		[Serializable]
		public class ReachedEvent : UnityEvent
		{
		}

		public enum VelocityVariation
		{
			Slow,
			Medium,
			Fast
		}

		public Vector3 position;

		public Vector3 rotation;

		public Transform lookAt;

		public Vector3 inTangent;

		public Vector3 outTangent;

		public bool symmetricTangents;

		public float velocity;

		public VelocityVariation inVariation;

		public VelocityVariation outVariation;

		public ReachedEvent reached;

		public Vector3 Position
		{
			get
			{
				return position;
			}
			set
			{
				position = value;
			}
		}

		public Vector3 Rotation
		{
			get
			{
				return rotation;
			}
			set
			{
				rotation = value;
			}
		}

		public Transform LookAt
		{
			get
			{
				return lookAt;
			}
			set
			{
				lookAt = value;
			}
		}

		public Vector3 InTangent
		{
			get
			{
				return inTangent;
			}
			set
			{
				inTangent = value;
				if (symmetricTangents)
				{
					outTangent = -inTangent;
				}
			}
		}

		public Vector3 OutTangent
		{
			get
			{
				return outTangent;
			}
			set
			{
				outTangent = value;
				if (symmetricTangents)
				{
					inTangent = -outTangent;
				}
			}
		}

		public bool SymmetricTangents
		{
			get
			{
				return symmetricTangents;
			}
			set
			{
				symmetricTangents = value;
			}
		}

		public VelocityVariation InVariation
		{
			get
			{
				return inVariation;
			}
			set
			{
				inVariation = value;
			}
		}

		public VelocityVariation OutVariation
		{
			get
			{
				return outVariation;
			}
			set
			{
				outVariation = value;
			}
		}

		public float Velocity
		{
			get
			{
				return velocity;
			}
			set
			{
				velocity = value;
			}
		}

		public ReachedEvent Reached
		{
			get
			{
				return reached;
			}
			set
			{
				reached = value;
			}
		}

		public Waypoint()
		{
			position = Vector3.zero;
			rotation = Vector3.zero;
			velocity = 1f;
			outTangent = Vector3.forward;
			inTangent = -Vector3.forward;
			symmetricTangents = true;
			inVariation = VelocityVariation.Medium;
			outVariation = VelocityVariation.Medium;
			reached = null;
		}
	}
}
namespace Jacovone.CameraTools
{
	[ExecuteInEditMode]
	public class PathMagicFollower : MonoBehaviour
	{
		public PathMagic pathMagic;

		public PathMagicAnimator pathMagicAnimator;

		public Transform target;

		public int precision = 1000;

		public bool accurate;

		public bool waypointsOnly;

		public bool lerpPosition = true;

		public float lerpFactor = 0.1f;

		public Transform Target
		{
			get
			{
				return target;
			}
			set
			{
				target = value;
			}
		}

		public int Precision
		{
			get
			{
				return precision;
			}
			set
			{
				precision = value;
			}
		}

		public bool Accurate
		{
			get
			{
				return accurate;
			}
			set
			{
				accurate = value;
			}
		}

		public bool WaypointsOnly
		{
			get
			{
				return waypointsOnly;
			}
			set
			{
				waypointsOnly = value;
			}
		}

		public bool LerpPosition
		{
			get
			{
				return lerpPosition;
			}
			set
			{
				lerpPosition = value;
			}
		}

		public float LerpFactor
		{
			get
			{
				return lerpFactor;
			}
			set
			{
				lerpFactor = value;
			}
		}

		public float CurrentPos
		{
			get
			{
				if (pathMagic != null)
				{
					return pathMagic.CurrentPos;
				}
				if (pathMagicAnimator != null)
				{
					return pathMagicAnimator.CurrentPos;
				}
				return 0f;
			}
			set
			{
				if (pathMagic != null)
				{
					pathMagic.CurrentPos = value;
					pathMagic.UpdateTarget();
				}
				else if (pathMagicAnimator != null)
				{
					pathMagicAnimator.CurrentPos = value;
					pathMagicAnimator.UpdateTarget();
				}
			}
		}

		public PathMagic Path
		{
			get
			{
				if (pathMagic != null)
				{
					return pathMagic;
				}
				if (pathMagicAnimator != null)
				{
					return pathMagicAnimator.pathMagic;
				}
				return null;
			}
		}

		public Vector3 PointOfView
		{
			get
			{
				Vector3 position = Vector3.zero;
				Quaternion rotation = Quaternion.identity;
				float velocity = 1f;
				int waypoint = 0;
				if (Path.presampledPath)
				{
					Path.sampledPositionAndRotationAndVelocityAndWaypointAtPos(CurrentPos, out position, out rotation, out velocity, out waypoint);
				}
				else
				{
					position = Path.computePositionAtPos(CurrentPos);
				}
				return Path.transform.TransformPoint(position);
			}
		}

		private void Awake()
		{
			PathMagic component = GetComponent<PathMagic>();
			if (component != null)
			{
				pathMagic = component;
				pathMagicAnimator = null;
				return;
			}
			PathMagicAnimator component2 = GetComponent<PathMagicAnimator>();
			if (component2 != null)
			{
				pathMagicAnimator = component2;
				pathMagic = null;
			}
		}

		private void OnEnable()
		{
		}

		private void OnDisable()
		{
		}

		private void Update()
		{
			float num = ((!waypointsOnly) ? computePosAtMinDistance() : computeWaypointPosAtMinDistance());
			if (Path.Loop)
			{
				if (Mathf.Abs(CurrentPos - num) > Mathf.Abs(CurrentPos - (1f + num)))
				{
					num = 1f + num;
				}
				if (Mathf.Abs(CurrentPos - num) > Mathf.Abs(CurrentPos - (num - 1f)))
				{
					num -= 1f;
				}
			}
			float num2;
			for (num2 = ((!lerpPosition) ? num : Mathf.Lerp(CurrentPos, num, lerpFactor)); num2 > 1f; num2 -= 1f)
			{
			}
			for (; num2 < 0f; num2 += 1f)
			{
			}
			CurrentPos = num2;
		}

		private float computeWaypointPosAtMinDistance()
		{
			float num = float.MaxValue;
			float num2 = 0f;
			int num3 = 0;
			float num4 = 1f / (float)precision;
			for (int i = 0; i < Path.Waypoints.Length; i++)
			{
				float num5 = Vector3.Distance(Path.transform.TransformPoint(Path.Waypoints[i].position), target.position);
				if (num5 < num)
				{
					num3 = i;
					num = num5;
				}
			}
			if (!Path.presampledPath)
			{
				for (; Path.GetWaypointFromPos(num2) != num3; num2 += num4)
				{
				}
				if (num2 > 1f)
				{
					num2 = 1f;
				}
			}
			else
			{
				int num6 = 0;
				while (Path.WaypointSamples[num6] != num3)
				{
					num2 += Path.SamplesDistances[num6++];
				}
				num2 /= Path.TotalDistance;
			}
			return num2;
		}

		private float computePosAtMinDistance()
		{
			if (target == null)
			{
				return 0f;
			}
			if (Path == null)
			{
				return 0f;
			}
			float num = float.MaxValue;
			float num2 = 1f / (float)precision;
			float num3 = 0f;
			for (int i = 0; i < precision; i++)
			{
				float num4 = Vector3.Distance(GetPositionForPos((float)i * num2), target.position);
				if (num4 < num)
				{
					num3 = (float)i * num2;
					num = num4;
				}
			}
			if (accurate)
			{
				float num5 = num3;
				for (float num6 = num5 - num2; num6 < num5 + num2; num6 += num2 / 100f)
				{
					float num7 = Vector3.Distance(GetPositionForPos(num6), target.position);
					if (num7 < num)
					{
						num3 = num6;
						num = num7;
					}
				}
			}
			return num3;
		}

		private Vector3 GetPositionForPos(float pos)
		{
			Vector3 position = Vector3.zero;
			Quaternion rotation = Quaternion.identity;
			float velocity = 1f;
			int waypoint = 0;
			if (pos < 0f)
			{
				pos = ((!Path.loop) ? 0f : (1f + pos));
			}
			if (Path.presampledPath)
			{
				Path.sampledPositionAndRotationAndVelocityAndWaypointAtPos(pos, out position, out rotation, out velocity, out waypoint);
			}
			else
			{
				position = Path.computePositionAtPos(pos);
			}
			return Path.transform.TransformPoint(position);
		}
	}
}
namespace Jacovone.Meshes
{
	[RequireComponent(typeof(MeshRenderer))]
	[RequireComponent(typeof(MeshFilter))]
	[ExecuteInEditMode]
	public abstract class PathMagicMesh : MonoBehaviour
	{
		private MeshFilter _mf;

		public Mesh mesh;

		public PathMagic path;

		public float startingFrom;

		public float endTo = 1f;

		public int pieces = 20;

		public int sections = 5;

		public bool flipped;

		protected List<Vector3> vertices;

		protected List<int> triangles;

		protected List<int> triangles2;

		protected List<int> triangles3;

		protected List<Vector3> normals;

		protected List<Vector2> UVs;

		public bool autoUpdateMesh = true;

		public void Generate()
		{
			if (path == null)
			{
				UnityEngine.Debug.LogWarning("Please assign path attribute!");
				return;
			}
			if (pieces < 3)
			{
				pieces = 3;
			}
			if (sections < 2)
			{
				sections = 2;
			}
			_mf = GetComponent<MeshFilter>();
			this.mesh = _mf.sharedMesh;
			if (this.mesh == null)
			{
				Mesh mesh2 = (_mf.sharedMesh = new Mesh());
				this.mesh = mesh2;
			}
			if (this.mesh == null)
			{
				this.mesh = new Mesh();
			}
			this.mesh.Clear();
			vertices = new List<Vector3>();
			normals = new List<Vector3>();
			triangles = new List<int>();
			triangles2 = new List<int>();
			triangles3 = new List<int>();
			UVs = new List<Vector2>();
			InitializeMesh();
			for (int i = 0; i <= pieces; i++)
			{
				float pos = startingFrom + 1f / (float)pieces * (float)i * (endTo - startingFrom);
				Vector3 position;
				Quaternion rotation;
				if (path.PresampledPath)
				{
					path.sampledPositionAndRotationAndVelocityAndWaypointAtPos(pos, out position, out rotation, out var _, out var _);
					position = path.transform.TransformPoint(position);
					rotation = path.transform.rotation * rotation;
				}
				else
				{
					position = path.transform.TransformPoint(path.computePositionAtPos(pos));
					rotation = path.transform.rotation * path.computeRotationAtPos(pos);
				}
				Vector3 direction = rotation * Vector3.forward;
				Vector3 normalized = (rotation * Vector3.right).normalized;
				Vector3 normalized2 = (rotation * -Vector3.up).normalized;
				GenerateMeshPart(i, position, direction, normalized, normalized2);
			}
			FinalizeMesh();
			this.mesh.vertices = vertices.ToArray();
			this.mesh.normals = normals.ToArray();
			this.mesh.subMeshCount = GetNumberOfMaterials();
			this.mesh.uv = UVs.ToArray();
			if (GetNumberOfMaterials() >= 1)
			{
				this.mesh.SetTriangles(triangles, 0);
			}
			if (GetNumberOfMaterials() >= 2)
			{
				this.mesh.SetTriangles(triangles2, 1);
			}
			if (GetNumberOfMaterials() >= 3)
			{
				this.mesh.SetTriangles(triangles3, 2);
			}
			this.mesh.RecalculateBounds();
		}

		protected void AddQuad1(int a, int b, int c, int d)
		{
			if (flipped)
			{
				triangles.Add(c);
				triangles.Add(b);
				triangles.Add(a);
				triangles.Add(d);
				triangles.Add(b);
				triangles.Add(c);
			}
			else
			{
				triangles.Add(a);
				triangles.Add(b);
				triangles.Add(c);
				triangles.Add(c);
				triangles.Add(b);
				triangles.Add(d);
			}
		}

		protected void AddQuad2(int a, int b, int c, int d)
		{
			if (flipped)
			{
				triangles2.Add(c);
				triangles2.Add(b);
				triangles2.Add(a);
				triangles2.Add(d);
				triangles2.Add(b);
				triangles2.Add(c);
			}
			else
			{
				triangles2.Add(a);
				triangles2.Add(b);
				triangles2.Add(c);
				triangles2.Add(c);
				triangles2.Add(b);
				triangles2.Add(d);
			}
		}

		protected void AddQuad3(int a, int b, int c, int d)
		{
			if (flipped)
			{
				triangles3.Add(c);
				triangles3.Add(b);
				triangles3.Add(a);
				triangles3.Add(d);
				triangles3.Add(b);
				triangles3.Add(c);
			}
			else
			{
				triangles3.Add(a);
				triangles3.Add(b);
				triangles3.Add(c);
				triangles3.Add(c);
				triangles3.Add(b);
				triangles3.Add(d);
			}
		}

		protected virtual int GetNumberOfMaterials()
		{
			return 1;
		}

		protected abstract void InitializeMesh();

		protected abstract void FinalizeMesh();

		protected abstract void GenerateMeshPart(int piece, Vector3 position, Vector3 direction, Vector3 xd, Vector3 yd);
	}
	public class PathMagicRoad : PathMagicMesh
	{
		public enum WidthType
		{
			Constant,
			Curve
		}

		public bool closeFront;

		public bool closeBack;

		public WidthType widthType;

		public float width = 1f;

		public float height = 0.3f;

		public AnimationCurve widthCurve;

		protected List<int> frontVertices;

		protected List<int> backVertices;

		private Vector3 frontNormal;

		private Vector3 backNormal;

		protected override void InitializeMesh()
		{
			frontVertices = new List<int>(sections);
			backVertices = new List<int>(sections);
		}

		protected override void FinalizeMesh()
		{
			if (closeFront)
			{
				int index = frontVertices[0];
				int index2 = frontVertices[1];
				int index3 = frontVertices[2];
				int index4 = frontVertices[3];
				Vector3 item = vertices[index];
				Vector3 item2 = vertices[index2];
				Vector3 item3 = vertices[index3];
				Vector3 item4 = vertices[index4];
				vertices.Add(item);
				UVs.Add(new Vector2(0f, 0f));
				normals.Add(frontNormal);
				index = vertices.Count - 1;
				vertices.Add(item2);
				UVs.Add(new Vector2(1f, 0f));
				normals.Add(frontNormal);
				index2 = vertices.Count - 1;
				vertices.Add(item3);
				UVs.Add(new Vector2(1f, 1f));
				normals.Add(frontNormal);
				index3 = vertices.Count - 1;
				vertices.Add(item4);
				UVs.Add(new Vector2(0f, 1f));
				normals.Add(frontNormal);
				index4 = vertices.Count - 1;
				AddQuad3(index3, index2, index4, index);
			}
			if (closeBack)
			{
				int index5 = backVertices[0];
				int index6 = backVertices[1];
				int index7 = backVertices[2];
				int index8 = backVertices[3];
				Vector3 item5 = vertices[index5];
				Vector3 item6 = vertices[index6];
				Vector3 item7 = vertices[index7];
				Vector3 item8 = vertices[index8];
				vertices.Add(item5);
				UVs.Add(new Vector2(0f, 0f));
				normals.Add(backNormal);
				index5 = vertices.Count - 1;
				vertices.Add(item6);
				UVs.Add(new Vector2(1f, 0f));
				normals.Add(backNormal);
				index6 = vertices.Count - 1;
				vertices.Add(item7);
				UVs.Add(new Vector2(1f, 1f));
				normals.Add(backNormal);
				index7 = vertices.Count - 1;
				vertices.Add(item8);
				UVs.Add(new Vector2(0f, 1f));
				normals.Add(backNormal);
				index8 = vertices.Count - 1;
				AddQuad3(index5, index6, index8, index7);
			}
		}

		protected override void GenerateMeshPart(int piece, Vector3 position, Vector3 direction, Vector3 xd, Vector3 yd)
		{
			float num;
			if (widthType == WidthType.Constant)
			{
				num = width;
			}
			else
			{
				float num2 = float.MaxValue;
				float num3 = float.MinValue;
				for (int i = 0; i < widthCurve.length; i++)
				{
					float time = widthCurve.keys[i].time;
					if (time > num3)
					{
						num3 = time;
					}
					if (time < num2)
					{
						num2 = time;
					}
				}
				float num4 = num3 - num2;
				float time2 = num2 + (float)piece / (float)pieces * num4;
				num = widthCurve.Evaluate(time2);
			}
			Vector3 position2 = position + num / 2f * xd - height * Vector3.up;
			vertices.Add(base.transform.InverseTransformPoint(position2));
			UVs.Add(new Vector2(0f, (float)piece * 1f / (float)pieces));
			Vector3 item = (flipped ? xd : (-xd));
			normals.Add(item);
			if (piece == 0)
			{
				frontVertices.Add(vertices.Count - 1);
				frontNormal = (flipped ? direction : (-direction));
			}
			else if (piece == pieces)
			{
				backVertices.Add(vertices.Count - 1);
				backNormal = (flipped ? (-direction) : direction);
			}
			position2 = position + num / 2f * xd;
			vertices.Add(base.transform.InverseTransformPoint(position2));
			UVs.Add(new Vector2(1f, (float)piece * 1f / (float)pieces));
			item = (flipped ? xd : (-xd));
			normals.Add(item);
			if (piece == 0)
			{
				frontVertices.Add(vertices.Count - 1);
				frontNormal = (flipped ? direction : (-direction));
			}
			else if (piece == pieces)
			{
				backVertices.Add(vertices.Count - 1);
				backNormal = (flipped ? (-direction) : direction);
			}
			for (int j = 0; j <= sections; j++)
			{
				position2 = position + (num / 2f - (float)j / (float)sections * num) * xd;
				vertices.Add(base.transform.InverseTransformPoint(position2));
				UVs.Add(new Vector2((float)j / (float)sections, (float)piece * 1f / (float)pieces));
				item = (flipped ? yd : (-yd));
				normals.Add(item);
			}
			position2 = position - num / 2f * xd;
			vertices.Add(base.transform.InverseTransformPoint(position2));
			UVs.Add(new Vector2(1f, (float)piece * 1f / (float)pieces));
			item = (flipped ? (-xd) : xd);
			normals.Add(item);
			if (piece == 0)
			{
				frontVertices.Add(vertices.Count - 1);
				frontNormal = (flipped ? direction : (-direction));
			}
			else if (piece == pieces)
			{
				backVertices.Add(vertices.Count - 1);
				backNormal = (flipped ? (-direction) : direction);
			}
			position2 = position - num / 2f * xd - height * Vector3.up;
			vertices.Add(base.transform.InverseTransformPoint(position2));
			UVs.Add(new Vector2(0f, (float)piece * 1f / (float)pieces));
			item = (flipped ? (-xd) : xd);
			normals.Add(item);
			if (piece == 0)
			{
				frontVertices.Add(vertices.Count - 1);
				frontNormal = (flipped ? direction : (-direction));
			}
			else if (piece == pieces)
			{
				backVertices.Add(vertices.Count - 1);
				backNormal = (flipped ? (-direction) : direction);
			}
			if (piece > 0)
			{
				int num5 = piece * (sections + 5);
				int a = num5;
				int b = num5 - (sections + 5);
				int c = num5 + 1;
				int d = num5 + 1 - (sections + 5);
				AddQuad2(a, b, c, d);
				for (int k = 2; k < sections + 2; k++)
				{
					a = num5 + k;
					b = num5 + k - (sections + 5);
					c = num5 + k + 1;
					d = num5 + k + 1 - (sections + 5);
					AddQuad1(a, b, c, d);
				}
				a = num5 + sections + 3;
				b = num5 + sections + 3 - (sections + 5);
				c = num5 + sections + 3 + 1;
				d = num5 + sections + 3 + 1 - (sections + 5);
				AddQuad2(a, b, c, d);
			}
		}

		protected override int GetNumberOfMaterials()
		{
			return 3;
		}
	}
	public class PathMagicTorus : PathMagicMesh
	{
		public enum RadiusType
		{
			Constant,
			Curve
		}

		public bool closeFront;

		public bool closeBack;

		public RadiusType radiusType;

		public float radius = 1f;

		public AnimationCurve radiusCurve;

		public float angleOffset;

		public float twist;

		protected List<int> frontVertices;

		protected List<int> backVertices;

		private float fTwist;

		private Vector3 frontNormal;

		private Vector3 backNormal;

		private Vector3 frontPosition;

		private Vector3 backPosition;

		protected override void InitializeMesh()
		{
			fTwist = 0f;
			frontVertices = new List<int>(sections);
			backVertices = new List<int>(sections);
		}

		protected override void FinalizeMesh()
		{
			if (closeFront)
			{
				for (int i = 0; i < frontVertices.Count - 1; i++)
				{
					int index = frontVertices[0];
					int index2 = frontVertices[i + 1];
					int index3 = frontVertices[i];
					Vector3 vector = vertices[index];
					Vector3 vector2 = vertices[index2];
					Vector3 vector3 = vertices[index3];
					vertices.Add(vector);
					UVs.Add(vector - frontPosition);
					normals.Add(frontNormal);
					index = vertices.Count - 1;
					vertices.Add(vector2);
					UVs.Add(vector2 - frontPosition);
					normals.Add(frontNormal);
					index2 = vertices.Count - 1;
					vertices.Add(vector3);
					UVs.Add(vector3 - frontPosition);
					normals.Add(frontNormal);
					index3 = vertices.Count - 1;
					if (flipped)
					{
						triangles2.Add(index3);
						triangles2.Add(index2);
						triangles2.Add(index);
					}
					else
					{
						triangles2.Add(index);
						triangles2.Add(index2);
						triangles2.Add(index3);
					}
				}
			}
			if (!closeBack)
			{
				return;
			}
			for (int j = 0; j < backVertices.Count - 1; j++)
			{
				int index4 = backVertices[0];
				int index5 = backVertices[j + 1];
				int index6 = backVertices[j];
				Vector3 vector4 = vertices[index4];
				Vector3 vector5 = vertices[index5];
				Vector3 vector6 = vertices[index6];
				vertices.Add(vector4);
				UVs.Add(vector4 - backPosition);
				normals.Add(backNormal);
				index4 = vertices.Count - 1;
				vertices.Add(vector5);
				UVs.Add(vector5 - backPosition);
				normals.Add(backNormal);
				index5 = vertices.Count - 1;
				vertices.Add(vector6);
				UVs.Add(vector6 - backPosition);
				normals.Add(backNormal);
				index6 = vertices.Count - 1;
				if (flipped)
				{
					triangles2.Add(index4);
					triangles2.Add(index5);
					triangles2.Add(index6);
				}
				else
				{
					triangles2.Add(index6);
					triangles2.Add(index5);
					triangles2.Add(index4);
				}
			}
		}

		protected override void GenerateMeshPart(int piece, Vector3 position, Vector3 direction, Vector3 xd, Vector3 yd)
		{
			float num;
			if (radiusType == RadiusType.Constant)
			{
				num = radius;
			}
			else
			{
				float num2 = float.MaxValue;
				float num3 = float.MinValue;
				for (int i = 0; i < radiusCurve.length; i++)
				{
					float time = radiusCurve.keys[i].time;
					if (time > num3)
					{
						num3 = time;
					}
					if (time < num2)
					{
						num2 = time;
					}
				}
				float num4 = num3 - num2;
				float time2 = num2 + (float)piece / (float)pieces * num4;
				num = radiusCurve.Evaluate(time2);
			}
			for (int j = 0; j <= sections; j++)
			{
				float f = (float)Math.PI / 180f * angleOffset + fTwist + (float)(j * 2) * (float)Math.PI / (float)sections;
				Vector3 vector = position + num * Mathf.Sin(f) * xd + num * Mathf.Cos(f) * yd;
				vertices.Add(base.transform.InverseTransformPoint(vector));
				UVs.Add(new Vector2((float)j * 1f / (float)sections, (float)piece * 1f / (float)pieces));
				Vector3 item = (flipped ? (position - vector).normalized : (vector - position).normalized);
				normals.Add(item);
				if (piece == 0)
				{
					frontVertices.Add(vertices.Count - 1);
					frontNormal = (flipped ? direction : (-direction));
					frontPosition = base.transform.InverseTransformPoint(position);
				}
				else if (piece == pieces)
				{
					backVertices.Add(vertices.Count - 1);
					backNormal = (flipped ? (-direction) : direction);
					backPosition = base.transform.InverseTransformPoint(position);
				}
			}
			fTwist += twist / 100f;
			if (piece > 0)
			{
				for (int k = 0; k < sections; k++)
				{
					int num5 = piece * (sections + 1);
					int a = num5 + k;
					int b = num5 + k - (sections + 1);
					int c = num5 + k + 1;
					int d = num5 + k + 1 - (sections + 1);
					AddQuad1(a, b, c, d);
				}
			}
		}

		protected override int GetNumberOfMaterials()
		{
			return 2;
		}
	}
}
namespace ONSPPropagationInterface
{
	public enum FaceType : uint
	{
		TRIANGLES,
		QUADS
	}
	public enum MaterialProperty : uint
	{
		ABSORPTION,
		TRANSMISSION,
		SCATTERING
	}
	[StructLayout(LayoutKind.Sequential, Pack = 1)]
	public struct MeshGroup
	{
		public UIntPtr indexOffset;

		public UIntPtr faceCount;

		[MarshalAs(UnmanagedType.U4)]
		public FaceType faceType;

		public IntPtr material;
	}
	public enum ovrAudioScalarType : uint
	{
		Int8,
		UInt8,
		Int16,
		UInt16,
		Int32,
		UInt32,
		Int64,
		UInt64,
		Float16,
		Float32,
		Float64
	}
}
namespace ONSPPropagationInterface.FMOD
{
	public class PropIFace
	{
		private static IntPtr context_ = IntPtr.Zero;

		public const string strOSPS = "OculusSpatializerFMOD";

		private static IntPtr context
		{
			get
			{
				if (context_ == IntPtr.Zero)
				{
					ovrAudio_GetPluginContext(out context_);
				}
				return context_;
			}
		}

		[DllImport("OculusSpatializerFMOD")]
		public static extern int ovrAudio_GetPluginContext(out IntPtr context);

		[DllImport("OculusSpatializerFMOD")]
		public static extern int ovrAudio_SetPropagationQuality(IntPtr context, float quality);

		public static int SetPropagationQuality(float quality)
		{
			return ovrAudio_SetPropagationQuality(context, quality);
		}

		[DllImport("OculusSpatializerFMOD")]
		public static extern int ovrAudio_SetPropagationThreadAffinity(IntPtr context, ulong cpuMask);

		public static int SetPropagationThreadAffinity(ulong cpuMask)
		{
			return ovrAudio_SetPropagationThreadAffinity(context, cpuMask);
		}

		[DllImport("OculusSpatializerFMOD")]
		public static extern int ovrAudio_CreateAudioGeometry(IntPtr context, out IntPtr geometry);

		public static int CreateAudioGeometry(out IntPtr geometry)
		{
			return ovrAudio_CreateAudioGeometry(context, out geometry);
		}

		[DllImport("OculusSpatializerFMOD")]
		public static extern int ovrAudio_DestroyAudioGeometry(IntPtr geometry);

		public static int DestroyAudioGeometry(IntPtr geometry)
		{
			return ovrAudio_DestroyAudioGeometry(geometry);
		}

		[DllImport("OculusSpatializerFMOD")]
		public static extern int ovrAudio_AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, UIntPtr verticesBytesOffset, UIntPtr vertexCount, UIntPtr vertexStride, ovrAudioScalarType vertexType, int[] indices, UIntPtr indicesByteOffset, UIntPtr indexCount, ovrAudioScalarType indexType, MeshGroup[] groups, UIntPtr groupCount);

		public static int AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, int vertexCount, int[] indices, int indexCount, MeshGroup[] groups, int groupCount)
		{
			return ovrAudio_AudioGeometryUploadMeshArrays(geometry, vertices, UIntPtr.Zero, (UIntPtr)(ulong)vertexCount, UIntPtr.Zero, ovrAudioScalarType.Float32, indices, UIntPtr.Zero, (UIntPtr)(ulong)indexCount, ovrAudioScalarType.UInt32, groups, (UIntPtr)(ulong)groupCount);
		}

		[DllImport("OculusSpatializerFMOD")]
		public static extern int ovrAudio_AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4);

		public static int AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4)
		{
			return ovrAudio_AudioGeometrySetTransform(geometry, matrix4x4);
		}

		[DllImport("OculusSpatializerFMOD")]
		public static extern int ovrAudio_AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4);

		public static int AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4)
		{
			return ovrAudio_AudioGeometryGetTransform(geometry, out matrix4x4);
		}

		[DllImport("OculusSpatializerFMOD")]
		public static extern int ovrAudio_AudioGeometryWriteMeshFile(IntPtr geometry, string filePath);

		public static int AudioGeometryWriteMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryWriteMeshFile(geometry, filePath);
		}

		[DllImport("OculusSpatializerFMOD")]
		public static extern int ovrAudio_AudioGeometryReadMeshFile(IntPtr geometry, string filePath);

		public static int AudioGeometryReadMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryReadMeshFile(geometry, filePath);
		}

		[DllImport("OculusSpatializerFMOD")]
		public static extern int ovrAudio_CreateAudioMaterial(IntPtr context, out IntPtr material);

		public static int CreateAudioMaterial(out IntPtr material)
		{
			return ovrAudio_CreateAudioMaterial(context, out material);
		}

		[DllImport("OculusSpatializerFMOD")]
		public static extern int ovrAudio_DestroyAudioMaterial(IntPtr material);

		public static int DestroyAudioMaterial(IntPtr material)
		{
			return ovrAudio_DestroyAudioMaterial(material);
		}

		[DllImport("OculusSpatializerFMOD")]
		public static extern int ovrAudio_AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value);

		public static int AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value)
		{
			return ovrAudio_AudioMaterialSetFrequency(material, property, frequency, value);
		}

		[DllImport("OculusSpatializerFMOD")]
		public static extern int ovrAudio_AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value);

		public static int AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value)
		{
			return ovrAudio_AudioMaterialGetFrequency(material, property, frequency, out value);
		}

		[DllImport("OculusSpatializerFMOD")]
		public static extern int ovrAudio_AudioMaterialReset(IntPtr material, MaterialProperty property);

		public static int AudioMaterialReset(IntPtr material, MaterialProperty property)
		{
			return ovrAudio_AudioMaterialReset(material, property);
		}
	}
}
namespace ONSPPropagationInterface.Wwise
{
	public class PropIFace
	{
		private static IntPtr context_ = IntPtr.Zero;

		public const string strOSPS = "OculusSpatializerWwise";

		private static IntPtr context
		{
			get
			{
				if (context_ == IntPtr.Zero)
				{
					ovrAudio_GetPluginContext(out context_);
				}
				return context_;
			}
		}

		[DllImport("OculusSpatializerWwise")]
		public static extern int ovrAudio_GetPluginContext(out IntPtr context);

		[DllImport("OculusSpatializerWwise")]
		public static extern int ovrAudio_SetPropagationQuality(IntPtr context, float quality);

		public static int SetPropagationQuality(float quality)
		{
			return ovrAudio_SetPropagationQuality(context, quality);
		}

		[DllImport("OculusSpatializerWwise")]
		public static extern int ovrAudio_SetPropagationThreadAffinity(IntPtr context, ulong cpuMask);

		public static int SetPropagationThreadAffinity(ulong cpuMask)
		{
			return ovrAudio_SetPropagationThreadAffinity(context, cpuMask);
		}

		[DllImport("OculusSpatializerWwise")]
		public static extern int ovrAudio_CreateAudioGeometry(IntPtr context, out IntPtr geometry);

		public static int CreateAudioGeometry(out IntPtr geometry)
		{
			return ovrAudio_CreateAudioGeometry(context, out geometry);
		}

		[DllImport("OculusSpatializerWwise")]
		public static extern int ovrAudio_DestroyAudioGeometry(IntPtr geometry);

		public static int DestroyAudioGeometry(IntPtr geometry)
		{
			return ovrAudio_DestroyAudioGeometry(geometry);
		}

		[DllImport("OculusSpatializerWwise")]
		public static extern int ovrAudio_AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, UIntPtr verticesBytesOffset, UIntPtr vertexCount, UIntPtr vertexStride, ovrAudioScalarType vertexType, int[] indices, UIntPtr indicesByteOffset, UIntPtr indexCount, ovrAudioScalarType indexType, MeshGroup[] groups, UIntPtr groupCount);

		public static int AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, int vertexCount, int[] indices, int indexCount, MeshGroup[] groups, int groupCount)
		{
			return ovrAudio_AudioGeometryUploadMeshArrays(geometry, vertices, UIntPtr.Zero, (UIntPtr)(ulong)vertexCount, UIntPtr.Zero, ovrAudioScalarType.Float32, indices, UIntPtr.Zero, (UIntPtr)(ulong)indexCount, ovrAudioScalarType.UInt32, groups, (UIntPtr)(ulong)groupCount);
		}

		[DllImport("OculusSpatializerWwise")]
		public static extern int ovrAudio_AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4);

		public static int AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4)
		{
			return ovrAudio_AudioGeometrySetTransform(geometry, matrix4x4);
		}

		[DllImport("OculusSpatializerWwise")]
		public static extern int ovrAudio_AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4);

		public static int AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4)
		{
			return ovrAudio_AudioGeometryGetTransform(geometry, out matrix4x4);
		}

		[DllImport("OculusSpatializerWwise")]
		public static extern int ovrAudio_AudioGeometryWriteMeshFile(IntPtr geometry, string filePath);

		public static int AudioGeometryWriteMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryWriteMeshFile(geometry, filePath);
		}

		[DllImport("OculusSpatializerWwise")]
		public static extern int ovrAudio_AudioGeometryReadMeshFile(IntPtr geometry, string filePath);

		public static int AudioGeometryReadMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryReadMeshFile(geometry, filePath);
		}

		[DllImport("OculusSpatializerWwise")]
		public static extern int ovrAudio_CreateAudioMaterial(IntPtr context, out IntPtr material);

		public static int CreateAudioMaterial(out IntPtr material)
		{
			return ovrAudio_CreateAudioMaterial(context, out material);
		}

		[DllImport("OculusSpatializerWwise")]
		public static extern int ovrAudio_DestroyAudioMaterial(IntPtr material);

		public static int DestroyAudioMaterial(IntPtr material)
		{
			return ovrAudio_DestroyAudioMaterial(material);
		}

		[DllImport("OculusSpatializerWwise")]
		public static extern int ovrAudio_AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value);

		public static int AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value)
		{
			return ovrAudio_AudioMaterialSetFrequency(material, property, frequency, value);
		}

		[DllImport("OculusSpatializerWwise")]
		public static extern int ovrAudio_AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value);

		public static int AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value)
		{
			return ovrAudio_AudioMaterialGetFrequency(material, property, frequency, out value);
		}

		[DllImport("OculusSpatializerWwise")]
		public static extern int ovrAudio_AudioMaterialReset(IntPtr material, MaterialProperty property);

		public static int AudioMaterialReset(IntPtr material, MaterialProperty property)
		{
			return ovrAudio_AudioMaterialReset(material, property);
		}
	}
}
namespace ONSPPropagationInterface.Unity_Native
{
	public class PropIFace
	{
		private static IntPtr context_ = IntPtr.Zero;

		public const string strOSPS = "AudioPluginOculusSpatializer";

		private static IntPtr context
		{
			get
			{
				if (context_ == IntPtr.Zero)
				{
					ovrAudio_GetPluginContext(out context_);
				}
				return context_;
			}
		}

		[DllImport("AudioPluginOculusSpatializer")]
		public static extern int ovrAudio_GetPluginContext(out IntPtr context);

		[DllImport("AudioPluginOculusSpatializer")]
		public static extern int ovrAudio_SetPropagationQuality(IntPtr context, float quality);

		public static int SetPropagationQuality(float quality)
		{
			return ovrAudio_SetPropagationQuality(context, quality);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		public static extern int ovrAudio_SetPropagationThreadAffinity(IntPtr context, ulong cpuMask);

		public static int SetPropagationThreadAffinity(ulong cpuMask)
		{
			return ovrAudio_SetPropagationThreadAffinity(context, cpuMask);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		public static extern int ovrAudio_CreateAudioGeometry(IntPtr context, out IntPtr geometry);

		public static int CreateAudioGeometry(out IntPtr geometry)
		{
			return ovrAudio_CreateAudioGeometry(context, out geometry);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		public static extern int ovrAudio_DestroyAudioGeometry(IntPtr geometry);

		public static int DestroyAudioGeometry(IntPtr geometry)
		{
			return ovrAudio_DestroyAudioGeometry(geometry);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		public static extern int ovrAudio_AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, UIntPtr verticesBytesOffset, UIntPtr vertexCount, UIntPtr vertexStride, ovrAudioScalarType vertexType, int[] indices, UIntPtr indicesByteOffset, UIntPtr indexCount, ovrAudioScalarType indexType, MeshGroup[] groups, UIntPtr groupCount);

		public static int AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, int vertexCount, int[] indices, int indexCount, MeshGroup[] groups, int groupCount)
		{
			return ovrAudio_AudioGeometryUploadMeshArrays(geometry, vertices, UIntPtr.Zero, (UIntPtr)(ulong)vertexCount, UIntPtr.Zero, ovrAudioScalarType.Float32, indices, UIntPtr.Zero, (UIntPtr)(ulong)indexCount, ovrAudioScalarType.UInt32, groups, (UIntPtr)(ulong)groupCount);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		public static extern int ovrAudio_AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4);

		public static int AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4)
		{
			return ovrAudio_AudioGeometrySetTransform(geometry, matrix4x4);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		public static extern int ovrAudio_AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4);

		public static int AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4)
		{
			return ovrAudio_AudioGeometryGetTransform(geometry, out matrix4x4);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		public static extern int ovrAudio_AudioGeometryWriteMeshFile(IntPtr geometry, string filePath);

		public static int AudioGeometryWriteMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryWriteMeshFile(geometry, filePath);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		public static extern int ovrAudio_AudioGeometryReadMeshFile(IntPtr geometry, string filePath);

		public static int AudioGeometryReadMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryReadMeshFile(geometry, filePath);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		public static extern int ovrAudio_CreateAudioMaterial(IntPtr context, out IntPtr material);

		public static int CreateAudioMaterial(out IntPtr material)
		{
			return ovrAudio_CreateAudioMaterial(context, out material);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		public static extern int ovrAudio_DestroyAudioMaterial(IntPtr material);

		public static int DestroyAudioMaterial(IntPtr material)
		{
			return ovrAudio_DestroyAudioMaterial(material);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		public static extern int ovrAudio_AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value);

		public static int AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value)
		{
			return ovrAudio_AudioMaterialSetFrequency(material, property, frequency, value);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		public static extern int ovrAudio_AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value);

		public static int AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value)
		{
			return ovrAudio_AudioMaterialGetFrequency(material, property, frequency, out value);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		public static extern int ovrAudio_AudioMaterialReset(IntPtr material, MaterialProperty property);

		public static int AudioMaterialReset(IntPtr material, MaterialProperty property)
		{
			return ovrAudio_AudioMaterialReset(material, property);
		}
	}
}
namespace DigitalOpus.MB.Core
{
	public static class MB_TGAWriter
	{
		public static void Write(UnityEngine.Color[] pixels, int width, int height, string path)
		{
			if (File.Exists(path))
			{
				File.Delete(path);
			}
			FileStream output = File.Create(path);
			Write(pixels, width, height, output);
		}

		public static void Write(UnityEngine.Color[] pixels, int width, int height, Stream output)
		{
			byte[] array = new byte[pixels.Length * 4];
			int num = 0;
			int num2 = 0;
			for (int i = 0; i < height; i++)
			{
				for (int j = 0; j < width; j++)
				{
					UnityEngine.Color color = pixels[num];
					array[num2] = (byte)(color.b * 255f);
					array[num2 + 1] = (byte)(color.g * 255f);
					array[num2 + 2] = (byte)(color.r * 255f);
					array[num2 + 3] = (byte)(color.a * 255f);
					num++;
					num2 += 4;
				}
			}
			byte[] buffer = new byte[18]
			{
				0,
				0,
				2,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				(byte)((uint)width & 0xFFu),
				(byte)((width & 0xFF00) >> 8),
				(byte)((uint)height & 0xFFu),
				(byte)((height & 0xFF00) >> 8),
				32,
				0
			};
			using BinaryWriter binaryWriter = new BinaryWriter(output);
			binaryWriter.Write(buffer);
			binaryWriter.Write(array);
		}
	}
	public class MB_Utility
	{
		public struct MeshAnalysisResult
		{
			public Rect uvRect;

			public bool hasOutOfBoundsUVs;

			public bool hasOverlappingSubmeshVerts;

			public bool hasOverlappingSubmeshTris;

			public bool hasUVs;

			public float submeshArea;
		}

		private class MB_Triangle
		{
			private int submeshIdx;

			private int[] vs = new int[3];

			public bool isSame(object obj)
			{
				MB_Triangle mB_Triangle = (MB_Triangle)obj;
				if (vs[0] == mB_Triangle.vs[0] && vs[1] == mB_Triangle.vs[1] && vs[2] == mB_Triangle.vs[2] && submeshIdx != mB_Triangle.submeshIdx)
				{
					return true;
				}
				return false;
			}

			public bool sharesVerts(MB_Triangle obj)
			{
				if ((vs[0] == obj.vs[0] || vs[0] == obj.vs[1] || vs[0] == obj.vs[2]) && submeshIdx != obj.submeshIdx)
				{
					return true;
				}
				if ((vs[1] == obj.vs[0] || vs[1] == obj.vs[1] || vs[1] == obj.vs[2]) && submeshIdx != obj.submeshIdx)
				{
					return true;
				}
				if ((vs[2] == obj.vs[0] || vs[2] == obj.vs[1] || vs[2] == obj.vs[2]) && submeshIdx != obj.submeshIdx)
				{
					return true;
				}
				return false;
			}

			public void Initialize(int[] ts, int idx, int sIdx)
			{
				vs[0] = ts[idx];
				vs[1] = ts[idx + 1];
				vs[2] = ts[idx + 2];
				submeshIdx = sIdx;
				Array.Sort(vs);
			}
		}

		public static bool DO_INTEGRITY_CHECKS;

		public static Texture2D createTextureCopy(Texture2D source)
		{
			Texture2D texture2D = new Texture2D(source.width, source.height, TextureFormat.ARGB32, mipChain: true);
			texture2D.SetPixels(source.GetPixels());
			return texture2D;
		}

		public static bool ArrayBIsSubsetOfA(object[] a, object[] b)
		{
			for (int i = 0; i < b.Length; i++)
			{
				bool flag = false;
				for (int j = 0; j < a.Length; j++)
				{
					if (a[j] == b[i])
					{
						flag = true;
						break;
					}
				}
				if (!flag)
				{
					return false;
				}
			}
			return true;
		}

		public static Material[] GetGOMaterials(GameObject go)
		{
			if (go == null)
			{
				return null;
			}
			Material[] array = null;
			Mesh mesh = null;
			MeshRenderer component = go.GetComponent<MeshRenderer>();
			if (component != null)
			{
				array = component.sharedMaterials;
				MeshFilter component2 = go.GetComponent<MeshFilter>();
				if (component2 == null)
				{
					throw new Exception(string.Concat("Object ", go, " has a MeshRenderer but no MeshFilter."));
				}
				mesh = component2.sharedMesh;
			}
			SkinnedMeshRenderer component3 = go.GetComponent<SkinnedMeshRenderer>();
			if (component3 != null)
			{
				array = component3.sharedMaterials;
				mesh = component3.sharedMesh;
			}
			if (array == null)
			{
				UnityEngine.Debug.LogError("Object " + go.name + " does not have a MeshRenderer or a SkinnedMeshRenderer component");
				return new Material[0];
			}
			if (mesh == null)
			{
				UnityEngine.Debug.LogError("Object " + go.name + " has a MeshRenderer or SkinnedMeshRenderer but no mesh.");
				return new Material[0];
			}
			if (mesh.subMeshCount < array.Length)
			{
				UnityEngine.Debug.LogWarning(string.Concat("Object ", go, " has only ", mesh.subMeshCount, " submeshes and has ", array.Length, " materials. Extra materials do nothing."));
				Material[] array2 = new Material[mesh.subMeshCount];
				Array.Copy(array, array2, array2.Length);
				array = array2;
			}
			return array;
		}

		public static Mesh GetMesh(GameObject go)
		{
			if (go == null)
			{
				return null;
			}
			MeshFilter component = go.GetComponent<MeshFilter>();
			if (component != null)
			{
				return component.sharedMesh;
			}
			SkinnedMeshRenderer component2 = go.GetComponent<SkinnedMeshRenderer>();
			if (component2 != null)
			{
				return component2.sharedMesh;
			}
			return null;
		}

		public static void SetMesh(GameObject go, Mesh m)
		{
			if (go == null)
			{
				return;
			}
			MeshFilter component = go.GetComponent<MeshFilter>();
			if (component != null)
			{
				component.sharedMesh = m;
				return;
			}
			SkinnedMeshRenderer component2 = go.GetComponent<SkinnedMeshRenderer>();
			if (component2 != null)
			{
				component2.sharedMesh = m;
			}
		}

		public static Renderer GetRenderer(GameObject go)
		{
			if (go == null)
			{
				return null;
			}
			MeshRenderer component = go.GetComponent<MeshRenderer>();
			if (component != null)
			{
				return component;
			}
			SkinnedMeshRenderer component2 = go.GetComponent<SkinnedMeshRenderer>();
			if (component2 != null)
			{
				return component2;
			}
			return null;
		}

		public static void DisableRendererInSource(GameObject go)
		{
			if (go == null)
			{
				return;
			}
			MeshRenderer component = go.GetComponent<MeshRenderer>();
			if (component != null)
			{
				component.enabled = false;
				return;
			}
			SkinnedMeshRenderer component2 = go.GetComponent<SkinnedMeshRenderer>();
			if (component2 != null)
			{
				component2.enabled = false;
			}
		}

		public static bool hasOutOfBoundsUVs(Mesh m, ref Rect uvBounds)
		{
			MeshAnalysisResult putResultHere = default(MeshAnalysisResult);
			bool result = hasOutOfBoundsUVs(m, ref putResultHere);
			uvBounds = putResultHere.uvRect;
			return result;
		}

		public static bool hasOutOfBoundsUVs(Mesh m, ref MeshAnalysisResult putResultHere, int submeshIndex = -1, int uvChannel = 0)
		{
			if (m == null)
			{
				putResultHere.hasOutOfBoundsUVs = false;
				return putResultHere.hasOutOfBoundsUVs;
			}
			return hasOutOfBoundsUVs(uvChannel switch
			{
				0 => m.uv, 
				1 => m.uv2, 
				2 => m.uv3, 
				_ => m.uv4, 
			}, m, ref putResultHere, submeshIndex);
		}

		public static bool hasOutOfBoundsUVs(Vector2[] uvs, Mesh m, ref MeshAnalysisResult putResultHere, int submeshIndex = -1)
		{
			putResultHere.hasUVs = true;
			if (uvs.Length == 0)
			{
				putResultHere.hasUVs = false;
				putResultHere.hasOutOfBoundsUVs = false;
				putResultHere.uvRect = default(Rect);
				return putResultHere.hasOutOfBoundsUVs;
			}
			if (submeshIndex >= m.subMeshCount)
			{
				putResultHere.hasOutOfBoundsUVs = false;
				putResultHere.uvRect = default(Rect);
				return putResultHere.hasOutOfBoundsUVs;
			}
			float num;
			float x;
			float num2;
			float y;
			if (submeshIndex >= 0)
			{
				int[] triangles = m.GetTriangles(submeshIndex);
				if (triangles.Length == 0)
				{
					putResultHere.hasOutOfBoundsUVs = false;
					putResultHere.uvRect = default(Rect);
					return putResultHere.hasOutOfBoundsUVs;
				}
				num = (x = uvs[triangles[0]].x);
				num2 = (y = uvs[triangles[0]].y);
				foreach (int num3 in triangles)
				{
					if (uvs[num3].x < num)
					{
						num = uvs[num3].x;
					}
					if (uvs[num3].x > x)
					{
						x = uvs[num3].x;
					}
					if (uvs[num3].y < num2)
					{
						num2 = uvs[num3].y;
					}
					if (uvs[num3].y > y)
					{
						y = uvs[num3].y;
					}
				}
			}
			else
			{
				num = (x = uvs[0].x);
				num2 = (y = uvs[0].y);
				for (int j = 0; j < uvs.Length; j++)
				{
					if (uvs[j].x < num)
					{
						num = uvs[j].x;
					}
					if (uvs[j].x > x)
					{
						x = uvs[j].x;
					}
					if (uvs[j].y < num2)
					{
						num2 = uvs[j].y;
					}
					if (uvs[j].y > y)
					{
						y = uvs[j].y;
					}
				}
			}
			Rect uvRect = default(Rect);
			uvRect.x = num;
			uvRect.y = num2;
			uvRect.width = x - num;
			uvRect.height = y - num2;
			if (x > 1f || num < 0f || y > 1f || num2 < 0f)
			{
				putResultHere.hasOutOfBoundsUVs = true;
			}
			else
			{
				putResultHere.hasOutOfBoundsUVs = false;
			}
			putResultHere.uvRect = uvRect;
			return putResultHere.hasOutOfBoundsUVs;
		}

		public static void setSolidColor(Texture2D t, UnityEngine.Color c)
		{
			UnityEngine.Color[] pixels = t.GetPixels();
			for (int i = 0; i < pixels.Length; i++)
			{
				pixels[i] = c;
			}
			t.SetPixels(pixels);
			t.Apply();
		}

		public static Texture2D resampleTexture(Texture2D source, int newWidth, int newHeight)
		{
			TextureFormat format = source.format;
			if (format == TextureFormat.ARGB32 || format == TextureFormat.RGBA32 || format == TextureFormat.BGRA32 || format == TextureFormat.RGB24 || format == TextureFormat.Alpha8 || format == TextureFormat.DXT1)
			{
				Texture2D texture2D = new Texture2D(newWidth, newHeight, TextureFormat.ARGB32, mipChain: true);
				float num = newWidth;
				float num2 = newHeight;
				for (int i = 0; i < newWidth; i++)
				{
					for (int j = 0; j < newHeight; j++)
					{
						float x = (float)i / num;
						float y = (float)j / num2;
						texture2D.SetPixel(i, j, source.GetPixelBilinear(x, y));
					}
				}
				texture2D.Apply();
				return texture2D;
			}
			UnityEngine.Debug.LogError("Can only resize textures in formats ARGB32, RGBA32, BGRA32, RGB24, Alpha8 or DXT");
			return null;
		}

		public static bool AreAllSharedMaterialsDistinct(Material[] sharedMaterials)
		{
			for (int i = 0; i < sharedMaterials.Length; i++)
			{
				for (int j = i + 1; j < sharedMaterials.Length; j++)
				{
					if (sharedMaterials[i] == sharedMaterials[j])
					{
						return false;
					}
				}
			}
			return true;
		}

		public static int doSubmeshesShareVertsOrTris(Mesh m, ref MeshAnalysisResult mar)
		{
			MB_Triangle mB_Triangle = new MB_Triangle();
			MB_Triangle mB_Triangle2 = new MB_Triangle();
			int[][] array = new int[m.subMeshCount][];
			for (int i = 0; i < m.subMeshCount; i++)
			{
				array[i] = m.GetTriangles(i);
			}
			bool flag = false;
			bool flag2 = false;
			for (int j = 0; j < m.subMeshCount; j++)
			{
				int[] array2 = array[j];
				for (int k = j + 1; k < m.subMeshCount; k++)
				{
					int[] array3 = array[k];
					for (int l = 0; l < array2.Length; l += 3)
					{
						mB_Triangle.Initialize(array2, l, j);
						for (int n = 0; n < array3.Length; n += 3)
						{
							mB_Triangle2.Initialize(array3, n, k);
							if (mB_Triangle.isSame(mB_Triangle2))
							{
								flag2 = true;
								break;
							}
							if (mB_Triangle.sharesVerts(mB_Triangle2))
							{
								flag = true;
								break;
							}
						}
					}
				}
			}
			if (flag2)
			{
				mar.hasOverlappingSubmeshVerts = true;
				mar.hasOverlappingSubmeshTris = true;
				return 2;
			}
			if (flag)
			{
				mar.hasOverlappingSubmeshVerts = true;
				mar.hasOverlappingSubmeshTris = false;
				return 1;
			}
			mar.hasOverlappingSubmeshTris = false;
			mar.hasOverlappingSubmeshVerts = false;
			return 0;
		}

		public static bool GetBounds(GameObject go, out Bounds b)
		{
			if (go == null)
			{
				UnityEngine.Debug.LogError("go paramater was null");
				b = new Bounds(Vector3.zero, Vector3.zero);
				return false;
			}
			Renderer renderer = GetRenderer(go);
			if (renderer == null)
			{
				UnityEngine.Debug.LogError("GetBounds must be called on an object with a Renderer");
				b = new Bounds(Vector3.zero, Vector3.zero);
				return false;
			}
			if (renderer is MeshRenderer)
			{
				b = renderer.bounds;
				return true;
			}
			if (renderer is SkinnedMeshRenderer)
			{
				b = renderer.bounds;
				return true;
			}
			UnityEngine.Debug.LogError("GetBounds must be called on an object with a MeshRender or a SkinnedMeshRenderer.");
			b = new Bounds(Vector3.zero, Vector3.zero);
			return false;
		}

		public static void Destroy(UnityEngine.Object o)
		{
			if (Application.isPlaying)
			{
				UnityEngine.Object.Destroy(o);
			}
			else
			{
				UnityEngine.Object.DestroyImmediate(o, allowDestroyingAssets: false);
			}
		}
	}
	public delegate void ProgressUpdateDelegate(string msg, float progress);
	public delegate bool ProgressUpdateCancelableDelegate(string msg, float progress);
	public enum MB_ObjsToCombineTypes
	{
		prefabOnly,
		sceneObjOnly,
		dontCare
	}
	public enum MB_OutputOptions
	{
		bakeIntoPrefab,
		bakeMeshsInPlace,
		bakeTextureAtlasesOnly,
		bakeIntoSceneObject
	}
	public enum MB_RenderType
	{
		meshRenderer,
		skinnedMeshRenderer
	}
	public enum MB2_OutputOptions
	{
		bakeIntoSceneObject,
		bakeMeshAssetsInPlace,
		bakeIntoPrefab
	}
	public enum MB2_LightmapOptions
	{
		preserve_current_lightmapping,
		ignore_UV2,
		copy_UV2_unchanged,
		generate_new_UV2_layout,
		copy_UV2_unchanged_to_separate_rects
	}
	public enum MB2_PackingAlgorithmEnum
	{
		UnitysPackTextures,
		MeshBakerTexturePacker,
		MeshBakerTexturePacker_Fast,
		MeshBakerTexturePacker_Horizontal,
		MeshBakerTexturePacker_Vertical
	}
	public enum MB_TextureTilingTreatment
	{
		none,
		considerUVs,
		edgeToEdgeX,
		edgeToEdgeY,
		edgeToEdgeXY,
		unknown
	}
	public enum MB2_ValidationLevel
	{
		none,
		quick,
		robust
	}
	public interface MB2_EditorMethodsInterface
	{
		void Clear();

		void RestoreReadFlagsAndFormats(ProgressUpdateDelegate progressInfo);

		void SetReadWriteFlag(Texture2D tx, bool isReadable, bool addToList);

		void AddTextureFormat(Texture2D tx, bool isNormalMap);

		void SaveAtlasToAssetDatabase(Texture2D atlas, ShaderTextureProperty texPropertyName, int atlasNum, Material resMat);

		bool IsNormalMap(Texture2D tx);

		string GetPlatformString();

		void SetTextureSize(Texture2D tx, int size);

		bool IsCompressed(Texture2D tx);

		void CheckBuildSettings(long estimatedAtlasSize);

		bool CheckPrefabTypes(MB_ObjsToCombineTypes prefabType, List<GameObject> gos);

		bool ValidateSkinnedMeshes(List<GameObject> mom);

		void CommitChangesToAssets();

		void OnPreTextureBake();

		void OnPostTextureBake();

		void Destroy(UnityEngine.Object o);
	}
	public enum MB2_LogLevel
	{
		none,
		error,
		warn,
		info,
		debug,
		trace
	}
	public class MB2_Log
	{
		public static void Log(MB2_LogLevel l, string msg, MB2_LogLevel currentThreshold)
		{
			if (l <= currentThreshold)
			{
				if (l == MB2_LogLevel.error)
				{
					UnityEngine.Debug.LogError(msg);
				}
				if (l == MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning($"frm={Time.frameCount} WARN {msg}");
				}
				if (l == MB2_LogLevel.info)
				{
					UnityEngine.Debug.Log($"frm={Time.frameCount} INFO {msg}");
				}
				if (l == MB2_LogLevel.debug)
				{
					UnityEngine.Debug.Log($"frm={Time.frameCount} DEBUG {msg}");
				}
				if (l == MB2_LogLevel.trace)
				{
					UnityEngine.Debug.Log($"frm={Time.frameCount} TRACE {msg}");
				}
			}
		}

		public static string Error(string msg, params object[] args)
		{
			string arg = string.Format(msg, args);
			string text = $"f={Time.frameCount} ERROR {arg}";
			UnityEngine.Debug.LogError(text);
			return text;
		}

		public static string Warn(string msg, params object[] args)
		{
			string arg = string.Format(msg, args);
			string text = $"f={Time.frameCount} WARN {arg}";
			UnityEngine.Debug.LogWarning(text);
			return text;
		}

		public static string Info(string msg, params object[] args)
		{
			string arg = string.Format(msg, args);
			string text = $"f={Time.frameCount} INFO {arg}";
			UnityEngine.Debug.Log(text);
			return text;
		}

		public static string LogDebug(string msg, params object[] args)
		{
			string arg = string.Format(msg, args);
			string text = $"f={Time.frameCount} DEBUG {arg}";
			UnityEngine.Debug.Log(text);
			return text;
		}

		public static string Trace(string msg, params object[] args)
		{
			string arg = string.Format(msg, args);
			string text = $"f={Time.frameCount} TRACE {arg}";
			UnityEngine.Debug.Log(text);
			return text;
		}
	}
	public class ObjectLog
	{
		private int pos;

		private string[] logMessages;

		private void _CacheLogMessage(string msg)
		{
			if (logMessages.Length != 0)
			{
				logMessages[pos] = msg;
				pos++;
				if (pos >= logMessages.Length)
				{
					pos = 0;
				}
			}
		}

		public ObjectLog(short bufferSize)
		{
			logMessages = new string[bufferSize];
		}

		public void Log(MB2_LogLevel l, string msg, MB2_LogLevel currentThreshold)
		{
			MB2_Log.Log(l, msg, currentThreshold);
			_CacheLogMessage(msg);
		}

		public void Error(string msg, params object[] args)
		{
			_CacheLogMessage(MB2_Log.Error(msg, args));
		}

		public void Warn(string msg, params object[] args)
		{
			_CacheLogMessage(MB2_Log.Warn(msg, args));
		}

		public void Info(string msg, params object[] args)
		{
			_CacheLogMessage(MB2_Log.Info(msg, args));
		}

		public void LogDebug(string msg, params object[] args)
		{
			_CacheLogMessage(MB2_Log.LogDebug(msg, args));
		}

		public void Trace(string msg, params object[] args)
		{
			_CacheLogMessage(MB2_Log.Trace(msg, args));
		}

		public string Dump()
		{
			StringBuilder stringBuilder = new StringBuilder();
			int num = 0;
			if (logMessages[logMessages.Length - 1] != null)
			{
				num = pos;
			}
			for (int i = 0; i < logMessages.Length; i++)
			{
				int num2 = (num + i) % logMessages.Length;
				if (logMessages[num2] == null)
				{
					break;
				}
				stringBuilder.AppendLine(logMessages[num2]);
			}
			return stringBuilder.ToString();
		}
	}
	public interface MBVersionInterface
	{
		string version();

		int GetMajorVersion();

		int GetMinorVersion();

		bool GetActive(GameObject go);

		void SetActive(GameObject go, bool isActive);

		void SetActiveRecursively(GameObject go, bool isActive);

		UnityEngine.Object[] FindSceneObjectsOfType(Type t);

		bool IsRunningAndMeshNotReadWriteable(Mesh m);

		Vector2[] GetMeshUV3orUV4(Mesh m, bool get3, MB2_LogLevel LOG_LEVEL);

		void MeshClear(Mesh m, bool t);

		void MeshAssignUV3(Mesh m, Vector2[] uv3s);

		void MeshAssignUV4(Mesh m, Vector2[] uv4s);

		Vector4 GetLightmapTilingOffset(Renderer r);

		Transform[] GetBones(Renderer r);

		void OptimizeMesh(Mesh m);

		int GetBlendShapeFrameCount(Mesh m, int shapeIndex);

		float GetBlendShapeFrameWeight(Mesh m, int shapeIndex, int frameIndex);

		void GetBlendShapeFrameVertices(Mesh m, int shapeIndex, int frameIndex, Vector3[] vs, Vector3[] ns, Vector3[] ts);

		void ClearBlendShapes(Mesh m);

		void AddBlendShapeFrame(Mesh m, string nm, float wt, Vector3[] vs, Vector3[] ns, Vector3[] ts);

		int MaxMeshVertexCount();

		void SetMeshIndexFormatAndClearMesh(Mesh m, int numVerts, bool vertices, bool justClearTriangles);
	}
	public class MBVersion
	{
		private static MBVersionInterface _MBVersion;

		private static MBVersionInterface _CreateMBVersionConcrete()
		{
			return (MBVersionInterface)Activator.CreateInstance(typeof(MBVersionConcrete));
		}

		public static string version()
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			return _MBVersion.version();
		}

		public static int GetMajorVersion()
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			return _MBVersion.GetMajorVersion();
		}

		public static int GetMinorVersion()
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			return _MBVersion.GetMinorVersion();
		}

		public static bool GetActive(GameObject go)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			return _MBVersion.GetActive(go);
		}

		public static void SetActive(GameObject go, bool isActive)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			_MBVersion.SetActive(go, isActive);
		}

		public static void SetActiveRecursively(GameObject go, bool isActive)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			_MBVersion.SetActiveRecursively(go, isActive);
		}

		public static UnityEngine.Object[] FindSceneObjectsOfType(Type t)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			return _MBVersion.FindSceneObjectsOfType(t);
		}

		public static bool IsRunningAndMeshNotReadWriteable(Mesh m)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			return _MBVersion.IsRunningAndMeshNotReadWriteable(m);
		}

		public static Vector2[] GetMeshUV3orUV4(Mesh m, bool get3, MB2_LogLevel LOG_LEVEL)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			return _MBVersion.GetMeshUV3orUV4(m, get3, LOG_LEVEL);
		}

		public static void MeshClear(Mesh m, bool t)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			_MBVersion.MeshClear(m, t);
		}

		public static void MeshAssignUV3(Mesh m, Vector2[] uv3s)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			_MBVersion.MeshAssignUV3(m, uv3s);
		}

		public static void MeshAssignUV4(Mesh m, Vector2[] uv4s)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			_MBVersion.MeshAssignUV4(m, uv4s);
		}

		public static Vector4 GetLightmapTilingOffset(Renderer r)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			return _MBVersion.GetLightmapTilingOffset(r);
		}

		public static Transform[] GetBones(Renderer r)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			return _MBVersion.GetBones(r);
		}

		public static void OptimizeMesh(Mesh m)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			_MBVersion.OptimizeMesh(m);
		}

		public static int GetBlendShapeFrameCount(Mesh m, int shapeIndex)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			return _MBVersion.GetBlendShapeFrameCount(m, shapeIndex);
		}

		public static float GetBlendShapeFrameWeight(Mesh m, int shapeIndex, int frameIndex)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			return _MBVersion.GetBlendShapeFrameWeight(m, shapeIndex, frameIndex);
		}

		public static void GetBlendShapeFrameVertices(Mesh m, int shapeIndex, int frameIndex, Vector3[] vs, Vector3[] ns, Vector3[] ts)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			_MBVersion.GetBlendShapeFrameVertices(m, shapeIndex, frameIndex, vs, ns, ts);
		}

		public static void ClearBlendShapes(Mesh m)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			_MBVersion.ClearBlendShapes(m);
		}

		public static void AddBlendShapeFrame(Mesh m, string nm, float wt, Vector3[] vs, Vector3[] ns, Vector3[] ts)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			_MBVersion.AddBlendShapeFrame(m, nm, wt, vs, ns, ts);
		}

		public static int MaxMeshVertexCount()
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			return _MBVersion.MaxMeshVertexCount();
		}

		public static void SetMeshIndexFormatAndClearMesh(Mesh m, int numVerts, bool vertices, bool justClearTriangles)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			_MBVersion.SetMeshIndexFormatAndClearMesh(m, numVerts, vertices, justClearTriangles);
		}
	}
	[Serializable]
	public class MB3_AgglomerativeClustering
	{
		[Serializable]
		public class ClusterNode
		{
			public item_s leaf;

			public ClusterNode cha;

			public ClusterNode chb;

			public int height;

			public float distToMergedCentroid;

			public Vector3 centroid;

			public int[] leafs;

			public int idx;

			public bool isUnclustered = true;

			public ClusterNode(item_s ii, int index)
			{
				leaf = ii;
				idx = index;
				leafs = new int[1];
				leafs[0] = index;
				centroid = ii.coord;
				height = 0;
			}

			public ClusterNode(ClusterNode a, ClusterNode b, int index, int h, float dist, ClusterNode[] clusters)
			{
				cha = a;
				chb = b;
				idx = index;
				leafs = new int[a.leafs.Length + b.leafs.Length];
				Array.Copy(a.leafs, leafs, a.leafs.Length);
				Array.Copy(b.leafs, 0, leafs, a.leafs.Length, b.leafs.Length);
				Vector3 zero = Vector3.zero;
				for (int i = 0; i < leafs.Length; i++)
				{
					zero += clusters[leafs[i]].centroid;
				}
				centroid = zero / leafs.Length;
				height = h;
				distToMergedCentroid = dist;
			}
		}

		[Serializable]
		public class item_s
		{
			public GameObject go;

			public Vector3 coord;
		}

		public class ClusterDistance
		{
			public ClusterNode a;

			public ClusterNode b;

			public ClusterDistance(ClusterNode aa, ClusterNode bb)
			{
				a = aa;
				b = bb;
			}
		}

		public List<item_s> items = new List<item_s>();

		public ClusterNode[] clusters;

		public bool wasCanceled;

		private const int MAX_PRIORITY_Q_SIZE = 2048;

		private float euclidean_distance(Vector3 a, Vector3 b)
		{
			return Vector3.Distance(a, b);
		}

		public bool agglomerate(ProgressUpdateCancelableDelegate progFunc)
		{
			wasCanceled = true;
			if (progFunc != null)
			{
				wasCanceled = progFunc("Filling Priority Queue:", 0f);
			}
			if (items.Count <= 1)
			{
				clusters = new ClusterNode[0];
				return false;
			}
			clusters = new ClusterNode[items.Count * 2 - 1];
			for (int i = 0; i < items.Count; i++)
			{
				clusters[i] = new ClusterNode(items[i], i);
			}
			int num = items.Count;
			List<ClusterNode> list = new List<ClusterNode>();
			for (int j = 0; j < num; j++)
			{
				clusters[j].isUnclustered = true;
				list.Add(clusters[j]);
			}
			int num2 = 0;
			new Stopwatch().Start();
			float num3 = 0f;
			long num4 = GC.GetTotalMemory(forceFullCollection: false) / 1000000;
			PriorityQueue<float, ClusterDistance> priorityQueue = new PriorityQueue<float, ClusterDistance>();
			int num5 = 0;
			while (list.Count > 1)
			{
				int num6 = 0;
				num2++;
				if (priorityQueue.Count == 0)
				{
					num5++;
					num4 = GC.GetTotalMemory(forceFullCollection: false) / 1000000;
					if (progFunc != null)
					{
						wasCanceled = progFunc("Refilling Q:" + (float)(items.Count - list.Count) * 100f / (float)items.Count + " unclustered:" + list.Count + " inQ:" + priorityQueue.Count + " usedMem:" + num4, (float)(items.Count - list.Count) / (float)items.Count);
					}
					num3 = _RefillPriorityQWithSome(priorityQueue, list, clusters, progFunc);
					if (priorityQueue.Count == 0)
					{
						break;
					}
				}
				KeyValuePair<float, ClusterDistance> keyValuePair = priorityQueue.Dequeue();
				while (!keyValuePair.Value.a.isUnclustered || !keyValuePair.Value.b.isUnclustered)
				{
					if (priorityQueue.Count == 0)
					{
						num5++;
						num4 = GC.GetTotalMemory(forceFullCollection: false) / 1000000;
						if (progFunc != null)
						{
							wasCanceled = progFunc("Creating clusters:" + (float)(items.Count - list.Count) * 100f / (float)items.Count + " unclustered:" + list.Count + " inQ:" + priorityQueue.Count + " usedMem:" + num4, (float)(items.Count - list.Count) / (float)items.Count);
						}
						num3 = _RefillPriorityQWithSome(priorityQueue, list, clusters, progFunc);
						if (priorityQueue.Count == 0)
						{
							break;
						}
					}
					keyValuePair = priorityQueue.Dequeue();
					num6++;
				}
				num++;
				ClusterNode clusterNode = new ClusterNode(keyValuePair.Value.a, keyValuePair.Value.b, num - 1, num2, keyValuePair.Key, clusters);
				list.Remove(keyValuePair.Value.a);
				list.Remove(keyValuePair.Value.b);
				keyValuePair.Value.a.isUnclustered = false;
				keyValuePair.Value.b.isUnclustered = false;
				int num7 = num - 1;
				if (num7 == clusters.Length)
				{
					UnityEngine.Debug.LogError("how did this happen");
				}
				clusters[num7] = clusterNode;
				list.Add(clusterNode);
				clusterNode.isUnclustered = true;
				for (int k = 0; k < list.Count - 1; k++)
				{
					float num8 = euclidean_distance(clusterNode.centroid, list[k].centroid);
					if (num8 < num3)
					{
						priorityQueue.Add(new KeyValuePair<float, ClusterDistance>(num8, new ClusterDistance(clusterNode, list[k])));
					}
				}
				if (wasCanceled)
				{
					break;
				}
				num4 = GC.GetTotalMemory(forceFullCollection: false) / 1000000;
				if (progFunc != null)
				{
					wasCanceled = progFunc("Creating clusters:" + (float)(items.Count - list.Count) * 100f / (float)items.Count + " unclustered:" + list.Count + " inQ:" + priorityQueue.Count + " usedMem:" + num4, (float)(items.Count - list.Count) / (float)items.Count);
				}
			}
			if (progFunc != null)
			{
				wasCanceled = progFunc("Finished clustering:", 100f);
			}
			if (wasCanceled)
			{
				return false;
			}
			return true;
		}

		private float _RefillPriorityQWithSome(PriorityQueue<float, ClusterDistance> pq, List<ClusterNode> unclustered, ClusterNode[] clusters, ProgressUpdateCancelableDelegate progFunc)
		{
			List<float> list = new List<float>(2048);
			for (int i = 0; i < unclustered.Count; i++)
			{
				for (int j = i + 1; j < unclustered.Count; j++)
				{
					list.Add(euclidean_distance(unclustered[i].centroid, unclustered[j].centroid));
				}
				wasCanceled = progFunc("Refilling Queue Part A:", (float)i / ((float)unclustered.Count * 2f));
				if (wasCanceled)
				{
					return 10f;
				}
			}
			if (list.Count == 0)
			{
				return 1E+11f;
			}
			float num = NthSmallestElement(list, 2048);
			for (int k = 0; k < unclustered.Count; k++)
			{
				for (int l = k + 1; l < unclustered.Count; l++)
				{
					int idx = unclustered[k].idx;
					int idx2 = unclustered[l].idx;
					float num2 = euclidean_distance(unclustered[k].centroid, unclustered[l].centroid);
					if (num2 <= num)
					{
						pq.Add(new KeyValuePair<float, ClusterDistance>(num2, new ClusterDistance(clusters[idx], clusters[idx2])));
					}
				}
				wasCanceled = progFunc("Refilling Queue Part B:", (float)(unclustered.Count + k) / ((float)unclustered.Count * 2f));
				if (wasCanceled)
				{
					return 10f;
				}
			}
			return num;
		}

		public int TestRun(List<GameObject> gos)
		{
			List<item_s> list = new List<item_s>();
			for (int i = 0; i < gos.Count; i++)
			{
				item_s item_s = new item_s();
				item_s.go = gos[i];
				item_s.coord = gos[i].transform.position;
				list.Add(item_s);
			}
			items = list;
			if (items.Count > 0)
			{
				agglomerate(null);
			}
			return 0;
		}

		public static void Main()
		{
			List<float> list = new List<float>();
			list.AddRange(new float[10] { 19f, 18f, 17f, 16f, 15f, 10f, 11f, 12f, 13f, 14f });
			UnityEngine.Debug.Log("Loop quick select 10 times.");
			UnityEngine.Debug.Log(NthSmallestElement(list, 0));
		}

		public static T NthSmallestElement<T>(List<T> array, int n) where T : IComparable<T>
		{
			if (n < 0)
			{
				n = 0;
			}
			if (n > array.Count - 1)
			{
				n = array.Count - 1;
			}
			if (array.Count == 0)
			{
				throw new ArgumentException("Array is empty.", "array");
			}
			if (array.Count == 1)
			{
				return array[0];
			}
			return QuickSelectSmallest(array, n)[n];
		}

		private static List<T> QuickSelectSmallest<T>(List<T> input, int n) where T : IComparable<T>
		{
			int num = 0;
			int num2 = input.Count - 1;
			int pivotIndex = n;
			System.Random random = new System.Random();
			while (num2 > num)
			{
				pivotIndex = QuickSelectPartition(input, num, num2, pivotIndex);
				if (pivotIndex == n)
				{
					break;
				}
				if (pivotIndex > n)
				{
					num2 = pivotIndex - 1;
				}
				else
				{
					num = pivotIndex + 1;
				}
				pivotIndex = random.Next(num, num2);
			}
			return input;
		}

		private static int QuickSelectPartition<T>(List<T> array, int startIndex, int endIndex, int pivotIndex) where T : IComparable<T>
		{
			T other = array[pivotIndex];
			Swap(array, pivotIndex, endIndex);
			for (int i = startIndex; i < endIndex; i++)
			{
				if (array[i].CompareTo(other) <= 0)
				{
					Swap(array, i, startIndex);
					startIndex++;
				}
			}
			Swap(array, endIndex, startIndex);
			return startIndex;
		}

		private static void Swap<T>(List<T> array, int index1, int index2)
		{
			if (index1 != index2)
			{
				T value = array[index1];
				array[index1] = array[index2];
				array[index2] = value;
			}
		}
	}
	public class MB3_CopyBoneWeights
	{
		public static void CopyBoneWeightsFromSeamMeshToOtherMeshes(float radius, Mesh seamMesh, Mesh[] targetMeshes)
		{
			List<int> list = new List<int>();
			if (seamMesh == null)
			{
				UnityEngine.Debug.LogError($"The SeamMesh cannot be null");
				return;
			}
			if (seamMesh.vertexCount == 0)
			{
				UnityEngine.Debug.LogError("The seam mesh has no vertices. Check that the Asset Importer for the seam mesh does not have 'Optimize Mesh' checked.");
				return;
			}
			Vector3[] vertices = seamMesh.vertices;
			BoneWeight[] boneWeights = seamMesh.boneWeights;
			Vector3[] normals = seamMesh.normals;
			Vector4[] tangents = seamMesh.tangents;
			Vector2[] uv = seamMesh.uv;
			if (uv.Length != vertices.Length)
			{
				UnityEngine.Debug.LogError("The seam mesh needs uvs to identify which vertices are part of the seam. Vertices with UV > .5 are part of the seam. Vertices with UV < .5 are not part of the seam.");
				return;
			}
			for (int i = 0; i < uv.Length; i++)
			{
				if (uv[i].x > 0.5f && uv[i].y > 0.5f)
				{
					list.Add(i);
				}
			}
			UnityEngine.Debug.Log($"The seam mesh has {seamMesh.vertices.Length} vertices of which {list.Count} are seam vertices.");
			if (list.Count == 0)
			{
				UnityEngine.Debug.LogError("None of the vertices in the Seam Mesh were marked as seam vertices. To mark a vertex as a seam vertex the UV must be greater than (.5,.5). Vertices with UV less than (.5,.5) are excluded.");
				return;
			}
			bool flag = false;
			for (int j = 0; j < targetMeshes.Length; j++)
			{
				if (targetMeshes[j] == null)
				{
					UnityEngine.Debug.LogError($"Mesh {j} was null");
					flag = true;
				}
				if (radius < 0f)
				{
					UnityEngine.Debug.LogError("radius must be zero or positive.");
				}
			}
			if (flag)
			{
				return;
			}
			for (int k = 0; k < targetMeshes.Length; k++)
			{
				Mesh obj = targetMeshes[k];
				Vector3[] vertices2 = obj.vertices;
				BoneWeight[] boneWeights2 = obj.boneWeights;
				Vector3[] normals2 = obj.normals;
				Vector4[] tangents2 = obj.tangents;
				int num = 0;
				for (int l = 0; l < vertices2.Length; l++)
				{
					for (int m = 0; m < list.Count; m++)
					{
						int num2 = list[m];
						if (Vector3.Distance(vertices2[l], vertices[num2]) <= radius)
						{
							num++;
							boneWeights2[l] = boneWeights[num2];
							vertices2[l] = vertices[num2];
							if (normals2.Length == vertices2.Length && normals.Length == normals.Length)
							{
								normals2[l] = normals[num2];
							}
							if (tangents2.Length == vertices2.Length && tangents.Length == vertices.Length)
							{
								tangents2[l] = tangents[num2];
							}
						}
					}
				}
				if (num > 0)
				{
					targetMeshes[k].vertices = vertices2;
					targetMeshes[k].boneWeights = boneWeights2;
					targetMeshes[k].normals = normals2;
					targetMeshes[k].tangents = tangents2;
				}
				UnityEngine.Debug.Log(string.Format("Copied boneweights for {1} vertices in mesh {0} that matched positions in the seam mesh.", targetMeshes[k].name, num));
			}
		}
	}
	[Serializable]
	public abstract class MB3_MeshCombiner
	{
		public delegate void GenerateUV2Delegate(Mesh m, float hardAngle, float packMargin);

		public class MBBlendShapeKey
		{
			public int gameObjecID;

			public int blendShapeIndexInSrc;

			public MBBlendShapeKey(int srcSkinnedMeshRenderGameObjectID, int blendShapeIndexInSource)
			{
				gameObjecID = srcSkinnedMeshRenderGameObjectID;
				blendShapeIndexInSrc = blendShapeIndexInSource;
			}

			public override bool Equals(object obj)
			{
				if (!(obj is MBBlendShapeKey) || obj == null)
				{
					return false;
				}
				MBBlendShapeKey mBBlendShapeKey = (MBBlendShapeKey)obj;
				if (gameObjecID == mBBlendShapeKey.gameObjecID)
				{
					return blendShapeIndexInSrc == mBBlendShapeKey.blendShapeIndexInSrc;
				}
				return false;
			}

			public override int GetHashCode()
			{
				return (23 * 31 + gameObjecID) * 31 + blendShapeIndexInSrc;
			}
		}

		public class MBBlendShapeValue
		{
			public GameObject combinedMeshGameObject;

			public int blendShapeIndex;
		}

		[SerializeField]
		protected MB2_LogLevel _LOG_LEVEL = MB2_LogLevel.info;

		[SerializeField]
		protected MB2_ValidationLevel _validationLevel = MB2_ValidationLevel.robust;

		[SerializeField]
		protected string _name;

		[SerializeField]
		protected MB2_TextureBakeResults _textureBakeResults;

		[SerializeField]
		protected GameObject _resultSceneObject;

		[SerializeField]
		protected Renderer _targetRenderer;

		[SerializeField]
		protected MB_RenderType _renderType;

		[SerializeField]
		protected MB2_OutputOptions _outputOption;

		[SerializeField]
		protected MB2_LightmapOptions _lightmapOption = MB2_LightmapOptions.ignore_UV2;

		[SerializeField]
		protected bool _doNorm = true;

		[SerializeField]
		protected bool _doTan = true;

		[SerializeField]
		protected bool _doCol;

		[SerializeField]
		protected bool _doUV = true;

		[SerializeField]
		protected bool _doUV3;

		[SerializeField]
		protected bool _doUV4;

		[SerializeField]
		protected bool _doBlendShapes;

		[SerializeField]
		protected bool _recenterVertsToBoundsCenter;

		[SerializeField]
		public bool _optimizeAfterBake = true;

		[SerializeField]
		public float uv2UnwrappingParamsHardAngle = 60f;

		[SerializeField]
		public float uv2UnwrappingParamsPackMargin = 0.005f;

		protected bool _usingTemporaryTextureBakeResult;

		public static bool EVAL_VERSION => false;

		public virtual MB2_LogLevel LOG_LEVEL
		{
			get
			{
				return _LOG_LEVEL;
			}
			set
			{
				_LOG_LEVEL = value;
			}
		}

		public virtual MB2_ValidationLevel validationLevel
		{
			get
			{
				return _validationLevel;
			}
			set
			{
				_validationLevel = value;
			}
		}

		public string name
		{
			get
			{
				return _name;
			}
			set
			{
				_name = value;
			}
		}

		public virtual MB2_TextureBakeResults textureBakeResults
		{
			get
			{
				return _textureBakeResults;
			}
			set
			{
				_textureBakeResults = value;
			}
		}

		public virtual GameObject resultSceneObject
		{
			get
			{
				return _resultSceneObject;
			}
			set
			{
				_resultSceneObject = value;
			}
		}

		public virtual Renderer targetRenderer
		{
			get
			{
				return _targetRenderer;
			}
			set
			{
				if (_targetRenderer != null && _targetRenderer != value)
				{
					UnityEngine.Debug.LogWarning("Previous targetRenderer was not null. Combined mesh may be being used by more than one Renderer");
				}
				_targetRenderer = value;
			}
		}

		public virtual MB_RenderType renderType
		{
			get
			{
				return _renderType;
			}
			set
			{
				_renderType = value;
			}
		}

		public virtual MB2_OutputOptions outputOption
		{
			get
			{
				return _outputOption;
			}
			set
			{
				_outputOption = value;
			}
		}

		public virtual MB2_LightmapOptions lightmapOption
		{
			get
			{
				return _lightmapOption;
			}
			set
			{
				_lightmapOption = value;
			}
		}

		public virtual bool doNorm
		{
			get
			{
				return _doNorm;
			}
			set
			{
				_doNorm = value;
			}
		}

		public virtual bool doTan
		{
			get
			{
				return _doTan;
			}
			set
			{
				_doTan = value;
			}
		}

		public virtual bool doCol
		{
			get
			{
				return _doCol;
			}
			set
			{
				_doCol = value;
			}
		}

		public virtual bool doUV
		{
			get
			{
				return _doUV;
			}
			set
			{
				_doUV = value;
			}
		}

		public virtual bool doUV1
		{
			get
			{
				return false;
			}
			set
			{
			}
		}

		public virtual bool doUV3
		{
			get
			{
				return _doUV3;
			}
			set
			{
				_doUV3 = value;
			}
		}

		public virtual bool doUV4
		{
			get
			{
				return _doUV4;
			}
			set
			{
				_doUV4 = value;
			}
		}

		public virtual bool doBlendShapes
		{
			get
			{
				return _doBlendShapes;
			}
			set
			{
				_doBlendShapes = value;
			}
		}

		public virtual bool recenterVertsToBoundsCenter
		{
			get
			{
				return _recenterVertsToBoundsCenter;
			}
			set
			{
				_recenterVertsToBoundsCenter = value;
			}
		}

		public bool optimizeAfterBake
		{
			get
			{
				return _optimizeAfterBake;
			}
			set
			{
				_optimizeAfterBake = value;
			}
		}

		public virtual bool doUV2()
		{
			if (_lightmapOption != MB2_LightmapOptions.copy_UV2_unchanged && _lightmapOption != 0)
			{
				return _lightmapOption == MB2_LightmapOptions.copy_UV2_unchanged_to_separate_rects;
			}
			return true;
		}

		public abstract int GetLightmapIndex();

		public abstract void ClearBuffers();

		public abstract void ClearMesh();

		public abstract void DestroyMesh();

		public abstract void DestroyMeshEditor(MB2_EditorMethodsInterface editorMethods);

		public abstract List<GameObject> GetObjectsInCombined();

		public abstract int GetNumObjectsInCombined();

		public abstract int GetNumVerticesFor(GameObject go);

		public abstract int GetNumVerticesFor(int instanceID);

		public abstract Dictionary<MBBlendShapeKey, MBBlendShapeValue> BuildSourceBlendShapeToCombinedIndexMap();

		public virtual void Apply()
		{
			Apply(null);
		}

		public abstract void Apply(GenerateUV2Delegate uv2GenerationMethod);

		public abstract void Apply(bool triangles, bool vertices, bool normals, bool tangents, bool uvs, bool uv2, bool uv3, bool uv4, bool colors, bool bones = false, bool blendShapeFlag = false, GenerateUV2Delegate uv2GenerationMethod = null);

		public abstract void UpdateGameObjects(GameObject[] gos, bool recalcBounds = true, bool updateVertices = true, bool updateNormals = true, bool updateTangents = true, bool updateUV = false, bool updateUV2 = false, bool updateUV3 = false, bool updateUV4 = false, bool updateColors = false, bool updateSkinningInfo = false);

		public abstract bool AddDeleteGameObjects(GameObject[] gos, GameObject[] deleteGOs, bool disableRendererInSource = true);

		public abstract bool AddDeleteGameObjectsByID(GameObject[] gos, int[] deleteGOinstanceIDs, bool disableRendererInSource);

		public abstract bool CombinedMeshContains(GameObject go);

		public abstract void UpdateSkinnedMeshApproximateBounds();

		public abstract void UpdateSkinnedMeshApproximateBoundsFromBones();

		public abstract void CheckIntegrity();

		public abstract void UpdateSkinnedMeshApproximateBoundsFromBounds();

		public static void UpdateSkinnedMeshApproximateBoundsFromBonesStatic(Transform[] bs, SkinnedMeshRenderer smr)
		{
			Vector3 position = bs[0].position;
			Vector3 position2 = bs[0].position;
			for (int i = 1; i < bs.Length; i++)
			{
				Vector3 position3 = bs[i].position;
				if (position3.x < position2.x)
				{
					position2.x = position3.x;
				}
				if (position3.y < position2.y)
				{
					position2.y = position3.y;
				}
				if (position3.z < position2.z)
				{
					position2.z = position3.z;
				}
				if (position3.x > position.x)
				{
					position.x = position3.x;
				}
				if (position3.y > position.y)
				{
					position.y = position3.y;
				}
				if (position3.z > position.z)
				{
					position.z = position3.z;
				}
			}
			Vector3 vector = (position + position2) / 2f;
			Vector3 vector2 = position - position2;
			Matrix4x4 worldToLocalMatrix = smr.worldToLocalMatrix;
			Bounds localBounds = new Bounds(worldToLocalMatrix * vector, worldToLocalMatrix * vector2);
			smr.localBounds = localBounds;
		}

		public static void UpdateSkinnedMeshApproximateBoundsFromBoundsStatic(List<GameObject> objectsInCombined, SkinnedMeshRenderer smr)
		{
			Bounds b = default(Bounds);
			Bounds bounds = default(Bounds);
			if (MB_Utility.GetBounds(objectsInCombined[0], out b))
			{
				bounds = b;
				for (int i = 1; i < objectsInCombined.Count; i++)
				{
					if (MB_Utility.GetBounds(objectsInCombined[i], out b))
					{
						bounds.Encapsulate(b);
						continue;
					}
					UnityEngine.Debug.LogError("Could not get bounds. Not updating skinned mesh bounds");
					return;
				}
				smr.localBounds = bounds;
			}
			else
			{
				UnityEngine.Debug.LogError("Could not get bounds. Not updating skinned mesh bounds");
			}
		}

		protected virtual bool _CreateTemporaryTextrueBakeResult(GameObject[] gos, List<Material> matsOnTargetRenderer)
		{
			if (GetNumObjectsInCombined() > 0)
			{
				UnityEngine.Debug.LogError("Can't add objects if there are already objects in combined mesh when 'Texture Bake Result' is not set. Perhaps enable 'Clear Buffers After Bake'");
				return false;
			}
			_usingTemporaryTextureBakeResult = true;
			_textureBakeResults = MB2_TextureBakeResults.CreateForMaterialsOnRenderer(gos, matsOnTargetRenderer);
			return true;
		}

		public abstract List<Material> GetMaterialsOnTargetRenderer();
	}
	[Serializable]
	public class MB3_MeshCombinerSingle : MB3_MeshCombiner
	{
		[Serializable]
		public class SerializableIntArray
		{
			public int[] data;

			public SerializableIntArray()
			{
			}

			public SerializableIntArray(int len)
			{
				data = new int[len];
			}
		}

		[Serializable]
		public class MB_DynamicGameObject : IComparable<MB_DynamicGameObject>
		{
			public int instanceID;

			public string name;

			public int vertIdx;

			public int blendShapeIdx;

			public int numVerts;

			public int numBlendShapes;

			public int[] indexesOfBonesUsed = new int[0];

			public int lightmapIndex = -1;

			public Vector4 lightmapTilingOffset = new Vector4(1f, 1f, 0f, 0f);

			public Vector3 meshSize = Vector3.one;

			public bool show = true;

			public bool invertTriangles;

			public int[] submeshTriIdxs;

			public int[] submeshNumTris;

			public int[] targetSubmeshIdxs;

			public Rect[] uvRects;

			public Rect[] encapsulatingRect;

			public Rect[] sourceMaterialTiling;

			public Rect[] obUVRects;

			public bool _beingDeleted;

			public int _triangleIdxAdjustment;

			[NonSerialized]
			public SerializableIntArray[] _tmpSubmeshTris;

			[NonSerialized]
			public Transform[] _tmpCachedBones;

			[NonSerialized]
			public Matrix4x4[] _tmpCachedBindposes;

			[NonSerialized]
			public BoneWeight[] _tmpCachedBoneWeights;

			[NonSerialized]
			public int[] _tmpIndexesOfSourceBonesUsed;

			public int CompareTo(MB_DynamicGameObject b)
			{
				return vertIdx - b.vertIdx;
			}
		}

		public class MeshChannels
		{
			public Vector3[] vertices;

			public Vector3[] normals;

			public Vector4[] tangents;

			public Vector2[] uv0raw;

			public Vector2[] uv0modified;

			public Vector2[] uv2;

			public Vector2[] uv3;

			public Vector2[] uv4;

			public UnityEngine.Color[] colors;

			public BoneWeight[] boneWeights;

			public Matrix4x4[] bindPoses;

			public int[] triangles;

			public MBBlendShape[] blendShapes;
		}

		[Serializable]
		public class MBBlendShapeFrame
		{
			public float frameWeight;

			public Vector3[] vertices;

			public Vector3[] normals;

			public Vector3[] tangents;
		}

		[Serializable]
		public class MBBlendShape
		{
			public int gameObjectID;

			public string name;

			public int indexInSource;

			public MBBlendShapeFrame[] frames;
		}

		public class MeshChannelsCache
		{
			private MB3_MeshCombinerSingle mc;

			protected Dictionary<int, MeshChannels> meshID2MeshChannels = new Dictionary<int, MeshChannels>();

			private Vector2 _HALF_UV = new Vector2(0.5f, 0.5f);

			public MeshChannelsCache(MB3_MeshCombinerSingle mcs)
			{
				mc = mcs;
			}

			internal Vector3[] GetVertices(Mesh m)
			{
				if (!meshID2MeshChannels.TryGetValue(m.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(m.GetInstanceID(), value);
				}
				if (value.vertices == null)
				{
					value.vertices = m.vertices;
				}
				return value.vertices;
			}

			internal Vector3[] GetNormals(Mesh m)
			{
				if (!meshID2MeshChannels.TryGetValue(m.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(m.GetInstanceID(), value);
				}
				if (value.normals == null)
				{
					value.normals = _getMeshNormals(m);
				}
				return value.normals;
			}

			internal Vector4[] GetTangents(Mesh m)
			{
				if (!meshID2MeshChannels.TryGetValue(m.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(m.GetInstanceID(), value);
				}
				if (value.tangents == null)
				{
					value.tangents = _getMeshTangents(m);
				}
				return value.tangents;
			}

			internal Vector2[] GetUv0Raw(Mesh m)
			{
				if (!meshID2MeshChannels.TryGetValue(m.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(m.GetInstanceID(), value);
				}
				if (value.uv0raw == null)
				{
					value.uv0raw = _getMeshUVs(m);
				}
				return value.uv0raw;
			}

			internal Vector2[] GetUv0Modified(Mesh m)
			{
				if (!meshID2MeshChannels.TryGetValue(m.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(m.GetInstanceID(), value);
				}
				if (value.uv0modified == null)
				{
					value.uv0modified = null;
				}
				return value.uv0modified;
			}

			internal Vector2[] GetUv2(Mesh m)
			{
				if (!meshID2MeshChannels.TryGetValue(m.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(m.GetInstanceID(), value);
				}
				if (value.uv2 == null)
				{
					value.uv2 = _getMeshUV2s(m);
				}
				return value.uv2;
			}

			internal Vector2[] GetUv3(Mesh m)
			{
				if (!meshID2MeshChannels.TryGetValue(m.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(m.GetInstanceID(), value);
				}
				if (value.uv3 == null)
				{
					value.uv3 = MBVersion.GetMeshUV3orUV4(m, get3: true, mc.LOG_LEVEL);
				}
				return value.uv3;
			}

			internal Vector2[] GetUv4(Mesh m)
			{
				if (!meshID2MeshChannels.TryGetValue(m.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(m.GetInstanceID(), value);
				}
				if (value.uv4 == null)
				{
					value.uv4 = MBVersion.GetMeshUV3orUV4(m, get3: false, mc.LOG_LEVEL);
				}
				return value.uv4;
			}

			internal UnityEngine.Color[] GetColors(Mesh m)
			{
				if (!meshID2MeshChannels.TryGetValue(m.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(m.GetInstanceID(), value);
				}
				if (value.colors == null)
				{
					value.colors = _getMeshColors(m);
				}
				return value.colors;
			}

			internal Matrix4x4[] GetBindposes(Renderer r)
			{
				Mesh mesh = MB_Utility.GetMesh(r.gameObject);
				if (!meshID2MeshChannels.TryGetValue(mesh.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(mesh.GetInstanceID(), value);
				}
				if (value.bindPoses == null)
				{
					value.bindPoses = _getBindPoses(r);
				}
				return value.bindPoses;
			}

			internal BoneWeight[] GetBoneWeights(Renderer r, int numVertsInMeshBeingAdded)
			{
				Mesh mesh = MB_Utility.GetMesh(r.gameObject);
				if (!meshID2MeshChannels.TryGetValue(mesh.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(mesh.GetInstanceID(), value);
				}
				if (value.boneWeights == null)
				{
					value.boneWeights = _getBoneWeights(r, numVertsInMeshBeingAdded);
				}
				return value.boneWeights;
			}

			internal int[] GetTriangles(Mesh m)
			{
				if (!meshID2MeshChannels.TryGetValue(m.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(m.GetInstanceID(), value);
				}
				if (value.triangles == null)
				{
					value.triangles = m.triangles;
				}
				return value.triangles;
			}

			internal MBBlendShape[] GetBlendShapes(Mesh m, int gameObjectID)
			{
				if (MBVersion.GetMajorVersion() > 5 || (MBVersion.GetMajorVersion() == 5 && MBVersion.GetMinorVersion() >= 3))
				{
					if (!meshID2MeshChannels.TryGetValue(m.GetInstanceID(), out var value))
					{
						value = new MeshChannels();
						meshID2MeshChannels.Add(m.GetInstanceID(), value);
					}
					if (value.blendShapes == null)
					{
						MBBlendShape[] array = new MBBlendShape[m.blendShapeCount];
						int vertexCount = m.vertexCount;
						for (int i = 0; i < array.Length; i++)
						{
							MBBlendShape mBBlendShape = (array[i] = new MBBlendShape());
							mBBlendShape.frames = new MBBlendShapeFrame[MBVersion.GetBlendShapeFrameCount(m, i)];
							mBBlendShape.name = m.GetBlendShapeName(i);
							mBBlendShape.indexInSource = i;
							mBBlendShape.gameObjectID = gameObjectID;
							for (int j = 0; j < mBBlendShape.frames.Length; j++)
							{
								MBBlendShapeFrame mBBlendShapeFrame = (mBBlendShape.frames[j] = new MBBlendShapeFrame());
								mBBlendShapeFrame.frameWeight = MBVersion.GetBlendShapeFrameWeight(m, i, j);
								mBBlendShapeFrame.vertices = new Vector3[vertexCount];
								mBBlendShapeFrame.normals = new Vector3[vertexCount];
								mBBlendShapeFrame.tangents = new Vector3[vertexCount];
								MBVersion.GetBlendShapeFrameVertices(m, i, j, mBBlendShapeFrame.vertices, mBBlendShapeFrame.normals, mBBlendShapeFrame.tangents);
							}
						}
						value.blendShapes = array;
						return value.blendShapes;
					}
					MBBlendShape[] array2 = new MBBlendShape[value.blendShapes.Length];
					for (int k = 0; k < array2.Length; k++)
					{
						array2[k] = new MBBlendShape();
						array2[k].name = value.blendShapes[k].name;
						array2[k].indexInSource = value.blendShapes[k].indexInSource;
						array2[k].frames = value.blendShapes[k].frames;
						array2[k].gameObjectID = gameObjectID;
					}
					return array2;
				}
				return new MBBlendShape[0];
			}

			private UnityEngine.Color[] _getMeshColors(Mesh m)
			{
				UnityEngine.Color[] array = m.colors;
				if (array.Length == 0)
				{
					if (mc.LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug(string.Concat("Mesh ", m, " has no colors. Generating"));
					}
					if (mc.LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning(string.Concat("Mesh ", m, " didn't have colors. Generating an array of white colors"));
					}
					array = new UnityEngine.Color[m.vertexCount];
					for (int i = 0; i < array.Length; i++)
					{
						array[i] = UnityEngine.Color.white;
					}
				}
				return array;
			}

			private Vector3[] _getMeshNormals(Mesh m)
			{
				Vector3[] normals = m.normals;
				if (normals.Length == 0)
				{
					if (mc.LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug(string.Concat("Mesh ", m, " has no normals. Generating"));
					}
					if (mc.LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning(string.Concat("Mesh ", m, " didn't have normals. Generating normals."));
					}
					Mesh mesh = UnityEngine.Object.Instantiate(m);
					mesh.RecalculateNormals();
					normals = mesh.normals;
					MB_Utility.Destroy(mesh);
				}
				return normals;
			}

			private Vector4[] _getMeshTangents(Mesh m)
			{
				Vector4[] array = m.tangents;
				if (array.Length == 0)
				{
					if (mc.LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug(string.Concat("Mesh ", m, " has no tangents. Generating"));
					}
					if (mc.LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning(string.Concat("Mesh ", m, " didn't have tangents. Generating tangents."));
					}
					Vector3[] vertices = m.vertices;
					Vector2[] uv0Raw = GetUv0Raw(m);
					Vector3[] normals = _getMeshNormals(m);
					array = new Vector4[m.vertexCount];
					for (int i = 0; i < m.subMeshCount; i++)
					{
						int[] triangles = m.GetTriangles(i);
						_generateTangents(triangles, vertices, uv0Raw, normals, array);
					}
				}
				return array;
			}

			private Vector2[] _getMeshUVs(Mesh m)
			{
				Vector2[] array = m.uv;
				if (array.Length == 0)
				{
					if (mc.LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug(string.Concat("Mesh ", m, " has no uvs. Generating"));
					}
					if (mc.LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning(string.Concat("Mesh ", m, " didn't have uvs. Generating uvs."));
					}
					array = new Vector2[m.vertexCount];
					for (int i = 0; i < array.Length; i++)
					{
						array[i] = _HALF_UV;
					}
				}
				return array;
			}

			private Vector2[] _getMeshUV2s(Mesh m)
			{
				Vector2[] array = m.uv2;
				if (array.Length == 0)
				{
					if (mc.LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug(string.Concat("Mesh ", m, " has no uv2s. Generating"));
					}
					if (mc.LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning(string.Concat("Mesh ", m, " didn't have uv2s. Generating uv2s."));
					}
					if (mc._lightmapOption == MB2_LightmapOptions.copy_UV2_unchanged_to_separate_rects)
					{
						UnityEngine.Debug.LogError(string.Concat("Mesh ", m, " did not have a UV2 channel. Nothing to copy when trying to copy UV2 to separate rects. The combined mesh will not lightmap properly. Try using generate new uv2 layout."));
					}
					array = new Vector2[m.vertexCount];
					for (int i = 0; i < array.Length; i++)
					{
						array[i] = _HALF_UV;
					}
				}
				return array;
			}

			public static Matrix4x4[] _getBindPoses(Renderer r)
			{
				if (r is SkinnedMeshRenderer)
				{
					return ((SkinnedMeshRenderer)r).sharedMesh.bindposes;
				}
				if (r is MeshRenderer)
				{
					Matrix4x4 identity = Matrix4x4.identity;
					return new Matrix4x4[1] { identity };
				}
				UnityEngine.Debug.LogError("Could not _getBindPoses. Object does not have a renderer");
				return null;
			}

			public static BoneWeight[] _getBoneWeights(Renderer r, int numVertsInMeshBeingAdded)
			{
				if (r is SkinnedMeshRenderer)
				{
					return ((SkinnedMeshRenderer)r).sharedMesh.boneWeights;
				}
				if (r is MeshRenderer)
				{
					BoneWeight boneWeight = default(BoneWeight);
					int num2 = (boneWeight.boneIndex3 = 0);
					int num4 = (boneWeight.boneIndex2 = num2);
					int boneIndex = (boneWeight.boneIndex1 = num4);
					boneWeight.boneIndex0 = boneIndex;
					boneWeight.weight0 = 1f;
					float num7 = (boneWeight.weight3 = 0f);
					float weight = (boneWeight.weight2 = num7);
					boneWeight.weight1 = weight;
					BoneWeight[] array = new BoneWeight[numVertsInMeshBeingAdded];
					for (int i = 0; i < array.Length; i++)
					{
						array[i] = boneWeight;
					}
					return array;
				}
				UnityEngine.Debug.LogError("Could not _getBoneWeights. Object does not have a renderer");
				return null;
			}

			private void _generateTangents(int[] triangles, Vector3[] verts, Vector2[] uvs, Vector3[] normals, Vector4[] outTangents)
			{
				int num = triangles.Length;
				int num2 = verts.Length;
				Vector3[] array = new Vector3[num2];
				Vector3[] array2 = new Vector3[num2];
				for (int i = 0; i < num; i += 3)
				{
					int num3 = triangles[i];
					int num4 = triangles[i + 1];
					int num5 = triangles[i + 2];
					Vector3 vector = verts[num3];
					Vector3 vector2 = verts[num4];
					Vector3 vector3 = verts[num5];
					Vector2 vector4 = uvs[num3];
					Vector2 vector5 = uvs[num4];
					Vector2 vector6 = uvs[num5];
					float num6 = vector2.x - vector.x;
					float num7 = vector3.x - vector.x;
					float num8 = vector2.y - vector.y;
					float num9 = vector3.y - vector.y;
					float num10 = vector2.z - vector.z;
					float num11 = vector3.z - vector.z;
					float num12 = vector5.x - vector4.x;
					float num13 = vector6.x - vector4.x;
					float num14 = vector5.y - vector4.y;
					float num15 = vector6.y - vector4.y;
					float num16 = num12 * num15 - num13 * num14;
					if (num16 == 0f)
					{
						UnityEngine.Debug.LogError("Could not compute tangents. All UVs need to form a valid triangles in UV space. If any UV triangles are collapsed, tangents cannot be generated.");
						return;
					}
					float num17 = 1f / num16;
					Vector3 vector7 = new Vector3((num15 * num6 - num14 * num7) * num17, (num15 * num8 - num14 * num9) * num17, (num15 * num10 - num14 * num11) * num17);
					Vector3 vector8 = new Vector3((num12 * num7 - num13 * num6) * num17, (num12 * num9 - num13 * num8) * num17, (num12 * num11 - num13 * num10) * num17);
					array[num3] += vector7;
					array[num4] += vector7;
					array[num5] += vector7;
					array2[num3] += vector8;
					array2[num4] += vector8;
					array2[num5] += vector8;
				}
				for (int j = 0; j < num2; j++)
				{
					Vector3 vector9 = normals[j];
					Vector3 vector10 = array[j];
					Vector3 normalized = (vector10 - vector9 * Vector3.Dot(vector9, vector10)).normalized;
					outTangents[j] = new Vector4(normalized.x, normalized.y, normalized.z);
					outTangents[j].w = ((Vector3.Dot(Vector3.Cross(vector9, vector10), array2[j]) < 0f) ? (-1f) : 1f);
				}
			}
		}

		public struct BoneAndBindpose
		{
			public Transform bone;

			public Matrix4x4 bindPose;

			public BoneAndBindpose(Transform t, Matrix4x4 bp)
			{
				bone = t;
				bindPose = bp;
			}

			public override bool Equals(object obj)
			{
				if (obj is BoneAndBindpose && bone == ((BoneAndBindpose)obj).bone && bindPose == ((BoneAndBindpose)obj).bindPose)
				{
					return true;
				}
				return false;
			}

			public override int GetHashCode()
			{
				return (bone.GetInstanceID() % int.MaxValue) ^ (int)bindPose[0, 0];
			}
		}

		[SerializeField]
		protected List<GameObject> objectsInCombinedMesh = new List<GameObject>();

		[SerializeField]
		private int lightmapIndex = -1;

		[SerializeField]
		private List<MB_DynamicGameObject> mbDynamicObjectsInCombinedMesh = new List<MB_DynamicGameObject>();

		private Dictionary<int, MB_DynamicGameObject> _instance2combined_map = new Dictionary<int, MB_DynamicGameObject>();

		[SerializeField]
		private Vector3[] verts = new Vector3[0];

		[SerializeField]
		private Vector3[] normals = new Vector3[0];

		[SerializeField]
		private Vector4[] tangents = new Vector4[0];

		[SerializeField]
		private Vector2[] uvs = new Vector2[0];

		[SerializeField]
		private Vector2[] uv2s = new Vector2[0];

		[SerializeField]
		private Vector2[] uv3s = new Vector2[0];

		[SerializeField]
		private Vector2[] uv4s = new Vector2[0];

		[SerializeField]
		private UnityEngine.Color[] colors = new UnityEngine.Color[0];

		[SerializeField]
		private Matrix4x4[] bindPoses = new Matrix4x4[0];

		[SerializeField]
		private Transform[] bones = new Transform[0];

		[SerializeField]
		internal MBBlendShape[] blendShapes = new MBBlendShape[0];

		[SerializeField]
		internal MBBlendShape[] blendShapesInCombined = new MBBlendShape[0];

		[SerializeField]
		private SerializableIntArray[] submeshTris = new SerializableIntArray[0];

		[SerializeField]
		private Mesh _mesh;

		private BoneWeight[] boneWeights = new BoneWeight[0];

		private GameObject[] empty = new GameObject[0];

		private int[] emptyIDs = new int[0];

		public override MB2_TextureBakeResults textureBakeResults
		{
			set
			{
				if (mbDynamicObjectsInCombinedMesh.Count > 0 && _textureBakeResults != value && _textureBakeResults != null && LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("If Texture Bake Result is changed then objects currently in combined mesh may be invalid.");
				}
				_textureBakeResults = value;
			}
		}

		public override MB_RenderType renderType
		{
			set
			{
				if (value == MB_RenderType.skinnedMeshRenderer && _renderType == MB_RenderType.meshRenderer && boneWeights.Length != verts.Length)
				{
					UnityEngine.Debug.LogError("Can't set the render type to SkinnedMeshRenderer without clearing the mesh first. Try deleteing the CombinedMesh scene object.");
				}
				_renderType = value;
			}
		}

		public override GameObject resultSceneObject
		{
			set
			{
				if (_resultSceneObject != value)
				{
					_targetRenderer = null;
					if (_mesh != null && _LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning("Result Scene Object was changed when this mesh baker component had a reference to a mesh. If mesh is being used by another object make sure to reset the mesh to none before baking to avoid overwriting the other mesh.");
					}
				}
				_resultSceneObject = value;
			}
		}

		private MB_DynamicGameObject instance2Combined_MapGet(int gameObjectID)
		{
			return _instance2combined_map[gameObjectID];
		}

		private void instance2Combined_MapAdd(int gameObjectID, MB_DynamicGameObject dgo)
		{
			_instance2combined_map.Add(gameObjectID, dgo);
		}

		private void instance2Combined_MapRemove(int gameObjectID)
		{
			_instance2combined_map.Remove(gameObjectID);
		}

		private bool instance2Combined_MapTryGetValue(int gameObjectID, out MB_DynamicGameObject dgo)
		{
			return _instance2combined_map.TryGetValue(gameObjectID, out dgo);
		}

		private int instance2Combined_MapCount()
		{
			return _instance2combined_map.Count;
		}

		private void instance2Combined_MapClear()
		{
			_instance2combined_map.Clear();
		}

		private bool instance2Combined_MapContainsKey(int gameObjectID)
		{
			return _instance2combined_map.ContainsKey(gameObjectID);
		}

		public override int GetNumObjectsInCombined()
		{
			return mbDynamicObjectsInCombinedMesh.Count;
		}

		public override List<GameObject> GetObjectsInCombined()
		{
			List<GameObject> list = new List<GameObject>();
			list.AddRange(objectsInCombinedMesh);
			return list;
		}

		public Mesh GetMesh()
		{
			if (_mesh == null)
			{
				_mesh = new Mesh();
			}
			return _mesh;
		}

		public void SetMesh(Mesh m)
		{
			_mesh = m;
		}

		public Transform[] GetBones()
		{
			return bones;
		}

		public override int GetLightmapIndex()
		{
			if (lightmapOption == MB2_LightmapOptions.generate_new_UV2_layout || lightmapOption == MB2_LightmapOptions.preserve_current_lightmapping)
			{
				return lightmapIndex;
			}
			return -1;
		}

		public override int GetNumVerticesFor(GameObject go)
		{
			return GetNumVerticesFor(go.GetInstanceID());
		}

		public override int GetNumVerticesFor(int instanceID)
		{
			if (instance2Combined_MapTryGetValue(instanceID, out var dgo))
			{
				return dgo.numVerts;
			}
			return -1;
		}

		public override Dictionary<MBBlendShapeKey, MBBlendShapeValue> BuildSourceBlendShapeToCombinedIndexMap()
		{
			Dictionary<MBBlendShapeKey, MBBlendShapeValue> dictionary = new Dictionary<MBBlendShapeKey, MBBlendShapeValue>();
			for (int i = 0; i < blendShapesInCombined.Length; i++)
			{
				MBBlendShapeValue mBBlendShapeValue = new MBBlendShapeValue();
				mBBlendShapeValue.combinedMeshGameObject = _targetRenderer.gameObject;
				mBBlendShapeValue.blendShapeIndex = i;
				dictionary.Add(new MBBlendShapeKey(blendShapesInCombined[i].gameObjectID, blendShapesInCombined[i].indexInSource), mBBlendShapeValue);
			}
			return dictionary;
		}

		private void _initialize(int numResultMats)
		{
			if (mbDynamicObjectsInCombinedMesh.Count == 0)
			{
				lightmapIndex = -1;
			}
			if (_mesh == null)
			{
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug("_initialize Creating new Mesh");
				}
				_mesh = GetMesh();
			}
			if (instance2Combined_MapCount() != mbDynamicObjectsInCombinedMesh.Count)
			{
				instance2Combined_MapClear();
				for (int i = 0; i < mbDynamicObjectsInCombinedMesh.Count; i++)
				{
					if (mbDynamicObjectsInCombinedMesh[i] != null)
					{
						instance2Combined_MapAdd(mbDynamicObjectsInCombinedMesh[i].instanceID, mbDynamicObjectsInCombinedMesh[i]);
					}
				}
				boneWeights = _mesh.boneWeights;
			}
			if (objectsInCombinedMesh.Count == 0 && submeshTris.Length != numResultMats)
			{
				submeshTris = new SerializableIntArray[numResultMats];
				for (int j = 0; j < submeshTris.Length; j++)
				{
					submeshTris[j] = new SerializableIntArray(0);
				}
			}
			if (mbDynamicObjectsInCombinedMesh.Count > 0 && mbDynamicObjectsInCombinedMesh[0].indexesOfBonesUsed.Length == 0 && renderType == MB_RenderType.skinnedMeshRenderer && boneWeights.Length != 0)
			{
				for (int k = 0; k < mbDynamicObjectsInCombinedMesh.Count; k++)
				{
					MB_DynamicGameObject mB_DynamicGameObject = mbDynamicObjectsInCombinedMesh[k];
					HashSet<int> hashSet = new HashSet<int>();
					for (int l = mB_DynamicGameObject.vertIdx; l < mB_DynamicGameObject.vertIdx + mB_DynamicGameObject.numVerts; l++)
					{
						if (boneWeights[l].weight0 > 0f)
						{
							hashSet.Add(boneWeights[l].boneIndex0);
						}
						if (boneWeights[l].weight1 > 0f)
						{
							hashSet.Add(boneWeights[l].boneIndex1);
						}
						if (boneWeights[l].weight2 > 0f)
						{
							hashSet.Add(boneWeights[l].boneIndex2);
						}
						if (boneWeights[l].weight3 > 0f)
						{
							hashSet.Add(boneWeights[l].boneIndex3);
						}
					}
					mB_DynamicGameObject.indexesOfBonesUsed = new int[hashSet.Count];
					hashSet.CopyTo(mB_DynamicGameObject.indexesOfBonesUsed);
				}
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					UnityEngine.Debug.Log("Baker used old systems that duplicated bones. Upgrading to new system by building indexesOfBonesUsed");
				}
			}
			if (LOG_LEVEL >= MB2_LogLevel.trace)
			{
				UnityEngine.Debug.Log($"_initialize numObjsInCombined={mbDynamicObjectsInCombinedMesh.Count}");
			}
		}

		private bool _collectMaterialTriangles(Mesh m, MB_DynamicGameObject dgo, Material[] sharedMaterials, OrderedDictionary sourceMats2submeshIdx_map)
		{
			int num = m.subMeshCount;
			if (sharedMaterials.Length < num)
			{
				num = sharedMaterials.Length;
			}
			dgo._tmpSubmeshTris = new SerializableIntArray[num];
			dgo.targetSubmeshIdxs = new int[num];
			for (int i = 0; i < num; i++)
			{
				if (_textureBakeResults.doMultiMaterial)
				{
					if (!sourceMats2submeshIdx_map.Contains(sharedMaterials[i]))
					{
						UnityEngine.Debug.LogError("Object " + dgo.name + " has a material that was not found in the result materials maping. " + sharedMaterials[i]);
						return false;
					}
					dgo.targetSubmeshIdxs[i] = (int)sourceMats2submeshIdx_map[sharedMaterials[i]];
				}
				else
				{
					dgo.targetSubmeshIdxs[i] = 0;
				}
				dgo._tmpSubmeshTris[i] = new SerializableIntArray();
				dgo._tmpSubmeshTris[i].data = m.GetTriangles(i);
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug("Collecting triangles for: " + dgo.name + " submesh:" + i + " maps to submesh:" + dgo.targetSubmeshIdxs[i] + " added:" + dgo._tmpSubmeshTris[i].data.Length, LOG_LEVEL);
				}
			}
			return true;
		}

		private bool _collectOutOfBoundsUVRects2(Mesh m, MB_DynamicGameObject dgo, Material[] sharedMaterials, OrderedDictionary sourceMats2submeshIdx_map, Dictionary<int, MB_Utility.MeshAnalysisResult[]> meshAnalysisResults, MeshChannelsCache meshChannelCache)
		{
			if (_textureBakeResults == null)
			{
				UnityEngine.Debug.LogError("Need to bake textures into combined material");
				return false;
			}
			if (meshAnalysisResults.TryGetValue(m.GetInstanceID(), out var value))
			{
				dgo.obUVRects = new Rect[sharedMaterials.Length];
				for (int i = 0; i < dgo.obUVRects.Length; i++)
				{
					dgo.obUVRects[i] = value[i].uvRect;
				}
			}
			else
			{
				int subMeshCount = m.subMeshCount;
				int num = subMeshCount;
				if (sharedMaterials.Length < subMeshCount)
				{
					num = sharedMaterials.Length;
				}
				dgo.obUVRects = new Rect[num];
				value = new MB_Utility.MeshAnalysisResult[subMeshCount];
				for (int j = 0; j < subMeshCount; j++)
				{
					int num2 = dgo.targetSubmeshIdxs[j];
					if (_textureBakeResults.resultMaterials[num2].considerMeshUVs)
					{
						MB_Utility.hasOutOfBoundsUVs(meshChannelCache.GetUv0Raw(m), m, ref value[j], j);
						Rect uvRect = value[j].uvRect;
						if (j < num)
						{
							dgo.obUVRects[j] = uvRect;
						}
					}
				}
				meshAnalysisResults.Add(m.GetInstanceID(), value);
			}
			return true;
		}

		private bool _validateTextureBakeResults()
		{
			if (_textureBakeResults == null)
			{
				UnityEngine.Debug.LogError("Texture Bake Results is null. Can't combine meshes.");
				return false;
			}
			if (_textureBakeResults.materialsAndUVRects == null || _textureBakeResults.materialsAndUVRects.Length == 0)
			{
				UnityEngine.Debug.LogError("Texture Bake Results has no materials in material to sourceUVRect map. Try baking materials. Can't combine meshes.");
				return false;
			}
			if (_textureBakeResults.resultMaterials == null || _textureBakeResults.resultMaterials.Length == 0)
			{
				UnityEngine.Debug.LogError("Texture Bake Results has no result materials. Try baking materials. Can't combine meshes.");
				return false;
			}
			return true;
		}

		private bool _validateMeshFlags()
		{
			if (mbDynamicObjectsInCombinedMesh.Count > 0 && ((!_doNorm && doNorm) || (!_doTan && doTan) || (!_doCol && doCol) || (!_doUV && doUV) || (!_doUV3 && doUV3) || (!_doUV4 && doUV4)))
			{
				UnityEngine.Debug.LogError("The channels have changed. There are already objects in the combined mesh that were added with a different set of channels.");
				return false;
			}
			_doNorm = doNorm;
			_doTan = doTan;
			_doCol = doCol;
			_doUV = doUV;
			_doUV3 = doUV3;
			_doUV4 = doUV4;
			return true;
		}

		private bool _showHide(GameObject[] goToShow, GameObject[] goToHide)
		{
			if (goToShow == null)
			{
				goToShow = empty;
			}
			if (goToHide == null)
			{
				goToHide = empty;
			}
			int numResultMats = _textureBakeResults.resultMaterials.Length;
			_initialize(numResultMats);
			for (int i = 0; i < goToHide.Length; i++)
			{
				if (!instance2Combined_MapContainsKey(goToHide[i].GetInstanceID()))
				{
					if (LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning(string.Concat("Trying to hide an object ", goToHide[i], " that is not in combined mesh. Did you initially bake with 'clear buffers after bake' enabled?"));
					}
					return false;
				}
			}
			for (int j = 0; j < goToShow.Length; j++)
			{
				if (!instance2Combined_MapContainsKey(goToShow[j].GetInstanceID()))
				{
					if (LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning(string.Concat("Trying to show an object ", goToShow[j], " that is not in combined mesh. Did you initially bake with 'clear buffers after bake' enabled?"));
					}
					return false;
				}
			}
			for (int k = 0; k < goToHide.Length; k++)
			{
				_instance2combined_map[goToHide[k].GetInstanceID()].show = false;
			}
			for (int l = 0; l < goToShow.Length; l++)
			{
				_instance2combined_map[goToShow[l].GetInstanceID()].show = true;
			}
			return true;
		}

		private bool _addToCombined(GameObject[] goToAdd, int[] goToDelete, bool disableRendererInSource)
		{
			Stopwatch stopwatch = null;
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				stopwatch = new Stopwatch();
				stopwatch.Start();
			}
			if (!_validateTextureBakeResults())
			{
				return false;
			}
			if (!_validateMeshFlags())
			{
				return false;
			}
			if (!ValidateTargRendererAndMeshAndResultSceneObj())
			{
				return false;
			}
			if (outputOption != MB2_OutputOptions.bakeMeshAssetsInPlace && renderType == MB_RenderType.skinnedMeshRenderer && (_targetRenderer == null || !(_targetRenderer is SkinnedMeshRenderer)))
			{
				UnityEngine.Debug.LogError("Target renderer must be set and must be a SkinnedMeshRenderer");
				return false;
			}
			if (_doBlendShapes && renderType != MB_RenderType.skinnedMeshRenderer)
			{
				UnityEngine.Debug.LogError("If doBlendShapes is set then RenderType must be skinnedMeshRenderer.");
				return false;
			}
			GameObject[] _goToAdd;
			if (goToAdd == null)
			{
				_goToAdd = empty;
			}
			else
			{
				_goToAdd = (GameObject[])goToAdd.Clone();
			}
			int[] array = ((goToDelete != null) ? ((int[])goToDelete.Clone()) : emptyIDs);
			if (_mesh == null)
			{
				DestroyMesh();
			}
			MB2_TextureBakeResults.Material2AtlasRectangleMapper material2AtlasRectangleMapper = new MB2_TextureBakeResults.Material2AtlasRectangleMapper(textureBakeResults);
			int num = _textureBakeResults.resultMaterials.Length;
			_initialize(num);
			if (submeshTris.Length != num)
			{
				UnityEngine.Debug.LogError("The number of submeshes " + submeshTris.Length + " in the combined mesh was not equal to the number of result materials " + num + " in the Texture Bake Result");
				return false;
			}
			if (_mesh.vertexCount > 0 && _instance2combined_map.Count == 0)
			{
				UnityEngine.Debug.LogWarning("There were vertices in the combined mesh but nothing in the MeshBaker buffers. If you are trying to bake in the editor and modify at runtime, make sure 'Clear Buffers After Bake' is unchecked.");
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				MB2_Log.LogDebug("==== Calling _addToCombined objs adding:" + _goToAdd.Length + " objs deleting:" + array.Length + " fixOutOfBounds:" + textureBakeResults.DoAnyResultMatsUseConsiderMeshUVs().ToString() + " doMultiMaterial:" + textureBakeResults.doMultiMaterial.ToString() + " disableRenderersInSource:" + disableRendererInSource.ToString(), LOG_LEVEL);
			}
			if (_textureBakeResults.resultMaterials == null || _textureBakeResults.resultMaterials.Length == 0)
			{
				UnityEngine.Debug.LogError("No resultMaterials in this TextureBakeResults. Try baking textures.");
				return false;
			}
			OrderedDictionary orderedDictionary = new OrderedDictionary();
			for (int j = 0; j < num; j++)
			{
				MB_MultiMaterial mB_MultiMaterial = _textureBakeResults.resultMaterials[j];
				for (int k = 0; k < mB_MultiMaterial.sourceMaterials.Count; k++)
				{
					if (mB_MultiMaterial.sourceMaterials[k] == null)
					{
						UnityEngine.Debug.LogError("Found null material in source materials for combined mesh materials " + j);
						return false;
					}
					if (!orderedDictionary.Contains(mB_MultiMaterial.sourceMaterials[k]))
					{
						orderedDictionary.Add(mB_MultiMaterial.sourceMaterials[k], j);
					}
				}
			}
			int num2 = 0;
			int[] array2 = new int[num];
			int num3 = 0;
			List<MB_DynamicGameObject>[] array3 = null;
			HashSet<int> hashSet = new HashSet<int>();
			HashSet<BoneAndBindpose> hashSet2 = new HashSet<BoneAndBindpose>();
			if (renderType == MB_RenderType.skinnedMeshRenderer && array.Length != 0)
			{
				array3 = _buildBoneIdx2dgoMap();
			}
			for (int l = 0; l < array.Length; l++)
			{
				if (instance2Combined_MapTryGetValue(array[l], out var dgo))
				{
					num2 += dgo.numVerts;
					num3 += dgo.numBlendShapes;
					if (renderType == MB_RenderType.skinnedMeshRenderer)
					{
						for (int m = 0; m < dgo.indexesOfBonesUsed.Length; m++)
						{
							if (array3[dgo.indexesOfBonesUsed[m]].Contains(dgo))
							{
								array3[dgo.indexesOfBonesUsed[m]].Remove(dgo);
								if (array3[dgo.indexesOfBonesUsed[m]].Count == 0)
								{
									hashSet.Add(dgo.indexesOfBonesUsed[m]);
								}
							}
						}
					}
					for (int n = 0; n < dgo.submeshNumTris.Length; n++)
					{
						array2[n] += dgo.submeshNumTris[n];
					}
				}
				else if (LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Trying to delete an object that is not in combined mesh");
				}
			}
			List<MB_DynamicGameObject> list = new List<MB_DynamicGameObject>();
			Dictionary<int, MB_Utility.MeshAnalysisResult[]> dictionary = new Dictionary<int, MB_Utility.MeshAnalysisResult[]>();
			MeshChannelsCache meshChannelsCache = new MeshChannelsCache(this);
			int num4 = 0;
			int[] array4 = new int[num];
			int num5 = 0;
			Dictionary<Transform, int> dictionary2 = new Dictionary<Transform, int>();
			for (int num6 = 0; num6 < bones.Length; num6++)
			{
				dictionary2.Add(bones[num6], num6);
			}
			int i;
			for (i = 0; i < _goToAdd.Length; i++)
			{
				if (!instance2Combined_MapContainsKey(_goToAdd[i].GetInstanceID()) || Array.FindIndex(array, (int o) => o == _goToAdd[i].GetInstanceID()) != -1)
				{
					MB_DynamicGameObject mB_DynamicGameObject = new MB_DynamicGameObject();
					GameObject gameObject = _goToAdd[i];
					Material[] gOMaterials = MB_Utility.GetGOMaterials(gameObject);
					if (LOG_LEVEL >= MB2_LogLevel.trace)
					{
						UnityEngine.Debug.Log($"Getting {gOMaterials.Length} shared materials for {gameObject}");
					}
					if (gOMaterials == null)
					{
						UnityEngine.Debug.LogError("Object " + gameObject.name + " does not have a Renderer");
						_goToAdd[i] = null;
						return false;
					}
					Mesh mesh = MB_Utility.GetMesh(gameObject);
					if (mesh == null)
					{
						UnityEngine.Debug.LogError("Object " + gameObject.name + " MeshFilter or SkinedMeshRenderer had no mesh");
						_goToAdd[i] = null;
						return false;
					}
					if (MBVersion.IsRunningAndMeshNotReadWriteable(mesh))
					{
						UnityEngine.Debug.LogError("Object " + gameObject.name + " Mesh Importer has read/write flag set to 'false'. This needs to be set to 'true' in order to read data from this mesh.");
						_goToAdd[i] = null;
						return false;
					}
					MB_TextureTilingTreatment[] array5 = new MB_TextureTilingTreatment[gOMaterials.Length];
					Rect[] array6 = new Rect[gOMaterials.Length];
					Rect[] array7 = new Rect[gOMaterials.Length];
					Rect[] array8 = new Rect[gOMaterials.Length];
					string errorMsg = "";
					for (int num7 = 0; num7 < gOMaterials.Length; num7++)
					{
						object obj = orderedDictionary[gOMaterials[num7]];
						if (obj == null)
						{
							UnityEngine.Debug.LogError(string.Concat("Source object ", gameObject.name, " used a material ", gOMaterials[num7], " that was not in the baked materials."));
							return false;
						}
						int idxInResultMats = (int)obj;
						if (!material2AtlasRectangleMapper.TryMapMaterialToUVRect(gOMaterials[num7], mesh, num7, idxInResultMats, meshChannelsCache, dictionary, out array5[num7], out array6[num7], out array7[num7], out array8[num7], ref errorMsg, LOG_LEVEL))
						{
							UnityEngine.Debug.LogError(errorMsg);
							_goToAdd[i] = null;
							return false;
						}
					}
					if (!(_goToAdd[i] != null))
					{
						continue;
					}
					list.Add(mB_DynamicGameObject);
					mB_DynamicGameObject.name = $"{_goToAdd[i].ToString()} {_goToAdd[i].GetInstanceID()}";
					mB_DynamicGameObject.instanceID = _goToAdd[i].GetInstanceID();
					mB_DynamicGameObject.uvRects = array6;
					mB_DynamicGameObject.encapsulatingRect = array7;
					mB_DynamicGameObject.sourceMaterialTiling = array8;
					mB_DynamicGameObject.numVerts = mesh.vertexCount;
					if (_doBlendShapes)
					{
						mB_DynamicGameObject.numBlendShapes = mesh.blendShapeCount;
					}
					Renderer renderer = MB_Utility.GetRenderer(gameObject);
					if (renderType == MB_RenderType.skinnedMeshRenderer)
					{
						_CollectBonesToAddForDGO(mB_DynamicGameObject, dictionary2, hashSet, hashSet2, renderer, meshChannelsCache);
					}
					if (lightmapIndex == -1)
					{
						lightmapIndex = renderer.lightmapIndex;
					}
					if (lightmapOption == MB2_LightmapOptions.preserve_current_lightmapping)
					{
						if (lightmapIndex != renderer.lightmapIndex && LOG_LEVEL >= MB2_LogLevel.warn)
						{
							UnityEngine.Debug.LogWarning("Object " + gameObject.name + " has a different lightmap index. Lightmapping will not work.");
						}
						if (!MBVersion.GetActive(gameObject) && LOG_LEVEL >= MB2_LogLevel.warn)
						{
							UnityEngine.Debug.LogWarning("Object " + gameObject.name + " is inactive. Can only get lightmap index of active objects.");
						}
						if (renderer.lightmapIndex == -1 && LOG_LEVEL >= MB2_LogLevel.warn)
						{
							UnityEngine.Debug.LogWarning("Object " + gameObject.name + " does not have an index to a lightmap.");
						}
					}
					mB_DynamicGameObject.lightmapIndex = renderer.lightmapIndex;
					mB_DynamicGameObject.lightmapTilingOffset = MBVersion.GetLightmapTilingOffset(renderer);
					if (!_collectMaterialTriangles(mesh, mB_DynamicGameObject, gOMaterials, orderedDictionary))
					{
						return false;
					}
					mB_DynamicGameObject.meshSize = renderer.bounds.size;
					mB_DynamicGameObject.submeshNumTris = new int[num];
					mB_DynamicGameObject.submeshTriIdxs = new int[num];
					if (textureBakeResults.DoAnyResultMatsUseConsiderMeshUVs() && !_collectOutOfBoundsUVRects2(mesh, mB_DynamicGameObject, gOMaterials, orderedDictionary, dictionary, meshChannelsCache))
					{
						return false;
					}
					num4 += mB_DynamicGameObject.numVerts;
					num5 += mB_DynamicGameObject.numBlendShapes;
					for (int num8 = 0; num8 < mB_DynamicGameObject._tmpSubmeshTris.Length; num8++)
					{
						array4[mB_DynamicGameObject.targetSubmeshIdxs[num8]] += mB_DynamicGameObject._tmpSubmeshTris[num8].data.Length;
					}
					mB_DynamicGameObject.invertTriangles = IsMirrored(gameObject.transform.localToWorldMatrix);
				}
				else
				{
					if (LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning("Object " + _goToAdd[i].name + " has already been added");
					}
					_goToAdd[i] = null;
				}
			}
			for (int num9 = 0; num9 < _goToAdd.Length; num9++)
			{
				if (_goToAdd[num9] != null && disableRendererInSource)
				{
					MB_Utility.DisableRendererInSource(_goToAdd[num9]);
					if (LOG_LEVEL == MB2_LogLevel.trace)
					{
						UnityEngine.Debug.Log("Disabling renderer on " + _goToAdd[num9].name + " id=" + _goToAdd[num9].GetInstanceID());
					}
				}
			}
			int num10 = verts.Length + num4 - num2;
			int num11 = bindPoses.Length + hashSet2.Count - hashSet.Count;
			int[] array9 = new int[num];
			int num12 = blendShapes.Length + num5 - num3;
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Verts adding:" + num4 + " deleting:" + num2 + " submeshes:" + array9.Length + " bones:" + num11 + " blendShapes:" + num12);
			}
			for (int num13 = 0; num13 < array9.Length; num13++)
			{
				array9[num13] = submeshTris[num13].data.Length + array4[num13] - array2[num13];
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug("    submesh :" + num13 + " already contains:" + submeshTris[num13].data.Length + " tris to be Added:" + array4[num13] + " tris to be Deleted:" + array2[num13]);
				}
			}
			if (num10 >= MBVersion.MaxMeshVertexCount())
			{
				UnityEngine.Debug.LogError("Cannot add objects. Resulting mesh will have more than " + MBVersion.MaxMeshVertexCount() + " vertices. Try using a Multi-MeshBaker component. This will split the combined mesh into several meshes. You don't have to re-configure the MB2_TextureBaker. Just remove the MB2_MeshBaker component and add a MB2_MultiMeshBaker component.");
				return false;
			}
			Vector3[] destinationArray = null;
			Vector4[] destinationArray2 = null;
			Vector2[] destinationArray3 = null;
			Vector2[] destinationArray4 = null;
			Vector2[] destinationArray5 = null;
			Vector2[] destinationArray6 = null;
			UnityEngine.Color[] destinationArray7 = null;
			MBBlendShape[] array10 = null;
			Vector3[] destinationArray8 = new Vector3[num10];
			if (_doNorm)
			{
				destinationArray = new Vector3[num10];
			}
			if (_doTan)
			{
				destinationArray2 = new Vector4[num10];
			}
			if (_doUV)
			{
				destinationArray3 = new Vector2[num10];
			}
			if (_doUV3)
			{
				destinationArray5 = new Vector2[num10];
			}
			if (_doUV4)
			{
				destinationArray6 = new Vector2[num10];
			}
			if (doUV2())
			{
				destinationArray4 = new Vector2[num10];
			}
			if (_doCol)
			{
				destinationArray7 = new UnityEngine.Color[num10];
			}
			if (_doBlendShapes)
			{
				array10 = new MBBlendShape[num12];
			}
			BoneWeight[] array11 = new BoneWeight[num10];
			Matrix4x4[] array12 = new Matrix4x4[num11];
			Transform[] array13 = new Transform[num11];
			SerializableIntArray[] array14 = new SerializableIntArray[num];
			for (int num14 = 0; num14 < array14.Length; num14++)
			{
				array14[num14] = new SerializableIntArray(array9[num14]);
			}
			for (int num15 = 0; num15 < array.Length; num15++)
			{
				MB_DynamicGameObject dgo2 = null;
				if (instance2Combined_MapTryGetValue(array[num15], out dgo2))
				{
					dgo2._beingDeleted = true;
				}
			}
			mbDynamicObjectsInCombinedMesh.Sort();
			int num16 = 0;
			int num17 = 0;
			int[] array15 = new int[num];
			int num18 = 0;
			for (int num19 = 0; num19 < mbDynamicObjectsInCombinedMesh.Count; num19++)
			{
				MB_DynamicGameObject mB_DynamicGameObject2 = mbDynamicObjectsInCombinedMesh[num19];
				if (!mB_DynamicGameObject2._beingDeleted)
				{
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug("Copying obj in combined arrays idx:" + num19, LOG_LEVEL);
					}
					Array.Copy(verts, mB_DynamicGameObject2.vertIdx, destinationArray8, num16, mB_DynamicGameObject2.numVerts);
					if (_doNorm)
					{
						Array.Copy(normals, mB_DynamicGameObject2.vertIdx, destinationArray, num16, mB_DynamicGameObject2.numVerts);
					}
					if (_doTan)
					{
						Array.Copy(tangents, mB_DynamicGameObject2.vertIdx, destinationArray2, num16, mB_DynamicGameObject2.numVerts);
					}
					if (_doUV)
					{
						Array.Copy(uvs, mB_DynamicGameObject2.vertIdx, destinationArray3, num16, mB_DynamicGameObject2.numVerts);
					}
					if (_doUV3)
					{
						Array.Copy(uv3s, mB_DynamicGameObject2.vertIdx, destinationArray5, num16, mB_DynamicGameObject2.numVerts);
					}
					if (_doUV4)
					{
						Array.Copy(uv4s, mB_DynamicGameObject2.vertIdx, destinationArray6, num16, mB_DynamicGameObject2.numVerts);
					}
					if (doUV2())
					{
						Array.Copy(uv2s, mB_DynamicGameObject2.vertIdx, destinationArray4, num16, mB_DynamicGameObject2.numVerts);
					}
					if (_doCol)
					{
						Array.Copy(colors, mB_DynamicGameObject2.vertIdx, destinationArray7, num16, mB_DynamicGameObject2.numVerts);
					}
					if (_doBlendShapes)
					{
						Array.Copy(blendShapes, mB_DynamicGameObject2.blendShapeIdx, array10, num17, mB_DynamicGameObject2.numBlendShapes);
					}
					if (renderType == MB_RenderType.skinnedMeshRenderer)
					{
						Array.Copy(boneWeights, mB_DynamicGameObject2.vertIdx, array11, num16, mB_DynamicGameObject2.numVerts);
					}
					for (int num20 = 0; num20 < num; num20++)
					{
						int[] data = submeshTris[num20].data;
						int num21 = mB_DynamicGameObject2.submeshTriIdxs[num20];
						int num22 = mB_DynamicGameObject2.submeshNumTris[num20];
						if (LOG_LEVEL >= MB2_LogLevel.debug)
						{
							MB2_Log.LogDebug("    Adjusting submesh triangles submesh:" + num20 + " startIdx:" + num21 + " num:" + num22 + " nsubmeshTris:" + array14.Length + " targSubmeshTidx:" + array15.Length, LOG_LEVEL);
						}
						for (int num23 = num21; num23 < num21 + num22; num23++)
						{
							data[num23] -= num18;
						}
						Array.Copy(data, num21, array14[num20].data, array15[num20], num22);
					}
					mB_DynamicGameObject2.vertIdx = num16;
					mB_DynamicGameObject2.blendShapeIdx = num17;
					for (int num24 = 0; num24 < array15.Length; num24++)
					{
						mB_DynamicGameObject2.submeshTriIdxs[num24] = array15[num24];
						array15[num24] += mB_DynamicGameObject2.submeshNumTris[num24];
					}
					num17 += mB_DynamicGameObject2.numBlendShapes;
					num16 += mB_DynamicGameObject2.numVerts;
				}
				else
				{
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug("Not copying obj: " + num19, LOG_LEVEL);
					}
					num18 += mB_DynamicGameObject2.numVerts;
				}
			}
			if (renderType == MB_RenderType.skinnedMeshRenderer)
			{
				_CopyBonesWeAreKeepingToNewBonesArrayAndAdjustBWIndexes(hashSet, hashSet2, array13, array12, array11, num2);
			}
			for (int num25 = mbDynamicObjectsInCombinedMesh.Count - 1; num25 >= 0; num25--)
			{
				if (mbDynamicObjectsInCombinedMesh[num25]._beingDeleted)
				{
					instance2Combined_MapRemove(mbDynamicObjectsInCombinedMesh[num25].instanceID);
					objectsInCombinedMesh.RemoveAt(num25);
					mbDynamicObjectsInCombinedMesh.RemoveAt(num25);
				}
			}
			verts = destinationArray8;
			if (_doNorm)
			{
				normals = destinationArray;
			}
			if (_doTan)
			{
				tangents = destinationArray2;
			}
			if (_doUV)
			{
				uvs = destinationArray3;
			}
			if (_doUV3)
			{
				uv3s = destinationArray5;
			}
			if (_doUV4)
			{
				uv4s = destinationArray6;
			}
			if (doUV2())
			{
				uv2s = destinationArray4;
			}
			if (_doCol)
			{
				colors = destinationArray7;
			}
			if (_doBlendShapes)
			{
				blendShapes = array10;
			}
			if (renderType == MB_RenderType.skinnedMeshRenderer)
			{
				boneWeights = array11;
			}
			int num26 = bones.Length - hashSet.Count;
			bindPoses = array12;
			bones = array13;
			submeshTris = array14;
			int num27 = 0;
			foreach (BoneAndBindpose item in hashSet2)
			{
				array13[num26 + num27] = item.bone;
				array12[num26 + num27] = item.bindPose;
				num27++;
			}
			for (int num28 = 0; num28 < list.Count; num28++)
			{
				MB_DynamicGameObject mB_DynamicGameObject3 = list[num28];
				GameObject gameObject2 = _goToAdd[num28];
				int num29 = num16;
				int index = num17;
				Mesh mesh2 = MB_Utility.GetMesh(gameObject2);
				Matrix4x4 localToWorldMatrix = gameObject2.transform.localToWorldMatrix;
				Matrix4x4 matrix4x = localToWorldMatrix;
				float num31 = (matrix4x[2, 3] = 0f);
				float value = (matrix4x[1, 3] = num31);
				matrix4x[0, 3] = value;
				destinationArray8 = meshChannelsCache.GetVertices(mesh2);
				Vector3[] array16 = null;
				Vector4[] array17 = null;
				if (_doNorm)
				{
					array16 = meshChannelsCache.GetNormals(mesh2);
				}
				if (_doTan)
				{
					array17 = meshChannelsCache.GetTangents(mesh2);
				}
				if (renderType != MB_RenderType.skinnedMeshRenderer)
				{
					for (int num33 = 0; num33 < destinationArray8.Length; num33++)
					{
						int num34 = num29 + num33;
						verts[num29 + num33] = localToWorldMatrix.MultiplyPoint3x4(destinationArray8[num33]);
						if (_doNorm)
						{
							normals[num34] = matrix4x.MultiplyPoint3x4(array16[num33]);
							normals[num34] = normals[num34].normalized;
						}
						if (_doTan)
						{
							float w = array17[num33].w;
							Vector3 vector = matrix4x.MultiplyPoint3x4(array17[num33]);
							vector.Normalize();
							tangents[num34] = vector;
							tangents[num34].w = w;
						}
					}
				}
				else
				{
					if (_doNorm)
					{
						array16.CopyTo(normals, num29);
					}
					if (_doTan)
					{
						array17.CopyTo(tangents, num29);
					}
					destinationArray8.CopyTo(verts, num29);
				}
				int subMeshCount = mesh2.subMeshCount;
				if (mB_DynamicGameObject3.uvRects.Length < subMeshCount)
				{
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug("Mesh " + mB_DynamicGameObject3.name + " has more submeshes than materials");
					}
					subMeshCount = mB_DynamicGameObject3.uvRects.Length;
				}
				else if (mB_DynamicGameObject3.uvRects.Length > subMeshCount && LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Mesh " + mB_DynamicGameObject3.name + " has fewer submeshes than materials");
				}
				if (_doUV)
				{
					_copyAndAdjustUVsFromMesh(mB_DynamicGameObject3, mesh2, num29, meshChannelsCache);
				}
				if (doUV2())
				{
					_copyAndAdjustUV2FromMesh(mB_DynamicGameObject3, mesh2, num29, meshChannelsCache);
				}
				if (_doUV3)
				{
					destinationArray5 = meshChannelsCache.GetUv3(mesh2);
					destinationArray5.CopyTo(uv3s, num29);
				}
				if (_doUV4)
				{
					destinationArray6 = meshChannelsCache.GetUv4(mesh2);
					destinationArray6.CopyTo(uv4s, num29);
				}
				if (_doCol)
				{
					destinationArray7 = meshChannelsCache.GetColors(mesh2);
					destinationArray7.CopyTo(colors, num29);
				}
				if (_doBlendShapes)
				{
					array10 = meshChannelsCache.GetBlendShapes(mesh2, mB_DynamicGameObject3.instanceID);
					array10.CopyTo(blendShapes, index);
				}
				if (renderType == MB_RenderType.skinnedMeshRenderer)
				{
					Renderer renderer2 = MB_Utility.GetRenderer(gameObject2);
					_AddBonesToNewBonesArrayAndAdjustBWIndexes(mB_DynamicGameObject3, renderer2, num29, array13, array11, meshChannelsCache);
				}
				for (int num35 = 0; num35 < array15.Length; num35++)
				{
					mB_DynamicGameObject3.submeshTriIdxs[num35] = array15[num35];
				}
				for (int num36 = 0; num36 < mB_DynamicGameObject3._tmpSubmeshTris.Length; num36++)
				{
					int[] data2 = mB_DynamicGameObject3._tmpSubmeshTris[num36].data;
					for (int num37 = 0; num37 < data2.Length; num37++)
					{
						data2[num37] += num29;
					}
					if (mB_DynamicGameObject3.invertTriangles)
					{
						for (int num38 = 0; num38 < data2.Length; num38 += 3)
						{
							int num39 = data2[num38];
							data2[num38] = data2[num38 + 1];
							data2[num38 + 1] = num39;
						}
					}
					int num40 = mB_DynamicGameObject3.targetSubmeshIdxs[num36];
					data2.CopyTo(submeshTris[num40].data, array15[num40]);
					mB_DynamicGameObject3.submeshNumTris[num40] += data2.Length;
					array15[num40] += data2.Length;
				}
				mB_DynamicGameObject3.vertIdx = num16;
				mB_DynamicGameObject3.blendShapeIdx = num17;
				instance2Combined_MapAdd(gameObject2.GetInstanceID(), mB_DynamicGameObject3);
				objectsInCombinedMesh.Add(gameObject2);
				mbDynamicObjectsInCombinedMesh.Add(mB_DynamicGameObject3);
				num16 += destinationArray8.Length;
				if (_doBlendShapes)
				{
					num17 += array10.Length;
				}
				for (int num41 = 0; num41 < mB_DynamicGameObject3._tmpSubmeshTris.Length; num41++)
				{
					mB_DynamicGameObject3._tmpSubmeshTris[num41] = null;
				}
				mB_DynamicGameObject3._tmpSubmeshTris = null;
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug("Added to combined:" + mB_DynamicGameObject3.name + " verts:" + destinationArray8.Length + " bindPoses:" + array12.Length, LOG_LEVEL);
				}
			}
			if (lightmapOption == MB2_LightmapOptions.copy_UV2_unchanged_to_separate_rects)
			{
				_copyUV2unchangedToSeparateRects();
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				MB2_Log.LogDebug("===== _addToCombined completed. Verts in buffer: " + verts.Length + " time(ms): " + stopwatch.ElapsedMilliseconds, LOG_LEVEL);
			}
			return true;
		}

		private void _copyAndAdjustUVsFromMesh(MB_DynamicGameObject dgo, Mesh mesh, int vertsIdx, MeshChannelsCache meshChannelsCache)
		{
			Vector2[] uv0Raw = meshChannelsCache.GetUv0Raw(mesh);
			int[] array = new int[uv0Raw.Length];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = -1;
			}
			bool flag = false;
			for (int j = 0; j < dgo.targetSubmeshIdxs.Length; j++)
			{
				int[] array2 = ((dgo._tmpSubmeshTris == null) ? mesh.GetTriangles(j) : dgo._tmpSubmeshTris[j].data);
				if (LOG_LEVEL >= MB2_LogLevel.trace)
				{
					UnityEngine.Debug.Log($"Build UV transform for mesh {dgo.name} submesh {j} encapsulatingRect {dgo.encapsulatingRect[j]}");
				}
				Rect rect = MB3_TextureCombinerMerging.BuildTransformMeshUV2AtlasRect(textureBakeResults.resultMaterials[dgo.targetSubmeshIdxs[j]].considerMeshUVs, dgo.uvRects[j], (dgo.obUVRects == null) ? new Rect(0f, 0f, 1f, 1f) : dgo.obUVRects[j], dgo.sourceMaterialTiling[j], dgo.encapsulatingRect[j]);
				foreach (int num in array2)
				{
					if (array[num] == -1)
					{
						array[num] = j;
						Vector2 vector = uv0Raw[num];
						vector.x = rect.x + vector.x * rect.width;
						vector.y = rect.y + vector.y * rect.height;
						uvs[vertsIdx + num] = vector;
					}
					if (array[num] != j)
					{
						flag = true;
					}
				}
			}
			if (flag && LOG_LEVEL >= MB2_LogLevel.warn)
			{
				UnityEngine.Debug.LogWarning(dgo.name + "has submeshes which share verticies. Adjusted uvs may not map correctly in combined atlas.");
			}
			if (LOG_LEVEL >= MB2_LogLevel.trace)
			{
				UnityEngine.Debug.Log($"_copyAndAdjustUVsFromMesh copied {uv0Raw.Length} verts");
			}
		}

		private void _copyAndAdjustUV2FromMesh(MB_DynamicGameObject dgo, Mesh mesh, int vertsIdx, MeshChannelsCache meshChannelsCache)
		{
			Vector2[] uv = meshChannelsCache.GetUv2(mesh);
			if (lightmapOption == MB2_LightmapOptions.preserve_current_lightmapping)
			{
				Vector4 lightmapTilingOffset = dgo.lightmapTilingOffset;
				Vector2 vector = new Vector2(lightmapTilingOffset.x, lightmapTilingOffset.y);
				Vector2 vector2 = new Vector2(lightmapTilingOffset.z, lightmapTilingOffset.w);
				Vector2 vector3 = default(Vector2);
				for (int i = 0; i < uv.Length; i++)
				{
					vector3.x = vector.x * uv[i].x;
					vector3.y = vector.y * uv[i].y;
					uv2s[vertsIdx + i] = vector2 + vector3;
				}
				if (LOG_LEVEL >= MB2_LogLevel.trace)
				{
					UnityEngine.Debug.Log("_copyAndAdjustUV2FromMesh copied and modify for preserve current lightmapping " + uv.Length);
				}
			}
			else
			{
				uv.CopyTo(uv2s, vertsIdx);
				if (LOG_LEVEL >= MB2_LogLevel.trace)
				{
					UnityEngine.Debug.Log("_copyAndAdjustUV2FromMesh copied without modifying " + uv.Length);
				}
			}
		}

		public override void UpdateSkinnedMeshApproximateBounds()
		{
			UpdateSkinnedMeshApproximateBoundsFromBounds();
		}

		public override void UpdateSkinnedMeshApproximateBoundsFromBones()
		{
			if (outputOption == MB2_OutputOptions.bakeMeshAssetsInPlace)
			{
				if (LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Can't UpdateSkinnedMeshApproximateBounds when output type is bakeMeshAssetsInPlace");
				}
			}
			else if (bones.Length == 0)
			{
				if (verts.Length != 0 && LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("No bones in SkinnedMeshRenderer. Could not UpdateSkinnedMeshApproximateBounds.");
				}
			}
			else if (_targetRenderer == null)
			{
				if (LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Target Renderer is not set. No point in calling UpdateSkinnedMeshApproximateBounds.");
				}
			}
			else if (!_targetRenderer.GetType().Equals(typeof(SkinnedMeshRenderer)))
			{
				if (LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Target Renderer is not a SkinnedMeshRenderer. No point in calling UpdateSkinnedMeshApproximateBounds.");
				}
			}
			else
			{
				MB3_MeshCombiner.UpdateSkinnedMeshApproximateBoundsFromBonesStatic(bones, (SkinnedMeshRenderer)targetRenderer);
			}
		}

		public override void UpdateSkinnedMeshApproximateBoundsFromBounds()
		{
			if (outputOption == MB2_OutputOptions.bakeMeshAssetsInPlace)
			{
				if (LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Can't UpdateSkinnedMeshApproximateBoundsFromBounds when output type is bakeMeshAssetsInPlace");
				}
			}
			else if (verts.Length == 0 || mbDynamicObjectsInCombinedMesh.Count == 0)
			{
				if (verts.Length != 0 && LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Nothing in SkinnedMeshRenderer. Could not UpdateSkinnedMeshApproximateBoundsFromBounds.");
				}
			}
			else if (_targetRenderer == null)
			{
				if (LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Target Renderer is not set. No point in calling UpdateSkinnedMeshApproximateBoundsFromBounds.");
				}
			}
			else if (!_targetRenderer.GetType().Equals(typeof(SkinnedMeshRenderer)))
			{
				if (LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Target Renderer is not a SkinnedMeshRenderer. No point in calling UpdateSkinnedMeshApproximateBoundsFromBounds.");
				}
			}
			else
			{
				MB3_MeshCombiner.UpdateSkinnedMeshApproximateBoundsFromBoundsStatic(objectsInCombinedMesh, (SkinnedMeshRenderer)targetRenderer);
			}
		}

		private int _getNumBones(Renderer r)
		{
			if (renderType == MB_RenderType.skinnedMeshRenderer)
			{
				if (r is SkinnedMeshRenderer)
				{
					return ((SkinnedMeshRenderer)r).bones.Length;
				}
				if (r is MeshRenderer)
				{
					return 1;
				}
				UnityEngine.Debug.LogError("Could not _getNumBones. Object does not have a renderer");
				return 0;
			}
			return 0;
		}

		private Transform[] _getBones(Renderer r)
		{
			return MBVersion.GetBones(r);
		}

		public override void Apply(GenerateUV2Delegate uv2GenerationMethod)
		{
			bool flag = false;
			if (renderType == MB_RenderType.skinnedMeshRenderer)
			{
				flag = true;
			}
			Apply(triangles: true, vertices: true, _doNorm, _doTan, _doUV, doUV2(), _doUV3, _doUV4, doCol, flag, doBlendShapes, uv2GenerationMethod);
		}

		public virtual void ApplyShowHide()
		{
			if (_validationLevel >= MB2_ValidationLevel.quick && !ValidateTargRendererAndMeshAndResultSceneObj())
			{
				return;
			}
			if (_mesh != null)
			{
				if (renderType == MB_RenderType.meshRenderer)
				{
					MBVersion.MeshClear(_mesh, t: true);
					_mesh.vertices = verts;
				}
				SerializableIntArray[] submeshTrisWithShowHideApplied = GetSubmeshTrisWithShowHideApplied();
				if (textureBakeResults.doMultiMaterial)
				{
					int num2 = (_mesh.subMeshCount = _numNonZeroLengthSubmeshTris(submeshTrisWithShowHideApplied));
					int numNonZeroLengthSubmeshTris = num2;
					int num3 = 0;
					for (int i = 0; i < submeshTrisWithShowHideApplied.Length; i++)
					{
						if (submeshTrisWithShowHideApplied[i].data.Length != 0)
						{
							_mesh.SetTriangles(submeshTrisWithShowHideApplied[i].data, num3);
							num3++;
						}
					}
					_updateMaterialsOnTargetRenderer(submeshTrisWithShowHideApplied, numNonZeroLengthSubmeshTris);
				}
				else
				{
					_mesh.triangles = submeshTrisWithShowHideApplied[0].data;
				}
				if (renderType == MB_RenderType.skinnedMeshRenderer)
				{
					if (verts.Length == 0)
					{
						targetRenderer.enabled = false;
					}
					else
					{
						targetRenderer.enabled = true;
					}
					bool updateWhenOffscreen = ((SkinnedMeshRenderer)targetRenderer).updateWhenOffscreen;
					((SkinnedMeshRenderer)targetRenderer).updateWhenOffscreen = true;
					((SkinnedMeshRenderer)targetRenderer).updateWhenOffscreen = updateWhenOffscreen;
				}
				if (LOG_LEVEL >= MB2_LogLevel.trace)
				{
					UnityEngine.Debug.Log("ApplyShowHide");
				}
			}
			else
			{
				UnityEngine.Debug.LogError("Need to add objects to this meshbaker before calling ApplyShowHide");
			}
		}

		public override void Apply(bool triangles, bool vertices, bool normals, bool tangents, bool uvs, bool uv2, bool uv3, bool uv4, bool colors, bool bones = false, bool blendShapesFlag = false, GenerateUV2Delegate uv2GenerationMethod = null)
		{
			Stopwatch stopwatch = null;
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				stopwatch = new Stopwatch();
				stopwatch.Start();
			}
			if (_validationLevel >= MB2_ValidationLevel.quick && !ValidateTargRendererAndMeshAndResultSceneObj())
			{
				return;
			}
			if (_mesh != null)
			{
				if (LOG_LEVEL >= MB2_LogLevel.trace)
				{
					UnityEngine.Debug.Log($"Apply called tri={triangles} vert={vertices} norm={normals} tan={tangents} uv={uvs} col={colors} uv3={uv3} uv4={uv4} uv2={uv2} bone={bones} blendShape{blendShapes} meshID={_mesh.GetInstanceID()}");
				}
				if (triangles || _mesh.vertexCount != verts.Length)
				{
					bool justClearTriangles = triangles && !vertices && !normals && !tangents && !uvs && !colors && !uv3 && !uv4 && !uv2 && !bones;
					MBVersion.SetMeshIndexFormatAndClearMesh(_mesh, verts.Length, vertices, justClearTriangles);
				}
				if (vertices)
				{
					Vector3[] array = verts;
					if (verts.Length != 0)
					{
						if (_recenterVertsToBoundsCenter && _renderType == MB_RenderType.meshRenderer)
						{
							array = new Vector3[verts.Length];
							Vector3 vector = verts[0];
							Vector3 vector2 = verts[0];
							for (int i = 1; i < verts.Length; i++)
							{
								Vector3 vector3 = verts[i];
								if (vector.x < vector3.x)
								{
									vector.x = vector3.x;
								}
								if (vector.y < vector3.y)
								{
									vector.y = vector3.y;
								}
								if (vector.z < vector3.z)
								{
									vector.z = vector3.z;
								}
								if (vector2.x > vector3.x)
								{
									vector2.x = vector3.x;
								}
								if (vector2.y > vector3.y)
								{
									vector2.y = vector3.y;
								}
								if (vector2.z > vector3.z)
								{
									vector2.z = vector3.z;
								}
							}
							Vector3 vector4 = (vector + vector2) / 2f;
							for (int j = 0; j < verts.Length; j++)
							{
								array[j] = verts[j] - vector4;
							}
							targetRenderer.transform.position = vector4;
						}
						else
						{
							targetRenderer.transform.position = Vector3.zero;
						}
					}
					_mesh.vertices = array;
				}
				if (triangles && (bool)_textureBakeResults)
				{
					if (_textureBakeResults == null)
					{
						UnityEngine.Debug.LogError("Texture Bake Result was not set.");
					}
					else
					{
						SerializableIntArray[] submeshTrisWithShowHideApplied = GetSubmeshTrisWithShowHideApplied();
						int num2 = (_mesh.subMeshCount = _numNonZeroLengthSubmeshTris(submeshTrisWithShowHideApplied));
						int numNonZeroLengthSubmeshTris = num2;
						int num3 = 0;
						for (int k = 0; k < submeshTrisWithShowHideApplied.Length; k++)
						{
							if (submeshTrisWithShowHideApplied[k].data.Length != 0)
							{
								_mesh.SetTriangles(submeshTrisWithShowHideApplied[k].data, num3);
								num3++;
							}
						}
						_updateMaterialsOnTargetRenderer(submeshTrisWithShowHideApplied, numNonZeroLengthSubmeshTris);
					}
				}
				if (normals)
				{
					if (_doNorm)
					{
						_mesh.normals = this.normals;
					}
					else
					{
						UnityEngine.Debug.LogError("normal flag was set in Apply but MeshBaker didn't generate normals");
					}
				}
				if (tangents)
				{
					if (_doTan)
					{
						_mesh.tangents = this.tangents;
					}
					else
					{
						UnityEngine.Debug.LogError("tangent flag was set in Apply but MeshBaker didn't generate tangents");
					}
				}
				if (uvs)
				{
					if (_doUV)
					{
						_mesh.uv = this.uvs;
					}
					else
					{
						UnityEngine.Debug.LogError("uv flag was set in Apply but MeshBaker didn't generate uvs");
					}
				}
				if (colors)
				{
					if (_doCol)
					{
						_mesh.colors = this.colors;
					}
					else
					{
						UnityEngine.Debug.LogError("color flag was set in Apply but MeshBaker didn't generate colors");
					}
				}
				if (uv3)
				{
					if (_doUV3)
					{
						MBVersion.MeshAssignUV3(_mesh, uv3s);
					}
					else
					{
						UnityEngine.Debug.LogError("uv3 flag was set in Apply but MeshBaker didn't generate uv3s");
					}
				}
				if (uv4)
				{
					if (_doUV4)
					{
						MBVersion.MeshAssignUV4(_mesh, uv4s);
					}
					else
					{
						UnityEngine.Debug.LogError("uv4 flag was set in Apply but MeshBaker didn't generate uv4s");
					}
				}
				if (uv2)
				{
					if (doUV2())
					{
						_mesh.uv2 = uv2s;
					}
					else
					{
						UnityEngine.Debug.LogError("uv2 flag was set in Apply but lightmapping option was set to " + lightmapOption);
					}
				}
				bool flag = false;
				if (renderType != MB_RenderType.skinnedMeshRenderer && lightmapOption == MB2_LightmapOptions.generate_new_UV2_layout)
				{
					if (uv2GenerationMethod != null)
					{
						uv2GenerationMethod(_mesh, uv2UnwrappingParamsHardAngle, uv2UnwrappingParamsPackMargin);
						if (LOG_LEVEL >= MB2_LogLevel.trace)
						{
							UnityEngine.Debug.Log("generating new UV2 layout for the combined mesh ");
						}
					}
					else
					{
						UnityEngine.Debug.LogError("No GenerateUV2Delegate method was supplied. UV2 cannot be generated.");
					}
					flag = true;
				}
				else if (renderType == MB_RenderType.skinnedMeshRenderer && lightmapOption == MB2_LightmapOptions.generate_new_UV2_layout && LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("UV2 cannot be generated for SkinnedMeshRenderer objects.");
				}
				if (renderType != MB_RenderType.skinnedMeshRenderer && lightmapOption == MB2_LightmapOptions.generate_new_UV2_layout && !flag)
				{
					UnityEngine.Debug.LogError("Failed to generate new UV2 layout. Only works in editor.");
				}
				if (renderType == MB_RenderType.skinnedMeshRenderer)
				{
					if (verts.Length == 0)
					{
						targetRenderer.enabled = false;
					}
					else
					{
						targetRenderer.enabled = true;
					}
					bool updateWhenOffscreen = ((SkinnedMeshRenderer)targetRenderer).updateWhenOffscreen;
					((SkinnedMeshRenderer)targetRenderer).updateWhenOffscreen = true;
					((SkinnedMeshRenderer)targetRenderer).updateWhenOffscreen = updateWhenOffscreen;
				}
				if (bones)
				{
					_mesh.bindposes = bindPoses;
					_mesh.boneWeights = boneWeights;
				}
				if (blendShapesFlag && (MBVersion.GetMajorVersion() > 5 || (MBVersion.GetMajorVersion() == 5 && MBVersion.GetMinorVersion() >= 3)))
				{
					if (blendShapesInCombined.Length != blendShapes.Length)
					{
						blendShapesInCombined = new MBBlendShape[blendShapes.Length];
					}
					Vector3[] array2 = new Vector3[verts.Length];
					Vector3[] array3 = new Vector3[verts.Length];
					Vector3[] array4 = new Vector3[verts.Length];
					MBVersion.ClearBlendShapes(_mesh);
					for (int l = 0; l < blendShapes.Length; l++)
					{
						MB_DynamicGameObject mB_DynamicGameObject = instance2Combined_MapGet(blendShapes[l].gameObjectID);
						if (mB_DynamicGameObject != null)
						{
							for (int m = 0; m < blendShapes[l].frames.Length; m++)
							{
								MBBlendShapeFrame mBBlendShapeFrame = blendShapes[l].frames[m];
								int vertIdx = mB_DynamicGameObject.vertIdx;
								Array.Copy(mBBlendShapeFrame.vertices, 0, array2, vertIdx, blendShapes[l].frames[m].vertices.Length);
								Array.Copy(mBBlendShapeFrame.normals, 0, array3, vertIdx, blendShapes[l].frames[m].normals.Length);
								Array.Copy(mBBlendShapeFrame.tangents, 0, array4, vertIdx, blendShapes[l].frames[m].tangents.Length);
								MBVersion.AddBlendShapeFrame(_mesh, blendShapes[l].name + blendShapes[l].gameObjectID, mBBlendShapeFrame.frameWeight, array2, array3, array4);
								_ZeroArray(array2, vertIdx, blendShapes[l].frames[m].vertices.Length);
								_ZeroArray(array3, vertIdx, blendShapes[l].frames[m].normals.Length);
								_ZeroArray(array4, vertIdx, blendShapes[l].frames[m].tangents.Length);
							}
						}
						else
						{
							UnityEngine.Debug.LogError("InstanceID in blend shape that was not in instance2combinedMap");
						}
						blendShapesInCombined[l] = blendShapes[l];
					}
					((SkinnedMeshRenderer)_targetRenderer).sharedMesh = null;
					((SkinnedMeshRenderer)_targetRenderer).sharedMesh = _mesh;
				}
				if (triangles || vertices)
				{
					if (LOG_LEVEL >= MB2_LogLevel.trace)
					{
						UnityEngine.Debug.Log("recalculating bounds on mesh.");
					}
					_mesh.RecalculateBounds();
				}
				if (_optimizeAfterBake && !Application.isPlaying)
				{
					MBVersion.OptimizeMesh(_mesh);
				}
			}
			else
			{
				UnityEngine.Debug.LogError("Need to add objects to this meshbaker before calling Apply or ApplyAll");
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Apply Complete time: " + stopwatch.ElapsedMilliseconds + " vertices: " + _mesh.vertexCount);
			}
		}

		private int _numNonZeroLengthSubmeshTris(SerializableIntArray[] subTris)
		{
			int num = 0;
			for (int i = 0; i < subTris.Length; i++)
			{
				if (subTris[i].data.Length != 0)
				{
					num++;
				}
			}
			return num;
		}

		private void _updateMaterialsOnTargetRenderer(SerializableIntArray[] subTris, int numNonZeroLengthSubmeshTris)
		{
			if (subTris.Length != textureBakeResults.resultMaterials.Length)
			{
				UnityEngine.Debug.LogError("Mismatch between number of submeshes and number of result materials");
			}
			Material[] array = new Material[numNonZeroLengthSubmeshTris];
			int num = 0;
			for (int i = 0; i < subTris.Length; i++)
			{
				if (subTris[i].data.Length != 0)
				{
					array[num] = _textureBakeResults.resultMaterials[i].combinedMaterial;
					num++;
				}
			}
			targetRenderer.materials = array;
		}

		public SerializableIntArray[] GetSubmeshTrisWithShowHideApplied()
		{
			bool flag = false;
			for (int i = 0; i < mbDynamicObjectsInCombinedMesh.Count; i++)
			{
				if (!mbDynamicObjectsInCombinedMesh[i].show)
				{
					flag = true;
					break;
				}
			}
			if (flag)
			{
				int[] array = new int[submeshTris.Length];
				SerializableIntArray[] array2 = new SerializableIntArray[submeshTris.Length];
				for (int j = 0; j < mbDynamicObjectsInCombinedMesh.Count; j++)
				{
					MB_DynamicGameObject mB_DynamicGameObject = mbDynamicObjectsInCombinedMesh[j];
					if (mB_DynamicGameObject.show)
					{
						for (int k = 0; k < mB_DynamicGameObject.submeshNumTris.Length; k++)
						{
							array[k] += mB_DynamicGameObject.submeshNumTris[k];
						}
					}
				}
				for (int l = 0; l < array2.Length; l++)
				{
					array2[l] = new SerializableIntArray(array[l]);
				}
				int[] array3 = new int[array2.Length];
				for (int m = 0; m < mbDynamicObjectsInCombinedMesh.Count; m++)
				{
					MB_DynamicGameObject mB_DynamicGameObject2 = mbDynamicObjectsInCombinedMesh[m];
					if (!mB_DynamicGameObject2.show)
					{
						continue;
					}
					for (int n = 0; n < submeshTris.Length; n++)
					{
						int[] data = submeshTris[n].data;
						int num = mB_DynamicGameObject2.submeshTriIdxs[n];
						int num2 = num + mB_DynamicGameObject2.submeshNumTris[n];
						for (int num3 = num; num3 < num2; num3++)
						{
							array2[n].data[array3[n]] = data[num3];
							array3[n]++;
						}
					}
				}
				return array2;
			}
			return submeshTris;
		}

		public override void UpdateGameObjects(GameObject[] gos, bool recalcBounds = true, bool updateVertices = true, bool updateNormals = true, bool updateTangents = true, bool updateUV = false, bool updateUV2 = false, bool updateUV3 = false, bool updateUV4 = false, bool updateColors = false, bool updateSkinningInfo = false)
		{
			_updateGameObjects(gos, recalcBounds, updateVertices, updateNormals, updateTangents, updateUV, updateUV2, updateUV3, updateUV4, updateColors, updateSkinningInfo);
		}

		private void _updateGameObjects(GameObject[] gos, bool recalcBounds, bool updateVertices, bool updateNormals, bool updateTangents, bool updateUV, bool updateUV2, bool updateUV3, bool updateUV4, bool updateColors, bool updateSkinningInfo)
		{
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("UpdateGameObjects called on " + gos.Length + " objects.");
			}
			int numResultMats = 1;
			if (textureBakeResults.doMultiMaterial)
			{
				numResultMats = textureBakeResults.resultMaterials.Length;
			}
			_initialize(numResultMats);
			if (_mesh.vertexCount > 0 && _instance2combined_map.Count == 0)
			{
				UnityEngine.Debug.LogWarning("There were vertices in the combined mesh but nothing in the MeshBaker buffers. If you are trying to bake in the editor and modify at runtime, make sure 'Clear Buffers After Bake' is unchecked.");
			}
			MeshChannelsCache meshChannelCache = new MeshChannelsCache(this);
			for (int i = 0; i < gos.Length; i++)
			{
				_updateGameObject(gos[i], updateVertices, updateNormals, updateTangents, updateUV, updateUV2, updateUV3, updateUV4, updateColors, updateSkinningInfo, meshChannelCache);
			}
			if (recalcBounds)
			{
				_mesh.RecalculateBounds();
			}
		}

		private void _updateGameObject(GameObject go, bool updateVertices, bool updateNormals, bool updateTangents, bool updateUV, bool updateUV2, bool updateUV3, bool updateUV4, bool updateColors, bool updateSkinningInfo, MeshChannelsCache meshChannelCache)
		{
			MB_DynamicGameObject dgo = null;
			if (!instance2Combined_MapTryGetValue(go.GetInstanceID(), out dgo))
			{
				UnityEngine.Debug.LogError("Object " + go.name + " has not been added");
				return;
			}
			Mesh mesh = MB_Utility.GetMesh(go);
			if (dgo.numVerts != mesh.vertexCount)
			{
				UnityEngine.Debug.LogError("Object " + go.name + " source mesh has been modified since being added. To update it must have the same number of verts");
				return;
			}
			if (_doUV && updateUV)
			{
				_copyAndAdjustUVsFromMesh(dgo, mesh, dgo.vertIdx, meshChannelCache);
			}
			if (doUV2() && updateUV2)
			{
				_copyAndAdjustUV2FromMesh(dgo, mesh, dgo.vertIdx, meshChannelCache);
			}
			if (renderType == MB_RenderType.skinnedMeshRenderer && updateSkinningInfo)
			{
				Renderer renderer = MB_Utility.GetRenderer(go);
				BoneWeight[] array = meshChannelCache.GetBoneWeights(renderer, dgo.numVerts);
				Transform[] array2 = _getBones(renderer);
				int num = dgo.vertIdx;
				bool flag = false;
				for (int i = 0; i < array.Length; i++)
				{
					if (array2[array[i].boneIndex0] != bones[boneWeights[num].boneIndex0])
					{
						flag = true;
						break;
					}
					boneWeights[num].weight0 = array[i].weight0;
					boneWeights[num].weight1 = array[i].weight1;
					boneWeights[num].weight2 = array[i].weight2;
					boneWeights[num].weight3 = array[i].weight3;
					num++;
				}
				if (flag)
				{
					UnityEngine.Debug.LogError("Detected that some of the boneweights reference different bones than when initial added. Boneweights must reference the same bones " + dgo.name);
				}
			}
			Matrix4x4 localToWorldMatrix = go.transform.localToWorldMatrix;
			if (updateVertices)
			{
				Vector3[] vertices = meshChannelCache.GetVertices(mesh);
				for (int j = 0; j < vertices.Length; j++)
				{
					verts[dgo.vertIdx + j] = localToWorldMatrix.MultiplyPoint3x4(vertices[j]);
				}
			}
			float num3 = (localToWorldMatrix[2, 3] = 0f);
			float value = (localToWorldMatrix[1, 3] = num3);
			localToWorldMatrix[0, 3] = value;
			if (_doNorm && updateNormals)
			{
				Vector3[] array3 = meshChannelCache.GetNormals(mesh);
				for (int k = 0; k < array3.Length; k++)
				{
					int num5 = dgo.vertIdx + k;
					normals[num5] = localToWorldMatrix.MultiplyPoint3x4(array3[k]);
					normals[num5] = normals[num5].normalized;
				}
			}
			if (_doTan && updateTangents)
			{
				Vector4[] array4 = meshChannelCache.GetTangents(mesh);
				for (int l = 0; l < array4.Length; l++)
				{
					int num6 = dgo.vertIdx + l;
					float w = array4[l].w;
					Vector3 vector = localToWorldMatrix.MultiplyPoint3x4(array4[l]);
					vector.Normalize();
					tangents[num6] = vector;
					tangents[num6].w = w;
				}
			}
			if (_doCol && updateColors)
			{
				UnityEngine.Color[] array5 = meshChannelCache.GetColors(mesh);
				for (int m = 0; m < array5.Length; m++)
				{
					colors[dgo.vertIdx + m] = array5[m];
				}
			}
			if (_doUV3 && updateUV3)
			{
				Vector2[] uv = meshChannelCache.GetUv3(mesh);
				for (int n = 0; n < uv.Length; n++)
				{
					uv3s[dgo.vertIdx + n] = uv[n];
				}
			}
			if (_doUV4 && updateUV4)
			{
				Vector2[] uv2 = meshChannelCache.GetUv4(mesh);
				for (int num7 = 0; num7 < uv2.Length; num7++)
				{
					uv4s[dgo.vertIdx + num7] = uv2[num7];
				}
			}
		}

		public bool ShowHideGameObjects(GameObject[] toShow, GameObject[] toHide)
		{
			if (textureBakeResults == null)
			{
				UnityEngine.Debug.LogError("TextureBakeResults must be set.");
				return false;
			}
			return _showHide(toShow, toHide);
		}

		public override bool AddDeleteGameObjects(GameObject[] gos, GameObject[] deleteGOs, bool disableRendererInSource = true)
		{
			int[] array = null;
			if (deleteGOs != null)
			{
				array = new int[deleteGOs.Length];
				for (int i = 0; i < deleteGOs.Length; i++)
				{
					if (deleteGOs[i] == null)
					{
						UnityEngine.Debug.LogError("The " + i + "th object on the list of objects to delete is 'Null'");
					}
					else
					{
						array[i] = deleteGOs[i].GetInstanceID();
					}
				}
			}
			return AddDeleteGameObjectsByID(gos, array, disableRendererInSource);
		}

		public override bool AddDeleteGameObjectsByID(GameObject[] gos, int[] deleteGOinstanceIDs, bool disableRendererInSource)
		{
			if (validationLevel > MB2_ValidationLevel.none)
			{
				if (gos != null)
				{
					for (int i = 0; i < gos.Length; i++)
					{
						if (gos[i] == null)
						{
							UnityEngine.Debug.LogError("The " + i + "th object on the list of objects to combine is 'None'. Use Command-Delete on Mac OS X; Delete or Shift-Delete on Windows to remove this one element.");
							return false;
						}
						if (validationLevel < MB2_ValidationLevel.robust)
						{
							continue;
						}
						for (int j = i + 1; j < gos.Length; j++)
						{
							if (gos[i] == gos[j])
							{
								UnityEngine.Debug.LogError(string.Concat("GameObject ", gos[i], " appears twice in list of game objects to add"));
								return false;
							}
						}
					}
				}
				if (deleteGOinstanceIDs != null && validationLevel >= MB2_ValidationLevel.robust)
				{
					for (int k = 0; k < deleteGOinstanceIDs.Length; k++)
					{
						for (int l = k + 1; l < deleteGOinstanceIDs.Length; l++)
						{
							if (deleteGOinstanceIDs[k] == deleteGOinstanceIDs[l])
							{
								UnityEngine.Debug.LogError("GameObject " + deleteGOinstanceIDs[k] + "appears twice in list of game objects to delete");
								return false;
							}
						}
					}
				}
			}
			if (_usingTemporaryTextureBakeResult && gos != null && gos.Length != 0)
			{
				MB_Utility.Destroy(_textureBakeResults);
				_textureBakeResults = null;
				_usingTemporaryTextureBakeResult = false;
			}
			if (_textureBakeResults == null && gos != null && gos.Length != 0 && gos[0] != null && !_CreateTemporaryTextrueBakeResult(gos, GetMaterialsOnTargetRenderer()))
			{
				return false;
			}
			BuildSceneMeshObject(gos);
			if (!_addToCombined(gos, deleteGOinstanceIDs, disableRendererInSource))
			{
				UnityEngine.Debug.LogError("Failed to add/delete objects to combined mesh");
				return false;
			}
			if (targetRenderer != null)
			{
				if (renderType == MB_RenderType.skinnedMeshRenderer)
				{
					SkinnedMeshRenderer obj = (SkinnedMeshRenderer)targetRenderer;
					obj.sharedMesh = _mesh;
					obj.bones = bones;
					UpdateSkinnedMeshApproximateBoundsFromBounds();
				}
				targetRenderer.lightmapIndex = GetLightmapIndex();
			}
			return true;
		}

		public override bool CombinedMeshContains(GameObject go)
		{
			return objectsInCombinedMesh.Contains(go);
		}

		public override void ClearBuffers()
		{
			verts = new Vector3[0];
			normals = new Vector3[0];
			tangents = new Vector4[0];
			uvs = new Vector2[0];
			uv2s = new Vector2[0];
			uv3s = new Vector2[0];
			uv4s = new Vector2[0];
			colors = new UnityEngine.Color[0];
			bones = new Transform[0];
			bindPoses = new Matrix4x4[0];
			boneWeights = new BoneWeight[0];
			submeshTris = new SerializableIntArray[0];
			blendShapes = new MBBlendShape[0];
			if (blendShapesInCombined == null)
			{
				blendShapesInCombined = new MBBlendShape[0];
			}
			else
			{
				for (int i = 0; i < blendShapesInCombined.Length; i++)
				{
					blendShapesInCombined[i].frames = new MBBlendShapeFrame[0];
				}
			}
			mbDynamicObjectsInCombinedMesh.Clear();
			objectsInCombinedMesh.Clear();
			instance2Combined_MapClear();
			if (_usingTemporaryTextureBakeResult)
			{
				MB_Utility.Destroy(_textureBakeResults);
				_textureBakeResults = null;
				_usingTemporaryTextureBakeResult = false;
			}
			if (LOG_LEVEL >= MB2_LogLevel.trace)
			{
				MB2_Log.LogDebug("ClearBuffers called");
			}
		}

		public override void ClearMesh()
		{
			if (_mesh != null)
			{
				MBVersion.MeshClear(_mesh, t: false);
			}
			else
			{
				_mesh = new Mesh();
			}
			ClearBuffers();
		}

		public override void DestroyMesh()
		{
			if (_mesh != null)
			{
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug("Destroying Mesh");
				}
				MB_Utility.Destroy(_mesh);
			}
			_mesh = new Mesh();
			ClearBuffers();
		}

		public override void DestroyMeshEditor(MB2_EditorMethodsInterface editorMethods)
		{
			if (_mesh != null)
			{
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug("Destroying Mesh");
				}
				editorMethods.Destroy(_mesh);
			}
			_mesh = new Mesh();
			ClearBuffers();
		}

		public bool ValidateTargRendererAndMeshAndResultSceneObj()
		{
			if (_resultSceneObject == null)
			{
				if (_LOG_LEVEL >= MB2_LogLevel.error)
				{
					UnityEngine.Debug.LogError("Result Scene Object was not set.");
				}
				return false;
			}
			if (_targetRenderer == null)
			{
				if (_LOG_LEVEL >= MB2_LogLevel.error)
				{
					UnityEngine.Debug.LogError("Target Renderer was not set.");
				}
				return false;
			}
			if (_targetRenderer.transform.parent != _resultSceneObject.transform)
			{
				if (_LOG_LEVEL >= MB2_LogLevel.error)
				{
					UnityEngine.Debug.LogError("Target Renderer game object is not a child of Result Scene Object was not set.");
				}
				return false;
			}
			if (_renderType == MB_RenderType.skinnedMeshRenderer && !(_targetRenderer is SkinnedMeshRenderer))
			{
				if (_LOG_LEVEL >= MB2_LogLevel.error)
				{
					UnityEngine.Debug.LogError("Render Type is skinned mesh renderer but Target Renderer is not.");
				}
				return false;
			}
			if (_renderType == MB_RenderType.meshRenderer)
			{
				if (!(_targetRenderer is MeshRenderer))
				{
					if (_LOG_LEVEL >= MB2_LogLevel.error)
					{
						UnityEngine.Debug.LogError("Render Type is mesh renderer but Target Renderer is not.");
					}
					return false;
				}
				MeshFilter component = _targetRenderer.GetComponent<MeshFilter>();
				if (_mesh != component.sharedMesh)
				{
					if (_LOG_LEVEL >= MB2_LogLevel.error)
					{
						UnityEngine.Debug.LogError("Target renderer mesh is not equal to mesh.");
					}
					return false;
				}
			}
			return true;
		}

		internal static Renderer BuildSceneHierarchPreBake(MB3_MeshCombinerSingle mom, GameObject root, Mesh m, bool createNewChild = false, GameObject[] objsToBeAdded = null)
		{
			if (mom._LOG_LEVEL >= MB2_LogLevel.trace)
			{
				UnityEngine.Debug.Log("Building Scene Hierarchy createNewChild=" + createNewChild);
			}
			MeshFilter meshFilter = null;
			MeshRenderer meshRenderer = null;
			SkinnedMeshRenderer skinnedMeshRenderer = null;
			Transform transform = null;
			if (root == null)
			{
				UnityEngine.Debug.LogError("root was null.");
				return null;
			}
			if (mom.textureBakeResults == null)
			{
				UnityEngine.Debug.LogError("textureBakeResults must be set.");
				return null;
			}
			if (root.GetComponent<Renderer>() != null)
			{
				UnityEngine.Debug.LogError("root game object cannot have a renderer component");
				return null;
			}
			if (!createNewChild)
			{
				if (mom.targetRenderer != null && mom.targetRenderer.transform.parent == root.transform)
				{
					transform = mom.targetRenderer.transform;
				}
				else
				{
					Renderer[] componentsInChildren = root.GetComponentsInChildren<Renderer>();
					if (componentsInChildren.Length == 1)
					{
						if (componentsInChildren[0].transform.parent != root.transform)
						{
							UnityEngine.Debug.LogError("Target Renderer is not an immediate child of Result Scene Object. Try using a game object with no children as the Result Scene Object..");
						}
						transform = componentsInChildren[0].transform;
					}
				}
			}
			if (transform != null && transform.parent != root.transform)
			{
				transform = null;
			}
			GameObject gameObject;
			if (transform == null)
			{
				gameObject = new GameObject(mom.name + "-mesh");
				gameObject.transform.parent = root.transform;
				transform = gameObject.transform;
			}
			transform.parent = root.transform;
			gameObject = transform.gameObject;
			if (mom.renderType == MB_RenderType.skinnedMeshRenderer)
			{
				MeshRenderer component = gameObject.GetComponent<MeshRenderer>();
				if (component != null)
				{
					MB_Utility.Destroy(component);
				}
				MeshFilter component2 = gameObject.GetComponent<MeshFilter>();
				if (component2 != null)
				{
					MB_Utility.Destroy(component2);
				}
				skinnedMeshRenderer = gameObject.GetComponent<SkinnedMeshRenderer>();
				if (skinnedMeshRenderer == null)
				{
					skinnedMeshRenderer = gameObject.AddComponent<SkinnedMeshRenderer>();
				}
			}
			else
			{
				SkinnedMeshRenderer component3 = gameObject.GetComponent<SkinnedMeshRenderer>();
				if (component3 != null)
				{
					MB_Utility.Destroy(component3);
				}
				meshFilter = gameObject.GetComponent<MeshFilter>();
				if (meshFilter == null)
				{
					meshFilter = gameObject.AddComponent<MeshFilter>();
				}
				meshRenderer = gameObject.GetComponent<MeshRenderer>();
				if (meshRenderer == null)
				{
					meshRenderer = gameObject.AddComponent<MeshRenderer>();
				}
			}
			if (mom.renderType == MB_RenderType.skinnedMeshRenderer)
			{
				skinnedMeshRenderer.bones = mom.GetBones();
				bool updateWhenOffscreen = skinnedMeshRenderer.updateWhenOffscreen;
				skinnedMeshRenderer.updateWhenOffscreen = true;
				skinnedMeshRenderer.updateWhenOffscreen = updateWhenOffscreen;
			}
			_ConfigureSceneHierarch(mom, root, meshRenderer, meshFilter, skinnedMeshRenderer, m, objsToBeAdded);
			if (mom.renderType == MB_RenderType.skinnedMeshRenderer)
			{
				return skinnedMeshRenderer;
			}
			return meshRenderer;
		}

		public static void BuildPrefabHierarchy(MB3_MeshCombinerSingle mom, GameObject instantiatedPrefabRoot, Mesh m, bool createNewChild = false, GameObject[] objsToBeAdded = null)
		{
			SkinnedMeshRenderer skinnedMeshRenderer = null;
			MeshRenderer meshRenderer = null;
			MeshFilter meshFilter = null;
			GameObject gameObject = new GameObject(mom.name + "-mesh");
			gameObject.transform.parent = instantiatedPrefabRoot.transform;
			Transform transform = gameObject.transform;
			transform.parent = instantiatedPrefabRoot.transform;
			gameObject = transform.gameObject;
			if (mom.renderType == MB_RenderType.skinnedMeshRenderer)
			{
				MeshRenderer component = gameObject.GetComponent<MeshRenderer>();
				if (component != null)
				{
					MB_Utility.Destroy(component);
				}
				MeshFilter component2 = gameObject.GetComponent<MeshFilter>();
				if (component2 != null)
				{
					MB_Utility.Destroy(component2);
				}
				skinnedMeshRenderer = gameObject.GetComponent<SkinnedMeshRenderer>();
				if (skinnedMeshRenderer == null)
				{
					skinnedMeshRenderer = gameObject.AddComponent<SkinnedMeshRenderer>();
				}
			}
			else
			{
				SkinnedMeshRenderer component3 = gameObject.GetComponent<SkinnedMeshRenderer>();
				if (component3 != null)
				{
					MB_Utility.Destroy(component3);
				}
				meshFilter = gameObject.GetComponent<MeshFilter>();
				if (meshFilter == null)
				{
					meshFilter = gameObject.AddComponent<MeshFilter>();
				}
				meshRenderer = gameObject.GetComponent<MeshRenderer>();
				if (meshRenderer == null)
				{
					meshRenderer = gameObject.AddComponent<MeshRenderer>();
				}
			}
			if (mom.renderType == MB_RenderType.skinnedMeshRenderer)
			{
				skinnedMeshRenderer.bones = mom.GetBones();
				bool updateWhenOffscreen = skinnedMeshRenderer.updateWhenOffscreen;
				skinnedMeshRenderer.updateWhenOffscreen = true;
				skinnedMeshRenderer.updateWhenOffscreen = updateWhenOffscreen;
				skinnedMeshRenderer.sharedMesh = m;
			}
			_ConfigureSceneHierarch(mom, instantiatedPrefabRoot, meshRenderer, meshFilter, skinnedMeshRenderer, m, objsToBeAdded);
			if (mom.targetRenderer != null)
			{
				Material[] array = new Material[mom.targetRenderer.sharedMaterials.Length];
				for (int i = 0; i < array.Length; i++)
				{
					array[i] = mom.targetRenderer.sharedMaterials[i];
				}
				if (mom.renderType == MB_RenderType.skinnedMeshRenderer)
				{
					skinnedMeshRenderer.sharedMaterial = null;
					skinnedMeshRenderer.sharedMaterials = array;
				}
				else
				{
					meshRenderer.sharedMaterial = null;
					meshRenderer.sharedMaterials = array;
				}
			}
		}

		private static void _ConfigureSceneHierarch(MB3_MeshCombinerSingle mom, GameObject root, MeshRenderer mr, MeshFilter mf, SkinnedMeshRenderer smr, Mesh m, GameObject[] objsToBeAdded = null)
		{
			GameObject gameObject;
			if (mom.renderType == MB_RenderType.skinnedMeshRenderer)
			{
				gameObject = smr.gameObject;
				smr.lightmapIndex = mom.GetLightmapIndex();
			}
			else
			{
				gameObject = mr.gameObject;
				mf.sharedMesh = m;
				mr.lightmapIndex = mom.GetLightmapIndex();
			}
			if (mom.lightmapOption == MB2_LightmapOptions.preserve_current_lightmapping || mom.lightmapOption == MB2_LightmapOptions.generate_new_UV2_layout)
			{
				gameObject.isStatic = true;
			}
			if (objsToBeAdded == null || objsToBeAdded.Length == 0 || !(objsToBeAdded[0] != null))
			{
				return;
			}
			bool flag = true;
			bool flag2 = true;
			string tag = objsToBeAdded[0].tag;
			int layer = objsToBeAdded[0].layer;
			for (int i = 0; i < objsToBeAdded.Length; i++)
			{
				if (objsToBeAdded[i] != null)
				{
					if (!objsToBeAdded[i].tag.Equals(tag))
					{
						flag = false;
					}
					if (objsToBeAdded[i].layer != layer)
					{
						flag2 = false;
					}
				}
			}
			if (flag)
			{
				root.tag = tag;
				gameObject.tag = tag;
			}
			if (flag2)
			{
				root.layer = layer;
				gameObject.layer = layer;
			}
		}

		public void BuildSceneMeshObject(GameObject[] gos = null, bool createNewChild = false)
		{
			if (_resultSceneObject == null)
			{
				_resultSceneObject = new GameObject("CombinedMesh-" + base.name);
			}
			_targetRenderer = BuildSceneHierarchPreBake(this, _resultSceneObject, GetMesh(), createNewChild, gos);
		}

		private bool IsMirrored(Matrix4x4 tm)
		{
			Vector3 lhs = tm.GetRow(0);
			Vector3 rhs = tm.GetRow(1);
			Vector3 rhs2 = tm.GetRow(2);
			lhs.Normalize();
			rhs.Normalize();
			rhs2.Normalize();
			if (!(Vector3.Dot(Vector3.Cross(lhs, rhs), rhs2) >= 0f))
			{
				return true;
			}
			return false;
		}

		public override void CheckIntegrity()
		{
			if (!MB_Utility.DO_INTEGRITY_CHECKS)
			{
				return;
			}
			if (renderType == MB_RenderType.skinnedMeshRenderer)
			{
				for (int i = 0; i < mbDynamicObjectsInCombinedMesh.Count; i++)
				{
					MB_DynamicGameObject mB_DynamicGameObject = mbDynamicObjectsInCombinedMesh[i];
					HashSet<int> hashSet = new HashSet<int>();
					HashSet<int> hashSet2 = new HashSet<int>();
					for (int j = mB_DynamicGameObject.vertIdx; j < mB_DynamicGameObject.vertIdx + mB_DynamicGameObject.numVerts; j++)
					{
						hashSet.Add(boneWeights[j].boneIndex0);
						hashSet.Add(boneWeights[j].boneIndex1);
						hashSet.Add(boneWeights[j].boneIndex2);
						hashSet.Add(boneWeights[j].boneIndex3);
					}
					for (int k = 0; k < mB_DynamicGameObject.indexesOfBonesUsed.Length; k++)
					{
						hashSet2.Add(mB_DynamicGameObject.indexesOfBonesUsed[k]);
					}
					hashSet2.ExceptWith(hashSet);
					if (hashSet2.Count > 0)
					{
						UnityEngine.Debug.LogError("The bone indexes were not the same. " + hashSet.Count + " " + hashSet2.Count);
					}
					for (int l = 0; l < mB_DynamicGameObject.indexesOfBonesUsed.Length; l++)
					{
						if (l < 0 || l > bones.Length)
						{
							UnityEngine.Debug.LogError("Bone index was out of bounds.");
						}
					}
					if (renderType == MB_RenderType.skinnedMeshRenderer && mB_DynamicGameObject.indexesOfBonesUsed.Length < 1)
					{
						UnityEngine.Debug.Log("DGO had no bones");
					}
				}
			}
			if (doBlendShapes && renderType != MB_RenderType.skinnedMeshRenderer)
			{
				UnityEngine.Debug.LogError("Blend shapes can only be used with skinned meshes.");
			}
		}

		private void _ZeroArray(Vector3[] arr, int idx, int length)
		{
			int num = idx + length;
			for (int i = idx; i < num; i++)
			{
				arr[i] = Vector3.zero;
			}
		}

		private List<MB_DynamicGameObject>[] _buildBoneIdx2dgoMap()
		{
			List<MB_DynamicGameObject>[] array = new List<MB_DynamicGameObject>[bones.Length];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = new List<MB_DynamicGameObject>();
			}
			for (int j = 0; j < mbDynamicObjectsInCombinedMesh.Count; j++)
			{
				MB_DynamicGameObject mB_DynamicGameObject = mbDynamicObjectsInCombinedMesh[j];
				for (int k = 0; k < mB_DynamicGameObject.indexesOfBonesUsed.Length; k++)
				{
					array[mB_DynamicGameObject.indexesOfBonesUsed[k]].Add(mB_DynamicGameObject);
				}
			}
			return array;
		}

		private void _CollectBonesToAddForDGO(MB_DynamicGameObject dgo, Dictionary<Transform, int> bone2idx, HashSet<int> boneIdxsToDelete, HashSet<BoneAndBindpose> bonesToAdd, Renderer r, MeshChannelsCache meshChannelCache)
		{
			Matrix4x4[] array = (dgo._tmpCachedBindposes = meshChannelCache.GetBindposes(r));
			BoneWeight[] array2 = (dgo._tmpCachedBoneWeights = meshChannelCache.GetBoneWeights(r, dgo.numVerts));
			Transform[] array3 = (dgo._tmpCachedBones = _getBones(r));
			HashSet<int> hashSet = new HashSet<int>();
			for (int i = 0; i < array2.Length; i++)
			{
				hashSet.Add(array2[i].boneIndex0);
				hashSet.Add(array2[i].boneIndex1);
				hashSet.Add(array2[i].boneIndex2);
				hashSet.Add(array2[i].boneIndex3);
			}
			int[] array4 = new int[hashSet.Count];
			hashSet.CopyTo(array4);
			for (int j = 0; j < array4.Length; j++)
			{
				bool flag = false;
				int num = array4[j];
				if (bone2idx.TryGetValue(array3[num], out var value) && array3[num] == bones[value] && !boneIdxsToDelete.Contains(value) && array[num] == bindPoses[value])
				{
					flag = true;
				}
				if (!flag)
				{
					BoneAndBindpose item = new BoneAndBindpose(array3[num], array[num]);
					if (!bonesToAdd.Contains(item))
					{
						bonesToAdd.Add(item);
					}
				}
			}
			dgo._tmpIndexesOfSourceBonesUsed = array4;
		}

		private void _CopyBonesWeAreKeepingToNewBonesArrayAndAdjustBWIndexes(HashSet<int> boneIdxsToDeleteHS, HashSet<BoneAndBindpose> bonesToAdd, Transform[] nbones, Matrix4x4[] nbindPoses, BoneWeight[] nboneWeights, int totalDeleteVerts)
		{
			if (boneIdxsToDeleteHS.Count > 0)
			{
				int[] array = new int[boneIdxsToDeleteHS.Count];
				boneIdxsToDeleteHS.CopyTo(array);
				Array.Sort(array);
				int[] array2 = new int[bones.Length];
				int num = 0;
				int num2 = 0;
				for (int i = 0; i < bones.Length; i++)
				{
					if (num2 < array.Length && array[num2] == i)
					{
						num2++;
						array2[i] = -1;
						continue;
					}
					array2[i] = num;
					nbones[num] = bones[i];
					nbindPoses[num] = bindPoses[i];
					num++;
				}
				int num3 = boneWeights.Length - totalDeleteVerts;
				for (int j = 0; j < num3; j++)
				{
					nboneWeights[j].boneIndex0 = array2[nboneWeights[j].boneIndex0];
					nboneWeights[j].boneIndex1 = array2[nboneWeights[j].boneIndex1];
					nboneWeights[j].boneIndex2 = array2[nboneWeights[j].boneIndex2];
					nboneWeights[j].boneIndex3 = array2[nboneWeights[j].boneIndex3];
				}
				for (int k = 0; k < mbDynamicObjectsInCombinedMesh.Count; k++)
				{
					MB_DynamicGameObject mB_DynamicGameObject = mbDynamicObjectsInCombinedMesh[k];
					for (int l = 0; l < mB_DynamicGameObject.indexesOfBonesUsed.Length; l++)
					{
						mB_DynamicGameObject.indexesOfBonesUsed[l] = array2[mB_DynamicGameObject.indexesOfBonesUsed[l]];
					}
				}
			}
			else
			{
				Array.Copy(bones, nbones, bones.Length);
				Array.Copy(bindPoses, nbindPoses, bindPoses.Length);
			}
		}

		private void _AddBonesToNewBonesArrayAndAdjustBWIndexes(MB_DynamicGameObject dgo, Renderer r, int vertsIdx, Transform[] nbones, BoneWeight[] nboneWeights, MeshChannelsCache meshChannelCache)
		{
			Transform[] tmpCachedBones = dgo._tmpCachedBones;
			Matrix4x4[] tmpCachedBindposes = dgo._tmpCachedBindposes;
			BoneWeight[] tmpCachedBoneWeights = dgo._tmpCachedBoneWeights;
			int[] array = new int[tmpCachedBones.Length];
			for (int i = 0; i < dgo._tmpIndexesOfSourceBonesUsed.Length; i++)
			{
				int num = dgo._tmpIndexesOfSourceBonesUsed[i];
				for (int j = 0; j < nbones.Length; j++)
				{
					if (tmpCachedBones[num] == nbones[j] && tmpCachedBindposes[num] == bindPoses[j])
					{
						array[num] = j;
						break;
					}
				}
			}
			for (int k = 0; k < tmpCachedBoneWeights.Length; k++)
			{
				int num2 = vertsIdx + k;
				nboneWeights[num2].boneIndex0 = array[tmpCachedBoneWeights[k].boneIndex0];
				nboneWeights[num2].boneIndex1 = array[tmpCachedBoneWeights[k].boneIndex1];
				nboneWeights[num2].boneIndex2 = array[tmpCachedBoneWeights[k].boneIndex2];
				nboneWeights[num2].boneIndex3 = array[tmpCachedBoneWeights[k].boneIndex3];
				nboneWeights[num2].weight0 = tmpCachedBoneWeights[k].weight0;
				nboneWeights[num2].weight1 = tmpCachedBoneWeights[k].weight1;
				nboneWeights[num2].weight2 = tmpCachedBoneWeights[k].weight2;
				nboneWeights[num2].weight3 = tmpCachedBoneWeights[k].weight3;
			}
			for (int l = 0; l < dgo._tmpIndexesOfSourceBonesUsed.Length; l++)
			{
				dgo._tmpIndexesOfSourceBonesUsed[l] = array[dgo._tmpIndexesOfSourceBonesUsed[l]];
			}
			dgo.indexesOfBonesUsed = dgo._tmpIndexesOfSourceBonesUsed;
			dgo._tmpIndexesOfSourceBonesUsed = null;
			dgo._tmpCachedBones = null;
			dgo._tmpCachedBindposes = null;
			dgo._tmpCachedBoneWeights = null;
		}

		private void _copyUV2unchangedToSeparateRects()
		{
			int padding = 16;
			List<Vector2> list = new List<Vector2>();
			float num = 1E+11f;
			float num2 = 0f;
			for (int i = 0; i < mbDynamicObjectsInCombinedMesh.Count; i++)
			{
				float magnitude = mbDynamicObjectsInCombinedMesh[i].meshSize.magnitude;
				if (magnitude > num2)
				{
					num2 = magnitude;
				}
				if (magnitude < num)
				{
					num = magnitude;
				}
			}
			float num3 = 1000f;
			float num4 = 10f;
			float num5 = 0f;
			float num6 = 1f;
			if (num2 - num > num3 - num4)
			{
				num6 = (num3 - num4) / (num2 - num);
				num5 = num4 - num * num6;
			}
			else
			{
				num6 = num3 / num2;
			}
			for (int j = 0; j < mbDynamicObjectsInCombinedMesh.Count; j++)
			{
				float magnitude2 = mbDynamicObjectsInCombinedMesh[j].meshSize.magnitude;
				magnitude2 = magnitude2 * num6 + num5;
				Vector2 item = Vector2.one * magnitude2;
				list.Add(item);
			}
			AtlasPackingResult[] rects = new MB2_TexturePackerRegular
			{
				atlasMustBePowerOfTwo = false
			}.GetRects(list, 8192, 8192, padding);
			for (int k = 0; k < mbDynamicObjectsInCombinedMesh.Count; k++)
			{
				MB_DynamicGameObject mB_DynamicGameObject = mbDynamicObjectsInCombinedMesh[k];
				float x;
				float num7 = (x = uv2s[mB_DynamicGameObject.vertIdx].x);
				float y;
				float num8 = (y = uv2s[mB_DynamicGameObject.vertIdx].y);
				int num9 = mB_DynamicGameObject.vertIdx + mB_DynamicGameObject.numVerts;
				for (int l = mB_DynamicGameObject.vertIdx; l < num9; l++)
				{
					if (uv2s[l].x < num7)
					{
						num7 = uv2s[l].x;
					}
					if (uv2s[l].x > x)
					{
						x = uv2s[l].x;
					}
					if (uv2s[l].y < num8)
					{
						num8 = uv2s[l].y;
					}
					if (uv2s[l].y > y)
					{
						y = uv2s[l].y;
					}
				}
				Rect rect = rects[0].rects[k];
				for (int m = mB_DynamicGameObject.vertIdx; m < num9; m++)
				{
					float num10 = x - num7;
					float num11 = y - num8;
					if (num10 == 0f)
					{
						num10 = 1f;
					}
					if (num11 == 0f)
					{
						num11 = 1f;
					}
					uv2s[m].x = (uv2s[m].x - num7) / num10 * rect.width + rect.x;
					uv2s[m].y = (uv2s[m].y - num8) / num11 * rect.height + rect.y;
				}
			}
		}

		public override List<Material> GetMaterialsOnTargetRenderer()
		{
			List<Material> list = new List<Material>();
			if (_targetRenderer != null)
			{
				list.AddRange(_targetRenderer.sharedMaterials);
			}
			return list;
		}
	}
	[Serializable]
	public class MB3_MultiMeshCombiner : MB3_MeshCombiner
	{
		[Serializable]
		public class CombinedMesh
		{
			public MB3_MeshCombinerSingle combinedMesh;

			public int extraSpace = -1;

			public int numVertsInListToDelete;

			public int numVertsInListToAdd;

			public List<GameObject> gosToAdd;

			public List<int> gosToDelete;

			public List<GameObject> gosToUpdate;

			public bool isDirty;

			public CombinedMesh(int maxNumVertsInMesh, GameObject resultSceneObject, MB2_LogLevel ll)
			{
				combinedMesh = new MB3_MeshCombinerSingle();
				combinedMesh.resultSceneObject = resultSceneObject;
				combinedMesh.LOG_LEVEL = ll;
				extraSpace = maxNumVertsInMesh;
				numVertsInListToDelete = 0;
				numVertsInListToAdd = 0;
				gosToAdd = new List<GameObject>();
				gosToDelete = new List<int>();
				gosToUpdate = new List<GameObject>();
			}

			public bool isEmpty()
			{
				List<GameObject> list = new List<GameObject>();
				list.AddRange(combinedMesh.GetObjectsInCombined());
				for (int i = 0; i < gosToDelete.Count; i++)
				{
					for (int j = 0; j < list.Count; j++)
					{
						if (list[j].GetInstanceID() == gosToDelete[i])
						{
							list.RemoveAt(j);
							break;
						}
					}
				}
				if (list.Count == 0)
				{
					return true;
				}
				return false;
			}
		}

		private static GameObject[] empty = new GameObject[0];

		private static int[] emptyIDs = new int[0];

		public Dictionary<int, CombinedMesh> obj2MeshCombinerMap = new Dictionary<int, CombinedMesh>();

		[SerializeField]
		public List<CombinedMesh> meshCombiners = new List<CombinedMesh>();

		[SerializeField]
		private int _maxVertsInMesh = 65535;

		public override MB2_LogLevel LOG_LEVEL
		{
			get
			{
				return _LOG_LEVEL;
			}
			set
			{
				_LOG_LEVEL = value;
				for (int i = 0; i < meshCombiners.Count; i++)
				{
					meshCombiners[i].combinedMesh.LOG_LEVEL = value;
				}
			}
		}

		public override MB2_ValidationLevel validationLevel
		{
			get
			{
				return _validationLevel;
			}
			set
			{
				_validationLevel = value;
				for (int i = 0; i < meshCombiners.Count; i++)
				{
					meshCombiners[i].combinedMesh.validationLevel = _validationLevel;
				}
			}
		}

		public int maxVertsInMesh
		{
			get
			{
				return _maxVertsInMesh;
			}
			set
			{
				if (obj2MeshCombinerMap.Count <= 0)
				{
					if (value < 3)
					{
						UnityEngine.Debug.LogError("Max verts in mesh must be greater than three.");
					}
					else if (value > MBVersion.MaxMeshVertexCount())
					{
						UnityEngine.Debug.LogError("Meshes in unity cannot have more than " + MBVersion.MaxMeshVertexCount() + " vertices.");
					}
					else
					{
						_maxVertsInMesh = value;
					}
				}
			}
		}

		public override int GetNumObjectsInCombined()
		{
			return obj2MeshCombinerMap.Count;
		}

		public override int GetNumVerticesFor(GameObject go)
		{
			CombinedMesh value = null;
			if (obj2MeshCombinerMap.TryGetValue(go.GetInstanceID(), out value))
			{
				return value.combinedMesh.GetNumVerticesFor(go);
			}
			return -1;
		}

		public override int GetNumVerticesFor(int gameObjectID)
		{
			CombinedMesh value = null;
			if (obj2MeshCombinerMap.TryGetValue(gameObjectID, out value))
			{
				return value.combinedMesh.GetNumVerticesFor(gameObjectID);
			}
			return -1;
		}

		public override List<GameObject> GetObjectsInCombined()
		{
			List<GameObject> list = new List<GameObject>();
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				list.AddRange(meshCombiners[i].combinedMesh.GetObjectsInCombined());
			}
			return list;
		}

		public override int GetLightmapIndex()
		{
			if (meshCombiners.Count > 0)
			{
				return meshCombiners[0].combinedMesh.GetLightmapIndex();
			}
			return -1;
		}

		public override bool CombinedMeshContains(GameObject go)
		{
			return obj2MeshCombinerMap.ContainsKey(go.GetInstanceID());
		}

		private bool _validateTextureBakeResults()
		{
			if (_textureBakeResults == null)
			{
				UnityEngine.Debug.LogError("Texture Bake Results is null. Can't combine meshes.");
				return false;
			}
			if (_textureBakeResults.materialsAndUVRects == null || _textureBakeResults.materialsAndUVRects.Length == 0)
			{
				UnityEngine.Debug.LogError("Texture Bake Results has no materials in material to sourceUVRect map. Try baking materials. Can't combine meshes.");
				return false;
			}
			if (_textureBakeResults.resultMaterials == null || _textureBakeResults.resultMaterials.Length == 0)
			{
				UnityEngine.Debug.LogError("Texture Bake Results has no result materials. Try baking materials. Can't combine meshes.");
				return false;
			}
			return true;
		}

		public override void Apply(GenerateUV2Delegate uv2GenerationMethod)
		{
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				if (meshCombiners[i].isDirty)
				{
					meshCombiners[i].combinedMesh.Apply(uv2GenerationMethod);
					meshCombiners[i].isDirty = false;
				}
			}
		}

		public override void Apply(bool triangles, bool vertices, bool normals, bool tangents, bool uvs, bool uv2, bool uv3, bool uv4, bool colors, bool bones = false, bool blendShapesFlag = false, GenerateUV2Delegate uv2GenerationMethod = null)
		{
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				if (meshCombiners[i].isDirty)
				{
					meshCombiners[i].combinedMesh.Apply(triangles, vertices, normals, tangents, uvs, uv2, uv3, uv4, colors, bones, blendShapesFlag, uv2GenerationMethod);
					meshCombiners[i].isDirty = false;
				}
			}
		}

		public override void UpdateSkinnedMeshApproximateBounds()
		{
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				meshCombiners[i].combinedMesh.UpdateSkinnedMeshApproximateBounds();
			}
		}

		public override void UpdateSkinnedMeshApproximateBoundsFromBones()
		{
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				meshCombiners[i].combinedMesh.UpdateSkinnedMeshApproximateBoundsFromBones();
			}
		}

		public override void UpdateSkinnedMeshApproximateBoundsFromBounds()
		{
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				meshCombiners[i].combinedMesh.UpdateSkinnedMeshApproximateBoundsFromBounds();
			}
		}

		public override void UpdateGameObjects(GameObject[] gos, bool recalcBounds = true, bool updateVertices = true, bool updateNormals = true, bool updateTangents = true, bool updateUV = false, bool updateUV2 = false, bool updateUV3 = false, bool updateUV4 = false, bool updateColors = false, bool updateSkinningInfo = false)
		{
			if (gos == null)
			{
				UnityEngine.Debug.LogError("list of game objects cannot be null");
				return;
			}
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				meshCombiners[i].gosToUpdate.Clear();
			}
			for (int j = 0; j < gos.Length; j++)
			{
				CombinedMesh value = null;
				obj2MeshCombinerMap.TryGetValue(gos[j].GetInstanceID(), out value);
				if (value != null)
				{
					value.gosToUpdate.Add(gos[j]);
				}
				else
				{
					UnityEngine.Debug.LogWarning(string.Concat("Object ", gos[j], " is not in the combined mesh."));
				}
			}
			for (int k = 0; k < meshCombiners.Count; k++)
			{
				if (meshCombiners[k].gosToUpdate.Count > 0)
				{
					meshCombiners[k].isDirty = true;
					GameObject[] gos2 = meshCombiners[k].gosToUpdate.ToArray();
					meshCombiners[k].combinedMesh.UpdateGameObjects(gos2, recalcBounds, updateVertices, updateNormals, updateTangents, updateUV, updateUV2, updateUV3, updateUV4, updateColors, updateSkinningInfo);
				}
			}
		}

		public override bool AddDeleteGameObjects(GameObject[] gos, GameObject[] deleteGOs, bool disableRendererInSource = true)
		{
			int[] array = null;
			if (deleteGOs != null)
			{
				array = new int[deleteGOs.Length];
				for (int i = 0; i < deleteGOs.Length; i++)
				{
					if (deleteGOs[i] == null)
					{
						UnityEngine.Debug.LogError("The " + i + "th object on the list of objects to delete is 'Null'");
					}
					else
					{
						array[i] = deleteGOs[i].GetInstanceID();
					}
				}
			}
			return AddDeleteGameObjectsByID(gos, array, disableRendererInSource);
		}

		public override bool AddDeleteGameObjectsByID(GameObject[] gos, int[] deleteGOinstanceIDs, bool disableRendererInSource = true)
		{
			if (_usingTemporaryTextureBakeResult && gos != null && gos.Length != 0)
			{
				MB_Utility.Destroy(_textureBakeResults);
				_textureBakeResults = null;
				_usingTemporaryTextureBakeResult = false;
			}
			if (_textureBakeResults == null && gos != null && gos.Length != 0 && gos[0] != null && !_CreateTemporaryTextrueBakeResult(gos, GetMaterialsOnTargetRenderer()))
			{
				return false;
			}
			if (!_validate(gos, deleteGOinstanceIDs))
			{
				return false;
			}
			_distributeAmongBakers(gos, deleteGOinstanceIDs);
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				MB2_Log.LogDebug(string.Concat("MB2_MultiMeshCombiner.AddDeleteGameObjects numCombinedMeshes: ", meshCombiners.Count, " added:", gos, " deleted:", deleteGOinstanceIDs, " disableRendererInSource:", disableRendererInSource.ToString(), " maxVertsPerCombined:", _maxVertsInMesh));
			}
			return _bakeStep1(gos, deleteGOinstanceIDs, disableRendererInSource);
		}

		private bool _validate(GameObject[] gos, int[] deleteGOinstanceIDs)
		{
			if (_validationLevel == MB2_ValidationLevel.none)
			{
				return true;
			}
			if (_maxVertsInMesh < 3)
			{
				UnityEngine.Debug.LogError("Invalid value for maxVertsInMesh=" + _maxVertsInMesh);
			}
			_validateTextureBakeResults();
			if (gos != null)
			{
				for (int i = 0; i < gos.Length; i++)
				{
					if (gos[i] == null)
					{
						UnityEngine.Debug.LogError("The " + i + "th object on the list of objects to combine is 'None'. Use Command-Delete on Mac OS X; Delete or Shift-Delete on Windows to remove this one element.");
						return false;
					}
					if (_validationLevel < MB2_ValidationLevel.robust)
					{
						continue;
					}
					for (int j = i + 1; j < gos.Length; j++)
					{
						if (gos[i] == gos[j])
						{
							UnityEngine.Debug.LogError(string.Concat("GameObject ", gos[i], "appears twice in list of game objects to add"));
							return false;
						}
					}
					if (!obj2MeshCombinerMap.ContainsKey(gos[i].GetInstanceID()))
					{
						continue;
					}
					bool flag = false;
					if (deleteGOinstanceIDs != null)
					{
						for (int k = 0; k < deleteGOinstanceIDs.Length; k++)
						{
							if (deleteGOinstanceIDs[k] == gos[i].GetInstanceID())
							{
								flag = true;
							}
						}
					}
					if (!flag)
					{
						UnityEngine.Debug.LogError(string.Concat("GameObject ", gos[i], " is already in the combined mesh ", gos[i].GetInstanceID()));
						return false;
					}
				}
			}
			if (deleteGOinstanceIDs != null && _validationLevel >= MB2_ValidationLevel.robust)
			{
				for (int l = 0; l < deleteGOinstanceIDs.Length; l++)
				{
					for (int m = l + 1; m < deleteGOinstanceIDs.Length; m++)
					{
						if (deleteGOinstanceIDs[l] == deleteGOinstanceIDs[m])
						{
							UnityEngine.Debug.LogError("GameObject " + deleteGOinstanceIDs[l] + "appears twice in list of game objects to delete");
							return false;
						}
					}
					if (!obj2MeshCombinerMap.ContainsKey(deleteGOinstanceIDs[l]))
					{
						UnityEngine.Debug.LogWarning("GameObject with instance ID " + deleteGOinstanceIDs[l] + " on the list of objects to delete is not in the combined mesh.");
					}
				}
			}
			return true;
		}

		private void _distributeAmongBakers(GameObject[] gos, int[] deleteGOinstanceIDs)
		{
			if (gos == null)
			{
				gos = empty;
			}
			if (deleteGOinstanceIDs == null)
			{
				deleteGOinstanceIDs = emptyIDs;
			}
			if (resultSceneObject == null)
			{
				resultSceneObject = new GameObject("CombinedMesh-" + base.name);
			}
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				meshCombiners[i].extraSpace = _maxVertsInMesh - meshCombiners[i].combinedMesh.GetMesh().vertexCount;
			}
			for (int j = 0; j < deleteGOinstanceIDs.Length; j++)
			{
				CombinedMesh value = null;
				if (obj2MeshCombinerMap.TryGetValue(deleteGOinstanceIDs[j], out value))
				{
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug("MB2_MultiMeshCombiner.Removing " + deleteGOinstanceIDs[j] + " from meshCombiner " + meshCombiners.IndexOf(value));
					}
					value.numVertsInListToDelete += value.combinedMesh.GetNumVerticesFor(deleteGOinstanceIDs[j]);
					value.gosToDelete.Add(deleteGOinstanceIDs[j]);
				}
				else
				{
					UnityEngine.Debug.LogWarning("Object " + deleteGOinstanceIDs[j] + " in the list of objects to delete is not in the combined mesh.");
				}
			}
			for (int k = 0; k < gos.Length; k++)
			{
				GameObject gameObject = gos[k];
				int vertexCount = MB_Utility.GetMesh(gameObject).vertexCount;
				CombinedMesh combinedMesh = null;
				for (int l = 0; l < meshCombiners.Count; l++)
				{
					if (meshCombiners[l].extraSpace + meshCombiners[l].numVertsInListToDelete - meshCombiners[l].numVertsInListToAdd > vertexCount)
					{
						combinedMesh = meshCombiners[l];
						if (LOG_LEVEL >= MB2_LogLevel.debug)
						{
							MB2_Log.LogDebug(string.Concat("MB2_MultiMeshCombiner.Added ", gos[k], " to combinedMesh ", l), LOG_LEVEL);
						}
						break;
					}
				}
				if (combinedMesh == null)
				{
					combinedMesh = new CombinedMesh(maxVertsInMesh, _resultSceneObject, _LOG_LEVEL);
					_setMBValues(combinedMesh.combinedMesh);
					meshCombiners.Add(combinedMesh);
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug("MB2_MultiMeshCombiner.Created new combinedMesh");
					}
				}
				combinedMesh.gosToAdd.Add(gameObject);
				combinedMesh.numVertsInListToAdd += vertexCount;
			}
		}

		private bool _bakeStep1(GameObject[] gos, int[] deleteGOinstanceIDs, bool disableRendererInSource)
		{
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				CombinedMesh combinedMesh = meshCombiners[i];
				if (combinedMesh.combinedMesh.targetRenderer == null)
				{
					combinedMesh.combinedMesh.resultSceneObject = _resultSceneObject;
					combinedMesh.combinedMesh.BuildSceneMeshObject(gos, createNewChild: true);
					if (_LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug("BuildSO combiner {0} goID {1} targetRenID {2} meshID {3}", i, combinedMesh.combinedMesh.targetRenderer.gameObject.GetInstanceID(), combinedMesh.combinedMesh.targetRenderer.GetInstanceID(), combinedMesh.combinedMesh.GetMesh().GetInstanceID());
					}
				}
				else if (combinedMesh.combinedMesh.targetRenderer.transform.parent != resultSceneObject.transform)
				{
					UnityEngine.Debug.LogError("targetRender objects must be children of resultSceneObject");
					return false;
				}
				if (combinedMesh.gosToAdd.Count > 0 || combinedMesh.gosToDelete.Count > 0)
				{
					combinedMesh.combinedMesh.AddDeleteGameObjectsByID(combinedMesh.gosToAdd.ToArray(), combinedMesh.gosToDelete.ToArray(), disableRendererInSource);
					if (_LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug("Baked combiner {0} obsAdded {1} objsRemoved {2} goID {3} targetRenID {4} meshID {5}", i, combinedMesh.gosToAdd.Count, combinedMesh.gosToDelete.Count, combinedMesh.combinedMesh.targetRenderer.gameObject.GetInstanceID(), combinedMesh.combinedMesh.targetRenderer.GetInstanceID(), combinedMesh.combinedMesh.GetMesh().GetInstanceID());
					}
				}
				Renderer renderer = combinedMesh.combinedMesh.targetRenderer;
				Mesh mesh = combinedMesh.combinedMesh.GetMesh();
				if (renderer is MeshRenderer)
				{
					renderer.gameObject.GetComponent<MeshFilter>().sharedMesh = mesh;
				}
				else
				{
					((SkinnedMeshRenderer)renderer).sharedMesh = mesh;
				}
			}
			for (int j = 0; j < meshCombiners.Count; j++)
			{
				CombinedMesh combinedMesh2 = meshCombiners[j];
				for (int k = 0; k < combinedMesh2.gosToDelete.Count; k++)
				{
					obj2MeshCombinerMap.Remove(combinedMesh2.gosToDelete[k]);
				}
			}
			for (int l = 0; l < meshCombiners.Count; l++)
			{
				CombinedMesh combinedMesh3 = meshCombiners[l];
				for (int m = 0; m < combinedMesh3.gosToAdd.Count; m++)
				{
					obj2MeshCombinerMap.Add(combinedMesh3.gosToAdd[m].GetInstanceID(), combinedMesh3);
				}
				if (combinedMesh3.gosToAdd.Count > 0 || combinedMesh3.gosToDelete.Count > 0)
				{
					combinedMesh3.gosToDelete.Clear();
					combinedMesh3.gosToAdd.Clear();
					combinedMesh3.numVertsInListToDelete = 0;
					combinedMesh3.numVertsInListToAdd = 0;
					combinedMesh3.isDirty = true;
				}
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				string text = "Meshes in combined:";
				for (int n = 0; n < meshCombiners.Count; n++)
				{
					text = text + " mesh" + n + "(" + meshCombiners[n].combinedMesh.GetObjectsInCombined().Count + ")\n";
				}
				text = text + "children in result: " + resultSceneObject.transform.childCount;
				MB2_Log.LogDebug(text, LOG_LEVEL);
			}
			if (meshCombiners.Count > 0)
			{
				return true;
			}
			return false;
		}

		public override Dictionary<MBBlendShapeKey, MBBlendShapeValue> BuildSourceBlendShapeToCombinedIndexMap()
		{
			Dictionary<MBBlendShapeKey, MBBlendShapeValue> dictionary = new Dictionary<MBBlendShapeKey, MBBlendShapeValue>();
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				for (int j = 0; j < meshCombiners[i].combinedMesh.blendShapes.Length; j++)
				{
					MB3_MeshCombinerSingle.MBBlendShape mBBlendShape = meshCombiners[i].combinedMesh.blendShapes[j];
					MBBlendShapeValue mBBlendShapeValue = new MBBlendShapeValue();
					mBBlendShapeValue.combinedMeshGameObject = meshCombiners[i].combinedMesh.targetRenderer.gameObject;
					mBBlendShapeValue.blendShapeIndex = j;
					dictionary.Add(new MBBlendShapeKey(mBBlendShape.gameObjectID, mBBlendShape.indexInSource), mBBlendShapeValue);
				}
			}
			return dictionary;
		}

		public override void ClearBuffers()
		{
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				meshCombiners[i].combinedMesh.ClearBuffers();
			}
			obj2MeshCombinerMap.Clear();
		}

		public override void ClearMesh()
		{
			DestroyMesh();
		}

		public override void DestroyMesh()
		{
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				if (meshCombiners[i].combinedMesh.targetRenderer != null)
				{
					MB_Utility.Destroy(meshCombiners[i].combinedMesh.targetRenderer.gameObject);
				}
				meshCombiners[i].combinedMesh.ClearMesh();
			}
			obj2MeshCombinerMap.Clear();
			meshCombiners.Clear();
		}

		public override void DestroyMeshEditor(MB2_EditorMethodsInterface editorMethods)
		{
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				if (meshCombiners[i].combinedMesh.targetRenderer != null)
				{
					editorMethods.Destroy(meshCombiners[i].combinedMesh.targetRenderer.gameObject);
				}
				meshCombiners[i].combinedMesh.ClearMesh();
			}
			obj2MeshCombinerMap.Clear();
			meshCombiners.Clear();
		}

		private void _setMBValues(MB3_MeshCombinerSingle targ)
		{
			targ.validationLevel = _validationLevel;
			targ.renderType = renderType;
			targ.outputOption = MB2_OutputOptions.bakeIntoSceneObject;
			targ.lightmapOption = lightmapOption;
			targ.textureBakeResults = textureBakeResults;
			targ.doNorm = doNorm;
			targ.doTan = doTan;
			targ.doCol = doCol;
			targ.doUV = doUV;
			targ.doUV3 = doUV3;
			targ.doUV4 = doUV4;
			targ.doBlendShapes = doBlendShapes;
			targ.optimizeAfterBake = base.optimizeAfterBake;
			targ.recenterVertsToBoundsCenter = recenterVertsToBoundsCenter;
			targ.uv2UnwrappingParamsHardAngle = uv2UnwrappingParamsHardAngle;
			targ.uv2UnwrappingParamsPackMargin = uv2UnwrappingParamsPackMargin;
		}

		public override List<Material> GetMaterialsOnTargetRenderer()
		{
			HashSet<Material> hashSet = new HashSet<Material>();
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				hashSet.UnionWith(meshCombiners[i].combinedMesh.GetMaterialsOnTargetRenderer());
			}
			return new List<Material>(hashSet);
		}

		public override void CheckIntegrity()
		{
			if (MB_Utility.DO_INTEGRITY_CHECKS)
			{
				for (int i = 0; i < meshCombiners.Count; i++)
				{
					meshCombiners[i].combinedMesh.CheckIntegrity();
				}
			}
		}
	}
	public class PriorityQueue<TPriority, TValue> : ICollection<KeyValuePair<TPriority, TValue>>, IEnumerable<KeyValuePair<TPriority, TValue>>, IEnumerable
	{
		public List<KeyValuePair<TPriority, TValue>> _baseHeap;

		private IComparer<TPriority> _comparer;

		public bool IsEmpty => _baseHeap.Count == 0;

		public int Count => _baseHeap.Count;

		public bool IsReadOnly => false;

		public PriorityQueue()
			: this((IComparer<TPriority>)Comparer<TPriority>.Default)
		{
		}

		public PriorityQueue(int capacity)
			: this(capacity, (IComparer<TPriority>)Comparer<TPriority>.Default)
		{
		}

		public PriorityQueue(int capacity, IComparer<TPriority> comparer)
		{
			if (comparer == null)
			{
				throw new ArgumentNullException();
			}
			_baseHeap = new List<KeyValuePair<TPriority, TValue>>(capacity);
			_comparer = comparer;
		}

		public PriorityQueue(IComparer<TPriority> comparer)
		{
			if (comparer == null)
			{
				throw new ArgumentNullException();
			}
			_baseHeap = new List<KeyValuePair<TPriority, TValue>>();
			_comparer = comparer;
		}

		public PriorityQueue(IEnumerable<KeyValuePair<TPriority, TValue>> data)
			: this(data, (IComparer<TPriority>)Comparer<TPriority>.Default)
		{
		}

		public PriorityQueue(IEnumerable<KeyValuePair<TPriority, TValue>> data, IComparer<TPriority> comparer)
		{
			if (data == null || comparer == null)
			{
				throw new ArgumentNullException();
			}
			_comparer = comparer;
			_baseHeap = new List<KeyValuePair<TPriority, TValue>>(data);
			for (int num = _baseHeap.Count / 2 - 1; num >= 0; num--)
			{
				HeapifyFromBeginningToEnd(num);
			}
		}

		public static PriorityQueue<TPriority, TValue> MergeQueues(PriorityQueue<TPriority, TValue> pq1, PriorityQueue<TPriority, TValue> pq2)
		{
			if (pq1 == null || pq2 == null)
			{
				throw new ArgumentNullException();
			}
			if (pq1._comparer != pq2._comparer)
			{
				throw new InvalidOperationException("Priority queues to be merged must have equal comparers");
			}
			return MergeQueues(pq1, pq2, pq1._comparer);
		}

		public static PriorityQueue<TPriority, TValue> MergeQueues(PriorityQueue<TPriority, TValue> pq1, PriorityQueue<TPriority, TValue> pq2, IComparer<TPriority> comparer)
		{
			if (pq1 == null || pq2 == null || comparer == null)
			{
				throw new ArgumentNullException();
			}
			PriorityQueue<TPriority, TValue> priorityQueue = new PriorityQueue<TPriority, TValue>(pq1.Count + pq2.Count, pq1._comparer);
			priorityQueue._baseHeap.AddRange(pq1._baseHeap);
			priorityQueue._baseHeap.AddRange(pq2._baseHeap);
			for (int num = priorityQueue._baseHeap.Count / 2 - 1; num >= 0; num--)
			{
				priorityQueue.HeapifyFromBeginningToEnd(num);
			}
			return priorityQueue;
		}

		public void Enqueue(TPriority priority, TValue value)
		{
			Insert(priority, value);
		}

		public KeyValuePair<TPriority, TValue> Dequeue()
		{
			if (!IsEmpty)
			{
				KeyValuePair<TPriority, TValue> result = _baseHeap[0];
				DeleteRoot();
				return result;
			}
			throw new InvalidOperationException("Priority queue is empty");
		}

		public TValue DequeueValue()
		{
			return Dequeue().Value;
		}

		public KeyValuePair<TPriority, TValue> Peek()
		{
			if (!IsEmpty)
			{
				return _baseHeap[0];
			}
			throw new InvalidOperationException("Priority queue is empty");
		}

		public TValue PeekValue()
		{
			return Peek().Value;
		}

		private void ExchangeElements(int pos1, int pos2)
		{
			KeyValuePair<TPriority, TValue> value = _baseHeap[pos1];
			_baseHeap[pos1] = _baseHeap[pos2];
			_baseHeap[pos2] = value;
		}

		private void Insert(TPriority priority, TValue value)
		{
			KeyValuePair<TPriority, TValue> item = new KeyValuePair<TPriority, TValue>(priority, value);
			_baseHeap.Add(item);
			HeapifyFromEndToBeginning(_baseHeap.Count - 1);
		}

		private int HeapifyFromEndToBeginning(int pos)
		{
			if (pos >= _baseHeap.Count)
			{
				return -1;
			}
			while (pos > 0)
			{
				int num = (pos - 1) / 2;
				if (_comparer.Compare(_baseHeap[num].Key, _baseHeap[pos].Key) <= 0)
				{
					break;
				}
				ExchangeElements(num, pos);
				pos = num;
			}
			return pos;
		}

		private void DeleteRoot()
		{
			if (_baseHeap.Count <= 1)
			{
				_baseHeap.Clear();
				return;
			}
			_baseHeap[0] = _baseHeap[_baseHeap.Count - 1];
			_baseHeap.RemoveAt(_baseHeap.Count - 1);
			HeapifyFromBeginningToEnd(0);
		}

		private void HeapifyFromBeginningToEnd(int pos)
		{
			if (pos >= _baseHeap.Count)
			{
				return;
			}
			while (true)
			{
				int num = pos;
				int num2 = 2 * pos + 1;
				int num3 = 2 * pos + 2;
				if (num2 < _baseHeap.Count && _comparer.Compare(_baseHeap[num].Key, _baseHeap[num2].Key) > 0)
				{
					num = num2;
				}
				if (num3 < _baseHeap.Count && _comparer.Compare(_baseHeap[num].Key, _baseHeap[num3].Key) > 0)
				{
					num = num3;
				}
				if (num != pos)
				{
					ExchangeElements(num, pos);
					pos = num;
					continue;
				}
				break;
			}
		}

		public void Add(KeyValuePair<TPriority, TValue> item)
		{
			Enqueue(item.Key, item.Value);
		}

		public void Clear()
		{
			_baseHeap.Clear();
		}

		public bool Contains(KeyValuePair<TPriority, TValue> item)
		{
			return _baseHeap.Contains(item);
		}

		public bool TryFindValue(TPriority item, out TValue foundVersion)
		{
			for (int i = 0; i < _baseHeap.Count; i++)
			{
				if (_comparer.Compare(item, _baseHeap[i].Key) == 0)
				{
					foundVersion = _baseHeap[i].Value;
					return true;
				}
			}
			foundVersion = default(TValue);
			return false;
		}

		public void CopyTo(KeyValuePair<TPriority, TValue>[] array, int arrayIndex)
		{
			_baseHeap.CopyTo(array, arrayIndex);
		}

		public bool Remove(KeyValuePair<TPriority, TValue> item)
		{
			int num = _baseHeap.IndexOf(item);
			if (num < 0)
			{
				return false;
			}
			_baseHeap[num] = _baseHeap[_baseHeap.Count - 1];
			_baseHeap.RemoveAt(_baseHeap.Count - 1);
			if (HeapifyFromEndToBeginning(num) == num)
			{
				HeapifyFromBeginningToEnd(num);
			}
			return true;
		}

		public IEnumerator<KeyValuePair<TPriority, TValue>> GetEnumerator()
		{
			return _baseHeap.GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}
	public struct DVector2
	{
		private static double epsilon = 1E-05;

		public double x;

		public double y;

		public static DVector2 Subtract(DVector2 a, DVector2 b)
		{
			return new DVector2(a.x - b.x, a.y - b.y);
		}

		public DVector2(double xx, double yy)
		{
			x = xx;
			y = yy;
		}

		public DVector2(DVector2 r)
		{
			x = r.x;
			y = r.y;
		}

		public Vector2 GetVector2()
		{
			return new Vector2((float)x, (float)y);
		}

		public bool IsContainedIn(DRect r)
		{
			if (x >= r.x && y >= r.y && x <= r.x + r.width && y <= r.y + r.height)
			{
				return true;
			}
			return false;
		}

		public bool IsContainedInWithMargin(DRect r)
		{
			if (x >= r.x - epsilon && y >= r.y - epsilon && x <= r.x + r.width + epsilon && y <= r.y + r.height + epsilon)
			{
				return true;
			}
			return false;
		}

		public override string ToString()
		{
			return $"({x},{y})";
		}

		public string ToString(string formatS)
		{
			return $"({x.ToString(formatS)},{y.ToString(formatS)})";
		}

		public static double Distance(DVector2 a, DVector2 b)
		{
			double num = b.x - a.x;
			double num2 = b.y - a.y;
			return Math.Sqrt(num * num + num2 * num2);
		}
	}
	public struct DRect
	{
		public double x;

		public double y;

		public double width;

		public double height;

		public DVector2 minD => new DVector2(x, y);

		public DVector2 maxD => new DVector2(x + width, y + height);

		public Vector2 min => new Vector2((float)x, (float)y);

		public Vector2 max => new Vector2((float)(x + width), (float)(y + height));

		public Vector2 size => new Vector2((float)width, (float)height);

		public DVector2 center => new DVector2(x + width / 2.0, y + height / 2.0);

		public DRect(Rect r)
		{
			x = r.x;
			y = r.y;
			width = r.width;
			height = r.height;
		}

		public DRect(Vector2 o, Vector2 s)
		{
			x = o.x;
			y = o.y;
			width = s.x;
			height = s.y;
		}

		public DRect(DRect r)
		{
			x = r.x;
			y = r.y;
			width = r.width;
			height = r.height;
		}

		public DRect(float xx, float yy, float w, float h)
		{
			x = xx;
			y = yy;
			width = w;
			height = h;
		}

		public DRect(double xx, double yy, double w, double h)
		{
			x = xx;
			y = yy;
			width = w;
			height = h;
		}

		public Rect GetRect()
		{
			return new Rect((float)x, (float)y, (float)width, (float)height);
		}

		public override bool Equals(object obj)
		{
			DRect dRect = (DRect)obj;
			if (dRect.x == x && dRect.y == y && dRect.width == width && dRect.height == height)
			{
				return true;
			}
			return false;
		}

		public static bool operator ==(DRect a, DRect b)
		{
			return a.Equals(b);
		}

		public static bool operator !=(DRect a, DRect b)
		{
			return !a.Equals(b);
		}

		public override string ToString()
		{
			return string.Format("(x={0},y={1},w={2},h={3})", x.ToString("F5"), y.ToString("F5"), width.ToString("F5"), height.ToString("F5"));
		}

		public void Expand(float amt)
		{
			x -= amt;
			y -= amt;
			width += amt * 2f;
			height += amt * 2f;
		}

		public bool Encloses(DRect smallToTestIfFits)
		{
			double num = smallToTestIfFits.x;
			double num2 = smallToTestIfFits.y;
			double num3 = smallToTestIfFits.x + smallToTestIfFits.width;
			double num4 = smallToTestIfFits.y + smallToTestIfFits.height;
			double num5 = x;
			double num6 = y;
			double num7 = x + width;
			double num8 = y + height;
			if (num5 <= num && num <= num7 && num5 <= num3 && num3 <= num7 && num6 <= num2 && num2 <= num8 && num6 <= num4)
			{
				return num4 <= num8;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return x.GetHashCode() ^ y.GetHashCode() ^ width.GetHashCode() ^ height.GetHashCode();
		}
	}
	public class MB3_UVTransformUtility
	{
		public static void Test()
		{
			DRect t = new DRect(0.5, 0.5, 2.0, 2.0);
			DRect t2 = new DRect(0.25, 0.25, 3.0, 3.0);
			DRect r = InverseTransform(ref t);
			DRect r2 = InverseTransform(ref t2);
			DRect r3 = CombineTransforms(ref t, ref r2);
			UnityEngine.Debug.Log(r);
			UnityEngine.Debug.Log(r3);
			UnityEngine.Debug.Log("one mat trans " + TransformPoint(ref t, new Vector2(1f, 1f)));
			UnityEngine.Debug.Log("one inv mat trans " + TransformPoint(ref r, new Vector2(1f, 1f)).ToString("f4"));
			UnityEngine.Debug.Log("zero " + TransformPoint(ref r3, new Vector2(0f, 0f)).ToString("f4"));
			UnityEngine.Debug.Log("one " + TransformPoint(ref r3, new Vector2(1f, 1f)).ToString("f4"));
		}

		public static float TransformX(DRect r, double x)
		{
			return (float)(r.width * x + r.x);
		}

		public static DRect CombineTransforms(ref DRect r1, ref DRect r2)
		{
			return new DRect(r1.x * r2.width + r2.x, r1.y * r2.height + r2.y, r1.width * r2.width, r1.height * r2.height);
		}

		public static Rect CombineTransforms(ref Rect r1, ref Rect r2)
		{
			return new Rect(r1.x * r2.width + r2.x, r1.y * r2.height + r2.y, r1.width * r2.width, r1.height * r2.height);
		}

		public static DRect InverseTransform(ref DRect t)
		{
			DRect result = default(DRect);
			result.x = (0.0 - t.x) / t.width;
			result.y = (0.0 - t.y) / t.height;
			result.width = 1.0 / t.width;
			result.height = 1.0 / t.height;
			return result;
		}

		public static DRect GetShiftTransformToFitBinA(ref DRect A, ref DRect B)
		{
			DVector2 center = A.center;
			DVector2 center2 = B.center;
			DVector2 dVector = DVector2.Subtract(center, center2);
			double xx = Convert.ToInt32(dVector.x);
			double yy = Convert.ToInt32(dVector.y);
			return new DRect(xx, yy, 1.0, 1.0);
		}

		public static DRect GetEncapsulatingRectShifted(ref DRect uvRect1, ref DRect willBeIn)
		{
			DVector2 center = uvRect1.center;
			DVector2 center2 = willBeIn.center;
			DVector2 dVector = DVector2.Subtract(center, center2);
			double num = Convert.ToInt32(dVector.x);
			double num2 = Convert.ToInt32(dVector.y);
			DRect dRect = new DRect(willBeIn);
			dRect.x += num;
			dRect.y += num2;
			double x = uvRect1.x;
			double y = uvRect1.y;
			double num3 = uvRect1.x + uvRect1.width;
			double num4 = uvRect1.y + uvRect1.height;
			double x2 = dRect.x;
			double y2 = dRect.y;
			double num5 = dRect.x + dRect.width;
			double num6 = dRect.y + dRect.height;
			double num7;
			double num8 = (num7 = x);
			double num9;
			double num10 = (num9 = y);
			if (x2 < num8)
			{
				num8 = x2;
			}
			if (x < num8)
			{
				num8 = x;
			}
			if (y2 < num10)
			{
				num10 = y2;
			}
			if (y < num10)
			{
				num10 = y;
			}
			if (num5 > num7)
			{
				num7 = num5;
			}
			if (num3 > num7)
			{
				num7 = num3;
			}
			if (num6 > num9)
			{
				num9 = num6;
			}
			if (num4 > num9)
			{
				num9 = num4;
			}
			return new DRect(num8, num10, num7 - num8, num9 - num10);
		}

		public static DRect GetEncapsulatingRect(ref DRect uvRect1, ref DRect uvRect2)
		{
			double x = uvRect1.x;
			double y = uvRect1.y;
			double num = uvRect1.x + uvRect1.width;
			double num2 = uvRect1.y + uvRect1.height;
			double x2 = uvRect2.x;
			double y2 = uvRect2.y;
			double num3 = uvRect2.x + uvRect2.width;
			double num4 = uvRect2.y + uvRect2.height;
			double num5;
			double num6 = (num5 = x);
			double num7;
			double num8 = (num7 = y);
			if (x2 < num6)
			{
				num6 = x2;
			}
			if (x < num6)
			{
				num6 = x;
			}
			if (y2 < num8)
			{
				num8 = y2;
			}
			if (y < num8)
			{
				num8 = y;
			}
			if (num3 > num5)
			{
				num5 = num3;
			}
			if (num > num5)
			{
				num5 = num;
			}
			if (num4 > num7)
			{
				num7 = num4;
			}
			if (num2 > num7)
			{
				num7 = num2;
			}
			return new DRect(num6, num8, num5 - num6, num7 - num8);
		}

		public static bool RectContainsShifted(ref DRect bucket, ref DRect tryFit)
		{
			DVector2 center = bucket.center;
			DVector2 center2 = tryFit.center;
			DVector2 dVector = DVector2.Subtract(center, center2);
			double num = Convert.ToInt32(dVector.x);
			double num2 = Convert.ToInt32(dVector.y);
			DRect smallToTestIfFits = new DRect(tryFit);
			smallToTestIfFits.x += num;
			smallToTestIfFits.y += num2;
			return bucket.Encloses(smallToTestIfFits);
		}

		public static bool RectContainsShifted(ref Rect bucket, ref Rect tryFit)
		{
			Vector2 center = bucket.center;
			Vector2 center2 = tryFit.center;
			Vector2 vector = center - center2;
			float num = Convert.ToInt32(vector.x);
			float num2 = Convert.ToInt32(vector.y);
			Rect smallToTestIfFits = new Rect(tryFit);
			smallToTestIfFits.x += num;
			smallToTestIfFits.y += num2;
			return RectContains(ref bucket, ref smallToTestIfFits);
		}

		public static bool LineSegmentContainsShifted(float bucketOffset, float bucketLength, float tryFitOffset, float tryFitLength)
		{
			float num = bucketOffset + bucketLength / 2f;
			float num2 = tryFitOffset + tryFitLength / 2f;
			float num3 = Convert.ToInt32(num - num2);
			tryFitOffset += num3;
			float num4 = tryFitOffset;
			float num5 = tryFitOffset + tryFitLength;
			float num6 = bucketOffset - 0.01f;
			float num7 = bucketOffset + bucketLength + 0.01f;
			if (num6 <= num4 && num4 <= num7 && num6 <= num5)
			{
				return num5 <= num7;
			}
			return false;
		}

		public static bool RectContains(ref DRect bigRect, ref DRect smallToTestIfFits)
		{
			double x = smallToTestIfFits.x;
			double y = smallToTestIfFits.y;
			double num = smallToTestIfFits.x + smallToTestIfFits.width;
			double num2 = smallToTestIfFits.y + smallToTestIfFits.height;
			double num3 = bigRect.x - 0.009999999776482582;
			double num4 = bigRect.y - 0.009999999776482582;
			double num5 = bigRect.x + bigRect.width + 0.009999999776482582;
			double num6 = bigRect.y + bigRect.height + 0.009999999776482582;
			if (num3 <= x && x <= num5 && num3 <= num && num <= num5 && num4 <= y && y <= num6 && num4 <= num2)
			{
				return num2 <= num6;
			}
			return false;
		}

		public static bool RectContains(ref Rect bigRect, ref Rect smallToTestIfFits)
		{
			float x = smallToTestIfFits.x;
			float y = smallToTestIfFits.y;
			float num = smallToTestIfFits.x + smallToTestIfFits.width;
			float num2 = smallToTestIfFits.y + smallToTestIfFits.height;
			float num3 = bigRect.x - 0.01f;
			float num4 = bigRect.y - 0.01f;
			float num5 = bigRect.x + bigRect.width + 0.01f;
			float num6 = bigRect.y + bigRect.height + 0.01f;
			if (num3 <= x && x <= num5 && num3 <= num && num <= num5 && num4 <= y && y <= num6 && num4 <= num2)
			{
				return num2 <= num6;
			}
			return false;
		}

		public static Vector2 TransformPoint(ref DRect r, Vector2 p)
		{
			return new Vector2((float)(r.width * (double)p.x + r.x), (float)(r.height * (double)p.y + r.y));
		}

		public static DVector2 TransformPoint(ref DRect r, DVector2 p)
		{
			return new DVector2(r.width * p.x + r.x, r.height * p.y + r.y);
		}
	}
	[Serializable]
	public struct AtlasPadding
	{
		public int topBottom;

		public int leftRight;

		public AtlasPadding(int p)
		{
			topBottom = p;
			leftRight = p;
		}

		public AtlasPadding(int px, int py)
		{
			topBottom = py;
			leftRight = px;
		}
	}
	[Serializable]
	public class AtlasPackingResult
	{
		public int atlasX;

		public int atlasY;

		public int usedW;

		public int usedH;

		public Rect[] rects;

		public AtlasPadding[] padding;

		public int[] srcImgIdxs;

		public object data;

		public AtlasPackingResult(AtlasPadding[] pds)
		{
			padding = pds;
		}

		public void CalcUsedWidthAndHeight()
		{
			float num = 0f;
			float num2 = 0f;
			float num3 = 0f;
			float num4 = 0f;
			for (int i = 0; i < rects.Length; i++)
			{
				num3 += (float)padding[i].leftRight * 2f;
				num4 += (float)padding[i].topBottom * 2f;
				num = Mathf.Max(num, rects[i].x + rects[i].width);
				num2 = Mathf.Max(num2, rects[i].y + rects[i].height);
			}
			usedW = Mathf.CeilToInt(num * (float)atlasX + num3);
			usedH = Mathf.CeilToInt(num2 * (float)atlasY + num4);
			if (usedW > atlasX)
			{
				usedW = atlasX;
			}
			if (usedH > atlasY)
			{
				usedH = atlasY;
			}
		}

		public override string ToString()
		{
			return $"numRects: {rects.Length}, atlasX: {atlasX} atlasY: {atlasY} usedW: {usedW} usedH: {usedH}";
		}
	}
	public abstract class MB2_TexturePacker
	{
		internal enum NodeType
		{
			Container,
			maxDim,
			regular
		}

		internal class PixRect
		{
			public int x;

			public int y;

			public int w;

			public int h;

			public PixRect()
			{
			}

			public PixRect(int xx, int yy, int ww, int hh)
			{
				x = xx;
				y = yy;
				w = ww;
				h = hh;
			}

			public override string ToString()
			{
				return $"x={x},y={y},w={w},h={h}";
			}
		}

		internal class Image
		{
			public int imgId;

			public int w;

			public int h;

			public int x;

			public int y;

			public Image(int id, int tw, int th, AtlasPadding padding, int minImageSizeX, int minImageSizeY)
			{
				imgId = id;
				w = Mathf.Max(tw + padding.leftRight * 2, minImageSizeX);
				h = Mathf.Max(th + padding.topBottom * 2, minImageSizeY);
			}

			public Image(Image im)
			{
				imgId = im.imgId;
				w = im.w;
				h = im.h;
				x = im.x;
				y = im.y;
			}
		}

		internal class ImgIDComparer : IComparer<Image>
		{
			public int Compare(Image x, Image y)
			{
				if (x.imgId > y.imgId)
				{
					return 1;
				}
				if (x.imgId == y.imgId)
				{
					return 0;
				}
				return -1;
			}
		}

		internal class ImageHeightComparer : IComparer<Image>
		{
			public int Compare(Image x, Image y)
			{
				if (x.h > y.h)
				{
					return -1;
				}
				if (x.h == y.h)
				{
					return 0;
				}
				return 1;
			}
		}

		internal class ImageWidthComparer : IComparer<Image>
		{
			public int Compare(Image x, Image y)
			{
				if (x.w > y.w)
				{
					return -1;
				}
				if (x.w == y.w)
				{
					return 0;
				}
				return 1;
			}
		}

		internal class ImageAreaComparer : IComparer<Image>
		{
			public int Compare(Image x, Image y)
			{
				int num = x.w * x.h;
				int num2 = y.w * y.h;
				if (num > num2)
				{
					return -1;
				}
				if (num == num2)
				{
					return 0;
				}
				return 1;
			}
		}

		public MB2_LogLevel LOG_LEVEL = MB2_LogLevel.info;

		public bool atlasMustBePowerOfTwo = true;

		public static int RoundToNearestPositivePowerOfTwo(int x)
		{
			int num = (int)Mathf.Pow(2f, Mathf.RoundToInt(Mathf.Log(x) / Mathf.Log(2f)));
			if (num == 0 || num == 1)
			{
				num = 2;
			}
			return num;
		}

		public static int CeilToNearestPowerOfTwo(int x)
		{
			int num = (int)Mathf.Pow(2f, Mathf.Ceil(Mathf.Log(x) / Mathf.Log(2f)));
			if (num == 0 || num == 1)
			{
				num = 2;
			}
			return num;
		}

		public abstract AtlasPackingResult[] GetRects(List<Vector2> imgWidthHeights, int maxDimensionX, int maxDimensionY, int padding);

		public abstract AtlasPackingResult[] GetRects(List<Vector2> imgWidthHeights, List<AtlasPadding> paddings, int maxDimensionX, int maxDimensionY, bool doMultiAtlas);

		internal bool ScaleAtlasToFitMaxDim(Vector2 rootWH, List<Image> images, int maxDimensionX, int maxDimensionY, AtlasPadding padding, int minImageSizeX, int minImageSizeY, int masterImageSizeX, int masterImageSizeY, ref int outW, ref int outH, out float padX, out float padY, out int newMinSizeX, out int newMinSizeY)
		{
			newMinSizeX = minImageSizeX;
			newMinSizeY = minImageSizeY;
			bool result = false;
			padX = (float)padding.leftRight / (float)outW;
			if (rootWH.x > (float)maxDimensionX)
			{
				padX = (float)padding.leftRight / (float)maxDimensionX;
				float num = (float)maxDimensionX / rootWH.x;
				if (LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Packing exceeded atlas width shrinking to " + num);
				}
				for (int i = 0; i < images.Count; i++)
				{
					Image image = images[i];
					if ((float)image.w * num < (float)masterImageSizeX)
					{
						if (LOG_LEVEL >= MB2_LogLevel.debug)
						{
							UnityEngine.Debug.Log("Small images are being scaled to zero. Will need to redo packing with larger minTexSizeX.");
						}
						result = true;
						newMinSizeX = Mathf.CeilToInt((float)minImageSizeX / num);
					}
					int num2 = (int)((float)(image.x + image.w) * num);
					image.x = (int)(num * (float)image.x);
					image.w = num2 - image.x;
				}
				outW = maxDimensionX;
			}
			padY = (float)padding.topBottom / (float)outH;
			if (rootWH.y > (float)maxDimensionY)
			{
				padY = (float)padding.topBottom / (float)maxDimensionY;
				float num3 = (float)maxDimensionY / rootWH.y;
				if (LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Packing exceeded atlas height shrinking to " + num3);
				}
				for (int j = 0; j < images.Count; j++)
				{
					Image image2 = images[j];
					if ((float)image2.h * num3 < (float)masterImageSizeY)
					{
						if (LOG_LEVEL >= MB2_LogLevel.debug)
						{
							UnityEngine.Debug.Log("Small images are being scaled to zero. Will need to redo packing with larger minTexSizeY.");
						}
						result = true;
						newMinSizeY = Mathf.CeilToInt((float)minImageSizeY / num3);
					}
					int num4 = (int)((float)(image2.y + image2.h) * num3);
					image2.y = (int)(num3 * (float)image2.y);
					image2.h = num4 - image2.y;
				}
				outH = maxDimensionY;
			}
			return result;
		}

		public void normalizeRects(AtlasPackingResult rr, AtlasPadding padding)
		{
			for (int i = 0; i < rr.rects.Length; i++)
			{
				rr.rects[i].x = (rr.rects[i].x + (float)padding.leftRight) / (float)rr.atlasX;
				rr.rects[i].y = (rr.rects[i].y + (float)padding.topBottom) / (float)rr.atlasY;
				rr.rects[i].width = (rr.rects[i].width - (float)(padding.leftRight * 2)) / (float)rr.atlasX;
				rr.rects[i].height = (rr.rects[i].height - (float)(padding.topBottom * 2)) / (float)rr.atlasY;
			}
		}
	}
	public class MB2_TexturePackerRegular : MB2_TexturePacker
	{
		private class ProbeResult
		{
			public int w;

			public int h;

			public int outW;

			public int outH;

			public Node root;

			public bool largerOrEqualToMaxDim;

			public float efficiency;

			public float squareness;

			public float totalAtlasArea;

			public int numAtlases;

			public void Set(int ww, int hh, int outw, int outh, Node r, bool fits, float e, float sq)
			{
				w = ww;
				h = hh;
				outW = outw;
				outH = outh;
				root = r;
				largerOrEqualToMaxDim = fits;
				efficiency = e;
				squareness = sq;
			}

			public float GetScore(bool doPowerOfTwoScore)
			{
				float num = (largerOrEqualToMaxDim ? 1f : 0f);
				if (doPowerOfTwoScore)
				{
					return num * 2f + efficiency;
				}
				return squareness + 2f * efficiency + num;
			}

			public void PrintTree()
			{
				printTree(root, "  ");
			}
		}

		internal class Node
		{
			internal NodeType isFullAtlas;

			internal Node[] child = new Node[2];

			internal PixRect r;

			internal Image img;

			private ProbeResult bestRoot;

			internal Node(NodeType rootType)
			{
				isFullAtlas = rootType;
			}

			private bool isLeaf()
			{
				if (child[0] == null || child[1] == null)
				{
					return true;
				}
				return false;
			}

			internal Node Insert(Image im, bool handed)
			{
				int num;
				int num2;
				if (handed)
				{
					num = 0;
					num2 = 1;
				}
				else
				{
					num = 1;
					num2 = 0;
				}
				if (!isLeaf())
				{
					Node node = child[num].Insert(im, handed);
					if (node != null)
					{
						return node;
					}
					return child[num2].Insert(im, handed);
				}
				if (img != null)
				{
					return null;
				}
				if (r.w < im.w || r.h < im.h)
				{
					return null;
				}
				if (r.w == im.w && r.h == im.h)
				{
					img = im;
					return this;
				}
				child[num] = new Node(NodeType.regular);
				child[num2] = new Node(NodeType.regular);
				int num3 = r.w - im.w;
				int num4 = r.h - im.h;
				if (num3 > num4)
				{
					child[num].r = new PixRect(r.x, r.y, im.w, r.h);
					child[num2].r = new PixRect(r.x + im.w, r.y, r.w - im.w, r.h);
				}
				else
				{
					child[num].r = new PixRect(r.x, r.y, r.w, im.h);
					child[num2].r = new PixRect(r.x, r.y + im.h, r.w, r.h - im.h);
				}
				return child[num].Insert(im, handed);
			}
		}

		private ProbeResult bestRoot;

		public int atlasY;

		private static void printTree(Node r, string spc)
		{
			UnityEngine.Debug.Log(spc + "Nd img=" + (r.img != null).ToString() + " r=" + r.r);
			if (r.child[0] != null)
			{
				printTree(r.child[0], spc + "      ");
			}
			if (r.child[1] != null)
			{
				printTree(r.child[1], spc + "      ");
			}
		}

		private static void flattenTree(Node r, List<Image> putHere)
		{
			if (r.img != null)
			{
				r.img.x = r.r.x;
				r.img.y = r.r.y;
				putHere.Add(r.img);
			}
			if (r.child[0] != null)
			{
				flattenTree(r.child[0], putHere);
			}
			if (r.child[1] != null)
			{
				flattenTree(r.child[1], putHere);
			}
		}

		private static void drawGizmosNode(Node r)
		{
			Vector3 size = new Vector3(r.r.w, r.r.h, 0f);
			Vector3 center = new Vector3((float)r.r.x + size.x / 2f, (float)(-r.r.y) - size.y / 2f, 0f);
			Gizmos.color = UnityEngine.Color.yellow;
			Gizmos.DrawWireCube(center, size);
			if (r.img != null)
			{
				Gizmos.color = new UnityEngine.Color(UnityEngine.Random.value, UnityEngine.Random.value, UnityEngine.Random.value);
				size = new Vector3(r.img.w, r.img.h, 0f);
				Gizmos.DrawCube(new Vector3((float)r.r.x + size.x / 2f, (float)(-r.r.y) - size.y / 2f, 0f), size);
			}
			if (r.child[0] != null)
			{
				Gizmos.color = UnityEngine.Color.red;
				drawGizmosNode(r.child[0]);
			}
			if (r.child[1] != null)
			{
				Gizmos.color = UnityEngine.Color.green;
				drawGizmosNode(r.child[1]);
			}
		}

		private static Texture2D createFilledTex(UnityEngine.Color c, int w, int h)
		{
			Texture2D texture2D = new Texture2D(w, h);
			for (int i = 0; i < w; i++)
			{
				for (int j = 0; j < h; j++)
				{
					texture2D.SetPixel(i, j, c);
				}
			}
			texture2D.Apply();
			return texture2D;
		}

		public void DrawGizmos()
		{
			if (bestRoot != null)
			{
				drawGizmosNode(bestRoot.root);
				Gizmos.color = UnityEngine.Color.yellow;
				Vector3 size = new Vector3(bestRoot.outW, -bestRoot.outH, 0f);
				Gizmos.DrawWireCube(new Vector3(size.x / 2f, size.y / 2f, 0f), size);
			}
		}

		private bool ProbeSingleAtlas(Image[] imgsToAdd, int idealAtlasW, int idealAtlasH, float imgArea, int maxAtlasDimX, int maxAtlasDimY, ProbeResult pr)
		{
			Node node = new Node(NodeType.maxDim);
			node.r = new PixRect(0, 0, idealAtlasW, idealAtlasH);
			for (int i = 0; i < imgsToAdd.Length; i++)
			{
				if (node.Insert(imgsToAdd[i], handed: false) == null)
				{
					return false;
				}
				if (i != imgsToAdd.Length - 1)
				{
					continue;
				}
				int x = 0;
				int y = 0;
				GetExtent(node, ref x, ref y);
				int num = x;
				int num2 = y;
				bool fits;
				float num6;
				float num7;
				if (atlasMustBePowerOfTwo)
				{
					num = Mathf.Min(MB2_TexturePacker.CeilToNearestPowerOfTwo(x), maxAtlasDimX);
					num2 = Mathf.Min(MB2_TexturePacker.CeilToNearestPowerOfTwo(y), maxAtlasDimY);
					if (num2 < num / 2)
					{
						num2 = num / 2;
					}
					if (num < num2 / 2)
					{
						num = num2 / 2;
					}
					fits = x <= maxAtlasDimX && y <= maxAtlasDimY;
					float num3 = Mathf.Max(1f, (float)x / (float)maxAtlasDimX);
					float num4 = Mathf.Max(1f, (float)y / (float)maxAtlasDimY);
					float num5 = (float)num * num3 * (float)num2 * num4;
					num6 = 1f - (num5 - imgArea) / num5;
					num7 = 1f;
				}
				else
				{
					num6 = 1f - ((float)(x * y) - imgArea) / (float)(x * y);
					num7 = ((x >= y) ? ((float)y / (float)x) : ((float)x / (float)y));
					fits = x <= maxAtlasDimX && y <= maxAtlasDimY;
				}
				pr.Set(x, y, num, num2, node, fits, num6, num7);
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug("Probe success efficiency w=" + x + " h=" + y + " e=" + num6 + " sq=" + num7 + " fits=" + fits.ToString());
				}
				return true;
			}
			UnityEngine.Debug.LogError("Should never get here.");
			return false;
		}

		private bool ProbeMultiAtlas(Image[] imgsToAdd, int idealAtlasW, int idealAtlasH, float imgArea, int maxAtlasDimX, int maxAtlasDimY, ProbeResult pr)
		{
			int num = 0;
			Node node = new Node(NodeType.maxDim);
			node.r = new PixRect(0, 0, idealAtlasW, idealAtlasH);
			for (int i = 0; i < imgsToAdd.Length; i++)
			{
				if (node.Insert(imgsToAdd[i], handed: false) == null)
				{
					if (imgsToAdd[i].x > idealAtlasW && imgsToAdd[i].y > idealAtlasH)
					{
						return false;
					}
					Node obj = new Node(NodeType.Container)
					{
						r = new PixRect(0, 0, node.r.w + idealAtlasW, idealAtlasH)
					};
					Node node2 = new Node(NodeType.maxDim)
					{
						r = new PixRect(node.r.w, 0, idealAtlasW, idealAtlasH)
					};
					obj.child[1] = node2;
					obj.child[0] = node;
					node = obj;
					node.Insert(imgsToAdd[i], handed: false);
					num++;
				}
			}
			pr.numAtlases = num;
			pr.root = node;
			pr.totalAtlasArea = num * maxAtlasDimX * maxAtlasDimY;
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				MB2_Log.LogDebug("Probe success efficiency numAtlases=" + num + " totalArea=" + pr.totalAtlasArea);
			}
			return true;
		}

		internal void GetExtent(Node r, ref int x, ref int y)
		{
			if (r.img != null)
			{
				if (r.r.x + r.img.w > x)
				{
					x = r.r.x + r.img.w;
				}
				if (r.r.y + r.img.h > y)
				{
					y = r.r.y + r.img.h;
				}
			}
			if (r.child[0] != null)
			{
				GetExtent(r.child[0], ref x, ref y);
			}
			if (r.child[1] != null)
			{
				GetExtent(r.child[1], ref x, ref y);
			}
		}

		private int StepWidthHeight(int oldVal, int step, int maxDim)
		{
			if (atlasMustBePowerOfTwo && oldVal < maxDim)
			{
				return oldVal * 2;
			}
			int num = oldVal + step;
			if (num > maxDim && oldVal < maxDim)
			{
				num = maxDim;
			}
			return num;
		}

		public override AtlasPackingResult[] GetRects(List<Vector2> imgWidthHeights, int maxDimensionX, int maxDimensionY, int atPadding)
		{
			List<AtlasPadding> list = new List<AtlasPadding>();
			for (int i = 0; i < imgWidthHeights.Count; i++)
			{
				AtlasPadding item = default(AtlasPadding);
				item.leftRight = (item.topBottom = atPadding);
				list.Add(item);
			}
			return GetRects(imgWidthHeights, list, maxDimensionX, maxDimensionY, doMultiAtlas: false);
		}

		public override AtlasPackingResult[] GetRects(List<Vector2> imgWidthHeights, List<AtlasPadding> paddings, int maxDimensionX, int maxDimensionY, bool doMultiAtlas)
		{
			int num = 0;
			int num2 = 0;
			for (int i = 0; i < paddings.Count; i++)
			{
				num = Mathf.Max(num, paddings[i].leftRight);
				num2 = Mathf.Max(num2, paddings[i].topBottom);
			}
			if (doMultiAtlas)
			{
				return _GetRectsMultiAtlas(imgWidthHeights, paddings, maxDimensionX, maxDimensionY, 2 + num * 2, 2 + num2 * 2, 2 + num * 2, 2 + num2 * 2);
			}
			AtlasPackingResult atlasPackingResult = _GetRectsSingleAtlas(imgWidthHeights, paddings, maxDimensionX, maxDimensionY, 2 + num * 2, 2 + num2 * 2, 2 + num * 2, 2 + num2 * 2, 0);
			if (atlasPackingResult == null)
			{
				return null;
			}
			return new AtlasPackingResult[1] { atlasPackingResult };
		}

		private AtlasPackingResult _GetRectsSingleAtlas(List<Vector2> imgWidthHeights, List<AtlasPadding> paddings, int maxDimensionX, int maxDimensionY, int minImageSizeX, int minImageSizeY, int masterImageSizeX, int masterImageSizeY, int recursionDepth)
		{
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log($"_GetRects numImages={imgWidthHeights.Count}, maxDimension={maxDimensionX}, minImageSizeX={minImageSizeX}, minImageSizeY={minImageSizeY}, masterImageSizeX={masterImageSizeX}, masterImageSizeY={masterImageSizeY}, recursionDepth={recursionDepth}");
			}
			if (recursionDepth > 10)
			{
				if (LOG_LEVEL >= MB2_LogLevel.error)
				{
					UnityEngine.Debug.LogError("Maximum recursion depth reached. Couldn't find packing for these textures.");
				}
				return null;
			}
			float num = 0f;
			int num2 = 0;
			int num3 = 0;
			Image[] array = new Image[imgWidthHeights.Count];
			for (int i = 0; i < array.Length; i++)
			{
				int tw = (int)imgWidthHeights[i].x;
				int th = (int)imgWidthHeights[i].y;
				Image image = (array[i] = new Image(i, tw, th, paddings[i], minImageSizeX, minImageSizeY));
				num += (float)(image.w * image.h);
				num2 = Mathf.Max(num2, image.w);
				num3 = Mathf.Max(num3, image.h);
			}
			if ((float)num3 / (float)num2 > 2f)
			{
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug("Using height Comparer");
				}
				Array.Sort(array, new ImageHeightComparer());
			}
			else if ((double)((float)num3 / (float)num2) < 0.5)
			{
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug("Using width Comparer");
				}
				Array.Sort(array, new ImageWidthComparer());
			}
			else
			{
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug("Using area Comparer");
				}
				Array.Sort(array, new ImageAreaComparer());
			}
			int num4 = (int)Mathf.Sqrt(num);
			int num6;
			int num5;
			if (atlasMustBePowerOfTwo)
			{
				num6 = (num5 = MB2_TexturePacker.RoundToNearestPositivePowerOfTwo(num4));
				if (num2 > num6)
				{
					num6 = MB2_TexturePacker.CeilToNearestPowerOfTwo(num6);
				}
				if (num3 > num5)
				{
					num5 = MB2_TexturePacker.CeilToNearestPowerOfTwo(num5);
				}
			}
			else
			{
				num6 = num4;
				num5 = num4;
				if (num2 > num4)
				{
					num6 = num2;
					num5 = Mathf.Max(Mathf.CeilToInt(num / (float)num2), num3);
				}
				if (num3 > num4)
				{
					num6 = Mathf.Max(Mathf.CeilToInt(num / (float)num3), num2);
					num5 = num3;
				}
			}
			if (num6 == 0)
			{
				num6 = 4;
			}
			if (num5 == 0)
			{
				num5 = 4;
			}
			int num7 = (int)((float)num6 * 0.15f);
			int num8 = (int)((float)num5 * 0.15f);
			if (num7 == 0)
			{
				num7 = 1;
			}
			if (num8 == 0)
			{
				num8 = 1;
			}
			int num9 = 2;
			int num10 = num6;
			int num11 = num5;
			while (num9 >= 1 && num11 < num4 * 1000)
			{
				bool flag = false;
				num9 = 0;
				num10 = num6;
				while (!flag && num10 < num4 * 1000)
				{
					ProbeResult probeResult = new ProbeResult();
					if (LOG_LEVEL >= MB2_LogLevel.trace)
					{
						UnityEngine.Debug.Log("Probing h=" + num11 + " w=" + num10);
					}
					if (ProbeSingleAtlas(array, num10, num11, num, maxDimensionX, maxDimensionY, probeResult))
					{
						flag = true;
						if (bestRoot == null)
						{
							bestRoot = probeResult;
						}
						else if (probeResult.GetScore(atlasMustBePowerOfTwo) > bestRoot.GetScore(atlasMustBePowerOfTwo))
						{
							bestRoot = probeResult;
						}
						continue;
					}
					num9++;
					num10 = StepWidthHeight(num10, num7, maxDimensionX);
					if (LOG_LEVEL >= MB2_LogLevel.trace)
					{
						MB2_Log.LogDebug("increasing Width h=" + num11 + " w=" + num10);
					}
				}
				num11 = StepWidthHeight(num11, num8, maxDimensionY);
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug("increasing Height h=" + num11 + " w=" + num10);
				}
			}
			if (bestRoot == null)
			{
				return null;
			}
			int num12 = 0;
			int num13 = 0;
			if (atlasMustBePowerOfTwo)
			{
				num12 = Mathf.Min(MB2_TexturePacker.CeilToNearestPowerOfTwo(bestRoot.w), maxDimensionX);
				num13 = Mathf.Min(MB2_TexturePacker.CeilToNearestPowerOfTwo(bestRoot.h), maxDimensionY);
				if (num13 < num12 / 2)
				{
					num13 = num12 / 2;
				}
				if (num12 < num13 / 2)
				{
					num12 = num13 / 2;
				}
			}
			else
			{
				num12 = Mathf.Min(bestRoot.w, maxDimensionX);
				num13 = Mathf.Min(bestRoot.h, maxDimensionY);
			}
			bestRoot.outW = num12;
			bestRoot.outH = num13;
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Best fit found: atlasW=" + num12 + " atlasH" + num13 + " w=" + bestRoot.w + " h=" + bestRoot.h + " efficiency=" + bestRoot.efficiency + " squareness=" + bestRoot.squareness + " fits in max dimension=" + bestRoot.largerOrEqualToMaxDim.ToString());
			}
			List<Image> list = new List<Image>();
			flattenTree(bestRoot.root, list);
			list.Sort(new ImgIDComparer());
			Vector2 rootWH = new Vector2(bestRoot.w, bestRoot.h);
			if (!ScaleAtlasToFitMaxDim(rootWH, list, maxDimensionX, maxDimensionY, paddings[0], minImageSizeX, minImageSizeY, masterImageSizeX, masterImageSizeY, ref num12, ref num13, out var padX, out var padY, out var newMinSizeX, out var newMinSizeY))
			{
				AtlasPackingResult atlasPackingResult = new AtlasPackingResult(paddings.ToArray());
				atlasPackingResult.rects = new Rect[list.Count];
				atlasPackingResult.srcImgIdxs = new int[list.Count];
				atlasPackingResult.atlasX = num12;
				atlasPackingResult.atlasY = num13;
				atlasPackingResult.usedW = -1;
				atlasPackingResult.usedH = -1;
				for (int j = 0; j < list.Count; j++)
				{
					Image image2 = list[j];
					Rect rect = (atlasPackingResult.rects[j] = new Rect((float)image2.x / (float)num12 + padX, (float)image2.y / (float)num13 + padY, (float)image2.w / (float)num12 - padX * 2f, (float)image2.h / (float)num13 - padY * 2f));
					atlasPackingResult.srcImgIdxs[j] = image2.imgId;
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug("Image: " + j + " imgID=" + image2.imgId + " x=" + rect.x * (float)num12 + " y=" + rect.y * (float)num13 + " w=" + rect.width * (float)num12 + " h=" + rect.height * (float)num13 + " padding=" + paddings[j]);
					}
				}
				atlasPackingResult.CalcUsedWidthAndHeight();
				return atlasPackingResult;
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("==================== REDOING PACKING ================");
			}
			return _GetRectsSingleAtlas(imgWidthHeights, paddings, maxDimensionX, maxDimensionY, newMinSizeX, newMinSizeY, masterImageSizeX, masterImageSizeY, recursionDepth + 1);
		}

		private AtlasPackingResult[] _GetRectsMultiAtlas(List<Vector2> imgWidthHeights, List<AtlasPadding> paddings, int maxDimensionPassedX, int maxDimensionPassedY, int minImageSizeX, int minImageSizeY, int masterImageSizeX, int masterImageSizeY)
		{
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log($"_GetRects numImages={imgWidthHeights.Count}, maxDimensionX={maxDimensionPassedX}, maxDimensionY={maxDimensionPassedY} minImageSizeX={minImageSizeX}, minImageSizeY={minImageSizeY}, masterImageSizeX={masterImageSizeX}, masterImageSizeY={masterImageSizeY}");
			}
			float num = 0f;
			int a = 0;
			int a2 = 0;
			Image[] array = new Image[imgWidthHeights.Count];
			int num2 = maxDimensionPassedX;
			int num3 = maxDimensionPassedY;
			if (atlasMustBePowerOfTwo)
			{
				num2 = MB2_TexturePacker.RoundToNearestPositivePowerOfTwo(num2);
				num3 = MB2_TexturePacker.RoundToNearestPositivePowerOfTwo(num3);
			}
			for (int i = 0; i < array.Length; i++)
			{
				int a3 = (int)imgWidthHeights[i].x;
				int a4 = (int)imgWidthHeights[i].y;
				a3 = Mathf.Min(a3, num2 - paddings[i].leftRight * 2);
				a4 = Mathf.Min(a4, num3 - paddings[i].topBottom * 2);
				Image image = (array[i] = new Image(i, a3, a4, paddings[i], minImageSizeX, minImageSizeY));
				num += (float)(image.w * image.h);
				a = Mathf.Max(a, image.w);
				a2 = Mathf.Max(a2, image.h);
			}
			int num4;
			int num5;
			if (atlasMustBePowerOfTwo)
			{
				num4 = MB2_TexturePacker.RoundToNearestPositivePowerOfTwo(num3);
				num5 = MB2_TexturePacker.RoundToNearestPositivePowerOfTwo(num2);
			}
			else
			{
				num4 = num3;
				num5 = num2;
			}
			if (num5 == 0)
			{
				num5 = 4;
			}
			if (num4 == 0)
			{
				num4 = 4;
			}
			ProbeResult probeResult = new ProbeResult();
			Array.Sort(array, new ImageHeightComparer());
			if (ProbeMultiAtlas(array, num5, num4, num, num2, num3, probeResult))
			{
				bestRoot = probeResult;
			}
			Array.Sort(array, new ImageWidthComparer());
			if (ProbeMultiAtlas(array, num5, num4, num, num2, num3, probeResult) && probeResult.totalAtlasArea < bestRoot.totalAtlasArea)
			{
				bestRoot = probeResult;
			}
			Array.Sort(array, new ImageAreaComparer());
			if (ProbeMultiAtlas(array, num5, num4, num, num2, num3, probeResult) && probeResult.totalAtlasArea < bestRoot.totalAtlasArea)
			{
				bestRoot = probeResult;
			}
			if (bestRoot == null)
			{
				return null;
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Best fit found: w=" + bestRoot.w + " h=" + bestRoot.h + " efficiency=" + bestRoot.efficiency + " squareness=" + bestRoot.squareness + " fits in max dimension=" + bestRoot.largerOrEqualToMaxDim.ToString());
			}
			List<AtlasPackingResult> list = new List<AtlasPackingResult>();
			List<Node> list2 = new List<Node>();
			Stack<Node> stack = new Stack<Node>();
			for (Node node = bestRoot.root; node != null; node = node.child[0])
			{
				stack.Push(node);
			}
			while (stack.Count > 0)
			{
				Node node = stack.Pop();
				if (node.isFullAtlas == NodeType.maxDim)
				{
					list2.Add(node);
				}
				if (node.child[1] != null)
				{
					for (node = node.child[1]; node != null; node = node.child[0])
					{
						stack.Push(node);
					}
				}
			}
			for (int j = 0; j < list2.Count; j++)
			{
				List<Image> list3 = new List<Image>();
				flattenTree(list2[j], list3);
				Rect[] array2 = new Rect[list3.Count];
				int[] array3 = new int[list3.Count];
				for (int k = 0; k < list3.Count; k++)
				{
					array2[k] = new Rect(list3[k].x - list2[j].r.x, list3[k].y, list3[k].w, list3[k].h);
					array3[k] = list3[k].imgId;
				}
				AtlasPackingResult atlasPackingResult = new AtlasPackingResult(paddings.ToArray());
				GetExtent(list2[j], ref atlasPackingResult.usedW, ref atlasPackingResult.usedH);
				atlasPackingResult.usedW -= list2[j].r.x;
				int w = list2[j].r.w;
				int h = list2[j].r.h;
				if (atlasMustBePowerOfTwo)
				{
					w = Mathf.Min(MB2_TexturePacker.CeilToNearestPowerOfTwo(atlasPackingResult.usedW), list2[j].r.w);
					h = Mathf.Min(MB2_TexturePacker.CeilToNearestPowerOfTwo(atlasPackingResult.usedH), list2[j].r.h);
					if (h < w / 2)
					{
						h = w / 2;
					}
					if (w < h / 2)
					{
						w = h / 2;
					}
				}
				else
				{
					w = atlasPackingResult.usedW;
					h = atlasPackingResult.usedH;
				}
				atlasPackingResult.atlasY = h;
				atlasPackingResult.atlasX = w;
				atlasPackingResult.rects = array2;
				atlasPackingResult.srcImgIdxs = array3;
				atlasPackingResult.CalcUsedWidthAndHeight();
				list.Add(atlasPackingResult);
				normalizeRects(atlasPackingResult, paddings[j]);
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug($"Done GetRects ");
				}
			}
			return list.ToArray();
		}
	}
	public class MB2_TexturePackerHorizontalVert : MB2_TexturePacker
	{
		public enum TexturePackingOrientation
		{
			horizontal,
			vertical
		}

		public TexturePackingOrientation packingOrientation;

		public bool stretchImagesToEdges = true;

		public override AtlasPackingResult[] GetRects(List<Vector2> imgWidthHeights, int maxDimensionX, int maxDimensionY, int padding)
		{
			List<AtlasPadding> list = new List<AtlasPadding>();
			for (int i = 0; i < imgWidthHeights.Count; i++)
			{
				AtlasPadding item = default(AtlasPadding);
				if (packingOrientation == TexturePackingOrientation.horizontal)
				{
					item.leftRight = 0;
					item.topBottom = 8;
				}
				else
				{
					item.leftRight = 8;
					item.topBottom = 0;
				}
				list.Add(item);
			}
			return GetRects(imgWidthHeights, list, maxDimensionX, maxDimensionY, doMultiAtlas: false);
		}

		public override AtlasPackingResult[] GetRects(List<Vector2> imgWidthHeights, List<AtlasPadding> paddings, int maxDimensionX, int maxDimensionY, bool doMultiAtlas)
		{
			int num = 0;
			int num2 = 0;
			for (int i = 0; i < paddings.Count; i++)
			{
				num = Mathf.Max(num, paddings[i].leftRight);
				num2 = Mathf.Max(num2, paddings[i].topBottom);
			}
			if (doMultiAtlas)
			{
				if (packingOrientation == TexturePackingOrientation.vertical)
				{
					return _GetRectsMultiAtlasVertical(imgWidthHeights, paddings, maxDimensionX, maxDimensionY, 2 + num * 2, 2 + num2 * 2, 2 + num * 2, 2 + num2 * 2);
				}
				return _GetRectsMultiAtlasHorizontal(imgWidthHeights, paddings, maxDimensionX, maxDimensionY, 2 + num * 2, 2 + num2 * 2, 2 + num * 2, 2 + num2 * 2);
			}
			AtlasPackingResult atlasPackingResult = _GetRectsSingleAtlas(imgWidthHeights, paddings, maxDimensionX, maxDimensionY, 2 + num * 2, 2 + num2 * 2, 2 + num * 2, 2 + num2 * 2, 0);
			if (atlasPackingResult == null)
			{
				return null;
			}
			return new AtlasPackingResult[1] { atlasPackingResult };
		}

		private AtlasPackingResult _GetRectsSingleAtlas(List<Vector2> imgWidthHeights, List<AtlasPadding> paddings, int maxDimensionX, int maxDimensionY, int minImageSizeX, int minImageSizeY, int masterImageSizeX, int masterImageSizeY, int recursionDepth)
		{
			AtlasPackingResult atlasPackingResult = new AtlasPackingResult(paddings.ToArray());
			List<Rect> list = new List<Rect>();
			int num = 0;
			int num2 = 0;
			int num3 = 0;
			List<Image> list2 = new List<Image>();
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Packing rects for: " + imgWidthHeights.Count);
			}
			for (int i = 0; i < imgWidthHeights.Count; i++)
			{
				Image image = new Image(i, (int)imgWidthHeights[i].x, (int)imgWidthHeights[i].y, paddings[i], minImageSizeX, minImageSizeY);
				if (packingOrientation == TexturePackingOrientation.vertical)
				{
					image.h -= paddings[i].topBottom * 2;
					image.x = num;
					image.y = 0;
					list.Add(new Rect(image.w, image.h, num, 0f));
					num += image.w;
					num2 = Mathf.Max(num2, image.h);
				}
				else
				{
					image.w -= paddings[i].leftRight * 2;
					image.y = num;
					image.x = 0;
					list.Add(new Rect(image.w, image.h, 0f, num));
					num += image.h;
					num3 = Mathf.Max(num3, image.w);
				}
				list2.Add(image);
			}
			Vector2 rootWH = ((packingOrientation != TexturePackingOrientation.vertical) ? new Vector2(num3, num) : new Vector2(num, num2));
			int outW = (int)rootWH.x;
			int outH = (int)rootWH.y;
			if (packingOrientation != TexturePackingOrientation.vertical)
			{
				outH = ((!atlasMustBePowerOfTwo) ? Mathf.Min(outH, maxDimensionY) : Mathf.Min(MB2_TexturePacker.CeilToNearestPowerOfTwo(outH), maxDimensionY));
			}
			else
			{
				outW = ((!atlasMustBePowerOfTwo) ? Mathf.Min(outW, maxDimensionX) : Mathf.Min(MB2_TexturePacker.CeilToNearestPowerOfTwo(outW), maxDimensionX));
			}
			if (!ScaleAtlasToFitMaxDim(rootWH, list2, maxDimensionX, maxDimensionY, paddings[0], minImageSizeX, minImageSizeY, masterImageSizeX, masterImageSizeY, ref outW, ref outH, out var padX, out var padY, out var _, out var _))
			{
				atlasPackingResult = new AtlasPackingResult(paddings.ToArray());
				atlasPackingResult.rects = new Rect[list2.Count];
				atlasPackingResult.srcImgIdxs = new int[list2.Count];
				atlasPackingResult.atlasX = outW;
				atlasPackingResult.atlasY = outH;
				for (int j = 0; j < list2.Count; j++)
				{
					Image image2 = list2[j];
					Rect rect = ((packingOrientation != TexturePackingOrientation.vertical) ? (atlasPackingResult.rects[j] = new Rect((float)image2.x / (float)outW, (float)image2.y / (float)outH + padY, stretchImagesToEdges ? 1f : ((float)image2.w / (float)outW), (float)image2.h / (float)outH - padY * 2f)) : (atlasPackingResult.rects[j] = new Rect((float)image2.x / (float)outW + padX, (float)image2.y / (float)outH, (float)image2.w / (float)outW - padX * 2f, stretchImagesToEdges ? 1f : ((float)image2.h / (float)outH))));
					atlasPackingResult.srcImgIdxs[j] = image2.imgId;
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug(string.Concat("Image: ", j, " imgID=", image2.imgId, " x=", rect.x * (float)outW, " y=", rect.y * (float)outH, " w=", rect.width * (float)outW, " h=", rect.height * (float)outH, " padding=", paddings[j], " outW=", outW, " outH=", outH));
					}
				}
				atlasPackingResult.CalcUsedWidthAndHeight();
				return atlasPackingResult;
			}
			UnityEngine.Debug.Log("Packing failed returning null atlas result");
			return null;
		}

		private AtlasPackingResult[] _GetRectsMultiAtlasVertical(List<Vector2> imgWidthHeights, List<AtlasPadding> paddings, int maxDimensionPassedX, int maxDimensionPassedY, int minImageSizeX, int minImageSizeY, int masterImageSizeX, int masterImageSizeY)
		{
			List<AtlasPackingResult> list = new List<AtlasPackingResult>();
			int num = 0;
			int num2 = 0;
			int atlasX = 0;
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Packing rects for: " + imgWidthHeights.Count);
			}
			List<Image> list2 = new List<Image>();
			for (int i = 0; i < imgWidthHeights.Count; i++)
			{
				Image image = new Image(i, (int)imgWidthHeights[i].x, (int)imgWidthHeights[i].y, paddings[i], minImageSizeX, minImageSizeY);
				image.h -= paddings[i].topBottom * 2;
				list2.Add(image);
			}
			list2.Sort(new ImageWidthComparer());
			List<Image> list3 = new List<Image>();
			List<Rect> list4 = new List<Rect>();
			int spaceRemaining = maxDimensionPassedX;
			while (list2.Count > 0 || list3.Count > 0)
			{
				Image image2 = PopLargestThatFits(list2, spaceRemaining, maxDimensionPassedX, list3.Count == 0);
				if (image2 == null)
				{
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						UnityEngine.Debug.Log("Atlas filled creating a new atlas ");
					}
					AtlasPackingResult atlasPackingResult = new AtlasPackingResult(paddings.ToArray());
					atlasPackingResult.atlasX = atlasX;
					atlasPackingResult.atlasY = num2;
					Rect[] array = new Rect[list3.Count];
					int[] array2 = new int[list3.Count];
					for (int j = 0; j < list3.Count; j++)
					{
						Rect rect = new Rect(list3[j].x, list3[j].y, list3[j].w, stretchImagesToEdges ? num2 : list3[j].h);
						array[j] = rect;
						array2[j] = list3[j].imgId;
					}
					atlasPackingResult.rects = array;
					atlasPackingResult.srcImgIdxs = array2;
					atlasPackingResult.CalcUsedWidthAndHeight();
					list3.Clear();
					list4.Clear();
					num = 0;
					num2 = 0;
					list.Add(atlasPackingResult);
					spaceRemaining = maxDimensionPassedX;
				}
				else
				{
					image2.x = num;
					image2.y = 0;
					list3.Add(image2);
					list4.Add(new Rect(num, 0f, image2.w, image2.h));
					num += image2.w;
					num2 = Mathf.Max(num2, image2.h);
					atlasX = num;
					spaceRemaining = maxDimensionPassedX - num;
				}
			}
			for (int k = 0; k < list.Count; k++)
			{
				int atlasX2 = list[k].atlasX;
				int outH = Mathf.Min(list[k].atlasY, maxDimensionPassedY);
				atlasX2 = ((!atlasMustBePowerOfTwo) ? Mathf.Min(atlasX2, maxDimensionPassedX) : Mathf.Min(MB2_TexturePacker.CeilToNearestPowerOfTwo(atlasX2), maxDimensionPassedX));
				list[k].atlasX = atlasX2;
				ScaleAtlasToFitMaxDim(new Vector2(list[k].atlasX, list[k].atlasY), list3, maxDimensionPassedX, maxDimensionPassedY, paddings[0], minImageSizeX, minImageSizeY, masterImageSizeX, masterImageSizeY, ref atlasX2, ref outH, out var _, out var _, out var _, out var _);
			}
			for (int l = 0; l < list.Count; l++)
			{
				normalizeRects(list[l], paddings[l]);
				list[l].CalcUsedWidthAndHeight();
			}
			return list.ToArray();
		}

		private AtlasPackingResult[] _GetRectsMultiAtlasHorizontal(List<Vector2> imgWidthHeights, List<AtlasPadding> paddings, int maxDimensionPassedX, int maxDimensionPassedY, int minImageSizeX, int minImageSizeY, int masterImageSizeX, int masterImageSizeY)
		{
			List<AtlasPackingResult> list = new List<AtlasPackingResult>();
			int num = 0;
			int atlasY = 0;
			int num2 = 0;
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Packing rects for: " + imgWidthHeights.Count);
			}
			List<Image> list2 = new List<Image>();
			for (int i = 0; i < imgWidthHeights.Count; i++)
			{
				Image image = new Image(i, (int)imgWidthHeights[i].x, (int)imgWidthHeights[i].y, paddings[i], minImageSizeX, minImageSizeY);
				image.w -= paddings[i].leftRight * 2;
				list2.Add(image);
			}
			list2.Sort(new ImageHeightComparer());
			List<Image> list3 = new List<Image>();
			List<Rect> list4 = new List<Rect>();
			int spaceRemaining = maxDimensionPassedY;
			while (list2.Count > 0 || list3.Count > 0)
			{
				Image image2 = PopLargestThatFits(list2, spaceRemaining, maxDimensionPassedY, list3.Count == 0);
				if (image2 == null)
				{
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						UnityEngine.Debug.Log("Atlas filled creating a new atlas ");
					}
					AtlasPackingResult atlasPackingResult = new AtlasPackingResult(paddings.ToArray());
					atlasPackingResult.atlasX = num2;
					atlasPackingResult.atlasY = atlasY;
					Rect[] array = new Rect[list3.Count];
					int[] array2 = new int[list3.Count];
					for (int j = 0; j < list3.Count; j++)
					{
						Rect rect = new Rect(list3[j].x, list3[j].y, stretchImagesToEdges ? num2 : list3[j].w, list3[j].h);
						array[j] = rect;
						array2[j] = list3[j].imgId;
					}
					atlasPackingResult.rects = array;
					atlasPackingResult.srcImgIdxs = array2;
					list3.Clear();
					list4.Clear();
					num = 0;
					atlasY = 0;
					list.Add(atlasPackingResult);
					spaceRemaining = maxDimensionPassedY;
				}
				else
				{
					image2.x = 0;
					image2.y = num;
					list3.Add(image2);
					list4.Add(new Rect(0f, num, image2.w, image2.h));
					num += image2.h;
					num2 = Mathf.Max(num2, image2.w);
					atlasY = num;
					spaceRemaining = maxDimensionPassedY - num;
				}
			}
			for (int k = 0; k < list.Count; k++)
			{
				int atlasY2 = list[k].atlasY;
				int outW = Mathf.Min(list[k].atlasX, maxDimensionPassedX);
				atlasY2 = ((!atlasMustBePowerOfTwo) ? Mathf.Min(atlasY2, maxDimensionPassedY) : Mathf.Min(MB2_TexturePacker.CeilToNearestPowerOfTwo(atlasY2), maxDimensionPassedY));
				list[k].atlasY = atlasY2;
				ScaleAtlasToFitMaxDim(new Vector2(list[k].atlasX, list[k].atlasY), list3, maxDimensionPassedX, maxDimensionPassedY, paddings[0], minImageSizeX, minImageSizeY, masterImageSizeX, masterImageSizeY, ref outW, ref atlasY2, out var _, out var _, out var _, out var _);
			}
			for (int l = 0; l < list.Count; l++)
			{
				normalizeRects(list[l], paddings[l]);
				list[l].CalcUsedWidthAndHeight();
			}
			return list.ToArray();
		}

		private Image PopLargestThatFits(List<Image> images, int spaceRemaining, int maxDim, bool emptyAtlas)
		{
			if (images.Count == 0)
			{
				return null;
			}
			int num = ((packingOrientation != TexturePackingOrientation.vertical) ? images[0].h : images[0].w);
			if (images.Count > 0 && num >= maxDim)
			{
				if (emptyAtlas)
				{
					Image result = images[0];
					images.RemoveAt(0);
					return result;
				}
				return null;
			}
			int i;
			for (i = 0; i < images.Count; i++)
			{
				if (num < spaceRemaining)
				{
					break;
				}
			}
			if (i < images.Count)
			{
				Image result2 = images[i];
				images.RemoveAt(i);
				return result2;
			}
			return null;
		}
	}
	internal interface MB_ITextureCombinerPacker
	{
		IEnumerator ConvertTexturesToReadableFormats(ProgressUpdateDelegate progressInfo, MB3_TextureCombiner.CombineTexturesIntoAtlasesCoroutineResult result, MB3_TextureCombinerPipeline.TexturePipelineData data, MB3_TextureCombiner combiner, MB2_EditorMethodsInterface textureEditorMethods, MB2_LogLevel LOG_LEVEL);

		AtlasPackingResult[] CalculateAtlasRectangles(MB3_TextureCombinerPipeline.TexturePipelineData data, bool doMultiAtlas, MB2_LogLevel LOG_LEVEL);

		IEnumerator CreateAtlases(ProgressUpdateDelegate progressInfo, MB3_TextureCombinerPipeline.TexturePipelineData data, MB3_TextureCombiner combiner, AtlasPackingResult packedAtlasRects, Texture2D[] atlases, MB2_EditorMethodsInterface textureEditorMethods, MB2_LogLevel LOG_LEVEL);
	}
	internal abstract class MB3_TextureCombinerPackerRoot : MB_ITextureCombinerPacker
	{
		internal static void CreateTemporaryTexturesForAtlas(List<MB_TexSet> distinctMaterialTextures, MB3_TextureCombiner combiner, int propIdx, MB3_TextureCombinerPipeline.TexturePipelineData data)
		{
			for (int i = 0; i < data.distinctMaterialTextures.Count; i++)
			{
				MB_TexSet mB_TexSet = data.distinctMaterialTextures[i];
				if (mB_TexSet.ts[propIdx].isNull)
				{
					UnityEngine.Color colorForTemporaryTexture = data.nonTexturePropertyBlender.GetColorForTemporaryTexture(mB_TexSet.matsAndGOs.mats[0].mat, data.texPropertyNames[propIdx]);
					mB_TexSet.CreateColoredTexToReplaceNull(data.texPropertyNames[propIdx].name, propIdx, data._fixOutOfBoundsUVs, combiner, colorForTemporaryTexture);
				}
			}
		}

		public static AtlasPackingResult[] CalculateAtlasRectanglesStatic(MB3_TextureCombinerPipeline.TexturePipelineData data, bool doMultiAtlas, MB2_LogLevel LOG_LEVEL)
		{
			List<Vector2> list = new List<Vector2>();
			for (int i = 0; i < data.distinctMaterialTextures.Count; i++)
			{
				list.Add(new Vector2(data.distinctMaterialTextures[i].idealWidth, data.distinctMaterialTextures[i].idealHeight));
			}
			MB2_TexturePacker mB2_TexturePacker = MB3_TextureCombinerPipeline.CreateTexturePacker(data._packingAlgorithm);
			mB2_TexturePacker.atlasMustBePowerOfTwo = data._meshBakerTexturePackerForcePowerOfTwo;
			List<AtlasPadding> list2 = new List<AtlasPadding>();
			for (int j = 0; j < list.Count; j++)
			{
				AtlasPadding item = default(AtlasPadding);
				item.topBottom = data._atlasPadding;
				item.leftRight = data._atlasPadding;
				if (data._packingAlgorithm == MB2_PackingAlgorithmEnum.MeshBakerTexturePacker_Horizontal)
				{
					item.leftRight = 0;
				}
				if (data._packingAlgorithm == MB2_PackingAlgorithmEnum.MeshBakerTexturePacker_Vertical)
				{
					item.topBottom = 0;
				}
				list2.Add(item);
			}
			return mB2_TexturePacker.GetRects(list, list2, data._maxAtlasWidth, data._maxAtlasHeight, doMultiAtlas: false);
		}

		public static void MakeProceduralTexturesReadable(ProgressUpdateDelegate progressInfo, MB3_TextureCombiner.CombineTexturesIntoAtlasesCoroutineResult result, MB3_TextureCombinerPipeline.TexturePipelineData data, MB3_TextureCombiner combiner, MB2_EditorMethodsInterface textureEditorMethods, MB2_LogLevel LOG_LEVEL)
		{
			UnityEngine.Debug.LogError("TODO this should be done as close to textures being used as possible due to memory issues.");
		}

		public virtual IEnumerator ConvertTexturesToReadableFormats(ProgressUpdateDelegate progressInfo, MB3_TextureCombiner.CombineTexturesIntoAtlasesCoroutineResult result, MB3_TextureCombinerPipeline.TexturePipelineData data, MB3_TextureCombiner combiner, MB2_EditorMethodsInterface textureEditorMethods, MB2_LogLevel LOG_LEVEL)
		{
			for (int i = 0; i < data.distinctMaterialTextures.Count; i++)
			{
				for (int j = 0; j < data.texPropertyNames.Count; j++)
				{
					MeshBakerMaterialTexture meshBakerMaterialTexture = data.distinctMaterialTextures[i].ts[j];
					if (!meshBakerMaterialTexture.isNull && textureEditorMethods != null)
					{
						Texture texture2D = meshBakerMaterialTexture.GetTexture2D();
						progressInfo?.Invoke($"Convert texture {texture2D} to readable format ", 0.5f);
						textureEditorMethods.AddTextureFormat((Texture2D)texture2D, data.texPropertyNames[j].isNormalMap);
					}
				}
			}
			yield break;
		}

		public virtual AtlasPackingResult[] CalculateAtlasRectangles(MB3_TextureCombinerPipeline.TexturePipelineData data, bool doMultiAtlas, MB2_LogLevel LOG_LEVEL)
		{
			return CalculateAtlasRectanglesStatic(data, doMultiAtlas, LOG_LEVEL);
		}

		public abstract IEnumerator CreateAtlases(ProgressUpdateDelegate progressInfo, MB3_TextureCombinerPipeline.TexturePipelineData data, MB3_TextureCombiner combiner, AtlasPackingResult packedAtlasRects, Texture2D[] atlases, MB2_EditorMethodsInterface textureEditorMethods, MB2_LogLevel LOG_LEVEL);
	}
	[Serializable]
	public class ShaderTextureProperty
	{
		public string name;

		public bool isNormalMap;

		public ShaderTextureProperty(string n, bool norm)
		{
			name = n;
			isNormalMap = norm;
		}

		public override bool Equals(object obj)
		{
			if (!(obj is ShaderTextureProperty))
			{
				return false;
			}
			ShaderTextureProperty shaderTextureProperty = (ShaderTextureProperty)obj;
			if (!name.Equals(shaderTextureProperty.name))
			{
				return false;
			}
			if (isNormalMap != shaderTextureProperty.isNormalMap)
			{
				return false;
			}
			return true;
		}

		public override int GetHashCode()
		{
			return base.GetHashCode();
		}

		public static string[] GetNames(List<ShaderTextureProperty> props)
		{
			string[] array = new string[props.Count];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = props[i].name;
			}
			return array;
		}
	}
	[Serializable]
	public class MB3_TextureCombiner
	{
		private class TemporaryTexture
		{
			internal string property;

			internal Texture2D texture;

			public TemporaryTexture(string prop, Texture2D tex)
			{
				property = prop;
				texture = tex;
			}
		}

		public class CombineTexturesIntoAtlasesCoroutineResult
		{
			public bool success = true;

			public bool isFinished;
		}

		public MB2_LogLevel LOG_LEVEL = MB2_LogLevel.info;

		[SerializeField]
		protected MB2_TextureBakeResults _textureBakeResults;

		[SerializeField]
		protected int _atlasPadding = 1;

		[SerializeField]
		protected int _maxAtlasSize = 1;

		[SerializeField]
		protected int _maxAtlasWidthOverride = 4096;

		[SerializeField]
		protected int _maxAtlasHeightOverride = 4096;

		[SerializeField]
		protected bool _useMaxAtlasWidthOverride;

		[SerializeField]
		protected bool _useMaxAtlasHeightOverride;

		[SerializeField]
		protected bool _resizePowerOfTwoTextures;

		[SerializeField]
		protected bool _fixOutOfBoundsUVs;

		[SerializeField]
		protected int _maxTilingBakeSize = 1024;

		[SerializeField]
		protected bool _saveAtlasesAsAssets;

		[SerializeField]
		protected MB2_PackingAlgorithmEnum _packingAlgorithm;

		[SerializeField]
		protected bool _meshBakerTexturePackerForcePowerOfTwo = true;

		[SerializeField]
		protected List<ShaderTextureProperty> _customShaderPropNames = new List<ShaderTextureProperty>();

		[SerializeField]
		protected bool _normalizeTexelDensity;

		[SerializeField]
		protected bool _considerNonTextureProperties;

		private List<TemporaryTexture> _temporaryTextures = new List<TemporaryTexture>();

		public static bool _RunCorutineWithoutPauseIsRunning;

		public MB2_TextureBakeResults textureBakeResults
		{
			get
			{
				return _textureBakeResults;
			}
			set
			{
				_textureBakeResults = value;
			}
		}

		public int atlasPadding
		{
			get
			{
				return _atlasPadding;
			}
			set
			{
				_atlasPadding = value;
			}
		}

		public int maxAtlasSize
		{
			get
			{
				return _maxAtlasSize;
			}
			set
			{
				_maxAtlasSize = value;
			}
		}

		public virtual int maxAtlasWidthOverride
		{
			get
			{
				return _maxAtlasWidthOverride;
			}
			set
			{
				_maxAtlasWidthOverride = value;
			}
		}

		public virtual int maxAtlasHeightOverride
		{
			get
			{
				return _maxAtlasHeightOverride;
			}
			set
			{
				_maxAtlasHeightOverride = value;
			}
		}

		public virtual bool useMaxAtlasWidthOverride
		{
			get
			{
				return _useMaxAtlasWidthOverride;
			}
			set
			{
				_useMaxAtlasWidthOverride = value;
			}
		}

		public virtual bool useMaxAtlasHeightOverride
		{
			get
			{
				return _useMaxAtlasHeightOverride;
			}
			set
			{
				_useMaxAtlasHeightOverride = value;
			}
		}

		public bool resizePowerOfTwoTextures
		{
			get
			{
				return _resizePowerOfTwoTextures;
			}
			set
			{
				_resizePowerOfTwoTextures = value;
			}
		}

		public bool fixOutOfBoundsUVs
		{
			get
			{
				return _fixOutOfBoundsUVs;
			}
			set
			{
				_fixOutOfBoundsUVs = value;
			}
		}

		public int maxTilingBakeSize
		{
			get
			{
				return _maxTilingBakeSize;
			}
			set
			{
				_maxTilingBakeSize = value;
			}
		}

		public bool saveAtlasesAsAssets
		{
			get
			{
				return _saveAtlasesAsAssets;
			}
			set
			{
				_saveAtlasesAsAssets = value;
			}
		}

		public MB2_PackingAlgorithmEnum packingAlgorithm
		{
			get
			{
				return _packingAlgorithm;
			}
			set
			{
				_packingAlgorithm = value;
			}
		}

		public bool meshBakerTexturePackerForcePowerOfTwo
		{
			get
			{
				return _meshBakerTexturePackerForcePowerOfTwo;
			}
			set
			{
				_meshBakerTexturePackerForcePowerOfTwo = value;
			}
		}

		public List<ShaderTextureProperty> customShaderPropNames
		{
			get
			{
				return _customShaderPropNames;
			}
			set
			{
				_customShaderPropNames = value;
			}
		}

		public bool considerNonTextureProperties
		{
			get
			{
				return _considerNonTextureProperties;
			}
			set
			{
				_considerNonTextureProperties = value;
			}
		}

		public static void RunCorutineWithoutPause(IEnumerator cor, int recursionDepth)
		{
			if (recursionDepth == 0)
			{
				_RunCorutineWithoutPauseIsRunning = true;
			}
			if (recursionDepth > 20)
			{
				UnityEngine.Debug.LogError("Recursion Depth Exceeded.");
				return;
			}
			while (cor.MoveNext())
			{
				object current = cor.Current;
				if (!(current is YieldInstruction) && current != null && current is IEnumerator)
				{
					RunCorutineWithoutPause((IEnumerator)cor.Current, recursionDepth + 1);
				}
			}
			if (recursionDepth == 0)
			{
				_RunCorutineWithoutPauseIsRunning = false;
			}
		}

		public bool CombineTexturesIntoAtlases(ProgressUpdateDelegate progressInfo, MB_AtlasesAndRects resultAtlasesAndRects, Material resultMaterial, List<GameObject> objsToMesh, List<Material> allowedMaterialsFilter, MB2_EditorMethodsInterface textureEditorMethods = null, List<AtlasPackingResult> packingResults = null, bool onlyPackRects = false)
		{
			CombineTexturesIntoAtlasesCoroutineResult combineTexturesIntoAtlasesCoroutineResult = new CombineTexturesIntoAtlasesCoroutineResult();
			RunCorutineWithoutPause(_CombineTexturesIntoAtlases(progressInfo, combineTexturesIntoAtlasesCoroutineResult, resultAtlasesAndRects, resultMaterial, objsToMesh, allowedMaterialsFilter, textureEditorMethods, packingResults, onlyPackRects), 0);
			return combineTexturesIntoAtlasesCoroutineResult.success;
		}

		public IEnumerator CombineTexturesIntoAtlasesCoroutine(ProgressUpdateDelegate progressInfo, MB_AtlasesAndRects resultAtlasesAndRects, Material resultMaterial, List<GameObject> objsToMesh, List<Material> allowedMaterialsFilter, MB2_EditorMethodsInterface textureEditorMethods = null, CombineTexturesIntoAtlasesCoroutineResult coroutineResult = null, float maxTimePerFrame = 0.01f, List<AtlasPackingResult> packingResults = null, bool onlyPackRects = false)
		{
			if (!_RunCorutineWithoutPauseIsRunning && (MBVersion.GetMajorVersion() < 5 || (MBVersion.GetMajorVersion() == 5 && MBVersion.GetMinorVersion() < 3)))
			{
				UnityEngine.Debug.LogError("Running the texture combiner as a coroutine only works in Unity 5.3 and higher");
				yield return null;
			}
			coroutineResult.success = true;
			coroutineResult.isFinished = false;
			if (maxTimePerFrame <= 0f)
			{
				UnityEngine.Debug.LogError("maxTimePerFrame must be a value greater than zero");
				coroutineResult.isFinished = true;
			}
			else
			{
				yield return _CombineTexturesIntoAtlases(progressInfo, coroutineResult, resultAtlasesAndRects, resultMaterial, objsToMesh, allowedMaterialsFilter, textureEditorMethods, packingResults, onlyPackRects);
				coroutineResult.isFinished = true;
			}
		}

		private IEnumerator _CombineTexturesIntoAtlases(ProgressUpdateDelegate progressInfo, CombineTexturesIntoAtlasesCoroutineResult result, MB_AtlasesAndRects resultAtlasesAndRects, Material resultMaterial, List<GameObject> objsToMesh, List<Material> allowedMaterialsFilter, MB2_EditorMethodsInterface textureEditorMethods, List<AtlasPackingResult> atlasPackingResult, bool onlyPackRects)
		{
			Stopwatch sw = new Stopwatch();
			sw.Start();
			try
			{
				_temporaryTextures.Clear();
				MeshBakerMaterialTexture.readyToBuildAtlases = false;
				if (textureEditorMethods != null)
				{
					textureEditorMethods.Clear();
					textureEditorMethods.OnPreTextureBake();
				}
				if (objsToMesh == null || objsToMesh.Count == 0)
				{
					UnityEngine.Debug.LogError("No meshes to combine. Please assign some meshes to combine.");
					result.success = false;
					yield break;
				}
				if (_atlasPadding < 0)
				{
					UnityEngine.Debug.LogError("Atlas padding must be zero or greater.");
					result.success = false;
					yield break;
				}
				if (_maxTilingBakeSize < 2 || _maxTilingBakeSize > 4096)
				{
					UnityEngine.Debug.LogError("Invalid value for max tiling bake size.");
					result.success = false;
					yield break;
				}
				for (int i = 0; i < objsToMesh.Count; i++)
				{
					Material[] gOMaterials = MB_Utility.GetGOMaterials(objsToMesh[i]);
					for (int j = 0; j < gOMaterials.Length; j++)
					{
						if (gOMaterials[j] == null)
						{
							UnityEngine.Debug.LogError(string.Concat("Game object ", objsToMesh[i], " has a null material"));
							result.success = false;
							yield break;
						}
					}
				}
				progressInfo?.Invoke("Collecting textures for " + objsToMesh.Count + " meshes.", 0.01f);
				MB3_TextureCombinerPipeline.TexturePipelineData texturePipelineData = LoadPipelineData(resultMaterial, new List<ShaderTextureProperty>(), objsToMesh, allowedMaterialsFilter, new List<MB_TexSet>());
				if (!MB3_TextureCombinerPipeline._CollectPropertyNames(texturePipelineData, LOG_LEVEL))
				{
					result.success = false;
					yield break;
				}
				if (_fixOutOfBoundsUVs && (_packingAlgorithm == MB2_PackingAlgorithmEnum.MeshBakerTexturePacker_Horizontal || _packingAlgorithm == MB2_PackingAlgorithmEnum.MeshBakerTexturePacker_Vertical) && LOG_LEVEL >= MB2_LogLevel.info)
				{
					UnityEngine.Debug.LogWarning("'Consider Mesh UVs' is enabled but packing algorithm is MeshBakerTexturePacker_Horizontal or MeshBakerTexturePacker_Vertical. It is recommended to use these packers without using 'Consider Mesh UVs'");
				}
				texturePipelineData.nonTexturePropertyBlender.LoadTextureBlendersIfNeeded(texturePipelineData.resultMaterial);
				if (onlyPackRects)
				{
					yield return __RunTexturePacker(result, texturePipelineData, textureEditorMethods, atlasPackingResult);
				}
				else
				{
					yield return __CombineTexturesIntoAtlases(progressInfo, result, resultAtlasesAndRects, texturePipelineData, textureEditorMethods);
				}
			}
			finally
			{
				MB3_TextureCombiner mB3_TextureCombiner = this;
				mB3_TextureCombiner._destroyAllTemporaryTextures();
				mB3_TextureCombiner._restoreProceduralMaterials();
				if (textureEditorMethods != null)
				{
					textureEditorMethods.RestoreReadFlagsAndFormats(progressInfo);
					textureEditorMethods.OnPostTextureBake();
				}
				if (mB3_TextureCombiner.LOG_LEVEL >= MB2_LogLevel.debug)
				{
					UnityEngine.Debug.Log(string.Concat("===== Done creating atlases for ", resultMaterial, " Total time to create atlases ", sw.Elapsed.ToString()));
				}
			}
		}

		private MB3_TextureCombinerPipeline.TexturePipelineData LoadPipelineData(Material resultMaterial, List<ShaderTextureProperty> texPropertyNames, List<GameObject> objsToMesh, List<Material> allowedMaterialsFilter, List<MB_TexSet> distinctMaterialTextures)
		{
			MB3_TextureCombinerPipeline.TexturePipelineData texturePipelineData = new MB3_TextureCombinerPipeline.TexturePipelineData();
			texturePipelineData._textureBakeResults = _textureBakeResults;
			texturePipelineData._atlasPadding = _atlasPadding;
			if (_packingAlgorithm == MB2_PackingAlgorithmEnum.MeshBakerTexturePacker_Vertical && _useMaxAtlasHeightOverride)
			{
				texturePipelineData._maxAtlasHeight = _maxAtlasHeightOverride;
				texturePipelineData._useMaxAtlasHeightOverride = true;
			}
			else
			{
				texturePipelineData._maxAtlasHeight = _maxAtlasSize;
			}
			if (_packingAlgorithm == MB2_PackingAlgorithmEnum.MeshBakerTexturePacker_Horizontal && _useMaxAtlasWidthOverride)
			{
				texturePipelineData._maxAtlasWidth = _maxAtlasWidthOverride;
				texturePipelineData._useMaxAtlasWidthOverride = true;
			}
			else
			{
				texturePipelineData._maxAtlasWidth = _maxAtlasSize;
			}
			texturePipelineData._resizePowerOfTwoTextures = _resizePowerOfTwoTextures;
			texturePipelineData._fixOutOfBoundsUVs = _fixOutOfBoundsUVs;
			texturePipelineData._maxTilingBakeSize = _maxTilingBakeSize;
			texturePipelineData._saveAtlasesAsAssets = _saveAtlasesAsAssets;
			texturePipelineData._packingAlgorithm = _packingAlgorithm;
			texturePipelineData._meshBakerTexturePackerForcePowerOfTwo = _meshBakerTexturePackerForcePowerOfTwo;
			texturePipelineData._customShaderPropNames = _customShaderPropNames;
			texturePipelineData._normalizeTexelDensity = _normalizeTexelDensity;
			texturePipelineData._considerNonTextureProperties = _considerNonTextureProperties;
			texturePipelineData.nonTexturePropertyBlender = new MB3_TextureCombinerNonTextureProperties(LOG_LEVEL, _considerNonTextureProperties);
			texturePipelineData.resultMaterial = resultMaterial;
			texturePipelineData.distinctMaterialTextures = distinctMaterialTextures;
			texturePipelineData.allObjsToMesh = objsToMesh;
			texturePipelineData.allowedMaterialsFilter = allowedMaterialsFilter;
			texturePipelineData.texPropertyNames = texPropertyNames;
			return texturePipelineData;
		}

		private IEnumerator __CombineTexturesIntoAtlases(ProgressUpdateDelegate progressInfo, CombineTexturesIntoAtlasesCoroutineResult result, MB_AtlasesAndRects resultAtlasesAndRects, MB3_TextureCombinerPipeline.TexturePipelineData data, MB2_EditorMethodsInterface textureEditorMethods)
		{
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("__CombineTexturesIntoAtlases texture properties in shader:" + data.texPropertyNames.Count + " objsToMesh:" + data.allObjsToMesh.Count + " _fixOutOfBoundsUVs:" + data._fixOutOfBoundsUVs.ToString());
			}
			progressInfo?.Invoke("Collecting textures ", 0.01f);
			List<GameObject> usedObjsToMesh = new List<GameObject>();
			yield return MB3_TextureCombinerPipeline.__Step1_CollectDistinctMatTexturesAndUsedObjects(progressInfo, result, data, this, textureEditorMethods, usedObjsToMesh, LOG_LEVEL);
			if (!result.success)
			{
				yield break;
			}
			if (MB3_MeshCombiner.EVAL_VERSION)
			{
				bool flag = true;
				for (int i = 0; i < data.distinctMaterialTextures.Count; i++)
				{
					for (int j = 0; j < data.distinctMaterialTextures[i].matsAndGOs.mats.Count; j++)
					{
						if (!data.distinctMaterialTextures[i].matsAndGOs.mats[j].mat.shader.name.EndsWith("Diffuse") && !data.distinctMaterialTextures[i].matsAndGOs.mats[j].mat.shader.name.EndsWith("Bumped Diffuse"))
						{
							UnityEngine.Debug.LogError("The free version of Mesh Baker only works with Diffuse and Bumped Diffuse Shaders. The full version can be used with any shader. Material " + data.distinctMaterialTextures[i].matsAndGOs.mats[j].mat.name + " uses shader " + data.distinctMaterialTextures[i].matsAndGOs.mats[j].mat.shader.name);
							flag = false;
						}
					}
				}
				if (!flag)
				{
					result.success = false;
					yield break;
				}
			}
			yield return MB3_TextureCombinerPipeline.CalculateIdealSizesForTexturesInAtlasAndPadding(progressInfo, result, data, this, textureEditorMethods, LOG_LEVEL);
			if (result.success)
			{
				StringBuilder report = MB3_TextureCombinerPipeline.GenerateReport(data);
				MB_ITextureCombinerPacker texturePaker = MB3_TextureCombinerPipeline.CreatePacker(data.OnlyOneTextureInAtlasReuseTextures(), data._packingAlgorithm);
				yield return texturePaker.ConvertTexturesToReadableFormats(progressInfo, result, data, this, textureEditorMethods, LOG_LEVEL);
				if (result.success)
				{
					AtlasPackingResult[] array = texturePaker.CalculateAtlasRectangles(data, doMultiAtlas: false, LOG_LEVEL);
					yield return MB3_TextureCombinerPipeline.__Step3_BuildAndSaveAtlasesAndStoreResults(result, progressInfo, data, this, texturePaker, array[0], textureEditorMethods, resultAtlasesAndRects, report, LOG_LEVEL);
				}
			}
		}

		private IEnumerator __RunTexturePacker(CombineTexturesIntoAtlasesCoroutineResult result, MB3_TextureCombinerPipeline.TexturePipelineData data, MB2_EditorMethodsInterface textureEditorMethods, List<AtlasPackingResult> packingResult)
		{
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("__RunTexturePacker texture properties in shader:" + data.texPropertyNames.Count + " objsToMesh:" + data.allObjsToMesh.Count + " _fixOutOfBoundsUVs:" + data._fixOutOfBoundsUVs.ToString());
			}
			List<GameObject> usedObjsToMesh = new List<GameObject>();
			yield return MB3_TextureCombinerPipeline.__Step1_CollectDistinctMatTexturesAndUsedObjects(null, result, data, this, textureEditorMethods, usedObjsToMesh, LOG_LEVEL);
			if (!result.success)
			{
				yield break;
			}
			data.allTexturesAreNullAndSameColor = new MB3_TextureCombinerPipeline.CreateAtlasForProperty[data.texPropertyNames.Count];
			yield return MB3_TextureCombinerPipeline.CalculateIdealSizesForTexturesInAtlasAndPadding(null, result, data, this, textureEditorMethods, LOG_LEVEL);
			if (result.success)
			{
				MB_ITextureCombinerPacker texturePacker = MB3_TextureCombinerPipeline.CreatePacker(data.OnlyOneTextureInAtlasReuseTextures(), data._packingAlgorithm);
				AtlasPackingResult[] array = MB3_TextureCombinerPipeline.__Step3_RunTexturePacker(data, texturePacker, LOG_LEVEL);
				for (int i = 0; i < array.Length; i++)
				{
					packingResult.Add(array[i]);
				}
			}
		}

		internal int _getNumTemporaryTextures()
		{
			return _temporaryTextures.Count;
		}

		public Texture2D _createTemporaryTexture(string propertyName, int w, int h, TextureFormat texFormat, bool mipMaps)
		{
			Texture2D texture2D = new Texture2D(w, h, texFormat, mipMaps);
			texture2D.name = $"tmp{_temporaryTextures.Count}_{w}x{h}";
			MB_Utility.setSolidColor(texture2D, UnityEngine.Color.clear);
			TemporaryTexture item = new TemporaryTexture(propertyName, texture2D);
			_temporaryTextures.Add(item);
			return texture2D;
		}

		internal Texture2D _createTextureCopy(string propertyName, Texture2D t)
		{
			Texture2D texture2D = MB_Utility.createTextureCopy(t);
			texture2D.name = $"tmpCopy{_temporaryTextures.Count}_{texture2D.width}x{texture2D.height}";
			TemporaryTexture item = new TemporaryTexture(propertyName, texture2D);
			_temporaryTextures.Add(item);
			return texture2D;
		}

		internal Texture2D _resizeTexture(string propertyName, Texture2D t, int w, int h)
		{
			Texture2D texture2D = MB_Utility.resampleTexture(t, w, h);
			texture2D.name = $"tmpResampled{_temporaryTextures.Count}_{w}x{h}";
			TemporaryTexture item = new TemporaryTexture(propertyName, texture2D);
			_temporaryTextures.Add(item);
			return texture2D;
		}

		internal void _destroyAllTemporaryTextures()
		{
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Destroying " + _temporaryTextures.Count + " temporary textures");
			}
			for (int i = 0; i < _temporaryTextures.Count; i++)
			{
				MB_Utility.Destroy(_temporaryTextures[i].texture);
			}
			_temporaryTextures.Clear();
		}

		internal void _destroyTemporaryTextures(string propertyName)
		{
			int num = 0;
			for (int num2 = _temporaryTextures.Count - 1; num2 >= 0; num2--)
			{
				if (_temporaryTextures[num2].property.Equals(propertyName))
				{
					num++;
					MB_Utility.Destroy(_temporaryTextures[num2].texture);
					_temporaryTextures.RemoveAt(num2);
				}
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Destroying " + num + " temporary textures " + propertyName + " num remaining " + _temporaryTextures.Count);
			}
		}

		public void _restoreProceduralMaterials()
		{
		}

		public void SuggestTreatment(List<GameObject> objsToMesh, Material[] resultMaterials, List<ShaderTextureProperty> _customShaderPropNames)
		{
			this._customShaderPropNames = _customShaderPropNames;
			StringBuilder stringBuilder = new StringBuilder();
			Dictionary<int, MB_Utility.MeshAnalysisResult[]> dictionary = new Dictionary<int, MB_Utility.MeshAnalysisResult[]>();
			for (int i = 0; i < objsToMesh.Count; i++)
			{
				GameObject gameObject = objsToMesh[i];
				if (gameObject == null)
				{
					continue;
				}
				Material[] gOMaterials = MB_Utility.GetGOMaterials(objsToMesh[i]);
				if (gOMaterials.Length > 1)
				{
					stringBuilder.AppendFormat("\nObject {0} uses {1} materials. Possible treatments:\n", objsToMesh[i].name, gOMaterials.Length);
					stringBuilder.AppendFormat("  1) Collapse the submeshes together into one submesh in the combined mesh. Each of the original submesh materials will map to a different UV rectangle in the atlas(es) used by the combined material.\n");
					stringBuilder.AppendFormat("  2) Use the multiple materials feature to map submeshes in the source mesh to submeshes in the combined mesh.\n");
				}
				Mesh mesh = MB_Utility.GetMesh(gameObject);
				if (!dictionary.TryGetValue(mesh.GetInstanceID(), out var value))
				{
					value = new MB_Utility.MeshAnalysisResult[mesh.subMeshCount];
					MB_Utility.doSubmeshesShareVertsOrTris(mesh, ref value[0]);
					for (int j = 0; j < mesh.subMeshCount; j++)
					{
						MB_Utility.hasOutOfBoundsUVs(mesh, ref value[j], j);
						value[j].hasOverlappingSubmeshTris = value[0].hasOverlappingSubmeshTris;
						value[j].hasOverlappingSubmeshVerts = value[0].hasOverlappingSubmeshVerts;
					}
					dictionary.Add(mesh.GetInstanceID(), value);
				}
				for (int k = 0; k < gOMaterials.Length; k++)
				{
					if (value[k].hasOutOfBoundsUVs)
					{
						DRect dRect = new DRect(value[k].uvRect);
						stringBuilder.AppendFormat("\nObject {0} submesh={1} material={2} uses UVs outside the range 0,0 .. 1,1 to create tiling that tiles the box {3},{4} .. {5},{6}. This is a problem because the UVs outside the 0,0 .. 1,1 rectangle will pick up neighboring textures in the atlas. Possible Treatments:\n", gameObject, k, gOMaterials[k], dRect.x.ToString("G4"), dRect.y.ToString("G4"), (dRect.x + dRect.width).ToString("G4"), (dRect.y + dRect.height).ToString("G4"));
						stringBuilder.AppendFormat("    1) Ignore the problem. The tiling may not affect result significantly.\n");
						stringBuilder.AppendFormat("    2) Use the 'fix out of bounds UVs' feature to bake the tiling and scale the UVs to fit in the 0,0 .. 1,1 rectangle.\n");
						stringBuilder.AppendFormat("    3) Use the Multiple Materials feature to map the material on this submesh to its own submesh in the combined mesh. No other materials should map to this submesh. This will result in only one texture in the atlas(es) and the UVs should tile correctly.\n");
						stringBuilder.AppendFormat("    4) Combine only meshes that use the same (or subset of) the set of materials on this mesh. The original material(s) can be applied to the result\n");
					}
				}
				if (value[0].hasOverlappingSubmeshVerts)
				{
					stringBuilder.AppendFormat("\nObject {0} has submeshes that share vertices. This is a problem because each vertex can have only one UV coordinate and may be required to map to different positions in the various atlases that are generated. Possible treatments:\n", objsToMesh[i]);
					stringBuilder.AppendFormat(" 1) Ignore the problem. The vertices may not affect the result.\n");
					stringBuilder.AppendFormat(" 2) Use the Multiple Materials feature to map the submeshs that overlap to their own submeshs in the combined mesh. No other materials should map to this submesh. This will result in only one texture in the atlas(es) and the UVs should tile correctly.\n");
					stringBuilder.AppendFormat(" 3) Combine only meshes that use the same (or subset of) the set of materials on this mesh. The original material(s) can be applied to the result\n");
				}
			}
			Dictionary<Material, List<GameObject>> dictionary2 = new Dictionary<Material, List<GameObject>>();
			for (int l = 0; l < objsToMesh.Count; l++)
			{
				if (!(objsToMesh[l] != null))
				{
					continue;
				}
				Material[] gOMaterials2 = MB_Utility.GetGOMaterials(objsToMesh[l]);
				for (int m = 0; m < gOMaterials2.Length; m++)
				{
					if (gOMaterials2[m] != null)
					{
						if (!dictionary2.TryGetValue(gOMaterials2[m], out var value2))
						{
							value2 = new List<GameObject>();
							dictionary2.Add(gOMaterials2[m], value2);
						}
						if (!value2.Contains(objsToMesh[l]))
						{
							value2.Add(objsToMesh[l]);
						}
					}
				}
			}
			for (int n = 0; n < resultMaterials.Length; n++)
			{
				string shaderName = ((resultMaterials[n] != null) ? "None" : resultMaterials[n].shader.name);
				MB3_TextureCombinerPipeline.TexturePipelineData texturePipelineData = LoadPipelineData(resultMaterials[n], new List<ShaderTextureProperty>(), objsToMesh, new List<Material>(), new List<MB_TexSet>());
				MB3_TextureCombinerPipeline._CollectPropertyNames(texturePipelineData, LOG_LEVEL);
				foreach (Material key in dictionary2.Keys)
				{
					for (int num = 0; num < texturePipelineData.texPropertyNames.Count; num++)
					{
						if (!key.HasProperty(texturePipelineData.texPropertyNames[num].name))
						{
							continue;
						}
						Texture textureConsideringStandardShaderKeywords = MB3_TextureCombinerPipeline.GetTextureConsideringStandardShaderKeywords(shaderName, key, texturePipelineData.texPropertyNames[num].name);
						if (textureConsideringStandardShaderKeywords != null)
						{
							Vector2 textureOffset = key.GetTextureOffset(texturePipelineData.texPropertyNames[num].name);
							Vector3 vector = key.GetTextureScale(texturePipelineData.texPropertyNames[num].name);
							if (textureOffset.x < 0f || textureOffset.x + vector.x > 1f || textureOffset.y < 0f || textureOffset.y + vector.y > 1f)
							{
								stringBuilder.AppendFormat("\nMaterial {0} used by objects {1} uses texture {2} that is tiled (scale={3} offset={4}). If there is more than one texture in the atlas  then Mesh Baker will bake the tiling into the atlas. If the baked tiling is large then quality can be lost. Possible treatments:\n", key, PrintList(dictionary2[key]), textureConsideringStandardShaderKeywords, vector, textureOffset);
								stringBuilder.AppendFormat("  1) Use the baked tiling.\n");
								stringBuilder.AppendFormat("  2) Use the Multiple Materials feature to map the material on this object/submesh to its own submesh in the combined mesh. No other materials should map to this submesh. The original material can be applied to this submesh.\n");
								stringBuilder.AppendFormat("  3) Combine only meshes that use the same (or subset of) the set of textures on this mesh. The original material can be applied to the result.\n");
							}
						}
					}
				}
			}
			string text = "";
			text = ((stringBuilder.Length != 0) ? ("====== There are possible problems with these meshes that may prevent them from combining well. TREATMENT SUGGESTIONS (copy and paste to text editor if too big) =====\n" + stringBuilder.ToString()) : "====== No problems detected. These meshes should combine well ====\n  If there are problems with the combined meshes please report the problem to digitalOpus.ca so we can improve Mesh Baker.");
			UnityEngine.Debug.Log(text);
		}

		private string PrintList(List<GameObject> gos)
		{
			StringBuilder stringBuilder = new StringBuilder();
			for (int i = 0; i < gos.Count; i++)
			{
				stringBuilder.Append(string.Concat(gos[i], ","));
			}
			return stringBuilder.ToString();
		}
	}
	public class MeshBakerMaterialTexture
	{
		private Texture2D _t;

		public float texelDensity;

		internal static bool readyToBuildAtlases;

		private DRect encapsulatingSamplingRect;

		public Texture2D t
		{
			set
			{
				_t = value;
			}
		}

		public DRect matTilingRect { get; private set; }

		public bool isNull => _t == null;

		public int width
		{
			get
			{
				if (_t != null)
				{
					return _t.width;
				}
				throw new Exception("Texture was null. can't get width");
			}
		}

		public int height
		{
			get
			{
				if (_t != null)
				{
					return _t.height;
				}
				throw new Exception("Texture was null. can't get height");
			}
		}

		public MeshBakerMaterialTexture()
		{
		}

		public MeshBakerMaterialTexture(Texture tx)
		{
			if (tx is Texture2D)
			{
				_t = (Texture2D)tx;
			}
			else if (!(tx == null))
			{
				UnityEngine.Debug.LogError("An error occured. Texture must be Texture2D " + tx);
			}
		}

		public MeshBakerMaterialTexture(Texture tx, Vector2 matTilingOffset, Vector2 matTilingScale, float texelDens)
		{
			if (tx is Texture2D)
			{
				_t = (Texture2D)tx;
			}
			else if (!(tx == null))
			{
				UnityEngine.Debug.LogError("An error occured. Texture must be Texture2D " + tx);
			}
			matTilingRect = new DRect(matTilingOffset, matTilingScale);
			texelDensity = texelDens;
		}

		public DRect GetEncapsulatingSamplingRect()
		{
			return encapsulatingSamplingRect;
		}

		public void SetEncapsulatingSamplingRect(MB_TexSet ts, DRect r)
		{
			encapsulatingSamplingRect = r;
		}

		public Texture2D GetTexture2D()
		{
			if (!readyToBuildAtlases)
			{
				UnityEngine.Debug.LogError("This function should not be called before Step3. For steps 1 and 2 should always call methods like isNull, width, height");
				throw new Exception("GetTexture2D called before ready to build atlases");
			}
			return _t;
		}

		public string GetTexName()
		{
			if (_t != null)
			{
				return _t.name;
			}
			return "null";
		}

		public bool AreTexturesEqual(MeshBakerMaterialTexture b)
		{
			if (_t == b._t)
			{
				return true;
			}
			return false;
		}
	}
	public class MatAndTransformToMerged
	{
		public Material mat;

		public string objName;

		public DRect obUVRectIfTilingSame { get; private set; }

		public DRect samplingRectMatAndUVTiling { get; private set; }

		public DRect materialTiling { get; private set; }

		public MatAndTransformToMerged(DRect obUVrect, bool fixOutOfBoundsUVs)
		{
			_init(obUVrect, fixOutOfBoundsUVs, null);
		}

		public MatAndTransformToMerged(DRect obUVrect, bool fixOutOfBoundsUVs, Material m)
		{
			_init(obUVrect, fixOutOfBoundsUVs, m);
		}

		private void _init(DRect obUVrect, bool fixOutOfBoundsUVs, Material m)
		{
			if (fixOutOfBoundsUVs)
			{
				obUVRectIfTilingSame = obUVrect;
			}
			else
			{
				obUVRectIfTilingSame = new DRect(0f, 0f, 1f, 1f);
			}
			mat = m;
		}

		public override bool Equals(object obj)
		{
			if (obj is MatAndTransformToMerged)
			{
				MatAndTransformToMerged matAndTransformToMerged = (MatAndTransformToMerged)obj;
				if (matAndTransformToMerged.mat == mat && matAndTransformToMerged.obUVRectIfTilingSame == obUVRectIfTilingSame)
				{
					return true;
				}
			}
			return false;
		}

		public override int GetHashCode()
		{
			return mat.GetHashCode() ^ obUVRectIfTilingSame.GetHashCode() ^ samplingRectMatAndUVTiling.GetHashCode();
		}

		public string GetMaterialName()
		{
			if (mat != null)
			{
				return mat.name;
			}
			if (objName != null)
			{
				return $"[matFor: {objName}]";
			}
			return "Unknown";
		}

		public void AssignInitialValuesForMaterialTilingAndSamplingRectMatAndUVTiling(bool allTexturesUseSameMatTiling, DRect matTiling)
		{
			if (allTexturesUseSameMatTiling)
			{
				materialTiling = matTiling;
			}
			else
			{
				materialTiling = new DRect(0f, 0f, 1f, 1f);
			}
			DRect r = materialTiling;
			DRect r2 = obUVRectIfTilingSame;
			samplingRectMatAndUVTiling = MB3_UVTransformUtility.CombineTransforms(ref r2, ref r);
		}
	}
	public class MatsAndGOs
	{
		public List<MatAndTransformToMerged> mats;

		public List<GameObject> gos;
	}
	public class MB_TexSet
	{
		private interface PipelineVariation
		{
			void GetRectsForTextureBakeResults(out Rect allPropsUseSameTiling_encapsulatingSamplingRect, out Rect propsUseDifferntTiling_obUVRect);

			void SetTilingTreatmentAndAdjustEncapsulatingSamplingRect(MB_TextureTilingTreatment newTilingTreatment);

			Rect GetMaterialTilingRectForTextureBakerResults(int materialIndex);

			void AdjustResultMaterialNonTextureProperties(Material resultMaterial, List<ShaderTextureProperty> props);
		}

		private class PipelineVariationAllTexturesUseSameMatTiling : PipelineVariation
		{
			private MB_TexSet texSet;

			public PipelineVariationAllTexturesUseSameMatTiling(MB_TexSet ts)
			{
				texSet = ts;
			}

			public void GetRectsForTextureBakeResults(out Rect allPropsUseSameTiling_encapsulatingSamplingRect, out Rect propsUseDifferntTiling_obUVRect)
			{
				propsUseDifferntTiling_obUVRect = new Rect(0f, 0f, 0f, 0f);
				allPropsUseSameTiling_encapsulatingSamplingRect = texSet.GetEncapsulatingSamplingRectIfTilingSame();
				if (texSet.tilingTreatment == MB_TextureTilingTreatment.edgeToEdgeX)
				{
					allPropsUseSameTiling_encapsulatingSamplingRect.x = 0f;
					allPropsUseSameTiling_encapsulatingSamplingRect.width = 1f;
				}
				else if (texSet.tilingTreatment == MB_TextureTilingTreatment.edgeToEdgeY)
				{
					allPropsUseSameTiling_encapsulatingSamplingRect.y = 0f;
					allPropsUseSameTiling_encapsulatingSamplingRect.height = 1f;
				}
				else if (texSet.tilingTreatment == MB_TextureTilingTreatment.edgeToEdgeXY)
				{
					allPropsUseSameTiling_encapsulatingSamplingRect = new Rect(0f, 0f, 1f, 1f);
				}
			}

			public void SetTilingTreatmentAndAdjustEncapsulatingSamplingRect(MB_TextureTilingTreatment newTilingTreatment)
			{
				if (texSet.tilingTreatment == MB_TextureTilingTreatment.edgeToEdgeX)
				{
					MeshBakerMaterialTexture[] ts = texSet.ts;
					foreach (MeshBakerMaterialTexture obj in ts)
					{
						DRect encapsulatingSamplingRect = obj.GetEncapsulatingSamplingRect();
						encapsulatingSamplingRect.width = 1.0;
						obj.SetEncapsulatingSamplingRect(texSet, encapsulatingSamplingRect);
					}
				}
				else if (texSet.tilingTreatment == MB_TextureTilingTreatment.edgeToEdgeY)
				{
					MeshBakerMaterialTexture[] ts = texSet.ts;
					foreach (MeshBakerMaterialTexture obj2 in ts)
					{
						DRect encapsulatingSamplingRect2 = obj2.GetEncapsulatingSamplingRect();
						encapsulatingSamplingRect2.height = 1.0;
						obj2.SetEncapsulatingSamplingRect(texSet, encapsulatingSamplingRect2);
					}
				}
				else if (texSet.tilingTreatment == MB_TextureTilingTreatment.edgeToEdgeXY)
				{
					MeshBakerMaterialTexture[] ts = texSet.ts;
					foreach (MeshBakerMaterialTexture obj3 in ts)
					{
						DRect encapsulatingSamplingRect3 = obj3.GetEncapsulatingSamplingRect();
						encapsulatingSamplingRect3.height = 1.0;
						encapsulatingSamplingRect3.width = 1.0;
						obj3.SetEncapsulatingSamplingRect(texSet, encapsulatingSamplingRect3);
					}
				}
			}

			public Rect GetMaterialTilingRectForTextureBakerResults(int materialIndex)
			{
				return texSet.matsAndGOs.mats[materialIndex].materialTiling.GetRect();
			}

			public void AdjustResultMaterialNonTextureProperties(Material resultMaterial, List<ShaderTextureProperty> props)
			{
			}
		}

		private class PipelineVariationSomeTexturesUseDifferentMatTiling : PipelineVariation
		{
			private MB_TexSet texSet;

			public PipelineVariationSomeTexturesUseDifferentMatTiling(MB_TexSet ts)
			{
				texSet = ts;
			}

			public void GetRectsForTextureBakeResults(out Rect allPropsUseSameTiling_encapsulatingSamplingRect, out Rect propsUseDifferntTiling_obUVRect)
			{
				allPropsUseSameTiling_encapsulatingSamplingRect = new Rect(0f, 0f, 0f, 0f);
				propsUseDifferntTiling_obUVRect = texSet.obUVrect.GetRect();
				if (texSet.tilingTreatment == MB_TextureTilingTreatment.edgeToEdgeX)
				{
					propsUseDifferntTiling_obUVRect.x = 0f;
					propsUseDifferntTiling_obUVRect.width = 1f;
				}
				else if (texSet.tilingTreatment == MB_TextureTilingTreatment.edgeToEdgeY)
				{
					propsUseDifferntTiling_obUVRect.y = 0f;
					propsUseDifferntTiling_obUVRect.height = 1f;
				}
				else if (texSet.tilingTreatment == MB_TextureTilingTreatment.edgeToEdgeXY)
				{
					propsUseDifferntTiling_obUVRect = new Rect(0f, 0f, 1f, 1f);
				}
			}

			public void SetTilingTreatmentAndAdjustEncapsulatingSamplingRect(MB_TextureTilingTreatment newTilingTreatment)
			{
				if (texSet.tilingTreatment == MB_TextureTilingTreatment.edgeToEdgeX)
				{
					MeshBakerMaterialTexture[] ts = texSet.ts;
					foreach (MeshBakerMaterialTexture obj in ts)
					{
						DRect encapsulatingSamplingRect = obj.GetEncapsulatingSamplingRect();
						encapsulatingSamplingRect.width = 1.0;
						obj.SetEncapsulatingSamplingRect(texSet, encapsulatingSamplingRect);
					}
				}
				else if (texSet.tilingTreatment == MB_TextureTilingTreatment.edgeToEdgeY)
				{
					MeshBakerMaterialTexture[] ts = texSet.ts;
					foreach (MeshBakerMaterialTexture obj2 in ts)
					{
						DRect encapsulatingSamplingRect2 = obj2.GetEncapsulatingSamplingRect();
						encapsulatingSamplingRect2.height = 1.0;
						obj2.SetEncapsulatingSamplingRect(texSet, encapsulatingSamplingRect2);
					}
				}
				else if (texSet.tilingTreatment == MB_TextureTilingTreatment.edgeToEdgeXY)
				{
					MeshBakerMaterialTexture[] ts = texSet.ts;
					foreach (MeshBakerMaterialTexture obj3 in ts)
					{
						DRect encapsulatingSamplingRect3 = obj3.GetEncapsulatingSamplingRect();
						encapsulatingSamplingRect3.height = 1.0;
						encapsulatingSamplingRect3.width = 1.0;
						obj3.SetEncapsulatingSamplingRect(texSet, encapsulatingSamplingRect3);
					}
				}
			}

			public Rect GetMaterialTilingRectForTextureBakerResults(int materialIndex)
			{
				return new Rect(0f, 0f, 0f, 0f);
			}

			public void AdjustResultMaterialNonTextureProperties(Material resultMaterial, List<ShaderTextureProperty> props)
			{
				if (!texSet.thisIsOnlyTexSetInAtlas)
				{
					return;
				}
				for (int i = 0; i < props.Count; i++)
				{
					if (resultMaterial.HasProperty(props[i].name))
					{
						resultMaterial.SetTextureOffset(props[i].name, texSet.ts[i].matTilingRect.min);
						resultMaterial.SetTextureScale(props[i].name, texSet.ts[i].matTilingRect.size);
					}
				}
			}
		}

		public MeshBakerMaterialTexture[] ts;

		public MatsAndGOs matsAndGOs;

		public int idealWidth;

		public int idealHeight;

		private PipelineVariation pipelineVariation;

		public bool allTexturesUseSameMatTiling { get; private set; }

		public bool thisIsOnlyTexSetInAtlas { get; private set; }

		public MB_TextureTilingTreatment tilingTreatment { get; private set; }

		public Vector2 obUVoffset { get; private set; }

		public Vector2 obUVscale { get; private set; }

		internal DRect obUVrect => new DRect(obUVoffset, obUVscale);

		public MB_TexSet(MeshBakerMaterialTexture[] tss, Vector2 uvOffset, Vector2 uvScale, MB_TextureTilingTreatment treatment)
		{
			ts = tss;
			tilingTreatment = treatment;
			obUVoffset = uvOffset;
			obUVscale = uvScale;
			allTexturesUseSameMatTiling = false;
			thisIsOnlyTexSetInAtlas = false;
			matsAndGOs = new MatsAndGOs();
			matsAndGOs.mats = new List<MatAndTransformToMerged>();
			matsAndGOs.gos = new List<GameObject>();
			pipelineVariation = new PipelineVariationSomeTexturesUseDifferentMatTiling(this);
		}

		internal bool IsEqual(object obj, bool fixOutOfBoundsUVs, MB3_TextureCombinerNonTextureProperties resultMaterialTextureBlender)
		{
			if (!(obj is MB_TexSet))
			{
				return false;
			}
			MB_TexSet mB_TexSet = (MB_TexSet)obj;
			if (mB_TexSet.ts.Length != ts.Length)
			{
				return false;
			}
			for (int i = 0; i < ts.Length; i++)
			{
				if (ts[i].matTilingRect != mB_TexSet.ts[i].matTilingRect)
				{
					return false;
				}
				if (!ts[i].AreTexturesEqual(mB_TexSet.ts[i]))
				{
					return false;
				}
				if (!resultMaterialTextureBlender.NonTexturePropertiesAreEqual(matsAndGOs.mats[0].mat, mB_TexSet.matsAndGOs.mats[0].mat))
				{
					return false;
				}
			}
			if (fixOutOfBoundsUVs && (obUVoffset.x != mB_TexSet.obUVoffset.x || obUVoffset.y != mB_TexSet.obUVoffset.y))
			{
				return false;
			}
			if (fixOutOfBoundsUVs && (obUVscale.x != mB_TexSet.obUVscale.x || obUVscale.y != mB_TexSet.obUVscale.y))
			{
				return false;
			}
			return true;
		}

		public Vector2 GetMaxRawTextureHeightWidth()
		{
			Vector2 result = new Vector2(0f, 0f);
			for (int i = 0; i < ts.Length; i++)
			{
				MeshBakerMaterialTexture meshBakerMaterialTexture = ts[i];
				if (!meshBakerMaterialTexture.isNull)
				{
					result.x = Mathf.Max(result.x, meshBakerMaterialTexture.width);
					result.y = Mathf.Max(result.y, meshBakerMaterialTexture.height);
				}
			}
			return result;
		}

		private Rect GetEncapsulatingSamplingRectIfTilingSame()
		{
			if (ts.Length != 0)
			{
				return ts[0].GetEncapsulatingSamplingRect().GetRect();
			}
			return new Rect(0f, 0f, 1f, 1f);
		}

		public void SetEncapsulatingSamplingRectWhenMergingTexSets(DRect newEncapsulatingSamplingRect)
		{
			for (int i = 0; i < ts.Length; i++)
			{
				ts[i].SetEncapsulatingSamplingRect(this, newEncapsulatingSamplingRect);
			}
		}

		public void SetEncapsulatingSamplingRectForTesting(int propIdx, DRect newEncapsulatingSamplingRect)
		{
			ts[propIdx].SetEncapsulatingSamplingRect(this, newEncapsulatingSamplingRect);
		}

		public void SetEncapsulatingRect(int propIdx, bool considerMeshUVs)
		{
			if (considerMeshUVs)
			{
				ts[propIdx].SetEncapsulatingSamplingRect(this, obUVrect);
			}
			else
			{
				ts[propIdx].SetEncapsulatingSamplingRect(this, new DRect(0f, 0f, 1f, 1f));
			}
		}

		public void CreateColoredTexToReplaceNull(string propName, int propIdx, bool considerMeshUVs, MB3_TextureCombiner combiner, UnityEngine.Color col)
		{
			MeshBakerMaterialTexture obj = ts[propIdx];
			obj.t = combiner._createTemporaryTexture(propName, 16, 16, TextureFormat.ARGB32, mipMaps: true);
			MB_Utility.setSolidColor(obj.GetTexture2D(), col);
		}

		public void SetThisIsOnlyTexSetInAtlasTrue()
		{
			thisIsOnlyTexSetInAtlas = true;
		}

		public void SetAllTexturesUseSameMatTilingTrue()
		{
			allTexturesUseSameMatTiling = true;
			pipelineVariation = new PipelineVariationAllTexturesUseSameMatTiling(this);
		}

		public void AdjustResultMaterialNonTextureProperties(Material resultMaterial, List<ShaderTextureProperty> props)
		{
			pipelineVariation.AdjustResultMaterialNonTextureProperties(resultMaterial, props);
		}

		public void SetTilingTreatmentAndAdjustEncapsulatingSamplingRect(MB_TextureTilingTreatment newTilingTreatment)
		{
			tilingTreatment = newTilingTreatment;
			pipelineVariation.SetTilingTreatmentAndAdjustEncapsulatingSamplingRect(newTilingTreatment);
		}

		internal void GetRectsForTextureBakeResults(out Rect allPropsUseSameTiling_encapsulatingSamplingRect, out Rect propsUseDifferntTiling_obUVRect)
		{
			pipelineVariation.GetRectsForTextureBakeResults(out allPropsUseSameTiling_encapsulatingSamplingRect, out propsUseDifferntTiling_obUVRect);
		}

		internal Rect GetMaterialTilingRectForTextureBakerResults(int materialIndex)
		{
			return pipelineVariation.GetMaterialTilingRectForTextureBakerResults(materialIndex);
		}

		internal void CalcInitialFullSamplingRects(bool fixOutOfBoundsUVs)
		{
			DRect r = new DRect(0f, 0f, 1f, 1f);
			if (fixOutOfBoundsUVs)
			{
				r = obUVrect;
			}
			for (int i = 0; i < ts.Length; i++)
			{
				if (!ts[i].isNull)
				{
					DRect r2 = ts[i].matTilingRect;
					DRect r3 = ((!fixOutOfBoundsUVs) ? new DRect(0.0, 0.0, 1.0, 1.0) : obUVrect);
					ts[i].SetEncapsulatingSamplingRect(this, MB3_UVTransformUtility.CombineTransforms(ref r3, ref r2));
					r = ts[i].GetEncapsulatingSamplingRect();
				}
			}
			for (int j = 0; j < ts.Length; j++)
			{
				if (ts[j].isNull)
				{
					ts[j].SetEncapsulatingSamplingRect(this, r);
				}
			}
		}

		internal void CalcMatAndUVSamplingRects()
		{
			DRect matTiling = new DRect(0f, 0f, 1f, 1f);
			if (allTexturesUseSameMatTiling)
			{
				for (int i = 0; i < ts.Length; i++)
				{
					if (!ts[i].isNull)
					{
						matTiling = ts[i].matTilingRect;
						break;
					}
				}
			}
			for (int j = 0; j < matsAndGOs.mats.Count; j++)
			{
				matsAndGOs.mats[j].AssignInitialValuesForMaterialTilingAndSamplingRectMatAndUVTiling(allTexturesUseSameMatTiling, matTiling);
			}
		}

		public bool AllTexturesAreSameForMerge(MB_TexSet other, bool considerNonTextureProperties, MB3_TextureCombinerNonTextureProperties resultMaterialTextureBlender)
		{
			if (other.ts.Length != ts.Length)
			{
				return false;
			}
			if (!other.allTexturesUseSameMatTiling || !allTexturesUseSameMatTiling)
			{
				return false;
			}
			int num = -1;
			for (int i = 0; i < ts.Length; i++)
			{
				if (!ts[i].AreTexturesEqual(other.ts[i]))
				{
					return false;
				}
				if (num == -1 && !ts[i].isNull)
				{
					num = i;
				}
				if (considerNonTextureProperties && !resultMaterialTextureBlender.NonTexturePropertiesAreEqual(matsAndGOs.mats[0].mat, other.matsAndGOs.mats[0].mat))
				{
					return false;
				}
			}
			if (num != -1)
			{
				for (int j = 0; j < ts.Length; j++)
				{
					if (!ts[j].AreTexturesEqual(other.ts[j]))
					{
						return false;
					}
				}
			}
			return true;
		}

		internal void DrawRectsToMergeGizmos(UnityEngine.Color encC, UnityEngine.Color innerC)
		{
			DRect A = ts[0].GetEncapsulatingSamplingRect();
			A.Expand(0.05f);
			Gizmos.color = encC;
			Gizmos.DrawWireCube(A.center.GetVector2(), A.size);
			for (int i = 0; i < matsAndGOs.mats.Count; i++)
			{
				DRect B = matsAndGOs.mats[i].samplingRectMatAndUVTiling;
				DRect r = MB3_UVTransformUtility.GetShiftTransformToFitBinA(ref A, ref B);
				Vector2 vector = MB3_UVTransformUtility.TransformPoint(ref r, B.min);
				B.x = vector.x;
				B.y = vector.y;
				Gizmos.color = innerC;
				Gizmos.DrawWireCube(B.center.GetVector2(), B.size);
			}
		}

		internal string GetDescription()
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.AppendFormat("[GAME_OBJS=");
			for (int i = 0; i < matsAndGOs.gos.Count; i++)
			{
				stringBuilder.AppendFormat("{0},", matsAndGOs.gos[i].name);
			}
			stringBuilder.AppendFormat("MATS=");
			for (int j = 0; j < matsAndGOs.mats.Count; j++)
			{
				stringBuilder.AppendFormat("{0},", matsAndGOs.mats[j].GetMaterialName());
			}
			stringBuilder.Append("]");
			return stringBuilder.ToString();
		}

		internal string GetMatSubrectDescriptions()
		{
			StringBuilder stringBuilder = new StringBuilder();
			for (int i = 0; i < matsAndGOs.mats.Count; i++)
			{
				stringBuilder.AppendFormat("\n    {0}={1},", matsAndGOs.mats[i].GetMaterialName(), matsAndGOs.mats[i].samplingRectMatAndUVTiling);
			}
			return stringBuilder.ToString();
		}
	}
	public class MB3_TextureCombinerMerging
	{
		private bool _considerNonTextureProperties;

		private MB3_TextureCombinerNonTextureProperties resultMaterialTextureBlender;

		private bool fixOutOfBoundsUVs = true;

		public MB2_LogLevel LOG_LEVEL = MB2_LogLevel.info;

		private static bool LOG_LEVEL_TRACE_MERGE_MAT_SUBRECTS;

		public static Rect BuildTransformMeshUV2AtlasRect(bool considerMeshUVs, Rect _atlasRect, Rect _obUVRect, Rect _sourceMaterialTiling, Rect _encapsulatingRect)
		{
			DRect r = new DRect(_atlasRect);
			DRect t = ((!considerMeshUVs) ? new DRect(0.0, 0.0, 1.0, 1.0) : new DRect(_obUVRect));
			DRect r2 = new DRect(_sourceMaterialTiling);
			DRect t2 = new DRect(_encapsulatingRect);
			DRect r3 = MB3_UVTransformUtility.InverseTransform(ref t2);
			DRect r4 = MB3_UVTransformUtility.InverseTransform(ref t);
			DRect B = MB3_UVTransformUtility.CombineTransforms(ref t, ref r2);
			DRect r5 = MB3_UVTransformUtility.GetShiftTransformToFitBinA(ref t2, ref B);
			B = MB3_UVTransformUtility.CombineTransforms(ref B, ref r5);
			DRect r6 = MB3_UVTransformUtility.CombineTransforms(ref B, ref r3);
			DRect r7 = MB3_UVTransformUtility.CombineTransforms(ref r4, ref r6);
			return MB3_UVTransformUtility.CombineTransforms(ref r7, ref r).GetRect();
		}

		public MB3_TextureCombinerMerging(bool considerNonTextureProps, MB3_TextureCombinerNonTextureProperties resultMaterialTexBlender, bool fixObUVs, MB2_LogLevel logLevel)
		{
			LOG_LEVEL = logLevel;
			_considerNonTextureProperties = considerNonTextureProps;
			resultMaterialTextureBlender = resultMaterialTexBlender;
			fixOutOfBoundsUVs = fixObUVs;
		}

		public void MergeOverlappingDistinctMaterialTexturesAndCalcMaterialSubrects(List<MB_TexSet> distinctMaterialTextures)
		{
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("MergeOverlappingDistinctMaterialTexturesAndCalcMaterialSubrects");
			}
			int num = 0;
			for (int i = 0; i < distinctMaterialTextures.Count; i++)
			{
				MB_TexSet mB_TexSet = distinctMaterialTextures[i];
				int num2 = -1;
				bool flag = true;
				DRect dRect = default(DRect);
				for (int j = 0; j < mB_TexSet.ts.Length; j++)
				{
					if (num2 != -1)
					{
						if (!mB_TexSet.ts[j].isNull && dRect != mB_TexSet.ts[j].matTilingRect)
						{
							flag = false;
						}
					}
					else if (!mB_TexSet.ts[j].isNull)
					{
						num2 = j;
						dRect = mB_TexSet.ts[j].matTilingRect;
					}
				}
				if (LOG_LEVEL >= MB2_LogLevel.debug || LOG_LEVEL_TRACE_MERGE_MAT_SUBRECTS)
				{
					if (flag)
					{
						UnityEngine.Debug.LogFormat("TextureSet {0} allTexturesUseSameMatTiling = {1}", i, flag);
					}
					else
					{
						UnityEngine.Debug.Log($"Textures in material(s) do not all use the same material tiling. This set of textures will not be considered for merge: {mB_TexSet.GetDescription()} ");
					}
				}
				if (flag)
				{
					mB_TexSet.SetAllTexturesUseSameMatTilingTrue();
				}
			}
			for (int k = 0; k < distinctMaterialTextures.Count; k++)
			{
				MB_TexSet mB_TexSet2 = distinctMaterialTextures[k];
				for (int l = 0; l < mB_TexSet2.matsAndGOs.mats.Count; l++)
				{
					if (mB_TexSet2.matsAndGOs.gos.Count > 0)
					{
						mB_TexSet2.matsAndGOs.mats[l].objName = mB_TexSet2.matsAndGOs.gos[0].name;
					}
					else if (mB_TexSet2.ts[0] != null)
					{
						mB_TexSet2.matsAndGOs.mats[l].objName = $"[objWithTx:{mB_TexSet2.ts[0].GetTexName()} atlasBlock:{k} matIdx{l}]";
					}
					else
					{
						mB_TexSet2.matsAndGOs.mats[l].objName = string.Format("[objWithTx:{0} atlasBlock:{1} matIdx{2}]", "Unknown", k, l);
					}
				}
				mB_TexSet2.CalcInitialFullSamplingRects(fixOutOfBoundsUVs);
				mB_TexSet2.CalcMatAndUVSamplingRects();
			}
			List<int> list = new List<int>();
			for (int m = 0; m < distinctMaterialTextures.Count; m++)
			{
				MB_TexSet mB_TexSet3 = distinctMaterialTextures[m];
				for (int n = m + 1; n < distinctMaterialTextures.Count; n++)
				{
					MB_TexSet mB_TexSet4 = distinctMaterialTextures[n];
					if (!mB_TexSet4.AllTexturesAreSameForMerge(mB_TexSet3, _considerNonTextureProperties, resultMaterialTextureBlender))
					{
						continue;
					}
					double num3 = 0.0;
					double num4 = 0.0;
					DRect dRect2 = default(DRect);
					int num5 = -1;
					for (int num6 = 0; num6 < mB_TexSet3.ts.Length; num6++)
					{
						if (!mB_TexSet3.ts[num6].isNull && num5 == -1)
						{
							num5 = num6;
						}
					}
					if (num5 != -1)
					{
						DRect uvRect = mB_TexSet4.matsAndGOs.mats[0].samplingRectMatAndUVTiling;
						for (int num7 = 1; num7 < mB_TexSet4.matsAndGOs.mats.Count; num7++)
						{
							DRect willBeIn = mB_TexSet4.matsAndGOs.mats[num7].samplingRectMatAndUVTiling;
							uvRect = MB3_UVTransformUtility.GetEncapsulatingRectShifted(ref uvRect, ref willBeIn);
						}
						DRect uvRect2 = mB_TexSet3.matsAndGOs.mats[0].samplingRectMatAndUVTiling;
						for (int num8 = 1; num8 < mB_TexSet3.matsAndGOs.mats.Count; num8++)
						{
							DRect willBeIn2 = mB_TexSet3.matsAndGOs.mats[num8].samplingRectMatAndUVTiling;
							uvRect2 = MB3_UVTransformUtility.GetEncapsulatingRectShifted(ref uvRect2, ref willBeIn2);
						}
						dRect2 = MB3_UVTransformUtility.GetEncapsulatingRectShifted(ref uvRect, ref uvRect2);
						num3 += dRect2.width * dRect2.height;
						num4 += uvRect.width * uvRect.height + uvRect2.width * uvRect2.height;
					}
					else
					{
						dRect2 = new DRect(0f, 0f, 1f, 1f);
					}
					if (num3 < num4)
					{
						num++;
						StringBuilder stringBuilder = null;
						if (LOG_LEVEL >= MB2_LogLevel.info)
						{
							stringBuilder = new StringBuilder();
							stringBuilder.AppendFormat("About To Merge:\n   TextureSet1 {0}\n   TextureSet2 {1}\n", mB_TexSet4.GetDescription(), mB_TexSet3.GetDescription());
							if (LOG_LEVEL >= MB2_LogLevel.trace)
							{
								for (int num9 = 0; num9 < mB_TexSet4.matsAndGOs.mats.Count; num9++)
								{
									stringBuilder.AppendFormat("tx1 Mat {0} matAndMeshUVRect {1} fullSamplingRect {2}\n", mB_TexSet4.matsAndGOs.mats[num9].mat, mB_TexSet4.matsAndGOs.mats[num9].samplingRectMatAndUVTiling, mB_TexSet4.ts[0].GetEncapsulatingSamplingRect());
								}
								for (int num10 = 0; num10 < mB_TexSet3.matsAndGOs.mats.Count; num10++)
								{
									stringBuilder.AppendFormat("tx2 Mat {0} matAndMeshUVRect {1} fullSamplingRect {2}\n", mB_TexSet3.matsAndGOs.mats[num10].mat, mB_TexSet3.matsAndGOs.mats[num10].samplingRectMatAndUVTiling, mB_TexSet3.ts[0].GetEncapsulatingSamplingRect());
								}
							}
						}
						for (int num11 = 0; num11 < mB_TexSet3.matsAndGOs.gos.Count; num11++)
						{
							if (!mB_TexSet4.matsAndGOs.gos.Contains(mB_TexSet3.matsAndGOs.gos[num11]))
							{
								mB_TexSet4.matsAndGOs.gos.Add(mB_TexSet3.matsAndGOs.gos[num11]);
							}
						}
						for (int num12 = 0; num12 < mB_TexSet3.matsAndGOs.mats.Count; num12++)
						{
							mB_TexSet4.matsAndGOs.mats.Add(mB_TexSet3.matsAndGOs.mats[num12]);
						}
						mB_TexSet4.SetEncapsulatingSamplingRectWhenMergingTexSets(dRect2);
						if (!list.Contains(m))
						{
							list.Add(m);
						}
						if (LOG_LEVEL < MB2_LogLevel.debug)
						{
							break;
						}
						if (LOG_LEVEL >= MB2_LogLevel.trace)
						{
							stringBuilder.AppendFormat("=== After Merge TextureSet {0}\n", mB_TexSet4.GetDescription());
							for (int num13 = 0; num13 < mB_TexSet4.matsAndGOs.mats.Count; num13++)
							{
								stringBuilder.AppendFormat("tx1 Mat {0} matAndMeshUVRect {1} fullSamplingRect {2}\n", mB_TexSet4.matsAndGOs.mats[num13].mat, mB_TexSet4.matsAndGOs.mats[num13].samplingRectMatAndUVTiling, mB_TexSet4.ts[0].GetEncapsulatingSamplingRect());
							}
							if (MB3_MeshBakerRoot.DO_INTEGRITY_CHECKS && MB3_MeshBakerRoot.DO_INTEGRITY_CHECKS)
							{
								DoIntegrityCheckMergedEncapsulatingSamplingRects(distinctMaterialTextures);
							}
						}
						UnityEngine.Debug.Log(stringBuilder.ToString());
						break;
					}
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						UnityEngine.Debug.Log($"Considered merging {mB_TexSet4.GetDescription()} and {mB_TexSet3.GetDescription()} but there was not enough overlap. It is more efficient to bake these to separate rectangles.");
					}
				}
			}
			for (int num14 = list.Count - 1; num14 >= 0; num14--)
			{
				distinctMaterialTextures.RemoveAt(list[num14]);
			}
			list.Clear();
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log($"MergeOverlappingDistinctMaterialTexturesAndCalcMaterialSubrects complete merged {num} now have {distinctMaterialTextures.Count}");
			}
			if (MB3_MeshBakerRoot.DO_INTEGRITY_CHECKS)
			{
				DoIntegrityCheckMergedEncapsulatingSamplingRects(distinctMaterialTextures);
			}
		}

		public void DoIntegrityCheckMergedEncapsulatingSamplingRects(List<MB_TexSet> distinctMaterialTextures)
		{
			if (!MB3_MeshBakerRoot.DO_INTEGRITY_CHECKS)
			{
				return;
			}
			for (int i = 0; i < distinctMaterialTextures.Count; i++)
			{
				MB_TexSet mB_TexSet = distinctMaterialTextures[i];
				if (!mB_TexSet.allTexturesUseSameMatTiling)
				{
					continue;
				}
				for (int j = 0; j < mB_TexSet.matsAndGOs.mats.Count; j++)
				{
					MatAndTransformToMerged matAndTransformToMerged = mB_TexSet.matsAndGOs.mats[j];
					DRect obUVRectIfTilingSame = matAndTransformToMerged.obUVRectIfTilingSame;
					DRect materialTiling = matAndTransformToMerged.materialTiling;
					if (!MB2_TextureBakeResults.IsMeshAndMaterialRectEnclosedByAtlasRect(mB_TexSet.tilingTreatment, obUVRectIfTilingSame.GetRect(), materialTiling.GetRect(), mB_TexSet.ts[0].GetEncapsulatingSamplingRect().GetRect(), MB2_LogLevel.info))
					{
						UnityEngine.Debug.LogErrorFormat(string.Concat("mesh ", mB_TexSet.matsAndGOs.mats[j].objName, "\n uv=", obUVRectIfTilingSame, "\n mat=", materialTiling.GetRect().ToString("f5"), "\n samplingRect=", mB_TexSet.matsAndGOs.mats[j].samplingRectMatAndUVTiling.GetRect().ToString("f4"), "\n encapsulatingRect ", mB_TexSet.ts[0].GetEncapsulatingSamplingRect().GetRect().ToString("f4"), "\n"));
						UnityEngine.Debug.LogErrorFormat(string.Format("Integrity check failed. " + mB_TexSet.matsAndGOs.mats[j].objName + " Encapsulating sampling rect failed to contain potentialRect\n"));
						MB2_TextureBakeResults.IsMeshAndMaterialRectEnclosedByAtlasRect(mB_TexSet.tilingTreatment, obUVRectIfTilingSame.GetRect(), materialTiling.GetRect(), mB_TexSet.ts[0].GetEncapsulatingSamplingRect().GetRect(), MB2_LogLevel.trace);
					}
				}
			}
		}
	}
	public class MB3_TextureCombinerNonTextureProperties
	{
		public interface MaterialProperty
		{
			string PropertyName { get; set; }

			MaterialPropertyValueAveraged GetAverageCalculator();

			object GetDefaultValue();
		}

		public class MaterialPropertyFloat : MaterialProperty
		{
			private MaterialPropertyValueAveragedFloat _averageCalc;

			private float _defaultValue;

			public string PropertyName { get; set; }

			public MaterialPropertyFloat(string name, float defValue)
			{
				_averageCalc = new MaterialPropertyValueAveragedFloat();
				_defaultValue = defValue;
				PropertyName = name;
			}

			public MaterialPropertyValueAveraged GetAverageCalculator()
			{
				return _averageCalc;
			}

			public object GetDefaultValue()
			{
				return _defaultValue;
			}
		}

		public class MaterialPropertyColor : MaterialProperty
		{
			private MaterialPropertyValueAveragedColor _averageCalc;

			private UnityEngine.Color _defaultValue;

			public string PropertyName { get; set; }

			public MaterialPropertyColor(string name, UnityEngine.Color defaultVal)
			{
				_averageCalc = new MaterialPropertyValueAveragedColor();
				_defaultValue = defaultVal;
				PropertyName = name;
			}

			public MaterialPropertyValueAveraged GetAverageCalculator()
			{
				return _averageCalc;
			}

			public object GetDefaultValue()
			{
				return _defaultValue;
			}
		}

		public interface MaterialPropertyValueAveraged
		{
			void TryGetPropValueFromMaterialAndBlendIntoAverage(Material mat, MaterialProperty property);

			object GetAverage();

			int NumValues();

			void SetAverageValueOrDefaultOnMaterial(Material mat, MaterialProperty property);
		}

		public class MaterialPropertyValueAveragedFloat : MaterialPropertyValueAveraged
		{
			public float averageVal;

			public int numValues;

			public void TryGetPropValueFromMaterialAndBlendIntoAverage(Material mat, MaterialProperty property)
			{
				if (mat.HasProperty(property.PropertyName))
				{
					float @float = mat.GetFloat(property.PropertyName);
					averageVal = averageVal * (float)numValues / (float)(numValues + 1) + @float / (float)(numValues + 1);
					numValues++;
				}
			}

			public object GetAverage()
			{
				return averageVal;
			}

			public int NumValues()
			{
				return numValues;
			}

			public void SetAverageValueOrDefaultOnMaterial(Material mat, MaterialProperty property)
			{
				if (mat.HasProperty(property.PropertyName))
				{
					if (numValues > 0)
					{
						mat.SetFloat(property.PropertyName, averageVal);
					}
					else
					{
						mat.SetFloat(property.PropertyName, (float)property.GetDefaultValue());
					}
				}
			}
		}

		public class MaterialPropertyValueAveragedColor : MaterialPropertyValueAveraged
		{
			public UnityEngine.Color averageVal;

			public int numValues;

			public void TryGetPropValueFromMaterialAndBlendIntoAverage(Material mat, MaterialProperty property)
			{
				if (mat.HasProperty(property.PropertyName))
				{
					UnityEngine.Color color = mat.GetColor(property.PropertyName);
					averageVal = averageVal * numValues / (numValues + 1) + color / (numValues + 1);
					numValues++;
				}
			}

			public object GetAverage()
			{
				return averageVal;
			}

			public int NumValues()
			{
				return numValues;
			}

			public void SetAverageValueOrDefaultOnMaterial(Material mat, MaterialProperty property)
			{
				if (mat.HasProperty(property.PropertyName))
				{
					if (numValues > 0)
					{
						mat.SetColor(property.PropertyName, averageVal);
					}
					else
					{
						mat.SetColor(property.PropertyName, (UnityEngine.Color)property.GetDefaultValue());
					}
				}
			}
		}

		public struct TexPropertyNameColorPair
		{
			public string name;

			public UnityEngine.Color color;

			public TexPropertyNameColorPair(string nm, UnityEngine.Color col)
			{
				name = nm;
				color = col;
			}
		}

		private interface NonTextureProperties
		{
			bool NonTexturePropertiesAreEqual(Material a, Material b);

			Texture2D TintTextureWithTextureCombiner(Texture2D t, MB_TexSet sourceMaterial, ShaderTextureProperty shaderPropertyName);

			void AdjustNonTextureProperties(Material resultMat, List<ShaderTextureProperty> texPropertyNames, List<MB_TexSet> distinctMaterialTextures, MB2_EditorMethodsInterface editorMethods);

			UnityEngine.Color GetColorForTemporaryTexture(Material matIfBlender, ShaderTextureProperty texProperty);

			UnityEngine.Color GetColorAsItWouldAppearInAtlasIfNoTexture(Material matIfBlender, ShaderTextureProperty texProperty);
		}

		private class NonTexturePropertiesDontBlendProps : NonTextureProperties
		{
			private MB3_TextureCombinerNonTextureProperties _textureProperties;

			public NonTexturePropertiesDontBlendProps(MB3_TextureCombinerNonTextureProperties textureProperties)
			{
				_textureProperties = textureProperties;
			}

			public bool NonTexturePropertiesAreEqual(Material a, Material b)
			{
				return true;
			}

			public Texture2D TintTextureWithTextureCombiner(Texture2D t, MB_TexSet sourceMaterial, ShaderTextureProperty shaderPropertyName)
			{
				UnityEngine.Debug.LogError("TintTextureWithTextureCombiner should never be called if resultMaterialTextureBlender is null");
				return t;
			}

			public void AdjustNonTextureProperties(Material resultMat, List<ShaderTextureProperty> texPropertyNames, List<MB_TexSet> distinctMaterialTextures, MB2_EditorMethodsInterface editorMethods)
			{
				if (resultMat == null || texPropertyNames == null)
				{
					return;
				}
				for (int i = 0; i < _textureProperties._nonTextureProperties.Length; i++)
				{
					MaterialProperty materialProperty = _textureProperties._nonTextureProperties[i];
					if (resultMat.HasProperty(materialProperty.PropertyName))
					{
						materialProperty.GetAverageCalculator().SetAverageValueOrDefaultOnMaterial(resultMat, materialProperty);
					}
				}
				editorMethods?.CommitChangesToAssets();
			}

			public UnityEngine.Color GetColorAsItWouldAppearInAtlasIfNoTexture(Material matIfBlender, ShaderTextureProperty texProperty)
			{
				return UnityEngine.Color.white;
			}

			public UnityEngine.Color GetColorForTemporaryTexture(Material matIfBlender, ShaderTextureProperty texProperty)
			{
				if (texProperty.isNormalMap)
				{
					return NEUTRAL_NORMAL_MAP_COLOR;
				}
				if (_textureProperties.textureProperty2DefaultColorMap.ContainsKey(texProperty.name))
				{
					return _textureProperties.textureProperty2DefaultColorMap[texProperty.name];
				}
				return new UnityEngine.Color(1f, 1f, 1f, 0f);
			}
		}

		private class NonTexturePropertiesBlendProps : NonTextureProperties
		{
			private MB3_TextureCombinerNonTextureProperties _textureProperties;

			private TextureBlender resultMaterialTextureBlender;

			public NonTexturePropertiesBlendProps(MB3_TextureCombinerNonTextureProperties textureProperties, TextureBlender resultMats)
			{
				resultMaterialTextureBlender = resultMats;
				_textureProperties = textureProperties;
			}

			public bool NonTexturePropertiesAreEqual(Material a, Material b)
			{
				return resultMaterialTextureBlender.NonTexturePropertiesAreEqual(a, b);
			}

			public Texture2D TintTextureWithTextureCombiner(Texture2D t, MB_TexSet sourceMaterial, ShaderTextureProperty shaderPropertyName)
			{
				resultMaterialTextureBlender.OnBeforeTintTexture(sourceMaterial.matsAndGOs.mats[0].mat, shaderPropertyName.name);
				if (_textureProperties.LOG_LEVEL >= MB2_LogLevel.trace)
				{
					UnityEngine.Debug.Log($"Blending texture {t.name} mat {sourceMaterial.matsAndGOs.mats[0].mat} with non-texture properties using TextureBlender {resultMaterialTextureBlender}");
				}
				for (int i = 0; i < t.height; i++)
				{
					UnityEngine.Color[] pixels = t.GetPixels(0, i, t.width, 1);
					for (int j = 0; j < pixels.Length; j++)
					{
						pixels[j] = resultMaterialTextureBlender.OnBlendTexturePixel(shaderPropertyName.name, pixels[j]);
					}
					t.SetPixels(0, i, t.width, 1, pixels);
				}
				t.Apply();
				return t;
			}

			public void AdjustNonTextureProperties(Material resultMat, List<ShaderTextureProperty> texPropertyNames, List<MB_TexSet> distinctMaterialTextures, MB2_EditorMethodsInterface editorMethods)
			{
				if (!(resultMat == null) && texPropertyNames != null)
				{
					if (_textureProperties.LOG_LEVEL >= MB2_LogLevel.debug)
					{
						UnityEngine.Debug.Log("Adjusting non texture properties using TextureBlender for shader: " + resultMat.shader.name);
					}
					resultMaterialTextureBlender.SetNonTexturePropertyValuesOnResultMaterial(resultMat);
					editorMethods?.CommitChangesToAssets();
				}
			}

			public UnityEngine.Color GetColorAsItWouldAppearInAtlasIfNoTexture(Material matIfBlender, ShaderTextureProperty texProperty)
			{
				resultMaterialTextureBlender.OnBeforeTintTexture(matIfBlender, texProperty.name);
				UnityEngine.Color colorForTemporaryTexture = GetColorForTemporaryTexture(matIfBlender, texProperty);
				return resultMaterialTextureBlender.OnBlendTexturePixel(texProperty.name, colorForTemporaryTexture);
			}

			public UnityEngine.Color GetColorForTemporaryTexture(Material matIfBlender, ShaderTextureProperty texProperty)
			{
				return resultMaterialTextureBlender.GetColorIfNoTexture(matIfBlender, texProperty);
			}
		}

		public static UnityEngine.Color NEUTRAL_NORMAL_MAP_COLOR = new UnityEngine.Color(0.5f, 0.5f, 1f);

		private TexPropertyNameColorPair[] defaultTextureProperty2DefaultColorMap = new TexPropertyNameColorPair[6]
		{
			new TexPropertyNameColorPair("_MainTex", new UnityEngine.Color(1f, 1f, 1f, 0f)),
			new TexPropertyNameColorPair("_MetallicGlossMap", new UnityEngine.Color(0f, 0f, 0f, 1f)),
			new TexPropertyNameColorPair("_ParallaxMap", new UnityEngine.Color(0f, 0f, 0f, 0f)),
			new TexPropertyNameColorPair("_OcclusionMap", new UnityEngine.Color(1f, 1f, 1f, 1f)),
			new TexPropertyNameColorPair("_EmissionMap", new UnityEngine.Color(0f, 0f, 0f, 0f)),
			new TexPropertyNameColorPair("_DetailMask", new UnityEngine.Color(0f, 0f, 0f, 0f))
		};

		private MaterialProperty[] _nonTextureProperties = new MaterialProperty[8]
		{
			new MaterialPropertyColor("_Color", UnityEngine.Color.white),
			new MaterialPropertyFloat("_Glossiness", 0.5f),
			new MaterialPropertyFloat("_GlossMapScale", 1f),
			new MaterialPropertyFloat("_Metallic", 0f),
			new MaterialPropertyFloat("_BumpScale", 0.1f),
			new MaterialPropertyFloat("_Parallax", 0.02f),
			new MaterialPropertyFloat("_OcclusionStrength", 1f),
			new MaterialPropertyColor("_EmissionColor", UnityEngine.Color.black)
		};

		private MB2_LogLevel LOG_LEVEL = MB2_LogLevel.info;

		private bool _considerNonTextureProperties;

		private TextureBlender resultMaterialTextureBlender;

		private TextureBlender[] textureBlenders = new TextureBlender[0];

		private Dictionary<string, UnityEngine.Color> textureProperty2DefaultColorMap = new Dictionary<string, UnityEngine.Color>();

		private NonTextureProperties _nonTexturePropertiesBlender;

		public MB3_TextureCombinerNonTextureProperties(MB2_LogLevel ll, bool considerNonTextureProps)
		{
			LOG_LEVEL = ll;
			_considerNonTextureProperties = considerNonTextureProps;
			textureProperty2DefaultColorMap = new Dictionary<string, UnityEngine.Color>();
			for (int i = 0; i < defaultTextureProperty2DefaultColorMap.Length; i++)
			{
				textureProperty2DefaultColorMap.Add(defaultTextureProperty2DefaultColorMap[i].name, defaultTextureProperty2DefaultColorMap[i].color);
				_nonTexturePropertiesBlender = new NonTexturePropertiesDontBlendProps(this);
			}
		}

		internal void CollectAverageValuesOfNonTextureProperties(Material resultMaterial, Material mat)
		{
			for (int i = 0; i < _nonTextureProperties.Length; i++)
			{
				MaterialProperty materialProperty = _nonTextureProperties[i];
				if (resultMaterial.HasProperty(materialProperty.PropertyName))
				{
					materialProperty.GetAverageCalculator().TryGetPropValueFromMaterialAndBlendIntoAverage(mat, materialProperty);
				}
			}
		}

		internal void LoadTextureBlendersIfNeeded(Material resultMaterial)
		{
			if (_considerNonTextureProperties)
			{
				LoadTextureBlenders();
				FindBestTextureBlender(resultMaterial);
			}
		}

		private static bool InterfaceFilter(Type typeObj, object criteriaObj)
		{
			return typeObj.ToString() == criteriaObj.ToString();
		}

		private void FindBestTextureBlender(Material resultMaterial)
		{
			resultMaterialTextureBlender = FindMatchingTextureBlender(resultMaterial.shader.name);
			if (resultMaterialTextureBlender != null)
			{
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					UnityEngine.Debug.Log("Using _considerNonTextureProperties found a TextureBlender for result material. Using: " + resultMaterialTextureBlender);
				}
			}
			else
			{
				if (LOG_LEVEL >= MB2_LogLevel.error)
				{
					UnityEngine.Debug.LogWarning("Using _considerNonTextureProperties could not find a TextureBlender that matches the shader on the result material. Using the Fallback Texture Blender.");
				}
				resultMaterialTextureBlender = new TextureBlenderFallback();
			}
			_nonTexturePropertiesBlender = new NonTexturePropertiesBlendProps(this, resultMaterialTextureBlender);
		}

		private void LoadTextureBlenders()
		{
			string filterCriteria = "DigitalOpus.MB.Core.TextureBlender";
			TypeFilter filter = InterfaceFilter;
			List<Type> list = new List<Type>();
			Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
			foreach (Assembly assembly in assemblies)
			{
				IEnumerable enumerable = null;
				try
				{
					enumerable = assembly.GetTypes();
				}
				catch (Exception ex)
				{
					ex.Equals(null);
				}
				if (enumerable == null)
				{
					continue;
				}
				Type[] types = assembly.GetTypes();
				foreach (Type type in types)
				{
					if (type.FindInterfaces(filter, filterCriteria).Length != 0)
					{
						list.Add(type);
					}
				}
			}
			TextureBlender textureBlender = null;
			List<TextureBlender> list2 = new List<TextureBlender>();
			foreach (Type item in list)
			{
				if (!item.IsAbstract && !item.IsInterface)
				{
					TextureBlender textureBlender2 = (TextureBlender)Activator.CreateInstance(item);
					if (textureBlender2 is TextureBlenderFallback)
					{
						textureBlender = textureBlender2;
					}
					else
					{
						list2.Add(textureBlender2);
					}
				}
			}
			if (textureBlender != null)
			{
				list2.Add(textureBlender);
			}
			textureBlenders = list2.ToArray();
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log($"Loaded {textureBlenders.Length} TextureBlenders.");
			}
		}

		internal bool NonTexturePropertiesAreEqual(Material a, Material b)
		{
			return _nonTexturePropertiesBlender.NonTexturePropertiesAreEqual(a, b);
		}

		internal Texture2D TintTextureWithTextureCombiner(Texture2D t, MB_TexSet sourceMaterial, ShaderTextureProperty shaderPropertyName)
		{
			return _nonTexturePropertiesBlender.TintTextureWithTextureCombiner(t, sourceMaterial, shaderPropertyName);
		}

		internal void AdjustNonTextureProperties(Material resultMat, List<ShaderTextureProperty> texPropertyNames, List<MB_TexSet> distinctMaterialTextures, MB2_EditorMethodsInterface editorMethods)
		{
			if (!(resultMat == null) && texPropertyNames != null)
			{
				_nonTexturePropertiesBlender.AdjustNonTextureProperties(resultMat, texPropertyNames, distinctMaterialTextures, editorMethods);
			}
		}

		internal UnityEngine.Color GetColorAsItWouldAppearInAtlasIfNoTexture(Material matIfBlender, ShaderTextureProperty texProperty)
		{
			return _nonTexturePropertiesBlender.GetColorAsItWouldAppearInAtlasIfNoTexture(matIfBlender, texProperty);
		}

		internal UnityEngine.Color GetColorForTemporaryTexture(Material matIfBlender, ShaderTextureProperty texProperty)
		{
			return _nonTexturePropertiesBlender.GetColorForTemporaryTexture(matIfBlender, texProperty);
		}

		private TextureBlender FindMatchingTextureBlender(string shaderName)
		{
			for (int i = 0; i < textureBlenders.Length; i++)
			{
				if (textureBlenders[i].DoesShaderNameMatch(shaderName))
				{
					return textureBlenders[i];
				}
			}
			return null;
		}
	}
	internal class MB3_TextureCombinerPackerMeshBaker : MB3_TextureCombinerPackerRoot
	{
		public override IEnumerator CreateAtlases(ProgressUpdateDelegate progressInfo, MB3_TextureCombinerPipeline.TexturePipelineData data, MB3_TextureCombiner combiner, AtlasPackingResult packedAtlasRects, Texture2D[] atlases, MB2_EditorMethodsInterface textureEditorMethods, MB2_LogLevel LOG_LEVEL)
		{
			Rect[] uvRects = packedAtlasRects.rects;
			int atlasSizeX = packedAtlasRects.atlasX;
			int atlasSizeY = packedAtlasRects.atlasY;
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Generated atlas will be " + atlasSizeX + "x" + atlasSizeY);
			}
			for (int propIdx = 0; propIdx < data.numAtlases; propIdx++)
			{
				ShaderTextureProperty property = data.texPropertyNames[propIdx];
				Texture2D texture2D;
				if (!MB3_TextureCombinerPipeline._ShouldWeCreateAtlasForThisProperty(propIdx, data._considerNonTextureProperties, data.allTexturesAreNullAndSameColor))
				{
					texture2D = null;
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						UnityEngine.Debug.Log("=== Not creating atlas for " + property.name + " because textures are null and default value parameters are the same.");
					}
				}
				else
				{
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						UnityEngine.Debug.Log("=== Creating atlas for " + property.name);
					}
					GC.Collect();
					MB3_TextureCombinerPackerRoot.CreateTemporaryTexturesForAtlas(data.distinctMaterialTextures, combiner, propIdx, data);
					UnityEngine.Color[][] atlasPixels = new UnityEngine.Color[atlasSizeY][];
					for (int i = 0; i < atlasPixels.Length; i++)
					{
						atlasPixels[i] = new UnityEngine.Color[atlasSizeX];
					}
					bool isNormalMap = false;
					if (property.isNormalMap)
					{
						isNormalMap = true;
					}
					for (int texSetIdx = 0; texSetIdx < data.distinctMaterialTextures.Count; texSetIdx++)
					{
						MB_TexSet mB_TexSet = data.distinctMaterialTextures[texSetIdx];
						MeshBakerMaterialTexture meshBakerMaterialTexture = mB_TexSet.ts[propIdx];
						string text = "Creating Atlas '" + property.name + "' texture " + meshBakerMaterialTexture.GetTexName();
						progressInfo?.Invoke(text, 0.01f);
						if (LOG_LEVEL >= MB2_LogLevel.trace)
						{
							UnityEngine.Debug.Log($"Adding texture {meshBakerMaterialTexture.GetTexName()} to atlas {property.name} for texSet {texSetIdx} srcMat {mB_TexSet.matsAndGOs.mats[0].GetMaterialName()}");
						}
						Rect rect = uvRects[texSetIdx];
						Texture2D texture2D2 = mB_TexSet.ts[propIdx].GetTexture2D();
						int targX = Mathf.RoundToInt(rect.x * (float)atlasSizeX);
						int targY = Mathf.RoundToInt(rect.y * (float)atlasSizeY);
						int num = Mathf.RoundToInt(rect.width * (float)atlasSizeX);
						int num2 = Mathf.RoundToInt(rect.height * (float)atlasSizeY);
						if (num == 0 || num2 == 0)
						{
							UnityEngine.Debug.LogError("Image in atlas has no height or width " + rect);
						}
						progressInfo?.Invoke(text + " set ReadWrite flag", 0.01f);
						textureEditorMethods?.SetReadWriteFlag(texture2D2, isReadable: true, addToList: true);
						progressInfo?.Invoke(text + "Copying to atlas: '" + meshBakerMaterialTexture.GetTexName() + "'", 0.02f);
						DRect encapsulatingSamplingRect = mB_TexSet.ts[propIdx].GetEncapsulatingSamplingRect();
						yield return CopyScaledAndTiledToAtlas(mB_TexSet.ts[propIdx], mB_TexSet, property, encapsulatingSamplingRect, targX, targY, num, num2, packedAtlasRects.padding[texSetIdx], atlasPixels, isNormalMap, data, combiner, progressInfo, LOG_LEVEL);
					}
					yield return data.numAtlases;
					progressInfo?.Invoke("Applying changes to atlas: '" + property.name + "'", 0.03f);
					texture2D = new Texture2D(atlasSizeX, atlasSizeY, TextureFormat.ARGB32, mipChain: true);
					for (int j = 0; j < atlasPixels.Length; j++)
					{
						texture2D.SetPixels(0, j, atlasSizeX, 1, atlasPixels[j]);
					}
					texture2D.Apply();
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						UnityEngine.Debug.Log("Saving atlas " + property.name + " w=" + texture2D.width + " h=" + texture2D.height);
					}
				}
				atlases[propIdx] = texture2D;
				progressInfo?.Invoke("Saving atlas: '" + property.name + "'", 0.04f);
				new Stopwatch().Start();
				if (data._saveAtlasesAsAssets && textureEditorMethods != null)
				{
					textureEditorMethods.SaveAtlasToAssetDatabase(atlases[propIdx], data.texPropertyNames[propIdx], propIdx, data.resultMaterial);
				}
				else
				{
					data.resultMaterial.SetTexture(data.texPropertyNames[propIdx].name, atlases[propIdx]);
				}
				data.resultMaterial.SetTextureOffset(data.texPropertyNames[propIdx].name, Vector2.zero);
				data.resultMaterial.SetTextureScale(data.texPropertyNames[propIdx].name, Vector2.one);
				combiner._destroyTemporaryTextures(data.texPropertyNames[propIdx].name);
			}
		}

		internal static IEnumerator CopyScaledAndTiledToAtlas(MeshBakerMaterialTexture source, MB_TexSet sourceMaterial, ShaderTextureProperty shaderPropertyName, DRect srcSamplingRect, int targX, int targY, int targW, int targH, AtlasPadding padding, UnityEngine.Color[][] atlasPixels, bool isNormalMap, MB3_TextureCombinerPipeline.TexturePipelineData data, MB3_TextureCombiner combiner, ProgressUpdateDelegate progressInfo = null, MB2_LogLevel LOG_LEVEL = MB2_LogLevel.info)
		{
			Texture2D texture2D = source.GetTexture2D();
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log($"CopyScaledAndTiledToAtlas: {texture2D} inAtlasX={targX} inAtlasY={targY} inAtlasW={targW} inAtlasH={targH} paddX={padding.leftRight} paddY={padding.topBottom} srcSamplingRect={srcSamplingRect}");
			}
			float num = targW;
			float num2 = targH;
			float num3 = (float)srcSamplingRect.width;
			float num4 = (float)srcSamplingRect.height;
			float num5 = (float)srcSamplingRect.x;
			float num6 = (float)srcSamplingRect.y;
			int w = (int)num;
			int h = (int)num2;
			if (data._considerNonTextureProperties)
			{
				texture2D = combiner._createTextureCopy(shaderPropertyName.name, texture2D);
				texture2D = data.nonTexturePropertyBlender.TintTextureWithTextureCombiner(texture2D, sourceMaterial, shaderPropertyName);
			}
			for (int k = 0; k < w; k++)
			{
				if (progressInfo != null && w > 0)
				{
					progressInfo("CopyScaledAndTiledToAtlas " + ((float)k / (float)w * 100f).ToString("F0"), 0.2f);
				}
				for (int l = 0; l < h; l++)
				{
					float x = (float)k / num * num3 + num5;
					float y = (float)l / num2 * num4 + num6;
					atlasPixels[targY + l][targX + k] = texture2D.GetPixelBilinear(x, y);
				}
			}
			for (int m = 0; m < w; m++)
			{
				for (int n = 1; n <= padding.topBottom; n++)
				{
					atlasPixels[targY - n][targX + m] = atlasPixels[targY][targX + m];
					atlasPixels[targY + h - 1 + n][targX + m] = atlasPixels[targY + h - 1][targX + m];
				}
			}
			for (int num7 = 0; num7 < h; num7++)
			{
				for (int num8 = 1; num8 <= padding.leftRight; num8++)
				{
					atlasPixels[targY + num7][targX - num8] = atlasPixels[targY + num7][targX];
					atlasPixels[targY + num7][targX + w + num8 - 1] = atlasPixels[targY + num7][targX + w - 1];
				}
			}
			for (int i = 1; i <= padding.leftRight; i++)
			{
				for (int j = 1; j <= padding.topBottom; j++)
				{
					atlasPixels[targY - j][targX - i] = atlasPixels[targY][targX];
					atlasPixels[targY + h - 1 + j][targX - i] = atlasPixels[targY + h - 1][targX];
					atlasPixels[targY + h - 1 + j][targX + w + i - 1] = atlasPixels[targY + h - 1][targX + w - 1];
					atlasPixels[targY - j][targX + w + i - 1] = atlasPixels[targY][targX + w - 1];
					yield return null;
				}
				yield return null;
			}
		}
	}
	internal class MB3_TextureCombinerPackerMeshBakerFast : MB_ITextureCombinerPacker
	{
		public IEnumerator ConvertTexturesToReadableFormats(ProgressUpdateDelegate progressInfo, MB3_TextureCombiner.CombineTexturesIntoAtlasesCoroutineResult result, MB3_TextureCombinerPipeline.TexturePipelineData data, MB3_TextureCombiner combiner, MB2_EditorMethodsInterface textureEditorMethods, MB2_LogLevel LOG_LEVEL)
		{
			yield break;
		}

		public virtual AtlasPackingResult[] CalculateAtlasRectangles(MB3_TextureCombinerPipeline.TexturePipelineData data, bool doMultiAtlas, MB2_LogLevel LOG_LEVEL)
		{
			return MB3_TextureCombinerPackerRoot.CalculateAtlasRectanglesStatic(data, doMultiAtlas, LOG_LEVEL);
		}

		public IEnumerator CreateAtlases(ProgressUpdateDelegate progressInfo, MB3_TextureCombinerPipeline.TexturePipelineData data, MB3_TextureCombiner combiner, AtlasPackingResult packedAtlasRects, Texture2D[] atlases, MB2_EditorMethodsInterface textureEditorMethods, MB2_LogLevel LOG_LEVEL)
		{
			Rect[] rects = packedAtlasRects.rects;
			int atlasX = packedAtlasRects.atlasX;
			int atlasY = packedAtlasRects.atlasY;
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Generated atlas will be " + atlasX + "x" + atlasY);
			}
			GameObject gameObject = null;
			try
			{
				gameObject = new GameObject("MBrenderAtlasesGO");
				MB3_AtlasPackerRenderTexture mB3_AtlasPackerRenderTexture = gameObject.AddComponent<MB3_AtlasPackerRenderTexture>();
				gameObject.AddComponent<Camera>();
				if (data._considerNonTextureProperties && LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Blend Non-Texture Properties has limited functionality when used with Mesh Baker Texture Packer Fast.");
				}
				for (int i = 0; i < data.numAtlases; i++)
				{
					Texture2D texture2D;
					if (!MB3_TextureCombinerPipeline._ShouldWeCreateAtlasForThisProperty(i, data._considerNonTextureProperties, data.allTexturesAreNullAndSameColor))
					{
						texture2D = null;
						if (LOG_LEVEL >= MB2_LogLevel.debug)
						{
							UnityEngine.Debug.Log("Not creating atlas for " + data.texPropertyNames[i].name + " because textures are null and default value parameters are the same.");
						}
					}
					else
					{
						GC.Collect();
						MB3_TextureCombinerPackerRoot.CreateTemporaryTexturesForAtlas(data.distinctMaterialTextures, combiner, i, data);
						progressInfo?.Invoke("Creating Atlas '" + data.texPropertyNames[i].name + "'", 0.01f);
						if (LOG_LEVEL >= MB2_LogLevel.debug)
						{
							UnityEngine.Debug.Log("About to render " + data.texPropertyNames[i].name + " isNormal=" + data.texPropertyNames[i].isNormalMap);
						}
						mB3_AtlasPackerRenderTexture.LOG_LEVEL = LOG_LEVEL;
						mB3_AtlasPackerRenderTexture.width = atlasX;
						mB3_AtlasPackerRenderTexture.height = atlasY;
						mB3_AtlasPackerRenderTexture.padding = data._atlasPadding;
						mB3_AtlasPackerRenderTexture.rects = rects;
						mB3_AtlasPackerRenderTexture.textureSets = data.distinctMaterialTextures;
						mB3_AtlasPackerRenderTexture.indexOfTexSetToRender = i;
						mB3_AtlasPackerRenderTexture.texPropertyName = data.texPropertyNames[i];
						mB3_AtlasPackerRenderTexture.isNormalMap = data.texPropertyNames[i].isNormalMap;
						mB3_AtlasPackerRenderTexture.fixOutOfBoundsUVs = data._fixOutOfBoundsUVs;
						mB3_AtlasPackerRenderTexture.considerNonTextureProperties = data._considerNonTextureProperties;
						mB3_AtlasPackerRenderTexture.resultMaterialTextureBlender = data.nonTexturePropertyBlender;
						texture2D = mB3_AtlasPackerRenderTexture.OnRenderAtlas(combiner);
						if (LOG_LEVEL >= MB2_LogLevel.debug)
						{
							UnityEngine.Debug.Log("Saving atlas " + data.texPropertyNames[i].name + " w=" + texture2D.width + " h=" + texture2D.height + " id=" + texture2D.GetInstanceID());
						}
					}
					atlases[i] = texture2D;
					progressInfo?.Invoke("Saving atlas: '" + data.texPropertyNames[i].name + "'", 0.04f);
					if (data._saveAtlasesAsAssets && textureEditorMethods != null)
					{
						textureEditorMethods.SaveAtlasToAssetDatabase(atlases[i], data.texPropertyNames[i], i, data.resultMaterial);
					}
					else
					{
						data.resultMaterial.SetTexture(data.texPropertyNames[i].name, atlases[i]);
					}
					data.resultMaterial.SetTextureOffset(data.texPropertyNames[i].name, Vector2.zero);
					data.resultMaterial.SetTextureScale(data.texPropertyNames[i].name, Vector2.one);
					combiner._destroyTemporaryTextures(data.texPropertyNames[i].name);
				}
			}
			catch (Exception exception)
			{
				UnityEngine.Debug.LogException(exception);
			}
			finally
			{
				if (gameObject != null)
				{
					MB_Utility.Destroy(gameObject);
				}
			}
			yield break;
		}
	}
	internal class MB3_TextureCombinerPackerMeshBakerHorizontalVertical : MB3_TextureCombinerPackerMeshBaker
	{
		private interface IPipeline
		{
			MB2_PackingAlgorithmEnum GetPackingAlg();

			void SortTexSetIntoBins(MB_TexSet texSet, List<MB_TexSet> horizontalVert, List<MB_TexSet> regular, int maxAtlasWidth, int maxAtlasHeight);

			MB_TextureTilingTreatment GetEdge2EdgeTreatment();

			void InitializeAtlasPadding(ref AtlasPadding padding, int paddingValue);

			void MergeAtlasPackingResultStackBonAInternal(AtlasPackingResult a, AtlasPackingResult b, out Rect AatlasToFinal, out Rect BatlasToFinal, bool stretchBToAtlasWidth, int maxWidthDim, int maxHeightDim, out int atlasX, out int atlasY);

			void GetExtraRoomForRegularAtlas(int usedHorizontalVertWidth, int usedHorizontalVertHeight, int maxAtlasWidth, int maxAtlasHeight, out int atlasRegularMaxWidth, out int atlasRegularMaxHeight);
		}

		private class VerticalPipeline : IPipeline
		{
			public MB2_PackingAlgorithmEnum GetPackingAlg()
			{
				return MB2_PackingAlgorithmEnum.MeshBakerTexturePacker_Vertical;
			}

			public void SortTexSetIntoBins(MB_TexSet texSet, List<MB_TexSet> horizontalVert, List<MB_TexSet> regular, int maxAtlasWidth, int maxAtlasHeight)
			{
				if (texSet.idealHeight >= maxAtlasHeight && texSet.ts[0].GetEncapsulatingSamplingRect().height >= 1.0)
				{
					horizontalVert.Add(texSet);
				}
				else
				{
					regular.Add(texSet);
				}
			}

			public MB_TextureTilingTreatment GetEdge2EdgeTreatment()
			{
				return MB_TextureTilingTreatment.edgeToEdgeY;
			}

			public void InitializeAtlasPadding(ref AtlasPadding padding, int paddingValue)
			{
				padding.topBottom = 0;
				padding.leftRight = paddingValue;
			}

			public void MergeAtlasPackingResultStackBonAInternal(AtlasPackingResult a, AtlasPackingResult b, out Rect AatlasToFinal, out Rect BatlasToFinal, bool stretchBToAtlasWidth, int maxWidthDim, int maxHeightDim, out int atlasX, out int atlasY)
			{
				float num = a.usedW + b.usedW;
				if (num > (float)maxWidthDim)
				{
					float num2 = (float)maxWidthDim / num;
					float num3 = (float)Mathf.FloorToInt((float)a.usedW * num2) / (float)maxWidthDim;
					num2 = num3;
					float width = 1f - num3;
					AatlasToFinal = new Rect(0f, 0f, num2, 1f);
					BatlasToFinal = new Rect(num3, 0f, width, 1f);
				}
				else
				{
					float num4 = (float)a.usedW / num;
					AatlasToFinal = new Rect(0f, 0f, num4, 1f);
					BatlasToFinal = new Rect(num4, 0f, (float)b.usedW / num, 1f);
				}
				if (a.atlasX > b.atlasX)
				{
					if (!stretchBToAtlasWidth)
					{
						BatlasToFinal.width = (float)b.atlasX / (float)a.atlasX;
					}
				}
				else if (b.atlasX > a.atlasX)
				{
					AatlasToFinal.width = (float)a.atlasX / (float)b.atlasX;
				}
				atlasX = a.usedW + b.usedW;
				atlasY = Mathf.Max(a.usedH, b.usedH);
			}

			public void GetExtraRoomForRegularAtlas(int usedHorizontalVertWidth, int usedHorizontalVertHeight, int maxAtlasWidth, int maxAtlasHeight, out int atlasRegularMaxWidth, out int atlasRegularMaxHeight)
			{
				atlasRegularMaxWidth = maxAtlasWidth - usedHorizontalVertWidth;
				atlasRegularMaxHeight = maxAtlasHeight;
			}
		}

		private class HorizontalPipeline : IPipeline
		{
			public MB2_PackingAlgorithmEnum GetPackingAlg()
			{
				return MB2_PackingAlgorithmEnum.MeshBakerTexturePacker_Horizontal;
			}

			public void SortTexSetIntoBins(MB_TexSet texSet, List<MB_TexSet> horizontalVert, List<MB_TexSet> regular, int maxAtlasWidth, int maxAtlasHeight)
			{
				if (texSet.idealWidth >= maxAtlasWidth && texSet.ts[0].GetEncapsulatingSamplingRect().width >= 1.0)
				{
					horizontalVert.Add(texSet);
				}
				else
				{
					regular.Add(texSet);
				}
			}

			public MB_TextureTilingTreatment GetEdge2EdgeTreatment()
			{
				return MB_TextureTilingTreatment.edgeToEdgeX;
			}

			public void InitializeAtlasPadding(ref AtlasPadding padding, int paddingValue)
			{
				padding.topBottom = paddingValue;
				padding.leftRight = 0;
			}

			public void MergeAtlasPackingResultStackBonAInternal(AtlasPackingResult a, AtlasPackingResult b, out Rect AatlasToFinal, out Rect BatlasToFinal, bool stretchBToAtlasWidth, int maxWidthDim, int maxHeightDim, out int atlasX, out int atlasY)
			{
				float num = a.usedH + b.usedH;
				if (num > (float)maxHeightDim)
				{
					float num2 = (float)maxHeightDim / num;
					float num3 = (float)Mathf.FloorToInt((float)a.usedH * num2) / (float)maxHeightDim;
					num2 = num3;
					float height = 1f - num3;
					AatlasToFinal = new Rect(0f, 0f, 1f, num2);
					BatlasToFinal = new Rect(0f, num3, 1f, height);
				}
				else
				{
					float num4 = (float)a.usedH / num;
					AatlasToFinal = new Rect(0f, 0f, 1f, num4);
					BatlasToFinal = new Rect(0f, num4, 1f, (float)b.usedH / num);
				}
				if (a.atlasX > b.atlasX)
				{
					if (!stretchBToAtlasWidth)
					{
						BatlasToFinal.width = (float)b.atlasX / (float)a.atlasX;
					}
				}
				else if (b.atlasX > a.atlasX)
				{
					AatlasToFinal.width = (float)a.atlasX / (float)b.atlasX;
				}
				atlasX = Mathf.Max(a.usedW, b.usedW);
				atlasY = a.usedH + b.usedH;
			}

			public void GetExtraRoomForRegularAtlas(int usedHorizontalVertWidth, int usedHorizontalVertHeight, int maxAtlasWidth, int maxAtlasHeight, out int atlasRegularMaxWidth, out int atlasRegularMaxHeight)
			{
				atlasRegularMaxWidth = maxAtlasWidth;
				atlasRegularMaxHeight = maxAtlasHeight - usedHorizontalVertHeight;
			}
		}

		public enum AtlasDirection
		{
			horizontal,
			vertical
		}

		private AtlasDirection _atlasDirection;

		public MB3_TextureCombinerPackerMeshBakerHorizontalVertical(AtlasDirection ad)
		{
			_atlasDirection = ad;
		}

		public override AtlasPackingResult[] CalculateAtlasRectangles(MB3_TextureCombinerPipeline.TexturePipelineData data, bool doMultiAtlas, MB2_LogLevel LOG_LEVEL)
		{
			IPipeline pipeline = ((_atlasDirection != 0) ? ((IPipeline)new VerticalPipeline()) : ((IPipeline)new HorizontalPipeline()));
			UnityEngine.Debug.LogError("TODO handle max atlas dimension when not using override");
			if (_atlasDirection == AtlasDirection.horizontal)
			{
				if (!data._useMaxAtlasWidthOverride)
				{
					int num = 2;
					for (int i = 0; i < data.distinctMaterialTextures.Count; i++)
					{
						MB_TexSet mB_TexSet = data.distinctMaterialTextures[i];
						int num2 = ((!data._fixOutOfBoundsUVs) ? mB_TexSet.idealWidth : ((int)mB_TexSet.GetMaxRawTextureHeightWidth().x));
						if (mB_TexSet.idealWidth > num)
						{
							num = num2;
						}
					}
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						UnityEngine.Debug.Log("Calculated max atlas width: " + num);
					}
					data._maxAtlasWidth = num;
				}
			}
			else if (!data._useMaxAtlasHeightOverride)
			{
				int num3 = 2;
				for (int j = 0; j < data.distinctMaterialTextures.Count; j++)
				{
					MB_TexSet mB_TexSet2 = data.distinctMaterialTextures[j];
					int num4 = ((!data._fixOutOfBoundsUVs) ? mB_TexSet2.idealHeight : ((int)mB_TexSet2.GetMaxRawTextureHeightWidth().y));
					if (mB_TexSet2.idealHeight > num3)
					{
						num3 = num4;
					}
				}
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					UnityEngine.Debug.Log("Calculated max atlas height: " + num3);
				}
				data._maxAtlasHeight = num3;
			}
			List<MB_TexSet> list = new List<MB_TexSet>();
			List<MB_TexSet> list2 = new List<MB_TexSet>();
			for (int k = 0; k < data.distinctMaterialTextures.Count; k++)
			{
				pipeline.SortTexSetIntoBins(data.distinctMaterialTextures[k], list, list2, data._maxAtlasWidth, data._maxAtlasHeight);
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log($"Splitting list of distinctMaterialTextures numHorizontalVertical={list.Count} numRegular={list2.Count} maxAtlasWidth={data._maxAtlasWidth} maxAtlasHeight={data._maxAtlasHeight}");
			}
			AtlasPackingResult[] array;
			if (list.Count > 0)
			{
				MB2_PackingAlgorithmEnum packingAlg = pipeline.GetPackingAlg();
				List<Vector2> list3 = new List<Vector2>();
				for (int l = 0; l < list.Count; l++)
				{
					list[l].SetTilingTreatmentAndAdjustEncapsulatingSamplingRect(pipeline.GetEdge2EdgeTreatment());
					list3.Add(new Vector2(list[l].idealWidth, list[l].idealHeight));
				}
				MB2_TexturePacker mB2_TexturePacker = MB3_TextureCombinerPipeline.CreateTexturePacker(packingAlg);
				mB2_TexturePacker.atlasMustBePowerOfTwo = false;
				List<AtlasPadding> list4 = new List<AtlasPadding>();
				for (int m = 0; m < list3.Count; m++)
				{
					AtlasPadding padding = default(AtlasPadding);
					pipeline.InitializeAtlasPadding(ref padding, data._atlasPadding);
					list4.Add(padding);
				}
				mB2_TexturePacker.LOG_LEVEL = MB2_LogLevel.trace;
				array = mB2_TexturePacker.GetRects(list3, list4, data._maxAtlasWidth, data._maxAtlasHeight, doMultiAtlas: false);
				if (LOG_LEVEL >= MB2_LogLevel.trace)
				{
					UnityEngine.Debug.Log($"Packed {list.Count} textures with edgeToEdge tiling into an atlas of size {array[0].atlasX} by {array[0].atlasY} usedW {array[0].usedW} usedH {array[0].usedH}");
				}
			}
			else
			{
				array = new AtlasPackingResult[0];
			}
			AtlasPackingResult[] array2;
			if (list2.Count > 0)
			{
				MB2_PackingAlgorithmEnum packingAlg = MB2_PackingAlgorithmEnum.MeshBakerTexturePacker;
				List<Vector2> list5 = new List<Vector2>();
				for (int n = 0; n < list2.Count; n++)
				{
					list5.Add(new Vector2(list2[n].idealWidth, list2[n].idealHeight));
				}
				MB2_TexturePacker mB2_TexturePacker = MB3_TextureCombinerPipeline.CreateTexturePacker(MB2_PackingAlgorithmEnum.MeshBakerTexturePacker);
				mB2_TexturePacker.atlasMustBePowerOfTwo = false;
				List<AtlasPadding> list6 = new List<AtlasPadding>();
				for (int num5 = 0; num5 < list5.Count; num5++)
				{
					AtlasPadding item = default(AtlasPadding);
					item.topBottom = data._atlasPadding;
					item.leftRight = data._atlasPadding;
					list6.Add(item);
				}
				int usedHorizontalVertWidth = 0;
				int usedHorizontalVertHeight = 0;
				if (array.Length != 0)
				{
					usedHorizontalVertHeight = array[0].atlasY;
					usedHorizontalVertWidth = array[0].atlasX;
				}
				pipeline.GetExtraRoomForRegularAtlas(usedHorizontalVertWidth, usedHorizontalVertHeight, data._maxAtlasWidth, data._maxAtlasHeight, out var atlasRegularMaxWidth, out var atlasRegularMaxHeight);
				array2 = mB2_TexturePacker.GetRects(list5, list6, atlasRegularMaxWidth, atlasRegularMaxHeight, doMultiAtlas: false);
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					UnityEngine.Debug.Log($"Packed {list2.Count} textures without edgeToEdge tiling into an atlas of size {array2[0].atlasX} by {array2[0].atlasY} usedW {array2[0].usedW} usedH {array2[0].usedH}");
				}
			}
			else
			{
				array2 = new AtlasPackingResult[0];
			}
			AtlasPackingResult atlasPackingResult = null;
			if (array.Length == 0 && array2.Length == 0)
			{
				return null;
			}
			if (array.Length != 0 && array2.Length != 0)
			{
				atlasPackingResult = MergeAtlasPackingResultStackBonA(array[0], array2[0], data._maxAtlasWidth, data._maxAtlasHeight, stretchBToAtlasWidth: true, pipeline);
			}
			else if (array.Length != 0)
			{
				atlasPackingResult = array[0];
			}
			else if (array2.Length != 0)
			{
				atlasPackingResult = array2[0];
			}
			list.AddRange(list2);
			data.distinctMaterialTextures = list;
			if (atlasPackingResult != null)
			{
				return new AtlasPackingResult[1] { atlasPackingResult };
			}
			return new AtlasPackingResult[0];
		}

		public static AtlasPackingResult TestStackRectanglesHorizontal(AtlasPackingResult a, AtlasPackingResult b, int maxHeightDim, int maxWidthDim, bool stretchBToAtlasWidth)
		{
			return MergeAtlasPackingResultStackBonA(a, b, maxWidthDim, maxHeightDim, stretchBToAtlasWidth, new HorizontalPipeline());
		}

		public static AtlasPackingResult TestStackRectanglesVertical(AtlasPackingResult a, AtlasPackingResult b, int maxHeightDim, int maxWidthDim, bool stretchBToAtlasWidth)
		{
			return MergeAtlasPackingResultStackBonA(a, b, maxWidthDim, maxHeightDim, stretchBToAtlasWidth, new VerticalPipeline());
		}

		private static AtlasPackingResult MergeAtlasPackingResultStackBonA(AtlasPackingResult a, AtlasPackingResult b, int maxWidthDim, int maxHeightDim, bool stretchBToAtlasWidth, IPipeline pipeline)
		{
			pipeline.MergeAtlasPackingResultStackBonAInternal(a, b, out var AatlasToFinal, out var BatlasToFinal, stretchBToAtlasWidth, maxWidthDim, maxHeightDim, out var atlasX, out var atlasY);
			Rect[] array = new Rect[a.rects.Length + b.rects.Length];
			AtlasPadding[] array2 = new AtlasPadding[a.rects.Length + b.rects.Length];
			int[] array3 = new int[a.rects.Length + b.rects.Length];
			Array.Copy(a.padding, array2, a.padding.Length);
			Array.Copy(b.padding, 0, array2, a.padding.Length, b.padding.Length);
			Array.Copy(a.srcImgIdxs, array3, a.srcImgIdxs.Length);
			Array.Copy(b.srcImgIdxs, 0, array3, a.srcImgIdxs.Length, b.srcImgIdxs.Length);
			Array.Copy(a.rects, array, a.rects.Length);
			for (int i = 0; i < a.rects.Length; i++)
			{
				Rect rect = a.rects[i];
				rect.x = AatlasToFinal.x + rect.x * AatlasToFinal.width;
				rect.y = AatlasToFinal.y + rect.y * AatlasToFinal.height;
				rect.width *= AatlasToFinal.width;
				rect.height *= AatlasToFinal.height;
				array[i] = rect;
				array3[i] = a.srcImgIdxs[i];
			}
			for (int j = 0; j < b.rects.Length; j++)
			{
				Rect rect2 = b.rects[j];
				rect2.x = BatlasToFinal.x + rect2.x * BatlasToFinal.width;
				rect2.y = BatlasToFinal.y + rect2.y * BatlasToFinal.height;
				rect2.width *= BatlasToFinal.width;
				rect2.height *= BatlasToFinal.height;
				array[a.rects.Length + j] = rect2;
				array3[a.rects.Length + j] = b.srcImgIdxs[j];
			}
			AtlasPackingResult atlasPackingResult = new AtlasPackingResult(array2);
			atlasPackingResult.atlasX = atlasX;
			atlasPackingResult.atlasY = atlasY;
			atlasPackingResult.padding = array2;
			atlasPackingResult.rects = array;
			atlasPackingResult.srcImgIdxs = array3;
			atlasPackingResult.CalcUsedWidthAndHeight();
			return atlasPackingResult;
		}
	}
	internal class MB3_TextureCombinerPackerOneTextureInAtlas : MB_ITextureCombinerPacker
	{
		public IEnumerator ConvertTexturesToReadableFormats(ProgressUpdateDelegate progressInfo, MB3_TextureCombiner.CombineTexturesIntoAtlasesCoroutineResult result, MB3_TextureCombinerPipeline.TexturePipelineData data, MB3_TextureCombiner combiner, MB2_EditorMethodsInterface textureEditorMethods, MB2_LogLevel LOG_LEVEL)
		{
			yield break;
		}

		public AtlasPackingResult[] CalculateAtlasRectangles(MB3_TextureCombinerPipeline.TexturePipelineData data, bool doMultiAtlas, MB2_LogLevel LOG_LEVEL)
		{
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Only one image per atlas. Will re-use original texture");
			}
			AtlasPackingResult[] array = new AtlasPackingResult[1];
			AtlasPadding[] pds = new AtlasPadding[1]
			{
				new AtlasPadding(data._atlasPadding)
			};
			array[0] = new AtlasPackingResult(pds);
			array[0].rects = new Rect[1];
			array[0].srcImgIdxs = new int[1];
			array[0].rects[0] = new Rect(0f, 0f, 1f, 1f);
			MeshBakerMaterialTexture meshBakerMaterialTexture = null;
			if (data.distinctMaterialTextures[0].ts.Length != 0)
			{
				meshBakerMaterialTexture = data.distinctMaterialTextures[0].ts[0];
			}
			if (meshBakerMaterialTexture == null || meshBakerMaterialTexture.isNull)
			{
				array[0].atlasX = 16;
				array[0].atlasY = 16;
				array[0].usedW = 16;
				array[0].usedH = 16;
			}
			else
			{
				array[0].atlasX = meshBakerMaterialTexture.width;
				array[0].atlasY = meshBakerMaterialTexture.height;
				array[0].usedW = meshBakerMaterialTexture.width;
				array[0].usedH = meshBakerMaterialTexture.height;
			}
			return array;
		}

		public IEnumerator CreateAtlases(ProgressUpdateDelegate progressInfo, MB3_TextureCombinerPipeline.TexturePipelineData data, MB3_TextureCombiner combiner, AtlasPackingResult packedAtlasRects, Texture2D[] atlases, MB2_EditorMethodsInterface textureEditorMethods, MB2_LogLevel LOG_LEVEL)
		{
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Only one image per atlas. Will re-use original texture");
			}
			for (int i = 0; i < data.numAtlases; i++)
			{
				MeshBakerMaterialTexture meshBakerMaterialTexture = data.distinctMaterialTextures[0].ts[i];
				atlases[i] = meshBakerMaterialTexture.GetTexture2D();
				data.resultMaterial.SetTexture(data.texPropertyNames[i].name, atlases[i]);
				data.resultMaterial.SetTextureScale(data.texPropertyNames[i].name, Vector2.one);
				data.resultMaterial.SetTextureOffset(data.texPropertyNames[i].name, Vector2.zero);
			}
			yield break;
		}
	}
	internal class MB3_TextureCombinerPackerUnity : MB3_TextureCombinerPackerRoot
	{
		public override AtlasPackingResult[] CalculateAtlasRectangles(MB3_TextureCombinerPipeline.TexturePipelineData data, bool doMultiAtlas, MB2_LogLevel LOG_LEVEL)
		{
			return new AtlasPackingResult[1]
			{
				new AtlasPackingResult(new AtlasPadding[0])
			};
		}

		public override IEnumerator CreateAtlases(ProgressUpdateDelegate progressInfo, MB3_TextureCombinerPipeline.TexturePipelineData data, MB3_TextureCombiner combiner, AtlasPackingResult packedAtlasRects, Texture2D[] atlases, MB2_EditorMethodsInterface textureEditorMethods, MB2_LogLevel LOG_LEVEL)
		{
			_ = packedAtlasRects.rects;
			long num = 0L;
			int w = 1;
			int h = 1;
			Rect[] array = null;
			for (int i = 0; i < data.numAtlases; i++)
			{
				ShaderTextureProperty shaderTextureProperty = data.texPropertyNames[i];
				Texture2D texture2D;
				if (!MB3_TextureCombinerPipeline._ShouldWeCreateAtlasForThisProperty(i, data._considerNonTextureProperties, data.allTexturesAreNullAndSameColor))
				{
					texture2D = null;
				}
				else
				{
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						UnityEngine.Debug.LogWarning("Beginning loop " + i + " num temporary textures " + combiner._getNumTemporaryTextures());
					}
					MB3_TextureCombinerPackerRoot.CreateTemporaryTexturesForAtlas(data.distinctMaterialTextures, combiner, i, data);
					Texture2D[] array2 = new Texture2D[data.distinctMaterialTextures.Count];
					for (int j = 0; j < data.distinctMaterialTextures.Count; j++)
					{
						MB_TexSet mB_TexSet = data.distinctMaterialTextures[j];
						int idealWidth = mB_TexSet.idealWidth;
						int idealHeight = mB_TexSet.idealHeight;
						Texture2D texture2D2 = mB_TexSet.ts[i].GetTexture2D();
						progressInfo?.Invoke("Adjusting for scale and offset " + texture2D2, 0.01f);
						textureEditorMethods?.SetReadWriteFlag(texture2D2, isReadable: true, addToList: true);
						texture2D2 = GetAdjustedForScaleAndOffset2(shaderTextureProperty.name, mB_TexSet.ts[i], mB_TexSet.obUVoffset, mB_TexSet.obUVscale, data, combiner, LOG_LEVEL);
						if (texture2D2.width != idealWidth || texture2D2.height != idealHeight)
						{
							progressInfo?.Invoke(string.Concat("Resizing texture '", texture2D2, "'"), 0.01f);
							if (LOG_LEVEL >= MB2_LogLevel.debug)
							{
								UnityEngine.Debug.LogWarning("Copying and resizing texture " + shaderTextureProperty.name + " from " + texture2D2.width + "x" + texture2D2.height + " to " + idealWidth + "x" + idealHeight);
							}
							texture2D2 = combiner._resizeTexture(shaderTextureProperty.name, texture2D2, idealWidth, idealHeight);
						}
						num += texture2D2.width * texture2D2.height;
						if (data._considerNonTextureProperties)
						{
							texture2D2 = combiner._createTextureCopy(shaderTextureProperty.name, texture2D2);
							data.nonTexturePropertyBlender.TintTextureWithTextureCombiner(texture2D2, data.distinctMaterialTextures[j], shaderTextureProperty);
						}
						array2[j] = texture2D2;
					}
					textureEditorMethods?.CheckBuildSettings(num);
					if (Math.Sqrt(num) > 3500.0 && LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning("The maximum possible atlas size is 4096. Textures may be shrunk");
					}
					texture2D = new Texture2D(1, 1, TextureFormat.ARGB32, mipChain: true);
					progressInfo?.Invoke("Packing texture atlas " + shaderTextureProperty.name, 0.25f);
					if (i == 0)
					{
						progressInfo?.Invoke("Estimated min size of atlases: " + Math.Sqrt(num).ToString("F0"), 0.1f);
						if (LOG_LEVEL >= MB2_LogLevel.info)
						{
							UnityEngine.Debug.Log("Estimated atlas minimum size:" + Math.Sqrt(num).ToString("F0"));
						}
						int maximumAtlasSize = 4096;
						array = texture2D.PackTextures(array2, data._atlasPadding, maximumAtlasSize, makeNoLongerReadable: false);
						if (LOG_LEVEL >= MB2_LogLevel.info)
						{
							UnityEngine.Debug.Log("After pack textures atlas size " + texture2D.width + " " + texture2D.height);
						}
						w = texture2D.width;
						h = texture2D.height;
						texture2D.Apply();
					}
					else
					{
						progressInfo?.Invoke("Copying Textures Into: " + shaderTextureProperty.name, 0.1f);
						texture2D = _copyTexturesIntoAtlas(array2, data._atlasPadding, array, w, h, combiner);
					}
				}
				atlases[i] = texture2D;
				if (data._saveAtlasesAsAssets)
				{
					textureEditorMethods?.SaveAtlasToAssetDatabase(atlases[i], shaderTextureProperty, i, data.resultMaterial);
				}
				data.resultMaterial.SetTextureOffset(shaderTextureProperty.name, Vector2.zero);
				data.resultMaterial.SetTextureScale(shaderTextureProperty.name, Vector2.one);
				combiner._destroyTemporaryTextures(shaderTextureProperty.name);
				GC.Collect();
			}
			packedAtlasRects.rects = array;
			yield break;
		}

		internal static Texture2D _copyTexturesIntoAtlas(Texture2D[] texToPack, int padding, Rect[] rs, int w, int h, MB3_TextureCombiner combiner)
		{
			Texture2D texture2D = new Texture2D(w, h, TextureFormat.ARGB32, mipChain: true);
			MB_Utility.setSolidColor(texture2D, UnityEngine.Color.clear);
			for (int i = 0; i < rs.Length; i++)
			{
				Rect rect = rs[i];
				Texture2D texture2D2 = texToPack[i];
				Texture2D texture2D3 = null;
				int x = Mathf.RoundToInt(rect.x * (float)w);
				int y = Mathf.RoundToInt(rect.y * (float)h);
				int num = Mathf.RoundToInt(rect.width * (float)w);
				int num2 = Mathf.RoundToInt(rect.height * (float)h);
				if (texture2D2.width != num && texture2D2.height != num2)
				{
					texture2D3 = (texture2D2 = MB_Utility.resampleTexture(texture2D2, num, num2));
				}
				texture2D.SetPixels(x, y, num, num2, texture2D2.GetPixels());
				if (texture2D3 != null)
				{
					MB_Utility.Destroy(texture2D3);
				}
			}
			texture2D.Apply();
			return texture2D;
		}

		internal static Texture2D GetAdjustedForScaleAndOffset2(string propertyName, MeshBakerMaterialTexture source, Vector2 obUVoffset, Vector2 obUVscale, MB3_TextureCombinerPipeline.TexturePipelineData data, MB3_TextureCombiner combiner, MB2_LogLevel LOG_LEVEL)
		{
			Texture2D texture2D = source.GetTexture2D();
			if (source.matTilingRect.x == 0.0 && source.matTilingRect.y == 0.0 && source.matTilingRect.width == 1.0 && source.matTilingRect.height == 1.0)
			{
				if (!data._fixOutOfBoundsUVs)
				{
					return texture2D;
				}
				if (obUVoffset.x == 0f && obUVoffset.y == 0f && obUVscale.x == 1f && obUVscale.y == 1f)
				{
					return texture2D;
				}
			}
			Vector2 adjustedForScaleAndOffset2Dimensions = MB3_TextureCombinerPipeline.GetAdjustedForScaleAndOffset2Dimensions(source, obUVoffset, obUVscale, data, LOG_LEVEL);
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.LogWarning(string.Concat("GetAdjustedForScaleAndOffset2: ", texture2D, " ", obUVoffset, " ", obUVscale));
			}
			float x = adjustedForScaleAndOffset2Dimensions.x;
			float y = adjustedForScaleAndOffset2Dimensions.y;
			float num = (float)source.matTilingRect.width;
			float num2 = (float)source.matTilingRect.height;
			float num3 = (float)source.matTilingRect.x;
			float num4 = (float)source.matTilingRect.y;
			if (data._fixOutOfBoundsUVs)
			{
				num *= obUVscale.x;
				num2 *= obUVscale.y;
				num3 = (float)(source.matTilingRect.x * (double)obUVscale.x + (double)obUVoffset.x);
				num4 = (float)(source.matTilingRect.y * (double)obUVscale.y + (double)obUVoffset.y);
			}
			Texture2D texture2D2 = combiner._createTemporaryTexture(propertyName, (int)x, (int)y, TextureFormat.ARGB32, mipMaps: true);
			for (int i = 0; i < texture2D2.width; i++)
			{
				for (int j = 0; j < texture2D2.height; j++)
				{
					float x2 = (float)i / x * num + num3;
					float y2 = (float)j / y * num2 + num4;
					texture2D2.SetPixel(i, j, texture2D.GetPixelBilinear(x2, y2));
				}
			}
			texture2D2.Apply();
			return texture2D2;
		}
	}
	public class MB3_TextureCombinerPipeline
	{
		public struct CreateAtlasForProperty
		{
			public bool allTexturesAreNull;

			public bool allTexturesAreSame;

			public bool allNonTexturePropsAreSame;

			public override string ToString()
			{
				return $"AllTexturesNull={allTexturesAreNull} areSame={allTexturesAreSame} nonTexPropsAreSame={allNonTexturePropsAreSame}";
			}
		}

		internal class TexturePipelineData
		{
			internal MB2_TextureBakeResults _textureBakeResults;

			internal int _atlasPadding = 1;

			internal int _maxAtlasWidth = 1;

			internal int _maxAtlasHeight = 1;

			internal bool _useMaxAtlasHeightOverride;

			internal bool _useMaxAtlasWidthOverride;

			internal bool _resizePowerOfTwoTextures;

			internal bool _fixOutOfBoundsUVs;

			internal int _maxTilingBakeSize = 1024;

			internal bool _saveAtlasesAsAssets;

			internal MB2_PackingAlgorithmEnum _packingAlgorithm;

			internal bool _meshBakerTexturePackerForcePowerOfTwo = true;

			internal List<ShaderTextureProperty> _customShaderPropNames = new List<ShaderTextureProperty>();

			internal bool _normalizeTexelDensity;

			internal bool _considerNonTextureProperties;

			internal MB3_TextureCombinerNonTextureProperties nonTexturePropertyBlender;

			internal List<MB_TexSet> distinctMaterialTextures;

			internal List<GameObject> allObjsToMesh;

			internal List<Material> allowedMaterialsFilter;

			internal List<ShaderTextureProperty> texPropertyNames;

			internal CreateAtlasForProperty[] allTexturesAreNullAndSameColor;

			internal Material resultMaterial;

			internal int numAtlases
			{
				get
				{
					if (texPropertyNames != null)
					{
						return texPropertyNames.Count;
					}
					return 0;
				}
			}

			internal bool OnlyOneTextureInAtlasReuseTextures()
			{
				if (distinctMaterialTextures != null && distinctMaterialTextures.Count == 1 && distinctMaterialTextures[0].thisIsOnlyTexSetInAtlas && !_fixOutOfBoundsUVs && !_considerNonTextureProperties)
				{
					return true;
				}
				return false;
			}
		}

		public static bool USE_EXPERIMENTAL_HOIZONTALVERTICAL = true;

		public static ShaderTextureProperty[] shaderTexPropertyNames = new ShaderTextureProperty[19]
		{
			new ShaderTextureProperty("_MainTex", norm: false),
			new ShaderTextureProperty("_BumpMap", norm: true),
			new ShaderTextureProperty("_Normal", norm: true),
			new ShaderTextureProperty("_BumpSpecMap", norm: false),
			new ShaderTextureProperty("_DecalTex", norm: false),
			new ShaderTextureProperty("_Detail", norm: false),
			new ShaderTextureProperty("_GlossMap", norm: false),
			new ShaderTextureProperty("_Illum", norm: false),
			new ShaderTextureProperty("_LightTextureB0", norm: false),
			new ShaderTextureProperty("_ParallaxMap", norm: false),
			new ShaderTextureProperty("_ShadowOffset", norm: false),
			new ShaderTextureProperty("_TranslucencyMap", norm: false),
			new ShaderTextureProperty("_SpecMap", norm: false),
			new ShaderTextureProperty("_SpecGlossMap", norm: false),
			new ShaderTextureProperty("_TranspMap", norm: false),
			new ShaderTextureProperty("_MetallicGlossMap", norm: false),
			new ShaderTextureProperty("_OcclusionMap", norm: false),
			new ShaderTextureProperty("_EmissionMap", norm: false),
			new ShaderTextureProperty("_DetailMask", norm: false)
		};

		internal static bool _ShouldWeCreateAtlasForThisProperty(int propertyIndex, bool considerNonTextureProperties, CreateAtlasForProperty[] allTexturesAreNullAndSameColor)
		{
			CreateAtlasForProperty createAtlasForProperty = allTexturesAreNullAndSameColor[propertyIndex];
			if (considerNonTextureProperties)
			{
				if (!createAtlasForProperty.allNonTexturePropsAreSame || !createAtlasForProperty.allTexturesAreNull)
				{
					return true;
				}
				return false;
			}
			if (!createAtlasForProperty.allTexturesAreNull)
			{
				return true;
			}
			return false;
		}

		internal static bool _CollectPropertyNames(TexturePipelineData data, MB2_LogLevel LOG_LEVEL)
		{
			int i;
			for (i = 0; i < data.texPropertyNames.Count; i++)
			{
				ShaderTextureProperty shaderTextureProperty = data._customShaderPropNames.Find((ShaderTextureProperty x) => x.name.Equals(data.texPropertyNames[i].name));
				if (shaderTextureProperty != null)
				{
					data._customShaderPropNames.Remove(shaderTextureProperty);
				}
			}
			Material resultMaterial = data.resultMaterial;
			if (resultMaterial == null)
			{
				UnityEngine.Debug.LogError("Please assign a result material. The combined mesh will use this material.");
				return false;
			}
			string text = "";
			for (int j = 0; j < shaderTexPropertyNames.Length; j++)
			{
				if (resultMaterial.HasProperty(shaderTexPropertyNames[j].name))
				{
					text = text + ", " + shaderTexPropertyNames[j].name;
					if (!data.texPropertyNames.Contains(shaderTexPropertyNames[j]))
					{
						data.texPropertyNames.Add(shaderTexPropertyNames[j]);
					}
					if (resultMaterial.GetTextureOffset(shaderTexPropertyNames[j].name) != new Vector2(0f, 0f) && LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning("Result material has non-zero offset. This is may be incorrect.");
					}
					if (resultMaterial.GetTextureScale(shaderTexPropertyNames[j].name) != new Vector2(1f, 1f) && LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning("Result material should have tiling of 1,1");
					}
				}
			}
			for (int k = 0; k < data._customShaderPropNames.Count; k++)
			{
				if (resultMaterial.HasProperty(data._customShaderPropNames[k].name))
				{
					text = text + ", " + data._customShaderPropNames[k].name;
					data.texPropertyNames.Add(data._customShaderPropNames[k]);
					if (resultMaterial.GetTextureOffset(data._customShaderPropNames[k].name) != new Vector2(0f, 0f) && LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning("Result material has non-zero offset. This is probably incorrect.");
					}
					if (resultMaterial.GetTextureScale(data._customShaderPropNames[k].name) != new Vector2(1f, 1f) && LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning("Result material should probably have tiling of 1,1.");
					}
				}
				else if (LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Result material shader does not use property " + data._customShaderPropNames[k].name + " in the list of custom shader property names");
				}
			}
			return true;
		}

		internal static bool _ShouldWeCreateAtlasForThisProperty(int propertyIndex, CreateAtlasForProperty[] allTexturesAreNullAndSameColor, TexturePipelineData data)
		{
			CreateAtlasForProperty createAtlasForProperty = allTexturesAreNullAndSameColor[propertyIndex];
			if (data._considerNonTextureProperties)
			{
				if (!createAtlasForProperty.allNonTexturePropsAreSame || !createAtlasForProperty.allTexturesAreNull)
				{
					return true;
				}
				return false;
			}
			if (!createAtlasForProperty.allTexturesAreNull)
			{
				return true;
			}
			return false;
		}

		public static Texture GetTextureConsideringStandardShaderKeywords(string shaderName, Material mat, string propertyName)
		{
			if ((shaderName.Equals("Standard") || shaderName.Equals("Standard (Specular setup)") || shaderName.Equals("Standard (Roughness setup")) && propertyName.Equals("_EmissionMap"))
			{
				if (mat.IsKeywordEnabled("_EMISSION"))
				{
					return mat.GetTexture(propertyName);
				}
				return null;
			}
			return mat.GetTexture(propertyName);
		}

		internal static IEnumerator __Step1_CollectDistinctMatTexturesAndUsedObjects(ProgressUpdateDelegate progressInfo, MB3_TextureCombiner.CombineTexturesIntoAtlasesCoroutineResult result, TexturePipelineData data, MB3_TextureCombiner combiner, MB2_EditorMethodsInterface textureEditorMethods, List<GameObject> usedObjsToMesh, MB2_LogLevel LOG_LEVEL)
		{
			Stopwatch stopwatch = new Stopwatch();
			stopwatch.Start();
			bool flag = false;
			Dictionary<int, MB_Utility.MeshAnalysisResult[]> dictionary = new Dictionary<int, MB_Utility.MeshAnalysisResult[]>();
			for (int i = 0; i < data.allObjsToMesh.Count; i++)
			{
				GameObject gameObject = data.allObjsToMesh[i];
				progressInfo?.Invoke("Collecting textures for " + gameObject, (float)i / (float)data.allObjsToMesh.Count / 2f);
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					UnityEngine.Debug.Log("Collecting textures for object " + gameObject);
				}
				if (gameObject == null)
				{
					UnityEngine.Debug.LogError("The list of objects to mesh contained nulls.");
					result.success = false;
					yield break;
				}
				Mesh mesh = MB_Utility.GetMesh(gameObject);
				if (mesh == null)
				{
					UnityEngine.Debug.LogError("Object " + gameObject.name + " in the list of objects to mesh has no mesh.");
					result.success = false;
					yield break;
				}
				Material[] gOMaterials = MB_Utility.GetGOMaterials(gameObject);
				if (gOMaterials.Length == 0)
				{
					UnityEngine.Debug.LogError("Object " + gameObject.name + " in the list of objects has no materials.");
					result.success = false;
					yield break;
				}
				if (!dictionary.TryGetValue(mesh.GetInstanceID(), out var value))
				{
					value = new MB_Utility.MeshAnalysisResult[mesh.subMeshCount];
					for (int j = 0; j < mesh.subMeshCount; j++)
					{
						MB_Utility.hasOutOfBoundsUVs(mesh, ref value[j], j);
						if (data._normalizeTexelDensity)
						{
							value[j].submeshArea = GetSubmeshArea(mesh, j);
						}
						if (data._fixOutOfBoundsUVs && !value[j].hasUVs)
						{
							value[j].uvRect = new Rect(0f, 0f, 1f, 1f);
							UnityEngine.Debug.LogWarning(string.Concat("Mesh for object ", gameObject, " has no UV channel but 'consider UVs' is enabled. Assuming UVs will be generated filling 0,0,1,1 rectangle."));
						}
					}
					dictionary.Add(mesh.GetInstanceID(), value);
				}
				if (data._fixOutOfBoundsUVs && LOG_LEVEL >= MB2_LogLevel.trace)
				{
					UnityEngine.Debug.Log(string.Concat("Mesh Analysis for object ", gameObject, " numSubmesh=", value.Length, " HasOBUV=", value[0].hasOutOfBoundsUVs.ToString(), " UVrectSubmesh0=", value[0].uvRect));
				}
				for (int k = 0; k < gOMaterials.Length; k++)
				{
					progressInfo?.Invoke($"Collecting textures for {gameObject} submesh {k}", (float)i / (float)data.allObjsToMesh.Count / 2f);
					Material material = gOMaterials[k];
					if (data.allowedMaterialsFilter != null && !data.allowedMaterialsFilter.Contains(material))
					{
						continue;
					}
					flag = flag || value[k].hasOutOfBoundsUVs;
					if (material.name.Contains("(Instance)"))
					{
						UnityEngine.Debug.LogError("The sharedMaterial on object " + gameObject.name + " has been 'Instanced'. This was probably caused by a script accessing the meshRender.material property in the editor.  The material to UV Rectangle mapping will be incorrect. To fix this recreate the object from its prefab or re-assign its material from the correct asset.");
						result.success = false;
						yield break;
					}
					if (data._fixOutOfBoundsUVs && !MB_Utility.AreAllSharedMaterialsDistinct(gOMaterials) && LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning("Object " + gameObject.name + " uses the same material on multiple submeshes. This may generate strange resultAtlasesAndRects especially when used with fix out of bounds uvs. Try duplicating the material.");
					}
					MeshBakerMaterialTexture[] array = new MeshBakerMaterialTexture[data.texPropertyNames.Count];
					for (int l = 0; l < data.texPropertyNames.Count; l++)
					{
						Texture texture = null;
						Vector2 matTilingScale = Vector2.one;
						Vector2 matTilingOffset = Vector2.zero;
						float texelDens = 0f;
						if (material.HasProperty(data.texPropertyNames[l].name))
						{
							Texture textureConsideringStandardShaderKeywords = GetTextureConsideringStandardShaderKeywords(data.resultMaterial.shader.name, material, data.texPropertyNames[l].name);
							if (textureConsideringStandardShaderKeywords != null)
							{
								if (!(textureConsideringStandardShaderKeywords is Texture2D))
								{
									UnityEngine.Debug.LogError("Object " + gameObject.name + " in the list of objects to mesh uses a Texture that is not a Texture2D. Cannot build atlases.");
									result.success = false;
									yield break;
								}
								texture = textureConsideringStandardShaderKeywords;
								TextureFormat format = ((Texture2D)texture).format;
								bool flag2 = false;
								if (!Application.isPlaying && textureEditorMethods != null)
								{
									flag2 = textureEditorMethods.IsNormalMap((Texture2D)texture);
								}
								if ((format != TextureFormat.ARGB32 && format != TextureFormat.RGBA32 && format != TextureFormat.BGRA32 && format != TextureFormat.RGB24 && format != TextureFormat.Alpha8) || flag2)
								{
									if (Application.isPlaying && data._packingAlgorithm != MB2_PackingAlgorithmEnum.MeshBakerTexturePacker_Fast)
									{
										UnityEngine.Debug.LogError(string.Concat("Object ", gameObject.name, " in the list of objects to mesh uses Texture ", texture.name, " uses format ", format, " that is not in: ARGB32, RGBA32, BGRA32, RGB24, Alpha8 or DXT. These textures cannot be resized at runtime. Try changing texture format. If format says 'compressed' try changing it to 'truecolor'"));
										result.success = false;
										yield break;
									}
									texture = (Texture2D)material.GetTexture(data.texPropertyNames[l].name);
								}
							}
							if (texture != null && data._normalizeTexelDensity)
							{
								texelDens = ((value[l].submeshArea != 0f) ? ((float)(texture.width * texture.height) / value[l].submeshArea) : 0f);
							}
							matTilingScale = material.GetTextureScale(data.texPropertyNames[l].name);
							matTilingOffset = material.GetTextureOffset(data.texPropertyNames[l].name);
						}
						array[l] = new MeshBakerMaterialTexture(texture, matTilingOffset, matTilingScale, texelDens);
					}
					data.nonTexturePropertyBlender.CollectAverageValuesOfNonTextureProperties(data.resultMaterial, material);
					Vector2 vector = new Vector2(value[k].uvRect.width, value[k].uvRect.height);
					Vector2 vector2 = new Vector2(value[k].uvRect.x, value[k].uvRect.y);
					MB_TextureTilingTreatment treatment = MB_TextureTilingTreatment.none;
					if (data._fixOutOfBoundsUVs)
					{
						treatment = MB_TextureTilingTreatment.considerUVs;
					}
					MB_TexSet setOfTexs = new MB_TexSet(array, vector2, vector, treatment);
					MatAndTransformToMerged item = new MatAndTransformToMerged(new DRect(vector2, vector), data._fixOutOfBoundsUVs, material);
					setOfTexs.matsAndGOs.mats.Add(item);
					MB_TexSet mB_TexSet = data.distinctMaterialTextures.Find((MB_TexSet x) => x.IsEqual(setOfTexs, data._fixOutOfBoundsUVs, data.nonTexturePropertyBlender));
					if (mB_TexSet != null)
					{
						setOfTexs = mB_TexSet;
					}
					else
					{
						data.distinctMaterialTextures.Add(setOfTexs);
					}
					if (!setOfTexs.matsAndGOs.mats.Contains(item))
					{
						setOfTexs.matsAndGOs.mats.Add(item);
					}
					if (!setOfTexs.matsAndGOs.gos.Contains(gameObject))
					{
						setOfTexs.matsAndGOs.gos.Add(gameObject);
						if (!usedObjsToMesh.Contains(gameObject))
						{
							usedObjsToMesh.Add(gameObject);
						}
					}
				}
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log($"Step1_CollectDistinctTextures collected {data.distinctMaterialTextures.Count} sets of textures fixOutOfBoundsUV={data._fixOutOfBoundsUVs} considerNonTextureProperties={data._considerNonTextureProperties}");
			}
			if (data.distinctMaterialTextures.Count == 0)
			{
				UnityEngine.Debug.LogError("None of the source object materials matched any of the allowed materials for this submesh.");
				result.success = false;
				yield break;
			}
			new MB3_TextureCombinerMerging(data._considerNonTextureProperties, data.nonTexturePropertyBlender, data._fixOutOfBoundsUVs, LOG_LEVEL).MergeOverlappingDistinctMaterialTexturesAndCalcMaterialSubrects(data.distinctMaterialTextures);
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Total time Step1_CollectDistinctTextures " + stopwatch.ElapsedMilliseconds.ToString("f5"));
			}
		}

		private static CreateAtlasForProperty[] CalculateAllTexturesAreNullAndSameColor(TexturePipelineData data, MB2_LogLevel LOG_LEVEL)
		{
			CreateAtlasForProperty[] array = new CreateAtlasForProperty[data.texPropertyNames.Count];
			for (int i = 0; i < data.texPropertyNames.Count; i++)
			{
				MeshBakerMaterialTexture meshBakerMaterialTexture = data.distinctMaterialTextures[0].ts[i];
				UnityEngine.Color color = UnityEngine.Color.black;
				if (data._considerNonTextureProperties)
				{
					color = data.nonTexturePropertyBlender.GetColorAsItWouldAppearInAtlasIfNoTexture(data.distinctMaterialTextures[0].matsAndGOs.mats[0].mat, data.texPropertyNames[i]);
				}
				int num = 0;
				int num2 = 0;
				int num3 = 0;
				for (int j = 0; j < data.distinctMaterialTextures.Count; j++)
				{
					if (!data.distinctMaterialTextures[j].ts[i].isNull)
					{
						num++;
					}
					if (meshBakerMaterialTexture.AreTexturesEqual(data.distinctMaterialTextures[j].ts[i]))
					{
						num2++;
					}
					if (data._considerNonTextureProperties && data.nonTexturePropertyBlender.GetColorAsItWouldAppearInAtlasIfNoTexture(data.distinctMaterialTextures[j].matsAndGOs.mats[0].mat, data.texPropertyNames[i]) == color)
					{
						num3++;
					}
				}
				array[i].allTexturesAreNull = num == 0;
				array[i].allTexturesAreSame = num2 == data.distinctMaterialTextures.Count;
				array[i].allNonTexturePropsAreSame = num3 == data.distinctMaterialTextures.Count;
				if (LOG_LEVEL >= MB2_LogLevel.trace)
				{
					UnityEngine.Debug.Log($"AllTexturesAreNullAndSameColor prop: {data.texPropertyNames[i].name} createAtlas:{_ShouldWeCreateAtlasForThisProperty(i, data._considerNonTextureProperties, array)}  val:{array[i]}");
				}
			}
			return array;
		}

		internal static IEnumerator CalculateIdealSizesForTexturesInAtlasAndPadding(ProgressUpdateDelegate progressInfo, MB3_TextureCombiner.CombineTexturesIntoAtlasesCoroutineResult result, TexturePipelineData data, MB3_TextureCombiner combiner, MB2_EditorMethodsInterface textureEditorMethods, MB2_LogLevel LOG_LEVEL)
		{
			Stopwatch stopwatch = new Stopwatch();
			stopwatch.Start();
			MeshBakerMaterialTexture.readyToBuildAtlases = true;
			data.allTexturesAreNullAndSameColor = CalculateAllTexturesAreNullAndSameColor(data, LOG_LEVEL);
			int num = data._atlasPadding;
			if (data.distinctMaterialTextures.Count == 1 && !data._fixOutOfBoundsUVs && !data._considerNonTextureProperties)
			{
				if (LOG_LEVEL >= MB2_LogLevel.info)
				{
					UnityEngine.Debug.Log("All objects use the same textures in this set of atlases. Original textures will be reused instead of creating atlases.");
				}
				num = 0;
				data.distinctMaterialTextures[0].SetThisIsOnlyTexSetInAtlasTrue();
				data.distinctMaterialTextures[0].SetTilingTreatmentAndAdjustEncapsulatingSamplingRect(MB_TextureTilingTreatment.edgeToEdgeXY);
			}
			for (int i = 0; i < data.distinctMaterialTextures.Count; i++)
			{
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					UnityEngine.Debug.Log("Calculating ideal sizes for texSet TexSet " + i + " of " + data.distinctMaterialTextures.Count);
				}
				MB_TexSet mB_TexSet = data.distinctMaterialTextures[i];
				mB_TexSet.idealWidth = 1;
				mB_TexSet.idealHeight = 1;
				int num2 = 1;
				int num3 = 1;
				for (int j = 0; j < data.texPropertyNames.Count; j++)
				{
					if (!_ShouldWeCreateAtlasForThisProperty(j, data._considerNonTextureProperties, data.allTexturesAreNullAndSameColor))
					{
						continue;
					}
					MeshBakerMaterialTexture meshBakerMaterialTexture = mB_TexSet.ts[j];
					if (LOG_LEVEL >= MB2_LogLevel.trace)
					{
						UnityEngine.Debug.Log($"Calculating ideal size for texSet {i} property {data.texPropertyNames[j].name}");
					}
					if (!meshBakerMaterialTexture.matTilingRect.size.Equals(Vector2.one) && data.distinctMaterialTextures.Count > 1 && LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning(string.Concat("Texture ", meshBakerMaterialTexture.GetTexName(), "is tiled by ", meshBakerMaterialTexture.matTilingRect.size, " tiling will be baked into a texture with maxSize:", data._maxTilingBakeSize));
					}
					if (!mB_TexSet.obUVscale.Equals(Vector2.one) && data.distinctMaterialTextures.Count > 1 && data._fixOutOfBoundsUVs && LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning(string.Concat("Texture ", meshBakerMaterialTexture.GetTexName(), " has out of bounds UVs that effectively tile by ", mB_TexSet.obUVscale, " tiling will be baked into a texture with maxSize:", data._maxTilingBakeSize));
					}
					if (meshBakerMaterialTexture.isNull)
					{
						mB_TexSet.SetEncapsulatingRect(j, data._fixOutOfBoundsUVs);
						if (LOG_LEVEL >= MB2_LogLevel.trace)
						{
							UnityEngine.Debug.Log($"No source texture creating a 16x16 texture for {data.texPropertyNames[j].name} texSet {i} srcMat {mB_TexSet.matsAndGOs.mats[0].GetMaterialName()}");
						}
					}
					if (meshBakerMaterialTexture.isNull)
					{
						continue;
					}
					Vector2 adjustedForScaleAndOffset2Dimensions = GetAdjustedForScaleAndOffset2Dimensions(meshBakerMaterialTexture, mB_TexSet.obUVoffset, mB_TexSet.obUVscale, data, LOG_LEVEL);
					if ((int)(adjustedForScaleAndOffset2Dimensions.x * adjustedForScaleAndOffset2Dimensions.y) > num2 * num3)
					{
						if (LOG_LEVEL >= MB2_LogLevel.trace)
						{
							UnityEngine.Debug.Log(string.Concat("    matTex ", meshBakerMaterialTexture.GetTexName(), " ", adjustedForScaleAndOffset2Dimensions, " has a bigger size than ", num2, " ", num3));
						}
						num2 = (int)adjustedForScaleAndOffset2Dimensions.x;
						num3 = (int)adjustedForScaleAndOffset2Dimensions.y;
					}
				}
				if (data._resizePowerOfTwoTextures)
				{
					if (num2 <= num * 5)
					{
						UnityEngine.Debug.LogWarning(string.Format("Some of the textures have widths close to the size of the padding. It is not recommended to use _resizePowerOfTwoTextures with widths this small.", mB_TexSet.ToString()));
					}
					if (num3 <= num * 5)
					{
						UnityEngine.Debug.LogWarning(string.Format("Some of the textures have heights close to the size of the padding. It is not recommended to use _resizePowerOfTwoTextures with heights this small.", mB_TexSet.ToString()));
					}
					if (IsPowerOfTwo(num2))
					{
						num2 -= num * 2;
					}
					if (IsPowerOfTwo(num3))
					{
						num3 -= num * 2;
					}
					if (num2 < 1)
					{
						num2 = 1;
					}
					if (num3 < 1)
					{
						num3 = 1;
					}
				}
				if (LOG_LEVEL >= MB2_LogLevel.trace)
				{
					UnityEngine.Debug.Log("    Ideal size is " + num2 + " " + num3);
				}
				mB_TexSet.idealWidth = num2;
				mB_TexSet.idealHeight = num3;
			}
			data._atlasPadding = num;
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Total time Step2 Calculate Ideal Sizes part1: " + stopwatch.Elapsed.ToString());
			}
			yield break;
		}

		internal static AtlasPackingResult[] __Step3_RunTexturePacker(TexturePipelineData data, MB_ITextureCombinerPacker texturePacker, MB2_LogLevel LOG_LEVEL)
		{
			AtlasPackingResult[] array = texturePacker.CalculateAtlasRectangles(data, doMultiAtlas: true, LOG_LEVEL);
			for (int i = 0; i < array.Length; i++)
			{
				List<MatsAndGOs> list = new List<MatsAndGOs>();
				array[i].data = list;
				for (int j = 0; j < array[i].srcImgIdxs.Length; j++)
				{
					MB_TexSet mB_TexSet = data.distinctMaterialTextures[array[i].srcImgIdxs[j]];
					list.Add(mB_TexSet.matsAndGOs);
				}
			}
			return array;
		}

		internal static MB_ITextureCombinerPacker CreatePacker(bool onlyOneTextureInAtlasReuseTextures, MB2_PackingAlgorithmEnum packingAlgorithm)
		{
			if (onlyOneTextureInAtlasReuseTextures)
			{
				return new MB3_TextureCombinerPackerOneTextureInAtlas();
			}
			switch (packingAlgorithm)
			{
			case MB2_PackingAlgorithmEnum.UnitysPackTextures:
				return new MB3_TextureCombinerPackerUnity();
			case MB2_PackingAlgorithmEnum.MeshBakerTexturePacker_Horizontal:
				if (USE_EXPERIMENTAL_HOIZONTALVERTICAL)
				{
					return new MB3_TextureCombinerPackerMeshBakerHorizontalVertical(MB3_TextureCombinerPackerMeshBakerHorizontalVertical.AtlasDirection.horizontal);
				}
				return new MB3_TextureCombinerPackerMeshBaker();
			case MB2_PackingAlgorithmEnum.MeshBakerTexturePacker_Vertical:
				if (USE_EXPERIMENTAL_HOIZONTALVERTICAL)
				{
					return new MB3_TextureCombinerPackerMeshBakerHorizontalVertical(MB3_TextureCombinerPackerMeshBakerHorizontalVertical.AtlasDirection.vertical);
				}
				return new MB3_TextureCombinerPackerMeshBaker();
			case MB2_PackingAlgorithmEnum.MeshBakerTexturePacker:
				return new MB3_TextureCombinerPackerMeshBaker();
			default:
				return new MB3_TextureCombinerPackerMeshBakerFast();
			}
		}

		internal static IEnumerator __Step3_BuildAndSaveAtlasesAndStoreResults(MB3_TextureCombiner.CombineTexturesIntoAtlasesCoroutineResult result, ProgressUpdateDelegate progressInfo, TexturePipelineData data, MB3_TextureCombiner combiner, MB_ITextureCombinerPacker packer, AtlasPackingResult atlasPackingResult, MB2_EditorMethodsInterface textureEditorMethods, MB_AtlasesAndRects resultAtlasesAndRects, StringBuilder report, MB2_LogLevel LOG_LEVEL)
		{
			Stopwatch sw = new Stopwatch();
			sw.Start();
			GC.Collect();
			Texture2D[] atlases = new Texture2D[data.numAtlases];
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("time Step 3 Create And Save Atlases part 1 " + sw.Elapsed.ToString());
			}
			yield return packer.CreateAtlases(progressInfo, data, combiner, atlasPackingResult, atlases, textureEditorMethods, LOG_LEVEL);
			float num = sw.ElapsedMilliseconds;
			data.nonTexturePropertyBlender.AdjustNonTextureProperties(data.resultMaterial, data.texPropertyNames, data.distinctMaterialTextures, textureEditorMethods);
			if (data.distinctMaterialTextures.Count > 0)
			{
				data.distinctMaterialTextures[0].AdjustResultMaterialNonTextureProperties(data.resultMaterial, data.texPropertyNames);
			}
			progressInfo?.Invoke("Building Report", 0.7f);
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.AppendLine("---- Atlases ------");
			for (int i = 0; i < data.numAtlases; i++)
			{
				if (atlases[i] != null)
				{
					stringBuilder.AppendLine("Created Atlas For: " + data.texPropertyNames[i].name + " h=" + atlases[i].height + " w=" + atlases[i].width);
				}
				else if (!_ShouldWeCreateAtlasForThisProperty(i, data._considerNonTextureProperties, data.allTexturesAreNullAndSameColor))
				{
					stringBuilder.AppendLine("Did not create atlas for " + data.texPropertyNames[i].name + " because all source textures were null.");
				}
			}
			report.Append(stringBuilder.ToString());
			List<MB_MaterialAndUVRect> list = new List<MB_MaterialAndUVRect>();
			for (int j = 0; j < data.distinctMaterialTextures.Count; j++)
			{
				MB_TexSet mB_TexSet = data.distinctMaterialTextures[j];
				List<MatAndTransformToMerged> mats = mB_TexSet.matsAndGOs.mats;
				mB_TexSet.GetRectsForTextureBakeResults(out var allPropsUseSameTiling_encapsulatingSamplingRect, out var propsUseDifferntTiling_obUVRect);
				for (int k = 0; k < mats.Count; k++)
				{
					Rect materialTilingRectForTextureBakerResults = mB_TexSet.GetMaterialTilingRectForTextureBakerResults(k);
					MB_MaterialAndUVRect item = new MB_MaterialAndUVRect(mats[k].mat, atlasPackingResult.rects[j], mB_TexSet.allTexturesUseSameMatTiling, materialTilingRectForTextureBakerResults, allPropsUseSameTiling_encapsulatingSamplingRect, propsUseDifferntTiling_obUVRect, mB_TexSet.tilingTreatment, mats[k].objName);
					if (!list.Contains(item))
					{
						list.Add(item);
					}
				}
			}
			resultAtlasesAndRects.atlases = atlases;
			resultAtlasesAndRects.texPropertyNames = ShaderTextureProperty.GetNames(data.texPropertyNames);
			resultAtlasesAndRects.mat2rect_map = list;
			progressInfo?.Invoke("Restoring Texture Formats & Read Flags", 0.8f);
			combiner._destroyAllTemporaryTextures();
			textureEditorMethods?.RestoreReadFlagsAndFormats(progressInfo);
			if (report != null && LOG_LEVEL >= MB2_LogLevel.info)
			{
				UnityEngine.Debug.Log(report.ToString());
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Time Step 3 Create And Save Atlases part 3 " + ((float)sw.ElapsedMilliseconds - num).ToString("f5"));
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Total time Step 3 Create And Save Atlases " + sw.Elapsed.ToString());
			}
		}

		internal static StringBuilder GenerateReport(TexturePipelineData data)
		{
			StringBuilder stringBuilder = new StringBuilder();
			if (data.numAtlases > 0)
			{
				stringBuilder = new StringBuilder();
				stringBuilder.AppendLine("Report");
				for (int i = 0; i < data.distinctMaterialTextures.Count; i++)
				{
					MB_TexSet mB_TexSet = data.distinctMaterialTextures[i];
					stringBuilder.AppendLine("----------");
					stringBuilder.Append("This set of textures will be resized to:" + mB_TexSet.idealWidth + "x" + mB_TexSet.idealHeight + "\n");
					for (int j = 0; j < mB_TexSet.ts.Length; j++)
					{
						if (!mB_TexSet.ts[j].isNull)
						{
							stringBuilder.Append("   [" + data.texPropertyNames[j].name + " " + mB_TexSet.ts[j].GetTexName() + " " + mB_TexSet.ts[j].width + "x" + mB_TexSet.ts[j].height + "]");
							if (mB_TexSet.ts[j].matTilingRect.size != Vector2.one || mB_TexSet.ts[j].matTilingRect.min != Vector2.zero)
							{
								stringBuilder.AppendFormat(" material scale {0} offset{1} ", mB_TexSet.ts[j].matTilingRect.size.ToString("G4"), mB_TexSet.ts[j].matTilingRect.min.ToString("G4"));
							}
							if (mB_TexSet.obUVscale != Vector2.one || mB_TexSet.obUVoffset != Vector2.zero)
							{
								stringBuilder.AppendFormat(" obUV scale {0} offset{1} ", mB_TexSet.obUVscale.ToString("G4"), mB_TexSet.obUVoffset.ToString("G4"));
							}
							stringBuilder.AppendLine("");
						}
						else
						{
							stringBuilder.Append("   [" + data.texPropertyNames[j].name + " null ");
							if (!_ShouldWeCreateAtlasForThisProperty(j, data._considerNonTextureProperties, data.allTexturesAreNullAndSameColor))
							{
								stringBuilder.Append("no atlas will be created all textures null]\n");
							}
							else
							{
								stringBuilder.AppendFormat("a 16x16 texture will be created]\n");
							}
						}
					}
					stringBuilder.AppendLine("");
					stringBuilder.Append("Materials using:");
					for (int k = 0; k < mB_TexSet.matsAndGOs.mats.Count; k++)
					{
						stringBuilder.Append(mB_TexSet.matsAndGOs.mats[k].mat.name + ", ");
					}
					stringBuilder.AppendLine("");
				}
			}
			return stringBuilder;
		}

		internal static MB2_TexturePacker CreateTexturePacker(MB2_PackingAlgorithmEnum _packingAlgorithm)
		{
			switch (_packingAlgorithm)
			{
			case MB2_PackingAlgorithmEnum.MeshBakerTexturePacker:
				return new MB2_TexturePackerRegular();
			case MB2_PackingAlgorithmEnum.MeshBakerTexturePacker_Fast:
				return new MB2_TexturePackerRegular();
			case MB2_PackingAlgorithmEnum.MeshBakerTexturePacker_Horizontal:
				return new MB2_TexturePackerHorizontalVert
				{
					packingOrientation = MB2_TexturePackerHorizontalVert.TexturePackingOrientation.horizontal
				};
			case MB2_PackingAlgorithmEnum.MeshBakerTexturePacker_Vertical:
				return new MB2_TexturePackerHorizontalVert
				{
					packingOrientation = MB2_TexturePackerHorizontalVert.TexturePackingOrientation.vertical
				};
			default:
				UnityEngine.Debug.LogError("packing algorithm must be one of the MeshBaker options to create a Texture Packer");
				return null;
			}
		}

		internal static Vector2 GetAdjustedForScaleAndOffset2Dimensions(MeshBakerMaterialTexture source, Vector2 obUVoffset, Vector2 obUVscale, TexturePipelineData data, MB2_LogLevel LOG_LEVEL)
		{
			if (source.matTilingRect.x == 0.0 && source.matTilingRect.y == 0.0 && source.matTilingRect.width == 1.0 && source.matTilingRect.height == 1.0)
			{
				if (!data._fixOutOfBoundsUVs)
				{
					return new Vector2(source.width, source.height);
				}
				if (obUVoffset.x == 0f && obUVoffset.y == 0f && obUVscale.x == 1f && obUVscale.y == 1f)
				{
					return new Vector2(source.width, source.height);
				}
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log(string.Concat("GetAdjustedForScaleAndOffset2Dimensions: ", source.GetTexName(), " ", obUVoffset, " ", obUVscale));
			}
			Rect rect = source.GetEncapsulatingSamplingRect().GetRect();
			float num = rect.width * (float)source.width;
			float num2 = rect.height * (float)source.height;
			if (num > (float)data._maxTilingBakeSize)
			{
				num = data._maxTilingBakeSize;
			}
			if (num2 > (float)data._maxTilingBakeSize)
			{
				num2 = data._maxTilingBakeSize;
			}
			if (num < 1f)
			{
				num = 1f;
			}
			if (num2 < 1f)
			{
				num2 = 1f;
			}
			return new Vector2(num, num2);
		}

		internal static Color32 ConvertNormalFormatFromUnity_ToStandard(Color32 c)
		{
			Vector3 zero = Vector3.zero;
			zero.x = (float)(int)c.a * 2f - 1f;
			zero.y = (float)(int)c.g * 2f - 1f;
			zero.z = Mathf.Sqrt(1f - zero.x * zero.x - zero.y * zero.y);
			Color32 result = default(Color32);
			result.a = 1;
			result.r = (byte)((zero.x + 1f) * 0.5f);
			result.g = (byte)((zero.y + 1f) * 0.5f);
			result.b = (byte)((zero.z + 1f) * 0.5f);
			return result;
		}

		internal static float GetSubmeshArea(Mesh m, int submeshIdx)
		{
			if (submeshIdx >= m.subMeshCount || submeshIdx < 0)
			{
				return 0f;
			}
			Vector3[] vertices = m.vertices;
			int[] indices = m.GetIndices(submeshIdx);
			float num = 0f;
			for (int i = 0; i < indices.Length; i += 3)
			{
				Vector3 vector = vertices[indices[i]];
				Vector3 vector2 = vertices[indices[i + 1]];
				Vector3 vector3 = vertices[indices[i + 2]];
				num += Vector3.Cross(vector2 - vector, vector3 - vector).magnitude / 2f;
			}
			return num;
		}

		internal static bool IsPowerOfTwo(int x)
		{
			return (x & (x - 1)) == 0;
		}
	}
	public class MB3_Comment : MonoBehaviour
	{
		[Multiline]
		public string comment;
	}
	public class MBVersionConcrete : MBVersionInterface
	{
		private Vector2 _HALF_UV = new Vector2(0.5f, 0.5f);

		public string version()
		{
			return "3.26.0";
		}

		public int GetMajorVersion()
		{
			return int.Parse(Application.unityVersion.Split('.')[0]);
		}

		public int GetMinorVersion()
		{
			return int.Parse(Application.unityVersion.Split('.')[1]);
		}

		public bool GetActive(GameObject go)
		{
			return go.activeInHierarchy;
		}

		public void SetActive(GameObject go, bool isActive)
		{
			go.SetActive(isActive);
		}

		public void SetActiveRecursively(GameObject go, bool isActive)
		{
			go.SetActive(isActive);
		}

		public UnityEngine.Object[] FindSceneObjectsOfType(Type t)
		{
			return UnityEngine.Object.FindObjectsOfType(t);
		}

		public void OptimizeMesh(Mesh m)
		{
		}

		public bool IsRunningAndMeshNotReadWriteable(Mesh m)
		{
			if (Application.isPlaying)
			{
				return !m.isReadable;
			}
			return false;
		}

		public Vector2[] GetMeshUV1s(Mesh m, MB2_LogLevel LOG_LEVEL)
		{
			if (LOG_LEVEL >= MB2_LogLevel.warn)
			{
				MB2_Log.LogDebug("UV1 does not exist in Unity 5+");
			}
			Vector2[] array = m.uv;
			if (array.Length == 0)
			{
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug(string.Concat("Mesh ", m, " has no uv1s. Generating"));
				}
				if (LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning(string.Concat("Mesh ", m, " didn't have uv1s. Generating uv1s."));
				}
				array = new Vector2[m.vertexCount];
				for (int i = 0; i < array.Length; i++)
				{
					array[i] = _HALF_UV;
				}
			}
			return array;
		}

		public Vector2[] GetMeshUV3orUV4(Mesh m, bool get3, MB2_LogLevel LOG_LEVEL)
		{
			Vector2[] array = ((!get3) ? m.uv4 : m.uv3);
			if (array.Length == 0)
			{
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug(string.Concat("Mesh ", m, " has no uv", get3 ? "3" : "4", ". Generating"));
				}
				array = new Vector2[m.vertexCount];
				for (int i = 0; i < array.Length; i++)
				{
					array[i] = _HALF_UV;
				}
			}
			return array;
		}

		public void MeshClear(Mesh m, bool t)
		{
			m.Clear(t);
		}

		public void MeshAssignUV3(Mesh m, Vector2[] uv3s)
		{
			m.uv3 = uv3s;
		}

		public void MeshAssignUV4(Mesh m, Vector2[] uv4s)
		{
			m.uv4 = uv4s;
		}

		public Vector4 GetLightmapTilingOffset(Renderer r)
		{
			return r.lightmapScaleOffset;
		}

		public Transform[] GetBones(Renderer r)
		{
			if (r is SkinnedMeshRenderer)
			{
				return ((SkinnedMeshRenderer)r).bones;
			}
			if (r is MeshRenderer)
			{
				return new Transform[1] { r.transform };
			}
			UnityEngine.Debug.LogError("Could not getBones. Object does not have a renderer");
			return null;
		}

		public int GetBlendShapeFrameCount(Mesh m, int shapeIndex)
		{
			return m.GetBlendShapeFrameCount(shapeIndex);
		}

		public float GetBlendShapeFrameWeight(Mesh m, int shapeIndex, int frameIndex)
		{
			return m.GetBlendShapeFrameWeight(shapeIndex, frameIndex);
		}

		public void GetBlendShapeFrameVertices(Mesh m, int shapeIndex, int frameIndex, Vector3[] vs, Vector3[] ns, Vector3[] ts)
		{
			m.GetBlendShapeFrameVertices(shapeIndex, frameIndex, vs, ns, ts);
		}

		public void ClearBlendShapes(Mesh m)
		{
			m.ClearBlendShapes();
		}

		public void AddBlendShapeFrame(Mesh m, string nm, float wt, Vector3[] vs, Vector3[] ns, Vector3[] ts)
		{
			m.AddBlendShapeFrame(nm, wt, vs, ns, ts);
		}

		public int MaxMeshVertexCount()
		{
			return 2147483646;
		}

		public void SetMeshIndexFormatAndClearMesh(Mesh m, int numVerts, bool vertices, bool justClearTriangles)
		{
			if (vertices && numVerts > 65534 && m.indexFormat == IndexFormat.UInt16)
			{
				MBVersion.MeshClear(m, t: false);
				m.indexFormat = IndexFormat.UInt32;
			}
			else if (vertices && numVerts <= 65534 && m.indexFormat == IndexFormat.UInt32)
			{
				MBVersion.MeshClear(m, t: false);
				m.indexFormat = IndexFormat.UInt16;
			}
			else if (justClearTriangles)
			{
				MBVersion.MeshClear(m, t: true);
			}
			else
			{
				MBVersion.MeshClear(m, t: false);
			}
		}
	}
	[Serializable]
	public class GrouperData
	{
		public bool clusterOnLMIndex;

		public bool clusterByLODLevel;

		public Vector3 origin;

		public Vector3 cellSize;

		public int pieNumSegments = 4;

		public Vector3 pieAxis = Vector3.up;

		public int height = 1;

		public float maxDistBetweenClusters = 1f;

		public bool includeCellsWithOnlyOneRenderer = true;
	}
	[Serializable]
	public abstract class MB3_MeshBakerGrouperCore
	{
		public GrouperData d;

		public abstract Dictionary<string, List<Renderer>> FilterIntoGroups(List<GameObject> selection);

		public abstract void DrawGizmos(Bounds sourceObjectBounds);

		public void DoClustering(MB3_TextureBaker tb, MB3_MeshBakerGrouper grouper)
		{
			Dictionary<string, List<Renderer>> dictionary = FilterIntoGroups(tb.GetObjectsToCombine());
			if (d.clusterOnLMIndex)
			{
				Dictionary<string, List<Renderer>> dictionary2 = new Dictionary<string, List<Renderer>>();
				foreach (string key4 in dictionary.Keys)
				{
					List<Renderer> gaws = dictionary[key4];
					Dictionary<int, List<Renderer>> dictionary3 = GroupByLightmapIndex(gaws);
					foreach (int key5 in dictionary3.Keys)
					{
						string key = key4 + "-LM-" + key5;
						dictionary2.Add(key, dictionary3[key5]);
					}
				}
				dictionary = dictionary2;
			}
			if (d.clusterByLODLevel)
			{
				Dictionary<string, List<Renderer>> dictionary4 = new Dictionary<string, List<Renderer>>();
				foreach (string key6 in dictionary.Keys)
				{
					foreach (Renderer r in dictionary[key6])
					{
						if (r == null)
						{
							continue;
						}
						bool flag = false;
						LODGroup componentInParent = r.GetComponentInParent<LODGroup>();
						if (componentInParent != null)
						{
							LOD[] lODs = componentInParent.GetLODs();
							for (int i = 0; i < lODs.Length; i++)
							{
								if (Array.Find(lODs[i].renderers, (Renderer x) => x == r) != null)
								{
									flag = true;
									string key2 = $"{key6}_LOD{i}";
									if (!dictionary4.TryGetValue(key2, out var value))
									{
										value = new List<Renderer>();
										dictionary4.Add(key2, value);
									}
									if (!value.Contains(r))
									{
										value.Add(r);
									}
								}
							}
						}
						if (!flag)
						{
							string key3 = $"{key6}_LOD0";
							if (!dictionary4.TryGetValue(key3, out var value2))
							{
								value2 = new List<Renderer>();
								dictionary4.Add(key3, value2);
							}
							if (!value2.Contains(r))
							{
								value2.Add(r);
							}
						}
					}
				}
				dictionary = dictionary4;
			}
			int num = 0;
			foreach (string key7 in dictionary.Keys)
			{
				List<Renderer> list = dictionary[key7];
				if (list.Count > 1 || grouper.data.includeCellsWithOnlyOneRenderer)
				{
					AddMeshBaker(tb, key7, list);
				}
				else
				{
					num++;
				}
			}
			UnityEngine.Debug.Log($"Found {dictionary.Count} cells with Renderers. Not creating bakers for {num} because there is only one mesh in the cell. Creating {dictionary.Count - num} bakers.");
		}

		private Dictionary<int, List<Renderer>> GroupByLightmapIndex(List<Renderer> gaws)
		{
			Dictionary<int, List<Renderer>> dictionary = new Dictionary<int, List<Renderer>>();
			for (int i = 0; i < gaws.Count; i++)
			{
				List<Renderer> list = null;
				if (dictionary.ContainsKey(gaws[i].lightmapIndex))
				{
					list = dictionary[gaws[i].lightmapIndex];
				}
				else
				{
					list = new List<Renderer>();
					dictionary.Add(gaws[i].lightmapIndex, list);
				}
				list.Add(gaws[i]);
			}
			return dictionary;
		}

		private void AddMeshBaker(MB3_TextureBaker tb, string key, List<Renderer> gaws)
		{
			int num = 0;
			for (int i = 0; i < gaws.Count; i++)
			{
				Mesh mesh = MB_Utility.GetMesh(gaws[i].gameObject);
				if (mesh != null)
				{
					num += mesh.vertexCount;
				}
			}
			GameObject gameObject = new GameObject("MeshBaker-" + key);
			gameObject.transform.position = Vector3.zero;
			MB3_MeshBakerCommon mB3_MeshBakerCommon;
			if (num >= 65535)
			{
				mB3_MeshBakerCommon = gameObject.AddComponent<MB3_MultiMeshBaker>();
				mB3_MeshBakerCommon.useObjsToMeshFromTexBaker = false;
			}
			else
			{
				mB3_MeshBakerCommon = gameObject.AddComponent<MB3_MeshBaker>();
				mB3_MeshBakerCommon.useObjsToMeshFromTexBaker = false;
			}
			mB3_MeshBakerCommon.textureBakeResults = tb.textureBakeResults;
			mB3_MeshBakerCommon.transform.parent = tb.transform;
			for (int j = 0; j < gaws.Count; j++)
			{
				mB3_MeshBakerCommon.GetObjectsToCombine().Add(gaws[j].gameObject);
			}
		}
	}
	[Serializable]
	public class MB3_MeshBakerGrouperNone : MB3_MeshBakerGrouperCore
	{
		public MB3_MeshBakerGrouperNone(GrouperData d)
		{
			base.d = d;
		}

		public override Dictionary<string, List<Renderer>> FilterIntoGroups(List<GameObject> selection)
		{
			UnityEngine.Debug.Log("Filtering into groups none");
			Dictionary<string, List<Renderer>> dictionary = new Dictionary<string, List<Renderer>>();
			List<Renderer> list = new List<Renderer>();
			for (int i = 0; i < selection.Count; i++)
			{
				if (selection[i] != null)
				{
					list.Add(selection[i].GetComponent<Renderer>());
				}
			}
			dictionary.Add("MeshBaker", list);
			return dictionary;
		}

		public override void DrawGizmos(Bounds sourceObjectBounds)
		{
		}
	}
	[Serializable]
	public class MB3_MeshBakerGrouperGrid : MB3_MeshBakerGrouperCore
	{
		public MB3_MeshBakerGrouperGrid(GrouperData d)
		{
			base.d = d;
		}

		public override Dictionary<string, List<Renderer>> FilterIntoGroups(List<GameObject> selection)
		{
			Dictionary<string, List<Renderer>> dictionary = new Dictionary<string, List<Renderer>>();
			if (d.cellSize.x <= 0f || d.cellSize.y <= 0f || d.cellSize.z <= 0f)
			{
				UnityEngine.Debug.LogError("cellSize x,y,z must all be greater than zero.");
				return dictionary;
			}
			UnityEngine.Debug.Log("Collecting renderers in each cell");
			foreach (GameObject item in selection)
			{
				if (item == null)
				{
					continue;
				}
				Renderer component = item.GetComponent<Renderer>();
				if (component is MeshRenderer || component is SkinnedMeshRenderer)
				{
					Vector3 center = component.bounds.center;
					center.x = Mathf.Floor((center.x - d.origin.x) / d.cellSize.x) * d.cellSize.x;
					center.y = Mathf.Floor((center.y - d.origin.y) / d.cellSize.y) * d.cellSize.y;
					center.z = Mathf.Floor((center.z - d.origin.z) / d.cellSize.z) * d.cellSize.z;
					List<Renderer> list = null;
					string key = center.ToString();
					if (dictionary.ContainsKey(key))
					{
						list = dictionary[key];
					}
					else
					{
						list = new List<Renderer>();
						dictionary.Add(key, list);
					}
					if (!list.Contains(component))
					{
						list.Add(component);
					}
				}
			}
			return dictionary;
		}

		public override void DrawGizmos(Bounds sourceObjectBounds)
		{
			Vector3 cellSize = d.cellSize;
			if (cellSize.x <= 1E-05f || cellSize.y <= 1E-05f || cellSize.z <= 1E-05f)
			{
				return;
			}
			Vector3 vector = sourceObjectBounds.center - sourceObjectBounds.extents;
			Vector3 origin = d.origin;
			origin.x %= cellSize.x;
			origin.y %= cellSize.y;
			origin.z %= cellSize.z;
			vector.x = Mathf.Round(vector.x / cellSize.x) * cellSize.x + origin.x;
			vector.y = Mathf.Round(vector.y / cellSize.y) * cellSize.y + origin.y;
			vector.z = Mathf.Round(vector.z / cellSize.z) * cellSize.z + origin.z;
			if (vector.x > sourceObjectBounds.center.x - sourceObjectBounds.extents.x)
			{
				vector.x -= cellSize.x;
			}
			if (vector.y > sourceObjectBounds.center.y - sourceObjectBounds.extents.y)
			{
				vector.y -= cellSize.y;
			}
			if (vector.z > sourceObjectBounds.center.z - sourceObjectBounds.extents.z)
			{
				vector.z -= cellSize.z;
			}
			Vector3 vector2 = vector;
			if (Mathf.CeilToInt(sourceObjectBounds.size.x / cellSize.x + sourceObjectBounds.size.y / cellSize.y + sourceObjectBounds.size.z / cellSize.z) > 200)
			{
				Gizmos.DrawWireCube(d.origin + cellSize / 2f, cellSize);
				return;
			}
			while (vector.x < sourceObjectBounds.center.x + sourceObjectBounds.extents.x)
			{
				vector.y = vector2.y;
				while (vector.y < sourceObjectBounds.center.y + sourceObjectBounds.extents.y)
				{
					vector.z = vector2.z;
					while (vector.z < sourceObjectBounds.center.z + sourceObjectBounds.extents.z)
					{
						Gizmos.DrawWireCube(vector + cellSize / 2f, cellSize);
						vector.z += cellSize.z;
					}
					vector.y += cellSize.y;
				}
				vector.x += cellSize.x;
			}
		}
	}
	[Serializable]
	public class MB3_MeshBakerGrouperPie : MB3_MeshBakerGrouperCore
	{
		public MB3_MeshBakerGrouperPie(GrouperData data)
		{
			d = data;
		}

		public override Dictionary<string, List<Renderer>> FilterIntoGroups(List<GameObject> selection)
		{
			Dictionary<string, List<Renderer>> dictionary = new Dictionary<string, List<Renderer>>();
			if (d.pieNumSegments == 0)
			{
				UnityEngine.Debug.LogError("pieNumSegments must be greater than zero.");
				return dictionary;
			}
			if (d.pieAxis.magnitude <= 1E-06f)
			{
				UnityEngine.Debug.LogError("Pie axis must have length greater than zero.");
				return dictionary;
			}
			d.pieAxis.Normalize();
			Quaternion quaternion = Quaternion.FromToRotation(d.pieAxis, Vector3.up);
			UnityEngine.Debug.Log("Collecting renderers in each cell");
			foreach (GameObject item in selection)
			{
				if (item == null)
				{
					continue;
				}
				Renderer component = item.GetComponent<Renderer>();
				if (!(component is MeshRenderer) && !(component is SkinnedMeshRenderer))
				{
					continue;
				}
				Vector3 vector = component.bounds.center - d.origin;
				vector.Normalize();
				vector = quaternion * vector;
				float num = 0f;
				if (Mathf.Abs(vector.x) < 0.0001f && Mathf.Abs(vector.z) < 0.0001f)
				{
					num = 0f;
				}
				else
				{
					num = Mathf.Atan2(vector.x, vector.z) * 57.29578f;
					if (num < 0f)
					{
						num = 360f + num;
					}
				}
				int num2 = Mathf.FloorToInt(num / 360f * (float)d.pieNumSegments);
				List<Renderer> list = null;
				string key = "seg_" + num2;
				if (dictionary.ContainsKey(key))
				{
					list = dictionary[key];
				}
				else
				{
					list = new List<Renderer>();
					dictionary.Add(key, list);
				}
				if (!list.Contains(component))
				{
					list.Add(component);
				}
			}
			return dictionary;
		}

		public override void DrawGizmos(Bounds sourceObjectBounds)
		{
			if (!(d.pieAxis.magnitude < 0.1f) && d.pieNumSegments >= 1)
			{
				float magnitude = sourceObjectBounds.extents.magnitude;
				DrawCircle(d.pieAxis, d.origin, magnitude, 24);
				Quaternion quaternion = Quaternion.FromToRotation(Vector3.up, d.pieAxis);
				Quaternion quaternion2 = Quaternion.AngleAxis(180f / (float)d.pieNumSegments, Vector3.up);
				Vector3 vector = Vector3.forward;
				for (int i = 0; i < d.pieNumSegments; i++)
				{
					Vector3 vector2 = quaternion * vector;
					Gizmos.DrawLine(d.origin, d.origin + vector2 * magnitude);
					vector = quaternion2 * vector;
					vector = quaternion2 * vector;
				}
			}
		}

		public static void DrawCircle(Vector3 axis, Vector3 center, float radius, int subdiv)
		{
			Quaternion quaternion = Quaternion.AngleAxis(360 / subdiv, axis);
			Vector3 vector = new Vector3(axis.y, 0f - axis.x, axis.z);
			vector.Normalize();
			vector *= radius;
			for (int i = 0; i < subdiv + 1; i++)
			{
				Vector3 vector2 = quaternion * vector;
				Gizmos.DrawLine(center + vector, center + vector2);
				vector = vector2;
			}
		}
	}
	[Serializable]
	public class MB3_MeshBakerGrouperKMeans : MB3_MeshBakerGrouperCore
	{
		public int numClusters = 4;

		public Vector3[] clusterCenters = new Vector3[0];

		public float[] clusterSizes = new float[0];

		public MB3_MeshBakerGrouperKMeans(GrouperData data)
		{
			d = data;
		}

		public override Dictionary<string, List<Renderer>> FilterIntoGroups(List<GameObject> selection)
		{
			Dictionary<string, List<Renderer>> dictionary = new Dictionary<string, List<Renderer>>();
			List<GameObject> list = new List<GameObject>();
			int num = 20;
			foreach (GameObject item in selection)
			{
				if (!(item == null))
				{
					GameObject gameObject = item;
					Renderer component = gameObject.GetComponent<Renderer>();
					if (component is MeshRenderer || component is SkinnedMeshRenderer)
					{
						list.Add(gameObject);
					}
				}
			}
			if (list.Count > 0 && num > 0 && num < list.Count)
			{
				MB3_KMeansClustering mB3_KMeansClustering = new MB3_KMeansClustering(list, num);
				mB3_KMeansClustering.Cluster();
				clusterCenters = new Vector3[num];
				clusterSizes = new float[num];
				for (int i = 0; i < num; i++)
				{
					List<Renderer> cluster = mB3_KMeansClustering.GetCluster(i, out clusterCenters[i], out clusterSizes[i]);
					if (cluster.Count > 0)
					{
						dictionary.Add("Cluster_" + i, cluster);
					}
				}
			}
			return dictionary;
		}

		public override void DrawGizmos(Bounds sceneObjectBounds)
		{
			if (clusterCenters != null && clusterSizes != null && clusterCenters.Length == clusterSizes.Length)
			{
				for (int i = 0; i < clusterSizes.Length; i++)
				{
					Gizmos.DrawWireSphere(clusterCenters[i], clusterSizes[i]);
				}
			}
		}
	}
	[Serializable]
	public class MB3_MeshBakerGrouperCluster : MB3_MeshBakerGrouperCore
	{
		public MB3_AgglomerativeClustering cluster;

		private float _lastMaxDistBetweenClusters;

		public float _ObjsExtents = 10f;

		public float _minDistBetweenClusters = 0.001f;

		private List<MB3_AgglomerativeClustering.ClusterNode> _clustersToDraw = new List<MB3_AgglomerativeClustering.ClusterNode>();

		private float[] _radii;

		public MB3_MeshBakerGrouperCluster(GrouperData data, List<GameObject> gos)
		{
			d = data;
		}

		public override Dictionary<string, List<Renderer>> FilterIntoGroups(List<GameObject> selection)
		{
			Dictionary<string, List<Renderer>> dictionary = new Dictionary<string, List<Renderer>>();
			for (int i = 0; i < _clustersToDraw.Count; i++)
			{
				MB3_AgglomerativeClustering.ClusterNode clusterNode = _clustersToDraw[i];
				List<Renderer> list = new List<Renderer>();
				for (int j = 0; j < clusterNode.leafs.Length; j++)
				{
					Renderer component = cluster.clusters[clusterNode.leafs[j]].leaf.go.GetComponent<Renderer>();
					if (component is MeshRenderer || component is SkinnedMeshRenderer)
					{
						list.Add(component);
					}
				}
				dictionary.Add("Cluster_" + i, list);
			}
			return dictionary;
		}

		public void BuildClusters(List<GameObject> gos, ProgressUpdateCancelableDelegate progFunc)
		{
			if (gos.Count == 0)
			{
				UnityEngine.Debug.LogWarning("No objects to cluster. Add some objects to the list of Objects To Combine.");
				return;
			}
			if (cluster == null)
			{
				cluster = new MB3_AgglomerativeClustering();
			}
			List<MB3_AgglomerativeClustering.item_s> list = new List<MB3_AgglomerativeClustering.item_s>();
			int i;
			for (i = 0; i < gos.Count; i++)
			{
				if (gos[i] != null && list.Find((MB3_AgglomerativeClustering.item_s x) => x.go == gos[i]) == null)
				{
					Renderer component = gos[i].GetComponent<Renderer>();
					if (component != null && (component is MeshRenderer || component is SkinnedMeshRenderer))
					{
						MB3_AgglomerativeClustering.item_s item_s = new MB3_AgglomerativeClustering.item_s();
						item_s.go = gos[i];
						item_s.coord = component.bounds.center;
						list.Add(item_s);
					}
				}
			}
			cluster.items = list;
			cluster.agglomerate(progFunc);
			if (!cluster.wasCanceled)
			{
				_BuildListOfClustersToDraw(progFunc, out var smallest, out var largest);
				d.maxDistBetweenClusters = Mathf.Lerp(smallest, largest, 0.9f);
			}
		}

		private void _BuildListOfClustersToDraw(ProgressUpdateCancelableDelegate progFunc, out float smallest, out float largest)
		{
			_clustersToDraw.Clear();
			if (cluster.clusters == null)
			{
				smallest = 1f;
				largest = 10f;
				return;
			}
			progFunc?.Invoke("Building Clusters To Draw A:", 0f);
			List<MB3_AgglomerativeClustering.ClusterNode> list = new List<MB3_AgglomerativeClustering.ClusterNode>();
			largest = 1f;
			smallest = 10000000f;
			for (int i = 0; i < cluster.clusters.Length; i++)
			{
				MB3_AgglomerativeClustering.ClusterNode clusterNode = cluster.clusters[i];
				if (clusterNode.distToMergedCentroid <= d.maxDistBetweenClusters)
				{
					if (d.includeCellsWithOnlyOneRenderer)
					{
						_clustersToDraw.Add(clusterNode);
					}
					else if (clusterNode.leaf == null)
					{
						_clustersToDraw.Add(clusterNode);
					}
				}
				if (clusterNode.distToMergedCentroid > largest)
				{
					largest = clusterNode.distToMergedCentroid;
				}
				if (clusterNode.height > 0 && clusterNode.distToMergedCentroid < smallest)
				{
					smallest = clusterNode.distToMergedCentroid;
				}
			}
			progFunc?.Invoke("Building Clusters To Draw B:", 0f);
			for (int j = 0; j < _clustersToDraw.Count; j++)
			{
				list.Add(_clustersToDraw[j].cha);
				list.Add(_clustersToDraw[j].chb);
			}
			for (int k = 0; k < list.Count; k++)
			{
				_clustersToDraw.Remove(list[k]);
			}
			_radii = new float[_clustersToDraw.Count];
			progFunc?.Invoke("Building Clusters To Draw C:", 0f);
			for (int l = 0; l < _radii.Length; l++)
			{
				MB3_AgglomerativeClustering.ClusterNode clusterNode2 = _clustersToDraw[l];
				Bounds bounds = new Bounds(clusterNode2.centroid, Vector3.one);
				for (int m = 0; m < clusterNode2.leafs.Length; m++)
				{
					Renderer component = cluster.clusters[clusterNode2.leafs[m]].leaf.go.GetComponent<Renderer>();
					if (component != null)
					{
						bounds.Encapsulate(component.bounds);
					}
				}
				_radii[l] = bounds.extents.magnitude;
			}
			progFunc?.Invoke("Building Clusters To Draw D:", 0f);
			_ObjsExtents = largest + 1f;
			_minDistBetweenClusters = Mathf.Lerp(smallest, 0f, 0.9f);
			if (_ObjsExtents < 2f)
			{
				_ObjsExtents = 2f;
			}
		}

		public override void DrawGizmos(Bounds sceneObjectBounds)
		{
			if (cluster != null && cluster.clusters != null)
			{
				if (_lastMaxDistBetweenClusters != d.maxDistBetweenClusters)
				{
					_BuildListOfClustersToDraw(null, out var _, out var _);
					_lastMaxDistBetweenClusters = d.maxDistBetweenClusters;
				}
				for (int i = 0; i < _clustersToDraw.Count; i++)
				{
					Gizmos.color = UnityEngine.Color.white;
					Gizmos.DrawWireSphere(_clustersToDraw[i].centroid, _radii[i]);
				}
			}
		}
	}
	public interface TextureBlender
	{
		bool DoesShaderNameMatch(string shaderName);

		void OnBeforeTintTexture(Material sourceMat, string shaderTexturePropertyName);

		UnityEngine.Color OnBlendTexturePixel(string shaderPropertyName, UnityEngine.Color pixelColor);

		bool NonTexturePropertiesAreEqual(Material a, Material b);

		void SetNonTexturePropertyValuesOnResultMaterial(Material resultMaterial);

		UnityEngine.Color GetColorIfNoTexture(Material m, ShaderTextureProperty texPropertyName);
	}
	public class TextureBlenderFallback : TextureBlender
	{
		private bool m_doTintColor;

		private UnityEngine.Color m_tintColor;

		private UnityEngine.Color m_defaultColor = UnityEngine.Color.white;

		public bool DoesShaderNameMatch(string shaderName)
		{
			return true;
		}

		public void OnBeforeTintTexture(Material sourceMat, string shaderTexturePropertyName)
		{
			if (shaderTexturePropertyName.Equals("_MainTex"))
			{
				m_doTintColor = true;
				m_tintColor = UnityEngine.Color.white;
				if (sourceMat.HasProperty("_Color"))
				{
					m_tintColor = sourceMat.GetColor("_Color");
				}
				else if (sourceMat.HasProperty("_TintColor"))
				{
					m_tintColor = sourceMat.GetColor("_TintColor");
				}
			}
			else
			{
				m_doTintColor = false;
			}
		}

		public UnityEngine.Color OnBlendTexturePixel(string shaderPropertyName, UnityEngine.Color pixelColor)
		{
			if (m_doTintColor)
			{
				return new UnityEngine.Color(pixelColor.r * m_tintColor.r, pixelColor.g * m_tintColor.g, pixelColor.b * m_tintColor.b, pixelColor.a * m_tintColor.a);
			}
			return pixelColor;
		}

		public bool NonTexturePropertiesAreEqual(Material a, Material b)
		{
			if (a.HasProperty("_Color"))
			{
				if (_compareColor(a, b, m_defaultColor, "_Color"))
				{
					return true;
				}
			}
			else if (a.HasProperty("_TintColor") && _compareColor(a, b, m_defaultColor, "_TintColor"))
			{
				return true;
			}
			return false;
		}

		public void SetNonTexturePropertyValuesOnResultMaterial(Material resultMaterial)
		{
			if (resultMaterial.HasProperty("_Color"))
			{
				resultMaterial.SetColor("_Color", m_defaultColor);
			}
			else if (resultMaterial.HasProperty("_TintColor"))
			{
				resultMaterial.SetColor("_TintColor", m_defaultColor);
			}
		}

		public UnityEngine.Color GetColorIfNoTexture(Material mat, ShaderTextureProperty texProperty)
		{
			if (texProperty.isNormalMap)
			{
				return new UnityEngine.Color(0.5f, 0.5f, 1f);
			}
			if (texProperty.name.Equals("_MainTex"))
			{
				if (mat != null && mat.HasProperty("_Color"))
				{
					try
					{
						return mat.GetColor("_Color");
					}
					catch (Exception)
					{
					}
				}
				else if (mat != null && mat.HasProperty("_TintColor"))
				{
					try
					{
						return mat.GetColor("_TintColor");
					}
					catch (Exception)
					{
					}
				}
			}
			else if (texProperty.name.Equals("_SpecGlossMap"))
			{
				if (mat != null && mat.HasProperty("_SpecColor"))
				{
					try
					{
						UnityEngine.Color color = mat.GetColor("_SpecColor");
						if (mat.HasProperty("_Glossiness"))
						{
							try
							{
								color.a = mat.GetFloat("_Glossiness");
							}
							catch (Exception)
							{
							}
						}
						UnityEngine.Debug.LogWarning(color);
						return color;
					}
					catch (Exception)
					{
					}
				}
			}
			else if (texProperty.name.Equals("_MetallicGlossMap"))
			{
				if (mat != null && mat.HasProperty("_Metallic"))
				{
					try
					{
						float @float = mat.GetFloat("_Metallic");
						UnityEngine.Color result = new UnityEngine.Color(@float, @float, @float);
						if (mat.HasProperty("_Glossiness"))
						{
							try
							{
								result.a = mat.GetFloat("_Glossiness");
							}
							catch (Exception)
							{
							}
						}
						return result;
					}
					catch (Exception)
					{
					}
				}
			}
			else
			{
				if (texProperty.name.Equals("_ParallaxMap"))
				{
					return new UnityEngine.Color(0f, 0f, 0f, 0f);
				}
				if (texProperty.name.Equals("_OcclusionMap"))
				{
					return new UnityEngine.Color(1f, 1f, 1f, 1f);
				}
				if (texProperty.name.Equals("_EmissionMap"))
				{
					if (mat != null && mat.HasProperty("_EmissionScaleUI"))
					{
						if (mat.HasProperty("_EmissionColor") && mat.HasProperty("_EmissionColorUI"))
						{
							try
							{
								UnityEngine.Color color2 = mat.GetColor("_EmissionColor");
								UnityEngine.Color color3 = mat.GetColor("_EmissionColorUI");
								float float2 = mat.GetFloat("_EmissionScaleUI");
								if (color2 == new UnityEngine.Color(0f, 0f, 0f, 0f) && color3 == new UnityEngine.Color(1f, 1f, 1f, 1f))
								{
									return new UnityEngine.Color(float2, float2, float2, float2);
								}
								return color3;
							}
							catch (Exception)
							{
							}
						}
						else
						{
							try
							{
								float float3 = mat.GetFloat("_EmissionScaleUI");
								return new UnityEngine.Color(float3, float3, float3, float3);
							}
							catch (Exception)
							{
							}
						}
					}
				}
				else if (texProperty.name.Equals("_DetailMask"))
				{
					return new UnityEngine.Color(0f, 0f, 0f, 0f);
				}
			}
			return new UnityEngine.Color(1f, 1f, 1f, 0f);
		}

		public static bool _compareColor(Material a, Material b, UnityEngine.Color defaultVal, string propertyName)
		{
			UnityEngine.Color color = defaultVal;
			UnityEngine.Color color2 = defaultVal;
			if (a.HasProperty(propertyName))
			{
				color = a.GetColor(propertyName);
			}
			if (b.HasProperty(propertyName))
			{
				color2 = b.GetColor(propertyName);
			}
			if (color != color2)
			{
				return false;
			}
			return true;
		}

		public static bool _compareFloat(Material a, Material b, float defaultVal, string propertyName)
		{
			float num = defaultVal;
			float num2 = defaultVal;
			if (a.HasProperty(propertyName))
			{
				num = a.GetFloat(propertyName);
			}
			if (b.HasProperty(propertyName))
			{
				num2 = b.GetFloat(propertyName);
			}
			if (num != num2)
			{
				return false;
			}
			return true;
		}
	}
	public class TextureBlenderLegacyBumpDiffuse : TextureBlender
	{
		private bool doColor;

		private UnityEngine.Color m_tintColor;

		private UnityEngine.Color m_defaultTintColor = UnityEngine.Color.white;

		public bool DoesShaderNameMatch(string shaderName)
		{
			if (shaderName.Equals("Legacy Shaders/Bumped Diffuse"))
			{
				return true;
			}
			if (shaderName.Equals("Bumped Diffuse"))
			{
				return true;
			}
			return false;
		}

		public void OnBeforeTintTexture(Material sourceMat, string shaderTexturePropertyName)
		{
			if (shaderTexturePropertyName.EndsWith("_MainTex"))
			{
				doColor = true;
				m_tintColor = sourceMat.GetColor("_Color");
			}
			else
			{
				doColor = false;
			}
		}

		public UnityEngine.Color OnBlendTexturePixel(string propertyToDoshaderPropertyName, UnityEngine.Color pixelColor)
		{
			if (doColor)
			{
				return new UnityEngine.Color(pixelColor.r * m_tintColor.r, pixelColor.g * m_tintColor.g, pixelColor.b * m_tintColor.b, pixelColor.a * m_tintColor.a);
			}
			return pixelColor;
		}

		public bool NonTexturePropertiesAreEqual(Material a, Material b)
		{
			return TextureBlenderFallback._compareColor(a, b, m_defaultTintColor, "_Color");
		}

		public void SetNonTexturePropertyValuesOnResultMaterial(Material resultMaterial)
		{
			resultMaterial.SetColor("_Color", UnityEngine.Color.white);
		}

		public UnityEngine.Color GetColorIfNoTexture(Material m, ShaderTextureProperty texPropertyName)
		{
			if (texPropertyName.name.Equals("_BumpMap"))
			{
				return new UnityEngine.Color(0.5f, 0.5f, 1f);
			}
			if (texPropertyName.name.Equals("_MainTex") && m != null && m.HasProperty("_Color"))
			{
				try
				{
					return m.GetColor("_Color");
				}
				catch (Exception)
				{
				}
			}
			return new UnityEngine.Color(1f, 1f, 1f, 0f);
		}
	}
	public class TextureBlenderLegacyDiffuse : TextureBlender
	{
		private bool doColor;

		private UnityEngine.Color m_tintColor;

		private UnityEngine.Color m_defaultTintColor = UnityEngine.Color.white;

		public bool DoesShaderNameMatch(string shaderName)
		{
			if (shaderName.Equals("Legacy Shaders/Diffuse"))
			{
				return true;
			}
			if (shaderName.Equals("Diffuse"))
			{
				return true;
			}
			return false;
		}

		public void OnBeforeTintTexture(Material sourceMat, string shaderTexturePropertyName)
		{
			if (shaderTexturePropertyName.EndsWith("_MainTex"))
			{
				doColor = true;
				m_tintColor = sourceMat.GetColor("_Color");
			}
			else
			{
				doColor = false;
			}
		}

		public UnityEngine.Color OnBlendTexturePixel(string propertyToDoshaderPropertyName, UnityEngine.Color pixelColor)
		{
			if (doColor)
			{
				return new UnityEngine.Color(pixelColor.r * m_tintColor.r, pixelColor.g * m_tintColor.g, pixelColor.b * m_tintColor.b, pixelColor.a * m_tintColor.a);
			}
			return pixelColor;
		}

		public bool NonTexturePropertiesAreEqual(Material a, Material b)
		{
			return TextureBlenderFallback._compareColor(a, b, m_defaultTintColor, "_Color");
		}

		public void SetNonTexturePropertyValuesOnResultMaterial(Material resultMaterial)
		{
			resultMaterial.SetColor("_Color", UnityEngine.Color.white);
		}

		public UnityEngine.Color GetColorIfNoTexture(Material m, ShaderTextureProperty texPropertyName)
		{
			if (texPropertyName.name.Equals("_MainTex") && m != null && m.HasProperty("_Color"))
			{
				try
				{
					return m.GetColor("_Color");
				}
				catch (Exception)
				{
				}
			}
			return new UnityEngine.Color(1f, 1f, 1f, 0f);
		}
	}
	public class TextureBlenderMaterialPropertyCacheHelper
	{
		private struct MaterialPropertyPair
		{
			public Material material;

			public string property;

			public MaterialPropertyPair(Material m, string prop)
			{
				material = m;
				property = prop;
			}

			public override bool Equals(object obj)
			{
				if (!(obj is MaterialPropertyPair materialPropertyPair))
				{
					return false;
				}
				if (!material.Equals(materialPropertyPair.material))
				{
					return false;
				}
				if (property != materialPropertyPair.property)
				{
					return false;
				}
				return true;
			}

			public override int GetHashCode()
			{
				return base.GetHashCode();
			}
		}

		private Dictionary<MaterialPropertyPair, object> nonTexturePropertyValuesForSourceMaterials = new Dictionary<MaterialPropertyPair, object>();

		private bool AllNonTexturePropertyValuesAreEqual(string prop)
		{
			bool flag = false;
			object obj = null;
			foreach (MaterialPropertyPair key in nonTexturePropertyValuesForSourceMaterials.Keys)
			{
				if (key.property.Equals(prop))
				{
					if (!flag)
					{
						obj = nonTexturePropertyValuesForSourceMaterials[key];
						flag = true;
					}
					else if (!obj.Equals(nonTexturePropertyValuesForSourceMaterials[key]))
					{
						return false;
					}
				}
			}
			return true;
		}

		public void CacheMaterialProperty(Material m, string property, object value)
		{
			nonTexturePropertyValuesForSourceMaterials[new MaterialPropertyPair(m, property)] = value;
		}

		public object GetValueIfAllSourceAreTheSameOrDefault(string property, object defaultValue)
		{
			if (AllNonTexturePropertyValuesAreEqual(property))
			{
				foreach (MaterialPropertyPair key in nonTexturePropertyValuesForSourceMaterials.Keys)
				{
					if (key.property.Equals(property))
					{
						return nonTexturePropertyValuesForSourceMaterials[key];
					}
				}
			}
			return defaultValue;
		}
	}
	public class TextureBlenderStandardMetallic : TextureBlender
	{
		private enum Prop
		{
			doColor,
			doMetallic,
			doEmission,
			doBump,
			doNone
		}

		private static UnityEngine.Color NeutralNormalMap = new UnityEngine.Color(0.5f, 0.5f, 1f);

		private TextureBlenderMaterialPropertyCacheHelper sourceMaterialPropertyCache = new TextureBlenderMaterialPropertyCacheHelper();

		private UnityEngine.Color m_tintColor;

		private float m_glossiness;

		private float m_glossMapScale;

		private float m_metallic;

		private bool m_hasMetallicGlossMap;

		private float m_bumpScale;

		private bool m_shaderDoesEmission;

		private UnityEngine.Color m_emissionColor;

		private Prop propertyToDo = Prop.doNone;

		private UnityEngine.Color m_generatingTintedAtlasColor = UnityEngine.Color.white;

		private float m_generatingTintedAtlasMetallic;

		private float m_generatingTintedAtlasGlossiness = 1f;

		private float m_generatingTintedAtlasGlossMapScale = 1f;

		private float m_generatingTintedAtlasBumpScale = 1f;

		private UnityEngine.Color m_generatingTintedAtlasEmission = UnityEngine.Color.white;

		private UnityEngine.Color m_notGeneratingAtlasDefaultColor = UnityEngine.Color.white;

		private float m_notGeneratingAtlasDefaultMetallic;

		private float m_notGeneratingAtlasDefaultGlossiness = 0.5f;

		private UnityEngine.Color m_notGeneratingAtlasDefaultEmisionColor = UnityEngine.Color.black;

		public bool DoesShaderNameMatch(string shaderName)
		{
			return shaderName.Equals("Standard");
		}

		public void OnBeforeTintTexture(Material sourceMat, string shaderTexturePropertyName)
		{
			if (shaderTexturePropertyName.Equals("_MainTex"))
			{
				propertyToDo = Prop.doColor;
				if (sourceMat.HasProperty("_Color"))
				{
					m_tintColor = sourceMat.GetColor("_Color");
				}
				else
				{
					m_tintColor = m_generatingTintedAtlasColor;
				}
			}
			else if (shaderTexturePropertyName.Equals("_MetallicGlossMap"))
			{
				propertyToDo = Prop.doMetallic;
				m_metallic = m_generatingTintedAtlasMetallic;
				if (sourceMat.GetTexture("_MetallicGlossMap") != null)
				{
					m_hasMetallicGlossMap = true;
				}
				else
				{
					m_hasMetallicGlossMap = false;
				}
				if (sourceMat.HasProperty("_Metallic"))
				{
					m_metallic = sourceMat.GetFloat("_Metallic");
				}
				else
				{
					m_metallic = 0f;
				}
				if (sourceMat.HasProperty("_GlossMapScale"))
				{
					m_glossMapScale = sourceMat.GetFloat("_GlossMapScale");
				}
				else
				{
					m_glossMapScale = 1f;
				}
				if (sourceMat.HasProperty("_Glossiness"))
				{
					m_glossiness = sourceMat.GetFloat("_Glossiness");
				}
				else
				{
					m_glossiness = 0f;
				}
			}
			else if (shaderTexturePropertyName.Equals("_BumpMap"))
			{
				propertyToDo = Prop.doBump;
				if (sourceMat.HasProperty(shaderTexturePropertyName))
				{
					if (sourceMat.HasProperty("_BumpScale"))
					{
						m_bumpScale = sourceMat.GetFloat("_BumpScale");
					}
				}
				else
				{
					m_bumpScale = m_generatingTintedAtlasBumpScale;
				}
			}
			else if (shaderTexturePropertyName.Equals("_EmissionMap"))
			{
				propertyToDo = Prop.doEmission;
				m_shaderDoesEmission = sourceMat.IsKeywordEnabled("_EMISSION");
				if (sourceMat.HasProperty("_EmissionColor"))
				{
					m_emissionColor = sourceMat.GetColor("_EmissionColor");
				}
				else
				{
					m_emissionColor = m_notGeneratingAtlasDefaultEmisionColor;
				}
			}
			else
			{
				propertyToDo = Prop.doNone;
			}
		}

		public UnityEngine.Color OnBlendTexturePixel(string propertyToDoshaderPropertyName, UnityEngine.Color pixelColor)
		{
			if (propertyToDo == Prop.doColor)
			{
				return new UnityEngine.Color(pixelColor.r * m_tintColor.r, pixelColor.g * m_tintColor.g, pixelColor.b * m_tintColor.b, pixelColor.a * m_tintColor.a);
			}
			if (propertyToDo == Prop.doMetallic)
			{
				if (m_hasMetallicGlossMap)
				{
					pixelColor = new UnityEngine.Color(pixelColor.r, pixelColor.g, pixelColor.b, pixelColor.a * m_glossMapScale);
					return pixelColor;
				}
				return new UnityEngine.Color(m_metallic, 0f, 0f, m_glossiness);
			}
			if (propertyToDo == Prop.doBump)
			{
				return UnityEngine.Color.Lerp(NeutralNormalMap, pixelColor, m_bumpScale);
			}
			if (propertyToDo == Prop.doEmission)
			{
				if (m_shaderDoesEmission)
				{
					return new UnityEngine.Color(pixelColor.r * m_emissionColor.r, pixelColor.g * m_emissionColor.g, pixelColor.b * m_emissionColor.b, pixelColor.a * m_emissionColor.a);
				}
				return UnityEngine.Color.black;
			}
			return pixelColor;
		}

		public bool NonTexturePropertiesAreEqual(Material a, Material b)
		{
			if (!TextureBlenderFallback._compareColor(a, b, m_notGeneratingAtlasDefaultColor, "_Color"))
			{
				return false;
			}
			if (!TextureBlenderFallback._compareFloat(a, b, m_notGeneratingAtlasDefaultGlossiness, "_Glossiness"))
			{
				return false;
			}
			bool flag = a.HasProperty("_MetallicGlossMap") && a.GetTexture("_MetallicGlossMap") != null;
			bool flag2 = b.HasProperty("_MetallicGlossMap") && b.GetTexture("_MetallicGlossMap") != null;
			if (flag && flag2)
			{
				if (!TextureBlenderFallback._compareFloat(a, b, m_notGeneratingAtlasDefaultMetallic, "_GlossMapScale"))
				{
					return false;
				}
			}
			else
			{
				if (flag || flag2)
				{
					return false;
				}
				if (!TextureBlenderFallback._compareFloat(a, b, m_notGeneratingAtlasDefaultMetallic, "_Metallic"))
				{
					return false;
				}
			}
			if (a.IsKeywordEnabled("_EMISSION") != b.IsKeywordEnabled("_EMISSION"))
			{
				return false;
			}
			if (a.IsKeywordEnabled("_EMISSION") && !TextureBlenderFallback._compareColor(a, b, m_notGeneratingAtlasDefaultEmisionColor, "_EmissionColor"))
			{
				return false;
			}
			return true;
		}

		public void SetNonTexturePropertyValuesOnResultMaterial(Material resultMaterial)
		{
			if (resultMaterial.GetTexture("_MainTex") != null)
			{
				resultMaterial.SetColor("_Color", m_generatingTintedAtlasColor);
			}
			else
			{
				resultMaterial.SetColor("_Color", (UnityEngine.Color)sourceMaterialPropertyCache.GetValueIfAllSourceAreTheSameOrDefault("_Color", m_notGeneratingAtlasDefaultColor));
			}
			if (resultMaterial.GetTexture("_MetallicGlossMap") != null)
			{
				resultMaterial.SetFloat("_Metallic", m_generatingTintedAtlasMetallic);
				resultMaterial.SetFloat("_GlossMapScale", m_generatingTintedAtlasGlossMapScale);
				resultMaterial.SetFloat("_Glossiness", m_generatingTintedAtlasGlossiness);
			}
			else
			{
				resultMaterial.SetFloat("_Metallic", (float)sourceMaterialPropertyCache.GetValueIfAllSourceAreTheSameOrDefault("_Metallic", m_notGeneratingAtlasDefaultMetallic));
				resultMaterial.SetFloat("_Glossiness", (float)sourceMaterialPropertyCache.GetValueIfAllSourceAreTheSameOrDefault("_Glossiness", m_notGeneratingAtlasDefaultGlossiness));
			}
			if (resultMaterial.GetTexture("_BumpMap") != null)
			{
				resultMaterial.SetFloat("_BumpScale", m_generatingTintedAtlasBumpScale);
			}
			if (resultMaterial.GetTexture("_EmissionMap") != null)
			{
				resultMaterial.EnableKeyword("_EMISSION");
				resultMaterial.SetColor("_EmissionColor", m_generatingTintedAtlasEmission);
			}
			else
			{
				resultMaterial.DisableKeyword("_EMISSION");
				resultMaterial.SetColor("_EmissionColor", (UnityEngine.Color)sourceMaterialPropertyCache.GetValueIfAllSourceAreTheSameOrDefault("_EmissionColor", m_notGeneratingAtlasDefaultEmisionColor));
			}
		}

		public UnityEngine.Color GetColorIfNoTexture(Material mat, ShaderTextureProperty texPropertyName)
		{
			if (texPropertyName.name.Equals("_BumpMap"))
			{
				return new UnityEngine.Color(0.5f, 0.5f, 1f);
			}
			if (texPropertyName.name.Equals("_MainTex"))
			{
				if (mat != null && mat.HasProperty("_Color"))
				{
					try
					{
						UnityEngine.Color color = mat.GetColor("_Color");
						sourceMaterialPropertyCache.CacheMaterialProperty(mat, "_Color", color);
					}
					catch (Exception)
					{
					}
					return UnityEngine.Color.white;
				}
			}
			else
			{
				if (texPropertyName.name.Equals("_MetallicGlossMap"))
				{
					if (mat != null && mat.HasProperty("_Metallic"))
					{
						try
						{
							float @float = mat.GetFloat("_Metallic");
							UnityEngine.Color color2 = new UnityEngine.Color(@float, @float, @float);
							if (mat.HasProperty("_Glossiness"))
							{
								try
								{
									color2.a = mat.GetFloat("_Glossiness");
								}
								catch (Exception)
								{
								}
							}
							sourceMaterialPropertyCache.CacheMaterialProperty(mat, "_Metallic", @float);
							sourceMaterialPropertyCache.CacheMaterialProperty(mat, "_Glossiness", color2.a);
						}
						catch (Exception)
						{
						}
						return new UnityEngine.Color(0f, 0f, 0f, 0.5f);
					}
					return new UnityEngine.Color(0f, 0f, 0f, 0.5f);
				}
				if (texPropertyName.name.Equals("_ParallaxMap"))
				{
					return new UnityEngine.Color(0f, 0f, 0f, 0f);
				}
				if (texPropertyName.name.Equals("_OcclusionMap"))
				{
					return new UnityEngine.Color(1f, 1f, 1f, 1f);
				}
				if (texPropertyName.name.Equals("_EmissionMap"))
				{
					if (mat != null)
					{
						if (!mat.IsKeywordEnabled("_EMISSION"))
						{
							return UnityEngine.Color.black;
						}
						if (!mat.HasProperty("_EmissionColor"))
						{
							return UnityEngine.Color.black;
						}
						try
						{
							UnityEngine.Color color3 = mat.GetColor("_EmissionColor");
							sourceMaterialPropertyCache.CacheMaterialProperty(mat, "_EmissionColor", color3);
						}
						catch (Exception)
						{
						}
					}
				}
				else if (texPropertyName.name.Equals("_DetailMask"))
				{
					return new UnityEngine.Color(0f, 0f, 0f, 0f);
				}
			}
			return new UnityEngine.Color(1f, 1f, 1f, 0f);
		}
	}
	public class TextureBlenderStandardMetallicRoughness : TextureBlender
	{
		private enum Prop
		{
			doColor,
			doMetallic,
			doRoughness,
			doEmission,
			doBump,
			doNone
		}

		private static UnityEngine.Color NeutralNormalMap = new UnityEngine.Color(0.5f, 0.5f, 1f);

		private TextureBlenderMaterialPropertyCacheHelper sourceMaterialPropertyCache = new TextureBlenderMaterialPropertyCacheHelper();

		private UnityEngine.Color m_tintColor;

		private float m_roughness;

		private float m_metallic;

		private bool m_hasMetallicGlossMap;

		private bool m_hasSpecGlossMap;

		private float m_bumpScale;

		private bool m_shaderDoesEmission;

		private UnityEngine.Color m_emissionColor;

		private Prop propertyToDo = Prop.doNone;

		private UnityEngine.Color m_generatingTintedAtlasColor = UnityEngine.Color.white;

		private float m_generatingTintedAtlasMetallic;

		private float m_generatingTintedAtlasRoughness = 0.5f;

		private float m_generatingTintedAtlasBumpScale = 1f;

		private UnityEngine.Color m_generatingTintedAtlasEmission = UnityEngine.Color.white;

		private UnityEngine.Color m_notGeneratingAtlasDefaultColor = UnityEngine.Color.white;

		private float m_notGeneratingAtlasDefaultMetallic;

		private float m_notGeneratingAtlasDefaultGlossiness = 0.5f;

		private UnityEngine.Color m_notGeneratingAtlasDefaultEmisionColor = UnityEngine.Color.black;

		public bool DoesShaderNameMatch(string shaderName)
		{
			return shaderName.Equals("Standard (Roughness setup)");
		}

		public void OnBeforeTintTexture(Material sourceMat, string shaderTexturePropertyName)
		{
			if (shaderTexturePropertyName.Equals("_MainTex"))
			{
				propertyToDo = Prop.doColor;
				if (sourceMat.HasProperty("_Color"))
				{
					m_tintColor = sourceMat.GetColor("_Color");
				}
				else
				{
					m_tintColor = m_generatingTintedAtlasColor;
				}
			}
			else if (shaderTexturePropertyName.Equals("_MetallicGlossMap"))
			{
				propertyToDo = Prop.doMetallic;
				m_metallic = m_generatingTintedAtlasMetallic;
				if (sourceMat.GetTexture("_MetallicGlossMap") != null)
				{
					m_hasMetallicGlossMap = true;
				}
				else
				{
					m_hasMetallicGlossMap = false;
				}
				if (sourceMat.HasProperty("_Metallic"))
				{
					m_metallic = sourceMat.GetFloat("_Metallic");
				}
				else
				{
					m_metallic = 0f;
				}
			}
			else if (shaderTexturePropertyName.Equals("_SpecGlossMap"))
			{
				propertyToDo = Prop.doRoughness;
				m_roughness = m_generatingTintedAtlasRoughness;
				if (sourceMat.GetTexture("_SpecGlossMap") != null)
				{
					m_hasSpecGlossMap = true;
				}
				else
				{
					m_hasSpecGlossMap = false;
				}
				if (sourceMat.HasProperty("_Glossiness"))
				{
					m_roughness = sourceMat.GetFloat("_Glossiness");
				}
				else
				{
					m_roughness = 1f;
				}
			}
			else if (shaderTexturePropertyName.Equals("_BumpMap"))
			{
				propertyToDo = Prop.doBump;
				if (sourceMat.HasProperty(shaderTexturePropertyName))
				{
					if (sourceMat.HasProperty("_BumpScale"))
					{
						m_bumpScale = sourceMat.GetFloat("_BumpScale");
					}
				}
				else
				{
					m_bumpScale = m_generatingTintedAtlasBumpScale;
				}
			}
			else if (shaderTexturePropertyName.Equals("_EmissionMap"))
			{
				propertyToDo = Prop.doEmission;
				m_shaderDoesEmission = sourceMat.IsKeywordEnabled("_EMISSION");
				if (sourceMat.HasProperty("_EmissionColor"))
				{
					m_emissionColor = sourceMat.GetColor("_EmissionColor");
				}
				else
				{
					m_emissionColor = m_notGeneratingAtlasDefaultEmisionColor;
				}
			}
			else
			{
				propertyToDo = Prop.doNone;
			}
		}

		public UnityEngine.Color OnBlendTexturePixel(string propertyToDoshaderPropertyName, UnityEngine.Color pixelColor)
		{
			if (propertyToDo == Prop.doColor)
			{
				return new UnityEngine.Color(pixelColor.r * m_tintColor.r, pixelColor.g * m_tintColor.g, pixelColor.b * m_tintColor.b, pixelColor.a * m_tintColor.a);
			}
			if (propertyToDo == Prop.doMetallic)
			{
				if (m_hasMetallicGlossMap)
				{
					return pixelColor;
				}
				return new UnityEngine.Color(m_metallic, 0f, 0f, m_roughness);
			}
			if (propertyToDo == Prop.doRoughness)
			{
				if (m_hasSpecGlossMap)
				{
					return pixelColor;
				}
				return new UnityEngine.Color(m_roughness, 0f, 0f, 0f);
			}
			if (propertyToDo == Prop.doBump)
			{
				return UnityEngine.Color.Lerp(NeutralNormalMap, pixelColor, m_bumpScale);
			}
			if (propertyToDo == Prop.doEmission)
			{
				if (m_shaderDoesEmission)
				{
					return new UnityEngine.Color(pixelColor.r * m_emissionColor.r, pixelColor.g * m_emissionColor.g, pixelColor.b * m_emissionColor.b, pixelColor.a * m_emissionColor.a);
				}
				return UnityEngine.Color.black;
			}
			return pixelColor;
		}

		public bool NonTexturePropertiesAreEqual(Material a, Material b)
		{
			if (!TextureBlenderFallback._compareColor(a, b, m_notGeneratingAtlasDefaultColor, "_Color"))
			{
				return false;
			}
			bool num = a.HasProperty("_MetallicGlossMap") && a.GetTexture("_MetallicGlossMap") != null;
			bool flag = b.HasProperty("_MetallicGlossMap") && b.GetTexture("_MetallicGlossMap") != null;
			if (!num && !flag)
			{
				if (!TextureBlenderFallback._compareFloat(a, b, m_notGeneratingAtlasDefaultMetallic, "_Metallic"))
				{
					return false;
				}
				bool num2 = a.HasProperty("_SpecGlossMap") && a.GetTexture("_SpecGlossMap") != null;
				bool flag2 = b.HasProperty("_SpecGlossMap") && b.GetTexture("_SpecGlossMap") != null;
				if (!num2 && !flag2)
				{
					if (!TextureBlenderFallback._compareFloat(a, b, m_generatingTintedAtlasRoughness, "_Glossiness"))
					{
						return false;
					}
					if (!TextureBlenderFallback._compareFloat(a, b, m_generatingTintedAtlasBumpScale, "_bumpScale"))
					{
						return false;
					}
					if (!TextureBlenderFallback._compareFloat(a, b, m_generatingTintedAtlasRoughness, "_Glossiness"))
					{
						return false;
					}
					if (a.IsKeywordEnabled("_EMISSION") != b.IsKeywordEnabled("_EMISSION"))
					{
						return false;
					}
					if (a.IsKeywordEnabled("_EMISSION") && !TextureBlenderFallback._compareColor(a, b, m_generatingTintedAtlasEmission, "_EmissionColor"))
					{
						return false;
					}
					return true;
				}
				return false;
			}
			return false;
		}

		public void SetNonTexturePropertyValuesOnResultMaterial(Material resultMaterial)
		{
			if (resultMaterial.GetTexture("_MainTex") != null)
			{
				resultMaterial.SetColor("_Color", m_generatingTintedAtlasColor);
			}
			else
			{
				resultMaterial.SetColor("_Color", (UnityEngine.Color)sourceMaterialPropertyCache.GetValueIfAllSourceAreTheSameOrDefault("_Color", m_notGeneratingAtlasDefaultColor));
			}
			if (resultMaterial.GetTexture("_MetallicGlossMap") != null)
			{
				resultMaterial.SetFloat("_Metallic", m_generatingTintedAtlasMetallic);
			}
			else
			{
				resultMaterial.SetFloat("_Metallic", (float)sourceMaterialPropertyCache.GetValueIfAllSourceAreTheSameOrDefault("_Metallic", m_notGeneratingAtlasDefaultMetallic));
			}
			if (!(resultMaterial.GetTexture("_SpecGlossMap") != null))
			{
				resultMaterial.SetFloat("_Glossiness", (float)sourceMaterialPropertyCache.GetValueIfAllSourceAreTheSameOrDefault("_Glossiness", m_notGeneratingAtlasDefaultGlossiness));
			}
			if (resultMaterial.GetTexture("_BumpMap") != null)
			{
				resultMaterial.SetFloat("_BumpScale", m_generatingTintedAtlasBumpScale);
			}
			else
			{
				resultMaterial.SetFloat("_BumpScale", m_generatingTintedAtlasBumpScale);
			}
			if (resultMaterial.GetTexture("_EmissionMap") != null)
			{
				resultMaterial.EnableKeyword("_EMISSION");
				resultMaterial.SetColor("_EmissionColor", UnityEngine.Color.white);
			}
			else
			{
				resultMaterial.DisableKeyword("_EMISSION");
				resultMaterial.SetColor("_EmissionColor", (UnityEngine.Color)sourceMaterialPropertyCache.GetValueIfAllSourceAreTheSameOrDefault("_EmissionColor", m_notGeneratingAtlasDefaultEmisionColor));
			}
		}

		public UnityEngine.Color GetColorIfNoTexture(Material mat, ShaderTextureProperty texPropertyName)
		{
			if (texPropertyName.name.Equals("_BumpMap"))
			{
				return new UnityEngine.Color(0.5f, 0.5f, 1f);
			}
			if (texPropertyName.name.Equals("_MainTex"))
			{
				if (mat != null && mat.HasProperty("_Color"))
				{
					try
					{
						UnityEngine.Color color = mat.GetColor("_Color");
						sourceMaterialPropertyCache.CacheMaterialProperty(mat, "_Color", color);
					}
					catch (Exception)
					{
					}
					return UnityEngine.Color.white;
				}
			}
			else
			{
				if (texPropertyName.name.Equals("_MetallicGlossMap"))
				{
					if (mat != null && mat.HasProperty("_Metallic"))
					{
						try
						{
							float @float = mat.GetFloat("_Metallic");
							sourceMaterialPropertyCache.CacheMaterialProperty(mat, "_Metallic", @float);
						}
						catch (Exception)
						{
						}
						return new UnityEngine.Color(0f, 0f, 0f, 0.5f);
					}
					return new UnityEngine.Color(0f, 0f, 0f, 0.5f);
				}
				if (texPropertyName.name.Equals("_SpecGlossMap"))
				{
					bool flag = false;
					try
					{
						UnityEngine.Color color2 = new UnityEngine.Color(0f, 0f, 0f, 0.5f);
						if (mat.HasProperty("_Glossiness"))
						{
							try
							{
								flag = true;
								color2.a = mat.GetFloat("_Glossiness");
							}
							catch (Exception)
							{
							}
						}
						sourceMaterialPropertyCache.CacheMaterialProperty(mat, "_Glossiness", color2.a);
						return new UnityEngine.Color(0f, 0f, 0f, 0.5f);
					}
					catch (Exception)
					{
					}
					if (!flag)
					{
						return new UnityEngine.Color(0f, 0f, 0f, 0.5f);
					}
				}
				else
				{
					if (texPropertyName.name.Equals("_ParallaxMap"))
					{
						return new UnityEngine.Color(0f, 0f, 0f, 0f);
					}
					if (texPropertyName.name.Equals("_OcclusionMap"))
					{
						return new UnityEngine.Color(1f, 1f, 1f, 1f);
					}
					if (texPropertyName.name.Equals("_EmissionMap"))
					{
						if (mat != null)
						{
							if (!mat.IsKeywordEnabled("_EMISSION"))
							{
								return UnityEngine.Color.black;
							}
							if (!mat.HasProperty("_EmissionColor"))
							{
								return UnityEngine.Color.black;
							}
							try
							{
								UnityEngine.Color color3 = mat.GetColor("_EmissionColor");
								sourceMaterialPropertyCache.CacheMaterialProperty(mat, "_EmissionColor", color3);
							}
							catch (Exception)
							{
							}
						}
					}
					else if (texPropertyName.name.Equals("_DetailMask"))
					{
						return new UnityEngine.Color(0f, 0f, 0f, 0f);
					}
				}
			}
			return new UnityEngine.Color(1f, 1f, 1f, 0f);
		}
	}
	public class TextureBlenderStandardSpecular : TextureBlender
	{
		private enum Prop
		{
			doColor,
			doSpecular,
			doEmission,
			doBump,
			doNone
		}

		private static UnityEngine.Color NeutralNormalMap = new UnityEngine.Color(0.5f, 0.5f, 1f);

		private TextureBlenderMaterialPropertyCacheHelper sourceMaterialPropertyCache = new TextureBlenderMaterialPropertyCacheHelper();

		private UnityEngine.Color m_tintColor;

		private float m_glossiness;

		private float m_SpecGlossMapScale;

		private UnityEngine.Color m_specColor;

		private bool m_hasSpecGlossMap;

		private float m_bumpScale;

		private bool m_shaderDoesEmission;

		private UnityEngine.Color m_emissionColor;

		private Prop propertyToDo = Prop.doNone;

		private UnityEngine.Color m_generatingTintedAtlaColor = UnityEngine.Color.white;

		private UnityEngine.Color m_generatingTintedAtlaSpecular = UnityEngine.Color.black;

		private float m_generatingTintedAtlaGlossiness = 1f;

		private float m_generatingTintedAtlaSpecGlossMapScale = 1f;

		private float m_generatingTintedAtlaBumpScale = 1f;

		private UnityEngine.Color m_generatingTintedAtlaEmission = UnityEngine.Color.white;

		private UnityEngine.Color m_notGeneratingAtlasDefaultColor = UnityEngine.Color.white;

		private UnityEngine.Color m_notGeneratingAtlasDefaultSpecularColor = new UnityEngine.Color(0f, 0f, 0f, 1f);

		private float m_notGeneratingAtlasDefaultGlossiness = 0.5f;

		private UnityEngine.Color m_notGeneratingAtlasDefaultEmisionColor = UnityEngine.Color.black;

		public bool DoesShaderNameMatch(string shaderName)
		{
			return shaderName.Equals("Standard (Specular setup)");
		}

		public void OnBeforeTintTexture(Material sourceMat, string shaderTexturePropertyName)
		{
			if (shaderTexturePropertyName.Equals("_MainTex"))
			{
				propertyToDo = Prop.doColor;
				if (sourceMat.HasProperty("_Color"))
				{
					m_tintColor = sourceMat.GetColor("_Color");
				}
				else
				{
					m_tintColor = m_generatingTintedAtlaColor;
				}
			}
			else if (shaderTexturePropertyName.Equals("_SpecGlossMap"))
			{
				propertyToDo = Prop.doSpecular;
				m_specColor = m_generatingTintedAtlaSpecular;
				if (sourceMat.GetTexture("_SpecGlossMap") != null)
				{
					m_hasSpecGlossMap = true;
				}
				else
				{
					m_hasSpecGlossMap = false;
				}
				if (sourceMat.HasProperty("_SpecColor"))
				{
					m_specColor = sourceMat.GetColor("_SpecColor");
				}
				else
				{
					m_specColor = new UnityEngine.Color(0f, 0f, 0f, 1f);
				}
				if (sourceMat.HasProperty("_GlossMapScale"))
				{
					m_SpecGlossMapScale = sourceMat.GetFloat("_GlossMapScale");
				}
				else
				{
					m_SpecGlossMapScale = 1f;
				}
				if (sourceMat.HasProperty("_Glossiness"))
				{
					m_glossiness = sourceMat.GetFloat("_Glossiness");
				}
				else
				{
					m_glossiness = 0f;
				}
			}
			else if (shaderTexturePropertyName.Equals("_BumpMap"))
			{
				propertyToDo = Prop.doBump;
				if (sourceMat.HasProperty(shaderTexturePropertyName))
				{
					if (sourceMat.HasProperty("_BumpScale"))
					{
						m_bumpScale = sourceMat.GetFloat("_BumpScale");
					}
				}
				else
				{
					m_bumpScale = m_generatingTintedAtlaBumpScale;
				}
			}
			else if (shaderTexturePropertyName.Equals("_EmissionMap"))
			{
				propertyToDo = Prop.doEmission;
				m_shaderDoesEmission = sourceMat.IsKeywordEnabled("_EMISSION");
				if (sourceMat.HasProperty("_EmissionColor"))
				{
					m_emissionColor = sourceMat.GetColor("_EmissionColor");
				}
				else
				{
					m_generatingTintedAtlaColor = m_notGeneratingAtlasDefaultEmisionColor;
				}
			}
			else
			{
				propertyToDo = Prop.doNone;
			}
		}

		public UnityEngine.Color OnBlendTexturePixel(string propertyToDoshaderPropertyName, UnityEngine.Color pixelColor)
		{
			if (propertyToDo == Prop.doColor)
			{
				return new UnityEngine.Color(pixelColor.r * m_tintColor.r, pixelColor.g * m_tintColor.g, pixelColor.b * m_tintColor.b, pixelColor.a * m_tintColor.a);
			}
			if (propertyToDo == Prop.doSpecular)
			{
				if (m_hasSpecGlossMap)
				{
					pixelColor = new UnityEngine.Color(pixelColor.r, pixelColor.g, pixelColor.b, pixelColor.a * m_SpecGlossMapScale);
					return pixelColor;
				}
				UnityEngine.Color specColor = m_specColor;
				specColor.a = m_glossiness;
				return specColor;
			}
			if (propertyToDo == Prop.doBump)
			{
				return UnityEngine.Color.Lerp(NeutralNormalMap, pixelColor, m_bumpScale);
			}
			if (propertyToDo == Prop.doEmission)
			{
				if (m_shaderDoesEmission)
				{
					return new UnityEngine.Color(pixelColor.r * m_emissionColor.r, pixelColor.g * m_emissionColor.g, pixelColor.b * m_emissionColor.b, pixelColor.a * m_emissionColor.a);
				}
				return UnityEngine.Color.black;
			}
			return pixelColor;
		}

		public bool NonTexturePropertiesAreEqual(Material a, Material b)
		{
			if (!TextureBlenderFallback._compareColor(a, b, m_generatingTintedAtlaColor, "_Color"))
			{
				return false;
			}
			if (!TextureBlenderFallback._compareColor(a, b, m_generatingTintedAtlaSpecular, "_SpecColor"))
			{
				return false;
			}
			bool flag = a.HasProperty("_SpecGlossMap") && a.GetTexture("_SpecGlossMap") != null;
			bool flag2 = b.HasProperty("_SpecGlossMap") && b.GetTexture("_SpecGlossMap") != null;
			if (flag && flag2)
			{
				if (!TextureBlenderFallback._compareFloat(a, b, m_generatingTintedAtlaSpecGlossMapScale, "_GlossMapScale"))
				{
					return false;
				}
			}
			else
			{
				if (flag || flag2)
				{
					return false;
				}
				if (!TextureBlenderFallback._compareFloat(a, b, m_generatingTintedAtlaGlossiness, "_Glossiness"))
				{
					return false;
				}
			}
			if (!TextureBlenderFallback._compareFloat(a, b, m_generatingTintedAtlaBumpScale, "_BumpScale"))
			{
				return false;
			}
			if (a.IsKeywordEnabled("_EMISSION") != b.IsKeywordEnabled("_EMISSION"))
			{
				return false;
			}
			if (a.IsKeywordEnabled("_EMISSION") && !TextureBlenderFallback._compareColor(a, b, m_generatingTintedAtlaEmission, "_EmissionColor"))
			{
				return false;
			}
			return true;
		}

		public void SetNonTexturePropertyValuesOnResultMaterial(Material resultMaterial)
		{
			if (resultMaterial.GetTexture("_MainTex") != null)
			{
				resultMaterial.SetColor("_Color", m_generatingTintedAtlaColor);
			}
			else
			{
				resultMaterial.SetColor("_Color", (UnityEngine.Color)sourceMaterialPropertyCache.GetValueIfAllSourceAreTheSameOrDefault("_Color", m_notGeneratingAtlasDefaultColor));
			}
			if (resultMaterial.GetTexture("_SpecGlossMap") != null)
			{
				resultMaterial.SetColor("_SpecColor", m_generatingTintedAtlaSpecular);
				resultMaterial.SetFloat("_GlossMapScale", m_generatingTintedAtlaSpecGlossMapScale);
				resultMaterial.SetFloat("_Glossiness", m_generatingTintedAtlaGlossiness);
			}
			else
			{
				resultMaterial.SetColor("_SpecColor", (UnityEngine.Color)sourceMaterialPropertyCache.GetValueIfAllSourceAreTheSameOrDefault("_SpecColor", m_notGeneratingAtlasDefaultSpecularColor));
				resultMaterial.SetFloat("_Glossiness", (float)sourceMaterialPropertyCache.GetValueIfAllSourceAreTheSameOrDefault("_Glossiness", m_notGeneratingAtlasDefaultGlossiness));
			}
			if (resultMaterial.GetTexture("_BumpMap") != null)
			{
				resultMaterial.SetFloat("_BumpScale", m_generatingTintedAtlaBumpScale);
			}
			else
			{
				resultMaterial.SetFloat("_BumpScale", m_generatingTintedAtlaBumpScale);
			}
			if (resultMaterial.GetTexture("_EmissionMap") != null)
			{
				resultMaterial.EnableKeyword("_EMISSION");
				resultMaterial.SetColor("_EmissionColor", UnityEngine.Color.white);
			}
			else
			{
				resultMaterial.DisableKeyword("_EMISSION");
				resultMaterial.SetColor("_EmissionColor", (UnityEngine.Color)sourceMaterialPropertyCache.GetValueIfAllSourceAreTheSameOrDefault("_EmissionColor", m_notGeneratingAtlasDefaultEmisionColor));
			}
		}

		public UnityEngine.Color GetColorIfNoTexture(Material mat, ShaderTextureProperty texPropertyName)
		{
			if (texPropertyName.name.Equals("_BumpMap"))
			{
				return new UnityEngine.Color(0.5f, 0.5f, 1f);
			}
			if (texPropertyName.name.Equals("_MainTex"))
			{
				if (mat != null && mat.HasProperty("_Color"))
				{
					try
					{
						UnityEngine.Color color = mat.GetColor("_Color");
						sourceMaterialPropertyCache.CacheMaterialProperty(mat, "_Color", color);
					}
					catch (Exception)
					{
					}
					return UnityEngine.Color.white;
				}
			}
			else
			{
				if (texPropertyName.name.Equals("_SpecGlossMap"))
				{
					if (mat != null && mat.HasProperty("_SpecColor"))
					{
						try
						{
							UnityEngine.Color color2 = mat.GetColor("_SpecColor");
							if (mat.HasProperty("_Glossiness"))
							{
								try
								{
									color2.a = mat.GetFloat("_Glossiness");
								}
								catch (Exception)
								{
								}
							}
							sourceMaterialPropertyCache.CacheMaterialProperty(mat, "_SpecColor", color2);
							sourceMaterialPropertyCache.CacheMaterialProperty(mat, "_Glossiness", color2.a);
						}
						catch (Exception)
						{
						}
					}
					return new UnityEngine.Color(0f, 0f, 0f, 0.5f);
				}
				if (texPropertyName.name.Equals("_ParallaxMap"))
				{
					return new UnityEngine.Color(0f, 0f, 0f, 0f);
				}
				if (texPropertyName.name.Equals("_OcclusionMap"))
				{
					return new UnityEngine.Color(1f, 1f, 1f, 1f);
				}
				if (texPropertyName.name.Equals("_EmissionMap"))
				{
					if (mat != null)
					{
						if (!mat.IsKeywordEnabled("_EMISSION"))
						{
							return UnityEngine.Color.black;
						}
						if (!mat.HasProperty("_EmissionColor"))
						{
							return UnityEngine.Color.black;
						}
						try
						{
							UnityEngine.Color color3 = mat.GetColor("_EmissionColor");
							sourceMaterialPropertyCache.CacheMaterialProperty(mat, "_EmissionColor", color3);
						}
						catch (Exception)
						{
						}
					}
				}
				else if (texPropertyName.name.Equals("_DetailMask"))
				{
					return new UnityEngine.Color(0f, 0f, 0f, 0f);
				}
			}
			return new UnityEngine.Color(1f, 1f, 1f, 0f);
		}
	}
}
namespace LiquidVolumeFX
{
	public class SpillController : MonoBehaviour
	{
		private float coffeeLeft = 100f;

		public ParticleSystem particles;

		[SerializeField]
		private ParticleSystem pourParticles;

		public bool canSpill = true;

		private void Start()
		{
			if (particles.gameObject.activeInHierarchy)
			{
				particles.gameObject.SetActive(value: false);
			}
			pourParticles.Stop();
		}

		public void EmitSteam()
		{
			StartCoroutine(SteamWait());
		}

		private IEnumerator SteamWait()
		{
			yield return Yield.WaitSeconds(0.2f);
			particles.gameObject.SetActive(value: true);
		}

		public void StopSteam()
		{
			particles.Stop();
		}

		private void FixedUpdate()
		{
			if (canSpill && AtSpillAngle() && coffeeLeft > 0f)
			{
				if (!pourParticles.isPlaying)
				{
					pourParticles.Play();
				}
				coffeeLeft -= 0.201f;
			}
			else if (pourParticles.isPlaying)
			{
				pourParticles.Stop(withChildren: true, ParticleSystemStopBehavior.StopEmitting);
			}
		}

		private bool AtSpillAngle()
		{
			float num = Vector3.SignedAngle(base.gameObject.transform.position, base.gameObject.transform.up, Vector3.up);
			if (num > 105f || num < -105f)
			{
				return true;
			}
			return false;
		}

		private IEnumerator DestroySpill(GameObject spill)
		{
			yield return Yield.WaitSeconds(1f);
			UnityEngine.Object.Destroy(spill);
		}
	}
	public class CubeSpawn : MonoBehaviour
	{
		public int instances = 150;

		public float radius = 2f;

		public float jitter = 0.5f;

		public float expansion = 0.04f;

		public float laps = 2f;

		private void Start()
		{
			for (int i = 1; i <= instances; i++)
			{
				GameObject obj = UnityEngine.Object.Instantiate(base.gameObject);
				obj.GetComponent<CubeSpawn>().enabled = false;
				obj.name = "Cube" + i;
				float f = (float)i / (float)instances * (float)Math.PI * 2f * laps;
				float num = (float)i * expansion;
				float x = Mathf.Cos(f) * (radius + num);
				float z = Mathf.Sin(f) * (radius + num);
				Vector3 vector = UnityEngine.Random.insideUnitSphere * jitter;
				obj.transform.position = base.transform.position + new Vector3(x, 0f, z) + vector;
				obj.transform.localScale *= 1f - UnityEngine.Random.value * jitter;
			}
		}
	}
	public class RandomRotation : MonoBehaviour
	{
		[Range(1f, 50f)]
		public float speed = 10f;

		[Range(1f, 30f)]
		public float randomChangeInterval = 10f;

		private float lastTime;

		private Vector3 v;

		private float randomization;

		private void Start()
		{
			randomization = UnityEngine.Random.value;
		}

		private void Update()
		{
			if (Time.time > lastTime)
			{
				lastTime = Time.time + randomChangeInterval + randomization;
				v = new Vector3(UnityEngine.Random.value, UnityEngine.Random.value, UnityEngine.Random.value);
			}
			base.transform.Rotate(v * Time.deltaTime * speed);
		}
	}
	public class CameraAnimator : MonoBehaviour
	{
		public float baseHeight = 0.6f;

		public float speedY = 0.005f;

		public float speedX = 5f;

		public float distAcceleration = 0.0002f;

		public float distSpeed = 0.0001f;

		public Vector3 lookAt;

		private float y;

		private float dy;

		private float distDirection = 1f;

		private float distSum;

		private void Start()
		{
			y = base.transform.position.y;
		}

		private void Update()
		{
			base.transform.RotateAround(lookAt, Vector3.up, Time.deltaTime * speedX);
			y += dy;
			dy -= (base.transform.position.y - baseHeight) * Time.deltaTime * speedY;
			base.transform.position = new Vector3(base.transform.position.x, y, base.transform.position.z);
			Quaternion rotation = base.transform.rotation;
			base.transform.LookAt(lookAt);
			base.transform.rotation = Quaternion.Lerp(rotation, base.transform.rotation, 0.2f);
			base.transform.position += base.transform.forward * distSum;
			distSum += distSpeed;
			distDirection = ((distSum < 0f) ? 1f : (-1f));
			distSpeed += Time.deltaTime * distDirection * distAcceleration;
		}
	}
	public class CylinderManager : MonoBehaviour
	{
		public float startingDelay = 1f;

		public int numCylinders = 16;

		public float scale = 0.2f;

		public float heightMultiplier = 2f;

		public float circleRadius = 1.75f;

		private void Update()
		{
			if (!(Time.time < startingDelay))
			{
				for (int i = 0; i < numCylinders; i++)
				{
					GameObject gameObject = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("Prefabs/CylinderFlask"));
					gameObject.hideFlags = HideFlags.DontSave;
					gameObject.transform.SetParent(base.transform, worldPositionStays: false);
					gameObject.transform.localScale = new Vector3(scale, scale * heightMultiplier, scale);
					float x = Mathf.Cos((float)i / (float)numCylinders * (float)Math.PI * 2f) * circleRadius;
					float z = Mathf.Sin((float)i / (float)numCylinders * (float)Math.PI * 2f) * circleRadius;
					gameObject.transform.position = new Vector3(x, -2f, z);
					FlaskAnimator flaskAnimator = gameObject.AddComponent<FlaskAnimator>();
					flaskAnimator.initialPosition = gameObject.transform.position;
					flaskAnimator.finalPosition = gameObject.transform.position + Vector3.up;
					flaskAnimator.duration = 5f + (float)i * 0.5f;
					flaskAnimator.acceleration = 0.001f;
					flaskAnimator.delay = 4f;
					LiquidVolume component = gameObject.GetComponent<LiquidVolume>();
					component.liquidColor1 = new UnityEngine.Color(UnityEngine.Random.value, UnityEngine.Random.value, UnityEngine.Random.value, UnityEngine.Random.value);
					component.liquidColor2 = new UnityEngine.Color(UnityEngine.Random.value, UnityEngine.Random.value, UnityEngine.Random.value, UnityEngine.Random.value);
					component.turbulence2 = 0f;
					component.refractionBlur = false;
				}
				UnityEngine.Object.Destroy(this);
			}
		}
	}
	public class FishAnimator : MonoBehaviour
	{
		private void Update()
		{
			Vector3 position = Camera.main.transform.position;
			base.transform.LookAt(new Vector3(0f - position.x, base.transform.position.y, 0f - position.z));
		}
	}
	public class FlaskAnimator : MonoBehaviour
	{
		public float speed = 0.01f;

		public Vector3 initialPosition = Vector3.down * 4f;

		public Vector3 finalPosition = Vector3.zero;

		public float duration = 5f;

		public float delay = 6f;

		[Range(0f, 1f)]
		public float level;

		[Range(0f, 1f)]
		public float minRange = 0.05f;

		[Range(0f, 1f)]
		public float maxRange = 0.95f;

		[Range(0f, 1f)]
		public float acceleration = 0.04f;

		[Range(0f, 1f)]
		public float rotationSpeed = 0.25f;

		[Range(0f, 2f)]
		public float alphaDuration = 2f;

		[Range(0f, 1f)]
		public float finalRefractionBlur = 0.75f;

		private LiquidVolume liquid;

		private float direction = 1f;

		private void Awake()
		{
			liquid = GetComponent<LiquidVolume>();
			level = liquid.level;
			liquid.alpha = 0f;
		}

		private void Update()
		{
			float num = ((duration > 0f) ? ((Time.time - delay) / duration) : 1f);
			if (num >= 1f)
			{
				level += direction * speed;
				if (level < minRange || level > maxRange)
				{
					direction *= -1f;
				}
				direction += Mathf.Sign(0.5f - level) * acceleration;
				level = Mathf.Clamp(level, minRange, maxRange);
				liquid.level = level;
				num = ((alphaDuration > 0f) ? Mathf.Clamp01((Time.time - duration - delay) / alphaDuration) : 1f);
				liquid.alpha = num;
				liquid.blurIntensity = num * finalRefractionBlur;
			}
			else if (initialPosition != finalPosition)
			{
				base.transform.position = Vector3.Lerp(initialPosition, finalPosition, num);
			}
			base.transform.Rotate(Vector3.up * Time.deltaTime * rotationSpeed * 57.29578f, Space.Self);
		}
	}
	public class PortalAnimator : MonoBehaviour
	{
		public float delay = 2f;

		public float duration = 1f;

		public float delayFadeOut = 4f;

		private Vector3 scale;

		private void Start()
		{
			scale = base.transform.localScale;
			base.transform.localScale = Vector3.zero;
		}

		private void Update()
		{
			if (!(Time.time < delay))
			{
				float value = ((!(Time.time > delayFadeOut)) ? ((Time.time - delay) / duration) : (1f - (Time.time - delayFadeOut) / duration));
				base.transform.localScale = Mathf.Clamp01(value) * scale;
			}
		}
	}
	public class SpotlightAnimator : MonoBehaviour
	{
		public float lightOnDelay = 2f;

		public float targetIntensity = 3.5f;

		public float initialIntensity;

		public float duration = 3f;

		public float nextColorInterval = 2f;

		public float colorChangeDuration = 2f;

		private Light spotLight;

		private float elapsedNextColor;

		private float lastColorChange;

		private float colorChangeStarted;

		private UnityEngine.Color currentColor;

		private UnityEngine.Color nextColor;

		private bool changingColor;

		private void Awake()
		{
			spotLight = GetComponent<Light>();
			spotLight.intensity = 0f;
		}

		private void Update()
		{
			if (Time.time < lightOnDelay)
			{
				return;
			}
			float t = (Time.time - lightOnDelay) / duration;
			spotLight.intensity = Mathf.Lerp(initialIntensity, targetIntensity, t);
			if (!(Time.time - lastColorChange > nextColorInterval))
			{
				return;
			}
			if (changingColor)
			{
				t = (Time.time - colorChangeStarted) / colorChangeDuration;
				if (t >= 1f)
				{
					changingColor = false;
					lastColorChange = Time.time;
				}
				spotLight.color = UnityEngine.Color.Lerp(currentColor, nextColor, t);
			}
			else
			{
				currentColor = spotLight.color;
				nextColor = new UnityEngine.Color(Mathf.Clamp01(UnityEngine.Random.value + 0.25f), Mathf.Clamp01(UnityEngine.Random.value + 0.25f), Mathf.Clamp01(UnityEngine.Random.value + 0.25f), 1f);
				changingColor = true;
				colorChangeStarted = Time.time;
			}
		}
	}
	public class VerticalBounce : MonoBehaviour
	{
		[Range(0f, 0.1f)]
		public float acceleration = 0.1f;

		private float direction = 1f;

		private float y;

		private float speed = 0.01f;

		private void Update()
		{
			base.transform.localPosition = new Vector3(base.transform.localPosition.x, y, base.transform.localPosition.z);
			y += speed;
			direction = ((y < 0f) ? 1f : (-1f));
			speed += Time.deltaTime * direction * acceleration;
		}
	}
	public class RandomMove : MonoBehaviour
	{
		[Range(0f, 10f)]
		public float right = 2f;

		[Range(0f, 10f)]
		public float left = -2f;

		[Range(0f, 10f)]
		public float back = 2f;

		[Range(0f, 10f)]
		public float front = -1f;

		[Range(0f, 0.2f)]
		public float speed = 0.5f;

		[Range(0.1f, 2f)]
		public float randomSpeed;

		public bool automatic;

		private Vector3 velocity = Vector3.zero;

		private Vector3 accel = Vector3.zero;

		private int flaskType;

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.F))
			{
				flaskType++;
				if (flaskType >= 3)
				{
					flaskType = 0;
				}
				base.transform.Find("SphereFlask").gameObject.SetActive(flaskType == 0);
				base.transform.Find("CylinderFlask").gameObject.SetActive(flaskType == 1);
				base.transform.Find("CubeFlask").gameObject.SetActive(flaskType == 2);
			}
			if (automatic)
			{
				if (UnityEngine.Random.value > 0.99f)
				{
					accel = Vector3.right * (speed + (UnityEngine.Random.value - 0.5f) * randomSpeed);
				}
			}
			else if (Input.GetKey(KeyCode.RightArrow))
			{
				accel = Vector3.right * speed;
			}
			else if (Input.GetKey(KeyCode.LeftArrow))
			{
				accel = Vector3.left * speed;
			}
			else if (Input.GetKey(KeyCode.UpArrow))
			{
				accel = Vector3.forward * speed;
			}
			else if (Input.GetKey(KeyCode.DownArrow))
			{
				accel = Vector3.back * speed;
			}
			else
			{
				accel = Vector3.zero;
			}
			velocity += accel;
			velocity *= 0.95f;
			base.transform.localPosition += velocity;
			if (base.transform.localPosition.x > right)
			{
				base.transform.localPosition = new Vector3(right, base.transform.localPosition.y, base.transform.localPosition.z);
				accel *= -1f;
			}
			if (base.transform.localPosition.x < left)
			{
				base.transform.localPosition = new Vector3(left, base.transform.localPosition.y, base.transform.localPosition.z);
				accel *= -1f;
			}
			if (base.transform.localPosition.z > back)
			{
				base.transform.localPosition = new Vector3(base.transform.localPosition.x, base.transform.localPosition.y, back);
				accel *= -1f;
			}
			if (base.transform.localPosition.z < front)
			{
				base.transform.localPosition = new Vector3(base.transform.localPosition.x, base.transform.localPosition.y, front);
				accel *= -1f;
			}
		}
	}
	public enum TOPOLOGY
	{
		Sphere = 0,
		Cylinder = 1,
		Cube = 2,
		Irregular = 10
	}
	public enum DETAIL
	{
		Simple = 0,
		Default = 10,
		DefaultNoFlask = 11,
		BumpTexture = 20,
		Reflections = 30
	}
	[ExecuteInEditMode]
	[HelpURL("http://kronnect.com/taptapgo")]
	[AddComponentMenu("Effects/Liquid Volume")]
	[DisallowMultipleComponent]
	public class LiquidVolume : MonoBehaviour
	{
		[SerializeField]
		private TOPOLOGY _topology;

		[SerializeField]
		private DETAIL _detail = DETAIL.Default;

		[SerializeField]
		[Range(0f, 1f)]
		private float _level = 0.5f;

		[SerializeField]
		[ColorUsage(true, true, 0f, 8f, 0.125f, 3f)]
		private UnityEngine.Color _liquidColor1 = new UnityEngine.Color(0f, 1f, 0f, 0.1f);

		[SerializeField]
		[Range(0.1f, 4.85f)]
		private float _liquidScale1 = 1f;

		[SerializeField]
		[ColorUsage(true, true, 0f, 8f, 0.125f, 3f)]
		private UnityEngine.Color _liquidColor2 = new UnityEngine.Color(1f, 0f, 0f, 0.3f);

		[SerializeField]
		[Range(2f, 4.85f)]
		private float _liquidScale2 = 5f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _alpha = 1f;

		[SerializeField]
		[ColorUsage(false, true, 0f, 8f, 0.125f, 3f)]
		private UnityEngine.Color _emissionColor = new UnityEngine.Color(0f, 0f, 0f);

		[SerializeField]
		[Range(0f, 8f)]
		private float _emissionBrightness;

		[SerializeField]
		private bool _ditherShadows = true;

		[SerializeField]
		[Range(0f, 1f)]
		private float _murkiness = 1f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _turbulence1 = 0.5f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _turbulence2 = 0.2f;

		[SerializeField]
		private float _frecuency = 1f;

		[SerializeField]
		[Range(0f, 2f)]
		private float _speed = 1f;

		[SerializeField]
		[Range(0f, 5f)]
		private float _sparklingIntensity = 0.1f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _sparklingAmount = 0.2f;

		[SerializeField]
		[Range(0f, 10f)]
		private float _deepObscurance = 2f;

		[SerializeField]
		[ColorUsage(true, true, 0f, 8f, 0.125f, 3f)]
		private UnityEngine.Color _foamColor = new UnityEngine.Color(1f, 1f, 1f, 0.65f);

		[SerializeField]
		[Range(0.01f, 1f)]
		private float _foamScale = 0.2f;

		[SerializeField]
		[Range(0f, 0.1f)]
		private float _foamThickness = 0.04f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _foamDensity = 0.5f;

		[SerializeField]
		[Range(8f, 100f)]
		private float _foamWeight = 10f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _foamTurbulence = 1f;

		[SerializeField]
		private bool _foamVisibleFromBottom = true;

		[ColorUsage(true, true, 0f, 8f, 0.125f, 3f)]
		[SerializeField]
		private UnityEngine.Color _smokeColor = new UnityEngine.Color(0.7f, 0.7f, 0.7f, 0.25f);

		[SerializeField]
		[Range(0.01f, 1f)]
		private float _smokeScale = 0.25f;

		[SerializeField]
		[Range(0f, 10f)]
		private float _smokeBaseObscurance = 2f;

		[SerializeField]
		[Range(0f, 20f)]
		private float _smokeSpeed = 5f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _upperLimit = 1f;

		[SerializeField]
		[ColorUsage(true, true, 0f, 8f, 0.125f, 3f)]
		private UnityEngine.Color _flaskTint = new UnityEngine.Color(0f, 0f, 0f, 1f);

		[SerializeField]
		[Range(0f, 1f)]
		private float _flaskThickness = 0.03f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _flaskGlossinessExternal = 0.767f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _flaskGlossinessInternal = 0.5f;

		[SerializeField]
		private bool _refractionBlur = true;

		[SerializeField]
		[Range(0f, 1f)]
		private float _blurIntensity = 0.75f;

		[SerializeField]
		private int _liquidRaySteps = 10;

		[SerializeField]
		private int _foamRaySteps = 7;

		[SerializeField]
		private int _smokeRaySteps = 5;

		[SerializeField]
		private Texture2D _bumpMap;

		[SerializeField]
		[Range(0f, 10f)]
		private float _bumpDistortionScale = 1f;

		[SerializeField]
		private Vector2 _bumpDistortionOffset;

		[SerializeField]
		private Texture2D _distortionMap;

		[SerializeField]
		private Texture2D _texture;

		[SerializeField]
		private Vector2 _textureScale = Vector2.one;

		[SerializeField]
		private Vector2 _textureOffset;

		[SerializeField]
		[Range(0f, 10f)]
		private float _distortionAmount = 1f;

		[SerializeField]
		private bool _depthAware;

		[SerializeField]
		private bool _depthAwareCustomPass;

		[SerializeField]
		private bool _ignoreGravity;

		[SerializeField]
		private bool _reactToForces;

		[SerializeField]
		[Range(0f, 1f)]
		private float _textureAlpha = 1f;

		[SerializeField]
		private Vector3 _extentsScale = Vector3.one;

		[SerializeField]
		[Range(1f, 3f)]
		private int _noiseVariation = 1;

		[SerializeField]
		private bool _allowViewFromInside;

		[SerializeField]
		private bool _debugSpillPoint;

		[SerializeField]
		private int _renderQueue = 3001;

		[SerializeField]
		private Cubemap _reflectionTexture;

		[SerializeField]
		[Range(1f, 5f)]
		private float _physicsMass = 1f;

		[SerializeField]
		[Range(0f, 0.2f)]
		private float _physicsAngularDamp = 0.02f;

		private const string SHADER_KEYWORD_DEPTH_AWARE = "LIQUID_VOLUME_DEPTH_AWARE";

		private const string SHADER_KEYWORD_DEPTH_AWARE_CUSTOM_PASS = "LIQUID_VOLUME_DEPTH_AWARE_PASS";

		private const string SHADER_KEYWORD_NON_AABB = "LIQUID_VOLUME_NON_AABB";

		private const string SHADER_KEYWORD_IGNORE_GRAVITY = "LIQUID_VOLUME_IGNORE_GRAVITY";

		private const string SHADER_KEYWORD_SPHERE = "LIQUID_VOLUME_SPHERE";

		private const string SHADER_KEYWORD_CUBE = "LIQUID_VOLUME_CUBE";

		private const string SHADER_KEYWORD_CYLINDER = "LIQUID_VOLUME_CYLINDER";

		private const string SHADER_KEYWORD_IRREGULAR = "LIQUID_VOLUME_IRREGULAR";

		private const string SPILL_POINT_GIZMO = "SpillPointGizmo";

		private Material liqMatSimple;

		private Material liqMatDefault;

		private Material liqMatDefaultNoFlask;

		private Material liqMatBump;

		private Material liqMatReflections;

		private Material liqMat;

		private Mesh mesh;

		private Renderer mr;

		private bool wasRefractionBlur;

		private bool wasBackBuffer;

		private bool wasFrontBuffer;

		private Vector3 lastPosition;

		private Vector3 lastScale;

		private Quaternion lastRotation;

		private List<string> shaderKeywords;

		private bool camInside;

		private float lastDistanceToCam;

		private DETAIL currentDetail;

		private Vector4 turb;

		private float turbulenceSpeed;

		private float liquidLevelPos;

		private List<Vector3> vertices;

		private bool shouldUpdateMaterialProperties;

		private Vector3 prevVelocity;

		private Vector3 prev2Velocity;

		private Vector3 inertia;

		private Vector3 lastAvgVelocity;

		private float angularVelocity;

		private float angularInertia;

		private float turbulenceDueForces;

		private Quaternion liquidRot;

		private float prevThickness;

		private GameObject spillPointGizmo;

		private static Dictionary<Camera, CommandBuffer> m_CamerasBlur = new Dictionary<Camera, CommandBuffer>();

		private static Material blurMat;

		private static Dictionary<Camera, CommandBuffer> m_CamerasBackBuffer = new Dictionary<Camera, CommandBuffer>();

		private static Material backBufferMat;

		private static List<Renderer> bbRenderers = new List<Renderer>();

		private static Dictionary<Camera, CommandBuffer> m_CamerasFrontBuffer = new Dictionary<Camera, CommandBuffer>();

		private static Material frontBufferMat;

		private static List<Renderer> fbRenderers = new List<Renderer>();

		public TOPOLOGY topology
		{
			get
			{
				return _topology;
			}
			set
			{
				if (_topology != value)
				{
					if (_topology == TOPOLOGY.Irregular)
					{
						CleanupCommandBuffer();
					}
					_topology = value;
					UpdateMaterialProperties();
				}
			}
		}

		public DETAIL detail
		{
			get
			{
				return _detail;
			}
			set
			{
				if (_detail != value)
				{
					_detail = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float level
		{
			get
			{
				return _level;
			}
			set
			{
				if (_level != Mathf.Clamp01(value))
				{
					_level = Mathf.Clamp01(value);
					UpdateMaterialProperties();
				}
			}
		}

		public UnityEngine.Color liquidColor1
		{
			get
			{
				return _liquidColor1;
			}
			set
			{
				if (_liquidColor1 != value)
				{
					_liquidColor1 = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float liquidScale1
		{
			get
			{
				return _liquidScale1;
			}
			set
			{
				if (_liquidScale1 != value)
				{
					_liquidScale1 = value;
					UpdateMaterialProperties();
				}
			}
		}

		public UnityEngine.Color liquidColor2
		{
			get
			{
				return _liquidColor2;
			}
			set
			{
				if (_liquidColor2 != value)
				{
					_liquidColor2 = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float liquidScale2
		{
			get
			{
				return _liquidScale2;
			}
			set
			{
				if (_liquidScale2 != value)
				{
					_liquidScale2 = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float alpha
		{
			get
			{
				return _alpha;
			}
			set
			{
				if (_alpha != Mathf.Clamp01(value))
				{
					_alpha = Mathf.Clamp01(value);
					UpdateMaterialProperties();
				}
			}
		}

		public UnityEngine.Color emissionColor
		{
			get
			{
				return _emissionColor;
			}
			set
			{
				if (_emissionColor != value)
				{
					_emissionColor = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float emissionBrightness
		{
			get
			{
				return _emissionBrightness;
			}
			set
			{
				if (_emissionBrightness != value)
				{
					_emissionBrightness = value;
					UpdateMaterialProperties();
				}
			}
		}

		public bool ditherShadows
		{
			get
			{
				return _ditherShadows;
			}
			set
			{
				if (_ditherShadows != value)
				{
					_ditherShadows = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float murkiness
		{
			get
			{
				return _murkiness;
			}
			set
			{
				if (_murkiness != value)
				{
					_murkiness = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float turbulence1
		{
			get
			{
				return _turbulence1;
			}
			set
			{
				if (_turbulence1 != value)
				{
					_turbulence1 = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float turbulence2
		{
			get
			{
				return _turbulence2;
			}
			set
			{
				if (_turbulence2 != value)
				{
					_turbulence2 = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float frecuency
		{
			get
			{
				return _frecuency;
			}
			set
			{
				if (_frecuency != value)
				{
					_frecuency = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float speed
		{
			get
			{
				return _speed;
			}
			set
			{
				if (_speed != value)
				{
					_speed = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float sparklingIntensity
		{
			get
			{
				return _sparklingIntensity;
			}
			set
			{
				if (_sparklingIntensity != value)
				{
					_sparklingIntensity = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float sparklingAmount
		{
			get
			{
				return _sparklingAmount;
			}
			set
			{
				if (_sparklingAmount != value)
				{
					_sparklingAmount = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float deepObscurance
		{
			get
			{
				return _deepObscurance;
			}
			set
			{
				if (_deepObscurance != value)
				{
					_deepObscurance = value;
					UpdateMaterialProperties();
				}
			}
		}

		public UnityEngine.Color foamColor
		{
			get
			{
				return _foamColor;
			}
			set
			{
				if (_foamColor != value)
				{
					_foamColor = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float foamScale
		{
			get
			{
				return _foamScale;
			}
			set
			{
				if (_foamScale != value)
				{
					_foamScale = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float foamThickness
		{
			get
			{
				return _foamThickness;
			}
			set
			{
				if (_foamThickness != value)
				{
					_foamThickness = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float foamDensity
		{
			get
			{
				return _foamDensity;
			}
			set
			{
				if (_foamDensity != value)
				{
					_foamDensity = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float foamWeight
		{
			get
			{
				return _foamWeight;
			}
			set
			{
				if (_foamWeight != value)
				{
					_foamWeight = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float foamTurbulence
		{
			get
			{
				return _foamTurbulence;
			}
			set
			{
				if (_foamTurbulence != value)
				{
					_foamTurbulence = value;
					UpdateMaterialProperties();
				}
			}
		}

		public bool foamVisibleFromBottom
		{
			get
			{
				return _foamVisibleFromBottom;
			}
			set
			{
				if (_foamVisibleFromBottom != value)
				{
					_foamVisibleFromBottom = value;
					UpdateMaterialProperties();
				}
			}
		}

		public UnityEngine.Color smokeColor
		{
			get
			{
				return _smokeColor;
			}
			set
			{
				if (_smokeColor != value)
				{
					_smokeColor = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float smokeScale
		{
			get
			{
				return _smokeScale;
			}
			set
			{
				if (_smokeScale != value)
				{
					_smokeScale = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float smokeBaseObscurance
		{
			get
			{
				return _smokeBaseObscurance;
			}
			set
			{
				if (_smokeBaseObscurance != value)
				{
					_smokeBaseObscurance = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float smokeSpeed
		{
			get
			{
				return _smokeSpeed;
			}
			set
			{
				if (_smokeSpeed != value)
				{
					_smokeSpeed = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float upperLimit
		{
			get
			{
				return _upperLimit;
			}
			set
			{
				if (_upperLimit != value)
				{
					_upperLimit = value;
					UpdateMaterialProperties();
				}
			}
		}

		public UnityEngine.Color flaskTint
		{
			get
			{
				return _flaskTint;
			}
			set
			{
				if (_flaskTint != value)
				{
					_flaskTint = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float flaskThickness
		{
			get
			{
				return _flaskThickness;
			}
			set
			{
				if (_flaskThickness != value)
				{
					_flaskThickness = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float flaskGlossinessExternal
		{
			get
			{
				return _flaskGlossinessExternal;
			}
			set
			{
				if (_flaskGlossinessExternal != value)
				{
					_flaskGlossinessExternal = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float flaskGlossinessInternal
		{
			get
			{
				return _flaskGlossinessInternal;
			}
			set
			{
				if (_flaskGlossinessInternal != value)
				{
					_flaskGlossinessInternal = value;
					UpdateMaterialProperties();
				}
			}
		}

		public bool refractionBlur
		{
			get
			{
				return _refractionBlur;
			}
			set
			{
				if (_refractionBlur != value)
				{
					_refractionBlur = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float blurIntensity
		{
			get
			{
				return _blurIntensity;
			}
			set
			{
				if (_blurIntensity != Mathf.Clamp01(value))
				{
					_blurIntensity = Mathf.Clamp01(value);
					UpdateMaterialProperties();
				}
			}
		}

		public int liquidRaySteps
		{
			get
			{
				return _liquidRaySteps;
			}
			set
			{
				if (_liquidRaySteps != value)
				{
					_liquidRaySteps = value;
					UpdateMaterialProperties();
				}
			}
		}

		public int foamRaySteps
		{
			get
			{
				return _foamRaySteps;
			}
			set
			{
				if (_foamRaySteps != value)
				{
					_foamRaySteps = value;
					UpdateMaterialProperties();
				}
			}
		}

		public int smokeRaySteps
		{
			get
			{
				return _smokeRaySteps;
			}
			set
			{
				if (_smokeRaySteps != value)
				{
					_smokeRaySteps = value;
					UpdateMaterialProperties();
				}
			}
		}

		public Texture2D bumpMap
		{
			get
			{
				return _bumpMap;
			}
			set
			{
				if (_bumpMap != value)
				{
					_bumpMap = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float bumpDistortionScale
		{
			get
			{
				return _bumpDistortionScale;
			}
			set
			{
				if (_bumpDistortionScale != value)
				{
					_bumpDistortionScale = value;
					UpdateMaterialProperties();
				}
			}
		}

		public Vector2 bumpDistortionOffset
		{
			get
			{
				return _bumpDistortionOffset;
			}
			set
			{
				if (_bumpDistortionOffset != value)
				{
					_bumpDistortionOffset = value;
					UpdateMaterialProperties();
				}
			}
		}

		public Texture2D distortionMap
		{
			get
			{
				return _distortionMap;
			}
			set
			{
				if (_distortionMap != value)
				{
					_distortionMap = value;
					UpdateMaterialProperties();
				}
			}
		}

		public Texture2D texture
		{
			get
			{
				return _texture;
			}
			set
			{
				if (_texture != value)
				{
					_texture = value;
					UpdateMaterialProperties();
				}
			}
		}

		public Vector2 textureScale
		{
			get
			{
				return _textureScale;
			}
			set
			{
				if (_textureScale != value)
				{
					_textureScale = value;
					UpdateMaterialProperties();
				}
			}
		}

		public Vector2 textureOffset
		{
			get
			{
				return _textureOffset;
			}
			set
			{
				if (_textureOffset != value)
				{
					_textureOffset = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float distortionAmount
		{
			get
			{
				return _distortionAmount;
			}
			set
			{
				if (_distortionAmount != value)
				{
					_distortionAmount = value;
					UpdateMaterialProperties();
				}
			}
		}

		public bool depthAware
		{
			get
			{
				return _depthAware;
			}
			set
			{
				if (_depthAware != value)
				{
					_depthAware = value;
					UpdateMaterialProperties();
				}
			}
		}

		public bool depthAwareCustomPass
		{
			get
			{
				return _depthAwareCustomPass;
			}
			set
			{
				if (_depthAwareCustomPass != value)
				{
					_depthAwareCustomPass = value;
					UpdateMaterialProperties();
				}
			}
		}

		public bool ignoreGravity
		{
			get
			{
				return _ignoreGravity;
			}
			set
			{
				if (_ignoreGravity != value)
				{
					_ignoreGravity = value;
					UpdateMaterialProperties();
				}
			}
		}

		public bool reactToForces
		{
			get
			{
				return _reactToForces;
			}
			set
			{
				if (_reactToForces != value)
				{
					_reactToForces = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float textureAlpha
		{
			get
			{
				return _textureAlpha;
			}
			set
			{
				if (_textureAlpha != value)
				{
					_textureAlpha = value;
					UpdateMaterialProperties();
				}
			}
		}

		public Vector3 extentsScale
		{
			get
			{
				return _extentsScale;
			}
			set
			{
				if (_extentsScale != value)
				{
					_extentsScale = value;
					UpdateMaterialProperties();
				}
			}
		}

		public int noiseVariation
		{
			get
			{
				return _noiseVariation;
			}
			set
			{
				if (_noiseVariation != value)
				{
					_noiseVariation = value;
					UpdateMaterialProperties();
				}
			}
		}

		public bool allowViewFromInside
		{
			get
			{
				return _allowViewFromInside;
			}
			set
			{
				if (_allowViewFromInside != value)
				{
					_allowViewFromInside = value;
					lastDistanceToCam = -1f;
					CheckInsideOut();
				}
			}
		}

		public bool debugSpillPoint
		{
			get
			{
				return _debugSpillPoint;
			}
			set
			{
				if (_debugSpillPoint != value)
				{
					_debugSpillPoint = value;
				}
			}
		}

		public int renderQueue
		{
			get
			{
				return _renderQueue;
			}
			set
			{
				if (_renderQueue != value)
				{
					_renderQueue = value;
					UpdateMaterialProperties();
				}
			}
		}

		public Cubemap reflectionTexture
		{
			get
			{
				return _reflectionTexture;
			}
			set
			{
				if (_reflectionTexture != value)
				{
					_reflectionTexture = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float physicsMass
		{
			get
			{
				return _physicsMass;
			}
			set
			{
				if (_physicsMass != value)
				{
					_physicsMass = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float physicsAngularDamp
		{
			get
			{
				return _physicsAngularDamp;
			}
			set
			{
				if (_physicsAngularDamp != value)
				{
					_physicsAngularDamp = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float liquidSurfaceYPosition => liquidLevelPos;

		private void OnEnable()
		{
			if (base.gameObject.activeInHierarchy)
			{
				turb.z = 1f;
				turbulenceDueForces = 0f;
				turbulenceSpeed = 1f;
				liquidRot = base.transform.rotation;
				currentDetail = _detail;
				lastPosition = base.transform.position;
				lastRotation = base.transform.rotation;
				lastScale = base.transform.localScale;
				prevThickness = _flaskThickness;
				if (_depthAwareCustomPass && base.transform.parent == null)
				{
					_depthAwareCustomPass = false;
				}
				CleanupCommandBuffer();
				RefreshMaterialProperties();
				ReadVertices();
			}
		}

		private void Reset()
		{
			if (!(mesh == null))
			{
				if (mesh.vertexCount == 24)
				{
					topology = TOPOLOGY.Cube;
				}
				else if (mesh.bounds.extents.y > mesh.bounds.extents.x)
				{
					topology = TOPOLOGY.Cylinder;
				}
			}
		}

		private void OnDestroy()
		{
			CleanupCommandBuffer();
			liqMat = null;
			if (liqMatDefault != null)
			{
				UnityEngine.Object.DestroyImmediate(liqMatDefault);
				liqMatDefault = null;
			}
			if (liqMatDefaultNoFlask != null)
			{
				UnityEngine.Object.DestroyImmediate(liqMatDefaultNoFlask);
				liqMatDefaultNoFlask = null;
			}
			if (liqMatSimple != null)
			{
				UnityEngine.Object.DestroyImmediate(liqMatSimple);
				liqMatSimple = null;
			}
			if (liqMatBump != null)
			{
				UnityEngine.Object.DestroyImmediate(liqMatBump);
				liqMatBump = null;
			}
			if (liqMatReflections != null)
			{
				UnityEngine.Object.DestroyImmediate(liqMatReflections);
				liqMatReflections = null;
			}
		}

		public void OnWillRenderObject()
		{
			bool num = base.gameObject.activeInHierarchy && base.enabled;
			if (shouldUpdateMaterialProperties)
			{
				shouldUpdateMaterialProperties = false;
				RefreshMaterialProperties();
			}
			if (num && _depthAware)
			{
				Camera.current.depthTextureMode |= DepthTextureMode.Depth;
			}
			if (num && _allowViewFromInside)
			{
				CheckInsideOut();
			}
			if (!num || (!_refractionBlur && wasRefractionBlur))
			{
				CleanupRefractionBuffer();
				wasRefractionBlur = false;
			}
			else if (_refractionBlur)
			{
				SetupRefractionBuffer();
				wasRefractionBlur = true;
			}
			UpdateAnimations();
			if (!num || (_topology != TOPOLOGY.Irregular && wasBackBuffer))
			{
				CleanupBackFacesBuffer();
				wasBackBuffer = false;
			}
			else if (_topology == TOPOLOGY.Irregular)
			{
				SetupBackFacesBuffer(GetComponent<Renderer>());
				wasBackBuffer = true;
			}
			if (!num || (!_depthAwareCustomPass && wasFrontBuffer))
			{
				CleanupFrontFacesBuffer();
				wasFrontBuffer = false;
			}
			else if (_depthAwareCustomPass)
			{
				Transform parent = base.transform.parent;
				if (parent != null)
				{
					Renderer component = parent.GetComponent<Renderer>();
					if (component != null)
					{
						SetupFrontFacesBuffer(component);
						wasFrontBuffer = true;
					}
				}
			}
			if (_debugSpillPoint)
			{
				UpdateSpillPointGizmo();
			}
		}

		private void FixedUpdate()
		{
			turbulenceSpeed += Time.deltaTime * 3f * _speed;
			liqMat.SetFloat("_TurbulenceSpeed", turbulenceSpeed * 4f);
		}

		private void OnDidApplyAnimationProperties()
		{
			shouldUpdateMaterialProperties = true;
		}

		private void OnDisable()
		{
			CleanupCommandBuffer();
		}

		private void ReadVertices()
		{
			if (!(mesh == null))
			{
				if (vertices == null)
				{
					vertices = new List<Vector3>(mesh.vertices);
				}
				else
				{
					vertices.Clear();
					vertices.AddRange(mesh.vertices);
				}
				vertices.Sort((Vector3 v0, Vector3 v1) => v1.y.CompareTo(v0.y));
			}
		}

		private void UpdateAnimations()
		{
			switch (topology)
			{
			case TOPOLOGY.Sphere:
				if (base.transform.localScale.y != base.transform.localScale.x || base.transform.localScale.z != base.transform.localScale.x)
				{
					base.transform.localScale = new Vector3(base.transform.localScale.x, base.transform.localScale.x, base.transform.localScale.x);
				}
				break;
			case TOPOLOGY.Cylinder:
				if (base.transform.localScale.z != base.transform.localScale.x)
				{
					base.transform.localScale = new Vector3(base.transform.localScale.x, base.transform.localScale.y, base.transform.localScale.x);
				}
				break;
			}
			if (liqMat != null)
			{
				liqMat.SetMatrix("_Cam2World", Camera.current.cameraToWorldMatrix);
				Vector3 lhs = Vector3.right;
				Quaternion rotation = base.transform.rotation;
				if (_reactToForces)
				{
					Quaternion b = base.transform.rotation;
					float deltaTime = Time.deltaTime;
					if (Application.isPlaying && deltaTime > 0f)
					{
						Vector3 vector = (base.transform.position - lastPosition) / deltaTime;
						Vector3 vector2 = (prev2Velocity + prevVelocity + vector) / 3f;
						prev2Velocity = prevVelocity;
						prevVelocity = vector;
						Vector3 vector3 = vector2 - lastAvgVelocity;
						lastAvgVelocity = vector2;
						inertia += vector2;
						float num = Mathf.Max(vector3.magnitude / _physicsMass - _physicsAngularDamp, 0f);
						angularInertia += num;
						angularVelocity += angularInertia;
						if (angularVelocity > 0f)
						{
							angularInertia -= Mathf.Abs(angularVelocity) * _physicsMass / 100f;
						}
						else if (angularVelocity < 0f)
						{
							angularInertia += Mathf.Abs(angularVelocity) * _physicsMass / 100f;
						}
						float num2 = 1f - _physicsAngularDamp;
						angularInertia *= num2;
						inertia *= num2;
						float angle = Mathf.Clamp(angularVelocity, -90f, 90f);
						lhs = inertia.normalized;
						Vector3 axis = Vector3.Cross(lhs, Vector3.down);
						b = Quaternion.AngleAxis(angle, axis);
						float num3 = Mathf.Abs(angularInertia) + Mathf.Abs(angularVelocity);
						turbulenceDueForces = Mathf.Min(0.5f / _physicsMass, turbulenceDueForces + num3 / 1000f);
						turbulenceDueForces *= num2;
					}
					else
					{
						turbulenceDueForces = 0f;
					}
					if (_topology == TOPOLOGY.Sphere)
					{
						liquidRot = Quaternion.Lerp(liquidRot, b, 0.1f);
						rotation = liquidRot;
					}
				}
				Matrix4x4 matrix4x = Matrix4x4.TRS(Vector3.zero, rotation, Vector3.one);
				liqMat.SetMatrix("_Rot", matrix4x.inverse);
				if (_topology != 0)
				{
					float x = lhs.x;
					lhs.x += (lhs.z - lhs.x) * 0.25f;
					lhs.z += (x - lhs.z) * 0.25f;
				}
				turb.z = lhs.x;
				turb.w = lhs.z;
			}
			if (_reactToForces || base.transform.position != lastPosition || base.transform.localScale != lastScale || base.transform.rotation != lastRotation)
			{
				UpdateLevels();
			}
		}

		public void UpdateMaterialProperties()
		{
			if (Application.isPlaying)
			{
				shouldUpdateMaterialProperties = true;
			}
			else
			{
				RefreshMaterialProperties();
			}
		}

		private void RefreshMaterialProperties()
		{
			if (!base.gameObject.activeInHierarchy)
			{
				return;
			}
			switch (_detail)
			{
			case DETAIL.Simple:
				if (liqMatSimple == null)
				{
					liqMatSimple = UnityEngine.Object.Instantiate(Resources.Load<Material>("Materials/LiquidVolumeSimple"));
					liqMatSimple.hideFlags = HideFlags.DontSave;
				}
				liqMat = liqMatSimple;
				break;
			case DETAIL.DefaultNoFlask:
				if (liqMatDefaultNoFlask == null)
				{
					liqMatDefaultNoFlask = UnityEngine.Object.Instantiate(Resources.Load<Material>("Materials/LiquidVolumeDefaultNoFlask"));
					liqMatDefaultNoFlask.hideFlags = HideFlags.DontSave;
				}
				liqMat = liqMatDefaultNoFlask;
				break;
			case DETAIL.BumpTexture:
				if (liqMatBump == null)
				{
					liqMatBump = UnityEngine.Object.Instantiate(Resources.Load<Material>("Materials/LiquidVolumeBump"));
					liqMatBump.hideFlags = HideFlags.DontSave;
				}
				liqMat = liqMatBump;
				break;
			case DETAIL.Reflections:
				if (liqMatReflections == null)
				{
					liqMatReflections = UnityEngine.Object.Instantiate(Resources.Load<Material>("Materials/LiquidVolumeReflections"));
					liqMatReflections.hideFlags = HideFlags.DontSave;
				}
				liqMat = liqMatReflections;
				break;
			default:
				if (liqMatDefault == null)
				{
					liqMatDefault = UnityEngine.Object.Instantiate(Resources.Load<Material>("Materials/LiquidVolumeDefault"));
					liqMatDefault.hideFlags = HideFlags.DontSave;
				}
				liqMat = liqMatDefault;
				break;
			}
			if (liqMat == null)
			{
				return;
			}
			UpdateLevels();
			if (mr == null)
			{
				return;
			}
			mr.sharedMaterial = liqMat;
			if (currentDetail != _detail)
			{
				currentDetail = _detail;
				if (_detail == DETAIL.Reflections)
				{
					_flaskTint = UnityEngine.Color.white;
					_flaskGlossinessExternal = 0.1f;
				}
				else
				{
					_flaskTint = new UnityEngine.Color(0f, 0f, 0f, 1f);
				}
			}
			liqMat.SetColor("_Color1", ApplyGlobalAlpha(_liquidColor1));
			liqMat.SetColor("_Color2", ApplyGlobalAlpha(_liquidColor2));
			liqMat.SetColor("_EmissionColor", _emissionColor * _emissionBrightness);
			liqMat.SetFloat("_Glossiness", _flaskGlossinessExternal);
			liqMat.SetFloat("_GlossinessInt", _flaskGlossinessInternal * 96f + 1f);
			liqMat.SetFloat("_Topology", (float)_topology);
			liqMat.SetFloat("_Muddy", _murkiness);
			liqMat.SetFloat("_Alpha", _alpha);
			float num = _alpha * Mathf.Clamp01((_liquidColor1.a + _liquidColor2.a) * 4f);
			if (_ditherShadows)
			{
				liqMat.SetFloat("_AlphaCombined", num);
			}
			else
			{
				liqMat.SetFloat("_AlphaCombined", (num > 0f) ? 1000f : 0f);
			}
			liqMat.SetFloat("_SparklingIntensity", _sparklingIntensity * 250f);
			liqMat.SetFloat("_SparklingThreshold", 1f - _sparklingAmount);
			liqMat.SetFloat("_DeepAtten", _deepObscurance);
			liqMat.SetColor("_SmokeColor", ApplyGlobalAlpha(_smokeColor));
			liqMat.SetFloat("_SmokeAtten", _smokeBaseObscurance);
			liqMat.SetFloat("_SmokeSpeed", _smokeSpeed);
			liqMat.SetFloat("_LiquidRaySteps", _liquidRaySteps);
			liqMat.SetFloat("_SmokeRaySteps", _smokeRaySteps);
			liqMat.SetFloat("_FlaskBlurIntensity", _blurIntensity * (_refractionBlur ? 1f : 0f));
			liqMat.SetColor("_FlaskTint", _flaskTint * _flaskTint.a);
			liqMat.SetColor("_FoamColor", ApplyGlobalAlpha(_foamColor));
			liqMat.SetFloat("_FoamRaySteps", _foamRaySteps);
			liqMat.SetFloat("_FoamDensity", _foamDensity);
			liqMat.SetFloat("_FoamWeight", _foamWeight);
			liqMat.SetFloat("_FoamBottom", _foamVisibleFromBottom ? 1f : 0f);
			liqMat.SetFloat("_FoamTurbulence", _foamTurbulence);
			liqMat.SetFloat("_FlaskTexAlpha", _textureAlpha);
			if (_detail == DETAIL.BumpTexture)
			{
				liqMat.SetTexture("_BumpMap", _bumpMap);
				liqMat.SetTextureScale("_BumpMap", Vector2.one * _bumpDistortionScale);
				liqMat.SetTextureOffset("_BumpMap", _bumpDistortionOffset);
				liqMat.SetTexture("_DispMap", _distortionMap);
				liqMat.SetTextureScale("_DispMap", Vector2.one * _bumpDistortionScale);
				liqMat.SetTextureOffset("_DispMap", _bumpDistortionOffset);
				liqMat.SetFloat("_DispAmount", _distortionAmount);
				liqMat.SetTexture("_FlaskTex", _texture);
				liqMat.SetTextureScale("_FlaskTex", _textureScale);
				liqMat.SetTextureOffset("_FlaskTex", _textureOffset);
			}
			if (_detail == DETAIL.Reflections)
			{
				if (_reflectionTexture == null)
				{
					_reflectionTexture = Resources.Load<Cubemap>("Textures/Reflections");
				}
				liqMat.SetTexture("_RefractTex", _reflectionTexture);
			}
			Texture3D texture3D = Resources.Load<Texture3D>("Textures/Noise3D" + _noiseVariation);
			if (texture3D != null)
			{
				liqMat.SetTexture("_NoiseTex", texture3D);
			}
			liqMat.renderQueue = _renderQueue;
			UpdateInsideOut();
			if (_topology == TOPOLOGY.Irregular && prevThickness != _flaskThickness)
			{
				prevThickness = _flaskThickness;
				CleanupBackFacesBuffer();
			}
		}

		private UnityEngine.Color ApplyGlobalAlpha(UnityEngine.Color originalColor)
		{
			return new UnityEngine.Color(originalColor.r, originalColor.g, originalColor.b, originalColor.a * _alpha);
		}

		private void UpdateLevels()
		{
			if (liqMat == null)
			{
				return;
			}
			if (mesh == null)
			{
				MeshFilter component = GetComponent<MeshFilter>();
				if (component != null)
				{
					mesh = component.sharedMesh;
					mr = GetComponent<MeshRenderer>();
				}
				else
				{
					SkinnedMeshRenderer component2 = GetComponent<SkinnedMeshRenderer>();
					if (component2 != null)
					{
						mesh = component2.sharedMesh;
						mr = component2;
					}
				}
			}
			if (!(mesh == null) && !(mr == null))
			{
				Vector4 value = new Vector4(mesh.bounds.extents.x * 2f * base.transform.lossyScale.x, mesh.bounds.extents.y * 2f * base.transform.lossyScale.y, mesh.bounds.extents.z * 2f * base.transform.lossyScale.z, 0f);
				value.x *= _extentsScale.x;
				value.y *= _extentsScale.y;
				value.z *= _extentsScale.z;
				float num = Mathf.Max(value.x, value.z);
				float num2 = value.y * 0.5f * (1f - _flaskThickness * num / value.y);
				Vector3 extents = mr.bounds.extents;
				extents.x *= _extentsScale.x;
				extents.y *= _extentsScale.y;
				extents.z *= _extentsScale.z;
				float num3;
				if (_upperLimit < 1f && !_ignoreGravity)
				{
					float y = base.transform.TransformPoint(Vector3.up * extents.y).y;
					num3 = Mathf.Max(base.transform.TransformPoint(Vector3.up * (extents.y * _upperLimit)).y - y, 0f);
				}
				else
				{
					num3 = 0f;
				}
				liquidLevelPos = base.transform.position.y - extents.y + extents.y * 2f * _level + num3;
				liqMat.SetFloat("_LevelPos", liquidLevelPos);
				float value2 = mesh.bounds.extents.y * _extentsScale.y * _upperLimit;
				liqMat.SetFloat("_UpperLimit", value2);
				float num4 = ((_level <= 0f || _level >= 1f) ? 0f : 1f);
				UpdateTurbulence();
				float value3 = base.transform.position.y - extents.y + (num3 + extents.y * 2f * (_level + _foamThickness)) * num4;
				liqMat.SetFloat("_FoamMaxPos", value3);
				Vector3 vector = new Vector3(1f - _flaskThickness, 1f - _flaskThickness * num / value.y, 1f - _flaskThickness * num / value.z);
				liqMat.SetVector("_FlaskThickness", vector);
				value.w = value.x * 0.5f * vector.x;
				liqMat.SetVector("_Size", value);
				liqMat.SetVector("_Scale", new Vector4(_smokeScale / num2, _foamScale / num2, _liquidScale1 / num2, _liquidScale2 / num2));
				liqMat.SetVector("_Center", base.transform.position);
				if (shaderKeywords == null)
				{
					shaderKeywords = new List<string>();
				}
				else
				{
					shaderKeywords.Clear();
				}
				if (_depthAware)
				{
					shaderKeywords.Add("LIQUID_VOLUME_DEPTH_AWARE");
				}
				if (_depthAwareCustomPass)
				{
					shaderKeywords.Add("LIQUID_VOLUME_DEPTH_AWARE_PASS");
				}
				if (_reactToForces && _topology == TOPOLOGY.Sphere)
				{
					shaderKeywords.Add("LIQUID_VOLUME_IGNORE_GRAVITY");
				}
				else if (_ignoreGravity)
				{
					shaderKeywords.Add("LIQUID_VOLUME_IGNORE_GRAVITY");
				}
				else if (base.transform.rotation.eulerAngles != Vector3.zero)
				{
					shaderKeywords.Add("LIQUID_VOLUME_NON_AABB");
				}
				switch (_topology)
				{
				case TOPOLOGY.Sphere:
					shaderKeywords.Add("LIQUID_VOLUME_SPHERE");
					break;
				case TOPOLOGY.Cube:
					shaderKeywords.Add("LIQUID_VOLUME_CUBE");
					break;
				case TOPOLOGY.Cylinder:
					shaderKeywords.Add("LIQUID_VOLUME_CYLINDER");
					break;
				default:
					shaderKeywords.Add("LIQUID_VOLUME_IRREGULAR");
					break;
				}
				liqMat.shaderKeywords = shaderKeywords.ToArray();
				lastPosition = base.transform.position;
				lastScale = base.transform.localScale;
				lastRotation = base.transform.rotation;
			}
		}

		private void UpdateTurbulence()
		{
			if (!(liqMat == null))
			{
				float num = 1f;
				float num2 = ((camInside && _allowViewFromInside) ? 0f : 1f);
				turb.x = _turbulence1 * num * num2;
				turb.y = Mathf.Max(_turbulence2, turbulenceDueForces) * num * num2;
				Vector4 value = turb;
				value.z *= (float)Math.PI * _frecuency * 4f;
				value.w *= (float)Math.PI * _frecuency * 4f;
				liqMat.SetVector("_Turbulence", value);
			}
		}

		private void CheckInsideOut()
		{
			if (Camera.current == null || mr == null)
			{
				if (!_allowViewFromInside)
				{
					UpdateInsideOut();
				}
				return;
			}
			Vector3 position = Camera.current.transform.position;
			float sqrMagnitude = (position - base.transform.position).sqrMagnitude;
			if (sqrMagnitude != lastDistanceToCam)
			{
				lastDistanceToCam = sqrMagnitude;
				bool flag = false;
				switch (_topology)
				{
				case TOPOLOGY.Cube:
					flag = PointInAABB(position);
					break;
				case TOPOLOGY.Cylinder:
					flag = PointInCylinder(position);
					break;
				default:
				{
					float num = mesh.bounds.extents.x * 2f;
					flag = (position - base.transform.position).sqrMagnitude < num * num;
					break;
				}
				}
				if (flag != camInside)
				{
					camInside = flag;
					UpdateInsideOut();
				}
			}
		}

		private bool PointInAABB(Vector3 point)
		{
			point = base.transform.InverseTransformPoint(point);
			Vector3 extents = mesh.bounds.extents;
			if (point.x < extents.x && point.x > 0f - extents.x && point.y < extents.y && point.y > 0f - extents.y && point.z < extents.z && point.z > 0f - extents.z)
			{
				return true;
			}
			return false;
		}

		private bool PointInCylinder(Vector3 point)
		{
			point = base.transform.InverseTransformPoint(point);
			Vector3 extents = mesh.bounds.extents;
			if (point.x < extents.x && point.x > 0f - extents.x && point.y < extents.y && point.y > 0f - extents.y && point.z < extents.z && point.z > 0f - extents.z)
			{
				point.y = 0f;
				Vector3 position = base.transform.position;
				position.y = 0f;
				return (point - position).sqrMagnitude < extents.x * extents.x;
			}
			return false;
		}

		private void UpdateInsideOut()
		{
			if (!(liqMat == null))
			{
				if (_allowViewFromInside && camInside)
				{
					liqMat.SetInt("_CullMode", 1);
					liqMat.SetInt("_ZTestMode", 8);
				}
				else
				{
					liqMat.SetInt("_CullMode", 2);
					liqMat.SetInt("_ZTestMode", 4);
				}
				UpdateTurbulence();
			}
		}

		private void CleanupCommandBuffer()
		{
			CleanupRefractionBuffer();
			CleanupBackFacesBuffer();
			CleanupFrontFacesBuffer();
		}

		internal static void CleanupRefractionBuffer()
		{
			foreach (KeyValuePair<Camera, CommandBuffer> item in m_CamerasBlur)
			{
				if ((bool)item.Key)
				{
					item.Key.RemoveCommandBuffer(CameraEvent.AfterImageEffectsOpaque, item.Value);
				}
			}
			m_CamerasBlur.Clear();
			if (blurMat != null)
			{
				UnityEngine.Object.DestroyImmediate(blurMat);
				blurMat = null;
			}
		}

		internal static void SetupRefractionBuffer()
		{
			Camera current = Camera.current;
			if (!current)
			{
				return;
			}
			CommandBuffer commandBuffer = null;
			if (!m_CamerasBlur.ContainsKey(current))
			{
				if (blurMat == null)
				{
					blurMat = UnityEngine.Object.Instantiate(Resources.Load<Material>("Materials/LiquidVolumeBlur"));
					blurMat.hideFlags = HideFlags.DontSave;
				}
				commandBuffer = new CommandBuffer();
				commandBuffer.name = "Volumetric Liquid Background Blur";
				m_CamerasBlur[current] = commandBuffer;
				int num = Shader.PropertyToID("_VLScreenCopyTexture");
				commandBuffer.GetTemporaryRT(num, -1, -1, 0, FilterMode.Bilinear);
				commandBuffer.Blit(BuiltinRenderTextureType.CurrentActive, num);
				int num2 = Shader.PropertyToID("_VLTemp1");
				int num3 = Shader.PropertyToID("_VLTemp2");
				commandBuffer.GetTemporaryRT(num2, -2, -2, 0, FilterMode.Bilinear);
				commandBuffer.GetTemporaryRT(num3, -2, -2, 0, FilterMode.Bilinear);
				commandBuffer.Blit(num, num3, blurMat, 0);
				commandBuffer.ReleaseTemporaryRT(num);
				commandBuffer.Blit(num3, num2, blurMat, 1);
				commandBuffer.ReleaseTemporaryRT(num3);
				commandBuffer.SetGlobalTexture("_VLGrabBlurTexture", num2);
				current.AddCommandBuffer(CameraEvent.AfterImageEffectsOpaque, commandBuffer);
			}
		}

		internal static void SetupBackFacesBuffer(Renderer renderer)
		{
			Camera current = Camera.current;
			if (!current || renderer == null)
			{
				return;
			}
			if (!bbRenderers.Contains(renderer))
			{
				CleanupBackFacesCameras();
			}
			CommandBuffer buf = null;
			if (m_CamerasBackBuffer.ContainsKey(current))
			{
				return;
			}
			if (backBufferMat == null)
			{
				backBufferMat = new Material(Shader.Find("LiquidVolume/ZWriteBack"));
				backBufferMat.hideFlags = HideFlags.DontSave;
			}
			bbRenderers.Add(renderer);
			buf = new CommandBuffer();
			buf.name = "Volumetric Liquid BackBuffer";
			m_CamerasBackBuffer[current] = buf;
			int num = Shader.PropertyToID("_VLBackBufferTexture");
			buf.GetTemporaryRT(num, -1, -1, 24, FilterMode.Point, RenderTextureFormat.ARGB32, RenderTextureReadWrite.Linear);
			buf.SetRenderTarget(num);
			buf.ClearRenderTarget(clearDepth: true, clearColor: true, new UnityEngine.Color(84f / 85f, 0.4470558f, 0.75f, 0f), 0f);
			bbRenderers.ForEach(delegate(Renderer obj)
			{
				if (obj != null && obj.gameObject.activeSelf)
				{
					backBufferMat.SetFloat("_FlaskThickness", 1f - obj.GetComponent<LiquidVolume>().flaskThickness);
					buf.DrawRenderer(obj, backBufferMat);
				}
			});
			current.AddCommandBuffer(CameraEvent.AfterImageEffectsOpaque, buf);
		}

		internal static void CleanupBackFacesBuffer()
		{
			CleanupBackFacesCameras();
			if (backBufferMat != null)
			{
				UnityEngine.Object.DestroyImmediate(backBufferMat);
				backBufferMat = null;
			}
			bbRenderers.Clear();
		}

		internal static void CleanupBackFacesCameras()
		{
			foreach (KeyValuePair<Camera, CommandBuffer> item in m_CamerasBackBuffer)
			{
				if ((bool)item.Key)
				{
					item.Key.RemoveCommandBuffer(CameraEvent.AfterImageEffectsOpaque, item.Value);
				}
			}
			m_CamerasBackBuffer.Clear();
		}

		internal static void SetupFrontFacesBuffer(Renderer renderer)
		{
			Camera current = Camera.current;
			if (!current)
			{
				return;
			}
			if (!fbRenderers.Contains(renderer))
			{
				CleanupFrontFacesCameras();
			}
			CommandBuffer buf = null;
			if (!m_CamerasFrontBuffer.ContainsKey(current))
			{
				if (frontBufferMat == null)
				{
					frontBufferMat = new Material(Shader.Find("LiquidVolume/ZWriteFront"));
					frontBufferMat.hideFlags = HideFlags.DontSave;
				}
				fbRenderers.Add(renderer);
				buf = new CommandBuffer();
				buf.name = "Volumetric Liquid FrontBuffer";
				m_CamerasFrontBuffer[current] = buf;
				int num = Shader.PropertyToID("_VLFrontBufferTexture");
				buf.GetTemporaryRT(num, -1, -1, 24, FilterMode.Point, RenderTextureFormat.ARGB32, RenderTextureReadWrite.Linear);
				buf.SetRenderTarget(num);
				buf.ClearRenderTarget(clearDepth: true, clearColor: true, new UnityEngine.Color(84f / 85f, 0.4470558f, 0.75f, 0f), 1f);
				fbRenderers.ForEach(delegate(Renderer obj)
				{
					buf.DrawRenderer(obj, frontBufferMat);
				});
				current.AddCommandBuffer(CameraEvent.AfterImageEffectsOpaque, buf);
			}
		}

		internal static void CleanupFrontFacesBuffer()
		{
			CleanupFrontFacesCameras();
			if (frontBufferMat != null)
			{
				UnityEngine.Object.DestroyImmediate(frontBufferMat);
				frontBufferMat = null;
			}
			fbRenderers.Clear();
		}

		internal static void CleanupFrontFacesCameras()
		{
			foreach (KeyValuePair<Camera, CommandBuffer> item in m_CamerasFrontBuffer)
			{
				if ((bool)item.Key)
				{
					item.Key.RemoveCommandBuffer(CameraEvent.AfterImageEffectsOpaque, item.Value);
				}
			}
			m_CamerasFrontBuffer.Clear();
		}

		public bool GetSpillPoint(out Vector3 spillPosition, float apertureStart = 1f)
		{
			float spillAmount = 0f;
			return GetSpillPoint(out spillPosition, out spillAmount, apertureStart);
		}

		public bool GetSpillPoint(out Vector3 spillPosition, out float spillAmount, float apertureStart = 1f)
		{
			spillPosition = Vector3.zero;
			spillAmount = 0f;
			if (mesh == null || vertices == null || _level <= 0f)
			{
				return false;
			}
			float num = mesh.bounds.extents.y * apertureStart;
			Vector3 vector = base.transform.position;
			bool flag = false;
			int count = vertices.Count;
			float num2 = float.MaxValue;
			for (int i = 0; i < count; i++)
			{
				Vector3 position = vertices[i];
				if (position.y < num)
				{
					break;
				}
				position = base.transform.TransformPoint(position);
				if (position.y < liquidLevelPos && position.y < num2)
				{
					num2 = position.y;
					vector = position;
					flag = true;
				}
			}
			if (!flag)
			{
				return false;
			}
			spillPosition = vector;
			spillAmount = (liquidLevelPos - vector.y) / (mesh.bounds.extents.y * 2f * base.transform.localScale.y);
			return true;
		}

		private void UpdateSpillPointGizmo()
		{
			if (spillPointGizmo == null)
			{
				Transform transform = base.transform.Find("SpillPointGizmo");
				if (transform != null)
				{
					spillPointGizmo = transform.gameObject;
				}
			}
			if (!_debugSpillPoint)
			{
				if (spillPointGizmo != null)
				{
					UnityEngine.Object.DestroyImmediate(spillPointGizmo);
					spillPointGizmo = null;
				}
				return;
			}
			if (spillPointGizmo == null)
			{
				spillPointGizmo = GameObject.CreatePrimitive(PrimitiveType.Sphere);
				spillPointGizmo.transform.localScale = Vector3.one * 0.05f;
				spillPointGizmo.transform.SetParent(base.transform, worldPositionStays: true);
				Collider component = spillPointGizmo.GetComponent<Collider>();
				if (component != null)
				{
					UnityEngine.Object.DestroyImmediate(component);
				}
				MeshRenderer component2 = spillPointGizmo.GetComponent<MeshRenderer>();
				if (component2 != null)
				{
					component2.material.color = UnityEngine.Color.yellow;
				}
			}
			if (GetSpillPoint(out var spillPosition))
			{
				spillPointGizmo.transform.position = spillPosition;
				spillPointGizmo.SetActive(value: true);
			}
			else
			{
				spillPointGizmo.SetActive(value: false);
			}
		}
	}
}
namespace DentedPixel.LTExamples
{
	public class PathBezier : MonoBehaviour
	{
		public Transform[] trans;

		private LTBezierPath cr;

		private GameObject avatar1;

		private float iter;

		private void OnEnable()
		{
			cr = new LTBezierPath(new Vector3[8]
			{
				trans[0].position,
				trans[2].position,
				trans[1].position,
				trans[3].position,
				trans[3].position,
				trans[5].position,
				trans[4].position,
				trans[6].position
			});
		}

		private void Start()
		{
			avatar1 = GameObject.Find("Avatar1");
			LTDescr lTDescr = LeanTween.move(avatar1, cr.pts, 6.5f).setOrientToPath(doesOrient: true).setRepeat(-1);
			UnityEngine.Debug.Log("length of path 1:" + cr.length);
			UnityEngine.Debug.Log("length of path 2:" + lTDescr.optional.path.length);
		}

		private void Update()
		{
			iter += Time.deltaTime * 0.07f;
			if (iter > 1f)
			{
				iter = 0f;
			}
		}

		private void OnDrawGizmos()
		{
			if (cr != null)
			{
				OnEnable();
			}
			Gizmos.color = UnityEngine.Color.red;
			if (cr != null)
			{
				cr.gizmoDraw();
			}
		}
	}
	public class TestingUnitTests : MonoBehaviour
	{
		public GameObject cube1;

		public GameObject cube2;

		public GameObject cube3;

		public GameObject cube4;

		public GameObject cubeAlpha1;

		public GameObject cubeAlpha2;

		private bool eventGameObjectWasCalled;

		private bool eventGeneralWasCalled;

		private int lt1Id;

		private LTDescr lt2;

		private LTDescr lt3;

		private LTDescr lt4;

		private LTDescr[] groupTweens;

		private GameObject[] groupGOs;

		private int groupTweensCnt;

		private int rotateRepeat;

		private int rotateRepeatAngle;

		private GameObject boxNoCollider;

		private float timeElapsedNormalTimeScale;

		private float timeElapsedIgnoreTimeScale;

		private void Awake()
		{
			boxNoCollider = GameObject.CreatePrimitive(PrimitiveType.Cube);
			UnityEngine.Object.Destroy(boxNoCollider.GetComponent(typeof(BoxCollider)));
		}

		private void Start()
		{
			LeanTest.timeout = 46f;
			LeanTest.expected = 57;
			LeanTween.init(1215);
			LeanTween.addListener(cube1, 0, eventGameObjectCalled);
			LeanTest.expect(!LeanTween.isTweening(), "NOTHING TWEEENING AT BEGINNING");
			LeanTest.expect(!LeanTween.isTweening(cube1), "OBJECT NOT TWEEENING AT BEGINNING");
			LeanTween.scaleX(cube4, 2f, 0f).setOnComplete((Action)delegate
			{
				LeanTest.expect(cube4.transform.localScale.x == 2f, "TWEENED WITH ZERO TIME");
			});
			LeanTween.dispatchEvent(0);
			LeanTest.expect(eventGameObjectWasCalled, "EVENT GAMEOBJECT RECEIVED");
			LeanTest.expect(!LeanTween.removeListener(cube2, 0, eventGameObjectCalled), "EVENT GAMEOBJECT NOT REMOVED");
			LeanTest.expect(LeanTween.removeListener(cube1, 0, eventGameObjectCalled), "EVENT GAMEOBJECT REMOVED");
			LeanTween.addListener(1, eventGeneralCalled);
			LeanTween.dispatchEvent(1);
			LeanTest.expect(eventGeneralWasCalled, "EVENT ALL RECEIVED");
			LeanTest.expect(LeanTween.removeListener(1, eventGeneralCalled), "EVENT ALL REMOVED");
			lt1Id = LeanTween.move(cube1, new Vector3(3f, 2f, 0.5f), 1.1f).id;
			LeanTween.move(cube2, new Vector3(-3f, -2f, -0.5f), 1.1f);
			LeanTween.reset();
			GameObject[] cubes = new GameObject[99];
			int[] tweenIds = new int[cubes.Length];
			for (int i = 0; i < cubes.Length; i++)
			{
				GameObject gameObject = cubeNamed("cancel" + i);
				tweenIds[i] = LeanTween.moveX(gameObject, 100f, 1f).id;
				cubes[i] = gameObject;
			}
			int onCompleteCount = 0;
			LeanTween.delayedCall(cubes[0], 0.2f, (Action)delegate
			{
				for (int l = 0; l < cubes.Length; l++)
				{
					if (l % 3 == 0)
					{
						LeanTween.cancel(cubes[l]);
					}
					else if (l % 3 == 1)
					{
						LeanTween.cancel(tweenIds[l]);
					}
					else if (l % 3 == 2)
					{
						LeanTween.descr(tweenIds[l]).setOnComplete((Action)delegate
						{
							onCompleteCount++;
							if (onCompleteCount >= 33)
							{
								LeanTest.expect(didPass: true, "CANCELS DO NOT EFFECT FINISHING");
							}
						});
					}
				}
			});
			new LTSpline(new Vector3[5]
			{
				new Vector3(-1f, 0f, 0f),
				new Vector3(0f, 0f, 0f),
				new Vector3(4f, 0f, 0f),
				new Vector3(20f, 0f, 0f),
				new Vector3(30f, 0f, 0f)
			}).place(cube4.transform, 0.5f);
			LeanTest.expect(Vector3.Distance(cube4.transform.position, new Vector3(10f, 0f, 0f)) <= 0.7f, "SPLINE POSITIONING AT HALFWAY", string.Concat("position is:", cube4.transform.position, " but should be:(10f,0f,0f)"));
			LeanTween.color(cube4, UnityEngine.Color.green, 0.01f);
			GameObject gameObject2 = cubeNamed("cubeDest");
			Vector3 cubeDestEnd = new Vector3(100f, 20f, 0f);
			LeanTween.move(gameObject2, cubeDestEnd, 0.7f);
			GameObject cubeToTrans = cubeNamed("cubeToTrans");
			LeanTween.move(cubeToTrans, gameObject2.transform, 1.2f).setEase(LeanTweenType.easeOutQuad).setOnComplete((Action)delegate
			{
				LeanTest.expect(cubeToTrans.transform.position == cubeDestEnd, "MOVE TO TRANSFORM WORKS");
			});
			GameObject obj2 = cubeNamed("cubeDestroy");
			LeanTween.moveX(obj2, 200f, 0.05f).setDelay(0.02f).setDestroyOnComplete(doesDestroy: true);
			LeanTween.moveX(obj2, 200f, 0.1f).setDestroyOnComplete(doesDestroy: true).setOnComplete((Action)delegate
			{
				LeanTest.expect(didPass: true, "TWO DESTROY ON COMPLETE'S SUCCEED");
			});
			GameObject cubeSpline = cubeNamed("cubeSpline");
			LeanTween.moveSpline(cubeSpline, new Vector3[4]
			{
				new Vector3(0.5f, 0f, 0.5f),
				new Vector3(0.75f, 0f, 0.75f),
				new Vector3(1f, 0f, 1f),
				new Vector3(1f, 0f, 1f)
			}, 0.1f).setOnComplete((Action)delegate
			{
				LeanTest.expect(Vector3.Distance(new Vector3(1f, 0f, 1f), cubeSpline.transform.position) < 0.01f, "SPLINE WITH TWO POINTS SUCCEEDS");
			});
			GameObject jumpCube = cubeNamed("jumpTime");
			jumpCube.transform.position = new Vector3(100f, 0f, 0f);
			jumpCube.transform.localScale *= 100f;
			int jumpTimeId = LeanTween.moveX(jumpCube, 200f, 1f).id;
			LeanTween.delayedCall(base.gameObject, 0.2f, (Action)delegate
			{
				LTDescr lTDescr2 = LeanTween.descr(jumpTimeId);
				float beforeX = jumpCube.transform.position.x;
				lTDescr2.setTime(0.5f);
				LeanTween.delayedCall(0f, (Action)delegate
				{
				}).setOnStart(delegate
				{
					float num2 = 1f;
					beforeX += Time.deltaTime * 100f * 2f;
					LeanTest.expect(Mathf.Abs(jumpCube.transform.position.x - beforeX) < num2, "CHANGING TIME DOESN'T JUMP AHEAD", "Difference:" + Mathf.Abs(jumpCube.transform.position.x - beforeX) + " beforeX:" + beforeX + " now:" + jumpCube.transform.position.x + " dt:" + Time.deltaTime);
				});
			});
			GameObject zeroCube = cubeNamed("zeroCube");
			LeanTween.moveX(zeroCube, 10f, 0f).setOnComplete((Action)delegate
			{
				LeanTest.expect(zeroCube.transform.position.x == 10f, "ZERO TIME FINSHES CORRECTLY", "final x:" + zeroCube.transform.position.x);
			});
			GameObject cubeScale = cubeNamed("cubeScale");
			LeanTween.scale(cubeScale, new Vector3(5f, 5f, 5f), 0.01f).setOnStart(delegate
			{
				LeanTest.expect(didPass: true, "ON START WAS CALLED");
			}).setOnComplete((Action)delegate
			{
				LeanTest.expect(cubeScale.transform.localScale.z == 5f, "SCALE", "expected scale z:" + 5f + " returned:" + cubeScale.transform.localScale.z);
			});
			GameObject cubeRotate = cubeNamed("cubeRotate");
			LeanTween.rotate(cubeRotate, new Vector3(0f, 180f, 0f), 0.02f).setOnComplete((Action)delegate
			{
				LeanTest.expect(cubeRotate.transform.eulerAngles.y == 180f, "ROTATE", "expected rotate y:" + 180f + " returned:" + cubeRotate.transform.eulerAngles.y);
			});
			GameObject cubeRotateA = cubeNamed("cubeRotateA");
			LeanTween.rotateAround(cubeRotateA, Vector3.forward, 90f, 0.3f).setOnComplete((Action)delegate
			{
				LeanTest.expect(cubeRotateA.transform.eulerAngles.z == 90f, "ROTATE AROUND", "expected rotate z:" + 90f + " returned:" + cubeRotateA.transform.eulerAngles.z);
			});
			GameObject cubeRotateB = cubeNamed("cubeRotateB");
			cubeRotateB.transform.position = new Vector3(200f, 10f, 8f);
			LeanTween.rotateAround(cubeRotateB, Vector3.forward, 360f, 0.3f).setPoint(new Vector3(5f, 3f, 2f)).setOnComplete((Action)delegate
			{
				LeanTest.expect(cubeRotateB.transform.position.ToString() == new Vector3(200f, 10f, 8f).ToString(), "ROTATE AROUND 360", string.Concat("expected rotate pos:", new Vector3(200f, 10f, 8f), " returned:", cubeRotateB.transform.position));
			});
			LeanTween.alpha(cubeAlpha1, 0.5f, 0.1f).setOnUpdate(delegate(float val)
			{
				LeanTest.expect(val != 0f, "ON UPDATE VAL");
			}).setOnCompleteParam("Hi!")
				.setOnComplete(delegate(object completeObj)
				{
					LeanTest.expect((string)completeObj == "Hi!", "ONCOMPLETE OBJECT");
					LeanTest.expect(cubeAlpha1.GetComponent<Renderer>().material.color.a == 0.5f, "ALPHA");
				});
			float onStartTime = -1f;
			LeanTween.color(cubeAlpha2, UnityEngine.Color.cyan, 0.3f).setOnComplete((Action)delegate
			{
				LeanTest.expect(cubeAlpha2.GetComponent<Renderer>().material.color == UnityEngine.Color.cyan, "COLOR");
				LeanTest.expect(onStartTime >= 0f && onStartTime < Time.time, "ON START", "onStartTime:" + onStartTime + " time:" + Time.time);
			}).setOnStart(delegate
			{
				onStartTime = Time.time;
			});
			Vector3 beforePos = cubeAlpha1.transform.position;
			LeanTween.moveY(cubeAlpha1, 3f, 0.2f).setOnComplete((Action)delegate
			{
				LeanTest.expect(cubeAlpha1.transform.position.x == beforePos.x && cubeAlpha1.transform.position.z == beforePos.z, "MOVE Y");
			});
			Vector3 beforePos2 = cubeAlpha2.transform.localPosition;
			LeanTween.moveLocalZ(cubeAlpha2, 12f, 0.2f).setOnComplete((Action)delegate
			{
				LeanTest.expect(cubeAlpha2.transform.localPosition.x == beforePos2.x && cubeAlpha2.transform.localPosition.y == beforePos2.y, "MOVE LOCAL Z", "ax:" + cubeAlpha2.transform.localPosition.x + " bx:" + beforePos.x + " ay:" + cubeAlpha2.transform.localPosition.y + " by:" + beforePos2.y);
			});
			AudioClip audio = LeanAudio.createAudio(new AnimationCurve(new Keyframe(0f, 1f, 0f, -1f), new Keyframe(1f, 0f, -1f, 0f)), new AnimationCurve(new Keyframe(0f, 0.001f, 0f, 0f), new Keyframe(1f, 0.001f, 0f, 0f)), LeanAudio.options());
			LeanTween.delayedSound(base.gameObject, audio, new Vector3(0f, 0f, 0f), 0.1f).setDelay(0.2f).setOnComplete((Action)delegate
			{
				LeanTest.expect(Time.time > 0f, "DELAYED SOUND");
			});
			int totalEasingCheck = 0;
			int totalEasingCheckSuccess = 0;
			for (int j = 0; j < 2; j++)
			{
				bool flag = j == 1;
				int totalTweenTypeLength = 33;
				for (int k = 0; k < totalTweenTypeLength; k++)
				{
					LeanTweenType leanTweenType = (LeanTweenType)k;
					GameObject onCompleteParam = cubeNamed("cube" + leanTweenType);
					LTDescr lTDescr = LeanTween.moveLocalX(onCompleteParam, 5f, 0.1f).setOnComplete(delegate(object obj)
					{
						GameObject obj3 = obj as GameObject;
						int num = totalEasingCheck;
						totalEasingCheck = num + 1;
						if (obj3.transform.position.x == 5f)
						{
							num = totalEasingCheckSuccess;
							totalEasingCheckSuccess = num + 1;
						}
						if (totalEasingCheck == 2 * totalTweenTypeLength)
						{
							LeanTest.expect(totalEasingCheck == totalEasingCheckSuccess, "EASING TYPES");
						}
					}).setOnCompleteParam(onCompleteParam);
					if (flag)
					{
						lTDescr.setFrom(-5f);
					}
				}
			}
			bool value2UpdateCalled = false;
			LeanTween.value(base.gameObject, new Vector2(0f, 0f), new Vector2(256f, 96f), 0.1f).setOnUpdate((Action<Vector2>)delegate
			{
				value2UpdateCalled = true;
			}, (object)null);
			LeanTween.delayedCall(0.2f, (Action)delegate
			{
				LeanTest.expect(value2UpdateCalled, "VALUE2 UPDATE");
			});
			StartCoroutine(timeBasedTesting());
		}

		private GameObject cubeNamed(string name)
		{
			GameObject obj = UnityEngine.Object.Instantiate(boxNoCollider);
			obj.name = name;
			return obj;
		}

		private IEnumerator timeBasedTesting()
		{
			yield return Yield.EndOfFrame;
			GameObject obj = cubeNamed("normalTimeScale");
			LeanTween.moveX(obj, 12f, 1.5f).setIgnoreTimeScale(useUnScaledTime: false).setOnComplete((Action)delegate
			{
				timeElapsedNormalTimeScale = Time.time;
			});
			LTDescr[] array = LeanTween.descriptions(obj);
			LeanTest.expect(array.Length >= 0 && array[0].to.x == 12f, "WE CAN RETRIEVE A DESCRIPTION");
			LeanTween.moveX(cubeNamed("ignoreTimeScale"), 5f, 1.5f).setIgnoreTimeScale(useUnScaledTime: true).setOnComplete((Action)delegate
			{
				timeElapsedIgnoreTimeScale = Time.time;
			});
			yield return Yield.WaitSeconds(1.5f);
			LeanTest.expect(Mathf.Abs(timeElapsedNormalTimeScale - timeElapsedIgnoreTimeScale) < 0.7f, "START IGNORE TIMING", "timeElapsedIgnoreTimeScale:" + timeElapsedIgnoreTimeScale + " timeElapsedNormalTimeScale:" + timeElapsedNormalTimeScale);
			Time.timeScale = 4f;
			int pauseCount = 0;
			LeanTween.value(base.gameObject, 0f, 1f, 1f).setOnUpdate((Action<float>)delegate
			{
				pauseCount++;
			}).pause();
			Vector3[] to = new Vector3[16]
			{
				new Vector3(0f, 0f, 0f),
				new Vector3(-9.1f, 25.1f, 0f),
				new Vector3(-1.2f, 15.9f, 0f),
				new Vector3(-25f, 25f, 0f),
				new Vector3(-25f, 25f, 0f),
				new Vector3(-50.1f, 15.9f, 0f),
				new Vector3(-40.9f, 25.1f, 0f),
				new Vector3(-50f, 0f, 0f),
				new Vector3(-50f, 0f, 0f),
				new Vector3(-40.9f, -25.1f, 0f),
				new Vector3(-50.1f, -15.9f, 0f),
				new Vector3(-25f, -25f, 0f),
				new Vector3(-25f, -25f, 0f),
				new Vector3(0f, -15.9f, 0f),
				new Vector3(-9.1f, -25.1f, 0f),
				new Vector3(0f, 0f, 0f)
			};
			GameObject cubeRound = cubeNamed("bRound");
			Vector3 onStartPos = cubeRound.transform.position;
			LeanTween.moveLocal(cubeRound, to, 0.5f).setOnComplete((Action)delegate
			{
				LeanTest.expect(cubeRound.transform.position == onStartPos, "BEZIER CLOSED LOOP SHOULD END AT START", string.Concat("onStartPos:", onStartPos, " onEnd:", cubeRound.transform.position));
			});
			Vector3[] to2 = new Vector3[6]
			{
				new Vector3(0f, 0f, 0f),
				new Vector3(0f, 0f, 0f),
				new Vector3(2f, 0f, 0f),
				new Vector3(0.9f, 2f, 0f),
				new Vector3(0f, 0f, 0f),
				new Vector3(0f, 0f, 0f)
			};
			GameObject cubeSpline = cubeNamed("bSpline");
			Vector3 onStartPosSpline = cubeSpline.transform.position;
			LeanTween.moveSplineLocal(cubeSpline, to2, 0.5f).setOnComplete((Action)delegate
			{
				LeanTest.expect(Vector3.Distance(onStartPosSpline, cubeSpline.transform.position) <= 0.01f, "SPLINE CLOSED LOOP SHOULD END AT START", string.Concat("onStartPos:", onStartPosSpline, " onEnd:", cubeSpline.transform.position, " dist:", Vector3.Distance(onStartPosSpline, cubeSpline.transform.position)));
			});
			groupTweens = new LTDescr[1200];
			groupGOs = new GameObject[groupTweens.Length];
			groupTweensCnt = 0;
			int descriptionMatchCount = 0;
			for (int i = 0; i < groupTweens.Length; i++)
			{
				GameObject gameObject = cubeNamed("c" + i);
				gameObject.transform.position = new Vector3(0f, 0f, i * 3);
				groupGOs[i] = gameObject;
			}
			yield return Yield.EndOfFrame;
			bool hasGroupTweensCheckStarted = false;
			int setOnStartNum = 0;
			int setPosNum = 0;
			bool setPosOnUpdate = true;
			for (int j = 0; j < groupTweens.Length; j++)
			{
				Vector3 vector = base.transform.position + Vector3.one * 3f;
				Dictionary<string, object> onCompleteParam = new Dictionary<string, object>
				{
					{ "final", vector },
					{
						"go",
						groupGOs[j]
					}
				};
				groupTweens[j] = LeanTween.move(groupGOs[j], vector, 3f).setOnStart(delegate
				{
					setOnStartNum++;
				}).setOnUpdate(delegate(Vector3 newPosition)
				{
					if (base.transform.position.z > newPosition.z)
					{
						setPosOnUpdate = false;
					}
				})
					.setOnCompleteParam(onCompleteParam)
					.setOnComplete(delegate(object param)
					{
						Dictionary<string, object> obj2 = param as Dictionary<string, object>;
						Vector3 vector2 = (Vector3)obj2["final"];
						GameObject gameObject2 = obj2["go"] as GameObject;
						if (vector2.ToString() == gameObject2.transform.position.ToString())
						{
							setPosNum++;
						}
						if (!hasGroupTweensCheckStarted)
						{
							hasGroupTweensCheckStarted = true;
							LeanTween.delayedCall(base.gameObject, 0.1f, (Action)delegate
							{
								LeanTest.expect(setOnStartNum == groupTweens.Length, "SETONSTART CALLS", "expected:" + groupTweens.Length + " was:" + setOnStartNum);
								LeanTest.expect(groupTweensCnt == groupTweens.Length, "GROUP FINISH", "expected " + groupTweens.Length + " tweens but got " + groupTweensCnt);
								LeanTest.expect(setPosNum == groupTweens.Length, "GROUP POSITION FINISH", "expected " + groupTweens.Length + " tweens but got " + setPosNum);
								LeanTest.expect(setPosOnUpdate, "GROUP POSITION ON UPDATE");
							});
						}
						groupTweensCnt++;
					});
				if (LeanTween.description(groupTweens[j].id).trans == groupTweens[j].trans)
				{
					descriptionMatchCount++;
				}
			}
			while (LeanTween.tweensRunning < groupTweens.Length)
			{
				yield return null;
			}
			LeanTest.expect(descriptionMatchCount == groupTweens.Length, "GROUP IDS MATCH");
			int num = groupTweens.Length + 5;
			LeanTest.expect(LeanTween.maxSearch <= num, "MAX SEARCH OPTIMIZED", "maxSearch:" + LeanTween.maxSearch + " should be:" + num);
			LeanTest.expect(LeanTween.isTweening(), "SOMETHING IS TWEENING");
			float previousXlt4 = cube4.transform.position.x;
			lt4 = LeanTween.moveX(cube4, 5f, 1.1f).setOnComplete((Action)delegate
			{
				LeanTest.expect(cube4 != null && previousXlt4 != cube4.transform.position.x, "RESUME OUT OF ORDER", string.Concat("cube4:", cube4, " previousXlt4:", previousXlt4, " cube4.transform.position.x:", (cube4 != null) ? cube4.transform.position.x : 0f));
			}).setDestroyOnComplete(doesDestroy: true);
			lt4.resume();
			TestingUnitTests testingUnitTests = this;
			TestingUnitTests testingUnitTests2 = this;
			int num2 = 0;
			testingUnitTests2.rotateRepeatAngle = 0;
			testingUnitTests.rotateRepeat = num2;
			LeanTween.rotateAround(cube3, Vector3.forward, 360f, 0.1f).setRepeat(3).setOnComplete(rotateRepeatFinished)
				.setOnCompleteOnRepeat(isOn: true)
				.setDestroyOnComplete(doesDestroy: true);
			yield return Yield.EndOfFrame;
			LeanTween.delayedCall(1.8f, rotateRepeatAllFinished);
			int tweensRunning = LeanTween.tweensRunning;
			LeanTween.cancel(lt1Id);
			LeanTest.expect(tweensRunning == LeanTween.tweensRunning, "CANCEL AFTER RESET SHOULD FAIL", "expected " + tweensRunning + " but got " + LeanTween.tweensRunning);
			LeanTween.cancel(cube2);
			int num3 = 0;
			for (int k = 0; k < groupTweens.Length; k++)
			{
				if (LeanTween.isTweening(groupGOs[k]))
				{
					num3++;
				}
				if (k % 3 == 0)
				{
					LeanTween.pause(groupGOs[k]);
				}
				else if (k % 3 == 1)
				{
					groupTweens[k].pause();
				}
				else
				{
					LeanTween.pause(groupTweens[k].id);
				}
			}
			LeanTest.expect(num3 == groupTweens.Length, "GROUP ISTWEENING", "expected " + groupTweens.Length + " tweens but got " + num3);
			yield return Yield.EndOfFrame;
			num3 = 0;
			for (int l = 0; l < groupTweens.Length; l++)
			{
				if (l % 3 == 0)
				{
					LeanTween.resume(groupGOs[l]);
				}
				else if (l % 3 == 1)
				{
					groupTweens[l].resume();
				}
				else
				{
					LeanTween.resume(groupTweens[l].id);
				}
				if ((l % 2 == 0) ? LeanTween.isTweening(groupTweens[l].id) : LeanTween.isTweening(groupGOs[l]))
				{
					num3++;
				}
			}
			LeanTest.expect(num3 == groupTweens.Length, "GROUP RESUME");
			LeanTest.expect(!LeanTween.isTweening(cube1), "CANCEL TWEEN LTDESCR");
			LeanTest.expect(!LeanTween.isTweening(cube2), "CANCEL TWEEN LEANTWEEN");
			LeanTest.expect(pauseCount == 0, "ON UPDATE NOT CALLED DURING PAUSE", "expect pause count of 0, but got " + pauseCount);
			yield return Yield.EndOfFrame;
			Time.timeScale = 0.25f;
			float num4 = 0.2f;
			float expectedTime = num4 * (1f / Time.timeScale);
			float start = Time.realtimeSinceStartup;
			bool onUpdateWasCalled = false;
			LeanTween.moveX(cube1, -5f, num4).setOnUpdate((Action<float>)delegate
			{
				onUpdateWasCalled = true;
			}).setOnComplete((Action)delegate
			{
				float num6 = Time.realtimeSinceStartup - start;
				LeanTest.expect(Mathf.Abs(expectedTime - num6) < 0.05f, "SCALED TIMING DIFFERENCE", "expected to complete in roughly " + expectedTime + " but completed in " + num6);
				LeanTest.expect(Mathf.Approximately(cube1.transform.position.x, -5f), "SCALED ENDING POSITION", "expected to end at -5f, but it ended at " + cube1.transform.position.x);
				LeanTest.expect(onUpdateWasCalled, "ON UPDATE FIRED");
			});
			bool didGetCorrectOnUpdate = false;
			LeanTween.value(base.gameObject, new Vector3(1f, 1f, 1f), new Vector3(10f, 10f, 10f), 1f).setOnUpdate(delegate(Vector3 val)
			{
				didGetCorrectOnUpdate = val.x >= 1f && val.y >= 1f && val.z >= 1f;
			}).setOnComplete((Action)delegate
			{
				LeanTest.expect(didGetCorrectOnUpdate, "VECTOR3 CALLBACK CALLED");
			});
			yield return Yield.WaitSeconds(expectedTime);
			Time.timeScale = 1f;
			int num5 = 0;
			GameObject[] array2 = UnityEngine.Object.FindObjectsOfType(typeof(GameObject)) as GameObject[];
			for (num2 = 0; num2 < array2.Length; num2++)
			{
				if (array2[num2].name == "~LeanTween")
				{
					num5++;
				}
			}
			LeanTest.expect(num5 == 1, "RESET CORRECTLY CLEANS UP");
			lotsOfCancels();
		}

		private IEnumerator lotsOfCancels()
		{
			yield return Yield.EndOfFrame;
			Time.timeScale = 4f;
			int cubeCount = 10;
			int[] tweensA = new int[cubeCount];
			GameObject[] aGOs = new GameObject[cubeCount];
			for (int i = 0; i < aGOs.Length; i++)
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(boxNoCollider);
				gameObject.transform.position = new Vector3(0f, 0f, (float)i * 2f);
				gameObject.name = "a" + i;
				aGOs[i] = gameObject;
				tweensA[i] = LeanTween.move(gameObject, gameObject.transform.position + new Vector3(10f, 0f, 0f), 0.5f + 1f * (1f / (float)aGOs.Length)).id;
				LeanTween.color(gameObject, UnityEngine.Color.red, 0.01f);
			}
			yield return Yield.WaitSeconds(1f);
			int[] tweensB = new int[cubeCount];
			GameObject[] bGOs = new GameObject[cubeCount];
			for (int j = 0; j < bGOs.Length; j++)
			{
				GameObject gameObject2 = UnityEngine.Object.Instantiate(boxNoCollider);
				gameObject2.transform.position = new Vector3(0f, 0f, (float)j * 2f);
				gameObject2.name = "b" + j;
				bGOs[j] = gameObject2;
				tweensB[j] = LeanTween.move(gameObject2, gameObject2.transform.position + new Vector3(10f, 0f, 0f), 2f).id;
			}
			for (int k = 0; k < aGOs.Length; k++)
			{
				LeanTween.cancel(aGOs[k]);
				GameObject gameObject3 = aGOs[k];
				tweensA[k] = LeanTween.move(gameObject3, new Vector3(0f, 0f, (float)k * 2f), 2f).id;
			}
			yield return Yield.WaitSeconds(0.5f);
			for (int l = 0; l < aGOs.Length; l++)
			{
				LeanTween.cancel(aGOs[l]);
				GameObject gameObject4 = aGOs[l];
				tweensA[l] = LeanTween.move(gameObject4, new Vector3(0f, 0f, (float)l * 2f) + new Vector3(10f, 0f, 0f), 2f).id;
			}
			for (int m = 0; m < bGOs.Length; m++)
			{
				LeanTween.cancel(bGOs[m]);
				GameObject gameObject5 = bGOs[m];
				tweensB[m] = LeanTween.move(gameObject5, new Vector3(0f, 0f, (float)m * 2f), 2f).id;
			}
			yield return Yield.WaitSeconds(2.1f);
			bool didPass = true;
			for (int n = 0; n < aGOs.Length; n++)
			{
				if (Vector3.Distance(aGOs[n].transform.position, new Vector3(0f, 0f, (float)n * 2f) + new Vector3(10f, 0f, 0f)) > 0.1f)
				{
					didPass = false;
				}
			}
			for (int num = 0; num < bGOs.Length; num++)
			{
				if (Vector3.Distance(bGOs[num].transform.position, new Vector3(0f, 0f, (float)num * 2f)) > 0.1f)
				{
					didPass = false;
				}
			}
			LeanTest.expect(didPass, "AFTER LOTS OF CANCELS");
		}

		private void rotateRepeatFinished()
		{
			if (Mathf.Abs(cube3.transform.eulerAngles.z) < 0.0001f)
			{
				rotateRepeatAngle++;
			}
			rotateRepeat++;
		}

		private void rotateRepeatAllFinished()
		{
			LeanTest.expect(rotateRepeatAngle == 3, "ROTATE AROUND MULTIPLE", "expected 3 times received " + rotateRepeatAngle + " times");
			LeanTest.expect(rotateRepeat == 3, "ROTATE REPEAT", "expected 3 times received " + rotateRepeat + " times");
			LeanTest.expect(cube3 == null, "DESTROY ON COMPLETE", "cube3:" + cube3);
		}

		private void eventGameObjectCalled(LTEvent e)
		{
			eventGameObjectWasCalled = true;
		}

		private void eventGeneralCalled(LTEvent e)
		{
			eventGeneralWasCalled = true;
		}
	}
}
namespace MiniEXR
{
	internal static class HalfHelper
	{
		private static uint[] mantissaTable = GenerateMantissaTable();

		private static uint[] exponentTable = GenerateExponentTable();

		private static ushort[] offsetTable = GenerateOffsetTable();

		private static ushort[] baseTable = GenerateBaseTable();

		private static sbyte[] shiftTable = GenerateShiftTable();

		private static uint ConvertMantissa(int i)
		{
			uint num = (uint)(i << 13);
			uint num2 = 0u;
			while ((num & 0x800000) == 0)
			{
				num2 -= 8388608;
				num <<= 1;
			}
			num &= 0xFF7FFFFFu;
			num2 += 947912704;
			return num | num2;
		}

		private static uint[] GenerateMantissaTable()
		{
			uint[] array = new uint[2048];
			array[0] = 0u;
			for (int i = 1; i < 1024; i++)
			{
				array[i] = ConvertMantissa(i);
			}
			for (int j = 1024; j < 2048; j++)
			{
				array[j] = (uint)(939524096 + (j - 1024 << 13));
			}
			return array;
		}

		private static uint[] GenerateExponentTable()
		{
			uint[] array = new uint[64];
			array[0] = 0u;
			for (int i = 1; i < 31; i++)
			{
				array[i] = (uint)(i << 23);
			}
			array[31] = 1199570944u;
			array[32] = 2147483648u;
			for (int j = 33; j < 63; j++)
			{
				array[j] = (uint)(2147483648u + (j - 32 << 23));
			}
			array[63] = 3347054592u;
			return array;
		}

		private static ushort[] GenerateOffsetTable()
		{
			ushort[] array = new ushort[64];
			array[0] = 0;
			for (int i = 1; i < 32; i++)
			{
				array[i] = 1024;
			}
			array[32] = 0;
			for (int j = 33; j < 64; j++)
			{
				array[j] = 1024;
			}
			return array;
		}

		private static ushort[] GenerateBaseTable()
		{
			ushort[] array = new ushort[512];
			for (int i = 0; i < 256; i++)
			{
				sbyte b = (sbyte)(127 - i);
				if (b > 24)
				{
					array[i | 0] = 0;
					array[i | 0x100] = 32768;
				}
				else if (b > 14)
				{
					array[i | 0] = (ushort)(1024 >> 18 + b);
					array[i | 0x100] = (ushort)((uint)(1024 >> 18 + b) | 0x8000u);
				}
				else if (b >= -15)
				{
					array[i | 0] = (ushort)(15 - b << 10);
					array[i | 0x100] = (ushort)((uint)(15 - b << 10) | 0x8000u);
				}
				else if (b > sbyte.MinValue)
				{
					array[i | 0] = 31744;
					array[i | 0x100] = 64512;
				}
				else
				{
					array[i | 0] = 31744;
					array[i | 0x100] = 64512;
				}
			}
			return array;
		}

		private static sbyte[] GenerateShiftTable()
		{
			sbyte[] array = new sbyte[512];
			for (int i = 0; i < 256; i++)
			{
				sbyte b = (sbyte)(127 - i);
				if (b > 24)
				{
					array[i | 0] = 24;
					array[i | 0x100] = 24;
				}
				else if (b > 14)
				{
					array[i | 0] = (sbyte)(b - 1);
					array[i | 0x100] = (sbyte)(b - 1);
				}
				else if (b >= -15)
				{
					array[i | 0] = 13;
					array[i | 0x100] = 13;
				}
				else if (b > sbyte.MinValue)
				{
					array[i | 0] = 24;
					array[i | 0x100] = 24;
				}
				else
				{
					array[i | 0] = 13;
					array[i | 0x100] = 13;
				}
			}
			return array;
		}

		public static float HalfToSingle(ushort half)
		{
			return BitConverter.ToSingle(BitConverter.GetBytes(mantissaTable[offsetTable[half >> 10] + (half & 0x3FF)] + exponentTable[half >> 10]), 0);
		}

		public static ushort SingleToHalf(float single)
		{
			uint num = BitConverter.ToUInt32(BitConverter.GetBytes(single), 0);
			return (ushort)(baseTable[(num >> 23) & 0x1FF] + ((num & 0x7FFFFF) >> (int)shiftTable[num >> 23]));
		}
	}
	public static class MiniEXR
	{
		public static void MiniEXRWrite(string _filePath, uint _width, uint _height, uint _channels, float[] _rgbaArray)
		{
			File.WriteAllBytes(_filePath, MiniEXRWrite(_width, _height, _channels, _rgbaArray));
		}

		public static void MiniEXRWrite(string _filePath, uint _width, uint _height, UnityEngine.Color[] _colorArray)
		{
			File.WriteAllBytes(_filePath, MiniEXRWrite(_width, _height, _colorArray));
		}

		public static byte[] MiniEXRWrite(uint _width, uint _height, UnityEngine.Color[] _colorArray)
		{
			float[] array = new float[_colorArray.Length * 3];
			for (int i = 0; i < _colorArray.Length; i++)
			{
				array[i * 3] = _colorArray[i].r;
				array[i * 3 + 1] = _colorArray[i].g;
				array[i * 3 + 2] = _colorArray[i].b;
			}
			return MiniEXRWrite(_width, _height, 3u, array);
		}

		public static byte[] MiniEXRWrite(uint _width, uint _height, uint _channels, float[] _rgbaArray)
		{
			uint num = _width - 1;
			uint num2 = _height - 1;
			byte[] obj = new byte[313]
			{
				118, 47, 49, 1, 2, 0, 0, 0, 99, 104,
				97, 110, 110, 101, 108, 115, 0, 99, 104, 108,
				105, 115, 116, 0, 55, 0, 0, 0, 66, 0,
				1, 0, 0, 0, 0, 0, 0, 0, 1, 0,
				0, 0, 1, 0, 0, 0, 71, 0, 1, 0,
				0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
				1, 0, 0, 0, 82, 0, 1, 0, 0, 0,
				0, 0, 0, 0, 1, 0, 0, 0, 1, 0,
				0, 0, 0, 99, 111, 109, 112, 114, 101, 115,
				115, 105, 111, 110, 0, 99, 111, 109, 112, 114,
				101, 115, 115, 105, 111, 110, 0, 1, 0, 0,
				0, 0, 100, 97, 116, 97, 87, 105, 110, 100,
				111, 119, 0, 98, 111, 120, 50, 105, 0, 16,
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0, 0, 100,
				105, 115, 112, 108, 97, 121, 87, 105, 110, 100,
				111, 119, 0, 98, 111, 120, 50, 105, 0, 16,
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0, 0, 108,
				105, 110, 101, 79, 114, 100, 101, 114, 0, 108,
				105, 110, 101, 79, 114, 100, 101, 114, 0, 1,
				0, 0, 0, 0, 112, 105, 120, 101, 108, 65,
				115, 112, 101, 99, 116, 82, 97, 116, 105, 111,
				0, 102, 108, 111, 97, 116, 0, 4, 0, 0,
				0, 0, 0, 128, 63, 115, 99, 114, 101, 101,
				110, 87, 105, 110, 100, 111, 119, 67, 101, 110,
				116, 101, 114, 0, 118, 50, 102, 0, 8, 0,
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				115, 99, 114, 101, 101, 110, 87, 105, 110, 100,
				111, 119, 87, 105, 100, 116, 104, 0, 102, 108,
				111, 97, 116, 0, 4, 0, 0, 0, 0, 0,
				128, 63, 0
			};
			obj[141] = (byte)(num & 0xFFu);
			obj[142] = (byte)((num >> 8) & 0xFFu);
			obj[143] = (byte)((num >> 16) & 0xFFu);
			obj[144] = (byte)((num >> 24) & 0xFFu);
			obj[145] = (byte)(num2 & 0xFFu);
			obj[146] = (byte)((num2 >> 8) & 0xFFu);
			obj[147] = (byte)((num2 >> 16) & 0xFFu);
			obj[148] = (byte)((num2 >> 24) & 0xFFu);
			obj[181] = (byte)(num & 0xFFu);
			obj[182] = (byte)((num >> 8) & 0xFFu);
			obj[183] = (byte)((num >> 16) & 0xFFu);
			obj[184] = (byte)((num >> 24) & 0xFFu);
			obj[185] = (byte)(num2 & 0xFFu);
			obj[186] = (byte)((num2 >> 8) & 0xFFu);
			obj[187] = (byte)((num2 >> 16) & 0xFFu);
			obj[188] = (byte)((num2 >> 24) & 0xFFu);
			byte[] array = obj;
			uint num3 = (uint)array.Length;
			uint num4 = 8 * _height;
			uint num5 = _width * 3 * 2;
			uint num6 = num5 + 8;
			byte[] array2 = new byte[num3 + num4 + _height * num6];
			int num7 = 0;
			for (int i = 0; i < num3; i++)
			{
				array2[num7] = array[i];
				num7++;
			}
			uint num8 = num3 + num4;
			for (int j = 0; j < _height; j++)
			{
				array2[num7++] = (byte)(num8 & 0xFFu);
				array2[num7++] = (byte)((num8 >> 8) & 0xFFu);
				array2[num7++] = (byte)((num8 >> 16) & 0xFFu);
				array2[num7++] = (byte)((num8 >> 24) & 0xFFu);
				array2[num7++] = 0;
				array2[num7++] = 0;
				array2[num7++] = 0;
				array2[num7++] = 0;
				num8 += num6;
			}
			ushort[] array3 = new ushort[_rgbaArray.Length];
			for (int k = 0; k < _rgbaArray.Length; k++)
			{
				_rgbaArray[k] = Mathf.Pow(_rgbaArray[k], 2.2f);
				array3[k] = HalfHelper.SingleToHalf(_rgbaArray[k]);
			}
			uint num9 = 0u;
			for (int l = 0; l < _height; l++)
			{
				array2[num7++] = (byte)((uint)l & 0xFFu);
				array2[num7++] = (byte)((uint)(l >> 8) & 0xFFu);
				array2[num7++] = (byte)((uint)(l >> 16) & 0xFFu);
				array2[num7++] = (byte)((uint)(l >> 24) & 0xFFu);
				array2[num7++] = (byte)(num5 & 0xFFu);
				array2[num7++] = (byte)((num5 >> 8) & 0xFFu);
				array2[num7++] = (byte)((num5 >> 16) & 0xFFu);
				array2[num7++] = (byte)((num5 >> 24) & 0xFFu);
				uint num10 = num9;
				for (int m = 0; m < _width; m++)
				{
					byte[] bytes = BitConverter.GetBytes(array3[num10 + 2]);
					array2[num7++] = bytes[0];
					array2[num7++] = bytes[1];
					num10 += _channels;
				}
				num10 = num9;
				for (int n = 0; n < _width; n++)
				{
					byte[] bytes2 = BitConverter.GetBytes(array3[num10 + 1]);
					array2[num7++] = bytes2[0];
					array2[num7++] = bytes2[1];
					num10 += _channels;
				}
				num10 = num9;
				for (int num11 = 0; num11 < _width; num11++)
				{
					byte[] bytes3 = BitConverter.GetBytes(array3[num10]);
					array2[num7++] = bytes3[0];
					array2[num7++] = bytes3[1];
					num10 += _channels;
				}
				num9 += _width * _channels;
			}
			return array2;
		}
	}
}
namespace IESLights
{
	[RequireComponent(typeof(IESToCubemap))]
	[RequireComponent(typeof(IESToSpotlightCookie))]
	public class IESConverter : MonoBehaviour
	{
		public int Resolution = 512;

		public NormalizationMode NormalizationMode;

		private Texture2D _iesTexture;

		public void ConvertIES(string filePath, string targetPath, bool createSpotlightCookies, bool rawImport, bool applyVignette, out Cubemap pointLightCookie, out Texture2D spotlightCookie, out EXRData exrData, out string targetFilename)
		{
			IESData iESData = ParseIES.Parse(filePath, (!rawImport) ? NormalizationMode : NormalizationMode.Linear);
			_iesTexture = IESToTexture.ConvertIesData(iESData);
			if (!rawImport)
			{
				exrData = default(EXRData);
				RegularImport(filePath, targetPath, createSpotlightCookies, applyVignette, out pointLightCookie, out spotlightCookie, out targetFilename, iESData);
			}
			else
			{
				pointLightCookie = null;
				spotlightCookie = null;
				RawImport(iESData, filePath, targetPath, createSpotlightCookies, out exrData, out targetFilename);
			}
			if (_iesTexture != null)
			{
				UnityEngine.Object.Destroy(_iesTexture);
			}
		}

		private void RegularImport(string filePath, string targetPath, bool createSpotlightCookies, bool applyVignette, out Cubemap pointLightCookie, out Texture2D spotlightCookie, out string targetFilename, IESData iesData)
		{
			if ((createSpotlightCookies && iesData.VerticalType != 0) || iesData.PhotometricType == PhotometricType.TypeA)
			{
				pointLightCookie = null;
				GetComponent<IESToSpotlightCookie>().CreateSpotlightCookie(_iesTexture, iesData, Resolution, applyVignette, flipVertically: false, out spotlightCookie);
			}
			else
			{
				spotlightCookie = null;
				GetComponent<IESToCubemap>().CreateCubemap(_iesTexture, iesData, Resolution, out pointLightCookie);
			}
			BuildTargetFilename(Path.GetFileNameWithoutExtension(filePath), targetPath, pointLightCookie != null, isRaw: false, NormalizationMode, iesData, out targetFilename);
		}

		private void RawImport(IESData iesData, string filePath, string targetPath, bool createSpotlightCookie, out EXRData exrData, out string targetFilename)
		{
			if ((createSpotlightCookie && iesData.VerticalType != 0) || iesData.PhotometricType == PhotometricType.TypeA)
			{
				Texture2D cookie = null;
				GetComponent<IESToSpotlightCookie>().CreateSpotlightCookie(_iesTexture, iesData, Resolution, applyVignette: false, flipVertically: true, out cookie);
				exrData = new EXRData(cookie.GetPixels(), Resolution, Resolution);
				UnityEngine.Object.DestroyImmediate(cookie);
			}
			else
			{
				exrData = new EXRData(GetComponent<IESToCubemap>().CreateRawCubemap(_iesTexture, iesData, Resolution), Resolution * 6, Resolution);
			}
			BuildTargetFilename(Path.GetFileNameWithoutExtension(filePath), targetPath, isCubemap: false, isRaw: true, NormalizationMode.Linear, iesData, out targetFilename);
		}

		private void BuildTargetFilename(string name, string folderHierarchy, bool isCubemap, bool isRaw, NormalizationMode normalizationMode, IESData iesData, out string targetFilePath)
		{
			if (!Directory.Exists(Path.Combine(Application.dataPath, $"IES/Imports/{folderHierarchy}")))
			{
				Directory.CreateDirectory(Path.Combine(Application.dataPath, $"IES/Imports/{folderHierarchy}"));
			}
			float num = 0f;
			if (iesData.PhotometricType == PhotometricType.TypeA)
			{
				num = iesData.HorizontalAngles.Max() - iesData.HorizontalAngles.Min();
			}
			string text = "";
			switch (normalizationMode)
			{
			case NormalizationMode.EqualizeHistogram:
				text = "[H] ";
				break;
			case NormalizationMode.Logarithmic:
				text = "[E] ";
				break;
			}
			string text2 = "";
			text2 = ((!isRaw) ? (isCubemap ? "cubemap" : "asset") : "exr");
			targetFilePath = Path.Combine(Path.Combine("Assets/IES/Imports/", folderHierarchy), string.Format("{0}{1}{2}.{3}", text, (iesData.PhotometricType == PhotometricType.TypeA) ? ("[FOV " + num + "] ") : "", name, text2));
			if (File.Exists(targetFilePath))
			{
				File.Delete(targetFilePath);
			}
		}
	}
	public class IESData
	{
		public List<float> VerticalAngles { get; set; }

		public List<float> HorizontalAngles { get; set; }

		public List<List<float>> CandelaValues { get; set; }

		public List<List<float>> NormalizedValues { get; set; }

		public PhotometricType PhotometricType { get; set; }

		public VerticalType VerticalType { get; set; }

		public HorizontalType HorizontalType { get; set; }

		public int PadBeforeAmount { get; set; }

		public int PadAfterAmount { get; set; }

		public float HalfSpotlightFov { get; set; }
	}
	public enum PhotometricType
	{
		TypeC = 1,
		TypeB,
		TypeA
	}
	public enum VerticalType
	{
		Full,
		Bottom,
		Top
	}
	public enum HorizontalType
	{
		Full,
		Half,
		Quadrant,
		None
	}
	public struct EXRData
	{
		public UnityEngine.Color[] Pixels;

		public uint Width;

		public uint Height;

		public EXRData(UnityEngine.Color[] pixels, int width, int height)
		{
			Pixels = pixels;
			Width = (uint)width;
			Height = (uint)height;
		}
	}
	[ExecuteInEditMode]
	public class IESToCubemap : MonoBehaviour
	{
		private Material _iesMaterial;

		private Material _horizontalMirrorMaterial;

		private void OnDestroy()
		{
			if (_horizontalMirrorMaterial != null)
			{
				UnityEngine.Object.DestroyImmediate(_horizontalMirrorMaterial);
			}
		}

		public void CreateCubemap(Texture2D iesTexture, IESData iesData, int resolution, out Cubemap cubemap)
		{
			PrepMaterial(iesTexture, iesData);
			CreateCubemap(resolution, out cubemap);
		}

		public UnityEngine.Color[] CreateRawCubemap(Texture2D iesTexture, IESData iesData, int resolution)
		{
			PrepMaterial(iesTexture, iesData);
			RenderTexture[] array = new RenderTexture[6];
			for (int i = 0; i < 6; i++)
			{
				array[i] = RenderTexture.GetTemporary(resolution, resolution, 0, RenderTextureFormat.ARGBFloat, RenderTextureReadWrite.Linear);
				array[i].filterMode = FilterMode.Trilinear;
			}
			Camera[] componentsInChildren = base.transform.GetChild(0).GetComponentsInChildren<Camera>();
			for (int j = 0; j < 6; j++)
			{
				componentsInChildren[j].targetTexture = array[j];
				componentsInChildren[j].Render();
				componentsInChildren[j].targetTexture = null;
			}
			RenderTexture temporary = RenderTexture.GetTemporary(resolution * 6, resolution, 0, RenderTextureFormat.ARGBFloat, RenderTextureReadWrite.Linear);
			temporary.filterMode = FilterMode.Trilinear;
			if (_horizontalMirrorMaterial == null)
			{
				_horizontalMirrorMaterial = new Material(Shader.Find("Hidden/IES/HorizontalFlip"));
			}
			RenderTexture.active = temporary;
			for (int k = 0; k < 6; k++)
			{
				GL.PushMatrix();
				GL.LoadPixelMatrix(0f, resolution * 6, 0f, resolution);
				Graphics.DrawTexture(new Rect(k * resolution, 0f, resolution, resolution), array[k], _horizontalMirrorMaterial);
				GL.PopMatrix();
			}
			Texture2D texture2D = new Texture2D(resolution * 6, resolution, TextureFormat.RGBAFloat, mipChain: false, linear: true)
			{
				filterMode = FilterMode.Trilinear
			};
			texture2D.ReadPixels(new Rect(0f, 0f, texture2D.width, texture2D.height), 0, 0);
			UnityEngine.Color[] pixels = texture2D.GetPixels();
			RenderTexture.active = null;
			RenderTexture[] array2 = array;
			for (int l = 0; l < array2.Length; l++)
			{
				RenderTexture.ReleaseTemporary(array2[l]);
			}
			RenderTexture.ReleaseTemporary(temporary);
			UnityEngine.Object.DestroyImmediate(texture2D);
			return pixels;
		}

		private void PrepMaterial(Texture2D iesTexture, IESData iesData)
		{
			if (_iesMaterial == null)
			{
				_iesMaterial = GetComponent<Renderer>().sharedMaterial;
			}
			_iesMaterial.mainTexture = iesTexture;
			SetShaderKeywords(iesData, _iesMaterial);
		}

		private void SetShaderKeywords(IESData iesData, Material iesMaterial)
		{
			if (iesData.VerticalType == VerticalType.Bottom)
			{
				iesMaterial.EnableKeyword("BOTTOM_VERTICAL");
				iesMaterial.DisableKeyword("TOP_VERTICAL");
				iesMaterial.DisableKeyword("FULL_VERTICAL");
			}
			else if (iesData.VerticalType == VerticalType.Top)
			{
				iesMaterial.EnableKeyword("TOP_VERTICAL");
				iesMaterial.DisableKeyword("BOTTOM_VERTICAL");
				iesMaterial.DisableKeyword("FULL_VERTICAL");
			}
			else
			{
				iesMaterial.DisableKeyword("TOP_VERTICAL");
				iesMaterial.DisableKeyword("BOTTOM_VERTICAL");
				iesMaterial.EnableKeyword("FULL_VERTICAL");
			}
			if (iesData.HorizontalType == HorizontalType.None)
			{
				iesMaterial.DisableKeyword("QUAD_HORIZONTAL");
				iesMaterial.DisableKeyword("HALF_HORIZONTAL");
				iesMaterial.DisableKeyword("FULL_HORIZONTAL");
			}
			else if (iesData.HorizontalType == HorizontalType.Quadrant)
			{
				iesMaterial.EnableKeyword("QUAD_HORIZONTAL");
				iesMaterial.DisableKeyword("HALF_HORIZONTAL");
				iesMaterial.DisableKeyword("FULL_HORIZONTAL");
			}
			else if (iesData.HorizontalType == HorizontalType.Half)
			{
				iesMaterial.DisableKeyword("QUAD_HORIZONTAL");
				iesMaterial.EnableKeyword("HALF_HORIZONTAL");
				iesMaterial.DisableKeyword("FULL_HORIZONTAL");
			}
			else if (iesData.HorizontalType == HorizontalType.Full)
			{
				iesMaterial.DisableKeyword("QUAD_HORIZONTAL");
				iesMaterial.DisableKeyword("HALF_HORIZONTAL");
				iesMaterial.EnableKeyword("FULL_HORIZONTAL");
			}
		}

		private void CreateCubemap(int resolution, out Cubemap cubemap)
		{
			cubemap = new Cubemap(resolution, TextureFormat.ARGB32, mipChain: false)
			{
				filterMode = FilterMode.Trilinear
			};
			GetComponent<Camera>().RenderToCubemap(cubemap);
		}
	}
	[ExecuteInEditMode]
	public class IESToSpotlightCookie : MonoBehaviour
	{
		private Material _spotlightMaterial;

		private Material _fadeSpotlightEdgesMaterial;

		private Material _verticalFlipMaterial;

		private void OnDestroy()
		{
			if (_spotlightMaterial != null)
			{
				UnityEngine.Object.Destroy(_spotlightMaterial);
			}
			if (_fadeSpotlightEdgesMaterial != null)
			{
				UnityEngine.Object.Destroy(_fadeSpotlightEdgesMaterial);
			}
			if (_verticalFlipMaterial != null)
			{
				UnityEngine.Object.Destroy(_verticalFlipMaterial);
			}
		}

		public void CreateSpotlightCookie(Texture2D iesTexture, IESData iesData, int resolution, bool applyVignette, bool flipVertically, out Texture2D cookie)
		{
			if (iesData.PhotometricType != PhotometricType.TypeA)
			{
				if (_spotlightMaterial == null)
				{
					_spotlightMaterial = new Material(Shader.Find("Hidden/IES/IESToSpotlightCookie"));
				}
				CalculateAndSetSpotHeight(iesData);
				SetShaderKeywords(iesData, applyVignette);
				cookie = CreateTexture(iesTexture, resolution, flipVertically);
			}
			else
			{
				if (_fadeSpotlightEdgesMaterial == null)
				{
					_fadeSpotlightEdgesMaterial = new Material(Shader.Find("Hidden/IES/FadeSpotlightCookieEdges"));
				}
				float verticalCenter = (applyVignette ? CalculateCookieVerticalCenter(iesData) : 0f);
				Vector2 vector = (applyVignette ? CalculateCookieFadeEllipse(iesData) : Vector2.zero);
				cookie = BlitToTargetSize(iesTexture, resolution, vector.x, vector.y, verticalCenter, applyVignette, flipVertically);
			}
		}

		private float CalculateCookieVerticalCenter(IESData iesData)
		{
			float num = 1f - (float)iesData.PadBeforeAmount / (float)iesData.NormalizedValues[0].Count;
			float num2 = (float)(iesData.NormalizedValues[0].Count - iesData.PadBeforeAmount - iesData.PadAfterAmount) / (float)iesData.NormalizedValues.Count / 2f;
			return num - num2;
		}

		private Vector2 CalculateCookieFadeEllipse(IESData iesData)
		{
			if (iesData.HorizontalAngles.Count > iesData.VerticalAngles.Count)
			{
				return new Vector2(0.5f, 0.5f * ((float)(iesData.NormalizedValues[0].Count - iesData.PadBeforeAmount - iesData.PadAfterAmount) / (float)iesData.NormalizedValues[0].Count));
			}
			if (iesData.HorizontalAngles.Count < iesData.VerticalAngles.Count)
			{
				return new Vector2(0.5f * (iesData.HorizontalAngles.Max() - iesData.HorizontalAngles.Min()) / (iesData.VerticalAngles.Max() - iesData.VerticalAngles.Min()), 0.5f);
			}
			return new Vector2(0.5f, 0.5f);
		}

		private Texture2D CreateTexture(Texture2D iesTexture, int resolution, bool flipVertically)
		{
			RenderTexture temporary = RenderTexture.GetTemporary(resolution, resolution, 0, RenderTextureFormat.ARGBFloat, RenderTextureReadWrite.Linear);
			temporary.filterMode = FilterMode.Trilinear;
			temporary.DiscardContents();
			RenderTexture.active = temporary;
			Graphics.Blit(iesTexture, _spotlightMaterial);
			if (flipVertically)
			{
				RenderTexture temporary2 = RenderTexture.GetTemporary(resolution, resolution, 0, RenderTextureFormat.ARGBFloat, RenderTextureReadWrite.Linear);
				Graphics.Blit(temporary, temporary2);
				FlipVertically(temporary2, temporary);
				RenderTexture.ReleaseTemporary(temporary2);
			}
			Texture2D texture2D = new Texture2D(resolution, resolution, TextureFormat.RGBAFloat, mipChain: false, linear: true);
			texture2D.filterMode = FilterMode.Trilinear;
			texture2D.wrapMode = TextureWrapMode.Clamp;
			texture2D.ReadPixels(new Rect(0f, 0f, resolution, resolution), 0, 0);
			texture2D.Apply();
			RenderTexture.active = null;
			RenderTexture.ReleaseTemporary(temporary);
			return texture2D;
		}

		private Texture2D BlitToTargetSize(Texture2D iesTexture, int resolution, float horizontalFadeDistance, float verticalFadeDistance, float verticalCenter, bool applyVignette, bool flipVertically)
		{
			if (applyVignette)
			{
				_fadeSpotlightEdgesMaterial.SetFloat("_HorizontalFadeDistance", horizontalFadeDistance);
				_fadeSpotlightEdgesMaterial.SetFloat("_VerticalFadeDistance", verticalFadeDistance);
				_fadeSpotlightEdgesMaterial.SetFloat("_VerticalCenter", verticalCenter);
			}
			RenderTexture temporary = RenderTexture.GetTemporary(resolution, resolution, 0, RenderTextureFormat.ARGBFloat, RenderTextureReadWrite.Linear);
			temporary.filterMode = FilterMode.Trilinear;
			temporary.DiscardContents();
			if (applyVignette)
			{
				RenderTexture.active = temporary;
				Graphics.Blit(iesTexture, _fadeSpotlightEdgesMaterial);
			}
			else if (flipVertically)
			{
				FlipVertically(iesTexture, temporary);
			}
			else
			{
				Graphics.Blit(iesTexture, temporary);
			}
			Texture2D texture2D = new Texture2D(resolution, resolution, TextureFormat.RGBAFloat, mipChain: false, linear: true);
			texture2D.filterMode = FilterMode.Trilinear;
			texture2D.wrapMode = TextureWrapMode.Clamp;
			texture2D.ReadPixels(new Rect(0f, 0f, resolution, resolution), 0, 0);
			texture2D.Apply();
			RenderTexture.active = null;
			RenderTexture.ReleaseTemporary(temporary);
			return texture2D;
		}

		private void FlipVertically(Texture iesTexture, RenderTexture renderTarget)
		{
			if (_verticalFlipMaterial == null)
			{
				_verticalFlipMaterial = new Material(Shader.Find("Hidden/IES/VerticalFlip"));
			}
			Graphics.Blit(iesTexture, renderTarget, _verticalFlipMaterial);
		}

		private void CalculateAndSetSpotHeight(IESData iesData)
		{
			float value = 0.5f / Mathf.Tan(iesData.HalfSpotlightFov * ((float)Math.PI / 180f));
			_spotlightMaterial.SetFloat("_SpotHeight", value);
		}

		private void SetShaderKeywords(IESData iesData, bool applyVignette)
		{
			if (applyVignette)
			{
				_spotlightMaterial.EnableKeyword("VIGNETTE");
			}
			else
			{
				_spotlightMaterial.DisableKeyword("VIGNETTE");
			}
			if (iesData.VerticalType == VerticalType.Top)
			{
				_spotlightMaterial.EnableKeyword("TOP_VERTICAL");
			}
			else
			{
				_spotlightMaterial.DisableKeyword("TOP_VERTICAL");
			}
			if (iesData.HorizontalType == HorizontalType.None)
			{
				_spotlightMaterial.DisableKeyword("QUAD_HORIZONTAL");
				_spotlightMaterial.DisableKeyword("HALF_HORIZONTAL");
				_spotlightMaterial.DisableKeyword("FULL_HORIZONTAL");
			}
			else if (iesData.HorizontalType == HorizontalType.Quadrant)
			{
				_spotlightMaterial.EnableKeyword("QUAD_HORIZONTAL");
				_spotlightMaterial.DisableKeyword("HALF_HORIZONTAL");
				_spotlightMaterial.DisableKeyword("FULL_HORIZONTAL");
			}
			else if (iesData.HorizontalType == HorizontalType.Half)
			{
				_spotlightMaterial.DisableKeyword("QUAD_HORIZONTAL");
				_spotlightMaterial.EnableKeyword("HALF_HORIZONTAL");
				_spotlightMaterial.DisableKeyword("FULL_HORIZONTAL");
			}
			else if (iesData.HorizontalType == HorizontalType.Full)
			{
				_spotlightMaterial.DisableKeyword("QUAD_HORIZONTAL");
				_spotlightMaterial.DisableKeyword("HALF_HORIZONTAL");
				_spotlightMaterial.EnableKeyword("FULL_HORIZONTAL");
			}
		}
	}
	public class IESToTexture : MonoBehaviour
	{
		public static Texture2D ConvertIesData(IESData data)
		{
			Texture2D texture2D = new Texture2D(data.NormalizedValues.Count, data.NormalizedValues[0].Count, TextureFormat.RGBAFloat, mipChain: false, linear: true)
			{
				filterMode = FilterMode.Trilinear,
				wrapMode = TextureWrapMode.Clamp
			};
			UnityEngine.Color[] array = new UnityEngine.Color[texture2D.width * texture2D.height];
			for (int i = 0; i < texture2D.width; i++)
			{
				for (int j = 0; j < texture2D.height; j++)
				{
					float num = data.NormalizedValues[i][j];
					array[i + j * texture2D.width] = new UnityEngine.Color(num, num, num, num);
				}
			}
			texture2D.SetPixels(array);
			texture2D.Apply();
			return texture2D;
		}
	}
	public static class ParseIES
	{
		private const float SpotlightCutoff = 0.1f;

		public static IESData Parse(string path, NormalizationMode normalizationMode)
		{
			string[] array = File.ReadAllLines(path);
			int lineNumber = 0;
			FindNumberOfAnglesLine(array, ref lineNumber);
			if (lineNumber == array.Length - 1)
			{
				throw new IESParseException("No line containing number of angles found.");
			}
			ReadProperties(array, ref lineNumber, out var numberOfVerticalAngles, out var numberOfHorizontalAngles, out var photometricType);
			List<float> verticalAngles = ReadValues(array, numberOfVerticalAngles, ref lineNumber);
			List<float> horizontalAngles = ReadValues(array, numberOfHorizontalAngles, ref lineNumber);
			List<List<float>> list = new List<List<float>>();
			for (int i = 0; i < numberOfHorizontalAngles; i++)
			{
				list.Add(ReadValues(array, numberOfVerticalAngles, ref lineNumber));
			}
			IESData iESData = new IESData
			{
				VerticalAngles = verticalAngles,
				HorizontalAngles = horizontalAngles,
				CandelaValues = list,
				PhotometricType = photometricType
			};
			NormalizeValues(iESData, normalizationMode == NormalizationMode.Logarithmic);
			if (normalizationMode == NormalizationMode.EqualizeHistogram)
			{
				EqualizeHistogram(iESData);
			}
			if (photometricType != PhotometricType.TypeA)
			{
				DiscardUnusedVerticalHalf(iESData);
				SetVerticalAndHorizontalType(iESData);
				iESData.HalfSpotlightFov = CalculateHalfSpotFov(iESData);
			}
			else
			{
				PadToSquare(iESData);
			}
			return iESData;
		}

		private static void DiscardUnusedVerticalHalf(IESData iesData)
		{
			if (iesData.VerticalAngles[0] != 0f || iesData.VerticalAngles[iesData.VerticalAngles.Count - 1] != 180f)
			{
				return;
			}
			int j;
			for (j = 0; j < iesData.VerticalAngles.Count && !iesData.NormalizedValues.Any((List<float> slice) => slice[j] > 0.1f); j++)
			{
				if (iesData.VerticalAngles[j] == 90f)
				{
					DiscardBottomHalf(iesData);
					return;
				}
				if (iesData.VerticalAngles[j] > 90f)
				{
					iesData.VerticalAngles[j] = 90f;
					DiscardBottomHalf(iesData);
					return;
				}
			}
			int i;
			for (i = iesData.VerticalAngles.Count - 1; i >= 0 && !iesData.NormalizedValues.Any((List<float> slice) => slice[i] > 0.1f); i--)
			{
				if (iesData.VerticalAngles[i] == 90f)
				{
					DiscardTopHalf(iesData);
					break;
				}
				if (iesData.VerticalAngles[i] < 90f)
				{
					iesData.VerticalAngles[i] = 90f;
					DiscardTopHalf(iesData);
					break;
				}
			}
		}

		private static void DiscardBottomHalf(IESData iesData)
		{
			int num = 0;
			for (int i = 0; i < iesData.VerticalAngles.Count && iesData.VerticalAngles[i] != 90f; i++)
			{
				num++;
			}
			DiscardHalf(iesData, 0, num);
		}

		private static void DiscardTopHalf(IESData iesData)
		{
			int num = 0;
			for (int i = 0; i < iesData.VerticalAngles.Count; i++)
			{
				if (iesData.VerticalAngles[i] == 90f)
				{
					num = i + 1;
					break;
				}
			}
			int range = iesData.VerticalAngles.Count - num;
			DiscardHalf(iesData, num, range);
		}

		private static void DiscardHalf(IESData iesData, int start, int range)
		{
			iesData.VerticalAngles.RemoveRange(start, range);
			for (int i = 0; i < iesData.CandelaValues.Count; i++)
			{
				iesData.CandelaValues[i].RemoveRange(start, range);
				iesData.NormalizedValues[i].RemoveRange(start, range);
			}
		}

		private static void PadToSquare(IESData iesData)
		{
			if (Mathf.Abs(iesData.HorizontalAngles.Count - iesData.VerticalAngles.Count) > 1)
			{
				int num = Mathf.Max(iesData.HorizontalAngles.Count, iesData.VerticalAngles.Count);
				if (iesData.HorizontalAngles.Count < num)
				{
					PadHorizontal(iesData, num);
				}
				else
				{
					PadVertical(iesData, num);
				}
			}
		}

		private static void PadHorizontal(IESData iesData, int longestSide)
		{
			int num = longestSide - iesData.HorizontalAngles.Count;
			int num2 = num / 2;
			int padBeforeAmount = (iesData.PadAfterAmount = num2);
			iesData.PadBeforeAmount = padBeforeAmount;
			List<float> item = Enumerable.Repeat(0f, iesData.VerticalAngles.Count).ToList();
			for (int i = 0; i < num2; i++)
			{
				iesData.NormalizedValues.Insert(0, item);
			}
			for (int j = 0; j < num - num2; j++)
			{
				iesData.NormalizedValues.Add(item);
			}
		}

		private static void PadVertical(IESData iesData, int longestSide)
		{
			int num = longestSide - iesData.VerticalAngles.Count;
			if (Mathf.Sign(iesData.VerticalAngles[0]) == (float)Math.Sign(iesData.VerticalAngles[iesData.VerticalAngles.Count - 1]))
			{
				int num3 = (iesData.PadBeforeAmount = num / 2);
				iesData.PadAfterAmount = num - num3;
				{
					foreach (List<float> normalizedValue in iesData.NormalizedValues)
					{
						normalizedValue.InsertRange(0, new List<float>(new float[num3]));
						normalizedValue.AddRange(new List<float>(new float[num - num3]));
					}
					return;
				}
			}
			int num4 = longestSide / 2 - iesData.VerticalAngles.Count((float v) => v >= 0f);
			if (iesData.VerticalAngles[0] < 0f)
			{
				iesData.PadBeforeAmount = num - num4;
				iesData.PadAfterAmount = num4;
				{
					foreach (List<float> normalizedValue2 in iesData.NormalizedValues)
					{
						normalizedValue2.InsertRange(0, new List<float>(new float[num - num4]));
						normalizedValue2.AddRange(new List<float>(new float[num4]));
					}
					return;
				}
			}
			iesData.PadBeforeAmount = num4;
			iesData.PadAfterAmount = num - num4;
			foreach (List<float> normalizedValue3 in iesData.NormalizedValues)
			{
				normalizedValue3.InsertRange(0, new List<float>(new float[num4]));
				normalizedValue3.AddRange(new List<float>(new float[num - num4]));
			}
		}

		private static void SetVerticalAndHorizontalType(IESData iesData)
		{
			if ((iesData.VerticalAngles[0] == 0f && iesData.VerticalAngles[iesData.VerticalAngles.Count - 1] == 90f) || (iesData.VerticalAngles[0] == -90f && iesData.VerticalAngles[iesData.VerticalAngles.Count - 1] == 0f))
			{
				iesData.VerticalType = VerticalType.Bottom;
			}
			else if (iesData.VerticalAngles[iesData.VerticalAngles.Count - 1] == 180f && iesData.VerticalAngles[0] == 90f)
			{
				iesData.VerticalType = VerticalType.Top;
			}
			else
			{
				iesData.VerticalType = VerticalType.Full;
			}
			if (iesData.HorizontalAngles.Count == 1)
			{
				iesData.HorizontalType = HorizontalType.None;
				return;
			}
			if (iesData.HorizontalAngles[iesData.HorizontalAngles.Count - 1] - iesData.HorizontalAngles[0] == 90f)
			{
				iesData.HorizontalType = HorizontalType.Quadrant;
				return;
			}
			if (iesData.HorizontalAngles[iesData.HorizontalAngles.Count - 1] - iesData.HorizontalAngles[0] == 180f)
			{
				iesData.HorizontalType = HorizontalType.Half;
				return;
			}
			iesData.HorizontalType = HorizontalType.Full;
			if (iesData.HorizontalAngles[iesData.HorizontalAngles.Count - 1] != 360f)
			{
				StitchHorizontalAssymetry(iesData);
			}
		}

		private static void StitchHorizontalAssymetry(IESData iesData)
		{
			iesData.HorizontalAngles.Add(360f);
			iesData.CandelaValues.Add(iesData.CandelaValues[0]);
			iesData.NormalizedValues.Add(iesData.NormalizedValues[0]);
		}

		private static float CalculateHalfSpotFov(IESData iesData)
		{
			if (iesData.VerticalType == VerticalType.Bottom && iesData.VerticalAngles[0] == 0f)
			{
				return CalculateHalfSpotlightFovForBottomHalf(iesData);
			}
			if (iesData.VerticalType == VerticalType.Top || (iesData.VerticalType == VerticalType.Bottom && iesData.VerticalAngles[0] == -90f))
			{
				return CalculateHalfSpotlightFovForTopHalf(iesData);
			}
			return -1f;
		}

		private static float CalculateHalfSpotlightFovForBottomHalf(IESData iesData)
		{
			for (int num = iesData.VerticalAngles.Count - 1; num >= 0; num--)
			{
				for (int i = 0; i < iesData.NormalizedValues.Count; i++)
				{
					if (iesData.NormalizedValues[i][num] >= 0.1f)
					{
						if (num < iesData.VerticalAngles.Count - 1)
						{
							return iesData.VerticalAngles[num + 1];
						}
						return iesData.VerticalAngles[num];
					}
				}
			}
			return 0f;
		}

		private static float CalculateHalfSpotlightFovForTopHalf(IESData iesData)
		{
			for (int i = 0; i < iesData.VerticalAngles.Count; i++)
			{
				for (int j = 0; j < iesData.NormalizedValues.Count; j++)
				{
					if (!(iesData.NormalizedValues[j][i] >= 0.1f))
					{
						continue;
					}
					if (iesData.VerticalType == VerticalType.Top)
					{
						if (i > 0)
						{
							return 180f - iesData.VerticalAngles[i - 1];
						}
						return 180f - iesData.VerticalAngles[i];
					}
					if (i > 0)
					{
						return 0f - iesData.VerticalAngles[i - 1];
					}
					return 0f - iesData.VerticalAngles[i];
				}
			}
			return 0f;
		}

		private static void NormalizeValues(IESData iesData, bool squashHistogram)
		{
			iesData.NormalizedValues = new List<List<float>>();
			float num = iesData.CandelaValues.SelectMany((List<float> v) => v).Max();
			if (squashHistogram)
			{
				num = Mathf.Log(num);
			}
			foreach (List<float> candelaValue in iesData.CandelaValues)
			{
				List<float> list = new List<float>();
				if (squashHistogram)
				{
					for (int i = 0; i < candelaValue.Count; i++)
					{
						list.Add(Mathf.Log(candelaValue[i]));
					}
				}
				else
				{
					list.AddRange(candelaValue);
				}
				for (int j = 0; j < candelaValue.Count; j++)
				{
					list[j] /= num;
					list[j] = Mathf.Clamp01(list[j]);
				}
				iesData.NormalizedValues.Add(list);
			}
		}

		private static void EqualizeHistogram(IESData iesData)
		{
			int num = Mathf.Min((int)iesData.CandelaValues.SelectMany((List<float> v) => v).Max(), 10000);
			float[] array = new float[num];
			float[] array2 = new float[num];
			foreach (List<float> normalizedValue in iesData.NormalizedValues)
			{
				foreach (float item in normalizedValue)
				{
					array[(int)(item * (float)(num - 1))] += 1f;
				}
			}
			float num2 = iesData.HorizontalAngles.Count * iesData.VerticalAngles.Count;
			for (int i = 0; i < array.Length; i++)
			{
				array[i] /= num2;
			}
			for (int j = 0; j < num; j++)
			{
				array2[j] = array.Take(j + 1).Sum();
			}
			foreach (List<float> normalizedValue2 in iesData.NormalizedValues)
			{
				for (int k = 0; k < normalizedValue2.Count; k++)
				{
					int num3 = (int)(normalizedValue2[k] * (float)(num - 1));
					normalizedValue2[k] = array2[num3] * (float)(num - 1) / (float)num;
				}
			}
		}

		private static void FindNumberOfAnglesLine(string[] lines, ref int lineNumber)
		{
			int i;
			for (i = 0; i < lines.Length; i++)
			{
				if (lines[i].Trim().StartsWith("TILT"))
				{
					try
					{
						i = ((!(lines[i].Split('=')[1].Trim() != "NONE")) ? (i + 1) : (i + 5));
					}
					catch (ArgumentOutOfRangeException)
					{
						throw new IESParseException("No TILT line present.");
					}
					break;
				}
			}
			lineNumber = i;
		}

		private static void ReadProperties(string[] lines, ref int lineNumber, out int numberOfVerticalAngles, out int numberOfHorizontalAngles, out PhotometricType photometricType)
		{
			List<float> list = ReadValues(lines, 13, ref lineNumber);
			numberOfVerticalAngles = (int)list[3];
			numberOfHorizontalAngles = (int)list[4];
			photometricType = (PhotometricType)list[5];
		}

		private static List<float> ReadValues(string[] lines, int numberOfValuesToFind, ref int lineNumber)
		{
			List<float> list = new List<float>();
			while (list.Count < numberOfValuesToFind)
			{
				if (lineNumber >= lines.Length)
				{
					throw new IESParseException("Reached end of file before the given number of values was read.");
				}
				char[] separator = null;
				if (lines[lineNumber].Contains(","))
				{
					separator = new char[1] { ',' };
				}
				string[] array = lines[lineNumber].Split(separator, StringSplitOptions.RemoveEmptyEntries);
				foreach (string s in array)
				{
					try
					{
						list.Add(float.Parse(s));
					}
					catch (Exception inner)
					{
						throw new IESParseException("Invalid value declaration.", inner);
					}
				}
				lineNumber++;
			}
			return list;
		}
	}
	public enum NormalizationMode
	{
		Linear,
		Logarithmic,
		EqualizeHistogram
	}
	[Serializable]
	public class IESParseException : Exception
	{
		public IESParseException()
		{
		}

		public IESParseException(string message)
			: base(message)
		{
		}

		public IESParseException(string message, Exception inner)
			: base(message, inner)
		{
		}

		protected IESParseException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
		}
	}
	public class RuntimeIESImporter : MonoBehaviour
	{
		public static void Import(string path, out Texture2D spotlightCookie, out Cubemap pointLightCookie, int resolution = 128, bool enhancedImport = false, bool applyVignette = true)
		{
			spotlightCookie = null;
			pointLightCookie = null;
			if (IsFileValid(path))
			{
				GetIESConverterAndCubeSphere(enhancedImport, resolution, out var cubemapSphere, out var iesConverter);
				ImportIES(path, iesConverter, allowSpotlightCookies: true, applyVignette, out spotlightCookie, out pointLightCookie);
				UnityEngine.Object.Destroy(cubemapSphere);
			}
		}

		public static Texture2D ImportSpotlightCookie(string path, int resolution = 128, bool enhancedImport = false, bool applyVignette = true)
		{
			if (!IsFileValid(path))
			{
				return null;
			}
			GetIESConverterAndCubeSphere(enhancedImport, resolution, out var cubemapSphere, out var iesConverter);
			ImportIES(path, iesConverter, allowSpotlightCookies: true, applyVignette, out var spotlightCookie, out var _);
			UnityEngine.Object.Destroy(cubemapSphere);
			return spotlightCookie;
		}

		public static Cubemap ImportPointLightCookie(string path, int resolution = 128, bool enhancedImport = false)
		{
			if (!IsFileValid(path))
			{
				return null;
			}
			GetIESConverterAndCubeSphere(enhancedImport, resolution, out var cubemapSphere, out var iesConverter);
			ImportIES(path, iesConverter, allowSpotlightCookies: false, applyVignette: false, out var _, out var pointlightCookie);
			UnityEngine.Object.Destroy(cubemapSphere);
			return pointlightCookie;
		}

		private static void GetIESConverterAndCubeSphere(bool logarithmicNormalization, int resolution, out GameObject cubemapSphere, out IESConverter iesConverter)
		{
			UnityEngine.Object original = Resources.Load("IES cubemap sphere");
			cubemapSphere = (GameObject)UnityEngine.Object.Instantiate(original);
			iesConverter = cubemapSphere.GetComponent<IESConverter>();
			iesConverter.NormalizationMode = (logarithmicNormalization ? NormalizationMode.Logarithmic : NormalizationMode.Linear);
			iesConverter.Resolution = resolution;
		}

		private static void ImportIES(string path, IESConverter iesConverter, bool allowSpotlightCookies, bool applyVignette, out Texture2D spotlightCookie, out Cubemap pointlightCookie)
		{
			string targetFilename = null;
			spotlightCookie = null;
			pointlightCookie = null;
			try
			{
				iesConverter.ConvertIES(path, "", allowSpotlightCookies, rawImport: false, applyVignette, out pointlightCookie, out spotlightCookie, out var _, out targetFilename);
			}
			catch (IESParseException ex)
			{
				UnityEngine.Debug.LogError($"[IES] Encountered invalid IES data in {path}. Error message: {ex.Message}");
			}
			catch (Exception ex2)
			{
				UnityEngine.Debug.LogError($"[IES] Error while parsing {path}. Please contact me through the forums or thomasmountainborn.com. Error message: {ex2.Message}");
			}
		}

		private static bool IsFileValid(string path)
		{
			if (!File.Exists(path))
			{
				UnityEngine.Debug.LogWarningFormat("[IES] The file \"{0}\" does not exist.", path);
				return false;
			}
			if (Path.GetExtension(path).ToLower() != ".ies")
			{
				UnityEngine.Debug.LogWarningFormat("[IES] The file \"{0}\" is not an IES file.", path);
				return false;
			}
			return true;
		}
	}
}
namespace UnityEngine.Timeline
{
	public class VideoPlayableBehaviour : PlayableBehaviour
	{
		public VideoPlayer videoPlayer;

		public VideoClip videoClip;

		public bool mute;

		public bool loop = true;

		public double preloadTime = 0.3;

		public double clipInTime;

		private bool playedOnce;

		private bool preparing;

		public void PrepareVideo()
		{
			if (videoPlayer == null || videoClip == null)
			{
				return;
			}
			videoPlayer.targetCameraAlpha = 0f;
			if (videoPlayer.clip != videoClip)
			{
				StopVideo();
			}
			if (videoPlayer.isPrepared || preparing)
			{
				return;
			}
			videoPlayer.source = VideoSource.VideoClip;
			videoPlayer.clip = videoClip;
			videoPlayer.playOnAwake = false;
			videoPlayer.waitForFirstFrame = true;
			videoPlayer.isLooping = loop;
			for (ushort num = 0; num < videoClip.audioTrackCount; num++)
			{
				if (videoPlayer.audioOutputMode == VideoAudioOutputMode.Direct)
				{
					videoPlayer.SetDirectAudioMute(num, mute || !Application.isPlaying);
				}
				else if (videoPlayer.audioOutputMode == VideoAudioOutputMode.AudioSource)
				{
					AudioSource targetAudioSource = videoPlayer.GetTargetAudioSource(num);
					if (targetAudioSource != null)
					{
						targetAudioSource.mute = mute || !Application.isPlaying;
					}
				}
			}
			videoPlayer.loopPointReached += LoopPointReached;
			videoPlayer.time = clipInTime;
			videoPlayer.Prepare();
			preparing = true;
		}

		private void LoopPointReached(VideoPlayer vp)
		{
			playedOnce = !loop;
		}

		public override void PrepareFrame(Playable playable, FrameData info)
		{
			if (!(videoPlayer == null) && !(videoClip == null))
			{
				videoPlayer.timeReference = (Application.isPlaying ? VideoTimeReference.ExternalTime : VideoTimeReference.Freerun);
				if (videoPlayer.isPlaying && Application.isPlaying)
				{
					videoPlayer.externalReferenceTime = playable.GetTime();
				}
				else if (!Application.isPlaying)
				{
					SyncVideoToPlayable(playable);
				}
			}
		}

		public override void OnBehaviourPlay(Playable playable, FrameData info)
		{
			if (!(videoPlayer == null) && !playedOnce)
			{
				PlayVideo();
				SyncVideoToPlayable(playable);
			}
		}

		public override void OnBehaviourPause(Playable playable, FrameData info)
		{
			if (!(videoPlayer == null))
			{
				if (Application.isPlaying)
				{
					PauseVideo();
				}
				else
				{
					StopVideo();
				}
			}
		}

		public override void ProcessFrame(Playable playable, FrameData info, object playerData)
		{
			if (videoPlayer == null || videoPlayer.clip == null)
			{
				return;
			}
			videoPlayer.targetCameraAlpha = info.weight;
			if (!Application.isPlaying)
			{
				return;
			}
			for (ushort num = 0; num < videoPlayer.clip.audioTrackCount; num++)
			{
				if (videoPlayer.audioOutputMode == VideoAudioOutputMode.Direct)
				{
					videoPlayer.SetDirectAudioVolume(num, info.weight);
				}
				else if (videoPlayer.audioOutputMode == VideoAudioOutputMode.AudioSource)
				{
					AudioSource targetAudioSource = videoPlayer.GetTargetAudioSource(num);
					if (targetAudioSource != null)
					{
						targetAudioSource.volume = info.weight;
					}
				}
			}
		}

		public override void OnGraphStart(Playable playable)
		{
			playedOnce = false;
		}

		public override void OnGraphStop(Playable playable)
		{
			if (!Application.isPlaying)
			{
				StopVideo();
			}
		}

		public override void OnPlayableDestroy(Playable playable)
		{
			StopVideo();
		}

		public void PlayVideo()
		{
			if (!(videoPlayer == null))
			{
				videoPlayer.Play();
				preparing = false;
				if (!Application.isPlaying)
				{
					PauseVideo();
				}
			}
		}

		public void PauseVideo()
		{
			if (!(videoPlayer == null))
			{
				videoPlayer.Pause();
				preparing = false;
			}
		}

		public void StopVideo()
		{
			if (!(videoPlayer == null))
			{
				playedOnce = false;
				videoPlayer.Stop();
				preparing = false;
			}
		}

		private void SyncVideoToPlayable(Playable playable)
		{
			if (!(videoPlayer == null) && !(videoPlayer.clip == null))
			{
				videoPlayer.time = (clipInTime + playable.GetTime() * (double)videoPlayer.playbackSpeed) % videoPlayer.clip.length;
			}
		}
	}
	public sealed class VideoSchedulerPlayableBehaviour : PlayableBehaviour
	{
		private IEnumerable<TimelineClip> m_Clips;

		private PlayableDirector m_Director;

		internal PlayableDirector director
		{
			get
			{
				return m_Director;
			}
			set
			{
				m_Director = value;
			}
		}

		internal IEnumerable<TimelineClip> clips
		{
			get
			{
				return m_Clips;
			}
			set
			{
				m_Clips = value;
			}
		}

		public override void ProcessFrame(Playable playable, FrameData info, object playerData)
		{
			if (m_Clips == null)
			{
				return;
			}
			int num = 0;
			foreach (TimelineClip clip in m_Clips)
			{
				VideoPlayableBehaviour behaviour = ((ScriptPlayable<VideoPlayableBehaviour>)playable.GetInput(num)).GetBehaviour();
				if (behaviour != null)
				{
					double num2 = Math.Max(0.0, behaviour.preloadTime);
					if (m_Director.time >= clip.start + clip.duration || m_Director.time <= clip.start - num2)
					{
						behaviour.StopVideo();
					}
					else if (m_Director.time > clip.start - num2)
					{
						behaviour.PrepareVideo();
					}
				}
				num++;
			}
		}
	}
	[Serializable]
	public class VideoScriptPlayableAsset : PlayableAsset
	{
		public ExposedReference<VideoPlayer> videoPlayer;

		[SerializeField]
		[NotKeyable]
		public VideoClip videoClip;

		[SerializeField]
		[NotKeyable]
		public bool mute;

		[SerializeField]
		[NotKeyable]
		public bool loop = true;

		[SerializeField]
		[NotKeyable]
		public double preloadTime = 0.3;

		[SerializeField]
		[NotKeyable]
		public double clipInTime;

		public override Playable CreatePlayable(PlayableGraph graph, GameObject go)
		{
			ScriptPlayable<VideoPlayableBehaviour> scriptPlayable = ScriptPlayable<VideoPlayableBehaviour>.Create(graph);
			VideoPlayableBehaviour behaviour = scriptPlayable.GetBehaviour();
			behaviour.videoPlayer = videoPlayer.Resolve(graph.GetResolver());
			behaviour.videoClip = videoClip;
			behaviour.mute = mute;
			behaviour.loop = loop;
			behaviour.preloadTime = preloadTime;
			behaviour.clipInTime = clipInTime;
			return scriptPlayable;
		}
	}
	[Serializable]
	[TrackClipType(typeof(VideoScriptPlayableAsset))]
	[TrackMediaType(TimelineAsset.MediaType.Script)]
	[TrackColor(0.008f, 0.698f, 0.655f)]
	public class VideoScriptPlayableTrack : TrackAsset
	{
		public override Playable CreateTrackMixer(PlayableGraph graph, GameObject go, int inputCount)
		{
			PlayableDirector component = go.GetComponent<PlayableDirector>();
			ScriptPlayable<VideoSchedulerPlayableBehaviour> scriptPlayable = ScriptPlayable<VideoSchedulerPlayableBehaviour>.Create(graph, inputCount);
			VideoSchedulerPlayableBehaviour behaviour = scriptPlayable.GetBehaviour();
			if (behaviour != null)
			{
				behaviour.director = component;
				behaviour.clips = GetClips();
			}
			return scriptPlayable;
		}
	}
}
namespace Subtitles
{
	[Serializable]
	public struct DialogueLineJSON
	{
		public string text;

		public float duration;
	}
	[Serializable]
	public class LanguageJSON
	{
		public string language;

		public DialogueLineJSON[] lines;

		[NonSerialized]
		private SubtitleLanguage subLan;

		public SubtitleLanguage Language
		{
			get
			{
				if (subLan == SubtitleLanguage.OFF)
				{
					if (!Enum.IsDefined(typeof(SubtitleLanguage), language))
					{
						UnityEngine.Debug.LogError("Please add language [" + language + "] to the SubtitleLanguage enum.");
						return SubtitleLanguage.OFF;
					}
					return (SubtitleLanguage)Enum.Parse(typeof(SubtitleLanguage), language);
				}
				return subLan;
			}
		}
	}
	[Serializable]
	public class DialogueJSON
	{
		public string clipID;

		public float initalDelay;

		public LanguageJSON[] languages;
	}
	[Serializable]
	public class SubsContainerJSON
	{
		public DialogueJSON[] container;
	}
	[Serializable]
	public class SubtitleManager
	{
		public SubsContainerJSON subtitles;

		private static SubtitleManager instance;

		private SCENES currentSubsScene;

		public SCENES CurrentSubsScene => currentSubsScene;

		public static SubtitleManager Instance
		{
			get
			{
				if (instance == null)
				{
					instance = new SubtitleManager();
				}
				return instance;
			}
		}

		public void InitForScene(SCENES scene)
		{
			currentSubsScene = scene;
			string text = scene.ToString();
			if (text.Contains("Combine"))
			{
				text = text.Substring(0, text.IndexOf("Combine"));
			}
			string text2 = "Scene_" + scene;
			try
			{
				TextAsset textAsset = Resources.Load(text2) as TextAsset;
				if (textAsset.text.Length > 0)
				{
					subtitles = (SubsContainerJSON)JsonUtility.FromJson(textAsset.text, typeof(SubsContainerJSON));
				}
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogError("Error in " + text2 + " with message: " + ex.Message);
			}
		}

		public LanguageJSON GetDialogue(string clipName, out float delay, SubtitleLanguage lan)
		{
			if (subtitles == null)
			{
				UnityEngine.Debug.LogError("Subtitles not loaded for scene");
			}
			DialogueJSON dialogueJSON = Array.Find(subtitles.container, (DialogueJSON e) => e.clipID == clipName);
			if (dialogueJSON == null)
			{
				throw new ArgumentNullException("Can't find matching subtitle entry for audioclip [" + clipName + "] please add this to the subs file to play subtitles!");
			}
			LanguageJSON languageJSON = Array.Find(dialogueJSON.languages, (LanguageJSON e) => e.Language == lan);
			if (languageJSON == null)
			{
				throw new ArgumentNullException("Can't find matching language entry for audioclip [" + clipName + "] and language [" + lan.ToString() + "] please add this to the subs file to play subtitles for this lanaguage.");
			}
			delay = dialogueJSON.initalDelay;
			return languageJSON;
		}
	}
}
namespace NewtonVR
{
	public enum LevelEnum
	{
		TOP,
		MIDDLE,
		BOTTOM
	}
	public class AstrolabeArtefact : NVRInteractable
	{
		[SerializeField]
		private GameObject topLayer;

		[SerializeField]
		private GameObject middleLayer;

		[SerializeField]
		private GameObject bottomLayer;

		[SerializeField]
		private GameObject artefactLayer;

		[SerializeField]
		private GameObject sacredEarth;

		[SerializeField]
		private AudioScript audioScript;

		[SerializeField]
		private AudioClip rotatingClip;

		[SerializeField]
		private AudioClip correctPositionFoundClip;

		[SerializeField]
		private AudioClip correctPositionUnlockClip;

		[SerializeField]
		private AudioClip gettingClosePositionClip;

		[SerializeField]
		private AudioClip resetPositionClip;

		[SerializeField]
		private AudioClip artefactRevealedClip;

		[SerializeField]
		private GameObject centerPoint;

		private LevelEnum currentLevel;

		protected Transform InitialAttachPoint;

		protected Transform CurrentAttachPoint;

		private static int topLayerLength = 24;

		private static int middleLayerLength = 24;

		private static int bottomLayerLength = 24;

		private static int topLayerPreviousPosition = 24;

		private static int middleLayerPreviousPosition = 24;

		private static int bottomLayerPreviousPosition = 24;

		private static int topLayerUnlockPosition = 0;

		private static int middleLayerUnlockPosition = 0;

		private static int bottomLayerUnlockPosition = 0;

		private bool topLayerInCorrectPosition;

		private bool middleLayerInCorrectPosition;

		private bool bottomLayerInCorrectPosition;

		private bool topLayerUnlocked;

		private bool middleLayerUnlocked;

		private bool bottomLayerUnlocked;

		public bool artefactUnlocked;

		public bool reverseDirection;

		private float artefactUnlockedYPos = 1.0488f;

		private float RungAngleInterval;

		private float rotationAmount = 0.9f;

		private int previousPosition;

		private float waitToPlayClick;

		private float timeToWait = 0.6f;

		private float distance;

		protected override void Start()
		{
			base.Start();
			sacredEarth.SetActive(value: false);
		}

		private void OnEnable()
		{
			Rigidbody.maxAngularVelocity = 100f;
			ResetArtefact(withAudio: false, levelStart: true);
			if (SaveManager.instance.HasFoundArtifact(ChapterID.NURSERY))
			{
				setArtifactRevealed();
			}
		}

		private void ResetArtefact(bool withAudio, bool levelStart = false)
		{
			StartCoroutine(ResetArtefactRoutine(withAudio, levelStart));
		}

		private IEnumerator ResetArtefactRoutine(bool withAudio, bool levelStart)
		{
			if (!SaveManager.instance.HasFoundArtifact(ChapterID.NURSERY))
			{
				EndInteraction(base.AttachedHand);
				CanAttach = false;
				topLayerInCorrectPosition = false;
				middleLayerInCorrectPosition = false;
				bottomLayerInCorrectPosition = false;
				if (withAudio)
				{
					audioScript.PlayOne(resetPositionClip);
					yield return Yield.WaitSeconds(0.3f);
				}
				topLayerUnlocked = false;
				middleLayerUnlocked = false;
				bottomLayerUnlocked = false;
				Vector3 localEulerAngles = topLayer.transform.localEulerAngles;
				localEulerAngles.y = UnityEngine.Random.Range(120f, 200f);
				Vector3 localEulerAngles2 = middleLayer.transform.localEulerAngles;
				localEulerAngles2.y = UnityEngine.Random.Range(200f, 290f);
				Vector3 localEulerAngles3 = bottomLayer.transform.localEulerAngles;
				localEulerAngles3.y = UnityEngine.Random.Range(230f, 360f);
				if (levelStart)
				{
					LeanTween.rotateLocal(topLayer, localEulerAngles, 0f);
					LeanTween.rotateLocal(middleLayer, localEulerAngles2, 0f);
					LeanTween.rotateLocal(bottomLayer, localEulerAngles3, 0f);
				}
				else
				{
					LeanTween.rotateLocal(topLayer, localEulerAngles, 0.6f);
					LeanTween.rotateLocal(middleLayer, localEulerAngles2, 0.6f);
					LeanTween.rotateLocal(bottomLayer, localEulerAngles3, 0.6f);
					yield return Yield.WaitSeconds(0.6f);
				}
				topLayerInCorrectPosition = false;
				middleLayerInCorrectPosition = false;
				bottomLayerInCorrectPosition = false;
				topLayerUnlocked = false;
				middleLayerUnlocked = false;
				bottomLayerUnlocked = false;
				currentLevel = LevelEnum.TOP;
				ChangeLevel(currentLevel);
				CanAttach = true;
			}
		}

		private void ChangeLevel(LevelEnum level)
		{
			switch (level)
			{
			case LevelEnum.TOP:
				RungAngleInterval = 360f / (float)topLayerLength;
				break;
			case LevelEnum.MIDDLE:
				RungAngleInterval = 360f / (float)middleLayerLength;
				break;
			case LevelEnum.BOTTOM:
				RungAngleInterval = 360f / (float)bottomLayerLength;
				break;
			}
		}

		public float AngleSigned(Vector3 v1, Vector3 v2, Vector3 n)
		{
			return Mathf.Atan2(Vector3.Dot(n, Vector3.Cross(v1, v2)), Vector3.Dot(v1, v2)) * 57.29578f;
		}

		public void setArtifactRevealed()
		{
			sacredEarth.SetActive(value: false);
			Vector3 localPosition = artefactLayer.transform.localPosition;
			localPosition.y = artefactUnlockedYPos;
			artefactLayer.transform.localPosition = localPosition;
			Vector3 localEulerAngles = topLayer.transform.localEulerAngles;
			localEulerAngles.y = 0f;
			topLayer.transform.localEulerAngles = localEulerAngles;
			Vector3 localEulerAngles2 = middleLayer.transform.localEulerAngles;
			localEulerAngles2.y = 0f;
			middleLayer.transform.localEulerAngles = localEulerAngles2;
			Vector3 localEulerAngles3 = bottomLayer.transform.localEulerAngles;
			localEulerAngles3.y = 0f;
			bottomLayer.transform.localEulerAngles = localEulerAngles3;
			artefactUnlocked = true;
			CanAttach = false;
		}

		protected void FixedUpdate()
		{
			if (IsAttached)
			{
				Vector3 position = base.AttachedHand.transform.position;
				position.y = InitialAttachPoint.position.y;
				CurrentAttachPoint.position = position;
				CurrentAttachPoint.rotation = base.AttachedHand.transform.rotation;
				_ = InitialAttachPoint.position - CurrentAttachPoint.position;
				Vector3 localEulerAngles = base.gameObject.transform.localEulerAngles;
				distance = Vector3.Distance(InitialAttachPoint.position, CurrentAttachPoint.position);
				float f = AngleSigned(CurrentAttachPoint.position, InitialAttachPoint.position, centerPoint.transform.position);
				if ((double)distance > 0.05)
				{
					if (reverseDirection)
					{
						if (Mathf.Sign(f) != 1f)
						{
							localEulerAngles.x = 0f;
							localEulerAngles.y += rotationAmount * distance;
							localEulerAngles.z = 0f;
						}
					}
					else if (Mathf.Sign(f) == 1f)
					{
						localEulerAngles.x = 0f;
						localEulerAngles.y += rotationAmount * distance;
						localEulerAngles.z = 0f;
					}
					base.gameObject.transform.localEulerAngles = localEulerAngles;
					if (topLayerUnlocked && middleLayerUnlocked && bottomLayerUnlocked && !artefactUnlocked)
					{
						Vector3 localEulerAngles2 = topLayer.transform.localEulerAngles;
						Vector3 localEulerAngles3 = middleLayer.transform.localEulerAngles;
						Vector3 localEulerAngles4 = bottomLayer.transform.localEulerAngles;
						Vector3 localEulerAngles5 = artefactLayer.transform.localEulerAngles;
						Vector3 localPosition = artefactLayer.transform.localPosition;
						if (reverseDirection)
						{
							if (Mathf.Sign(f) != 1f)
							{
								localEulerAngles2.y += rotationAmount * distance;
								localEulerAngles3.y += rotationAmount * distance;
								localEulerAngles4.y += rotationAmount * distance;
								localEulerAngles5.y += 0.0002f;
								localPosition.y += 0.0002f;
							}
						}
						else if (Mathf.Sign(f) == 1f)
						{
							localEulerAngles2.y += rotationAmount * distance;
							localEulerAngles3.y += rotationAmount * distance;
							localEulerAngles4.y += rotationAmount * distance;
							localEulerAngles5.y += 0.0002f;
							localPosition.y += 0.0002f;
						}
						if (!audioScript.IsPlaying())
						{
							audioScript.PlayLoop(rotatingClip);
						}
						topLayer.transform.localEulerAngles = localEulerAngles2;
						middleLayer.transform.localEulerAngles = localEulerAngles3;
						bottomLayer.transform.localEulerAngles = localEulerAngles4;
						if (localPosition.y > 0.93616f)
						{
							artefactLayer.transform.localEulerAngles = localEulerAngles5;
							artefactLayer.transform.localPosition = localPosition;
						}
						else
						{
							localPosition.y = 0.93616f;
						}
						if (!artefactUnlocked && artefactLayer.transform.localPosition.y >= artefactUnlockedYPos)
						{
							artefactUnlocked = true;
							EndInteraction(base.AttachedHand);
							CanAttach = false;
						}
					}
					else if (!topLayerUnlocked || !middleLayerUnlocked || !bottomLayerUnlocked)
					{
						switch (currentLevel)
						{
						case LevelEnum.TOP:
						{
							Vector3 localEulerAngles7 = topLayer.transform.localEulerAngles;
							if (reverseDirection)
							{
								if (Mathf.Sign(f) != 1f)
								{
									localEulerAngles7.y += rotationAmount * distance;
									if (!audioScript.IsPlaying())
									{
										audioScript.PlayLoop(rotatingClip);
									}
									topLayer.transform.localEulerAngles = localEulerAngles7;
								}
							}
							else if (Mathf.Sign(f) == 1f)
							{
								localEulerAngles7.y += rotationAmount * distance;
								if (!audioScript.IsPlaying())
								{
									audioScript.PlayLoop(rotatingClip);
								}
								topLayer.transform.localEulerAngles = localEulerAngles7;
							}
							break;
						}
						case LevelEnum.MIDDLE:
						{
							Vector3 localEulerAngles8 = middleLayer.transform.localEulerAngles;
							if (reverseDirection)
							{
								if (Mathf.Sign(f) != 1f)
								{
									localEulerAngles8.y += rotationAmount * distance;
									if (!audioScript.IsPlaying())
									{
										audioScript.PlayLoop(rotatingClip);
									}
									middleLayer.transform.localEulerAngles = localEulerAngles8;
								}
							}
							else if (Mathf.Sign(f) == 1f)
							{
								localEulerAngles8.y += rotationAmount * distance;
								if (!audioScript.IsPlaying())
								{
									audioScript.PlayLoop(rotatingClip);
								}
								middleLayer.transform.localEulerAngles = localEulerAngles8;
							}
							break;
						}
						case LevelEnum.BOTTOM:
						{
							Vector3 localEulerAngles6 = bottomLayer.transform.localEulerAngles;
							if (reverseDirection)
							{
								if (Mathf.Sign(f) != 1f)
								{
									localEulerAngles6.y += rotationAmount * distance;
									if (!audioScript.IsPlaying())
									{
										audioScript.PlayLoop(rotatingClip);
									}
									bottomLayer.transform.localEulerAngles = localEulerAngles6;
								}
							}
							else if (Mathf.Sign(f) == 1f)
							{
								localEulerAngles6.y += rotationAmount * distance;
								if (!audioScript.IsPlaying())
								{
									audioScript.PlayLoop(rotatingClip);
								}
								bottomLayer.transform.localEulerAngles = localEulerAngles6;
							}
							break;
						}
						}
					}
				}
				else
				{
					audioScript.StopLoop();
				}
			}
			else
			{
				switch (currentLevel)
				{
				case LevelEnum.TOP:
					if (topLayerInCorrectPosition && !topLayerUnlocked)
					{
						Quaternion localRotation3 = topLayer.transform.localRotation;
						localRotation3.x = 0f;
						localRotation3.y = 0f;
						localRotation3.z = 0f;
						topLayer.transform.localRotation = localRotation3;
						audioScript.PlayOne(correctPositionUnlockClip);
						topLayerUnlocked = true;
						currentLevel++;
						ChangeLevel(currentLevel);
					}
					break;
				case LevelEnum.MIDDLE:
					if (middleLayerInCorrectPosition && !middleLayerUnlocked)
					{
						Quaternion localRotation2 = middleLayer.transform.localRotation;
						localRotation2.x = 0f;
						localRotation2.y = 0f;
						localRotation2.z = 0f;
						middleLayer.transform.localRotation = localRotation2;
						audioScript.PlayOne(correctPositionUnlockClip);
						middleLayerUnlocked = true;
						currentLevel++;
						ChangeLevel(currentLevel);
					}
					break;
				case LevelEnum.BOTTOM:
					if (bottomLayerInCorrectPosition && !bottomLayerUnlocked)
					{
						Quaternion localRotation = bottomLayer.transform.localRotation;
						localRotation.x = 0f;
						localRotation.y = 0f;
						localRotation.z = 0f;
						bottomLayer.transform.localRotation = localRotation;
						LeanTween.moveLocalY(artefactLayer, 0.9516f, 1f);
						audioScript.PlayOne(artefactRevealedClip);
						sacredEarth.SetActive(value: true);
						bottomLayerUnlocked = true;
					}
					break;
				}
			}
			if (!topLayerUnlocked || !middleLayerUnlocked || !bottomLayerUnlocked)
			{
				CheckForCorrectPosition();
			}
		}

		public override void BeginInteraction(NVRHand hand, bool runBeginInteractionCallback = true)
		{
			Rigidbody.isKinematic = false;
			base.BeginInteraction(hand);
			HandRendersActive(showHands: false, hand);
			InitialAttachPoint = new GameObject($"[{base.gameObject.name}] InitialAttachPoint").transform;
			InitialAttachPoint.position = hand.transform.position;
			InitialAttachPoint.rotation = hand.transform.rotation;
			InitialAttachPoint.localScale = Vector3.one;
			InitialAttachPoint.parent = base.transform.parent.transform;
			CurrentAttachPoint = new GameObject($"[{base.gameObject.name}] CurrentAttachPoint").transform;
			CurrentAttachPoint.position = hand.transform.position;
			CurrentAttachPoint.rotation = hand.transform.rotation;
			CurrentAttachPoint.localScale = Vector3.one;
			CurrentAttachPoint.parent = base.transform.parent.transform;
		}

		public override void EndInteraction(NVRHand hand)
		{
			base.EndInteraction(hand);
			HandRendersActive(showHands: true, hand);
			if (audioScript.m_AudioSource != null)
			{
				audioScript.StopLoop();
			}
			if (InitialAttachPoint != null)
			{
				UnityEngine.Object.Destroy(InitialAttachPoint.gameObject);
			}
			if (CurrentAttachPoint != null)
			{
				UnityEngine.Object.Destroy(CurrentAttachPoint.gameObject);
			}
			distance = 0f;
		}

		private void CheckForCorrectPosition()
		{
			if (currentLevel == LevelEnum.TOP)
			{
				int num = Mathf.RoundToInt(topLayer.transform.localEulerAngles.y / RungAngleInterval);
				if ((double)topLayer.transform.localEulerAngles.y < 0.3)
				{
					num = topLayerLength - num;
				}
				if (num > topLayerLength)
				{
					num = 0;
				}
				if (num < 0)
				{
					num = topLayerLength;
				}
				if (num == topLayerUnlockPosition)
				{
					if (previousPosition == topLayerPreviousPosition)
					{
						if (!topLayerInCorrectPosition)
						{
							audioScript.PlayOne(correctPositionFoundClip);
						}
						topLayerInCorrectPosition = true;
					}
					else
					{
						previousPosition = num;
						topLayerInCorrectPosition = false;
					}
				}
				else if (num == topLayerPreviousPosition)
				{
					if (Time.time > waitToPlayClick + timeToWait && (double)distance > 0.05)
					{
						audioScript.PlayOne(gettingClosePositionClip);
						waitToPlayClick = Time.time;
					}
				}
				else
				{
					if (topLayerInCorrectPosition)
					{
						previousPosition = 0;
						ResetArtefact(withAudio: true);
					}
					topLayerInCorrectPosition = false;
				}
				if (num != topLayerUnlockPosition && previousPosition != topLayerPreviousPosition)
				{
					previousPosition = num;
					waitToPlayClick = Time.time;
				}
			}
			else if (currentLevel == LevelEnum.MIDDLE)
			{
				int num2 = Mathf.RoundToInt(middleLayer.transform.localEulerAngles.y / RungAngleInterval);
				if ((double)middleLayer.transform.localEulerAngles.y < 0.3)
				{
					num2 = middleLayerLength - num2;
				}
				if (num2 > middleLayerLength)
				{
					num2 = 0;
				}
				if (num2 < 0)
				{
					num2 = middleLayerLength;
				}
				if (num2 == middleLayerUnlockPosition)
				{
					if (previousPosition == middleLayerPreviousPosition)
					{
						if (!middleLayerInCorrectPosition)
						{
							audioScript.PlayOne(correctPositionFoundClip);
						}
						middleLayerInCorrectPosition = true;
					}
					else
					{
						previousPosition = num2;
						middleLayerInCorrectPosition = false;
					}
				}
				else if (num2 == middleLayerPreviousPosition)
				{
					if (Time.time > waitToPlayClick + timeToWait && (double)distance > 0.05)
					{
						audioScript.PlayOne(gettingClosePositionClip);
						waitToPlayClick = Time.time;
					}
				}
				else
				{
					if (middleLayerInCorrectPosition)
					{
						previousPosition = 0;
						ResetArtefact(withAudio: true);
					}
					middleLayerInCorrectPosition = false;
				}
				if (num2 != middleLayerUnlockPosition && previousPosition != middleLayerPreviousPosition)
				{
					previousPosition = num2;
					waitToPlayClick = Time.time;
				}
			}
			else
			{
				if (currentLevel != LevelEnum.BOTTOM)
				{
					return;
				}
				int num3 = Mathf.RoundToInt(bottomLayer.transform.localEulerAngles.y / RungAngleInterval);
				if ((double)bottomLayer.transform.localEulerAngles.y < 0.3)
				{
					num3 = bottomLayerLength - num3;
				}
				if (num3 > bottomLayerLength)
				{
					num3 = 0;
				}
				if (num3 < 0)
				{
					num3 = bottomLayerLength;
				}
				if (num3 == bottomLayerUnlockPosition)
				{
					if (previousPosition == bottomLayerPreviousPosition)
					{
						if (!bottomLayerInCorrectPosition)
						{
							audioScript.PlayOne(correctPositionFoundClip);
						}
						bottomLayerInCorrectPosition = true;
					}
					else
					{
						previousPosition = num3;
						bottomLayerInCorrectPosition = false;
					}
				}
				else if (num3 == bottomLayerPreviousPosition)
				{
					if (Time.time > waitToPlayClick + timeToWait && (double)distance > 0.05)
					{
						audioScript.PlayOne(gettingClosePositionClip);
						waitToPlayClick = Time.time;
					}
				}
				else
				{
					if (bottomLayerInCorrectPosition)
					{
						previousPosition = 0;
						ResetArtefact(withAudio: true);
					}
					bottomLayerInCorrectPosition = false;
				}
				if (num3 != bottomLayerUnlockPosition && previousPosition != bottomLayerPreviousPosition)
				{
					previousPosition = num3;
					waitToPlayClick = Time.time;
				}
			}
		}

		private void HandRendersActive(bool showHands, NVRHand hand)
		{
			if (hand != null)
			{
				if (!hand.IsPrimary)
				{
					GameController.instance.player.watch.gameObject.SetActive(showHands);
				}
				Renderer[] componentsInChildren = hand.RenderModel.GetComponentsInChildren<Renderer>();
				for (int i = 0; i < componentsInChildren.Length; i++)
				{
					componentsInChildren[i].enabled = showHands;
				}
			}
		}
	}
	public class NVRCollisionSoundController : MonoBehaviour
	{
		public static NVRCollisionSoundController Instance;

		[Tooltip("The max number of sounds that can possibly be playing at once.")]
		public int SoundPoolSize = 100;

		[Tooltip("Turns on or off randomizing the pitch of the collision sounds")]
		public bool PitchModulationEnabled = true;

		[Range(0f, 3f)]
		public float PitchModulationRange = 0.5f;

		[Tooltip("Don't play collision sounds that will produce an impact with a volume lower than this number")]
		public float MinCollisionVolume = 0.1f;

		public float MaxCollisionVelocity = 5f;

		[HideInInspector]
		public NVRCollisionSoundProviders SoundEngine = NVRCollisionSoundProviders.Unity;

		private static NVRCollisionSoundProvider Provider;

		private void Awake()
		{
			Instance = this;
			Provider = base.gameObject.AddComponent<NVRCollisionSoundProviderUnity>();
		}

		public static void Play(NVRCollisionSoundMaterials material, Vector3 position, float impactVolume)
		{
			if (Provider != null)
			{
				Provider.Play(material, position, impactVolume);
			}
		}
	}
	public enum NVRCollisionSoundProviders
	{
		None,
		Unity,
		FMOD
	}
	public enum NVRCollisionSoundMaterials
	{
		none = 0,
		_default = 1,
		carpet = 2,
		wood = 3,
		metal = 4,
		glass = 5,
		plastic = 6,
		cardboard = 7,
		EndNewtonVRMaterials = 50
	}
	public class NVRCollisionSoundMaterialsList
	{
		public static Type typeCache;

		private static NVRCollisionSoundMaterials[] list;

		public static Type TypeCache
		{
			get
			{
				if (typeCache == null)
				{
					typeCache = typeof(NVRCollisionSoundMaterials);
				}
				return typeCache;
			}
		}

		public static NVRCollisionSoundMaterials[] List
		{
			get
			{
				if (NVRCollisionSoundMaterialsList.list == null)
				{
					List<NVRCollisionSoundMaterials> list = new List<NVRCollisionSoundMaterials>();
					foreach (NVRCollisionSoundMaterials value in Enum.GetValues(typeof(NVRCollisionSoundMaterials)))
					{
						list.Add(value);
					}
					NVRCollisionSoundMaterialsList.list = list.ToArray();
				}
				return NVRCollisionSoundMaterialsList.list;
			}
		}

		public static NVRCollisionSoundMaterials? Parse(string materialString)
		{
			materialString = materialString.ToLower();
			if (Enum.IsDefined(TypeCache, materialString))
			{
				return (NVRCollisionSoundMaterials)Enum.Parse(TypeCache, materialString);
			}
			return null;
		}
	}
	public class NVRCollisionSoundObject : MonoBehaviour
	{
		private static Dictionary<Collider, NVRCollisionSoundObject> SoundObjects = new Dictionary<Collider, NVRCollisionSoundObject>();

		public NVRCollisionSoundMaterials Material;

		private Collider[] Colliders;

		protected virtual void Awake()
		{
			Colliders = GetComponentsInChildren<Collider>(includeInactive: true);
			for (int i = 0; i < Colliders.Length; i++)
			{
				SoundObjects[Colliders[i]] = this;
			}
		}

		protected virtual void OnDestroy()
		{
			Colliders = GetComponentsInChildren<Collider>(includeInactive: true);
			for (int i = 0; i < Colliders.Length; i++)
			{
				SoundObjects.Remove(Colliders[i]);
			}
		}

		protected virtual void OnCollisionEnter(Collision collision)
		{
			Collider collider = collision.collider;
			if (SoundObjects.ContainsKey(collider))
			{
				NVRCollisionSoundObject nVRCollisionSoundObject = SoundObjects[collider];
				float num = CalculateImpactVolume(collision);
				if (!(num < NVRCollisionSoundController.Instance.MinCollisionVolume))
				{
					NVRCollisionSoundController.Play(Material, collision.contacts[0].point, num);
					NVRCollisionSoundController.Play(nVRCollisionSoundObject.Material, collision.contacts[0].point, num);
				}
			}
		}

		private float CalculateImpactVolume(Collision collision)
		{
			return CubicEaseOut(collision.relativeVelocity.magnitude);
		}

		public static float CubicEaseOut(float velocity, float startingValue = 0f, float changeInValue = 1f)
		{
			return changeInValue * ((velocity = velocity / NVRCollisionSoundController.Instance.MaxCollisionVelocity - 1f) * velocity * velocity + 1f) + startingValue;
		}
	}
	public abstract class NVRCollisionSoundProvider : MonoBehaviour
	{
		public abstract void Awake();

		public abstract void Play(NVRCollisionSoundMaterials material, Vector3 position, float impactVolume);
	}
	public class NVRCollisionSoundProviderFMOD : NVRCollisionSoundProvider
	{
		public override void Awake()
		{
		}

		public override void Play(NVRCollisionSoundMaterials material, Vector3 position, float impactVolume)
		{
		}
	}
	public class NVRCollisionSoundProviderUnity : NVRCollisionSoundProvider
	{
		private static string AudioSourcePrefabPath = "CollisionSoundPrefab";

		private static string CollisionSoundsPath = "CollisionSounds";

		private GameObject AudioSourcePrefab;

		private AudioSource[] AudioPool;

		private int CurrentPoolIndex;

		private Dictionary<NVRCollisionSoundMaterials, List<AudioClip>> Clips;

		public override void Awake()
		{
			AudioPool = new AudioSource[NVRCollisionSoundController.Instance.SoundPoolSize];
			AudioSourcePrefab = Resources.Load<GameObject>(AudioSourcePrefabPath);
			for (int i = 0; i < AudioPool.Length; i++)
			{
				AudioPool[i] = UnityEngine.Object.Instantiate(AudioSourcePrefab).GetComponent<AudioSource>();
				AudioPool[i].transform.parent = base.transform;
			}
			AudioClip[] array = Resources.LoadAll<AudioClip>(CollisionSoundsPath);
			Clips = new Dictionary<NVRCollisionSoundMaterials, List<AudioClip>>();
			for (int j = 0; j < array.Length; j++)
			{
				string text = array[j].name;
				int num = text.IndexOf("__");
				if (num >= 0)
				{
					text = text.Substring(0, num);
				}
				NVRCollisionSoundMaterials? nVRCollisionSoundMaterials = NVRCollisionSoundMaterialsList.Parse(text);
				if (nVRCollisionSoundMaterials.HasValue)
				{
					if (!Clips.ContainsKey(nVRCollisionSoundMaterials.Value) || Clips[nVRCollisionSoundMaterials.Value] == null)
					{
						Clips[nVRCollisionSoundMaterials.Value] = new List<AudioClip>();
					}
					Clips[nVRCollisionSoundMaterials.Value].Add(array[j]);
				}
			}
		}

		public override void Play(NVRCollisionSoundMaterials material, Vector3 position, float impactVolume)
		{
			if (material != 0)
			{
				if (NVRCollisionSoundController.Instance.PitchModulationEnabled)
				{
					AudioPool[CurrentPoolIndex].pitch = UnityEngine.Random.Range(1f - NVRCollisionSoundController.Instance.PitchModulationRange, 1f + NVRCollisionSoundController.Instance.PitchModulationRange);
				}
				AudioPool[CurrentPoolIndex].transform.position = position;
				AudioPool[CurrentPoolIndex].volume = impactVolume;
				AudioPool[CurrentPoolIndex].clip = GetClip(material);
				AudioPool[CurrentPoolIndex].Play();
				CurrentPoolIndex++;
				if (CurrentPoolIndex >= AudioPool.Length)
				{
					CurrentPoolIndex = 0;
				}
			}
		}

		private AudioClip GetClip(NVRCollisionSoundMaterials material)
		{
			if (!Clips.ContainsKey(material))
			{
				material = NVRCollisionSoundMaterials._default;
			}
			int index = UnityEngine.Random.Range(0, Clips[material].Count);
			return Clips[material][index];
		}
	}
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	internal struct EnumEqualityComparer<TEnum> : IEqualityComparer<TEnum> where TEnum : struct
	{
		private static class BoxAvoidance
		{
			private static readonly Func<TEnum, int> _wrapper;

			public static int ToInt(TEnum enu)
			{
				return _wrapper(enu);
			}

			static BoxAvoidance()
			{
				ParameterExpression parameterExpression = Expression.Parameter(typeof(TEnum), null);
				_wrapper = Expression.Lambda<Func<TEnum, int>>(Expression.ConvertChecked(parameterExpression, typeof(int)), new ParameterExpression[1] { parameterExpression }).Compile();
			}
		}

		public bool Equals(TEnum firstEnum, TEnum secondEnum)
		{
			return BoxAvoidance.ToInt(firstEnum) == BoxAvoidance.ToInt(secondEnum);
		}

		public int GetHashCode(TEnum firstEnum)
		{
			return BoxAvoidance.ToInt(firstEnum);
		}
	}
	public class NVRAttachJoint : MonoBehaviour
	{
		public NVRInteractableItem AttachedItem;

		public NVRAttachPoint AttachedPoint;

		public float PullRange = 0.2f;

		public float AttachRange = 0.01f;

		public float DropDistance = 0.1f;

		public bool MatchRotation = true;

		public bool IsAttached => AttachedItem != null;

		protected virtual void OnTriggerStay(Collider col)
		{
			if (IsAttached)
			{
				return;
			}
			NVRAttachPoint attachPoint = AttachPointMapper.GetAttachPoint(col);
			if (attachPoint != null && !attachPoint.IsAttached)
			{
				if (Vector3.Distance(attachPoint.transform.position, base.transform.position) < AttachRange)
				{
					Attach(attachPoint);
				}
				else
				{
					attachPoint.PullTowards(this);
				}
			}
		}

		protected virtual void FixedUpdate()
		{
			if (IsAttached)
			{
				FixedUpdateAttached();
			}
		}

		protected virtual void FixedUpdateAttached()
		{
			if (Vector3.Distance(AttachedPoint.transform.position, base.transform.position) > DropDistance)
			{
				Detach();
			}
			else
			{
				AttachedPoint.PullTowards(this);
			}
		}

		protected virtual void Attach(NVRAttachPoint point)
		{
			point.Attached(this);
			AttachedItem = point.Item;
			AttachedPoint = point;
		}

		protected virtual void Detach()
		{
			AttachedPoint.Detached(this);
			AttachedItem = null;
			AttachedPoint = null;
		}
	}
	public class NVRAttachPoint : MonoBehaviour
	{
		private const float MaxVelocityChange = 5f;

		private const float MaxAngularVelocityChange = 10f;

		private const float VelocityMagic = 3000f;

		private const float AngularVelocityMagic = 25f;

		[HideInInspector]
		public Rigidbody Rigidbody;

		[HideInInspector]
		public NVRInteractableItem Item;

		public bool IsAttached;

		protected virtual void Awake()
		{
			IsAttached = false;
			Item = FindNVRItem(base.gameObject);
			if (Item == null)
			{
				UnityEngine.Debug.LogError("No NVRInteractableItem found on this object. " + base.gameObject.name, base.gameObject);
			}
			AttachPointMapper.Register(GetComponent<Collider>(), this);
		}

		protected virtual void Start()
		{
			Rigidbody = Item.Rigidbody;
		}

		private NVRInteractableItem FindNVRItem(GameObject gameobject)
		{
			NVRInteractableItem component = gameobject.GetComponent<NVRInteractableItem>();
			if (component != null)
			{
				return component;
			}
			if (gameobject.transform.parent != null)
			{
				return FindNVRItem(gameobject.transform.parent.gameObject);
			}
			return null;
		}

		public virtual void Attached(NVRAttachJoint joint)
		{
			Vector3 position = joint.transform.position + (Item.transform.position - base.transform.position);
			Rigidbody.MovePosition(position);
			if (joint.MatchRotation)
			{
				Rigidbody.MoveRotation(joint.transform.rotation);
			}
			Rigidbody.velocity = Vector3.zero;
			Rigidbody.angularVelocity = Vector3.zero;
			IsAttached = true;
			Rigidbody.useGravity = false;
		}

		public virtual void Detached(NVRAttachJoint joint)
		{
			IsAttached = false;
			if (Item.EnableGravityOnDetach)
			{
				Rigidbody.useGravity = true;
			}
		}

		public virtual void PullTowards(NVRAttachJoint joint)
		{
			float num = 3000f / (Time.deltaTime / 0.0111f);
			float num2 = 25f / (Time.deltaTime / 0.0111f);
			Vector3 target = (joint.transform.position - base.transform.position) * num * Time.deltaTime;
			if (!float.IsNaN(target.x))
			{
				target = Vector3.MoveTowards(Item.Rigidbody.velocity, target, 5f);
				Item.AddExternalVelocity(target);
			}
			if (!joint.MatchRotation)
			{
				return;
			}
			(joint.transform.rotation * Quaternion.Inverse(Item.transform.rotation)).ToAngleAxis(out var angle, out var axis);
			if (angle > 180f)
			{
				angle -= 360f;
			}
			if (angle != 0f)
			{
				Vector3 vector = angle * axis;
				if (!float.IsNaN(vector.x))
				{
					vector = vector * num2 * Time.deltaTime;
					vector = Vector3.MoveTowards(Item.Rigidbody.angularVelocity, vector, 10f);
					Item.AddExternalAngularVelocity(vector);
				}
			}
		}
	}
	public class AttachPointMapper
	{
		private static Dictionary<Collider, NVRAttachPoint> Colliders = new Dictionary<Collider, NVRAttachPoint>();

		public static void Register(Collider col, NVRAttachPoint point)
		{
			Colliders.Add(col, point);
		}

		public static void Deregister(Collider col)
		{
			Colliders.Remove(col);
		}

		public static NVRAttachPoint GetAttachPoint(Collider col)
		{
			Colliders.TryGetValue(col, out var value);
			return value;
		}
	}
	public class NVRButton : MonoBehaviour
	{
		public Rigidbody Rigidbody;

		[Tooltip("The (worldspace) distance from the initial position you have to push the button for it to register as pushed")]
		public float DistanceToEngage = 0.075f;

		[Tooltip("Is set to true when the button has been pressed down this update frame")]
		public bool ButtonDown;

		[Tooltip("Is set to true when the button has been released from the down position this update frame")]
		public bool ButtonUp;

		[Tooltip("Is set to true each frame the button is pressed down")]
		public bool ButtonIsPushed;

		[Tooltip("Is set to true if the button was in a pushed state last frame")]
		public bool ButtonWasPushed;

		protected Transform InitialPosition;

		protected float MinDistance = 0.001f;

		protected float PositionMagic = 1000f;

		protected float CurrentDistance = -1f;

		private Vector3 InitialLocalPosition;

		private Vector3 ConstrainedPosition;

		private Quaternion InitialLocalRotation;

		private Quaternion ConstrainedRotation;

		private void Awake()
		{
			InitialPosition = new GameObject($"[{base.gameObject.name}] Initial Position").transform;
			InitialPosition.parent = base.transform.parent;
			InitialPosition.localPosition = Vector3.zero;
			InitialPosition.localRotation = Quaternion.identity;
			if (Rigidbody == null)
			{
				Rigidbody = GetComponent<Rigidbody>();
			}
			if (Rigidbody == null)
			{
				UnityEngine.Debug.LogError("There is no rigidbody attached to this button.");
			}
			InitialLocalPosition = base.transform.localPosition;
			ConstrainedPosition = InitialLocalPosition;
			InitialLocalRotation = base.transform.localRotation;
			ConstrainedRotation = InitialLocalRotation;
		}

		private void FixedUpdate()
		{
			ConstrainPosition();
			CurrentDistance = Vector3.Distance(base.transform.position, InitialPosition.position);
			Vector3 vector = InitialPosition.position - base.transform.position;
			Rigidbody.velocity = vector * PositionMagic * Time.deltaTime;
		}

		private void Update()
		{
			ButtonWasPushed = ButtonIsPushed;
			ButtonIsPushed = CurrentDistance > DistanceToEngage;
			if (!ButtonWasPushed && ButtonIsPushed)
			{
				ButtonDown = true;
			}
			else
			{
				ButtonDown = false;
			}
			if (ButtonWasPushed && !ButtonIsPushed)
			{
				ButtonUp = true;
			}
			else
			{
				ButtonUp = false;
			}
		}

		private void ConstrainPosition()
		{
			ConstrainedPosition.y = base.transform.localPosition.y;
			base.transform.localPosition = ConstrainedPosition;
			base.transform.localRotation = ConstrainedRotation;
		}

		private void LateUpdate()
		{
			ConstrainPosition();
		}
	}
	public class NVRButtonInputs
	{
		private bool PressDownCachedA;

		private bool PressDownExpiredA;

		private bool PressDownCachedB;

		private bool PressDownExpiredB;

		private bool PressDownCachedX;

		private bool PressDownExpiredX;

		private bool PressDownCachedY;

		private bool PressDownExpiredY;

		private bool PressDownCachedApp;

		private bool PressDownExpiredApp;

		private bool PressUpCachedA;

		private bool PressUpExpiredA;

		private bool PressUpCachedB;

		private bool PressUpExpiredB;

		private bool PressUpCachedX;

		private bool PressUpExpiredX;

		private bool PressUpCachedY;

		private bool PressUpExpiredY;

		private bool PressUpCachedApp;

		private bool PressUpExpiredApp;

		private bool IsPressedCachedA;

		private bool IsPressedExpiredA;

		private bool IsPressedCachedB;

		private bool IsPressedExpiredB;

		private bool IsPressedCachedX;

		private bool IsPressedExpiredX;

		private bool IsPressedCachedY;

		private bool IsPressedExpiredY;

		private bool IsPressedCachedGripRight;

		private bool IsPressedExpiredGripRight;

		private bool IsPressedCachedGripLeft;

		private bool IsPressedExpiredGripLeft;

		private bool IsPressedCachedTriggerRight;

		private bool IsPressedExpiredTriggerRight;

		private bool IsPressedCachedTriggerLeft;

		private bool IsPressedExpiredTriggerLeft;

		private bool IsPressedCachedAppRight;

		private bool IsPressedExpiredAppRight;

		private bool IsPressedCachedAppLeft;

		private bool IsPressedExpiredAppLeft;

		private Vector2 AxisCachedLeft;

		private bool AxisExpiredLeft;

		private Vector2 AxisCachedRight;

		private bool AxisExpiredRight;

		private bool SingleAxisUpCachedLeft;

		private bool SingleAxisUpExpiredLeft;

		private bool SingleAxisUpCachedRight;

		private bool SingleAxisUpExpiredRight;

		private bool SingleAxisDownCachedLeft;

		private bool SingleAxisDownExpiredLeft;

		private bool SingleAxisDownCachedRight;

		private bool SingleAxisDownExpiredRight;

		private bool GripDownCachedRight;

		private bool GripDownExpiredRight;

		private bool GripDownCachedLeft;

		private bool GripDownExpiredLeft;

		private bool GripUpCachedRight;

		private bool GripUpExpiredRight;

		private bool GripUpCachedLeft;

		private bool GripUpExpiredLeft;

		private NVRInputDevice InputDevice;

		private NVRButtons NVRbutton;

		public bool PressDownA
		{
			get
			{
				if (PressDownExpiredA)
				{
					PressDownCachedA = InputDevice.GetPressDownA(NVRbutton);
					PressDownExpiredA = false;
				}
				return PressDownCachedA;
			}
		}

		public bool PressDownB
		{
			get
			{
				if (PressDownExpiredB)
				{
					PressDownCachedB = InputDevice.GetPressDownB(NVRbutton);
					PressDownExpiredB = false;
				}
				return PressDownCachedB;
			}
		}

		public bool PressDownX
		{
			get
			{
				if (PressDownExpiredX)
				{
					PressDownCachedX = InputDevice.GetPressDownX(NVRbutton);
					PressDownExpiredX = false;
				}
				return PressDownCachedX;
			}
		}

		public bool PressDownY
		{
			get
			{
				if (PressDownExpiredY)
				{
					PressDownCachedY = InputDevice.GetPressDownY(NVRbutton);
					PressDownExpiredY = false;
				}
				return PressDownCachedY;
			}
		}

		public bool PressDownApp
		{
			get
			{
				if (PressDownExpiredApp)
				{
					PressDownCachedApp = InputDevice.GetPressDownApp(NVRbutton);
					PressDownExpiredApp = false;
				}
				return PressDownCachedApp;
			}
		}

		public bool PressUpA
		{
			get
			{
				if (PressUpExpiredA)
				{
					PressUpCachedA = InputDevice.GetPressUpA(NVRbutton);
					PressUpExpiredA = false;
				}
				return PressUpCachedA;
			}
		}

		public bool PressUpB
		{
			get
			{
				if (PressUpExpiredB)
				{
					PressUpCachedB = InputDevice.GetPressUpB(NVRbutton);
					PressUpExpiredB = false;
				}
				return PressUpCachedB;
			}
		}

		public bool PressUpX
		{
			get
			{
				if (PressUpExpiredX)
				{
					PressUpCachedX = InputDevice.GetPressUpX(NVRbutton);
					PressUpExpiredX = false;
				}
				return PressUpCachedX;
			}
		}

		public bool PressUpY
		{
			get
			{
				if (PressUpExpiredY)
				{
					PressUpCachedY = InputDevice.GetPressUpY(NVRbutton);
					PressUpExpiredY = false;
				}
				return PressUpCachedY;
			}
		}

		public bool PressUpApp
		{
			get
			{
				if (PressUpExpiredApp)
				{
					PressUpCachedApp = InputDevice.GetPressUpApp(NVRbutton);
					PressUpExpiredApp = false;
				}
				return PressUpCachedApp;
			}
		}

		public bool IsPressedA
		{
			get
			{
				if (IsPressedExpiredA)
				{
					IsPressedCachedA = InputDevice.GetPressA(NVRbutton);
					IsPressedExpiredA = false;
				}
				return IsPressedCachedA;
			}
		}

		public bool IsPressedB
		{
			get
			{
				if (IsPressedExpiredB)
				{
					IsPressedCachedB = InputDevice.GetPressB(NVRbutton);
					IsPressedExpiredB = false;
				}
				return IsPressedCachedB;
			}
		}

		public bool IsPressedX
		{
			get
			{
				if (IsPressedExpiredX)
				{
					IsPressedCachedX = InputDevice.GetPressX(NVRbutton);
					IsPressedExpiredX = false;
				}
				return IsPressedCachedX;
			}
		}

		public bool IsPressedY
		{
			get
			{
				if (IsPressedExpiredY)
				{
					IsPressedCachedY = InputDevice.GetPressY(NVRbutton);
					IsPressedExpiredY = false;
				}
				return IsPressedCachedY;
			}
		}

		public bool IsPressedGripRight
		{
			get
			{
				if (IsPressedExpiredGripRight)
				{
					IsPressedCachedGripRight = InputDevice.GetPressGripRight(NVRbutton);
					IsPressedExpiredGripRight = false;
				}
				return IsPressedCachedGripRight;
			}
		}

		public bool IsPressedGripLeft
		{
			get
			{
				if (IsPressedExpiredGripLeft)
				{
					IsPressedCachedGripLeft = InputDevice.GetPressGripLeft(NVRbutton);
					IsPressedExpiredGripLeft = false;
				}
				return IsPressedCachedGripLeft;
			}
		}

		public bool IsPressedTriggerRight
		{
			get
			{
				if (IsPressedExpiredTriggerRight)
				{
					IsPressedCachedTriggerRight = InputDevice.GetPressTriggerRight(NVRbutton);
					IsPressedExpiredTriggerRight = false;
				}
				return IsPressedCachedTriggerRight;
			}
		}

		public bool IsPressedTriggerLeft
		{
			get
			{
				if (IsPressedExpiredTriggerLeft)
				{
					IsPressedCachedTriggerLeft = InputDevice.GetPressTriggerLeft(NVRbutton);
					IsPressedExpiredTriggerLeft = false;
				}
				return IsPressedCachedTriggerLeft;
			}
		}

		public bool IsPressedAppRight
		{
			get
			{
				if (IsPressedExpiredAppRight)
				{
					IsPressedCachedAppRight = InputDevice.GetPressAppRight(NVRbutton);
					IsPressedExpiredAppRight = false;
				}
				return IsPressedCachedAppRight;
			}
		}

		public bool IsPressedAppLeft
		{
			get
			{
				if (IsPressedExpiredAppLeft)
				{
					IsPressedCachedAppLeft = InputDevice.GetPressAppLeft(NVRbutton);
					IsPressedExpiredAppLeft = false;
				}
				return IsPressedCachedAppLeft;
			}
		}

		public Vector2 AxisLeft
		{
			get
			{
				if (AxisExpiredLeft)
				{
					AxisCachedLeft = InputDevice.GetAxis2DLeft(NVRbutton);
					AxisExpiredLeft = false;
				}
				return AxisCachedLeft;
			}
		}

		public Vector2 AxisRight
		{
			get
			{
				if (AxisExpiredRight)
				{
					AxisCachedRight = InputDevice.GetAxis2DRight(NVRbutton);
					AxisExpiredRight = false;
				}
				return AxisCachedRight;
			}
		}

		public bool SingleAxisLeftUp
		{
			get
			{
				if (SingleAxisUpExpiredLeft)
				{
					SingleAxisUpCachedLeft = InputDevice.GetAxis1DLeftUp(NVRbutton);
					SingleAxisUpExpiredLeft = false;
				}
				return SingleAxisUpCachedLeft;
			}
		}

		public bool SingleAxisRightUp
		{
			get
			{
				if (SingleAxisUpExpiredRight)
				{
					SingleAxisUpCachedRight = InputDevice.GetAxis1DRightUp(NVRbutton);
					SingleAxisUpExpiredRight = false;
				}
				return SingleAxisUpCachedRight;
			}
		}

		public bool SingleAxisLeftDown
		{
			get
			{
				if (SingleAxisDownExpiredLeft)
				{
					SingleAxisDownCachedLeft = InputDevice.GetAxis1DLeftDown(NVRbutton);
					SingleAxisDownExpiredLeft = false;
				}
				return SingleAxisDownCachedLeft;
			}
		}

		public bool SingleAxisRightDown
		{
			get
			{
				if (SingleAxisDownExpiredRight)
				{
					SingleAxisDownCachedRight = InputDevice.GetAxis1DRightDown(NVRbutton);
					SingleAxisDownExpiredRight = false;
				}
				return SingleAxisDownCachedRight;
			}
		}

		public bool GripRightDown
		{
			get
			{
				if (GripDownExpiredRight)
				{
					GripDownCachedRight = InputDevice.GetRightDown(NVRbutton);
					GripDownExpiredRight = false;
				}
				return GripDownCachedRight;
			}
		}

		public bool GripLeftDown
		{
			get
			{
				if (GripDownExpiredLeft)
				{
					GripDownCachedLeft = InputDevice.GetLeftDown(NVRbutton);
					GripDownExpiredLeft = false;
				}
				return GripDownCachedLeft;
			}
		}

		public bool GripRightUp
		{
			get
			{
				if (GripUpExpiredRight)
				{
					GripUpCachedRight = InputDevice.GetRightUp(NVRbutton);
					GripUpExpiredRight = false;
				}
				return GripUpCachedRight;
			}
		}

		public bool GripLeftUp
		{
			get
			{
				if (GripUpExpiredLeft)
				{
					GripUpCachedLeft = InputDevice.GetLeftUp(NVRbutton);
					GripUpExpiredLeft = false;
				}
				return GripUpCachedLeft;
			}
		}

		public void FrameReset(NVRInputDevice inputDevice, NVRButtons button)
		{
			InputDevice = inputDevice;
			NVRbutton = button;
			PressDownExpiredA = true;
			PressUpExpiredA = true;
			PressDownExpiredB = true;
			PressUpExpiredB = true;
			PressDownExpiredX = true;
			PressUpExpiredX = true;
			PressDownExpiredY = true;
			PressUpExpiredY = true;
			IsPressedExpiredA = true;
			IsPressedExpiredB = true;
			IsPressedExpiredX = true;
			IsPressedExpiredY = true;
			IsPressedExpiredGripRight = true;
			IsPressedExpiredGripLeft = true;
			IsPressedExpiredTriggerRight = true;
			IsPressedExpiredTriggerLeft = true;
			IsPressedExpiredAppRight = true;
			IsPressedExpiredAppLeft = true;
			AxisExpiredLeft = true;
			AxisExpiredRight = true;
			SingleAxisDownExpiredLeft = true;
			SingleAxisDownExpiredRight = true;
			SingleAxisUpExpiredLeft = true;
			SingleAxisUpExpiredRight = true;
			PressDownExpiredApp = true;
			PressUpExpiredApp = true;
			GripDownExpiredLeft = true;
			GripDownExpiredRight = true;
			GripUpExpiredLeft = true;
			GripUpExpiredRight = true;
		}
	}
	[Serializable]
	public enum NVRButtons
	{
		System,
		ApplicationMenu,
		Grip,
		DPad_Left,
		DPad_Up,
		DPad_Right,
		DPad_Down,
		A,
		B,
		X,
		Y,
		Axis0,
		Axis1,
		Axis2,
		Axis3,
		Axis4,
		Touchpad,
		Trigger,
		TriggerLeft,
		TriggerRight,
		Back,
		Stick,
		StickLeft,
		StickRight,
		StickPress,
		StickPressLeft,
		StickPressRight,
		BumperLeft,
		BumperRight
	}
	public class NVRButtonsHelper
	{
		private static NVRButtons[] array;

		public static NVRButtons[] Array
		{
			get
			{
				if (array == null)
				{
					array = (NVRButtons[])Enum.GetValues(typeof(NVRButtons));
				}
				return array;
			}
		}
	}
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	public struct NVRButtonsComparer : IEqualityComparer<NVRButtons>
	{
		public bool Equals(NVRButtons x, NVRButtons y)
		{
			return x == y;
		}

		public int GetHashCode(NVRButtons obj)
		{
			return (int)obj;
		}
	}
	public class NVRCanvasInput : BaseInputModule
	{
		public bool GeometryBlocksLaser = true;

		public LayerMask LayersThatBlockLaser = -1;

		public Sprite CursorSprite;

		public Material CursorMaterial;

		public float NormalCursorScale = 0.05f;

		public bool LaserEnabled = true;

		public UnityEngine.Color LaserColor = UnityEngine.Color.blue;

		public float LaserStartWidth = 0.02f;

		public float LaserEndWidth = 0.001f;

		public bool OnCanvas;

		public bool CanvasUsed;

		private RectTransform[] Cursors;

		private LineRenderer[] Lasers;

		private GameObject[] CurrentPoint;

		private GameObject[] CurrentPressed;

		private GameObject[] CurrentDragging;

		private PointerEventData[] PointEvents;

		private bool Initialized;

		private Camera ControllerCamera;

		private NVRPlayer Player;

		protected override void Start()
		{
			base.Start();
			if (Initialized)
			{
				return;
			}
			StartCoroutine(DelayedCameraInit());
			Player = GetComponent<NVRPlayer>();
			Cursors = new RectTransform[Player.Hands.Length];
			Lasers = new LineRenderer[Cursors.Length];
			for (int i = 0; i < Cursors.Length; i++)
			{
				GameObject gameObject = new GameObject("Cursor for " + Player.Hands[i].gameObject.name);
				gameObject.transform.parent = base.transform;
				gameObject.transform.localPosition = Vector3.zero;
				gameObject.transform.localRotation = Quaternion.identity;
				Canvas canvas = gameObject.AddComponent<Canvas>();
				gameObject.AddComponent<CanvasRenderer>();
				gameObject.AddComponent<CanvasScaler>();
				gameObject.AddComponent<NVRUIIgnoreRaycast>();
				gameObject.AddComponent<GraphicRaycaster>();
				canvas.renderMode = RenderMode.WorldSpace;
				canvas.sortingOrder = 1000;
				UnityEngine.UI.Image image = gameObject.AddComponent<UnityEngine.UI.Image>();
				image.sprite = CursorSprite;
				image.material = CursorMaterial;
				if (LaserEnabled)
				{
					Lasers[i] = gameObject.AddComponent<LineRenderer>();
					Lasers[i].material = new Material(Shader.Find("Standard"));
					Lasers[i].material.color = LaserColor;
					NVRHelpers.LineRendererSetColor(Lasers[i], LaserColor, LaserColor);
					NVRHelpers.LineRendererSetWidth(Lasers[i], LaserStartWidth, LaserEndWidth);
					Lasers[i].useWorldSpace = true;
					Lasers[i].enabled = false;
				}
				if (CursorSprite == null)
				{
					UnityEngine.Debug.LogError("Set CursorSprite on " + base.gameObject.name + " to the sprite you want to use as your cursor.", base.gameObject);
				}
				Cursors[i] = gameObject.GetComponent<RectTransform>();
			}
			CurrentPoint = new GameObject[Cursors.Length];
			CurrentPressed = new GameObject[Cursors.Length];
			CurrentDragging = new GameObject[Cursors.Length];
			PointEvents = new PointerEventData[Cursors.Length];
			Initialized = true;
		}

		protected IEnumerator DelayedCameraInit()
		{
			ControllerCamera = new GameObject("Controller UI Camera").AddComponent<Camera>();
			yield return null;
			ControllerCamera.clearFlags = CameraClearFlags.Nothing;
			ControllerCamera.cullingMask = 0;
			ControllerCamera.stereoTargetEye = StereoTargetEyeMask.None;
			Canvas[] array = UnityEngine.Object.FindObjectsOfType<Canvas>();
			for (int i = 0; i < array.Length; i++)
			{
				array[i].worldCamera = ControllerCamera;
			}
		}

		private bool GetLookPointerEventData(int index)
		{
			if (PointEvents[index] == null)
			{
				PointEvents[index] = new PointerEventData(base.eventSystem);
			}
			else
			{
				PointEvents[index].Reset();
			}
			PointEvents[index].delta = Vector2.zero;
			PointEvents[index].position = new Vector2((float)ControllerCamera.pixelWidth * 0.5f, (float)ControllerCamera.pixelHeight * 0.5f);
			PointEvents[index].scrollDelta = Vector2.zero;
			base.eventSystem.RaycastAll(PointEvents[index], m_RaycastResultCache);
			PointEvents[index].pointerCurrentRaycast = BaseInputModule.FindFirstRaycast(m_RaycastResultCache);
			if (PointEvents[index].pointerCurrentRaycast.gameObject != null)
			{
				OnCanvas = true;
			}
			m_RaycastResultCache.Clear();
			return true;
		}

		private bool UpdateCursor(int index, PointerEventData pointData)
		{
			bool flag = false;
			if (PointEvents[index].pointerCurrentRaycast.gameObject != null && pointData.pointerEnter != null)
			{
				RectTransform component = pointData.pointerEnter.GetComponent<RectTransform>();
				if (RectTransformUtility.ScreenPointToWorldPointInRectangle(component, pointData.position, pointData.enterEventCamera, out var worldPoint))
				{
					Vector3 currentPosition = Player.Hands[index].CurrentPosition;
					Vector3 currentForward = Player.Hands[index].CurrentForward;
					Vector3 vector = worldPoint;
					float maxDistance = Vector3.Distance(currentPosition, vector);
					bool flag2 = false;
					if (GeometryBlocksLaser)
					{
						flag2 = Physics.Raycast(currentPosition, currentForward, maxDistance, LayersThatBlockLaser);
					}
					if (!flag2)
					{
						flag = true;
						Cursors[index].position = worldPoint;
						Cursors[index].rotation = component.rotation;
						Cursors[index].localScale = Vector3.one * (NormalCursorScale / 100f);
						if (LaserEnabled)
						{
							Lasers[index].enabled = true;
							Lasers[index].SetPositions(new Vector3[2] { currentPosition, vector });
						}
					}
				}
			}
			Cursors[index].gameObject.SetActive(flag);
			return flag;
		}

		public void ClearSelection()
		{
			if ((bool)base.eventSystem.currentSelectedGameObject)
			{
				base.eventSystem.SetSelectedGameObject(null);
			}
		}

		private void Select(GameObject go)
		{
			ClearSelection();
			if ((bool)ExecuteEvents.GetEventHandler<ISelectHandler>(go))
			{
				base.eventSystem.SetSelectedGameObject(go);
			}
		}

		private bool SendUpdateEventToSelectedObject()
		{
			if (base.eventSystem.currentSelectedGameObject == null)
			{
				return false;
			}
			BaseEventData baseEventData = GetBaseEventData();
			ExecuteEvents.Execute(base.eventSystem.currentSelectedGameObject, baseEventData, ExecuteEvents.updateSelectedHandler);
			return baseEventData.used;
		}

		private void UpdateCameraPosition(int index)
		{
			ControllerCamera.transform.position = Player.Hands[index].CurrentPosition;
			ControllerCamera.transform.forward = Player.Hands[index].CurrentForward;
		}

		public override void Process()
		{
		}

		private void Update()
		{
			OnCanvas = false;
			CanvasUsed = false;
			SendUpdateEventToSelectedObject();
			for (int i = 0; i < Cursors.Length; i++)
			{
				if (!Player.Hands[i].gameObject.activeInHierarchy || !Player.Hands[i].IsCurrentlyTracked)
				{
					if (Cursors[i].gameObject.activeInHierarchy)
					{
						Cursors[i].gameObject.SetActive(value: false);
					}
					continue;
				}
				UpdateCameraPosition(i);
				if (!GetLookPointerEventData(i))
				{
					continue;
				}
				CurrentPoint[i] = PointEvents[i].pointerCurrentRaycast.gameObject;
				HandlePointerExitAndEnter(PointEvents[i], CurrentPoint[i]);
				bool flag = UpdateCursor(i, PointEvents[i]);
				if (!(Player.Hands[i] != null) || !flag)
				{
					continue;
				}
				if (ButtonDownA(i))
				{
					ClearSelection();
					PointEvents[i].pressPosition = PointEvents[i].position;
					PointEvents[i].pointerPressRaycast = PointEvents[i].pointerCurrentRaycast;
					PointEvents[i].pointerPress = null;
					if (CurrentPoint[i] != null)
					{
						CurrentPressed[i] = CurrentPoint[i];
						GameObject gameObject = ExecuteEvents.ExecuteHierarchy(CurrentPressed[i], PointEvents[i], ExecuteEvents.pointerDownHandler);
						if (gameObject == null)
						{
							gameObject = ExecuteEvents.ExecuteHierarchy(CurrentPressed[i], PointEvents[i], ExecuteEvents.pointerClickHandler);
							if (gameObject != null)
							{
								CurrentPressed[i] = gameObject;
							}
						}
						else
						{
							CurrentPressed[i] = gameObject;
							ExecuteEvents.Execute(gameObject, PointEvents[i], ExecuteEvents.pointerClickHandler);
						}
						if (gameObject != null)
						{
							PointEvents[i].pointerPress = gameObject;
							CurrentPressed[i] = gameObject;
							Select(CurrentPressed[i]);
							CanvasUsed = true;
						}
						ExecuteEvents.Execute(CurrentPressed[i], PointEvents[i], ExecuteEvents.beginDragHandler);
						PointEvents[i].pointerDrag = CurrentPressed[i];
						CurrentDragging[i] = CurrentPressed[i];
					}
				}
				if (ButtonDownB(i))
				{
					ClearSelection();
					PointEvents[i].pressPosition = PointEvents[i].position;
					PointEvents[i].pointerPressRaycast = PointEvents[i].pointerCurrentRaycast;
					PointEvents[i].pointerPress = null;
					if (CurrentPoint[i] != null)
					{
						CurrentPressed[i] = CurrentPoint[i];
						GameObject gameObject2 = ExecuteEvents.ExecuteHierarchy(CurrentPressed[i], PointEvents[i], ExecuteEvents.pointerDownHandler);
						if (gameObject2 == null)
						{
							gameObject2 = ExecuteEvents.ExecuteHierarchy(CurrentPressed[i], PointEvents[i], ExecuteEvents.pointerClickHandler);
							if (gameObject2 != null)
							{
								CurrentPressed[i] = gameObject2;
							}
						}
						else
						{
							CurrentPressed[i] = gameObject2;
							ExecuteEvents.Execute(gameObject2, PointEvents[i], ExecuteEvents.pointerClickHandler);
						}
						if (gameObject2 != null)
						{
							PointEvents[i].pointerPress = gameObject2;
							CurrentPressed[i] = gameObject2;
							Select(CurrentPressed[i]);
							CanvasUsed = true;
						}
						ExecuteEvents.Execute(CurrentPressed[i], PointEvents[i], ExecuteEvents.beginDragHandler);
						PointEvents[i].pointerDrag = CurrentPressed[i];
						CurrentDragging[i] = CurrentPressed[i];
					}
				}
				if (ButtonDownX(i))
				{
					ClearSelection();
					PointEvents[i].pressPosition = PointEvents[i].position;
					PointEvents[i].pointerPressRaycast = PointEvents[i].pointerCurrentRaycast;
					PointEvents[i].pointerPress = null;
					if (CurrentPoint[i] != null)
					{
						CurrentPressed[i] = CurrentPoint[i];
						GameObject gameObject3 = ExecuteEvents.ExecuteHierarchy(CurrentPressed[i], PointEvents[i], ExecuteEvents.pointerDownHandler);
						if (gameObject3 == null)
						{
							gameObject3 = ExecuteEvents.ExecuteHierarchy(CurrentPressed[i], PointEvents[i], ExecuteEvents.pointerClickHandler);
							if (gameObject3 != null)
							{
								CurrentPressed[i] = gameObject3;
							}
						}
						else
						{
							CurrentPressed[i] = gameObject3;
							ExecuteEvents.Execute(gameObject3, PointEvents[i], ExecuteEvents.pointerClickHandler);
						}
						if (gameObject3 != null)
						{
							PointEvents[i].pointerPress = gameObject3;
							CurrentPressed[i] = gameObject3;
							Select(CurrentPressed[i]);
							CanvasUsed = true;
						}
						ExecuteEvents.Execute(CurrentPressed[i], PointEvents[i], ExecuteEvents.beginDragHandler);
						PointEvents[i].pointerDrag = CurrentPressed[i];
						CurrentDragging[i] = CurrentPressed[i];
					}
				}
				if (ButtonDownY(i))
				{
					ClearSelection();
					PointEvents[i].pressPosition = PointEvents[i].position;
					PointEvents[i].pointerPressRaycast = PointEvents[i].pointerCurrentRaycast;
					PointEvents[i].pointerPress = null;
					if (CurrentPoint[i] != null)
					{
						CurrentPressed[i] = CurrentPoint[i];
						GameObject gameObject4 = ExecuteEvents.ExecuteHierarchy(CurrentPressed[i], PointEvents[i], ExecuteEvents.pointerDownHandler);
						if (gameObject4 == null)
						{
							gameObject4 = ExecuteEvents.ExecuteHierarchy(CurrentPressed[i], PointEvents[i], ExecuteEvents.pointerClickHandler);
							if (gameObject4 != null)
							{
								CurrentPressed[i] = gameObject4;
							}
						}
						else
						{
							CurrentPressed[i] = gameObject4;
							ExecuteEvents.Execute(gameObject4, PointEvents[i], ExecuteEvents.pointerClickHandler);
						}
						if (gameObject4 != null)
						{
							PointEvents[i].pointerPress = gameObject4;
							CurrentPressed[i] = gameObject4;
							Select(CurrentPressed[i]);
							CanvasUsed = true;
						}
						ExecuteEvents.Execute(CurrentPressed[i], PointEvents[i], ExecuteEvents.beginDragHandler);
						PointEvents[i].pointerDrag = CurrentPressed[i];
						CurrentDragging[i] = CurrentPressed[i];
					}
				}
				if (ButtonUpA(i))
				{
					if ((bool)CurrentDragging[i])
					{
						ExecuteEvents.Execute(CurrentDragging[i], PointEvents[i], ExecuteEvents.endDragHandler);
						if (CurrentPoint[i] != null)
						{
							ExecuteEvents.ExecuteHierarchy(CurrentPoint[i], PointEvents[i], ExecuteEvents.dropHandler);
						}
						PointEvents[i].pointerDrag = null;
						CurrentDragging[i] = null;
					}
					if ((bool)CurrentPressed[i])
					{
						ExecuteEvents.Execute(CurrentPressed[i], PointEvents[i], ExecuteEvents.pointerUpHandler);
						PointEvents[i].rawPointerPress = null;
						PointEvents[i].pointerPress = null;
						CurrentPressed[i] = null;
					}
				}
				if (ButtonUpB(i))
				{
					if ((bool)CurrentDragging[i])
					{
						ExecuteEvents.Execute(CurrentDragging[i], PointEvents[i], ExecuteEvents.endDragHandler);
						if (CurrentPoint[i] != null)
						{
							ExecuteEvents.ExecuteHierarchy(CurrentPoint[i], PointEvents[i], ExecuteEvents.dropHandler);
						}
						PointEvents[i].pointerDrag = null;
						CurrentDragging[i] = null;
					}
					if ((bool)CurrentPressed[i])
					{
						ExecuteEvents.Execute(CurrentPressed[i], PointEvents[i], ExecuteEvents.pointerUpHandler);
						PointEvents[i].rawPointerPress = null;
						PointEvents[i].pointerPress = null;
						CurrentPressed[i] = null;
					}
				}
				if (ButtonUpX(i))
				{
					if ((bool)CurrentDragging[i])
					{
						ExecuteEvents.Execute(CurrentDragging[i], PointEvents[i], ExecuteEvents.endDragHandler);
						if (CurrentPoint[i] != null)
						{
							ExecuteEvents.ExecuteHierarchy(CurrentPoint[i], PointEvents[i], ExecuteEvents.dropHandler);
						}
						PointEvents[i].pointerDrag = null;
						CurrentDragging[i] = null;
					}
					if ((bool)CurrentPressed[i])
					{
						ExecuteEvents.Execute(CurrentPressed[i], PointEvents[i], ExecuteEvents.pointerUpHandler);
						PointEvents[i].rawPointerPress = null;
						PointEvents[i].pointerPress = null;
						CurrentPressed[i] = null;
					}
				}
				if (ButtonUpY(i))
				{
					if ((bool)CurrentDragging[i])
					{
						ExecuteEvents.Execute(CurrentDragging[i], PointEvents[i], ExecuteEvents.endDragHandler);
						if (CurrentPoint[i] != null)
						{
							ExecuteEvents.ExecuteHierarchy(CurrentPoint[i], PointEvents[i], ExecuteEvents.dropHandler);
						}
						PointEvents[i].pointerDrag = null;
						CurrentDragging[i] = null;
					}
					if ((bool)CurrentPressed[i])
					{
						ExecuteEvents.Execute(CurrentPressed[i], PointEvents[i], ExecuteEvents.pointerUpHandler);
						PointEvents[i].rawPointerPress = null;
						PointEvents[i].pointerPress = null;
						CurrentPressed[i] = null;
					}
				}
				if (CurrentDragging[i] != null)
				{
					ExecuteEvents.Execute(CurrentDragging[i], PointEvents[i], ExecuteEvents.dragHandler);
				}
			}
		}

		private bool ButtonDownA(int index)
		{
			return Player.Hands[index].Inputs[NVRButtons.Trigger].PressDownA;
		}

		private bool ButtonUpA(int index)
		{
			return Player.Hands[index].Inputs[NVRButtons.Trigger].PressUpA;
		}

		private bool ButtonDownB(int index)
		{
			return Player.Hands[index].Inputs[NVRButtons.Trigger].PressDownB;
		}

		private bool ButtonUpB(int index)
		{
			return Player.Hands[index].Inputs[NVRButtons.Trigger].PressUpB;
		}

		private bool ButtonDownX(int index)
		{
			return Player.Hands[index].Inputs[NVRButtons.Trigger].PressDownX;
		}

		private bool ButtonUpX(int index)
		{
			return Player.Hands[index].Inputs[NVRButtons.Trigger].PressUpX;
		}

		private bool ButtonDownY(int index)
		{
			return Player.Hands[index].Inputs[NVRButtons.Trigger].PressDownY;
		}

		private bool ButtonUpY(int index)
		{
			return Player.Hands[index].Inputs[NVRButtons.Trigger].PressUpY;
		}
	}
	public class NVRHand : MonoBehaviour
	{
		[Serializable]
		public class NVRInteractableEvent : UnityEvent<NVRInteractable>
		{
		}

		[HideInInspector]
		public bool IsRight;

		[HideInInspector]
		public bool IsLeft;

		[HideInInspector]
		public bool IsPrimary;

		[HideInInspector]
		public NVRPlayer Player;

		[SerializeField]
		public GameObject movementUI;

		[SerializeField]
		private GameObject fistCollider;

		[SerializeField]
		private Material standardHandMat;

		[HideInInspector]
		public NVRInteractable hoverRemoveObject;

		public Dictionary<NVRButtons, NVRButtonInputs> Inputs;

		[HideInInspector]
		public InterationStyle CurrentInteractionStyle;

		public Rigidbody Rigidbody;

		[HideInInspector]
		public GameObject CustomModel;

		[HideInInspector]
		public GameObject CustomPhysicalColliders;

		private VisibilityLevel CurrentVisibility = VisibilityLevel.Visible;

		private bool VisibilityLocked;

		[HideInInspector]
		public HandState CurrentHandState;

		[HideInInspector]
		public Dictionary<NVRInteractable, Dictionary<Collider, float>> CurrentlyHoveringOver;

		[HideInInspector]
		public NVRInteractable CurrentlyInteracting;

		[HideInInspector]
		public NVRInteractableEvent OnBeginInteraction = new NVRInteractableEvent();

		[HideInInspector]
		public NVRInteractableEvent OnEndInteraction = new NVRInteractableEvent();

		private int EstimationSampleIndex;

		private Vector3[] LastPositions;

		private Quaternion[] LastRotations;

		private float[] LastDeltas;

		private int EstimationSamples = 5;

		[HideInInspector]
		public NVRPhysicalController PhysicalController;

		private Collider[] GhostColliders;

		private Renderer[] GhostRenderers;

		[HideInInspector]
		public NVRInputDevice InputDevice;

		[HideInInspector]
		public GameObject RenderModel;

		[HideInInspector]
		public Animator handAnimator;

		[HideInInspector]
		public HandPointer handPointer;

		[HideInInspector]
		private InteractionManager interactionManager;

		[SerializeField]
		private SkinnedMeshRenderer handMeshRenderer;

		[SerializeField]
		public GameObject handAttachPoint;

		public bool fist;

		private bool interacting;

		private GameObject pointCollider;

		private bool initInputs;

		public bool isInitilised;

		private string currentAnim = string.Empty;

		[HideInInspector]
		public bool lockedByItem;

		public bool IsHovering => CurrentlyHoveringOver.Any((KeyValuePair<NVRInteractable, Dictionary<Collider, float>> kvp) => kvp.Value.Count > 0);

		public bool IsInteracting => CurrentlyInteracting != null;

		public bool HasCustomModel => CustomModel != null;

		public bool IsCurrentlyTracked
		{
			get
			{
				if (InputDevice != null)
				{
					return InputDevice.IsCurrentlyTracked;
				}
				return false;
			}
		}

		public Vector3 CurrentForward
		{
			get
			{
				if (PhysicalController != null && PhysicalController.State)
				{
					return PhysicalController.PhysicalController.transform.forward;
				}
				return base.transform.forward;
			}
		}

		public Vector3 CurrentPosition
		{
			get
			{
				if (PhysicalController != null && PhysicalController.State)
				{
					return PhysicalController.PhysicalController.transform.position;
				}
				return base.transform.position;
			}
		}

		public virtual void PreInitialize(NVRPlayer player)
		{
			Player = player;
			IsRight = Player.RightHand == this;
			IsLeft = Player.LeftHand == this;
			if (IsRight)
			{
				IsPrimary = PreferenceManager.instance.GetInt(PlayerPreferences.PRIMARY_HAND.ToString()) == 1;
			}
			else
			{
				IsPrimary = PreferenceManager.instance.GetInt(PlayerPreferences.PRIMARY_HAND.ToString()) == 0;
			}
			if (!IsPrimary)
			{
				Player.HandMenu.transform.parent.parent = base.transform;
				Player.HandMenu.transform.parent.position = base.transform.position;
				Player.HandMenu.transform.parent.rotation = base.transform.rotation;
				Player.watch.gameObject.transform.parent = base.transform;
				if (IsRight)
				{
					Player.watch.gameObject.transform.position = Player.RightHand.transform.position;
					Player.watch.SetToRight();
					Player.HandMenu.SetToRight();
				}
				else
				{
					Player.watch.gameObject.transform.position = Player.LeftHand.transform.position;
					Player.watch.SetToLeft();
					Player.HandMenu.SetToLeft();
				}
			}
			CurrentInteractionStyle = Player.InteractionStyle;
			CurrentlyHoveringOver = new Dictionary<NVRInteractable, Dictionary<Collider, float>>();
			LastPositions = new Vector3[EstimationSamples];
			LastRotations = new Quaternion[EstimationSamples];
			LastDeltas = new float[EstimationSamples];
			EstimationSampleIndex = 0;
			VisibilityLocked = false;
			Inputs = new Dictionary<NVRButtons, NVRButtonInputs>(default(NVRButtonsComparer));
			for (int i = 0; i < NVRButtonsHelper.Array.Length; i++)
			{
				if (!Inputs.ContainsKey(NVRButtonsHelper.Array[i]))
				{
					Inputs.Add(NVRButtonsHelper.Array[i], new NVRButtonInputs());
				}
			}
			if (Player.CurrentIntegrationType == NVRSDKIntegrations.Oculus)
			{
				InputDevice = base.gameObject.AddComponent<NVROculusInputDevice>();
				if (Player.OverrideOculus)
				{
					if (IsLeft)
					{
						CustomModel = Player.OverrideOculusLeftHand;
						CustomPhysicalColliders = Player.OverrideOculusLeftHandPhysicalColliders;
					}
					else if (IsRight)
					{
						CustomModel = Player.OverrideOculusRightHand;
						CustomPhysicalColliders = Player.OverrideOculusRightHandPhysicalColliders;
					}
					else
					{
						UnityEngine.Debug.LogError("[NewtonVR] Error: Unknown hand for oculus model override.");
					}
				}
			}
			else if (Player.CurrentIntegrationType == NVRSDKIntegrations.OculusQuest)
			{
				InputDevice = base.gameObject.AddComponent<NVROculusQuestInputDevice>();
				if (Player.OverrideOculusQuest)
				{
					if (IsLeft)
					{
						CustomModel = Player.OverrideOculusLeftHand;
						CustomPhysicalColliders = Player.OverrideOculusQuestLeftHandPhysicalColliders;
					}
					else if (IsRight)
					{
						CustomModel = Player.OverrideOculusRightHand;
						CustomPhysicalColliders = Player.OverrideOculusQuestRightHandPhysicalColliders;
					}
					else
					{
						UnityEngine.Debug.LogError("[NewtonVR] Error: Unknown hand for oculus model override.");
					}
				}
			}
			else if (Player.CurrentIntegrationType == NVRSDKIntegrations.SteamVR)
			{
				InputDevice = base.gameObject.AddComponent<NVRSteamVRInputDevice>();
				if (Player.OverrideSteamVR)
				{
					if (IsLeft)
					{
						CustomModel = Player.OverrideSteamVRLeftHand;
						CustomPhysicalColliders = Player.OverrideSteamVRLeftHandPhysicalColliders;
					}
					else if (IsRight)
					{
						CustomModel = Player.OverrideSteamVRRightHand;
						CustomPhysicalColliders = Player.OverrideSteamVRRightHandPhysicalColliders;
					}
					else
					{
						UnityEngine.Debug.LogError("[NewtonVR] Error: Unknown hand for SteamVR model override.");
					}
				}
			}
			else if (Player.CurrentIntegrationType == NVRSDKIntegrations.PSVR)
			{
				InputDevice = base.gameObject.AddComponent<NVRPSVRInputDevice>();
				if (Player.OverridePSVR)
				{
					if (IsRight)
					{
						CustomModel = Player.OverrideSteamVRRightHand;
						CustomPhysicalColliders = Player.OverridePSVRRightHandPhysicalColliders;
					}
					else if (IsLeft)
					{
						CustomModel = Player.OverrideSteamVRLeftHand;
						CustomPhysicalColliders = Player.OverridePSVRLeftHandPhysicalColliders;
					}
					else
					{
						UnityEngine.Debug.LogError("[NewtonVR] Error: Unknown hand for PSVR model override.");
					}
				}
			}
			else
			{
				if (Player.CurrentIntegrationType != NVRSDKIntegrations.Pico)
				{
					return;
				}
				Player.OverridePico = true;
				InputDevice = base.gameObject.AddComponent<NVRPicoInputDevice>();
				if (Player.OverridePico)
				{
					if (IsRight)
					{
						CustomModel = Player.OverridePicoRightHand;
						CustomPhysicalColliders = Player.OverridePicoRightHandPhysicalColliders;
					}
					else if (IsLeft)
					{
						CustomModel = Player.OverridePicoLeftHand;
						CustomPhysicalColliders = Player.OverridePicoLeftHandPhysicalColliders;
					}
					else
					{
						UnityEngine.Debug.LogError("[NewtonVR] Error: Unknown hand for Pico model override.");
					}
				}
			}
			if (Player.OverrideAll)
			{
				if (IsLeft)
				{
					CustomModel = Player.OverrideAllLeftHand;
					CustomPhysicalColliders = Player.OverrideAllLeftHandPhysicalColliders;
				}
				else
				{
					if (!IsRight)
					{
						UnityEngine.Debug.LogError("[NewtonVR] Error: Unknown hand for SteamVR model override.");
						return;
					}
					CustomModel = Player.OverrideAllRightHand;
					CustomPhysicalColliders = Player.OverrideAllRightHandPhysicalColliders;
				}
			}
			InputDevice.Initialize(this);
			InitializeRenderModel();
			handAnimator = GetComponentInChildren<Animator>();
			handPointer = base.gameObject.AddComponent<HandPointer>();
			handMeshRenderer = handAnimator.gameObject.GetComponentInChildren<SkinnedMeshRenderer>();
			if (IsLeft)
			{
				handPointer.fingerPos = GameObject.FindGameObjectWithTag("LeftHandPointerStart").transform;
			}
			else
			{
				handPointer.fingerPos = GameObject.FindGameObjectWithTag("RightHandPointerStart").transform;
			}
			handPointer.distanceToObject = 10f;
			handPointer.anim = handAnimator;
			UpdateHandPointer();
			SetInteractionManager();
			isInitilised = true;
			EventManager.StartListening(EventManager.AvailableEvents.SwitchedScenes.ToString(), SetInteractionManager);
		}

		public void DS4Position()
		{
			base.transform.localPosition = base.transform.localPosition + new Vector3(0f, 0.5f, 0.3f);
			base.transform.localEulerAngles = base.transform.localEulerAngles + new Vector3(-45f, 0f, 0f);
		}

		private void SetInteractionManager()
		{
			try
			{
				interactionManager = GameObject.Find("Scene").GetComponent<InteractionManager>();
			}
			catch
			{
				interactionManager = null;
			}
			if (handMeshRenderer != null)
			{
				ResetHandMaterial();
			}
		}

		public virtual void Update()
		{
			if (!isInitilised)
			{
				return;
			}
			if (CurrentHandState == HandState.Uninitialized)
			{
				if (!(InputDevice == null) && InputDevice.ReadyToInitialize())
				{
					Initialize();
				}
				return;
			}
			if (!InputDevice.inputDeviceInit && !initInputs)
			{
				StartCoroutine(InputDeviceInit());
			}
			UpdateButtonStates();
			UpdateInteractions();
			UpdateHovering();
			UpdateVisibilityAndColliders();
			if (IsPrimary)
			{
				FistAnimation();
			}
			else if (Player.HandMenu == null)
			{
				FistAnimation();
			}
			else if (!Player.HandMenu.IsActive)
			{
				FistAnimation();
			}
		}

		private IEnumerator InputDeviceInit()
		{
			initInputs = true;
			while (!InputDevice.inputDeviceInit)
			{
				yield return Yield.WaitSeconds(1f);
				InputDevice.Initialize(this);
			}
			initInputs = false;
		}

		protected void FistAnimation()
		{
			if (!lockedByItem && !IsInteracting && !handAnimator.GetBool("PointBool"))
			{
				if ((IsPrimary ? ControlsManager.instance.primaryPickupButtonDown : ControlsManager.instance.secondaryPickupButtonDown) && !fist)
				{
					fist = true;
					SetAnimation("FistBool");
					fistCollider.SetActive(value: true);
				}
				else if ((IsPrimary ? ControlsManager.instance.primaryPickupButtonUp : ControlsManager.instance.secondaryPickupButtonUp) && fist)
				{
					fist = false;
					SetAnimation("IdleBool");
					fistCollider.SetActive(value: false);
				}
			}
		}

		public void SetAnimation(string anim)
		{
			if (!lockedByItem)
			{
				handAnimator.SetBool("IdleBool", value: false);
				handAnimator.SetBool("FistBool", value: false);
				handAnimator.SetBool("PointBool", value: false);
				handAnimator.SetBool("OpenBool", value: false);
				handAnimator.SetBool("CgripBool", value: false);
				handAnimator.SetBool("LgripBool", value: false);
				handAnimator.SetBool("PinchBool", value: false);
				handAnimator.SetBool(anim, value: true);
				currentAnim = anim;
			}
		}

		public void ForceDropItem()
		{
			if ((bool)CurrentlyInteracting)
			{
				Collider collider = CurrentlyInteracting.GetComponent<Collider>();
				if (!collider)
				{
					collider = CurrentlyInteracting.GetComponentInChildren<Collider>();
				}
				EndInteraction(CurrentlyInteracting);
				OnTriggerExit(collider);
			}
		}

		protected void UpdateHovering()
		{
			if (CurrentHandState == HandState.Idle)
			{
				Dictionary<NVRInteractable, Dictionary<Collider, float>>.Enumerator enumerator = CurrentlyHoveringOver.GetEnumerator();
				while (enumerator.MoveNext())
				{
					KeyValuePair<NVRInteractable, Dictionary<Collider, float>> current = enumerator.Current;
					if (current.Value.Count > 0)
					{
						current.Key.HoveringUpdate(this, Time.time - current.Value.OrderBy((KeyValuePair<Collider, float> colliderTime) => colliderTime.Value).First().Value);
					}
					if (hoverRemoveObject != null)
					{
						if (CurrentlyHoveringOver.ContainsKey(hoverRemoveObject))
						{
							CurrentlyHoveringOver.Remove(hoverRemoveObject);
						}
						hoverRemoveObject = null;
						break;
					}
				}
			}
			if (InputDevice != null && !IsInteracting && IsHovering && Player.VibrateOnHover)
			{
				InputDevice.TriggerHapticPulse(100f, 500);
			}
		}

		protected void UpdateButtonStates()
		{
			for (int i = 0; i < NVRButtonsHelper.Array.Length; i++)
			{
				NVRButtons nVRButtons = NVRButtonsHelper.Array[i];
				Inputs[nVRButtons].FrameReset(InputDevice, nVRButtons);
			}
		}

		protected void UpdateInteractions()
		{
			if (CurrentInteractionStyle == InterationStyle.Hold)
			{
				if (IsPrimary ? ControlsManager.instance.primaryPickupButtonUp : ControlsManager.instance.secondaryPickupButtonUp)
				{
					VisibilityLocked = false;
				}
				if (IsPrimary ? ControlsManager.instance.primaryPickupButtonDown : ControlsManager.instance.secondaryPickupButtonDown)
				{
					if (CurrentlyInteracting == null)
					{
						PickupClosest();
					}
				}
				else if ((IsPrimary ? ControlsManager.instance.primaryPickupButtonUp : ControlsManager.instance.secondaryPickupButtonUp) && CurrentlyInteracting != null)
				{
					EndInteraction(null);
				}
			}
			else if (CurrentInteractionStyle == InterationStyle.Toggle)
			{
				if (IsPrimary ? ControlsManager.instance.primaryPickupButtonDown : ControlsManager.instance.secondaryPickupButtonDown)
				{
					if (CurrentHandState == HandState.Idle)
					{
						PickupClosest();
						if (IsInteracting)
						{
							CurrentHandState = HandState.GripToggleOnInteracting;
						}
						else if (Player.PhysicalHands)
						{
							CurrentHandState = HandState.GripToggleOnNotInteracting;
						}
					}
					else if (CurrentHandState == HandState.GripToggleOnInteracting)
					{
						CurrentHandState = HandState.Idle;
						VisibilityLocked = false;
						EndInteraction(null);
					}
					else if (CurrentHandState == HandState.GripToggleOnNotInteracting)
					{
						CurrentHandState = HandState.Idle;
						VisibilityLocked = false;
					}
				}
			}
			else
			{
				_ = CurrentInteractionStyle;
				_ = 2;
			}
			if (IsInteracting)
			{
				CurrentlyInteracting.InteractingUpdate(this);
			}
		}

		private void UpdateVisibilityAndColliders()
		{
			if (Player.PhysicalHands)
			{
				if (CurrentInteractionStyle == InterationStyle.Hold)
				{
					if ((IsPrimary ? ControlsManager.instance.primaryPickupButtonHold : ControlsManager.instance.secondaryPickupButtonHold) && !IsInteracting && CurrentHandState != HandState.GripDownNotInteracting && !VisibilityLocked)
					{
						VisibilityLocked = true;
						SetVisibility(VisibilityLevel.Visible);
						CurrentHandState = HandState.GripDownNotInteracting;
					}
					if ((IsPrimary ? ControlsManager.instance.primaryPickupButtonDown : ControlsManager.instance.secondaryPickupButtonDown) && IsInteracting)
					{
						if (CurrentHandState != HandState.GripDownInteracting && !VisibilityLocked)
						{
							VisibilityLocked = true;
							if (Player.MakeControllerInvisibleOnInteraction)
							{
								SetVisibility(VisibilityLevel.Invisible);
							}
							else
							{
								SetVisibility(VisibilityLevel.Ghost);
							}
							CurrentHandState = HandState.GripDownInteracting;
						}
					}
					else if (!IsInteracting && CurrentHandState != HandState.Idle && !VisibilityLocked)
					{
						SetVisibility(VisibilityLevel.Ghost);
						CurrentHandState = HandState.Idle;
					}
				}
				else
				{
					if (CurrentInteractionStyle != InterationStyle.Toggle)
					{
						return;
					}
					if (CurrentHandState == HandState.Idle)
					{
						if (!VisibilityLocked && CurrentVisibility != VisibilityLevel.Ghost)
						{
							SetVisibility(VisibilityLevel.Ghost);
						}
						else
						{
							VisibilityLocked = false;
						}
					}
					else if (CurrentHandState == HandState.GripToggleOnInteracting)
					{
						if (!VisibilityLocked)
						{
							VisibilityLocked = true;
							SetVisibility(VisibilityLevel.Ghost);
						}
					}
					else if (CurrentHandState == HandState.GripToggleOnNotInteracting && !VisibilityLocked)
					{
						VisibilityLocked = true;
						SetVisibility(VisibilityLevel.Visible);
					}
				}
			}
			else if (!Player.PhysicalHands && Player.MakeControllerInvisibleOnInteraction)
			{
				if (IsInteracting)
				{
					SetVisibility(VisibilityLevel.Invisible);
				}
				else if (!IsInteracting)
				{
					SetVisibility(VisibilityLevel.Ghost);
				}
			}
		}

		public void TriggerHapticPulse(float durationMicroSec = 500f, NVRButtons button = NVRButtons.Grip)
		{
			if (!(InputDevice != null))
			{
				return;
			}
			if (durationMicroSec < 3000f)
			{
				if (Player.CurrentIntegrationType == NVRSDKIntegrations.OculusQuest)
				{
					InputDevice.TriggerHapticPulse(durationMicroSec / 2f, (ushort)(durationMicroSec * 200f));
				}
				else if (Player.CurrentIntegrationType == NVRSDKIntegrations.SteamVR)
				{
					if (GameController.instance.isUsingAnOculus())
					{
						InputDevice.TriggerHapticPulse(40f, (ushort)(durationMicroSec * 500f));
					}
					else
					{
						InputDevice.TriggerHapticPulse(1f, (ushort)(durationMicroSec * 200f));
					}
				}
			}
			else
			{
				UnityEngine.Debug.LogWarning("You're trying to pulse for over 3000 microseconds, you probably don't want to do that. If you do, use NVRHand.LongHapticPulse(float seconds)");
			}
		}

		public void LongHapticPulse(float seconds, NVRButtons button = NVRButtons.Grip)
		{
			StartCoroutine(DoLongHapticPulse(seconds, button));
		}

		private IEnumerator DoLongHapticPulse(float seconds, NVRButtons button)
		{
			float time = Time.time;
			float endTime = time + seconds;
			while (Time.time < endTime)
			{
				TriggerHapticPulse(5f, button);
				yield return null;
			}
		}

		public Vector3 GetVelocityEstimation()
		{
			float num = LastDeltas.Sum();
			Vector3 zero = Vector3.zero;
			for (int i = 0; i < LastPositions.Length - 1; i++)
			{
				Vector3 vector = LastPositions[i + 1] - LastPositions[i];
				zero += vector;
			}
			return zero / num;
		}

		public Vector3 GetAngularVelocityEstimation()
		{
			float num = LastDeltas.Sum();
			float angle = 0f;
			Vector3 axis = Vector3.zero;
			Quaternion identity = Quaternion.identity;
			(LastRotations[LastRotations.Length - 1] * Quaternion.Inverse(LastRotations[LastRotations.Length - 2])).ToAngleAxis(out angle, out axis);
			return axis * (angle * ((float)Math.PI / 180f) / num);
		}

		public Vector3 GetPositionDelta()
		{
			int num = EstimationSampleIndex - 1;
			int num2 = EstimationSampleIndex - 2;
			if (num < 0)
			{
				num += EstimationSamples;
			}
			if (num2 < 0)
			{
				num2 += EstimationSamples;
			}
			return LastPositions[num] - LastPositions[num2];
		}

		public Quaternion GetRotationDelta()
		{
			int num = EstimationSampleIndex - 1;
			int num2 = EstimationSampleIndex - 2;
			if (num < 0)
			{
				num += EstimationSamples;
			}
			if (num2 < 0)
			{
				num2 += EstimationSamples;
			}
			return LastRotations[num] * Quaternion.Inverse(LastRotations[num2]);
		}

		protected virtual void FixedUpdate()
		{
			if (CurrentHandState != 0)
			{
				LastPositions[EstimationSampleIndex] = base.transform.position;
				LastRotations[EstimationSampleIndex] = base.transform.rotation;
				LastDeltas[EstimationSampleIndex] = Time.deltaTime;
				EstimationSampleIndex++;
				if (EstimationSampleIndex >= LastPositions.Length)
				{
					EstimationSampleIndex = 0;
				}
			}
		}

		public virtual void BeginInteraction(NVRInteractable interactable)
		{
			if (interactable.CanAttach)
			{
				if (interactable.AttachedHand != null && !interactable.AllowTwoHanded)
				{
					interactable.AttachedHand.EndInteraction(null);
				}
				CurrentlyInteracting = interactable;
				CurrentlyInteracting.BeginInteraction(this);
				if (interactionManager == null)
				{
					SetInteractionManager();
				}
				if (CurrentlyInteracting != null)
				{
					interactionManager.BeginInteraction(interactable);
				}
				if (OnBeginInteraction != null)
				{
					OnBeginInteraction.Invoke(interactable);
				}
			}
		}

		public virtual void EndInteraction(NVRInteractable item)
		{
			if (lockedByItem)
			{
				return;
			}
			if (item != null && CurrentlyHoveringOver.ContainsKey(item))
			{
				CurrentlyHoveringOver.Remove(item);
			}
			if (CurrentlyInteracting != null)
			{
				CurrentlyInteracting.EndInteraction(this);
				if (OnEndInteraction != null)
				{
					OnEndInteraction.Invoke(CurrentlyInteracting);
				}
				if (interactionManager == null)
				{
					SetInteractionManager();
				}
				if (CurrentlyInteracting != null)
				{
					interactionManager.EndInteraction(CurrentlyInteracting);
				}
				CurrentlyInteracting = null;
			}
			if (CurrentInteractionStyle == InterationStyle.Toggle && CurrentHandState != HandState.Idle)
			{
				CurrentHandState = HandState.Idle;
			}
		}

		private bool PickupClosest()
		{
			NVRInteractable nVRInteractable = null;
			float num = float.MaxValue;
			int num2 = 0;
			foreach (KeyValuePair<NVRInteractable, Dictionary<Collider, float>> item in CurrentlyHoveringOver)
			{
				if (item.Key == null && item.Key.gameObject.tag != "TriggerCollider")
				{
					continue;
				}
				if (nVRInteractable == null)
				{
					nVRInteractable = item.Key;
					num = Vector3.Distance(base.transform.position, item.Key.transform.position);
					continue;
				}
				int priority = (int)item.Key.Priority;
				if (priority >= num2)
				{
					num2 = priority;
					float num3 = Vector3.Distance(base.transform.position, item.Key.transform.position);
					if (num3 < num)
					{
						num = num3;
						nVRInteractable = item.Key;
					}
				}
			}
			if (nVRInteractable != null)
			{
				BeginInteraction(nVRInteractable);
				return true;
			}
			EndInteraction(null);
			return false;
		}

		public virtual void OnTriggerEnter(Collider collider)
		{
			TriggerInteraction(collider);
		}

		private void TriggerInteraction(Collider collider)
		{
			if (((fist || IsInteracting) && !(collider.gameObject.tag == "TriggerCollider")) || (!IsPrimary && Player.HandMenu.IsActive))
			{
				return;
			}
			if (collider.gameObject.tag == "PointCollider" && !CurrentlyInteracting)
			{
				SetAnimation("PointBool");
				return;
			}
			NVRInteractable interactable = NVRInteractables.GetInteractable(collider);
			if (interactable == null || !interactable.enabled)
			{
				return;
			}
			BreakableObject componentInChildren = interactable.gameObject.GetComponentInChildren<BreakableObject>(includeInactive: true);
			if (!componentInChildren || !componentInChildren.hasSmashed)
			{
				if (!CurrentlyHoveringOver.ContainsKey(interactable))
				{
					CurrentlyHoveringOver[interactable] = new Dictionary<Collider, float>();
				}
				if (!CurrentlyHoveringOver[interactable].ContainsKey(collider))
				{
					CurrentlyHoveringOver[interactable][collider] = Time.time;
				}
				interacting = true;
				if (collider.gameObject.tag != "TriggerCollider" && collider.gameObject.tag != "PointInteractable" && !handAnimator.GetBool("OpenBool") && interactable.CanAttach)
				{
					SetAnimation("OpenBool");
				}
				if (interactionManager == null)
				{
					SetInteractionManager();
				}
				interactionManager.OnTriggerEnter(collider);
			}
		}

		public virtual void OnTriggerStay(Collider collider)
		{
			TriggerInteraction(collider);
		}

		public virtual void OnTriggerExit(Collider collider)
		{
			if (fist || (!IsPrimary && Player.HandMenu.IsActive))
			{
				return;
			}
			if (collider.gameObject.tag == "PointCollider")
			{
				if (currentAnim == "PointBool")
				{
					SetAnimation("IdleBool");
				}
				return;
			}
			NVRInteractable interactable = NVRInteractables.GetInteractable(collider);
			if (interactable == null)
			{
				return;
			}
			if (CurrentlyHoveringOver.ContainsKey(interactable) && CurrentlyHoveringOver[interactable].ContainsKey(collider))
			{
				CurrentlyHoveringOver[interactable].Remove(collider);
				if (CurrentlyHoveringOver[interactable].Count == 0)
				{
					CurrentlyHoveringOver.Remove(interactable);
				}
			}
			if (interactionManager == null)
			{
				SetInteractionManager();
			}
			if ((bool)interactionManager)
			{
				interactionManager.OnTriggerExit(collider);
			}
			interacting = false;
			if (collider.gameObject.tag != "TriggerCollider" && collider.gameObject.tag != "PointInteractable" && CurrentlyInteracting == null)
			{
				SetAnimation("IdleBool");
			}
		}

		public void OnPointerEnter(Collider collider)
		{
			if (interactionManager == null)
			{
				SetInteractionManager();
			}
			interactionManager.OnPointerEnter(collider);
		}

		public void OnPointerStay(Collider collider)
		{
			if (interactionManager == null)
			{
				SetInteractionManager();
			}
			interactionManager.OnPointerStay(collider);
		}

		public void OnPointerExit(Collider collider)
		{
			if (interactionManager == null)
			{
				SetInteractionManager();
			}
			interactionManager.OnPointerExit(collider);
		}

		public string GetDeviceName()
		{
			if (InputDevice != null)
			{
				return InputDevice.GetDeviceName();
			}
			return null;
		}

		public Collider[] SetupDefaultPhysicalColliders(Transform ModelParent)
		{
			return InputDevice.SetupDefaultPhysicalColliders(ModelParent);
		}

		public void DeregisterInteractable(NVRInteractable interactable)
		{
			if (CurrentlyInteracting == interactable)
			{
				CurrentlyInteracting = null;
			}
			if (CurrentlyHoveringOver != null && CurrentlyHoveringOver.ContainsKey(interactable))
			{
				CurrentlyHoveringOver.Remove(interactable);
			}
		}

		public void SetVisibility(VisibilityLevel visibility)
		{
			if (CurrentVisibility != visibility)
			{
				if (visibility == VisibilityLevel.Invisible)
				{
					if (PhysicalController != null)
					{
						PhysicalController.Off();
					}
					if (Player.AutomaticallySetControllerTransparency)
					{
						for (int i = 0; i < GhostRenderers.Length; i++)
						{
							GhostRenderers[i].enabled = false;
						}
					}
				}
				if (visibility == VisibilityLevel.Ghost)
				{
					if (PhysicalController != null)
					{
						PhysicalController.Off();
					}
					if (Player.AutomaticallySetControllerTransparency)
					{
						for (int j = 0; j < GhostRenderers.Length; j++)
						{
							GhostRenderers[j].enabled = true;
						}
						for (int k = 0; k < GhostColliders.Length; k++)
						{
							GhostColliders[k].enabled = true;
						}
					}
				}
				if (visibility == VisibilityLevel.Visible)
				{
					if (PhysicalController != null)
					{
						PhysicalController.On();
					}
					if (Player.AutomaticallySetControllerTransparency)
					{
						for (int l = 0; l < GhostRenderers.Length; l++)
						{
							GhostRenderers[l].enabled = false;
						}
						for (int m = 0; m < GhostColliders.Length; m++)
						{
							GhostColliders[m].enabled = false;
						}
					}
				}
			}
			CurrentVisibility = visibility;
		}

		protected void InitializeRenderModel()
		{
			if (CustomModel == null)
			{
				RenderModel = InputDevice.SetupDefaultRenderModel();
				return;
			}
			RenderModel = UnityEngine.Object.Instantiate(CustomModel);
			RenderModel.transform.parent = base.transform;
			RenderModel.transform.localScale = RenderModel.transform.localScale;
			RenderModel.transform.localPosition = Vector3.zero;
			RenderModel.transform.localRotation = Quaternion.identity;
		}

		public void Initialize()
		{
			Rigidbody = GetComponent<Rigidbody>();
			if (Rigidbody == null)
			{
				Rigidbody = base.gameObject.AddComponent<Rigidbody>();
			}
			Rigidbody.isKinematic = true;
			Rigidbody.maxAngularVelocity = float.MaxValue;
			Rigidbody.useGravity = false;
			Collider[] array = null;
			array = ((!(CustomModel == null)) ? RenderModel.GetComponentsInChildren<Collider>() : InputDevice.SetupDefaultColliders());
			Player.RegisterHand(this);
			if (Player.PhysicalHands)
			{
				if (PhysicalController != null)
				{
					PhysicalController.Kill();
				}
				PhysicalController = base.gameObject.AddComponent<NVRPhysicalController>();
				PhysicalController.Initialize(this, initialState: false);
				if (Player.AutomaticallySetControllerTransparency)
				{
					UnityEngine.Color white = UnityEngine.Color.white;
					white.a = 0.7f;
					GhostRenderers = GetComponentsInChildren<Renderer>();
					for (int i = 0; i < GhostRenderers.Length; i++)
					{
						NVRHelpers.SetTransparent(GhostRenderers[i].material, white);
					}
				}
				if (array != null)
				{
					GhostColliders = array;
				}
				CurrentVisibility = VisibilityLevel.Ghost;
			}
			else
			{
				if (Player.AutomaticallySetControllerTransparency)
				{
					UnityEngine.Color white2 = UnityEngine.Color.white;
					white2.a = 0.7f;
					GhostRenderers = GetComponentsInChildren<Renderer>();
					for (int j = 0; j < GhostRenderers.Length; j++)
					{
						NVRHelpers.SetTransparent(GhostRenderers[j].material, white2);
					}
				}
				if (array != null)
				{
					GhostColliders = array;
				}
				CurrentVisibility = VisibilityLevel.Ghost;
			}
			CurrentHandState = HandState.Idle;
		}

		public void UpdateHandPointer()
		{
			handPointer.SwapHands(IsPrimary);
		}

		public void ForceGhost()
		{
			SetVisibility(VisibilityLevel.Ghost);
			PhysicalController.Off();
		}

		public void ToggleInteractionStyle()
		{
			if (PreferenceManager.instance.GetInt(PlayerPreferences.GRIP.ToString()) == 0)
			{
				CurrentInteractionStyle = InterationStyle.Toggle;
			}
			else
			{
				CurrentInteractionStyle = InterationStyle.Hold;
			}
		}

		public void ToggleMovementUI()
		{
			if (!IsPrimary)
			{
				if (movementUI.activeInHierarchy)
				{
					movementUI.SetActive(value: false);
				}
				else
				{
					movementUI.SetActive(value: true);
				}
			}
			else
			{
				movementUI.SetActive(value: false);
			}
		}

		public void SwapOutHandMaterial(Material mat)
		{
			handMeshRenderer.material = mat;
		}

		public void ResetHandMaterial()
		{
			handMeshRenderer.material = standardHandMat;
		}
	}
	public enum VisibilityLevel
	{
		Invisible = 0,
		Ghost = 70,
		Visible = 100
	}
	public enum HandState
	{
		Uninitialized,
		Idle,
		GripDownNotInteracting,
		GripDownInteracting,
		GripToggleOnNotInteracting,
		GripToggleOnInteracting,
		GripToggleOff
	}
	public enum InterationStyle
	{
		Hold,
		Toggle,
		ByScript
	}
	public class NVRHead : MonoBehaviour
	{
		public void Initialize()
		{
		}
	}
	public class NVRHelpers
	{
		private static Shader standardShader;

		private static Shader StandardShader
		{
			get
			{
				if (standardShader == null)
				{
					standardShader = Shader.Find("Standard");
				}
				return standardShader;
			}
		}

		public static void SetTransparent(Material material, UnityEngine.Color? newcolor = null)
		{
			if (material.shader != StandardShader)
			{
				UnityEngine.Debug.LogWarning("Trying to set transparent mode on non-standard shader. Please use the Standard Shader instead or modify this method.");
			}
			material.SetOverrideTag("RenderType", "Transparent");
			material.SetInt("_SrcBlend", 5);
			material.SetInt("_DstBlend", 10);
			material.SetInt("_ZWrite", 0);
			material.DisableKeyword("_ALPHATEST_ON");
			material.DisableKeyword("_ALPHABLEND_ON");
			material.EnableKeyword("_ALPHAPREMULTIPLY_ON");
			material.SetFloat("_Metallic", 0f);
			material.SetFloat("_Glossiness", 0f);
			material.renderQueue = 3000;
			material.mainTexture = null;
			if (newcolor.HasValue)
			{
				material.color = newcolor.Value;
			}
		}

		public static void SetOpaque(Material material)
		{
			if (material.shader != StandardShader)
			{
				UnityEngine.Debug.LogWarning("Trying to set opaque mode on non-standard shader. Please use the Standard Shader instead or modify this method.");
			}
			material.SetOverrideTag("RenderType", "");
			material.SetInt("_SrcBlend", 1);
			material.SetInt("_DstBlend", 0);
			material.SetInt("_ZWrite", 1);
			material.DisableKeyword("_ALPHATEST_ON");
			material.DisableKeyword("_ALPHABLEND_ON");
			material.DisableKeyword("_ALPHAPREMULTIPLY_ON");
			material.renderQueue = -1;
		}

		public static void SetProperty(object obj, string propertyName, object value, bool isPublic)
		{
			BindingFlags bindingFlags = BindingFlags.Instance;
			bindingFlags = ((!isPublic) ? (bindingFlags | BindingFlags.NonPublic) : (bindingFlags | BindingFlags.Public));
			obj.GetType().GetProperty(propertyName, bindingFlags).SetValue(obj, value, null);
		}

		public static void SetField(object obj, string fieldName, object value, bool isPublic)
		{
			BindingFlags bindingFlags = BindingFlags.Instance;
			bindingFlags = ((!isPublic) ? (bindingFlags | BindingFlags.NonPublic) : (bindingFlags | BindingFlags.Public));
			obj.GetType().GetField(fieldName, bindingFlags).SetValue(obj, value);
		}

		public static void LineRendererSetColor(LineRenderer lineRenderer, UnityEngine.Color startColor, UnityEngine.Color endColor)
		{
			lineRenderer.startColor = startColor;
			lineRenderer.endColor = endColor;
		}

		public static void LineRendererSetWidth(LineRenderer lineRenderer, float startWidth, float endWidth)
		{
			lineRenderer.startWidth = startWidth;
			lineRenderer.endWidth = endWidth;
		}

		public static Quaternion AverageQuaternion(ref Vector4 cumulative, Quaternion newRotation, Quaternion firstRotation, int addAmount)
		{
			float num = 0f;
			float num2 = 0f;
			float num3 = 0f;
			if (!AreQuaternionsClose(newRotation, firstRotation))
			{
				newRotation = InverseSignQuaternion(newRotation);
			}
			float num4 = 1f / (float)addAmount;
			cumulative.w += newRotation.w;
			num = cumulative.w * num4;
			cumulative.x += newRotation.x;
			float x = cumulative.x * num4;
			cumulative.y += newRotation.y;
			num2 = cumulative.y * num4;
			cumulative.z += newRotation.z;
			num3 = cumulative.z * num4;
			return NormalizeQuaternion(x, num2, num3, num);
		}

		public static Quaternion NormalizeQuaternion(float x, float y, float z, float w)
		{
			float num = 1f / (w * w + x * x + y * y + z * z);
			w *= num;
			x *= num;
			y *= num;
			z *= num;
			return new Quaternion(x, y, z, w);
		}

		public static Quaternion InverseSignQuaternion(Quaternion q)
		{
			return new Quaternion(0f - q.x, 0f - q.y, 0f - q.z, 0f - q.w);
		}

		public static bool AreQuaternionsClose(Quaternion q1, Quaternion q2)
		{
			if (Quaternion.Dot(q1, q2) < 0f)
			{
				return false;
			}
			return true;
		}
	}
	public abstract class NVRInputDevice : MonoBehaviour
	{
		public enum VibrationForce
		{
			Light,
			Medium,
			Hard
		}

		protected NVRHand Hand;

		public bool inputDeviceInit;

		public abstract bool IsCurrentlyTracked { get; }

		public virtual void Initialize(NVRHand hand)
		{
			Hand = hand;
		}

		public abstract Collider[] SetupDefaultPhysicalColliders(Transform ModelParent);

		public abstract GameObject SetupDefaultRenderModel();

		public abstract bool ReadyToInitialize();

		public abstract Collider[] SetupDefaultColliders();

		public abstract string GetDeviceName();

		public abstract void TriggerHapticPulse(float power = 0.2f, ushort durationMicroSec = 500, NVRButtons button = NVRButtons.Touchpad);

		public abstract void TriggerHapticPulse(VibrationForce force, float time);

		public abstract bool GetAxis1DRightUp(NVRButtons button);

		public abstract bool GetAxis1DLeftUp(NVRButtons button);

		public abstract bool GetAxis1DRightDown(NVRButtons button);

		public abstract bool GetAxis1DLeftDown(NVRButtons button);

		public abstract bool GetLeftDown(NVRButtons button);

		public abstract bool GetRightDown(NVRButtons button);

		public abstract bool GetLeftUp(NVRButtons button);

		public abstract bool GetRightUp(NVRButtons button);

		public abstract Vector2 GetAxis2DRight(NVRButtons button);

		public abstract Vector2 GetAxis2DLeft(NVRButtons button);

		public abstract bool GetPressDownX(NVRButtons button);

		public abstract bool GetPressDownY(NVRButtons button);

		public abstract bool GetPressDownA(NVRButtons button);

		public abstract bool GetPressDownB(NVRButtons button);

		public abstract bool GetPressDownApp(NVRButtons button);

		public abstract bool GetPressUpX(NVRButtons button);

		public abstract bool GetPressUpY(NVRButtons button);

		public abstract bool GetPressUpA(NVRButtons button);

		public abstract bool GetPressUpB(NVRButtons button);

		public abstract bool GetPressUpApp(NVRButtons button);

		public abstract bool GetPressA(NVRButtons button);

		public abstract bool GetPressB(NVRButtons button);

		public abstract bool GetPressX(NVRButtons button);

		public abstract bool GetPressY(NVRButtons button);

		public abstract bool GetPressGripLeft(NVRButtons button);

		public abstract bool GetPressGripRight(NVRButtons button);

		public abstract bool GetPressTriggerLeft(NVRButtons button);

		public abstract bool GetPressTriggerRight(NVRButtons button);

		public abstract bool GetPressAppLeft(NVRButtons button);

		public abstract bool GetPressAppRight(NVRButtons button);
	}
	public abstract class NVRIntegration
	{
		protected NVRPlayer Player;

		public abstract void Initialize(NVRPlayer player);

		public abstract Vector3 GetPlayspaceBounds();

		public abstract bool IsHmdPresent();
	}
	public abstract class NVRInteractable : MonoBehaviour
	{
		public enum PRIORITIES
		{
			LOW,
			MEDIUM,
			HIGH
		}

		public PRIORITIES Priority = PRIORITIES.MEDIUM;

		public Rigidbody Rigidbody;

		public bool CanAttach = true;

		public bool AllowTwoHanded;

		public bool DisableKinematicOnAttach = true;

		public bool EnableKinematicOnDetach;

		public float DropDistance = 1f;

		public bool EnableGravityOnDetach = true;

		public bool EnableReparentOnDetach;

		public bool ReparentToRoomOnDetach = true;

		protected Transform originalParent;

		public List<NVRHand> AttachedHands = new List<NVRHand>();

		protected Collider[] Colliders = new Collider[0];

		protected Vector3 ClosestHeldPoint;

		[SerializeField]
		public bool hideHands;

		public bool lockItem;

		[HideInInspector]
		public bool lockedToHand;

		protected float storedDropDist;

		protected Vector3 startPosition = Vector3.zero;

		public NVRHand AttachedHand
		{
			get
			{
				if (AttachedHands.Count == 0)
				{
					return null;
				}
				return AttachedHands[0];
			}
		}

		public virtual bool IsAttached => AttachedHand != null;

		protected virtual void Awake()
		{
			if (Rigidbody == null)
			{
				Rigidbody = GetComponent<Rigidbody>();
			}
			if (Rigidbody == null)
			{
				UnityEngine.Debug.LogError("There is no rigidbody attached to this interactable. = " + base.gameObject.name);
			}
			originalParent = base.transform.parent;
		}

		protected virtual void Start()
		{
			UpdateColliders();
			startPosition = Rigidbody.position;
		}

		public virtual void ResetInteractable()
		{
			Awake();
			Start();
			AttachedHands.Clear();
		}

		public virtual void UpdateColliders()
		{
			Colliders = GetComponentsInChildren<Collider>();
			NVRInteractables.Register(this, Colliders);
		}

		protected virtual bool CheckForDrop()
		{
			for (int i = 0; i < AttachedHands.Count; i++)
			{
				float num = float.MaxValue;
				NVRHand nVRHand = AttachedHands[i];
				for (int j = 0; j < Colliders.Length; j++)
				{
					Vector3 vector = Colliders[j].ClosestPointOnBounds(nVRHand.transform.position);
					float num2 = Vector3.Distance(nVRHand.transform.position, vector);
					if (num2 < num)
					{
						num = num2;
						ClosestHeldPoint = vector;
					}
				}
				if (DropDistance != -1f && nVRHand.CurrentInteractionStyle != InterationStyle.ByScript && num > DropDistance)
				{
					DroppedBecauseOfDistance(nVRHand);
					if (!IsAttached)
					{
						return true;
					}
				}
			}
			return false;
		}

		protected virtual void Update()
		{
		}

		public virtual void BeginInteraction(NVRHand hand, bool runBeginInteractionCallback = true)
		{
			if (base.gameObject.tag != "Fixture")
			{
				base.transform.parent = null;
			}
			AttachedHands.Add(hand);
			if (DisableKinematicOnAttach)
			{
				Rigidbody.isKinematic = false;
			}
		}

		public virtual void InteractingUpdate(NVRHand hand)
		{
		}

		public virtual void HoveringUpdate(NVRHand hand, float forTime)
		{
		}

		public void ForceDetach(NVRHand hand = null)
		{
			if (hand != null)
			{
				hand.EndInteraction(this);
				EndInteraction(hand);
				return;
			}
			for (int i = 0; i < AttachedHands.Count; i++)
			{
				AttachedHands[i].EndInteraction(this);
				EndInteraction(AttachedHands[i]);
			}
		}

		public virtual void EndInteraction(NVRHand hand)
		{
			AttachedHands.Remove(hand);
			ClosestHeldPoint = Vector3.zero;
			if (EnableKinematicOnDetach)
			{
				Rigidbody.isKinematic = true;
			}
			if (EnableGravityOnDetach)
			{
				Rigidbody.useGravity = true;
			}
			if (ReparentToRoomOnDetach)
			{
				Room currentRoom = GameController.instance.currentRoom;
				if (currentRoom != null)
				{
					if (currentRoom.associatedParentGameObject != null)
					{
						if (base.gameObject.activeInHierarchy)
						{
							base.transform.parent = currentRoom.associatedParentGameObject.transform;
						}
						BreakableObject component = base.gameObject.GetComponent<BreakableObject>();
						if (component != null)
						{
							component.fragmentsParent = currentRoom.associatedParentGameObject.transform;
						}
					}
					else
					{
						base.transform.parent = originalParent;
					}
				}
				else
				{
					base.transform.parent = originalParent;
				}
			}
			if (EnableReparentOnDetach)
			{
				base.transform.parent = originalParent;
			}
		}

		protected virtual void DroppedBecauseOfDistance(NVRHand hand)
		{
			hand.EndInteraction(this);
		}

		public virtual void UseButtonUp()
		{
		}

		public virtual void UseButtonDown()
		{
		}

		public virtual void AddExternalVelocity(Vector3 velocity)
		{
			Rigidbody.AddForce(velocity, ForceMode.VelocityChange);
		}

		public virtual void AddExternalAngularVelocity(Vector3 angularVelocity)
		{
			Rigidbody.AddTorque(angularVelocity, ForceMode.VelocityChange);
		}

		protected virtual void OnDestroy()
		{
			ForceDetach();
			NVRInteractables.Deregister(this);
		}
	}
	public class NVRInteractableItem : NVRInteractable
	{
		public enum GripTypes
		{
			C,
			L,
			Pinch
		}

		[SerializeField]
		private bool respawnIfOOR;

		public bool EditMode;

		private const float MaxVelocityChange = 10f;

		private const float MaxAngularVelocityChange = 20f;

		private const float VelocityMagic = 6000f;

		private const float AngularVelocityMagic = 50f;

		[Tooltip("If you have a specific point you'd like the object held at, create a transform there and set it to this variable")]
		public Transform InteractionPointRight;

		public Transform InteractionPointLeft;

		public UnityEvent OnUseButtonDown;

		public UnityEvent OnUseButtonUp;

		public UnityEvent OnHovering;

		public UnityEvent OnBeginInteraction;

		public UnityEvent OnEndInteraction;

		public Dictionary<NVRHand, Transform> PickupTransforms = new Dictionary<NVRHand, Transform>();

		protected Vector3 ExternalVelocity;

		protected Vector3 ExternalAngularVelocity;

		protected Vector3?[] VelocityHistory;

		protected Vector3?[] AngularVelocityHistory;

		protected int CurrentVelocityHistoryStep;

		protected float StartingDrag = -1f;

		protected float StartingAngularDrag = -1f;

		protected Dictionary<Collider, PhysicMaterial> MaterialCache = new Dictionary<Collider, PhysicMaterial>();

		protected float resetTime = 5f;

		protected float resetElaspedTime;

		protected Vector3 origionalPosition;

		protected Quaternion origionalRotation;

		public bool ignoreInteractableTrigger;

		[SerializeField]
		protected bool isHint;

		[SerializeField]
		protected MeshRenderer[] meshArrayForHighlighting;

		[SerializeField]
		protected SkinnedMeshRenderer[] skinnedMeshArrayForHighlighting;

		protected Material highlightingMaterial;

		[HideInInspector]
		public bool isHighlighting;

		[Space]
		public GripTypes gripType;

		[Range(0f, 1f)]
		public float gripPercentage;

		private AnimationClip[] animClips;

		private Renderer[] handRenderersRight;

		private Renderer[] handRenderersLeft;

		[SerializeField]
		private Sprite instructionUISteam;

		[SerializeField]
		private Sprite instructionUIOculus;

		[SerializeField]
		private Sprite instructionUIOculusQuest;

		[SerializeField]
		private Sprite instructionUIPico;

		[SerializeField]
		private SpriteRenderer instructionUIPlacementLeft;

		[SerializeField]
		private SpriteRenderer instructionUIPlacementRight;

		[SerializeField]
		private bool instructionUIAlwaysShow;

		[SerializeField]
		private float instructionUITimeTillDestroy = 4f;

		[SerializeField]
		private bool hasSeenUI;

		private bool fadingUI;

		private bool isOutOfReach;

		[SerializeField]
		private bool hasTranslation;

		public Transform OriginalParent
		{
			get
			{
				return originalParent;
			}
			set
			{
				originalParent = value;
			}
		}

		protected override void Awake()
		{
			base.Awake();
			Rigidbody.maxAngularVelocity = 100f;
		}

		protected override void Start()
		{
			base.Start();
			if (NVRPlayer.Instance.VelocityHistorySteps > 0)
			{
				VelocityHistory = new Vector3?[NVRPlayer.Instance.VelocityHistorySteps];
				AngularVelocityHistory = new Vector3?[NVRPlayer.Instance.VelocityHistorySteps];
			}
			originalParent = base.transform.parent;
			origionalPosition = base.transform.position;
			origionalRotation = base.transform.rotation;
			if (isHint)
			{
				highlightingMaterial = (Material)Resources.Load("HoverHighlight", typeof(Material));
			}
			if (instructionUIPlacementLeft != null)
			{
				LeanTween.alpha(instructionUIPlacementLeft.gameObject, 0f, 0f);
			}
			if (instructionUIPlacementRight != null)
			{
				LeanTween.alpha(instructionUIPlacementLeft.gameObject, 0f, 0f);
			}
			storedDropDist = DropDistance;
			if (GetType() == typeof(ExorcismItem))
			{
				ExorcismItem exorcismItem = (ExorcismItem)this;
				if (exorcismItem.type == ExorcismItem.ExItemType.HOLYWATER)
				{
					hasSeenUI = PreferenceManager.instance.GetBool(PlayerPreferences.HAS_SEEN_HOLYWATER_UI.ToString());
				}
				else if (exorcismItem.type == ExorcismItem.ExItemType.LIGHTER)
				{
					hasSeenUI = PreferenceManager.instance.GetBool(PlayerPreferences.HAS_SEEN_LIGHTER_UI.ToString());
				}
				else if (exorcismItem.type == ExorcismItem.ExItemType.SALT)
				{
					hasSeenUI = PreferenceManager.instance.GetBool(PlayerPreferences.HAS_SEEN_SALTSPRAYER_UI.ToString());
				}
			}
		}

		protected virtual void FixedUpdate()
		{
			if (IsAttached && !CheckForDrop())
			{
				UpdateVelocities();
			}
			AddExternalVelocities();
		}

		private new void Update()
		{
			if (EditMode)
			{
				if (Input.GetKeyDown(KeyCode.UpArrow))
				{
					gripType = (GripTypes)((int)(gripType + 1) % 3);
				}
				if (Input.GetKeyDown(KeyCode.LeftArrow))
				{
					gripPercentage -= 0.1f;
					if (gripPercentage < 1f)
					{
						gripPercentage = 1f;
					}
				}
				if (Input.GetKeyDown(KeyCode.RightArrow))
				{
					gripPercentage += 0.1f;
					if (gripPercentage > 1f)
					{
						gripPercentage = 0f;
					}
				}
				if (base.AttachedHand != null)
				{
					EditInteractionPoint(base.AttachedHand);
				}
			}
			if (!isOutOfReach)
			{
				return;
			}
			if (base.AttachedHand != null)
			{
				resetElaspedTime = 0f;
				return;
			}
			resetElaspedTime += Time.deltaTime;
			if (resetElaspedTime >= resetTime)
			{
				resetElaspedTime = 0f;
				base.transform.position = origionalPosition;
				base.transform.rotation = origionalRotation;
				Rigidbody.velocity = Vector3.zero;
				Rigidbody.angularVelocity = Vector3.zero;
				isOutOfReach = false;
			}
		}

		protected virtual void GetTargetValues(out Vector3 targetHandPosition, out Quaternion targetHandRotation, out Vector3 targetItemPosition, out Quaternion targetItemRotation)
		{
			if (AttachedHands.Count == 1)
			{
				NVRHand nVRHand = AttachedHands[0];
				if (!EditMode)
				{
					if (nVRHand.IsRight && InteractionPointRight != null)
					{
						targetItemPosition = InteractionPointRight.position;
						targetItemRotation = InteractionPointRight.rotation;
						targetHandPosition = nVRHand.handAttachPoint.transform.position;
						targetHandRotation = nVRHand.handAttachPoint.transform.rotation;
					}
					else if (nVRHand.IsLeft && InteractionPointLeft != null)
					{
						targetItemPosition = InteractionPointLeft.position;
						targetItemRotation = InteractionPointLeft.rotation;
						targetHandPosition = nVRHand.handAttachPoint.transform.position;
						targetHandRotation = nVRHand.handAttachPoint.transform.rotation;
					}
					else
					{
						targetItemPosition = base.transform.position;
						targetItemRotation = base.transform.rotation;
						targetHandPosition = PickupTransforms[nVRHand].position;
						targetHandRotation = PickupTransforms[nVRHand].rotation;
					}
				}
				else
				{
					targetItemPosition = base.transform.position;
					targetItemRotation = base.transform.rotation;
					targetHandPosition = PickupTransforms[nVRHand].position;
					targetHandRotation = PickupTransforms[nVRHand].rotation;
				}
				return;
			}
			Vector3 zero = Vector3.zero;
			Vector4 cumulative = Vector4.zero;
			Quaternion? quaternion = null;
			targetItemRotation = Quaternion.identity;
			Vector3 zero2 = Vector3.zero;
			Vector4 cumulative2 = Vector4.zero;
			Quaternion? quaternion2 = null;
			targetHandRotation = Quaternion.identity;
			for (int i = 0; i < AttachedHands.Count; i++)
			{
				NVRHand nVRHand2 = AttachedHands[i];
				if (!EditMode)
				{
					if (nVRHand2.IsRight && InteractionPointRight != null && i == 0)
					{
						targetItemRotation = InteractionPointRight.rotation;
						zero += InteractionPointRight.position;
						targetHandRotation = nVRHand2.transform.rotation;
						zero2 += nVRHand2.transform.position;
					}
					else if (nVRHand2.IsLeft && InteractionPointLeft != null && i == 0)
					{
						targetItemRotation = InteractionPointLeft.rotation;
						zero += InteractionPointLeft.position;
						targetHandRotation = nVRHand2.transform.rotation;
						zero2 += nVRHand2.transform.position;
					}
					else
					{
						targetItemRotation = base.transform.rotation;
						zero += base.transform.position;
						targetHandRotation = PickupTransforms[nVRHand2].rotation;
						zero2 += PickupTransforms[nVRHand2].position;
					}
				}
				else
				{
					targetItemRotation = base.transform.rotation;
					zero += base.transform.position;
					targetHandRotation = PickupTransforms[nVRHand2].rotation;
					zero2 += PickupTransforms[nVRHand2].position;
				}
				if (!quaternion.HasValue)
				{
					quaternion = targetItemRotation;
				}
				if (!quaternion2.HasValue)
				{
					quaternion2 = targetHandRotation;
				}
				targetItemRotation = NVRHelpers.AverageQuaternion(ref cumulative, targetItemRotation, quaternion.Value, i);
				targetHandRotation = NVRHelpers.AverageQuaternion(ref cumulative2, targetHandRotation, quaternion2.Value, i);
			}
			targetItemPosition = zero / AttachedHands.Count;
			targetHandPosition = zero2 / AttachedHands.Count;
		}

		protected virtual void UpdateVelocities()
		{
			GetTargetValues(out var targetHandPosition, out var targetHandRotation, out var targetItemPosition, out var targetItemRotation);
			float num = 6000f / (Time.deltaTime / 0.0111f);
			float num2 = 50f / (Time.deltaTime / 0.0111f);
			Vector3 vector = targetHandPosition - targetItemPosition;
			Quaternion quaternion = targetHandRotation * Quaternion.Inverse(targetItemRotation);
			Vector3 target = vector * num * Time.deltaTime;
			if (!float.IsNaN(target.x))
			{
				Rigidbody.velocity = Vector3.MoveTowards(Rigidbody.velocity, target, 10f);
			}
			quaternion.ToAngleAxis(out var angle, out var axis);
			if (angle > 180f)
			{
				angle -= 360f;
			}
			if (angle != 0f)
			{
				Vector3 vector2 = angle * axis;
				if (!float.IsNaN(vector2.x))
				{
					vector2 = vector2 * num2 * Time.deltaTime;
					Rigidbody.angularVelocity = Vector3.MoveTowards(Rigidbody.angularVelocity, vector2, 20f);
				}
			}
			if (VelocityHistory != null)
			{
				CurrentVelocityHistoryStep++;
				if (CurrentVelocityHistoryStep >= VelocityHistory.Length)
				{
					CurrentVelocityHistoryStep = 0;
				}
				VelocityHistory[CurrentVelocityHistoryStep] = Rigidbody.velocity;
				AngularVelocityHistory[CurrentVelocityHistoryStep] = Rigidbody.angularVelocity;
			}
		}

		protected virtual void AddExternalVelocities()
		{
			if (ExternalVelocity != Vector3.zero)
			{
				Rigidbody.velocity = Vector3.Lerp(Rigidbody.velocity, ExternalVelocity, 0.5f);
				ExternalVelocity = Vector3.zero;
			}
			if (ExternalAngularVelocity != Vector3.zero)
			{
				Rigidbody.angularVelocity = Vector3.Lerp(Rigidbody.angularVelocity, ExternalAngularVelocity, 0.5f);
				ExternalAngularVelocity = Vector3.zero;
			}
		}

		public override void AddExternalVelocity(Vector3 velocity)
		{
			if (ExternalVelocity == Vector3.zero)
			{
				ExternalVelocity = velocity;
			}
			else
			{
				ExternalVelocity = Vector3.Lerp(ExternalVelocity, velocity, 0.5f);
			}
		}

		public override void AddExternalAngularVelocity(Vector3 angularVelocity)
		{
			if (ExternalAngularVelocity == Vector3.zero)
			{
				ExternalAngularVelocity = angularVelocity;
			}
			else
			{
				ExternalAngularVelocity = Vector3.Lerp(ExternalAngularVelocity, angularVelocity, 0.5f);
			}
		}

		public override void BeginInteraction(NVRHand hand, bool runBeginInteractionCallback = true)
		{
			if (lockItem)
			{
				return;
			}
			base.BeginInteraction(hand);
			if (hasTranslation)
			{
				HUD.Instance.PlaySubtitles(base.gameObject.name, hasPriority: false);
			}
			StartingDrag = Rigidbody.drag;
			StartingAngularDrag = Rigidbody.angularDrag;
			Rigidbody.drag = 0f;
			Rigidbody.angularDrag = 0.05f;
			DisablePhysicalMaterials();
			Transform transform = new GameObject($"[{base.gameObject.name}] NVRPickupTransform").transform;
			transform.parent = hand.transform;
			transform.position = base.transform.position;
			transform.rotation = base.transform.rotation;
			PickupTransforms.Add(hand, transform);
			ResetVelocityHistory();
			if (OnBeginInteraction != null && runBeginInteractionCallback)
			{
				OnBeginInteraction.Invoke();
			}
			if (hideHands)
			{
				DisableHandRender(hand, showHands: false);
			}
			GripAnimation(gripping: true, hand);
			if (GetType() == typeof(ExorcismItem))
			{
				ExorcismItem exorcismItem = (ExorcismItem)this;
				if (exorcismItem.type == ExorcismItem.ExItemType.HOLYWATER)
				{
					hasSeenUI = PreferenceManager.instance.GetBool(PlayerPreferences.HAS_SEEN_HOLYWATER_UI.ToString(), defaultValue: false);
				}
				else if (exorcismItem.type == ExorcismItem.ExItemType.LIGHTER)
				{
					hasSeenUI = PreferenceManager.instance.GetBool(PlayerPreferences.HAS_SEEN_LIGHTER_UI.ToString(), defaultValue: false);
				}
				else if (exorcismItem.type == ExorcismItem.ExItemType.SALT)
				{
					hasSeenUI = PreferenceManager.instance.GetBool(PlayerPreferences.HAS_SEEN_SALTSPRAYER_UI.ToString(), defaultValue: false);
				}
			}
			if (GameController.instance.player.CurrentIntegrationType == NVRSDKIntegrations.Oculus)
			{
				if (instructionUIOculus != null && (instructionUIAlwaysShow || !hasSeenUI))
				{
					if (hand.IsLeft)
					{
						instructionUIOculus = GameController.instance.translator.GetSprite(instructionUIOculus.name) ?? instructionUIOculus;
						instructionUIPlacementRight.sprite = instructionUIOculus;
						LeanTween.alpha(instructionUIPlacementRight.gameObject, 1f, 1f);
					}
					else
					{
						instructionUIOculus = GameController.instance.translator.GetSprite(instructionUIOculus.name) ?? instructionUIOculus;
						instructionUIPlacementLeft.sprite = instructionUIOculus;
						LeanTween.alpha(instructionUIPlacementLeft.gameObject, 1f, 1f);
					}
					setUIAsSeen();
					StartCoroutine(HideInstructionUI(hand));
				}
			}
			else if (GameController.instance.player.CurrentIntegrationType == NVRSDKIntegrations.OculusQuest)
			{
				if (instructionUIOculusQuest != null && (instructionUIAlwaysShow || !hasSeenUI))
				{
					if (hand.IsLeft)
					{
						instructionUIOculusQuest = GameController.instance.translator.GetSprite(instructionUIOculusQuest.name) ?? instructionUIOculusQuest;
						instructionUIPlacementRight.sprite = instructionUIOculusQuest;
						LeanTween.alpha(instructionUIPlacementRight.gameObject, 1f, 1f);
					}
					else
					{
						instructionUIOculusQuest = GameController.instance.translator.GetSprite(instructionUIOculusQuest.name) ?? instructionUIOculusQuest;
						instructionUIPlacementLeft.sprite = instructionUIOculusQuest;
						LeanTween.alpha(instructionUIPlacementLeft.gameObject, 1f, 1f);
					}
					setUIAsSeen();
					StartCoroutine(HideInstructionUI(hand));
				}
			}
			else if (GameController.instance.player.CurrentIntegrationType == NVRSDKIntegrations.Pico)
			{
				if (instructionUIPico != null && (instructionUIAlwaysShow || !hasSeenUI))
				{
					if (hand.IsLeft)
					{
						instructionUIPico = GameController.instance.translator.GetSprite(instructionUIPico.name) ?? instructionUIPico;
						instructionUIPlacementRight.sprite = instructionUIPico;
						LeanTween.alpha(instructionUIPlacementRight.gameObject, 1f, 1f);
					}
					else
					{
						instructionUIPico = GameController.instance.translator.GetSprite(instructionUIPico.name) ?? instructionUIPico;
						instructionUIPlacementLeft.sprite = instructionUIPico;
						LeanTween.alpha(instructionUIPlacementLeft.gameObject, 1f, 1f);
					}
					setUIAsSeen();
					StartCoroutine(HideInstructionUI(hand));
				}
			}
			else
			{
				if (!(instructionUISteam != null))
				{
					return;
				}
				if (GameController.instance.isUsingAnOculus())
				{
					if (instructionUIAlwaysShow || !hasSeenUI)
					{
						if (hand.IsLeft)
						{
							instructionUIOculus = GameController.instance.translator.GetSprite(instructionUIOculus.name) ?? instructionUIOculus;
							instructionUIPlacementRight.sprite = instructionUIOculus;
							LeanTween.alpha(instructionUIPlacementRight.gameObject, 1f, 1f);
						}
						else
						{
							instructionUIOculus = GameController.instance.translator.GetSprite(instructionUIOculus.name) ?? instructionUIOculus;
							instructionUIPlacementLeft.sprite = instructionUIOculus;
							LeanTween.alpha(instructionUIPlacementLeft.gameObject, 1f, 1f);
						}
						setUIAsSeen();
						StartCoroutine(HideInstructionUI(hand));
					}
				}
				else if (instructionUIAlwaysShow || !hasSeenUI)
				{
					if (hand.IsLeft)
					{
						instructionUISteam = GameController.instance.translator.GetSprite(instructionUISteam.name) ?? instructionUISteam;
						instructionUIPlacementRight.sprite = instructionUISteam;
						LeanTween.alpha(instructionUIPlacementRight.gameObject, 1f, 1f);
					}
					else
					{
						instructionUISteam = GameController.instance.translator.GetSprite(instructionUISteam.name) ?? instructionUISteam;
						instructionUIPlacementLeft.sprite = instructionUISteam;
						LeanTween.alpha(instructionUIPlacementLeft.gameObject, 1f, 1f);
					}
					setUIAsSeen();
					StartCoroutine(HideInstructionUI(hand));
				}
			}
		}

		public void LockToHand(bool isLocked)
		{
			if (!base.AttachedHand)
			{
				UnityEngine.Debug.Log("LOCK RETURN: Returning as there is no attached hand on the " + base.gameObject.name + " object.");
				return;
			}
			base.AttachedHand.lockedByItem = isLocked;
			lockedToHand = isLocked;
			if (isLocked)
			{
				CanAttach = false;
				DropDistance = 999f;
				return;
			}
			CanAttach = true;
			DropDistance = storedDropDist;
			if (!(base.AttachedHand.IsPrimary ? ControlsManager.instance.primaryPickupButtonHold : ControlsManager.instance.secondaryPickupButtonHold))
			{
				EndInteraction(base.AttachedHand);
			}
		}

		private IEnumerator HideInstructionUI(NVRHand hand)
		{
			fadingUI = true;
			yield return Yield.WaitSeconds(instructionUITimeTillDestroy);
			if (hand.IsLeft)
			{
				LeanTween.alpha(instructionUIPlacementRight.gameObject, 0f, 0.3f);
			}
			else
			{
				LeanTween.alpha(instructionUIPlacementLeft.gameObject, 0f, 0.3f);
			}
			yield return Yield.WaitSeconds(0.5f);
			fadingUI = false;
		}

		public void setUIAsSeen()
		{
			hasSeenUI = true;
			if (GetType() == typeof(ExorcismItem))
			{
				ExorcismItem exorcismItem = (ExorcismItem)this;
				if (exorcismItem.type == ExorcismItem.ExItemType.HOLYWATER)
				{
					PreferenceManager.instance.SetBool(PlayerPreferences.HAS_SEEN_HOLYWATER_UI.ToString(), value: true);
				}
				else if (exorcismItem.type == ExorcismItem.ExItemType.LIGHTER)
				{
					PreferenceManager.instance.SetBool(PlayerPreferences.HAS_SEEN_LIGHTER_UI.ToString(), value: true);
				}
				else if (exorcismItem.type == ExorcismItem.ExItemType.SALT)
				{
					PreferenceManager.instance.SetBool(PlayerPreferences.HAS_SEEN_SALTSPRAYER_UI.ToString(), value: true);
				}
			}
		}

		private void DisableHandRender(NVRHand hand, bool showHands)
		{
			if (hand.IsRight)
			{
				if (handRenderersRight == null)
				{
					handRenderersRight = hand.RenderModel.GetComponentsInChildren<Renderer>();
				}
				Renderer[] array = handRenderersRight;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].enabled = showHands;
				}
			}
			else
			{
				if (handRenderersLeft == null)
				{
					handRenderersLeft = hand.RenderModel.GetComponentsInChildren<Renderer>();
				}
				Renderer[] array = handRenderersLeft;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].enabled = showHands;
				}
			}
			if (!hand.IsPrimary)
			{
				hand.Player.watch.gameObject.SetActive(showHands);
			}
		}

		public override void EndInteraction(NVRHand hand)
		{
			if (lockedToHand)
			{
				return;
			}
			if (!hand.CurrentlyHoveringOver.ContainsKey(this))
			{
				hand.SetAnimation("IdleBool");
			}
			if (hasTranslation)
			{
				HUD.Instance.KillSubtitlesIfLowPriority();
			}
			base.EndInteraction(hand);
			if (instructionUIPlacementLeft != null)
			{
				LeanTween.alpha(instructionUIPlacementLeft.gameObject, 0f, 0.1f);
			}
			if (instructionUIPlacementRight != null)
			{
				LeanTween.alpha(instructionUIPlacementLeft.gameObject, 0f, 0.1f);
			}
			if (hand == null)
			{
				Dictionary<NVRHand, Transform>.Enumerator enumerator = PickupTransforms.GetEnumerator();
				while (enumerator.MoveNext())
				{
					KeyValuePair<NVRHand, Transform> current = enumerator.Current;
					if (current.Value != null)
					{
						UnityEngine.Object.Destroy(current.Value.gameObject);
					}
				}
				PickupTransforms.Clear();
			}
			else if (PickupTransforms.ContainsKey(hand))
			{
				UnityEngine.Object.Destroy(PickupTransforms[hand].gameObject);
				PickupTransforms.Remove(hand);
			}
			if (PickupTransforms.Count == 0)
			{
				Rigidbody.drag = StartingDrag;
				Rigidbody.angularDrag = StartingAngularDrag;
				EnablePhysicalMaterials();
				ApplyVelocityHistory();
				ResetVelocityHistory();
				if (OnEndInteraction != null)
				{
					OnEndInteraction.Invoke();
				}
			}
			if (hideHands)
			{
				DisableHandRender(hand, showHands: true);
			}
			GripAnimation(gripping: false, hand);
		}

		public override void HoveringUpdate(NVRHand hand, float forTime)
		{
			base.HoveringUpdate(hand, forTime);
			if (OnHovering != null)
			{
				OnHovering.Invoke();
			}
		}

		public override void ResetInteractable()
		{
			EndInteraction(null);
			base.ResetInteractable();
		}

		public override void UseButtonDown()
		{
			base.UseButtonDown();
			if (OnUseButtonDown != null)
			{
				OnUseButtonDown.Invoke();
			}
		}

		public override void UseButtonUp()
		{
			base.UseButtonUp();
			if (OnUseButtonUp != null)
			{
				OnUseButtonUp.Invoke();
			}
		}

		protected virtual void ApplyVelocityHistory()
		{
			if (VelocityHistory != null)
			{
				Vector3? meanVector = GetMeanVector(VelocityHistory);
				if (meanVector.HasValue)
				{
					Rigidbody.velocity = meanVector.Value;
				}
				Vector3? meanVector2 = GetMeanVector(AngularVelocityHistory);
				if (meanVector2.HasValue)
				{
					Rigidbody.angularVelocity = meanVector2.Value;
				}
			}
		}

		protected virtual void ResetVelocityHistory()
		{
			CurrentVelocityHistoryStep = 0;
			if (VelocityHistory != null && VelocityHistory.Length != 0)
			{
				VelocityHistory = new Vector3?[VelocityHistory.Length];
				AngularVelocityHistory = new Vector3?[VelocityHistory.Length];
			}
		}

		protected Vector3? GetMeanVector(Vector3?[] positions)
		{
			float num = 0f;
			float num2 = 0f;
			float num3 = 0f;
			int num4 = 0;
			for (int i = 0; i < positions.Length; i++)
			{
				if (positions[i].HasValue)
				{
					num += positions[i].Value.x;
					num2 += positions[i].Value.y;
					num3 += positions[i].Value.z;
					num4++;
				}
			}
			if (num4 > 0)
			{
				return new Vector3(num / (float)num4, num2 / (float)num4, num3 / (float)num4);
			}
			return null;
		}

		protected void DisablePhysicalMaterials()
		{
			for (int i = 0; i < Colliders.Length; i++)
			{
				if (!(Colliders[i] == null))
				{
					MaterialCache[Colliders[i]] = Colliders[i].sharedMaterial;
					Colliders[i].sharedMaterial = null;
				}
			}
		}

		protected void EnablePhysicalMaterials()
		{
			for (int i = 0; i < Colliders.Length; i++)
			{
				if (!(Colliders[i] == null) && MaterialCache.ContainsKey(Colliders[i]))
				{
					Colliders[i].sharedMaterial = MaterialCache[Colliders[i]];
				}
			}
		}

		public override void UpdateColliders()
		{
			base.UpdateColliders();
			for (int i = 0; i < Colliders.Length; i++)
			{
				if (!MaterialCache.ContainsKey(Colliders[i]))
				{
					MaterialCache.Add(Colliders[i], Colliders[i].sharedMaterial);
					if (IsAttached)
					{
						Colliders[i].sharedMaterial = null;
					}
				}
			}
		}

		protected virtual void OnTriggerEnter(Collider other)
		{
			if (respawnIfOOR && other.gameObject.tag == "OutOfReach")
			{
				isOutOfReach = true;
			}
			else if (other.gameObject.tag == "InteractableTrigger" && !ignoreInteractableTrigger)
			{
				NVRTrigger component = other.gameObject.GetComponent<NVRTrigger>();
				if ((bool)component)
				{
					component.TriggerEnter(this);
				}
				else
				{
					UnityEngine.Debug.LogWarning(other.gameObject.name + " is tagged as \"InteractableTrigger\" but has no NVRCollision to derive functions from");
				}
			}
		}

		protected virtual void OnTriggerExit(Collider other)
		{
			if (other.gameObject.tag == "InteractableTrigger" && !ignoreInteractableTrigger)
			{
				NVRTrigger component = other.gameObject.GetComponent<NVRTrigger>();
				if ((bool)component)
				{
					component.TriggerEnd(this);
				}
				else
				{
					UnityEngine.Debug.LogWarning(other.gameObject.name + " is tagged as \"InteractableTrigger\" but has no NVRCollision to derive functions from");
				}
			}
		}

		public void HighlightItem(bool highlight)
		{
			if (highlight)
			{
				if (!isHighlighting)
				{
					for (int i = 0; i < meshArrayForHighlighting.Length; i++)
					{
						MeshRenderer meshRenderer = meshArrayForHighlighting[i];
						List<Material> list = new List<Material>();
						list.AddRange(meshRenderer.materials);
						list.Add(highlightingMaterial);
						meshRenderer.materials = list.ToArray();
						isHighlighting = true;
					}
					for (int j = 0; j < skinnedMeshArrayForHighlighting.Length; j++)
					{
						SkinnedMeshRenderer skinnedMeshRenderer = skinnedMeshArrayForHighlighting[j];
						List<Material> list2 = new List<Material>();
						list2.AddRange(skinnedMeshRenderer.materials);
						list2.Add(highlightingMaterial);
						skinnedMeshRenderer.materials = list2.ToArray();
						isHighlighting = true;
					}
				}
			}
			else
			{
				if (!isHighlighting)
				{
					return;
				}
				for (int k = 0; k < meshArrayForHighlighting.Length; k++)
				{
					MeshRenderer meshRenderer2 = meshArrayForHighlighting[k];
					List<Material> list3 = new List<Material>();
					list3.AddRange(meshRenderer2.materials);
					for (int l = 0; l < list3.Count; l++)
					{
						Material material = list3[l];
						if (material.shader.name == "Outlined/Silhouette")
						{
							list3.Remove(material);
						}
					}
					meshRenderer2.materials = list3.ToArray();
					isHighlighting = false;
				}
				for (int m = 0; m < skinnedMeshArrayForHighlighting.Length; m++)
				{
					SkinnedMeshRenderer skinnedMeshRenderer2 = skinnedMeshArrayForHighlighting[m];
					List<Material> list4 = new List<Material>();
					list4.AddRange(skinnedMeshRenderer2.materials);
					for (int n = 0; n < list4.Count; n++)
					{
						Material material2 = list4[n];
						if (material2.shader.name == "Outlined/Silhouette")
						{
							list4.Remove(material2);
						}
					}
					skinnedMeshRenderer2.materials = list4.ToArray();
					isHighlighting = false;
				}
			}
		}

		public void GripAnimation(bool gripping, NVRHand hand)
		{
			hand.handAnimator.SetFloat("Offset", gripPercentage);
			if (gripping)
			{
				switch (gripType)
				{
				case GripTypes.C:
					hand.SetAnimation("CgripBool");
					break;
				case GripTypes.L:
					hand.SetAnimation("LgripBool");
					break;
				case GripTypes.Pinch:
					hand.SetAnimation("PinchBool");
					break;
				}
			}
			else if (hand.IsHovering)
			{
				hand.SetAnimation("OpenBool");
			}
			else
			{
				hand.SetAnimation("IdleBool");
			}
		}

		private void EditInteractionPoint(NVRHand hand)
		{
			if (Input.GetKeyDown(KeyCode.Space))
			{
				if (hand.IsRight)
				{
					InteractionPointRight.position = hand.transform.position;
					InteractionPointRight.rotation = hand.transform.rotation;
				}
				else
				{
					InteractionPointLeft.position = hand.transform.position;
					InteractionPointLeft.rotation = hand.transform.rotation;
				}
			}
		}

		private void OnDisable()
		{
			NVRPlayer player = GameController.instance.player;
			if (instructionUIPlacementLeft != null)
			{
				LeanTween.alpha(instructionUIPlacementLeft.gameObject, 0f, 0.1f);
			}
			if (instructionUIPlacementRight != null)
			{
				LeanTween.alpha(instructionUIPlacementLeft.gameObject, 0f, 0.1f);
			}
			if ((bool)player)
			{
				if ((bool)player.LeftHand && player.LeftHand.CurrentlyHoveringOver != null && player.LeftHand.CurrentlyHoveringOver.ContainsKey(this))
				{
					player.LeftHand.CurrentlyHoveringOver.Remove(this);
				}
				if ((bool)player.RightHand && player.RightHand.CurrentlyHoveringOver != null && player.RightHand.CurrentlyHoveringOver.ContainsKey(this))
				{
					player.RightHand.CurrentlyHoveringOver.Remove(this);
				}
			}
		}
	}
	public class NVRInteractableItemAutoAttach : NVRInteractableItem
	{
		public float PickupAfterSeconds = 0.5f;

		public override void HoveringUpdate(NVRHand hand, float forTime)
		{
			base.HoveringUpdate(hand, forTime);
			if (!IsAttached && forTime > PickupAfterSeconds)
			{
				hand.BeginInteraction(this);
			}
		}
	}
	public class NVRInteractableItemClippable : NVRInteractableItem
	{
		protected override void UpdateVelocities()
		{
			GetTargetValues(out var targetHandPosition, out var targetHandRotation, out var _, out var _);
			Rigidbody.MovePosition(targetHandPosition);
			Rigidbody.MoveRotation(targetHandRotation);
		}

		public override void BeginInteraction(NVRHand hand, bool runBeginInteractionCallback = true)
		{
			base.BeginInteraction(hand, runBeginInteractionCallback);
			Rigidbody.isKinematic = true;
		}

		public override void EndInteraction(NVRHand hand)
		{
			base.EndInteraction(hand);
			Rigidbody.isKinematic = false;
		}
	}
	public class NVRInteractableRotator : NVRInteractable
	{
		public float CurrentAngle;

		protected Transform InitialAttachPoint;

		protected virtual float DeltaMagic => 1f;

		protected override void Awake()
		{
			base.Awake();
			Rigidbody.maxAngularVelocity = 100f;
		}

		protected virtual void FixedUpdate()
		{
			if (IsAttached)
			{
				Vector3 force = (base.AttachedHand.transform.position - InitialAttachPoint.position) * DeltaMagic;
				Rigidbody.AddForceAtPosition(force, InitialAttachPoint.position, ForceMode.VelocityChange);
			}
			CurrentAngle = Quaternion.Angle(Quaternion.identity, base.transform.rotation);
		}

		public override void BeginInteraction(NVRHand hand, bool runBeginInteractionCallback = true)
		{
			base.BeginInteraction(hand, runBeginInteractionCallback);
			InitialAttachPoint = new GameObject($"[{base.gameObject.name}] InitialAttachPoint").transform;
			InitialAttachPoint.position = hand.transform.position;
			InitialAttachPoint.rotation = hand.transform.rotation;
			InitialAttachPoint.localScale = Vector3.one * 0.25f;
			InitialAttachPoint.parent = base.transform;
		}

		public override void EndInteraction(NVRHand hand)
		{
			base.EndInteraction(hand);
			if (InitialAttachPoint != null)
			{
				UnityEngine.Object.Destroy(InitialAttachPoint.gameObject);
			}
		}
	}
	public class NVRInteractables : MonoBehaviour
	{
		private static Dictionary<Collider, NVRInteractable> ColliderMapping;

		private static Dictionary<NVRInteractable, Collider[]> NVRInteractableMapping;

		private static List<NVRInteractable> NVRInteractableList;

		private static bool Initialized;

		public static void Initialize()
		{
			ColliderMapping = new Dictionary<Collider, NVRInteractable>();
			NVRInteractableMapping = new Dictionary<NVRInteractable, Collider[]>();
			NVRInteractableList = new List<NVRInteractable>();
			Initialized = true;
		}

		public static void Register(NVRInteractable interactable, Collider[] colliders)
		{
			if (!Initialized)
			{
				UnityEngine.Debug.LogError("[NewtonVR] Error: NVRInteractables.Register called before initialization.");
			}
			NVRInteractableMapping[interactable] = colliders;
			for (int i = 0; i < colliders.Length; i++)
			{
				ColliderMapping[colliders[i]] = interactable;
			}
			if (!NVRInteractableList.Contains(interactable))
			{
				NVRInteractableList.Add(interactable);
			}
		}

		public static void Deregister(NVRInteractable interactable)
		{
			if (!Initialized)
			{
				UnityEngine.Debug.LogError("[NewtonVR] Error: NVRInteractables.Register called before initialization.");
			}
			NVRPlayer.DeregisterInteractable(interactable);
			ColliderMapping = ColliderMapping.Where((KeyValuePair<Collider, NVRInteractable> mapping) => mapping.Value != interactable).ToDictionary((KeyValuePair<Collider, NVRInteractable> mapping) => mapping.Key, (KeyValuePair<Collider, NVRInteractable> mapping) => mapping.Value);
			NVRInteractableMapping.Remove(interactable);
			NVRInteractableList.Remove(interactable);
		}

		public static NVRInteractable GetInteractable(Collider collider)
		{
			if (!Initialized)
			{
				UnityEngine.Debug.LogError("[NewtonVR] Error: NVRInteractables.Register called before initialization.");
			}
			ColliderMapping.TryGetValue(collider, out var value);
			return value;
		}

		public static List<NVRInteractable> GetAllInteractables()
		{
			return NVRInteractableList;
		}
	}
	public class NVRLetterSpinner : NVRInteractableRotator
	{
		private static string LETTERLIST = "ABCDEFGHIJKLMNOPQRSTUVWXYZ?";

		private float SnapDistance = 1f;

		private float RungAngleInterval;

		private Vector3 LastAngularVelocity = Vector3.zero;

		protected override void Awake()
		{
			base.Awake();
			RungAngleInterval = 360f / (float)LETTERLIST.Length;
		}

		protected override void FixedUpdate()
		{
			base.FixedUpdate();
			if (!IsAttached)
			{
				float z = base.transform.localEulerAngles.z;
				float num = Mathf.RoundToInt(z / RungAngleInterval);
				float num2 = Mathf.Abs(z - num * RungAngleInterval);
				float num3 = Mathf.Abs(Rigidbody.angularVelocity.z);
				if (num3 > 0.001f && num3 < 0.5f)
				{
					if (num2 > SnapDistance)
					{
						Rigidbody.angularVelocity = LastAngularVelocity;
					}
					else
					{
						Rigidbody.velocity = Vector3.zero;
						Rigidbody.angularVelocity = Vector3.zero;
						Vector3 localEulerAngles = base.transform.localEulerAngles;
						localEulerAngles.z = num * RungAngleInterval;
						base.transform.localEulerAngles = localEulerAngles;
						Rigidbody.isKinematic = true;
					}
				}
			}
			LastAngularVelocity = Rigidbody.angularVelocity;
		}

		public override void BeginInteraction(NVRHand hand, bool runBeginInteractionCallback = true)
		{
			Rigidbody.isKinematic = false;
			base.BeginInteraction(hand, runBeginInteractionCallback);
		}

		public string GetLetter()
		{
			int num = Mathf.RoundToInt(base.transform.localEulerAngles.z / RungAngleInterval);
			if ((double)base.transform.localEulerAngles.z < 0.3)
			{
				num = LETTERLIST.Length - num;
			}
			if (num == 27)
			{
				num = 0;
			}
			if (num == -1)
			{
				num = 26;
			}
			return LETTERLIST.Substring(num, 1);
		}
	}
	public class NVRLever : NVRInteractableItem
	{
		public enum LeverPosition
		{
			Off,
			Mid,
			On
		}

		public enum RotationAxis
		{
			XAxis,
			YAxis,
			ZAxis
		}

		public float LastValue;

		public float CurrentValue;

		public LeverPosition LastLeverPosition;

		public LeverPosition CurrentLeverPosition;

		public bool LeverEngaged;

		public float EngageWaitTime = 1f;

		protected Transform InitialAttachPoint;

		protected HingeJoint HingeJoint;

		protected bool UseMotor;

		protected Quaternion Max;

		protected Quaternion Mid;

		protected Quaternion Min;

		protected float AngleRange;

		protected virtual float DeltaMagic => 2f;

		protected override void Awake()
		{
			base.Awake();
			Rigidbody.maxAngularVelocity = 100f;
			if (HingeJoint == null)
			{
				HingeJoint = Rigidbody.gameObject.GetComponent<HingeJoint>();
			}
			Mid = HingeJoint.transform.localRotation;
			Max = Mid * Quaternion.AngleAxis(HingeJoint.limits.max, HingeJoint.axis);
			Min = Mid * Quaternion.AngleAxis(HingeJoint.limits.min, HingeJoint.axis);
			UseMotor = HingeJoint.useMotor;
			if (HingeJoint.useLimits)
			{
				AngleRange = Mathf.Max(HingeJoint.limits.max, HingeJoint.limits.min) - Mathf.Min(HingeJoint.limits.max, HingeJoint.limits.min);
			}
		}

		protected override void Update()
		{
			base.Update();
			LeverEngaged = false;
			LastValue = CurrentValue;
			LastLeverPosition = CurrentLeverPosition;
			CurrentValue = GetValue();
			CurrentLeverPosition = GetPosition();
			if (LastLeverPosition != LeverPosition.On && CurrentLeverPosition == LeverPosition.On)
			{
				LeverEngaged = true;
				Engage();
			}
		}

		protected virtual void Engage()
		{
			if (base.AttachedHand != null)
			{
				base.AttachedHand.EndInteraction(this);
			}
			CanAttach = false;
			StartCoroutine(HoldPosition(EngageWaitTime));
		}

		private IEnumerator HoldPosition(float time)
		{
			HingeJoint.useMotor = false;
			yield return Yield.WaitSeconds(time);
			HingeJoint.useMotor = true;
			CanAttach = true;
		}

		public override void BeginInteraction(NVRHand hand, bool runBeginInteractionCallback = true)
		{
			base.BeginInteraction(hand, runBeginInteractionCallback);
			InitialAttachPoint = new GameObject($"[{base.gameObject.name}] InitialAttachPoint").transform;
			InitialAttachPoint.position = hand.transform.position;
			InitialAttachPoint.rotation = hand.transform.rotation;
			InitialAttachPoint.localScale = Vector3.one * 0.25f;
			InitialAttachPoint.parent = base.transform;
			HingeJoint.useMotor = false;
		}

		public override void EndInteraction(NVRHand hand)
		{
			base.EndInteraction(hand);
			HingeJoint.useMotor = true;
			if (InitialAttachPoint != null)
			{
				UnityEngine.Object.Destroy(InitialAttachPoint.gameObject);
			}
		}

		private float GetValue()
		{
			float num = 0f;
			if (HingeJoint.useLimits)
			{
				num = HingeJoint.angle - HingeJoint.limits.min;
			}
			return 1f - num / AngleRange;
		}

		private LeverPosition GetPosition()
		{
			if ((double)CurrentValue <= 0.05)
			{
				return LeverPosition.Off;
			}
			if ((double)CurrentValue >= 0.95)
			{
				return LeverPosition.On;
			}
			return LeverPosition.Mid;
		}
	}
	public class NVROculusQuestInputDevice : NVRInputDevice
	{
		public override bool IsCurrentlyTracked
		{
			get
			{
				throw new NotImplementedException();
			}
		}

		public override bool GetAxis1DRightDown(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetAxis1DLeftDown(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetAxis1DRightUp(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetAxis1DLeftUp(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override Vector2 GetAxis2DRight(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override Vector2 GetAxis2DLeft(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override string GetDeviceName()
		{
			throw new NotImplementedException();
		}

		public override bool GetPressA(NVRButtons button)
		{
			return false;
		}

		public override bool GetPressB(NVRButtons button)
		{
			return false;
		}

		public override bool GetPressX(NVRButtons button)
		{
			return false;
		}

		public override bool GetPressY(NVRButtons button)
		{
			return false;
		}

		public override bool GetPressGripLeft(NVRButtons button)
		{
			return false;
		}

		public override bool GetPressGripRight(NVRButtons button)
		{
			return false;
		}

		public override bool GetPressTriggerLeft(NVRButtons button)
		{
			return false;
		}

		public override bool GetPressTriggerRight(NVRButtons button)
		{
			return false;
		}

		public override bool GetPressAppLeft(NVRButtons button)
		{
			return false;
		}

		public override bool GetPressAppRight(NVRButtons button)
		{
			return false;
		}

		public override bool GetPressDownA(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetPressDownB(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetPressDownX(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetPressDownY(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetPressDownApp(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetPressUpA(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetPressUpB(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetPressUpX(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetPressUpY(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetPressUpApp(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetRightDown(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetLeftDown(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetRightUp(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetLeftUp(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool ReadyToInitialize()
		{
			throw new NotImplementedException();
		}

		public override Collider[] SetupDefaultColliders()
		{
			throw new NotImplementedException();
		}

		public override Collider[] SetupDefaultPhysicalColliders(Transform ModelParent)
		{
			throw new NotImplementedException();
		}

		public override GameObject SetupDefaultRenderModel()
		{
			throw new NotImplementedException();
		}

		public override void TriggerHapticPulse(float power = 0.2f, ushort durationMicroSec = 500, NVRButtons button = NVRButtons.Touchpad)
		{
			throw new NotImplementedException();
		}

		public override void TriggerHapticPulse(VibrationForce force, float time)
		{
			throw new NotImplementedException();
		}
	}
	public class NVRPhysicalController : MonoBehaviour
	{
		private NVRHand Hand;

		public bool State;

		private Rigidbody Rigidbody;

		[HideInInspector]
		public GameObject PhysicalController;

		private Collider[] Colliders;

		protected Vector3 ClosestHeldPoint;

		protected float AttachedRotationMagic = 20f;

		protected float AttachedPositionMagic = 3000f;

		private Type[] KeepTypes = new Type[4]
		{
			typeof(MeshFilter),
			typeof(Renderer),
			typeof(Transform),
			typeof(Rigidbody)
		};

		protected float DropDistance => 1f;

		public void Initialize(NVRHand trackingHand, bool initialState)
		{
			Hand = trackingHand;
			Hand.gameObject.SetActive(value: false);
			PhysicalController = UnityEngine.Object.Instantiate(Hand.gameObject);
			PhysicalController.name = PhysicalController.name.Replace("(Clone)", " [Physical]");
			Hand.gameObject.SetActive(value: true);
			UnityEngine.Component[] componentsInChildren = PhysicalController.GetComponentsInChildren<UnityEngine.Component>(includeInactive: true);
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				Type componentType = componentsInChildren[i].GetType();
				if (!KeepTypes.Any((Type keepType) => keepType == componentType || componentType.IsSubclassOf(keepType)))
				{
					UnityEngine.Object.DestroyImmediate(componentsInChildren[i]);
				}
			}
			PhysicalController.transform.parent = Hand.transform.parent;
			PhysicalController.transform.position = Hand.transform.position;
			PhysicalController.transform.rotation = Hand.transform.rotation;
			PhysicalController.transform.localScale = Hand.transform.localScale;
			PhysicalController.SetActive(value: true);
			if (Hand.HasCustomModel)
			{
				SetupCustomModel();
			}
			else
			{
				Colliders = Hand.SetupDefaultPhysicalColliders(PhysicalController.transform);
			}
			if (Colliders == null)
			{
				UnityEngine.Debug.LogError("[NewtonVR] Error: Physical colliders on hand not setup properly.");
			}
			Rigidbody = PhysicalController.GetComponent<Rigidbody>();
			Rigidbody.isKinematic = false;
			Rigidbody.maxAngularVelocity = float.MaxValue;
			if (trackingHand.Player.AutomaticallySetControllerTransparency)
			{
				Renderer[] componentsInChildren2 = PhysicalController.GetComponentsInChildren<Renderer>();
				for (int j = 0; j < componentsInChildren2.Length; j++)
				{
					NVRHelpers.SetOpaque(componentsInChildren2[j].material);
				}
			}
			if (!initialState)
			{
				Off();
			}
			else
			{
				On();
			}
		}

		public void Kill()
		{
			UnityEngine.Object.Destroy(PhysicalController);
			UnityEngine.Object.Destroy(this);
		}

		private bool CheckForDrop()
		{
			if (Vector3.Distance(Hand.transform.position, base.transform.position) > DropDistance)
			{
				DroppedBecauseOfDistance();
				return true;
			}
			return false;
		}

		private void UpdatePosition()
		{
			Rigidbody.maxAngularVelocity = float.MaxValue;
			Quaternion quaternion = Hand.transform.rotation * Quaternion.Inverse(PhysicalController.transform.rotation);
			Vector3 vector = Hand.transform.position - PhysicalController.transform.position;
			quaternion.ToAngleAxis(out var angle, out var axis);
			if (angle > 180f)
			{
				angle -= 360f;
			}
			if (angle != 0f)
			{
				Vector3 angularVelocity = angle * axis;
				Rigidbody.angularVelocity = angularVelocity;
			}
			Vector3 velocity = vector / Time.deltaTime;
			Rigidbody.velocity = velocity;
		}

		protected virtual void FixedUpdate()
		{
			if (State && !CheckForDrop())
			{
				UpdatePosition();
			}
		}

		protected virtual void DroppedBecauseOfDistance()
		{
			Hand.ForceGhost();
		}

		public void On()
		{
			PhysicalController.transform.position = Hand.transform.position;
			PhysicalController.transform.rotation = Hand.transform.rotation;
			PhysicalController.SetActive(value: true);
			State = true;
		}

		public void Off()
		{
			PhysicalController.SetActive(value: false);
			State = false;
		}

		protected void SetupCustomModel()
		{
			Transform transform = null;
			if (Hand.CustomPhysicalColliders == null)
			{
				GameObject obj = UnityEngine.Object.Instantiate(Hand.CustomModel);
				obj.name = "CustomColliders";
				transform = obj.transform;
				transform.parent = PhysicalController.transform;
				transform.localPosition = Vector3.zero;
				transform.localRotation = Quaternion.identity;
				transform.localScale = Vector3.one;
				Collider[] componentsInChildren = obj.GetComponentsInChildren<Collider>();
				for (int i = 0; i < componentsInChildren.Length; i++)
				{
					componentsInChildren[i].isTrigger = false;
				}
				Colliders = transform.GetComponentsInChildren<Collider>();
			}
			else
			{
				GameObject obj2 = UnityEngine.Object.Instantiate(Hand.CustomPhysicalColliders);
				obj2.name = "CustomColliders";
				transform = obj2.transform;
				transform.parent = PhysicalController.transform;
				transform.localPosition = Vector3.zero;
				transform.localRotation = Quaternion.identity;
				transform.localScale = Hand.CustomPhysicalColliders.transform.localScale;
			}
			Colliders = transform.GetComponentsInChildren<Collider>();
		}
	}
	public class NVRPicoInputDevice : NVRInputDevice
	{
		private GameObject RenderModel;

		private Pvr_Controller Controller;

		private Dictionary<NVRButtons, Pvr_KeyCode> ButtonMapping = new Dictionary<NVRButtons, Pvr_KeyCode>(default(NVRButtonsComparer));

		private Dictionary<NVRButtons, Pvr_KeyCode> TriggerMapping = new Dictionary<NVRButtons, Pvr_KeyCode>(default(NVRButtonsComparer));

		private Dictionary<NVRButtons, Pvr_KeyCode> StickMapping = new Dictionary<NVRButtons, Pvr_KeyCode>(default(NVRButtonsComparer));

		private int lastHapticFrame;

		private bool hapticActive;

		private NVRHand PvrHand;

		public override bool IsCurrentlyTracked => true;

		public override void Initialize(NVRHand hand)
		{
			base.Initialize(hand);
			PvrHand = hand;
			SetupButtonMapping();
			_ = hand == Hand.Player.LeftHand;
		}

		protected virtual void SetupButtonMapping()
		{
			if (!inputDeviceInit)
			{
				ButtonMapping.Add(NVRButtons.A, Pvr_KeyCode.A);
				ButtonMapping.Add(NVRButtons.B, Pvr_KeyCode.B);
				ButtonMapping.Add(NVRButtons.X, Pvr_KeyCode.X);
				ButtonMapping.Add(NVRButtons.Y, Pvr_KeyCode.Y);
				ButtonMapping.Add(NVRButtons.ApplicationMenu, Pvr_KeyCode.APP);
				ButtonMapping.Add(NVRButtons.Trigger, Pvr_KeyCode.TRIGGER);
				if (PvrHand == Hand.Player.LeftHand)
				{
					ButtonMapping.Add(NVRButtons.Grip, Pvr_KeyCode.Left);
				}
				else
				{
					ButtonMapping.Add(NVRButtons.Grip, Pvr_KeyCode.Right);
				}
				ButtonMapping.Add(NVRButtons.System, Pvr_KeyCode.APP);
				TriggerMapping.Add(NVRButtons.Grip, Pvr_KeyCode.Left);
				TriggerMapping.Add(NVRButtons.Trigger, Pvr_KeyCode.TRIGGER);
				StickMapping.Add(NVRButtons.Touchpad, Pvr_KeyCode.TOUCHPAD);
				inputDeviceInit = true;
			}
		}

		private Pvr_KeyCode GetButtonMap(NVRButtons button)
		{
			if (!ButtonMapping.ContainsKey(button))
			{
				return Pvr_KeyCode.A;
			}
			return ButtonMapping[button];
		}

		private Pvr_KeyCode GetTriggerMap(NVRButtons button)
		{
			if (!TriggerMapping.ContainsKey(button))
			{
				return Pvr_KeyCode.TRIGGER;
			}
			return TriggerMapping[button];
		}

		private Pvr_KeyCode GetStickMap(NVRButtons button)
		{
			if (!StickMapping.ContainsKey(button))
			{
				return Pvr_KeyCode.TOUCHPAD;
			}
			return StickMapping[button];
		}

		public override bool GetAxis1DRightDown(NVRButtons button)
		{
			return Pvr_UnitySDKAPI.Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TRIGGER);
		}

		public override bool GetAxis1DLeftDown(NVRButtons button)
		{
			return Pvr_UnitySDKAPI.Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.TRIGGER);
		}

		public override bool GetAxis1DRightUp(NVRButtons button)
		{
			return Pvr_UnitySDKAPI.Controller.UPvr_GetKeyUp(1, Pvr_KeyCode.TRIGGER);
		}

		public override bool GetAxis1DLeftUp(NVRButtons button)
		{
			return Pvr_UnitySDKAPI.Controller.UPvr_GetKeyUp(0, Pvr_KeyCode.TRIGGER);
		}

		public override Vector2 GetAxis2DLeft(NVRButtons button)
		{
			return Pvr_UnitySDKAPI.Controller.UPvr_GetAxis2D(0);
		}

		public override Vector2 GetAxis2DRight(NVRButtons button)
		{
			return Pvr_UnitySDKAPI.Controller.UPvr_GetAxis2D(1);
		}

		public override bool GetPressDownX(NVRButtons button)
		{
			return Pvr_UnitySDKAPI.Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.X);
		}

		public override bool GetPressDownY(NVRButtons button)
		{
			return Pvr_UnitySDKAPI.Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.Y);
		}

		public override bool GetPressDownA(NVRButtons button)
		{
			return Pvr_UnitySDKAPI.Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.A);
		}

		public override bool GetPressDownB(NVRButtons button)
		{
			return Pvr_UnitySDKAPI.Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.B);
		}

		public override bool GetPressDownApp(NVRButtons button)
		{
			return Pvr_UnitySDKAPI.Controller.UPvr_GetKeyUp(0, Pvr_KeyCode.APP);
		}

		public override bool GetPressUpX(NVRButtons button)
		{
			return Pvr_UnitySDKAPI.Controller.UPvr_GetKeyUp(0, Pvr_KeyCode.X);
		}

		public override bool GetPressUpY(NVRButtons button)
		{
			return Pvr_UnitySDKAPI.Controller.UPvr_GetKeyUp(0, Pvr_KeyCode.Y);
		}

		public override bool GetPressUpA(NVRButtons button)
		{
			return Pvr_UnitySDKAPI.Controller.UPvr_GetKeyUp(1, Pvr_KeyCode.A);
		}

		public override bool GetPressUpB(NVRButtons button)
		{
			return Pvr_UnitySDKAPI.Controller.UPvr_GetKeyUp(1, Pvr_KeyCode.B);
		}

		public override bool GetPressUpApp(NVRButtons button)
		{
			return Pvr_UnitySDKAPI.Controller.UPvr_GetKeyUp(0, Pvr_KeyCode.APP);
		}

		public override bool GetRightDown(NVRButtons button)
		{
			return Pvr_UnitySDKAPI.Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.Right);
		}

		public override bool GetLeftDown(NVRButtons button)
		{
			return Pvr_UnitySDKAPI.Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.Left);
		}

		public override bool GetRightUp(NVRButtons button)
		{
			return Pvr_UnitySDKAPI.Controller.UPvr_GetKeyUp(1, Pvr_KeyCode.Right);
		}

		public override bool GetLeftUp(NVRButtons button)
		{
			return Pvr_UnitySDKAPI.Controller.UPvr_GetKeyUp(0, Pvr_KeyCode.Left);
		}

		public override bool GetPressA(NVRButtons button)
		{
			if (Pvr_UnitySDKAPI.Controller.UPvr_GetKeyLongPressed(1, Pvr_KeyCode.A))
			{
				return true;
			}
			return false;
		}

		public override bool GetPressB(NVRButtons button)
		{
			if (Pvr_UnitySDKAPI.Controller.UPvr_GetKeyLongPressed(1, Pvr_KeyCode.B))
			{
				return true;
			}
			return false;
		}

		public override bool GetPressX(NVRButtons button)
		{
			if (Pvr_UnitySDKAPI.Controller.UPvr_GetKeyLongPressed(0, Pvr_KeyCode.X))
			{
				return true;
			}
			return false;
		}

		public override bool GetPressY(NVRButtons button)
		{
			if (Pvr_UnitySDKAPI.Controller.UPvr_GetKeyLongPressed(0, Pvr_KeyCode.Y))
			{
				return true;
			}
			return false;
		}

		public override bool GetPressGripLeft(NVRButtons button)
		{
			if (Pvr_UnitySDKAPI.Controller.UPvr_GetKeyLongPressed(0, Pvr_KeyCode.Left))
			{
				return true;
			}
			return false;
		}

		public override bool GetPressGripRight(NVRButtons button)
		{
			if (Pvr_UnitySDKAPI.Controller.UPvr_GetKeyLongPressed(1, Pvr_KeyCode.Right))
			{
				return true;
			}
			return false;
		}

		public override bool GetPressTriggerLeft(NVRButtons button)
		{
			if (Pvr_UnitySDKAPI.Controller.UPvr_GetKeyLongPressed(0, Pvr_KeyCode.Left))
			{
				return true;
			}
			return false;
		}

		public override bool GetPressTriggerRight(NVRButtons button)
		{
			if (Pvr_UnitySDKAPI.Controller.UPvr_GetKeyLongPressed(1, Pvr_KeyCode.Right))
			{
				return true;
			}
			return false;
		}

		public override bool GetPressAppLeft(NVRButtons button)
		{
			if (Pvr_UnitySDKAPI.Controller.UPvr_GetKeyLongPressed(0, Pvr_KeyCode.APP))
			{
				return true;
			}
			return false;
		}

		public override bool GetPressAppRight(NVRButtons button)
		{
			if (Pvr_UnitySDKAPI.Controller.UPvr_GetKeyLongPressed(1, Pvr_KeyCode.APP))
			{
				return true;
			}
			return false;
		}

		public override void TriggerHapticPulse(float power = 0.2f, ushort durationMicroSec = 500, NVRButtons button = NVRButtons.Touchpad)
		{
			power = Mathf.Clamp01(power);
			hapticActive = true;
			lastHapticFrame = Time.frameCount;
			_ = Controller == Hand.Player.RightHand;
		}

		private IEnumerator DoHapticPulse(ushort durationMicroSec, float power)
		{
			power = Mathf.Clamp01(power);
			hapticActive = true;
			lastHapticFrame = Time.frameCount;
			_ = Controller == Hand.Player.RightHand;
			yield return null;
		}

		private void Update()
		{
			if (lastHapticFrame + 1 < Time.frameCount && hapticActive)
			{
				if (Controller == Hand.Player.RightHand)
				{
					Pvr_UnitySDKAPI.Controller.UPvr_VibrateNeo2Controller(0f, 0, 1);
				}
				if (Controller == Hand.Player.LeftHand)
				{
					Pvr_UnitySDKAPI.Controller.UPvr_VibrateNeo2Controller(0f, 0, 0);
				}
				hapticActive = false;
			}
		}

		public override GameObject SetupDefaultRenderModel()
		{
			if (Hand.IsLeft)
			{
				RenderModel = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("TouchControllers/PicoTouchLeft"));
			}
			else
			{
				RenderModel = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("TouchControllers/PicoTouchRight"));
			}
			RenderModel.name = "Render Model for " + Hand.gameObject.name;
			RenderModel.transform.parent = Hand.transform;
			RenderModel.transform.localPosition = Vector3.zero;
			RenderModel.transform.localRotation = Quaternion.identity;
			RenderModel.transform.localScale = Vector3.one;
			return RenderModel;
		}

		public override bool ReadyToInitialize()
		{
			return true;
		}

		public override string GetDeviceName()
		{
			if (Hand.HasCustomModel)
			{
				return "Custom";
			}
			return Pvr_UnitySDKAPI.Controller.UPvr_GetDeviceType().ToString();
		}

		public override Collider[] SetupDefaultPhysicalColliders(Transform ModelParent)
		{
			string text = "PicoTouch";
			text = ((!Hand.IsLeft) ? (text + "Right") : (text + "Left"));
			text += "Colliders";
			Transform transform = ModelParent.transform.Find(text);
			if (transform == null)
			{
				transform = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("TouchControllers/" + text)).transform;
				transform.parent = ModelParent.transform;
				transform.localPosition = Vector3.zero;
				transform.localRotation = Quaternion.identity;
				transform.localScale = Vector3.one;
			}
			return transform.GetComponentsInChildren<Collider>();
		}

		public override Collider[] SetupDefaultColliders()
		{
			SphereCollider sphereCollider = RenderModel.AddComponent<SphereCollider>();
			sphereCollider.isTrigger = true;
			sphereCollider.radius = 0.15f;
			return new Collider[1] { sphereCollider };
		}

		public override void TriggerHapticPulse(VibrationForce force, float time)
		{
			throw new NotImplementedException();
		}
	}
	public class NVRPlayer : MonoBehaviour
	{
		public const decimal NewtonVRVersion = 1.22m;

		public const float NewtonVRExpectedDeltaTime = 0.0111f;

		public static List<NVRPlayer> Instances = new List<NVRPlayer>();

		[HideInInspector]
		public bool SteamVREnabled;

		[HideInInspector]
		public bool OculusSDKEnabled;

		[HideInInspector]
		public bool OculusQuestSDKEnabled;

		[HideInInspector]
		public bool PSVREnabled;

		[HideInInspector]
		public bool PicoEnabled;

		public InterationStyle InteractionStyle;

		public bool PhysicalHands = true;

		public bool MakeControllerInvisibleOnInteraction;

		public bool AutomaticallySetControllerTransparency = true;

		public bool VibrateOnHover = true;

		public int VelocityHistorySteps = 3;

		public UnityEvent OnInitialized;

		[Space]
		public bool EnableEditorPlayerPreview = true;

		public Mesh EditorPlayerPreview;

		public Mesh EditorPlayspacePreview;

		public bool EditorPlayspaceOverride;

		public Vector2 EditorPlayspaceDefault = new Vector2(2f, 1.5f);

		private bool swapHands;

		[Space]
		[HideInInspector]
		public bool OverrideAll;

		[HideInInspector]
		public GameObject OverrideAllLeftHand;

		[HideInInspector]
		public GameObject OverrideAllLeftHandPhysicalColliders;

		[HideInInspector]
		public GameObject OverrideAllRightHand;

		[HideInInspector]
		public GameObject OverrideAllRightHandPhysicalColliders;

		[HideInInspector]
		public bool OverrideSteamVR;

		[HideInInspector]
		public GameObject OverrideSteamVRLeftHand;

		[HideInInspector]
		public GameObject OverrideSteamVRLeftHandPhysicalColliders;

		[HideInInspector]
		public GameObject OverrideSteamVRRightHand;

		[HideInInspector]
		public GameObject OverrideSteamVRRightHandPhysicalColliders;

		[HideInInspector]
		public bool OverrideOculus;

		[HideInInspector]
		public GameObject OverrideOculusLeftHand;

		[HideInInspector]
		public GameObject OverrideOculusLeftHandPhysicalColliders;

		[HideInInspector]
		public GameObject OverrideOculusRightHand;

		[HideInInspector]
		public GameObject OverrideOculusRightHandPhysicalColliders;

		[HideInInspector]
		public bool OverrideOculusQuest;

		[HideInInspector]
		public GameObject OverrideOculusQuestLeftHand;

		[HideInInspector]
		public GameObject OverrideOculusQuestLeftHandPhysicalColliders;

		[HideInInspector]
		public GameObject OverrideOculusQuestRightHand;

		[HideInInspector]
		public GameObject OverrideOculusQuestRightHandPhysicalColliders;

		[HideInInspector]
		public bool OverridePSVR;

		[HideInInspector]
		public GameObject OverridePSVRLeftHand;

		[HideInInspector]
		public GameObject OverridePSVRLeftHandPhysicalColliders;

		[HideInInspector]
		public GameObject OverridePSVRRightHand;

		[HideInInspector]
		public GameObject OverridePSVRRightHandPhysicalColliders;

		[HideInInspector]
		public bool OverridePico;

		[HideInInspector]
		public GameObject OverridePicoLeftHand;

		[HideInInspector]
		public GameObject OverridePicoLeftHandPhysicalColliders;

		[HideInInspector]
		public GameObject OverridePicoRightHand;

		[HideInInspector]
		public GameObject OverridePicoRightHandPhysicalColliders;

		[Space]
		public NVRHead Head;

		public NVRHand LeftHand;

		public NVRHand RightHand;

		public GameObject PicoLight;

		[HideInInspector]
		public NVRHand[] Hands;

		[HideInInspector]
		public NVRSDKIntegrations CurrentIntegrationType;

		private NVRIntegration Integration;

		private Dictionary<Collider, NVRHand> ColliderToHandMapping;

		[Space]
		public bool DEBUGEnableFallback2D;

		public bool DEBUGDropFrames;

		public int DEBUGSleepPerFrame = 13;

		public bool AutoSetFixedDeltaTime = true;

		public bool NotifyOnVersionUpdate = true;

		public MenuScript HandMenu;

		public PlayerWatch watch;

		[SerializeField]
		public InterstitialTitleManager interstitialTitleManager;

		private bool initPSControllers;

		[Space]
		[Header("Our Variables")]
		[Space]
		public Camera mainCamera;

		[Space]
		public GameObject locoVisual;

		public GameObject locoVisual_Head;

		public GameObject locoVisual_PlayCenter;

		public GameObject locoVisual_PlayAreaVive;

		public GameObject locoVisual_PlayAreaRift;

		public GameObject locoVisual_PlayAreaQuest;

		public GameObject locoVisual_PlayAreaPSVR;

		public GameObject locoVisual_PlayAreaPico;

		[Space]
		public PlayerLight playerLight;

		[Space]
		public GameObject visual_OOB;

		[Space]
		public Material screenFader;

		[Space]
		public AudioScript playerAudio;

		[Space]
		public Fisheye fishEyeFX;

		[HideInInspector]
		public Locomotion movement;

		public ScreenFX screenFX;

		[SerializeField]
		public BoundDetection boundDetection;

		[SerializeField]
		private LayerMask standardLayerMask;

		public static NVRPlayer Instance => Instances.First((NVRPlayer player) => player != null && player.gameObject != null);

		public Vector3 PlayspaceSize
		{
			get
			{
				if (Integration != null)
				{
					return Integration.GetPlayspaceBounds();
				}
				if (OculusSDKEnabled)
				{
					Integration = new NVROculusIntegration();
					if (Integration.IsHmdPresent())
					{
						return Integration.GetPlayspaceBounds();
					}
					Integration = null;
				}
				if (OculusQuestSDKEnabled)
				{
					Integration = new NVROculusQuestIntegration();
					if (Integration.IsHmdPresent())
					{
						return Integration.GetPlayspaceBounds();
					}
					Integration = null;
				}
				if (SteamVREnabled)
				{
					Integration = new NVRSteamVRIntegration();
					if (Integration.IsHmdPresent())
					{
						return Integration.GetPlayspaceBounds();
					}
					Integration = null;
				}
				if (PSVREnabled)
				{
					Integration = new NVRPSVRIntegration();
					if (Integration.IsHmdPresent())
					{
						return Integration.GetPlayspaceBounds();
					}
					Integration = null;
				}
				if (PicoEnabled)
				{
					Integration = new NVRPicoIntegration();
					if (Integration.IsHmdPresent())
					{
						return Integration.GetPlayspaceBounds();
					}
					Integration = null;
				}
				return Vector3.zero;
			}
		}

		private void Awake()
		{
			if (AutoSetFixedDeltaTime)
			{
				Time.fixedDeltaTime = 0.0111f;
			}
			Instances.Add(this);
			NVRInteractables.Initialize();
			if (Head == null)
			{
				Head = GetComponentInChildren<NVRHead>();
			}
			Head.Initialize();
			if (LeftHand == null || RightHand == null)
			{
				UnityEngine.Debug.LogError("[FATAL ERROR] Please set the left and right hand to a nvrhands.");
			}
			watch.gameObject.SetActive(value: true);
			ColliderToHandMapping = new Dictionary<Collider, NVRHand>();
			StartCoroutine(SetupIntegration());
			StartCoroutine(PreWarmMenu());
		}

		private IEnumerator PreWarmMenu()
		{
			while (!HandMenu.player)
			{
				yield return null;
			}
			HandMenu.OpenMenu();
			Canvas.ForceUpdateCanvases();
		}

		private IEnumerator SetupIntegration(bool logOutput = true)
		{
			while (!SaveManager.instance.savedDataLoaded)
			{
				yield return Yield.WaitSeconds(0.5f);
			}
			StartCoroutine(SetupIntrgationRoutine(logOutput));
		}

		private IEnumerator SetupIntrgationRoutine(bool logOutput = true)
		{
			while (XRDevice.isPresent)
			{
				yield return Yield.WaitSeconds(1f);
			}
			ContinueSetupIntegration(logOutput);
		}

		private void ContinueSetupIntegration(bool logOutput = true)
		{
			CurrentIntegrationType = DetermineCurrentIntegration(logOutput);
			if (CurrentIntegrationType == NVRSDKIntegrations.Oculus)
			{
				Integration = new NVROculusIntegration();
			}
			else if (CurrentIntegrationType == NVRSDKIntegrations.OculusQuest)
			{
				Integration = new NVROculusQuestIntegration();
			}
			else if (CurrentIntegrationType == NVRSDKIntegrations.SteamVR)
			{
				Integration = new NVRSteamVRIntegration();
			}
			else if (CurrentIntegrationType == NVRSDKIntegrations.PSVR)
			{
				Integration = new NVRPSVRIntegration();
			}
			else
			{
				if (CurrentIntegrationType != NVRSDKIntegrations.Pico)
				{
					if (CurrentIntegrationType == NVRSDKIntegrations.FallbackNonVR)
					{
						if (logOutput)
						{
							UnityEngine.Debug.LogError("[NewtonVR] Fallback non-vr not yet implemented.");
						}
					}
					else if (logOutput)
					{
						UnityEngine.Debug.LogError("[NewtonVR] Critical Error: Oculus / SteamVR / Pico not setup properly or no headset found.");
					}
					return;
				}
				Integration = new NVRPicoIntegration();
			}
			if (Hands == null || Hands.Length == 0)
			{
				if (PreferenceManager.instance.GetInt(PlayerPreferences.PRIMARY_HAND.ToString()) == 0)
				{
					Hands = new NVRHand[2] { LeftHand, RightHand };
				}
				else
				{
					Hands = new NVRHand[2] { RightHand, LeftHand };
				}
				for (int i = 0; i < Hands.Length; i++)
				{
					Hands[i].PreInitialize(this);
				}
			}
			if (Integration != null)
			{
				Integration.Initialize(this);
			}
			standardLayerMask = mainCamera.cullingMask;
			if (OnInitialized != null)
			{
				OnInitialized.Invoke();
			}
		}

		public void ResetCullingMask()
		{
			mainCamera.cullingMask = standardLayerMask;
		}

		private void ReloadForPreferences()
		{
			SwapPrimaryHand();
			ControlsManager.instance.ChangeInteractButton();
		}

		public void MoveToSafeZone()
		{
			base.gameObject.transform.position = new Vector3(100f, 100f, 100f);
		}

		public void SwapPrimaryHand()
		{
			if (!swapHands)
			{
				swapHands = true;
				StartCoroutine(SwapHands());
			}
		}

		private IEnumerator SwapHands()
		{
			while (HandMenu.IsActive)
			{
				yield return null;
			}
			if (PreferenceManager.instance.GetInt(PlayerPreferences.PRIMARY_HAND.ToString()) == 0)
			{
				LeftHand.IsPrimary = true;
				RightHand.IsPrimary = false;
				HandMenu.transform.parent.parent = RightHand.gameObject.transform;
				HandMenu.transform.parent.position = RightHand.gameObject.transform.position;
				HandMenu.transform.parent.rotation = RightHand.gameObject.transform.rotation;
				HandMenu.SetToRight();
				watch.gameObject.transform.parent = RightHand.gameObject.transform;
				watch.gameObject.transform.position = RightHand.gameObject.transform.position;
				watch.gameObject.transform.rotation = RightHand.gameObject.transform.rotation;
				watch.SetToRight();
				LeftHand.UpdateHandPointer();
				RightHand.UpdateHandPointer();
			}
			else
			{
				LeftHand.IsPrimary = false;
				RightHand.IsPrimary = true;
				HandMenu.transform.parent.parent = LeftHand.gameObject.transform;
				HandMenu.transform.parent.position = LeftHand.gameObject.transform.position;
				HandMenu.transform.parent.rotation = LeftHand.gameObject.transform.rotation;
				HandMenu.SetToLeft();
				watch.gameObject.transform.parent = LeftHand.gameObject.transform;
				watch.gameObject.transform.position = LeftHand.gameObject.transform.position;
				watch.gameObject.transform.rotation = LeftHand.gameObject.transform.rotation;
				watch.SetToLeft();
				LeftHand.UpdateHandPointer();
				RightHand.UpdateHandPointer();
			}
			ControlsManager.instance.SetHands();
			swapHands = false;
		}

		public NVRSDKIntegrations DetermineCurrentIntegration(bool logOutput = true)
		{
			NVRSDKIntegrations nVRSDKIntegrations = NVRSDKIntegrations.None;
			string text = "[NewtonVR] Version : " + 1.22m + ". ";
			if (!XRDevice.isPresent)
			{
				text = text + "Found VRDevice: " + XRSettings.loadedDeviceName + ". ";
				UnityEngine.Debug.LogWarning("Neither SteamVR, Oculus SDK, or PSVR  is enabled in the NVRPlayer. Please check the \"Enable SteamVR\" or \"Enable Oculus SDK\" or \"Enable PSVR\" checkbox in the NVRPlayer script in the NVRPlayer GameObject.");
				nVRSDKIntegrations = NVRSDKIntegrations.Pico;
			}
			if (nVRSDKIntegrations == NVRSDKIntegrations.None)
			{
				if (DEBUGEnableFallback2D)
				{
					nVRSDKIntegrations = NVRSDKIntegrations.FallbackNonVR;
				}
				else
				{
					text += "Did not find supported VR device. Or no integrations enabled.";
				}
			}
			if (logOutput)
			{
				UnityEngine.Debug.Log(text);
			}
			return nVRSDKIntegrations;
		}

		public void RegisterHand(NVRHand hand)
		{
			Collider[] componentsInChildren = hand.GetComponentsInChildren<Collider>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				if (!ColliderToHandMapping.ContainsKey(componentsInChildren[i]))
				{
					ColliderToHandMapping.Add(componentsInChildren[i], hand);
				}
			}
		}

		public NVRHand GetHand(Collider collider)
		{
			return ColliderToHandMapping[collider];
		}

		public static void DeregisterInteractable(NVRInteractable interactable)
		{
			for (int i = 0; i < Instances.Count; i++)
			{
				if (!(Instances[i] != null) || Instances[i].Hands == null)
				{
					continue;
				}
				for (int j = 0; j < Instances[i].Hands.Length; j++)
				{
					if (Instances[i].Hands[j] != null)
					{
						Instances[i].Hands[j].DeregisterInteractable(interactable);
					}
				}
			}
		}

		public void ForceDropItems()
		{
			LeftHand.ForceDropItem();
			RightHand.ForceDropItem();
		}

		public void HandRendersActive(bool showHands, bool onlySecondary = false)
		{
			if (onlySecondary)
			{
				if (LeftHand.IsPrimary)
				{
					Renderer[] componentsInChildren = RightHand.RenderModel.GetComponentsInChildren<Renderer>();
					for (int i = 0; i < componentsInChildren.Length; i++)
					{
						componentsInChildren[i].enabled = showHands;
					}
				}
				else
				{
					Renderer[] componentsInChildren = LeftHand.RenderModel.GetComponentsInChildren<Renderer>();
					for (int i = 0; i < componentsInChildren.Length; i++)
					{
						componentsInChildren[i].enabled = showHands;
					}
				}
			}
			else
			{
				NVRHand[] hands = Hands;
				for (int i = 0; i < hands.Length; i++)
				{
					Renderer[] componentsInChildren = hands[i].RenderModel.GetComponentsInChildren<Renderer>();
					for (int j = 0; j < componentsInChildren.Length; j++)
					{
						componentsInChildren[j].enabled = showHands;
					}
				}
			}
			watch.gameObject.SetActive(showHands);
		}

		public void SetPosition(GameObject pos, bool setRotation = true)
		{
			Vector3 vector = new Vector3(0f, 0.05f, 0f);
			if (NavMesh.SamplePosition(pos.transform.position, out var hit, 1f, -1))
			{
				base.gameObject.transform.position = hit.position - vector;
			}
			else
			{
				base.gameObject.transform.position = pos.transform.position - vector;
			}
			if (setRotation)
			{
				if (CurrentIntegrationType == NVRSDKIntegrations.SteamVR)
				{
					if (XRDevice.model.IndexOf("oculus", StringComparison.CurrentCultureIgnoreCase) != -1)
					{
						base.gameObject.transform.rotation = pos.transform.rotation;
					}
					else
					{
						base.gameObject.transform.rotation = pos.transform.rotation;
						float y = base.gameObject.transform.eulerAngles.y - Head.gameObject.transform.eulerAngles.y;
						base.gameObject.transform.Rotate(new Vector3(0f, y, 0f));
					}
				}
				else
				{
					base.gameObject.transform.rotation = pos.transform.rotation;
				}
			}
			if ((bool)locoVisual)
			{
				locoVisual.transform.position = new Vector3(locoVisual.transform.position.x, pos.transform.position.y, locoVisual.transform.position.z);
			}
		}

		public void AddToLayerMask(string layerName)
		{
			mainCamera.cullingMask = (mainCamera.cullingMask |= 1 << LayerMask.NameToLayer(layerName));
		}

		public void AddToLayerMask(int layer)
		{
			mainCamera.cullingMask = (mainCamera.cullingMask |= 1 << layer);
		}

		public void SubtractFromLayerMask(string layerName)
		{
			mainCamera.cullingMask = (mainCamera.cullingMask &= ~(1 << LayerMask.NameToLayer(layerName)));
		}

		public void SubtractFromLayerMask(int layer)
		{
			mainCamera.cullingMask = (mainCamera.cullingMask &= ~(1 << layer));
		}

		private void OnDestroy()
		{
			Instances.Remove(this);
		}

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.W))
			{
				GameController.instance.GotoNextScene();
			}
			if (Input.GetKeyDown(KeyCode.T))
			{
				GameController.instance.GoToSpecificScene(SCENES.TOMB);
			}
			if (DEBUGDropFrames)
			{
				Thread.Sleep(DEBUGSleepPerFrame);
			}
			if (movement == null)
			{
				movement = Head.GetComponent<Locomotion>();
			}
		}

		public void BeginShutdownVR()
		{
			StartCoroutine(ShutdownVR());
		}

		private IEnumerator ShutdownVR()
		{
			XRSettings.LoadDeviceByName("None");
			yield return null;
			XRSettings.enabled = false;
			XRSettings.showDeviceView = false;
			Camera.main.fieldOfView = 60f;
			Camera.main.ResetAspect();
			SceneManager.LoadScene(0);
		}

		public void SetupHMDDevice()
		{
		}
	}
	public enum NVRSDKIntegrations
	{
		None,
		FallbackNonVR,
		SteamVR,
		Oculus,
		OculusQuest,
		PSVR,
		Pico
	}
	public class NVRSlider : NVRInteractable
	{
		[Tooltip("Set to zero when the slider is at StartPoint. Set to one when the slider is at EndPoint.")]
		public float CurrentValue;

		[Tooltip("A transform at the position of the zero point of the slider")]
		public Transform StartPoint;

		[Tooltip("A transform at the position of the one point of the slider")]
		public Transform EndPoint;

		protected float AttachedPositionMagic = 3000f;

		protected Transform PickupTransform;

		protected Vector3 SliderPath;

		protected override void Awake()
		{
			base.Awake();
			if (StartPoint == null)
			{
				UnityEngine.Debug.LogError("This slider has no StartPoint.");
			}
			if (EndPoint == null)
			{
				UnityEngine.Debug.LogError("This slider has no EndPoint.");
			}
			base.transform.position = Vector3.Lerp(StartPoint.position, EndPoint.position, CurrentValue);
			SliderPath = EndPoint.position - StartPoint.position;
		}

		protected virtual void FixedUpdate()
		{
			if (IsAttached && !CheckForDrop())
			{
				Vector3 velocity = (PickupTransform.position - base.transform.position) * AttachedPositionMagic * Time.deltaTime;
				Rigidbody.velocity = ProjectVelocityOnPath(velocity, SliderPath);
			}
			if (base.transform.hasChanged)
			{
				float num = Vector3.Distance(StartPoint.position, EndPoint.position);
				float num2 = Vector3.Distance(StartPoint.position, base.transform.position);
				CurrentValue = num2 / num;
				base.transform.hasChanged = false;
			}
		}

		public override void BeginInteraction(NVRHand hand, bool runBeginInteractionCallback = true)
		{
			base.BeginInteraction(hand, runBeginInteractionCallback);
			PickupTransform = new GameObject($"[{base.gameObject.name}] PickupTransform").transform;
			PickupTransform.parent = hand.transform;
			PickupTransform.position = base.transform.position;
			PickupTransform.rotation = base.transform.rotation;
		}

		public override void EndInteraction(NVRHand hand)
		{
			base.EndInteraction(hand);
			if (PickupTransform != null)
			{
				UnityEngine.Object.Destroy(PickupTransform.gameObject);
			}
		}

		protected Vector3 ProjectVelocityOnPath(Vector3 velocity, Vector3 path)
		{
			return Vector3.Project(velocity, path);
		}
	}
	public class NVRSwitch : MonoBehaviour
	{
		public bool CurrentState = true;

		public bool LastState = true;

		private bool FixedState = true;

		public Transform OnButton;

		public Renderer OnButtonRenderer;

		public Transform OffButton;

		public Renderer OffButtonRenderer;

		private Rigidbody Rigidbody;

		private float ForceMagic = 100f;

		private void Awake()
		{
			Rigidbody = GetComponent<Rigidbody>();
			SetRotation(CurrentState);
		}

		private void FixedUpdate()
		{
			float num = base.transform.localEulerAngles.z;
			if (num > 180f)
			{
				num -= 360f;
			}
			if (num > -7.5f)
			{
				if (num < -0.2f)
				{
					Rigidbody.AddForceAtPosition(-base.transform.right * ForceMagic, OnButton.position);
				}
				else if ((num > -0.2f && num < -0.1f) || num > 0.1f)
				{
					SetRotation(forState: true);
				}
			}
			else if (num < -7.5f)
			{
				if (num > -14.8f)
				{
					Rigidbody.AddForceAtPosition(-base.transform.right * ForceMagic, OffButton.position);
				}
				else if ((num < -14.8f && num > -14.9f) || (double)num < -15.1)
				{
					SetRotation(forState: false);
				}
			}
		}

		private void Update()
		{
			LastState = CurrentState;
			CurrentState = FixedState;
		}

		private void SetRotation(bool forState)
		{
			FixedState = forState;
			if (FixedState)
			{
				base.transform.localEulerAngles = Vector3.zero;
				OnButtonRenderer.material.color = UnityEngine.Color.yellow;
				OffButtonRenderer.material.color = UnityEngine.Color.white;
			}
			else
			{
				base.transform.localEulerAngles = new Vector3(0f, 0f, -15f);
				OnButtonRenderer.material.color = UnityEngine.Color.white;
				OffButtonRenderer.material.color = UnityEngine.Color.red;
			}
			Rigidbody.angularVelocity = Vector3.zero;
			Rigidbody.velocity = Vector3.zero;
		}
	}
	public class NVRSwitchItem : NVRInteractableItem
	{
		private bool active;

		private new void Update()
		{
			if (ControlsManager.instance.interactPrimaryDown || ControlsManager.instance.interactSecondaryDown)
			{
				active = !active;
				UnityEngine.Debug.Log(active);
			}
		}
	}
	public class NVRUIIgnoreRaycast : MonoBehaviour, ICanvasRaycastFilter
	{
		public bool IsRaycastLocationValid(Vector2 sp, Camera eventCamera)
		{
			return false;
		}
	}
	public class NVROculusInputDevice : NVRInputDevice
	{
		public override bool IsCurrentlyTracked
		{
			get
			{
				throw new NotImplementedException();
			}
		}

		public override bool GetAxis1DRightDown(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetAxis1DLeftDown(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetAxis1DRightUp(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetAxis1DLeftUp(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override Vector2 GetAxis2DRight(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override Vector2 GetAxis2DLeft(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override string GetDeviceName()
		{
			throw new NotImplementedException();
		}

		public override bool GetPressA(NVRButtons button)
		{
			return false;
		}

		public override bool GetPressB(NVRButtons button)
		{
			return false;
		}

		public override bool GetPressX(NVRButtons button)
		{
			return false;
		}

		public override bool GetPressY(NVRButtons button)
		{
			return false;
		}

		public override bool GetPressGripLeft(NVRButtons button)
		{
			return false;
		}

		public override bool GetPressGripRight(NVRButtons button)
		{
			return false;
		}

		public override bool GetPressTriggerLeft(NVRButtons button)
		{
			return false;
		}

		public override bool GetPressTriggerRight(NVRButtons button)
		{
			return false;
		}

		public override bool GetPressAppLeft(NVRButtons button)
		{
			return false;
		}

		public override bool GetPressAppRight(NVRButtons button)
		{
			return false;
		}

		public override bool GetPressDownA(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetPressDownB(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetPressDownX(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetPressDownY(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetPressDownApp(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetPressUpA(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetPressUpB(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetPressUpX(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetPressUpY(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetPressUpApp(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetRightDown(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetLeftDown(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetRightUp(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetLeftUp(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool ReadyToInitialize()
		{
			throw new NotImplementedException();
		}

		public override Collider[] SetupDefaultColliders()
		{
			throw new NotImplementedException();
		}

		public override Collider[] SetupDefaultPhysicalColliders(Transform ModelParent)
		{
			throw new NotImplementedException();
		}

		public override GameObject SetupDefaultRenderModel()
		{
			throw new NotImplementedException();
		}

		public override void TriggerHapticPulse(float power = 0.2f, ushort durationMicroSec = 500, NVRButtons button = NVRButtons.Touchpad)
		{
			throw new NotImplementedException();
		}

		public override void TriggerHapticPulse(VibrationForce force, float time)
		{
			throw new NotImplementedException();
		}
	}
	public class NVROculusIntegration : NVRIntegration
	{
		public override void Initialize(NVRPlayer player)
		{
		}

		public override Vector3 GetPlayspaceBounds()
		{
			return Vector3.zero;
		}

		public override bool IsHmdPresent()
		{
			return false;
		}
	}
	public class NVROculusQuestIntegration : NVRIntegration
	{
		public override void Initialize(NVRPlayer player)
		{
		}

		public override Vector3 GetPlayspaceBounds()
		{
			return Vector3.zero;
		}

		public override bool IsHmdPresent()
		{
			return false;
		}
	}
	public class NVRPicoIntegration : NVRIntegration
	{
		private Vector3 PlayspaceBounds = Vector3.zero;

		public override void Initialize(NVRPlayer player)
		{
			Player = player;
			Player.gameObject.SetActive(value: false);
			Player.gameObject.AddComponent<OVRManager>().trackingOriginType = OVRManager.TrackingOrigin.FloorLevel;
			PicoCameraRig obj = player.gameObject.AddComponent<PicoCameraRig>();
			Player.Head.gameObject.AddComponent<Locomotion>();
			NVRHelpers.SetProperty(obj, "trackingSpace", Player.transform, isPublic: true);
			NVRHelpers.SetProperty(obj, "leftHandAnchor", Player.LeftHand.transform, isPublic: true);
			NVRHelpers.SetProperty(obj, "rightHandAnchor", Player.RightHand.transform, isPublic: true);
			NVRHelpers.SetProperty(obj, "centerEyeAnchor", Player.Head.transform, isPublic: true);
			Player.gameObject.SetActive(value: true);
			Player.HandMenu.InitialiseMenu();
		}

		public override Vector3 GetPlayspaceBounds()
		{
			return PlayspaceBounds;
		}

		public override bool IsHmdPresent()
		{
			if (!Application.isPlaying && !XRSettings.enabled)
			{
				XRSettings.enabled = true;
			}
			return true;
		}
	}
	public class NVRPSVRInputDevice : NVRInputDevice
	{
		public override bool IsCurrentlyTracked
		{
			get
			{
				throw new NotImplementedException();
			}
		}

		public override bool GetAxis1DRightDown(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetAxis1DLeftDown(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetAxis1DRightUp(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetAxis1DLeftUp(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override Vector2 GetAxis2DRight(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override Vector2 GetAxis2DLeft(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override string GetDeviceName()
		{
			throw new NotImplementedException();
		}

		public override bool GetPressA(NVRButtons button)
		{
			return false;
		}

		public override bool GetPressB(NVRButtons button)
		{
			return false;
		}

		public override bool GetPressX(NVRButtons button)
		{
			return false;
		}

		public override bool GetPressY(NVRButtons button)
		{
			return false;
		}

		public override bool GetPressGripLeft(NVRButtons button)
		{
			return false;
		}

		public override bool GetPressGripRight(NVRButtons button)
		{
			return false;
		}

		public override bool GetPressTriggerLeft(NVRButtons button)
		{
			return false;
		}

		public override bool GetPressTriggerRight(NVRButtons button)
		{
			return false;
		}

		public override bool GetPressAppLeft(NVRButtons button)
		{
			return false;
		}

		public override bool GetPressAppRight(NVRButtons button)
		{
			return false;
		}

		public override bool GetPressDownA(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetPressDownB(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetPressDownX(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetPressDownY(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetPressDownApp(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetPressUpA(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetPressUpB(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetPressUpX(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetPressUpY(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetPressUpApp(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetRightDown(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetLeftDown(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetRightUp(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetLeftUp(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool ReadyToInitialize()
		{
			throw new NotImplementedException();
		}

		public override Collider[] SetupDefaultColliders()
		{
			throw new NotImplementedException();
		}

		public override Collider[] SetupDefaultPhysicalColliders(Transform ModelParent)
		{
			throw new NotImplementedException();
		}

		public override GameObject SetupDefaultRenderModel()
		{
			throw new NotImplementedException();
		}

		public override void TriggerHapticPulse(float power = 0.2f, ushort durationMicroSec = 500, NVRButtons button = NVRButtons.Touchpad)
		{
			throw new NotImplementedException();
		}

		public override void TriggerHapticPulse(VibrationForce force, float time)
		{
			throw new NotImplementedException();
		}
	}
	public class NVRPSVRIntegration : NVRIntegration
	{
		public override void Initialize(NVRPlayer player)
		{
			UnityEngine.Debug.Log("Not Using PSVR");
		}

		public override Vector3 GetPlayspaceBounds()
		{
			return Vector3.zero;
		}

		public override bool IsHmdPresent()
		{
			return false;
		}
	}
	public class NVRSteamVRInputDevice : NVRInputDevice
	{
		public override bool IsCurrentlyTracked
		{
			get
			{
				throw new NotImplementedException();
			}
		}

		public override bool GetAxis1DRightDown(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetAxis1DLeftDown(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetAxis1DRightUp(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetAxis1DLeftUp(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override Vector2 GetAxis2DRight(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override Vector2 GetAxis2DLeft(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override string GetDeviceName()
		{
			throw new NotImplementedException();
		}

		public override bool GetPressA(NVRButtons button)
		{
			return false;
		}

		public override bool GetPressB(NVRButtons button)
		{
			return false;
		}

		public override bool GetPressX(NVRButtons button)
		{
			return false;
		}

		public override bool GetPressY(NVRButtons button)
		{
			return false;
		}

		public override bool GetPressGripLeft(NVRButtons button)
		{
			return false;
		}

		public override bool GetPressGripRight(NVRButtons button)
		{
			return false;
		}

		public override bool GetPressTriggerLeft(NVRButtons button)
		{
			return false;
		}

		public override bool GetPressTriggerRight(NVRButtons button)
		{
			return false;
		}

		public override bool GetPressAppLeft(NVRButtons button)
		{
			return false;
		}

		public override bool GetPressAppRight(NVRButtons button)
		{
			return false;
		}

		public override bool GetPressDownA(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetPressDownB(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetPressDownX(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetPressDownY(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetPressDownApp(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetPressUpA(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetPressUpB(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetPressUpX(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetPressUpY(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetPressUpApp(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetRightDown(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetLeftDown(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetRightUp(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool GetLeftUp(NVRButtons button)
		{
			throw new NotImplementedException();
		}

		public override bool ReadyToInitialize()
		{
			throw new NotImplementedException();
		}

		public override Collider[] SetupDefaultColliders()
		{
			throw new NotImplementedException();
		}

		public override Collider[] SetupDefaultPhysicalColliders(Transform ModelParent)
		{
			throw new NotImplementedException();
		}

		public override GameObject SetupDefaultRenderModel()
		{
			throw new NotImplementedException();
		}

		public override void TriggerHapticPulse(float power = 0.2f, ushort durationMicroSec = 500, NVRButtons button = NVRButtons.Touchpad)
		{
			throw new NotImplementedException();
		}

		public override void TriggerHapticPulse(VibrationForce force, float time)
		{
			throw new NotImplementedException();
		}
	}
	public class NVRSteamVRIntegration : NVRIntegration
	{
		public override void Initialize(NVRPlayer player)
		{
		}

		public override Vector3 GetPlayspaceBounds()
		{
			return Vector3.zero;
		}

		public override bool IsHmdPresent()
		{
			return false;
		}
	}
}
namespace NewtonVR.Example
{
	public class NVRExampleButtonDropSphere : MonoBehaviour
	{
		public void DropSphere()
		{
			GameObject obj = GameObject.CreatePrimitive(PrimitiveType.Sphere);
			obj.transform.position = new Vector3(0f, 20f, 0f);
			obj.transform.localScale = Vector3.one * 0.1f;
			obj.AddComponent<Rigidbody>();
			obj.AddComponent<NVRInteractableItem>();
		}
	}
	public class NVRExampleButtonResetScene : MonoBehaviour
	{
		public void ResetScene()
		{
			SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex);
		}
	}
	public class NVRExampleColorLever : MonoBehaviour
	{
		public UnityEngine.Color From;

		public UnityEngine.Color To;

		public Renderer Result;

		public NVRLever Lever;

		private void Update()
		{
			Result.material.color = UnityEngine.Color.Lerp(From, To, Lever.CurrentValue);
		}
	}
	public class NVRExampleColorSlider : MonoBehaviour
	{
		public UnityEngine.Color From;

		public UnityEngine.Color To;

		public Renderer Result;

		public NVRSlider Slider;

		private void Update()
		{
			Result.material.color = UnityEngine.Color.Lerp(From, To, Slider.CurrentValue);
		}
	}
	public class NVRExampleDegreeResult : MonoBehaviour
	{
		public NVRInteractableItem Knob;

		private TextMesh Text;

		private void Awake()
		{
			Text = GetComponent<TextMesh>();
		}

		private void Update()
		{
			Text.text = ((int)Knob.transform.localEulerAngles.y).ToString();
		}
	}
	public class NVRExampleEvent : MonoBehaviour
	{
		public void Duplicate()
		{
			GameObject obj = UnityEngine.Object.Instantiate(base.gameObject);
			obj.transform.Translate(0f, UnityEngine.Random.value, 0f, Space.World);
			obj.GetComponent<NVRInteractableItem>().ResetInteractable();
		}
	}
	public class NVRExampleGrower : NVRInteractableItem
	{
		public override void InteractingUpdate(NVRHand hand)
		{
			base.InteractingUpdate(hand);
			if (hand.Inputs[NVRButtons.Touchpad].PressUpA || hand.Inputs[NVRButtons.Touchpad].PressUpB || hand.Inputs[NVRButtons.Touchpad].PressUpX || hand.Inputs[NVRButtons.Touchpad].PressUpY)
			{
				Vector3 insideUnitSphere = UnityEngine.Random.insideUnitSphere;
				insideUnitSphere *= Colliders[0].bounds.extents.x;
				insideUnitSphere += Colliders[0].bounds.center;
				insideUnitSphere += Colliders[0].bounds.extents;
				GameObject obj = GameObject.CreatePrimitive(PrimitiveType.Cube);
				obj.transform.parent = base.transform;
				obj.transform.localScale = base.transform.localScale / 2f;
				obj.transform.position = insideUnitSphere;
				UpdateColliders();
			}
		}
	}
	public class NVRExampleGun : NVRInteractableItem
	{
		public GameObject BulletPrefab;

		public Transform FirePoint;

		public Vector3 BulletForce = new Vector3(0f, 0f, 250f);

		public override void UseButtonDown()
		{
			base.UseButtonDown();
			GameObject obj = UnityEngine.Object.Instantiate(BulletPrefab);
			obj.transform.position = FirePoint.position;
			obj.transform.forward = FirePoint.forward;
			obj.GetComponent<Rigidbody>().AddRelativeForce(BulletForce);
			base.AttachedHand.TriggerHapticPulse(5f);
		}
	}
	public class NVRExampleLaserPointer : MonoBehaviour
	{
		public UnityEngine.Color LineColor;

		public float LineWidth = 0.02f;

		public bool ForceLineVisible = true;

		public bool OnlyVisibleOnTrigger = true;

		private LineRenderer Line;

		private NVRHand Hand;

		private void Awake()
		{
			Line = GetComponent<LineRenderer>();
			Hand = GetComponent<NVRHand>();
			if (Line == null)
			{
				Line = base.gameObject.AddComponent<LineRenderer>();
			}
			if (Line.sharedMaterial == null)
			{
				Line.material = new Material(Shader.Find("Unlit/Color"));
				Line.material.SetColor("_Color", LineColor);
				NVRHelpers.LineRendererSetColor(Line, LineColor, LineColor);
			}
			Line.useWorldSpace = true;
		}

		private void LateUpdate()
		{
			Line.enabled = ForceLineVisible || (OnlyVisibleOnTrigger && Hand != null);
			if (Line.enabled)
			{
				Line.material.SetColor("_Color", LineColor);
				NVRHelpers.LineRendererSetColor(Line, LineColor, LineColor);
				NVRHelpers.LineRendererSetWidth(Line, LineWidth, LineWidth);
				RaycastHit hitInfo;
				Vector3 vector = ((!Physics.Raycast(base.transform.position, base.transform.forward, out hitInfo, 1000f)) ? (base.transform.position + base.transform.forward * 1000f) : hitInfo.point);
				Line.SetPositions(new Vector3[2]
				{
					base.transform.position,
					vector
				});
			}
		}
	}
	public class NVRExampleLetterResult : MonoBehaviour
	{
		public NVRLetterSpinner LetterSpinner;

		private TextMesh Text;

		private void Awake()
		{
			Text = GetComponent<TextMesh>();
		}

		private void Update()
		{
			Text.text = LetterSpinner.GetLetter();
		}
	}
	public class NVRExampleLeverResultRocket : MonoBehaviour
	{
		public GameObject RocketPrefab;

		public NVRLever Control;

		private GameObject RocketInstance;

		private void Awake()
		{
			StartCoroutine(DoSpawnShip());
		}

		private void Update()
		{
			if (Control.LeverEngaged)
			{
				StartCoroutine(DoBlastOff());
			}
		}

		public IEnumerator DoBlastOff()
		{
			RocketInstance.GetComponent<Rigidbody>().AddRelativeForce(new Vector3(0f, 1000f, 0f), ForceMode.Force);
			yield return Yield.WaitSeconds(0.5f);
			StartCoroutine(DoSpawnShip());
		}

		private IEnumerator DoSpawnShip()
		{
			RocketInstance = UnityEngine.Object.Instantiate(RocketPrefab, base.transform.position, base.transform.rotation);
			RocketInstance.GetComponent<Rigidbody>().isKinematic = true;
			RocketInstance.GetComponent<NVRInteractableItem>().CanAttach = false;
			Vector3 startScale = Vector3.one * 0.1f;
			Vector3 endScale = Vector3.one;
			float startTime = Time.time;
			float overTime = 0.5f;
			float stopTime = startTime + overTime;
			while (Time.time < stopTime)
			{
				RocketInstance.transform.localScale = Vector3.Lerp(startScale, endScale, (Time.time - startTime) / overTime);
				yield return null;
			}
			RocketInstance.GetComponent<Rigidbody>().isKinematic = false;
			RocketInstance.GetComponent<NVRInteractableItem>().CanAttach = true;
		}
	}
	public class NVRExampleRGBResult : MonoBehaviour
	{
		public NVRSlider SliderRed;

		public NVRSlider SliderGreen;

		public NVRSlider SliderBlue;

		public Renderer Result;

		private void Update()
		{
			Result.material.color = new UnityEngine.Color(SliderRed.CurrentValue, SliderGreen.CurrentValue, SliderBlue.CurrentValue);
		}
	}
	public class NVRExampleSpawner : MonoBehaviour
	{
		public NVRButton Button;

		public GameObject ToCopy;

		private void Update()
		{
			if (Button.ButtonDown)
			{
				GameObject obj = UnityEngine.Object.Instantiate(ToCopy);
				obj.transform.position = base.transform.position + new Vector3(0f, 1f, 0f);
				obj.transform.localScale = ToCopy.transform.lossyScale;
			}
		}
	}
	public class NVRExampleSwitchResult : MonoBehaviour
	{
		public NVRSwitch Switch;

		private Light SpotLight;

		private void Awake()
		{
			SpotLight = GetComponent<Light>();
		}

		private void Update()
		{
			SpotLight.enabled = Switch.CurrentState;
		}
	}
	[RequireComponent(typeof(NVRHand))]
	public class NVRExampleTeleporter : MonoBehaviour
	{
		public UnityEngine.Color LineColor;

		public float LineWidth = 0.02f;

		private LineRenderer Line;

		private NVRHand Hand;

		private NVRPlayer Player;

		private void Awake()
		{
			Line = GetComponent<LineRenderer>();
			Hand = GetComponent<NVRHand>();
			if (Line == null)
			{
				Line = base.gameObject.AddComponent<LineRenderer>();
			}
			if (Line.sharedMaterial == null)
			{
				Line.material = new Material(Shader.Find("Unlit/Color"));
				Line.material.SetColor("_Color", LineColor);
				NVRHelpers.LineRendererSetColor(Line, LineColor, LineColor);
			}
			Line.useWorldSpace = true;
		}

		private void Start()
		{
			Player = Hand.Player;
		}

		private void LateUpdate()
		{
			if (Player == Hand.Player.RightHand)
			{
				Line.enabled = Hand != null && Hand.Inputs[NVRButtons.Trigger].SingleAxisRightDown;
				if (!Line.enabled)
				{
					return;
				}
				Line.material.SetColor("_Color", LineColor);
				NVRHelpers.LineRendererSetColor(Line, LineColor, LineColor);
				NVRHelpers.LineRendererSetWidth(Line, LineWidth, LineWidth);
				Vector3 vector;
				if (Physics.Raycast(base.transform.position, base.transform.forward, out var hitInfo, 1000f))
				{
					vector = hitInfo.point;
					if (Hand.Inputs[NVRButtons.Trigger].PressDownA)
					{
						NVRInteractable currentlyInteracting = Player.LeftHand.CurrentlyInteracting;
						NVRInteractable currentlyInteracting2 = Player.RightHand.CurrentlyInteracting;
						Vector3 vector2 = Player.Head.transform.position - Player.transform.position;
						vector2.y = 0f;
						Player.transform.position = hitInfo.point - vector2;
						if (currentlyInteracting != null)
						{
							currentlyInteracting.transform.position = Player.LeftHand.transform.position;
						}
						if (currentlyInteracting2 != null)
						{
							currentlyInteracting2.transform.position = Player.RightHand.transform.position;
						}
					}
					else if (Hand.Inputs[NVRButtons.Trigger].PressDownB)
					{
						NVRInteractable currentlyInteracting3 = Player.LeftHand.CurrentlyInteracting;
						NVRInteractable currentlyInteracting4 = Player.RightHand.CurrentlyInteracting;
						Vector3 vector3 = Player.Head.transform.position - Player.transform.position;
						vector3.y = 0f;
						Player.transform.position = hitInfo.point - vector3;
						if (currentlyInteracting3 != null)
						{
							currentlyInteracting3.transform.position = Player.LeftHand.transform.position;
						}
						if (currentlyInteracting4 != null)
						{
							currentlyInteracting4.transform.position = Player.RightHand.transform.position;
						}
					}
				}
				else
				{
					vector = base.transform.position + base.transform.forward * 1000f;
				}
				Line.SetPositions(new Vector3[2]
				{
					base.transform.position,
					vector
				});
			}
			else
			{
				if (!(Player == Hand.Player.LeftHand))
				{
					return;
				}
				Line.enabled = Hand != null && Hand.Inputs[NVRButtons.Trigger].SingleAxisLeftDown;
				if (!Line.enabled)
				{
					return;
				}
				Line.material.SetColor("_Color", LineColor);
				Line.material.SetColor("_Color", LineColor);
				NVRHelpers.LineRendererSetColor(Line, LineColor, LineColor);
				NVRHelpers.LineRendererSetWidth(Line, LineWidth, LineWidth);
				Vector3 vector4;
				if (Physics.Raycast(base.transform.position, base.transform.forward, out var hitInfo2, 1000f))
				{
					vector4 = hitInfo2.point;
					if (Hand.Inputs[NVRButtons.Trigger].PressDownX)
					{
						NVRInteractable currentlyInteracting5 = Player.LeftHand.CurrentlyInteracting;
						NVRInteractable currentlyInteracting6 = Player.RightHand.CurrentlyInteracting;
						Vector3 vector5 = Player.Head.transform.position - Player.transform.position;
						vector5.y = 0f;
						Player.transform.position = hitInfo2.point - vector5;
						if (currentlyInteracting5 != null)
						{
							currentlyInteracting5.transform.position = Player.LeftHand.transform.position;
						}
						if (currentlyInteracting6 != null)
						{
							currentlyInteracting6.transform.position = Player.RightHand.transform.position;
						}
					}
					else if (Hand.Inputs[NVRButtons.Trigger].PressDownY)
					{
						NVRInteractable currentlyInteracting7 = Player.LeftHand.CurrentlyInteracting;
						NVRInteractable currentlyInteracting8 = Player.RightHand.CurrentlyInteracting;
						Vector3 vector6 = Player.Head.transform.position - Player.transform.position;
						vector6.y = 0f;
						Player.transform.position = hitInfo2.point - vector6;
						if (currentlyInteracting7 != null)
						{
							currentlyInteracting7.transform.position = Player.LeftHand.transform.position;
						}
						if (currentlyInteracting8 != null)
						{
							currentlyInteracting8.transform.position = Player.RightHand.transform.position;
						}
					}
				}
				else
				{
					vector4 = base.transform.position + base.transform.forward * 1000f;
				}
				Line.SetPositions(new Vector3[2]
				{
					base.transform.position,
					vector4
				});
			}
		}
	}
}
