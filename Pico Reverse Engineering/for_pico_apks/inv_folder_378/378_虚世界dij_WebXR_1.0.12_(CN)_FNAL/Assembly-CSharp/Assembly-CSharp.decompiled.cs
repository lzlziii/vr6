using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Net;
using System.Net.Security;
using System.Net.Sockets;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Security.Principal;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Windows.Forms;
using Cinemachine;
using Cinemachine.Utility;
using DG.Tweening;
using DG.Tweening.Core;
using HedgehogTeam.EasyTouch;
using LitJson;
using SocketIO;
using Unity.XR.CoreUtils;
using Unity.XR.PXR;
using UnityEngine;
using UnityEngine.AI;
using UnityEngine.EventSystems;
using UnityEngine.Events;
using UnityEngine.InputSystem;
using UnityEngine.InputSystem.Controls;
using UnityEngine.InputSystem.EnhancedTouch;
using UnityEngine.InputSystem.Interactions;
using UnityEngine.InputSystem.Layouts;
using UnityEngine.InputSystem.LowLevel;
using UnityEngine.InputSystem.Utilities;
using UnityEngine.Networking;
using UnityEngine.SceneManagement;
using UnityEngine.Serialization;
using UnityEngine.UI;
using UnityEngine.Video;
using UnityEngine.XR;
using UnityEngine.XR.Interaction.Toolkit;
using UnityEngine.XR.Interaction.Toolkit.Inputs;
using UnityStandardAssets.CrossPlatformInput;
using UnityStandardAssets.CrossPlatformInput.PlatformSpecific;
using UnityStandardAssets.Utility;
using WebSocketSharp;
using WebSocketSharp.Net;
using WebSocketSharp.Net.Security;
using WebSocketSharp.Net.WebSockets;

[assembly: CompilationRelaxations(8)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: AssemblyTitle("websocket-sharp")]
[assembly: AssemblyDescription("A C# implementation of the WebSocket protocol client and server")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("websocket-sharp.dll")]
[assembly: AssemblyCopyright("sta.blockhead")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyVersion("1.0.2.0")]
public class ControllerSampleInputActions : IInputActionCollection2, IInputActionCollection, IEnumerable<InputAction>, IEnumerable, IDisposable
{
	public struct RightControllerActions
	{
		private ControllerSampleInputActions m_Wrapper;

		public InputAction Trigger => m_Wrapper.m_RightController_Trigger;

		public InputAction Grip => m_Wrapper.m_RightController_Grip;

		public InputAction AX => m_Wrapper.m_RightController_AX;

		public InputAction BY => m_Wrapper.m_RightController_BY;

		public InputAction JoystickClick => m_Wrapper.m_RightController_JoystickClick;

		public InputAction App => m_Wrapper.m_RightController_App;

		public bool enabled => Get().enabled;

		public RightControllerActions(ControllerSampleInputActions wrapper)
		{
			m_Wrapper = wrapper;
		}

		public InputActionMap Get()
		{
			return m_Wrapper.m_RightController;
		}

		public void Enable()
		{
			Get().Enable();
		}

		public void Disable()
		{
			Get().Disable();
		}

		public static implicit operator InputActionMap(RightControllerActions set)
		{
			return set.Get();
		}

		public void SetCallbacks(IRightControllerActions instance)
		{
			if (m_Wrapper.m_RightControllerActionsCallbackInterface != null)
			{
				Trigger.started -= m_Wrapper.m_RightControllerActionsCallbackInterface.OnTrigger;
				Trigger.performed -= m_Wrapper.m_RightControllerActionsCallbackInterface.OnTrigger;
				Trigger.canceled -= m_Wrapper.m_RightControllerActionsCallbackInterface.OnTrigger;
				Grip.started -= m_Wrapper.m_RightControllerActionsCallbackInterface.OnGrip;
				Grip.performed -= m_Wrapper.m_RightControllerActionsCallbackInterface.OnGrip;
				Grip.canceled -= m_Wrapper.m_RightControllerActionsCallbackInterface.OnGrip;
				AX.started -= m_Wrapper.m_RightControllerActionsCallbackInterface.OnAX;
				AX.performed -= m_Wrapper.m_RightControllerActionsCallbackInterface.OnAX;
				AX.canceled -= m_Wrapper.m_RightControllerActionsCallbackInterface.OnAX;
				BY.started -= m_Wrapper.m_RightControllerActionsCallbackInterface.OnBY;
				BY.performed -= m_Wrapper.m_RightControllerActionsCallbackInterface.OnBY;
				BY.canceled -= m_Wrapper.m_RightControllerActionsCallbackInterface.OnBY;
				JoystickClick.started -= m_Wrapper.m_RightControllerActionsCallbackInterface.OnJoystickClick;
				JoystickClick.performed -= m_Wrapper.m_RightControllerActionsCallbackInterface.OnJoystickClick;
				JoystickClick.canceled -= m_Wrapper.m_RightControllerActionsCallbackInterface.OnJoystickClick;
				App.started -= m_Wrapper.m_RightControllerActionsCallbackInterface.OnApp;
				App.performed -= m_Wrapper.m_RightControllerActionsCallbackInterface.OnApp;
				App.canceled -= m_Wrapper.m_RightControllerActionsCallbackInterface.OnApp;
			}
			m_Wrapper.m_RightControllerActionsCallbackInterface = instance;
			if (instance != null)
			{
				Trigger.started += instance.OnTrigger;
				Trigger.performed += instance.OnTrigger;
				Trigger.canceled += instance.OnTrigger;
				Grip.started += instance.OnGrip;
				Grip.performed += instance.OnGrip;
				Grip.canceled += instance.OnGrip;
				AX.started += instance.OnAX;
				AX.performed += instance.OnAX;
				AX.canceled += instance.OnAX;
				BY.started += instance.OnBY;
				BY.performed += instance.OnBY;
				BY.canceled += instance.OnBY;
				JoystickClick.started += instance.OnJoystickClick;
				JoystickClick.performed += instance.OnJoystickClick;
				JoystickClick.canceled += instance.OnJoystickClick;
				App.started += instance.OnApp;
				App.performed += instance.OnApp;
				App.canceled += instance.OnApp;
			}
		}
	}

	public struct LeftControllerActions
	{
		private ControllerSampleInputActions m_Wrapper;

		public InputAction App => m_Wrapper.m_LeftController_App;

		public InputAction JoystickClick => m_Wrapper.m_LeftController_JoystickClick;

		public InputAction BY => m_Wrapper.m_LeftController_BY;

		public InputAction AX => m_Wrapper.m_LeftController_AX;

		public InputAction Grip => m_Wrapper.m_LeftController_Grip;

		public InputAction Trigger => m_Wrapper.m_LeftController_Trigger;

		public bool enabled => Get().enabled;

		public LeftControllerActions(ControllerSampleInputActions wrapper)
		{
			m_Wrapper = wrapper;
		}

		public InputActionMap Get()
		{
			return m_Wrapper.m_LeftController;
		}

		public void Enable()
		{
			Get().Enable();
		}

		public void Disable()
		{
			Get().Disable();
		}

		public static implicit operator InputActionMap(LeftControllerActions set)
		{
			return set.Get();
		}

		public void SetCallbacks(ILeftControllerActions instance)
		{
			if (m_Wrapper.m_LeftControllerActionsCallbackInterface != null)
			{
				App.started -= m_Wrapper.m_LeftControllerActionsCallbackInterface.OnApp;
				App.performed -= m_Wrapper.m_LeftControllerActionsCallbackInterface.OnApp;
				App.canceled -= m_Wrapper.m_LeftControllerActionsCallbackInterface.OnApp;
				JoystickClick.started -= m_Wrapper.m_LeftControllerActionsCallbackInterface.OnJoystickClick;
				JoystickClick.performed -= m_Wrapper.m_LeftControllerActionsCallbackInterface.OnJoystickClick;
				JoystickClick.canceled -= m_Wrapper.m_LeftControllerActionsCallbackInterface.OnJoystickClick;
				BY.started -= m_Wrapper.m_LeftControllerActionsCallbackInterface.OnBY;
				BY.performed -= m_Wrapper.m_LeftControllerActionsCallbackInterface.OnBY;
				BY.canceled -= m_Wrapper.m_LeftControllerActionsCallbackInterface.OnBY;
				AX.started -= m_Wrapper.m_LeftControllerActionsCallbackInterface.OnAX;
				AX.performed -= m_Wrapper.m_LeftControllerActionsCallbackInterface.OnAX;
				AX.canceled -= m_Wrapper.m_LeftControllerActionsCallbackInterface.OnAX;
				Grip.started -= m_Wrapper.m_LeftControllerActionsCallbackInterface.OnGrip;
				Grip.performed -= m_Wrapper.m_LeftControllerActionsCallbackInterface.OnGrip;
				Grip.canceled -= m_Wrapper.m_LeftControllerActionsCallbackInterface.OnGrip;
				Trigger.started -= m_Wrapper.m_LeftControllerActionsCallbackInterface.OnTrigger;
				Trigger.performed -= m_Wrapper.m_LeftControllerActionsCallbackInterface.OnTrigger;
				Trigger.canceled -= m_Wrapper.m_LeftControllerActionsCallbackInterface.OnTrigger;
			}
			m_Wrapper.m_LeftControllerActionsCallbackInterface = instance;
			if (instance != null)
			{
				App.started += instance.OnApp;
				App.performed += instance.OnApp;
				App.canceled += instance.OnApp;
				JoystickClick.started += instance.OnJoystickClick;
				JoystickClick.performed += instance.OnJoystickClick;
				JoystickClick.canceled += instance.OnJoystickClick;
				BY.started += instance.OnBY;
				BY.performed += instance.OnBY;
				BY.canceled += instance.OnBY;
				AX.started += instance.OnAX;
				AX.performed += instance.OnAX;
				AX.canceled += instance.OnAX;
				Grip.started += instance.OnGrip;
				Grip.performed += instance.OnGrip;
				Grip.canceled += instance.OnGrip;
				Trigger.started += instance.OnTrigger;
				Trigger.performed += instance.OnTrigger;
				Trigger.canceled += instance.OnTrigger;
			}
		}
	}

	public interface IRightControllerActions
	{
		void OnTrigger(InputAction.CallbackContext context);

		void OnGrip(InputAction.CallbackContext context);

		void OnAX(InputAction.CallbackContext context);

		void OnBY(InputAction.CallbackContext context);

		void OnJoystickClick(InputAction.CallbackContext context);

		void OnApp(InputAction.CallbackContext context);
	}

	public interface ILeftControllerActions
	{
		void OnApp(InputAction.CallbackContext context);

		void OnJoystickClick(InputAction.CallbackContext context);

		void OnBY(InputAction.CallbackContext context);

		void OnAX(InputAction.CallbackContext context);

		void OnGrip(InputAction.CallbackContext context);

		void OnTrigger(InputAction.CallbackContext context);
	}

	private readonly InputActionMap m_RightController;

	private IRightControllerActions m_RightControllerActionsCallbackInterface;

	private readonly InputAction m_RightController_Trigger;

	private readonly InputAction m_RightController_Grip;

	private readonly InputAction m_RightController_AX;

	private readonly InputAction m_RightController_BY;

	private readonly InputAction m_RightController_JoystickClick;

	private readonly InputAction m_RightController_App;

	private readonly InputActionMap m_LeftController;

	private ILeftControllerActions m_LeftControllerActionsCallbackInterface;

	private readonly InputAction m_LeftController_App;

	private readonly InputAction m_LeftController_JoystickClick;

	private readonly InputAction m_LeftController_BY;

	private readonly InputAction m_LeftController_AX;

	private readonly InputAction m_LeftController_Grip;

	private readonly InputAction m_LeftController_Trigger;

	public InputActionAsset asset { get; }

	public InputBinding? bindingMask
	{
		get
		{
			return asset.bindingMask;
		}
		set
		{
			asset.bindingMask = value;
		}
	}

	public ReadOnlyArray<UnityEngine.InputSystem.InputDevice>? devices
	{
		get
		{
			return asset.devices;
		}
		set
		{
			asset.devices = value;
		}
	}

	public ReadOnlyArray<InputControlScheme> controlSchemes => asset.controlSchemes;

	public IEnumerable<InputBinding> bindings => asset.bindings;

	public RightControllerActions RightController => new RightControllerActions(this);

	public LeftControllerActions LeftController => new LeftControllerActions(this);

	public ControllerSampleInputActions()
	{
		asset = InputActionAsset.FromJson("{\n    \"name\": \"ControllerSampleInputActions\",\n    \"maps\": [\n        {\n            \"name\": \"RightController\",\n            \"id\": \"0d83ca55-7ddb-4dc8-a1b8-b667fb447ea3\",\n            \"actions\": [\n                {\n                    \"name\": \"Trigger\",\n                    \"type\": \"Button\",\n                    \"id\": \"a40102d7-3f0a-47cb-9fe7-9c10882984e3\",\n                    \"expectedControlType\": \"Button\",\n                    \"processors\": \"\",\n                    \"interactions\": \"\",\n                    \"initialStateCheck\": false\n                },\n                {\n                    \"name\": \"Grip\",\n                    \"type\": \"Button\",\n                    \"id\": \"0dfd212d-78dc-47a1-8076-e1bbc99cf1e7\",\n                    \"expectedControlType\": \"Button\",\n                    \"processors\": \"\",\n                    \"interactions\": \"\",\n                    \"initialStateCheck\": false\n                },\n                {\n                    \"name\": \"AX\",\n                    \"type\": \"Button\",\n                    \"id\": \"9192d49a-08f2-4086-aa31-c8230a65be5a\",\n                    \"expectedControlType\": \"Button\",\n                    \"processors\": \"\",\n                    \"interactions\": \"\",\n                    \"initialStateCheck\": false\n                },\n                {\n                    \"name\": \"BY\",\n                    \"type\": \"Button\",\n                    \"id\": \"1be3ff26-46c8-4299-b7a6-26a015689012\",\n                    \"expectedControlType\": \"Button\",\n                    \"processors\": \"\",\n                    \"interactions\": \"\",\n                    \"initialStateCheck\": false\n                },\n                {\n                    \"name\": \"JoystickClick\",\n                    \"type\": \"Button\",\n                    \"id\": \"2414c9f0-e4ea-437e-94a1-3a0be22a56ee\",\n                    \"expectedControlType\": \"Button\",\n                    \"processors\": \"\",\n                    \"interactions\": \"\",\n                    \"initialStateCheck\": false\n                },\n                {\n                    \"name\": \"App\",\n                    \"type\": \"Button\",\n                    \"id\": \"c5ced84e-b4d9-4190-89f0-408c5a93a933\",\n                    \"expectedControlType\": \"Button\",\n                    \"processors\": \"\",\n                    \"interactions\": \"\",\n                    \"initialStateCheck\": false\n                }\n            ],\n            \"bindings\": [\n                {\n                    \"name\": \"\",\n                    \"id\": \"69bb2a1a-94c9-4323-ad9d-ec657812e9de\",\n                    \"path\": \"<XRController>{RightHand}/triggerPressed\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"\",\n                    \"action\": \"Trigger\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"\",\n                    \"id\": \"4540ab38-57a0-4c0e-ba6b-f7aa30ec821d\",\n                    \"path\": \"<XRController>{RightHand}/gripPressed\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"\",\n                    \"action\": \"Grip\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"\",\n                    \"id\": \"a334860b-4314-42e4-9770-71967f743acb\",\n                    \"path\": \"<XRController>{RightHand}/primaryButton\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"\",\n                    \"action\": \"AX\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"\",\n                    \"id\": \"55d2fdbb-70a4-4baf-98d6-8270b0acad06\",\n                    \"path\": \"<XRController>{RightHand}/secondaryButton\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"\",\n                    \"action\": \"BY\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"\",\n                    \"id\": \"99ee062a-e63a-40c2-91a4-7351838505b3\",\n                    \"path\": \"<XRController>{RightHand}/primary2DAxisClick\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"\",\n                    \"action\": \"JoystickClick\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"\",\n                    \"id\": \"8980c5de-9c7a-4ba0-84e0-4a126cec0c3f\",\n                    \"path\": \"<XRController>{RightHand}/menu\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"\",\n                    \"action\": \"App\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                }\n            ]\n        },\n        {\n            \"name\": \"LeftController\",\n            \"id\": \"722cc55d-eb5d-46bb-a018-e7301750dc57\",\n            \"actions\": [\n                {\n                    \"name\": \"App\",\n                    \"type\": \"Button\",\n                    \"id\": \"a03b2790-280e-4768-b30a-a9b9f9899b2f\",\n                    \"expectedControlType\": \"Button\",\n                    \"processors\": \"\",\n                    \"interactions\": \"\",\n                    \"initialStateCheck\": false\n                },\n                {\n                    \"name\": \"JoystickClick\",\n                    \"type\": \"Button\",\n                    \"id\": \"ce5b5d4e-9094-4d2c-b9f9-53b13f10fbce\",\n                    \"expectedControlType\": \"Button\",\n                    \"processors\": \"\",\n                    \"interactions\": \"\",\n                    \"initialStateCheck\": false\n                },\n                {\n                    \"name\": \"BY\",\n                    \"type\": \"Button\",\n                    \"id\": \"22b17e08-2dbc-46dc-8fd8-ff6b5c967c62\",\n                    \"expectedControlType\": \"Button\",\n                    \"processors\": \"\",\n                    \"interactions\": \"\",\n                    \"initialStateCheck\": false\n                },\n                {\n                    \"name\": \"AX\",\n                    \"type\": \"Button\",\n                    \"id\": \"5676308a-6cfd-478c-9430-c6bdd0ba0c75\",\n                    \"expectedControlType\": \"Button\",\n                    \"processors\": \"\",\n                    \"interactions\": \"\",\n                    \"initialStateCheck\": false\n                },\n                {\n                    \"name\": \"Grip\",\n                    \"type\": \"Button\",\n                    \"id\": \"9272183f-8416-4f2a-bc4b-bca4608b4cdb\",\n                    \"expectedControlType\": \"Button\",\n                    \"processors\": \"\",\n                    \"interactions\": \"\",\n                    \"initialStateCheck\": false\n                },\n                {\n                    \"name\": \"Trigger\",\n                    \"type\": \"Button\",\n                    \"id\": \"20968439-2ee3-428a-bc43-a256654774b2\",\n                    \"expectedControlType\": \"Button\",\n                    \"processors\": \"\",\n                    \"interactions\": \"\",\n                    \"initialStateCheck\": false\n                }\n            ],\n            \"bindings\": [\n                {\n                    \"name\": \"\",\n                    \"id\": \"b345fe39-d349-4f4e-89a3-31029b6c8383\",\n                    \"path\": \"<XRController>{LeftHand}/triggerPressed\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"\",\n                    \"action\": \"Trigger\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"\",\n                    \"id\": \"d13f8b92-a9c9-49cd-8f80-2baecc6d6e71\",\n                    \"path\": \"<XRController>{LeftHand}/gripPressed\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"\",\n                    \"action\": \"Grip\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"\",\n                    \"id\": \"69964ebd-d78e-4525-aa5e-34755f5ee1b3\",\n                    \"path\": \"<XRController>{LeftHand}/primaryButton\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"\",\n                    \"action\": \"AX\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"\",\n                    \"id\": \"50d6b296-7faf-48e5-952b-57e28c3658f8\",\n                    \"path\": \"<XRController>{LeftHand}/secondaryButton\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"\",\n                    \"action\": \"BY\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"\",\n                    \"id\": \"67eaceaf-16ce-40f6-af33-ee2d19868d2a\",\n                    \"path\": \"<XRController>{LeftHand}/primary2DAxisClick\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"\",\n                    \"action\": \"JoystickClick\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"\",\n                    \"id\": \"0e449a72-85e1-4a80-a9ae-bac6e99e29f0\",\n                    \"path\": \"<XRController>{LeftHand}/menu\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"\",\n                    \"action\": \"App\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                }\n            ]\n        }\n    ],\n    \"controlSchemes\": []\n}");
		m_RightController = asset.FindActionMap("RightController", throwIfNotFound: true);
		m_RightController_Trigger = m_RightController.FindAction("Trigger", throwIfNotFound: true);
		m_RightController_Grip = m_RightController.FindAction("Grip", throwIfNotFound: true);
		m_RightController_AX = m_RightController.FindAction("AX", throwIfNotFound: true);
		m_RightController_BY = m_RightController.FindAction("BY", throwIfNotFound: true);
		m_RightController_JoystickClick = m_RightController.FindAction("JoystickClick", throwIfNotFound: true);
		m_RightController_App = m_RightController.FindAction("App", throwIfNotFound: true);
		m_LeftController = asset.FindActionMap("LeftController", throwIfNotFound: true);
		m_LeftController_App = m_LeftController.FindAction("App", throwIfNotFound: true);
		m_LeftController_JoystickClick = m_LeftController.FindAction("JoystickClick", throwIfNotFound: true);
		m_LeftController_BY = m_LeftController.FindAction("BY", throwIfNotFound: true);
		m_LeftController_AX = m_LeftController.FindAction("AX", throwIfNotFound: true);
		m_LeftController_Grip = m_LeftController.FindAction("Grip", throwIfNotFound: true);
		m_LeftController_Trigger = m_LeftController.FindAction("Trigger", throwIfNotFound: true);
	}

	public void Dispose()
	{
		UnityEngine.Object.Destroy(asset);
	}

	public bool Contains(InputAction action)
	{
		return asset.Contains(action);
	}

	public IEnumerator<InputAction> GetEnumerator()
	{
		return asset.GetEnumerator();
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return GetEnumerator();
	}

	public void Enable()
	{
		asset.Enable();
	}

	public void Disable()
	{
		asset.Disable();
	}

	public InputAction FindAction(string actionNameOrId, bool throwIfNotFound = false)
	{
		return asset.FindAction(actionNameOrId, throwIfNotFound);
	}

	public int FindBinding(InputBinding bindingMask, out InputAction action)
	{
		return asset.FindBinding(bindingMask, out action);
	}
}
public class ControllerUITest : MonoBehaviour
{
	public ScrollRect leftLogScrollRect;

	public ScrollRect rightLogScrollRect;

	private Text leftLogInfo;

	private Text rightLogInfo;

	private ControllerSampleInputActions 私想;

	private void Awake()
	{
		leftLogInfo = leftLogScrollRect.content.GetComponent<Text>();
		rightLogInfo = rightLogScrollRect.content.GetComponent<Text>();
		私想 = new ControllerSampleInputActions();
	}

	public void 公讲(string 串参, bool 为佐参)
	{
		if (为佐参)
		{
			string text;
			switch (串参)
			{
			case "左次键击":
				text = "升\r\n";
				类走.逮.取垂直移动方向("升");
				break;
			case "左主键击":
				text = "降\r\n";
				类走.逮.取垂直移动方向("降");
				break;
			case "左菜击":
				text = "虚\r\n";
				佐.逮.虚();
				佐.逮.墙隐();
				break;
			case "左摇击":
				text = "悬\r\n";
				类走.逮.取垂直移动方向();
				break;
			case "左 Trigger 下":
			case "左扳上":
			case "左抓上":
			case "左 Grip 下":
				text = "";
				break;
			default:
				text = 串参 + "\r\n";
				break;
			}
			leftLogInfo.text += text;
		}
		else
		{
			switch (串参)
			{
			case "右 Trigger 下":
				if (佑.逮.公为喷)
				{
					string text = "喷()\r\n";
					佐.逮.脑喷();
				}
				break;
			case "右扳上":
			{
				string text = 佐.逮.公态 + 佐.逮.造啥 + "\r\n";
				break;
			}
			case "右抓上":
			{
				string text = "";
				break;
			}
			case "右主键击":
			{
				string text = "";
				佐.逮.深减();
				break;
			}
			case "右次键击":
			{
				string text = "";
				佐.逮.深加();
				break;
			}
			default:
			{
				string text = 串参 + "\r\n";
				rightLogInfo.text += text;
				break;
			}
			}
		}
		Canvas.ForceUpdateCanvases();
		leftLogScrollRect.verticalNormalizedPosition = 0f;
		rightLogScrollRect.verticalNormalizedPosition = 0f;
	}

	private void OnEnable()
	{
		私想.RightController.AX.Enable();
		私想.RightController.AX.performed += delegate
		{
			公讲("右主键击", 为佐参: false);
		};
		私想.RightController.BY.Enable();
		私想.RightController.BY.performed += delegate
		{
			公讲("右次键击", 为佐参: false);
		};
		私想.RightController.App.Enable();
		私想.RightController.App.started += delegate
		{
			公讲("右菜击", 为佐参: false);
		};
		私想.RightController.JoystickClick.Enable();
		私想.RightController.JoystickClick.started += delegate
		{
			公讲("杆击", 为佐参: false);
		};
		私想.LeftController.AX.Enable();
		私想.LeftController.AX.performed += delegate
		{
			公讲("左主键击", 为佐参: true);
		};
		私想.LeftController.BY.Enable();
		私想.LeftController.BY.performed += delegate
		{
			公讲("左次键击", 为佐参: true);
		};
		私想.LeftController.App.Enable();
		私想.LeftController.App.performed += delegate
		{
			公讲("左菜击", 为佐参: true);
		};
		私想.LeftController.JoystickClick.Enable();
		私想.LeftController.JoystickClick.performed += delegate
		{
			公讲("左摇击", 为佐参: true);
		};
	}
}
public class ShakeController : MonoBehaviour
{
	public float lowStrength = 0.3f;

	public float highStrength = 1f;

	public int shakeTime = 1000;

	private ControllerSampleInputActions 手柄;

	private ControllerUITest 佐佑;

	private void Awake()
	{
		佐佑 = UnityEngine.Object.FindObjectOfType<ControllerUITest>();
		手柄 = new ControllerSampleInputActions();
	}

	private void OnEnable()
	{
		手柄.RightController.AX.Enable();
		手柄.RightController.AX.performed += RightAXButtonClickHandler;
		手柄.RightController.BY.Enable();
		手柄.RightController.BY.performed += RightBYButtonClickHandler;
		手柄.RightController.Trigger.Enable();
		手柄.RightController.Trigger.performed += RightTriggerDownHandler;
		手柄.RightController.Trigger.canceled += RightTriggerUpHandler;
		手柄.RightController.Grip.Enable();
		手柄.RightController.Grip.performed += RightGripDownHandler;
		手柄.RightController.Grip.canceled += RightGripUpHandler;
		手柄.LeftController.AX.Enable();
		手柄.LeftController.AX.performed += LeftAXButtonClickHandler;
		手柄.LeftController.BY.Enable();
		手柄.LeftController.BY.performed += LeftBYButtonClickHandler;
		手柄.LeftController.Grip.Enable();
		手柄.LeftController.Grip.performed += LeftGripDownHandler;
		手柄.LeftController.Grip.canceled += LeftGripUpHandler;
		手柄.LeftController.Trigger.Enable();
		手柄.LeftController.Trigger.performed += LeftTriggerDownHandler;
		手柄.LeftController.Trigger.canceled += LeftTriggerUpHandler;
	}

	private void OnDisable()
	{
		手柄.RightController.AX.Disable();
		手柄.RightController.AX.performed -= RightAXButtonClickHandler;
		手柄.RightController.BY.Disable();
		手柄.RightController.BY.performed -= RightBYButtonClickHandler;
		手柄.RightController.Trigger.Disable();
		手柄.RightController.Trigger.performed -= RightTriggerDownHandler;
		手柄.RightController.Trigger.canceled -= RightTriggerUpHandler;
		手柄.RightController.Grip.Disable();
		手柄.RightController.Grip.performed -= RightGripDownHandler;
		手柄.RightController.Grip.canceled -= RightGripUpHandler;
		手柄.LeftController.AX.Disable();
		手柄.LeftController.AX.performed -= LeftAXButtonClickHandler;
		手柄.LeftController.BY.Disable();
		手柄.LeftController.BY.performed -= LeftBYButtonClickHandler;
		手柄.LeftController.Grip.Disable();
		手柄.LeftController.Grip.performed -= LeftGripDownHandler;
		手柄.LeftController.Grip.canceled -= LeftGripUpHandler;
		手柄.LeftController.Trigger.Disable();
		手柄.LeftController.Trigger.performed -= LeftTriggerDownHandler;
		手柄.LeftController.Trigger.canceled -= LeftTriggerUpHandler;
	}

	private void LeftTriggerDownHandler(InputAction.CallbackContext callbackContext)
	{
		手柄.LeftController.Trigger.performed -= LeftTriggerDownHandler;
	}

	private void LeftTriggerUpHandler(InputAction.CallbackContext callbackContext)
	{
		佐佑.公讲("左扳上", 为佐参: true);
	}

	private void LeftGripUpHandler(InputAction.CallbackContext callbackContext)
	{
		佐佑.公讲("左抓上", 为佐参: true);
	}

	private void LeftGripDownHandler(InputAction.CallbackContext callbackContext)
	{
	}

	private void LeftBYButtonClickHandler(InputAction.CallbackContext callbackContext)
	{
	}

	private void LeftAXButtonClickHandler(InputAction.CallbackContext callbackContext)
	{
	}

	private void RightTriggerUpHandler(InputAction.CallbackContext callbackContext)
	{
		佐佑.公讲("右扳上", 为佐参: false);
		StopCoroutine("RightControllerShake");
	}

	private void RightTriggerDownHandler(InputAction.CallbackContext callbackContext)
	{
		StartCoroutine("RightControllerShake", "Trigger");
	}

	private IEnumerator RightControllerShake(string str)
	{
		while (true)
		{
			if (!(str == "Trigger"))
			{
				_ = lowStrength;
			}
			else
			{
				_ = highStrength;
			}
			佐佑.公讲("右 " + str + " 下", 为佐参: false);
			yield return new WaitForSeconds((float)shakeTime * 0.001f);
		}
	}

	private IEnumerator LeftControllerShake(string str)
	{
		while (true)
		{
			if (!(str == "Trigger"))
			{
				_ = lowStrength;
			}
			else
			{
				_ = highStrength;
			}
			佐佑.公讲("左 " + str + " 下", 为佐参: true);
			yield return new WaitForSeconds((float)shakeTime * 0.001f);
		}
	}

	private void RightGripUpHandler(InputAction.CallbackContext callbackContext)
	{
		佐佑.公讲("右抓上", 为佐参: false);
		StopCoroutine("RightControllerShake");
	}

	private void RightGripDownHandler(InputAction.CallbackContext callbackContext)
	{
	}

	private void RightBYButtonClickHandler(InputAction.CallbackContext callbackContext)
	{
	}

	private void RightAXButtonClickHandler(InputAction.CallbackContext callbackContext)
	{
	}
}
public class MultiLayerTouch : MonoBehaviour
{
	public Text label;

	public Text label2;

	private void OnEnable()
	{
		EasyTouch.On_TouchDown += On_TouchDown;
		EasyTouch.On_TouchUp += On_TouchUp;
	}

	private void OnDestroy()
	{
		EasyTouch.On_TouchDown -= On_TouchDown;
		EasyTouch.On_TouchUp -= On_TouchUp;
	}

	private void On_TouchDown(Gesture gesture)
	{
		if (gesture.pickedObject != null)
		{
			if (!EasyTouch.GetAutoUpdatePickedObject())
			{
				Text text = label;
				string text2 = gesture.pickedObject.name;
				Vector2 position = gesture.position;
				text.text = "Picked object from event : " + text2 + " : " + position.ToString();
			}
			else
			{
				Text text3 = label;
				string text4 = gesture.pickedObject.name;
				Vector2 position = gesture.position;
				text3.text = "Picked object from event : " + text4 + " : " + position.ToString();
			}
		}
		else if (!EasyTouch.GetAutoUpdatePickedObject())
		{
			label.text = "Picked object from event :  none";
		}
		else
		{
			label.text = "Picked object from event : none";
		}
		label2.text = "";
		if (!EasyTouch.GetAutoUpdatePickedObject())
		{
			GameObject currentPickedObject = gesture.GetCurrentPickedObject();
			if (currentPickedObject != null)
			{
				label2.text = "Picked object from GetCurrentPickedObject : " + currentPickedObject.name;
			}
			else
			{
				label2.text = "Picked object from GetCurrentPickedObject : none";
			}
		}
	}

	private void On_TouchUp(Gesture gesture)
	{
		label.text = "";
		label2.text = "";
	}
}
public class MultiLayerUI : MonoBehaviour
{
	public void SetAutoSelect(bool value)
	{
		EasyTouch.SetEnableAutoSelect(value);
	}

	public void SetAutoUpdate(bool value)
	{
		EasyTouch.SetAutoUpdatePickedObject(value);
	}

	public void Layer1(bool value)
	{
		LayerMask layerMask = EasyTouch.Get3DPickableLayer();
		if (value)
		{
			layerMask = (int)layerMask | 0x100;
		}
		else
		{
			layerMask = ~(int)layerMask;
			layerMask = ~((int)layerMask | 0x100);
		}
		EasyTouch.Set3DPickableLayer(layerMask);
	}

	public void Layer2(bool value)
	{
		LayerMask layerMask = EasyTouch.Get3DPickableLayer();
		if (value)
		{
			layerMask = (int)layerMask | 0x200;
		}
		else
		{
			layerMask = ~(int)layerMask;
			layerMask = ~((int)layerMask | 0x200);
		}
		EasyTouch.Set3DPickableLayer(layerMask);
	}

	public void Layer3(bool value)
	{
		LayerMask layerMask = EasyTouch.Get3DPickableLayer();
		if (value)
		{
			layerMask = (int)layerMask | 0x400;
		}
		else
		{
			layerMask = ~(int)layerMask;
			layerMask = ~((int)layerMask | 0x400);
		}
		EasyTouch.Set3DPickableLayer(layerMask);
	}
}
public class MultiCameraTouch : MonoBehaviour
{
	public Text label;

	private void OnEnable()
	{
		EasyTouch.On_TouchDown += On_TouchDown;
		EasyTouch.On_TouchUp += On_TouchUp;
	}

	private void OnDestroy()
	{
		EasyTouch.On_TouchDown -= On_TouchDown;
		EasyTouch.On_TouchUp -= On_TouchUp;
	}

	private void On_TouchDown(Gesture gesture)
	{
		if (gesture.pickedObject != null)
		{
			label.text = "You touch : " + gesture.pickedObject.name + " on camera : " + gesture.pickedCamera.name;
		}
	}

	private void On_TouchUp(Gesture gesture)
	{
		label.text = "";
	}
}
public class MultiCameraUI : MonoBehaviour
{
	public Camera cam2;

	public Camera cam3;

	public void AddCamera2(bool value)
	{
		AddCamera(cam2, value);
	}

	public void AddCamera3(bool value)
	{
		AddCamera(cam3, value);
	}

	public void AddCamera(Camera cam, bool value)
	{
		if (value)
		{
			EasyTouch.AddCamera(cam);
		}
		else
		{
			EasyTouch.RemoveCamera(cam);
		}
	}
}
public class CubeSelect : MonoBehaviour
{
	private GameObject cube;

	private void OnEnable()
	{
		EasyTouch.On_SimpleTap += On_SimpleTap;
	}

	private void OnDestroy()
	{
		EasyTouch.On_SimpleTap -= On_SimpleTap;
	}

	private void Start()
	{
		cube = null;
	}

	private void On_SimpleTap(Gesture gesture)
	{
		if (gesture.pickedObject != null && gesture.pickedObject.name == "Cube")
		{
			ResteColor();
			cube = gesture.pickedObject;
			cube.GetComponent<Renderer>().material.color = Color.red;
		}
	}

	private void ResteColor()
	{
		if (cube != null)
		{
			cube.GetComponent<Renderer>().material.color = new Color(0.23529412f, 0.56078434f, 67f / 85f);
		}
	}
}
public class RTSCamera : MonoBehaviour
{
	private Vector3 delta;

	private void OnEnable()
	{
		EasyTouch.On_Swipe += On_Swipe;
		EasyTouch.On_Drag += On_Drag;
		EasyTouch.On_Twist += On_Twist;
		EasyTouch.On_Pinch += On_Pinch;
	}

	private void On_Twist(Gesture gesture)
	{
		base.transform.Rotate(Vector3.up * gesture.twistAngle);
	}

	private void OnDestroy()
	{
		EasyTouch.On_Swipe -= On_Swipe;
		EasyTouch.On_Drag -= On_Drag;
		EasyTouch.On_Twist -= On_Twist;
	}

	private void On_Drag(Gesture gesture)
	{
		On_Swipe(gesture);
	}

	private void On_Swipe(Gesture gesture)
	{
		base.transform.Translate(Vector3.left * gesture.deltaPosition.x / UnityEngine.Screen.width);
		base.transform.Translate(Vector3.back * gesture.deltaPosition.y / UnityEngine.Screen.height);
	}

	private void On_Pinch(Gesture gesture)
	{
		Camera.main.fieldOfView += gesture.deltaPinch * Time.deltaTime;
	}
}
public class Ball : MonoBehaviour
{
}
public class BallRunPlayer : MonoBehaviour
{
	public Transform ballModel;

	private bool start;

	private Vector3 moveDirection;

	private CharacterController characterController;

	private Vector3 startPosition;

	private bool isJump;

	private void OnEnable()
	{
		EasyTouch.On_SwipeEnd += On_SwipeEnd;
	}

	private void OnDestroy()
	{
		EasyTouch.On_SwipeEnd -= On_SwipeEnd;
	}

	private void Start()
	{
		characterController = GetComponent<CharacterController>();
		startPosition = base.transform.position;
	}

	private void Update()
	{
		if (start)
		{
			moveDirection = base.transform.TransformDirection(Vector3.forward) * 10f * Time.deltaTime;
			moveDirection.y -= 9.81f * Time.deltaTime;
			if (isJump)
			{
				moveDirection.y = 8f;
				isJump = false;
			}
			characterController.Move(moveDirection);
			ballModel.Rotate(Vector3.right * 400f * Time.deltaTime);
		}
		if ((double)base.transform.position.y < 0.5)
		{
			start = false;
			base.transform.position = startPosition;
		}
	}

	private void OnCollision()
	{
		UnityEngine.Debug.Log("ok");
	}

	private void On_SwipeEnd(Gesture gesture)
	{
		if (!start)
		{
			return;
		}
		switch (gesture.swipe)
		{
		case EasyTouch.SwipeDirection.Left:
		case EasyTouch.SwipeDirection.UpLeft:
		case EasyTouch.SwipeDirection.DownLeft:
			base.transform.Rotate(Vector3.up * -90f);
			break;
		case EasyTouch.SwipeDirection.Right:
		case EasyTouch.SwipeDirection.UpRight:
		case EasyTouch.SwipeDirection.DownRight:
			base.transform.Rotate(Vector3.up * 90f);
			break;
		case EasyTouch.SwipeDirection.Up:
			if (characterController.isGrounded)
			{
				isJump = true;
			}
			break;
		case EasyTouch.SwipeDirection.Down:
			break;
		}
	}

	public void StartGame()
	{
		start = true;
	}
}
public class ThirdPersonCamera : MonoBehaviour
{
	public float distanceAway;

	public float distanceUp;

	public float smooth;

	private GameObject hovercraft;

	private Vector3 targetPosition;

	private Transform follow;

	private void Start()
	{
		follow = GameObject.FindWithTag("Player").transform;
	}

	private void LateUpdate()
	{
		targetPosition = follow.position + Vector3.up * distanceUp - follow.forward * distanceAway;
		base.transform.position = Vector3.Lerp(base.transform.position, targetPosition, Time.deltaTime * smooth);
		base.transform.LookAt(follow);
	}
}
public class LoadExamples : MonoBehaviour
{
	public void LoadExample(string level)
	{
		UnityEngine.Application.LoadLevel(level);
	}
}
public class FingerTouch : MonoBehaviour
{
	private TextMesh textMesh;

	public Vector3 deltaPosition = Vector2.zero;

	public int fingerId = -1;

	private void OnEnable()
	{
		EasyTouch.On_TouchStart += On_TouchStart;
		EasyTouch.On_TouchUp += On_TouchUp;
		EasyTouch.On_Swipe += On_Swipe;
		EasyTouch.On_Drag += On_Drag;
		EasyTouch.On_DoubleTap += On_DoubleTap;
		textMesh = GetComponentInChildren<TextMesh>();
	}

	private void OnDestroy()
	{
		EasyTouch.On_TouchStart -= On_TouchStart;
		EasyTouch.On_TouchUp -= On_TouchUp;
		EasyTouch.On_Swipe -= On_Swipe;
		EasyTouch.On_Drag -= On_Drag;
		EasyTouch.On_DoubleTap -= On_DoubleTap;
	}

	private void On_Drag(Gesture gesture)
	{
		if (gesture.pickedObject.transform.IsChildOf(base.gameObject.transform) && fingerId == gesture.fingerIndex)
		{
			Vector3 touchToWorldPoint = gesture.GetTouchToWorldPoint(gesture.pickedObject.transform.position);
			base.transform.position = touchToWorldPoint - deltaPosition;
		}
	}

	private void On_Swipe(Gesture gesture)
	{
		if (fingerId == gesture.fingerIndex)
		{
			Vector3 touchToWorldPoint = gesture.GetTouchToWorldPoint(base.transform.position);
			base.transform.position = touchToWorldPoint - deltaPosition;
		}
	}

	private void On_TouchStart(Gesture gesture)
	{
		if (gesture.pickedObject != null && gesture.pickedObject.transform.IsChildOf(base.gameObject.transform))
		{
			fingerId = gesture.fingerIndex;
			textMesh.text = fingerId.ToString();
			Vector3 touchToWorldPoint = gesture.GetTouchToWorldPoint(gesture.pickedObject.transform.position);
			deltaPosition = touchToWorldPoint - base.transform.position;
		}
	}

	private void On_TouchUp(Gesture gesture)
	{
		if (gesture.fingerIndex == fingerId)
		{
			fingerId = -1;
			textMesh.text = "";
		}
	}

	public void InitTouch(int ind)
	{
		fingerId = ind;
		textMesh.text = fingerId.ToString();
	}

	private void On_DoubleTap(Gesture gesture)
	{
		if (gesture.pickedObject != null && gesture.pickedObject.transform.IsChildOf(base.gameObject.transform))
		{
			UnityEngine.Object.DestroyImmediate(base.transform.gameObject);
		}
	}
}
public class MutliFingersScreenTouch : MonoBehaviour
{
	public GameObject touchGameObject;

	private void OnEnable()
	{
		EasyTouch.On_TouchStart += On_TouchStart;
	}

	private void OnDestroy()
	{
		EasyTouch.On_TouchStart -= On_TouchStart;
	}

	private void On_TouchStart(Gesture gesture)
	{
		if (gesture.pickedObject == null)
		{
			Vector3 touchToWorldPoint = gesture.GetTouchToWorldPoint(5f);
			UnityEngine.Object.Instantiate(touchGameObject, touchToWorldPoint, Quaternion.identity).GetComponent<FingerTouch>().InitTouch(gesture.fingerIndex);
		}
	}
}
public class DoubleTapMe : MonoBehaviour
{
	private void OnEnable()
	{
		EasyTouch.On_DoubleTap += On_DoubleTap;
	}

	private void OnDisable()
	{
		UnsubscribeEvent();
	}

	private void OnDestroy()
	{
		UnsubscribeEvent();
	}

	private void UnsubscribeEvent()
	{
		EasyTouch.On_DoubleTap -= On_DoubleTap;
	}

	private void On_DoubleTap(Gesture gesture)
	{
		if (gesture.pickedObject == base.gameObject)
		{
			base.gameObject.GetComponent<Renderer>().material.color = new Color(UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f));
		}
	}
}
public class DragMe : MonoBehaviour
{
	private TextMesh textMesh;

	private Color startColor;

	private Vector3 deltaPosition;

	private int fingerIndex;

	private void OnEnable()
	{
		EasyTouch.On_Drag += On_Drag;
		EasyTouch.On_DragStart += On_DragStart;
		EasyTouch.On_DragEnd += On_DragEnd;
	}

	private void OnDisable()
	{
		UnsubscribeEvent();
	}

	private void OnDestroy()
	{
		UnsubscribeEvent();
	}

	private void UnsubscribeEvent()
	{
		EasyTouch.On_Drag -= On_Drag;
		EasyTouch.On_DragStart -= On_DragStart;
		EasyTouch.On_DragEnd -= On_DragEnd;
	}

	private void Start()
	{
		textMesh = GetComponentInChildren<TextMesh>();
		startColor = base.gameObject.GetComponent<Renderer>().material.color;
	}

	private void On_DragStart(Gesture gesture)
	{
		if (gesture.pickedObject == base.gameObject)
		{
			fingerIndex = gesture.fingerIndex;
			RandomColor();
			Vector3 touchToWorldPoint = gesture.GetTouchToWorldPoint(gesture.pickedObject.transform.position);
			deltaPosition = touchToWorldPoint - base.transform.position;
		}
	}

	private void On_Drag(Gesture gesture)
	{
		if (gesture.pickedObject == base.gameObject && fingerIndex == gesture.fingerIndex)
		{
			Vector3 touchToWorldPoint = gesture.GetTouchToWorldPoint(gesture.pickedObject.transform.position);
			base.transform.position = touchToWorldPoint - deltaPosition;
			float swipeOrDragAngle = gesture.GetSwipeOrDragAngle();
			textMesh.text = swipeOrDragAngle.ToString("f2") + " / " + gesture.swipe;
		}
	}

	private void On_DragEnd(Gesture gesture)
	{
		if (gesture.pickedObject == base.gameObject)
		{
			base.gameObject.GetComponent<Renderer>().material.color = startColor;
			textMesh.text = "Drag me";
		}
	}

	private void RandomColor()
	{
		base.gameObject.GetComponent<Renderer>().material.color = new Color(UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f));
	}
}
public class LongTapMe : MonoBehaviour
{
	private TextMesh textMesh;

	private Color startColor;

	private void OnEnable()
	{
		EasyTouch.On_LongTapStart += On_LongTapStart;
		EasyTouch.On_LongTap += On_LongTap;
		EasyTouch.On_LongTapEnd += On_LongTapEnd;
	}

	private void OnDisable()
	{
		UnsubscribeEvent();
	}

	private void OnDestroy()
	{
		UnsubscribeEvent();
	}

	private void UnsubscribeEvent()
	{
		EasyTouch.On_LongTapStart -= On_LongTapStart;
		EasyTouch.On_LongTap -= On_LongTap;
		EasyTouch.On_LongTapEnd -= On_LongTapEnd;
	}

	private void Start()
	{
		textMesh = GetComponentInChildren<TextMesh>();
		startColor = base.gameObject.GetComponent<Renderer>().material.color;
	}

	private void On_LongTapStart(Gesture gesture)
	{
		if (gesture.pickedObject == base.gameObject)
		{
			RandomColor();
		}
	}

	private void On_LongTap(Gesture gesture)
	{
		if (gesture.pickedObject == base.gameObject)
		{
			textMesh.text = gesture.actionTime.ToString("f2");
		}
	}

	private void On_LongTapEnd(Gesture gesture)
	{
		if (gesture.pickedObject == base.gameObject)
		{
			base.gameObject.GetComponent<Renderer>().material.color = startColor;
			textMesh.text = "Long tap me";
		}
	}

	private void RandomColor()
	{
		base.gameObject.GetComponent<Renderer>().material.color = new Color(UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f));
	}
}
public class Swipe : MonoBehaviour
{
	public GameObject trail;

	public Text swipeText;

	private void OnEnable()
	{
		EasyTouch.On_SwipeStart += On_SwipeStart;
		EasyTouch.On_Swipe += On_Swipe;
		EasyTouch.On_SwipeEnd += On_SwipeEnd;
	}

	private void OnDisable()
	{
		UnsubscribeEvent();
	}

	private void OnDestroy()
	{
		UnsubscribeEvent();
	}

	private void UnsubscribeEvent()
	{
		EasyTouch.On_SwipeStart -= On_SwipeStart;
		EasyTouch.On_Swipe -= On_Swipe;
		EasyTouch.On_SwipeEnd -= On_SwipeEnd;
	}

	private void On_SwipeStart(Gesture gesture)
	{
		swipeText.text = "You start a swipe";
	}

	private void On_Swipe(Gesture gesture)
	{
		Vector3 touchToWorldPoint = gesture.GetTouchToWorldPoint(5f);
		trail.transform.position = touchToWorldPoint;
	}

	private void On_SwipeEnd(Gesture gesture)
	{
		float swipeOrDragAngle = gesture.GetSwipeOrDragAngle();
		swipeText.text = "Last swipe : " + gesture.swipe.ToString() + " /  vector : " + gesture.swipeVector.normalized.ToString() + " / angle : " + swipeOrDragAngle.ToString("f2");
	}
}
public class TapMe : MonoBehaviour
{
	private void OnEnable()
	{
		EasyTouch.On_SimpleTap += On_SimpleTap;
	}

	private void OnDisable()
	{
		UnsubscribeEvent();
	}

	private void OnDestroy()
	{
		UnsubscribeEvent();
	}

	private void UnsubscribeEvent()
	{
		EasyTouch.On_SimpleTap -= On_SimpleTap;
	}

	private void On_SimpleTap(Gesture gesture)
	{
		if (gesture.pickedObject == base.gameObject)
		{
			base.gameObject.GetComponent<Renderer>().material.color = new Color(UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f));
		}
	}
}
public class TouchMe : MonoBehaviour
{
	private TextMesh textMesh;

	private Color startColor;

	private void OnEnable()
	{
		EasyTouch.On_TouchStart += On_TouchStart;
		EasyTouch.On_TouchDown += On_TouchDown;
		EasyTouch.On_TouchUp += On_TouchUp;
	}

	private void OnDisable()
	{
		UnsubscribeEvent();
	}

	private void OnDestroy()
	{
		UnsubscribeEvent();
	}

	private void UnsubscribeEvent()
	{
		EasyTouch.On_TouchStart -= On_TouchStart;
		EasyTouch.On_TouchDown -= On_TouchDown;
		EasyTouch.On_TouchUp -= On_TouchUp;
	}

	private void Start()
	{
		textMesh = GetComponentInChildren<TextMesh>();
		startColor = base.gameObject.GetComponent<Renderer>().material.color;
	}

	private void On_TouchStart(Gesture gesture)
	{
		if (gesture.pickedObject == base.gameObject)
		{
			RandomColor();
		}
	}

	private void On_TouchDown(Gesture gesture)
	{
		if (gesture.pickedObject == base.gameObject)
		{
			textMesh.text = "Down since :" + gesture.actionTime.ToString("f2");
		}
	}

	private void On_TouchUp(Gesture gesture)
	{
		if (gesture.pickedObject == base.gameObject)
		{
			base.gameObject.GetComponent<Renderer>().material.color = startColor;
			textMesh.text = "Touch me";
		}
	}

	private void RandomColor()
	{
		base.gameObject.GetComponent<Renderer>().material.color = new Color(UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f));
	}
}
public class PinchMe : MonoBehaviour
{
	private TextMesh textMesh;

	private void OnEnable()
	{
		EasyTouch.On_TouchStart2Fingers += On_TouchStart2Fingers;
		EasyTouch.On_PinchIn += On_PinchIn;
		EasyTouch.On_PinchOut += On_PinchOut;
		EasyTouch.On_PinchEnd += On_PinchEnd;
	}

	private void OnDisable()
	{
		UnsubscribeEvent();
	}

	private void OnDestroy()
	{
		UnsubscribeEvent();
	}

	private void UnsubscribeEvent()
	{
		EasyTouch.On_TouchStart2Fingers -= On_TouchStart2Fingers;
		EasyTouch.On_PinchIn -= On_PinchIn;
		EasyTouch.On_PinchOut -= On_PinchOut;
		EasyTouch.On_PinchEnd -= On_PinchEnd;
	}

	private void Start()
	{
		textMesh = GetComponentInChildren<TextMesh>();
	}

	private void On_TouchStart2Fingers(Gesture gesture)
	{
		if (gesture.pickedObject == base.gameObject)
		{
			EasyTouch.SetEnableTwist(enable: false);
			EasyTouch.SetEnablePinch(enable: true);
		}
	}

	private void On_PinchIn(Gesture gesture)
	{
		if (gesture.pickedObject == base.gameObject)
		{
			float num = Time.deltaTime * gesture.deltaPinch;
			Vector3 localScale = base.transform.localScale;
			base.transform.localScale = new Vector3(localScale.x - num, localScale.y - num, localScale.z - num);
			textMesh.text = "Delta pinch : " + gesture.deltaPinch;
		}
	}

	private void On_PinchOut(Gesture gesture)
	{
		if (gesture.pickedObject == base.gameObject)
		{
			float num = Time.deltaTime * gesture.deltaPinch;
			Vector3 localScale = base.transform.localScale;
			base.transform.localScale = new Vector3(localScale.x + num, localScale.y + num, localScale.z + num);
			textMesh.text = "Delta pinch : " + gesture.deltaPinch;
		}
	}

	private void On_PinchEnd(Gesture gesture)
	{
		if (gesture.pickedObject == base.gameObject)
		{
			base.transform.localScale = new Vector3(2.5f, 2.5f, 2.5f);
			EasyTouch.SetEnableTwist(enable: true);
			textMesh.text = "Pinch me";
		}
	}
}
public class TooglePickMethodUI : MonoBehaviour
{
	public void SetPickMethod2Finger(bool value)
	{
		if (value)
		{
			EasyTouch.SetTwoFingerPickMethod(EasyTouch.TwoFingerPickMethod.Finger);
		}
	}

	public void SetPickMethod2Averager(bool value)
	{
		if (value)
		{
			EasyTouch.SetTwoFingerPickMethod(EasyTouch.TwoFingerPickMethod.Average);
		}
	}
}
public class TwistMe : MonoBehaviour
{
	private TextMesh textMesh;

	private void OnEnable()
	{
		EasyTouch.On_TouchStart2Fingers += On_TouchStart2Fingers;
		EasyTouch.On_Twist += On_Twist;
		EasyTouch.On_TwistEnd += On_TwistEnd;
		EasyTouch.On_Cancel2Fingers += On_Cancel2Fingers;
	}

	private void OnDisable()
	{
		UnsubscribeEvent();
	}

	private void OnDestroy()
	{
		UnsubscribeEvent();
	}

	private void UnsubscribeEvent()
	{
		EasyTouch.On_TouchStart2Fingers -= On_TouchStart2Fingers;
		EasyTouch.On_Twist -= On_Twist;
		EasyTouch.On_TwistEnd -= On_TwistEnd;
		EasyTouch.On_Cancel2Fingers -= On_Cancel2Fingers;
	}

	private void Start()
	{
		textMesh = GetComponentInChildren<TextMesh>();
	}

	private void On_TouchStart2Fingers(Gesture gesture)
	{
		if (gesture.pickedObject == base.gameObject)
		{
			EasyTouch.SetEnableTwist(enable: true);
			EasyTouch.SetEnablePinch(enable: false);
		}
	}

	private void On_Twist(Gesture gesture)
	{
		if (gesture.pickedObject == base.gameObject)
		{
			base.transform.Rotate(new Vector3(0f, 0f, gesture.twistAngle));
			textMesh.text = "Delta angle : " + gesture.twistAngle;
		}
	}

	private void On_TwistEnd(Gesture gesture)
	{
		if (gesture.pickedObject == base.gameObject)
		{
			EasyTouch.SetEnablePinch(enable: true);
			base.transform.rotation = Quaternion.identity;
			textMesh.text = "Twist me";
		}
	}

	private void On_Cancel2Fingers(Gesture gesture)
	{
		EasyTouch.SetEnablePinch(enable: true);
		base.transform.rotation = Quaternion.identity;
		textMesh.text = "Twist me";
	}
}
public class TwoDoubleTapMe : MonoBehaviour
{
	private void OnEnable()
	{
		EasyTouch.On_DoubleTap2Fingers += On_DoubleTap2Fingers;
	}

	private void OnDisable()
	{
		UnsubscribeEvent();
	}

	private void OnDestroy()
	{
		UnsubscribeEvent();
	}

	private void UnsubscribeEvent()
	{
		EasyTouch.On_DoubleTap2Fingers -= On_DoubleTap2Fingers;
	}

	private void On_DoubleTap2Fingers(Gesture gesture)
	{
		if (gesture.pickedObject == base.gameObject)
		{
			base.gameObject.GetComponent<Renderer>().material.color = new Color(UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f));
		}
	}
}
public class TwoDragMe : MonoBehaviour
{
	private TextMesh textMesh;

	private Vector3 deltaPosition;

	private Color startColor;

	private void OnEnable()
	{
		EasyTouch.On_DragStart2Fingers += On_DragStart2Fingers;
		EasyTouch.On_Drag2Fingers += On_Drag2Fingers;
		EasyTouch.On_DragEnd2Fingers += On_DragEnd2Fingers;
		EasyTouch.On_Cancel2Fingers += On_Cancel2Fingers;
	}

	private void OnDisable()
	{
		UnsubscribeEvent();
	}

	private void OnDestroy()
	{
		UnsubscribeEvent();
	}

	private void UnsubscribeEvent()
	{
		EasyTouch.On_DragStart2Fingers -= On_DragStart2Fingers;
		EasyTouch.On_Drag2Fingers -= On_Drag2Fingers;
		EasyTouch.On_DragEnd2Fingers -= On_DragEnd2Fingers;
		EasyTouch.On_Cancel2Fingers -= On_Cancel2Fingers;
	}

	private void Start()
	{
		textMesh = GetComponentInChildren<TextMesh>();
		startColor = base.gameObject.GetComponent<Renderer>().material.color;
	}

	private void On_DragStart2Fingers(Gesture gesture)
	{
		if (gesture.pickedObject == base.gameObject)
		{
			RandomColor();
			Vector3 touchToWorldPoint = gesture.GetTouchToWorldPoint(gesture.pickedObject.transform.position);
			deltaPosition = touchToWorldPoint - base.transform.position;
		}
	}

	private void On_Drag2Fingers(Gesture gesture)
	{
		if (gesture.pickedObject == base.gameObject)
		{
			Vector3 touchToWorldPoint = gesture.GetTouchToWorldPoint(gesture.pickedObject.transform.position);
			base.transform.position = touchToWorldPoint - deltaPosition;
			float swipeOrDragAngle = gesture.GetSwipeOrDragAngle();
			textMesh.text = swipeOrDragAngle.ToString("f2") + " / " + gesture.swipe;
		}
	}

	private void On_DragEnd2Fingers(Gesture gesture)
	{
		if (gesture.pickedObject == base.gameObject)
		{
			base.gameObject.GetComponent<Renderer>().material.color = startColor;
			textMesh.text = "Drag me";
		}
	}

	private void On_Cancel2Fingers(Gesture gesture)
	{
		On_DragEnd2Fingers(gesture);
	}

	private void RandomColor()
	{
		base.gameObject.GetComponent<Renderer>().material.color = new Color(UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f));
	}
}
public class TwoLongTapMe : MonoBehaviour
{
	private TextMesh textMesh;

	private Color startColor;

	private void OnEnable()
	{
		EasyTouch.On_LongTapStart2Fingers += On_LongTapStart2Fingers;
		EasyTouch.On_LongTap2Fingers += On_LongTap2Fingers;
		EasyTouch.On_LongTapEnd2Fingers += On_LongTapEnd2Fingers;
		EasyTouch.On_Cancel2Fingers += On_Cancel2Fingers;
	}

	private void OnDisable()
	{
		UnsubscribeEvent();
	}

	private void OnDestroy()
	{
		UnsubscribeEvent();
	}

	private void UnsubscribeEvent()
	{
		EasyTouch.On_LongTapStart2Fingers -= On_LongTapStart2Fingers;
		EasyTouch.On_LongTap2Fingers -= On_LongTap2Fingers;
		EasyTouch.On_LongTapEnd2Fingers -= On_LongTapEnd2Fingers;
		EasyTouch.On_Cancel2Fingers -= On_Cancel2Fingers;
	}

	private void Start()
	{
		textMesh = GetComponentInChildren<TextMesh>();
		startColor = base.gameObject.GetComponent<Renderer>().material.color;
	}

	private void On_LongTapStart2Fingers(Gesture gesture)
	{
		if (gesture.pickedObject == base.gameObject)
		{
			RandomColor();
		}
	}

	private void On_LongTap2Fingers(Gesture gesture)
	{
		if (gesture.pickedObject == base.gameObject)
		{
			textMesh.text = gesture.actionTime.ToString("f2");
		}
	}

	private void On_LongTapEnd2Fingers(Gesture gesture)
	{
		if (gesture.pickedObject == base.gameObject)
		{
			base.gameObject.GetComponent<Renderer>().material.color = startColor;
			textMesh.text = "Long tap me";
		}
	}

	private void On_Cancel2Fingers(Gesture gesture)
	{
		On_LongTapEnd2Fingers(gesture);
	}

	private void RandomColor()
	{
		base.gameObject.GetComponent<Renderer>().material.color = new Color(UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f));
	}
}
public class TwoSwipe : MonoBehaviour
{
	public GameObject trail;

	public Text swipeData;

	private void OnEnable()
	{
		EasyTouch.On_SwipeStart2Fingers += On_SwipeStart2Fingers;
		EasyTouch.On_Swipe2Fingers += On_Swipe2Fingers;
		EasyTouch.On_SwipeEnd2Fingers += On_SwipeEnd2Fingers;
	}

	private void OnDisable()
	{
		UnsubscribeEvent();
	}

	private void OnDestroy()
	{
		UnsubscribeEvent();
	}

	private void UnsubscribeEvent()
	{
		EasyTouch.On_SwipeStart2Fingers -= On_SwipeStart2Fingers;
		EasyTouch.On_Swipe2Fingers -= On_Swipe2Fingers;
		EasyTouch.On_SwipeEnd2Fingers -= On_SwipeEnd2Fingers;
	}

	private void On_SwipeStart2Fingers(Gesture gesture)
	{
		swipeData.text = "You start a swipe";
	}

	private void On_Swipe2Fingers(Gesture gesture)
	{
		Vector3 touchToWorldPoint = gesture.GetTouchToWorldPoint(5f);
		trail.transform.position = touchToWorldPoint;
	}

	private void On_SwipeEnd2Fingers(Gesture gesture)
	{
		float swipeOrDragAngle = gesture.GetSwipeOrDragAngle();
		swipeData.text = "Last swipe : " + gesture.swipe.ToString() + " /  vector : " + gesture.swipeVector.normalized.ToString() + " / angle : " + swipeOrDragAngle.ToString("f2");
	}
}
public class TwoTapMe : MonoBehaviour
{
	private void OnEnable()
	{
		EasyTouch.On_SimpleTap2Fingers += On_SimpleTap2Fingers;
	}

	private void OnDisable()
	{
		UnsubscribeEvent();
	}

	private void OnDestroy()
	{
		UnsubscribeEvent();
	}

	private void UnsubscribeEvent()
	{
		EasyTouch.On_SimpleTap2Fingers -= On_SimpleTap2Fingers;
	}

	private void On_SimpleTap2Fingers(Gesture gesture)
	{
		if (gesture.pickedObject == base.gameObject)
		{
			RandomColor();
		}
	}

	private void RandomColor()
	{
		base.gameObject.GetComponent<Renderer>().material.color = new Color(UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f));
	}
}
public class TwoTouchMe : MonoBehaviour
{
	private TextMesh textMesh;

	private Color startColor;

	private void OnEnable()
	{
		EasyTouch.On_TouchStart2Fingers += On_TouchStart2Fingers;
		EasyTouch.On_TouchDown2Fingers += On_TouchDown2Fingers;
		EasyTouch.On_TouchUp2Fingers += On_TouchUp2Fingers;
		EasyTouch.On_Cancel2Fingers += On_Cancel2Fingers;
	}

	private void OnDisable()
	{
		UnsubscribeEvent();
	}

	private void OnDestroy()
	{
		UnsubscribeEvent();
	}

	private void UnsubscribeEvent()
	{
		EasyTouch.On_TouchStart2Fingers -= On_TouchStart2Fingers;
		EasyTouch.On_TouchDown2Fingers -= On_TouchDown2Fingers;
		EasyTouch.On_TouchUp2Fingers -= On_TouchUp2Fingers;
		EasyTouch.On_Cancel2Fingers -= On_Cancel2Fingers;
	}

	private void Start()
	{
		textMesh = GetComponentInChildren<TextMesh>();
		startColor = base.gameObject.GetComponent<Renderer>().material.color;
	}

	private void On_TouchStart2Fingers(Gesture gesture)
	{
		if (gesture.pickedObject == base.gameObject)
		{
			RandomColor();
		}
	}

	private void On_TouchDown2Fingers(Gesture gesture)
	{
		if (gesture.pickedObject == base.gameObject)
		{
			textMesh.text = "Down since :" + gesture.actionTime.ToString("f2");
		}
	}

	private void On_TouchUp2Fingers(Gesture gesture)
	{
		if (gesture.pickedObject == base.gameObject)
		{
			base.gameObject.GetComponent<Renderer>().material.color = startColor;
			textMesh.text = "Touch me";
		}
	}

	private void On_Cancel2Fingers(Gesture gesture)
	{
		On_TouchUp2Fingers(gesture);
	}

	private void RandomColor()
	{
		base.gameObject.GetComponent<Renderer>().material.color = new Color(UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f));
	}
}
public class ETWindow : MonoBehaviour
{
	private bool drag;

	private void OnEnable()
	{
		EasyTouch.On_TouchDown += On_TouchDown;
		EasyTouch.On_TouchStart += On_TouchStart;
	}

	private void OnDestroy()
	{
		EasyTouch.On_TouchDown -= On_TouchDown;
		EasyTouch.On_TouchStart -= On_TouchStart;
	}

	private void On_TouchStart(Gesture gesture)
	{
		drag = false;
		if (gesture.isOverGui && (gesture.pickedUIElement == base.gameObject || gesture.pickedUIElement.transform.IsChildOf(base.transform)))
		{
			base.transform.SetAsLastSibling();
			drag = true;
		}
	}

	private void On_TouchDown(Gesture gesture)
	{
		if (gesture.isOverGui && (gesture.pickedUIElement == base.gameObject || gesture.pickedUIElement.transform.IsChildOf(base.transform)) && drag)
		{
			base.transform.position += (Vector3)gesture.deltaPosition;
		}
	}
}
public class GlobalEasyTouchEvent : MonoBehaviour
{
	public Text statText;

	private void OnEnable()
	{
		EasyTouch.On_TouchDown += On_TouchDown;
		EasyTouch.On_TouchUp += On_TouchUp;
		EasyTouch.On_OverUIElement += On_OverUIElement;
		EasyTouch.On_UIElementTouchUp += On_UIElementTouchUp;
	}

	private void OnDestroy()
	{
		EasyTouch.On_TouchDown -= On_TouchDown;
		EasyTouch.On_TouchUp -= On_TouchUp;
		EasyTouch.On_OverUIElement -= On_OverUIElement;
		EasyTouch.On_UIElementTouchUp -= On_UIElementTouchUp;
	}

	private void On_TouchDown(Gesture gesture)
	{
		statText.transform.SetAsFirstSibling();
		if (gesture.pickedUIElement != null)
		{
			statText.text = "You touch UI Element : " + gesture.pickedUIElement.name + " (from gesture event)";
		}
		if (!gesture.isOverGui && gesture.pickedObject == null)
		{
			statText.text = "You touch an empty area";
		}
		if (gesture.pickedObject != null && !gesture.isOverGui)
		{
			statText.text = "You touch a 3D Object";
		}
	}

	private void On_OverUIElement(Gesture gesture)
	{
		statText.text = "You touch UI Element : " + gesture.pickedUIElement.name + " (from On_OverUIElement event)";
	}

	private void On_UIElementTouchUp(Gesture gesture)
	{
		statText.text = "";
	}

	private void On_TouchUp(Gesture gesture)
	{
		statText.text = "";
	}
}
public class UICompatibility : MonoBehaviour
{
	public void SetCompatibility(bool value)
	{
		EasyTouch.SetUICompatibily(value);
	}
}
public class UIWindow : MonoBehaviour, IDragHandler, IEventSystemHandler, IPointerDownHandler
{
	public void OnDrag(PointerEventData eventData)
	{
		base.transform.position += (Vector3)eventData.delta;
	}

	public void OnPointerDown(PointerEventData eventData)
	{
		base.transform.SetAsLastSibling();
	}
}
public class UIDrag : MonoBehaviour
{
	private int fingerId = -1;

	private bool drag = true;

	private void OnEnable()
	{
		EasyTouch.On_TouchDown += On_TouchDown;
		EasyTouch.On_TouchStart += On_TouchStart;
		EasyTouch.On_TouchUp += On_TouchUp;
		EasyTouch.On_TouchStart2Fingers += On_TouchStart2Fingers;
		EasyTouch.On_TouchDown2Fingers += On_TouchDown2Fingers;
		EasyTouch.On_TouchUp2Fingers += On_TouchUp2Fingers;
	}

	private void OnDestroy()
	{
		EasyTouch.On_TouchDown -= On_TouchDown;
		EasyTouch.On_TouchStart -= On_TouchStart;
		EasyTouch.On_TouchUp -= On_TouchUp;
		EasyTouch.On_TouchStart2Fingers -= On_TouchStart2Fingers;
		EasyTouch.On_TouchDown2Fingers -= On_TouchDown2Fingers;
		EasyTouch.On_TouchUp2Fingers -= On_TouchUp2Fingers;
	}

	private void On_TouchStart(Gesture gesture)
	{
		if (gesture.isOverGui && drag && (gesture.pickedUIElement == base.gameObject || gesture.pickedUIElement.transform.IsChildOf(base.transform)) && fingerId == -1)
		{
			fingerId = gesture.fingerIndex;
			base.transform.SetAsLastSibling();
		}
	}

	private void On_TouchDown(Gesture gesture)
	{
		if (fingerId == gesture.fingerIndex && drag && gesture.isOverGui && (gesture.pickedUIElement == base.gameObject || gesture.pickedUIElement.transform.IsChildOf(base.transform)))
		{
			base.transform.position += (Vector3)gesture.deltaPosition;
		}
	}

	private void On_TouchUp(Gesture gesture)
	{
		if (fingerId == gesture.fingerIndex)
		{
			fingerId = -1;
		}
	}

	private void On_TouchStart2Fingers(Gesture gesture)
	{
		if (gesture.isOverGui && drag && (gesture.pickedUIElement == base.gameObject || gesture.pickedUIElement.transform.IsChildOf(base.transform)) && fingerId == -1)
		{
			base.transform.SetAsLastSibling();
		}
	}

	private void On_TouchDown2Fingers(Gesture gesture)
	{
		if (gesture.isOverGui && (gesture.pickedUIElement == base.gameObject || gesture.pickedUIElement.transform.IsChildOf(base.transform)))
		{
			if (gesture.pickedUIElement == base.gameObject || gesture.pickedUIElement.transform.IsChildOf(base.transform))
			{
				base.transform.position += (Vector3)gesture.deltaPosition;
			}
			drag = false;
		}
	}

	private void On_TouchUp2Fingers(Gesture gesture)
	{
		if (gesture.isOverGui && (gesture.pickedUIElement == base.gameObject || gesture.pickedUIElement.transform.IsChildOf(base.transform)))
		{
			drag = true;
		}
	}
}
public class UIPinch : MonoBehaviour
{
	public void OnEnable()
	{
		EasyTouch.On_Pinch += On_Pinch;
	}

	public void OnDestroy()
	{
		EasyTouch.On_Pinch -= On_Pinch;
	}

	private void On_Pinch(Gesture gesture)
	{
		if (gesture.isOverGui && (gesture.pickedUIElement == base.gameObject || gesture.pickedUIElement.transform.IsChildOf(base.transform)))
		{
			base.transform.localScale = new Vector3(base.transform.localScale.x + gesture.deltaPinch * Time.deltaTime, base.transform.localScale.y + gesture.deltaPinch * Time.deltaTime, base.transform.localScale.z);
		}
	}
}
public class UITwist : MonoBehaviour
{
	public void OnEnable()
	{
		EasyTouch.On_Twist += On_Twist;
	}

	public void OnDestroy()
	{
		EasyTouch.On_Twist -= On_Twist;
	}

	private void On_Twist(Gesture gesture)
	{
		if (gesture.isOverGui && (gesture.pickedUIElement == base.gameObject || gesture.pickedUIElement.transform.IsChildOf(base.transform)))
		{
			base.transform.Rotate(new Vector3(0f, 0f, gesture.twistAngle));
		}
	}
}
public class RTS_NewSyntaxe : MonoBehaviour
{
	private GameObject cube;

	private void Start()
	{
		cube = null;
	}

	private void Update()
	{
		Gesture current = EasyTouch.current;
		if (current.type == EasyTouch.EvtType.On_SimpleTap && current.pickedObject != null && current.pickedObject.name == "Cube")
		{
			ResteColor();
			cube = current.pickedObject;
			cube.GetComponent<Renderer>().material.color = Color.red;
			base.transform.Translate(Vector2.up, Space.World);
		}
		if (current.type == EasyTouch.EvtType.On_Swipe && current.touchCount == 1)
		{
			base.transform.Translate(Vector3.left * current.deltaPosition.x / UnityEngine.Screen.width);
			base.transform.Translate(Vector3.back * current.deltaPosition.y / UnityEngine.Screen.height);
		}
		if (current.type == EasyTouch.EvtType.On_Pinch)
		{
			Camera.main.fieldOfView += current.deltaPinch * 10f * Time.deltaTime;
		}
		if (current.type == EasyTouch.EvtType.On_Twist)
		{
			base.transform.Rotate(Vector3.up * current.twistAngle);
		}
	}

	private void ResteColor()
	{
		if (cube != null)
		{
			cube.GetComponent<Renderer>().material.color = new Color(0.23529412f, 0.56078434f, 67f / 85f);
		}
	}
}
public class SimpleActionExample : MonoBehaviour
{
	private TextMesh textMesh;

	private Vector3 startScale;

	private void Start()
	{
		textMesh = GetComponentInChildren<TextMesh>();
		startScale = base.transform.localScale;
	}

	public void ChangeColor(Gesture gesture)
	{
		RandomColor();
	}

	public void TimePressed(Gesture gesture)
	{
		textMesh.text = "Down since :" + gesture.actionTime.ToString("f2");
	}

	public void DisplaySwipeAngle(Gesture gesture)
	{
		float swipeOrDragAngle = gesture.GetSwipeOrDragAngle();
		textMesh.text = swipeOrDragAngle.ToString("f2") + " / " + gesture.swipe;
	}

	public void ChangeText(string text)
	{
		textMesh.text = text;
	}

	public void ResetScale()
	{
		base.transform.localScale = startScale;
	}

	private void RandomColor()
	{
		base.gameObject.GetComponent<Renderer>().material.color = new Color(UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f));
	}
}
[AddComponentMenu("EasyTouch Controls/Set Direct Action Transform ")]
public class ETCSetDirectActionTransform : MonoBehaviour
{
	public string axisName1;

	public string axisName2;

	private void Start()
	{
		if (!string.IsNullOrEmpty(axisName1))
		{
			ETCInput.SetAxisDirecTransform(axisName1, base.transform);
		}
		if (!string.IsNullOrEmpty(axisName2))
		{
			ETCInput.SetAxisDirecTransform(axisName2, base.transform);
		}
	}
}
public class ButtonInputUI : MonoBehaviour
{
	public Text getButtonDownText;

	public Text getButtonText;

	public Text getButtonTimeText;

	public Text getButtonUpText;

	private void Update()
	{
		if (ETCInput.GetButton("Button"))
		{
			getButtonText.text = "YES";
			getButtonTimeText.text = ETCInput.GetButtonValue("Button").ToString();
		}
		else
		{
			getButtonText.text = "";
			getButtonTimeText.text = "";
		}
		if (ETCInput.GetButtonDown("Button"))
		{
			getButtonDownText.text = "YES";
			StartCoroutine(ClearText(getButtonDownText));
		}
		if (ETCInput.GetButtonUp("Button"))
		{
			getButtonUpText.text = "YES";
			StartCoroutine(ClearText(getButtonUpText));
		}
	}

	private IEnumerator ClearText(Text textToCLead)
	{
		yield return new WaitForSeconds(0.3f);
		textToCLead.text = "";
	}

	public void SetSwipeIn(bool value)
	{
		ETCInput.SetControlSwipeIn("Button", value);
	}

	public void SetSwipeOut(bool value)
	{
		ETCInput.SetControlSwipeOut("Button", value);
	}

	public void setTimePush(bool value)
	{
		ETCInput.SetAxisOverTime("Button", value);
	}
}
public class ButtonUIEvent : MonoBehaviour
{
	public Text downText;

	public Text pressText;

	public Text pressValueText;

	public Text upText;

	public void Down()
	{
		downText.text = "YES";
		StartCoroutine(ClearText(downText));
	}

	public void Up()
	{
		upText.text = "YES";
		StartCoroutine(ClearText(upText));
		StartCoroutine(ClearText(pressText));
		StartCoroutine(ClearText(pressValueText));
	}

	public void Press()
	{
		pressText.text = "YES";
	}

	public void PressValue(float value)
	{
		pressValueText.text = value.ToString();
	}

	private IEnumerator ClearText(Text textToCLead)
	{
		yield return new WaitForSeconds(0.3f);
		textToCLead.text = "";
	}
}
public class ControlUIEvent : MonoBehaviour
{
	public Text moveStartText;

	public Text moveText;

	public Text moveSpeedText;

	public Text moveEndText;

	public Text touchStartText;

	public Text touchUpText;

	public Text downRightText;

	public Text downDownText;

	public Text downLeftText;

	public Text downUpText;

	public Text rightText;

	public Text downText;

	public Text leftText;

	public Text upText;

	private bool isDown;

	private bool isLeft;

	private bool isUp;

	private bool isRight;

	private void Update()
	{
		if (isDown)
		{
			downText.text = "YES";
			isDown = false;
		}
		else
		{
			downText.text = "";
		}
		if (isLeft)
		{
			leftText.text = "YES";
			isLeft = false;
		}
		else
		{
			leftText.text = "";
		}
		if (isUp)
		{
			upText.text = "YES";
			isUp = false;
		}
		else
		{
			upText.text = "";
		}
		if (isRight)
		{
			rightText.text = "YES";
			isRight = false;
		}
		else
		{
			rightText.text = "";
		}
	}

	public void MoveStart()
	{
		moveStartText.text = "YES";
		StartCoroutine(ClearText(moveStartText));
	}

	public void Move(Vector2 move)
	{
		moveText.text = move.ToString();
	}

	public void MoveSpeed(Vector2 move)
	{
		moveSpeedText.text = move.ToString();
	}

	public void MoveEnd()
	{
		if (moveEndText.enabled)
		{
			moveEndText.text = "YES";
			StartCoroutine(ClearText(moveEndText));
			StartCoroutine(ClearText(touchUpText));
			StartCoroutine(ClearText(moveText));
			StartCoroutine(ClearText(moveSpeedText));
		}
	}

	public void TouchStart()
	{
		touchStartText.text = "YES";
		StartCoroutine(ClearText(touchStartText));
	}

	public void TouchUp()
	{
		touchUpText.text = "YES";
		StartCoroutine(ClearText(touchUpText));
		StartCoroutine(ClearText(moveText));
		StartCoroutine(ClearText(moveSpeedText));
	}

	public void DownRight()
	{
		downRightText.text = "YES";
		StartCoroutine(ClearText(downRightText));
	}

	public void DownDown()
	{
		downDownText.text = "YES";
		StartCoroutine(ClearText(downDownText));
	}

	public void DownLeft()
	{
		downLeftText.text = "YES";
		StartCoroutine(ClearText(downLeftText));
	}

	public void DownUp()
	{
		downUpText.text = "YES";
		StartCoroutine(ClearText(downUpText));
	}

	public void Right()
	{
		isRight = true;
	}

	public void Down()
	{
		isDown = true;
	}

	public void Left()
	{
		isLeft = true;
	}

	public void Up()
	{
		isUp = true;
	}

	private IEnumerator ClearText(Text textToCLead)
	{
		yield return new WaitForSeconds(0.3f);
		textToCLead.text = "";
	}
}
public class ControlUIInput : MonoBehaviour
{
	public Text getAxisText;

	public Text getAxisSpeedText;

	public Text getAxisYText;

	public Text getAxisYSpeedText;

	public Text downRightText;

	public Text downDownText;

	public Text downLeftText;

	public Text downUpText;

	public Text rightText;

	public Text downText;

	public Text leftText;

	public Text upText;

	private void Update()
	{
		getAxisText.text = ETCInput.GetAxis("Horizontal").ToString("f2");
		getAxisSpeedText.text = ETCInput.GetAxisSpeed("Horizontal").ToString("f2");
		getAxisYText.text = ETCInput.GetAxis("Vertical").ToString("f2");
		getAxisYSpeedText.text = ETCInput.GetAxisSpeed("Vertical").ToString("f2");
		if (ETCInput.GetAxisDownRight("Horizontal"))
		{
			downRightText.text = "YES";
			StartCoroutine(ClearText(downRightText));
		}
		if (ETCInput.GetAxisDownDown("Vertical"))
		{
			downDownText.text = "YES";
			StartCoroutine(ClearText(downDownText));
		}
		if (ETCInput.GetAxisDownLeft("Horizontal"))
		{
			downLeftText.text = "YES";
			StartCoroutine(ClearText(downLeftText));
		}
		if (ETCInput.GetAxisDownUp("Vertical"))
		{
			downUpText.text = "YES";
			StartCoroutine(ClearText(downUpText));
		}
		if (ETCInput.GetAxisPressedRight("Horizontal"))
		{
			rightText.text = "YES";
		}
		else
		{
			rightText.text = "";
		}
		if (ETCInput.GetAxisPressedDown("Vertical"))
		{
			downText.text = "YES";
		}
		else
		{
			downText.text = "";
		}
		if (ETCInput.GetAxisPressedLeft("Horizontal"))
		{
			leftText.text = "Yes";
		}
		else
		{
			leftText.text = "";
		}
		if (ETCInput.GetAxisPressedUp("Vertical"))
		{
			upText.text = "YES";
		}
		else
		{
			upText.text = "";
		}
	}

	private IEnumerator ClearText(Text textToCLead)
	{
		yield return new WaitForSeconds(0.3f);
		textToCLead.text = "";
	}
}
public class DPadParameterUI : MonoBehaviour
{
	public void SetClassicalInertia(bool value)
	{
		ETCInput.SetAxisInertia("Horizontal", value);
		ETCInput.SetAxisInertia("Vertical", value);
	}

	public void SetTimePushInertia(bool value)
	{
		ETCInput.SetAxisInertia("HorizontalTP", value);
		ETCInput.SetAxisInertia("VerticalTP", value);
	}

	public void SetClassicalTwoAxesCount()
	{
		ETCInput.SetDPadAxesCount("DPadClassical", ETCBase.DPadAxis.Two_Axis);
	}

	public void SetClassicalFourAxesCount()
	{
		ETCInput.SetDPadAxesCount("DPadClassical", ETCBase.DPadAxis.Four_Axis);
	}

	public void SetTimePushTwoAxesCount()
	{
		ETCInput.SetDPadAxesCount("DPadTimePush", ETCBase.DPadAxis.Two_Axis);
	}

	public void SetTimePushFourAxesCount()
	{
		ETCInput.SetDPadAxesCount("DPadTimePush", ETCBase.DPadAxis.Four_Axis);
	}
}
public class FPSPlayerControl : MonoBehaviour
{
	public AudioClip gunSound;

	public AudioClip reload;

	public AudioClip needReload;

	public ParticleSystem shellParticle;

	public GameObject muzzleEffect;

	public GameObject impactEffect;

	public Text armoText;

	private bool inFire;

	private bool inReload;

	private Animator anim;

	private int armoCount = 30;

	private AudioSource audioSource;

	private void Awake()
	{
		anim = GetComponentInChildren<Animator>();
		audioSource = GetComponent<AudioSource>();
	}

	private void Update()
	{
		if (ETCInput.GetButton("Fire") && !inFire && armoCount > 0 && !inReload)
		{
			inFire = true;
			anim.SetBool("Shoot", value: true);
			InvokeRepeating("GunFire", 0.12f, 0.12f);
			GunFire();
		}
		if (ETCInput.GetButtonDown("Fire") && armoCount == 0 && !inReload)
		{
			audioSource.PlayOneShot(needReload, 1f);
		}
		if (ETCInput.GetButtonUp("Fire"))
		{
			anim.SetBool("Shoot", value: false);
			muzzleEffect.SetActive(value: false);
			inFire = false;
			CancelInvoke();
		}
		if (ETCInput.GetButtonDown("Reload"))
		{
			inReload = true;
			audioSource.PlayOneShot(reload, 1f);
			anim.SetBool("Reload", value: true);
			StartCoroutine(Reload());
		}
		if (ETCInput.GetButtonDown("Back"))
		{
			base.transform.Rotate(Vector3.up * 180f);
		}
		armoText.text = armoCount.ToString();
	}

	public void MoveStart()
	{
		anim.SetBool("Move", value: true);
	}

	public void MoveStop()
	{
		anim.SetBool("Move", value: false);
	}

	public void GunFire()
	{
		if (armoCount > 0)
		{
			muzzleEffect.transform.Rotate(Vector3.forward * UnityEngine.Random.Range(0f, 360f));
			muzzleEffect.transform.localScale = new Vector3(UnityEngine.Random.Range(0.1f, 0.2f), UnityEngine.Random.Range(0.1f, 0.2f), 1f);
			muzzleEffect.SetActive(value: true);
			StartCoroutine(Flash());
			audioSource.PlayOneShot(gunSound, 1f);
			shellParticle.Emit(1);
			Vector3 pos = new Vector3(UnityEngine.Screen.width / 2, UnityEngine.Screen.height / 2, 0f);
			pos += new Vector3(UnityEngine.Random.Range(-10, 10), UnityEngine.Random.Range(-10, 10), 0f);
			RaycastHit[] array = Physics.RaycastAll(Camera.main.ScreenPointToRay(pos));
			if (array.Length != 0)
			{
				UnityEngine.Object.Instantiate(impactEffect, array[0].point - array[0].normal * -0.2f, Quaternion.identity);
			}
		}
		else
		{
			anim.SetBool("Shoot", value: false);
			muzzleEffect.SetActive(value: false);
			inFire = false;
		}
		armoCount--;
		if (armoCount < 0)
		{
			armoCount = 0;
		}
	}

	public void TouchPadSwipe(bool value)
	{
		ETCInput.SetControlSwipeIn("FreeLookTouchPad", value);
	}

	private IEnumerator Flash()
	{
		yield return new WaitForSeconds(0.08f);
		muzzleEffect.SetActive(value: false);
	}

	private IEnumerator Reload()
	{
		yield return new WaitForSeconds(0.5f);
		armoCount = 30;
		inReload = false;
		anim.SetBool("Reload", value: false);
	}
}
public class ImpactEffect : MonoBehaviour
{
	private ParticleSystem ps;

	private void Start()
	{
		ps = GetComponent<ParticleSystem>();
	}

	private void Update()
	{
		if (!ps.IsAlive())
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}
}
public class AxisXUi : MonoBehaviour
{
	public void ActivateAxisX(bool value)
	{
		ETCInput.SetAxisEnabled("Horizontal", value);
	}

	public void InvertedAxisX(bool value)
	{
		ETCInput.SetAxisInverted("Horizontal", value);
	}

	public void DeadAxisX(float value)
	{
		ETCInput.SetAxisDeadValue("Horizontal", value);
	}

	public void SpeedAxisX(float value)
	{
		ETCInput.SetAxisSensitivity("Horizontal", value);
	}

	public void IsInertiaX(bool value)
	{
		ETCInput.SetAxisInertia("Horizontal", value);
	}

	public void InertiaSpeedX(float value)
	{
		ETCInput.SetAxisInertiaSpeed("Horizontal", value);
	}

	public void ActivateAxisY(bool value)
	{
		ETCInput.SetAxisEnabled("Vertical", value);
	}

	public void InvertedAxisY(bool value)
	{
		ETCInput.SetAxisInverted("Vertical", value);
	}

	public void DeadAxisY(float value)
	{
		ETCInput.SetAxisDeadValue("Vertical", value);
	}

	public void SpeedAxisY(float value)
	{
		ETCInput.SetAxisSensitivity("Vertical", value);
	}

	public void IsInertiaY(bool value)
	{
		ETCInput.SetAxisInertia("Vertical", value);
	}

	public void InertiaSpeedY(float value)
	{
		ETCInput.SetAxisInertiaSpeed("Vertical", value);
	}
}
public class LoadLevelScript : MonoBehaviour
{
	public void LoadMainMenu()
	{
		UnityEngine.Application.LoadLevel("MainMenu");
	}

	public void LoadJoystickEvent()
	{
		UnityEngine.Application.LoadLevel("Joystick-Event-Input");
	}

	public void LoadJoysticParameter()
	{
		UnityEngine.Application.LoadLevel("Joystick-Parameter");
	}

	public void LoadDPadEvent()
	{
		UnityEngine.Application.LoadLevel("DPad-Event-Input");
	}

	public void LoadDPadClassicalTime()
	{
		UnityEngine.Application.LoadLevel("DPad-Classical-Time");
	}

	public void LoadTouchPad()
	{
		UnityEngine.Application.LoadLevel("TouchPad-Event-Input");
	}

	public void LoadButton()
	{
		UnityEngine.Application.LoadLevel("Button-Event-Input");
	}

	public void LoadFPS()
	{
		UnityEngine.Application.LoadLevel("FPS_Example");
	}

	public void LoadThird()
	{
		UnityEngine.Application.LoadLevel("ThirdPerson+Jump");
	}

	public void LoadThirddungeon()
	{
		UnityEngine.Application.LoadLevel("ThirdPersonDungeon+Jump");
	}
}
public class TouchPadUIEvent : MonoBehaviour
{
	public Text touchDownText;

	public Text touchText;

	public Text touchUpText;

	public void TouchDown()
	{
		touchDownText.text = "YES";
		StartCoroutine(ClearText(touchDownText));
	}

	public void TouchEvt(Vector2 value)
	{
		touchText.text = value.ToString();
	}

	public void TouchUp()
	{
		touchUpText.text = "YES";
		StartCoroutine(ClearText(touchUpText));
		StartCoroutine(ClearText(touchText));
	}

	private IEnumerator ClearText(Text textToCLead)
	{
		yield return new WaitForSeconds(0.3f);
		textToCLead.text = "";
	}
}
public class CharacterAnimation : MonoBehaviour
{
	private CharacterController cc;

	private Animation anim;

	private void Start()
	{
		cc = GetComponentInChildren<CharacterController>();
		anim = GetComponentInChildren<Animation>();
	}

	private void LateUpdate()
	{
		if (cc.isGrounded && ETCInput.GetAxis("Vertical") != 0f)
		{
			anim.CrossFade("soldierRun");
		}
		if (cc.isGrounded && ETCInput.GetAxis("Vertical") == 0f && ETCInput.GetAxis("Horizontal") == 0f)
		{
			anim.CrossFade("soldierIdleRelaxed");
		}
		if (!cc.isGrounded)
		{
			anim.CrossFade("soldierFalling");
		}
		if (cc.isGrounded && ETCInput.GetAxis("Vertical") == 0f && ETCInput.GetAxis("Horizontal") > 0f)
		{
			anim.CrossFade("soldierSpinRight");
		}
		if (cc.isGrounded && ETCInput.GetAxis("Vertical") == 0f && ETCInput.GetAxis("Horizontal") < 0f)
		{
			anim.CrossFade("soldierSpinLeft");
		}
	}
}
public class CharacterAnimationDungeon : MonoBehaviour
{
	private CharacterController cc;

	private Animation anim;

	private void Start()
	{
		cc = GetComponentInChildren<CharacterController>();
		anim = GetComponentInChildren<Animation>();
	}

	private void LateUpdate()
	{
		if (cc.isGrounded && (ETCInput.GetAxis("Vertical") != 0f || ETCInput.GetAxis("Horizontal") != 0f))
		{
			anim.CrossFade("soldierRun");
		}
		if (cc.isGrounded && ETCInput.GetAxis("Vertical") == 0f && ETCInput.GetAxis("Horizontal") == 0f)
		{
			anim.CrossFade("soldierIdleRelaxed");
		}
		if (!cc.isGrounded)
		{
			anim.CrossFade("soldierFalling");
		}
	}
}
public class SliderText : MonoBehaviour
{
	public void SetText(float value)
	{
		GetComponent<Text>().text = value.ToString("f2");
	}
}
public static class ComponentExtensions
{
	public static RectTransform rectTransform(this UnityEngine.Component cp)
	{
		return cp.transform as RectTransform;
	}

	public static float Remap(this float value, float from1, float to1, float from2, float to2)
	{
		return (value - from1) / (to1 - from1) * (to2 - from2) + from2;
	}
}
[Serializable]
public class ETCArea : MonoBehaviour
{
	public enum AreaPreset
	{
		Choose,
		TopLeft,
		TopRight,
		BottomLeft,
		BottomRight
	}

	public bool show;

	public ETCArea()
	{
		show = true;
	}

	public void Awake()
	{
		GetComponent<Image>().enabled = show;
	}

	public void ApplyPreset(AreaPreset preset)
	{
		RectTransform component = base.transform.parent.GetComponent<RectTransform>();
		switch (preset)
		{
		case AreaPreset.TopRight:
			this.rectTransform().anchoredPosition = new Vector2(component.rect.width / 4f, component.rect.height / 4f);
			this.rectTransform().SetSizeWithCurrentAnchors(RectTransform.Axis.Horizontal, component.rect.width / 2f);
			this.rectTransform().SetSizeWithCurrentAnchors(RectTransform.Axis.Vertical, component.rect.height / 2f);
			this.rectTransform().anchorMin = new Vector2(1f, 1f);
			this.rectTransform().anchorMax = new Vector2(1f, 1f);
			this.rectTransform().anchoredPosition = new Vector2((0f - this.rectTransform().sizeDelta.x) / 2f, (0f - this.rectTransform().sizeDelta.y) / 2f);
			break;
		case AreaPreset.TopLeft:
			this.rectTransform().anchoredPosition = new Vector2((0f - component.rect.width) / 4f, component.rect.height / 4f);
			this.rectTransform().SetSizeWithCurrentAnchors(RectTransform.Axis.Horizontal, component.rect.width / 2f);
			this.rectTransform().SetSizeWithCurrentAnchors(RectTransform.Axis.Vertical, component.rect.height / 2f);
			this.rectTransform().anchorMin = new Vector2(0f, 1f);
			this.rectTransform().anchorMax = new Vector2(0f, 1f);
			this.rectTransform().anchoredPosition = new Vector2(this.rectTransform().sizeDelta.x / 2f, (0f - this.rectTransform().sizeDelta.y) / 2f);
			break;
		case AreaPreset.BottomRight:
			this.rectTransform().anchoredPosition = new Vector2(component.rect.width / 4f, (0f - component.rect.height) / 4f);
			this.rectTransform().SetSizeWithCurrentAnchors(RectTransform.Axis.Horizontal, component.rect.width / 2f);
			this.rectTransform().SetSizeWithCurrentAnchors(RectTransform.Axis.Vertical, component.rect.height / 2f);
			this.rectTransform().anchorMin = new Vector2(1f, 0f);
			this.rectTransform().anchorMax = new Vector2(1f, 0f);
			this.rectTransform().anchoredPosition = new Vector2((0f - this.rectTransform().sizeDelta.x) / 2f, this.rectTransform().sizeDelta.y / 2f);
			break;
		case AreaPreset.BottomLeft:
			this.rectTransform().anchoredPosition = new Vector2((0f - component.rect.width) / 4f, (0f - component.rect.height) / 4f);
			this.rectTransform().SetSizeWithCurrentAnchors(RectTransform.Axis.Horizontal, component.rect.width / 2f);
			this.rectTransform().SetSizeWithCurrentAnchors(RectTransform.Axis.Vertical, component.rect.height / 2f);
			this.rectTransform().anchorMin = new Vector2(0f, 0f);
			this.rectTransform().anchorMax = new Vector2(0f, 0f);
			this.rectTransform().anchoredPosition = new Vector2(this.rectTransform().sizeDelta.x / 2f, this.rectTransform().sizeDelta.y / 2f);
			break;
		}
	}
}
[Serializable]
public class ETCAxis
{
	public enum DirectAction
	{
		Rotate,
		RotateLocal,
		Translate,
		TranslateLocal,
		Scale,
		Force,
		RelativeForce,
		Torque,
		RelativeTorque,
		Jump
	}

	public enum AxisInfluenced
	{
		X,
		Y,
		Z
	}

	public enum AxisValueMethod
	{
		Classical,
		Curve
	}

	public enum AxisState
	{
		None,
		Down,
		Press,
		Up,
		DownUp,
		DownDown,
		DownLeft,
		DownRight,
		PressUp,
		PressDown,
		PressLeft,
		PressRight
	}

	public enum ActionOn
	{
		Down,
		Press
	}

	public string name;

	public bool autoLinkTagPlayer;

	public string autoTag = "Player";

	public GameObject player;

	public bool enable;

	public bool invertedAxis;

	public float speed;

	public float deadValue;

	public AxisValueMethod valueMethod;

	public AnimationCurve curveValue;

	public bool isEnertia;

	public float inertia;

	public float inertiaThreshold;

	public bool isAutoStab;

	public float autoStabThreshold;

	public float autoStabSpeed;

	private float startAngle;

	public bool isClampRotation;

	public float maxAngle;

	public float minAngle;

	public bool isValueOverTime;

	public float overTimeStep;

	public float maxOverTimeValue;

	public float axisValue;

	public float axisSpeedValue;

	public float axisThreshold;

	public bool isLockinJump;

	private Vector3 lastMove;

	public AxisState axisState;

	[SerializeField]
	private Transform _directTransform;

	public DirectAction directAction;

	public AxisInfluenced axisInfluenced;

	public ActionOn actionOn;

	public CharacterController directCharacterController;

	public Rigidbody directRigidBody;

	public float gravity;

	public float currentGravity;

	public bool isJump;

	public string unityAxis;

	public bool showGeneralInspector;

	public bool showDirectInspector;

	public bool showInertiaInspector;

	public bool showSimulatinInspector;

	public Transform directTransform
	{
		get
		{
			return _directTransform;
		}
		set
		{
			_directTransform = value;
			if (_directTransform != null)
			{
				directCharacterController = _directTransform.GetComponent<CharacterController>();
				directRigidBody = _directTransform.GetComponent<Rigidbody>();
			}
			else
			{
				directCharacterController = null;
			}
		}
	}

	public ETCAxis(string axisName)
	{
		name = axisName;
		enable = true;
		speed = 15f;
		invertedAxis = false;
		isEnertia = false;
		inertia = 0f;
		inertiaThreshold = 0.08f;
		axisValue = 0f;
		axisSpeedValue = 0f;
		gravity = 0f;
		isAutoStab = false;
		autoStabThreshold = 0.01f;
		autoStabSpeed = 10f;
		maxAngle = 90f;
		minAngle = 90f;
		axisState = AxisState.None;
		maxOverTimeValue = 1f;
		overTimeStep = 1f;
		isValueOverTime = false;
		axisThreshold = 0.5f;
		deadValue = 0.1f;
		actionOn = ActionOn.Press;
	}

	public void InitAxis()
	{
		if (autoLinkTagPlayer)
		{
			player = GameObject.FindGameObjectWithTag(autoTag);
			UnityEngine.Debug.Log(player.name + "dadavv...");
			if ((bool)player)
			{
				directTransform = player.transform;
			}
		}
		startAngle = GetAngle();
	}

	public void UpdateAxis(float realValue, bool isOnDrag, ETCBase.ControlType type, bool deltaTime = true)
	{
		if ((autoLinkTagPlayer && player == null) || ((bool)player && !player.activeSelf))
		{
			player = GameObject.FindGameObjectWithTag(autoTag);
			if ((bool)player)
			{
				directTransform = player.transform;
			}
		}
		if (isAutoStab && axisValue == 0f && (bool)_directTransform)
		{
			DoAutoStabilisation();
		}
		if (invertedAxis)
		{
			realValue *= -1f;
		}
		if (isValueOverTime && realValue != 0f)
		{
			axisValue += overTimeStep * Mathf.Sign(realValue) * Time.deltaTime;
			if (Mathf.Sign(axisValue) > 0f)
			{
				axisValue = Mathf.Clamp(axisValue, 0f, maxOverTimeValue);
			}
			else
			{
				axisValue = Mathf.Clamp(axisValue, 0f - maxOverTimeValue, 0f);
			}
		}
		ComputAxisValue(realValue, type, isOnDrag, deltaTime);
	}

	public void UpdateButton()
	{
		if ((autoLinkTagPlayer && player == null) || ((bool)player && !player.activeSelf))
		{
			player = GameObject.FindGameObjectWithTag(autoTag);
			if ((bool)player)
			{
				directTransform = player.transform;
			}
		}
		if (isValueOverTime)
		{
			axisValue += overTimeStep * Time.deltaTime;
			axisValue = Mathf.Clamp(axisValue, 0f, maxOverTimeValue);
		}
		else if (axisState == AxisState.Press || axisState == AxisState.Down)
		{
			axisValue = 1f;
		}
		else
		{
			axisValue = 0f;
		}
		switch (actionOn)
		{
		case ActionOn.Down:
			axisSpeedValue = axisValue * speed;
			if (axisState == AxisState.Down)
			{
				DoDirectAction();
			}
			break;
		case ActionOn.Press:
			axisSpeedValue = axisValue * speed * Time.deltaTime;
			if (axisState == AxisState.Press)
			{
				DoDirectAction();
			}
			break;
		}
	}

	public void ResetAxis()
	{
		if (!isEnertia || (isEnertia && Mathf.Abs(axisValue) < inertiaThreshold))
		{
			axisValue = 0f;
			axisSpeedValue = 0f;
		}
	}

	public void DoDirectAction()
	{
		if (!directTransform)
		{
			return;
		}
		Vector3 influencedAxis = GetInfluencedAxis();
		switch (directAction)
		{
		case DirectAction.Rotate:
			directTransform.Rotate(influencedAxis * axisSpeedValue, Space.World);
			break;
		case DirectAction.RotateLocal:
			directTransform.Rotate(influencedAxis * axisSpeedValue * 20f, Space.Self);
			break;
		case DirectAction.Translate:
			if (directCharacterController == null)
			{
				directTransform.Translate(influencedAxis * axisSpeedValue, Space.World);
			}
			else if (directCharacterController.isGrounded || !isLockinJump)
			{
				Vector3 motion2 = influencedAxis * axisSpeedValue;
				directCharacterController.Move(motion2);
				lastMove = influencedAxis * (axisSpeedValue / Time.deltaTime);
			}
			else
			{
				directCharacterController.Move(lastMove * Time.deltaTime);
			}
			break;
		case DirectAction.TranslateLocal:
			if (directCharacterController == null)
			{
				directTransform.Translate(influencedAxis * axisSpeedValue, Space.Self);
			}
			else if (directCharacterController.isGrounded || !isLockinJump)
			{
				Vector3 motion = directCharacterController.transform.TransformDirection(influencedAxis) * axisSpeedValue;
				directCharacterController.Move(motion);
				lastMove = directCharacterController.transform.TransformDirection(influencedAxis) * (axisSpeedValue / Time.deltaTime);
			}
			else
			{
				directCharacterController.Move(lastMove * Time.deltaTime);
			}
			break;
		case DirectAction.Scale:
			directTransform.localScale += new Vector3(1f, 1f, 1f) * axisSpeedValue;
			break;
		case DirectAction.Force:
			if (directRigidBody != null)
			{
				directRigidBody.AddForce(influencedAxis * axisValue * speed);
			}
			else
			{
				UnityEngine.Debug.LogWarning("ETCAxis : " + name + " No rigidbody on gameobject : " + _directTransform.name);
			}
			break;
		case DirectAction.RelativeForce:
			if (directRigidBody != null)
			{
				directRigidBody.AddRelativeForce(influencedAxis * axisValue * speed);
			}
			else
			{
				UnityEngine.Debug.LogWarning("ETCAxis : " + name + " No rigidbody on gameobject : " + _directTransform.name);
			}
			break;
		case DirectAction.Torque:
			if (directRigidBody != null)
			{
				directRigidBody.AddTorque(influencedAxis * axisValue * speed);
			}
			else
			{
				UnityEngine.Debug.LogWarning("ETCAxis : " + name + " No rigidbody on gameobject : " + _directTransform.name);
			}
			break;
		case DirectAction.RelativeTorque:
			if (directRigidBody != null)
			{
				directRigidBody.AddRelativeTorque(influencedAxis * axisValue * speed);
			}
			else
			{
				UnityEngine.Debug.LogWarning("ETCAxis : " + name + " No rigidbody on gameobject : " + _directTransform.name);
			}
			break;
		case DirectAction.Jump:
			if (directCharacterController != null && !isJump)
			{
				isJump = true;
				currentGravity = speed;
			}
			break;
		}
		if (isClampRotation && directAction == DirectAction.RotateLocal)
		{
			DoAngleLimitation();
		}
	}

	public void DoGravity()
	{
		if (directCharacterController != null && gravity != 0f)
		{
			if (!isJump)
			{
				Vector3 vector = new Vector3(0f, 0f - gravity, 0f);
				directCharacterController.Move(vector * Time.deltaTime);
			}
			else
			{
				currentGravity -= gravity * Time.deltaTime;
				Vector3 vector2 = new Vector3(0f, currentGravity, 0f);
				directCharacterController.Move(vector2 * Time.deltaTime);
			}
			if (directCharacterController.isGrounded)
			{
				isJump = false;
				currentGravity = 0f;
			}
		}
	}

	private void ComputAxisValue(float realValue, ETCBase.ControlType type, bool isOnDrag, bool deltaTime)
	{
		if (enable)
		{
			if (type == ETCBase.ControlType.Joystick)
			{
				if (valueMethod == AxisValueMethod.Classical)
				{
					float num = Mathf.Max(Mathf.Abs(realValue), 0.001f);
					float num2 = Mathf.Max(num - deadValue, 0f) / (1f - deadValue) / num;
					realValue *= num2;
				}
				else
				{
					realValue = curveValue.Evaluate(realValue);
				}
			}
			if (isEnertia)
			{
				realValue -= axisValue;
				realValue /= inertia;
				axisValue += realValue;
				if (Mathf.Abs(axisValue) < inertiaThreshold && !isOnDrag)
				{
					axisValue = 0f;
				}
			}
			else if (!isValueOverTime || (isValueOverTime && realValue == 0f))
			{
				axisValue = realValue;
			}
			if (deltaTime)
			{
				axisSpeedValue = axisValue * speed * Time.deltaTime;
			}
			else
			{
				axisSpeedValue = axisValue * speed;
			}
		}
		else
		{
			axisValue = 0f;
			axisSpeedValue = 0f;
		}
	}

	private Vector3 GetInfluencedAxis()
	{
		Vector3 result = Vector3.zero;
		switch (axisInfluenced)
		{
		case AxisInfluenced.X:
			result = Vector3.right;
			break;
		case AxisInfluenced.Y:
			result = Vector3.up;
			break;
		case AxisInfluenced.Z:
			result = Vector3.forward;
			break;
		}
		return result;
	}

	private float GetAngle()
	{
		float num = 0f;
		if (_directTransform != null)
		{
			switch (axisInfluenced)
			{
			case AxisInfluenced.X:
				num = _directTransform.localRotation.eulerAngles.x;
				break;
			case AxisInfluenced.Y:
				num = _directTransform.localRotation.eulerAngles.y;
				break;
			case AxisInfluenced.Z:
				num = _directTransform.localRotation.eulerAngles.z;
				break;
			}
			if (num <= 360f && num >= 180f)
			{
				num -= 360f;
			}
		}
		return num;
	}

	private void DoAutoStabilisation()
	{
		float num = GetAngle();
		if (num <= 360f && num >= 180f)
		{
			num -= 360f;
		}
		if (num > startAngle - autoStabThreshold || num < startAngle + autoStabThreshold)
		{
			float num2 = 0f;
			Vector3 euler = Vector3.zero;
			if (num > startAngle - autoStabThreshold)
			{
				num2 = num + autoStabSpeed / 100f * Mathf.Abs(num - startAngle) * Time.deltaTime * -1f;
			}
			if (num < startAngle + autoStabThreshold)
			{
				num2 = num + autoStabSpeed / 100f * Mathf.Abs(num - startAngle) * Time.deltaTime;
			}
			switch (axisInfluenced)
			{
			case AxisInfluenced.X:
				euler = new Vector3(num2, _directTransform.localRotation.eulerAngles.y, _directTransform.localRotation.eulerAngles.z);
				break;
			case AxisInfluenced.Y:
				euler = new Vector3(_directTransform.localRotation.eulerAngles.x, num2, _directTransform.localRotation.eulerAngles.z);
				break;
			case AxisInfluenced.Z:
				euler = new Vector3(_directTransform.localRotation.eulerAngles.x, _directTransform.localRotation.eulerAngles.y, num2);
				break;
			}
			_directTransform.localRotation = Quaternion.Euler(euler);
		}
	}

	private void DoAngleLimitation()
	{
		Quaternion localRotation = _directTransform.localRotation;
		localRotation.x /= localRotation.w;
		localRotation.y /= localRotation.w;
		localRotation.z /= localRotation.w;
		localRotation.w = 1f;
		float num = 0f;
		switch (axisInfluenced)
		{
		case AxisInfluenced.X:
			num = 114.59156f * Mathf.Atan(localRotation.x);
			num = Mathf.Clamp(num, 0f - minAngle, maxAngle);
			localRotation.x = Mathf.Tan(MathF.PI / 360f * num);
			break;
		case AxisInfluenced.Y:
			num = 114.59156f * Mathf.Atan(localRotation.y);
			num = Mathf.Clamp(num, 0f - minAngle, maxAngle);
			localRotation.y = Mathf.Tan(MathF.PI / 360f * num);
			break;
		case AxisInfluenced.Z:
			num = 114.59156f * Mathf.Atan(localRotation.z);
			num = Mathf.Clamp(num, 0f - minAngle, maxAngle);
			localRotation.z = Mathf.Tan(MathF.PI / 360f * num);
			break;
		}
		_directTransform.localRotation = localRotation;
	}

	public void InitDeadCurve()
	{
		curveValue = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);
		curveValue.postWrapMode = WrapMode.PingPong;
		curveValue.preWrapMode = WrapMode.PingPong;
	}
}
[Serializable]
public abstract class ETCBase : MonoBehaviour
{
	public enum ControlType
	{
		Joystick,
		TouchPad,
		DPad,
		Button
	}

	public enum RectAnchor
	{
		UserDefined,
		BottomLeft,
		BottomCenter,
		BottonRight,
		CenterLeft,
		Center,
		CenterRight,
		TopLeft,
		TopCenter,
		TopRight
	}

	public enum DPadAxis
	{
		Two_Axis,
		Four_Axis
	}

	public enum CameraMode
	{
		Follow,
		SmoothFollow
	}

	public enum CameraTargetMode
	{
		UserDefined,
		LinkOnTag,
		FromDirectActionAxisX,
		FromDirectActionAxisY
	}

	protected RectTransform cachedRectTransform;

	protected Canvas cachedRootCanvas;

	public bool isUnregisterAtDisable;

	private bool visibleAtStart = true;

	private bool activatedAtStart = true;

	[SerializeField]
	protected RectAnchor _anchor;

	[SerializeField]
	protected Vector2 _anchorOffet;

	[SerializeField]
	protected bool _visible;

	[SerializeField]
	protected bool _activated;

	public bool enableCamera;

	public CameraMode cameraMode;

	public string camTargetTag = "Player";

	public bool autoLinkTagCam = true;

	public string autoCamTag = "MainCamera";

	public Transform cameraTransform;

	public CameraTargetMode cameraTargetMode;

	public bool enableWallDetection;

	public LayerMask wallLayer = 0;

	public Transform cameraLookAt;

	protected CharacterController cameraLookAtCC;

	public Vector3 followOffset = new Vector3(0f, 6f, -6f);

	public float followDistance = 10f;

	public float followHeight = 5f;

	public float followRotationDamping = 5f;

	public float followHeightDamping = 5f;

	public int pointId = -1;

	public bool enableKeySimulation;

	public bool allowSimulationStandalone;

	public bool visibleOnStandalone = true;

	public DPadAxis dPadAxisCount;

	public bool useFixedUpdate;

	private List<RaycastResult> uiRaycastResultCache = new List<RaycastResult>();

	private PointerEventData uiPointerEventData;

	private EventSystem uiEventSystem;

	public bool isOnDrag;

	public bool isSwipeIn;

	public bool isSwipeOut;

	public bool showPSInspector;

	public bool showSpriteInspector;

	public bool showEventInspector;

	public bool showBehaviourInspector;

	public bool showAxesInspector;

	public bool showTouchEventInspector;

	public bool showDownEventInspector;

	public bool showPressEventInspector;

	public bool showCameraInspector;

	public RectAnchor anchor
	{
		get
		{
			return _anchor;
		}
		set
		{
			if (value != _anchor)
			{
				_anchor = value;
				SetAnchorPosition();
			}
		}
	}

	public Vector2 anchorOffet
	{
		get
		{
			return _anchorOffet;
		}
		set
		{
			if (value != _anchorOffet)
			{
				_anchorOffet = value;
				SetAnchorPosition();
			}
		}
	}

	public bool visible
	{
		get
		{
			return _visible;
		}
		set
		{
			if (value != _visible)
			{
				_visible = value;
				SetVisible();
			}
		}
	}

	public bool activated
	{
		get
		{
			return _activated;
		}
		set
		{
			if (value != _activated)
			{
				_activated = value;
				SetActivated();
			}
		}
	}

	protected virtual void Awake()
	{
		cachedRectTransform = base.transform as RectTransform;
		cachedRootCanvas = base.transform.parent.GetComponent<Canvas>();
		if (!allowSimulationStandalone)
		{
			enableKeySimulation = false;
		}
		visibleAtStart = _visible;
		activatedAtStart = _activated;
		if (!isUnregisterAtDisable)
		{
			ETCInput.instance.RegisterControl(this);
		}
	}

	public virtual void Start()
	{
		if (enableCamera && autoLinkTagCam)
		{
			cameraTransform = null;
			GameObject gameObject = GameObject.FindGameObjectWithTag(autoCamTag);
			if ((bool)gameObject)
			{
				cameraTransform = gameObject.transform;
			}
		}
	}

	public virtual void OnEnable()
	{
		if (isUnregisterAtDisable)
		{
			ETCInput.instance.RegisterControl(this);
		}
		visible = visibleAtStart;
		activated = activatedAtStart;
	}

	private void OnDisable()
	{
		if ((bool)ETCInput._instance && isUnregisterAtDisable)
		{
			ETCInput.instance.UnRegisterControl(this);
		}
		visibleAtStart = _visible;
		activated = _activated;
		visible = false;
		activated = false;
	}

	private void OnDestroy()
	{
		if ((bool)ETCInput._instance)
		{
			ETCInput.instance.UnRegisterControl(this);
		}
	}

	public virtual void Update()
	{
		if (!useFixedUpdate)
		{
			StartCoroutine("UpdateVirtualControl");
		}
	}

	public virtual void FixedUpdate()
	{
		if (useFixedUpdate)
		{
			StartCoroutine("FixedUpdateVirtualControl");
		}
	}

	public virtual void LateUpdate()
	{
		if (!enableCamera)
		{
			return;
		}
		if (autoLinkTagCam && cameraTransform == null)
		{
			GameObject gameObject = GameObject.FindGameObjectWithTag(autoCamTag);
			if ((bool)gameObject)
			{
				cameraTransform = gameObject.transform;
			}
		}
		switch (cameraMode)
		{
		case CameraMode.Follow:
			CameraFollow();
			break;
		case CameraMode.SmoothFollow:
			CameraSmoothFollow();
			break;
		}
	}

	protected virtual void UpdateControlState()
	{
	}

	protected virtual void SetVisible(bool forceUnvisible = true)
	{
	}

	protected virtual void SetActivated()
	{
	}

	public void SetAnchorPosition()
	{
		switch (_anchor)
		{
		case RectAnchor.TopLeft:
			this.rectTransform().anchorMin = new Vector2(0f, 1f);
			this.rectTransform().anchorMax = new Vector2(0f, 1f);
			this.rectTransform().anchoredPosition = new Vector2(this.rectTransform().sizeDelta.x / 2f + _anchorOffet.x, (0f - this.rectTransform().sizeDelta.y) / 2f - _anchorOffet.y);
			break;
		case RectAnchor.TopCenter:
			this.rectTransform().anchorMin = new Vector2(0.5f, 1f);
			this.rectTransform().anchorMax = new Vector2(0.5f, 1f);
			this.rectTransform().anchoredPosition = new Vector2(_anchorOffet.x, (0f - this.rectTransform().sizeDelta.y) / 2f - _anchorOffet.y);
			break;
		case RectAnchor.TopRight:
			this.rectTransform().anchorMin = new Vector2(1f, 1f);
			this.rectTransform().anchorMax = new Vector2(1f, 1f);
			this.rectTransform().anchoredPosition = new Vector2((0f - this.rectTransform().sizeDelta.x) / 2f - _anchorOffet.x, (0f - this.rectTransform().sizeDelta.y) / 2f - _anchorOffet.y);
			break;
		case RectAnchor.CenterLeft:
			this.rectTransform().anchorMin = new Vector2(0f, 0.5f);
			this.rectTransform().anchorMax = new Vector2(0f, 0.5f);
			this.rectTransform().anchoredPosition = new Vector2(this.rectTransform().sizeDelta.x / 2f + _anchorOffet.x, _anchorOffet.y);
			break;
		case RectAnchor.Center:
			this.rectTransform().anchorMin = new Vector2(0.5f, 0.5f);
			this.rectTransform().anchorMax = new Vector2(0.5f, 0.5f);
			this.rectTransform().anchoredPosition = new Vector2(_anchorOffet.x, _anchorOffet.y);
			break;
		case RectAnchor.CenterRight:
			this.rectTransform().anchorMin = new Vector2(1f, 0.5f);
			this.rectTransform().anchorMax = new Vector2(1f, 0.5f);
			this.rectTransform().anchoredPosition = new Vector2((0f - this.rectTransform().sizeDelta.x) / 2f - _anchorOffet.x, _anchorOffet.y);
			break;
		case RectAnchor.BottomLeft:
			this.rectTransform().anchorMin = new Vector2(0f, 0f);
			this.rectTransform().anchorMax = new Vector2(0f, 0f);
			this.rectTransform().anchoredPosition = new Vector2(this.rectTransform().sizeDelta.x / 2f + _anchorOffet.x, this.rectTransform().sizeDelta.y / 2f + _anchorOffet.y);
			break;
		case RectAnchor.BottomCenter:
			this.rectTransform().anchorMin = new Vector2(0.5f, 0f);
			this.rectTransform().anchorMax = new Vector2(0.5f, 0f);
			this.rectTransform().anchoredPosition = new Vector2(_anchorOffet.x, this.rectTransform().sizeDelta.y / 2f + _anchorOffet.y);
			break;
		case RectAnchor.BottonRight:
			this.rectTransform().anchorMin = new Vector2(1f, 0f);
			this.rectTransform().anchorMax = new Vector2(1f, 0f);
			this.rectTransform().anchoredPosition = new Vector2((0f - this.rectTransform().sizeDelta.x) / 2f - _anchorOffet.x, this.rectTransform().sizeDelta.y / 2f + _anchorOffet.y);
			break;
		}
	}

	protected GameObject GetFirstUIElement(Vector2 position)
	{
		uiEventSystem = EventSystem.current;
		if (uiEventSystem != null)
		{
			uiPointerEventData = new PointerEventData(uiEventSystem);
			uiPointerEventData.position = position;
			uiEventSystem.RaycastAll(uiPointerEventData, uiRaycastResultCache);
			if (uiRaycastResultCache.Count > 0)
			{
				return uiRaycastResultCache[0].gameObject;
			}
			return null;
		}
		return null;
	}

	protected void CameraSmoothFollow()
	{
		if ((bool)cameraTransform && (bool)cameraLookAt)
		{
			float y = cameraLookAt.eulerAngles.y;
			float b = cameraLookAt.position.y + followHeight;
			float y2 = cameraTransform.eulerAngles.y;
			float y3 = cameraTransform.position.y;
			y2 = Mathf.LerpAngle(y2, y, followRotationDamping * Time.deltaTime);
			y3 = Mathf.Lerp(y3, b, followHeightDamping * Time.deltaTime);
			Quaternion quaternion = Quaternion.Euler(0f, y2, 0f);
			Vector3 position = cameraLookAt.position;
			position -= quaternion * Vector3.forward * followDistance;
			position = new Vector3(position.x, y3, position.z);
			if (enableWallDetection && Physics.Linecast(new Vector3(cameraLookAt.position.x, cameraLookAt.position.y + 1f, cameraLookAt.position.z), position, out var hitInfo))
			{
				position = new Vector3(hitInfo.point.x, y3, hitInfo.point.z);
			}
			cameraTransform.position = position;
			cameraTransform.LookAt(cameraLookAt);
		}
	}

	protected void CameraFollow()
	{
		if ((bool)cameraTransform && (bool)cameraLookAt)
		{
			Vector3 vector = followOffset;
			cameraTransform.position = cameraLookAt.position + vector;
			cameraTransform.LookAt(cameraLookAt.position);
		}
	}

	private IEnumerator UpdateVirtualControl()
	{
		DoActionBeforeEndOfFrame();
		yield return new WaitForEndOfFrame();
		UpdateControlState();
	}

	private IEnumerator FixedUpdateVirtualControl()
	{
		DoActionBeforeEndOfFrame();
		yield return new WaitForFixedUpdate();
		UpdateControlState();
	}

	protected virtual void DoActionBeforeEndOfFrame()
	{
	}
}
[Serializable]
public class ETCButton : ETCBase, IPointerEnterHandler, IEventSystemHandler, IPointerDownHandler, IPointerUpHandler, IPointerExitHandler
{
	[Serializable]
	public class OnDownHandler : UnityEvent
	{
	}

	[Serializable]
	public class OnPressedHandler : UnityEvent
	{
	}

	[Serializable]
	public class OnPressedValueandler : UnityEvent<float>
	{
	}

	[Serializable]
	public class OnUPHandler : UnityEvent
	{
	}

	[SerializeField]
	public OnDownHandler onDown;

	[SerializeField]
	public OnPressedHandler onPressed;

	[SerializeField]
	public OnPressedValueandler onPressedValue;

	[SerializeField]
	public OnUPHandler onUp;

	public ETCAxis axis;

	public Sprite normalSprite;

	public Color normalColor;

	public Sprite pressedSprite;

	public Color pressedColor;

	private Image cachedImage;

	private bool isOnPress;

	private GameObject previousDargObject;

	private bool isOnTouch;

	public ETCButton()
	{
		axis = new ETCAxis("Button");
		_visible = true;
		_activated = true;
		isOnTouch = false;
		enableKeySimulation = true;
		axis.unityAxis = "Jump";
		showPSInspector = true;
		showSpriteInspector = false;
		showBehaviourInspector = false;
		showEventInspector = false;
	}

	protected override void Awake()
	{
		base.Awake();
		cachedImage = GetComponent<Image>();
	}

	public override void Start()
	{
		axis.InitAxis();
		base.Start();
		isOnPress = false;
		if (allowSimulationStandalone && enableKeySimulation && !UnityEngine.Application.isEditor)
		{
			SetVisible(visibleOnStandalone);
		}
	}

	protected override void UpdateControlState()
	{
		UpdateButton();
	}

	protected override void DoActionBeforeEndOfFrame()
	{
		axis.DoGravity();
	}

	public void OnPointerEnter(PointerEventData eventData)
	{
		if (isSwipeIn && !isOnTouch)
		{
			if (eventData.pointerDrag != null && (bool)eventData.pointerDrag.GetComponent<ETCBase>() && eventData.pointerDrag != base.gameObject)
			{
				previousDargObject = eventData.pointerDrag;
			}
			eventData.pointerDrag = base.gameObject;
			eventData.pointerPress = base.gameObject;
			OnPointerDown(eventData);
		}
	}

	public void OnPointerDown(PointerEventData eventData)
	{
		if (_activated && !isOnTouch)
		{
			pointId = eventData.pointerId;
			axis.ResetAxis();
			axis.axisState = ETCAxis.AxisState.Down;
			isOnPress = false;
			isOnTouch = true;
			onDown.Invoke();
			ApllyState();
			axis.UpdateButton();
		}
	}

	public void OnPointerUp(PointerEventData eventData)
	{
		if (pointId == eventData.pointerId)
		{
			isOnPress = false;
			isOnTouch = false;
			axis.axisState = ETCAxis.AxisState.Up;
			axis.axisValue = 0f;
			onUp.Invoke();
			ApllyState();
			if ((bool)previousDargObject)
			{
				ExecuteEvents.Execute(previousDargObject, eventData, ExecuteEvents.pointerUpHandler);
				previousDargObject = null;
			}
		}
	}

	public void OnPointerExit(PointerEventData eventData)
	{
		if (pointId == eventData.pointerId && axis.axisState == ETCAxis.AxisState.Press && !isSwipeOut)
		{
			OnPointerUp(eventData);
		}
	}

	private void UpdateButton()
	{
		if (axis.axisState == ETCAxis.AxisState.Down)
		{
			isOnPress = true;
			axis.axisState = ETCAxis.AxisState.Press;
		}
		if (isOnPress)
		{
			axis.UpdateButton();
			onPressed.Invoke();
			onPressedValue.Invoke(axis.axisValue);
		}
		if (axis.axisState == ETCAxis.AxisState.Up)
		{
			isOnPress = false;
			axis.axisState = ETCAxis.AxisState.None;
		}
		if (enableKeySimulation && _activated && _visible && !isOnTouch)
		{
			if (Input.GetButton(axis.unityAxis) && axis.axisState == ETCAxis.AxisState.None)
			{
				axis.ResetAxis();
				onDown.Invoke();
				axis.axisState = ETCAxis.AxisState.Down;
			}
			if (!Input.GetButton(axis.unityAxis) && axis.axisState == ETCAxis.AxisState.Press)
			{
				axis.axisState = ETCAxis.AxisState.Up;
				axis.axisValue = 0f;
				onUp.Invoke();
			}
			axis.UpdateButton();
			ApllyState();
		}
	}

	protected override void SetVisible(bool forceUnvisible = false)
	{
		bool flag = _visible;
		if (!base.visible)
		{
			flag = base.visible;
		}
		GetComponent<Image>().enabled = flag;
	}

	private void ApllyState()
	{
		if ((bool)cachedImage)
		{
			ETCAxis.AxisState axisState = axis.axisState;
			if ((uint)(axisState - 1) <= 1u)
			{
				cachedImage.sprite = pressedSprite;
				cachedImage.color = pressedColor;
			}
			else
			{
				cachedImage.sprite = normalSprite;
				cachedImage.color = normalColor;
			}
		}
	}

	protected override void SetActivated()
	{
		if (!_activated)
		{
			isOnPress = false;
			isOnTouch = false;
			axis.axisState = ETCAxis.AxisState.None;
			axis.axisValue = 0f;
			ApllyState();
		}
	}
}
public class ETCDPad : ETCBase, IDragHandler, IEventSystemHandler, IPointerDownHandler, IPointerUpHandler
{
	[Serializable]
	public class OnMoveStartHandler : UnityEvent
	{
	}

	[Serializable]
	public class OnMoveHandler : UnityEvent<Vector2>
	{
	}

	[Serializable]
	public class OnMoveSpeedHandler : UnityEvent<Vector2>
	{
	}

	[Serializable]
	public class OnMoveEndHandler : UnityEvent
	{
	}

	[Serializable]
	public class OnTouchStartHandler : UnityEvent
	{
	}

	[Serializable]
	public class OnTouchUPHandler : UnityEvent
	{
	}

	[Serializable]
	public class OnDownUpHandler : UnityEvent
	{
	}

	[Serializable]
	public class OnDownDownHandler : UnityEvent
	{
	}

	[Serializable]
	public class OnDownLeftHandler : UnityEvent
	{
	}

	[Serializable]
	public class OnDownRightHandler : UnityEvent
	{
	}

	[Serializable]
	public class OnPressUpHandler : UnityEvent
	{
	}

	[Serializable]
	public class OnPressDownHandler : UnityEvent
	{
	}

	[Serializable]
	public class OnPressLeftHandler : UnityEvent
	{
	}

	[Serializable]
	public class OnPressRightHandler : UnityEvent
	{
	}

	[SerializeField]
	public OnMoveStartHandler onMoveStart;

	[SerializeField]
	public OnMoveHandler onMove;

	[SerializeField]
	public OnMoveSpeedHandler onMoveSpeed;

	[SerializeField]
	public OnMoveEndHandler onMoveEnd;

	[SerializeField]
	public OnTouchStartHandler onTouchStart;

	[SerializeField]
	public OnTouchUPHandler onTouchUp;

	[SerializeField]
	public OnDownUpHandler OnDownUp;

	[SerializeField]
	public OnDownDownHandler OnDownDown;

	[SerializeField]
	public OnDownLeftHandler OnDownLeft;

	[SerializeField]
	public OnDownRightHandler OnDownRight;

	[SerializeField]
	public OnDownUpHandler OnPressUp;

	[SerializeField]
	public OnDownDownHandler OnPressDown;

	[SerializeField]
	public OnDownLeftHandler OnPressLeft;

	[SerializeField]
	public OnDownRightHandler OnPressRight;

	public ETCAxis axisX;

	public ETCAxis axisY;

	public Sprite normalSprite;

	public Color normalColor;

	public Sprite pressedSprite;

	public Color pressedColor;

	private Vector2 tmpAxis;

	private Vector2 OldTmpAxis;

	private bool isOnTouch;

	private Image cachedImage;

	public float buttonSizeCoef = 3f;

	public ETCDPad()
	{
		axisX = new ETCAxis("Horizontal");
		axisY = new ETCAxis("Vertical");
		_visible = true;
		_activated = true;
		dPadAxisCount = DPadAxis.Two_Axis;
		tmpAxis = Vector2.zero;
		showPSInspector = true;
		showSpriteInspector = false;
		showBehaviourInspector = false;
		showEventInspector = false;
		isOnDrag = false;
		isOnTouch = false;
		axisX.unityAxis = "Horizontal";
		axisY.unityAxis = "Vertical";
		enableKeySimulation = true;
	}

	public override void Start()
	{
		base.Start();
		tmpAxis = Vector2.zero;
		OldTmpAxis = Vector2.zero;
		axisX.InitAxis();
		axisY.InitAxis();
		if (allowSimulationStandalone && enableKeySimulation && !UnityEngine.Application.isEditor)
		{
			SetVisible(visibleOnStandalone);
		}
	}

	protected override void UpdateControlState()
	{
		UpdateDPad();
	}

	protected override void DoActionBeforeEndOfFrame()
	{
		axisX.DoGravity();
		axisY.DoGravity();
	}

	public void OnPointerDown(PointerEventData eventData)
	{
		if (_activated && !isOnTouch)
		{
			onTouchStart.Invoke();
			GetTouchDirection(eventData.position, eventData.pressEventCamera);
			isOnTouch = true;
			isOnDrag = true;
			pointId = eventData.pointerId;
		}
	}

	public void OnDrag(PointerEventData eventData)
	{
		if (_activated && pointId == eventData.pointerId)
		{
			isOnTouch = true;
			isOnDrag = true;
			GetTouchDirection(eventData.position, eventData.pressEventCamera);
		}
	}

	public void OnPointerUp(PointerEventData eventData)
	{
		if (pointId == eventData.pointerId)
		{
			isOnTouch = false;
			isOnDrag = false;
			tmpAxis = Vector2.zero;
			OldTmpAxis = Vector2.zero;
			axisX.axisState = ETCAxis.AxisState.None;
			axisY.axisState = ETCAxis.AxisState.None;
			if (!axisX.isEnertia && !axisY.isEnertia)
			{
				axisX.ResetAxis();
				axisY.ResetAxis();
				onMoveEnd.Invoke();
			}
			pointId = -1;
			onTouchUp.Invoke();
		}
	}

	private void UpdateDPad()
	{
		if (enableKeySimulation && !isOnTouch && _activated && _visible)
		{
			float axis = Input.GetAxis(axisX.unityAxis);
			float axis2 = Input.GetAxis(axisY.unityAxis);
			isOnDrag = false;
			tmpAxis = Vector2.zero;
			if (axis != 0f)
			{
				isOnDrag = true;
				tmpAxis = new Vector2(1f * Mathf.Sign(axis), tmpAxis.y);
			}
			if (axis2 != 0f)
			{
				isOnDrag = true;
				tmpAxis = new Vector2(tmpAxis.x, 1f * Mathf.Sign(axis2));
			}
		}
		OldTmpAxis.x = axisX.axisValue;
		OldTmpAxis.y = axisY.axisValue;
		axisX.UpdateAxis(tmpAxis.x, isOnDrag, ControlType.DPad);
		axisY.UpdateAxis(tmpAxis.y, isOnDrag, ControlType.DPad);
		if ((axisX.axisValue != 0f || axisY.axisValue != 0f) && OldTmpAxis == Vector2.zero)
		{
			onMoveStart.Invoke();
		}
		if (axisX.axisValue != 0f || axisY.axisValue != 0f)
		{
			if (axisX.actionOn == ETCAxis.ActionOn.Down && (axisX.axisState == ETCAxis.AxisState.DownLeft || axisX.axisState == ETCAxis.AxisState.DownRight))
			{
				axisX.DoDirectAction();
			}
			else if (axisX.actionOn == ETCAxis.ActionOn.Press)
			{
				axisX.DoDirectAction();
			}
			if (axisY.actionOn == ETCAxis.ActionOn.Down && (axisY.axisState == ETCAxis.AxisState.DownUp || axisY.axisState == ETCAxis.AxisState.DownDown))
			{
				axisY.DoDirectAction();
			}
			else if (axisY.actionOn == ETCAxis.ActionOn.Press)
			{
				axisY.DoDirectAction();
			}
			onMove.Invoke(new Vector2(axisX.axisValue, axisY.axisValue));
			onMoveSpeed.Invoke(new Vector2(axisX.axisSpeedValue, axisY.axisSpeedValue));
		}
		else if (axisX.axisValue == 0f && axisY.axisValue == 0f && OldTmpAxis != Vector2.zero)
		{
			onMoveEnd.Invoke();
		}
		float num = 1f;
		if (axisX.invertedAxis)
		{
			num = -1f;
		}
		if (OldTmpAxis.x == 0f && Mathf.Abs(axisX.axisValue) > 0f)
		{
			if (axisX.axisValue * num > 0f)
			{
				axisX.axisState = ETCAxis.AxisState.DownRight;
				OnDownRight.Invoke();
			}
			else if (axisX.axisValue * num < 0f)
			{
				axisX.axisState = ETCAxis.AxisState.DownLeft;
				OnDownLeft.Invoke();
			}
			else
			{
				axisX.axisState = ETCAxis.AxisState.None;
			}
		}
		else if (axisX.axisState != 0)
		{
			if (axisX.axisValue * num > 0f)
			{
				axisX.axisState = ETCAxis.AxisState.PressRight;
				OnPressRight.Invoke();
			}
			else if (axisX.axisValue * num < 0f)
			{
				axisX.axisState = ETCAxis.AxisState.PressLeft;
				OnPressLeft.Invoke();
			}
			else
			{
				axisX.axisState = ETCAxis.AxisState.None;
			}
		}
		num = 1f;
		if (axisY.invertedAxis)
		{
			num = -1f;
		}
		if (OldTmpAxis.y == 0f && Mathf.Abs(axisY.axisValue) > 0f)
		{
			if (axisY.axisValue * num > 0f)
			{
				axisY.axisState = ETCAxis.AxisState.DownUp;
				OnDownUp.Invoke();
			}
			else if (axisY.axisValue * num < 0f)
			{
				axisY.axisState = ETCAxis.AxisState.DownDown;
				OnDownDown.Invoke();
			}
			else
			{
				axisY.axisState = ETCAxis.AxisState.None;
			}
		}
		else if (axisY.axisState != 0)
		{
			if (axisY.axisValue * num > 0f)
			{
				axisY.axisState = ETCAxis.AxisState.PressUp;
				OnPressUp.Invoke();
			}
			else if (axisY.axisValue * num < 0f)
			{
				axisY.axisState = ETCAxis.AxisState.PressDown;
				OnPressDown.Invoke();
			}
			else
			{
				axisY.axisState = ETCAxis.AxisState.None;
			}
		}
	}

	protected override void SetVisible(bool forceUnvisible = false)
	{
		bool flag = _visible;
		if (!base.visible)
		{
			flag = base.visible;
		}
		GetComponent<Image>().enabled = flag;
	}

	protected override void SetActivated()
	{
		if (!_activated)
		{
			isOnTouch = false;
			isOnDrag = false;
			tmpAxis = Vector2.zero;
			OldTmpAxis = Vector2.zero;
			axisX.axisState = ETCAxis.AxisState.None;
			axisY.axisState = ETCAxis.AxisState.None;
			if (!axisX.isEnertia && !axisY.isEnertia)
			{
				axisX.ResetAxis();
				axisY.ResetAxis();
			}
			pointId = -1;
		}
	}

	private void GetTouchDirection(Vector2 position, Camera cam)
	{
		RectTransformUtility.ScreenPointToLocalPointInRectangle(cachedRectTransform, position, cam, out var localPoint);
		Vector2 vector = this.rectTransform().sizeDelta / buttonSizeCoef;
		tmpAxis = Vector2.zero;
		if ((localPoint.x < (0f - vector.x) / 2f && localPoint.y > (0f - vector.y) / 2f && localPoint.y < vector.y / 2f && dPadAxisCount == DPadAxis.Two_Axis) || (dPadAxisCount == DPadAxis.Four_Axis && localPoint.x < (0f - vector.x) / 2f))
		{
			tmpAxis.x = -1f;
		}
		if ((localPoint.x > vector.x / 2f && localPoint.y > (0f - vector.y) / 2f && localPoint.y < vector.y / 2f && dPadAxisCount == DPadAxis.Two_Axis) || (dPadAxisCount == DPadAxis.Four_Axis && localPoint.x > vector.x / 2f))
		{
			tmpAxis.x = 1f;
		}
		if ((localPoint.y > vector.y / 2f && localPoint.x > (0f - vector.x) / 2f && localPoint.x < vector.x / 2f && dPadAxisCount == DPadAxis.Two_Axis) || (dPadAxisCount == DPadAxis.Four_Axis && localPoint.y > vector.y / 2f))
		{
			tmpAxis.y = 1f;
		}
		if ((localPoint.y < (0f - vector.y) / 2f && localPoint.x > (0f - vector.x) / 2f && localPoint.x < vector.x / 2f && dPadAxisCount == DPadAxis.Two_Axis) || (dPadAxisCount == DPadAxis.Four_Axis && localPoint.y < (0f - vector.y) / 2f))
		{
			tmpAxis.y = -1f;
		}
	}
}
public class ETCInput : MonoBehaviour
{
	public static ETCInput _instance;

	private Dictionary<string, ETCAxis> axes = new Dictionary<string, ETCAxis>();

	private Dictionary<string, ETCBase> controls = new Dictionary<string, ETCBase>();

	private static ETCBase control;

	private static ETCAxis axis;

	public static ETCInput instance
	{
		get
		{
			if (!_instance)
			{
				_instance = UnityEngine.Object.FindObjectOfType(typeof(ETCInput)) as ETCInput;
				if (!_instance)
				{
					_instance = new GameObject("InputManager").AddComponent<ETCInput>();
				}
			}
			return _instance;
		}
	}

	public void RegisterControl(ETCBase ctrl)
	{
		if (controls.ContainsKey(ctrl.name))
		{
			UnityEngine.Debug.LogWarning("ETCInput control : " + ctrl.name + " already exists");
			return;
		}
		controls.Add(ctrl.name, ctrl);
		if (ctrl.GetType() == typeof(ETCJoystick))
		{
			RegisterAxis((ctrl as ETCJoystick).axisX);
			RegisterAxis((ctrl as ETCJoystick).axisY);
		}
		else if (ctrl.GetType() == typeof(ETCTouchPad))
		{
			RegisterAxis((ctrl as ETCTouchPad).axisX);
			RegisterAxis((ctrl as ETCTouchPad).axisY);
		}
		else if (ctrl.GetType() == typeof(ETCDPad))
		{
			RegisterAxis((ctrl as ETCDPad).axisX);
			RegisterAxis((ctrl as ETCDPad).axisY);
		}
		else if (ctrl.GetType() == typeof(ETCButton))
		{
			RegisterAxis((ctrl as ETCButton).axis);
		}
	}

	public void UnRegisterControl(ETCBase ctrl)
	{
		if (controls.ContainsKey(ctrl.name) && ctrl.enabled)
		{
			controls.Remove(ctrl.name);
			if (ctrl.GetType() == typeof(ETCJoystick))
			{
				UnRegisterAxis((ctrl as ETCJoystick).axisX);
				UnRegisterAxis((ctrl as ETCJoystick).axisY);
			}
			else if (ctrl.GetType() == typeof(ETCTouchPad))
			{
				UnRegisterAxis((ctrl as ETCTouchPad).axisX);
				UnRegisterAxis((ctrl as ETCTouchPad).axisY);
			}
			else if (ctrl.GetType() == typeof(ETCDPad))
			{
				UnRegisterAxis((ctrl as ETCDPad).axisX);
				UnRegisterAxis((ctrl as ETCDPad).axisY);
			}
			else if (ctrl.GetType() == typeof(ETCButton))
			{
				UnRegisterAxis((ctrl as ETCButton).axis);
			}
		}
	}

	public void Create()
	{
	}

	public static void Register(ETCBase ctrl)
	{
		instance.RegisterControl(ctrl);
	}

	public static void UnRegister(ETCBase ctrl)
	{
		instance.UnRegisterControl(ctrl);
	}

	public static void SetControlVisible(string ctrlName, bool value)
	{
		if (instance.controls.TryGetValue(ctrlName, out control))
		{
			control.visible = value;
		}
		else
		{
			UnityEngine.Debug.LogWarning("ETCInput : " + ctrlName + " doesn't exist");
		}
	}

	public static bool GetControlVisible(string ctrlName)
	{
		if (instance.controls.TryGetValue(ctrlName, out control))
		{
			return control.visible;
		}
		UnityEngine.Debug.LogWarning("ETCInput : " + ctrlName + " doesn't exist");
		return false;
	}

	public static void SetControlActivated(string ctrlName, bool value)
	{
		if (instance.controls.TryGetValue(ctrlName, out control))
		{
			control.activated = value;
		}
		else
		{
			UnityEngine.Debug.LogWarning("ETCInput : " + ctrlName + " doesn't exist");
		}
	}

	public static bool GetControlActivated(string ctrlName)
	{
		if (instance.controls.TryGetValue(ctrlName, out control))
		{
			return control.activated;
		}
		UnityEngine.Debug.LogWarning("ETCInput : " + ctrlName + " doesn't exist");
		return false;
	}

	public static void SetControlSwipeIn(string ctrlName, bool value)
	{
		if (instance.controls.TryGetValue(ctrlName, out control))
		{
			control.isSwipeIn = value;
		}
		else
		{
			UnityEngine.Debug.LogWarning("ETCInput : " + ctrlName + " doesn't exist");
		}
	}

	public static bool GetControlSwipeIn(string ctrlName)
	{
		if (instance.controls.TryGetValue(ctrlName, out control))
		{
			return control.isSwipeIn;
		}
		UnityEngine.Debug.LogWarning("ETCInput : " + ctrlName + " doesn't exist");
		return false;
	}

	public static void SetControlSwipeOut(string ctrlName, bool value)
	{
		if (instance.controls.TryGetValue(ctrlName, out control))
		{
			control.isSwipeOut = value;
		}
		else
		{
			UnityEngine.Debug.LogWarning("ETCInput : " + ctrlName + " doesn't exist");
		}
	}

	public static bool GetControlSwipeOut(string ctrlName, bool value)
	{
		if (instance.controls.TryGetValue(ctrlName, out control))
		{
			return control.isSwipeOut;
		}
		UnityEngine.Debug.LogWarning("ETCInput : " + ctrlName + " doesn't exist");
		return false;
	}

	public static void SetDPadAxesCount(string ctrlName, ETCBase.DPadAxis value)
	{
		if (instance.controls.TryGetValue(ctrlName, out control))
		{
			control.dPadAxisCount = value;
		}
		else
		{
			UnityEngine.Debug.LogWarning("ETCInput : " + ctrlName + " doesn't exist");
		}
	}

	public static ETCBase.DPadAxis GetDPadAxesCount(string ctrlName)
	{
		if (instance.controls.TryGetValue(ctrlName, out control))
		{
			return control.dPadAxisCount;
		}
		UnityEngine.Debug.LogWarning("ETCInput : " + ctrlName + " doesn't exist");
		return ETCBase.DPadAxis.Two_Axis;
	}

	public static ETCJoystick GetControlJoystick(string ctrlName)
	{
		if (instance.controls.TryGetValue(ctrlName, out control) && control.GetType() == typeof(ETCJoystick))
		{
			return (ETCJoystick)control;
		}
		return null;
	}

	public static ETCDPad GetControlDPad(string ctrlName)
	{
		if (instance.controls.TryGetValue(ctrlName, out control) && control.GetType() == typeof(ETCDPad))
		{
			return (ETCDPad)control;
		}
		return null;
	}

	public static ETCTouchPad GetControlTouchPad(string ctrlName)
	{
		if (instance.controls.TryGetValue(ctrlName, out control) && control.GetType() == typeof(ETCTouchPad))
		{
			return (ETCTouchPad)control;
		}
		return null;
	}

	public static ETCButton GetControlButton(string ctrlName)
	{
		if (instance.controls.TryGetValue(ctrlName, out control) && control.GetType() == typeof(ETCJoystick))
		{
			return (ETCButton)control;
		}
		return null;
	}

	public static void SetControlSprite(string ctrlName, Sprite spr, Color color = default(Color))
	{
		if (instance.controls.TryGetValue(ctrlName, out control))
		{
			Image component = control.GetComponent<Image>();
			if ((bool)component)
			{
				component.sprite = spr;
				component.color = color;
			}
		}
	}

	public static void SetJoystickThumbSprite(string ctrlName, Sprite spr, Color color = default(Color))
	{
		if (!instance.controls.TryGetValue(ctrlName, out control) || !(control.GetType() == typeof(ETCJoystick)))
		{
			return;
		}
		ETCJoystick eTCJoystick = (ETCJoystick)control;
		if ((bool)eTCJoystick)
		{
			Image component = eTCJoystick.thumb.GetComponent<Image>();
			if ((bool)component)
			{
				component.sprite = spr;
				component.color = color;
			}
		}
	}

	public static void SetButtonPressedSprite(string ctrlName, Sprite spr, Color color = default(Color))
	{
	}

	public static void SetAxisSpeed(string axisName, float speed)
	{
		if (instance.axes.TryGetValue(axisName, out axis))
		{
			axis.speed = speed;
		}
		else
		{
			UnityEngine.Debug.LogWarning("ETCInput : " + axisName + " doesn't exist");
		}
	}

	public static void SetAxisGravity(string axisName, float gravity)
	{
		if (instance.axes.TryGetValue(axisName, out axis))
		{
			axis.gravity = gravity;
		}
		else
		{
			UnityEngine.Debug.LogWarning("ETCInput : " + axisName + " doesn't exist");
		}
	}

	public static void SetTurnMoveSpeed(string ctrlName, float speed)
	{
		ETCJoystick controlJoystick = GetControlJoystick(ctrlName);
		if ((bool)controlJoystick)
		{
			controlJoystick.tmSpeed = speed;
		}
	}

	public static void ResetAxis(string axisName)
	{
		if (instance.axes.TryGetValue(axisName, out axis))
		{
			axis.axisValue = 0f;
			axis.axisSpeedValue = 0f;
		}
		else
		{
			UnityEngine.Debug.LogWarning("ETCInput : " + axisName + " doesn't exist");
		}
	}

	public static void SetAxisEnabled(string axisName, bool value)
	{
		if (instance.axes.TryGetValue(axisName, out axis))
		{
			axis.enable = value;
		}
		else
		{
			UnityEngine.Debug.LogWarning("ETCInput : " + axisName + " doesn't exist");
		}
	}

	public static bool GetAxisEnabled(string axisName)
	{
		if (instance.axes.TryGetValue(axisName, out axis))
		{
			return axis.enable;
		}
		UnityEngine.Debug.LogWarning("ETCInput : " + axisName + " doesn't exist");
		return false;
	}

	public static void SetAxisInverted(string axisName, bool value)
	{
		if (instance.axes.TryGetValue(axisName, out axis))
		{
			axis.invertedAxis = value;
		}
		else
		{
			UnityEngine.Debug.LogWarning("ETCInput : " + axisName + " doesn't exist");
		}
	}

	public static bool GetAxisInverted(string axisName)
	{
		if (instance.axes.TryGetValue(axisName, out axis))
		{
			return axis.invertedAxis;
		}
		UnityEngine.Debug.LogWarning("ETCInput : " + axisName + " doesn't exist");
		return false;
	}

	public static void SetAxisDeadValue(string axisName, float value)
	{
		if (instance.axes.TryGetValue(axisName, out axis))
		{
			axis.deadValue = value;
		}
		else
		{
			UnityEngine.Debug.LogWarning("ETCInput : " + axisName + " doesn't exist");
		}
	}

	public static float GetAxisDeadValue(string axisName)
	{
		if (instance.axes.TryGetValue(axisName, out axis))
		{
			return axis.deadValue;
		}
		UnityEngine.Debug.LogWarning("ETCInput : " + axisName + " doesn't exist");
		return -1f;
	}

	public static void SetAxisSensitivity(string axisName, float value)
	{
		if (instance.axes.TryGetValue(axisName, out axis))
		{
			axis.speed = value;
		}
		else
		{
			UnityEngine.Debug.LogWarning("ETCInput : " + axisName + " doesn't exist");
		}
	}

	public static float GetAxisSensitivity(string axisName)
	{
		if (instance.axes.TryGetValue(axisName, out axis))
		{
			return axis.speed;
		}
		UnityEngine.Debug.LogWarning("ETCInput : " + axisName + " doesn't exist");
		return -1f;
	}

	public static void SetAxisThreshold(string axisName, float value)
	{
		if (instance.axes.TryGetValue(axisName, out axis))
		{
			axis.axisThreshold = value;
		}
		else
		{
			UnityEngine.Debug.LogWarning("ETCInput : " + axisName + " doesn't exist");
		}
	}

	public static float GetAxisThreshold(string axisName)
	{
		if (instance.axes.TryGetValue(axisName, out axis))
		{
			return axis.axisThreshold;
		}
		UnityEngine.Debug.LogWarning("ETCInput : " + axisName + " doesn't exist");
		return -1f;
	}

	public static void SetAxisInertia(string axisName, bool value)
	{
		if (instance.axes.TryGetValue(axisName, out axis))
		{
			axis.isEnertia = value;
		}
		else
		{
			UnityEngine.Debug.LogWarning("ETCInput : " + axisName + " doesn't exist");
		}
	}

	public static bool GetAxisInertia(string axisName)
	{
		if (instance.axes.TryGetValue(axisName, out axis))
		{
			return axis.isEnertia;
		}
		UnityEngine.Debug.LogWarning("ETCInput : " + axisName + " doesn't exist");
		return false;
	}

	public static void SetAxisInertiaSpeed(string axisName, float value)
	{
		if (instance.axes.TryGetValue(axisName, out axis))
		{
			axis.inertia = value;
		}
		else
		{
			UnityEngine.Debug.LogWarning("ETCInput : " + axisName + " doesn't exist");
		}
	}

	public static float GetAxisInertiaSpeed(string axisName)
	{
		if (instance.axes.TryGetValue(axisName, out axis))
		{
			return axis.inertia;
		}
		UnityEngine.Debug.LogWarning("ETCInput : " + axisName + " doesn't exist");
		return -1f;
	}

	public static void SetAxisInertiaThreshold(string axisName, float value)
	{
		if (instance.axes.TryGetValue(axisName, out axis))
		{
			axis.inertiaThreshold = value;
		}
		else
		{
			UnityEngine.Debug.LogWarning("ETCInput : " + axisName + " doesn't exist");
		}
	}

	public static float GetAxisInertiaThreshold(string axisName)
	{
		if (instance.axes.TryGetValue(axisName, out axis))
		{
			return axis.inertiaThreshold;
		}
		UnityEngine.Debug.LogWarning("ETCInput : " + axisName + " doesn't exist");
		return -1f;
	}

	public static void SetAxisAutoStabilization(string axisName, bool value)
	{
		if (instance.axes.TryGetValue(axisName, out axis))
		{
			axis.isAutoStab = value;
		}
		else
		{
			UnityEngine.Debug.LogWarning("ETCInput : " + axisName + " doesn't exist");
		}
	}

	public static bool GetAxisAutoStabilization(string axisName)
	{
		if (instance.axes.TryGetValue(axisName, out axis))
		{
			return axis.isAutoStab;
		}
		UnityEngine.Debug.LogWarning("ETCInput : " + axisName + " doesn't exist");
		return false;
	}

	public static void SetAxisAutoStabilizationSpeed(string axisName, float value)
	{
		if (instance.axes.TryGetValue(axisName, out axis))
		{
			axis.autoStabSpeed = value;
		}
		else
		{
			UnityEngine.Debug.LogWarning("ETCInput : " + axisName + " doesn't exist");
		}
	}

	public static float GetAxisAutoStabilizationSpeed(string axisName)
	{
		if (instance.axes.TryGetValue(axisName, out axis))
		{
			return axis.autoStabSpeed;
		}
		UnityEngine.Debug.LogWarning("ETCInput : " + axisName + " doesn't exist");
		return -1f;
	}

	public static void SetAxisAutoStabilizationThreshold(string axisName, float value)
	{
		if (instance.axes.TryGetValue(axisName, out axis))
		{
			axis.autoStabThreshold = value;
		}
		else
		{
			UnityEngine.Debug.LogWarning("ETCInput : " + axisName + " doesn't exist");
		}
	}

	public static float GetAxisAutoStabilizationThreshold(string axisName)
	{
		if (instance.axes.TryGetValue(axisName, out axis))
		{
			return axis.autoStabThreshold;
		}
		UnityEngine.Debug.LogWarning("ETCInput : " + axisName + " doesn't exist");
		return -1f;
	}

	public static void SetAxisClampRotation(string axisName, bool value)
	{
		if (instance.axes.TryGetValue(axisName, out axis))
		{
			axis.isClampRotation = value;
		}
		else
		{
			UnityEngine.Debug.LogWarning("ETCInput : " + axisName + " doesn't exist");
		}
	}

	public static bool GetAxisClampRotation(string axisName)
	{
		if (instance.axes.TryGetValue(axisName, out axis))
		{
			return axis.isClampRotation;
		}
		UnityEngine.Debug.LogWarning("ETCInput : " + axisName + " doesn't exist");
		return false;
	}

	public static void SetAxisClampRotationValue(string axisName, float min, float max)
	{
		if (instance.axes.TryGetValue(axisName, out axis))
		{
			axis.minAngle = min;
			axis.maxAngle = max;
		}
		else
		{
			UnityEngine.Debug.LogWarning("ETCInput : " + axisName + " doesn't exist");
		}
	}

	public static void SetAxisClampRotationMinValue(string axisName, float value)
	{
		if (instance.axes.TryGetValue(axisName, out axis))
		{
			axis.minAngle = value;
		}
		else
		{
			UnityEngine.Debug.LogWarning("ETCInput : " + axisName + " doesn't exist");
		}
	}

	public static void SetAxisClampRotationMaxValue(string axisName, float value)
	{
		if (instance.axes.TryGetValue(axisName, out axis))
		{
			axis.maxAngle = value;
		}
		else
		{
			UnityEngine.Debug.LogWarning("ETCInput : " + axisName + " doesn't exist");
		}
	}

	public static float GetAxisClampRotationMinValue(string axisName)
	{
		if (instance.axes.TryGetValue(axisName, out axis))
		{
			return axis.minAngle;
		}
		UnityEngine.Debug.LogWarning("ETCInput : " + axisName + " doesn't exist");
		return -1f;
	}

	public static float GetAxisClampRotationMaxValue(string axisName)
	{
		if (instance.axes.TryGetValue(axisName, out axis))
		{
			return axis.maxAngle;
		}
		UnityEngine.Debug.LogWarning("ETCInput : " + axisName + " doesn't exist");
		return -1f;
	}

	public static void SetAxisDirecTransform(string axisName, Transform value)
	{
		if (instance.axes.TryGetValue(axisName, out axis))
		{
			axis.directTransform = value;
		}
		else
		{
			UnityEngine.Debug.LogWarning("ETCInput : " + axisName + " doesn't exist");
		}
	}

	public static Transform GetAxisDirectTransform(string axisName)
	{
		if (instance.axes.TryGetValue(axisName, out axis))
		{
			return axis.directTransform;
		}
		UnityEngine.Debug.LogWarning("ETCInput : " + axisName + " doesn't exist");
		return null;
	}

	public static void SetAxisDirectAction(string axisName, ETCAxis.DirectAction value)
	{
		if (instance.axes.TryGetValue(axisName, out axis))
		{
			axis.directAction = value;
		}
		else
		{
			UnityEngine.Debug.LogWarning("ETCInput : " + axisName + " doesn't exist");
		}
	}

	public static ETCAxis.DirectAction GetAxisDirectAction(string axisName)
	{
		if (instance.axes.TryGetValue(axisName, out axis))
		{
			return axis.directAction;
		}
		UnityEngine.Debug.LogWarning("ETCInput : " + axisName + " doesn't exist");
		return ETCAxis.DirectAction.Rotate;
	}

	public static void SetAxisAffectedAxis(string axisName, ETCAxis.AxisInfluenced value)
	{
		if (instance.axes.TryGetValue(axisName, out axis))
		{
			axis.axisInfluenced = value;
		}
		else
		{
			UnityEngine.Debug.LogWarning("ETCInput : " + axisName + " doesn't exist");
		}
	}

	public static ETCAxis.AxisInfluenced GetAxisAffectedAxis(string axisName)
	{
		if (instance.axes.TryGetValue(axisName, out axis))
		{
			return axis.axisInfluenced;
		}
		UnityEngine.Debug.LogWarning("ETCInput : " + axisName + " doesn't exist");
		return ETCAxis.AxisInfluenced.X;
	}

	public static void SetAxisOverTime(string axisName, bool value)
	{
		if (instance.axes.TryGetValue(axisName, out axis))
		{
			axis.isValueOverTime = value;
		}
		else
		{
			UnityEngine.Debug.LogWarning("ETCInput : " + axisName + " doesn't exist");
		}
	}

	public static bool GetAxisOverTime(string axisName)
	{
		if (instance.axes.TryGetValue(axisName, out axis))
		{
			return axis.isValueOverTime;
		}
		UnityEngine.Debug.LogWarning("ETCInput : " + axisName + " doesn't exist");
		return false;
	}

	public static void SetAxisOverTimeStep(string axisName, float value)
	{
		if (instance.axes.TryGetValue(axisName, out axis))
		{
			axis.overTimeStep = value;
		}
		else
		{
			UnityEngine.Debug.LogWarning("ETCInput : " + axisName + " doesn't exist");
		}
	}

	public static float GetAxisOverTimeStep(string axisName)
	{
		if (instance.axes.TryGetValue(axisName, out axis))
		{
			return axis.overTimeStep;
		}
		UnityEngine.Debug.LogWarning("ETCInput : " + axisName + " doesn't exist");
		return -1f;
	}

	public static void SetAxisOverTimeMaxValue(string axisName, float value)
	{
		if (instance.axes.TryGetValue(axisName, out axis))
		{
			axis.maxOverTimeValue = value;
		}
		else
		{
			UnityEngine.Debug.LogWarning("ETCInput : " + axisName + " doesn't exist");
		}
	}

	public static float GetAxisOverTimeMaxValue(string axisName)
	{
		if (instance.axes.TryGetValue(axisName, out axis))
		{
			return axis.maxOverTimeValue;
		}
		UnityEngine.Debug.LogWarning("ETCInput : " + axisName + " doesn't exist");
		return -1f;
	}

	public static float GetAxis(string axisName)
	{
		if (instance.axes.TryGetValue(axisName, out axis))
		{
			return axis.axisValue;
		}
		UnityEngine.Debug.LogWarning("ETCInput : " + axisName + " doesn't exist");
		return 0f;
	}

	public static float GetAxisSpeed(string axisName)
	{
		if (instance.axes.TryGetValue(axisName, out axis))
		{
			return axis.axisSpeedValue;
		}
		UnityEngine.Debug.LogWarning(axisName + " doesn't exist");
		return 0f;
	}

	public static bool GetAxisDownUp(string axisName)
	{
		if (instance.axes.TryGetValue(axisName, out axis))
		{
			if (axis.axisState == ETCAxis.AxisState.DownUp)
			{
				return true;
			}
			return false;
		}
		UnityEngine.Debug.LogWarning(axisName + " doesn't exist");
		return false;
	}

	public static bool GetAxisDownDown(string axisName)
	{
		if (instance.axes.TryGetValue(axisName, out axis))
		{
			if (axis.axisState == ETCAxis.AxisState.DownDown)
			{
				return true;
			}
			return false;
		}
		UnityEngine.Debug.LogWarning(axisName + " doesn't exist");
		return false;
	}

	public static bool GetAxisDownRight(string axisName)
	{
		if (instance.axes.TryGetValue(axisName, out axis))
		{
			if (axis.axisState == ETCAxis.AxisState.DownRight)
			{
				return true;
			}
			return false;
		}
		UnityEngine.Debug.LogWarning(axisName + " doesn't exist");
		return false;
	}

	public static bool GetAxisDownLeft(string axisName)
	{
		if (instance.axes.TryGetValue(axisName, out axis))
		{
			if (axis.axisState == ETCAxis.AxisState.DownLeft)
			{
				return true;
			}
			return false;
		}
		UnityEngine.Debug.LogWarning(axisName + " doesn't exist");
		return false;
	}

	public static bool GetAxisPressedUp(string axisName)
	{
		if (instance.axes.TryGetValue(axisName, out axis))
		{
			if (axis.axisState == ETCAxis.AxisState.PressUp)
			{
				return true;
			}
			return false;
		}
		UnityEngine.Debug.LogWarning(axisName + " doesn't exist");
		return false;
	}

	public static bool GetAxisPressedDown(string axisName)
	{
		if (instance.axes.TryGetValue(axisName, out axis))
		{
			if (axis.axisState == ETCAxis.AxisState.PressDown)
			{
				return true;
			}
			return false;
		}
		UnityEngine.Debug.LogWarning(axisName + " doesn't exist");
		return false;
	}

	public static bool GetAxisPressedRight(string axisName)
	{
		if (instance.axes.TryGetValue(axisName, out axis))
		{
			if (axis.axisState == ETCAxis.AxisState.PressRight)
			{
				return true;
			}
			return false;
		}
		UnityEngine.Debug.LogWarning(axisName + " doesn't exist");
		return false;
	}

	public static bool GetAxisPressedLeft(string axisName)
	{
		if (instance.axes.TryGetValue(axisName, out axis))
		{
			if (axis.axisState == ETCAxis.AxisState.PressLeft)
			{
				return true;
			}
			return false;
		}
		UnityEngine.Debug.LogWarning(axisName + " doesn't exist");
		return false;
	}

	public static bool GetButtonDown(string buttonName)
	{
		if (instance.axes.TryGetValue(buttonName, out axis))
		{
			if (axis.axisState == ETCAxis.AxisState.Down)
			{
				return true;
			}
			return false;
		}
		return false;
	}

	public static bool GetButton(string buttonName)
	{
		if (instance.axes.TryGetValue(buttonName, out axis))
		{
			if (axis.axisState == ETCAxis.AxisState.Down || axis.axisState == ETCAxis.AxisState.Press)
			{
				return true;
			}
			return false;
		}
		UnityEngine.Debug.LogWarning(buttonName + " doesn't exist");
		return false;
	}

	public static bool GetButtonUp(string buttonName)
	{
		if (instance.axes.TryGetValue(buttonName, out axis))
		{
			if (axis.axisState == ETCAxis.AxisState.Up)
			{
				return true;
			}
			return false;
		}
		UnityEngine.Debug.LogWarning(buttonName + " doesn't exist");
		return false;
	}

	public static float GetButtonValue(string buttonName)
	{
		if (instance.axes.TryGetValue(buttonName, out axis))
		{
			return axis.axisValue;
		}
		UnityEngine.Debug.LogWarning(buttonName + " doesn't exist");
		return -1f;
	}

	private void RegisterAxis(ETCAxis axis)
	{
		if (instance.axes.ContainsKey(axis.name))
		{
			UnityEngine.Debug.LogWarning("ETCInput axis : " + axis.name + " already exists");
		}
		else
		{
			axes.Add(axis.name, axis);
		}
	}

	private void UnRegisterAxis(ETCAxis axis)
	{
		if (instance.axes.ContainsKey(axis.name))
		{
			axes.Remove(axis.name);
		}
	}
}
[Serializable]
public class ETCJoystick : ETCBase, IPointerEnterHandler, IEventSystemHandler, IDragHandler, IBeginDragHandler, IPointerDownHandler, IPointerUpHandler
{
	[Serializable]
	public class OnMoveStartHandler : UnityEvent
	{
	}

	[Serializable]
	public class OnMoveSpeedHandler : UnityEvent<Vector2>
	{
	}

	[Serializable]
	public class OnMoveHandler : UnityEvent<Vector2>
	{
	}

	[Serializable]
	public class OnMoveEndHandler : UnityEvent
	{
	}

	[Serializable]
	public class OnTouchStartHandler : UnityEvent
	{
	}

	[Serializable]
	public class OnTouchUpHandler : UnityEvent
	{
	}

	[Serializable]
	public class OnDownUpHandler : UnityEvent
	{
	}

	[Serializable]
	public class OnDownDownHandler : UnityEvent
	{
	}

	[Serializable]
	public class OnDownLeftHandler : UnityEvent
	{
	}

	[Serializable]
	public class OnDownRightHandler : UnityEvent
	{
	}

	[Serializable]
	public class OnPressUpHandler : UnityEvent
	{
	}

	[Serializable]
	public class OnPressDownHandler : UnityEvent
	{
	}

	[Serializable]
	public class OnPressLeftHandler : UnityEvent
	{
	}

	[Serializable]
	public class OnPressRightHandler : UnityEvent
	{
	}

	public enum JoystickArea
	{
		UserDefined,
		FullScreen,
		Left,
		Right,
		Top,
		Bottom,
		TopLeft,
		TopRight,
		BottomLeft,
		BottomRight
	}

	public enum JoystickType
	{
		Dynamic,
		Static
	}

	public enum RadiusBase
	{
		Width,
		Height,
		UserDefined
	}

	[SerializeField]
	public OnMoveStartHandler onMoveStart;

	[SerializeField]
	public OnMoveHandler onMove;

	[SerializeField]
	public OnMoveSpeedHandler onMoveSpeed;

	[SerializeField]
	public OnMoveEndHandler onMoveEnd;

	[SerializeField]
	public OnTouchStartHandler onTouchStart;

	[SerializeField]
	public OnTouchUpHandler onTouchUp;

	[SerializeField]
	public OnDownUpHandler OnDownUp;

	[SerializeField]
	public OnDownDownHandler OnDownDown;

	[SerializeField]
	public OnDownLeftHandler OnDownLeft;

	[SerializeField]
	public OnDownRightHandler OnDownRight;

	[SerializeField]
	public OnDownUpHandler OnPressUp;

	[SerializeField]
	public OnDownDownHandler OnPressDown;

	[SerializeField]
	public OnDownLeftHandler OnPressLeft;

	[SerializeField]
	public OnDownRightHandler OnPressRight;

	public JoystickType joystickType;

	public bool allowJoystickOverTouchPad;

	public RadiusBase radiusBase;

	public float radiusBaseValue;

	public ETCAxis axisX;

	public ETCAxis axisY;

	public RectTransform thumb;

	public JoystickArea joystickArea;

	public RectTransform userArea;

	public bool isTurnAndMove;

	public float tmSpeed = 10f;

	public float tmAdditionnalRotation;

	public AnimationCurve tmMoveCurve;

	public bool tmLockInJump;

	private Vector3 tmLastMove;

	private Vector2 thumbPosition;

	private bool isDynamicActif;

	private Vector2 tmpAxis;

	private Vector2 OldTmpAxis;

	private bool isOnTouch;

	[SerializeField]
	private bool isNoReturnThumb;

	private Vector2 noReturnPosition;

	private Vector2 noReturnOffset;

	[SerializeField]
	private bool isNoOffsetThumb;

	public bool _realVisible;

	public bool IsNoReturnThumb
	{
		get
		{
			return isNoReturnThumb;
		}
		set
		{
			isNoReturnThumb = value;
		}
	}

	public bool IsNoOffsetThumb
	{
		get
		{
			return isNoOffsetThumb;
		}
		set
		{
			isNoOffsetThumb = value;
		}
	}

	public bool RealVisible
	{
		get
		{
			return _realVisible;
		}
		set
		{
			_realVisible = value;
		}
	}

	public ETCJoystick()
	{
		joystickType = JoystickType.Static;
		allowJoystickOverTouchPad = false;
		radiusBase = RadiusBase.Width;
		axisX = new ETCAxis("Horizontal");
		axisY = new ETCAxis("Vertical");
		_visible = true;
		_activated = true;
		joystickArea = JoystickArea.FullScreen;
		isDynamicActif = false;
		isOnDrag = false;
		isOnTouch = false;
		axisX.unityAxis = "Horizontal";
		axisY.unityAxis = "Vertical";
		enableKeySimulation = true;
		isNoReturnThumb = false;
		showPSInspector = false;
		showAxesInspector = false;
		showEventInspector = false;
		showSpriteInspector = false;
	}

	protected override void Awake()
	{
		base.Awake();
		if (joystickType == JoystickType.Dynamic)
		{
			this.rectTransform().anchorMin = new Vector2(0.5f, 0.5f);
			this.rectTransform().anchorMax = new Vector2(0.5f, 0.5f);
			this.rectTransform().SetAsLastSibling();
			base.visible = false;
		}
		if (allowSimulationStandalone && enableKeySimulation && !UnityEngine.Application.isEditor && joystickType != 0)
		{
			SetVisible(visibleOnStandalone);
		}
	}

	public override void Start()
	{
		axisX.InitAxis();
		axisY.InitAxis();
		if (enableCamera)
		{
			InitCameraLookAt();
		}
		tmpAxis = Vector2.zero;
		OldTmpAxis = Vector2.zero;
		noReturnPosition = thumb.position;
		pointId = -1;
		if (joystickType == JoystickType.Dynamic)
		{
			base.visible = false;
		}
		base.Start();
		if (enableCamera && cameraMode == CameraMode.SmoothFollow && (bool)cameraTransform && (bool)cameraLookAt)
		{
			cameraTransform.position = cameraLookAt.TransformPoint(new Vector3(0f, followHeight, 0f - followDistance));
			cameraTransform.LookAt(cameraLookAt);
		}
		if (enableCamera && cameraMode == CameraMode.Follow && (bool)cameraTransform && (bool)cameraLookAt)
		{
			cameraTransform.position = cameraLookAt.position + followOffset;
			cameraTransform.LookAt(cameraLookAt.position);
		}
	}

	public override void Update()
	{
		base.Update();
		if (joystickType == JoystickType.Dynamic && !_visible && _activated)
		{
			Vector2 localPosition = Vector2.zero;
			Vector2 screenPosition = Vector2.zero;
			if (isTouchOverJoystickArea(ref localPosition, ref screenPosition))
			{
				GameObject firstUIElement = GetFirstUIElement(screenPosition);
				if (firstUIElement == null || (allowJoystickOverTouchPad && (bool)firstUIElement.GetComponent<ETCTouchPad>()) || (firstUIElement != null && (bool)firstUIElement.GetComponent<ETCArea>()))
				{
					cachedRectTransform.anchoredPosition = localPosition;
					base.visible = true;
				}
			}
		}
		if (joystickType == JoystickType.Dynamic && _visible && GetTouchCount() == 0)
		{
			base.visible = false;
		}
	}

	public override void LateUpdate()
	{
		if (enableCamera && !cameraLookAt)
		{
			InitCameraLookAt();
		}
		base.LateUpdate();
	}

	private void InitCameraLookAt()
	{
		if (cameraTargetMode == CameraTargetMode.FromDirectActionAxisX)
		{
			cameraLookAt = axisX.directTransform;
		}
		else if (cameraTargetMode == CameraTargetMode.FromDirectActionAxisY)
		{
			cameraLookAt = axisY.directTransform;
			if (isTurnAndMove)
			{
				cameraLookAt = axisX.directTransform;
			}
		}
		else if (cameraTargetMode == CameraTargetMode.LinkOnTag)
		{
			GameObject gameObject = GameObject.FindGameObjectWithTag(camTargetTag);
			if ((bool)gameObject)
			{
				cameraLookAt = gameObject.transform;
			}
		}
		if ((bool)cameraLookAt)
		{
			cameraLookAtCC = cameraLookAt.GetComponent<CharacterController>();
		}
	}

	protected override void UpdateControlState()
	{
		if (_visible)
		{
			_realVisible = _visible;
			UpdateJoystick();
			return;
		}
		_realVisible = false;
		if (joystickType == JoystickType.Dynamic)
		{
			OnUp(real: false);
		}
	}

	public void OnPointerEnter(PointerEventData eventData)
	{
		if (joystickType == JoystickType.Dynamic && !isDynamicActif && _activated && pointId == -1)
		{
			eventData.pointerDrag = base.gameObject;
			eventData.pointerPress = base.gameObject;
			isDynamicActif = true;
			pointId = eventData.pointerId;
		}
		if (joystickType == JoystickType.Dynamic && !eventData.eligibleForClick)
		{
			OnPointerUp(eventData);
		}
	}

	public void OnPointerDown(PointerEventData eventData)
	{
		onTouchStart.Invoke();
		pointId = eventData.pointerId;
		if (isNoOffsetThumb)
		{
			OnDrag(eventData);
		}
	}

	public void OnBeginDrag(PointerEventData eventData)
	{
	}

	public void OnDrag(PointerEventData eventData)
	{
		if (pointId != eventData.pointerId)
		{
			return;
		}
		isOnDrag = true;
		isOnTouch = true;
		float radius = GetRadius();
		if (!isNoReturnThumb)
		{
			thumbPosition = eventData.position - eventData.pressPosition;
		}
		else
		{
			thumbPosition = (eventData.position - noReturnPosition) / cachedRootCanvas.rectTransform().localScale.x + noReturnOffset;
		}
		if (isNoOffsetThumb)
		{
			thumbPosition = (eventData.position - (Vector2)cachedRectTransform.position) / cachedRootCanvas.rectTransform().localScale.x;
		}
		thumbPosition.x = Mathf.FloorToInt(thumbPosition.x);
		thumbPosition.y = Mathf.FloorToInt(thumbPosition.y);
		if (!axisX.enable)
		{
			thumbPosition.x = 0f;
		}
		if (!axisY.enable)
		{
			thumbPosition.y = 0f;
		}
		if (thumbPosition.magnitude > radius)
		{
			if (!isNoReturnThumb)
			{
				thumbPosition = thumbPosition.normalized * radius;
			}
			else
			{
				thumbPosition = thumbPosition.normalized * radius;
			}
		}
		thumb.anchoredPosition = thumbPosition;
	}

	public void OnPointerUp(PointerEventData eventData)
	{
		if (pointId == eventData.pointerId)
		{
			OnUp();
		}
	}

	private void OnUp(bool real = true)
	{
		isOnDrag = false;
		isOnTouch = false;
		if (isNoReturnThumb)
		{
			noReturnPosition = thumb.position;
			noReturnOffset = thumbPosition;
		}
		if (!isNoReturnThumb)
		{
			thumbPosition = Vector2.zero;
			thumb.anchoredPosition = Vector2.zero;
			axisX.axisState = ETCAxis.AxisState.None;
			axisY.axisState = ETCAxis.AxisState.None;
		}
		if (!axisX.isEnertia && !axisY.isEnertia)
		{
			axisX.ResetAxis();
			axisY.ResetAxis();
			tmpAxis = Vector2.zero;
			OldTmpAxis = Vector2.zero;
			if (real)
			{
				onMoveEnd.Invoke();
			}
		}
		if (joystickType == JoystickType.Dynamic)
		{
			base.visible = false;
			isDynamicActif = false;
		}
		pointId = -1;
		if (real)
		{
			onTouchUp.Invoke();
		}
	}

	protected override void DoActionBeforeEndOfFrame()
	{
		axisX.DoGravity();
		axisY.DoGravity();
	}

	private void UpdateJoystick()
	{
		if (enableKeySimulation && !isOnTouch && _activated && _visible)
		{
			float axis = Input.GetAxis(axisX.unityAxis);
			float axis2 = Input.GetAxis(axisY.unityAxis);
			if (!isNoReturnThumb)
			{
				thumb.localPosition = Vector2.zero;
			}
			isOnDrag = false;
			if (axis != 0f)
			{
				isOnDrag = true;
				thumb.localPosition = new Vector2(GetRadius() * axis, thumb.localPosition.y);
			}
			if (axis2 != 0f)
			{
				isOnDrag = true;
				thumb.localPosition = new Vector2(thumb.localPosition.x, GetRadius() * axis2);
			}
			thumbPosition = thumb.localPosition;
		}
		OldTmpAxis.x = axisX.axisValue;
		OldTmpAxis.y = axisY.axisValue;
		tmpAxis = thumbPosition / GetRadius();
		axisX.UpdateAxis(tmpAxis.x, isOnDrag, ControlType.Joystick);
		axisY.UpdateAxis(tmpAxis.y, isOnDrag, ControlType.Joystick);
		if ((axisX.axisValue != 0f || axisY.axisValue != 0f) && OldTmpAxis == Vector2.zero)
		{
			onMoveStart.Invoke();
		}
		if (axisX.axisValue != 0f || axisY.axisValue != 0f)
		{
			if (!isTurnAndMove)
			{
				if (axisX.actionOn == ETCAxis.ActionOn.Down && (axisX.axisState == ETCAxis.AxisState.DownLeft || axisX.axisState == ETCAxis.AxisState.DownRight))
				{
					axisX.DoDirectAction();
				}
				else if (axisX.actionOn == ETCAxis.ActionOn.Press)
				{
					axisX.DoDirectAction();
				}
				if (axisY.actionOn == ETCAxis.ActionOn.Down && (axisY.axisState == ETCAxis.AxisState.DownUp || axisY.axisState == ETCAxis.AxisState.DownDown))
				{
					axisY.DoDirectAction();
				}
				else if (axisY.actionOn == ETCAxis.ActionOn.Press)
				{
					axisY.DoDirectAction();
				}
			}
			else
			{
				DoTurnAndMove();
			}
			onMove.Invoke(new Vector2(axisX.axisValue, axisY.axisValue));
			onMoveSpeed.Invoke(new Vector2(axisX.axisSpeedValue, axisY.axisSpeedValue));
		}
		else if (axisX.axisValue == 0f && axisY.axisValue == 0f && OldTmpAxis != Vector2.zero)
		{
			onMoveEnd.Invoke();
		}
		if (!isTurnAndMove)
		{
			if (axisX.axisValue == 0f && (bool)axisX.directCharacterController && !axisX.directCharacterController.isGrounded && axisX.isLockinJump)
			{
				axisX.DoDirectAction();
			}
			if (axisY.axisValue == 0f && (bool)axisY.directCharacterController && !axisY.directCharacterController.isGrounded && axisY.isLockinJump)
			{
				axisY.DoDirectAction();
			}
		}
		else if (axisX.axisValue == 0f && axisY.axisValue == 0f && (bool)axisX.directCharacterController && !axisX.directCharacterController.isGrounded && tmLockInJump)
		{
			DoTurnAndMove();
		}
		float num = 1f;
		if (axisX.invertedAxis)
		{
			num = -1f;
		}
		if (Mathf.Abs(OldTmpAxis.x) < axisX.axisThreshold && Mathf.Abs(axisX.axisValue) >= axisX.axisThreshold)
		{
			UnityEngine.Debug.Log("ee");
			testes._instance.长宽高(Manager._instance.Down.当前选择);
			if (axisX.axisValue * num > 0f)
			{
				axisX.axisState = ETCAxis.AxisState.DownRight;
				OnDownRight.Invoke();
			}
			else if (axisX.axisValue * num < 0f)
			{
				axisX.axisState = ETCAxis.AxisState.DownLeft;
				OnDownLeft.Invoke();
			}
			else
			{
				axisX.axisState = ETCAxis.AxisState.None;
			}
		}
		else if (axisX.axisState != 0)
		{
			if (axisX.axisValue * num > 0f)
			{
				axisX.axisState = ETCAxis.AxisState.PressRight;
				OnPressRight.Invoke();
			}
			else if (axisX.axisValue * num < 0f)
			{
				axisX.axisState = ETCAxis.AxisState.PressLeft;
				OnPressLeft.Invoke();
			}
			else
			{
				axisX.axisState = ETCAxis.AxisState.None;
			}
		}
		num = 1f;
		if (axisY.invertedAxis)
		{
			num = -1f;
		}
		if (Mathf.Abs(OldTmpAxis.y) < axisY.axisThreshold && Mathf.Abs(axisY.axisValue) >= axisY.axisThreshold)
		{
			UnityEngine.Debug.Log("dee");
			testes._instance.长宽高(Manager._instance.Down.当前选择);
			if (axisY.axisValue * num > 0f)
			{
				axisY.axisState = ETCAxis.AxisState.DownUp;
				OnDownUp.Invoke();
			}
			else if (axisY.axisValue * num < 0f)
			{
				axisY.axisState = ETCAxis.AxisState.DownDown;
				OnDownDown.Invoke();
			}
			else
			{
				axisY.axisState = ETCAxis.AxisState.None;
			}
		}
		else if (axisY.axisState != 0)
		{
			if (axisY.axisValue * num > 0f)
			{
				axisY.axisState = ETCAxis.AxisState.PressUp;
				OnPressUp.Invoke();
			}
			else if (axisY.axisValue * num < 0f)
			{
				axisY.axisState = ETCAxis.AxisState.PressDown;
				OnPressDown.Invoke();
			}
			else
			{
				axisY.axisState = ETCAxis.AxisState.None;
			}
		}
	}

	private bool isTouchOverJoystickArea(ref Vector2 localPosition, ref Vector2 screenPosition)
	{
		bool flag = false;
		bool flag2 = false;
		screenPosition = Vector2.zero;
		int touchCount = GetTouchCount();
		for (int i = 0; i < touchCount; i++)
		{
			if (flag)
			{
				break;
			}
			if (Input.GetTouch(i).phase == UnityEngine.TouchPhase.Began)
			{
				screenPosition = Input.GetTouch(i).position;
				flag2 = true;
			}
			if (flag2 && isScreenPointOverArea(screenPosition, ref localPosition))
			{
				flag = true;
			}
		}
		return flag;
	}

	private bool isScreenPointOverArea(Vector2 screenPosition, ref Vector2 localPosition)
	{
		bool result = false;
		if (joystickArea != 0)
		{
			if (RectTransformUtility.ScreenPointToLocalPointInRectangle(cachedRootCanvas.rectTransform(), screenPosition, null, out localPosition))
			{
				switch (joystickArea)
				{
				case JoystickArea.Left:
					if (localPosition.x < 0f)
					{
						result = true;
					}
					break;
				case JoystickArea.Right:
					if (localPosition.x > 0f)
					{
						result = true;
					}
					break;
				case JoystickArea.FullScreen:
					result = true;
					break;
				case JoystickArea.TopLeft:
					if (localPosition.y > 0f && localPosition.x < 0f)
					{
						result = true;
					}
					break;
				case JoystickArea.Top:
					if (localPosition.y > 0f)
					{
						result = true;
					}
					break;
				case JoystickArea.TopRight:
					if (localPosition.y > 0f && localPosition.x > 0f)
					{
						result = true;
					}
					break;
				case JoystickArea.BottomLeft:
					if (localPosition.y < 0f && localPosition.x < 0f)
					{
						result = true;
					}
					break;
				case JoystickArea.Bottom:
					if (localPosition.y < 0f)
					{
						result = true;
					}
					break;
				case JoystickArea.BottomRight:
					if (localPosition.y < 0f && localPosition.x > 0f)
					{
						result = true;
					}
					break;
				}
			}
		}
		else if (RectTransformUtility.RectangleContainsScreenPoint(userArea, screenPosition, cachedRootCanvas.worldCamera))
		{
			RectTransformUtility.ScreenPointToLocalPointInRectangle(cachedRootCanvas.rectTransform(), screenPosition, cachedRootCanvas.worldCamera, out localPosition);
			result = true;
		}
		return result;
	}

	private int GetTouchCount()
	{
		return Input.touchCount;
	}

	public float GetRadius()
	{
		float result = 0f;
		switch (radiusBase)
		{
		case RadiusBase.Width:
			result = cachedRectTransform.sizeDelta.x * 0.5f;
			break;
		case RadiusBase.Height:
			result = cachedRectTransform.sizeDelta.y * 0.5f;
			break;
		case RadiusBase.UserDefined:
			result = radiusBaseValue;
			break;
		}
		return result;
	}

	protected override void SetActivated()
	{
		GetComponent<CanvasGroup>().blocksRaycasts = _activated;
		if (!_activated)
		{
			OnUp(real: false);
		}
	}

	protected override void SetVisible(bool visible = true)
	{
		bool flag = _visible;
		if (!visible)
		{
			flag = visible;
		}
		GetComponent<Image>().enabled = flag;
		thumb.GetComponent<Image>().enabled = flag;
		GetComponent<CanvasGroup>().blocksRaycasts = _activated;
	}

	private void DoTurnAndMove()
	{
		float num = Mathf.Atan2(axisX.axisValue, axisY.axisValue) * 57.29578f;
		float num2 = tmMoveCurve.Evaluate(new Vector2(axisX.axisValue, axisY.axisValue).magnitude) * tmSpeed;
		if (!(axisX.directTransform != null))
		{
			return;
		}
		axisX.directTransform.rotation = Quaternion.Euler(new Vector3(0f, num + tmAdditionnalRotation, 0f));
		if (axisX.directCharacterController != null)
		{
			if (axisX.directCharacterController.isGrounded || !tmLockInJump)
			{
				Vector3 vector = axisX.directCharacterController.transform.TransformDirection(Vector3.forward) * num2;
				axisX.directCharacterController.Move(vector * Time.deltaTime);
				tmLastMove = vector;
			}
			else
			{
				axisX.directCharacterController.Move(tmLastMove * Time.deltaTime);
			}
		}
		else
		{
			axisX.directTransform.Translate(Vector3.forward * num2 * Time.deltaTime, Space.Self);
		}
	}

	public void InitCurve()
	{
		axisX.InitDeadCurve();
		axisY.InitDeadCurve();
		InitTurnMoveCurve();
	}

	public void InitTurnMoveCurve()
	{
		tmMoveCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);
		tmMoveCurve.postWrapMode = WrapMode.PingPong;
		tmMoveCurve.preWrapMode = WrapMode.PingPong;
	}
}
[Serializable]
public class ETCTouchPad : ETCBase, IBeginDragHandler, IEventSystemHandler, IDragHandler, IPointerEnterHandler, IPointerDownHandler, IPointerUpHandler, IPointerExitHandler
{
	[Serializable]
	public class OnMoveStartHandler : UnityEvent
	{
	}

	[Serializable]
	public class OnMoveHandler : UnityEvent<Vector2>
	{
	}

	[Serializable]
	public class OnMoveSpeedHandler : UnityEvent<Vector2>
	{
	}

	[Serializable]
	public class OnMoveEndHandler : UnityEvent
	{
	}

	[Serializable]
	public class OnTouchStartHandler : UnityEvent
	{
	}

	[Serializable]
	public class OnTouchUPHandler : UnityEvent
	{
	}

	[Serializable]
	public class OnDownUpHandler : UnityEvent
	{
	}

	[Serializable]
	public class OnDownDownHandler : UnityEvent
	{
	}

	[Serializable]
	public class OnDownLeftHandler : UnityEvent
	{
	}

	[Serializable]
	public class OnDownRightHandler : UnityEvent
	{
	}

	[Serializable]
	public class OnPressUpHandler : UnityEvent
	{
	}

	[Serializable]
	public class OnPressDownHandler : UnityEvent
	{
	}

	[Serializable]
	public class OnPressLeftHandler : UnityEvent
	{
	}

	[Serializable]
	public class OnPressRightHandler : UnityEvent
	{
	}

	[SerializeField]
	public OnMoveStartHandler onMoveStart;

	[SerializeField]
	public OnMoveHandler onMove;

	[SerializeField]
	public OnMoveSpeedHandler onMoveSpeed;

	[SerializeField]
	public OnMoveEndHandler onMoveEnd;

	[SerializeField]
	public OnTouchStartHandler onTouchStart;

	[SerializeField]
	public OnTouchUPHandler onTouchUp;

	[SerializeField]
	public OnDownUpHandler OnDownUp;

	[SerializeField]
	public OnDownDownHandler OnDownDown;

	[SerializeField]
	public OnDownLeftHandler OnDownLeft;

	[SerializeField]
	public OnDownRightHandler OnDownRight;

	[SerializeField]
	public OnDownUpHandler OnPressUp;

	[SerializeField]
	public OnDownDownHandler OnPressDown;

	[SerializeField]
	public OnDownLeftHandler OnPressLeft;

	[SerializeField]
	public OnDownRightHandler OnPressRight;

	public ETCAxis axisX;

	public ETCAxis axisY;

	public bool isDPI;

	private Image cachedImage;

	private Vector2 tmpAxis;

	private Vector2 OldTmpAxis;

	private GameObject previousDargObject;

	private bool isOut;

	private bool isOnTouch;

	private bool cachedVisible;

	public ETCTouchPad()
	{
		axisX = new ETCAxis("Horizontal");
		axisX.speed = 1f;
		axisY = new ETCAxis("Vertical");
		axisY.speed = 1f;
		_visible = true;
		_activated = true;
		showPSInspector = true;
		showSpriteInspector = false;
		showBehaviourInspector = false;
		showEventInspector = false;
		tmpAxis = Vector2.zero;
		isOnDrag = false;
		isOnTouch = false;
		axisX.unityAxis = "Horizontal";
		axisY.unityAxis = "Vertical";
		enableKeySimulation = true;
		enableKeySimulation = false;
		isOut = false;
		axisX.axisState = ETCAxis.AxisState.None;
		useFixedUpdate = false;
		isDPI = false;
	}

	protected override void Awake()
	{
		base.Awake();
		cachedVisible = _visible;
		cachedImage = GetComponent<Image>();
	}

	public override void OnEnable()
	{
		base.OnEnable();
		if (!cachedVisible)
		{
			cachedImage.color = new Color(0f, 0f, 0f, 0f);
		}
		if (allowSimulationStandalone && enableKeySimulation && !UnityEngine.Application.isEditor)
		{
			SetVisible(visibleOnStandalone);
		}
	}

	public override void Start()
	{
		base.Start();
		tmpAxis = Vector2.zero;
		OldTmpAxis = Vector2.zero;
		axisX.InitAxis();
		axisY.InitAxis();
	}

	protected override void UpdateControlState()
	{
		UpdateTouchPad();
	}

	protected override void DoActionBeforeEndOfFrame()
	{
		axisX.DoGravity();
		axisY.DoGravity();
	}

	public void OnPointerEnter(PointerEventData eventData)
	{
		if (isSwipeIn && axisX.axisState == ETCAxis.AxisState.None && _activated && !isOnTouch)
		{
			if (eventData.pointerDrag != null && eventData.pointerDrag != base.gameObject)
			{
				previousDargObject = eventData.pointerDrag;
			}
			else if (eventData.pointerPress != null && eventData.pointerPress != base.gameObject)
			{
				previousDargObject = eventData.pointerPress;
			}
			eventData.pointerDrag = base.gameObject;
			eventData.pointerPress = base.gameObject;
			OnPointerDown(eventData);
		}
	}

	public void OnBeginDrag(PointerEventData eventData)
	{
		if (pointId == eventData.pointerId)
		{
			onMoveStart.Invoke();
		}
	}

	public void OnDrag(PointerEventData eventData)
	{
		if (base.activated && !isOut && pointId == eventData.pointerId)
		{
			isOnTouch = true;
			isOnDrag = true;
			if (isDPI)
			{
				tmpAxis = new Vector2(eventData.delta.x / UnityEngine.Screen.dpi * 100f, eventData.delta.y / UnityEngine.Screen.dpi * 100f);
			}
			else
			{
				tmpAxis = new Vector2(eventData.delta.x, eventData.delta.y);
			}
			if (!axisX.enable)
			{
				tmpAxis.x = 0f;
			}
			if (!axisY.enable)
			{
				tmpAxis.y = 0f;
			}
		}
	}

	public void OnPointerDown(PointerEventData eventData)
	{
		if (_activated && !isOnTouch)
		{
			axisX.axisState = ETCAxis.AxisState.Down;
			tmpAxis = eventData.delta;
			isOut = false;
			isOnTouch = true;
			pointId = eventData.pointerId;
			onTouchStart.Invoke();
		}
	}

	public void OnPointerUp(PointerEventData eventData)
	{
		if (pointId == eventData.pointerId)
		{
			isOnDrag = false;
			isOnTouch = false;
			tmpAxis = Vector2.zero;
			OldTmpAxis = Vector2.zero;
			axisX.axisState = ETCAxis.AxisState.None;
			axisY.axisState = ETCAxis.AxisState.None;
			if (!axisX.isEnertia && !axisY.isEnertia)
			{
				axisX.ResetAxis();
				axisY.ResetAxis();
				onMoveEnd.Invoke();
			}
			onTouchUp.Invoke();
			if ((bool)previousDargObject)
			{
				ExecuteEvents.Execute(previousDargObject, eventData, ExecuteEvents.pointerUpHandler);
				previousDargObject = null;
			}
			pointId = -1;
		}
	}

	public void OnPointerExit(PointerEventData eventData)
	{
		if (pointId == eventData.pointerId && !isSwipeOut)
		{
			isOut = true;
			OnPointerUp(eventData);
		}
	}

	private void UpdateTouchPad()
	{
		if (enableKeySimulation && !isOnTouch && _activated && _visible)
		{
			isOnDrag = false;
			tmpAxis = Vector2.zero;
			float axis = Input.GetAxis(axisX.unityAxis);
			float axis2 = Input.GetAxis(axisY.unityAxis);
			if (axis != 0f)
			{
				isOnDrag = true;
				tmpAxis = new Vector2(1f * Mathf.Sign(axis), tmpAxis.y);
			}
			if (axis2 != 0f)
			{
				isOnDrag = true;
				tmpAxis = new Vector2(tmpAxis.x, 1f * Mathf.Sign(axis2));
			}
		}
		OldTmpAxis.x = axisX.axisValue;
		OldTmpAxis.y = axisY.axisValue;
		axisX.UpdateAxis(tmpAxis.x, isOnDrag, ControlType.DPad);
		axisY.UpdateAxis(tmpAxis.y, isOnDrag, ControlType.DPad);
		if (axisX.axisValue != 0f || axisY.axisValue != 0f)
		{
			if (axisX.actionOn == ETCAxis.ActionOn.Down && (axisX.axisState == ETCAxis.AxisState.DownLeft || axisX.axisState == ETCAxis.AxisState.DownRight))
			{
				axisX.DoDirectAction();
			}
			else if (axisX.actionOn == ETCAxis.ActionOn.Press)
			{
				axisX.DoDirectAction();
			}
			if (axisY.actionOn == ETCAxis.ActionOn.Down && (axisY.axisState == ETCAxis.AxisState.DownUp || axisY.axisState == ETCAxis.AxisState.DownDown))
			{
				axisY.DoDirectAction();
			}
			else if (axisY.actionOn == ETCAxis.ActionOn.Press)
			{
				axisY.DoDirectAction();
			}
			onMove.Invoke(new Vector2(axisX.axisValue, axisY.axisValue));
			onMoveSpeed.Invoke(new Vector2(axisX.axisSpeedValue, axisY.axisSpeedValue));
		}
		else if (axisX.axisValue == 0f && axisY.axisValue == 0f && OldTmpAxis != Vector2.zero)
		{
			onMoveEnd.Invoke();
		}
		float num = 1f;
		if (axisX.invertedAxis)
		{
			num = -1f;
		}
		if (OldTmpAxis.x == 0f && Mathf.Abs(axisX.axisValue) > 0f)
		{
			if (axisX.axisValue * num > 0f)
			{
				axisX.axisState = ETCAxis.AxisState.DownRight;
				OnDownRight.Invoke();
			}
			else if (axisX.axisValue * num < 0f)
			{
				axisX.axisState = ETCAxis.AxisState.DownLeft;
				OnDownLeft.Invoke();
			}
			else
			{
				axisX.axisState = ETCAxis.AxisState.None;
			}
		}
		else if (axisX.axisState != 0)
		{
			if (axisX.axisValue * num > 0f)
			{
				axisX.axisState = ETCAxis.AxisState.PressRight;
				OnPressRight.Invoke();
			}
			else if (axisX.axisValue * num < 0f)
			{
				axisX.axisState = ETCAxis.AxisState.PressLeft;
				OnPressLeft.Invoke();
			}
			else
			{
				axisX.axisState = ETCAxis.AxisState.None;
			}
		}
		num = 1f;
		if (axisY.invertedAxis)
		{
			num = -1f;
		}
		if (OldTmpAxis.y == 0f && Mathf.Abs(axisY.axisValue) > 0f)
		{
			if (axisY.axisValue * num > 0f)
			{
				axisY.axisState = ETCAxis.AxisState.DownUp;
				OnDownUp.Invoke();
			}
			else if (axisY.axisValue * num < 0f)
			{
				axisY.axisState = ETCAxis.AxisState.DownDown;
				OnDownDown.Invoke();
			}
			else
			{
				axisY.axisState = ETCAxis.AxisState.None;
			}
		}
		else if (axisY.axisState != 0)
		{
			if (axisY.axisValue * num > 0f)
			{
				axisY.axisState = ETCAxis.AxisState.PressUp;
				OnPressUp.Invoke();
			}
			else if (axisY.axisValue * num < 0f)
			{
				axisY.axisState = ETCAxis.AxisState.PressDown;
				OnPressDown.Invoke();
			}
			else
			{
				axisY.axisState = ETCAxis.AxisState.None;
			}
		}
		tmpAxis = Vector2.zero;
	}

	protected override void SetVisible(bool forceUnvisible = false)
	{
		if (UnityEngine.Application.isPlaying)
		{
			if (!_visible)
			{
				cachedImage.color = new Color(0f, 0f, 0f, 0f);
			}
			else
			{
				cachedImage.color = new Color(1f, 1f, 1f, 1f);
			}
		}
	}

	protected override void SetActivated()
	{
		if (!_activated)
		{
			isOnDrag = false;
			isOnTouch = false;
			tmpAxis = Vector2.zero;
			OldTmpAxis = Vector2.zero;
			axisX.axisState = ETCAxis.AxisState.None;
			axisY.axisState = ETCAxis.AxisState.None;
			if (!axisX.isEnertia && !axisY.isEnertia)
			{
				axisX.ResetAxis();
				axisY.ResetAxis();
			}
			pointId = -1;
		}
	}
}
public class destory : MonoBehaviour
{
	public float xiaohuiwu;

	private void Start()
	{
		UnityEngine.Object.Destroy(base.gameObject, xiaohuiwu);
	}

	private void Update()
	{
	}
}
public class FCP_ExampleScript : MonoBehaviour
{
	public bool getStartingColorFromMaterial;

	public FlexibleColorPicker fcp;

	public Material material;

	private void Start()
	{
		if (getStartingColorFromMaterial)
		{
			fcp.color = material.color;
		}
		fcp.onColorChange.AddListener(OnChangeColor);
	}

	private void OnChangeColor(Color co)
	{
		material.color = co;
	}
}
[RequireComponent(typeof(FlexibleColorPicker))]
public class FCP_Persistence : MonoBehaviour
{
	public enum SaveStrategy
	{
		SessionOnly,
		File,
		PlayerPrefs
	}

	public string saveName = GenerateID();

	public SaveStrategy saveStrategy;

	private FlexibleColorPicker fcp;

	private static Dictionary<string, Color> savedColors;

	private static string saveFilePath;

	private static bool saveFileLoaded;

	private static bool saveFileOutdated;

	private void Awake()
	{
		fcp = GetComponent<FlexibleColorPicker>();
		InitStatic();
	}

	private void InitStatic()
	{
		if (saveFilePath == null)
		{
			saveFilePath = Path.Combine(UnityEngine.Application.persistentDataPath, "FCP_SavedColors.txt");
		}
		if (savedColors == null)
		{
			savedColors = new Dictionary<string, Color>();
		}
		if (!saveFileLoaded & (saveStrategy == SaveStrategy.File))
		{
			LoadDataFile();
			saveFileLoaded = true;
		}
	}

	private void OnDestroy()
	{
		if (saveFileOutdated & (saveStrategy == SaveStrategy.File))
		{
			SaveDataFile();
			saveFileOutdated = false;
		}
	}

	private void OnEnable()
	{
		if (savedColors == null)
		{
			InitStatic();
		}
		if (LoadColor(out var c))
		{
			fcp.color = c;
		}
	}

	private void OnDisable()
	{
		SaveColor(fcp.color);
	}

	private void LoadDataFile()
	{
		string[] array = File.ReadAllLines(saveFilePath);
		foreach (string text in array)
		{
			int num = text.LastIndexOf('#');
			if (num >= 0 && ColorUtility.TryParseHtmlString(text.Substring(num, text.Length - num), out var color))
			{
				savedColors.Add(text.Substring(0, num), color);
			}
		}
	}

	private void SaveDataFile()
	{
		string[] array = new string[savedColors.Count];
		int num = 0;
		foreach (KeyValuePair<string, Color> savedColor in savedColors)
		{
			array[num++] = savedColor.Key + "#" + ColorUtility.ToHtmlStringRGBA(savedColor.Value);
		}
		File.WriteAllText(saveFilePath, string.Join("\r\n", array));
	}

	public void SaveColor(Color c)
	{
		if (saveStrategy == SaveStrategy.PlayerPrefs)
		{
			PlayerPrefs.SetString("FCP_sc_" + saveName, "#" + ColorUtility.ToHtmlStringRGBA(c));
		}
		else if (savedColors.ContainsKey(saveName))
		{
			saveFileOutdated |= savedColors[saveName] != c;
			savedColors[saveName] = c;
		}
		else
		{
			savedColors.Add(saveName, c);
			saveFileOutdated = true;
		}
	}

	public bool LoadColor(out Color c)
	{
		c = Color.black;
		if (saveStrategy == SaveStrategy.PlayerPrefs)
		{
			string key = "FCP_sc_" + saveName;
			if (!PlayerPrefs.HasKey(key))
			{
				return false;
			}
			if (!ColorUtility.TryParseHtmlString(PlayerPrefs.GetString(key), out c))
			{
				return false;
			}
		}
		else
		{
			if (!savedColors.ContainsKey(saveName))
			{
				return false;
			}
			c = savedColors[saveName];
		}
		return true;
	}

	private static string GenerateID()
	{
		return Convert.ToBase64String(BitConverter.GetBytes(DateTime.Now.Ticks));
	}
}
[ExecuteInEditMode]
public class FCP_SpriteMeshEditor : MonoBehaviour
{
	public enum MeshType
	{
		CenterPoint,
		forward,
		backward
	}

	public int x;

	public int y;

	public MeshType meshType;

	public Sprite sprite;

	private int bufferedHash;

	private void Update()
	{
		int settingHash = GetSettingHash();
		if (settingHash != 0 && settingHash != bufferedHash)
		{
			MakeMesh(sprite, x, y, meshType);
			Image component = GetComponent<Image>();
			if ((bool)component)
			{
				component.useSpriteMesh = false;
				component.useSpriteMesh = true;
			}
			bufferedHash = settingHash;
		}
	}

	private int GetSettingHash()
	{
		if (sprite == null || x <= 0 || y <= 0)
		{
			return 0;
		}
		return sprite.GetHashCode() * (x ^ 0x88) * (y ^ 0x53E) * (int)((meshType + 1) ^ (MeshType)99999);
	}

	private void MakeMesh(Sprite sprite, int x, int y, MeshType meshtype)
	{
		bool flag = meshType == MeshType.CenterPoint;
		int num = x + 1;
		int num2 = y + 1;
		int num3 = num * num2;
		Vector2[] array;
		ushort[] array2;
		if (flag)
		{
			array = new Vector2[num3 + x * y];
			array2 = new ushort[x * y * 12];
		}
		else
		{
			array = new Vector2[num3];
			array2 = new ushort[x * y * 6];
		}
		for (int i = 0; i < num; i++)
		{
			float num4 = (float)i / (float)x;
			for (int j = 0; j < num2; j++)
			{
				float num5 = (float)j / (float)y;
				array[num * j + i] = new Vector2(num4, num5);
			}
		}
		if (flag)
		{
			for (int k = 0; k < x; k++)
			{
				float num6 = ((float)k + 0.5f) / (float)x;
				for (int l = 0; l < y; l++)
				{
					float num7 = ((float)l + 0.5f) / (float)y;
					array[l * x + k + num3] = new Vector2(num6, num7);
				}
			}
			for (int m = 0; m < x; m++)
			{
				for (int n = 0; n < y; n++)
				{
					int num8 = 12 * (n * x + m);
					int num9 = n * num + m;
					ushort num10 = (ushort)(n * x + m + num3);
					array2[num8 + 11] = (array2[num8] = (ushort)num9);
					array2[num8 + 3] = (array2[num8 + 2] = (ushort)(num9 + 1));
					array2[num8 + 6] = (array2[num8 + 5] = (ushort)(num9 + num + 1));
					array2[num8 + 9] = (array2[num8 + 8] = (ushort)(num9 + num));
					array2[num8 + 1] = (array2[num8 + 4] = (array2[num8 + 7] = (array2[num8 + 10] = num10)));
				}
			}
		}
		else if (meshtype == MeshType.forward)
		{
			for (int num11 = 0; num11 < x; num11++)
			{
				for (int num12 = 0; num12 < y; num12++)
				{
					int num13 = 6 * (num12 * x + num11);
					int num14 = num12 * num + num11;
					array2[num13 + 5] = (array2[num13 + 1] = (ushort)num14);
					array2[num13] = (ushort)(num14 + 1);
					array2[num13 + 4] = (array2[num13 + 2] = (ushort)(num14 + num + 1));
					array2[num13 + 3] = (ushort)(num14 + num);
				}
			}
		}
		else if (meshType == MeshType.backward)
		{
			for (int num15 = 0; num15 < x; num15++)
			{
				for (int num16 = 0; num16 < y; num16++)
				{
					int num17 = 6 * (num16 * x + num15);
					int num18 = num16 * num + num15;
					array2[num17] = (ushort)num18;
					array2[num17 + 4] = (array2[num17 + 2] = (ushort)(num18 + 1));
					array2[num17 + 3] = (ushort)(num18 + num + 1);
					array2[num17 + 5] = (array2[num17 + 1] = (ushort)(num18 + num));
				}
			}
		}
		sprite.OverrideGeometry(array, array2);
	}
}
public class FlexibleColorPicker : MonoBehaviour
{
	[Serializable]
	private struct Picker
	{
		public Image image;

		public Sprite dynamicSprite;

		public Sprite staticSpriteHor;

		public Sprite staticSpriteVer;

		public Material dynamicMaterial;
	}

	private enum PickerType
	{
		Main,
		R,
		G,
		B,
		H,
		S,
		V,
		A,
		Preview,
		PreviewAlpha
	}

	public enum MainPickingMode
	{
		HS,
		HV,
		SH,
		SV,
		VH,
		VS
	}

	[Serializable]
	public class ColorUpdateEvent : UnityEvent<Color>
	{
	}

	[Serializable]
	public class AdvancedSettings
	{
		[Serializable]
		public class PSettings
		{
			[Tooltip("Value can be used to restrict slider range")]
			public Vector2 range = new Vector2(0f, 1f);

			[Tooltip("Make the picker associated with this value act static, even in a dynamic color picker setup")]
			public bool overrideStatic;
		}

		public bool mainStatic = true;

		public PSettings r;

		public PSettings g;

		public PSettings b;

		public PSettings h;

		public PSettings s;

		public PSettings v;

		public PSettings a;

		public PSettings Get(int i)
		{
			if (i <= 0 || i > 7)
			{
				return new PSettings();
			}
			return (new PSettings[7] { r, g, b, h, s, v, a })[i - 1];
		}
	}

	[Serializable]
	private class BufferedColor
	{
		public Color color;

		private float bufferedHue;

		private float bufferedSaturation;

		public float r => color.r;

		public float g => color.g;

		public float b => color.b;

		public float a => color.a;

		public float h => bufferedHue;

		public float s => bufferedSaturation;

		public float v => RGBToHSV(color).z;

		public BufferedColor()
		{
			bufferedHue = 0f;
			bufferedSaturation = 0f;
			color = Color.black;
		}

		public BufferedColor(Color color)
			: this()
		{
			Set(color);
		}

		public BufferedColor(Color color, float hue, float sat)
			: this(color)
		{
			bufferedHue = hue;
			bufferedSaturation = sat;
		}

		public BufferedColor(Color color, BufferedColor source)
			: this(color, source.bufferedHue, source.bufferedSaturation)
		{
			Set(color);
		}

		public void Set(Color color)
		{
			Set(color, bufferedHue, bufferedSaturation);
		}

		public void Set(Color color, float bufferedHue, float bufferedSaturation)
		{
			this.color = color;
			Vector3 vector = RGBToHSV(color);
			if (vector.y == 0f || vector.z == 0f)
			{
				this.bufferedHue = bufferedHue;
			}
			else
			{
				this.bufferedHue = vector.x;
			}
			if (vector.z == 0f)
			{
				this.bufferedSaturation = bufferedSaturation;
			}
			else
			{
				this.bufferedSaturation = vector.y;
			}
		}

		public BufferedColor PickR(float value)
		{
			Color color = this.color;
			color.r = value;
			return new BufferedColor(color, this);
		}

		public BufferedColor PickG(float value)
		{
			Color color = this.color;
			color.g = value;
			return new BufferedColor(color, this);
		}

		public BufferedColor PickB(float value)
		{
			Color color = this.color;
			color.b = value;
			return new BufferedColor(color, this);
		}

		public BufferedColor PickA(float value)
		{
			Color color = this.color;
			color.a = value;
			return new BufferedColor(color, this);
		}

		public BufferedColor PickH(float value)
		{
			Vector3 vector = RGBToHSV(this.color);
			Color color = HSVToRGB(value, vector.y, vector.z);
			color.a = this.color.a;
			return new BufferedColor(color, value, bufferedSaturation);
		}

		public BufferedColor PickS(float value)
		{
			Vector3 vector = RGBToHSV(this.color);
			Color color = HSVToRGB(bufferedHue, value, vector.z);
			color.a = this.color.a;
			return new BufferedColor(color, bufferedHue, value);
		}

		public BufferedColor PickV(float value)
		{
			Color color = HSVToRGB(bufferedHue, bufferedSaturation, value);
			color.a = this.color.a;
			return new BufferedColor(color, bufferedHue, bufferedSaturation);
		}
	}

	[Tooltip("Connections to the FCP's picker images, this should not be adjusted unless in advanced use cases.")]
	[SerializeField]
	private Picker[] pickers;

	[Tooltip("Connection to the FCP's hexadecimal input field.")]
	[SerializeField]
	private InputField hexInput;

	[Tooltip("Connection to the FCP's mode dropdown menu.")]
	[SerializeField]
	private Dropdown modeDropdown;

	private Canvas canvas;

	[Tooltip("The (starting) 2D picking mode, i.e. the 2 color values that can be picked with the large square picker.")]
	[SerializeField]
	private MainPickingMode mode;

	[Tooltip("Sprites to be used in static mode on the main picker, one for each 2D mode.")]
	[SerializeField]
	private Sprite[] staticSpriteMain;

	private BufferedColor bufferedColor;

	private Picker focusedPicker;

	private PickerType focusedPickerType;

	private MainPickingMode lastUpdatedMode;

	private bool typeUpdate;

	private bool triggeredStaticMode;

	private bool materialsSeperated;

	[Tooltip("Color set to the color picker on Start(). If you wish to set a starting color via script please used the standard color parameter of the FCP in stead.")]
	[SerializeField]
	private Color startingColor = Color.white;

	[Tooltip("Use static mode: picker images are replaced by static images in stead of adaptive Unity shaders.")]
	public bool staticMode;

	[Tooltip("Make sure FCP seperates its picker materials so that the dynamic mode works consistently, even when multiple FPCs are active at the same time. Turning this off yields a slight performance boost.")]
	public bool multiInstance = true;

	public ColorUpdateEvent onColorChange;

	private const float HUE_LOOP = 5.9999f;

	private const string SHADER_MODE = "_Mode";

	private const string SHADER_C1 = "_Color1";

	private const string SHADER_C2 = "_Color2";

	private const string SHADER_DOUBLE_MODE = "_DoubleMode";

	private const string SHADER_HSV = "_HSV";

	private const string SHADER_HSV_MIN = "_HSV_MIN";

	private const string SHADER_HSV_MAX = "_HSV_MAX";

	[Tooltip("More specific settings for color picker. Changes are not applied immediately, but require an FCP update to trigger.")]
	public AdvancedSettings advancedSettings;

	private AdvancedSettings avs => advancedSettings;

	public Color color
	{
		get
		{
			if (bufferedColor == null)
			{
				return startingColor;
			}
			return bufferedColor.color;
		}
		set
		{
			if (bufferedColor == null)
			{
				startingColor = value;
				return;
			}
			bufferedColor.Set(value);
			UpdateMarkers();
			UpdateTextures();
			UpdateHex();
			typeUpdate = true;
			onColorChange.Invoke(value);
		}
	}

	public Color GetColor()
	{
		return color;
	}

	public void SetColor(Color color)
	{
		this.color = color;
	}

	public Color GetColorFullAlpha()
	{
		Color result = color;
		result.a = 1f;
		return result;
	}

	public void SetColorNoAlpha(Color color)
	{
		color.a = this.color.a;
		this.color = color;
	}

	private void Awake()
	{
		canvas = GetComponentInParent<Canvas>();
	}

	private void OnEnable()
	{
		if (bufferedColor == null)
		{
			bufferedColor = new BufferedColor(startingColor);
		}
		if (multiInstance && !materialsSeperated)
		{
			SeperateMaterials();
			materialsSeperated = true;
		}
		triggeredStaticMode = staticMode;
		UpdateTextures();
		MakeModeOptions();
		UpdateMarkers();
		UpdateHex();
		onColorChange.Invoke(startingColor);
	}

	private void Update()
	{
		typeUpdate = false;
		if (lastUpdatedMode != mode)
		{
			ChangeMode(mode);
		}
		if (staticMode != triggeredStaticMode)
		{
			UpdateTextures();
			triggeredStaticMode = staticMode;
		}
		if (multiInstance && !materialsSeperated)
		{
			SeperateMaterials();
			materialsSeperated = true;
		}
	}

	public void SetPointerFocus(int i)
	{
		if (i < 0 || i >= pickers.Length)
		{
			PickerType pickerType = (PickerType)i;
			UnityEngine.Debug.LogWarning("No picker image available of type " + pickerType.ToString() + ". Did you assign all the picker images in the editor?");
		}
		else
		{
			focusedPicker = pickers[i];
		}
		focusedPickerType = (PickerType)i;
	}

	public void PointerUpdate(BaseEventData e)
	{
		Vector2 normalizedPointerPosition = GetNormalizedPointerPosition(canvas, focusedPicker.image.rectTransform, e);
		bufferedColor = PickColor(bufferedColor, focusedPickerType, normalizedPointerPosition);
		UpdateMarkers();
		UpdateTextures();
		typeUpdate = true;
		UpdateHex();
		onColorChange.Invoke(bufferedColor.color);
	}

	public void TypeHex(string input)
	{
		TypeHex(input, finish: false);
		UpdateTextures();
		UpdateMarkers();
	}

	public void FinishTypeHex(string input)
	{
		TypeHex(input, finish: true);
		UpdateTextures();
		UpdateMarkers();
	}

	public void ChangeMode(int newMode)
	{
		ChangeMode((MainPickingMode)newMode);
	}

	public void ChangeMode(MainPickingMode mode)
	{
		this.mode = mode;
		triggeredStaticMode = false;
		UpdateTextures();
		UpdateMarkers();
		UpdateMode(mode);
	}

	private void SeperateMaterials()
	{
		for (int i = 0; i < pickers.Length; i++)
		{
			Picker picker = pickers[i];
			if (IsPickerAvailable(i) & (picker.dynamicMaterial != null))
			{
				Material material = (picker.dynamicMaterial = new Material(picker.dynamicMaterial));
				pickers[i] = picker;
				if (!staticMode)
				{
					picker.image.material = material;
				}
			}
		}
	}

	public void ShiftColor(int type, float delta)
	{
		float value = GetValue1D((PickerType)type) + delta;
		bufferedColor = PickColor1D(bufferedColor, (PickerType)type, value);
		UpdateMarkers();
		UpdateTextures();
		typeUpdate = true;
		UpdateHex();
		onColorChange.Invoke(bufferedColor.color);
	}

	public void ShiftHue(float delta)
	{
		PickerType type = PickerType.H;
		float value = Mathf.Repeat(GetValue1D(type) + delta, 6f) / 6f;
		bufferedColor = PickColor1D(bufferedColor, type, value);
		UpdateMarkers();
		UpdateTextures();
		typeUpdate = true;
		UpdateHex();
		onColorChange.Invoke(bufferedColor.color);
	}

	private BufferedColor PickColor(BufferedColor color, PickerType type, Vector2 v)
	{
		switch (type)
		{
		case PickerType.Main:
			return PickColorMain(color, v);
		case PickerType.Preview:
		case PickerType.PreviewAlpha:
			return color;
		default:
			return PickColor1D(color, type, v);
		}
	}

	private BufferedColor PickColorMain(BufferedColor color, Vector2 v)
	{
		return PickColorMain(color, mode, v);
	}

	private BufferedColor PickColor1D(BufferedColor color, PickerType type, Vector2 v)
	{
		float value = (IsHorizontal(pickers[(int)type]) ? v.x : v.y);
		return PickColor1D(color, type, value);
	}

	private BufferedColor PickColorMain(BufferedColor color, MainPickingMode mode, Vector2 v)
	{
		return mode switch
		{
			MainPickingMode.HS => PickColor2D(color, PickerType.H, v.x, PickerType.S, v.y), 
			MainPickingMode.HV => PickColor2D(color, PickerType.H, v.x, PickerType.V, v.y), 
			MainPickingMode.SH => PickColor2D(color, PickerType.S, v.x, PickerType.H, v.y), 
			MainPickingMode.SV => PickColor2D(color, PickerType.S, v.x, PickerType.V, v.y), 
			MainPickingMode.VH => PickColor2D(color, PickerType.V, v.x, PickerType.H, v.y), 
			MainPickingMode.VS => PickColor2D(color, PickerType.V, v.x, PickerType.S, v.y), 
			_ => bufferedColor, 
		};
	}

	private BufferedColor PickColor2D(BufferedColor color, PickerType type1, float value1, PickerType type2, float value2)
	{
		color = PickColor1D(color, type1, value1);
		color = PickColor1D(color, type2, value2);
		return color;
	}

	private BufferedColor PickColor1D(BufferedColor color, PickerType type, float value)
	{
		AdvancedSettings.PSettings pSettings = avs.Get((int)type);
		value = Mathf.Lerp(pSettings.range.x, pSettings.range.y, value);
		return type switch
		{
			PickerType.R => color.PickR(value), 
			PickerType.G => color.PickG(value), 
			PickerType.B => color.PickB(value), 
			PickerType.H => color.PickH(value * 5.9999f), 
			PickerType.S => color.PickS(value), 
			PickerType.V => color.PickV(value), 
			PickerType.A => color.PickA(value), 
			_ => throw new Exception("Picker type " + type.ToString() + " is not associated with a single color value."), 
		};
	}

	private void UpdateMarkers()
	{
		for (int i = 0; i < pickers.Length; i++)
		{
			if (IsPickerAvailable(i))
			{
				PickerType type = (PickerType)i;
				Vector2 value = GetValue(type);
				UpdateMarker(pickers[i], type, value);
			}
		}
	}

	private void UpdateMarker(Picker picker, PickerType type, Vector2 v)
	{
		switch (type)
		{
		case PickerType.Main:
			SetMarker(picker.image, v, setX: true, setY: true);
			break;
		default:
		{
			bool flag = IsHorizontal(picker);
			SetMarker(picker.image, v, flag, !flag);
			break;
		}
		case PickerType.Preview:
		case PickerType.PreviewAlpha:
			break;
		}
	}

	private void SetMarker(Image picker, Vector2 v, bool setX, bool setY)
	{
		RectTransform rectTransform = null;
		RectTransform rectTransform2 = null;
		if (setX && setY)
		{
			rectTransform = GetMarker(picker, null);
		}
		else if (setX)
		{
			rectTransform = GetMarker(picker, "hor");
			rectTransform2 = GetMarker(picker, "ver");
		}
		else if (setY)
		{
			rectTransform = GetMarker(picker, "ver");
			rectTransform2 = GetMarker(picker, "hor");
		}
		if (rectTransform2 != null)
		{
			rectTransform2.gameObject.SetActive(value: false);
		}
		if (!(rectTransform == null))
		{
			rectTransform.gameObject.SetActive(value: true);
			RectTransform rectTransform3 = picker.rectTransform;
			Vector2 size = rectTransform3.rect.size;
			Vector2 vector = rectTransform.localPosition;
			if (setX)
			{
				vector.x = (v.x - rectTransform3.pivot.x) * size.x;
			}
			if (setY)
			{
				vector.y = (v.y - rectTransform3.pivot.y) * size.y;
			}
			rectTransform.localPosition = vector;
		}
	}

	private RectTransform GetMarker(Image picker, string search)
	{
		for (int i = 0; i < picker.transform.childCount; i++)
		{
			RectTransform component = picker.transform.GetChild(i).GetComponent<RectTransform>();
			string text = component.name.ToLower();
			if (text.Contains("marker") & (string.IsNullOrEmpty(search) || text.Contains(search)))
			{
				return component;
			}
		}
		return null;
	}

	private Vector2 GetValue(PickerType type)
	{
		switch (type)
		{
		case PickerType.Main:
			return GetValue(mode);
		case PickerType.Preview:
		case PickerType.PreviewAlpha:
			return Vector2.zero;
		default:
		{
			float value1D = GetValue1D(type);
			return new Vector2(value1D, value1D);
		}
		}
	}

	private float GetValue1D(PickerType type)
	{
		AdvancedSettings.PSettings pSettings = avs.Get((int)type);
		float x = pSettings.range.x;
		float y = pSettings.range.y;
		return type switch
		{
			PickerType.R => Mathf.InverseLerp(x, y, bufferedColor.r), 
			PickerType.G => Mathf.InverseLerp(x, y, bufferedColor.g), 
			PickerType.B => Mathf.InverseLerp(x, y, bufferedColor.b), 
			PickerType.H => Mathf.InverseLerp(x, y, bufferedColor.h / 5.9999f), 
			PickerType.S => Mathf.InverseLerp(x, y, bufferedColor.s), 
			PickerType.V => Mathf.InverseLerp(x, y, bufferedColor.v), 
			PickerType.A => Mathf.InverseLerp(x, y, bufferedColor.a), 
			_ => throw new Exception("Picker type " + type.ToString() + " is not associated with a single color value."), 
		};
	}

	private Vector2 GetValue(MainPickingMode mode)
	{
		return mode switch
		{
			MainPickingMode.HS => new Vector2(GetValue1D(PickerType.H), GetValue1D(PickerType.S)), 
			MainPickingMode.HV => new Vector2(GetValue1D(PickerType.H), GetValue1D(PickerType.V)), 
			MainPickingMode.SH => new Vector2(GetValue1D(PickerType.S), GetValue1D(PickerType.H)), 
			MainPickingMode.SV => new Vector2(GetValue1D(PickerType.S), GetValue1D(PickerType.V)), 
			MainPickingMode.VH => new Vector2(GetValue1D(PickerType.V), GetValue1D(PickerType.H)), 
			MainPickingMode.VS => new Vector2(GetValue1D(PickerType.V), GetValue1D(PickerType.S)), 
			_ => throw new Exception("Unkown main picking mode: " + mode), 
		};
	}

	private void UpdateTextures()
	{
		foreach (PickerType value in Enum.GetValues(typeof(PickerType)))
		{
			if (staticMode | avs.Get((int)value).overrideStatic | ((value == PickerType.Main) & avs.mainStatic))
			{
				UpdateStatic(value);
			}
			else
			{
				UpdateDynamic(value);
			}
		}
	}

	private void UpdateStatic(PickerType type)
	{
		if (IsPickerAvailable(type))
		{
			Picker p = pickers[(int)type];
			bool flag = IsHorizontal(p);
			Sprite sprite = (flag ? p.staticSpriteHor : p.staticSpriteVer);
			if (sprite == null)
			{
				sprite = (flag ? p.staticSpriteVer : p.staticSpriteHor);
			}
			p.image.sprite = sprite;
			p.image.material = null;
			p.image.color = Color.white;
			Color color = this.color;
			switch (type)
			{
			case PickerType.Main:
				p.image.sprite = staticSpriteMain[(int)mode];
				break;
			case PickerType.Preview:
				color.a = 1f;
				p.image.color = color;
				break;
			case PickerType.PreviewAlpha:
				p.image.color = color;
				break;
			}
		}
	}

	private void UpdateDynamic(PickerType type)
	{
		if (!IsPickerAvailable(type))
		{
			return;
		}
		Picker picker = pickers[(int)type];
		if (!(picker.dynamicMaterial == null))
		{
			picker.image.material = picker.dynamicMaterial;
			picker.image.color = Color.white;
			picker.image.sprite = picker.dynamicSprite;
			Material materialForRendering = picker.image.materialForRendering;
			BufferedColor bufferedColor = this.bufferedColor;
			bool flag = IsAlphaType(type);
			materialForRendering.SetInt("_Mode", GetGradientMode(type));
			Color value = PickColor(bufferedColor, type, Vector2.zero).color;
			Color value2 = PickColor(bufferedColor, type, Vector2.one).color;
			if (!flag)
			{
				value = new Color(value.r, value.g, value.b);
				value2 = new Color(value2.r, value2.g, value2.b);
			}
			materialForRendering.SetColor("_Color1", value);
			materialForRendering.SetColor("_Color2", value2);
			if (type == PickerType.Main)
			{
				materialForRendering.SetInt("_DoubleMode", (int)mode);
			}
			materialForRendering.SetVector("_HSV", new Vector4(bufferedColor.h / 5.9999f, bufferedColor.s, bufferedColor.v, flag ? bufferedColor.a : 1f));
			materialForRendering.SetVector("_HSV_MIN", new Vector4(avs.h.range.x, avs.s.range.x, avs.v.range.x));
			materialForRendering.SetVector("_HSV_MAX", new Vector4(avs.h.range.y, avs.s.range.y, avs.v.range.y));
		}
	}

	private int GetGradientMode(PickerType type)
	{
		int num = ((!IsHorizontal(pickers[(int)type])) ? 1 : 0);
		return type switch
		{
			PickerType.Main => 2, 
			PickerType.H => 3 + num, 
			_ => num, 
		};
	}

	private bool IsPickerAvailable(PickerType type)
	{
		return IsPickerAvailable((int)type);
	}

	private bool IsPickerAvailable(int index)
	{
		if (index < 0 || index >= pickers.Length)
		{
			return false;
		}
		Picker picker = pickers[index];
		if (picker.image == null || !picker.image.gameObject.activeInHierarchy)
		{
			return false;
		}
		return true;
	}

	private void UpdateHex()
	{
		if (!(hexInput == null) && hexInput.gameObject.activeInHierarchy)
		{
			hexInput.SetTextWithoutNotify("#" + ColorUtility.ToHtmlStringRGB(color));
		}
	}

	private void TypeHex(string input, bool finish)
	{
		if (typeUpdate)
		{
			return;
		}
		typeUpdate = true;
		string sanitizedHex = GetSanitizedHex(input, finish);
		string sanitizedHex2 = GetSanitizedHex(input, full: true);
		int caretPosition = hexInput.caretPosition;
		hexInput.SetTextWithoutNotify(sanitizedHex);
		if (hexInput.caretPosition == 0)
		{
			hexInput.caretPosition = 1;
		}
		else if (sanitizedHex.Length == 2)
		{
			hexInput.caretPosition = 2;
		}
		else if (input.Length > sanitizedHex.Length && caretPosition < input.Length)
		{
			hexInput.caretPosition = caretPosition - input.Length + sanitizedHex.Length;
		}
		if (ColorUtility.TryParseHtmlString(sanitizedHex2, out var arg))
		{
			if (bufferedColor != null)
			{
				bufferedColor.Set(arg);
				UpdateMarkers();
				UpdateTextures();
				onColorChange.Invoke(arg);
			}
			else
			{
				startingColor = arg;
			}
		}
	}

	private void MakeModeOptions()
	{
		if (modeDropdown == null || !modeDropdown.gameObject.activeInHierarchy)
		{
			return;
		}
		modeDropdown.ClearOptions();
		List<string> list = new List<string>();
		foreach (MainPickingMode value in Enum.GetValues(typeof(MainPickingMode)))
		{
			list.Add(value.ToString());
		}
		modeDropdown.AddOptions(list);
		UpdateMode(mode);
	}

	private void UpdateMode(MainPickingMode mode)
	{
		lastUpdatedMode = mode;
		if (!(modeDropdown == null) && modeDropdown.gameObject.activeInHierarchy)
		{
			modeDropdown.value = (int)mode;
		}
	}

	private static bool IsPreviewType(PickerType type)
	{
		return type switch
		{
			PickerType.Preview => true, 
			PickerType.PreviewAlpha => true, 
			_ => false, 
		};
	}

	private static bool IsAlphaType(PickerType type)
	{
		return type switch
		{
			PickerType.A => true, 
			PickerType.PreviewAlpha => true, 
			_ => false, 
		};
	}

	private static bool IsHorizontal(Picker p)
	{
		Vector2 size = p.image.rectTransform.rect.size;
		return size.x >= size.y;
	}

	public static string GetSanitizedHex(string input, bool full)
	{
		if (string.IsNullOrEmpty(input))
		{
			return "#";
		}
		List<char> list = new List<char>();
		list.Add('#');
		int num = 0;
		char[] array = input.ToCharArray();
		while (list.Count < 7 && num < input.Length)
		{
			char c = char.ToUpper(array[num++]);
			if (IsValidHexChar(c))
			{
				list.Add(c);
			}
		}
		while (full && list.Count < 7)
		{
			list.Insert(1, '0');
		}
		return new string(list.ToArray());
	}

	private static bool IsValidHexChar(char c)
	{
		return char.IsNumber(c) || (c >= 'A' && c <= 'F');
	}

	public static Color ParseHex(string input)
	{
		return ParseHex(input, Color.black);
	}

	public static Color ParseHex(string input, Color defaultColor)
	{
		if (ColorUtility.TryParseHtmlString(GetSanitizedHex(input, full: true), out var result))
		{
			return result;
		}
		return defaultColor;
	}

	private static Vector2 GetNormalizedPointerPosition(Canvas canvas, RectTransform rect, BaseEventData e)
	{
		switch (canvas.renderMode)
		{
		case RenderMode.ScreenSpaceCamera:
			if (canvas.worldCamera == null)
			{
				return GetNormScreenSpace(rect, e);
			}
			return GetNormWorldSpace(canvas, rect, e);
		case RenderMode.ScreenSpaceOverlay:
			return GetNormScreenSpace(rect, e);
		case RenderMode.WorldSpace:
			if (canvas.worldCamera == null)
			{
				UnityEngine.Debug.LogError("FCP in world space render mode requires an event camera to be set up on the parent canvas!");
				return Vector2.zero;
			}
			return GetNormWorldSpace(canvas, rect, e);
		default:
			return Vector2.zero;
		}
	}

	private static Vector2 GetNormScreenSpace(RectTransform rect, BaseEventData e)
	{
		Vector2 position = ((PointerEventData)e).position;
		Vector2 vector = rect.worldToLocalMatrix.MultiplyPoint(position);
		float x = Mathf.Clamp01(vector.x / rect.rect.size.x + rect.pivot.x);
		float y = Mathf.Clamp01(vector.y / rect.rect.size.y + rect.pivot.y);
		return new Vector2(x, y);
	}

	private static Vector2 GetNormWorldSpace(Canvas canvas, RectTransform rect, BaseEventData e)
	{
		Vector2 position = ((PointerEventData)e).position;
		Ray ray = canvas.worldCamera.ScreenPointToRay(position);
		new Plane(canvas.transform.forward, canvas.transform.position).Raycast(ray, out var enter);
		Vector3 point = ray.origin + enter * ray.direction;
		Vector2 vector = rect.worldToLocalMatrix.MultiplyPoint(point);
		float x = Mathf.Clamp01(vector.x / rect.rect.size.x + rect.pivot.x);
		float y = Mathf.Clamp01(vector.y / rect.rect.size.y + rect.pivot.y);
		return new Vector2(x, y);
	}

	public static Color HSVToRGB(Vector3 hsv)
	{
		return HSVToRGB(hsv.x, hsv.y, hsv.z);
	}

	public static Color HSVToRGB(float h, float s, float v)
	{
		float num = s * v;
		float num2 = v - num;
		float num3 = num * (1f - Mathf.Abs(h % 2f - 1f)) + num2;
		num += num2;
		return Mathf.FloorToInt(h % 6f) switch
		{
			0 => new Color(num, num3, num2), 
			1 => new Color(num3, num, num2), 
			2 => new Color(num2, num, num3), 
			3 => new Color(num2, num3, num), 
			4 => new Color(num3, num2, num), 
			5 => new Color(num, num2, num3), 
			_ => Color.black, 
		};
	}

	public static Vector3 RGBToHSV(Color color)
	{
		float r = color.r;
		float g = color.g;
		float b = color.b;
		return RGBToHSV(r, g, b);
	}

	public static Vector3 RGBToHSV(float r, float g, float b)
	{
		float num = Mathf.Max(r, g, b);
		float num2 = Mathf.Min(r, g, b);
		float num3 = num - num2;
		float x = 0f;
		if (num3 > 0f)
		{
			if (r >= b && r >= g)
			{
				x = Mathf.Repeat((g - b) / num3, 6f);
			}
			else if (g >= r && g >= b)
			{
				x = (b - r) / num3 + 2f;
			}
			else if (b >= r && b >= g)
			{
				x = (r - g) / num3 + 4f;
			}
		}
		float y = ((num == 0f) ? 0f : (num3 / num));
		float z = num;
		return new Vector3(x, y, z);
	}
}
public class BulletController : MonoBehaviour
{
	private Rigidbody 私刚;

	private void Awake()
	{
		私刚 = GetComponent<Rigidbody>();
		私刚.useGravity = false;
	}

	public void AddForce(Vector3 尤力参)
	{
		私刚.AddForce(尤力参, ForceMode.Impulse);
	}

	private void OnCollisionEnter(Collision collision)
	{
		UnityEngine.Object.Destroy(私刚);
		Vector3 仨参 = 佐.逮.位撞(collision);
		仨参 = 佐.逮.位不重叠(仨参);
		float x = 佐.逮.改横(仨参.x);
		float y = 佐.逮.改纵(仨参.y);
		float z = 佐.逮.改深(仨参.z);
		base.transform.parent.localPosition = new Vector3(x, y, z);
		base.transform.parent.localRotation = Quaternion.Euler(0f, 0f, 0f);
		base.transform.localPosition = new Vector3(0.05f, 0.05f, -0.05f);
		base.transform.localRotation = Quaternion.Euler(0f, 0f, 0f);
		UnityEngine.Object.Destroy(GetComponent<BulletController>());
	}
}
public class GunController : MonoBehaviour
{
	private GameObject 公尤丸;

	public Transform 公变火点;

	public float 公几力 = 5f;

	private XRGrabInteractable 公交互式基础;

	private void Awake()
	{
		公交互式基础 = GetComponent<XRGrabInteractable>();
		公交互式基础.activated.AddListener(抓握枪处理);
	}

	private void 抓握枪处理(ActivateEventArgs arg0)
	{
		打();
	}

	private void 打()
	{
		公尤丸 = Resources.Load("预制/" + 佐.逮.造啥) as GameObject;
		GameObject obj = UnityEngine.Object.Instantiate(公尤丸, 公变火点.position, 公变火点.rotation);
		GameObject gameObject = obj.transform.GetChild(0).gameObject;
		if (佑.逮.公队.Count > 0)
		{
			佐.逮.消();
		}
		GameObject 该 = 佐.逮.该;
		佐.逮.该 = gameObject;
		佐.逮.刚();
		佐.逮.该 = 该;
		gameObject.AddComponent<BulletController>();
		obj.GetComponentInChildren<BulletController>().AddForce(公变火点.forward * 公几力);
	}
}
public class InteractionSampleInputActions : IInputActionCollection2, IInputActionCollection, IEnumerable<InputAction>, IEnumerable, IDisposable
{
	public struct TeleportActions
	{
		private InteractionSampleInputActions m_Wrapper;

		public InputAction Trigger => m_Wrapper.m_Teleport_Trigger;

		public bool enabled => Get().enabled;

		public TeleportActions(InteractionSampleInputActions wrapper)
		{
			m_Wrapper = wrapper;
		}

		public InputActionMap Get()
		{
			return m_Wrapper.m_Teleport;
		}

		public void Enable()
		{
			Get().Enable();
		}

		public void Disable()
		{
			Get().Disable();
		}

		public static implicit operator InputActionMap(TeleportActions set)
		{
			return set.Get();
		}

		public void SetCallbacks(ITeleportActions instance)
		{
			if (m_Wrapper.m_TeleportActionsCallbackInterface != null)
			{
				Trigger.started -= m_Wrapper.m_TeleportActionsCallbackInterface.OnTrigger;
				Trigger.performed -= m_Wrapper.m_TeleportActionsCallbackInterface.OnTrigger;
				Trigger.canceled -= m_Wrapper.m_TeleportActionsCallbackInterface.OnTrigger;
			}
			m_Wrapper.m_TeleportActionsCallbackInterface = instance;
			if (instance != null)
			{
				Trigger.started += instance.OnTrigger;
				Trigger.performed += instance.OnTrigger;
				Trigger.canceled += instance.OnTrigger;
			}
		}
	}

	public interface ITeleportActions
	{
		void OnTrigger(InputAction.CallbackContext context);
	}

	private readonly InputActionMap m_Teleport;

	private ITeleportActions m_TeleportActionsCallbackInterface;

	private readonly InputAction m_Teleport_Trigger;

	public InputActionAsset asset { get; }

	public InputBinding? bindingMask
	{
		get
		{
			return asset.bindingMask;
		}
		set
		{
			asset.bindingMask = value;
		}
	}

	public ReadOnlyArray<UnityEngine.InputSystem.InputDevice>? devices
	{
		get
		{
			return asset.devices;
		}
		set
		{
			asset.devices = value;
		}
	}

	public ReadOnlyArray<InputControlScheme> controlSchemes => asset.controlSchemes;

	public IEnumerable<InputBinding> bindings => asset.bindings;

	public TeleportActions Teleport => new TeleportActions(this);

	public InteractionSampleInputActions()
	{
		asset = InputActionAsset.FromJson("{\n    \"name\": \"InteractionSampleInputActions\",\n    \"maps\": [\n        {\n            \"name\": \"Teleport\",\n            \"id\": \"681b0566-8302-4264-9336-815af1405bab\",\n            \"actions\": [\n                {\n                    \"name\": \"Trigger\",\n                    \"type\": \"Button\",\n                    \"id\": \"0e7759bc-8a59-427e-8523-08f610d2a2bf\",\n                    \"expectedControlType\": \"Button\",\n                    \"processors\": \"\",\n                    \"interactions\": \"\",\n                    \"initialStateCheck\": false\n                }\n            ],\n            \"bindings\": [\n                {\n                    \"name\": \"\",\n                    \"id\": \"509d90d2-bc5f-4155-8b67-0b49cb863f02\",\n                    \"path\": \"<XRController>{RightHand}/triggerPressed\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"\",\n                    \"action\": \"Trigger\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                }\n            ]\n        }\n    ],\n    \"controlSchemes\": []\n}");
		m_Teleport = asset.FindActionMap("Teleport", throwIfNotFound: true);
		m_Teleport_Trigger = m_Teleport.FindAction("Trigger", throwIfNotFound: true);
	}

	public void Dispose()
	{
		UnityEngine.Object.Destroy(asset);
	}

	public bool Contains(InputAction action)
	{
		return asset.Contains(action);
	}

	public IEnumerator<InputAction> GetEnumerator()
	{
		return asset.GetEnumerator();
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return GetEnumerator();
	}

	public void Enable()
	{
		asset.Enable();
	}

	public void Disable()
	{
		asset.Disable();
	}

	public InputAction FindAction(string actionNameOrId, bool throwIfNotFound = false)
	{
		return asset.FindAction(actionNameOrId, throwIfNotFound);
	}

	public int FindBinding(InputBinding bindingMask, out InputAction action)
	{
		return asset.FindBinding(bindingMask, out action);
	}
}
public class TeleportController : MonoBehaviour
{
	public static TeleportController 逮;

	private TeleportationProvider 提供者;

	[FormerlySerializedAs("teleportRay")]
	public XRRayInteractor 隐形光线交互器;

	private InteractionSampleInputActions 输入操作;

	private void Start()
	{
	}

	private void Update()
	{
		if (佑.逮.公为搁)
		{
			GameObject reticle = GameObject.Find("/传送刻线");
			隐形光线交互器.GetComponent<XRInteractorLineVisual>().reticle = reticle;
		}
	}

	private void Awake()
	{
		逮 = this;
		提供者 = GetComponent<TeleportationProvider>();
	}

	public void 搁哪()
	{
		输入操作 = new InteractionSampleInputActions();
		输入操作.Teleport.Trigger.Enable();
		输入操作.Teleport.Trigger.performed += 瞬始;
		输入操作.Teleport.Trigger.canceled += 瞬完;
	}

	private void 瞬始(InputAction.CallbackContext 回调上下文)
	{
		隐形光线交互器.enabled = true;
		GameObject reticle = GameObject.Find("/传送刻线");
		隐形光线交互器.GetComponent<XRInteractorLineVisual>().reticle = reticle;
	}

	private void 瞬完(InputAction.CallbackContext 回调上下文)
	{
		if (隐形光线交互器.TryGetCurrent3DRaycastHit(out var raycastHit) && raycastHit.collider != null && (raycastHit.collider.GetComponent<TeleportationArea>() != null || raycastHit.collider.GetComponent<TeleportationAnchor>() != null))
		{
			佐.逮.公仨搁 = raycastHit.point;
			佐.逮.脑搁();
		}
	}

	public void 瞬(Vector3 仨参)
	{
		TeleportRequest teleportRequest = default(TeleportRequest);
		teleportRequest.destinationPosition = 仨参;
		提供者.QueueTeleportRequest(teleportRequest);
	}
}
public class Function : MonoBehaviour
{
	public void 输出字(string z)
	{
		Var.字.text = (Var.字.text += z);
	}

	public void 删除键()
	{
	}
}
public class Load : MonoBehaviour
{
	public Text 拼音;

	public Text 汉字;

	public Text 字;

	private void Start()
	{
		StaticLei.输入法拼音 = 拼音;
		StaticLei.选择的汉字 = 汉字;
		Var.字 = 字;
		StaticLei.输出 = new Function();
		Var.字库 = new JSONObject((Resources.Load("ziku3") as TextAsset).text);
		Var.拼音表 = new JSONObject("{\"a\":\"a,ai,an,ang,ao\",\"b\":\"ba,bai,ban,bang,bao,bei,ben,beng,bi,bian,biao,bie,bin,bing,bo,bu\",\"c\":\"ca,cai,can,cang,cao,ce,cei,cen,ceng,cha,chai,chan,chang,chao,che,chen,cheng,chi,chong,chou,chu,chua,chuai,chuan,chuang,chui,chun,chuo,ci,cong,cou,cu,cuan,cui,cun,cuo\",\"d\":\"da,dai,dan,dang,dao,de,den,dei,deng,di,dia,dian,diao,die,ding,diu,dong,dou,du,duan,dui,dun,duo\",\"e\":\"e,ei,en,eng,er\",\"f\":\"fa,fan,fang,fei,fen,feng,fo,fou,fu\",\"g\":\"ga,gai,gan,gang,gao,ge,gei,gen,geng,gong,gou,gu,gua,guai,guan,guang,gui,gun,guo\",\"h\":\"ha,hai,han,hang,hao,he,hei,hen,heng,hong,hou,hu,hua,huai,huan,huang,hui,hun,huo\",\"i\":\"i\",\"j\":\"ji,jia,jian,jiang,jiao,jie,jin,jing,jiong,jiu,ju,juan,jue,jun\",\"k\":\"ka,kai,kan,kang,kao,ke,ken,keng,kong,kou,ku,kua,kuai,kuan,kuang,kui,kun,kuo\",\"l\":\"la,lai,lan,lang,lao,le,lei,leng,li,lia,lian,liang,liao,lie,lin,ling,liu,long,lou,lu,lv,luan,lve,lun,luo\",\"m\":\"m,ma,mai,man,mang,mao,me,mei,men,meng,mi,mian,miao,mie,min,ming,miu,mo,mou,mu\",\"n\":\"na,nai,nan,nang,nao,ne,nei,nen,neng,ng,ni,nian,niang,niao,nie,nin,ning,niu,nong,nou,nu,nv,nuan,nve,nuo,nun\",\"o\":\"o,ou\",\"p\":\"pa,pai,pan,pang,pao,pei,pen,peng,pi,pian,piao,pie,pin,ping,po,pou,pu\",\"q\":\"qi,qia,qian,qiang,qiao,qie,qin,qing,qiong,qiu,qu,quan,que,qun\",\"r\":\"ran,rang,rao,re,ren,reng,ri,rong,rou,ru,ruan,rui,run,ruo\",\"s\":\"sa,sai,san,sang,sao,se,sen,seng,sha,shai,shan,shang,shao,she,shei,shen,sheng,shi,shou,shu,shua,shuai,shuan,shuang,shui,shun,shuo,si,song,sou,su,suan,sui,sun,suo\",\"t\":\"ta,tai,tan,tang,tao,te,teng,ti,tian,tiao,tie,ting,tong,tou,tu,tuan,tui,tun,tuo\",\"u\":\"u\",\"v\":\"v\",\"w\":\"wa,wai,wan,wang,wei,wen,weng,wo,wu\",\"x\":\"xi,xia,xian,xiang,xiao,xie,xin,xing,xiong,xiu,xu,xuan,xue,xun\",\"y\":\"ya,yan,yang,yao,ye,yi,yin,ying,yo,yong,you,yu,yuan,yue,yun\",\"z\":\"za,zai,zan,zang,zao,ze,zei,zen,zeng,zha,zhai,zhan,zhang,zhao,zhe,zhei,zhen,zheng,zhi,zhong,zhou,zhu,zhua,zhuai,zhuan,zhuang,zhui,zhun,zhuo,zi,zong,zou,zu,zuan,zui,zun,zuo\"}");
	}
}
public class PengZhuang : MonoBehaviour
{
	public void OnTriggerEnter(Collider col)
	{
		string text = col.gameObject.tag.ToString();
		switch (text)
		{
		case "Img_All":
			return;
		case "Img_World":
			return;
		case "Img_GongHui":
			return;
		case "Img_ZuDui":
			return;
		case "Img_FuJin":
			return;
		case "cube_S":
			return;
		}
		StaticLei.Pengzhuang(text);
	}
}
public class StaticLei : MonoBehaviour
{
	public static Text 输入法拼音;

	public static Text 选择的汉字;

	public static Function 输出;

	private static string 用户输入拼音 = "";

	private static string 用户输入拼音2 = "";

	private static ArrayList 阵选字 = new ArrayList();

	private static int 选字标签 = 0;

	private static string 取出的字库;

	private static int 取出字库的长度 = 0;

	private static string zfc = "0,1,2,3,4,5,6,7,8,9";

	private static bool 输入状态 = false;

	private static int 切换状态 = 0;

	public static void Pengzhuang(string a)
	{
		string text = a;
		switch (text)
		{
		case "qingchu":
			MonoBehaviour.print("清除");
			清除选字();
			输入结束();
			return;
		case "qiehuan":
			切换状态++;
			if (切换状态 > 2)
			{
				切换状态 = 0;
			}
			if (输入状态)
			{
				输入状态 = false;
				输出.输出字(用户输入拼音);
				清除选字();
				输入结束();
			}
			return;
		case "shanchu":
			MonoBehaviour.print(用户输入拼音);
			if (用户输入拼音.Length < 1)
			{
				输出.删除键();
			}
			if (用户输入拼音.Length >= 1)
			{
				用户输入拼音 = 删除(用户输入拼音);
			}
			if (用户输入拼音2.Length >= 1)
			{
				用户输入拼音2 = 删除(用户输入拼音2);
			}
			输入法拼音.text = 用户输入拼音;
			if (用户输入拼音.Length > 1)
			{
				解析类型(用户输入拼音, "");
			}
			return;
		case "xiayiye":
			if (输入状态 && 选字标签 < 取出字库的长度)
			{
				加数字序号(取出的字库, 选字标签);
			}
			return;
		case "shangyiye":
			if (输入状态)
			{
				选字标签 += -20;
				if (选字标签 < 0)
				{
					选字标签 = 0;
				}
				加数字序号(取出的字库, 选字标签);
			}
			return;
		}
		if (切换状态 != 0)
		{
			if (切换状态 == 1)
			{
				输出.输出字(a.ToLower());
			}
			else
			{
				输出.输出字(a.ToUpper());
			}
		}
		else if (zfc.IndexOf(text) != -1)
		{
			if (阵选字.Count != 0)
			{
				if (text == "0")
				{
					text = "10";
				}
				int num = int.Parse(text) - 1;
				int count = 阵选字.Count;
				if (num <= count)
				{
					string z = 阵选字[num].ToString();
					输出.输出字(z);
				}
				清除选字();
				输入结束();
			}
		}
		else
		{
			输入状态 = true;
			用户输入拼音 += text;
			输入法拼音.text = 用户输入拼音;
			解析类型(用户输入拼音, text);
		}
	}

	private static void 解析类型(string 参数, string 参数2)
	{
		string text = 分割输入的拼音(参数)[^1];
		string text2 = text[0].ToString();
		string text3 = Var.拼音表[text2].ToString();
		if (text3 == null)
		{
			return;
		}
		if (text3.IndexOf(text) != -1)
		{
			用户输入拼音2 = 输入法拼音.text;
		}
		else
		{
			用户输入拼音2 = 用户输入拼音2 + "'" + 参数2;
			用户输入拼音 = 用户输入拼音2;
			输入法拼音.text = 用户输入拼音;
		}
		string[] array = 分割输入的拼音(用户输入拼音);
		if (array.Length == 1)
		{
			选字标签 = 0;
			if ((bool)Var.字库[text2]["字"][text])
			{
				取出的字库 = Var.字库[text2]["字"][text].ToString();
			}
			else
			{
				取出的字库 = 函把所以的字加进数组(text2);
			}
			取出的字库 = jsontoString(取出的字库, "\"");
			加数字序号(取出的字库, 0);
		}
		else if (array.Length > 1 && (bool)Var.字库[text2]["词"][用户输入拼音2])
		{
			选字标签 = 0;
			取出的字库 = Var.字库[text2]["词"][用户输入拼音2].ToString();
			取出的字库 = jsontoString(取出的字库, "\"");
			MonoBehaviour.print("取出的字库:" + 取出的字库);
			加数字序号(取出的字库, 0);
		}
	}

	private static string 函把所以的字加进数组(string 参数)
	{
		int num = 0;
		ArrayList arrayList = new ArrayList();
		string text = "";
		for (int i = 0; i < Var.字库[参数]["字"].list.Count; i++)
		{
			string value = Var.字库[参数]["字"].keys[i];
			arrayList.Add(value);
			int length = Var.字库[参数]["字"].list[i].ToString().Length;
			if (num < length)
			{
				num = length;
			}
		}
		for (int j = 0; j < num; j++)
		{
			for (int k = 0; k < arrayList.Count; k++)
			{
				string text2 = Var.字库[参数]["字"][arrayList[k].ToString()].ToString();
				if (text2.Length > j)
				{
					text += text2[j];
				}
				else
				{
					arrayList.Remove(k);
				}
			}
		}
		string replacement = "\"";
		return new Regex("\"+").Replace(text, replacement);
	}

	private static void 加数字序号(string 参数, int 参数2)
	{
		阵选字.Clear();
		string text = "";
		ArrayList arrayList = new ArrayList();
		if (参数.IndexOf(",") != -1)
		{
			arrayList = new ArrayList(Regex.Split(参数, ","));
		}
		else
		{
			for (int i = 0; i < 参数.Length; i++)
			{
				string value = 参数.Substring(i, 1);
				arrayList.Add(value);
			}
		}
		取出字库的长度 = arrayList.Count;
		for (int j = 0; j < 10; j++)
		{
			int num = j + 1;
			if (num == 10)
			{
				num = 0;
			}
			int num2 = ((参数2 == 0) ? j : (参数2 + j));
			if (num2 >= 取出字库的长度)
			{
				break;
			}
			text = text + num + "." + arrayList[num2]?.ToString() + " ";
			阵选字.Add(arrayList[num2]);
			选字标签++;
		}
		选择的汉字.text = text;
		MonoBehaviour.print("临显示选字" + text);
	}

	private static string 删除(string 参数)
	{
		string text = 参数;
		text = text.Substring(0, text.Length - 1);
		if (text.Length < 1)
		{
			清除选字();
			return "";
		}
		if (text[text.Length - 1].ToString() == "'")
		{
			text = text.Substring(0, text.Length - 1);
		}
		return text;
	}

	private static void 清除选字()
	{
		阵选字.Clear();
		选择的汉字.text = "";
	}

	private static void 输入结束()
	{
		输入状态 = false;
		取出的字库 = "";
		选字标签 = 0;
		取出字库的长度 = 0;
		用户输入拼音 = "";
		用户输入拼音2 = "";
		输入法拼音.text = "";
		选择的汉字.text = "";
	}

	private static string[] 分割输入的拼音(string 参数)
	{
		return Regex.Split(参数, "'");
	}

	private static string jsontoString(string target, string s)
	{
		return Regex.Split(target, s)[1];
	}
}
public class Var
{
	public static JSONObject 拼音表;

	public static JSONObject 字库;

	public static Text 字;
}
public enum SlimeAnimationState
{
	Idle,
	Walk,
	Jump,
	Attack,
	Damage
}
public class EnemyAi : MonoBehaviour
{
	public enum WalkType
	{
		Patroll,
		ToOrigin
	}

	public Face faces;

	public GameObject SmileBody;

	public SlimeAnimationState currentState;

	public Animator animator;

	public NavMeshAgent agent;

	public Transform[] waypoints;

	public int damType;

	private int m_CurrentWaypointIndex;

	private bool move;

	private Material faceMaterial;

	private Vector3 originPos;

	private WalkType walkType;

	private void Start()
	{
		originPos = base.transform.position;
		faceMaterial = SmileBody.GetComponent<Renderer>().materials[1];
		walkType = WalkType.Patroll;
	}

	public void WalkToNextDestination()
	{
		currentState = SlimeAnimationState.Walk;
		m_CurrentWaypointIndex = (m_CurrentWaypointIndex + 1) % waypoints.Length;
		agent.SetDestination(waypoints[m_CurrentWaypointIndex].position);
		SetFace(faces.WalkFace);
	}

	public void CancelGoNextDestination()
	{
		CancelInvoke("WalkToNextDestination");
	}

	private void SetFace(Texture tex)
	{
		faceMaterial.SetTexture("_MainTex", tex);
	}

	private void Update()
	{
		switch (currentState)
		{
		case SlimeAnimationState.Idle:
			if (!animator.GetCurrentAnimatorStateInfo(0).IsName("Idle"))
			{
				StopAgent();
				SetFace(faces.Idleface);
			}
			break;
		case SlimeAnimationState.Walk:
			if (animator.GetCurrentAnimatorStateInfo(0).IsName("Walk"))
			{
				break;
			}
			agent.isStopped = false;
			agent.updateRotation = true;
			if (walkType == WalkType.ToOrigin)
			{
				agent.SetDestination(originPos);
				SetFace(faces.WalkFace);
				if (agent.remainingDistance < agent.stoppingDistance)
				{
					walkType = WalkType.Patroll;
					base.transform.rotation = Quaternion.identity;
					currentState = SlimeAnimationState.Idle;
				}
			}
			else
			{
				if (waypoints[0] == null)
				{
					break;
				}
				agent.SetDestination(waypoints[m_CurrentWaypointIndex].position);
				if (agent.remainingDistance < agent.stoppingDistance)
				{
					currentState = SlimeAnimationState.Idle;
					Invoke("WalkToNextDestination", 2f);
				}
			}
			animator.SetFloat("Speed", agent.velocity.magnitude);
			break;
		case SlimeAnimationState.Jump:
			if (!animator.GetCurrentAnimatorStateInfo(0).IsName("Jump"))
			{
				StopAgent();
				SetFace(faces.jumpFace);
				animator.SetTrigger("Jump");
			}
			break;
		case SlimeAnimationState.Attack:
			if (!animator.GetCurrentAnimatorStateInfo(0).IsName("Attack"))
			{
				StopAgent();
				SetFace(faces.attackFace);
				animator.SetTrigger("Attack");
			}
			break;
		case SlimeAnimationState.Damage:
			if (!animator.GetCurrentAnimatorStateInfo(0).IsName("Damage0") && !animator.GetCurrentAnimatorStateInfo(0).IsName("Damage1") && !animator.GetCurrentAnimatorStateInfo(0).IsName("Damage2"))
			{
				StopAgent();
				animator.SetTrigger("Damage");
				animator.SetInteger("DamageType", damType);
				SetFace(faces.damageFace);
			}
			break;
		}
	}

	private void StopAgent()
	{
		agent.isStopped = true;
		animator.SetFloat("Speed", 0f);
		agent.updateRotation = false;
	}

	public void AlertObservers(string message)
	{
		if (message.Equals("AnimationDamageEnded"))
		{
			if (Vector3.Distance(base.transform.position, originPos) > 1f)
			{
				walkType = WalkType.ToOrigin;
				currentState = SlimeAnimationState.Walk;
			}
			else
			{
				currentState = SlimeAnimationState.Idle;
			}
		}
		if (message.Equals("AnimationAttackEnded"))
		{
			currentState = SlimeAnimationState.Idle;
		}
		if (message.Equals("AnimationJumpEnded"))
		{
			currentState = SlimeAnimationState.Idle;
		}
	}

	private void OnAnimatorMove()
	{
		Vector3 rootPosition = animator.rootPosition;
		rootPosition.y = agent.nextPosition.y;
		base.transform.position = rootPosition;
		agent.nextPosition = base.transform.position;
	}
}
[CreateAssetMenu(fileName = "Data", menuName = "ScriptableObjects/Face", order = 1)]
public class Face : ScriptableObject
{
	public Texture Idleface;

	public Texture WalkFace;

	public Texture jumpFace;

	public Texture attackFace;

	public Texture damageFace;
}
public class GameManager : MonoBehaviour
{
	public GameObject mainSlime;

	public UnityEngine.UI.Button idleBut;

	public UnityEngine.UI.Button walkBut;

	public UnityEngine.UI.Button jumpBut;

	public UnityEngine.UI.Button attackBut;

	public UnityEngine.UI.Button damageBut0;

	public UnityEngine.UI.Button damageBut1;

	public UnityEngine.UI.Button damageBut2;

	public Camera cam;

	private void Start()
	{
		idleBut.onClick.AddListener(delegate
		{
			Idle();
		});
		walkBut.onClick.AddListener(delegate
		{
			ChangeStateTo(SlimeAnimationState.Walk);
		});
		jumpBut.onClick.AddListener(delegate
		{
			LookAtCamera();
			ChangeStateTo(SlimeAnimationState.Jump);
		});
		attackBut.onClick.AddListener(delegate
		{
			LookAtCamera();
			ChangeStateTo(SlimeAnimationState.Attack);
		});
		damageBut0.onClick.AddListener(delegate
		{
			LookAtCamera();
			ChangeStateTo(SlimeAnimationState.Damage);
			mainSlime.GetComponent<EnemyAi>().damType = 0;
		});
		damageBut1.onClick.AddListener(delegate
		{
			LookAtCamera();
			ChangeStateTo(SlimeAnimationState.Damage);
			mainSlime.GetComponent<EnemyAi>().damType = 1;
		});
		damageBut2.onClick.AddListener(delegate
		{
			LookAtCamera();
			ChangeStateTo(SlimeAnimationState.Damage);
			mainSlime.GetComponent<EnemyAi>().damType = 2;
		});
	}

	private void Idle()
	{
		LookAtCamera();
		mainSlime.GetComponent<EnemyAi>().CancelGoNextDestination();
		ChangeStateTo(SlimeAnimationState.Idle);
	}

	public void ChangeStateTo(SlimeAnimationState state)
	{
		if (!(mainSlime == null) && state != mainSlime.GetComponent<EnemyAi>().currentState)
		{
			mainSlime.GetComponent<EnemyAi>().currentState = state;
		}
	}

	private void LookAtCamera()
	{
		mainSlime.transform.rotation = Quaternion.Euler(new Vector3(mainSlime.transform.rotation.x, cam.transform.rotation.y, mainSlime.transform.rotation.z));
	}
}
[RequireComponent(typeof(Texture))]
public class ForcedReset : MonoBehaviour
{
	private void Update()
	{
		if (CrossPlatformInputManager.GetButtonDown("ResetObject"))
		{
			UnityEngine.Application.LoadLevelAsync(UnityEngine.Application.loadedLevelName);
		}
	}
}
public class MouseOrbit_ForRTS_CSharp : MonoBehaviour
{
	public float ZoomSpeed = 10f;

	public float MovingSpeed = 0.5f;

	public float RotateSpeed = 1f;

	public float distance = 5f;

	private void Start()
	{
	}

	private void Update()
	{
		if (Input.GetMouseButton(0))
		{
			float num = Input.GetAxis("Mouse X") * MovingSpeed;
			float num2 = Input.GetAxis("Mouse Y") * MovingSpeed;
			Quaternion quaternion = Quaternion.Euler(0f, base.transform.rotation.eulerAngles.y, 0f);
			base.transform.position = quaternion * new Vector3(0f - num, 0f, 0f - num2) + base.transform.position;
		}
		if (Input.GetAxis("Mouse ScrollWheel") != 0f)
		{
			float num3 = (0f - Input.GetAxis("Mouse ScrollWheel")) * ZoomSpeed;
			base.transform.Translate(0f, 0f, 0f - num3);
			distance += num3;
		}
		if (Input.GetMouseButton(1))
		{
			float yAngle = Input.GetAxis("Mouse X") * RotateSpeed;
			float xAngle = (0f - Input.GetAxis("Mouse Y")) * RotateSpeed;
			Vector3 vector = base.transform.rotation * new Vector3(0f, 0f, distance) + base.transform.position;
			base.transform.Rotate(0f, yAngle, 0f, Space.World);
			base.transform.Rotate(xAngle, 0f, 0f);
			base.transform.position = base.transform.rotation * new Vector3(0f, 0f, 0f - distance) + vector;
		}
	}
}
[RequireComponent(typeof(Camera))]
public class SelectObject : MonoBehaviour
{
	public static SelectObject _instance;

	public int Iterations = 3;

	public float Spread = 0.7f;

	public Color outterColor = new Color(0.2f, 1f, 0f, 1f);

	public GameObject targetsGroup1;

	public GameObject[] targetsGroup2;

	public Camera outterLineCamera;

	public Shader compositeShader;

	private Material m_CompositeMaterial;

	public Shader blurShader;

	private Material m_BlurMaterial;

	public Shader cutoffShader;

	private Material m_cutoffMaterial;

	private Material m_outterLineMat;

	private RenderTexture outterLineTexture;

	protected Material compositeMaterial
	{
		get
		{
			if (m_CompositeMaterial == null)
			{
				m_CompositeMaterial = new Material(compositeShader);
				m_CompositeMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return m_CompositeMaterial;
		}
	}

	protected Material blurMaterial
	{
		get
		{
			if (m_BlurMaterial == null)
			{
				m_BlurMaterial = new Material(blurShader);
				m_BlurMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return m_BlurMaterial;
		}
	}

	protected Material cutoffMaterial
	{
		get
		{
			if (m_cutoffMaterial == null)
			{
				m_cutoffMaterial = new Material(cutoffShader);
				m_cutoffMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return m_cutoffMaterial;
		}
	}

	protected Material outterLineMat => m_outterLineMat;

	private void Awake()
	{
		_instance = this;
	}

	private void Start()
	{
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
			return;
		}
		if (!blurMaterial.shader.isSupported)
		{
			base.enabled = false;
		}
		if (!compositeMaterial.shader.isSupported)
		{
			base.enabled = false;
		}
		if (!cutoffMaterial.shader.isSupported)
		{
			base.enabled = false;
		}
		if ((bool)targetsGroup1)
		{
			targetsGroup1.AddComponent<ShowSelected>().outterColor = outterColor;
		}
		GameObject[] array = targetsGroup2;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].AddComponent<ShowSelectedBump>().outterColor = outterColor;
		}
		if (!outterLineTexture)
		{
			outterLineTexture = new RenderTexture(GetComponent<Camera>().pixelWidth, GetComponent<Camera>().pixelHeight, 16);
			outterLineTexture.hideFlags = HideFlags.DontSave;
		}
	}

	private void OnDisable()
	{
		if ((bool)outterLineTexture)
		{
			UnityEngine.Object.DestroyImmediate(outterLineTexture);
			outterLineTexture = null;
		}
		if ((bool)m_CompositeMaterial)
		{
			UnityEngine.Object.DestroyImmediate(m_CompositeMaterial);
		}
		if ((bool)m_BlurMaterial)
		{
			UnityEngine.Object.DestroyImmediate(m_BlurMaterial);
		}
		if ((bool)m_outterLineMat)
		{
			UnityEngine.Object.DestroyImmediate(m_outterLineMat);
		}
	}

	public void FourTapCone(RenderTexture source, RenderTexture dest, int iteration)
	{
		float num = 0.5f + (float)iteration * Spread;
		Graphics.BlitMultiTap(source, dest, blurMaterial, new Vector2(num, num), new Vector2(0f - num, num), new Vector2(num, 0f - num), new Vector2(0f - num, 0f - num));
	}

	private void OnPreRender()
	{
	}

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		Iterations = Mathf.Clamp(Iterations, 0, 15);
		Spread = Mathf.Clamp(Spread, 0.5f, 6f);
		RenderTexture temporary = RenderTexture.GetTemporary(outterLineTexture.width, outterLineTexture.height, 0);
		RenderTexture temporary2 = RenderTexture.GetTemporary(outterLineTexture.width, outterLineTexture.height, 0);
		Graphics.Blit(outterLineTexture, temporary);
		bool flag = true;
		for (int i = 0; i < Iterations; i++)
		{
			if (flag)
			{
				FourTapCone(temporary, temporary2, i);
			}
			else
			{
				FourTapCone(temporary2, temporary, i);
			}
			flag = !flag;
		}
		Graphics.Blit(source, destination);
		if (flag)
		{
			Graphics.Blit(outterLineTexture, temporary, cutoffMaterial);
			Graphics.Blit(temporary, destination, compositeMaterial);
		}
		else
		{
			Graphics.Blit(outterLineTexture, temporary2, cutoffMaterial);
			Graphics.Blit(temporary2, destination, compositeMaterial);
		}
		RenderTexture.ReleaseTemporary(temporary);
		RenderTexture.ReleaseTemporary(temporary2);
	}
}
[RequireComponent(typeof(Camera))]
public class SelectObjectNew : MonoBehaviour
{
	public int borderWidth = 3;

	public Color outterColor = new Color(0.133f, 1f, 0f, 1f);

	public GameObject[] targetsGroup1;

	public GameObject[] targetsGroup2;

	public Camera outterLineCamera;

	public Shader compositeShader;

	private Material m_CompositeMaterial;

	public Shader blurShader;

	private Material m_BlurMaterial;

	private Material m_outterLineMat;

	private RenderTexture outterLineTexture;

	protected Material compositeMaterial
	{
		get
		{
			if (m_CompositeMaterial == null)
			{
				m_CompositeMaterial = new Material(compositeShader);
				m_CompositeMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return m_CompositeMaterial;
		}
	}

	protected Material blurMaterial
	{
		get
		{
			if (m_BlurMaterial == null)
			{
				m_BlurMaterial = new Material(blurShader);
				m_BlurMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return m_BlurMaterial;
		}
	}

	protected Material outterLineMat
	{
		get
		{
			if (m_outterLineMat == null)
			{
				m_outterLineMat = new Material("Shader\"Hidden/SolidBody1\"{SubShader{Pass{Color(" + outterColor.r + "," + outterColor.g + "," + outterColor.b + "," + outterColor.a + ")}}}");
				m_outterLineMat.hideFlags = HideFlags.HideAndDontSave;
				m_outterLineMat.shader.hideFlags = HideFlags.HideAndDontSave;
			}
			return m_outterLineMat;
		}
	}

	private void Start()
	{
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
			return;
		}
		if (!blurMaterial.shader.isSupported)
		{
			base.enabled = false;
		}
		if (!compositeMaterial.shader.isSupported)
		{
			base.enabled = false;
		}
		if (!outterLineMat.shader.isSupported)
		{
			base.enabled = false;
		}
		GameObject[] array = targetsGroup1;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].AddComponent<ShowSelected>().outterColor = outterColor;
		}
		array = targetsGroup2;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].AddComponent<ShowSelectedBump>().outterColor = outterColor;
		}
		if (!outterLineTexture)
		{
			outterLineTexture = new RenderTexture(GetComponent<Camera>().pixelWidth, GetComponent<Camera>().pixelHeight, 16);
			outterLineTexture.hideFlags = HideFlags.DontSave;
		}
	}

	private void OnDisable()
	{
		if ((bool)outterLineTexture)
		{
			UnityEngine.Object.DestroyImmediate(outterLineTexture);
		}
		if ((bool)m_CompositeMaterial)
		{
			UnityEngine.Object.DestroyImmediate(m_CompositeMaterial);
		}
		if ((bool)m_BlurMaterial)
		{
			UnityEngine.Object.DestroyImmediate(m_BlurMaterial);
		}
		if ((bool)m_outterLineMat)
		{
			UnityEngine.Object.DestroyImmediate(m_outterLineMat);
		}
	}

	private void OnPreRender()
	{
		outterLineCamera.targetTexture = outterLineTexture;
		outterLineCamera.RenderWithShader(outterLineMat.shader, "");
	}

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		borderWidth = Mathf.Clamp(borderWidth, 1, 5);
		RenderTexture temporary = RenderTexture.GetTemporary(outterLineTexture.width, outterLineTexture.height, 0);
		Graphics.BlitMultiTap(outterLineTexture, temporary, blurMaterial, new Vector2(borderWidth, borderWidth));
		Graphics.Blit(source, destination);
		Graphics.Blit(temporary, destination, compositeMaterial);
		RenderTexture.ReleaseTemporary(temporary);
	}
}
[RequireComponent(typeof(Camera))]
public class SelectShader : MonoBehaviour
{
	public static SelectShader _instance;

	public int Iterations = 3;

	public float Spread = 0.7f;

	public Color outterColor = new Color(0.2f, 1f, 0f, 1f);

	public GameObject targetsGroup1;

	public GameObject[] targetsGroup2;

	public Camera outterLineCamera;

	public Shader compositeShader;

	private Material m_CompositeMaterial;

	public Shader blurShader;

	private Material m_BlurMaterial;

	public Shader cutoffShader;

	private Material m_cutoffMaterial;

	private Material m_outterLineMat;

	private RenderTexture outterLineTexture;

	protected Material compositeMaterial
	{
		get
		{
			if (m_CompositeMaterial == null)
			{
				m_CompositeMaterial = new Material(compositeShader);
				m_CompositeMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return m_CompositeMaterial;
		}
	}

	protected Material blurMaterial
	{
		get
		{
			if (m_BlurMaterial == null)
			{
				m_BlurMaterial = new Material(blurShader);
				m_BlurMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return m_BlurMaterial;
		}
	}

	protected Material cutoffMaterial
	{
		get
		{
			if (m_cutoffMaterial == null)
			{
				m_cutoffMaterial = new Material(cutoffShader);
				m_cutoffMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return m_cutoffMaterial;
		}
	}

	protected Material outterLineMat => m_outterLineMat;

	private void Awake()
	{
		_instance = this;
	}

	private void Start()
	{
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
			return;
		}
		if (!blurMaterial.shader.isSupported)
		{
			base.enabled = false;
		}
		if (!compositeMaterial.shader.isSupported)
		{
			base.enabled = false;
		}
		if (!cutoffMaterial.shader.isSupported)
		{
			base.enabled = false;
		}
		if ((bool)targetsGroup1)
		{
			targetsGroup1.AddComponent<ShowSelected>().outterColor = outterColor;
		}
		GameObject[] array = targetsGroup2;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].AddComponent<ShowSelectedBump>().outterColor = outterColor;
		}
		if (!outterLineTexture)
		{
			outterLineTexture = new RenderTexture(GetComponent<Camera>().pixelWidth, GetComponent<Camera>().pixelHeight, 16);
			outterLineTexture.hideFlags = HideFlags.DontSave;
		}
	}

	private void OnDisable()
	{
		if ((bool)outterLineTexture)
		{
			UnityEngine.Object.DestroyImmediate(outterLineTexture);
			outterLineTexture = null;
		}
		if ((bool)m_CompositeMaterial)
		{
			UnityEngine.Object.DestroyImmediate(m_CompositeMaterial);
		}
		if ((bool)m_BlurMaterial)
		{
			UnityEngine.Object.DestroyImmediate(m_BlurMaterial);
		}
		if ((bool)m_outterLineMat)
		{
			UnityEngine.Object.DestroyImmediate(m_outterLineMat);
		}
	}

	public void FourTapCone(RenderTexture source, RenderTexture dest, int iteration)
	{
		float num = 0.5f + (float)iteration * Spread;
		Graphics.BlitMultiTap(source, dest, blurMaterial, new Vector2(num, num), new Vector2(0f - num, num), new Vector2(num, 0f - num), new Vector2(0f - num, 0f - num));
	}

	private void OnPreRender()
	{
	}

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		Iterations = Mathf.Clamp(Iterations, 0, 15);
		Spread = Mathf.Clamp(Spread, 0.5f, 6f);
		RenderTexture temporary = RenderTexture.GetTemporary(outterLineTexture.width, outterLineTexture.height, 0);
		RenderTexture temporary2 = RenderTexture.GetTemporary(outterLineTexture.width, outterLineTexture.height, 0);
		Graphics.Blit(outterLineTexture, temporary);
		bool flag = true;
		for (int i = 0; i < Iterations; i++)
		{
			if (flag)
			{
				FourTapCone(temporary, temporary2, i);
			}
			else
			{
				FourTapCone(temporary2, temporary, i);
			}
			flag = !flag;
		}
		Graphics.Blit(source, destination);
		if (flag)
		{
			Graphics.Blit(outterLineTexture, temporary, cutoffMaterial);
			Graphics.Blit(temporary, destination, compositeMaterial);
		}
		else
		{
			Graphics.Blit(outterLineTexture, temporary2, cutoffMaterial);
			Graphics.Blit(temporary2, destination, compositeMaterial);
		}
		RenderTexture.ReleaseTemporary(temporary);
		RenderTexture.ReleaseTemporary(temporary2);
	}
}
public class ShowSelected : MonoBehaviour
{
	public static ShowSelected _instance;

	public Shader selectedShader;

	public Color outterColor;

	private Color innerColor;

	private Color myColor;

	private Shader myShader;

	private bool Selected;

	public bool 是否点击;

	public int i = -1;

	private void Awake()
	{
		_instance = this;
	}

	private void Start()
	{
		innerColor = Color.red;
		myColor = GetComponent<Renderer>().material.color;
		myShader = GetComponent<Renderer>().material.shader;
		selectedShader = Shader.Find("Hidden/RimLightSpce");
		if (!selectedShader)
		{
			base.enabled = false;
		}
	}

	private void Update()
	{
		GetComponent<Renderer>().material.shader = selectedShader;
		GetComponent<Renderer>().material.SetColor("_RimColor", outterColor);
	}

	private void onMouseDown()
	{
		MonoBehaviour.print("ddd");
		GetComponent<Renderer>().material.shader = selectedShader;
		GetComponent<Renderer>().material.SetColor("_RimColor", innerColor);
		是否点击 = true;
	}

	public void 颜色改变(string name, int noname)
	{
		if (SelectObject._instance.targetsGroup1.tag == name)
		{
			GetComponent<Renderer>().material.shader = selectedShader;
			GetComponent<Renderer>().material.SetColor("_RimColor", outterColor);
			GetComponent<Renderer>().material.SetTextureScale("_MainTex", new Vector2(10f, 10f));
		}
		else if (noname == 1)
		{
			GetComponent<Renderer>().material.color = myColor;
			GetComponent<Renderer>().material.shader = myShader;
		}
	}
}
public class ShowSelectedBump : MonoBehaviour
{
	public Shader selectedShader;

	public Color outterColor;

	private Color myColor;

	private Shader myShader;

	private SkinnedMeshRenderer sRenderer;

	private bool Selected;

	private void Start()
	{
		sRenderer = GetComponentInChildren<SkinnedMeshRenderer>();
		myColor = sRenderer.material.color;
		myShader = sRenderer.material.shader;
		selectedShader = Shader.Find("Hidden/RimLightSpecBump");
		if (!selectedShader)
		{
			base.enabled = false;
		}
	}

	private void SetLayerRecursively(GameObject obj, int newLayer)
	{
		obj.layer = newLayer;
		foreach (Transform item in obj.transform)
		{
			SetLayerRecursively(item.gameObject, newLayer);
		}
	}

	private void Update()
	{
	}

	private void OnMouseEnter()
	{
		sRenderer.material.shader = selectedShader;
		sRenderer.material.SetColor("_RimColor", outterColor);
	}

	private void OnMouseExit()
	{
		sRenderer.material.color = myColor;
		sRenderer.material.shader = myShader;
	}

	private void OnMouseDown()
	{
		Selected = !Selected;
		if (Selected)
		{
			SetLayerRecursively(base.gameObject, 8);
			GetComponent<Animation>().Play();
		}
		else
		{
			SetLayerRecursively(base.gameObject, 0);
			GetComponent<Animation>().Stop();
		}
	}
}
[DisallowMultipleComponent]
public class Outline : MonoBehaviour
{
	public enum Mode
	{
		OutlineAll,
		OutlineVisible,
		OutlineHidden,
		OutlineAndSilhouette,
		SilhouetteOnly
	}

	[Serializable]
	private class ListVector3
	{
		public List<Vector3> data;
	}

	private static HashSet<Mesh> registeredMeshes = new HashSet<Mesh>();

	[SerializeField]
	private Mode outlineMode;

	[SerializeField]
	private Color outlineColor = Color.white;

	[SerializeField]
	[Range(0f, 10f)]
	private float outlineWidth = 2f;

	[Header("Optional")]
	[SerializeField]
	[Tooltip("Precompute enabled: Per-vertex calculations are performed in the editor and serialized with the object. Precompute disabled: Per-vertex calculations are performed at runtime in Awake(). This may cause a pause for large meshes.")]
	private bool precomputeOutline;

	[SerializeField]
	[HideInInspector]
	private List<Mesh> bakeKeys = new List<Mesh>();

	[SerializeField]
	[HideInInspector]
	private List<ListVector3> bakeValues = new List<ListVector3>();

	private Renderer[] renderers;

	private Material outlineMaskMaterial;

	private Material outlineFillMaterial;

	private bool needsUpdate;

	public Mode OutlineMode
	{
		get
		{
			return outlineMode;
		}
		set
		{
			outlineMode = value;
			needsUpdate = true;
		}
	}

	public Color OutlineColor
	{
		get
		{
			return outlineColor;
		}
		set
		{
			outlineColor = value;
			needsUpdate = true;
		}
	}

	public float OutlineWidth
	{
		get
		{
			return outlineWidth;
		}
		set
		{
			outlineWidth = value;
			needsUpdate = true;
		}
	}

	private void Awake()
	{
		renderers = GetComponentsInChildren<Renderer>();
		outlineMaskMaterial = UnityEngine.Object.Instantiate(Resources.Load<Material>("Materials/OutlineMask"));
		outlineFillMaterial = UnityEngine.Object.Instantiate(Resources.Load<Material>("Materials/OutlineFill"));
		outlineMaskMaterial.name = "OutlineMask (Instance)";
		outlineFillMaterial.name = "OutlineFill (Instance)";
		LoadSmoothNormals();
		needsUpdate = true;
	}

	private void OnEnable()
	{
		Renderer[] array = renderers;
		foreach (Renderer obj in array)
		{
			List<Material> list = Enumerable.ToList(obj.sharedMaterials);
			list.Add(outlineMaskMaterial);
			list.Add(outlineFillMaterial);
			obj.materials = list.ToArray();
		}
	}

	private void OnValidate()
	{
		needsUpdate = true;
		if ((!precomputeOutline && bakeKeys.Count != 0) || bakeKeys.Count != bakeValues.Count)
		{
			bakeKeys.Clear();
			bakeValues.Clear();
		}
		if (precomputeOutline && bakeKeys.Count == 0)
		{
			Bake();
		}
	}

	private void Update()
	{
		if (needsUpdate)
		{
			needsUpdate = false;
			UpdateMaterialProperties();
		}
	}

	private void OnDisable()
	{
		Renderer[] array = renderers;
		foreach (Renderer obj in array)
		{
			List<Material> list = Enumerable.ToList(obj.sharedMaterials);
			list.Remove(outlineMaskMaterial);
			list.Remove(outlineFillMaterial);
			obj.materials = list.ToArray();
		}
	}

	private void OnDestroy()
	{
		UnityEngine.Object.Destroy(outlineMaskMaterial);
		UnityEngine.Object.Destroy(outlineFillMaterial);
	}

	private void Bake()
	{
		HashSet<Mesh> hashSet = new HashSet<Mesh>();
		MeshFilter[] componentsInChildren = GetComponentsInChildren<MeshFilter>();
		foreach (MeshFilter meshFilter in componentsInChildren)
		{
			if (hashSet.Add(meshFilter.sharedMesh))
			{
				List<Vector3> data = SmoothNormals(meshFilter.sharedMesh);
				bakeKeys.Add(meshFilter.sharedMesh);
				bakeValues.Add(new ListVector3
				{
					data = data
				});
			}
		}
	}

	private void LoadSmoothNormals()
	{
		MeshFilter[] componentsInChildren = GetComponentsInChildren<MeshFilter>();
		foreach (MeshFilter meshFilter in componentsInChildren)
		{
			if (registeredMeshes.Add(meshFilter.sharedMesh))
			{
				int num = bakeKeys.IndexOf(meshFilter.sharedMesh);
				List<Vector3> uvs = ((num >= 0) ? bakeValues[num].data : SmoothNormals(meshFilter.sharedMesh));
				meshFilter.sharedMesh.SetUVs(3, uvs);
				Renderer component = meshFilter.GetComponent<Renderer>();
				if (component != null)
				{
					CombineSubmeshes(meshFilter.sharedMesh, component.sharedMaterials);
				}
			}
		}
		SkinnedMeshRenderer[] componentsInChildren2 = GetComponentsInChildren<SkinnedMeshRenderer>();
		foreach (SkinnedMeshRenderer skinnedMeshRenderer in componentsInChildren2)
		{
			if (registeredMeshes.Add(skinnedMeshRenderer.sharedMesh))
			{
				skinnedMeshRenderer.sharedMesh.uv4 = new Vector2[skinnedMeshRenderer.sharedMesh.vertexCount];
				CombineSubmeshes(skinnedMeshRenderer.sharedMesh, skinnedMeshRenderer.sharedMaterials);
			}
		}
	}

	private List<Vector3> SmoothNormals(Mesh mesh)
	{
		IEnumerable<IGrouping<Vector3, KeyValuePair<Vector3, int>>> enumerable = from pair in mesh.vertices.Select((Vector3 vertex, int index) => new KeyValuePair<Vector3, int>(vertex, index))
			group pair by pair.Key;
		List<Vector3> list = new List<Vector3>(mesh.normals);
		foreach (IGrouping<Vector3, KeyValuePair<Vector3, int>> item in enumerable)
		{
			if (item.Count() == 1)
			{
				continue;
			}
			Vector3 zero = Vector3.zero;
			foreach (KeyValuePair<Vector3, int> item2 in item)
			{
				zero += list[item2.Value];
			}
			zero.Normalize();
			foreach (KeyValuePair<Vector3, int> item3 in item)
			{
				list[item3.Value] = zero;
			}
		}
		return list;
	}

	private void CombineSubmeshes(Mesh mesh, Material[] materials)
	{
		if (mesh.subMeshCount != 1 && mesh.subMeshCount <= materials.Length)
		{
			mesh.subMeshCount++;
			mesh.SetTriangles(mesh.triangles, mesh.subMeshCount - 1);
		}
	}

	private void UpdateMaterialProperties()
	{
		outlineFillMaterial.SetColor("_OutlineColor", outlineColor);
		switch (outlineMode)
		{
		case Mode.OutlineAll:
			outlineMaskMaterial.SetFloat("_ZTest", 8f);
			outlineFillMaterial.SetFloat("_ZTest", 8f);
			outlineFillMaterial.SetFloat("_OutlineWidth", outlineWidth);
			break;
		case Mode.OutlineVisible:
			outlineMaskMaterial.SetFloat("_ZTest", 8f);
			outlineFillMaterial.SetFloat("_ZTest", 4f);
			outlineFillMaterial.SetFloat("_OutlineWidth", outlineWidth);
			break;
		case Mode.OutlineHidden:
			outlineMaskMaterial.SetFloat("_ZTest", 8f);
			outlineFillMaterial.SetFloat("_ZTest", 5f);
			outlineFillMaterial.SetFloat("_OutlineWidth", outlineWidth);
			break;
		case Mode.OutlineAndSilhouette:
			outlineMaskMaterial.SetFloat("_ZTest", 4f);
			outlineFillMaterial.SetFloat("_ZTest", 8f);
			outlineFillMaterial.SetFloat("_OutlineWidth", outlineWidth);
			break;
		case Mode.SilhouetteOnly:
			outlineMaskMaterial.SetFloat("_ZTest", 4f);
			outlineFillMaterial.SetFloat("_ZTest", 5f);
			outlineFillMaterial.SetFloat("_OutlineWidth", 0f);
			break;
		}
	}
}
public class move : MonoBehaviour
{
	public float speed;

	private void FixedUpdate()
	{
		float axis = Input.GetAxis("Horizontal");
		float axis2 = Input.GetAxis("Vertical");
		Vector3 vector = new Vector3(axis, 0f, axis2);
		GetComponent<Rigidbody>().velocity = vector * speed;
	}
}
public class rotate : MonoBehaviour
{
	public float turnSpeed = 15f;

	private void Update()
	{
		base.transform.Rotate(Vector3.up, turnSpeed * Time.deltaTime);
	}
}
public class ActivateOnKeypress : MonoBehaviour
{
	public KeyCode ActivationKey = KeyCode.LeftControl;

	public int PriorityBoostAmount = 10;

	public GameObject Reticle;

	private CinemachineVirtualCameraBase vcam;

	private bool boosted;

	private void Start()
	{
		vcam = GetComponent<CinemachineVirtualCameraBase>();
	}

	private void Update()
	{
		if (vcam != null)
		{
			if (Input.GetKey(ActivationKey))
			{
				if (!boosted)
				{
					vcam.Priority += PriorityBoostAmount;
					boosted = true;
				}
			}
			else if (boosted)
			{
				vcam.Priority -= PriorityBoostAmount;
				boosted = false;
			}
		}
		if (Reticle != null)
		{
			Reticle.SetActive(boosted);
		}
	}
}
public class PlayerLookAt : MonoBehaviour
{
	public float speed = 5f;

	private void Update()
	{
		float yAngle = Input.GetAxis("Mouse X") * speed;
		float num = Input.GetAxis("Mouse Y") * speed;
		base.transform.Rotate(0f, yAngle, 0f, Space.World);
		base.transform.Rotate(0f - num, 0f, 0f, Space.Self);
	}
}
public class PlayerMovement : MonoBehaviour
{
	public float movementSpeed = 10f;

	public float lookatspeed = 5f;

	private void Update()
	{
		if (Input.GetKey("w"))
		{
			base.transform.position += base.transform.TransformDirection(Vector3.forward) * Time.deltaTime * movementSpeed;
		}
		else if (Input.GetKey("s"))
		{
			base.transform.position -= base.transform.TransformDirection(Vector3.forward) * Time.deltaTime * movementSpeed;
		}
		if (Input.GetKey("a") && !Input.GetKey("d"))
		{
			base.transform.position += base.transform.TransformDirection(Vector3.left) * Time.deltaTime * movementSpeed;
		}
		else if (Input.GetKey("d") && !Input.GetKey("a"))
		{
			base.transform.position -= base.transform.TransformDirection(Vector3.left) * Time.deltaTime * movementSpeed;
		}
		float yAngle = Input.GetAxis("Mouse X") * lookatspeed;
		Input.GetAxis("Mouse Y");
		_ = lookatspeed;
		base.transform.Rotate(0f, yAngle, 0f, Space.World);
	}
}
public class TagChanger : MonoBehaviour
{
	public void PlayerTagChanger()
	{
		base.tag = "Player";
	}

	public void UntaggedTagChanger()
	{
		base.tag = "Untagged";
	}
}
public class BossLookAt : MonoBehaviour
{
	[Tooltip("Look at this transform")]
	public Transform m_LookAt;

	[Tooltip("Lock the camera's X rotation to this value (in angles)")]
	public float m_RotationX;

	[Tooltip("Lock the camera's Z rotation to this value (in angles)")]
	public float m_RotationZ;

	private void Update()
	{
		base.transform.LookAt(m_LookAt);
		Vector3 eulerAngles = base.transform.rotation.eulerAngles;
		base.transform.rotation = Quaternion.Euler(m_RotationX, eulerAngles.y, m_RotationZ);
	}
}
[ExecuteAlways]
[SaveDuringPlay]
[AddComponentMenu("")]
public class CustomLockCameraY : CinemachineExtension
{
	[Tooltip("Lock the camera's Y position to this value")]
	public float m_YPosition = 10f;

	protected override void PostPipelineStageCallback(CinemachineVirtualCameraBase vcam, CinemachineCore.Stage stage, ref CameraState state, float deltaTime)
	{
		if (stage == CinemachineCore.Stage.Finalize)
		{
			Vector3 rawPosition = state.RawPosition;
			rawPosition.y = m_YPosition;
			state.RawPosition = rawPosition;
		}
	}
}
[ExecuteInEditMode]
public class CameraMagnetProperty : MonoBehaviour
{
	[Range(0.1f, 50f)]
	public float MagnetStrength = 5f;

	[Range(0.1f, 50f)]
	public float Proximity = 5f;

	public Transform ProximityVisualization;

	[HideInInspector]
	public Transform myTransform;

	private void Start()
	{
		myTransform = base.transform;
	}

	private void Update()
	{
		if (ProximityVisualization != null)
		{
			ProximityVisualization.localScale = new Vector3(Proximity * 2f, Proximity * 2f, 1f);
		}
	}
}
public class CameraMagnetTargetController : MonoBehaviour
{
	public CinemachineTargetGroup targetGroup;

	private int playerIndex;

	private CameraMagnetProperty[] cameraMagnets;

	private void Start()
	{
		cameraMagnets = GetComponentsInChildren<CameraMagnetProperty>();
		playerIndex = 0;
	}

	private void Update()
	{
		for (int i = 1; i < targetGroup.m_Targets.Length; i++)
		{
			float magnitude = (targetGroup.m_Targets[playerIndex].target.position - targetGroup.m_Targets[i].target.position).magnitude;
			if (magnitude < cameraMagnets[i - 1].Proximity)
			{
				targetGroup.m_Targets[i].weight = cameraMagnets[i - 1].MagnetStrength * (1f - magnitude / cameraMagnets[i - 1].Proximity);
			}
			else
			{
				targetGroup.m_Targets[i].weight = 0f;
			}
		}
	}
}
public class MoveAimTarget : MonoBehaviour
{
	public CinemachineBrain Brain;

	public RectTransform ReticleImage;

	[Tooltip("How far to raycast to place the aim target")]
	public float AimDistance;

	[Tooltip("Objects on these layers will be detected")]
	public LayerMask CollideAgainst;

	[TagField]
	[Tooltip("Obstacles with this tag will be ignored.  It's a good idea to set this field to the player's tag")]
	public string IgnoreTag = string.Empty;

	[Header("Axis Control")]
	[Tooltip("The Vertical axis.  Value is -90..90. Controls the vertical orientation")]
	[AxisStateProperty]
	public AxisState VerticalAxis;

	[Tooltip("The Horizontal axis.  Value is -180..180.  Controls the horizontal orientation")]
	[AxisStateProperty]
	public AxisState HorizontalAxis;

	private void OnValidate()
	{
		VerticalAxis.Validate();
		HorizontalAxis.Validate();
		AimDistance = Mathf.Max(1f, AimDistance);
	}

	private void Reset()
	{
		AimDistance = 200f;
		ReticleImage = null;
		CollideAgainst = 1;
		IgnoreTag = string.Empty;
		VerticalAxis = new AxisState(-70f, 70f, wrap: false, rangeLocked: false, 10f, 0.1f, 0.1f, "Mouse Y", invert: true);
		VerticalAxis.m_SpeedMode = AxisState.SpeedMode.InputValueGain;
		HorizontalAxis = new AxisState(-180f, 180f, wrap: true, rangeLocked: false, 10f, 0.1f, 0.1f, "Mouse X", invert: false);
		HorizontalAxis.m_SpeedMode = AxisState.SpeedMode.InputValueGain;
	}

	private void OnEnable()
	{
		CinemachineCore.CameraUpdatedEvent.RemoveListener(PlaceReticle);
		CinemachineCore.CameraUpdatedEvent.AddListener(PlaceReticle);
	}

	private void OnDisable()
	{
		CinemachineCore.CameraUpdatedEvent.RemoveListener(PlaceReticle);
	}

	private void Update()
	{
		if (!(Brain == null))
		{
			HorizontalAxis.Update(Time.deltaTime);
			VerticalAxis.Update(Time.deltaTime);
			PlaceTarget();
		}
	}

	private void PlaceTarget()
	{
		Quaternion quaternion = Quaternion.Euler(VerticalAxis.Value, HorizontalAxis.Value, 0f);
		Vector3 rawPosition = Brain.CurrentCameraState.RawPosition;
		base.transform.position = GetProjectedAimTarget(rawPosition + quaternion * Vector3.forward, rawPosition);
	}

	private Vector3 GetProjectedAimTarget(Vector3 pos, Vector3 camPos)
	{
		Vector3 origin = pos;
		Vector3 normalized = (pos - camPos).normalized;
		pos += AimDistance * normalized;
		if ((int)CollideAgainst != 0 && RaycastIgnoreTag(new Ray(origin, normalized), out var hitInfo, AimDistance, CollideAgainst))
		{
			pos = hitInfo.point;
		}
		return pos;
	}

	private bool RaycastIgnoreTag(Ray ray, out RaycastHit hitInfo, float rayLength, int layerMask)
	{
		float num = 0f;
		while (Physics.Raycast(ray, out hitInfo, rayLength, layerMask, QueryTriggerInteraction.Ignore))
		{
			if (IgnoreTag.Length == 0 || !hitInfo.collider.CompareTag(IgnoreTag))
			{
				hitInfo.distance += num;
				return true;
			}
			Ray ray2 = new Ray(ray.GetPoint(rayLength), -ray.direction);
			if (!hitInfo.collider.Raycast(ray2, out hitInfo, rayLength))
			{
				break;
			}
			float num2 = rayLength - (hitInfo.distance - 0.001f);
			if (num2 < 0.001f)
			{
				break;
			}
			num += num2;
			rayLength = hitInfo.distance - 0.001f;
			if (rayLength < 0.001f)
			{
				break;
			}
			ray.origin = ray2.GetPoint(rayLength);
		}
		return false;
	}

	private void PlaceReticle(CinemachineBrain brain)
	{
		if (!(brain == null) && !(brain != Brain) && !(ReticleImage == null) && !(brain.OutputCamera == null))
		{
			PlaceTarget();
			_ = brain.CurrentCameraState;
			Camera outputCamera = brain.OutputCamera;
			Vector3 vector = outputCamera.WorldToScreenPoint(base.transform.position);
			Vector2 anchoredPosition = new Vector2(vector.x - (float)outputCamera.pixelWidth * 0.5f, vector.y - (float)outputCamera.pixelHeight * 0.5f);
			ReticleImage.anchoredPosition = anchoredPosition;
		}
	}
}
public class PointAtAimTarget : MonoBehaviour
{
	[Tooltip("This object represents the aim target.  We always point toeards this")]
	public Transform AimTarget;

	private void Update()
	{
		if (!(AimTarget == null))
		{
			Vector3 forward = AimTarget.position - base.transform.position;
			if (forward.sqrMagnitude > 0.01f)
			{
				base.transform.rotation = Quaternion.LookRotation(forward);
			}
		}
	}
}
public class CharacterMovementNoCamera : MonoBehaviour
{
	public Transform InvisibleCameraOrigin;

	public float StrafeSpeed = 0.1f;

	public float TurnSpeed = 3f;

	public float Damping = 0.2f;

	public float VerticalRotMin = -80f;

	public float VerticalRotMax = 80f;

	public KeyCode sprintJoystick = KeyCode.JoystickButton2;

	public KeyCode sprintKeyboard = KeyCode.Space;

	private bool isSprinting;

	private Animator anim;

	private float currentStrafeSpeed;

	private Vector2 currentVelocity;

	private void OnEnable()
	{
		anim = GetComponent<Animator>();
		currentVelocity = Vector2.zero;
		currentStrafeSpeed = 0f;
		isSprinting = false;
	}

	private void FixedUpdate()
	{
		Vector2 vector = new Vector2(Input.GetAxis("Horizontal"), Input.GetAxis("Vertical"));
		float y = vector.y;
		y = Mathf.Clamp(y, -1f, 1f);
		y = Mathf.SmoothDamp(anim.GetFloat("Speed"), y, ref currentVelocity.y, Damping);
		anim.SetFloat("Speed", y);
		anim.SetFloat("Direction", y);
		isSprinting = (Input.GetKey(sprintJoystick) || Input.GetKey(sprintKeyboard)) && y > 0f;
		anim.SetBool("isSprinting", isSprinting);
		currentStrafeSpeed = Mathf.SmoothDamp(currentStrafeSpeed, vector.x * StrafeSpeed, ref currentVelocity.x, Damping);
		base.transform.position += base.transform.TransformDirection(Vector3.right) * currentStrafeSpeed;
		Vector2 vector2 = new Vector2(Input.GetAxis("Mouse X"), Input.GetAxis("Mouse Y"));
		Vector3 eulerAngles = base.transform.eulerAngles;
		eulerAngles.y += vector2.x * TurnSpeed;
		base.transform.rotation = Quaternion.Euler(eulerAngles);
		if (InvisibleCameraOrigin != null)
		{
			eulerAngles = InvisibleCameraOrigin.localRotation.eulerAngles;
			eulerAngles.x -= vector2.y * TurnSpeed;
			if (eulerAngles.x > 180f)
			{
				eulerAngles.x -= 360f;
			}
			eulerAngles.x = Mathf.Clamp(eulerAngles.x, VerticalRotMin, VerticalRotMax);
			InvisibleCameraOrigin.localRotation = Quaternion.Euler(eulerAngles);
		}
	}
}
public class PlayerMove : MonoBehaviour
{
	public enum ForwardMode
	{
		Camera,
		Player,
		World
	}

	public float Speed;

	public float VelocityDamping;

	public float JumpTime;

	public ForwardMode InputForward;

	public bool RotatePlayer = true;

	public Action SpaceAction;

	public Action EnterAction;

	private Vector3 m_currentVleocity;

	private float m_currentJumpSpeed;

	private float m_restY;

	private void Reset()
	{
		Speed = 5f;
		InputForward = ForwardMode.Camera;
		RotatePlayer = true;
		VelocityDamping = 0.5f;
		m_currentVleocity = Vector3.zero;
		JumpTime = 1f;
		m_currentJumpSpeed = 0f;
	}

	private void OnEnable()
	{
		m_currentJumpSpeed = 0f;
		m_restY = base.transform.position.y;
		SpaceAction = (Action)Delegate.Remove(SpaceAction, new Action(Jump));
		SpaceAction = (Action)Delegate.Combine(SpaceAction, new Action(Jump));
	}

	private void Update()
	{
		Vector3 vector = InputForward switch
		{
			ForwardMode.Camera => Camera.main.transform.forward, 
			ForwardMode.Player => base.transform.forward, 
			_ => Vector3.forward, 
		};
		vector.y = 0f;
		vector = vector.normalized;
		if (!(vector.sqrMagnitude < 0.01f))
		{
			Quaternion quaternion = Quaternion.LookRotation(vector, Vector3.up);
			Vector3 vector2 = new Vector3(Input.GetAxis("Horizontal"), 0f, Input.GetAxis("Vertical"));
			vector2 = quaternion * vector2;
			float deltaTime = Time.deltaTime;
			Vector3 initial = vector2 * Speed - m_currentVleocity;
			m_currentVleocity += Damper.Damp(initial, VelocityDamping, deltaTime);
			base.transform.position += m_currentVleocity * deltaTime;
			if (RotatePlayer && m_currentVleocity.sqrMagnitude > 0.01f)
			{
				Quaternion rotation = base.transform.rotation;
				Quaternion b = Quaternion.LookRotation((InputForward == ForwardMode.Player && Vector3.Dot(vector, m_currentVleocity) < 0f) ? (-m_currentVleocity) : m_currentVleocity);
				base.transform.rotation = Quaternion.Slerp(rotation, b, Damper.Damp(1f, VelocityDamping, deltaTime));
			}
			if (m_currentJumpSpeed != 0f)
			{
				m_currentJumpSpeed -= 10f * deltaTime;
			}
			Vector3 position = base.transform.position;
			position.y += m_currentJumpSpeed * deltaTime;
			if (position.y < m_restY)
			{
				position.y = m_restY;
				m_currentJumpSpeed = 0f;
			}
			base.transform.position = position;
			if (Input.GetKeyDown(KeyCode.Space) && SpaceAction != null)
			{
				SpaceAction();
			}
			if (Input.GetKeyDown(KeyCode.Return) && EnterAction != null)
			{
				EnterAction();
			}
		}
	}

	public void Jump()
	{
		m_currentJumpSpeed += 10f * JumpTime * 0.5f;
	}
}
public class PlayerMoveOnSphere : MonoBehaviour
{
	public SphereCollider Sphere;

	public float speed = 5f;

	public bool rotatePlayer = true;

	public float rotationDamping = 0.5f;

	private void Update()
	{
		Vector3 vector = new Vector3(Input.GetAxis("Horizontal"), 0f, Input.GetAxis("Vertical"));
		if (vector.magnitude > 0f)
		{
			vector = Camera.main.transform.rotation * vector;
			if (vector.magnitude > 0.001f)
			{
				base.transform.position += vector * (speed * Time.deltaTime);
				if (rotatePlayer)
				{
					float t = Damper.Damp(1f, rotationDamping, Time.deltaTime);
					Quaternion b = Quaternion.LookRotation(vector.normalized, base.transform.up);
					base.transform.rotation = Quaternion.Slerp(base.transform.rotation, b, t);
				}
			}
		}
		if (Sphere != null)
		{
			Vector3 normalized = (base.transform.position - Sphere.transform.position).normalized;
			Vector3 forward = base.transform.forward.ProjectOntoPlane(normalized);
			base.transform.position = Sphere.transform.position + normalized * (Sphere.radius + base.transform.localScale.y / 2f);
			base.transform.rotation = Quaternion.LookRotation(forward, normalized);
		}
	}
}
public class PlayerMovePhysics : MonoBehaviour
{
	public float speed = 5f;

	public bool worldDirection = true;

	public bool rotatePlayer = true;

	public Action spaceAction;

	public Action enterAction;

	private Rigidbody rb;

	private void Start()
	{
		rb = GetComponent<Rigidbody>();
	}

	private void OnEnable()
	{
		base.transform.position += new Vector3(10f, 0f, 0f);
	}

	private void FixedUpdate()
	{
		Vector3 vector = new Vector3(Input.GetAxis("Horizontal"), 0f, Input.GetAxis("Vertical"));
		if (vector.magnitude > 0f)
		{
			Vector3 vector2 = (worldDirection ? Vector3.forward : (base.transform.position - Camera.main.transform.position));
			vector2.y = 0f;
			vector2 = vector2.normalized;
			if (vector2.magnitude > 0.001f)
			{
				vector = Quaternion.LookRotation(vector2, Vector3.up) * vector;
				if (vector.magnitude > 0.001f)
				{
					rb.AddForce(speed * vector);
					if (rotatePlayer)
					{
						base.transform.rotation = Quaternion.LookRotation(vector.normalized, Vector3.up);
					}
				}
			}
		}
		if (Input.GetKeyDown(KeyCode.Space) && spaceAction != null)
		{
			spaceAction();
		}
		if (Input.GetKeyDown(KeyCode.Return) && enterAction != null)
		{
			enterAction();
		}
	}
}
public class SimpleElevator : MonoBehaviour
{
	public float minY;

	public float maxY;

	public float speed;

	public bool on;

	private float m_Direction = 1f;

	private void FixedUpdate()
	{
		if (base.transform.position.y < minY)
		{
			m_Direction = 1f;
		}
		if (base.transform.position.y > maxY)
		{
			m_Direction = -1f;
		}
		Vector3 vector = new Vector3(0f, m_Direction * speed * Time.fixedDeltaTime, 0f);
		base.transform.position += vector;
	}
}
public class SpawnInCircle : MonoBehaviour
{
	public GameObject Prefab;

	public float Radius = 1000f;

	public float Amount = 10000f;

	public bool DoIt;

	private void Update()
	{
		if (DoIt && Prefab != null)
		{
			Vector3 position = base.transform.position;
			Quaternion rotation = base.transform.rotation;
			for (int i = 0; (float)i < Amount; i++)
			{
				int num = UnityEngine.Random.Range(0, 360);
				Vector3 vector = new Vector3(Mathf.Cos(num), 0f, Mathf.Sin(num));
				vector = position + vector * Mathf.Sqrt(UnityEngine.Random.Range(0f, 1f)) * Radius;
				UnityEngine.Object.Instantiate(Prefab, vector, rotation, base.transform.parent);
			}
		}
		DoIt = false;
	}
}
[DisplayStringFormat("{multiplier}*{stick}")]
public class CustomComposite : InputBindingComposite<Vector2>
{
	[InputControl(layout = "Axis")]
	public int multiplier;

	[InputControl(layout = "Vector2")]
	public int stick;

	public float scaleFactor = 1f;

	[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
	private static void Initialize()
	{
		InputSystem.RegisterBindingComposite<CustomComposite>();
	}

	public override Vector2 ReadValue(ref InputBindingCompositeContext context)
	{
		Vector2 vector = context.ReadValue<Vector2, Vector2MagnitudeComparer>(stick);
		float num = context.ReadValue<float>(multiplier);
		return vector * (num * scaleFactor);
	}
}
public static class InitCustomDeviceUsages
{
	static InitCustomDeviceUsages()
	{
		Initialize();
	}

	[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
	private static void Initialize()
	{
		InputSystem.RegisterLayoutOverride("\n            {\n                \"name\" : \"GamepadPlayerUsageTags\",\n                \"extend\" : \"Gamepad\",\n                \"commonUsages\" : [\n                    \"Player1\", \"Player2\"\n                ]\n            }\n        ");
	}
}
public class CustomDeviceUsages : MonoBehaviour
{
	public int gamepadIndex;

	public string usageTag;

	private Gamepad m_Gamepad;

	protected void OnEnable()
	{
		if (gamepadIndex >= 0 && gamepadIndex < Gamepad.all.Count)
		{
			m_Gamepad = Gamepad.all[gamepadIndex];
			InputSystem.AddDeviceUsage(m_Gamepad, usageTag);
		}
	}

	protected void OnDisable()
	{
		if (m_Gamepad != null && m_Gamepad.added)
		{
			InputSystem.RemoveDeviceUsage(m_Gamepad, usageTag);
		}
		m_Gamepad = null;
	}
}
public struct CustomDeviceState : IInputStateTypeInfo
{
	[InputControl(name = "firstButton", layout = "Button", bit = 0u, displayName = "First Button")]
	[InputControl(name = "secondButton", layout = "Button", bit = 1u, displayName = "Second Button")]
	[InputControl(name = "thirdButton", layout = "Button", bit = 2u, displayName = "Third Button")]
	public ushort buttons;

	[InputControl(name = "stick", format = "VC2B", layout = "Stick", displayName = "Main Stick")]
	[InputControl(name = "stick/x", defaultState = 127, format = "BYTE", offset = 0u, parameters = "normalize,normalizeMin=0,normalizeMax=1,normalizeZero=0.5")]
	public byte x;

	[InputControl(name = "stick/y", defaultState = 127, format = "BYTE", offset = 1u, parameters = "normalize,normalizeMin=0,normalizeMax=1,normalizeZero=0.5")]
	[InputControl(name = "stick/up", parameters = "normalize,normalizeMin=0,normalizeMax=1,normalizeZero=0.5,clamp=2,clampMin=0,clampMax=1")]
	[InputControl(name = "stick/down", parameters = "normalize,normalizeMin=0,normalizeMax=1,normalizeZero=0.5,clamp=2,clampMin=-1,clampMax=0,invert")]
	[InputControl(name = "stick/left", parameters = "normalize,normalizeMin=0,normalizeMax=1,normalizeZero=0.5,clamp=2,clampMin=-1,clampMax=0,invert")]
	[InputControl(name = "stick/right", parameters = "normalize,normalizeMin=0,normalizeMax=1,normalizeZero=0.5,clamp=2,clampMin=0,clampMax=1")]
	public byte y;

	public FourCC format => new FourCC('C', 'U', 'S', 'T');
}
[InputControlLayout(stateType = typeof(CustomDeviceState))]
public class CustomDevice : UnityEngine.InputSystem.InputDevice, IInputUpdateCallbackReceiver
{
	public ButtonControl firstButton { get; private set; }

	public ButtonControl secondButton { get; private set; }

	public ButtonControl thirdButton { get; private set; }

	public StickControl stick { get; private set; }

	public static CustomDevice current { get; private set; }

	[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
	private static void Initialize()
	{
		InputSystem.RegisterLayout<CustomDevice>(null, default(InputDeviceMatcher).WithInterface("Custom"));
	}

	protected override void FinishSetup()
	{
		base.FinishSetup();
		firstButton = GetChildControl<ButtonControl>("firstButton");
		secondButton = GetChildControl<ButtonControl>("secondButton");
		thirdButton = GetChildControl<ButtonControl>("thirdButton");
		stick = GetChildControl<StickControl>("stick");
	}

	public override void MakeCurrent()
	{
		base.MakeCurrent();
		current = this;
	}

	protected override void OnRemoved()
	{
		base.OnRemoved();
		if (current == this)
		{
			current = null;
		}
	}

	public void OnUpdate()
	{
		Keyboard keyboard = Keyboard.current;
		if (keyboard != null)
		{
			CustomDeviceState state = default(CustomDeviceState);
			state.x = 127;
			state.y = 127;
			bool isPressed = keyboard.wKey.isPressed;
			bool isPressed2 = keyboard.aKey.isPressed;
			bool isPressed3 = keyboard.sKey.isPressed;
			bool isPressed4 = keyboard.dKey.isPressed;
			if (isPressed2)
			{
				state.x -= 127;
			}
			if (isPressed4)
			{
				state.x += 127;
			}
			if (isPressed)
			{
				state.y += 127;
			}
			if (isPressed3)
			{
				state.y -= 127;
			}
			if (keyboard.digit1Key.isPressed)
			{
				state.buttons |= 1;
			}
			if (keyboard.digit2Key.isPressed)
			{
				state.buttons |= 2;
			}
			if (keyboard.digit3Key.isPressed)
			{
				state.buttons |= 4;
			}
			InputSystem.QueueStateEvent(this, state);
		}
	}
}
public class SimpleController_UsingActionAsset : MonoBehaviour
{
	public float moveSpeed;

	public float rotateSpeed;

	public float burstSpeed;

	public GameObject projectile;

	private SimpleControls m_Controls;

	private bool m_Charging;

	private Vector2 m_Rotation;

	public void Awake()
	{
		m_Controls = new SimpleControls();
		m_Controls.gameplay.fire.performed += delegate(InputAction.CallbackContext ctx)
		{
			if (ctx.interaction is SlowTapInteraction)
			{
				StartCoroutine(BurstFire((int)(ctx.duration * (double)burstSpeed)));
			}
			else
			{
				Fire();
			}
			m_Charging = false;
		};
		m_Controls.gameplay.fire.started += delegate(InputAction.CallbackContext ctx)
		{
			if (ctx.interaction is SlowTapInteraction)
			{
				m_Charging = true;
			}
		};
		m_Controls.gameplay.fire.canceled += delegate
		{
			m_Charging = false;
		};
	}

	public void OnEnable()
	{
		m_Controls.Enable();
	}

	public void OnDisable()
	{
		m_Controls.Disable();
	}

	public void OnGUI()
	{
		if (m_Charging)
		{
			GUI.Label(new Rect(100f, 100f, 200f, 100f), "Charging...");
		}
	}

	public void Update()
	{
		Vector2 vector = m_Controls.gameplay.look.ReadValue<Vector2>();
		Vector2 direction = m_Controls.gameplay.move.ReadValue<Vector2>();
		Look(vector);
		Move(direction);
	}

	private void Move(Vector2 direction)
	{
		if (!((double)direction.sqrMagnitude < 0.01))
		{
			float num = moveSpeed * Time.deltaTime;
			Vector3 vector = Quaternion.Euler(0f, base.transform.eulerAngles.y, 0f) * new Vector3(direction.x, 0f, direction.y);
			base.transform.position += vector * num;
		}
	}

	private void Look(Vector2 rotate)
	{
		if (!((double)rotate.sqrMagnitude < 0.01))
		{
			float num = rotateSpeed * Time.deltaTime;
			m_Rotation.y += rotate.x * num;
			m_Rotation.x = Mathf.Clamp(m_Rotation.x - rotate.y * num, -89f, 89f);
			base.transform.localEulerAngles = m_Rotation;
		}
	}

	private IEnumerator BurstFire(int burstAmount)
	{
		int i = 0;
		while (i < burstAmount)
		{
			Fire();
			yield return new WaitForSeconds(0.1f);
			int num = i + 1;
			i = num;
		}
	}

	private void Fire()
	{
		Transform transform = base.transform;
		GameObject obj = UnityEngine.Object.Instantiate(projectile);
		obj.transform.position = transform.position + transform.forward * 0.6f;
		obj.transform.rotation = transform.rotation;
		obj.transform.localScale *= 1f;
		obj.GetComponent<Rigidbody>().mass = Mathf.Pow(1f, 3f);
		obj.GetComponent<Rigidbody>().AddForce(transform.forward * 20f, ForceMode.Impulse);
		obj.GetComponent<MeshRenderer>().material.color = new Color(UnityEngine.Random.value, UnityEngine.Random.value, UnityEngine.Random.value, 1f);
	}
}
public class SimpleController_UsingActions : MonoBehaviour
{
	public float moveSpeed;

	public float rotateSpeed;

	public float burstSpeed;

	public GameObject projectile;

	public InputAction moveAction;

	public InputAction lookAction;

	public InputAction fireAction;

	private bool m_Charging;

	private Vector2 m_Rotation;

	public void Awake()
	{
		fireAction.performed += delegate(InputAction.CallbackContext ctx)
		{
			if (ctx.interaction is SlowTapInteraction)
			{
				StartCoroutine(BurstFire((int)(ctx.duration * (double)burstSpeed)));
			}
			else
			{
				Fire();
			}
			m_Charging = false;
		};
		fireAction.started += delegate(InputAction.CallbackContext ctx)
		{
			if (ctx.interaction is SlowTapInteraction)
			{
				m_Charging = true;
			}
		};
		fireAction.canceled += delegate
		{
			m_Charging = false;
		};
	}

	public void OnEnable()
	{
		moveAction.Enable();
		lookAction.Enable();
		fireAction.Enable();
	}

	public void OnDisable()
	{
		moveAction.Disable();
		lookAction.Disable();
		fireAction.Disable();
	}

	public void OnGUI()
	{
		if (m_Charging)
		{
			GUI.Label(new Rect(100f, 100f, 200f, 100f), "Charging...");
		}
	}

	public void Update()
	{
		Vector2 vector = lookAction.ReadValue<Vector2>();
		Vector2 direction = moveAction.ReadValue<Vector2>();
		Look(vector);
		Move(direction);
	}

	private void Move(Vector2 direction)
	{
		if (!((double)direction.sqrMagnitude < 0.01))
		{
			float num = moveSpeed * Time.deltaTime;
			Vector3 vector = Quaternion.Euler(0f, base.transform.eulerAngles.y, 0f) * new Vector3(direction.x, 0f, direction.y);
			base.transform.position += vector * num;
		}
	}

	private void Look(Vector2 rotate)
	{
		if (!((double)rotate.sqrMagnitude < 0.01))
		{
			float num = rotateSpeed * Time.deltaTime;
			m_Rotation.y += rotate.x * num;
			m_Rotation.x = Mathf.Clamp(m_Rotation.x - rotate.y * num, -89f, 89f);
			base.transform.localEulerAngles = m_Rotation;
		}
	}

	private IEnumerator BurstFire(int burstAmount)
	{
		int i = 0;
		while (i < burstAmount)
		{
			Fire();
			yield return new WaitForSeconds(0.1f);
			int num = i + 1;
			i = num;
		}
	}

	private void Fire()
	{
		Transform transform = base.transform;
		GameObject obj = UnityEngine.Object.Instantiate(projectile);
		obj.transform.position = transform.position + transform.forward * 0.6f;
		obj.transform.rotation = transform.rotation;
		int num = 1;
		obj.transform.localScale *= (float)num;
		obj.GetComponent<Rigidbody>().mass = Mathf.Pow(num, 3f);
		obj.GetComponent<Rigidbody>().AddForce(transform.forward * 20f, ForceMode.Impulse);
		obj.GetComponent<MeshRenderer>().material.color = new Color(UnityEngine.Random.value, UnityEngine.Random.value, UnityEngine.Random.value, 1f);
	}
}
public class SimpleController_UsingPlayerInput : MonoBehaviour
{
	public float moveSpeed;

	public float rotateSpeed;

	public float burstSpeed;

	public GameObject projectile;

	private bool m_Charging;

	private Vector2 m_Rotation;

	private Vector2 m_Look;

	private Vector2 m_Move;

	public void OnMove(InputAction.CallbackContext context)
	{
		m_Move = context.ReadValue<Vector2>();
	}

	public void OnLook(InputAction.CallbackContext context)
	{
		m_Look = context.ReadValue<Vector2>();
	}

	public void OnFire(InputAction.CallbackContext context)
	{
		switch (context.phase)
		{
		case InputActionPhase.Performed:
			if (context.interaction is SlowTapInteraction)
			{
				StartCoroutine(BurstFire((int)(context.duration * (double)burstSpeed)));
			}
			else
			{
				Fire();
			}
			m_Charging = false;
			break;
		case InputActionPhase.Started:
			if (context.interaction is SlowTapInteraction)
			{
				m_Charging = true;
			}
			break;
		case InputActionPhase.Canceled:
			m_Charging = false;
			break;
		}
	}

	public void OnGUI()
	{
		if (m_Charging)
		{
			GUI.Label(new Rect(100f, 100f, 200f, 100f), "Charging...");
		}
	}

	public void Update()
	{
		Look(m_Look);
		Move(m_Move);
	}

	private void Move(Vector2 direction)
	{
		if (!((double)direction.sqrMagnitude < 0.01))
		{
			float num = moveSpeed * Time.deltaTime;
			Vector3 vector = Quaternion.Euler(0f, base.transform.eulerAngles.y, 0f) * new Vector3(direction.x, 0f, direction.y);
			base.transform.position += vector * num;
		}
	}

	private void Look(Vector2 rotate)
	{
		if (!((double)rotate.sqrMagnitude < 0.01))
		{
			float num = rotateSpeed * Time.deltaTime;
			m_Rotation.y += rotate.x * num;
			m_Rotation.x = Mathf.Clamp(m_Rotation.x - rotate.y * num, -89f, 89f);
			base.transform.localEulerAngles = m_Rotation;
		}
	}

	private IEnumerator BurstFire(int burstAmount)
	{
		int i = 0;
		while (i < burstAmount)
		{
			Fire();
			yield return new WaitForSeconds(0.1f);
			int num = i + 1;
			i = num;
		}
	}

	private void Fire()
	{
		Transform transform = base.transform;
		GameObject obj = UnityEngine.Object.Instantiate(projectile);
		obj.transform.position = transform.position + transform.forward * 0.6f;
		obj.transform.rotation = transform.rotation;
		obj.transform.localScale *= 1f;
		obj.GetComponent<Rigidbody>().mass = Mathf.Pow(1f, 3f);
		obj.GetComponent<Rigidbody>().AddForce(transform.forward * 20f, ForceMode.Impulse);
		obj.GetComponent<MeshRenderer>().material.color = new Color(UnityEngine.Random.value, UnityEngine.Random.value, UnityEngine.Random.value, 1f);
	}
}
public class SimpleController_UsingState : MonoBehaviour
{
	public float moveSpeed;

	public float rotateSpeed;

	public GameObject projectile;

	private Vector2 m_Rotation;

	private bool m_Firing;

	private float m_FireCooldown;

	public void Update()
	{
		Gamepad current = Gamepad.current;
		if (current != null)
		{
			Vector2 direction = current.leftStick.ReadValue();
			Vector2 vector = current.rightStick.ReadValue();
			Look(vector);
			Move(direction);
			if (current.buttonSouth.wasPressedThisFrame)
			{
				m_Firing = true;
				m_FireCooldown = 0f;
			}
			else if (current.buttonSouth.wasReleasedThisFrame)
			{
				m_Firing = false;
			}
			if (m_Firing && m_FireCooldown < Time.time)
			{
				Fire();
				m_FireCooldown = Time.time + 0.1f;
			}
		}
	}

	private void Move(Vector2 direction)
	{
		if (!((double)direction.sqrMagnitude < 0.01))
		{
			float num = moveSpeed * Time.deltaTime;
			Vector3 vector = Quaternion.Euler(0f, base.transform.eulerAngles.y, 0f) * new Vector3(direction.x, 0f, direction.y);
			base.transform.position += vector * num;
		}
	}

	private void Look(Vector2 rotate)
	{
		if (!((double)rotate.sqrMagnitude < 0.01))
		{
			float num = rotateSpeed * Time.deltaTime;
			m_Rotation.y += rotate.x * num;
			m_Rotation.x = Mathf.Clamp(m_Rotation.x - rotate.y * num, -89f, 89f);
			base.transform.localEulerAngles = m_Rotation;
		}
	}

	private void Fire()
	{
		Transform transform = base.transform;
		GameObject obj = UnityEngine.Object.Instantiate(projectile);
		obj.transform.position = transform.position + transform.forward * 0.6f;
		obj.transform.rotation = transform.rotation;
		obj.transform.localScale *= 1f;
		obj.GetComponent<Rigidbody>().mass = Mathf.Pow(1f, 3f);
		obj.GetComponent<Rigidbody>().AddForce(transform.forward * 20f, ForceMode.Impulse);
		obj.GetComponent<MeshRenderer>().material.color = new Color(UnityEngine.Random.value, UnityEngine.Random.value, UnityEngine.Random.value, 1f);
	}
}
public class SimpleControls : IInputActionCollection2, IInputActionCollection, IEnumerable<InputAction>, IEnumerable, IDisposable
{
	public struct GameplayActions
	{
		private SimpleControls m_Wrapper;

		public InputAction fire => m_Wrapper.m_gameplay_fire;

		public InputAction move => m_Wrapper.m_gameplay_move;

		public InputAction look => m_Wrapper.m_gameplay_look;

		public bool enabled => Get().enabled;

		public GameplayActions(SimpleControls wrapper)
		{
			m_Wrapper = wrapper;
		}

		public InputActionMap Get()
		{
			return m_Wrapper.m_gameplay;
		}

		public void Enable()
		{
			Get().Enable();
		}

		public void Disable()
		{
			Get().Disable();
		}

		public static implicit operator InputActionMap(GameplayActions set)
		{
			return set.Get();
		}

		public void SetCallbacks(IGameplayActions instance)
		{
			if (m_Wrapper.m_GameplayActionsCallbackInterface != null)
			{
				fire.started -= m_Wrapper.m_GameplayActionsCallbackInterface.OnFire;
				fire.performed -= m_Wrapper.m_GameplayActionsCallbackInterface.OnFire;
				fire.canceled -= m_Wrapper.m_GameplayActionsCallbackInterface.OnFire;
				move.started -= m_Wrapper.m_GameplayActionsCallbackInterface.OnMove;
				move.performed -= m_Wrapper.m_GameplayActionsCallbackInterface.OnMove;
				move.canceled -= m_Wrapper.m_GameplayActionsCallbackInterface.OnMove;
				look.started -= m_Wrapper.m_GameplayActionsCallbackInterface.OnLook;
				look.performed -= m_Wrapper.m_GameplayActionsCallbackInterface.OnLook;
				look.canceled -= m_Wrapper.m_GameplayActionsCallbackInterface.OnLook;
			}
			m_Wrapper.m_GameplayActionsCallbackInterface = instance;
			if (instance != null)
			{
				fire.started += instance.OnFire;
				fire.performed += instance.OnFire;
				fire.canceled += instance.OnFire;
				move.started += instance.OnMove;
				move.performed += instance.OnMove;
				move.canceled += instance.OnMove;
				look.started += instance.OnLook;
				look.performed += instance.OnLook;
				look.canceled += instance.OnLook;
			}
		}
	}

	public interface IGameplayActions
	{
		void OnFire(InputAction.CallbackContext context);

		void OnMove(InputAction.CallbackContext context);

		void OnLook(InputAction.CallbackContext context);
	}

	private readonly InputActionMap m_gameplay;

	private IGameplayActions m_GameplayActionsCallbackInterface;

	private readonly InputAction m_gameplay_fire;

	private readonly InputAction m_gameplay_move;

	private readonly InputAction m_gameplay_look;

	public InputActionAsset asset { get; }

	public InputBinding? bindingMask
	{
		get
		{
			return asset.bindingMask;
		}
		set
		{
			asset.bindingMask = value;
		}
	}

	public ReadOnlyArray<UnityEngine.InputSystem.InputDevice>? devices
	{
		get
		{
			return asset.devices;
		}
		set
		{
			asset.devices = value;
		}
	}

	public ReadOnlyArray<InputControlScheme> controlSchemes => asset.controlSchemes;

	public IEnumerable<InputBinding> bindings => asset.bindings;

	public GameplayActions gameplay => new GameplayActions(this);

	public SimpleControls()
	{
		asset = InputActionAsset.FromJson("{\n    \"name\": \"SimpleControls\",\n    \"maps\": [\n        {\n            \"name\": \"gameplay\",\n            \"id\": \"265c38f5-dd18-4d34-b198-aec58e1627ff\",\n            \"actions\": [\n                {\n                    \"name\": \"fire\",\n                    \"type\": \"Button\",\n                    \"id\": \"1077f913-a9f9-41b1-acb3-b9ee0adbc744\",\n                    \"expectedControlType\": \"Button\",\n                    \"processors\": \"\",\n                    \"interactions\": \"Tap,SlowTap\",\n                    \"initialStateCheck\": false\n                },\n                {\n                    \"name\": \"move\",\n                    \"type\": \"Value\",\n                    \"id\": \"50fd2809-3aa3-4a90-988e-1facf6773553\",\n                    \"expectedControlType\": \"Vector2\",\n                    \"processors\": \"\",\n                    \"interactions\": \"\",\n                    \"initialStateCheck\": true\n                },\n                {\n                    \"name\": \"look\",\n                    \"type\": \"Value\",\n                    \"id\": \"c60e0974-d140-4597-a40e-9862193067e9\",\n                    \"expectedControlType\": \"Vector2\",\n                    \"processors\": \"\",\n                    \"interactions\": \"\",\n                    \"initialStateCheck\": true\n                }\n            ],\n            \"bindings\": [\n                {\n                    \"name\": \"\",\n                    \"id\": \"abb776f3-f329-4f7b-bbf8-b577d13be018\",\n                    \"path\": \"*/{PrimaryAction}\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"\",\n                    \"action\": \"fire\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"\",\n                    \"id\": \"e1b8c4dd-7b3a-4db6-a93a-0889b59b1afc\",\n                    \"path\": \"<Gamepad>/leftStick\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"\",\n                    \"action\": \"move\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"Dpad\",\n                    \"id\": \"cefc16fc-557a-44b0-939f-2ad792876b07\",\n                    \"path\": \"Dpad\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"\",\n                    \"action\": \"move\",\n                    \"isComposite\": true,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"up\",\n                    \"id\": \"07244659-79df-461d-b329-defbe2fbc5f6\",\n                    \"path\": \"<Keyboard>/w\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"\",\n                    \"action\": \"move\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": true\n                },\n                {\n                    \"name\": \"down\",\n                    \"id\": \"f0ec75cb-f02c-40d2-a33f-1fd6eab2ae0b\",\n                    \"path\": \"<Keyboard>/s\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"\",\n                    \"action\": \"move\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": true\n                },\n                {\n                    \"name\": \"left\",\n                    \"id\": \"21fe6bfe-4721-4483-9f4a-a0031ade105c\",\n                    \"path\": \"<Keyboard>/a\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"\",\n                    \"action\": \"move\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": true\n                },\n                {\n                    \"name\": \"right\",\n                    \"id\": \"2dd39746-c75c-4a11-838a-e59eacaf4e0b\",\n                    \"path\": \"<Keyboard>/d\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"\",\n                    \"action\": \"move\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": true\n                },\n                {\n                    \"name\": \"\",\n                    \"id\": \"c106d6e6-2780-47ff-b318-396171bd54cc\",\n                    \"path\": \"<Gamepad>/rightStick\",\n                    \"interactions\": \"\",\n                    \"processors\": \"\",\n                    \"groups\": \"\",\n                    \"action\": \"look\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                },\n                {\n                    \"name\": \"\",\n                    \"id\": \"578caa03-6827-4797-adfc-a59770c437fe\",\n                    \"path\": \"<Pointer>/delta\",\n                    \"interactions\": \"\",\n                    \"processors\": \"ScaleVector2(x=2,y=2)\",\n                    \"groups\": \"\",\n                    \"action\": \"look\",\n                    \"isComposite\": false,\n                    \"isPartOfComposite\": false\n                }\n            ]\n        }\n    ],\n    \"controlSchemes\": []\n}");
		m_gameplay = asset.FindActionMap("gameplay", throwIfNotFound: true);
		m_gameplay_fire = m_gameplay.FindAction("fire", throwIfNotFound: true);
		m_gameplay_move = m_gameplay.FindAction("move", throwIfNotFound: true);
		m_gameplay_look = m_gameplay.FindAction("look", throwIfNotFound: true);
	}

	public void Dispose()
	{
		UnityEngine.Object.Destroy(asset);
	}

	public bool Contains(InputAction action)
	{
		return asset.Contains(action);
	}

	public IEnumerator<InputAction> GetEnumerator()
	{
		return asset.GetEnumerator();
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return GetEnumerator();
	}

	public void Enable()
	{
		asset.Enable();
	}

	public void Disable()
	{
		asset.Disable();
	}

	public InputAction FindAction(string actionNameOrId, bool throwIfNotFound = false)
	{
		return asset.FindAction(actionNameOrId, throwIfNotFound);
	}

	public int FindBinding(InputBinding bindingMask, out InputAction action)
	{
		return asset.FindBinding(bindingMask, out action);
	}
}
public class SimpleMultiplayerPlayer : MonoBehaviour
{
	public void OnTeleport()
	{
		base.transform.position = new Vector3(UnityEngine.Random.Range(-75, 75), 0.5f, UnityEngine.Random.Range(-75, 75));
	}
}
public class UnityRemoteTestScript : MonoBehaviour
{
	public Camera camera;

	public Text accelerometerInputText;

	public Text touchInputText;

	public Text gyroInputText;

	public Transform rotatingCube;

	private Vector3 m_Rotation;

	private float m_CubeOffsetFromCanvas;

	private Vector3 m_CubeStartingPosition;

	public void ResetCube()
	{
		rotatingCube.SetPositionAndRotation(m_CubeStartingPosition, default(Quaternion));
	}

	private void OnEnable()
	{
		m_CubeOffsetFromCanvas = rotatingCube.position.z - base.transform.position.z;
		m_CubeStartingPosition = rotatingCube.position;
		EnhancedTouchSupport.Enable();
	}

	private void OnDisable()
	{
		EnhancedTouchSupport.Disable();
	}

	private void Update()
	{
		UpdateTouch();
		UpdateAccelerometer();
		UpdateGyro();
	}

	private void UpdateTouch()
	{
		Touchscreen remoteDevice = GetRemoteDevice<Touchscreen>();
		if (remoteDevice == null)
		{
			touchInputText.text = "No remote touchscreen found.";
			return;
		}
		string text = null;
		foreach (UnityEngine.InputSystem.EnhancedTouch.Touch activeTouch in UnityEngine.InputSystem.EnhancedTouch.Touch.activeTouches)
		{
			if (activeTouch.screen == remoteDevice)
			{
				if (text == null)
				{
					text = "Active Touches:\n";
				}
				text += $"\nid={activeTouch.touchId} phase={activeTouch.phase} position={activeTouch.screenPosition} pressure={activeTouch.pressure}\n";
			}
		}
		if (text == null)
		{
			text = "No active touches.";
		}
		touchInputText.text = text;
		if (remoteDevice.primaryTouch.isInProgress)
		{
			Vector2 vector = remoteDevice.primaryTouch.position.ReadValue();
			Vector3 position = camera.ScreenToWorldPoint(new Vector3(vector.x, vector.y, base.transform.position.z + m_CubeOffsetFromCanvas));
			rotatingCube.position = position;
		}
	}

	private void UpdateAccelerometer()
	{
		Accelerometer remoteDevice = GetRemoteDevice<Accelerometer>();
		if (remoteDevice == null)
		{
			accelerometerInputText.text = "No remote accelerometer found.";
			return;
		}
		Vector3 vector = remoteDevice.acceleration.ReadValue();
		accelerometerInputText.text = $"Accelerometer: x={vector.x} y={vector.y} z={vector.z}";
	}

	private void UpdateGyro()
	{
		UnityEngine.InputSystem.Gyroscope remoteDevice = GetRemoteDevice<UnityEngine.InputSystem.Gyroscope>();
		AttitudeSensor remoteDevice2 = GetRemoteDevice<AttitudeSensor>();
		GravitySensor remoteDevice3 = GetRemoteDevice<GravitySensor>();
		LinearAccelerationSensor remoteDevice4 = GetRemoteDevice<LinearAccelerationSensor>();
		EnableDeviceIfNeeded(remoteDevice);
		EnableDeviceIfNeeded(remoteDevice2);
		EnableDeviceIfNeeded(remoteDevice3);
		EnableDeviceIfNeeded(remoteDevice4);
		string text;
		if (remoteDevice == null && remoteDevice2 == null && remoteDevice3 == null && remoteDevice4 == null)
		{
			text = "No remote gyro found.";
		}
		else
		{
			string text2 = null;
			string text3 = null;
			string text4 = null;
			string text5 = null;
			if (remoteDevice != null)
			{
				Vector3 vector = remoteDevice.angularVelocity.ReadValue();
				text2 = $"Rotation: x={vector.x} y={vector.y} z={vector.z}";
				m_Rotation += vector;
				rotatingCube.localEulerAngles = m_Rotation;
			}
			if (remoteDevice2 != null)
			{
				Quaternion quaternion = remoteDevice2.attitude.ReadValue();
				text3 = $"Attitude: x={quaternion.x} y={quaternion.y} z={quaternion.z} w={quaternion.w}";
			}
			if (remoteDevice3 != null)
			{
				Vector3 vector2 = remoteDevice3.gravity.ReadValue();
				text4 = $"Gravity: x={vector2.x} y={vector2.y} z={vector2.z}";
			}
			if (remoteDevice4 != null)
			{
				Vector3 vector3 = remoteDevice4.acceleration.ReadValue();
				text5 = $"Acceleration: x={vector3.x} y={vector3.y} z={vector3.z}";
			}
			text = string.Join("\n", text2, text3, text4, text5);
		}
		gyroInputText.text = text;
	}

	private static void EnableDeviceIfNeeded(UnityEngine.InputSystem.InputDevice device)
	{
		if (device != null && !device.enabled)
		{
			InputSystem.EnableDevice(device);
		}
	}

	private static TDevice GetRemoteDevice<TDevice>() where TDevice : UnityEngine.InputSystem.InputDevice
	{
		foreach (UnityEngine.InputSystem.InputDevice device in InputSystem.devices)
		{
			if (device.remote && device is TDevice result)
			{
				return result;
			}
		}
		return null;
	}
}
public class a : MonoBehaviour
{
	public Text T;

	public GameObject 发送消息;

	public string url = "https://openapi.baidu.com/oauth/2.0/token";

	public string token;

	private IEnumerator Start()
	{
		WWWForm wWWForm = new WWWForm();
		wWWForm.AddField("grant_type", "client_credentials");
		wWWForm.AddField("client_id", "xZOmb7xgblGZXeyg0OSxIW4z");
		wWWForm.AddField("client_secret", "z67jsE0tKEGigSOViaV11Eo6Qj669dGy");
		WWW getData = new WWW(url, wWWForm);
		yield return getData;
		if (getData.error != null)
		{
			UnityEngine.Debug.Log("【语】错：" + getData.error);
			yield break;
		}
		UnityEngine.Debug.Log("【语】肉：" + getData.text);
		JsonData jsonData = JsonMapper.ToObject(getData.text);
		token = (string)jsonData["access_token"];
	}

	public IEnumerator uploadVoice(byte[] postData)
	{
		WWWForm wWWForm = new WWWForm();
		UnityEngine.Debug.Log("读取wav文件。大小: " + postData.Length + " bytes");
		Dictionary<string, string> headers = wWWForm.headers;
		headers["Method"] = "POST";
		headers["Content-Type"] = "audio/wav; rate=8000";
		headers["Content-Length"] = postData.Length.ToString();
		T.text = "准备发送数据";
		wWWForm.AddBinaryData("fileUpload", postData, "flacFile", "audio/wav; rate=8000");
		WWW getData = new WWW("http://vop.baidu.com/server_api?lan=zh&cuid=vr&token=" + token, wWWForm.data, headers);
		yield return getData;
		if (getData.error != null)
		{
			T.text = getData.error;
			UnityEngine.Debug.Log("【语】错：" + getData.error);
			yield break;
		}
		UnityEngine.Debug.Log("【语】肉：" + getData.text);
		Regex regex = new Regex("[一-龥]+");
		string text = "";
		foreach (Match item in regex.Matches(getData.text))
		{
			text += item.Value;
			switch (item.Value)
			{
			case "开灯":
				发送消息.SendMessage("开灯", "");
				break;
			case "关灯":
				发送消息.SendMessage("关灯", "");
				break;
			case "跑":
			case "泡":
			case "炮":
			case "好":
			case "抛":
				发送消息.SendMessage("跑", "");
				break;
			case "猫":
			case "毛":
			case "包":
			case "矛":
			case "么":
				发送消息.SendMessage("猫", "");
				break;
			case "滚":
			case "棍":
			case "关":
			case "个":
				发送消息.SendMessage("滚", "");
				break;
			case "摇头":
				发送消息.SendMessage("摇头", "");
				break;
			case "躺下":
				发送消息.SendMessage("躺下", "");
				break;
			}
		}
		T.text = text;
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.A))
		{
			base.gameObject.SendMessage("关灯", "");
			UnityEngine.Debug.Log("A 关灯：");
		}
		if (Input.GetKeyDown(KeyCode.B))
		{
			base.gameObject.SendMessage("跑", "");
			UnityEngine.Debug.Log("B 跑：");
		}
		if (Input.GetKeyDown(KeyCode.C))
		{
			base.gameObject.SendMessage("猫", "");
			UnityEngine.Debug.Log("C 猫：");
		}
		if (Input.GetKeyDown(KeyCode.D))
		{
			base.gameObject.SendMessage("开灯", "");
			UnityEngine.Debug.Log("D 开灯：");
		}
	}
}
public class GetMessage : MonoBehaviour
{
	public SkinnedMeshRenderer Panda;

	public Animator 熊猫动作;

	public Light 灯;

	public void 开灯()
	{
		灯.enabled = true;
	}

	public void 关灯()
	{
		灯.enabled = false;
	}

	public void 跑()
	{
		熊猫动作.Play("zou");
	}

	public void 猫()
	{
		Panda.enabled = true;
	}

	public void 滚()
	{
		熊猫动作.Play("gun");
	}

	public void 摇头()
	{
		熊猫动作.Play("yaotou");
	}

	public void 躺下()
	{
		熊猫动作.Play("tangxia");
	}
}
public class MicrophoneTest : MonoBehaviour
{
	public AudioSource 公韵;

	public 语 公语;

	private AudioClip 公颂;

	public UnityEngine.XR.InputDevice device;

	private void Start()
	{
	}

	private void Update()
	{
		device = InputDevices.GetDeviceAtXRNode(XRNode.LeftHand);
		device.TryGetFeatureValue(UnityEngine.XR.CommonUsages.menuButton, out var _);
	}

	public void 始语()
	{
		UnityEngine.Debug.Log("始语");
		公韵.clip = Microphone.Start(Microphone.devices[0], loop: false, 10, 8000);
	}

	public void 末语()
	{
		UnityEngine.Debug.Log("末语");
		Microphone.End(Microphone.devices[0]);
	}

	public void 语播()
	{
		UnityEngine.Debug.Log("语播");
		公韵.Play();
		float[] array = new float[公韵.clip.samples];
		公韵.clip.GetData(array, 0);
		short[] array2 = new short[array.Length];
		byte[] array3 = new byte[array.Length * 2];
		int num = 32767;
		for (int i = 0; i < array.Length; i++)
		{
			array2[i] = (short)(array[i] * (float)num);
			_ = new byte[2];
			BitConverter.GetBytes(array2[i]).CopyTo(array3, i * 2);
		}
		StartCoroutine(公语.语音识别(array3));
	}

	private void OnGUI()
	{
		if (GUI.Button(new Rect(0f, 0f, 200f, 60f), "录音"))
		{
			始语();
		}
		if (GUI.Button(new Rect(0f, 60f, 200f, 60f), "停止"))
		{
			末语();
		}
		if (GUI.Button(new Rect(0f, 120f, 200f, 60f), "播放"))
		{
			语播();
		}
	}
}
public class Resolution : MonoBehaviour
{
	public Camera mainCamera;

	private void Start()
	{
		mainCamera = Camera.main;
		mainCamera.aspect = 1.78f;
	}
}
public class AnimatorContol : MonoBehaviour
{
	public Animator animator;

	private void Start()
	{
	}

	private void Update()
	{
		if (Add.intance_.已生成)
		{
			MonoBehaviour.print("1111111111正在播放动画");
			Invoke("InvokePlay", 5f);
		}
	}

	private void InvokePlay()
	{
		animator.SetBool("isEnter", value: true);
	}
}
public class 妥造 : MonoBehaviour
{
	private GameObject 枝轴点;

	private GameObject 私摆点;

	private GameObject 私态;

	public GameObject 它;

	public GameObject 公组;

	public string 类型;

	private string 串删除的类型;

	public string 删除的坐标;

	public Collider[] 尤碰撞物;

	public Transform 锁定的坐标;

	public int 几倍 = 10;

	public int 几余 = 1;

	public Vector3 几撑;

	public Vector3 positionChange;

	public string 广;

	public 佐 第一级UI;

	private float 公浮横;

	private float 公浮纵;

	private float 公浮深;

	private void Awake()
	{
		几撑 = new Vector3(-0.01f, -0.01f, -0.01f);
	}

	private void Start()
	{
		枝轴点 = GameObject.Find("/XR Origin/Camera Offset/RightHand Controller/枝轴点");
		私摆点 = GameObject.Find("/XR Origin/Camera Offset/RightHand Controller/愚");
	}

	private void Update()
	{
		if (佑.逮.公为摆 || 佑.逮.公为喷)
		{
			base.transform.position = new Vector3(私摆点.transform.position.x, 私摆点.transform.position.y, 私摆点.transform.position.z);
		}
		else
		{
			base.transform.position = 枝轴点.transform.position;
		}
		if ((!佑.逮.公为移 || !佑.逮.公为挪 || !佑.逮.公为撑) && (bool)佐.逮.该)
		{
			公浮横 = 佐.逮.该.transform.position.x;
			公浮纵 = 佐.逮.该.transform.position.y;
			公浮深 = 佐.逮.该.transform.position.z;
		}
		if (佑.逮.公为扳机 && !佑.逮.公为删 && !佑.逮.公为选)
		{
			float num = 改横();
			float num2 = 改纵();
			float num3 = 改深();
			int layerMask = 256;
			float radius = 0.0495f;
			佐.逮.公讲.text = "横" + num + "纵" + num2 + "深" + num3;
			GameObject.Find("/=造/组调/球调").transform.localPosition = new Vector3(num + 0.05f, num2 + 0.05f, num3 - 0.05f);
			尤碰撞物 = Physics.OverlapSphere(new Vector3(num + 0.05f, num2 + 0.05f, num3 - 0.05f), radius, layerMask);
			if (尤碰撞物.Length != 0)
			{
				return;
			}
			if (佑.逮.公为造)
			{
				它 = Resources.Load("预制/" + 佐.逮.造啥) as GameObject;
			}
			else if (佑.逮.公为广)
			{
				它 = 佑.逮.它;
			}
			if (佑.逮.无锁定 && 佑.逮.公为移)
			{
				if ((bool)佐.逮.该)
				{
					佐.逮.该.transform.localPosition = base.transform.localPosition;
				}
			}
			else if (佑.逮.无锁定 && 佑.逮.公为挪)
			{
				if ((bool)佐.逮.该)
				{
					望(佐.逮.该.transform, base.transform.position, Vector3.up);
				}
			}
			else if (佑.逮.无锁定 && 佑.逮.公为撑)
			{
				float num4 = (num - 公浮横) * 10f;
				float num5 = (num2 - 公浮纵) * 10f;
				float num6 = (num3 - 公浮深) * -10f;
				if (num4 == 0f)
				{
					num4 = 1f;
				}
				if (num5 == 0f)
				{
					num5 = 1f;
				}
				if (num6 == 0f)
				{
					num6 = 1f;
				}
				if ((bool)佐.逮.该)
				{
					佐.逮.该.transform.localScale = new Vector3(num4, num5, num6);
				}
			}
			else if (佑.逮.无锁定 && 佑.逮.公为广)
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(它, new Vector3(num, num2, num3), Quaternion.identity);
				gameObject.transform.localRotation = Quaternion.Euler(0f, 180f, 0f);
				佐.逮.公几量++;
				佐.逮.公量.text = 佐.逮.公几量.ToString();
				gameObject.transform.SetParent(公组.transform);
				佐.逮.该 = gameObject;
			}
			else if ((佑.逮.无锁定 && 佑.逮.公为造) || (佑.逮.无锁定 && 佑.逮.公为摆))
			{
				Vector3 position = new Vector3(num, num2, num3);
				if ((bool)它)
				{
					它 = Resources.Load("预制/" + 佐.逮.造啥) as GameObject;
				}
				GameObject gameObject2 = UnityEngine.Object.Instantiate(它, position, 佑.逮.它.transform.localRotation);
				佐.逮.公几量++;
				佐.逮.公量.text = 佐.逮.公几量.ToString();
				gameObject2.transform.localScale = 佑.逮.它.transform.localScale;
				gameObject2.transform.SetParent(公组.transform);
				佐.逮.该 = gameObject2;
			}
			if (佑.逮.锁定XY)
			{
				UnityEngine.Object.Instantiate(它, new Vector3(改横(), 改纵(), 佑.逮.几锁深), Quaternion.identity).transform.SetParent(公组.transform);
			}
			if (佑.逮.锁定XZ)
			{
				UnityEngine.Object.Instantiate(它, new Vector3(改横(), 改纵(), 改深()), Quaternion.identity).transform.SetParent(公组.transform);
			}
			if (佑.逮.锁定YZ)
			{
				UnityEngine.Object.Instantiate(它, new Vector3(改横(), 改纵(), 改深()), Quaternion.identity).transform.SetParent(公组.transform);
			}
		}
		else if (佑.逮.公为扳机 && 佑.逮.公为删)
		{
			float num7 = 0.0095f;
			尤碰撞物 = Physics.OverlapSphere(new Vector3(改横(), 改纵(), 改深()), num7 - 0.02f, 256);
			if (尤碰撞物.Length >= 1)
			{
				Collider[] array = 尤碰撞物;
				foreach (Collider collider in array)
				{
					Regex regex = new Regex("[一-龥]+");
					串删除的类型 = regex.Matches(collider.name)[0].Value;
					删除的坐标 = collider.gameObject.transform.position.x + "," + collider.gameObject.transform.position.y + "," + collider.gameObject.transform.position.z + "," + 串删除的类型 + "|";
					UnityEngine.Object.DestroyImmediate(collider.gameObject);
				}
			}
		}
		else
		{
			if (!佑.逮.公为扳机 || !佑.逮.公为选)
			{
				return;
			}
			尤碰撞物 = Physics.OverlapSphere(new Vector3(改横(), 改纵(), 改深()), 0.05f, 256);
			if (尤碰撞物.Length < 1)
			{
				return;
			}
			Collider[] array = 尤碰撞物;
			foreach (Collider collider2 in array)
			{
				new Regex("[一-龥]+");
				GameObject gameObject3 = collider2.transform.parent.gameObject;
				佐.逮.该 = gameObject3;
				if (无此尤(gameObject3))
				{
					佑.逮.公尤阵选.Add(gameObject3);
					佑.逮.醒(collider2.gameObject, 佑.逮.公材醒);
				}
			}
		}
	}

	public bool 无此尤(GameObject 尤参)
	{
		foreach (GameObject item in 佑.逮.公尤阵选)
		{
			if (item == 尤参)
			{
				return false;
			}
		}
		return true;
	}

	public void 望(Transform tr_self, Vector3 lookPos, Vector3 directionAxis)
	{
		Quaternion rotation = tr_self.rotation;
		Vector3 vector = lookPos - tr_self.position;
		Vector3 vector2 = tr_self.rotation * directionAxis;
		Vector3 normalized = Vector3.Cross(vector2, vector).normalized;
		float angle = Vector3.Angle(vector2, vector);
		tr_self.rotation = Quaternion.AngleAxis(angle, normalized) * rotation;
		tr_self.localEulerAngles = new Vector3(0f, tr_self.localEulerAngles.y, 90f);
	}

	public float 改横()
	{
		float num = ((!佑.逮.公为摆 && !佑.逮.公为喷) ? 枝轴点.transform.position.x : 私摆点.transform.position.x);
		float num2 = num * (float)几倍;
		float num3 = Mathf.Round(num2);
		if (num2 < num3 && num3 % (float)几余 != 0f)
		{
			num3 -= 1f;
			return num3 / (float)几倍;
		}
		if (num2 < num3 && num3 % (float)几余 == 0f)
		{
			return num3 / (float)几倍;
		}
		if (num2 > num3 && num3 % (float)几余 != 0f)
		{
			num3 += 1f;
			return num3 / (float)几倍;
		}
		if (num2 > num3 && num3 % (float)几余 == 0f)
		{
			return num3 / (float)几倍;
		}
		return 0f;
	}

	public float 改纵()
	{
		float num = ((!佑.逮.公为摆 && !佑.逮.公为喷) ? 枝轴点.transform.position.y : 私摆点.transform.position.y);
		float num2 = num * (float)几倍;
		float num3 = Mathf.Round(num2);
		if (num2 < num3 && num3 % (float)几余 != 0f)
		{
			num3 -= 1f;
			return num3 / (float)几倍;
		}
		if (num2 < num3 && num3 % (float)几余 == 0f)
		{
			return num3 / (float)几倍;
		}
		if (num2 > num3 && num3 % (float)几余 != 0f)
		{
			num3 += 1f;
			return num3 / (float)几倍;
		}
		if (num2 > num3 && num3 % (float)几余 == 0f)
		{
			return num3 / (float)几倍;
		}
		return 0f;
	}

	public float 改深()
	{
		float num = ((!佑.逮.公为摆 && !佑.逮.公为喷) ? 枝轴点.transform.position.z : 私摆点.transform.position.z);
		float num2 = num * (float)几倍;
		float num3 = Mathf.Round(num2);
		if (num2 < num3 && num3 % (float)几余 != 0f)
		{
			num3 -= 1f;
			return num3 / (float)几倍;
		}
		if (num2 < num3 && num3 % (float)几余 == 0f)
		{
			return num3 / (float)几倍;
		}
		if (num2 > num3 && num3 % (float)几余 != 0f)
		{
			num3 += 1f;
			return num3 / (float)几倍;
		}
		if (num2 > num3 && num3 % (float)几余 == 0f)
		{
			return num3 / (float)几倍;
		}
		return 0f;
	}
}
public class SetParent : MonoBehaviour
{
	public static SetParent _instan;

	private GameObject VR插件;

	private void Awake()
	{
		_instan = this;
		VR插件 = GameObject.Find("[CameraRig]");
	}

	private void Start()
	{
		base.transform.parent = VR插件.transform;
	}

	private void Update()
	{
	}
}
public class TextContol : MonoBehaviour
{
	public Text 我的气泡;

	private float 计时点;

	public GameObject 整个气泡;

	private void Start()
	{
		计时点 = 0f;
		整个气泡.SetActive(value: false);
	}

	private void Update()
	{
		if (Add.intance_.已发送消息)
		{
			整个气泡.SetActive(value: true);
		}
		if (我的气泡.text != "")
		{
			计时点 += Time.deltaTime;
			if (计时点 > 8f)
			{
				计时点 = 0f;
				我的气泡.text = "";
				整个气泡.SetActive(value: false);
				Add.intance_.已发送消息 = false;
			}
		}
	}
}
public class Add : MonoBehaviour
{
	public static Add intance_;

	public GameObject 人物;

	public GameObject 人物1;

	public GameObject 人物2;

	public Text 我的头顶气泡;

	public Vector3 位置;

	public SocketIOComponent 套接;

	private ectScript 函字符串分割;

	private GameObject 我的气泡;

	public Text 发送框;

	public GameObject 自己对话;

	public GameObject 对方对话;

	public Vector3 对话位置;

	public Image 面板;

	public GameObject 面板1;

	private GameObject 对话;

	private GameObject 另对话;

	private Vector3 另位置;

	public bool 已生成;

	public bool 已发送消息;

	private string[] myIntArray = new string[3] { "10774", "11111", "19999" };

	private void Awake()
	{
		intance_ = this;
		另位置 = new Vector3(0f, 0f, 0f);
		已生成 = false;
		已发送消息 = false;
	}

	private void Start()
	{
		StaticFuction.VR框 = GameObject.Find("[CameraRig]");
		GameObject gameObject = GameObject.Find("SocketIO");
		套接 = gameObject.GetComponent<SocketIOComponent>();
		函字符串分割 = gameObject.GetComponent<ectScript>();
		套接.On("新人加进来了", 新人加进来了);
		套接.On("嗨新人我的位置在这里", 嗨新人我的位置在这里);
		套接.On("接收消息", 接收消息);
		位置 = new Vector3(0f, 0f, 0f);
		if (类脑.微我号 == myIntArray[0])
		{
			类脑.主角 = UnityEngine.Object.Instantiate(人物, 位置, Quaternion.identity);
			已生成 = true;
		}
		else if (类脑.微我号 == myIntArray[1])
		{
			类脑.主角 = UnityEngine.Object.Instantiate(人物1, 位置, Quaternion.identity);
			已生成 = true;
		}
		else if (类脑.微我号 == myIntArray[2])
		{
			类脑.主角 = UnityEngine.Object.Instantiate(人物2, 位置, Quaternion.identity);
			已生成 = true;
		}
		类脑.主角.name = 类脑.微我号;
		我的头顶气泡 = GameObject.Find(类脑.主角.name).gameObject.transform.Find("深灰透明底框/气泡/Text").GetComponent<Text>();
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		dictionary["position"] = 位置.x + "," + 位置.y + "," + 位置.z;
		套接.Emit("新人加入", new JSONObject(dictionary));
		类脑.主角.AddComponent<PlayerMove>();
		类脑.主角.AddComponent<SetParent>();
	}

	public void 别人移动(SocketIOEvent 参数)
	{
		MonoBehaviour.print(参数);
		GameObject.Find(函字符串分割.jsontoString(参数.data[1].ToString(), "\"")).transform.position = 函字符串分割.StringtoVector3(函字符串分割.jsontoString(参数.data[0].ToString(), "\""));
	}

	public void 嗨新人我的位置在这里(SocketIOEvent 参数)
	{
		解析人物信息(参数);
	}

	public void 创建人物(string 参数, Vector3 参数2, string 参数3)
	{
		GameObject original = new GameObject();
		if (参数 == myIntArray[0])
		{
			original = 人物;
		}
		else if (参数 == myIntArray[1])
		{
			original = 人物1;
		}
		else if (参数 == myIntArray[2])
		{
			original = 人物2;
		}
		GameObject obj = UnityEngine.Object.Instantiate(original, 参数2, Quaternion.identity);
		obj.GetComponent<Att>().socketid = 参数3;
		obj.name = 参数;
		MonoBehaviour.print("创建真正的人物");
	}

	public void 解析人物信息(SocketIOEvent 参数)
	{
		string 参数2 = 函字符串分割.jsontoString(参数.data["id"].ToString(), "\"");
		string 参数3 = 函字符串分割.jsontoString(参数.data["socketid"].ToString(), "\"");
		Vector3 参数4 = 函字符串分割.StringtoVector3(函字符串分割.jsontoString(参数.data["position"].ToString(), "\""));
		创建人物(参数2, 参数4, 参数3);
		MonoBehaviour.print("给予创建人物的数据");
	}

	public void 新人加进来了(SocketIOEvent 参数)
	{
		解析人物信息(参数);
		MonoBehaviour.print("新人加进来了");
		string value = 函字符串分割.jsontoString(参数.data["socketid"].ToString(), "\"");
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		dictionary["position"] = 位置.x + "," + 位置.y + "," + 位置.z;
		dictionary["socketid"] = value;
		套接.Emit("告诉新进来的人我的位置", new JSONObject(dictionary));
	}

	public void 接收消息(SocketIOEvent 参数)
	{
		GameObject.Find(函字符串分割.jsontoString(参数.data["id"].ToString(), "\"")).gameObject.GetComponentInChildren<Text>().text = 参数.data["信息"].ToString();
		另对话 = UnityEngine.Object.Instantiate(对方对话, 另位置, Quaternion.identity);
		另对话.transform.SetParent(面板1.transform);
		另对话.transform.localPosition = 另位置;
		另对话.transform.localRotation = Quaternion.identity;
		另对话.GetComponent<RectTransform>().localScale = new Vector3(1f, 1f, 1f);
		另对话.GetComponentInChildren<Text>().text = 参数.data["信息"].ToString();
	}

	public void 发信息()
	{
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		dictionary["id"] = 类脑.微我号;
		dictionary["信息"] = 发送框.text;
		我的头顶气泡.text = dictionary["信息"];
		已发送消息 = true;
		套接.Emit("信息发送", new JSONObject(dictionary));
		if (发送框.text != null)
		{
			对话位置 = new Vector3(4f, 40f, 10.2f);
			对话 = UnityEngine.Object.Instantiate(自己对话, 对话位置, Quaternion.identity);
			对话.transform.SetParent(面板1.transform);
			对话.transform.localPosition = 对话位置;
			对话.GetComponentInChildren<Text>().text = dictionary["信息"];
			对话.transform.localRotation = Quaternion.identity;
			对话.GetComponent<RectTransform>().localScale = new Vector3(1f, 1f, 1f);
			Canvas.ForceUpdateCanvases();
			对话.transform.Find("Img_对话框").GetComponent<Image>().GetComponent<RectTransform>()
				.sizeDelta = 对话.transform.Find("Img_对话框/text_自己的话").GetComponent<Text>().GetComponent<RectTransform>()
				.sizeDelta + new Vector2(5f, 1f);
			发送框.text = "";
		}
	}
}
public class Att : MonoBehaviour
{
	public string socketid;
}
public class BntControl : MonoBehaviour
{
	private void Start()
	{
	}

	public void OnTriggerEnter(Collider col)
	{
		Add.intance_.发信息();
		MonoBehaviour.print("12");
		UnityEngine.Debug.Log(col.name);
		if (col.tag == "cube_S")
		{
			Add.intance_.发信息();
			UnityEngine.Debug.Log(col.name);
		}
	}
}
public class CameFollow : MonoBehaviour
{
	public static CameFollow _instan;

	public GameObject Player;

	public Vector3 vector;

	private void Awake()
	{
		_instan = this;
		Player = 类脑.主角;
	}

	private void Update()
	{
		base.transform.position = new Vector3(Player.transform.position.x + 10f, Player.transform.position.y + 35f, Player.transform.position.z + 150f);
		vector = base.transform.position;
	}
}
public class FollowTarget2 : MonoBehaviour
{
	public static FollowTarget2 _instan;

	public GameObject 跟随的玩家;

	public Vector3 人物偏移 = new Vector3(0f, 37f, 0f);

	public float 旋转速度 = 10f;

	public GameObject 角度跟随目标;

	public bool 是私聊;

	public Text 对话内容;

	private void Awake()
	{
		_instan = this;
		是私聊 = true;
	}

	private void Update()
	{
	}
}
public class LineTeleporter : MonoBehaviour
{
	public LineRenderer Line;

	public Transform StartPosit;

	public Transform Player;

	public float Hight = -6.37f;

	private Vector3 targetPoint;

	private void Start()
	{
		Line.SetWidth(0.2f, 0.2f);
	}

	private void FixedUpdate()
	{
		InputDevices.GetDeviceAtXRNode(XRNode.LeftHand).TryGetFeatureValue(UnityEngine.XR.CommonUsages.primaryButton, out var value);
		if (value)
		{
			MonoBehaviour.print("按下【摇杆】");
			if (Physics.Raycast(new Ray(StartPosit.position, StartPosit.forward), out var hitInfo))
			{
				MonoBehaviour.print("获得移动位置");
				Line.enabled = true;
				targetPoint = hitInfo.point;
				Line.SetPosition(0, StartPosit.position);
				Line.SetPosition(1, targetPoint);
			}
		}
		if (!value)
		{
			MonoBehaviour.print("设定位置");
			Line.enabled = false;
		}
	}
}
public class MyStartUIControl : MonoBehaviour
{
	public InputField 账号;

	public InputField 密码;

	private UnityEngine.AsyncOperation async;

	private SocketIOComponent 套接;

	private ectScript 函字符串分割;

	public GameObject 登录界面;

	public GameObject 加载界面;

	public GameObject 错误提示;

	public Slider 进度条;

	public Text 进度值;

	public string[] 随机的内容 = new string[3] { "你知道吗？在虚我中唤出菜单点击“创”可以进入虚创空间撘建家园哦！", "你知道吗？在虚我中唤出菜单点击“游”可以选择不同的游戏哦！", "你知道吗？在虚我中唤出菜单点击“聊”可以选择不同的聊天方式哦！" };

	public Text 提示内容;

	private void Awake()
	{
		登录界面.SetActive(value: true);
		加载界面.SetActive(value: false);
		进度值.text = "0";
		提示内容.text = 随机的内容[UnityEngine.Random.Range(0, 3)];
		错误提示.SetActive(value: false);
	}

	private void Start()
	{
		GameObject gameObject = GameObject.Find("SocketIO");
		套接 = gameObject.GetComponent<SocketIOComponent>();
		函字符串分割 = gameObject.GetComponent<ectScript>();
		套接.On("帐号密码错误", 帐号密码错误);
		套接.On("登录成功", 登录成功);
	}

	public void 登录成功(SocketIOEvent 参数)
	{
		佐.逮.公据 = jsontoString(参数.data["txt"].ToString());
		类脑.微我号 = 函字符串分割.jsontoString(参数.data["id"].ToString(), "\"");
		MonoBehaviour.print(类脑.微我号);
		类脑.socketId = 函字符串分割.jsontoString(参数.data["socketid"].ToString(), "\"");
		登录界面.SetActive(value: false);
		加载界面.SetActive(value: true);
		StartCoroutine(loadScene(3));
	}

	public string jsontoString(string target)
	{
		return Regex.Split(target, "\"")[1];
	}

	private void Update()
	{
	}

	public void 帐号密码错误(SocketIOEvent 参数)
	{
		MonoBehaviour.print("帐号密码错误");
		错误提示.SetActive(value: true);
		登录界面.SetActive(value: false);
	}

	public void 点击进入按钮()
	{
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		dictionary["id"] = 账号.text;
		dictionary["pw"] = 密码.text;
		套接.Emit("登录", new JSONObject(dictionary));
	}

	private IEnumerator loadScene(int timer)
	{
		yield return new WaitForSeconds(timer);
		async = UnityEngine.Application.LoadLevelAsync("lou");
		yield return async;
	}

	public void 点击错误界面确认()
	{
		错误提示.SetActive(value: false);
		登录界面.SetActive(value: true);
	}
}
public class PlayerMove2 : MonoBehaviour
{
	public static PlayerMove2 _instan;

	private int groundLayerIndex = -1;

	private Rigidbody _myRigidbody;

	public int _speed = 1;

	public int _force = 5;

	public bool isGround;

	public bool isPress;

	public float timer;

	public SocketIOComponent 套接;

	private Transform m_Camera;

	public float m_RotateFactor = 10f;

	private void Awake()
	{
		_instan = this;
		isGround = false;
		isPress = false;
		timer = 0f;
		m_Camera = Camera.main.transform;
		_myRigidbody = GetComponent<Rigidbody>();
		GameObject gameObject = GameObject.Find("SocketIO");
		套接 = gameObject.GetComponent<SocketIOComponent>();
	}

	private void Destory()
	{
	}

	private void Start()
	{
	}

	private void Update()
	{
		if (Input.GetAxis("Vertical") != 0f || Input.GetAxis("Horizontal") != 0f)
		{
			float axis = Input.GetAxis("Horizontal");
			float axis2 = Input.GetAxis("Vertical");
			base.transform.Translate(axis * 0.2f, 0f, axis2 * 0.2f);
			timer += Time.deltaTime;
			Dictionary<string, string> dictionary = new Dictionary<string, string>();
			dictionary["position"] = base.transform.position.x + "," + base.transform.position.y + "," + base.transform.position.z;
			套接.Emit("移动", new JSONObject(dictionary));
		}
		if (isPress && isGround)
		{
			isGround = false;
			if (timer >= 0.5f)
			{
				_myRigidbody.velocity = new Vector3(0f, 5f, 0f);
				timer = 0f;
			}
		}
	}

	private void Move(float delta)
	{
		float y = Camera.main.transform.eulerAngles.y + delta;
		Quaternion b = Quaternion.Euler(0f, y, 0f);
		base.transform.rotation = Quaternion.Lerp(base.transform.rotation, b, Time.deltaTime * m_RotateFactor);
	}

	public void OnCollisionEnter(Collision col)
	{
		if (col.gameObject.tag == "Floor")
		{
			isGround = true;
			isPress = false;
		}
	}

	public void OnTriggerEnter(Collider col)
	{
	}
}
public class UIChange : MonoBehaviour
{
	public static UIChange 自己;

	public GameObject 键盘;

	public GameObject 手柄;

	public GameObject 键盘球;

	public UIControl_XuWo 虚我脚本;

	public UIControl_XuLiao 虚聊脚本;

	public GameObject 虚我UI;

	public bool 进入虚聊;

	public bool 返回虚我;

	public bool 是否激活键盘;

	private void Awake()
	{
		自己 = this;
		进入虚聊 = false;
		返回虚我 = true;
		是否激活键盘 = false;
		键盘.SetActive(value: false);
		虚我脚本.enabled = true;
		虚聊脚本.enabled = false;
		键盘球.SetActive(value: false);
	}

	private void Start()
	{
	}

	private void Update()
	{
		脚本激活控制();
		UnityEngine.XR.InputDevice deviceAtXRNode = InputDevices.GetDeviceAtXRNode(XRNode.LeftHand);
		if (是否激活键盘)
		{
			键盘.SetActive(value: true);
			键盘球.SetActive(value: true);
			deviceAtXRNode.TryGetFeatureValue(UnityEngine.XR.CommonUsages.menuButton, out var value);
			if (value)
			{
				键盘.SetActive(value: false);
				返回虚我 = true;
				脚本激活控制();
				虚我脚本.进入动画();
				是否激活键盘 = false;
				键盘球.SetActive(value: false);
			}
		}
	}

	public void 脚本激活控制()
	{
		if (返回虚我)
		{
			虚我脚本.enabled = true;
			虚聊脚本.enabled = false;
		}
		else if (进入虚聊)
		{
			虚我脚本.enabled = false;
			虚聊脚本.enabled = true;
		}
		if (!返回虚我 && !进入虚聊)
		{
			虚我脚本.enabled = false;
			虚聊脚本.enabled = false;
		}
	}
}
public class UIControl_XuLiao : MonoBehaviour
{
	public GameObject 魔方;

	public GameObject 上级UI;

	public UIControl_XuWo 虚我脚本;

	public Image[] 图片集合;

	private int 广;

	private float 第一次触摸的X坐标;

	private float 第一次触摸的Y坐标;

	private bool 是否触摸中;

	private int 当前摇杆的X;

	private int 当前摇杆的Y;

	private int 上一次触摸的X坐标;

	private int 上一次触摸的Y坐标;

	public bool 是否唤出虚聊UI;

	private void Awake()
	{
		是否触摸中 = true;
	}

	private void OnEnable()
	{
		是否唤出虚聊UI = true;
	}

	private void Start()
	{
		图片集合[12].DOFade(0.1f, 0.1f);
		广 = 12;
	}

	private void Update()
	{
		UnityEngine.XR.InputDevice deviceAtXRNode = InputDevices.GetDeviceAtXRNode(XRNode.LeftHand);
		deviceAtXRNode.TryGetFeatureValue(UnityEngine.XR.CommonUsages.menuButton, out var value);
		if (value)
		{
			if (是否唤出虚聊UI)
			{
				退出动画();
			}
			if (!是否唤出虚聊UI)
			{
				魔方.SetActive(value: true);
				进入动画();
			}
		}
		if (!value)
		{
			是否唤出虚聊UI = !是否唤出虚聊UI;
		}
		deviceAtXRNode.TryGetFeatureValue(UnityEngine.XR.CommonUsages.triggerButton, out var value2);
		if (value2 && 是否唤出虚聊UI)
		{
			执(广);
		}
		deviceAtXRNode.TryGetFeatureValue(UnityEngine.XR.CommonUsages.primary2DAxisClick, out var value3);
		if (value3)
		{
			Vector2 value4 = default(Vector2);
			deviceAtXRNode.TryGetFeatureValue(UnityEngine.XR.CommonUsages.primary2DAxis, out value4);
			if (是否触摸中)
			{
				第一次触摸的X坐标 = value4.x;
				第一次触摸的Y坐标 = value4.y;
				是否触摸中 = false;
			}
			上一次触摸的X坐标 = (int)(第一次触摸的X坐标 * 10f);
			当前摇杆的X = (int)(value4.x * 10f);
			上一次触摸的Y坐标 = (int)(第一次触摸的Y坐标 * 10f);
			当前摇杆的Y = (int)(value4.y * 10f);
			if (广 + 1 < 图片集合.Length && 当前摇杆的X - 上一次触摸的X坐标 == 2)
			{
				图片集合[广 + 1].DOFade(0.1f, 0.1f);
				图片集合[广].DOFade(1f, 1f);
				广++;
				第一次触摸的X坐标 = value4.x;
			}
			else if (广 + 1 > 图片集合.Length)
			{
				广 = 24;
				图片集合[广].DOFade(0.1f, 0.1f);
			}
			if (广 - 1 >= 0 && 当前摇杆的X - 上一次触摸的X坐标 == -2)
			{
				图片集合[广 - 1].DOFade(0.1f, 0.1f);
				图片集合[广].DOFade(1f, 1f);
				广--;
				第一次触摸的X坐标 = value4.x;
			}
			else if (广 - 1 < 0)
			{
				广 = 0;
				图片集合[广].DOFade(0.1f, 0.1f);
			}
			if (广 - 5 >= 0 && 当前摇杆的Y - 上一次触摸的Y坐标 == 2)
			{
				图片集合[广 - 5].DOFade(0.1f, 0.1f);
				图片集合[广].DOFade(1f, 1f);
				广 -= 5;
				第一次触摸的Y坐标 = value4.y;
			}
			else if (广 - 5 < 0)
			{
				图片集合[广].DOFade(0.1f, 0.1f);
			}
			if (广 + 5 < 图片集合.Length && 当前摇杆的Y - 上一次触摸的Y坐标 == -2)
			{
				图片集合[广 + 5].DOFade(0.1f, 0.1f);
				图片集合[广].DOFade(1f, 1f);
				广 += 5;
				第一次触摸的Y坐标 = value4.y;
			}
			else if (广 + 5 >= 图片集合.Length)
			{
				图片集合[广].DOFade(0.1f, 0.1f);
			}
		}
		if (!value3)
		{
			是否触摸中 = true;
		}
	}

	private void 执(int 元素)
	{
		if (元素 == 0)
		{
			是否唤出虚聊UI = !是否唤出虚聊UI;
			退出动画();
			上级UI.SetActive(value: true);
			虚我脚本.进入动画();
			UIChange.自己.返回虚我 = true;
			UIChange.自己.进入虚聊 = false;
		}
		if (元素 == 1)
		{
			是否唤出虚聊UI = !是否唤出虚聊UI;
			退出动画();
			UIChange.自己.返回虚我 = false;
			UIChange.自己.进入虚聊 = false;
			UIChange.自己.是否激活键盘 = true;
		}
		_ = 2;
		_ = 3;
		_ = 4;
		_ = 5;
		_ = 6;
		_ = 7;
		_ = 8;
	}

	public void 进入动画()
	{
		魔方.GetComponent<RectTransform>().localScale = new Vector3(0.0005f, 0.0005f, 0.0005f);
		魔方.GetComponent<CanvasGroup>().alpha = 0f;
		Sequence s = DOTween.Sequence();
		s.Append(魔方.GetComponent<RectTransform>().DOScale(new Vector3(0.005f, 0.005f, 0.005f), 1f));
		s.Insert(0.1f, 魔方.GetComponent<CanvasGroup>().DOFade(1f, 0.9f));
	}

	public void 退出动画()
	{
		Sequence s = DOTween.Sequence();
		s.Append(魔方.GetComponent<RectTransform>().DOScale(new Vector3(0.0005f, 0.0005f, 0.0005f), 1f));
		s.Insert(0.1f, 魔方.GetComponent<CanvasGroup>().DOFade(0f, 0.9f));
		Invoke("销毁魔方", 1.1f);
	}

	private void 销毁魔方()
	{
		魔方.SetActive(value: false);
	}
}
public class UIControl_XuWo : MonoBehaviour
{
	public GameObject 魔方;

	public GameObject 下级UI;

	public UIControl_XuLiao 虚聊脚本;

	public Image[] 图片集合;

	private int 广;

	private float 第一次触摸的X坐标;

	private float 第一次触摸的Y坐标;

	private bool 是否触摸中;

	private int 当前摇杆的X;

	private int 当前摇杆的Y;

	private int 上一次触摸的X坐标;

	private int 上一次触摸的Y坐标;

	private bool 是否唤出虚我UI;

	public Text 公告;

	public Text 调试;

	private void Awake()
	{
		是否触摸中 = true;
	}

	private void OnEnable()
	{
		是否唤出虚我UI = true;
	}

	private void Start()
	{
		图片集合[12].DOFade(0.1f, 0.1f);
		广 = 12;
	}

	private void Update()
	{
		UnityEngine.XR.InputDevice deviceAtXRNode = InputDevices.GetDeviceAtXRNode(XRNode.LeftHand);
		deviceAtXRNode.TryGetFeatureValue(UnityEngine.XR.CommonUsages.menuButton, out var value);
		if (value)
		{
			if (是否唤出虚我UI)
			{
				退出动画();
			}
			if (!是否唤出虚我UI)
			{
				魔方.SetActive(value: true);
				进入动画();
			}
		}
		if (!value)
		{
			是否唤出虚我UI = !是否唤出虚我UI;
		}
		deviceAtXRNode.TryGetFeatureValue(UnityEngine.XR.CommonUsages.triggerButton, out var value2);
		if (value2 && 是否唤出虚我UI)
		{
			执(广);
		}
		deviceAtXRNode.TryGetFeatureValue(UnityEngine.XR.CommonUsages.primary2DAxisClick, out var value3);
		if (value3)
		{
			Vector2 value4 = default(Vector2);
			deviceAtXRNode.TryGetFeatureValue(UnityEngine.XR.CommonUsages.primary2DAxis, out value4);
			if (是否触摸中)
			{
				第一次触摸的X坐标 = value4.x;
				第一次触摸的Y坐标 = value4.y;
				是否触摸中 = false;
			}
			上一次触摸的X坐标 = (int)(第一次触摸的X坐标 * 10f);
			当前摇杆的X = (int)(value4.x * 10f);
			上一次触摸的Y坐标 = (int)(第一次触摸的Y坐标 * 10f);
			当前摇杆的Y = (int)(value4.y * 10f);
			if (广 + 1 < 图片集合.Length && 当前摇杆的X - 上一次触摸的X坐标 == 2)
			{
				图片集合[广 + 1].DOFade(0.1f, 0.1f);
				图片集合[广].DOFade(1f, 1f);
				广++;
				第一次触摸的X坐标 = value4.x;
			}
			else if (广 + 1 > 图片集合.Length)
			{
				广 = 24;
				图片集合[广].DOFade(0.1f, 0.1f);
			}
			if (广 - 1 >= 0 && 当前摇杆的X - 上一次触摸的X坐标 == -2)
			{
				图片集合[广 - 1].DOFade(0.1f, 0.1f);
				图片集合[广].DOFade(1f, 1f);
				广--;
				第一次触摸的X坐标 = value4.x;
			}
			else if (广 - 1 < 0)
			{
				广 = 0;
				图片集合[广].DOFade(0.1f, 0.1f);
			}
			if (广 - 5 >= 0 && 当前摇杆的Y - 上一次触摸的Y坐标 == 2)
			{
				图片集合[广 - 5].DOFade(0.1f, 0.1f);
				图片集合[广].DOFade(1f, 1f);
				广 -= 5;
				第一次触摸的Y坐标 = value4.y;
			}
			else if (广 - 5 < 0)
			{
				图片集合[广].DOFade(0.1f, 0.1f);
			}
			if (广 + 5 < 图片集合.Length && 当前摇杆的Y - 上一次触摸的Y坐标 == -2)
			{
				图片集合[广 + 5].DOFade(0.1f, 0.1f);
				图片集合[广].DOFade(1f, 1f);
				广 += 5;
				第一次触摸的Y坐标 = value4.y;
			}
			else if (广 + 5 >= 图片集合.Length)
			{
				图片集合[广].DOFade(0.1f, 0.1f);
			}
		}
		if (!value3)
		{
			是否触摸中 = true;
		}
	}

	private void 执(int 元素)
	{
		调试.text = 类脑.取时间() + "执之元素：" + 元素;
		if (元素 == 0)
		{
			是否唤出虚我UI = !是否唤出虚我UI;
			退出动画();
			下级UI.SetActive(value: true);
			虚聊脚本.进入动画();
			UIChange.自己.返回虚我 = false;
			UIChange.自己.进入虚聊 = true;
		}
		if (元素 == 1)
		{
			是否唤出虚我UI = !是否唤出虚我UI;
			退出动画();
			UnityEngine.Application.LoadLevel(2);
		}
		_ = 2;
		_ = 3;
		_ = 4;
		_ = 5;
		_ = 6;
		_ = 7;
		_ = 8;
	}

	public void 进入动画()
	{
		魔方.GetComponent<RectTransform>().localScale = new Vector3(0.0005f, 0.0005f, 0.0005f);
		魔方.GetComponent<CanvasGroup>().alpha = 0f;
		Sequence s = DOTween.Sequence();
		s.Append(魔方.GetComponent<RectTransform>().DOScale(new Vector3(0.005f, 0.005f, 0.005f), 1f));
		s.Insert(0.1f, 魔方.GetComponent<CanvasGroup>().DOFade(1f, 0.9f));
	}

	public void 退出动画()
	{
		Sequence s = DOTween.Sequence();
		s.Append(魔方.GetComponent<RectTransform>().DOScale(new Vector3(0.0005f, 0.0005f, 0.0005f), 1f));
		s.Insert(0.1f, 魔方.GetComponent<CanvasGroup>().DOFade(0f, 0.9f));
		Invoke("销毁魔方", 1.1f);
	}

	private void 销毁魔方()
	{
		魔方.SetActive(value: false);
	}
}
public class MouseMoveandScale : MonoBehaviour
{
	private Vector2 p1;

	private Vector2 p2;

	private Vector2 p3;

	private Vector2 p4;

	private void Start()
	{
	}

	private void Update()
	{
		zoom();
	}

	private void translationDrag()
	{
		if (Input.GetMouseButtonDown(0))
		{
			p1 = new Vector2(Input.mousePosition.x, Input.mousePosition.y);
		}
		if (Input.GetMouseButton(0))
		{
			p2 = new Vector2(Input.mousePosition.x, Input.mousePosition.y);
			float num = 0.8f * (p2.x - p1.x);
			float num2 = 0.8f * (p2.y - p1.y);
			if (num >= 0f)
			{
				base.transform.Translate((0f - num) * Vector3.right * Time.deltaTime);
			}
			else
			{
				base.transform.Translate(num * Vector3.left * Time.deltaTime);
			}
			if (num2 >= 0f)
			{
				base.transform.Translate(num2 * Vector3.down * Time.deltaTime);
			}
			else
			{
				base.transform.Translate((0f - num2) * Vector3.up * Time.deltaTime);
			}
		}
	}

	private void zoom()
	{
		if (Input.GetAxis("Mouse ScrollWheel") < 0f)
		{
			if (Camera.main.fieldOfView <= 100f)
			{
				Camera.main.fieldOfView += 2f;
			}
			if (Camera.main.orthographicSize <= 20f)
			{
				Camera.main.orthographicSize += 0.5f;
			}
		}
		if (Input.GetAxis("Mouse ScrollWheel") > 0f)
		{
			if (Camera.main.fieldOfView > 2f)
			{
				Camera.main.fieldOfView -= 2f;
			}
			if (Camera.main.orthographicSize >= 1f)
			{
				Camera.main.orthographicSize -= 0.5f;
			}
		}
	}

	private void rotate()
	{
		if (Input.GetKey(KeyCode.C))
		{
			base.transform.Rotate(0f, 0f, -25f * Time.deltaTime, Space.Self);
		}
		if (Input.GetKey(KeyCode.Z))
		{
			base.transform.Rotate(0f, 0f, 25f * Time.deltaTime, Space.Self);
		}
		if (Input.GetMouseButtonDown(1))
		{
			p3 = new Vector2(Input.mousePosition.x, Input.mousePosition.y);
		}
		if (Input.GetMouseButton(1))
		{
			p4 = new Vector2(Input.mousePosition.x, Input.mousePosition.y);
			float num = 0.8f * (p4.x - p3.x);
			float num2 = 0.8f * (p4.y - p3.y);
			if (num >= 0f)
			{
				base.transform.Rotate(0f, 0f, -25f * Time.deltaTime, Space.Self);
			}
			else
			{
				base.transform.Rotate(0f, 0f, 25f * Time.deltaTime, Space.Self);
			}
			if (num2 >= 0f)
			{
				base.transform.Rotate(0f, 0f, -25f * Time.deltaTime, Space.Self);
			}
			else
			{
				base.transform.Rotate(0f, 0f, 25f * Time.deltaTime, Space.Self);
			}
		}
	}
}
[ExecuteInEditMode]
public class MirrorReflection : MonoBehaviour
{
	public bool m_DisablePixelLights = true;

	public int m_TextureSize = 1024;

	public float m_ClipPlaneOffset = 0.07f;

	public LayerMask m_ReflectLayers = -1;

	private Hashtable m_ReflectionCameras = new Hashtable();

	private RenderTexture m_ReflectionTexture;

	private int m_OldReflectionTextureSize;

	private static bool s_InsideRendering;

	public void OnWillRenderObject()
	{
		if (!base.enabled || !GetComponent<Renderer>() || !GetComponent<Renderer>().sharedMaterial || !GetComponent<Renderer>().enabled)
		{
			return;
		}
		Camera current = Camera.current;
		if (!current || s_InsideRendering)
		{
			return;
		}
		s_InsideRendering = true;
		CreateMirrorObjects(current, out var reflectionCamera);
		Vector3 position = base.transform.position;
		Vector3 up = base.transform.up;
		int pixelLightCount = QualitySettings.pixelLightCount;
		if (m_DisablePixelLights)
		{
			QualitySettings.pixelLightCount = 0;
		}
		UpdateCameraModes(current, reflectionCamera);
		float w = 0f - Vector3.Dot(up, position) - m_ClipPlaneOffset;
		Vector4 plane = new Vector4(up.x, up.y, up.z, w);
		Matrix4x4 reflectionMat = Matrix4x4.zero;
		CalculateReflectionMatrix(ref reflectionMat, plane);
		Vector3 position2 = current.transform.position;
		Vector3 position3 = reflectionMat.MultiplyPoint(position2);
		reflectionCamera.worldToCameraMatrix = current.worldToCameraMatrix * reflectionMat;
		Vector4 clipPlane = CameraSpacePlane(reflectionCamera, position, up, 1f);
		Matrix4x4 projection = current.projectionMatrix;
		CalculateObliqueMatrix(ref projection, clipPlane);
		reflectionCamera.projectionMatrix = projection;
		reflectionCamera.cullingMask = -17 & m_ReflectLayers.value;
		reflectionCamera.targetTexture = m_ReflectionTexture;
		GL.SetRevertBackfacing(revertBackFaces: true);
		reflectionCamera.transform.position = position3;
		Vector3 eulerAngles = current.transform.eulerAngles;
		reflectionCamera.transform.eulerAngles = new Vector3(0f, eulerAngles.y, eulerAngles.z);
		reflectionCamera.Render();
		reflectionCamera.transform.position = position2;
		GL.SetRevertBackfacing(revertBackFaces: false);
		Material[] sharedMaterials = GetComponent<Renderer>().sharedMaterials;
		Material[] array = sharedMaterials;
		foreach (Material material in array)
		{
			if (material.HasProperty("_ReflectionTex"))
			{
				material.SetTexture("_ReflectionTex", m_ReflectionTexture);
			}
		}
		Matrix4x4 matrix4x = Matrix4x4.TRS(new Vector3(0.5f, 0.5f, 0.5f), Quaternion.identity, new Vector3(0.5f, 0.5f, 0.5f));
		Vector3 lossyScale = base.transform.lossyScale;
		Matrix4x4 matrix4x2 = base.transform.localToWorldMatrix * Matrix4x4.Scale(new Vector3(1f / lossyScale.x, 1f / lossyScale.y, 1f / lossyScale.z));
		matrix4x2 = matrix4x * current.projectionMatrix * current.worldToCameraMatrix * matrix4x2;
		array = sharedMaterials;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetMatrix("_ProjMatrix", matrix4x2);
		}
		if (m_DisablePixelLights)
		{
			QualitySettings.pixelLightCount = pixelLightCount;
		}
		s_InsideRendering = false;
	}

	private void OnDisable()
	{
		if ((bool)m_ReflectionTexture)
		{
			UnityEngine.Object.DestroyImmediate(m_ReflectionTexture);
			m_ReflectionTexture = null;
		}
		foreach (DictionaryEntry reflectionCamera in m_ReflectionCameras)
		{
			UnityEngine.Object.DestroyImmediate(((Camera)reflectionCamera.Value).gameObject);
		}
		m_ReflectionCameras.Clear();
	}

	private void UpdateCameraModes(Camera src, Camera dest)
	{
		if (dest == null)
		{
			return;
		}
		dest.clearFlags = src.clearFlags;
		dest.backgroundColor = src.backgroundColor;
		if (src.clearFlags == CameraClearFlags.Skybox)
		{
			Skybox skybox = src.GetComponent(typeof(Skybox)) as Skybox;
			Skybox skybox2 = dest.GetComponent(typeof(Skybox)) as Skybox;
			if (!skybox || !skybox.material)
			{
				skybox2.enabled = false;
			}
			else
			{
				skybox2.enabled = true;
				skybox2.material = skybox.material;
			}
		}
		dest.farClipPlane = src.farClipPlane;
		dest.nearClipPlane = src.nearClipPlane;
		dest.orthographic = src.orthographic;
		dest.fieldOfView = src.fieldOfView;
		dest.aspect = src.aspect;
		dest.orthographicSize = src.orthographicSize;
	}

	private void CreateMirrorObjects(Camera currentCamera, out Camera reflectionCamera)
	{
		reflectionCamera = null;
		if (!m_ReflectionTexture || m_OldReflectionTextureSize != m_TextureSize)
		{
			if ((bool)m_ReflectionTexture)
			{
				UnityEngine.Object.DestroyImmediate(m_ReflectionTexture);
			}
			m_ReflectionTexture = new RenderTexture(m_TextureSize, m_TextureSize, 16);
			m_ReflectionTexture.name = "__MirrorReflection" + GetInstanceID();
			m_ReflectionTexture.isPowerOfTwo = true;
			m_ReflectionTexture.hideFlags = HideFlags.DontSave;
			m_OldReflectionTextureSize = m_TextureSize;
		}
		reflectionCamera = m_ReflectionCameras[currentCamera] as Camera;
		if (!reflectionCamera)
		{
			GameObject gameObject = new GameObject("Mirror Refl Camera id" + GetInstanceID() + " for " + currentCamera.GetInstanceID(), typeof(Camera), typeof(Skybox));
			reflectionCamera = gameObject.GetComponent<Camera>();
			reflectionCamera.enabled = false;
			reflectionCamera.transform.position = base.transform.position;
			reflectionCamera.transform.rotation = base.transform.rotation;
			reflectionCamera.gameObject.AddComponent<FlareLayer>();
			gameObject.hideFlags = HideFlags.HideAndDontSave;
			m_ReflectionCameras[currentCamera] = reflectionCamera;
		}
	}

	private static float sgn(float a)
	{
		if (a > 0f)
		{
			return 1f;
		}
		if (a < 0f)
		{
			return -1f;
		}
		return 0f;
	}

	private Vector4 CameraSpacePlane(Camera cam, Vector3 pos, Vector3 normal, float sideSign)
	{
		Vector3 point = pos + normal * m_ClipPlaneOffset;
		Matrix4x4 worldToCameraMatrix = cam.worldToCameraMatrix;
		Vector3 lhs = worldToCameraMatrix.MultiplyPoint(point);
		Vector3 rhs = worldToCameraMatrix.MultiplyVector(normal).normalized * sideSign;
		return new Vector4(rhs.x, rhs.y, rhs.z, 0f - Vector3.Dot(lhs, rhs));
	}

	private static void CalculateObliqueMatrix(ref Matrix4x4 projection, Vector4 clipPlane)
	{
		Vector4 b = projection.inverse * new Vector4(sgn(clipPlane.x), sgn(clipPlane.y), 1f, 1f);
		Vector4 vector = clipPlane * (2f / Vector4.Dot(clipPlane, b));
		projection[2] = vector.x - projection[3];
		projection[6] = vector.y - projection[7];
		projection[10] = vector.z - projection[11];
		projection[14] = vector.w - projection[15];
	}

	private static void CalculateReflectionMatrix(ref Matrix4x4 reflectionMat, Vector4 plane)
	{
		reflectionMat.m00 = 1f - 2f * plane[0] * plane[0];
		reflectionMat.m01 = -2f * plane[0] * plane[1];
		reflectionMat.m02 = -2f * plane[0] * plane[2];
		reflectionMat.m03 = -2f * plane[3] * plane[0];
		reflectionMat.m10 = -2f * plane[1] * plane[0];
		reflectionMat.m11 = 1f - 2f * plane[1] * plane[1];
		reflectionMat.m12 = -2f * plane[1] * plane[2];
		reflectionMat.m13 = -2f * plane[3] * plane[1];
		reflectionMat.m20 = -2f * plane[2] * plane[0];
		reflectionMat.m21 = -2f * plane[2] * plane[1];
		reflectionMat.m22 = 1f - 2f * plane[2] * plane[2];
		reflectionMat.m23 = -2f * plane[3] * plane[2];
		reflectionMat.m30 = 0f;
		reflectionMat.m31 = 0f;
		reflectionMat.m32 = 0f;
		reflectionMat.m33 = 1f;
	}
}
public class ectScript : MonoBehaviour
{
	public Vector3 StringtoVector3(string target)
	{
		string[] array = Regex.Split(target, ",");
		return new Vector3(float.Parse(array[0]), float.Parse(array[1]), float.Parse(array[2]));
	}

	public string jsontoString(string target, string s)
	{
		return Regex.Split(target, s)[1];
	}
}
public class GC2
{
	public static SocketIOComponent 套接2;
}
public class MySocket : MonoBehaviour
{
	public static JSONObject 用户信息;

	public static Dictionary<string, JSONObject> GroupMessage = new Dictionary<string, JSONObject>();

	public static string 新的群号 = "";

	public static string 消息 = null;

	public static List<JSONObject> 查询的信息 = new List<JSONObject>();

	public static List<string> 申请好友列表 = new List<string>();

	public static List<string> 申请好友成功反馈 = new List<string>();

	public static List<string> groupIdList = new List<string>();

	public static List<string> idList = new List<string>();

	public GameObject 输入法;

	public Transform 输入法出现位置;

	public static MySocket _instance;

	public static List<Item> itemList = new List<Item>();

	public Text 帐号;

	public Text 密码;

	public string 虚号;

	private void Awake()
	{
		_instance = this;
	}

	private void Start()
	{
		GC.套接 = GameObject.Find("SocketIO").GetComponent<SocketIOComponent>();
		StartCoroutine("开始");
		GC.套接.On("登录成功", 登录成功);
		GC.套接.On("连接成功", 连接成功);
		GC.套接.On("户广", 户广);
		GC.套接.On("群信息", 群信息);
		GC.套接.On("群消息", 群消息);
		GC.套接.On("接收私聊", 接收私聊);
		GC.套接.On("虚我号信息", 虚我号信息);
		GC.套接.On("好友请求", 好友请求);
		GC.套接.On("好友同意添加", 好友同意添加);
		GC.套接.On("创建群成功", 创建群成功);
		GC.套接.On("世界消息接收", 世界信息);
	}

	private IEnumerator 开始()
	{
		yield return new WaitForSeconds(1f);
		GC.套接.Emit("连接");
	}

	public void 户广(SocketIOEvent 参数)
	{
	}

	public void 登录成功(SocketIOEvent 参数)
	{
		用户信息 = 参数.data;
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject.transform.parent);
		SceneManager.LoadScene(1);
	}

	public void 世界信息(SocketIOEvent 参数)
	{
		string text = 参数.data["id"].ToString();
		string text2 = 参数.data["信息"].ToString();
		text = text.Substring(1, text.Length - 2);
		text2 = text2.Substring(1, text2.Length - 2);
		ChatController._instance.实例化(text, text2);
	}

	public void 登录()
	{
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		dictionary["id"] = "12345";
		dictionary["pw"] = "1";
		dictionary["表"] = "az_400";
		虚号 = 帐号.text;
		string value = "10774";
		PlayerPrefs.SetString("虚我号", value);
		GC.套接.Emit("登录", new JSONObject(dictionary));
	}

	public void 发送世界信息(string id, string message)
	{
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		dictionary["信息"] = message;
		dictionary["id"] = id;
		GC.套接.Emit("世界消息发送", new JSONObject(dictionary));
	}

	public void 连接成功(SocketIOEvent 参数)
	{
	}

	public void 群消息(SocketIOEvent 参数)
	{
		JSONObject data = 参数.data;
		MessageClass._instance.存信息(data);
		if (ChatController._instance.currentID != null)
		{
			foreach (Message message in MessageClass._instance.messageList)
			{
				if (ChatController._instance.currentID == message.群号)
				{
					ChatController._instance.实例化(message.个人虚号, message.消息);
					if (MessageClass._instance.tipsList.Contains(message))
					{
						MessageClass._instance.tipsList.Remove(message);
					}
				}
				else
				{
					MessageClass._instance.tipsList.Add(message);
				}
			}
		}
		else
		{
			foreach (Message message2 in MessageClass._instance.messageList)
			{
				MessageClass._instance.tipsList.Add(message2);
			}
		}
		foreach (Message tips in MessageClass._instance.tipsList)
		{
			if (!groupIdList.Contains(tips.群号))
			{
				groupIdList.Add(tips.群号);
				MessageTips._instance.群信息提醒(tips.群号);
			}
		}
	}

	public void 群信息(SocketIOEvent 参数)
	{
		JSONObject data = 参数.data;
		foreach (string key in GroupMessage.Keys)
		{
			JSONObject value = null;
			GroupMessage.TryGetValue(key, out value);
			if (value == null)
			{
				GroupMessage[key] = data;
				break;
			}
		}
	}

	public void 创建群成功(SocketIOEvent 参数)
	{
		新的群号 = 参数.data["data"]["insertId"].ToString();
		RightHand._instance.UpdateNewGroup();
	}

	public static void 群消息初始化()
	{
		GroupMessage.Clear();
		int length = 用户信息["自己的信息"]["weiwo_group"].ToString().Length;
		string text = 用户信息["自己的信息"]["weiwo_group"].ToString().Substring(1, length - 2);
		if (text == null && !(text == ""))
		{
			return;
		}
		string[] array = text.Split(',');
		foreach (string text2 in array)
		{
			Dictionary<string, string> dictionary = new Dictionary<string, string>();
			dictionary["id"] = text2;
			if (text2 == "")
			{
				break;
			}
			GC.套接.Emit("获取群信息", new JSONObject(dictionary));
			GroupMessage.Add(text2, null);
		}
	}

	public static void 设置新群信息(string n, string friendArray)
	{
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		dictionary["name"] = n;
		dictionary["haoyou"] = friendArray;
		GC.套接.Emit("创建群", new JSONObject(dictionary));
	}

	public static void 发送群信息(string id, string message)
	{
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		dictionary["id"] = id;
		dictionary["信息"] = message;
		GC.套接.Emit("群聊", new JSONObject(dictionary));
	}

	public static void 删除群(string id)
	{
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		dictionary["id"] = id;
		GC.套接.Emit("删除群", new JSONObject(dictionary));
	}

	public static void 再添加好友(string id, string idArray)
	{
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		dictionary["haoyou"] = idArray;
		dictionary["id"] = id;
		GC.套接.Emit("把好友添加进群", new JSONObject(dictionary));
	}

	public static void 修改群名(string id, string name)
	{
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		dictionary["name"] = name;
		dictionary["id"] = id;
		GC.套接.Emit("更改群名", new JSONObject(dictionary));
	}

	public void 接收私聊(SocketIOEvent 参数)
	{
		MessageClass._instance.存个人信息(参数.data);
		if (ChatController._instance.currentID != null)
		{
			foreach (PersonMessage personMessage in MessageClass._instance.personMessageList)
			{
				if (personMessage.个人虚号 == ChatController._instance.currentID)
				{
					ChatController._instance.实例化(ChatController._instance.currentID, personMessage.消息);
					if (MessageClass._instance.persontipsList.Contains(personMessage))
					{
						MessageClass._instance.persontipsList.Remove(personMessage);
					}
					else
					{
						MessageClass._instance.persontipsList.Add(personMessage);
					}
				}
			}
		}
		else
		{
			foreach (PersonMessage personMessage2 in MessageClass._instance.personMessageList)
			{
				MessageClass._instance.persontipsList.Add(personMessage2);
			}
		}
		foreach (PersonMessage persontips in MessageClass._instance.persontipsList)
		{
			if (!idList.Contains(persontips.个人虚号))
			{
				idList.Add(persontips.个人虚号);
				MessageTips._instance.个人信息提醒(persontips.个人虚号);
			}
		}
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.L))
		{
			设置新群信息("qun", "12345,10086,19999");
		}
	}

	public static void 发送私聊信息(string id, string message)
	{
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		dictionary["id"] = id;
		dictionary["data"] = message;
		GC.套接.Emit("私聊", new JSONObject(dictionary));
	}

	public void 虚我号信息(SocketIOEvent 参数)
	{
		查询的信息.Add(参数.data);
	}

	public void 好友请求(SocketIOEvent 参数)
	{
		string text = 参数.data["请求者"].ToString();
		if (!申请好友列表.Contains(text) && text != FriendData._intance.自己.Xuwo_id)
		{
			申请好友列表.Add(text);
		}
		Ray_Controller._instance.添加好友提醒.SetActive(value: true);
	}

	public void 好友同意添加(SocketIOEvent 参数)
	{
		string text = 参数.data["同意"].ToString();
		text = text.Substring(1, text.Length - 2);
		string text2 = 参数.data["虚我号"].ToString();
		if (text == "true")
		{
			添加好友(text2);
			if (!申请好友成功反馈.Contains(text2))
			{
				申请好友成功反馈.Add(text2);
			}
			Ray_Controller._instance.好友同意添加反馈();
		}
	}

	public static void 查询虚我号信息(string id)
	{
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		dictionary["虚我号"] = id;
		GC.套接.Emit("查询虚我号", new JSONObject(dictionary));
	}

	public static void 删除好友(string id)
	{
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		dictionary["虚我号"] = id;
		GC.套接.Emit("删除好友", new JSONObject(dictionary));
	}

	public static void 好友申请(string id)
	{
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		dictionary["虚我号"] = id;
		GC.套接.Emit("好友请求", new JSONObject(dictionary));
	}

	public static void 好友同意(string id, string b)
	{
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		dictionary["虚我号"] = id;
		dictionary["同意"] = b;
		GC.套接.Emit("好友同意添加", new JSONObject(dictionary));
	}

	public static void 添加好友(string id)
	{
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		dictionary["虚我号"] = id;
		GC.套接.Emit("好友添加", new JSONObject(dictionary));
	}
}
public class StaticFuction
{
	public static SocketIOComponent 套接;

	public static ectScript 函字符串分割;

	public static GameObject VR框;

	public static void init()
	{
	}
}
public class JSONObject
{
	public enum Type
	{
		NULL,
		STRING,
		NUMBER,
		OBJECT,
		ARRAY,
		BOOL,
		BAKED
	}

	public delegate void AddJSONConents(JSONObject self);

	public delegate void FieldNotFound(string name);

	public delegate void GetFieldResponse(JSONObject obj);

	private const int MAX_DEPTH = 100;

	private const string INFINITY = "\"INFINITY\"";

	private const string NEGINFINITY = "\"NEGINFINITY\"";

	private const string NaN = "\"NaN\"";

	private static readonly char[] WHITESPACE = new char[4] { ' ', '\r', '\n', '\t' };

	public Type type;

	public List<JSONObject> list;

	public List<string> keys;

	public string str;

	public float n;

	public bool b;

	private const float maxFrameTime = 0.008f;

	private static readonly Stopwatch printWatch = new Stopwatch();

	public bool isContainer
	{
		get
		{
			if (type != Type.ARRAY)
			{
				return type == Type.OBJECT;
			}
			return true;
		}
	}

	public int Count
	{
		get
		{
			if (list == null)
			{
				return -1;
			}
			return list.Count;
		}
	}

	public float f => n;

	public static JSONObject nullJO => Create(Type.NULL);

	public static JSONObject obj => Create(Type.OBJECT);

	public static JSONObject arr => Create(Type.ARRAY);

	public bool IsNumber => type == Type.NUMBER;

	public bool IsNull => type == Type.NULL;

	public bool IsString => type == Type.STRING;

	public bool IsBool => type == Type.BOOL;

	public bool IsArray => type == Type.ARRAY;

	public bool IsObject => type == Type.OBJECT;

	public JSONObject this[int index]
	{
		get
		{
			if (list.Count > index)
			{
				return list[index];
			}
			return null;
		}
		set
		{
			if (list.Count > index)
			{
				list[index] = value;
			}
		}
	}

	public JSONObject this[string index]
	{
		get
		{
			return GetField(index);
		}
		set
		{
			SetField(index, value);
		}
	}

	public JSONObject(Type t)
	{
		type = t;
		switch (t)
		{
		case Type.ARRAY:
			list = new List<JSONObject>();
			break;
		case Type.OBJECT:
			list = new List<JSONObject>();
			keys = new List<string>();
			break;
		}
	}

	public JSONObject(bool b)
	{
		type = Type.BOOL;
		this.b = b;
	}

	public JSONObject(float f)
	{
		type = Type.NUMBER;
		n = f;
	}

	public JSONObject(Dictionary<string, string> dic)
	{
		type = Type.OBJECT;
		keys = new List<string>();
		list = new List<JSONObject>();
		foreach (KeyValuePair<string, string> item in dic)
		{
			keys.Add(item.Key);
			list.Add(CreateStringObject(item.Value));
		}
	}

	public JSONObject(Dictionary<string, JSONObject> dic)
	{
		type = Type.OBJECT;
		keys = new List<string>();
		list = new List<JSONObject>();
		foreach (KeyValuePair<string, JSONObject> item in dic)
		{
			keys.Add(item.Key);
			list.Add(item.Value);
		}
	}

	public JSONObject(AddJSONConents content)
	{
		content(this);
	}

	public JSONObject(JSONObject[] objs)
	{
		type = Type.ARRAY;
		list = new List<JSONObject>(objs);
	}

	public static JSONObject StringObject(string val)
	{
		return CreateStringObject(val);
	}

	public void Absorb(JSONObject obj)
	{
		list.AddRange(obj.list);
		keys.AddRange(obj.keys);
		str = obj.str;
		n = obj.n;
		b = obj.b;
		type = obj.type;
	}

	public static JSONObject Create()
	{
		return new JSONObject();
	}

	public static JSONObject Create(Type t)
	{
		JSONObject jSONObject = Create();
		jSONObject.type = t;
		switch (t)
		{
		case Type.ARRAY:
			jSONObject.list = new List<JSONObject>();
			break;
		case Type.OBJECT:
			jSONObject.list = new List<JSONObject>();
			jSONObject.keys = new List<string>();
			break;
		}
		return jSONObject;
	}

	public static JSONObject Create(bool val)
	{
		JSONObject jSONObject = Create();
		jSONObject.type = Type.BOOL;
		jSONObject.b = val;
		return jSONObject;
	}

	public static JSONObject Create(float val)
	{
		JSONObject jSONObject = Create();
		jSONObject.type = Type.NUMBER;
		jSONObject.n = val;
		return jSONObject;
	}

	public static JSONObject Create(int val)
	{
		JSONObject jSONObject = Create();
		jSONObject.type = Type.NUMBER;
		jSONObject.n = val;
		return jSONObject;
	}

	public static JSONObject CreateStringObject(string val)
	{
		JSONObject jSONObject = Create();
		jSONObject.type = Type.STRING;
		jSONObject.str = val;
		return jSONObject;
	}

	public static JSONObject CreateBakedObject(string val)
	{
		JSONObject jSONObject = Create();
		jSONObject.type = Type.BAKED;
		jSONObject.str = val;
		return jSONObject;
	}

	public static JSONObject Create(string val)
	{
		return Create(val, -2, storeExcessLevels: false, strict: false);
	}

	public static JSONObject Create(string val, int maxDepth)
	{
		return Create(val, maxDepth, storeExcessLevels: false, strict: false);
	}

	public static JSONObject Create(string val, int maxDepth, bool storeExcessLevels)
	{
		return Create(val, maxDepth, storeExcessLevels, strict: false);
	}

	public static JSONObject Create(string val, int maxDepth, bool storeExcessLevels, bool strict)
	{
		JSONObject jSONObject = Create();
		jSONObject.Parse(val, maxDepth, storeExcessLevels, strict);
		return jSONObject;
	}

	public static JSONObject Create(AddJSONConents content)
	{
		JSONObject jSONObject = Create();
		content(jSONObject);
		return jSONObject;
	}

	public static JSONObject Create(Dictionary<string, string> dic)
	{
		JSONObject jSONObject = Create();
		jSONObject.type = Type.OBJECT;
		jSONObject.keys = new List<string>();
		jSONObject.list = new List<JSONObject>();
		foreach (KeyValuePair<string, string> item in dic)
		{
			jSONObject.keys.Add(item.Key);
			jSONObject.list.Add(CreateStringObject(item.Value));
		}
		return jSONObject;
	}

	public JSONObject()
	{
	}

	public JSONObject(string str)
	{
		Parse(str, -2, storeExcessLevels: false, strict: false);
	}

	public JSONObject(string str, int maxDepth, bool storeExcessLevels, bool strict)
	{
		Parse(str, maxDepth, storeExcessLevels, strict);
	}

	private void Parse(string str)
	{
		Parse(str, -2, storeExcessLevels: false, strict: false);
	}

	private void Parse(string str, int maxDepth, bool storeExcessLevels, bool strict)
	{
		if (!string.IsNullOrEmpty(str))
		{
			str = str.Trim(WHITESPACE);
			if (strict && str[0] != '[' && str[0] != '{')
			{
				type = Type.NULL;
				UnityEngine.Debug.LogWarning("Improper (strict) JSON formatting.  First character must be [ or {");
			}
			else if (str.Length > 0)
			{
				if (string.Compare(str, "true", ignoreCase: true) == 0)
				{
					type = Type.BOOL;
					b = true;
					return;
				}
				if (string.Compare(str, "false", ignoreCase: true) == 0)
				{
					type = Type.BOOL;
					b = false;
					return;
				}
				if (string.Compare(str, "null", ignoreCase: true) == 0)
				{
					type = Type.NULL;
					return;
				}
				switch (str)
				{
				case "\"INFINITY\"":
					type = Type.NUMBER;
					n = float.PositiveInfinity;
					return;
				case "\"NEGINFINITY\"":
					type = Type.NUMBER;
					n = float.NegativeInfinity;
					return;
				case "\"NaN\"":
					type = Type.NUMBER;
					n = float.NaN;
					return;
				}
				if (str[0] == '"')
				{
					type = Type.STRING;
					this.str = str.Substring(1, str.Length - 2);
					return;
				}
				int num = 1;
				int num2 = 0;
				switch (str[num2])
				{
				case '{':
					type = Type.OBJECT;
					keys = new List<string>();
					list = new List<JSONObject>();
					break;
				case '[':
					type = Type.ARRAY;
					list = new List<JSONObject>();
					break;
				default:
					try
					{
						n = Convert.ToSingle(str);
						type = Type.NUMBER;
						return;
					}
					catch (FormatException)
					{
						type = Type.NULL;
						UnityEngine.Debug.LogWarning("improper JSON formatting:" + str);
						return;
					}
				}
				string item = "";
				bool flag = false;
				bool flag2 = false;
				int num3 = 0;
				while (++num2 < str.Length)
				{
					if (Array.IndexOf(WHITESPACE, str[num2]) > -1)
					{
						continue;
					}
					if (str[num2] == '\\')
					{
						num2++;
						continue;
					}
					if (str[num2] == '"')
					{
						if (flag)
						{
							if (!flag2 && num3 == 0 && type == Type.OBJECT)
							{
								item = str.Substring(num + 1, num2 - num - 1);
							}
							flag = false;
						}
						else
						{
							if (num3 == 0 && type == Type.OBJECT)
							{
								num = num2;
							}
							flag = true;
						}
					}
					if (flag)
					{
						continue;
					}
					if (type == Type.OBJECT && num3 == 0 && str[num2] == ':')
					{
						num = num2 + 1;
						flag2 = true;
					}
					if (str[num2] == '[' || str[num2] == '{')
					{
						num3++;
					}
					else if (str[num2] == ']' || str[num2] == '}')
					{
						num3--;
					}
					if ((str[num2] != ',' || num3 != 0) && num3 >= 0)
					{
						continue;
					}
					flag2 = false;
					string text = str.Substring(num, num2 - num).Trim(WHITESPACE);
					if (text.Length > 0)
					{
						if (type == Type.OBJECT)
						{
							keys.Add(item);
						}
						if (maxDepth != -1)
						{
							list.Add(Create(text, (maxDepth < -1) ? (-2) : (maxDepth - 1)));
						}
						else if (storeExcessLevels)
						{
							list.Add(CreateBakedObject(text));
						}
					}
					num = num2 + 1;
				}
			}
			else
			{
				type = Type.NULL;
			}
		}
		else
		{
			type = Type.NULL;
		}
	}

	public void Add(bool val)
	{
		Add(Create(val));
	}

	public void Add(float val)
	{
		Add(Create(val));
	}

	public void Add(int val)
	{
		Add(Create(val));
	}

	public void Add(string str)
	{
		Add(CreateStringObject(str));
	}

	public void Add(AddJSONConents content)
	{
		Add(Create(content));
	}

	public void Add(JSONObject obj)
	{
		if (!obj)
		{
			return;
		}
		if (type != Type.ARRAY)
		{
			type = Type.ARRAY;
			if (list == null)
			{
				list = new List<JSONObject>();
			}
		}
		list.Add(obj);
	}

	public void AddField(string name, bool val)
	{
		AddField(name, Create(val));
	}

	public void AddField(string name, float val)
	{
		AddField(name, Create(val));
	}

	public void AddField(string name, int val)
	{
		AddField(name, Create(val));
	}

	public void AddField(string name, AddJSONConents content)
	{
		AddField(name, Create(content));
	}

	public void AddField(string name, string val)
	{
		AddField(name, CreateStringObject(val));
	}

	public void AddField(string name, JSONObject obj)
	{
		if (!obj)
		{
			return;
		}
		if (type != Type.OBJECT)
		{
			if (keys == null)
			{
				keys = new List<string>();
			}
			if (type == Type.ARRAY)
			{
				for (int i = 0; i < list.Count; i++)
				{
					keys.Add(i.ToString() ?? "");
				}
			}
			else if (list == null)
			{
				list = new List<JSONObject>();
			}
			type = Type.OBJECT;
		}
		keys.Add(name);
		list.Add(obj);
	}

	public void SetField(string name, bool val)
	{
		SetField(name, Create(val));
	}

	public void SetField(string name, float val)
	{
		SetField(name, Create(val));
	}

	public void SetField(string name, int val)
	{
		SetField(name, Create(val));
	}

	public void SetField(string name, JSONObject obj)
	{
		if (HasField(name))
		{
			list.Remove(this[name]);
			keys.Remove(name);
		}
		AddField(name, obj);
	}

	public void RemoveField(string name)
	{
		if (keys.IndexOf(name) > -1)
		{
			list.RemoveAt(keys.IndexOf(name));
			keys.Remove(name);
		}
	}

	public void GetField(ref bool field, string name)
	{
		GetField(ref field, name, null);
	}

	public void GetField(ref bool field, string name, FieldNotFound fail)
	{
		if (type == Type.OBJECT)
		{
			int num = keys.IndexOf(name);
			if (num >= 0)
			{
				field = list[num].b;
				return;
			}
		}
		fail?.Invoke(name);
	}

	public void GetField(ref float field, string name)
	{
		GetField(ref field, name, null);
	}

	public void GetField(ref float field, string name, FieldNotFound fail)
	{
		if (type == Type.OBJECT)
		{
			int num = keys.IndexOf(name);
			if (num >= 0)
			{
				field = list[num].n;
				return;
			}
		}
		fail?.Invoke(name);
	}

	public void GetField(ref int field, string name)
	{
		GetField(ref field, name, null);
	}

	public void GetField(ref int field, string name, FieldNotFound fail)
	{
		if (type == Type.OBJECT)
		{
			int num = keys.IndexOf(name);
			if (num >= 0)
			{
				field = (int)list[num].n;
				return;
			}
		}
		fail?.Invoke(name);
	}

	public void GetField(ref uint field, string name)
	{
		GetField(ref field, name, null);
	}

	public void GetField(ref uint field, string name, FieldNotFound fail)
	{
		if (type == Type.OBJECT)
		{
			int num = keys.IndexOf(name);
			if (num >= 0)
			{
				field = (uint)list[num].n;
				return;
			}
		}
		fail?.Invoke(name);
	}

	public void GetField(ref string field, string name)
	{
		GetField(ref field, name, null);
	}

	public void GetField(ref string field, string name, FieldNotFound fail)
	{
		if (type == Type.OBJECT)
		{
			int num = keys.IndexOf(name);
			if (num >= 0)
			{
				field = list[num].str;
				return;
			}
		}
		fail?.Invoke(name);
	}

	public void GetField(string name, GetFieldResponse response)
	{
		GetField(name, response, null);
	}

	public void GetField(string name, GetFieldResponse response, FieldNotFound fail)
	{
		if (response != null && type == Type.OBJECT)
		{
			int num = keys.IndexOf(name);
			if (num >= 0)
			{
				response(list[num]);
				return;
			}
		}
		fail?.Invoke(name);
	}

	public JSONObject GetField(string name)
	{
		if (type == Type.OBJECT)
		{
			for (int i = 0; i < keys.Count; i++)
			{
				if (keys[i] == name)
				{
					return list[i];
				}
			}
		}
		return null;
	}

	public bool HasFields(string[] names)
	{
		for (int i = 0; i < names.Length; i++)
		{
			if (!keys.Contains(names[i]))
			{
				return false;
			}
		}
		return true;
	}

	public bool HasField(string name)
	{
		if (type == Type.OBJECT)
		{
			for (int i = 0; i < keys.Count; i++)
			{
				if (keys[i] == name)
				{
					return true;
				}
			}
		}
		return false;
	}

	public void Clear()
	{
		type = Type.NULL;
		if (list != null)
		{
			list.Clear();
		}
		if (keys != null)
		{
			keys.Clear();
		}
		str = "";
		n = 0f;
		b = false;
	}

	public JSONObject Copy()
	{
		return Create(Print());
	}

	public void Merge(JSONObject obj)
	{
		MergeRecur(this, obj);
	}

	private static void MergeRecur(JSONObject left, JSONObject right)
	{
		if (left.type == Type.NULL)
		{
			left.Absorb(right);
		}
		else if (left.type == Type.OBJECT && right.type == Type.OBJECT)
		{
			for (int i = 0; i < right.list.Count; i++)
			{
				string text = right.keys[i];
				if (right[i].isContainer)
				{
					if (left.HasField(text))
					{
						MergeRecur(left[text], right[i]);
					}
					else
					{
						left.AddField(text, right[i]);
					}
				}
				else if (left.HasField(text))
				{
					left.SetField(text, right[i]);
				}
				else
				{
					left.AddField(text, right[i]);
				}
			}
		}
		else
		{
			if (left.type != Type.ARRAY || right.type != Type.ARRAY)
			{
				return;
			}
			if (right.Count > left.Count)
			{
				UnityEngine.Debug.LogError("Cannot merge arrays when right object has more elements");
				return;
			}
			for (int j = 0; j < right.list.Count; j++)
			{
				if (left[j].type == right[j].type)
				{
					if (left[j].isContainer)
					{
						MergeRecur(left[j], right[j]);
					}
					else
					{
						left[j] = right[j];
					}
				}
			}
		}
	}

	public void Bake()
	{
		if (type != Type.BAKED)
		{
			str = Print();
			type = Type.BAKED;
		}
	}

	public IEnumerable BakeAsync()
	{
		if (type == Type.BAKED)
		{
			yield break;
		}
		foreach (string item in PrintAsync())
		{
			if (item == null)
			{
				yield return item;
			}
			else
			{
				str = item;
			}
		}
		type = Type.BAKED;
	}

	public string Print()
	{
		return Print(pretty: false);
	}

	public string Print(bool pretty)
	{
		StringBuilder stringBuilder = new StringBuilder();
		Stringify(0, stringBuilder, pretty);
		return stringBuilder.ToString();
	}

	public IEnumerable<string> PrintAsync()
	{
		return PrintAsync(pretty: false);
	}

	public IEnumerable<string> PrintAsync(bool pretty)
	{
		StringBuilder builder = new StringBuilder();
		printWatch.Reset();
		printWatch.Start();
		foreach (IEnumerable item in StringifyAsync(0, builder, pretty))
		{
			_ = item;
			yield return null;
		}
		yield return builder.ToString();
	}

	private IEnumerable StringifyAsync(int depth, StringBuilder builder)
	{
		return StringifyAsync(depth, builder, pretty: false);
	}

	private IEnumerable StringifyAsync(int depth, StringBuilder builder, bool pretty)
	{
		if (depth++ > 100)
		{
			UnityEngine.Debug.Log("reached max depth!");
			yield break;
		}
		if (printWatch.Elapsed.TotalSeconds > 0.00800000037997961)
		{
			printWatch.Reset();
			yield return null;
			printWatch.Start();
		}
		switch (type)
		{
		case Type.BAKED:
			builder.Append(str);
			break;
		case Type.STRING:
			builder.AppendFormat("\"{0}\"", str);
			break;
		case Type.NUMBER:
			if (float.IsInfinity(this.n))
			{
				builder.Append("\"INFINITY\"");
			}
			else if (float.IsNegativeInfinity(this.n))
			{
				builder.Append("\"NEGINFINITY\"");
			}
			else if (float.IsNaN(this.n))
			{
				builder.Append("\"NaN\"");
			}
			else
			{
				builder.Append(this.n.ToString());
			}
			break;
		case Type.OBJECT:
			builder.Append("{");
			if (list.Count > 0)
			{
				if (pretty)
				{
					builder.Append("\n");
				}
				for (int j = 0; j < list.Count; j++)
				{
					string arg = keys[j];
					JSONObject jSONObject = list[j];
					if (!jSONObject)
					{
						continue;
					}
					if (pretty)
					{
						for (int k = 0; k < depth; k++)
						{
							builder.Append("\t");
						}
					}
					builder.AppendFormat("\"{0}\":", arg);
					foreach (IEnumerable item in jSONObject.StringifyAsync(depth, builder, pretty))
					{
						yield return item;
					}
					builder.Append(",");
					if (pretty)
					{
						builder.Append("\n");
					}
				}
				if (pretty)
				{
					builder.Length -= 2;
				}
				else
				{
					builder.Length--;
				}
			}
			if (pretty && list.Count > 0)
			{
				builder.Append("\n");
				for (int l = 0; l < depth - 1; l++)
				{
					builder.Append("\t");
				}
			}
			builder.Append("}");
			break;
		case Type.ARRAY:
			builder.Append("[");
			if (list.Count > 0)
			{
				if (pretty)
				{
					builder.Append("\n");
				}
				for (int j = 0; j < list.Count; j++)
				{
					if (!list[j])
					{
						continue;
					}
					if (pretty)
					{
						for (int m = 0; m < depth; m++)
						{
							builder.Append("\t");
						}
					}
					foreach (IEnumerable item2 in list[j].StringifyAsync(depth, builder, pretty))
					{
						yield return item2;
					}
					builder.Append(",");
					if (pretty)
					{
						builder.Append("\n");
					}
				}
				if (pretty)
				{
					builder.Length -= 2;
				}
				else
				{
					builder.Length--;
				}
			}
			if (pretty && list.Count > 0)
			{
				builder.Append("\n");
				for (int n = 0; n < depth - 1; n++)
				{
					builder.Append("\t");
				}
			}
			builder.Append("]");
			break;
		case Type.BOOL:
			if (b)
			{
				builder.Append("true");
			}
			else
			{
				builder.Append("false");
			}
			break;
		case Type.NULL:
			builder.Append("null");
			break;
		}
	}

	private void Stringify(int depth, StringBuilder builder)
	{
		Stringify(depth, builder, pretty: false);
	}

	private void Stringify(int depth, StringBuilder builder, bool pretty)
	{
		if (depth++ > 100)
		{
			UnityEngine.Debug.Log("reached max depth!");
			return;
		}
		switch (type)
		{
		case Type.BAKED:
			builder.Append(str);
			break;
		case Type.STRING:
			builder.AppendFormat("\"{0}\"", str);
			break;
		case Type.NUMBER:
			if (float.IsInfinity(this.n))
			{
				builder.Append("\"INFINITY\"");
			}
			else if (float.IsNegativeInfinity(this.n))
			{
				builder.Append("\"NEGINFINITY\"");
			}
			else if (float.IsNaN(this.n))
			{
				builder.Append("\"NaN\"");
			}
			else
			{
				builder.Append(this.n.ToString());
			}
			break;
		case Type.OBJECT:
			builder.Append("{");
			if (list.Count > 0)
			{
				if (pretty)
				{
					builder.Append("\n");
				}
				for (int i = 0; i < list.Count; i++)
				{
					string arg = keys[i];
					JSONObject jSONObject = list[i];
					if (!jSONObject)
					{
						continue;
					}
					if (pretty)
					{
						for (int j = 0; j < depth; j++)
						{
							builder.Append("\t");
						}
					}
					builder.AppendFormat("\"{0}\":", arg);
					jSONObject.Stringify(depth, builder, pretty);
					builder.Append(",");
					if (pretty)
					{
						builder.Append("\n");
					}
				}
				if (pretty)
				{
					builder.Length -= 2;
				}
				else
				{
					builder.Length--;
				}
			}
			if (pretty && list.Count > 0)
			{
				builder.Append("\n");
				for (int k = 0; k < depth - 1; k++)
				{
					builder.Append("\t");
				}
			}
			builder.Append("}");
			break;
		case Type.ARRAY:
			builder.Append("[");
			if (list.Count > 0)
			{
				if (pretty)
				{
					builder.Append("\n");
				}
				for (int l = 0; l < list.Count; l++)
				{
					if (!list[l])
					{
						continue;
					}
					if (pretty)
					{
						for (int m = 0; m < depth; m++)
						{
							builder.Append("\t");
						}
					}
					list[l].Stringify(depth, builder, pretty);
					builder.Append(",");
					if (pretty)
					{
						builder.Append("\n");
					}
				}
				if (pretty)
				{
					builder.Length -= 2;
				}
				else
				{
					builder.Length--;
				}
			}
			if (pretty && list.Count > 0)
			{
				builder.Append("\n");
				for (int n = 0; n < depth - 1; n++)
				{
					builder.Append("\t");
				}
			}
			builder.Append("]");
			break;
		case Type.BOOL:
			if (b)
			{
				builder.Append("true");
			}
			else
			{
				builder.Append("false");
			}
			break;
		case Type.NULL:
			builder.Append("null");
			break;
		}
	}

	public static implicit operator WWWForm(JSONObject obj)
	{
		WWWForm wWWForm = new WWWForm();
		for (int i = 0; i < obj.list.Count; i++)
		{
			string fieldName = i.ToString() ?? "";
			if (obj.type == Type.OBJECT)
			{
				fieldName = obj.keys[i];
			}
			string text = obj.list[i].ToString();
			if (obj.list[i].type == Type.STRING)
			{
				text = text.Replace("\"", "");
			}
			wWWForm.AddField(fieldName, text);
		}
		return wWWForm;
	}

	public override string ToString()
	{
		return Print();
	}

	public string ToString(bool pretty)
	{
		return Print(pretty);
	}

	public Dictionary<string, string> ToDictionary()
	{
		if (type == Type.OBJECT)
		{
			Dictionary<string, string> dictionary = new Dictionary<string, string>();
			for (int i = 0; i < list.Count; i++)
			{
				JSONObject jSONObject = list[i];
				switch (jSONObject.type)
				{
				case Type.STRING:
					dictionary.Add(keys[i], jSONObject.str);
					break;
				case Type.NUMBER:
					dictionary.Add(keys[i], jSONObject.n.ToString() ?? "");
					break;
				case Type.BOOL:
					dictionary.Add(keys[i], jSONObject.b.ToString() ?? "");
					break;
				default:
					UnityEngine.Debug.LogWarning("Omitting object: " + keys[i] + " in dictionary conversion");
					break;
				}
			}
			return dictionary;
		}
		UnityEngine.Debug.LogWarning("Tried to turn non-Object JSONObject into a dictionary");
		return null;
	}

	public static implicit operator bool(JSONObject o)
	{
		return o != null;
	}
}
public static class JSONTemplates
{
	private static readonly HashSet<object> touched = new HashSet<object>();

	public static JSONObject TOJSON(object obj)
	{
		if (touched.Add(obj))
		{
			JSONObject obj2 = JSONObject.obj;
			FieldInfo[] fields = obj.GetType().GetFields();
			foreach (FieldInfo fieldInfo in fields)
			{
				JSONObject jSONObject = JSONObject.nullJO;
				if (!fieldInfo.GetValue(obj).Equals(null))
				{
					MethodInfo method = typeof(JSONTemplates).GetMethod("From" + fieldInfo.FieldType.Name);
					jSONObject = ((method != null) ? ((JSONObject)method.Invoke(null, new object[1] { fieldInfo.GetValue(obj) })) : ((!(fieldInfo.FieldType == typeof(string))) ? JSONObject.Create(fieldInfo.GetValue(obj).ToString()) : JSONObject.CreateStringObject(fieldInfo.GetValue(obj).ToString())));
				}
				if ((bool)jSONObject)
				{
					if (jSONObject.type != 0)
					{
						obj2.AddField(fieldInfo.Name, jSONObject);
						continue;
					}
					UnityEngine.Debug.LogWarning("Null for this non-null object, property " + fieldInfo.Name + " of class " + obj.GetType().Name + ". Object type is " + fieldInfo.FieldType.Name);
				}
			}
			PropertyInfo[] properties = obj.GetType().GetProperties();
			foreach (PropertyInfo propertyInfo in properties)
			{
				JSONObject jSONObject2 = JSONObject.nullJO;
				if (!propertyInfo.GetValue(obj, null).Equals(null))
				{
					MethodInfo method2 = typeof(JSONTemplates).GetMethod("From" + propertyInfo.PropertyType.Name);
					jSONObject2 = ((method2 != null) ? ((JSONObject)method2.Invoke(null, new object[1] { propertyInfo.GetValue(obj, null) })) : ((!(propertyInfo.PropertyType == typeof(string))) ? JSONObject.Create(propertyInfo.GetValue(obj, null).ToString()) : JSONObject.CreateStringObject(propertyInfo.GetValue(obj, null).ToString())));
				}
				if ((bool)jSONObject2)
				{
					if (jSONObject2.type != 0)
					{
						obj2.AddField(propertyInfo.Name, jSONObject2);
						continue;
					}
					UnityEngine.Debug.LogWarning("Null for this non-null object, property " + propertyInfo.Name + " of class " + obj.GetType().Name + ". Object type is " + propertyInfo.PropertyType.Name);
				}
			}
			return obj2;
		}
		UnityEngine.Debug.LogWarning("trying to save the same data twice");
		return JSONObject.nullJO;
	}

	public static Vector2 ToVector2(JSONObject obj)
	{
		float x = (obj["x"] ? obj["x"].f : 0f);
		float y = (obj["y"] ? obj["y"].f : 0f);
		return new Vector2(x, y);
	}

	public static JSONObject FromVector2(Vector2 v)
	{
		JSONObject obj = JSONObject.obj;
		if (v.x != 0f)
		{
			obj.AddField("x", v.x);
		}
		if (v.y != 0f)
		{
			obj.AddField("y", v.y);
		}
		return obj;
	}

	public static JSONObject FromVector3(Vector3 v)
	{
		JSONObject obj = JSONObject.obj;
		if (v.x != 0f)
		{
			obj.AddField("x", v.x);
		}
		if (v.y != 0f)
		{
			obj.AddField("y", v.y);
		}
		if (v.z != 0f)
		{
			obj.AddField("z", v.z);
		}
		return obj;
	}

	public static Vector3 ToVector3(JSONObject obj)
	{
		float x = (obj["x"] ? obj["x"].f : 0f);
		float y = (obj["y"] ? obj["y"].f : 0f);
		float z = (obj["z"] ? obj["z"].f : 0f);
		return new Vector3(x, y, z);
	}

	public static JSONObject FromVector4(Vector4 v)
	{
		JSONObject obj = JSONObject.obj;
		if (v.x != 0f)
		{
			obj.AddField("x", v.x);
		}
		if (v.y != 0f)
		{
			obj.AddField("y", v.y);
		}
		if (v.z != 0f)
		{
			obj.AddField("z", v.z);
		}
		if (v.w != 0f)
		{
			obj.AddField("w", v.w);
		}
		return obj;
	}

	public static Vector4 ToVector4(JSONObject obj)
	{
		float x = (obj["x"] ? obj["x"].f : 0f);
		float y = (obj["y"] ? obj["y"].f : 0f);
		float z = (obj["z"] ? obj["z"].f : 0f);
		float w = (obj["w"] ? obj["w"].f : 0f);
		return new Vector4(x, y, z, w);
	}

	public static JSONObject FromMatrix4x4(Matrix4x4 m)
	{
		JSONObject obj = JSONObject.obj;
		if (m.m00 != 0f)
		{
			obj.AddField("m00", m.m00);
		}
		if (m.m01 != 0f)
		{
			obj.AddField("m01", m.m01);
		}
		if (m.m02 != 0f)
		{
			obj.AddField("m02", m.m02);
		}
		if (m.m03 != 0f)
		{
			obj.AddField("m03", m.m03);
		}
		if (m.m10 != 0f)
		{
			obj.AddField("m10", m.m10);
		}
		if (m.m11 != 0f)
		{
			obj.AddField("m11", m.m11);
		}
		if (m.m12 != 0f)
		{
			obj.AddField("m12", m.m12);
		}
		if (m.m13 != 0f)
		{
			obj.AddField("m13", m.m13);
		}
		if (m.m20 != 0f)
		{
			obj.AddField("m20", m.m20);
		}
		if (m.m21 != 0f)
		{
			obj.AddField("m21", m.m21);
		}
		if (m.m22 != 0f)
		{
			obj.AddField("m22", m.m22);
		}
		if (m.m23 != 0f)
		{
			obj.AddField("m23", m.m23);
		}
		if (m.m30 != 0f)
		{
			obj.AddField("m30", m.m30);
		}
		if (m.m31 != 0f)
		{
			obj.AddField("m31", m.m31);
		}
		if (m.m32 != 0f)
		{
			obj.AddField("m32", m.m32);
		}
		if (m.m33 != 0f)
		{
			obj.AddField("m33", m.m33);
		}
		return obj;
	}

	public static Matrix4x4 ToMatrix4x4(JSONObject obj)
	{
		Matrix4x4 result = default(Matrix4x4);
		if ((bool)obj["m00"])
		{
			result.m00 = obj["m00"].f;
		}
		if ((bool)obj["m01"])
		{
			result.m01 = obj["m01"].f;
		}
		if ((bool)obj["m02"])
		{
			result.m02 = obj["m02"].f;
		}
		if ((bool)obj["m03"])
		{
			result.m03 = obj["m03"].f;
		}
		if ((bool)obj["m10"])
		{
			result.m10 = obj["m10"].f;
		}
		if ((bool)obj["m11"])
		{
			result.m11 = obj["m11"].f;
		}
		if ((bool)obj["m12"])
		{
			result.m12 = obj["m12"].f;
		}
		if ((bool)obj["m13"])
		{
			result.m13 = obj["m13"].f;
		}
		if ((bool)obj["m20"])
		{
			result.m20 = obj["m20"].f;
		}
		if ((bool)obj["m21"])
		{
			result.m21 = obj["m21"].f;
		}
		if ((bool)obj["m22"])
		{
			result.m22 = obj["m22"].f;
		}
		if ((bool)obj["m23"])
		{
			result.m23 = obj["m23"].f;
		}
		if ((bool)obj["m30"])
		{
			result.m30 = obj["m30"].f;
		}
		if ((bool)obj["m31"])
		{
			result.m31 = obj["m31"].f;
		}
		if ((bool)obj["m32"])
		{
			result.m32 = obj["m32"].f;
		}
		if ((bool)obj["m33"])
		{
			result.m33 = obj["m33"].f;
		}
		return result;
	}

	public static JSONObject FromQuaternion(Quaternion q)
	{
		JSONObject obj = JSONObject.obj;
		if (q.w != 0f)
		{
			obj.AddField("w", q.w);
		}
		if (q.x != 0f)
		{
			obj.AddField("x", q.x);
		}
		if (q.y != 0f)
		{
			obj.AddField("y", q.y);
		}
		if (q.z != 0f)
		{
			obj.AddField("z", q.z);
		}
		return obj;
	}

	public static Quaternion ToQuaternion(JSONObject obj)
	{
		float x = (obj["x"] ? obj["x"].f : 0f);
		float y = (obj["y"] ? obj["y"].f : 0f);
		float z = (obj["z"] ? obj["z"].f : 0f);
		float w = (obj["w"] ? obj["w"].f : 0f);
		return new Quaternion(x, y, z, w);
	}

	public static JSONObject FromColor(Color c)
	{
		JSONObject obj = JSONObject.obj;
		if (c.r != 0f)
		{
			obj.AddField("r", c.r);
		}
		if (c.g != 0f)
		{
			obj.AddField("g", c.g);
		}
		if (c.b != 0f)
		{
			obj.AddField("b", c.b);
		}
		if (c.a != 0f)
		{
			obj.AddField("a", c.a);
		}
		return obj;
	}

	public static Color ToColor(JSONObject obj)
	{
		Color result = default(Color);
		for (int i = 0; i < obj.Count; i++)
		{
			switch (obj.keys[i])
			{
			case "r":
				result.r = obj[i].f;
				break;
			case "g":
				result.g = obj[i].f;
				break;
			case "b":
				result.b = obj[i].f;
				break;
			case "a":
				result.a = obj[i].f;
				break;
			}
		}
		return result;
	}

	public static JSONObject FromLayerMask(LayerMask l)
	{
		JSONObject obj = JSONObject.obj;
		obj.AddField("value", l.value);
		return obj;
	}

	public static LayerMask ToLayerMask(JSONObject obj)
	{
		LayerMask result = default(LayerMask);
		result.value = (int)obj["value"].n;
		return result;
	}

	public static JSONObject FromRect(Rect r)
	{
		JSONObject obj = JSONObject.obj;
		if (r.x != 0f)
		{
			obj.AddField("x", r.x);
		}
		if (r.y != 0f)
		{
			obj.AddField("y", r.y);
		}
		if (r.height != 0f)
		{
			obj.AddField("height", r.height);
		}
		if (r.width != 0f)
		{
			obj.AddField("width", r.width);
		}
		return obj;
	}

	public static Rect ToRect(JSONObject obj)
	{
		Rect result = default(Rect);
		for (int i = 0; i < obj.Count; i++)
		{
			switch (obj.keys[i])
			{
			case "x":
				result.x = obj[i].f;
				break;
			case "y":
				result.y = obj[i].f;
				break;
			case "height":
				result.height = obj[i].f;
				break;
			case "width":
				result.width = obj[i].f;
				break;
			}
		}
		return result;
	}

	public static JSONObject FromRectOffset(RectOffset r)
	{
		JSONObject obj = JSONObject.obj;
		if (r.bottom != 0)
		{
			obj.AddField("bottom", r.bottom);
		}
		if (r.left != 0)
		{
			obj.AddField("left", r.left);
		}
		if (r.right != 0)
		{
			obj.AddField("right", r.right);
		}
		if (r.top != 0)
		{
			obj.AddField("top", r.top);
		}
		return obj;
	}

	public static RectOffset ToRectOffset(JSONObject obj)
	{
		RectOffset rectOffset = new RectOffset();
		for (int i = 0; i < obj.Count; i++)
		{
			switch (obj.keys[i])
			{
			case "bottom":
				rectOffset.bottom = (int)obj[i].n;
				break;
			case "left":
				rectOffset.left = (int)obj[i].n;
				break;
			case "right":
				rectOffset.right = (int)obj[i].n;
				break;
			case "top":
				rectOffset.top = (int)obj[i].n;
				break;
			}
		}
		return rectOffset;
	}

	public static AnimationCurve ToAnimationCurve(JSONObject obj)
	{
		AnimationCurve animationCurve = new AnimationCurve();
		if (obj.HasField("keys"))
		{
			JSONObject field = obj.GetField("keys");
			for (int i = 0; i < field.list.Count; i++)
			{
				animationCurve.AddKey(ToKeyframe(field[i]));
			}
		}
		if (obj.HasField("preWrapMode"))
		{
			animationCurve.preWrapMode = (WrapMode)obj.GetField("preWrapMode").n;
		}
		if (obj.HasField("postWrapMode"))
		{
			animationCurve.postWrapMode = (WrapMode)obj.GetField("postWrapMode").n;
		}
		return animationCurve;
	}

	public static JSONObject FromAnimationCurve(AnimationCurve a)
	{
		JSONObject obj = JSONObject.obj;
		obj.AddField("preWrapMode", a.preWrapMode.ToString());
		obj.AddField("postWrapMode", a.postWrapMode.ToString());
		if (a.keys.Length != 0)
		{
			JSONObject jSONObject = JSONObject.Create();
			for (int i = 0; i < a.keys.Length; i++)
			{
				jSONObject.Add(FromKeyframe(a.keys[i]));
			}
			obj.AddField("keys", jSONObject);
		}
		return obj;
	}

	public static Keyframe ToKeyframe(JSONObject obj)
	{
		Keyframe result = new Keyframe(obj.HasField("time") ? obj.GetField("time").n : 0f, obj.HasField("value") ? obj.GetField("value").n : 0f);
		if (obj.HasField("inTangent"))
		{
			result.inTangent = obj.GetField("inTangent").n;
		}
		if (obj.HasField("outTangent"))
		{
			result.outTangent = obj.GetField("outTangent").n;
		}
		if (obj.HasField("tangentMode"))
		{
			result.tangentMode = (int)obj.GetField("tangentMode").n;
		}
		return result;
	}

	public static JSONObject FromKeyframe(Keyframe k)
	{
		JSONObject obj = JSONObject.obj;
		if (k.inTangent != 0f)
		{
			obj.AddField("inTangent", k.inTangent);
		}
		if (k.outTangent != 0f)
		{
			obj.AddField("outTangent", k.outTangent);
		}
		if (k.tangentMode != 0)
		{
			obj.AddField("tangentMode", k.tangentMode);
		}
		if (k.time != 0f)
		{
			obj.AddField("time", k.time);
		}
		if (k.value != 0f)
		{
			obj.AddField("value", k.value);
		}
		return obj;
	}
}
public class TestSocketIO : MonoBehaviour
{
	private SocketIOComponent socket;

	public void Start()
	{
		GameObject gameObject = GameObject.Find("SocketIO");
		socket = gameObject.GetComponent<SocketIOComponent>();
		socket.On("open", TestOpen);
		socket.On("boop", TestBoop);
		socket.On("error", TestError);
		socket.On("close", TestClose);
		StartCoroutine("BeepBoop");
	}

	private IEnumerator BeepBoop()
	{
		yield return new WaitForSeconds(1f);
		socket.Emit("beep");
		yield return new WaitForSeconds(3f);
		socket.Emit("beep");
		yield return new WaitForSeconds(2f);
		socket.Emit("beep");
		yield return null;
		socket.Emit("beep");
		socket.Emit("beep");
	}

	public void TestOpen(SocketIOEvent e)
	{
		UnityEngine.Debug.Log("[SocketIO] Open received: " + e.name + " " + e.data);
	}

	public void TestBoop(SocketIOEvent e)
	{
		UnityEngine.Debug.Log("[SocketIO] Boop received: " + e.name + " " + e.data);
		if (e.data != null)
		{
			UnityEngine.Debug.Log("#####################################################THIS: " + e.data.GetField("this").str + "#####################################################");
		}
	}

	public void TestError(SocketIOEvent e)
	{
		UnityEngine.Debug.Log("[SocketIO] Error received: " + e.name + " " + e.data);
	}

	public void TestClose(SocketIOEvent e)
	{
		UnityEngine.Debug.Log("[SocketIO] Close received: " + e.name + " " + e.data);
	}
}
public class CustomEditorExample : MonoBehaviour
{
	public float floatType;

	public int intType;

	public string stringType = "string";

	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class BasicRigidBodyPush : MonoBehaviour
{
	public LayerMask pushLayers;

	public bool canPush;

	[Range(0.5f, 5f)]
	public float strength = 1.1f;

	private void OnControllerColliderHit(ControllerColliderHit hit)
	{
		if (canPush)
		{
			PushRigidBodies(hit);
		}
	}

	private void PushRigidBodies(ControllerColliderHit hit)
	{
		Rigidbody attachedRigidbody = hit.collider.attachedRigidbody;
		if (!(attachedRigidbody == null) && !attachedRigidbody.isKinematic && ((1 << attachedRigidbody.gameObject.layer) & pushLayers.value) != 0 && !(hit.moveDirection.y < -0.3f))
		{
			Vector3 vector = new Vector3(hit.moveDirection.x, 0f, hit.moveDirection.z);
			attachedRigidbody.AddForce(vector * strength, ForceMode.Impulse);
		}
	}
}
public class MobileDisableAutoSwitchControls : MonoBehaviour
{
	[Header("Target")]
	public PlayerInput playerInput;

	private void Start()
	{
		DisableAutoSwitchControls();
	}

	private void DisableAutoSwitchControls()
	{
		playerInput.neverAutoSwitchControlSchemes = true;
	}
}
public class UIVirtualButton : MonoBehaviour, IPointerDownHandler, IEventSystemHandler, IPointerUpHandler, IPointerClickHandler
{
	[Serializable]
	public class BoolEvent : UnityEvent<bool>
	{
	}

	[Serializable]
	public class Event : UnityEvent
	{
	}

	[Header("Output")]
	public BoolEvent buttonStateOutputEvent;

	public Event buttonClickOutputEvent;

	public void OnPointerDown(PointerEventData eventData)
	{
		OutputButtonStateValue(buttonState: true);
	}

	public void OnPointerUp(PointerEventData eventData)
	{
		OutputButtonStateValue(buttonState: false);
	}

	public void OnPointerClick(PointerEventData eventData)
	{
		OutputButtonClickEvent();
	}

	private void OutputButtonStateValue(bool buttonState)
	{
		buttonStateOutputEvent.Invoke(buttonState);
	}

	private void OutputButtonClickEvent()
	{
		buttonClickOutputEvent.Invoke();
	}
}
public class UIVirtualJoystick : MonoBehaviour, IPointerDownHandler, IEventSystemHandler, IDragHandler, IPointerUpHandler
{
	[Serializable]
	public class Event : UnityEvent<Vector2>
	{
	}

	[Header("Rect References")]
	public RectTransform containerRect;

	public RectTransform handleRect;

	[Header("Settings")]
	public float joystickRange = 50f;

	public float magnitudeMultiplier = 1f;

	public bool invertXOutputValue;

	public bool invertYOutputValue;

	[Header("Output")]
	public Event joystickOutputEvent;

	private void Start()
	{
		SetupHandle();
	}

	private void SetupHandle()
	{
		if ((bool)handleRect)
		{
			UpdateHandleRectPosition(Vector2.zero);
		}
	}

	public void OnPointerDown(PointerEventData eventData)
	{
		OnDrag(eventData);
	}

	public void OnDrag(PointerEventData eventData)
	{
		RectTransformUtility.ScreenPointToLocalPointInRectangle(containerRect, eventData.position, eventData.pressEventCamera, out var localPoint);
		localPoint = ApplySizeDelta(localPoint);
		Vector2 vector = ClampValuesToMagnitude(localPoint);
		Vector2 vector2 = ApplyInversionFilter(localPoint);
		OutputPointerEventValue(vector2 * magnitudeMultiplier);
		if ((bool)handleRect)
		{
			UpdateHandleRectPosition(vector * joystickRange);
		}
	}

	public void OnPointerUp(PointerEventData eventData)
	{
		OutputPointerEventValue(Vector2.zero);
		if ((bool)handleRect)
		{
			UpdateHandleRectPosition(Vector2.zero);
		}
	}

	private void OutputPointerEventValue(Vector2 pointerPosition)
	{
		joystickOutputEvent.Invoke(pointerPosition);
	}

	private void UpdateHandleRectPosition(Vector2 newPosition)
	{
		handleRect.anchoredPosition = newPosition;
	}

	private Vector2 ApplySizeDelta(Vector2 position)
	{
		float x = position.x / containerRect.sizeDelta.x * 2.5f;
		float y = position.y / containerRect.sizeDelta.y * 2.5f;
		return new Vector2(x, y);
	}

	private Vector2 ClampValuesToMagnitude(Vector2 position)
	{
		return Vector2.ClampMagnitude(position, 1f);
	}

	private Vector2 ApplyInversionFilter(Vector2 position)
	{
		if (invertXOutputValue)
		{
			position.x = InvertValue(position.x);
		}
		if (invertYOutputValue)
		{
			position.y = InvertValue(position.y);
		}
		return position;
	}

	private float InvertValue(float value)
	{
		return 0f - value;
	}
}
public class UIVirtualTouchZone : MonoBehaviour, IPointerDownHandler, IEventSystemHandler, IDragHandler, IPointerUpHandler
{
	[Serializable]
	public class Event : UnityEvent<Vector2>
	{
	}

	[Header("Rect References")]
	public RectTransform containerRect;

	public RectTransform handleRect;

	[Header("Settings")]
	public bool clampToMagnitude;

	public float magnitudeMultiplier = 1f;

	public bool invertXOutputValue;

	public bool invertYOutputValue;

	private Vector2 pointerDownPosition;

	private Vector2 currentPointerPosition;

	[Header("Output")]
	public Event touchZoneOutputEvent;

	private void Start()
	{
		SetupHandle();
	}

	private void SetupHandle()
	{
		if ((bool)handleRect)
		{
			SetObjectActiveState(handleRect.gameObject, newState: false);
		}
	}

	public void OnPointerDown(PointerEventData eventData)
	{
		RectTransformUtility.ScreenPointToLocalPointInRectangle(containerRect, eventData.position, eventData.pressEventCamera, out pointerDownPosition);
		if ((bool)handleRect)
		{
			SetObjectActiveState(handleRect.gameObject, newState: true);
			UpdateHandleRectPosition(pointerDownPosition);
		}
	}

	public void OnDrag(PointerEventData eventData)
	{
		RectTransformUtility.ScreenPointToLocalPointInRectangle(containerRect, eventData.position, eventData.pressEventCamera, out currentPointerPosition);
		Vector2 deltaBetweenPositions = GetDeltaBetweenPositions(pointerDownPosition, currentPointerPosition);
		Vector2 position = ClampValuesToMagnitude(deltaBetweenPositions);
		Vector2 vector = ApplyInversionFilter(position);
		OutputPointerEventValue(vector * magnitudeMultiplier);
	}

	public void OnPointerUp(PointerEventData eventData)
	{
		pointerDownPosition = Vector2.zero;
		currentPointerPosition = Vector2.zero;
		OutputPointerEventValue(Vector2.zero);
		if ((bool)handleRect)
		{
			SetObjectActiveState(handleRect.gameObject, newState: false);
			UpdateHandleRectPosition(Vector2.zero);
		}
	}

	private void OutputPointerEventValue(Vector2 pointerPosition)
	{
		touchZoneOutputEvent.Invoke(pointerPosition);
	}

	private void UpdateHandleRectPosition(Vector2 newPosition)
	{
		handleRect.anchoredPosition = newPosition;
	}

	private void SetObjectActiveState(GameObject targetObject, bool newState)
	{
		targetObject.SetActive(newState);
	}

	private Vector2 GetDeltaBetweenPositions(Vector2 firstPosition, Vector2 secondPosition)
	{
		return secondPosition - firstPosition;
	}

	private Vector2 ClampValuesToMagnitude(Vector2 position)
	{
		return Vector2.ClampMagnitude(position, 1f);
	}

	private Vector2 ApplyInversionFilter(Vector2 position)
	{
		if (invertXOutputValue)
		{
			position.x = InvertValue(position.x);
		}
		if (invertYOutputValue)
		{
			position.y = InvertValue(position.y);
		}
		return position;
	}

	private float InvertValue(float value)
	{
		return 0f - value;
	}
}
public class Readme : ScriptableObject
{
	[Serializable]
	public class Section
	{
		public string heading;

		public string text;

		public string linkText;

		public string url;
	}

	public Texture2D icon;

	public string title;

	public Section[] sections;

	public bool loadedLayout;
}
public class KeyboardController : MonoBehaviour
{
	public enum ButtonType
	{
		Letter,
		Backspace,
		Enter,
		Blank
	}

	public class ButtonItem
	{
		public UnityEngine.UI.Button button { get; set; }

		public string buttonValue { get; set; }

		public ButtonType buttonType { get; set; }

		public ButtonItem(UnityEngine.UI.Button button)
		{
			this.button = button;
			buttonType = GetButtonType(button.gameObject.name);
			buttonValue = GetButtonValue(button.gameObject.name, buttonType);
		}

		private ButtonType GetButtonType(string value)
		{
			value = value.ToLower();
			if (value.Length == 1 && ((value[0] >= 'a' && value[0] <= 'z') || (value[0] >= '0' && value[0] <= '9')))
			{
				return ButtonType.Letter;
			}
			return value switch
			{
				"backspace" => ButtonType.Backspace, 
				"enter" => ButtonType.Enter, 
				"blank" => ButtonType.Blank, 
				_ => ButtonType.Blank, 
			};
		}

		private string GetButtonValue(string value, ButtonType buttonType)
		{
			return buttonType switch
			{
				ButtonType.Letter => value, 
				ButtonType.Blank => " ", 
				ButtonType.Enter => "\n", 
				_ => "", 
			};
		}
	}

	private List<ButtonItem> buttonList;

	public InputField inputField;

	private void Awake()
	{
		InitKeyboard();
	}

	private void OnEnable()
	{
		foreach (ButtonItem item in buttonList)
		{
			switch (item.buttonType)
			{
			case ButtonType.Letter:
			case ButtonType.Enter:
			case ButtonType.Blank:
				item.button.onClick.AddListener(delegate
				{
					InputButtonClickHandler(item.buttonValue);
				});
				break;
			case ButtonType.Backspace:
				item.button.onClick.AddListener(BackspaceButtonClickHandler);
				break;
			}
		}
	}

	private void OnDisable()
	{
		foreach (ButtonItem button in buttonList)
		{
			switch (button.buttonType)
			{
			case ButtonType.Letter:
			case ButtonType.Enter:
			case ButtonType.Blank:
				button.button.onClick.RemoveAllListeners();
				break;
			case ButtonType.Backspace:
				button.button.onClick.RemoveAllListeners();
				break;
			}
		}
	}

	private void BackspaceButtonClickHandler()
	{
		if (!(inputField == null) && !string.IsNullOrEmpty(inputField.text))
		{
			inputField.text = inputField.text.Remove(inputField.text.Length - 1);
		}
	}

	private void InputButtonClickHandler(string itemButtonValue)
	{
		if (!(inputField == null))
		{
			inputField.text += itemButtonValue;
		}
	}

	private void InitKeyboard()
	{
		buttonList = new List<ButtonItem>();
		UnityEngine.UI.Button[] componentsInChildren = base.transform.GetComponentsInChildren<UnityEngine.UI.Button>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			ButtonItem item = new ButtonItem(componentsInChildren[i]);
			buttonList.Add(item);
		}
	}

	public void SetKeyboardState(bool state)
	{
		base.gameObject.SetActive(state);
	}

	public void SetInteractiveInputField(InputField inputField)
	{
	}
}
public class UITest : MonoBehaviour
{
	private TouchScreenKeyboard board;

	private KeyboardController boardController;

	public UnityEngine.UI.Button volumeUPButton;

	public UnityEngine.UI.Button volumeDownButton;

	private Slider brightnessSlider;

	private InputField testInputField;

	private Toggle toggle;

	private void Awake()
	{
		board = TouchScreenKeyboard.Open("", TouchScreenKeyboardType.Default, autocorrection: false, multiline: false, secure: false);
		board.active = false;
		boardController = GetComponentInChildren<KeyboardController>();
		toggle = GetComponentInChildren<Toggle>();
		testInputField = GetComponentInChildren<InputField>();
		brightnessSlider = GetComponentInChildren<Slider>();
		PXR_System.InitAudioDevice();
	}

	private void OnEnable()
	{
	}

	private void OnDisable()
	{
	}

	private void LateUpdate()
	{
		board.active = false;
	}
}
public class TopSceneManager : MonoBehaviour
{
	public GameObject webview;

	public Text countDownText;

	private int countDown = 10;

	private void Start()
	{
		InvokeRepeating("Show", 1f, 1f);
	}

	private void Show()
	{
		countDown--;
		countDownText.text = "Show web view in " + countDown + "s";
		if (countDown == 0)
		{
			webview.SetActive(value: true);
			CancelInvoke();
		}
	}
}
public class UseWithCodeSceneManager : MonoBehaviour
{
	public InputField urlInput;

	private void Start()
	{
		urlInput.text = "https://google.com";
	}

	public void OpenButtonClicked()
	{
		GameObject gameObject = GameObject.Find("WebView");
		if (gameObject == null)
		{
			gameObject = new GameObject("WebView");
		}
		UniWebView uniWebView = gameObject.AddComponent<UniWebView>();
		uniWebView.OnLoadComplete += OnLoadComplete;
		uniWebView.InsetsForScreenOreitation += InsetsForScreenOreitation;
		uniWebView.toolBarShow = true;
		uniWebView.url = urlInput.text;
		uniWebView.Load();
	}

	private void OnLoadComplete(UniWebView webView, bool success, string errorMessage)
	{
		if (success)
		{
			webView.Show();
		}
		else
		{
			UnityEngine.Debug.Log("Something wrong in webview loading: " + errorMessage);
		}
	}

	private UniWebViewEdgeInsets InsetsForScreenOreitation(UniWebView webView, UniWebViewOrientation orientation)
	{
		return new UniWebViewEdgeInsets(35, 35, 35, 35);
	}
}
public class LocalHTMLSceneManager : MonoBehaviour
{
	public string fileName;

	public string htmlText;

	public void LoadFromFile()
	{
		UniWebView uniWebView = CreateWebView();
		uniWebView.url = UniWebViewHelper.streamingAssetURLForPath(fileName);
		uniWebView.Load();
		uniWebView.Show();
	}

	public void LoadFromText()
	{
		UniWebView uniWebView = CreateWebView();
		uniWebView.LoadHTMLString(htmlText, null);
		uniWebView.Show();
	}

	private UniWebView CreateWebView()
	{
		GameObject gameObject = GameObject.Find("WebView");
		if (gameObject == null)
		{
			gameObject = new GameObject("WebView");
		}
		UniWebView uniWebView = gameObject.AddComponent<UniWebView>();
		uniWebView.toolBarShow = true;
		return uniWebView;
	}
}
public class SizeAndTransitionSceneManager : MonoBehaviour
{
	private UniWebView _webView;

	private bool _webViewReady;

	public InputField top;

	public InputField left;

	public InputField bottom;

	public InputField right;

	public InputField x;

	public InputField y;

	public InputField width;

	public InputField height;

	public bool fade { get; set; }

	public int transitionEdge { get; set; }

	private void Start()
	{
		_webView = CreateWebView();
		_webView.Load("https://baidu.com");
	}

	public void ShowClicked()
	{
		if (_webViewReady)
		{
			_webView.Show(fade, (UniWebViewTransitionEdge)transitionEdge, 0.4f, delegate
			{
				UnityEngine.Debug.Log("Show Finished.");
			});
			_webView.ShowToolBar(animate: true);
		}
		else
		{
			UnityEngine.Debug.Log("Web view is not prepared yet. Trying to reload.");
			_webView.Load("https://baidu.com");
		}
	}

	public void SetInsetsClicked()
	{
		int aTop = ((!string.IsNullOrEmpty(top.text)) ? int.Parse(top.text) : 0);
		int aLeft = ((!string.IsNullOrEmpty(left.text)) ? int.Parse(left.text) : 0);
		int aBottom = ((!string.IsNullOrEmpty(bottom.text)) ? int.Parse(bottom.text) : 0);
		int aRight = ((!string.IsNullOrEmpty(right.text)) ? int.Parse(right.text) : 0);
		_webView.insets = new UniWebViewEdgeInsets(aTop, aLeft, aBottom, aRight);
	}

	private UniWebView CreateWebView()
	{
		GameObject gameObject = GameObject.Find("WebView");
		if (gameObject == null)
		{
			gameObject = new GameObject("WebView");
		}
		UniWebView webView = gameObject.AddComponent<UniWebView>();
		webView.OnLoadComplete += delegate(UniWebView view, bool success, string errorMessage)
		{
			if (success)
			{
				_webViewReady = true;
			}
			else
			{
				UnityEngine.Debug.LogError("Loading failed: " + errorMessage);
			}
		};
		webView.OnWebViewShouldClose += delegate
		{
			webView.Hide(fade, (UniWebViewTransitionEdge)transitionEdge, 0.4f, delegate
			{
				UnityEngine.Debug.Log("Hide Finished.");
			});
			webView.HideToolBar(animate: true);
			return false;
		};
		return webView;
	}
}
public class CallbackFromWebSceneManager : MonoBehaviour
{
	public Text result;

	private UniWebView _webView;

	private string _fileName = "UniWebViewDemo/callback.html";

	public void LoadFromFile()
	{
		if (!(_webView != null))
		{
			_webView = CreateWebView();
			_webView.url = UniWebViewHelper.streamingAssetURLForPath(_fileName);
			int screenHeight = UniWebViewHelper.screenHeight;
			_webView.insets = new UniWebViewEdgeInsets(0, 0, screenHeight / 2, 0);
			_webView.OnReceivedMessage += OnReceivedMessage;
			_webView.Load();
			_webView.Show();
		}
	}

	private void OnReceivedMessage(UniWebView webView, UniWebViewMessage message)
	{
		if (message.path == "close")
		{
			result.text = "";
			UnityEngine.Object.Destroy(webView);
			_webView = null;
		}
		if (message.path == "add")
		{
			int num = 0;
			int num2 = 0;
			if (int.TryParse(message.args["num1"], out num) && int.TryParse(message.args["num2"], out num2))
			{
				int num3 = num + num2;
				result.text = num + " + " + num2 + " = " + num3;
			}
			else
			{
				result.text = "Invalid Input";
			}
		}
	}

	private UniWebView CreateWebView()
	{
		GameObject gameObject = GameObject.Find("WebView");
		if (gameObject == null)
		{
			gameObject = new GameObject("WebView");
		}
		UniWebView uniWebView = gameObject.AddComponent<UniWebView>();
		uniWebView.toolBarShow = true;
		return uniWebView;
	}
}
public class RunJavaScriptInWebSceneManager : MonoBehaviour
{
	public Text result;

	private UniWebView _webView;

	private string _fileName = "UniWebViewDemo/demo.html";

	public void LoadFromFile()
	{
		if (!(_webView != null))
		{
			_webView = CreateWebView();
			_webView.url = UniWebViewHelper.streamingAssetURLForPath(_fileName);
			int screenHeight = UniWebViewHelper.screenHeight;
			_webView.insets = new UniWebViewEdgeInsets(0, 0, screenHeight / 2, 0);
			_webView.OnEvalJavaScriptFinished += OnEvalJavaScriptFinished;
			_webView.OnWebViewShouldClose += delegate
			{
				_webView = null;
				return true;
			};
			_webView.Load();
			_webView.Show();
		}
	}

	public void AddScript(InputField input)
	{
		if (_webView == null)
		{
			result.text = "Please open the web view first.";
		}
		else
		{
			_webView.AddJavaScript(input.text);
		}
	}

	public void RunScript(InputField input)
	{
		if (_webView == null)
		{
			result.text = "Please open the web view first.";
		}
		else
		{
			_webView.EvaluatingJavaScript(input.text);
		}
	}

	private void OnEvalJavaScriptFinished(UniWebView webView, string r)
	{
		result.text = r;
	}

	private UniWebView CreateWebView()
	{
		GameObject gameObject = GameObject.Find("WebView");
		if (gameObject == null)
		{
			gameObject = new GameObject("WebView");
		}
		UniWebView uniWebView = gameObject.AddComponent<UniWebView>();
		uniWebView.toolBarShow = true;
		return uniWebView;
	}
}
public class Navigator : MonoBehaviour
{
	public void NavigateTo(int level)
	{
		SceneManager.LoadScene(level);
	}
}
public class UniWebViewHelper
{
	public static int screenHeight => UnityEngine.Screen.height;

	public static int screenWidth => UnityEngine.Screen.width;

	public static int screenScale => 1;

	public static string streamingAssetURLForPath(string path)
	{
		return "file:///android_asset/" + path;
	}
}
public class UniWebView : MonoBehaviour
{
	public delegate void LoadCompleteDelegate(UniWebView webView, bool success, string errorMessage);

	public delegate void LoadBeginDelegate(UniWebView webView, string loadingUrl);

	public delegate void ReceivedMessageDelegate(UniWebView webView, UniWebViewMessage message);

	public delegate void EvalJavaScriptFinishedDelegate(UniWebView webView, string result);

	public delegate bool WebViewShouldCloseDelegate(UniWebView webView);

	public delegate void ReceivedKeyCodeDelegate(UniWebView webView, int keyCode);

	public delegate UniWebViewEdgeInsets InsetsForScreenOreitationDelegate(UniWebView webView, UniWebViewOrientation orientation);

	[SerializeField]
	private UniWebViewEdgeInsets _insets = new UniWebViewEdgeInsets(0, 0, 0, 0);

	public string url;

	public bool loadOnStart;

	public bool autoShowWhenLoadComplete;

	private bool _backButtonEnable = true;

	private bool _bouncesEnable;

	private bool _zoomEnable;

	private string _currentGUID;

	private int _lastScreenHeight;

	private bool _immersiveMode = true;

	private Action _showTransitionAction;

	private Action _hideTransitionAction;

	public bool toolBarShow;

	public UniWebViewEdgeInsets insets
	{
		get
		{
			return _insets;
		}
		set
		{
			if (_insets != value)
			{
				ForceUpdateInsetsInternal(value);
			}
		}
	}

	public string currentUrl => UniWebViewPlugin.GetCurrentUrl(base.gameObject.name);

	public bool backButtonEnable
	{
		get
		{
			return _backButtonEnable;
		}
		set
		{
			if (_backButtonEnable != value)
			{
				_backButtonEnable = value;
				UniWebViewPlugin.SetBackButtonEnable(base.gameObject.name, _backButtonEnable);
			}
		}
	}

	public bool bouncesEnable
	{
		get
		{
			return _bouncesEnable;
		}
		set
		{
			if (_bouncesEnable != value)
			{
				_bouncesEnable = value;
				UniWebViewPlugin.SetBounces(base.gameObject.name, _bouncesEnable);
			}
		}
	}

	public bool zoomEnable
	{
		get
		{
			return _zoomEnable;
		}
		set
		{
			if (_zoomEnable != value)
			{
				_zoomEnable = value;
				UniWebViewPlugin.SetZoomEnable(base.gameObject.name, _zoomEnable);
			}
		}
	}

	public string userAgent => UniWebViewPlugin.GetUserAgent(base.gameObject.name);

	public float alpha
	{
		get
		{
			return UniWebViewPlugin.GetAlpha(base.gameObject.name);
		}
		set
		{
			UniWebViewPlugin.SetAlpha(base.gameObject.name, Mathf.Clamp01(value));
		}
	}

	public bool openLinksInExternalBrowser
	{
		get
		{
			return UniWebViewPlugin.GetOpenLinksInExternalBrowser(base.gameObject.name);
		}
		set
		{
			UniWebViewPlugin.SetOpenLinksInExternalBrowser(base.gameObject.name, value);
		}
	}

	public bool immersiveMode
	{
		get
		{
			return _immersiveMode;
		}
		set
		{
			_immersiveMode = value;
			UniWebViewPlugin.SetImmersiveModeEnabled(base.gameObject.name, _immersiveMode);
		}
	}

	public event LoadCompleteDelegate OnLoadComplete;

	public event LoadBeginDelegate OnLoadBegin;

	public event ReceivedMessageDelegate OnReceivedMessage;

	public event EvalJavaScriptFinishedDelegate OnEvalJavaScriptFinished;

	public event WebViewShouldCloseDelegate OnWebViewShouldClose;

	public event ReceivedKeyCodeDelegate OnReceivedKeyCode;

	public event InsetsForScreenOreitationDelegate InsetsForScreenOreitation;

	private void ForceUpdateInsetsInternal(UniWebViewEdgeInsets insets)
	{
		_insets = insets;
		UniWebViewPlugin.ChangeInsets(base.gameObject.name, this.insets.top, this.insets.left, this.insets.bottom, this.insets.right);
	}

	public static void SetUserAgent(string value)
	{
		UniWebViewPlugin.SetUserAgent(value);
	}

	public static void ResetUserAgent()
	{
		SetUserAgent(null);
	}

	public static void SetDoneButtonText(string text)
	{
	}

	public void Load()
	{
		string text = (string.IsNullOrEmpty(url) ? "about:blank" : url.Trim());
		UniWebViewPlugin.Load(base.gameObject.name, text);
	}

	public void Load(string aUrl)
	{
		url = aUrl;
		Load();
	}

	public void LoadHTMLString(string htmlString, string baseUrl)
	{
		UniWebViewPlugin.LoadHTMLString(base.gameObject.name, htmlString, baseUrl);
	}

	public void Reload()
	{
		UniWebViewPlugin.Reload(base.gameObject.name);
	}

	public void Stop()
	{
		UniWebViewPlugin.Stop(base.gameObject.name);
	}

	public void Show(bool fade = false, UniWebViewTransitionEdge direction = UniWebViewTransitionEdge.None, float duration = 0.4f, Action finishAction = null)
	{
		_lastScreenHeight = UniWebViewHelper.screenHeight;
		ResizeInternal();
		UniWebViewPlugin.Show(base.gameObject.name, fade, (int)direction, duration);
		_showTransitionAction = finishAction;
		if (toolBarShow)
		{
			ShowToolBar(animate: true);
		}
	}

	public void Hide(bool fade = false, UniWebViewTransitionEdge direction = UniWebViewTransitionEdge.None, float duration = 0.4f, Action finishAction = null)
	{
		UniWebViewPlugin.Hide(base.gameObject.name, fade, (int)direction, duration);
		_hideTransitionAction = finishAction;
	}

	public void EvaluatingJavaScript(string javaScript)
	{
		UniWebViewPlugin.EvaluatingJavaScript(base.gameObject.name, javaScript);
	}

	public void AddJavaScript(string javaScript)
	{
		UniWebViewPlugin.AddJavaScript(base.gameObject.name, javaScript);
	}

	public void CleanCache()
	{
		UniWebViewPlugin.CleanCache(base.gameObject.name);
	}

	public void CleanCookie(string key = null)
	{
		UniWebViewPlugin.CleanCookie(base.gameObject.name, key);
	}

	[Obsolete("SetTransparentBackground is deprecated, please use SetBackgroundColor instead.")]
	public void SetTransparentBackground(bool transparent = true)
	{
		UniWebViewPlugin.TransparentBackground(base.gameObject.name, transparent);
	}

	public void SetBackgroundColor(Color color)
	{
		UniWebViewPlugin.SetBackgroundColor(base.gameObject.name, color.r, color.g, color.b, color.a);
	}

	public void ShowToolBar(bool animate)
	{
	}

	public void HideToolBar(bool animate)
	{
	}

	public void SetShowSpinnerWhenLoading(bool show)
	{
		UniWebViewPlugin.SetSpinnerShowWhenLoading(base.gameObject.name, show);
	}

	public void SetSpinnerLabelText(string text)
	{
		UniWebViewPlugin.SetSpinnerText(base.gameObject.name, text);
	}

	public void SetUseWideViewPort(bool use)
	{
		UniWebViewPlugin.SetUseWideViewPort(base.gameObject.name, use);
	}

	public bool CanGoBack()
	{
		return UniWebViewPlugin.CanGoBack(base.gameObject.name);
	}

	public bool CanGoForward()
	{
		return UniWebViewPlugin.CanGoForward(base.gameObject.name);
	}

	public void GoBack()
	{
		UniWebViewPlugin.GoBack(base.gameObject.name);
	}

	public void GoForward()
	{
		UniWebViewPlugin.GoForward(base.gameObject.name);
	}

	public void AddPermissionRequestTrustSite(string url)
	{
		UniWebViewPlugin.AddPermissionRequestTrustSite(base.gameObject.name, url);
	}

	public void AddUrlScheme(string scheme)
	{
		UniWebViewPlugin.AddUrlScheme(base.gameObject.name, scheme);
	}

	public void RemoveUrlScheme(string scheme)
	{
		UniWebViewPlugin.RemoveUrlScheme(base.gameObject.name, scheme);
	}

	public void SetHeaderField(string key, string value)
	{
		UniWebViewPlugin.SetHeaderField(base.gameObject.name, key, value);
	}

	public void SetVerticalScrollBarShow(bool show)
	{
		UniWebViewPlugin.SetVerticalScrollBarShow(base.gameObject.name, show);
	}

	public void SetHorizontalScrollBarShow(bool show)
	{
		UniWebViewPlugin.SetHorizontalScrollBarShow(base.gameObject.name, show);
	}

	private bool OrientationChanged()
	{
		int screenHeight = UniWebViewHelper.screenHeight;
		if (_lastScreenHeight != screenHeight)
		{
			_lastScreenHeight = screenHeight;
			return true;
		}
		return false;
	}

	private void ResizeInternal()
	{
		int screenHeight = UniWebViewHelper.screenHeight;
		int screenWidth = UniWebViewHelper.screenWidth;
		UniWebViewEdgeInsets uniWebViewEdgeInsets = insets;
		if (this.InsetsForScreenOreitation != null)
		{
			UniWebViewOrientation orientation = ((screenHeight < screenWidth) ? UniWebViewOrientation.LandScape : UniWebViewOrientation.Portrait);
			uniWebViewEdgeInsets = this.InsetsForScreenOreitation(this, orientation);
		}
		ForceUpdateInsetsInternal(uniWebViewEdgeInsets);
	}

	private void LoadComplete(string message)
	{
		bool num = string.Equals(message, "");
		bool flag = this.OnLoadComplete != null;
		if (num)
		{
			if (flag)
			{
				this.OnLoadComplete(this, success: true, null);
			}
			if (autoShowWhenLoadComplete)
			{
				Show();
			}
			return;
		}
		UnityEngine.Debug.LogWarning("Web page load failed: " + base.gameObject.name + "; url: " + url + "; error:" + message);
		if (flag)
		{
			this.OnLoadComplete(this, success: false, message);
		}
	}

	private void LoadBegin(string url)
	{
		if (this.OnLoadBegin != null)
		{
			this.OnLoadBegin(this, url);
		}
	}

	private void ReceivedMessage(string rawMessage)
	{
		UniWebViewMessage message = new UniWebViewMessage(rawMessage);
		if (this.OnReceivedMessage != null)
		{
			this.OnReceivedMessage(this, message);
		}
	}

	private void WebViewDone(string message)
	{
		bool flag = true;
		if (this.OnWebViewShouldClose != null)
		{
			flag = this.OnWebViewShouldClose(this);
		}
		if (flag)
		{
			Hide();
			UnityEngine.Object.Destroy(this);
		}
	}

	private void WebViewKeyDown(string message)
	{
		int keyCode = Convert.ToInt32(message);
		if (this.OnReceivedKeyCode != null)
		{
			this.OnReceivedKeyCode(this, keyCode);
		}
	}

	private void EvalJavaScriptFinished(string result)
	{
		if (this.OnEvalJavaScriptFinished != null)
		{
			this.OnEvalJavaScriptFinished(this, result);
		}
	}

	private void AnimationFinished(string identifier)
	{
	}

	private void ShowTransitionFinished(string message)
	{
		if (_showTransitionAction != null)
		{
			_showTransitionAction();
			_showTransitionAction = null;
		}
	}

	private void HideTransitionFinished(string message)
	{
		if (_hideTransitionAction != null)
		{
			_hideTransitionAction();
			_hideTransitionAction = null;
		}
	}

	private IEnumerator LoadFromJarPackage(string jarFilePath)
	{
		WWW stream = new WWW(jarFilePath);
		yield return stream;
		if (stream.error != null)
		{
			if (this.OnLoadComplete != null)
			{
				this.OnLoadComplete(this, success: false, stream.error);
			}
		}
		else
		{
			LoadHTMLString(stream.text, "");
		}
	}

	private void Awake()
	{
		_currentGUID = Guid.NewGuid().ToString();
		base.gameObject.name = base.gameObject.name + _currentGUID;
		UniWebViewPlugin.Init(base.gameObject.name, insets.top, insets.left, insets.bottom, insets.right);
		_lastScreenHeight = UniWebViewHelper.screenHeight;
	}

	private void Start()
	{
		if (loadOnStart)
		{
			Load();
		}
	}

	private void OnDestroy()
	{
		RemoveAllListeners();
		UniWebViewPlugin.Destroy(base.gameObject.name);
		base.gameObject.name = base.gameObject.name.Replace(_currentGUID, "");
	}

	private void RemoveAllListeners()
	{
		this.OnLoadBegin = null;
		this.OnLoadComplete = null;
		this.OnReceivedMessage = null;
		this.OnReceivedKeyCode = null;
		this.OnEvalJavaScriptFinished = null;
		this.OnWebViewShouldClose = null;
		this.InsetsForScreenOreitation = null;
	}

	private void Update()
	{
		if (OrientationChanged())
		{
			ResizeInternal();
		}
	}
}
[Serializable]
public class UniWebViewEdgeInsets
{
	public int top;

	public int left;

	public int bottom;

	public int right;

	public UniWebViewEdgeInsets(int aTop, int aLeft, int aBottom, int aRight)
	{
		top = aTop;
		left = aLeft;
		bottom = aBottom;
		right = aRight;
	}

	public static bool operator ==(UniWebViewEdgeInsets inset1, UniWebViewEdgeInsets inset2)
	{
		return inset1.Equals(inset2);
	}

	public static bool operator !=(UniWebViewEdgeInsets inset1, UniWebViewEdgeInsets inset2)
	{
		return !inset1.Equals(inset2);
	}

	public override int GetHashCode()
	{
		return (top + left + bottom + right).GetHashCode();
	}

	public override bool Equals(object obj)
	{
		if (obj == null || GetType() != obj.GetType())
		{
			return false;
		}
		UniWebViewEdgeInsets uniWebViewEdgeInsets = (UniWebViewEdgeInsets)obj;
		if (top == uniWebViewEdgeInsets.top && left == uniWebViewEdgeInsets.left && bottom == uniWebViewEdgeInsets.bottom)
		{
			return right == uniWebViewEdgeInsets.right;
		}
		return false;
	}
}
public struct UniWebViewMessage
{
	public string rawMessage { get; private set; }

	public string scheme { get; private set; }

	public string path { get; private set; }

	public Dictionary<string, string> args { get; private set; }

	public UniWebViewMessage(string rawMessage)
	{
		this = default(UniWebViewMessage);
		this.rawMessage = rawMessage;
		string[] array = rawMessage.Split(new string[1] { "://" }, StringSplitOptions.None);
		if (array.Length >= 2)
		{
			scheme = array[0];
			string text = "";
			for (int i = 1; i < array.Length; i++)
			{
				text += array[i];
			}
			string[] array2 = text.Split("?"[0]);
			path = array2[0].TrimEnd('/');
			args = new Dictionary<string, string>();
			if (array2.Length <= 1)
			{
				return;
			}
			string[] array3 = array2[1].Split("&"[0]);
			for (int j = 0; j < array3.Length; j++)
			{
				string[] array4 = array3[j].Split("="[0]);
				if (array4.Length > 1)
				{
					args[array4[0]] = WWW.UnEscapeURL(array4[1]);
				}
			}
		}
		else
		{
			UnityEngine.Debug.LogError("Bad url scheme. Can not be parsed to UniWebViewMessage: " + rawMessage);
		}
	}
}
public enum UniWebViewOrientation
{
	Portrait,
	LandScape
}
public enum UniWebViewTransitionEdge
{
	None,
	Top,
	Left,
	Bottom,
	Right
}
public class ShuRufa : MonoBehaviour
{
	public Text 输入法拼音;

	public JSONObject 拼音表;

	private JSONObject 字库;

	private string 用户输入拼音 = "";

	private string 用户输入拼音2 = "";

	private ArrayList 列表选字 = new ArrayList();

	private int 选字标签;

	private string 取出的字库;

	private int 取出字库的长度;

	private string 公串候选数字 = "0,1,2,3,4,5,6,7,8,9";

	private bool 输入状态 = true;

	public bool is输入;

	private bool 是否五笔;

	public GameObject 五笔键盘;

	public GameObject 拼音键盘;

	private void Start()
	{
	}

	public void 置候选字(ArrayList 阵串参)
	{
		for (int i = 0; i < 阵串参.Count; i++)
		{
			GameObject.Find("/=布编程/拼音/Keys/" + i + "/Text" + i).GetComponent<Text>().text = 阵串参[i].ToString();
		}
	}

	public void 清候选字()
	{
		for (int i = 0; i < 10; i++)
		{
			GameObject.Find("/=布编程/拼音/Keys/" + i + "/Text" + i).GetComponent<Text>().text = "";
		}
	}

	public void 建拼音表()
	{
		TextAsset textAsset = Resources.Load("ziku3") as TextAsset;
		字库 = new JSONObject(textAsset.text);
		string str = "{\"a\":\"a,ai,an,ang,ao\",\"b\":\"ba,bai,ban,bang,bao,bei,ben,beng,bi,bian,biao,bie,bin,bing,bo,bu\",\"c\":\"ca,cai,can,cang,cao,ce,cei,cen,ceng,cha,chai,chan,chang,chao,che,chen,cheng,chi,chong,chou,chu,chua,chuai,chuan,chuang,chui,chun,chuo,ci,cong,cou,cu,cuan,cui,cun,cuo\",\"d\":\"da,dai,dan,dang,dao,de,den,dei,deng,di,dia,dian,diao,die,ding,diu,dong,dou,du,duan,dui,dun,duo\",\"e\":\"e,ei,en,eng,er\",\"f\":\"fa,fan,fang,fei,fen,feng,fo,fou,fu\",\"g\":\"ga,gai,gan,gang,gao,ge,gei,gen,geng,gong,gou,gu,gua,guai,guan,guang,gui,gun,guo\",\"h\":\"ha,hai,han,hang,hao,he,hei,hen,heng,hong,hou,hu,hua,huai,huan,huang,hui,hun,huo\",\"i\":\"i\",\"j\":\"ji,jia,jian,jiang,jiao,jie,jin,jing,jiong,jiu,ju,juan,jue,jun\",\"k\":\"ka,kai,kan,kang,kao,ke,ken,keng,kong,kou,ku,kua,kuai,kuan,kuang,kui,kun,kuo\",\"l\":\"la,lai,lan,lang,lao,le,lei,leng,li,lia,lian,liang,liao,lie,lin,ling,liu,long,lou,lu,lv,luan,lve,lun,luo\",\"m\":\"m,ma,mai,man,mang,mao,me,mei,men,meng,mi,mian,miao,mie,min,ming,miu,mo,mou,mu\",\"n\":\"na,nai,nan,nang,nao,ne,nei,nen,neng,ng,ni,nian,niang,niao,nie,nin,ning,niu,nong,nou,nu,nv,nuan,nve,nuo,nun\",\"o\":\"o,ou\",\"p\":\"pa,pai,pan,pang,pao,pei,pen,peng,pi,pian,piao,pie,pin,ping,po,pou,pu\",\"q\":\"qi,qia,qian,qiang,qiao,qie,qin,qing,qiong,qiu,qu,quan,que,qun\",\"r\":\"ran,rang,rao,re,ren,reng,ri,rong,rou,ru,ruan,rui,run,ruo\",\"s\":\"sa,sai,san,sang,sao,se,sen,seng,sha,shai,shan,shang,shao,she,shei,shen,sheng,shi,shou,shu,shua,shuai,shuan,shuang,shui,shun,shuo,si,song,sou,su,suan,sui,sun,suo\",\"t\":\"ta,tai,tan,tang,tao,te,teng,ti,tian,tiao,tie,ting,tong,tou,tu,tuan,tui,tun,tuo\",\"u\":\"u\",\"v\":\"v\",\"w\":\"wa,wai,wan,wang,wei,wen,weng,wo,wu\",\"x\":\"xi,xia,xian,xiang,xiao,xie,xin,xing,xiong,xiu,xu,xuan,xue,xun\",\"y\":\"ya,yan,yang,yao,ye,yi,yin,ying,yo,yong,you,yu,yuan,yue,yun\",\"z\":\"za,zai,zan,zang,zao,ze,zei,zen,zeng,zha,zhai,zhan,zhang,zhao,zhe,zhei,zhen,zheng,zhi,zhong,zhou,zhu,zhua,zhuai,zhuan,zhuang,zhui,zhun,zhuo,zi,zong,zou,zu,zuan,zui,zun,zuo\"}";
		拼音表 = new JSONObject(str);
	}

	public void 切换输入法()
	{
		五笔键盘.transform.localPosition = new Vector3(-0.2608948f, 0.04000866f, 0.8564412f);
		拼音键盘.transform.localPosition = new Vector3(-100f, -100f, -100f);
		输入结束();
	}

	public string 输入(string 键值)
	{
		for (int i = 0; i < 列表选字.Count; i++)
		{
		}
		string text = 键值;
		if (公串候选数字.IndexOf(text) != -1)
		{
			if (列表选字.Count == 0)
			{
				结束拼写();
				return 键值;
			}
			if (text == "0")
			{
				text = "10";
			}
			int num = int.Parse(text);
			int count = 列表选字.Count;
			if (num < count)
			{
				string result = 列表选字[num].ToString();
				结束拼写();
				return result;
			}
		}
		else
		{
			输入状态 = true;
			用户输入拼音 += text;
			输入法拼音.text = 用户输入拼音;
			解析类型(用户输入拼音, text);
		}
		return "";
	}

	public void 上一页()
	{
		选字标签 += -20;
		if (选字标签 < 0)
		{
			选字标签 = 0;
		}
		加数字序号(取出的字库, 选字标签);
	}

	public void 下一页()
	{
		if (选字标签 < 取出字库的长度)
		{
			加数字序号(取出的字库, 选字标签);
		}
	}

	public bool 回删键()
	{
		if (用户输入拼音.Length >= 1)
		{
			用户输入拼音 = 删除(用户输入拼音);
			if (用户输入拼音2.Length >= 1)
			{
				用户输入拼音2 = 删除(用户输入拼音2);
			}
			输入法拼音.text = 用户输入拼音;
			if (用户输入拼音.Length > 1)
			{
				解析类型(用户输入拼音, "");
			}
			return true;
		}
		return false;
	}

	public void 结束拼写()
	{
		清除选字();
		输入结束();
	}

	public bool 返回输入状态()
	{
		return 输入状态;
	}

	private void 解析类型(string 参数, string 参数2)
	{
		string text = 分割输入的拼音(参数)[^1];
		string text2 = text[0].ToString();
		if (!拼音表)
		{
			建拼音表();
		}
		string text3 = 拼音表[text2].ToString();
		if (text3 == null)
		{
			return;
		}
		if (text3.IndexOf(text) != -1)
		{
			用户输入拼音2 = 输入法拼音.text;
		}
		else
		{
			用户输入拼音2 = 用户输入拼音2 + "'" + 参数2;
			用户输入拼音 = 用户输入拼音2;
			输入法拼音.text = 用户输入拼音;
		}
		string[] array = 分割输入的拼音(用户输入拼音);
		if (array.Length == 1)
		{
			选字标签 = 0;
			if ((bool)字库[text2]["字"][text])
			{
				取出的字库 = 字库[text2]["字"][text].ToString();
			}
			else
			{
				取出的字库 = 函把所以的字加进数组(text2);
			}
			取出的字库 = jsontoString(取出的字库, "\"");
			加数字序号(取出的字库, 0);
		}
		else if (array.Length > 1 && (bool)字库[text2]["字"][用户输入拼音2])
		{
			选字标签 = 0;
			取出的字库 = 字库[text2]["字"][用户输入拼音2].ToString();
			取出的字库 = jsontoString(取出的字库, "\"");
			加数字序号(取出的字库, 0);
		}
	}

	private string 函把所以的字加进数组(string 参数)
	{
		int num = 0;
		ArrayList arrayList = new ArrayList();
		string text = "";
		for (int i = 0; i < 字库[参数]["字"].list.Count; i++)
		{
			string value = 字库[参数]["字"].keys[i];
			arrayList.Add(value);
			int length = 字库[参数]["字"].list[i].ToString().Length;
			if (num < length)
			{
				num = length;
			}
		}
		for (int j = 0; j < num; j++)
		{
			for (int k = 0; k < arrayList.Count; k++)
			{
				string text2 = 字库[参数]["字"][arrayList[k].ToString()].ToString();
				if (text2.Length > j)
				{
					text += text2[j];
				}
				else
				{
					arrayList.Remove(k);
				}
			}
		}
		string replacement = "\"";
		return new Regex("\"+").Replace(text, replacement);
	}

	private void 加数字序号(string 参数, int 参数2)
	{
		列表选字.Clear();
		Static.选字.Clear();
		string text = "";
		ArrayList arrayList = new ArrayList();
		if (参数.IndexOf(",") != -1)
		{
			arrayList = new ArrayList(Regex.Split(参数, ","));
		}
		else
		{
			for (int i = 0; i < 参数.Length; i++)
			{
				string value = 参数.Substring(i, 1);
				arrayList.Add(value);
			}
		}
		取出字库的长度 = arrayList.Count;
		for (int j = 0; j < 10; j++)
		{
			int num = j + 1;
			if (num == 10)
			{
				num = 0;
			}
			int num2 = ((参数2 == 0) ? j : (参数2 + j));
			if (num2 >= 取出字库的长度)
			{
				break;
			}
			text = text + num + "." + arrayList[num2]?.ToString() + " ";
			列表选字.Add(arrayList[num2]);
			选字标签++;
		}
		Static.选字 = 列表选字;
		清候选字();
		置候选字(列表选字);
	}

	private string 删除(string 参数)
	{
		string text = 参数;
		text = text.Substring(0, text.Length - 1);
		if (text.Length < 1)
		{
			清除选字();
			输入结束();
			return "";
		}
		if (text[text.Length - 1].ToString() == "'")
		{
			text = text.Substring(0, text.Length - 1);
		}
		return text;
	}

	private void 清除选字()
	{
		列表选字.Clear();
	}

	public void 输入结束()
	{
		列表选字.Clear();
		输入状态 = false;
		取出的字库 = "";
		选字标签 = 0;
		取出字库的长度 = 0;
		用户输入拼音 = "";
		用户输入拼音2 = "";
		输入法拼音.text = "";
		清候选字();
	}

	private string[] 分割输入的拼音(string 参数)
	{
		return Regex.Split(参数, "'");
	}

	private static string jsontoString(string target, string s)
	{
		return Regex.Split(target, s)[1];
	}
}
public class SrfQH : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class Static
{
	public static ArrayList 选字 = new ArrayList();
}
public class Var2
{
	public static string raw = "a工,其,或aa式,戒,芽aaa工aaaa工,恭恭敬敬aaad工期aaan工艺aaay劳苦功高aabt医药卫生aad式,匿aadg工厂aadk匿aadn慝,葚aadw萁aady工矿,落落大方aaet节节胜利aaf苷,甙aafb工地aafd甙aaff苷,蓬蓬勃勃aafw工夫aagk工事,工整aago戒严aah芽aaht芽aahw工具,工龄aaie卧薪尝胆aajf工时aajg蕴藏量aajh蒸蒸日上aak戒aakk工艺品aan苣aanf苣aany戒心aaog工业aaol戒烟aape工农aapp切切实实aaqk匿名aaqy工贸aarr熙熙攘攘aasu式样aat荛aatk工程,工种aatl戒备aatq荛aatu工科aatv工委,戒律aaum工商aauq工交,工效,工资aavv勤勤恳恳aawf工会aawi勤工俭学aaws欧共体aawt工伤,工余,工作aaww工人,草菅人命,世世代代aaxg警戒线aaxx花花绿绿aayc工序ab节,蒸,荫abag若隐若现abce节能abdw节奏abe荫abef荫abf茸abh邛abhh节目abi蒸,菡,荪abib菡abii节水abim节油abio蒸abit节省abiu荪abiy节流abj节abjj节日abjn节电abm茁abmj茁abn芤abnb芤abnt蒸发aboa节煤abr菰abrg节后abrm节制abry菰abu萨abud节减abue节前abuf茁壮abut萨abwt节余abww节俭abxq节约abyc节育abyd巧取豪夺ac芭,茎,茅aca茎acaf茎acak戒骄戒躁acb芭,茅,蓣acbm蓣acbt茅acis七台河ack苔ackf苔acnt欺骗性ad基,若,藏ada莽,蕻adaa藏匿adad苦苦adah藏龙卧虎adai菲薄adaj莽adal苦功adat藏医adaw蕻aday葫芦adb苊adbb苊adbv期限adc茇adcu茇adcw苦难adcy欺骗addb基础addf欺压addj若非addl藏历addn茂盛ade戎,葫adef葫adeq藏胞adf苦,蓐,萘adfb基地adff蓐adfg苦干,其二,若干adfi萘adfj期刊,蒙在鼓里adfp敬而远之adg葳adga巧夺天工,荣辱与共adgc甚至adgf基于adgg其一adgk惹事adgt葳adh荐,茬,葜adha欺瞒adhb荐adhd葜adhf茬adhh项目,基础上adhk基点,苦战adhw期盼adi藉,藕adia期满adii苦水adij藉adim勘测adip苦学adiv苦涩adiy藕adj菲,匪adjd匪,菲adjg若是adjs苦果adk若,惹adkf若adkh其中adkn惹adl苈adlb苈adld基因adm项,蒇admt蒇admy项adn茂,藏adna藏民adnf基层adnn藏书adnt藏,茂,基础性adny苦恼,苦心adog基业adou世态炎凉adov基数adpn茂密adpu其实adpw勘察adpx其它adpy惹祸adqk茂名adqm欺负adqn蒙古包adqq基金adqy功成名就adrg其后adrl若有所思adrp勘探adrr若有所失adru莽撞adsf东奔西走adsg基本,斟酌adsj勘查adsk东奔西跑adtf匪徒,期待adth苦处adtm藏身,甚微adtt苦笑adu蕨adud苦头aduf欺凌aduj其间adun苦闷aduq其次aduw蕨,基准advf基建adw其,甚,期adwa戡adwb其他adwe期adwf斟,基,甚佳adwi綦adwl勘adwn甚adwr斯adwt蓁,欺侮,其余adwu其adww欺,惹人,其人adwx期货adx茏adxa苦练adxb茏adxg基线adya基诺adyf苦读adyg藏语adyj基础课adyk苦衷adyl甚为adym甚高adyn期望adyt欺诈,藏族adyy藏文,斯文,甚广ae菜,散,藤aeai散落aean菜蔬aeb艿,菔,莩aebc菔aebf莩aede莫须有aedm散布aee藐,蒯aeej蒯aeeq藐aefb菜地aefn菜场,散场aeft获胜者aeg苴aega散开aegf苴aehi散步aeij散漫aelf菜园aend散居aent散发aepe菜农aepy藐视aeqd菜肴aert散播aerw散失aes菜aesu菜aet散,蕤aetd散乱aetg蕤aetm散射aety散aeu藤aeuf散装aeui藤aev荽aevf荽aewf散会aeww菜价,七月份aey芨aeym菜市aeyn散记aeyu芨aeyy散文af革,某,著afa鞯,鞴afab鞯,劳动节afad甘苦,某项afae鞴afag若无其事afb邯afbh邯afbp敬老院afbt甘孜afbw革除afc靶,鞣,芸afcn靶afcs鞣afcu芸,芰afd甘,薷,鞑afdg匹夫有责afdj薷afdp鞑afdr甘愿aff芏,鞋,鞲affb某地afff鞋,葑,鞲affm甘南affp勒索afft著者,劳动者afgd落井下石afgf甘于,莫过于afgo东南亚afgt功亏一篑afhx某些afi蒜,鞘afid芜湖afie鞘afif劳动法afii蒜afiv甘当afj革,靼afjc勒紧afjg靼afjj劳动日afk薹afkf薹afl勒,蕾aflf蕾afln勒aflt劳动力afm贰,鞅afmd鞅afmi贰afmm鞍山afn苇afnh苇afnn著书,劳动局afnt区域性afny甘心afp鞍,荸afpb荸afpg劳动密集型afpv鞍afq鞠,芜,鞔afqb芜,芫afqk著名afqm鞍钢afqo鞠afqq鞔afqw莰afqy鞫afr靳afrh靳afrw七十年代afs某afsu某,东南西北afsy著述aft著,鞒,蓍aftd甘甜aftg鞭策aftj著,鞒,蓍aftk某种aftm鞠躬aftq著称afu蔷afuj邯郸afuk蔷,某部,东南部,劳动部afus革新afvi甘肃afw鞭,菱,芙afwa七零八落afwg革命afwo荒无人烟afwq鞭afws甘休afwt菱,著作afwu芙afww某人afwx靴afwy藿,勒令afyu或者说afyy东南方ag七,巧,葬aga荆agaj荆agd匡agdb欧亚大陆agdd七大age莆,菁agee七月agef菁aget巧用agey莆agf芋agfg巧干agfj芋agfy苦不堪言aggf甚至于aggg七一aggm荆棘aggo划不来agh廿,蔫aghg廿aghh艹agho蔫agi苤agif花天酒地agig苤agj蕙agjm巧遇agjn蕙agjs苹果agk蔌agkw蔌aglf共青团aglk共青团员agm芾,颟agmh芾agmm颟agn巧,七,匚agnk戈壁agnn巧agnt戈agny弋ago莱agou莱agpt落到实处agpy葬礼agq葬,薤agqa葬agqg薤ags茉agsk切不可agsu茉agt廾agta董事长agtd功到自然成agth廾,匡算agtm葬身agu苹,荚agub药到病除agud葬送aguh苹aguw荚aguy荆门agv萋agvi巧妙agvv萋agwf董事会agwg巧合agwy戒严令agx荑agxw荑agyd某一方面agyf巧计agyt荆州agyw区政府ah牙,邪,雅aha蘧ahaa卧式ahap蘧ahcm雅观ahdg欺上压下ahf苜,芷ahfh雅趣ahgc雅致ahgo邪恶ahhg欺上瞒下ahhw牙齿ahi菽ahic菽ahiw雅兴ahk熙,苫,颐ahkf苫ahkg雅号ahkh邪路ahkm颐,赜ahko熙ahlg卧车ahn臣,卧ahnh卧,臣ahnn工具书ahpv雅安aht牙,雅,鸦ahtb邪ahte牙ahtg鸦ahtp迓ahty雅ahug卧病ahut邪道ahww某些人ahwy邪念ahx茈ahxb茈ai东,落,薄aia茳,蕖aiaf茳aiai茫茫aiaj落幕aiap东莞aiaq东欧aias蕖aiaw欧洲共同体aiax勤学苦练aib范aibb范aibp工学院,医学院aidg荣誉感aidm东面aidn落成aie菹aiea薄膜aief落脚aieg菹aifb落地aiff落款,鸦雀无声aifm东南aifu蒙混过关aig薄,萍,蒲aigf薄aigh萍aigy蒲aih菠aihc菠aii东,莎aiit莎,荡涤aiiu荡漾aije东盟aijj落日aik藻aikf落叶aiks藻aikt东川ailb划清界限aild范畴ailf范围ailp东边aimq东风,落网ain荡ainr荡ainu荧光屏aipu落实aipw落空aiq鸫aiqd茫然aiqg鸫air蒎aire蒎airg落后ais菏aisg东西aisk菏aisr薄板ait落,藩aitf落选aitj薄利aitk落aitl藩aity落入aiu汞aiud落差aiug艾滋病aiuk东部aiuq东郊,荣誉奖aiux东北aiuy东门aiwg范例,落伍aixc东经aixt东乡,萍乡aixu薄弱aiy茫,蒗aiye蒗aiyn茫,落户aiyw落座aiyy东方,范文aj划,草,莫ajaa萌芽ajag墓葬ajaj或明或暗,若明若暗ajax草药ajb蕞ajbc蕞ajbm划出ajd莫,暮,幕ajdc蓦ajdd莫大ajdf墓ajdh幕,划破ajdj暮,莫非ajdl募ajdm幕布ajdn慕ajdr摹,草原ajdu莫aje萌ajef萌ajf昔,莳ajfb草地ajfc萌动ajfg草坪ajfu莳ajgd蓝天ajh划ajj草,菖ajjf菖ajjj昔日ajjv划归ajl蔓ajlc蔓ajlt草图,蓝图ajnt萌发ajpg划定ajpv草案ajq葛,鹊ajqc蓝色,暮色ajqg鹊ajqn葛ajrg幕后ajrk募捐ajrn草拟,划拨,暮气ajsg蓝本ajss草木ajt蓝ajte划船ajth划算,蔓延ajtl蓝ajtw草签ajty草稿aju茧ajv郾ajvb郾ajvk莫如ajwa划时代ajwv划分ajwy募集,摹仿ajyl划为ajyx草率ak或,惑,勤akad勤苦akap勤劳akb葺,蕺akbf葺akbt蕺akcw共患难akd叵akdl勤奋akft或者akg或,鄞,堇akgb鄞akgd或akgf堇,勤于akgh勤政akgl勤akgn惑akgq觐akh匮,蒉akhm匮,蒉akih甚嚣尘上akin苦口婆心akip勤学akjg或是akk颧,莒,鹳akkf莒akkg鹳akkm颧akkn萼akm莴akmw莴aknn勤快akpg其中之一akqk勤勉aksp切中要害aktl勤务aktp匮乏akve勤恳akww惑众,勤俭akyt或许al功,苏,苗alah功臣alap功劳alas苦思苦想albu苏联alce功能alcm世界观ald茵,蒽,蔑aldn蒽aldt蔑aldu茵alf苗,薯alfj薯alfw功夫alk匣,茄,茴alkf茄,茴alkm功勋all荔allg苗圃alll荔allt功力almw范围内aln功,葸alnd欺软怕硬alnt世界性alnu葸alp莲,瞢,甍alph瞢alpl苏军alpn甍alpu莲alpx薨alpy蔑视alq萝,鹋alqg鹋alqt花团锦簇alqu萝alsg苏醒,世界杯alsp世界杯赛alss苗木alt菌alts苗条altu菌alud苗头alug苏美aluq功效alv匦alvv匦alw苏alwu苏alxg功绩alyg世界语alyj功课alyt苗族,苏州alyx功率alyy苏方am贡,黄,英amc芟amce英勇amcu芟amd英amdc英雄amdg黄石amdu英amf苒amff苒,黄土amfg黄埔amfm贡献,黄南amft英才amg茼amga英武amgk茼amgq英烈amh匝,萜amhk匝,萜,共同点amis黄河amit黄海amje英明amk苘amkf苘amkg恐吓amld巩固amlg英国ammd花岗岩ammm黄山ammq黄冈amna恐慌amnd恐怖amnh恐惧amnr恐怕ampt共同之处amq苋amqa黄昏amqb苋amqc黄色amqk英名amqq黄金amrh黄牛amsa英模amso英杰amth黄牌amu贡amup黄帝amuq英姿amvo英灵amw黄,芮amwc英俊amws共同体amwu芮,黄amwx英华amy巩,恐,跫amyg英语amyh跫amyj蛩amyn恐amyp英豪amyq銎amyy巩,英文an世,艺,芯ana苠anab苠anae蔬菜anaf巨著anar巨匠anb艺,芑ancn翘尾巴and巨andd巨大andg恐惧感andm世面andy世态anf蔚anff蔚,巨款anga巨型angk世事anh蔬,葭anhc葭anhh世上anhq蔬ani忒ank薜anki甘居中游anku薜anlw巨轮,世界anm贳anmh巨幅anmu贳ann蕊annd甘心情愿annn蕊anpe世家anpt巨额anqd蔚然anqh匠心独具ansy艺术anu芯,荬anud荬,巨头anuj世间anuq巨资anuy著书立说anv世anw蓼anwa世代anwe蓼anwm劳民伤财anww巨人,世人,世俗anxn世纪any苡,荩anyo巨变anyu荩anyw苡ao蒌,薮aoaq工业区aokk工业品aokm营业员aolg工业国aolw工业界aonn工业局aoot惹火烧身aopt营业额aorn营业所aotu营业税aov蒌aovf蒌aovt薮aowx工业化ap芝,劳,营apaa劳工apad劳苦apaq荣获,营区apau蒙蔽apcc营垒apd菪apdf菪,荣辱apdg蒙古apep蒙受apf茔,蔻,莞apfb营地apfc劳动apff茔apfi营救apfl蔻apfq莞apft劳教apfu荣幸apg蒙,萱,莹apgb劳顿apge蒙apgf苎apgg萱,茅塞顿开apgq其实不然apgy莹api荥apiq荣耀apiu荥apiw荣誉apj萤apju萤apjv荣归apk营apkk营apl劳,荤aplb劳aplj荤aplk劳驾aplt劳力aplx劳累apn茕,菅apnf茕apnn菅,警察局apnt劳改apnu荧屏apo荧apog营业,工农业apou荧appy劳神apq莺,菀apqb菀apqf蓥apqg莺apr荦aprg工农兵aprh荦aps荣apsa劳模apso黄鹤楼apsu荣apta营长aptf营造aptg营生apu芝apud营养apuq劳资apvf营建apw蓉,蓿apwj蓿apwk蓉,劳保apwt劳作,荣任apwx荣华apx萦apxi萦apyn营房apyw荣膺aq区,获,警aqa芪aqaa警戒aqab芪aqai或多或少aqaj敬慕,区划aqaq葡萄,区区aqav莫名其妙aqb苑aqbb苑aqbc获取aqbg警卫aqdg慕名而来aqdm蔚然成风aqeg区县aqep敬爱aqet获胜aqfa区域aqfd荡然无存aqfi获救aqfm敬献aqfp其乐无穷aqft敬老aqg葡,藓,蓟aqgb茚aqgd藓aqgj蓟aqgn瓯aqgo欧亚aqgy葡aqi区aqip警觉aqiy欧洲aqj荀aqjf荀aqk敬,苟,擎aqkf苟,茗aqkl区别aqkr擎aqks檠aqkt敬,花色品种aqky警,菟aqlg警车aqm殴aqmc殴aqmm花名册aqn苞aqnb苞aqnj警惕aqnt区属aqo菊aqou菊aqpw警察aqpy敬礼aqq欧,鸥aqqg鸥aqqk警钟aqqw欧aqr萄,葱,蔸aqrb警报aqrm萄aqrn葱aqrq蔸aqrr芴aqrs殴打aqsg匹配aqt获,荻aqta区长aqtb茆aqtd获aqtf警告aqtj获得,获利aqtl警备aqtm警笛aqtn莸aqto荻,获释,获悉aqts节外生枝aqtv区委aqu艾aqug欧美aquj敬意,区间aquq获奖aquw获益,获准aqv匹aqvf萏aqw芡aqwf基金会aqwm敬佩aqwq敬仰aqwu芡aqwv区分aqwy匿名信aqxw工贸结合,劳逸结合aqy芍,茑,鸢aqyg茑,鸢,敬请aqyu芍aqyy警方ar匠,芹,葩arc葩arcb葩ard菝ardc菝argm甘拜下风ari茱ariu茱arj芹ark匠arsr东拉西扯art萆artf萆arwe七手八脚arwk医护人员arwr七折八扣arwu七拼八凑as苛,蘸,茜asab艺术节asal基本功asar莺歌燕舞asf茜asfi苛求asg苯asgf苯asgo蘸ash葙ashf葙ashh基本上ashk基本点asif基本法asj蕈asjj蕈ask苛askf苛askk艺术品aslf艺术团asns苍松翠柏asnt艺术性aspe艺术家aspx荷枪实弹asr菥asrj菥assa划框框astu花样翻新asw菘aswc菘asyn苛刻asyy东西方at攻,医,翘ata苌atag蓬莱ataq警备区atax医药atay苌atbb菜篮子atbp医院atd医,翳,蓬atdh攻破atdi医atdj荞atdn翳atdp蓬atdq攻克ate莠ateb莠atet医用atf芊,荇,莛atfg医士atfh荇atfj芊atfm攻击atfp莛,蓬勃atft获得者atg董,薰,尧atgf董atgk董事atgn翘atgo薰atgq尧ath蓰athh蓰athk攻占atic医治atim落入法网atip医学atj莉atjg医师,工程师atjj莉atkg划等号atkm勤务员atl蓖atlf颐和园atlg共和国atlx蓖atm薇atmt薇atnu鞠躬尽瘁ato蕃atol蕃atpg医务室atq藜,蘅atqh蘅atqi藜atqq薄利多销atr莪atrt莪atru营私舞弊atrv攻势atry医护atsw蓬松atsy医术attf医德attg医生atth工程处attl医务attu医科atty攻入atub医疗atud攻关atut翘首atv萎atvf萎atww黄种人atx莓,蘩atxi蘩atxj劳务费atxp萎缩atxu莓aty攻atyf攻读au燕,蒋,薪auab菩萨auai获益匪浅aub蒴aube蒴aubu工商联aubw医疗队audi东北三省audm基准面auft获奖者augf东半球augk苦差事augu邪门歪道auik共产党员auip共产党auiw共产党人auj莘,薏,蕲aujn薏aujr蕲auk菩aukf菩auko燕aulg东道国aulw工商界aum蔽aumm燕山aumt蔽aunn工商局aunt翘首以待auog工商业aup蒂,蒡auph蒂aupy蒡auq蒋,茭,茨auqe东北角auqf蒋auqh巧立名目auqq薪金auqu茭auqw茨aus薪ausr薪aut蒺autd蒺auuk东北部auv蒹auvo蒹auw蔺auwy蔺auyg东道主auyy共产主义av切,萧,茹avaj切莫avay若即若离avb艽avbw切除avd菇,薅avdf菇,薅avdu切磋ave茛aveu茛avf荨avfu荨avga切开avgg萧瑟avhw切盼avi萧avij萧avis萧洒avit甘肃省avjg切题avk茹,苕avkf茹,苕avn切avnn切忌avon切断avpd切割avpu切实avtm切身avts萧条avw萸avwu萸avwv切分avy芄avyn切记avyu芄aw共,花,茶awaf蓓蕾awai苍茫,雅俗共赏awaj花草awaw葵花away芬芳,荟萃awb苍awbb苍awbw工作队awc蓊awca苍劲awcn蓊awd茯awda欺人太甚awde共有awdh共存awdm工作面awdu茯aweb工作服awet共用awf蔡,荟,茌awfa花卉awfc荟awff茌,花坛awfi蔡awfj共进awfk恭喜awft苍老,工作者awfu苻awg葵,荃,莶awgd葵awgf荃awgi莶awgt蔹awh莜awhh工作上awht莜awhw茶具awj芥awjg工作量awjj芥,工作日,节假日awk葆awkf茶叶awkq共鸣awks葆awlf花园awlh花甲awlk恭贺awlu花圈awmg共同awms花朵awn巷,恭,薛awnb孽,巷awns蘖awnt共性awnu恭,薛awny苍翠awpb切合实际awpk荣华富贵awpw苍穹awpy欺人之谈awqg花钱awqi花销awqr茶余饭后awrr苍白awrv花招aws茶,荷awsc茶树,著作权awsg茶杯awsk荷awss花木awsu茶,花样,荣登榜首awsw世代相传awt荼,荏awtf荏awtg共生awth共处awtp共管awtu荼awu共,莅,蓓awuf莅awuh工作站awuk蓓awum共商awv芬awvb芬awvf共建awvk花絮aww巫,觋,苁awwb共创awwf花会awwi巫awwq觋awwu苁awx花awxb花awxe工作组awxj花费awxy花纹awy蕉,苓awya共度awyb共享awyc苓awyd共庆awyf萑,共计awyj劐awyn芩awyo蕉ax药,蕴,荜axa荭axad蕴藏axaf荭axb芎axdg药厂axet药用axf荮axfu荮axg莼axgn莼axgs世纪末axib蕴涵axj蕴axjl蕴axkk药品axq药axqy药axsf药材axt芗axtr芗,药物axx芘,蒈axxb芘axxf荜axxr蒈axyj药剂axyy药方ay芳,荒,蓄aya蔗ayaf荒芜ayao蔗ayay花言巧语ayb芳,蓠aybc蓠ayc茺aycq茺aydc蔚为大观aydr荒原ayfb荒地ayfh荒坡ayfn菜市场ayge勘误表aygf卧床不起aygr萎靡不振ayh苄ayhu苄ayia荒漠,蓄洪ayic荒滩ayii荒沙,蓄水ayj蔼,荠ayjf荒野ayjj荠ayjn蔼ayk蓑ayke蓑aym蒿,藁aymk蒿aymm荒山ayms藁ayn芒,匾,芦ayna匾aynb芒aynh荒疏aynq荒,蓄谋已久aynr芦ayp葶ayps葶ays蘑,蘼aysd蘼,蘑ayt蔟aytd蔟aytj芳香aytk蓄积ayuj蓄意ayuy荒凉ayv莨ayve莨ayw萃,菸aywf萃,茶话会aywq巧言令色aywu菸ayx蓄,蕹ayxa东方红ayxl蓄ayxw节衣缩食ayxy蕹ayya蓄谋ayyn荒废,荒谬ayyt荒诞ayyv荒唐b了,子,也ba陈bafw陈规bagq陈列bahj陈旧bai陈baiy陈bapd限期完成baru隔靴搔痒basy陈述bati孤芳自赏baym陈设bayw陈腐bayx出勤率bb子,耶,陬bbb子bbbb子bbbi子孙bbc陬bbcy陬bbgn耿耿于怀bbgw孜孜不倦bbh耶bbhj耳聪目明bbpu孤陋寡闻bbrh孺子牛bbri孙子兵法bbux子弟bbvv子女bbwu孩子们bbww随随便便bbxu子弹bbxx隐隐约约bc取,聚,娶bca陉bcag陉,取巧bcbm取出bcc聂,颞bccm颞bccu聂bcet取胜,取用bcff取款bcfh取走bchq聚餐bcii取消,取水bcje取暖bclk取回bcnd聚居bcnu取悦bcqi取乐bcqk取名bcrd聚拢bcsf取材bcsu取样bct聚,鄹bctb鄹bcti聚bctj取得bctk聚积bctt取笑bcut聚首bcv娶bcvf娶bcwa取代bcwf聚会,取舍,联欢会bcwg聚合bcwk取保bcww聚众bcwy聚集,取信bcxc取经bcxu取缔bcy取bcyg取证bd承,随,堕bda隋,隳bdae隋bdai堕落bdan隳bdbf阳奉阴违bddx承袭bde随bdef堕bdep随,承受bdfa承载bdfb随地bdfc承运bdfm陇南bdgt联成一片bdgw联成一体bdi承bdii承bdiy随大流bdj陌bdjf随时bdjg陌bdlw承办bdmg随同bdpl随军bdqn承包bdrg随后bdrj承担,承揽bdrt随手bdru承接bdsm随机bdte承租bdtf承德,随行bdtg陌生bdth随处bdtk随和bdtm随身bdtr障碍物bdtt随笔bdty堕入bdud随着bduj随意bdvc随即bdvf承建bdwg随便bdwp取而代之bdww随从bdx陇bdxn陇bdya承诺bdyw承认be阴,阻bebg阻隔bebw阴险bedj阻碍befa阻截befc阴云befg阴雨beg阴begd阴天begg阻behh阻止beip阴沉beju阴暗bejy阴影belt阻力,承受力bepf阻塞bera阻挠beri阻挡berm聘用制beru阻拦bess阴森beuw阴冷beuy阴凉beya阴谋bf际,陆,陡bfaj陵墓bfbn陈规陋习bfbt随声附和bfd孺bfdj孺bffb陆地bffc陆运bffh陡坡bffw孤零零bfh陡bfhy陡bfi际bfiy际bfj阱bfjg降雨量bfjh阱bfkh陆路bflf陵园bfm陆bfmh陆bfmi陡峭bfpl陆军bfq阮bfqd陡然bfqn阮bfw陵bfwt陵bfww承运人bfxf陆续bg卫,耳,隔bgbw卫队bgd卫bgdy卫戍bgeb防不胜防bgfg卫士bgfh出事地点,了不起bgga隔开bgh耳bghg耳bghh耳目bgjq卫冕bgjt卫星bgk隔bgkh隔bgkk陈列品bglg卫国bglp耳边bgm陋bgma降下帷幕bgmn陋bgnu陋习bgon隔断bgpg陋室bgq阢bgqn阢bgrv隔热bgsg陕西bgtg卫生bgtj了不得bgu陕bguw陕bguy隔阂bgww陋俗bgxq隔绝bgyb隔离bh耻,蚩,陟bhc陂bhcw陈旧观念bhcy陂bhdf耻辱bhdq除此而外bhg耻bhgj蚩bhgu耳目一新bhi陟,骘bhic骘bhit陟bhk屮,阽bhkg阽bhnq除此以外bhpq除此之外bhtt耻笑bhyg承上启下bi孙,逊,函bib函bibb孙子bibk函biei随波逐流big丞,卺bigb卺bigf丞,逊于bigr孤注一掷bihi耳濡目染bij隙bijg降水量biji隙bijn函电bimq函购bip逊bipi逊bipw陆海空biqc逊色bire函授biss防沙林bivv孙女biwr函件biy孙bj阳,隅,陧bjbf随时随地bjdm阴暗面bjdp随遇而安bjdw阳春bjf陧bjfg陧bjg阳bjia阳江bjiq阳光bjm隅bjmy隅bjnt阳性bjri阳泉bjx隰bjxo隰bk职,亟,陨bkaa职工bkai陨落bkbg随叫随到bkc亟bkce职能bkcg亟bkdg陨石bkgm职责bkgq防患于未然bkh聩bkhm聩bkjg出口量bkkm职员bklg出口国bklq出口转内销bkm陨bkmm孙中山bkmy陨bkog职业bkpf职守bkpt出口额bksc职权bktf亟待bktl职务bktq职称bkum出口商bkw职bkwu职位bkwy职bkyh耳听为虚bl阵,孟,隈blap阵营blef阵脚blf孟blfb阵地blfg阵雨blge隈blgv出力不讨好blh阵bll勐blln勐blpw阵容blrv阵势bltu附加税blww承办人blxg阵线blxj附加费bm出,聘,祟bmaa出工bmak出勤bman出世bmbp出院bmck出台bmcn出马bmco隔岸观火bmdg出厂bmdm出面bmds出奇bmet聘用bmf祟,聃bmfc出动,出去bmff出土bmfg聃bmfh出走bmfi祟,出示bmfm出击bmfn出场,出卖bmfu出境bmg聘bmgf出于bmgk出事bmgm出现bmgn聘bmgo出来bmhk出战bmim出没bmiq出逃bmit出海bmk出bmkh出路bmkk出口,出品bmlg出国bmlt出力bmlv出轨bmnn聘书bmnt出发bmo粜bmou粜bmqc出色bmqk出名bmrg出兵bmrt出手bmst出格bmtd出笼bmte出租bmtg出生,出征bmth出版,出处,出息,出自bmtl出血bmtm出身bmtu出乎bmty出入bmud出差,出头,出风头bmuq出资bmut出产bmuy出门bmwg出使bmwt出任,聘任bmww出众bmwy出售bmxg出线bmxm出纳bmxq聘约bmya出席bmyg聘请bmyh出让bmyl聘为bmyt出庭bmyw出诊bmyy出访bn也,孔,孑bnbb孔子bnfc了却bngf取悦于bngk了事bnh卩,阝,了,凵bnhg孑bnhk出发点bnhn也bniw孔雀bnjg也是bnlf也罢bnn孔bnqe了解bnrw随心所欲bnsv也要bntf也行bntn聊以自慰bnvb也好bnwn出以公心bnxf了结bnyn了望bnyt也许bnyw孔府bo耿bofh耿直bora出类拔萃boug职业病bowp聚精会神boy耿bp辽,院,耽bpai辽东,院落bpbj辽阳bpdg随之而来bpf院bpfq院bpfw孤寡老人bpgf取之于bpgn取之不尽bpid辽源bpim防空洞bpis辽河bpit辽宁省bpk辽bpnt限定性bpps辽宁bpq耽bpqn耽bprn院所bpru耽搁bps聍bpsg辽西bpsh聍bpsu院校bpta院长bpui辽阔bpwv聚宝盆bpx陀bpxn陀bpyk耽误bq隐,聊,陷bqaa隐匿bqad隐藏bqai陷落bqau隐蔽bqbf陷阱bqfd聊城bqft承包者bqga隐形bqgd聊天bqgf陷于bqgt险象环生bqha隐瞒bqjt隐晦bqkk隐患bqn孢bqnn孢bqpd陷害bqr陶bqrm陶,承包制bqrq出尔反尔bqsg陶醉bqt聊bqtb聊bqty陷入bquc陶冶bqum承包商bquq陶瓷bqv陷bqvg陷bqvn隐bqww承包人bqyf隐讳br孤,阪,隍brad孤苦brc孤brcy阪,孤brg隍brgg隍brgm出手不凡brnt限制性brpd孤寡brq隗brqc隗brqt孤独,孤儿brss防护林brt陴brtf陴bruu孤立brwn孤僻brwp阿拉伯数字bs阿,耵bsh耵bsit陕西省bsk阿bskg阿bsvc阿妈bsvg阿姨bswq阿爸bsyy随机应变bt降,隆,陲bta降btah降btai降落btau职务工资btbb出乱子btbp卫生院btd聒btdg聒btf阡btfg降雨btfh阡,隆起btfu出入境btfv降雪btg隆btgc降到btgf陲,出自于btgg隆bth阼bthf阼bthk联系点btii降水btij降温btjt降临btkk出入口btlf陷入困境btlg出租车btlw出版界btnn卫生局btnt防御性btog出版业btpt取长补短btpy出版社btre出生年月btrg随身携带btrn卫生所btsi防微杜渐btsm随处可见bttg隆重,出生入死bttu隆冬btuj卫生间btuk卫生部btum出版商btwq降低btww降价,承租人,联系人btxe降级bty孜btyr承先启后btyx出生率bu联,陪,聪buap联营bubq联产承包,阴差阳错bubw联队buby联防bucq联欢bud联budd联大budj障碍budt联邦budy联bue隧buep隧bufc联运bufd出头露面bufr孤立无援buhh耳闻目睹buim隧洞buj障buje聪明,联盟bujg出问题bujh障buk陪bukg陪bukn聪bumg陪同buna联展bunr陶冶情操bunt随意性bupf联赛bupj陪审bupu陪衬buqk联名burg子弟兵buru联接bush联想busm联机butx联系buud陪送buuh防疫站buut隧道,阳关道buw隘buwg联合buwl隘buwu陪伴buxf联结buxt联络buya联席buyn联户buyp联谊buyr承前启后bv限bvad限期bve限bvey限bvfq隐姓埋名bvgf限于bvjf限时bvjg限量bvpg限定bvpt限额bvri了如指掌bvrm限制bvut限产bvww限价bvwy限令bvya限度bw队,险,除bwai坠落bwaj除草bwbb出岔子bwbn除了bwdc队友bwdj除非bwet险胜bwf附,坠bwfc除去bwff坠bwfu险境bwfy附bwg险bwga除开,队形bwge附表bwgi险bwgk附带bwgm险遭bwgn取信于民bwgo险恶bwgq队列bwhh附上bwhx险些bwif除尘bwj阶bwjh阶bwkm队员bwkr聆听bwlg联合国bwlk附加bwmc险峻bwmj附则bwnf阶层bwng险情,子公司bwnt附属,阶段性bwpd除害bwqh除外bwqk除名bwqt除夕bwrg附后bwrm联合制bwrp附近bwsu阶梯bwsv险要bwt除bwta队长bwtk附和bwtr聚合物bwty除bwuo出人意料bwva坠毁bwvi附录bwwd阶段bwwf联合会,职代会bwwg队伍bwwr附件bwxe阶级bwy队,聆bwyc聆bwym附设bwyt队旗bwyv附庸bx陛bxkm联络员bxnt阶级性bxuh联络站bxuk联络部bxx陛bxxf陛by防,孩,孓byai防范byat出谋划策bybb孩子bybg防卫bydb阿谀奉承byfd防震byft出谋献策bygx防毒byhh防止byi孓byia防洪,防涝byic防治byif防潮,防尘byii防水byin防汛byjf防暑byjy也就是说bymq防风byn防,陔bynw孩,陔byoo防火bype阴谋家bypf防寒,防守bypo防灾bypw防空byry防护bytl防备,防务bytr防御byug防病byuj出主意byum防疫byuq防盗byww出席人byxg防线byyw防腐c以,又,能ca戏,劲,颈caaa能工巧匠caae驱散cabw驱除cace骁勇cad颈,骐cadm颈,戏耍cadw骐caep驱逐cafc驱动cafh驱赶caj弁,刭cajh刭cal劲calg驱车caln劲cama戏曲camm马鞍山cand戏剧cant艰巨性cap迳capd迳caq驱caqy驱cat戏,骁catd劲敌catq骁caud劲头cawg驱使cay巯cayq巯cayt劲旅cb邓,予,柔cbaa双职工cbad预期cbby预防cbc骤cbci骤cbcm驰骋cbd预cbdg预感cbdm预cbfc预支cbfi预示cbgi欢聚一堂cbh邓cbim预测cbip预演cbiq预兆cbj予cbkd柔顺cblq柔软cbmq预购,预见cbn驰cbna预展cbny予以cbou预料cbpf预赛cbpg预定cbpj预审cbpy预祝cbq豫cbqd骤然cbqe豫cbqk驰名cbqy预留cbrb预报cbrf矜持,矛盾cbrm预制cbrv预热cbsh预想cbt矛,矜,瞀cbtc骛cbtf预先,预选cbtg鹬,鹜cbth瞀,预算cbtj蝥,蟊cbtk柔和cbtl预备cbtn矜cbtq鍪cbtr矛cbts柔cbtv婺cbud矛头cbwf预付cbwv预分cbwy预售cbxq预约cbxu柔弱cbya预谋cbyf预计cbys预订cbyy预言,预防为主cc双,叠,垒ccc又,桑,颡cccc又cccf垒cccg叠cccm颡cccs桑ccd骖ccde骖ccdo熊熊大火ccef双脚ccey又及ccf驿ccfc骚动ccff欢欢喜喜ccfh驿ccfk双喜ccgg又一cchh马马虎虎ccjg又是ccjj双日cck骀cckg骀cclf参观团cclp双边cclv双轨ccnf双层ccoo熊熊燃烧ccov双数ccrd骚扰ccre双拥ccrs双打ccrt双手ccsk难能可贵ccsv又要cctd骚乱cctg双重cctm双向ccud双关ccus双亲ccvk又如ccw骏ccwg双全ccwt骏ccww双份ccy双,驭,骚ccyj骚ccyn双肩,又讯ccyy双方cd参,骑,驮cdcb参预cdcm参观cdcn骑马cdd叁cddf叁cde参,毵cden毵cder参cdff骑墙cdft参考cdgh参政cdgn参与cdgp鸡犬不宁cdhk参战cdiq骄奢淫逸cdjv参照cdkw马大哈cdl畚cdlf畚cdlg骑车cdlk参加cdln马克思cdna参展cdnh双丰收cdov参数cdpf参赛cdpl参军cdrd参拜cdrg骑兵cds骑cdsk骑cduu参阅cdy驮cdya参谋cdyq双百方针cdyy参议ce能,通,勇cedf勇夺cedi能耗cedp通达ceec双胞胎ceet通用cefc能动cefg能干,勇士cefj双月刊cefp通过ceg驵cegf勇于cegg驵cegi能否cegk通融cehh能上ceid能源ceip通常cej甬ceja通晓ceje通明cejg能量cejh通畅cejn通电cekd通顺cekh通路cel勇celb勇celg通车celt能力cemb通邮cemj通则cemq通风cen恿cenb勇敢cenu恿cep通cepi通宵cepk通ceqk能够ceqt熊猫,勇猛cerb通报cern勇气cert能手cesf通票cetd通知cete通航cetf通告,通行ceth通牒cetm通向cetq通称cety通篇,通往ceug通病ceum通商cewt通途ceww能人,通俗cewx通货cewy通令,通信cex能,熊cexk通缉cexo熊cexx能ceyl能为ceyn通讯ceyt通话ceyu能说ceyw通夜cf对,圣,怼cfbu对联cfcc对垒cfdm对面cff圣cffb圣地cfga对开cfgf对于cfhx对此cfif圣洁cfjc圣贤cfju双喜临门cfjv对照cfkh对路cfkk对口cfmd对岸cfmf对峙cfmw对内cfn怼cfnn参考书cfnt能动性cfnu怼cfqa能者多劳cfqh对外cfqj对象cfrf对质cfrt对手cfru对接cfry对抗cftf对待,对等cftg对策cftq对称cfty欢声笑语cfuf对半cfuu对立cfuw对准cfwf对付cfwx对华cfxx对比cfy对cfyi对应cfyj能者为师cfym对调cfyt对话cfyy对方cg骊cgce能不能cgda马到成功cgff欢天喜地cgfh对不起cgft参与者cgm骊cgmy骊cgtj巴不得cgwk马不停蹄cgwy对不住cgyg参政议政chcg能上能下,骑虎难下cigu邓小平ciit台湾省cime台湾同胞ciuh观测站ciuk能源部cj骒cjs骒cjsy骒ck台,驶,驯ckb邰ckbh邰ckbw台阶ckeb驯服ckeq台胞ckf台ckfn欢呼声ckgh台下ckh驯ckhh台上ckiy台湾ckje台盟ckkh台中ckmq台风ckn怠cknj怠慢cknt台属cknu怠cko炱ckou炱ckp迨ckpd迨ckq驶ckqt台独ckqy驶cktk欢蹦乱跳cktm驶向ckty对号入座,驶入,驶往ckux台北ckwx驯化ckyt台州cl劝,骡,驷claa劝戒clbe劝阻clft参加者clg驷clhh劝止clmm双鸭山cln劝clnf劝导,劝慰clqe劝解clrm双轨制cltf劝告cltk劝和clve劝退clww通力合作clx骡clxi骡clyu劝说cm观,骋cmg骋cmgn骋cmhk观点cmim观测cmip观赏cmiq观光cmnt预见性cmpw观察cmq观cmqn观cmrh观看cmrw通风报信cmww观众cmwy观念cmya能见度cmyn观望cmys观摩cn马,巴,骣cnb骣cnbb骣cncw能屈能伸cndg通情达理cndp马达cnff预收款cngq马列cnh巴cnha马虎cnhh马上cnhn巴cnkh马路cnlg马车cnlt马力cnn马cnng马cnnr鸡飞蛋打cnnt戏剧性cny厶cnyn巴望cp驼cpdj通宵达旦cpft参赛者cpkm观察员cppe观察家cpx驼cpxn驼cq允,鸡,欢cqb允cqbc欢聚cqcw难解难分cqeu欢腾cqfk欢喜cqfn欢声cqjh欢畅cqk驹cqkg驹cqkt欢呼cqlk驳回cqnh鸡蛋cqnn欢快cqny欢心cqpj欢宴cqq驳cqqb欢迎cqqi欢乐cqqy驳cqrq欢欣cqry驳斥cqsg鸡西cqte驳船cqtt欢笑cqud欢送cqv驺cqvg驺cqw欢cqwf欢迎会cqwy欢cqy鸡,骝cqya欢度,允诺cqyd欢庆cqyg鸡cqyl骝cqyn欢迎词cqyt允许cr牟crbc牟取crfr欢欣鼓舞crh牟crhj牟crnt对抗性croq马后炮crsw马拉松crtj牟利crtr勇挑重担cs骠csbb台柱子csf骠csfi骠cssj通栏标题csur能歌善舞ct矣,骄,骆ctbj骄阳ctd矣ctdj骄ctdu矣ctfb通行无阻ctfh对得起,通盘考虑ctfu勇往直前ctk骆ctkg骆ctl骢ctln骢ctmw预算内ctnn通知书ctpf预选赛ctqh预算外ctrn骄气ctte双季稻cttm预备役ctwg骄傲ctyg双管齐下cu骈,骥cua骈cuah骈cudm对立面cuga对症下药cugy参差不齐cux骥cuxw骥cuyg双关语cuyw马前卒cv艰cvad艰苦cvan艰巨cvbw艰险cvcw艰难cve艰cvey艰cvfr骄娇二气cvuy艰辛cw难,验,皴cwbx通信联络cwcq难分难解cwcw难舍难分cwep难受cwf驸cwfa难堪cwfp难过cwfu通令嘉奖cwfy驸cwg验cwgf难于cwgi验cwhk难点cwjg难题cwjn通俗易懂cwkm通信员cwku骇人听闻cwlw难办cwna难民cwnc难怪cwnh验收cwny难以cwqe难解cwqk难免cwrh难看cwt逡cwtc皴cwth难处,验算cwtj难得cwtp逡cwud难关cwut难产,难道cwvy难忍cwwk难保cwx骅cwxf骅cwy难,骓cwya难度cwyg难,骓,验证cwyl难为cwyn难忘cwyu难说cxcf又红又专cxya对比度cy驻,骗,驴cyab圣诞节cybc骗取cyby驻防cycg能文能武cyfb驻地cyg驻cygg驻cyi叉cyj蚤cyju蚤cyk骧cyke骧cykm通讯员cyn驴,骟,骇cyna骗cynn骟,骗局cynt驴cynw骇cypf驻守cypl驻军cypy通讯社cyqh驻外cyrn驻扎cysy骗术cyta参谋长cyuu能言善辩cyvi通讯录cywu能说会道cyww骗人cywx驻华cyyi驻京d在,大,而da左,砸,碟dacy有苦难言dad厮dadk左右dadm左面dadr厮,大草原dadw克勤克俭daf左dafw硬功夫dah砑daht砑dai礴daif礴dair左派daj厝dajd厝dajg尤其是dalh在世界上dalp左边dam磺damh砸damw磺dan碟danl左翼dans碟daog大工业dap礞dape礞dapk成功之路daq奁,砹daqu奁daqy砹dart左手dasv尤其要dat硗datd大功告成datg有期徒刑datq硗dav砌dava砸毁davn砌daw礤dawe大获全胜dawg大革命dawh在工作上dawi礤dawk有功人员,在工作中dawm左侧dawt砸伤dawx左倾,丰功伟绩day硭dayn硭dayx成功率,大功率dayy百花齐放db顾,耷,厄dbce太阳能,原子能dbd顾dbdm顾dbds有职有权dbey顾及dbf耷dbfc厄运dbfs有职无权dbgy奉陪到底dbha顾虑dbhw顾盼dbiq太阳光dbm础dbmh础dbnn顾忌dbpt顾客dbuk顾问dbv厄dbwg顾全dbxu原子弹dc友,码,雄dcc磉dccs磉dcd碜dcde碜,万马奔腾dcdj雄厚dcdm面对面dcdy有勇有谋dcep友爱dcfl友协dcg码dcmq雄风dcng友情dcny雄心dcqt大熊猫dcu友dcud码头,雄关,友善dcuf雄壮dcuq雄姿dcuy雄辩dcvb友好dcw雄dcwf雄伟dcww友人dcwy雄,友邻dcyp友谊dcyw雄鹰dd大,套,厌ddaa郁郁葱葱ddag确有其事ddah大臣,大雅ddal大功ddan厌世ddaq大区ddaw厚古薄今dday夸大其词,夸夸其谈ddbf大陆ddbp大院ddbw大队ddcm大观ddd磊,靥,砺dddd大,大厦,硕大,磕磕碰碰ddde大有dddf磊dddg大厂,硬碰硬dddh历历在目,左顾右盼dddl靥dddn砺dddq飙ddds大厅dddv大肆ddej大胆ddet套用,大胜ddey大脑ddfb大地ddfg大雨ddfm大坝ddfn厉声ddft大都ddfu大增ddfv大雪ddfw大夫ddfy碌碌无为ddg碱ddga大型ddgc大致ddge压而不服ddgf大于,而在于,有感于ddgg三三两两ddgj大理ddgk大豆,大事ddgn石破天惊ddgo厌恶ddgt碱,奄奄一息ddh厦ddhi大步ddhk大战,厌战ddht厦,成百上千ddi厌ddia大江,套汇ddih大小ddii大水,大大小小ddip大学ddis大河ddit大海ddiu大洋ddiv大梁ddiy大洲ddjf大旱ddjg大量,大师,确非易事ddjs硕果ddkh大路,大中ddl厣ddlg大国ddlk厣ddlp大连ddlt大力ddlw大办ddm硕ddmg大同ddmh大幅ddmq大风,套购ddmy硕ddn厉,励ddnl励ddnn大局,顾大局ddnv厉ddny压在心底ddod厌烦ddog大业ddoo大火,兢兢业业,破破烂烂ddoq大炮ddoy大米ddpb大字ddpc郁郁寡欢ddpd厉害ddpe大家ddpf大赛,大宗ddpl大军ddpv大案ddqg大鱼ddqk大名ddqq大多ddr魇ddrc魇ddrr大抓ddrt左右手ddrx大批ddry大搞ddsc大权,大树ddsh面面相觑ddso大楼ddss原原本本ddst大桥ddsv大概ddsy大有可为ddta故态复萌ddtf大街,大选,厉行ddth大片ddti左右逢源ddtk套种,大面积ddtt大笔,春夏秋冬ddu套dduf套装dduj大意,套间dduk大部dduq大将,大奖ddut大道dduy大门,厦门,大闹ddvb大好ddw餍ddwd大有人在ddwe餍ddwf大会ddwg大全,大使,面面俱到ddwh大修ddwo大伙ddws大体ddwu厌倦ddww大人,大众ddxm大纲ddxq大约ddyc左右为难ddyd大庆ddye大衣ddyf大计,大讲ddyl大为ddym太原市ddyn大户ddyq大义ddyv大庸ddyy大方de胡,髻,髯deal有功deb郁debb胡子debh郁debv有限decq大受欢迎dedj有碍dee硼deeg硼deet有用def有defh有趣defk髻defn有声,有志defq有无defu有幸deg胡,髡degf有助于degj有理degk有事degq髡degu面貌一新degx有毒deh髭dehk有点dehx髭,有些dejf有时dekk耐用品del鬟dele鬟delt有力dem髯demf髯demg胡同deng有情deny有心deov有数dep鬃,鬓depd有害depi鬃depw鬓deq鹕deqa有错deqc有色deqg鹕,有钱deqk有名derk有损dern有所derq有的derw有失desc有权desm有机det髟,髦,鬏detd有知detf有待detj有利detk有种,郁积detn髦deto鬏deu鬈deub鬈deud有着deuj有意deun郁闷deuq有奖,有效deuw有益deuy胡闹dev髫,鬣devk髫,有如devn鬣dew髹dewi有偿dews髹dewt有余deww三月份dexg有线deyk有误deyn有望deyu胡说deyy有方df夺,夸,压dfa奔dfaj奔dfaq原地区dfbc夺取dfbg百无聊赖dfbs大专院校dfc磕,砝dfcb奔驰dfcl磕dfcy砝dfda大起大落dfdd夸大dfdl雄才大略dfdq有声有色dfdu磕碰dfe辰,辱,唇dfeb压服dfef辱dfei辰dfej蜃dfek唇dfeu奔腾dfey大动脉dff硅,奎dffd压垮dfff奎dffg硅dffh奔赴,奔走dffu奔丧,有增无减dffw奋起直追dfgf有求于,有志于,原封不动dfgk大喜事dfgr万无一失dfh矸dfhh夺目dfht磕睡dfi奈dfih奔波dfiq夸耀dfiu奈dfiw硕士学位dfiy奔流dfkh奔跑dfkk辱骂,奔走呼号dflg大无畏dflk夺回dflt压力dfn夸,砖,瓠dfnb夸dfnj刳dfnn匏,肆无忌惮dfns有无必要dfnt破坏性dfny砖,瓠,奔忙,有求必应dfpf夺冠dfpt存款额dfqi达斡尔dfrm压制dfrn有志气dfrp压迫dfrq夺魁,压抑dfrs磕打dfsa大规模dfsc夺权dfsf夺标dfsp压榨dfst奔走相告dft奢dftd唇舌dftf夸赞dftg硕士生dftj奢,夺得dftm奔向dfu夺dfud奔头,磕头dfuk大声疾呼dfuq夸奖dfwq奢侈dfwt大协作dfwx奢华dfxp压缩dfxt夸张dfy压dfyi压dfym成都市,大城市dfyn奢望dfyt奔放dg三,石,感dga研,硎dgaa非正式dgah研dgaj硎,古墓dgaq厂区dgat古董dgay破天荒dgb砘dgbb石子dgbj咸阳dgbn砘dgce三通,万事通dgda太平盛世dgdd三大,有一套dgdf万事大吉dgdh三夏dgdr有理有据dgdt奋不顾身dgdv三五成群dgdy厂矿dgee三月dgel威胁dgep感受dgfc感动dgfd古城dgfh厂址dgft古老dgg三dgga威武dggc感到dggd有一天dggf有赖于dggg三dggk威逼,硬逼dggn威武不屈dggo威严,三亚dggs大不一样dgh古dghg古dghh顾不上dghl大开眼界dghr达到目的dght万事具备dgic硬汉dgih在政治上dgim石油dgip感觉dgir感激dgit威海dgiu太平洋dgiv感染dgj硬dgje三明dgjg厨师,硬是dgjq硬dgk咸,厨dgkc感叹dgkf厨dgkg威吓dgkn感dgkt咸dgl礓dglg礓dgln三思dglt威力dgm碛dgma古典dgmg三峡dgmq威风dgmy碛dgn戌dgnb威慑dgnc古怪dgng感情dgnp奇珍异宝dgnq面不改色dgnt戌,感性dgnu奇形怪状dgnv感慨dgpe厂家dgpl三军dgps咸宁dgpw研究dgqe感触,三角dgrm研制,三班制dgrn硬气dgsh感想,古朴dgsm大不相同dgt厂,犬dgta厂长dgtd古籍,三乱dgtf三等dgtg石dgtj顾不得dgtn万不得已dgtq古稀dgty犬dgu砰,硖dgud石头dguh砰dguk厂部dgum厂商dguq三资dguw硖dgux三北dgv威dgvb三好dgvt威dgvu万事如意dgwa古代,三代dgwc原班人马dgwd硬仗dgwg三班倒dgwo大型企业dgwr硬件dgww感人dgwx感化,硬化dgwy古今,威信dgx碡dgxe三级dgxg三线dgxo大开绿灯dgxu碡dgxx成正比dgya硬度dgyf研读,研讨dgyh故弄玄虚dgyi感应dgyn厂房,厨房,威望,大事记dgyo古迹dgyt感谢dgyy厂方,三方dh丰,存,破dha戛dhaa破戒dhah有目共睹dhai破落dhan在世dhaq破获dhar戛dhat厚此薄彼dhb存dhbc存取dhbd存dhbk在职dhbw破除dhc破dhcy破dhd慧,酆,彗dhdb酆dhdd丰硕dhde百战百胜dhdf砉dhdh存在dhdj丰厚dhdn慧,丰盛dhdr丰碑dhdv彗dhdy破碎dhf在dhfd在dhff存款,破土dhfg破坏dhfn在场dhgd夏天dhgf在于,破旧不堪dhgh在下dhgj在理dhgm艳丽dhgo破灭dhgq破裂dhgu面目一新dhhj破旧dhhv慧眼dhhx在此dhi戚,蹙dhia丰满dhih蹙dhiq在逃dhit戚dhja破晓dhjf在野dhjj夏日dhk丰,砧dhkg砧dhmw在内dhnh丰收,夏收dhny在心dhog在业dhou破烂dhoy夏粮dhpe在家dhpg丰富dhpn破密dhpv破案,在案dhq艳dhqc艳dhqh在外dhrk破损dhrn在握dhrr存折dhrt顾此失彼dhsi存档dhsm契机dhst破格dhsu存栏,在校dhsv存根dhsw唇齿相依dht夏dhtb夏季dhtf在先,在行dhtt顾虑重重dhtu夏,在乎dhtx万紫千红dhty存入dhuj存单,在意dhut丰产,破产dhuu破旧立新dhuy破门dhv契,挈,恝dhvc在即dhvd契dhvn恝dhvr挈dhvt非此即彼dhwd面目全非dhwg破例dhwu在位dhwx存货dhwy存储,夏令dhxj破费dhxp破绽dhxq契约dhxy在编dhyi在京dhyn在望dhyt存放dhyw在座di砂,耗,耕dia耢,磲dial耢dias磲dib耔dibb石河子dibg耔dic耙dice耗能dicn耙did耨dide有没有didf耨didi耕耘,石沉大海didm牵涉面die硝dieg硝dif耕,耘,耩difb耕地difc耘diff耩difh感兴趣difj耕difs大兴土木digg大小不一digt春小麦,大小不等digw有法不依dii耒,耥,耖diik耥diit耖diiy大洋洲dij耦dijn耗电dijv春光明媚dijy耦dill耕田din耜dinn耜dinw有法必依diny耗尽dio耧diol硝烟diov耧dipm大兴安岭dirh耕牛dirk耗损dirq大海捞针disw有法可依dit砂ditg大学生ditk耕种ditn耗ditt砂diu泵,耪diuq耗资diuy耪diw耠diwk耠diwq大少爷diwt耕作diwu春满人间dixj耗费diy耱diyd耱diyx成活率,存活率dj百,非,辈djag春暖花开djb厚djbd厚djcm悲观djcw非难djd非,悲,翡djdd非,大是大非djde裴djdg韭djdi胡里胡涂djdj蜚djdl辈djdn悲,翡,百万djdy斐djf百,厘djfd厘djg碍djgf碍djgh有鉴于此djh砷djhh砷djif非法djip非常djiy非洲djjf百里djll硕果累累djmy非凡djn奄,鹌djnb奄djnc悲惨djnd悲剧djnf悲愤djng鹌djoy厘米djpc大显神通djq碣djqd斐然djqn碣djrg百里挑一djrh百年djrm夏时制djte百般djtj非得djtr大显身手djtu百科djuc悲痛djuf悲壮djuj厚意djvt百姓djwj非但djwn有时侯djwt悲伤djwu百倍djwx百货djya厚度djye悲哀djyn厚望djyy非议dk右,夼dkcu有口难辩dkdk大吃大喝dkdm右面dkf右dkfj大跃进dkga大中型dkgf有别于dkgn大吃一惊dkhi大踏步dkhu三足鼎立dkih大中小dkir右派dkj夼dkjd大器晚成dklg成员国dklp右边dkmm石嘴山dkng有史以来dknl右翼dknt历史性dkrt右手dkww三中全会dkwx右倾dkxd有口皆碑dkyx成品率dl历,奋,夯dlb夯dlbw历险dlce奋勇dldf春回大地dldt三思而后行,三思而行dlf奋dlfh奋起dlfj奋进dlgo历来dlh砗dlhk奋战dlif历法dlk厍dlkq历史dllt奋力dlmq在国内外dln劢dlnm历届dlnt奋发dlny历尽dlpf三连冠dlrh历年dlsh在思想上dltk历程dlts胡思乱想dluf奋斗dluq历次dlv历dlwa历代dlwt历任dlxc历经dlxf大团结dm面,页,布dma碘dmaf布鞋dman面世dmaw碘dmbb面子dmbn面孔dmcc而又dmcf面对dmd碳dmdi大风大浪dmdo碳dmds泰山压顶dmee面貌dmeg而且dmet耐用dmf碉dmfk碉dmg硐dmga耍弄dmgk硐,耍赖dmgt非同一般dmh布dmhh面目,原则上dmhj布dmhw面具dmia布满dmin大同小异dmis非同小可dmj而,耐,耍dmjd面dmjf耐dmjg鸸,而是dmjj而dmjk厕dmjn恧dmjt面临dmjv耍dmlf布置dmlh面罩dmlt耐力dmn矶dmnn布局,而已dmnt非同以往,原则性dmny耐心dmoo耐火dmou面料dmow面粉dmpf耐寒dmpt面额dmpw面容dmq砚,砜dmqc面色dmqn砚,面包dmqy砜dmre面授dmrf威风扫地dmrg而后dmrn厕所dmrv耐热dmtf布告dmtk面积dmtm面向dmtu春风得意dmu页dmud硬骨头dmue面前dmuk面部dmuq面交dmuu威风凛凛dmvi非同寻常dmwf面值,春风化雨dmwy而今,布依dmxi面纱dmy矾dmya大幅度dmyo面谈dmys耐磨dmyv布朗dmyy矾,面议dn成,万,盛dna碾dnab成荫dnad尤其dnae碾dnal成功dnan盛世dnax成药dnbm迈出dnce万能dncw万难dnd臧dndd成套,盛大dndh盛夏dndn尴尬,万万dndt臧,夏收夏种dndw克己奉公dndy成矿dneg感情用事,万县dnfa有恃无恐dnff雄心勃勃dnfj迈进dnfn成块dnfp硬性规定dnfq万元dnfr灰心丧气dnft成才,成都dnfu万幸,三心二意dnfw成堆dnga成型,盛开dngg万一dngk盛事,万事dnh嘏dnhc嘏dnhi迈步dnit成活dniw盛誉dnj尴,虿dnjl尴dnjs成果dnju虿dnk趸dnkh趸,大飞跃dnkk成品dnkm成员dnl劢dnld成因dnln劢dnlx奋发图强dnma盛典dnmq成风,万岁dnmt成败dnn成dnng盛情dnnl盛dnnt成dnp迈dnpe成家dnpk百忙之中dnpo成灾dnpv迈dnq尥dnqj万象dnqk成名dnqy尥dnr砀dnrh成年,万年,丰收年dnri硬性摊派dnrt砀dnrx成批dnsf成材dnsg成本dnta成长,厅局长dntf盛行,盛赞,万千dnth成片,奋发向上dntm迈向dntr万物dnuf盛装,雄心壮志dnuk盛况dnuq成交,成效dnut盛产dnuu成立dnv万,尤,尢dnvt成群dnw尬dnwf盛会dnwg万全dnwj尬dnwn大快人心dnwt万余dnwu成倍dnwv成分,万分dnww成人,成份,万人,有心人dnxe厅局级dnxg成绩dny戊dnyb成熟dnye成衣dnyg成语dnyi成就dnyk盛衰dnyl成为,原以为dnyn万户dnyt戊dnyy成文do灰,盔,磷dodq百炼成钢doec磷肥doif灰尘doju灰暗dol盔dolf盔dolh盔甲doli励精图治dony灰心doon灰烬doq磷doqc灰色doqh磷dorr灰白dou灰dp达,牵,碗dpbp研究院dpdn达成dpfc牵动dpfu有害无益dpg碹,碇dpgc达到dpgg碹dpgh碇dpi达dpih牵涉dpkk在实践中dpkm研究员dplp牵连dplx牵累dpog大农业dppg研究室dpq碗dpqb碗dpqe丰富多彩dpqk百家争鸣dpr牵dprf牵挂dprh牵,牵扯dprm牵制dprn研究所dpsf达标dpsp大案要案dpss有案可查dptg研究生dpud牵头dpuo成家立业dpwf研究会dpx砣dpxg牵线dpxh牵引dpxk牵强dpxn砣dpyf石家庄dpyt大家庭dpyx破案率dpyy非官方,石家庄市dq克,砍,爽dqa磔,砥dqas磔dqav确切dqay砥dqb克dqbb碰钉子dqd兢dqdp成名成家dqdq兢dqdr大包大揽dqe确dqeb克服dqeh确dqfg大包干dqfh爽直dqfp有名无实dqga三角形dqhh大名鼎鼎dqi砾dqiy砾,三角洲dqlg面包车dqly顾名思义dqnn克己,爽快dqnt耐久性dqnx有错必纠dqog确凿dqov大多数dqpg确定dqpu确实dqq爽dqqn大锅饭dqqq爽dqrh砍掉dqrk克扣dqrm克制dqta泰然自若dqtp泰然处之dqtq大错特错dquu确立dqw砍dqwa砍伐dqwg三角债dqwk确保dqwy砍,确信dqy矽,鸪dqyg鸪dqyi确应dqyn有错就改dqyv爽朗dqyw确认dr原,愿,碑draf原著drbb原子drbm研制出drcq在所难免drda研制成功drde原有,大手大脚drdg压抑感drdr大摇大摆drdy百年大计dree原貌drfb原地drfh原址drga原型,原形drgf有损于drgj原理,百年不遇drgn在所不惜drgo原来drgr百折不挠drgt在所不辞drgw克拉玛依drh斫dri原drii原,大气污染,矿泉水drim原油drin愿drjf原野drjg大批量drld原因drle成年累月drmh原由drmj原则drnf大气层,大势已去droa原煤drou原料drpg原定drqk原名drqy秦皇岛drrf大势所趋drry大失所望drsg原本drsp面授机宜drt碑drtc厉兵秣马drtd原籍drtf碑,原告drtv原委drty原稿drud原判,原状druf原装druj愿意druw盛气凌人drvc原始drwh大气候drwn成气侯drww成年人dryg原主dryn愿望dryt有的放矢dryy原谅,原文ds厅,奇,厢dsal奇功dsam在本世纪内dsap大本营dsar奇葩dscm奇观dsdh有板有眼dsdr有根有据,有权有势dsfn奇志dsft奇才dsg硒dsgh有禁不止dsgj盛极一时dsgk奇事dsgn大可不必dsh厢dshd厢dsie大材小用dsiu大西洋dsj碴dsjg碴dsjm奇遇dsjy奇景dsk奇,厅,欹dskf奇dskj剞dskw欹dsmt奇峰dsna奇异dsnc奇怪dsrm奇缺dssd硬梆梆dssj大检查dsst有机可乘dsta厅长dstg在校生dstr奇特dstw唇枪舌剑dsty大相径庭dsub奇闻dsux大西北dsvi奇妙dsyo奇迹,奇谈dt帮,故,寿dtaa帮工dtal大千世界,三等功dtb邦dtbh帮,邦dtbu故障dtdf寿辰dtdg有条有理dtdu有利有弊dteg帮助dtf寿,焘dtfd万般无奈dtff故土dtfk有备无患dtfo焘dtfu寿dtgf有待于,有利于dtgg大循环dtgk故事dtgt三长两短dtgu三番五次dtgy有条不紊dth砟dthd成千上万dthf砟dtia大街小巷dtih在生活上dtik在生活中dtir帮派dtjt寿星dtk硌dtkg硌dtl硇dtlj有生力量dtlq硇dtnd故居dtng有生以来dtnk在我心中dtnn矿务局dtny帮忙dtp砭dtpk故宫dtpr有生之年dtpy砭dtqb帮凶dtqd大自然dtr硪dtre克敌制胜dtrg在我看来dtrt硪dtsl有利可图dtuh大处着眼dtuj故意dtuq三等奖dtut大生产dtwg寿命,古往今来dtwn百科全书dtwt大秋作物dtxt故乡dty故dtya三季度du磁,碰,厥duad有效期duag碰巧duan雄姿英发dub劂dubj劂dubw厥duc磙duce磙dud磋duda磋,磅礴dudn有头有尾dufb厚颜无耻,有效地dufn磁场dufp有关规定,有益无害dufu有意无意dug砬dugj大道理dugk磁带dugo百问不烦dugt奋斗不息,有关政策dugy奋斗到底duin有关当局duj辜,鹩dujg鹩,成交量,成问题,大问题duk碚dukg碚dukk矿产品dull丰产田duln有意思dulp有关国家dult磁力duma三部曲dumg三门峡dumq春意盎然,龙卷风dune奇装异服dunk碰壁dunt磁性,有效性duo碰duog碰dup磅,碲dupf大奖赛duph碲dupt成交额dupy磅duqm辜负duqr磁铁durj大前提duru碰撞dute磁盘duuh硬着头皮duuj有关问题duum磋商duuu有关部门duuw有关单位duwf碰头会duwk有关人员duws磁体duwu原单位duwv大部分dux磁duxx磁duyd有关方面duyk有意识duyx有效率dv肆,碌,厩dvc厩dvcq厩dvdx有始有终dvf肆dvfh肆dvgk大好事dvgr大好形势dvha肆虐dvi碌dviy碌dvuj肆意dvuw大刀阔斧dvxb成群结队dw春,蠢,奉dwa砼dwab春节dwag砼dwap夏令营dwaw春花dwbu春联,奉陪dwcl奉劝dwdg礁石dwdh春夏dwdi春耕dwdk百依百顺dwdw左邻右舍dwdy胡作非为dwet有偿服务dwf奉dwfc春运dwfg春雨dwfh奉dwfl春雷dwfm奉献dwft大公无私dwg奏,硷,磴dwga压倒一切dwgd奏,春天dwgi硷,奉还dwgj三令五申dwgk蠢事dwgn万众一心dwgt有令不行dwgu磴dwgw三位一体dwgy研修班dwhh大体上dwhk百分点dwi泰,仄dwia春灌dwin春汛dwip大会堂dwiq春光dwiu泰dwiy春游dwj春dwjf春,春旱dwjj蠢dwkk存储器dwkq古今中外dwly有偿转让dwmm泰山dwmq春风dwov百分数dwpd百分之百dwpi奉公守法dwpp百分之dwpt万全之策dwpv泰安dwqc春色dwqd泰然dwqn大使馆dwqo压倒多数dwrf威信扫地dwrm百分制dwrt春播dwsi大体相当dwt秦dwtb春季dwtf奉告,奉行dwti故伎重演dwtk春种dwto春秋dwtp春华秋实dwtt有何特长dwtu秦dwtv春笋dwud奉送,故作姿态dwuf春装,泰斗dwuj春意dwuq奏效dwux雁北dwv舂dwva三八妇女节dwvf舂dwvk耐人寻味dww雁,赝dwwe有偿使用dwwg奉命dwwm赝dwws大集体dwwy雁dwxx百分比dwy礁,碓dwyg碓,大体说来dwyo礁dwyu大做文章,有价证券dwyx百分率dx龙,袭,聋dxa龚dxaw龚dxb聋dxbf聋,面红耳赤dxbw牵强附会dxd砻dxdb破绽百出dxdf砻dxdh大红大紫dxdq成绩斐然dxet袭用dxf垄dxff垄dxfm袭击dxj砩dxjh砩dxkg聋哑dxon垄断dxos龙灯dxrs牵线搭桥dxte龙舟dxud龙头dxuj成绩单dxv龙dxvi破纪录dxwg三结合dxx砒dxxh在组织上dxxn砒dxy袭dxye袭dxyf大张旗鼓dy太,态,碎dyaa矿工dyad矿藏dyaj有计划,原计划dyaq矿区dyau在这期间dyb礅dybj太阳dybt礅dyc硫dycq硫dydg矿石dydt有言在先dydy太太dyfj矿井dyfn大市场dyfw丈夫dygn大言不惭dygq碎裂dygu太平dygy三言两语dyi丈,太dykw丰衣足食dymm矿山dyn态,戍,碥dyna碥dync大为改观dyne大放异彩dynf矿层dynt戍,耐磨性dynu态dyny奇谈怪论dyog矿业dypf有识之士dypr在这之后dypu在这之前dypw太空dyri矿泉dyrv态势dyt矿dyta矿长dytf奇迹般地dytr矿物dyty胡言乱语dyw碎dywe古为今用dywf碎,研讨会dywt夏熟作物dywu胡说八道dyya态度dyyd在这方面dyyk在讲话中dyys矿床e有,月,及ea肛,腻,腊eaed朦胧eaee腊月eaf腻eafm腻eag肛eai胨eaiy胨eaj腊,膜eajd膜eajg腊eap朦eape朦eart用其所长east腊梅eauq月工资eb服,乳,孕ebax服药ebb郛ebbh郛ebc服ebcy服ebet服用ebf孕,孚ebif乳汁ebkk乳品eblw服输ebn乳ebnn乳ebqn服饰ebtl服务ebtm服役ebuf服装ebvv孕妇ebwf服侍ebww服从ebyc孕育ec肥,胎,盈eca胫ecag胫eceu肥胖ecfn盈亏ecit肥沃eck胎eckg胎ecl盈,戤ecla戤eclf盈ecll肥田eclt肥力ecn肥ecou肥料ecqt胎儿ecra肥皂ecrm肥缺ectj盈利ecuf肥壮ecug肥美ecuq肥效ecwt盈余ed须,腌,胯edc肱edcy肱eddt胸有成竹edem腼腆edf胯edfn胯edfu悬而未决edj腓edjd腓edjn腌edm须,腼edmd腼edmy须ednh须眉ednx胆大心细edog采矿业edqg胆大包天edtd须知edw腠edwd腠edx胧edxn胧edy肽edyy肽,胆大妄为ee朋,貌,豹eea貘eead貘eear腰肌劳损eeau月薪eeb脬eebg脬eebm月出eed貊eedc朋友eedj貊eee月eeee月eef豺eefj月刊eeft豺eeg朋eegs月末eeiq月光eekh月中eem豳eemk豳eeo燹eeou燹eepu月初eepy肺腑之言eeq鹏eeqg鹏eeqy豹eer豸,邈eerb月报eerm脱胎换骨eerp邈eerq貌eesj肝胆相照eet肜,貉,貔eeth月息eetk貉eetx貔eeut月产eev貂eevk貂eew貅eews貅eeww月份eey豚eeyp月亮eeyq月底eeyw月夜ef肝,脚,肚efc肢efcb脚efcy肢efdf胸无大志efej肝胆efet膨胀efg肚efgh脚下efh肝,虢efhi脚步efhm虢efig肤浅efiy脚注efj肼efjh肼efk膨,臌efkc臌efke膨eflf腾云驾雾efm腩efmf腩efn肟efnn肟efp脖efpb脖efq朊efqc肤色efqe肢解efqg脚印efqn朊efsg脚本eft爰eftc爰efw肤efwy肤efy肘eg且,助,县egb肫egbn肫,受不了egc县,悬egcn悬egcu县egd且egdg助威,助研ege脯,膊,腈egec胚胎egef膊egeg腈egey脯,肺腑egfd县城egfh县直egft助教eggj助理eggq悬殊egi胚egie悬浮egig胚egip悬赏egiw助兴egk膈egkh膈egl助egln助egm肺egmh肺egmw县内egnj且慢egnt县属egpf用武之地egpv悬案egpw悬空egrf悬挂egrt助手egt豕egta县长,助长egtr爱不释手egtv县委egty豕egud用不着egw雎egwy雎,悬念egx胰egxe县级egxw胰egym县市egyw县政府eh鼐,胪,胩ehh胩ehhy胩ehn鼐ehnn鼐,胆战心惊ehnt胪ei膛,胱,尕eing胆小怕事einu爱学习eip膛eipf膛eiq胱eiqn胱eiu尕eivv胆小如鼠ej胆,腥,刖ejbb胆子ejdd胆大ejg胆ejgg胆ejh刖,胂ejhh胂ejjg胆量ejl腽ejlg腽ejlt胆略ejnb胆敢ejnf胆怯ejt腥ejtg腥ejyk胆识ek肿,臊,腭ekdb脱口而出ekdo胸中有数eket肿胀ekfo胸中无数ekh肿ekhh肿ekk腭ekkn腭ekks臊ekm脶ekmw脶ekpf脚踏实地ekuq肿瘤el肋,爵,腮eld胭eldy胭elh胛eln肋elny腮elrp胁迫elv爵elvf爵elw胁elww胁从elwy胁elxe县团级em肌,股,觅ema腆emac悬崖勒马emai股东emaw腆emc股emcy股emg胴emgk胴emkm采购员emld受贿罪emmn悬崖峭壁emmw肌肉emn肌empv受贿案emq觅emqb觅emqq股金emsf股票emsg股本emtf腥风血雨emw肭emws肌体emww股份emwy肭emxn悬崖绝壁emym股市en甩,肠,脲endf胸怀大志endn胸怀大局enga甩开eni脲eniy脲enr肠enrh甩掉enrt肠,甩手enty月收入env甩enya用心良苦eo膦,脒eoq膦eoqh膦eoy脒ep爱,受,逐epad受苦epaj爱慕epan受宠若惊epbe受阻epbm受聘epc受epcu受epcy受骗epd爱epdc爱epdf腾空而起epdn受之有愧epe脓epee逐月epey脓epf脘,腙epfa爱戴epfi腙epfq脘epft受害者epg腚epgc受到epgf用之于epgg逐一epgh腚epgj受惠,受理ephi逐步epi逐epil逐渐epjj逐日epld受罪eplg爱国,爱祖国eplx受累eply受罚epmd受贿epna爱惜epng爱情epnu爱憎epny受尽eppb逐字eppd受害eppo受灾epq腕,舜epqb腕epqh舜epr膑epre受援eprf爱抚eprh逐年eprk受损eprn受气eprp受控eprt受托eprw膑,受挫epry爱护epsc受权epts逐条epug爱美epuq受奖,逐次epuw受益epv胺epvb爱好epvg胺epw腔,膣epwa腔epwf膣epwg受命epwh逐个epwt受伤epww爱人epxe逐级epyk受训epym腔调eq胸,胞,脆eqa胝eqay胝eqci胜负难测eqd脆eqdb脆eqei胸膛eqk朐eqkg朐eqkh胸中eqkk胸口eqkq胞兄eqn胞eqng胸怀eqnn胞eqpu胸襟eqq胸eqqb胸eqs脎eqsy脎equx胞弟eqvf胞妹eqw肷eqwk脍炙人口eqwy肷eqxu脆弱er遥,腺,脾erc胍ercy胍erdg遥感erer遥遥erfq遥远eri腺erim遥测eriy腺erkk乳制品erlk脚手架erm遥,鹞,繇ermg鹞ermi繇ermp遥erpy遥祝erqc乳白色errn脾气errp遥控ert脾ertf脾ertm服兵役eryn遥望es采,彩,腰esbb腰杆子esbc采取esbe肠梗阻esdy采矿ese彩eset彩,采用esf膘esfi膘esim采油esja彩虹esje采暖esjn彩电esky遥相呼应esmq采购esoa采煤esos彩灯espg采写esqc彩色esqn腰包esrd彩排esrn采掘esru采摘esss用材林essu采样esu采esv腰esvg腰esw膝eswa采伐eswi膝eswy采集esxm采纳esxy采编esyt彩旗esyy采访et用,乃,胜eta胀etaa用工etad用项etax用药etay胀etbw服务队etck服务台etdy胜利在望eteg胳膊etep腹腔etey用脑etfb腹地,胜地,用地etfn用场etfp胜过etft胜利者,胜者etg胜etga用武etgc乃至etgf胜于,用于,服务于etgg胜etgo用来eth胙ethf胙ethq用餐ethw用具etif用法etiq用光etj腹etjg乃是,用量etjn用电etjt腹etk胳etkg胳etkk用品etkm服务员etlt用力etmq服务网etmt胜败etn乃etnh用etny用尽,用心,用以,县委书记etoa用煤etog服务业etqm胜负etrg用兵etrt用手ett彡etth用处ettj胜利ettt彡etty腹稿etuj用意etuk腹部,服务部etwd胜仗etwn胜似etwt胜任,用途etww用人etxj用费,服务费etyf用计etyg用语etyn用户etyr胜诉eu胶,脱,胖eua胼euab脱节euah胼euai脱落,受益匪浅eubw脱险eud腾,滕,膳eudc腾eudf塍eudi滕eudk膳eudv媵eudy朕euf胖eufh胖,腾越euft受益者euim臆测euj臆eujg月产量eujn臆euk脱eukq脱eunu腾飞euon臆断eup膀,膪eupk膪eupw腾空eupy膀euq胶euqg胶印euqi脱销euqq脱钩euqy胶eurt脱手eush臆想eutf臆造euth胶片eutm脱身euud胶卷euut脱产euwd用意何在euwv脱贫euwy膳食euyb脱离euyn脱盲ev妥,腿,舀eve腿evep腿evf妥,舀,腱evfl妥协evfp腱evft爱好者evud妥善evw腴evwy腴ew脸,脍,脞ewdm脸面ewe胗ewet胗ewf脍ewfc脍ewft受伤者ewg脸,腧ewgf服从于ewgi脸ewgj腧ewpy貌合神离ewqc脸色ewrm股份制eww脞ewwf脞ewyd脸庞ewyq助人为乐ewyu脸谱ex脂,奚exai奚落exd奚exdb脱颖而出exdu奚exj脂exjg脂expc脱缰之马ey及,脏,脑eyad及其eyb脑eybb脑子eybh脑eyek臃肿eyey肮脏eyf脏eyfg脏eygh用户至上eygi用词不当eyi及eyit脑海eyj脐eyjf及时eyjh脐,及早eyl膻eylg膻eylt脑力eym肮eymn肮eyn肪,脉,胲eyni脉eynw胲eyrg脉搏eyst及格eyte脑筋eyu臁eyuk脉冲eyum用户意见eyuo臁eyw腑,腋eywa脑袋eywf腑eywy腋eyx臃eyxy臃f地,都,却fa载,戴,栽faaq截获faat二期工程faaw栽花fabc截取fad堪fade载有fadm截面fadn堪fae霰faef截肢faet霰faf霸,坩fafc载运fafe霸fafg坩fafm截击fafs声东击西fafu栽培fagc截至fagg霸王fagn无巧不成书fahh截止fahk霸占faiw载誉faiy截流faj卉,堰fajv堰fak哉,域fakd哉fakg域fakm裁员fal载falk载falw戴fam贲famu贲famy栽赃fan堞fans堞fant地区性,进攻性faon截断fapg裁定fapl裁军fapt载客faqd截然faqy截留farh老黄牛fas栽fasc霸权,栽树fasf栽植fasg坏东西fasi栽fatg载重fatk栽种fatq堪称faud裁减,裁判faun裁决faut霸道faw截,塔fawd零七八碎fawg栽倒fawk塔faws载体fawx规范化fawy截,截住fay裁faye裁fayg霸主fayn示范户fayy载文fb地,邗fbaa教职工fbad地基,无限期fbaq地区fbdm地面fbea地膜fbee地貌fbfa地域fbfd地震fbfg雷阵雨fbfh地址fbfi越陷越深fbfl地雷fbfn地块fbfp地壳fbfu进出境fbga地形fbge地表fbgf地球,趋附于fbgh地下fbgj地理fbgk地带fbgt无孔不入fbh邗fbhc地皮fbhh地上fbhi地步fbhk地点fbka教职员工fbkk进出口fbkm教职员fblt地图,地力fbn地fbnf地层fbny进取心fbpn赤子之心fbqk地名fbqr地铁fbrf地质fbrm无限制fbrv地势fbsr地板fbst无隙可乘fbte地盘fbtf地毯fbth地处fbtv地委fbud地头fbut地产,地道fbwd地段,震耳欲聋fbwu地位fbww地价,卖出价fbym地市fbyq喜出望外fbyy地方fc支,去,动fcaa动工fcai动荡fcan去世fcap运营fcb却fcbc支取fcbh却fcbk去职fcbm支出fcbw支队fcca走马观花fccn干巴巴fccw劫难fcdy动态fcet运用fceu翅膀fcey动脉fcfa运载fcfc运动fcfk干劲十足fcfm云南fcft云雾fcgc运到fcge动静fcgi却不fchi却步fchw走马上任fcis运河fciy支流fckh去路fckm动员fckr动听fcl动,劫,盍fclf盍,运转fclk支架fcln劫,动fclt动力fclw运输fcn翅fcnd翅fcnf云层fcng动情fcnn支局,支书fcny动心fcos走马灯fcp运fcpe支农fcpi运fcqi运销fcqy去留fcr魂fcrc魂fcre动摇,支援fcrf劫持,支持fcrh去掉,去年fcrn运气fcrq运抵fcrr魂魄fcsf支票fcsg支配fcsm动机,劫机fcsy支柱fct埃fctd埃,动乱,运筹fctf运行fcth去处,运算fctm动身,动向fctr动物fcty运往fcu去,云,支fcuk支部fcwf支付fcws老骥伏枥fcwt动作fcww动人fcxg支线fcyl无能为力fcyu却说fcyy动议fd城,需,震fdai震荡fdaq城区fdas朝秦暮楚fdck垮台fdcw博古通今,老大难fddd十三大fddq老态龙钟fddy老太太fdet需用fdf震,垮fdfb盐碱地fdfc震动fdfe震fdfi需求fdfn垮,志大才疏fdfq求成过急fdfs超大规模fdft示威者fdgd无奇不有fdhh真面目fdj埯,霏fdjd霏fdjf城里fdjn埯fdkh震中fdl坜,雳fdlb雳fdln坜fdm需,颥,顸fdmj需,无原则fdmm颥fdmt雷厉风行fdmy顸fdn城fdnb震慑fdnn志愿书fdnt城fdny震惊fdoi博大精深fdoq十万火急fdqf城镇fdr塬fdrd震撼fdrh垮掉fdri塬,老有所学fdrq老有所乐fdru老有所养fdrw未成年人fdry老有所为fdsv需要fdtd需知fdtf地大物博fdtj志在千里fdtn老大自居fduq城郊fdvc震怒fdvf城建fdvt老百姓fdwj十万八千里fdwq老大爷fdwv十有八九fdx垅fdxe教研组fdxn垅fdxt城乡fdyl震颤fdym城市fdyp进而言之fdyy土石方fe圾,霾,埒fee堋feef霾feeg堋fef埒fefy埒fegf求助于,无助于,运用于fegj未受理fekn赤胆忠心fete动脑筋fetv运用自如feuy南腔北调fewt博采众长feww元月份fey圾feyy圾ff寺,土,墙ffaa款式ffad款项ffar丧魂落魄ffax二十世纪ffbb款子,进进出出ffbi直截了当ffbw运动队ffc坛ffcy坛ffdh封存ffdm封面ffdq赫赫有名,雷霆万钧,塔吉克ffdt井井有条ffee十二月ffef墙脚ffew十二月份fff圭fffa堵截fffb土地fffe专款专用ffff土fffn运动场,走过场ffft无声无息fffy封,土壤ffge填表ffgj雨过天晴ffgu填平ffgx二十一世纪ffgy无动于衷ffh填,埴,卦ffhg埴ffhw填ffhy卦ffi款ffif土法,土地法ffit云南省ffiw款ffjg需求量ffjj零零星星ffkm运动员fflf违者罚款ffmm封山ffn圬,雩,恚ffnb雩ffnk墙壁ffnn圬ffnu恚ffpe土家,土专家ffpf堵塞ffpg填写ffpi真才实学ffpp老老实实ffpu填补ffqe墙角ffqi封锁,塔塔尔ffrb墙报,填报ffrf土质ffss土木fft堵fftd老规矩fftf款待fftg博士生fftj堵fftp无地自容ffty未老先衰ffu寺ffua封冻ffuf封闭ffuk墙,老干部ffut土产ffuu地地道道,干干净净,走南闯北ffvf封建,土建ffwf运动会ffww志士仁人ffwy堵住ffxx未雨绸缪ffyc填充ffym寺庙ffyn远走高飞fg二,十,干fgad老于世故fgaq干警fgc垤fgca干劲fgcb干预fgcf垤fgdd老一套fgdj老一辈fgdy露天矿fge博,埔fgee十一月fgef博fgep博爱fgeq干脆fgew十一月份fgey埔fgf圩fgfa十堰fgfd越来越大fgfg博士fgfh圩fgfi越来越少,越来越小fgfq越来越多fgft二者fgg二fggd雨天fggf十恶不赦fggh干fggk干事fggq干裂,坏死fgh十,寸,雨fghg士fghh赶不上fghi进一步fghy雨,寸,进一步说fgi坏,坯fgia干渠fgig坯fgih干涉fgii雨水,地下水fgil干涸fgip博学fgit干活fgiy坏,干流fgj埂,垣fgjf干旱fgjg垣,雨量fgjq埂fgjt博览fgk塥fgkh塥,十足fglt地形图,起死回生fgo垭fgog垭fgok干燥fgoy干粮fgpg地下室fgpj真不容易fgrd干扰fgrg士兵fgrh十年fgrn士气fgrw救死扶伤fgsd干枯fgsg干杯fgtb雨季fgtd无事生非fgtf二等,二千fgth坏处,动画片fgtj博得fgtr博物fgts喜不自禁fgu坪fguh坪fguk干部fguq干将,干净fgvt干群fgwa老一代fgwe无副作用fgwf十佳fgwn十亿fgwq无一例外,朝不保夕fgwv十分fgww坏人fgwx无与伦比fgxa干练fgxg干线,地平线fgyd无政府状态fgyy无政府主义fh直,真,走fha越,墟fhad超期fhag墟,赶巧fhai起落fhaj起草fhat越fhav真切fhb趣fhbc趣fhbm超出,走出fhbw趋附fhc坡fhca起劲fhce直通fhcm直观fhct寸步难行fhcy坡fhdc起码,老战友fhdd盐碱fhdp直达fhdq直爽fhe趄fheg趄fhet起用fheu超脱fhf赶,直,矗fhfa超载fhfb坡地fhfc超支,走动,走运,起动fhfd盐城fhfg真坏fhfh矗,超越,赶超,赶赴,赶走fhfj走进fhfk赶fhfn超声fhfp超过,越过,走过fhfu越境,无止境fhg址,趔fhga起开fhgc赶到,直到fhgf趋于fhgh真正fhgj趔,真理fhgk超速,起事,趣事fhgm考虑不周fhgo起来fhh赴fhhh赶上,走上fhhi赴,起步fhhk起点fhhw超龄fhi趟fhia无上光荣fhid起源fhik趟fhip超常,直觉fhiq老眼光fhjc赶紧fhjf越野fhjg超量,越是,真是fhk亍,坫fhkf趣味fhkg坫fhkh赶路,起跑,走路fhkm超员fhl盐fhld起因fhlf盐,雪上加霜fhlg超车fhlk赶回fhlv越轨fhlw越界fhmq起见fhmy超凡fhn起,赳,垆fhnd起居fhng真情fhnh赳,超收fhnn赶快fhnt垆,越发,直属fhnu起飞fhnv起fhny真心fhog盐业fhoj起爆fhoo起火fhpe起家fhpj赴宴fhpt超额fhpu起初,真实fhq赵,趋fhqd超然fhqi赵fhqv趋fhrq真的fhrt直播fhru直接fhrv趁势,趋势,真挚fhsc越权fhsh真相fhsm趁机fhst颠覆fhsw趁此机会fht趱fhta颠簸fhtc直径,走私fhtd真知fhte起航fhtf起先fhtg超生,超重fhtk起程fhtm趱,起身,趋向fhtt未卜先知fhtu越冬fhtx直系fhty赶往fhu走,趑fhub趣闻fhud趁着,起头fhue超前fhut超产fhuu矗立fhuw趑fhv超fhvb真好fhvc起始fhvk超fhvt超群fhw真,趁,颠fhwd起伏fhwe趁fhwf超值,赴会fhwg颠倒fhwi走俏fhwm颠fhwn真假,超假fhwt赴任fhwu真,越位fhww超人fhwy真伪fhxa走红fhxe超级,越级fhxg直线fhya坡度fhyd真诚fhym超高fhyq起义fhyr起诉fhys起床fhyx直率fhyy直言,走访,走廊fi示,未,救fiai示范fibc求取fibk求职fibm救出fice未能fidg示威fidn未成fie霄,霪fief霄,霪fiet求胜fifg求雨fifh求真fifi求救fift求教fig霈figa超小型figg无济于事figh霈figo未来figs未尝不可figu超水平fihc土法上马fihk求战fii未fiic救治fiif教学法,无党派人士fiip求学fiit救活fiiu喜洋洋fiiy救济fijc求贤fijg求是fijt救星fiko赴汤蹈火filg救国filp老少边穷fimg求同fimq未见fing求情finp违法必究fint未必fioo救火fipg未定fipi无源之水fipo救灾fipu求实,未被fiqf博学多才fiqv救急fire救援,求援firg救兵firp未按firy救护fiso教学楼fist教学相长fit嫠fitd求知,未知fitg求生fiti远渡重洋fitj求得fitk求和fitv嫠fitx违法乱纪fiu示fiue未遂fiuj示意fius求新fiuu老当益壮fiv墚fivq未婚fivs墚fiwg救命,求全fiww救人fixc未经fixj超消费fixp老少皆宜fixu示弱fixw土洋结合fiy求,裘,逑fiye裘fiyi求fiyo未变fiyp逑fiyq南海诸岛fiyt救fj进,朝,埋fja戟fjab教师节fjad埋藏fjag埋葬fjai坦荡fjat戟,进攻fjbc进取fjbm进出fjby堤防fjcy进驻fjdm进而fjdq坦克fje朝fjeg朝fjf埋,韩,埘fjfa刊载fjfc进去fjfd进城fjff进款fjfg埋fjfh韩fjfj乾坤fjfk无影无踪fjfm堤坝fjfn朝霞fjfq墙里墙外fjfr土里土气fjfy埘,无时无刻fjg坦,堤,觏fjgg坦fjgh堤,井下fjgo进来fjgp遘fjgq觏fjgr无坚不摧fjh刊,坤fjhh坤fjhi进步fjii进水fjim埋没fjj亓fjk井fjkk进口fjl墁fjlc墁fjmd堤岸fjmm进山fjn塌fjna进展fjng塌fjos霓虹灯fjp进fjpk进fjpl进军fjq埸fjqb埋怨fjqd井然,坦然fjqg朝鲜fjqr埸fjrl起早摸黑fjrn朝气fjrr坦白fjt乾fjtf进行fjtk进程fjtn乾fjtr刊物fjty进入fjud朝着,埋头fjuy进门fjve进退fjw翰,斡fjwd埋伏fjwf斡,博览会fjwg刊登,老师傅fjwh进修fjwl起早贪黑fjwn翰fjwt坦途fjwx进货fjwy进食fjxa无照经营fjya进度fjyd坦诚fjyi进京fjym南昌市fjyt斡旋fjyx坦率fjyy进言,塌方fk吉,露,喜fkaq喜获fkbm露出fkca鼓劲fkcq喜欢fkd颉fkdd鼓励fkdm颉,露面fke袁fkep喜爱fkeu袁fkf吉fkfc鼓动fkfg喜雨fkfh鼓起fkg埕fkgd露天fkge老中青fkgg埕fkgk喜事fkh圳fkhk露fkip鼓掌fkiq吉兆fkiw嘉兴fkjg进口量fkjj吉日fkk酃fkkb酃fkkh鼓足fkkk鼓噪fkkq鼓吹fklg进口国fklt无足轻重fklu声嘶力竭fkm埚,埙fkme露骨fkmw埚fkmy埙fknd喜剧fknt趣味性fknu喜悦fkpr嘉宾fkpv吉安fkpw露宿fkpy吉祥fkqb吉凶,喜迎fkqc喜色fkqk嘉勉fkqt教唆犯fkrb喜报fkrh喜看fkrl鼓舞fkrn喜气fkss吉林fktj吉利fktu进口税fku喜,鼓,彭fkub喜闻fkuc鼓fkud露头,栽跟头fkue彭fkuf鼙fkuh瞽fkuk嘉,喜fkum雪中送炭fkun甏fkuo熹fkuq嘉奖fkvb喜好fkwf动员会fkwr元器件fkww喜人fkwx进口货fkyb远距离fkyd吉庆,喜庆fkyn喜讯fl协,雷,塄fldp雷达fleg协助flf雷flfa卖国求荣flfb无边无际flfg雷雨flfm雷击flfn雷声flgw顽固不化flif土办法flir顽固派fljg运输量fljn雷电fllt协力fllw协办flmg协同flnn二轻局flog运输业flpg协定flqt雷锋fltk协和flud替罪羊flul南辕北辙flum协商flw协flwf协会flwt协作flwy协flxq协约fly塄flym协调,直辖市flyn塄flyy协议fm南,献,击fmai击落fmbj南阳fmbm献出fmdh击破fmdi无风三尺浪fmdm南面fmdn求同存异fmew超凡脱俗fmfj坍塌fmfn老同志fmg垌fmgf击球fmgh南下fmgi无风不起浪fmgk垌fmgo南亚fmgq土崩瓦解fmhy远见卓识fmii南沙fmik击溃fmip击沉fmjj南昌fmk击fmkh击中fmmt击败fmn垲fmnn垲fmps南宁fmpy献礼fmqh境内外fmrf献技fmrg十几年来fms垛fmse南极fmsy垛fmtg献策fmtm献身fmu南fmud献fmuf南fmuq南郊fmuw志同道合fmux南北fmva击毁fmve击退fmwj未见分晓fmwt击伤fmxf南纬fmxw献给fmxx击毙fmy坝,坍fmyc南充fmyf献计fmyg坍fmyi南京fmyn献词fmyy南方fn志,声,卖fnad专项fnaf专著,增收节支fnap专营fnaq专区fnb堀fnbk专职fnbm堀fnbw教导队fncu喜忧参半fndm场面fndr志愿fnet专用fnfb场地fnfd霹雳fnff专款fnfg志士fnfh志趣,无忧无虑fnfj专刊fnfn专场,专卖fnfv越快越好fngf无愧于,无异于,专心致志fngg专一fngh专政fngm专责fngp未尽事宜fnh韦,违,韬fnhc霞fnhk韦fnhl韫fnhp违fnhv韬fnhy韧fni墀fnie卖淫fnif违法fnih墀fniw声誉fnje声明fnjg专题fnjy场景fnk霹fnkm专员,教导员fnkq震惊中外fnkt声响fnku霹fnlf专署fnlg卖国fnlk专辑fnlt卖力fnm馨,磬,罄fnmd磬fnmj馨fnmm罄fnmw场内fnmy謦fnn圮,圯fnnt韧性,专发fnny违心,专心fnog专业fnpe专家fnpg起居室fnpu真心实意fnpv专案fnpw亏空fnqh场外fnqk声名fnqn场馆fnqt违犯fnr声,场fnrc违反fnre声援fnrh卖掉fnrk亏损fnrm专制fnrn场所,志气fnrt场fnrv声势fnry违抗fnsa专柜,专横fnsf无懈可击fnsg亏本fnsm专机fnss违禁fnsu专栏fnta场长,专长fntf亏待fnth声息fntj专利fntk专程fntl无以复加fntm志向fntp专管fntq声称fntu专科fnu志,觌fnud卖,块状fnuh场站fnuj声音,违章fnuq觌,场次,丧心病狂fnux违背fnuy专门fnv亏fnw块fnwa专供fnwg场合fnwh专修fnws超导体fnww卖价,专人fnwy块,专集fnx坭fnxg专线fnxn坭,违纪fnxq违约fnxt声张fnxw卖给fny专fnyf声讨fnyg卖主fnyi专fnyn场记,声望fnyt真心话fnyy卖方,声言,专访fo赤,螫,赦fob郝,赧fobb赤子fobc赧fobh郝fobo去粗取精fobr趋炎附势fof赫,赭fofj赭fofo赫fomt赤峰fopb赤字fopo无米之炊foqk赦免forf趁火打劫forr赫哲fot赦fotj螫foty赦fou赤fowx专业化foyd赤诚foyn专业户fp过,壶,壳fpab过节fpad过期fpb勃,孛,鹁fpbc索取fpbf孛fpbg鹁fpbl勃fpbw考察队fpdd过大,无穷大fpdg过硬,真实感fpf垸fpfc过去fpfn过场,无穷无尽fpfp勃勃fpfq垸,求之过急fpfu过境fpg壹,懿,彀fpgc觳,彀fpgf过于fpgl无官一身轻fpgn懿fpgo过来fpgt求之不得fpgu壹fphh过目fpi过fpih过滤,无穷小fpiy过渡fpjf过时fpjg过量fpjh过早fpkg老字号fpkh过路fpkk十字路口fpl毂fplc毂fplf考察团fpm壳,悫fpmb壳fpmd索贿fpmh露宿风餐fpmn悫fpmu索赔fpnn动之以情,过快fpnt索性,真实性fpo壶fpog壶fpoo过火fppu赤裸裸fpqa过错fpqd索然fpqp幸灾乐祸fpqq过多fpqv过急fprg过后fprh过年fprv过热fprw过失fpsj无家可归fpsv索要fptg过重fptk过程fptr吉祥物fptu过冬,过剩fptx过敏,未完待续fpty过往fpud过关,过头fpuf过半fpuk过问fpuq过奖fpvu吉祥如意fpwq过低fpwv过分,十之八九fpww过人,索价,老实人fpx索,坨fpxh索引fpxi索fpxl过细fpxn坨fpya过度fpym过高,南宁市fpyu老实说fpyw过夜fq无,元,远fqa坻fqad无期,远期,无名英雄fqai远东fqaw超负荷fqay坻fqb元fqbg远隔fqbh无耻fqbq无聊fqbv无限fqcc无双fqce无能,均能fqd顽fqdd远大fqde均有fqdf无奈fqdg远古fqdh远在fqdj远非fqdm顽fqdr声名大振fqdu无辜fqdv勃然大怒fqdw无独有偶fqed无须fqee元月fqfd无需,均需fqfi均未fqfk索然无味fqfn无声fqfq均无fqfr博尔塔拉fqfs坎坷fqft元老fqga无形fqgi无不,均不fqgj无理fqgm截然不同fqgx无毒,元素fqhi远眺fqif无法fqip无常fqiu远洋fqjg元旦fqjm元帅fqjn无暇fqjy远景fqk堍,鼋fqkn鼋fqky堍fqld顽固,无罪fqlg无畏fqlp无边fqlt无力fqmh均由fqmq远见fqn雹,坞fqna无异fqnb雹fqng坞,无情fqnn均已fqnr无愧fqny无心fqog无业fqov无数fqp远fqpd无害fqpi元宵fqpo雹灾fqpv远,真名实姓fqpw无穷fqpy无礼,无视fqqa声名狼藉fqqi远销fqqj无锡fqqk无名fqqu均匀fqre无援fqrk无损fqrn元气fqrp远近fqrv均势fqry顽抗fqsc无权fqsk均可fqsm无机fqta坦然自若fqtc无私fqtd无敌,无知fqte远航fqtf均等fqtg远征fqth远处fqtk远程fqtq均衡fqu均fqud无关fqug均,顽症fquj无意fqum无端fquq无效,远郊fqut元首fqv无fqvy无妨fqw坎fqwd声色俱厉fqwi无偿fqwr元件fqwv均分fqww无从,无人fqwy坎fqxg无线fqxk顽强fqxt无疑fqxx无比,无缘fqya无度fqyb远离fqyg无证fqyi均应fqyk无误fqyn无望,远望fqyw无论fqyy无方,远方fr垢,坂,圻fraf朝气蓬勃frc坂frcy坂frdm亏损面frdn无所顾忌frdt雨后春笋fren无所用心frfe动手动脚frfg无拘无束frfk走投无路frg垢frgd颠扑不破,无所不在frgf雷打不动frgh支持下frgk垢frgq无所不包frgy顽抗到底,无所不为frh圻frid声势浩大frii喜气洋洋frln无所畏惧frnn地质局frpf真抓实干frpt亏损额frpu赤手空拳frrk无所措手足frrq趁热打铁frt埤frtf埤frtw无所适从frui地热资源fruy走后门frwp坦白从宽frww老年人frwy无所作为fry坼fryl无所谓fryt无的放矢fryx亏损率fryy坼fs霜,霖,堙fsdl丧权辱国fsdr真相大白fsdw无可奈何fsdy无可非议fsf堙fsfg堙fsfr无权无势,载歌载舞fsh霜fshf霜fsit吉林省fsjg需要量fsk坷fskg坷fskk违禁品fsky专横跋扈fslx无可置疑fsps无本之木fsqu无可争辩fsrf老根据地fsrl无可挽回fss霖fssa老框框fssu霖fstk违禁物品fstr动植物fsuc无可辩驳fsum走极端fsuw超标准fswr零配件fsxr无可比拟ft才,者,老ftaa老式ftak考勤ftal走向世界ftaq老区,孝敬ftb孝,教ftbc考取ftbf孝ftbp博物院ftbt教ftce才能,都能ftcw考验ftdc老友ftdd老大ftde才有ftdg教研,考古ftdn老成fte才ftee十冬腊月ftf霆ftfc过得去ftfg才干ftfl无私无畏ftfn考场ftfp霆ftfq老远ftft土生土长ftg考ftge无往不胜ftgg无敌于天下,无微不至ftgj去向不明ftgn考ftgx堪称一绝fth埏ftha考虑,老虎fthh考上fthp埏fthw教具,老龄ftic老汉ftif教法,专利法ftih老婆,老小ftip才学,教学ftiy老生常谈ftj者,煮,翥ftjb都ftjf者ftjg才是,都是,教师,考题,老师,老是,载重量ftjm老帅ftjn翥ftjo煮ftkc教唆ftkd孝顺ftkm教员,载入史册ftl雾ftlb雾ftlf动物园ftm垧ftma进行曲ftmk垧ftmm运筹帷幄ftn圪ftnf教导ftnn圪,教书,教科书,专利局ftnt规律性ftny孝心ftom真知灼见ftpe老农ftpg教室ftpu老实ftpv走私案ftpw考察,考究ftpy无稽之谈ftqh老外ftqn博物馆ftqt走私犯ftre教授ftrh老年ftrt老手ftsc专利权ftsf教材ftsg老本ftsj考查ftsl无利可图ftsm起重机ftsr老板ftsv都要ftsy考核fttd才智fttg考生ftth老牌,教务处fttk教程fttl教务ftts教条fttv教委ftud教养,考卷ftug老毛病,喜笑颜开ftuk土特产品ftun喜迁新居ftuq老将,二等奖ftut土特产ftvb都好ftvi超乎寻常ftvm堆积如山ftvn老鼠ftwf教会,无息贷款,支委会ftwr无条件ftww老人ftwx才华,老化ftx老,霉,耄ftxa教练ftxb老ftxf耋ftxg考绩ftxj耆ftxn耄ftxu霉,老弱ftya考试ftyc教育ftyg考评,考证ftyk教训ftym都市ftyt教诲ftyx增长率ftyy教科文fu增,幸,境fuaq远郊区fubx无产阶级fudd增大fudh幸存,喜新厌旧fudj老前辈fudm幸而fudn无关大局fue丧fuej丧胆fueu丧fuf幸fufb境地fufc幸运fufe垃圾fufj幸,增进,增刊fuft违章者,无产者fug垃fugc增至fugf过意不去fugg协商一致fugk丧事fugn二次开发fugq增殖fuig增添fuiq增光fuir增派fuj境fujg增量fujm境遇fujq境fujs无关紧要fuk培fukg培fukh无意中fukm裁判员ful增,啬fulg吉普车fulj增fulk啬,增加fult示意图fulw境界fum墒fumk墒fumm增删fumw境内funh增收funy支部书记fuov过半数fupk无意之中fupu增补fupy幸福fuqc增色fuqh境外fuqk幸免fuqm喜闻乐见fuqq增多fure增援furg增兵furn丧气,增拨furw丧失fusf培植futa增长futf增选futm丧身fuud培养,增减fuuk境况fuuq增效fuut增产fuuw增益,求效益fuv霎fuvb幸好fuvf霎fuwf增值fuwr零部件fuwx专门化fuxk增强fuyc培育fuyk培训,无意识fuym增高,增设fuys增订fuyy南北方fv雪,霓,垠fvaw雪花fvdr雪原fve垠fvey垠fvf雪fvgc进退两难fvi埭fviy埭fvme雪崩fvmm雪山fvnn城建局fvp埽fvph埽fvq霓fvqb霓fvrr雪白fvww老好人fvxw进退维谷fvyp雪亮fvyq喜怒哀乐fw夫,替,零fwae零散fwai规范fwaj规划fwaq协作区fwbb坏分子fwbf零陵fwbw才华出众fwcl规劝fwdf去伪存真fwdy零碎fwf替,辇,逵fwfg真人真事fwfj替fwfl辇fwfp逵fwfu十全十美fwgh零下fwgv夫妻fwgy替班,进修班fwhh无休止fwhk零点fwi夫fwjf零时fwjt零星fwm规fwmj规则fwmq规fwn埠,堠fwnd堠fwnf埠fwnx动人心弦fwpg规定fwpp十分之,无价之宝fwpr真凭实据fwpt零售额fwqn朝令夕改fwrq替换fwsa规模fwsi才华横溢fwst规格fwtc干什么fwtd规矩,零乱fwtk堆积,规程fwtm替身fwtv规律fwui无人问津fwuj规章fwvt十拿九稳fwvv夫妇fww赍,麴fwwa替代fwwm赍fwwo麴fwwr零件fwww夫人,零售价fwwy零售fwy堆,霍,埝fwya零度fwyc零fwyf霍,无从谈起fwyg堆fwyn埝fwyt堆放fx坳,坶fxdl超级大国fxfd无缘无故fxg坶fxgu坶fxjn无线电fxkm教练员fxl坳fxln坳fxpu城乡之间fxty违纪行为fxug老弱病残fxwo二级企业fxyf超级市场fy坟,坑,塘fyaj坟墓fyb墩,垴fybh垴fybt墩fydd支离破碎fydf超高压fyds教育厅fyft献计献策fyge进度表fygy培训班,直言不讳fyim无底洞fyiy二话没说fyj霁,霭fyjj霁fyjn霭fyk壤fyke壤fykh走弯路fylw教育界fym坑fymn坑fyn坊,垓fynn教育局,协议书fynt地方性fynw垓fyp壕fypd坑害fype壕,教育家fypj井底之蛙fyqs无记名投票fyss坑木fysy无计可施fyt圹fytx老调重弹fyu雯fyug地方病fyut坑道fyv塘,墉fyvh墉fyvk塘fyvw无论如何fywf协调会fyy坟fyym南京市g一,与,于ga开,形,型gaaa开工,形式,开幕式gaad刑期gaaj开幕gaaq武警,刑警gaar不甘落后gaaw开花gaay开荒gab邢gabh邢gabw开除gabx与世隔绝gace开通gad琪gada不劳而获gadb亚欧大陆gadj不期而遇gadm五项原则gadn形成gadr弄巧成拙gadw琪,开春gady开矿,形态gae形gaes开采gaet形gaeu开脱gafc开动,开支gaff开封gafh开赴gafn开场gafq与世无争gafx不甘示弱gagj下落不明gagk刑事gagq开列gagr青黄不接gags一草一木gah武,琊,鹉gahb琊gahd武gahg鹉gahh形式上gahk开战gahv开眼gaic武汉gaid开源gaif刑法gaig弄清gaii开水gaip开学gaj弄,刑gaje开明gajf型gajh刑gak开,瑾gakg瑾,型号gakh开路gakk开口,武器galg开车,开国galt武力galw开办galy刑罚gam瑛,璜gamd瑛gamm开山gamw璜gana开展ganf开导,下基层gank开辟gann开局gant开发gany开心,不甘心gaog开业gaon武断gaoo开火gapb不切实际gapf开赛gapp不甘寂寞gapr不惑之年gapw开窍,形容gaqa弄错gaqh开外gaqi开销gaqj形象gaqm武钢gaqn开馆gaqs形式多样gaqy开镰gard开拓garn开掘garp开挖garv形势garw豆蔻年华gasc弄权gasf开标,开票gasm开机gasw开枪gasy武术gatb天花乱坠gatd一落千丈gate开船,开盘gatv刑律gaty开往gaud开关,开头,形状gauf武装gaui开阔gaum开端gaut开道,开颜gauy开门gavc开始gave开垦gaw珙gawb开创gawf开会gawg一切从严gawn形似gaws形体gawu五花八门gawy珙gaxp下世纪初gaxt开张gayj开课gaym开设,开市gayn开户,开幕词gayo形迹gayq一劳永逸gayt开放,开庭gayu与其说gayv开朗gayx开工率gayy开方gb屯,顿,珥gbbb一阵子gbbp不了了之gbdg顿感gbdl事出有因gbg珥gbgu不耻下问gbjf顿时gbn屯gbnm顿gbnt严阵以待gbnv屯gbqd顿然gbqe不了解gbro不出所料gbta副院长gbwd现阶段gc到,至,致gcad到期gcaq致敬gcbi致函gcda不欢而散gcdc一通百通gcdf互通有无gcdp到达gcf至,臻,郅gcfb郅gcff至gcfh不予考虑gcfj到gcfn到场gcft致,臻,死难者gcg玛gcgf至于gcgi不能不gcgk不骄不躁gcgo到来gcgq致死gcgv玛瑙gchh至上gchx至此gcit至少,一马当先gcjn致电gclt致力gcnr互通情报gcpe到家gcpg致富gcqq至多gcra下马看花gcrt到手gctd致辞gcth到处gctr不能自拔gcud死对头gcuj致意gcwg致命,致使gcwt到任,致伤,互通信息gcwx到货gcwy至今gcyn致词gcyt致谢gd天,吞,蚕gdad青春期gdao不厌其烦gdbb一辈子gdbf天际gdbk天职gdcc蚕桑gde瑚gdeg瑚gdfa亚太地区gdfb天地,正确地gdfe来龙去脉gdff天坛gdfh天真gdft天才gdga不顾一切gdgd天天gdgh天下gdgj天理gdgk两码事gdgo吞灭gdgu天平gdgy一成不变gdhg不在此列gdhh天上,画龙点睛gdhi形而上学,一大步gdi天gdim吞没gdip天堂gdir两面派,死硬派gdiv天津gdiy五大洲gdj蚕gdje天明gdjf天时gdjh一大早gdju蚕gdk吞gdkf吞,吞吐gdkt吞噬gdlg天国gdlr天堑,下大力气gdm顼gdmg天赋,死胡同gdmm天山gdmy顼gdn忝gdnt正确性gdnu忝gdpo天灾gdpw天空gdqc天色gdqd天然gdrn天气,死而后已gdrx一大批gds琦gdsc不大可能gdsk琦gdsq下大本钱gdst天桥gdtd天敌gdtg天生gdto死灰复燃gdtu不在乎gdua吞并gduf一大半gduq天资gdwg天使gdws天体gdwx表面化,不成体统gdwy蚕食,事在人为gdx珑gdxg天线gdxn珑gdxw不成比例gdxx蚕丝gdyg不在话下gdyp天亮gdyy天文ge表,青,静geaa青工gecm静观gecq不受欢迎gedf不胫而走gedm表面gedp表达gedw青春gedy表态geey静脉gef青,瑗gefc瑗gefi表示gefk表露gegm表现gegt更胜一筹geh甫,敷,逋gehc表皮gehg青睐gehh静止gehp逋geht敷gehy甫geip表演geit青海geje表明gejn静电gekr静听gelf静默gelw不服输gem靓gemm青山gemq靓genf表层geng表情geny青翠gep靛,瑷gepc瑷geph靛,静寂geq静geqh静geqj表象geqy青岛ger瑶gerh青年germ瑶gern表扬,不服气gerr表白gesb一脉相承gesi不胜枚举gest表格geti敷衍getj青稞geu表geud静养geuj表彰geun表决gewh静候geww五月份,一月份gexx五彩缤纷gey琢geym敷设geys琢磨geyt瑶族geyu不用说geyx表率geyy琢gf于,玩,球gfaj烈士墓gfan球艺gfaq不求甚解gfbw球队gfc珐gfcy珐gfdm球面,玩耍gffa天真无邪gfff不走过场gffh青云直上gffn球场gfft事过境迁gffu天南地北,一干二净gfga球形,玩弄gfgf一动不动gfgk一声不响gfgq一朝一夕gfgr来者不拒,一夫一妻制,一去不复返gfgu不干不净gfgw平起平坐gfhf不求上进gfhh一起上gfhw玩具gfi球gfig死去活来gfiy球gfjg于是gfjt一无是处gfk于gfkh下坡路gfl盂gflf盂gflk迂回gfmj不规则gfn玮gfnh玮gfop球迷gfov平均数gfp迂gfpf球赛gfpk迂,天壤之别gfq玩gfqc一专多能gfqn玩gfqq来去匆匆gfra一无所获gfrd一无所有gfre副教授gfrr开场白,一起抓gfrt一无所知gfru理直气壮gftd死规矩gftj不远千里gftm来去自由gftt玩笑gfud球状,不过关gfug不无道理gfut不动产,不无关系gfuw责无旁贷gfuy球门gfwf现场会,亚运会gfwg一声令下gfwk环城公路gfwr一鼓作气gfwx一元化,正规化gfyc再教育gfyp画地为牢gfys不堪设想gg五,王,环ggab环节,五一节ggan一世ggap顿开茅塞ggav一切ggaw一共ggbb一下子ggbg环卫ggbl一阵ggbw下一阶段ggc琶ggcb琶ggcc一双ggcf一致通过ggck五台ggdb环顾ggdd一整套ggdf事与愿违ggdm一面ggee五月,一月gges五彩ggey来不及ggfd环城ggfh一起,一直ggfi互不干涉ggfn一块,一场ggfq一无ggfu环境ggg王,戋ggga环形gggc一致gggd一天gggf环球,不亚于,不至于gggg王,五一,一一,平平静静gggh一下gggk一带,一事gggm一再gggt戋ggh五gghe一瞬gghg五gghi下一步,一步gghk一点gghx一些ggi环ggih琳琅满目ggii平平淡淡ggir一派ggiw一举ggiy环,五洲,一流ggjg一旦,一是,再不是ggjh一早ggjj一日ggjt五星,一览ggkf一味ggkg一号ggkh一路ggkk一口,吞吞吐吐ggkm一员ggl一gglf一团gglg王国gglk一回ggll一gglp一边,一连gglt表现力ggmg一同ggmm环山ggmu一致同意ggn瑟ggna一展ggnf开天辟地ggnt瑟,一致性ggny一心ggod一类ggpb一字ggpf王冠ggpg一定,不一定ggpm不正之风ggpn五官ggpp不速之客,平平安安,严严实实ggpt不到之处ggpy环视ggqc一色ggqq五金,形形色色ggqy至理名言ggrh五年,一年ggrn一气ggrq环抱ggrr歪歪扭扭ggru殊死搏斗ggrx一批ggsu一样ggsv一概ggsy素不相识ggta理事长ggtd殊不知ggte一般ggtf环行,一等,一行,不平等,一千ggtg一生ggth王牌,天天向上,一处ggtj来不得ggtk一种ggtm一身,一向ggto一番ggtq不平衡ggts一条ggtt开玩笑,来来往往,平平稳稳ggtv一律ggty不来往ggua一并ggud一头gguf一半ggum一瞥,一致意见ggup一旁gguq一次,再一次ggus一新ggut一道ggvk一如ggvt一群ggw琴ggwa一代,下一代ggwd一段ggwf理事会ggwg一例ggwh一个,下一个ggwk环保,五保ggwm一侧ggwn琴ggwo一伙ggwq互不侵犯ggws一体ggwt一任ggwu一倍ggww五谷,歪歪斜斜,一班人ggx琵ggxa环绕ggxc一经ggxe一级ggxf一贯ggxg一线ggxx琵ggxy一统,一再强调ggy珏ggya一度ggyi刑事诉讼法ggyj一齐ggyn一刻ggyw天下为公,下不为例,现政府ggyy珏,一方,一致认为,整整齐齐gh下,正,政gha琥,璩ghaa下工,政工,正式ghae璩ghag正巧ghai下落gham琥ghbq一目了然ghbt下降ghbv下限ghc玻ghck下台ghcn下马ghcy玻ghd正ghdd正大ghdg下厂ghdh正在ghdm下面,正面ghdp下达ghdq正确ghee正月,下月ghfc下去ghff政坛ghfh正直ghfl政协ghfn下场ghfu与此无关ghfv下雪ghfw正规ghg焉,鄢ghgb鄢ghgg不上不下ghgi一点一滴ghgk政事,正副ghgo焉,下来ghgq下列ghgs更上一层楼ghgu不止一次,速战速决ghgw一步到位ghgy玻璃,下班ghhk正点ghi下ghic政治ghif玷污,正法ghim下滑,逼上梁山ghip下沉,正常,政党ghir正派ghiv正当ghiy下游ghjg正是,正题ghk玷ghkg玷ghkh下跌,正路,正中ghkk正品ghlg下车ghlp下边ghlv正轨ghlw政界ghmf下周ghmg下同ghmj与此同时ghmm下山ghmq政见ghn丐,忑ghnf下层ghng下情ghnm下届ghnn政局ghnt下发,下属ghnu忑ghnv丐ghpf正宗ghpj政审ghpt政客ghpy正视ghq璨ghqj下旬ghqk正名ghqo璨ghrc正反ghrn正气ghrt下手ghsc政权ghsr与此相反ghsu与此相关ghsy下述ght政ghtd正逢ghtf下等,下午,正待,正告,正午ghtg下策,政策ghtl政务ghtv政委ghty政ghuj一瞬间ghuk下部ghuq下次ghut正道ghuw一些单位ghuy正门ghvb正好ghvk正如ghwf正值ghwg一步登天ghwh政企ghws政体,正体ghww弄虚作假ghwy下令,政令ghxc正经ghxe下级ghxg政绩ghxn政纪ghxt下乡ghxx正比ghxy正统ghyh到此为止ghym下调,下设ghyo政变ghyq正义ghyt下放ghyw政府,政论,两点论ghyy下文,正文gi不,还,否giag不巧giai开源节流gicb不予gice不能,不通gicf不对gicw不难gidb不顾gidd不大gide还有gidh不在gidq一举成名gidr不愿,还原gidy琐碎gie甭gieb不服gied还须giej甭giet不胜,不用giev不妥giey不及gifa不堪gifd不需,还需giff还款gifi还未gifm还击gifp不过gifq不远,五光十色gifs不学无术,一清二楚gifu不幸gig歪,丕,邳gigb邳gigc不致gigf丕,来源于,一举一动gigg不一gigh歪,不正gigi一尘不染gigj歪理gigk琐事gigm不再gigo不严gigt一举两得gigu不平gihe不肯gihh不止,政治上gii不giia不满giig还清giip不觉,不深giiq不光,天涯海角giit不少,青海省giiv不当gije不明gijf不时gijg还是gijh不畅,一清早gijq不易gik否gikf否gikh不足gikw不只gilg不畏gili五湖四海gilt不力gilv不轨gim琐gima歪曲gimf不周gimg不同gimh不由gimj否则gimq不见,歪风gimt不败gimy琐,不凡gina不惜,不懂ginb不敢,不屈ginf不慎ginn不快,不已,政治局ginq不懈ginr不愧,不怕gint不必,刺激性ginu不悦giny不尽,不忙gion不断giou不料gip还gipe不宜,政治家gipg不定,否定gipi还gipt不当之处,不法之徒gipu不治之症gipv不安gipw不容giq珧giqa不错giqd不然giqe不解giqh不外giqj不象giqk不够,不免giqn珧giqt一举多得,政治犯giqy不久gird不振girh青少年,正当年girq不拘girt还手girw不失gisg不配,不朽,还本gish不想gisk不可giss不禁gisv不要,还要gitd不适,不知gitf不等,不行,不靠gith不息,不算gitj不利gitk不和gitp不乏,不管gitq不稳gitw不符gity不法行为giud不善giuj不单,不意giuk不问,政治部giul不曾giun否决giuu政法部门giuw不准giv孬givb孬,不好givi不妙givk不如givy不妨,不忍giwb不法分子giwc不公,不仅giwf不佳,不值giwg不便,不合,还债giwj不但giwt歪斜giwu不倦giww正常人giwx正常化giwy不依,不信gixc不经gixq不绝gixv亚洲纪录gixw还给giyb不熟giyf不计,不讲giyi不应,还应giym天津市,武汉市giyn不忘giyo不变giyq不义giyt不许giyu不详giyv不良giyw不论,否认giyy不该gj理,更,惠gjad下星期gjce更能gjcw更难gjdd更大gjdh惠存gjf理,墼,軎gjfc更动gjff墼gjfg理gjfk軎gjfn理亏gjft天时地利gjfw更替,一览无余gjg亘,芈gjge一览表gjgf亘gjgg表里不一,一时一事gjgh芈,更正gjgj不早不晚gjgk理事gjgn不紧不慢gjgr不明不白gjgt素昧平生gjgy形影不离gjh惠,瑁gjhe理睬gjhg瑁gjhn惠gjih更小gjik画蛇添足gjip更深gjiv理当gjk丌gjkd理顺gjlk更加gjmf理财gjmh理由gjna惠民gjnb理屈gjnn更快gjnt更改,理发,理性gjq更gjqe理解gjqi更gjqq更多gjrn不景气gjrq更换gjrw更迭,平易近人gjsh理想gjsv更要gjtd理智gjtg更生gjtj一日千里gjtq更稳gjtu理科gjub理疗gjus更新gjvb更好gjvg表里如一gjwf理会,与日俱增gjwh到时候gjwx理化gjx琨gjxx琨gjxy五星红旗gjyi理应,更应gjym更高gjys更是这样gjyt惠州,来日方长gjyw理论gk事,整,带gkad事项gkbb开口子gkbk副职gkce融通gkcl开足马力gkdd整套gkde带有gkdf一哄而起gkdn速成gkdt事故gkdy事态,一蹴而就gkee整月gket速胜gkf吾gkfb整地gkfh逼真gkfj副刊gkgb整顿gkgd整天gkgj整理,来路不明gkgk整整gkgo带来gkgr一蹶不振gkh囊,蠹,璐gkhe囊gkhh一路上gkhj蠹gkhk璐gkhs橐gki束,赖,速gkic整治gkif整洁gkih整gkii束gkij剌gkim赖,速滑gkip速,整党gkit敕gkiw融洽gkjg吞吐量gkjj整日gkjn带电gkjv速归gkk卅,噩gkkk噩,副品gkl副,逼gklj副gklk带回gklp逼gkm融,鬲,翮gkmh鬲gkmj融gkmn翮gkmq整风gkng事情gknt整改gknw一鸣惊人gkog副业,事业gkp带gkpe事宜gkpg速写gkph带gkpt不足之处gkpu事实gkpw整容gkq吏gkqe融解gkqi吏gkqy逗留gkrg带兵,事后gkrh不足挂齿gkrp逼近,逼迫gkrt副手,囊括gksg副本gksj速查gksm整机gktl事务gktr事物gku豆,逗,豇gkua豇,速冻gkub豌gkuc豉gkud带状,带着gkue事前gkuf豆gkug带病gkum事端gkun速决gkup逗gkuq速效gkut武器装备gkv事gkvh事gkwg融合,事例gkwh整个,整修gkwl不遗余力gkwr事件gkws整体gkwt一路领先gkwx融化gkwy带领,副食gkxg束缚gkxy整编gkya速度gkyd不足为奇gkyj整齐gkyo事迹gkyw整夜,不足为凭gl画,盏,柬glb画glbj画gldm画面glf盏glff五四运动glfj画刊glfm天罗地网glga五四青年节glgf致力于glgk两回事,一回事glgr一国两制gli柬glii柬glk珈glkg珈glkm列车员gllf不加思索gllt画图glmg一连几天glmm画册glna画展glog一团糟glp琏glpe画家glpg画室glpy琏glrb画报glsg不置可否gltr一团和气gltt严加惩处glud画卷gluj两国间glwq画像glws不加分析glyy画廊gm现,两,再gma曹,遭gmaj曹gmap遭gmar歪风邪气gmbg刺耳gmbk现职gmbm现出gmbp两院gmcw两难,责难gmd瑞gmde现有gmdg再三gmdh现存,现在gmdj瑞gmdm两面gmdn现成,责成gmep遭受gmet两用gmf再gmfb两地gmfc遭劫gmfd再gmff现款gmfg瑞士gmfn现场gmft两者,再者gmfv瑞雪gmgc遭到gmgd不几天gmgf不同于gmgi再不gmgm再现,瑞丽gmgq遭殃gmhy形同虚设gmi刺,棘,枣gmia现汇,丽江gmif一败涂地gmii棘,丽水gmij刺gmip两党gmir刺激gmiu枣gmjf现时gmjm遭遇gmlp两边gmm珊,璎gmma瑞典gmmd两岸gmme刺骨gmmg珊gmmk不同凡响,一帆风顺gmmq再见gmmv璎gmn玑gmnc责怪gmnl两翼gmnn现已gmnt两性gmpf不败之地gmpj再审gmpo遭灾gmpt不同之处gmpu现实gmq现gmqi现钞gmqj现象gmqn现gmqq现金gmrh现年gmrt棘手,两手gmse两极gmsf再植gmss两栖gmsu两样gmtf现行,再造gmtg再生gmth再版gmtj不由得gmtl责备gmtm现役gmty不由自主gmu责gmud两头,现状gmuf两半gmuj不同意gmuk现况,责问gmum两端gmup两旁gmuq再次,两次,现将gmvd一见如故gmw丙,邴,璀gmwa现代gmwb邴gmwf再会gmwg两便,两全gmwi丙gmwm两侧gmwt现任,责任gmww两,两败俱伤gmwx现货gmwy璀,现今,责令,不由分说gmxe两级gmxt刺绣gmxw不见经传gmy丽,郦,鹂gmya再度gmyb郦gmyf枣庄gmyg鹂gmyp逦gmyu再说gmyy丽,再议gn与,瓦,欤gna珉gnad与其gnan珉gnaq开发区gnas不惜工本gnaw与共gnd琚gndg琚gndn不翼而飞gndp不发达gndq瓦砾gndy平心而论gng与gnga于心不甘gngd与,不屑一顾gngf不属于gngi与否gngn不慌不忙gngr不屈不挠,平心静气gngu一心一意gngv于心不忍gngw欤,于己于人gnh瑕gnhc瑕gnhd下情上达gniv不敢当gnlg开快车gnni静悄悄gnnn不愉快gnnt开发性gnpl一臂之力gnqd不尽然gnqe瓦解gntn严以律己gnuk开发部gnvu不怀好意gnwf与会gnwu不尽人意gnxj开发费gny瓦gnyn瓦,瓦房,副书记gnyq不以为然go来,恶,严gobi来函goby严防god严godd严厉godj亚非godl来历godr严gofd晋城goft来者gog亚,晋,璞goga戬gogd亚gogf垩,严于gogh严正gogj晋gogn恶gogx恶毒gogy璞gohk恶战gohx来此goi灭,来goid来源goit恶劣goiy亚洲goje严明gojn来电gojs恶果gojt来临gokh来路,晋中gola来料加工golk来回,严加gom赉gomc严峻gomh来由gomu赉gont恶性gonu恶习gony恶心,事业心goo琰gooo灭火gooy琰gopf严寒,严守gopl亚军gopn严密gopr来宾gorh来看,来年gorv来势gosg严酷goss严禁gost严格gota晋升gotg严惩,严重goth来自gotu严冬goty来稿,来往goud来头gouj恶意,来意govi严肃gowr来件goww来人gowx恶化,来华gowy来信goxe晋级goxq灭绝goya严谨goyn灭亡goys恶魔goyu来说goyy来访,来文gp琮,琛,彀gpad不定期gpcb天之骄子gpf琮gpfi琮gpfr一穷二白gpgc彀,一窍不通gpgj来之不易gphh事实上gpim两袖清风gpjy开宗明义gpl珲gplh珲gpmw一视同仁gpnt烈军属,现实性gppi不祥之兆gppy不实之词gpq琬gpqb琬gprn不客气gpuy天安门gpw琛gpwp天灾人祸gpws琛gpww一家人gpwy不完全统计gpyt不容许gpyu束之高阁gq列,死,熬gqb殛gqbg殛gqbk殉职gqbm列出gqbp玩忽职守gqbu残联gqbw列队gqc殆gqck殆gqcw死难gqdg死硬gqdh残存gqds五角大楼gqe殂,殍gqeb殍gqeg殂gqf殖,麸,殪gqfg烈士gqfh殖gqfi妻儿老小gqfm歼击gqft死者gqfu殪gqfw麸gqg残gqga死刑gqgf不急于,死于gqgo歼灭gqgt残gqgw不负责任gqi歹gqip死党gqit死活gqiw列举gqiy遨游gqj列,烈,裂gqja残暴gqje裂gqjh列gqji虺gqjj烈日gqjo烈gqjt五角星gqk殒gqkh死路gqkm殒gqld死因,死罪gqlg列车gqm殃,殁gqmc殁gqmd殃gqme残骸gqmq不多见gqmt一针见血gqnn残局gqnt烈属,烈性gqny死心gqoo烈火gqp殡gqpd残害gqpf死守gqph死寂gqps列宁gqpt来犯之敌gqpw殡gqpx不解之缘gqpy死神gqq殉gqqe死角gqqj殉gqqy残留gqr殊gqrg死后gqri殊gqrm残缺gqrn天然气gqry不然的话gqsg残酷gqsr死板gqsy赘述gqt歼,殇,敖gqtb聱gqtc骜gqtd獒gqtf歼,歹徒gqtg鳌gqtj螯gqtm赘gqto熬gqtp遨gqtq鏊gqtr殇gqtu不外乎gqty敖,列入gqu殚gque不久前gquf殚gqut残疾gquv裂痕gqv兀gqvn一触即发gqvy残忍gqw殓,殄,餮gqwe餮,殄gqwi殓gqws不包分配gqwt残余,死伤gqwx形象化gqwy不负众望gqx死gqxb死gqxt裂缝gqxy裂纹gqy玖gqya列席gqyl列为gqyn残废,死亡gqyq画饼充饥gqyt一句话gqyy玖gr珠,碧,瑰grab青年节graj碧蓝grbb一揽子grd碧grdf碧grdm正反面grdp一扫而空grft开拓者,束手无策grg珀grga开拓型grgd再接再厉grgk亚热带grgm瑰丽grgr不折不扣grgs不拘一格grgu一年到头grgw残缺不全,形势逼人grgy碧玉,不卑不亢,一年一度gri珠gria珠江grid一反常态grih碧波grii来势汹汹,死气沉沉griq理所当然grit珠海griy珠grjs不失时机grkd一气呵成grlf青年团grlt一年四季grmu残兵败将grnt互换性grpg瑰宝,珠宝grpt一技之长grpw碧空grq瑰grqc瑰grqg一年多来grql一手包办grrt一把手grrw不择手段grts开白条gruy开后门grvw一拍即合grwn不近人情grww青年人grxr一年比一年grxv碧绿grya五年计划gryl不失为gs末,琳,珂gsad末期gsce不可能gsdt一本万利gsfg不相干gsga不可一世gsgi不可不gsgs一模一样gsgu不可开交gsgx一本正经gsh玎gshg不相上下gsi末gsii正本清源gsjc不要紧gsk珂gskg珂gsla来样加工gsmm平顶山gsnt末尾gspp灭顶之灾gspw不相容gsqt不可多得gsrh末年gss琳gssy琳gstq不相称gstw不可告人gsty不相适应gsuj互相间gswa末代gswt还本付息gsww两极分化gt玫,麦,珞gtai一盘散沙gtal麦苗,一等功gtan一筹莫展gtar死得其所gtaw不乏其人gtbb麦子gtbg敷衍了事gtbk不称职gtbn不得了,不行了gtcm一箭双雕gtcn珞巴gtdd不复存在gtdk不辞而别gtdt不得而知,不告而辞gtdx一条龙gtek两条腿走路gtey来得及gtf珩,瓒gtff玩物丧志gtfh珩gtfm瓒gtfq天长地久gtfs天翻地覆gtft不知去向gtfu一往无前gtfy一般地说gtgc严惩不怠gtgf不等于,不利于,正处于gtgg互利互惠,平等互惠gtgi不知不觉gtgo不务正业gtgq一系列gtgr玫瑰gtgt平等互利,现行政策gtgy一般来说gtid一息尚存gtip不科学gtjl不自量力gtjq天长日久gtk珞gtkg珞gtkh一生中gtkk一等品gtl璁gtll麦田gtln璁gtlp一笑置之gtnh麦收gtni一往情深gtnn不得已gtnt两重性,严重性,一般性,政策性gtny一条心gtpf不毛之地gtpg不稳定gtpi不智之举gtqq一笔勾销gtrn事务所gtrq一笔抹杀gtrr不知所措gtry现行制度gtsa一盘棋gtsu现行标准gtsw不得要领gttf一条街gttn不徇私情gtu麦gtua不辞辛苦gtuj不简单gtuq一等奖,一知半解gtut不知道,再生产gtwn不得人心gtww一行人gtwx一般化gty玫gtya一季度gtyg一般说来gtyi不适应,现身说法gu平,夹,颊guau歪门邪道guaw事半功倍gubt一意孤行guck平台gucq夹道欢迎gudm平面gudn事关大局gufa副总裁gufb平地gufj平坦gufm夹击gufn下半场gufq平均guge平静gugk夹带,平整gugo到头来gugw班门弄斧guh平guhk平guhl开阔眼界guig平添guim平滑guio平淡guip平常guir不减当年guj璋gujf平时,下半时gujh璋gujj平日gukk副产品guli开门办学gumm开门见山gumy平凡guna平民gunf夹层gunn平局gunt一次性guny下决心gurc平反gurh青壮年,下半年gusc表决权,否决权gusr夹板,平板guta副部长gutd事关重大gutf平等,平行,不道德gutg平生,一并处理guth平息gutn整装待发gutq平衡,平稳guts至关重要guua再立新功guuk武装部guuq五颜六色guvs夹杂guw夹,郏guwb郏guwf表彰会guwi夹guwm颊guwn事关全局guwv平分,一部分guww平价,带头人guxa开门红guxe平缓guxg副总经理guyi开闸放水guyk下意识guym平调guyn平房guyv平庸guyy平方,正前方gv妻,瑙gvav一刀切gvgf再好不过gvgy不妨一试gvh妻gvhv妻gvnt严肃性gvt瑙gvtq瑙gvul不好意思gvvt一如既往gvwq天怒人怨gw珍,玲,瑜gwa玳gwad珍藏gwaq责任区gwau两全其美,事倍功半gwax下个世纪gway玳gwcw一个又一个gwdf弄假成真gwdg责任感gwds珍奇gwdw五谷丰登gwe珍gweb不舒服gwee下个月gwel不使用武力gwep珍爱gweq不分胜负gwet珍,副作用gwft与会者gwg瑜gwgd玲珑gwge副代表gwgf不低于gwgj瑜,不合理gwgm与众不同gwgo不伦不类gwgr珍珠,不值一提gwgw不偏不倚,五谷不分gwif不合法,两分法gwip致公党gwjp不合时宜gwkh珍贵gwkk珍品,副食品gwkn一个中心gwll责任田gwmf与会同志gwmj殊途同归gwna珍惜gwnn环保局,责任书gwnt开创性gwny责任心gwpg珍宝gwpq天伦之乐gwpu一念之差gwpy珍视gwqt一会儿gwrf五体投地gwrm五分制gwsg珍本gwtf再创造gwtg珍重gwtj不值得gwtq珍稀gwuk环保部gwuw一代新人gwv玢gwvh不仅如此gwvn玢gwwc不仅仅gwwd天从人愿gwwg与会代表,政企分开gwww现代人gwwx现代化,一体化gwxc融会贯通gwy玲gwyc玲gwyf一分为二gwyn五保户gwyu与人为善gx互,毒,素gxde素有gxdm不约而同gxeg互助gxep互爱gxf纛gxfi纛gxfy天经地义gxg互gxga一丝不苟gxgb不绝于耳gxgd互gxgg不经一事gxgj互惠gxgo素来gxgu毒gxgx毒素gxgy一丝一毫gxi素gxiu素gxiy不经济gxjp毒蛇gxkk毒品gxmu互赠gxnt毒性gxos开绿灯gxpd毒害gxpu互补gxpy互祝gxqk互勉gxqy一线希望gxra素描gxrf素质gxrm一贯制gxrn毒气gxrq互换gxrr青红皂白gxrs毒打gxsf素材gxsh互相gxta班组长gxud素养gxug毒辣gxw夷gxwg正比例gxwi夷gxwn灭绝人性gxwx毒化gxyh互让gxyl互为gxym互设gxyw下结论gxyy互访gy玉,班,斑gyao不计其数gyaq开放区gyb璃gyba妻离子散gybb班子gybc璃gyc琉gyck天文台gycq琉gydg正义感gydk不言而喻gydm两方面,一方面gydu死记硬背gydw不谋而合,不识大体,开诚布公gydy整齐有序gyfb一望无际gyfh至高无上gyft来访者gyfx天衣无缝gyg斑gyga开放型gygg斑gygr不亢不卑gygt一言一行gygw融为一体gyhh理论上gyhk斑点gyi玉,琼gyiy琼,死说活说gyjt不识时务gykw恶语中伤gylg班车gylu五讲四美gylw班轮,理论界gynp一言以蔽之gynt开放性,正义性gyoy玉米,平方米gype理论家gypl天府之国gypm不义之财gypu一夜之间gyqt开户银行gyrs不计报酬gyrx严词拒绝gysc玉树gysm班机,开诚相见gysx形迹可疑gyt班,璇gyta班长,副市长gytf开户行gytg班gyth璇gytj不言自明gytt不谋私利gyud一语道破gyuj政府间gyuq班次gyv琅,瑭gyve琅gyvk瑭gywt班主任gyww一应俱全gyxe班级,班组gyy玟gyyt一席话gyyu斑斓gyyx死亡率gyyy不应该,更应该h上,此,点ha虎,瞒,虚haa虐haag虐haap虚荣hadf虚夸hae遽haep遽hag眶hagg眶hagw瞒hak虞hakd虞hal瞄,虏halg瞄halv虏ham虎,彪hame彪hamv虎han虑hani虑hany虚惊,虚心,虚荣心hao虚,觑haog虚haoq觑hapu虚实haq眍haqk虚名haqy眍harb虚报hasq虚构hatf虐待hauw瞄准hav虍hawn虚假hawy虚伪haxn虚幻haxt眼花缭乱haxu虚弱hay虔haya虚度hayd虔诚hayi虔haym虚设hc皮,颇,眸hcaf皮革,皮鞋hcbw上台阶hccn眼巴巴hcd颇hcde颇有hcdh颇丰hcdm颇hcef皮肤hchw颇具hci皮hck眙hckg眙hcqq颇多hcr眸hcrh眸hcsr皮棉hctf皮毛hcu攴hcw睃hcwt睃hcyl颇为hcym颇高hd睚hddu卓有成效hdf睚hdff睚hdhh睁大眼睛hdif颇感兴趣hdjg占有量he肯,睬,瞬hebb卡脖子hecq颇受欢迎hef肯hefg肯干hep瞬hepg肯定heph瞬hes睬hesy睬heth瞬息heuj瞬间hf睦,睹,歧hfc歧,瞌hfcl瞌hfcy歧hff眭hffg眭hfft目击者hfix目无法纪hfkh歧路hfny上进心hfpy歧视hft睹hfti旧地重游hftj睹hftw此起彼伏hfw睦hfwf睦hfwt歧途hfwy睦邻hfxx虚无缥缈hfyq歧义hg睛,凸,睐hgb盹hgbn盹hgbw上一阶段hge睛hgeg睛hgf盱hgfh盱,瞧不起hggg上下一致hggp忐忑不安hggy上下班hgh眄hghh睁开眼睛hghn眄hgjr目不暇接hglh目不转睛hgm凸hgmg凸hgo睐hgoy睐hguf战天斗地hgv睫hgvh睫hgwh上一个hgxe上下级hgys目不识丁hgyy上下文hh止,目,卡hhbl上阵hhbv上限hhck上台hhcn上马hhdd战战兢兢hhdm上面hhdn上万hhdp上达hhee上月hhfc上去hhfj上进hhfm目击hhfn上场hhg上hhgd上天hhgg上hhgh上下hhgo上来hhgq上列hhgy上班hhh止hhhf目睹hhhg止hhhh目hhhq眼睁睁hhhy目眩hhim目测hhip上学,上演hhiq目光hhit上海hhiv上当hhix上涨hhjm上映hhkh上路hhkk目瞪口呆hhl丨hhlg卡车,上车hhlk上回hhll丨hhlp上边hhmh上帐hhmm上岗,上山hhnf上层hhnm上届hhny上心hhpw上空hhqj上旬hhqq上钩hhrb上报hhrh上年hhrq目的hhsf目标hhsu上校hhsy上述hhta上升hhtf上等,上告,上街,上午,上行hhtg上策hhth卡片hhtl止血hhtu上乘,上税hhu卡hhuc止痛hhue目前,上前hhuk上部hhum上端hhuq上次,上将,上交hhuy上门hhvi目录hhw矍,瞿,氍hhwc矍hhwn氍hhwt上任hhwy瞿,卡住hhx眦hhxe上级hhxn眦hhxr上缴hhxt瞠目结舌hhy卜hhya步步为营hhyj上课hhym上调,上市hhyr上诉hhyy上访,上方,上文hi步,叔,频hibb步子hic叔,督hicb步骤hich督hicy叔hid频,颦hidf颦hidm频hihi叔叔hinf督导hint步履hip瞠hipf瞠hiq眺hiqn眺hir步hirg步兵hism柴油机hisw步枪hit眇hitf步行hitt眇hitx频繁hity步入hiwa步伐hiwf频传hiwk督促hiym步调,上海市hiyn眺望hiyx频率hj旧,桌,卓hjad上星期hjaf卓著hjbb桌子hjee旧貌hjfh旧址,卓越hjg旧hjhy此时此刻hjj卓hjs桌hjsu桌hjxq卓绝hjyk卓识hk占,战,觇hka战hkal战功hkaq战区hkat战hkbb点子hkbm点出hkdc战友hkde占有hket战胜,占用hkf占hkfb战地hkfg战士hkfn战场hkfw目中无人hkgk战事hkiu点滴hkjf战时hkjs战果hklg旧中国hklt战略hkm觇hkmq觇hkmt战败hkn乩hknn乩,战局hkny点心hko点hkoo战火hkoq点燃hkou点hkpr鼎足之势hkqk点名,点钟hkqs眼中钉hkqv战争hkrb战报hkrg战后hkrn占据hksk战歌hksm战机hksy战术hktd战乱hkte战舰hktf占先hktl战备hktm战役hkud点头hkue战前hkuf战斗hkuk战况hkwe战俘hkwy占领,占住hkxc点缀hkxg战绩,战线hl卤,卣,鹾hln卣hlnf卣hlq卤hlqa鹾hlqi卤hm贞hmgx上山下乡hmtj眼见得hmu贞hmyp眼见为实hn卢,鼎,眠hna眠hnan眠hnaw虚怀若谷hnb瞰hnbt瞰hnd鼎,颅hndm颅hndn鼎,鼎盛hne卢hngd上情下达hnhh瞩目hnnx旧习惯hnq鸬hnqg鸬hnt瞩hnty瞩hnu忐hnuu鼎立hnwu虚情假意hnxc步履维艰ho眯,瞵hoif柴米油盐hoq瞵hoqh瞵hoy眯hp瞎,睿,壑hpd瞎hpdk瞎hpg壑hpga目空一切hpgf壑hpgh睿hphh虎视眈眈hpj瞑hpju瞑hpq眈hpqn眈hpwf旧社会hq餐,睁,瞻hqc餐,粲hqce餐hqco粲hqd瞻hqds餐厅hqdy瞻hqhj餐桌hqhv睁眼hqhw餐具hqq眵hqqn餐馆hqqy眵hqv睁hqvh睁hqwq瞻仰hqxg紫外线hqyn瞻望hr睥hrfb目的地hrjg步兵师hrnt目的性hrrp瞎指挥hrt睥hrtf睥hs盯,瞟hsf瞟hsfi瞟hsh盯ht睡,眨,瞅htdy瞬息万变htfh瞧得起htg睡htgf睡htgu上行下效hthn睡眠htip睡觉htmq瞅见hto瞅htoy瞅htp眨htpy眨httw具备条件hu瞳,睇hudr瞻前顾后hufn上半场huj瞳hujf瞳,上半时hujn虎头蛇尾hult战斗力hurh上半年hurn眼疾手快hutn旧病复发huuk上半部huvr瞬间即逝huxt睇hv眼,睨,瞍hve眼hvey眼hvgh眼下hvh瞍hvhc瞍hvhg眼睛hvih眼泪hviq眼光hvlt眼力hvlw眼界hvpw眼帘hvpy眼神hvq睨hvqc眼色hvqn睨hvqu眼镜hvrh眼看hvrv眼热hvue眼前hw具,瞧,盼hwaq占领区hwax上个世纪hwb齿,龄,龇hwbc龄hwbe龈hwbf龌hwbg龃hwbh龊hwbj齿hwbk龉,龆hwbn龅hwbx龇,龀hwby龋hwde具有hwee上个月hwg瞪,睽,睑hwgd睽,上传下达hwgi睑hwgu瞪hwlw齿轮hwmq瞧见hwpe占便宜hwrv占优势hwtl具备hwu具hwud盼头hwv盼hwvn盼hwws具体hwy瞧,睢hwyg睢hwyn盼望hwyo瞧hx此,些,柴hxad此项hxaj柴草hxd砦hxdc雌雄hxdf砦hxf些hxff些hxfr虚张声势hxgc此致hxgk此事hxim柴油hxjf此时hxm赀hxmu赀hxn此hxnt雌性hxod此类hxq觜hxqe觜hxqh此外hxrg此后hxs柴hxsu柴hxtf此行hxuj此间hxuq此次hxw雌hxwy雌hxx紫hxxi紫hxy訾hxyf訾hxyn此刻hy眩hygg步调一致hyrw眼高手低hyx眩hyxy眩i不,水,小ia江,港,满iaab活菩萨iaad满期iaaj湛蓝iaal江苏iaaq灌区iabc汇聚iaca泄劲iack港台iad湛,淇,漭iada漭,流芳百世iadb水落石出iadm江面,满面iadn湛,汇成iadr澌iadw淇iaee满月iaep满腔iaew满脸iaf泔iafa满载iafc举世无双iaff汇款iafg泔iafk泄露iafm江南iag江,懑iagd满天iagg小巧玲珑iagn懑iagw满iahh满目,举世瞩目iaia浇灌,渠灌,湛江iaid江湖iaii洪水,江水,灌水iain泄漏iaip汇演iais江河,潇洒iait港澳,江苏省iaiv灌溉iaiw江淮iaiy灌注iaj漠iajd漠iak灌iakh满足,江中iakk港口,满口iakm满员iaky灌ialp江边ialw灌输,江轮iam潢iama小巫见大巫iamd江岸iamt洪峰iamw潢ian汇,泄,渠ianf泄愤iang满怀iann泄ians渠,渫iaow污七糟八iap涝,滢,潆iapi潆iapl涝iapn泄密iapo洪灾,涝灾iapy滢,漠视iaq沤,鸿iaqd浇铸,漠然iaqg鸿iaqy沤iarb汇报iarn泄气ias柒iasf汇票iasg江西iass灌木iasu柒,光荣榜iat浇iatl港务iatm满身iatq浇iaud满头iauj满意iauk汇总iaum港商iauq灌浆iaut渠道iauy江门iav沏,潇iavj潇iavn沏iaw洪iawg汇合iawn港iawv满分iaww汇价iawy洪,汇集iaxy汇编iayt满族iayw港府,满座iayx汇率ib池,涵,滁ibbb小孩子ibc滠ibcc滠ibeg滁县ibfy池塘ibg洱ibi涵ibib涵ibim涵洞ibk凼ibl泐ibld渎职罪ibln泐ibn池ibpw海陆空ibrn派出所ibud涵养ibug涵盖ibw滁ibwt滁,光阴似箭ibym沈阳市ibyq涵义ic汉,治,泽ica泾icaa汗马功劳icag泾icd渗icde渗ice涌iceh涌icf泽icfh泽,涌起icfj涌进icgj治理icgm涌现icii治水icin渗漏icip治学iciw滩涂icjg流通量ick治ickg治iclg治国icmm治山icpb汉字icpe治家icpl治军icpv治安icsf治标icsg治本icte渗透ictm涌向icty渗入,涌入icub治疗icud滩头icug治病icw滩,浚icwg治愈icwt浚icwy滩icy汉,汊icyg汉语icyt汉族icyy汊id尖,湖,淹idaq湖区idbb尖子iddm湖面iddq深有感触iddu温故而知新ide湖,洧ideg湖,洧idf涯,溽idff涯,溽idfm湖南idfp没有过idg沽idgd学而不厌idge沥青idgf源于idgp深感不安idh沣,滟idhc滟idhh沣idi尜idim淹没idip湖滨idir湖泊idiu尜idiw滥砍滥伐idj淹idjg消耗量idjn淹idl沥idlg添砖加瓦idll学成回国idln沥idlu湖畔idm湎idmd湎,深有同感idmq浮夸风idog少而精idqu尖锐idr源idrd学有所成idre学有所用idrg尖兵idri源,源泉idt涛idtf涛idtg澳大利亚idtj尖利idtu温故知新idu尖,潦idud源头idui潦idum尖端idux湖北idw溱idwt溱idww深有体会idwx小百货idx泷idxn泷idxw深耕细作idy汰idyd学大庆idyj兴奋剂idyn尖刻idyt湖州idyy汰ie肖,浮,削ieap深受其害ieb浮iebc汲取iebg浮iec淝iecn淝iedc小朋友iedf浮夸iedg淫威iedh光彩夺目ieer逍遥ief肖iefg淫雨iefu沮丧ieg沮iegd滔天iegg沮iegu削平ieiq逍遥法外iej削iejh削iejw光彩照人iemf浮雕iep逍iepb常用字iepd逍ieqt淫猥iern满腔热情iero涂脂抹粉iet淫ietd淫乱ietf淫ietm淫秽ieud削减ieug水乳交融ieup常胜将军iev滔ievg滔ieww削价iex溪iexd溪iexu削弱iey汲,涿ieyy涿,汲if法,汗,汁ifa灞ifad潜藏ifae灞ifal污蔑ifat清规戒律ifbk渎职ifbp法院ifc法,溘ifce潜能ifcl溘ifcy法ifd濡ifdf污辱ifdh潜在ifdj濡,满载而归iff尘,洼iffc尘埃ifff尘土iffg洼iffr污垢iffw法规ifgf滚雪球ifgp洗劫一空ifh汗,汁,滇ifhf学无止境ifhk污点ifhw滇ific法治ifid澎湖ifii潮水,汗水,潜水,污水ifij潮湿,污浊ifin潮汛,污泥ifip法学ifiq潮汐,潜逃ifir澎湃,激进派ifit渤海,海南省,河南省,湖南省,源远流长ifiv污染ifiy潮流ifj潮,瀚ifje潮ifjn瀚ifk洁,澎,澍ifke澎ifkf澍ifkg洁iflb漫无边际iflg法国iflt潜力iflw法办ifma法典ifmj法则ifmq法网ifn污,渎ifnd渎ifnn污ifnr尘土飞扬ifnt流动性ifny潜心ifp渤ifpe活动家ifpg法宝,法定ifpl渤ifpn法官ifpv法案ifq沅ifqn沅ifqt学雷锋ifrk污损ifrm法制ifrn潮气ifrr洁白ifsa小规模ift渚ifte潜艇iftj渚iftm污秽iftv法律ifty潜入ifuk党支部,小卖部ifuq洁净ifuy党支部书记ifw潜ifwd潜伏ifwj潜ifww法人,当地人ifwy法令ifxn法纪ifyg法语ifyk少走弯路ifym济南市ifyn法盲ifyt法庭ig汪,清,添igad清苦igai浅薄igb沌igbn沌,少不了igbw清除igd添igdm海平面,水平面igdn添igdp溃不成军igdq清爽igdt满不在乎ige清,浦,溥igef溥igeg清igei举不胜举igeq清脆igey浦igff兴致勃勃igfh清真igfp逃不过igfq清远igg汪igga流于形式igge清静iggj清理igh沔ighk清点ighn沔igic浅滩igid水到渠成igif清洁igio清淡igit浅海,常来常往igiu汪洋igiy清澈igj洹igjd清晨igje清明igjg洹igjh清早igjo浅显igjs清晰igk滞,漱,濑igkg浯igkh滞igki涑igkm濑igkn深表遗憾igkw漱iglf添置iglk添加igm渍,沛,漕igmh沛,清帐igmj漕igmq浅见,清风,添购igmy渍ignu满天飞igo涞igoy涞igpi党政军民学igpl党政军igpu添补igq洌igqc清一色igqi滞销igqj洌igqw清欠igqy滞留igrd举一反三,耀武扬威igrg滞后igrv清扫igs沫igsg清醒igsj清查igss清楚igsu清样igsy沫igt浅igtd添乱igte清秀igth清算igtj清香igto浅释igu浃iguj清单igun漠不关心igus清闲,清新iguw浃,清冷igux深恶痛绝iguy清凉igwb清仓igwj光天化日igww当事人igwx清华igxg水平线igxn漫不经心igxx清幽igyg溢于言表igyi清正廉洁igym清高,添设igyu浅说,清廉igyw省政府ih小,波,沾iha滤,滹ihab小节ihag小巧ihah滹ihai渺茫ihan滤,涉世ihaq小区ihaw泪花ihbw小队ihby小孩ihc波,婆ihcv婆ihcy波ihey涉及ihfd小城ihfg小雨ihfu举目无亲ihfv小雪ihg泪ihga小型ihgf濒于,小于ihgk小事ihgt小麦ihi涉,淑,濒ihic淑ihid波涛ihih婆婆ihii泪水ihim濒ihip小学ihiq沾光ihit涉,渺ihiu波澜ihiv沾染ihiy波浪ihj淖ihjf小时ihjg掌上明珠ihjh淖ihjt濒临ihk沾ihkg沾ihkh涉足,小路ihkk小品ihlg小国ihlp沾边ihm浈ihmr小贩ihmy浈ihn泸ihns水上飞机ihnt泸ihny小心ihpe婆家,小农ihq瀣ihqd濒危ihqg瀣ihqh涉外ihqt涉猎,小儿ihqu学龄儿童ihrn小气ihrr波折iht小ihty小ihue学龄前ihuh小站ihuj波音ihuq小将ihuu学龄前儿童ihve小姐ihvt婆媳ihvu涉嫌ihw濉ihwd波段ihwo小伙ihwy濉ihxe小组ihxf小结ihyf小计ihyu小说ihyv小康ii水,消,沙iiaa浩浩荡荡iiaj水草iiay沙荒iibb沙子iibf水陆iibw消除iiby消防iice水能iick港澳台iicl沧海桑田iicv激流勇退iidb漏洞百出iidc洋洋大观iidg沙石,滚滚而来,水厂,水泥厂iidi消耗,汪洋大海iidk津津有味iidm水面iidp泛滥成灾,水滴石穿iidu滴水成冰iidy泛泛而谈iie消iieg消iifa水域iifb沙地,水浇地iifc水运iiff水土iifm水坝iifn沙场iigc水泄不通iigf水球iigg堂堂正正iigh水下iigi滴水不漏,济济一堂iigk消融iigo消灭,源源不断iigs沧海一粟iigu水平iigx消毒,滔滔不绝iii水,淼iiia沙漠,水渠iiic沙滩iiid水源,泪流满面,污染源iiif海洋法iiii水,江河湖海,污泥浊水,汹涌澎湃iiin水泥iiip消沉iiit浙江省iiiu淼,汗流浃背iiiv水污染iiiy水流iijg江河日下iijn水电iijr激光照排iijs水果iikh水路,消遣iilg小汽车iill水田iils添油加醋iilt水力iilw港澳办iim淌iimh流水帐iimk淌iimq湖光山色iing淋漓尽致iint沙发iior水深火热iipd水害,滴水穿石iipf淘汰赛iipo水灾iiq洮iiqn洮iiqu津津乐道iirg沙丘,水兵iirq浑水摸鱼,满满的iirr消逝,清清白白iirv水势iirw消失iise消极iisi沧海横流iiss清清楚楚iisu小学校iit沙,裟,鲨iite裟,水稻iitf沾沾自喜iitg鲨,小学生iith消息iitj水利iitr挲,污染物iitt沙iitu洋洋得意iitv娑iity水涨船高iiut水产,水道iiuv消瘦iiuw水准iive消退iiwg泥沙俱下,誉满全球iiwj泾渭分明iiwx消化iixg流水线iixj消费iixt水乡iiyl水库iiym沙市iiyn消亡iiys消磨iiyt水族ij浊,混,温ija瀑ijai瀑ijcb温柔ijda光明磊落ijdm瀑布ijdw小题大作ijet滥用ijf沓,涅ijfg涅ijfj混进ijfn温馨ijfw兴师动众ijg汨,汩ijgd漫天,光明正大ijgl漫画ijhi漫步ijhk混战ijij混浊ijiq混淆ijiu湿润ijiy漫游ijje温暖ijjn浅显易懂ijjr光明日报ijkd温顺ijl温,漫ijlc漫ijlg温ijn溻ijng溻,温情ijnt滥发ijo湿ijog湿ijpg温室ijq渴ijqn渴,温饱ijt滥ijta漫长ijtd混乱ijtk温和ijtl滥ijty混入ijuh水电站ijuk水电部ijvd温暖如春ijvs混杂ijwa滥伐ijwg混合ijwh小时候ijx混ijxx混ijxy混纺ijy浊,灏ijya温度ijym灏,滥调ijyn渴望ijyo漫谈ijys温床ijyt漫话,温州ik澡,溃,涡ikau涉足其间ike涓ikeg涓ikgf满足于ikh溃,潞,浞ikhk潞ikhm溃ikhy浞ikj渑ikjn渑ikk澡,漶ikkn漶ikks澡iklt举足轻重ikm涡ikmd党中央ikmt溃败ikmw涡ikre水中捞月iktn削足适履ikun溃疡ikve溃退ikwe省吃俭用ikwf演唱会ikym海口市il渐,泅,渭ilce举国欢腾ild涸,洇ildg涸ildq满园春色ildy洇ile渭,溷ileg渭iley溷ilf涠ilfh涠,渐趋ilfj渐进ilg泗,淠ilgj淠ilgl漆黑一团ilgy沉默不语ilhg举国上下ilig小恩小惠ilil渐渐ilis漯河iliv少男少女ilk洄ilkg洄ilkm党团员illg小轿车ilp涟ilpn治国安民ilpy涟,沉默寡言ilr渐ilrh渐iluh汽车站ilw泅ilwy泅ilx漯ilxi漯ilyh深思熟虑ilyj添加剂ilyo渐变ilyr流连忘返im没,洞,油ima澧imaf沿革imau澧imbb小册子imc没imcw测验,尚难imcy没imd湍,泱imde没有imdj湍imdx沿袭imdy泱ime滑imeg滑,尚且imet沿用imfc滑动imfh滑坡imfi尚未imfj油井imfq尚无imfv滑雪img油,溅imga敞开imgi游山玩水imgk洞,没事imgm海峡两岸imgt溅imh汕imia沿江imif油污imit沿海imj测imjg测量imjh测imk沿,尚,敞imkf尚imkg沿imkh测距,沿路imkn氅imkt敞imlg敞车imll油田imlp沿边imlw油轮immd沿岸imnf油层imnh没收imnt尚属,汕尾imol油烟imou油料impf没完impg测定imqh党内外,海内外,省内外imqn少见多怪imrn油气imrp测控imrq活见鬼imsk尚可imsu滑梯imtd滑稽imtf滑行,沿街imth测算imud滑翔,汕头,沿着imug常见病imui滑冰imw涔imwi兴风作浪imwn涔imwt沿途imww油价imxg沿线,海岸线imxw测绘imya测试imyg测评imyj漫山遍野imyl油库in沁,泥,漏ina泯inad汛期,洗心革面inan泯inb澉,潺inbb潺inbt澉inby光怪陆离indy深情厚谊inf汛inff泥土infh汛infy漏,泥坑ing渥inge学以致用ingf渥,潜心于ingy学习班inh湄inhg湄inii漏水,泥沙inim漏洞inip泥泞injn漏电inlf泼墨inm涮inmj涮inmq漏网inn汜inng汛情innh赏心悦目innn小心翼翼inr汤,烫inrb漏报inrn漏气inro烫inrt汤int泌,泼intb深居简出intt泌intu漏税inty泼inub泥塑inug泼辣inuq泥浆inw濯inwy濯inx泥inxn泥iny沁io淡,瀵ioah淡雅ioai淡薄iofn水火无情iogp水火不相容ioia淡漠ioii淡水iol瀵iolw瀵ioo淡iooy淡iore没精打采iotb淡季ioww少数人iowx淡化ioyn淡忘ip学,常,觉ipa黉ipad学期ipaq省军区ipav深切ipaw黉ipb学ipbf学ipbj沈阳ipbm演出ipbp学院ipbt沉降ipcy常驻ipde浓郁ipdf溜之大吉ipdg深感ipdj浓厚,深厚ipdl学历ipdw演奏ipdy常态ipe浓ipep深受ipet常用ipey浓ipf尝,淙,浣ipfc尝ipfg学士ipfi淙,演示ipfk深圳ipfn掌声,当之无愧ipfq浣,深远ipft学者ipfw常规ipg演,泻,淀ipge常青ipgg泻,渲ipgh淀,党政ipgk常事ipgw演ipht沉睡ipi泶ipia浑江ipie沉浮ipig深浅ipij常温,浑浊ipim沉没ipip沉淀,深沉,光宗耀祖ipir党派ipis沉渣ipit深海,深渊ipiu泶ipiv沉浸,渲染ipiy溶液ipj渖,溟ipje兴安盟ipjh渖ipju溟ipk党,掌,赏ipke裳ipkf堂ipkh常ipkj演唱ipkm赏,党员,演员ipkq党,党史ipkr掌ipks棠ipl浑iplf沉默,党团iplh浑ipln沉思iplt洞察力iplw学界iply赏罚ipm沉ipmn沉ipmq觉,常见,党风ipmw党内ipn涫ipnf深层ipng觉悟,深情ipnn涫ipnt党性ipnu学习,演习ipog学业ipov常数ippn浓密ippw觉察,深邃ipq沈,鲎ipqe溶解ipqg鲎ipqh党外ipqn沈ipr滨iprh常年iprm学制iprn掌握iprv深挚iprw滨ips泞ipsc掌权ipsg沉醉,觉醒ipsh泞ipsu学校ipsy学术ipt喾iptd党籍,深知ipte掌舵iptf学徒,常德iptg沉重,学生ipth深处iptj觉得iptk喾,沉积iptl常备,常务iptm浑身,深奥iptp掌管iptu学科iptv常委,党委ipty深入ipu滓ipuc沉痛ipud沉着ipuh滓ipuj党章ipuk学部,学问ipun沉闷ipvb学好ipw深,溶ipwf学会ipwg溶合ipwk溶ipws深ipwt常任ipwu学位ipww当家人ipwx溶化,深化ipwy深信ipx沱ipxa演练ipxc演绎ipxe党组ipxj学费ipxn沱,党纪ipxp浓缩ipya尝试,浓度,深度ipyf演讲ipyk常识,赏识ipym常设ipyn深刻ipyo演变ipyq演义ipyt常州,党旗ipyu演说iq光,兆,逃iqae涣散,逃散iqap光荣iqaw满负荷iqay光芒iqb光,汹iqbe光阴iqbh汹iqc沟iqce沟通iqcw逃难iqcy沟iqd淆,澹,浠iqdb光顾iqdd光大iqde淆iqdf逃奔iqdh浠iqdt油然而生iqdy澹iqes光彩iqeu逃脱iqf鼗iqfc鼗iqfh逃走iqfn渔场,游乐场iqg淦,渔iqgc逃到iqgg渔iqgr浩然正气iqgw浑然一体iqhp沟壑iqhv耀眼iqi泺iqia沟渠iqic光泽,汹涌iqid淘汰iqif光洁iqig泡沫iqim光滑iqip光学iqiq光辉iqiy泺iqj洵iqje光明iqjg洵iqjm辉映iqjn光电iqjt光临iqjv光照iqjy光景,泡影iqk浼iqkh逃跑iqkq浼iqlp漠然置之iqlw渔轮iqm涣iqmd涣iqn泡,耀iqna渔民iqnk逃避iqnn泡iqny耀iqog渔业iqor辉煌iqp逃,辉iqpl辉iqpv逃iqpw逃窜iqqi沽名钓誉iqql沉甸甸iqqq淘金iqqy没多久iqr淘iqrf逃遁iqrg逃兵iqrh光年iqrm淘iqt泖,漪,潴iqtb泖iqte渔船iqtg逃生iqth海外版iqtj潴iqtk漪iqtu逃税iqty逃往iqud兆头iqv兆iqwx光华,尖锐化iqxg光线iqxj光缆iqxt光纤iqy汐,溜iqyb逃离iqyl溜iqyn逃亡iqyp光亮ir泊,派,汽irbm派出ircy派驻ird湃irdd激励irdf湃ire派irey派irfc激动irfh激起irfj激进irfu激增irg泊,浜,湟irgg湟irgq激烈irgw浜irh沂irhk激战iri洙iria浙江irim汽油iriq激光irit满打满算iriy洙,激流irjq激昂irkh派遣irkl派别irlg汽车irn汽irnf激愤irng激情irnn汽irnt激发irpk少年宫irpp少年之家irr浙irrg派兵irrh浙irtd浩气长存irtg派生irti泥牛入海irtx派系irty派往irud派头irwf汇报会irwu泊位irwx激化,法制化iry激iryt激is洒,酒,河isad法西斯isdd河套isdg酒厂isf漂,湮isfg湮isfi漂isfj河堤isfm河南isft当权者isg洒isgc没想到isgf沉醉于isgg酒ish汀,湘ishg湘isib河池isic河滩isid河源isie漂浮isih洒泪isim河沿isip渣滓isis湘潭isit江西省isiw沐浴isiy河流,淋漓,漂流isj潭,渣isjg渣,小标题isjh潭isk河iskg河islf漆黑islk添枝加叶islp河边islu河畔ismd河岸ismm河山isog酒精ispe酒家isr淅isrg酒后isrh淅isrr漂白iss淋,潸,溧isse潸issg湘西issv漤issy淋,溧istq漂移isuo当机立断isut河道isux河北isw漆,淞iswc淞iswf酒会iswi漆isww河谷isy沐,沭isya尖酸刻薄isyh酒店isyp漂亮isyq河底isys河床isyy沭it少,活,省ita洚itah洚itai浩荡,海东itaq省区itaw党务工作itb沲itbj洛阳itbk少先队员itbn沲itbu兴利除弊itbw少先队itby海防itd活,沃,鋈itdd浩大itde少有itdg活itdh浴血奋战itdm海面itdq鋈itds水利厅itdy沃itf洗,浩itfa海域itfc浩劫,活动itfd省城,游行示威itff沃土itfg渊博itfh省直itfj海堤,学先进itfk浩itfm海南itfq洗itgg小循环itgk海事,省事itgn常备不懈itgw流血事件ith省,涎,洎ithd溴ithf省ithg洎ithh海上ithj濞ithp涎iti潲itic海滩itid渊源itie潲itif浩瀚itii海水itij泛滥itik洗澡itin活泼itip海滨itit洗涤itiu海洋itiy海浪,海湾itjf海里,省时itjg少量itk洛itkg洛itkh活跃itkk海口itl劣,洫itlb劣itlg洫itlp海边itlt省力,省略itlw海轮,法律界,潜移默化,学生界itm澳itmd澳,海岸itmg海峡itmq少见itmw省内itn汔itnf泄私愤itnm洗刷itnn汔,港务局,水利局itnt活性,省属,流行性itny省心ito渊,潘,湫itoh渊itol潘itov少数itoy湫itp泛itpl海军itpq当务之急itpy泛,洗礼itqd浩然itqg海鲜,省钱itqh海外,省外itqt少儿itqy海岛itr少itrd海拔itrf劣质itrh少年,洗掉itrt洗手itrv劣势its涤itsg海西itsy涤itt滗itta省长itte小算盘ittf劣等ittl活血ittn滗ittv省委,洁身自好,省科委ittx浩繁itud海关itug流行病ituk水利部itup消息闭塞ituq少将ituy澳门itvv少女itwd省优itwf省会,常委会,党委会,学生会itwn深得人心itwq活像itwt少生优生itww省份itwx水利化itx海itxe省级itxf海疆itxr海绵itxu海itye洗衣ityf活计itym省市ityo劣迹,滥竽充数ityq海底ityt少许ityw省府ityy活该iu洋,滴,滚iub溯iube溯iubf涪陵iubm溢出iuc滚iuce滚iud洋iudh洋iue湔iuej湔iuf泮iufc滚动iuff混凝土iufh泮iufy学前教育iug泣,润,澜iugg润iugi漾,澜iugk滋事iugp海阔天空iuif海商法,激将法iuii泼冷水iuim润滑iuit河北省,湖北省iuiu滚滚,洋溢,滋润iuj漳,潼,涧iujf潼iujg涧iujh漳iuk涪iukf滋味iukg涪iukk海产品,水产品,小商品iult注意力ium滴iumd滴iunn水产局iuog水产业iup滂iupu滋补iupy滂iuta滋长iutg滋生iutx没关系iuud滋养iuuk兴冲冲iuw溢iuwl溢iuwx洋货iux滋,涕iuxe省部级iuxt涕iuxx滋iuyh沉着应战iuyk潜意识iuyt漳州iv当,浸,染ivc溉ivcq溉ivdm当面ivdn当成ivee当月ivf当,津,浔ivfb当地ivfg淄博,泪如雨下ivfh津,当真ivfn当场ivfy浔ivg汝ivgd当天ivh溲ivhc溲ivi渌ivig浸渍iviq浸泡iviu浸润iviv浸染iviy渌ivjf当时ivjj当日ivjq当晚ivk沼,洳ivkg沼,洳ivkh当中ivl淄ivlg淄ivmh津贴ivnn当局ivny当心ivoi浩如烟海ivp浸ivpc浸ivpe当家ivpu当初ivqd当然ivrg当兵ivrh当年ivri洋奴哲学ivrx染指ivs染ivsc当权ivsu染ivte浸透ivtf当选ivtk浸种ivty浸入ivue当前ivut党群关系ivvc当即ivvy小姑娘ivw梁,粱ivwa当代ivwd当做ivwo粱ivws梁ivwt当作ivwy当今ivy涩ivyh涩iw兴,举,誉iwad潜伏期iwai沦落iwan举世iwb沧iwbb小伙子iwbn沧iwbt兴隆iwbw小分队iwcc沧桑iwdl兴奋iwe脊iwef脊iwf举,浍iwfc浍,举动iwfh举,兴起,兴趣iwg洽,渝,澄iwga瀹iwgc兴致iwgj渝iwgk洽iwgt潋iwgu澄iwgx深信不疑iwgy当仁不让iwhh举目,举止iwig澄清iwip兴学iwis淮河iwit沧海iwiv脊梁iwjg兴旺iwlg举国iwlw举办iwme脊髓iwne沁人心脾iwo濮iwou涂料iwoy濮iwpe小便宜iwq滏iwqu滏iwrb举报iwrg涂抹iwsg举杯iwsw脊椎iwsy脊柱iwt涂,溆iwtc溆,没什么iwtf举行iwtg举重iwtr混合物iwtt渔人得利iwty涂iwu兴iwum洽商iwux淮北,脊背iwv汾,湓iwvf兴建iwvl湓iwvn汾iww浴iwwg举例iwwh兴修iwwk浴iwx沦iwxn沦iwy淮,雀,泠iwyc泠iwyf雀,誉iwyg淮iwyk兴衰iwyl沦为,誉为iwyn兴亡iwyo洽谈iwyt沧州ix涨,沸,溺ixc泓ixcy泓ixep溺爱ixeu沸腾ixft消费者ixfy潍坊ixga流线型ixj沸ixjg消费量ixjh沸ixkk消费品ixmh涨幅ixt涨ixtv省纪委ixty涨ixu溺ixuu溺ixw潍ixww涨价ixwy潍ixxk党组织iy注,流,游iya渡iyac渡iyag游弋iyai流落iyaq省市区iyaw浪花iyb淳,漓iybb游子iybc漓iybg淳iyc流,澈,鎏iyca游戏iyce流通iycq流,鎏iyct澈iydg流感iydl游历iyeg兴高采烈iyfa流域iyfc流动iyfh深谋远虑iyfk流露iyfm济南iyfp渡过iyfr水文地质iyg注iygf游玩,流于iygg注iygk流速iygx流毒iyh汴iyhh注目iyhy汴iyid浪涛iyif浪潮iyih流泪iyii流水,流淌iyij浪漫iyin淤泥iyir流派iyiy流浪,游泳iyj济,浏iyje注明iyjg流量iyjh浏,济,流畅iyjt游览iyke洋为中用iykk渡口iyl沩,澶iylf游园iylg澶iylw渡轮iyly沩iym沆iymm注册iymn沆iyn沪,泳,漉iyna小市民iyni泳iynt沪iynx漉iyny瀛iyo湾,滦iyoo淬火iyos滦iyox湾iyp濠iype濠iypt游客iypw流窜iypy注视,少讲空话iyqa温文尔雅iyqe注解iyqi游乐,注销iyqt游逛iyqw少说多做iyre海底捞月iyrq水文气象iyrr流逝,流离失所iyrw流失iysh淳朴iyt洲,浒,漩iytb游iyte渡船iytf浒,流行,游行iytg注重iyth洲,漩iytj流利iytk流程iytl流血iytm流向,注射iyto注释iytr游牧iyty流入,污言秽语iyu濂iyud浪头iyuj注意iyuo濂iyut流产iyv浪,溏iyve浪iyvk溏iyw液,淬,淤iywf淬,流传,洽谈会,演讲会iyws流体,液体iywu淤iyww游人iywx液化iywy液iyx泫iyxj浪费iyxy泫iyy汶iyyg氵iyyn流氓,流亡iyyt流放iyyu游说j是,日,最ja虹,晓,暴jad蜞,蟒jada蟒jadg星期三jadw蜞jaf蚶jafg蚶,暴雨,星期二jafk暴露jag虹,螨jagd星期天jagf归功于jagg昙花一现,星期五,星期一jagw螨jah蚜jaht蚜jaiv蜡染jaix暴涨jaj蜡,蟆jajd蟆jajg蜡jajj星期日jak蜮jakg蜮jakh暴跌jal蠛jalh星期四jalt蠛,暴力jam蟥jamw蟥jan蝶jans蝶jant暴发jaoj蜡烛jap蠓,蝾jape蠓japs蝾jat晓,蛲jatd暴乱jatf暴徒,暴行jatq晓,蛲jauq日工资jauy星期六jaw暴,蠖jawc蠖jawi暴jb最,蜢jbc最jbcu最jbdd最大jbfg最坏jbih最小jbit最少jbjg时隐时现jbjh最早jbjj早出晚归jbl蜢jblg蜢jbnn最快jbny最迟jbpu最初jbqq最多jbrg最后jbrp最近jbtf最先jbus最新jbwf最佳jbwq最低jbxt最终jbym最高jbys临阵磨枪jc紧,竖,肾jcdg坚硬jce肾,蛹jcef肾jceh蛹jcf坚,蛏jcfb畅通无阻jcff坚jcfg蛏jcfh竖起jcfn坚韧jcft遇难者jcg蚂jcgj贤惠jcgk紧逼jchm坚贞jcjc紧紧jcje贤明jckh紧跟jcld坚固jcm贤jcmu贤jcpf坚守jcpg坚定jcpn紧密jcpu坚实jcql里通外国jcqv紧急jcr蛑jcrf坚持jcrh蛑jcrm紧缺jcrn紧握jcrp紧迫jcrt坚挺jcsv紧要jctf紧靠,贤德jcu竖jcue坚毅jcuf竖jcun坚决jcuu竖立jcwi紧俏jcwy坚信,紧邻jcx紧jcxi紧jcxk坚强jcxp紧缩jcxt紧张jcyv贤良jd晨,蚌,昃jdaf是非功过jdd蛎jddn蛎jde蝴jdeg蝴jdf晨,蝰jdfe晨jdff蝰jdfw蚌埠jdg蛄jdh蚌jdhh蚌jdjm显而易见jdju晨曦jdmf是非曲直jdn晟jdnt晟jdr螈jdri螈jdw昃,蝽,螓jdwj蝽jdwt螓jdwu昃je明,盟,暖jeb蜉jebg蜉jebn明了jedc盟友jedq明确jeee明月jef暖jefc暖jeg明,蛆jegd明天jegg蛆jegr明珠jeiy暖流jeje明明jejf暧昧jejj明日jejo明显jejq明晚jejt明星jeju明暗jekk日用品jekm盟员jel盟jelf盟jelg盟国jenn明快jeoo明火jeos明灯jep暧jepc暧jepl盟军jequ明镜jerh明年jern暖气jerr明白jetd明智jeth明处jetk暖和jevn明媚jexq盟约jeyn暖房jeyp明亮jeyu明说jeyv明朗jeyy明文jf时,里,野jfab时节jfad时期,暑期jfap野营jfbg时隔jfbv时限jfc野,墅,昙jfcb野jfcf墅jfcu昙jfd里,蠕jfde时髦jfdj蠕jfdm里面,时而jff蛙jffc时运jffg蛙jffk暴露无遗jfft时过境迁jfga里弄jfge晴雨表jfgj显赫一时jfgk时事,时速jfgr坚韧不拔jfh旰jfhk野战jfi昧jfim时尚jfip时常jfiq时光jfiy昧jfj旱jfjf时时,暗地里jfjj时日jfk蟛jfke蟛jflp里边jfm蝻jfmf蝻jfng旱情jfnn时局jfny野心jfpe时宜jfpo旱灾jfpw时空jfqf时针jfqh里外,野外jfqk时钟jfrv时势jfsm时机,电动机jft暑jftd时逢jftg野生jftj暑jftk里程jfud里头jfuf时装jfuj时间jful野兽jfuq时效jfve量才录用jfw蚨jfwa时代jfwf时值jfwh时候jfwn暑假jfwv时分jfwy蚨jfy时jfyn时刻jfyo野蛮jg量,题,师jgai师范jgbb量子jgbd师承jgbp师院jgc蛭jgcf蛭jgd昊jgdj是非jgdn旺盛jgdu昊jge晴,蜻,晡jgeg晴,蜻jgey晡jgf旦jgfl时来运转jgg旺jggd晴天jggg时不再来jggi是否jgh是,韪,虾jghh韪,题目jghm题jghu是jghx匙jghy虾jgj量,蟪jgjf量jgjg是不是jgjn蟪jgk晤,蝠jgkg晤jgkl蝠jglf师团jglg最惠国jgm师,螬jgmh师jgmj螬jgpb题字jgpg题写jgpw晴空jgqk题名jgqt旦夕jgrn监理所jgsf题材jgsr坚不可摧jgtb旺季jgtf师徒jgtg师生jgtt时不我待jgu蛱jguw蛱jgwg师傅jgwj时至今日jgyl题为jgyn题词jgyo量变jgyv晴朗jgyx贤妻良母jh早,虫,冒jhad早期jhbw冒险jhce畅通jhdw早春jhf冒jhfg冒雨jhfj冒进jhgn坚贞不屈jhh刂,蠼jhhc蠼jhhh早上jhhq早餐jhid冒尖jhiy畅游jhjd早晨jhje申明jhjw早些时候jhk申jhkm监督员jhl勖jhln勖jhlw申办jhn早,曰,畅jhng曰jhnh早jhnn畅快,早已jhnr畅jhny虫jhpd虫害jhpo虫灾jhpq申冤jhqi畅销jhqn畅饮jhrb申报jhrh早年jhsh畅想jhsy申述jhte早稻jhtf早先jhth冒牌jhud冒着jhuh监督站jhuy申辩jhve早退jhvq早婚jhwt畅叙jhxe明目张胆jhyb早熟jhyc冒充jhyg申请jhyo畅谈jhyr申诉ji晃,晁,蛸jiai晃荡jie蛸jieg蛸jifc晃动jip螳jipf螳jiq晃jiqb晃,晁jirf临渴掘井jiwn旱涝保收jj昌,晶,曝jja曝jjaa临时工jjad日期jjai曝,日落jjap晶莹jjar愚昧落后jjbb日子,紧日子jjbm日出jjbp电影院jjdd是是非非jjdn昌盛jjee日月jjet日用jjf昌jjfh日趋jjfj日刊jjfk昌吉jjfn日志jjfq日均jjft愚昧无知jjg蛳jjgc日臻jjgh蛳,日下jjhh星星点点jjil日渐jjip日常jjiq曝光,日光jjj晶jjjf晶jjjj日jjjv日照jjkh日中jjku蚂蚁啃骨头jjlw电影界jjmq日见jjmw日内jjnt临时性jjpo星星之火jjq蝎,蜴jjqn蝎jjqq里里外外jjqr蜴jjrb日报jjrg日后jjrq旷日持久jjrr明明白白jjs蜾jjsg日本jjsy蜾jjtk日程jjuj日间jjut日产jjuw日益jjwb日创jjwl临时代办jjws晶体jjwx日化jjym昆明市jjyn日记jjyw日夜jjyy日方,时时刻刻jk蝇,蜗,蜈jkg蜈jkgd蜈jkj蝇jkjn蝇jklt影响力jkm蜗jkmw蜗jl曙,曼,螺jlc曼jlcu曼jldt量力而行jldy量力而为jlf蛊jlfj曙jlg蝈jlgy蝈jliq曙光jlk蛔jlkg蛔jlmq电力网jlnn电力局jlsd星罗棋布jlx螺jlxi螺jlyl是因为jm遇,帅,映jma蛐jmag蛐jmbm映出jmbw遇险jmcw遇难jmd映jmdw愚蠢jmdy映jmeg贤内助jmf蚺,蜩jmfg蚺,暴风雨jmfi遇救jmfk蜩jmfv暴风雪jmg蚰jmga愚弄jmgc遇到jmgk遇事jmgm遇刺jmh帅,愚,禺jmhh帅jmhn愚jmhp遇jmhy禺jmjf愚昧jmjv映照jmmq遇见jmn虮jmpd遇害jmpu映衬jmq蚬jmqn蚬jmrn帅气jmtm映射jmts愚笨jmw蚋jmwy蚋jmyn电风扇jn电,昵,虬jnaa电工jnbb电子jnce电能jnck电台jndd电大jndf电压jndg电厂jndp早已有之jndu电磁jndy晓以大义jney电脑jnfc电动jnff野心勃勃jnge电表jngt愚民政策jnh暇jnhc暇jnib电池jnid电源jnih电波jniq电光jniy电流jnjg电量jnjn时快时慢jnjy电影jnkh电路jnkk电器jnlg电车jnlk电贺jnlt电力jnmq电网jnn虬jnoy电炉jnp遢jnpd遢jnpe野心家jnpy电视jnqe电解jnrb电报jnrn电气jnrv电热jnse电极jnsm电机jnsu电梯jntf电告jnub电疗jnuh电站jnv电jnw曜jnwf电传jnwy曜,电信jnx昵jnxg电线jnxj电缆jnxn昵jnxy日以继夜jnyn电扇,电讯,暴发户jnyt电话jnyy电文jo显,炅,蝼joaf显著jobm显出jofi显示jofk显露jofo显赫jog显jogf显jogm显现johv显眼jojo易燃易爆jojx时断时续jonn电业局joqd显然jorw明火执仗josv显要jotj显得jou炅jov蝼jovg蝼jp晕,蛇,晖jpck电视台jpcm时空观jpg暄jpgg暄jpgt坚定不移jphu电视频道jpj螟,暝jpjt蜿蜒jpju暝,螟jpjy明察暗访jpkm监察员jpl晕jplh晖jplj晕jpnd电视剧jpng晓之以理jpnn监察局jpnt坚定性jpq蜿jpqb蜿jpsm电视机jpth电视片jptu监守自盗jpuk监察部jpv晏jpvf晏jpwf鉴定会jpx蛇jpxn蛇jq晚,易,歇jqab晚节jqad晚期jqar昭然若揭jqb昂jqbj昂jqbm剔出jqbw剔除jqd蟾jqdj晚辈jqdy蟾jqet易用jqfb易地jqfn晚霞jqgf易于jqgh照猫画虎jqgn临危不惧jqgt日久天长jqhh晚上jqhk晚点jqip易学jqj蟓jqje蟓jqk晚,冕,煦jqkh昂贵jqkk畅销品jqko煦jqkq晚,冕jqmn日久见人心jqna易懂jqnn畅销书jqoq易燃jqqn晚饭jqr易,剔jqrb晚报jqrh晚年jqrj剔jqrm遏制jqrr易jqsf冒名顶替jqt昴jqtb昴jqte晚稻jqth歇息jqu昀jqug昀jquj晚间jqvq晚婚jqw歇,遏,曷jqwf晚会jqwn曷jqwp遏jqww歇,易人jqwx畅销货jqyc晚育jr蝗,蛛,昕jrct最后通牒jrdg蜂拥而来,紧迫感jrg蝗,蚯jrge日报表jrgg蝗,蚯jrh昕jri蛛jriy蛛jrnt紧迫性jrrk电报挂号jrt蜱jrtf蜱jrud紧接着jrww监护人jrwx电气化jrwy畅所欲言js果,颗,晒jsd颗jsdm颗jsf螵jsfh果真jsfi螵jsg晒jsgy归根到底jsi果jsit果洛jsjt明枪暗箭jsk蚵jskg蚵jslf果园jsnb果敢json果断jsou颗粒jspt照本宣科jspu果实jsq夥jsqd果然jsqq夥jsr晰,蜥jsrh晰,蜥jssc果树jsu杲jswl显要位置jsxy归根结底jt昨,星,临jtad星期jtbf星际jtd蜂,蜘,蛞jtdg蛞jtdh蜂jtdk蜘jtdq明知故犯jtdr里程碑jtel日积月累jtf蚝,蜓jtfb畅行无阻jtfc星云jtfh临走jtfn蚝jtfp蜓jtg星,戥,曛jtga戥jtgd昨天jtge日程表jtgf星,鉴于,星球,归咎于jtgj监理jtgo曛jth昨,蚱,蜒jthf昨,蚱jthi监督jthk晷,临战jthn螅jthp蜒jtim监测jtip鉴赏jtiq星光jtj蜊,蝮jtjf临时jtjh蜊jtjj昨日jtjq昨晚jtjt蝮,星星jtkl鉴别,临别jtkr监听jtlw临界jtm晌jtmk晌jtn虼jtnn虼jto蟋,蟠jtol蟠jton蟋jtoo星火jtpg鉴定jtpw监察,星空jtpy监视jtqd临危jtqf景德镇jtqt监狱jtr蛾jtrm监制jtrp监控,临近jtrt蛾,显身手jtry监护jtsr最重要的jtss监禁jttf临行jttp监管jttx星系jtu蝌jtuf蝌jtul星移斗转jtws星体jtwt晚秋作物jtx晦jtxt临终jtxu晦jty临,鉴,览jtyb量入为出jtyj临jtyl监jtyq鉴,览jtys临床jtyw昨夜ju暗,蜷,昱juad暗藏jubu蝉联jud蛘,蟮,蜣judb蜷judh蛘judk蟮judn蜣juen日新月异juf昱,蚪jufh蚪jufi暗示jug曦juge时间表jugt曦juio暗淡juj暗,蝉,蟑jujd明辨是非jujf蝉jujg暗,日产量jujh蟑jujr时冷时热juju暗暗juk蜕jukh暗中jukq蜕jult晕头转向junt时间性,时效性jup螃jupy螃juq蛟juqs暗杀juqy蛟jure昂首挺胸jus蝤jusg蝤juth暗处juts电冰箱juuh昂首阔步juwx蜕化juxp蜷缩jv归,照,昭jvb旯jvbw归队jvdb照顾jvfh照直jvfi昭示jvfv昭雪jvg归jvgf归于jvgi归还jvgo归来jvh螋jvhc螋jvhj照旧jvip照常jviq照耀jvje照明jvjy晚婚晚育jvk昭jvkg昭jvkk归口jvko照jvlg归国jvlw照办jvnt归属,照发jvou照料jvpu照实jvpv归案jvri照抄,易如反掌jvrt照搬jvsh照相jvsu照样jvtd坚如磐石jvth照片jvtp照管jvuj照章jvwg照例jvwt归侨jvxf归结jvxm归纳jvyi照应jvyp照亮jw蛤,晔,暌jwc蚣jwcy蚣jwfy电化教育jwg蛤,蝓jwgd暌jwgj蝓jwgk蛤jwgt坚信不移jwhk最低点jwj蚧jwjh蚧jwnn电信局jwop愚公精神jwt蜍jwth明信片jwtm愚公移山jwtp晶体管jwty蜍jwwx紧俏货jwx晔jwxf晔jwy暹,蛉,晗jwyc蛉jwyk晗jwyp暹jx昆,曳,蚴jxe曳jxgn坚强不屈jxh蚓jxhh蚓jxje昆明jxjh昆虫jxl蚴jxln蚴jxwx昆仑jxx昆,蚍jxxb昆jxxn蚍jxyl归结为jy景,影,晾jyaa旷工jyb暾,螭jybb影子jybc螭jybp影院jybt暾jycm景观jyg蛀jygc景致jygg蛀jyhc景颇jyhk景点,最高点jyi景,颢jyib最高法院jyie影jyim颢jyiu景jyiy晾jyj蛴jyjf旷野jyjh蛴jyk曩jykd电话号码jyke曩jykt影响jymq电话网jymt最高峰jyn虻,蝙jyna蝙,影展jynn虻,电话局,申请书jypy影视jyq蚁jyqc景色jyqg影印jyqj景象jyqw里应外合jyqy蚁jyrn景气jysm电话机jyt旷,蝣jytb蝣jyth影片jytr景物jyu蠊jyuk景况jyuo蠊jyuq最高奖jyur野蛮装卸jyv螂,螗jyvb螂jyvk螗jywq景仰,影像jyww申请人jyx蟀jyxe最高级jyxf蟀jyy蚊jyyj旷课k中,口,只ka呀,哎,哄kaah咬牙切齿kaax中医药kad嘶,喏kada吃苦耐劳kadk喏kadq哈萨克kadr嘶kaei口若悬河kaf嘞kafl嘞kag哐kagg哐kagr叫苦不迭kah呀kaht呀kaik中共党员kaj噶kajn噶kajs叶落归根kakf呕吐kakm中共中央kakv唠叨kal喵kalg喵,叫苦连天kam咂kamh咂kan呓,喋kann呓kans喋kap唠kapl唠kaq哎,呕kaqy哎,呕karr顺藤摸瓜kat哓katq哓,顺其自然,听其自然kaw哄,嗒,嗬kawf哄传kawk嗒,嗬kawy哄kaxn跨世纪kay嚆kayk嚆kb啊,吼,叩kbc嗫kbcc嗫kbgf只限于kbh叩,嗤kbhj嗤kbm咄kbmh咄kbn吼,戢kbnf别出心裁kbnn吼kbnt戢kbqy口出狂言kbs啊kbsk啊kbuk中联部kbym贵阳市kc吧,吗,唉kcb邑kcbb嗓子kcc嗓,啜kccc啜kccs嗓kce嗵kceb叹服kcep嗵kcg吗kcga患难与共kcgr串通一气kciu啜泣kcke吮吸kcn吧kcpu患难之交kcq吮kcqn吮kcr哞kcrh哞kcrn叹气kct唉kctd唉kcth叹息kcw唆kcwg唆使kcwt唆kcy叹kd顺,喊,嘎kdb呃kdbg顺耳kdbn呃kden别有用心kdf喹kdff喹kdg咕kdgt喊kdgu听而不闻kdh嘎,嘁,嗄kdha嘎kdht嘁,嗄kdiv顺当kdj啡,喱kdjd啡kdjf喱kdjh顺畅kdkh顺路kdkk顺口kdkn喊叫kdl呖kdln呖kdm顺kdmk别有风味kdmq顺风kdmy顺kdny顺心kdo咴kdoy咴kdp哒kdpy哒kdqq吃大锅饭kdrt顺手kdrv顺势kdth顺延kdtj顺利kdtv中顾委kdu噘,嘹kdui嘹kduq顺次kduw噘kdw唪,嗪kdwg顺便kdwh唪kdwt嗪kdww顺从kdx咙kdxn咙kdxu吐故纳新kdy吠,呔kdyc顺序kdyi顺应kdyp嘹亮kdyy呔ke吸,嚼,啄kebc吸取kebw吸附keg咀kegg咀kegx吸毒keiy口服液kel嚼kelf嚼kene口服心服kenh吸收keol吸烟kep嗳kepc嗳keq鹃keqg鹃kexh吸引key吸keyy吸,啄kf叶,吐,味kfa喷kfai鄙薄kfam喷kfaq跨地区kfbk别无出路kfbm喷出kfc吱,嗑kfcl嗑kfcy吱kfd嚅kfdj嚅kff哇kffg哇kffk吐露kfft喷雾kfg吐kfga嘲弄kfh叶,嗔kfhw嗔kfi味kfia喷灌kfis喷漆,喷洒kfit中南海kfiy味kfj嘲kfje嘲kfk嘻,嘭,咭kfke嘭kfkg咭kfkh喷嘴kfkk嘻kfkr唉声叹气kfl鄙kflb鄙kfm喃kfmf喃kfnt喷发kfo哧kfoo喷火kfoy哧kfp噎,嚏,嗦kfph嚏kfpi嗦kfpu噎kfpy鄙视kfq呒kfqn呒kfrf别无所求kfrh中老年kfri喷泉kfrw中老年人kfsg吃老本kft哮,嘟,嗜kftb嘟,哮kftj嗜kftm喷射kftr别无选择kftt嘲笑kfut味道kfuw史无前例kfvb嗜好kfw呋,嚯kfwi别无他法kfwy嚯,呋kfym嘲讽kg呈,号,吨kgb吨,郢kgbh郢kgbn吨kgbp忠于职守kgbw足球队kgd吴kgdc号码kgdu吴,顺理成章kge哺kgeb哺乳kgey哺kgf呈,吁kgfh吁kgfj听不进kgfn足球场kgfp只不过kgga吃不开kggm呈现kgh吓kghy吓kgi呸kgig呸kgii吃不消kgiy中下游kgj哽kgjq哽kgk喇,嗝,嗽kgke囔kgkg唔kgkh嗝kgkj喇kgkw嗽,喇叭kgky喇嘛kgm啧,嘈kgmj嘈kgmw听天由命kgmy啧kgn号,饕kgnb号kgne饕kgo哑kgog哑kgp逞kgpd逞kgpf足球赛kgq咧,嗷kgqj咧,中下旬kgqt嗷kgrb呈报kgrh中青年kgrk路不拾遗kgt唛kgtd别开生面kgtk另一种kgtq号称kgty唛kgud哺养kgux呈递kgvk号召kgvs嘈杂kgwg吓倒,吓不倒kgwu吨位kgwy号令kgx咦,嗉kgxi嗉kgxw咦kgyc哺育kgyd另一方面kgyg吁请kh中,跟,跳kha距,跷,蹒khaa中式khad路基,中期khae噱,遣散khag嘘khai跌落,中东khaj躇khal中苏kham唬,中英khan距,别具匠心khaq跷,中欧,跨区khas蹀khat中医khaw蹒khax中药khay躏khb蹑khbb路子khbc蹑khbd跟随khbj贵阳khbu路障khbw中队khc踊,跆,蹂khce踊khck跆khcn跑马,嘴巴khcs蹂khd跨,踌,蹰khdc跋khdf蹰,踌khdg跖khdj忠厚khdm路面khdn跨khdr遗愿,中原khdw蹶khe啃,踩,蹈khed蹊kheg啃khes踩khet中用khev蹈khey趿khf趺,跬khfc跳动khff跬,足坛khfg中雨khfh跨越,遗址,跃起,中直khfj跃进,跳进khfm中南khfn遗志,中专khfp跨过,路过khfw趺khg践,贵,遗khga趼,中型khgc跌到khgf忠于,足球,踢皮球khgh中下khgi忠贞不渝khgm贵khgo中亚khgp遗,遣khgq忠烈khgs别具一格khgt践khgu踏平khgx中毒khgy跟班khh趾,跛,踔khhc跛khhe中肯khhg趾khhh路上,中止khhi跑步,踏步khhj踔khhk蹲点khhm忠贞khhy咔khi跳,踏khih跋涉khij踏khin遗漏khip中学khiq跳khit跨海,跨省khiy中游,中上游khj踢,蹋,踝khjc中坚khjj中日khjn蹋khjr踢khjs踝khjy踪影khk中,躁khkf中叶khkh踌躇,蹉跎,跟踪,践踏,蹒跚,蹊跷,蹂躏,跳跃,踊跃khkk路口khkn遗嘱khks躁khl盅,躅,跏khlf盅,中转khlg贵国,跨国,中国khlj躅khlk跏khlp路边khm跺,蹦,跚khmd中央khme蹦khmg跚khmj踹khmm中山khmq足见khms跺khn忠,踞,跽khnd踞,遗憾,跃居khnf中层,中上层khnn跽,路局khnt中性khnu忠khny中心,忠心,足以kho蹼,躞khoc躞khon中断khos路灯khoy蹼khp踪,蹿,跎khph蹿khpi踪khpr贵宾khpu踏实,忠实khpx跎khq跑,跪,趵khqb跪khqh中外khqi跞khqj中旬khqk足够khqn跑khqy趵,遗留khr跌,踬khrc遣返khrh中年khrl跳舞khrm踬khrw跌,遗失khrx中指khsa中枢khsf路标,中标khsg中西khsi中档khsr踏板,跳板kht路,跃,踵khtd跃khte中盘khtf踵,中等,忠告,中午,中选khtg鹭,贵重khtk路,踟,路程,中和khtl蹯khtm躜khtp跹khtq跣,别具特色khty踽,跳入khu足,蹲,蹭khua蹉khub踯khud遣送khue跟前khuf蹲khug中美khuh蹄khuj蹭,中间,中意khuk踣,中部khup路旁khuq跤,中奖khut跑道,遗产khuu中立khv跟,躐,踺khve跟khvn躐khvp踺khw趴,蹬,跗khwb跄,啮khwd路段khwf跗,遗传khwj中介khwt路途,中途khwu蹬khww跌价khwx中华khwy趴,距今khx嘴,跸,呲khxe嘴,中级khxf跸khxg路线khxj路费khxn呲khxo中继khy卟,踱,踮khya蹁,跨度khyb距离khyc踱,遗弃khyd忠诚khye踉khyf躔khyj跻khyk踮khyn蹴,跑遍,遗忘khyo遗迹,踪迹,足迹khyt贵州,贵族khyv忠良khyy遗言,中方,中文ki吵,嗨,啵kidg顺流而下kidq鄂温克kids中流砥柱kidt哄堂大笑kie哨kieg哨kifj中学教师kify中小城市kiga中小型kigt川流不息kih啵kihc啵kiin跳梁小丑kiip中小学kiis中小学校kiit中小学生kiiv响当当kiky吵嚷kilk吵架kim唢kimy唢kiq咣kiqn咣kirn哨所kirt顺水推舟kit吵kitg中学生kitt吵kitu嗨,跨学科kiuw品学兼优kiuy吵闹kiwo中小企业kj虽,唱,喝kjb嘬kjbc嘬kjca唱戏kjep唱腔kjes喝彩kjf哩kjfg哩kjh呻kjhh呻kjj唱kjjg唱kjm喁kjmj虽则kjmy喁kjn黾kjnb黾kjnd口是心非kjq喝kjqd虽然kjqn喝kjsk唱歌kjth唱片kju虽kjyu虽说kk吕,哭,骂kkbb口子kkbu串联kkc骂kkce串通kkcf骂kkcw患难kkd器,嚣kkde患有kkdk器,嚣kkdu哭kkeb口服kkep口腔kkf吕,鹗,颚kkfb鄂kkff口口声声kkfg鹗kkfm颚kkfn哭声kkft患者,口才kkfy哑口无言kkgq吃喝玩乐kkgu踌躇不前kkgw喋喋不休,咄咄逼人kkh串,患kkhk串kkhn患kkhw口齿,器具kkif踌躇满志kkip品尝kkiu哭泣kkiv吕梁kkk品,噪kkkd哭喊kkkf品,口味,品味kkkg口号kkkh口中kkkk口,咒骂,嘻嘻哈哈kkkn哭叫kkkq口吻kkks噪kkl鼍kkln鼍kkm咒kkmb咒kkmd口岸kkme蹉跎岁月kkmf叱咤风云kkmq吃喝风kkmw口内kkng咄咄怪事kknn呼吁书kkoy口粮kkpn器官kkpp踏踏实实kkpu口实kkqi器乐kkqk品名kkre口授kkrf品质kkrn口气kksa器械kksf器材kksg鄂西kkst品格kksy口述kktc口径kktf串行,品德,品行kktg器重kktk品种kktr器物kkud口头kkug患病kkuj口音,噪音kkuy哭闹kkvf咆哮如雷kkwa口袋,口供kkwr器件kkwu品位kkwy口令,口信,跃跃欲试kkxt嚣张kkya口试kkyc口译kkyg口语,品评kkyn口诀kkyr哭诉kkyt鄂州kl另,别,喂klb另klbw中国队kld咽,嗯klde另有kldn嗯kldy咽kle喟kleg喟klf嘿,啭klfo嘿klfy啭klgc别致klge喂klh呷klj别kljh别klk咖klkd咖啡klkg咖klkw咽喉kllg别国kllk另加kln叻klqh另外klrh别看klrj别提klrn别扭,另据klsu别样kltf另选klth别处klud喂养klww别人,中国人klyb别离klyy另议km员,吊,喘kma嗣kmaa员工kmak嗣kmb郧kmbh郧kmbj郧阳kmd喘kmdj喘kme嘣kmee嘣kmf啁kmfk啁kmh吊kmhj吊kmii跋山涉水kmkd呐喊kmky吊唁kml勋kmln勋kmm嘤kmmv嘤kmn叽kmq哕kmqi吊销kmqy哕kms哚kmsy哚kmth喘息kmu员kmuf吊装kmuj勋章kmw呐,剐,呙kmwj剐kmwu呙kmwy呐kmy呗kn叫,呢,叼knad叫苦knau吃尽苦头knbb忠心耿耿knfn叫卖kng叼,喔kngf喔kngg叼knh叫knhh叫knit呕心沥血knk噼knkd叫喊knkk叫嚣knkq叫唤knku噼knkw嘱咐knky叫嚷knm唰knmj唰knqu吸收外资knrt嘱托knt嘱kntg跃居第一knty嘱knuw跃居首位knvb叫好knwd叫做knx呢knxa呢绒knxn呢knxq叫绝kny吣knyw唯心论ko咪,喽,噗kog噗kogy噗koo啖kooy啖kov喽kovg喽koy咪kp喧,嚓,喀kpdy喧宾夺主kpe哝kpew口蜜腹剑kpey哝kpf噻kpff噻kpg喧,啶kpgg喧kpgh啶kpkk喧嚣kpkw喧哗kpky喧嚷kpn嘧kpnm嘧kps咛kpsh咛kpt喀,咤kpta咤kptk喀kpuk中宣部kpuy喧闹kpw嚓kpwf喀什kpwi嚓kpwp听之任之kq史,兄,吹kqb兄kqd唏kqdh唏kqfh唤起kqfq只争朝夕kqg噜kqga吹开kqgj噜kqi史kqip哈尔滨kqiy哈尔滨市kqkh吹嘘kqkk吃饱喝足kqm唤kqmd唤kqmm史册kqmq吹风kqn咆,呜kqng呜kqnn咆kqou史料kqpj吃饱穿暖kqpu史实kqq哆kqqc唱独角戏kqqy哆kqr吻,啕,唿kqrd吹捧kqrh吹牛kqrm啕kqrn唿kqrt吻kqsg唤醒kqsw鸣枪kqta兄长kqux兄弟kqvf兄妹kqw吹kqwg吻合kqwy吹kqxh跃然纸上kqy鸣kqyg鸣kqyt鸣放kr听,啦,啪kra唣kran唣krbc听取krc呱krcy呱krd嗥krdf嗥krdu顺手牵羊kre哌krey哌krgc听到krh听krig听清krip听觉kris啤酒krlt听力krmq听见krr啪,哳krrg啪krrh哳krst唾手可得krt啤krtf啤krtw哄抬物价kru啦krug啦krwg听命krwh听候krwt听凭krww听从,听众,中年人krya跨年度krym唱反调kryt听话kryu听说ks呆,呵,喳ksaw中西医结合ksf嘌ksfi嘌ksg哂ksgm别树一帜ksh叮ksj喳ksjg喳ksk呵kskg呵kskn叮嘱kskp叮咛kss啉,噤kssi噤kssr呆板kssy啉ksu呆kt呼,吃,响kta噬,吒ktad吃苦ktan吒ktaw噬ktbp中科院ktct另行通知ktff响彻云霄ktfi呼救ktfj顺我者昌ktfn吃亏,呼声,响声ktg唾ktgf唾,跻身于ktgt哭笑不得kth咱,川,嗅kthd嗅kthf咋kthg咱kthh川ktip嗅觉ktit呼和浩特ktiy呼和浩特市ktjc吃紧ktjl唯利是图ktk咯ktkd呼喊ktke呼吸ktkg咯,呼吁ktkj吃喝ktkk唾骂ktkn呼叫ktkq呼唤ktkr患得患失ktkv呼啸ktlt吃力ktm响,噢ktmd噢ktmk响ktn吃ktnn吃ktny吃惊kto啾ktog跨行业ktoy啾,吃粮ktpr另行安排ktpw踏入社会ktqn吃饭ktqu唯我独尊ktr哦ktrh吃掉ktrt哦ktte吃透ktu呼,咚ktuh呼ktui唯物辩证法ktuy咚ktwu咱们ktxd啼笑皆非ktyc唾弃ktyg吃请ktyi呼应,响应ktyp响亮ktyw唯物论ktyy唯物主义ku啼,咬,噫kuah咬牙kub嗍kube嗍kud咩,嗟kuda嗟kudh咩kuh吖kuhh吖kuip兄弟党kuir中间派kuiy中美洲kuj喑kujg喑kujn噫kul噌kulj噌kum嘀kumd嘀kup啼kuph啼kupy口头禅kuq咬kuqy咬kute兄弟般kuuy跨部门kuv唼kuvg唼kuw嗌kuwl嗌kuww中间人kuyg口头语kuyk品头论足kv哪,啸,唧kvc呶kvcb唧kvce哪能kvcy呶kve哏kvey哏kvf哪kvfb哪kvh嗖kvhc嗖kvhx哪些kvi啸kvij啸kvjf哪里kvlt号召力kvn叨kvnr哪怕kvqt哪儿kvwh哪个kw只,哈,啥kwad唯其kwb呛kwbn呛kwbp哗众取宠kwbv只限kwc嗡kwce只能kwcn嗡kwdb只顾kwde只有,唯有kwdp哈达kwdw鄂伦春kwet只用kwf咐,哙kwfc哙kwfd只需kwfi只求kwfk啥kwfy咐kwg哈,喻,噔kwgg唯一kwgj喻kwgk哈kwgu噔kwhk只占kwjg只是kwjw唯命是从kwkw吩咐kwld只因kwmj呼伦贝尔盟kwmq只见kwn喉kwnd喉kwnx哈尼kwny唯心kwq嗲kwqd哗然kwqq嗲kwqt唯独kws咻kwsi中低档kwsv只要kwsy咻kwtd喉舌kwtg听候处理kwtj只得kwtm只身kwtp只管kwu只kwv吩,咿kwvb只好kwvd叶公好龙kwvn吩kwvt咿kww唑kwwf唑kwx哗kwxf哗kwy叭,唯,吟kwyc呤,噙kwyg唯kwyn吟kwyo噍,哗变kwyt只许kx哟,吆,叱kxe喙kxey喙kxh吲kxhh吲kxl呦kxln呦kxlt吸引力kxn叱kxq哟kxqy哟kxtv中纪委kxuk中组部kxww吸引人kxx吡,哔,咝kxxf哔kxxg咝kxxn吡kxxr喈kxy吆ky嘛,哼,嚷kyb哼kybh哼kybi唁函kyc唷kyce唷kych叹为观止kyfn吭声kyg唁kyii顺应潮流kyit贵州省kyj哜kyjh哜kyjn唁电kyk嚷kyke嚷kykg咳嗽kykp咬文嚼字kym吭kymn吭kyn咏,咳,唳kynd唳kyni咏kynw咳kyp嚎kype嚎kypu中庸之道kyqe唱主角kyrn吭气kyrr趾高气扬kys嘛kysi中高档kyss嘛kyt嗾kytd嗾kyty只言片语kyv啷kyvb啷kyw啐kywf啐kyym唱高调l国,因,回la轼,羁laa轼laag轼labs斩草除根ladg加工厂laf羁lafc羁lafm黔东南lamu置若罔闻lann轻工局laog加工业,轻工业laou轻工业部lauk轻工部laxu羁绊lb囝,辄lbaa国际劳动节lbd囝lbhh国际上lbic男子汉lbif国际法lbim国际法准则lbn辄lbnn辄lbnt国际性lbuj国际间lbuk国防部lbwx国际化lbyt因陋就简lc轻,轰,辍lca轻lcaa轻工lcag轻,轻巧lcai轻薄lcbc轻取lcbt轰隆lcc轰lccb轻柔lccc辍lccu轰lcec轻盈lcfc轰动lcfm轰击lcft轻者lcga轻型lcie轻浮lcip辍学lcjq轻易lckm驾驶员lckq轰鸣lcmj轻则lcnn轻快lcot轰炸lcpy轻视lcsw轻松lctg轻重lctm轻微lctt困难重重lcuf轻装lcus轻闲lcwd四通八达lcwg轻便lcwi轻佻lcwt轻伤lcwy轻信lcxy轻纺lcyn困难户lcyx轻率ld因,罪,恩ldaw罪孽ldb轭ldbb因子ldbn轭ldd固ldde固有lddm因而lddr固原lddt因故lddy固态lde囿lded囿ldep恩爱ldf罟ldfp罪过ldg轱ldga畸形ldgf加在一起ldgj恩惠ldgm罪责ldgo罪恶ldgs罪大恶极ldgt连成一片ldgx因素ldhx因此ldi因ldia黑龙江ldic恩泽ldii固沙,黑龙江省ldj罪,罨ldjd罪ldji轻而易举ldjn罨ldjs因果ldmj恩赐ldn恩ldng恩情ldnu恩ldpf固守ldpg固定ldqb恩怨ldqd固然ldqk罪名ldqt罪犯ldrq罪魁ldrv固执lds畸ldsk畸ldt畴ldtf畴,恩德,罪行ldud罪状lduy软硬兼施ldw辏ldwd辏ldws固体ldww恩人ldwx国有化ldwy四面八方ldy畎ldyg罪证ldyl因为ldyt罪有应得le胃ledc男朋友lef胃legt略胜一筹lekk胃口lent辅助性leww四月份lf轩,转,黑lfaa罢工lfan园艺lfaq园区lfat围攻lfbc团聚lfc罢,罴lfcm围观lfco罴lfcu罢lfdh默契lfdp转达lff畦lffa转载lffb园地lffc转动,转运lfff黑土,围墙lffg畦lffm黔南lffn转卖lfgf置于lfgh转正lfgj轰动一时lfh轩,置lfhe转瞬lfhf置lfhv转眼lfia连云港,黔江lfju黑暗lfk辕lfke辕lfkk转口lfkm团员lflf默默,团团,轩辕lfli边干边学lflk团圆lfls围困lflw置办lfm罱lfmf罱lfmh转帐lfn转lfnh围lfnt转发lfny转lfo黑,默,黝lfod默,黩lfoe黪lfof墨lfog转业lfoi黥lfoj黯lfok黠lfol黝lfom黜lfon黔lfoq黟lfot黢lfou黑lfq园lfqc黑色lfqk罢免,署名lfqv园lfrd围拢lfrp因地制宜lfrq置换,转换lfrr黑白,转折lfrt转播,转手lfsa围棋lfsg园丁lfsm转机lfsr黑板lfss园林lft团,署lfta团长lfte团lftf转告lftj署lftl置备lftm置身,转身,转向lftq转移lftv团委lfty转入lfu圉lfud转送lfuf圉lfug回过头来lfuk团部,团支部lfuq转交lfut转产lfve围垦lfvj围剿lfvp转嫁lfwo团伙lfws罢休,团体lfww黑人lfwx转化lfwy置信lfxa围绕lfxf团结lfxg国境线lfxt置疑lfxw转给lfye默哀lfyh转让lfyl转为lfym黑市lfyo墨迹,转变,转弯lfyt团旗lfyw黑夜lg车,辆,辅lgap国营lgb囤lgbf国际lgbn囤lgbw车队lgby国防lgc轾lgcf轾lgci罪责难逃lgcw畏难lgde国有lgdn办不成lgds车厢lge畏,圃,圊lged圊lgeg辅助lgeu畏lgey辅,圃lgff国土lgfn车场lgft国都lgfu国境lggc办不到lggg国王lggk车速lggl国画,连环画lgh罡lghc车皮lghf罡lgi罘lgif国法lgiu罘lgiy车流lgj畀lgjj畀lgk辐,圄lgkd圄lgkk轻武器lgkl辐lgkm办事员lgld畏罪lglg车辆lglh加班加点lgln边整边改lglt国力lglw车轮,国界lgm辆lgmw辆,国内lgn车lgna国民lgnf辅导lgng国情lgnh车,畏惧lgnn国书lgpe国家lgpg国宝lgpr国宾lgpy车祸,罪不容诛lgqh国外lgrh男青年lgsf车票lgsk国歌lgst国格lgtd国籍lgte车船lgtg国策lgth办事处lgtk囤积lgtl国务lgtm车身,辐射,国徽lgtt罪恶行径lgue车前lguh车站lguj车间lguq车次lgut国产lgwd国优lgwf国会lgwg国债lgwn力不从心lgwt四平八稳lgww国人lgwx国货lgxj加班费lgxp畏缩lgy国lgyd国庆lgyi国lgyl车库,国库lgys车床lgyt国旗lgyu国事访问lh四,甲,罩lhae四散lhdb四顾lhdd四大lhdm四面lhee四月lhef四肢lhfh四起lhgu四平lhit四海lhj罩lhjj罩lhkt四川lhlp四边lhmf四周lhn皿,轳,囗lhng四,皿,囗lhnh甲lhnt轳lhpd四害lhqe四角lhqh四外lhsr甲板lhtb四季lhtf固步自封lhth四处lhwy四邻lhxe甲级lhyy甲方,四方licd车水马龙lird因小失大liss固沙林litp输油管litx输油管线liyf轻举妄动liyp四海为家lj辊ljdm黑暗面ljx辊ljxx辊lk加,圆,架lkaa加工lkai回荡,回落lkb辑lkbg辑lkbi回函lkc驾lkcc驾驭lkcf驾lkck驾驶lkd回lkdb回顾lkdd加大lkdj加厚lkfc回去lkfk贺喜lkfm回击lkfn回声lkfp回味无穷lkg加lkga圆形lkgc回到lkgk加速lkgo回来lkgy加班lkhj圆桌lkhk加点lkia圆满lkif回潮,加法lkii加水lkij加温lkim加油,圆滑lkip加深lkit四川省lkiu圆润lkjc加紧lkje回暖lkjn贺电,回电lkjv回归lkkf回味lkkt回响lkld加固lklf回转lklg回国lklt加力lkm贺lkmd团中央lkmi圆lkmu贺lkna回民lknh回收lknk回避lknn回忆,加快lkny加以lkoy回炉lkp迦lkpa加宽lkpd迦lkpe回家lkpn加密lkpw架空lkqv加急lkrb回报lkrc回返lkrh贺年lkrk回扣lkrv回执,加热lks架,哿lksh回想lksk哿lkst架桥lksu架lkta回升,加长lktd回笼lktg加重lktj回复lktk回程lktw回答lkty加入lkud回头,加减lkuj回音lkuq架次lkut回首lkvi辑录lkw轵lkwg回合lkwu加倍lkww加价lkwy轵,贺信,回信lkxk加强lkxq回绝lkxt回乡lky袈lkye袈lkym加高,架设lkyn贺词lkyt回话,回旋,回族lkyw因噎废食lkyy回访ll男,田,圜llaa男式llb男llbb男子llbu田联llby男孩llcc男双llfb田地llfu默默无闻llg圜llga四边形llge圜llgg轰轰烈烈,囫囵吞枣lljf田里,田野lll田,勰lllf田园,团团转llll田llln勰llmm男婴llnt男性,逻辑性llqt男儿llrw辗转反侧lltc田径lltg男生lltj男篮llud田头lluj男单,田间llv嬲llvl嬲llvv男女,男男女女llww男人llxg边界线llyy驾轻就熟lm轴,辋lmfn男同志lmg轴lmgg略见一斑lmqh国内外lmu辋lmun辋ln思,轧,辗lna辗lnac思茅lnae辗,软懒散lncw罹难lnfp思索lnft思考lnha思虑lnif思潮lnip国民党lnjg思量lnkh思路lnkm辅导员lnlf辗转lnn轧lnpg图书室lnqm轧钢lnqn图书馆lnsh思想lnsm轧机lnu思lnuh辅导站lnvi回忆录lnw罹lnwy罹,思念lnxf思绪lnxt思乡lnxw思维lnya思谋lnyx回收率lo辚loq辚loqh辚lp边,连,辖lpaq边区,辖区lpbf边际lpbt边陲lpbw连队,国家队lpby边防lpce连通lpdf墨守成规lpdk辖lpet连胜lpfa连载lpfn连声lpfq边远lpfu边境lpgd连天lpgf加害于lpgg连环,置之不理lpgk连带,办实事lpgm连遭lpim边沿lpjj连日lpk连lplp连连lplw边界lplx连累lpmg连同lpny连忙lpq畹lpqb畹lpqi连锁lpqn国宾馆lprh连年lpru连接lpta连长lpty连篇lpuc连闯lpud边关lpv边lpwt连任,国家体委lpxe国家级lpxf边疆,连续,连结lpxg边线lpxr连绵lpxx边缘lpyq置之度外lpyw连夜lq罗,软,鸭lqdi轩然大波lqfq斩钉截铁lqgq罗列lqi轹lqiy轹lqj蜀lqju蜀lqlk逻辑lqp逻lqpi逻lqr囫lqre囫lqrq黯然失色lqu罗lquf软包装lqw软lqwr软件lqwx软化lqwy软lqxu软弱lqy鸭lqyg鸭lqyp转危为安lr斩,暂,轶lrc畈lrce力所能及lrcy畈lreg暂且lret暂用lrf堑lrff堑lrgi暂不lrgk轶事lrh斩lrhk转折点lrip轻描淡写lrj暂lrjf暂,暂时lrnm固执己见lrpg暂定lrpu罪魁祸首lrq錾lrqf錾lrqi力挽狂澜lrrm暂缺lrs椠lrsf软指标lrsu椠lrtf暂行lrtn因势利导lrub轶闻lrvd力挫群雄lrw轶lrwy轶,暂停,暂住,力排众议lrxe暂缓ls困,町,轲lsad困苦,恩格斯lsak困惑lscw困难lsfm黔西南lsfu困境lsh町lsi困lsk轲lskg轲lspf困守lsrd困扰lssf轻飘飘lswu困倦lsyf因材施教lt力,图,略ltbp国务院ltd轿ltde略有ltdj轿ltdq力克ltfc略去ltff田径运动ltfi力求ltga图形ltgc办得到ltge图表ltgf略知一二ltgl图画ltip软科学ltjg力量ltjy图景ltk略,辂ltkg略,辂ltlg轿车ltlk略加ltll罪行累累ltlt力图,略图,连篇累牍ltn力ltnd囤积居奇ltnn图书ltpf田径赛ltpv图案ltqe图解ltqj图象ltqt国务卿ltqv力争ltrn力气ltsu图样lttd略知ltth图片lttm略微ltu图,轷ltuh轷ltui图ltvm恩重如山ltwg图例ltwk力促ltwq图像ltxq图纸,轻重缓急lty畋ltya图谋,四季度ltyg略语lu较,圈,畔lubb圈子lucw较难lud圈ludb圈ludd较大,圈套luf畔lufh畔lufq较远luih较小luit较少luj疃lujc较紧lujf疃lujg较量lujq较易lul罾lulc较轻lulj罾luln畏首畏尾lunn较快lupp较之luq较luqi轻音乐luqq较多luqy较lurp较近luta较长lutd较短lutg较重luud较差luuu圈阅luvb较好luvr男尊女卑luwd较优luwq较低luwr恩将仇报luwx国产化luxk较强luxu较弱luyl较为luym较高lv轨,囡,轫lvbw男女队lvd囡lvfi男女老少lvgt男女平等lvk轺lvkg轺lvl辎lvlg辎lvn轨lvut轨道lvy轫lvyo轨迹lvyy轫lw办,轮,输lwbb轮子lwbm输出lwbv界限lwdd加拿大lwdg办厂lwdm界面lwdn办成lwdr界碑lwds办公厅lwdt四人帮lwe轸,畛lwec轮胎lwet轸,畛lwev办妥lwg输,辁lwgg辁,四分五裂lwgj输,办理lwgk办事lwgy办班,轮班lwhj办公桌lwi囚,办lwif办法lwip办学lwiq输光lwis界河lwiy轮渡,轮流lwj界lwjj界lwjn输电lwpf团体赛lwpg办公室lwpv办案lwqn软件包lwrh输掉lwrq轮换lwso办公楼lwsy界桩lwte轮船lwtl输血,软任务lwto轮番lwty输入lwud输送lwvb办好lwwc办公lwwf团代会lwwt轮作lwx轮,囵lwxg界线lwxj办公费lwxn轮lwxv囵lwy囹lwyc囹lwyk轮训lwyn输赢lwyy轮廓lx累,毗lxbw甲级队lxfj累进lxfw连绵起伏lxgg团结一致lxgo连绵不断lxgq累赘lxgu畏缩不前lxi累lxia鸭绿江lxiu累lxlk累加lxlp毗连lxlx累累lxnt连贯性,连续性lxtk累积lxwy毗邻lxx毗lxxk团组织lxxn毗lxxr软绵绵lxyf累计ly罚,辙,詈lyab国庆节lyc辙lyct辙lyf詈lyff罚款lygf略高于lyj罚lyjj罚,国庆日lyn辘lynt国计民生lynx辘lyqq罚金lyrq转弯抹角lyua图文并茂lyud国库券m同,几,由ma曲,贼,典maaa同甘共苦maah典雅maai典范mad贼,曲madd嵌套madg内蒙古madm见世面madt贼,典故maf嵌mafh曲直mafw嵌maga典型mah岈maht岈mai岽mait山东省maiu岽mams同工同酬mant周期性map崂,嵘mapl崂maps嵘mapy典礼maq岖maqe曲解maqy岖marr曲折matd典籍maty嵌入maug曲靖maw典mawn曲阜mawu典maxg曲线mb邮mbdc邮码mbgh邮政mbgl同出一辙mbh邮mbjn邮电mbkh邮路mbmq邮购mbnn邮局mbpd邮寄mbqn邮包mbqx内联外引mbsf邮票mbuq邮资mbux邮递mbwr邮件mbxj邮费mbxy邮编mc凤,贻,殳mcb岜mcf峄mcfh峄mci凤mcjr风驰电掣mck贻mckg贻mcmi峻峭mcmw峻岭mcsi刚柔相济mcu殳mcw峻mcwt峻mcyk贻误md央,岸,岩mddg岩石mde贿mdeg贿mdf岩,崖,赈mdfe赈mdff崖mdfi央求mdfj岸mdg岵,崴mdgt崴mdhg岂有此理mdhh岸上mdi央mdj崦,颛mdjm颛mdjn崦mdl盎mdlf盎mdlp岸边mdm遄,颛mdma崎岖mdmm颛mdmp遄mdmt贿赂mdo炭mdou炭mdpo赈灾mdpy见面礼mdq鸯mdqd盎然mdqg鸯mds崎mdsk崎mdtv周而复始me骨,髓,崩med髓,骷medg骷medo骨灰medp髓medx崩龙mee崩meef崩mef骨,胄mefg骨干mefj崩塌megq崩裂meik崩溃mej髁mejs髁mel髑melj髑mem骰memc骰memw骨肉meo髅meov髅mep髂,髋,髌mepk髂mepq髋mepw髌meq鹘,骶meqg鹘meqy骶mer骺,髀merf髀merk骺mern骨气met骼metk骼metu骨科meud骨头mew骱mewj骱mey骸,岌meyu岌meyw骸mf财,周,赌mfad周期mfc岐mfcy岐mfd冉mff峙mffb风雨无阻mffg赌博mffi风起云涌mffj周刊mffn赌场mffy峙mfgc周到mfgh财政mfgs周末mfh巅mfhm巅mfi赇mfid财源mfiu山南海北mfiy赇,周游mfk周,雕mfkd周mfkk周口mfky雕mflf财团,周围,周转mflt财力mfmq周岁mfmt风雨同舟mfn赎mfnd赎mfnu赎买mfpg财富mfpn周密mfpy财神mfqy财贸mfrb周报mfrh周年mfrr周折mfsc财权mft财mftf赌徒mftj赌mftl财务mftr财物mftt财mftu财税mfub雕塑mful风雨交加mfuq崭露头角mfut财产mfwf财会mfwg周全mfwq雕像mfwu同志们mfxc财经mfyn雕刻mfyt周旋mfyu周详mg同,贱,赋mga赋,岍mgad同期mgah赋,岍mgcb赋予mgdg同感mgdh由下而上mgdr夙愿mge赙mgef赙mgej由表及里mgeq同胞mgfn同志mggd网开一面mggg同一mggk同事mggo几天来mghh同上mghi同步mghw同龄mgig风平浪静mgik山珍海味mgip同学mgje同盟mgjf同时mgjj同日mgk同mgkd同mgmy几天几夜mgn屿mgng屿,同情mgnn财政局,邮政局mgnq由来已久mgo崃mgod同类mgog同业mgoy崃mgpv贩毒案mgq夙mgqi夙mgqk同名mgrh同年mgrp岁末年初mgsu同样mgt贱mgtf同等,同行mgtj由不得mgtw见不得人mgty同往mgu峡mguj同意mguk财政部,内政部mguw峡mgwo同伙mgwu同伴mgww峡谷mgxd邮政编码mgxe同级,同组mgxt同乡mgya同谋mh由,幅,帽mhaj帷幕mhav贴切mhbb帽子mhd帱mhdf帱mhdg由此而来,由上而下mhdm帐面mhet由此及彼mhf帏mhfh帏mhfp风餐露宿mhg幅,帻mhgd由点到面mhgf由于mhgg凹凸不平mhgl幅mhgm帻,贴现mhgr由此来看mhh帖,帧,帔mhhc帔mhhh帐目mhhk帖mhhm帧mhj帽,幔,幌mhjc幔mhjh帽mhjq幌mhk巾,贴,帜mhkg贴,帐号mhkm幅员mhkw帜mhl帼mhly帼mhm帆mhmh巾帼mhmy帆mhn贝,冂,幄mhnf幄mhng由mhny贝,贴心mho幞mhoy幞mhpu贴补mhr帕,帙mhrg帕,由此看来mhrp贴近mhrw帙mhsm由此可见mht帐,幡mhth贴息mhtl幡mhtt帐篷,凡此种种mhty帐mhu幢,幛mhuf幢mhuj幛,帐单mhw帷mhwy帷mhya幅度mhyk由衷mhyn帐户mi峭,嵴miad财源茂盛mie峭mieg峭migs雕梁画栋miit山清水秀mink峭壁miti由浅入深miud山海关mivq崇洋媚外miw嵴miwe嵴miwi同流合污miww风尘仆仆mj则,赐,岿mjad同时期mjaq风景区mjde则有mjft同盟者mjgc由易到难mjh则mjir山盟海誓mjlg同盟国mjnn邮电局mjog邮电业mjpl同盟军mjq赐mjqr赐mjuk邮电部mjv岿mjvf岿mjwf同盟会mk迥,贶mkaf风吹草动mkfr风吹雨打mkik山呼海啸mkp迥mkpd迥mkq贶mkqd迥然mkqn贶mkrm贼喊捉贼mkww同路人ml崭,崽,崮mld崮mldf崮mlgo周恩来mlh岬mljg周转量mln崽mlnu崽mlr崭mlrj崭mlus崭新mm册,山,凹mmab删节mmai山东mmaq山区mmbw删除mmef山脚mmey山脉mmfb山地mmfh山坡mmfm山南mmg岫,删,峒mmgd凹,册mmgh山下mmgj删mmgk峒mmgq兕mmhh山上mmia山洪mmii山水mmiq山沟mmis山河mmkk山口mmkt山川mmm山mmme峥嵘岁月mmmm山,崇山峻岭mmmt山峰mmnt删改mmoo山火mmq岗,岚,岘mmqn岘mmqt婴儿mmqu岚,岗mmr罂mmrg山岳mmrm罂mmsd山顶mmsf山村mmsg山西mmsq岌岌可危mmss山林mmud山头mmv婴,鹦mmvf婴mmvg鹦mmwt见风使舵mmwu岗位mmww山谷mmxt山乡mmyf山庄mmyo山峦mmyy曲曲弯弯mn岂,凯,崛mna岷mnan岷mnb岂mnbm崛mnce岂能mndj岂非mnfh崛起mnfl同心协力mngg贼心不死mnh嵋mnhg嵋mnhh岂止mnj剀mnjh剀mnlt购买力,见异思迁mnm凯,觊mnmm峨眉山mnmn凯mnmq觊mnmt同心同德mnn屺mnnb岂敢mnny同情心mnqk内忧外患mnsk凯歌mntd岂知mnte刚愎自用mnwg觊觎mnww贴心人mny赆mnyt凯旋mnyu赆mo嶙,嵝,赕moo赕mooy赕moq嶙moqh嶙mosl内燃机车mov嵝movg嵝mp迪,崇,贮mpad贮藏mpaq崇敬mpd迪mpdh贮存mpf崇mpfi崇mpfp贻害无穷mpg贮mpgf见之于mpgg贮mpim崇尚mpin山穷水尽mprd崇拜mptl贮备mpuu赔礼道歉mpw崆mpwa崆mpwq财神爷mpyd迪庆mpym崇高mq风,见,网mqag刚巧mqai风范mqb见mqbw风险mqc购mqca刚劲mqcc风骚mqcy购mqd赡,崤mqde崤mqdk内外有别mqdm见面mqdy赡mqee风貌,岁月mqes风采mqfc风云mqff风土mqfg风雨mqfh风趣,刚直mqfn风声mqfv风雪mqgf网球,岿然不动mqgk风速mqgm迥然不同mqgn见多不怪mqgq刚烈mqgs岁末mqh飓mqhk网点mqhw飓mqi冈,风mqif风尘mqih风波mqii风沙mqim风尚mqiq风光mqiy风浪,风流mqj刚,峋,刿mqja风暴mqjg峋mqjh刚,刿mqjy风景mqk岣mqkf风味mqkg岣mqkk风口mqlf购置mqlq网罗mqlt风力mqmq刚刚,飓风mqmu巍然屹立mqng风情mqnu购买,见习mqo飚mqoo飚mqov岁数mqpf风寒mqpo风灾mqq网,飑mqqe见解mqqi网,购销mqqn飑mqrb见报mqrn风气mqst风格mqt峁mqta见长mqtb峁mqtm风向mqtq风筝mqtr购物mqu岁mqub风闻,见闻mqud见状,赡养,网状mque刚毅mquj风韵mqul内外交困mquq风姿,见效mqv峥,飕mqvb刚好mqvc飕mqvh峥mqww风俗mqwx风化mqxk刚强mqxt网络mqya风度mqyg见证mqyk见识mqyn购房mqys风靡mqyy见多识广mr贩,凰,嵬mrc贩mrcy贩mrfc贩运mrfm见所未见mrfn贩卖mrg凰mrgd凰mrgx贩毒mrkk肉制品mrq嵬mrqc嵬mrtc贩私ms朵,剁,崧msit山西省msj剁msjh剁msk岢mskf岢msu朵msv崾msvg崾msw崧mswc崧mt几,败,峰mta账mtai败落,同舟共济mtay账mtbk贬职mtbl败阵mtd峰,峤mtdh峰mtdj峤,几百mtdn几万mtfg败坏,几十mtfk败露mtgd几天mtgj风行一时mthk几点mtjf几时mtjg风和日丽mtjj几日mtk赂mtkg赂mtmf几周mtmt巍峨mtn屹,几mtnn屹,败局mtod败类mtog同行业mtp贬mtpy贬mtqd巍然mtr峨mtrh几年mtrt峨mttf几千mtth财务处mtto几番mtts几条mttu几乎,财务科mtu嵊mtuk内务部mtuq几次mtuu屹立mtux嵊,败北mtv巍mtvc巍mtwd败仗mtwf贬值mtwh几个mtwn几亿mtwq贬低mtwr几件mtws几何mtxc几经mtxg败绩mtxw败给mty败mtyo峰峦mtyq贬义,凤毛麟角mtyy见利忘义mu赠,赚,赔mud嵯muda嵯muff赔款,赠款mugj周总理mugn赠与muj嶂mujh嶂muk赔mukg赔mukm邮递员mul赠mulj赠muqg赔钱,赚钱musc财产权musg赔本musn同病相怜muud赠送,赚头muuu赠阅muv赚muvo赚muwi赔偿mux嵫muxj赡养费muxw赠给muxx嵫muy罔muyn罔muyy赠言mvgx由始至终mw内,肉,赊mwaj内幕mwap内蒙mwbf内陆mwde内有mwdh内在mwdi内耗mwet肉用mwey内脏mwf赊mwfb内地mwfi赊mwg嵛,嶝mwga风华正茂mwgh内政mwgj嵛mwgu嶝mwhk内战mwhv肉眼mwi内mwia内江mwib内涵mwis内河mwja见分晓mwkk肉食品mwld内因mwmt见仁见智mwng内情mwny内心mwod肉类mwpg内定mwpr内宾mwpw内容mwqh内外mwqi内销mwtf内行mwtl内务mwtm内向mwtn同仇敌忾mwtu内科mwuf内装mwuk内部mwuq内疚,内资mwut内阁mww肉,峪mwwg内债mwwi肉mwwk峪mwws肉体mwww几代人mwwy肉食mwxg内线mwy崔,岭,岑mwyc岭mwyf崔mwym内设mwyn岑mwyu内详mx嶷mxqt婴幼儿mxrq见缝插针mxt嶷mxth嶷my凡,丹,赃myai丹东myb崞mybg崞mycy见义勇为myd丹mydm几方面mye彤myet彤myf赃myff赃款myfg赃myfk风调雨顺myge丹青mygf见诸于mygk凡事myi凡myjg凡是mym嵩mymk嵩myn赅mynt凡属mynw赅mytf见诸行动mytr赃物myww见证人n民,已,书na民,懂,慌naaa民工naad展期naaf民革naap民营naaq民警nabm展出naby民防nack展台nae展naed飞黄腾达naei展naes异彩naet民用nafb异地nafc民运,展翅nafi展示nafj民进nafk展露nag惬naga异型,展开nagh民政nagk懂事,民事nagm展现nagw惬naif民法naip殿堂,异常nair改革派naj异,羿,惜naje民盟najg惜,改邪归正najt展览nakf异味nakk民品,展品nakl惜别nal懵nalg异国nalh懵nalt忆苦思甜nalw民办namg异同namq民风nan屉nand心甘情愿nanf民愤nang民情nann异己nanv屉nany慌忙,民心napp以工补农naq怄naqi展销naqy怄nard尽其所有narg民兵nart展播nask民歌nasu异样nat懂,愍natd慌乱nate民船,民航natf懂,懂行natg民生natj懂得natn愍,居功自恃natw居功自傲nauj民间,民意,惬意naum异端nav民navf民建naw殿,臀nawc殿nawe臀nawm以工代赈naws异体naww民俗,民众naxt慌张,异乡nay慌naye民谣nayg民主,展评nayn民房,展望nayq慌nayt民族nayy异议nb敢,屈,憨nbb孱nbbb孱nbc慑nbcc慑nbdf屈辱nbdg以防万一nbdj憨厚nbeb屈服nbgf敢于,局限于nbgi以防不测nbgp层出不穷nbm屈nbmk屈nbng尽职尽责nbnt局限性nbs屙nbsk屙nbt敢nbtn憨nbty敢nbwd敢做nbww屈从nbyf敢讲nbyu敢说nc怪,惨,怡ncd惨ncde惨ncf怪,怿ncfg怪ncfh怿ncgk怪事ncgm惨遭ncio惨淡nck怡nckg怡ncla快马加鞭ncld怪罪ncmt惨败ncna怪异ncpv惨案ncrn避难所ncru以观后效nctg惨重nctr怪物ncuc惨痛ncun怪癖ncw悛ncwn怪僻ncwt悛ncyt怪话ncyw怪论nd居,剧,惰nda惰ndae惰ndal居功ndd居,恹nddb丑态百出ndde忧郁nddy恹ndfu剧增ndg怙,憾ndgf居于ndgk憾事ndgn憾ndgq剧烈ndgy避而不谈ndha忧虑ndhj恰在此时ndj剧,悱ndjd悱ndjh剧ndkh居中ndkk忧患ndlf剧团ndm怖ndmh怖ndn忧ndna居民ndnf忧愤ndnn忧ndnt惰性ndny居心,忧心ndo恢ndoy恢ndqd居然ndqq居多ndqy居留ndtj恢复ndto忧愁ndud剧减ndwn心有余悸ndwt忧伤ndwy居住neax避孕药negf屈服于neke心服口服nepk心腹之患nf导,层,丑nfa愤nfam愤nfap慰劳nfbg丑陋nfc层,恸,怯nfci层nfcl恸nfcy忮,怯nfd丑,懦nfdj懦nfdm层面nff恃nffw懦夫nffy恃nfgc导致nfgf慎于nfgk迅速nfgn屡教不改nfgo丑恶nfh慎nfhw慎nfi慰,尉,熨nfif尉nfin慰nfio熨nfip导演nfiy导游nfjg导师nfjn导电nfkk必需品nfkn心直口快nfnf怯懦nfnv愤慨nfp迅,悖nfpb悖nfpk迅nfq怃nfqd愤然nfqn怃nfqs屠杀nfqt迅猛nfrg迅捷nfrw改朝换代nfsm发动机nft屠nfte导航nftg慎重nftj屠nftm导向nftp导管nftu悔过自新nfu导,悻nfua情真意切nfub丑闻nfuf悻nfuk慰问nfuq层次nfvc愤怒,迅即nfwf展示会nfwt慢动作nfwu惨无人道nfww发起人nfwx丑化nfxe层级nfxg导线nfxu导弹,懦弱nfy忖ng怀,情,懒ngab情节ngae懒散ngbb屋子ngbm悟出ngbt民不聊生ngc屋ngce恨不能ngcf屋ngcw刁难ngd刁ngde怀有ngdg情感ngdm情面ngdr情愿ngds民政厅nge情ngeb怀孕ngeg情ngew以理服人ngff惊天动地ngfg忙不过来ngfh情趣,情真ngga情形nggd慢吞吞nggf懒于,以至于nggj情理ngh怔nghg怔nghh心理上nghj怀旧ngi怀ngic懒汉ngif司法ngij恒温ngip心理学ngiw屋脊ngiy怀ngj恒ngjg恒ngjt恒星ngjy情景ngk司,悟,悚ngkd司ngkg悟ngki悚ngkm懒ngln情思ngmh情由ngnd懒惰ngng情怀ngnl尽责尽力ngnn民政局ngnv怀恨ngny恒心ngqh刁钻ngrb情报ngrf改天换地ngrk情操ngrq怀抱ngrt心平气和ngrv情势ngsd屋顶ngsi必不可少ngsm司机ngsq必不可免ngta司长ngtb恬不知耻ngtj懒得,怪不得,恨不得ngts情不自禁ngu怦nguh怦nguj情意nguk情况,民政部ngvh惨不忍睹ngvt恰到好处ngwk情侣ngwu改恶从善ngwy怀念,司令ngx愫ngxf情绪ngxi愫ngxt怀疑ngyp情谊nh收,蛋,眉nhaa收工nhad收藏nhae疏散nhaq收获nhbc收取nhce疏通nhd眉,戕,奘nhda戕nhdd奘nhde爿nhdn收成nhe胥nhef胥nhep收受nhf遐nhfc收支nhff收款nhfh收起nhfn收场nhfp遐nhfq疏远nhgc收到nhgd以点带面nhhh眉目nhi疋nhin疏漏nhj蛋,悼nhjc收紧nhjh悼nhju蛋nhkh心目中nhkr收听nhlk收回nhlq收罗nhmq收购nhne屡战屡胜nhnf疏导nhnr惧怕nhnt收发,收尾nhnu收买nhpd收割nhpw收容nhq鹛nhqg鹛nhqr疏忽nhqy收留nhrd收拢nhrg收兵nhrh收看nhrn收据nhrr蛋白nhru以旧换新nhrw收拾nhsh遐想nhsw疏松nht收nhtj收复nhts收条nhtu收税nhty收,收入nhud收养nhuj收音nhuq收效nhuw收益nhvi收录nhw惧nhwg收敛nhwy惧,悼念,收集nhxj收费nhxp收缩nhxr收缴nhxy收编nhy疏nhya以此为荣nhyn悼词nhyq疏nhyy收文ni悄,屑,尿nici惊涛骇浪nie悄nied屑nieg悄nieq以少胜多nifb发源地nigx尿素nii尿niit以法治税niiu懒洋洋nili劈波斩浪nim惝nimd以小见大nimk惝nini悄悄ninq恍惚nipe书法家niq恍niqd悄然niqn恍nir犀nirh犀nitj犀利niuk司法部,心满意足nj慢,愠,惺njc悭njcf悭njdg发电厂njf悍,悝njfg悝njfh悍njg怛njgg怛njgp心照不宣njhy心明眼亮njjg发电量njl慢,愠njlc慢njlg愠,慢车njmy避暑山庄njnt慢性njpe发明家njpn心旷神怡njq惕njqd悍然njqn展览馆njqr惕njsm发电机njt惺njtg惺njuh发电站njuq发明奖njwf展览会njwu忙里偷闲njy憬njyi憬njyt心里话nk避,臂,壁nkbb书呆子nkc悒nkcc壁垒nkcn悒nkcw避难nkdo心中有数nkeb避孕nkfo心中无数nkga避开nkgl壁画nkh忡,愦nkhh忡nkhm愦nkjf避暑nkk愕nkkn愕nkmf异口同声nkmq避风nknb尽忠尽职nkqk避免nku辟,劈,譬nkue臂,襞nkuf壁nkuh辟nkun甓nkup避nkuq鐾nkur擘nkus檗nkuv劈,嬖nkuy譬,璧nkvg心口如一nkvk譬如nkye辟谣nkyw发号施令nl惭,愣,翼nla翼nlaw翼nldy尽力而为nlnr惭愧nlny心连心nlr惭nlrh惭nls悃nlsy悃nluu心力交瘁nlwe民办公助nly愣nlyn愣nm届,刷,惴nmd届,怏nmdj惴nmdy怏nmf惆nmfk惆nmfp尸骨未寒nmg恫nmgk恫nmgq屡见不鲜nmh刷nmhj刷nmia届满,避风港nmit刷洗nmj恻nmjf届时nmjg收购量nmjh恻nmkg恫吓nmma异曲同工nmn恺nmnn恺nmnt惆怅nmny心贴心nmpk必由之路nmpt收购额nmrk情同手足nmu惘nmuh收购站nmun惘nmus刷新nmwj已见分晓nmww收购价nn忆,快,局nna巽nnai居心叵测,心怀叵测nnap层层落实nnaq居民区,已获nnat快攻nnaw巽nnbv局限nndd忙忙碌碌nndm局面,书面nndn怀恨在心nndq习惯成自然nndt已故nnf忸nnfg忸nnfj书刊nnfr惊心动魄nng己,巳,尸nngf快于,习惯于nngg愤愤不平nngk快速nngl书画nngn己,巳nngt尸nnh书nnhh书目nnhi快步nnhk居民点nnhq快餐nnhy书nnif书法nnij慷慨激昂nnit快活nnk局nnkd局nnkq发展史nnl乙nnlg快车nnll乙nnlx发愤图强nnn忆nnna书展nnnf快慰nnnj快慢nnnl羽翼,尽心尽力nnnn已,忧心忡忡nnnt习惯性nnpg书写nnqg慷慨解囊nnqh局外nnqi快乐nnqn书包nnqq快快乐乐nnqr眉飞色舞nnrb快报,书报nnrr层层迭迭,惊慌失措nnrv局势nnsg书本nnsv快要nnta局长nntd书籍,已知nnte快艇nnty已往nnu忌nnug慢性病nnuk局部nnul尽心竭力nnuq已将nnux快递nnv乜nnvq已婚nnvs忧心如焚nnw快nnwk局促nnws尸体nnwy快,快信,书信nnx怩nnxa羽绒nnxc已经nnxe局级,司局级nnxn怩nny羽nnye心悦诚服nnyf忌讳nnyg羽nnyh书店nnyi习以为常nnyn快讯,书记no屡,屎nofp导火索noi屎nono屡屡nouq屡次nov屡novd屡noxg导火线np忱,恽,惋npcn慎之又慎npfb发祥地npgp发家致富,心神不安npgt心安理得npjc悔之晚矣npl恽nplh恽nplq居安思危npmn司空见惯npna惋惜nppf异军突起npq忱npqb惋npqn忱npst以礼相待npwi屄nq懈,恂,惚nqck懈怠nqdf愤然而起nqdn恍然大悟nqdu疏忽大意nqe懈nqeh懈nqj恂nqjg恂nqnt必然性nqr惚nqrn惚nqru心狠手辣nqta以逸待劳nquc心猿意马nquq遐尔闻名nqvs心急如焚nqwf展销会nqww局外人nr怕,愧,忾nrad怕苦nrak惶惑nram惶恐nrdw以势压人nrg怕,惶nrgg惶nrgq怕死nrh忻nrkk蛋制品nrky飞扬跋扈nrlx怕累nrmq情报网nrn忾nrnn忾nrnr惶惶,敢打敢拼nrq愧nrqc愧nrrf蛋白质nrrn情报所nrso屈指可数nruq愧疚nrww怕人nrxj书报费nryt忻州ns怵,憷nsce尽可能nsfn飞机场nsgg异想天开nsgh屡禁不止nsnt必要性nss憷nssh憷nsy怵nsyt以权谋私nsyy怵nt必,改,性nta怅ntaa发芽ntad改期ntaf改革ntay怅ntb悸ntbd尾随ntbg悸ntbi发函ntbm发出ntc发ntce性能ntcm改观ntcn尾巴ntcw发难ntcy发ntd恬ntde必有ntdg恬ntdl发奋ntdm发布ntdn改成ntdp发达nte必nted必须ntet必胜ntf尾,屐,忏ntfc屐,发动,改动ntfd必需ntfh忤,忏,发起ntfj改进ntfn尾,尾声ntfp改过,悔过ntg性ntgb以身殉职ntge发表,恬静ntgf属于,以利于,羽毛球ntgg性ntgh改正,以利再战ntgi发还ntgk履带ntgm发现nth怍,屣nthf怍nthh屣ntia发泄ntid发源ntip发觉ntiq发光ntj虱,愎ntje发明ntjg发行量ntji虱ntjj改日ntjn发电ntjt愎ntk属,恪ntkg恪ntkk改口,发生器ntkl性别ntkm飞行员ntky属ntl恤ntld悔罪ntlg恤ntm懊ntmd懊ntmf发财ntmt必败ntna发慌,发展ntnf发愤ntng悔悟,性情ntnt懊悔,忏悔,悔改,属性ntnv悔恨ntny懊恼nto愀,屦ntoo发炎ntov屦ntoy愀ntpe发家ntpf恪守ntpg必定,改写ntpu属实ntqd必然ntqn发包ntqq快得多ntqv性急ntrf性质ntrh改掉ntrn发掘,发扬,书生气ntrp发挥ntrq改换,以德报怨ntrr发誓ntrv发热ntsf发票ntsg发酵ntst性格ntsv必要ntt履nttf发行,改行,改造,履行nttg发生nttj必得nttl必备nttm发射ntto发愁nttt履,发笑ntty发稿,改稿ntud发送,改判,改善ntuf改装ntug发病ntum发疯ntuq必将,发奖ntvf改建ntvi异乎寻常ntwf居委会ntwg性命ntwh必修ntwm以身作则ntwt发作,改任ntwx发货ntwy发信ntx悔ntxe改组ntxu悔ntxw发给ntxy改编nty改ntyc发育ntyg发证ntyl改为,避重就轻ntyo改变ntyp发亮ntyt发放ntyv改良ntyy发文,发言nu习,飞,买nua屏nuaj屏幕nuak屏nuat收效甚微nuau屏蔽nubg悦耳nubu屏障nucb飞驰nuce买通nud买,习,羼nudd羼nudf飞奔nudu买nudv恼羞成怒nuet习用nuf翌nufh飞越nufj买进nufn买卖nugk飞速nugo飞来,憎恶nuhh悦目nui飞nuim飞溅nuix飞涨nuj惮,憧nujf惮,憧nujj翌日nujn慰问电nuk悦nukh飞跑,飞跃nukq悦nul憎nulf慰问团nulg飞车nulj憎nunj憧憬nunn飞快nunt习性nunu尽善尽美nunv憎恨nunx习惯nurd改头换面nurh翌年nurl飞舞nurn飞扬,习气nusm飞机,收音机nute飞船nutf飞行nuty飞往nuud飞翔nuv慊nuvo慊nuwj层次分明nuwt习作nuwu居首位nuww买价,习俗nuwy慰问信nux悌nuxt悌nuy悯nuyg买主nuyv以次充好nuyx发病率nuyy悯,买方nv恨,慨,尻nvaw恰如其分nvc慨nvcq慨nvda屡建奇功nve恨nvey恨nvk怊nvkg怊nvly快刀斩乱麻nvn忉nvni惟妙惟肖nvsm收录机nvt忉nvv尻nvvp心如刀割nw愉,恰,怜nwag恰巧nwam惟恐nwaq居住区nwb怆nwbn怆nwc忪nwcy忪nwde惟有nwe戮,鹨nwea戮nweg鹨nwg愉nwgj愉nwgk恰nwgl慌作一团nwiv恰当nwkm司令员nwlt尽全力nwna怜惜nwng快人快事nwnn愉快nwnu怜悯,愉悦nwnw恰恰nwny憔悴,敢作敢为nwpw戳穿,心领神会nwqt惟独nwtd恰逢nwtf以假乱真nwuk司令部nwvb恰好nwwh慢悠悠nwwk司售人员nwwn恰似nwwu性命攸关nwww收货人,收件人,收信人nwxt尽人皆知nwy惟,戳,翟nwya戳nwyc怜nwyf翟nwyg惟nwyj必修课nwyo憔nx尼,屁,惯nxet惯用nxf惯nxfm惯nxgu迟疑不决nxgx改弦更张nxj怫nxjh怫nxjl改弦易辙nxpf必经之地nxux恃强凌弱nxv尼nxwg惯例nxx屁nxxv屁ny心,尽,忙nyad以期nyai以东nyam惊恐nyb恼nybh恼nybk尽职nybw惊险nyby以防nycy惊骇nydr心愿nyds惊奇nydv忙碌nydy心态nyef心肝nyen心肠nyep心爱nyeq心胸nyet心腹nyey心脏nyfb心地nyfc惊动nyfg尺寸nyfi以求,以示nyfk惊喜nyfm以南nyfn心声nyfq心坎,以远nyfu心境nygc迟到,以致,以至nygf忙于nygh以下nygj心理nygk尽速,心事nygm尽责nygo以来nyh惦,忭nyha心虚nyhh心目,以上,心上nyhk惦nyhv心眼nyhx以此nyhy忭,忄nyi尺,惊nyif心潮nyip民主党nyiw尽兴nyiy惊nyj昼nyjf心里nyjg昼,尽量,尽是,居高临下nyjh迟早nyk咫nykc惊叹nykg惊吓nykh心跳nykn惊叫nykt惊呼nykw咫nyl懔nyli懔nyll心田nyln心思nylq心软nylt尽力nymw以内nyn忙,心nyna惊慌,惊异,心慌nyng尽情,心怀,心情nynk惊愕nynn忙,尽快nynr惊惶nynv慷慨nyny心,惊心,尽心,咫尺nyoo恼火nyp迟nypi迟nypy心神nyqg迟钝nyqh以外nyqk以免nyqv心急nyrd惊扰nyrg以后nysc发言权nysg惊醒,心酸,以西nysh心想nyst以诚相待nytd忙乱nytf以待nytj心得nytl心血,尽义务nytp尽管nyts民族自决权nytu民族自决nyty以往nyu尽nyuc心痛nyud尽头,心头nyue以前nyuj心意nyuq以资nyut心疼nyuu尽nyux以北nyv慷,慵nyvc恼怒nyvh慵nyvi慷nyvo心灵nyw以,翠,悴nywf翠,悴nywg以便nywr民主集中制nyww惊人,发言人nywx民主化,民族化nywy以,惦念nyxe迟缓nyxf心绪nyxl心细nyxt迟疑nyxv翠绿nyxy心弦nyya尺度,惊讶nyyf心计nyyk迟误nyyl以为nyyn惦记nyyp惊诧nyyw昼夜o为,火,米oa煤,烧,炼oabb炎黄子孙oadi煤耗oady煤矿oaf煤oafg烘干oafs煤oagq烧死oaim炼油,煤油oakf火药味oall煤田oamd煤炭oan炬oanf煤层oang炬oanw炼oaol煤烟oaqm炼钢oaqr炼铁oarf煤质oarm炼制oarn煤气oart烘托oat烧oatq烧oava烧毁oaw烘,粪oawt烧伤oawu粪oawy烘,炼焦oaxf烧结ob籽obg籽oc烃,粑,糁oca烃ocag烃ocb糅ocbs糅ocd糁ocde糁ocn粑od类,烦,糊odd粝oddn粝oddr燎原ode糊,煳odeg糊,煳odg炻odga类型odiw糊涂odkh烦躁odkl类别odm烦odmy烦odny烦恼odrw类推odu类,燎odui燎odwn类似odxw精耕细作odxx类比odya精确度oe粗,爝oeg粗oegg粗oeja粗暴oel爝oelf爝oelt粗略oeny粗心oeot粗糙oeqt粗犷oeuf粗壮of灶,烤,炜ofd糯ofdj糯ofg灶ofn炜ofnh炜ofol烤烟oft烤oftn烤ofxi烟雾弥漫og业,精,糟ogaa精工ogag精巧ogam精英ogb邺,炖ogbh邺ogbn炖ogce精通ogd业ogdi精耕ogdq精确oge精ogeg精ogeo数不胜数oges精彩ogfg精干ogga凿开oggc精致ogia精湛ogig数不清ogiq精光ogj粳ogje精明ogjq粳ogk焐ogkg焐ogkh糟蹋ogkk精品oglt精力ogm炳ogme精髓ogmj糟ogmw炳ognj精悍ognk精辟ognn业已ogoa精炼ogor糟粕ogou糟糕ogpn精密ogpy精神ogqu精锐ogrg精兵ogrm精制ogtf精选ogtl业务ogtu精简ogu凿,黻,黹ogub凿oguc黻ogud精减ogug精美ogui黹oguy黼ogwt业余ogwx精华,数理化ogxc业经ogxg业绩ogxl精细ogxy精纺ogya精度ogyd精诚ogyf精读ogyg业主ogyv精良oh粘,焯ohj焯ohjh焯ohk粘ohkg粘ohli火上加油ohmh粘贴oi炒oifa烟消云散oit炒oitt炒oj烛,爆,焊oja爆ojai爆ojat数易其稿ojf焊ojfh焊ojgq爆裂ojia爆满ojl熳ojlc熳ojnt爆发ojoi糊里糊涂ojot爆炸ojru焊接oju煜ojug煜ojxf精明强干ojy烛ok炽,燥okgq炽烈okk燥okks燥okrv炽热okw炽okwy炽ol烟,煨olaj烟草olck烟台old烟oldy烟olft烟雾olg煨olge煨olif烟尘olkf烟叶oloo烟火oltl烟囱olud火车头oluh火车站olwf粉墨登场olyi精力充沛om灿,炯,籼omh灿,籼omho煽风点火omk炯omkg炯omom炯炯omou灿烂omxy精雕细刻on断,熠,烬ondm断面ondu粗心大意ondy数以百计,数以万计onga断开ongq断裂onh糈onhe糈oniy断流onjn断电onjo精心照料onnf断层onpg断定onpq燃眉之急onqd断然onr断,炀,熠onrg熠onrh断onrt炀onta精心策划onty数以千计onud断送onuq断交onw炔onwy炔onxq断绝onxx精心组织ony烬onyu烬onyy断言,精心设计oo炎,焱,郯ooal火苗ooaq火警ooaw火花ooax火药oob郯oobh郯oocj灯火通明oodh炎夏oofn火场oogk火速ooiq火光ooit火海ooj剡oojh剡oojt火星oolg火车oolt火力oomm火山oong火情ooo火oooa火炬,火烧oooo火oooq火焰ooou焱oooy火炉oopo火灾oorc火把oorv火热,炎热ootk火种ootu火箭oou炎ooug炎症oouy炎凉ooxg火线,炉火纯青ooxx断断续续op迷,熔,烷opaa数字式opak迷惑opf烷,粽opfi粽opfq烷opft迷雾opg煊opgg煊opgk熔融opi迷opij迷漫opkh迷路opnm迷惘opoy熔炉oppk迷宫oprw迷失opw熔opwk熔opww迷人opwx熔化opwy迷信opxx粮农组织opya精密度opyo迷恋oq炮,燃,焰oqa遴,粼oqab粼oqap遴oqd烯oqdh烯oqdo燃oqfh燃起oqfm炮击oqfn炮声oqgu焕然一新oqhw炊具oqi烁oqim燃油oqiy烁oqlc炮轰oqm焕oqmd焕oqn炮oqnn炮oqnt焕发oqoa燃烧oqoo焰火oqou燃料oqrg炮兵oqrm炮制oqrv灼热oqv焰oqvg焰oqw炊oqwt灼伤oqwy炊oqxu炮弹oqy灼,熘oqyl熘oqyt燃放oqyy灼or煌,粕orbb烂摊子org粕orgg煌orit粗制滥造ortg精兵简政orxt精打细算oryl数据库os灯,粞osdk粗枝大叶osg粞osh灯osiq灯光osoo灯火ot烽,炸,熄otax炸药otd烽otdh烽otdm粉身碎骨otf糙otfg炸坏otfp糙otgo熄灭otgq炸死oth炸,糗,糌othd糗othf炸othj糌othn熄otk烙otkg烙otkm业务员otm燠otmd燠oto燔otol燔oton炸断otqg烙印otrn粮管所ottu业务科otu烀otuh烀otva炸毁otwt炸伤otxu炸弹oty敉ou料,粒,烂oubb粒子ouby断章取义oud烊oudh烊oue燧ouep燧ouf料oufg烂oufh料oufo精益求精oug粒,糕ougj料理ougo糕ouij烂漫ouin烂泥ouk焙oukg焙ouln精疲力尽oulu精疲力竭oum熵oumk熵oun焖ouny焖ousg精装本ouug火辣辣ouuy爆冷门oux糍ouxx糍ov娄,数,煺ovai数落ovdn数万ove煺ovee数月ovep煺ovf娄ovhh数目ovip数学ovjg数量ovjj数日ovpb数字ovpt数额ovrh数年ovrn数据ovrp数控ovt数ovty数ovuq数次ovwf数值ovwu数位ovxw精妙绝伦ow粉,烩,煅owb炝owbn炝owd煅owdc煅owdy粉碎owf烩owfc烩owgs粉末own糇ownd糇ownm粉刷ownn粮食局owqn粉饰owtr迷途知返owud粉状owv粉owvn粉owx烨owxa粉红owxf烨owy焓owyj粉剂,粘合剂owyk焓ox糨oxix灯红酒绿oxk糨oxkj糨oxts粗线条oy米,粮,糖oyaj粮草oyak煽惑oydg糖厂oyfc煽动oyg炷oygg炷oyim粮油oyiq炫耀oyjs糖果oyll粮田oym炕oymn炕oyn炉,煽,煸oyna煸oynn煽oynt炉oyo燮oyoc燮oyox糖衣炮弹oysr粮棉oyt米oyty米oyud炕头oyuh粮站oyv粮,糖,糠oyve粮oyvi糠oyvk糖oyw粹oywb粮仓oywf粹oyww粮价oywy粮食oyx炫oyxy炫oyy灬oyyh粮店oyyl粮库oyyy灬p这,之,被pa宽,宦,寞paai空荡荡pabv宽限padd宽大padj宽厚padl究其原因pah宦pahh宦paim宽敞paip农工党paj寞pajd寞pajg农艺师pajh宽畅pam宽pamq宽panf宽慰pant礼节性papu宽裕papw宽容paqs字斟句酌pasi究其根源pasw宽松paui宽阔paum农工商pavk宽恕pawt宽余paya宽度payy宽广pb字pbay初出茅庐pbf字pbfc豁出去pbhh实际上pbhv字眼pbma字典pbrg空降兵pbsu字样pbxg字母pbyo字迹pchh客观上pcnt客观性,灾难性pcpg实验室pd害,寄,宠pdbw割除pdc宏pdcb寄予pdcm宏观pdcu宏pddd宏大pddh寄存pddp豁达pde寡,宥pdef宥pdev寡pdf宕,宸pdfe宸pdgm视而不见pdgq割裂pdh害,割,豁pdhj割pdhk豁,害,突破点pdjh害虫pdlt宏图pdnr害怕pdnt突破性pdon割断pdpw寄宿pdqk豁免pdqt宠儿pdrt寄托pds寄pdsk寄pdta神态自若pdtg寄生pdth害处,寄自pdty寄往pdu寮pdug害病pdui寮pdwf宏伟pdwy宠信,寄信pdx宠pdxb宠pdyg寄语pdyt寄放pe家,农,宜peaa农工peax农药pedl农历peet家用,农用pefe袒胸露腹pefn农场pefu家境,袒胸露背peg宜pega实用型pegf宜pehw家具,农具pei农peih家小peip家常,农学peit农活peiv家当pejf家里,农时pejj宜昌pejn家电,农电pekh家中pekq家史pelf家园pell农田pemf家财pena农民penr神采飞扬pent家属peny农忙peog农业pepe农家pepr宜宾peqq补助金peqy农贸perf农技pesf农村pesm农机pess农林peta家长petf农行petl家务petr农牧peu家peuq农资peus农闲peut家产peuy家门peve农垦pevv农妇pewa农贷pewo家伙peww家人pewy家禽,家信pexj补助费pext家乡pey冢peyn农户peyt家庭,家族peyu冢,家谱peyx家畜peyy家访,神采奕奕pf守,完,赛pfaa完工pfaq赛区pfbg守卫pfbn完了pfdf穿云破雾pfdn完成pffn赛场pffp实地考察pfft宗教pfgk赛事,完整pfgw空无一人pfhh塞上pfhj守旧pfi宗pfia完满,塞满pfif寒潮,守法pfir宗派pfiu宗pfiy寒流pfj寒,塞,寨pfjc骞pfje褰pfjf塞pfjg客运量pfjh蹇pfjm赛pfjr搴pfjs寨pfju寒pfjy謇pfkh赛跑pflw宗教界pfmj守则pfmq寒风pfpl冠军pfq完,冠,寇pfqa初露锋芒pfqb完pfqc寇pfqf冠pfqh塞外pfrg赛后pfrt突击手pfrv守势pfry守护pftk赛程pftl守备,完备pftu寒冬,完税pfu守pfud完善pfug完美pfuw寒冷pfux塞北pfvb完好pfwg完全pfwh守候pfwn寒假pfwy守信pfxf完结pfxj宗旨pfxq守约pfxx完毕pfyc官运亨通pg定,写,宝pgad宝藏,定期pgbm写出pgc室pgcf室pgde富有pgdg宝石pgdm宣布pgdn写成pgdy富矿pgf宇pgfb宝地pgfh写真pgfj宇,实事求是pgfr完整无缺,完整无损pgft宣教pgga定型pggf富于,定于pggj定理pggm富丽pggn宁死不屈pggu安于现状pgh定pghk定点,宣战pghu定pgia宣泄pgif写法pgir富丽堂皇pgj宣pgjf定时pgjg宣,定量pgjt寒来暑往pgjv写照pgk富pgkh宝贵,富贵,富足pgkl富pgkm定员pgld定罪pglg富国pgm寅pgmh宝贝pgmq定购,裙带风pgmw寅,室内pgn写pgna富民pgnd定居pgng写pgnn定局pgnt定性,军烈属,完整性pgpb写字pgpe军事家pgpg宝宝pgpl冠亚军pgpm宇宙pgpt定额pgpu富裕,写实pgpv定案pgpy定神pgqh室外pgqk定名pgqm宝钢pgqn富饶pgqy宝岛pgrn宣扬pgrr宣誓pgsd牢不可破pgsw密不可分pgte宇航pgtf宣告pgtj容不得pgtm定向pgtq宣称pgtv定律pgtw寡不敌众pgty定稿pgud宣判pguj定单pguk农副产品pgut定产,裙带关系pgvj宾至如归,视死如归pgwd定做pgwf宣传,安理会pgwt富余,写作pgwu定位pgww定价pgwx定货,军事化pgwy写信pgxe定级pgxk富强pgxy定编pgy宝pgyf宣读,宣讲pgyl宝库pgyp富豪pgyq定义pgyu宝pgyw宝座,定论,军政府pgyy宣言ph寂phge寂静phi寂phic寂phpa寂寞phtr初战告捷pi宵pibp农学院picw宗法观念pie宵pief宵pift空洞无物pijg客流量pion容光焕发piss宵禁pitg礼尚往来piwq家常便饭piyl被誉为pj审,宴,寓pjbb穷日子pjd幂pjdh幂pjgf寓于pjgj审理pjh审pjhj审pjir冠冕堂皇pjm寓pjmu窗明几净pjmy寓pjnf审慎pjpg审定pjpw审察pjpy审视pjrn寓所pjrx审批pjsj审查pjsy审核pjtu字里行间pju冥pjud审判pjug审美pjuj寓意pjuk审问pjuu冥,审阅pjv宴pjvf宴pjwf宴会pjxf审结pjya宴席pjyf审计pjyg宴请pjyn审讯pjyr审时度势pjys审订pjyy审议pk宫pkfw空口无凭pkk宫pkkf宫pkna宫殿pktf宫廷pktg初中生pkvu守口如瓶pkyj家喻户晓pl军,寰,郓plaa军工,初加工plap军营plaq军警,军区plas冥思苦想plat军医plb郓plbb官架子,空架子plbh郓plbk军职plbw军队pldg军威pldj农转非pleb军服plet军用plfd军需plg寰plge寰plgh军政plgk军事plgn祸国殃民plh皲plhc皲plhw军龄plia军港plir实力派plj军pljg军师plkk军品pllf军团pllg军车pllt军力pllw军界plmb军邮plna军民,军转民plnt军属,礼轻情义重plny军心ploo军火plpg寰宇plpn军官plpw军容plpy军礼plqi军乐plqn军饷plre军援plsa军械plsc军权plsk军歌plsm军机plsu军校plta军长pltd军籍plte军舰pltk军种pltl军备,军务pltq军衔pltv军委pluf军装pluk军部plve军垦plww军人plwy军令plxj军费plxn军纪plyk军训plyn穷困户plyt军旅,军旗plyy军方,军国主义pm宙,冗pmb冗pmf宙pmfm穿山越岭pmly穷则思变pmqc视同儿戏pmta冗长pmva神丹妙药pmxj补贴费pmxn军风纪pn官,密,蜜pnaq家属区pnav密切pndc密码pndm密布pne甯pnej甯pnff密封pnh官,寐,寤pnhi寐pnhk寤pnhn官pnhp逭pnjt蜜蜂pnkm官员pnlw官办pnng官司pnnt突发性pnqf突飞猛进pnqo安居乐业pnrg官兵pnsf密植pnss密林pnt密,宓pntg实习生pntj蜜pntm密pntr宓pnuf密闭pnvy定心丸pnw寥pnwe寥pnwg官倒,密使pnww官价pnwy密集pnxe密级pny廴pnya密度,密谋pnyy官方po灾poaq灾区poay灾荒pocw灾难polg农业国polw实业界pona灾民pong灾情popd灾害pope实业家popy灾祸potu农业税pou灾pouk农业部poum军火商poyl军火库pp之ppay安家落户ppbf之际ppdd实实在在ppdg之三ppdj宽宏大量ppdw富富有余ppdy宽宏大度ppfg之二ppfm寥寥无几ppgg之一,安安静静ppgh之下pphh之上ppiy之流ppkh之中,之路ppkp冤家路窄pplk神农架ppmw之内ppng礼宾司ppod之类ppp之pppf冠军赛pppp之ppqh之外ppqv之争ppqy之久pprg之后pptt安安稳稳ppue之前ppuj之间ppuo安家立业pput之首ppvb空空如也ppwt之余ppxj安家费ppyy家家户户,密密麻麻pq宛,冤,剜pqb宛pqbb宛pqbj剜pqbw军乐队pqfu安然无恙pqgy豁然开朗pqk冤pqky冤pqnb冤屈pqpv冤案pqpw安乐窝pqq鸩pqqd宛然pqqg鸩pqsg冤枉,穷凶极恶pquj突然间pqvk宛如pqxx穿针引线pqyf农贸市场pr宾,牢prcc牢骚prg宾prgw宾prh牢prhj牢prhk空白点prld牢固prny之所以prpq实报实销prpt宾客prqn宾馆prtf牢靠pruc袖手旁观pryg宾主pryn牢记ps宁,宋psdg农机厂psdh宁夏psdr宁愿psge宁静pshe宁肯psih宁波psj宁pssk宁可pstf宁德psti农林牧副渔pstq守株待兔psu宋pt客,额,宅pta宅ptab宅ptaq农牧区ptbp福利院,农科院,社科院ptbw客队ptcm客观ptdb官复原职ptdd客套ptdg福利厂,神秘感ptds客厅ptf宪ptfc客运ptfq宪ptgk家务事ptia客满ptif宪法ptio农牧渔业ptit安徽省,家务活ptiy客流ptjh寄生虫ptk客ptkf客ptkm额ptlg客车ptlw客轮ptna农牧民ptog农牧业ptpg额定ptqh额外ptrn客气ptsf客票ptsm客机ptte客舱ptuj宪章ptum客商ptww客人,被告人ptwx神秘化ptxj福利费ptya额度ptyn客房,客户pu实,补,初pua褡puad初期puak褡pubb裤子pubf实际puc衩,裰pucc裰pucw实验pucy衩pud实,褥pudf褥pudg初三pudh初夏,实在pudu实pudw初春pue衫pueg补助puet衫,实用puf衬,褂,褚pufc被动,被劫pufg实干pufh褂pufi补救pufj褚,襦pufk裸露,袒露,初露pufr完美无缺puft补考pufy衬pug袜,裱puge裱pugg初一pugj实惠pugk实事pugm实现pugs袜pugw袖珍puh补puhc被puhi初步puhk初战,实战puhw初具puhy补pui衤,裆puip初学puiv裆puj宰,裸,袒pujg袒pujl褴pujn褐pujr裼pujs裸puk裎pukg裎pukh补遗,补足,初中,实践,实足pukk补品,农产品pukm审判员pul裢puld裕固pulp裢pult实力pum袖,衲pumg袖pumh补贴pumq初见pumw衲pun袂,裾,褶pund裾pung襟怀,实情punr褶punt补发punu补习,实习punw袂puny实心puo褛puog实业puov褛pupd宰割,被害pupf初赛pupg寝室,补写pupj初审pupu被褥,衬衫puq袍puqc褐色,褪色puqn袍puqs宰杀,被杀puqt初犯pur裨,褫purb补报purf裨,实质purg被捕purk被扣purm褫,补缺purn实据purp被迫,被控purt衬托pury袒护pus襟,襻pusc实权,审判权pusi襟pusr襻put袄,衽,袼puta审判长putd袄putf衽,被告,补选,初等,初选,实行putk袼putl补血puto初秋putr实物putu补税,初冬puty初稿,补入puu袢,褙,裥puue褙puuf袢puuj裥puuk实况puuq初次,实效,被盗,补交puuw补益puv初,寝,裙puvc寝,初始puve裉puvk裙puvn初puvp褪puw裕,裣,衿puwb初创puwd袱puwe被俘puwg实例puwi裣,补偿puwk裕,袷puwn衿puws褓,裸体,实体pux襁puxe初级puxj襁puxr空前绝后puxw补给puy裤,褊puya褊,初试puyc补充puye衬衣puyg初评puyj补课puyk初衷puyl裤puyt实话,实施pv安,案,宄pvag安葬,突如其来pvb宄pvbb案子pvf安pvfr完好无损pvgb安顿pvge安静pvgf宝刀不老pvhh安上pvit福建省pvjq安歇pvlf安置pvna安民pvnd安居pvnf安慰pvng案情pvny安心pvpe安家pvpg安定pvpy安祥pvqd安然,安危pvqi安乐pvqk安逸pvqt案犯pvrd安排pvrf安抚pvs案pvsu案pvth安息pvtm安徽,安身pvtq安稳pvuf安装pvwg案例,安全pvwr案件pvwv安分pvyd安庆pvyt安放pvyu安详pvyv安康pvyx完好率pw空,穿,穷pwa空,窍,窃pwad穷苦,窝藏pwaf空pwan窍pwaq安全区,军分区pwat穿pwav窃pwb窿pwbb空子pwbc窃取pwbg窿pwbi空隙pwbm突出pwbt空降pwbw宣传队pwby空防pwcw空难pwd突,宿pwdg安全感pwdh突破pwdj宿pwdr宿愿pwds宴会厅pwdu突pwdx空袭pwee容貌,宣传月pwet守信用pwf罕,窦,察pwfa空域,空载pwfb空地pwfc空运pwfd窦pwfh穿越,突起pwfi察pwfj罕pwfm突击pwfp穿过pwfq窥pwfu窘境pwg窒,窀pwgf窒pwgk安全带,穷途末路pwgn窀pwha空虚pwhh社会上pwhk空战pwi窕pwim空洞,窥测pwip察觉pwiq窕pwj窠pwjg容量pwjh害人虫pwjq容易pwjs窠pwjy空旷pwk窜,窝pwkh窜,空中pwkk窗口,容器,宣传品pwkr窃听pwkw窝pwl穷pwlb穷pwlf空转pwlg穷国pwls穷困pwm帘pwmf宣传周pwmh帘,安全帽pwmm鹤岗pwmq罕见,窥见pwn窟pwnk鹤壁pwnm窟pwnn安全局pwnt突发,安全性,社会性pwny空心pwo窭pwoo窝火pwov窭pwpl空军pwpn安分守己pwpt空额pwpw窟窿pwpy窥视pwq穸pwqa容错pwqd突然pwqp冤假错案pwqu穸pwr窑,窳pwrh察看pwrm窑,空缺,空投pwrn空气pwrp窘迫,窥探pwrr空白pwry窳pwsc穿梭pwsh空想pwt窗,窄,窖pwtf窄pwtg寄人篱下pwth窒息pwtj容得pwtk窖,容积pwtp窆pwtq窗pwtr农作物pwu穴,邃,窨pwud穿着,空头,军令状pwue空前pwui空阔pwuj窨,究竟,空间pwup邃pwuq宿将pwus空闲pwut容颜pwuy窍门pwv究,窘pwvb究pwvk窘pwvy容忍pww容,窬pwwf宿舍pwwj窬pwwk容pwww寄件人,寄信人pwwx社会化pwx穹,窈pwxb穹pwxj补偿费pwxl窈pwxm容纳pwy鹤pwyg鹤pwym空调pwyn窗户pwyo空谈,突变pwyt空话,容许px它pxb它pxgy初级班pxtv守纪律pxwf穷乡僻壤pxwu它们pxww家乡人py社,神,祝pya祺pyab礼节pyaj定计划pyaq社区pyaw祺,礼花pyb祁pybh祁pyce神通pycf神圣pycq察言观色pyd祷,祓,祜pydc祓pydd禊pydf祷pydg祜pydj祖辈pydr祝愿pyds神奇pydy神态pye祖pyee礼貌pyeg祖pyes神采pyf社,祛,禧pyfc祛pyfg社pyfi祈求pyfk禧pyg福,祆pygd祆pygk祸事,神速pygl福pyh祉,祯pyhg祉pyhh祖上pyhm祯pyi礻,祧pyip礼堂,视觉pyiq祧pyj神pyje神明pyjf视野pyjh神pyjm礼遇pyjr安度晚年pyk祝,祸pykk祸患,礼品pykm社员pykq祝pykr视听pykw祸pylf社团,审计署pylg祖国pylk祝贺pylt视力,空话连篇pym视pymg视同pymq视pyn礼,祠,冖pyng神情pynk祠pynn礼,祀,审计局pyny辶,祸心pyoq礼炮pypd祸害pypf祖宗pypw视察pypy祈祷,祝福pyq祢,祗pyqc神色pyqe视角pyqi祢pyqy祗pyr祈pyrh祈pyrn福气,神气pysv祸根pyt祚pyta社长pytd神智,祖籍pytf祚,祖先pytj福利pytk祥和pytn神秘pytr礼物pyty神往pyu祥,禅,禚pyud祥pyuf禅pyuj福音,神韵pyuk农畜产品pyuo禚pyuq社交pyv禄pyvf福建pyvi禄pywf社会,祖传pywm神仙pywn神似pywq祖父pywx神化pywy礼仪pyxc神经pyxg祖母pyy宀,禳pyye禳pyyh礼让pyyl视为pyym福州市pyyn宀,祈望pyyt福州,神话,神州pyyw社论q我,金,多qa氏,错,昏qaai错落qabw包工队qace多功能qad锘qadg错落有致qadk锘qaf钳qafg钳qafp错过qagk错事qah舛,桀,铘qahb铘qahh舛qahs桀qaip错觉,昏沉qaj错,镆qajd镆qajf昏qajg错qaju昏暗qak钷qakg钷qal锚qalg锚qan钜,钺,铽qang钜qant钺qany铽qaop昏迷qap铹qapb错字qapl铹qapv错案qaqt多劳多得qarm钳制qart急功近利qary链式反应qat铙qatd错乱qatq铙qav氏qaw镬qawc镬qawo乌七八糟qawu错位qaxf锋芒毕露qay氐,邸,鸱qayb邸qayg鸱qayi氐qayk错误qb凶,怨,迎qbad危险期qbbw凶险qbc镊qbcc镊qbdm迎面qbdw迎春qbfm迎击qbg铒qbgo凶恶,迎来qbgq凶残qbh钌,眢qbhf眢qbhk迎战qbja凶暴qbk凶qbkd乌孜别克qbkk凶器,危险品qbl锰qblg锰qbmq迎风qbn怨qbnf独出心裁qbnj凶悍qbnt危险性qbnu怨qbnv怨恨qbp迎qbpk迎qbpr迎宾qbq鸳qbqg鸳qbqs凶杀qbqt凶狠,凶猛qbrn怨气qbrt凶手qbru迎接qbs锕qbsk锕qbud迎送,迎头,迎着qbus迎新qbwg迎合qbwh迎候qbws独联体qbyy怨言qc色,勾,钗qcb色qcbq杀鸡取卵qcce勾通qces色彩qcf铎qcfh铎qcgl勾画qcgu犹豫不决qcgx色素qci勾qcic色泽qcn钯qcng色情qcnt针对性qcqi勾销qcxf勾结qcxr杀鸡给猴看qcy钗qcyf乐观主义者qcym色调qcyy钗qd然,希,危qdb危qdbb危qdbw危险qdc郄,钹qdcb郄qdcw危难qdcy钹qddh鲜艳夺目qddm然而qdds希奇qde肴,铕qdef肴qdeg铕qdey危及qdf锛qdfa锛qdft铁面无私qdg钴qdh锲qdhd锲qdhk争夺战qdiv鱼龙混杂qdjq危在旦夕qdm希,郗,欷qdmb郗qdmh希,钸qdmw欷qdn铖qdne铁石心肠qdnt铖qdo然qdou然qdpd危害qdpw希罕qdpy名存实亡qdqc银灰色qdqp久而久之qdqv危急qdrg然后qdrt多面手qdsm危机qdt铸qdtf铸qdtg危重qdu镣,镢qdui镣qduw镢qdux希冀qdw詹qdwf留有余地qdwg煞有介事qdwy詹qdy钛qdyn危房,危亡,希望qdyy钛qe角,解,触qeae解散qeai角落qebk解职qebm解聘qebw解除qecl解劝qecw解难qedw触礁qedy名胜古迹qeep角逐qeeu解脱qeey触及qef锊,锾qefc锾qefi解救qefy锊qeg钥,锄qega解开qegi觫qegl锄qegx解毒qei觥qeij解渴qeiq觥qej角qejg钥匙qejy触qelf解围qen觖qent触发qenv解恨qenw觖qepn解密qeqc角色qeqe触角qeqt触犯qer觚qera触摸qery觚qet钐,觞qeto解释qetr觞qetw解答qeu斛,觯qeua解冻qeuf觯,斛qeuk解剖qeun解决,解闷qev解,蟹,邂qevh解qevj蟹qevp邂qews解体qeya角度qeyn解雇qeyt解放qeyu解说qf针,镇,铐qfay销声匿迹qfcf针对qfdf镇压qfdr名声大振qfft独裁者qffu怨声载道qffw急起直追qfg钍qfge镇静qfgm针刺qfh针qfhw镇qfia镇江qfkg锣鼓喧天qfkk急需品qfkq名震中外qfl镭qflg镭qfpg镇定qfqa多才多艺qfqn铜墙铁壁qfqy针灸qfrm包干制qft锗,铑qftj锗qftn铐qftx铑qfuh急救站qfww外地人qfwx多元化qfxk针织qg钱,鱼,鲁qga鲽,鳓qgal鳓,鱼苗qgap名副其实qgas鲽qgaw鲜花qgb印,钝,鲰qgbc鲰qgbh印qgbn钝,免不了qgc鲐,鳋qgcj鳋qgck鲐qgd鱿,鲔,鳜qgdc鲅qgdd鲱qgde鲔qgdh鲜艳qgdj鲕qgdm铺面qgdn鱿qgdw鳜,怨天尤人qge铺,匍,鳐qgeg锖qgem鳐qgew乐于助人qgey铺,匍qgf鱼,鲑,鳍qgfd急于求成qgff鲑,独一无二qgfj鳍qgfk鲒qgfm鲼qgft鲮qgfv鳕qgfy鱼塘qgg鲆,鲠,鲡qgga铺开qggd鲸吞qgge鲭qggh鲆qggp名不副实qggq鲠qggu铺平qggy鲡qgh钙,鲇,鲈qghg钲qghk鲇,狼吞虎咽qghn钙,鲈qghw名不虚传qgi盥,钚qgil盥qgiv印染qgiy钚qgj鲁,鳗,鲤qgjc鳗qgje鲜明qgjf鲁,鲤,鲣,鲥qgjg鱼虾qgjj鲳qgjn鳎qgjx鲲qgk匐,鳄,镉qgkh镉,铺路qgkl匐qgkn鳄qgl鳃,鳏,鲢qgld鲴qgli鳏qgln鳃qglp鲢qglv铺轨qglw金融界qgm鲷,鳢qgmf钱财qgmk鲷qgmu鳢qgmw鱼肉,名不见经传qgn鲺qgnj鲺qgnm印刷qgnt印发qgo鳞,铼qgod鱼类qgog金融业qgoh鳞qgov印数qgoy铼,钱粮qgp鲩qgpq鲩qgpt独到之处qgq鲍qgqd兔死狐悲qgqg鳄鱼qgqj印象qgqn鲍qgr鳇qgrg鳇qgrm负责制qgrv铺垫qgs鳔qgsd急不可耐qgse解囊相助qgsi鳔,锐不可当qgst急不可待qgt钱,稣,鳅qgta镇静自若qgti鲧qgtl鲜血qgtm钱币qgto鳅qgtr钱物qgts鲦qgtt鳆qgty稣qgu鲜,鳟,鲛qgua名列前茅qgud鲜qguf鳟,铺天盖地qgug铺盖,鲜美qguj印章qguk鳝qguq鲛qgut迎来送往qguw铗qgv鲟qgvb鲫,鲵qgvf鲟qgvg鲜嫩qgvl鲻qgvq鲵qgvy锦囊妙计qgw鲋,鲶qgwd杀一儆百qgwf鲋qgwn鲶qgwt负责任qgww负责人qgxa鲜红qgxt铺张qgy鲸,鳊,钰qgya鳊qgyh鳙qgyi鲸qgyj鲚qgyk名正言顺qgym铺设qgyn鲂qgyy钰qh外,钻,钋qhan独具匠心qhap钻营qhbm外出qhc铍qhcm外观qhcy铍qhdg钻石,钻研,外厂qhdh外在qhdm外面qhee外貌qheg外县qhfb外地qhfc外运qhfj钻井qhfp外壳qhg钼qhga外形qhge外表qhgi多此一举qhgk外事qhgs独具一格qhgu独占鳌头,乐此不疲qhia外汇,锦上添花qhig鱼目混珠qhiy外流qhjn外电qhjy外景qhk钻qhkg钻qhld外因qhlf外围qhlg外国qhlk外加qhlp外边qhlw外界,外轮qhnf外层qhnn外快,触目惊心qhpr外宾qhqi外销qhqy外贸qhre外援qhrp钻探qhta外长qhtd外籍qhtf外行qhth外延qhtl外务qhtm外币,外向qhtq名目繁多qhtu外科qhuk外部qhum外商qhuq外交,外资qhwg外债qhwt外伤qhww外人qhxc外经qhxg外线qhxt外乡qhy外,钋qhyg外语qhym外调qhyy外文qi乐,尔,锁qibw乐队qicm乐观qie销qieg销qifh乐趣qig玺qigd独当一面qigk乐事qigy玺qii乐qijg销量qikh销路qikk乐器qikm名演员qilf乐团,乐园qili饮水思源qim锁qima乐曲qimm乐山qimy锁,销赃qin铴qing鱼水情qinr铴qip迩,镗qipf镗qipi迩qiq铫qiql锁链qiqn铫qisf钞票qit钞qitg留学生qitt钞qitu多学科qity销往qiu尔qiuj乐意,乐章qiut多渠道qiuu金光闪闪qiv铛qiva销毁qivg铛qiww多党合作,销价qiwy销售qj旬,龟,象qjb郇qjbh郇qjc铿qjcf铿qjd旬qje象qjeu象qjf锂qjfg锂qjg钽,锝qjgf锝qjgg钽qjh钊,刈qjjg贸易量qjl镘qjlc镘qjlw贸易界qjn龟qjnb龟qjpt贸易额qjq锡qjqr锡qjs锞qjsy锞qjtg象征qjtn触景生情qjuk贸易部qjum贸易商qjwr锡伯qjx锟qjxx锟qjyj杀虫剂qk名,句,够qkaf名著qkat名医qkbk免职qkbw免除qkd句qkdd勉励qkep钟爱,免受qket名胜qkf名qkfc免去qkfd名城qkfn名声qkg锃qkga免刑qkge钟表qkgf免于qkgg锃qkgm免遭qkgq名列qkh钟,钏qkhh锺,钟,名目qkip名堂qkis名酒qkiw名誉qkiy名流qkk铝,锷qkkg铝qkkh名贵qkkn锷qkl劬qkln劬qkm锅,铞qkmh铞qkmm名册qkmw锅qkng钟情qknh免收qknn铁路局qkoy锅炉qkpb名字qkpe名家qkpt名额qkq免,勉,逸qkqb免qkqg鸲qkql勉qkqp逸qkqq够qkqy兔qkrn名气qkrt名手qkst狭路相逢qktg免征qkth名牌,名片qktj免得,名利qktq名称qktt急中生智qktu免税qkud钟头qkuj名单qkum免疫qkuq名次,名将qkwd名优qkwt名作qkww名人qkxg铁路线qkxj免费qkxk勉强qkym银川市qkyn名词,名望qkyq名义qkyy名言ql甸,链,锣qlbb兜圈子qld甸,锢,铟qldg锢qldq包罗万象qldy铟qlfg急转直下qlfk锣鼓qlg钿qlh钾qln锶qlny锶qlp链qlpy链qlq锣,镯qlqj镯qlqy锣qlts链条qlx镙qlxi镙qlyx犯罪率qm负,铜,钢qmaw负荷qmbf铜陵qmd奂qmdg钢厂,金刚石qmdk名山大川qmdu奂qmdy铜矿qmfa负载qmfh负起qmg铀qmgf多见于,负于qmgk铜qmgm负责qmj铡qmjh铡qmk铅qmkg铅qmkt铜川qmn铠qmnn铠qmq钢qmqg铅印qmqp钢锭qmqr钢铁qmqy钢qmrj负担qmsf钢材qmsr钢板qmte钢筋qmtg负重qmth铜牌qmtp钢管qmtt铅笔qmu负qmw钠qmwg负债qmwq铜像qmwt负伤qmwy钠qmy钡,钒qmyy钒qn包,饱,饭qna饶,馍,馑qnaa包工qnad馍qnae饭菜qnag馑qnaq饶qnat馓qnay饥荒qnb饣,饵qnbb包子qnbg饵qnc饴qnck饴qnd锯qnde饶有qndg锯,印刷厂qndp饭碗qnds饭厅qne馁qnen狠心肠qnet饮用qnev馁qnf钮,饽qnfb饽qnfc乌云qnfg钮,包干,饼干qng乌,饯,馕qngb邬qngd乌qnge馕qngn饨qngq饿死qngt饯qnh镅qnhg镅qnhj饭桌qnia饱满qnib包涵qnii饮水qnip饱尝qnis饮酒qnit乌海qnj蚀,馒,刨qnjc馒qnjh刨qnjk印刷电路qnjx馄qnjy蚀qnk馈qnkk印刷品qnkm馈qnkt独辟蹊径qnlf包围,乌黑qnlw包办qnm饥qnmn饥qnmu包赔,馈赠qnn钇,钆,饲qnnk饲,锔qnnr饧qnnw馔qnou饲料,饮料qnp馆qnpn馆qnpu包袱qnpw包容qnq饮,馋,馅qnqi包销qnql馏qnqn饱,饭馆,饥饿qnqu馋qnqv馅qnqw饮qnr饭,饩qnrc饭qnrg饭后qnrj包揽qnrn饩,包扎qnrt包括qns馇qnsf饭票qnsg馇qnt饿,饰,饷qnta馆长qntd饫qnte包租qntf饪,饯行qnth饰qntk饷,饱和qntl饬qntt饿,铋qnu饼,饺,馐qnua饼qnud饲养qnuf馐,包装qnug多发病qnuq饺,多层次,勾心斗角qnv包,馊qnvc馊qnve包退qnvi多快好省qnvk饶恕qnw馀qnwg饭盒qnwh包修qnwt馀qnwy包含,饱含,饮食qnx铌qnxn铌qnyf饭庄qnyh饭店qnyj包裹qnym铭心刻骨qnyt多民族qnyx包庇qo炙,镂,鬯qob鬯qobx鬯qog镤qogy镤qoo锬qooy锬qopx鱼米之乡qou炙qouc触类旁通qour乌烟瘴气qov镂qovg镂qoy钬qp锭,夤,镲qpbb钻空子qpbq鳏寡孤独qpe镓qpey镓qpfa金字塔qpg锭qpgh锭qpgq凶神恶煞qpgw夤qpnt危害性qpqn迎宾馆qpr镔qprw镔qpta镇定自若qpth留守处qpv铵qpvg铵qpvm铁案如山qpw镩qpwh镩qpwi镲qpx铊qpxn铊qq多,钩,钓qqad多项qqb匈qqbb金子qqbk匈qqc钩,铯qqcn铯qqcy钩qqdp多达,铁饭碗qqdq久负盛名qqdt争名夺利qqdy金矿qqes多彩qqet多用qqfc多云qqfi凶多吉少qqfn多亏qqfq多元qqg镥qqgf多于,狼狈不堪qqgj镥qqgk金融qqi铄qqii多多少少qqiq金光qqit多少qqiy铄qqjf多时qqjg外销量qqjj多日,金昌qqk铭qqkf狗急跳墙qqkg铭qqlg多国,急刹车qqlp多边qqlw多办qqmj多则qqmq金刚qqn钨qqng钨qqnh多收qqnn匆匆忙忙qqnt金属,多发qqov多数qqpe多家qqpt金额qqq鑫qqqc金色qqqf鑫qqqg钓鱼,金钱qqqq金qqr锪qqrh多年qqrn锪qqs铩qqsc针锋相对qqsg金杯qqsu多样qqsy铩,乌鲁木齐qqt铆qqtb铆qqtc多么qqth金牌,多处qqtj多得qqtk多种qqu多,爻,钧qqud多头qqug钧qquk外贸部qquq多次,金奖qqv铮qqvb多好qqvh铮qqw钦qqwh多个qqwm钦佩qqwt多余qqwx金华qqwy钦qqxx勉勉强强qqy钓,镏qqyk犯错误qqyl镏,金库qqyn铭记,铭刻qqyo多变qqyt多谢qqyv狼狈为奸qqyy钓,多方qr铁,勿,锦qrc钣qrcy钣qrdy铁矿qre勿qrg铂qrgl久拖不办qri铢qriy铢qrj刎qrjh刎qrkh铁路,留后路qrkq名扬中外qrli名扬四海qrlt忽略qrlv铁轨qrm锦qrmh锦qrn忽,兜qrnq兜qrnu忽qrny匆忙qrpy忽视qrq锨qrqc银白色qrqd忽然qrqr匆匆qrqw锨qrrj兜揽qrrt留后手qrsf锦标qrsg锦西qrsr铁板qrtg多年生qrub忽闻qrud铁拳qruq金质奖,银质奖qrut铁道qruy铁门qrw铁qrww铁人qrwy铁,兜售qrxt锦绣qry匆qryg铁证qryi匆qrys错失良机qryt锦旗,锦州qs钉,杀,弑qsa弑qsaa弑qsal杀菌qsbb钉子qsdg危机感qsf镖qsfi镖qsg钵qsgf铁板一块qsgg钵qsgm独树一帜qsgq杀死qsh钉qsj刹,镡qsjh刹,镡qsk钶qskg钶qslg刹车qslw危机四伏qsnt多样性qspd杀害qspf锦标赛qstd乐极生悲qsu杀qsvf刹那qswt杀伤qsww杀人qswx多样化qswy刹住qsxf凶相毕露qt儿,猜,狠qta猎,猫qtad狨qtaj猎qtal猫qtar争先恐后qtat猛攻qtay獾,锋芒qtb犯,猛,狲qtbb儿子qtbh卯qtbi狲,儿孙qtbj夕阳qtbl猛qtbn犯qtbu狭隘qtbv独生子女qtc狁qtca儿戏qtcb犹豫qtcg犸,猱qtcn名利双收qtcq狁,狂欢qtcs猱qtct狻qtd锋,犹,獗qtde猢,独有,犯有qtdh锋qtdi獠qtdk猗qtdn犹qtdw獗qtdx独龙qte锈,犭,狙qteg狙qten锈qtf钎,猪,猿qtfa独霸,独裁qtfc铥qtfe猿qtfh钎,犴qtfj猪qtfk锆qtfp铤qtfq铣qtfs橥qtfu猛增qtfv锸qtfw犯规qtg狂,锤,逛qtga外向型qtgc独到qtge猜qtgf锤,锺qtgg狂qtgh犯下qtgk狡赖,名垂青史qtgm獭qtgn钅qtgp逛qtgq猛烈qtgw狭qth镍qthk独占qths镍qthw独具qtif犯法qtih狭小qtim猜测qtix猛涨qtj独,狸,狮qtja狂暴qtjf狸qtjg猩qtjh狮qtjj猖qtjs猓qtjy独qtk铬,狷qtke狷qtkg铬qtkh猛跌qtl狎,猥,猬qtld犯罪qtle猥,猬qtlh狎qtlq猡qtm猾,狈qtme猾qtmq狂风qtmw猪肉qtmy狈qtn儿,勹,夕qtnf狃qtnh猸qtnt象征性qtny夕,狠心qto锹,狄,逖qtoa锤炼qtop逖qtoy锹,狄qtp狞,狩qtpe独家qtpf狩qtpl急行军qtps狞qtpw狭窄qtq狗,狰,狍qtqd猝然,猛然qtqh狰,獬qtqk狗qtqn狍qtqt猖獗,猖狂,狠狠,狡猾,狼狈,狰狞,急先锋qtr狐,锇qtrj独揽qtrr狠抓qtrs猛打qtrt锇qtrv狂热qtry狐qts猹qtsg猹,猛醒qtsh猜想qtt猁,獯qtta狭长,猛升qtth独自qttj猁,锋利,独得qtto獯qttr独特qtu狡,獐,獍qtug多管闲事qtuj獐,儿童qtuk猛冲qtuq獍,狡,独资,金牌奖qtut名特产qtuu独立qtuy狡辩qtv狠,卿,犰qtvb卿qtve狠qtvk犹如qtvn犰qtvq猊qtvv儿女qtw猴,狯,狳qtwb独创qtwc狯qtwd猴qtwi猃qtwk猞qtwt狳qtww犯人qtwx名牌货qtx狒,猕,狴qtxf狴qtxi猕qtxj狒qtxt猜疑,犹疑qty狼,狱,犷qtyd狱qtye狼qtyf猝qtyg狺qtyn狂妄qtyq狭义qtyt犷,狡诈qu匀,镜,铲quab儿童节qubb镜子qubw铲除qud匀,锩qudb锩quf钭qufh钭qug镁,锎,镧quga锎qugd镁qugi镧quh锌quj镜,锏,镱qujg锏,钢产量qujn镱qujq镜quk锐,锫qukg锫qukq锐qulw外交界qum镝qumd镝qun钔qunt独立性quo镨quoj镨qup镑qupj乌兰察布盟qupn外交官qupy镑quq铰,锵quqf锵quqy铰qurn锐气qusx鳞次栉比qut铲qutj锐利qutq匀称qutt铲quud镜头,锐减quuj锐意,解决问题quuk铁道部,外交部quw镒quwl镒quwu外单位qux锑quxj包装费quxt锑qv争,银,急qvaj银幕qvav急切qvb邹qvbc争取qvbh邹qvdf争夺qvdh争艳qvdq迎刃而解qve银qvet急用qvey银qvf键,刍qvfa争霸qvfd急需qvfi急救qvfm银南qvfp键qvg钕qvga雏形qvgf急于qvgk急速qvh争,皱,锼qvhc皱,锼qvhj争qviq争光qvis银河qviv争当qviy急流qvk铷qvkg铷qvkh急躁qvki争吵qvkq争鸣qvkt银川qvl锱qvlf银团qvlg锱,煞车qvlw争办qvmq争购qvn急qvnd急剧qvnt急性qvnu急,银屏qvny急忙qvp锓qvpc锓qvrn争气qvrp急迫qvrv争执qvsc争权qvsg银杯qvsh争相qvsv银根qvt煞qvte键盘qvtf银行qvth银牌qvto煞qvuf争斗qvuj刹那间qvum争端qvuq银奖qvuy争辩qvw雏qvwb争创qvwk急促qvwr急件qvwu键位qvwy雏qvxy皱纹qvyw急诊,争论qvyy争议qw欠,铃,飧qwd锻qwdc锻qwdt争分夺秒qwev欠妥qwff欠款qwfn铃声qwg铨,镫,铪qwgg铨qwgh杀人不眨眼qwgk铪qwgp销售一空qwgr镎qwgt杀人不见血qwgu镫qwjg销售量qwmc独领风骚qwmh欠帐qwnh欠收qwnt独创性qwoa锻炼qwog饮食业qwpt销售额qwpw乌合之众qwqq铝合金,铁合金qwrm欠缺qwts欠条qwtu欠税qwu欠qwuk销售部qwus名优新qwut欠产qww锉qwwf锉,贸促会qwwg欠债qwx铧qwxf铧qwy铃,锥,镌qwyc铃qwye镌,飧qwyg锥qwyn钤qx镪,镄,锴qxan煞费苦心qxim锦绣河山qxj镄qxjm镄qxk镪qxkf外强中干qxkj镪qxmb外引内联qxmf饱经风霜qxmh乌纱帽qxsq钢结构qxtv错综复杂qxuk外经部qxut锦绣前程qxx锴qxxr锴qy久,鸟,留qya镀qyac镀,勉为其难qyaq解放区qyat鸟语花香qyb镦qybt镦qyc铳,锍qycq铳,锍qycy留驻qyd訇qydh留存qydm多方面qydn留成qye铱,锿qyet留用qyey铱,锿qyfn久违qyft解放者qygh留下qyhn鸟瞰qyi久,勺qyip留学qyjq贸易qyjy留影qyk镶qyke镶qykl久别qylg岛国qym镐,铈,钪qyma镶嵌qymg岛屿qymh铈qymk镐qymn钪qyn钫,岛,枭qync鹱qyne袅qyng鸟,留情qynm岛,凫qyno镳qyns枭qynt多义性qynx鸵qyny留心qyo灸qyou灸qypf留守qypg急诊室qypl解放军qypr解放军报qypy留神qyqq镀金qyqv镀银qyqy久留qyrg解放后qyt卵,孵,镞qytb孵qytd镞qyth镟qyty卵qyu镰qyug留美qyuj留意qyuo镰qyv贸,遛,锒qyve锒qyvh镛qyvl留qyvm贸,铁证如山qyvp遛qywk危言耸听qywq久仰qywt留任,鲜为人知qywx孵化qywy留念qyx铉qyxc久经qyxw留给qyxy铉qyyo留恋qyyy留言r的,年,把ra找,摸,捞raa拭raag拭raai白茫茫raak手工艺品raan手工艺rab皂rabc捞取rabm找出rad撕radb打基础radg兵工厂,失落感,制药厂radh撕破radr撕rae撒raet撒,拔苗助长rafa搭载rafp摸索raft拓荒者rag扛raga撕开ragc找到ragi拒不ragq撕裂ragx抗菌素raia缺医少药raig摸清raj措,揠rajd摸rajg措,捕获量rajv揠ral描ralf摸黑ralg描,披荆斩棘ramd拒贿ramw近期内ran拒,拣,揲rang拒ranh拒收ranj打草惊蛇rans揲rant迫切性ranw拣raog手工业rap捞rapg描写rapl捞raq抠raqy抠,技工贸rarh撕扯,撕掉rart撒播,撒手raru撒拉rarv投其所好rasg搭配rasy描述rat找,挠ratd措辞ratq挠ratu搭乘raud抓苗头rauk后勤部rava撕毁ravf找寻raw拱,搭,搽rawf拒付rawg反革命rawk搭raws搽rawy拱raxq拒绝raxw描绘rayi邀功请赏raym拉萨市rayn措词,找遍rayq摸底rayt措施rb报,摄,拙rbaq报警rbb揶rbbh揶rbbu推陈出新rbc报rbcc摄rbcy报rbdc排除万难rbfi拯救rbfj报刊rbfk报喜rbft报考rbgc报到rbge报表rbi拯rbig拯rbit拙劣rbjf报时rbjy摄影rbld报恩rblg报国rblw报界rbm拙rbmh拙,报帐rbnn排除异己rbny报以rbog报业rbpj报审rbpv报案rbpy报社rbqa摄氏rbqe据了解rbqi报销rbqk报名rbrg报捷rbrm摄制rbrx报批rbsg报酬rbsp摘取桂冠rbtf报告,指出稹rbtj报复rbtl报务rbtw报答rbud报送,报头rbuq报效rbut报道rbwq摄像rbwv报仇rbww报价rbxq报纸rbyg报请rbyn报废rc反,抬,瓜rca拚rcaa返工rcah拚rcaj瓜葛rcat反攻rcb抒,揉rcbb摊子rcbh抒rcbs揉rcc掇,搡rcca把戏rccc掇rccf反对rccq反驳rccs搡rcd掺rcde掺rcdg反感rcdi反骄破满rcdm反而,反面rce捅rceh捅rcf择rcfc反动rcfh择rcfm反击rcge返青rcgh反正rcgk挨整rchh反目rchk反战,摊点rci反rcip反常,反党,拍巴掌rciq反光rcir摊派,反对派rcit反省rcjm反映rcjp捅马蜂窝rck抬rckg抬rckt反响rclf反转rclk返回rcln反思rcmr摊贩rcn把rcng抒怀,抒情rcnt反悔,抒发rcnx拍马屁rcp返rcpf把守,擂台赛rcpi返rcpp反之rcpu反衬rcqi返销rcqn挨饿,反馈rcrf把持rcrg拚搏rcrn把握rcrp挨近rcrs挨打rcrt反手rcry反抗rcsg把柄rcsu返校rct挨rctd挨rcte返航rcth摊牌rctj反复rctm反射,反向rcud挨着,反叛,抬头rcuk反问rcw摊rcwd择优rcwg反倒,拚命rcwh挨个rcwn掺假rcwu摊位rcwv瓜分rcwy摊rcxx反比rcy瓜,搔,瓞rcyi瓜,反应rcyj搔rcym抬高rcyw瓞rd拓,排,捧rdad掩藏rdai振荡rdau掩蔽rday拓荒rdb扼rdbn扼rdbw排除rdc拔rdcy拔rddg扑面而来rddl振奋rddm抱有成见rdf振,拜,挎rdfb所在地rdfc扰动,振动rdfe振rdff捱rdfh拜,捧走rdfi捺rdfj皋,掩埋rdfn挎,翱,排场,捧场rdg拓,撼rdgf排球rdgn撼rdgq排列rdgt打成一片rdgx拧成一股绳rdhj看在眼里rdia排泄rdid拔尖rdif排污rdiv挑大梁rdiw振兴rdj排,掩rdjd排rdjg拜师rdjm掩映rdjn掩rdm颀rdmy颀rdn扰rdna拓展rdnh迫在眉睫rdnn扰,近在咫尺rdnt势在必行rdp挞rdpa拓宽rdpb排字rdpf扼守rdpn后顾之忧rdpy挞rdqe排解rdqg排印rdqh排外rdqn挎包,掩饰rdqs扼杀rdrh拜年rdrt拜托rdry排斥,排挤,掩护rds掎rdsc所有权rdsk掎rdsv扼要rdsy反唇相讥rdta排长rdtd扰乱rdth排版rdtt失而复得rdu撩,撅rdud翱翔rdug掩盖rdui撩rduw撅rdva技压群芳rdvd技压群雄rdw捧,揍rdwd揍rdwf扩大会rdwh捧rdwm抱有偏见rdwt振作rdx拢rdxa排练rdxg抛砖引玉rdxi拉帮结派rdxn拢rdxw拉帮结伙rdyp推而广之rdyt排放rdyy拜访re扔,摇,拥recb授予rede拥有reeg援助reeu热腾腾ref援,捋refa拥戴refc援,摇动refi援救refy捋regh扔下reh拥reie披肝沥胆reji摇晃rekm授勋relf摆脱困境ren扔rep授repc授repl拥军,援军reqh援外reqn掏腰包rer摇rerg援兵rerh扔掉rerl摇摆rerm摇rerq拥抱reru挑肥拣瘦rery拥护,拥挤resc授权retj摇篮retq授衔reud摇头reuj授意reuq授奖revf援建rewg授命rexh援引reyj授课rf持,技,挂rfag技巧rfan技艺rfaq欣喜若狂rfar失魂落魄rfbk挂职rfc技rfce技能rfck擂台rfcy技rfde持有rfdf拔地而起rfdg质感rfdp挂牵rfeg扶助rff持rffb质地rffe扭亏增盈rffg挂rffu抢救无效rffy持rfgo反过来,看起来rfgp挥霍一空rfgu持平rfh盾,遁rfhd盾rfhp遁rfir反动派rfj擀rfjf擀rfjg技师,质量rfjm挂帅rfk拮,撷rfkd抚顺rfkg拮,挂号rfkm撷rfl擂rfld接二连三rflg擂rflt势均力敌,推动力rfm质rfmh拷贝rfmi质rfn抟rfnf抚慰rfnt抚恤,技改rfny抟rfp挝rfpg按规定rfpt后起之秀rfpy挝rfq抚rfqe挖墙角rfqk挂名rfqn抚rfqq挂钩rfqt抢劫犯rfqy持久rfra抚摸rfrd抗干扰rfrf扶持rfrn拮据rfrs拷打rfrt打击报复rfrw挂失rfrx扶老携幼rfsf扶植rfsh质朴rfsu技校rfsy技术rft拷rftf挂靠rfth盾牌,挂牌rftn拷rfty年增长率rfud抚养,扶养,年过半百rfuk质问rfw扶,撵,攉rfwl撵rfwv扶贫rfwx年老体弱rfwy扶,攉,挂念rfxf持续rfxt质疑rfyc抚育rfye扭亏为盈rfyq质询rfyt抚州rg后,兵,捕rgad后期rgak后勤rgan后世rgap兵营rgaq捕获rgb邱,卮rgbf丘陵rgbh邱rgbm看不出rgbt探囊取物rgbv卮rgca后劲rgck后台rgcn兵马rgd丘,掭rgdm后面rgdn掭rge捕,搏rgef搏rgen拥政爱民rget迫不及待rgey捕rgf皇rgff乒坛rgfh看不起rgfj后进rgfm搏击,抨击rgfq年平均rgft执政者rggd后天rggk后事rggo后来,接下来rggu势不两立rgh扌rghg扌rgip执政党rgjs后果rgk后,捂,攮rgkd后rgke攮rgkg捂rgkh后路,看不顺眼rgkk兵器,后患rgkm兵员rgkp逅rglf兵团rglp后边rglq据理力争rglt兵力rglw誓不罢休rgm岳rgmj岳rgmq看不见rgnh后来居上rgnt后悔rgnx看不惯rgny年事已高rgp遑rgpd遑rgpe皇家rgpf皇冠rgpg皇室rgpk皇宫rgpt所到之处rgqg捕鱼rgqn手下留情rgqs捕杀,抹杀rgra捕捞rgrb捷报rgrc捞一把rgrg乒乓,近一年来rgrk捕捉rgry后撤rgs抹rgsi势不可当rgsr势不可挡rgsy抹rgt乒rgtc捷径rgtk兵种rgtl后备rgtm兵役rgtn迫不得已rgtr乒rgu挟,抨rgud后头rguf搏斗rguh抨,兵站rgup皇帝rguw挟rguy后门rgv捷rgve后退rgvh捷rgw兵rgwa后代rgwt后任,担责任rgwu兵rgww接班人rgwy捕食,捂住rgxf后续rgy乓rgyo兵变rgyu乓,按理说rgyw反政府rgyy后方rh年,看,牛rha掳,摅rhab年节rhal掳rhan摅rhb卸rhbh卸rhbm看出rhbv年限rhbw掉队rhc披rhca看戏rhck看台rhcy披rhdl年历rhdm扑面rhdn看成,年成,年迈rhee年月rhf看rhfh爬坡rhfj年刊rhfk年,披露rhfp看过rhfq年均rhft年老rhg扯rhgc看到rhge年青rhgh年下,卸下rhgk年事rhgo看来,年来,扑灭rhgs年末rhh攫rhhc攫,扯皮,牛皮rhhw年龄rhia年满rhif看法rhix看涨rhj掉rhjh掉rhjt年鉴rhjy年景rhk牛,拈rhkg拈rhkh看中,年中rhkm指战员rhlc年轻rhlf掉转rhlg卸车rhlw年轮rhmm爬山rhmq看见,年岁rhmw年内rhnn看书,挑战书rhnt拭目以待rhoo扑火rhpf看守rhpu年初rhpw扑空rhrb看报,年报rhrg近些年来,年后rhrq掉换rhry看护rhte看透rhtf看待,爬行rhtj年利rhtp看管rhud掉头,年头rhue年前rhug看病,找上门来rhuj年间rhut年产rhvb看好rhve牛奶rhwa年代rhwt卸任rhww年份rhwx年华,年货,卸货rhxe年级rhxn年纪rhxt年终rhy扑,爬,爪rhya年度rhyc爬rhyi爪rhyn看望rhyq年底ri朱,挑,泉rib邾ribh邾ridx抄袭rie捎rieg捎rieh热泪盈眶riei推波助澜rifc搅动,挑动rifh挑起rifm拦河坝riga换汤不换药rigg执法不严rigi拖泥带水rigk捎带rigm挑刺rihk挑战rii朱riid泉源riiq排水沟riiy反潮流rijg排水量rijq挑剔rikc挑唆rikh挡路rilk挡驾ring执法必严rinh抄收rip撑,搅ripg抄写,据测定ripq搅ripr撑riq挑riqn挑rira挑拣rirn挑拨riru搅拌risa反法西斯risc近水楼台rit抄ritd搅乱ritf挑选ritl挑衅ritt抄ritx排水系统riu泉riud抄送riv挡rivf挥汗如雨rivg挡rivi抄录riwy挡住riyt泉州rj提,捏,担rjaj揭幕rjb撮rjbb担子rjbc撮,提取rjbg捍卫rjbm提出rjdg热电厂rjdn提成rjey提及rjf捍rjff提款rjfg捏,提干rjfh捍,提起rjfi揭示,提示rjfk揭露rjg担rjga揭开rjgc提到rjgg担rjgh提rjgo近日来rjh抻rjhh抻rjiv担当rjja揭晓rjjh提早rjlk担架rjnd担忧rjnt揭发rjny担心rjoa提炼rjpj提审rjpv提案rjpw揭穿rjq揭rjqk提名rjqm担负rjqn揭rjrb打电报rjrd提拔rjsg提醒rjsj哲里木盟rjst指日可待rjsv提要rjt揽rjta提升rjtf捏造rjtq揽rjud质量关rjue提前rjuj提单,挤时间,抢时间rjuk提问rjuq提交rjuu握紧拳头rjwa提供rjwj提倡rjwk担保rjwt担任rjww提价,鬼蜮伎俩rjwx提货rjx拽rjxe提级rjxg提纯rjxm提纲rjxt拽rjyg提请rjym提高rjyt打电话rjyy提议rk扣,捉,操rkap操劳rkb揖rkbb扣子rkbg揖rkbw扣除rkc挹rkcn挹rkcy拐骗rkdf扣压rkdg接踵而来,接踵而至rkdi损耗rkds手中有权rke捐rkeg捐,捐助rkff捐款rkfg损坏rkfm捐献rkfn操场rkfp后患无穷rkfr手足无措rkft失足者rkg扣rkga捉弄rkh捉rkha拦路虎rkhp探听虚实rkhy捉rkk操rkks操rkkt气呼呼rkkw打哈哈rkl拐,捌rklj捌rkln拐rkm损rkmu捐赠rkmy损rknt扣发rkny操心rkpd损害rkpg兵贵神速rkpn手足之情rkqs扣杀rkqy扣留rkra捉摸rkrf操持rkrl扣押rkrw损失rksd拐杖rksj拐棍rktf操行rktm捐躯rktw捷足先登rkud摔跟头rkug后遗症rkuq捐资rkwg捉拿rkwt操作,损伤rkwy捉住rkxa操练rkxw操纵rkyo拐弯rl押,摆,舞rlck舞台rld摁rldm摆布rldn摁rldy年轻有为rleu摆脱rlf摆rlfc摆,摆动,舞动,押运rlg舞,掴,擐rlga摆弄rlge擐rlgh舞,摆正rlgo接连不断rlgw年轻一代,招架不住rlgy掴rlh押rlia摆满rliy摆渡rlkh舞蹈rllu年轻力壮rlnt拈轻怕重rlpf接力赛rlqe押解rlqq押金rlrn捆扎rls捆rlsy捆rlt撂rltk撂rlum舞弊rlww年轻人rlwx年轻化rlx摞rlxd捆绑rlxi摞rlym摆设rm抽,投,缺rma缸,罐rmag缸rmak缺勤rmay罐rmbb扣帽子rmbc抽取rmbm抽出rmbq缺陷rmbt投降rmbw担风险rmc投rmcy投rmd揣rmdf投奔rmdj揣rmdn制成rmeb制服rmet制胜rmfa制裁rmfc制动rmfh抽走rmft失败者rmg抽rmgd近几天rmgg近几天来rmgq摧残rmh帛,制,罅rmhh罅,制止rmhj制,帛rmhk缺点rmhr掣rmii抽水rmim揣测rmit缺少rmiu抽泣rmk缶rmkk缺口,制品rmlt制图rmm撄rmmg近几周来rmmq抢购风rmmv撄rmn缺,皑rmna抽屉rmnn皑rmnw缺rmol抽烟rmpd投寄rmpg制定rmpt缺额rmpv投案rmpw抽空rmqj抽象rmqw缺欠rmrg近几年来rmrh抽掉,近几年rmrj捕风捉影rmrk缺损rmru所见所闻rmsf投标,投票rmsj抽查rmsm投机rmsu抽样rmsw抽检rmtf投靠,制造rmtl制备rmtm投身,投向rmtp缺乏rmtw抽签rmty投入rmud投送rmuq投资rmut投产rmuw制冷rmux投递rmva摧毁rmw摧rmwd制做rmwi排山倒海rmwk投保rmwt制作,看风使舵rmwx缺货rmwy摧rmxq制约rmxy缺编rmya揣度,缺席,制度rmye反败为胜rmyj制剂rmym抽调rmyr投诉rmys揣摩,制订rmyt投放rn所,气,据rna抿,搌rnae搌,后悔莫及rnal气功rnan抿rnb气,掘,撖rnbm掘rnbt撖rnc氢rnca氢rnce拨通,所能rnd据,氪rnde所有,握有rndf气压rndg据rndh所在rndq氪rne氖rneb氖rnec氮肥rnen担惊受怕,热心肠rnet手忙脚乱rnf扭rnfc拨动,气动rnff拨款rnfg扭rnfj掘进rng握,氰,氩rnga拨弄rngc所致rnge氰rngf握,拟于rngg氩rngh指导下rnhx据此rnij气温rnir气派rnj氘,氲rnjg气量rnjj氘rnjl氲rnk擗,氚rnkj氚rnkm指导员rnkr扬眉吐气rnku擗rnl氤rnld氤rnle推心置腹rnlf扭转rnln掉以轻心rnlt气力rnm氙rnma扭曲rnmj氙rnmq所见rnn扎,撰rnnf气愤rnnt所属rnnw撰rnny气恼,所以rno氮rnoo氮rnoq气焰rnp氨rnpg拟定,撰写,所写rnpm拨冗rnpu扎实rnpv氨rnqc气色,排忧解难rnqj气象rnqk扬名rnqn气馁rnqq抚恤金rnr扬,摺rnrc抉择rnrf气质rnrg摺rnrh所rnrn气氛,氧气rnrr气魄rnrs扭打rnrt扬,握手rnrv气势rnrw后发制人rnsj据查rnsv气概,扎根rnt拨,氕,氡rnta所长rntd所知rnth气息rnto据悉rntq据称rntr氕rntu氡rnty拨,拟稿,撰稿,年收入rnu氧,摒rnua摒rnub据闻,所闻rnud氧rnuk批发部rnv氯rnvi氯rnw氛,抉,擢rnwf据传rnwg按惯例rnwh气候rnws气体rnwt扭伤rnwv氛rnwx氧化rnwy抉,擢,握住rnx氟rnxj氟rnxw拨给rny拟,氦rnya气度rnyc摒弃rnyl所谓rnyt气话rnyu据说rnyw拟,氦rnyy拟议,扬言,撰文ro搂,擞robb捅娄子rofg热火朝天roft失业者rogn执迷不悟ronp鬼迷心窍rov搂rovg搂rovt擞royx失业率rp近,探,挖rpad按期,近期,挖苦rpav迫切rpbm挖出rpbt迫降rpbw探险rpd迫rpdy探矿rpee按月rpen拥军爱民rpf皖rpfc挥动rpfi探求rpfp探索rpfq皖,操之过急rpfw挥霍rpg揎rpgf迫于rpgg揎rpgj按理rpgo近来rpih挥泪rpim探测rpip拉家常rpje探明rpjf按时rpjg按量rpjj近日,按日rpjv按照rpk近rpkh探路rpkr探听rpkx拍案叫绝rpl挥rplh挥rplx年富力强rpme捉襟见肘rpnl挖空心思rpnn持之以恒rpnt挥发rppd迫害rppw探究rppy近视rpqn按钮rpr摈rpra擦拭rprh近年,按年rprl挥舞rprm控制rprn挖掘rprp迫近rprw摈rps拧rpsh拧rpsj探查rpsm打字机rptf控告rpth近处rptu近乎rpud挥拳,按着rpug探病rpuk近况,探问rpuq近郊,拒之门外rpus探亲rpuy找窍门rpv按rpvf探寻rpvg按rpw控,擦,撺rpwa控,近代rpwg迫使rpwh撺rpwi擦rpwn挖,近似,拥军优属rpws探rpwy近邻rpyc摈弃rpyf探讨rpyg按语rpyn探望rpyp挥毫rpyq探询,反之亦然rpyr控诉rpyu按说rpyy探访rq换,抱,鬼rqa抵rqak抑或rqay抵rqb抑rqbc换取rqbh抑rqbm掏出rqby换防rqc鬼,魅,魁rqcc魑,魃rqce魈rqcf魁rqci鬼,魅rqck气象台rqcn魍rqcw魉rqde抑郁rqdn换成rqdp抵达rqdq的确rqdt气象万千rqeu挣脱rqfi挽救rqfk欣喜rqg撸rqgj撸,拾金不昧rqgk抵赖,拘束rqgy换班rqhh抑止rqhk持久战rqhn手急眼快rqia换汇rqii抵消rqij鬼混rqin拘泥rqip欣赏rqk拘,挽,搀rqkg拘rqkq挽rqku搀rqlk挽回rqlt魅力rqm换rqmd换rqmf气急败坏rqmh抵帐rqn抱rqnf欣慰rqnm换届rqnn抱,气象局rqnu欣悦rqo掬rqoy掬rqq揿rqqb抱怨rqqd欣然rqqe抵触rqqg挣钱rqqm抱负rqqw揿rqqy拘留,挽留rqr掏rqrf搀扶rqrg拘捕rqri抵挡rqrl抵押rqrm掏,抵制,抑制rqrn挣扎,托儿所rqrw年久失修rqry抵抗rqsc摇钱树rqsg魁梧rqsm打印机rqss拘禁rqtd捣乱rqth换算rqtk搀和rqtr抵御rqtu换乘rquf换装rqug抱病rquh气象站rquv抱歉rqv掐,挣rqva捣毁rqvf挥金如土rqvg掐rqvh挣rqvs搀杂rqw欣rqwa换代rqwf魁伟rqwn搀假rqwx换货rqwy欣rqy的,捣rqya拘谨rqym捣rqyn换房rqyy的,换文,换句话说rr折,抓,白rraa手提式rrae白菜rran逝世rrap指挥若定rraq抓获,控制区rrbb鬼鬼祟祟rrc扳,皈rrca鬼把戏rrcc折叠rrck拆台,控制台rrcy扳,皈rrdd气势磅礴rrdn拆成rreb折服rreu折腾rrev扯后腿,拉后腿,拖后腿rrfc白云rrfh掀起,扶摇直上rrfn拍卖rrfp白手起家rrfv白雪rrg拍rrga拆开rrgd白天rrge措手不及,指手画脚rrgf按兵不动,乒乓球,拥挤不堪rrgg打抱不平rrgj哲理rrgo近年来rrgp捉摸不定rrgq誓死rrgw按捺不住,推卸责任rrh折,搋rrhj折旧rrhm搋rrhy抓rrig缺斤少两rrii气势汹汹rrip哲学rrit拆洗rrj蜇rrjc抓紧rrjg誓师rrju蜇rrjv拍照rrk哲,踅rrkf哲rrkh踅rrkk抵押品,控制器,手舞足蹈rrkm指挥员rrkt打招呼rrkv拍手叫好rrlt魄力rrnc招兵买马rrny白昼rron折断rrp逝rrpg控制室rrpk逝,白宫rrpp扎扎实实rrpw拆穿rrq掀,魄rrqc魄,白色rrqv白银rrqw掀rrr白rrra白搭rrrb拍摄rrrc招摇撞骗rrrh拆卸rrrk折扣,打折扣rrrn指挥所rrrr白,拖拖拉拉rrrt手挽手rrru损兵折将rrsd指挥棒rrsm拖拉机rrsr拍板rrt捭rrta欣欣向荣rrtf捭,拆迁rrth拍片,折算rrtn拍手称快rrts白条rruk指挥部rrut白痴,据报道rrva拆毁rrvb抓好rrvh年年如此rrwa拆借rrwb摇摇欲坠rrwg折合,抗拒从严rrwx白热化,抢手货rrwy抓住rrxj白费rrxq白纸rry拆,誓rryf誓rryk折衷rryl斤斤计较rrys折磨rryt白族rryu挑拨离间rryw控制论rryy拆,誓言rs打,揸rsba投机取巧rsbb看样子rsbo护林防火rsce打通rsdh打破rsdy打碎rsfd打垮rsfj打进rsfm打击rsga打开rsgf打球rsgh打下rsgq打死rsh打rshk打点rsif打法rsii打消rsj揸rsjg揸,打量rskh打中rskm技术员rskr打听rslk打架rsmt打败rsnt打发,技术性rson打断rspb打字rsqg打印rsra打捞rsrh打掉rsri打搅rsrn打气rsrv打扫rsrw打扮rstd打乱rsth打算rstu技术科rsty打入rsud打头rsui拉丁美洲rsuk技术部rsvb打好rswd打仗rswg打倒rswt打伤rsyy拉丁文rt手,斤,挺rta托rtaa手工rtaj捞稻草rtan托,手艺rtb拖rtbm播出,看得出rtbn拖rtca热乎劲rtd括,挢rtdb挺身而出rtdf扬长而去rtdg括,扑鼻而来rtdj挢rtdt托故rte搬rtec搬rtef手脚rtep手腕rtf插,扦,卑rtfb郫rtfc搬运rtfd拖垮rtfg鹎rtfh扦,搬走rtfj卑,挺进rtfk皓rtfm攒rtfn撬rtfp挺rtft所向无敌rtfv插rtg手,捶rtga搬弄rtge手表rtgf捶,投身于rtgh手,卑下rtgm斤两rtgr年复一年rtgx抗生素rtgy摇身一变rth擤,攥rthi攥rthj擤rtif手法,兵役法rtit卑劣rtiu年利润rtjm播映rtkf卑鄙rtkh插足,手足rtkm招待员rtlf报告团rtlq手软rtlt插图rtlw托办rtlx拖累rtma插曲rtmm手册rtnt播发,报复性,挑衅性,扬长避短rto揪,播,皤rtog制造业rtol播,皤rtoy揪rtpe搬家rtpg接待室rtpl后备军rtqi插销rtqw拖欠rtrd挺拔rtrf手持rtrg拨乱反正rtrh搬掉rtrj挑重担rtrn招待所rtru拖拉rtrv手势rtrw失物招领rtrx手指rtry所向披靡rtsw手枪rtsy手术rtt斤rtth斤,拖延,挡箭牌rttk播种rttm插秧rttp托管rttt手笔rtty插入,手稿,拖入rtub投入产出rtud播送,插头,手头rtug挑毛病rtuh接待站rtuj播音rtum制造商rtuu挺立rtwd手段rtwf托付,报告会,招待会,执委会rtww托人rtxf手续rtxj招待费rtyf播讲rtyo手迹rtyt播放rtyw插座ru拉,接,拼rua拼ruab拉萨ruah拼ruaq近郊区rub搠rubb捂盖子rubc摘取rube搠,拦阻rubl打头阵rubw摘除ruce接通rud搓,掷ruda搓rudb掷rudm撑门面rudw择善而从ruep接受rues拦腰ruf拦,拌,抖rufa拦截rufc抖动rufd抛头露面rufg拦,撞坏rufh拌,抖,摘走rufm拦击,撞击ruft投资者rufw接替,拉夫rufy接壤rug拉ruga拉开,撇开rugc接到rugu拉平rugy接班ruhn手疾眼快ruig搁浅ruit接活ruiw接洽ruiy接济ruj撞,掸,揞rujf撞,掸rujg揞,年产量ruk掊rukg掊rukh拦路rukk接口rukm播音员rulf搁置rulg撞车rulp接连rult接力rulv接轨rum摘,撇rumd摘rumi气壮山河rumq接见,提意见rumt撇run扪runh接收runn招商局ruoy扑朔迷离rupe失道寡助rupt投资额rupy拉祜ruq皎ruqe接触ruqy皎rurd拉拢rurf抗美援朝rurg拼搏rurh拉扯ruri拦挡,摘抄rurn摆阔气ruro抖擞rurp接近,拉近rus撙rusf撙rusg拉丁rusv摘要rut搁ruta拉长rutf接待rutg接生rutk搁,接种,拌种rutp接管rutx拉关系ruty拉入ruud接送,接头,接着,拼凑ruug拉美ruuj拼音ruuk后半部,气冲冲ruut打交道,年总产ruv接,搛ruvg接ruvi摘录ruvo搛ruwf年产值ruwg拼命ruwt接任,撞伤ruwx热门货ruwy拦住,质次价高ruxj抚养费ruxm接纳ruyd探亲访友ruyg按部就班ruyi接应ruyn摘记rv扫,热,势rvaa招工rvad招惹rvai扫荡rvaj扫墓,招募rvak殷勤,执勤rvam扫黄rvav热切,殷切rvbm招聘,抛出rvbw扫除rvdc挚友rvdt势如破竹rvep热爱rvet挪用rvf挪rvfb挪,扫地rvfc挪动rvfl扫雷rvfp搜索rvft招考rvg扫rvgc招致rvgh执政rvgq热烈rvgx扫毒rvh搜rvhc搜rvif热潮,执法,打退堂鼓rvig扫清rvih热泪rvii热水rvip执掌rviw扫兴rviy热流rvjg热量rvjv执照rvk招rvkg招rvkh热中rvkt招呼rvl抛rvlk招架rvln抛rvlq搜罗rvlt势力rvmq热风rvn殷rvna招展rvnc殷rvng热情rvnh招收rvnp热忱rvnt扫尾rvny热心rvpu殷实rvpy扫视rvq拶rvqa抛锚rvqy拶rvra扫描rvrg搜捕,招兵rvrj招揽rvrn热气rvru抛掷rvrx执拗rvsf招标rvsj搜查rvt捃rvtf招待,执行rvtg招徕,招生rvth招牌rvtj势利rvtk捃rvtm扫射rvud势头rvuj执意rvuy热门,热闹rvvf搜寻rvwa挪借,招供rvwf垫付rvwy抛售,搜集,招集,招领rvxg热线rvxh招引rvy执,垫,挚rvyc抛弃rvyd热诚rvyf垫rvyg鸷rvyi絷rvyj蛰rvyl势rvym贽rvyn热望,扫盲rvyo热rvyr挚rvyw招认rvyy执rw失,推,捡rwad推荐rwae失散rwai失落rwb抢rwbc拾取rwbh掩人耳目rwbk失职rwbm推出rwbn抢rwbq失陷rwbu失陪rwbw抢险rwck操作台rwdf抢夺rwdt年逾古稀rwet反作用,损公肥私rwf拊rwfb失地rwfc抢劫,失去,推动rwfh迭起,失真,抢走rwfi抢救rwfj推进rwfn失声rwfw拾零rwfy拊rwg拴,拾,揆rwga推开rwgd揆rwgg拴rwgi捡rwgj揄,推理rwgk拾,失事,携带rwgn损人不利己rwgr搿rwhk抢占rwi失rwif反贪污rwim推测rwip扮演,失常,失学rwiw推举rwkh失踪,失足rwkm操作员rwkq近代史rwmp推崇rwmq抢购rwmt挫败,失败rwnh抢收rwnt指令性rwnx扣人心弦rwny推迟rwog失业rwon推断rwoo失火rwp迭rwpd失宠rwpi迭rwpn损人害己rwpu鬼使神差rwpw失窃rwpy失神rwqc失色rwqi推销rwra失措rwrh失掉rwrp失控rwrr挫折rwrt携手rwrw捡拾rwry抢掠rwsh推想rwsr据分析rwss失禁rwtd推辞rwtf推选rwtg失策,推倒重来rwth失算,推算rwtj失利rwtk抢种rwtn损人利己rwto推翻rwtq失衡,推移rwuj失意rwuq失盗,失效rwv扮,掰rwvn扮rwvo失灵rwvr掰rww挫rwwd抗倒伏rwwf挫,失传rwwg推倒rwwh抢修rwwt挫伤rwwy失信rwx抡rwxn抡rwxv据介绍rwy扒,拎,捻rwyc擒,拎rwye携rwyf据估计rwyg推,失主rwyk失误rwym失调,推敲rwyn捻,失望rwyw推论rwyy失言,推广rx批,指,揩rxcq批驳rxcu兵强马壮rxdw后继有人,提纲挈领rxe掾rxey掾rxf掼rxfi批示,指示rxfm掼,指南rxft指教,操纵者rxg拇rxgh指正rxgm指责rxgu拇rxhk指点rxir指派rxj指,拂rxja拂晓rxje指明rxjg指,批量rxjh拂rxl拗rxln拗rxlp白纸黑字rxnf指导rxnt批发,批改,持续性rxov指数rxqf指针rxrp指挥,指控rxrx拇指rxsf指标,操纵杆rxtj批复,气贯长虹rxtm指向rxu搦rxud批判rxuu搦,批阅rxuw批准rxvf报纸杂志rxwg指使rxwy指令rxx批rxxh指引rxxj手续费rxxn批rxxr揩rxyf据统计rxyg批评rxyn指望rxyy批文ry扩,搞,护rya摭ryaa瓜熟蒂落ryae扩散ryaj按计划ryao摭rybk撤职rybm撤出rybw撤除ryc撤ryct撤rydd扩大rydf挤压,掠夺rydh摔破ryfd抗震ryfg护士,摔坏ryfh撤走ryfm抗击ryfw反应堆ryg拄rygf热衷于rygg拄rygj护理rygl措施不力,舞文弄墨rygm斥责rygt技高一筹ryh掂ryhh擦亮眼睛ryhk掂,抗战ryi斥,掠ryia挤满,抗洪,抗涝ryif反证法ryig搞清ryii撤消ryit搞活ryiy掠ryj挤ryja抗暴ryjf抗旱ryjh挤ryjj抗日ryjv护照ryk攘ryke攘rykh护路ryl擅rylg擅rylk撤回rym搞,抗rymk搞rymn抗ryn护,捩,掮ryna扩展rynd捩,据为己有ryne掮rynt护ryod找麻烦rype批评家rypf抗寒,搪塞,邀请赛rypl撤军,扩军rypo抗灾rypp换言之ryqi撤销ryqv抗争ryra抗拒ryrg撤兵ryrq撤换ryrs摔打rysj据调查ryss护林ryt扩,邀,敫ryta擅长rytd护短ryte护航ryth擅自rytp邀rytq抗衡rytr抗御rytu抗税ryty敫,擅入ryud护送ryug抗病ryuj打主意ryuk挤兑ryuq搪瓷ryv搪ryvb搞好ryve撤退ryvf扩建ryvk搪ryw掖rywg摔倒ryws抗体rywx制度化rywy掖,邀请信ryx摔,搐ryxf摔ryxl搐ryxt扩张ryxy扩编ryyb撤离ryyc扩充ryyg邀请ryyr撤诉ryyy抗议s要,本,可sa械,横,框saa械saaa模式saah械saai模范saan棋艺sab栉sabb棋子sabh栉sack柜台sad棋,榧,椹sadd榧sadn椹sadw棋saf柑saff棋坛safg柑safh横越sag杠saga模型sagg框sai栋saia松花江saiv栋梁saiy栋,横渡saj模sajc横竖sajd模sajw横七竖八sak槿sakg槿sakh横跨salk框架sam横samh横幅samw横san柜sang柜saod模糊,棋类saog核工业sap檬sape檬sapw横穿saq枢,柩saqw杠铃saqy枢,柩sarn模拟sart棋手sarv横扫sasf杠杆sasu模样sat桡satf横行satm横向satq桡satr模特saut林荫道savp相敬如宾sawt歌功颂德sawy模仿saxf横贯saxg横线,本世纪末saxm本世纪内saxn枢纽,本世纪saxp本世纪初sb李,椰,椭sbaw本职工作sbb椰sbbh椰sbd椭sbde椭sbf李sbtx相联系sc权,树,桶scal树苗scb杼,橘,懋scbh杼scbk橘scbn懋scbv权限scdg权威scdr树碑scdy相对而言sce桶sceh桶scf树,柽scfg柽scfy树scg杩scgy相对来说sckh权贵sckm检验员sclt权力scn杷scnt可能性,相对性scpe权宜scrv权势scss树林,树木scsy权术sctd树敌sctj权利sctk树种sctq权衡sctx西双版纳scuu树立scuw权益scw梭scwt梭scww树丛,树人scy权,杈scyy杈sd枯,顶,椅sdat枯萎sdbb椅子sdet顶用sdfb可耕地sdfw顶替sdg枯,柘,橱sdgf橱sdgk顶事sdgq枯死sdgy顶班sdh楔,槭sdhd楔sdhk顶点sdht槭sdii枯水sdl枥sdln枥sdm顶sdmq顶风sdmt顶峰sdmy顶sdnt权威性sdok枯燥sdpw橱窗sdqq顶多sdrm树大招风sdru顶撞sds椅sdsa橱柜sdsf可有可无sdsi树大根深sdsk椅sdt梆sdtb梆sdu橛sduj枯竭sduk顶部sdum顶端sduw橛,树碑立传sdw棒,椿,榛sdwd楱sdwh棒sdwj椿sdwt榛sdwy顶住sdx栊sdxn栊sdy杖sdyy杖se极,棚,杉sead极其seb桴sebg桴sebv极限sec楹secl楹seda极左sedd极大sedk极右see棚seeg棚sefg极坏sehk极点seih极小sejq极易set杉seud极差seum极端sevb极好sewq极低sey极seya极度seyl极为seyy极sf村,枝,票sfab枝节sfae飘散sfaf相去甚远sfai村落,飘荡,飘落sfaq本地区sfb鄄sfbb村子,票子sfbh鄄sfc枝sfcy枝sfdm票面sff桂,樗sffc飘动sffg桂sffi标示sffm相去无几sffn樗,标志sffw飘零sfg杜,甄sfgc标致sfgk飘带sfgn甄sfh杆,植,樾sfhg植sfht樾sfi标,飘,瓢sfie飘浮sfij剽sfiq飘sfiu票,柰sfiy标,瓢,飘流sfje标明sfjg标题sfk桔sfkf枝叶sfkg桔sfkl甄别sfl檑sflg檑sflt核动力sfm楠sfmf楠sfn椟sfna村民sfnd椟sfnt机动性sfou材料sfpf桂冠sfpl核裁军sfpt票额sfpu植被sfpw剽窃sfqd飘然sfqe西南角sfqf村镇sfqk飘逸sfre飘摇sfrg标兵sfrl飘舞sfrn杜撰,票据,飘扬sfsc植树sfsg标本sfsr植株sfss桂林sfsu标榜sft材,楮,栲sfta村长sftj楮sftn栲sftr植物sftt材sftw标签sftx栳sfu樯sfuk樯,村干部sfuw标准,杳无音信sfw棱sfwk植保sfwt棱sfww标价,票价sfxq杜绝sfy村sfyf村庄sfyg标语,票证sfyk标识sfyn标记,票房sg本,西,杯sga醋,酣,醛sgaa西式sgad西藏sgaf酣sgag醛sgaj醋sgap酬劳sgaq西欧,本区sgat西医sgax配药sgb酏sgbe梗阻sgbk本职sgbn酏sgc酸,桎sgce本能,想不通sgcf桎,配对sgct酸sgd本,酉,醐sgdd配套sgde醐,配有sgdg酤,本厂sgdh本来面目sgdl醢sgdn酿成sgdy酞sge酹sgee本月sgef酹sgeg本县sgep酷爱sgf酝,酵,酐sgfb酵,本地sgfc酝sgff本土sgfh酐,禁不起sgfj本刊sgfm西南sgfy酎sgg枉,酽,酾sgga想不开sggc想不到,相一致sggd酽sggk本事sggo本来,西亚sggy酾sgh丁,醵sghe醵sghg西sghh醒目sgi杯sgid西湖sgif枉法sgis酿酒,酗酒sgit本省sgiy杯sgj醒,桓,醍sgjf酷暑sgjg桓,醒,酌量,可不是sgjh醍sgjj西昌sgjn配电sgjq梗sgjx醌sgk梧sgkg梧,酲sgkk核武器sgl楝sglf配置sglg本国sgli楝sglp西边sgm柄,槽,醴sgmf本周sgmj槽sgmk酮sgmu醴sgmw柄sgn配,朽,醪sgne醑,醪sgng醒悟,酌情sgnm本届sgnn朽,配sgnt本性,配发,酸性sgo醚,桠,醭sgog桠sgop醚sgou配料sgoy醭sgp酡sgpf梗塞sgpg酌定sgpr酬宾sgps西宁sgpt配额sgpv西安sgpx酡sgq酌,酩,杌sgqb酗sgqc本色,配色sgqd枉然,要不然sgqe配角sgqg本钱sgqk酩sgqn杌sgqq本金,酬金sgqy酌sgra配搭sgrb本报sgrf本质sgrm配制sgrv酷热sgs酊sgsf想来想去sgsg醋酸,酝酿sgsh酊sgsr机不可失sgss酸楚,朽木sgst栈桥,桎梏sgsu本校sgsv梗概sgt栈,酢,酷sgtf酢,本行,酿造sgtj本利,要不得sgtk酷,酪,配种sgtl配备sgtm本身sgto醺sgtq酰sgtu酶,本科sgty酥sgu枰sguc酸痛sgud本着sguf西装,顶天立地sguh枰sguj本意,配音sguk醅,本部,西部sguq西郊,本次sgux西北sgw酚,醮,酴sgwg配合sgwj配偶sgwl本末倒置sgwn酷似sgwo醮sgwr配件sgwt酴sgwu本位sgwv酚sgww本人sgwx西化sgwy本领,顶不住sgx酯sgxj酯sgxw配给sgy醉,酬,醇sgyb醇sgye酿sgyf醉sgyh酬sgyi本应sgyk醣sgyl醯sgym本市sgyt酬谢,梧州sgyy本该,本文,配方,西方sh相,想,朴shbg相隔shbm想出shce相通shcf相对shdq榜上有名shep相爱shfg相干shfn相声shg相shgc想到shgx朴素,相互shi椒shic椒shif想法shiv相当shj棹shjh棹shjm相遇shkh相距shlp相连shm桢shmg相同shmq相见shmy桢shn想,栌shnt栌,想必shnu想shpu朴实shqj想象,相象shrc相反shrf相持shrp相近shrq相抵shru相接,相撞shtd相逢shtf相等,相待shth相处shtq相称shtw相符shud相差,相关shuj相间shum相商shuq相交shwf相传,相会shwn相似shwy相仿,相邻,想念,相信shxo相继shxq相约shxx相比shy朴shyi相应shyk相识si档,桃,梢sial根深蒂固sibb想法子sidf瓢泼大雨sie梢sieg梢sigf相当于sii桫siiq酸溜溜siit桫sika根深叶茂sila杯水车薪sint可溶性siov极少数siow极少数人sip樘sipf樘sipv档案siq桃,桄siqd想当然siqn桃,桄siqr楼堂馆所sirh想当年sisb桃李sisy顶梁柱sit杪site核潜艇sitt杪,枉法徇私sitv校党委siuq档次siv档sivg档siw榉siwh榉siww检举人sj查,棵,棍sjaj柳暗花明sjaq查获sjbb棍子sjbm查出sjcf查对sjcw查验sjdf相映成趣sjf杳sjff查封sjg查sjgf查sjig查清sjj覃sjje查明sjki查哨sjlw查办sjmh查帐sjn榻sjng榻sjnh查收sjqg查铺sjra查找sjrh查看sjs棵sjsd棍棒sjss查禁sjsy棵,查核sjt槛,榄sjth查处sjtl槛sjtq榄sjtu查税sjuh核电站sjuk查问,机电部sjuu查阅sjx棍sjxx棍sjyg查证sjyq查询sk可,哥,歌skaq可敬skb楫skbc可取skbg楫skbh可耻skce可能skck查号台skcm可观skd可skdj可悲skep可爱skf杏skfk可喜skfn歌声skg枵skgi可不skgn枵skgo可恶skjg可是skjt歌星skk榀skkf可鄙skkh可贵skkj歌唱skkk榀,可口skkr顶呱呱skma歌曲skmq可见skna可惜sknd歌剧sknr可怕sknv可恨sknw可怜skny可以skrl歌舞sks哥sksk哥sksw歌sktf可靠,可行sktt可笑skw枳skwc歌颂skwg相吻合skww机器人skwy枳,可信skxt可疑skyl可谓skyn歌词,可望skyo可变sl楞,枷,椤slad校办工厂slh柙slif想办法slk枷slkg枷slq椤slqi枷锁slqy椤slsd相辅相成sltm核辐射sltv校团委sly楞slyn楞sm机,贾,樱smaa机工smaq机警smce机能smdi机耕smfc机动smfj机井smfn机场smg柚,桐smga机型smgg可见一斑smgk桐smhh机上smhw机具smjm机遇smjn机电smkk机器smm栅smmg栅smmv樱smn机,桤smnn桤smpn机密smpt相同之处smq枫,枧smqn枧smqy枫smrm机制smsa机械smsq机构smsu栅栏smsv机要smtd机智smtk机种smtl机务smtx机敏smu贾smud机关smvo机灵smw枘smwf机会smws机体smwy枘smxe机组smya可见度smyn机房smys机床sn杨,札,杞snb橄snbt橄snd椐sndg椐sng栩snh楣snhg楣sni榍,樨snie榍snih樨snn札,杞snr杨snrt杨snsj橄榄snyn札记snyu可以说so杰,楼,粟sobm杰出sodg材料厂sods林业厅sonn林业局sont可燃性sosu楼梯sou粟,杰souk林业部sout楼阁sov楼sovg楼sowt杰作soxj材料费soyn楼房sp棕,枕,榕spbc榨取spbp检察院sper顶礼膜拜spf棕spfg相安无事spfi棕spfw朴实无华spg楦spgg楦spkm检察员spn棺spnf梦寐以求spnn棺sppn检察官sppy权宜之计spq枕spqn枕,档案馆spr槟sprw槟sps柠spsh柠spta检察长spv桉spvg桉spw榨,檫,榷spwf榨spwi檫spwk榕spwy榷spx柁spxn柁spym西安市,西宁市sq构,攀,柳sqa柢sqay柢sqc构sqcy构sqd桅,檐sqdb桅,柯尔克孜sqdn构成sqdy檐sqe桷,槲sqef槲sqeh桷sqeu橡胶sqg橹sqgj橹sqi栎sqiy栎sqj橡sqje橡sqk枸sqkg枸sqln构思sqlt构图,想象力sqq攀,樊sqqd樊sqqr攀sqsh构想sqt柳sqta构筑sqtb柳sqtf构造sqwg攀登sqxx攀比sqy榴,杓sqyl榴sqyo攀谈sqyt柳州sqyy杓sr析,板,棉sraa板式sraw棉花src板srcy板srd槔srdf槔srdm棉布sren可接受性srfb根据地srg柏,栀srgb栀srgg相持不下srh析sri株sriy株,株洲srlf歌舞团srll棉田srlp株连srm棉srmh棉srnt概括性srpe棉农srq槐srqc槐srr皙srrb板报srrf皙srss柏林srsy核技术sruy相提并论srwg板凳srxf板结srxi棉纱srxy棉纺sry檄,柝srya本年度srye棉衣sryf核反应堆sryt檄sryy柝,檄文ss林,木,梦ssaa木工,松松散散ssaq禁区ssaw攀枝花ssb郴ssbb林子,枪杆子ssbh郴ssdg机械厂ssdp彬彬有礼ssdt可想而知sse彬sset彬,禁用ssf禁ssfb林地ssfc禁运ssff松松垮垮ssfi禁ssfn林场ssg栖ssgk林带ssgo森严ssgs模棱两可ssgx禁毒sshh禁止,根本上ssit林海ssj楂ssjg楂ssjt木星ssk柯sskg柯sskk木器sskm检查员sslf检查团ssm梵ssmf木雕ssmy梵ssn楚ssnh楚ssnn禁忌sso焚ssoa焚烧ssog林业ssoo模模糊糊ssou焚,木料ssq梦ssql禁锢ssqu梦sss森sssf木材sssg木本sssh梦想sssi可歌可泣sssr木板ssss木,林木,森林sssu森sstd枯木逢春sste木船sstg相机行事ssth栖息sstm栖身ssu栗ssud木头ssuh检查站ssuu林立ssv婪ssva焚毁ssvf婪ssvt栩栩如生ssw棼sswj木偶sswv棼sswx机械化sswy禁令ssxe检查组ssxf枪林弹雨ssxn梦幻ssy林,麓ssym桂林市ssyx麓st格,桥,梅sta枨staa格式stau酸甜苦辣staw梅花stay枨stcr棋逢对手std桥,栝stdd想入非非stdg栝stdj桥stet可利用stf橇,杵,桁stfh杵,桁stfk梏stfn橇stfp梃stg棰stga想得开stgc想得到stgf棰sth柞sthf柞stim覆没stiv桥梁stk格stka枝繁叶茂stkg格stlf植物园stm榭stmf榭stnn格局stnt可靠性,可行性sto楸stoy楸stps可乘之机stqh格外stsn可移植性stt覆sttg本科生stth桥牌sttt覆stug覆盖stuu相得益彰stwd机务段stwy顶得住stx梅stxu梅stxy本系统sty枚styi相适应stym格调styt梅州su样,校,栏suaa样式subb样子subw梯队sucf校对suck检阅台sucw校验sud样,槎suda槎sudc校友sudh样sueg相差悬殊suf栏sufg栏sufj校刊sufr横冲直撞suga梯形sugh校正suh梓suhh栏目suj樟sujh樟suk榈sukk榈,样品,林产品sulf校园sull梯田sumq校风,西北风sunt可塑性sup榜supy榜suq校suqe西北角suqh校外suqy校sus榇,樽susa可亲可敬susf樽,栏杆susg样本susm样机susr样板susu榜样susy榇suta校长suuk西北部suun标新立异suut榜首suuw校准suuy本部门suwf校舍suwu本单位sux梯suxe梯级suxt梯suyd校庆suys校订suyx覆盖率suyy校方sv要,根,概svad根基svbb根子svbk要职svbw根除svc概svcq概sve根svee概貌svey根svf要,楗svfb要地svfi要求svfp楗svg桕svgi要不svgk要事svgx要素svhh要目svhk要点svi棣svic根治svid根源sviy棣svjc要紧svjg要是svlt概略svo棂svoy棂svpd要害svpv要案svrg要挟svrn根据svrt概括svsg根本svsv概要svsy概述svtc要么svth概算svub要闻svuk概况,根部svut要道svvb要好svwg要命svwr要件svww要价,要人svwy概念,要领svxk要强svyq根底svyw概论sw检,枪,松swae松散swb枪swbn枪swc松swca松劲swcw检验swcy松swd椴swdc椴swdg机修厂swf桧swfc桧,枪支,松动swfm枪击swfn枪声swfp检索swg栓,橙,榆swga松开swgg栓swgi检swgj榆swgu橙swhk枪战swim检测swiw检举swkk松口swn槌swng杞人忧天swnn松快swnp槌swnq松懈swpg检定swpw检察swqs枪杀swsj检查swum检疫swuu检阅sww枞swwh检修swwx概念化swwy枞swx桦swxb松弛swxf桦swy椎,柃,榫swyc柃,檎swyf榫,检讨swyg椎swyo樵sx楷,椽,枇sxdg棉纺厂sxe椽sxey椽sxjj杯弓蛇影sxkk棉织品sxnn楷书sxns枉费心机sxpg相比之下sxsa楷模sxsq木结构sxsy西红柿sxua相继问世sxud核弹头sxwg相结合sxws可比价格sxx楷,橼sxxd棉纺织厂sxxe橼sxxk棉纺织sxxn枇sxxr楷sy术,柱,梳syb椁sybg椁sybk述职syc梳syce核能sycf核对sycq梳sycw核试验sydg柱石syf桩,槠syfj槠syg柱sygg柱syi术,椋syit梳洗syiy椋syjn核电syk榱syke榱syl檀,檩sylg檀syli檩sym杭,柿,槁symh柿symk槁symn杭syn核,枋synw核syny核心syp述sypg核定sypi述sypu核实sysj核查syth核算,标语牌syts极为重要syud核减syuv梳妆syuw核准syv榔syvb榔syyf核计syyg述评syyi想方设法syym杭州市syyt杭州syyu述说t和,得,很ta长,升,筑taad长期taaw自欺欺人tab筇tabj筇tabt升降tad箕,簸,篚tadc簸tadd篚,长大tadj长辈tadk箬tadn长成tadw箕,长春tadx长龙taeu升腾tafd长城tafh升起tafj长进tafq长远taft策划者tafu徒劳无益tag筐,箧tagf筐tagp稀世珍宝tagw箧tah逄tahp逄taia长江taii长沙taij升温taip升学tak升,笸takf笸takh长跑,筑路tam筑,簧tamw簧,短期内tamy筑tang长期以来tant长期性,季节性taog重工业tapp稀世之宝tapw升空taq簪taqj簪taqy长久tarv长势tasi升档tass穆斯林tast升格tatd长短tatf升迁tatg长征tath长处tats各式各样taty长篇tav乇,彻tavn彻taw筮tawf升值tawo乱七八糟tawq繁花似锦tawt长途,升任taww筮tawx升华,长期化taxe升级tay长taya长度tayi长taym升高tayo长谈tayq彻底tayt升旗tayw彻夜tayy长廊tb季,迤tbab季节tbf季tbfj季刊tbfu入出境tbgt翻了一番,稍逊一筹tbp迤tbpv迤tbrf各取所需tbtr种子选手tbya季度tc么,私,径tca径tcag径tcap私营tcb笆tcde私有tcdf知难而进tcdh知难而上tcf笃tcfh径直tcft先驱者tcgd私吞tcgh私下tcgk私事tciy径流tck笞tckf笞tcnf私愤tcng私情tcny私心tcth私自tctj私利tcu么tcwg私拿tcwv私分tcww私人,私欲tcy私tcym私设tcyu很难说td知,智,短tda矩,甜,榘tdad短期tdaf甜tdaj筹划tdal丢三落四tdan矩tdas榘tdbc智取tdbk辞职tdbr科研院所tdce智能tdcf敌对tdd舌tddc筹码tddh智慧tddn千百万,千奇百怪,稀奇古怪tddu很有成效tdet适用tdfc辞去,乱动tdff筹款tdfh知趣,刮起tdfn矢志tdft第三者tdg短,舔,箴tdga矫形tdge知青tdgf适于tdgh矫正tdgk智囊tdgn舔tdgp自成一家tdgt箴,自愿互利tdgu短tdh逢tdhp逢tdhq徒有虚名tdhw适龄tdi夭,籍tdif知法,很感兴趣tdig短浅tdih矮小,短波,生龙活虎tdij籍tdip知觉,生态学tdiv适当tdiw乱砍滥伐tdj乔,刮,徘tdja知晓tdjd徘tdjf适时tdjh刮tdjj乔tdk知tdkf甜味tdkg知,辞呈tdkh短路,适中tdkj智tdkl辞别tdlh笼罩tdlr短暂tdlt智力tdlw筹办tdm岙tdma辞典tdmj岙tdmq刮风tdn乱,稽,嵇tdng敌情,知情,自古以来tdnj稽tdnm嵇tdnn乱,辞书,知己tdns很有必要tdnt乱发,敏感性,片面性tdny知心tdp适tdpd适tdpe适宜tdpl敌军tdpn甜蜜tdpy敌视tdq鸹,舐tdqa舐tdqg鸹tdqk知名,第三名tdqy很有希望tdra筹措tdrm短缺,私有制tdrn科研所tdrr夭折tdru答非所问tdsf赞成票tdsj稽查tdt敌,筹,矮tdtd适逢tdtf筹,辞行,乔迁tdth筹算,短处tdtj矫tdtk短程tdtl筹备,徘徊tdtn憩tdto知悉tdtv矮tdty敌tdu矢,辞tdud甜头tdug甜美tduh辞tduj敌意,知音tdum智商tduq筹资tdut知道tdve辞退tdvf筹建tdw矬,雉tdwa筹借tdwf矬,适值tdwg适合tdwk短促tdwt短途,自成体系tdwv矫健tdww敌人tdwx私有化tdwy雉,筹集tdx笼,矧tdxb笼tdxf籍贯tdxg短线tdxh矧,箭在弦上tdxt笼络tdxy笼统tdya适度,智谋tdyc智育tdyg短评tdyi适应tdyk知识tdym长春市tdyn短讯tdyp简而言之tdyq知底tdyy短文,箴言te秀,般,租tea舡,艨teae艨teag舡teb秀,艋,稃tebb稻子,盘子tebg稃tebl艋tebw船队,舰队tedg船厂tedh盘存teet租用tefc航运,透支tefk透露tefp透过teft秀才teg租,艚,徂tegd航天tegf适用于tegg租,徂tegj艚tegm秀丽tegy航班teh舻tehh船上tehk盘点tehn舻tei舟,艄teie艄teit航海teje透明tek舯tekh舯tekk舱口tekm船员tekw船只tel盘,筋telb筋telf盘tell稻田tem般,船,舰temc般temd磐teme筋骨temg舳temh舢,盘帐temk船temm舟山temq舰,透风ten艉tenn艉tep透,舵tepv透tepw航空tepx舵tepy透视teqq租金,备用金teqr盘锦ter舶,舨,徭terc舨terg舶term徭tern透气,秀气tert舵手tes舸,舾tesa航模tesd透顶tesf船票,航标tesg舾tesj盘查tesk舸tet艇,舴teta舰长,透彻tete船舶,船舱,舰艇tetf舴,航行teth盘算tetk稻种,航程tetm航向tetp艇teu艏,艟teuf艟,筋斗,乘胜前进teug秀美,笑逐颜开teuh艏teuk盘问teuq航次teut航道tev稻,艘tevc艘tevg稻tevi盘剥tew舱tewa租借tewb舱tewt租赁tewu舱位teww稻谷tex舭texa盘绕texg航线texx舭tey航,舷,舣teyl盘库teym航teyn舫teyp透亮teyq舣teyt盘旋teyu笈teyx舷,利用率tf行,等,靠tfad行期tfap徒劳tfaq街区,选区,各地区tfat行医tfbc选取tfbj德阳tfbm选出,选聘,迁出tfc丢tfca先驱tfck行驶tfct千载难逢tfcu丢tfcw毛难tfcy行骗tfd壬tfdg千古tfdj先辈,千百tfdn千万,赞成,造成tfdq千克tfef得过且过tfeg赞助tfet选用tff竺,街,待tffc行动tffg毛坯tffh街,行走,迁走tffj先进,行进tffn得寸进尺tfft德才tffu等tffy待,街坊tfga徒刑,造型tfgc等到,迁至tfgd先天tfgf等于,先于tfgh德政,行政tfgi矢志不渝tfgk行事tfgn千瓦tfgq行列,先烈tfgy知无不言tfh秆,徒,稹tfhc毛皮tfhh行,街上,千卡,行动上tfhi徒步,第二步tfhq午餐tfhw稹tfhy徒tfip赞赏tfiq先兆tfir选派tfiw选举,赞誉tfj午,竿,篝tfjf篝,千里tfjg选题tfjm待遇tfk千,告,造tfkb郜tfkc赞叹tfkd靠tfkf告tfkg秸,鹄,等号tfkh先遣,行路,行踪tfkl告别tfkp造tfkt循规蹈矩tfl德tflf行署tflg德国tfln德tflp靠边tfmd靠岸,行贿tfmg等同,赞同tfmm靠山tfmq选购tfn毛,毯,毡tfna选民tfnd迁居tfnf先导tfng行情tfnh毪tfnj氆,氇tfnk毡tfnn毳tfno毯tfnp毽tfnt告发,毛发,先进性tfnv毛tfny街心tfog待业,行业tfou毛料tfoy千米tfp迁,廷,迕tfpd廷,德宏tfpe行家tfpg选定tfpk迁,迕tfpl行军tfpw行窃tfpy造福tfq先,赞,选tfqb先,行凶tfqh等外tfqi行销tfqk第二名tfqm赞tfqn午饭tfqp选tfqq千金tfqt先锋tfqu筠tfqv告急tfrc选择tfrd选拔tfrg告捷,午后tfrh丢掉tfrn赞扬tfrp靠近tfrr先哲,第二把手tfrt千斤,徒手tfrw丢失tfrx待批tfsb行李tfsf选材,选票tfsg选配tfsj待查tfsk赞歌tfss造林tft箸tftc行径tftd告辞,告知,先知tfte造船tftf等待,等等,毛毯,先行tftg毛重,先生tfth迁徙,科教片,选自tftj箸,毛利tftk行程tfto千秋tftq迁移tftt毛笔tfty迁入,迁往,选入tfu乖,穑tfud告状,街头,选送,入场券tfue午前tfuf行装tfug毛病,赞美tfuj午间tfuk穑tfuq等效,行将tfut街道,德才兼备tfux乖,徒弟tfv歃tfvb选好tfvc迁怒tfvw歃tfwa第二代tfwc赞颂tfwf等值,行会,奥运会,冬运会tfwg待命,行使tfwh等候tfws午休tfww等价,行人,等人tfwx自动化tfwy选集tfxe等级tfxf待续tfxg毛线tfxq造纸tfxt告终tfxy毛纺tfya告诫tfyc德育,丢弃tfye造谣tfyg赞语tfyi迁就,造就tfyl行为tfym选调tfyr告诉tfyt德州,赞许tfyw午夜tfyx造诣tfyy行文tg生,重,策tga垂,笄tgaf垂tgaj笄,策划tgaq行政区tgbd秉承tgbm征聘tgbn算不了tgbq熏陶tgcc重叠tgce行不通tgd生tgdc条形码tgdd重大tgdg生硬tgdh生存,自下而上tgdn生成tgdy生态,生死存亡tge箐tgeb征服tgef箐tget征用,重用tgf竽tgfb重地tgfc策动,生动tgfg身残志不残tgfh垂直,秉直tgfi征求tgfj竽,身残志坚tgfw等于零tggb入不敷出tggc得不到tggi生还tggj生理tggk重整,先天不足tggm重现tggo生来tggq生死,生殖tggu生平tgh征,惩,眚tghf眚tghg征tghi第一步tghk征战,重点tghn惩tgic惩治tgid生涯tgif行政法tgii自来水tgij重温tgip物理学tgiq征兆tgit生活tgiv熏染,生吞活剥tgiy第一流tgj重,穗,筻tgjf重tgjg重量tgjh重申tgjj生日tgjn穗tgjq筻tgk衙,籁,簌tgkh衙,生路tgkk处理品tgkm籁,管理员tgku微不足道tgkw簌tgl熏,甥tglf智囊团tgll甥tglo熏tglt策略,繁殖力tglw惩办tgly惩罚,重罚tgm策,箦tgmi策tgmq征购tgmu箦tgnh生疏,征收tgnn管理局tgnt秉性,生性,特殊性,先天性tgny重心tgo徕tgoy徕tgpf循环赛tgpw息事宁人tgpy重视tgqd垂危,得天独厚tgqf重镇tgqk第一名tgqm重负tgqr生铁tgqt生猪tgr笺tgrc策反,重返tgrg征兵tgrj重担tgrn生气,管理所tgrr第一把手tgrt第一手tgrx先下手为强tgs秣tgsc行政权tgsf翻来覆去,翻天覆地tgsm生机,处理机,各不相同,微型机tgsu臭不可闻tgsv重要,生根tgsy秣tgta生长tgtd重逢tgtf称王称霸,翻来复去tgth惩处,重版,管理处tgtj重复tgtk征程tgto翻两番,翻一番tgtp征管tgtr生物tgtu征税tgty征稿tgu秤tgud生养tgug生病tguh秤tguj生意tguq生效,重奖,第一次tgus重新tgut生产tgv秉tgvf重建tgvi秉tgvk征召tgwa告一段落tgwb重创tgwc秉公tgwd惩一儆百tgwg生命tgwh每一个tgwj条理分明tgwr得不偿失tgwt征途,重任tgwu第一位,生死攸关tgwx特殊化,系列化tgwy征集tgxg第一线tgxj管理费tgxk赞不绝口tgxt生疑tgyc生育tgyd重庆tgyf生计,重整旗鼓tgyi策应tgym征调tgyq征询tgys征订tgyx繁殖率tgyy征文th处,自,算tha算thaa算式thad延期,自荐thaj算tham自贡than处世thap自营thbb牌子thbg自卫thbm算出thc彼thce怎能thcy彼thd自,臭,篡thdc篡thdf怎奈,自夸,乱占耕地thdg自上而下thdh处在,自在thdi纂thdm版面,片面thdr自愿thdt乘虚而入thdu臭thep自爱thet自用thf乍,怎,迮thfc自动thfd乍thff自封thfn怎thfp迮thfu处境thg片,版,牌thgc版thgd牍thgf牌,处于,长此下去thgj处理,自理thgk处事thgl版画thgn片thgs牒thgy牖thh徙,衢thhh衢thho笑眯眯thhx彼此thhy徙thi处thia自满thic自治thif算法thip自觉thiy自流thj昝thjf昝thjg算是thjv牌照thk咎thkf咎thkg牌号thkh自足thl鼻,鼾,齄thlf鼾,处置thlg齄thlj鼻,劓thlt版图,自力thlv鼽thlw自办thly处罚thmd彼岸thmh自由,算帐thn息thnf自恃,自慰thnn自己thnt篡改,自发,长此以往thnu息,自习thny处以,延迟thon片断thov算数thp延thpd延thpe自家thpg自定thpp处之thpu彼此之间thpv延安thqd自然thqi自销thqk自勉thqm自负thqs自杀thqu辞旧迎新thrd延拓thrf自持thrh往上爬thrm自制thrn处所thrp自控thrt自卑ths臬thsc版权thsg版本thsr刮目相看thsu臬,怎样thsy自述thta处长thtc怎么,自私thtd自筹thte算盘thtf自行thtg自重thth处处thtl自备thtq自称,各具特色thuk自问thun处决,自决thus自新,自尊thut自首thuu自立thvc息怒thvk自如thwd片段thwf自传thwj延伸thwv处分thww牌价thwy自信thxe延缓thxf延续thxj自费thxk自强thxl自幼thxw自给thxy自编thyf算计thyg自主thyk延误thyn片刻,先睹为快thyp自豪thyt衢州thyy处方ti秒,稍,簿tiai毛泽东tiaq生活区,自治区tibp科学院tidd稍大tide稍有tidf自学成才tidi长江三角洲tidq积少成多tie稍,筲tief筲tieg稍,自治县tif衍,愆tifb策源地tifh衍tifn愆tig簿tigf簿tigi稍不tigt冬小麦tihh生活上tiif选举法tiih稍小tijf每小时tilw科学界tim徜timk徜tint科学性,自觉性tion短小精悍tiqi知法犯法tiqk秒钟tiqp长治久安tir箔tirf箔tirg稍后tisc选举权tit秒titd自觉自愿titf稍等titi稍稍titm稍微titt秒tiud稍差tivb稍好tiwq稍低tiwt稍作tiww乱涨价tiwx科学化tixj生活费tiyl稍为tiym长沙市,各省市,稍高tiyt自治州tiyx利润率,入学率,升学率tj得,复,利tjad长时期,每星期tjaf身临其境tjai利落tjal复苏tjbb筛子,微电子tjbi复函tjbm得出,复出tjbn得了tjcn千里马tjdr复原tjdy物归原主tjet得胜,利用tjey微电脑tjf香tjfi得救tjfp利索tjg得,筛,笪tjgc得到tjgf得,笪,篮球,利于tjgh筛tjh利tjia香港tjif得法tjit复活tjiu利润tjiv得当tjiw复兴tjjn复电tjkg得逞tjkm复员tjlg利国tjlt得力tjna利民tjnk复辟tjnn利己tjnt复发tjnu复习tjny得以tjoi稀里糊涂tjol香烟tjoo香火tjpc各显神通tjpd利害tjpf复赛tjqg复印tjqk得名tjr犁tjrh犁tjrm复制tjrt得手tjrw得失tjs梨,稞tjsj复查tjsu梨tjsy稞,复核tjt复,篮,馥tjtd得知,香甜tjtf筛选tjth利息tjtj得利tjtl篮tjtt馥tjtu复,利税tjty每时每刻tjuj得意tjum利弊tjuq得奖,复交tjuw得益,利益tjvs复杂tjwc选贤任能tjwg复合tjws得体tjwv得分tjww利欲tjwy复信tjxg复线tjya透明度tjyj复课tjyt利诱tjyx利率tjyy复议tk各,种,积tkaa各式tkad各项tkaw种花tkay和蔼,积蓄tkbb种子tkbc积聚tkbw先遣队tkdb稳中有降tkde各有tkdf积压tkdh积存tkec积肥tkf各tkfb种地,各地tkfv积雪tkg和,程tkgg程tkgu和平tkgy矢口否认tkh种,篑tkhf和睦tkhh种tkhm篑tkii积水tkit各省tkjg特别是tkjq和煦tkk稆tkkf笑嘻嘻tkkg稆tklg各国tkll种田tklw各界tklx积累tkm禹tkmy禹tkna各异tkod各类,种类tkog各业tkqb积怨tkqe和解tkqw积欠tkrn和气tkrp程控tkrt积攒tkse积极tksf种植tksl重蹈覆辙tksr臭味相投tksu各样tkta委员长tktf各行tkth各处,各自,入口处tktk各种,种种tkud和善tkuk各部tkvb和好tkw积,雒tkwf委员会tkwh各个tkwu各位tkwv积分tkww各人tkwy积,雒tkxe和缓,各级tkxq和约tkya程度tkyb长距离,短距离tkyc程序tkyo和谈tkyt各族,种族tkyx和谐tkyy各方tl务,血,备tlay备荒,自圆其说tlb务tld血,篾tlde备有tldf血压tldi备耕tldt篾tlej血腥tlet备用tlf备,睾tlff睾tlfi务求,乱加干涉tlg箅tlgj箅tlgt自力更生tlha务虚tlhk备战tlif血汗tlih血泪tlir血泊tliy备注,血液tlk徊,笳tlkf笳tlkg徊tlmw血肉tln惫,衄tlnf衄tlnt务必,策略性tlnu惫tlo粤tlon粤tlou备料tlp笾tlpl生力军tlpu笾,务实tlpv备案tlq箩,囱,囟tlqc血色tlqi囱,囟tlqu箩tlsj备查tltn利国利民tltp血管tlu衅tluf衅tluh靠边站tlvb备好tlw稷tlwg务使tlwr备件tlwt稷tlww备份,得罪人tlxx血缘tlyg务请tlyj备课,备齐tlyn特困户tlyo血迹tm向,身,射tmaa自由式tmad躲藏tmai微薄,向东tmal秧苗tman身世tmb秃tmbj向阳tmc役tmcm微观tmcy役tmd身,躺,躲tmda向左tmdf射tmdi乘风破浪tmdk躺,向右tmdm颓tmdq躯tmds躲tmdt身tmdx躬tmdy秧tmf笛,稠tmfk稠tmfm射击,翻山越岭tmft身教tmfw委曲求全tmg微,徵,筒tmga躲开,微型tmgh躺下,向下tmgk筒tmgo向来tmgt徽,徵,微tmh币tmhh向上tmhk币tmia牡丹江tmih微波,微小tmiy自由泳tmjg微量tmjw移风易俗tmjy身影tmk向tmkd向tmkm靠山吃山tmlf徽墨tmlp身边tmmq微风tmmt颓败tmmw向内tmnf向导tmnk躲避tmny身心tmo奥tmod奥tmou微粒tmpj先见之明tmpn稠密tmpu生财之道tmq秽,笕tmqb笕tmqg身败名裂tmqh向外tmqy秽tmrg身后,向后tmsf身材tmsg向西tmsl血肉相连tmsm微机tmtb咎由自取tmtk射程tmtm身躯tmtn奥秘tmtt微笑tmty向往tmue向前tmuw躲闪tmux向北tmvi奥妙,微妙tmwg躺倒tmws躯体,身体tmww身份,身价tmwx自由化tmxf和风细雨tmxu微弱tmyn身亡,颓废tn秘,乞,筷tnab各司其职tnae物尽其用tnb乞tnbb筷子tnfi乞求tng笥tngk笥tnkq秘史tnlt向心力tnn筷tnnn秘书tnnt自发性tnnw筷tnp迄tnpn秘密tnpv迄tnrc各尽所能tnrw先发制人tnsb身居要职tnsi徇情枉法tnt秘tnta秘书长tntg入情入理tnth处心积虑,秘书处tntt秘,知己知彼tntu利改税tnvu称心如意tnww知情人,知心人tnwy迄今tnxj乱收费tnxr身怀绝技tnyf乞讨tnyj自以为是tnyl自以为tnyn秘诀tnyr得心应手tnyt各民族tnyw身居高位tnyy秘方to秋,愁,翻toad愁苦toc释toch释todi秋耕toeu翻腾toew翻脸tofh翻越toga翻开togd秋天toiu翻滚tol番,鄱tolb鄱tolf番,翻转tolg翻车toln翻tom釉tomg釉tomq秋风ton悉,簖tonh秋收tonr簖tonu愁,悉tony悉心tooy秋粮toqc秋色toqg翻印torg秋后tort秋播totb秋季toth翻版totm翻身toto翻番totu秋冬tous翻新touu翻阅tov篓tovf篓,翻建towh翻修toxf愁绪toxt释疑toy秋toyc翻译toyq释义toyt释放tp管,乏,稼tpai知之甚少tpdc千军万马tpdu行之有效tpdy千家万户tpe稼tpey稼tpfg先富起来tpgj管理tpi乏tpkf乏味tplp管辖tpn管tpnn管tpnt稳定性tpq箢tpqb箢tprm管制tpsr笑容可掬tptf长安街tpty各家各户tpvb管好tpw箜tpwa箜tpxt航空母舰tpyl称之为tq称,稳,移tqai稀薄tqbk称职tqbw先锋队tqck适销对路tqd稀,衡tqdc称雄tqde稀有tqdh衡,稀tqdo千锤百炼tqds稀奇tqef自负盈亏tqev稳妥tqf衔tqfa移栽tqfb自留地tqfc移动tqff稀土tqfh衔tqfr臭名远扬tqgn千钧一发tqhi稳步tqi称tqit稀少tqiv稳当tqiy称tqj徇tqja臭名昭著tqjg徇,衡量tqk笱tqkf笱tqkg称号tqkk衡器tqkt称呼tqld稳固tqlt自然力tqlw自然界tqna移民tqnd移居tqng徇情tqnh稀疏tqnn称快,翻然悔悟,知错必改tqny称心tqpg稳定tqpt身外之物tqpw稀罕tqq移tqqy移tqr笏,篼tqrh向钱看tqrq篼tqrr笏tqru衔接tqsf移植,自然村tqsm复印机tqsw稀松tqt黎,黧tqtc徇私tqtf称赞tqtg稳重tqti黎tqto黧tqtw身负重任tqud移送tqug自然美tquq移交tqut称道tqv稳,筝tqvh筝tqvn稳tqwc称颂tqwf逢凶化吉tqwv稳健tqwy稳住tqya知名度tqyl称为tqyt称许,黎族tqyv生儿育女tr物,特,牧tra箍,箝traf箝trah箍traj牧草trap犒劳traq牧区,特区trbp我院trc筢,箨trcb筢trch箨trd犄,牯trdd特大,生搬硬套trde特有trdg牯,我厂trdk犄tret御用trf特,循,犊trfa逢年过节trfb特地trfd犊trff特,生气勃勃trfg牡trfh循trfj特刊trfn牧场trg徨,篁,牾trgf篁trgg徨,循环trgj物理trgk牾trgq特殊trh御,篪,笊trhb御trhk特点trhm篪trhw犋trhx特此trhy笊tri穆trie穆trig短斤少两trip犒赏trir特派triy物流trk筘trkf筘trkk物品,复制品trkl特别trlg我国trlk特辑trlt物力trlw科技界trmb乱扣帽子trn我,鹅trna牧民,特异trng鹅trnm各持己见,各抒己见trnn特快,我局trnt我,特性trog牧业trpf御寒,选拔赛trpg特定,特写trpl我军trq物,籀trqc特色trql籀trqn科技馆trqr物trqv特急trrf特技,物质trrv科技热trry特邀trs牺trsc特权trsg牺trsr短兵相接trsu我校trt牧,牲,稗trta特长trtd御敌trtf稗,特等trtg牲,特征,臭气熏天trth我处trtk牿,物种trtm特向trtn牦trtr牺牲,稳扎稳打trtw矫揉造作trty牧trud牧羊,延年益寿truj特意truq特效,物资,科技奖trut特产,物产trv犍trvp犍trw秩trwg特例,特使trwr物件trws物体trwu我们trww物价trwy秩trx牝trxe特级trxn牝try徼,犒,犏trya犏tryc秩序tryg物证,物主tryk犒trym血气方刚tryt徼,特许tryx牲畜tryy我方ts条,笨,箱tsad奥林匹克tsbb条子,笔杆子tscr自相矛盾tsdh适可而止tsdw入木三分tsff条款,生机勃勃tsfg矫枉过正tsg笨tsgf笨tsgj条理tsh箱tshf箱tshh条目tsj簟tsjj簟tslf种植园tsnr物极必反tsnt积极性,重要性tsog种植业tsrb笨拙tsrs身材魁梧tss篥tssu篥tstg笨重tsu条tswg条例tswr条件tswy条令tsxq条约tsxy条纹tsy秫tsyy秫,条文tt笔,禾,笑ttad生长期ttaj各行其是,自行其是ttal禾苗ttaq自得其乐ttar适得其反ttat微乎其微ttcr积重难返ttd笑,篷ttdc自告奋勇ttdd千千万万ttdo千秋大业ttdp篷ttdu笑ttdy长篇大论ttee笑貌ttew笑脸ttf笔,筅ttfh笔直ttfn笔,笑声ttfq筅ttft笔者,先行者ttfy身先士卒ttg竹,笙ttgf笙ttgh竹,笔下ttgs微处理机ttgt千篇一律ttgy攵tth笮,筵tthf笮tthh称得上tthp筵tthx各条战线ttif笔法ttin和稀泥ttip生物学ttkk牺牲品ttl丿,篦ttlc重重困难ttlf笔墨ttlg自行车ttll丿ttlw怎么办ttlx篦ttn夂,秭,笫ttnn税务局ttnt秭,笫ttny夂ttog各行业,造船业ttou笑料ttpj自知之明ttpn先行官ttpw笑容ttrb和盘托出ttrn税务所ttrq短短的ttrt笔挺ttsc息息相通ttsg笑柄ttss条条框框ttsu息息相关,怎么样ttt禾,彳tttb秋冬季tttg我行我素ttth彳ttto各行各业tttr微生物tttt禾,自私自利tttu自身利益tttw笔答ttuf自选商场ttuq特等奖ttuu躲躲闪闪,简简单单ttuy循循善诱ttvi笔录ttwf奥委会,筹委会,管委会ttws德智体,翻箱倒柜ttwu先生们ttwy靠得住ttxm笑纳ttya笔试ttyc笔译ttyg笑语ttyk笔误ttym笔调ttyn笔记ttyo笑谈ttyx生长率ttyy先入为主tu科,剩,乘tuan街头巷尾tuax特效药tubg简陋tuca重头戏tud徉tuda千辛万苦tudd科大,千姿百态tudg科研tudh徉tudl简历tudx千头万绪tue箭tuej箭tuf笠tuff税款tufh科,简直tufj向前进tufl科协tuft科教,生产者tugd冬天tugh剩下tugt冬麦tugy科班tuh乎tuhh科目,税目tuhk乎tuif简洁tuii得意洋洋tuip科学tuiy冬泳tuj简,箪,螽tuje简明tujf简,箪tujg生产量tujj螽tujq简易tuk税tukq税tulg乘车,生产国tuln筋疲力尽tult简略,生产力tumj税则tunh税收tunq和颜悦色tuny自尊心tuob身兼数职tupg科室tupp等闲视之tupt乘客,税额tuqe得道多助tuqq税金tuqt稳准狠turb简报turf科技turg简捷turh向前看turm税制tusc自决权tusf税票tush简朴tusm乘机tusv简要tusy简述tuta科长,毛遂自荐tutb冬季tutd简短tute乘船tutk税种tutl税务tutn彻头彻尾tutq简称tutv科委,各部委tutw先决条件tuu冬tuub先头部队tuud箭头tuuj简单,简章tuuk简况tuuo科普tuus冬闲tuuy各部门tuwg简便,每况愈下tuwj简介tuwt剩余tuwu各单位tuww乘坐tuwx简化,简单化tuwy物美价廉tux乘tuxa简练tuxc生意经tuxe科级tuxg生产线tuxj剩tuxr惩前毖后tuxv乘tuyg得意忘形tuyk冬训tuyn简讯,科盲tuyu稳产高产tuyx税率,生产率tv委,魏,律tvcw很难tvdd很大tvdm稳如泰山tve很,簋tvel簋tvey很tvf委tvfg很坏tvfh律tvgx自始至终tvi箫tvih很小tvij箫tvir委派tvit很少tvjf自即日起tvjg律师tvk笤tvkf笤tvkm委员tvma委曲tvnb委屈tvnj很慢tvnn很快tvnt复杂性tvny委以tvp逶tvpd逶tvpu委实tvqq很多tvr魏tvrc魏tvrt委托tvt笋tvta很长tvtb逶迤tvtd很短tvtg很重tvtr笋tvvb很好tvvp委婉tvwt委任tvwx复杂化tvym很高tw答,签,徐twa筏twal自食其力twar筏twdo秉公而断twf符twfu符twg答,筌,簦twgc签到twgf筌,适合于twgi签twgk答twgl乱作一团twgu簦twh筱twht筱twi黍,黏twik黏twiu黍twjy长途电话twkg符号twlf签署twlg秉公办事twlt生命力,身体力行twn篌twnd篌twnh签收twnn物价局twnt签发twny得人心,自信心twpb签字twpg签定twpv答案twqk签名twrn稚气,先人后己twrt先公后私twt徐twtj答复twty徐twud答卷twuw知人善任twuy答辩twwg符合twwu生命攸关twxg生命线twxq签约twy稚,稔twyg稚,签证,身份证twyi答应twyn稔,答词twys签订twyt答谢,徐州twyx自作主张tx第,每,系txad繁茂txap繁荣txbg每隔txbw入乡随俗txcw繁难txdg敏感,第三,毛纺厂txdn繁盛txdx千丝万缕txe篆,胤txee每月txen胤txeu篆txfg第二txg每,敏,鳘txgd每天txgf系于txgg第一txgi繁,繁琐txgq毓,繁殖,系列txgt敏,自强不息txgu每txh第txht第txi系txiu系txiv每当txjj每日txkk毛织品txlu身强力壮txmf每周txnt系统性txny繁忙txov系数txpe每家txqq繁多txqu敏锐txrg敏捷txrh每年txrm等级制txt後txtd每逢txtg繁重txti繁衍txtk自给自足txty後txuq每次txvs繁杂txwh每个txwu身强体壮txww每人txwx繁华txx秕,筚txxd毛纺织厂txxf筚txxn秕txxy系统txyc繁育txyn每户ty入,往,篇tyaj往昔tyaw造谣惑众tyay街谈巷议tyb篱tybc篱tybg入耳tybk自谋出路tybo自谋职业tybw入队tycl适应能力tydg自豪感tydm各方面,知识面tydw入春tydy千方百计tyem入股tyfn入场tyfq秋毫无犯,秩序井然tyfu入境,答记者问tyg往tyga长方形tygg往tygk往事tygo往来tygu行为不端tygy短训班tyhh篇目,往上tyi入tyif循序渐进tyip入党,入学,往常tyiu汆tyjj往日tyk穰tyke穰tykk入口tykw造谣中伤tylf入团tylw知识界tym稿,篙tymh篇幅,入帐tymk稿,篙tymw入内tyn彷,簏tyna篇tynt适应性,知识性tynx簏tyo籴tyop入迷tyou籴typp简言之typw答谢宴会typy入神,甜言蜜语tyqh往外tyrc往返tyrd秋高气爽tyre簇拥tyrg往后tyrh往年tysc自主权tysg笔记本tyt簇tytc篱笆tytd簇,自高自大tytf入选tytj往复tytr彷徨tytu入冬tyty往往tyue往前tyuj篇章tyus簇新tyuy入门tyv稂tyve稂tyvi备忘录tywb入仓tywf入会tywg入伍tywi私设公堂tywl丢卒保车tywo入伙tywr稿件tywv入侵tywx知识化tyxa繁文缛节tyyl入库tyyt德高望重tyyw入夜,入座u产,着,将ua并,瓶,冻uaaa闭幕式uaan新工艺uabb瓶子uabp总医院uabu并联uace并能uade并有uadg奠基石uadh并存uadj并非uaeg并且uaet并用uaf疳uafc盖世无双uafd疳uafi并未uafj并进uafm新贡献uafq并无uafw旁若无人uag瓶,疟uagd疟,并吞uagi并不uagn瓶uagq并列,冻死uai冻uaiw并举uaiy冻uaj并,瘼uajd瘼uak阈uakg阈ualf并转ualw新世界uam癀uaml将功赎罪uamw癀uant迸发,并发uany前功尽弃uaop总营业额uap迸,痨uapd冻害uapk迸uapl痨uarb并报uard并排uarj并提uarl将功折罪uarp并按uasu新花样uasv并要uatf并行uatj总工程师uaty并入uauf瓶装,冷若冰霜uauq单项奖uauu并立uauy半工半读uaw瘩uawf总工会uawk瘩uawt冻伤uaww奠基人uaxf冻结uayg并请uayn并肩,闭幕词ub闻,逆,瘾ubbg逆耳ubd闻ubfn闻声ubfu逆境ubif疗法ubiy逆流ubk疗,疖ublf逆转ublt凝聚力ubou塑料ubq瘾ubqk闻名ubqn瘾ubt逆,朔,塑ubte朔ubtf塑,塑造ubtg癃ubtk疗程ubtp逆ubts槊ubud疗养,逆差ubuq疗效ubwd新阶段ubwq塑像ubwy新陈代谢ubyn闻讯ubyx产出率uc冯,痛,闯uca痉ucaa竣工ucad痉,痛苦ucd闯ucdg痛感uce痛,衮ucek痛uceu衮ucfi旁观者清ucfj闯进ucfm痛击ucg冯uck冶uckg冶uclq瘫软ucmm交通岗ucna痛惜ucnn痛快ucnv痛恨ucny痛心ucoa冶炼ucq兖ucqb兖ucqq冶金ucrs痛打ucrw痛失ucry痛斥ucth痛处,总预算ucty闯入ucud闯关ucuk交通部ucuq闯将,瘫痪ucuu痛痒ucuv疤痕ucv疤ucw竣,瘫ucwt竣ucww普通人ucwy瘫,新观念ucxg交通线ucy瘙ucyj瘙ucyt普通话,总参谋长ud关,头,送uda差udab关节udaf差udag凑巧udai着落udav关切udb郑,卷udbb卷,半辈子udbf着陆udbh郑,羞耻udc闳,羟,羧udca羟udci闳udcq养鸡udct羧udd闫uddd养大uddf减压,羞辱uddp兼而有之uddy状态ude豢udeu豢udey头脑udfh送走udfm拳击udfq状元udft养老udg减udga判刑udgc送到udgf关于,善于udgi送还udgk减速udgq养殖udgt减udh着,眷,瘛udhf着,眷udhh头目,头上udhk善战udhn瘛udhv着眼udi头udif减法udih减小udiq叛逃udit减少,养活udiv羞涩udiy关注udj羊,判,阉udjd痱udje判明udjg并非易事udjh判udjn阉,羯udjv关照udkg头号udkh差遣,差距,养路udkk关口,半成品udkl差别,判别,送别udkm减员udl疬udlc减轻udlg叛国udlk送回udlt着力udlv疬udm羰udma卷曲udmo羰udn羞,翔,羌udna差异,着慌udnb羌udnf羞,羞怯udng翔,关怀udnh减收udnj减慢udnr羞愧udnt眷属,头发,准确性udnv疣,疠udny关心udoa送煤udol卷烟udon判断udoo着火udop着迷udp送,闼udpe养家udpf卷宗udpg判定udpi送,闼udpl叛军udpo减灾udpt差额udpu着实udpv判案udpy送礼udq羝,鲞udqa差错udqc着色udqg鲞udqk减免udqt养猪udqv关键,着急udqy羝udr拳,叛udrc叛udrg养兵udrj拳udrl关押udrn送气udrt着手uds桊udsd头顶udsg总成本udsi北大西洋udsu桊udtd叛乱udtf叛徒,送行,羊毛udtg郑重,着重udth判处udtk总面积udtq头衔udtr益寿延年udts头条udtu关税,减税udtx关系udty卷入,送入udu关,善,鄯udub鄯uduc头痛udud豢养,拳头uduf关闭,减半,着装uduj善意,着意uduk善,头部,状况udun判决uduq送交udut减产,头疼uduy关门,着凉udv券udvb券udve减退udvh并非如此udw凑,羚udwc羚udwd凑udwg判例udwq减低udwt头面人物udwv养分udww减价udwx送货udwy送信udxe减缓udxf头绪udxg总成绩udxu减弱udy状,养,誊udyb叛离udyc养育udyf誊udyj养udyo眷恋,叛变udyp总而言之udys着魔udyt郑州udyv善良udyx准确率ue前,剪,毅uead前期uebg前卫ueca前驱uedc交朋友uedj前辈uedm前面uedr遂愿uedw前奏uees剪彩uefa剪裁uefc前去uefj前进,半月刊uefn前场ueg疽uega普及型uegd疽,前天uego前来uegq煎熬uehg问及此事uehk立脚点ueim前沿ueiq前兆ueiu羊肠小道uej前,煎,翦uejj前uejn翦uejo煎uejv剪uejy剪影,前景uek痈ueki前哨uelk剪辑uelp前边uelt毅力uem毅uemc毅uemq道貌岸然uenr头脑发热uep遂,阌uepc阌uepi遂ueps遂宁ueqd毅然ueqt前锋,前夕uerd前排uerg前后uerh前年uerj前提uetk前程uetm前身uety前往ueud前头ueuh前站ueuj遂意ueut半脱产uevn剪刀uewr装腔作势uewt前途ueww六月份uexg前线uey瘃ueyi瘃ueyw前夜ueyx普及率ueyy前方,前言uf半,斗,装ufaj闭幕ufaq斗殴ufaw兰花ufax意志薄弱ufbm总支出ufbp养老院ufc阖ufcl阖ufcm壮观ufdd凌厉,壮大ufde装有ufdf凌辱ufee半月ufej斗胆,壮胆ufex尊老爱幼uff兰,闺,痔uffa装载uffc装运uffd闺uffi痔,总需求uffn斗志,壮志uffs壮志未酬ufg壮ufgk装束,总干事ufgm壮丽ufgq壮烈ufgy总起来说ufh阗,癫ufhm癫ufhw阗ufih冲击波ufis北戴河ufiw壮举ufjd凌晨ufjf背地里ufjr斗志昂扬ufk斗,半ufkh半路ufkm总动员uflf装置uflg装车uflk半圆,凌驾ufmf闻过则喜ufn闱,痣ufnh闱ufni痣ufpf闭塞ufpg总协定ufpu壮实ufqn装饰ufqq养老金ufqv斗争ufqy半岛ufrh半年,壮年,装卸ufrv总趋势ufrw装扮,六十年代ufrx前赴后继ufsa总规模ufsg装配ufsm装机uft闭uftc半径uftd斗智ufte闭uftg卷土重来uftl装备uftm新动向ufts装箱ufuf新老交替,壮志凌云ufug关起门来ufui壮阔ufvv闺女ufw凌ufwf闭会ufwg闭合ufwh半个,装修ufwt凌ufwx装货ufxa总教练ufy装ufye装ufys装订ufyt兰州,壮族ufyw半夜ufyx背井离乡ug闰,美,病ugaa美工,新形式ugaj羡慕ugal病菌ugbp病院ugby冷不防ugce并不能,决不能ugcm美观ugcr并不矛盾ugd闩,闰ugdg美感ugdl病历ugdu美ugdw疲于奔命ugdy病态uge靖ugeg靖ugen美不胜收ugeq决一胜负ugfb新天地ugff冰天雪地ugfn养殖场ugfq美元uggj病理uggm美丽uggq病残uggu善恶不辨uggx病毒ugh症ughd症,决一雌雄ughq差一点儿ugi痞ugia美满ugik痞ugip美学ugis美酒ugiu总政治部ugiy美洲ugjg并不是,决不是ugjy美景ugk辣,癞,痘ugkd痦ugkf美味ugki辣,竦ugkj瘌ugkm癞,病员ugku痘ugl盖,阑ugld病因uglf盖uglg美国ugli阑uglk头一回uglw决不罢休ugm病ugmw病ugmy普天同庆ugn恙ugna美展ugnc凄惨ugnu恙ugo羔,羹,痖ugod羹ugog痖,新开业,养殖业ugou羔ugpl美军ugpv病案ugpw美容ugq冽ugqa六一儿童节ugqd病危ugqi总开销ugqj冽ugqk美名ugqq差不多ugrg新形势下ugrh头一年ugrv新形势ugsj病榻ugss美梦ugsv病根ugsy美术ugt羲ugtf美德ugtg并不等于,总政策ugtq美称ugtr新事物ugtt羲ugu羡,瘗uguc病痛ugud病状,症状uguf瘗ugug病症uguq头一次uguw羡uguy凄凉ugv姜,凄ugvb美好ugvf姜ugvi美妙ugvv凄ugvw疾恶如仇ugwa新一代ugwd前一段ugwe站不住脚ugwf决不会ugwg病例,病愈ugwn症侯ugww病人ugwx美化ugwy决不食言,闲不住,站不住ugx冱,痍ugxf症结ugxg冱ugxw痍ugy癍ugyc美育ugyg癍ugym新开设ugyo病变ugys病魔ugyw前政府ugyy美方uh站,丫,疲uhap疲劳uhbw站队uhc疲uhci疲uhck站台uhd阒uhdi阒uhgd前些天uhgf着眼于uhh癯uhhk着眼点uhhy癯uhjw前些时候uhk丫uhkg站uhlq疲软uhmm站岗uhnt前瞻性uhpg站定uhqu送旧迎新uhsf总目标uht夔uhta站长uhtl疲惫uhtp疲乏uhtq站稳uhtr首战告捷uhtt夔uhuf阔步前进,新旧交替uhuu站立uhwr新旧体制uhwu疲倦uhwy站住uhx疵uhxv疵ui冰,阔,瘠uiau首当其冲uibp商学院uide并没有uifq冰雹uifv冰雪uigh背水一战uigu新水平uihk交汇点uii痧uiis冰河uiit痧uikl阔别uikt冰川uiqq奖学金uirn阔气uirq前清后欠uisa冰柜uit阔uitd阔uits冰箱uitt逆水行舟uiua冰冻uiuo新兴产业uiuw冰冷uiuy冰凉uiw瘠uiwe瘠uiwf交流会uiy冰uiyt资深望重uiyw立党为公uj间,竟,单ujaa童工,闪电式ujab章节ujad单项,新时期ujai单薄ujak间或ujb鄣ujbg间隔ujbh鄣ujbi间隙ujd间ujde竟有ujdh意在ujdr意愿uje彰ujet彰ujf音,童,郸ujfb郸ujfe冁ujff童ujfg单干ujfi竟未ujfj单ujfm闽南ujfn意志ujfq单元ujfu意境ujg疸ujgd疸ujgg单一uji闽ujif章法ujj章,阊ujjd阊ujjq间歇ujkf意味,韵味ujkt音响ujl瘟ujld瘟ujln意思ujlt竭力,意图ujlv单轨ujmm韶山ujmq意见ujn意ujnb竟敢ujnu意ujny竭尽,童心ujon间断ujou意料ujpd病虫害ujpt交易额ujpy瘟神ujq竟,竭,韵ujqb竟ujqd竟然ujqh意外ujqi音乐ujqn竭ujqt单独ujqu韵ujqw歆ujrh童年ujrn单据,意气,交易所ujrs单打,前紧后松ujru间接ujsm单机ujt赣,戆ujtf单行,尊师重教ujtk单程,章程ujtm赣,单身,单向,意向ujtn戆ujud韶关ujuf童装ujum瘟疫ujut单产ujv韶ujvk韶ujwa新时代ujwf意会,交易会ujwq音像ujwt间作ujwu单位ujww单人ujwy意念,音信ujxg单纯,单线ujya间谍ujyc音译ujyd竭诚ujyf将遇良才ujyk意识ujym单调ujyn单词,音讯ujyq意义ujyt童话ujyy单方uk部,总,问ukai部落ukan问世ukaw总共ukb部ukbb新路子ukbh部ukbm冲出ukbw部队,总队ukcd总参ukce总能ukd问ukdg总厂ukdh冲破ukdm剖面ukeg况且ukey问及ukfa总裁ukfc冲动ukfd冲垮ukfh冲走ukfm冲击ukfw辨别真假ukg瓿ukgd冲天ukgf立足于ukgh部下,总政ukgj总理ukgk美中不足ukgm冲刺,兑现ukgn瓿ukh冲ukhh冲ukhk立足点ukio冲淡ukit冲洗,意味深长ukiv问津ukj剖ukjg问题,总量,总是ukjh剖ukjv总归ukk癌,闾ukkd闾ukkm癌uklf部署uklg新中国ukmh总帐ukmj总则ukn总uknm冲刷uknn总局uknt部属uknu总ukod部类ukov总数ukoy商品粮ukpf竞赛,立足之地ukpp总之ukpt总额ukpw冲突ukq况,竞,兑ukqb竞,兑ukqi交响乐ukql交响乐团ukqn况ukqt冲锋ukqv竞争ukrf竞技ukrg总后ukrh冲掉ukrq兑换ukry冷嘲热讽uksh竞相uksm总机uksr剖析ukta部长,总长uktf竞选,总行ukth总算uktk总和,新品种uktl总务uktq总称uktt交口称赞uktv部委uktw问答ukud问卷,意味着ukug癌症ukuh总站ukuk总部ukut部首,总产,美中关系ukux亲兄弟ukuy部门ukva冲毁ukvb问好ukwd部优ukwf兑付,总值ukwh问候ukwr部件ukws总体ukwu部位,总吨位ukwv部分,总分,部颁ukwx商品化ukwy道听途说ukxe部级ukxf总结ukxg总路线ukxy总统ukyf总计ukyg总评ukyn问讯,商品房ukyt部族ul曾,兽,闸ulaa总罢工ulat兽医ulaw善罢甘休uld痼uldd痼ulde曾有uldh曾在ulg兽,痹ulgd半边天ulgj痹ulgk兽ulj曾,甑uljf曾uljn甑ulk闸,痂,瘸ulkd痂ulkw瘸ulny曾以ulpj前车之鉴ulps立国之本ulrj前因后果ulrs前思后想uls阃ulsh新思想ulsi阃ulth交界处ulwt曾任ulx瘰ulxc曾经ulxi瘰ulyc并驾齐驱ulyl曾为ulyy帝国主义um商,端,疯umal疫苗umc疫umci疫umd端umdf闻风而动umdg闻风而至umdj端umf凋umfk凋umfn商场umfw凋零umgd前几天umgh端正umhk端点,商战umi敝,憋,瞥umia弊umig鳖umih瞥,蹩umim新风尚umin憋umit敝,商洛umiw商洽umjg商量umk疝umkk商品umlw商界umm瘿ummq瞥见ummv瘿umng疫情umnj并网发电umog商业umpg商定umpy商社umq疯,飒umqi疯umqt疯狂umqy飒umrg商丘umrh前几年umsf商标umsg商酌umsp商榷umsw商检umte商船umtf商行umti意见簿umtl商务umts意见箱umug弊病,疫病umum弊端umw商umwf商会umwj曾几何时umwk商umwv端倪umww商人umyf端庄,商讨umyh商店umyo商谈umyu端详umyy商议un决,闷,癖una癜unaa首发式unac癜unb阚unbm决出unbt阚undm新局面unet决胜unfn问心无愧ung翊ungi决不ungm新发现ungq决裂ungr首屈一指unh瘕unhc瘕unhk决战uni闷unk癖unkk决口unku癖unna新发展unnn决心书unny决心unon决断unpf决赛unpg决定unqd决然unr疡unre疡unrv闷热untd决心很大untg决策,关怀备至unth决算unty净收入,总收入unud痛改前非unuj决意unuu痛心疾首unw决,瘳unwe瘳unwl竭尽全力unws半导体unwy决,总司令unxf闹情绪unyf决计unyy决议uo普,痰,瘘uoaq产粮区,商业区,养精蓄锐uoat闪烁其辞uobt普降uoce普通uodg塑料厂uoey普及uog普uogj普uogn痴迷不悟uoif普法uolw产业界uomq商业网uonn商业局uont商业性uoo痰uooi痰uopk意料之中uosj普查uouk商业部uov瘘uovd瘘uowx产业化uoyl资料库uoyn普遍up帝,旁,啻upcm旁观upfu亲密无间upkr旁听uplp旁边upm帝upmh帝upmk啻upnt兼容性,决定性upsc决赛权upte音容笑貌upuj问寒问暖upwf新社会upy旁upyb旁upyg旁证uq交,次,资uqa阍uqaa交工uqad将其uqaj阍uqap效劳uqaq郊区uqb郊uqbb冲锋陷阵uqbf交际uqbh郊uqbm交出uqce交通,效能uqcy交叉uqd奖uqdd奖励uqde将有uqdg关键在于,新鲜感uqdl资历uqdu奖uqdy姿态uqeg资助uqet盗用,效用uqf将uqff交款uqfg将士uqfn盗卖uqft竞争者uqfw交替uqfy将uqg癣uqga闻名于世uqgd癣,意外事故uqgf次于,将于uqgi交还uqgk交融,新鲜事uqgo将来uqgy交班uqhk交战uqi浆uqic门外汉uqid资源uqih交涉uqip奖赏uqiu浆uqiy交流,郊游uqj阄uqjg产销量uqjj次日uqjn阄,交电uqjq交易uqjs效果uqkk次品,瓷器,奖品uqlk交加uqlt效力,竞争力uqlw交办,交界uqly奖罚uqm痪uqmd痪uqmf资财uqn疱uqng交情uqnt关键性,竞争性uqnv疱uqny交心uqog养猪业uqoo交火uqou资料uqpf立锥之地uqpl将军uqpp次之uqpu背包袱uqpw盗窃uqqa交错uqqh郊外uqqq奖金,资金uqqt交锋uqrp将近uqrq交换uqrt交手uqru交接uqrv姿势uqs桨,酱uqsc交权uqsd交椅uqsg酱,奖杯,交配,资本uqst资格uqsu桨uqsv次要,将要uqsw冲锋枪uqt效uqtg奖惩,净重uqth奖牌uqti弊多利少uqtj净利uqtu交税,奖金税,减免税uqty效,交稿,交往uqu交uqud奖券,奖状uquj奖章uqun闹独立性uqup关贸总协定uquq毅然决然uqut交道,资产uquw效益uqv净,阎uqvd阎uqvh净uqw次,姿,盗uqwa交代uqwc交公uqwf交付,音乐会uqwk咨uqwl盗uqwm资uqwn瓷,恣uqwo粢uqwu善解人意uqwv姿uqwx交货,净化uqwy次,将领,奖售,效仿uqxj交费uqxk交织uqxm交纳uqxw交给uqy疚,瘤uqyc次序uqyi疚,将就,效应uqyl瘤,将为uqyn新名词uqyo交谈uqyp交谊uqyq咨询,将错就错uqyx效率ur瓣uraw善后工作urc瓣urcu瓣ureg意气用事urfd前所未有urfu前所未闻,闻所未闻urgr总的形势urgy总的来说urmn意气风发urng逆反心理urqj新气象urrp总指挥urru总指挥部ursm交换机ursy新技术urtg善后处理urtj辩护律师urug冷热病uruq总投资urwg半斤八两urwn总揽全局urww辩护人uryg总的说来urys痛失良机us亲,新,闲usaa新式usac单枪匹马usad奠基usae闲散usal新苗usaq新区,尊敬usav亲切usax新药usbq闲聊usdc亲友usdh亲戚usds新奇usdw新春usee亲朋usep亲爱usf瘭usfd新城usfh新址usfi瘭,新要求usfu新增usg尊,奠,遵usga新型usgd奠,猷usgf酋,尊usgg意想不到usgk闲事,新事usgo尊严usgp遵,遒ushv亲眼usi闲usif新潮,新法usij交相辉映usjg尊师usjn闲暇usjt亲临,新星,北极星usjv遵照usk疔uskd疴uskh尊贵,新路uslf闲置uslw美术界,新办usmq新风usnd新居usnn新书,商检局usnt亲属usny闲心usou新材料uspe资本家uspf遵守uspg奠定uspn亲密usq鹇usqg鹇,新鲜usqn美术馆usr新usrg新兵usrh新,新年usrj前松后紧usrp新近usrt亲手,新手usrv亲热,新招ussf新村usta尊长uste新秀ustg亲生,新生,尊重usth亲自ustm亲身ustr遵循ustt亲笔usu亲usub新闻usud部机关usuj新意usvf新建usvy新娘usw凇uswc凇uswg遵命,冷板凳usws装模作样uswt新任,新作,新余usww亲人,闲人,新人,遵从uswx新华uswy亲信usxf新疆usxg装配线usxt新颖usxy新编usyn新房usyo闲谈usyt闲话usyv新郎ut产,首,道utad疾苦utag郑重其事utaq产区utbb闹乱子utbm产出utcb疾驰utck疾驶utcm道德观utd疾,痴utdg头等大事utdi疾utdk痴ute产,颜,彦utec瘢utel头重脚轻utem颜utep疼爱uter彦utey首脑utf冼utfb产地utfc半自动utfn首场utfq冼utft首都,决策者utgf疲惫不堪utgh阁下utgj道理utgo首恶uth首,瘪,痄uthf首,痄uthg馘uthp道uthx瘪utii六盘水utim产油utit新生活utj痢utjg产量,总重量utjk痢utjm首映utk阁utkd阁utkh道路utkk产品utlw首轮utmj立竿见影utmq关系网utn疙utnm首届utnt首尾,意向性utnv疙utog产业utoy产粮utpe首家utpg首富utqc颜色utqg送往迎来utqi产销utqm首钢utqn首饰utqt首犯,新生儿utrf新科技utrg产后utrw首推utrx首批utsc产权utsh首相utst首枚utsv首要utta首长uttf道德,首先uttg产生,新长征uttr产物utu疼utua疙瘩utuc疼痛utue产前utug疾病utui疼utuj新篇章utuq首次utut头版头条,问长问短utuv道歉utv痿utvd痿utvv产妇utwb首创utwe站得住脚utwf产值utwg首例utwj首倡utwn产假utww决策人,美籍华人utwy站得住utxe部长级utya首席utyc新秩序utyk新知识utyn关系户utyq道义utyt闹笑话utyw首府uu立,阅,痒uuaa辛辛苦苦uuad立项uual立功uub阙uubp疗养院uubw阙uucc普普通通uud痒,瘥uuda瘥uudc背道而驰uudk痒uudl阅历uudm装门面uufn立场,立志,前半场uugf立于uugg端端正正uugj前总理uuif立法uuih疮痍满目uuii冷冷清清uuj阐,瘴,瘅uuje阐明uujf瘅,阐uujg新问题,总产量uujk瘴uujn癔uujt阅览uuju头头是道uuk阅uukh立足uukk新产品uukq阅uulf新装置uulg立国uulw新闻界uumq闹意见uuni闪闪发光uunn判决书,痛痛快快uunw新闻发布会uupf半决赛uupv立案uuql闭关锁国uurb交头接耳uurr前前后后uus痫uusi痫uust立交桥uusy阐述uutl闭门造车uutp闭关自守uutw养尊处优uuu立uuug闭门羹uuui冷冰冰uuuj立意uuus立新uuuu立uuvc立即uuwf总产值uuws立体uuxy前总统uuyf阅读uuyn立刻uuyw立论uuyy立方uv妆,兼,瘦uvap兼营uvbk兼职uvdb兼顾uvde兼有uve痕uvei痕uvf妾uvft单刀直入uvg妆uvgp亲如一家uvh瘦uvhc瘦uvih瘦小uvnh兼收uvo兼,歉,鹣uvog鹣uvou兼uvow歉uvpw兼容uvq阋uvqv阋uvtl兼备uvtp兼管uvua兼并uvuj歉意uvux善始善终uvw瘐uvwi瘐uvwk闲杂人员uvwt兼任uvxu瘦弱uvyo痕迹uw闪,准,冷uwa阀uwad冷藏uwae阀uwai冷落uwb疮uwbj益阳uwbv疮uwcb准予uwdc益友uwdq准确uwdy半途而废uwe疹uwee疹uwef站住脚uwf瘵uwfa新领域uwfc冷却,闪动uwfi瘵uwfj前途无量uwfn冷场uwg痊,阕uwga闪开uwgd痊,阕,冷天uwge冷静uwgk总领事uwgm闪现uwhh总体上uwhk冷战uwhn新仇旧恨uwi闪uwia冷漠uwif冷汗uwig冷清uwii冷水uwio冷淡uwiq闪光,闪耀uwj疥uwje冷暖uwjf准时uwjg总储量uwjk疥uwjm冷遇uwjn闪电uwju前段时间uwkk总人口uwkt病从口入uwl益,蠲uwlf益uwli奖优罚劣uwlj蠲uwln冷轧uwmj准则uwmq冷风uwn瘊uwnd瘊uwng总公司uwoq闪烁uwov总人数uwpy新华社uwqi产供销uwqn冷饮uwrm新体制uwrn冷气uwrv冷热uwrw闪失uwrx前仆后继uwsg冷酷uwsu部颁标准uwtc新途径uwtl准备,新任务,总任务uwtt冷笑uwua冷冻uwuc疮疤,立体交叉uwug新人新事uwux半信半疑,将信将疑uwuy阀门,冷门uww痤uwwf痤,总价值uwwg痊愈uwwk准保uwwn冷僻uwwy冷食uwxk准绳uwxw总供给uwy准uwyc冷uwyg准uwyj总会计师uwyl冷库uwyp闪亮uwyt准许uwyy背信弃义ux北,弟,背uxai冀东uxaq北欧uxb邶uxbb辫子,弟子uxbc凝聚uxbe背阴uxbh邶uxcw新经验uxdm背面,北面uxdn凝成uxe背uxef背uxep慈爱uxfq新纪元uxfu递增uxgj总经理uxh弟,递,剃uxhg鹈uxhj剃uxhp递uxht弟uxij总经济师uxit北海uxjy背景uxkh冀中uxkq弟兄uxl冀uxld凝固uxlg北国uxlk总编辑uxlp北边uxlw冀uxmq北风uxn北uxnt新颖性,总结性uxpi遵纪守法uxpy慈祥,凝神,凝视uxqm背负uxqn背包uxrg背后uxrm总统制uxse北极uxt凝uxth凝uxu辫uxud背叛,慈善,递减uxug北美uxuh辫uxuk北部uxuq兹将uxux弟弟uxvi新纪录uxwf总结会uxwu差强人意uxwy凝集uxx兹,慈,孳uxxb孳uxxf北疆,北纬,凝结uxxg鹚uxxn慈uxxq北约uxxu兹uxyb背离uxyi北京uxyn凝望uxyy北方uy六,门,闹uyad辛苦uyak辛勤uyap辛劳uyay门庭若市uycn门巴uycq辩驳uydi北京大学uydm门面,单方面uydq凉爽uydy闲言碎语uyee六月uyg辛,冫,疰uygc意识到uygd疰uygg疒uygh辛,丬uygk闹事uygy六uyh门uyhn门uyi闵,凉uyif辩证法,新方法uyig辨清uyiy凉uyju北京时间uykh门路uykk门口uykl辨别uyl凛uyli凛uym闹,闶uymh闹uymm凉山uymq凉风uymt新高峰uymv闶uyn阂uynd闹剧uynn凉快uynt普遍性uynw阂uyod门类uyoy立方米uypg门诊室uypm门户之见uypv决议案,六安uypw门窗uyqd凛然uyqf总方针uyqk闹钟uyry辩护uysf门票uysg辛酸uyt辨uytu辨uyu辩uyug凛冽uyuh辩,北京站uyuk门市部,门诊部uyut门道uyuy冷言冷语uyv阆uyve阆uyw瘁,瘀,阏uywf瘁,旁敲侧击uywu瘀,阏uyww北京人uyx痃uyxi痃uyya新高度uyyg辩证uyym闹市,北京市,兰州市,郑州市uyyn门户uyyw辩论,辨认,门诊uyyy将计就计v发,好,如va毁,媒,姬vaf媒vafg毁坏vafs媒vagf毁于vago毁灭vagp如获至宝vah姬vahh姬vaiw毁誉vaj舁,嫫vajd嫫vam毁vamc毁vaq妪vaqv群芳争妍vaqy妪vass毁林vat娆vatq娆vauo建功立业vavw杂七杂八vawf群英会vawj媒介vawq如花似锦vaws媒体vaxq毁约vb好,她,媸vbbb好孩子,女孩子vbca好戏vbdc好友vbdg好感vbdh好在vbds好奇vbet好胜,好用vbfc好运vbfg好坏vbfp君子协定vbg好vbgi好不vbgk好事vbh媸vbhj媸vbhx好些vbip好学vbkt好吃vblf好转vbn她vbnn好书vbny好心vbpt好客vbqj好象vbqq好多vbqy好久vbrh好看vbrq好的vbrt好手vbs婀vbsk婀vbth好处vbuj好意vbwg好使vbwn好似vbwq好像vbwu她们vbww好人vbxt妇孺皆知vbxx好比vbyg好评vbyt好话vbyu好说vc妈,即,既vca既,暨vcag暨vcaq既vcb即,孥,妤vcbf孥vcbh即,妤vcc驽vcce既能vccf驽vcde既有vcg妈vcgs始末vcia怒江vciw即兴vcjf即时vcjg既是vcjj即日vck始vckb怒吼vckg始vcl努vclb努vclt努力vcm帑,胬vcmh帑vcmw胬vcn怒vcnt始发vcnu怒vcoo怒火vcpg既定vcqd既然vcry怒斥vcsk即可vcsv既要vctm奴役vcty既往vcuq即将vcvc妈妈vcvi奴隶vcwg即便,即使vcwu即位vcww恕难从命vcwy即令vcx弩vcxb弩vcxt始终vcy奴vcya即席vcyn即刻vcyt怒放vd姑,娠vdeg姑且vdf娠vdfa好大喜功vdfe娠vdg姑vdgp既成事实vdip九三学社vdnw如愿以偿vdny好奇心vdqt忍辱负重vdth姑息vdvy姑娘ve奶,姐,退veaq垦区veav恳切veay垦荒vebk退职vebm退出vedc女朋友vef垦,媛vefc媛,退却veff垦vefi恳求vefn退场veg姐vegg姐vegi退还vehi退步vei艮veim奶油veip退党vekh退路velk退回vemu退赔ven奶,恳venk退避venu恳veow奶粉vep退,嫒vepc嫒vepi退verg退后verh奶牛,退掉verq退换vetm退役vetu退税veve姐姐,奶奶vevf姐妹vewg退伍vewi如胶似漆vews退休veww九月份vewx退化,退货vexp退缩veyg恳请veyh退让vf寻,妹,那vfb那vfbh那vfbp建院vfc妓vfcy妓vfdg建厂vfdn建成vfdp群起而攻之vfem寻觅vff娃vffg娃vffh建起vffi寻求vffq九霄云外vfgd那天vfgf建于vfgs那末vfgw好坏不分vfh奸,建,聿vfhk聿vfhp建vfhx那些vfi妹vfip建党,寻常vfiy妹vfj媾vfjf媾,那里,那时vfjg那是vfk嬉vfkk嬉vflg建国vflp那边vfpl建军vfq妩vfqn妩vfqt那儿vfra寻找vfrm建制vfrn好运气vfs孀vfsc建树vfsf建材vfsh孀vfsi建档vfsm寻机vfst妙趣横生vfsu那样vfsv忍无可忍vft姥vfta建筑vftc那么vftf建造vftk那种vftl寻衅vftv建委vftx姥vfu寻,嫱vfuk嫱,女干部vfuq建交,那次vfuu建立vfvf妹妹,娃娃vfwh那个vfym建设vfyn建房vfyy建议,寻访vg姨,嫩,妍vga妍vgah妍vge婧,婊vgeg婧vgey婊,那还用说vggj毁于一旦vggt九死一生vgh嫣vgho嫣vghy退一步说vgk嫩vgkt嫩vgnt毁灭性vgo娅vgog娅vgpj好不容易vgrh女青年vgul婚事新办vgv婕vgvh婕vgwy忍不住vgx姨vgxw姨vh叟,肀vhc叟vhcu叟vhdn如此而已vhfi鼠目寸光vhin如虎添翼vhk肀vhtt如此等等vhvx姹紫嫣红vhyg如此说来vi录,剥,妙viai剥落viax妙药vibc录取vidf剥夺viet录用,妙用vige肃静vihc剥皮vihw妙龄vii隶viie剥削vij肃vijh剥vijk肃vint隶属,灵活性vip逮,嫦,逯viph嫦vipi逮,逯viq姚viqn姚virc肃反virg逮捕virm录制vit妙vite巡洋舰vitg好学生vith妙算vitr肃穆vitt妙vity录入viu录viuj录音viuu肃立viwq录像viyb剥离viyf妙计viyg妙语vj旭,娼,巢vjbb好日子vjd旭vjf旮,娌vjfg娌vjg妲vjgg妲vjgt好景不长vjj娼vjjg娼vjl媪vjlg媪vjpw巢穴vjs巢,剿vjsj剿vjsu巢vjvc妒贤嫉能vjwh那时候vjyu如是说vk如,恕,召vkad如期,如若vkb邵vkbh邵vkc邕vkcb邕vkce如能vkdr如愿vkdt如故vke娟vkeg娟vkf召vkg如,娱vkga召开vkgd娱vkgg如一vkgh如下vkgi恕不vkhh如上vkhx如此vkip如常vkjg如是vkjs如果vkkq召唤vkl劭vklk召回vkln劭vkm娲vkmg如同vkmq召见vkmw娲vkn恕vknu恕vkp迢vkpd迢vkpu如实vkqi娱乐vkuj如意vkws如何vkwy如今,召集vkx絮vkxi絮vkxq如约vkyg絮语vkys女中豪杰vl舅,姻,甾vld姻vldy姻vlf甾vll舅vllb舅vlq邋vlqp邋vlx嫘vlxi嫘vlxx姻缘vm妯,娉,姗vmfn女同志vmg妯vmgn娉vmm姗vmmg姗vmuq好几次vmva灵丹妙药vmwh好几个vn刀,鼠,妞vndn好收成vndw退避三舍vnf妞vnfg妞vnfx退居二线vng彐vngf隶属于vngg彐vnh媚,婿vnhe婿vnhg媚vnn妃,巛vnnn巛vnrd群情振奋vnt刀,娓vntn娓vnu鼠,鼬,鼢vnud鼷vnuk鼯vnum鼬vnun鼠vnuv鼢,鼹vnx妮vnxn妮vny姒vnyw姒vo灵voag灵巧voce灵通vodg灵感vofc灵魂voit灵活voko妒火中烧votx灵敏vou灵vova如火如荼vowg灵便vp巡,嫁,婶vpab建军节vpe嫁vpey嫁vpgw嫁祸于人vpj婶vpjh婶vplf婉转vplk巡回vplq巡逻vpm帚vpmh帚vppy巡视vpq婉vpqb婉vpr嫔vpru嫁接vprw嫔vpt姹vpta姹vpuv嫁妆vpv巡vpvg召之即来vpyw巡诊vpyy婉言vq婚,娩,妁vqa婚vqaj婚vqga好逸恶劳vqgk婚事vqk娩vqkq娩vqnt娱乐性vqo舄vqou舄vqpy婚礼vqrg婚后vqti如鱼得水vque婚前vqvl婚姻vqwi如饥似渴vqy妁,鸠vqyg鸠vqyy妁vr姝,婢vrgt九牛一毛vri姝vriy姝vrt婢vrtf婢vs杂,嫖vsaj杂草vsbn好极了vsf嫖vsfi嫖vsfn杂志vsgf灵机一动vsgk杂事vskk杂品vsrf杂质,杂技vstd杂乱vsth杂牌vstl杂务vstr杂物vsu杂vsuq杂交vsuy寻根问底vswx杂货vsxj杂费vsyy杂文vt九,君,群vtai群落vtam群英vtay群芳vtbb君子vtd妖,娇vtdc群雄vtdd九大vtdj娇vtdn九成vtdy妖vte尹vtee九月vtf妊vtfg妊vtfu杂乱无章vtfy恕我直言vtg姓vtgg姓vtgt既往不咎vth臼,媳vthg臼vthn媳vthx那么些vtjt群星vtk群,郡vtkb郡vtkd君,群vtl媲vtlx媲vtmm群山vtn九,姊vtng群情vtnt姊vtnu娇生惯养vtnx娇惯vtog建筑业vtqk姓名vtqy群岛vtr娥vtrn娇气vtrt娥vttq如释重负vttr建筑物vttu既得利益vttv好得很vtty姑息迁就vtug媲美vtuv姑息养奸vtvf姊妹vtvg娇嫩vtvl群策群力vtvn娇媚vtvt建筑群vtvv媳妇vtws群体vtww群众vtya灵敏度vtyp好自为之vtyt九州vu嫌,娴,娣vua姘vuab妇产医院vuah姘vugk录音带vuj婵,嫜vujf婵vujh嫜vum嫡vumd嫡vunv嫉恨vuq姣vuqy姣vus娴vusm录音机vusy娴vut嫉,馗vutd嫉vuth馗vutu妇产科vutx嫡系vuv嫌vuve奴颜婢膝vuvo嫌vuvy嫉妒vuwf嫡传vux娣vuxt娣,嫌疑vuyb娴熟vuyc嫌弃vv妇,女,嫂vvaa女工vvab妇女节vvbb女子vvbu妇联vvbw女队vvby女孩vvf娜vvfb娜vvfg女士vvfk娓娓动听vvg妇vvgf始建于vvh嫂vvhc嫂vvif婚姻法vvnt女性vvpy女神vvqt女儿vvrd女排vvrg女兵vvtg女生vvtj女篮vvtu妇科vvuf女装vvuj女单vvuq女将vvv女vvvn女婿vvvv女,妇女vvww女人vvxl妇幼vvyy女方vw臾,妗vwi臾vwnt群众性vwqq退休金vwsm录像机vwvg好人好事vwww召集人vwxj退休费vwy妗vwyn妗vx姆,妣vxg姆vxgi始终不渝vxgu姆vxvg始终如一vxx妣vxxn妣vy妨,忍,娘vydj妨碍vydm忍耐vyep忍受vyft建设者vyi丸,刃vyip群言堂vyl妫,嬗vylg嬗vyly妫vyn忍,妨,妒vynn建议书vynt妒,建设性vynu忍vyny忍心vyp婷vypd妨害vyps婷vyrn妖魔鬼怪vys嬷vysc嬷vytf好高务远vyuc忍痛vyuk建设部vyv娘vyve娘vyyh忍让w人,个,但wa代,借,供wabb袋子wabk供职wacx今昔对比wad偌wadc代码wadg化工厂wadk偌wadt借故waeg借助waet代用,借用waf垡,仝wafa华东地区wafb集散地wafc借支wafd供需waff垡,贷款,借款wafi供求wafu代培,侥幸wafw代替wage代表wagj代理wah伢waht伢waii供水waj借,偃waje供暖wajg借wajn供电wajt借鉴wajv偃wakg代号wakk借口wal黛walo黛walw代办,全世界wam贷,岱wamj岱wamq代购wamu贷wann借书,化工局,任其发展wany借以wapt储蓄额waq僭,儆,伛waqb停薪留职waqi代销,供销waqj僭waqt儆waqy伛war牮warh牮warn储蓄所warv供热wass伐木wat伐,侥wato停工待料watp代管watq侥wats借条watx作茧自缚waud供养wauf袋装wauk化工部wauo偷工减料wauq低工资wauu借阅waw供wawa借贷wawg借债wawq任劳任怨wawr分期分批waww代价wawx供货,公式化wawy供,代售,含苞欲放waxw供给way代,袋waye袋wayi供应waym借调wayt代谢wayw供认wayy贷方,借方wb他,创,仓wba戗wbad保险期wbat戗wbb仓wbbn作出了wbdm创面wbfj创刊wbft保卫者,追随者wbg仔,佴wbia创汇wbiw创举wbj创wbjh创wblg他国wblw创办wbn他wbnh创收wbog创业wbsa保险柜wbss停职检查wbtf创造wbtj创利wbtu保卫科wbus创新wbuu创立wbvc创始wbvf创建wbwd创优,分阶段wbwk仓促wbwt创伤,创作wbwu他们wbwy仓储wbxj保险费wbxl仔细wbyg化险为夷wbyl仓库wbym创设wc公,仅,翁wcaa公式wcaj公墓wcaw公共wcbi公函wcbk公职wcbv仅限wcd颂wcde公有,仅有wcdh仅存wcdm颂,公布wce俑wceh俑wcff公款wcfq公元wcg瓮wcga公开wcgh公正wcgk公事wcgn瓮wcgu公平wcip公演wcit公海wcjf公里wckh公路wclf公署,公园wclg公车wcn翁wcna公民wcnf翁,公愤wcng公司wcny公尺wcpd公害wcpe公家wcpg化验室wcpj公寓wcpo优柔寡断wcpy公社wcqd公然wcr侔wcrb公报wcrh侔wcrn颂扬wcrt公斤wcsk颂歌wcso俊杰wct俟wcta公升wctc公私wctd俟wcte俊秀wctf公德,公告,仅靠wctl公务wcu公wcud公差,公关wcug俊美wcuj公章wcuq公交wcut公道wcuw公益wcw俊,傩wcwc仅仅wcwg公债,从难从严wcwh公仆wcwi俊俏wcwt俊wcwv公分wcww公众wcwy傩wcxd公顷wcxj公费wcxq公约wcy仅wcyg公证,公主wcyn公房wcyt债台高筑wcyw公认wcyy公文wd估,做,段wda佐wdaa做工wdad保存期wdag佐wdai段落wdax今非昔比wddj优厚wddn做成wddw颂古非今wde侑wdeg侑wdet优胜wdf侉wdfh优越wdfn侉wdg估,仨wdga休戚与共wdgc做到wdgf优于,公布于,供大于求,含而不露wdgj优惠wdgk倚赖,做事wdgl低三下四wdgp华而不实wdgw从古到今wdhk优点wdhw假面具wdif做法wdit优劣wdj佰,俺,俳wdjd俳wdjg佰,估量wdjj伊克昭盟wdjn俺wdk佑wdkg佑wdkk传感器wdm段wdmc段wdmw八达岭wdn优wdna优异wdnn优wdnt全面性wdpg传达室wdpv伏案wdrf优抚,优质wdrm公有制wdrv优势wds倚wdsg低成本wdsk倚wdss做梦wdsu休戚相关wdt做,俦wdte优秀wdtf俦,倚靠,优待,优等,优先wdtg优生wdth估算wdty做wdu僚wdug优美wdui僚wdut估产wdvb做好wdw傣,俸wdwb人寿保险wdwd倚仗wdwh俸wdwi傣wdwn亿万人民wdwp作威作福wdww估价wdwx优化,公有化wdy伏,仗wdyc优育wdyf估计wdyg佐证,做主wdyq仗义wdyt傣族,公而忘私wdyv优良wdyy仗we仍,俘,佣wead使用期weaq俘获web俘webg俘wede仍有wedf集腋成裘wefi仍未weft优胜者wegf借助于,作用于wegi仍不weh佣weha俘虏wehh信用卡wehj仍旧weii优胜劣汰wejg仍是wejy公用电话wekk代用品wen仍wepy信用社weqd仍然wesc使用权wete伤脑筋weww八月份wexj使用费weyi仍应weym合肥市weyn促膝谈心wf会,传,值wfa偾wfab佳节wfad会期wfak值勤wfam偾wfan传艺wfbm付出wfc会,郐,刽wfcb郐wfcj刽wfcu会wfcy伎wfd儒wfdb人才辈出wfdd伟大wfdf众志成城wfdg传感wfdj儒wfdm会面wfdp传达wfds传奇wfeb舒服wfep仁爱wff侍,佳wffc传动wfff付款wffg佳wffh传真,会址wffj会刊,舒坦wffn会场wfft会考wffy侍wfg仁,仕wfga传开wfgd从无到有wfgf供过于求wfgh仁政,会下wfgo传来wfgr低声下气wfgy值班wfh什wfhg值wfhh会上wfhi人声鼎沸wfhk会战wfhq会餐wfhx值此wfi祭,畲,佘wfii人才济济wfil畲wfip会堂wfir促进派wfiu祭,佘wfiv传染wfiy俅wfjg会师,会晤wfjh舒畅wfjj值日wfk舍,舒,佶wfkb舒wfkf舍wfkg佶wfkk僖wfkm会员wfl舆wflt传略wflw舆,传输wfm璺,爨wfmg会同wfmo爨wfmq会见wfmy璺wfn伟wfna舒展wfnf传导wfnh伟wfnt优越性wfny传,会心,舒心wfog伟业wfpe儒家,体无完肤wfpj会审wfpr佳宾wfpt会客wfpy传神wfqd佳肴wfqg付印,付钱wfre传授wfrg会后wfrh传看,舍掉wfrn传扬wfrt传播wfsf传票wfsm传真机wft佬wftc什么wftd舒适wftj舍得,值得wftk全过程wftl会务wftm会徽,舍身wftn人地生疏wftx佬wfty传入wfub传闻wfud传送wfue公元前wfuh货运站wfuj传单,佳音wfuu传阅wfux传递,仁慈wfv佞wfvg佞wfwf促进会,全运会wfwg会合,伎俩wfwp货真价实wfwt佳作wfww伟人wfxc传经wfxg佳绩,伟绩wfxj会费wfxw付给wfxy传统wfy付wfyc传诵,舍弃wfyf会计,人云亦云wfyn传遍,传记wfyo会谈wfyq仁义wfyt会话,佳话,畲族wfyu传说wfyw会诊,舆论wfyy会议,付方wg全,使,命wgaa盒式wgab使节wgad逾期wgaf合著wgap合营wgaq全区wgbb例子wgbf登陆wgbi便函wgbm使出wgbw全队,八一队,代表队wgc倒,侄wgca使劲wgce全能,便能wgcf侄wgcj倒wgck倒台,登台wgd癸wgdd全套wgde全有wgdf从现在起wgdg僵硬,全厂wgdm全面wgdn合成,全盛wgdo食不厌精wgdu癸wgdw合奏wge傅,愈,逾wgec合肥wgee全貌,全月wgef傅wgeg倩,全县wgej俞wgem合股wgen愈,毹wgep逾wgeq觎wget全胜,使用wgey命脉wgf全wgfa登载wgfc命运wgff债款wgfh逾越wgfj倒塌wgfn登场,全场wgfp信不过wgfq全无wgft倒霉,全才,全都wgfu全境wgg伍wgga分不开wggd全天wggf便于,全球wggg合一wggh拿下wggj合理wggk全副,全速wggy全班wgi剑,敛,佥wgif佥,合法wgig分不清wgii从严治党wgij剑wgip全党wgit敛wgiv便当wgiy合流,创一流wgj便wgjg命题wgjj全日wgjq便wgjt登临wgjy合影,全景wgk合,拿,登wgka龠wgkb命wgkf合wgkg鸽wgkh命中,全路wgkj合唱wgkl盒wgkm凳,颌,全员,值班员wgkn翕wgkq使,使唤wgkr拿,人到中年wgku登wgkw歙wgkx龛wgl僵wglf倒置,代表团wglg僵,全国wglk愈加wglt合力,全力wglw合办wgm俩,债,俪wgmd欲速则不达wgmg合同wgmm登山wgmw俩wgmy债,俪wgn佤,兮wgna便民,全民wgnb兮wgnj傲慢wgnn佤,僵局,全局,全书,人事局wgnt代表性,全球性,依赖性wgo俨wgod俨wgog企事业wgov倒数,全数wgpe便宜,全家wgpf公开赛wgpg值班室wgpl全军wgpt全额,债额wgpv修正案wgq例,傲wgqd全然,俨然wgqh例外wgqj例wgqk命名wgqn使馆,领事馆wgqq合金wgqt傲wgqu作恶多端wgrb登报wgrf倒挂,僵持wgrh全年wgrn傲气wgrr合拍wgrt拿手wgsc全权,债权wgsd俗不可耐wgsf全村wgsq登攀wgst合格,剑桥wgsu全校wgta全长wgtd合适wgte全盘wgtf例行,全靠wgth合算,代表处,分理处,人事处wgtj便利,舍不得wgtk全程wgtl债务wgtm全身wgtq全称wgtu合乎,人事科wgty修正稿wgu侠wgua合并wgud债券wguf倒闭wguk全部,人事部wguq合资wgus全新wguw侠wguy登门wgva八一建军节wgvb全好wgve倒退wgvf合建wgvk例如wgwd倒伏,全优wgwf例会,全会,代表会wgwg使命,愈合,愈来愈wgwh全天候wgwi愈来愈少wgwo合伙wgwq愈来愈多wgws全体wgwt合作,代表作,人来人往wgww代理人,伤残人,优惠价wgwx僵化,公开化,合理化wgwy命令,全集wgxg全线wgxq合约wgxt全乡wgya合谋wgyf供不应求,合计,化整为零wgyg例证,债主wgym登高,全市wgyn登记,仁至义尽wgyt佤族wgyy全文wh个,候,悠whak修葺whdh侦破whf企whfi企求whfq悠远whgg从上到下whgh修正whgj修理whgk修整whh佧whhh众目睽睽whhw企盼whhy佧whj个,倬whjh倬whkh修路whkl个别whkr侦听whlg候车whlt企图whm侦whmy侦whn候whnd候whnt个性,修改whoa修炼whog企业whor依此类推whpu候补,修补whpw侦察whqd悠然whqn修饰whqy悠久whrn悠扬whrp侦探whsg修配whsj侦查whsm候机wht修,倏,攸whta修筑whtd倏,修辞whte修,候船whtf候选,修造whtj修复whtn悠whty攸,修旧利废whud修养whue修剪whus悠闲whvb修好whvf修建whw俱whwg俱全,会上会下whws个体whww个人whwy俱whxk侦缉whxu修缮why仆whyn企望whys修订wi偿,倘,俏wiad倘若wice化学能widi低消耗wie俏wieg俏wigd从小到大wigg人浮于事wigi偿还wigm俏丽wigu低水平,停滞不前wijd分清是非wijf八小时wild贪污罪wim倘wimk倘wimw分水岭wint传染性,合法性wip偿,傥wipc偿wipq傥wipt创汇额wiq佻wiqn佻wiqt贪污犯wird贪小失大wirm储油罐wirs偷梁换柱witg信誉第一witj含沙射影witu偷漏税wiu氽wiua保温瓶wiug传染病wiwf偿付wiwg愈演愈烈wiwp贪小便宜wiyk货源充足,人满为患wj介,伸,偶wjbm伸出wjdd似是而非wjf俚wjfg俚wjg但wjgf介于wjgg但,今明两天wjgj从早到晚wjgr今明两年wjh伸wjhh伸wjj倡,介wjjg但是,储电量wjm偶wjmy偶wjna伸展wjnf倡导wjnn供电局wjnr借题发挥wjq偈wjqd偶然wjqi偶尔wjqn偈wjrf介质,从明年起wjrm全日制wjs倮wjsv但要wjsy倮wjty介入wjuj介意wjwf何时何地wjwg偶合wjwq偶像wjxp伸缩wjxt伸张wjxv介绍wjyy倡议wk保,促,仲wkbg保卫wkbu保障wkbw保险wkcc堡垒wkdg食品厂wkdh保存wkdn促成wkfa仲裁wkfj促进wkg俣wkgd俣wkgi信口开河wkh促wkhh仲wkhy促wkij保温wkje保暖wkk侣wkkg侣wklg会员国,全中国wkpf保守wkpg保定wkpn保密wkpv保安wkq侃wkqg保鲜wkqi促销wkqn侃wkqs保镖wkqy保留wkrf保持,保质wkru瓮中捉鳖wkry保护wks保,堡,煲wksf堡wksg保本wkso煲wksy保wktg保重wktp保管wkud保养wkwf保值wkwg促使wkwh保修wkwv保健wkww保价wkwy保住wkyc保育wkyg保证wkyx命中率wl佃,偎,儇wlad俄罗斯wlbb拿架子wlct人困马乏wlfn停车场wlft侵略者wlg佃wlgc欲罢不能wlge偎,儇wlk伽wlkg伽wll儡wlll儡wln仂wlnf全力以赴wlnt全国性wlpg候车室wlpl集团军,侵略军wlpq贪图安逸wlrn代办所wlth代办处wlww创办人wlxg分界线,贫困线wlye贪图享受wlyn贫困户wlyu集思广益wm仙,催,侧wmaa合同工wmdm侧面wmeb佩服wmf倜wmfk倜wmg佩,侗,俜wmgh佩wmgj人财两旺wmgk侗wmgn俜wmgp人财两空wmh仙wmj侧wmjh侧wmlw催办wmmw伤风败俗wmn仉wmnl侧翼wmnn合同书wmpd他山之石wmrm合同制wmsi贪赃枉法wmtg侧重wmts登峰造极wmtt体贴入微wmw催wmwa人赃俱获wmwi人山人海wmwk催促wmwx催化wmwy催wmys分崩离析wmyt侗族wn亿,假,似wnad假期,假若wnaf人尽其才wnb倔wnbd追随wnbj阜阳wnbm倔wnce似能wnd倨wnde似有wndg倨wndi人民大会堂wndn亿万,似懂非懂wnep追逐wnfh追赶wnfi追求wnfn做买卖wnft倡导者,领导者wnfw舍己救人wng伺wnge僻静wngk伺,贪心不足wnh假wnhc假wniu追溯wnjh假冒wnjj假日wnk僻wnkf人情味wnkh追踪wnku僻wnlk追回,追加wnmm假山wnn亿,追,阜wnnf阜,领导层wnnh追悼wnnn追忆,人心惶惶wnnp追wnnt全局性,全民性wnpg假定wnpw追究wnqj假象wnre追授wnrg追捕wnrt人心所向wnsc公民权,领导权wnsj追查wnsm伺机wnsy追述wnt侯wntd侯wntm人民币wntu似乎wntv体改委wnty低收入,修改稿wnuk追问wnvf追寻wnvk假如wnwa假借wnwf倒买倒卖,信心倍增,追悼会wnwg假使,合情合理wnwh伺候wnwu全心全意wnww领导人wnwx假货wnx伲wnxk倔强wnxn伲wnxr追缴wny似wnyf信以为真wnym假设wnyn追记wnyt假话,全民族wnyw似,追认,舍己为公,舍己为人wo伙,偻woay含糊其词woft创业者wogi含糊不清wokq创业史wolw企业界womg伙同wope企业家wov偻wovg偻wowk从业人员wowu伙伴wowx企业化wowy伙食woy伙wp侬,伫,倌wpaq住宅区wpau倾家荡产wpds公安厅wpe侬wpeg人定胜天wpey侬wpfa公安干警wpg伫wpgg伫wpgo付之一炬wpgr从容不迫wpin人之常情wpir保守派wpn倌wpnn倌,公安局wppg传家宝wpr傧wprg侦察兵wprw傧wpuk公安部wpw倥wpwa倥wpwf全社会wpwr倚官仗势wpww全家人wpx佗wpxi全神贯注wpxj食宿费wpxn佗wq你,您,像wqa低wqai低落wqaj仰慕wqay低wqb爷,仰wqbb父子wqbh仰wqbj爷wqc爸wqcb爸wqd儋wqdj父辈wqdm仰面wqdt依然故我wqdy儋wqf釜wqfi人多地少wqft父老wqfu釜wqgf低于wqgh低下wqgk低速wqi你wqif低潮wqij低温wqin您wqip低沉wqit低劣wqiy你wqj像wqje像wqk佝wqkg佝wqkq父兄wqnt偶然性wqpy供销社wqq侈,爹wqqq爹wqqy侈wqr斧,偬wqrj斧wqrn偬wqrq你的wqrw人多势众wqsi低档wqtd低矮wqtf低等,华尔街wqth低息wqtr你我wqtt悠然自得wqu父wquk俱乐部wqus父亲wqut低产,仰首wqvb你好,您好wqvd依然如故wqwd低估wqwq爸爸,爷爷wqwu你们wqww低谷,低价wqxe低级wqxg父母wqyn仰望,代名词wqyu低廉wr伯,件,佚wraa便携式wraq保护区wrat人所共知wraw仗势欺人wrdx欲擒故纵wref做手脚wret售后服务wrft保持者wrg伯wrgm人手一册wrgp依据事实,优势互补wrh件wrhh件wri侏wrir伸手派wriy侏wrmq保护网wrmt众所周知wrnf保护层wrq傀wrqc傀wrsh从技术上wrt俾wrtf俾wrvj俯拾即是wrvx剑拔弩张wrw佚wrwj保质保量wrwl傀儡wrww人托人wrwy佚wrxe低年级wrys坐失良机ws休,何,体wsad何苦,何其,佳木斯wsbp体院wscw体验wsdh何在wsdm体面wsdy体态wsfa体裁wsff体坛wsfl体协wsfv人杰地灵wsg体wsgg体wsgi何不wsgk休整wsgm体现wsh仃wshh何止,休止wshk休战wsif公检法wsii追根溯源wsij人丁兴旺wsip何尝wsjf何时wsk何wskf体味wskg何wskk合格品wskm售票员wslt体力wsly体罚wsmh体贴wsmw体内wsnt何必wsny何以wso僳wsoy僳wspe分析家wspg候机室wspk修桥补路wspw体察wspy追根究底wsq鸺wsqg鸺wsqh体外wsrf体质wsrk体操wsrm体制wsrr体魄wsrt借机报复wss傈wssc分配权wssh休想wsst体格wssu体校wssw体检wssy傈wstd休憩wstf何等wstg体重wsth何处,休息,售票处wstk何种,体积wstv体委wstx体系wsud休养wsuk何况wsus休闲wswf体会wswg体例wswn休假wsww债权人wsxy体统wsy休wsyc体育wsyg合格证wsyn合格证书wsyx合格率wsyy体谅wt作,余,八wta伥wtad任期wtaq保税区wtay伥wtbk任职wtbm作祟,作出wtbu侨联wtc叙,仫wtcm人生观wtcy叙,仫wtd侨wtda人生在世wtdf侮辱,任重而道远wtdg伤感wtdj侨,八百wtdn八成,八万wtee八月wteq侨胞wtet任用,作用wtf任,凭,赁wtfb余地wtfc全自动wtfd贪得无厌wtff余款,耸入云霄wtfg任,八十wtfh仟,仵wtfm凭,赁wtfn恁wtfp信得过wtft任教,作者,创造者wtfy人生地不熟wtgc作到wtgf侧重于,偏重于,倾向于wtgg八一wtgk傻事wtgq伤残wtgr依我来看,值得一提wtgu修复一新wtgx余毒wth亻wthf作wthj叙旧wthk作战,侧重点wtia侨汇wtif优选法,作法wtit舒筋活血,偷税漏税wtj俐wtjd今冬明春wtjg储备量,信息量wtjh俐wtjn余暇wtjv凭照wtkh途中wtkk伤口,作品wtkm伤员,保管员,公务员wtl伤,傻wtlg债务国wtln伤wtlp侨务办公室wtlt傻,创造力wtlw侨办wtmq作风wtn仡wtna侨民wtnc作怪wtnd侨居wtng贪生怕死wtnn仡,任务书wtnq分秒必争wtnt任性,余悸,创造性,倾向性wtny伤心,全身心wtog作业wtoy储备粮wtp途wtpd伤害wtpe作家wtpi途wtpr众矢之的wtpt余额,作客wtpv作案wtpw凭空wtqk任免wtqq公积金wtr俄wtrc傻瓜wtrh余年wtrm余缺wtrn凭据wtrt俄wtrv伤势,余热wtsc优先权wtsu什么样wtsy叙述wttc途径wtte作秀wtth作息wttl任务wttr作物wttu创利税wtu余,斜,佟wtuc伤疤,伤痛wtud侨眷wtuf斜,任重道远wtug伤病wtuj任意wtum作弊wtun修身养性wtuq优秀奖wtut促生产wtuv伤痕wtuy佟,倒行逆施wtv倭wtvg倭wtwa凭借wtwf从我做起,仡佬wtwg任命wtws任何wtwt任凭wtww作价,候选人wtwy优生优育wtx侮wtxc途经wtxt侨乡wtxu侮wty八wtyg凭证,作证,舍生忘死,作主wtyl作为wtyn伤亡,作废,健身房wtyo叙谈wtyu叙说wtyx低利率wtyy从长计议wu们,位,倍wuaa含辛茹苦wubd伴随wuck倦怠,领奖台wud倦,佯wudb倦wudg倍感wudh佯wuep倍受wuf伴wufa华北地区wufh伴wufu倍增wug位wugf位于,仅次于wugn从头到尾,从头至尾wugp坐立不安wugy低头不语wuh伞wuhj伞wuj僮wujf僮wujq傍晚wuk倍wukg倍wukk化妆品wukm伤病员wuko分门别类wul僧wulf位置wulj僧wulk倍加wull低产田,伤痕累累wun们wund位居wuop焦头烂额wuov倍数wup傍wupy傍wuq佼wuqy佼wurn休养所wurq分道扬镳wusw坐冷板凳wuts集装箱wutu人头税wuuf佯装wuuj倦意wuul贫病交加wuuq位次wuuw低效益wuwh从总体上wuwk伴侣wuxi余音绕梁wuxu欲盖弥彰wuyl依次为wuyx低效率,分辨率wv分,盆,贫wvaa分工wvad分期,贫苦wvae分散wvaq分区,分获wvb分wvbb岔子wvbf倾巢出动wvbg分隔wvbp分院wvbw分队wvd颁wvdg分厂wvdh健在wvdm颁,颁布,分布wvdn分成wvdw伊春wvdx侵袭wvf健,坌wvfb盆地wvff坌wvfg分寸wvfh分赴wvfn分场wvfp健wvga分开wvgd侵吞wvgf八九不离十wvgk做好事wvgq分裂,分列wvhf分歧wvhi健步wvhk侵占wvia分洪wvig分清wvin分泌wviy分流wvja分晓wvje分明wvjf从那时起wvjg分量wvkh岔路wvkl分别wvl盆wvlf盆wvls贫困wvlt侵略wvlw分界wvm贫,岔wvmj岔wvmm分册wvmu贫wvmy分赃wvn仇,忿wvna贫民wvnd分居,分忧wvnn分局wvnt颁发,分属wvnu忿wvnv仇恨wvny分心wvov分数wvp侵wvpc侵wvpd分割,侵害wvpe贫农wvpf贫寒wvpg贫富wvpw贫穷wvpy仇视wvq倪wvqe分解wvqh分外wvqk分钟wvqn倪,侵蚀wvqs仇杀wvqt健儿,侵犯wvrc分摊wvrd侵扰wvrj分担wvrt分手wvrx分批wvsc侵权wvsg分配wvsr分析wvt伊wvtf分行wvtl贫血wvtm健身wvtp分管,贫乏wvtt伊wvty侵入wvud分送,分头wvuf健壮wvug健美wvui贫瘠wvuk分部wvuq颁奖,健将wvuy分辨,分辩wvvc伊始wvwd分段wvwf分会wvwg健全wvww仇人,创始人wvxa分红wvxe分级,分组wvy仞wvyb分离,分享wvyh分店wvyl分为wvyo健谈wvyv健康wvyy仞ww从,份,坐wwaa人工wwad保修期wwai坐落wwan人世wwb耸,伧wwbf耸,人际wwbn伧wwby人防wwcd人参wwce怂恿wwcf仅供参考wwcm价值观wwct人仰马翻wwdd人大,俗套wwdf催人奋进wwdg人人有责wwdm从而wwdx偷袭wwdy侃侃而谈wwe佾,俎wwee人月,舒舒服服wweg佾,俎wwey人脑wwf坐,侩,傺wwfb谷地wwfc侩,偷运wwff坐,价款wwfg人士wwfh偷越wwfi傺,从未,八仙过海wwfq人均wwft人才wwg丛,偷,俭wwgf丛,从今天起wwgh从政,坐下wwgi俭,从不wwgj偷,伦理wwgk从事,从速,人事wwgn欲与wwgo从来,从严wwgq分化瓦解wwgr食欲不振wwgt低人一等,人人平等wwgw依依不舍wwgy念念不忘wwhx从此wwih从小wwin偷漏wwit俭省,人海,假公济私wwiy人流wwj价wwjg从师,份量wwjh价wwjy人影wwk谷,欲,鹆wwkf谷wwkg鹆wwkj任人唯贤wwkk人口,人品wwkm人员,售货员wwku任人唯亲,耸人听闻wwkw欲wwlf价值连城wwlt人力wwn怂wwna人民wwng人情,分公司wwnn丛书wwnt从属,人性wwnu怂wwny人心wwod人类,全人类wwol人烟wwoo含含糊糊wwpa从宽wwpe人家,贪便宜wwpw从容,偷窃wwpy合作社wwqg价钱wwqk人名wwqn使领馆wwqq众多wwrf人质,从今年起wwrh人年wwrm合作制wwrr偷偷摸摸wwrt人手wwsc人权wwsf坐标,人材wwsh俭朴wwsm人机wwss丛林wwst价格,人格wwtf人选,人造,坐等,你追我赶wwtg人生wwtk人和wwtm人身wwtq人称,俗称wwtr谷物,人物,化合物wwtt分分秒秒wwtu从简,偷税wwud从头,人头wwue从前wwuj人间,人意wwuq人次,偷盗wwus从新wwut人道wwuu耸立wwv份wwvn份wwvt人群www众,俗wwwf价值,人代会wwwg人命wwwk俗wwws人体wwwt伶俐wwwu众,人们wwww人,众人wwwy从今wwx伦wwxn伦wwxt人人皆知wwxx人缘,仔仔细细wwy从,伶,僬wwyc伶wwyg人证,俗语wwyj催化剂wwyl人为wwyn欲望,众望,个体户wwyo僬wwyt俗话,化公为私wwyy人文wx化,华,货wxaa化工wxai华东wxb仑wxcw化验wxd倾wxdg化石wxdh华夏wxdm倾wxdn化成wxdp人皆有之wxec化肥wxf华wxfc货运wxff货款wxfj华wxfm华南wxfn货场wxft佛教wxge华表wxgk佛事wxgm华丽wxgu修缮一新wxid货源wxif佛法wxip佛学,化学,倾泻wxiy倾注wxj佛wxjh佛wxkf倾吐wxkh华贵,华中wxkk货品wxkr倾听wxlg货车wxlk货架wxlw货轮wxm货wxmg偕同wxmm佛山,华山wxmu货wxn化wxny倾心wxos华灯wxpy佛祖wxqc货色wxqi倾销wxqu体弱多病wxrc货摊wxsf货票wxsg货栈wxsm货机wxte货船wxtm货币,倾向wxtr货物wxuf化装wxuj货单wxup传经送宝wxus父母亲wxuv化妆wxvi创纪录wxwf分组会wxwg倾倒wxwq佛像wxwt华侨,倾斜wxww华人wxwy介绍信wxx仳,偕wxxa集约经营wxxc佛经wxxn仳wxxr偕wxxt化纤wxye华裔wxyg货主wxyl化为wxyr倾诉wxyv货郎wy信,今,含wyaa停工,仪式wyad储藏wyae集散wyai付诸东流wyaj今昔wyay储蓄,含蓄wyb禽wybc禽,集聚,领取wybj信阳wybm售出wybp住院,保育院wybw领队,依附,集训队wyc令,邻,领wycb邻wycm领wycn翎,瓴wycu令wycw住房难wydd偏大wyde含有wydg仿古wydh储存,今夏wydn集成wydt邻邦wydw信奉wydy仪态wye依,隽wyeb隽,信服wyeg邻县wyep偏爱wyet食用,信用,停用wyey依wyf储,隼wyfa领域wyfb领地,住地wyff领土wyfh仿真,住址,今起wyfj隼,储wyfn体育场wyfq偏远wyfr八方支援wyft领教wyg住,信,隹wygb停顿,分文不取wygd今天wyge仪表,登记表wygg住wygk领事,信赖,依赖wygw公诸于众wyha焦虑wyhh停止wyhj依旧wyhk焦点,停战wyhn俯瞰wyhx依此wyi僦wyia信汇wyif贪污,依法wyig停滞wyih偏小wyij含混wyim食油wyin僦wyip食堂wyir偏激,停泊wyit领海,伪劣wyiv停当wyiw信誉wyj侪wyjd今晨wyjf邻里,从这时起wyjg储量,含量,供应量,会计师wyjh侪wyjj今日wyjq今晚,停歇wyjv仿照,依照wyk售wykf售wykg信号wykh焦躁,集中,领路wykk食品,仪器wykm保育员,会计员wyl伪wylf集团wylg邻国,停车wylt领略,贪图wylw停办,体育界,舆论界wyly伪wym伉wymb集邮wymd焦炭wymf贪财wymm登记册wymn伉wymq偏见wymy贪赃wyn仿,贪,念wyna偏wynb今wynd邻居,化为己有wyne衾wynf领导wyng领悟wynk含wynm贪,颔wynn念,念书,保证书,倡议书,公证书wynt停发wyny贪心,信心wyo焦,鹪,劁wyoa焦煤wyod含糊wyog鹪,停业wyoj劁wyoo停火wyoq焦灼wyou焦wyoy食糖wyp停wypf信守wypg会议室,人迹罕至wyps停wypt住宅wypu领袖,偏袒wypw领空,食宿,仪容,住宿wypy俯视,付诸实施wyq仪wyqd依然,化为乌有wyqe俯角wyqf集镇wyqn体育馆wyqq贪多,保证金wyqr集锦wyqv焦急wyqy仪,停留wyra釜底抽薪wyrg今后wyrh今年wyrj众望所归wyrm仿制wyrn依据wyrp分庭抗礼wyrt信托,依托wyry仗义执言wys集wysf邻村wysg合订本,修订本wyss贪婪wysu集wytf仿造,领先,伪造,信徒,依靠,偃旗息鼓wytg偏重wyth停息,信息,住处,公证处wytl储备wytm偏向wyto今秋wytr食物wyts信条,信箱wytt含笑wytu价廉物美,今冬wyty修订稿wyud含羞,念头,偏差,伪善wyuf伪装wyuh供应站wyuj含意,做文章wyuq仿效,集资,领奖wyut俯首,停产wyuy传为美谈wyv食wyve食wyvf停建wyw俯wywa信贷wywd依仗wywf俯,集会,领会,停付wywg集合wywn偏僻wywq信仰,偏低wywr信件wyws集体wywt信任wywu全方位wyww令人,售价,依从,代言人wywx仿佛,售货wywy偏偏,信念wyxf集结wyxx众说纷纭wyy雠wyyb偏离wyyg领主,伪证wyyk集训wyym集市,偏高wyyn储户,住房wyyo贪恋wyyq含义,信义wyyt停放wyyu俗话说wyyy雠,食言,信访x经,给,比xa红,练,绕xaal练功xad绒xadt绒xaf绀,缂xafg绀xafh缂xaft经营者xag红xaiq红光xajt红星xan练,绁xann绁xanu练习xanw练xaoo红火xaos红灯xapu经营之道xaqc红色xarg练兵xarr张牙舞爪xasc经营权xat绕xath红牌xatq绕xaut绕道xaxa毕恭毕敬xayt红旗xb弛,弭,绌xbft继承者xbg弭xbif继承法xbm绌xbmh绌xbn弛xbsc继承权xbww继承人xc经,弘,缀xca经,弪xcag弪,经xcap经营xcb纾xcbh纾xcc缀xccc缀xccw经验xcdl经历xcep经受xcf绎xcfh绎xcfp经过xcgj经理xcip经常xciy经济xck绐xckg绐xcma经典xcmh经由xcpy经验之谈xcqi经销xcqy经贸xcrn弘扬xcrt经手xctv经委xcum经商xcwx绝对化xcxj经费xcxn经纪xcxt经络xcy弘xd顷,毋,绑xdc绂xdcf皆大欢喜xdcy绂xde毋xded毋须xdf绔,缛xdff缛xdfn绔xdg缄xdgn引而不发xdgt缄xdir强硬派xdj弼,绯xdjd绯xdjg绝非易事xdjx弼xdlk绑架xdm顷,缅xdmd缅xdmy顷xdng缅怀xdqo绝大多数xdqw绝大多数人xds绮xdsk绮xdt绑xdtb绑xdu缭xdui缭xduw绝大部分xdxa缭绕xdyn顷刻xe级,组,缓xead缓期xedg绊脚石xedn组成xee绷xeeg绷xef缓xefc缓xeg组xegg组xehi缓步xej蠡xejj蠡xekl级别xekm组员xelf组团xelw缓办xenj缓慢xep绶xepc绶xeqe缓解xeqv缓急xeta组长xetk缓和xeu彖xeud级差xeuf组装xeuk缓冲xeut组阁xev绥xevf缓建,组建xevg绥xewg组合xexk组织xey级xeyy级xf结,续,纬xfc纭xfce贯通xfcy纭xfdh结存xfdn结成xffa疆域xfff疆土xfg疆xfgg疆xfgk结束xfh缜xfhw缜xfiy贯注xfje结盟xfjj结晶xfjs结果xfk结,缬xfkg结xfkm缬xflw疆界xfm贯xfmh结帐xfmu贯xfn续xfnd续xfnh纬xfnn结局xfnt结尾xfnx乡规民约xfog结业xfpu结实xfpv结案xfpw贯穿,红十字会xfpy结社xfq鸨xfqg鸨xfrn结扎xfrp编者按xfsq结构xft绪xfta贯彻xfth结算xftj绪xftw续签xfui结冰xfuk乡干部xfuq结交xfvf续建xfvq结婚xfw绫xfwd绝无仅有xfwg结合xfwt绫xfwu结伴xfwy续集xfxq绘声绘色xfxy续编xfy纣xfya纬度xfyk结识xfyl结为xfyw结论,绪论xfyy绪言xg线,纯,母xgb纯xgbb母子xgbn纯xgdd纯碱xgdw比下有余xge缚xgef缚xgep母爱xgf纡xgfc缙云xgfh纡,纯真,经不起xgfp线索xggh纯正xgif纯洁xgig纷至沓来xgj绠xgjq绠xgkh线路xgl缰xglg缰xglt约束力xgm绩xgmy绩xgnt纯属,线性xgo彝,缙xgoa彝xgoj缙xgoy纯粹xgqi维吾尔xgqq纯金xgsh纯朴xgsu母校xgt线xgtj纯利xgts线条xgu母xgui母xguq纯净xgus母亲xgvv母女xgwf经互会xgws母体xgx彘xgxx彘xgyg母语,结束语xgyt彝族xgyw乡政府xh引,缈,绰xhbm引出xhet引用xhfh引起xhfj引进xhgk比上不足xhh引xhi缈xhit缈xhj绰xhjh绰xhkh引路xhnf引导xhnt引发xhoj引爆xhrs综上所述xhtj引得xhtk引种xhtm引向xhty引入xhug红眼病xhuk统战部xhyr纸上谈兵xhyt引诱xi纱,绡,颍xiaq经济区xiat结党营私xiaw经济共同体xid颍xidm颍xidu约法三章xie绡xieg绡xigw经济一体化xihm引水上山xiim绿油油xiip经济学,经济学家xilw经济界xim绱ximk绱xint经常性xiss经济林xit纱xiti细水长流xitt纱xiu糸xiwx经常化xj旨,费,弗xjaa费工xjca费劲xjdh旨在xjet费用xjf旨xjg缇xjgh缇xjgk费事xjh绅xjhh绅xjjf费时xjk弗xjl缦xjlc缦xjlt费力xjm费xjmu费xjny费心xjpy费神xjq艴xjqc艴xjqe费解xjt缆xjtq缆xjuj旨意xjx绲xjxx绲xk强,绳,织xkad强项xkaq缉获xkat强攻xkb缉xkbg缉xkca强劲xkdd强大xkdf强压xkdg强硬xkdn强盛xke绢xkeg绢xkfi强求xkft强者xkgq强烈xkgx缉毒xkh缋,缱xkhk强占xkhm缋xkhp缱xkj强,犟xkja强暴xkjh犟xkjn绳xkjy强xkk缲xkks缲xklg强国xklt强力xknj强悍xknk细嚼慢咽xkrm强制xkrp强迫xkrt强手xksc强权xktc缉私xktf强行xkuf强壮xkuy强辩xkvf强奸xkw织xkwg缉拿xkwt强作xkwv强健xkww强人xkwx强化xkwy织xkxt张口结舌xkxu强弱xkya强度xkym强调xl细,幼,辔xlab细节xlal细菌,幼苗xlbb绕圈子xlbt编辑出版xldy细碎,比较而言xlea细腻xleq细胞xlfg细雨xlg细,缳xlgc细致xlge缳xlgf强加于xlgw强加于人xlhh细目xlih细小,幼小xljh幼虫xlmj细则xln幼,缌xlny缌,细心xlpk强国之路xlqt幼儿xlrh幼年xlss幼林xlta细长xltm细微xltw幼稚xluk编辑部xlww经办人xlwx细化xlx辔,缧xlxi缧xlxk辔xm纲,纳,绸xmf绸xmfk绸xmhh纲目xmm缨xmmv缨xmmy红彤彤xmq纲xmqy纲xmsv纲要xmtu纳税xmty纳入xmun纳闷xmw纳xmwy纳,纲领xn纪,弓,幻xna缗xnaj缗,纠葛xnei绞尽脑汁xnf纽xnfg纽xng弓xngh纠正xngk纪事,纽带xngn弓xnh纠xnhh纠xnjy幻影xnn幻,纪,幺xnng纟xnns费尽心机xnnt费尽心血xnny幺xnos幻灯xnpu纪实xnsh幻想xnsv纪要xnsw纪检xntv纪律,纪委xnty纯收入xnvi纪录xnw缪xnwe缪xnwy纪念,纠集,纠偏xnxw纠纷xnxy纠缠xnya引以为戒,引以为荣xnyb引以为耻xnyj强心剂xnyn引以为憾xo继,缕,粥xobd继承xodm继而xogy毕业班xon继xonn继xoot引火烧身xotg毕业生xov缕xovg缕xox粥,鬻xoxe张灯结彩xoxf继续xoxh鬻xoxn粥xp综,缩,缤xpcm综观xpf综xpfi综xpg绽xpga绽开xpgh绽xpih缩小xpjy缩影xpkk张家口xpn绾xpni绳之以法xpnn绾xppg缩写xpr缤xprw缤xpsf张冠李戴xpsy综述xptd缩短xpud缩减xpw缩xpwg综合xpwj缩xpwr绝密件xpxr疑神疑鬼xpxw缤纷xpxy缩编xpyt缩放xq约,纸,绝xqa纸xqan纸xqc绝xqcf绝对xqcn绝xqde经久耐用,约有xqdj绝非xqfu绝境xqgi绝不xqgk约束xqgm绚丽xqgt经久不息xqhk约占xqi弥xqij弥漫xqit绝活xqiy弥xqj绚xqjg绚xqkh绝路xqlf幼儿园xqmq约见xqou绚烂xqpg约定xqpn绝密xqpu弥补xqrf绝技xqrv绝招xqsd绝顶xqtk绝种xqug绝症xquk经贸部,经销部xqum经销商xquq绝交xqv绉xqvb约好xqvg绉xqvi绝妙xqwf约会xqwg弥合xqxg红外线xqxx绝缘xqy约xqyc绝育xqyg约请xqyn绝望xqyo绝迹xqyy约xr绵,弧,缴xraq缴获xrc弧xrcy弧xrm绵xrmh绵xrnt强制性xrpy缓兵之计xrth绵延xrud绵羊xrvs强手如林xrxe缩手缩脚xrxm缴纳xry缴xryt缴xs缥,缃xsf缥xsfi缥xsfq缘木求鱼xsgj红极一时xsh缃xshg缃xsnt结构性xsxh缥缈xt张,疑,终xta张,绛xtah绛xtak疑惑xtay张xtbi缝隙xtbn终了xtcw疑难xtd颖,肄,缝xtdh疑,肄xtdm颖xtdp缝xte乡,绣xten绣xtf纤,绗,缵xtff乡土xtfh绗,纤xtfm缵xtfn终场xtg缍xtga张开xtgf缍,终于xtgg继往开来xtgh乡下xtgx维生素xth绺xtha疑虑xthh终止,比得上xthk绺,疑点,终点xtiu纯利润xtjf乡里xtjj终日xtjv终归xtk络xtkg络xtlf疑团xtlq张罗xtlw乡办xtmh张贴xtn匕,纥xtnh疑惧,红得发紫xtnn纥,终局xtnt纪律性xtny疑心xtpj终审xtpw终究xtqf乡镇xtrh终年xtrn张扬xts绦xtsf乡村xtsy绦xtta乡长xttg终生xttm终身xttt绝处逢生xtu终xtud统筹兼顾xtuj乡间xtuk疑问xtum终端xtuq终将xtus乡亲xtut匕首xtuy终xtw飨xtwe飨xtwf编委会,组委会xtxf终结xtxu纤弱xtxw纤维xtyn张望xtyq疑义xu弱,弹,绞xuad弱项xuax弹药xud缮,绻xudb绻xudk缮xudt绕道而行xuf绊xufh绊xuft弱者xuhk弱点xuih弱小xuj弹xujf弹xul缯xulj缯xunt弹性xunx弹道导弹xup缔xuph缔xuq绞xuqy绞xutf缔造xuud弹头xuv缣xuvo缣xuw缢xuwl缢xuwu乡亲们xuwx弱化xux弱,绨xuxf缔结xuxq缔约xuxt绨xuxu弱xv绿,绍,缁xvab绿荫xval绿茵xvec绿肥xvfb绿地xvi绿xviw绍兴xviy绿,绿洲xvj缫xvjs缫xvk绍xvkf绿叶xvkg绍xvl缁xvlg缁xvos绿灯xvqc绿色xvsc绿树xvth纪录片xvwx绿化xvy纫,纨xvyu比如说xvyy纫,纨xw给,维,纵xwbm给出xwbw纵队xwcb给予xwcm纵观xwd缎xwdc缎xwdr纪念碑xwf绘xwfc绘xwg给,缏xwgk给xwgl绘画xwgq缏xwhh引人瞩目xwih引人注目xwip纵深,纪念堂xwjt纵览xwkg纷呈xwkk纪念品xwlt绘图xwmh红领巾xwn缑,缒xwnd缑xwng纵情xwnp缒xwnt综合性xwny给以xwpg给定xwpw纵容xwqd纵然xwqn纪念馆xwqv纷争xwrc强人所难xwrf维持xwrm绘制xwry维护xwsa纵横xwtd纷乱xwte引人入胜xwtm纵向xwtx纷繁,维系xwud给养xwug综合症xwuk维修部xwus维新xwv纷xwvn纷xww纵xwwf纪念会xwwg纵使xwwh维修xwws综合体xwwu维修保养xwwx经人介绍xwwy纵xwx纶xwxf纷纭,纵贯xwxn纶xwxw纷纷,统分结合xwy维xwyg维xwyo纵谈xwyt维族xwyw纵论xx比,丝,缘xxa畿xxab毕节xxah幽雅xxaj比划xxal畿xxbu纨绔子弟xxde皆有xxdg纺织厂xxdt缘故xxdw绰绰有余xxe缘xxey缘xxf毕xxfj毕xxft组织者xxg丝,毙,鸶xxga比武xxge幽静xxgf丝,纹丝不动xxgg鸶xxgx毙,络绎不绝xxhh组织上xxj绋xxjh绋xxju幽暗xxjv比照xxkw比喻xxlf幽默xxlu比较xxm幽xxmh缘由xxmk幽xxn比,毖xxnt毖,组织性xxog毕业,纺织业xxpf比赛xxpk丝绸之路xxpp缝缝补补xxr皆xxrf皆xxrm引经据典xxrn比拟xxrr纷纷扬扬xxsk皆可xxsm缝纫机xxso绝缘材料xxtg毕生,比重xxud比着xxuj毕竟xxuk纺织部,组织部xxvk比如xxvo幽灵xxwg比例xxwv比分,缘分xxww比价,经纪人xxx纟,纰xxxj比比皆是xxxm丝绸xxxn纰xxxx纟xxya比试xxyf比诸xxyp丝毫xxyx比率xxyy比方xy纺,统,编xyaf编著xyaw统共xyb缡xybc缡xybw编队xyc统xycq统xydc编码xydg强词夺理xydn编成xyft编者,统考xyge统计表xygg统一xyhk统战xyic统治xyj缠xyjf缠xyjm统帅xykg编号xylk编辑xylp统辖xym缟xymk缟xymq统购xyn纺xyna编xynf编导xynn统计局xypg编写xypu顷刻之间xyqg编印xyqh编外xyqi统销xyrd编排xyrm编制xyrn编撰xyrt红旗手xysg统配xyt纩xytd统筹xytf编造xyth编篡xytp统管xytq统称xyty编入xywt编余xyx弦xyxa缠绕xyxe编组xyxi纺纱xyxk编织,纺织xyxy弦xyy纹xyyc编译xyyf统计xyyx统率y主,就,该ya度,试,谋yaa试,诫yaag试yaah诫yaaj谋划yaal诬蔑yaau遮蔽yabc谋取yabq诬陷yabw施工队yaby谨防yac度yaci度yacw试验yad诺,谌yadk诺yadn谌yaet试用yaf谋yafi谋求yafp度过yafs谋yag讧,诓yagf为期不远yagg诓yagk诬赖yah讶yahk试点yaht讶yait广东省yaj谟yajd谟yajg度量,试题,充其量yajj度日yak谨,廑yakg谨,廑yalf文工团yalg试车yalt试图,诱惑力yalw试办,文艺界yam席yamh席yamw计划内yan谍,讵,庹yanf谨慎yang讵yans谍yant计划性yanu试飞yany庹yao庶,遮,鹧yaog鹧yaoi庶yaop遮yapd谋害yaq讴,谮yaqh计划外yaqi试销yaqj谮yaqs谋杀yaqy讴yarb谎报yard遮掩yari遮挡yarm试制yarp试探yash试想yask讴歌yatc谋私yate试航yatf诬告yatg谋生yati论功行赏yatj谋利yatk试种yatp试管yatu调节税yaud席卷yaug遮盖yauj席间yauk试问yaut试产yaw诬yawf庆功会yawi文艺会演yawn度假yawu席位yaww诬yay谎yayj试剂yayp诸葛亮yayq谎yayt谎话yayy谎言,诺言yb离,孰,熟ybae离散ybai底子薄ybb郭ybbb离子ybbh郭ybbk离职ybc诹ybcy诹ybdd望子成龙ybde享有ybds离奇ybep享受ybet享用ybf享ybfu离境ybga离开ybgu充耳不闻ybh邝,邡ybht熟睡ybj亨ybkl离别ybm离,诎ybmc离ybmd离岸ybmh诎ybna离异ybny离心ybo烹ybor敦煌ybou烹ybpe离家ybpy享福ybq鹑ybqg鹑ybqi享乐ybqn烹饪ybrh享年ybt敦,憝ybtg讲卫生ybtn憝ybto熟悉ybty敦ybuj离间ybv熟,塾ybvf塾ybvo熟ybvq离婚ybvy孰ybwk敦促ybws离休ybww熟人ybxa熟练ybxy离弦ybyf熟读ybyi离京ybyk熟识ybym烹调yc充,弃,序yca弃ycaf译著ycaj弃,序幕ycal育苗ycaq试验区ycb序,袤,谲ycbe袤ycbk序,谲ycdn译成yce育,诵ycec育肥ycef育yceh诵ycf译ycff充填ycfh译ycft译者,育才ycgq序列ychw育龄ycia充满ycig充沛ycip弃学yciv充当ycjn充电yck诒yckg诒,序号yckh充足yclf弃置ycll试验田ycma序曲ycov充数ycpu充实,充裕ycq充ycqb充ycqk译名ycqt诈骗犯ycrm译制ycrn充气ycry充斥ycsc弃权ycsg译本ycss育林yct诶ycta熟能生巧yctd诶yctk育种yctm育秧ycuj译音ycwc充公ycwt充任ycwv充分ycya高难度ycyy序言,译文yd庆,诚,斋yddd庞大yddw言而有信ydfh望而却步ydfu庆幸ydfw言而无信ydg诂ydgf就在于ydgu议而不决ydi庆,诔ydiy诔ydj诽,齑,庵ydjd诽ydjg库存量ydjj齑ydjn庵,高压电ydkk变压器ydlk庆贺ydm斋ydma庆典ydmj斋ydn诚ydnd应有尽有ydnt诚ydny诚心ydo诙ydoy诙ydpu诚实ydpy庆祝ydqd诚然ydqq座右铭ydrv诚挚ydtl望而生畏yduj诚意,良辰美景ydve诚恳ydwg为非作歹ydws识大体ydx庞ydxv庞ydyt说大话ydyu诽谤ydyx诙谐ye衣,哀,谣yead试用期yeeb衣服yef谖yefc谖yefi哀求yefy说服教育yeg诅yegf应用于yegg诅yekk诅咒yeln哀思yelt说服力yem裔yemk裔yenh哀悼yeqs衣钵yer谣yerm谣yetr衣物yeu哀,衣yewf谣传yewt哀伤yey诼yeyy诼,谣言yf计,讲,读yfaj计划yfap言过其实yfbs就地取材yfc庋yfci庋yfck讲台yfd庄yfdd讨厌yfdt应运而生yfdw席地而坐yff诗,诖yfff讲坛yffg诖yffi讲求yffl言者无罪yfft读者yffy诗yfgi讨还,就地正法yfgj讲理yfgo庄严yfgy永志不忘yfh计,讦yfhy座无虚席yfig讲清yfip讲演yfj讲yfje讲明yfjf计时yfjg讲师,计量yfjh讲yfk诘yfkg诘yflu计较yfm谳yfmd谳yfn读,讳yfnd读yfng讲情yfnh讳yfnn读书,文教局yfnt主动性yfnu讲习yfpg读写yfpw讲究yfpy说老实话yfq庑yfqd文过饰非yfqe讲解yfqq诸多yfqv庑yfrb读报yfrd义无反顾yfre讲授yfrq说真的yfsc主动权yfsi旗鼓相当yfsk诗歌yfsr毫无根据yfsu市直机关yfsy讲述yft诸yftf试运行yftg计策,庄重yfth计算yftj诸yftp庄稼yftr读物yftv计委yfty讲稿,诗篇yfuj诗意yfuk市场部yfut房地产,毫无关系yfuy毫无意义yfvb讨好yfvk诸如yfwg讨债yfwh永无休止yfwu诸位,语无伦次yfwv计分yfww诗人,讨价yfwx市场化yfxa主教练yfxu毫无疑问yfxy毫无疑义yfy讨yfyg讲评yfyj讲课yfyn诗词yfyt讲话,说真话yfyw讲座,讨论yfyy讳言yg主,请,证yga斌ygah斌ygal请功ygat主攻ygbm评聘,评出ygbn忘不了ygcj文不对题ygcm主观ygcw文武双全ygd主yge请ygeg请ygfc主动ygff说不过去ygfi请求,请示ygfr毫不动摇ygft肇事者ygga离不开yggf请于,说一不二yggh这一下yggl请柬ygh证yghg证yghh说不上,谈不上yghk请战,这一点ygic主治ygig说不清ygim评测ygip主演ygiy主流,为政清廉ygje证明ygjg主题ygjm主帅ygk语ygkg语ygl谏yglf请转ygli谏yglt主力yglw主办ygmh请帖ygmq主见ygmy言不由衷ygnf主导ygnn证书ygnx毫不迟疑ygny诉不尽ygpg评定ygpj评审ygpt请客,义不容辞ygpu证实,主宰,言下之意ygpx刻不容缓ygq廒ygqc毫不犹豫ygqe主角ygqn毫不留情ygqr请勿ygqt廒,主犯ygrf主持ygrn证据ygsc主权ygsf毫不相干ygss高不可攀ygsv主要ygsy评述ygte旗开得胜ygtf评选ygtp主管ygtv评委ygu评ygud证券,主送yguh评yguj语音,证章,主意yguk请问,广开门路yguq评奖,主次,主将yguw说不准ygvi语录ygwd评估,评优ygwg说到做到ygwj评介ygwn请假ygwq亦不例外ygwr证件ygws主体ygwt主任ygwv评分ygww评价,证人,主从,主人,肇事人ygxe评级ygxt主张ygxx评比ygxy主编ygya主谋,主席,高速度ygyf谈天说地,谢天谢地ygyg评语,就事论事,蛮不讲理,义正词严ygyj主课ygyl评为ygyn证词ygyq主义,说到底ygyu评说ygyw评论,市政府ygyy评议,语文,语言yh让,店,卞yha谑yhag谑yhfh高瞻远瞩yhg让yhga让开yhhi让步yhk店yhkd店yhkh让路yhlu弃旧图新yhng计上心来yhnt盲目性yhpr座上宾yhqg店铺yhqy谈虎色变yhrh这些年yhtj让利yhtu废旧物资yhu卞yhwp望眼欲穿yhwu让位yhxw让给yhy讣yi就,应,京yiae望尘莫及yiai就范,京东yiaq旅游区yiat就医yibd应承yibk就职yibm应聘yice应能yicf应对yicq应允yid应,鹫yide应有yidg鹫yidn就yidw廉洁奉公yie诮yieg诮yiet应用yifa方兴未艾yifd京城yifn应声yift应考,旅游者yigg说法不一yigu高水平yihk应战,旅游点yihq就餐yiik望洋兴叹yiit京海yiiv应当,京津yijg就是,应是yilf旅游团yind京剧yinh应收yinm应届yinn旅游局yint广泛性,谨小慎微yiog就业,旅游业yip谠yipq谠yiqm应负yiqv应急yirb文汇报yirp就近,应按yirv就势yiry应邀yisg京西,应酬yiss讲清楚yisv就要yitg应征yith就算yitj应得yiu京yiuj请注意yiuq应将yiwf应付yiwg夜深人静yiwu就位yiww应从yixf就绪yixj高消费yiyo应变yiyw就座,方法论yiyy应该,京广yj刘,齐,课yjbn说明了yjdy话里有话yjf廛yjff廛yjfj为时过早yjgj为时不晚yjgk齐整yjh刘yjhh课目yjhj课桌yjij为时尚早yjip课堂yjj齐,剂yjjf课时yjjg课题yjjh剂yjjj亮晶晶yjkk谩骂yjl谩yjlc谩yjnj为时已晚yjnn计量局,说明书,证明书yjny齐心yjq谒yjqh课外yjqn谒yjrj弃暗投明yjrn变电所yjs课,裹yjse裹yjsg课本yjsy课yjtk课程yjtl齐备yjuh变电站yjwh这时候yjwt课余yjww证明人yjwy齐集yjyd谁是谁非yjyu就是说yk训,误,识ykaa误工ykai衰落ykdh识破ykdy话中有话yken衷肠ykf吝ykft衰老ykfu吝啬ykg误,衰ykgd误ykge衰ykgm谴责ykgu裹足不前ykh训,衷,谴ykhe衷ykhk误点ykhp谴ykk襄,瓤,谔ykke襄ykkl识别ykkn谔ykky瓤ykmt衰败ykna吝惜yknf训导ykng衷情ykny衷心,市中心ykqe误解ykqn文史馆ykry训斥yksq襄樊ykud误差ykuj衰竭ykve衰退ykw识ykwf误传,误会ykwy识,训令ykxa训练ykxu衰弱ykya训诫ykyn衰亡ykyt训话ykyw言听计从ykyx废品率yl为,亩,库ylad库藏ylaq市辖区ylbn为了ylbv为限ylcw为难yldh库存yle谓yleg谓ylf亩ylfc颤动ylfk敲边鼓ylft主办者ylgk为副ylhh为止ylhx为此yljg为题ylk库,禀,颤ylki禀ylkm颤ylna为民ylnt禀性ylov为数ylpl主力军ylpp为之ylqi为国争光ylqk为名ylqy忘恩负义ylrb禀报ylru颤抖ylsg为本ylss颤栗ylut亩产,为首yluw为准ylw谡ylwf为佳ylws为何ylwt谡ylww为人yly为ylyc为序ylyg为主ylyi为ylyn库房,为国为民ym高,市,设ymab调节ymad高峰期ymah高雅ymaq市区ymau高薪ymb亢ymbb调子ymbm调出,高出ymby设防ymc设ymce高能ymcy设ymd庙,颃ymdd高大ymde设有ymdf高压ymdg调研ymdm颃,市面ymdp高达ymdr高原ymet调用ymf调ymfb高地ymfc调动ymfh高超ymfk调ymfm敲击ymfn高声,市场ymft高考ymgd这几天ymgf高于ymgg褒贬不一ymgh市政ymgk高速,调整ymgm讽刺ymh讪ymhj市ymhw高龄ymif高潮,设法ymij高温ymim高尚ymip调演ymiw高兴ymix高涨ymjq高昂ymk高,敲ymkc敲ymkf高ymkh调遣,高中ymkj高唱ymkt高呼ymlf设置ymmm高山ymmt高峰ymmw市内ymn讥ymna市民ymnf高层ymnt市属ympf高寒ympg庙宇ympj设宴ympw高空,市容ymq讽ymqe调解ymqf市镇ymqn刻骨铭心ymqy讽ymrg这几年来ymrh这几年ymrm市制ymrn调拨ymrp调控ymrq调换ymrs敲打ymrt高手ymrv高招ymsg调配ymsh设想ymsi高档ymsj调查ymsu高校ymta市长ymtf高等ymth高处ymtk调和ymtl设备ymtt讥笑ymtv市委ymty调入ymuq高效,市郊ymuu设立ymw讷ymwf庙会ymwi文山会海ymwq高低ymwt调任ymwv高分ymww高价,市价,调价ymwy讷,调集ymxe高级ymya调度,调试,高风亮节ymyf设计ymyj调剂ymym讥讽ymyt敲诈,设施ymyw市府yn记,词,望ynaa雇工,启发式ynad刻苦ynai刻薄ynaj刻划ynal记功ynan永世ynap启蒙ynb邙ynbb房子ynbc记取ynbh邙ynbp为民除害ynbw废除ynce高性能ynd戾,扉yndd扉ynde刻有yndh永存yndi戾yndm遍布yne户,肩,肓yned肩ynef肓yneg望ynet雇用,启用yneu肩膀yney遍及ynf讯ynfa记载ynfb遍地ynfc启动,妄动,忘却ynff启封ynfh讯,废墟ynfi启示ynfl齐心协力ynfp记过ynfq永远ynft记者ynfy义愤填膺yng诩yngg放心不下yngi永不yngk词,记事,启事,肇事yngl刻画yngy讲习班ynh盲ynhf盲ynhh废止,盲目,肩上ynhj废旧ynhk鏖战ynhw启齿yni永,昶ynia词汇ynii永,废水ynij昶ynin豪情满怀ynis废渣yniy废液ynj鹿,麝,麟ynjf麝,遍野ynjg麈ynjh麟ynjm麂ynjo麋ynjq鏖ynjt麇ynjw麒ynjx鹿ynjy说心里话ynk启,扈,赢ynkc扈ynkd启ynkg记号ynkk废品,户口ynkl永别ynkm雇员ynky赢,羸,蠃,嬴ynlf废黜ynlk妄加ynlt妄图,记忆力ynm遍,扁,翩ynma扁,词典,词曲ynme刻骨ynmk扃ynmn翩ynmp遍,启迪ynn忘,记,扇ynna氓ynnd扇ynng房屋,忘怀,忘情,永恒ynnn记忆ynnt房改,记性,启发,启发性ynnu忘ynou废料ynpw诀窍ynqh户外ynqk为避免ynqm肩负ynqr废铁ynqu记忆犹新ynqy永久ynrh忘掉ynri肩挑ynrn废气ynrr高蛋白ynsg忘本ynsh妄想ynsr刻板ynsy记述ynt刻,废,肇yntd户籍ynte房租,启航ynth肇,讯息ynti綮yntj刻,记得,赢得,赢利yntk启程yntl谧,劾yntm颏yntr废物,忘我yntw亥ynty废,读书笔记ynu戽ynud肩头ynuf戽,豪情壮志ynuj房间ynuk讯问ynut房产ynv亡,妄ynvf妄ynvi记录ynw廖,雇,诀ynwe谬,廖,雇佣ynwg谨慎从事ynwt记叙ynwv记分ynww盲从,盲人ynwy雇,诀,记住ynxe词组ynxj夜以继日ynxq废纸yny房ynyc废弃ynyd肇庆ynyg词语,雇主,户主ynyn忘记ynyt离心离德ynyv房ynyw谬论yo变,亦,谈yoa弈yoaf变革yoaj弈yob孪yobf孪yoc变yoce变通yocu变yod奕yodn变成yodu奕yody变态yoep恋爱yoev谈妥yofc变动yofg蛮干,变坏yofh谈起yoga变形yogd谈天yogi为数不少yogq为数不多yoid高精尖yoig谈清yoj蛮yoje变暖yoju蛮yokf谈吐yokh弯路yolf变黑yom峦,脔yoma弯曲yomj峦yomw脔yon恋yonu恋yony谈心yoo谈yooy谈yop迹,谜yopi迹yopy谜yoq鸾,銮yoqc变色yoqf銮yoqg鸾yoqj迹象yor挛yorf变质yorj挛yorq变换yos栾yosa蛮横yosh变相yosk亦可yosu栾,变样yotj变得yotk变种yott谈笑you亦youd谈判yov娈yovb变好yovc亦即yovf娈yowf亦佳yowx变化yox弯yoxb弯yoxn变幻yoya高精度yoyl变为yoyt谈话yoyw谈论yp这,亮,毫ypcm主客观ypdg言之有理ypdn豪迈ypdp高官厚禄ypdq毫克,豪爽ypdr说实在的ypdt言之有物ype谊,豪ypee讲礼貌ypeg谊ypeu豪ypfh熟视无睹ypft言之无物ypgg这一ypgr为之一振yphk这点yphx这些ypi这ypjf这里ypk膏ypke膏ypl诨yplh诨yplp这边ypm亮ypmb亮ypna诧异ypng豪情ypod这类ypoy毫米ypqt这儿yps亭ypsh亮相ypsj亭ypso豪杰ypt毫,诧,亳ypta诧,亳,毫升yptc这么yptk这种yptn毫ypwf庆祝会ypwk雍容华贵ypwx豪华ypyj文字说明ypyt豪放,说实话ypyw废寝忘食yq义,底,询yqa底,诋yqay底,诋yqd诡,谵yqdb诡yqdg试金石yqdy谵yqe廨yqeh廨yqfh肩负起yqfn言犹未尽yqgh底下yqi义yqj询yqjg询yqk谗yqkk试销品yqku谗yqn庖yqnf底层,义愤yqnt腐蚀性,永久性yqnv庖yqpu言外之意yqrn义气yqt诳yqte底盘yqtg诳yqtl义务yqty底稿yquk底部,询问yqv谄,诌,诤yqva诋毁yqvg谄,诌yqvh诤yqxl底细yqyj腐蚀剂yqyt诡诈,这句话yqyw底座yr诉,诛,诟yrad诉苦yrat齐抓共管yrdg读后感yrfn讲排场yrg诟yrgj应接不暇yrgk诟yri诛yrif亵渎yriy诛yrjg高质量yrkk试制品yrku调兵遣将yrlg摩托车yrnt试探性yrso高技术产业yrss文质彬彬yrsy高技术yrt庳yrtf庳yrv亵yrve亵yrww主持人yry诉yryf诉诸yryu诉说yryw诉讼yryy诉ys订,床,麻yscw磨难ysdd高楼大厦ysfn高枕无忧ysgf订于ysgg这样一来ysgo磨灭ysgw麻木不仁ysh订ysi床ysiq磨光ysj谭ysjh谭ysk诃yskg诃ysld变本加厉yslp床边ysmq订购ysod麻烦ysrk磨损ysrp摩擦,磨擦ysrt摩托yss麻,魔,磨yssc魔,麽yssd磨,靡yssf弃权票yssg麻醉yssi麻,縻yssn麾ysso糜yssr摩ysss麻木ysuj订单ysul麻痹ysuo文档资料ysuu订立,订阅ysuw高标准yswu床位yswx订货ysxa磨练ysxe调查组ysxy麻纺ysyg许可证ysyn订户yt放,话,谢yta旗ytaa施工ytaj谢幕ytak诱惑ytaw旗ytb施ytbc诈取ytbm放出ytbn施ytbp庭院ytbs高等院校ytcy诱骗,诈骗ytd话,旖ytdd放大ytdf诞辰ytdg话,设备厂ytdh放在ytdk旖ytdr许愿ytdv放肆ytdy文物古迹yte诱,旅,膂ytec施肥ytee膂yten诱ytep放逐ytet施用ytey旅ytf许,诰,庭ytfh许ytfk诰ytfn放声ytfp庭,放过ytfq诜ytg旆ytga放开ytgg言行不一ytgh旆,放下,施政ytgs永垂不朽yth诈,诞ythf诈ythh谈得上ythp诞ythv放眼ythw误入歧途ytii放水ytik旋涡ytip放学ytit诱敌深入ytiy旅游ytjg话题ytjm放映ytjn放电ytki放哨ytkk计算器ytkl话别ytkm话务员ytku孪生兄弟ytlf放置,庭园,旋转,旅行团ytlk施加ytm谢,旃ytmf谢ytmh旗帜ytmq旋风ytmt谈笑风生ytmy旃ytn旋,讫,旎ytna施展ytnd话剧,旅居ytnf诱导ytnh旋ytnj放慢ytnn讫,房管局ytnt诱发,方向性,语重心长ytnx旎ytny放心ytog畜牧业ytoo放火ytpa放宽ytpt旅客ytpy旅社,旅行社ytqn旅馆,诱饵ytqq许多ytqy许久ytre为我所用ytrf高科技ytrk诱拐ytrn忘乎所以ytrv放热ytsa敲竹杠ytsf旗杆ytsg话柄ytsk许可ytsm计算机ytsq夜长梦多ytsw放松ytt族,旌,旄ytta谈笑自若yttd族ytte方向盘yttf旅行,施行,设身处地yttg旌,诞生yttk旅程yttl话务yttm放射,话筒yttn旄yttr放牧yttv旋律ytud放养,话头,妄自尊大ytuj话音ytum言简意赅ytut试生产,主航道ytv诿ytvg诿ytwa诱供,高利贷ytwf施舍,评委会ytwn放假ytwt放任,旅途ytww诱人,庄稼人ytx诲ytxj房租费ytxq谢绝ytxu诲ytxw放纵yty放,州,旒ytya许诺ytyc放弃ytyg话语ytyh州,旅店ytyq旒ytyt施放,谢谢ytyx高利率yu说,详,廉yubh廉耻yubi谦逊yuce说通yud详,庠yudh详yudk庠yudu麻痹大意yue谫yueb说服yued广交朋友yuev谫yufh说起yufp说过yuft说教yug谰,斓yugh廉政yugi谰,斓yugj说理,讲道理yugp席卷一空yuha谦虚yuhj谈判桌yuif廉洁,说法yuj谙yuje说明yujg谙,高产量,亩产量yuk说yukj说唱yukk评头品足,畜产品yukq说yulf访问团yult详略yum谪yuma话音刚落yumd谪yuna讳疾忌医yung详情yuny详尽yuo谱yuoj谱yup谤,谛yupg谱写,说定yuph谛yupp亡羊补牢yupw说穿yupy谤yuq谘yuqk谘yurd论资排辈yuri摩拳擦掌yurk课间操yurs高新技术yut谚yute谚yutf讲道德yutk谦和yutt说笑yuuf齐头并进yuuw高效益,讲效益yuv谦yuvo廉,谦yuw谥yuwl谥yuww廉价yuxl详细yuya说谎yuyg谚语yuyk评头论足,熟门熟路yuyn肩并肩yuyo详谈yuyt说话,说闲话yuyx高效率yuyy谰言yv良,朗,郎yvad良苦yvat良医yvax良药yvc朗yvcb郎yvce朗yvdc良友yvdp记录在案yve良,庸,裒yveh庸yvei良yveu裒yvft庸才yvh唐yvhk唐yvi康yvii康yvjg良师yvk诏yvkg诏yvll良田yvmm唐山yvnt良性yvny良心yvpi良宵yvpw唐突yvsm良机yvtd良知yvtg良策yvtj康复yvtk良种yvtw诚恳待人yvvb良好yvw庚,庾,谀yvwi庚,庾yvwm赓yvws离退休yvww庸俗yvwy谀yvxx良缘yvyc朗诵yvyf朗读yvyv朗朗yw认,谁,论ywab文化节ywaf论著ywai变化莫测ywaj夜幕ywbb高分子ywbm认出ywc讼ywcy讼ywdw文化大革命ywe诊ywet诊,讲信用ywf府,腐ywff论坛ywfh认真ywfi府,变化无常ywfw腐ywg诠,谕ywga豪华型ywgf为人正直ywgg诠ywgj谕,论理ywgk这件事ywgw诲人不倦,讨价还价ywgy夜班ywhk论点,论战ywic诊治ywig认清ywiq夜光ywis鹰潭ywjf夜里ywjg为人师表ywjq夜晚ywk褒ywke褒ywld认罪ywlf访华团ywlw认输,文化界ywmg认同,订合同ywmh认帐ywmq认购ywmt褒贬,腐败ywna为人民ywnn文化局ywnt为人民服务ywon诊断ywou腐烂ywpg认定ywpk文化宫ywpt亡命之徒ywqa认错ywqc夜色ywqn腐蚀,文化馆ywqu变化多端ywrn褒扬,论据,诊所ywrt为人所知yws庥ywsg腐朽ywsi庥ywsk认可ywsu夜校ywsy论述ywt夜ywtc为什么ywtd谁知ywtf亡命徒,言传身教ywth论处ywtj认得ywty夜ywu於ywub诊疗ywuh文化站ywuj夜间ywuk文化部ywuq褒奖,座次ywuy於yww座,鹰,卒ywwc主人公,主人翁ywwe膺ywwf座,卒ywwg鹰,谶ywwt衣食住行ywwu座位ywwx腐化ywwy认领ywx论,讹ywxn讹,论ywy谁,认,谯ywyg谁,论证ywyk认识ywym论调,夜市ywyn谂ywyo谯,座谈ywyq褒义ywyt讹诈,说假话ywyu论说ywyy论文yx率,玄,畜yxai变幻莫测yxdg训练有素yxfi变幻无常yxgy训练班yxi率,紊yxif率yxiu紊yxj诣yxjg诣yxl畜yxlf畜yxry庇护yxt雍,壅,饔yxtd紊乱yxte饔yxtf壅,率先yxtr畜牧yxtv计经委yxty雍yxu玄yxuf离乡背井yxut畜产yxuu离经叛道yxv庀yxwy率领yxx庇,谐yxxr谐yxxv庇yxya高强度yy方,文,广yyaa方式yyaf文革yyah文雅yyai广东yyan文艺yyb廓,谆yybb廓yybg谆yybp议院,设计院yybu文联yyce方能yyck主席台yydd广大,方方面面yydh高高在上yydm方面yyes文采yyfg广博yyfm文献yyfn方块,广场yyfq广元yyft文教,设计者yyg亠yyga方形yyge文静yygg方方正正yygk议事yygl诉诸武力yygn方yygt广yygw恋恋不舍yygy文yyi谅yyif方法,诉讼法yyii高高兴兴yyip文学,语言学yyit广泛yyiy谅yyje文明,讲文明yyjg议题,设计师yyjj访日yyjy这就是说yykh文中yykm议员,评论员yykq文史,齐齐哈尔yyl丶,廪yylf主席团yyli廪yylk方圆yyll丶yylt设计图yymm庐山,文山yymq文风,议购yyn访,讠,庐yyna谝yyne庐yynn文书yynw该yypb文字yype评论家yypg议定,调度室yypv方案,议案yyq议yyqe谅解yyqf方针yyqq许许多多yyqy议yyrk摩肩接踵yyrt广播yyru文摘yysa方框yysg广西,文本yysk方可yytd言辞yytf广告,文告,文选,言行yytk方程,言和,议程yytm方向yyto说话算数yytr文物,废弃物yytt文笔,说说笑笑yyty文稿,望文生义yyug访美yyui广阔yyuj文章yyuk访问yyuy高谈阔论,豪言壮语yyv廊yyvb廊yyvk文娱yyw谇yywf谇,议会,座谈会yywg方便yywr文件yyws文体yywt文凭yywu方位yyww文人,议价yywx文化,访华yywy文集,论文集,主席令yyxx详详细细yyy言yyya广度,议席yyyc广袤yyyg言语yyyl误认为yyym广州市yyyn言词yyyo言谈yyyp变废为宝yyyq广义yyyt广州yyyw言论,议论,认识论yyyy言";
}
public class WuBi2 : MonoBehaviour
{
	private List<int> start_stack = new List<int>();

	private List<int> index_stack = new List<int>();

	private List<string> word_list = new List<string>();

	private string candidates = "";

	private string pattern = "[a-z]+[^a-z]+";

	private List<string> code_table = new List<string>();

	private int start_mem = -1;

	private int index_mem;

	private string code_field;

	public bool 是否输入;

	private void Awake()
	{
		foreach (Match item in Regex.Matches(Var2.raw, pattern))
		{
			code_table.Add(item.Value);
		}
		pattern = "[a-z]+";
	}

	private void Start()
	{
	}

	public List<string> 下一页()
	{
		if (start_mem != -1)
		{
			start_stack.Add(start_mem);
			index_stack.Add(index_mem);
			for (int i = 0; i <= 9; i++)
			{
				word_list[i] = "";
			}
			create_word_list(start_mem, index_mem, code_field);
			return word_list;
		}
		return null;
	}

	public List<string> 上一页()
	{
		if (start_stack.Count > 1)
		{
			start_stack.Remove(start_stack.Count - 1);
			index_stack.Remove(index_stack.Count - 1);
			create_word_list(start_stack[start_stack.Count - 1], index_stack[index_stack.Count - 1], code_field);
			return word_list;
		}
		return null;
	}

	public List<string> 输入(string str)
	{
		是否输入 = true;
		code_field = str;
		on_code_change(code_field);
		return word_list;
	}

	public int search_code_table(string str)
	{
		int result = -1;
		double num = 0.0;
		double num2 = code_table.Count - 1;
		int length = str.Length;
		int num3 = 0;
		while (num <= num2)
		{
			num3++;
			int num4 = (int)(num + num2) / 2;
			string text = "";
			foreach (Match item in Regex.Matches(code_table[num4], pattern))
			{
				text = item.ToString();
			}
			if (text.Length >= length)
			{
				if (text.Substring(0, length) == str)
				{
					result = num4;
					num2 = num4 - 1;
				}
				else if (string.Compare(text, str) == 1)
				{
					num2 = num4 - 1;
				}
				else
				{
					num = num4 + 1;
				}
			}
			else if (string.Compare(text, str) == 1)
			{
				num2 = num4 - 1;
			}
			else
			{
				num = num4 + 1;
			}
		}
		return result;
	}

	public void create_word_list(int start, int index, string str)
	{
		int length = str.Length;
		int i = 1;
		string text = "[^a-z]+";
		string input = "";
		foreach (Match item in Regex.Matches(code_table[start], text))
		{
			input = item.ToString();
		}
		string[] array = Regex.Split(input, ",");
		candidates = "";
		for (; i <= 10; i++)
		{
			candidates = candidates + (i % 10 + 46) + array[index] + " ";
			word_list[i - 1] = array[index];
			index++;
			if (index < array.Length)
			{
				continue;
			}
			index = 0;
			start++;
			if (start >= code_table.Count || code_table[start].Substring(0, length) != str)
			{
				start = -1;
				break;
			}
			foreach (Match item2 in Regex.Matches(code_table[start], text))
			{
				input = item2.ToString();
			}
			array = Regex.Split(input, ",");
		}
		if (start > 0)
		{
			if (start_stack.Count > 1)
			{
				candidates += "<PgUp  PgDn>";
			}
			else
			{
				candidates += " PgDn>";
			}
		}
		else if (start_stack.Count > 1)
		{
			candidates += "<PgUp";
		}
		else
		{
			candidates = candidates ?? "";
		}
		start_mem = start;
		index_mem = index;
	}

	public void on_code_change(string str)
	{
		for (int i = 0; i <= 9; i++)
		{
			word_list.Add("");
		}
		for (int j = 0; j <= 9; j++)
		{
			word_list[j] = "";
		}
		candidates = "";
		start_stack.Clear();
		index_stack.Clear();
		if (str != "")
		{
			int num = search_code_table(str);
			start_stack.Add(num);
			index_stack.Add(0);
			if (num >= 0)
			{
				create_word_list(num, 0, str);
			}
		}
	}

	public int 转换ASCII(string zimu)
	{
		byte num = Encoding.ASCII.GetBytes(zimu)[0];
		Convert.ToString((int)num);
		return num;
	}

	private void Ascii(string zimu)
	{
	}

	private void Update()
	{
	}
}
public class Window : MonoBehaviour
{
	public static Window _instan;

	[Header("语音识别")]
	public string url = "https://openapi.baidu.com/oauth/2.0/token";

	public string token;

	public AudioClip SetClip;

	public AudioSource 播放器;

	private int 序列;

	public IEnumerator uploadVoice(byte[] postData)
	{
		WWWForm wWWForm = new WWWForm();
		UnityEngine.Debug.Log("Read wav file. Size: " + postData.Length + " bytes");
		Dictionary<string, string> headers = wWWForm.headers;
		headers["Method"] = "POST";
		headers["Content-Type"] = "audio/wav; rate=8000";
		headers["Content-Length"] = postData.Length.ToString();
		wWWForm.AddBinaryData("fileUpload", postData, "flacFile", "audio/wav; rate=8000");
		WWW getData = new WWW("http://vop.baidu.com/server_api?lan=zh&cuid=vr&token=" + token, wWWForm.data, headers);
		yield return getData;
		if (getData.error != null)
		{
			UnityEngine.Debug.Log(getData.error);
			yield break;
		}
		Regex regex = new Regex("[一-龥]+");
		string text = "";
		foreach (Match item in regex.Matches(getData.text))
		{
			text += item.Value;
			switch (item.Value)
			{
			case "玩一号":
				序列 = 1;
				玩几号(序列);
				break;
			case "玩的号":
				序列 = 1;
				玩几号(序列);
				break;
			case "玩以号":
				序列 = 1;
				玩几号(序列);
				break;
			case "玩你号":
				序列 = 1;
				玩几号(序列);
				break;
			case "玩的好":
				序列 = 1;
				玩几号(序列);
				break;
			case "玩二号":
				序列 = 2;
				玩几号(序列);
				break;
			case "玩三号":
				序列 = 3;
				玩几号(序列);
				break;
			case "玩四号":
				序列 = 4;
				玩几号(序列);
				break;
			case "玩五号":
				序列 = 5;
				玩几号(序列);
				break;
			case "玩六号":
				序列 = 6;
				玩几号(序列);
				break;
			case "玩七号":
				序列 = 7;
				玩几号(序列);
				break;
			case "玩八号":
				序列 = 8;
				玩几号(序列);
				break;
			case "玩九号":
				序列 = 9;
				玩几号(序列);
				break;
			case "玩十号":
				序列 = 10;
				玩几号(序列);
				break;
			case "玩十一号":
				序列 = 11;
				玩几号(序列);
				break;
			case "玩十二号":
				序列 = 12;
				玩几号(序列);
				break;
			case "玩十三号":
				序列 = 13;
				玩几号(序列);
				break;
			case "玩十四号":
				序列 = 14;
				玩几号(序列);
				break;
			case "玩十五号":
				序列 = 15;
				玩几号(序列);
				break;
			case "玩十六号":
				序列 = 16;
				玩几号(序列);
				break;
			case "玩十七号":
				序列 = 17;
				玩几号(序列);
				break;
			case "玩十八号":
				序列 = 18;
				玩几号(序列);
				break;
			case "玩十九号":
				序列 = 19;
				玩几号(序列);
				break;
			case "玩二十号":
				序列 = 20;
				玩几号(序列);
				break;
			case "玩二十一号":
				序列 = 21;
				玩几号(序列);
				break;
			case "玩二十二号":
				序列 = 22;
				玩几号(序列);
				break;
			case "玩二十三号":
				序列 = 23;
				玩几号(序列);
				break;
			case "玩二十四号":
				序列 = 24;
				玩几号(序列);
				break;
			case "玩二十五号":
				序列 = 25;
				玩几号(序列);
				break;
			case "玩二十六号":
				序列 = 26;
				玩几号(序列);
				break;
			case "玩二十七号":
				序列 = 27;
				玩几号(序列);
				break;
			case "玩二十八号":
				序列 = 28;
				玩几号(序列);
				break;
			case "玩二十九号":
				序列 = 29;
				玩几号(序列);
				break;
			case "玩三十号":
				序列 = 30;
				玩几号(序列);
				break;
			case "玩三十一号":
				序列 = 31;
				玩几号(序列);
				break;
			case "玩三十二号":
				序列 = 32;
				玩几号(序列);
				break;
			case "玩三十三号":
				序列 = 33;
				玩几号(序列);
				break;
			}
		}
		MonoBehaviour.print(text);
	}

	public void 开始录音()
	{
		UnityEngine.Debug.Log("start");
		播放器.clip = Microphone.Start(Microphone.devices[0], loop: false, 10, 8000);
		MonoBehaviour.print(Microphone.devices.Length);
	}

	public void 结束录音()
	{
		UnityEngine.Debug.Log("stop");
		Microphone.End(Microphone.devices[0]);
	}

	public void 播放及执行命令()
	{
		UnityEngine.Debug.Log("play");
		播放器.Play();
		float[] array = new float[播放器.clip.samples];
		播放器.clip.GetData(array, 0);
		short[] array2 = new short[array.Length];
		byte[] array3 = new byte[array.Length * 2];
		int num = 32767;
		for (int i = 0; i < array.Length; i++)
		{
			array2[i] = (short)(array[i] * (float)num);
			_ = new byte[2];
			BitConverter.GetBytes(array2[i]).CopyTo(array3, i * 2);
		}
		StartCoroutine(uploadVoice(array3));
	}

	public void 玩几号(int 数字)
	{
		UnityEngine.Application.OpenURL("E:/vr2045/" + 数字 + "/" + 数字 + ".exe");
	}
}
public class Friend : MonoBehaviour
{
	public static Friend _intance;

	public string Xuwo_id { get; set; }

	public string Xuwo_nickname { get; set; }

	public string Xuwo_headimgurl { get; set; }

	public string[] Xuwo_friend { get; set; }

	public string[] Xuwo_gtoup { get; set; }

	private void Awake()
	{
		_intance = this;
	}
}
public class FriendData : MonoBehaviour
{
	public static FriendData _intance;

	public List<Person> FriData = new List<Person>();

	public Person 自己;

	private string[] p;

	private string[] g;

	private void Awake()
	{
		_intance = this;
	}

	public void AddFriend()
	{
		for (int i = 0; i < MySocket.用户信息["好友信息"].Count; i++)
		{
			Person item = new Person(MySocket.用户信息["好友信息"][i]["weiwo_id"].ToString(), MySocket.用户信息["好友信息"][i]["weiwo_nickname"].ToString(), Headimg: MySocket.用户信息["好友信息"][i]["weiwo_headimgurl"].ToString(), Friend: p, Group: g);
			FriData.Add(item);
		}
	}

	public void GetData()
	{
		string id = MySocket.用户信息["自己的信息"]["weiwo_id"].ToString();
		string nickname = MySocket.用户信息["自己的信息"]["weiwo_nickname"].ToString();
		string headimg = MySocket.用户信息["自己的信息"]["weiwo_headimgurl"].ToString();
		string[] friend = jsontoString(MySocket.用户信息["自己的信息"]["weiwo_friend"].ToString(), ",");
		string[] group = jsontoString(MySocket.用户信息["自己的信息"]["weiwo_group"].ToString(), ",");
		Person item = new Person(id, nickname, friend, group, headimg);
		FriData.Add(item);
		自己 = item;
	}

	public Person GetListData(string xuwo_id)
	{
		foreach (Person friDatum in FriData)
		{
			if (friDatum.Xuwo_id == xuwo_id)
			{
				return friDatum;
			}
		}
		return null;
	}

	public string[] jsontoString(string target, string s)
	{
		return Regex.Split(target, s);
	}
}
public class Person
{
	private string xuwo_id;

	private string xuwo_nickname;

	private string[] xuwo_friend;

	private string[] xuwo_group;

	private string xuwo_headimgurl;

	public string Xuwo_id => xuwo_id;

	public string Xuwo_nickname => xuwo_nickname.Substring(1, xuwo_nickname.Length - 2);

	public string Xuwo_headimgurl => xuwo_headimgurl;

	public string[] Xuwo_friend => xuwo_friend;

	public string[] Xuwo_gtoup => xuwo_group;

	public Person(string Id, string Nickname, string[] Friend, string[] Group, string Headimg)
	{
		xuwo_id = Id;
		xuwo_nickname = Nickname;
		xuwo_friend = Friend;
		xuwo_group = Group;
		xuwo_headimgurl = Headimg;
	}
}
public enum ChatType
{
	World,
	Private,
	Group
}
public class ChatController : MonoBehaviour
{
	public static ChatController _instance;

	public ChatType chatType;

	public GameObject worldGrid;

	public GameObject worldItem;

	public GameObject otherWorldItem;

	public Transform pos;

	public GameObject 聊天面板;

	public GameObject worldUI;

	public GameObject privateUI;

	public GameObject groupUI;

	public GameObject findFriendUI;

	public GameObject CreateGroupUI;

	public Text textInput;

	public string currentID;

	public string 自己的虚号;

	public GameObject friendAcceptItem;

	public Transform 接受UI位置;

	public GameObject 添加好友提醒;

	private void Awake()
	{
		_instance = this;
		自己的虚号 = MySocket._instance.虚号;
		UpdateShow();
	}

	private void Start()
	{
		foreach (PersonMessage personMessage in MessageClass._instance.personMessageList)
		{
			MessageClass._instance.persontipsList.Add(personMessage);
		}
		foreach (PersonMessage persontips in MessageClass._instance.persontipsList)
		{
			if (!MySocket.idList.Contains(persontips.个人虚号))
			{
				MySocket.idList.Add(persontips.个人虚号);
				MessageTips._instance.个人信息提醒(persontips.个人虚号);
			}
		}
		if (MySocket.申请好友列表.Count > 0)
		{
			添加好友提醒.SetActive(value: true);
		}
		好友同意添加反馈();
	}

	public void UpdateShow()
	{
		for (int i = 0; i < worldGrid.transform.childCount; i++)
		{
			UnityEngine.Object.Destroy(worldGrid.transform.GetChild(i).gameObject);
		}
		switch (chatType)
		{
		case ChatType.World:
			worldUI.SetActive(value: true);
			privateUI.SetActive(value: false);
			groupUI.SetActive(value: false);
			findFriendUI.SetActive(value: false);
			CreateGroupUI.SetActive(value: false);
			世界信息初始化();
			break;
		case ChatType.Private:
			worldUI.SetActive(value: false);
			privateUI.SetActive(value: true);
			groupUI.SetActive(value: false);
			findFriendUI.SetActive(value: false);
			CreateGroupUI.SetActive(value: false);
			break;
		case ChatType.Group:
			worldUI.SetActive(value: false);
			privateUI.SetActive(value: false);
			groupUI.SetActive(value: true);
			findFriendUI.SetActive(value: false);
			CreateGroupUI.SetActive(value: false);
			break;
		}
	}

	public void 世界信息初始化()
	{
		MySocket.用户信息["世界信息"].ToString();
		for (int i = 0; i < MySocket.用户信息["世界信息"].Count; i++)
		{
			string text = MySocket.用户信息["世界信息"][i]["信息"].ToString();
			string text2 = MySocket.用户信息["世界信息"][i]["id"].ToString();
			text = text.Substring(1, text.Length - 2);
			text2 = text2.Substring(1, text2.Length - 2);
			实例化(text2, text);
		}
	}

	public void 点击聊天()
	{
		聊天面板.SetActive(value: true);
		float y = pos.transform.parent.transform.position.y;
		聊天面板.transform.position = new Vector3(pos.transform.position.x, y, pos.transform.position.z);
		聊天面板.transform.localRotation = new Quaternion(0f, base.transform.localRotation.y, 0f, base.transform.localRotation.w);
		float x = 聊天面板.transform.localEulerAngles.x;
		float y2 = 聊天面板.transform.localEulerAngles.y - 15f;
		float z = 聊天面板.transform.localEulerAngles.z;
		聊天面板.transform.localRotation = Quaternion.Euler(x, y2, z);
	}

	public void 关闭聊天()
	{
		聊天面板.SetActive(value: false);
		chatType = ChatType.World;
	}

	public void 点击文本输入框()
	{
		textInput.text = "";
		井模块._instance.输入法显示();
		井模块._instance.输入法.GetComponent<Load>().字 = textInput;
		RightHand._instance.gameObject.transform.Find("Cube").gameObject.SetActive(value: true);
	}

	public void 发送信息()
	{
		if (textInput.text != null)
		{
			if (_instance.chatType == ChatType.World)
			{
				MySocket._instance.发送世界信息(自己的虚号, textInput.text);
			}
			else if (_instance.chatType == ChatType.Private)
			{
				MySocket.发送私聊信息(currentID, textInput.text);
				实例化(自己的虚号, textInput.text);
			}
			else if (_instance.chatType == ChatType.Group)
			{
				MySocket.发送群信息(currentID, textInput.text);
			}
		}
		textInput.text = "";
	}

	public void 实例化(string id, string message)
	{
		GameObject gameObject = null;
		if (_instance.chatType == ChatType.World)
		{
			gameObject = UnityEngine.Object.Instantiate(worldItem, worldGrid.transform.position, Quaternion.identity);
			if (id == MySocket._instance.虚号)
			{
				gameObject.transform.Find("NameText").GetComponent<Text>().color = Color.red;
				gameObject.transform.Find("MessageText").GetComponent<Text>().color = Color.red;
			}
			gameObject.GetComponent<WorldItem>().UpdateMessage(id, message);
		}
		else if (_instance.chatType == ChatType.Private)
		{
			gameObject = ((!(id == MySocket._instance.虚号)) ? UnityEngine.Object.Instantiate(worldItem, worldGrid.transform.position, Quaternion.identity) : UnityEngine.Object.Instantiate(otherWorldItem, worldGrid.transform.position, Quaternion.identity));
			gameObject.GetComponent<WorldItem>().UpdateMessage(id, message);
		}
		else if (_instance.chatType == ChatType.Group)
		{
			gameObject = ((!(id == MySocket._instance.虚号)) ? UnityEngine.Object.Instantiate(worldItem, worldGrid.transform.position, Quaternion.identity) : UnityEngine.Object.Instantiate(otherWorldItem, worldGrid.transform.position, Quaternion.identity));
			gameObject.GetComponent<WorldItem>().UpdateMessage(id, message);
		}
		gameObject.transform.SetParent(worldGrid.transform);
		gameObject.transform.localScale = Vector3.one;
		gameObject.transform.localRotation = Quaternion.identity;
	}

	public void 好友同意添加反馈()
	{
		for (int i = 0; i < MySocket.申请好友成功反馈.Count; i++)
		{
			GameObject obj = UnityEngine.Object.Instantiate(friendAcceptItem, base.transform.position, Quaternion.identity);
			float y = pos.transform.parent.transform.position.y;
			obj.transform.position = new Vector3(pos.transform.position.x, y, pos.transform.position.z);
			obj.transform.localRotation = new Quaternion(0f, base.transform.localRotation.y, 0f, base.transform.localRotation.w);
			float x = obj.transform.localEulerAngles.x;
			float y2 = obj.transform.localEulerAngles.y - 15f;
			float z = obj.transform.localEulerAngles.z;
			obj.transform.localRotation = Quaternion.Euler(x, y2, z);
			obj.transform.localScale = new Vector3(0.006179337f, 0.006179337f, 0.006179337f);
			obj.GetComponent<FriendAcceptItem>().初始化(MySocket.申请好友成功反馈[i]);
		}
	}
}
public class GetNetTime : MonoBehaviour
{
	public static GetNetTime _instance;

	private string url = "http://www.hko.gov.hk/cgi-bin/gts/time5a.pr?a=2";

	public string s;

	private void Awake()
	{
		_instance = this;
		GetTimer();
	}

	public void GetTimer()
	{
		StartCoroutine(GetNowTime());
	}

	private IEnumerator GetNowTime()
	{
		yield return null;
		string timeStamp = GetWebClient(url).Split('=')[1].Substring(0, 10);
		DateTime time = GetTime(timeStamp);
		s = time.Year + "/" + time.Month + "/" + time.Day + "  " + time.Hour + ":" + time.Minute + ":" + time.Second;
	}

	private string GetWebClient(string url)
	{
		Stream stream = new WebClient().OpenRead(url);
		string result = new StreamReader(stream, Encoding.GetEncoding("utf-8")).ReadToEnd();
		stream.Close();
		return result;
	}

	public DateTime GetTime(string timeStamp)
	{
		DateTime dateTime = TimeZone.CurrentTimeZone.ToLocalTime(new DateTime(1970, 1, 1));
		long ticks = long.Parse(timeStamp + "0000000");
		TimeSpan value = new TimeSpan(ticks);
		return dateTime.Add(value);
	}
}
public class Chat : MonoBehaviour
{
	public static Chat _instance;

	public string 群号;

	public Group g;

	private string 名字;

	public new Text name;

	public Text 提示;

	public GameObject 文字;

	public GameObject 语音;

	public GameObject 我的信息项;

	public GameObject 其他人信息项;

	public Transform grid;

	public Text text;

	public string message;

	public GameObject 群聊UI;

	public GameObject 群信息UI;

	public GameObject 改名UI;

	public GameObject 退群UI;

	public Scrollbar 信息Bar;

	public Scrollbar 头像Bar;

	public Text 群名;

	public float 初始的高度;

	public float 间隔高度;

	public float dis;

	private void Awake()
	{
		_instance = this;
	}

	private void Start()
	{
		ShowText();
		初始的高度 = -166f;
		text.transform.parent.GetComponent<RectTransform>().sizeDelta = new Vector2(100f, 17.3f);
		text.transform.parent.GetComponent<RectTransform>().localPosition = new Vector3(0f, -8f, 0f);
		dis = text.preferredHeight;
	}

	public void ShowText()
	{
		文字.SetActive(value: true);
		语音.SetActive(value: false);
	}

	public void ShowVoice()
	{
		文字.SetActive(value: false);
		语音.SetActive(value: true);
		提示.text = "按住扳机说话，快速摇晃手柄取消";
	}

	public void 初始化()
	{
		初始的高度 = -166f;
		for (int i = 0; i < grid.transform.childCount; i++)
		{
			UnityEngine.Object.Destroy(grid.transform.GetChild(i).gameObject);
		}
		if (MessageClass._instance.messageList.Count > 0)
		{
			for (int j = 0; j < MessageClass._instance.messageList.Count; j++)
			{
				List<Message> messageList = MessageClass._instance.messageList;
				if (messageList[j].群号 == 群号)
				{
					接受其他人文本信息(messageList[j].个人虚号, messageList[j].消息);
					MessageClass._instance.messageList.Remove(messageList[j]);
				}
			}
		}
		for (int k = 0; k < MySocket.groupIdList.Count; k++)
		{
			if (MySocket.groupIdList[k] == 群号)
			{
				MySocket.groupIdList.Remove(MySocket.idList[k]);
			}
		}
	}

	public void 发自己文本信息(string id, string message)
	{
		GameObject obj = UnityEngine.Object.Instantiate(我的信息项, grid.position, Quaternion.identity);
		obj.transform.SetParent(grid.transform);
		obj.transform.localRotation = Quaternion.Euler(0f, 0f, 180f);
		obj.GetComponent<MessageItem>().SetProprety(id, message);
		obj.transform.localScale = Vector3.one;
	}

	public void 输入框()
	{
		text.text = "";
		井模块._instance.输入法显示();
		井模块._instance.输入法.GetComponent<Load>().字 = text;
		Var.字 = text;
		text.transform.parent.GetComponent<RectTransform>().sizeDelta = new Vector2(100f, 17.3f);
		text.transform.parent.GetComponent<RectTransform>().localPosition = new Vector3(0.4f, -8f, 0f);
		text.transform.parent.transform.localScale = Vector3.one;
	}

	private void Update()
	{
		if (text.GetComponent<RectTransform>().rect.height > dis)
		{
			text.transform.parent.GetComponent<RectTransform>().sizeDelta = new Vector2(text.transform.parent.GetComponent<RectTransform>().rect.width, text.preferredHeight);
			text.transform.parent.GetComponent<RectTransform>().localPosition = new Vector3(text.transform.parent.GetComponent<RectTransform>().localPosition.x, text.transform.parent.GetComponent<RectTransform>().localPosition.y - (float)text.fontSize * 0.5f, text.transform.parent.GetComponent<RectTransform>().localPosition.z);
			text.transform.parent.transform.localScale = Vector3.one;
			dis = text.preferredHeight;
		}
	}

	public void 发送信息()
	{
		message = text.text;
		if (message != "" && message != null)
		{
			MySocket.发送群信息(RightController._instance.currentGroup.id, message);
		}
		text.transform.parent.GetComponent<RectTransform>().sizeDelta = new Vector2(100f, 17.3f);
		text.transform.parent.GetComponent<RectTransform>().localPosition = new Vector3(0f, -8f, 0f);
		text.transform.parent.transform.localScale = Vector3.one;
		text.text = "";
	}

	public void Send()
	{
		if (MessageClass._instance.messageList.Count <= 0)
		{
			return;
		}
		foreach (Message message in MessageClass._instance.messageList)
		{
			if (RightController._instance.currentGroup.id == message.群号)
			{
				if (message.个人虚号 == FriendData._intance.自己.Xuwo_id)
				{
					发自己文本信息(message.个人虚号, message.消息);
				}
				else
				{
					接受其他人文本信息(message.个人虚号, message.消息);
					MessageClass._instance.messageList.Remove(message);
				}
			}
			MessageClass._instance.messageList.Remove(message);
		}
	}

	public void 接受其他人文本信息(string id, string message)
	{
		GameObject obj = UnityEngine.Object.Instantiate(其他人信息项, grid.position, Quaternion.identity);
		obj.transform.SetParent(grid.transform);
		obj.transform.localRotation = Quaternion.identity;
		obj.GetComponent<MessageItem>().SetProprety(id, message);
		obj.transform.localScale = Vector3.one;
	}

	public void SetName(string s)
	{
		名字 = s;
		name.text = s;
	}

	public void SetGroupId(string id)
	{
		群号 = id;
		g = Groups._instance.getGroupById(id);
	}

	public void 关闭提示()
	{
		GetComponentInChildren<GroupMessage>().信息提醒();
	}

	public void 关闭群聊面板()
	{
		群聊UI.SetActive(value: false);
		群信息UI.SetActive(value: true);
		GetComponentInChildren<GroupMessage>().初始化();
		GetComponentInChildren<GroupMessage>().SetGroupName(名字);
	}

	public void 群聊信息返回面板()
	{
		群信息UI.SetActive(value: false);
		群聊UI.SetActive(value: true);
	}

	public void 退群面板()
	{
		群信息UI.SetActive(value: false);
		退群UI.SetActive(value: true);
	}

	public void 改群名()
	{
		群信息UI.SetActive(value: false);
		改名UI.SetActive(value: true);
	}

	public void 群名修改面板返回()
	{
		群信息UI.SetActive(value: true);
		改名UI.SetActive(value: false);
	}

	public void 退群返回()
	{
		退群UI.SetActive(value: false);
		群信息UI.SetActive(value: true);
	}

	public void 修改群名()
	{
		text.text = "";
		井模块._instance.输入法显示();
		井模块._instance.输入法.GetComponent<Load>().字 = text;
		Var.字 = text;
		Var.字 = 群名;
	}
}
public class CreateGroups : MonoBehaviour
{
	public static CreateGroups _instance;

	public GameObject 好友信息项;

	public List<GameObject> 好友信息列表 = new List<GameObject>();

	public GameObject Grid;

	public GameObject 头像项;

	public GameObject hGrid;

	public List<GameObject> 添加头像列表 = new List<GameObject>();

	private void Awake()
	{
		_instance = this;
	}

	public void 初始化()
	{
		for (int i = 0; i < Grid.transform.childCount; i++)
		{
			UnityEngine.Object.Destroy(Grid.transform.GetChild(i).gameObject);
			好友信息列表.Clear();
		}
		for (int j = 0; j < hGrid.transform.childCount; j++)
		{
			UnityEngine.Object.Destroy(hGrid.transform.GetChild(j).gameObject);
			RightController._instance.添加好友列表.Clear();
			添加头像列表.Clear();
		}
		for (int k = 0; k < FriendData._intance.FriData.Count; k++)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(好友信息项, Grid.transform.position, Quaternion.identity);
			gameObject.transform.SetParent(Grid.transform);
			gameObject.transform.localScale = Vector3.one;
			gameObject.transform.localRotation = Quaternion.identity;
			gameObject.GetComponent<PersonItem>().SetMessage(FriendData._intance.FriData[k]);
			好友信息列表.Add(gameObject);
		}
	}

	public void 添加好友(GameObject go)
	{
		更新添加或取消好友头像(go, isSelect: true);
	}

	public void 取消好友(GameObject go)
	{
		更新添加或取消好友头像(go, isSelect: false);
	}

	public void 更新添加或取消好友头像(GameObject go1, bool isSelect)
	{
		Person 信息 = go1.GetComponent<PersonItem>().信息;
		if (isSelect)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(头像项, hGrid.transform.position, Quaternion.identity);
			gameObject.transform.SetParent(hGrid.transform);
			gameObject.transform.localRotation = Quaternion.identity;
			gameObject.transform.localScale = Vector3.one;
			gameObject.GetComponent<HeadItem>().设置头像(信息);
			RightController._instance.添加好友列表.Add(信息);
			添加头像列表.Add(gameObject);
			return;
		}
		for (int i = 0; i < 添加头像列表.Count; i++)
		{
			if ((bool)添加头像列表[i] && 信息.Xuwo_id == 添加头像列表[i].GetComponent<HeadItem>().虚号)
			{
				RightController._instance.添加好友列表.Remove(信息);
				添加头像列表.Remove(添加头像列表[i]);
				UnityEngine.Object.Destroy(添加头像列表[i].gameObject);
			}
		}
	}

	public void 再添加好友()
	{
		for (int i = 0; i < Grid.transform.childCount; i++)
		{
			UnityEngine.Object.Destroy(Grid.transform.GetChild(i).gameObject);
			好友信息列表.Clear();
		}
		for (int j = 0; j < FriendData._intance.FriData.Count; j++)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(好友信息项, Grid.transform.position, Quaternion.identity);
			gameObject.transform.SetParent(Grid.transform);
			gameObject.transform.localScale = Vector3.one;
			gameObject.transform.localRotation = Quaternion.identity;
			gameObject.GetComponent<PersonItem>().SetMessage(FriendData._intance.FriData[j]);
			好友信息列表.Add(gameObject);
		}
		for (int k = 0; k < hGrid.transform.childCount; k++)
		{
			UnityEngine.Object.Destroy(hGrid.transform.GetChild(k).gameObject);
		}
		foreach (Person item in RightController._instance.添加好友列表)
		{
			GameObject gameObject2 = UnityEngine.Object.Instantiate(头像项, hGrid.transform.position, Quaternion.identity);
			gameObject2.transform.SetParent(hGrid.transform);
			gameObject2.transform.localScale = Vector3.one;
			gameObject2.transform.localRotation = Quaternion.identity;
			gameObject2.GetComponent<HeadItem>().设置头像(item);
			添加头像列表.Add(gameObject2);
		}
		foreach (Person item2 in RightController._instance.添加好友列表)
		{
			foreach (GameObject item3 in 好友信息列表)
			{
				if (item3.GetComponent<PersonItem>().虚号 == item2.Xuwo_id)
				{
					item3.GetComponent<PersonItem>().isClick = true;
					item3.GetComponentInChildren<Toggle>().isOn = true;
				}
			}
		}
	}
}
public class FriendUI : MonoBehaviour
{
	public static FriendUI _instance;

	public GameObject grid;

	public GameObject 好友;

	public List<GameObject> friendList = new List<GameObject>();

	private void Awake()
	{
		_instance = this;
	}

	public void Init()
	{
		for (int i = 1; i < grid.transform.childCount; i++)
		{
			UnityEngine.Object.Destroy(grid.transform.GetChild(i).gameObject);
			friendList.Clear();
		}
		foreach (Person friDatum in FriendData._intance.FriData)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(好友, grid.transform.position, Quaternion.identity);
			gameObject.transform.SetParent(grid.transform);
			gameObject.transform.localScale = Vector3.one;
			gameObject.transform.localRotation = Quaternion.identity;
			gameObject.GetComponent<FriendItem>().SetId(friDatum);
			friendList.Add(gameObject);
		}
	}
}
public class GroupItem : MonoBehaviour
{
	public string groupId;

	public Text groupName;

	public Image head;

	public Group g;

	private void Start()
	{
	}

	public void SetId(string id)
	{
		groupId = id;
		g = Groups._instance.getGroupById(id);
		groupName.text = g.name.Substring(1, g.name.Length - 2);
	}
}
public class GroupMessage : MonoBehaviour
{
	public static GroupMessage _instance;

	public new Text name;

	public GameObject 头像;

	public GameObject 新添加;

	public GameObject rGrid;

	private GameObject 添加按钮;

	private bool isTip = true;

	public Text 提示Text;

	private void Awake()
	{
		_instance = this;
	}

	public void 初始化()
	{
		for (int i = 0; i < rGrid.transform.childCount; i++)
		{
			UnityEngine.Object.Destroy(rGrid.transform.GetChild(i).gameObject);
			添加按钮 = null;
		}
		foreach (Person item in RightController._instance.currentGroup.friend)
		{
			GameObject obj = UnityEngine.Object.Instantiate(头像, rGrid.transform.position, Quaternion.identity);
			obj.transform.SetParent(rGrid.transform);
			obj.transform.localRotation = Quaternion.identity;
			obj.transform.localScale = Vector3.one;
			obj.GetComponent<HeadItem>().设置头像(item);
			if (!RightController._instance.添加好友列表.Contains(item))
			{
				RightController._instance.添加好友列表.Add(item);
			}
		}
		if (!添加按钮)
		{
			添加按钮 = UnityEngine.Object.Instantiate(新添加, rGrid.transform.position, Quaternion.identity);
			添加按钮.transform.SetParent(rGrid.transform);
			添加按钮.transform.localRotation = Quaternion.identity;
			添加按钮.transform.localScale = Vector3.one;
		}
		RightController._instance.添加好友列表.Clear();
	}

	public void 信息提醒()
	{
		if (isTip)
		{
			isTip = false;
			GetComponentInChildren<Toggle>().isOn = false;
			提示Text.text = "关闭";
		}
		else
		{
			isTip = true;
			GetComponentInChildren<Toggle>().isOn = true;
			提示Text.text = "开启";
		}
	}

	public void SetGroupName(string value)
	{
		name.text = value;
	}
}
public class Groups : MonoBehaviour
{
	public static Groups _instance;

	public Dictionary<string, Group> groupData = new Dictionary<string, Group>();

	private void Awake()
	{
		_instance = this;
	}

	public bool IsHaveGroup()
	{
		bool result = false;
		if (MySocket.GroupMessage.Count > 0)
		{
			result = true;
		}
		return result;
	}

	public void Init()
	{
		groupData.Clear();
		if (!IsHaveGroup())
		{
			return;
		}
		foreach (string key in MySocket.GroupMessage.Keys)
		{
			Group group = new Group();
			group.id = MySocket.GroupMessage[key]["群信息"][0]["weiwo_qun_id"].ToString();
			group.manageId = MySocket.GroupMessage[key]["群信息"][0]["weiwo_qun_manage"].ToString();
			group.name = MySocket.GroupMessage[key]["群信息"][0]["weiwo_qun_name"].ToString();
			string text = MySocket.GroupMessage[key]["群信息"][0]["weiwo_qun_chengyuan"].ToString();
			string[] array = text.Substring(1, text.Length - 2).Split(',');
			List<Person> list = new List<Person>();
			string[] array2 = array;
			foreach (string xuwo_id in array2)
			{
				Person listData = FriendData._intance.GetListData(xuwo_id);
				list.Add(listData);
			}
			group.friend = list;
			groupData.Add(group.id, group);
		}
	}

	public Group getGroupById(string id)
	{
		Group value = null;
		groupData.TryGetValue(id, out value);
		return value;
	}
}
public class Group
{
	public string id;

	public string head;

	public string manageId;

	public string name;

	public List<Person> friend;

	public bool isTip;
}
public class GroupUI : MonoBehaviour
{
	public static GroupUI _instance;

	public GameObject grid;

	public GameObject groupItem;

	private void Awake()
	{
		_instance = this;
	}

	public void InitGroup()
	{
		if (grid.transform.childCount > 0)
		{
			for (int i = 1; i < grid.transform.childCount; i++)
			{
				UnityEngine.Object.Destroy(grid.transform.GetChild(i).gameObject);
			}
		}
		if (Groups._instance.groupData.Count <= 0)
		{
			return;
		}
		foreach (KeyValuePair<string, Group> groupDatum in Groups._instance.groupData)
		{
			GameObject obj = UnityEngine.Object.Instantiate(groupItem, grid.transform.position, Quaternion.identity);
			obj.transform.SetParent(grid.transform);
			obj.transform.localScale = Vector3.one;
			obj.transform.localRotation = Quaternion.identity;
			obj.GetComponent<GroupItem>().SetId(groupDatum.Key);
		}
	}
}
public class HeadItem : MonoBehaviour
{
	public string 虚号;

	public Image 头像;

	public Person p;

	private void Start()
	{
	}

	public void 设置头像(Person p)
	{
		this.p = p;
		虚号 = p.Xuwo_id;
		StartCoroutine(下载图片(p.Xuwo_headimgurl));
	}

	private IEnumerator 下载图片(string 图片网址)
	{
		string url = 图片网址.Substring(1, 图片网址.Length - 2);
		WWW date = new WWW(url);
		yield return date;
		Texture2D texture = date.texture;
		头像.GetComponent<Image>().overrideSprite = Sprite.Create(texture, new Rect(0f, 0f, texture.width, texture.height), new Vector2(0f, 0f));
	}
}
public class MessageClass : MonoBehaviour
{
	public static MessageClass _instance;

	public List<Message> messageList = new List<Message>();

	public List<Message> tipsList = new List<Message>();

	public List<PersonMessage> personMessageList = new List<PersonMessage>();

	public List<PersonMessage> persontipsList = new List<PersonMessage>();

	private void Awake()
	{
		_instance = this;
	}

	public void 存信息(JSONObject obj)
	{
		Message message = new Message();
		string text = obj["id"].ToString();
		string text2 = obj["群id"].ToString();
		message.个人虚号 = text.Substring(1, text.Length - 2);
		message.群号 = text2.Substring(1, text2.Length - 2);
		message.名字 = obj["名字"].ToString();
		string text3 = obj["信息"].ToString();
		message.消息 = text3.Substring(1, text3.Length - 2);
		messageList.Add(message);
	}

	public void 存个人信息(JSONObject obj)
	{
		PersonMessage personMessage = new PersonMessage();
		string 个人虚号 = obj["id"].ToString();
		string text = obj["data"].ToString();
		string 消息 = text.Substring(1, text.Length - 2);
		personMessage.个人虚号 = 个人虚号;
		personMessage.消息 = 消息;
		personMessageList.Add(personMessage);
	}
}
public class Message
{
	public string 个人虚号;

	public string 群号;

	public string 名字;

	public string 消息;
}
public class PersonMessage
{
	public string 个人虚号;

	public string 消息;
}
public class MessageItem : MonoBehaviour
{
	public string 虚号;

	public Image 头像;

	public Text messageText;

	public Text timeText;

	private void Start()
	{
	}

	private void Update()
	{
	}

	public void SetProprety(string id, string message)
	{
		虚号 = id;
		messageText.text = message;
		GetNetTime._instance.GetTimer();
		MySocket.查询虚我号信息(id);
		Invoke("更新显示", 1f);
		timeText.text = GetNetTime._instance.s;
		base.transform.GetComponent<RectTransform>().sizeDelta = new Vector2(base.transform.GetComponent<RectTransform>().rect.width, base.transform.GetComponent<RectTransform>().rect.height + (float)base.transform.Find("MessageText").GetComponent<Text>().fontSize);
		if (base.transform.transform.childCount > 1)
		{
			Chat._instance.初始的高度 += base.transform.GetComponent<RectTransform>().rect.height + Chat._instance.间隔高度;
		}
		GetComponent<RectTransform>().transform.localPosition = new Vector3(0f, Chat._instance.初始的高度, 0f);
	}

	private IEnumerator 下载图片(string 图片网址)
	{
		string url = 图片网址.Substring(1, 图片网址.Length - 2);
		WWW date = new WWW(url);
		yield return date;
		Texture2D texture = date.texture;
		头像.GetComponent<Image>().overrideSprite = Sprite.Create(texture, new Rect(0f, 0f, texture.width, texture.height), new Vector2(0f, 0f));
	}

	private void 更新显示()
	{
		if (MySocket.查询的信息.Count <= 0)
		{
			return;
		}
		for (int i = 0; i < MySocket.查询的信息.Count; i++)
		{
			string text = MySocket.查询的信息[i]["信息"]["weiwo_id"].ToString();
			string 图片网址 = MySocket.查询的信息[i]["信息"]["weiwo_headimgurl"].ToString();
			StartCoroutine(下载图片(图片网址));
			if (虚号 == text)
			{
				MySocket.查询的信息.Remove(MySocket.查询的信息[i]);
			}
		}
	}
}
public class PersonItem : MonoBehaviour
{
	public string 虚号;

	public GameObject 头像;

	public Text 昵称;

	public Toggle toggle;

	public Person 信息;

	public bool isClick;

	private void Start()
	{
	}

	public void SetMessage(Person p)
	{
		信息 = p;
		虚号 = p.Xuwo_id;
		StartCoroutine(下载图片(p.Xuwo_headimgurl));
		昵称.text = p.Xuwo_nickname;
		GetComponentInChildren<Toggle>().isOn = false;
	}

	private IEnumerator 下载图片(string 图片网址)
	{
		string url = 图片网址.Substring(1, 图片网址.Length - 2);
		WWW date = new WWW(url);
		yield return date;
		Texture2D texture = date.texture;
		头像.GetComponent<Image>().overrideSprite = Sprite.Create(texture, new Rect(0f, 0f, texture.width, texture.height), new Vector2(0f, 0f));
	}
}
public class TipsItem : MonoBehaviour
{
	public string 群号;

	public Group g;

	private void Start()
	{
	}

	public void 设置小人信息(string id)
	{
		群号 = id;
		g = Groups._instance.getGroupById(id);
	}
}
public class MessageTips : MonoBehaviour
{
	public static MessageTips _instance;

	public GameObject 小人;

	public GameObject 小人1;

	public GameObject[] pos;

	public GameObject[] pos1;

	public List<GameObject> 小人提醒;

	public List<GameObject> 小人提醒1;

	private void Awake()
	{
		_instance = this;
	}

	public void 群信息提醒(string id)
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(小人, base.gameObject.transform.position, Quaternion.identity);
		if (小人提醒.Count > 0)
		{
			gameObject.transform.SetParent(pos[小人提醒.Count + 1].transform);
		}
		else
		{
			gameObject.transform.SetParent(pos[0].transform);
		}
		gameObject.transform.localPosition = pos[小人提醒.Count + 1].transform.position;
		gameObject.transform.localScale = Vector3.one;
		小人提醒.Add(gameObject);
		gameObject.GetComponent<TipsItem>().设置小人信息(id);
	}

	public void 个人信息提醒(string id)
	{
		MonoBehaviour.print("xc");
		GameObject gameObject = UnityEngine.Object.Instantiate(小人1, base.gameObject.transform.position, Quaternion.identity);
		if (小人提醒1.Count > 0)
		{
			gameObject.transform.SetParent(pos1[小人提醒1.Count + 1].transform);
		}
		else
		{
			gameObject.transform.SetParent(pos1[0].transform);
		}
		gameObject.transform.localPosition = pos1[小人提醒.Count + 1].transform.position;
		gameObject.transform.localScale = Vector3.one;
		小人提醒1.Add(gameObject);
		gameObject.transform.name = id;
	}

	public void 点击小人(GameObject go)
	{
		int num = 小人提醒.IndexOf(go);
		if (num != -1)
		{
			小人提醒.Remove(go);
			UnityEngine.Object.Destroy(go);
			for (int i = num; i < 小人提醒.Count; i++)
			{
				小人提醒[i].transform.position = _instance.pos[i].transform.position;
			}
		}
	}

	public void 点击(GameObject go)
	{
		int num = 小人提醒1.IndexOf(go);
		if (num != -1)
		{
			小人提醒1.Remove(go);
			UnityEngine.Object.Destroy(go);
			for (int i = num; i < 小人提醒1.Count; i++)
			{
				小人提醒1[i].transform.position = _instance.pos[i].transform.position;
			}
		}
	}
}
public class AddFriendUI : MonoBehaviour
{
	public static AddFriendUI _instance;

	public GameObject grid;

	public GameObject addFriendItem;

	private void Awake()
	{
		_instance = this;
	}

	public void 初始化()
	{
		for (int i = 0; i < MySocket.申请好友列表.Count; i++)
		{
			MySocket.查询虚我号信息(MySocket.申请好友列表[i]);
			GameObject obj = UnityEngine.Object.Instantiate(addFriendItem, grid.transform.position, Quaternion.identity);
			obj.transform.SetParent(grid.transform);
			obj.transform.localScale = Vector3.one;
			obj.transform.localRotation = Quaternion.identity;
			obj.GetComponent<AddFrienfItem>().初始化(MySocket.申请好友列表[i]);
		}
	}
}
public class AddFrienfItem : MonoBehaviour
{
	public string 虚号;

	public Image 头像;

	public Text 名字;

	public void 初始化(string id)
	{
		虚号 = id;
		Invoke("更新显示", 1f);
	}

	private void 更新显示()
	{
		if (MySocket.查询的信息.Count <= 0)
		{
			return;
		}
		for (int i = 0; i < MySocket.查询的信息.Count; i++)
		{
			string text = MySocket.查询的信息[i]["信息"]["weiwo_id"].ToString();
			if (虚号 == text)
			{
				string text2 = MySocket.查询的信息[i]["信息"]["weiwo_nickname"].ToString();
				string text3 = text2.Substring(1, text2.Length - 2);
				string text4 = MySocket.查询的信息[i]["信息"]["weiwo_headimgurl"].ToString();
				string url = text4.Substring(1, text4.Length - 2);
				名字.text = text3;
				StartCoroutine(显示头像(url));
				MySocket.查询的信息.Remove(MySocket.查询的信息[i]);
			}
		}
	}

	private IEnumerator 显示头像(string url)
	{
		WWW www = new WWW(url);
		yield return www;
		Texture2D texture = www.texture;
		头像.overrideSprite = Sprite.Create(texture, new Rect(0f, 0f, texture.width, texture.height), new Vector2(0f, 0f));
	}
}
public class FriendAcceptItem : MonoBehaviour
{
	public string 虚号;

	public Person p;

	public Text 描述;

	private void Start()
	{
	}

	public void 初始化(string id)
	{
		虚号 = id;
		MySocket.查询虚我号信息(虚号);
		Invoke("更新显示", 1f);
	}

	private void 更新显示()
	{
		if (MySocket.查询的信息.Count <= 0)
		{
			return;
		}
		for (int i = 0; i < MySocket.查询的信息.Count; i++)
		{
			string text = MySocket.查询的信息[i]["信息"]["weiwo_id"].ToString();
			string nickname = MySocket.查询的信息[i]["信息"]["weiwo_nickname"].ToString();
			string headimg = MySocket.查询的信息[i]["信息"]["weiwo_headimgurl"].ToString();
			p = new Person(text, nickname, null, null, headimg);
			if (虚号 == text)
			{
				string text2 = MySocket.查询的信息[i]["信息"]["weiwo_nickname"].ToString();
				string text3 = text2.Substring(1, text2.Length - 2);
				描述.text = "您已成功添加" + text3 + "为好友跟对方打声招呼吧";
				MySocket.查询的信息.Remove(MySocket.查询的信息[i]);
				FriendData._intance.FriData.Add(p);
			}
		}
	}
}
public class FriendItem : MonoBehaviour
{
	public string 虚号;

	public Person p;

	public Image 头像;

	public Text 名字;

	public GameObject btn;

	private void Start()
	{
		btn.SetActive(value: false);
	}

	public void SetId(Person p)
	{
		this.p = p;
		虚号 = p.Xuwo_id;
		下载图片(p.Xuwo_headimgurl);
		名字.text = p.Xuwo_nickname;
	}

	private void 下载图片(string 图片网址)
	{
		WWW wWW = new WWW(图片网址.Substring(1, 图片网址.Length - 2));
		if (wWW.isDone)
		{
			Texture2D texture = wWW.texture;
			头像.GetComponent<Image>().overrideSprite = Sprite.Create(texture, new Rect(0f, 0f, texture.width, texture.height), new Vector2(0f, 0f));
		}
	}

	public void 点击好友()
	{
		btn.SetActive(value: true);
	}

	public void 点击其他好友()
	{
		btn.SetActive(value: false);
	}
}
public class PrivateChatItem : MonoBehaviour
{
	public static PrivateChatItem _instance;

	public string 虚号;

	public GameObject grid;

	public GameObject 自己的文本;

	public GameObject 其他人的文本;

	public Text 输入文本;

	public GameObject 文本;

	public GameObject 语音;

	public Text 提示;

	private string message;

	public GameObject cube;

	public float 初始的高度;

	public float 间隔高度;

	public float dis;

	private void Awake()
	{
		_instance = this;
		初始的高度 = -82f;
	}

	private void Start()
	{
		ShowText();
		dis = 输入文本.preferredHeight;
	}

	public void ShowText()
	{
		文本.SetActive(value: true);
		语音.SetActive(value: false);
	}

	public void ShowVoice()
	{
		文本.SetActive(value: false);
		语音.SetActive(value: true);
		提示.text = "按住扳机说话，快速摇晃手柄取消";
	}

	public void 输入框()
	{
		输入文本.text = "";
		井模块._instance.输入法显示();
		井模块._instance.输入法.GetComponent<Load>().字 = 输入文本;
		Var.字 = 输入文本;
		输入文本.transform.parent.GetComponent<RectTransform>().sizeDelta = new Vector2(40.8f, 6f);
		输入文本.transform.parent.GetComponent<RectTransform>().localPosition = new Vector3(0.4f, 2.5f, 0f);
		输入文本.transform.parent.transform.localScale = Vector3.one;
	}

	private void Update()
	{
		if (输入文本.GetComponent<RectTransform>().rect.height > dis)
		{
			输入文本.transform.parent.GetComponent<RectTransform>().sizeDelta = new Vector2(输入文本.transform.parent.GetComponent<RectTransform>().rect.width, 输入文本.preferredHeight);
			输入文本.transform.parent.GetComponent<RectTransform>().localPosition = new Vector3(输入文本.transform.parent.GetComponent<RectTransform>().localPosition.x, 输入文本.transform.parent.GetComponent<RectTransform>().localPosition.y - (float)输入文本.fontSize * 0.5f, 输入文本.transform.parent.GetComponent<RectTransform>().localPosition.z);
			输入文本.transform.parent.transform.localScale = Vector3.one;
			dis = 输入文本.preferredHeight;
		}
	}

	public void 设置虚号(Person p)
	{
		虚号 = p.Xuwo_id;
		StartCoroutine(下载图片(p.Xuwo_headimgurl));
	}

	public void 发自己文本信息(string message)
	{
		MySocket.发送私聊信息(虚号, message);
		GameObject gameObject = UnityEngine.Object.Instantiate(自己的文本, grid.transform.position, Quaternion.identity);
		gameObject.transform.SetParent(grid.transform);
		gameObject.transform.localScale = Vector3.one;
		gameObject.transform.localRotation = Quaternion.identity;
		gameObject.transform.Find("Text").GetComponent<Text>().text = message;
		gameObject.transform.GetComponent<RectTransform>().sizeDelta = new Vector2(gameObject.transform.GetComponent<RectTransform>().rect.width, gameObject.transform.GetComponent<RectTransform>().rect.height + (float)gameObject.transform.Find("Text").GetComponent<Text>().fontSize);
		if (grid.transform.childCount <= 1)
		{
			初始的高度 += 0f - grid.transform.position.y;
		}
		else
		{
			初始的高度 += gameObject.transform.GetComponent<RectTransform>().rect.height + 间隔高度;
		}
		gameObject.GetComponent<RectTransform>().transform.localPosition = new Vector3(0f, 初始的高度, 0f);
		GetNetTime._instance.GetTimer();
		gameObject.transform.Find("time").GetComponent<Text>().text = GetNetTime._instance.s;
	}

	public void 接受其他人文本信息()
	{
		if (MessageClass._instance.personMessageList.Count <= 0)
		{
			return;
		}
		for (int i = 0; i < MessageClass._instance.personMessageList.Count; i++)
		{
			if (虚号 == MessageClass._instance.personMessageList[i].个人虚号)
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(其他人的文本, grid.transform.position, Quaternion.identity);
				gameObject.transform.SetParent(grid.transform);
				gameObject.transform.localScale = Vector3.one;
				gameObject.transform.localRotation = Quaternion.identity;
				gameObject.transform.Find("Text").GetComponent<Text>().text = MessageClass._instance.personMessageList[i].消息;
				gameObject.transform.GetComponent<RectTransform>().sizeDelta = new Vector2(gameObject.transform.GetComponent<RectTransform>().rect.width, gameObject.transform.GetComponent<RectTransform>().rect.height + (float)gameObject.transform.Find("Text").GetComponent<Text>().fontSize);
				if (grid.transform.childCount <= 1)
				{
					初始的高度 += (0f - grid.transform.position.y) / 2f;
				}
				else
				{
					初始的高度 += gameObject.transform.GetComponent<RectTransform>().rect.height + 间隔高度;
				}
				gameObject.GetComponent<RectTransform>().transform.localPosition = new Vector3(0f, 初始的高度, 0f);
				GetNetTime._instance.GetTimer();
				gameObject.transform.Find("time").GetComponent<Text>().text = GetNetTime._instance.s;
			}
		}
		MessageClass._instance.personMessageList.Clear();
	}

	public void 发送信息()
	{
		message = 输入文本.text;
		if (message != "" && message != null)
		{
			发自己文本信息(message);
		}
		输入文本.transform.parent.GetComponent<RectTransform>().sizeDelta = new Vector2(40.8f, 6f);
		输入文本.transform.parent.GetComponent<RectTransform>().localPosition = new Vector3(0.4f, 2.5f, 0f);
		输入文本.transform.parent.transform.localScale = Vector3.one;
		输入文本.text = "";
	}

	private IEnumerator 下载图片(string 图片网址)
	{
		string url = 图片网址.Substring(1, 图片网址.Length - 2);
		WWW date = new WWW(url);
		yield return date;
		cube.GetComponent<Renderer>().material.mainTexture = date.texture;
	}
}
public class Ray_Controller : MonoBehaviour
{
	public static Ray_Controller _instance;

	private LineRenderer 射线;

	private Transform 开始位置;

	private RaycastHit 射线反馈;

	private Vector3 目标点;

	public GameObject 标志物;

	private GameObject 目标物;

	private LayerMask 层;

	private Vector3 oldPos;

	private Vector3 newPos;

	private GameObject obj;

	public GameObject 虚聊面板UI;

	public GameObject 好友UI;

	public GameObject chatUIParent;

	public GameObject chatUI;

	public bool isUseVoice;

	public List<GameObject> chatList = new List<GameObject>();

	public GameObject 新的朋友UI;

	public GameObject first;

	public GameObject second;

	public GameObject third;

	private string num;

	public Text numInput;

	public Text 查询的名字;

	public Image 查询的头像;

	public GameObject 数字输入法;

	public GameObject 添加好友UI;

	public GameObject 添加好友提醒;

	public GameObject friendAcceptItem;

	public GameObject 群聊UI;

	public GameObject 无群;

	public GameObject 有群;

	public Transform 聊天框位置;

	public Transform 好友UI位置;

	public Transform 群UI位置;

	public Transform 接受UI位置;

	private void Awake()
	{
		_instance = this;
	}

	private void Start()
	{
		层 = 512;
		射线 = GetComponent<LineRenderer>();
		oldPos = (newPos = base.transform.position);
		foreach (PersonMessage personMessage in MessageClass._instance.personMessageList)
		{
			MessageClass._instance.persontipsList.Add(personMessage);
		}
		foreach (PersonMessage persontips in MessageClass._instance.persontipsList)
		{
			if (!MySocket.idList.Contains(persontips.个人虚号))
			{
				MySocket.idList.Add(persontips.个人虚号);
				MessageTips._instance.个人信息提醒(persontips.个人虚号);
			}
		}
		if (MySocket.申请好友列表.Count > 0)
		{
			添加好友提醒.SetActive(value: true);
		}
		好友同意添加反馈();
		开始位置 = base.transform;
	}

	private void FixedUpdate()
	{
		UnityEngine.XR.InputDevice deviceAtXRNode = InputDevices.GetDeviceAtXRNode(XRNode.RightHand);
		deviceAtXRNode.TryGetFeatureValue(UnityEngine.XR.CommonUsages.triggerButton, out var value);
		if (Physics.Raycast(new Ray(开始位置.position, 开始位置.forward), out 射线反馈, 1200f, 层))
		{
			射线.enabled = true;
			目标点 = 射线反馈.point;
			if (!this.obj)
			{
				this.obj = UnityEngine.Object.Instantiate(标志物, 目标点, Quaternion.identity);
			}
			this.obj.transform.position = 目标点;
			射线.SetPosition(0, 开始位置.position);
			射线.SetPosition(1, 目标点);
			目标物 = 射线反馈.collider.gameObject;
			if (目标物.name == "NewFriendBtn" && 按下扳机(deviceAtXRNode))
			{
				新的朋友UI.SetActive(value: true);
				好友UI.SetActive(value: false);
				first.SetActive(value: true);
				second.SetActive(value: false);
			}
			else if (目标物.name == "GroupChatBtn" && 按下扳机(deviceAtXRNode))
			{
				虚聊面板UI.SetActive(value: false);
				群聊UI.SetActive(value: true);
				群聊UI.GetComponent<RectTransform>().localPosition = 群UI位置.position;
				群聊UI.GetComponent<RectTransform>().localRotation = 群UI位置.rotation;
				群聊UI.transform.Find("GroupUI").gameObject.SetActive(value: true);
				if (Groups._instance.IsHaveGroup())
				{
					无群.SetActive(value: false);
					有群.SetActive(value: true);
					Groups._instance.Init();
					GroupUI._instance.InitGroup();
				}
				else
				{
					无群.SetActive(value: true);
					有群.SetActive(value: false);
				}
			}
			else if (目标物.name == "FriendItem(Clone)" && 按下扳机(deviceAtXRNode))
			{
				FriendItem component = 目标物.GetComponent<FriendItem>();
				component.点击好友();
				foreach (GameObject friend in FriendUI._instance.friendList)
				{
					if (friend.GetComponent<FriendItem>().虚号 != component.虚号)
					{
						friend.GetComponent<FriendItem>().点击其他好友();
					}
				}
			}
			else if (目标物.name == "Chat" && 按下扳机(deviceAtXRNode))
			{
				bool flag = false;
				目标物.GetComponentInParent<FriendItem>().点击其他好友();
				if (chatList.Count > 0)
				{
					foreach (GameObject chat in chatList)
					{
						flag = ((目标物.GetComponentInParent<FriendItem>().虚号 == chat.GetComponent<PrivateChatItem>().虚号) ? true : false);
					}
				}
				else
				{
					flag = false;
				}
				if (!flag)
				{
					GameObject gameObject = UnityEngine.Object.Instantiate(chatUI, chatUIParent.transform.position, Quaternion.identity);
					gameObject.transform.SetParent(chatUIParent.transform);
					gameObject.transform.parent.parent.localPosition = 聊天框位置.position;
					gameObject.transform.parent.parent.localRotation = Quaternion.Euler(0f, 聊天框位置.rotation.y, 0f);
					gameObject.transform.localRotation = Quaternion.identity;
					gameObject.transform.localScale = Vector3.one;
					Person p = 目标物.GetComponentInParent<FriendItem>().p;
					gameObject.GetComponent<PrivateChatItem>().设置虚号(p);
					chatList.Add(gameObject);
				}
			}
			else if (目标物.name == "Delete" && 按下扳机(deviceAtXRNode))
			{
				MySocket.删除好友(目标物.GetComponentInParent<FriendItem>().虚号);
				FriendData._intance.FriData.Remove(目标物.GetComponentInParent<FriendItem>().p);
				UnityEngine.Object.Destroy(目标物.GetComponentInParent<FriendItem>().gameObject);
				FriendUI._instance.Init();
			}
			else if (目标物.name == "InputBtn" && 按下扳机(deviceAtXRNode))
			{
				目标物.GetComponentInParent<PrivateChatItem>().输入框();
				base.gameObject.transform.Find("Cube").gameObject.SetActive(value: true);
			}
			else if (目标物.name == "Voice" && 按下扳机(deviceAtXRNode))
			{
				isUseVoice = true;
				目标物.GetComponentInParent<PrivateChatItem>().ShowVoice();
			}
			else if (目标物.name == "Send" && 按下扳机(deviceAtXRNode))
			{
				目标物.GetComponentInParent<PrivateChatItem>().发送信息();
			}
			else if (目标物.name == "Close" && 按下扳机(deviceAtXRNode))
			{
				for (int i = 0; i < chatList.Count; i++)
				{
					if (chatList[i].GetComponent<PrivateChatItem>().虚号 == 目标物.GetComponentInParent<PrivateChatItem>().虚号)
					{
						chatList.Remove(chatList[i]);
						井模块._instance.输入法隐藏();
						UnityEngine.Object.Destroy(目标物.GetComponentInParent<PrivateChatItem>().gameObject);
					}
				}
			}
			else if (目标物.name == "Back" && 按下扳机(deviceAtXRNode))
			{
				好友UI.SetActive(value: true);
				新的朋友UI.SetActive(value: false);
				数字输入法.SetActive(value: false);
				first.SetActive(value: true);
				second.SetActive(value: false);
				third.SetActive(value: false);
			}
			else if (目标物.name == "NumChaXunBtn" && 按下扳机(deviceAtXRNode))
			{
				first.SetActive(value: false);
				second.SetActive(value: true);
				third.SetActive(value: false);
			}
			else if ((!(目标物.name == "DouYiDouBtn") || !按下扳机(deviceAtXRNode)) && (!(目标物.name == "User") || !按下扳机(deviceAtXRNode)))
			{
				if (目标物.name == "NumInput" && 按下扳机(deviceAtXRNode))
				{
					numInput.text = "";
					数字输入法.SetActive(value: true);
					num = numInput.text;
				}
				else if (目标物.name == "Ok" && 按下扳机(deviceAtXRNode))
				{
					first.SetActive(value: false);
					second.SetActive(value: false);
					third.SetActive(value: true);
					num = numInput.text;
					MySocket.查询虚我号信息(num);
					Invoke("显示查询信息", 1f);
				}
				else if (目标物.name == "Add" && 按下扳机(deviceAtXRNode))
				{
					MySocket.好友申请(num);
					好友UI.SetActive(value: true);
					新的朋友UI.SetActive(value: false);
					添加好友UI.SetActive(value: false);
				}
				else if (目标物.name == "Add1" && 按下扳机(deviceAtXRNode))
				{
					GameObject obj = 目标物.GetComponentInParent<AddFrienfItem>().gameObject;
					string 虚号 = obj.GetComponent<AddFrienfItem>().虚号;
					MySocket.好友同意(虚号, "true");
					MySocket.申请好友列表.Remove(虚号);
					UnityEngine.Object.Destroy(obj);
					AddFriendUI._instance.初始化();
				}
				else if (目标物.name == "Cancel" && 按下扳机(deviceAtXRNode))
				{
					GameObject obj2 = 目标物.GetComponentInParent<AddFrienfItem>().gameObject;
					string 虚号2 = obj2.GetComponent<AddFrienfItem>().虚号;
					MySocket.好友同意(虚号2, "false");
					MySocket.申请好友列表.Remove(虚号2);
					UnityEngine.Object.Destroy(obj2);
					AddFriendUI._instance.初始化();
				}
				else if (目标物.name == "Back1" && 按下扳机(deviceAtXRNode))
				{
					好友UI.SetActive(value: true);
					新的朋友UI.SetActive(value: false);
					添加好友UI.SetActive(value: false);
					FriendUI._instance.Init();
				}
				else if (目标物.name == "Chat1" && 按下扳机(deviceAtXRNode))
				{
					string 虚号3 = 目标物.GetComponentInParent<FriendAcceptItem>().虚号;
					GameObject gameObject2 = UnityEngine.Object.Instantiate(chatUI, chatUIParent.transform.position, Quaternion.identity);
					gameObject2.transform.SetParent(chatUIParent.transform);
					gameObject2.transform.parent.parent.localPosition = 聊天框位置.position;
					gameObject2.transform.parent.parent.localRotation = 聊天框位置.rotation;
					gameObject2.transform.localRotation = Quaternion.identity;
					gameObject2.transform.localScale = Vector3.one;
					Person listData = FriendData._intance.GetListData(虚号3);
					gameObject2.GetComponent<PrivateChatItem>().设置虚号(listData);
					chatList.Add(gameObject2);
					UnityEngine.Object.Destroy(目标物.GetComponentInParent<FriendAcceptItem>().gameObject);
				}
				else if (目标物.name == "Cancel1" && 按下扳机(deviceAtXRNode))
				{
					UnityEngine.Object.Destroy(目标物.GetComponentInParent<FriendAcceptItem>().gameObject);
				}
			}
			if (目标物.CompareTag("Chat"))
			{
				if (value)
				{
					目标物.transform.SetParent(base.transform);
					井模块._instance.输入法隐藏();
				}
				else
				{
					目标物.transform.SetParent(chatUIParent.transform);
				}
			}
		}
		else
		{
			射线.enabled = false;
			if ((bool)this.obj)
			{
				UnityEngine.Object.Destroy(this.obj.gameObject);
			}
		}
		if (isUseVoice && value)
		{
			目标物.GetComponentInParent<PrivateChatItem>().提示.text = "松开扳机结束语音";
			Vector3 value2 = default(Vector3);
			deviceAtXRNode.TryGetFeatureValue(UnityEngine.XR.CommonUsages.deviceVelocity, out value2);
			if (value2.magnitude > 2f)
			{
				目标物.GetComponentInParent<PrivateChatItem>().提示.text = "松开扳机结束语音";
				isUseVoice = false;
				目标物.GetComponentInParent<PrivateChatItem>().ShowText();
			}
		}
	}

	public bool 按下扳机(UnityEngine.XR.InputDevice device)
	{
		bool result = false;
		device.TryGetFeatureValue(UnityEngine.XR.CommonUsages.triggerButton, out var value);
		if (value)
		{
			result = true;
		}
		return result;
	}

	private void 手柄移动(Scrollbar bar)
	{
		newPos = base.transform.position;
		Vector3 vector = newPos - oldPos;
		if (Mathf.Abs(vector.y) > 0f)
		{
			bar.value += vector.y;
		}
	}

	public void 显示查询信息()
	{
		if (MySocket.查询的信息.Count <= 0)
		{
			return;
		}
		for (int i = 0; i < MySocket.查询的信息.Count; i++)
		{
			string text = MySocket.查询的信息[i]["信息"]["weiwo_id"].ToString();
			string text2 = MySocket.查询的信息[i]["信息"]["weiwo_nickname"].ToString();
			string text3 = text2.Substring(1, text2.Length - 2);
			string text4 = MySocket.查询的信息[i]["信息"]["weiwo_headimgurl"].ToString();
			string url = text4.Substring(1, text4.Length - 2);
			if (text == num)
			{
				查询的名字.text = text3;
				StartCoroutine(显示头像(url));
				数字输入法.SetActive(value: false);
				MySocket.查询的信息.Remove(MySocket.查询的信息[i]);
			}
		}
	}

	public void 好友同意添加反馈()
	{
		for (int i = 0; i < MySocket.申请好友成功反馈.Count; i++)
		{
			GameObject obj = UnityEngine.Object.Instantiate(friendAcceptItem, base.transform.position, Quaternion.identity);
			obj.transform.localPosition = 接受UI位置.position;
			obj.transform.localRotation = 接受UI位置.rotation;
			obj.transform.localScale = new Vector3(0.006179337f, 0.006179337f, 0.006179337f);
			obj.GetComponent<FriendAcceptItem>().初始化(MySocket.申请好友成功反馈[i]);
		}
	}

	private IEnumerator 显示头像(string url)
	{
		using UnityWebRequest getData = UnityWebRequestTexture.GetTexture(url);
		yield return getData.SendWebRequest();
		Texture2D content = DownloadHandlerTexture.GetContent(getData);
		查询的头像.overrideSprite = Sprite.Create(content, new Rect(0f, 0f, content.width, content.height), new Vector2(0f, 0f));
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.CompareTag("Num"))
		{
			if (numInput.text.Length < 5 && other.transform.name != "*" && int.Parse(other.transform.name) <= 9)
			{
				numInput.text += other.transform.name;
			}
			if (other.transform.name == "*" && numInput.text.Length > 0)
			{
				string text = numInput.text.Remove(numInput.text.Length - 1);
				numInput.text = null;
				numInput.text = text;
			}
		}
		else if (other.transform.name == "addFriendTip")
		{
			虚聊面板UI.SetActive(value: true);
			虚聊面板UI.GetComponent<RectTransform>().localPosition = 好友UI位置.position;
			虚聊面板UI.GetComponent<RectTransform>().localRotation = 好友UI位置.rotation;
			好友UI.SetActive(value: false);
			添加好友UI.SetActive(value: true);
			新的朋友UI.SetActive(value: false);
			AddFriendUI._instance.初始化();
			添加好友提醒.SetActive(value: false);
		}
		else
		{
			if (!other.transform.CompareTag("XiaoRen"))
			{
				return;
			}
			string text2 = other.transform.name;
			GameObject gameObject = UnityEngine.Object.Instantiate(chatUI, chatUIParent.transform.position, Quaternion.identity);
			gameObject.transform.SetParent(chatUIParent.transform);
			gameObject.transform.parent.parent.localPosition = 聊天框位置.position;
			gameObject.transform.parent.parent.localRotation = 聊天框位置.rotation;
			gameObject.transform.localRotation = Quaternion.identity;
			gameObject.transform.localScale = Vector3.one;
			Person listData = FriendData._intance.GetListData(text2);
			gameObject.GetComponent<PrivateChatItem>().设置虚号(listData);
			chatList.Add(gameObject);
			for (int i = 0; i < MySocket.idList.Count; i++)
			{
				if (MySocket.idList[i] == text2)
				{
					MySocket.idList.Remove(MySocket.idList[i]);
				}
			}
			gameObject.GetComponent<PrivateChatItem>().接受其他人文本信息();
			MessageTips._instance.点击(other.gameObject);
		}
	}

	public void 虚友显示()
	{
		虚聊面板UI.SetActive(value: true);
		虚聊面板UI.GetComponent<RectTransform>().localPosition = 好友UI位置.position;
		虚聊面板UI.GetComponent<RectTransform>().localRotation = new Quaternion(0f, 好友UI位置.localRotation.y, 0f, 好友UI位置.localRotation.w);
		float x = 虚聊面板UI.transform.localEulerAngles.x;
		float y = 虚聊面板UI.transform.localEulerAngles.y + 30f;
		float z = 虚聊面板UI.transform.localEulerAngles.z;
		虚聊面板UI.transform.localRotation = Quaternion.Euler(x, y, z);
		FriendUI._instance.Init();
	}

	public void 虚友隐藏()
	{
		虚聊面板UI.SetActive(value: false);
		群聊UI.SetActive(value: false);
	}
}
public class RightController : MonoBehaviour
{
	public static RightController _instance;

	private UnityEngine.XR.InputDevice device;

	private LineRenderer 射线;

	public Transform 开始位置;

	private RaycastHit 射线反馈;

	private Vector3 目标点;

	public GameObject 标志物;

	private GameObject 目标物;

	private LayerMask 层;

	private GameObject obj;

	public GameObject 群UI;

	public GameObject 创UI;

	public Scrollbar 群Bar;

	public Scrollbar 好友Bar;

	public Scrollbar 添加头像Bar;

	private Vector3 oldPos;

	private Vector3 newPos;

	private bool isUseVoice;

	public List<Person> 添加好友列表 = new List<Person>();

	public Group currentGroup;

	private bool isAddAgain;

	private int l;

	public GameObject chat;

	public List<GameObject> chatList = new List<GameObject>();

	public GameObject chatUI;

	public bool 选择小人;

	public bool isCreate;

	public Transform 聊天框位置;

	private void Awake()
	{
		_instance = this;
	}

	private void Start()
	{
		层 = 512;
		射线 = GetComponent<LineRenderer>();
		射线.enabled = false;
		射线.SetWidth(0.02f, 0.02f);
		oldPos = (newPos = base.transform.position);
		Groups._instance.Init();
	}

	private void Update()
	{
		device = InputDevices.GetDeviceAtXRNode(XRNode.RightHand);
		device.TryGetFeatureValue(UnityEngine.XR.CommonUsages.triggerButton, out var value);
		if (Physics.Raycast(new Ray(开始位置.position, 开始位置.forward), out 射线反馈, 600f, 层))
		{
			射线.enabled = true;
			目标点 = 射线反馈.point;
			if (!obj)
			{
				obj = UnityEngine.Object.Instantiate(标志物, 目标点, Quaternion.identity);
			}
			obj.transform.position = 目标点;
			射线.SetPosition(0, 开始位置.position);
			射线.SetPosition(1, 目标点);
			目标物 = 射线反馈.collider.gameObject;
			if (目标物.name == "BackBtn1" && 按下扳机())
			{
				群UI.SetActive(value: false);
			}
			else if (目标物.name == "GroupItem(Clone)" && 按下扳机())
			{
				string groupId = 目标物.GetComponent<GroupItem>().groupId;
				currentGroup = Groups._instance.getGroupById(groupId);
				群UI.SetActive(value: false);
				bool flag = false;
				if (chatList.Count > 0)
				{
					foreach (GameObject chat in chatList)
					{
						flag = ((chat.GetComponent<Chat>().群号 == groupId) ? true : false);
					}
				}
				else
				{
					flag = false;
				}
				if (!flag)
				{
					CreateGroupChat();
				}
			}
			else if (目标物.name == "AddBtn" && 按下扳机())
			{
				群UI.SetActive(value: false);
				创UI.SetActive(value: true);
				CreateGroups._instance.初始化();
			}
			else if (目标物.name == "BackBtn2" && 按下扳机())
			{
				群UI.SetActive(value: true);
				创UI.SetActive(value: false);
			}
			else if (目标物.name == "PersonItem(Clone)" && 按下扳机())
			{
				Toggle component = 目标物.transform.Find("Toggle").GetComponent<Toggle>();
				if (!component.isOn)
				{
					component.isOn = true;
					CreateGroups._instance.添加好友(目标物);
				}
				else
				{
					component.isOn = false;
					CreateGroups._instance.取消好友(目标物);
				}
			}
			else if (目标物.name == "OKBtn" && 按下扳机())
			{
				创UI.SetActive(value: false);
				Create();
				GameObject gameObject = UnityEngine.Object.Instantiate(chatUI, this.chat.transform.position, Quaternion.identity);
				gameObject.transform.SetParent(this.chat.transform);
				gameObject.transform.parent.parent.localPosition = 聊天框位置.position;
				gameObject.transform.parent.parent.localRotation = 聊天框位置.rotation;
				gameObject.transform.localRotation = Quaternion.identity;
				gameObject.transform.localScale = Vector3.one;
				chatList.Add(gameObject);
				gameObject.GetComponent<Chat>().SetName(currentGroup.name);
				gameObject.GetComponent<Chat>().SetGroupId(currentGroup.id);
			}
			else if (目标物.name == "Name1" && 按下扳机())
			{
				目标物.GetComponentInParent<Chat>().关闭群聊面板();
			}
			else if (目标物.name == "CloseBtn1" && 按下扳机())
			{
				群UI.SetActive(value: true);
				for (int i = 0; i < chatList.Count; i++)
				{
					if (chatList[i].GetComponentInParent<Chat>().群号 == currentGroup.id)
					{
						chatList.Remove(chatList[i]);
						UnityEngine.Object.Destroy(目标物.GetComponentInParent<Chat>().gameObject);
						井模块._instance.输入法隐藏();
					}
				}
				GroupUI._instance.InitGroup();
			}
			else if (目标物.name == "VoiceBtn" && 按下扳机())
			{
				目标物.GetComponentInParent<Chat>().ShowVoice();
				isUseVoice = true;
			}
			else if (目标物.name == "SendBtn" && 按下扳机())
			{
				目标物.GetComponentInParent<Chat>().发送信息();
			}
			else if (目标物.name == "MessageText" && 按下扳机())
			{
				目标物.GetComponentInParent<Chat>().输入框();
				base.gameObject.transform.Find("Cube").gameObject.SetActive(value: true);
			}
			else if (目标物.name == "BackBtn3" && 按下扳机())
			{
				目标物.GetComponentInParent<Chat>().群聊信息返回面板();
			}
			else if (目标物.name == "NewItem(Clone)" && 按下扳机())
			{
				创UI.SetActive(value: true);
				CreateGroups._instance.再添加好友();
				isAddAgain = true;
				for (int j = 0; j < chatList.Count; j++)
				{
					if (chatList[j].GetComponentInParent<Chat>().群号 == currentGroup.id)
					{
						chatList.Remove(chatList[j]);
						UnityEngine.Object.Destroy(目标物.GetComponentInParent<Chat>().gameObject);
					}
				}
			}
			else if (目标物.name == "Name2" && 按下扳机())
			{
				目标物.GetComponentInParent<Chat>().改群名();
			}
			else if (目标物.name == "Toggle" && 按下扳机())
			{
				目标物.GetComponentInParent<Chat>().关闭提示();
			}
			else if (目标物.name == "QuitBtn" && 按下扳机())
			{
				目标物.GetComponentInParent<Chat>().退群面板();
			}
			else if (目标物.name == "BackBtn4" && 按下扳机())
			{
				目标物.GetComponentInParent<Chat>().群名修改面板返回();
			}
			else if (目标物.name == "Name3" && 按下扳机())
			{
				目标物.GetComponentInParent<Chat>().修改群名();
				base.gameObject.transform.Find("Cube").gameObject.SetActive(value: true);
			}
			else if (目标物.name == "BackBtn5" && 按下扳机())
			{
				string text = 目标物.transform.parent.Find("Name3").GetComponent<Text>().text;
				if (text != null)
				{
					MySocket.修改群名(currentGroup.id, text);
				}
				目标物.GetComponentInParent<Chat>().退群返回();
			}
			else if (目标物.name == "OKBtn1" && 按下扳机())
			{
				群UI.SetActive(value: true);
				MySocket.删除群(_instance.currentGroup.id);
				for (int k = 0; k < chatList.Count; k++)
				{
					if (chatList[k].GetComponentInParent<Chat>().群号 == currentGroup.id)
					{
						Groups._instance.groupData.Remove(currentGroup.id);
						chatList.Remove(chatList[k]);
						UnityEngine.Object.Destroy(目标物.GetComponentInParent<Chat>().gameObject);
						井模块._instance.输入法隐藏();
					}
				}
				GroupUI._instance.InitGroup();
			}
			else if (目标物.name == "QuitBtn" && 按下扳机())
			{
				群UI.SetActive(value: true);
				for (int l = 0; l < chatList.Count; l++)
				{
					if (chatList[l].GetComponentInParent<Chat>().群号 == currentGroup.id)
					{
						chatList.Remove(chatList[l]);
						UnityEngine.Object.Destroy(目标物.GetComponentInParent<Chat>().gameObject);
						井模块._instance.输入法隐藏();
					}
				}
				GroupUI._instance.InitGroup();
			}
			else if (目标物.CompareTag("ChatItem") && 按下扳机())
			{
				if (currentGroup != null && !(目标物.GetComponent<Chat>().群号 == currentGroup.id))
				{
					目标物.transform.SetAsFirstSibling();
					currentGroup = 目标物.GetComponent<Chat>().g;
				}
			}
			else if (选择小人)
			{
				选择小人 = false;
			}
			if (目标物.name == "Scrollbar" && value)
			{
				手柄移动(群Bar);
			}
			if (目标物.name == "Scrollbar1")
			{
				if (value)
				{
					手柄移动(好友Bar);
				}
			}
			else if (目标物.name == "Scrollbar2")
			{
				if (value)
				{
					手柄移动(添加头像Bar);
				}
			}
			else if (目标物.name == "Scrollbar3")
			{
				if (value)
				{
					手柄移动(目标物.GetComponentInParent<Chat>().信息Bar);
				}
			}
			else if (目标物.name == "Scrollbar4" && value)
			{
				手柄移动(目标物.GetComponentInParent<Chat>().头像Bar);
			}
			if (isUseVoice)
			{
				if (value)
				{
					目标物.GetComponentInParent<Chat>().提示.text = "松开扳机结束语音";
					Vector3 value2 = default(Vector3);
					device.TryGetFeatureValue(UnityEngine.XR.CommonUsages.deviceVelocity, out value2);
					if (value2.magnitude > 2f)
					{
						目标物.GetComponentInParent<Chat>().提示.text = "松开扳机结束语音";
						isUseVoice = false;
						目标物.GetComponentInParent<Chat>().ShowText();
					}
				}
			}
			else if (目标物.CompareTag("ChatItem"))
			{
				if (value)
				{
					目标物.transform.SetParent(base.transform);
					井模块._instance.输入法隐藏();
				}
				else
				{
					目标物.transform.SetParent(this.chat.transform);
				}
			}
		}
		else
		{
			射线.enabled = false;
			if ((bool)obj)
			{
				UnityEngine.Object.Destroy(obj.gameObject);
			}
		}
		if (value)
		{
			if (isUseVoice)
			{
				isUseVoice = false;
			}
			oldPos = base.transform.position;
		}
	}

	public bool 按下扳机()
	{
		bool result = false;
		device.TryGetFeatureValue(UnityEngine.XR.CommonUsages.triggerButton, out var value);
		if (value)
		{
			result = true;
		}
		return result;
	}

	private void 手柄移动(Scrollbar bar)
	{
		newPos = base.transform.position;
		Vector3 vector = newPos - oldPos;
		if (Mathf.Abs(vector.y) > 0.0005f)
		{
			bar.value += vector.y * 100f;
		}
		newPos = (oldPos = base.transform.position);
	}

	public void Create()
	{
		if (!isAddAgain)
		{
			string n = FriendData._intance.自己.Xuwo_nickname + "创建的群";
			string text = "";
			for (int i = 0; i < 添加好友列表.Count; i++)
			{
				text = ((i >= 添加好友列表.Count - 1) ? (text + 添加好友列表[i].Xuwo_id) : (text + 添加好友列表[i].Xuwo_id + ","));
			}
			MySocket.设置新群信息(n, text);
			Group group = (currentGroup = new Group());
			currentGroup.id = (group.id = MySocket.新的群号);
			currentGroup.name = (group.name = n);
			currentGroup.manageId = (group.manageId = FriendData._intance.自己.Xuwo_id);
			currentGroup.friend = (group.friend = 添加好友列表);
			Groups._instance.groupData.Add(group.id, group);
			isCreate = true;
		}
		else
		{
			string text2 = "";
			for (int j = l; j < 添加好友列表.Count; j++)
			{
				text2 = ((j >= 添加好友列表.Count - 1) ? (text2 + 添加好友列表[j].Xuwo_id) : (text2 + 添加好友列表[j].Xuwo_id + ","));
			}
			MySocket.再添加好友(_instance.currentGroup.id, text2);
			isAddAgain = false;
		}
	}

	public void CreateGroupChat()
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(chatUI, chat.transform.position, Quaternion.identity);
		gameObject.transform.SetParent(chat.transform);
		gameObject.transform.parent.parent.localPosition = 聊天框位置.position;
		gameObject.transform.parent.parent.localRotation = 聊天框位置.rotation;
		gameObject.transform.localRotation = Quaternion.identity;
		gameObject.transform.localScale = Vector3.one;
		chatList.Add(gameObject);
		Chat component = gameObject.GetComponent<Chat>();
		component.SetName(currentGroup.name);
		component.SetGroupId(currentGroup.id);
		gameObject.GetComponent<Chat>().初始化();
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.transform.name == "小人(Clone)")
		{
			Groups._instance.Init();
			Group g = other.GetComponent<TipsItem>().g;
			currentGroup = g;
			选择小人 = true;
			MessageTips._instance.点击小人(other.gameObject);
			CreateGroupChat();
		}
	}
}
public class RightHand : MonoBehaviour
{
	public static RightHand _instance;

	private UnityEngine.XR.InputDevice device;

	private LineRenderer 射线;

	private Transform 开始位置;

	private RaycastHit 射线反馈;

	private Vector3 目标点;

	public GameObject 标志物;

	private GameObject 目标物;

	private LayerMask 层;

	private Vector3 oldPos;

	private Vector3 newPos;

	private GameObject obj;

	private string num;

	public Text numInput;

	public GameObject 数字输入法;

	public Text 查询的名字;

	public Image 查询的头像;

	public List<Person> 已选择好友 = new List<Person>();

	private void Awake()
	{
		_instance = this;
	}

	private void Start()
	{
		层 = 512;
		射线 = GetComponent<LineRenderer>();
		oldPos = (newPos = base.transform.position);
		开始位置 = base.transform;
	}

	private void Update()
	{
		device = InputDevices.GetDeviceAtXRNode(XRNode.RightHand);
		device.TryGetFeatureValue(UnityEngine.XR.CommonUsages.triggerButton, out var value);
		if (Physics.Raycast(new Ray(开始位置.position, 开始位置.forward), out 射线反馈, 1200f, 层))
		{
			射线.enabled = true;
			目标点 = 射线反馈.point;
			if (!obj)
			{
				obj = UnityEngine.Object.Instantiate(标志物, 目标点, Quaternion.identity);
			}
			obj.transform.position = 目标点;
			目标物 = 射线反馈.collider.gameObject;
			if (目标物.transform.name == "WorldBtn" && 按下扳机())
			{
				ChatController._instance.chatType = ChatType.World;
				ChatController._instance.UpdateShow();
			}
			else if (目标物.transform.name == "PrivateBtn" && 按下扳机())
			{
				ChatController._instance.chatType = ChatType.Private;
				FriendUI._instance.Init();
				ChatController._instance.UpdateShow();
			}
			else if (目标物.transform.name == "GroupBtn" && 按下扳机())
			{
				ChatController._instance.chatType = ChatType.Group;
				Groups._instance.Init();
				ChatController._instance.UpdateShow();
				GroupUI._instance.InitGroup();
			}
			else if (目标物.transform.name == "Text" && 按下扳机())
			{
				ChatController._instance.点击文本输入框();
			}
			else if (目标物.transform.name == "SendBtn" && 按下扳机())
			{
				ChatController._instance.发送信息();
			}
			else if (目标物.name == "FriendItem(Clone)" && 按下扳机())
			{
				FriendItem component = 目标物.GetComponent<FriendItem>();
				component.点击好友();
				foreach (GameObject friend in FriendUI._instance.friendList)
				{
					if (friend.GetComponent<FriendItem>().虚号 != component.虚号)
					{
						friend.GetComponent<FriendItem>().点击其他好友();
					}
				}
			}
			else if (目标物.name == "NewFriend" && 按下扳机())
			{
				ChatController._instance.findFriendUI.SetActive(value: true);
				ChatController._instance.privateUI.SetActive(value: false);
				ChatController._instance.findFriendUI.transform.Find("Find").gameObject.SetActive(value: true);
				ChatController._instance.findFriendUI.transform.Find("Get").gameObject.SetActive(value: false);
			}
			else if (目标物.name == "NumInput" && 按下扳机())
			{
				numInput.text = "";
				数字输入法.SetActive(value: true);
			}
			else if (目标物.name == "OkBtn" && 按下扳机())
			{
				if (numInput.text != null)
				{
					num = numInput.text;
				}
				ChatController._instance.findFriendUI.transform.Find("Find").gameObject.SetActive(value: false);
				ChatController._instance.findFriendUI.transform.Find("Get").gameObject.SetActive(value: true);
				MySocket.查询虚我号信息(num);
				Invoke("显示查询信息", 1f);
			}
			else if (目标物.name == "AddBtn" && 按下扳机())
			{
				MySocket.好友申请(num);
				ChatController._instance.findFriendUI.SetActive(value: false);
				ChatController._instance.privateUI.SetActive(value: true);
			}
			else if (目标物.name == "Chat" && 按下扳机())
			{
				ChatController._instance.currentID = 目标物.GetComponentInParent<FriendItem>().虚号;
				目标物.GetComponentInParent<FriendItem>().点击其他好友();
				ChatController._instance.worldUI.SetActive(value: true);
				ChatController._instance.privateUI.SetActive(value: false);
			}
			else if (目标物.name == "Delete" && 按下扳机())
			{
				MySocket.删除好友(目标物.GetComponentInParent<FriendItem>().虚号);
				FriendData._intance.FriData.Remove(目标物.GetComponentInParent<FriendItem>().p);
				UnityEngine.Object.Destroy(目标物.GetComponentInParent<FriendItem>().gameObject);
				FriendUI._instance.Init();
			}
			else if (目标物.name == "NewGroup" && 按下扳机())
			{
				ChatController._instance.CreateGroupUI.SetActive(value: true);
				ChatController._instance.groupUI.SetActive(value: false);
				CreateGroups._instance.初始化();
			}
			else if (目标物.name == "PersonItem(Clone)" && 按下扳机())
			{
				Toggle component2 = 目标物.transform.Find("Toggle").GetComponent<Toggle>();
				Person 信息 = 目标物.GetComponent<PersonItem>().信息;
				if (!component2.isOn)
				{
					component2.isOn = true;
					已选择好友.Add(信息);
				}
				else
				{
					已选择好友.Remove(信息);
					component2.isOn = false;
				}
			}
			else if (目标物.name == "CreateBtn" && 按下扳机())
			{
				CreateNewGroup();
				ChatController._instance.chatType = ChatType.Group;
				ChatController._instance.worldUI.SetActive(value: true);
				ChatController._instance.CreateGroupUI.SetActive(value: false);
			}
			else if (目标物.name == "CancelBtn" && 按下扳机())
			{
				ChatController._instance.CreateGroupUI.SetActive(value: false);
				ChatController._instance.groupUI.SetActive(value: true);
			}
			else if (目标物.name == "GroupItem(Clone)" && 按下扳机())
			{
				ChatController._instance.currentID = 目标物.GetComponent<GroupItem>().groupId;
				ChatController._instance.worldUI.SetActive(value: true);
				ChatController._instance.groupUI.SetActive(value: false);
			}
			if (目标物.transform.name == "Handle" && value)
			{
				手柄移动(目标物.GetComponentInParent<Scrollbar>());
			}
		}
		else
		{
			射线.enabled = false;
			if ((bool)obj)
			{
				UnityEngine.Object.Destroy(obj.gameObject);
			}
		}
		if (value)
		{
			oldPos = base.transform.position;
		}
	}

	public bool 按下扳机()
	{
		bool result = false;
		device.TryGetFeatureValue(UnityEngine.XR.CommonUsages.triggerButton, out var value);
		if (value)
		{
			result = true;
		}
		return result;
	}

	private void 手柄移动(Scrollbar bar)
	{
		newPos = base.transform.position;
		Vector3 vector = newPos - oldPos;
		if (Mathf.Abs(vector.y) > 0f)
		{
			bar.value += vector.y;
		}
	}

	public void 显示查询信息()
	{
		if (MySocket.查询的信息.Count <= 0)
		{
			return;
		}
		for (int i = 0; i < MySocket.查询的信息.Count; i++)
		{
			string text = MySocket.查询的信息[i]["信息"]["weiwo_id"].ToString();
			string text2 = MySocket.查询的信息[i]["信息"]["weiwo_nickname"].ToString();
			string text3 = text2.Substring(1, text2.Length - 2);
			string text4 = MySocket.查询的信息[i]["信息"]["weiwo_headimgurl"].ToString();
			string url = text4.Substring(1, text4.Length - 2);
			if (text == num)
			{
				查询的名字.text = text3;
				StartCoroutine(显示头像(url));
				数字输入法.SetActive(value: false);
				MySocket.查询的信息.Remove(MySocket.查询的信息[i]);
			}
		}
	}

	private IEnumerator 显示头像(string url)
	{
		WWW www = new WWW(url);
		yield return www;
		Texture2D texture = www.texture;
		查询的头像.overrideSprite = Sprite.Create(texture, new Rect(0f, 0f, texture.width, texture.height), new Vector2(0f, 0f));
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.CompareTag("Num"))
		{
			if (numInput.text.Length < 5 && other.transform.name != "*" && int.Parse(other.transform.name) <= 9)
			{
				numInput.text += other.transform.name;
			}
			if (other.transform.name == "*" && numInput.text.Length > 0)
			{
				string text = numInput.text.Remove(numInput.text.Length - 1);
				numInput.text = null;
				numInput.text = text;
			}
		}
		else if (other.transform.name == "addFriendTip")
		{
			ChatController._instance.点击聊天();
			AddFriendUI._instance.初始化();
			ChatController._instance.chatType = ChatType.Private;
		}
		else if (other.transform.CompareTag("XiaoRen"))
		{
			ChatController._instance.currentID = other.transform.name;
			ChatController._instance.点击聊天();
			ChatController._instance.chatType = ChatType.Private;
			for (int i = 0; i < MessageClass._instance.persontipsList.Count; i++)
			{
				ChatController._instance.实例化(ChatController._instance.currentID, MessageClass._instance.persontipsList[i].消息);
				MessageClass._instance.persontipsList.Remove(MessageClass._instance.persontipsList[i]);
			}
			for (int j = 0; j < MySocket.idList.Count; j++)
			{
				if (MySocket.idList[j] == ChatController._instance.currentID)
				{
					MySocket.idList.Remove(MySocket.idList[j]);
				}
			}
			MessageTips._instance.点击(other.gameObject);
		}
		else
		{
			if (!(other.transform.name == "小人(Clone)"))
			{
				return;
			}
			Groups._instance.Init();
			Group g = other.GetComponent<TipsItem>().g;
			ChatController._instance.currentID = g.id;
			ChatController._instance.点击聊天();
			ChatController._instance.chatType = ChatType.Group;
			MessageTips._instance.点击小人(other.gameObject);
			for (int k = 0; k < MessageClass._instance.tipsList.Count; k++)
			{
				ChatController._instance.实例化(ChatController._instance.currentID, MessageClass._instance.tipsList[k].消息);
				MessageClass._instance.tipsList.Remove(MessageClass._instance.tipsList[k]);
			}
			for (int l = 0; l < MySocket.idList.Count; l++)
			{
				if (MySocket.groupIdList[l] == ChatController._instance.currentID)
				{
					MySocket.groupIdList.Remove(MySocket.idList[l]);
				}
			}
		}
	}

	public void CreateNewGroup()
	{
		string n = FriendData._intance.自己.Xuwo_nickname + "创建的群";
		string text = "";
		for (int i = 0; i < 已选择好友.Count; i++)
		{
			text = ((i >= 已选择好友.Count - 1) ? (text + 已选择好友[i].Xuwo_id) : (text + 已选择好友[i].Xuwo_id + ","));
		}
		MySocket.设置新群信息(n, text);
	}

	public void UpdateNewGroup()
	{
		Group group = new Group();
		ChatController._instance.currentID = (group.id = MySocket.新的群号);
		group.name = base.name;
		group.manageId = FriendData._intance.自己.Xuwo_id;
		group.friend = 已选择好友;
		Groups._instance.groupData.Add(group.id, group);
	}
}
public class WorldItem : MonoBehaviour
{
	public Text nameText;

	public Text messageText;

	private string 虚号;

	private void Start()
	{
	}

	public void UpdateMessage(string id, string message)
	{
		虚号 = id;
		MySocket.查询虚我号信息(id);
		Invoke("更新显示", 1f);
		messageText.text = message;
	}

	private void 更新显示()
	{
		if (MySocket.查询的信息.Count <= 0)
		{
			return;
		}
		for (int i = 0; i < MySocket.查询的信息.Count; i++)
		{
			string text = MySocket.查询的信息[i]["信息"]["weiwo_id"].ToString();
			nameText.text = MySocket.查询的信息[i]["信息"]["weiwo_nickname"].ToString();
			if (虚号 == text)
			{
				MySocket.查询的信息.Remove(MySocket.查询的信息[i]);
			}
		}
	}
}
public class daimove : MonoBehaviour
{
	public Material M;

	private float m_du = 1f;

	public Texture2D tex;

	public Texture2D tex2;

	public Transform 作用物体;

	public Transform 人模;

	public Transform 太阳;

	public float 速度 = 40f;

	public Image 全局表情;

	public List<GameObject> 换东西 = new List<GameObject>();

	public GameObject 色板;

	public GameObject 颜板;

	private int 换几;

	private bool 是否旋转;

	private bool 是否行走;

	private bool 是否移动;

	private bool 是否上下;

	private bool 上移;

	private float 移动时间 = 1f;

	private Quaternion 目标角度;

	private float 默认角度;

	private float 自y度;

	private float 自x度;

	private float 自z度;

	private int count;

	private string 参参 = "1";

	private bool 是否世界;

	private Vector3 新位置;

	private bool 是否后退;

	private float 移动多少时间;

	private Vector3 旧位置;

	private float 移动米;

	private float 旋转速度 = 20f;

	public static Material 色材质;

	public static bool 是否开始选颜色 = false;

	public static bool 是否选好颜色 = true;

	public static TerrainData td;

	public static GameObject terrain00;

	private void 建地(string 参数 = "1")
	{
	}

	private void Start()
	{
		默认角度 = 72f;
		自y度 = 作用物体.transform.localEulerAngles.y;
		自x度 = 作用物体.transform.localEulerAngles.x;
		自z度 = 作用物体.transform.localEulerAngles.z;
		人模 = GameObject.Find("Main Camera").transform;
		if (换东西.Count == 0)
		{
			换东西 = GameObject.Find("Manager").GetComponent<daimove>().换东西;
		}
		if (太阳 == null)
		{
			太阳 = GameObject.Find("Manager").GetComponent<daimove>().太阳;
		}
		if (全局表情 == null)
		{
			全局表情 = GameObject.Find("Manager").GetComponent<daimove>().全局表情;
		}
		旧位置 = 作用物体.transform.position;
	}

	private void Update()
	{
		if (是否旋转)
		{
			if (!是否世界)
			{
				作用物体.transform.localRotation = Quaternion.Slerp(作用物体.transform.localRotation, 目标角度, Time.deltaTime * 旋转速度);
				自y度 = 作用物体.transform.localEulerAngles.y;
				自x度 = 作用物体.transform.localEulerAngles.x;
				自z度 = 作用物体.transform.localEulerAngles.z;
				if (Quaternion.Angle(作用物体.transform.localRotation, 目标角度) < 0.01f)
				{
					作用物体.transform.localRotation = 目标角度;
					是否旋转 = false;
					if (是否行走)
					{
						StartCoroutine(行走(参参));
						是否行走 = false;
					}
				}
			}
			else
			{
				作用物体.transform.rotation = Quaternion.Slerp(作用物体.transform.rotation, 目标角度, Time.deltaTime * 旋转速度);
				if (Quaternion.Angle(作用物体.transform.rotation, 目标角度) < 0.01f)
				{
					作用物体.transform.rotation = 目标角度;
					是否旋转 = false;
					是否世界 = false;
				}
			}
		}
		if (是否移动)
		{
			if (!是否后退)
			{
				作用物体.transform.Translate(-作用物体.transform.forward * Time.deltaTime * 速度 / 8f, Space.World);
			}
			else
			{
				作用物体.transform.Translate(作用物体.transform.forward * Time.deltaTime * 速度 / 8f, Space.World);
			}
			if (Vector3.Distance(作用物体.transform.position, 旧位置) >= 移动米)
			{
				移动时间 = 0f;
				是否移动 = false;
				是否后退 = false;
				旧位置 = 作用物体.transform.position;
			}
		}
		if (是否上下)
		{
			if (上移)
			{
				作用物体.transform.Translate(作用物体.transform.up * Time.deltaTime * 速度 / 8f, Space.World);
			}
			else
			{
				作用物体.transform.Translate(-作用物体.transform.up * Time.deltaTime * 速度 / 8f, Space.World);
			}
			if (Vector3.Distance(作用物体.transform.position, 旧位置) >= 移动米)
			{
				移动时间 = 0f;
				是否上下 = false;
				上移 = false;
				旧位置 = 作用物体.transform.position;
			}
		}
		if (是否开始选颜色 && 是否选好颜色)
		{
			if (色板.active)
			{
				色板.active = false;
			}
			else if (颜板.active)
			{
				颜板.active = false;
			}
			是否开始选颜色 = false;
		}
	}

	private void 重置旋转移动()
	{
		是否旋转 = false;
		是否移动 = false;
		移动时间 = 0f;
		是否上下 = false;
		上移 = false;
		if (速度 == 0f)
		{
			速度 = 40f;
		}
	}

	public IEnumerator 左(string 参数)
	{
		重置旋转移动();
		目标角度 = Quaternion.Euler(0f, 自y度 - 90f, 0f) * Quaternion.identity;
		if (参数 == "")
		{
			参数 = "1";
		}
		移动米 = float.Parse(参数);
		参参 = 参数;
		是否旋转 = true;
		是否移动 = true;
		yield return "左完";
	}

	public IEnumerator 后(string 参数)
	{
		if (参数 == "")
		{
			参数 = "1";
		}
		参参 = 参数;
		移动米 = float.Parse(参数);
		是否移动 = true;
		是否后退 = true;
		yield return "后完";
	}

	public IEnumerator 右(string 参数)
	{
		重置旋转移动();
		目标角度 = Quaternion.Euler(0f, 自y度 + 90f, 0f) * Quaternion.identity;
		if (参数 == "")
		{
			参数 = "1";
		}
		移动米 = float.Parse(参数);
		参参 = 参数;
		是否旋转 = true;
		移动多少时间 = float.Parse(参数) / (速度 / 8f);
		是否移动 = true;
		yield return "右完";
	}

	public IEnumerator 前(string 参数)
	{
		if (速度 == 0f)
		{
			速度 = 40f;
		}
		if (参数 == "")
		{
			参数 = "1";
		}
		移动米 = float.Parse(参数);
		移动时间 = 0f;
		是否移动 = true;
		是否上下 = false;
		上移 = false;
		yield return "前完";
	}

	public IEnumerator 行走(string 参数)
	{
		新位置 = new Vector3(作用物体.localPosition.x, 作用物体.localPosition.y, 作用物体.localPosition.z + float.Parse(参数));
		_ = Vector3.Distance(作用物体.localPosition, 新位置) / 速度;
		作用物体.gameObject.GetComponent<Rigidbody>().velocity = 作用物体.forward * 速度;
		作用物体.gameObject.GetComponent<Rigidbody>().velocity = 作用物体.forward * 0f;
		yield return "行走完";
	}

	public IEnumerator 上(string 参数)
	{
		if (速度 == 0f)
		{
			速度 = 40f;
		}
		if (参数 == "")
		{
			参数 = "0.1";
		}
		移动米 = float.Parse(参数);
		移动多少时间 = float.Parse(参数) / (速度 / 8f);
		移动时间 = 0f;
		是否移动 = false;
		是否上下 = true;
		上移 = true;
		yield return "上完";
	}

	public IEnumerator 下(string 参数)
	{
		if (速度 == 0f)
		{
			速度 = 40f;
		}
		if (参数 == "")
		{
			参数 = "0.1";
		}
		移动米 = float.Parse(参数);
		移动多少时间 = float.Parse(参数) / (速度 / 8f);
		移动时间 = 0f;
		是否移动 = false;
		是否上下 = true;
		上移 = false;
		yield return "下完";
	}

	public string 表(string 参数 = null)
	{
		表情(参数.Substring(1));
		return 参数 + "表完";
	}

	public string 表情(string 参数 = null)
	{
		DirectoryInfo directoryInfo = new DirectoryInfo(Environment.CurrentDirectory + "/Assets/Resources/Sprites");
		if (directoryInfo.Exists)
		{
			FileInfo[] files = directoryInfo.GetFiles();
			int num = 0;
			while (files != null && num < files.Length)
			{
				string text = files[num].Name.Substring(0, 1);
				if (text == 参数)
				{
					Sprite sprite = Resources.Load("Sprites/" + text, typeof(Sprite)) as Sprite;
					全局表情.sprite = sprite;
					break;
				}
				num++;
			}
		}
		return "表情完";
	}

	public string 笑(string 参数 = null)
	{
		string 参数2 = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		表情(参数2);
		return "笑完";
	}

	public string 哭(string 参数 = null)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		表情(text);
		return text + "完";
	}

	public string 苦(string 参数 = null)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		表情(text);
		return text + "完";
	}

	public string 萌(string 参数 = null)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		表情(text);
		return text + "完";
	}

	public string 逗(string 参数 = null)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		表情(text);
		return text + "完";
	}

	public string 哈(string 参数 = null)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		表情(text);
		return text + "完";
	}

	public string 羞(string 参数 = null)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		表情(text);
		return text + "完";
	}

	public string 吓(string 参数 = null)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		表情(text);
		return text + "完";
	}

	public string 怜(string 参数 = null)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		表情(text);
		return text + "完";
	}

	public string 惊(string 参数 = null)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		表情(text);
		return text + "完";
	}

	public string 酷(string 参数 = null)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		表情(text);
		return text + "完";
	}

	public string 吐(string 参数 = null)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		表情(text);
		return text + "完";
	}

	public string 傲(string 参数 = null)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		表情(text);
		return text + "完";
	}

	public string 困(string 参数 = null)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		表情(text);
		return text + "完";
	}

	public string 恐(string 参数 = null)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		表情(text);
		return text + "完";
	}

	public string 骂(string 参数 = null)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		表情(text);
		return text + "完";
	}

	public string 嘘(string 参数 = null)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		表情(text);
		return text + "完";
	}

	public string 晕(string 参数 = null)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		表情(text);
		return text + "完";
	}

	public string 衰(string 参数 = null)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		表情(text);
		return text + "完";
	}

	public string 糗(string 参数 = null)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		表情(text);
		return text + "完";
	}

	public string 坏(string 参数 = null)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		表情(text);
		return text + "完";
	}

	public string 奸(string 参数 = null)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		表情(text);
		return text + "完";
	}

	public string 哼(string 参数 = null)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		表情(text);
		return text + "完";
	}

	public string 鄙(string 参数 = null)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		表情(text);
		return text + "完";
	}

	public string 屈(string 参数 = null)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		表情(text);
		return text + "完";
	}

	public string 憨(string 参数 = null)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		表情(text);
		return text + "完";
	}

	public string 尴(string 参数 = null)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		表情(text);
		return text + "完";
	}

	public string 快(string 参数)
	{
		if (参数 == "")
		{
			参数 = "5";
		}
		float num = float.Parse(参数);
		if (速度 < 80f)
		{
			速度 += num;
		}
		if (换东西[换几].name == "扇" || 换东西[换几].name == "扇2")
		{
			换东西[换几].GetComponentInChildren<rotaself>().自转速度 = 换东西[换几].GetComponentInChildren<rotaself>().自转速度 + num;
		}
		MonoBehaviour.print("快……速度:" + 速度);
		return "完";
	}

	public string 速(string 参数)
	{
		if (参数 == "")
		{
			参数 = "40";
		}
		速度 = float.Parse(参数);
		if (换东西[换几].name == "扇" || 换东西[换几].name == "扇2")
		{
			换东西[换几].GetComponentInChildren<rotaself>().自转速度 = 速度;
		}
		MonoBehaviour.print("速度:" + 速度);
		return "完";
	}

	public string 呆(string 参数)
	{
		if (参数.Substring(0, 1) == "速")
		{
			呆速(参数.Substring(1));
		}
		return "完";
	}

	public string 呆速(string 参数)
	{
		if (参数 == "")
		{
			参数 = "40";
		}
		速度 = float.Parse(参数) / 10f;
		return "完";
	}

	public string 慢(string 参数)
	{
		if (参数 == "")
		{
			参数 = "5";
		}
		float num = float.Parse(参数);
		if (速度 > 0f && 速度 >= num)
		{
			速度 -= num;
		}
		if (换东西[换几].name == "扇" || 换东西[换几].name == "扇2")
		{
			if (换东西[换几].GetComponentInChildren<rotaself>().自转速度 > num)
			{
				换东西[换几].GetComponentInChildren<rotaself>().自转速度 = 换东西[换几].GetComponentInChildren<rotaself>().自转速度 - num;
			}
			else
			{
				换东西[换几].GetComponentInChildren<rotaself>().自转速度 = 0f;
			}
		}
		MonoBehaviour.print("慢……速度:" + 速度);
		return "完";
	}

	public string 停(string 参数)
	{
		速度 = 0f;
		if (换东西[换几].name == "扇" || 换东西[换几].name == "扇2")
		{
			换东西[换几].GetComponentInChildren<rotaself>().自转速度 = 0f;
		}
		return "完";
	}

	public string 开(string 参数 = null)
	{
		if (换东西[换几].name == "灯" || 换东西[换几].name == "USB")
		{
			作用物体.gameObject.GetComponentInChildren<Light>().enabled = true;
		}
		else if (换东西[换几].name == "扇" || 换东西[换几].name == "扇2")
		{
			换东西[换几].transform.GetChild(0).gameObject.GetComponent<rotaself>().是否自转 = true;
		}
		return "完";
	}

	public string 关(string 参数 = null)
	{
		if (换东西[换几].name == "灯" || 换东西[换几].name == "USB")
		{
			作用物体.gameObject.GetComponentInChildren<Light>().enabled = false;
		}
		else if (换东西[换几].name == "扇" || 换东西[换几].name == "扇2")
		{
			换东西[换几].transform.GetChild(0).gameObject.GetComponent<rotaself>().是否自转 = false;
		}
		return "完";
	}

	public string 换(string 参数 = null)
	{
		if (参数 == "灯" || 参数 == "")
		{
			if (换几 < 换东西.Count - 1)
			{
				换东西[换几].active = false;
				换几++;
			}
			else
			{
				换东西[换几].active = false;
				换几 = 0;
			}
			换东西[换几].active = true;
		}
		return "换完";
	}

	public void 雪(string 参数 = null)
	{
		Manager._instance.Down.下载模型("4012013");
		Manager._instance.vr12888.是否下载模型 = true;
		string 模型名 = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		Manager._instance.vr12888.模型名 = 模型名;
	}

	public void 冰(string 参数 = null)
	{
		Manager._instance.Down.下载模型("4012001");
	}

	public void 水(string 参数 = null)
	{
		Manager._instance.Down.下载模型("4012014");
	}

	public void 雨(string 参数 = null)
	{
		Manager._instance.Down.下载模型("4012011");
	}

	public void 电(string 参数 = null)
	{
		Manager._instance.Down.下载模型("4012012");
	}

	public void 火(string 参数 = null)
	{
		Manager._instance.Down.下载模型("4012010");
	}

	public void 炸(string 参数 = null)
	{
		Manager._instance.Down.下载模型("4011043");
	}

	public void 爆(string 参数 = null)
	{
		Manager._instance.Down.下载模型("4011079");
	}

	public void 激(string 参数 = null)
	{
		Manager._instance.Down.下载模型("4011032");
	}

	public void 霜(string 参数 = null)
	{
		Manager._instance.Down.下载模型("4011032");
	}

	public void 光(string 参数 = null)
	{
		Manager._instance.Down.下载模型("4011080");
	}

	public string 风(string 参数)
	{
		Manager._instance.Down.下载模型("4012047");
		return "完";
	}

	public string 雷(string 参数)
	{
		Manager._instance.Down.下载模型("4012081");
		return "完";
	}

	public string 气(string 参数)
	{
		return "完";
	}

	public string 烟(string 参数)
	{
		Manager._instance.Down.下载模型("4011068");
		return "完";
	}

	public string 星(string 参数)
	{
		return "完";
	}

	public string 东(string 参数 = null)
	{
		目标角度 = Quaternion.Euler(0f, 90f, 0f) * Quaternion.identity;
		是否旋转 = true;
		return "完";
	}

	public string 南(string 参数 = null)
	{
		目标角度 = Quaternion.Euler(0f, -180f, 0f) * Quaternion.identity;
		是否旋转 = true;
		return "完";
	}

	public string 西(string 参数 = null)
	{
		目标角度 = Quaternion.Euler(0f, -90f, 0f) * Quaternion.identity;
		是否旋转 = true;
		return "完";
	}

	public string 北(string 参数 = null)
	{
		目标角度 = Quaternion.Euler(0f, 0f, 0f) * Quaternion.identity;
		是否旋转 = true;
		return "完";
	}

	public string 远(string 参数)
	{
		重置旋转移动();
		是否上下 = false;
		上移 = false;
		if (参数 == "")
		{
			参数 = "1";
		}
		参参 = 参数;
		目标角度 = Quaternion.LookRotation(-(作用物体.position - 人模.position));
		是否旋转 = true;
		移动米 = float.Parse(参数);
		是否移动 = true;
		return "完";
	}

	public string 近(string 参数)
	{
		重置旋转移动();
		是否上下 = false;
		上移 = false;
		if (参数 == "")
		{
			参数 = "1";
		}
		参参 = 参数;
		目标角度 = Quaternion.LookRotation(-(人模.position - 作用物体.position));
		是否旋转 = true;
		移动米 = float.Parse(参数);
		是否移动 = true;
		return "完";
	}

	public string 年(string 参数 = null)
	{
		作用物体.gameObject.GetComponentInChildren<Text>().text = DateTime.Now.Year.ToString();
		return "完";
	}

	public string 月(string 参数 = null)
	{
		作用物体.gameObject.GetComponentInChildren<Text>().text = DateTime.Now.Month.ToString();
		return "完";
	}

	public string 日(string 参数 = null)
	{
		作用物体.gameObject.GetComponentInChildren<Text>().text = DateTime.Now.Day.ToString();
		return "完";
	}

	public string 周(string 参数 = null)
	{
		作用物体.gameObject.GetComponentInChildren<Text>().text = DateTime.Now.DayOfWeek.ToString();
		return "完";
	}

	public string 时(string 参数 = null)
	{
		作用物体.gameObject.GetComponentInChildren<Text>().text = DateTime.Now.Hour.ToString();
		return "完";
	}

	public string 分(string 参数 = null)
	{
		作用物体.gameObject.GetComponentInChildren<Text>().text = DateTime.Now.Minute.ToString();
		return "完";
	}

	public string 秒(string 参数 = null)
	{
		作用物体.gameObject.GetComponentInChildren<Text>().text = DateTime.Now.Second.ToString();
		return "完";
	}

	public string 早(string 参数 = "6")
	{
		if (参数 == "")
		{
			参数 = "6";
		}
		float x = (float.Parse(参数) - 6f) * 15f;
		太阳.transform.rotation = Quaternion.Euler(x, -60f, 0f);
		return "完";
	}

	public string 晚(string 参数 = "18")
	{
		if (参数 == "")
		{
			参数 = "18";
		}
		float x = (float.Parse(参数) - 18f) * 15f;
		太阳.transform.rotation = Quaternion.Euler(x, -60f, 0f);
		return "完";
	}

	public string 季(string 参数 = null)
	{
		int month = DateTime.Now.Month;
		if (month >= 3 && month <= 5)
		{
			作用物体.gameObject.GetComponentInChildren<Text>().text = "春";
		}
		else if (month >= 6 && month <= 8)
		{
			作用物体.gameObject.GetComponentInChildren<Text>().text = "夏";
		}
		else if (month >= 9 && month <= 11)
		{
			作用物体.gameObject.GetComponentInChildren<Text>().text = "秋";
		}
		else if (month == 12 || month <= 2)
		{
			作用物体.gameObject.GetComponentInChildren<Text>().text = "冬";
		}
		return "完";
	}

	public string 天(string 参数 = null)
	{
		if (参数 == null || 参数 == "")
		{
			作用物体.gameObject.GetComponentInChildren<Text>().text = DateTime.Now.DayOfYear.ToString();
		}
		return "完";
	}

	public string 春(string 参数 = null)
	{
		UnityEngine.Object.Destroy(GameObject.Find("Terrain"));
		if ((bool)GameObject.Find("雪"))
		{
			UnityEngine.Object.Destroy(GameObject.Find("雪"));
		}
		建地("1,2,3,4,5,6;Ground Grass 01,Ground Grass 02,Ground Grass 02,Ground Soil 02,Ground Rock 01,Ground Rock 02");
		return "完";
	}

	public string 夏(string 参数 = null)
	{
		UnityEngine.Object.Destroy(GameObject.Find("Terrain"));
		if ((bool)GameObject.Find("雪"))
		{
			UnityEngine.Object.Destroy(GameObject.Find("雪"));
		}
		建地("1,2,3,4,5,6;Ground Grass 01,Ground Grass 02,Ground Soil 01,Ground Soil 02,Ground Rock 01,Ground Rock 02");
		return "完";
	}

	public string 秋(string 参数 = null)
	{
		UnityEngine.Object.Destroy(GameObject.Find("Terrain"));
		if ((bool)GameObject.Find("雪"))
		{
			UnityEngine.Object.Destroy(GameObject.Find("雪"));
		}
		建地("1,2,3,4,5,6;Ground Grass 01,Ground Soil 01,Ground Soil 01,Ground Soil 02,Ground Rock 01,Ground Rock 02");
		return "完";
	}

	public string 冬(string 参数 = null)
	{
		UnityEngine.Object.Destroy(GameObject.Find("Terrain"));
		if ((bool)GameObject.Find("雪"))
		{
			UnityEngine.Object.Destroy(GameObject.Find("雪"));
		}
		建地("1,2,3,4,5,6;Ground Soil 01,Ground Soil 01,Ground Soil 01,Ground Soil 02,Ground Rock 01,Ground Rock 02");
		雪();
		GameObject.Find("雪").transform.position = new Vector3(0f, 15f, 0f);
		return "完";
	}

	public string 暗(string 参数 = null)
	{
		m_du -= 0.1f;
		太阳.GetComponent<Light>().intensity = m_du;
		return "完";
	}

	public string 亮(string 参数 = null)
	{
		m_du += 0.1f;
		太阳.GetComponent<Light>().intensity = m_du;
		return "完";
	}

	public string 阴(string 参数 = null)
	{
		m_du = 0.1f;
		太阳.GetComponent<Light>().intensity = m_du;
		return "完";
	}

	public string 晴(string 参数 = null)
	{
		m_du = 2f;
		太阳.GetComponent<Light>().intensity = m_du;
		return "完";
	}

	public string 算(string 参数 = null)
	{
		return "算完";
	}

	public string 加(string 参数 = "0")
	{
		if (参数 == "")
		{
			参数 = "0";
		}
		string[] array = 参数.Split('与');
		float num = 0f;
		for (int i = 0; i < array.Length; i++)
		{
			num += float.Parse(array[i]);
		}
		作用物体.gameObject.GetComponentInChildren<Text>().text = num.ToString();
		return "加完";
	}

	public string 减(string 参数 = "0")
	{
		if (参数 == "")
		{
			参数 = "0";
		}
		string[] array = 参数.Split('与');
		float num = float.Parse(array[0]);
		for (int i = 1; i < array.Length; i++)
		{
			num -= float.Parse(array[i]);
		}
		作用物体.gameObject.GetComponentInChildren<Text>().text = num.ToString();
		return "减完";
	}

	public string 均(string 参数 = "0")
	{
		if (参数 == "")
		{
			参数 = "0";
		}
		string[] array = 参数.Split('与');
		float num = 0f;
		for (int i = 0; i < array.Length; i++)
		{
			num += float.Parse(array[i]);
		}
		num /= (float)array.Length;
		作用物体.gameObject.GetComponentInChildren<Text>().text = num.ToString();
		return "减完";
	}

	public string 非(string 参数 = "真")
	{
		string text = "假";
		if (参数 == "")
		{
			参数 = "真";
		}
		text = ((!(参数 == "真")) ? "真" : "假");
		作用物体.gameObject.GetComponentInChildren<Text>().text = text;
		return "减完";
	}

	public string 半(string 参数 = "0")
	{
		if (参数 == "")
		{
			参数 = "0";
		}
		float num = 0f;
		num = float.Parse(参数) / 2f;
		作用物体.gameObject.GetComponentInChildren<Text>().text = num.ToString();
		return "减完";
	}

	public string 余(string 参数 = "0")
	{
		if (参数 == "")
		{
			参数 = "0";
		}
		string[] array = 参数.Split('与');
		float num = 0f;
		num = float.Parse(array[0]) % float.Parse(array[1]);
		作用物体.gameObject.GetComponentInChildren<Text>().text = num.ToString();
		return "减完";
	}

	public string 忐(string 参数 = "0")
	{
		if (参数 == "")
		{
			参数 = "0";
		}
		double num = 0.0;
		num = Math.Ceiling(double.Parse(参数));
		作用物体.gameObject.GetComponentInChildren<Text>().text = num.ToString();
		return "减完";
	}

	public string 忑(string 参数 = "0")
	{
		if (参数 == "")
		{
			参数 = "0";
		}
		double num = 0.0;
		num = Math.Floor(double.Parse(参数));
		作用物体.gameObject.GetComponentInChildren<Text>().text = num.ToString();
		return "减完";
	}

	public string 舍(string 参数 = "0")
	{
		if (参数 == "")
		{
			参数 = "0";
		}
		double num = 0.0;
		num = Math.Round(double.Parse(参数));
		作用物体.gameObject.GetComponentInChildren<Text>().text = num.ToString();
		return "减完";
	}

	public string 绝(string 参数 = "0")
	{
		if (参数 == "")
		{
			参数 = "0";
		}
		double num = 0.0;
		num = 0f - float.Parse(参数);
		作用物体.gameObject.GetComponentInChildren<Text>().text = num.ToString();
		return "减完";
	}

	public string 乘(string 参数)
	{
		float num = 1f;
		if (参数 == "")
		{
			参数 = "0";
		}
		string[] array = 参数.Split('与');
		for (int i = 0; i < array.Length; i++)
		{
			num *= float.Parse(array[i]);
		}
		作用物体.gameObject.GetComponentInChildren<Text>().text = num.ToString();
		return "完";
	}

	public string 除(string 参数)
	{
		float num = 0f;
		if (参数 == "")
		{
			参数 = "0";
		}
		string[] array = 参数.Split('与');
		for (int i = 0; i < array.Length - 1; i++)
		{
			num = ((num != 0f) ? (num / float.Parse(array[i + 1])) : (float.Parse(array[i]) / float.Parse(array[i + 1])));
		}
		作用物体.gameObject.GetComponentInChildren<Text>().text = num.ToString();
		return "完";
	}

	public string 色(string 参数)
	{
		色板.active = true;
		是否开始选颜色 = true;
		呆色();
		是否选好颜色 = false;
		return "完";
	}

	public string 颜(string 参数 = "")
	{
		颜板.active = true;
		是否开始选颜色 = true;
		呆色();
		是否选好颜色 = false;
		return "完";
	}

	public string 透(string 参数)
	{
		return "完";
	}

	public string 浅(string 参数)
	{
		return "完";
	}

	public string 艳(string 参数)
	{
		return "完";
	}

	private void 呆色()
	{
		if (色材质 == null)
		{
			色材质 = new Material(作用物体.GetComponent<MeshRenderer>().material);
			色材质.name = "aaaa";
			作用物体.GetComponent<MeshRenderer>().material = 色材质;
		}
	}

	public string 红(string 参数 = "")
	{
		呆色();
		色材质.color = new Color(1f, 0f, 0f, 1f);
		return new StackTrace().GetFrame(0).ToString().Substring(0, 1) + "完";
	}

	public string 绿(string 参数 = "")
	{
		呆色();
		色材质.color = new Color(0f, 1f, 0f, 1f);
		return new StackTrace().GetFrame(0).ToString().Substring(0, 1) + "完";
	}

	public string 蓝(string 参数 = "")
	{
		呆色();
		色材质.color = new Color(0f, 0f, 1f, 1f);
		return new StackTrace().GetFrame(0).ToString().Substring(0, 1) + "完";
	}

	public string 黑(string 参数 = "")
	{
		呆色();
		色材质.color = new Color(0f, 0f, 0f, 1f);
		return new StackTrace().GetFrame(0).ToString().Substring(0, 1) + "完";
	}

	public string 白(string 参数 = "")
	{
		呆色();
		色材质.color = new Color(1f, 1f, 1f, 1f);
		return new StackTrace().GetFrame(0).ToString().Substring(0, 1) + "完";
	}

	public string 灰(string 参数 = "")
	{
		呆色();
		色材质.color = new Color(0.5f, 0.5f, 0.5f, 1f);
		return new StackTrace().GetFrame(0).ToString().Substring(0, 1) + "完";
	}

	public string 青(string 参数 = "")
	{
		呆色();
		色材质.color = new Color(0f, 0.54f, 0.54f, 1f);
		return new StackTrace().GetFrame(0).ToString().Substring(0, 1) + "完";
	}

	public string 黄(string 参数 = "")
	{
		呆色();
		色材质.color = new Color(1f, 1f, 0f, 1f);
		return new StackTrace().GetFrame(0).ToString().Substring(0, 1) + "完";
	}

	public string 粉(string 参数 = "")
	{
		呆色();
		色材质.color = new Color(1f, 0.75f, 0.79f, 1f);
		return new StackTrace().GetFrame(0).ToString().Substring(0, 1) + "完";
	}

	public string 紫(string 参数 = "")
	{
		呆色();
		色材质.color = new Color(0.5f, 0f, 1f, 1f);
		return new StackTrace().GetFrame(0).ToString().Substring(0, 1) + "完";
	}

	public string 橙(string 参数 = "")
	{
		呆色();
		色材质.color = new Color(1f, 0.54f, 0f, 1f);
		return new StackTrace().GetFrame(0).ToString().Substring(0, 1) + "完";
	}

	public string 褐(string 参数 = "")
	{
		呆色();
		色材质.color = new Color(0.58f, 0.29f, 0f, 1f);
		return new StackTrace().GetFrame(0).ToString().Substring(0, 1) + "完";
	}
}
public class rotaself : MonoBehaviour
{
	public bool 是否自转;

	public float 自转速度 = 10f;

	private void Start()
	{
	}

	private void FixedUpdate()
	{
		if (是否自转)
		{
			base.transform.Rotate(Vector3.forward * 自转速度, Space.Self);
		}
	}
}
public class show_jing : MonoBehaviour
{
	public GameObject 井;

	public static string 历史00 = "";

	public static string 最后一个历史 = "";

	private bool 是否历史 = true;

	public Jing_PC2 跳转页面;

	public bool 清 = true;

	private void Start()
	{
		if (清)
		{
			PlayerPrefs.DeleteAll();
		}
		if (!PlayerPrefs.HasKey("历史"))
		{
			return;
		}
		历史00 = PlayerPrefs.GetString("历史");
		MonoBehaviour.print("历史00:" + 历史00);
		string @string = PlayerPrefs.GetString("点击记录历史");
		if (!(@string != ""))
		{
			return;
		}
		string[] array = @string.Split(';');
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i] == "")
			{
				Jing_PC2.点击记录.Push("-");
			}
			else
			{
				Jing_PC2.点击记录.Push(array[i]);
			}
		}
	}

	private void Update()
	{
	}

	public void show_j()
	{
		if (井.active)
		{
			井.active = false;
			return;
		}
		井.active = true;
		if (是否历史 && PlayerPrefs.HasKey("历史"))
		{
			跳转页面.当前虚游 = 历史00.Substring(1);
			StartCoroutine(稍时());
		}
	}

	private IEnumerator 稍时()
	{
		yield return new WaitForSeconds(5f);
		MonoBehaviour.print("childCount:" + 跳转页面.grid.transform.childCount);
		MonoBehaviour.print(Jing_PC2.点击记录.Peek());
		跳转页面.grid.transform.GetChild(24).GetComponent<ImageItem>().内容.text = Jing_PC2.点击记录.Peek();
		是否历史 = false;
	}
}
public class close_jing : MonoBehaviour
{
	public GameObject 脚本心;

	private void Start()
	{
	}

	private void Update()
	{
	}

	public void 点击操作()
	{
		if ((bool)脚本心)
		{
			脚本心.GetComponent<xupin>().井模块.active = false;
		}
	}
}
public class LineRendererDemo : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class MySocket2 : MonoBehaviour
{
	public static MySocket2 _instance;

	public Text 帐号;

	public Text 密码;

	public string 虚号;

	private void Awake()
	{
		_instance = this;
	}

	private void Start()
	{
	}

	public void 开始井()
	{
		GC.套接 = GameObject.Find("SocketIO").GetComponent<SocketIOComponent>();
		StartCoroutine("开始");
		GC.套接.On("连接成功", 连接成功);
		GC.套接.On("户广", 户广);
		登录();
	}

	private IEnumerator 开始()
	{
		yield return new WaitForSeconds(1f);
		GC.套接.Emit("连接");
	}

	public void 户广(SocketIOEvent 参数)
	{
	}

	public void 登录成功(SocketIOEvent 参数)
	{
		MonoBehaviour.print("登录成功");
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject.transform.parent);
		SceneManager.LoadScene(1);
	}

	public void 连接成功(SocketIOEvent 参数)
	{
	}

	private void 登录()
	{
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		dictionary["id"] = "12345";
		dictionary["pw"] = "1";
		dictionary["表"] = "az_400";
		string value = "10774";
		PlayerPrefs.SetString("虚我号", value);
		GC.套接.Emit("登录", new JSONObject(dictionary));
	}
}
public class CircleProcess : MonoBehaviour
{
	[SerializeField]
	private float speed;

	[SerializeField]
	private Transform process;

	private float currentAmout;

	public int targetProcess { get; set; }

	private void Start()
	{
		targetProcess = 100;
	}

	private void Update()
	{
		if (currentAmout < (float)targetProcess)
		{
			currentAmout += speed;
			process.GetComponent<Image>().fillAmount = currentAmout / 100f;
			if ((double)currentAmout >= 99.9)
			{
				currentAmout = 0f;
			}
		}
	}

	public void SetTargetProcess(int target)
	{
		if (target >= 0 && target <= 100)
		{
			targetProcess = target;
		}
	}
}
public class ClickObject : MonoBehaviour
{
	private void Start()
	{
		base.transform.GetComponent<UnityEngine.UI.Button>().onClick.AddListener(当前点击);
	}

	private void 当前点击()
	{
		SendMessageUpwards("井_PC", base.gameObject, SendMessageOptions.DontRequireReceiver);
	}
}
public class ImageItem : MonoBehaviour
{
	public Image 图标;

	public Text 描述;

	public Text 内容;

	public Text 备注;

	public Text 字母;

	public Texture 格子图片;

	public bool 是否是最后一个;

	private void Awake()
	{
		字母 = base.transform.Find("Num").GetComponent<Text>();
		备注 = base.transform.Find("Image02/Text02").GetComponent<Text>();
		内容 = base.transform.Find("Image/Text").GetComponent<Text>();
		描述 = base.transform.Find("Image01/Text").GetComponent<Text>();
		图标 = base.transform.Find("Icon").GetComponent<Image>();
	}

	public void UpdateImage(string s)
	{
		StartCoroutine(下载图片(s));
	}

	private IEnumerator 下载图片(string url)
	{
		WWW date = new WWW(url);
		yield return date;
		if (date.error == null)
		{
			Texture2D texture = date.texture;
			图标.overrideSprite = Sprite.Create(texture, new Rect(0f, 0f, texture.width, texture.height), new Vector2(0f, 0f));
			格子图片 = texture;
		}
	}
}
public class ItemButton : MonoBehaviour
{
	private void Start()
	{
		base.transform.GetComponent<UnityEngine.UI.Button>().onClick.AddListener(当前点击);
	}

	private void 当前点击()
	{
		SendMessageUpwards("编辑内容", base.gameObject, SendMessageOptions.DontRequireReceiver);
	}
}
public class JingHand : MonoBehaviour
{
	public GameObject 画布;

	private bool 是否显示UI;

	public Transform pos;

	private LineRenderer Line;

	private GameObject 旋转标志物;

	private GameObject 眼睛;

	private bool 获取到眼睛;

	public GameObject 输入法;

	public static JingHand _instance;

	public bool 编辑模式;

	public string 修改下标;

	private List<GameObject> 场景中井;

	[HideInInspector]
	private Transform 佐;

	private bool 获取到手柄;

	private GameObject currentGo;

	public GameObject 临时的井;

	public GameObject 层次面板;

	public UnityEngine.UI.Button 关闭按钮;

	public GameObject 检视面板;

	public UnityEngine.UI.Button 检视面板关闭按钮;

	private void Awake()
	{
		_instance = this;
		场景中井 = new List<GameObject>();
	}

	private void Start()
	{
		是否显示UI = false;
		佐 = base.transform;
		Line = GetComponent<LineRenderer>();
		旋转标志物 = GameObject.CreatePrimitive(PrimitiveType.Cube);
		旋转标志物.name = "旋转标志物";
		BoxCollider component = 旋转标志物.GetComponent<BoxCollider>();
		MeshRenderer component2 = 旋转标志物.GetComponent<MeshRenderer>();
		UnityEngine.Object.Destroy(component);
		UnityEngine.Object.Destroy(component2);
	}

	private void Update()
	{
		if ((bool)GameObject.Find("Camera (eye)") && !获取到眼睛)
		{
			眼睛 = GameObject.Find("Camera (eye)");
			获取到眼睛 = true;
		}
		if ((bool)眼睛 && (bool)旋转标志物)
		{
			float y = 眼睛.transform.eulerAngles.y;
			旋转标志物.transform.rotation = Quaternion.AngleAxis(y, Vector3.up);
		}
	}

	private void 生成井画布()
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(画布);
		float y = GetHight() + 1f;
		gameObject.transform.position = new Vector3(pos.transform.position.x, y, pos.transform.position.z);
		gameObject.transform.rotation = 旋转标志物.transform.rotation;
		gameObject.SetActive(value: true);
		场景中井.Add(gameObject);
	}

	private void 清空数组()
	{
		for (int i = 0; i < 场景中井.Count; i++)
		{
			UnityEngine.Object.Destroy(场景中井[i]);
		}
		场景中井.Clear();
	}

	public void 显示输入法(bool b)
	{
		if (b)
		{
			if ((bool)currentGo)
			{
				临时的井 = currentGo;
				临时的井.SetActive(value: false);
			}
			float y = GetHight() + 2f;
			输入法.transform.position = new Vector3(pos.transform.position.x, y, pos.transform.position.z - 1f);
			输入法.transform.rotation = 旋转标志物.transform.rotation;
			输入法.SetActive(value: true);
		}
		else
		{
			输入法.SetActive(value: false);
			输入法.transform.position = new Vector3(500f, 0f, 0f);
			输入法.transform.rotation = Quaternion.identity;
			if ((bool)临时的井)
			{
				临时的井.SetActive(value: true);
			}
		}
	}

	public void 修改内容(string a, string b)
	{
		if ((bool)临时的井)
		{
			临时的井.GetComponent<井模块>().修改数据(a, b);
		}
	}

	public void 输入框文字处理(string str)
	{
		if ((bool)临时的井)
		{
			临时的井.GetComponent<井模块>().输入框文字赋值(str);
		}
	}

	private void FixedUpdate()
	{
		if (!佐)
		{
			return;
		}
		if (Physics.Raycast(new Ray(佐.position, 佐.forward), out var hitInfo, 600f, 1 << LayerMask.NameToLayer("JingUI")))
		{
			Line.enabled = true;
			Line.SetPosition(0, 佐.position);
			Line.SetPosition(1, hitInfo.point);
			获取当前井(hitInfo.transform.gameObject);
			if (!(currentGo != null))
			{
				return;
			}
			if (!currentGo.GetComponent<井模块>().是否编辑模式)
			{
				if (hitInfo.transform.CompareTag("ImageFirst"))
				{
					currentGo.GetComponent<井模块>().执行井宫格(hitInfo.transform.gameObject);
					if (按下扳机())
					{
						currentGo.GetComponent<井模块>().按下扳机执行井(hitInfo.transform.gameObject);
					}
				}
			}
			else
			{
				currentGo.GetComponent<井模块>().格子颜色恢复();
				if (hitInfo.transform.CompareTag("Change02"))
				{
					GameObject go = hitInfo.transform.gameObject;
					if (按下扳机())
					{
						currentGo.GetComponent<井模块>().修改备注(go);
					}
					currentGo.GetComponent<井模块>().描述备注变色(go, "Image01");
					currentGo.GetComponent<井模块>().图片颜色恢复("Image02");
				}
				else if (hitInfo.transform.CompareTag("Change03"))
				{
					GameObject go2 = hitInfo.transform.gameObject;
					if (按下扳机())
					{
						currentGo.GetComponent<井模块>().修改描述(go2);
					}
					currentGo.GetComponent<井模块>().描述备注变色(go2, "Image02");
					currentGo.GetComponent<井模块>().图片颜色恢复("Image01");
				}
			}
			if (hitInfo.transform.name == "锁定按钮")
			{
				currentGo.GetComponent<井模块>().按钮放大(hitInfo.transform, 1.1f);
				if (按下扳机())
				{
					currentGo.GetComponent<井模块>().锁定按钮操作();
				}
			}
			else if (hitInfo.transform.name == "根目录")
			{
				currentGo.GetComponent<井模块>().按钮放大(hitInfo.transform, 1.1f);
				if (按下扳机())
				{
					currentGo.GetComponent<井模块>().返回根目录();
				}
			}
			else
			{
				if (hitInfo.transform.name == "RestoreBtn")
				{
					return;
				}
				if (hitInfo.transform.name == "EditorBtn")
				{
					currentGo.GetComponent<井模块>().按钮放大(hitInfo.transform, 1.1f);
					currentGo.GetComponent<井模块>().图片颜色恢复("Image01");
					currentGo.GetComponent<井模块>().图片颜色恢复("Image02");
					if (按下扳机())
					{
						currentGo.GetComponent<井模块>().功能切换();
					}
				}
				else if (hitInfo.transform.name == "IconBtn")
				{
					currentGo.GetComponent<井模块>().按钮放大(hitInfo.transform, 1.1f);
					if (按下扳机())
					{
						currentGo.GetComponent<井模块>().图标切换();
					}
				}
				else if (hitInfo.transform.name == "刷新按钮")
				{
					currentGo.GetComponent<井模块>().按钮放大(hitInfo.transform, 1.1f);
					if (按下扳机())
					{
						currentGo.GetComponent<井模块>().重新加载当前场景();
					}
				}
				else if (hitInfo.transform.name == "输入")
				{
					currentGo.GetComponent<井模块>().按钮放大(hitInfo.transform, 1.1f);
					if (按下扳机())
					{
						显示输入法(b: true);
					}
				}
				else if (hitInfo.transform.name == "输入执行")
				{
					if (按下扳机())
					{
						显示输入法(b: true);
					}
				}
				else if (hitInfo.transform.name == "执行")
				{
					currentGo.GetComponent<井模块>().按钮放大(hitInfo.transform, 1.1f);
					if (按下扳机())
					{
						currentGo.GetComponent<井模块>().输入法确定执行();
					}
				}
				else
				{
					currentGo.GetComponent<井模块>().按钮恢复();
				}
			}
		}
		else
		{
			if (currentGo != null)
			{
				currentGo.GetComponent<井模块>().射线结束();
			}
			Line.enabled = false;
			currentGo = null;
		}
	}

	public bool 按下扳机()
	{
		return false;
	}

	private void 获取当前井(GameObject go)
	{
		switch (go.name)
		{
		case "井模块画布(VR)(Clone)":
			currentGo = go;
			break;
		case "刷新按钮":
		case "EditorBtn":
		case "锁定按钮":
		case "IconBtn":
		case "ImageBg":
			currentGo = go.transform.parent.parent.gameObject;
			break;
		case "Image":
		case "Image01":
		case "Image02":
			currentGo = go.transform.parent.parent.parent.parent.gameObject;
			break;
		case "根目录":
		case "输入":
		case "执行":
		case "输入执行":
			currentGo = go.transform.parent.gameObject;
			break;
		case "ImageFirst(Clone)":
			currentGo = go.transform.parent.parent.parent.gameObject;
			break;
		default:
			currentGo = null;
			break;
		}
	}

	private float GetHight()
	{
		GameObject.Find("[CameraRig]");
		_ = pos;
		return (pos.position - pos.parent.transform.position - 眼睛.transform.localPosition).y;
	}

	public void 层次视图显示()
	{
		层次面板.SetActive(value: true);
		if ((bool)currentGo)
		{
			临时的井 = currentGo;
			临时的井.SetActive(value: false);
		}
		层次面板.transform.position = 临时的井.transform.position;
		层次面板.transform.rotation = 临时的井.transform.rotation;
	}

	public void 关闭层次面板()
	{
		层次面板.SetActive(value: false);
		if ((bool)临时的井)
		{
			临时的井.SetActive(value: true);
		}
	}

	public void 检视视图显示()
	{
		检视面板.SetActive(value: true);
		if ((bool)currentGo)
		{
			临时的井 = currentGo;
			临时的井.SetActive(value: false);
		}
		检视面板.transform.position = new Vector3(临时的井.transform.position.x, 临时的井.transform.position.y, 临时的井.transform.position.z);
		检视面板.transform.rotation = 临时的井.transform.rotation;
	}

	public void 关闭检视面板()
	{
		检视面板.SetActive(value: false);
		if ((bool)临时的井)
		{
			临时的井.SetActive(value: true);
		}
	}
}
public class Jing_PC : MonoBehaviour
{
	public GameObject 当前选择;

	public string 当前虚号 = "150";

	public string 当前虚游 = "虚unity3d";

	public string 当前虚我 = "12101";

	public UnityEngine.UI.Button 图标按钮;

	public UnityEngine.UI.Button 编辑按钮;

	public UnityEngine.UI.Button 返回按钮;

	public UnityEngine.UI.Button 恢复按钮;

	public UnityEngine.UI.Button 锁定按钮;

	public GameObject grid;

	private bool 是否编辑;

	private bool 是否切换图标;

	public string 虚我号;

	private string 表 = "az_400";

	private string 默认虚号 = "10000";

	private string 中;

	private JSONObject 取得数据;

	private JSONObject 默认数据;

	private string strPath = "http://224248.com/png/快/";

	private string finalPath;

	private bool 是否首次运行;

	private bool 是否恢复默认;

	[HideInInspector]
	public SocketIOComponent 套接;

	private string 根目录;

	private Text rootText;

	public GameObject 进度条;

	public GameObject ItemUI;

	public Texture 获取当前图片;

	public static Text 显示数字;

	public UnityEngine.UI.Button 确定按钮;

	public UnityEngine.UI.Button 取消按钮;

	public GameObject 输入框;

	private GameObject 当前点击格子;

	private string 上一级目录 = "-";

	private Stack<string> 点击记录 = new Stack<string>();

	public bool 是否锁定;

	private bool 锁定;

	private void Start()
	{
		根目录 = "井" + 当前虚游;
		获取虚号();
		图标按钮.onClick.AddListener(图标);
		编辑按钮.onClick.AddListener(编辑);
		确定按钮.onClick.AddListener(确定修改);
		取消按钮.onClick.AddListener(取消修改);
		返回按钮.onClick.AddListener(返回根目录);
		恢复按钮.onClick.AddListener(恢复默认);
		锁定按钮.onClick.AddListener(锁定按钮操作);
		点击记录.Push(上一级目录);
		套接 = GC.套接;
		rootText = base.transform.Find("根目录/RootText").GetComponent<Text>();
		StartCoroutine("首次运行");
		套接.On("户广", 户广);
	}

	private void 获取虚号()
	{
		if (PlayerPrefs.HasKey("虚我号"))
		{
			虚我号 = PlayerPrefs.GetString("虚我号");
		}
		else
		{
			虚我号 = "10774";
		}
	}

	private void Update()
	{
	}

	private void 井_PC(GameObject go)
	{
		string text = go.GetComponent<ImageItem>().内容.text;
		string text2 = text.Substring(0, 1);
		text.Substring(1);
		_ = go.GetComponent<ImageItem>().字母.text;
		if (text2 == "井")
		{
			StopAllCoroutines();
			if (text.Substring(1, 1) == "换")
			{
				是否切换图标 = false;
			}
			else
			{
				是否切换图标 = true;
			}
			跳转(虚我号, text);
			点击最后一个(go);
			rootText.text = text;
			StartCoroutine("加载数据");
			进度条.SetActive(value: true);
			图标();
			return;
		}
		StopAllCoroutines();
		string parameter = "";
		if (rootText.text == "井云加载")
		{
			char[] array = go.transform.GetComponent<ImageItem>().字母.text.ToCharArray();
			if (array[0] >= 'a' && array[0] <= 'j')
			{
				string text3 = go.transform.GetComponent<ImageItem>().内容.text;
				显示数字.text += text3;
			}
		}
		else if (rootText.text.Substring(0, 2) == "井换")
		{
			获取当前图片 = go.transform.GetComponent<ImageItem>().格子图片;
		}
		else if (rootText.text.Substring(0, 3) == "井虚游")
		{
			string text4 = go.transform.GetComponent<ImageItem>().描述.text;
			BroadcastMessage("玩虚游", text4, SendMessageOptions.DontRequireReceiver);
		}
		else if (rootText.text == "井拼健身")
		{
			string parameter2 = text.Substring(1, text.Length - 1);
			BroadcastMessage("物", parameter2, SendMessageOptions.DontRequireReceiver);
		}
		else if (rootText.text == "井虚令")
		{
			string parameter3 = text.Substring(1, text.Length - 1);
			BroadcastMessage("令", parameter3, SendMessageOptions.DontRequireReceiver);
		}
		BroadcastMessage(text, parameter, SendMessageOptions.DontRequireReceiver);
	}

	private void 编辑()
	{
		是否编辑 = !是否编辑;
		if (是否编辑)
		{
			编辑切换(b1: false, b2: true);
			按钮文字显示(编辑按钮, "指 令");
		}
		else
		{
			编辑切换(b1: true, b2: false);
			按钮文字显示(编辑按钮, "编 辑");
		}
	}

	private void 锁定按钮操作()
	{
		锁定 = !锁定;
		if (锁定)
		{
			按钮文字显示(锁定按钮, "解 锁");
			是否锁定 = true;
		}
		else
		{
			按钮文字显示(锁定按钮, "锁 定");
			是否锁定 = false;
		}
	}

	private void 图标()
	{
		是否切换图标 = !是否切换图标;
		if (是否切换图标)
		{
			图标切换(b: true);
			按钮文字显示(图标按钮, "文 字");
		}
		else
		{
			图标切换(b: false);
			按钮文字显示(图标按钮, "图 标");
		}
	}

	private void 编辑切换(bool b1, bool b2)
	{
		for (int i = 0; i < grid.transform.childCount; i++)
		{
			GameObject obj = grid.transform.GetChild(i).gameObject;
			obj.GetComponent<UnityEngine.UI.Button>().enabled = b1;
			GameObject gameObject = obj.transform.Find("Image").gameObject;
			gameObject.GetComponent<Image>().enabled = b2;
			开启关闭按钮(gameObject, b2);
			GameObject gameObject2 = obj.transform.Find("Image01").gameObject;
			开启关闭按钮(gameObject2, b2);
			GameObject gameObject3 = obj.transform.Find("Image02").gameObject;
			开启关闭按钮(gameObject3, b2);
			gameObject2.SetActive(b2);
			gameObject3.SetActive(b2);
			gameObject2.GetComponent<Image>().enabled = b2;
			gameObject3.GetComponent<Image>().enabled = b2;
		}
	}

	private void 开启关闭按钮(GameObject go, bool b)
	{
		go.GetComponent<UnityEngine.UI.Button>().enabled = b;
	}

	private void 按钮文字显示(UnityEngine.UI.Button btn, string str)
	{
		btn.gameObject.transform.Find("Text").GetComponent<Text>().text = str;
	}

	private void 图标切换(bool b)
	{
		for (int i = 0; i < grid.transform.childCount; i++)
		{
			GameObject obj = grid.transform.GetChild(i).gameObject;
			obj.transform.Find("Icon").gameObject.SetActive(b);
			obj.transform.Find("Image").gameObject.SetActive(!b);
		}
	}

	public void 户广(SocketIOEvent 参数)
	{
		if (!是否首次运行)
		{
			是否首次运行 = true;
			StartCoroutine("加载数据");
		}
		if (!是否恢复默认)
		{
			取得数据 = 参数.data;
			return;
		}
		默认数据 = 参数.data;
		是否恢复默认 = false;
	}

	private IEnumerator 首次运行()
	{
		yield return new WaitForSeconds(1f);
		跳转(虚我号, 根目录);
		rootText.text = 根目录;
	}

	private IEnumerator 加载数据()
	{
		yield return new WaitForSeconds(0.5f);
		进度条.SetActive(value: false);
		进度条.transform.Find("Process").GetComponent<Image>().fillAmount = 0f;
		获取数据处理();
	}

	public void 跳转(string a, string b)
	{
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		dictionary["户"] = a;
		dictionary["广"] = b;
		dictionary["表"] = 表;
		套接.Emit("加载户广", new JSONObject(dictionary));
	}

	private void 获取数据处理()
	{
		if (grid.transform.childCount == 0)
		{
			for (char c = 'a'; c < 'z'; c = (char)(c + 1))
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(ItemUI, grid.transform.position, Quaternion.identity);
				gameObject.transform.parent = grid.transform;
				gameObject.transform.localScale = Vector3.one;
				gameObject.transform.transform.localRotation = grid.transform.localRotation;
				中 = 取得数据["户广"][0][c.ToString()].ToString().Replace("\"", "");
				if (中 == "")
				{
					gameObject.GetComponent<ImageItem>().内容.text = "-";
					中 = "-";
				}
				else
				{
					gameObject.GetComponent<ImageItem>().内容.text = 中;
				}
				gameObject.GetComponent<ImageItem>().描述.text = 取得数据["户广"][0][c + "2"].ToString().Replace("\"", "");
				gameObject.GetComponent<ImageItem>().字母.text = c.ToString();
				gameObject.GetComponent<ImageItem>().备注.text = 取得数据["户广"][0][c + "3"].ToString().Replace("\"", "");
				if (中 != "" || 中 != null)
				{
					string text = 中.Substring(0, 1);
					string path = 中.Substring(1);
					string s = ((!(text == "井") && !(text == "丰")) ? 转码(中) : 转码(path));
					gameObject.GetComponent<ImageItem>().UpdateImage(s);
				}
			}
			grid.transform.GetChild(24).GetComponent<ImageItem>().是否是最后一个 = true;
			grid.transform.GetChild(24).GetComponent<ImageItem>().内容.text = 点击记录.Peek();
		}
		else
		{
			char c2 = 'a';
			for (int i = 0; i < grid.transform.childCount; i++)
			{
				GameObject gameObject2 = grid.transform.GetChild(i).gameObject;
				中 = 取得数据["户广"][0][c2.ToString()].ToString().Replace("\"", "");
				if (中 == "")
				{
					gameObject2.GetComponent<ImageItem>().内容.text = "-";
					中 = "-";
				}
				else
				{
					gameObject2.GetComponent<ImageItem>().内容.text = 中;
				}
				string text2 = 取得数据["户广"][0][c2 + "2"].ToString().Replace("\"", "");
				gameObject2.GetComponent<ImageItem>().描述.text = text2;
				gameObject2.GetComponent<ImageItem>().字母.text = c2.ToString();
				gameObject2.GetComponent<ImageItem>().备注.text = 取得数据["户广"][0][c2 + "3"].ToString().Replace("\"", "");
				if (中 != "" || 中 != null)
				{
					string text3 = 中.Substring(0, 1);
					string path2 = 中.Substring(1);
					string s2 = ((!(text3 == "井")) ? 转码(中) : 转码(path2));
					gameObject2.GetComponent<ImageItem>().UpdateImage(s2);
				}
				c2 = (char)(c2 + 1);
			}
		}
		grid.transform.GetChild(24).GetComponent<ImageItem>().内容.text = 点击记录.Peek();
	}

	private string 转码(string path)
	{
		string stringToEscape = strPath + path + ".png";
		finalPath = Uri.EscapeUriString(stringToEscape);
		return finalPath;
	}

	private void 确定修改()
	{
		if ((bool)当前点击格子)
		{
			string text = 输入框.transform.Find("InputField/Text").GetComponent<Text>().text;
			string 下标 = "";
			if (当前点击格子.name == "Image01")
			{
				下标 = 当前点击格子.transform.parent.GetComponent<ImageItem>().字母.text + "2";
			}
			else if (当前点击格子.name == "Image02")
			{
				下标 = 当前点击格子.transform.parent.GetComponent<ImageItem>().字母.text + "3";
			}
			修改数据(下标, text);
			输入框.SetActive(value: false);
			当前点击格子 = null;
		}
	}

	private void 取消修改()
	{
		输入框.SetActive(value: false);
	}

	private void 编辑内容(GameObject go)
	{
		当前点击格子 = go;
		输入框.SetActive(value: true);
	}

	public void 修改数据(string 下标, string 新内容)
	{
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		dictionary["户"] = 虚我号;
		dictionary["广"] = rootText.text;
		dictionary["字段"] = 下标;
		dictionary["内容"] = 新内容;
		dictionary["表"] = 表;
		套接.Emit("更改户广", new JSONObject(dictionary));
		跳转(虚我号, rootText.text);
		StartCoroutine("加载数据");
		MonoBehaviour.print("修改数据");
	}

	public void 点击最后一个(GameObject go)
	{
		if (!go.GetComponent<ImageItem>().是否是最后一个)
		{
			上一级目录 = rootText.text;
			点击记录.Push(上一级目录);
		}
		else
		{
			上一级目录 = 点击记录.Pop();
		}
	}

	public void 返回根目录()
	{
		string text = "井虚世界";
		跳转(虚我号, text);
		rootText.text = text;
		StartCoroutine("加载数据");
	}

	public void 恢复默认()
	{
		是否恢复默认 = true;
		string text = rootText.text;
		跳转(默认虚号, text);
		恢复数据();
	}

	private void 恢复数据()
	{
		for (char c = 'a'; c < 'z'; c = (char)(c + 1))
		{
			string text = 默认数据["户广"][0][c.ToString()].ToString().Replace("\"", "");
			string text2 = 取得数据["户广"][0][c.ToString()].ToString().Replace("\"", "");
			string text3 = 默认数据["户广"][0][c + "2"].ToString().Replace("\"", "");
			string text4 = 取得数据["户广"][0][c + "2"].ToString().Replace("\"", "");
			string text5 = 默认数据["户广"][0][c + "3"].ToString().Replace("\"", "");
			string text6 = 取得数据["户广"][0][c + "3"].ToString().Replace("\"", "");
			if (text != text2)
			{
				初始化(虚我号, rootText.text, c.ToString(), text);
			}
			if (text3 != text4)
			{
				初始化(虚我号, rootText.text, c + "2", text3);
			}
			if (text5 != text6)
			{
				初始化(虚我号, rootText.text, c + "3", text5);
			}
		}
		跳转(虚我号, rootText.text);
		StartCoroutine("加载数据");
	}

	public void 初始化(string a, string b, string 字段, string 内容)
	{
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		dictionary["户"] = a;
		dictionary["广"] = b;
		dictionary["字段"] = 字段;
		dictionary["内容"] = 内容;
		dictionary["表"] = 表;
		套接.Emit("更改户广", new JSONObject(dictionary));
		跳转(a, b);
	}

	private void 显示内容(GameObject g, bool b1, bool b2)
	{
		if (!是否编辑)
		{
			for (int i = 0; i < grid.transform.childCount; i++)
			{
				GameObject obj = grid.transform.GetChild(i).gameObject;
				GameObject gameObject = obj.transform.Find("Image01").gameObject;
				GameObject obj2 = obj.transform.Find("Image02").gameObject;
				gameObject.GetComponent<Image>().enabled = false;
				obj2.GetComponent<Image>().enabled = false;
				gameObject.SetActive(b1);
				obj2.SetActive(b2);
			}
		}
	}
}
public class ModelController : MonoBehaviour
{
	private int index = 2;

	public GameObject vr模式;

	public GameObject 普通模式;

	public GameObject pc_井;

	public UnityEngine.UI.Button 展示按钮;

	private bool 是否显示;

	private void Start()
	{
		展示按钮.onClick.AddListener(显示井);
	}

	private void Update()
	{
		if (index == 1)
		{
			vr模式.SetActive(value: false);
			普通模式.SetActive(value: true);
		}
		else
		{
			vr模式.SetActive(value: true);
			普通模式.SetActive(value: false);
		}
	}

	private void 显示井()
	{
		是否显示 = !是否显示;
		pc_井.SetActive(是否显示);
	}
}
public class ReceivesMessage : MonoBehaviour
{
	private GameObject 下载的模型复制品;

	private string[] names;

	private string 开始的模型名字;

	private string webpath;

	private void 清空(string 参数)
	{
	}

	private void 玩虚游(string 数字)
	{
		UnityEngine.Application.OpenURL("E:/VR2045/" + 数字 + "/" + 数字 + ".exe");
	}

	private void 物(string 参数)
	{
		webpath = "http://diywebapp.com/ab/" + 参数 + ".ab";
		MonoBehaviour.print("物()" + webpath);
		StartCoroutine(LoadMainGameObject(webpath));
	}

	private void 令(string 参数)
	{
	}

	private IEnumerator LoadMainGameObject(string path)
	{
		下载的模型复制品 = null;
		MonoBehaviour.print("LoadMainGameObject()模型开始下载");
		WWW bundle = new WWW(path);
		MonoBehaviour.print("LoadMainGameObject()模型下载中");
		yield return bundle;
		if (bundle.error == null)
		{
			MonoBehaviour.print("模型下载完毕");
			names = bundle.assetBundle.GetAllAssetNames();
			AssetBundleRequest request = bundle.assetBundle.LoadAssetAsync(names[0], typeof(GameObject));
			yield return request;
			下载的模型复制品 = UnityEngine.Object.Instantiate(request.asset) as GameObject;
			开始的模型名字 = 下载的模型复制品.name;
			yield return 下载的模型复制品;
			yield return new WaitForSeconds(1f);
			Material[] materials = 下载的模型复制品.GetComponent<MeshRenderer>().materials;
			for (int i = 0; i < materials.Length; i++)
			{
				materials[i].shader = Shader.Find("Standard");
			}
			bundle.assetBundle.Unload(unloadAllLoadedObjects: false);
			Caching.ClearCache();
		}
	}

	public void 放电(string 参数)
	{
		MonoBehaviour.print("放电了");
	}
}
public class Shurufa : MonoBehaviour
{
	public static Shurufa _instance;

	private LineRenderer Line;

	[HideInInspector]
	public Transform 佐;

	private bool 获取到手柄;

	private GameObject 输入法;

	private GameObject 井画布;

	private string 输入法文字 = "";

	private string 获取输入框内容 = "";

	private void Awake()
	{
		_instance = this;
	}

	private void Start()
	{
		获取到手柄 = false;
		井画布 = JingHand._instance.画布;
		输入法 = JingHand._instance.输入法;
	}

	private void Update()
	{
		if ((bool)GameObject.Find("Controller (left)") && !获取到手柄)
		{
			佐 = GameObject.Find("Controller (left)").transform;
			Line = 佐.GetComponent<LineRenderer>();
			Line.startWidth = 0.01f;
			Line.endWidth = 0.01f;
			Line.enabled = false;
			获取到手柄 = true;
		}
	}

	private void FixedUpdate()
	{
		if ((bool)佐)
		{
			if (Physics.Raycast(new Ray(佐.position, 佐.forward), out var hitInfo, 600f, 1 << LayerMask.NameToLayer("JingUI")))
			{
				Line.enabled = true;
				Line.SetPosition(0, 佐.position);
				Line.SetPosition(1, hitInfo.point);
			}
			else
			{
				Line.enabled = false;
			}
		}
	}

	public void 获取输入法内容()
	{
		输入法文字 = 输入法.transform.Find("Canvas/文字").GetComponent<Text>().text;
		JingHand._instance.显示输入法(b: false);
		JingHand._instance.输入框文字处理(输入法文字);
	}

	public void 获取修改内容()
	{
		输入法文字 = 输入法.transform.Find("Canvas/文字").GetComponent<Text>().text;
		JingHand._instance.显示输入法(b: false);
		JingHand._instance.修改内容(JingHand._instance.修改下标, 输入法文字);
	}

	public void 取消输入法()
	{
		JingHand._instance.显示输入法(b: false);
	}
}
public class ButtonTest : MonoBehaviour
{
	private LineRenderer Line;

	[HideInInspector]
	public Transform 佐;

	private bool 获取到手柄;

	public List<GameObject> listObj = new List<GameObject>();

	private GameObject go;

	private void Start()
	{
	}

	private void Update()
	{
		if ((bool)GameObject.Find("Controller (left)") && !获取到手柄)
		{
			佐 = GameObject.Find("Controller (left)").transform;
			Line = 佐.GetComponent<LineRenderer>();
			Line.startWidth = 0.01f;
			Line.endWidth = 0.01f;
			Line.enabled = false;
			获取到手柄 = true;
		}
	}

	private void FixedUpdate()
	{
		if (!佐)
		{
			return;
		}
		if (Physics.Raycast(new Ray(佐.position, 佐.forward), out var hitInfo, 600f, 1 << LayerMask.NameToLayer("JingUI")))
		{
			Line.enabled = true;
			Line.SetPosition(0, 佐.position);
			Line.SetPosition(1, hitInfo.point);
			if (hitInfo.transform.tag == "Change01")
			{
				MonoBehaviour.print(hitInfo.transform.name);
				if (按下扳机())
				{
					go = hitInfo.transform.gameObject;
					go.GetComponent<ButtonTest2>().变大();
				}
			}
		}
		else
		{
			if (go != null)
			{
				go.GetComponent<ButtonTest2>().恢复();
			}
			Line.enabled = false;
		}
	}

	public bool 按下扳机()
	{
		return false;
	}
}
public class ButtonTest2 : MonoBehaviour
{
	public void 变大()
	{
		base.transform.localScale = new Vector3(1.2f, 1.2f, 1.2f);
	}

	public void 恢复()
	{
		base.transform.localScale = Vector3.one;
	}
}
public class 井模块 : MonoBehaviour
{
	public enum CurState
	{
		One,
		Two,
		Three
	}

	public enum OperationState
	{
		KeyBoard,
		InputVR
	}

	public GameObject 当前选择;

	public string 当前虚号 = "150";

	public string 当前虚游 = "家";

	public string 当前虚我 = "10774";

	public static 井模块 _instance;

	public string 虚我号;

	public GameObject grid;

	public GameObject gridSecond;

	public GameObject ItemUI;

	public GameObject ItemUISecond;

	private bool 是否图标切换;

	private string 中;

	private Text rootText;

	private string strPath = "http://224248.com/png/快/";

	private string finalPath;

	public LineRenderer Line;

	public Transform 手柄;

	private Vector3 targetPoint;

	public Transform 图标切换按钮;

	public Transform 编辑切换按钮;

	public Transform 恢复默认按钮;

	public Transform 返回按钮;

	public Transform 执行按钮;

	public Transform 输入按钮;

	public Transform 刷新按钮;

	public Transform 锁定按钮;

	public GameObject Root;

	public GameObject RootSecond;

	public Scrollbar scrollbar;

	private Vector3 oldPos;

	private Vector3 newPos;

	private float y;

	private CurState state;

	private OperationState operationState;

	public bool 是否显示宫格 = true;

	public bool 是否编辑模式;

	private string 输入文字;

	private string 测试修改文字;

	private string 修改文字;

	[HideInInspector]
	public string 字母标志 = "";

	private JSONObject 取得数据;

	private JSONObject 默认数据;

	public GameObject 编辑提示;

	private bool 是否恢复默认;

	public GameObject 输入法;

	[HideInInspector]
	public string 修改新内容 = "";

	[HideInInspector]
	public SocketIOComponent 套接;

	private bool 是否首次运行;

	private KeyCode 当前键盘按键;

	private bool 退出按键;

	private string 临时键盘按键 = "";

	private bool 运行停止;

	public GameObject 输入框;

	private string 获取输入框内容 = "";

	public Transform 输入法出现位置;

	private LeftHand leftHand;

	public GameObject 进度条;

	[HideInInspector]
	public Texture 获取当前图片;

	private string 表 = "az_400";

	private string 默认虚号 = "10000";

	public Text 显示数字;

	public bool 鼠标点击执行;

	public string 传入内容;

	private string 根目录 = "井家";

	private bool 获取到手柄;

	private string 上一级目录 = "-";

	private Stack<string> 点击记录 = new Stack<string>();

	public bool 是否锁定;

	private bool 锁定;

	private void Awake()
	{
		_instance = this;
	}

	private void Start()
	{
		是否编辑模式 = false;
		获取到手柄 = false;
		if (PlayerPrefs.HasKey("虚我号"))
		{
			虚我号 = PlayerPrefs.GetString("虚我号");
		}
		else
		{
			虚我号 = "10774";
		}
		当前键盘按键 = KeyCode.Space;
		根目录 = "井" + 当前虚游;
		点击记录.Push(上一级目录);
		套接 = GC.套接;
		rootText = base.transform.Find("Btn/RootText").GetComponent<Text>();
		StartCoroutine("首次运行");
		Line.SetWidth(0.01f, 0.01f);
		套接.On("户广", 户广);
		鼠标点击执行 = false;
		传入内容 = null;
		leftHand = 手柄.GetComponent<LeftHand>();
	}

	private void OnGUI()
	{
		if (Input.anyKeyDown)
		{
			Event current = Event.current;
			if (current.isKey && !退出按键)
			{
				当前键盘按键 = current.keyCode;
				临时键盘按键 = 当前键盘按键.ToString();
				退出按键 = true;
				运行停止 = false;
			}
		}
		else
		{
			退出按键 = false;
		}
	}

	private void Update()
	{
		if (!运行停止 && !是否编辑模式)
		{
			operationState = OperationState.KeyBoard;
			操作方式();
		}
		if (rootText.text == "界面加载中..." || grid.transform.childCount == 0)
		{
			刷新按钮.gameObject.SetActive(value: true);
		}
		else
		{
			刷新按钮.gameObject.SetActive(value: false);
		}
		显示描述备注信息();
	}

	private void 显示描述备注信息()
	{
		if (rootText.text.Length >= 3)
		{
			if (rootText.text.Substring(0, 3) == "井虚游")
			{
				显示内容(grid, b1: true, b2: true);
			}
		}
		else if (rootText.text == "井拼健身")
		{
			显示内容(grid, b1: false, b2: true);
		}
		else
		{
			显示内容(grid, b1: false, b2: false);
		}
	}

	private IEnumerator 首次运行()
	{
		yield return new WaitForSeconds(1f);
		跳转(虚我号, 根目录);
		rootText.text = 根目录;
	}

	public void 命令(string 参数)
	{
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		dictionary["命令"] = 参数;
		套接.Emit("命令通信", new JSONObject(dictionary));
	}

	public void EnterBtn()
	{
		if ((bool)GameObject.Find("InputField"))
		{
			输入文字 = 输入框.GetComponent<InputField>().text;
			MonoBehaviour.print("EnterBtn()输入文字:" + 输入文字);
			Dictionary<string, string> dictionary = new Dictionary<string, string>();
			dictionary["户"] = 虚我号;
			dictionary["广"] = rootText.text;
			dictionary["字段"] = 字母标志;
			dictionary["内容"] = 输入文字;
			套接.Emit("更改户广", new JSONObject(dictionary));
			跳转(虚我号, rootText.text);
			StartCoroutine("加载数据");
		}
	}

	public void 修改数据(string 下标, string 新内容)
	{
		MonoBehaviour.print("〖井模块〗修改数据()");
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		dictionary["户"] = 虚我号;
		dictionary["广"] = rootText.text;
		dictionary["字段"] = 下标;
		dictionary["内容"] = 新内容;
		dictionary["表"] = 表;
		套接.Emit("更改户广", new JSONObject(dictionary));
		跳转(虚我号, rootText.text);
		StartCoroutine("加载数据");
	}

	private void 射线检测()
	{
		if (!Input.GetMouseButtonDown(0) || !Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out var hitInfo, 600f))
		{
			return;
		}
		if (!是否编辑模式)
		{
			if (hitInfo.collider.tag == "ImageSecond")
			{
				string text = hitInfo.transform.GetComponent<ImageSecondItem>().内容.text;
				MonoBehaviour.print("射线检测() 内容:" + text);
				string text2 = text.Substring(0, 1);
				string text3 = text.Substring(1);
				if (text2 == "#")
				{
					state = CurState.One;
					跳转(虚我号, text3);
					rootText.text = text3;
				}
				else if (text2 == "=")
				{
					state = CurState.Two;
					跳转(虚我号, text3);
					rootText.text = text3;
				}
				else
				{
					BroadcastMessage(text, SendMessageOptions.DontRequireReceiver);
				}
				MonoBehaviour.print(text2);
				MonoBehaviour.print(text3);
			}
			if (hitInfo.collider.tag == "Image")
			{
				中 = hitInfo.transform.GetComponent<ImageItem>().内容.text;
				string text4 = 中.Substring(0, 1);
				string text5 = 中.Substring(1);
				MonoBehaviour.print("#000000:" + text5);
				if (text4 == "井")
				{
					state = CurState.One;
					跳转(虚我号, 中);
					rootText.text = 中;
					StartCoroutine("加载数据");
				}
				else if (text4 == "丰")
				{
					state = CurState.Two;
					跳转(虚我号, 中);
					rootText.text = 中;
					StartCoroutine("加载数据");
				}
				else
				{
					BroadcastMessage(中, SendMessageOptions.DontRequireReceiver);
				}
			}
		}
		else
		{
			输入框.SetActive(value: true);
			if (hitInfo.collider.tag == "ImageSecond")
			{
				测试修改文字 = hitInfo.transform.GetComponent<ImageSecondItem>().内容.text;
				MonoBehaviour.print("内容:" + 测试修改文字);
			}
			if (hitInfo.collider.tag == "Change01")
			{
				MonoBehaviour.print("Image01");
				字母标志 = hitInfo.transform.parent.GetComponent<ImageItem>().字母.text;
				MonoBehaviour.print(字母标志);
			}
			if (hitInfo.collider.tag == "Change02")
			{
				MonoBehaviour.print("Image02");
				字母标志 = hitInfo.transform.parent.GetComponent<ImageItem>().字母.text + "2";
				MonoBehaviour.print(字母标志);
			}
			if (hitInfo.collider.tag == "Change03")
			{
				MonoBehaviour.print("Image02");
				字母标志 = hitInfo.transform.parent.GetComponent<ImageItem>().字母.text + "3";
				MonoBehaviour.print(字母标志);
			}
		}
	}

	private IEnumerator 加载数据()
	{
		yield return new WaitForSeconds(0.5f);
		进度条.SetActive(value: false);
		进度条.transform.Find("Process").GetComponent<Image>().fillAmount = 0f;
		获取数据处理();
	}

	private void FixedUpdate()
	{
		UnityEngine.XR.InputDevice deviceAtXRNode = InputDevices.GetDeviceAtXRNode(XRNode.LeftHand);
		deviceAtXRNode.TryGetFeatureValue(UnityEngine.XR.CommonUsages.triggerButton, out var value);
		if (Physics.Raycast(new Ray(手柄.position, 手柄.forward), out var hitInfo, 600f))
		{
			if (hitInfo.collider.gameObject.layer == 8)
			{
				Line.enabled = true;
				targetPoint = hitInfo.point;
				Line.SetPosition(0, 手柄.position);
				Line.SetPosition(1, hitInfo.point);
			}
			else
			{
				Line.enabled = false;
			}
			if (!是否编辑模式)
			{
				if (hitInfo.transform.CompareTag("ImageFirst"))
				{
					GameObject gameObject = hitInfo.transform.gameObject;
					hitInfo.transform.GetComponent<Image>().color = new Color(1f, 0f, 0f, 1f);
					for (int i = 0; i < grid.transform.childCount; i++)
					{
						GameObject gameObject2 = grid.transform.GetChild(i).gameObject;
						if (gameObject2 != gameObject)
						{
							gameObject2.GetComponent<Image>().color = new Color(1f, 1f, 1f, 1f);
						}
					}
					if (value)
					{
						string text = hitInfo.transform.GetComponent<ImageItem>().内容.text;
						string text2 = text.Substring(0, 1);
						text.Substring(1);
						_ = hitInfo.transform.GetComponent<ImageItem>().字母.text;
						if (text == "聊天")
						{
							ChatController._instance.点击聊天();
							RightHand._instance.gameObject.GetComponent<Collider>().enabled = true;
							OnTrigger._instance.enabled = false;
							followMove._instance.enabled = false;
						}
						else
						{
							ChatController._instance.关闭聊天();
							OnTrigger._instance.enabled = true;
							followMove._instance.enabled = true;
							RightHand._instance.gameObject.GetComponent<Collider>().enabled = false;
						}
						if (text2 == "井")
						{
							StopAllCoroutines();
							if (text.Substring(1, 1) == "换")
							{
								是否图标切换 = false;
							}
							else
							{
								是否图标切换 = true;
							}
							state = CurState.One;
							跳转(虚我号, text);
							rootText.text = text;
							StartCoroutine("加载数据");
							进度条.SetActive(value: true);
							图标切换();
						}
						else if (text2 == "丰")
						{
							StopAllCoroutines();
							state = CurState.Two;
							跳转(虚我号, text);
							rootText.text = text;
							StartCoroutine("加载数据");
							进度条.SetActive(value: true);
						}
						else
						{
							StopAllCoroutines();
							if (rootText.text == "井家")
							{
								jia.CreateInstance().jiafangfa(text);
							}
							else if (rootText.text == "井编辑")
							{
								MonoBehaviour.print("bapojpfjp");
								井法宝.CreateInstance().获取法宝(text);
							}
							else
							{
								if (rootText.text.Substring(0, 2) == "井换")
								{
									获取当前图片 = hitInfo.transform.GetComponent<ImageItem>().格子图片;
								}
								if (rootText.text == "井换照片")
								{
									OnTrigger._instance.换图();
									MonoBehaviour.print("ekjlfjlsf");
								}
								BroadcastMessage(text, SendMessageOptions.DontRequireReceiver);
							}
							LeftHand.是否显示UI = false;
							Line.enabled = false;
						}
					}
				}
			}
			else if (hitInfo.collider.CompareTag("Change01"))
			{
				if (value)
				{
					字母标志 = hitInfo.transform.parent.GetComponent<ImageItem>().字母.text;
					MonoBehaviour.print(字母标志);
					输入法.transform.Find("BtnImage").gameObject.SetActive(value: true);
					关闭碰撞器();
					输入法.transform.position = 输入法出现位置.position;
					输入法.transform.rotation = base.transform.rotation * Quaternion.Euler(-60f, 180f, 0f);
					输入法.GetComponent<Load>().字 = 输入法.transform.Find("BtnImage/获取框/Text").GetComponent<Text>();
					Var.字 = 输入法.transform.Find("BtnImage/获取框/Text").GetComponent<Text>();
				}
			}
			else if (hitInfo.collider.CompareTag("Change02"))
			{
				if (value)
				{
					MonoBehaviour.print("1111111111111:" + hitInfo.transform.name);
					字母标志 = hitInfo.transform.parent.GetComponent<ImageItem>().字母.text + "2";
					输入法.SetActive(value: false);
					输入法.SetActive(value: true);
					输入法.transform.Find("BtnImage").gameObject.SetActive(value: true);
					关闭碰撞器();
					输入法.transform.position = 输入法出现位置.position;
					输入法.transform.rotation = base.transform.rotation * Quaternion.Euler(-60f, 180f, 0f);
					输入法.GetComponent<Load>().字 = 输入法.transform.Find("BtnImage/获取框/Text").GetComponent<Text>();
					Var.字 = 输入法.transform.Find("BtnImage/获取框/Text").GetComponent<Text>();
				}
			}
			else if (hitInfo.collider.CompareTag("Change03") && value)
			{
				MonoBehaviour.print("1111111111111:" + hitInfo.transform.name);
				字母标志 = hitInfo.transform.parent.GetComponent<ImageItem>().字母.text + "3";
				输入法.SetActive(value: false);
				输入法.SetActive(value: true);
				输入法.transform.Find("BtnImage").gameObject.SetActive(value: true);
				关闭碰撞器();
				输入法.transform.position = 输入法出现位置.position;
				输入法.transform.rotation = base.transform.rotation * Quaternion.Euler(-60f, 180f, 0f);
				输入法.GetComponent<Load>().字 = 输入法.transform.Find("BtnImage/获取框/Text").GetComponent<Text>();
				Var.字 = 输入法.transform.Find("BtnImage/获取框/Text").GetComponent<Text>();
			}
			if (hitInfo.transform.CompareTag("InputText") && value)
			{
				输入法.SetActive(value: true);
				输入法.transform.Find("BtnImage").gameObject.SetActive(value: false);
				输入法.transform.position = 输入法出现位置.position;
				输入法.transform.rotation = base.transform.rotation * Quaternion.Euler(-60f, 180f, 0f);
				输入法.GetComponent<Load>().字 = hitInfo.transform.Find("Text").GetComponent<Text>();
				Var.字 = hitInfo.transform.Find("Text").GetComponent<Text>();
			}
			if (hitInfo.transform.CompareTag("EnterBtn") && value)
			{
				获取输入框内容 = 输入框.transform.Find("Text").GetComponent<Text>().text;
				operationState = OperationState.InputVR;
				输入法.SetActive(value: false);
				操作方式();
				输入框.transform.Find("Text").GetComponent<Text>().text = null;
				开启碰撞器();
			}
			if (hitInfo.transform.CompareTag("ClearUp") && value)
			{
				输入法.transform.Find("BtnImage/获取框/Text").GetComponent<Text>().text = null;
				输入框.transform.Find("Text").GetComponent<Text>().text = null;
			}
			if (hitInfo.transform.gameObject.tag == "ImageSecond")
			{
				手柄移动();
				deviceAtXRNode.TryGetFeatureValue(UnityEngine.XR.CommonUsages.primaryButton, out var value2);
				if (value2)
				{
					if (y < 0f)
					{
						scrollbar.value += 0.005f;
					}
					else if (y > 0f)
					{
						scrollbar.value -= 0.005f;
					}
				}
				if (value)
				{
					string text3 = hitInfo.transform.GetComponent<ImageSecondItem>().内容.text;
					string text4 = text3.Substring(0, 1);
					string text5 = text3.Substring(1);
					if (text4 == "井")
					{
						StopAllCoroutines();
						state = CurState.One;
						跳转(虚我号, text5);
						rootText.text = text5;
						StartCoroutine("加载数据");
					}
					else if (text4 == "丰")
					{
						StopAllCoroutines();
						state = CurState.Two;
						跳转(虚我号, text5);
						rootText.text = text5;
						StartCoroutine("加载数据");
					}
					else
					{
						StopAllCoroutines();
						BroadcastMessage(text3, SendMessageOptions.DontRequireReceiver);
						LeftHand.是否显示UI = false;
						base.gameObject.SetActive(value: false);
						Line.enabled = false;
					}
				}
			}
			if (hitInfo.transform.name == "BackBtn")
			{
				按钮放大(返回按钮, 1.1f);
				if (value)
				{
					返回根目录();
				}
			}
			else if (hitInfo.transform.name == "RestoreBtn")
			{
				按钮放大(恢复默认按钮, 1.1f);
				if (value)
				{
					MonoBehaviour.print("恢复默认");
					恢复默认();
				}
			}
			else if (hitInfo.transform.name == "EditorBtn")
			{
				按钮放大(编辑切换按钮, 1.1f);
				if (value)
				{
					功能切换();
				}
			}
			else if (hitInfo.transform.name == "IconBtn")
			{
				按钮放大(图标切换按钮, 1.1f);
				if (value)
				{
					图标切换();
				}
			}
			else
			{
				按钮放大(图标切换按钮, 1f);
				按钮放大(编辑切换按钮, 1f);
				按钮放大(恢复默认按钮, 1f);
				按钮放大(返回按钮, 1f);
			}
		}
		else
		{
			Line.enabled = false;
		}
	}

	public void 按钮放大(Transform 按钮, float 放大倍数)
	{
		按钮.localScale = new Vector3(放大倍数, 放大倍数, 放大倍数);
	}

	public void 按钮恢复()
	{
		按钮放大(图标切换按钮, 1f);
		按钮放大(编辑切换按钮, 1f);
		按钮放大(恢复默认按钮, 1f);
		按钮放大(返回按钮, 1f);
		按钮放大(刷新按钮, 1f);
		按钮放大(锁定按钮, 1f);
		按钮放大(执行按钮, 1f);
		按钮放大(输入按钮, 1f);
	}

	public void 射线结束()
	{
		格子颜色恢复();
		图片颜色恢复("Image01");
		图片颜色恢复("Image02");
	}

	public void 格子颜色恢复()
	{
		for (int i = 0; i < grid.transform.childCount; i++)
		{
			grid.transform.GetChild(i).gameObject.GetComponent<Image>().color = new Color(1f, 1f, 1f, 1f);
		}
	}

	public void 图标切换()
	{
		是否图标切换 = !是否图标切换;
		GameObject gameObject = ((!是否显示宫格) ? gridSecond : grid);
		if (是否图标切换)
		{
			图标切换按钮.Find("Text").GetComponent<Text>().text = "文 字";
			for (int i = 0; i < gameObject.transform.childCount; i++)
			{
				GameObject obj = gameObject.transform.GetChild(i).gameObject;
				obj.transform.Find("Image/Text").gameObject.SetActive(value: false);
				obj.transform.Find("Icon").gameObject.SetActive(value: true);
			}
		}
		else
		{
			图标切换按钮.Find("Text").GetComponent<Text>().text = "图 标";
			for (int j = 0; j < gameObject.transform.childCount; j++)
			{
				GameObject obj2 = gameObject.transform.GetChild(j).gameObject;
				obj2.transform.Find("Image/Text").gameObject.SetActive(value: true);
				obj2.transform.Find("Icon").gameObject.SetActive(value: false);
			}
		}
	}

	public void 获取数据处理()
	{
		switch (state)
		{
		case CurState.One:
		{
			Root.SetActive(value: true);
			if (grid.transform.childCount == 0)
			{
				for (char c = 'a'; c < 'z'; c = (char)(c + 1))
				{
					GameObject gameObject = UnityEngine.Object.Instantiate(ItemUI, grid.transform.position, Quaternion.identity);
					gameObject.transform.parent = grid.transform;
					gameObject.transform.localScale = Vector3.one;
					gameObject.transform.transform.localRotation = grid.transform.localRotation;
					中 = 取得数据["户广"][0][c.ToString()].ToString().Replace("\"", "");
					if (中 == "")
					{
						gameObject.GetComponent<ImageItem>().内容.text = "-";
						中 = "-";
					}
					else
					{
						gameObject.GetComponent<ImageItem>().内容.text = 中;
					}
					gameObject.GetComponent<ImageItem>().描述.text = 取得数据["户广"][0][c + "2"].ToString().Replace("\"", "");
					gameObject.GetComponent<ImageItem>().字母.text = c.ToString();
					gameObject.GetComponent<ImageItem>().备注.text = 取得数据["户广"][0][c + "3"].ToString().Replace("\"", "");
					if (中 != "" || 中 != null)
					{
						string text = 中.Substring(0, 1);
						string path = 中.Substring(1);
						string s = ((!(text == "井") && !(text == "丰")) ? 转码(中) : 转码(path));
						gameObject.GetComponent<ImageItem>().UpdateImage(s);
					}
				}
				grid.transform.GetChild(24).GetComponent<ImageItem>().是否是最后一个 = true;
				grid.transform.GetChild(24).GetComponent<ImageItem>().内容.text = 点击记录.Peek();
				break;
			}
			char c2 = 'a';
			for (int i = 0; i < grid.transform.childCount; i++)
			{
				GameObject gameObject2 = grid.transform.GetChild(i).gameObject;
				中 = 取得数据["户广"][0][c2.ToString()].ToString().Replace("\"", "");
				if (中 == "")
				{
					gameObject2.GetComponent<ImageItem>().内容.text = "-";
					中 = "-";
				}
				else
				{
					gameObject2.GetComponent<ImageItem>().内容.text = 中;
				}
				string text2 = 取得数据["户广"][0][c2 + "2"].ToString().Replace("\"", "");
				gameObject2.GetComponent<ImageItem>().描述.text = text2;
				gameObject2.GetComponent<ImageItem>().字母.text = c2.ToString();
				gameObject2.GetComponent<ImageItem>().备注.text = 取得数据["户广"][0][c2 + "3"].ToString().Replace("\"", "");
				if (中 != "" || 中 != null)
				{
					string text3 = 中.Substring(0, 1);
					string path2 = 中.Substring(1);
					string s2 = ((!(text3 == "井") && !(text3 == "丰")) ? 转码(中) : 转码(path2));
					gameObject2.GetComponent<ImageItem>().UpdateImage(s2);
				}
				c2 = (char)(c2 + 1);
			}
			grid.transform.GetChild(24).GetComponent<ImageItem>().内容.text = 点击记录.Peek();
			break;
		}
		case CurState.Two:
		case CurState.Three:
			break;
		}
	}

	public void 户广(SocketIOEvent 参数)
	{
		if (!是否首次运行)
		{
			是否首次运行 = true;
			StartCoroutine("加载数据");
		}
		if (!是否恢复默认)
		{
			取得数据 = 参数.data;
			return;
		}
		默认数据 = 参数.data;
		是否恢复默认 = false;
	}

	public void 初始化(string a, string b, string 字段, string 内容)
	{
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		dictionary["户"] = a;
		dictionary["广"] = b;
		dictionary["字段"] = 字段;
		dictionary["内容"] = 内容;
		dictionary["表"] = 表;
		套接.Emit("更改户广", new JSONObject(dictionary));
		跳转(a, b);
	}

	public void 跳转(string a, string b)
	{
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		dictionary["户"] = a;
		dictionary["广"] = b;
		dictionary["表"] = 表;
		套接.Emit("加载户广", new JSONObject(dictionary));
	}

	public void 按钮放大2(Transform 按钮, float 放大倍数)
	{
		按钮.localScale = new Vector3(放大倍数, 放大倍数, 放大倍数);
	}

	public void 锁定按钮操作()
	{
		锁定 = !锁定;
		if (锁定)
		{
			锁定按钮.Find("Text").GetComponent<Text>().text = "解 锁";
			是否锁定 = true;
		}
		else
		{
			锁定按钮.Find("Text").GetComponent<Text>().text = "锁 定";
			是否锁定 = false;
		}
	}

	public void 描述备注显示(GameObject g, bool b1, bool b2)
	{
		for (int i = 0; i < g.transform.childCount; i++)
		{
			GameObject obj = g.transform.GetChild(i).gameObject;
			obj.transform.Find("Image/Text").gameObject.SetActive(b1);
			obj.transform.Find("Icon").gameObject.SetActive(b2);
		}
	}

	public void 返回根目录()
	{
		state = CurState.One;
		string text = "井虚世界";
		跳转(虚我号, text);
		rootText.text = text;
		StartCoroutine("加载数据");
	}

	public void 恢复默认()
	{
		是否恢复默认 = true;
		string text = rootText.text;
		跳转(默认虚号, text);
		恢复数据();
	}

	public void 功能切换()
	{
		是否编辑模式 = !是否编辑模式;
		JingHand._instance.编辑模式 = 是否编辑模式;
		if (是否编辑模式)
		{
			图片颜色恢复("Image01");
			图片颜色恢复("Image02");
			编辑提示.SetActive(value: true);
			编辑切换按钮.Find("Text").GetComponent<Text>().text = "执 行";
			MonoBehaviour.print("〖井模块〗功能切换()→编辑模式。即【编】");
			for (int i = 0; i < grid.transform.childCount; i++)
			{
				GameObject obj = grid.transform.GetChild(i).gameObject;
				obj.GetComponent<BoxCollider>().enabled = false;
				obj.transform.Find("Image").gameObject.GetComponent<BoxCollider>().enabled = true;
				obj.transform.Find("Image01").gameObject.SetActive(value: true);
				obj.transform.Find("Image02").gameObject.SetActive(value: true);
			}
		}
		else
		{
			MonoBehaviour.print("〖井模块〗功能切换()→非编辑模式。即【执】");
			输入法.SetActive(value: false);
			编辑切换按钮.Find("Text").GetComponent<Text>().text = "编 辑";
			编辑提示.SetActive(value: false);
			for (int j = 0; j < grid.transform.childCount; j++)
			{
				GameObject obj2 = grid.transform.GetChild(j).gameObject;
				obj2.GetComponent<BoxCollider>().enabled = true;
				obj2.transform.Find("Image").gameObject.GetComponent<BoxCollider>().enabled = false;
				obj2.transform.Find("Image01").gameObject.SetActive(value: false);
				obj2.transform.Find("Image02").gameObject.SetActive(value: false);
			}
		}
	}

	public void 手柄移动()
	{
		newPos = 手柄.position;
		if (!(oldPos == Vector3.zero))
		{
			y = newPos.y - oldPos.y;
		}
		oldPos = newPos;
	}

	public string 转码(string path)
	{
		string stringToEscape = strPath + path + ".png";
		finalPath = Uri.EscapeUriString(stringToEscape);
		return finalPath;
	}

	public void 恢复数据()
	{
		for (char c = 'a'; c < 'z'; c = (char)(c + 1))
		{
			string text = 默认数据["户广"][0][c.ToString()].ToString().Replace("\"", "");
			string text2 = 取得数据["户广"][0][c.ToString()].ToString().Replace("\"", "");
			string text3 = 默认数据["户广"][0][c + "2"].ToString().Replace("\"", "");
			string text4 = 取得数据["户广"][0][c + "2"].ToString().Replace("\"", "");
			string text5 = 默认数据["户广"][0][c + "3"].ToString().Replace("\"", "");
			string text6 = 取得数据["户广"][0][c + "3"].ToString().Replace("\"", "");
			if (text != text2)
			{
				初始化(虚我号, rootText.text, c.ToString(), text);
			}
			if (text3 != text4)
			{
				初始化(虚我号, rootText.text, c + "2", text3);
			}
			if (text5 != text6)
			{
				初始化(虚我号, rootText.text, c + "3", text5);
			}
		}
		跳转(虚我号, rootText.text);
		StartCoroutine("加载数据");
	}

	public void 点击最后一个(GameObject go)
	{
		if (!go.GetComponent<ImageItem>().是否是最后一个)
		{
			上一级目录 = rootText.text;
			点击记录.Push(上一级目录);
		}
		else
		{
			上一级目录 = 点击记录.Pop();
		}
	}

	public void 操作方式()
	{
		GameObject gameObject = ((!是否显示宫格) ? gridSecond : grid);
		switch (operationState)
		{
		case OperationState.KeyBoard:
		{
			if (gameObject.transform.childCount == 0)
			{
				break;
			}
			for (int j = 0; j < gameObject.transform.childCount; j++)
			{
				GameObject gameObject2 = gameObject.transform.GetChild(j).gameObject;
				if (gameObject2.GetComponent<ImageItem>().字母.text == 临时键盘按键.ToLower())
				{
					string text4 = gameObject2.GetComponent<ImageItem>().内容.text;
					string text5 = text4.Substring(0, 1);
					text4.Substring(1);
					if (text5 == "井")
					{
						StopAllCoroutines();
						MonoBehaviour.print("进入跳转");
						state = CurState.One;
						跳转(虚我号, text4);
						点击最后一个(gameObject2);
						rootText.text = text4;
						StartCoroutine("加载数据");
					}
					else
					{
						StopAllCoroutines();
						BroadcastMessage(text4, SendMessageOptions.DontRequireReceiver);
					}
					运行停止 = true;
				}
			}
			break;
		}
		case OperationState.InputVR:
		{
			if (gameObject.transform.childCount == 0)
			{
				break;
			}
			for (int i = 0; i < gameObject.transform.childCount; i++)
			{
				string text = gameObject.transform.GetChild(i).gameObject.GetComponent<ImageItem>().内容.text;
				MonoBehaviour.print("〖井模块〗操作方式()字：" + text);
				string text2 = text.Substring(0, 1);
				string text3 = text.Substring(1);
				if (获取输入框内容 == text3)
				{
					if (text2 == "井")
					{
						StopAllCoroutines();
						MonoBehaviour.print("进入跳转");
						state = CurState.One;
						跳转(虚我号, text);
						rootText.text = text;
						StartCoroutine("加载数据");
					}
					else if (text2 == "丰")
					{
						StopAllCoroutines();
						state = CurState.Two;
						跳转(虚我号, text);
						rootText.text = text;
						StartCoroutine("加载数据");
					}
					else
					{
						StopAllCoroutines();
						MonoBehaviour.print("〖井模块〗操作方式()字：" + text);
						BroadcastMessage(text, SendMessageOptions.DontRequireReceiver);
					}
				}
			}
			break;
		}
		}
	}

	public void 关闭碰撞器()
	{
		for (int i = 0; i < grid.transform.childCount; i++)
		{
			GameObject obj = grid.transform.GetChild(i).gameObject;
			obj.transform.Find("Image").gameObject.GetComponent<BoxCollider>().enabled = false;
			obj.transform.Find("Image01").gameObject.GetComponent<BoxCollider>().enabled = false;
			obj.transform.Find("Image02").gameObject.GetComponent<BoxCollider>().enabled = false;
		}
	}

	public void 开启碰撞器()
	{
		for (int i = 0; i < grid.transform.childCount; i++)
		{
			GameObject obj = grid.transform.GetChild(i).gameObject;
			obj.transform.Find("Image").gameObject.GetComponent<BoxCollider>().enabled = true;
			obj.transform.Find("Image01").gameObject.GetComponent<BoxCollider>().enabled = true;
			obj.transform.Find("Image02").gameObject.GetComponent<BoxCollider>().enabled = true;
		}
	}

	public void 确认修改内容()
	{
		修改新内容 = 输入法.transform.Find("BtnImage/获取框/Text").GetComponent<Text>().text;
		修改数据(字母标志, 修改新内容);
		输入法.SetActive(value: false);
		开启碰撞器();
	}

	public void 退格操作()
	{
		string text = 输入法.transform.Find("BtnImage/获取框/Text").GetComponent<Text>().text;
		text = text.Substring(0, text.Length - 1);
		输入法.transform.Find("BtnImage/获取框/Text").GetComponent<Text>().text = text;
		MonoBehaviour.print("执行退格");
	}

	public void 取消()
	{
		输入法.SetActive(value: false);
		开启碰撞器();
	}

	public void 输入法显示()
	{
		输入法.SetActive(value: true);
		输入法.transform.Find("BtnImage").gameObject.SetActive(value: false);
		关闭碰撞器();
		输入法.transform.position = 输入法出现位置.position;
		输入法.transform.rotation = base.transform.rotation * Quaternion.Euler(-60f, 180f, 0f);
	}

	public void 输入法隐藏()
	{
		Ray_Controller._instance.虚聊面板UI.SetActive(value: false);
		RightController._instance.群UI.SetActive(value: false);
		输入法.SetActive(value: false);
		输入法.transform.Find("BtnImage").gameObject.SetActive(value: true);
	}

	public void 按下扳机执行井(GameObject go)
	{
		string text = go.transform.GetComponent<ImageItem>().内容.text;
		string text2 = text.Substring(0, 1);
		text.Substring(1);
		_ = go.transform.GetComponent<ImageItem>().字母.text;
		if (text2 == "井")
		{
			StopAllCoroutines();
			if (text.Substring(1, 1) == "换")
			{
				是否图标切换 = false;
			}
			else
			{
				是否图标切换 = true;
			}
			state = CurState.One;
			跳转(虚我号, text);
			点击最后一个(go);
			rootText.text = text;
			StartCoroutine("加载数据");
			进度条.SetActive(value: true);
			图标切换();
			return;
		}
		StopAllCoroutines();
		string parameter = "";
		if (rootText.text == "井云加载")
		{
			char[] array = go.transform.GetComponent<ImageItem>().字母.text.ToCharArray();
			if (array[0] >= 'a' && array[0] <= 'j')
			{
				string text3 = go.transform.GetComponent<ImageItem>().内容.text;
				显示数字.text += text3;
			}
		}
		else if (rootText.text.Length >= 2)
		{
			if (rootText.text.Substring(0, 2) == "井换")
			{
				获取当前图片 = go.transform.GetComponent<ImageItem>().格子图片;
			}
		}
		else if (rootText.text.Length >= 3)
		{
			if (rootText.text.Substring(0, 3) == "井虚游")
			{
				string text4 = go.transform.GetComponent<ImageItem>().描述.text;
				BroadcastMessage("玩虚游", text4, SendMessageOptions.DontRequireReceiver);
			}
		}
		else if (rootText.text == "井拼健身")
		{
			string parameter2 = text.Substring(1, text.Length - 1);
			BroadcastMessage("物", parameter2, SendMessageOptions.DontRequireReceiver);
		}
		else if (rootText.text == "井虚令")
		{
			string parameter3 = text.Substring(1, text.Length - 1);
			BroadcastMessage("令", parameter3, SendMessageOptions.DontRequireReceiver);
		}
		BroadcastMessage(text, parameter, SendMessageOptions.DontRequireReceiver);
	}

	public void 执行井宫格(GameObject go)
	{
		go.transform.GetComponent<Image>().color = new Color(1f, 0f, 0f, 1f);
		for (int i = 0; i < grid.transform.childCount; i++)
		{
			GameObject gameObject = grid.transform.GetChild(i).gameObject;
			if (gameObject != go)
			{
				gameObject.GetComponent<Image>().color = new Color(1f, 1f, 1f, 1f);
			}
		}
	}

	private void 显示内容(GameObject g, bool b1, bool b2)
	{
		if (!是否编辑模式)
		{
			for (int i = 0; i < grid.transform.childCount; i++)
			{
				GameObject obj = grid.transform.GetChild(i).gameObject;
				GameObject gameObject = obj.transform.Find("Image01").gameObject;
				GameObject obj2 = obj.transform.Find("Image02").gameObject;
				gameObject.SetActive(b1);
				obj2.SetActive(b2);
			}
		}
	}

	public bool 按下扳机()
	{
		return false;
	}

	public bool 按住扳机()
	{
		return false;
	}

	public bool 抬起扳机()
	{
		return false;
	}

	public void 重新加载当前场景()
	{
		SceneManager.LoadScene(SceneManager.GetActiveScene().name);
	}

	private void 鼠标执行(string 内容)
	{
		if (!是否编辑模式 && 内容 != null)
		{
			string text = 内容.Substring(0, 1);
			内容.Substring(1);
			if (text == "井")
			{
				state = CurState.One;
				跳转(虚我号, 内容);
				rootText.text = 内容;
				StartCoroutine("加载数据");
			}
			else
			{
				BroadcastMessage(内容, "", SendMessageOptions.DontRequireReceiver);
			}
		}
	}

	public void 输入法确定执行()
	{
		获取输入框内容 = 输入框.transform.Find("Text").GetComponent<Text>().text;
		operationState = OperationState.InputVR;
		操作方式();
		输入框.transform.Find("Text").GetComponent<Text>().text = "";
	}

	public void 输入框文字赋值(string str)
	{
		输入框.transform.Find("Text").GetComponent<Text>().text = str;
	}

	public void 修改数据处理(GameObject obj, string tag1, string tag2)
	{
		修改描述(obj);
		描述备注变色(obj, "tag1");
		图片颜色恢复("tag2");
	}

	public void 修改备注(GameObject go)
	{
		字母标志 = go.transform.parent.GetComponent<ImageItem>().字母.text + "2";
		JingHand._instance.修改下标 = 字母标志;
		MonoBehaviour.print(字母标志);
		输入法显示();
	}

	public void 修改描述(GameObject go)
	{
		字母标志 = go.transform.parent.GetComponent<ImageItem>().字母.text + "3";
		输入法显示();
		JingHand._instance.修改下标 = 字母标志;
	}

	public void 描述备注变色(GameObject go, string str)
	{
		if ((bool)go.transform.Find("Image"))
		{
			go.transform.Find("Image").gameObject.SetActive(value: true);
		}
		for (int i = 0; i < grid.transform.childCount; i++)
		{
			GameObject gameObject = grid.transform.GetChild(i).transform.Find(str).gameObject;
			if (gameObject != go)
			{
				gameObject.transform.Find("Image").gameObject.SetActive(value: false);
			}
		}
	}

	public void 图片颜色恢复(string str)
	{
		for (int i = 0; i < grid.transform.childCount; i++)
		{
			grid.transform.GetChild(i).transform.Find(str).gameObject.transform.Find("Image").gameObject.SetActive(value: false);
		}
	}
}
public class Jing_PC2 : MonoBehaviour
{
	public GameObject 当前选择;

	public string 当前虚号 = "150";

	public string 当前虚游 = "虚unity3d";

	public string 当前虚我 = "12101";

	public UnityEngine.UI.Button 图标按钮;

	public UnityEngine.UI.Button 编辑按钮;

	public UnityEngine.UI.Button 返回按钮;

	public UnityEngine.UI.Button 恢复按钮;

	public UnityEngine.UI.Button 锁定按钮;

	public GameObject grid;

	private bool 是否编辑;

	private bool 是否切换图标;

	public string 虚我号;

	private string 表 = "az_400";

	private string 默认虚号 = "10000";

	private string 中;

	private JSONObject 取得数据;

	private JSONObject 默认数据;

	private string strPath = "http://224248.com/png/快/";

	private string finalPath;

	private bool 是否首次运行;

	private bool 是否恢复默认;

	[HideInInspector]
	public SocketIOComponent 套接;

	private string 根目录;

	private Text rootText;

	public GameObject 进度条;

	public GameObject ItemUI;

	public Texture 获取当前图片;

	public static Text 显示数字;

	public UnityEngine.UI.Button 确定按钮;

	public UnityEngine.UI.Button 取消按钮;

	public GameObject 输入框;

	private GameObject 当前点击格子;

	private string 上一级目录 = "-";

	public static Stack<string> 点击记录 = new Stack<string>();

	public bool 是否锁定;

	private bool 锁定;

	private void Start()
	{
		根目录 = "井" + 当前虚游;
		获取虚号();
		图标按钮.onClick.AddListener(图标);
		编辑按钮.onClick.AddListener(编辑);
		确定按钮.onClick.AddListener(确定修改);
		取消按钮.onClick.AddListener(取消修改);
		返回按钮.onClick.AddListener(返回根目录);
		恢复按钮.onClick.AddListener(恢复默认);
		锁定按钮.onClick.AddListener(锁定按钮操作);
		if (!PlayerPrefs.HasKey("点击记录历史"))
		{
			点击记录.Push(上一级目录);
		}
		套接 = GC.套接;
		rootText = base.transform.Find("根目录/RootText").GetComponent<Text>();
		StartCoroutine("首次运行");
		套接.On("户广", 户广);
	}

	private void 获取虚号()
	{
		if (PlayerPrefs.HasKey("虚我号"))
		{
			虚我号 = PlayerPrefs.GetString("虚我号");
		}
		else
		{
			虚我号 = "10774";
		}
	}

	private void Update()
	{
	}

	private void 井_PC(GameObject go)
	{
		string text = go.GetComponent<ImageItem>().内容.text;
		string text2 = text.Substring(0, 1);
		text.Substring(1);
		_ = go.GetComponent<ImageItem>().字母.text;
		if (text2 == "井")
		{
			StopAllCoroutines();
			if (text.Substring(1, 1) == "换")
			{
				是否切换图标 = false;
			}
			else
			{
				是否切换图标 = true;
			}
			跳转(虚我号, text);
			rootText.text = text;
			StartCoroutine("加载数据");
			进度条.SetActive(value: true);
			图标();
			return;
		}
		StopAllCoroutines();
		string parameter = "";
		if (rootText.text == "井云加载")
		{
			char[] array = go.transform.GetComponent<ImageItem>().字母.text.ToCharArray();
			if (array[0] >= 'a' && array[0] <= 'j')
			{
				string text3 = go.transform.GetComponent<ImageItem>().内容.text;
				显示数字.text += text3;
			}
		}
		else if (rootText.text.Substring(0, 2) == "井换")
		{
			获取当前图片 = go.transform.GetComponent<ImageItem>().格子图片;
		}
		else if (rootText.text.Substring(0, 3) == "井虚游")
		{
			string text4 = go.transform.GetComponent<ImageItem>().描述.text;
			BroadcastMessage("玩虚游", text4, SendMessageOptions.DontRequireReceiver);
		}
		else if (rootText.text == "井拼健身")
		{
			string parameter2 = text.Substring(1, text.Length - 1);
			BroadcastMessage("物", parameter2, SendMessageOptions.DontRequireReceiver);
		}
		else if (rootText.text == "井虚令")
		{
			string parameter3 = text.Substring(1, text.Length - 1);
			BroadcastMessage("令", parameter3, SendMessageOptions.DontRequireReceiver);
		}
		BroadcastMessage(text, parameter, SendMessageOptions.DontRequireReceiver);
	}

	private void 编辑()
	{
		是否编辑 = !是否编辑;
		if (是否编辑)
		{
			编辑切换(b1: false, b2: true);
			按钮文字显示(编辑按钮, "指 令");
		}
		else
		{
			编辑切换(b1: true, b2: false);
			按钮文字显示(编辑按钮, "编 辑");
		}
	}

	private void 锁定按钮操作()
	{
		锁定 = !锁定;
		if (锁定)
		{
			按钮文字显示(锁定按钮, "解 锁");
			是否锁定 = true;
		}
		else
		{
			按钮文字显示(锁定按钮, "锁 定");
			是否锁定 = false;
		}
	}

	private void 图标()
	{
		是否切换图标 = !是否切换图标;
		if (是否切换图标)
		{
			图标切换(b: true);
			按钮文字显示(图标按钮, "文 字");
		}
		else
		{
			图标切换(b: false);
			按钮文字显示(图标按钮, "图 标");
		}
	}

	private void 编辑切换(bool b1, bool b2)
	{
		for (int i = 0; i < grid.transform.childCount; i++)
		{
			GameObject obj = grid.transform.GetChild(i).gameObject;
			obj.GetComponent<UnityEngine.UI.Button>().enabled = b1;
			GameObject gameObject = obj.transform.Find("Image").gameObject;
			gameObject.GetComponent<Image>().enabled = b2;
			开启关闭按钮(gameObject, b2);
			GameObject gameObject2 = obj.transform.Find("Image01").gameObject;
			开启关闭按钮(gameObject2, b2);
			GameObject gameObject3 = obj.transform.Find("Image02").gameObject;
			开启关闭按钮(gameObject3, b2);
			gameObject2.SetActive(b2);
			gameObject3.SetActive(b2);
			gameObject2.GetComponent<Image>().enabled = b2;
			gameObject3.GetComponent<Image>().enabled = b2;
		}
	}

	private void 开启关闭按钮(GameObject go, bool b)
	{
		go.GetComponent<UnityEngine.UI.Button>().enabled = b;
	}

	private void 按钮文字显示(UnityEngine.UI.Button btn, string str)
	{
		btn.gameObject.transform.Find("Text").GetComponent<Text>().text = str;
	}

	private void 图标切换(bool b)
	{
		for (int i = 0; i < grid.transform.childCount; i++)
		{
			GameObject obj = grid.transform.GetChild(i).gameObject;
			obj.transform.Find("Icon").gameObject.SetActive(b);
			obj.transform.Find("Image").gameObject.SetActive(!b);
		}
	}

	public void 户广(SocketIOEvent 参数)
	{
		if (!是否首次运行)
		{
			是否首次运行 = true;
			StartCoroutine("加载数据");
		}
		if (!是否恢复默认)
		{
			取得数据 = 参数.data;
			return;
		}
		默认数据 = 参数.data;
		是否恢复默认 = false;
	}

	private IEnumerator 首次运行()
	{
		yield return new WaitForSeconds(1f);
		跳转(虚我号, 根目录);
		rootText.text = 根目录;
	}

	private IEnumerator 加载数据()
	{
		yield return new WaitForSeconds(0.5f);
		进度条.SetActive(value: false);
		进度条.transform.Find("Process").GetComponent<Image>().fillAmount = 0f;
		获取数据处理();
	}

	public void 跳转(string a, string b)
	{
		PlayerPrefs.SetString("历史", b);
		string text = "";
		for (int i = 0; i < 点击记录.Count; i++)
		{
			text = ((!(text == "")) ? (";" + 点击记录.Peek()) : 点击记录.Peek());
		}
		PlayerPrefs.SetString("点击记录历史", text);
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		dictionary["户"] = a;
		dictionary["广"] = b;
		dictionary["表"] = 表;
		套接.Emit("必须从【登录】场景开始.....加载户广", new JSONObject(dictionary));
	}

	private void 获取数据处理()
	{
		if (grid.transform.childCount == 0)
		{
			for (char c = 'a'; c < 'z'; c = (char)(c + 1))
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(ItemUI, grid.transform.position, Quaternion.identity);
				gameObject.transform.parent = grid.transform;
				gameObject.transform.localScale = Vector3.one;
				gameObject.transform.transform.localRotation = grid.transform.localRotation;
				中 = 取得数据["户广"][0][c.ToString()].ToString().Replace("\"", "");
				if (中 == "")
				{
					gameObject.GetComponent<ImageItem>().内容.text = "-";
					中 = "-";
				}
				else
				{
					gameObject.GetComponent<ImageItem>().内容.text = 中;
				}
				gameObject.GetComponent<ImageItem>().描述.text = 取得数据["户广"][0][c + "2"].ToString().Replace("\"", "");
				gameObject.GetComponent<ImageItem>().字母.text = c.ToString();
				gameObject.GetComponent<ImageItem>().备注.text = 取得数据["户广"][0][c + "3"].ToString().Replace("\"", "");
				if (中 != "" || 中 != null)
				{
					string text = 中.Substring(0, 1);
					string path = 中.Substring(1);
					string s = ((!(text == "井") && !(text == "丰")) ? 转码(中) : 转码(path));
					gameObject.GetComponent<ImageItem>().UpdateImage(s);
				}
			}
			return;
		}
		char c2 = 'a';
		for (int i = 0; i < grid.transform.childCount; i++)
		{
			GameObject gameObject2 = grid.transform.GetChild(i).gameObject;
			中 = 取得数据["户广"][0][c2.ToString()].ToString().Replace("\"", "");
			if (中 == "")
			{
				gameObject2.GetComponent<ImageItem>().内容.text = "-";
				中 = "-";
			}
			else
			{
				gameObject2.GetComponent<ImageItem>().内容.text = 中;
			}
			string text2 = 取得数据["户广"][0][c2 + "2"].ToString().Replace("\"", "");
			gameObject2.GetComponent<ImageItem>().描述.text = text2;
			gameObject2.GetComponent<ImageItem>().字母.text = c2.ToString();
			gameObject2.GetComponent<ImageItem>().备注.text = 取得数据["户广"][0][c2 + "3"].ToString().Replace("\"", "");
			if (中 != "" || 中 != null)
			{
				string text3 = 中.Substring(0, 1);
				string path2 = 中.Substring(1);
				string s2 = ((!(text3 == "井")) ? 转码(中) : 转码(path2));
				gameObject2.GetComponent<ImageItem>().UpdateImage(s2);
			}
			c2 = (char)(c2 + 1);
		}
	}

	private string 转码(string path)
	{
		string stringToEscape = strPath + path + ".png";
		finalPath = Uri.EscapeUriString(stringToEscape);
		return finalPath;
	}

	private void 确定修改()
	{
		if ((bool)当前点击格子)
		{
			string text = 输入框.transform.Find("InputField/Text").GetComponent<Text>().text;
			string 下标 = "";
			if (当前点击格子.name == "Image01")
			{
				下标 = 当前点击格子.transform.parent.GetComponent<ImageItem>().字母.text + "2";
			}
			else if (当前点击格子.name == "Image02")
			{
				下标 = 当前点击格子.transform.parent.GetComponent<ImageItem>().字母.text + "3";
			}
			修改数据(下标, text);
			输入框.SetActive(value: false);
			当前点击格子 = null;
		}
	}

	private void 取消修改()
	{
		输入框.SetActive(value: false);
	}

	private void 编辑内容(GameObject go)
	{
		当前点击格子 = go;
		输入框.SetActive(value: true);
	}

	public void 修改数据(string 下标, string 新内容)
	{
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		dictionary["户"] = 虚我号;
		dictionary["广"] = rootText.text;
		dictionary["字段"] = 下标;
		dictionary["内容"] = 新内容;
		dictionary["表"] = 表;
		套接.Emit("更改户广", new JSONObject(dictionary));
		跳转(虚我号, rootText.text);
		StartCoroutine("加载数据");
		MonoBehaviour.print("修改数据");
	}

	public void 返回根目录()
	{
		string text = "井虚世界";
		跳转(虚我号, text);
		rootText.text = text;
		StartCoroutine("加载数据");
	}

	public void 恢复默认()
	{
		是否恢复默认 = true;
		string text = rootText.text;
		跳转(默认虚号, text);
		恢复数据();
	}

	private void 恢复数据()
	{
		for (char c = 'a'; c < 'z'; c = (char)(c + 1))
		{
			string text = 默认数据["户广"][0][c.ToString()].ToString().Replace("\"", "");
			string text2 = 取得数据["户广"][0][c.ToString()].ToString().Replace("\"", "");
			string text3 = 默认数据["户广"][0][c + "2"].ToString().Replace("\"", "");
			string text4 = 取得数据["户广"][0][c + "2"].ToString().Replace("\"", "");
			string text5 = 默认数据["户广"][0][c + "3"].ToString().Replace("\"", "");
			string text6 = 取得数据["户广"][0][c + "3"].ToString().Replace("\"", "");
			if (text != text2)
			{
				初始化(虚我号, rootText.text, c.ToString(), text);
			}
			if (text3 != text4)
			{
				初始化(虚我号, rootText.text, c + "2", text3);
			}
			if (text5 != text6)
			{
				初始化(虚我号, rootText.text, c + "3", text5);
			}
		}
		跳转(虚我号, rootText.text);
		StartCoroutine("加载数据");
	}

	public void 初始化(string a, string b, string 字段, string 内容)
	{
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		dictionary["户"] = a;
		dictionary["广"] = b;
		dictionary["字段"] = 字段;
		dictionary["内容"] = 内容;
		dictionary["表"] = 表;
		套接.Emit("更改户广", new JSONObject(dictionary));
		跳转(a, b);
	}

	private void 显示内容(GameObject g, bool b1, bool b2)
	{
		if (!是否编辑)
		{
			for (int i = 0; i < grid.transform.childCount; i++)
			{
				GameObject obj = grid.transform.GetChild(i).gameObject;
				GameObject gameObject = obj.transform.Find("Image01").gameObject;
				GameObject obj2 = obj.transform.Find("Image02").gameObject;
				gameObject.GetComponent<Image>().enabled = false;
				obj2.GetComponent<Image>().enabled = false;
				gameObject.SetActive(b1);
				obj2.SetActive(b2);
			}
		}
	}
}
public class xupin : MonoBehaviour
{
	public GameObject 井模块;

	public MySocket2 井脚;

	private void Start()
	{
	}

	private void Update()
	{
	}

	public string 井(string 参数 = null)
	{
		井模块.active = true;
		井脚.开始井();
		return "井完";
	}
}
public class TreeViewControl : MonoBehaviour
{
	public delegate void ClickItemdelegate(GameObject item);

	[HideInInspector]
	public List<TreeViewData> Data;

	public List<TreeViewData> datas;

	public GameObject Template;

	public Transform TreeItems;

	public int VerticalItemSpace = 2;

	public int HorizontalItemSpace = 25;

	public int ItemWidth = 230;

	public int ItemHeight = 35;

	private List<GameObject> _treeViewItems;

	private List<GameObject> _treeViewItemsClone;

	private int _yIndex;

	private int _hierarchy;

	private int 编号;

	public static TreeViewControl _instance;

	public Transform TreeView;

	public event ClickItemdelegate ClickItemEvent;

	private void Awake()
	{
		ClickItemEvent += ClickItemTemplate;
		_instance = this;
		datas = new List<TreeViewData>();
	}

	public void ClickItem(GameObject item)
	{
		this.ClickItemEvent(item);
	}

	private void ClickItemTemplate(GameObject item)
	{
	}

	public bool ItemIsCheck(string itemName)
	{
		for (int i = 0; i < _treeViewItems.Count; i++)
		{
			if (_treeViewItems[i].transform.Find("TreeViewText").GetComponent<Text>().text == itemName)
			{
				return _treeViewItems[i].transform.Find("TreeViewToggle").GetComponent<Toggle>().isOn;
			}
		}
		return false;
	}

	public List<string> ItemsIsCheck()
	{
		List<string> list = new List<string>();
		for (int i = 0; i < _treeViewItems.Count; i++)
		{
			if (_treeViewItems[i].transform.Find("TreeViewToggle").GetComponent<Toggle>().isOn)
			{
				list.Add(_treeViewItems[i].transform.Find("TreeViewText").GetComponent<Text>().text);
			}
		}
		return list;
	}

	public void 更改层级(int index)
	{
		Data[index].ParentID = -1;
	}

	public void 变换父物体(GameObject obj1, GameObject obj2)
	{
		int 虚物编号 = obj1.GetComponent<TreeViewButton>().虚物编号;
		int 虚物编号2 = obj2.GetComponent<TreeViewButton>().虚物编号;
		if (虚物编号 > 虚物编号2)
		{
			Data[虚物编号].ParentID = 虚物编号2;
			GlobalObj._instance.第一虚物体.transform.parent = GlobalObj._instance.第二虚物体.transform;
		}
		GenerateTreeView();
		RefreshTreeView();
	}

	public void GenerateTreeView()
	{
		if (_treeViewItems != null)
		{
			for (int i = 0; i < _treeViewItems.Count; i++)
			{
				UnityEngine.Object.Destroy(_treeViewItems[i]);
			}
			_treeViewItems.Clear();
		}
		_treeViewItems = new List<GameObject>();
		for (int j = 0; j < Data.Count; j++)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(Template);
			if (Data[j].ParentID == -1)
			{
				gameObject.GetComponent<TreeViewItem>().SetHierarchy(0);
				gameObject.GetComponent<TreeViewItem>().SetParent(null);
			}
			else
			{
				TreeViewItem component = _treeViewItems[Data[j].ParentID].GetComponent<TreeViewItem>();
				gameObject.GetComponent<TreeViewItem>().SetHierarchy(component.GetHierarchy() + 1);
				gameObject.GetComponent<TreeViewItem>().SetParent(component);
				component.AddChildren(gameObject.GetComponent<TreeViewItem>());
			}
			gameObject.transform.name = "TreeViewItem";
			gameObject.transform.Find("TreeViewText").GetComponent<Text>().text = Data[j].Name;
			gameObject.transform.SetParent(TreeItems);
			gameObject.transform.localPosition = Vector3.zero;
			gameObject.transform.localScale = Vector3.one;
			gameObject.transform.localRotation = Quaternion.Euler(Vector3.zero);
			gameObject.SetActive(value: true);
			_treeViewItems.Add(gameObject);
		}
		for (int k = 0; k < _treeViewItems.Count; k++)
		{
			_treeViewItems[k].GetComponent<TreeViewButton>().虚物编号 = k;
		}
	}

	public void RefreshTreeView()
	{
		_yIndex = 0;
		_hierarchy = 0;
		_treeViewItemsClone = new List<GameObject>(_treeViewItems);
		for (int i = 0; i < _treeViewItemsClone.Count; i++)
		{
			if (!(_treeViewItemsClone[i] == null) && _treeViewItemsClone[i].activeSelf)
			{
				TreeViewItem component = _treeViewItemsClone[i].GetComponent<TreeViewItem>();
				_treeViewItemsClone[i].GetComponent<RectTransform>().localPosition = new Vector3(component.GetHierarchy() * HorizontalItemSpace, _yIndex, 0f);
				_yIndex += -(ItemHeight + VerticalItemSpace);
				if (component.GetHierarchy() > _hierarchy)
				{
					_hierarchy = component.GetHierarchy();
				}
				if (component.IsExpanding)
				{
					RefreshTreeViewChild(component);
				}
				_treeViewItemsClone[i] = null;
			}
		}
		float x = _hierarchy * HorizontalItemSpace + ItemWidth;
		float y = Mathf.Abs(_yIndex);
		TreeView.GetComponent<ScrollRect>().content.sizeDelta = new Vector2(x, y);
		_treeViewItemsClone.Clear();
	}

	private void RefreshTreeViewChild(TreeViewItem tvi)
	{
		for (int i = 0; i < tvi.GetChildrenNumber(); i++)
		{
			tvi.GetChildrenByIndex(i).gameObject.GetComponent<RectTransform>().localPosition = new Vector3(tvi.GetChildrenByIndex(i).GetHierarchy() * HorizontalItemSpace, _yIndex, 0f);
			_yIndex += -(ItemHeight + VerticalItemSpace);
			if (tvi.GetChildrenByIndex(i).GetHierarchy() > _hierarchy)
			{
				_hierarchy = tvi.GetChildrenByIndex(i).GetHierarchy();
			}
			if (tvi.GetChildrenByIndex(i).IsExpanding)
			{
				RefreshTreeViewChild(tvi.GetChildrenByIndex(i));
			}
			int num = _treeViewItemsClone.IndexOf(tvi.GetChildrenByIndex(i).gameObject);
			if (num >= 0)
			{
				_treeViewItemsClone[num] = null;
			}
		}
	}

	public void 新建物体属性(GameObject obj, string name, int index = -1)
	{
		int 虚物体id = GlobalObj._instance.虚物体id;
		obj.AddComponent<ObjectID>().ID = 虚物体id;
		obj.transform.position = Vector3.zero;
		obj.name = name + "(" + 虚物体id + ")";
		CreateObjectManager._instance.AddGameObjectInList(虚物体id, obj);
		添加数据(obj, index);
		更新数据();
		GlobalObj._instance.虚物体id++;
	}

	private void 加入虚物(GameObject go)
	{
		if ((bool)GameObject.Find("虚物"))
		{
			go.transform.parent = GameObject.Find("虚物").transform;
		}
	}

	public void 更新数据()
	{
		Data = datas;
		GenerateTreeView();
		RefreshTreeView();
	}

	public void 添加数据(GameObject obj, int index)
	{
		TreeViewData treeViewData = new TreeViewData();
		treeViewData.Name = obj.name;
		treeViewData.ParentID = index;
		datas.Add(treeViewData);
	}
}
public class TreeViewData
{
	public string Name;

	public int ParentID;
}
public class TreeViewItem : MonoBehaviour
{
	public TreeViewControl Controler;

	public bool IsExpanding;

	private int _hierarchy;

	private TreeViewItem _parent;

	private List<TreeViewItem> _children;

	private void Awake()
	{
		base.transform.Find("ContextButton").GetComponent<UnityEngine.UI.Button>().onClick.AddListener(ContextButtonClick);
		base.transform.Find("TreeViewButton").GetComponent<UnityEngine.UI.Button>().onClick.AddListener(delegate
		{
			Controler.ClickItem(base.gameObject);
		});
	}

	private void ContextButtonClick()
	{
		if (IsExpanding)
		{
			base.transform.Find("ContextButton").GetComponent<RectTransform>().localRotation = Quaternion.Euler(0f, 0f, 90f);
			IsExpanding = false;
			ChangeChildren(this, value: false);
		}
		else
		{
			base.transform.Find("ContextButton").GetComponent<RectTransform>().localRotation = Quaternion.Euler(0f, 0f, 0f);
			IsExpanding = true;
			ChangeChildren(this, value: true);
		}
		Controler.RefreshTreeView();
	}

	private void ChangeChildren(TreeViewItem tvi, bool value)
	{
		for (int i = 0; i < tvi.GetChildrenNumber(); i++)
		{
			tvi.GetChildrenByIndex(i).gameObject.SetActive(value);
			ChangeChildren(tvi.GetChildrenByIndex(i), value);
		}
	}

	public int GetHierarchy()
	{
		return _hierarchy;
	}

	public void SetHierarchy(int hierarchy)
	{
		_hierarchy = hierarchy;
	}

	public TreeViewItem GetParent()
	{
		return _parent;
	}

	public void SetParent(TreeViewItem parent)
	{
		_parent = parent;
	}

	public void AddChildren(TreeViewItem children)
	{
		if (_children == null)
		{
			_children = new List<TreeViewItem>();
		}
		_children.Add(children);
	}

	public void RemoveChildren(TreeViewItem children)
	{
		if (_children != null)
		{
			_children.Remove(children);
		}
	}

	public void RemoveChildren(int index)
	{
		if (_children != null && index >= 0 && index < _children.Count)
		{
			_children.RemoveAt(index);
		}
	}

	public int GetChildrenNumber()
	{
		if (_children == null)
		{
			return 0;
		}
		return _children.Count;
	}

	public TreeViewItem GetChildrenByIndex(int index)
	{
		if (index >= _children.Count)
		{
			return null;
		}
		return _children[index];
	}
}
public class AudioPanel : MonoBehaviour
{
	public static AudioPanel _instance;

	public Scrollbar 音量滑块;

	public Text 音量值;

	public Scrollbar 音调滑块;

	public Text 音调值;

	private GameObject tempObj;

	private void Awake()
	{
		if (_instance == null)
		{
			_instance = this;
		}
	}

	private void Update()
	{
		ShowAudioInfo();
	}

	private void ShowAudioInfo()
	{
		if ((bool)GlobalObj._instance.当前选择物体 && (bool)GlobalObj._instance.当前选择物体.GetComponent<AudioSource>())
		{
			tempObj = GlobalObj._instance.当前选择物体;
			float value = 音量滑块.value;
			音量值.text = value.ToString() ?? "";
			tempObj.GetComponent<AudioSource>().volume = value;
			float value2 = 音调滑块.value;
			音调值.text = (value2 * 3f).ToString() ?? "";
			tempObj.GetComponent<AudioSource>().pitch = value2 * 3f;
		}
	}

	public void 位置归零(GameObject obj)
	{
		if ((bool)obj.GetComponent<AudioSource>())
		{
			float volume = obj.GetComponent<AudioSource>().volume;
			float pitch = obj.GetComponent<AudioSource>().pitch;
			音量滑块.value = volume;
			音调滑块.value = pitch;
		}
	}
}
public class ButtonGameObject : MonoBehaviour
{
	public int 虚物编号;

	private string _name;

	private int id;

	public string Name
	{
		get
		{
			return _name;
		}
		set
		{
			_name = value;
		}
	}

	public int ID
	{
		get
		{
			return id;
		}
		set
		{
			id = value;
		}
	}

	private void Start()
	{
		虚物编号 = 0;
		base.transform.GetComponent<UnityEngine.UI.Button>().onClick.AddListener(获取物体);
	}

	private void 获取物体()
	{
		int num = base.transform.parent.GetComponent<TreeViewButton>().虚物编号;
		GameObject gameobjectById = CreateObjectManager._instance.GetGameobjectById(num);
		if (GlobalObj._instance.当前选择物体 == gameobjectById)
		{
			移动视图();
		}
		else
		{
			GlobalObj._instance.当前选择物体 = gameobjectById;
		}
		GlobalObj._instance.临时物体 = gameobjectById;
		TransformPanel._instance.位置归零(GlobalObj._instance.临时物体);
		RigidbodyPanel._instance.位置归零(GlobalObj._instance.临时物体);
		LightPanel._instance.位置归零(GlobalObj._instance.临时物体);
		AudioPanel._instance.位置归零(GlobalObj._instance.临时物体);
		GetAttributesPlane._instance.获取物体属性(GlobalObj._instance.临时物体);
		if (GlobalObj._instance.第一物体 == null && GlobalObj._instance.第二物体 == null)
		{
			GlobalObj._instance.第一物体 = base.transform.parent.gameObject;
			GlobalObj._instance.第一虚物体 = CreateObjectManager._instance.GetGameobjectById(num);
		}
		else if (GlobalObj._instance.第一物体 != null && GlobalObj._instance.第二物体 == null)
		{
			GlobalObj._instance.第二物体 = base.transform.parent.gameObject;
			GlobalObj._instance.第二虚物体 = CreateObjectManager._instance.GetGameobjectById(num);
			TreeViewControl._instance.变换父物体(GlobalObj._instance.第一物体, GlobalObj._instance.第二物体);
			GlobalObj._instance.第一物体 = null;
			GlobalObj._instance.第二物体 = null;
			GlobalObj._instance.第一虚物体 = null;
			GlobalObj._instance.第二虚物体 = null;
		}
	}

	private void 移动视图()
	{
		GameObject gameObject = GameObject.Find("[CameraRig]");
		Transform transform = gameObject.transform.Find("Camera (eye)/Pos");
		if ((bool)GlobalObj._instance.当前选择物体)
		{
			Vector3 position = GlobalObj._instance.当前选择物体.transform.position - transform.localPosition - transform.parent.transform.localPosition;
			gameObject.transform.position = position;
		}
	}
}
public class ClearObjButton : MonoBehaviour
{
	private void Start()
	{
		base.transform.GetComponent<UnityEngine.UI.Button>().onClick.AddListener(清空当前物体);
	}

	private void 清空当前物体()
	{
		GlobalObj._instance.清空物体();
	}
}
public class CreateObjectManager : MonoBehaviour
{
	public static CreateObjectManager _instance;

	public Text 当前选中物体;

	public Dictionary<int, GameObject> 游物 = new Dictionary<int, GameObject>();

	private void Awake()
	{
		if (_instance == null)
		{
			_instance = this;
		}
	}

	private void Start()
	{
		清空字典();
	}

	private void Update()
	{
		if ((bool)GlobalObj._instance.当前选择物体)
		{
			当前选中物体.text = GlobalObj._instance.当前选择物体.name;
		}
		else
		{
			当前选中物体.text = "";
		}
	}

	public GameObject GetGameobjectById(int id)
	{
		if (游物.ContainsKey(id))
		{
			return 游物[id];
		}
		return null;
	}

	public void AddGameObjectInList(int id, GameObject obj)
	{
		if (!游物.ContainsKey(id))
		{
			游物.Add(id, obj);
		}
	}

	private void 清空字典()
	{
		for (int i = 0; i < 游物.Count; i++)
		{
			游物.Remove(0);
		}
		游物.Clear();
	}
}
public class DragBase : MonoBehaviour, IPointerDownHandler, IEventSystemHandler, IDragHandler
{
	private Vector2 Local_Pointer_Position;

	private Vector3 Panel_Local_Position;

	public RectTransform targetObject;

	private RectTransform parentRectTransform;

	private RectTransform targetRectTransform;

	private void Awake()
	{
		if (targetObject == null)
		{
			targetObject = base.transform as RectTransform;
		}
		parentRectTransform = targetObject.parent as RectTransform;
		targetRectTransform = targetObject;
	}

	public void OnPointerDown(PointerEventData data)
	{
		Panel_Local_Position = targetRectTransform.localPosition;
		RectTransformUtility.ScreenPointToLocalPointInRectangle(parentRectTransform, data.position, data.pressEventCamera, out Local_Pointer_Position);
		targetObject.gameObject.transform.SetAsLastSibling();
	}

	public void OnDrag(PointerEventData data)
	{
		if (RectTransformUtility.ScreenPointToLocalPointInRectangle(parentRectTransform, data.position, data.pressEventCamera, out var localPoint))
		{
			Vector3 vector = localPoint - Local_Pointer_Position;
			targetObject.localPosition = Panel_Local_Position + vector;
		}
	}
}
public class GetAttributesPlane : MonoBehaviour
{
	public static GetAttributesPlane _instance;

	public GameObject 位置面板;

	public GameObject 灯光面板;

	public GameObject 刚体面板;

	public GameObject 声音面板;

	public GameObject Content;

	private int _yIndex;

	private int posY;

	private bool isLight;

	private bool isRig;

	private bool isAudio;

	public List<GameObject> 当前激活面板 = new List<GameObject>();

	public GameObject 属性面板;

	private void Awake()
	{
		_instance = this;
	}

	private void Start()
	{
		灯光面板.SetActive(value: false);
		声音面板.SetActive(value: false);
		刚体面板.SetActive(value: false);
	}

	private void Update()
	{
		if (GlobalObj._instance.当前选择物体 == null)
		{
			面板初始化();
		}
	}

	private void 清空数组()
	{
		当前激活面板.Clear();
	}

	public void 获取物体属性(GameObject obj)
	{
		面板初始化();
		位置面板.SetActive(value: true);
		if (!obj)
		{
			return;
		}
		UnityEngine.Component[] components = obj.GetComponents<UnityEngine.Component>();
		foreach (UnityEngine.Component obj2 in components)
		{
			if (obj2.GetType() == typeof(Light))
			{
				isLight = true;
			}
			if (obj2.GetType() == typeof(Rigidbody))
			{
				isRig = true;
			}
			if (obj2.GetType() == typeof(AudioSource))
			{
				isAudio = true;
			}
		}
		属性面板显示();
		更新显示位置();
	}

	private void 面板初始化()
	{
		灯光面板.SetActive(value: false);
		声音面板.SetActive(value: false);
		刚体面板.SetActive(value: false);
		位置面板.SetActive(value: false);
		isLight = false;
		isRig = false;
		isAudio = false;
		清空数组();
		属性面板.transform.Find("Scroll View").GetComponent<ScrollRect>().content.sizeDelta = new Vector2(310f, 315f);
	}

	private void 更新显示位置()
	{
		_yIndex = 0;
		int childCount = Content.transform.childCount;
		int num = 0;
		for (int i = 0; i < childCount; i++)
		{
			GameObject gameObject = Content.transform.GetChild(i).gameObject;
			if (gameObject.activeSelf)
			{
				当前激活面板.Add(gameObject);
				num++;
			}
		}
		for (int j = 0; j < 当前激活面板.Count; j++)
		{
			GameObject gameObject2 = 当前激活面板[j];
			if (j == 0)
			{
				posY = 100;
			}
			else
			{
				posY = (int)当前激活面板[j - 1].GetComponent<RectTransform>().localPosition.y;
			}
			Vector2 size = gameObject2.GetComponent<RectTransform>().rect.size;
			_yIndex += (int)size.y;
			int num2 = posY - (int)size.y + 50;
			if (j == 0)
			{
				当前激活面板[0].GetComponent<RectTransform>().localPosition = new Vector3(150f, -50f, 0f);
			}
			else
			{
				gameObject2.GetComponent<RectTransform>().localPosition = new Vector3(150f, num2, 0f);
			}
		}
		float y = Mathf.Abs(_yIndex);
		属性面板.transform.Find("Scroll View").GetComponent<ScrollRect>().content.sizeDelta = new Vector2(310f, y);
	}

	private void 属性面板显示()
	{
		if (isLight)
		{
			灯光面板.SetActive(value: true);
		}
		else
		{
			灯光面板.SetActive(value: false);
		}
		if (isRig)
		{
			刚体面板.SetActive(value: true);
		}
		else
		{
			刚体面板.SetActive(value: false);
		}
		if (isAudio)
		{
			声音面板.SetActive(value: true);
		}
		else
		{
			声音面板.SetActive(value: false);
		}
	}
}
public class GlobalObj : MonoBehaviour
{
	public GameObject 当前选择物体;

	public int 虚物体id;

	[HideInInspector]
	public GameObject 第一物体;

	[HideInInspector]
	public GameObject 第二物体;

	[HideInInspector]
	public GameObject 第一虚物体;

	[HideInInspector]
	public GameObject 第二虚物体;

	[HideInInspector]
	public GameObject 临时物体;

	public static GlobalObj _instance;

	private void Awake()
	{
		if (_instance == null)
		{
			_instance = this;
		}
	}

	public void 清空物体()
	{
		当前选择物体 = null;
		第一物体 = null;
		第二物体 = null;
		第一虚物体 = null;
		第二虚物体 = null;
	}
}
public class LightPanel : MonoBehaviour
{
	public Scrollbar 强度滑块;

	public Scrollbar 弹性强度滑块;

	public Scrollbar 范围滑块;

	public Text 强度滑块数值;

	public Text 弹性强度滑块数值;

	public Text 范围滑块数值;

	public Dropdown dropDown1;

	public GameObject 范围面板;

	private GameObject tempObj;

	public UnityEngine.UI.Button 修改颜色按钮;

	public GameObject 颜色面板;

	public GameObject 普通属性面板;

	public UnityEngine.UI.Button 关闭按钮;

	public static LightPanel _instance;

	private void Awake()
	{
		if (_instance == null)
		{
			_instance = this;
		}
	}

	private void Start()
	{
		修改颜色按钮.onClick.AddListener(修改颜色);
		关闭按钮.onClick.AddListener(关闭灯光按钮);
		颜色面板.SetActive(value: false);
	}

	private void Update()
	{
		显示数值();
	}

	private void 显示数值()
	{
		if ((bool)GlobalObj._instance.当前选择物体 && (bool)GlobalObj._instance.当前选择物体.GetComponent<Light>())
		{
			tempObj = GlobalObj._instance.当前选择物体;
			int num = Mathf.RoundToInt(强度滑块.value * 8f);
			强度滑块数值.text = num.ToString() ?? "";
			int num2 = Mathf.RoundToInt(弹性强度滑块.value * 8f);
			弹性强度滑块数值.text = num2.ToString() ?? "";
			tempObj.GetComponent<Light>().intensity = num;
			tempObj.GetComponent<Light>().bounceIntensity = num2;
			int value = dropDown1.value;
			显示灯光类型(value);
		}
	}

	private void 显示灯光类型(int index)
	{
		switch (index)
		{
		case 0:
			tempObj.GetComponent<Light>().type = LightType.Directional;
			范围面板.SetActive(value: false);
			break;
		case 1:
			tempObj.GetComponent<Light>().type = LightType.Point;
			范围面板.SetActive(value: true);
			范围数值();
			break;
		case 2:
			tempObj.GetComponent<Light>().type = LightType.Spot;
			范围面板.SetActive(value: true);
			范围数值();
			break;
		case 3:
			tempObj.GetComponent<Light>().type = LightType.Area;
			范围面板.SetActive(value: false);
			break;
		}
	}

	private void 范围数值()
	{
		int num = Mathf.RoundToInt(范围滑块.value * 100f);
		tempObj.GetComponent<Light>().range = num;
		范围滑块数值.text = num.ToString() ?? "";
	}

	private void 修改颜色()
	{
		颜色面板.SetActive(value: true);
		普通属性面板.SetActive(value: false);
	}

	private void 关闭灯光按钮()
	{
		颜色面板.SetActive(value: false);
		普通属性面板.SetActive(value: true);
	}

	public void 位置归零(GameObject obj)
	{
		if ((bool)obj.GetComponent<Light>())
		{
			强度滑块.value = obj.GetComponent<Light>().intensity / 8f;
			弹性强度滑块.value = obj.GetComponent<Light>().bounceIntensity / 8f;
			范围滑块.value = obj.GetComponent<Light>().range / 100f;
			修改颜色按钮.gameObject.GetComponent<Image>().color = obj.GetComponent<Light>().color;
			dropDown1.value = 反转灯光类型(obj);
		}
	}

	private int 反转灯光类型(GameObject obj)
	{
		if (obj.GetComponent<Light>().type == LightType.Directional)
		{
			return 0;
		}
		if (obj.GetComponent<Light>().type == LightType.Point)
		{
			return 1;
		}
		if (obj.GetComponent<Light>().type == LightType.Spot)
		{
			return 2;
		}
		if (obj.GetComponent<Light>().type == LightType.Area)
		{
			return 3;
		}
		return 0;
	}
}
public class LineDemo : MonoBehaviour
{
	[HideInInspector]
	public Sprite colorBoard;

	private LineRenderer line;

	[HideInInspector]
	public Texture2D c;

	[HideInInspector]
	public Texture2D b;

	public GameObject 颜色修改器;

	private void Start()
	{
		line = base.transform.GetComponent<LineRenderer>();
		line.startWidth = 0.01f;
		line.endWidth = 0.01f;
	}

	private void Update()
	{
		Ray ray = new Ray(base.transform.position, base.transform.forward);
		if (Physics.Raycast(ray, out var hitInfo, 600f, 1 << LayerMask.NameToLayer("ColorUIPlane")))
		{
			b = hitInfo.collider.gameObject.GetComponent<Renderer>().material.mainTexture as Texture2D;
			line.SetPosition(0, base.transform.position);
			line.SetPosition(1, hitInfo.point);
			Vector2 textureCoord = hitInfo.textureCoord2;
			textureCoord.x *= b.width;
			textureCoord.y *= b.height;
			Color pixel = b.GetPixel((int)textureCoord.x, (int)textureCoord.y);
			if (按下扳机())
			{
				if (GlobalObj._instance.临时物体 != null && (bool)GlobalObj._instance.临时物体.GetComponent<Light>())
				{
					GlobalObj._instance.临时物体.GetComponent<Light>().color = pixel;
				}
				颜色修改器.GetComponent<Image>().color = pixel;
			}
		}
		if (Physics.Raycast(ray, out hitInfo, 1000f))
		{
			b = hitInfo.collider.gameObject.GetComponent<Renderer>().material.mainTexture as Texture2D;
			line.SetPosition(0, base.transform.position);
			line.SetPosition(1, hitInfo.point);
		}
	}

	public bool 按下扳机()
	{
		return false;
	}
}
public class ObjectID : MonoBehaviour
{
	public int ID;
}
public class ReceivesMessage_unity : MonoBehaviour
{
	private void 更新数据()
	{
		TreeViewControl._instance.更新数据();
	}

	private void 新建物体属性(GameObject obj1, string name, int index = -1)
	{
		TreeViewControl._instance.新建物体属性(obj1, name, index);
	}

	public void 建空(string 参数)
	{
		GameObject obj = new GameObject("GameObject");
		新建物体属性(obj, "空物体");
	}

	public void 建子空(string 参数)
	{
		if ((bool)GlobalObj._instance.当前选择物体)
		{
			GameObject 当前选择物体 = GlobalObj._instance.当前选择物体;
			GameObject gameObject = new GameObject("GameObject");
			int 虚物体id = GlobalObj._instance.虚物体id;
			gameObject.transform.parent = 当前选择物体.transform;
			gameObject.transform.localPosition = Vector3.zero;
			gameObject.name = "空物体(" + 虚物体id + ")";
			CreateObjectManager._instance.AddGameObjectInList(虚物体id, gameObject);
			int iD = 当前选择物体.GetComponent<ObjectID>().ID;
			新建物体属性(gameObject, "空物体", iD);
		}
	}

	public void 清父(string 参数)
	{
		if ((bool)GlobalObj._instance.当前选择物体)
		{
			GameObject 当前选择物体 = GlobalObj._instance.当前选择物体;
			int iD = 当前选择物体.GetComponent<ObjectID>().ID;
			TreeViewControl._instance.更改层级(iD);
			更新数据();
			当前选择物体.transform.parent = null;
		}
	}

	public void 切换活跃状态(string 参数)
	{
		if ((bool)GlobalObj._instance.当前选择物体)
		{
			bool activeSelf = GlobalObj._instance.当前选择物体.activeSelf;
			GlobalObj._instance.当前选择物体.SetActive(!activeSelf);
		}
	}

	public void 造父(string 参数)
	{
		if ((bool)GlobalObj._instance.当前选择物体)
		{
			int iD = GlobalObj._instance.当前选择物体.GetComponent<ObjectID>().ID;
			TreeViewControl._instance.更改层级(iD);
			更新数据();
		}
	}

	public void 立方体(string 参数)
	{
		GameObject obj = GameObject.CreatePrimitive(PrimitiveType.Cube);
		新建物体属性(obj, "立方体");
	}

	public void 长方体(string 参数)
	{
		GameObject gameObject = GameObject.CreatePrimitive(PrimitiveType.Cube);
		gameObject.transform.localScale = new Vector3(2f, 1f, 1f);
		新建物体属性(gameObject, "长方体");
	}

	public void 球体(string 参数)
	{
		GameObject obj = GameObject.CreatePrimitive(PrimitiveType.Sphere);
		新建物体属性(obj, "球体");
	}

	public void 胶囊(string 参数)
	{
		GameObject obj = GameObject.CreatePrimitive(PrimitiveType.Capsule);
		新建物体属性(obj, "胶囊");
	}

	public void 圆柱体(string 参数)
	{
		GameObject obj = GameObject.CreatePrimitive(PrimitiveType.Cylinder);
		新建物体属性(obj, "圆柱体");
	}

	public void 平面(string 参数)
	{
		GameObject obj = GameObject.CreatePrimitive(PrimitiveType.Plane);
		新建物体属性(obj, "平面");
	}

	public void 四边形(string 参数)
	{
		GameObject obj = GameObject.CreatePrimitive(PrimitiveType.Quad);
		新建物体属性(obj, "四边形");
	}

	public void 地形(string 参数)
	{
		GameObject gameObject = new GameObject("Terrain");
		TerrainData terrainData = new TerrainData();
		gameObject.AddComponent<Terrain>();
		gameObject.GetComponent<Terrain>().terrainData = terrainData;
		gameObject.AddComponent<TerrainCollider>();
		gameObject.GetComponent<TerrainCollider>().terrainData = terrainData;
		新建物体属性(gameObject, "地形");
	}

	public void 树型(string 参数)
	{
		GameObject obj = UnityEngine.Object.Instantiate(Resources.Load("Tree") as GameObject);
		新建物体属性(obj, "树型");
	}

	public void 文本(string 参数)
	{
		GameObject obj = UnityEngine.Object.Instantiate(Resources.Load("New Text") as GameObject);
		新建物体属性(obj, "3d文本");
		MonoBehaviour.print("3d文本！");
	}

	public void 定向光(string 参数)
	{
		GameObject gameObject = new GameObject("Directional Light");
		gameObject.AddComponent<Light>();
		gameObject.GetComponent<Light>().type = LightType.Directional;
		新建物体属性(gameObject, "定向光");
	}

	public void 点光(string 参数)
	{
		GameObject gameObject = new GameObject("Point light");
		gameObject.AddComponent<Light>();
		gameObject.GetComponent<Light>().type = LightType.Point;
		新建物体属性(gameObject, "点光");
	}

	public void 聚光灯(string 参数)
	{
		GameObject gameObject = new GameObject("Spotlight");
		gameObject.AddComponent<Light>();
		gameObject.GetComponent<Light>().type = LightType.Spot;
		新建物体属性(gameObject, "聚光灯");
	}

	public void 区域光(string 参数)
	{
		GameObject gameObject = new GameObject("Area Light");
		gameObject.AddComponent<Light>();
		gameObject.GetComponent<Light>().type = LightType.Area;
		新建物体属性(gameObject, "区域光");
	}

	public void 反应探头(string 参数)
	{
		GameObject gameObject = new GameObject("Reflection Probe");
		gameObject.AddComponent<ReflectionProbe>();
		新建物体属性(gameObject, "反应探头");
	}

	public void 光探测组(string 参数)
	{
		GameObject gameObject = new GameObject("Light Probe Group");
		gameObject.AddComponent<LightProbeGroup>();
		新建物体属性(gameObject, "光探测组");
	}

	public void 音频源(string 参数)
	{
		GameObject gameObject = new GameObject("Audio Source");
		gameObject.AddComponent<AudioSource>();
		新建物体属性(gameObject, "Audio Source");
	}

	public void 音频混响区(string 参数)
	{
		GameObject gameObject = new GameObject("Reverb Zone");
		gameObject.AddComponent<AudioReverbZone>();
		新建物体属性(gameObject, "音频混响区");
	}

	public void 精灵(string 参数)
	{
		GameObject gameObject = new GameObject("New Sprite");
		gameObject.AddComponent<SpriteRenderer>();
		新建物体属性(gameObject, "精灵");
	}

	public void 摄影机(string 参数)
	{
		GameObject gameObject = new GameObject("Camera");
		gameObject.AddComponent<Camera>();
		新建物体属性(gameObject, "摄影机");
	}

	private GameObject 查找场景画布()
	{
		if (GameObject.FindGameObjectsWithTag("Canvas") != null)
		{
			return GameObject.FindGameObjectsWithTag("Canvas")[0];
		}
		return null;
	}

	public void 画布文本(string 参数)
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(Resources.Load("Canvas") as GameObject);
		GameObject obj = new GameObject("NewText");
		obj.AddComponent<Text>();
		obj.GetComponent<Text>().text = "New Text";
		obj.transform.parent = gameObject.transform;
		gameObject.GetComponent<Canvas>().renderMode = RenderMode.WorldSpace;
		新建物体属性(gameObject, "画布文本");
	}

	public void 图片(string 参数)
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(Resources.Load("Canvas") as GameObject);
		GameObject obj = new GameObject("Image");
		obj.AddComponent<Image>();
		obj.transform.parent = gameObject.transform;
		新建物体属性(gameObject, "Canvas");
		gameObject.GetComponent<Canvas>().renderMode = RenderMode.WorldSpace;
	}

	public void 原始图片(string 参数)
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(Resources.Load("Canvas") as GameObject);
		GameObject obj = new GameObject("RawImage");
		obj.AddComponent<RawImage>();
		obj.transform.parent = gameObject.transform;
		gameObject.GetComponent<Canvas>().renderMode = RenderMode.WorldSpace;
		新建物体属性(gameObject, "Canvas");
	}

	public void 按钮(string 参数)
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(Resources.Load("Canvas") as GameObject);
		gameObject.name = "Canvas";
		gameObject.transform.position = Vector3.zero;
		GameObject obj = new GameObject("Button");
		obj.AddComponent<Image>();
		obj.AddComponent<UnityEngine.UI.Button>();
		obj.transform.parent = gameObject.transform;
	}

	public void 选项(string 参数)
	{
	}

	public void 滑块(string 参数)
	{
	}

	public void 滚动条(string 参数)
	{
	}

	public void 下拉列表(string 参数)
	{
	}

	public void 输入框(string 参数)
	{
	}

	public void 画布(string 参数)
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(Resources.Load("Canvas") as GameObject);
		gameObject.tag = "Canvas";
		新建物体属性(gameObject, "画布");
		gameObject.GetComponent<Canvas>().renderMode = RenderMode.WorldSpace;
	}

	public void 面板(string 参数)
	{
	}

	public void 滚动视图(string 参数)
	{
	}

	public void 事件系统(string 参数)
	{
	}

	public void 移到视图(string 参数)
	{
		Transform transform = GameObject.Find("[CameraRig]").transform.Find("Camera (eye)/Pos");
		if ((bool)GlobalObj._instance.当前选择物体)
		{
			GlobalObj._instance.当前选择物体.transform.position = transform.position;
		}
	}

	public void 对齐视图(string 参数)
	{
		GameObject gameObject = GameObject.Find("[CameraRig]");
		Transform transform = gameObject.transform.Find("Camera (eye)/Pos");
		if ((bool)GlobalObj._instance.当前选择物体)
		{
			Vector3 position = GlobalObj._instance.当前选择物体.transform.position - transform.localPosition - transform.parent.transform.localPosition;
			gameObject.transform.position = position;
		}
	}

	public void 粒子系统(string 参数)
	{
		GameObject obj = UnityEngine.Object.Instantiate(Resources.Load("Particle System") as GameObject);
		新建物体属性(obj, "粒子系统");
	}

	public void 添粒子系统(string 参数)
	{
		if ((bool)获取当前物体())
		{
			获取当前物体().AddComponent<ParticleSystem>();
		}
	}

	public void 拖尾渲染器(string 参数)
	{
		if ((bool)获取当前物体())
		{
			获取当前物体().AddComponent<TrailRenderer>();
		}
	}

	public void 线渲染器(string 参数)
	{
		if ((bool)获取当前物体())
		{
			获取当前物体().AddComponent<LineRenderer>();
		}
	}

	public void 镜头炫光(string 参数)
	{
		if ((bool)获取当前物体())
		{
			获取当前物体().AddComponent<LensFlare>();
		}
	}

	public void 光圈(string 参数)
	{
	}

	public void 投影机(string 参数)
	{
		if ((bool)获取当前物体())
		{
			获取当前物体().AddComponent<Projector>();
		}
	}

	private GameObject 获取当前物体()
	{
		if (!GlobalObj._instance.当前选择物体)
		{
			return null;
		}
		return GlobalObj._instance.当前选择物体;
	}

	public void 刚体(string 参数)
	{
		if ((bool)获取当前物体())
		{
			获取当前物体().AddComponent<Rigidbody>();
		}
	}

	public void 角色控制器(string 参数)
	{
		获取当前物体().AddComponent<CharacterController>();
	}

	public void 盒子碰撞器(string 参数)
	{
		获取当前物体().AddComponent<BoxCollider>();
	}

	public void 球体碰撞器(string 参数)
	{
		获取当前物体().AddComponent<SphereCollider>();
	}

	public void 胶囊碰撞器(string 参数)
	{
		获取当前物体().AddComponent<CapsuleCollider>();
	}

	public void 网格碰撞器(string 参数)
	{
		获取当前物体().AddComponent<MeshCollider>();
	}

	public void 轮子碰撞器(string 参数)
	{
		获取当前物体().AddComponent<WheelCollider>();
	}

	public void 地形碰撞器(string 参数)
	{
		获取当前物体().AddComponent<TerrainCollider>();
	}

	public void 布料(string 参数)
	{
		if ((bool)获取当前物体().GetComponent<SkinnedMeshRenderer>())
		{
			获取当前物体().AddComponent<Cloth>();
			return;
		}
		获取当前物体().AddComponent<SkinnedMeshRenderer>();
		获取当前物体().AddComponent<Cloth>();
	}

	public void 铰链关节(string 参数)
	{
		if ((bool)获取当前物体().GetComponent<Rigidbody>())
		{
			获取当前物体().AddComponent<HingeJoint>();
			return;
		}
		获取当前物体().AddComponent<Rigidbody>();
		获取当前物体().AddComponent<HingeJoint>();
	}

	public void 固定关节(string 参数)
	{
		if ((bool)获取当前物体().GetComponent<Rigidbody>())
		{
			获取当前物体().AddComponent<FixedJoint>();
			return;
		}
		获取当前物体().AddComponent<Rigidbody>();
		获取当前物体().AddComponent<FixedJoint>();
	}

	public void 弹簧关节(string 参数)
	{
		if ((bool)获取当前物体().GetComponent<Rigidbody>())
		{
			获取当前物体().AddComponent<SpringJoint>();
			return;
		}
		获取当前物体().AddComponent<Rigidbody>();
		获取当前物体().AddComponent<SpringJoint>();
	}

	public void 角色关节(string 参数)
	{
		if ((bool)获取当前物体().GetComponent<Rigidbody>())
		{
			获取当前物体().AddComponent<CharacterJoint>();
			return;
		}
		获取当前物体().AddComponent<Rigidbody>();
		获取当前物体().AddComponent<CharacterJoint>();
	}

	public void 可配置关节(string 参数)
	{
		if ((bool)获取当前物体().GetComponent<Rigidbody>())
		{
			获取当前物体().AddComponent<ConfigurableJoint>();
			return;
		}
		获取当前物体().AddComponent<Rigidbody>();
		获取当前物体().AddComponent<ConfigurableJoint>();
	}

	public void 恒力(string 参数)
	{
		if ((bool)获取当前物体().GetComponent<Rigidbody>())
		{
			获取当前物体().AddComponent<ConstantForce>();
			return;
		}
		获取当前物体().AddComponent<Rigidbody>();
		获取当前物体().AddComponent<ConstantForce>();
	}

	public void 导航网格代理(string 参数)
	{
		if ((bool)获取当前物体())
		{
			获取当前物体().AddComponent<NavMeshAgent>();
		}
	}

	public void 断开网格链接(string 参数)
	{
		if ((bool)获取当前物体())
		{
			获取当前物体().AddComponent<OffMeshLink>();
		}
	}

	public void 导航网格障碍(string 参数)
	{
		if ((bool)获取当前物体())
		{
			获取当前物体().AddComponent<NavMeshObstacle>();
		}
	}

	public void 音频侦听器(string 参数)
	{
	}

	public void 添音频源(string 参数)
	{
		if ((bool)获取当前物体())
		{
			获取当前物体().AddComponent<AudioSource>();
		}
	}

	public void 添音频混响区(string 参数)
	{
		if ((bool)获取当前物体())
		{
			获取当前物体().AddComponent<AudioReverbZone>();
		}
	}

	public void 音频低通过滤器(string 参数)
	{
		if ((bool)获取当前物体())
		{
			获取当前物体().AddComponent<AudioLowPassFilter>();
		}
	}

	public void 音频高通过滤器(string 参数)
	{
		if ((bool)获取当前物体())
		{
			获取当前物体().AddComponent<AudioHighPassFilter>();
		}
	}

	public void 音频回声过滤器(string 参数)
	{
		if ((bool)获取当前物体())
		{
			获取当前物体().AddComponent<AudioEchoFilter>();
		}
	}

	public void 音频失真过滤器(string 参数)
	{
		if ((bool)获取当前物体())
		{
			获取当前物体().AddComponent<AudioDistortionFilter>();
		}
	}

	public void 音频混响过滤器(string 参数)
	{
		if ((bool)获取当前物体())
		{
			获取当前物体().AddComponent<AudioReverbFilter>();
		}
	}

	public void 音频合声过滤器(string 参数)
	{
		if ((bool)获取当前物体())
		{
			获取当前物体().AddComponent<AudioChorusFilter>();
		}
	}

	public void 音频空间(string 参数)
	{
	}

	public void 属性(string 参数)
	{
		JingHand._instance.检视视图显示();
	}

	public void 层次(string 参数)
	{
		JingHand._instance.层次视图显示();
	}
}
public class RigidbodyPanel : MonoBehaviour
{
	public Scrollbar scrollbar1;

	public Scrollbar scrollbar2;

	public Scrollbar scrollbar3;

	public Toggle toggle1;

	public Toggle toggle2;

	public Text value1;

	public Text value2;

	public Text value3;

	private GameObject tempObj;

	public static RigidbodyPanel _instance;

	private void Awake()
	{
		if (_instance == null)
		{
			_instance = this;
		}
	}

	private void Update()
	{
		ShowRigidbodyInfo();
	}

	private void ShowRigidbodyInfo()
	{
		if ((bool)GlobalObj._instance.当前选择物体 && (bool)GlobalObj._instance.当前选择物体.GetComponent<Rigidbody>())
		{
			tempObj = GlobalObj._instance.当前选择物体;
			float value = scrollbar1.value;
			value1.text = (value * 100f).ToString() ?? "";
			tempObj.GetComponent<Rigidbody>().mass = value * 100f;
			float value2 = scrollbar2.value;
			this.value2.text = (value2 * 100f).ToString() ?? "";
			tempObj.GetComponent<Rigidbody>().drag = value2 * 100f;
			float value3 = scrollbar3.value;
			this.value3.text = (value3 * 100f).ToString() ?? "";
			tempObj.GetComponent<Rigidbody>().angularDrag = value3 * 100f;
			tempObj.GetComponent<Rigidbody>().useGravity = toggle1.isOn;
			tempObj.GetComponent<Rigidbody>().isKinematic = toggle2.isOn;
		}
	}

	public void 位置归零(GameObject obj)
	{
		if ((bool)obj.GetComponent<Rigidbody>())
		{
			float mass = obj.GetComponent<Rigidbody>().mass;
			float drag = obj.GetComponent<Rigidbody>().drag;
			float angularDrag = obj.GetComponent<Rigidbody>().angularDrag;
			scrollbar1.value = mass;
			scrollbar2.value = drag;
			scrollbar3.value = angularDrag;
			bool useGravity = obj.GetComponent<Rigidbody>().useGravity;
			bool isKinematic = obj.GetComponent<Rigidbody>().isKinematic;
			toggle1.isOn = useGravity;
			toggle2.isOn = isKinematic;
		}
	}
}
public class TransformPanel : MonoBehaviour
{
	public Slider slider1;

	public Slider slider2;

	public Slider slider3;

	public Text text1;

	public Text text2;

	public Text text3;

	public Slider slider4;

	public Slider slider5;

	public Slider slider6;

	public Text text4;

	public Text text5;

	public Text text6;

	public Slider slider7;

	public Slider slider8;

	public Slider slider9;

	public Text text7;

	public Text text8;

	public Text text9;

	private GameObject tempObj;

	private Quaternion q;

	public static TransformPanel _instance;

	private void Awake()
	{
		_instance = this;
	}

	private void Update()
	{
		ShowTransformInfo();
	}

	private void ShowTransformInfo()
	{
		if ((bool)GlobalObj._instance.当前选择物体)
		{
			tempObj = GlobalObj._instance.当前选择物体;
			float value = slider1.value;
			text1.text = value.ToString() ?? "";
			float value2 = slider2.value;
			text2.text = value2.ToString() ?? "";
			float value3 = slider3.value;
			text3.text = value3.ToString() ?? "";
			tempObj.transform.position = new Vector3(value, value2, value3);
			float value4 = slider4.value;
			text4.text = value4.ToString() ?? "";
			float value5 = slider5.value;
			text5.text = value5.ToString() ?? "";
			float value6 = slider6.value;
			text6.text = value6.ToString() ?? "";
			q.eulerAngles = new Vector3(value4, value5, value6);
			tempObj.transform.localRotation = q;
			float value7 = slider7.value;
			text7.text = value7.ToString() ?? "";
			float value8 = slider8.value;
			text8.text = value8.ToString() ?? "";
			float value9 = slider9.value;
			text9.text = value9.ToString() ?? "";
			tempObj.transform.localScale = new Vector3(value7, value8, value9);
		}
	}

	public void 位置归零(GameObject obj)
	{
		float x = obj.transform.position.x;
		float y = obj.transform.position.y;
		float z = obj.transform.position.z;
		slider1.value = x;
		slider2.value = y;
		slider3.value = z;
		float x2 = obj.transform.localEulerAngles.x;
		float y2 = obj.transform.localEulerAngles.y;
		float z2 = obj.transform.localEulerAngles.z;
		slider4.value = x2;
		slider5.value = y2;
		slider6.value = z2;
		float x3 = obj.transform.localScale.x;
		float y3 = obj.transform.localScale.y;
		float z3 = obj.transform.localScale.z;
		slider7.value = x3;
		slider8.value = y3;
		slider9.value = z3;
	}
}
public class TreeViewButton : MonoBehaviour
{
	public int 虚物编号;
}
public class WeakInfoManager : MonoBehaviour
{
	public static WeakInfoManager Instance;

	public List<Text> WeakTextList;

	public GameObject WeakInfosParent;

	private const float ShowTime = 1f;

	private int curIndex;

	private const int MaxShowCount = 2;

	private int curShowCount;

	private Dictionary<int, float> WeakInfoLeftTimeDic = new Dictionary<int, float>();

	private void Awake()
	{
		if (Instance == null)
		{
			Instance = this;
		}
	}

	public void SetWeakInfo(string msg)
	{
		WeakTextList[curIndex].text = msg;
		WeakTextList[curIndex].gameObject.transform.localScale = Vector3.one;
		WeakInfoLeftTimeDic[curIndex] = 1f;
		curShowCount++;
		if (curShowCount > 2)
		{
			int num = (curIndex - 2 + WeakTextList.Count) % WeakTextList.Count;
			WeakTextList[num].gameObject.transform.SetParent(WeakInfosParent.transform.parent);
			WeakTextList[num].gameObject.transform.DOScale(new Vector3(0f, 0f, 0f), 0.8f);
			WeakInfoLeftTimeDic[num] = 0f;
			curShowCount--;
		}
		curIndex = (curIndex + 1) % WeakTextList.Count;
		for (int i = 1; i <= curShowCount; i++)
		{
			int index = (i * -1 + curIndex + WeakTextList.Count) % WeakTextList.Count;
			WeakTextList[index].gameObject.transform.SetParent(WeakInfosParent.transform.parent);
			WeakTextList[index].gameObject.transform.SetParent(WeakInfosParent.transform);
		}
	}

	private void Update()
	{
		if (curShowCount <= 0)
		{
			return;
		}
		for (int i = 0; i < WeakTextList.Count; i++)
		{
			if (WeakInfoLeftTimeDic.ContainsKey(i) && WeakInfoLeftTimeDic[i] > 0f)
			{
				WeakInfoLeftTimeDic[i] -= Time.deltaTime;
				if (WeakInfoLeftTimeDic[i] <= 0f)
				{
					WeakTextList[i].gameObject.transform.SetParent(WeakInfosParent.transform.parent);
					WeakTextList[i].gameObject.transform.DOScale(new Vector3(0f, 0f, 0f), 0.8f);
					WeakInfoLeftTimeDic[i] = 0f;
					curShowCount--;
				}
			}
		}
	}
}
public class 佐下载控制 : MonoBehaviour
{
	public static 佐下载控制 _instance;

	private string[] names;

	private string webpath;

	private Texture t1;

	public GameObject 佐;

	public GameObject 数字键盘;

	public GameObject 头显;

	public Text 模型代号;

	private GameObject 下载的模型复制品;

	public GameObject 错误提示;

	public LineRenderer 射线材质;

	public Transform 键盘新位置;

	public Transform 下载模型位置;

	public GameObject 正在下载;

	public GameObject 下载成功;

	private GameObject o;

	private bool 是否旋转;

	private bool 射线开关;

	public static bool 选中物体;

	public static bool 可移动;

	public static bool 可旋转;

	public static bool 可缩放;

	private string 标签字符串;

	private void Awake()
	{
		_instance = this;
	}

	private void Start()
	{
		数字键盘.SetActive(value: false);
		错误提示.SetActive(value: false);
		射线开关 = true;
	}

	private void Update()
	{
		UnityEngine.XR.InputDevice deviceAtXRNode = InputDevices.GetDeviceAtXRNode(XRNode.LeftHand);
		if (Physics.Raycast(new Ray(佐.transform.position, 佐.transform.forward), out var hitInfo))
		{
			射线材质.enabled = true;
			射线材质.SetPosition(0, 佐.transform.position);
			射线材质.SetPosition(1, hitInfo.point);
			deviceAtXRNode.TryGetFeatureValue(UnityEngine.XR.CommonUsages.triggerButton, out var value);
			if (!value)
			{
				return;
			}
			switch (hitInfo.collider.tag)
			{
			case "Num":
			{
				string text = hitInfo.collider.gameObject.name;
				模型代号.text += text;
				if (模型代号.text.Length > 4)
				{
					模型代号.text = 模型代号.text.Substring(0, 模型代号.text.Length - 1);
				}
				break;
			}
			case "Delete":
				模型代号.text = "";
				break;
			case "Down":
				确认载入模型();
				break;
			case "move":
				if (佑控.模型 != null)
				{
					可移动 = true;
					可旋转 = false;
					可缩放 = false;
				}
				break;
			case "rotate":
				if (佑控.模型 != null)
				{
					可旋转 = true;
					可缩放 = false;
					可移动 = false;
				}
				break;
			case "scale":
				if (佑控.模型 != null)
				{
					可缩放 = true;
					可移动 = false;
					可旋转 = false;
				}
				break;
			case "close":
				数字键盘.SetActive(value: false);
				可缩放 = false;
				可移动 = false;
				可旋转 = false;
				佑控.模型 = null;
				break;
			}
		}
		else
		{
			射线材质.enabled = false;
		}
	}

	public void 调出数字键盘()
	{
		数字键盘.SetActive(value: true);
		数字键盘.transform.position = 键盘新位置.position;
		数字键盘.transform.rotation = 键盘新位置.rotation;
	}

	private IEnumerator LoadMainGameObject(string path)
	{
		下载的模型复制品 = null;
		MonoBehaviour.print("开始下载");
		WWW bundle = WWW.LoadFromCacheOrDownload(path, 1);
		MonoBehaviour.print("下载中");
		正在下载.SetActive(value: true);
		yield return bundle;
		if (bundle.error == null)
		{
			MonoBehaviour.print("下载完毕");
			正在下载.SetActive(value: false);
			下载成功.SetActive(value: true);
			names = bundle.assetBundle.GetAllAssetNames();
			AssetBundleRequest request = bundle.assetBundle.LoadAssetAsync(names[0], typeof(GameObject));
			yield return request;
			下载的模型复制品 = UnityEngine.Object.Instantiate(request.asset) as GameObject;
			yield return 下载的模型复制品;
			yield return new WaitForSeconds(1f);
			下载成功.SetActive(value: false);
			模型代号.text = "";
			下载的模型复制品.tag = "download";
			下载的模型复制品.AddComponent<MeshCollider>();
			下载的模型复制品.transform.position = 下载模型位置.position;
			下载的模型复制品.transform.parent = null;
			下载的模型复制品.transform.localScale = new Vector3(5f, 5f, 5f);
			bundle.assetBundle.Unload(unloadAllLoadedObjects: false);
			Caching.ClearCache();
		}
		else
		{
			错误提示.SetActive(value: true);
			正在下载.SetActive(value: false);
			模型代号.text = "";
			yield return new WaitForSeconds(2f);
			错误提示.SetActive(value: false);
		}
	}

	private IEnumerator LoadGameObject(string path)
	{
		MonoBehaviour.print("开始下载");
		WWW bundle = new WWW(path);
		MonoBehaviour.print("下载中");
		yield return bundle;
		if (bundle.error == null)
		{
			t1 = bundle.texture;
			if (t1 != null)
			{
				下载的模型复制品.GetComponent<Renderer>().material.mainTexture = t1;
				MonoBehaviour.print("下载完毕");
			}
		}
	}

	private void 确认载入模型()
	{
		webpath = "http://diywebapp.com/ab/" + 模型代号.text + ".ab";
		MonoBehaviour.print("确认载入模型()" + webpath);
		StartCoroutine(LoadMainGameObject(webpath));
		确认载入材质();
	}

	private void 确认载入材质()
	{
		webpath = "diywebapp.com/ab/png/" + 模型代号.text + ".png";
		MonoBehaviour.print("确认载入材质()" + webpath);
		StartCoroutine(LoadGameObject(webpath));
		MonoBehaviour.print(webpath);
	}
}
public class 佑控 : MonoBehaviour
{
	public GameObject 佑;

	public LineRenderer 射线材质;

	private bool 固定第一个点;

	private Vector2 第一个点;

	public static GameObject 模型;

	private void Update()
	{
		if (Physics.Raycast(new Ray(佑.transform.position, 佑.transform.forward), out var hitInfo))
		{
			射线材质.enabled = true;
			射线材质.SetPosition(0, 佑.transform.position);
			射线材质.SetPosition(1, hitInfo.point);
			if (hitInfo.collider.tag == "download")
			{
				模型 = hitInfo.collider.gameObject;
			}
		}
		else
		{
			射线材质.enabled = false;
		}
		if (佐下载控制.可移动)
		{
			模式(1);
		}
		if (佐下载控制.可旋转)
		{
			模式(2);
		}
		if (佐下载控制.可缩放)
		{
			模式(3);
		}
	}

	private void 模式(int i)
	{
		UnityEngine.XR.InputDevice deviceAtXRNode = InputDevices.GetDeviceAtXRNode(XRNode.RightHand);
		Vector2 value = default(Vector2);
		deviceAtXRNode.TryGetFeatureValue(UnityEngine.XR.CommonUsages.primary2DAxis, out value);
		if (!固定第一个点)
		{
			第一个点 = value;
			固定第一个点 = true;
		}
		if (value.x - 第一个点.x >= 0.1f)
		{
			switch (i)
			{
			case 1:
				模型.transform.Translate(new Vector3(2f, 0f, 0f));
				break;
			case 2:
				模型.transform.Rotate(new Vector3(5f, 0f, 0f));
				break;
			case 3:
				模型.transform.localScale += new Vector3(0.5f, 0f, 0f);
				break;
			}
			第一个点 = value;
		}
		else if (value.x - 第一个点.x <= -0.1f)
		{
			switch (i)
			{
			case 1:
				模型.transform.Translate(new Vector3(-2f, 0f, 0f));
				break;
			case 2:
				模型.transform.Rotate(new Vector3(-5f, 0f, 0f));
				break;
			case 3:
				模型.transform.localScale += new Vector3(-0.5f, 0f, 0f);
				break;
			}
			第一个点 = value;
		}
		if (value.y - 第一个点.y >= 0.1f)
		{
			switch (i)
			{
			case 1:
				模型.transform.Translate(new Vector3(0f, 0f, 2f));
				break;
			case 2:
				模型.transform.Rotate(new Vector3(0f, 5f, 0f));
				break;
			case 3:
				模型.transform.localScale += new Vector3(0f, 0.5f, 0f);
				break;
			}
			第一个点 = value;
		}
		else if (value.y - 第一个点.y <= -0.1f)
		{
			switch (i)
			{
			case 1:
				模型.transform.Translate(new Vector3(0f, 0f, -2f));
				break;
			case 2:
				模型.transform.Rotate(new Vector3(0f, -5f, 0f));
				break;
			case 3:
				模型.transform.localScale += new Vector3(0f, -0.5f, 0f);
				break;
			}
			第一个点 = value;
		}
		deviceAtXRNode.TryGetFeatureValue(UnityEngine.XR.CommonUsages.triggerButton, out var value2);
		if (value2)
		{
			switch (i)
			{
			case 1:
				佐下载控制.可移动 = false;
				break;
			case 2:
				佐下载控制.可旋转 = false;
				break;
			case 3:
				佐下载控制.可缩放 = false;
				break;
			}
			模型 = null;
		}
	}
}
public class 时间 : MonoBehaviour
{
	private DateTime pauseT;

	private DateTime resumeT;

	public static DateTime 中间时间;

	public GameObject 时针;

	public GameObject 秒针;

	public GameObject 分针;

	public Text 月份;

	public Text 年份;

	public Text 号;

	public Text 白天黑夜;

	private int 相差秒数;

	private TimeSpan ts1;

	private TimeSpan ts2;

	private TimeSpan tsSub;

	private int 现在的月份;

	private int 几号;

	private int 年数;

	private float 时针转动角度计算;

	private int 时针转动角度提取整数;

	private int 时针转动角度提取小数;

	private string s;

	private void Awake()
	{
	}

	private void Start()
	{
		pauseT = Convert.ToDateTime("2016-10-10 00:00:00");
		resumeT = DateTime.Now;
		ts1 = new TimeSpan(pauseT.Ticks);
		ts2 = new TimeSpan(resumeT.Ticks);
		tsSub = ts1.Subtract(ts2).Duration();
		if (tsSub.Days >= 1)
		{
			相差秒数 = (tsSub.Days * 60 * 60 * 24 + tsSub.Hours * 60 * 60 + tsSub.Minutes * 60 + tsSub.Seconds) * 24;
		}
		else if (tsSub.Days < 1)
		{
			相差秒数 = (tsSub.Hours * 60 * 60 + tsSub.Minutes * 60 + tsSub.Seconds) * 24;
		}
		中间时间 = pauseT.AddSeconds(相差秒数);
		年数 = 中间时间.Year;
		现在的月份 = 中间时间.Month;
		几号 = 中间时间.Day;
		时针转动角度计算 = (float)(resumeT.Minute * 60 + resumeT.Second) * 24f / 60f / 60f;
		时针转动角度提取整数 = (int)时针转动角度计算;
		s = 时针转动角度计算.ToString("f2").Substring(时针转动角度计算.ToString().IndexOf('.') + 1);
		时针转动角度提取小数 = int.Parse(s);
		时针.transform.rotation = Quaternion.Euler(0f, 0f, ((float)时针转动角度提取整数 * 30f + (float)时针转动角度提取小数 * 0.3f) % 360f);
		分针.transform.eulerAngles = new Vector3(0f, 0f, (float)中间时间.Minute * 6f);
		InvokeRepeating("时针走动", 0f, 1f);
		InvokeRepeating("分针走动", 0f, 0.02f);
		InvokeRepeating("秒针走动", 0f, 0.02f);
		InvokeRepeating("时间流逝", 0f, 1f);
	}

	private void Update()
	{
		判断是白天还是晚上();
		年份.text = 年数.ToString();
		月份.text = 现在的月份.ToString();
		号.text = 几号.ToString();
	}

	private void 时间流逝()
	{
		中间时间 = 中间时间.AddSeconds(24.0);
	}

	private void 时针走动()
	{
		时针.transform.eulerAngles += new Vector3(0f, 0f, 0.2f);
	}

	private void 秒针走动()
	{
		秒针.transform.eulerAngles += new Vector3(0f, 0f, 2.88f);
	}

	private void 分针走动()
	{
		分针.transform.eulerAngles += new Vector3(0f, 0f, 0.048f);
	}

	private void 判断是白天还是晚上()
	{
		string text = 中间时间.ToString();
		text = text.Substring(text.Length - 2, 2);
		白天黑夜.text = text;
	}
}
public class Box : MonoBehaviour
{
	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject.name == "清除")
		{
			VR2045._instance.退格操作();
		}
		if (other.gameObject.name == "确定")
		{
			VR2045._instance.确认修改内容();
		}
		if (other.gameObject.name == "取消")
		{
			VR2045._instance.取消();
		}
	}
}
public class ChangePicture : MonoBehaviour
{
	private int i;

	public Texture[] textures;

	public InputField textFied;

	private string network;

	private WWW www;

	private bool 是否加载图片;

	public Texture texture1;

	private void Start()
	{
	}

	private void Update()
	{
		if (Input.GetMouseButtonDown(0))
		{
			是否加载图片 = true;
			i++;
			switch (i)
			{
			case 1:
				GetComponent<MeshRenderer>().materials[0].mainTexture = textures[0];
				MonoBehaviour.print("1");
				break;
			case 2:
				GetComponent<MeshRenderer>().materials[0].mainTexture = textures[1];
				MonoBehaviour.print("2");
				break;
			case 3:
				GetComponent<MeshRenderer>().materials[0].mainTexture = textures[2];
				break;
			case 4:
				GetComponent<MeshRenderer>().materials[0].mainTexture = textures[3];
				break;
			case 5:
				GetComponent<MeshRenderer>().materials[0].mainTexture = textures[4];
				i = 0;
				break;
			}
		}
		if (textFied.text != "" && 是否加载图片)
		{
			MonoBehaviour.print("dd");
			StartCoroutine(loadPicture());
			是否加载图片 = false;
		}
	}

	private IEnumerator loadPicture()
	{
		network = textFied.text;
		MonoBehaviour.print("下载图片");
		www = new WWW(network);
		yield return www;
		texture1 = www.texture;
		GetComponent<MeshRenderer>().materials[0].mainTexture = texture1;
	}

	public void 本地上传()
	{
		OpenFileDialog openFileDialog = new OpenFileDialog();
		openFileDialog.Title = "请选择图片";
		openFileDialog.Filter = "所有文件(*.*)|*.*|png文件|*.png|jpg文件|*.jpg";
		if (openFileDialog.ShowDialog() == DialogResult.OK)
		{
			StartCoroutine(GetTexture("file://" + openFileDialog.FileName));
		}
	}

	private IEnumerator GetTexture(string url)
	{
		WWW www = new WWW(url);
		yield return www;
		if (www.isDone && www.error == null)
		{
			GetComponent<MeshRenderer>().materials[0].mainTexture = www.texture;
		}
	}
}
public class ChangePicture1 : MonoBehaviour
{
	private int i;

	public Texture[] textures;

	private void Start()
	{
	}

	private void Update()
	{
		if (Input.GetMouseButtonDown(1))
		{
			MonoBehaviour.print("按下按钮1");
			i++;
			switch (i)
			{
			case 1:
				GetComponent<MeshRenderer>().materials[0].mainTexture = textures[0];
				MonoBehaviour.print("1");
				break;
			case 2:
				GetComponent<MeshRenderer>().materials[0].mainTexture = textures[1];
				MonoBehaviour.print("2");
				break;
			case 3:
				GetComponent<MeshRenderer>().materials[0].mainTexture = textures[2];
				break;
			case 4:
				GetComponent<MeshRenderer>().materials[0].mainTexture = textures[3];
				break;
			case 5:
				GetComponent<MeshRenderer>().materials[0].mainTexture = textures[4];
				i = 0;
				break;
			}
		}
	}
}
public class fangxiang
{
	public float offset;

	public void 移动大小(GameObject names, float 新位置, float 旧位置, int i, bool isMove)
	{
		offset = 新位置 - 旧位置;
		if (isMove)
		{
			switch (i)
			{
			case 0:
				names.transform.position += new Vector3(offset, 0f, 0f);
				break;
			case 1:
				names.transform.position += new Vector3(0f, offset, 0f);
				break;
			case 2:
				names.transform.position += new Vector3(0f, 0f, offset);
				break;
			}
		}
		else
		{
			if (isMove)
			{
				return;
			}
			switch (i)
			{
			case 0:
				if (offset < 0f)
				{
					names.transform.localScale -= new Vector3(Mathf.Abs(offset), 0f, 0f);
				}
				else if (offset > 0f)
				{
					names.transform.localScale += new Vector3(Mathf.Abs(offset), 0f, 0f);
				}
				break;
			case 1:
				if (offset < 0f)
				{
					names.transform.localScale -= new Vector3(0f, Mathf.Abs(offset), 0f);
				}
				else if (offset > 0f)
				{
					names.transform.localScale += new Vector3(0f, Mathf.Abs(offset), 0f);
				}
				break;
			case 2:
				if (offset < 0f)
				{
					names.transform.localScale -= new Vector3(0f, 0f, Mathf.Abs(offset));
				}
				else if (offset > 0f)
				{
					names.transform.localScale += new Vector3(0f, 0f, Mathf.Abs(offset));
				}
				break;
			}
		}
	}

	public void 放在地上(GameObject game)
	{
		if (game.transform.position.y != moving._instance.复位1.list1[0].y)
		{
			float y = moving._instance.复位1.list1[0].y;
			game.transform.position = new Vector3(game.transform.position.x, y, game.transform.position.z);
		}
	}
}
public class FengSan : MonoBehaviour
{
	public static FengSan _instance;

	public GameObject 长风扇叶子;

	public GameObject 短风扇叶子;

	private bool 是否开电风扇;

	private void Awake()
	{
		_instance = this;
	}

	private void Start()
	{
		是否开电风扇 = false;
	}

	private void Update()
	{
		if (是否开电风扇)
		{
			开风扇();
		}
	}

	public void 开风扇()
	{
		长风扇叶子.transform.Rotate(0f, 20f, 0f);
		短风扇叶子.transform.Rotate(0f, 0f, 20f);
		是否开电风扇 = true;
	}

	public void 关风扇()
	{
		if (是否开电风扇)
		{
			是否开电风扇 = false;
		}
	}
}
public class fireOpen : MonoBehaviour
{
	private float i;

	private bool 是否加;

	private void Update()
	{
		i += 1f;
		if (i <= 40f && !是否加)
		{
			GetComponent<Light>().intensity += 0.01f;
		}
		if (i > 40f)
		{
			是否加 = true;
			GetComponent<Light>().intensity -= 0.01f;
			if (i == 80f)
			{
				i = 0f;
				是否加 = false;
			}
		}
	}
}
public class followMove : MonoBehaviour
{
	public static followMove _instance;

	private bool 是否移动;

	public GameObject 手柄位置;

	private bool 是否方向移动 = true;

	public bool 是否使用射线;

	public Transform 开始位置;

	public Vector3 目标点;

	public LineRenderer 射线;

	public GameObject gameObj;

	public bool 是否选中;

	public Color outterColor = new Color(0.2f, 1f, 0f, 1f);

	public int i = 1;

	private bool 是否射击;

	public Shader mat;

	private Ray ray;

	public bool 方向不能移动;

	public Text text;

	private bool 是否第一个点;

	private Vector2 第一个点;

	public bool 开始触摸 = true;

	private float yy;

	private float xx;

	private GameObject 子弹;

	public GameObject 飞镖模型;

	public GameObject 获取最初的点击对象;

	public GameObject 图片面板;

	public GameObject 输入框;

	private string network;

	private WWW www;

	private Texture texture1;

	public Texture t;

	public GameObject 初对象;

	private void Awake()
	{
		是否第一个点 = false;
		_instance = this;
	}

	private void Start()
	{
		是否移动 = false;
	}

	private void Update()
	{
	}

	private void FixedUpdate()
	{
		UnityEngine.XR.InputDevice deviceAtXRNode = InputDevices.GetDeviceAtXRNode(XRNode.RightHand);
		deviceAtXRNode.TryGetFeatureValue(UnityEngine.XR.CommonUsages.triggerButton, out var value);
		if (value)
		{
			变换不同的特效();
		}
		deviceAtXRNode.TryGetFeatureValue(UnityEngine.XR.CommonUsages.primary2DAxisClick, out var value2);
		if (!value2 || !gameObj)
		{
			return;
		}
		Vector2 value3 = default(Vector2);
		deviceAtXRNode.TryGetFeatureValue(UnityEngine.XR.CommonUsages.primary2DAxis, out value3);
		float num = VectorAngle(new Vector2(1f, 0f), value3);
		MonoBehaviour.print(num);
		if (num > 45f && num < 135f)
		{
			OnTrigger._instance.摇杆移动(gameObj, -2, OnTrigger._instance.是否触碰了大小模型, OnTrigger._instance.是否旋转模型);
			if (开始触摸)
			{
				gameObj.transform.position += new Vector3(0f, 0f, 0.01f);
			}
			if (OnTrigger._instance.是否缩放)
			{
				gameObj.transform.localScale += new Vector3(0.001f, 0.001f, 0.001f);
			}
			if (OnTrigger._instance.是否旋转)
			{
				xx -= 0.01f;
				gameObj.transform.Rotate(new Vector3(0f, xx, 0f));
			}
		}
		if (num < -45f && num > -135f)
		{
			OnTrigger._instance.摇杆移动(gameObj, 2, OnTrigger._instance.是否触碰了大小模型, OnTrigger._instance.是否旋转模型);
			if (开始触摸)
			{
				gameObj.transform.position -= new Vector3(0f, 0f, 0.01f);
			}
			if (OnTrigger._instance.是否缩放)
			{
				gameObj.transform.localScale -= new Vector3(0.001f, 0.001f, 0.001f);
			}
			if (OnTrigger._instance.是否旋转)
			{
				yy += 0.01f;
				gameObj.transform.Rotate(new Vector3(0f, yy, 0f));
			}
		}
		if ((num < 180f && num > 135f) || (num < -135f && num > -180f))
		{
			OnTrigger._instance.摇杆移动(gameObj, 1, OnTrigger._instance.是否触碰了大小模型, OnTrigger._instance.是否旋转模型);
			if (开始触摸)
			{
				gameObj.transform.position += new Vector3(0.01f, 0f, 0f);
			}
			if (OnTrigger._instance.是否缩放)
			{
				gameObj.transform.localScale += new Vector3(0.001f, 0.001f, 0.001f);
			}
			if (OnTrigger._instance.是否旋转)
			{
				xx -= 0.01f;
				gameObj.transform.Rotate(new Vector3(0f, xx, 0f));
			}
		}
		if ((num > 0f && num < 45f) || (num > -45f && num < 0f))
		{
			OnTrigger._instance.摇杆移动(gameObj, -1, OnTrigger._instance.是否触碰了大小模型, OnTrigger._instance.是否旋转模型);
			if (开始触摸)
			{
				gameObj.transform.position -= new Vector3(0.01f, 0f, 0f);
			}
			if (OnTrigger._instance.是否缩放)
			{
				gameObj.transform.localScale -= new Vector3(0.001f, 0.001f, 0.001f);
			}
			if (OnTrigger._instance.是否旋转)
			{
				yy += 0.01f;
				gameObj.transform.Rotate(new Vector3(0f, yy, 0f));
			}
		}
	}

	public void 位置移动()
	{
		if (是否选中 && !OnTrigger._instance.是否缩放)
		{
			OnTrigger._instance.创建方向模型();
			if (OnTrigger._instance.是否旋转)
			{
				OnTrigger._instance.y.GetComponent<MeshRenderer>().materials[0].color = Color.yellow;
				return;
			}
			OnTrigger._instance.x.GetComponent<MeshRenderer>().materials[0].color = Color.yellow;
			OnTrigger._instance.z.GetComponent<MeshRenderer>().materials[0].color = Color.yellow;
		}
	}

	private float VectorAngle(Vector2 from, Vector2 to)
	{
		Vector3 vector = Vector3.Cross(from, to);
		float num = Vector2.Angle(from, to);
		if (!(vector.z > 0f))
		{
			return num;
		}
		return 0f - num;
	}

	public void 发亮效果(GameObject game)
	{
		if (game != null)
		{
			SelectObject._instance.targetsGroup1 = game;
			if (game.GetComponent<ShowSelected>() == null)
			{
				game.AddComponent<ShowSelected>().outterColor = outterColor;
			}
			showSelected._instance.Change_Color();
			MonoBehaviour.print("要改：20221218 发亮效果()");
		}
	}

	private IEnumerator loadPicture()
	{
		network = 输入框.GetComponent<InputField>().text;
		MonoBehaviour.print("下载图片");
		www = new WWW(network);
		yield return www;
		texture1 = www.texture;
		获取最初的点击对象.GetComponent<MeshRenderer>().materials[0].mainTexture = texture1;
	}

	private IEnumerator GetTexture(string url)
	{
		WWW www = new WWW(url);
		yield return www;
		if (www.isDone && www.error == null)
		{
			获取最初的点击对象.GetComponent<MeshRenderer>().materials[0].mainTexture = www.texture;
		}
	}

	private void 删除特效()
	{
		if (子弹 != null)
		{
			UnityEngine.Object.Destroy(子弹);
		}
	}

	private void 变换不同的特效()
	{
		子弹 = UnityEngine.Object.Instantiate(飞镖模型, 开始位置.position, Quaternion.identity);
		子弹.GetComponent<Rigidbody>().velocity = base.transform.forward * 8f;
	}

	private IEnumerator Picture()
	{
		string value = gameObj.GetComponent<Image>().sprite.name;
		string text = "http://www.diywebapp.com/jpg/.jpg".Insert(29, value);
		MonoBehaviour.print("Picture()" + text);
		WWW www = new WWW(text);
		yield return www;
		t = www.texture;
		if (获取最初的点击对象.tag == "照片1")
		{
			获取最初的点击对象.GetComponent<MeshRenderer>().materials[0].mainTexture = www.texture;
			获取最初的点击对象.GetComponent<MeshRenderer>().material.SetTextureScale("_MainTex", new Vector2(3f, 3.5f));
			获取最初的点击对象.GetComponent<MeshRenderer>().material.SetTextureOffset("_MainTex", new Vector2(-10f, 0.59f));
			MonoBehaviour.print("zhaopinga");
			MonoBehaviour.print(获取最初的点击对象?.ToString() + "eeeeeeee");
		}
		if (获取最初的点击对象.tag == "小照片2")
		{
			MonoBehaviour.print("gag");
			获取最初的点击对象.GetComponent<MeshRenderer>().materials[0].mainTexture = 井模块._instance.获取当前图片;
			获取最初的点击对象.GetComponent<MeshRenderer>().material.SetTextureScale("_MainTex", new Vector2(3f, 3.5f));
			获取最初的点击对象.GetComponent<MeshRenderer>().material.SetTextureOffset("_MainTex", new Vector2(-10f, 0.59f));
			MonoBehaviour.print(获取最初的点击对象?.ToString() + "eeeeeeee");
		}
		if (获取最初的点击对象.tag == "大图片")
		{
			获取最初的点击对象.GetComponent<MeshRenderer>().materials[0].mainTexture = www.texture;
			获取最初的点击对象.GetComponent<MeshRenderer>().material.SetTextureScale("_MainTex", new Vector2(1f, 1f));
			获取最初的点击对象.GetComponent<MeshRenderer>().material.SetTextureOffset("_MainTex", new Vector2(-9.88f, 0.91f));
		}
		if (获取最初的点击对象.tag == "插画")
		{
			获取最初的点击对象.GetComponent<MeshRenderer>().materials[0].mainTexture = www.texture;
			获取最初的点击对象.GetComponent<MeshRenderer>().material.SetTextureScale("_MainTex", new Vector2(0.8f, 0.8f));
			获取最初的点击对象.GetComponent<MeshRenderer>().material.SetTextureOffset("_MainTex", new Vector2(-9.94f, 0.25f));
		}
	}

	public void 是否有对象()
	{
		if ((bool)gameObj)
		{
			OnTrigger._instance.Rotation1 = gameObj.transform.localEulerAngles;
			if (!是否选中 && !OnTrigger._instance.是否换图)
			{
				mat = gameObj.GetComponent<MeshRenderer>().material.shader;
			}
			if (!OnTrigger._instance.是否换图)
			{
				发亮效果(gameObj);
			}
			if (gameObj.tag == "照片1" || gameObj.tag == "插画" || gameObj.tag == "大图片" || ((gameObj.tag == "小照片2") | (gameObj.tag == "小照片3")))
			{
				获取最初的点击对象 = gameObj;
			}
			else
			{
				获取最初的点击对象 = null;
				if (OnTrigger._instance.是否换图)
				{
					发亮效果(gameObj);
				}
			}
		}
		是否选中 = true;
		位置移动();
		是否射击 = false;
		是否使用射线 = true;
	}

	public void Pictures()
	{
		t = 井模块._instance.获取当前图片;
		MonoBehaviour.print("wohahah");
		if (获取最初的点击对象.tag == "照片1")
		{
			获取最初的点击对象.GetComponent<MeshRenderer>().materials[0].mainTexture = 井模块._instance.获取当前图片;
			获取最初的点击对象.GetComponent<MeshRenderer>().material.SetTextureScale("_MainTex", new Vector2(3f, 3.5f));
			获取最初的点击对象.GetComponent<MeshRenderer>().material.SetTextureOffset("_MainTex", new Vector2(-10f, 0.59f));
		}
		if (获取最初的点击对象.tag == "小照片2")
		{
			MonoBehaviour.print("gag");
			获取最初的点击对象.GetComponent<MeshRenderer>().materials[0].mainTexture = 井模块._instance.获取当前图片;
			获取最初的点击对象.GetComponent<MeshRenderer>().material.SetTextureScale("_MainTex", new Vector2(3f, 3.5f));
			获取最初的点击对象.GetComponent<MeshRenderer>().material.SetTextureOffset("_MainTex", new Vector2(-9.75f, 0.46f));
		}
		if (获取最初的点击对象.tag == "小照片3")
		{
			MonoBehaviour.print("gag");
			获取最初的点击对象.GetComponent<MeshRenderer>().materials[0].mainTexture = 井模块._instance.获取当前图片;
			获取最初的点击对象.GetComponent<MeshRenderer>().material.SetTextureScale("_MainTex", new Vector2(3f, 3.5f));
			获取最初的点击对象.GetComponent<MeshRenderer>().material.SetTextureOffset("_MainTex", new Vector2(-10.31f, 0.46f));
		}
		if (获取最初的点击对象.tag == "大图片")
		{
			获取最初的点击对象.GetComponent<MeshRenderer>().materials[0].mainTexture = 井模块._instance.获取当前图片;
			获取最初的点击对象.GetComponent<MeshRenderer>().material.SetTextureScale("_MainTex", new Vector2(1f, 1f));
			获取最初的点击对象.GetComponent<MeshRenderer>().material.SetTextureOffset("_MainTex", new Vector2(-9.88f, 0.91f));
		}
		if (获取最初的点击对象.tag == "插画")
		{
			获取最初的点击对象.GetComponent<MeshRenderer>().materials[0].mainTexture = 井模块._instance.获取当前图片;
			获取最初的点击对象.GetComponent<MeshRenderer>().material.SetTextureScale("_MainTex", new Vector2(0.8f, 0.8f));
			获取最初的点击对象.GetComponent<MeshRenderer>().material.SetTextureOffset("_MainTex", new Vector2(-9.94f, 0.12f));
		}
		UnityEngine.Object.Destroy(_instance.获取最初的点击对象.GetComponent<ShowSelected>());
		_instance.获取最初的点击对象.GetComponent<MeshRenderer>().material.shader = mat;
	}
}
public class fuwei
{
	public List<Vector3> list1 = new List<Vector3>();

	public List<Quaternion> list2 = new List<Quaternion>();

	public List<Material> list3 = new List<Material>();

	public void 开始()
	{
		Quaternion rotation = moving._instance.transform.rotation;
		Vector3 position = moving._instance.transform.position;
		Vector3 localScale = moving._instance.transform.localScale;
		list1.Add(position);
		list1.Add(localScale);
		list2.Add(rotation);
	}

	public void 贴图颜色复原()
	{
		Material item = OnTrigger._instance.x.GetComponent<MeshRenderer>().materials[0];
		Material item2 = OnTrigger._instance.y.GetComponent<MeshRenderer>().materials[0];
		Material item3 = OnTrigger._instance.z.GetComponent<MeshRenderer>().materials[0];
		list3.Add(item);
		list3.Add(item2);
		list3.Add(item3);
	}
}
public class handCol : MonoBehaviour
{
	public static handCol _instance;
}
public class ImageSecondItem : MonoBehaviour
{
	public Image 图标;

	public Text 描述;

	public Text 内容;

	public Text 子目录标志;

	private void Awake()
	{
		图标 = base.transform.Find("ImageIcon").GetComponent<Image>();
		内容 = base.transform.Find("BgImage/Text02").GetComponent<Text>();
		描述 = base.transform.Find("BgImage/Text03").GetComponent<Text>();
		子目录标志 = base.transform.Find("BgImage/Text01").GetComponent<Text>();
	}

	public void UpdateImage(string 路径)
	{
		StartCoroutine(下载图片(路径));
	}

	private IEnumerator 下载图片(string url)
	{
		WWW date = new WWW(url);
		yield return date;
		Texture2D texture = date.texture;
		图标.overrideSprite = Sprite.Create(texture, new Rect(0f, 0f, texture.width, texture.height), new Vector2(0f, 0f));
	}
}
public class Item
{
	private string _上;

	private string _中;

	private string _下;

	private string _子;

	public string 上
	{
		get
		{
			return _上;
		}
		set
		{
			_上 = value;
		}
	}

	public string 中
	{
		get
		{
			return _中;
		}
		set
		{
			_中 = value;
		}
	}

	public string 下
	{
		get
		{
			return _下;
		}
		set
		{
			_下 = value;
		}
	}

	public string 子
	{
		get
		{
			return _子;
		}
		set
		{
			_子 = value;
		}
	}
}
public class jia
{
	private static jia instance = null;

	private static readonly object lockHelper = new object();

	private jia()
	{
	}

	public static jia CreateInstance()
	{
		if (instance == null)
		{
			lock (lockHelper)
			{
				if (instance == null)
				{
					instance = new jia();
				}
			}
		}
		return instance;
	}

	public void jiafangfa(string type)
	{
		switch (type)
		{
		case "开灯":
		case "关灯":
			LightOpen._instance.SendMessage(type);
			break;
		case "开电视":
			TVOpen._instance.SendMessage(type);
			break;
		case "关电视":
			TVOpen._instance.SendMessage(type);
			break;
		case "开音响":
		case "关音响":
			OpenMusic._instance.SendMessage(type);
			break;
		case "开风扇":
		case "关风扇":
			FengSan._instance.SendMessage(type);
			break;
		case "移动":
		case "缩小":
		case "放大":
		case "旋转":
			moving._instance.SendMessage(type);
			break;
		case "开门":
		case "关门":
		case "开窗":
		case "关窗":
		case "点火":
		case "关火":
		case "点蜡烛":
		case "关蜡烛":
		case "开冰箱":
		case "关冰箱":
		case "开空调":
		case "关空调":
			OnTrigger._instance.SendMessage(type);
			break;
		case "虚":
			主虚.逮.SendMessage(type);
			break;
		}
	}
}
public class LeftHand : MonoBehaviour
{
	public GameObject 画布;

	private float timer;

	[HideInInspector]
	public static bool 是否显示UI;

	public float height;

	public Transform pos;

	public LineRenderer Line;

	public GameObject 魔法书;

	public GameObject 开魔法书;

	private void Start()
	{
		是否显示UI = false;
	}

	private void Update()
	{
		InputDevices.GetDeviceAtXRNode(XRNode.LeftHand).TryGetFeatureValue(UnityEngine.XR.CommonUsages.menuButton, out var value);
		if (value)
		{
			timer += 1f;
			是否显示UI = !是否显示UI;
			if (是否显示UI)
			{
				画布.transform.position = pos.transform.position;
				画布.transform.localRotation = new Quaternion(0f, base.transform.localRotation.y, 0f, base.transform.localRotation.w);
				float x = 画布.transform.localEulerAngles.x;
				float y = 画布.transform.localEulerAngles.y - 38f;
				float z = 画布.transform.localEulerAngles.z;
				画布.transform.localRotation = Quaternion.Euler(x, y, z);
				画布.SetActive(value: true);
				timer = 0f;
				魔法书.SetActive(value: false);
				开魔法书.SetActive(value: true);
				井模块._instance.输入法隐藏();
			}
			else
			{
				画布.SetActive(value: false);
				魔法书.SetActive(value: true);
				开魔法书.SetActive(value: false);
			}
		}
	}
}
public class LightOpen : MonoBehaviour
{
	public static LightOpen _instance;

	public GameObject 灯1;

	public GameObject 灯2;

	public GameObject 客厅灯1;

	public GameObject 客厅灯2;

	public bool 是否开灯;

	private void Awake()
	{
		_instance = this;
	}

	private void Start()
	{
	}

	public void 开灯()
	{
		灯1.AddComponent<Light>();
		灯2.AddComponent<Light>();
		base.gameObject.AddComponent<Light>();
		客厅灯1.SetActive(value: true);
		客厅灯2.SetActive(value: true);
		是否开灯 = true;
		MonoBehaviour.print("开灯咯。。。。。。。");
	}

	public void 关灯()
	{
		if (是否开灯)
		{
			UnityEngine.Object.Destroy(灯1.GetComponent<Light>());
			UnityEngine.Object.Destroy(灯2.GetComponent<Light>());
			UnityEngine.Object.Destroy(base.gameObject.GetComponent<Light>());
			客厅灯1.SetActive(value: false);
			客厅灯2.SetActive(value: false);
			是否开灯 = false;
			MonoBehaviour.print("关灯");
		}
	}
}
public class Line : MonoBehaviour
{
	public Transform cube;

	public Transform cube1;

	public Transform cube2;

	public GameObject line2;

	private LineRenderer 线1;

	private LineRenderer 线2;

	private void Start()
	{
		线1 = base.transform.GetComponent<LineRenderer>();
		线2 = line2.transform.GetComponent<LineRenderer>();
	}

	private void Update()
	{
	}
}
public class moving : MonoBehaviour
{
	public static moving _instance;

	private float 速度;

	private bool 是否点击;

	public fuwei 复位1;

	private void Awake()
	{
		_instance = this;
	}

	private void Start()
	{
		复位1 = new fuwei();
		复位1.开始();
	}

	private void Update()
	{
		if (是否点击)
		{
			移动();
		}
	}

	public void 移动()
	{
		if (ShowSelected._instance.是否点击)
		{
			Vector3 vector = Camera.main.WorldToScreenPoint(base.transform.position);
			Vector3 mousePosition = Input.mousePosition;
			mousePosition.z = vector.z;
			Camera.main.ScreenToWorldPoint(mousePosition);
			速度 = 1f;
			base.transform.Translate(Vector3.forward * 速度 * Time.deltaTime);
			是否点击 = true;
			MonoBehaviour.print("移动");
			MonoBehaviour.print(是否点击);
		}
	}

	public void 缩小()
	{
		MonoBehaviour.print("hahah");
		if (ShowSelected._instance.是否点击)
		{
			base.transform.localScale *= 0.5f;
			MonoBehaviour.print("缩小");
		}
	}

	public void 放大()
	{
		if (ShowSelected._instance.是否点击)
		{
			base.transform.localScale *= 1.5f;
		}
	}

	public void 旋转()
	{
		if (ShowSelected._instance.是否点击)
		{
			base.transform.Rotate(0f, 20f, 0f);
		}
	}

	public void 复位()
	{
		MonoBehaviour.print("复位了");
		base.transform.position = 复位1.list1[0];
		base.transform.localScale = 复位1.list1[1];
		base.transform.rotation = 复位1.list2[0];
	}
}
public class OnTrigger : MonoBehaviour
{
	public static OnTrigger _instance;

	public GameObject 门;

	public GameObject 窗户;

	private bool isOpen;

	private HingeJoint hjoint;

	private bool 是否开窗;

	private int i = 1;

	private int a = -1;

	private int b = -1;

	private int c = 1;

	public GameObject 方向模型;

	public GameObject 大小模型;

	private bool 出现方向;

	private bool 出现大小;

	public GameObject x;

	public GameObject y;

	public GameObject z;

	private GameObject 零点;

	public GameObject 大小1;

	public GameObject 方向1;

	private bool 是方向X;

	private bool 是方向Y;

	private bool 是方向Z;

	private bool 是方向XY;

	private bool 是方向YZ;

	private bool 是方向XZ;

	private bool 是大小XYZ;

	private bool 是左窗户;

	private bool 是右窗户;

	private JointMotor motor;

	private GameObject 门1;

	public GameObject 图片;

	public GameObject 存放子类;

	public GameObject rightGame;

	public bool 是否触碰 = true;

	public GameObject gameObj;

	public Shader mat;

	private bool 是否点击方向模型;

	private GameObject 零点对象;

	public bool 是否缩放;

	public bool 是否触碰了大小模型;

	public bool 是否旋转;

	public bool 是否旋转模型;

	private float yy;

	private float xx;

	public Vector3 Rotation1;

	private GameObject 飞镖;

	public bool 是否换图;

	public GameObject 火特效;

	private GameObject 火;

	public GameObject 蜡烛;

	private GameObject 烛心;

	public GameObject 蜡烛模型;

	public GameObject 冰箱;

	public GameObject 空调;

	private bool 选择1;

	private void Awake()
	{
		_instance = this;
	}

	private void Start()
	{
	}

	private void Update()
	{
	}

	public void 旋转()
	{
		选择1 = false;
		删除所有模型();
		if (followMove._instance.gameObj == null)
		{
			飞镖.SetActive(value: true);
		}
		if (出现方向)
		{
			是否缩放 = false;
			是否旋转 = true;
			followMove._instance.开始触摸 = false;
			是否触碰了大小模型 = true;
			是否旋转模型 = true;
			followMove._instance.位置移动();
		}
	}

	public void 缩放()
	{
		选择1 = false;
		删除所有模型();
		if (followMove._instance.gameObj == null)
		{
			飞镖.SetActive(value: true);
		}
		是否缩放 = true;
		if (大小1 == null)
		{
			大小1 = UnityEngine.Object.Instantiate(大小模型, rightGame.transform);
			大小1.transform.localPosition = new Vector3(-0.0038f, 0.0549f, 0.0085f);
			大小1.transform.localRotation = Quaternion.Euler(-13.385f, -178.831f, 2.776f);
			出现大小 = true;
			给碰撞体(大小1);
			if (方向1 != null)
			{
				销毁方向();
				MonoBehaviour.print(方向1?.ToString() + "11111111111111");
			}
		}
		是否触碰了大小模型 = true;
		是否旋转 = false;
		followMove._instance.开始触摸 = false;
		是否旋转模型 = false;
		MonoBehaviour.print("大小.........");
	}

	public void 移动()
	{
		选择1 = false;
		删除所有模型();
		if (followMove._instance.gameObj == null)
		{
			飞镖.SetActive(value: true);
		}
		是否旋转 = false;
		是否缩放 = false;
		followMove._instance.开始触摸 = true;
		是否旋转模型 = false;
		是否触碰了大小模型 = false;
		followMove._instance.位置移动();
	}

	public void 开门()
	{
		hjoint = 门.GetComponent<HingeJoint>();
		motor = default(JointMotor);
		motor.targetVelocity = 20f;
		motor.force = 20f;
		hjoint.motor = motor;
	}

	public void 关门()
	{
		hjoint = 门.GetComponent<HingeJoint>();
		motor = default(JointMotor);
		motor.targetVelocity = -20f;
		motor.force = 20f;
		hjoint.motor = motor;
	}

	public void 开冰箱()
	{
		hjoint = 冰箱.GetComponent<HingeJoint>();
		motor = default(JointMotor);
		motor.targetVelocity = -20f;
		motor.force = 20f;
		hjoint.motor = motor;
	}

	public void 关冰箱()
	{
		hjoint = 冰箱.GetComponent<HingeJoint>();
		motor = default(JointMotor);
		motor.targetVelocity = 20f;
		motor.force = 20f;
		hjoint.motor = motor;
	}

	public void 开窗()
	{
		float num = 1.25f;
		窗户.transform.Translate(Vector3.forward * num);
	}

	public void 关窗()
	{
		float num = 1.25f;
		窗户.transform.Translate(Vector3.back * num);
	}

	public void 点火()
	{
		火 = UnityEngine.Object.Instantiate(火特效);
		火.transform.localPosition = new Vector3(5.844f, 0.502f, 16.81f);
	}

	public void 关火()
	{
		if (火 != null)
		{
			UnityEngine.Object.Destroy(火);
		}
	}

	public void 开空调()
	{
		空调.SetActive(value: true);
	}

	public void 关空调()
	{
		空调.SetActive(value: false);
	}

	public void 点蜡烛()
	{
		烛心 = UnityEngine.Object.Instantiate(蜡烛模型, 蜡烛.transform);
		烛心.transform.localPosition = new Vector3(-0.0003f, 0.1322f, 0.0033f);
		烛心.transform.localScale = new Vector3(13f, 13f, 13f);
		蜡烛.transform.Find("点光源").gameObject.SetActive(value: true);
	}

	public void 关蜡烛()
	{
		if (烛心 != null)
		{
			UnityEngine.Object.Destroy(烛心);
			蜡烛.transform.Find("点光源").gameObject.SetActive(value: false);
		}
	}

	public void 给碰撞体(GameObject name)
	{
		x = name.transform.Find("X").gameObject;
		y = name.transform.Find("Y").gameObject;
		z = name.transform.Find("Z").gameObject;
		零点 = name.transform.Find("零点").gameObject;
	}

	public void 颜色复原()
	{
		x.GetComponent<MeshRenderer>().materials[0].color = Color.red;
		z.GetComponent<MeshRenderer>().materials[0].color = Color.blue;
		y.GetComponent<MeshRenderer>().materials[0].color = Color.green;
		零点.GetComponent<MeshRenderer>().materials[0].color = Color.white;
	}

	public void 销毁方向()
	{
		UnityEngine.Object.Destroy(方向1);
	}

	public void 销毁大小()
	{
		UnityEngine.Object.Destroy(大小1);
	}

	public void 移动缩放(int index)
	{
		followMove._instance.开始触摸 = false;
		是否旋转 = false;
		是否缩放 = false;
		颜色复原();
		if (index == 1)
		{
			是方向X = true;
			x.GetComponent<MeshRenderer>().materials[0].color = Color.yellow;
		}
		if (index == 2)
		{
			是方向Y = true;
			y.GetComponent<MeshRenderer>().materials[0].color = Color.yellow;
		}
		if (index == 3)
		{
			z.GetComponent<MeshRenderer>().materials[0].color = Color.yellow;
			是方向Z = true;
		}
		if (index == 4)
		{
			x.GetComponent<MeshRenderer>().materials[0].color = Color.yellow;
			y.GetComponent<MeshRenderer>().materials[0].color = Color.yellow;
			是方向XY = true;
		}
		if (index == 5)
		{
			x.GetComponent<MeshRenderer>().materials[0].color = Color.yellow;
			z.GetComponent<MeshRenderer>().materials[0].color = Color.yellow;
			是方向XZ = true;
		}
		if (index == 6)
		{
			z.GetComponent<MeshRenderer>().materials[0].color = Color.yellow;
			y.GetComponent<MeshRenderer>().materials[0].color = Color.yellow;
			是方向YZ = true;
		}
		if (index == 7)
		{
			z.GetComponent<MeshRenderer>().materials[0].color = Color.yellow;
			x.GetComponent<MeshRenderer>().materials[0].color = Color.yellow;
			y.GetComponent<MeshRenderer>().materials[0].color = Color.yellow;
			是大小XYZ = true;
		}
	}

	public void 摇杆移动(GameObject game, int i, bool 是否缩放, bool 是否旋转了)
	{
		if (选择1)
		{
			return;
		}
		if (是方向X && !是否缩放 && !是否旋转了)
		{
			switch (i)
			{
			case 1:
				game.transform.position += new Vector3(0.01f, 0f, 0f);
				break;
			case -1:
				game.transform.position -= new Vector3(0.01f, 0f, 0f);
				break;
			case 2:
				game.transform.position += new Vector3(0.01f, 0f, 0f);
				break;
			case -2:
				game.transform.position -= new Vector3(0.01f, 0f, 0f);
				break;
			}
			MonoBehaviour.print("x");
		}
		if (是方向Y && !是否缩放 && !是否旋转了)
		{
			switch (i)
			{
			case 1:
				game.transform.position += new Vector3(0f, 0.01f, 0f);
				break;
			case -1:
				game.transform.position -= new Vector3(0f, 0.01f, 0f);
				break;
			case 2:
				game.transform.position += new Vector3(0f, 0.01f, 0f);
				break;
			case -2:
				game.transform.position -= new Vector3(0f, 0.01f, 0f);
				break;
			}
			MonoBehaviour.print("y");
		}
		if (是方向Z && !是否缩放 && !是否旋转了)
		{
			switch (i)
			{
			case 1:
				game.transform.position += new Vector3(0f, 0f, 0.01f);
				break;
			case -1:
				game.transform.position -= new Vector3(0f, 0f, 0.01f);
				break;
			case 2:
				game.transform.position += new Vector3(0f, 0f, 0.01f);
				break;
			case -2:
				game.transform.position -= new Vector3(0f, 0f, 0.01f);
				break;
			}
			MonoBehaviour.print("z");
		}
		if (是方向YZ && !是否缩放 && !是否旋转了)
		{
			switch (i)
			{
			case 1:
				game.transform.position += new Vector3(0f, 0f, 0.01f);
				break;
			case -1:
				game.transform.position -= new Vector3(0f, 0f, 0.01f);
				break;
			case 2:
				game.transform.position += new Vector3(0f, 0.01f, 0f);
				break;
			case -2:
				game.transform.position -= new Vector3(0f, 0.01f, 0f);
				break;
			}
			MonoBehaviour.print("yz");
		}
		if (是方向XY && !是否缩放 && !是否旋转了)
		{
			switch (i)
			{
			case 1:
				game.transform.position += new Vector3(0.01f, 0f, 0f);
				break;
			case -1:
				game.transform.position -= new Vector3(0.01f, 0f, 0f);
				break;
			case 2:
				game.transform.position += new Vector3(0f, 0.01f, 0f);
				break;
			case -2:
				game.transform.position -= new Vector3(0f, 0.01f, 0f);
				break;
			}
			MonoBehaviour.print("xy");
		}
		if (是方向XZ && !是否缩放 && !是否旋转了)
		{
			followMove._instance.开始触摸 = true;
		}
		if (是方向X && 是否缩放 && !是否旋转了)
		{
			switch (i)
			{
			case 1:
				game.transform.localScale += new Vector3(0.001f, 0f, 0f);
				break;
			case -1:
				game.transform.localScale -= new Vector3(0.001f, 0f, 0f);
				break;
			}
			switch (i)
			{
			case 2:
				game.transform.localScale -= new Vector3(0.001f, 0f, 0f);
				break;
			case -2:
				game.transform.localScale += new Vector3(0.001f, 0f, 0f);
				break;
			}
		}
		if (是方向Y && 是否缩放 && !是否旋转了)
		{
			switch (i)
			{
			case -1:
			case 2:
				game.transform.localScale -= new Vector3(0f, 0.001f, 0f);
				break;
			case -2:
			case 1:
				game.transform.localScale += new Vector3(0f, 0.001f, 0f);
				break;
			}
		}
		if (是方向Z && 是否缩放 && !是否旋转了)
		{
			switch (i)
			{
			case -1:
			case 2:
				game.transform.localScale -= new Vector3(0f, 0f, 0.001f);
				break;
			case -2:
			case 1:
				game.transform.localScale += new Vector3(0f, 0f, 0.001f);
				break;
			}
		}
		if (是方向XY && 是否缩放 && !是否旋转了)
		{
			switch (i)
			{
			case 1:
				game.transform.localScale += new Vector3(0.001f, 0f, 0f);
				break;
			case -1:
				game.transform.localScale -= new Vector3(0.001f, 0f, 0f);
				break;
			}
			switch (i)
			{
			case 2:
				game.transform.localScale -= new Vector3(0f, 0.001f, 0f);
				break;
			case -2:
				game.transform.localScale += new Vector3(0f, 0.001f, 0f);
				break;
			}
		}
		if (是方向YZ && 是否缩放 && !是否旋转了)
		{
			switch (i)
			{
			case 1:
				game.transform.localScale += new Vector3(0f, 0.001f, 0f);
				break;
			case -1:
				game.transform.localScale -= new Vector3(0f, 0.001f, 0f);
				break;
			}
			switch (i)
			{
			case 2:
				game.transform.localScale -= new Vector3(0f, 0f, 0.001f);
				break;
			case -2:
				game.transform.localScale += new Vector3(0f, 0f, 0.001f);
				break;
			}
		}
		if (是方向XZ && 是否缩放 && !是否旋转了)
		{
			switch (i)
			{
			case 1:
				game.transform.localScale += new Vector3(0.001f, 0f, 0f);
				break;
			case -1:
				game.transform.localScale -= new Vector3(0.001f, 0f, 0f);
				break;
			}
			switch (i)
			{
			case 2:
				game.transform.localScale -= new Vector3(0f, 0f, 0.001f);
				break;
			case -2:
				game.transform.localScale += new Vector3(0f, 0f, 0.001f);
				break;
			}
		}
		if (是大小XYZ && 是否缩放 && !是否旋转了)
		{
			switch (i)
			{
			case 1:
				game.transform.localScale += new Vector3(0.001f, 0.001f, 0.001f);
				break;
			case -1:
				game.transform.localScale -= new Vector3(0.001f, 0.001f, 0.001f);
				break;
			}
			switch (i)
			{
			case 2:
				game.transform.localScale -= new Vector3(0.001f, 0.001f, 0.001f);
				break;
			case -2:
				game.transform.localScale += new Vector3(0.001f, 0.001f, 0.001f);
				break;
			}
		}
		if (是方向X && 是否旋转了)
		{
			switch (i)
			{
			case 1:
			case 2:
				xx -= 0.01f;
				game.transform.Rotate(new Vector3(xx, 0f, 0f));
				break;
			case -2:
			case -1:
				yy += 0.01f;
				game.transform.Rotate(new Vector3(yy, 0f, 0f));
				break;
			}
		}
		if (是方向Z && 是否旋转了)
		{
			switch (i)
			{
			case 1:
			case 2:
				xx -= 0.01f;
				game.transform.Rotate(new Vector3(0f, 0f, xx));
				break;
			case -2:
			case -1:
				yy += 0.01f;
				game.transform.Rotate(new Vector3(0f, 0f, yy));
				break;
			}
		}
		if (是方向XY && 是否旋转了)
		{
			switch (i)
			{
			case 1:
				xx -= 0.01f;
				game.transform.Rotate(new Vector3(xx, 0f, 0f));
				break;
			case -1:
				yy += 0.01f;
				game.transform.Rotate(new Vector3(yy, 0f, 0f));
				break;
			}
			switch (i)
			{
			case 2:
				yy += 0.01f;
				game.transform.Rotate(new Vector3(0f, yy, 0f));
				break;
			case -2:
				xx -= 0.01f;
				game.transform.Rotate(new Vector3(0f, xx, 0f));
				break;
			}
		}
		if (是方向XZ && 是否旋转了)
		{
			switch (i)
			{
			case 1:
				xx -= 0.01f;
				game.transform.Rotate(new Vector3(xx, 0f, 0f));
				break;
			case -1:
				yy += 0.01f;
				game.transform.Rotate(new Vector3(yy, 0f, 0f));
				break;
			}
			switch (i)
			{
			case 2:
				xx -= 0.01f;
				game.transform.Rotate(new Vector3(0f, 0f, xx));
				break;
			case -2:
				yy += 0.01f;
				game.transform.Rotate(new Vector3(0f, 0f, yy));
				break;
			}
		}
		if (是方向YZ && 是否旋转了)
		{
			switch (i)
			{
			case 1:
				yy += 0.01f;
				game.transform.Rotate(new Vector3(0f, yy, 0f));
				break;
			case -1:
				xx -= 0.01f;
				game.transform.Rotate(new Vector3(0f, xx, 0f));
				break;
			}
			switch (i)
			{
			case 2:
				xx -= 0.01f;
				game.transform.Rotate(new Vector3(0f, 0f, xx));
				break;
			case -2:
				yy += 0.01f;
				game.transform.Rotate(new Vector3(0f, 0f, yy));
				break;
			}
		}
		if (是方向Y && 是否旋转了)
		{
			是否旋转 = true;
		}
	}

	public void 创建方向模型()
	{
		if (方向1 == null)
		{
			方向1 = UnityEngine.Object.Instantiate(方向模型, rightGame.transform);
			方向1.transform.localRotation = Quaternion.Euler(-13.385f, -178.831f, 2.776f);
			方向1.transform.localPosition = new Vector3(0.048f, 0.112f, 0.169f);
			出现方向 = true;
			给碰撞体(方向1);
			if (大小1 != null)
			{
				销毁大小();
			}
		}
	}

	public void 删除()
	{
		删除所有模型();
		if (followMove._instance.gameObj == null)
		{
			飞镖.SetActive(value: true);
		}
		if (followMove._instance.gameObj != null)
		{
			UnityEngine.Object.Destroy(followMove._instance.gameObj);
		}
	}

	public void 隐藏()
	{
		删除所有模型();
		if (followMove._instance.gameObj == null)
		{
			飞镖.SetActive(value: true);
		}
		followMove._instance.gameObj.SetActive(value: false);
	}

	public void 摆地上()
	{
		删除所有模型();
		if (followMove._instance.gameObj == null)
		{
			飞镖.SetActive(value: true);
		}
		if (followMove._instance.gameObj != null)
		{
			followMove._instance.gameObj.transform.rotation = Quaternion.Euler(Rotation1);
			followMove._instance.gameObj.transform.position = new Vector3(followMove._instance.gameObj.transform.position.x, 0f, followMove._instance.gameObj.transform.position.z);
		}
	}

	public void 摆桌上()
	{
		删除所有模型();
		if (followMove._instance.gameObj == null)
		{
			飞镖.SetActive(value: true);
		}
		if (followMove._instance.gameObj != null)
		{
			followMove._instance.gameObj.transform.rotation = Quaternion.Euler(Rotation1);
			followMove._instance.gameObj.transform.position = new Vector3(followMove._instance.gameObj.transform.position.x, 0.74f, followMove._instance.gameObj.transform.position.z);
		}
	}

	public void 摆凳上()
	{
		删除所有模型();
		if (followMove._instance.gameObj == null)
		{
			飞镖.SetActive(value: true);
		}
		if (followMove._instance.gameObj != null)
		{
			followMove._instance.gameObj.transform.rotation = Quaternion.Euler(Rotation1);
			followMove._instance.gameObj.transform.position = new Vector3(followMove._instance.gameObj.transform.position.x, 0.42f, followMove._instance.gameObj.transform.position.z);
		}
	}

	public void 摆天花板下()
	{
		if (followMove._instance.gameObj != null)
		{
			followMove._instance.gameObj.transform.rotation = Quaternion.Euler(Rotation1);
			float num = followMove._instance.gameObj.GetComponent<Collider>().bounds.size.y;
			float num2 = followMove._instance.gameObj.transform.localScale.y;
			float num3 = num * num2;
			MonoBehaviour.print(num3 + "dddddd");
			float num4 = 2.8f - num3;
			followMove._instance.gameObj.transform.position = new Vector3(followMove._instance.gameObj.transform.position.x, num4, followMove._instance.gameObj.transform.position.z);
		}
	}

	public void 选择()
	{
		选择1 = true;
		followMove._instance.开始触摸 = false;
		是否旋转 = false;
		是否缩放 = false;
		删除所有模型();
		followMove._instance.位置移动();
		MonoBehaviour.print("选择");
	}

	public void 攻击()
	{
		删除所有模型();
		MonoBehaviour.print("mao111111111111........攻击......");
		if (followMove._instance.gameObj == null)
		{
			飞镖.SetActive(value: true);
		}
	}

	public void 换图()
	{
		MonoBehaviour.print("换图()");
		删除所有模型();
		if (followMove._instance.gameObj == null)
		{
			飞镖.SetActive(value: true);
		}
		是否换图 = true;
		MonoBehaviour.print("ttttttt换图()tttttttt");
		followMove._instance.Pictures();
	}

	private void 删除所有模型()
	{
		if (是否换图)
		{
			是否换图 = false;
		}
		飞镖 = base.transform.Find("staff").gameObject;
	}

	public void 不同的方向模型(bool 是否是射线)
	{
		if (是否是射线)
		{
			是方向X = false;
			是方向Y = false;
			是方向XY = false;
			是方向Z = false;
			是方向YZ = false;
			是否点击方向模型 = false;
			是方向XZ = false;
			是大小XYZ = false;
		}
	}
}
public class OpenDoor : MonoBehaviour
{
}
public class OpenMusic : MonoBehaviour
{
	public static OpenMusic _instance;

	public AudioSource 播放音乐;

	private void Awake()
	{
		_instance = this;
	}

	public void 开音响()
	{
		播放音乐.Play();
	}

	public void 关音响()
	{
		播放音乐.Stop();
	}
}
public class SaveData
{
}
public class showSelected : MonoBehaviour
{
	public Shader selectedShader;

	public Color outterColor;

	private Color myColor;

	private Shader myShader;

	private bool Selected;

	public static showSelected _instance;

	private GameObject 对象;

	private void Awake()
	{
		_instance = this;
	}

	private void Start()
	{
	}

	public string 炫()
	{
		if (对象 == null || 对象 != Manager._instance.Down.当前选择)
		{
			myColor = Manager._instance.Down.当前选择.GetComponent<MeshRenderer>().material.color;
			myShader = Manager._instance.Down.当前选择.GetComponent<MeshRenderer>().material.shader;
			Manager._instance.Down.当前选择.GetComponent<MeshRenderer>().material.shader = selectedShader;
			Manager._instance.Down.当前选择.GetComponent<MeshRenderer>().material.SetColor("_RimColor", outterColor);
			Manager._instance.Down.当前选择.GetComponent<MeshRenderer>().material.SetColor("_MainColor", myColor);
		}
		对象 = Manager._instance.Down.当前选择;
		return "炫完";
	}

	public string 不()
	{
		对象 = null;
		Manager._instance.Down.当前选择.GetComponent<MeshRenderer>().material.color = myColor;
		Manager._instance.Down.当前选择.GetComponent<MeshRenderer>().material.shader = myShader;
		return "不完";
	}

	public void Change_Color()
	{
		if ((bool)检测._instance.Main_Obj)
		{
			myColor = 检测._instance.Main_Obj.GetComponent<MeshRenderer>().material.color;
			myShader = 检测._instance.Main_Obj.GetComponent<MeshRenderer>().material.shader;
			if (!selectedShader)
			{
				base.enabled = false;
				return;
			}
			检测._instance.Main_Obj.GetComponent<MeshRenderer>().material.shader = selectedShader;
			检测._instance.Main_Obj.GetComponent<MeshRenderer>().material.SetColor("_RimColor", outterColor);
			检测._instance.Main_Obj.GetComponent<MeshRenderer>().material.SetColor("_MainColor", myColor);
			MonoBehaviour.print("Change_Color()");
		}
	}
}
public class Test2 : MonoBehaviour
{
	private void Start()
	{
		GC.套接.On("户广", 户广);
		StartCoroutine("开始");
	}

	private IEnumerator 开始()
	{
		yield return new WaitForSeconds(2f);
		MonoBehaviour.print("s");
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		dictionary["户"] = "10774";
		dictionary["广"] = "井虚我";
		GC.套接.Emit("加载户广", new JSONObject(dictionary));
		GC.套接.Emit("连接");
	}

	public void 连接成功(SocketIOEvent 参数)
	{
		MonoBehaviour.print("连接成功");
	}

	public void 户广(SocketIOEvent 参数)
	{
		MonoBehaviour.print(参数);
	}

	private void Update()
	{
	}
}
public class triggerEnter : MonoBehaviour
{
	private void OnTriggerEnter(Collider col)
	{
	}
}
public class TVOpen : MonoBehaviour
{
	public static TVOpen _instance;

	public AudioSource 声音;

	public bool 是否开电视;

	public Material 原纹理;

	private void Awake()
	{
		_instance = this;
	}

	public void 开电视()
	{
		if (!是否开电视)
		{
			GetComponent<MeshRenderer>().materials[1].color = Color.white;
			声音.Play();
			是否开电视 = true;
			MonoBehaviour.print("开电视()");
		}
	}

	public void 关电视()
	{
		if (是否开电视)
		{
			声音.Stop();
			GetComponent<MeshRenderer>().materials[1].color = Color.black;
			GetComponent<MeshRenderer>().materials[1].mainTexture = null;
			是否开电视 = false;
		}
	}

	private void Start()
	{
	}

	private void EndReached(VideoPlayer vp)
	{
		vp.playbackSpeed /= 10f;
	}
}
public class VR2045 : MonoBehaviour
{
	public enum CurState
	{
		One,
		Two,
		Three
	}

	public enum OperationState
	{
		KeyBoard,
		InputVR
	}

	public static VR2045 _instance;

	public string 虚我号;

	public GameObject grid;

	public GameObject gridSecond;

	public GameObject ItemUI;

	public GameObject ItemUISecond;

	private bool 是否图标切换;

	private string 中;

	private Text rootText;

	private string strPath = "http://224248.com/png/快/";

	private string finalPath;

	public LineRenderer Line;

	public Transform 手柄;

	private Vector3 targetPoint;

	public Transform 图标切换按钮;

	public Transform 编辑切换按钮;

	public Transform 恢复默认按钮;

	public Transform 返回按钮;

	public GameObject Root;

	public GameObject RootSecond;

	public Scrollbar scrollbar;

	private Vector3 oldPos;

	private Vector3 newPos;

	private float y;

	private CurState state;

	private OperationState operationState;

	private bool 是否显示宫格 = true;

	private bool 是否编辑模式;

	private string 输入文字;

	private string 测试修改文字;

	private string 修改文字;

	[HideInInspector]
	public string 字母标志 = "";

	private JSONObject 取得数据;

	private JSONObject 默认数据;

	public GameObject 编辑提示;

	private bool 是否恢复默认;

	public GameObject 输入法;

	[HideInInspector]
	public string 修改新内容 = "";

	public SocketIOComponent 套接;

	public bool 是否首次运行;

	private KeyCode 当前键盘按键;

	private bool 退出按键;

	private string 临时键盘按键 = "";

	private bool 运行停止;

	public GameObject 输入框;

	private string 获取输入框内容 = "";

	public Transform 输入法出现位置;

	public Transform 输入法出现位置二;

	private void Awake()
	{
		_instance = this;
	}

	private void Start()
	{
		虚我号 = PlayerPrefs.GetString("虚我号");
		MonoBehaviour.print("获得虚拟号：" + 虚我号);
		当前键盘按键 = KeyCode.Space;
		套接 = GC.套接;
		rootText = base.transform.Find("Btn/RootText").GetComponent<Text>();
		StartCoroutine("首次运行");
		Line.SetWidth(0.01f, 0.01f);
		套接.On("户广", 户广);
	}

	private void OnGUI()
	{
		if (Input.anyKeyDown)
		{
			Event current = Event.current;
			if (current.isKey && !退出按键)
			{
				当前键盘按键 = current.keyCode;
				临时键盘按键 = 当前键盘按键.ToString();
				退出按键 = true;
				运行停止 = false;
			}
		}
		else
		{
			退出按键 = false;
		}
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Alpha1))
		{
			跳转(虚我号, "虚我");
		}
		if (Input.GetKeyDown(KeyCode.Alpha2))
		{
			BroadcastMessage("Fast", SendMessageOptions.DontRequireReceiver);
		}
		if (Input.GetKeyDown(KeyCode.Alpha3))
		{
			运行停止 = false;
			MonoBehaviour.print(运行停止);
		}
		Input.GetKeyDown(KeyCode.Alpha4);
		射线检测();
		if (!运行停止 && !是否编辑模式)
		{
			operationState = OperationState.KeyBoard;
			操作方式();
		}
	}

	private IEnumerator 首次运行()
	{
		MonoBehaviour.print("0首次运行");
		yield return new WaitForSeconds(1f);
		跳转(虚我号, "井虚我");
		rootText.text = "井虚我";
	}

	public void 命令(string 参数)
	{
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		dictionary["命令"] = 参数;
		套接.Emit("命令通信", new JSONObject(dictionary));
	}

	public void EnterBtn()
	{
		if ((bool)GameObject.Find("InputField"))
		{
			输入文字 = 输入框.GetComponent<InputField>().text;
			Dictionary<string, string> dictionary = new Dictionary<string, string>();
			dictionary["户"] = 虚我号;
			dictionary["广"] = rootText.text;
			dictionary["字段"] = 字母标志;
			dictionary["内容"] = 输入文字;
			套接.Emit("更改户广", new JSONObject(dictionary));
			跳转(虚我号, rootText.text);
			StartCoroutine("加载数据");
		}
	}

	public void 修改数据(string 下标, string 新内容)
	{
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		dictionary["户"] = 虚我号;
		dictionary["广"] = rootText.text;
		dictionary["字段"] = 下标;
		dictionary["内容"] = 新内容;
		套接.Emit("更改户广", new JSONObject(dictionary));
		跳转(虚我号, rootText.text);
		StartCoroutine("加载数据");
	}

	private void 射线检测()
	{
		if (!Input.GetMouseButtonDown(0) || !Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out var hitInfo, 600f))
		{
			return;
		}
		if (!是否编辑模式)
		{
			if (hitInfo.collider.tag == "ImageSecond")
			{
				string text = hitInfo.transform.GetComponent<ImageSecondItem>().内容.text;
				MonoBehaviour.print("内容:" + text);
				string text2 = text.Substring(0, 1);
				string text3 = text.Substring(1);
				if (text2 == "#")
				{
					state = CurState.One;
					跳转(虚我号, text3);
					rootText.text = text3;
				}
				else if (text2 == "=")
				{
					state = CurState.Two;
					跳转(虚我号, text3);
					rootText.text = text3;
				}
				else
				{
					BroadcastMessage(text, SendMessageOptions.DontRequireReceiver);
				}
				MonoBehaviour.print(text2);
				MonoBehaviour.print(text3);
			}
			if (hitInfo.collider.tag == "Image")
			{
				中 = hitInfo.transform.GetComponent<ImageItem>().内容.text;
				string text4 = 中.Substring(0, 1);
				string text5 = 中.Substring(1);
				MonoBehaviour.print("#000000:" + text5);
				if (text4 == "井")
				{
					state = CurState.One;
					跳转(虚我号, 中);
					rootText.text = 中;
					StartCoroutine("加载数据");
				}
				else if (text4 == "丰")
				{
					state = CurState.Two;
					跳转(虚我号, 中);
					rootText.text = 中;
					StartCoroutine("加载数据");
				}
				else
				{
					BroadcastMessage(中, SendMessageOptions.DontRequireReceiver);
				}
			}
		}
		else
		{
			输入框.SetActive(value: true);
			if (hitInfo.collider.tag == "ImageSecond")
			{
				测试修改文字 = hitInfo.transform.GetComponent<ImageSecondItem>().内容.text;
				MonoBehaviour.print("内容:" + 测试修改文字);
			}
			if (hitInfo.collider.tag == "Change01")
			{
				MonoBehaviour.print("Image01");
				字母标志 = hitInfo.transform.parent.GetComponent<ImageItem>().字母.text;
				MonoBehaviour.print(字母标志);
			}
			if (hitInfo.collider.tag == "Change02")
			{
				MonoBehaviour.print("Image02");
				字母标志 = hitInfo.transform.parent.GetComponent<ImageItem>().字母.text + "2";
				MonoBehaviour.print(字母标志);
			}
			if (hitInfo.collider.tag == "Change03")
			{
				MonoBehaviour.print("Image03");
				字母标志 = hitInfo.transform.parent.GetComponent<ImageItem>().字母.text + "3";
				MonoBehaviour.print(字母标志);
			}
		}
	}

	private IEnumerator 加载数据()
	{
		yield return new WaitForSeconds(0.5f);
		获取数据处理();
		MonoBehaviour.print("加载数据");
	}

	private void FixedUpdate()
	{
		UnityEngine.XR.InputDevice deviceAtXRNode = InputDevices.GetDeviceAtXRNode(XRNode.LeftHand);
		deviceAtXRNode.TryGetFeatureValue(UnityEngine.XR.CommonUsages.triggerButton, out var value);
		if (Physics.Raycast(new Ray(手柄.position, 手柄.forward), out var hitInfo, 600f))
		{
			if (hitInfo.collider.gameObject.layer == 8)
			{
				Line.enabled = true;
				targetPoint = hitInfo.point;
				Line.SetPosition(0, 手柄.position);
				Line.SetPosition(1, hitInfo.point);
			}
			if (!是否编辑模式)
			{
				if (hitInfo.transform.CompareTag("Image"))
				{
					GameObject gameObject = hitInfo.transform.gameObject;
					hitInfo.transform.GetComponent<Image>().color = new Color(0.79607844f, 64f / 85f, 16f / 85f, 1f);
					for (int i = 0; i < grid.transform.childCount; i++)
					{
						GameObject gameObject2 = grid.transform.GetChild(i).gameObject;
						if (gameObject2 != gameObject)
						{
							gameObject2.GetComponent<Image>().color = new Color(0.9254902f, 46f / 51f, 48f / 85f, 1f);
						}
					}
					if (value)
					{
						string text = hitInfo.transform.GetComponent<ImageItem>().内容.text;
						string text2 = text.Substring(0, 1);
						text.Substring(1);
						string text3 = hitInfo.transform.GetComponent<ImageItem>().字母.text;
						MonoBehaviour.print("字母：" + text3);
						if (text2 == "井")
						{
							StopAllCoroutines();
							MonoBehaviour.print("进入跳转");
							state = CurState.One;
							跳转(虚我号, text);
							rootText.text = text;
							StartCoroutine("加载数据");
						}
						else if (text2 == "丰")
						{
							StopAllCoroutines();
							state = CurState.Two;
							跳转(虚我号, text);
							rootText.text = text;
							StartCoroutine("加载数据");
						}
						else
						{
							StopAllCoroutines();
							BroadcastMessage(text, SendMessageOptions.DontRequireReceiver);
							base.gameObject.SetActive(value: false);
						}
					}
				}
			}
			else if (hitInfo.collider.CompareTag("Change01"))
			{
				if (value)
				{
					字母标志 = hitInfo.transform.parent.GetComponent<ImageItem>().字母.text;
					MonoBehaviour.print(字母标志);
					输入法.SetActive(value: false);
					输入法.SetActive(value: true);
					输入法.transform.Find("BtnImage").gameObject.SetActive(value: true);
					关闭碰撞器();
					输入法.transform.position = 输入法出现位置二.position;
					输入法.transform.rotation = base.transform.rotation * Quaternion.Euler(-60f, 180f, 0f);
					输入法.GetComponent<Load>().字 = 输入法.transform.Find("BtnImage/获取框/Text").GetComponent<Text>();
					Var.字 = 输入法.transform.Find("BtnImage/获取框/Text").GetComponent<Text>();
				}
			}
			else if (hitInfo.collider.CompareTag("Change02"))
			{
				if (value)
				{
					MonoBehaviour.print("1111111111111:" + hitInfo.transform.name);
					字母标志 = hitInfo.transform.parent.GetComponent<ImageItem>().字母.text + "2";
					输入法.SetActive(value: false);
					输入法.SetActive(value: true);
					输入法.transform.Find("BtnImage").gameObject.SetActive(value: true);
					关闭碰撞器();
					输入法.transform.position = 输入法出现位置二.position;
					输入法.transform.rotation = base.transform.rotation * Quaternion.Euler(-60f, 180f, 0f);
					输入法.GetComponent<Load>().字 = 输入法.transform.Find("BtnImage/获取框/Text").GetComponent<Text>();
					Var.字 = 输入法.transform.Find("BtnImage/获取框/Text").GetComponent<Text>();
				}
			}
			else if (hitInfo.collider.CompareTag("Change03") && value)
			{
				MonoBehaviour.print("1111111111111:" + hitInfo.transform.name);
				字母标志 = hitInfo.transform.parent.GetComponent<ImageItem>().字母.text + "3";
				输入法.SetActive(value: false);
				输入法.SetActive(value: true);
				输入法.transform.Find("BtnImage").gameObject.SetActive(value: true);
				关闭碰撞器();
				输入法.transform.position = 输入法出现位置二.position;
				输入法.transform.rotation = base.transform.rotation * Quaternion.Euler(-60f, 180f, 0f);
				输入法.GetComponent<Load>().字 = 输入法.transform.Find("BtnImage/获取框/Text").GetComponent<Text>();
				Var.字 = 输入法.transform.Find("BtnImage/获取框/Text").GetComponent<Text>();
			}
			if (hitInfo.transform.CompareTag("InputText") && value)
			{
				输入法.SetActive(value: true);
				输入法.transform.Find("BtnImage").gameObject.SetActive(value: false);
				输入法.transform.position = 输入法出现位置二.position;
				输入法.transform.rotation = base.transform.rotation * Quaternion.Euler(-60f, 180f, 0f);
				输入法.GetComponent<Load>().字 = hitInfo.transform.Find("Text").GetComponent<Text>();
				Var.字 = hitInfo.transform.Find("Text").GetComponent<Text>();
			}
			if (hitInfo.transform.CompareTag("EnterBtn") && value)
			{
				获取输入框内容 = 输入框.transform.Find("Text").GetComponent<Text>().text;
				operationState = OperationState.InputVR;
				输入法.SetActive(value: false);
				操作方式();
				输入框.transform.Find("Text").GetComponent<Text>().text = null;
				开启碰撞器();
			}
			if (hitInfo.transform.CompareTag("ClearUp") && value)
			{
				输入法.transform.Find("BtnImage/获取框/Text").GetComponent<Text>().text = null;
				输入框.transform.Find("Text").GetComponent<Text>().text = null;
			}
			if (hitInfo.transform.gameObject.tag == "ImageSecond")
			{
				手柄移动();
				deviceAtXRNode.TryGetFeatureValue(UnityEngine.XR.CommonUsages.primaryButton, out var value2);
				if (value2)
				{
					if (y < 0f)
					{
						scrollbar.value += 0.005f;
					}
					else if (y > 0f)
					{
						scrollbar.value -= 0.005f;
					}
				}
				if (value)
				{
					string text4 = hitInfo.transform.GetComponent<ImageSecondItem>().内容.text;
					string text5 = text4.Substring(0, 1);
					string text6 = text4.Substring(1);
					if (text5 == "井")
					{
						StopAllCoroutines();
						state = CurState.One;
						跳转(虚我号, text6);
						rootText.text = text6;
						StartCoroutine("加载数据");
					}
					else if (text5 == "丰")
					{
						StopAllCoroutines();
						state = CurState.Two;
						跳转(虚我号, text6);
						rootText.text = text6;
						StartCoroutine("加载数据");
					}
					else
					{
						StopAllCoroutines();
						BroadcastMessage(text4, SendMessageOptions.DontRequireReceiver);
					}
				}
			}
			if (hitInfo.transform.name == "BackBtn")
			{
				按钮放大(返回按钮, 1.1f);
				if (value)
				{
					返回根目录();
				}
			}
			else if (hitInfo.transform.name == "RestoreBtn")
			{
				按钮放大(恢复默认按钮, 1.1f);
				if (value)
				{
					MonoBehaviour.print("恢复默认");
					恢复默认();
				}
			}
			else if (hitInfo.transform.name == "EditorBtn")
			{
				按钮放大(编辑切换按钮, 1.1f);
				if (value)
				{
					功能切换();
				}
			}
			else if (hitInfo.transform.name == "IconBtn")
			{
				按钮放大(图标切换按钮, 1.1f);
				if (value)
				{
					图标切换();
				}
			}
			else
			{
				按钮放大(图标切换按钮, 1f);
				按钮放大(编辑切换按钮, 1f);
				按钮放大(恢复默认按钮, 1f);
				按钮放大(返回按钮, 1f);
			}
		}
		else
		{
			Line.enabled = false;
		}
	}

	private void 按钮放大(Transform 按钮, float 放大倍数)
	{
		按钮.localScale = new Vector3(放大倍数, 放大倍数, 放大倍数);
	}

	public void 图标切换()
	{
		是否图标切换 = !是否图标切换;
		GameObject gameObject = ((!是否显示宫格) ? gridSecond : grid);
		if (是否图标切换)
		{
			图标切换按钮.Find("Text").GetComponent<Text>().text = "文 字";
			for (int i = 0; i < gameObject.transform.childCount; i++)
			{
				GameObject obj = gameObject.transform.GetChild(i).gameObject;
				obj.transform.Find("Image/Text").gameObject.SetActive(value: false);
				obj.transform.Find("Icon").gameObject.SetActive(value: true);
			}
		}
		else
		{
			图标切换按钮.Find("Text").GetComponent<Text>().text = "图 标";
			for (int j = 0; j < gameObject.transform.childCount; j++)
			{
				GameObject obj2 = gameObject.transform.GetChild(j).gameObject;
				obj2.transform.Find("Image/Text").gameObject.SetActive(value: true);
				obj2.transform.Find("Icon").gameObject.SetActive(value: false);
			}
		}
	}

	public void 获取数据处理()
	{
		MonoBehaviour.print("获取数据处理！");
		switch (state)
		{
		case CurState.One:
			Root.SetActive(value: true);
			RootSecond.SetActive(value: false);
			if (grid.transform.childCount == 0)
			{
				for (char c3 = 'a'; c3 < 'z'; c3 = (char)(c3 + 1))
				{
					GameObject obj3 = UnityEngine.Object.Instantiate(ItemUI, grid.transform.position, Quaternion.identity);
					obj3.transform.parent = grid.transform;
					obj3.transform.localScale = Vector3.one;
					obj3.transform.transform.localRotation = grid.transform.localRotation;
					中 = 取得数据["户广"][0][c3.ToString()].ToString().Replace("\"", "");
					obj3.GetComponent<ImageItem>().内容.text = 中;
					obj3.GetComponent<ImageItem>().描述.text = 取得数据["户广"][0][c3 + "2"].ToString().Replace("\"", "");
					obj3.GetComponent<ImageItem>().字母.text = c3.ToString();
					obj3.GetComponent<ImageItem>().备注.text = 取得数据["户广"][0][c3 + "3"].ToString().Replace("\"", "");
					string text3 = 中.Substring(0, 1);
					string path3 = 中.Substring(1);
					string s = ((!(text3 == "井") && !(text3 == "丰")) ? 转码(中) : 转码(path3));
					obj3.GetComponent<ImageItem>().UpdateImage(s);
				}
			}
			else
			{
				char c4 = 'a';
				for (int j = 0; j < grid.transform.childCount; j++)
				{
					GameObject obj4 = grid.transform.GetChild(j).gameObject;
					中 = 取得数据["户广"][0][c4.ToString()].ToString().Replace("\"", "");
					obj4.GetComponent<ImageItem>().内容.text = 中;
					string text4 = 取得数据["户广"][0][c4 + "2"].ToString().Replace("\"", "");
					obj4.GetComponent<ImageItem>().描述.text = text4;
					obj4.GetComponent<ImageItem>().字母.text = c4.ToString();
					obj4.GetComponent<ImageItem>().备注.text = 取得数据["户广"][0][c4 + "3"].ToString().Replace("\"", "");
					string text5 = 中.Substring(0, 1);
					string path4 = 中.Substring(1);
					string s2 = ((!(text5 == "井") && !(text5 == "丰")) ? 转码(中) : 转码(path4));
					obj4.GetComponent<ImageItem>().UpdateImage(s2);
					c4 = (char)(c4 + 1);
				}
			}
			break;
		case CurState.Two:
			Root.SetActive(value: false);
			RootSecond.SetActive(value: true);
			if (gridSecond.transform.childCount == 0)
			{
				for (char c = 'a'; c < 'z'; c = (char)(c + 1))
				{
					GameObject obj = UnityEngine.Object.Instantiate(ItemUISecond, gridSecond.transform.position, Quaternion.identity);
					obj.transform.parent = gridSecond.transform;
					obj.transform.localScale = Vector3.one;
					obj.transform.transform.localRotation = grid.transform.localRotation;
					中 = 取得数据["户广"][0][c.ToString()].ToString().Replace("\"", "");
					obj.GetComponent<ImageSecondItem>().内容.text = 中;
					obj.GetComponent<ImageSecondItem>().描述.text = 取得数据["户广"][0][c + "2"].ToString().Replace("\"", "");
					obj.GetComponent<ImageSecondItem>().子目录标志.text = 取得数据["户广"][0][c + "3"].ToString().Replace("\"", "");
					string text = 中.Substring(0, 1);
					string path = 中.Substring(1);
					string 路径 = ((!(text == "井") && !(text == "丰")) ? 转码(中) : 转码(path));
					obj.GetComponent<ImageSecondItem>().UpdateImage(路径);
				}
			}
			else
			{
				char c2 = 'a';
				for (int i = 0; i < gridSecond.transform.childCount; i++)
				{
					GameObject obj2 = gridSecond.transform.GetChild(i).gameObject;
					中 = 取得数据["户广"][0][c2.ToString()].ToString().Replace("\"", "");
					obj2.GetComponent<ImageSecondItem>().内容.text = 中;
					obj2.GetComponent<ImageSecondItem>().描述.text = 取得数据["户广"][0][c2 + "2"].ToString().Replace("\"", "");
					obj2.GetComponent<ImageSecondItem>().子目录标志.text = 取得数据["户广"][0][c2 + "3"].ToString().Replace("\"", "");
					string text2 = 中.Substring(0, 1);
					string path2 = 中.Substring(1);
					string 路径2 = ((!(text2 == "井") && !(text2 == "丰")) ? 转码(中) : 转码(path2));
					obj2.GetComponent<ImageSecondItem>().UpdateImage(路径2);
					c2 = (char)(c2 + 1);
				}
			}
			break;
		case CurState.Three:
			break;
		}
	}

	public void 户广(SocketIOEvent 参数)
	{
		if (!是否首次运行)
		{
			是否首次运行 = true;
			StartCoroutine("加载数据");
		}
		MonoBehaviour.print("户广执行");
		if (!是否恢复默认)
		{
			取得数据 = 参数.data;
			return;
		}
		默认数据 = 参数.data;
		MonoBehaviour.print("默认数据:" + 默认数据["户广"]);
		是否恢复默认 = false;
	}

	public void 初始化(string a, string b, string 字段, string 内容)
	{
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		dictionary["户"] = a;
		dictionary["广"] = b;
		dictionary["字段"] = 字段;
		dictionary["内容"] = 内容;
		套接.Emit("更改户广", new JSONObject(dictionary));
		跳转(a, b);
	}

	public void 跳转(string a, string b)
	{
		MonoBehaviour.print("跳转方法");
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		dictionary["户"] = a;
		dictionary["广"] = b;
		套接.Emit("加载户广", new JSONObject(dictionary));
	}

	public void 返回根目录()
	{
		state = CurState.One;
		跳转(虚我号, "井虚我");
		rootText.text = "井虚我";
		MonoBehaviour.print("按下返回按钮");
		StartCoroutine("加载数据");
	}

	public void 恢复默认()
	{
		是否恢复默认 = true;
		string text = rootText.text;
		跳转("10000", text);
		恢复数据();
	}

	public void 功能切换()
	{
		是否编辑模式 = !是否编辑模式;
		if (是否编辑模式)
		{
			编辑提示.SetActive(value: true);
			编辑切换按钮.Find("Text").GetComponent<Text>().text = "执 行";
			MonoBehaviour.print("编辑模式");
			for (int i = 0; i < grid.transform.childCount; i++)
			{
				GameObject obj = grid.transform.GetChild(i).gameObject;
				obj.GetComponent<BoxCollider>().enabled = false;
				obj.transform.Find("Image").gameObject.GetComponent<BoxCollider>().enabled = true;
				obj.transform.Find("Image01").gameObject.SetActive(value: true);
				obj.transform.Find("Image02").gameObject.SetActive(value: true);
			}
			return;
		}
		MonoBehaviour.print("非编辑模式");
		输入法.SetActive(value: false);
		编辑切换按钮.Find("Text").GetComponent<Text>().text = "编 辑";
		编辑提示.SetActive(value: false);
		for (int j = 0; j < grid.transform.childCount; j++)
		{
			GameObject obj2 = grid.transform.GetChild(j).gameObject;
			obj2.GetComponent<BoxCollider>().enabled = true;
			obj2.transform.Find("Image").gameObject.GetComponent<BoxCollider>().enabled = false;
			obj2.transform.Find("Image01").gameObject.SetActive(value: false);
			obj2.transform.Find("Image02").gameObject.SetActive(value: false);
		}
	}

	private void 手柄移动()
	{
		newPos = 手柄.position;
		if (!(oldPos == Vector3.zero))
		{
			y = newPos.y - oldPos.y;
		}
		oldPos = newPos;
	}

	private string 转码(string path)
	{
		string stringToEscape = strPath + path + ".png";
		finalPath = Uri.EscapeUriString(stringToEscape);
		return finalPath;
	}

	private void 恢复数据()
	{
		for (char c = 'a'; c < 'z'; c = (char)(c + 1))
		{
			string text = 默认数据["户广"][0][c.ToString()].ToString().Replace("\"", "");
			string text2 = 取得数据["户广"][0][c.ToString()].ToString().Replace("\"", "");
			string text3 = 默认数据["户广"][0][c + "2"].ToString().Replace("\"", "");
			string text4 = 取得数据["户广"][0][c + "2"].ToString().Replace("\"", "");
			string text5 = 默认数据["户广"][0][c + "3"].ToString().Replace("\"", "");
			string text6 = 取得数据["户广"][0][c + "3"].ToString().Replace("\"", "");
			if (text != text2)
			{
				初始化(虚我号, rootText.text, c.ToString(), text);
			}
			if (text3 != text4)
			{
				初始化(虚我号, rootText.text, c + "2", text3);
			}
			if (text5 != text6)
			{
				初始化(虚我号, rootText.text, c + "3", text5);
			}
		}
		跳转(虚我号, rootText.text);
		StartCoroutine("加载数据");
	}

	private void 操作方式()
	{
		GameObject gameObject = ((!是否显示宫格) ? gridSecond : grid);
		switch (operationState)
		{
		case OperationState.KeyBoard:
		{
			if (gameObject.transform.childCount == 0)
			{
				break;
			}
			for (int j = 0; j < gameObject.transform.childCount; j++)
			{
				GameObject gameObject2 = gameObject.transform.GetChild(j).gameObject;
				if (gameObject2.GetComponent<ImageItem>().字母.text == 临时键盘按键.ToLower())
				{
					string text4 = gameObject2.GetComponent<ImageItem>().内容.text;
					string text5 = text4.Substring(0, 1);
					text4.Substring(1);
					if (text5 == "井")
					{
						StopAllCoroutines();
						MonoBehaviour.print("进入跳转");
						state = CurState.One;
						跳转(虚我号, text4);
						rootText.text = text4;
						StartCoroutine("加载数据");
					}
					else if (text5 == "丰")
					{
						StopAllCoroutines();
						state = CurState.Two;
						跳转(虚我号, text4);
						rootText.text = text4;
						StartCoroutine("加载数据");
					}
					else
					{
						StopAllCoroutines();
						BroadcastMessage(text4, SendMessageOptions.DontRequireReceiver);
					}
					运行停止 = true;
				}
			}
			break;
		}
		case OperationState.InputVR:
		{
			if (gameObject.transform.childCount == 0)
			{
				break;
			}
			for (int i = 0; i < gameObject.transform.childCount; i++)
			{
				string text = gameObject.transform.GetChild(i).gameObject.GetComponent<ImageItem>().内容.text;
				string text2 = text.Substring(0, 1);
				string text3 = text.Substring(1);
				if (获取输入框内容 == text3)
				{
					if (text2 == "井")
					{
						StopAllCoroutines();
						MonoBehaviour.print("进入跳转");
						state = CurState.One;
						跳转(虚我号, text);
						rootText.text = text;
						StartCoroutine("加载数据");
					}
					else if (text2 == "丰")
					{
						StopAllCoroutines();
						state = CurState.Two;
						跳转(虚我号, text);
						rootText.text = text;
						StartCoroutine("加载数据");
					}
					else
					{
						StopAllCoroutines();
						BroadcastMessage(text, SendMessageOptions.DontRequireReceiver);
					}
				}
			}
			break;
		}
		}
	}

	private void 关闭碰撞器()
	{
		for (int i = 0; i < grid.transform.childCount; i++)
		{
			GameObject obj = grid.transform.GetChild(i).gameObject;
			obj.transform.Find("Image").gameObject.GetComponent<BoxCollider>().enabled = false;
			obj.transform.Find("Image01").gameObject.GetComponent<BoxCollider>().enabled = false;
			obj.transform.Find("Image02").gameObject.GetComponent<BoxCollider>().enabled = false;
		}
	}

	private void 开启碰撞器()
	{
		for (int i = 0; i < grid.transform.childCount; i++)
		{
			GameObject obj = grid.transform.GetChild(i).gameObject;
			obj.transform.Find("Image").gameObject.GetComponent<BoxCollider>().enabled = true;
			obj.transform.Find("Image01").gameObject.GetComponent<BoxCollider>().enabled = true;
			obj.transform.Find("Image02").gameObject.GetComponent<BoxCollider>().enabled = true;
		}
	}

	public void 确认修改内容()
	{
		修改新内容 = 输入法.transform.Find("BtnImage/获取框/Text").GetComponent<Text>().text;
		修改数据(字母标志, 修改新内容);
		输入法.SetActive(value: false);
		开启碰撞器();
	}

	public void 退格操作()
	{
		string text = 输入法.transform.Find("BtnImage/获取框/Text").GetComponent<Text>().text;
		text = text.Substring(0, text.Length - 1);
		输入法.transform.Find("BtnImage/获取框/Text").GetComponent<Text>().text = text;
		MonoBehaviour.print("执行退格");
	}

	public void 取消()
	{
		输入法.SetActive(value: false);
		开启碰撞器();
	}
}
public class xyz : MonoBehaviour
{
	private int a = 5;

	private int b = 7;

	private int c = 2;

	private bool 延迟执行;

	private void Start()
	{
		延迟执行 = false;
	}

	private void Awake()
	{
	}

	private void 延迟()
	{
		延迟执行 = false;
	}

	private void FixedUpdate()
	{
		UnityEngine.XR.InputDevice deviceAtXRNode = InputDevices.GetDeviceAtXRNode(XRNode.LeftHand);
		deviceAtXRNode.TryGetFeatureValue(UnityEngine.XR.CommonUsages.primary2DAxisClick, out var value);
		if (value && followMove._instance.gameObj != null && !延迟执行)
		{
			延迟执行 = true;
			Invoke("延迟", 0.2f);
			Vector2 value2 = default(Vector2);
			deviceAtXRNode.TryGetFeatureValue(UnityEngine.XR.CommonUsages.primary2DAxis, out value2);
		}
	}

	private float VectorAngle(Vector2 from, Vector2 to)
	{
		Vector3 vector = Vector3.Cross(from, to);
		float num = Vector2.Angle(from, to);
		if (!(vector.z > 0f))
		{
			return num;
		}
		return 0f - num;
	}

	private void 判断是哪个轴的功能(int number, int i)
	{
		OnTrigger._instance.不同的方向模型(followMove._instance.是否使用射线);
		if (number == 1)
		{
			switch (i)
			{
			case 1:
				a++;
				if (a == 7)
				{
					a = 1;
				}
				OnTrigger._instance.移动缩放(a);
				MonoBehaviour.print(a + "dddd");
				break;
			case 2:
				a--;
				if (a == 0)
				{
					a = 6;
				}
				OnTrigger._instance.移动缩放(a);
				break;
			}
		}
		if (number == 2)
		{
			switch (i)
			{
			case 1:
				b++;
				if (b > 7)
				{
					b = 1;
				}
				OnTrigger._instance.移动缩放(b);
				break;
			case 2:
				b--;
				if (b == 0)
				{
					b = 7;
				}
				OnTrigger._instance.移动缩放(b);
				break;
			}
		}
		if (number != 3)
		{
			return;
		}
		switch (i)
		{
		case 1:
			c++;
			if (c == 7)
			{
				c = 1;
			}
			OnTrigger._instance.移动缩放(c);
			break;
		case 2:
			c--;
			if (c == 0)
			{
				c = 6;
			}
			OnTrigger._instance.移动缩放(c);
			break;
		}
	}
}
public class 主虚 : MonoBehaviour
{
	public static 主虚 逮;

	private void Start()
	{
		逮 = this;
	}

	public void 虚()
	{
		GameObject gameObject = GameObject.Find("=造/-广/虚");
		gameObject.gameObject.SetActive(!gameObject.gameObject.activeSelf);
	}
}
public class 井法宝
{
	private static 井法宝 instance = null;

	private static readonly object lockHelper = new object();

	private 井法宝()
	{
	}

	public static 井法宝 CreateInstance()
	{
		if (instance == null)
		{
			lock (lockHelper)
			{
				if (instance == null)
				{
					instance = new 井法宝();
				}
			}
		}
		return instance;
	}

	public void 获取法宝(string type)
	{
		switch (type)
		{
		case "移动":
			OnTrigger._instance.移动();
			break;
		case "缩放":
			OnTrigger._instance.缩放();
			break;
		case "旋转":
			OnTrigger._instance.旋转();
			break;
		case "删除":
			OnTrigger._instance.删除();
			break;
		case "隐藏":
			OnTrigger._instance.隐藏();
			break;
		case "摆地上":
			OnTrigger._instance.摆地上();
			break;
		case "摆桌上":
			OnTrigger._instance.摆桌上();
			break;
		case "摆凳上":
			OnTrigger._instance.摆凳上();
			break;
		case "摆天花板下":
			OnTrigger._instance.摆天花板下();
			break;
		case "选择":
			OnTrigger._instance.选择();
			break;
		case "攻击":
			OnTrigger._instance.攻击();
			break;
		case "换图":
			OnTrigger._instance.换图();
			break;
		}
	}
}
public class 检测 : MonoBehaviour
{
	[HideInInspector]
	public GameObject 对象;

	public bool 选中 = true;

	public static 检测 _instance;

	[HideInInspector]
	public GameObject Main_Obj;

	private void Awake()
	{
		_instance = this;
	}

	private void OnTriggerEnter(Collider other)
	{
		if (!other.transform.gameObject)
		{
			return;
		}
		Main_Obj = other.transform.gameObject;
		if ((bool)followMove._instance.gameObj && followMove._instance.gameObj.tag != "图1")
		{
			UnityEngine.Object.Destroy(followMove._instance.gameObj.GetComponent<showSelected>());
			followMove._instance.gameObj.GetComponent<MeshRenderer>().material.shader = followMove._instance.mat;
			if (followMove._instance.初对象 == other.transform.gameObject)
			{
				followMove._instance.text.text = "无";
				选中 = false;
			}
		}
		followMove._instance.gameObj = other.transform.gameObject;
		followMove._instance.初对象 = followMove._instance.gameObj;
		if (!选中)
		{
			followMove._instance.gameObj = null;
		}
		followMove._instance.是否有对象();
		UnityEngine.Object.Destroy(base.gameObject);
	}
}
public class PlayerController : MonoBehaviour
{
	[Header("EasyTouch")]
	public ETCJoystick 走摇杆;

	public float 蓝队方向偏移;

	private Animator 动画机;

	public float 摇杆转换角度速度 = 10f;

	public float 玩家移动速度;

	private Vector3 玩家角度;

	public GameObject 人物;

	private float 移动值;

	private Vector3 移动坐标;

	private void Start()
	{
		动画机 = 人物.GetComponent<Animator>();
		走摇杆 = ETCInput.GetControlJoystick("Joystick");
		移动值 = base.transform.position.y;
	}

	private void Update()
	{
		if (走摇杆.isOnDrag)
		{
			动画机.SetBool("Run", value: true);
		}
	}
}
public class FPSPlayerControl2 : MonoBehaviour
{
	public static FPSPlayerControl2 _instance;

	public AudioClip gunSound;

	public AudioClip reload;

	public AudioClip needReload;

	public AudioClip paoSound;

	public ParticleSystem shellParticle;

	public GameObject muzzleEffect;

	public GameObject impactEffect;

	private bool inFire;

	private bool inReload;

	private int armoCount;

	public AudioSource audioSource;

	public Lijie_Click 点击事件;

	public GameObject 枪;

	public Text 弹匣数;

	public Text 子弹数;

	public GameObject 选中的物体;

	public bool 是否选中状态;

	public GameObject 大炮;

	public GameObject 炮弹;

	public List<GameObject> 弹炮 = new List<GameObject>();

	public GameObject Camera1;

	private void Awake()
	{
		_instance = this;
		audioSource = GetComponent<AudioSource>();
	}

	private void Update()
	{
		if (ETCInput.GetButtonDown("Qiehuan") && 点击事件.典武器列表.Count > 0)
		{
			if (枪.activeSelf && 点击事件.组沙袋.Count > 0)
			{
				点击事件.沙袋.SetActive(value: true);
				return;
			}
			if (!枪.activeSelf)
			{
				点击事件.沙袋.SetActive(value: false);
			}
		}
		if (ETCInput.GetButton("Fire") && 枪.activeSelf && 枪.name != "魔法棒" && !inFire && armoCount > 0 && !inReload)
		{
			inFire = true;
			InvokeRepeating("GunFire", 0.12f, 0.12f);
			GunFire();
		}
		if (ETCInput.GetButtonDown("Fire") && armoCount == 0 && !inReload)
		{
			audioSource.PlayOneShot(needReload, 1f);
		}
		if (ETCInput.GetButtonUp("Fire"))
		{
			muzzleEffect.SetActive(value: false);
			inFire = false;
			CancelInvoke();
			if (点击事件.沙袋.activeSelf && !Lijie_Click._instance.是否为手 && !Lijie_Click._instance.是否为魔法宝)
			{
				if (点击事件.组沙袋.Count > 0)
				{
					点击事件.组沙袋[0].SetActive(value: true);
					GameObject obj = 点击事件.组沙袋[0];
					obj.transform.position = 点击事件.沙袋.transform.position;
					obj.transform.rotation = 点击事件.沙袋.transform.localRotation;
					obj.GetComponent<Rigidbody>().velocity = (点击事件.沙袋.transform.forward + new Vector3(0f, 0.07f, 0f)) * 25f;
					点击事件.组沙袋.Remove(点击事件.组沙袋[0]);
				}
				if (点击事件.组沙袋.Count == 0)
				{
					点击事件.沙袋.SetActive(value: false);
					点击事件.典武器列表.Remove("投掷");
				}
			}
			return;
		}
		if (ETCInput.GetButtonDown("Reload") && 枪.activeSelf && 枪.name != "魔法棒")
		{
			inReload = true;
			audioSource.PlayOneShot(reload, 1f);
			int num = int.Parse(弹匣数.text);
			if (num > 0)
			{
				弹匣数.text = (num - 1).ToString();
				armoCount += 10;
				子弹数.text = armoCount.ToString();
			}
			StartCoroutine(Reload());
		}
		if (ETCInput.GetButtonDown("Back"))
		{
			base.transform.Rotate(Vector3.up * 180f);
		}
	}

	public void MoveStart()
	{
	}

	public void MoveStop()
	{
	}

	public void GunFire()
	{
		if (armoCount > 0)
		{
			muzzleEffect.transform.Rotate(Vector3.forward * UnityEngine.Random.Range(0f, 360f));
			muzzleEffect.transform.localScale = new Vector3(UnityEngine.Random.Range(0.1f, 0.2f), UnityEngine.Random.Range(0.1f, 0.2f), 1f);
			muzzleEffect.SetActive(value: true);
			StartCoroutine(Flash());
			audioSource.PlayOneShot(gunSound, 1f);
			shellParticle.Emit(1);
			Vector3 pos = new Vector3(UnityEngine.Screen.width / 2, UnityEngine.Screen.height / 2, 0f);
			pos += new Vector3(UnityEngine.Random.Range(-10, 10), UnityEngine.Random.Range(-10, 10), 0f);
			Ray ray = Camera.main.ScreenPointToRay(pos);
			RaycastHit[] array = Physics.RaycastAll(ray);
			if (Physics.Raycast(ray, out var hitInfo, 100f))
			{
				UnityEngine.Object.Instantiate(impactEffect, hitInfo.point - array[0].normal * -0.2f, Quaternion.identity);
				if ((bool)hitInfo.rigidbody)
				{
					hitInfo.rigidbody.AddForce((array[0].point - muzzleEffect.transform.position) * 100f);
				}
			}
		}
		else
		{
			muzzleEffect.SetActive(value: false);
			inFire = false;
		}
		if (armoCount < 0)
		{
			armoCount = 0;
		}
	}

	private void 选中状态()
	{
		Vector3 pos = new Vector3(UnityEngine.Screen.width / 2, UnityEngine.Screen.height / 2, 0f);
		pos += new Vector3(UnityEngine.Random.Range(-10, 10), UnityEngine.Random.Range(-10, 10), 0f);
		Ray ray = Camera.main.ScreenPointToRay(pos);
		Physics.RaycastAll(ray);
		if (!Physics.Raycast(ray, out var hitInfo, 100f) || !(hitInfo.transform.name != "枪") || !(hitInfo.transform.name != "机关枪") || !(hitInfo.transform.name != "Plane") || !(hitInfo.transform.name != "魔法棒"))
		{
			return;
		}
		if (Lijie_Click._instance.是否为手)
		{
			Lijie_Click._instance.沙袋.SetActive(value: true);
			GameObject gameObject = hitInfo.transform.gameObject;
			if (hitInfo.transform.tag == "加碰撞体")
			{
				gameObject = gameObject.transform.parent.gameObject;
			}
			if ((bool)gameObject.GetComponent<Rigidbody>())
			{
				UnityEngine.Object.Destroy(gameObject.GetComponent<Rigidbody>());
			}
			gameObject.transform.parent = Lijie_Click._instance.中心位置.transform;
			gameObject.transform.localPosition = new Vector3(0f, 0f, 0f);
			选中的物体 = gameObject.transform.gameObject;
			Manager._instance.Down.下载提示1.transform.Find("Text").GetComponent<Text>().text = 选中的物体.name;
		}
		else if (Lijie_Click._instance.是否为魔法宝)
		{
			Manager._instance.Down.当前选择 = hitInfo.transform.gameObject;
			if (!Manager._instance.Down.下载提示1.activeSelf)
			{
				Manager._instance.Down.下载提示1.SetActive(value: true);
			}
			if (Manager._instance.Down.当前选择.tag == "加碰撞体")
			{
				Manager._instance.Down.当前选择 = Manager._instance.Down.当前选择.transform.parent.gameObject;
			}
			Manager._instance.Down.下载提示1.transform.Find("Text").GetComponent<Text>().text = Manager._instance.Down.当前选择.name;
			Lijie_Click._instance.是否点击魔法棒功能 = true;
			MonoBehaviour.print("da......da...");
			testes._instance.长宽高(Manager._instance.Down.当前选择);
			testes._instance.是否法宝 = true;
			testes._instance.index = 0;
		}
	}

	public void TouchPadSwipe(bool value)
	{
		if (枪.activeSelf && 枪.name != "魔法棒")
		{
			armoCount = int.Parse(子弹数.text);
			if (armoCount > 0)
			{
				armoCount--;
			}
			子弹数.text = armoCount.ToString();
		}
		else if (Lijie_Click._instance.是否为手)
		{
			是否选中状态 = !是否选中状态;
			MonoBehaviour.print(是否选中状态 + "zhuagntai..");
			if (是否选中状态)
			{
				选中状态();
			}
			else
			{
				MonoBehaviour.print("zcchuagntai..");
				点击按钮功能();
			}
		}
		else if (Lijie_Click._instance.是否为魔法宝)
		{
			选中状态();
			if (!Manager._instance.Vr2045.是否是人走状态)
			{
				Manager._instance.Vr2045.选择为当前对象();
			}
		}
		if (大炮.activeSelf)
		{
			MonoBehaviour.print("dd..ee.");
			audioSource.PlayOneShot(paoSound, 1f);
			GameObject gameObject = 弹炮[0];
			gameObject.transform.position = 炮弹.transform.position;
			gameObject.transform.rotation = 炮弹.transform.rotation;
			gameObject.SetActive(value: true);
			gameObject.GetComponent<Rigidbody>().velocity = gameObject.transform.forward * 5f;
		}
		ETCInput.SetControlSwipeIn("FreeLookTouchPad", value);
	}

	public void 点击按钮功能()
	{
		MonoBehaviour.print("123..");
		if ((bool)选中的物体)
		{
			选中的物体.transform.parent = Manager._instance.Trans_form.区对象.transform;
			选中的物体.AddComponent<Rigidbody>();
			选中的物体 = null;
		}
	}

	private IEnumerator Flash()
	{
		yield return new WaitForSeconds(0.08f);
		muzzleEffect.SetActive(value: false);
	}

	private IEnumerator Reload()
	{
		yield return new WaitForSeconds(0.5f);
		inReload = false;
	}
}
public class Lijie_Click : MonoBehaviour
{
	public static Lijie_Click _instance;

	public GameObject 沙袋;

	public List<GameObject> 组沙袋;

	public bool 是否有武器;

	public Dictionary<string, bool> 典武器列表 = new Dictionary<string, bool>();

	public List<GameObject> 枪支1 = new List<GameObject>();

	public Dictionary<string, int> 典法宝1 = new Dictionary<string, int>();

	public List<GameObject> 法宝对象 = new List<GameObject>();

	private int indexNum;

	private bool 是否有枪显示;

	public List<Sprite> 组合图片 = new List<Sprite>();

	public List<Sprite> 添加图片 = new List<Sprite>();

	private int ImgIndex;

	public ETCButton ETCButton;

	public bool 是否为手 = true;

	public bool 是否为魔法宝;

	public bool 是否点击魔法棒功能;

	public GameObject 中心位置;

	public Text text;

	public GameObject 法宝按钮;

	public AudioClip DownButtonClip;

	public bool 是否点击选中;

	private void Start()
	{
		_instance = this;
		枪支1[0].SetActive(value: false);
		沙袋.SetActive(value: false);
	}

	private void Update()
	{
		if (!Input.GetMouseButtonDown(0) || !Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out var hitInfo))
		{
			return;
		}
		if (hitInfo.transform.name == "枪")
		{
			int num = int.Parse(FPSPlayerControl2._instance.弹匣数.text);
			FPSPlayerControl2._instance.弹匣数.text = (num + 1).ToString();
			法宝对象.Add(枪支1[0]);
			组合图片.Add(添加图片[0]);
			法宝按钮.GetComponent<Image>().sprite = 组合图片[法宝对象.Count - 1];
			判断法宝类型(法宝对象.Count);
			MonoBehaviour.print(典武器列表.Count + "con.");
			if (典武器列表.Count == 0)
			{
				是否有枪显示 = true;
			}
			hitInfo.transform.gameObject.SetActive(value: false);
			典武器列表[hitInfo.transform.name] = true;
		}
		else if (hitInfo.transform.name == "机关枪")
		{
			int num2 = int.Parse(FPSPlayerControl2._instance.弹匣数.text);
			FPSPlayerControl2._instance.弹匣数.text = (num2 + 1).ToString();
			法宝对象.Add(枪支1[1]);
			组合图片.Add(添加图片[1]);
			法宝按钮.GetComponent<Image>().sprite = 组合图片[法宝对象.Count - 1];
			判断法宝类型(法宝对象.Count);
			是否有枪显示 = true;
			hitInfo.transform.gameObject.SetActive(value: false);
			典武器列表[hitInfo.transform.name] = true;
		}
		else if (hitInfo.transform.name == "大炮")
		{
			int num3 = int.Parse(FPSPlayerControl2._instance.弹匣数.text);
			FPSPlayerControl2._instance.弹匣数.text = (num3 + 1).ToString();
			法宝对象.Add(枪支1[2]);
			组合图片.Add(添加图片[2]);
			法宝按钮.GetComponent<Image>().sprite = 组合图片[法宝对象.Count - 1];
			判断法宝类型(法宝对象.Count);
			是否有枪显示 = true;
			hitInfo.transform.gameObject.SetActive(value: false);
			典武器列表[hitInfo.transform.name] = true;
		}
		else if (hitInfo.transform.name == "魔法棒")
		{
			法宝对象.Add(枪支1[3]);
			组合图片.Add(添加图片[3]);
			hitInfo.transform.gameObject.SetActive(value: false);
			法宝按钮.GetComponent<Image>().sprite = 组合图片[法宝对象.Count - 1];
			判断法宝类型(法宝对象.Count);
		}
	}

	private void 判断法宝类型(int num)
	{
		ImgIndex = num;
		text.text = ImgIndex + "/" + num;
		if (num > 1 && num < 6)
		{
			for (int i = 0; i < num - 1; i++)
			{
				法宝对象[i].SetActive(value: false);
			}
			法宝对象[num - 1].SetActive(value: true);
			if (法宝对象[num - 1].name == "枪1" || 法宝对象[num - 1].name == "枪2")
			{
				FPSPlayerControl2._instance.枪 = 法宝对象[num - 1];
			}
			if (法宝对象[num - 1].name == "魔法棒")
			{
				是否为魔法宝 = true;
				是否为手 = false;
			}
		}
	}

	public void 转换法宝()
	{
		FPSPlayerControl2._instance.audioSource.PlayOneShot(DownButtonClip, 1f);
		indexNum++;
		if (indexNum >= 法宝对象.Count)
		{
			indexNum = 0;
		}
		if (ImgIndex < 组合图片.Count - 1)
		{
			是否为手 = false;
			ImgIndex++;
			if (法宝对象[ImgIndex].name == "魔法棒")
			{
				是否为魔法宝 = true;
			}
			else
			{
				是否为魔法宝 = false;
				是否点击魔法棒功能 = false;
				testes._instance.是否法宝 = false;
			}
			法宝按钮.GetComponent<Image>().sprite = 组合图片[ImgIndex];
			text.text = ImgIndex + 1 + "/" + 法宝对象.Count;
		}
		else
		{
			是否为手 = true;
			是否为魔法宝 = false;
			是否点击魔法棒功能 = false;
			testes._instance.是否法宝 = false;
			ImgIndex = 0;
			法宝按钮.GetComponent<Image>().sprite = 组合图片[ImgIndex];
			text.text = "1/" + 法宝对象.Count;
		}
		转换法宝1();
	}

	public void 转换法宝1()
	{
		if (ImgIndex > 0)
		{
			法宝对象[ImgIndex - 1].SetActive(value: false);
			法宝对象[ImgIndex].SetActive(value: true);
			if (法宝对象[ImgIndex].name == "枪1" || 法宝对象[ImgIndex].name == "枪2")
			{
				FPSPlayerControl2._instance.枪 = 法宝对象[ImgIndex];
			}
		}
		else
		{
			法宝对象[组合图片.Count - 1].SetActive(value: false);
			法宝对象[ImgIndex].SetActive(value: true);
			if (法宝对象[ImgIndex].name == "枪1" || 法宝对象[ImgIndex].name == "枪2")
			{
				FPSPlayerControl2._instance.枪 = 法宝对象[ImgIndex];
			}
		}
	}
}
public class Lijie_Radar : MonoBehaviour
{
	public GameObject target;

	public float speed = 10f;

	private float distanceToTarget;

	private bool move = true;

	private void Start()
	{
		distanceToTarget = Vector3.Distance(base.transform.position, target.transform.position);
		StartCoroutine(Shoot());
	}

	private IEnumerator Shoot()
	{
		while (move)
		{
			Vector3 position = target.transform.position;
			base.transform.LookAt(position);
			float num = Mathf.Min(1f, Vector3.Distance(base.transform.position, position) / distanceToTarget) * 45f;
			base.transform.rotation = base.transform.rotation * Quaternion.Euler(Mathf.Clamp(0f - num, -42f, 42f), 0f, 0f);
			float num2 = Vector3.Distance(base.transform.position, target.transform.position);
			if (num2 < 0.5f)
			{
				move = false;
			}
			base.transform.Translate(Vector3.forward * Mathf.Min(speed * Time.deltaTime, num2));
			yield return null;
		}
	}
}
public class Lijie_TouZhi : MonoBehaviour
{
	public GameObject 投掷位置;

	public GameObject 投掷物;

	public GameObject 物体;

	public float 力度;

	public GameObject UI;

	public GameObject 虚语言UI;

	public Vector2 鼠标按下 = new Vector2(0f, 0f);

	public Vector2 鼠标弹起 = new Vector2(0f, 0f);

	public InputField 广框;

	public Text 状态栏;

	public static int 内容光标点;

	private void Start()
	{
	}

	public void 隐藏显示UI()
	{
		if (虚语言UI.activeInHierarchy)
		{
			虚语言UI.SetActive(value: false);
		}
		else
		{
			虚语言UI.SetActive(value: true);
		}
	}

	private float VectorAngle(Vector2 from, Vector2 to)
	{
		Vector3 vector = Vector3.Cross(from, to);
		float num = Vector2.Angle(from, to);
		if (!(vector.z > 0f))
		{
			return num;
		}
		return 0f - num;
	}

	public static double CalulateXYAnagle(double startx, double starty, double endx, double endy)
	{
		double num = Math.Atan(Math.Abs((endy - starty) / (endx - startx))) * 180.0 / Math.PI;
		if (endx > startx && endy > starty)
		{
			return 0.0 - num;
		}
		if (endx > startx && endy < starty)
		{
			return num;
		}
		if (endx < startx && endy > starty)
		{
			return num - 180.0;
		}
		return 180.0 - num;
	}

	public void 焦点位置()
	{
	}

	public void test()
	{
		MonoBehaviour.print("cheshi");
	}

	private void Update()
	{
		if (Input.GetButtonDown("Fire1") && 广框.caretPosition != 0)
		{
			内容光标点 = 广框.caretPosition;
		}
		if (Input.GetButtonDown("Fire1") && !虚语言UI.activeInHierarchy)
		{
			鼠标按下 = Input.mousePosition;
		}
		if (Input.GetButtonUp("Fire1") && !虚语言UI.activeInHierarchy)
		{
			鼠标弹起 = Input.mousePosition;
			GameObject gameObject = UnityEngine.Object.Instantiate(投掷物, 投掷位置.transform.position, Quaternion.identity);
			float num = (float)CalulateXYAnagle(鼠标按下.x, 鼠标按下.y, 鼠标弹起.x, 鼠标弹起.y);
			float num2 = Vector2.Distance(new Vector2(鼠标按下.x, 鼠标按下.y), new Vector2(鼠标弹起.x, 鼠标弹起.y)) / 90f;
			if (num > -90f)
			{
				float num3 = (90f - num * -1f) / 90f;
				gameObject.GetComponent<Rigidbody>().velocity = (投掷位置.transform.forward + new Vector3(num3 * -1f, 1f, 0f)) * num2;
				MonoBehaviour.print(num3);
			}
			else
			{
				float num3 = (num * -1f - 90f) / 90f;
				gameObject.GetComponent<Rigidbody>().velocity = (投掷位置.transform.forward + new Vector3(num3 * 1f, 1f, 0f)) * num2;
			}
			gameObject.transform.rotation = Quaternion.Euler(0f, 10f * Time.deltaTime, 0f);
		}
	}
}
public class GC
{
	public static SocketIOComponent 套接;
}
public class VR12345_AIRandMove : MonoBehaviour
{
	private float stopTime;

	private float moveTime;

	private float vel_x;

	private float vel_y;

	private float vel_z;

	public float maxPos_x = 10f;

	public float maxPos_y = 10f;

	public float maxPos_z = 10f;

	public float minPos_x = -10f;

	public float minPos_y = -10f;

	public float minPos_z = -10f;

	private float 角度;

	private int curr_frame;

	private int total_frame;

	private float timeCounter1;

	private float timeCounter2;

	private bool 运行 = true;

	public static VR12345_AIRandMove _instance;

	private void Start()
	{
		_instance = this;
		Change();
	}

	public void 死亡()
	{
		运行 = false;
		base.gameObject.AddComponent<Rigidbody>();
		UnityEngine.Object.Destroy(base.gameObject, 2f);
	}

	private void Update()
	{
		if (!运行)
		{
			return;
		}
		timeCounter1 += Time.deltaTime;
		if (timeCounter1 < moveTime)
		{
			base.transform.Translate(vel_x * 0.8f, vel_y * 0.8f, vel_z * 0.8f, Space.Self);
		}
		else
		{
			timeCounter2 += Time.deltaTime;
			if (timeCounter2 > stopTime)
			{
				Change();
				timeCounter1 = 0f;
				timeCounter2 = 0f;
			}
		}
		Check();
	}

	private void Change()
	{
		stopTime = UnityEngine.Random.Range(1, 5);
		角度 = UnityEngine.Random.Range(1, 360);
		moveTime = UnityEngine.Random.Range(1, 20);
		vel_x = UnityEngine.Random.Range(0.05f, 0.2f);
		vel_y = UnityEngine.Random.Range(0.05f, 0.2f);
		vel_z = UnityEngine.Random.Range(0.05f, 0.2f);
	}

	private void Check()
	{
		if (base.transform.localPosition.x > maxPos_x)
		{
			vel_x = 0f - vel_x;
			base.transform.localPosition = new Vector3(maxPos_x, base.transform.localPosition.y, base.transform.localPosition.z);
		}
		if (base.transform.localPosition.x < minPos_x)
		{
			vel_x = 0f - vel_x;
			base.transform.localPosition = new Vector3(minPos_x, base.transform.localPosition.y, base.transform.localPosition.z);
		}
		if (base.transform.localPosition.y > maxPos_y)
		{
			vel_y = 0f - vel_y;
			base.transform.localPosition = new Vector3(base.transform.localPosition.x, maxPos_y, base.transform.localPosition.z);
		}
		if (base.transform.localPosition.y < minPos_y)
		{
			vel_y = 0f - vel_y;
			base.transform.localPosition = new Vector3(base.transform.localPosition.x, minPos_y, base.transform.localPosition.z);
		}
		if (base.transform.localPosition.z > maxPos_z)
		{
			vel_z = 0f - vel_z;
			base.transform.localPosition = new Vector3(base.transform.localPosition.x, base.transform.localPosition.y, maxPos_z);
		}
		if (base.transform.localPosition.z < minPos_z)
		{
			vel_z = 0f - vel_z;
			base.transform.localPosition = new Vector3(base.transform.localPosition.x, base.transform.localPosition.y, minPos_z);
		}
	}
}
public class chu_8 : MonoBehaviour
{
	public string 名;

	public GameObject 物;

	public string 值;

	public bool 是否触;

	private void Update()
	{
	}

	private void OnTriggerEnter2D(Collider2D col)
	{
		if (col.transform.name == 名 && !col.gameObject.GetComponent<chu_8>().是否触)
		{
			是否触 = true;
			物.SendMessage("触", 值);
		}
	}
}
public class click_color : MonoBehaviour
{
	public Texture2D heightmap;

	private void Start()
	{
	}

	private void Update()
	{
	}

	public void 点击颜色块(int 孩几 = 0)
	{
		if (daimove.是否开始选颜色)
		{
			float num = base.transform.GetComponent<RectTransform>().sizeDelta.x / 10f;
			float num2 = base.transform.GetComponent<RectTransform>().sizeDelta.y / 10f;
			int num3 = Mathf.CeilToInt(num * 4f + num / 2f);
			int num4 = Mathf.CeilToInt(num2 * 4f + num2 / 2f);
			float num5 = base.transform.position.x - (float)num3;
			float num6 = base.transform.position.y - (float)num4;
			float num7 = base.transform.GetChild(孩几).position.x - num5;
			float num8 = base.transform.GetChild(孩几).position.y - num6;
			int x = (int)(num7 * (float)heightmap.width / base.transform.GetComponent<RectTransform>().sizeDelta.x);
			int y = (int)(num8 * (float)heightmap.height / base.transform.GetComponent<RectTransform>().sizeDelta.y);
			daimove.色材质.color = heightmap.GetPixel(x, y);
			daimove.是否选好颜色 = true;
		}
	}
}
public class click_color2 : MonoBehaviour
{
	public Texture2D heightmap;

	public Vector3 size = new Vector3(50f, 10f, 50f);

	public Vector2 po = new Vector2(-248f, 248f);

	private void Start()
	{
		MonoBehaviour.print(heightmap.GetPixel((int)po.x, (int)po.y));
		MonoBehaviour.print("(int)po.x:" + (int)po.x);
		MonoBehaviour.print("(int)po.y:" + (int)po.y);
	}

	private void Update()
	{
	}
}
public class dian : MonoBehaviour
{
	public bool 是否点;

	private void Start()
	{
	}

	private void Update()
	{
		if (Input.GetMouseButtonDown(0))
		{
			是否点 = true;
		}
	}
}
public class end : MonoBehaviour
{
	public float 横;

	public float 纵;

	public float 深;

	public Vector3 终点;

	private bool 停;

	private void Start()
	{
		终点 = new Vector3(横, 纵, 深);
	}

	private void Update()
	{
		if (!停 && Vector3.Distance(base.transform.position, 终点) <= 1f)
		{
			base.transform.position = 终点;
			停 = true;
		}
	}

	public void 隐隐()
	{
		base.enabled = false;
	}

	public void 显显()
	{
		base.enabled = true;
	}
}
public class FollowMovement2 : MonoBehaviour
{
	public Transform TargetTF;

	public float RecordGap = 0.05f;

	public float StopCount = 2f;

	public float WalkSpeed = 1f;

	public float RunSpeed = 3f;

	public float SpeedLerpRant = 2f;

	public float StartRunCount = 1f;

	private Rigidbody Rig;

	private List<Vector3> PosList = new List<Vector3>();

	public bool Running
	{
		get
		{
			return (float)PosList.Count > StartRunCount;
		}
		set
		{
		}
	}

	private void Awake()
	{
		Rig = GetComponent<Rigidbody>();
		Rig.constraints = RigidbodyConstraints.FreezeRotation;
	}

	public void OnDisabled()
	{
		PosList.Clear();
	}

	private void Start()
	{
	}

	private void Update()
	{
	}

	private void FixedUpdate()
	{
		if (!TargetTF)
		{
			return;
		}
		while (PosList.Count > 0 && Vector3.Distance(base.transform.position, PosList[0]) < RecordGap)
		{
			PosList.RemoveAt(0);
		}
		if (PosList.Count > 0)
		{
			if (Vector3.Distance(TargetTF.position, PosList[PosList.Count - 1]) > RecordGap)
			{
				PosList.Add(TargetTF.position);
			}
			if ((float)PosList.Count > StopCount)
			{
				Rig.velocity = Vector3.Lerp(Rig.velocity, new Vector3(PosList[0].x - base.transform.position.x, PosList[0].y - base.transform.position.y, PosList[0].z - base.transform.position.z).normalized * (Running ? RunSpeed : WalkSpeed), SpeedLerpRant);
				Vector3 worldPosition = new Vector3(PosList[0].x, PosList[0].y, PosList[0].z);
				base.transform.LookAt(worldPosition);
			}
			else
			{
				Rig.velocity = Vector3.Lerp(Rig.velocity, Vector3.zero, SpeedLerpRant);
			}
		}
		else
		{
			PosList.Add(TargetTF.position);
		}
	}
}
public class Gemstone : MonoBehaviour
{
	public float xOffset = -4.5f;

	public float yOffset = -2f;

	public int rowIndex;

	public int columIndex;

	public List<GameObject> gemstoneBgs = new List<GameObject>();

	public List<Sprite> gemstoneBgs2 = new List<Sprite>();

	public int gemstoneType;

	private GameObject gemstoneBg;

	public xiaoxiao gameController;

	private SpriteRenderer spriteRenderer;

	public bool isSelected
	{
		set
		{
			if (value)
			{
				if (gameController.物图 == 0)
				{
					base.transform.GetChild(0).localScale = new Vector3(base.transform.localScale.x + base.transform.localScale.x / 3f, base.transform.localScale.y + base.transform.localScale.y / 3f, base.transform.localScale.z + base.transform.localScale.z / 3f);
				}
				else if (gameController.物图 == 1)
				{
					base.transform.localScale = new Vector3(base.transform.localScale.x + base.transform.localScale.x / 3f, base.transform.localScale.y + base.transform.localScale.y / 3f, base.transform.localScale.z + base.transform.localScale.z / 3f);
				}
				return;
			}
			float 寸横 = gameController.寸横;
			float 寸纵 = gameController.寸纵;
			float 寸深 = gameController.寸深;
			if (gameController.物图 == 0)
			{
				base.transform.GetChild(0).transform.localScale = new Vector3(寸横, 寸纵, 寸深);
			}
			else if (gameController.物图 == 1)
			{
				base.transform.localScale = new Vector3(寸横, 寸纵, 寸深);
			}
		}
	}

	private void Start()
	{
	}

	private void Update()
	{
	}

	public void UpdatePosition(int _rowIndex, int _columIndex)
	{
		rowIndex = _rowIndex;
		columIndex = _columIndex;
		float x = (float)columIndex * xOffset + gameController.偏x;
		float y = (float)rowIndex * yOffset + gameController.偏y;
		base.transform.position = new Vector3(x, y, 0f);
	}

	public void TweenToPostion(int _rowIndex, int _columIndex)
	{
		rowIndex = _rowIndex;
		columIndex = _columIndex;
		float num = (float)columIndex * xOffset + gameController.偏x;
		float num2 = (float)rowIndex * yOffset + gameController.偏y;
		iTween.MoveTo(base.gameObject, iTween.Hash("x", num, "y", num2, "time", 0.5f));
	}

	public void RandomCreateGemstoneBg()
	{
		if (base.transform.parent.GetComponent<xiaoxiao>().物图 == 0)
		{
			gemstoneType = UnityEngine.Random.Range(0, gemstoneBgs.Count);
			gemstoneBg = UnityEngine.Object.Instantiate(gemstoneBgs[gemstoneType]);
			gemstoneBg.transform.parent = base.transform;
		}
		else if (base.transform.parent.GetComponent<xiaoxiao>().物图 == 1)
		{
			gemstoneType = UnityEngine.Random.Range(0, gemstoneBgs2.Count);
			base.gameObject.GetComponent<Image>().sprite = gemstoneBgs2[gemstoneType];
		}
	}

	public void OnMouseDown()
	{
		if (gameController.是否按)
		{
			gameController.Select(base.gameObject.GetComponent<Gemstone>());
		}
	}

	public void Dispose()
	{
		UnityEngine.Object.Destroy(base.gameObject);
		gameController = null;
	}
}
public class GetPix : MonoBehaviour
{
	private Texture2D T;

	public GameObject Plan;

	private Color C2;

	private void Start()
	{
		T = Plan.GetComponent<MeshRenderer>().material.mainTexture as Texture2D;
	}

	private void Update()
	{
		if (Input.GetMouseButtonDown(0) || (Input.touchCount == 1 && Input.GetTouch(0).phase == UnityEngine.TouchPhase.Began))
		{
			Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
			RaycastHit hitInfo = default(RaycastHit);
			if (Physics.Raycast(ray, out hitInfo) && hitInfo.transform.name == "颜板")
			{
				调色板(hitInfo, T);
			}
		}
	}

	public void 调色板(RaycastHit r, Texture2D T2)
	{
		Vector2 textureCoord = r.textureCoord;
		textureCoord.x *= T2.width;
		textureCoord.y *= T2.height;
		C2 = T2.GetPixel((int)textureCoord.x, (int)textureCoord.y);
		MonoBehaviour.print(C2);
		daimove.色材质.color = C2;
		daimove.是否选好颜色 = true;
	}
}
public class gui : MonoBehaviour
{
	public float 速度 = 5f;

	public Vector3 目标点;

	public Vector3 起点;

	public bool 是否开始跑;

	public float 加横;

	public float 加纵;

	public float 加深;

	private void Start()
	{
		目标点 = new Vector3(base.transform.position.x + 加横, base.transform.position.y + 加纵, base.transform.position.z + 加深);
	}

	private void Update()
	{
		if (是否开始跑)
		{
			base.transform.position = Vector3.MoveTowards(base.transform.position, 目标点, Time.deltaTime * 速度);
			if (Vector3.Distance(base.transform.position, 目标点) <= 0.1f)
			{
				base.transform.position = 目标点;
				_ = GetType().FullName;
				是否开始跑 = false;
			}
		}
		if (Input.GetMouseButtonDown(0))
		{
			是否开始跑 = true;
		}
	}

	public void 隐隐()
	{
		base.enabled = false;
	}

	public void 显显()
	{
		base.enabled = true;
	}
}
public class image_ha : MonoBehaviour
{
	public bool 是否有;

	private void Start()
	{
	}

	private void Update()
	{
	}

	public void 点(GameObject 参数)
	{
		if (参数.GetComponent<Image>() != null && 参数.GetComponent<Image>().sprite != null)
		{
			参数.GetComponent<Image>().sprite = null;
			参数.GetComponent<Image>().color = new Color(1f, 1f, 1f, 0f);
			是否有 = true;
		}
		else
		{
			是否有 = false;
		}
	}
}
public class longg : MonoBehaviour
{
	public Vector3 点;

	private bool 完;

	public float 横;

	public float 纵;

	public float 深;

	public Vector3 出生点;

	public string 名;

	private void Start()
	{
		出生点 = new Vector3(横, 纵, 深);
	}

	private void Update()
	{
		if (完 || !(Vector3.Distance(base.transform.position, 点) <= 0.05f))
		{
			return;
		}
		完 = true;
		GameObject gameObject = GameObject.Find(名);
		if (gameObject != null)
		{
			GameObject gameObject2 = UnityEngine.Object.Instantiate(gameObject);
			Manager._instance.Down.当前选择 = gameObject2;
			gameObject2.transform.position = 出生点;
			gameObject2.transform.rotation = Quaternion.Euler(0f, 0f, 0f);
			UnityEngine.Component[] components = gameObject2.GetComponents<UnityEngine.Component>();
			for (int i = 0; i < components.Length; i++)
			{
				components[i].SendMessage("显显");
			}
			if (gameObject2.GetComponent<gui>() != null)
			{
				gameObject2.GetComponent<gui>().是否开始跑 = false;
			}
			base.enabled = false;
		}
	}

	public void 显显()
	{
		base.enabled = true;
	}
}
public class niu_new : MonoBehaviour
{
	public Vector3 点;

	private bool 完;

	public string 值;

	private void Start()
	{
	}

	private void Update()
	{
		if (完 || !(Vector3.Distance(base.transform.position, 点) <= 0.05f))
		{
			return;
		}
		GameObject gameObject = Resources.Load("Button1", typeof(GameObject)) as GameObject;
		if (gameObject != null)
		{
			GameObject gameObject2 = UnityEngine.Object.Instantiate(gameObject);
			gameObject2.transform.parent = GameObject.Find("Canvas").transform;
			if (值 == "新")
			{
				gameObject2.GetComponent<RectTransform>().sizeDelta = new Vector2(100f, 50f);
				gameObject2.GetComponent<RectTransform>().localPosition = new Vector3(0f, 0f, 0f);
				gameObject2.GetComponentInChildren<Text>().text = "重新开始";
				gameObject2.GetComponent<UnityEngine.UI.Button>().onClick.AddListener(delegate
				{
					vr12888.重新开始游戏();
				});
			}
		}
		完 = true;
	}
}
public class peng : MonoBehaviour
{
	private RaycastHit hit;

	public GameObject 爆炸特效;

	public AudioClip 爆炸声;

	public AudioSource 音效播放;

	public GameObject 死亡光效;

	public bool 是否多个死亡光效 = true;

	public GameObject 死亡物体父级;

	public string 参数 = "";

	private void Start()
	{
	}

	private void Update()
	{
	}

	public void 事碰(string 参数 = "")
	{
		if (Physics.Raycast(base.transform.position, base.transform.forward, out hit) || Physics.Raycast(base.transform.position, -base.transform.forward, out hit))
		{
			UnityEngine.Debug.DrawLine(base.transform.position, hit.point);
			if (参数 == "" && this.参数 != "")
			{
				参数 = this.参数;
			}
			if (hit.transform.name == 参数 && !vr12888.是否进入碰撞状态)
			{
				vr12888.是否进入碰撞状态 = true;
			}
		}
	}
}
public class iTween : MonoBehaviour
{
	private delegate float EasingFunction(float start, float end, float Value);

	private delegate void ApplyTween();

	public enum EaseType
	{
		easeInQuad,
		easeOutQuad,
		easeInOutQuad,
		easeInCubic,
		easeOutCubic,
		easeInOutCubic,
		easeInQuart,
		easeOutQuart,
		easeInOutQuart,
		easeInQuint,
		easeOutQuint,
		easeInOutQuint,
		easeInSine,
		easeOutSine,
		easeInOutSine,
		easeInExpo,
		easeOutExpo,
		easeInOutExpo,
		easeInCirc,
		easeOutCirc,
		easeInOutCirc,
		linear,
		spring,
		easeInBounce,
		easeOutBounce,
		easeInOutBounce,
		easeInBack,
		easeOutBack,
		easeInOutBack,
		easeInElastic,
		easeOutElastic,
		easeInOutElastic,
		punch
	}

	public enum LoopType
	{
		none,
		loop,
		pingPong
	}

	public enum NamedValueColor
	{
		_Color,
		_SpecColor,
		_Emission,
		_ReflectColor
	}

	public static class Defaults
	{
		public static float time = 1f;

		public static float delay = 0f;

		public static NamedValueColor namedColorValue = NamedValueColor._Color;

		public static LoopType loopType = LoopType.none;

		public static EaseType easeType = EaseType.easeOutExpo;

		public static float lookSpeed = 3f;

		public static bool isLocal = false;

		public static Space space = Space.Self;

		public static bool orientToPath = false;

		public static Color color = Color.white;

		public static float updateTimePercentage = 0.05f;

		public static float updateTime = 1f * updateTimePercentage;

		public static float lookAhead = 0.05f;

		public static bool useRealTime = false;

		public static Vector3 up = Vector3.up;
	}

	private class CRSpline
	{
		public Vector3[] pts;

		public CRSpline(params Vector3[] pts)
		{
			this.pts = new Vector3[pts.Length];
			Array.Copy(pts, this.pts, pts.Length);
		}

		public Vector3 Interp(float t)
		{
			int num = pts.Length - 3;
			int num2 = Mathf.Min(Mathf.FloorToInt(t * (float)num), num - 1);
			float num3 = t * (float)num - (float)num2;
			Vector3 vector = pts[num2];
			Vector3 vector2 = pts[num2 + 1];
			Vector3 vector3 = pts[num2 + 2];
			Vector3 vector4 = pts[num2 + 3];
			return 0.5f * ((-vector + 3f * vector2 - 3f * vector3 + vector4) * (num3 * num3 * num3) + (2f * vector - 5f * vector2 + 4f * vector3 - vector4) * (num3 * num3) + (-vector + vector3) * num3 + 2f * vector2);
		}
	}

	public static List<Hashtable> tweens = new List<Hashtable>();

	public string id;

	public string type;

	public string method;

	public EaseType easeType;

	public float time;

	public float delay;

	public LoopType loopType;

	public bool isRunning;

	public bool isPaused;

	public string _name;

	private float runningTime;

	private float percentage;

	private float delayStarted;

	private bool kinematic;

	private bool isLocal;

	private bool loop;

	private bool reverse;

	private bool wasPaused;

	private bool physics;

	private Hashtable tweenArguments;

	private Space space;

	private EasingFunction ease;

	private ApplyTween apply;

	private AudioSource audioSource;

	private Vector3[] vector3s;

	private Vector2[] vector2s;

	private Color[,] colors;

	private float[] floats;

	private Rect[] rects;

	private CRSpline path;

	private Vector3 preUpdate;

	private Vector3 postUpdate;

	private NamedValueColor namedcolorvalue;

	private float lastRealTime;

	private bool useRealTime;

	private Transform thisTransform;

	public static void Init(GameObject target)
	{
		MoveBy(target, Vector3.zero, 0f);
	}

	public static void ValueTo(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		if (!args.Contains("onupdate") || !args.Contains("from") || !args.Contains("to"))
		{
			UnityEngine.Debug.LogError("iTween Error: ValueTo() requires an 'onupdate' callback function and a 'from' and 'to' property.  The supplied 'onupdate' callback must accept a single argument that is the same type as the supplied 'from' and 'to' properties!");
			return;
		}
		args["type"] = "value";
		if (args["from"].GetType() == typeof(Vector2))
		{
			args["method"] = "vector2";
		}
		else if (args["from"].GetType() == typeof(Vector3))
		{
			args["method"] = "vector3";
		}
		else if (args["from"].GetType() == typeof(Rect))
		{
			args["method"] = "rect";
		}
		else if (args["from"].GetType() == typeof(float))
		{
			args["method"] = "float";
		}
		else
		{
			if (!(args["from"].GetType() == typeof(Color)))
			{
				UnityEngine.Debug.LogError("iTween Error: ValueTo() only works with interpolating Vector3s, Vector2s, floats, ints, Rects and Colors!");
				return;
			}
			args["method"] = "color";
		}
		if (!args.Contains("easetype"))
		{
			args.Add("easetype", EaseType.linear);
		}
		Launch(target, args);
	}

	public static void FadeFrom(GameObject target, float alpha, float time)
	{
		FadeFrom(target, Hash("alpha", alpha, "time", time));
	}

	public static void FadeFrom(GameObject target, Hashtable args)
	{
		ColorFrom(target, args);
	}

	public static void FadeTo(GameObject target, float alpha, float time)
	{
		FadeTo(target, Hash("alpha", alpha, "time", time));
	}

	public static void FadeTo(GameObject target, Hashtable args)
	{
		ColorTo(target, args);
	}

	public static void ColorFrom(GameObject target, Color color, float time)
	{
		ColorFrom(target, Hash("color", color, "time", time));
	}

	public static void ColorFrom(GameObject target, Hashtable args)
	{
		Color color = default(Color);
		Color color2 = default(Color);
		args = CleanArgs(args);
		if (!args.Contains("includechildren") || (bool)args["includechildren"])
		{
			foreach (Transform item in target.transform)
			{
				Hashtable hashtable = (Hashtable)args.Clone();
				hashtable["ischild"] = true;
				ColorFrom(item.gameObject, hashtable);
			}
		}
		if (!args.Contains("easetype"))
		{
			args.Add("easetype", EaseType.linear);
		}
		if ((bool)target.GetComponent<Renderer>())
		{
			color2 = (color = target.GetComponent<Renderer>().material.color);
		}
		else if ((bool)target.GetComponent<Light>())
		{
			color2 = (color = target.GetComponent<Light>().color);
		}
		if (args.Contains("color"))
		{
			color = (Color)args["color"];
		}
		else
		{
			if (args.Contains("r"))
			{
				color.r = (float)args["r"];
			}
			if (args.Contains("g"))
			{
				color.g = (float)args["g"];
			}
			if (args.Contains("b"))
			{
				color.b = (float)args["b"];
			}
			if (args.Contains("a"))
			{
				color.a = (float)args["a"];
			}
		}
		if (args.Contains("amount"))
		{
			color.a = (float)args["amount"];
			args.Remove("amount");
		}
		else if (args.Contains("alpha"))
		{
			color.a = (float)args["alpha"];
			args.Remove("alpha");
		}
		if ((bool)target.GetComponent<Renderer>())
		{
			target.GetComponent<Renderer>().material.color = color;
		}
		else if ((bool)target.GetComponent<Light>())
		{
			target.GetComponent<Light>().color = color;
		}
		args["color"] = color2;
		args["type"] = "color";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void ColorTo(GameObject target, Color color, float time)
	{
		ColorTo(target, Hash("color", color, "time", time));
	}

	public static void ColorTo(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		if (!args.Contains("includechildren") || (bool)args["includechildren"])
		{
			foreach (Transform item in target.transform)
			{
				Hashtable hashtable = (Hashtable)args.Clone();
				hashtable["ischild"] = true;
				ColorTo(item.gameObject, hashtable);
			}
		}
		if (!args.Contains("easetype"))
		{
			args.Add("easetype", EaseType.linear);
		}
		args["type"] = "color";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void AudioFrom(GameObject target, float volume, float pitch, float time)
	{
		AudioFrom(target, Hash("volume", volume, "pitch", pitch, "time", time));
	}

	public static void AudioFrom(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		AudioSource audioSource;
		if (args.Contains("audiosource"))
		{
			audioSource = (AudioSource)args["audiosource"];
		}
		else
		{
			if (!target.GetComponent<AudioSource>())
			{
				UnityEngine.Debug.LogError("iTween Error: AudioFrom requires an AudioSource.");
				return;
			}
			audioSource = target.GetComponent<AudioSource>();
		}
		Vector2 vector = default(Vector2);
		Vector2 vector2 = default(Vector2);
		vector.x = (vector2.x = audioSource.volume);
		vector.y = (vector2.y = audioSource.pitch);
		if (args.Contains("volume"))
		{
			vector2.x = (float)args["volume"];
		}
		if (args.Contains("pitch"))
		{
			vector2.y = (float)args["pitch"];
		}
		audioSource.volume = vector2.x;
		audioSource.pitch = vector2.y;
		args["volume"] = vector.x;
		args["pitch"] = vector.y;
		if (!args.Contains("easetype"))
		{
			args.Add("easetype", EaseType.linear);
		}
		args["type"] = "audio";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void AudioTo(GameObject target, float volume, float pitch, float time)
	{
		AudioTo(target, Hash("volume", volume, "pitch", pitch, "time", time));
	}

	public static void AudioTo(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		if (!args.Contains("easetype"))
		{
			args.Add("easetype", EaseType.linear);
		}
		args["type"] = "audio";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void Stab(GameObject target, AudioClip audioclip, float delay)
	{
		Stab(target, Hash("audioclip", audioclip, "delay", delay));
	}

	public static void Stab(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "stab";
		Launch(target, args);
	}

	public static void LookFrom(GameObject target, Vector3 looktarget, float time)
	{
		LookFrom(target, Hash("looktarget", looktarget, "time", time));
	}

	public static void LookFrom(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		Vector3 eulerAngles = target.transform.eulerAngles;
		if (args["looktarget"].GetType() == typeof(Transform))
		{
			target.transform.LookAt((Transform)args["looktarget"], ((Vector3?)args["up"]) ?? Defaults.up);
		}
		else if (args["looktarget"].GetType() == typeof(Vector3))
		{
			target.transform.LookAt((Vector3)args["looktarget"], ((Vector3?)args["up"]) ?? Defaults.up);
		}
		if (args.Contains("axis"))
		{
			Vector3 eulerAngles2 = target.transform.eulerAngles;
			switch ((string)args["axis"])
			{
			case "x":
				eulerAngles2.y = eulerAngles.y;
				eulerAngles2.z = eulerAngles.z;
				break;
			case "y":
				eulerAngles2.x = eulerAngles.x;
				eulerAngles2.z = eulerAngles.z;
				break;
			case "z":
				eulerAngles2.x = eulerAngles.x;
				eulerAngles2.y = eulerAngles.y;
				break;
			}
			target.transform.eulerAngles = eulerAngles2;
		}
		args["rotation"] = eulerAngles;
		args["type"] = "rotate";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void LookTo(GameObject target, Vector3 looktarget, float time)
	{
		LookTo(target, Hash("looktarget", looktarget, "time", time));
	}

	public static void LookTo(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		if (args.Contains("looktarget") && args["looktarget"].GetType() == typeof(Transform))
		{
			Transform transform = (Transform)args["looktarget"];
			args["position"] = new Vector3(transform.position.x, transform.position.y, transform.position.z);
			args["rotation"] = new Vector3(transform.eulerAngles.x, transform.eulerAngles.y, transform.eulerAngles.z);
		}
		args["type"] = "look";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void MoveTo(GameObject target, Vector3 position, float time)
	{
		MoveTo(target, Hash("position", position, "time", time));
	}

	public static void MoveTo(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		if (args.Contains("position") && args["position"].GetType() == typeof(Transform))
		{
			Transform transform = (Transform)args["position"];
			args["position"] = new Vector3(transform.position.x, transform.position.y, transform.position.z);
			args["rotation"] = new Vector3(transform.eulerAngles.x, transform.eulerAngles.y, transform.eulerAngles.z);
			args["scale"] = new Vector3(transform.localScale.x, transform.localScale.y, transform.localScale.z);
		}
		args["type"] = "move";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void MoveFrom(GameObject target, Vector3 position, float time)
	{
		MoveFrom(target, Hash("position", position, "time", time));
	}

	public static void MoveFrom(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		bool flag = ((!args.Contains("islocal")) ? Defaults.isLocal : ((bool)args["islocal"]));
		if (args.Contains("path"))
		{
			Vector3[] array2;
			if (args["path"].GetType() == typeof(Vector3[]))
			{
				Vector3[] array = (Vector3[])args["path"];
				array2 = new Vector3[array.Length];
				Array.Copy(array, array2, array.Length);
			}
			else
			{
				Transform[] array3 = (Transform[])args["path"];
				array2 = new Vector3[array3.Length];
				for (int i = 0; i < array3.Length; i++)
				{
					array2[i] = array3[i].position;
				}
			}
			if (array2[^1] != target.transform.position)
			{
				Vector3[] array4 = new Vector3[array2.Length + 1];
				Array.Copy(array2, array4, array2.Length);
				if (flag)
				{
					array4[^1] = target.transform.localPosition;
					target.transform.localPosition = array4[0];
				}
				else
				{
					array4[^1] = target.transform.position;
					target.transform.position = array4[0];
				}
				args["path"] = array4;
			}
			else
			{
				if (flag)
				{
					target.transform.localPosition = array2[0];
				}
				else
				{
					target.transform.position = array2[0];
				}
				args["path"] = array2;
			}
		}
		else
		{
			Vector3 vector;
			Vector3 vector2 = ((!flag) ? (vector = target.transform.position) : (vector = target.transform.localPosition));
			if (args.Contains("position"))
			{
				if (args["position"].GetType() == typeof(Transform))
				{
					vector = ((Transform)args["position"]).position;
				}
				else if (args["position"].GetType() == typeof(Vector3))
				{
					vector = (Vector3)args["position"];
				}
			}
			else
			{
				if (args.Contains("x"))
				{
					vector.x = (float)args["x"];
				}
				if (args.Contains("y"))
				{
					vector.y = (float)args["y"];
				}
				if (args.Contains("z"))
				{
					vector.z = (float)args["z"];
				}
			}
			if (flag)
			{
				target.transform.localPosition = vector;
			}
			else
			{
				target.transform.position = vector;
			}
			args["position"] = vector2;
		}
		args["type"] = "move";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void MoveAdd(GameObject target, Vector3 amount, float time)
	{
		MoveAdd(target, Hash("amount", amount, "time", time));
	}

	public static void MoveAdd(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "move";
		args["method"] = "add";
		Launch(target, args);
	}

	public static void MoveBy(GameObject target, Vector3 amount, float time)
	{
		MoveBy(target, Hash("amount", amount, "time", time));
	}

	public static void MoveBy(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "move";
		args["method"] = "by";
		Launch(target, args);
	}

	public static void ScaleTo(GameObject target, Vector3 scale, float time)
	{
		ScaleTo(target, Hash("scale", scale, "time", time));
	}

	public static void ScaleTo(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		if (args.Contains("scale") && args["scale"].GetType() == typeof(Transform))
		{
			Transform transform = (Transform)args["scale"];
			args["position"] = new Vector3(transform.position.x, transform.position.y, transform.position.z);
			args["rotation"] = new Vector3(transform.eulerAngles.x, transform.eulerAngles.y, transform.eulerAngles.z);
			args["scale"] = new Vector3(transform.localScale.x, transform.localScale.y, transform.localScale.z);
		}
		args["type"] = "scale";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void ScaleFrom(GameObject target, Vector3 scale, float time)
	{
		ScaleFrom(target, Hash("scale", scale, "time", time));
	}

	public static void ScaleFrom(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		Vector3 localScale;
		Vector3 vector = (localScale = target.transform.localScale);
		if (args.Contains("scale"))
		{
			if (args["scale"].GetType() == typeof(Transform))
			{
				localScale = ((Transform)args["scale"]).localScale;
			}
			else if (args["scale"].GetType() == typeof(Vector3))
			{
				localScale = (Vector3)args["scale"];
			}
		}
		else
		{
			if (args.Contains("x"))
			{
				localScale.x = (float)args["x"];
			}
			if (args.Contains("y"))
			{
				localScale.y = (float)args["y"];
			}
			if (args.Contains("z"))
			{
				localScale.z = (float)args["z"];
			}
		}
		target.transform.localScale = localScale;
		args["scale"] = vector;
		args["type"] = "scale";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void ScaleAdd(GameObject target, Vector3 amount, float time)
	{
		ScaleAdd(target, Hash("amount", amount, "time", time));
	}

	public static void ScaleAdd(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "scale";
		args["method"] = "add";
		Launch(target, args);
	}

	public static void ScaleBy(GameObject target, Vector3 amount, float time)
	{
		ScaleBy(target, Hash("amount", amount, "time", time));
	}

	public static void ScaleBy(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "scale";
		args["method"] = "by";
		Launch(target, args);
	}

	public static void RotateTo(GameObject target, Vector3 rotation, float time)
	{
		RotateTo(target, Hash("rotation", rotation, "time", time));
	}

	public static void RotateTo(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		if (args.Contains("rotation") && args["rotation"].GetType() == typeof(Transform))
		{
			Transform transform = (Transform)args["rotation"];
			args["position"] = new Vector3(transform.position.x, transform.position.y, transform.position.z);
			args["rotation"] = new Vector3(transform.eulerAngles.x, transform.eulerAngles.y, transform.eulerAngles.z);
			args["scale"] = new Vector3(transform.localScale.x, transform.localScale.y, transform.localScale.z);
		}
		args["type"] = "rotate";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void RotateFrom(GameObject target, Vector3 rotation, float time)
	{
		RotateFrom(target, Hash("rotation", rotation, "time", time));
	}

	public static void RotateFrom(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		bool flag = ((!args.Contains("islocal")) ? Defaults.isLocal : ((bool)args["islocal"]));
		Vector3 vector;
		Vector3 vector2 = ((!flag) ? (vector = target.transform.eulerAngles) : (vector = target.transform.localEulerAngles));
		if (args.Contains("rotation"))
		{
			if (args["rotation"].GetType() == typeof(Transform))
			{
				vector = ((Transform)args["rotation"]).eulerAngles;
			}
			else if (args["rotation"].GetType() == typeof(Vector3))
			{
				vector = (Vector3)args["rotation"];
			}
		}
		else
		{
			if (args.Contains("x"))
			{
				vector.x = (float)args["x"];
			}
			if (args.Contains("y"))
			{
				vector.y = (float)args["y"];
			}
			if (args.Contains("z"))
			{
				vector.z = (float)args["z"];
			}
		}
		if (flag)
		{
			target.transform.localEulerAngles = vector;
		}
		else
		{
			target.transform.eulerAngles = vector;
		}
		args["rotation"] = vector2;
		args["type"] = "rotate";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void RotateAdd(GameObject target, Vector3 amount, float time)
	{
		RotateAdd(target, Hash("amount", amount, "time", time));
	}

	public static void RotateAdd(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "rotate";
		args["method"] = "add";
		Launch(target, args);
	}

	public static void RotateBy(GameObject target, Vector3 amount, float time)
	{
		RotateBy(target, Hash("amount", amount, "time", time));
	}

	public static void RotateBy(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "rotate";
		args["method"] = "by";
		Launch(target, args);
	}

	public static void ShakePosition(GameObject target, Vector3 amount, float time)
	{
		ShakePosition(target, Hash("amount", amount, "time", time));
	}

	public static void ShakePosition(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "shake";
		args["method"] = "position";
		Launch(target, args);
	}

	public static void ShakeScale(GameObject target, Vector3 amount, float time)
	{
		ShakeScale(target, Hash("amount", amount, "time", time));
	}

	public static void ShakeScale(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "shake";
		args["method"] = "scale";
		Launch(target, args);
	}

	public static void ShakeRotation(GameObject target, Vector3 amount, float time)
	{
		ShakeRotation(target, Hash("amount", amount, "time", time));
	}

	public static void ShakeRotation(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "shake";
		args["method"] = "rotation";
		Launch(target, args);
	}

	public static void PunchPosition(GameObject target, Vector3 amount, float time)
	{
		PunchPosition(target, Hash("amount", amount, "time", time));
	}

	public static void PunchPosition(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "punch";
		args["method"] = "position";
		args["easetype"] = EaseType.punch;
		Launch(target, args);
	}

	public static void PunchRotation(GameObject target, Vector3 amount, float time)
	{
		PunchRotation(target, Hash("amount", amount, "time", time));
	}

	public static void PunchRotation(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "punch";
		args["method"] = "rotation";
		args["easetype"] = EaseType.punch;
		Launch(target, args);
	}

	public static void PunchScale(GameObject target, Vector3 amount, float time)
	{
		PunchScale(target, Hash("amount", amount, "time", time));
	}

	public static void PunchScale(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "punch";
		args["method"] = "scale";
		args["easetype"] = EaseType.punch;
		Launch(target, args);
	}

	private void GenerateTargets()
	{
		switch (type)
		{
		case "value":
			switch (method)
			{
			case "float":
				GenerateFloatTargets();
				apply = ApplyFloatTargets;
				break;
			case "vector2":
				GenerateVector2Targets();
				apply = ApplyVector2Targets;
				break;
			case "vector3":
				GenerateVector3Targets();
				apply = ApplyVector3Targets;
				break;
			case "color":
				GenerateColorTargets();
				apply = ApplyColorTargets;
				break;
			case "rect":
				GenerateRectTargets();
				apply = ApplyRectTargets;
				break;
			}
			break;
		case "color":
			if (method == "to")
			{
				GenerateColorToTargets();
				apply = ApplyColorToTargets;
			}
			break;
		case "audio":
			if (method == "to")
			{
				GenerateAudioToTargets();
				apply = ApplyAudioToTargets;
			}
			break;
		case "move":
			switch (method)
			{
			case "to":
				if (tweenArguments.Contains("path"))
				{
					GenerateMoveToPathTargets();
					apply = ApplyMoveToPathTargets;
				}
				else
				{
					GenerateMoveToTargets();
					apply = ApplyMoveToTargets;
				}
				break;
			case "by":
			case "add":
				GenerateMoveByTargets();
				apply = ApplyMoveByTargets;
				break;
			}
			break;
		case "scale":
			switch (method)
			{
			case "to":
				GenerateScaleToTargets();
				apply = ApplyScaleToTargets;
				break;
			case "by":
				GenerateScaleByTargets();
				apply = ApplyScaleToTargets;
				break;
			case "add":
				GenerateScaleAddTargets();
				apply = ApplyScaleToTargets;
				break;
			}
			break;
		case "rotate":
			switch (method)
			{
			case "to":
				GenerateRotateToTargets();
				apply = ApplyRotateToTargets;
				break;
			case "add":
				GenerateRotateAddTargets();
				apply = ApplyRotateAddTargets;
				break;
			case "by":
				GenerateRotateByTargets();
				apply = ApplyRotateAddTargets;
				break;
			}
			break;
		case "shake":
			switch (method)
			{
			case "position":
				GenerateShakePositionTargets();
				apply = ApplyShakePositionTargets;
				break;
			case "scale":
				GenerateShakeScaleTargets();
				apply = ApplyShakeScaleTargets;
				break;
			case "rotation":
				GenerateShakeRotationTargets();
				apply = ApplyShakeRotationTargets;
				break;
			}
			break;
		case "punch":
			switch (method)
			{
			case "position":
				GeneratePunchPositionTargets();
				apply = ApplyPunchPositionTargets;
				break;
			case "rotation":
				GeneratePunchRotationTargets();
				apply = ApplyPunchRotationTargets;
				break;
			case "scale":
				GeneratePunchScaleTargets();
				apply = ApplyPunchScaleTargets;
				break;
			}
			break;
		case "look":
			if (method == "to")
			{
				GenerateLookToTargets();
				apply = ApplyLookToTargets;
			}
			break;
		case "stab":
			GenerateStabTargets();
			apply = ApplyStabTargets;
			break;
		}
	}

	private void GenerateRectTargets()
	{
		rects = new Rect[3];
		rects[0] = (Rect)tweenArguments["from"];
		rects[1] = (Rect)tweenArguments["to"];
	}

	private void GenerateColorTargets()
	{
		colors = new Color[1, 3];
		colors[0, 0] = (Color)tweenArguments["from"];
		colors[0, 1] = (Color)tweenArguments["to"];
	}

	private void GenerateVector3Targets()
	{
		vector3s = new Vector3[3];
		vector3s[0] = (Vector3)tweenArguments["from"];
		vector3s[1] = (Vector3)tweenArguments["to"];
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateVector2Targets()
	{
		vector2s = new Vector2[3];
		vector2s[0] = (Vector2)tweenArguments["from"];
		vector2s[1] = (Vector2)tweenArguments["to"];
		if (tweenArguments.Contains("speed"))
		{
			Vector3 vector = new Vector3(vector2s[0].x, vector2s[0].y, 0f);
			Vector3 b = new Vector3(vector2s[1].x, vector2s[1].y, 0f);
			float num = Math.Abs(Vector3.Distance(vector, b));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateFloatTargets()
	{
		floats = new float[3];
		floats[0] = (float)tweenArguments["from"];
		floats[1] = (float)tweenArguments["to"];
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(floats[0] - floats[1]);
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateColorToTargets()
	{
		if ((bool)GetComponent<Renderer>())
		{
			colors = new Color[GetComponent<Renderer>().materials.Length, 3];
			for (int i = 0; i < GetComponent<Renderer>().materials.Length; i++)
			{
				colors[i, 0] = GetComponent<Renderer>().materials[i].GetColor(namedcolorvalue.ToString());
				colors[i, 1] = GetComponent<Renderer>().materials[i].GetColor(namedcolorvalue.ToString());
			}
		}
		else if ((bool)GetComponent<Light>())
		{
			colors = new Color[1, 3];
			colors[0, 0] = (colors[0, 1] = GetComponent<Light>().color);
		}
		else
		{
			colors = new Color[1, 3];
		}
		if (tweenArguments.Contains("color"))
		{
			for (int j = 0; j < colors.GetLength(0); j++)
			{
				colors[j, 1] = (Color)tweenArguments["color"];
			}
		}
		else
		{
			if (tweenArguments.Contains("r"))
			{
				for (int k = 0; k < colors.GetLength(0); k++)
				{
					colors[k, 1].r = (float)tweenArguments["r"];
				}
			}
			if (tweenArguments.Contains("g"))
			{
				for (int l = 0; l < colors.GetLength(0); l++)
				{
					colors[l, 1].g = (float)tweenArguments["g"];
				}
			}
			if (tweenArguments.Contains("b"))
			{
				for (int m = 0; m < colors.GetLength(0); m++)
				{
					colors[m, 1].b = (float)tweenArguments["b"];
				}
			}
			if (tweenArguments.Contains("a"))
			{
				for (int n = 0; n < colors.GetLength(0); n++)
				{
					colors[n, 1].a = (float)tweenArguments["a"];
				}
			}
		}
		if (tweenArguments.Contains("amount"))
		{
			for (int num = 0; num < colors.GetLength(0); num++)
			{
				colors[num, 1].a = (float)tweenArguments["amount"];
			}
		}
		else if (tweenArguments.Contains("alpha"))
		{
			for (int num2 = 0; num2 < colors.GetLength(0); num2++)
			{
				colors[num2, 1].a = (float)tweenArguments["alpha"];
			}
		}
	}

	private void GenerateAudioToTargets()
	{
		vector2s = new Vector2[3];
		if (tweenArguments.Contains("audiosource"))
		{
			audioSource = (AudioSource)tweenArguments["audiosource"];
		}
		else if ((bool)GetComponent<AudioSource>())
		{
			audioSource = GetComponent<AudioSource>();
		}
		else
		{
			UnityEngine.Debug.LogError("iTween Error: AudioTo requires an AudioSource.");
			Dispose();
		}
		vector2s[0] = (vector2s[1] = new Vector2(audioSource.volume, audioSource.pitch));
		if (tweenArguments.Contains("volume"))
		{
			vector2s[1].x = (float)tweenArguments["volume"];
		}
		if (tweenArguments.Contains("pitch"))
		{
			vector2s[1].y = (float)tweenArguments["pitch"];
		}
	}

	private void GenerateStabTargets()
	{
		if (tweenArguments.Contains("audiosource"))
		{
			audioSource = (AudioSource)tweenArguments["audiosource"];
		}
		else if ((bool)GetComponent<AudioSource>())
		{
			audioSource = GetComponent<AudioSource>();
		}
		else
		{
			base.gameObject.AddComponent<AudioSource>();
			audioSource = GetComponent<AudioSource>();
			audioSource.playOnAwake = false;
		}
		audioSource.clip = (AudioClip)tweenArguments["audioclip"];
		if (tweenArguments.Contains("pitch"))
		{
			audioSource.pitch = (float)tweenArguments["pitch"];
		}
		if (tweenArguments.Contains("volume"))
		{
			audioSource.volume = (float)tweenArguments["volume"];
		}
		time = audioSource.clip.length / audioSource.pitch;
	}

	private void GenerateLookToTargets()
	{
		vector3s = new Vector3[3];
		vector3s[0] = thisTransform.eulerAngles;
		if (tweenArguments.Contains("looktarget"))
		{
			if (tweenArguments["looktarget"].GetType() == typeof(Transform))
			{
				thisTransform.LookAt((Transform)tweenArguments["looktarget"], ((Vector3?)tweenArguments["up"]) ?? Defaults.up);
			}
			else if (tweenArguments["looktarget"].GetType() == typeof(Vector3))
			{
				thisTransform.LookAt((Vector3)tweenArguments["looktarget"], ((Vector3?)tweenArguments["up"]) ?? Defaults.up);
			}
		}
		else
		{
			UnityEngine.Debug.LogError("iTween Error: LookTo needs a 'looktarget' property!");
			Dispose();
		}
		vector3s[1] = thisTransform.eulerAngles;
		thisTransform.eulerAngles = vector3s[0];
		if (tweenArguments.Contains("axis"))
		{
			switch ((string)tweenArguments["axis"])
			{
			case "x":
				vector3s[1].y = vector3s[0].y;
				vector3s[1].z = vector3s[0].z;
				break;
			case "y":
				vector3s[1].x = vector3s[0].x;
				vector3s[1].z = vector3s[0].z;
				break;
			case "z":
				vector3s[1].x = vector3s[0].x;
				vector3s[1].y = vector3s[0].y;
				break;
			}
		}
		vector3s[1] = new Vector3(clerp(vector3s[0].x, vector3s[1].x, 1f), clerp(vector3s[0].y, vector3s[1].y, 1f), clerp(vector3s[0].z, vector3s[1].z, 1f));
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateMoveToPathTargets()
	{
		Vector3[] array2;
		if (tweenArguments["path"].GetType() == typeof(Vector3[]))
		{
			Vector3[] array = (Vector3[])tweenArguments["path"];
			if (array.Length == 1)
			{
				UnityEngine.Debug.LogError("iTween Error: Attempting a path movement with MoveTo requires an array of more than 1 entry!");
				Dispose();
			}
			array2 = new Vector3[array.Length];
			Array.Copy(array, array2, array.Length);
		}
		else
		{
			Transform[] array3 = (Transform[])tweenArguments["path"];
			if (array3.Length == 1)
			{
				UnityEngine.Debug.LogError("iTween Error: Attempting a path movement with MoveTo requires an array of more than 1 entry!");
				Dispose();
			}
			array2 = new Vector3[array3.Length];
			for (int i = 0; i < array3.Length; i++)
			{
				array2[i] = array3[i].position;
			}
		}
		bool flag;
		int num;
		if (thisTransform.position != array2[0])
		{
			if (!tweenArguments.Contains("movetopath") || (bool)tweenArguments["movetopath"])
			{
				flag = true;
				num = 3;
			}
			else
			{
				flag = false;
				num = 2;
			}
		}
		else
		{
			flag = false;
			num = 2;
		}
		vector3s = new Vector3[array2.Length + num];
		if (flag)
		{
			vector3s[1] = thisTransform.position;
			num = 2;
		}
		else
		{
			num = 1;
		}
		Array.Copy(array2, 0, vector3s, num, array2.Length);
		vector3s[0] = vector3s[1] + (vector3s[1] - vector3s[2]);
		vector3s[vector3s.Length - 1] = vector3s[vector3s.Length - 2] + (vector3s[vector3s.Length - 2] - vector3s[vector3s.Length - 3]);
		if (vector3s[1] == vector3s[vector3s.Length - 2])
		{
			Vector3[] array4 = new Vector3[vector3s.Length];
			Array.Copy(vector3s, array4, vector3s.Length);
			array4[0] = array4[^3];
			array4[^1] = array4[2];
			vector3s = new Vector3[array4.Length];
			Array.Copy(array4, vector3s, array4.Length);
		}
		path = new CRSpline(vector3s);
		if (tweenArguments.Contains("speed"))
		{
			float num2 = PathLength(vector3s);
			time = num2 / (float)tweenArguments["speed"];
		}
	}

	private void GenerateMoveToTargets()
	{
		vector3s = new Vector3[3];
		if (isLocal)
		{
			vector3s[0] = (vector3s[1] = thisTransform.localPosition);
		}
		else
		{
			vector3s[0] = (vector3s[1] = thisTransform.position);
		}
		if (tweenArguments.Contains("position"))
		{
			if (tweenArguments["position"].GetType() == typeof(Transform))
			{
				Transform transform = (Transform)tweenArguments["position"];
				vector3s[1] = transform.position;
			}
			else if (tweenArguments["position"].GetType() == typeof(Vector3))
			{
				vector3s[1] = (Vector3)tweenArguments["position"];
			}
		}
		else
		{
			if (tweenArguments.Contains("x"))
			{
				vector3s[1].x = (float)tweenArguments["x"];
			}
			if (tweenArguments.Contains("y"))
			{
				vector3s[1].y = (float)tweenArguments["y"];
			}
			if (tweenArguments.Contains("z"))
			{
				vector3s[1].z = (float)tweenArguments["z"];
			}
		}
		if (tweenArguments.Contains("orienttopath") && (bool)tweenArguments["orienttopath"])
		{
			tweenArguments["looktarget"] = vector3s[1];
		}
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateMoveByTargets()
	{
		vector3s = new Vector3[6];
		vector3s[4] = thisTransform.eulerAngles;
		vector3s[0] = (vector3s[1] = (vector3s[3] = thisTransform.position));
		if (tweenArguments.Contains("amount"))
		{
			vector3s[1] = vector3s[0] + (Vector3)tweenArguments["amount"];
		}
		else
		{
			if (tweenArguments.Contains("x"))
			{
				vector3s[1].x = vector3s[0].x + (float)tweenArguments["x"];
			}
			if (tweenArguments.Contains("y"))
			{
				vector3s[1].y = vector3s[0].y + (float)tweenArguments["y"];
			}
			if (tweenArguments.Contains("z"))
			{
				vector3s[1].z = vector3s[0].z + (float)tweenArguments["z"];
			}
		}
		thisTransform.Translate(vector3s[1], space);
		vector3s[5] = thisTransform.position;
		thisTransform.position = vector3s[0];
		if (tweenArguments.Contains("orienttopath") && (bool)tweenArguments["orienttopath"])
		{
			tweenArguments["looktarget"] = vector3s[1];
		}
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateScaleToTargets()
	{
		vector3s = new Vector3[3];
		vector3s[0] = (vector3s[1] = thisTransform.localScale);
		if (tweenArguments.Contains("scale"))
		{
			if (tweenArguments["scale"].GetType() == typeof(Transform))
			{
				Transform transform = (Transform)tweenArguments["scale"];
				vector3s[1] = transform.localScale;
			}
			else if (tweenArguments["scale"].GetType() == typeof(Vector3))
			{
				vector3s[1] = (Vector3)tweenArguments["scale"];
			}
		}
		else
		{
			if (tweenArguments.Contains("x"))
			{
				vector3s[1].x = (float)tweenArguments["x"];
			}
			if (tweenArguments.Contains("y"))
			{
				vector3s[1].y = (float)tweenArguments["y"];
			}
			if (tweenArguments.Contains("z"))
			{
				vector3s[1].z = (float)tweenArguments["z"];
			}
		}
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateScaleByTargets()
	{
		vector3s = new Vector3[3];
		vector3s[0] = (vector3s[1] = thisTransform.localScale);
		if (tweenArguments.Contains("amount"))
		{
			vector3s[1] = Vector3.Scale(vector3s[1], (Vector3)tweenArguments["amount"]);
		}
		else
		{
			if (tweenArguments.Contains("x"))
			{
				vector3s[1].x *= (float)tweenArguments["x"];
			}
			if (tweenArguments.Contains("y"))
			{
				vector3s[1].y *= (float)tweenArguments["y"];
			}
			if (tweenArguments.Contains("z"))
			{
				vector3s[1].z *= (float)tweenArguments["z"];
			}
		}
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateScaleAddTargets()
	{
		vector3s = new Vector3[3];
		vector3s[0] = (vector3s[1] = thisTransform.localScale);
		if (tweenArguments.Contains("amount"))
		{
			vector3s[1] += (Vector3)tweenArguments["amount"];
		}
		else
		{
			if (tweenArguments.Contains("x"))
			{
				vector3s[1].x += (float)tweenArguments["x"];
			}
			if (tweenArguments.Contains("y"))
			{
				vector3s[1].y += (float)tweenArguments["y"];
			}
			if (tweenArguments.Contains("z"))
			{
				vector3s[1].z += (float)tweenArguments["z"];
			}
		}
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateRotateToTargets()
	{
		vector3s = new Vector3[3];
		if (isLocal)
		{
			vector3s[0] = (vector3s[1] = thisTransform.localEulerAngles);
		}
		else
		{
			vector3s[0] = (vector3s[1] = thisTransform.eulerAngles);
		}
		if (tweenArguments.Contains("rotation"))
		{
			if (tweenArguments["rotation"].GetType() == typeof(Transform))
			{
				Transform transform = (Transform)tweenArguments["rotation"];
				vector3s[1] = transform.eulerAngles;
			}
			else if (tweenArguments["rotation"].GetType() == typeof(Vector3))
			{
				vector3s[1] = (Vector3)tweenArguments["rotation"];
			}
		}
		else
		{
			if (tweenArguments.Contains("x"))
			{
				vector3s[1].x = (float)tweenArguments["x"];
			}
			if (tweenArguments.Contains("y"))
			{
				vector3s[1].y = (float)tweenArguments["y"];
			}
			if (tweenArguments.Contains("z"))
			{
				vector3s[1].z = (float)tweenArguments["z"];
			}
		}
		vector3s[1] = new Vector3(clerp(vector3s[0].x, vector3s[1].x, 1f), clerp(vector3s[0].y, vector3s[1].y, 1f), clerp(vector3s[0].z, vector3s[1].z, 1f));
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateRotateAddTargets()
	{
		vector3s = new Vector3[5];
		vector3s[0] = (vector3s[1] = (vector3s[3] = thisTransform.eulerAngles));
		if (tweenArguments.Contains("amount"))
		{
			vector3s[1] += (Vector3)tweenArguments["amount"];
		}
		else
		{
			if (tweenArguments.Contains("x"))
			{
				vector3s[1].x += (float)tweenArguments["x"];
			}
			if (tweenArguments.Contains("y"))
			{
				vector3s[1].y += (float)tweenArguments["y"];
			}
			if (tweenArguments.Contains("z"))
			{
				vector3s[1].z += (float)tweenArguments["z"];
			}
		}
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateRotateByTargets()
	{
		vector3s = new Vector3[4];
		vector3s[0] = (vector3s[1] = (vector3s[3] = thisTransform.eulerAngles));
		if (tweenArguments.Contains("amount"))
		{
			vector3s[1] += Vector3.Scale((Vector3)tweenArguments["amount"], new Vector3(360f, 360f, 360f));
		}
		else
		{
			if (tweenArguments.Contains("x"))
			{
				vector3s[1].x += 360f * (float)tweenArguments["x"];
			}
			if (tweenArguments.Contains("y"))
			{
				vector3s[1].y += 360f * (float)tweenArguments["y"];
			}
			if (tweenArguments.Contains("z"))
			{
				vector3s[1].z += 360f * (float)tweenArguments["z"];
			}
		}
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateShakePositionTargets()
	{
		vector3s = new Vector3[4];
		vector3s[3] = thisTransform.eulerAngles;
		vector3s[0] = thisTransform.position;
		if (tweenArguments.Contains("amount"))
		{
			vector3s[1] = (Vector3)tweenArguments["amount"];
			return;
		}
		if (tweenArguments.Contains("x"))
		{
			vector3s[1].x = (float)tweenArguments["x"];
		}
		if (tweenArguments.Contains("y"))
		{
			vector3s[1].y = (float)tweenArguments["y"];
		}
		if (tweenArguments.Contains("z"))
		{
			vector3s[1].z = (float)tweenArguments["z"];
		}
	}

	private void GenerateShakeScaleTargets()
	{
		vector3s = new Vector3[3];
		vector3s[0] = thisTransform.localScale;
		if (tweenArguments.Contains("amount"))
		{
			vector3s[1] = (Vector3)tweenArguments["amount"];
			return;
		}
		if (tweenArguments.Contains("x"))
		{
			vector3s[1].x = (float)tweenArguments["x"];
		}
		if (tweenArguments.Contains("y"))
		{
			vector3s[1].y = (float)tweenArguments["y"];
		}
		if (tweenArguments.Contains("z"))
		{
			vector3s[1].z = (float)tweenArguments["z"];
		}
	}

	private void GenerateShakeRotationTargets()
	{
		vector3s = new Vector3[3];
		vector3s[0] = thisTransform.eulerAngles;
		if (tweenArguments.Contains("amount"))
		{
			vector3s[1] = (Vector3)tweenArguments["amount"];
			return;
		}
		if (tweenArguments.Contains("x"))
		{
			vector3s[1].x = (float)tweenArguments["x"];
		}
		if (tweenArguments.Contains("y"))
		{
			vector3s[1].y = (float)tweenArguments["y"];
		}
		if (tweenArguments.Contains("z"))
		{
			vector3s[1].z = (float)tweenArguments["z"];
		}
	}

	private void GeneratePunchPositionTargets()
	{
		vector3s = new Vector3[5];
		vector3s[4] = thisTransform.eulerAngles;
		vector3s[0] = thisTransform.position;
		vector3s[1] = (vector3s[3] = Vector3.zero);
		if (tweenArguments.Contains("amount"))
		{
			vector3s[1] = (Vector3)tweenArguments["amount"];
			return;
		}
		if (tweenArguments.Contains("x"))
		{
			vector3s[1].x = (float)tweenArguments["x"];
		}
		if (tweenArguments.Contains("y"))
		{
			vector3s[1].y = (float)tweenArguments["y"];
		}
		if (tweenArguments.Contains("z"))
		{
			vector3s[1].z = (float)tweenArguments["z"];
		}
	}

	private void GeneratePunchRotationTargets()
	{
		vector3s = new Vector3[4];
		vector3s[0] = thisTransform.eulerAngles;
		vector3s[1] = (vector3s[3] = Vector3.zero);
		if (tweenArguments.Contains("amount"))
		{
			vector3s[1] = (Vector3)tweenArguments["amount"];
			return;
		}
		if (tweenArguments.Contains("x"))
		{
			vector3s[1].x = (float)tweenArguments["x"];
		}
		if (tweenArguments.Contains("y"))
		{
			vector3s[1].y = (float)tweenArguments["y"];
		}
		if (tweenArguments.Contains("z"))
		{
			vector3s[1].z = (float)tweenArguments["z"];
		}
	}

	private void GeneratePunchScaleTargets()
	{
		vector3s = new Vector3[3];
		vector3s[0] = thisTransform.localScale;
		vector3s[1] = Vector3.zero;
		if (tweenArguments.Contains("amount"))
		{
			vector3s[1] = (Vector3)tweenArguments["amount"];
			return;
		}
		if (tweenArguments.Contains("x"))
		{
			vector3s[1].x = (float)tweenArguments["x"];
		}
		if (tweenArguments.Contains("y"))
		{
			vector3s[1].y = (float)tweenArguments["y"];
		}
		if (tweenArguments.Contains("z"))
		{
			vector3s[1].z = (float)tweenArguments["z"];
		}
	}

	private void ApplyRectTargets()
	{
		rects[2].x = ease(rects[0].x, rects[1].x, percentage);
		rects[2].y = ease(rects[0].y, rects[1].y, percentage);
		rects[2].width = ease(rects[0].width, rects[1].width, percentage);
		rects[2].height = ease(rects[0].height, rects[1].height, percentage);
		tweenArguments["onupdateparams"] = rects[2];
		if (percentage == 1f)
		{
			tweenArguments["onupdateparams"] = rects[1];
		}
	}

	private void ApplyColorTargets()
	{
		colors[0, 2].r = ease(colors[0, 0].r, colors[0, 1].r, percentage);
		colors[0, 2].g = ease(colors[0, 0].g, colors[0, 1].g, percentage);
		colors[0, 2].b = ease(colors[0, 0].b, colors[0, 1].b, percentage);
		colors[0, 2].a = ease(colors[0, 0].a, colors[0, 1].a, percentage);
		tweenArguments["onupdateparams"] = colors[0, 2];
		if (percentage == 1f)
		{
			tweenArguments["onupdateparams"] = colors[0, 1];
		}
	}

	private void ApplyVector3Targets()
	{
		vector3s[2].x = ease(vector3s[0].x, vector3s[1].x, percentage);
		vector3s[2].y = ease(vector3s[0].y, vector3s[1].y, percentage);
		vector3s[2].z = ease(vector3s[0].z, vector3s[1].z, percentage);
		tweenArguments["onupdateparams"] = vector3s[2];
		if (percentage == 1f)
		{
			tweenArguments["onupdateparams"] = vector3s[1];
		}
	}

	private void ApplyVector2Targets()
	{
		vector2s[2].x = ease(vector2s[0].x, vector2s[1].x, percentage);
		vector2s[2].y = ease(vector2s[0].y, vector2s[1].y, percentage);
		tweenArguments["onupdateparams"] = vector2s[2];
		if (percentage == 1f)
		{
			tweenArguments["onupdateparams"] = vector2s[1];
		}
	}

	private void ApplyFloatTargets()
	{
		floats[2] = ease(floats[0], floats[1], percentage);
		tweenArguments["onupdateparams"] = floats[2];
		if (percentage == 1f)
		{
			tweenArguments["onupdateparams"] = floats[1];
		}
	}

	private void ApplyColorToTargets()
	{
		for (int i = 0; i < colors.GetLength(0); i++)
		{
			colors[i, 2].r = ease(colors[i, 0].r, colors[i, 1].r, percentage);
			colors[i, 2].g = ease(colors[i, 0].g, colors[i, 1].g, percentage);
			colors[i, 2].b = ease(colors[i, 0].b, colors[i, 1].b, percentage);
			colors[i, 2].a = ease(colors[i, 0].a, colors[i, 1].a, percentage);
		}
		if ((bool)GetComponent<Renderer>())
		{
			for (int j = 0; j < colors.GetLength(0); j++)
			{
				GetComponent<Renderer>().materials[j].SetColor(namedcolorvalue.ToString(), colors[j, 2]);
			}
		}
		else if ((bool)GetComponent<Light>())
		{
			GetComponent<Light>().color = colors[0, 2];
		}
		if (percentage != 1f)
		{
			return;
		}
		if ((bool)GetComponent<Renderer>())
		{
			for (int k = 0; k < colors.GetLength(0); k++)
			{
				GetComponent<Renderer>().materials[k].SetColor(namedcolorvalue.ToString(), colors[k, 1]);
			}
		}
		else if ((bool)GetComponent<Light>())
		{
			GetComponent<Light>().color = colors[0, 1];
		}
	}

	private void ApplyAudioToTargets()
	{
		vector2s[2].x = ease(vector2s[0].x, vector2s[1].x, percentage);
		vector2s[2].y = ease(vector2s[0].y, vector2s[1].y, percentage);
		audioSource.volume = vector2s[2].x;
		audioSource.pitch = vector2s[2].y;
		if (percentage == 1f)
		{
			audioSource.volume = vector2s[1].x;
			audioSource.pitch = vector2s[1].y;
		}
	}

	private void ApplyStabTargets()
	{
	}

	private void ApplyMoveToPathTargets()
	{
		preUpdate = thisTransform.position;
		float value = ease(0f, 1f, percentage);
		if (isLocal)
		{
			thisTransform.localPosition = path.Interp(Mathf.Clamp(value, 0f, 1f));
		}
		else
		{
			thisTransform.position = path.Interp(Mathf.Clamp(value, 0f, 1f));
		}
		if (tweenArguments.Contains("orienttopath") && (bool)tweenArguments["orienttopath"])
		{
			float num = ((!tweenArguments.Contains("lookahead")) ? Defaults.lookAhead : ((float)tweenArguments["lookahead"]));
			float value2 = ease(0f, 1f, Mathf.Min(1f, percentage + num));
			tweenArguments["looktarget"] = path.Interp(Mathf.Clamp(value2, 0f, 1f));
		}
		postUpdate = thisTransform.position;
		if (physics)
		{
			GetComponent<Rigidbody>().MovePosition(postUpdate);
		}
	}

	private void ApplyMoveToTargets()
	{
		preUpdate = thisTransform.position;
		vector3s[2].x = ease(vector3s[0].x, vector3s[1].x, percentage);
		vector3s[2].y = ease(vector3s[0].y, vector3s[1].y, percentage);
		vector3s[2].z = ease(vector3s[0].z, vector3s[1].z, percentage);
		if (isLocal)
		{
			thisTransform.localPosition = vector3s[2];
		}
		else
		{
			thisTransform.position = vector3s[2];
		}
		if (percentage == 1f)
		{
			if (isLocal)
			{
				thisTransform.localPosition = vector3s[1];
			}
			else
			{
				thisTransform.position = vector3s[1];
			}
		}
		postUpdate = thisTransform.position;
		if (physics)
		{
			GetComponent<Rigidbody>().MovePosition(postUpdate);
		}
	}

	private void ApplyMoveByTargets()
	{
		preUpdate = thisTransform.position;
		Vector3 eulerAngles = default(Vector3);
		if (tweenArguments.Contains("looktarget"))
		{
			eulerAngles = thisTransform.eulerAngles;
			thisTransform.eulerAngles = vector3s[4];
		}
		vector3s[2].x = ease(vector3s[0].x, vector3s[1].x, percentage);
		vector3s[2].y = ease(vector3s[0].y, vector3s[1].y, percentage);
		vector3s[2].z = ease(vector3s[0].z, vector3s[1].z, percentage);
		thisTransform.Translate(vector3s[2] - vector3s[3], space);
		vector3s[3] = vector3s[2];
		if (tweenArguments.Contains("looktarget"))
		{
			thisTransform.eulerAngles = eulerAngles;
		}
		postUpdate = thisTransform.position;
		if (physics)
		{
			GetComponent<Rigidbody>().MovePosition(postUpdate);
		}
	}

	private void ApplyScaleToTargets()
	{
		vector3s[2].x = ease(vector3s[0].x, vector3s[1].x, percentage);
		vector3s[2].y = ease(vector3s[0].y, vector3s[1].y, percentage);
		vector3s[2].z = ease(vector3s[0].z, vector3s[1].z, percentage);
		thisTransform.localScale = vector3s[2];
		if (percentage == 1f)
		{
			thisTransform.localScale = vector3s[1];
		}
	}

	private void ApplyLookToTargets()
	{
		vector3s[2].x = ease(vector3s[0].x, vector3s[1].x, percentage);
		vector3s[2].y = ease(vector3s[0].y, vector3s[1].y, percentage);
		vector3s[2].z = ease(vector3s[0].z, vector3s[1].z, percentage);
		if (isLocal)
		{
			thisTransform.localRotation = Quaternion.Euler(vector3s[2]);
		}
		else
		{
			thisTransform.rotation = Quaternion.Euler(vector3s[2]);
		}
	}

	private void ApplyRotateToTargets()
	{
		preUpdate = thisTransform.eulerAngles;
		vector3s[2].x = ease(vector3s[0].x, vector3s[1].x, percentage);
		vector3s[2].y = ease(vector3s[0].y, vector3s[1].y, percentage);
		vector3s[2].z = ease(vector3s[0].z, vector3s[1].z, percentage);
		if (isLocal)
		{
			thisTransform.localRotation = Quaternion.Euler(vector3s[2]);
		}
		else
		{
			thisTransform.rotation = Quaternion.Euler(vector3s[2]);
		}
		if (percentage == 1f)
		{
			if (isLocal)
			{
				thisTransform.localRotation = Quaternion.Euler(vector3s[1]);
			}
			else
			{
				thisTransform.rotation = Quaternion.Euler(vector3s[1]);
			}
		}
		postUpdate = thisTransform.eulerAngles;
		if (physics)
		{
			GetComponent<Rigidbody>().MoveRotation(Quaternion.Euler(postUpdate));
		}
	}

	private void ApplyRotateAddTargets()
	{
		preUpdate = thisTransform.eulerAngles;
		vector3s[2].x = ease(vector3s[0].x, vector3s[1].x, percentage);
		vector3s[2].y = ease(vector3s[0].y, vector3s[1].y, percentage);
		vector3s[2].z = ease(vector3s[0].z, vector3s[1].z, percentage);
		thisTransform.Rotate(vector3s[2] - vector3s[3], space);
		vector3s[3] = vector3s[2];
		postUpdate = thisTransform.eulerAngles;
		if (physics)
		{
			GetComponent<Rigidbody>().MoveRotation(Quaternion.Euler(postUpdate));
		}
	}

	private void ApplyShakePositionTargets()
	{
		if (isLocal)
		{
			preUpdate = thisTransform.localPosition;
		}
		else
		{
			preUpdate = thisTransform.position;
		}
		Vector3 eulerAngles = default(Vector3);
		if (tweenArguments.Contains("looktarget"))
		{
			eulerAngles = thisTransform.eulerAngles;
			thisTransform.eulerAngles = vector3s[3];
		}
		if (percentage == 0f)
		{
			thisTransform.Translate(vector3s[1], space);
		}
		if (isLocal)
		{
			thisTransform.localPosition = vector3s[0];
		}
		else
		{
			thisTransform.position = vector3s[0];
		}
		float num = 1f - percentage;
		vector3s[2].x = UnityEngine.Random.Range((0f - vector3s[1].x) * num, vector3s[1].x * num);
		vector3s[2].y = UnityEngine.Random.Range((0f - vector3s[1].y) * num, vector3s[1].y * num);
		vector3s[2].z = UnityEngine.Random.Range((0f - vector3s[1].z) * num, vector3s[1].z * num);
		if (isLocal)
		{
			thisTransform.localPosition += vector3s[2];
		}
		else
		{
			thisTransform.position += vector3s[2];
		}
		if (tweenArguments.Contains("looktarget"))
		{
			thisTransform.eulerAngles = eulerAngles;
		}
		postUpdate = thisTransform.position;
		if (physics)
		{
			GetComponent<Rigidbody>().MovePosition(postUpdate);
		}
	}

	private void ApplyShakeScaleTargets()
	{
		if (percentage == 0f)
		{
			thisTransform.localScale = vector3s[1];
		}
		thisTransform.localScale = vector3s[0];
		float num = 1f - percentage;
		vector3s[2].x = UnityEngine.Random.Range((0f - vector3s[1].x) * num, vector3s[1].x * num);
		vector3s[2].y = UnityEngine.Random.Range((0f - vector3s[1].y) * num, vector3s[1].y * num);
		vector3s[2].z = UnityEngine.Random.Range((0f - vector3s[1].z) * num, vector3s[1].z * num);
		thisTransform.localScale += vector3s[2];
	}

	private void ApplyShakeRotationTargets()
	{
		preUpdate = thisTransform.eulerAngles;
		if (percentage == 0f)
		{
			thisTransform.Rotate(vector3s[1], space);
		}
		thisTransform.eulerAngles = vector3s[0];
		float num = 1f - percentage;
		vector3s[2].x = UnityEngine.Random.Range((0f - vector3s[1].x) * num, vector3s[1].x * num);
		vector3s[2].y = UnityEngine.Random.Range((0f - vector3s[1].y) * num, vector3s[1].y * num);
		vector3s[2].z = UnityEngine.Random.Range((0f - vector3s[1].z) * num, vector3s[1].z * num);
		thisTransform.Rotate(vector3s[2], space);
		postUpdate = thisTransform.eulerAngles;
		if (physics)
		{
			GetComponent<Rigidbody>().MoveRotation(Quaternion.Euler(postUpdate));
		}
	}

	private void ApplyPunchPositionTargets()
	{
		preUpdate = thisTransform.position;
		Vector3 eulerAngles = default(Vector3);
		if (tweenArguments.Contains("looktarget"))
		{
			eulerAngles = thisTransform.eulerAngles;
			thisTransform.eulerAngles = vector3s[4];
		}
		if (vector3s[1].x > 0f)
		{
			vector3s[2].x = punch(vector3s[1].x, percentage);
		}
		else if (vector3s[1].x < 0f)
		{
			vector3s[2].x = 0f - punch(Mathf.Abs(vector3s[1].x), percentage);
		}
		if (vector3s[1].y > 0f)
		{
			vector3s[2].y = punch(vector3s[1].y, percentage);
		}
		else if (vector3s[1].y < 0f)
		{
			vector3s[2].y = 0f - punch(Mathf.Abs(vector3s[1].y), percentage);
		}
		if (vector3s[1].z > 0f)
		{
			vector3s[2].z = punch(vector3s[1].z, percentage);
		}
		else if (vector3s[1].z < 0f)
		{
			vector3s[2].z = 0f - punch(Mathf.Abs(vector3s[1].z), percentage);
		}
		thisTransform.Translate(vector3s[2] - vector3s[3], space);
		vector3s[3] = vector3s[2];
		if (tweenArguments.Contains("looktarget"))
		{
			thisTransform.eulerAngles = eulerAngles;
		}
		postUpdate = thisTransform.position;
		if (physics)
		{
			GetComponent<Rigidbody>().MovePosition(postUpdate);
		}
	}

	private void ApplyPunchRotationTargets()
	{
		preUpdate = thisTransform.eulerAngles;
		if (vector3s[1].x > 0f)
		{
			vector3s[2].x = punch(vector3s[1].x, percentage);
		}
		else if (vector3s[1].x < 0f)
		{
			vector3s[2].x = 0f - punch(Mathf.Abs(vector3s[1].x), percentage);
		}
		if (vector3s[1].y > 0f)
		{
			vector3s[2].y = punch(vector3s[1].y, percentage);
		}
		else if (vector3s[1].y < 0f)
		{
			vector3s[2].y = 0f - punch(Mathf.Abs(vector3s[1].y), percentage);
		}
		if (vector3s[1].z > 0f)
		{
			vector3s[2].z = punch(vector3s[1].z, percentage);
		}
		else if (vector3s[1].z < 0f)
		{
			vector3s[2].z = 0f - punch(Mathf.Abs(vector3s[1].z), percentage);
		}
		thisTransform.Rotate(vector3s[2] - vector3s[3], space);
		vector3s[3] = vector3s[2];
		postUpdate = thisTransform.eulerAngles;
		if (physics)
		{
			GetComponent<Rigidbody>().MoveRotation(Quaternion.Euler(postUpdate));
		}
	}

	private void ApplyPunchScaleTargets()
	{
		if (vector3s[1].x > 0f)
		{
			vector3s[2].x = punch(vector3s[1].x, percentage);
		}
		else if (vector3s[1].x < 0f)
		{
			vector3s[2].x = 0f - punch(Mathf.Abs(vector3s[1].x), percentage);
		}
		if (vector3s[1].y > 0f)
		{
			vector3s[2].y = punch(vector3s[1].y, percentage);
		}
		else if (vector3s[1].y < 0f)
		{
			vector3s[2].y = 0f - punch(Mathf.Abs(vector3s[1].y), percentage);
		}
		if (vector3s[1].z > 0f)
		{
			vector3s[2].z = punch(vector3s[1].z, percentage);
		}
		else if (vector3s[1].z < 0f)
		{
			vector3s[2].z = 0f - punch(Mathf.Abs(vector3s[1].z), percentage);
		}
		thisTransform.localScale = vector3s[0] + vector3s[2];
	}

	private IEnumerator TweenDelay()
	{
		delayStarted = Time.time;
		yield return new WaitForSeconds(delay);
		if (wasPaused)
		{
			wasPaused = false;
			TweenStart();
		}
	}

	private void TweenStart()
	{
		CallBack("onstart");
		if (!loop)
		{
			ConflictCheck();
			GenerateTargets();
		}
		if (type == "stab")
		{
			audioSource.PlayOneShot(audioSource.clip);
		}
		if (type == "move" || type == "scale" || type == "rotate" || type == "punch" || type == "shake" || type == "curve" || type == "look")
		{
			EnableKinematic();
		}
		isRunning = true;
	}

	private IEnumerator TweenRestart()
	{
		if (delay > 0f)
		{
			delayStarted = Time.time;
			yield return new WaitForSeconds(delay);
		}
		loop = true;
		TweenStart();
	}

	private void TweenUpdate()
	{
		apply();
		CallBack("onupdate");
		UpdatePercentage();
	}

	private void TweenComplete()
	{
		isRunning = false;
		if (percentage > 0.5f)
		{
			percentage = 1f;
		}
		else
		{
			percentage = 0f;
		}
		apply();
		if (type == "value")
		{
			CallBack("onupdate");
		}
		if (loopType == LoopType.none)
		{
			Dispose();
		}
		else
		{
			TweenLoop();
		}
		CallBack("oncomplete");
	}

	private void TweenLoop()
	{
		DisableKinematic();
		switch (loopType)
		{
		case LoopType.loop:
			percentage = 0f;
			runningTime = 0f;
			apply();
			StartCoroutine("TweenRestart");
			break;
		case LoopType.pingPong:
			reverse = !reverse;
			runningTime = 0f;
			StartCoroutine("TweenRestart");
			break;
		}
	}

	public static Rect RectUpdate(Rect currentValue, Rect targetValue, float speed)
	{
		return new Rect(FloatUpdate(currentValue.x, targetValue.x, speed), FloatUpdate(currentValue.y, targetValue.y, speed), FloatUpdate(currentValue.width, targetValue.width, speed), FloatUpdate(currentValue.height, targetValue.height, speed));
	}

	public static Vector3 Vector3Update(Vector3 currentValue, Vector3 targetValue, float speed)
	{
		Vector3 vector = targetValue - currentValue;
		currentValue += vector * speed * Time.deltaTime;
		return currentValue;
	}

	public static Vector2 Vector2Update(Vector2 currentValue, Vector2 targetValue, float speed)
	{
		Vector2 vector = targetValue - currentValue;
		currentValue += vector * speed * Time.deltaTime;
		return currentValue;
	}

	public static float FloatUpdate(float currentValue, float targetValue, float speed)
	{
		float num = targetValue - currentValue;
		currentValue += num * speed * Time.deltaTime;
		return currentValue;
	}

	public static void FadeUpdate(GameObject target, Hashtable args)
	{
		args["a"] = args["alpha"];
		ColorUpdate(target, args);
	}

	public static void FadeUpdate(GameObject target, float alpha, float time)
	{
		FadeUpdate(target, Hash("alpha", alpha, "time", time));
	}

	public static void ColorUpdate(GameObject target, Hashtable args)
	{
		CleanArgs(args);
		Color[] array = new Color[4];
		if (!args.Contains("includechildren") || (bool)args["includechildren"])
		{
			foreach (Transform item in target.transform)
			{
				ColorUpdate(item.gameObject, args);
			}
		}
		float num;
		if (args.Contains("time"))
		{
			num = (float)args["time"];
			num *= Defaults.updateTimePercentage;
		}
		else
		{
			num = Defaults.updateTime;
		}
		if ((bool)target.GetComponent<Renderer>())
		{
			array[0] = (array[1] = target.GetComponent<Renderer>().material.color);
		}
		else if ((bool)target.GetComponent<Light>())
		{
			array[0] = (array[1] = target.GetComponent<Light>().color);
		}
		if (args.Contains("color"))
		{
			array[1] = (Color)args["color"];
		}
		else
		{
			if (args.Contains("r"))
			{
				array[1].r = (float)args["r"];
			}
			if (args.Contains("g"))
			{
				array[1].g = (float)args["g"];
			}
			if (args.Contains("b"))
			{
				array[1].b = (float)args["b"];
			}
			if (args.Contains("a"))
			{
				array[1].a = (float)args["a"];
			}
		}
		array[3].r = Mathf.SmoothDamp(array[0].r, array[1].r, ref array[2].r, num);
		array[3].g = Mathf.SmoothDamp(array[0].g, array[1].g, ref array[2].g, num);
		array[3].b = Mathf.SmoothDamp(array[0].b, array[1].b, ref array[2].b, num);
		array[3].a = Mathf.SmoothDamp(array[0].a, array[1].a, ref array[2].a, num);
		if ((bool)target.GetComponent<Renderer>())
		{
			target.GetComponent<Renderer>().material.color = array[3];
		}
		else if ((bool)target.GetComponent<Light>())
		{
			target.GetComponent<Light>().color = array[3];
		}
	}

	public static void ColorUpdate(GameObject target, Color color, float time)
	{
		ColorUpdate(target, Hash("color", color, "time", time));
	}

	public static void AudioUpdate(GameObject target, Hashtable args)
	{
		CleanArgs(args);
		Vector2[] array = new Vector2[4];
		float num;
		if (args.Contains("time"))
		{
			num = (float)args["time"];
			num *= Defaults.updateTimePercentage;
		}
		else
		{
			num = Defaults.updateTime;
		}
		AudioSource audioSource;
		if (args.Contains("audiosource"))
		{
			audioSource = (AudioSource)args["audiosource"];
		}
		else
		{
			if (!target.GetComponent<AudioSource>())
			{
				UnityEngine.Debug.LogError("iTween Error: AudioUpdate requires an AudioSource.");
				return;
			}
			audioSource = target.GetComponent<AudioSource>();
		}
		array[0] = (array[1] = new Vector2(audioSource.volume, audioSource.pitch));
		if (args.Contains("volume"))
		{
			array[1].x = (float)args["volume"];
		}
		if (args.Contains("pitch"))
		{
			array[1].y = (float)args["pitch"];
		}
		array[3].x = Mathf.SmoothDampAngle(array[0].x, array[1].x, ref array[2].x, num);
		array[3].y = Mathf.SmoothDampAngle(array[0].y, array[1].y, ref array[2].y, num);
		audioSource.volume = array[3].x;
		audioSource.pitch = array[3].y;
	}

	public static void AudioUpdate(GameObject target, float volume, float pitch, float time)
	{
		AudioUpdate(target, Hash("volume", volume, "pitch", pitch, "time", time));
	}

	public static void RotateUpdate(GameObject target, Hashtable args)
	{
		CleanArgs(args);
		Vector3[] array = new Vector3[4];
		_ = target.transform.eulerAngles;
		float num;
		if (args.Contains("time"))
		{
			num = (float)args["time"];
			num *= Defaults.updateTimePercentage;
		}
		else
		{
			num = Defaults.updateTime;
		}
		bool flag = ((!args.Contains("islocal")) ? Defaults.isLocal : ((bool)args["islocal"]));
		if (flag)
		{
			array[0] = target.transform.localEulerAngles;
		}
		else
		{
			array[0] = target.transform.eulerAngles;
		}
		if (args.Contains("rotation"))
		{
			if (args["rotation"].GetType() == typeof(Transform))
			{
				Transform transform = (Transform)args["rotation"];
				array[1] = transform.eulerAngles;
			}
			else if (args["rotation"].GetType() == typeof(Vector3))
			{
				array[1] = (Vector3)args["rotation"];
			}
		}
		array[3].x = Mathf.SmoothDampAngle(array[0].x, array[1].x, ref array[2].x, num);
		array[3].y = Mathf.SmoothDampAngle(array[0].y, array[1].y, ref array[2].y, num);
		array[3].z = Mathf.SmoothDampAngle(array[0].z, array[1].z, ref array[2].z, num);
		if (flag)
		{
			target.transform.localEulerAngles = array[3];
		}
		else
		{
			target.transform.eulerAngles = array[3];
		}
		if (target.GetComponent<Rigidbody>() != null)
		{
			Vector3 eulerAngles = target.transform.eulerAngles;
			target.GetComponent<Rigidbody>().MoveRotation(Quaternion.Euler(eulerAngles));
		}
	}

	public static void RotateUpdate(GameObject target, Vector3 rotation, float time)
	{
		RotateUpdate(target, Hash("rotation", rotation, "time", time));
	}

	public static void ScaleUpdate(GameObject target, Hashtable args)
	{
		CleanArgs(args);
		Vector3[] array = new Vector3[4];
		float num;
		if (args.Contains("time"))
		{
			num = (float)args["time"];
			num *= Defaults.updateTimePercentage;
		}
		else
		{
			num = Defaults.updateTime;
		}
		array[0] = (array[1] = target.transform.localScale);
		if (args.Contains("scale"))
		{
			if (args["scale"].GetType() == typeof(Transform))
			{
				Transform transform = (Transform)args["scale"];
				array[1] = transform.localScale;
			}
			else if (args["scale"].GetType() == typeof(Vector3))
			{
				array[1] = (Vector3)args["scale"];
			}
		}
		else
		{
			if (args.Contains("x"))
			{
				array[1].x = (float)args["x"];
			}
			if (args.Contains("y"))
			{
				array[1].y = (float)args["y"];
			}
			if (args.Contains("z"))
			{
				array[1].z = (float)args["z"];
			}
		}
		array[3].x = Mathf.SmoothDamp(array[0].x, array[1].x, ref array[2].x, num);
		array[3].y = Mathf.SmoothDamp(array[0].y, array[1].y, ref array[2].y, num);
		array[3].z = Mathf.SmoothDamp(array[0].z, array[1].z, ref array[2].z, num);
		target.transform.localScale = array[3];
	}

	public static void ScaleUpdate(GameObject target, Vector3 scale, float time)
	{
		ScaleUpdate(target, Hash("scale", scale, "time", time));
	}

	public static void MoveUpdate(GameObject target, Hashtable args)
	{
		CleanArgs(args);
		Vector3[] array = new Vector3[4];
		_ = target.transform.position;
		float num;
		if (args.Contains("time"))
		{
			num = (float)args["time"];
			num *= Defaults.updateTimePercentage;
		}
		else
		{
			num = Defaults.updateTime;
		}
		bool flag = ((!args.Contains("islocal")) ? Defaults.isLocal : ((bool)args["islocal"]));
		if (flag)
		{
			array[0] = (array[1] = target.transform.localPosition);
		}
		else
		{
			array[0] = (array[1] = target.transform.position);
		}
		if (args.Contains("position"))
		{
			if (args["position"].GetType() == typeof(Transform))
			{
				Transform transform = (Transform)args["position"];
				array[1] = transform.position;
			}
			else if (args["position"].GetType() == typeof(Vector3))
			{
				array[1] = (Vector3)args["position"];
			}
		}
		else
		{
			if (args.Contains("x"))
			{
				array[1].x = (float)args["x"];
			}
			if (args.Contains("y"))
			{
				array[1].y = (float)args["y"];
			}
			if (args.Contains("z"))
			{
				array[1].z = (float)args["z"];
			}
		}
		array[3].x = Mathf.SmoothDamp(array[0].x, array[1].x, ref array[2].x, num);
		array[3].y = Mathf.SmoothDamp(array[0].y, array[1].y, ref array[2].y, num);
		array[3].z = Mathf.SmoothDamp(array[0].z, array[1].z, ref array[2].z, num);
		if (args.Contains("orienttopath") && (bool)args["orienttopath"])
		{
			args["looktarget"] = array[3];
		}
		if (args.Contains("looktarget"))
		{
			LookUpdate(target, args);
		}
		if (flag)
		{
			target.transform.localPosition = array[3];
		}
		else
		{
			target.transform.position = array[3];
		}
		if (target.GetComponent<Rigidbody>() != null)
		{
			Vector3 position = target.transform.position;
			target.GetComponent<Rigidbody>().MovePosition(position);
		}
	}

	public static void MoveUpdate(GameObject target, Vector3 position, float time)
	{
		MoveUpdate(target, Hash("position", position, "time", time));
	}

	public static void LookUpdate(GameObject target, Hashtable args)
	{
		CleanArgs(args);
		Vector3[] array = new Vector3[5];
		float num;
		if (args.Contains("looktime"))
		{
			num = (float)args["looktime"];
			num *= Defaults.updateTimePercentage;
		}
		else if (args.Contains("time"))
		{
			num = (float)args["time"] * 0.15f;
			num *= Defaults.updateTimePercentage;
		}
		else
		{
			num = Defaults.updateTime;
		}
		array[0] = target.transform.eulerAngles;
		if (args.Contains("looktarget"))
		{
			if (args["looktarget"].GetType() == typeof(Transform))
			{
				target.transform.LookAt((Transform)args["looktarget"], ((Vector3?)args["up"]) ?? Defaults.up);
			}
			else if (args["looktarget"].GetType() == typeof(Vector3))
			{
				target.transform.LookAt((Vector3)args["looktarget"], ((Vector3?)args["up"]) ?? Defaults.up);
			}
			array[1] = target.transform.eulerAngles;
			target.transform.eulerAngles = array[0];
			array[3].x = Mathf.SmoothDampAngle(array[0].x, array[1].x, ref array[2].x, num);
			array[3].y = Mathf.SmoothDampAngle(array[0].y, array[1].y, ref array[2].y, num);
			array[3].z = Mathf.SmoothDampAngle(array[0].z, array[1].z, ref array[2].z, num);
			target.transform.eulerAngles = array[3];
			if (args.Contains("axis"))
			{
				array[4] = target.transform.eulerAngles;
				switch ((string)args["axis"])
				{
				case "x":
					array[4].y = array[0].y;
					array[4].z = array[0].z;
					break;
				case "y":
					array[4].x = array[0].x;
					array[4].z = array[0].z;
					break;
				case "z":
					array[4].x = array[0].x;
					array[4].y = array[0].y;
					break;
				}
				target.transform.eulerAngles = array[4];
			}
		}
		else
		{
			UnityEngine.Debug.LogError("iTween Error: LookUpdate needs a 'looktarget' property!");
		}
	}

	public static void LookUpdate(GameObject target, Vector3 looktarget, float time)
	{
		LookUpdate(target, Hash("looktarget", looktarget, "time", time));
	}

	public static float PathLength(Transform[] path)
	{
		Vector3[] array = new Vector3[path.Length];
		float num = 0f;
		for (int i = 0; i < path.Length; i++)
		{
			array[i] = path[i].position;
		}
		Vector3[] pts = PathControlPointGenerator(array);
		Vector3 vector = Interp(pts, 0f);
		int num2 = path.Length * 20;
		for (int j = 1; j <= num2; j++)
		{
			float t = (float)j / (float)num2;
			Vector3 vector2 = Interp(pts, t);
			num += Vector3.Distance(vector, vector2);
			vector = vector2;
		}
		return num;
	}

	public static float PathLength(Vector3[] path)
	{
		float num = 0f;
		Vector3[] pts = PathControlPointGenerator(path);
		Vector3 vector = Interp(pts, 0f);
		int num2 = path.Length * 20;
		for (int i = 1; i <= num2; i++)
		{
			float t = (float)i / (float)num2;
			Vector3 vector2 = Interp(pts, t);
			num += Vector3.Distance(vector, vector2);
			vector = vector2;
		}
		return num;
	}

	public static void PutOnPath(GameObject target, Vector3[] path, float percent)
	{
		target.transform.position = Interp(PathControlPointGenerator(path), percent);
	}

	public static void PutOnPath(Transform target, Vector3[] path, float percent)
	{
		target.position = Interp(PathControlPointGenerator(path), percent);
	}

	public static void PutOnPath(GameObject target, Transform[] path, float percent)
	{
		Vector3[] array = new Vector3[path.Length];
		for (int i = 0; i < path.Length; i++)
		{
			array[i] = path[i].position;
		}
		target.transform.position = Interp(PathControlPointGenerator(array), percent);
	}

	public static void PutOnPath(Transform target, Transform[] path, float percent)
	{
		Vector3[] array = new Vector3[path.Length];
		for (int i = 0; i < path.Length; i++)
		{
			array[i] = path[i].position;
		}
		target.position = Interp(PathControlPointGenerator(array), percent);
	}

	public static Vector3 PointOnPath(Transform[] path, float percent)
	{
		Vector3[] array = new Vector3[path.Length];
		for (int i = 0; i < path.Length; i++)
		{
			array[i] = path[i].position;
		}
		return Interp(PathControlPointGenerator(array), percent);
	}

	public static void DrawLine(Vector3[] line)
	{
		if (line.Length != 0)
		{
			DrawLineHelper(line, Defaults.color, "gizmos");
		}
	}

	public static void DrawLine(Vector3[] line, Color color)
	{
		if (line.Length != 0)
		{
			DrawLineHelper(line, color, "gizmos");
		}
	}

	public static void DrawLine(Transform[] line)
	{
		if (line.Length != 0)
		{
			Vector3[] array = new Vector3[line.Length];
			for (int i = 0; i < line.Length; i++)
			{
				array[i] = line[i].position;
			}
			DrawLineHelper(array, Defaults.color, "gizmos");
		}
	}

	public static void DrawLine(Transform[] line, Color color)
	{
		if (line.Length != 0)
		{
			Vector3[] array = new Vector3[line.Length];
			for (int i = 0; i < line.Length; i++)
			{
				array[i] = line[i].position;
			}
			DrawLineHelper(array, color, "gizmos");
		}
	}

	public static void DrawLineGizmos(Vector3[] line)
	{
		if (line.Length != 0)
		{
			DrawLineHelper(line, Defaults.color, "gizmos");
		}
	}

	public static void DrawLineGizmos(Vector3[] line, Color color)
	{
		if (line.Length != 0)
		{
			DrawLineHelper(line, color, "gizmos");
		}
	}

	public static void DrawLineGizmos(Transform[] line)
	{
		if (line.Length != 0)
		{
			Vector3[] array = new Vector3[line.Length];
			for (int i = 0; i < line.Length; i++)
			{
				array[i] = line[i].position;
			}
			DrawLineHelper(array, Defaults.color, "gizmos");
		}
	}

	public static void DrawLineGizmos(Transform[] line, Color color)
	{
		if (line.Length != 0)
		{
			Vector3[] array = new Vector3[line.Length];
			for (int i = 0; i < line.Length; i++)
			{
				array[i] = line[i].position;
			}
			DrawLineHelper(array, color, "gizmos");
		}
	}

	public static void DrawLineHandles(Vector3[] line)
	{
		if (line.Length != 0)
		{
			DrawLineHelper(line, Defaults.color, "handles");
		}
	}

	public static void DrawLineHandles(Vector3[] line, Color color)
	{
		if (line.Length != 0)
		{
			DrawLineHelper(line, color, "handles");
		}
	}

	public static void DrawLineHandles(Transform[] line)
	{
		if (line.Length != 0)
		{
			Vector3[] array = new Vector3[line.Length];
			for (int i = 0; i < line.Length; i++)
			{
				array[i] = line[i].position;
			}
			DrawLineHelper(array, Defaults.color, "handles");
		}
	}

	public static void DrawLineHandles(Transform[] line, Color color)
	{
		if (line.Length != 0)
		{
			Vector3[] array = new Vector3[line.Length];
			for (int i = 0; i < line.Length; i++)
			{
				array[i] = line[i].position;
			}
			DrawLineHelper(array, color, "handles");
		}
	}

	public static Vector3 PointOnPath(Vector3[] path, float percent)
	{
		return Interp(PathControlPointGenerator(path), percent);
	}

	public static void DrawPath(Vector3[] path)
	{
		if (path.Length != 0)
		{
			DrawPathHelper(path, Defaults.color, "gizmos");
		}
	}

	public static void DrawPath(Vector3[] path, Color color)
	{
		if (path.Length != 0)
		{
			DrawPathHelper(path, color, "gizmos");
		}
	}

	public static void DrawPath(Transform[] path)
	{
		if (path.Length != 0)
		{
			Vector3[] array = new Vector3[path.Length];
			for (int i = 0; i < path.Length; i++)
			{
				array[i] = path[i].position;
			}
			DrawPathHelper(array, Defaults.color, "gizmos");
		}
	}

	public static void DrawPath(Transform[] path, Color color)
	{
		if (path.Length != 0)
		{
			Vector3[] array = new Vector3[path.Length];
			for (int i = 0; i < path.Length; i++)
			{
				array[i] = path[i].position;
			}
			DrawPathHelper(array, color, "gizmos");
		}
	}

	public static void DrawPathGizmos(Vector3[] path)
	{
		if (path.Length != 0)
		{
			DrawPathHelper(path, Defaults.color, "gizmos");
		}
	}

	public static void DrawPathGizmos(Vector3[] path, Color color)
	{
		if (path.Length != 0)
		{
			DrawPathHelper(path, color, "gizmos");
		}
	}

	public static void DrawPathGizmos(Transform[] path)
	{
		if (path.Length != 0)
		{
			Vector3[] array = new Vector3[path.Length];
			for (int i = 0; i < path.Length; i++)
			{
				array[i] = path[i].position;
			}
			DrawPathHelper(array, Defaults.color, "gizmos");
		}
	}

	public static void DrawPathGizmos(Transform[] path, Color color)
	{
		if (path.Length != 0)
		{
			Vector3[] array = new Vector3[path.Length];
			for (int i = 0; i < path.Length; i++)
			{
				array[i] = path[i].position;
			}
			DrawPathHelper(array, color, "gizmos");
		}
	}

	public static void DrawPathHandles(Vector3[] path)
	{
		if (path.Length != 0)
		{
			DrawPathHelper(path, Defaults.color, "handles");
		}
	}

	public static void DrawPathHandles(Vector3[] path, Color color)
	{
		if (path.Length != 0)
		{
			DrawPathHelper(path, color, "handles");
		}
	}

	public static void DrawPathHandles(Transform[] path)
	{
		if (path.Length != 0)
		{
			Vector3[] array = new Vector3[path.Length];
			for (int i = 0; i < path.Length; i++)
			{
				array[i] = path[i].position;
			}
			DrawPathHelper(array, Defaults.color, "handles");
		}
	}

	public static void DrawPathHandles(Transform[] path, Color color)
	{
		if (path.Length != 0)
		{
			Vector3[] array = new Vector3[path.Length];
			for (int i = 0; i < path.Length; i++)
			{
				array[i] = path[i].position;
			}
			DrawPathHelper(array, color, "handles");
		}
	}

	public static void Resume(GameObject target)
	{
		UnityEngine.Component[] components = target.GetComponents<iTween>();
		components = components;
		for (int i = 0; i < components.Length; i++)
		{
			((iTween)components[i]).enabled = true;
		}
	}

	public static void Resume(GameObject target, bool includechildren)
	{
		Resume(target);
		if (!includechildren)
		{
			return;
		}
		foreach (Transform item in target.transform)
		{
			Resume(item.gameObject, includechildren: true);
		}
	}

	public static void Resume(GameObject target, string type)
	{
		UnityEngine.Component[] components = target.GetComponents<iTween>();
		components = components;
		for (int i = 0; i < components.Length; i++)
		{
			iTween iTween2 = (iTween)components[i];
			if ((iTween2.type + iTween2.method).Substring(0, type.Length).ToLower() == type.ToLower())
			{
				iTween2.enabled = true;
			}
		}
	}

	public static void Resume(GameObject target, string type, bool includechildren)
	{
		UnityEngine.Component[] components = target.GetComponents<iTween>();
		components = components;
		for (int i = 0; i < components.Length; i++)
		{
			iTween iTween2 = (iTween)components[i];
			if ((iTween2.type + iTween2.method).Substring(0, type.Length).ToLower() == type.ToLower())
			{
				iTween2.enabled = true;
			}
		}
		if (!includechildren)
		{
			return;
		}
		foreach (Transform item in target.transform)
		{
			Resume(item.gameObject, type, includechildren: true);
		}
	}

	public static void Resume()
	{
		for (int i = 0; i < tweens.Count; i++)
		{
			Resume((GameObject)tweens[i]["target"]);
		}
	}

	public static void Resume(string type)
	{
		ArrayList arrayList = new ArrayList();
		for (int i = 0; i < tweens.Count; i++)
		{
			GameObject value = (GameObject)tweens[i]["target"];
			arrayList.Insert(arrayList.Count, value);
		}
		for (int j = 0; j < arrayList.Count; j++)
		{
			Resume((GameObject)arrayList[j], type);
		}
	}

	public static void Pause(GameObject target)
	{
		UnityEngine.Component[] components = target.GetComponents<iTween>();
		components = components;
		for (int i = 0; i < components.Length; i++)
		{
			iTween iTween2 = (iTween)components[i];
			if (iTween2.delay > 0f)
			{
				iTween2.delay -= Time.time - iTween2.delayStarted;
				iTween2.StopCoroutine("TweenDelay");
			}
			iTween2.isPaused = true;
			iTween2.enabled = false;
		}
	}

	public static void Pause(GameObject target, bool includechildren)
	{
		Pause(target);
		if (!includechildren)
		{
			return;
		}
		foreach (Transform item in target.transform)
		{
			Pause(item.gameObject, includechildren: true);
		}
	}

	public static void Pause(GameObject target, string type)
	{
		UnityEngine.Component[] components = target.GetComponents<iTween>();
		components = components;
		for (int i = 0; i < components.Length; i++)
		{
			iTween iTween2 = (iTween)components[i];
			if ((iTween2.type + iTween2.method).Substring(0, type.Length).ToLower() == type.ToLower())
			{
				if (iTween2.delay > 0f)
				{
					iTween2.delay -= Time.time - iTween2.delayStarted;
					iTween2.StopCoroutine("TweenDelay");
				}
				iTween2.isPaused = true;
				iTween2.enabled = false;
			}
		}
	}

	public static void Pause(GameObject target, string type, bool includechildren)
	{
		UnityEngine.Component[] components = target.GetComponents<iTween>();
		components = components;
		for (int i = 0; i < components.Length; i++)
		{
			iTween iTween2 = (iTween)components[i];
			if ((iTween2.type + iTween2.method).Substring(0, type.Length).ToLower() == type.ToLower())
			{
				if (iTween2.delay > 0f)
				{
					iTween2.delay -= Time.time - iTween2.delayStarted;
					iTween2.StopCoroutine("TweenDelay");
				}
				iTween2.isPaused = true;
				iTween2.enabled = false;
			}
		}
		if (!includechildren)
		{
			return;
		}
		foreach (Transform item in target.transform)
		{
			Pause(item.gameObject, type, includechildren: true);
		}
	}

	public static void Pause()
	{
		for (int i = 0; i < tweens.Count; i++)
		{
			Pause((GameObject)tweens[i]["target"]);
		}
	}

	public static void Pause(string type)
	{
		ArrayList arrayList = new ArrayList();
		for (int i = 0; i < tweens.Count; i++)
		{
			GameObject value = (GameObject)tweens[i]["target"];
			arrayList.Insert(arrayList.Count, value);
		}
		for (int j = 0; j < arrayList.Count; j++)
		{
			Pause((GameObject)arrayList[j], type);
		}
	}

	public static int Count()
	{
		return tweens.Count;
	}

	public static int Count(string type)
	{
		int num = 0;
		for (int i = 0; i < tweens.Count; i++)
		{
			Hashtable hashtable = tweens[i];
			if (((string)hashtable["type"] + (string)hashtable["method"]).Substring(0, type.Length).ToLower() == type.ToLower())
			{
				num++;
			}
		}
		return num;
	}

	public static int Count(GameObject target)
	{
		UnityEngine.Component[] components = target.GetComponents<iTween>();
		return components.Length;
	}

	public static int Count(GameObject target, string type)
	{
		int num = 0;
		UnityEngine.Component[] components = target.GetComponents<iTween>();
		components = components;
		for (int i = 0; i < components.Length; i++)
		{
			iTween iTween2 = (iTween)components[i];
			if ((iTween2.type + iTween2.method).Substring(0, type.Length).ToLower() == type.ToLower())
			{
				num++;
			}
		}
		return num;
	}

	public static void Stop()
	{
		for (int i = 0; i < tweens.Count; i++)
		{
			Stop((GameObject)tweens[i]["target"]);
		}
		tweens.Clear();
	}

	public static void Stop(string type)
	{
		ArrayList arrayList = new ArrayList();
		for (int i = 0; i < tweens.Count; i++)
		{
			GameObject value = (GameObject)tweens[i]["target"];
			arrayList.Insert(arrayList.Count, value);
		}
		for (int j = 0; j < arrayList.Count; j++)
		{
			Stop((GameObject)arrayList[j], type);
		}
	}

	public static void StopByName(string name)
	{
		ArrayList arrayList = new ArrayList();
		for (int i = 0; i < tweens.Count; i++)
		{
			GameObject value = (GameObject)tweens[i]["target"];
			arrayList.Insert(arrayList.Count, value);
		}
		for (int j = 0; j < arrayList.Count; j++)
		{
			StopByName((GameObject)arrayList[j], name);
		}
	}

	public static void Stop(GameObject target)
	{
		UnityEngine.Component[] components = target.GetComponents<iTween>();
		components = components;
		for (int i = 0; i < components.Length; i++)
		{
			((iTween)components[i]).Dispose();
		}
	}

	public static void Stop(GameObject target, bool includechildren)
	{
		Stop(target);
		if (!includechildren)
		{
			return;
		}
		foreach (Transform item in target.transform)
		{
			Stop(item.gameObject, includechildren: true);
		}
	}

	public static void Stop(GameObject target, string type)
	{
		UnityEngine.Component[] components = target.GetComponents<iTween>();
		components = components;
		for (int i = 0; i < components.Length; i++)
		{
			iTween iTween2 = (iTween)components[i];
			if ((iTween2.type + iTween2.method).Substring(0, type.Length).ToLower() == type.ToLower())
			{
				iTween2.Dispose();
			}
		}
	}

	public static void StopByName(GameObject target, string name)
	{
		UnityEngine.Component[] components = target.GetComponents<iTween>();
		components = components;
		for (int i = 0; i < components.Length; i++)
		{
			iTween iTween2 = (iTween)components[i];
			if (iTween2._name == name)
			{
				iTween2.Dispose();
			}
		}
	}

	public static void Stop(GameObject target, string type, bool includechildren)
	{
		UnityEngine.Component[] components = target.GetComponents<iTween>();
		components = components;
		for (int i = 0; i < components.Length; i++)
		{
			iTween iTween2 = (iTween)components[i];
			if ((iTween2.type + iTween2.method).Substring(0, type.Length).ToLower() == type.ToLower())
			{
				iTween2.Dispose();
			}
		}
		if (!includechildren)
		{
			return;
		}
		foreach (Transform item in target.transform)
		{
			Stop(item.gameObject, type, includechildren: true);
		}
	}

	public static void StopByName(GameObject target, string name, bool includechildren)
	{
		UnityEngine.Component[] components = target.GetComponents<iTween>();
		components = components;
		for (int i = 0; i < components.Length; i++)
		{
			iTween iTween2 = (iTween)components[i];
			if (iTween2._name == name)
			{
				iTween2.Dispose();
			}
		}
		if (!includechildren)
		{
			return;
		}
		foreach (Transform item in target.transform)
		{
			StopByName(item.gameObject, name, includechildren: true);
		}
	}

	public static Hashtable Hash(params object[] args)
	{
		Hashtable hashtable = new Hashtable(args.Length / 2);
		if (args.Length % 2 != 0)
		{
			UnityEngine.Debug.LogError("Tween Error: Hash requires an even number of arguments!");
			return null;
		}
		for (int i = 0; i < args.Length - 1; i += 2)
		{
			hashtable.Add(args[i], args[i + 1]);
		}
		return hashtable;
	}

	private iTween(Hashtable h)
	{
		tweenArguments = h;
	}

	private void Awake()
	{
		thisTransform = base.transform;
		RetrieveArgs();
		lastRealTime = Time.realtimeSinceStartup;
	}

	private IEnumerator Start()
	{
		if (delay > 0f)
		{
			yield return StartCoroutine("TweenDelay");
		}
		TweenStart();
	}

	private void Update()
	{
		if (!isRunning || physics)
		{
			return;
		}
		if (!reverse)
		{
			if (percentage < 1f)
			{
				TweenUpdate();
			}
			else
			{
				TweenComplete();
			}
		}
		else if (percentage > 0f)
		{
			TweenUpdate();
		}
		else
		{
			TweenComplete();
		}
	}

	private void FixedUpdate()
	{
		if (!isRunning || !physics)
		{
			return;
		}
		if (!reverse)
		{
			if (percentage < 1f)
			{
				TweenUpdate();
			}
			else
			{
				TweenComplete();
			}
		}
		else if (percentage > 0f)
		{
			TweenUpdate();
		}
		else
		{
			TweenComplete();
		}
	}

	private void LateUpdate()
	{
		if (tweenArguments.Contains("looktarget") && isRunning && (type == "move" || type == "shake" || type == "punch"))
		{
			LookUpdate(base.gameObject, tweenArguments);
		}
	}

	private void OnEnable()
	{
		if (isRunning)
		{
			EnableKinematic();
		}
		if (isPaused)
		{
			isPaused = false;
			if (delay > 0f)
			{
				wasPaused = true;
				ResumeDelay();
			}
		}
	}

	private void OnDisable()
	{
		DisableKinematic();
	}

	private static void DrawLineHelper(Vector3[] line, Color color, string method)
	{
		Gizmos.color = color;
		for (int i = 0; i < line.Length - 1; i++)
		{
			if (method == "gizmos")
			{
				Gizmos.DrawLine(line[i], line[i + 1]);
			}
			else if (method == "handles")
			{
				UnityEngine.Debug.LogError("iTween Error: Drawing a line with Handles is temporarily disabled because of compatability issues with Unity 2.6!");
			}
		}
	}

	private static void DrawPathHelper(Vector3[] path, Color color, string method)
	{
		Vector3[] pts = PathControlPointGenerator(path);
		Vector3 to = Interp(pts, 0f);
		Gizmos.color = color;
		int num = path.Length * 20;
		for (int i = 1; i <= num; i++)
		{
			float t = (float)i / (float)num;
			Vector3 vector = Interp(pts, t);
			if (method == "gizmos")
			{
				Gizmos.DrawLine(vector, to);
			}
			else if (method == "handles")
			{
				UnityEngine.Debug.LogError("iTween Error: Drawing a path with Handles is temporarily disabled because of compatability issues with Unity 2.6!");
			}
			to = vector;
		}
	}

	private static Vector3[] PathControlPointGenerator(Vector3[] path)
	{
		int num = 2;
		Vector3[] array = new Vector3[path.Length + num];
		Array.Copy(path, 0, array, 1, path.Length);
		array[0] = array[1] + (array[1] - array[2]);
		array[^1] = array[^2] + (array[^2] - array[^3]);
		if (array[1] == array[^2])
		{
			Vector3[] array2 = new Vector3[array.Length];
			Array.Copy(array, array2, array.Length);
			array2[0] = array2[^3];
			array2[^1] = array2[2];
			array = new Vector3[array2.Length];
			Array.Copy(array2, array, array2.Length);
		}
		return array;
	}

	private static Vector3 Interp(Vector3[] pts, float t)
	{
		int num = pts.Length - 3;
		int num2 = Mathf.Min(Mathf.FloorToInt(t * (float)num), num - 1);
		float num3 = t * (float)num - (float)num2;
		Vector3 vector = pts[num2];
		Vector3 vector2 = pts[num2 + 1];
		Vector3 vector3 = pts[num2 + 2];
		Vector3 vector4 = pts[num2 + 3];
		return 0.5f * ((-vector + 3f * vector2 - 3f * vector3 + vector4) * (num3 * num3 * num3) + (2f * vector - 5f * vector2 + 4f * vector3 - vector4) * (num3 * num3) + (-vector + vector3) * num3 + 2f * vector2);
	}

	private static void Launch(GameObject target, Hashtable args)
	{
		if (!args.Contains("id"))
		{
			args["id"] = GenerateID();
		}
		if (!args.Contains("target"))
		{
			args["target"] = target;
		}
		tweens.Insert(0, args);
		target.AddComponent<iTween>();
	}

	private static Hashtable CleanArgs(Hashtable args)
	{
		Hashtable hashtable = new Hashtable(args.Count);
		Hashtable hashtable2 = new Hashtable(args.Count);
		foreach (DictionaryEntry arg in args)
		{
			hashtable.Add(arg.Key, arg.Value);
		}
		foreach (DictionaryEntry item in hashtable)
		{
			if (item.Value.GetType() == typeof(int))
			{
				float num = (int)item.Value;
				args[item.Key] = num;
			}
			if (item.Value.GetType() == typeof(double))
			{
				float num2 = (float)(double)item.Value;
				args[item.Key] = num2;
			}
		}
		foreach (DictionaryEntry arg2 in args)
		{
			hashtable2.Add(arg2.Key.ToString().ToLower(), arg2.Value);
		}
		args = hashtable2;
		return args;
	}

	private static string GenerateID()
	{
		return Guid.NewGuid().ToString();
	}

	private void RetrieveArgs()
	{
		foreach (Hashtable tween in tweens)
		{
			if ((GameObject)tween["target"] == base.gameObject)
			{
				tweenArguments = tween;
				break;
			}
		}
		id = (string)tweenArguments["id"];
		type = (string)tweenArguments["type"];
		_name = (string)tweenArguments["name"];
		method = (string)tweenArguments["method"];
		if (tweenArguments.Contains("time"))
		{
			time = (float)tweenArguments["time"];
		}
		else
		{
			time = Defaults.time;
		}
		if (GetComponent<Rigidbody>() != null)
		{
			physics = true;
		}
		if (tweenArguments.Contains("delay"))
		{
			delay = (float)tweenArguments["delay"];
		}
		else
		{
			delay = Defaults.delay;
		}
		if (tweenArguments.Contains("namedcolorvalue"))
		{
			if (tweenArguments["namedcolorvalue"].GetType() == typeof(NamedValueColor))
			{
				namedcolorvalue = (NamedValueColor)tweenArguments["namedcolorvalue"];
			}
			else
			{
				try
				{
					namedcolorvalue = (NamedValueColor)Enum.Parse(typeof(NamedValueColor), (string)tweenArguments["namedcolorvalue"], ignoreCase: true);
				}
				catch
				{
					UnityEngine.Debug.LogWarning("iTween: Unsupported namedcolorvalue supplied! Default will be used.");
					namedcolorvalue = NamedValueColor._Color;
				}
			}
		}
		else
		{
			namedcolorvalue = Defaults.namedColorValue;
		}
		if (tweenArguments.Contains("looptype"))
		{
			if (tweenArguments["looptype"].GetType() == typeof(LoopType))
			{
				loopType = (LoopType)tweenArguments["looptype"];
			}
			else
			{
				try
				{
					loopType = (LoopType)Enum.Parse(typeof(LoopType), (string)tweenArguments["looptype"], ignoreCase: true);
				}
				catch
				{
					UnityEngine.Debug.LogWarning("iTween: Unsupported loopType supplied! Default will be used.");
					loopType = LoopType.none;
				}
			}
		}
		else
		{
			loopType = LoopType.none;
		}
		if (tweenArguments.Contains("easetype"))
		{
			if (tweenArguments["easetype"].GetType() == typeof(EaseType))
			{
				easeType = (EaseType)tweenArguments["easetype"];
			}
			else
			{
				try
				{
					easeType = (EaseType)Enum.Parse(typeof(EaseType), (string)tweenArguments["easetype"], ignoreCase: true);
				}
				catch
				{
					UnityEngine.Debug.LogWarning("iTween: Unsupported easeType supplied! Default will be used.");
					easeType = Defaults.easeType;
				}
			}
		}
		else
		{
			easeType = Defaults.easeType;
		}
		if (tweenArguments.Contains("space"))
		{
			if (tweenArguments["space"].GetType() == typeof(Space))
			{
				space = (Space)tweenArguments["space"];
			}
			else
			{
				try
				{
					space = (Space)Enum.Parse(typeof(Space), (string)tweenArguments["space"], ignoreCase: true);
				}
				catch
				{
					UnityEngine.Debug.LogWarning("iTween: Unsupported space supplied! Default will be used.");
					space = Defaults.space;
				}
			}
		}
		else
		{
			space = Defaults.space;
		}
		if (tweenArguments.Contains("islocal"))
		{
			isLocal = (bool)tweenArguments["islocal"];
		}
		else
		{
			isLocal = Defaults.isLocal;
		}
		if (tweenArguments.Contains("ignoretimescale"))
		{
			useRealTime = (bool)tweenArguments["ignoretimescale"];
		}
		else
		{
			useRealTime = Defaults.useRealTime;
		}
		GetEasingFunction();
	}

	private void GetEasingFunction()
	{
		switch (easeType)
		{
		case EaseType.easeInQuad:
			ease = easeInQuad;
			break;
		case EaseType.easeOutQuad:
			ease = easeOutQuad;
			break;
		case EaseType.easeInOutQuad:
			ease = easeInOutQuad;
			break;
		case EaseType.easeInCubic:
			ease = easeInCubic;
			break;
		case EaseType.easeOutCubic:
			ease = easeOutCubic;
			break;
		case EaseType.easeInOutCubic:
			ease = easeInOutCubic;
			break;
		case EaseType.easeInQuart:
			ease = easeInQuart;
			break;
		case EaseType.easeOutQuart:
			ease = easeOutQuart;
			break;
		case EaseType.easeInOutQuart:
			ease = easeInOutQuart;
			break;
		case EaseType.easeInQuint:
			ease = easeInQuint;
			break;
		case EaseType.easeOutQuint:
			ease = easeOutQuint;
			break;
		case EaseType.easeInOutQuint:
			ease = easeInOutQuint;
			break;
		case EaseType.easeInSine:
			ease = easeInSine;
			break;
		case EaseType.easeOutSine:
			ease = easeOutSine;
			break;
		case EaseType.easeInOutSine:
			ease = easeInOutSine;
			break;
		case EaseType.easeInExpo:
			ease = easeInExpo;
			break;
		case EaseType.easeOutExpo:
			ease = easeOutExpo;
			break;
		case EaseType.easeInOutExpo:
			ease = easeInOutExpo;
			break;
		case EaseType.easeInCirc:
			ease = easeInCirc;
			break;
		case EaseType.easeOutCirc:
			ease = easeOutCirc;
			break;
		case EaseType.easeInOutCirc:
			ease = easeInOutCirc;
			break;
		case EaseType.linear:
			ease = linear;
			break;
		case EaseType.spring:
			ease = spring;
			break;
		case EaseType.easeInBounce:
			ease = easeInBounce;
			break;
		case EaseType.easeOutBounce:
			ease = easeOutBounce;
			break;
		case EaseType.easeInOutBounce:
			ease = easeInOutBounce;
			break;
		case EaseType.easeInBack:
			ease = easeInBack;
			break;
		case EaseType.easeOutBack:
			ease = easeOutBack;
			break;
		case EaseType.easeInOutBack:
			ease = easeInOutBack;
			break;
		case EaseType.easeInElastic:
			ease = easeInElastic;
			break;
		case EaseType.easeOutElastic:
			ease = easeOutElastic;
			break;
		case EaseType.easeInOutElastic:
			ease = easeInOutElastic;
			break;
		}
	}

	private void UpdatePercentage()
	{
		if (useRealTime)
		{
			runningTime += Time.realtimeSinceStartup - lastRealTime;
		}
		else
		{
			runningTime += Time.deltaTime;
		}
		if (reverse)
		{
			percentage = 1f - runningTime / time;
		}
		else
		{
			percentage = runningTime / time;
		}
		lastRealTime = Time.realtimeSinceStartup;
	}

	private void CallBack(string callbackType)
	{
		if (tweenArguments.Contains(callbackType) && !tweenArguments.Contains("ischild"))
		{
			GameObject gameObject = ((!tweenArguments.Contains(callbackType + "target")) ? base.gameObject : ((GameObject)tweenArguments[callbackType + "target"]));
			if (tweenArguments[callbackType].GetType() == typeof(string))
			{
				gameObject.SendMessage((string)tweenArguments[callbackType], tweenArguments[callbackType + "params"], SendMessageOptions.DontRequireReceiver);
				return;
			}
			UnityEngine.Debug.LogError("iTween Error: Callback method references must be passed as a String!");
			UnityEngine.Object.Destroy(this);
		}
	}

	private void Dispose()
	{
		for (int i = 0; i < tweens.Count; i++)
		{
			if ((string)tweens[i]["id"] == id)
			{
				tweens.RemoveAt(i);
				break;
			}
		}
		UnityEngine.Object.Destroy(this);
	}

	private void ConflictCheck()
	{
		UnityEngine.Component[] components = GetComponents<iTween>();
		components = components;
		for (int i = 0; i < components.Length; i++)
		{
			iTween iTween2 = (iTween)components[i];
			if (iTween2.type == "value")
			{
				break;
			}
			if (!iTween2.isRunning || !(iTween2.type == type))
			{
				continue;
			}
			if (iTween2.method != method)
			{
				break;
			}
			if (iTween2.tweenArguments.Count != tweenArguments.Count)
			{
				iTween2.Dispose();
				break;
			}
			foreach (DictionaryEntry tweenArgument in tweenArguments)
			{
				if (!iTween2.tweenArguments.Contains(tweenArgument.Key))
				{
					iTween2.Dispose();
					return;
				}
				if (!iTween2.tweenArguments[tweenArgument.Key].Equals(tweenArguments[tweenArgument.Key]) && (string)tweenArgument.Key != "id")
				{
					iTween2.Dispose();
					return;
				}
			}
			Dispose();
		}
	}

	private void EnableKinematic()
	{
	}

	private void DisableKinematic()
	{
	}

	private void ResumeDelay()
	{
		StartCoroutine("TweenDelay");
	}

	private float linear(float start, float end, float value)
	{
		return Mathf.Lerp(start, end, value);
	}

	private float clerp(float start, float end, float value)
	{
		float num = 0f;
		float num2 = 360f;
		float num3 = Mathf.Abs((num2 - num) * 0.5f);
		float num4 = 0f;
		float num5 = 0f;
		if (end - start < 0f - num3)
		{
			num5 = (num2 - start + end) * value;
			return start + num5;
		}
		if (end - start > num3)
		{
			num5 = (0f - (num2 - end + start)) * value;
			return start + num5;
		}
		return start + (end - start) * value;
	}

	private float spring(float start, float end, float value)
	{
		value = Mathf.Clamp01(value);
		value = (Mathf.Sin(value * MathF.PI * (0.2f + 2.5f * value * value * value)) * Mathf.Pow(1f - value, 2.2f) + value) * (1f + 1.2f * (1f - value));
		return start + (end - start) * value;
	}

	private float easeInQuad(float start, float end, float value)
	{
		end -= start;
		return end * value * value + start;
	}

	private float easeOutQuad(float start, float end, float value)
	{
		end -= start;
		return (0f - end) * value * (value - 2f) + start;
	}

	private float easeInOutQuad(float start, float end, float value)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return end * 0.5f * value * value + start;
		}
		value -= 1f;
		return (0f - end) * 0.5f * (value * (value - 2f) - 1f) + start;
	}

	private float easeInCubic(float start, float end, float value)
	{
		end -= start;
		return end * value * value * value + start;
	}

	private float easeOutCubic(float start, float end, float value)
	{
		value -= 1f;
		end -= start;
		return end * (value * value * value + 1f) + start;
	}

	private float easeInOutCubic(float start, float end, float value)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return end * 0.5f * value * value * value + start;
		}
		value -= 2f;
		return end * 0.5f * (value * value * value + 2f) + start;
	}

	private float easeInQuart(float start, float end, float value)
	{
		end -= start;
		return end * value * value * value * value + start;
	}

	private float easeOutQuart(float start, float end, float value)
	{
		value -= 1f;
		end -= start;
		return (0f - end) * (value * value * value * value - 1f) + start;
	}

	private float easeInOutQuart(float start, float end, float value)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return end * 0.5f * value * value * value * value + start;
		}
		value -= 2f;
		return (0f - end) * 0.5f * (value * value * value * value - 2f) + start;
	}

	private float easeInQuint(float start, float end, float value)
	{
		end -= start;
		return end * value * value * value * value * value + start;
	}

	private float easeOutQuint(float start, float end, float value)
	{
		value -= 1f;
		end -= start;
		return end * (value * value * value * value * value + 1f) + start;
	}

	private float easeInOutQuint(float start, float end, float value)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return end * 0.5f * value * value * value * value * value + start;
		}
		value -= 2f;
		return end * 0.5f * (value * value * value * value * value + 2f) + start;
	}

	private float easeInSine(float start, float end, float value)
	{
		end -= start;
		return (0f - end) * Mathf.Cos(value * (MathF.PI / 2f)) + end + start;
	}

	private float easeOutSine(float start, float end, float value)
	{
		end -= start;
		return end * Mathf.Sin(value * (MathF.PI / 2f)) + start;
	}

	private float easeInOutSine(float start, float end, float value)
	{
		end -= start;
		return (0f - end) * 0.5f * (Mathf.Cos(MathF.PI * value) - 1f) + start;
	}

	private float easeInExpo(float start, float end, float value)
	{
		end -= start;
		return end * Mathf.Pow(2f, 10f * (value - 1f)) + start;
	}

	private float easeOutExpo(float start, float end, float value)
	{
		end -= start;
		return end * (0f - Mathf.Pow(2f, -10f * value) + 1f) + start;
	}

	private float easeInOutExpo(float start, float end, float value)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return end * 0.5f * Mathf.Pow(2f, 10f * (value - 1f)) + start;
		}
		value -= 1f;
		return end * 0.5f * (0f - Mathf.Pow(2f, -10f * value) + 2f) + start;
	}

	private float easeInCirc(float start, float end, float value)
	{
		end -= start;
		return (0f - end) * (Mathf.Sqrt(1f - value * value) - 1f) + start;
	}

	private float easeOutCirc(float start, float end, float value)
	{
		value -= 1f;
		end -= start;
		return end * Mathf.Sqrt(1f - value * value) + start;
	}

	private float easeInOutCirc(float start, float end, float value)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return (0f - end) * 0.5f * (Mathf.Sqrt(1f - value * value) - 1f) + start;
		}
		value -= 2f;
		return end * 0.5f * (Mathf.Sqrt(1f - value * value) + 1f) + start;
	}

	private float easeInBounce(float start, float end, float value)
	{
		end -= start;
		float num = 1f;
		return end - easeOutBounce(0f, end, num - value) + start;
	}

	private float easeOutBounce(float start, float end, float value)
	{
		value /= 1f;
		end -= start;
		if (value < 0.36363637f)
		{
			return end * (7.5625f * value * value) + start;
		}
		if (value < 0.72727275f)
		{
			value -= 0.54545456f;
			return end * (7.5625f * value * value + 0.75f) + start;
		}
		if ((double)value < 0.9090909090909091)
		{
			value -= 0.8181818f;
			return end * (7.5625f * value * value + 0.9375f) + start;
		}
		value -= 21f / 22f;
		return end * (7.5625f * value * value + 63f / 64f) + start;
	}

	private float easeInOutBounce(float start, float end, float value)
	{
		end -= start;
		float num = 1f;
		if (value < num * 0.5f)
		{
			return easeInBounce(0f, end, value * 2f) * 0.5f + start;
		}
		return easeOutBounce(0f, end, value * 2f - num) * 0.5f + end * 0.5f + start;
	}

	private float easeInBack(float start, float end, float value)
	{
		end -= start;
		value /= 1f;
		float num = 1.70158f;
		return end * value * value * ((num + 1f) * value - num) + start;
	}

	private float easeOutBack(float start, float end, float value)
	{
		float num = 1.70158f;
		end -= start;
		value -= 1f;
		return end * (value * value * ((num + 1f) * value + num) + 1f) + start;
	}

	private float easeInOutBack(float start, float end, float value)
	{
		float num = 1.70158f;
		end -= start;
		value /= 0.5f;
		if (value < 1f)
		{
			num *= 1.525f;
			return end * 0.5f * (value * value * ((num + 1f) * value - num)) + start;
		}
		value -= 2f;
		num *= 1.525f;
		return end * 0.5f * (value * value * ((num + 1f) * value + num) + 2f) + start;
	}

	private float punch(float amplitude, float value)
	{
		float num = 9f;
		if (value == 0f)
		{
			return 0f;
		}
		if (value == 1f)
		{
			return 0f;
		}
		float num2 = 0.3f;
		num = num2 / (MathF.PI * 2f) * Mathf.Asin(0f);
		return amplitude * Mathf.Pow(2f, -10f * value) * Mathf.Sin((value * 1f - num) * (MathF.PI * 2f) / num2);
	}

	private float easeInElastic(float start, float end, float value)
	{
		end -= start;
		float num = 1f;
		float num2 = num * 0.3f;
		float num3 = 0f;
		float num4 = 0f;
		if (value == 0f)
		{
			return start;
		}
		if ((value /= num) == 1f)
		{
			return start + end;
		}
		if (num4 == 0f || num4 < Mathf.Abs(end))
		{
			num4 = end;
			num3 = num2 / 4f;
		}
		else
		{
			num3 = num2 / (MathF.PI * 2f) * Mathf.Asin(end / num4);
		}
		return 0f - num4 * Mathf.Pow(2f, 10f * (value -= 1f)) * Mathf.Sin((value * num - num3) * (MathF.PI * 2f) / num2) + start;
	}

	private float easeOutElastic(float start, float end, float value)
	{
		end -= start;
		float num = 1f;
		float num2 = num * 0.3f;
		float num3 = 0f;
		float num4 = 0f;
		if (value == 0f)
		{
			return start;
		}
		if ((value /= num) == 1f)
		{
			return start + end;
		}
		if (num4 == 0f || num4 < Mathf.Abs(end))
		{
			num4 = end;
			num3 = num2 * 0.25f;
		}
		else
		{
			num3 = num2 / (MathF.PI * 2f) * Mathf.Asin(end / num4);
		}
		return num4 * Mathf.Pow(2f, -10f * value) * Mathf.Sin((value * num - num3) * (MathF.PI * 2f) / num2) + end + start;
	}

	private float easeInOutElastic(float start, float end, float value)
	{
		end -= start;
		float num = 1f;
		float num2 = num * 0.3f;
		float num3 = 0f;
		float num4 = 0f;
		if (value == 0f)
		{
			return start;
		}
		if ((value /= num * 0.5f) == 2f)
		{
			return start + end;
		}
		if (num4 == 0f || num4 < Mathf.Abs(end))
		{
			num4 = end;
			num3 = num2 / 4f;
		}
		else
		{
			num3 = num2 / (MathF.PI * 2f) * Mathf.Asin(end / num4);
		}
		if (value < 1f)
		{
			return -0.5f * (num4 * Mathf.Pow(2f, 10f * (value -= 1f)) * Mathf.Sin((value * num - num3) * (MathF.PI * 2f) / num2)) + start;
		}
		return num4 * Mathf.Pow(2f, -10f * (value -= 1f)) * Mathf.Sin((value * num - num3) * (MathF.PI * 2f) / num2) * 0.5f + end + start;
	}
}
public class MoveSample : MonoBehaviour
{
	private void Start()
	{
		iTween.MoveBy(base.gameObject, iTween.Hash("x", 2, "easeType", "easeInOutExpo", "loopType", "pingPong", "delay", 0.1));
	}
}
public class RotateSample : MonoBehaviour
{
	private void Start()
	{
		iTween.RotateBy(base.gameObject, iTween.Hash("x", 0.25, "easeType", "easeInOutBack", "loopType", "pingPong", "delay", 0.4));
	}
}
public class SampleInfo : MonoBehaviour
{
	private void OnGUI()
	{
		GUILayout.Label("iTween can spin, shake, punch, move, handle audio, fade color and transparency \nand much more with each task needing only one line of code.");
		GUILayout.BeginHorizontal();
		GUILayout.Label("iTween works with C#, JavaScript and Boo. For full documentation and examples visit:");
		if (GUILayout.Button("http://itween.pixelplacement.com"))
		{
			UnityEngine.Application.OpenURL("http://itween.pixelplacement.com");
		}
		GUILayout.EndHorizontal();
	}
}
public class ru : MonoBehaviour
{
	public Vector3 点;

	private bool 完;

	public string 父;

	private void Start()
	{
	}

	private void Update()
	{
		if (!完 && Vector3.Distance(base.transform.position, 点) <= 0.05f)
		{
			完 = true;
			GameObject gameObject = GameObject.Find(父).gameObject;
			base.transform.parent = gameObject.transform;
		}
	}

	public void 隐隐()
	{
		base.enabled = false;
	}

	public void 显显()
	{
		base.enabled = true;
	}
}
public class self_rot : MonoBehaviour
{
	public bool 开始 = true;

	public float 速度 = 50f;

	private void Start()
	{
	}

	private void Update()
	{
		if (开始)
		{
			base.transform.Rotate(base.transform.forward, Time.deltaTime * 速度);
		}
	}
}
public class shuo : MonoBehaviour
{
	public Vector3 点;

	public string 文;

	private bool 完;

	private void Start()
	{
	}

	private void Update()
	{
		if (!完 && Vector3.Distance(base.transform.position, 点) <= 0.05f)
		{
			GameObject obj = UnityEngine.Object.Instantiate(Resources.Load("言", typeof(GameObject)) as GameObject);
			obj.transform.position = base.transform.position;
			obj.GetComponentInChildren<Text>().text = 文;
			完 = true;
		}
	}

	public void 隐隐()
	{
		base.enabled = false;
	}

	public void 显显()
	{
		base.enabled = true;
	}
}
public class slide_con : MonoBehaviour
{
	private Slider 条;

	public bool 是否开始跑;

	public float 速率 = 0.0001f;

	private GameObject 值终出;

	public float 条件值;

	public string 条件键 = "";

	public bool 是否额外执;

	public string 额外文 = "";

	private void Start()
	{
		条 = GetComponent<Slider>();
	}

	private void FixedUpdate()
	{
		if (!是否开始跑 || !(条.value > 0f))
		{
			return;
		}
		条.value -= 速率;
		if (条件键 == "等" || 条件键 == "禾")
		{
			if (条.value <= 条件值)
			{
				值终出 = 返回物(额外文);
				值终出.active = true;
			}
		}
		else if (条件键 == "小" && 条.value < 条件值)
		{
			值终出 = 返回物(额外文);
			值终出.active = true;
		}
	}

	private GameObject 返回物(string 参数)
	{
		GameObject result = null;
		if (参数.Substring(0, 1) == "判" && 参数.Substring(1, 1) == "数")
		{
			int num = 参数.IndexOf("于");
			int num2 = 参数.IndexOf("是");
			int num3 = 参数.IndexOf("否");
			string text = 参数.Substring(num2 + 1, num3 - num2 - 1);
			string text2 = 参数.Substring(num3 + 1);
			GameObject gameObject = null;
			GameObject gameObject2 = null;
			GameObject gameObject3 = GameObject.Find("Canvas");
			for (int i = 0; i < gameObject3.transform.childCount; i++)
			{
				if (gameObject3.transform.GetChild(i).name == text)
				{
					gameObject = gameObject3.transform.GetChild(i).gameObject;
				}
				if (gameObject3.transform.GetChild(i).name == text2)
				{
					gameObject2 = gameObject3.transform.GetChild(i).gameObject;
				}
			}
			string text3 = 参数.Substring(num + 1, num2 - num - 1);
			int num4 = text3.IndexOf("与");
			string text4 = text3.Substring(0, num4);
			string text5 = text3.Substring(num4 + 1);
			Text component = GameObject.Find(text4).GetComponent<Text>();
			Text component2 = GameObject.Find(text5).GetComponent<Text>();
			if (component != null && component2 != null && 参数.Substring(2, 1) == "大")
			{
				result = ((!(float.Parse(component.text) >= float.Parse(component2.text))) ? gameObject2 : gameObject);
			}
		}
		return result;
	}
}
public class sui_show : MonoBehaviour
{
	public Sprite 图;

	public GameObject 父;

	public float 隔时;

	private float 时间;

	private int 洞数;

	public bool 是否开始;

	private void Start()
	{
		if (父 != null)
		{
			洞数 = 父.transform.childCount;
		}
	}

	private void Update()
	{
		if (是否开始)
		{
			时间 += Time.deltaTime;
			if (时间 >= 隔时)
			{
				时间 = 0f;
				消鼠();
				int index = UnityEngine.Random.Range(0, 洞数);
				父.transform.GetChild(index).gameObject.GetComponent<Image>().sprite = 图;
				Color32 color = 父.transform.GetChild(index).gameObject.GetComponent<Image>().color;
				color.a = byte.MaxValue;
				父.transform.GetChild(index).gameObject.GetComponent<Image>().color = color;
			}
		}
	}

	private void 消鼠()
	{
		for (int i = 0; i < 洞数; i++)
		{
			if (父.transform.GetChild(i).gameObject.GetComponent<Image>().sprite != null)
			{
				父.transform.GetChild(i).gameObject.GetComponent<Image>().sprite = null;
				Color32 color = 父.transform.GetChild(i).gameObject.GetComponent<Image>().color;
				color.a = 0;
				父.transform.GetChild(i).gameObject.GetComponent<Image>().color = color;
			}
		}
	}
}
public class tu : MonoBehaviour
{
	public float 速度;

	public Vector3 起点;

	private bool 是否移动;

	public Vector3 终点 = Vector3.zero;

	private Vector3 前进点;

	public float 加横;

	public float 加纵;

	public float 加深;

	private bool 是否停;

	private void Start()
	{
	}

	private void Update()
	{
		if (是否停)
		{
			return;
		}
		if (Input.GetMouseButtonDown(0))
		{
			是否移动 = true;
			前进点 = new Vector3(base.transform.position.x + 加横, base.transform.position.y + 加纵, base.transform.position.z + 加深);
			if (终点 == Vector3.zero && base.gameObject.GetComponent<end>() != null)
			{
				终点 = base.gameObject.GetComponent<end>().终点;
			}
		}
		if (是否移动)
		{
			base.transform.position = Vector3.MoveTowards(base.transform.position, 前进点, Time.deltaTime * 速度);
			if (Vector3.Distance(base.transform.position, 前进点) <= 0.01f)
			{
				base.transform.position = 前进点;
				是否移动 = false;
			}
			if (终点 != Vector3.zero && base.transform.position.x >= 终点.x)
			{
				是否停 = true;
				base.transform.position = 终点;
			}
		}
	}

	public void 隐隐()
	{
		base.enabled = false;
	}

	public void 显显()
	{
		base.enabled = true;
	}
}
public class vr12888 : MonoBehaviour
{
	private bool 是否跟准心;

	public bool 是否下载模型;

	public bool 是否下载特效;

	public GameObject 中心前位置;

	private bool 是否下载字;

	private bool 是否连着下载;

	private string 串字;

	private float 第一字x;

	private int 字串长度;

	private bool 是否串下一 = true;

	private bool 点击否;

	private float 点击否时;

	private ArrayList 格消集 = new ArrayList();

	private ArrayList 格集 = new ArrayList();

	public static string 作用物类型;

	public string 模型名;

	private List<GameObject> 跟准心物集 = new List<GameObject>();

	private List<GameObject> 字集 = new List<GameObject>();

	private List<GameObject> 当前物 = new List<GameObject>();

	private float 时间;

	public GameObject cs12888cs;

	public static bool 是否进入碰撞状态;

	private RaycastHit hit;

	public TextAsset 单人令;

	public TextAsset 单字令;

	private bool 是否移动;

	private GameObject 目标;

	private float 移动速度;

	private float 距长;

	private bool 是否缓动;

	private List<float> 缓动速度 = new List<float>();

	private List<GameObject> 缓目标 = new List<GameObject>();

	private List<string> 缓属性 = new List<string>();

	private List<string> 缓目的 = new List<string>();

	private bool 是否叠加;

	private List<string> 目标函 = new List<string>();

	public Dictionary<string, string> 单事件 = new Dictionary<string, string>();

	private bool 是否开始事件;

	private string 串字模 = "一2301001;丁2301002;七2301003;万2301004;丈2301005;三2301006;上2301007;下2301008;不2301009;与2301010;丑2301011;专2301012;且2301013;世2301014;丘2301015;丙2301016;业2301017;丛2301018;东2301019;丝2301020;丢2301021;两2301022;严2301023;丧2301024;个2301025;中2301026;丰2301027;串2301028;临2301029;丸2301030;丹2301031;为2301032;主2301033;丽2301034;举2301035;乃2301036;久2301037;么2301038;义2301039;之2301040;乌2301041;乎2301042;乏2301043;乐2301044;乒2301045;乓2301046;乔2301047;乖2301048;乘2301049;乙2301050;九2301051;乞2301052;也2301053;习2301054;乡2301055;书2301056;买2301057;乱2301058;乳2301059;了2301060;予2301061;争2301062;事2301063;二2301064;于2301065;亏2301066;云2301067;互2301068;五2301069;井2301070;亚2301071;些2301072;亡2301073;交2301074;亦2301075;产2301076;亩2301077;享2301078;京2301079;亭2301080;亮2301081;亲2301082;人2301083;亿2301084;什2301085;仁2301086;仅2301087;仆2301088;仇2301089;今2301090;介2301091;仍2301092;从2301093;仓2301094;仔2301095;他2301096;仗2301097;付2301098;仙2301099;代2301100;令2301101;以2301102;仪2301103;们2301104;仰2301105;件2301106;价2301107;任2301108;份2301109;仿2301110;企2301111;伍2301112;伏2301113;伐2301114;休2301115;众2301116;优2301117;伙2301118;会2301119;伞2301120;伟2301121;传2301122;伤2301123;伪2301124;伯2301125;估2301126;伴2301127;伶2301128;伸2301129;似2301130;但2301131;位2301132;低2301133;住2301134;体2301135;何2301136;余2301137;佛2301138;作2301139;你2301140;佣2301141;佩2301142;佳2301143;使2301144;侄2301145;例2301146;侍2301147;供2301148;依2301149;侦2301150;侧2301151;侨2301152;侮2301153;侵2301154;便2301155;促2301156;俊2301157;俗2301158;俘2301159;保2301160;信2301161;俩2301162;俭2301163;修2301164;俯2301165;俱2301166;倍2301167;倒2301168;倘2301169;候2301170;倚2301171;借2301172;倡2301173;倦2301174;债2301175;值2301176;倾2301177;假2301178;偏2301179;做2301180;停2301181;健2301182;偶2301183;偷2301184;偿2301185;傅2301186;傍2301187;储2301188;催2301189;傲2301190;傻2301191;像2301192;僚2301193;僵2301194;僻2301195;儿2301196;允2301197;元2301198;兄2301199;充2301200;兆2301201;先2301202;光2301203;克2301204;免2301205;兔2301206;党2301207;入2301208;全2301209;八2301210;公2301211;六2301212;兰2301213;共2301214;关2301215;兴2301216;兵2301217;其2301218;具2301219;典2301220;养2301221;兼2301222;兽2301223;内2301224;冈2301225;册2301226;再2301227;冒2301228;写2301229;军2301230;农2301231;冠2301232;冤2301233;冬2301234;冰2301235;冲2301236;决2301237;况2301238;冶2301239;冷2301240;冻2301241;净2301242;准2301243;凉2301244;减2301245;凑2301246;凝2301247;几2301248;凡2301249;凤2301250;凭2301251;凯2301252;凳2301253;凶2301254;出2301255;击2301256;刀2301257;刃2301258;分2301259;切2301260;刊2301261;刑2301262;划2301263;列2301264;刘2301265;则2301266;刚2301267;创2301268;初2301269;删2301270;判2301271;利2301272;别2301273;刮2301274;到2301275;制2301276;刷2301277;券2301278;刺2301279;刻2301280;剂2301281;剃2301282;削2301283;前2301284;剑2301285;剖2301286;剥2301287;剧2301288;剩2301289;剪2301290;副2301291;割2301292;劈2301293;力2301294;劝2301295;办2301296;功2301297;加2301298;务2301299;劣2301300;动2301301;助2301302;努2301303;劫2301304;励2301305;劲2301306;劳2301307;势2301308;勇2301309;勉2301310;勒2301311;勤2301312;勺2301313;勾2301314;勿2301315;匀2301316;包2301317;匆2301318;化2301319;北2301320;匙2301321;匠2301322;匪2301323;匹2301324;区2301325;医2301326;十2301327;千2301328;升2301329;午2301330;半2301331;华2301332;协2301333;单2301334;卖2301335;南2301336;博2301337;卜2301338;占2301339;卡2301340;卧2301341;卫2301342;印2301343;危2301344;即2301345;却2301346;卵2301347;卷2301348;卸2301349;厂2301350;厅2301351;历2301352;厉2301353;压2301354;厌2301355;厕2301356;厘2301357;厚2301358;原2301359;厦2301360;厨2301361;去2301362;县2301363;参2301364;又2301365;叉2301366;及2301367;友2301368;双2301369;反2301370;发2301371;叔2301372;取2301373;受2301374;变2301375;叙2301376;叛2301377;叠2301378;口2301379;古2301380;句2301381;另2301382;叨2301383;只2301384;叫2301385;召2301386;叮2301387;可2301388;台2301389;史2301390;右2301391;叶2301392;号2301393;司2301394;叹2301395;叼2301396;吃2301397;各2301398;合2301399;吉2301400;吊2301401;同2301402;名2301403;后2301404;吐2301405;向2301406;吓2301407;吗2301408;君2301409;吞2301410;否2301411;吧2301412;吨2301413;吩2301414;含2301415;听2301416;启2301417;吴2301418;吵2301419;吸2301420;吹2301421;吼2301422;呀2301423;呆2301424;呈2301425;告2301426;员2301427;呜2301428;呢2301429;周2301430;味2301431;呼2301432;命2301433;和2301434;咏2301435;咐2301436;咬2301437;咱2301438;咳2301439;咸2301440;咽2301441;哀2301442;品2301443;哄2301444;哈2301445;响2301446;哑2301447;哗2301448;哥2301449;哨2301450;哪2301451;哭2301452;哲2301453;唇2301454;唉2301455;唐2301456;唤2301457;售2301458;唯2301459;唱2301460;啄2301461;商2301462;啊2301463;啦2301464;喂2301465;善2301466;喇2301467;喉2301468;喊2301469;喘2301470;喜2301471;喝2301472;喷2301473;嗓2301474;嗽2301475;嘉2301476;嘱2301477;嘴2301478;器2301479;嚷2301480;嚼2301481;囊2301482;四2301483;回2301484;因2301485;团2301486;园2301487;困2301488;围2301489;固2301490;国2301491;图2301492;圆2301493;圈2301494;土2301495;圣2301496;在2301497;地2301498;场2301499;圾2301500;址2301501;均2301502;坊2301503;坏2301504;坐2301505;坑2301506;块2301507;坚2301508;坛2301509;坝2301510;坟2301511;坡2301512;坦2301513;垂2301514;垃2301515;垄2301516;型2301517;垒2301518;垦2301519;垫2301520;垮2301521;埋2301522;城2301523;域2301524;培2301525;基2301526;堂2301527;堆2301528;堡2301529;堤2301530;堪2301531;堵2301532;塌2301533;塑2301534;塔2301535;塘2301536;塞2301537;填2301538;境2301539;墓2301540;墙2301541;增2301542;墨2301543;壁2301544;壤2301545;士2301546;壮2301547;声2301548;壳2301549;壶2301550;处2301551;备2301552;复2301553;夏2301554;夕2301555;外2301556;多2301557;夜2301558;够2301559;大2301560;天2301561;太2301562;夫2301563;央2301564;失2301565;头2301566;夸2301567;夹2301568;夺2301569;奇2301570;奉2301571;奋2301572;奏2301573;奔2301574;奖2301575;套2301576;奥2301577;女2301578;奴2301579;奶2301580;奸2301581;她2301582;好2301583;如2301584;妄2301585;妇2301586;妈2301587;妖2301588;妙2301589;妥2301590;妨2301591;妹2301592;妻2301593;始2301594;姐2301595;姑2301596;姓2301597;委2301598;姜2301599;姥2301600;姨2301601;姻2301602;姿2301603;威2301604;娃2301605;娇2301606;娘2301607;娱2301608;婆2301609;婚2301610;婶2301611;嫁2301612;嫂2301613;嫌2301614;嫩2301615;子2301616;孔2301617;孕2301618;字2301619;存2301620;孙2301621;孝2301622;孟2301623;季2301624;孤2301625;学2301626;孩2301627;宁2301628;它2301629;宅2301630;宇2301631;守2301632;安2301633;宋2301634;完2301635;宏2301636;宗2301637;官2301638;宙2301639;定2301640;宜2301641;宝2301642;实2301643;审2301644;客2301645;宣2301646;室2301647;宪2301648;宫2301649;宰2301650;害2301651;宴2301652;宵2301653;家2301654;容2301655;宽2301656;宾2301657;宿2301658;寄2301659;密2301660;寇2301661;富2301662;寒2301663;察2301664;寨2301665;寸2301666;对2301667;寺2301668;寻2301669;导2301670;寿2301671;封2301672;射2301673;将2301674;尊2301675;小2301676;少2301677;尖2301678;尘2301679;尚2301680;尝2301681;尤2301682;就2301683;尸2301684;尺2301685;尼2301686;尽2301687;尾2301688;尿2301689;局2301690;层2301691;居2301692;屈2301693;届2301694;屋2301695;屑2301696;展2301697;属2301698;屠2301699;屡2301700;屯2301701;山2301702;屿2301703;岁2301704;岂2301705;岔2301706;岗2301707;岛2301708;岩2301709;岭2301710;岸2301711;峡2301712;峰2301713;崇2301714;崖2301715;崭2301716;川2301717;州2301718;巡2301719;工2301720;左2301721;巧2301722;巨2301723;巩2301724;差2301725;己2301726;已2301727;巴2301728;巷2301729;巾2301730;币2301731;市2301732;布2301733;帅2301734;帆2301735;师2301736;希2301737;帐2301738;帖2301739;帘2301740;帜2301741;帝2301742;带2301743;席2301744;帮2301745;常2301746;帽2301747;幅2301748;幕2301749;干2301750;平2301751;年2301752;并2301753;幸2301754;幻2301755;幼2301756;广2301757;庄2301758;庆2301759;床2301760;序2301761;库2301762;应2301763;底2301764;店2301765;庙2301766;府2301767;废2301768;度2301769;座2301770;庭2301771;康2301772;庸2301773;廉2301774;廊2301775;延2301776;建2301777;开2301778;异2301779;弃2301780;弄2301781;弊2301782;式2301783;弓2301784;引2301785;弟2301786;张2301787;弦2301788;弯2301789;弱2301790;弹2301791;强2301792;归2301793;当2301794;录2301795;形2301796;彩2301797;影2301798;役2301799;彻2301800;彼2301801;往2301802;征2301803;径2301804;待2301805;很2301806;律2301807;徐2301808;徒2301809;得2301810;御2301811;循2301812;微2301813;德2301814;心2301815;必2301816;忆2301817;忌2301818;忍2301819;志2301820;忘2301821;忙2301822;忠2301823;忧2301824;快2301825;念2301826;忽2301827;怀2301828;态2301829;怎2301830;怒2301831;怕2301832;怖2301833;怜2301834;思2301835;怠2301836;急2301837;性2301838;怨2301839;怪2301840;总2301841;恋2301842;恐2301843;恒2301844;恢2301845;恨2301846;恩2301847;恭2301848;息2301849;恰2301850;恳2301851;恶2301852;恼2301853;悄2301854;悉2301855;悔2301856;悟2301857;悠2301858;患2301859;悦2301860;您2301861;悬2301862;悲2301863;悼2301864;情2301865;惊2301866;惑2301867;惕2301868;惜2301869;惠2301870;惧2301871;惨2301872;惩2301873;惭2301874;惯2301875;惰2301876;想2301877;惹2301878;愁2301879;愈2301880;愉2301881;意2301882;愚2301883;感2301884;愤2301885;愧2301886;愿2301887;慈2301888;慌2301889;慎2301890;慕2301891;慢2301892;慧2301893;慨2301894;慰2301895;懂2301896;懒2301897;戏2301898;成2301899;我2301900;戒2301901;或2301902;战2301903;戚2301904;截2301905;戴2301906;户2301907;房2301908;所2301909;扁2301910;扇2301911;手2301912;才2301913;扎2301914;扑2301915;扒2301916;打2301917;扔2301918;托2301919;扛2301920;扣2301921;执2301922;扩2301923;扫2301924;扬2301925;扭2301926;扮2301927;扯2301928;扰2301929;扶2301930;批2301931;找2301932;承2301933;技2301934;抄2301935;把2301936;抓2301937;投2301938;抖2301939;抗2301940;折2301941;抚2301942;抛2301943;抢2301944;护2301945;报2301946;披2301947;抬2301948;抱2301949;抵2301950;抹2301951;押2301952;抽2301953;担2301954;拆2301955;拉2301956;拌2301957;拍2301958;拐2301959;拒2301960;拔2301961;拖2301962;拘2301963;招2301964;拜2301965;拢2301966;拣2301967;拥2301968;拦2301969;拨2301970;择2301971;括2301972;拳2301973;拴2301974;拼2301975;拾2301976;拿2301977;持2301978;挂2301979;指2301980;按2301981;挎2301982;挑2301983;挖2301984;挠2301985;挡2301986;挣2301987;挤2301988;挥2301989;挨2301990;挪2301991;振2301992;挺2301993;挽2301994;捆2301995;捉2301996;捎2301997;捏2301998;捐2301999;捕2302000;捞2302001;损2302002;捡2302003;换2302004;捧2302005;据2302006;捷2302007;掀2302008;授2302009;掉2302010;掌2302011;掏2302012;掘2302013;掠2302014;探2302015;接2302016;控2302017;推2302018;掩2302019;揉2302020;描2302021;提2302022;插2302023;握2302024;揪2302025;揭2302026;援2302027;搁2302028;搂2302029;搅2302030;搏2302031;搜2302032;搞2302033;搬2302034;搭2302035;携2302036;摄2302037;摆2302038;摇2302039;摊2302040;摔2302041;摘2302042;摧2302043;摩2302044;摸2302045;撇2302046;撑2302047;撒2302048;撕2302049;撞2302050;撤2302051;播2302052;操2302053;擦2302054;攀2302055;支2302056;收2302057;改2302058;攻2302059;放2302060;政2302061;故2302062;效2302063;敌2302064;敏2302065;救2302066;教2302067;敞2302068;敢2302069;散2302070;敬2302071;数2302072;敲2302073;整2302074;文2302075;斑2302076;斗2302077;料2302078;斜2302079;斤2302080;斥2302081;斧2302082;斩2302083;断2302084;斯2302085;新2302086;方2302087;施2302088;旁2302089;旅2302090;旋2302091;族2302092;旗2302093;无2302094;既2302095;日2302096;旦2302097;旧2302098;旨2302099;早2302100;旬2302101;旱2302102;时2302103;旷2302104;旺2302105;昂2302106;昆2302107;昌2302108;明2302109;昏2302110;易2302111;星2302112;映2302113;春2302114;昨2302115;是2302116;昼2302117;显2302118;晃2302119;晋2302120;晌2302121;晒2302122;晓2302123;晕2302124;晚2302125;晨2302126;普2302127;景2302128;晴2302129;晶2302130;智2302131;暂2302132;暑2302133;暖2302134;暗2302135;暮2302136;暴2302137;曲2302138;更2302139;曾2302140;替2302141;最2302142;月2302143;有2302144;朋2302145;服2302146;朗2302147;望2302148;朝2302149;期2302150;木2302151;未2302152;末2302153;本2302154;术2302155;朱2302156;朴2302157;朵2302158;机2302159;朽2302160;杀2302161;杂2302162;权2302163;杆2302164;李2302165;杏2302166;材2302167;村2302168;杜2302169;束2302170;杠2302171;条2302172;来2302173;杨2302174;杯2302175;杰2302176;松2302177;板2302178;极2302179;构2302180;析2302181;枕2302182;林2302183;果2302184;枝2302185;枣2302186;枪2302187;枯2302188;架2302189;柄2302190;柏2302191;某2302192;染2302193;柔2302194;柜2302195;查2302196;柱2302197;柳2302198;柴2302199;柿2302200;标2302201;栋2302202;栏2302203;树2302204;栗2302205;校2302206;株2302207;样2302208;核2302209;根2302210;格2302211;栽2302212;桂2302213;桃2302214;框2302215;案2302216;桌2302217;桐2302218;桑2302219;档2302220;桥2302221;桨2302222;桶2302223;梁2302224;梅2302225;梢2302226;梦2302227;梨2302228;梯2302229;械2302230;梳2302231;检2302232;棉2302233;棋2302234;棍2302235;棒2302236;棕2302237;棚2302238;森2302239;棵2302240;椅2302241;植2302242;椒2302243;楚2302244;楼2302245;概2302246;榆2302247;榜2302248;榨2302249;榴2302250;槐2302251;槽2302252;模2302253;横2302254;樱2302255;橘2302256;橡2302257;欠2302258;次2302259;欢2302260;欣2302261;欧2302262;欲2302263;欺2302264;款2302265;歇2302266;歉2302267;歌2302268;止2302269;正2302270;此2302271;步2302272;武2302273;歪2302274;死2302275;歼2302276;殃2302277;殊2302278;残2302279;殖2302280;段2302281;殿2302282;毁2302283;毅2302284;母2302285;每2302286;毒2302287;比2302288;毕2302289;毙2302290;毛2302291;毫2302292;毯2302293;氏2302294;民2302295;气2302296;氧2302297;水2302298;永2302299;汁2302300;求2302301;汇2302302;汉2302303;汗2302304;江2302305;池2302306;污2302307;汤2302308;汪2302309;汽2302310;沃2302311;沈2302312;沉2302313;沙2302314;沟2302315;没2302316;沫2302317;河2302318;沸2302319;油2302320;治2302321;沾2302322;沿2302323;泄2302324;泉2302325;泊2302326;法2302327;泛2302328;泡2302329;波2302330;泥2302331;注2302332;泪2302333;泰2302334;泳2302335;泻2302336;泼2302337;泽2302338;洁2302339;洋2302340;洒2302341;洗2302342;洞2302343;津2302344;洪2302345;洲2302346;活2302347;洽2302348;派2302349;流2302350;浅2302351;浆2302352;浇2302353;浊2302354;测2302355;济2302356;浑2302357;浓2302358;浙2302359;浩2302360;浪2302361;浮2302362;浴2302363;海2302364;浸2302365;涂2302366;消2302367;涉2302368;涌2302369;涛2302370;涝2302371;润2302372;涨2302373;液2302374;淋2302375;淘2302376;淡2302377;深2302378;混2302379;淹2302380;添2302381;清2302382;渐2302383;渔2302384;渗2302385;渠2302386;渡2302387;渣2302388;温2302389;港2302390;渴2302391;游2302392;湖2302393;湾2302394;湿2302395;溉2302396;源2302397;溜2302398;溪2302399;滋2302400;滑2302401;滔2302402;滚2302403;满2302404;滤2302405;滥2302406;滨2302407;滩2302408;滴2302409;漂2302410;漆2302411;漏2302412;演2302413;漠2302414;漫2302415;潜2302416;潮2302417;澡2302418;激2302419;灌2302420;火2302421;灭2302422;灯2302423;灰2302424;灵2302425;灶2302426;灾2302427;灿2302428;炉2302429;炊2302430;炎2302431;炒2302432;炕2302433;炭2302434;炮2302435;炸2302436;点2302437;炼2302438;烂2302439;烈2302440;烘2302441;烛2302442;烟2302443;烤2302444;烦2302445;烧2302446;烫2302447;热2302448;焦2302449;焰2302450;然2302451;煌2302452;煎2302453;煤2302454;照2302455;煮2302456;熄2302457;熊2302458;熔2302459;熟2302460;燃2302461;燕2302462;燥2302463;爆2302464;爪2302465;爬2302466;爱2302467;父2302468;爷2302469;爸2302470;爹2302471;爽2302472;片2302473;版2302474;牌2302475;牙2302476;牛2302477;牢2302478;牧2302479;物2302480;牲2302481;牵2302482;特2302483;牺2302484;犁2302485;犬2302486;犯2302487;状2302488;犹2302489;狂2302490;狐2302491;狗2302492;狠2302493;狡2302494;独2302495;狭2302496;狮2302497;狱2302498;狸2302499;狼2302500;猎2302501;猛2302502;猜2302503;猪2302504;猫2302505;献2302506;猴2302507;猾2302508;率2302509;玉2302510;王2302511;玩2302512;环2302513;现2302514;玻2302515;珍2302516;珠2302517;班2302518;球2302519;理2302520;琴2302521;瑞2302522;璃2302523;瓜2302524;瓣2302525;瓦2302526;瓶2302527;甘2302528;甚2302529;甜2302530;生2302531;用2302532;甩2302533;田2302534;由2302535;甲2302536;申2302537;电2302538;男2302539;画2302540;畅2302541;界2302542;畏2302543;留2302544;畜2302545;略2302546;番2302547;疆2302548;疏2302549;疑2302550;疗2302551;疤2302552;疫2302553;疮2302554;疯2302555;疲2302556;疼2302557;疾2302558;病2302559;症2302560;痒2302561;痕2302562;痛2302563;痰2302564;瘦2302565;登2302566;白2302567;百2302568;皂2302569;的2302570;皆2302571;皇2302572;皮2302573;皱2302574;盆2302575;盈2302576;益2302577;盏2302578;盐2302579;监2302580;盒2302581;盖2302582;盗2302583;盘2302584;盛2302585;盟2302586;目2302587;盯2302588;盲2302589;直2302590;相2302591;盼2302592;盾2302593;省2302594;眉2302595;看2302596;真2302597;眠2302598;眨2302599;眯2302600;眼2302601;着2302602;睁2302603;睛2302604;睡2302605;督2302606;睬2302607;瞎2302608;瞒2302609;瞧2302610;矛2302611;知2302612;矩2302613;短2302614;矮2302615;石2302616;矿2302617;码2302618;砌2302619;砍2302620;研2302621;砖2302622;破2302623;础2302624;硬2302625;确2302626;碌2302627;碍2302628;碎2302629;碑2302630;碗2302631;碧2302632;碰2302633;磁2302634;磨2302635;示2302636;礼2302637;社2302638;祖2302639;祝2302640;神2302641;祥2302642;票2302643;祸2302644;禁2302645;福2302646;离2302647;禽2302648;禾2302649;秀2302650;私2302651;秃2302652;秆2302653;秋2302654;种2302655;科2302656;秒2302657;秘2302658;租2302659;秤2302660;秧2302661;秩2302662;积2302663;称2302664;移2302665;稀2302666;程2302667;稍2302668;税2302669;稠2302670;稳2302671;稻2302672;稼2302673;稿2302674;穗2302675;穴2302676;究2302677;穷2302678;空2302679;穿2302680;突2302681;窃2302682;窄2302683;窑2302684;窗2302685;窜2302686;窝2302687;立2302688;竖2302689;站2302690;竞2302691;竟2302692;章2302693;童2302694;竭2302695;端2302696;竹2302697;竿2302698;笋2302699;笑2302700;笔2302701;笛2302702;符2302703;笨2302704;第2302705;笼2302706;等2302707;筋2302708;筐2302709;筑2302710;筒2302711;答2302712;策2302713;筛2302714;筝2302715;筹2302716;签2302717;简2302718;算2302719;管2302720;箩2302721;箭2302722;箱2302723;篇2302724;篮2302725;籍2302726;米2302727;类2302728;粉2302729;粒2302730;粗2302731;粘2302732;粥2302733;粪2302734;粮2302735;粱2302736;精2302737;糊2302738;糕2302739;糖2302740;糟2302741;糠2302742;系2302743;素2302744;索2302745;紧2302746;紫2302747;累2302748;絮2302749;繁2302750;纠2302751;红2302752;纤2302753;约2302754;级2302755;纪2302756;纯2302757;纱2302758;纲2302759;纳2302760;纵2302761;纷2302762;纸2302763;纹2302764;纺2302765;纽2302766;线2302767;练2302768;组2302769;细2302770;织2302771;终2302772;绍2302773;经2302774;绑2302775;绒2302776;结2302777;绕2302778;绘2302779;给2302780;络2302781;绝2302782;绞2302783;统2302784;绢2302785;绣2302786;继2302787;绩2302788;绪2302789;续2302790;绳2302791;维2302792;绵2302793;绸2302794;绿2302795;缎2302796;缓2302797;编2302798;缘2302799;缝2302800;缠2302801;缩2302802;缴2302803;缸2302804;缺2302805;罐2302806;网2302807;罗2302808;罚2302809;罢2302810;罩2302811;罪2302812;置2302813;羊2302814;美2302815;羞2302816;羡2302817;群2302818;羽2302819;翁2302820;翅2302821;翠2302822;翻2302823;翼2302824;耀2302825;老2302826;考2302827;者2302828;而2302829;耍2302830;耐2302831;耕2302832;耗2302833;耳2302834;耻2302835;耽2302836;聋2302837;职2302838;联2302839;聚2302840;聪2302841;肃2302842;肆2302843;肉2302844;肌2302845;肚2302846;肝2302847;肠2302848;股2302849;肢2302850;肤2302851;肥2302852;肩2302853;肯2302854;育2302855;肺2302856;肾2302857;肿2302858;胀2302859;胁2302860;胃2302861;胆2302862;背2302863;胖2302864;胜2302865;胞2302866;胡2302867;胳2302868;胶2302869;胸2302870;能2302871;脂2302872;脆2302873;脉2302874;脊2302875;脏2302876;脑2302877;脖2302878;脚2302879;脱2302880;脸2302881;脾2302882;腊2302883;腐2302884;腔2302885;腥2302886;腰2302887;腹2302888;腾2302889;腿2302890;膀2302891;膊2302892;膏2302893;膛2302894;膜2302895;膝2302896;膨2302897;臂2302898;臣2302899;自2302900;臭2302901;至2302902;致2302903;舅2302904;舌2302905;舍2302906;舒2302907;舞2302908;舟2302909;航2302910;般2302911;舰2302912;舱2302913;船2302914;艇2302915;艘2302916;良2302917;艰2302918;色2302919;艳2302920;艺2302921;节2302922;芒2302923;芝2302924;芦2302925;芬2302926;花2302927;芳2302928;芹2302929;芽2302930;苍2302931;苏2302932;苗2302933;若2302934;苦2302935;英2302936;苹2302937;茂2302938;范2302939;茄2302940;茅2302941;茎2302942;茧2302943;茫2302944;茶2302945;草2302946;荐2302947;荒2302948;荡2302949;荣2302950;药2302951;荷2302952;莫2302953;莲2302954;获2302955;菊2302956;菌2302957;菜2302958;菠2302959;萄2302960;萌2302961;萍2302962;萝2302963;营2302964;落2302965;著2302966;葛2302967;葡2302968;董2302969;葬2302970;葱2302971;葵2302972;蒙2302973;蒜2302974;蒸2302975;蓄2302976;蓝2302977;蓬2302978;蔑2302979;蔬2302980;蔽2302981;蕉2302982;薄2302983;薪2302984;薯2302985;藏2302986;虎2302987;虏2302988;虑2302989;虚2302990;虫2302991;虹2302992;虽2302993;虾2302994;蚀2302995;蚁2302996;蚂2302997;蚊2302998;蚕2302999;蛇2303000;蛋2303001;蛙2303002;蛛2303003;蛮2303004;蛾2303005;蜂2303006;蜒2303007;蜘2303008;蜜2303009;蜡2303010;蜻2303011;蝇2303012;蝴2303013;蝶2303014;融2303015;螺2303016;蠢2303017;血2303018;行2303019;衔2303020;街2303021;衡2303022;衣2303023;补2303024;表2303025;衫2303026;衬2303027;衰2303028;袄2303029;袋2303030;袍2303031;袖2303032;袜2303033;被2303034;袭2303035;裁2303036;裂2303037;装2303038;裕2303039;裙2303040;裤2303041;裳2303042;裹2303043;西2303044;要2303045;覆2303046;见2303047;观2303048;规2303049;视2303050;览2303051;觉2303052;角2303053;解2303054;触2303055;言2303056;誉2303057;誓2303058;警2303059;计2303060;订2303061;认2303062;讨2303063;让2303064;训2303065;议2303066;讯2303067;记2303068;讲2303069;许2303070;论2303071;讽2303072;设2303073;访2303074;证2303075;评2303076;识2303077;诉2303078;诊2303079;词2303080;译2303081;试2303082;诗2303083;诚2303084;话2303085;诞2303086;询2303087;该2303088;详2303089;语2303090;误2303091;诱2303092;说2303093;诵2303094;请2303095;诸2303096;读2303097;课2303098;谁2303099;调2303100;谅2303101;谈2303102;谊2303103;谋2303104;谎2303105;谜2303106;谢2303107;谣2303108;谦2303109;谨2303110;谱2303111;谷2303112;豆2303113;象2303114;豪2303115;貌2303116;贝2303117;贞2303118;负2303119;贡2303120;财2303121;责2303122;贤2303123;败2303124;货2303125;质2303126;贩2303127;贪2303128;贫2303129;购2303130;贯2303131;贱2303132;贴2303133;贵2303134;贷2303135;贸2303136;费2303137;贺2303138;贼2303139;贿2303140;资2303141;赌2303142;赏2303143;赔2303144;赖2303145;赚2303146;赛2303147;赞2303148;赠2303149;赢2303150;赤2303151;走2303152;赴2303153;赵2303154;赶2303155;起2303156;趁2303157;超2303158;越2303159;趋2303160;趟2303161;趣2303162;足2303163;趴2303164;跃2303165;跌2303166;跑2303167;距2303168;跟2303169;跨2303170;跪2303171;路2303172;跳2303173;践2303174;踏2303175;踢2303176;踩2303177;踪2303178;蹄2303179;蹈2303180;蹦2303181;蹲2303182;躁2303183;身2303184;躬2303185;躲2303186;躺2303187;车2303188;轧2303189;轨2303190;转2303191;轮2303192;软2303193;轰2303194;轻2303195;载2303196;轿2303197;较2303198;辅2303199;辆2303200;辈2303201;辉2303202;输2303203;辛2303204;辜2303205;辞2303206;辟2303207;辣2303208;辨2303209;辩2303210;辫2303211;辰2303212;辱2303213;边2303214;辽2303215;达2303216;迁2303217;迅2303218;过2303219;迈2303220;迎2303221;运2303222;近2303223;返2303224;还2303225;这2303226;进2303227;远2303228;违2303229;连2303230;迟2303231;迫2303232;述2303233;迷2303234;迹2303235;追2303236;退2303237;送2303238;适2303239;逃2303240;逆2303241;选2303242;透2303243;逐2303244;递2303245;途2303246;逗2303247;通2303248;逝2303249;速2303250;造2303251;逢2303252;逮2303253;逼2303254;遇2303255;遍2303256;道2303257;遗2303258;遣2303259;遥2303260;遭2303261;遮2303262;遵2303263;避2303264;邀2303265;那2303266;邪2303267;邮2303268;邻2303269;郁2303270;郊2303271;郎2303272;郑2303273;部2303274;都2303275;鄙2303276;配2303277;酒2303278;酬2303279;酱2303280;酷2303281;酸2303282;酿2303283;醉2303284;醋2303285;醒2303286;采2303287;释2303288;里2303289;重2303290;野2303291;量2303292;金2303293;鉴2303294;针2303295;钉2303296;钓2303297;钞2303298;钟2303299;钢2303300;钥2303301;钩2303302;钱2303303;钳2303304;钻2303305;铁2303306;铃2303307;铅2303308;铜2303309;铲2303310;银2303311;铸2303312;铺2303313;链2303314;销2303315;锁2303316;锄2303317;锅2303318;锈2303319;锋2303320;锐2303321;错2303322;锡2303323;锣2303324;锤2303325;锦2303326;键2303327;锯2303328;锹2303329;锻2303330;镇2303331;镜2303332;镰2303333;长2303334;门2303335;闪2303336;闭2303337;问2303338;闯2303339;闲2303340;间2303341;闷2303342;闸2303343;闹2303344;闻2303345;阀2303346;阁2303347;阅2303348;阔2303349;队2303350;防2303351;阳2303352;阴2303353;阵2303354;阶2303355;阻2303356;阿2303357;附2303358;际2303359;陆2303360;陈2303361;降2303362;限2303363;陕2303364;陡2303365;院2303366;除2303367;险2303368;陪2303369;陵2303370;陶2303371;陷2303372;隆2303373;随2303374;隐2303375;隔2303376;隙2303377;障2303378;隶2303379;难2303380;雀2303381;雁2303382;雄2303383;雅2303384;集2303385;雕2303386;雨2303387;雪2303388;零2303389;雷2303390;雹2303391;雾2303392;需2303393;震2303394;霉2303395;霜2303396;霞2303397;露2303398;霸2303399;青2303400;静2303401;非2303402;靠2303403;面2303404;革2303405;鞋2303406;鞠2303407;鞭2303408;音2303409;韵2303410;页2303411;顶2303412;顷2303413;项2303414;顺2303415;须2303416;顽2303417;顾2303418;顿2303419;颂2303420;预2303421;领2303422;颈2303423;颗2303424;题2303425;颜2303426;额2303427;颠2303428;风2303429;飘2303430;飞2303431;食2303432;餐2303433;饥2303434;饭2303435;饮2303436;饰2303437;饱2303438;饲2303439;饶2303440;饺2303441;饼2303442;饿2303443;馅2303444;馆2303445;馋2303446;馒2303447;首2303448;香2303449;马2303450;驰2303451;驱2303452;驳2303453;驴2303454;驶2303455;驻2303456;驼2303457;驾2303458;骂2303459;骄2303460;骆2303461;验2303462;骑2303463;骗2303464;骡2303465;骤2303466;骨2303467;高2303468;鬼2303469;魂2303470;魄2303471;魔2303472;鱼2303473;鲁2303474;鲜2303475;鸟2303476;鸡2303477;鸣2303478;鸦2303479;鸭2303480;鸽2303481;鹂2303482;鹅2303483;鹊2303484;鹰2303485;鹿2303486;麦2303487;麻2303488;黄2303489;黎2303490;黑2303491;默2303492;鼓2303493;鼠2303494;鼻2303495;齐2303496;齿2303497;龄2303498;龙2303499;龟2303500";

	private string 串模 = "{\r\n    '51人物': {\r\n        '爸': '2015003',\r\n        '宝': '2011003',\r\n        '宾': '2014001',\r\n        '兵': '2019003',\r\n        '伯': '2016001',\r\n        '臣': '',\r\n        '歹': '2019004',\r\n        '敌': '2017001',\r\n        '弟': '2012003',\r\n        '爹': '',\r\n        '儿': '2011001',\r\n        '匪': '',\r\n        '夫': '',\r\n        '俘': '',\r\n        '妇': '',\r\n        '傅': '',\r\n        '哥': '',\r\n        '姑': '',\r\n        '顾': '',\r\n        '官': '',\r\n        '冠': '',\r\n        '孩': '',\r\n        '皇': '',\r\n        '匠': '',\r\n        '姐': '',\r\n        '舅': '',\r\n        '君': '',\r\n        '客': '',\r\n        '姥': '',\r\n        '侣': '',\r\n        '妈': '',\r\n        '妹': '',\r\n        '们': '',\r\n        '盟': '',\r\n        '民': '',\r\n        '奶': '',\r\n        '你': '',\r\n        '娘': '',\r\n        '您': '',\r\n        '农': '',\r\n        '奴': '',\r\n        '朋': '',\r\n        '婆': '',\r\n        '仆': '',\r\n        '妻': '',\r\n        '戚': '',\r\n        '腔': '',\r\n        '侨': '',\r\n        '嫂': '',\r\n        '僧': '',\r\n        '婶': '',\r\n        '圣': '',\r\n        '师': '',\r\n        '士': '',\r\n        '叔': '',\r\n        '谁': '',\r\n        '孙': '',\r\n        '他': '',\r\n        '它': '',\r\n        '她': '',\r\n        '童': '',\r\n        '娃': '',\r\n        '王': '',\r\n        '卫': '',\r\n        '翁': '',\r\n        '我': '',\r\n        '仙': '',\r\n        '贤': '',\r\n        '兄': '',\r\n        '爷': '',\r\n        '姨': '',\r\n        '婴': '',\r\n        '佣': '',\r\n        '友': '',\r\n        '幼': '',\r\n        '员': '',\r\n        '孕': '',\r\n        '仔': '',\r\n        '咱': '',\r\n        '贼': '',\r\n        '侄': '',\r\n        '众': '',\r\n        '诸': '',\r\n        '族': '',\r\n        '祖': ''\r\n    },\r\n    '52动物': {\r\n        '蚕': '',\r\n        '虫': '',\r\n        '畜': '',\r\n        '蝶': '',\r\n        '鹅': '',\r\n        '蛾': '',\r\n        '蜂': '',\r\n        '凤': '',\r\n        '鸽': '',\r\n        '狗': '',\r\n        '龟': '',\r\n        '猴': '',\r\n        '狐': '',\r\n        '蝴': '',\r\n        '虎': '',\r\n        '鸡': '',\r\n        '菌': '',\r\n        '狼': '',\r\n        '龙': '',\r\n        '鹿': '',\r\n        '骡': '',\r\n        '螺': '',\r\n        '骆': '',\r\n        '驴': '',\r\n        '马': '',\r\n        '蚂': '',\r\n        '猫': '',\r\n        '蜜': '',\r\n        '鸟': '',\r\n        '牛': '',\r\n        '禽': '',\r\n        '蜻': '',\r\n        '犬': '',\r\n        '雀': '',\r\n        '鹊': '',\r\n        '蛇': '',\r\n        '狮': '',\r\n        '兔': '',\r\n        '蛙': '',\r\n        '蚊': '',\r\n        '乌': '',\r\n        '虾': '',\r\n        '象': '',\r\n        '猩': '',\r\n        '熊': '',\r\n        '鸦': '',\r\n        '鸭': '',\r\n        '雁': '',\r\n        '燕': '',\r\n        '羊': '',\r\n        '蚁': '',\r\n        '鹰': '',\r\n        '蝇': '',\r\n        '鱼': '',\r\n        '猿': '',\r\n        '蜘': '',\r\n        '猪': ''\r\n    },\r\n    '53植物': {\r\n        '柏': '',\r\n        '瓣': '',\r\n        '草': '',\r\n        '稻': '',\r\n        '禾': '',\r\n        '荷': '',\r\n        '花': '',\r\n        '槐': '',\r\n        '稼': '',\r\n        '菊': '',\r\n        '葵': '',\r\n        '兰': '',\r\n        '莲': '',\r\n        '柳': '',\r\n        '萝': '',\r\n        '梅': '',\r\n        '棉': '',\r\n        '苗': '',\r\n        '蓬': '',\r\n        '树': '',\r\n        '杨': '',\r\n        '椰': '',\r\n        '叶': '',\r\n        '榆': '',\r\n        '芝': '',\r\n        '植': '',\r\n        '竹': ''\r\n    },\r\n    '武器': {\r\n        '棒': '',\r\n        '匕': '',\r\n        '鞭': '',\r\n        '锤': '',\r\n        '刀': '',\r\n        '盾': '',\r\n        '斧': '',\r\n        '弓': '',\r\n        '钩': '',\r\n        '剑': '',\r\n        '舰': '',\r\n        '箭': '',\r\n        '矛': '',\r\n        '枪': '',\r\n        '刃': ''\r\n    },\r\n    '乐器': {\r\n        '笛': '',\r\n        '鼓': '',\r\n        '喇': '',\r\n        '锣': '',\r\n        '琴': '',\r\n        '箫': ''\r\n    },\r\n    '日用': {\r\n        '包': '',\r\n        '布': '',\r\n        '灯': '',\r\n        '凳': '',\r\n        '膏': '',\r\n        '壶': '',\r\n        '机': '',\r\n        '剂': '',\r\n        '巾': '',\r\n        '镜': '',\r\n        '具': '',\r\n        '卡': '',\r\n        '裤': '',\r\n        '筷': '',\r\n        '垃': '',\r\n        '蜡': '',\r\n        '历': '',\r\n        '帽': '',\r\n        '膜': '',\r\n        '墨': '',\r\n        '袍': '',\r\n        '瓶': '',\r\n        '器': '',\r\n        '券': '',\r\n        '容': '',\r\n        '伞': '',\r\n        '扫': '',\r\n        '扇': '',\r\n        '书': '',\r\n        '梳': '',\r\n        '梯': '',\r\n        '帖': '',\r\n        '图': '',\r\n        '袜': '',\r\n        '鞋': '',\r\n        '钥': '',\r\n        '皂': '',\r\n        '针': '',\r\n        '枕': '',\r\n        '钟': ''\r\n    },\r\n    '交通': {\r\n        '巴': '',\r\n        '车': '',\r\n        '船': '',\r\n        '渡': '',\r\n        '轿': '',\r\n        '摩': '',\r\n        '桥': '',\r\n        '艇': '',\r\n        '舟': ''\r\n    },\r\n    '家私': {\r\n        '壁': '',\r\n        '床': '',\r\n        '柜': '',\r\n        '帘': '',\r\n        '炉': '',\r\n        '椅': '',\r\n        '桌': ''\r\n    },\r\n    '家装': {\r\n        '窗': '',\r\n        '阶': '',\r\n        '炕': '',\r\n        '梁': '',\r\n        '门': '',\r\n        '墙': '',\r\n        '灶': ''\r\n    },\r\n    '餐具': {\r\n        '杯': '',\r\n        '叉': '',\r\n        '锅': '',\r\n        '盆': '',\r\n        '勺': '',\r\n        '匙': '',\r\n        '碗': ''\r\n    },\r\n    '食物': {\r\n        '饼': '',\r\n        '菠': '',\r\n        '菜': '',\r\n        '茶': '',\r\n        '橙': '',\r\n        '葱': '',\r\n        '醋': '',\r\n        '蛋': '',\r\n        '豆': '',\r\n        '饭': '',\r\n        '糕': '',\r\n        '瓜': '',\r\n        '果': '',\r\n        '姜': '',\r\n        '酱': '',\r\n        '椒': '',\r\n        '蕉': '',\r\n        '饺': '',\r\n        '酒': '',\r\n        '橘': '',\r\n        '糠': '',\r\n        '腊': '',\r\n        '梨': '',\r\n        '李': '',\r\n        '粮': '',\r\n        '粱': '',\r\n        '料': '',\r\n        '榴': '',\r\n        '麦': '',\r\n        '馒': '',\r\n        '芒': '',\r\n        '米': '',\r\n        '面': '',\r\n        '苹': '',\r\n        '葡': '',\r\n        '茄': '',\r\n        '芹': '',\r\n        '肉': '',\r\n        '乳': '',\r\n        '食': '',\r\n        '柿': '',\r\n        '蔬': '',\r\n        '薯': '',\r\n        '蒜': '',\r\n        '笋': '',\r\n        '汤': '',\r\n        '糖': '',\r\n        '桃': '',\r\n        '丸': '',\r\n        '宵': '',\r\n        '杏': '',\r\n        '盐': '',\r\n        '糟': '',\r\n        '枣': '',\r\n        '粥': ''\r\n    },\r\n    '办公': {\r\n        '笔': '',\r\n        '杠': '',\r\n        '稿': '',\r\n        '胶': '',\r\n        '锦': '',\r\n        '铅': '',\r\n        '页': '',\r\n        '帐': '',\r\n        '证': '',\r\n        '纸': ''\r\n    },\r\n    '材料': {\r\n        '板': '',\r\n        '玻': '',\r\n        '材': '',\r\n        '绸': '',\r\n        '钢': '',\r\n        '浆': '',\r\n        '晶': '',\r\n        '绢': '',\r\n        '壳': '',\r\n        '绵': '',\r\n        '水': '',\r\n        '铁': '',\r\n        '铜': '',\r\n        '土': '',\r\n        '弦': '',\r\n        '线': '',\r\n        '械': '',\r\n        '银': '',\r\n        '玉': '',\r\n        '脂': ''\r\n    },\r\n    '道具': {\r\n        '碍': '',\r\n        '泵': '',\r\n        '匾': '',\r\n        '槽': '',\r\n        '柴': '',\r\n        '铲': '',\r\n        '锄': '',\r\n        '瓷': '',\r\n        '袋': '',\r\n        '丹': '',\r\n        '碟': '',\r\n        '鼎': '',\r\n        '钉': '',\r\n        '毒': '',\r\n        '阀': '',\r\n        '粪': '',\r\n        '佛': '',\r\n        '竿': '',\r\n        '杆': '',\r\n        '缸': '',\r\n        '卦': '',\r\n        '罐': '',\r\n        '棍': '',\r\n        '盒': '',\r\n        '货': '',\r\n        '桨': '',\r\n        '金': '',\r\n        '锯': '',\r\n        '刊': '',\r\n        '筐': '',\r\n        '矿': '',\r\n        '盔': '',\r\n        '篮': '',\r\n        '镰': '',\r\n        '铃': '',\r\n        '笼': '',\r\n        '轮': '',\r\n        '箩': '',\r\n        '漫': '',\r\n        '煤': '',\r\n        '木': '',\r\n        '幕': '',\r\n        '泥': '',\r\n        '尿': '',\r\n        '牌': '',\r\n        '盘': '',\r\n        '谱': '',\r\n        '漆': '',\r\n        '旗': '',\r\n        '气': '',\r\n        '钳': '',\r\n        '锹': '',\r\n        '球': '',\r\n        '泉': '',\r\n        '壤': '',\r\n        '沙': '',\r\n        '绳': '',\r\n        '石': '',\r\n        '实': '',\r\n        '饰': '',\r\n        '丝': '',\r\n        '毯': '',\r\n        '炭': '',\r\n        '陶': '',\r\n        '筒': '',\r\n        '匣': '',\r\n        '纤': '',\r\n        '箱': '',\r\n        '橡': '',\r\n        '星': '',\r\n        '烟': '',\r\n        '岩': '',\r\n        '药': '',\r\n        '云': '',\r\n        '赃': '',\r\n        '闸': '',\r\n        '筝': '',\r\n        '珠': '',\r\n        '烛': '',\r\n        '柱': '',\r\n        '砖': '',\r\n        '钻': ''\r\n    },\r\n    '场景': {\r\n        '岸': '',\r\n        '坝': '',\r\n        '吧': '',\r\n        '班': '',\r\n        '堡': '',\r\n        '滨': '',\r\n        '餐': '',\r\n        '舱': '',\r\n        '厕': '',\r\n        '岔': '',\r\n        '厂': '',\r\n        '潮': '',\r\n        '城': '',\r\n        '池': '',\r\n        '厨': '',\r\n        '楚': '',\r\n        '川': '',\r\n        '丛': '',\r\n        '村': '',\r\n        '岛': '',\r\n        '道': '',\r\n        '堤': '',\r\n        '地': '',\r\n        '店': '',\r\n        '殿': '',\r\n        '碉': '',\r\n        '洞': '',\r\n        '坊': '',\r\n        '房': '',\r\n        '坟': '',\r\n        '峰': '',\r\n        '府': '',\r\n        '冈': '',\r\n        '港': '',\r\n        '阁': '',\r\n        '古': '',\r\n        '谷': '',\r\n        '馆': '',\r\n        '海': '',\r\n        '浩': '',\r\n        '河': '',\r\n        '虹': '',\r\n        '湖': '',\r\n        '荒': '',\r\n        '婚': '',\r\n        '江': '',\r\n        '疆': '',\r\n        '郊': '',\r\n        '街': '',\r\n        '京': '',\r\n        '阱': '',\r\n        '景': '',\r\n        '境': '',\r\n        '俱': '',\r\n        '凯': '',\r\n        '坑': '',\r\n        '旷': '',\r\n        '昆': '',\r\n        '廊': '',\r\n        '浪': '',\r\n        '牢': '',\r\n        '黎': '',\r\n        '林': '',\r\n        '岭': '',\r\n        '陆': '',\r\n        '路': '',\r\n        '茅': '',\r\n        '庙': '',\r\n        '漠': '',\r\n        '牧': '',\r\n        '墓': '',\r\n        '欧': '',\r\n        '棚': '',\r\n        '坡': '',\r\n        '瀑': '',\r\n        '秦': '',\r\n        '丘': '',\r\n        '渠': '',\r\n        '森': '',\r\n        '厦': '',\r\n        '山': '',\r\n        '世': '',\r\n        '市': '',\r\n        '室': '',\r\n        '寺': '',\r\n        '宋': '',\r\n        '塔': '',\r\n        '台': '',\r\n        '滩': '',\r\n        '唐': '',\r\n        '堂': '',\r\n        '塘': '',\r\n        '天': '',\r\n        '田': '',\r\n        '厅': '',\r\n        '亭': '',\r\n        '途': '',\r\n        '湾': '',\r\n        '窝': '',\r\n        '屋': '',\r\n        '溪': '',\r\n        '峡': '',\r\n        '县': '',\r\n        '乡': '',\r\n        '巷': '',\r\n        '校': '',\r\n        '宿': '',\r\n        '穴': '',\r\n        '崖': '',\r\n        '亚': '',\r\n        '沿': '',\r\n        '宴': '',\r\n        '洋': '',\r\n        '窑': '',\r\n        '野': '',\r\n        '夜': '',\r\n        '役': '',\r\n        '屿': '',\r\n        '宇': '',\r\n        '狱': '',\r\n        '域': '',\r\n        '寓': '',\r\n        '园': '',\r\n        '院': '',\r\n        '灾': '',\r\n        '宅': '',\r\n        '寨': '',\r\n        '战': '',\r\n        '洲': '',\r\n        '庄': ''\r\n    },\r\n    '器官': {\r\n        '鼻': '',\r\n        '臂': '',\r\n        '脖': '',\r\n        '肠': '',\r\n        '翅': '',\r\n        '唇': '',\r\n        '胆': '',\r\n        '肚': '',\r\n        '额': '',\r\n        '耳': '',\r\n        '肺': '',\r\n        '肤': '',\r\n        '腹': '',\r\n        '肝': '',\r\n        '胳': '',\r\n        '骨': '',\r\n        '喉': '',\r\n        '肌': '',\r\n        '脊': '',\r\n        '肩': '',\r\n        '脚': '',\r\n        '筋': '',\r\n        '颈': '',\r\n        '口': '',\r\n        '脸': '',\r\n        '脉': '',\r\n        '毛': '',\r\n        '眉': '',\r\n        '脑': '',\r\n        '膀': '',\r\n        '皮': '',\r\n        '脾': '',\r\n        '拳': '',\r\n        '嗓': '',\r\n        '舌': '',\r\n        '身': '',\r\n        '肾': '',\r\n        '手': '',\r\n        '蹄': '',\r\n        '头': '',\r\n        '腿': '',\r\n        '胃': '',\r\n        '膝': '',\r\n        '心': '',\r\n        '胸': '',\r\n        '牙': '',\r\n        '眼': '',\r\n        '腰': '',\r\n        '羽': '',\r\n        '掌': '',\r\n        '爪': '',\r\n        '肢': '',\r\n        '足': '',\r\n        '嘴': ''\r\n    }\r\n}";

	private void Start()
	{
	}

	private void Update()
	{
		是否准心();
		if ((是否下载模型 || 是否下载特效) && Manager._instance.Vr2045.全局是下载完成)
		{
			是否下载模型 = false;
			if (是否下载特效)
			{
				作用物类型 = "特效";
				重置大小("尺");
				是否下载特效 = false;
				当前物.Clear();
				当前物.Add(Manager._instance.Down.当前选择);
			}
			else
			{
				作用物类型 = "模型";
				Manager._instance.Down.当前选择.name = 模型名;
				if (是否下载字)
				{
					Manager._instance.Down.当前选择.transform.localScale = new Vector3(10f, 10f, 10f);
					Manager._instance.Down.当前选择.transform.rotation = Quaternion.Euler(0f, 180f, 0f);
					是否下载字 = false;
					int length = 串字.Length;
					float x = (float)(字串长度 - length) * 0.4f + 第一字x;
					Manager._instance.Down.当前选择.transform.position = new Vector3(x, 中心前位置.transform.position.y, 中心前位置.transform.position.z);
					字集.Add(Manager._instance.Down.当前选择);
					if (是否连着下载)
					{
						if (length >= 2)
						{
							字(串字.Substring(1));
						}
						else
						{
							是否串下一 = true;
							是否连着下载 = false;
						}
						当前物.Add(Manager._instance.Down.当前选择);
					}
					else
					{
						是否串下一 = true;
						当前物.Clear();
						当前物.Add(Manager._instance.Down.当前选择);
					}
				}
				else
				{
					当前物.Clear();
					当前物.Add(Manager._instance.Down.当前选择);
				}
			}
			Manager._instance.Vr2045.全局是下载完成 = false;
		}
		移动();
		缓动();
		点击是否();
	}

	private void 移动()
	{
		if (是否移动)
		{
			Manager._instance.Down.当前选择.transform.position = Vector3.MoveTowards(Manager._instance.Down.当前选择.transform.position, 目标.transform.position, Time.deltaTime * 移动速度);
			if (Vector3.Distance(Manager._instance.Down.当前选择.transform.position, 目标.transform.position) <= 距长)
			{
				是否移动 = false;
				Manager._instance.Down.当前选择.transform.position = 目标.transform.position;
				目标 = null;
			}
		}
	}

	private void 缓动()
	{
		if (!是否缓动)
		{
			return;
		}
		for (int i = 0; i < 缓目标.Count; i++)
		{
			if (!(目标函[i] == "摄"))
			{
				continue;
			}
			Camera component = 缓目标[i].GetComponent<Camera>();
			if (缓属性[i] == "色" && 缓目的[i] == "红")
			{
				component.backgroundColor = Color.Lerp(component.backgroundColor, Color.red, Time.deltaTime * 缓动速度[i]);
				if (component.backgroundColor == Color.red)
				{
					目标函.RemoveAt(i);
					缓目标.RemoveAt(i);
					缓属性.RemoveAt(i);
					缓动速度.RemoveAt(i);
					缓目的.RemoveAt(i);
				}
			}
			if (!(缓属性[i] == "视"))
			{
				continue;
			}
			float result = 0f;
			if (float.TryParse(缓目的[i], out result))
			{
				component.fieldOfView = Mathf.Lerp(component.fieldOfView, 45f, Time.deltaTime * 缓动速度[i]);
				if (component.fieldOfView - 45f <= 0.01f)
				{
					目标函.RemoveAt(i);
					缓目标.RemoveAt(i);
					缓属性.RemoveAt(i);
					缓动速度.RemoveAt(i);
					缓目的.RemoveAt(i);
				}
			}
		}
		if (缓目标.Count == 0)
		{
			是否缓动 = false;
		}
	}

	private void 是否准心()
	{
		if (!是否跟准心)
		{
			return;
		}
		时间 += Time.deltaTime;
		if (!(时间 >= 1f))
		{
			return;
		}
		时间 = 0f;
		GameObject gameObject = GameObject.Find("Head");
		if (gameObject != null && gameObject.transform.parent.name == "CardboardMain")
		{
			是否跟准心 = false;
			for (int i = 0; i < 跟准心物集.Count; i++)
			{
				跟准心物集[i].transform.parent = gameObject.transform;
			}
			跟准心物集.RemoveRange(0, 跟准心物集.Count);
		}
	}

	private void 重置大小(string 参数)
	{
		if (模型名.IndexOf(参数) != -1)
		{
			GameObject 当前选择 = Manager._instance.Down.当前选择;
			if (当前选择.GetComponent<ParticleSystem>() != null || 当前选择.GetComponentInChildren<ParticleSystem>() != null)
			{
				ParticleSystem[] componentsInChildren = 当前选择.GetComponentsInChildren<ParticleSystem>();
				int num = 1;
				string text = 模型名.Substring(模型名.IndexOf(参数) + num, 1);
				if (模型名.IndexOf(参数) + num + 1 < 模型名.Length && !Regex.IsMatch(模型名.Substring(模型名.IndexOf(参数) + num + 1, 1), "^[a-zA-Z]"))
				{
					num++;
					text += 模型名.Substring(模型名.IndexOf(参数) + num, 1);
					if (模型名.IndexOf(参数) + num + 1 < 模型名.Length && !Regex.IsMatch(模型名.Substring(模型名.IndexOf(参数) + num + 1, 1), "^[a-zA-Z]"))
					{
						num++;
						text += 模型名.Substring(模型名.IndexOf(参数) + num, 1);
					}
				}
				float num2 = float.Parse(text) / componentsInChildren[0].startSize;
				for (int i = 0; i < componentsInChildren.Length; i++)
				{
					componentsInChildren[i].startSize = componentsInChildren[i].startSize * num2;
				}
			}
			Manager._instance.Down.当前选择.name = 模型名.Substring(0, 7);
		}
		else
		{
			Manager._instance.Down.当前选择.name = 模型名;
		}
	}

	public IEnumerator 摄近(string 参数)
	{
		Camera 摄0 = Camera.main;
		while (true)
		{
			摄0.fieldOfView = Mathf.Lerp(摄0.fieldOfView, float.Parse(参数), Time.deltaTime * 10f);
			if ((摄0.fieldOfView >= float.Parse(参数) && 摄0.fieldOfView - float.Parse(参数) <= 0.01f) || (摄0.fieldOfView <= float.Parse(参数) && float.Parse(参数) - 摄0.fieldOfView <= 0.01f))
			{
				break;
			}
			yield return new WaitForSeconds(0.01f);
		}
		yield return new WaitForSeconds(0f);
	}

	public IEnumerator 摄色(string 参数)
	{
		Camera 摄1 = Camera.main;
		while (true)
		{
			if (参数 == "红")
			{
				摄1.backgroundColor = Color.Lerp(摄1.backgroundColor, Color.red, Time.deltaTime * 10f);
				if (摄1.backgroundColor == Color.red)
				{
					break;
				}
			}
			yield return new WaitForSeconds(0.01f);
		}
		yield return new WaitForSeconds(0f);
	}

	public IEnumerator 物快(string 参数)
	{
		GameObject 物1 = GameObject.Find(参数);
		float 初速 = 0f;
		if (物1 != null && 物1.GetComponent<self_rot>() != null)
		{
			初速 = 物1.GetComponent<self_rot>().速度;
			物1.GetComponent<self_rot>().速度 = 物1.GetComponent<self_rot>().速度 + 50f;
		}
		yield return new WaitForSeconds(3f);
		if (物1.GetComponent<self_rot>() != null)
		{
			物1.GetComponent<self_rot>().速度 = 初速;
		}
	}

	public static void 重新开始游戏()
	{
		SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex);
	}

	private void 下关游戏(string 参数)
	{
		int num = (参数.Length - 参数.Replace("与", "").Length) / "与".Length;
		int num2 = 0;
		for (int i = 0; i < num + 1; i++)
		{
			int num3 = 参数.IndexOf("与", num2);
			string text = "";
			text = ((num3 < 0) ? 参数.Substring(num2) : 参数.Substring(num2, num3 - num2));
			UnityEngine.Debug.Log(text);
			num2 = num3 + 1;
			int num4 = text.IndexOf("之");
			if (num4 >= 0)
			{
				GameObject gameObject = GameObject.Find(text.Substring(num4 + 1));
				int num5 = text.IndexOf("值");
				if (text.Substring(num5 + 1, 1) == "等")
				{
					float value = float.Parse(取轴数(text, "等"));
					if (text.Substring(0, 1) == "条")
					{
						if (gameObject != null)
						{
							gameObject.GetComponent<Slider>().value = value;
						}
					}
					else if (text.Substring(0, 1) == "文" && gameObject != null)
					{
						gameObject.GetComponent<Text>().text = value.ToString();
					}
				}
				else
				{
					if (!(text.Substring(num5 + 1, 1) == "加"))
					{
						continue;
					}
					float num6 = float.Parse(取轴数(text, "加"));
					if (text.Substring(0, 1) == "条")
					{
						if (gameObject != null)
						{
							gameObject.GetComponent<Slider>().value = gameObject.GetComponent<Slider>().value + num6;
						}
					}
					else if (text.Substring(0, 1) == "文" && gameObject != null)
					{
						gameObject.GetComponent<Text>().text = (float.Parse(gameObject.GetComponent<Text>().text) + num6).ToString();
					}
				}
			}
			else if (text.Substring(0, 1) == "俺" && text.Substring(1, 1) == "隐")
			{
				Manager._instance.Down.当前选择.active = false;
			}
		}
	}

	public void 点击是否()
	{
		if (点击否)
		{
			点击否时 += Time.deltaTime;
			if (点击否时 >= 0.5f)
			{
				点击否时 = 0f;
				点击否 = false;
			}
		}
	}

	public void 判图分(GameObject 参数, string 参数分)
	{
		if (!(参数.GetComponent<Image>() != null) || !(参数.GetComponent<Image>().sprite != null))
		{
			return;
		}
		int num = 参数分.IndexOf('文');
		GameObject gameObject = GameObject.Find(参数分.Substring(0, num));
		if (gameObject != null)
		{
			string text = gameObject.GetComponent<Text>().text;
			int num2 = int.Parse(参数分.Substring(num + 2));
			if (参数分.Substring(num + 1, 1) == "加")
			{
				if (text != "" && text != null)
				{
					gameObject.GetComponent<Text>().text = (float.Parse(text) + (float)num2).ToString();
				}
				else
				{
					gameObject.GetComponent<Text>().text = num2.ToString();
				}
			}
			else if (参数分.Substring(num + 1, 1) == "减")
			{
				if (text != "" && text != null)
				{
					gameObject.GetComponent<Text>().text = (float.Parse(text) - (float)num2).ToString();
				}
				else
				{
					gameObject.GetComponent<Text>().text = num2.ToString();
				}
			}
		}
		点击否 = true;
		参数.GetComponent<Image>().color = new Color(1f, 1f, 1f, 0f);
		参数.GetComponent<Image>().sprite = null;
	}

	public void 判图分2(GameObject 参数, string 参数分)
	{
		if (!(参数.GetComponent<Image>() != null) || !(参数.GetComponent<Image>().sprite == null) || 点击否)
		{
			return;
		}
		int num = 参数分.IndexOf('文');
		GameObject gameObject = GameObject.Find(参数分.Substring(0, num));
		if (!(gameObject != null))
		{
			return;
		}
		string text = gameObject.GetComponent<Text>().text;
		int num2 = int.Parse(参数分.Substring(num + 2));
		if (参数分.Substring(num + 1, 1) == "加")
		{
			if (text != "" && text != null)
			{
				gameObject.GetComponent<Text>().text = (float.Parse(text) + (float)num2).ToString();
			}
			else
			{
				gameObject.GetComponent<Text>().text = num2.ToString();
			}
		}
		else if (参数分.Substring(num + 1, 1) == "减")
		{
			if (text != "" && text != null)
			{
				gameObject.GetComponent<Text>().text = (float.Parse(text) - (float)num2).ToString();
			}
			else
			{
				gameObject.GetComponent<Text>().text = "-" + num2;
			}
		}
	}

	private Color 判色(string 参数, string 源参, int 位几)
	{
		Color result = default(Color);
		if (参数 == "#")
		{
			result = ColorRevert.ToColor(源参.Substring(位几, 7));
			float r = result.r / 255f;
			float g = result.g / 255f;
			float b = result.b / 255f;
			result = new Color(r, g, b);
		}
		else if (参数 == "绿")
		{
			result = Color.green;
		}
		return result;
	}

	public string 典(string 参数)
	{
		if (参数.Substring(0, 4) == "虚物随之")
		{
			string[] array = 参数.Split('与');
			int max = array.Length + 1;
			int num = UnityEngine.Random.RandomRange(0, max);
			string text = ((num != 0) ? array[num] : array[num].Split('之')[1]);
			Manager._instance.Down.在数字后添加判断符(text.Substring(0));
			string[] array2 = Manager._instance.Down.在数字后添加判断符(text.Substring(0)).Split(new char[1] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
			foreach (string 参数2 in array2)
			{
				Manager._instance.Down.典虚物.Add(Manager._instance.Vr2045.判中文(参数2), float.Parse(Manager._instance.Vr2045.判数字(参数2)));
			}
		}
		return "典完";
	}

	public string 如(string 参数)
	{
		if (参数.Substring(0, 1) == "射" && 参数.IndexOf("之") != -1)
		{
			string[] array = 参数.Split('之');
			GameObject gameObject = GameObject.Find(array[0].Substring(1));
			Ray ray = new Ray(gameObject.transform.position, gameObject.transform.forward);
			if (array[1].Substring(0, 1) == "名")
			{
				if (Physics.Raycast(ray, out hit, 100f) && !(hit.transform.name == array[1].Substring(1)))
				{
				}
			}
			else if (array[1].Substring(0, 1) == "标" && Physics.Raycast(ray, out hit, 100f))
			{
				_ = hit.transform.tag == array[1].Substring(1);
			}
		}
		return "如完";
	}

	public string 随(string 参数)
	{
		if (Manager._instance.Down.当前选择 != null)
		{
			string[] array = 参数.Split('与');
			float x = UnityEngine.Random.RandomRange(float.Parse(array[0].Split('和')[0]), float.Parse(array[0].Split('和')[1]));
			float y = UnityEngine.Random.RandomRange(float.Parse(array[1].Split('和')[0]), float.Parse(array[1].Split('和')[1]));
			float z = UnityEngine.Random.RandomRange(float.Parse(array[2].Split('和')[0]), float.Parse(array[2].Split('和')[1]));
			Manager._instance.Down.当前选择.transform.position = new Vector3(x, y, z);
		}
		return "放完";
	}

	public string 跟(string 参数)
	{
		if (参数 == "5")
		{
			是否跟准心 = true;
			跟准心物集.Add(Manager._instance.Down.当前选择);
		}
		return "跟完";
	}

	public string 在(string 参数)
	{
		if (参数 == "5")
		{
			GameObject gameObject = GameObject.Find("Head");
			if (gameObject != null)
			{
				Manager._instance.Down.当前选择.transform.parent = gameObject.transform;
				Manager._instance.Down.当前选择.transform.localPosition = new Vector3(0f, 0f, 0f);
			}
		}
		MonoBehaviour.print("在5完");
		return "";
	}

	public string 夹(string 参数)
	{
		if (参数.Substring(0, 2) == "长之")
		{
			_ = GameObject.Find(参数.Substring(2)) != null;
		}
		return "";
	}

	public string 孩(string 参数)
	{
		if (参数.Substring(0, 1) == "变")
		{
			GameObject 当前选择 = Manager._instance.Down.当前选择;
			int childCount = 当前选择.transform.childCount;
			for (int i = 0; i < childCount; i++)
			{
				Manager._instance.Down.在数字后添加判断符(参数.Substring(1));
				string[] array = Manager._instance.Down.在数字后添加判断符(参数.Substring(1)).Split(new char[1] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
				foreach (string 参数2 in array)
				{
					Manager._instance.Down.典虚物.Add(Manager._instance.Vr2045.判中文(参数2), float.Parse(Manager._instance.Vr2045.判数字(参数2)));
				}
				GameObject gameObject = new GameObject();
				gameObject.name = Manager._instance.Down.当前选择.name + "集";
				Manager._instance.Down.当前选择.transform.parent = gameObject.transform;
				Manager._instance.Down.当前选择.transform.position = 当前选择.transform.GetChild(i).position;
			}
			for (int k = 0; k < childCount; k++)
			{
				UnityEngine.Object.Destroy(当前选择.transform.GetChild(k).gameObject);
			}
		}
		else if (参数.Substring(0, 1) == "随")
		{
			if (参数.Substring(1, 1) == "图" && 参数.Substring(2, 1) == "源")
			{
				string[] array2 = 参数.Substring(2).Split('之');
				Sprite 图 = Resources.Load("PNG/界面图/" + array2[1], typeof(Sprite)) as Sprite;
				GameObject obj = new GameObject();
				obj.name = "孩随";
				obj.AddComponent<sui_show>();
				obj.GetComponent<sui_show>().图 = 图;
				obj.GetComponent<sui_show>().父 = Manager._instance.Down.当前选择;
				int num = array2[0].IndexOf("停");
				float 隔时 = float.Parse(array2[0].Substring(num + 1));
				obj.GetComponent<sui_show>().隔时 = 隔时;
				obj.GetComponent<sui_show>().是否开始 = true;
			}
		}
		else if (参数.Substring(0, 1) == "钮")
		{
			if (参数.Substring(1, 1) == "侦" && 参数.Substring(2, 1) == "点")
			{
				string text = 参数.Substring(3);
				if (text.Substring(0, 1) == "事")
				{
					GameObject 当前选择2 = Manager._instance.Down.当前选择;
					int childCount2 = 当前选择2.transform.childCount;
					int num2 = text.IndexOf('后');
					if (num2 >= 0)
					{
						string 参3 = text.Substring(num2 + 1);
						if (text.Substring(1, 2) == "图实")
						{
							for (int l = 0; l < childCount2; l++)
							{
								GameObject 物4 = 当前选择2.transform.GetChild(l).gameObject;
								if (物4.GetComponent<UnityEngine.UI.Button>() != null)
								{
									物4.GetComponent<UnityEngine.UI.Button>().onClick.AddListener(delegate
									{
										判图分(物4, 参3);
									});
								}
							}
						}
						else if (text.Substring(1, 2) == "图空")
						{
							for (int m = 0; m < childCount2; m++)
							{
								GameObject 物3 = 当前选择2.transform.GetChild(m).gameObject;
								if (物3.GetComponent<UnityEngine.UI.Button>() != null)
								{
									物3.GetComponent<UnityEngine.UI.Button>().onClick.AddListener(delegate
									{
										判图分2(物3, 参3);
									});
								}
							}
						}
					}
					else if (text.Substring(1, 2) == "换位")
					{
						xiaoxiao component = 当前选择2.GetComponent<xiaoxiao>();
						if (component != null)
						{
							component.是否按 = true;
						}
					}
				}
			}
		}
		else if (参数 == "")
		{
			string text2 = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
			人单令(text2);
			return text2 + "完";
		}
		return "";
	}

	public string 变(string 参数)
	{
		GameObject 当前选择 = Manager._instance.Down.当前选择;
		Manager._instance.Down.在数字后添加判断符(参数.Substring(1));
		string[] array = Manager._instance.Down.在数字后添加判断符(参数.Substring(1)).Split(new char[1] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
		foreach (string 参数2 in array)
		{
			Manager._instance.Down.典虚物.Add(Manager._instance.Vr2045.判中文(参数2), float.Parse(Manager._instance.Vr2045.判数字(参数2)));
		}
		if (GameObject.Find(Manager._instance.Down.当前选择.name + "集") != null)
		{
			Manager._instance.Down.当前选择.transform.parent = GameObject.Find(Manager._instance.Down.当前选择.name + "集").transform;
			Manager._instance.Down.当前选择.transform.position = 当前选择.transform.position;
		}
		else
		{
			GameObject gameObject = new GameObject();
			gameObject.name = Manager._instance.Down.当前选择.name + "集";
			Manager._instance.Down.当前选择.transform.parent = gameObject.transform;
			Manager._instance.Down.当前选择.transform.position = 当前选择.transform.position;
		}
		UnityEngine.Object.Destroy(当前选择);
		return "";
	}

	public string 隐(string 参数)
	{
		if (参数 == "场")
		{
			Manager._instance.Vr2045.隐藏();
		}
		else if (GameObject.Find(参数) != null)
		{
			GameObject.Find(参数).active = false;
		}
		return "";
	}

	public string 显(string 参数)
	{
		if (GameObject.Find(参数) != null)
		{
			GameObject.Find(参数).active = true;
		}
		return "";
	}

	public string 附(string 参数)
	{
		if (参数.Substring(0, 3) == "跟随之")
		{
			Manager._instance.Down.当前选择.AddComponent<FollowMovement2>();
			GameObject gameObject = GameObject.Find(参数.Substring(3));
			if (gameObject != null)
			{
				Manager._instance.Down.当前选择.GetComponent<FollowMovement2>().TargetTF = gameObject.transform;
			}
		}
		if (!(参数 == "圈碰撞体2"))
		{
			if (参数 == "刚体2")
			{
				Manager._instance.Down.当前选择.AddComponent<Rigidbody2D>();
				Manager._instance.Down.当前选择.GetComponent<Rigidbody2D>().gravityScale = 0f;
			}
		}
		else
		{
			Manager._instance.Down.当前选择.AddComponent<CircleCollider2D>();
			Manager._instance.Down.当前选择.GetComponent<CircleCollider2D>().isTrigger = true;
			Manager._instance.Down.当前选择.AddComponent<Rigidbody2D>();
			Manager._instance.Down.当前选择.GetComponent<Rigidbody2D>().gravityScale = 0f;
		}
		return "附完";
	}

	public string 几(string 参数)
	{
		if (参数.IndexOf("之") != -1)
		{
			string[] array = 参数.Split('之');
			int num = 0;
			if (array[1] != null && array[1] != "")
			{
				do
				{
					GameObject.Find(array[1]).name += "2";
					num++;
				}
				while (GameObject.Find(array[1]) != null);
			}
			if (Manager._instance.JieMian.文几字典.ContainsKey(array[0]))
			{
				Manager._instance.JieMian.文几字典[array[0]] = num;
			}
			else
			{
				Manager._instance.JieMian.文几字典.Add(array[0], num);
			}
		}
		return "完";
	}

	public string 名(string 参数)
	{
		if (参数.Substring(0, 1) == "改")
		{
			GameObject 当前选择 = Manager._instance.Down.当前选择;
			if (当前选择 != null)
			{
				当前选择.transform.name = 参数.Substring(1);
			}
		}
		return "名完";
	}

	public string 位(string 参数)
	{
		if (参数.Substring(0, 1) == "之")
		{
			if (GameObject.Find(参数.Substring(1)) != null && Manager._instance.Down.当前选择 != null)
			{
				Manager._instance.Down.当前选择.transform.position = GameObject.Find(参数.Substring(1)).transform.position;
			}
		}
		else if (参数.IndexOf('=') >= 0)
		{
			string[] array = 参数.Split('=');
			GameObject obj = new GameObject();
			obj.name = array[0];
			string[] array2 = array[1].Split(',');
			obj.transform.position = new Vector3(float.Parse(array2[0]), float.Parse(array2[1]), float.Parse(array2[2]));
		}
		return "位完";
	}

	public string 毁(string 参数)
	{
		if (参数.IndexOf("之") != -1)
		{
			string[] array = 参数.Split('之');
			UnityEngine.Object.Destroy(GameObject.Find(参数), float.Parse(array[1]));
		}
		else
		{
			UnityEngine.Object.Destroy(GameObject.Find(参数));
		}
		return "完";
	}

	public string 试(string 参数)
	{
		MonoBehaviour.print(参数);
		return "试完";
	}

	public string 警(string 参数)
	{
		UnityEngine.Debug.Log(参数);
		return "警完";
	}

	public string 去(string 参数)
	{
		if (参数 == "重力")
		{
			Manager._instance.Down.当前选择.GetComponent<Rigidbody>().useGravity = false;
		}
		return "去完";
	}

	public string 局(string 参数)
	{
		if (Manager._instance.Down.当前选择 != null)
		{
			GameObject 当前选择 = Manager._instance.Down.当前选择;
			switch (参数)
			{
			case "1":
				当前选择.GetComponent<RectTransform>().anchorMin = new Vector2(0f, 1f);
				当前选择.GetComponent<RectTransform>().anchorMax = new Vector2(0f, 1f);
				break;
			case "2":
				当前选择.GetComponent<RectTransform>().anchorMin = new Vector2(0.5f, 1f);
				当前选择.GetComponent<RectTransform>().anchorMax = new Vector2(0.5f, 1f);
				break;
			case "3":
				当前选择.GetComponent<RectTransform>().anchorMin = new Vector2(1f, 1f);
				当前选择.GetComponent<RectTransform>().anchorMax = new Vector2(1f, 1f);
				break;
			case "4":
				当前选择.GetComponent<RectTransform>().anchorMin = new Vector2(0f, 0.5f);
				当前选择.GetComponent<RectTransform>().anchorMax = new Vector2(0f, 0.5f);
				break;
			case "5":
				当前选择.GetComponent<RectTransform>().anchorMin = new Vector2(0.5f, 0.5f);
				当前选择.GetComponent<RectTransform>().anchorMax = new Vector2(0.5f, 0.5f);
				break;
			case "6":
				当前选择.GetComponent<RectTransform>().anchorMin = new Vector2(1f, 0.5f);
				当前选择.GetComponent<RectTransform>().anchorMax = new Vector2(1f, 0.5f);
				break;
			case "7":
				当前选择.GetComponent<RectTransform>().anchorMin = new Vector2(0f, 0f);
				当前选择.GetComponent<RectTransform>().anchorMax = new Vector2(0f, 0f);
				break;
			case "8":
				当前选择.GetComponent<RectTransform>().anchorMin = new Vector2(0.5f, 0f);
				当前选择.GetComponent<RectTransform>().anchorMax = new Vector2(0.5f, 0f);
				break;
			case "9":
				当前选择.GetComponent<RectTransform>().anchorMin = new Vector2(1f, 0f);
				当前选择.GetComponent<RectTransform>().anchorMax = new Vector2(1f, 0f);
				break;
			}
		}
		return "局完";
	}

	public string 添(string 参数)
	{
		if (参数.Substring(0, 1) == "图")
		{
			Sprite sprite = Resources.Load("PNG/界面图/" + 参数.Substring(1), typeof(Sprite)) as Sprite;
			Manager._instance.Down.当前选择.GetComponent<Image>().sprite = sprite;
		}
		return "添完";
	}

	public string 点(string 参数)
	{
		string[] array = 参数.Split('之');
		GameObject gameObject = GameObject.Find(array[0]);
		if (gameObject != null)
		{
			Ray ray = new Ray(gameObject.transform.position, gameObject.transform.forward);
			if (array[1].Substring(0, 1) == "名")
			{
				if (Physics.Raycast(ray, out hit, 100f) && hit.transform.name == array[1].Substring(1))
				{
					Manager._instance.Down.当前选择.transform.position = hit.point;
				}
			}
			else if (array[1].Substring(0, 1) == "标" && Physics.Raycast(ray, out hit, 100f) && hit.transform.tag == array[1].Substring(1))
			{
				Manager._instance.Down.当前选择.transform.position = hit.point;
			}
		}
		return "点完";
	}

	private void 人单令(string 参数)
	{
		MonoBehaviour.print("〖vr12888〗人单令()→参数：" + 参数);
		int num = 串模.IndexOf(参数) + 5;
		int num2 = 串模.IndexOf("'", num);
		string 参数2 = 串模.Substring(num, num2 - num);
		Manager._instance.Down.模(参数2);
		是否下载模型 = true;
		模型名 = 参数;
	}

	public string 爸(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 妈(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 爷(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 奶(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 哥(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 弟(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 姐(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 妹(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 夫(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 妻(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 儿(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 伯(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 婶(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 叔(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 嫂(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 姑(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 舅(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 姨(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 婿(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 爹(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 娘(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 姥(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 兄(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 马(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 牛(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 羊(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 狼(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 虎(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 豹(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 熊(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 象(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 猩(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 猴(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 猿(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 骆(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 驴(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 狐(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 兔(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 狮(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 蛇(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 骡(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 鹿(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 树(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 竹(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 草(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 柳(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 柏(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 椰(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 榆(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 芝(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 槐(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 叶(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 瓣(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 苗(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 稻(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 禾(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 蓬(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 杨(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 刀(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 剑(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 弓(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 箭(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 矛(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 盾(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 棒(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 匕(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 刃(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 斧(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 钩(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 锤(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 鞭(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 枪(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 炮(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 舰(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 笛(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 鼓(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 喇(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 锣(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 琴(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 箫(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 谱(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 棉(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 巾(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 钟(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 灯(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 膏(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 壶(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 机(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 剂(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 筷(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 垃(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 蜡(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 历(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 帽(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 膜(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 墨(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 袍(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 瓶(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 器(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 钥(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 皂(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 针(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 扇(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 枕(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 梳(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 伞(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 头(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 身(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 脚(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 腿(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 脸(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 额(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 眼(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 鼻(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 嘴(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 唇(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 牙(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 舌(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 耳(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 颈(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 脖(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 臂(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 腰(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 膝(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 掌(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 翅(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 肩(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 眉(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 拳(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 蹄(string 参数)
	{
		string text = new StackTrace().GetFrame(0).ToString().Substring(0, 1);
		人单令(text);
		return text + "完";
	}

	public string 率(string 参数)
	{
		if (作用物类型 == "特效")
		{
			GameObject 当前选择 = Manager._instance.Down.当前选择;
			if (当前选择.GetComponent<ParticleSystem>() != null || 当前选择.GetComponentInChildren<ParticleSystem>() != null)
			{
				ParticleSystem[] componentsInChildren = 当前选择.GetComponentsInChildren<ParticleSystem>();
				float num = float.Parse(参数) / componentsInChildren[0].startSize;
				for (int i = 0; i < componentsInChildren.Length; i++)
				{
					componentsInChildren[i].startSize = componentsInChildren[i].startSize * num;
				}
			}
		}
		else if (参数.IndexOf("横") != -1 || 参数.IndexOf("纵") != -1 || 参数.IndexOf("深") != -1)
		{
			string text = 参数.Split('横')[1];
			string text2 = text.Split('纵')[1];
			if (Manager._instance.Down.当前选择 != null)
			{
				Manager._instance.Down.当前选择.gameObject.GetComponent<RectTransform>().localScale = new Vector3(float.Parse(text.Split('纵')[0]), float.Parse(text2.Split('深')[0]), float.Parse(text2.Split('深')[1]));
			}
		}
		return "率完";
	}

	public string 原(string 参数)
	{
		return "完";
	}

	public string 字(string 参数)
	{
		if (参数 != "")
		{
			if (Regex.IsMatch(参数, "[\\u4e00-\\u9fbb]+$"))
			{
				string[] array = 串字模.Split(';');
				string text = "0";
				for (int i = 0; i < array.Length; i++)
				{
					if (!(array[i].Substring(0, 1) == 参数.Substring(0, 1)))
					{
						continue;
					}
					text = array[i].Substring(1);
					Manager._instance.Down.模(text);
					是否下载字 = true;
					是否下载模型 = true;
					模型名 = 参数.Substring(0, 1);
					串字 = 参数;
					MonoBehaviour.print("参数：" + 参数);
					if (是否串下一)
					{
						第一字x = (float)参数.Length * -0.2f;
						字串长度 = 参数.Length;
						是否串下一 = false;
						if (参数.Length >= 2)
						{
							是否连着下载 = true;
							当前物.Clear();
						}
					}
					break;
				}
			}
			else
			{
				MonoBehaviour.print("333333333333");
			}
		}
		return "完";
	}

	public string 取轴数(string 参数, string 轴)
	{
		if (参数.IndexOf(轴) >= 0)
		{
			string text = "";
			int result = 0;
			for (int i = 参数.IndexOf(轴); i < 参数.Length - 1; i++)
			{
				if (int.TryParse(参数.Substring(i + 1, 1), out result))
				{
					text += result;
					continue;
				}
				if (参数.Substring(i + 1, 1).IndexOf('-') < 0 && 参数.Substring(i + 1, 1).IndexOf('.') < 0)
				{
					break;
				}
				text += 参数.Substring(i + 1, 1);
			}
			return text;
		}
		return "null";
	}

	public string 鬼(string 参数)
	{
		if (参数 != "")
		{
			SpriteRenderer component = Manager._instance.Down.当前选择.GetComponent<SpriteRenderer>();
			string text = 参数.Split('色')[1];
			Color color = Color.white;
			if (text == "黑")
			{
				color = new Color(0f, 0f, 0f);
			}
			else if (text == "红")
			{
				color = new Color(1f, 0f, 0f);
			}
			component.color = color;
		}
		return "色完";
	}

	public string 绕(string 参数)
	{
		if (参数.Substring(0, 2) == "自转")
		{
			Manager._instance.Down.当前选择.AddComponent<self_rot>();
			float result = 0f;
			if (float.TryParse(参数.Split('速')[1], out result))
			{
				Manager._instance.Down.当前选择.GetComponent<self_rot>().速度 = result;
			}
		}
		return "绕完";
	}

	public string 物(string 参数)
	{
		if (参数.IndexOf('=') >= 0)
		{
			string[] array = 参数.Split('=');
			if (array[1] == "null")
			{
				new GameObject().name = array[0];
			}
			else
			{
				GameObject.Find(array[0]);
				GameObject.Find(array[1]);
			}
		}
		else
		{
			GameObject 当前选择 = Resources.Load(参数, typeof(GameObject)) as GameObject;
			Manager._instance.Down.当前选择 = 当前选择;
		}
		return "物完";
	}

	public string 摄(string 参数)
	{
		Camera main = Camera.main;
		if (参数.Substring(0, 1) == "型")
		{
			if (参数.Substring(1) == "固")
			{
				main.GetComponent<Camera>().clearFlags = CameraClearFlags.Color;
			}
		}
		else if (参数.Substring(0, 1) == "色")
		{
			if (参数.Substring(1, 1) == "之")
			{
				string[] array = 参数.Substring(2).Split('红')[1].Split('绿');
				float num = float.Parse(array[0]);
				string[] array2 = array[1].Split('蓝');
				float num2 = float.Parse(array2[0]);
				float num3 = float.Parse(array2[1]);
				main.GetComponent<Camera>().backgroundColor = new Color(num / 255f, num2 / 255f, num3 / 255f);
				MonoBehaviour.print("红0:" + num + ";绿0:" + num2 + ";蓝0" + num3 + ";wwwwwwwwwwwwwwwwwwww");
			}
		}
		else if (参数.Substring(0, 1) == "处")
		{
			if (参数.Substring(1).IndexOf('纵') >= 0 && 参数.Substring(1).IndexOf('横') < 0 && 参数.Substring(1).IndexOf('深') < 0)
			{
				main.transform.position = new Vector3(Manager._instance.Down.当前选择.transform.position.x, float.Parse(参数.Split('纵')[1]), Manager._instance.Down.当前选择.transform.position.z);
			}
			else if (参数.Substring(1).IndexOf('深') >= 0 && 参数.Substring(1).IndexOf('横') < 0 && 参数.Substring(1).IndexOf('纵') < 0)
			{
				main.transform.position = new Vector3(Manager._instance.Down.当前选择.transform.position.x, Manager._instance.Down.当前选择.transform.position.y, float.Parse(参数.Split('深')[1]));
			}
			else if (参数.Substring(1).IndexOf('横') >= 0 && 参数.Substring(1).IndexOf('纵') < 0 && 参数.Substring(1).IndexOf('深') < 0)
			{
				main.transform.position = new Vector3(float.Parse(参数.Split('横')[1]), Manager._instance.Down.当前选择.transform.position.y, Manager._instance.Down.当前选择.transform.position.z);
			}
			else if (参数.Substring(1).IndexOf('横') >= 0 && 参数.Substring(1).IndexOf('纵') >= 0 && 参数.Substring(1).IndexOf('深') >= 0)
			{
				string[] array3 = 参数.Split('横')[1].Split('纵');
				float x = float.Parse(array3[0]);
				string[] array4 = array3[1].Split('深');
				float y = float.Parse(array4[0]);
				float z = float.Parse(array4[1]);
				main.transform.position = new Vector3(x, y, z);
			}
		}
		return "摄完";
	}

	public string 择(string 参数)
	{
		switch (参数)
		{
		case "子":
		{
			Transform child = Manager._instance.Down.当前选择.transform.GetChild(0);
			Manager._instance.Down.当前选择 = child.gameObject;
			break;
		}
		case "弟":
		{
			Transform child3 = Manager._instance.Down.当前选择.transform.GetChild(1);
			Manager._instance.Down.当前选择 = child3.gameObject;
			break;
		}
		case "兄":
		{
			Transform child2 = Manager._instance.Down.当前选择.transform.parent.GetChild(1);
			Manager._instance.Down.当前选择 = child2.gameObject;
			break;
		}
		case "父":
			if (Manager._instance.Down.当前选择.transform.parent != null)
			{
				Manager._instance.Down.当前选择 = Manager._instance.Down.当前选择.transform.parent.gameObject;
			}
			break;
		}
		return "择完";
	}

	public string 傅(string 参数)
	{
		if (参数.Substring(0, 1) == "横")
		{
			Manager._instance.Down.当前选择.GetComponent<Text>().horizontalOverflow = HorizontalWrapMode.Overflow;
		}
		return "浮完";
	}

	public string 鼠(string 参数)
	{
		if (参数.Substring(0, 1) == "点")
		{
			GameObject obj = new GameObject();
			obj.AddComponent<dian>();
			obj.name = "开始游戏";
			是否开始事件 = true;
		}
		else
		{
			_ = 参数.Substring(0, 1) == "完";
		}
		return "鼠完";
	}

	public string 驾(string 参数)
	{
		if (参数.IndexOf('之') >= 0)
		{
			string[] array = 参数.Split('之');
			int result = 0;
			if (int.TryParse(array[0], out result))
			{
				if (array[1].IndexOf('距') >= 0)
				{
					string[] array2 = array[1].Split('距');
					距长 = float.Parse(array2[1]);
					目标 = GameObject.Find(array2[0]);
				}
				else
				{
					距长 = 0.01f;
					目标 = GameObject.Find(array[1]);
				}
				移动速度 = result;
				是否移动 = true;
			}
		}
		return "驾完";
	}

	public string 缓(string 参数)
	{
		if (参数.IndexOf('之') >= 0)
		{
			string[] array = 参数.Split('之');
			是否缓动 = true;
			缓动速度.Add(float.Parse(array[0]));
			if (array[1].Substring(0, 1) == "摄")
			{
				目标函.Add(array[1].Substring(0, 1));
				缓目标.Add(Camera.main.gameObject);
				缓属性.Add(array[1].Substring(1, 1));
				缓目的.Add(array[1].Substring(2));
			}
		}
		return "缓完";
	}

	public string 停(string 参数)
	{
		float result = 0f;
		float.TryParse(参数, out result);
		return "停完";
	}

	public string 场(string 参数)
	{
		if (参数 == "自")
		{
			SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex);
		}
		return "场完";
	}

	public string 培(string 参数)
	{
		if (参数.IndexOf('之') >= 0)
		{
			string[] array = 参数.Split('之');
			if (array[0] == "图")
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(Resources.Load(array[1], typeof(GameObject)) as GameObject);
				Manager._instance.Down.当前选择 = gameObject;
				if (Manager._instance.JieMian.是否为界面)
				{
					gameObject.transform.parent = GameObject.Find("Canvas").transform;
				}
			}
		}
		return "生完";
	}

	public string 处(string 参数)
	{
		if (参数.IndexOf('横') >= 0 && 参数.IndexOf('纵') >= 0 && 参数.IndexOf('深') >= 0)
		{
			string[] array = 参数.Substring(1).Split('纵');
			float x = float.Parse(array[0]);
			string[] array2 = array[1].Split('深');
			float y = float.Parse(array2[0]);
			float z = float.Parse(array2[1]);
			Manager._instance.Down.当前选择.transform.position = new Vector3(x, y, z);
		}
		return "处完";
	}

	public string 置(string 参数)
	{
		if (参数.IndexOf('横') >= 0 && 参数.IndexOf('纵') >= 0 && 参数.IndexOf('深') >= 0)
		{
			string[] array = 参数.Substring(1).Split('纵');
			float x = float.Parse(array[0]);
			string[] array2 = array[1].Split('深');
			float y = float.Parse(array2[0]);
			float z = float.Parse(array2[1]);
			Manager._instance.Down.当前选择.transform.localPosition = new Vector3(x, y, z);
		}
		else if (参数.IndexOf('左') >= 0 && 参数.IndexOf('右') >= 0)
		{
			string text = "";
			string text2 = "";
			int result = 0;
			for (int i = 参数.IndexOf('左'); i < 参数.Length - 1; i++)
			{
				if (int.TryParse(参数.Substring(i + 1, 1), out result))
				{
					text += result;
					continue;
				}
				if (参数.Substring(i + 1, 1).IndexOf('-') < 0 && 参数.Substring(i + 1, 1).IndexOf('.') < 0)
				{
					break;
				}
				text += 参数.Substring(i + 1, 1);
			}
			for (int j = 参数.IndexOf('右'); j < 参数.Length - 1; j++)
			{
				if (int.TryParse(参数.Substring(j + 1, 1), out result))
				{
					text2 += result;
					continue;
				}
				if (参数.Substring(j + 1, 1).IndexOf('-') < 0 && 参数.Substring(j + 1, 1).IndexOf('.') < 0)
				{
					break;
				}
				text2 += 参数.Substring(j + 1, 1);
			}
		}
		return "置完";
	}

	public string 卢(string 参数)
	{
		if (参数.IndexOf('宽') >= 0 && 参数.IndexOf('高') >= 0)
		{
			string[] array = 参数.Substring(1).Split('高');
			float x = float.Parse(array[0]);
			float y = float.Parse(array[1]);
			Manager._instance.Down.当前选择.GetComponent<RectTransform>().sizeDelta = new Vector2(x, y);
		}
		return "卢完";
	}

	public string 寸(string 参数)
	{
		string s = 取轴数(参数, "横");
		string s2 = 取轴数(参数, "纵");
		string s3 = 取轴数(参数, "深");
		Manager._instance.Down.当前选择.GetComponent<RectTransform>().localScale = new Vector3(float.Parse(s), float.Parse(s2), float.Parse(s3));
		return "寸完";
	}

	public string 获(string 参数)
	{
		if (参数.Substring(0, 1) == "图")
		{
			if (参数.Substring(1, 1) == "源")
			{
				Sprite sprite = Resources.Load("PNG/界面图/" + 参数.Substring(1).Split('之')[1], typeof(Sprite)) as Sprite;
				if (sprite != null)
				{
					UnityEngine.Debug.Log("ImgObj1:" + sprite.name);
				}
				Manager._instance.Down.当前选择.GetComponent<Image>().sprite = sprite;
			}
			else if (参数.Substring(1, 1) == "色")
			{
				if (参数.Substring(1).IndexOf('之') >= 0)
				{
					if (参数.Substring(1).Split('之')[1] == "红")
					{
						Manager._instance.Down.当前选择.GetComponent<Image>().color = Color.red;
					}
					else if (参数.Substring(1).Split('之')[1].Substring(0, 1) == "#")
					{
						Color color = ColorRevert.ToColor(参数.Substring(1).Split('之')[1]);
						Manager._instance.Down.当前选择.GetComponent<Image>().color = color;
					}
				}
				else
				{
					Color32 color2 = Manager._instance.Down.当前选择.GetComponent<Image>().color;
					if (参数.Substring(2) == "隐")
					{
						color2.a = 0;
					}
					else if (参数.Substring(2) == "显")
					{
						color2.a = 1;
					}
					Manager._instance.Down.当前选择.GetComponent<Image>().color = color2;
				}
			}
		}
		return "获完";
	}

	public string 咔(string 参数)
	{
		if (参数.Substring(0, 1) == "层")
		{
			int result = 0;
			if (int.TryParse(参数.Split('之')[1], out result))
			{
				Manager._instance.Down.当前选择.GetComponent<Canvas>().sortingOrder = result;
			}
		}
		return "咔完";
	}

	public string 入(string 参数)
	{
		if (参数 == "界")
		{
			Manager._instance.Down.当前选择.transform.parent = GameObject.Find("Canvas").transform;
		}
		else
		{
			GameObject gameObject = GameObject.Find(参数);
			if (gameObject != null)
			{
				Manager._instance.Down.当前选择.transform.parent = gameObject.transform;
			}
		}
		return "入完";
	}

	public string 跑(string 参数)
	{
		if (参数.Substring(0, 1) == "段")
		{
			if (Manager._instance.Down.当前选择.GetComponent<tu>() == null)
			{
				Manager._instance.Down.当前选择.AddComponent<tu>();
				string[] array = 参数.Split('速');
				Manager._instance.Down.当前选择.GetComponent<tu>().速度 = float.Parse(array[1]);
				string text = 取轴数(参数, "横");
				string text2 = 取轴数(参数, "纵");
				string text3 = 取轴数(参数, "深");
				if (text != "null")
				{
					Manager._instance.Down.当前选择.GetComponent<tu>().加横 = float.Parse(text);
				}
				if (text2 != "null")
				{
					Manager._instance.Down.当前选择.GetComponent<tu>().加纵 = float.Parse(text2);
				}
				if (text3 != "null")
				{
					Manager._instance.Down.当前选择.GetComponent<tu>().加深 = float.Parse(text3);
				}
			}
		}
		else if (参数.Substring(0, 1) == "直" && Manager._instance.Down.当前选择.GetComponent<gui>() == null)
		{
			Manager._instance.Down.当前选择.AddComponent<gui>();
			string[] array2 = 参数.Split('速');
			Manager._instance.Down.当前选择.GetComponent<gui>().速度 = float.Parse(array2[1]);
			string text4 = 取轴数(参数, "横");
			string text5 = 取轴数(参数, "纵");
			string text6 = 取轴数(参数, "深");
			if (text4 != "null")
			{
				Manager._instance.Down.当前选择.GetComponent<gui>().加横 = float.Parse(text4);
			}
			if (text5 != "null")
			{
				Manager._instance.Down.当前选择.GetComponent<gui>().加纵 = float.Parse(text5);
			}
			if (text6 != "null")
			{
				Manager._instance.Down.当前选择.GetComponent<gui>().加深 = float.Parse(text6);
			}
		}
		return "跑完";
	}

	public string 终(string 参数)
	{
		if (参数.Substring(0, 1) == "点")
		{
			if (Manager._instance.Down.当前选择.GetComponent<end>() == null)
			{
				Manager._instance.Down.当前选择.AddComponent<end>();
				string text = 取轴数(参数, "横");
				string text2 = 取轴数(参数, "纵");
				string text3 = 取轴数(参数, "深");
				if (text != "null")
				{
					Manager._instance.Down.当前选择.GetComponent<end>().横 = float.Parse(text);
				}
				if (text2 != "null")
				{
					Manager._instance.Down.当前选择.GetComponent<end>().纵 = float.Parse(text2);
				}
				if (text3 != "null")
				{
					Manager._instance.Down.当前选择.GetComponent<end>().深 = float.Parse(text3);
				}
			}
		}
		else if (参数.Substring(0, 1) == "说")
		{
			if (Manager._instance.Down.当前选择.GetComponent<shuo>() == null)
			{
				Manager._instance.Down.当前选择.AddComponent<shuo>();
				Vector3 vector = new Vector3(Manager._instance.Down.当前选择.GetComponent<end>().横, Manager._instance.Down.当前选择.GetComponent<end>().纵, Manager._instance.Down.当前选择.GetComponent<end>().深);
				Manager._instance.Down.当前选择.GetComponent<shuo>().点 = vector;
				string 文 = 参数.Split('之')[1];
				Manager._instance.Down.当前选择.GetComponent<shuo>().文 = 文;
			}
		}
		else if (参数.Substring(0, 1) == "入")
		{
			if (Manager._instance.Down.当前选择.GetComponent<ru>() == null)
			{
				Manager._instance.Down.当前选择.AddComponent<ru>();
				Vector3 vector2 = new Vector3(Manager._instance.Down.当前选择.GetComponent<end>().横, Manager._instance.Down.当前选择.GetComponent<end>().纵, Manager._instance.Down.当前选择.GetComponent<end>().深);
				Manager._instance.Down.当前选择.GetComponent<ru>().点 = vector2;
				Manager._instance.Down.当前选择.GetComponent<ru>().父 = 参数.Substring(1);
			}
		}
		else if (参数.Substring(0, 1) == "消")
		{
			if (Manager._instance.Down.当前选择.GetComponent<xiao>() == null)
			{
				Manager._instance.Down.当前选择.AddComponent<xiao>();
				Vector3 vector3 = new Vector3(Manager._instance.Down.当前选择.GetComponent<end>().横, Manager._instance.Down.当前选择.GetComponent<end>().纵, Manager._instance.Down.当前选择.GetComponent<end>().深);
				Manager._instance.Down.当前选择.GetComponent<xiao>().点 = vector3;
			}
		}
		else if (参数.Substring(0, 1) == "隆")
		{
			if (Manager._instance.Down.当前选择.GetComponent<longg>() == null)
			{
				Manager._instance.Down.当前选择.AddComponent<longg>();
				Vector3 vector4 = new Vector3(Manager._instance.Down.当前选择.GetComponent<end>().横, Manager._instance.Down.当前选择.GetComponent<end>().纵, Manager._instance.Down.当前选择.GetComponent<end>().深);
				Manager._instance.Down.当前选择.GetComponent<longg>().点 = vector4;
				string text4 = 取轴数(参数, "横");
				string text5 = 取轴数(参数, "纵");
				string text6 = 取轴数(参数, "深");
				if (text4 != "null")
				{
					Manager._instance.Down.当前选择.GetComponent<longg>().横 = float.Parse(text4);
				}
				if (text5 != "null")
				{
					Manager._instance.Down.当前选择.GetComponent<longg>().纵 = float.Parse(text5);
				}
				if (text6 != "null")
				{
					Manager._instance.Down.当前选择.GetComponent<longg>().深 = float.Parse(text6);
				}
				int num = 参数.IndexOf('之');
				string text7 = 参数.Substring(1, num - 1);
				Manager._instance.Down.当前选择.GetComponent<longg>().名 = text7;
			}
		}
		else if (参数.Substring(0, 1) == "钮" && Manager._instance.Down.当前选择.GetComponent<niu_new>() == null)
		{
			Manager._instance.Down.当前选择.AddComponent<niu_new>();
			Vector3 vector5 = new Vector3(Manager._instance.Down.当前选择.GetComponent<end>().横, Manager._instance.Down.当前选择.GetComponent<end>().纵, Manager._instance.Down.当前选择.GetComponent<end>().深);
			Manager._instance.Down.当前选择.GetComponent<niu_new>().点 = vector5;
			Manager._instance.Down.当前选择.GetComponent<niu_new>().值 = 参数.Substring(1);
		}
		return "终完";
	}

	public string 触(string 参数)
	{
		if (参数.IndexOf('之') < 0)
		{
			if (参数.Substring(0, 2) == "同名")
			{
				string text = Manager._instance.Down.当前选择.name;
				if (Manager._instance.Down.当前选择.GetComponent<chu_8>() == null)
				{
					Manager._instance.Down.当前选择.AddComponent<chu_8>();
					Manager._instance.Down.当前选择.GetComponent<chu_8>().名 = text;
					Manager._instance.Down.当前选择.GetComponent<chu_8>().物 = base.gameObject;
					if (参数.Length > 2)
					{
						Manager._instance.Down.当前选择.GetComponent<chu_8>().值 = 参数.Substring(2);
					}
				}
			}
			else if (参数.Substring(0, 1) == "事")
			{
				int num = (参数.Length - 参数.Replace("事", "").Length) / "事".Length;
				int num2 = 0;
				for (int i = 0; i < num; i++)
				{
					GameObject gameObject = null;
					if (参数.Substring(i + 1 + num2, 1) == "全")
					{
						MonoBehaviour[] components = Manager._instance.Down.当前选择.GetComponents<MonoBehaviour>();
						for (int j = 0; j < components.Length; j++)
						{
							for (int k = 0; k < components.Length; k++)
							{
								if (components[j].ToString().Contains(components[k].ToString()))
								{
									components[j].enabled = false;
									break;
								}
							}
						}
					}
					else if (参数.Substring(i + 1 + num2, 1) == "摄")
					{
						if (参数.Substring(i + 2 + num2, 1) == "近")
						{
							StartCoroutine(摄近("35"));
						}
						else
						{
							string 参数2 = 参数.Substring(i + 2 + num2, 1);
							StartCoroutine(摄色(参数2));
						}
					}
					else if (参数.Substring(i + 1 + num2, 1) == "钮")
					{
						GameObject gameObject2 = Resources.Load("Button1", typeof(GameObject)) as GameObject;
						if (gameObject2 != null)
						{
							GameObject gameObject3 = UnityEngine.Object.Instantiate(gameObject2);
							gameObject3.transform.parent = GameObject.Find("Canvas").transform;
							if (参数.Substring(i + 2 + num2, 1) == "新")
							{
								gameObject3.GetComponent<RectTransform>().sizeDelta = new Vector2(100f, 50f);
								gameObject3.GetComponent<RectTransform>().localPosition = new Vector3(0f, 0f, 0f);
								gameObject3.GetComponentInChildren<Text>().text = "重新开始";
								gameObject3.GetComponent<UnityEngine.UI.Button>().onClick.AddListener(delegate
								{
									重新开始游戏();
								});
							}
						}
					}
					else
					{
						gameObject = GameObject.Find(参数.Substring(i + 1 + num2, 1));
						if (gameObject != null)
						{
							if (参数.Substring(i + 2 + num2, 1) == "停")
							{
								MonoBehaviour[] components2 = gameObject.GetComponents<MonoBehaviour>();
								for (int l = 0; l < components2.Length; l++)
								{
									if (components2[l].ToString().Contains("self_rot"))
									{
										components2[l].enabled = false;
									}
								}
							}
							else if (参数.Substring(i + 2 + num2, 1) == "消")
							{
								MonoBehaviour[] components3 = gameObject.GetComponents<MonoBehaviour>();
								for (int m = 0; m < components3.Length; m++)
								{
									for (int n = 0; n < components3.Length; n++)
									{
										if (components3[m].ToString().Contains(components3[n].ToString()))
										{
											components3[m].enabled = false;
											break;
										}
									}
								}
							}
							else if (参数.Substring(i + 2 + num2, 1) == "快")
							{
								StartCoroutine(物快(参数.Substring(i + 1 + num2, 1)));
							}
						}
					}
					num2 += 2;
				}
			}
		}
		return "触完";
	}

	public string 型(string 参数)
	{
		if (参数.Substring(0, 1) == "界")
		{
			switch (int.Parse(参数.Split('之')[1]))
			{
			case 1:
				Manager._instance.Down.当前选择.GetComponent<Canvas>().renderMode = RenderMode.ScreenSpaceOverlay;
				break;
			case 2:
				Manager._instance.Down.当前选择.GetComponent<Canvas>().renderMode = RenderMode.ScreenSpaceCamera;
				break;
			case 3:
				Manager._instance.Down.当前选择.GetComponent<Canvas>().renderMode = RenderMode.WorldSpace;
				break;
			}
		}
		else if (参数.Substring(0, 1) == "样")
		{
			GameObject 当前选择 = Manager._instance.Down.当前选择;
			switch (int.Parse(参数.Substring(1)))
			{
			case 1:
				当前选择.GetComponent<RectTransform>().anchorMin = new Vector2(0f, 1f);
				当前选择.GetComponent<RectTransform>().anchorMax = new Vector2(0f, 1f);
				break;
			case 2:
				当前选择.GetComponent<RectTransform>().anchorMin = new Vector2(0.5f, 1f);
				当前选择.GetComponent<RectTransform>().anchorMax = new Vector2(0.5f, 1f);
				break;
			case 3:
				当前选择.GetComponent<RectTransform>().anchorMin = new Vector2(1f, 1f);
				当前选择.GetComponent<RectTransform>().anchorMax = new Vector2(1f, 1f);
				break;
			case 4:
				当前选择.GetComponent<RectTransform>().anchorMin = new Vector2(0f, 0.5f);
				当前选择.GetComponent<RectTransform>().anchorMax = new Vector2(0f, 0.5f);
				break;
			case 5:
				当前选择.GetComponent<RectTransform>().anchorMin = new Vector2(0.5f, 0.5f);
				当前选择.GetComponent<RectTransform>().anchorMax = new Vector2(0.5f, 0.5f);
				break;
			case 6:
				当前选择.GetComponent<RectTransform>().anchorMin = new Vector2(1f, 0.5f);
				当前选择.GetComponent<RectTransform>().anchorMax = new Vector2(1f, 0.5f);
				break;
			case 7:
				当前选择.GetComponent<RectTransform>().anchorMin = new Vector2(0f, 0f);
				当前选择.GetComponent<RectTransform>().anchorMax = new Vector2(0f, 0f);
				break;
			case 8:
				当前选择.GetComponent<RectTransform>().anchorMin = new Vector2(0.5f, 0f);
				当前选择.GetComponent<RectTransform>().anchorMax = new Vector2(0.5f, 0f);
				break;
			case 9:
				当前选择.GetComponent<RectTransform>().anchorMin = new Vector2(1f, 0f);
				当前选择.GetComponent<RectTransform>().anchorMax = new Vector2(1f, 0f);
				break;
			case 0:
				当前选择.GetComponent<RectTransform>().anchorMin = new Vector2(0f, 0f);
				当前选择.GetComponent<RectTransform>().anchorMax = new Vector2(1f, 1f);
				break;
			}
		}
		return "型完";
	}

	public string 雯(string 参数)
	{
		Manager._instance.Down.当前选择.GetComponent<Text>().text = 参数;
		return "雯完";
	}

	public string 涩(string 参数)
	{
		Color color = ColorRevert.ToColor(参数);
		Manager._instance.Down.当前选择.GetComponent<Text>().color = color;
		return "涩完";
	}

	public string 全(string 参数)
	{
		if (参数 == "隐")
		{
			GameObject.Find("EasyTouchControlsCanvas").SetActive(value: false);
			Camera main = Camera.main;
			if (main.transform.childCount > 0)
			{
				for (int i = 0; i < main.transform.childCount; i++)
				{
					if (main.transform.GetChild(i).gameObject.active)
					{
						main.transform.GetChild(i).gameObject.active = false;
					}
				}
			}
		}
		else if (参数 == "显")
		{
			GameObject.Find("EasyTouchControlsCanvas").SetActive(value: true);
		}
		return "全完";
	}

	public string 格(string 参数)
	{
		if (参数.IndexOf('行') >= 0 && 参数.IndexOf('列') >= 0)
		{
			格集 = new ArrayList();
			格消集 = new ArrayList();
			int rowNum = int.Parse(取轴数(参数, "行"));
			int columNum = int.Parse(取轴数(参数, "列"));
			float 隔上 = float.Parse(取轴数(参数, "上"));
			float 隔左 = float.Parse(取轴数(参数, "左"));
			float 偏x = float.Parse(取轴数(参数, "偏"));
			float 偏y = float.Parse(取轴数(参数, "与"));
			float 寸横 = 1f;
			float 寸纵 = 1f;
			float 寸深 = 1f;
			if (参数.IndexOf("横") >= 0 && 参数.IndexOf("纵") >= 0 && 参数.IndexOf("深") >= 0)
			{
				寸横 = float.Parse(取轴数(参数, "横"));
				寸纵 = float.Parse(取轴数(参数, "纵"));
				寸深 = float.Parse(取轴数(参数, "深"));
			}
			if (参数.Substring(0, 1) == "图")
			{
				GameObject gameObject = Resources.Load("背景2", typeof(GameObject)) as GameObject;
				if (gameObject != null)
				{
					GameObject gameObject2 = UnityEngine.Object.Instantiate(gameObject);
					GameObject gameObject3 = Resources.Load("框", typeof(GameObject)) as GameObject;
					if (gameObject3 != null)
					{
						GameObject gameObject4 = UnityEngine.Object.Instantiate(gameObject3);
						gameObject4.transform.parent = gameObject2.transform.GetChild(0);
						gameObject4.AddComponent<xiaoxiao>();
						gameObject4.GetComponent<xiaoxiao>().rowNum = rowNum;
						gameObject4.GetComponent<xiaoxiao>().columNum = columNum;
						gameObject4.GetComponent<xiaoxiao>().寸横 = 寸横;
						gameObject4.GetComponent<xiaoxiao>().寸纵 = 寸纵;
						gameObject4.GetComponent<xiaoxiao>().寸深 = 寸深;
						gameObject4.GetComponent<xiaoxiao>().隔上 = 隔上;
						gameObject4.GetComponent<xiaoxiao>().隔左 = 隔左;
						gameObject4.GetComponent<xiaoxiao>().物图 = 1;
						gameObject4.GetComponent<xiaoxiao>().偏x = 偏x;
						gameObject4.GetComponent<xiaoxiao>().偏y = 偏y;
						Manager._instance.Down.当前选择 = gameObject4;
					}
				}
			}
			else if (参数.Substring(0, 1) == "物" || 参数.Substring(0, 1) == "行" || 参数.Substring(0, 1) == "列")
			{
				GameObject gameObject5 = new GameObject();
				gameObject5.AddComponent<xiaoxiao>();
				gameObject5.GetComponent<xiaoxiao>().rowNum = rowNum;
				gameObject5.GetComponent<xiaoxiao>().columNum = columNum;
				Manager._instance.Down.当前选择 = gameObject5;
			}
		}
		return "格完";
	}

	public string 混(string 参数)
	{
		int num = 参数.IndexOf("于");
		int num2 = 参数.IndexOf("之");
		GameObject gameObject = GameObject.Find(参数.Substring(num + 1, num2 - num - 1));
		if (gameObject != null)
		{
			string text = 参数.Substring(num2 + 1);
			int num3 = 0;
			if (text.IndexOf("与") >= 0)
			{
				num3 = (text.Length - text.Replace("与", "").Length) / "与".Length;
			}
			List<string> list = new List<string>();
			string text2 = text;
			for (int i = 0; i < num3 + 1; i++)
			{
				int num4 = text2.IndexOf("与");
				string text3 = "";
				text3 = ((num4 < 0) ? text2 : text2.Substring(0, num4));
				list.Add(text3);
				text2 = text2.Substring(num4 + 1);
			}
			int childCount = gameObject.transform.childCount;
			if (参数.Substring(0, 1) == "图")
			{
				GameObject gameObject2 = Resources.Load("格钮", typeof(GameObject)) as GameObject;
				if (gameObject2 != null)
				{
					if (gameObject2.GetComponent<Gemstone>() == null)
					{
						gameObject2.AddComponent<Gemstone>();
					}
					gameObject2.GetComponent<Gemstone>().xOffset = gameObject.GetComponent<xiaoxiao>().隔左;
					gameObject2.GetComponent<Gemstone>().yOffset = gameObject.GetComponent<xiaoxiao>().隔上;
					gameObject2.GetComponent<Gemstone>().gemstoneBgs2.Clear();
					for (int j = 0; j < list.Count; j++)
					{
						Sprite sprite = Resources.Load("12888/" + list[j], typeof(Sprite)) as Sprite;
						if (sprite != null)
						{
							gameObject2.GetComponent<Gemstone>().gemstoneBgs2.Add(sprite);
						}
					}
					gameObject.GetComponent<xiaoxiao>().gemstone = gameObject2.GetComponent<Gemstone>();
					gameObject.GetComponent<xiaoxiao>().是否生 = true;
				}
			}
			else if (参数.Substring(0, 1) == "物" || 参数.Substring(0, 1) == "于")
			{
				for (int k = 0; k < childCount; k++)
				{
					int index = UnityEngine.Random.Range(0, list.Count);
					GameObject gameObject3 = Resources.Load(list[index], typeof(GameObject)) as GameObject;
					if (gameObject3 != null)
					{
						GameObject obj = UnityEngine.Object.Instantiate(gameObject3);
						obj.transform.parent = gameObject.transform.GetChild(k);
						obj.transform.localPosition = new Vector3(0f, 0f, 0f);
					}
				}
			}
		}
		return "混完";
	}

	public string 消(string 参数)
	{
		if (参数.IndexOf("之") >= 0)
		{
			int num = 参数.IndexOf("之");
			GameObject gameObject = GameObject.Find(参数.Substring(0, num));
			if (gameObject != null)
			{
				if (gameObject.GetComponent<xiaoxiao>() != null)
				{
					int num2 = 参数.IndexOf("于");
					GameObject gameObject2 = GameObject.Find(参数.Substring(num + 1, num2 - num - 1));
					if (gameObject2.GetComponent<Text>() != null)
					{
						gameObject.GetComponent<xiaoxiao>().计分板 = gameObject2;
						string text = 参数.Substring(num2 + 1, 1);
						if (text == "加")
						{
							int 低计分 = int.Parse(取轴数(参数, text));
							gameObject.GetComponent<xiaoxiao>().低计分 = 低计分;
						}
						else
						{
							_ = text == "减";
						}
					}
					gameObject.GetComponent<xiaoxiao>().是否消 = true;
				}
				Manager._instance.Down.当前选择 = gameObject;
			}
		}
		else
		{
			GameObject gameObject3 = GameObject.Find(参数);
			if (gameObject3 != null)
			{
				if (gameObject3.GetComponent<xiaoxiao>() != null)
				{
					gameObject3.GetComponent<xiaoxiao>().是否消 = true;
				}
				Manager._instance.Down.当前选择 = gameObject3;
			}
		}
		return "消完";
	}

	public string 条(string 参数)
	{
		if (参数.Substring(0, 1) == "生")
		{
			GameObject gameObject = Resources.Load("条", typeof(GameObject)) as GameObject;
			if (gameObject != null)
			{
				GameObject gameObject2 = UnityEngine.Object.Instantiate(gameObject);
				GameObject gameObject3 = GameObject.Find("Canvas");
				if (gameObject3 != null)
				{
					gameObject2.transform.parent = gameObject3.transform;
					if (参数.IndexOf("值") >= 0)
					{
						float value = float.Parse(取轴数(参数, "值"));
						gameObject2.GetComponent<Slider>().value = value;
					}
				}
				Manager._instance.Down.当前选择 = gameObject2;
			}
		}
		else if (参数.Substring(0, 1) == "动")
		{
			slide_con component = Manager._instance.Down.当前选择.GetComponent<slide_con>();
			if (参数.IndexOf("之") >= 0 && 参数.IndexOf("速") >= 0)
			{
				float 速率 = float.Parse(取轴数(参数, "速"));
				component.速率 = 速率;
			}
			component.是否开始跑 = true;
		}
		else if (参数.Substring(0, 1) == "值")
		{
			float value2 = float.Parse(取轴数(参数, 参数.Substring(1, 1)));
			int num = 参数.IndexOf("之");
			Slider slider = null;
			if (num >= 0)
			{
				string text = 参数.Substring(num + 1);
				if (GameObject.Find(text) != null && GameObject.Find(text).GetComponent<Slider>() != null)
				{
					slider = GameObject.Find(text).GetComponent<Slider>();
				}
			}
			else if (Manager._instance.Down.当前选择.GetComponent<Slider>() != null)
			{
				slider = Manager._instance.Down.当前选择.GetComponent<Slider>();
			}
			if (slider != null)
			{
				slider.value = value2;
			}
		}
		else if (参数.Substring(0, 1) == "时")
		{
			int num2 = 参数.IndexOf("事");
			slide_con component2 = Manager._instance.Down.当前选择.GetComponent<slide_con>();
			if (参数.IndexOf("值") >= 0)
			{
				int num3 = 参数.IndexOf("值");
				float 条件值 = float.Parse(取轴数(参数, 参数.Substring(num3 + 1, 1)));
				if (参数.Substring(num2 + 1, 2) == "活显")
				{
					component2.条件值 = 条件值;
					component2.条件键 = 参数.Substring(1, 1);
					string text2 = 参数.Substring(num2 + 1);
					if (text2.IndexOf("事") >= 0)
					{
						string 额外文 = text2.Substring(text2.IndexOf("事") + 1);
						component2.是否额外执 = true;
						component2.额外文 = 额外文;
					}
				}
			}
		}
		else if (参数.Substring(0, 1) == "色")
		{
			int num4 = 参数.IndexOf("前");
			int num5 = 参数.IndexOf("后");
			int num6 = 参数.IndexOf("之");
			GameObject gameObject4 = null;
			if (num6 >= 0)
			{
				if (GameObject.Find(参数.Substring(num6 + 1)) != null)
				{
					gameObject4 = GameObject.Find(参数.Substring(num6 + 1));
				}
			}
			else if (Manager._instance.Down.当前选择.GetComponent<Slider>() != null)
			{
				gameObject4 = Manager._instance.Down.当前选择;
			}
			if (gameObject4 != null)
			{
				if (num4 >= 0)
				{
					string 参数2 = 参数.Substring(num4 + 1, 1);
					Color color = 判色(参数2, 参数, num4 + 1);
					gameObject4.transform.GetChild(1).gameObject.transform.GetChild(0).GetComponent<Image>().color = color;
				}
				if (num5 >= 0)
				{
					string 参数3 = 参数.Substring(num5 + 1, 1);
					Color color2 = 判色(参数3, 参数, num5 + 1);
					gameObject4.transform.GetChild(0).gameObject.GetComponent<Image>().color = color2;
				}
			}
		}
		return "条完";
	}

	public string 活(string 参数)
	{
		if (参数 == "隐")
		{
			Manager._instance.Down.当前选择.active = false;
		}
		else if (参数 == "显")
		{
			Manager._instance.Down.当前选择.active = true;
		}
		return "活完";
	}

	public string 侦(string 参数)
	{
		if (参数.Substring(0, 1) == "钮")
		{
			if (参数.Substring(1, 1) == "新")
			{
				Manager._instance.Down.当前选择.GetComponent<UnityEngine.UI.Button>().onClick.AddListener(delegate
				{
					重新开始游戏();
				});
			}
			else if (参数.Substring(1, 1) == "下")
			{
				int num = 参数.IndexOf("于");
				string 参数2 = 参数.Substring(num + 1);
				Manager._instance.Down.当前选择.GetComponent<UnityEngine.UI.Button>().onClick.AddListener(delegate
				{
					下关游戏(参数2);
				});
			}
		}
		return "侦完";
	}
}
public class xiao : MonoBehaviour
{
	public Vector3 点;

	private bool 完;

	private void Start()
	{
	}

	private void Update()
	{
		if (!完 && base.transform.parent != null)
		{
			完 = true;
			UnityEngine.Component[] components = base.gameObject.GetComponents<UnityEngine.Component>();
			for (int i = 0; i < components.Length; i++)
			{
				components[i].SendMessage("隐隐");
			}
			base.enabled = false;
		}
	}

	public void 显显()
	{
		base.enabled = true;
	}
}
public class xiaoxiao : MonoBehaviour
{
	public Gemstone gemstone;

	public int rowNum = 7;

	public int columNum = 10;

	public ArrayList gemstoneList;

	private Gemstone currentGemstone;

	private ArrayList matchesGemstone;

	public AudioClip match3Clip;

	public AudioClip swapClip;

	public AudioClip erroeClip;

	public GameObject 计分板;

	public int 低计分;

	public bool 是否生;

	public bool 是否消;

	public bool 是否按;

	private bool 是否消2;

	public float 隔上;

	public float 隔左;

	public float 寸横 = 1f;

	public float 寸纵 = 1f;

	public float 寸深 = 1f;

	public float 偏x;

	public float 偏y;

	public int 物图;

	private void Start()
	{
	}

	public void Restart()
	{
		gemstoneList = new ArrayList();
		matchesGemstone = new ArrayList();
		for (int i = 0; i < rowNum; i++)
		{
			ArrayList arrayList = new ArrayList();
			for (int j = 0; j < columNum; j++)
			{
				Gemstone value = AddGemstone(i, j);
				arrayList.Add(value);
			}
			gemstoneList.Add(arrayList);
		}
		if ((CheckHorizontalMatches() || CheckVerticalMatches()) && 是否消2)
		{
			RemoveMatches();
		}
	}

	public void 消消格()
	{
		if (CheckHorizontalMatches() || CheckVerticalMatches())
		{
			RemoveMatches();
		}
	}

	public Gemstone AddGemstone(int rowIndex, int columIndex)
	{
		Gemstone obj = UnityEngine.Object.Instantiate(gemstone);
		obj.transform.parent = base.transform;
		obj.transform.localScale = new Vector3(寸横, 寸纵, 寸深);
		obj.gameController = this;
		obj.GetComponent<Gemstone>().RandomCreateGemstoneBg();
		obj.GetComponent<Gemstone>().UpdatePosition(rowIndex, columIndex);
		return obj;
	}

	private void Update()
	{
		if (是否生)
		{
			Restart();
			是否生 = false;
		}
		if (是否消)
		{
			消消格();
			是否消 = false;
			是否消2 = true;
		}
	}

	public void Select(Gemstone c)
	{
		if (currentGemstone == null)
		{
			currentGemstone = c;
			currentGemstone.isSelected = true;
			return;
		}
		if (Mathf.Abs(currentGemstone.rowIndex - c.rowIndex) + Mathf.Abs(currentGemstone.columIndex - c.columIndex) == 1)
		{
			StartCoroutine(ExangeAndMatches(currentGemstone, c));
		}
		else
		{
			base.gameObject.GetComponent<AudioSource>().PlayOneShot(erroeClip);
		}
		currentGemstone.isSelected = false;
		currentGemstone = null;
	}

	private IEnumerator ExangeAndMatches(Gemstone c1, Gemstone c2)
	{
		Exchange(c1, c2);
		yield return new WaitForSeconds(0.5f);
		if (是否消2)
		{
			if (CheckHorizontalMatches() || CheckVerticalMatches())
			{
				RemoveMatches();
			}
			else
			{
				Exchange(c1, c2);
			}
		}
	}

	private bool CheckHorizontalMatches()
	{
		bool result = false;
		for (int i = 0; i < rowNum; i++)
		{
			for (int j = 0; j < columNum - 2; j++)
			{
				if (GetGemstone(i, j).gemstoneType == GetGemstone(i, j + 1).gemstoneType && GetGemstone(i, j).gemstoneType == GetGemstone(i, j + 2).gemstoneType)
				{
					AddMatches(GetGemstone(i, j));
					AddMatches(GetGemstone(i, j + 1));
					AddMatches(GetGemstone(i, j + 2));
					result = true;
				}
			}
		}
		return result;
	}

	private bool CheckVerticalMatches()
	{
		bool result = false;
		for (int i = 0; i < columNum; i++)
		{
			for (int j = 0; j < rowNum - 2; j++)
			{
				if (GetGemstone(j, i).gemstoneType == GetGemstone(j + 1, i).gemstoneType && GetGemstone(j, i).gemstoneType == GetGemstone(j + 2, i).gemstoneType)
				{
					AddMatches(GetGemstone(j, i));
					AddMatches(GetGemstone(j + 1, i));
					AddMatches(GetGemstone(j + 2, i));
					result = true;
				}
			}
		}
		return result;
	}

	private void AddMatches(Gemstone c)
	{
		if (matchesGemstone == null)
		{
			matchesGemstone = new ArrayList();
		}
		if (matchesGemstone.IndexOf(c) == -1)
		{
			matchesGemstone.Add(c);
		}
	}

	private void RemoveMatches()
	{
		if (计分板 != null)
		{
			switch (matchesGemstone.Count)
			{
			case 3:
				计分板.GetComponent<Text>().text = (int.Parse(计分板.GetComponent<Text>().text) + 低计分).ToString();
				break;
			case 4:
				计分板.GetComponent<Text>().text = (int.Parse(计分板.GetComponent<Text>().text) + 低计分 + 2).ToString();
				break;
			case 5:
				计分板.GetComponent<Text>().text = (int.Parse(计分板.GetComponent<Text>().text) + 低计分 + 4).ToString();
				break;
			case 6:
				计分板.GetComponent<Text>().text = (int.Parse(计分板.GetComponent<Text>().text) + 低计分 + 6).ToString();
				break;
			case 7:
				计分板.GetComponent<Text>().text = (int.Parse(计分板.GetComponent<Text>().text) + 低计分 + 8).ToString();
				break;
			case 8:
				计分板.GetComponent<Text>().text = (int.Parse(计分板.GetComponent<Text>().text) + 低计分 + 10).ToString();
				break;
			case 9:
				计分板.GetComponent<Text>().text = (int.Parse(计分板.GetComponent<Text>().text) + 低计分 + 12).ToString();
				break;
			case 10:
				计分板.GetComponent<Text>().text = (int.Parse(计分板.GetComponent<Text>().text) + 低计分 + 14).ToString();
				break;
			case 11:
				计分板.GetComponent<Text>().text = (int.Parse(计分板.GetComponent<Text>().text) + 低计分 + 16).ToString();
				break;
			case 12:
				计分板.GetComponent<Text>().text = (int.Parse(计分板.GetComponent<Text>().text) + 低计分 + 18).ToString();
				break;
			case 13:
				计分板.GetComponent<Text>().text = (int.Parse(计分板.GetComponent<Text>().text) + 低计分 + 20).ToString();
				break;
			case 14:
				计分板.GetComponent<Text>().text = (int.Parse(计分板.GetComponent<Text>().text) + 低计分 + 22).ToString();
				break;
			}
		}
		for (int i = 0; i < matchesGemstone.Count; i++)
		{
			Gemstone c = matchesGemstone[i] as Gemstone;
			RemoveGemstone(c);
		}
		matchesGemstone = new ArrayList();
		StartCoroutine(WaitForCheckMatchesAgain());
	}

	private IEnumerator WaitForCheckMatchesAgain()
	{
		yield return new WaitForSeconds(0.5f);
		if ((CheckHorizontalMatches() || CheckVerticalMatches()) && 是否消2)
		{
			RemoveMatches();
		}
	}

	private void RemoveGemstone(Gemstone c)
	{
		c.Dispose();
		base.gameObject.GetComponent<AudioSource>().PlayOneShot(match3Clip);
		for (int i = c.rowIndex + 1; i < rowNum; i++)
		{
			Gemstone gemstone = GetGemstone(i, c.columIndex);
			gemstone.rowIndex--;
			SetGemstone(gemstone.rowIndex, gemstone.columIndex, gemstone);
			gemstone.TweenToPostion(gemstone.rowIndex, gemstone.columIndex);
		}
		Gemstone gemstone2 = AddGemstone(rowNum, c.columIndex);
		gemstone2.rowIndex--;
		SetGemstone(gemstone2.rowIndex, gemstone2.columIndex, gemstone2);
		gemstone2.TweenToPostion(gemstone2.rowIndex, gemstone2.columIndex);
	}

	public Gemstone GetGemstone(int rowIndex, int columIndex)
	{
		return (gemstoneList[rowIndex] as ArrayList)[columIndex] as Gemstone;
	}

	public void SetGemstone(int rowIndex, int columIndex, Gemstone c)
	{
		(gemstoneList[rowIndex] as ArrayList)[columIndex] = c;
	}

	public void Exchange(Gemstone c1, Gemstone c2)
	{
		base.gameObject.GetComponent<AudioSource>().PlayOneShot(swapClip);
		SetGemstone(c1.rowIndex, c1.columIndex, c2);
		SetGemstone(c2.rowIndex, c2.columIndex, c1);
		int rowIndex = c1.rowIndex;
		c1.rowIndex = c2.rowIndex;
		c2.rowIndex = rowIndex;
		int columIndex = c1.columIndex;
		c1.columIndex = c2.columIndex;
		c2.columIndex = columIndex;
		c1.TweenToPostion(c1.rowIndex, c1.columIndex);
		c2.TweenToPostion(c2.rowIndex, c2.columIndex);
	}
}
[DisallowMultipleComponent]
[AddComponentMenu("")]
public class PoolObject : MonoBehaviour
{
	public string poolName;

	public bool isPooled;
}
public enum PoolInflationType
{
	INCREMENT,
	DOUBLE
}
internal class Pool
{
	private Stack<PoolObject> availableObjStack = new Stack<PoolObject>();

	private GameObject rootObj;

	private float lastUsedTime = -1f;

	private PoolInflationType inflationType;

	private string poolName;

	private int objectsInUse;

	public Pool(string poolName, GameObject poolObjectPrefab, GameObject rootPoolObj, int initialCount, PoolInflationType type)
	{
		lastUsedTime = Time.time;
		if (!(poolObjectPrefab == null))
		{
			this.poolName = poolName;
			inflationType = type;
			rootObj = new GameObject(poolName + "Pool");
			rootObj.transform.SetParent(rootPoolObj.transform, worldPositionStays: false);
			GameObject gameObject = UnityEngine.Object.Instantiate(poolObjectPrefab);
			PoolObject poolObject = gameObject.GetComponent<PoolObject>();
			if (poolObject == null)
			{
				poolObject = gameObject.AddComponent<PoolObject>();
			}
			poolObject.poolName = poolName;
			AddObjectToPool(poolObject);
			populatePool(Mathf.Max(initialCount, 1));
		}
	}

	private void AddObjectToPool(PoolObject po)
	{
		po.gameObject.SetActive(value: false);
		po.gameObject.name = poolName;
		availableObjStack.Push(po);
		po.isPooled = true;
		po.gameObject.transform.SetParent(rootObj.transform, worldPositionStays: false);
	}

	private void populatePool(int initialCount)
	{
		for (int i = 0; i < initialCount; i++)
		{
			PoolObject po = UnityEngine.Object.Instantiate(availableObjStack.Peek());
			AddObjectToPool(po);
		}
	}

	public GameObject NextAvailableObject(bool autoActive)
	{
		lastUsedTime = Time.time;
		PoolObject poolObject = null;
		if (availableObjStack.Count > 1)
		{
			poolObject = availableObjStack.Pop();
		}
		else
		{
			int num = 0;
			if (inflationType == PoolInflationType.INCREMENT)
			{
				num = 1;
			}
			else if (inflationType == PoolInflationType.DOUBLE)
			{
				num = availableObjStack.Count + Mathf.Max(objectsInUse, 0);
			}
			if (num > 0)
			{
				populatePool(num);
				poolObject = availableObjStack.Pop();
			}
		}
		GameObject gameObject = null;
		if (poolObject != null)
		{
			objectsInUse++;
			poolObject.isPooled = false;
			gameObject = poolObject.gameObject;
			if (autoActive)
			{
				gameObject.SetActive(value: true);
			}
		}
		return gameObject;
	}

	public void ReturnObjectToPool(PoolObject po)
	{
		if (poolName.Equals(po.poolName))
		{
			objectsInUse--;
			if (!po.isPooled)
			{
				AddObjectToPool(po);
			}
		}
		else
		{
			UnityEngine.Debug.Log($"Trying to add object to incorrect pool {po.poolName} {poolName}");
		}
	}
}
[DisallowMultipleComponent]
[AddComponentMenu("")]
public class ResourceManager : MonoBehaviour
{
	private Dictionary<string, Pool> poolDict = new Dictionary<string, Pool>();

	private static ResourceManager mInstance;

	public static ResourceManager Instance
	{
		get
		{
			if (mInstance == null)
			{
				mInstance = new GameObject("ResourceManager", typeof(ResourceManager)).GetComponent<ResourceManager>();
				if (UnityEngine.Application.isPlaying)
				{
					UnityEngine.Object.DontDestroyOnLoad(mInstance.gameObject);
				}
				else
				{
					UnityEngine.Debug.LogWarning("[ResourceManager] You'd better ignore ResourceManager in Editor mode");
				}
			}
			return mInstance;
		}
	}

	public void InitPool(string poolName, int size, PoolInflationType type = PoolInflationType.DOUBLE)
	{
		if (!poolDict.ContainsKey(poolName))
		{
			GameObject gameObject = Resources.Load<GameObject>(poolName);
			if (gameObject == null)
			{
				UnityEngine.Debug.Log("[ResourceManager] Invalide prefab name for pooling :" + poolName);
			}
			else
			{
				poolDict[poolName] = new Pool(poolName, gameObject, base.gameObject, size, type);
			}
		}
	}

	public GameObject GetObjectFromPool(string poolName, bool autoActive = true, int autoCreate = 0)
	{
		GameObject result = null;
		if (!poolDict.ContainsKey(poolName) && autoCreate > 0)
		{
			InitPool(poolName, autoCreate, PoolInflationType.INCREMENT);
		}
		if (poolDict.ContainsKey(poolName))
		{
			result = poolDict[poolName].NextAvailableObject(autoActive);
		}
		return result;
	}

	public void ReturnObjectToPool(GameObject go)
	{
		PoolObject component = go.GetComponent<PoolObject>();
		if (!(component == null))
		{
			Pool value = null;
			if (poolDict.TryGetValue(component.poolName, out value))
			{
				value.ReturnObjectToPool(component);
			}
		}
	}

	public void ReturnTransformToPool(Transform t)
	{
		if (!(t == null))
		{
			t.gameObject.SetActive(value: false);
			t.SetParent(null, worldPositionStays: false);
			ReturnObjectToPool(t.gameObject);
		}
	}
}
public class FollowTarget : MonoBehaviour
{
	public float smoothing = 3f;

	public Transform player;

	private void Start()
	{
	}

	private void FixedUpdate()
	{
		Vector3 b = player.position + new Vector3(0f, 0f, -2f);
		base.transform.position = Vector3.Lerp(base.transform.position, b, smoothing * Time.deltaTime);
	}
}
public class Overrid_ETC
{
	public void 多功能()
	{
		new ETCAxis("").directTransform = Manager._instance.Down.当前选择.transform;
	}
}
public class showSelected2 : MonoBehaviour
{
	public Shader selectedShader;

	public Color outterColor;

	public Color myColor;

	public Shader myShader;

	private bool Selected;

	public static showSelected2 _instance;

	private GameObject 对象;

	private void Awake()
	{
		_instance = this;
	}

	public string 炫()
	{
		if (对象 == null || 对象 != Manager._instance.Down.当前选择)
		{
			myColor = Manager._instance.Down.当前选择.GetComponent<MeshRenderer>().material.color;
			myShader = Manager._instance.Down.当前选择.GetComponent<MeshRenderer>().material.shader;
			Manager._instance.Down.当前选择.GetComponent<MeshRenderer>().material.shader = selectedShader;
			Manager._instance.Down.当前选择.GetComponent<MeshRenderer>().material.SetColor("_RimColor", outterColor);
			Manager._instance.Down.当前选择.GetComponent<MeshRenderer>().material.SetColor("_MainColor", myColor);
		}
		对象 = Manager._instance.Down.当前选择;
		return "炫完";
	}

	public string 不()
	{
		对象 = null;
		Manager._instance.Down.当前选择.GetComponent<MeshRenderer>().material.color = myColor;
		Manager._instance.Down.当前选择.GetComponent<MeshRenderer>().material.shader = myShader;
		return "不完";
	}

	public void Change_Color()
	{
		if ((bool)检测._instance.Main_Obj)
		{
			myColor = 检测._instance.Main_Obj.GetComponent<MeshRenderer>().material.color;
			myShader = 检测._instance.Main_Obj.GetComponent<MeshRenderer>().material.shader;
			if (!selectedShader)
			{
				base.enabled = false;
				return;
			}
			检测._instance.Main_Obj.GetComponent<MeshRenderer>().material.shader = selectedShader;
			检测._instance.Main_Obj.GetComponent<MeshRenderer>().material.SetColor("_RimColor", outterColor);
			检测._instance.Main_Obj.GetComponent<MeshRenderer>().material.SetColor("_MainColor", myColor);
			MonoBehaviour.print("dudu");
		}
	}
}
public class SpeechRecognition : MonoBehaviour
{
	[Header("语音识别")]
	public string url = "https://openapi.baidu.com/oauth/2.0/token";

	public string token;

	public AudioClip Setclip;

	public AudioSource 播放器;

	public string 识别结果;

	private int 几数;

	public GameObject 声音;

	public AudioClip DownButtonClip1;

	public float Volume
	{
		get
		{
			if (Microphone.IsRecording(null))
			{
				int num = 128;
				float[] array = new float[num];
				int offsetSamples = Microphone.GetPosition(null) - (num + 1);
				播放器.clip.GetData(array, offsetSamples);
				float num2 = 0f;
				for (int i = 0; i < num; i++)
				{
					float num3 = array[i];
					if (num2 < num3)
					{
						num2 = num3;
					}
				}
				return num2 * 99f;
			}
			return 0f;
		}
	}

	private IEnumerator Start()
	{
		UnityEngine.Debug.Log("xxxxxxxxxxxxxxxxxxxxxx不应出现xxxxxxxxxxxxxxxxxxxxxxxxxxxx");
		WWWForm wWWForm = new WWWForm();
		wWWForm.AddField("grant_type", "client_credentials");
		wWWForm.AddField("client_id", "ZtaqX3ww4DQp6A6Ep3B2H2UgivGRWSKb");
		wWWForm.AddField("client_secret", "9znfO0RU3q9uppQb6YKNDdU69vgm1YTG");
		using UnityWebRequest getData = UnityWebRequest.Post(url, wWWForm);
		yield return getData.SendWebRequest();
		if (getData.result != UnityWebRequest.Result.Success)
		{
			UnityEngine.Debug.Log("【语】错：" + getData.error);
			yield break;
		}
		UnityEngine.Debug.Log("【语】肉：" + getData.downloadHandler.text);
		JsonData jsonData = JsonMapper.ToObject(getData.downloadHandler.text);
		token = (string)jsonData["access_token"];
	}

	public void 开始录音()
	{
		播放器.clip = Microphone.Start(Microphone.devices[0], loop: false, 10, 8000);
		声音.SetActive(value: true);
		FPSPlayerControl2._instance.audioSource.PlayOneShot(DownButtonClip1, 1f);
		MonoBehaviour.print("dada...");
	}

	public void 结束录音()
	{
		Microphone.End(Microphone.devices[0]);
		存储录音内容();
		声音.SetActive(value: false);
	}

	public void 录音中()
	{
	}

	public void 存储录音内容()
	{
		float[] array = new float[播放器.clip.samples];
		播放器.clip.GetData(array, 0);
		short[] array2 = new short[array.Length];
		byte[] array3 = new byte[array.Length * 2];
		int num = 32767;
		for (int i = 0; i < array.Length; i++)
		{
			array2[i] = (short)(array[i] * (float)num);
			_ = new byte[2];
			BitConverter.GetBytes(array2[i]).CopyTo(array3, i * 2);
		}
		StartCoroutine(语音识别(array3));
	}

	private IEnumerator 语音识别(byte[] postData)
	{
		WWWForm wWWForm = new WWWForm();
		Dictionary<string, string> headers = wWWForm.headers;
		headers["Method"] = "POST";
		headers["Content-Type"] = "audio/wav;rate=8000";
		wWWForm.AddBinaryData("fileUpload", postData, "flacFile", "audio/wav; rate=8000");
		MonoBehaviour.print("语音识别");
		using UnityWebRequest getData = UnityWebRequest.Post("http://vop.baidu.com/server_api?lan=zh&cuid=vr&token=" + token, wWWForm);
		getData.SetRequestHeader("Content-Type", "audio/wav; rate=8000");
		yield return getData.SendWebRequest();
		if (getData.result != UnityWebRequest.Result.Success)
		{
			UnityEngine.Debug.Log("⒈【语】错：" + getData.error);
		}
		else
		{
			Regex regex = new Regex("[一-龥]+");
			string text = "";
			foreach (Match item in regex.Matches(getData.downloadHandler.text))
			{
				text += item.Value;
			}
			识别结果 = text;
		}
		MonoBehaviour.print(识别结果 + "识别结果..");
		Manager._instance.Vr2045.虚号输入框.GetComponent<InputField>().text = 识别结果;
	}
}
public class Test : MonoBehaviour
{
	private enum MouseButton
	{
		MouseButton_Left,
		MouseButton_Right,
		MouseButton_Midle
	}

	public float Distance = 5f;

	private float SpeedX = 240f;

	private float SpeedY = 120f;

	private float MinLimitY = -180f;

	private float MaxLimitY = 180f;

	private float mX;

	private float mY;

	private float MaxDistance = 10f;

	private float MinDistance = 1.5f;

	private float ZoomSpeed = 2f;

	public bool isNeedDamping = true;

	public float Damping = 10f;

	private Quaternion mRotation;

	private float MoveSpeed = 5f;

	private Vector3 mScreenPoint;

	private Vector3 mOffset;

	private float camPostion_x;

	private float camPostion_y;

	private void Start()
	{
		mX = base.transform.eulerAngles.x;
		mY = base.transform.eulerAngles.y;
	}

	private void Update()
	{
		if (Input.GetMouseButton(2))
		{
			MonoBehaviour.print("按下中间");
			base.transform.Translate(Vector3.left * Input.GetAxis("Mouse X"));
			base.transform.Translate(Vector3.down * Input.GetAxis("Mouse Y"));
		}
		if (Input.GetAxis("Mouse ScrollWheel") == 0f)
		{
			return;
		}
		if (Input.GetAxis("Mouse ScrollWheel") < 0f)
		{
			if (Camera.main.fieldOfView <= 100f)
			{
				Camera.main.fieldOfView += 2f;
			}
			if (Camera.main.orthographicSize <= 20f)
			{
				Camera.main.orthographicSize += 0.5f;
			}
		}
		if (Input.GetAxis("Mouse ScrollWheel") > 0f)
		{
			if (Camera.main.fieldOfView > 2f)
			{
				Camera.main.fieldOfView -= 2f;
			}
			if (Camera.main.orthographicSize >= 1f)
			{
				Camera.main.orthographicSize -= 0.5f;
			}
		}
	}

	private float ClampAngle(float angle, float min, float max)
	{
		if (angle < -360f)
		{
			angle += 360f;
		}
		if (angle > 360f)
		{
			angle -= 360f;
		}
		return Mathf.Clamp(angle, min, max);
	}
}
public class testing : MonoBehaviour
{
	public ETCJoystick joystick;

	public GameObject 多功能;

	private void Update()
	{
		if (Input.GetMouseButtonDown(0))
		{
			MonoBehaviour.print("hehe..");
			Invoke("等待", 0.2f);
		}
		if (Input.GetMouseButtonUp(0))
		{
			MonoBehaviour.print("youeijojflasf....");
			Invoke("等待", 0.2f);
		}
	}

	private void UpdateControlState()
	{
		MonoBehaviour.print(joystick._realVisible + "...");
		if (joystick._realVisible)
		{
			多功能.SetActive(value: true);
			MonoBehaviour.print("dada,,");
		}
		else
		{
			多功能.SetActive(value: false);
		}
	}

	private void 等待()
	{
		UpdateControlState();
	}
}
public class UWebView : MonoBehaviour
{
	public string url = "https://ssl.22.cn22.cn";

	public GameObject UniWebViewObjectPrefab;

	private bool 是否加载中;

	private bool 是否显示网页;

	public Texture2D Img;

	private bool 是否点击按钮;

	private GameObject UniWebViewObject;

	public GUISkin customSkin;

	private UniWebView webView;

	private void OnGUI()
	{
		GUI.skin = customSkin;
		if (是否显示网页)
		{
			GUIStyle gUIStyle = new GUIStyle();
			gUIStyle.normal.background = Img;
			GUI.Label(new Rect(0f, 0f, UnityEngine.Screen.width, UnityEngine.Screen.height), "", gUIStyle);
			if (GUI.Button(new Rect((float)(UnityEngine.Screen.width - 20) - (float)UnityEngine.Screen.width * 0.02f, 20f - (float)UnityEngine.Screen.width * 0.02f, (float)UnityEngine.Screen.width * 0.04f, (float)UnityEngine.Screen.width * 0.04f), "", "end"))
			{
				是否显示网页 = false;
				CloseWeb(webView);
			}
		}
		if (是否加载中)
		{
			GUIStyle gUIStyle2 = new GUIStyle();
			gUIStyle2.fontSize = 30;
			gUIStyle2.normal.textColor = Color.red;
			GUI.Label(new Rect(50f, 100f, (float)UnityEngine.Screen.width * 0.2f, (float)UnityEngine.Screen.height * 0.2f), "加载中.....", gUIStyle2);
		}
	}

	public void OpenWebView()
	{
		MonoBehaviour.print("webview..");
		是否加载中 = true;
		GameObject.Find("WebView");
		if (UniWebViewObject == null)
		{
			UniWebViewObject = UnityEngine.Object.Instantiate(UniWebViewObjectPrefab);
		}
		if ((bool)UniWebViewObject.GetComponent<UniWebView>())
		{
			webView = UniWebViewObject.GetComponent<UniWebView>();
		}
		else
		{
			webView = UniWebViewObject.AddComponent<UniWebView>();
		}
		webView.OnLoadComplete += OnLoadComplete;
		webView.InsetsForScreenOreitation += InsetsForScreenOreitation;
		webView.Load(url);
	}

	private void OnLoadComplete(UniWebView webView, bool success, string errorMessage)
	{
		if (success)
		{
			webView.Show();
			是否加载中 = false;
			是否显示网页 = true;
		}
		else
		{
			UnityEngine.Debug.Log("Something wrong in webview loading: " + errorMessage);
		}
	}

	private void CloseWeb(UniWebView webView)
	{
		webView.Hide();
		UnityEngine.Object.Destroy(webView);
		webView.InsetsForScreenOreitation -= InsetsForScreenOreitation;
		webView = null;
	}

	private UniWebViewEdgeInsets InsetsForScreenOreitation(UniWebView webView, UniWebViewOrientation orientation)
	{
		return new UniWebViewEdgeInsets(30, 30, 30, 30);
	}
}
public class WebCamManager : MonoBehaviour
{
	public static WebCamManager _instance;

	private WebCamTexture camTexture;

	private Image img;

	public GameObject quad;

	private void Start()
	{
		_instance = this;
	}

	public IEnumerator CallCamera()
	{
		yield return UnityEngine.Application.RequestUserAuthorization(UserAuthorization.WebCam);
		if (UnityEngine.Application.HasUserAuthorization(UserAuthorization.WebCam))
		{
			img = GetComponentInChildren<Image>();
			string text = WebCamTexture.devices[0].name;
			UnityEngine.Debug.Log(text);
			camTexture = new WebCamTexture(text);
			img.canvasRenderer.SetTexture(camTexture);
			camTexture.Play();
		}
	}
}
public class ColorRevert
{
	public static Color ToColor(string colorName)
	{
		if (colorName.StartsWith("#"))
		{
			colorName = colorName.Replace("#", string.Empty);
		}
		int num = int.Parse(colorName, NumberStyles.HexNumber);
		return new Color((int)Convert.ToByte((num >> 16) & 0xFF), (int)Convert.ToByte((num >> 8) & 0xFF), (int)Convert.ToByte(num & 0xFF), 1f);
	}
}
public class DWay
{
	private static DWay instance;

	private string webpaths;

	private string 数字下载类型;

	private string 文字下载类型;

	private static readonly object synRoot = new object();

	public static DWay GetInstance()
	{
		if (instance == null)
		{
			lock (synRoot)
			{
				if (instance == null)
				{
					instance = new DWay();
				}
			}
		}
		return instance;
	}

	public string 玩类型(string 参数)
	{
		UnityEngine.Debug.LogWarning("玩类型........." + 参数);
		string result = "";
		bool flag = 参数.IndexOf('号') != -1;
		bool flag2 = Regex.IsMatch(参数, "[\\u4e00-\\u9fa5]+");
		if (flag2 && !flag)
		{
			string path = "http://vr2045.com/index.php?s=/Base/getdata.html&玩=" + 参数;
			Manager._instance.Down.载(Manager._instance.Down.下载物体(path, "文本模型", "游戏"));
		}
		else if (!flag2 && !flag)
		{
			result = "6011" + 参数;
		}
		else if (flag)
		{
			string[] array = 参数.Split('号');
			result = "6011" + array[1];
		}
		return result;
	}

	public string 判断类型操作(Dictionary<string, float> 参数)
	{
		string text = Manager._instance.Vr2045.余字(Manager._instance.Down.模名字);
		string 参数2 = Manager._instance.Down.模名字.Substring(0, 1);
		if (参数.ContainsKey(text))
		{
			判断类型(参数2);
			Manager._instance.Down.载(Manager._instance.Down.下载物体(Manager._instance.Down.下载测试模型(参数[text].ToString()), text, ""));
		}
		else
		{
			判断虚号类型(Manager._instance.Down.模名字);
		}
		return "完";
	}

	public string 判断虚号类型(string 参数)
	{
		string text = 参数.Substring(0, 1);
		Match match = new Regex("(?<=" + text + ")[一-叶司-龟0-9]+").Match(参数);
		bool flag = 参数.IndexOf('号') != -1;
		bool flag2 = Regex.IsMatch(match.ToString(), "[\\u4e00-\\u9fa5]+");
		string text2 = 判断类型(text);
		UnityEngine.Debug.Log(text2 + "判断字符类型...");
		if (flag2 && !flag)
		{
			UnityEngine.Debug.Log("中文。。。。。。");
			Manager._instance.Down.模型名字 = match.ToString();
			UnityEngine.Debug.Log(Manager._instance.Down.模型名字);
			UnityEngine.Debug.Log(text2 + "判断字符类型");
			if (text2 == "文本")
			{
				string mname = 参数.Substring(1, 参数.Length - 1);
				Manager._instance.Down.实现内容文本(text2, mname, match.ToString());
			}
			else
			{
				Manager._instance.Down.载(Manager._instance.Down.下载物体(文字网址类型(match.ToString()), "文本模型", text2));
			}
		}
		else if (!flag2 && !flag)
		{
			UnityEngine.Debug.Log("数字..........");
			if (text2 == "文本")
			{
				string mname2 = 参数.Substring(1, 参数.Length - 1);
				Manager._instance.Down.实现内容文本(text2, mname2, match.ToString());
			}
			else
			{
				Manager._instance.Down.载(Manager._instance.Down.下载物体(Manager._instance.Down.下载测试模型(match.ToString()), text2, ""));
			}
		}
		else if (flag)
		{
			string[] array = 参数.Split('号');
			UnityEngine.Debug.Log(array[0].Length + "length..");
			if (text2 == "文本")
			{
				if (array[0].Length > 1)
				{
					string name = array[0].Substring(1, array[0].Length - 1);
					Manager._instance.Down.载(Manager._instance.Down.下载物体(文本网址(array[1]), text2, name));
				}
				else
				{
					Manager._instance.Down.载(Manager._instance.Down.下载物体(文本网址(array[1]), text2, array[1]));
				}
			}
			else if (array[0].Length > 1)
			{
				UnityEngine.Debug.Log(text2 + "判断字符类型..");
				Manager._instance.Down.载(Manager._instance.Down.下载物体(Manager._instance.Down.下载测试模型(array[1]), text2, match.ToString()));
			}
			else
			{
				Manager._instance.Down.载(Manager._instance.Down.下载物体(Manager._instance.Down.下载测试模型(array[1]), text2, array[1]));
			}
		}
		UnityEngine.Debug.Log(match.ToString() + "Match....");
		return "完";
	}

	private string 文本网址(string 参数)
	{
		string text = "http://diywebapp.com/app/vr2045.php?id=" + 参数;
		UnityEngine.Debug.Log("文本网址()" + text);
		return text;
	}

	private string 文字网址类型(string 参数)
	{
		string text = "vr2045.com/index.php?s=/Base/getdata.html&" + 文字下载类型 + "=" + 参数;
		UnityEngine.Debug.Log("文本网址()" + text);
		return text;
	}

	private string 判断类型(string 参数)
	{
		string result = "";
		switch (参数)
		{
		case "看":
			result = "视频";
			数字下载类型 = "ogv";
			文字下载类型 = "vr9";
			break;
		case "听":
			result = "音乐";
			数字下载类型 = "ogg";
			文字下载类型 = "vr8";
			break;
		case "图":
			result = "图片";
			数字下载类型 = "png";
			break;
		case "模":
			result = "模型";
			文字下载类型 = "vr2";
			break;
		case "文":
			result = "文本";
			break;
		case "买":
			result = "买模型";
			数字下载类型 = "ab";
			break;
		case "动":
			result = "动作";
			break;
		case "效":
			result = "特效";
			break;
		case "令":
			result = "命令";
			break;
		case "人":
			result = "人物";
			数字下载类型 = "ab";
			break;
		}
		return result;
	}
}
public class GameObjectPool : MonoBehaviour
{
	private List<GameObject> pools = new List<GameObject>();

	public GameObject names;

	public GameObject obj;

	private static GameObjectPool instance;

	private static int index;

	private GameObject 当前唯一区对象;

	private GameObjectPool()
	{
	}

	public static GameObjectPool GetInstance()
	{
		if (instance == null)
		{
			GameObject gameObject = new GameObject("GameObjectPool");
			Vector3 当前始 = Manager._instance.Trans_form.当前始;
			UnityEngine.Debug.Log(当前始.ToString() + "pool...");
			gameObject.transform.localPosition = Manager._instance.Trans_form.当前始;
			if ((bool)Manager._instance.Trans_form.区对象)
			{
				gameObject.transform.parent = Manager._instance.Trans_form.区对象.transform;
			}
			instance = gameObject.AddComponent<GameObjectPool>();
		}
		return instance;
	}

	public GameObject MyInstantiate(UnityEngine.Object name)
	{
		if (pools.Count == 0)
		{
			MonoBehaviour.print("如果对象池中没有对象");
			GameObject gameObject = UnityEngine.Object.Instantiate(name) as GameObject;
			gameObject.AddComponent<Rigidbody>();
			gameObject.GetComponent<Rigidbody>().useGravity = false;
			gameObject.AddComponent<BoxCollider>();
			gameObject.GetComponent<BoxCollider>().isTrigger = true;
			Material[] materials = gameObject.GetComponent<MeshRenderer>().materials;
			for (int i = 0; i < materials.Length; i++)
			{
				materials[i].shader = Shader.Find("Standard");
			}
			return gameObject;
		}
		obj = pools[0];
		MonoBehaviour.print(obj.name + "object.....");
		obj.SetActive(value: true);
		pools.Remove(obj);
		return obj;
	}

	public void MyDisable(GameObject name)
	{
		names = name;
		MonoBehaviour.print(name.GetComponent<Rigidbody>().velocity);
		name.GetComponent<Rigidbody>().velocity = new Vector3(0f, 0f, 0f);
		name.SetActive(value: false);
		pools.Add(name);
		MonoBehaviour.print(pools.Count + "poools");
	}
}
public class GameObjectPool1 : MonoBehaviour
{
	private List<GameObject> pools1 = new List<GameObject>();

	public GameObject names;

	public GameObject obj;

	private static GameObjectPool1 instance;

	private GameObjectPool1()
	{
	}

	public static GameObjectPool1 GetInstance()
	{
		if (instance == null)
		{
			instance = new GameObject("GameObjectPool1").AddComponent<GameObjectPool1>();
		}
		return instance;
	}

	public GameObject MyInstantiate(UnityEngine.Object name)
	{
		if (pools1.Count == 0)
		{
			MonoBehaviour.print("22222222222222222222222222222222222222222222222");
			MonoBehaviour.print("子弹(Clone)......");
			GameObject gameObject = UnityEngine.Object.Instantiate(name) as GameObject;
			gameObject.transform.localPosition = Manager._instance.Trans_form.真正的子弹位置和角度.transform.position;
			gameObject.transform.localRotation = Manager._instance.Trans_form.真正的子弹位置和角度.transform.rotation;
			gameObject.AddComponent<Rigidbody>();
			gameObject.GetComponent<Rigidbody>().useGravity = false;
			gameObject.AddComponent<BoxCollider>();
			gameObject.GetComponent<BoxCollider>().isTrigger = true;
			Material[] materials = gameObject.GetComponent<MeshRenderer>().materials;
			for (int i = 0; i < materials.Length; i++)
			{
				materials[i].shader = Shader.Find("Standard");
			}
			return gameObject;
		}
		MonoBehaviour.print("fjlsjff..f.......");
		obj = pools1[0];
		MonoBehaviour.print(obj.name + "object.....");
		obj.SetActive(value: true);
		pools1.Remove(obj);
		return obj;
	}

	public void MyDisable(GameObject name)
	{
		names = name;
		MonoBehaviour.print(name.GetComponent<Rigidbody>().velocity);
		name.GetComponent<Rigidbody>().velocity = new Vector3(0f, 0f, 0f);
		name.SetActive(value: false);
		pools1.Add(name);
		MonoBehaviour.print(pools1.Count + "poools");
	}
}
public class Manager : MonoBehaviour
{
	public static Manager _instance;

	public Vr2045 _vr2045;

	public Loop _loop;

	public YanFu _YanFu;

	public Trans_form _Transform;

	public Down _Down;

	public ButtonDown _ButtonDown;

	public JieMian _JieMain;

	public vr12888 _vr12888;

	public Vr2045 Vr2045
	{
		get
		{
			return _vr2045;
		}
		set
		{
			_vr2045 = value;
		}
	}

	public Loop Loop
	{
		get
		{
			return _loop;
		}
		set
		{
			_loop = value;
		}
	}

	public YanFu YanFu
	{
		get
		{
			return _YanFu;
		}
		set
		{
			_YanFu = value;
		}
	}

	public Trans_form Trans_form
	{
		get
		{
			return _Transform;
		}
		set
		{
			_Transform = value;
		}
	}

	public Down Down
	{
		get
		{
			return _Down;
		}
		set
		{
			_Down = value;
		}
	}

	public ButtonDown ButtonDown
	{
		get
		{
			return _ButtonDown;
		}
		set
		{
			_ButtonDown = value;
		}
	}

	public JieMian JieMian
	{
		get
		{
			return _JieMain;
		}
		set
		{
			_JieMain = value;
		}
	}

	public vr12888 vr12888
	{
		get
		{
			return _vr12888;
		}
		set
		{
			_vr12888 = value;
		}
	}

	private void Awake()
	{
		_instance = this;
	}
}
public class Mathes
{
	private static Mathes instance;

	private static readonly object syncRoot = new object();

	public static Mathes GetInstance()
	{
		if (instance == null)
		{
			lock (syncRoot)
			{
				if (instance == null)
				{
					instance = new Mathes();
				}
			}
		}
		return instance;
	}

	public float 绝对值(string 参数)
	{
		return Mathf.Abs(float.Parse(参数));
	}

	public float 反余弦(string 参数)
	{
		return Mathf.Acos(float.Parse(参数));
	}

	public float 反正弦(string 参数)
	{
		return Mathf.Asin(float.Parse(参数));
	}

	public float 反正切(string 参数)
	{
		return Mathf.Atan(float.Parse(参数));
	}

	public float 点角度(string 参数)
	{
		return Mathf.Atan(float.Parse(参数));
	}

	public float 上舍(string 参数)
	{
		return Mathf.Ceil(float.Parse(参数));
	}

	public float 余弦(string 参数)
	{
		return Mathf.Cos(float.Parse(参数));
	}

	public float 指数(string 参数)
	{
		return Mathf.Exp(float.Parse(参数));
	}

	public float 下舍(string 参数)
	{
		return Mathf.Floor(float.Parse(参数));
	}

	public float 自然对数(string 参数)
	{
		return Mathf.Log(float.Parse(参数));
	}

	public float 较大(string 参数)
	{
		float num = float.Parse(参数);
		return Mathf.Max(num);
	}

	public float 较小(string 参数)
	{
		float num = float.Parse(参数);
		return Mathf.Min(num);
	}

	public float 次方(string 参数)
	{
		string[] array = 参数.Split(',');
		float f = float.Parse(Manager._instance.Vr2045.判数字(array[0]));
		float p = float.Parse(Manager._instance.Vr2045.判数字(array[1]));
		return Mathf.Pow(f, p);
	}

	public float 随机()
	{
		return UnityEngine.Random.Range(0, 100);
	}

	public float 四舍(string 参数)
	{
		return Mathf.Round(float.Parse(参数));
	}

	public float 正弦(string 参数)
	{
		return Mathf.Sin(float.Parse(参数));
	}

	public float 平方根(string 参数)
	{
		return Mathf.Sqrt(float.Parse(参数));
	}

	public float 十底对数(string 参数)
	{
		return Mathf.Log10(float.Parse(参数));
	}

	public float 圆周率()
	{
		return MathF.PI;
	}

	public float 正切(string 参数)
	{
		return Mathf.Tan(float.Parse(参数));
	}
}
public class Bullet : MonoBehaviour
{
	private void Awake()
	{
		base.gameObject.GetComponent<MeshRenderer>().enabled = true;
		UnityEngine.Debug.Log("Bullet1:" + base.gameObject.activeInHierarchy);
	}

	private void OnEnable()
	{
		UnityEngine.Debug.Log("Bullet2:" + base.gameObject.activeInHierarchy);
		base.transform.localPosition = Manager._instance.Trans_form.真正的子弹位置和角度.transform.position;
		base.transform.localRotation = Manager._instance.Trans_form.真正的子弹位置和角度.transform.rotation;
		Manager._instance.Down.当前选择 = base.gameObject;
		base.gameObject.GetComponent<Rigidbody>().useGravity = false;
		MonoBehaviour.print("shidl...");
		foreach (string key in Manager._instance.Trans_form.典速度.Keys)
		{
			MonoBehaviour.print("lalal.....ddee..e");
			if (Manager._instance.Trans_form.典速度[key] >= 0f)
			{
				MonoBehaviour.print("dada...");
				Manager._instance.Trans_form.判断正速度方向(key);
			}
			else if (Manager._instance.Trans_form.典速度[key] < 0f)
			{
				MonoBehaviour.print("dada.111..");
				Manager._instance.Trans_form.判断负速度方向(key);
			}
		}
		StartCoroutine(DelayDisable(0.5f));
	}

	private IEnumerator DelayDisable(float time)
	{
		yield return new WaitForSeconds(time);
		GameObjectPool1.GetInstance().MyDisable(base.gameObject);
	}

	private void OnTriggerEnter(Collider other)
	{
		GameObject gameObject = other.gameObject;
		if ((bool)gameObject && Vr2045._instance.是否爆炸)
		{
			Vr2045._instance.爆(gameObject.name);
		}
	}
}
public class ButtonDown : MonoBehaviour
{
	public GameObject 按钮;

	public bool 是执行;

	public bool 是否虚令 = true;

	public bool 是虚代码;

	public void 执行(string 参数)
	{
		是执行 = true;
		是否虚令 = false;
		是虚代码 = false;
		UnityEngine.Debug.Log("⒈执行......");
	}

	public void 虚令(string 参数)
	{
		MonoBehaviour.print("⒉虚令......");
		是执行 = false;
		是否虚令 = true;
		是虚代码 = false;
	}

	public void 虚代码(string 参数)
	{
		MonoBehaviour.print("⒊虚代码......");
		是执行 = false;
		是否虚令 = false;
		是虚代码 = true;
	}
}
public class Down : MonoBehaviour
{
	public int 确定执一次;

	public string 当前虚号;

	public Dictionary<string, float> 典虚物 = new Dictionary<string, float>();

	public int 执行一次;

	private string 私串址;

	private WWW bundle;

	public GameObject 前全局对象;

	private List<string> listPath = new List<string>();

	private string[] names;

	public AssetBundleRequest request;

	public Transform 子弹位置;

	public GameObject 当前选择;

	public List<GameObject> 子弹库;

	public bool 是否按下佑;

	public bool 法宝之射;

	public string 模型名字;

	public string 模名字;

	public bool 是否虚令;

	public GameObject 下载提示1;

	public List<GameObject> DownList = new List<GameObject>();

	public bool 是否加快X;

	public bool 是否加快Y;

	public bool 是否减慢X;

	public bool 是否减慢Y;

	public int 照相机位置执行一次;

	public bool 是否文字;

	public List<string> listName = new List<string>();

	public int 名字数字;

	private bool 是否下载单个模型;

	public GameObject 命令对象;

	public GameObject 文本内容;

	public GameObject 多功能;

	public GameObject 多功能按钮;

	public GameObject 大地图;

	public GameObject 区域;

	public bool 旋转按钮;

	private bool 恢复旋转位置;

	private bool 旋转按钮1;

	public GameObject 合成;

	private bool 上移合成;

	private bool 下移合成;

	public GameObject 多功能加;

	private bool 是否命令按钮;

	private bool 是否广按钮;

	public List<GameObject> 多个按钮集合 = new List<GameObject>();

	public List<Sprite> 击中图片 = new List<Sprite>();

	private bool 是否收起大地图;

	private bool 是否点击收起;

	private bool 是否放下大地图;

	private bool 确定已经收起大地图;

	public GameObject 收起按钮;

	public bool 提示是否出现;

	public bool 是否为虚文;

	public AudioClip DownButtonClip1;

	public Sprite 人走图片;

	private bool 是否按下区域按钮;

	private void Start()
	{
		私串址 = UnityEngine.Application.streamingAssetsPath + "/" + 佐.逮.址() + "/";
	}

	private void Update()
	{
		if (是否收起大地图)
		{
			int num = 数据平台();
			大地图.transform.Translate(Vector2.up * num);
			Vector2 vector = new Vector3(-5.4f, -40f);
			收起按钮.transform.localPosition = Vector3.MoveTowards(收起按钮.transform.localPosition, vector, num + 4);
			if (大地图.transform.localPosition.y >= 280f)
			{
				是否收起大地图 = false;
				收起按钮.transform.localRotation = Quaternion.Euler(0f, 0f, 180f);
				确定已经收起大地图 = true;
			}
		}
		if (是否放下大地图)
		{
			int num2 = 数据平台();
			Vector3 target = new Vector3(-3.374681f, -30.00002f, 0f);
			Vector3 target2 = new Vector3(-5.4f, -279.1f, 0f);
			大地图.transform.localPosition = Vector3.MoveTowards(大地图.transform.localPosition, target, num2 + 6);
			收起按钮.transform.localPosition = Vector3.MoveTowards(收起按钮.transform.localPosition, target2, num2 + 1);
			if (大地图.transform.localPosition.y <= -30f)
			{
				是否放下大地图 = false;
				收起按钮.transform.localRotation = Quaternion.Euler(0f, 0f, 0f);
				确定已经收起大地图 = false;
			}
		}
		if (上移合成)
		{
			int num3 = 数据平台();
			合成.transform.Translate(Vector2.up * num3);
			收起按钮.transform.Translate(Vector2.up * num3);
			if (合成.transform.localPosition.y >= 200f)
			{
				上移合成 = false;
				旋转按钮1 = true;
			}
		}
		if (旋转按钮1)
		{
			多功能按钮.transform.Rotate(0f, 0f, 10f);
			float height = 多功能加.transform.GetComponent<RectTransform>().rect.height;
			float width = 多功能加.transform.GetComponent<RectTransform>().rect.width;
			height += 1f;
			width += 1f;
			if (height <= 70f)
			{
				多功能加.gameObject.GetComponent<RectTransform>().sizeDelta = new Vector2(height, width);
			}
			if (多功能按钮.transform.eulerAngles.z >= 225f)
			{
				多功能.SetActive(value: true);
				float x = 多功能.transform.localScale.x;
				x += 0.1f;
				if (x > 1f)
				{
					多功能.transform.localScale = new Vector3(1f, 1f, 1f);
					MonoBehaviour.print(多功能按钮.transform.eulerAngles.z + "..z..");
					if (多功能按钮.transform.eulerAngles.z <= 320f && 多功能按钮.transform.eulerAngles.z >= 319f)
					{
						旋转按钮1 = false;
					}
					MonoBehaviour.print("dada....." + 旋转按钮1);
				}
				else
				{
					多功能.transform.localScale = new Vector3(x, x, x);
				}
			}
		}
		if (下移合成)
		{
			Vector2 vector2 = new Vector2(3f, -119f);
			Vector3 target3 = new Vector3(-5.4f, -279.1f, 0f);
			int num4 = 数据平台();
			合成.transform.localPosition = Vector3.MoveTowards(合成.transform.localPosition, vector2, num4);
			收起按钮.transform.localPosition = Vector3.MoveTowards(收起按钮.transform.localPosition, target3, num4);
			if (合成.transform.localPosition.y <= -119f)
			{
				下移合成 = false;
			}
		}
		if (!恢复旋转位置)
		{
			return;
		}
		多功能按钮.transform.Rotate(0f, 0f, 10f);
		float height2 = 多功能加.transform.GetComponent<RectTransform>().rect.height;
		float width2 = 多功能加.transform.GetComponent<RectTransform>().rect.width;
		height2 -= 1f;
		width2 -= 1f;
		if (height2 >= 53f)
		{
			多功能加.gameObject.GetComponent<RectTransform>().sizeDelta = new Vector2(height2, width2);
		}
		float z = 多功能按钮.transform.eulerAngles.z;
		if (Mathf.Abs(z - 365f) >= 184f && Mathf.Abs(z - 365f) <= 186f)
		{
			恢复旋转位置 = false;
			if (!确定已经收起大地图)
			{
				下移合成 = true;
				return;
			}
			区域.SetActive(value: true);
			收起按钮.SetActive(value: true);
		}
	}

	private int 数据平台()
	{
		if (UnityEngine.Application.platform == RuntimePlatform.Android)
		{
			return 15;
		}
		if (UnityEngine.Application.platform == RuntimePlatform.IPhonePlayer)
		{
			return 25;
		}
		return 15;
	}

	public void 按钮功能(string 参数)
	{
		UnityEngine.Debug.Log(参数);
		if (Manager._instance.JieMian.是否开始事件 || Manager._instance.JieMian.是否结束倒计时 || Manager._instance.JieMian.按下屏幕 || Manager._instance.JieMian.是否碰到)
		{
			MonoBehaviour.print(参数.Substring(1, 参数.Length - 1) + "da...");
			MonoBehaviour.print(Manager._instance.JieMian.开始内容数据 + "Manager._instance.JieMian.开始内容数据...");
			if (参数.Substring(1, 参数.Length - 2) == Manager._instance.JieMian.开始内容数据)
			{
				MonoBehaviour.print("执行。。。。。");
				SendMessage(Manager._instance.Vr2045.首字(参数), Manager._instance.Vr2045.余字(参数));
			}
			else
			{
				MonoBehaviour.print("youmeyou...");
				Manager._instance.Vr2045.连接字符(参数);
			}
		}
		else
		{
			SendMessage(Manager._instance.Vr2045.首字(参数), Manager._instance.Vr2045.余字(参数));
		}
	}

	public void 确定()
	{
		下载提示1.SetActive(value: true);
		提示是否出现 = true;
		Manager._instance.Vr2045.几数据 = 0;
		Manager._instance.Vr2045.执行一次1 = 0;
		确定执一次++;
		if (确定执一次 != 1)
		{
			return;
		}
		当前虚号 = Manager._instance.Vr2045.虚号输入框.GetComponent<InputField>().text;
		确定执一次 = 0;
		string input = 当前虚号.Substring(0, 1);
		if (new Regex("^[一-龥]+$").IsMatch(input))
		{
			按钮功能(当前虚号);
		}
		else if (当前虚号.Length == 4)
		{
			GameObject gameObject = GameObject.Find("GameObjectPool");
			if ((bool)gameObject)
			{
				UnityEngine.Object.Destroy(gameObject);
			}
			是否为虚文 = true;
			虚文(当前虚号);
		}
		else
		{
			是否下载单个模型 = true;
			下载测试模型(当前虚号);
		}
	}

	public string 下载测试模型(string 参数 = "2011001")
	{
		string text = 私串址 + "vr" + 参数 + ".ab";
		if (是否下载单个模型)
		{
			是否下载单个模型 = false;
			载(下载物体(text, 参数, ""));
		}
		return text;
	}

	public void 下载模型(string 参数 = "2011001", string 参2 = "")
	{
		string text = 私串址 + "vr" + 参数 + ".ab";
		UnityEngine.Debug.Log("222222222下载模型:" + text);
		if (参2 == "")
		{
			参2 = 参数;
		}
		载(下载物体(text, 参2, ""));
	}

	public void 清除缓存(string 参数 = "")
	{
		Caching.ClearCache();
	}

	public void 清(string 参数 = "")
	{
		Manager._instance.Vr2045.是否为虚游戏 = false;
		if (参数 == "")
		{
			MonoBehaviour.print("清除..");
			if (Manager._instance.Vr2045.有重复执行)
			{
				Manager._instance.Vr2045.有重复执行 = false;
			}
			if (DownList.Count > 0)
			{
				foreach (GameObject down in DownList)
				{
					UnityEngine.Object.Destroy(down);
				}
				DownList = new List<GameObject>();
			}
			if (Manager._instance.Trans_form.区对象数组.Count > 0)
			{
				foreach (GameObject item in Manager._instance.Trans_form.区对象数组)
				{
					Manager._instance.Trans_form.区对象数组 = new List<GameObject>();
					UnityEngine.Object.Destroy(item);
				}
			}
		}
		else
		{
			UnityEngine.Object.Destroy(GameObject.Find("区" + 参数).gameObject);
		}
		清除缓存();
		Manager._instance.Vr2045.复原();
	}

	public void 隐(string 参数 = "")
	{
		if (参数 == "景")
		{
			GameObject.Find("Plane").gameObject.GetComponent<MeshRenderer>().enabled = false;
		}
	}

	public void 显(string 参数 = "")
	{
		if (参数 == "")
		{
			Manager._instance.Vr2045.输入框.transform.parent.gameObject.SetActive(value: true);
			下载提示1.SetActive(value: true);
		}
		else
		{
			UnityEngine.Debug.Log("出现....");
			GameObject.Find("Canvas").gameObject.transform.Find(参数).gameObject.SetActive(value: true);
		}
		if (参数 == "景")
		{
			GameObject.Find("Plane").gameObject.GetComponent<MeshRenderer>().enabled = true;
		}
	}

	private void 典(string 参数)
	{
		if (参数.Substring(0, 3) == "虚物之")
		{
			在数字后添加判断符(参数.Substring(3));
			string[] array = 在数字后添加判断符(参数.Substring(3)).Split(new char[1] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
			foreach (string 参数2 in array)
			{
				典虚物.Add(Manager._instance.Vr2045.判中文(参数2), float.Parse(Manager._instance.Vr2045.判数字(参数2)));
			}
		}
	}

	public string 在数字后添加判断符(string 参数)
	{
		new Regex("\\d+\\.?\\d*").Matches(参数);
		参数 = Regex.Replace(参数, "(\\d+\\.?\\d*)", "$1 ");
		参数 = Regex.Replace(参数, "[ \u3000\\t]+", " ");
		return 参数;
	}

	public void 虚文(string 参数)
	{
		MonoBehaviour.print("3333333333333333⒊【4899来这里】\uff3e☉\uff3e虚文：" + 参数 + Vr2045._instance.为本地全局文本);
		if (Vr2045._instance.为本地全局文本)
		{
			Vr2045._instance.取文本(Vr2045._instance.公广);
			return;
		}
		string text = "http://diywebapp.com/app/vr2045.php?id=" + 参数;
		MonoBehaviour.print("虚文()" + text);
		载(下载物体(text, "文本", ""));
	}

	public string 简(string 参数 = "")
	{
		string path = "http://diywebapp.com/app/vr2045.php?id=5258";
		载(下载物体(path, "虚文", ""));
		return "简完";
	}

	public string 汉(string 参数 = "")
	{
		string text = "http://diywebapp.com/app/vr2045.php?id=4897";
		MonoBehaviour.print("汉()" + text);
		载(下载物体(text, "虚文", ""));
		return "汉完";
	}

	private void 景(string 参数)
	{
		MonoBehaviour.print("景()" + 参数);
		if (参数 == "隐")
		{
			隐("景");
		}
		else if (参数 == "显")
		{
			显("景");
		}
		else
		{
			载(下载物体(下载测试模型(号分割(参数)), "场景", ""));
		}
	}

	private void 买(string 参数)
	{
		模名字 = "买" + 参数;
		DWay.GetInstance().判断类型操作(典虚物);
	}

	private string 号分割(string 参数)
	{
		return 参数.Split('号')[1];
	}

	private string 看(string 参数)
	{
		模名字 = "看" + 参数;
		_ = "vr2045.com/index.php?s=/Base/getdata.html&vr9=" + 参数;
		DWay.GetInstance().判断类型操作(典虚物);
		return "看完";
	}

	private string 听(string 参数)
	{
		模名字 = "听" + 参数;
		if (参数 == "激光发射声")
		{
			if (!Manager._instance.JieMian.MainCamera.GetComponent<AudioSource>())
			{
				Manager._instance.JieMian.MainCamera.AddComponent<AudioSource>().clip = Manager._instance.JieMian.激光声;
			}
			Manager._instance.JieMian.MainCamera.GetComponent<AudioSource>().Play();
		}
		else
		{
			DWay.GetInstance().判断虚号类型(模名字);
		}
		return "听完";
	}

	private string 图(string 参数)
	{
		UnityEngine.Debug.Log(Manager._instance.JieMian.是否为界面 + "...jiemian....");
		UnityEngine.Debug.Log("Img");
		if (Manager._instance.JieMian.是否为界面)
		{
			string 参数2 = "靠";
			当前选择 = Manager._instance.JieMian.创建图标(参数2);
			bool 是宽 = 参数.IndexOf("宽") != -1;
			bool 是高 = 参数.IndexOf("高") != -1;
			UnityEngine.Debug.Log("名字...");
			string text = Manager._instance.JieMian.添加物体大小和图片名(是宽, 是高, 参数);
			UnityEngine.Debug.Log("qqqqqqqqqqqqqqqqqq" + text + "...tu...");
			string path = "PNG/界面图/" + text;
			当前选择.name = text;
			Sprite sprite = Resources.Load(path, typeof(Sprite)) as Sprite;
			当前选择.GetComponent<Image>().sprite = sprite;
			Manager._instance.JieMian.物体的父类();
			Manager._instance.JieMian.锚点(Manager._instance.JieMian.靠几);
			Manager._instance.JieMian.判断是否有放();
			Manager._instance.JieMian.有换行();
		}
		else
		{
			模名字 = "图" + 参数;
			string path2 = "http://vr2045.com/png/vr" + 参数 + ".png";
			载(下载物体(path2, "图片", ""));
		}
		return "图完";
	}

	private string 人(string 参数)
	{
		模名字 = "人" + 参数;
		DWay.GetInstance().判断类型操作(典虚物);
		return "人完";
	}

	private string 文(string 参数)
	{
		if (Manager._instance.JieMian.是否为界面)
		{
			if (参数.IndexOf("几") != -1)
			{
				当前选择 = Manager._instance.JieMian.创建图标("靠文");
				bool 是宽 = 参数.IndexOf("宽") != -1;
				bool 是高 = 参数.IndexOf("高") != -1;
				string text = Manager._instance.JieMian.添加物体大小和图片名(是宽, 是高, 参数);
				string text2 = text.Substring(1, text.Length - 1);
				当前选择.name = text2;
				string text3 = "几" + text2;
				MonoBehaviour.print(text3 + "ming....");
				foreach (KeyValuePair<string, float> item in Manager._instance.JieMian.文几字典)
				{
					MonoBehaviour.print(item.Key + "    " + item.Value);
					MonoBehaviour.print(item.Key + "..");
					MonoBehaviour.print(Manager._instance.JieMian.文几字典[item.Key] + "lala...");
				}
				if (Manager._instance.JieMian.文几字典.ContainsKey(text3))
				{
					当前选择.GetComponent<Text>().text = Manager._instance.JieMian.文几字典[text3].ToString();
				}
				else
				{
					Manager._instance.JieMian.文几字典.Add(text2, 0f);
					当前选择.GetComponent<Text>().text = Manager._instance.JieMian.文几字典[text3].ToString();
				}
				Manager._instance.JieMian.物体的父类();
				Manager._instance.JieMian.锚点(Manager._instance.JieMian.靠几);
				Manager._instance.JieMian.判断是否有放();
				Manager._instance.JieMian.有换行();
				UnityEngine.Debug.Log(当前选择.name + "name..text...");
				string key = "几" + 当前选择.name;
				Manager._instance.JieMian.几文本变量.Add(key, 当前选择);
			}
			else if (参数.IndexOf('宽') >= 0 && 参数.IndexOf('高') >= 0)
			{
				string[] array = 参数.Split('宽');
				当前选择.GetComponent<Text>().text = array[0];
				string[] array2 = array[1].Split('高');
				当前选择.GetComponent<RectTransform>().sizeDelta = new Vector2(float.Parse(array2[0]), float.Parse(array2[1]));
			}
		}
		else
		{
			是否文字 = true;
			模名字 = "文" + 参数;
			MonoBehaviour.print(模名字);
			DWay.GetInstance().判断虚号类型(模名字);
		}
		return "文完";
	}

	private string 令(string 参数)
	{
		return "令完";
	}

	private string 动(string 参数)
	{
		return "动完";
	}

	public void 模(string 参数 = "")
	{
		模名字 = "模" + 参数;
		DWay.GetInstance().判断类型操作(典虚物);
	}

	public void 实现内容文本(string name1, string Mname, string 模名)
	{
		if (name1 == "文本")
		{
			GameObject gameObject = GameObject.Find("Canvas").gameObject;
			GameObject gameObject2 = UnityEngine.Object.Instantiate(Resources.Load("文", typeof(GameObject)) as GameObject, gameObject.transform);
			gameObject2.GetComponent<Text>().text = 模名;
			当前选择 = gameObject2;
			Manager._instance.Trans_form.全局对象 = 当前选择;
			判断名字名数(Mname);
		}
	}

	public string 载(IEnumerator 参数)
	{
		StartCoroutine(参数);
		return "载完";
	}

	public IEnumerator 下载物体(string path, string name, string name1)
	{
		switch (name)
		{
		case "文本":
		case "虚文":
		case "音乐":
		case "电影":
		case "文本模型":
		case "图片":
			bundle = new WWW(path);
			break;
		default:
			if (Manager._instance.Vr2045.是否批完)
			{
				Manager._instance.Vr2045.全局是下载完成批 = true;
				if (前全局对象 != null)
				{
					前全局对象 = 当前选择;
				}
			}
			else
			{
				Manager._instance.Vr2045.全局是开始下载 = true;
			}
			当前选择 = null;
			bundle = WWW.LoadFromCacheOrDownload(path, 1);
			break;
		}
		状("1");
		yield return bundle;
		if (bundle.error == null)
		{
			listPath.Add(path);
			状("2");
			switch (name)
			{
			case "文本":
			{
				string text2 = JsonMapper.ToObject(bundle.text)["data"]["广"].ToString();
				if (!是否文字)
				{
					Manager._instance.Vr2045.取文本(text2.Substring(1, text2.Length - 2));
					break;
				}
				是否文字 = false;
				text2 = text2.Replace("\"", "");
				实现内容文本(name, name1, text2);
				break;
			}
			case "文本模型":
			{
				JsonData jsonData = JsonMapper.ToObject(bundle.text);
				string text = ((jsonData["data"].Count <= 0) ? jsonData["data"]["号"].ToString() : jsonData["data"][0]["号"].ToString());
				text = text.Replace("\"", "");
				if (text != "空")
				{
					if (name1 == "模型")
					{
						下载模型(text, 模型名字);
					}
					DownList.Add(当前选择);
				}
				break;
			}
			case "虚文":
			{
				string 参数 = JsonMapper.ToObject(bundle.text)["data"]["广"].ToString();
				string[] 参数2 = Manager._instance.Vr2045.割(参数);
				Manager._instance.Vr2045.容错存(参数2);
				break;
			}
			case "音乐":
			{
				AudioClip audioClip = bundle.GetAudioClip(threeD: false);
				当前选择.AddComponent<AudioSource>();
				当前选择.GetComponent<AudioSource>().clip = audioClip;
				当前选择.GetComponent<AudioSource>().PlayOneShot(audioClip);
				break;
			}
			case "图片":
			{
				Texture2D texture = bundle.texture;
				GameObject obj = UnityEngine.Object.Instantiate(Resources.Load("Image", typeof(GameObject)) as GameObject).gameObject;
				obj.GetComponent<Image>().overrideSprite = Sprite.Create(texture, new Rect(0f, 0f, texture.width, texture.height), new Vector2(0f, 0f));
				GameObject gameObject = GameObject.Find("Canvas").gameObject;
				obj.transform.SetParent(gameObject.transform);
				break;
			}
			default:
			{
				names = bundle.assetBundle.GetAllAssetNames();
				request = bundle.assetBundle.LoadAssetAsync(names[0], typeof(GameObject));
				yield return request;
				当前选择 = UnityEngine.Object.Instantiate(request.asset) as GameObject;
				DownList.Add(当前选择);
				当前选择.transform.localPosition = Manager._instance.Trans_form.当前始;
				bundle.assetBundle.Unload(unloadAllLoadedObjects: false);
				Manager._instance.Trans_form.全局对象 = 当前选择;
				UnityEngine.Component[] componentsInChildren = 当前选择.GetComponentsInChildren(typeof(MeshRenderer));
				if (componentsInChildren != null)
				{
					UnityEngine.Component[] array = componentsInChildren;
					for (int i = 0; i < array.Length; i++)
					{
						Material[] materials = ((MeshRenderer)array[i]).materials;
						for (int j = 0; j < materials.Length; j++)
						{
							materials[j].shader = Shader.Find("Standard");
						}
					}
				}
				foreach (Transform item in 当前选择.transform)
				{
					子弹位置 = item;
				}
				_ = name == "测试模型";
				switch (name)
				{
				case "地毯":
					当前选择.tag = "Plane";
					break;
				case "场景":
					当前选择.transform.localPosition = Manager._instance.Trans_form.当前区;
					break;
				case "子弹":
					当前选择.transform.SetParent(子弹位置.parent);
					当前选择.transform.localPosition = 子弹位置.localPosition;
					子弹库.Add(当前选择);
					Manager._instance.Trans_form.真正的子弹位置和角度 = 当前选择;
					当前选择.GetComponent<MeshRenderer>().enabled = false;
					break;
				case "枪":
					当前选择.transform.localRotation = Quaternion.Euler(0f, 0f, 0f);
					break;
				}
				if (前全局对象 == null && Manager._instance.Vr2045.是否批完)
				{
					前全局对象 = 当前选择;
				}
				if (name != "模型")
				{
					判断名字名数(name);
				}
				if (name == "模型")
				{
					判断名字名数(name1);
				}
				yield return 当前选择;
				yield return new WaitForSeconds(1f);
				Manager._instance.Vr2045.全局是下载完成 = true;
				if ((bool)Manager._instance.Trans_form.区对象)
				{
					当前选择.transform.parent = Manager._instance.Trans_form.区对象.transform;
				}
				break;
			}
			case "电影":
				break;
			}
			if (Manager._instance.Vr2045.是否有模 && name != "文本模型")
			{
				Manager._instance.Vr2045.是否有模 = false;
				Manager._instance.Vr2045.循环(Manager._instance.Vr2045.全局数组);
			}
		}
		else
		{
			状("3");
		}
	}

	public void 判断名字名数(string name1)
	{
		if (listName.Count > 0)
		{
			foreach (string item in listName)
			{
				if (!(item == name1))
				{
					continue;
				}
				名字数字++;
				if (Manager._instance.Vr2045.判中文(name1) != "")
				{
					name1 = Manager._instance.Vr2045.判中文(name1) + 名字数字;
					continue;
				}
				if (name1.IndexOf("-") != -1)
				{
					name1 = name1.Split('-')[0];
				}
				name1 = name1 + "-" + 名字数字;
			}
		}
		当前选择.name = name1;
		listName.Add(name1);
		名字数字 = 0;
	}

	public string 状(string 参数 = "")
	{
		switch (参数)
		{
		case "1":
			下载提示1.transform.Find("Text").GetComponent<Text>().text = "下载中..";
			break;
		case "2":
			下载提示1.transform.Find("Text").GetComponent<Text>().text = "下载完成";
			break;
		case "3":
			下载提示1.transform.Find("Text").GetComponent<Text>().text = "下载失败";
			break;
		}
		return "状完";
	}

	private string 观(string 参数)
	{
		GameObject.Find("Player").gameObject.transform.position = 当前选择.transform.localPosition + new Vector3(0f, 0f, -4f);
		return "观完";
	}

	private string 去(string 参数)
	{
		GameObject.Find("Player").gameObject.transform.position = new Vector3(0f, 0f, 0f) + new Vector3(0f, 0f, -1f);
		return "去完";
	}

	private string 快(string 参数)
	{
		是否加快X = true;
		是否加快Y = true;
		ETCAxis eTCAxis = new ETCAxis("");
		if (是否加快X)
		{
			eTCAxis.speed *= 2f;
			是否加快X = false;
		}
		return "快完";
	}

	private string 慢(string 参数)
	{
		是否减慢X = true;
		是否减慢Y = true;
		ETCAxis eTCAxis = new ETCAxis("");
		if (是否减慢X)
		{
			eTCAxis.speed /= 2f;
			是否减慢X = false;
		}
		return "慢完";
	}

	private void 加(string 参数)
	{
		if (参数 == "刚体")
		{
			GameObject obj = UnityEngine.Object.Instantiate(Resources.Load("物体", typeof(GameObject)) as GameObject, 当前选择.transform).gameObject;
			obj.AddComponent<Rigidbody>();
			obj.GetComponent<Rigidbody>().useGravity = false;
		}
		else if (参数 == "碰撞体")
		{
			GameObject obj2 = UnityEngine.Object.Instantiate(Resources.Load("物体", typeof(GameObject)) as GameObject, 当前选择.transform).gameObject;
			obj2.transform.localPosition = new Vector3(0f, 0.245f, 0f);
			obj2.tag = "加碰撞体";
			obj2.AddComponent<BoxCollider>();
		}
	}

	private void 附(string 参数)
	{
		switch (参数)
		{
		case "刚体":
			变刚体(当前选择);
			break;
		case "碰撞体":
			变碰撞体(当前选择);
			break;
		case "特效拖尾":
			UnityEngine.Object.Instantiate(Resources.Load("Trail", typeof(GameObject)) as GameObject, 当前选择.transform).gameObject.transform.localPosition = new Vector3(0f, 0f, 0f);
			break;
		}
	}

	private void 变(string 参数)
	{
		是否按下佑 = false;
		switch (参数)
		{
		case "道具":
			变道具(当前选择);
			return;
		case "法宝之扔":
			是否按下佑 = true;
			变道具(当前选择);
			return;
		case "法宝之射":
			是否按下佑 = true;
			法宝之射 = true;
			变碰撞体(当前选择);
			return;
		case "量":
			return;
		case "量完":
			return;
		}
		if (参数 != "道具" && 参数 != "法宝之扔" && 参数 != "法宝之射")
		{
			GameObject gameObject = GameObject.Find(参数).gameObject;
			当前选择 = gameObject;
		}
	}

	private void 变刚体(GameObject 参数)
	{
		参数.AddComponent<Rigidbody>();
		参数.GetComponent<Rigidbody>().useGravity = true;
	}

	private void 变碰撞体(GameObject 参数)
	{
		参数.AddComponent<BoxCollider>();
	}

	private void 变道具(GameObject 参数)
	{
		if (参数.GetComponent<Rigidbody>() == null)
		{
			参数.AddComponent<Rigidbody>();
			参数.GetComponent<Rigidbody>().useGravity = true;
		}
		当前选择.AddComponent<BoxCollider>();
	}

	public void 刷(string 参数)
	{
	}

	public void 删(string 参数 = "")
	{
		UnityEngine.Object.Destroy(当前选择);
	}

	public void 选(string 参数)
	{
		GameObject gameObject = GameObject.Find(参数).gameObject;
		当前选择 = gameObject;
	}

	public void 令()
	{
		是否命令按钮 = !是否命令按钮;
		if (是否命令按钮)
		{
			if (!命令对象.activeSelf)
			{
				多个按钮集合[0].GetComponent<Image>().sprite = 击中图片[1];
				命令对象.SetActive(value: true);
			}
		}
		else
		{
			多个按钮集合[0].GetComponent<Image>().sprite = 击中图片[0];
			命令对象.SetActive(value: false);
		}
	}

	public void 广()
	{
		是否广按钮 = !是否广按钮;
		if (是否广按钮)
		{
			if (!文本内容.activeSelf)
			{
				多个按钮集合[1].GetComponent<Image>().sprite = 击中图片[1];
				文本内容.SetActive(value: true);
			}
		}
		else
		{
			多个按钮集合[1].GetComponent<Image>().sprite = 击中图片[0];
			文本内容.SetActive(value: false);
		}
	}

	public void 多功能按钮功能()
	{
		旋转按钮 = !旋转按钮;
		if (旋转按钮)
		{
			if (确定已经收起大地图)
			{
				旋转按钮1 = true;
				区域.SetActive(value: false);
				收起按钮.SetActive(value: false);
			}
			else
			{
				上移合成 = true;
			}
			多功能.transform.Find("人走").GetComponent<Image>().sprite = 人走图片;
		}
		else if (确定已经收起大地图)
		{
			多功能.SetActive(value: false);
			恢复旋转位置 = true;
		}
		else
		{
			多功能.transform.localScale = new Vector3(0f, 0f, 0f);
			恢复旋转位置 = true;
			多功能.SetActive(value: false);
		}
	}

	public void 收起地图()
	{
		是否点击收起 = !是否点击收起;
		if (是否点击收起)
		{
			是否收起大地图 = true;
		}
		else
		{
			是否放下大地图 = true;
		}
	}

	public void 传送列表()
	{
		是否按下区域按钮 = !是否按下区域按钮;
		if (是否按下区域按钮)
		{
			Manager._instance.Vr2045.传送列表.SetActive(value: false);
		}
		else
		{
			Manager._instance.Vr2045.传送列表.SetActive(value: true);
		}
	}
}
public class Loop : MonoBehaviour
{
	public bool 为做;

	public bool 为运算符;

	private int 几数1;

	private string 判参;

	private List<string> 列表案子 = new List<string>();

	public int 甲;

	private string 当数;

	private string 判(string 参数)
	{
		if (参数.IndexOf('串') != -1)
		{
			string[] array = 参数.Split('串');
			string key = "串" + array[1];
			判参 = Manager._instance.Vr2045.全局串[key];
			UnityEngine.Debug.Log("1判参........" + 判参);
		}
		else
		{
			string key2 = "串" + 参数;
			判参 = Manager._instance.Vr2045.全局串[key2];
		}
		return 判参;
	}

	public List<string> 案(string 参数)
	{
		if (参数.IndexOf('默') == -1)
		{
			列表案子.Add(参数);
		}
		UnityEngine.Debug.Log("1参数......" + 参数);
		是否有案和返(参数);
		return 列表案子;
	}

	private string 是否有案和返(string 参数)
	{
		if (参数.IndexOf("默") != -1)
		{
			string[] array = 参数.Split('默');
			列表案子.Add(array[0]);
			string value = "则" + array[1];
			SendMessage("默", value);
		}
		return "完";
	}

	private string 默(string 参数)
	{
		列表案子.Add(参数);
		语句判断(判参);
		return "默完";
	}

	private void 语句判断(string 参数)
	{
		bool flag = false;
		bool flag2 = false;
		bool flag3 = false;
		bool flag4 = false;
		UnityEngine.Debug.Log(列表案子.Count + "列表案子");
		for (int i = 0; i < 列表案子.Count; i++)
		{
			StringBuilder stringBuilder = new StringBuilder();
			string[] array = 列表案子[i].Split('F');
			for (int j = 1; j < array.Length - 1; j++)
			{
				string value = array[j] + "F";
				stringBuilder.Append(value);
			}
			UnityEngine.Debug.Log("2判参..." + 判参);
			if (!(array[0] == 判参 || flag))
			{
				continue;
			}
			flag = true;
			string[] array2 = stringBuilder.ToString().Split('F');
			for (int k = 0; k < array2.Length - 1; k++)
			{
				UnityEngine.Debug.Log("2kkkk............" + k);
				UnityEngine.Debug.Log("2llllll......" + array2[k]);
				bool num = array2[k].IndexOf('破') != -1;
				flag4 = array2[k].IndexOf('续') != -1;
				if (num)
				{
					UnityEngine.Debug.Log("2break............");
					flag2 = true;
				}
				if (flag4)
				{
					UnityEngine.Debug.Log("2contine............");
					flag3 = true;
				}
				if (!num && !flag4)
				{
					flag4 = false;
					Manager._instance.Vr2045.广(array2[k]);
				}
			}
			if (flag2)
			{
				break;
			}
		}
	}

	public void 如(string 参数)
	{
		if (参数 == "完")
		{
			Manager._instance.Vr2045.是执行 = true;
		}
		bool flag = 参数.IndexOf('为') != -1;
		foreach (KeyValuePair<string, bool> item in Manager._instance.Vr2045.全局是)
		{
			_ = item;
		}
		if (flag)
		{
			if (Manager._instance.Vr2045.全局是.ContainsKey(参数))
			{
				if (Manager._instance.Vr2045.全局是[参数])
				{
					Manager._instance.Vr2045.是执行 = true;
					return;
				}
				Manager._instance.Vr2045.是执行 = false;
				Manager._instance.Vr2045.是假 = true;
			}
		}
		else if (参数 != "完")
		{
			运算符(参数);
		}
	}

	private void 运算符(string 参数)
	{
		为运算符 = true;
		bool flag = 参数.IndexOf("等于") != -1;
		bool flag2 = 参数.IndexOf("大于") != -1;
		bool flag3 = 参数.IndexOf("小于") != -1;
		if (flag && flag2)
		{
			string[] array = 参数.Split(new char[3] { '等', '于', '大' }, StringSplitOptions.RemoveEmptyEntries);
			if (甲 >= int.Parse(array[1]))
			{
				Manager._instance.Vr2045.是执行 = true;
				为运算符 = false;
			}
			else
			{
				Manager._instance.Vr2045.是执行 = false;
				Manager._instance.Vr2045.是假 = true;
			}
		}
		if (flag && flag3)
		{
			string[] array2 = 参数.Split(new char[3] { '等', '于', '小' }, StringSplitOptions.RemoveEmptyEntries);
			for (int i = 0; i < array2.Length; i++)
			{
				int.Parse(array2[i]);
			}
		}
		if (flag && !flag2 && !flag3)
		{
			string[] array3 = 参数.Split(new char[2] { '等', '于' }, StringSplitOptions.RemoveEmptyEntries);
			for (int j = 0; j < array3.Length; j++)
			{
				int.Parse(array3[j]);
			}
		}
		if (flag2 && !flag)
		{
			string[] array4 = 参数.Split(new char[2] { '于', '大' }, StringSplitOptions.RemoveEmptyEntries);
			for (int k = 0; k < array4.Length; k++)
			{
				int.Parse(array4[k]);
			}
		}
		if (flag3 && !flag)
		{
			string[] array5 = 参数.Split(new char[2] { '于', '小' }, StringSplitOptions.RemoveEmptyEntries);
			for (int l = 0; l < array5.Length; l++)
			{
				int.Parse(array5[l]);
			}
		}
	}

	public void 否(string 参数)
	{
		Manager._instance.Vr2045.是执行 = !Manager._instance.Vr2045.是执行;
	}

	public string 当(string 参数)
	{
		当数 = 参数;
		bool 参数2 = Manager._instance.Vr2045.全局是[参数];
		if (为做)
		{
			循环2(参数2);
		}
		else
		{
			循环1(参数2);
		}
		return 参数;
	}

	public string 做(string 参数)
	{
		为做 = true;
		string[] array = Manager._instance.Vr2045.分割中(Manager._instance.Vr2045.content.ToString());
		foreach (string text in array)
		{
			if (Manager._instance.Vr2045.首字(text) == "当" && text != "当完")
			{
				SendMessage(Manager._instance.Vr2045.首字(text), Manager._instance.Vr2045.余字(text));
			}
		}
		return 参数;
	}

	private void 循环2(bool 参数)
	{
		do
		{
			甲++;
			循环当命令(Manager._instance.Vr2045.content.ToString());
			参数 = Manager._instance.Vr2045.全局是[当数];
		}
		while (参数);
		Manager._instance.Vr2045.循环(Manager._instance.Vr2045.全局数组);
	}

	private void 循环1(bool 参数)
	{
		while (参数)
		{
			甲++;
			循环当命令(Manager._instance.Vr2045.content.ToString());
			参数 = Manager._instance.Vr2045.全局是[当数];
		}
		Manager._instance.Vr2045.循环(Manager._instance.Vr2045.全局数组);
	}

	public string 循环当命令(string contents)
	{
		string[] array = contents.Split('F');
		for (int i = 几数1; i < array.Length - 1; i++)
		{
			几数1++;
			string text = array[i];
			if (text == "当完")
			{
				break;
			}
			if (Manager._instance.Vr2045.首字(text) == "当" && text != "当完")
			{
				if (!为做)
				{
					SendMessage(Manager._instance.Vr2045.首字(text), Manager._instance.Vr2045.余字(text));
				}
				break;
			}
			if (为运算符)
			{
				为运算符 = false;
				几数1 = 1;
				break;
			}
			if (text == "做")
			{
				SendMessage(Manager._instance.Vr2045.首字(text), Manager._instance.Vr2045.余字(text));
				break;
			}
			SendMessage(Manager._instance.Vr2045.首字(text), Manager._instance.Vr2045.余字(text));
		}
		return "完";
	}
}
public class scratch : MonoBehaviour
{
	public GameObject 当前选择;

	private bool 是否娜;

	private float x;

	private float y;

	private float z;

	private AudioClip clip;

	private string webpaths;

	private bool 为视频;

	private bool 为音频;

	private bool 为扳机;

	private bool 为菜单;

	private bool 为侧键;

	private bool 为触摸;

	private bool 为向上;

	private GameObject Scr_当前选择;

	public GameObject CanvaObj;

	private void Awake()
	{
	}

	private void Update()
	{
		if (是否娜)
		{
			当前选择.transform.position = new Vector3(Mathf.Lerp(当前选择.transform.localPosition.x, x, Time.deltaTime), Mathf.Lerp(当前选择.transform.localPosition.y, y, Time.deltaTime), Mathf.Lerp(当前选择.transform.localPosition.z, z, Time.deltaTime));
		}
	}

	private string 显(string 参数)
	{
		if (!当前选择.activeSelf)
		{
			当前选择.SetActive(value: true);
		}
		return "完";
	}

	private string 隐(string 参数)
	{
		if (当前选择.activeSelf)
		{
			当前选择.SetActive(value: false);
		}
		return "完";
	}

	private string 挪(string 参数)
	{
		Scr_当前选择 = Manager._instance.Down.当前选择;
		是否娜 = true;
		if (Manager._instance.Trans_form.轴方向(参数))
		{
			x = Scr_当前选择.transform.localPosition.x + Manager._instance.Trans_form.轴典["横"];
			y = Scr_当前选择.transform.localPosition.y + Manager._instance.Trans_form.轴典["纵"];
			z = Scr_当前选择.transform.localPosition.z + Manager._instance.Trans_form.轴典["深"];
			Scr_当前选择.transform.Translate(x, y, z);
		}
		else
		{
			x = Scr_当前选择.transform.localPosition.x + float.Parse(Manager._instance.Trans_form.Trans_集参[0]);
			y = Scr_当前选择.transform.localPosition.y + float.Parse(Manager._instance.Trans_form.Trans_集参[1]);
			z = Scr_当前选择.transform.localPosition.z + float.Parse(Manager._instance.Trans_form.Trans_集参[2]);
			MonoBehaviour.print(x + "xxx");
		}
		return "完";
	}

	private string 到(string 参数)
	{
		if (Manager._instance.Trans_form.轴方向(参数))
		{
			Scr_当前选择.transform.position = Scr_当前选择.transform.position + new Vector3(Manager._instance.Trans_form.轴典["横"], Manager._instance.Trans_form.轴典["纵"], Manager._instance.Trans_form.轴典["深"]);
		}
		else
		{
			Scr_当前选择.transform.position = Scr_当前选择.transform.position + new Vector3(float.Parse(Vr2045._instance.集参[0]), float.Parse(Vr2045._instance.集参[1]), float.Parse(Vr2045._instance.集参[2]));
		}
		return "完";
	}

	private string 移(string 参数)
	{
		return "完";
	}

	private string 弹(string 参数)
	{
		MonoBehaviour.print("弹出面板");
		return "完";
	}

	private string 说(string 参数)
	{
		GameObject original = Resources.Load("说角", typeof(GameObject)) as GameObject;
		GameObject gameObject = GameObject.Find("canvas").gameObject;
		_ = 当前选择.transform.localPosition + new Vector3(0f, 0.9f, 0f);
		GameObject obj = UnityEngine.Object.Instantiate(original, gameObject.transform);
		obj.transform.localPosition = new Vector3(0f, 0f, 0f);
		GameObject gameObject2 = obj.transform.Find("说").gameObject;
		GameObject gameObject3 = gameObject2.transform.Find("Text").gameObject;
		gameObject3.GetComponent<Text>().text = 参数;
		StartCoroutine(UpdateContentHeight1(gameObject3, gameObject2));
		return "完";
	}

	private string 想(string 参数)
	{
		GameObject original = Resources.Load("想角", typeof(GameObject)) as GameObject;
		GameObject gameObject = GameObject.Find("canvas").gameObject;
		_ = 当前选择.transform.localPosition + new Vector3(0f, 0.9f, 0f);
		GameObject obj = UnityEngine.Object.Instantiate(original, gameObject.transform);
		obj.transform.localPosition = new Vector3(0f, 0f, 0f);
		GameObject gameObject2 = obj.transform.Find("想").gameObject;
		GameObject gameObject3 = gameObject2.transform.Find("Text").gameObject;
		gameObject3.GetComponent<Text>().text = 参数;
		StartCoroutine(UpdateContentHeight2(gameObject3, gameObject2));
		return "完";
	}

	private IEnumerator UpdateContentHeight1(GameObject 文字, GameObject Obj_image)
	{
		yield return null;
		float num = 文字.transform.GetComponent<RectTransform>().rect.height + 20f;
		MonoBehaviour.print("height" + 文字.transform.GetComponent<RectTransform>().rect.height);
		float num2 = 文字.transform.GetComponent<RectTransform>().rect.width + 20f;
		Obj_image.GetComponent<Image>().GetComponent<RectTransform>().sizeDelta = new Vector3(num2, num);
		MonoBehaviour.print(num + "......");
	}

	private IEnumerator UpdateContentHeight2(GameObject 文字, GameObject Obj_image)
	{
		yield return null;
		float num = 文字.transform.GetComponent<RectTransform>().rect.height + 20f;
		float num2 = 文字.transform.GetComponent<RectTransform>().rect.width + 20f;
		Obj_image.GetComponent<Image>().GetComponent<RectTransform>().sizeDelta = new Vector3(num2, num);
		MonoBehaviour.print(num + "......");
	}

	private string 音(string 参数)
	{
		当前选择.GetComponent<AudioSource>().volume = float.Parse(参数);
		return "完";
	}

	private string 停(string 参数)
	{
		_ = 为视频;
		if (为音频)
		{
			当前选择.GetComponent<AudioSource>().Stop();
		}
		return "完";
	}

	private string 升(string 参数)
	{
		float num = float.Parse(判断是否有参数(参数));
		当前选择.transform.localPosition += new Vector3(0f, num, 0f);
		return "完";
	}

	private string 降(string 参数)
	{
		float num = float.Parse(判断是否有参数(参数));
		当前选择.transform.localPosition -= new Vector3(0f, num, 0f);
		return "完";
	}

	private string 玩(string 参数)
	{
		SceneManager.LoadScene(参数);
		return "玩完";
	}

	private string 判断是否有参数(string 参数)
	{
		if (参数 == " ")
		{
			参数 = "1";
		}
		return 参数;
	}

	private float 乱(string 参数)
	{
		return UnityEngine.Random.Range(-1, 1);
	}

	private string 榜(string 参数)
	{
		string[] array = 参数.Split('号');
		UnityEngine.Debug.Log(array.Length + "length");
		UnityEngine.Debug.Log(array[1] + "str.....");
		return "榜完";
	}

	private string 血(string 参数)
	{
		UnityEngine.Object.Instantiate(CanvaObj, Manager._instance.Down.当前选择.transform).transform.localPosition = new Vector3(0f, 0f, 0f);
		return "血完";
	}
}
public class Trans_form : MonoBehaviour
{
	private bool 是否浮起;

	private float y;

	private bool 是否向下;

	private bool 是否向上;

	private bool 轴方向是否有中文;

	[HideInInspector]
	public Vector3 当前区 = new Vector3(0f, 0f, 0f);

	public Vector3 当前始;

	public Dictionary<string, float> 轴典 = new Dictionary<string, float>();

	public string[] Trans_集参;

	private int index;

	private float 几移动数1;

	public GameObject Trans_当前选择;

	private float 几移负动数;

	private float speed;

	public Dictionary<string, float> 典速度;

	[HideInInspector]
	public GameObject 真正的子弹位置和角度;

	public GameObject 全局对象;

	public GameObject 区对象;

	public List<GameObject> 区对象数组 = new List<GameObject>();

	public static int 区数;

	private int 轴方向执行一次;

	private int 乱飞数;

	public bool 是否凡人视角1;

	public GameObject TouchPad;

	public GameObject 主角;

	private void Start()
	{
	}

	private void Update()
	{
		if (是否浮起)
		{
			Trans_当前选择 = Manager._instance.Down.当前选择;
			UnityEngine.Debug.Log("1y....." + y);
			if (Trans_当前选择.transform.localPosition.y == y)
			{
				是否向上 = true;
			}
			if (Trans_当前选择.transform.localPosition.y >= y + 0.1f)
			{
				是否向下 = true;
				是否向上 = false;
			}
			if (Trans_当前选择.transform.localPosition.y <= y)
			{
				是否向上 = true;
				是否向下 = false;
			}
			if (是否向上)
			{
				Trans_当前选择.transform.Translate(Vector3.up * Time.deltaTime * 0.2f);
			}
			if (是否向下)
			{
				Trans_当前选择.transform.Translate(Vector3.down * Time.deltaTime * 0.2f);
			}
		}
	}

	public string 放(string 参数)
	{
		if (Manager._instance.JieMian.是否为界面)
		{
			UnityEngine.Debug.Log(参数 + "..参数..");
			string text = 参数.Substring(0, 参数.Length - 1);
			UnityEngine.Debug.Log(text + "..name..");
			if (参数.Substring(参数.Length - 1, 1) != "完")
			{
				UnityEngine.Debug.Log("lalal...");
				if (Manager._instance.JieMian.框对象.Count > 0)
				{
					GameObject gameObject = Manager._instance.JieMian.框对象[Manager._instance.JieMian.框对象.Count - 1];
					Manager._instance.Down.当前选择 = gameObject.transform.Find(text).gameObject;
				}
				else
				{
					GameObject 当前选择 = GameObject.Find(text);
					Manager._instance.Down.当前选择 = 当前选择;
				}
				string 参数2 = 参数.Substring(参数.Length - 1, 1);
				Manager._instance.JieMian.放的位置 = Manager._instance.JieMian.判断方位(参数2);
				Manager._instance.JieMian.放数 = 1f;
			}
			if (参数.Substring(参数.Length - 1, 1) == "完")
			{
				Manager._instance.JieMian.放数 = 0f;
			}
		}
		else
		{
			UnityEngine.Debug.LogWarning("----------放：" + 参数);
			switch (参数)
			{
			case "桌子上":
			{
				GameObject gameObject2 = GameObject.Find("桌子").gameObject;
				全局对象.transform.localPosition = gameObject2.transform.localPosition + new Vector3(0f, 0.74f, 0f);
				break;
			}
			case "在中心":
				Manager._instance.Down.当前选择.transform.localPosition = new Vector3(0f, 0f, 0f);
				break;
			case "可乐旁":
			{
				GameObject gameObject3 = GameObject.Find("可乐").gameObject;
				全局对象 = gameObject3;
				break;
			}
			default:
				if (纯数字(参数))
				{
					float num = float.Parse(参数);
					Manager._instance.Down.当前选择.transform.position += new Vector3(num, num, num);
				}
				else if (轴方向(参数))
				{
					Manager._instance.Down.当前选择.transform.position = new Vector3(轴典["横"], 轴典["纵"], 轴典["深"]);
				}
				else
				{
					Manager._instance.Down.当前选择.transform.position = Manager._instance.Down.当前选择.transform.position + new Vector3(float.Parse(Trans_集参[0]), float.Parse(Trans_集参[1]), float.Parse(Trans_集参[2]));
				}
				break;
			}
		}
		return "放完==========";
	}

	private bool 纯数字(string 参数)
	{
		return new Regex("^(-?\\d+)(\\.\\d+)?$", RegexOptions.None).IsMatch(参数.Trim());
	}

	public bool 轴方向(string 参数)
	{
		Trans_当前选择 = Manager._instance.Down.当前选择;
		StringBuilder stringBuilder = new StringBuilder();
		string[] array = Manager._instance.Vr2045.割参(参数);
		foreach (string value in array)
		{
			stringBuilder.Append(value);
			stringBuilder.Append(' ');
		}
		string 参数2 = ((!Manager._instance.Vr2045.是否分割) ? 参数 : stringBuilder.ToString());
		Trans_集参 = Manager._instance.Down.在数字后添加判断符(参数2).Split(new char[1] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
		string text = Manager._instance.Vr2045.判中文(参数2);
		array = Trans_集参;
		foreach (string 参数3 in array)
		{
			if (text == "")
			{
				轴方向是否有中文 = false;
				continue;
			}
			轴方向是否有中文 = true;
			轴方向执行一次++;
			if (轴方向执行一次 == 1)
			{
				轴典.Add("横", 0.1f);
				轴典.Add("纵", 0.1f);
				轴典.Add("深", 0.1f);
			}
			轴方向是否有中文 = true;
			if (轴典.ContainsKey(Manager._instance.Vr2045.判中文(参数3)))
			{
				轴典.Remove(Manager._instance.Vr2045.判中文(参数3));
				轴典.Add(Manager._instance.Vr2045.判中文(参数3), float.Parse(Manager._instance.Vr2045.判数字(参数3)));
			}
		}
		return 轴方向是否有中文;
	}

	private void 旋(string 参数 = "")
	{
		if (参数 == "")
		{
			Trans_当前选择 = 全局对象;
			Trans_当前选择.transform.localRotation = Quaternion.Euler(0f, 0f, 0f);
		}
		else if (轴方向(参数))
		{
			Trans_当前选择.transform.localRotation = Quaternion.Euler(轴典["横"], 轴典["纵"], 轴典["深"]);
		}
		else if (!Manager._instance.Vr2045.是否分割)
		{
			Trans_当前选择.transform.localRotation = Quaternion.Euler(0f, float.Parse(参数), 0f);
		}
		else
		{
			Trans_当前选择.transform.localRotation = Quaternion.Euler(float.Parse(Trans_集参[0]), float.Parse(Trans_集参[1]), float.Parse(Trans_集参[2]));
		}
	}

	private void 判断轴方向(GameObject obj, string 参数)
	{
		bool flag = 参数.IndexOf("横") != -1;
		bool flag2 = 参数.IndexOf("纵") != -1;
		bool flag3 = 参数.IndexOf("深") != -1;
		if (flag && flag2 && flag3)
		{
			obj.transform.Rotate(new Vector3(轴典["横"], 轴典["纵"], 轴典["深"]));
		}
		else if (flag && flag2 && !flag3)
		{
			obj.transform.Rotate(new Vector3(轴典["横"], 轴典["纵"], 0f));
		}
		else if (flag && !flag2 && !flag3)
		{
			UnityEngine.Debug.Log("dada...");
			obj.transform.Rotate(轴典["横"], 0f, 0f, Space.World);
		}
		else if (!flag && flag2 && !flag3)
		{
			obj.transform.Rotate(new Vector3(0f, 轴典["纵"], 0f));
		}
		else if (!flag && flag2 && flag3)
		{
			obj.transform.Rotate(new Vector3(0f, 轴典["纵"], 轴典["深"]));
		}
		else if (!flag && !flag2 && flag3)
		{
			obj.transform.Rotate(new Vector3(0f, 0f, 轴典["深"]));
		}
		else if (flag && !flag2 && flag3)
		{
			obj.transform.Rotate(new Vector3(轴典["横"], 0f, 轴典["深"]));
		}
	}

	private void 转(string 参数)
	{
		if (轴方向(参数))
		{
			判断轴方向(Trans_当前选择, 参数);
		}
		else if (纯数字(参数))
		{
			float num = float.Parse(参数);
			float num2 = Trans_当前选择.transform.eulerAngles.y + num;
			Trans_当前选择.transform.localRotation = Quaternion.Euler(0f, num2, 0f);
		}
		else
		{
			Trans_当前选择.transform.localRotation = Quaternion.Euler(Trans_当前选择.transform.eulerAngles.x + float.Parse(Trans_集参[0]), Trans_当前选择.transform.eulerAngles.y + float.Parse(Trans_集参[1]), Trans_当前选择.transform.eulerAngles.z + float.Parse(Trans_集参[2]));
		}
	}

	private void 缩(string 参数)
	{
		Trans_当前选择 = Manager._instance.Down.当前选择;
		float x = Trans_当前选择.transform.localScale.x;
		float num = Trans_当前选择.transform.localScale.y;
		float z = Trans_当前选择.transform.localScale.z;
		if (轴方向(参数))
		{
			Trans_当前选择.transform.localScale = new Vector3(x / 轴典["横"], num / 轴典["纵"], z / 轴典["深"]);
		}
		else if (纯数字(参数))
		{
			float num2 = float.Parse(参数);
			Trans_当前选择.transform.localScale = new Vector3(num2, num2, num2);
		}
		else
		{
			Trans_当前选择.transform.localScale = new Vector3(x / float.Parse(Trans_集参[0]), num / float.Parse(Trans_集参[1]), z / float.Parse(Trans_集参[2]));
		}
	}

	private void 压(string 参数)
	{
		Trans_当前选择 = Manager._instance.Down.当前选择;
		float x = Trans_当前选择.transform.lossyScale.x;
		float num = Trans_当前选择.transform.lossyScale.y;
		float z = Trans_当前选择.transform.lossyScale.z;
		if (轴方向(参数))
		{
			Trans_当前选择.transform.localScale = new Vector3(x / 轴典["横"], num / 轴典["纵"], z / 轴典["深"]);
		}
		else if (纯数字(参数))
		{
			float num2 = float.Parse(参数);
			Trans_当前选择.transform.localScale = new Vector3(num2, num2, num2);
		}
		else
		{
			Trans_当前选择.transform.localScale = new Vector3(x / float.Parse(Trans_集参[0]), num / float.Parse(Trans_集参[1]), z / float.Parse(Trans_集参[2]));
		}
	}

	private void 扩(string 参数)
	{
		Trans_当前选择 = Manager._instance.Down.当前选择;
		float x = Trans_当前选择.transform.localScale.x;
		float num = Trans_当前选择.transform.localScale.y;
		float z = Trans_当前选择.transform.localScale.z;
		MonoBehaviour.print(x + "x.." + num + "y.." + z + "z..");
		if (轴方向(参数))
		{
			Trans_当前选择.transform.localScale = new Vector3(x * 轴典["横"], num * 轴典["纵"], z * 轴典["深"]);
		}
		else if (纯数字(参数))
		{
			float num2 = float.Parse(参数);
			Trans_当前选择.transform.localScale = new Vector3(x * num2, num * num2, z * num2);
		}
		else
		{
			Trans_当前选择.transform.localScale = new Vector3(x * float.Parse(Trans_集参[0]), num * float.Parse(Trans_集参[1]), z * float.Parse(Trans_集参[2]));
		}
	}

	private void 撑(string 参数)
	{
		Trans_当前选择 = Manager._instance.Down.当前选择;
		float x = Trans_当前选择.transform.lossyScale.x;
		float num = Trans_当前选择.transform.lossyScale.y;
		float z = Trans_当前选择.transform.lossyScale.z;
		if (轴方向(参数))
		{
			Trans_当前选择.transform.localScale = new Vector3(x * 轴典["横"], num * 轴典["纵"], z * 轴典["深"]);
		}
		else if (纯数字(参数))
		{
			float num2 = float.Parse(参数);
			Trans_当前选择.transform.localScale = new Vector3(num2, num2, num2);
		}
		else
		{
			Trans_当前选择.transform.localScale = new Vector3(x * float.Parse(Trans_集参[0]), num * float.Parse(Trans_集参[1]), z * float.Parse(Trans_集参[2]));
		}
	}

	private void 移(string 参数)
	{
		if (轴方向(参数))
		{
			Trans_当前选择.transform.localPosition += new Vector3(轴典["横"], 轴典["纵"], 轴典["深"]);
		}
		else if (纯数字(参数))
		{
			float num = float.Parse(参数);
			Trans_当前选择.transform.localPosition = new Vector3(0f, num, 0f);
		}
		else
		{
			Trans_当前选择.transform.localPosition += new Vector3(float.Parse(Trans_集参[0]), float.Parse(Trans_集参[1]), float.Parse(Trans_集参[2]));
		}
	}

	private Vector3 区(string 参数)
	{
		float num = 0f;
		string[] array = 参数.Split('之');
		int num2 = int.Parse(array[0]);
		if (区数 == num2 && (bool)区对象)
		{
			UnityEngine.Object.Destroy(区对象);
		}
		区数 = num2;
		GameObject original = Resources.Load("空对象", typeof(GameObject)) as GameObject;
		区对象 = UnityEngine.Object.Instantiate(original);
		区对象.name = "区" + array[0];
		区对象数组.Add(区对象);
		float x = num2 / 10 * 10;
		float z = (num2 % 10 - 1) * 10;
		当前区 = new Vector3(x, num, z);
		string 参数2 = array[1];
		if (轴方向(参数2))
		{
			当前始 = 当前区 + new Vector3(轴典["横"], 轴典["纵"], 轴典["深"]);
		}
		else
		{
			当前始 = 当前区 + new Vector3(float.Parse(Trans_集参[0]), float.Parse(Trans_集参[1]), float.Parse(Trans_集参[2]));
		}
		区对象.transform.localPosition = 当前始;
		return 当前始;
	}

	private void 多种方式x(GameObject 参数)
	{
		if (判断是那个方位(index) == 1)
		{
			Trans_当前选择.transform.localPosition = 参数.transform.localPosition + new Vector3(几移动数1, 0f, 0f);
		}
		else if (判断是那个方位(index) == 2)
		{
			Trans_当前选择.transform.localRotation = Quaternion.Euler(几移动数1, 0f, 0f);
		}
		else if (判断是那个方位(index) == 3)
		{
			Trans_当前选择.transform.localScale = 参数.transform.localScale + new Vector3(几移动数1, 0f, 0f);
		}
		else if (判断是那个方位(index) == 4)
		{
			Trans_当前选择.transform.localScale = 参数.transform.localScale - new Vector3(几移动数1, 0f, 0f);
		}
		else if (判断是那个方位(index) == 5)
		{
			Trans_当前选择.transform.position = 参数.transform.position + new Vector3(几移动数1, 0f, 0f);
		}
		else if (判断是那个方位(index) == 6)
		{
			Trans_当前选择.transform.rotation = Quaternion.Euler(几移动数1, 0f, 0f);
		}
		else if (判断是那个方位(index) == 7)
		{
			Trans_当前选择.transform.localScale = 参数.transform.lossyScale + new Vector3(几移动数1, 0f, 0f);
		}
		else if (判断是那个方位(index) == 8)
		{
			Trans_当前选择.transform.localScale = 参数.transform.lossyScale - new Vector3(几移动数1, 0f, 0f);
		}
	}

	private void 多种方式z(GameObject 参数)
	{
		if (判断是那个方位(index) == 1)
		{
			Trans_当前选择.transform.localPosition = 参数.transform.localPosition + new Vector3(0f, 0f, 几移动数1);
		}
		else if (判断是那个方位(index) == 2)
		{
			Trans_当前选择.transform.localRotation = Quaternion.Euler(0f, 0f, 几移动数1);
		}
		else if (判断是那个方位(index) == 3)
		{
			Trans_当前选择.transform.localScale = 参数.transform.localScale + new Vector3(0f, 0f, 几移动数1);
		}
		else if (判断是那个方位(index) == 4)
		{
			Trans_当前选择.transform.localScale = 参数.transform.localScale - new Vector3(0f, 0f, 几移动数1);
		}
		else if (判断是那个方位(index) == 5)
		{
			Trans_当前选择.transform.position = 参数.transform.position + new Vector3(0f, 0f, 几移动数1);
		}
		else if (判断是那个方位(index) == 6)
		{
			Trans_当前选择.transform.rotation = Quaternion.Euler(0f, 0f, 几移动数1);
		}
		else if (判断是那个方位(index) == 7)
		{
			Trans_当前选择.transform.localScale = 参数.transform.lossyScale + new Vector3(0f, 0f, 几移动数1);
		}
		else if (判断是那个方位(index) == 8)
		{
			Trans_当前选择.transform.localScale = 参数.transform.lossyScale - new Vector3(0f, 0f, 几移动数1);
		}
	}

	private void 多种方式y(GameObject 参数)
	{
		if (判断是那个方位(index) == 1)
		{
			Trans_当前选择.transform.localPosition = 参数.transform.localPosition + new Vector3(0f, 几移动数1, 0f);
		}
		else if (判断是那个方位(index) == 2)
		{
			Trans_当前选择.transform.localRotation = Quaternion.Euler(0f, 几移动数1, 0f);
		}
		else if (判断是那个方位(index) == 3)
		{
			Trans_当前选择.transform.localScale = 参数.transform.localScale + new Vector3(0f, 几移动数1, 0f);
		}
		else if (判断是那个方位(index) == 4)
		{
			Trans_当前选择.transform.localScale = 参数.transform.localScale - new Vector3(0f, 几移动数1, 0f);
		}
		else if (判断是那个方位(index) == 5)
		{
			Trans_当前选择.transform.position = 参数.transform.position + new Vector3(0f, 几移动数1, 0f);
		}
		else if (判断是那个方位(index) == 6)
		{
			Trans_当前选择.transform.rotation = Quaternion.Euler(0f, 几移动数1, 0f);
		}
		else if (判断是那个方位(index) == 7)
		{
			Trans_当前选择.transform.localScale = 参数.transform.lossyScale + new Vector3(0f, 几移动数1, 0f);
		}
		else if (判断是那个方位(index) == 8)
		{
			Trans_当前选择.transform.localScale = 参数.transform.lossyScale - new Vector3(0f, 几移动数1, 0f);
		}
	}

	private void 横(string 参数)
	{
		Trans_当前选择 = Manager._instance.Down.当前选择;
		bool flag = 参数.IndexOf('移') != -1;
		if (!判断移动位置(参数))
		{
			if (纯数字(参数))
			{
				index = 1;
				几移动数1 = float.Parse(参数);
			}
			else if (flag)
			{
				几移动数1 = 移动正位置的多少(参数);
			}
			else
			{
				string 参数2 = "横" + 参数;
				几移动数1 = 移动正位置的多少(参数2);
			}
			if (!Manager._instance.Vr2045.是否批完)
			{
				if (Manager._instance.Down.是否虚令)
				{
					多种方式x(Trans_当前选择);
				}
				else
				{
					多种方式x(全局对象);
				}
			}
			else
			{
				多种方式x(Manager._instance.Down.前全局对象);
			}
		}
		else
		{
			几移动数1 = 移动负位置的多少(参数);
			几移动数1 *= -1f;
			多种方式x(全局对象);
		}
	}

	private void 深(string 参数)
	{
		Trans_当前选择 = Manager._instance.Down.当前选择;
		全局对象 = Trans_当前选择;
		bool flag = 参数.IndexOf('移') != -1;
		if (!判断移动位置(参数))
		{
			if (纯数字(参数))
			{
				index = 1;
				几移动数1 = float.Parse(参数);
			}
			else if (flag)
			{
				几移动数1 = 移动正位置的多少(参数) * -1f;
			}
			else
			{
				string 参数2 = "深" + 参数;
				几移动数1 = 移动正位置的多少(参数2) * -1f;
			}
			if (!Manager._instance.Vr2045.是否批完)
			{
				if (Manager._instance.Down.是否虚令)
				{
					多种方式z(Trans_当前选择);
				}
				else
				{
					多种方式z(全局对象);
				}
			}
			else
			{
				多种方式z(Manager._instance.Down.前全局对象);
			}
		}
		else
		{
			几移动数1 = 移动负位置的多少(参数);
			多种方式z(全局对象);
		}
	}

	private void 纵(string 参数)
	{
		Trans_当前选择 = Manager._instance.Down.当前选择;
		全局对象 = Trans_当前选择;
		bool flag = 参数.IndexOf('移') != -1;
		if (!判断移动位置(参数))
		{
			if (纯数字(参数))
			{
				index = 1;
				几移动数1 = float.Parse(参数);
			}
			else if (flag)
			{
				几移动数1 = 移动正位置的多少(参数);
			}
			else
			{
				string 参数2 = "纵" + 参数;
				几移动数1 = 移动正位置的多少(参数2);
			}
			if (!Manager._instance.Vr2045.是否批完)
			{
				if (Manager._instance.Down.是否虚令)
				{
					多种方式y(Trans_当前选择);
				}
				else
				{
					多种方式y(全局对象);
				}
			}
			else
			{
				多种方式y(Manager._instance.Down.前全局对象);
			}
		}
		else
		{
			几移动数1 = 移动负位置的多少(参数) * -1f;
			多种方式y(全局对象);
		}
	}

	private bool 判断移动位置(string 参数)
	{
		bool result = false;
		bool num = 参数.IndexOf("负") != -1;
		bool flag = 参数.IndexOf("-") != -1;
		if (num)
		{
			result = true;
		}
		if (flag)
		{
			result = true;
		}
		return result;
	}

	private float 移动正位置的多少(string 参数)
	{
		float result = 0f;
		index = 1;
		bool flag = 参数.IndexOf('纵') != -1;
		bool flag2 = 参数.IndexOf('深') != -1;
		bool flag3 = 参数.IndexOf('横') != -1;
		if (纯数字(参数))
		{
			result = float.Parse(参数);
		}
		else if (flag || flag2 || flag3)
		{
			移(参数);
			return 0f;
		}
		bool num = 参数.IndexOf('移') != -1;
		bool flag4 = 参数.IndexOf('旋') != -1;
		bool flag5 = 参数.IndexOf('扩') != -1;
		bool flag6 = 参数.IndexOf('缩') != -1;
		bool flag7 = 参数.IndexOf('放') != -1;
		bool flag8 = 参数.IndexOf('转') != -1;
		bool flag9 = 参数.IndexOf('挣') != -1;
		bool flag10 = 参数.IndexOf('压') != -1;
		if (num)
		{
			index = 1;
			result = float.Parse(参数.Split('移')[1]);
		}
		else if (flag4)
		{
			index = 2;
			flag4 = false;
			result = float.Parse(参数.Split('旋')[1]);
		}
		else if (flag5)
		{
			index = 3;
			flag5 = false;
			result = float.Parse(参数.Split('扩')[1]);
		}
		else if (flag6)
		{
			index = 4;
			flag6 = false;
			result = float.Parse(参数.Split('缩')[1]);
		}
		else if (flag7)
		{
			index = 5;
			flag7 = false;
			result = float.Parse(参数.Split('放')[1]);
		}
		else if (flag8)
		{
			index = 6;
			flag8 = false;
			result = float.Parse(参数.Split('转')[1]);
		}
		else if (flag9)
		{
			index = 7;
			flag9 = false;
			result = float.Parse(参数.Split('撑')[1]);
		}
		else if (flag10)
		{
			index = 8;
			flag10 = false;
			result = float.Parse(参数.Split('压')[1]);
		}
		判断是那个方位(index);
		return result;
	}

	private int 判断是那个方位(int 参数)
	{
		return 参数;
	}

	private float 移动负位置的多少(string 参数)
	{
		bool flag = 参数.IndexOf("负") != -1;
		bool flag2 = 参数.IndexOf("-") != -1;
		if (flag && !flag2)
		{
			string[] array = 参数.Split('负');
			几移负动数 = float.Parse(array[1]);
		}
		if (flag2 && !flag)
		{
			string[] array2 = 参数.Split('-');
			几移负动数 = float.Parse(array2[1]);
		}
		return 几移负动数;
	}

	private string 速(string 参数)
	{
		Trans_当前选择 = Manager._instance.Down.当前选择;
		bool flag = 参数.IndexOf('加') != -1;
		speed = float.Parse(Manager._instance.Vr2045.判数字(参数));
		if (Manager._instance.Trans_form.轴方向(参数))
		{
			string text = Manager._instance.Vr2045.判中文(参数);
			MonoBehaviour.print("中文字" + text);
			MonoBehaviour.print("speed" + speed);
			if (!flag)
			{
				if (判断移动位置(参数))
				{
					判断负速度方向(text);
				}
				else
				{
					判断正速度方向(text);
				}
			}
			else
			{
				典速度 = new Dictionary<string, float>();
				if (判断移动位置(参数))
				{
					典速度.Add(text, speed * -1f);
				}
				else
				{
					典速度.Add(text, speed);
				}
			}
		}
		else
		{
			char[] separator = Manager._instance.Vr2045.判数字(参数).ToCharArray();
			string[] array = 参数.Split(separator, StringSplitOptions.RemoveEmptyEntries);
			MonoBehaviour.print("轴" + array[0]);
			string text2 = 大小写(array[0]);
			if (!flag)
			{
				if (判断移动位置(参数))
				{
					MonoBehaviour.print("判断负方向......");
					判断负速度方向(text2);
				}
				else
				{
					判断正速度方向(text2);
					MonoBehaviour.print("判断正方向......");
				}
			}
			else
			{
				典速度 = new Dictionary<string, float>();
				if (判断移动位置(参数))
				{
					MonoBehaviour.print("判断负方向......");
					典速度.Add(text2, speed * -1f);
				}
				else
				{
					典速度.Add(text2, speed);
					MonoBehaviour.print("判断正方向......");
				}
			}
		}
		return "速完";
	}

	public string 判断正速度方向(string 参数)
	{
		if (参数 == "加横" || 参数 == "加x")
		{
			Trans_当前选择.GetComponent<Rigidbody>().velocity = base.transform.TransformDirection(真正的子弹位置和角度.transform.forward * speed);
		}
		if (参数 == "加纵" || 参数 == "加y")
		{
			Trans_当前选择.GetComponent<Rigidbody>().velocity = base.transform.TransformDirection(真正的子弹位置和角度.transform.up * speed);
		}
		if (参数 == "加深" || 参数 == "加z")
		{
			Trans_当前选择.GetComponent<Rigidbody>().velocity = base.transform.TransformDirection(真正的子弹位置和角度.transform.right * speed);
		}
		if (参数 == "加横纵深" || 参数 == "加xyz")
		{
			Trans_当前选择.GetComponent<Rigidbody>().velocity = new Vector3(speed, speed, speed);
		}
		return "判断正速度方向完";
	}

	public string 判断负速度方向(string 参数)
	{
		MonoBehaviour.print("有we没有。。。。" + 参数);
		switch (参数)
		{
		case "加横负":
		case "加x":
		case "加横-":
			MonoBehaviour.print("lala.......");
			Trans_当前选择.GetComponent<Rigidbody>().velocity = base.transform.TransformDirection(真正的子弹位置和角度.transform.forward * speed * -1f);
			break;
		}
		switch (参数)
		{
		case "加纵负":
		case "加y":
		case "加纵-":
			Trans_当前选择.GetComponent<Rigidbody>().velocity = base.transform.TransformDirection(真正的子弹位置和角度.transform.up * speed * -1f);
			break;
		}
		switch (参数)
		{
		case "加深负":
		case "加z":
		case "加深-":
			Trans_当前选择.GetComponent<Rigidbody>().velocity = base.transform.TransformDirection(真正的子弹位置和角度.transform.right * speed * -1f);
			break;
		}
		switch (参数)
		{
		case "加横纵深负":
		case "加xyz":
		case "加横纵深-":
			Trans_当前选择.GetComponent<Rigidbody>().velocity = new Vector3(speed * -1f, speed * -1f, speed * -1f);
			break;
		}
		return "判断负速度方向完";
	}

	private string 大小写(string 参数)
	{
		string result = "";
		if (参数 == "X" || 参数 == "x")
		{
			result = "x";
		}
		if (参数 == "Y" || 参数 == "y")
		{
			result = "y";
		}
		if (参数 == "Z" || 参数 == "z")
		{
			result = "z";
		}
		if (参数 == "XYZ" || 参数 == "xyz")
		{
			result = "xyz";
		}
		return result;
	}

	private void 放在文本中(string text)
	{
		if (Manager._instance.Vr2045.输入框.GetComponent<Text>().text != "")
		{
			Text component = Manager._instance.Vr2045.输入框.GetComponent<Text>();
			component.text = component.text + "\n" + text;
		}
		else
		{
			Manager._instance.Vr2045.输入框.GetComponent<Text>().text += text;
		}
		Manager._instance.Vr2045.输入框.transform.parent.transform.Find("Scrollbar").GetComponent<Scrollbar>().value = 0f;
	}

	public float 浮(string 参数)
	{
		是否浮起 = true;
		y = Manager._instance.Down.当前选择.transform.localPosition.y;
		return y;
	}

	public string 乱(string 参数)
	{
		if (Manager._instance.Down.当前选择.GetComponent<VR12345_AIRandMove>() == null)
		{
			Manager._instance.Down.当前选择.AddComponent<VR12345_AIRandMove>();
			StartCoroutine(添加等待时间(0.1f, 参数));
		}
		return "乱完";
	}

	private IEnumerator 添加等待时间(float time, string 参数)
	{
		yield return new WaitForSeconds(time);
		string[] array = 参数.Split('之');
		MonoBehaviour.print(array[1] + "str..");
		string[] array2 = array[1].Split('至');
		foreach (string 参数2 in array2)
		{
			判断值(参数2);
		}
		乱飞数 = 0;
	}

	public void 判断值(string 参数)
	{
		乱飞数++;
		string text = 参数.Substring(0, 1);
		bool flag = text.IndexOf("横") != -1;
		bool flag2 = text.IndexOf("纵") != -1;
		bool flag3 = text.IndexOf("深") != -1;
		string text2 = 参数.Substring(1, 参数.Length - 1);
		if (flag)
		{
			if (text2.IndexOf("纵") != -1)
			{
				string[] array = text2.Split('纵');
				if (乱飞数 == 1)
				{
					MonoBehaviour.print(array[0] + "Num_S1 [0]..");
					VR12345_AIRandMove._instance.minPos_x = float.Parse(array[0]);
					MonoBehaviour.print(array[0] + "Num_S1 [11]..");
				}
				else
				{
					VR12345_AIRandMove._instance.maxPos_x = float.Parse(array[0]);
				}
				if (array[1].IndexOf("深") != -1)
				{
					string[] array2 = array[1].Split('深');
					if (乱飞数 == 1)
					{
						VR12345_AIRandMove._instance.minPos_y = float.Parse(array2[0]);
						VR12345_AIRandMove._instance.minPos_z = float.Parse(array2[1]);
					}
					else
					{
						VR12345_AIRandMove._instance.maxPos_y = float.Parse(array2[0]);
						VR12345_AIRandMove._instance.maxPos_z = float.Parse(array2[1]);
					}
				}
			}
			else
			{
				if (text2.IndexOf("深") == -1)
				{
					return;
				}
				string[] array3 = text2.Split('深');
				if (乱飞数 == 1)
				{
					VR12345_AIRandMove._instance.minPos_x = float.Parse(array3[0]);
				}
				else
				{
					VR12345_AIRandMove._instance.maxPos_x = float.Parse(array3[0]);
				}
				if (array3[1].IndexOf("纵") != -1)
				{
					string[] array4 = array3[1].Split('纵');
					if (乱飞数 == 1)
					{
						VR12345_AIRandMove._instance.minPos_z = float.Parse(array4[0]);
						VR12345_AIRandMove._instance.minPos_y = float.Parse(array4[1]);
					}
					else
					{
						VR12345_AIRandMove._instance.maxPos_z = float.Parse(array4[0]);
						VR12345_AIRandMove._instance.maxPos_y = float.Parse(array4[1]);
					}
				}
			}
		}
		else if (flag2)
		{
			if (text2.IndexOf("横") != -1)
			{
				string[] array5 = text2.Split('横');
				if (乱飞数 == 1)
				{
					VR12345_AIRandMove._instance.minPos_y = float.Parse(array5[0]);
				}
				else
				{
					VR12345_AIRandMove._instance.maxPos_y = float.Parse(array5[0]);
				}
				if (array5[1].IndexOf("深") != -1)
				{
					string[] array6 = array5[1].Split('深');
					VR12345_AIRandMove._instance.minPos_x = float.Parse(array6[0]);
					VR12345_AIRandMove._instance.minPos_z = float.Parse(array6[1]);
				}
			}
			else
			{
				if (text2.IndexOf("深") == -1)
				{
					return;
				}
				string[] array7 = text2.Split('深');
				VR12345_AIRandMove._instance.minPos_y = float.Parse(array7[0]);
				if (array7[1].IndexOf("横") != -1)
				{
					string[] array8 = array7[1].Split('深');
					if (乱飞数 == 1)
					{
						VR12345_AIRandMove._instance.minPos_z = float.Parse(array8[0]);
						VR12345_AIRandMove._instance.minPos_x = float.Parse(array8[1]);
					}
					else
					{
						VR12345_AIRandMove._instance.maxPos_z = float.Parse(array8[0]);
						VR12345_AIRandMove._instance.maxPos_x = float.Parse(array8[1]);
					}
				}
			}
		}
		else
		{
			if (!flag3)
			{
				return;
			}
			if (text2.IndexOf("横") != -1)
			{
				string[] array9 = text2.Split('横');
				if (乱飞数 == 1)
				{
					VR12345_AIRandMove._instance.minPos_z = float.Parse(array9[0]);
				}
				if (array9[1].IndexOf("纵") != -1)
				{
					string[] array10 = array9[1].Split('纵');
					if (乱飞数 == 1)
					{
						VR12345_AIRandMove._instance.minPos_x = float.Parse(array10[0]);
						VR12345_AIRandMove._instance.minPos_y = float.Parse(array10[1]);
					}
					else
					{
						VR12345_AIRandMove._instance.maxPos_x = float.Parse(array10[0]);
						VR12345_AIRandMove._instance.maxPos_y = float.Parse(array10[1]);
					}
				}
			}
			else
			{
				if (text2.IndexOf("纵") == -1)
				{
					return;
				}
				string[] array11 = text2.Split('横');
				if (乱飞数 == 1)
				{
					VR12345_AIRandMove._instance.minPos_z = float.Parse(array11[0]);
				}
				if (array11[1].IndexOf("横") != -1)
				{
					string[] array12 = array11[1].Split('横');
					if (乱飞数 == 1)
					{
						VR12345_AIRandMove._instance.minPos_y = float.Parse(array12[0]);
						VR12345_AIRandMove._instance.minPos_z = float.Parse(array12[1]);
					}
					else
					{
						VR12345_AIRandMove._instance.maxPos_y = float.Parse(array12[0]);
						VR12345_AIRandMove._instance.maxPos_z = float.Parse(array12[1]);
					}
				}
			}
		}
	}

	public float 绝(string 参数)
	{
		if (Manager._instance.Vr2045.判中文(参数) == "对值")
		{
			return Mathes.GetInstance().绝对值(Manager._instance.Vr2045.判数字(参数));
		}
		return 0f;
	}

	public float 反(string 参数)
	{
		MonoBehaviour.print("hao..de");
		if (Manager._instance.Vr2045.判中文(参数) == "余弦")
		{
			Mathes instance = Mathes.GetInstance();
			放在文本中(Manager._instance.Vr2045.判数字(参数).ToString());
			return instance.反余弦(Manager._instance.Vr2045.判数字(参数));
		}
		if (Manager._instance.Vr2045.判中文(参数) == "正弦")
		{
			return Mathes.GetInstance().反正弦(Manager._instance.Vr2045.判数字(参数));
		}
		if (Manager._instance.Vr2045.判中文(参数) == "正切")
		{
			return Mathes.GetInstance().反正切(Manager._instance.Vr2045.判数字(参数));
		}
		if (Manager._instance.Vr2045.判中文(参数) == "")
		{
			float num = ((参数.IndexOf("-") == -1) ? (float.Parse(Manager._instance.Vr2045.判数字(参数)) * -1f) : float.Parse(Manager._instance.Vr2045.判数字(参数)));
			放在文本中(num.ToString());
			MonoBehaviour.print(num + "num.");
		}
		return 0f;
	}

	public float 正(string 参数)
	{
		if (Manager._instance.Vr2045.判中文(参数) == "弦")
		{
			return Mathes.GetInstance().正弦(Manager._instance.Vr2045.判数字(参数));
		}
		if (Manager._instance.Vr2045.判中文(参数) == "切")
		{
			return Mathes.GetInstance().正切(Manager._instance.Vr2045.判数字(参数));
		}
		return 0f;
	}

	public float 点(string 参数)
	{
		if (Manager._instance.Vr2045.判中文(参数) == "角度")
		{
			return Mathes.GetInstance().点角度(Manager._instance.Vr2045.判数字(参数));
		}
		return 0f;
	}

	public float 上(string 参数)
	{
		if (Manager._instance.Vr2045.判中文(参数) == "舍")
		{
			return Mathes.GetInstance().上舍(Manager._instance.Vr2045.判数字(参数));
		}
		return 0f;
	}

	public float 余(string 参数)
	{
		if (Manager._instance.Vr2045.判中文(参数) == "弦")
		{
			return Mathes.GetInstance().余弦(Manager._instance.Vr2045.判数字(参数));
		}
		return 0f;
	}

	public float 指(string 参数)
	{
		if (Manager._instance.Vr2045.判中文(参数) == "数")
		{
			return Mathes.GetInstance().指数(Manager._instance.Vr2045.判数字(参数));
		}
		return 0f;
	}

	public float 下(string 参数)
	{
		if (参数 == "舍")
		{
			return Mathes.GetInstance().下舍(Manager._instance.Vr2045.判数字(参数));
		}
		return 0f;
	}

	public float 自(string 参数)
	{
		if (Manager._instance.Vr2045.判中文(参数) == "然对数")
		{
			return Mathes.GetInstance().自然对数(Manager._instance.Vr2045.判数字(参数));
		}
		return 0f;
	}

	public float 较(string 参数)
	{
		if (Manager._instance.Vr2045.判中文(参数) == "大")
		{
			return Mathes.GetInstance().较大(Manager._instance.Vr2045.判数字(参数));
		}
		if (Manager._instance.Vr2045.判中文(参数) == "小")
		{
			return Mathes.GetInstance().较小(Manager._instance.Vr2045.判数字(参数));
		}
		return 0f;
	}

	public float 次(string 参数)
	{
		if (参数 == "方")
		{
			return Mathes.GetInstance().次方(参数);
		}
		return 0f;
	}

	public float 随(string 参数)
	{
		if (参数 == "机")
		{
			MonoBehaviour.print("shuiji,,");
			Mathes instance = Mathes.GetInstance();
			Text component = Manager._instance.Vr2045.输入框.GetComponent<Text>();
			component.text = component.text + "\n" + instance.随机();
			Manager._instance.Vr2045.输入框.transform.parent.transform.Find("Scrollbar").GetComponent<Scrollbar>().value = 0f;
			return instance.随机();
		}
		return 0f;
	}

	public float 四(string 参数)
	{
		if (Manager._instance.Vr2045.判中文(参数) == "舍")
		{
			return Mathes.GetInstance().四舍(Manager._instance.Vr2045.判数字(参数));
		}
		return 0f;
	}

	public float 平(string 参数)
	{
		if (Manager._instance.Vr2045.判中文(参数) == "方根")
		{
			return Mathes.GetInstance().平方根(Manager._instance.Vr2045.判数字(参数));
		}
		return 0f;
	}

	public float 十(string 参数)
	{
		if (Manager._instance.Vr2045.判中文(参数) == "底对数")
		{
			return Mathes.GetInstance().十底对数(Manager._instance.Vr2045.判数字(参数));
		}
		return 0f;
	}

	public float 圆(string 参数)
	{
		if (Manager._instance.Vr2045.判中文(参数) == "周率")
		{
			return Mathes.GetInstance().圆周率();
		}
		return 0f;
	}

	public string 凡(string 参数 = "")
	{
		是否凡人视角1 = false;
		TouchPad.SetActive(value: true);
		return "帝完";
	}

	public string 帝(string 参数 = "")
	{
		是否凡人视角1 = true;
		TouchPad.SetActive(value: false);
		主角.SetActive(value: true);
		return "凡完";
	}
}
public class Vr2045 : MonoBehaviour
{
	public GameObject 虚号输入框;

	public static Vr2045 _instance;

	public bool 全局是开始下载;

	public bool 全局是下载完成;

	public bool 全局是下载完成批;

	public bool 为本地全局文本 = true;

	private string 全局文本;

	[NonSerialized]
	public string 公广 = "手游4899\n区1之横25纵0深5\n典虚物之桌子2172001可乐2232001雪碧2232006王老吉2232007地毯2186001沙滩伞2251001沙袋2241001\n为摆桌上等于真 注：景沙滩号2045003\n模桌子\n缩横1纵1深2\n模可乐\n如为摆桌上\n\t放桌子上 \n否\n\t放凳子上 \n如完\n模雪碧\n放可乐旁\n横移0.4 \n模王老吉\n放可乐旁\n横移负0.4\n模地毯\n深负0.8\n模沙滩伞\n深移4\n批5\n\t买沙袋\n\t放桌子上\n\t横移负0.3\n\t深移4.4\n\t横移0.1\n批完";

	public string 当前虚代码;

	public string[] 全局数组;

	public string[] 集参;

	public int 几数据;

	private int i;

	private int k;

	private int j;

	public float 全局分数;

	public Dictionary<string, float> 典分数 = new Dictionary<string, float>();

	private string 串果 = "";

	public StringBuilder content;

	private bool 是否批下;

	public bool 是否批完;

	private bool 全局是批内容;

	private float 全局批数;

	private int 全局值数;

	private int 全局值数1;

	public Dictionary<string, bool> 全局是 = new Dictionary<string, bool>();

	public Dictionary<string, string> 全局串 = new Dictionary<string, string>();

	private Dictionary<string, float> 全局数 = new Dictionary<string, float>();

	public bool 是执行 = true;

	public int 执行一次1;

	public bool 是假;

	private bool 等于否;

	private bool 画布是否隐藏;

	public bool 是否交互;

	public bool 是否分割;

	public GameObject 输入框;

	public float 量数 = 100f;

	public bool 是否爆炸;

	private bool 有延复;

	private bool 当命令是否已经执行;

	private bool 是做;

	private bool 是当;

	private bool 是否判;

	public bool 是否为虚游戏;

	public bool 是否有模;

	public bool 是否玩;

	public List<string> PlayList = new List<string>();

	private int 游戏数;

	private bool 是否玩完;

	public bool 是有换行;

	public bool 是界面;

	private int 宇甲;

	private int 宇乙;

	private int 宇丙;

	private int 宇丁;

	public bool 是否有复;

	public bool 有重复执行;

	private bool 显文本内容;

	private bool 显命令对象;

	public List<GameObject> AllObj = new List<GameObject>();

	public Sprite 闭眼图片;

	public Sprite 睁眼图片;

	public GameObject 显隐按钮;

	public ETCJoystick ETCJoystick;

	public GameObject 多功能按钮;

	public bool 是否多功能按钮显示;

	public GameObject 上一个对象;

	public List<Sprite> 点击多功能图 = new List<Sprite>();

	public List<Sprite> 不点击多功能图 = new List<Sprite>();

	public List<GameObject> 多功能的按钮 = new List<GameObject>();

	public GameObject Player1;

	public bool 是否是人走状态 = true;

	public GameObject 区域Prefabs;

	public GameObject 传送列表;

	public Dictionary<string, GameObject> 区域字典 = new Dictionary<string, GameObject>();

	private void Awake()
	{
		_instance = this;
	}

	private void Start()
	{
		content = new StringBuilder();
	}

	private void FixedUpdate()
	{
		if (Input.GetKey(KeyCode.P))
		{
			圆盘缩放物体();
		}
		if (Input.GetKey(KeyCode.F2))
		{
			隐藏();
		}
	}

	private string 分案(string 参数)
	{
		string[] array = 参数.Split('案');
		for (int i = 1; i < array.Length; i++)
		{
			UnityEngine.Debug.Log(i + "i.........");
			UnityEngine.Debug.Log(array[i] + "串.........");
			array[i].IndexOf('默');
			SendMessage("案", array[i]);
		}
		return "分案完";
	}

	public string[] 分割中(string contents)
	{
		return contents.Split('F');
	}

	public void ButtonDown()
	{
		执行一次1++;
		if (执行一次1 == 1)
		{
			虚语言(null);
		}
	}

	public string 玩(string 参数)
	{
		是否玩 = true;
		if (参数 == "完")
		{
			是否玩完 = true;
			i = 0;
			游戏("");
		}
		else if (!是否玩完 || !是有换行)
		{
			DWay.GetInstance().玩类型(参数);
		}
		return "玩完";
	}

	public string 游戏(string 参数)
	{
		int num = 游戏数;
		if (num < PlayList.Count)
		{
			UnityEngine.Debug.LogWarning(PlayList[num] + "playstring....");
			string 参数2 = PlayList[num];
			Manager._instance.Down.虚文(参数2);
		}
		return "游戏完";
	}

	public void 隐藏()
	{
		if (!画布是否隐藏)
		{
			显隐按钮.GetComponent<Image>().sprite = 闭眼图片;
			foreach (GameObject item in AllObj)
			{
				item.SetActive(value: false);
			}
			MonoBehaviour.print("dd" + Manager._instance.Down.旋转按钮);
			if (多功能按钮.activeSelf)
			{
				MonoBehaviour.print("dd..dd");
				是否多功能按钮显示 = true;
				多功能按钮.SetActive(value: false);
			}
			if (Manager._instance.Down.提示是否出现)
			{
				Manager._instance.Down.下载提示1.SetActive(value: false);
			}
			if (Manager._instance.Down.命令对象.activeSelf)
			{
				显命令对象 = true;
				Manager._instance.Down.命令对象.SetActive(value: false);
			}
			if (Manager._instance.Down.文本内容.activeSelf)
			{
				显文本内容 = true;
				Manager._instance.Down.文本内容.SetActive(value: false);
			}
		}
		else
		{
			显隐按钮.GetComponent<Image>().sprite = 睁眼图片;
			foreach (GameObject item2 in AllObj)
			{
				item2.SetActive(value: true);
			}
			MonoBehaviour.print("dd" + Manager._instance.Down.旋转按钮);
			if (是否多功能按钮显示)
			{
				MonoBehaviour.print("dd");
				是否多功能按钮显示 = false;
				多功能按钮.SetActive(value: true);
			}
			if (Manager._instance.Down.提示是否出现)
			{
				Manager._instance.Down.下载提示1.SetActive(value: true);
			}
			if (显命令对象)
			{
				显命令对象 = false;
				Manager._instance.Down.命令对象.SetActive(value: true);
			}
			if (显文本内容)
			{
				显文本内容 = false;
				Manager._instance.Down.文本内容.SetActive(value: true);
			}
		}
		画布是否隐藏 = !画布是否隐藏;
	}

	private void Update()
	{
		是否再次循环(全局数组);
	}

	public void 取文本(string 参数)
	{
		全局文本 = 预处理(参数);
		当前虚代码 = 全局文本;
		string text = 语法颜色(当前虚代码);
		输入框.GetComponent<Text>().text = text;
		if (是否玩)
		{
			虚语言(null);
		}
	}

	private void 虚语言(string 参数)
	{
		if (Manager._instance.ButtonDown.是虚代码)
		{
			全局文本 = 输入框.GetComponent<Text>().text;
			当前虚代码 = 全局文本;
		}
		是有换行 = 全局文本.IndexOf("\n") != -1;
		if (是有换行)
		{
			全局数组 = 割(当前虚代码);
			循环(全局数组);
		}
		else
		{
			SendMessage(首字(全局文本), 余字(全局文本));
		}
	}

	public void 循环(string[] 参数)
	{
		i = 几数据;
		while (i < 参数.Length)
		{
			if (!全局是开始下载)
			{
				串果 = 全局数组[i];
				串果 = 删前后空(串果);
				if (Manager._instance.YanFu.是否延复)
				{
					几数据 = i + 1;
					有延复 = true;
					执(串果);
					连接字符(串果);
					Manager._instance.YanFu.延复对象 = Manager._instance.Down.request.asset;
					Manager._instance.YanFu.延复选择 = Manager._instance.Down.当前选择;
				}
				if (是执行 && !Manager._instance.JieMian.是否为事件)
				{
					执(串果);
				}
				if (是否判)
				{
					是执行 = false;
					执(串果);
					连接字符(串果);
				}
				if (是做 && !是当)
				{
					执(串果);
					连接字符(串果);
				}
				if (是当)
				{
					是做 = false;
					是当 = false;
					连接字符(串果);
					几数据 = i + 1;
					Manager._instance.Loop.循环当命令(content.ToString());
					break;
				}
				if ((是假 && 串果 == "否") || (是假 && 等于否))
				{
					if (等于否)
					{
						执(串果);
					}
					等于否 = true;
				}
				if (串果 == "如完")
				{
					是假 = false;
					执(串果);
				}
				if (全局是批内容)
				{
					几数据 = i + 1;
					break;
				}
				if (是否有模)
				{
					几数据 = i + 1;
					break;
				}
				if (Manager._instance.JieMian.是否为事件)
				{
					UnityEngine.Debug.Log("事件执行....");
					Manager._instance.Down.按钮功能(串果);
				}
				i++;
				continue;
			}
			全局是开始下载 = false;
			break;
		}
	}

	private void 是否再次循环(string[] 参数)
	{
		if (i < 参数.Length && 全局是下载完成 && !全局是批内容)
		{
			全局是下载完成 = false;
			几数据 = i;
			循环(全局数组);
		}
		if (是否批完 && 全局是下载完成)
		{
			是否批完 = false;
			全局是下载完成 = false;
			全局是下载完成批 = false;
			k = 全局值数;
			j = 全局值数1;
			执行批命令();
		}
	}

	private void 执(string 参数)
	{
		整个批(参数);
		if (参数 == "做" || 首字(参数) == "当")
		{
			if (!当命令是否已经执行)
			{
				当命令是否已经执行 = true;
				content = new StringBuilder();
			}
			Manager._instance.Loop.甲 = 0;
			是执行 = false;
			是做 = true;
		}
		if (参数 == "当完")
		{
			是执行 = true;
			是当 = true;
		}
		if (首字(参数) != "批" && !Manager._instance.YanFu.是否延复 && !是做 && !是否判 && !是否批下)
		{
			广(参数);
		}
		if (首字(参数) == "判" && 参数 != "判完")
		{
			是否判 = true;
			content = new StringBuilder();
		}
		if (首字(参数) == "判" && 参数 == "判完")
		{
			是执行 = true;
			是否判 = false;
			UnityEngine.Debug.Log(content.ToString() + ".........content..............");
			分案(content.ToString());
		}
		if (参数 == "复批")
		{
			Manager._instance.YanFu.是否延复 = true;
			content = new StringBuilder();
		}
		if (参数 == "复批完")
		{
			Manager._instance.YanFu.是否延复 = false;
		}
		if (首字(参数) == "批" && 参数 != "批完" && !是否批下)
		{
			是否批下 = true;
			content = new StringBuilder();
			全局批数 = float.Parse(余字(参数));
		}
		if (参数 == "虚游完" || 参数 == "手游完")
		{
			UnityEngine.Debug.LogWarning("是否玩....." + 是否玩);
			if (是否玩)
			{
				游戏数++;
				游戏("");
			}
			Manager._instance.YanFu.是否虚完 = true;
			MonoBehaviour.print("完完完");
			if (Manager._instance.Trans_form.区对象数组.Count > 0)
			{
				for (int i = 0; i < Manager._instance.Trans_form.区对象数组.Count; i++)
				{
					GameObject Obj = UnityEngine.Object.Instantiate(区域Prefabs, 传送列表.transform).gameObject;
					MonoBehaviour.print(Obj.transform.localPosition.y + "..y");
					MonoBehaviour.print(i + "i...");
					Obj.transform.localPosition = new Vector3(Obj.transform.localPosition.x, Obj.transform.localPosition.y - (float)(40 * i), Obj.transform.localPosition.z);
					Obj.transform.Find("Text").GetComponent<Text>().text = Manager._instance.Trans_form.区对象数组[i].name;
					区域字典.Add(Manager._instance.Trans_form.区对象数组[i].name, Manager._instance.Trans_form.区对象数组[i]);
					Obj.GetComponent<UnityEngine.UI.Button>().onClick.AddListener(delegate
					{
						点击区域(Obj.transform.Find("Text").GetComponent<Text>().text);
					});
				}
			}
			复原();
		}
		else if (首字(参数) == "模" || 首字(参数) == "听" || 首字(参数) == "看" || 首字(参数) == "玩")
		{
			是否有模 = true;
		}
	}

	public void 点击区域(string str)
	{
		_ = 区域字典[str];
	}

	public string 广(string 参数 = "")
	{
		foreach (KeyValuePair<string, float> item in Manager._instance.Trans_form.轴典)
		{
			_ = item;
		}
		if (首字(参数) == "复")
		{
			是否有复 = true;
			return "广完";
		}
		参数 = 参数.Trim();
		SendMessage(首字(参数), 余字(参数));
		return "广完";
	}

	public void 复原()
	{
		Manager._instance.YanFu.第一次设置位置 = 0;
		是否有复 = false;
		Manager._instance.YanFu.次数 = 0;
		几数据 = 0;
		全局是开始下载 = false;
		全局是下载完成 = false;
		全局是下载完成批 = false;
		是否批下 = false;
		是否批完 = false;
		全局是批内容 = false;
		全局批数 = 0f;
		全局值数 = 0;
		全局值数1 = 0;
		Manager._instance.Down.执行一次 = 0;
		执行一次1 = 0;
		有延复 = false;
		content = new StringBuilder();
		当命令是否已经执行 = false;
		Manager._instance.Down.listName = new List<string>();
	}

	private void 整个批(string 参数)
	{
		if (是否批下)
		{
			if (参数 != "批完")
			{
				连接字符(参数);
				return;
			}
			执行批命令();
			全局是批内容 = true;
		}
	}

	public void 连接字符(string 参数)
	{
		content.Append(参数);
		content.Append("F");
		if (有延复)
		{
			Manager._instance.YanFu.延复内容 = content;
		}
	}

	private void 执行批命令()
	{
		是否批下 = false;
		是否批完 = true;
		string[] array = content.ToString().Split('F');
		甲("0");
		乙("0");
		丙("0");
		丁("0");
		j = 全局值数1;
		while ((float)j < 全局批数)
		{
			宇甲 = j;
			for (k = 全局值数; k < array.Length - 1; k++)
			{
				广(array[k]);
				if (k == array.Length - 2)
				{
					全局值数 = 0;
					全局值数1++;
				}
				if (全局是下载完成批)
				{
					全局值数++;
					break;
				}
			}
			if (!全局是下载完成批)
			{
				if ((float)j == 全局批数 - 1f)
				{
					全局是批内容 = false;
					全局是开始下载 = false;
					循环(全局数组);
				}
				j++;
				continue;
			}
			break;
		}
	}

	public string[] 割(string 参数)
	{
		换(参数 + "广分隔(\r\n|\n)广分隔===");
		string[] result = new string[200];
		bool num = 寻(参数 + "广分隔\r\n") != -1;
		bool flag = 寻(参数 + "广分隔\n") != -1;
		bool flag2 = 寻(参数 + "广分隔\r") != -1;
		bool flag3 = 寻(参数 + "广分隔,") != -1;
		bool flag4 = 寻(参数 + "广分隔 ") != -1;
		Regex regex = new Regex("\\r\\n");
		if (num)
		{
			return regex.Split(参数);
		}
		if (flag)
		{
			return 参数.Split('\n');
		}
		if (flag2)
		{
			return 参数.Split('\r');
		}
		if (flag3)
		{
			return 参数.Split(',');
		}
		if (flag4)
		{
			return 参数.Split(' ');
		}
		MonoBehaviour.print("报错：割无分割符");
		return result;
	}

	private int 寻(string 参数)
	{
		return 参1(参数).IndexOf(参2(参数));
	}

	private string 物每(string[] 参数)
	{
		for (int i = 0; i < 参数.Length; i++)
		{
			_ = 参数[i];
		}
		return "物每完";
	}

	private string 砍(string 参数)
	{
		string text = 参1(参数);
		int startIndex = 到整(参2(参数));
		int length = 到整(参3(参数));
		return text.Substring(startIndex, length);
	}

	public string 首字(string 参数 = "ok")
	{
		参数 = 参数.Trim();
		if (参数 != "")
		{
			return 参数.Substring(0, 1);
		}
		return "";
	}

	public string 余字(string 参数)
	{
		return 参数.Substring(1);
	}

	private string 余参(string 参数)
	{
		return 参数.Substring(1);
	}

	private string 二参(string 参数)
	{
		return 参数.Substring(2);
	}

	private string 三参(string 参数)
	{
		return 参数.Substring(3);
	}

	private int 到整(string 参数)
	{
		return int.Parse(参数);
	}

	private string 参1(string 参数)
	{
		集参 = 割参(参数);
		return 集参[0];
	}

	private string 参2(string 参数)
	{
		集参 = 割参(参数);
		return 集参[1];
	}

	private string 参3(string 参数)
	{
		集参 = 割参(参数);
		return 集参[2];
	}

	public string[] 割参(string 参数)
	{
		是否分割 = true;
		bool num = 参数.IndexOf("广分隔") != -1;
		bool flag = 参数.IndexOf(",") != -1;
		bool flag2 = 参数.IndexOf(" ") != -1;
		bool flag3 = 参数.IndexOf("与") != -1;
		bool flag4 = 参数.IndexOf("、") != -1;
		bool flag5 = 参数.IndexOf("横纵深") != -1;
		bool flag6 = 参数.IndexOf("\n") != -1;
		if (num)
		{
			集参 = Regex.Split(参数, "广分隔", RegexOptions.IgnoreCase);
		}
		else if (flag)
		{
			集参 = 参数.Split(new char[1] { ',' }, StringSplitOptions.RemoveEmptyEntries);
		}
		else if (flag2)
		{
			集参 = 参数.Split(new char[1] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
		}
		else if (flag3)
		{
			集参 = 参数.Split(new char[1] { '与' }, StringSplitOptions.RemoveEmptyEntries);
		}
		else if (flag4)
		{
			集参 = 参数.Split(new char[1] { '、' }, StringSplitOptions.RemoveEmptyEntries);
		}
		else if (flag5)
		{
			集参 = 参数.Split(new char[3] { '横', '纵', '深' }, StringSplitOptions.RemoveEmptyEntries);
		}
		else if (!flag6)
		{
			是否分割 = false;
		}
		return 集参;
	}

	public string 语法颜色(string 参数 = "")
	{
		new GUIStyle().richText = true;
		string 参数2 = 一令颜色(参数);
		参数2 = 数字颜色(参数2);
		参数2 = 分隔颜色(参数2);
		参数2 = 注释颜色(参数2);
		return 运算颜色(参数2);
	}

	public string 一令颜色(string 参数 = "")
	{
		return 换(参数 + "广分隔([ \\t]+.)广分隔<color=#569cd6ff>$1</color>");
	}

	public string 数字颜色(string 参数 = "")
	{
		return 换(参数 + "广分隔([0123478])广分隔<color=#f39800ff>$1</color>");
	}

	public string 分隔颜色(string 参数 = "")
	{
		return 换(参数 + "广分隔([之为与或乃完])广分隔<color=#ea68a2ff>$1</color>");
	}

	public string 注释颜色(string 参数 = "")
	{
		return 换(参数 + "广分隔(注.*$)广分隔<color=#98d6f7ff>$1</color>");
	}

	public string 运算颜色(string 参数 = "")
	{
		return 换(参数 + "广分隔((等于|不等|大于|大等|小等|全等))广分隔<color=#ea68a2ff>$1</color>");
	}

	public string 换(string 参数 = "")
	{
		string text = Regex.Replace(参1(参数), 参2(参数), 参3(参数));
		印("换串果:" + text);
		return text;
	}

	public string 印(string 参数 = "")
	{
		return "印完";
	}

	public void 容错存(string[] 参数)
	{
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		foreach (string 参数2 in 参数)
		{
			string[] array = 割参(参数2);
			if (!是否分割)
			{
				break;
			}
			if (array[1].IndexOf('|') != -1)
			{
				string[] array2 = array[1].Split('|');
				foreach (string key in array2)
				{
					dictionary.Add(key, array[0]);
				}
			}
			else
			{
				dictionary.Add(array[1], array[0]);
			}
		}
		foreach (string key2 in dictionary.Keys)
		{
			if (全局文本.IndexOf(key2) != -1)
			{
				全局文本.Replace(key2, dictionary[key2]);
			}
		}
		dictionary = null;
		语法颜色(全局文本.Substring(1, 全局文本.Length - 2));
		ButtonDown();
	}

	public void 爆(string 参数)
	{
		GameObject gameObject = GameObject.Find(参数).gameObject;
		gameObject.SetActive(value: false);
		GameObject original = Resources.Load("boom", typeof(GameObject)) as GameObject;
		Vector3 position = gameObject.transform.localPosition + new Vector3(0f, 0.09f, 0f);
		UnityEngine.Object.Instantiate(original, position, gameObject.transform.rotation);
	}

	private void 碰(string 参数)
	{
		if (Manager._instance.JieMian.是否为事件)
		{
			MonoBehaviour.print("11111111111111111111111111");
			if (参数.Substring(参数.Length - 1, 1) != "完")
			{
				_ = GameObject.Find("Canvas1").gameObject.transform.Find("Image").gameObject.active;
				Manager._instance.JieMian.开始内容数据 = 参数;
				Manager._instance.JieMian.是否碰到 = true;
			}
			else
			{
				string text = 参数.Substring(0, 参数.Length - 1);
				MonoBehaviour.print(text + "names....");
				Manager._instance.JieMian.是否碰到 = false;
				Manager._instance.JieMian.典事件.Add(text, Manager._instance.Vr2045.content.ToString());
				Manager._instance.Vr2045.content = new StringBuilder();
			}
		}
		else
		{
			string[] array = 参数.Split('加');
			string key = array[0];
			if (判中文(array[1]) == "空")
			{
				全局分数 = float.Parse(array[1]);
				典分数.Add(key, 全局分数);
			}
			if (判数字(array[1]) == "空" && array[1] == "爆炸")
			{
				是否爆炸 = true;
			}
		}
	}

	public string 预处理(string 参数)
	{
		string result = 删注释(参数);
		Manager._instance.Down.简(参数);
		return result;
	}

	public string 删注释(string 参数)
	{
		return Regex.Replace(参数, "注：.*", "");
	}

	private string 删前后空(string 参数)
	{
		if (参数 != null)
		{
			参数 = 参数.Trim();
		}
		return 参数;
	}

	private void 为(string 参数)
	{
		string[] array = 参数.Split(new char[2] { '等', '于' }, StringSplitOptions.RemoveEmptyEntries);
		string text = array[0];
		text = "为" + text;
		bool value = array[1] == "真";
		if (全局是.ContainsKey(text))
		{
			全局是.Remove(text);
			全局是.Add(text, value);
		}
		else
		{
			全局是.Add(text, value);
		}
	}

	private void 串(string 参数)
	{
		string[] array = 参数.Split(new char[2] { '等', '于' }, StringSplitOptions.RemoveEmptyEntries);
		string text = array[0];
		text = "串" + text;
		string value = array[1];
		if (全局串.ContainsKey(text))
		{
			全局串.Remove(text);
			全局串.Add(text, value);
		}
		else
		{
			全局串.Add(text, value);
		}
	}

	private void 数(string 参数)
	{
		string[] array = 参数.Split(new char[2] { '等', '于' }, StringSplitOptions.RemoveEmptyEntries);
		string text = array[0];
		text = "数" + text;
		float value = float.Parse(array[1]);
		全局数.Add(text, value);
	}

	public string 变(string 参数)
	{
		_ = 参数 == "量";
		_ = 参数 == "量完";
		return "变完";
	}

	private void 几(string 参数)
	{
		bool num = 参数.IndexOf("等于") != -1;
		bool flag = 参数.IndexOf("=") != -1;
		string[] array = new string[10];
		if (num)
		{
			array = 参数.Split(new char[2] { '等', '于' }, StringSplitOptions.RemoveEmptyEntries);
		}
		else if (flag)
		{
			array = 参数.Split('=');
		}
		string text = array[0];
		text = "几" + text;
		float value = float.Parse(array[1]);
		Manager._instance.JieMian.文几字典.Add(text, value);
	}

	public string 判中文(string 参数)
	{
		MatchCollection matchCollection = new Regex("[\\u4e00-\\u9fa5]").Matches(参数);
		StringBuilder stringBuilder = new StringBuilder();
		foreach (Match item in matchCollection)
		{
			stringBuilder.Append(item.Value);
		}
		return stringBuilder.ToString();
	}

	public string 判数字(string 参数)
	{
		MatchCollection matchCollection = new Regex("\\d+\\.?\\d*").Matches(参数);
		StringBuilder stringBuilder = new StringBuilder();
		foreach (Match item in matchCollection)
		{
			stringBuilder.Append(item.Value);
		}
		return stringBuilder.ToString();
	}

	private void 可(string 参数)
	{
		if (参数 == "交互")
		{
			是否交互 = true;
		}
	}

	public float 量(string 参数)
	{
		量数 = float.Parse(参数);
		return 量数;
	}

	private string[] 阵(string 参数)
	{
		if (参数.IndexOf(' ') != -1)
		{
			string[] result = 参数.Split(' ');
			MonoBehaviour.print("为空串.......");
			return result;
		}
		string[] result2 = new string[3];
		MonoBehaviour.print("错误:要用空格来保存数组");
		return result2;
	}

	private string 虚(string 参数)
	{
		string text = 判中文(参数);
		if (text == "游")
		{
			是否为虚游戏 = false;
		}
		else if (text == "游玩")
		{
			是否为虚游戏 = true;
		}
		return "完";
	}

	private string 手(string 参数)
	{
		string text = 判中文(参数);
		if (text == "游")
		{
			是否为虚游戏 = false;
		}
		else if (text == "游完")
		{
			是否为虚游戏 = true;
			if (是否有复)
			{
				有重复执行 = true;
			}
		}
		return "完";
	}

	private string 界(string 参数)
	{
		是界面 = true;
		return "完";
	}

	private string 甲(string 参数)
	{
		宇甲 = int.Parse(参数);
		return 参数;
	}

	private string 乙(string 参数)
	{
		宇乙 = int.Parse(参数);
		return 参数;
	}

	private string 丙(string 参数)
	{
		宇丙 = int.Parse(参数);
		return 参数;
	}

	private string 丁(string 参数)
	{
		宇丁 = int.Parse(参数);
		return 参数;
	}

	private string 开(string 参数)
	{
		if (参数 == "摄像头")
		{
			GameObject.Find("Canvas1").gameObject.transform.Find("Image").gameObject.SetActive(value: true);
			StartCoroutine(等待开启(0.1f));
		}
		return "开完";
	}

	private IEnumerator 等待开启(float time)
	{
		yield return new WaitForSeconds(time);
		StartCoroutine(WebCamManager._instance.CallCamera());
	}

	public void 圆盘移动物体()
	{
		是否是人走状态 = false;
		选择为当前对象();
		图片隐藏();
		多功能的按钮[0].GetComponent<Image>().sprite = 点击多功能图[0];
		ETCJoystick.axisX.directAction = ETCAxis.DirectAction.TranslateLocal;
		ETCJoystick.axisY.directAction = ETCAxis.DirectAction.TranslateLocal;
		ETCJoystick.axisX.axisInfluenced = ETCAxis.AxisInfluenced.X;
		ETCJoystick.axisY.axisInfluenced = ETCAxis.AxisInfluenced.Z;
	}

	public void 圆盘缩放物体()
	{
		是否是人走状态 = false;
		选择为当前对象();
		图片隐藏();
		多功能的按钮[3].GetComponent<Image>().sprite = 点击多功能图[3];
		ETCJoystick.axisX.directAction = ETCAxis.DirectAction.Scale;
		ETCJoystick.axisY.directAction = ETCAxis.DirectAction.Scale;
	}

	public void 圆盘旋转物体()
	{
		是否是人走状态 = false;
		选择为当前对象();
		图片隐藏();
		多功能的按钮[2].GetComponent<Image>().sprite = 点击多功能图[2];
		ETCJoystick.axisX.directAction = ETCAxis.DirectAction.RotateLocal;
		ETCJoystick.axisY.directAction = ETCAxis.DirectAction.RotateLocal;
		ETCJoystick.axisX.axisInfluenced = ETCAxis.AxisInfluenced.Y;
		ETCJoystick.axisY.axisInfluenced = ETCAxis.AxisInfluenced.Y;
	}

	public void 人走物体()
	{
		是否是人走状态 = true;
		图片隐藏();
		多功能的按钮[1].GetComponent<Image>().sprite = 点击多功能图[1];
		Manager._instance.Down.当前选择.tag = "Untagged";
		Player1.tag = "Player";
		ETCJoystick.axisX.autoLinkTagPlayer = true;
		ETCJoystick.axisY.autoLinkTagPlayer = true;
		ETCJoystick.axisX.InitAxis();
		ETCJoystick.axisY.InitAxis();
		ETCJoystick.axisX.axisInfluenced = ETCAxis.AxisInfluenced.X;
		ETCJoystick.axisY.axisInfluenced = ETCAxis.AxisInfluenced.Z;
		ETCJoystick.axisX.directAction = ETCAxis.DirectAction.TranslateLocal;
		ETCJoystick.axisY.directAction = ETCAxis.DirectAction.TranslateLocal;
	}

	public void 选择为当前对象()
	{
		MonoBehaviour.print(Manager._instance.Down.当前选择.name + ".name.");
		if ((bool)上一个对象)
		{
			MonoBehaviour.print(上一个对象.name + ",,,name...");
			上一个对象.tag = "Untagged";
		}
		ETCJoystick.axisX.autoLinkTagPlayer = true;
		ETCJoystick.axisY.autoLinkTagPlayer = true;
		Manager._instance.Down.当前选择.tag = "Player";
		Player1.tag = "Untagged";
		ETCJoystick.axisX.InitAxis();
		ETCJoystick.axisY.InitAxis();
		上一个对象 = Manager._instance.Down.当前选择;
	}

	public void 图片隐藏()
	{
		for (int i = 0; i < 多功能的按钮.Count; i++)
		{
			多功能的按钮[i].GetComponent<Image>().sprite = 不点击多功能图[i];
		}
	}

	public void 多()
	{
	}

	public void 说()
	{
	}
}
public class YanFu : MonoBehaviour
{
	public bool 是否延复;

	private int 几数;

	[HideInInspector]
	public Rigidbody bodys;

	public bool 开始延复;

	private bool 是否延迟;

	public GameObject 延复选择;

	public UnityEngine.Object 延复对象;

	public StringBuilder 延复内容;

	[HideInInspector]
	public int 第一次设置位置;

	[HideInInspector]
	public int 次数;

	private Vector3 vector;

	public bool 是否虚完;

	private StringBuilder Ycontent;

	private GameObject 延区对象;

	private void Awake()
	{
	}

	private void FixedUpdate()
	{
		if (次数 == 0)
		{
			if ((是否延迟 || Manager._instance.Vr2045.有重复执行) && 延复内容 != null)
			{
				次数++;
				Ycontent = new StringBuilder();
				Manager._instance.YanFu.开始延复 = true;
				Ycontent = 延复内容;
				Manager._instance.YanFu.分割延复(Ycontent.ToString());
			}
		}
		else if (是否延迟 && Ycontent != null)
		{
			Manager._instance.YanFu.开始延复 = true;
			Manager._instance.YanFu.分割延复(Ycontent.ToString());
		}
	}

	public string 分割延复(string contents)
	{
		MonoBehaviour.print("contents....." + contents);
		string[] array = contents.Split('F');
		for (int i = 几数; i < array.Length - 1; i++)
		{
			几数++;
			string text = array[i];
			if (text == "复批完")
			{
				几数 = 0;
				是否虚完 = false;
			}
			else
			{
				SendMessage(Manager._instance.Vr2045.首字(text), Manager._instance.Vr2045.余字(text));
			}
		}
		return "完";
	}

	private string 抛(string 参数)
	{
		if (开始延复)
		{
			bodys = 延复选择.GetComponent<Rigidbody>();
			MonoBehaviour.print(延复选择.name + "naem1111........");
		}
		MonoBehaviour.print(延复选择.name + "naem........");
		if (Manager._instance.Trans_form.轴方向(参数))
		{
			bodys.AddForce(Manager._instance.Trans_form.轴典["横"], Manager._instance.Trans_form.轴典["纵"], Manager._instance.Trans_form.轴典["深"]);
		}
		else
		{
			bodys.AddForce(float.Parse(Manager._instance.Trans_form.Trans_集参[0]), float.Parse(Manager._instance.Trans_form.Trans_集参[1]), float.Parse(Manager._instance.Trans_form.Trans_集参[2]));
		}
		return "抛完";
	}

	private string 延(string 参数)
	{
		MonoBehaviour.print(几数 + "延迟,.......");
		是否延迟 = false;
		延复选择 = GameObjectPool.GetInstance().MyInstantiate(延复对象);
		第一次设置位置++;
		if (第一次设置位置 == 1)
		{
			Vector3 当前始 = Manager._instance.Trans_form.当前始;
			UnityEngine.Debug.Log(vector);
			延复选择.transform.localPosition = 当前始;
			延复选择.transform.parent = Manager._instance.Trans_form.区对象.transform;
			vector = 延复选择.transform.localPosition;
			延区对象 = Manager._instance.Trans_form.区对象;
		}
		else
		{
			延复选择.transform.parent = 延区对象.transform;
			延复选择.transform.localPosition = vector;
		}
		float time = float.Parse(Manager._instance.Vr2045.判数字(参数));
		Invoke("延迟", time);
		return "延时完";
	}

	private void 延迟()
	{
		GameObjectPool.GetInstance().MyDisable(延复选择);
		是否延迟 = true;
	}
}
public class JieMian : MonoBehaviour
{
	public bool 是否为界面;

	public string 靠几 = "1";

	private float 靠数;

	public Vector2 放的位置;

	public float 放数;

	public List<GameObject> 框对象 = new List<GameObject>();

	private GameObject 框对象1;

	private bool 是否换行;

	private float 换行y;

	public Dictionary<string, float> 文几字典 = new Dictionary<string, float>();

	public Dictionary<string, string> 典事件 = new Dictionary<string, string>();

	public Dictionary<string, GameObject> 几文本变量 = new Dictionary<string, GameObject>();

	private float 换的数量;

	private int 多框;

	private GameObject testOBj;

	private GameObject testOBj1;

	public bool 是否开始事件;

	public bool 是否为事件;

	private bool 是否开始倒计时;

	public bool 是否结束倒计时;

	public bool 是否碰到;

	private float AllTime;

	private GameObject 当前文本对象;

	private string 典名字;

	public bool 按下屏幕;

	public GameObject MainCamera;

	public AudioClip 激光声;

	public GameObject 激光obj;

	public GameObject 爆炸;

	public float 得分;

	public float 子弹数;

	private Vector3 射中位置 = new Vector3(0f, 0f, 0f);

	public LineRenderer line;

	public GameObject 激光开始位置;

	public GameObject 效果;

	private int 开始数据;

	public string 开始内容数据;

	private bool 是否有按字;

	private bool 是否游戏结束;

	private List<GameObject> pool = new List<GameObject>();

	public bool 是否开始执行事件;

	private void Update()
	{
		if (是否开始倒计时)
		{
			AllTime -= Time.deltaTime;
			int num = (int)AllTime;
			当前文本对象.GetComponent<Text>().text = num.ToString();
			if (num <= 0)
			{
				是否游戏结束 = true;
				是否开始倒计时 = false;
				MonoBehaviour.print("退出游戏》。。。。");
				分割的事件(典名字);
			}
		}
		if (Input.GetButtonDown("Fire1") && 典事件.ContainsKey("按屏幕") && !是否游戏结束)
		{
			分割的事件("按屏幕");
		}
		if (Input.GetButtonUp("Fire1") && 典事件.ContainsKey("按屏幕"))
		{
			激光obj.SetActive(value: false);
		}
	}

	private void 射线射击(GameObject obj)
	{
		MonoBehaviour.print("涉及。。。");
		Ray ray = Camera.main.ScreenPointToRay(obj.transform.position);
		Physics.RaycastAll(ray);
		if (!Physics.Raycast(ray, out var hitInfo, 100f))
		{
			return;
		}
		MonoBehaviour.print(hitInfo.transform.name);
		string key = Manager._instance.Vr2045.判中文(hitInfo.transform.name);
		射中位置 = hitInfo.point;
		foreach (KeyValuePair<string, string> item in Manager._instance.JieMian.典事件)
		{
			MonoBehaviour.print(item.Key + "    " + item.Value);
		}
		if (典事件.ContainsKey(key))
		{
			MonoBehaviour.print(hitInfo.transform.name + "name...");
			分割的事件(key);
			UnityEngine.Object.Destroy(hitInfo.transform.gameObject);
		}
	}

	public string 界(string 参数)
	{
		MonoBehaviour.print(参数);
		if (参数 == "面")
		{
			MonoBehaviour.print("you..");
			是否为界面 = true;
		}
		if (参数 == "面完")
		{
			是否为界面 = false;
		}
		MonoBehaviour.print(是否为界面 + "...s是否为界面..");
		return "完";
	}

	public string 靠(string 参数)
	{
		靠数 = 0f;
		if (!(参数.Substring(参数.Length - 1, 1) == "完"))
		{
			靠几 = 参数;
		}
		return "靠完";
	}

	public string 锚点(string num)
	{
		GameObject 当前选择 = Manager._instance.Down.当前选择;
		float x = 当前选择.transform.localScale.x;
		float y = 当前选择.transform.localScale.y;
		UnityEngine.Debug.Log(num + "..num..");
		switch (num)
		{
		case "1":
			当前选择.transform.localPosition = new Vector3(13f * x, -13f * y, 0f);
			当前选择.GetComponent<RectTransform>().anchorMin = new Vector2(0f, 1f);
			当前选择.GetComponent<RectTransform>().anchorMax = new Vector2(0f, 1f);
			break;
		case "2":
			当前选择.transform.localPosition = new Vector3(-1.2f * x, -13.5f * y, 0f);
			当前选择.GetComponent<RectTransform>().anchorMin = new Vector2(0.5f, 1f);
			当前选择.GetComponent<RectTransform>().anchorMax = new Vector2(0.5f, 1f);
			break;
		case "3":
			当前选择.GetComponent<RectTransform>().localPosition = new Vector3(-14.6f * x, -13.5f * y, 0f);
			UnityEngine.Debug.Log(当前选择.GetComponent<RectTransform>().localPosition);
			当前选择.GetComponent<RectTransform>().anchorMin = new Vector2(1f, 1f);
			当前选择.GetComponent<RectTransform>().anchorMax = new Vector2(1f, 1f);
			break;
		case "4":
			UnityEngine.Debug.Log("4");
			当前选择.transform.localPosition = new Vector3(13f * x, -2.5f * y, 0f);
			当前选择.GetComponent<RectTransform>().anchorMin = new Vector2(0f, 0.5f);
			当前选择.GetComponent<RectTransform>().anchorMax = new Vector2(0f, 0.5f);
			break;
		case "5":
			当前选择.transform.localPosition = new Vector3(-1.2f * x, -2.5f * y, 0f);
			当前选择.GetComponent<RectTransform>().anchorMin = new Vector2(0.5f, 0.5f);
			当前选择.GetComponent<RectTransform>().anchorMax = new Vector2(0.5f, 0.5f);
			break;
		case "6":
			当前选择.transform.localPosition = new Vector3(-14.6f * x, -2.5f * y, 0f);
			当前选择.GetComponent<RectTransform>().anchorMin = new Vector2(1f, 0.5f);
			当前选择.GetComponent<RectTransform>().anchorMax = new Vector2(1f, 0.5f);
			break;
		case "7":
			当前选择.transform.localPosition = new Vector3(13f * x, 13f * y, 0f);
			当前选择.GetComponent<RectTransform>().anchorMin = new Vector2(0f, 0f);
			当前选择.GetComponent<RectTransform>().anchorMax = new Vector2(0f, 0f);
			break;
		case "8":
			当前选择.transform.localPosition = new Vector3(-1.2f * x, 13f * y, 0f);
			当前选择.GetComponent<RectTransform>().anchorMin = new Vector2(0.5f, 0f);
			当前选择.GetComponent<RectTransform>().anchorMax = new Vector2(0.5f, 0f);
			break;
		case "9":
			当前选择.transform.localPosition = new Vector3(-14.6f * x, 13f * y, 0f);
			当前选择.GetComponent<RectTransform>().anchorMin = new Vector2(1f, 0f);
			当前选择.GetComponent<RectTransform>().anchorMax = new Vector2(1f, 0f);
			break;
		}
		Manager._instance.Down.当前选择 = 当前选择;
		return "完";
	}

	public GameObject 创建图标(string 参数)
	{
		GameObject gameObject = GameObject.Find("Canvas").gameObject;
		GameObject original = Resources.Load(参数, typeof(GameObject)) as GameObject;
		MonoBehaviour.print(参数 + "...参数....");
		return UnityEngine.Object.Instantiate(original, gameObject.transform).gameObject;
	}

	public string 钮(string 参数)
	{
		Manager._instance.Down.当前选择 = 创建图标("Button1");
		bool 是宽 = 参数.IndexOf("宽") != -1;
		bool 是高 = 参数.IndexOf("高") != -1;
		string text = 添加物体大小和图片名(是宽, 是高, 参数);
		string path = "PNG/界面图/" + text;
		Manager._instance.Down.当前选择.name = text;
		Sprite sprite = Resources.Load(path, typeof(Sprite)) as Sprite;
		Manager._instance.Down.当前选择.GetComponent<Image>().sprite = sprite;
		物体的父类();
		锚点(靠几);
		判断是否有放();
		有换行();
		return "钮完";
	}

	public string 框(string 参数)
	{
		if (参数 != "完")
		{
			Manager._instance.Down.当前选择 = 创建图标("框");
			bool 是宽 = 参数.IndexOf("宽") != -1;
			bool 是高 = 参数.IndexOf("高") != -1;
			添加物体大小和图片名(是宽, 是高, 参数);
			锚点(靠几);
			判断是否有放();
			UnityEngine.Debug.Log(框对象.Count + ".....框对象.Count......");
			if (框对象.Count > 0)
			{
				物体的父类();
			}
			多框++;
			if (框对象1 == null)
			{
				框对象1 = Manager._instance.Down.当前选择;
				框对象.Add(Manager._instance.Down.当前选择);
			}
			else
			{
				if (框对象1 != Manager._instance.Down.当前选择)
				{
					UnityEngine.Debug.LogWarning("啦啦。。。");
					框对象.Add(Manager._instance.Down.当前选择);
				}
				框对象1 = Manager._instance.Down.当前选择;
			}
		}
		else
		{
			testOBj1 = 框对象[框对象.Count - 1];
			框对象.Remove(框对象[框对象.Count - 1]);
			多框 = 0;
		}
		return "完";
	}

	public string 判断是否有放()
	{
		if (放数 == 1f)
		{
			UnityEngine.Debug.Log("访美");
			放数 = 0f;
			Manager._instance.Down.当前选择.transform.localPosition = 放的位置;
			UnityEngine.Debug.Log(Manager._instance.Down.当前选择.GetComponent<RectTransform>().anchoredPosition);
		}
		return "完";
	}

	public string 物体的父类()
	{
		if (框对象.Count > 0)
		{
			testOBj = 框对象[0];
			UnityEngine.Debug.LogWarning(多框);
			Manager._instance.Down.当前选择.transform.parent = 框对象[框对象.Count - 1].transform;
		}
		return "完";
	}

	public string 添加物体大小和图片名(bool 是宽, bool 是高, string 参数)
	{
		string text = "nil";
		string text2 = "nil";
		string result = "nil";
		if (是宽 && 是高)
		{
			string[] array = 参数.Split('宽');
			if (array[1].IndexOf("高") != -1)
			{
				string[] array2 = array[1].Split('高');
				text = array2[0];
				text2 = array2[1];
				result = array[0].Trim();
			}
			else
			{
				text = array[1];
				string[] array3 = array[0].Split('高');
				text2 = array3[1];
				result = array3[0].Trim();
			}
			float num = Manager._instance.Down.当前选择.GetComponent<RectTransform>().rect.width * Manager._instance.Down.当前选择.transform.localScale.x;
			float num2 = Manager._instance.Down.当前选择.GetComponent<RectTransform>().rect.height * Manager._instance.Down.当前选择.transform.localScale.y;
			float num3 = float.Parse(text);
			float num4 = float.Parse(text2);
			float x = num3 / num;
			float y = num4 / num2;
			Manager._instance.Down.当前选择.transform.localScale = new Vector2(x, y);
		}
		if (是宽 && !是高)
		{
			string[] array4 = 参数.Split('宽');
			text = array4[1];
			result = array4[0].Trim();
			float num5 = Manager._instance.Down.当前选择.GetComponent<RectTransform>().rect.width * Manager._instance.Down.当前选择.transform.localScale.x;
			float x2 = float.Parse(text) / num5;
			Manager._instance.Down.当前选择.transform.localScale = new Vector2(x2, Manager._instance.Down.当前选择.transform.localScale.y);
		}
		if (!是宽 && 是高)
		{
			string[] array5 = 参数.Split('高');
			text2 = array5[1];
			result = array5[0].Trim();
			float num6 = Manager._instance.Down.当前选择.GetComponent<RectTransform>().rect.height * Manager._instance.Down.当前选择.transform.localScale.y;
			float y2 = float.Parse(text2) / num6;
			Manager._instance.Down.当前选择.transform.localScale = new Vector2(Manager._instance.Down.当前选择.transform.localScale.x, y2);
		}
		return result;
	}

	public Vector2 判断方位(string 参数)
	{
		bool num = 参数.IndexOf("左") != -1;
		bool flag = 参数.IndexOf("右") != -1;
		bool flag2 = 参数.IndexOf("上") != -1;
		bool flag3 = 参数.IndexOf("下") != -1;
		Vector2 vector = new Vector2(0f, 0f);
		if (num)
		{
			vector = new Vector2(位置放(3), Manager._instance.Down.当前选择.transform.localPosition.y);
			Vector2 vector2 = vector;
			UnityEngine.Debug.Log(vector2.ToString() + "..vector..");
		}
		else if (flag)
		{
			vector = new Vector2(位置放(4), Manager._instance.Down.当前选择.transform.localPosition.y);
		}
		else if (flag2)
		{
			vector = new Vector2(Manager._instance.Down.当前选择.transform.localPosition.x, 位置放(1));
		}
		else if (flag3)
		{
			vector = new Vector2(Manager._instance.Down.当前选择.transform.localPosition.x, 位置放(2));
		}
		return vector;
	}

	public float 位置放(int index)
	{
		float num = Manager._instance.Down.当前选择.GetComponent<RectTransform>().rect.height / 2f;
		float num2 = Manager._instance.Down.当前选择.GetComponent<RectTransform>().rect.width / 2f;
		float x = Manager._instance.Down.当前选择.transform.localScale.x;
		float y = Manager._instance.Down.当前选择.transform.localScale.y;
		float result = 0f;
		if (index == 1)
		{
			result = Manager._instance.Down.当前选择.transform.localPosition.y + num * y;
		}
		if (index == 2)
		{
			result = Manager._instance.Down.当前选择.transform.localPosition.y - num * y;
		}
		if (index == 3)
		{
			UnityEngine.Debug.Log(Manager._instance.Down.当前选择.name);
			UnityEngine.Debug.Log(Manager._instance.Down.当前选择.transform.localPosition);
			result = Manager._instance.Down.当前选择.transform.localPosition.x - num2 * x;
		}
		if (index == 4)
		{
			result = Manager._instance.Down.当前选择.transform.localPosition.x + num2 * x;
		}
		return result;
	}

	public string 换(string 参数)
	{
		换的数量 += 1f;
		if (参数 == "行")
		{
			是否换行 = true;
			UnityEngine.Debug.Log(Manager._instance.Down.当前选择.name);
			换行y = 位置移动(Manager._instance.Down.当前选择);
			UnityEngine.Debug.Log(换行y + "...换行y...");
		}
		return "完";
	}

	public string 有换行()
	{
		if (是否换行)
		{
			是否换行 = false;
			if (换的数量 > 1f)
			{
				_ = 换的数量;
			}
			float y = 换行y - Manager._instance.Down.当前选择.GetComponent<RectTransform>().rect.height / 2f * Manager._instance.Down.当前选择.transform.localScale.y;
			Manager._instance.Down.当前选择.transform.localPosition = new Vector2(Manager._instance.Down.当前选择.transform.localPosition.x, y);
		}
		return "完";
	}

	public string 距(string 参数)
	{
		MonoBehaviour.print(参数 + "..参数...");
		判断具体位置(参数);
		return "完";
	}

	public string 判断具体位置(string 参数)
	{
		UnityEngine.Debug.LogWarning("lala...");
		string text = Manager._instance.Vr2045.判中文(参数);
		bool flag = text.IndexOf("左") != -1;
		bool flag2 = text.IndexOf("右") != -1;
		bool flag3 = text.IndexOf("上") != -1;
		bool flag4 = text.IndexOf("下") != -1;
		if (flag)
		{
			string[] array = 参数.Split('左');
			string s = ((!(flag2 || flag3 || flag4)) ? Manager._instance.Vr2045.判数字(array[1]) : array[1].Split(new char[3] { '右', '上', '下' }, StringSplitOptions.RemoveEmptyEntries)[0]);
			float num = float.Parse(s);
			MonoBehaviour.print(num + "...数....");
			float x = Manager._instance.Down.当前选择.transform.localPosition.x + num;
			UnityEngine.Debug.Log(Manager._instance.Down.当前选择.transform.localPosition.x + "xxx...");
			UnityEngine.Debug.Log(Manager._instance.Down.当前选择.GetComponent<RectTransform>().anchoredPosition.x + "xx111x...");
			UnityEngine.Debug.Log(x + "...ww...");
			UnityEngine.Debug.Log(Manager._instance.Down.当前选择.name);
			Manager._instance.Down.当前选择.transform.localPosition = new Vector2(x, Manager._instance.Down.当前选择.transform.localPosition.y);
		}
		if (flag2)
		{
			string[] array2 = 参数.Split('右');
			string s = ((!(flag || flag3 || flag4)) ? Manager._instance.Vr2045.判数字(array2[1]) : array2[1].Split(new char[3] { '左', '上', '下' }, StringSplitOptions.RemoveEmptyEntries)[0]);
			float num2 = float.Parse(s);
			MonoBehaviour.print(num2 + "...数....");
			UnityEngine.Debug.Log(Manager._instance.Down.当前选择.GetComponent<RectTransform>().anchoredPosition.y + "xx111x...");
			float x = Manager._instance.Down.当前选择.transform.localPosition.x - num2;
			Manager._instance.Down.当前选择.transform.localPosition = new Vector2(x, Manager._instance.Down.当前选择.transform.localPosition.y);
		}
		if (flag3)
		{
			string[] array3 = 参数.Split('上');
			string s = ((!(flag2 || flag || flag4)) ? Manager._instance.Vr2045.判数字(array3[1]) : array3[1].Split(new char[3] { '右', '左', '下' }, StringSplitOptions.RemoveEmptyEntries)[0]);
			float num3 = float.Parse(s);
			MonoBehaviour.print(num3 + "...数111....");
			UnityEngine.Debug.Log(Manager._instance.Down.当前选择.transform.localPosition.y + "xxx...");
			UnityEngine.Debug.Log(Manager._instance.Down.当前选择.GetComponent<RectTransform>().anchoredPosition.y + "xx111x...");
			float x = Manager._instance.Down.当前选择.transform.localPosition.y - num3;
			UnityEngine.Debug.Log(x + "...ww...");
			Manager._instance.Down.当前选择.transform.localPosition = new Vector2(Manager._instance.Down.当前选择.transform.localPosition.x, x);
		}
		if (flag4)
		{
			string[] array4 = 参数.Split('下');
			string s = ((!(flag2 || flag || flag3)) ? Manager._instance.Vr2045.判数字(array4[1]) : array4[1].Split(new char[3] { '右', '左', '上' }, StringSplitOptions.RemoveEmptyEntries)[0]);
			float num4 = float.Parse(s);
			MonoBehaviour.print(num4 + "...数111....");
			float x = Manager._instance.Down.当前选择.transform.localPosition.y + num4;
			Manager._instance.Down.当前选择.transform.localPosition = new Vector2(Manager._instance.Down.当前选择.transform.localPosition.x, x);
		}
		return "完";
	}

	public float 位置移动(GameObject 对象)
	{
		float y = 对象.transform.localScale.y;
		float num = 对象.GetComponent<RectTransform>().rect.height * y / 2f;
		UnityEngine.Debug.Log(num + "...高...");
		float result = 对象.transform.localPosition.y - num;
		UnityEngine.Debug.Log(对象.transform.localPosition.y + "dd.d...");
		return result;
	}

	public string 色(string 参数)
	{
		Text component = Manager._instance.Down.当前选择.GetComponent<Text>();
		Color color = ColorRevert.ToColor(参数);
		component.color = color;
		return "色完";
	}

	public string 壮(string 参数)
	{
		int fontSize = int.Parse(Manager._instance.Vr2045.判数字(参数));
		Manager._instance.Down.当前选择.GetComponent<Text>().fontSize = fontSize;
		return "壮完";
	}

	public string 体(string 参数)
	{
		Font font = Resources.Load("Font/" + 参数, typeof(Font)) as Font;
		Manager._instance.Down.当前选择.GetComponent<Text>().font = font;
		return "体完";
	}

	public string 事(string 参数)
	{
		if (参数 == "件")
		{
			是否为事件 = true;
		}
		if (参数 == "件完")
		{
			是否为事件 = false;
		}
		return "事完";
	}

	public void 按(string 参数)
	{
		开始数据++;
		if (开始数据 == 1)
		{
			开始内容数据 = 参数;
		}
		if (参数.Substring(参数.Length - 1, 1) != "完" && 参数 != "屏幕")
		{
			是否开始事件 = true;
			UnityEngine.UI.Button component = GameObject.Find("Canvas/" + 参数).gameObject.GetComponent<UnityEngine.UI.Button>();
			string names = "按" + 参数;
			Manager._instance.Vr2045.content = new StringBuilder();
			component.onClick.AddListener(delegate
			{
				执行事件(names);
			});
		}
		if (参数 == "屏幕")
		{
			按下屏幕 = true;
			开始内容数据 = 参数;
		}
		else
		{
			if (!(参数.Substring(参数.Length - 1, 1) == "完"))
			{
				return;
			}
			MonoBehaviour.print(参数.Substring(0, 参数.Length - 1) + "...");
			MonoBehaviour.print(开始内容数据 + "..开始内容数据..");
			if (!(参数.Substring(0, 参数.Length - 1) == 开始内容数据))
			{
				return;
			}
			开始数据 = 0;
			是否开始事件 = false;
			按下屏幕 = false;
			string text = "按" + 参数.Substring(0, 参数.Length - 1);
			MonoBehaviour.print(text + "namess..");
			if (!(text != ""))
			{
				return;
			}
			典事件.Add(text, Manager._instance.Vr2045.content.ToString());
			Manager._instance.Vr2045.content = new StringBuilder();
			foreach (KeyValuePair<string, string> item in Manager._instance.JieMian.典事件)
			{
				MonoBehaviour.print(item.Key + "    " + item.Value);
			}
		}
	}

	public void 执行事件(string name)
	{
		MonoBehaviour.print(name + "name....");
		是否游戏结束 = false;
		分割的事件(name);
		MonoBehaviour.print("点击事件.." + name);
	}

	public void 分割的事件(string name)
	{
		MonoBehaviour.print("总事件:11111111");
		string text = 典事件[name];
		MonoBehaviour.print("总事件:" + text);
		string[] array = text.Split('F');
		StringBuilder stringBuilder = new StringBuilder();
		for (int i = 0; i < array.Length - 1; i++)
		{
			MonoBehaviour.print(array[i] + "。。。。。数据。。。。。。。");
			if (是否有按字)
			{
				MonoBehaviour.print(array[i].Substring(array[i].Length - 1, 1) + "总事件...");
				if (array[i].Substring(array[i].Length - 1, 1) == "完")
				{
					MonoBehaviour.print("执行完..s");
					是否有按字 = false;
					Manager._instance.Vr2045.广(array[i]);
				}
				else
				{
					MonoBehaviour.print("执行完.");
					stringBuilder.Append(array[i]);
					stringBuilder.Append('F');
					Manager._instance.Vr2045.content = stringBuilder;
				}
				MonoBehaviour.print(Manager._instance.Vr2045.content?.ToString() + "..content...");
			}
			else
			{
				Manager._instance.Vr2045.广(array[i]);
			}
			if (array[i].IndexOf('按') != -1 && array[i].Substring(array[i].Length - 1, 1) != "完")
			{
				是否有按字 = true;
			}
		}
	}

	public string 倒(string 参数)
	{
		if (参数.IndexOf("之") != -1)
		{
			string[] array = 参数.Split('之');
			MonoBehaviour.print(array[1] + "割串[1]...");
			if (文几字典.ContainsKey(array[1]))
			{
				MonoBehaviour.print(array[1] + "割串[1]...");
				AllTime = 文几字典[array[1]];
				MonoBehaviour.print(AllTime + "alltime...");
				当前文本对象 = 几文本变量[array[1]];
				是否开始倒计时 = true;
			}
		}
		else
		{
			if (参数.Substring(参数.Length - 2, 2) == "结束")
			{
				开始内容数据 = 参数;
				是否结束倒计时 = true;
			}
			if (参数.Substring(参数.Length - 1, 1) == "完")
			{
				是否结束倒计时 = false;
				典名字 = 参数;
				典事件.Add(典名字, Manager._instance.Vr2045.content.ToString());
				Manager._instance.Vr2045.content = new StringBuilder();
			}
		}
		return "倒完";
	}

	public string 朝(string 参数)
	{
		string[] array = 参数.Split('之');
		GameObject obj = GameObject.Find("Canvas").gameObject.transform.Find(array[0]).gameObject;
		MainCamera.transform.Find(array[1]).gameObject.SetActive(value: true);
		射线射击(obj);
		return "朝完";
	}

	public string 效(string 参数)
	{
		string 参数2 = (Regex.IsMatch(参数.Substring(0, 7), "^[a-zA-Z]") ? 参数 : 参数.Substring(0, 7));
		Manager._instance.Down.模(参数2);
		Manager._instance.vr12888.是否下载特效 = true;
		Manager._instance.vr12888.模型名 = 参数;
		Invoke("等待消失", 0.5f);
		return "效完";
	}

	private void 等待消失()
	{
	}

	public string 得(string 参数)
	{
		bool num = 参数.IndexOf('+') != -1;
		bool flag = 参数.IndexOf('加') != -1;
		if (num || flag)
		{
			float num2 = float.Parse(Manager._instance.Vr2045.判数字(参数));
			得分 += num2;
			几文本变量["几得分"].GetComponent<Text>().text = 得分.ToString();
		}
		return "得完";
	}

	public string 子(string 参数)
	{
		bool num = 参数.IndexOf('-') != -1;
		bool flag = 参数.IndexOf('减') != -1;
		if (num || flag)
		{
			float num2 = float.Parse(Manager._instance.Vr2045.判数字(参数));
			子弹数 = int.Parse(几文本变量["几子弹数"].GetComponent<Text>().text);
			子弹数 -= num2;
			几文本变量["几子弹数"].GetComponent<Text>().text = 子弹数.ToString();
		}
		return "完";
	}
}
public class SVG : MonoBehaviour
{
	private string 串福 = "<svg width='100' height='100' viewBox='0 0 100 100'><circle cx='50' cy='50' r='50' fill='red'/></svg>";

	private void Start()
	{
		Mesh mesh = SVGReader.ReadSVG(串福);
		GameObject obj = GameObject.Find("/方测SVG");
		obj.gameObject.GetComponent<MeshFilter>().mesh = mesh;
		MonoBehaviour.print(mesh);
		MonoBehaviour.print(obj);
	}

	private void Update()
	{
	}
}
public class SVGReader
{
	public static Mesh ReadSVG(string svgContent)
	{
		string[] array = svgContent.Split('\n');
		List<Vector3> list = new List<Vector3>();
		List<int> list2 = new List<int>();
		List<Vector2> list3 = new List<Vector2>();
		int num = 0;
		for (int i = 0; i < array.Length; i++)
		{
			string text = array[i].Trim();
			if (!text.StartsWith("<polygon"))
			{
				continue;
			}
			string[] array2 = text.Split('"')[1].Split(' ');
			for (int j = 0; j < array2.Length; j++)
			{
				string[] array3 = array2[j].Split(',');
				float x = float.Parse(array3[0]);
				float y = float.Parse(array3[1]);
				list.Add(new Vector3(x, y, 0f));
				list3.Add(new Vector2(x, y));
				if (j > 1)
				{
					list2.Add(num);
					list2.Add(num + j - 1);
					list2.Add(num + j);
				}
			}
			num += array2.Length;
		}
		Mesh mesh = new Mesh();
		mesh.vertices = list.ToArray();
		mesh.triangles = list2.ToArray();
		mesh.uv = list3.ToArray();
		mesh.RecalculateNormals();
		return mesh;
	}
}
public class testes : MonoBehaviour
{
	public static testes _instance;

	private float x;

	private float y;

	private float RspeedX = 6f;

	private Vector3 direction;

	private float minAngle;

	private float maxAngle = 180f;

	private float camHeight = 0.3f;

	private float distance = 3.5f;

	public Transform target;

	private static Material lineMaterial;

	private float width;

	private float lenght;

	private float height;

	private float customNum = 0.01f;

	public bool 是否法宝;

	public int index;

	private bool 是否有长宽高值;

	private bool 是否Y为正值 = true;

	private bool 是否倒下;

	private int num = 1;

	private void Awake()
	{
		_instance = this;
	}

	public void 长宽高(GameObject Cube)
	{
		if ((bool)Cube.GetComponent<MeshFilter>())
		{
			num = 1;
			是否有长宽高值 = true;
			width = Cube.GetComponent<MeshFilter>().mesh.bounds.size.x * Cube.transform.localScale.x;
			lenght = Cube.GetComponent<MeshFilter>().mesh.bounds.size.z * Cube.transform.localScale.z;
			height = Cube.GetComponent<MeshFilter>().mesh.bounds.size.y * Cube.transform.localScale.y;
			MonoBehaviour.print("yoj66..." + Cube.transform.localEulerAngles.x % 360f);
			if (Cube.transform.localEulerAngles.z == 0f || Cube.transform.localEulerAngles.x == 0f || Cube.transform.localEulerAngles.z == 360f || Cube.transform.localEulerAngles.x == 360f)
			{
				是否Y为正值 = true;
			}
			if (Mathf.Abs(Cube.transform.localEulerAngles.z) == 180f || Mathf.Abs(Cube.transform.localEulerAngles.x) == 180f)
			{
				是否Y为正值 = false;
			}
			else
			{
				是否Y为正值 = true;
				是否倒下 = false;
			}
			if (Cube.transform.localEulerAngles.x / 90f == 1f || Cube.transform.localEulerAngles.x / 90f == 3f || Cube.transform.localEulerAngles.z / 90f == 1f || Cube.transform.localEulerAngles.z / 90f == 3f)
			{
				是否倒下 = true;
				if (Cube.transform.localEulerAngles.x == 270f || Cube.transform.localEulerAngles.z == 270f)
				{
					num = -1;
				}
				MonoBehaviour.print("yowwj...");
			}
			else
			{
				是否倒下 = false;
			}
		}
		else
		{
			是否有长宽高值 = false;
		}
	}

	private void Update()
	{
		if (Manager._instance.Trans_form.是否凡人视角1)
		{
			MonoBehaviour.print(Manager._instance.Trans_form.是否凡人视角1 + "..");
			CameraRotate();
		}
	}

	private static void CreateLineMaterial()
	{
		lineMaterial = new Material("Shader \"Hidden/Alpha\" {SubShader { Pass { ZTest Always Cull Off ZWrite Off Blend DstAlpha Zero Color (1,1,1,1) }}}");
		lineMaterial.hideFlags = HideFlags.HideAndDontSave;
		lineMaterial.shader.hideFlags = HideFlags.HideAndDontSave;
		lineMaterial.SetPass(0);
	}

	private void OnPostRender()
	{
		if (是否法宝 && 是否有长宽高值)
		{
			GL.PushMatrix();
			GL.Begin(1);
			GL.Color(Color.white);
			float num = Manager._instance.Down.当前选择.transform.localPosition.y;
			float num2 = num;
			float num3 = Manager._instance.Down.当前选择.transform.localPosition.x - width / 2f - customNum;
			float num4 = Manager._instance.Down.当前选择.transform.localPosition.z - lenght / 2f * (float)this.num - customNum * (float)this.num;
			num2 = ((!是否倒下) ? num2 : (num2 - lenght / 2f));
			Vector3 v = new Vector3(num3, num2, num4);
			Vector3 v2 = new Vector3(num3 + width + customNum * 2f, num2, num4);
			Vector3 v3 = new Vector3(num3 + width + customNum * 2f, num2, num4);
			Vector3 v4;
			Vector3 v5;
			Vector3 v6;
			Vector3 v7;
			if (是否倒下)
			{
				v4 = new Vector3(num3 + width + customNum * 2f, num2 + lenght + customNum * 2f, num4);
				v5 = new Vector3(num3 + width + customNum * 2f, num2 + lenght + customNum * 2f, num4);
				v6 = new Vector3(num3, num2 + lenght + customNum * 2f, num4);
				v7 = new Vector3(num3, num2 + lenght + customNum * 2f, num4);
			}
			else
			{
				v4 = new Vector3(num3 + width + customNum * 2f, num2, num4 + lenght + customNum * 2f);
				v5 = new Vector3(num3 + width + customNum * 2f, num2, num4 + lenght + customNum * 2f);
				v6 = new Vector3(num3, num2, num4 + lenght + customNum * 2f);
				v7 = new Vector3(num3, num2, num4 + lenght + customNum * 2f);
			}
			Vector3 v8 = new Vector3(num3, num2, num4);
			float num5 = ((!是否Y为正值) ? (num - height - customNum) : (num + height + customNum));
			Vector3 v9;
			Vector3 v10;
			Vector3 v11;
			Vector3 v12;
			Vector3 v13;
			Vector3 v14;
			Vector3 v15;
			Vector3 v16;
			if (是否倒下)
			{
				v9 = new Vector3(num3, num2, (height + customNum) * (float)this.num);
				v10 = new Vector3(num3 + width + customNum * 2f, num2, (height + customNum) * (float)this.num);
				v11 = new Vector3(num3 + width + customNum * 2f, num2, (height + customNum) * (float)this.num);
				v12 = new Vector3(num3 + width + customNum * 2f, num2 + lenght + customNum * 2f, (height + customNum) * (float)this.num);
				v13 = new Vector3(num3 + width + customNum * 2f, num2 + lenght + customNum * 2f, (height + customNum) * (float)this.num);
				v14 = new Vector3(num3, num2 + lenght + customNum * 2f, (height + customNum) * (float)this.num);
				v15 = new Vector3(num3, num2 + lenght + customNum * 2f, (height + customNum) * (float)this.num);
				v16 = new Vector3(num3, num2, (height + customNum) * (float)this.num);
			}
			else
			{
				v9 = new Vector3(num3, num5, num4);
				v10 = new Vector3(num3 + width + customNum * 2f, num5, num4);
				v11 = new Vector3(num3 + width + customNum * 2f, num5, num4);
				v12 = new Vector3(num3 + width + customNum * 2f, num5, num4 + lenght + customNum * 2f);
				v13 = new Vector3(num3 + width + customNum * 2f, num5, num4 + lenght + customNum * 2f);
				v14 = new Vector3(num3, num5, num4 + lenght + customNum * 2f);
				v15 = new Vector3(num3, num5, num4 + lenght + customNum * 2f);
				v16 = new Vector3(num3, num5, num4);
			}
			Vector3 v17;
			Vector3 v18;
			Vector3 v19;
			Vector3 v20;
			if (是否倒下)
			{
				v17 = new Vector3(num3, num2, num4);
				v18 = new Vector3(num3, num2, (height + customNum) * (float)this.num);
				v19 = new Vector3(num3, num2 + lenght + customNum * 2f, num4);
				v20 = new Vector3(num3, num2 + lenght + customNum * 2f, (height + customNum) * (float)this.num);
			}
			else
			{
				v17 = new Vector3(num3, num2, num4);
				v18 = new Vector3(num3, num5, num4);
				v19 = new Vector3(num3, num2, num4 + lenght + customNum * 2f);
				v20 = new Vector3(num3, num5, num4 + lenght + customNum * 2f);
			}
			Vector3 v21;
			Vector3 v22;
			Vector3 v23;
			Vector3 v24;
			if (是否倒下)
			{
				v21 = new Vector3(num3 + width + customNum * 2f, num2, num4);
				v22 = new Vector3(num3 + width + customNum * 2f, num2, (height + customNum) * (float)this.num);
				v23 = new Vector3(num3 + width + customNum * 2f, num2 + lenght + customNum * 2f, num4);
				v24 = new Vector3(num3 + width + customNum * 2f, num2 + lenght + customNum * 2f, (height + customNum) * (float)this.num);
			}
			else
			{
				v21 = new Vector3(num3 + width + customNum * 2f, num2, num4);
				v22 = new Vector3(num3 + width + customNum * 2f, num5, num4);
				v23 = new Vector3(num3 + width + customNum * 2f, num2, num4 + lenght + customNum * 2f);
				v24 = new Vector3(num3 + width + customNum * 2f, num5, num4 + lenght + customNum * 2f);
			}
			GL.Vertex(v);
			GL.Vertex(v2);
			GL.Vertex(v3);
			GL.Vertex(v4);
			GL.Vertex(v5);
			GL.Vertex(v6);
			GL.Vertex(v7);
			GL.Vertex(v8);
			GL.Vertex(v9);
			GL.Vertex(v10);
			GL.Vertex(v11);
			GL.Vertex(v12);
			GL.Vertex(v13);
			GL.Vertex(v14);
			GL.Vertex(v15);
			GL.Vertex(v16);
			GL.Vertex(v17);
			GL.Vertex(v18);
			GL.Vertex(v19);
			GL.Vertex(v20);
			GL.Vertex(v21);
			GL.Vertex(v22);
			GL.Vertex(v23);
			GL.Vertex(v24);
			GL.End();
			GL.PopMatrix();
		}
		else
		{
			index++;
			if (index == 1)
			{
				GL.PushMatrix();
				GL.Begin(1);
				Vector3 v25 = new Vector3(0f, 0f, 0f);
				Vector3 v26 = new Vector3(0f, 0f, 0.01f);
				GL.Vertex(v25);
				GL.Vertex(v26);
				GL.End();
				GL.PopMatrix();
			}
		}
	}

	private void CameraRotate()
	{
		if (Input.GetMouseButton(0))
		{
			MonoBehaviour.print("dad,,,");
			x += Input.GetAxis("Mouse X") * RspeedX;
			y -= Input.GetAxis("Mouse Y") * RspeedX;
			y = ClampAngle(y, minAngle, maxAngle);
			Quaternion quaternion = Quaternion.Euler(y, x, 0f);
			direction = new Vector3(0f, camHeight, 0f - distance);
			base.transform.rotation = quaternion;
			base.transform.position = target.position + quaternion * direction;
			y = ClampAngle(y, minAngle, maxAngle);
		}
	}

	private static float ClampAngle(float angle, float min, float max)
	{
		if (angle < -360f)
		{
			angle += 360f;
		}
		if (angle > 360f)
		{
			angle -= 360f;
		}
		return Mathf.Clamp(angle, min, max);
	}
}
public class 摘 : MonoBehaviour
{
	public string url;

	[Obsolete]
	private void Start()
	{
		string 取广 = 佐.逮.取广;
		批摘(取广);
		GameObject.Find("/=虚/-单字").transform.Translate(-11.2f, 0f, 12.45f);
	}

	[Obsolete]
	public void 空摘(string 串参)
	{
		拿(串参 + ".广");
	}

	[Obsolete]
	public void 批摘(string 串参)
	{
		Regex regex = new Regex("\\r\\n");
		Regex regex2 = new Regex("");
		string[] array = regex.Split(串参);
		string text = ".广";
		for (int i = 0; i < array.Length; i++)
		{
			string text2 = array[i];
			text2 = text2.Trim();
			string[] array2 = regex2.Split(text2);
			for (int j = 0; j < array2.Length - 1; j++)
			{
				if (array2[j].Length != 0)
				{
					拿(array2[j] + text);
				}
			}
		}
	}

	[Obsolete]
	public void 拿(string 串参)
	{
		GameObject gameObject;
		if (串参 == "廣.广")
		{
			gameObject = new GameObject("廣");
		}
		else
		{
			AssetBundle assetBundle = AssetBundle.LoadFromFile(Path.Combine(UnityEngine.Application.streamingAssetsPath + "/" + 佐.逮.址() + "/", 串参));
			if (assetBundle == null)
			{
				UnityEngine.Debug.Log("未能加载AssetBundle！");
				佐.逮.公告.text = "未能加载：" + 佐.逮.址();
				return;
			}
			string key = 串参.Substring(0, 1);
			gameObject = UnityEngine.Object.Instantiate(assetBundle.LoadAsset<GameObject>(key));
			佐.逮.公典虚.Add(key, gameObject);
		}
		GameObject gameObject2 = GameObject.Find("/=虚/-单字");
		gameObject.transform.parent = gameObject2.transform;
		移(gameObject);
	}

	public string 患(string[] 阵参)
	{
		string text = "";
		foreach (string text2 in 阵参)
		{
			text = text + text2 + ",";
		}
		return text;
	}

	public void 移(GameObject 物参)
	{
		string value = 物参.transform.name.Substring(0, 1);
		int num = 佐.逮.取广.IndexOf(value);
		string text = 佐.逮.取广.Substring(0, num);
		char 炭换行 = '\n';
		int num2 = text.Count((char f) => f == 炭换行) + 1;
		int num3 = 佐.逮.取广.Count((char f) => f == 炭换行) + 1;
		int num4 = text.LastIndexOf("\n");
		float x = (float)(-(num - num4)) * 佐.逮.公几速虚 / 10f;
		float y = (float)(num3 - num2) * 佐.逮.公几速虚 / 10f;
		float z = 0f;
		float num5 = 1f * 佐.逮.公几速虚;
		物参.transform.localEulerAngles = new Vector3(0f, 180f, 0f);
		物参.transform.localScale = new Vector3(num5, num5, num5);
		物参.transform.Translate(x, y, z);
		碰(物参);
	}

	private void 碰(GameObject 物体)
	{
		BoxCollider boxCollider = 物体.AddComponent<BoxCollider>();
		boxCollider.center = new Vector3(-0.04f, 0.05f, 0f);
		boxCollider.size = new Vector3(0.1f, 0.1f, 0.01f);
		物体.AddComponent<射线>();
		GameObject obj = UnityEngine.Object.Instantiate(Resources.Load("预制/射线事件") as GameObject);
		GameObject gameObject = GameObject.Find("/=令/-事/射线事件");
		obj.transform.SetParent(gameObject.transform);
	}
}
public class 采 : MonoBehaviour
{
	public string url;

	private string 串广公 = "虚世界微渺元宇宙引擎\r\n人模令效动玩图听看产资它\r\n变横平纵垂深浅斜坠抬迁爬跌移挪滚翻拧扭旋转宽窄高矮\r\n俺放缩厚薄胖瘦肥扁大小来去撑戏挺沉阔伸起落\r\n我你他她上下左右摇前后升降飞天地内外翔缠绵懵懂\r\n呆摆过收展拱瞧远近距达朝望跟踪巡逻\r\n走跑奔跃蹲打闪必\r\n选旨巧式主谓宾参羔其货多少访持扬片倘若\r\n广文章节题滤签价为几串阵物链评赞函司群组排隐谁户时\r\n闻长替换捞掏割找迂摘连勺筹赛觅含勿罕牡丹洁烧烤煲\r\n共执建开关存另撤再剪\r\n造方球胶柱板院环棱锥遛楔穹塔壶梯刻歪矫盒珠梦\r\n形路直曲弧角钝尖波闭骨并交差凸凹通卷补封准折雅孔\r\n互扳抓拿遥锁载传感器光灯聚亮暗唱歌跳舞迪岛\r\n状矩圆椭描扇星\r\n钮富汪杜曹卢徐单复盼盯浏览漏拍摄录麦庄\r\n材金木水火土银铜铁铝钢铅山石冰塑渲烘玻泥瓷毛皮肤纹\r\n颜红橙黄绿青靛蓝紫乌黑白灰粉翠碧棕朱赤褐渐彩艳纯\r\n特爆炸雾雪风雨雷电烟春夏秋冬霜雹焰泡沫烁虹辐露幻粒\r\n理轻重气吹温\r\n修笔绘填锋喷\r\n演播暂停场趁使嫌稍进退快慢往倒回洗循秀原果\r\n韵１２３４５６７８９０－＝鸣荡谱奏鼓镲笛筝唠叨吵响\r\n数一二三四五六七八九零减等加乘除余十百千万亿兆京\r\n钥壹贰叁肆伍陆柒捌玖拾涨广";

	[Obsolete]
	private void Start()
	{
		批采(串广公);
	}

	[Obsolete]
	public void 空采(string 串参)
	{
		StartCoroutine(拿(串参));
	}

	[Obsolete]
	public void 批采(string 串参)
	{
		Regex regex = new Regex("\\r\\n");
		Regex regex2 = new Regex("");
		string[] array = regex.Split(串参);
		url = "http://xuniren.com/2048/";
		string text = ".广";
		foreach (string input in array)
		{
			string[] source = regex2.Split(input);
			source = source.Where((string s) => !string.IsNullOrEmpty(s)).ToArray();
			for (int j = 0; j < source.Length - 1; j++)
			{
				StartCoroutine(拿(url + source[j] + text));
			}
		}
	}

	[Obsolete]
	public IEnumerator 拿(string 串参)
	{
		UnityWebRequest www = UnityWebRequestAssetBundle.GetAssetBundle(串参);
		yield return www.SendWebRequest();
		if (www.isNetworkError || www.isHttpError)
		{
			UnityEngine.Debug.Log(www.error);
			yield break;
		}
		AssetBundle content = DownloadHandlerAssetBundle.GetContent(www);
		string[] allAssetNames = content.GetAllAssetNames();
		foreach (string text in allAssetNames)
		{
			if (text != "")
			{
				GameObject 物参 = (GameObject)UnityEngine.Object.Instantiate(content.LoadAsset(text));
				移(物参);
			}
		}
	}

	public string 患(string[] 阵参)
	{
		string text = "";
		foreach (string text2 in 阵参)
		{
			text = text + text2 + ",";
		}
		return text;
	}

	public void 移(GameObject 物参)
	{
		string value = 广(物参.transform.name);
		int num = 串广公.IndexOf(value);
		string text = 串广公.Substring(0, num);
		char 炭换行 = '\n';
		int num2 = text.Count((char f) => f == 炭换行) + 1;
		int num3 = 串广公.Count((char f) => f == 炭换行) + 1;
		int num4 = text.LastIndexOf("\n");
		int num5 = num - num4;
		float num6 = 10f;
		float x = (float)(-num5) / num6;
		float y = (float)(num3 - num2) / num6;
		float z = 0f - 20f / num6;
		float num7 = 10f / num6;
		物参.transform.localEulerAngles = new Vector3(0f, 180f, 0f);
		物参.transform.localScale = new Vector3(num7, num7, num7);
		物参.transform.Translate(x, y, z);
	}

	public string 广(string 串参)
	{
		return 串参.Substring(0, 1);
	}
}
public class 佐 : MonoBehaviour
{
	public static 佐 逮;

	private string 私串汉库 = "锕皑蔼碍爱嗳嫒瑷暧霭谙铵鹌肮袄奥媪骜鳌坝罢钯摆败呗颁办绊钣帮绑镑谤剥饱宝报鲍鸨龅辈贝钡狈备惫鹎贲锛绷笔毕毙币闭荜哔滗铋筚跸边编贬变辩辫苄缏笾标骠飑飙镖镳鳔鳖别瘪濒滨宾摈傧缤槟殡膑镔髌鬓饼禀拨钵铂驳饽钹鹁补钸财参蚕残惭惨灿骖黪苍舱仓沧厕侧册测恻层诧锸侪钗搀掺蝉馋谗缠铲产阐颤冁谄谶蒇忏婵骣觇禅镡场尝长偿肠厂畅伥苌怅阊鲳钞车彻砗尘陈衬伧谌榇碜龀撑称惩诚骋枨柽铖铛痴迟驰耻齿炽饬鸱冲冲虫宠铳畴踌筹绸俦帱雠橱厨锄雏础储触处刍绌蹰传钏疮闯创怆锤缍纯鹑绰辍龊辞词赐鹚聪葱囱从丛苁骢枞凑辏蹿窜撺错锉鹾达哒鞑带贷骀绐担单郸掸胆惮诞弹殚赕瘅箪当挡党荡档谠砀裆捣岛祷导盗焘灯邓镫敌涤递缔籴诋谛绨觌镝颠点垫电巅钿癫钓调铫鲷谍叠鲽钉顶锭订铤丢铥东动栋冻岽鸫窦犊独读赌镀渎椟牍笃黩锻断缎簖兑队对怼镦吨顿钝炖趸夺堕铎鹅额讹恶饿谔垩阏轭锇锷鹗颚颛鳄诶儿尔饵贰迩铒鸸鲕发罚阀珐矾钒烦贩饭访纺钫鲂飞诽废费绯镄鲱纷坟奋愤粪偾丰枫锋风疯冯缝讽凤沣肤辐抚辅赋复负讣妇缚凫驸绂绋赙麸鲋鳆钆该钙盖赅杆赶秆赣尴擀绀冈刚钢纲岗戆镐睾诰缟锆搁鸽阁铬个纥镉颍给亘赓绠鲠龚宫巩贡钩沟苟构购够诟缑觏蛊顾诂毂钴锢鸪鹄鹘剐挂鸹掴关观馆惯贯诖掼鹳鳏广犷规归龟闺轨诡贵刽匦刿妫桧鲑鳜辊滚衮绲鲧锅国过埚呙帼椁蝈铪骇韩汉阚绗颉号灏颢阂鹤贺诃阖蛎横轰鸿红黉讧荭闳鲎壶护沪户浒鹕哗华画划话骅桦铧怀坏欢环还缓换唤痪焕涣奂缳锾鲩黄谎鳇挥辉毁贿秽会烩汇讳诲绘诙荟哕浍缋珲晖荤浑诨馄阍获货祸钬镬击机积饥迹讥鸡绩缉极辑级挤几蓟剂济计记际继纪讦诘荠叽哜骥玑觊齑矶羁虿跻霁鲚鲫夹荚颊贾钾价驾郏浃铗镓蛲歼监坚笺间艰缄茧检碱硷拣捡简俭减荐槛鉴践贱见键舰剑饯渐溅涧谏缣戋戬睑鹣笕鲣鞯将浆蒋桨奖讲酱绛缰胶浇骄娇搅铰矫侥脚饺缴绞轿较挢峤鹪鲛阶节洁结诫届疖颌鲒紧锦仅谨进晋烬尽劲荆茎卺荩馑缙赆觐鲸惊经颈静镜径痉竞净刭泾迳弪胫靓纠厩旧阄鸠鹫驹举据锯惧剧讵屦榉飓钜锔窭龃鹃绢锩镌隽觉决绝谲珏钧军骏皲开凯剀垲忾恺铠锴龛闶钪铐颗壳课骒缂轲钶锞颔垦恳龈铿抠库裤喾块侩郐哙脍宽狯髋矿旷况诓诳邝圹纩贶亏岿窥馈溃匮蒉愦聩篑阃锟鲲扩阔蛴蜡腊莱来赖崃徕涞濑赉睐铼癞籁蓝栏拦篮阑兰澜谰揽览懒缆烂滥岚榄斓镧褴琅阆锒捞劳涝唠崂铑铹痨乐鳓镭垒类泪诔缧篱狸离鲤礼丽厉励砾历沥隶俪郦坜苈莅蓠呖逦骊缡枥栎轹砺锂鹂疠粝跞雳鲡鳢俩联莲连镰怜涟帘敛脸链恋炼练蔹奁潋琏殓裢裣鲢粮凉两辆谅魉疗辽镣缭钌鹩猎临邻鳞凛赁蔺廪檩辚躏龄铃灵岭领绫棂蛏鲮馏刘浏骝绺镏鹨龙聋咙笼垄拢陇茏泷珑栊胧砻楼娄搂篓偻蒌喽嵝镂瘘耧蝼髅芦卢颅庐炉掳卤虏鲁赂禄录陆垆撸噜闾泸渌栌橹轳辂辘氇胪鸬鹭舻鲈峦挛孪滦乱脔娈栾鸾銮抡轮伦仑沦纶论囵萝罗逻锣箩骡骆络荦猡泺椤脶镙驴吕铝侣屡缕虑滤绿榈褛锊呒妈玛码蚂马骂吗唛嬷杩买麦卖迈脉劢瞒馒蛮满谩缦镘颡鳗猫锚铆贸麽没镁门闷们扪焖懑钔锰梦眯谜弥觅幂芈谧猕祢绵缅渑腼黾庙缈缪灭悯闽闵缗鸣铭谬谟蓦馍殁镆谋亩钼呐钠纳难挠脑恼闹铙讷馁内拟腻铌鲵撵辇鲶酿鸟茑袅聂啮镊镍陧蘖嗫颟蹑柠狞宁拧泞苎咛聍钮纽脓浓农侬哝驽钕诺傩疟欧鸥殴呕沤讴怄瓯盘蹒庞抛疱赔辔喷鹏纰罴铍骗谝骈飘缥频贫嫔苹凭评泼颇钋扑铺朴谱镤镨栖脐齐骑岂启气弃讫蕲骐绮桤碛颀颃鳍牵钎铅迁签谦钱钳潜浅谴堑佥荨悭骞缱椠钤枪呛墙蔷强抢嫱樯戗炝锖锵镪羟跄锹桥乔侨翘窍诮谯荞缲硗跷窃惬锲箧钦亲寝锓轻氢倾顷请庆揿鲭琼穷茕蛱巯赇虮鳅趋区躯驱龋诎岖阒觑鸲颧权劝诠绻辁铨却鹊确阕阙悫让饶扰绕荛娆桡热韧认纫饪轫荣绒嵘蝾缛铷颦软锐蚬闰润洒萨飒鳃赛伞毵糁丧骚扫缫涩啬铯穑杀刹纱铩鲨筛晒酾删闪陕赡缮讪姗骟钐鳝墒伤赏垧殇觞烧绍赊摄慑设厍滠畲绅审婶肾渗诜谂渖声绳胜师狮湿诗时蚀实识驶势适释饰视试谥埘莳弑轼贳铈鲥寿兽绶枢输书赎属术树竖数摅纾帅闩双谁税顺说硕烁铄丝饲厮驷缌锶鸶耸怂颂讼诵擞薮馊飕锼苏诉肃谡稣虽随绥岁谇孙损笋荪狲缩琐锁唢睃獭挞闼铊鳎台态钛鲐摊贪瘫滩坛谭谈叹昙钽锬顸汤烫傥饧铴镗涛绦讨韬铽腾誊锑题体屉缇鹈阗条粜龆鲦贴铁厅听烃铜统恸头钭秃图钍团抟颓蜕饨脱鸵驮驼椭箨鼍袜娲腽弯湾顽万纨绾网辋韦违围为潍维苇伟伪纬谓卫诿帏闱沩涠玮韪炜鲔温闻纹稳问阌瓮挝蜗涡窝卧莴龌呜钨乌诬无芜吴坞雾务误邬庑怃妩骛鹉鹜锡牺袭习铣戏细饩阋玺觋虾辖峡侠狭厦吓硖鲜纤贤衔闲显险现献县馅羡宪线苋莶藓岘猃娴鹇痫蚝籼跹厢镶乡详响项芗饷骧缃飨萧嚣销晓啸哓潇骁绡枭箫协挟携胁谐写泻谢亵撷绁缬锌衅兴陉荥凶汹锈绣馐鸺虚嘘须许叙绪续诩顼轩悬选癣绚谖铉镟学谑泶鳕勋询寻驯训讯逊埙浔鲟压鸦鸭哑亚讶垭娅桠氩阉烟盐严岩颜阎艳厌砚彦谚验厣赝俨兖谳恹闫酽魇餍鼹鸯杨扬疡阳痒养样炀瑶摇尧遥窑谣药轺鹞鳐爷页业叶靥谒邺晔烨医铱颐遗仪蚁艺亿忆义诣议谊译异绎诒呓峄饴怿驿缢轶贻钇镒镱瘗舣荫阴银饮隐铟瘾樱婴鹰应缨莹萤营荧蝇赢颖茔莺萦蓥撄嘤滢潆璎鹦瘿颏罂哟拥佣痈踊咏镛优忧邮铀犹诱莸铕鱿舆鱼渔娱与屿语狱誉预驭伛俣谀谕蓣嵛饫阈妪纡觎欤钰鹆鹬龉鸳渊辕园员圆缘远橼鸢鼋约跃钥粤悦阅钺郧匀陨运蕴酝晕韵郓芸恽愠纭韫殒氲杂灾载攒暂赞瓒趱錾赃脏驵凿枣责择则泽赜啧帻箦贼谮赠综缯轧铡闸栅诈斋债毡盏斩辗崭栈战绽谵张涨帐账胀赵诏钊蛰辙锗这谪辄鹧贞针侦诊镇阵浈缜桢轸赈祯鸩挣睁狰争帧症郑证诤峥钲铮筝织职执纸挚掷帜质滞骘栉栀轵轾贽鸷蛳絷踬踯觯钟终种肿众锺诌轴皱昼骤纣绉猪诸诛烛瞩嘱贮铸驻伫槠铢专砖转赚啭馔颞桩庄装妆壮状锥赘坠缀骓缒谆准着浊诼镯兹资渍谘缁辎赀眦锱龇鲻踪总纵偬邹诹驺鲰诅组镞钻缵躜鳟翱并卜沉丑淀迭斗范干皋硅柜后伙秸杰诀夸里凌么霉捻凄扦圣尸抬涂洼喂污锨咸蝎彝涌游吁御愿岳云灶扎札筑于志注凋讠谫郄勐凼坂垅垴埯埝苘荬荮莜莼菰藁揸吒吣咔咝咴噘噼嚯幞岙嵴彷徼犸狍馀馇馓馕愣憷懔丬溆滟溷漤潴澹甯纟绔绱珉枧桊桉槔橥轱轷赍肷胨飚煳煅熘愍淼砜磙眍钚钷铘铞锃锍锎锏锘锝锪锫锿镅镎镢镥镩镲稆鹋鹛鹱疬疴痖癯裥襁耢颥螨麴鲅鲆鲇鲞鲴鲺鲼鳊鳋鳘鳙鞒鞴齄";

	private string 私串繁库 = "錒皚藹礙愛噯嬡璦曖靄諳銨鵪骯襖奧媼驁鰲壩罷鈀擺敗唄頒辦絆鈑幫綁鎊謗剝飽寶報鮑鴇齙輩貝鋇狽備憊鵯賁錛繃筆畢斃幣閉蓽嗶潷鉍篳蹕邊編貶變辯辮芐緶籩標驃颮飆鏢鑣鰾鱉別癟瀕濱賓擯儐繽檳殯臏鑌髕鬢餅稟撥缽鉑駁餑鈸鵓補鈽財參蠶殘慚慘燦驂黲蒼艙倉滄廁側冊測惻層詫鍤儕釵攙摻蟬饞讒纏鏟產闡顫囅諂讖蕆懺嬋驏覘禪鐔場嘗長償腸廠暢倀萇悵閶鯧鈔車徹硨塵陳襯傖諶櫬磣齔撐稱懲誠騁棖檉鋮鐺癡遲馳恥齒熾飭鴟沖衝蟲寵銃疇躊籌綢儔幬讎櫥廚鋤雛礎儲觸處芻絀躕傳釧瘡闖創愴錘綞純鶉綽輟齪辭詞賜鶿聰蔥囪從叢蓯驄樅湊輳躥竄攛錯銼鹺達噠韃帶貸駘紿擔單鄲撣膽憚誕彈殫賧癉簞當擋黨蕩檔讜碭襠搗島禱導盜燾燈鄧鐙敵滌遞締糴詆諦綈覿鏑顛點墊電巔鈿癲釣調銚鯛諜疊鰈釘頂錠訂鋌丟銩東動棟凍崠鶇竇犢獨讀賭鍍瀆櫝牘篤黷鍛斷緞籪兌隊對懟鐓噸頓鈍燉躉奪墮鐸鵝額訛惡餓諤堊閼軛鋨鍔鶚顎顓鱷誒兒爾餌貳邇鉺鴯鮞發罰閥琺礬釩煩販飯訪紡鈁魴飛誹廢費緋鐨鯡紛墳奮憤糞僨豐楓鋒風瘋馮縫諷鳳灃膚輻撫輔賦復負訃婦縛鳧駙紱紼賻麩鮒鰒釓該鈣蓋賅桿趕稈贛尷搟紺岡剛鋼綱崗戇鎬睪誥縞鋯擱鴿閣鉻個紇鎘潁給亙賡綆鯁龔宮鞏貢鉤溝茍構購夠詬緱覯蠱顧詁轂鈷錮鴣鵠鶻剮掛鴰摑關觀館慣貫詿摜鸛鰥廣獷規歸龜閨軌詭貴劊匭劌媯檜鮭鱖輥滾袞緄鯀鍋國過堝咼幗槨蟈鉿駭韓漢闞絎頡號灝顥閡鶴賀訶闔蠣橫轟鴻紅黌訌葒閎鱟壺護滬戶滸鶘嘩華畫劃話驊樺鏵懷壞歡環還緩換喚瘓煥渙奐繯鍰鯇黃謊鰉揮輝毀賄穢會燴匯諱誨繪詼薈噦澮繢琿暉葷渾諢餛閽獲貨禍鈥鑊擊機積饑跡譏雞績緝極輯級擠幾薊劑濟計記際繼紀訐詰薺嘰嚌驥璣覬齏磯羈蠆躋霽鱭鯽夾莢頰賈鉀價駕郟浹鋏鎵蟯殲監堅箋間艱緘繭檢堿鹼揀撿簡儉減薦檻鑒踐賤見鍵艦劍餞漸濺澗諫縑戔戩瞼鶼筧鰹韉將漿蔣槳獎講醬絳韁膠澆驕嬌攪鉸矯僥腳餃繳絞轎較撟嶠鷦鮫階節潔結誡屆癤頜鮚緊錦僅謹進晉燼盡勁荊莖巹藎饉縉贐覲鯨驚經頸靜鏡徑痙競凈剄涇逕弳脛靚糾廄舊鬮鳩鷲駒舉據鋸懼劇詎屨櫸颶鉅鋦窶齟鵑絹錈鐫雋覺決絕譎玨鈞軍駿皸開凱剴塏愾愷鎧鍇龕閌鈧銬顆殼課騍緙軻鈳錁頷墾懇齦鏗摳庫褲嚳塊儈鄶噲膾寬獪髖礦曠況誆誑鄺壙纊貺虧巋窺饋潰匱蕢憒聵簣閫錕鯤擴闊蠐蠟臘萊來賴崍徠淶瀨賚睞錸癩籟藍欄攔籃闌蘭瀾讕攬覽懶纜爛濫嵐欖斕鑭襤瑯閬鋃撈勞澇嘮嶗銠鐒癆樂鰳鐳壘類淚誄縲籬貍離鯉禮麗厲勵礫歷瀝隸儷酈壢藶蒞蘺嚦邐驪縭櫪櫟轢礪鋰鸝癘糲躒靂鱺鱧倆聯蓮連鐮憐漣簾斂臉鏈戀煉練蘞奩瀲璉殮褳襝鰱糧涼兩輛諒魎療遼鐐繚釕鷯獵臨鄰鱗凜賃藺廩檁轔躪齡鈴靈嶺領綾欞蟶鯪餾劉瀏騮綹鎦鷚龍聾嚨籠壟攏隴蘢瀧瓏櫳朧礱樓婁摟簍僂蔞嘍嶁鏤瘺耬螻髏蘆盧顱廬爐擄鹵虜魯賂祿錄陸壚擼嚕閭瀘淥櫨櫓轤輅轆氌臚鸕鷺艫鱸巒攣孿灤亂臠孌欒鸞鑾掄輪倫侖淪綸論圇蘿羅邏鑼籮騾駱絡犖玀濼欏腡鏍驢呂鋁侶屢縷慮濾綠櫚褸鋝嘸媽瑪碼螞馬罵嗎嘜嬤榪買麥賣邁脈勱瞞饅蠻滿謾縵鏝顙鰻貓錨鉚貿麼沒鎂門悶們捫燜懣鍆錳夢瞇謎彌覓冪羋謐獼禰綿緬澠靦黽廟緲繆滅憫閩閔緡鳴銘謬謨驀饃歿鏌謀畝鉬吶鈉納難撓腦惱鬧鐃訥餒內擬膩鈮鯢攆輦鯰釀鳥蔦裊聶嚙鑷鎳隉蘗囁顢躡檸獰寧擰濘苧嚀聹鈕紐膿濃農儂噥駑釹諾儺瘧歐鷗毆嘔漚謳慪甌盤蹣龐拋皰賠轡噴鵬紕羆鈹騙諞駢飄縹頻貧嬪蘋憑評潑頗釙撲鋪樸譜鏷鐠棲臍齊騎豈啟氣棄訖蘄騏綺榿磧頎頏鰭牽釬鉛遷簽謙錢鉗潛淺譴塹僉蕁慳騫繾槧鈐槍嗆墻薔強搶嬙檣戧熗錆鏘鏹羥蹌鍬橋喬僑翹竅誚譙蕎繰磽蹺竊愜鍥篋欽親寢鋟輕氫傾頃請慶撳鯖瓊窮煢蛺巰賕蟣鰍趨區軀驅齲詘嶇闃覷鴝顴權勸詮綣輇銓卻鵲確闋闕愨讓饒擾繞蕘嬈橈熱韌認紉飪軔榮絨嶸蠑縟銣顰軟銳蜆閏潤灑薩颯鰓賽傘毿糝喪騷掃繅澀嗇銫穡殺剎紗鎩鯊篩曬釃刪閃陜贍繕訕姍騸釤鱔墑傷賞坰殤觴燒紹賒攝懾設厙灄畬紳審嬸腎滲詵諗瀋聲繩勝師獅濕詩時蝕實識駛勢適釋飾視試謚塒蒔弒軾貰鈰鰣壽獸綬樞輸書贖屬術樹豎數攄紓帥閂雙誰稅順說碩爍鑠絲飼廝駟緦鍶鷥聳慫頌訟誦擻藪餿颼鎪蘇訴肅謖穌雖隨綏歲誶孫損筍蓀猻縮瑣鎖嗩脧獺撻闥鉈鰨臺態鈦鮐攤貪癱灘壇譚談嘆曇鉭錟頇湯燙儻餳鐋鏜濤絳討韜鋱騰謄銻題體屜緹鵜闐條糶齠鰷貼鐵廳聽烴銅統慟頭鈄禿圖釷團摶頹蛻飩脫鴕馱駝橢籜鼉襪媧膃彎灣頑萬紈綰網輞韋違圍為濰維葦偉偽緯謂衛諉幃闈溈潿瑋韙煒鮪溫聞紋穩問閿甕撾蝸渦窩臥萵齷嗚鎢烏誣無蕪吳塢霧務誤鄔廡憮嫵騖鵡鶩錫犧襲習銑戲細餼鬩璽覡蝦轄峽俠狹廈嚇硤鮮纖賢銜閑顯險現獻縣餡羨憲線莧薟蘚峴獫嫻鷴癇蠔秈躚廂鑲鄉詳響項薌餉驤緗饗蕭囂銷曉嘯嘵瀟驍綃梟簫協挾攜脅諧寫瀉謝褻擷紲纈鋅釁興陘滎兇洶銹繡饈鵂虛噓須許敘緒續詡頊軒懸選癬絢諼鉉鏇學謔澩鱈勛詢尋馴訓訊遜塤潯鱘壓鴉鴨啞亞訝埡婭椏氬閹煙鹽嚴巖顏閻艷厭硯彥諺驗厴贗儼兗讞懨閆釅魘饜鼴鴦楊揚瘍陽癢養樣煬瑤搖堯遙窯謠藥軺鷂鰩爺頁業葉靨謁鄴曄燁醫銥頤遺儀蟻藝億憶義詣議誼譯異繹詒囈嶧飴懌驛縊軼貽釔鎰鐿瘞艤蔭陰銀飲隱銦癮櫻嬰鷹應纓瑩螢營熒蠅贏穎塋鶯縈鎣攖嚶瀅瀠瓔鸚癭頦罌喲擁傭癰踴詠鏞優憂郵鈾猶誘蕕銪魷輿魚漁娛與嶼語獄譽預馭傴俁諛諭蕷崳飫閾嫗紆覦歟鈺鵒鷸齬鴛淵轅園員圓緣遠櫞鳶黿約躍鑰粵悅閱鉞鄖勻隕運蘊醞暈韻鄆蕓惲慍紜韞殞氳雜災載攢暫贊瓚趲鏨贓臟駔鑿棗責擇則澤賾嘖幘簀賊譖贈綜繒軋鍘閘柵詐齋債氈盞斬輾嶄棧戰綻譫張漲帳賬脹趙詔釗蟄轍鍺這謫輒鷓貞針偵診鎮陣湞縝楨軫賑禎鴆掙睜猙爭幀癥鄭證諍崢鉦錚箏織職執紙摯擲幟質滯騭櫛梔軹輊贄鷙螄縶躓躑觶鐘終種腫眾鍾謅軸皺晝驟紂縐豬諸誅燭矚囑貯鑄駐佇櫧銖專磚轉賺囀饌顳樁莊裝妝壯狀錐贅墜綴騅縋諄準著濁諑鐲茲資漬諮緇輜貲眥錙齜鯔蹤總縱傯鄒諏騶鯫詛組鏃鉆纘躦鱒翺並蔔沈醜澱叠鬥範幹臯矽櫃後夥稭傑訣誇裏淩麽黴撚淒扡聖屍擡塗窪餵汙鍁鹹蠍彜湧遊籲禦願嶽雲竈紮劄築於誌註雕訁譾郤猛氹阪壟堖垵墊檾蕒葤蓧蒓菇槁摣咤唚哢噝噅撅劈謔襆嶴脊仿僥獁麅餘餷饊饢楞怵懍爿漵灩混濫瀦淡寧糸絝緔瑉梘棬案橰櫫軲軤賫膁腖飈糊煆溜湣渺碸滾瞘鈈鉕鋣銱鋥鋶鐦鐧鍩鍀鍃錇鎄鎇鎿鐝鑥鑹鑔穭鶓鶥鸌癧屙瘂臒襇繈耮顬蟎麯鮁鮃鮎鯗鯝鯴鱝鯿鰠鰵鱅鞽韝齇";

	private string 公广 = "虚世界微渺元宇宙繁英汉\r\n造摆搁喷随它\r\n方球胶柱锥骰丸坡环圈心星惺棱塔苍壶梯钻\r\n移横平纵垂深浅迁徒沧桑抬坠徘徊哪位\r\n挪纠缠拧扭转旋羡慕跌摔糟糕凯涡那弄\r\n撑宽窄高矮厚薄肥腻胖瘦挺扁放缩啊谦\r\n选消全清删剪拷贴隆仿撤再到达播停已仅然\r\n红橙黄绿青靛蓝紫黑白灰乌粉翠碧棕朱赤褐\r\n金银铜铁木板皮革凝土山石岩泥砖玻璃瓷塑\r\n墙涯东南西北芯穹帮天地桌椅显隐毁亮阴暗刚冈\r\n广签游解存另开执升降悬春夏秋冬远近顾振透封\r\n";

	public GameObject 魔方;

	public Image[] 图片集合;

	private float 第一次触摸的X坐标;

	private float 第一次触摸的Y坐标;

	private bool 是否触摸中;

	private int 当前摇杆的X;

	private int 当前摇杆的Y;

	private int 上一次触摸的X坐标;

	private int 上一次触摸的Y坐标;

	public bool 是否唤出UI;

	public 纹理 纹理脚本;

	public GameObject 公纹理;

	public Text 公讲;

	public Text 公告;

	public Text 公量;

	public int 公几广;

	public int 公几材质;

	public int 公几纹理;

	public int 公几纹理数 = 15;

	public int 公几量;

	public bool 公为主键;

	public bool 公为次键;

	public bool 公为开灯;

	public bool 公为呆;

	public GameObject 公平行光;

	public float 公几大 = 2f;

	public float 公几中 = 1f;

	public float 公几小 = 0.5f;

	public bool 公为帮;

	public GameObject 公图帮;

	public AudioSource 公韵;

	public 语 公语;

	private AudioClip 公颂;

	private UnityEngine.XR.InputDevice device;

	public GameObject 该;

	public GameObject 该已;

	public float 公几速虚 = 5f;

	public float 公微 = 0.1f;

	public float 公渺 = 0.5f;

	public float 公元 = 1f;

	public float 公宇 = 2f;

	public float 公宙 = 5f;

	public float 公系 = 1f;

	public bool 公为摇;

	public string 公态;

	public string 公势;

	public string 公靶;

	public string 公主;

	public string 公谓;

	public string 公宾;

	public string 公串造;

	public string 选啥;

	public string 造啥;

	public string 公敬;

	private GameObject 公尤丸;

	public float 公几力 = 5f;

	public GameObject 子弹方向;

	public int 几倍 = 10;

	public int 几余 = 1;

	public Collider[] 尤碰撞物;

	public Dictionary<string, string> 公典帮 = new Dictionary<string, string>();

	private string[] 私串阵个;

	private Vector3 物体的坐标;

	private string 私串令;

	private string 私串参;

	public string 公据;

	private string 私该开 = "";

	private Dictionary<string, string> 私典 = new Dictionary<string, string>();

	public string 公虚;

	public Transform 公变左下;

	public Transform 公变右上;

	public int 公几随 = 3;

	public bool 公为繁;

	public string 公自;

	public string 公脉;

	public string 公签;

	public string 公签原;

	private Color 公色;

	private GameObject[] 私尤横集;

	private GameObject[] 私尤平集;

	private GameObject[] 私尤纵集;

	private GameObject[] 私尤垂集;

	private GameObject[] 私尤深集;

	private GameObject[] 私尤浅集;

	private GameObject[] 私尤迁集;

	private GameObject[] 私尤徒集;

	private GameObject[] 私尤沧集;

	private GameObject[] 私尤桑集;

	private GameObject[] 私尤抬集;

	private GameObject[] 私尤坠集;

	private GameObject[] 私尤徘集;

	private GameObject[] 私尤徊集;

	private GameObject[] 私尤纠集;

	private GameObject[] 私尤缠集;

	private GameObject[] 私尤拧集;

	private GameObject[] 私尤扭集;

	private GameObject[] 私尤转集;

	private GameObject[] 私尤旋集;

	private GameObject[] 私尤羡集;

	private GameObject[] 私尤慕集;

	private GameObject[] 私尤跌集;

	private GameObject[] 私尤摔集;

	private GameObject[] 私尤糟集;

	private GameObject[] 私尤糕集;

	private GameObject[] 私尤凯集;

	private GameObject[] 私尤涡集;

	private GameObject[] 私尤宽集;

	private GameObject[] 私尤窄集;

	private GameObject[] 私尤高集;

	private GameObject[] 私尤矮集;

	private GameObject[] 私尤厚集;

	private GameObject[] 私尤薄集;

	private GameObject[] 私尤肥集;

	private GameObject[] 私尤腻集;

	private GameObject[] 私尤胖集;

	private GameObject[] 私尤瘦集;

	private GameObject[] 私尤挺集;

	private GameObject[] 私尤扁集;

	private GameObject[] 私尤放集;

	private GameObject[] 私尤缩集;

	public Vector3 公仨搁;

	public string 公已广;

	public string 公该广;

	public string 公然广;

	public string 公已稿;

	public string 公该稿;

	public string 公然稿;

	public string 公果;

	public bool 公为;

	public bool 公为透;

	public GameObject 公已;

	private string 私串简 = "";

	private string 私串繁 = "";

	private string 私串英 = "";

	private string 私串汉 = "";

	public Dictionary<string, GameObject> 公典虚 = new Dictionary<string, GameObject>();

	public ScrollRect leftLogScrollRect;

	public string 取广
	{
		get
		{
			return 公广;
		}
		set
		{
			公广 = value;
		}
	}

	private void Awake()
	{
		逮 = this;
		是否触摸中 = true;
		是否唤出UI = true;
		魔方.SetActive(value: true);
		公串造 = "方球胶柱锥";
		公虚 = "佐";
	}

	private void Start()
	{
		公态 = "造";
		公谓 = "然";
		造啥 = "方";
		公敬 = "仅";
		生典(私串简);
		已广();
		佑.逮.置态("造");
		佑.逮.置佑摇("啊");
		佑.逮.改造啥(造啥);
		开();
		公变左下 = GameObject.Find("/=算/-位置/左下").transform;
		公变右上 = GameObject.Find("/=算/-位置/右上").transform;
		StartCoroutine(载汉(UnityEngine.Application.streamingAssetsPath + "/txt/cn.txt"));
		StartCoroutine(载英(UnityEngine.Application.streamingAssetsPath + "/txt/en.txt"));
		公签 = "横平纵垂深浅迁徒沧桑抬坠徘徊纠缠拧扭转旋羡慕跌摔糟糕凯涡宽窄高矮厚薄肥腻胖瘦挺扁放缩";
		公签原 = 公签;
		签播();
		随色();
		if (PXR_Input.GetControllerDeviceType() == PXR_Input.ControllerDevice.PICO_4)
		{
			透();
		}
		公讲.text = "欢迎使用虚世界（彩透版）";
	}

	private void OnEnable()
	{
	}

	private void FixedUpdate()
	{
		if (Time.frameCount % 30 != 0)
		{
			return;
		}
		if (私尤横集 != null && 公签.IndexOf("横") != -1 && 私尤横集.Length != 0)
		{
			for (int i = 0; i < 私尤横集.Length; i++)
			{
				脑执("横");
			}
		}
		if (私尤平集 != null && 公签.IndexOf("平") != -1 && 私尤平集.Length != 0)
		{
			for (int j = 0; j < 私尤平集.Length; j++)
			{
				脑执("平");
			}
		}
		if (私尤纵集 != null && 公签.IndexOf("纵") != -1 && 私尤纵集.Length != 0)
		{
			for (int k = 0; k < 私尤纵集.Length; k++)
			{
				脑执("纵");
			}
		}
		if (私尤垂集 != null && 公签.IndexOf("垂") != -1 && 私尤垂集.Length != 0)
		{
			for (int l = 0; l < 私尤垂集.Length; l++)
			{
				脑执("垂");
			}
		}
		if (私尤深集 != null && 公签.IndexOf("深") != -1 && 私尤深集.Length != 0)
		{
			for (int m = 0; m < 私尤深集.Length; m++)
			{
				脑执("深");
			}
		}
		if (私尤浅集 != null && 公签.IndexOf("浅") != -1 && 私尤浅集.Length != 0)
		{
			for (int n = 0; n < 私尤浅集.Length; n++)
			{
				脑执("浅");
			}
		}
		if (私尤迁集 != null && 公签.IndexOf("迁") != -1 && 私尤迁集.Length != 0)
		{
			for (int num = 0; num < 私尤迁集.Length; num++)
			{
				脑执("迁");
			}
		}
		if (私尤徒集 != null && 公签.IndexOf("徒") != -1 && 私尤徒集.Length != 0)
		{
			for (int num2 = 0; num2 < 私尤徒集.Length; num2++)
			{
				脑执("徒");
			}
		}
		if (私尤沧集 != null && 公签.IndexOf("沧") != -1 && 私尤沧集.Length != 0)
		{
			for (int num3 = 0; num3 < 私尤沧集.Length; num3++)
			{
				脑执("沧");
			}
		}
		if (私尤桑集 != null && 公签.IndexOf("桑") != -1 && 私尤桑集.Length != 0)
		{
			for (int num4 = 0; num4 < 私尤桑集.Length; num4++)
			{
				脑执("桑");
			}
		}
		if (私尤抬集 != null && 公签.IndexOf("抬") != -1 && 私尤抬集.Length != 0)
		{
			for (int num5 = 0; num5 < 私尤抬集.Length; num5++)
			{
				脑执("抬");
			}
		}
		if (私尤坠集 != null && 公签.IndexOf("坠") != -1 && 私尤坠集.Length != 0)
		{
			for (int num6 = 0; num6 < 私尤坠集.Length; num6++)
			{
				脑执("坠");
			}
		}
		if (私尤徘集 != null && 公签.IndexOf("徘") != -1 && 私尤徘集.Length != 0)
		{
			for (int num7 = 0; num7 < 私尤徘集.Length; num7++)
			{
				脑执("徘");
			}
		}
		if (私尤徊集 != null && 公签.IndexOf("徊") != -1 && 私尤徊集.Length != 0)
		{
			for (int num8 = 0; num8 < 私尤徊集.Length; num8++)
			{
				脑执("徊");
			}
		}
		if (私尤纠集 != null && 公签.IndexOf("纠") != -1 && 私尤纠集.Length != 0)
		{
			for (int num9 = 0; num9 < 私尤纠集.Length; num9++)
			{
				脑执("纠");
			}
		}
		if (私尤缠集 != null && 公签.IndexOf("缠") != -1 && 私尤缠集.Length != 0)
		{
			for (int num10 = 0; num10 < 私尤缠集.Length; num10++)
			{
				脑执("缠");
			}
		}
		if (私尤拧集 != null && 公签.IndexOf("拧") != -1 && 私尤拧集.Length != 0)
		{
			for (int num11 = 0; num11 < 私尤拧集.Length; num11++)
			{
				脑执("拧");
			}
		}
		if (私尤扭集 != null && 公签.IndexOf("扭") != -1 && 私尤扭集.Length != 0)
		{
			for (int num12 = 0; num12 < 私尤扭集.Length; num12++)
			{
				脑执("扭");
			}
		}
		if (私尤转集 != null && 公签.IndexOf("转") != -1 && 私尤转集.Length != 0)
		{
			for (int num13 = 0; num13 < 私尤转集.Length; num13++)
			{
				脑执("转");
			}
		}
		if (私尤旋集 != null && 公签.IndexOf("旋") != -1 && 私尤旋集.Length != 0)
		{
			for (int num14 = 0; num14 < 私尤旋集.Length; num14++)
			{
				脑执("旋");
			}
		}
		if (私尤羡集 != null && 公签.IndexOf("羡") != -1 && 私尤羡集.Length != 0)
		{
			for (int num15 = 0; num15 < 私尤羡集.Length; num15++)
			{
				脑执("羡");
			}
		}
		if (私尤慕集 != null && 公签.IndexOf("慕") != -1 && 私尤慕集.Length != 0)
		{
			for (int num16 = 0; num16 < 私尤慕集.Length; num16++)
			{
				脑执("慕");
			}
		}
		if (私尤跌集 != null && 公签.IndexOf("跌") != -1 && 私尤跌集.Length != 0)
		{
			for (int num17 = 0; num17 < 私尤跌集.Length; num17++)
			{
				脑执("跌");
			}
		}
		if (私尤摔集 != null && 公签.IndexOf("摔") != -1 && 私尤摔集.Length != 0)
		{
			for (int num18 = 0; num18 < 私尤摔集.Length; num18++)
			{
				脑执("摔");
			}
		}
		if (私尤糟集 != null && 公签.IndexOf("糟") != -1 && 私尤糟集.Length != 0)
		{
			for (int num19 = 0; num19 < 私尤糟集.Length; num19++)
			{
				脑执("糟");
			}
		}
		if (私尤糕集 != null && 公签.IndexOf("糕") != -1 && 私尤糕集.Length != 0)
		{
			for (int num20 = 0; num20 < 私尤糕集.Length; num20++)
			{
				脑执("糕");
			}
		}
		if (私尤凯集 != null && 公签.IndexOf("凯") != -1 && 私尤凯集.Length != 0)
		{
			for (int num21 = 0; num21 < 私尤凯集.Length; num21++)
			{
				脑执("凯");
			}
		}
		if (私尤涡集 != null && 公签.IndexOf("涡") != -1 && 私尤涡集.Length != 0)
		{
			for (int num22 = 0; num22 < 私尤涡集.Length; num22++)
			{
				脑执("涡");
			}
		}
		if (私尤宽集 != null && 公签.IndexOf("宽") != -1 && 私尤宽集.Length != 0)
		{
			for (int num23 = 0; num23 < 私尤宽集.Length; num23++)
			{
				脑执("宽");
			}
		}
		if (私尤窄集 != null && 公签.IndexOf("窄") != -1 && 私尤窄集.Length != 0)
		{
			for (int num24 = 0; num24 < 私尤窄集.Length; num24++)
			{
				脑执("窄");
			}
		}
		if (私尤高集 != null && 公签.IndexOf("高") != -1 && 私尤高集.Length != 0)
		{
			for (int num25 = 0; num25 < 私尤高集.Length; num25++)
			{
				脑执("高");
			}
		}
		if (私尤矮集 != null && 公签.IndexOf("矮") != -1 && 私尤矮集.Length != 0)
		{
			for (int num26 = 0; num26 < 私尤矮集.Length; num26++)
			{
				脑执("矮");
			}
		}
		if (私尤厚集 != null && 公签.IndexOf("厚") != -1 && 私尤厚集.Length != 0)
		{
			for (int num27 = 0; num27 < 私尤厚集.Length; num27++)
			{
				脑执("厚");
			}
		}
		if (私尤薄集 != null && 公签.IndexOf("薄") != -1 && 私尤薄集.Length != 0)
		{
			for (int num28 = 0; num28 < 私尤薄集.Length; num28++)
			{
				脑执("薄");
			}
		}
		if (私尤肥集 != null && 公签.IndexOf("肥") != -1 && 私尤肥集.Length != 0)
		{
			for (int num29 = 0; num29 < 私尤肥集.Length; num29++)
			{
				脑执("肥");
			}
		}
		if (私尤腻集 != null && 公签.IndexOf("腻") != -1 && 私尤腻集.Length != 0)
		{
			for (int num30 = 0; num30 < 私尤腻集.Length; num30++)
			{
				脑执("腻");
			}
		}
		if (私尤胖集 != null && 公签.IndexOf("胖") != -1 && 私尤胖集.Length != 0)
		{
			for (int num31 = 0; num31 < 私尤胖集.Length; num31++)
			{
				脑执("胖");
			}
		}
		if (私尤瘦集 != null && 公签.IndexOf("瘦") != -1 && 私尤瘦集.Length != 0)
		{
			for (int num32 = 0; num32 < 私尤瘦集.Length; num32++)
			{
				脑执("瘦");
			}
		}
		if (私尤挺集 != null && 公签.IndexOf("挺") != -1 && 私尤挺集.Length != 0)
		{
			for (int num33 = 0; num33 < 私尤挺集.Length; num33++)
			{
				脑执("挺");
			}
		}
		if (私尤扁集 != null && 公签.IndexOf("扁") != -1 && 私尤扁集.Length != 0)
		{
			for (int num34 = 0; num34 < 私尤扁集.Length; num34++)
			{
				脑执("扁");
			}
		}
		if (私尤放集 != null && 公签.IndexOf("放") != -1 && 私尤放集.Length != 0)
		{
			for (int num35 = 0; num35 < 私尤放集.Length; num35++)
			{
				脑执("放");
			}
		}
		if (私尤缩集 != null && 公签.IndexOf("缩") != -1 && 私尤缩集.Length != 0)
		{
			for (int num36 = 0; num36 < 私尤缩集.Length; num36++)
			{
				脑执("缩");
			}
		}
	}

	private void OnApplicationPause(bool pause)
	{
		if (!pause && 公为透)
		{
			PXR_Boundary.EnableSeeThroughManual(value: true);
		}
	}

	public void 脑执(string 串参)
	{
		MonoBehaviour.print("0脑执()公态:" + 公态 + "----------串参:" + 串参);
		if (公态 == "广")
		{
			if (串参 == "广")
			{
				造();
			}
			else
			{
				广文(串参);
			}
		}
		else if (串参 == "广")
		{
			广(串参);
		}
		else if (串参 == "开")
		{
			MonoBehaviour.print("1广开");
			广开();
		}
		else if (公态 == "开")
		{
			MonoBehaviour.print("2开(串参)串参:" + 串参);
			开(串参);
		}
		else if (串参 == "签")
		{
			MonoBehaviour.print("1这里是串参 ==  签");
			广签();
		}
		else if (公态 == "签")
		{
			MonoBehaviour.print("2这里是公态 ==  签");
			签(串参);
		}
		else if (公态 == "佐")
		{
			脑佐();
		}
		else if (公态 == "佑")
		{
			脑佑();
		}
		else if (公态 != "签")
		{
			SendMessage(串参, "");
			脑史();
		}
		else
		{
			MonoBehaviour.print("xxxxxxxxxxxxxxxxxxxx不应该");
		}
	}

	public void 我(string 串参 = "")
	{
		GameObject gameObject = GameObject.Find("/XR Origin/Camera Offset/我");
		该 = gameObject;
	}

	public void 你(string 串参 = "")
	{
		GameObject gameObject = GameObject.Find("/=我/-伙伴/你");
		该 = gameObject;
	}

	public void 他(string 串参 = "")
	{
		GameObject gameObject = GameObject.Find("/=我/-对面/他");
		该 = gameObject;
	}

	public void 它(string 串参 = "")
	{
		该 = 佑.逮.它;
	}

	public void 愚(string 串参 = "")
	{
	}

	public void 呆(string 串参 = "")
	{
	}

	public void 萌(string 串参 = "")
	{
	}

	public void 乖(string 串参 = "")
	{
	}

	public void 巧(string 串参 = "")
	{
	}

	public void 广(string 串参 = "")
	{
		佑.逮.置态("广");
		佑.逮.改造啥("广");
		佑.逮.改态("广");
		广文("广");
	}

	public void 自(string 串参 = "")
	{
		if (公自 == "")
		{
			公自 = "转";
		}
		else
		{
			公自 = "";
		}
	}

	public void 脉(string 串参 = "")
	{
		if (公脉 == "")
		{
			公脉 = "转";
		}
		else
		{
			公脉 = "";
		}
	}

	public void 签(string 串参 = "")
	{
		MonoBehaviour.print("签：串参" + 串参);
		if (公签原.IndexOf(串参) != -1)
		{
			该.tag = 串参;
			签刷();
			造();
		}
	}

	public void 吕(string 串参 = "")
	{
	}

	public void 签变(string 串参 = "")
	{
		if (公签 == "")
		{
			签播();
			公签 = "横平纵垂深浅迁徒沧桑抬坠徘徊纠缠拧扭转旋羡慕跌摔糟糕凯涡宽窄高矮厚薄肥腻胖瘦挺扁放缩";
		}
		else
		{
			公签 = "";
		}
	}

	public void 广文(string 串参 = "")
	{
		MonoBehaviour.print("2广文()串参:" + 串参);
		MonoBehaviour.print("3广文()公态:" + 公态);
		GameObject gameObject = UnityEngine.Object.Instantiate(GameObject.Find("/=虚/-单字/" + 串参 + "(Clone)"));
		gameObject.name = 串参;
		GameObject 公组 = GameObject.Find("/=造/-组啥/组广");
		GameObject gameObject2 = GameObject.Find("/XR Origin/Camera Offset/RightHand Controller/枝轴点/");
		GameObject gameObject3 = GameObject.Find("/=造/-造啥/广");
		if (gameObject3.transform.childCount > 0)
		{
			UnityEngine.Object.Destroy(gameObject3.transform.GetChild(0).gameObject);
		}
		gameObject.transform.SetParent(gameObject3.transform);
		gameObject3.GetComponent<妥造>().公组 = 公组;
		gameObject.transform.localPosition = gameObject2.transform.localPosition;
		gameObject.transform.localRotation = Quaternion.Euler(0f, 180f, 0f);
		gameObject.transform.localScale = Vector3.one;
		gameObject.layer = 8;
		佑.逮.它 = gameObject;
	}

	public void 虚(string 串参 = "")
	{
		if (公虚 == "佐")
		{
			GameObject obj = GameObject.Find("/=虚/-单字");
			GameObject gameObject = GameObject.Find("/XR Origin/Camera Offset/LeftHand Controller");
			obj.transform.SetParent(gameObject.transform);
			obj.transform.localPosition = new Vector3(-1f, 0f, 0.5f);
			obj.transform.localScale = new Vector3(0.1f, 0.1f, 0.1f);
			obj.transform.localRotation = Quaternion.Euler(0f, 0f, 0f);
			公虚 = "悬";
		}
		else if (公虚 == "悬")
		{
			GameObject obj2 = GameObject.Find("/XR Origin/Camera Offset/LeftHand Controller/-单字");
			GameObject gameObject2 = GameObject.Find("/=虚");
			obj2.transform.SetParent(gameObject2.transform);
			公虚 = "东";
		}
		else if (公虚 == "东")
		{
			GameObject obj3 = GameObject.Find("/=虚/-单字");
			obj3.transform.localPosition = new Vector3(11.2f, 0f, 12.5f);
			obj3.transform.localScale = new Vector3(1f, 1f, 1f);
			obj3.transform.localRotation = Quaternion.Euler(0f, 90f, 0f);
			公虚 = "北";
		}
		else if (公虚 == "北")
		{
			GameObject obj4 = GameObject.Find("/=虚/-单字");
			obj4.transform.localPosition = new Vector3(-11.2f, 0f, 12.45f);
			obj4.transform.localRotation = Quaternion.Euler(0f, 0f, 0f);
			公虚 = "佐";
		}
		else
		{
			MonoBehaviour.print("【虚】报错");
		}
	}

	public void 世(string 串参 = "")
	{
		TeleportController.逮.瞬(Vector3.zero);
	}

	public void 界(string 串参 = "")
	{
		if (GameObject.Find("/=布编程/-域").transform.localPosition.y < -1000f)
		{
			尤显("/=布编程/-域,/=布编程/-帮助/帮,/=布讲告,/=布编程/-帮助/略");
		}
		else
		{
			尤隐("/=布编程/-域,/=布编程/-帮助/帮,/=布讲告,/=布编程/-帮助/略");
		}
	}

	public void 微(string 串参 = "")
	{
		公系 = 公微;
	}

	public void 渺(string 串参 = "")
	{
		公系 = 公渺;
	}

	public void 元(string 串参 = "")
	{
		公系 = 公元;
	}

	public void 宇(string 串参 = "")
	{
		公系 = 公宇;
	}

	public void 宙(string 串参 = "")
	{
		公系 = 公宙;
	}

	public void 引(string 串参 = "")
	{
	}

	public void 擎(string 串参 = "")
	{
	}

	public void 播(string 串参 = "")
	{
		签刷();
		公签 = "横平纵垂深浅迁徒沧桑抬坠徘徊纠缠拧扭转旋羡慕跌摔糟糕凯涡宽窄高矮厚薄肥腻胖瘦挺扁放缩";
	}

	public void 暂(string 串参 = "")
	{
	}

	public void 停(string 串参 = "")
	{
		公签 = "";
	}

	public void 到(string 串参 = "")
	{
		Vector3 localPosition = 该.transform.localPosition;
		TeleportController.逮.瞬(new Vector3(localPosition.x, localPosition.y - 1.5f, localPosition.z - 0.5f));
	}

	public void 达(string 串参 = "")
	{
		Vector3 localPosition = 该.transform.localPosition;
		TeleportController.逮.瞬(new Vector3(localPosition.x + 该.transform.localScale.x * 0.1f, localPosition.y - 1.5f + 该.transform.localScale.y * 0.1f, localPosition.z - 0.5f - 该.transform.localScale.z * 0.1f));
	}

	public void 扶(string 串参 = "")
	{
		Vector3 localPosition = 该.transform.localPosition;
		TeleportController.逮.瞬(new Vector3(localPosition.x, localPosition.y - 1.5f, localPosition.z - 0.5f));
	}

	public void 问(string 串参 = "")
	{
	}

	public void 答(string 串参 = "")
	{
	}

	public void 退(string 串参 = "")
	{
		TeleportController.逮.瞬(Vector3.zero);
	}

	public void 愿(string 串参 = "")
	{
	}

	public void 源(string 串参 = "")
	{
	}

	public void 数(string 串参 = "")
	{
	}

	public void 简(string 串参 = "")
	{
		生典(私串汉);
	}

	public void 繁(string 串参 = "")
	{
		公为繁 = true;
		生典(私串汉);
	}

	public void 英(string 串参 = "")
	{
		生典(私串英);
	}

	public void 汉(string 串参 = "")
	{
		公为繁 = false;
		生典(私串汉);
	}

	public void 游(string 串参 = "")
	{
		Manager._instance.Down.确定();
		GameObject.Find("/=虚/-单字/游(Clone)").SetActive(value: false);
	}

	public void 帐(string 串参 = "")
	{
		GameObject obj = GameObject.Find("/=布编程/-运行时/帐");
		obj.SetActive(!obj.activeSelf);
	}

	public void 属(string 串参 = "")
	{
		GameObject obj = GameObject.Find("/=布编程/-运行时/属");
		obj.SetActive(!obj.activeSelf);
	}

	public void 帮(string 串参 = "")
	{
		GameObject gameObject = GameObject.Find("/=布编程/-帮助/帮");
		GameObject obj = GameObject.Find("/=布编程/-帮助/略");
		gameObject.SetActive(!gameObject.activeSelf);
		obj.SetActive(gameObject.activeSelf);
	}

	public void 录(string 串参 = "")
	{
		开始录音();
	}

	public void 主(string 串参 = "")
	{
	}

	public void 锁(string 串参 = "")
	{
		佑.逮.主锁迁();
	}

	public void 射(string 串参 = "")
	{
		公主 = "射";
	}

	public void 选(string 串参 = "")
	{
		公主 = "选";
		佑.逮.置态("选");
	}

	public void 全(string 串参 = "")
	{
		if (佑.逮.公组.transform.childCount > 0)
		{
			for (int i = 0; i < 佑.逮.公组.transform.childCount; i++)
			{
				GameObject gameObject = 佑.逮.公组.transform.GetChild(i).gameObject;
				佑.逮.公尤阵选.Add(gameObject);
				佑.逮.醒(gameObject, 佑.逮.公材醒);
			}
		}
	}

	public void 剪(string 串参 = "")
	{
		GameObject obj = GameObject.Find("/=布编程/-域/Viewport/Content");
		GUIUtility.systemCopyBuffer = obj.GetComponent<Text>().text;
		obj.GetComponent<Text>().text = "";
		MonoBehaviour.print("剪:" + GUIUtility.systemCopyBuffer);
	}

	public void 拷(string 串参 = "")
	{
		GUIUtility.systemCopyBuffer = GameObject.Find("/=布编程/-域/Viewport/Content").GetComponent<Text>().text;
		MonoBehaviour.print("拷:" + GUIUtility.systemCopyBuffer);
	}

	public void 贴(string 串参 = "")
	{
		GameObject obj = GameObject.Find("/=布编程/-域/Viewport/Content");
		_ = obj.GetComponent<Text>().text;
		obj.GetComponent<Text>().text = GUIUtility.systemCopyBuffer;
		MonoBehaviour.print("贴:" + GUIUtility.systemCopyBuffer);
	}

	public void 享(string 串参 = "")
	{
		string text = WWW.EscapeURL(串参);
		UnityEngine.Application.OpenURL("https://picosong.com/w/" + text);
	}

	public void 藏(string 串参 = "")
	{
	}

	public void 哪(string 串参 = "")
	{
		公态 = "哪";
		佑.逮.置佑摇("哪");
	}

	public void 那(string 串参 = "")
	{
		公态 = "那";
		佑.逮.置佑摇("那");
	}

	public void 啊(string 串参 = "")
	{
		公态 = "啊";
		佑.逮.置佑摇("啊");
	}

	public void 创(string 串参 = "")
	{
		公态 = "创";
		佑.逮.置态("创");
	}

	public void 造(string 串参 = "")
	{
		振();
		公态 = "造";
		佑.逮.置态("造");
		佑.逮.改造啥(造啥);
	}

	public void 司(string 串参 = "")
	{
	}

	public void 群(string 串参 = "")
	{
	}

	public void 组(string 串参 = "")
	{
	}

	public void 个(string 串参 = "")
	{
	}

	public void 点(string 串参 = "")
	{
	}

	public void 线(string 串参 = "")
	{
	}

	public void 面(string 串参 = "")
	{
	}

	public void 谓(string 串参 = "")
	{
	}

	public void 已(string 串参 = "")
	{
		公敬 = "已";
	}

	public void 仅(string 串参 = "")
	{
		公敬 = "仅";
	}

	public void 然(string 串参 = "")
	{
		公敬 = "然";
	}

	public void 解(string 串参 = "")
	{
		GameObject gameObject = GameObject.Find("/=造/-组啥");
		string text = "";
		string text2 = "";
		string 串参2 = "";
		string text3 = "";
		for (int i = 0; i < gameObject.transform.childCount; i++)
		{
			GameObject gameObject2 = gameObject.transform.GetChild(i).gameObject;
			string text4 = gameObject2.name.Substring(1, 1);
			if (gameObject2.transform.childCount <= 0)
			{
				continue;
			}
			for (int j = 0; j < gameObject2.transform.childCount; j++)
			{
				GameObject gameObject3 = gameObject2.transform.GetChild(j).gameObject;
				if (text4 == "广")
				{
					text2 = "白";
					text3 = "广";
				}
				else
				{
					text2 = gameObject3.GetComponentInChildren<MeshRenderer>().materials[0].ToString().Substring(0, 1);
					text3 = "造";
				}
				text = text + text3 + gameObject3.name.Substring(0, 1) + 解横(gameObject3.transform.localPosition.x.ToString()) + 解纵(gameObject3.transform.localPosition.y.ToString()) + 解深(gameObject3.transform.localPosition.z.ToString()) + 解纠(gameObject3.transform.localEulerAngles.x.ToString()) + 解拧(gameObject3.transform.localEulerAngles.y.ToString()) + 解转(gameObject3.transform.localEulerAngles.z.ToString()) + 解宽(gameObject3.transform.localScale.x.ToString()) + 解高(gameObject3.transform.localScale.y.ToString()) + 解厚(gameObject3.transform.localScale.z.ToString()) + 解材(text2) + 解签(串参2) + "\r\n";
			}
		}
		域刷(text);
	}

	private void 域刷(string 串参 = "")
	{
		MonoBehaviour.print("域刷()串参:" + 串参);
		GameObject.Find("/=布编程/-域/Viewport/Content").GetComponent<Text>().text = 串参;
		Canvas.ForceUpdateCanvases();
		leftLogScrollRect.verticalNormalizedPosition = 0f;
	}

	public string 脑解(string 串参 = "")
	{
		GameObject gameObject = GameObject.Find("/=造/-组啥");
		string text = "";
		string text2 = "";
		string text3 = "";
		for (int i = 0; i < gameObject.transform.childCount; i++)
		{
			GameObject gameObject2 = gameObject.transform.GetChild(i).gameObject;
			string text4 = gameObject2.name.Substring(1, 1);
			if (gameObject2.transform.childCount <= 0)
			{
				continue;
			}
			for (int j = 0; j < gameObject2.transform.childCount; j++)
			{
				GameObject gameObject3 = gameObject2.transform.GetChild(j).gameObject;
				if (text4 == "广")
				{
					text2 = "白";
					text3 = "广";
				}
				else
				{
					text2 = gameObject3.GetComponentInChildren<MeshRenderer>().materials[0].ToString().Substring(0, 1);
					text3 = "造";
				}
				text = text + text3 + gameObject3.name.Substring(0, 1) + 解横(gameObject3.transform.localPosition.x.ToString()) + 解纵(gameObject3.transform.localPosition.y.ToString()) + 解深(gameObject3.transform.localPosition.z.ToString()) + 解纠(gameObject3.transform.localEulerAngles.x.ToString()) + 解拧(gameObject3.transform.localEulerAngles.y.ToString()) + 解转(gameObject3.transform.localEulerAngles.z.ToString()) + 解宽(gameObject3.transform.localScale.x.ToString()) + 解高(gameObject3.transform.localScale.y.ToString()) + 解厚(gameObject3.transform.localScale.z.ToString()) + 解材(text2) + "\r\n";
			}
		}
		return text;
	}

	private string 解横(string 串参 = "")
	{
		if (串参 == "0")
		{
			串参 = "";
		}
		return "横" + 串参;
	}

	private string 解纵(string 串参 = "")
	{
		if (串参 == "0")
		{
			串参 = "";
		}
		return "纵" + 串参;
	}

	private string 解深(string 串参 = "")
	{
		if (串参 == "0")
		{
			串参 = "";
		}
		return "深" + 串参;
	}

	private string 解纠(string 串参 = "")
	{
		if (串参 == "0")
		{
			return "";
		}
		return "纠" + 串参;
	}

	private string 解拧(string 串参 = "")
	{
		if (串参 == "0")
		{
			return "";
		}
		return "拧" + 串参;
	}

	private string 解转(string 串参 = "")
	{
		if (串参 == "0")
		{
			return "";
		}
		return "转" + 串参;
	}

	private string 解宽(string 串参 = "")
	{
		if (串参 == "1")
		{
			return "";
		}
		return "宽" + 串参;
	}

	private string 解高(string 串参 = "")
	{
		if (串参 == "1")
		{
			return "";
		}
		return "高" + 串参;
	}

	private string 解厚(string 串参 = "")
	{
		if (串参 == "1")
		{
			return "";
		}
		return "厚" + 串参;
	}

	private string 解材(string 串参 = "")
	{
		if (串参 == "白")
		{
			return "";
		}
		return "材" + 串参;
	}

	private string 解签(string 串参 = "")
	{
		if (串参 == "Cube")
		{
			return "";
		}
		return "材" + 串参;
	}

	public void 存(string 串参 = "")
	{
		解();
		string text = GameObject.Find("/=布编程/-域/Viewport/Content").GetComponent<Text>().text;
		string text2 = ((!(私该开 != "")) ? 已广() : 私该开);
		公讲.text = "存在【" + text2 + "】上，用【开" + text2 + "】可打开";
		PlayerPrefs.SetString(text2, text);
		PlayerPrefs.Save();
		振();
	}

	public void 另(string 串参 = "")
	{
		解();
		string text = GameObject.Find("/=布编程/-域/Viewport/Content").GetComponent<Text>().text;
		string 串参2 = 已广();
		串参2 = 然广(串参2);
		公讲.text = "另存在【" + 串参2 + "】上，用【开" + 串参2 + "】可打开";
		PlayerPrefs.SetString(串参2, text);
		PlayerPrefs.Save();
		振();
	}

	public void 清广(string 串参 = "")
	{
		PlayerPrefs.DeleteAll();
	}

	public string 已广(string 串参 = "")
	{
		string pattern = "\\s";
		string input = Regex.Replace(公广, pattern, "");
		string[] array = new Regex("").Split(input);
		string text = "";
		for (int i = 1; i < array.Length; i++)
		{
			text = array[i];
			if (!(text.Trim() == "") && !PlayerPrefs.HasKey(text))
			{
				text = array[i - 1];
				break;
			}
		}
		if (text == "")
		{
			text = "虚";
		}
		return text;
	}

	public string 然广(string 串参 = "")
	{
		string pattern = "\\s";
		string text = Regex.Replace(公广, pattern, "");
		text = text.Substring(text.IndexOf(串参) + 1, 1);
		MonoBehaviour.print("【然广】下一个要另存为的广：" + text);
		return text;
	}

	public void 脑史(string 串参 = "")
	{
		公已稿 = 公该稿;
		公该稿 = 脑解();
		公然稿 = 公该稿;
		域刷(公该稿);
	}

	public void 开(string 串参 = "")
	{
		公已稿 = 脑解();
		清();
		string key;
		if (串参 == "")
		{
			key = 已广();
		}
		else
		{
			key = 串参;
			佑.逮.置态("造");
		}
		私该开 = key;
		string @string = PlayerPrefs.GetString(key, "");
		析(@string);
		GameObject.Find("/=布编程/-域/Viewport/Content").GetComponent<Text>().text = @string;
		公已稿 = @string;
		公该稿 = @string;
		公然稿 = @string;
	}

	public void 撤(string 串参 = "")
	{
		公该稿 = 公已稿;
		公然稿 = 公该稿;
		清();
		析(公已稿);
	}

	public void 再(string 串参 = "")
	{
		公已稿 = 公该稿;
		公该稿 = 公然稿;
		公然稿 = 公该稿;
		清();
		析(公然稿);
	}

	public void 广开()
	{
		公态 = "开";
		佑.逮.置态("开");
	}

	public void 广签()
	{
		公态 = "签";
		佑.逮.置态("签");
	}

	public void 执(string 串参 = "")
	{
		清();
		string text = GameObject.Find("/=布编程/-域/Viewport/Content").GetComponent<Text>().text;
		析(text);
	}

	public void 清(string 串参 = "")
	{
		if (串参 == "")
		{
			串参 = "/=造/-组啥";
		}
		GameObject gameObject = GameObject.Find(串参);
		for (int i = 0; i < gameObject.transform.childCount; i++)
		{
			GameObject gameObject2 = gameObject.transform.GetChild(i).gameObject;
			for (int j = 0; j < gameObject2.transform.childCount; j++)
			{
				UnityEngine.Object.Destroy(gameObject2.transform.GetChild(j).gameObject);
			}
		}
	}

	public void 宾(string 串参 = "")
	{
	}

	public void 瞬(string 串参 = "")
	{
	}

	public void 右(string 串参 = "")
	{
	}

	public void 左(string 串参 = "")
	{
	}

	public void 升(string 串参 = "")
	{
		类走.逮.取垂直移动方向("升");
	}

	public void 降(string 串参 = "")
	{
		类走.逮.取垂直移动方向("降");
	}

	public void 悬(string 串参 = "")
	{
		类走.逮.取垂直移动方向();
	}

	public void 上(string 串参 = "")
	{
	}

	public void 下(string 串参 = "")
	{
	}

	public void 过(string 串参 = "")
	{
	}

	public void 往(string 串参 = "")
	{
	}

	public void 倾(string 串参 = "")
	{
	}

	public void 斜(string 串参 = "")
	{
	}

	public void 大(string 串参 = "")
	{
		佑.逮.它.transform.localScale += new Vector3(公系, 公系, 公系);
		float x = 佑.逮.它.transform.localPosition.x;
		float y = 佑.逮.它.transform.localPosition.y;
		float z = 佑.逮.它.transform.localPosition.z;
		公告.text = "横:" + x + "纵:" + y + "深:" + z;
	}

	public void 中(string 串参 = "")
	{
		佑.逮.它.transform.localScale = Vector3.one;
		float x = 佑.逮.它.transform.localPosition.x;
		float y = 佑.逮.它.transform.localPosition.y;
		float z = 佑.逮.它.transform.localPosition.z;
		公告.text = "横:" + x + "纵:" + y + "深:" + z;
	}

	public void 小(string 串参 = "")
	{
		佑.逮.它.transform.localScale -= new Vector3(公系, 公系, 公系);
		float x = 佑.逮.它.transform.localPosition.x;
		float y = 佑.逮.它.transform.localPosition.y;
		float z = 佑.逮.它.transform.localPosition.z;
		公告.text = "横:" + x + "纵:" + y + "深:" + z;
	}

	public void 移(string 串参 = "")
	{
		佑.逮.置态("移");
	}

	public void 位(string 串参 = "")
	{
		if (佑.逮.公尤阵选.Count > 1)
		{
			for (int i = 0; i < 佑.逮.公尤阵选.Count; i++)
			{
				GameObject gameObject = 佑.逮.公尤阵选[i].gameObject;
				if ((bool)gameObject)
				{
					gameObject.transform.localPosition = new Vector3(0f, 0f, 0f);
				}
			}
		}
		else if ((bool)该)
		{
			该.transform.localPosition = new Vector3(0f, 0f, 0f);
		}
	}

	public void 横(string 串参 = "")
	{
		if (佑.逮.公尤阵选.Count > 1)
		{
			for (int i = 0; i < 佑.逮.公尤阵选.Count; i++)
			{
				GameObject gameObject = 佑.逮.公尤阵选[i].gameObject;
				if ((bool)gameObject)
				{
					gameObject.transform.localPosition += new Vector3(公系 * 公微, 0f, 0f);
				}
			}
		}
		else if (私尤横集 != null && 公签 != "" && 私尤横集.Length != 0)
		{
			for (int j = 0; j < 私尤横集.Length; j++)
			{
				GameObject gameObject2 = 私尤横集[j].gameObject;
				if ((bool)gameObject2)
				{
					gameObject2.transform.localPosition += new Vector3(公系 * 公微, 0f, 0f);
				}
			}
		}
		else if ((bool)该)
		{
			该.transform.localPosition += new Vector3(公系 * 公微, 0f, 0f);
		}
	}

	public void 平(string 串参 = "")
	{
		if (佑.逮.公尤阵选.Count > 1)
		{
			for (int i = 0; i < 佑.逮.公尤阵选.Count; i++)
			{
				GameObject gameObject = 佑.逮.公尤阵选[i].gameObject;
				if ((bool)gameObject)
				{
					gameObject.transform.localPosition -= new Vector3(公系 * 公微, 0f, 0f);
				}
			}
		}
		else if (私尤平集 != null && 公签 != "" && 私尤平集.Length != 0)
		{
			MonoBehaviour.print("平");
			for (int j = 0; j < 私尤平集.Length; j++)
			{
				GameObject gameObject2 = 私尤平集[j].gameObject;
				if ((bool)gameObject2)
				{
					gameObject2.transform.localPosition -= new Vector3(公系 * 公微, 0f, 0f);
				}
			}
		}
		else if ((bool)该)
		{
			该.transform.localPosition -= new Vector3(公系 * 公微, 0f, 0f);
		}
	}

	public void 纵(string 串参 = "")
	{
		if (佑.逮.公尤阵选.Count > 1)
		{
			for (int i = 0; i < 佑.逮.公尤阵选.Count; i++)
			{
				GameObject gameObject = 佑.逮.公尤阵选[i].gameObject;
				if ((bool)gameObject)
				{
					gameObject.transform.localPosition += new Vector3(0f, 公系 * 公微, 0f);
				}
			}
		}
		else if (私尤纵集 != null && 公签 != "" && 私尤纵集.Length != 0)
		{
			MonoBehaviour.print("---------纵-----------");
			for (int j = 0; j < 私尤纵集.Length; j++)
			{
				GameObject gameObject2 = 私尤纵集[j].gameObject;
				if ((bool)gameObject2)
				{
					gameObject2.transform.localPosition += new Vector3(0f, 公系 * 公微, 0f);
				}
			}
		}
		else if ((bool)该)
		{
			该.transform.localPosition += new Vector3(0f, 公系 * 公微, 0f);
		}
	}

	public void 垂(string 串参 = "")
	{
		if (佑.逮.公尤阵选.Count > 1)
		{
			for (int i = 0; i < 佑.逮.公尤阵选.Count; i++)
			{
				GameObject gameObject = 佑.逮.公尤阵选[i].gameObject;
				if ((bool)gameObject)
				{
					gameObject.transform.localPosition -= new Vector3(0f, 公系 * 公微, 0f);
				}
			}
		}
		else if (私尤垂集 != null && 公签 != "" && 私尤垂集.Length != 0)
		{
			MonoBehaviour.print("---------垂-----------");
			for (int j = 0; j < 私尤垂集.Length; j++)
			{
				GameObject gameObject2 = 私尤垂集[j].gameObject;
				if ((bool)gameObject2)
				{
					gameObject2.transform.localPosition -= new Vector3(0f, 公系 * 公微, 0f);
				}
			}
		}
		else if ((bool)该)
		{
			该.transform.localPosition -= new Vector3(0f, 公系 * 公微, 0f);
		}
	}

	public void 深(string 串参 = "")
	{
		if (佑.逮.公尤阵选.Count > 1)
		{
			for (int i = 0; i < 佑.逮.公尤阵选.Count; i++)
			{
				GameObject gameObject = 佑.逮.公尤阵选[i].gameObject;
				if ((bool)gameObject)
				{
					gameObject.transform.localPosition += new Vector3(0f, 0f, 公系 * 公微);
				}
			}
		}
		else if (私尤深集 != null && 公签 != "" && 私尤深集.Length != 0)
		{
			MonoBehaviour.print("------------深--------");
			for (int j = 0; j < 私尤深集.Length; j++)
			{
				GameObject gameObject2 = 私尤深集[j].gameObject;
				if ((bool)gameObject2)
				{
					gameObject2.transform.localPosition += new Vector3(0f, 0f, 公系 * 公微);
				}
			}
		}
		else if ((bool)该)
		{
			该.transform.localPosition += new Vector3(0f, 0f, 公系 * 公微);
		}
	}

	public void 浅(string 串参 = "")
	{
		if (佑.逮.公尤阵选.Count > 1)
		{
			for (int i = 0; i < 佑.逮.公尤阵选.Count; i++)
			{
				GameObject gameObject = 佑.逮.公尤阵选[i].gameObject;
				if ((bool)gameObject)
				{
					gameObject.transform.localPosition -= new Vector3(0f, 0f, 公系 * 公微);
				}
			}
		}
		else if (私尤浅集 != null && 公签 != "" && 私尤浅集.Length != 0)
		{
			MonoBehaviour.print("----------浅----------");
			for (int j = 0; j < 私尤浅集.Length; j++)
			{
				GameObject gameObject2 = 私尤浅集[j].gameObject;
				if ((bool)gameObject2)
				{
					gameObject2.transform.localPosition -= new Vector3(0f, 0f, 公系 * 公微);
				}
			}
		}
		else if ((bool)该)
		{
			该.transform.localPosition -= new Vector3(0f, 0f, 公系 * 公微);
		}
	}

	public void 迁(string 串参 = "")
	{
		if (佑.逮.公尤阵选.Count > 1)
		{
			for (int i = 0; i < 佑.逮.公尤阵选.Count; i++)
			{
				GameObject gameObject = 佑.逮.公尤阵选[i].gameObject;
				if ((bool)gameObject)
				{
					gameObject.transform.localPosition += new Vector3(公系 * 公微, 公系 * 公微, 0f);
				}
			}
		}
		else if (私尤迁集 != null && 公签 != "" && 私尤迁集.Length != 0)
		{
			MonoBehaviour.print("---------迁-----------");
			for (int j = 0; j < 私尤迁集.Length; j++)
			{
				GameObject gameObject2 = 私尤迁集[j].gameObject;
				if ((bool)gameObject2)
				{
					gameObject2.transform.localPosition += new Vector3(公系 * 公微, 公系 * 公微, 0f);
				}
			}
		}
		else if ((bool)该)
		{
			该.transform.localPosition += new Vector3(公系 * 公微, 公系 * 公微, 0f);
		}
	}

	public void 徒(string 串参 = "")
	{
		if (佑.逮.公尤阵选.Count > 1)
		{
			for (int i = 0; i < 佑.逮.公尤阵选.Count; i++)
			{
				GameObject gameObject = 佑.逮.公尤阵选[i].gameObject;
				if ((bool)gameObject)
				{
					gameObject.transform.localPosition -= new Vector3(公系 * 公微, 公系 * 公微, 0f);
				}
			}
		}
		else if (私尤徒集 != null && 公签 != "" && 私尤徒集.Length != 0)
		{
			MonoBehaviour.print("----------徒----------");
			for (int j = 0; j < 私尤徒集.Length; j++)
			{
				GameObject gameObject2 = 私尤徒集[j].gameObject;
				if ((bool)gameObject2)
				{
					gameObject2.transform.localPosition -= new Vector3(公系 * 公微, 公系 * 公微, 0f);
				}
			}
		}
		else if ((bool)该)
		{
			该.transform.localPosition -= new Vector3(公系 * 公微, 公系 * 公微, 0f);
		}
	}

	public void 沧(string 串参 = "")
	{
		if (佑.逮.公尤阵选.Count > 1)
		{
			for (int i = 0; i < 佑.逮.公尤阵选.Count; i++)
			{
				GameObject gameObject = 佑.逮.公尤阵选[i].gameObject;
				if ((bool)gameObject)
				{
					gameObject.transform.localPosition += new Vector3(公系 * 公微, 0f, 公系 * 公微);
				}
			}
		}
		else if (私尤沧集 != null && 公签 != "" && 私尤沧集.Length != 0)
		{
			MonoBehaviour.print("----------沧----------");
			for (int j = 0; j < 私尤沧集.Length; j++)
			{
				GameObject gameObject2 = 私尤沧集[j].gameObject;
				if ((bool)gameObject2)
				{
					gameObject2.transform.localPosition += new Vector3(公系 * 公微, 0f, 公系 * 公微);
				}
			}
		}
		else if ((bool)该)
		{
			该.transform.localPosition += new Vector3(公系 * 公微, 0f, 公系 * 公微);
		}
	}

	public void 桑(string 串参 = "")
	{
		if (佑.逮.公尤阵选.Count > 1)
		{
			for (int i = 0; i < 佑.逮.公尤阵选.Count; i++)
			{
				GameObject gameObject = 佑.逮.公尤阵选[i].gameObject;
				if ((bool)gameObject)
				{
					gameObject.transform.localPosition -= new Vector3(公系 * 公微, 0f, 公系 * 公微);
				}
			}
		}
		else if (私尤桑集 != null && 公签 != "" && 私尤桑集.Length != 0)
		{
			MonoBehaviour.print("---------桑-----------");
			for (int j = 0; j < 私尤桑集.Length; j++)
			{
				GameObject gameObject2 = 私尤桑集[j].gameObject;
				if ((bool)gameObject2)
				{
					gameObject2.transform.localPosition -= new Vector3(公系 * 公微, 0f, 公系 * 公微);
				}
			}
		}
		else if ((bool)该)
		{
			该.transform.localPosition -= new Vector3(公系 * 公微, 0f, 公系 * 公微);
		}
	}

	public void 抬(string 串参 = "")
	{
		if (佑.逮.公尤阵选.Count > 1)
		{
			for (int i = 0; i < 佑.逮.公尤阵选.Count; i++)
			{
				GameObject gameObject = 佑.逮.公尤阵选[i].gameObject;
				if ((bool)gameObject)
				{
					gameObject.transform.localPosition += new Vector3(0f, 公系 * 公微, 公系 * 公微);
				}
			}
		}
		else if (私尤抬集 != null && 公签 != "" && 私尤抬集.Length != 0)
		{
			MonoBehaviour.print("---------抬-----------");
			for (int j = 0; j < 私尤抬集.Length; j++)
			{
				GameObject gameObject2 = 私尤抬集[j].gameObject;
				if ((bool)gameObject2)
				{
					gameObject2.transform.localPosition += new Vector3(0f, 公系 * 公微, 公系 * 公微);
				}
			}
		}
		else if ((bool)该)
		{
			该.transform.localPosition += new Vector3(0f, 公系 * 公微, 公系 * 公微);
		}
	}

	public void 坠(string 串参 = "")
	{
		if (佑.逮.公尤阵选.Count > 1)
		{
			for (int i = 0; i < 佑.逮.公尤阵选.Count; i++)
			{
				GameObject gameObject = 佑.逮.公尤阵选[i].gameObject;
				if ((bool)gameObject)
				{
					gameObject.transform.localPosition -= new Vector3(0f, 公系 * 公微, 公系 * 公微);
				}
			}
		}
		else if (私尤坠集 != null && 公签 != "" && 私尤坠集.Length != 0)
		{
			MonoBehaviour.print("---------坠-----------");
			for (int j = 0; j < 私尤坠集.Length; j++)
			{
				GameObject gameObject2 = 私尤坠集[j].gameObject;
				if ((bool)gameObject2)
				{
					gameObject2.transform.localPosition -= new Vector3(0f, 公系 * 公微, 公系 * 公微);
				}
			}
		}
		else if ((bool)该)
		{
			该.transform.localPosition -= new Vector3(0f, 公系 * 公微, 公系 * 公微);
		}
	}

	public void 徘(string 串参 = "")
	{
		if (佑.逮.公尤阵选.Count > 1)
		{
			for (int i = 0; i < 佑.逮.公尤阵选.Count; i++)
			{
				GameObject gameObject = 佑.逮.公尤阵选[i].gameObject;
				if ((bool)gameObject)
				{
					gameObject.transform.localPosition += new Vector3(公系 * 公微, 公系 * 公微, 公系 * 公微);
				}
			}
		}
		else if (私尤徘集 != null && 公签 != "" && 私尤徘集.Length != 0)
		{
			MonoBehaviour.print("---------徘-----------");
			for (int j = 0; j < 私尤徘集.Length; j++)
			{
				GameObject gameObject2 = 私尤徘集[j].gameObject;
				if ((bool)gameObject2)
				{
					gameObject2.transform.localPosition += new Vector3(公系 * 公微, 公系 * 公微, 公系 * 公微);
				}
			}
		}
		else if ((bool)该)
		{
			该.transform.localPosition += new Vector3(公系 * 公微, 公系 * 公微, 公系 * 公微);
		}
	}

	public void 徊(string 串参 = "")
	{
		if (佑.逮.公尤阵选.Count > 1)
		{
			for (int i = 0; i < 佑.逮.公尤阵选.Count; i++)
			{
				GameObject gameObject = 佑.逮.公尤阵选[i].gameObject;
				if ((bool)gameObject)
				{
					gameObject.transform.localPosition -= new Vector3(公系 * 公微, 公系 * 公微, 公系 * 公微);
				}
			}
		}
		else if (私尤徊集 != null && 公签 != "" && 私尤徊集.Length != 0)
		{
			MonoBehaviour.print("----------徊----------");
			for (int j = 0; j < 私尤徊集.Length; j++)
			{
				GameObject gameObject2 = 私尤徊集[j].gameObject;
				if ((bool)gameObject2)
				{
					gameObject2.transform.localPosition -= new Vector3(公系 * 公微, 公系 * 公微, 公系 * 公微);
				}
			}
		}
		else if ((bool)该)
		{
			该.transform.localPosition -= new Vector3(公系 * 公微, 公系 * 公微, 公系 * 公微);
		}
	}

	public void 挪(string 串参 = "")
	{
		佑.逮.置态("挪");
	}

	public void 弄(string 串参 = "")
	{
		if (佑.逮.公尤阵选.Count > 1)
		{
			for (int i = 0; i < 佑.逮.公尤阵选.Count; i++)
			{
				GameObject gameObject = 佑.逮.公尤阵选[i].gameObject;
				if ((bool)gameObject)
				{
					gameObject.transform.localRotation = Quaternion.Euler(0f, 0f, 0f);
				}
			}
		}
		else if ((bool)该)
		{
			该.transform.localRotation = Quaternion.Euler(0f, 0f, 0f);
		}
	}

	public void 纠(string 串参 = "")
	{
		if (佑.逮.公尤阵选.Count > 1)
		{
			for (int i = 0; i < 佑.逮.公尤阵选.Count; i++)
			{
				GameObject gameObject = 佑.逮.公尤阵选[i].gameObject;
				if ((bool)gameObject)
				{
					gameObject.transform.localRotation *= Quaternion.Euler(公系 * 公宙, 0f, 0f);
				}
			}
		}
		else if (私尤纠集 != null && 公签 != "" && 私尤纠集.Length != 0)
		{
			MonoBehaviour.print("----------纠----------");
			for (int j = 0; j < 私尤纠集.Length; j++)
			{
				GameObject gameObject2 = 私尤纠集[j].gameObject;
				if ((bool)gameObject2)
				{
					gameObject2.transform.localRotation *= Quaternion.Euler(公系 * 公宙, 0f, 0f);
				}
			}
		}
		else if ((bool)该)
		{
			该.transform.localRotation *= Quaternion.Euler(公系 * 公宙, 0f, 0f);
		}
	}

	public void 缠(string 串参 = "")
	{
		if (佑.逮.公尤阵选.Count > 1)
		{
			for (int i = 0; i < 佑.逮.公尤阵选.Count; i++)
			{
				GameObject gameObject = 佑.逮.公尤阵选[i].gameObject;
				if ((bool)gameObject)
				{
					gameObject.transform.localRotation *= Quaternion.Euler((0f - 公系) * 公宙, 0f, 0f);
				}
			}
		}
		else if (私尤缠集 != null && 公签 != "" && 私尤缠集.Length != 0)
		{
			MonoBehaviour.print("-----------缠---------");
			for (int j = 0; j < 私尤缠集.Length; j++)
			{
				GameObject gameObject2 = 私尤缠集[j].gameObject;
				if ((bool)gameObject2)
				{
					gameObject2.transform.localRotation *= Quaternion.Euler((0f - 公系) * 公宙, 0f, 0f);
				}
			}
		}
		else if ((bool)该)
		{
			该.transform.localRotation *= Quaternion.Euler((0f - 公系) * 公宙, 0f, 0f);
		}
	}

	public void 拧(string 串参 = "")
	{
		if (佑.逮.公尤阵选.Count > 1)
		{
			for (int i = 0; i < 佑.逮.公尤阵选.Count; i++)
			{
				GameObject gameObject = 佑.逮.公尤阵选[i].gameObject;
				if ((bool)gameObject)
				{
					gameObject.transform.localRotation *= Quaternion.Euler(0f, 公系 * 公宙, 0f);
				}
			}
		}
		else if (私尤拧集 != null && 公签 != "" && 私尤拧集.Length != 0)
		{
			MonoBehaviour.print("---------拧-----------");
			for (int j = 0; j < 私尤拧集.Length; j++)
			{
				GameObject gameObject2 = 私尤拧集[j].gameObject;
				if ((bool)gameObject2)
				{
					gameObject2.transform.localRotation *= Quaternion.Euler(0f, 公系 * 公宙, 0f);
				}
			}
		}
		else if ((bool)该)
		{
			该.transform.localRotation *= Quaternion.Euler(0f, 公系 * 公宙, 0f);
		}
	}

	public void 扭(string 串参 = "")
	{
		if (佑.逮.公尤阵选.Count > 1)
		{
			for (int i = 0; i < 佑.逮.公尤阵选.Count; i++)
			{
				GameObject gameObject = 佑.逮.公尤阵选[i].gameObject;
				if ((bool)gameObject)
				{
					gameObject.transform.localRotation *= Quaternion.Euler(0f, (0f - 公系) * 公宙, 0f);
				}
			}
		}
		else if (私尤扭集 != null && 公签 != "" && 私尤扭集.Length != 0)
		{
			MonoBehaviour.print("----------扭----------");
			for (int j = 0; j < 私尤扭集.Length; j++)
			{
				GameObject gameObject2 = 私尤扭集[j].gameObject;
				if ((bool)gameObject2)
				{
					gameObject2.transform.localRotation *= Quaternion.Euler(0f, (0f - 公系) * 公宙, 0f);
				}
			}
		}
		else if ((bool)该)
		{
			该.transform.localRotation *= Quaternion.Euler(0f, (0f - 公系) * 公宙, 0f);
		}
	}

	public void 转(string 串参 = "")
	{
		if (佑.逮.公尤阵选.Count > 1)
		{
			for (int i = 0; i < 佑.逮.公尤阵选.Count; i++)
			{
				GameObject gameObject = 佑.逮.公尤阵选[i].gameObject;
				if ((bool)gameObject)
				{
					gameObject.transform.localRotation *= Quaternion.Euler(0f, 0f, (0f - 公系) * 公宙);
				}
			}
		}
		else if (私尤转集 != null && 公签 != "" && 私尤转集.Length != 0)
		{
			for (int j = 0; j < 私尤转集.Length; j++)
			{
				GameObject gameObject2 = 私尤转集[j].gameObject;
				if ((bool)gameObject2)
				{
					gameObject2.transform.localRotation *= Quaternion.Euler(0f, 0f, (0f - 公系) * 公宙);
				}
			}
		}
		else if ((bool)该)
		{
			该.transform.localRotation *= Quaternion.Euler(0f, 0f, (0f - 公系) * 公宙);
		}
	}

	public void 旋(string 串参 = "")
	{
		if (佑.逮.公尤阵选.Count > 1)
		{
			for (int i = 0; i < 佑.逮.公尤阵选.Count; i++)
			{
				GameObject gameObject = 佑.逮.公尤阵选[i].gameObject;
				if ((bool)gameObject)
				{
					gameObject.transform.localRotation *= Quaternion.Euler(0f, 0f, 公系 * 公宙);
				}
			}
		}
		else if (私尤旋集 != null && 公签 != "" && 私尤旋集.Length != 0)
		{
			MonoBehaviour.print("----------旋----------");
			for (int j = 0; j < 私尤旋集.Length; j++)
			{
				GameObject gameObject2 = 私尤旋集[j].gameObject;
				if ((bool)gameObject2)
				{
					gameObject2.transform.localRotation *= Quaternion.Euler(0f, 0f, 公系 * 公宙);
				}
			}
		}
		else if ((bool)该)
		{
			该.transform.localRotation *= Quaternion.Euler(0f, 0f, 公系 * 公宙);
		}
	}

	public void 跌(string 串参 = "")
	{
		if (佑.逮.公尤阵选.Count > 1)
		{
			for (int i = 0; i < 佑.逮.公尤阵选.Count; i++)
			{
				GameObject gameObject = 佑.逮.公尤阵选[i].gameObject;
				if ((bool)gameObject)
				{
					gameObject.transform.localRotation *= Quaternion.Euler(公系 * 公宙, 公系 * 公宙, 0f);
				}
			}
		}
		else if (私尤跌集 != null && 公签 != "" && 私尤跌集.Length != 0)
		{
			MonoBehaviour.print("----------跌----------");
			for (int j = 0; j < 私尤跌集.Length; j++)
			{
				GameObject gameObject2 = 私尤跌集[j].gameObject;
				if ((bool)gameObject2)
				{
					gameObject2.transform.localRotation *= Quaternion.Euler(公系 * 公宙, 公系 * 公宙, 0f);
				}
			}
		}
		else if ((bool)该)
		{
			该.transform.localRotation *= Quaternion.Euler(公系 * 公宙, 公系 * 公宙, 0f);
		}
	}

	public void 摔(string 串参 = "")
	{
		if (佑.逮.公尤阵选.Count > 1)
		{
			for (int i = 0; i < 佑.逮.公尤阵选.Count; i++)
			{
				GameObject gameObject = 佑.逮.公尤阵选[i].gameObject;
				if ((bool)gameObject)
				{
					gameObject.transform.localRotation *= Quaternion.Euler((0f - 公系) * 公宙, (0f - 公系) * 公宙, 0f);
				}
			}
		}
		else if (私尤摔集 != null && 公签 != "" && 私尤摔集.Length != 0)
		{
			MonoBehaviour.print("----------摔----------");
			for (int j = 0; j < 私尤摔集.Length; j++)
			{
				GameObject gameObject2 = 私尤摔集[j].gameObject;
				if ((bool)gameObject2)
				{
					gameObject2.transform.localRotation *= Quaternion.Euler((0f - 公系) * 公宙, (0f - 公系) * 公宙, 0f);
				}
			}
		}
		else if ((bool)该)
		{
			该.transform.localRotation *= Quaternion.Euler((0f - 公系) * 公宙, (0f - 公系) * 公宙, 0f);
		}
	}

	public void 羡(string 串参 = "")
	{
		if (佑.逮.公尤阵选.Count > 1)
		{
			for (int i = 0; i < 佑.逮.公尤阵选.Count; i++)
			{
				GameObject gameObject = 佑.逮.公尤阵选[i].gameObject;
				if ((bool)gameObject)
				{
					gameObject.transform.localRotation *= Quaternion.Euler(公系 * 公宙, 0f, 公系 * 公宙);
				}
			}
		}
		else if (私尤羡集 != null && 公签 != "" && 私尤羡集.Length != 0)
		{
			MonoBehaviour.print("---------羡-----------");
			for (int j = 0; j < 私尤羡集.Length; j++)
			{
				GameObject gameObject2 = 私尤羡集[j].gameObject;
				if ((bool)gameObject2)
				{
					gameObject2.transform.localRotation *= Quaternion.Euler(公系 * 公宙, 0f, 公系 * 公宙);
				}
			}
		}
		else if ((bool)该)
		{
			该.transform.localRotation *= Quaternion.Euler(公系 * 公宙, 0f, 公系 * 公宙);
		}
	}

	public void 慕(string 串参 = "")
	{
		if (佑.逮.公尤阵选.Count > 1)
		{
			for (int i = 0; i < 佑.逮.公尤阵选.Count; i++)
			{
				GameObject gameObject = 佑.逮.公尤阵选[i].gameObject;
				if ((bool)gameObject)
				{
					gameObject.transform.localRotation *= Quaternion.Euler((0f - 公系) * 公宙, 0f, (0f - 公系) * 公宙);
				}
			}
		}
		else if (私尤慕集 != null && 公签 != "" && 私尤慕集.Length != 0)
		{
			MonoBehaviour.print("---------慕-----------");
			for (int j = 0; j < 私尤慕集.Length; j++)
			{
				GameObject gameObject2 = 私尤慕集[j].gameObject;
				if ((bool)gameObject2)
				{
					gameObject2.transform.localRotation *= Quaternion.Euler((0f - 公系) * 公宙, 0f, (0f - 公系) * 公宙);
				}
			}
		}
		else if ((bool)该)
		{
			该.transform.localRotation *= Quaternion.Euler((0f - 公系) * 公宙, 0f, (0f - 公系) * 公宙);
		}
	}

	public void 糟(string 串参 = "")
	{
		if (佑.逮.公尤阵选.Count > 1)
		{
			for (int i = 0; i < 佑.逮.公尤阵选.Count; i++)
			{
				GameObject gameObject = 佑.逮.公尤阵选[i].gameObject;
				if ((bool)gameObject)
				{
					gameObject.transform.localRotation *= Quaternion.Euler(0f, 公系 * 公宙, 公系 * 公宙);
				}
			}
		}
		else if (私尤糟集 != null && 公签 != "" && 私尤糟集.Length != 0)
		{
			MonoBehaviour.print("----------糟----------");
			for (int j = 0; j < 私尤糟集.Length; j++)
			{
				GameObject gameObject2 = 私尤糟集[j].gameObject;
				if ((bool)gameObject2)
				{
					gameObject2.transform.localRotation *= Quaternion.Euler(0f, 公系 * 公宙, 公系 * 公宙);
				}
			}
		}
		else if ((bool)该)
		{
			该.transform.localRotation *= Quaternion.Euler(0f, 公系 * 公宙, 公系 * 公宙);
		}
	}

	public void 糕(string 串参 = "")
	{
		if (佑.逮.公尤阵选.Count > 1)
		{
			for (int i = 0; i < 佑.逮.公尤阵选.Count; i++)
			{
				GameObject gameObject = 佑.逮.公尤阵选[i].gameObject;
				if ((bool)gameObject)
				{
					gameObject.transform.localRotation *= Quaternion.Euler(0f, (0f - 公系) * 公宙, (0f - 公系) * 公宙);
				}
			}
		}
		else if (私尤糕集 != null && 公签 != "" && 私尤糕集.Length != 0)
		{
			MonoBehaviour.print("----------糕----------");
			for (int j = 0; j < 私尤糕集.Length; j++)
			{
				GameObject gameObject2 = 私尤糕集[j].gameObject;
				if ((bool)gameObject2)
				{
					gameObject2.transform.localRotation *= Quaternion.Euler(0f, (0f - 公系) * 公宙, (0f - 公系) * 公宙);
				}
			}
		}
		else if ((bool)该)
		{
			该.transform.localRotation *= Quaternion.Euler(0f, (0f - 公系) * 公宙, (0f - 公系) * 公宙);
		}
	}

	public void 凯(string 串参 = "")
	{
		if (佑.逮.公尤阵选.Count > 1)
		{
			for (int i = 0; i < 佑.逮.公尤阵选.Count; i++)
			{
				GameObject gameObject = 佑.逮.公尤阵选[i].gameObject;
				if ((bool)gameObject)
				{
					gameObject.transform.localRotation *= Quaternion.Euler(公系 * 公宙, 公系 * 公宙, 公系 * 公宙);
				}
			}
		}
		else if (私尤凯集 != null && 公签 != "" && 私尤凯集.Length != 0)
		{
			MonoBehaviour.print("----------凯----------");
			for (int j = 0; j < 私尤凯集.Length; j++)
			{
				GameObject gameObject2 = 私尤凯集[j].gameObject;
				if ((bool)gameObject2)
				{
					gameObject2.transform.localRotation *= Quaternion.Euler(公系 * 公宙, 公系 * 公宙, 公系 * 公宙);
				}
			}
		}
		else if ((bool)该)
		{
			该.transform.localRotation *= Quaternion.Euler(公系 * 公宙, 公系 * 公宙, 公系 * 公宙);
		}
	}

	public void 涡(string 串参 = "")
	{
		if (佑.逮.公尤阵选.Count > 1)
		{
			for (int i = 0; i < 佑.逮.公尤阵选.Count; i++)
			{
				GameObject gameObject = 佑.逮.公尤阵选[i].gameObject;
				if ((bool)gameObject)
				{
					gameObject.transform.localRotation *= Quaternion.Euler((0f - 公系) * 公宙, (0f - 公系) * 公宙, (0f - 公系) * 公宙);
				}
			}
		}
		else if (私尤涡集 != null && 公签 != "" && 私尤涡集.Length != 0)
		{
			MonoBehaviour.print("----------涡--？？？？？？？？要改：20230214？？？？？？？？？？？？？？？？？？？？？？？？？--------");
			for (int j = 0; j < 私尤涡集.Length; j++)
			{
				GameObject gameObject2 = 私尤涡集[j].gameObject;
				if ((bool)gameObject2)
				{
					gameObject2.transform.localRotation *= Quaternion.Euler((0f - 公系) * 公宙, (0f - 公系) * 公宙, (0f - 公系) * 公宙);
				}
			}
		}
		else if ((bool)该)
		{
			该.transform.localRotation *= Quaternion.Euler((0f - 公系) * 公宙, (0f - 公系) * 公宙, (0f - 公系) * 公宙);
		}
	}

	public void 撑(string 串参 = "")
	{
		佑.逮.置态("撑");
	}

	public void 谦(string 串参 = "")
	{
		if (佑.逮.公尤阵选.Count > 1)
		{
			for (int i = 0; i < 佑.逮.公尤阵选.Count; i++)
			{
				GameObject gameObject = 佑.逮.公尤阵选[i].gameObject;
				if ((bool)gameObject)
				{
					gameObject.transform.localScale = new Vector3(1f, 1f, 1f);
				}
			}
		}
		else if ((bool)该)
		{
			该.transform.localScale = new Vector3(1f, 1f, 1f);
		}
	}

	public void 宽(string 串参 = "")
	{
		if (佑.逮.公尤阵选.Count > 1)
		{
			for (int i = 0; i < 佑.逮.公尤阵选.Count; i++)
			{
				GameObject gameObject = 佑.逮.公尤阵选[i].gameObject;
				if ((bool)gameObject)
				{
					gameObject.transform.localScale += new Vector3(公系, 0f, 0f);
				}
			}
		}
		else if (私尤宽集 != null && 公签 != "" && 私尤宽集.Length != 0)
		{
			MonoBehaviour.print("----------宽----------");
			for (int j = 0; j < 私尤宽集.Length; j++)
			{
				GameObject gameObject2 = 私尤宽集[j].gameObject;
				if ((bool)gameObject2)
				{
					gameObject2.transform.localScale += new Vector3(公系, 0f, 0f);
				}
			}
		}
		else if ((bool)该)
		{
			该.transform.localScale += new Vector3(公系, 0f, 0f);
		}
	}

	public void 窄(string 串参 = "")
	{
		if (佑.逮.公尤阵选.Count > 1)
		{
			for (int i = 0; i < 佑.逮.公尤阵选.Count; i++)
			{
				GameObject gameObject = 佑.逮.公尤阵选[i].gameObject;
				if ((bool)gameObject)
				{
					gameObject.transform.localScale -= new Vector3(公系, 0f, 0f);
				}
			}
		}
		else if (私尤窄集 != null && 公签 != "" && 私尤窄集.Length != 0)
		{
			MonoBehaviour.print("---------窄-----------");
			for (int j = 0; j < 私尤窄集.Length; j++)
			{
				GameObject gameObject2 = 私尤窄集[j].gameObject;
				if ((bool)gameObject2)
				{
					gameObject2.transform.localScale -= new Vector3(公系, 0f, 0f);
				}
			}
		}
		else if ((bool)该)
		{
			该.transform.localScale -= new Vector3(公系, 0f, 0f);
		}
	}

	public void 高(string 串参 = "")
	{
		if (佑.逮.公尤阵选.Count > 1)
		{
			for (int i = 0; i < 佑.逮.公尤阵选.Count; i++)
			{
				GameObject gameObject = 佑.逮.公尤阵选[i].gameObject;
				if ((bool)gameObject)
				{
					gameObject.transform.localScale += new Vector3(0f, 公系, 0f);
				}
			}
		}
		else if (私尤高集 != null && 公签 != "" && 私尤高集.Length != 0)
		{
			MonoBehaviour.print("----------高----------");
			for (int j = 0; j < 私尤高集.Length; j++)
			{
				GameObject gameObject2 = 私尤高集[j].gameObject;
				if ((bool)gameObject2)
				{
					gameObject2.transform.localScale += new Vector3(0f, 公系, 0f);
				}
			}
		}
		else if ((bool)该)
		{
			该.transform.localScale += new Vector3(0f, 公系, 0f);
		}
	}

	public void 矮(string 串参 = "")
	{
		if (佑.逮.公尤阵选.Count > 1)
		{
			for (int i = 0; i < 佑.逮.公尤阵选.Count; i++)
			{
				GameObject gameObject = 佑.逮.公尤阵选[i].gameObject;
				if ((bool)gameObject)
				{
					gameObject.transform.localScale -= new Vector3(0f, 公系, 0f);
				}
			}
		}
		else if (私尤矮集 != null && 公签 != "" && 私尤矮集.Length != 0)
		{
			MonoBehaviour.print("----------矮----------");
			for (int j = 0; j < 私尤矮集.Length; j++)
			{
				GameObject gameObject2 = 私尤矮集[j].gameObject;
				if ((bool)gameObject2)
				{
					gameObject2.transform.localScale -= new Vector3(0f, 公系, 0f);
				}
			}
		}
		else if ((bool)该)
		{
			该.transform.localScale -= new Vector3(0f, 公系, 0f);
		}
	}

	public void 厚(string 串参 = "")
	{
		if (佑.逮.公尤阵选.Count > 1)
		{
			for (int i = 0; i < 佑.逮.公尤阵选.Count; i++)
			{
				GameObject gameObject = 佑.逮.公尤阵选[i].gameObject;
				if ((bool)gameObject)
				{
					gameObject.transform.localScale += new Vector3(0f, 0f, 公系);
				}
			}
		}
		else if (私尤厚集 != null && 公签 != "" && 私尤厚集.Length != 0)
		{
			MonoBehaviour.print("----------厚----------");
			for (int j = 0; j < 私尤厚集.Length; j++)
			{
				GameObject gameObject2 = 私尤厚集[j].gameObject;
				if ((bool)gameObject2)
				{
					gameObject2.transform.localScale += new Vector3(0f, 0f, 公系);
				}
			}
		}
		else if ((bool)该)
		{
			该.transform.localScale += new Vector3(0f, 0f, 公系);
		}
	}

	public void 薄(string 串参 = "")
	{
		if (佑.逮.公尤阵选.Count > 1)
		{
			for (int i = 0; i < 佑.逮.公尤阵选.Count; i++)
			{
				GameObject gameObject = 佑.逮.公尤阵选[i].gameObject;
				if ((bool)gameObject)
				{
					gameObject.transform.localScale -= new Vector3(0f, 0f, 公系);
				}
			}
		}
		else if (私尤薄集 != null && 公签 != "" && 私尤薄集.Length != 0)
		{
			MonoBehaviour.print("----------薄----------");
			for (int j = 0; j < 私尤薄集.Length; j++)
			{
				GameObject gameObject2 = 私尤薄集[j].gameObject;
				if ((bool)gameObject2)
				{
					gameObject2.transform.localScale -= new Vector3(0f, 0f, 公系);
				}
			}
		}
		else if ((bool)该)
		{
			该.transform.localScale -= new Vector3(0f, 0f, 公系);
		}
	}

	public void 肥(string 串参 = "")
	{
		if (佑.逮.公尤阵选.Count > 1)
		{
			for (int i = 0; i < 佑.逮.公尤阵选.Count; i++)
			{
				GameObject gameObject = 佑.逮.公尤阵选[i].gameObject;
				if ((bool)gameObject)
				{
					gameObject.transform.localScale += new Vector3(公系, 公系, 0f);
				}
			}
		}
		else if (私尤肥集 != null && 公签 != "" && 私尤肥集.Length != 0)
		{
			MonoBehaviour.print("----------肥----------");
			for (int j = 0; j < 私尤肥集.Length; j++)
			{
				GameObject gameObject2 = 私尤肥集[j].gameObject;
				if ((bool)gameObject2)
				{
					gameObject2.transform.localScale += new Vector3(公系, 公系, 0f);
				}
			}
		}
		else if ((bool)该)
		{
			该.transform.localScale += new Vector3(公系, 公系, 0f);
		}
	}

	public void 腻(string 串参 = "")
	{
		if (佑.逮.公尤阵选.Count > 1)
		{
			for (int i = 0; i < 佑.逮.公尤阵选.Count; i++)
			{
				GameObject gameObject = 佑.逮.公尤阵选[i].gameObject;
				if ((bool)gameObject)
				{
					gameObject.transform.localScale -= new Vector3(公系, 公系, 0f);
				}
			}
		}
		else if (私尤腻集 != null && 公签 != "" && 私尤腻集.Length != 0)
		{
			MonoBehaviour.print("---------腻-----------");
			for (int j = 0; j < 私尤腻集.Length; j++)
			{
				GameObject gameObject2 = 私尤腻集[j].gameObject;
				if ((bool)gameObject2)
				{
					gameObject2.transform.localScale -= new Vector3(公系, 公系, 0f);
				}
			}
		}
		else if ((bool)该)
		{
			该.transform.localScale -= new Vector3(公系, 公系, 0f);
		}
	}

	public void 胖(string 串参 = "")
	{
		if (佑.逮.公尤阵选.Count > 1)
		{
			for (int i = 0; i < 佑.逮.公尤阵选.Count; i++)
			{
				GameObject gameObject = 佑.逮.公尤阵选[i].gameObject;
				if ((bool)gameObject)
				{
					gameObject.transform.localScale += new Vector3(公系, 0f, 公系);
				}
			}
		}
		else if (私尤胖集 != null && 公签 != "" && 私尤胖集.Length != 0)
		{
			MonoBehaviour.print("---------胖-----------");
			for (int j = 0; j < 私尤胖集.Length; j++)
			{
				GameObject gameObject2 = 私尤胖集[j].gameObject;
				if ((bool)gameObject2)
				{
					gameObject2.transform.localScale += new Vector3(公系, 0f, 公系);
				}
			}
		}
		else if ((bool)该)
		{
			该.transform.localScale += new Vector3(公系, 0f, 公系);
		}
	}

	public void 瘦(string 串参 = "")
	{
		if (佑.逮.公尤阵选.Count > 1)
		{
			for (int i = 0; i < 佑.逮.公尤阵选.Count; i++)
			{
				GameObject gameObject = 佑.逮.公尤阵选[i].gameObject;
				if ((bool)gameObject)
				{
					gameObject.transform.localScale -= new Vector3(公系, 0f, 公系);
				}
			}
		}
		else if (私尤瘦集 != null && 公签 != "" && 私尤瘦集.Length != 0)
		{
			MonoBehaviour.print("---------瘦-----------");
			for (int j = 0; j < 私尤瘦集.Length; j++)
			{
				GameObject gameObject2 = 私尤瘦集[j].gameObject;
				if ((bool)gameObject2)
				{
					gameObject2.transform.localScale -= new Vector3(公系, 0f, 公系);
				}
			}
		}
		else if ((bool)该)
		{
			该.transform.localScale -= new Vector3(公系, 0f, 公系);
		}
	}

	public void 挺(string 串参 = "")
	{
		if (佑.逮.公尤阵选.Count > 1)
		{
			for (int i = 0; i < 佑.逮.公尤阵选.Count; i++)
			{
				GameObject gameObject = 佑.逮.公尤阵选[i].gameObject;
				if ((bool)gameObject)
				{
					gameObject.transform.localScale += new Vector3(0f, 公系, 公系);
				}
			}
		}
		else if (私尤挺集 != null && 公签 != "" && 私尤挺集.Length != 0)
		{
			MonoBehaviour.print("----------挺----------");
			for (int j = 0; j < 私尤挺集.Length; j++)
			{
				GameObject gameObject2 = 私尤挺集[j].gameObject;
				if ((bool)gameObject2)
				{
					gameObject2.transform.localScale += new Vector3(0f, 公系, 公系);
				}
			}
		}
		else if ((bool)该)
		{
			该.transform.localScale += new Vector3(0f, 公系, 公系);
		}
	}

	public void 扁(string 串参 = "")
	{
		if (佑.逮.公尤阵选.Count > 1)
		{
			for (int i = 0; i < 佑.逮.公尤阵选.Count; i++)
			{
				GameObject gameObject = 佑.逮.公尤阵选[i].gameObject;
				if ((bool)gameObject)
				{
					gameObject.transform.localScale -= new Vector3(0f, 公系, 公系);
				}
			}
		}
		else if (私尤扁集 != null && 公签 != "" && 私尤扁集.Length != 0)
		{
			MonoBehaviour.print("---------扁-----------");
			for (int j = 0; j < 私尤扁集.Length; j++)
			{
				GameObject gameObject2 = 私尤扁集[j].gameObject;
				if ((bool)gameObject2)
				{
					gameObject2.transform.localScale -= new Vector3(0f, 公系, 公系);
				}
			}
		}
		else if ((bool)该)
		{
			该.transform.localScale -= new Vector3(0f, 公系, 公系);
		}
	}

	public void 放(string 串参 = "")
	{
		if (佑.逮.公尤阵选.Count > 1)
		{
			for (int i = 0; i < 佑.逮.公尤阵选.Count; i++)
			{
				GameObject gameObject = 佑.逮.公尤阵选[i].gameObject;
				if ((bool)gameObject)
				{
					gameObject.transform.localScale += new Vector3(公系, 公系, 公系);
				}
			}
		}
		else if (私尤放集 != null && 公签 != "" && 私尤放集.Length != 0)
		{
			MonoBehaviour.print("-----------放---------");
			for (int j = 0; j < 私尤放集.Length; j++)
			{
				GameObject gameObject2 = 私尤放集[j].gameObject;
				if ((bool)gameObject2)
				{
					gameObject2.transform.localScale += new Vector3(公系, 公系, 公系);
				}
			}
		}
		else if ((bool)该)
		{
			该.transform.localScale += new Vector3(公系, 公系, 公系);
		}
	}

	public void 缩(string 串参 = "")
	{
		if (佑.逮.公尤阵选.Count > 1)
		{
			for (int i = 0; i < 佑.逮.公尤阵选.Count; i++)
			{
				GameObject gameObject = 佑.逮.公尤阵选[i].gameObject;
				if ((bool)gameObject)
				{
					gameObject.transform.localScale -= new Vector3(公系, 公系, 公系);
				}
			}
		}
		else if (私尤缩集 != null && 公签 != "" && 私尤缩集.Length != 0)
		{
			MonoBehaviour.print("----------缩----------");
			for (int j = 0; j < 私尤缩集.Length; j++)
			{
				GameObject gameObject2 = 私尤缩集[j].gameObject;
				if ((bool)gameObject2)
				{
					gameObject2.transform.localScale -= new Vector3(公系, 公系, 公系);
				}
			}
		}
		else if ((bool)该)
		{
			该.transform.localScale -= new Vector3(公系, 公系, 公系);
		}
	}

	public void 搬(string 串参 = "")
	{
		佑.逮.置态("搬");
	}

	public void 摆(string 串参 = "")
	{
		佑.逮.改造啥(造啥);
		佑.逮.置态("摆");
	}

	public void 搁(string 串参 = "")
	{
		佑.逮.改造啥(造啥);
		佑.逮.置态("搁");
		TeleportController.逮.搁哪();
	}

	public void 喷(string 串参 = "")
	{
		佑.逮.改造啥(造啥);
		佑.逮.置态("喷");
	}

	public void 合(string 串参 = "")
	{
	}

	public void 离(string 串参 = "")
	{
		佑.逮.主锁无();
	}

	public void 柄(string 串参 = "")
	{
	}

	public void 脑(string 串参 = "")
	{
	}

	public void 语(string 串参 = "")
	{
	}

	public void 言(string 串参 = "")
	{
	}

	public void 擒(string 串参)
	{
	}

	[Obsolete]
	public void 拿(string 串参)
	{
		AssetBundle assetBundle = AssetBundle.LoadFromFile(Path.Combine(UnityEngine.Application.streamingAssetsPath + "/" + 逮.址() + "/", 串参));
		if (assetBundle == null)
		{
			UnityEngine.Debug.Log("未能加载AssetBundle！");
			return;
		}
		string text = 令(串参 + ".fbx");
		GameObject obj = UnityEngine.Object.Instantiate(assetBundle.LoadAsset<GameObject>(text));
		GameObject gameObject = GameObject.Find("/=造/-组啥/组广");
		obj.transform.SetParent(gameObject.transform, worldPositionStays: false);
		GameObject gameObject2 = GameObject.Find("/XR Origin/Camera Offset/RightHand Controller/枝轴点/");
		gameObject.transform.position = gameObject2.transform.position;
	}

	public string 址()
	{
		string result = "";
		switch (UnityEngine.Application.platform)
		{
		case RuntimePlatform.OSXEditor:
			result = "2048";
			break;
		case RuntimePlatform.WindowsEditor:
			result = "2048";
			break;
		case RuntimePlatform.Android:
			result = "2047";
			break;
		case RuntimePlatform.IPhonePlayer:
			result = "2048";
			break;
		case RuntimePlatform.WebGLPlayer:
			result = "2048";
			break;
		case RuntimePlatform.WindowsPlayer:
			result = "2048";
			break;
		}
		return result;
	}

	public string 令(string 串参)
	{
		return 串参.Substring(0, 1);
	}

	public void 光(string 串参 = "")
	{
		MonoBehaviour.print(公平行光.GetComponent<Light>().intensity);
		if (公平行光.GetComponent<Light>().intensity != 0f)
		{
			公平行光.GetComponent<Light>().intensity = 1f;
		}
		else
		{
			公平行光.GetComponent<Light>().intensity = 0f;
		}
	}

	public void 灯(string 串参 = "")
	{
		GameObject obj = new GameObject("Point light");
		obj.AddComponent<Light>();
		obj.GetComponent<Light>().type = LightType.Point;
	}

	public void 聚(string 串参 = "")
	{
		GameObject obj = new GameObject("Spotlight");
		obj.AddComponent<Light>();
		obj.GetComponent<Light>().type = LightType.Spot;
	}

	public void 阳(string 串参 = "")
	{
		GameObject gameObject = GameObject.Find("/=光/-阳/阳");
		该 = gameObject;
	}

	public void 添阳(string 串参 = "")
	{
		GameObject obj = new GameObject("Directional Light");
		obj.AddComponent<Light>();
		obj.GetComponent<Light>().type = LightType.Directional;
	}

	public void 耀(string 串参 = "")
	{
		GameObject obj = new GameObject("Area Light");
		obj.AddComponent<Light>();
		obj.GetComponent<Light>().type = LightType.Area;
	}

	public void 反应探头(string 参数)
	{
		new GameObject("Reflection Probe").AddComponent<ReflectionProbe>();
	}

	public void 光探测组(string 参数)
	{
		new GameObject("Light Probe Group").AddComponent<LightProbeGroup>();
	}

	public void 顾(string 串参 = "")
	{
		子弹方向.transform.localPosition = new Vector3(0f, 0f, 1f);
	}

	public void 远(string 串参 = "")
	{
		子弹方向.transform.localPosition += new Vector3(0f, 0f, 公系);
	}

	public void 近(string 串参 = "")
	{
		子弹方向.transform.localPosition -= new Vector3(0f, 0f, 公系);
	}

	public void 家(string 串参 = "")
	{
		SceneManager.LoadSceneAsync("虚家");
	}

	public void 去(string 串参 = "")
	{
		if ((bool)该)
		{
			该.transform.localPosition += new Vector3(公系, 0f, 0f);
		}
	}

	public void 来(string 串参 = "")
	{
		if ((bool)该)
		{
			该.transform.localPosition += new Vector3(公系, 0f, 0f);
		}
	}

	public void 翻(string 串参 = "")
	{
		if ((bool)该)
		{
			该.transform.localPosition += new Vector3(公系, 0f, 0f);
		}
	}

	public void 方(string 串参 = "")
	{
		造啥 = "方";
		佑.逮.改造啥(造啥);
		if (公态 != "造" || 公态 != "摆" || 公态 != "喷")
		{
			佑.逮.置态("造");
		}
	}

	public void 球(string 串参 = "")
	{
		造啥 = "球";
		佑.逮.改造啥(造啥);
		if (公态 != "造" || 公态 != "摆" || 公态 != "喷")
		{
			佑.逮.置态("造");
		}
	}

	public void 胶(string 串参 = "")
	{
		造啥 = "胶";
		佑.逮.改造啥(造啥);
		if (公态 != "造" || 公态 != "摆" || 公态 != "喷")
		{
			佑.逮.置态("造");
		}
	}

	public void 柱(string 串参 = "")
	{
		造啥 = "柱";
		佑.逮.改造啥(造啥);
		if (公态 != "造" || 公态 != "摆" || 公态 != "喷")
		{
			佑.逮.置态("造");
		}
	}

	public void 锥(string 串参 = "")
	{
		造啥 = "锥";
		佑.逮.改造啥(造啥);
		if (公态 != "造" || 公态 != "摆" || 公态 != "喷")
		{
			佑.逮.置态("造");
		}
	}

	public void 骰(string 串参 = "")
	{
		造啥 = "骰";
		佑.逮.改造啥(造啥);
		if (公态 != "造" || 公态 != "摆" || 公态 != "喷")
		{
			佑.逮.置态("造");
		}
	}

	public void 圈(string 串参 = "")
	{
		造啥 = "圈";
		佑.逮.改造啥(造啥);
		if (公态 != "造" || 公态 != "摆" || 公态 != "喷")
		{
			佑.逮.置态("造");
		}
	}

	public void 钻(string 串参 = "")
	{
		造啥 = "钻";
		佑.逮.改造啥(造啥);
		if (公态 != "造" || 公态 != "摆" || 公态 != "喷")
		{
			佑.逮.置态("造");
		}
	}

	public void 盒(string 串参 = "")
	{
		造啥 = "盒";
		佑.逮.改造啥(造啥);
		if (公态 != "造" || 公态 != "摆" || 公态 != "喷")
		{
			佑.逮.置态("造");
		}
	}

	public void 珠(string 串参 = "")
	{
		造啥 = "珠";
		佑.逮.改造啥(造啥);
		if (公态 != "造" || 公态 != "摆" || 公态 != "喷")
		{
			佑.逮.置态("造");
		}
	}

	public void 囊(string 串参 = "")
	{
		造啥 = "囊";
		佑.逮.改造啥(造啥);
		if (公态 != "造" || 公态 != "摆" || 公态 != "喷")
		{
			佑.逮.置态("造");
		}
	}

	public void 棍(string 串参 = "")
	{
		造啥 = "棍";
		佑.逮.改造啥(造啥);
		if (公态 != "造" || 公态 != "摆" || 公态 != "喷")
		{
			佑.逮.置态("造");
		}
	}

	public void 丸(string 串参 = "")
	{
		造啥 = "丸";
		佑.逮.改造啥(造啥);
		if (公态 != "造" || 公态 != "摆" || 公态 != "喷")
		{
			佑.逮.置态("造");
		}
	}

	public void 心(string 串参 = "")
	{
		造啥 = "心";
		佑.逮.改造啥(造啥);
		if (公态 != "造" || 公态 != "摆" || 公态 != "喷")
		{
			佑.逮.置态("造");
		}
	}

	public void 坡(string 串参 = "")
	{
		造啥 = "坡";
		佑.逮.改造啥(造啥);
		if (公态 != "造" || 公态 != "摆" || 公态 != "喷")
		{
			佑.逮.置态("造");
		}
	}

	public void 环(string 串参 = "")
	{
		造啥 = "环";
		佑.逮.改造啥(造啥);
		if (公态 != "造" || 公态 != "摆" || 公态 != "喷")
		{
			佑.逮.置态("造");
		}
	}

	public void 星(string 串参 = "")
	{
		造啥 = "星";
		佑.逮.改造啥(造啥);
		if (公态 != "造" || 公态 != "摆" || 公态 != "喷")
		{
			佑.逮.置态("造");
		}
	}

	public void 惺(string 串参 = "")
	{
		造啥 = "惺";
		佑.逮.改造啥(造啥);
		if (公态 != "造" || 公态 != "摆" || 公态 != "喷")
		{
			佑.逮.置态("造");
		}
	}

	public void 卷(string 串参 = "")
	{
		造啥 = "卷";
		佑.逮.改造啥(造啥);
		if (公态 != "造" || 公态 != "摆" || 公态 != "喷")
		{
			佑.逮.置态("造");
		}
	}

	public void 棱(string 串参 = "")
	{
		造啥 = "棱";
		佑.逮.改造啥(造啥);
		if (公态 != "造" || 公态 != "摆" || 公态 != "喷")
		{
			佑.逮.置态("造");
		}
	}

	public void 遛(string 串参 = "")
	{
		造啥 = "遛";
		佑.逮.改造啥(造啥);
		if (公态 != "造" || 公态 != "摆" || 公态 != "喷")
		{
			佑.逮.置态("造");
		}
	}

	public void 楔(string 串参 = "")
	{
		造啥 = "楔";
		佑.逮.改造啥(造啥);
		if (公态 != "造" || 公态 != "摆" || 公态 != "喷")
		{
			佑.逮.置态("造");
		}
	}

	public void 塔(string 串参 = "")
	{
		造啥 = "塔";
		佑.逮.改造啥(造啥);
		if (公态 != "造" || 公态 != "摆" || 公态 != "喷")
		{
			佑.逮.置态("造");
		}
	}

	public void 苍(string 串参 = "")
	{
		造啥 = "苍";
		佑.逮.改造啥(造啥);
		if (公态 != "造" || 公态 != "摆" || 公态 != "喷")
		{
			佑.逮.置态("造");
		}
	}

	public void 壶(string 串参 = "")
	{
		造啥 = "壶";
		佑.逮.改造啥(造啥);
		if (公态 != "造" || 公态 != "摆" || 公态 != "喷")
		{
			佑.逮.置态("造");
		}
	}

	public void 梯(string 串参 = "")
	{
		造啥 = "梯";
		佑.逮.改造啥(造啥);
		if (公态 != "造" || 公态 != "摆" || 公态 != "喷")
		{
			佑.逮.置态("造");
		}
	}

	public void 剑(string 串参 = "")
	{
		造啥 = "剑";
		佑.逮.改造啥(造啥);
		if (公态 != "造" || 公态 != "摆" || 公态 != "喷")
		{
			佑.逮.置态("造");
		}
	}

	public void 刀(string 串参 = "")
	{
		造啥 = "刀";
		佑.逮.改造啥(造啥);
		if (公态 != "造" || 公态 != "摆" || 公态 != "喷")
		{
			佑.逮.置态("造");
		}
	}

	public void 院(string 串参 = "")
	{
	}

	public void 愣(string 串参 = "")
	{
	}

	public void 红(string 串参 = "")
	{
		纹理.逮.材("红");
	}

	public void 橙(string 串参 = "")
	{
		纹理.逮.材("橙");
	}

	public void 黄(string 串参 = "")
	{
		纹理.逮.材("黄");
	}

	public void 绿(string 串参 = "")
	{
		纹理.逮.材("绿");
	}

	public void 青(string 串参 = "")
	{
		纹理.逮.材("青");
	}

	public void 靛(string 串参 = "")
	{
		纹理.逮.材("靛");
	}

	public void 蓝(string 串参 = "")
	{
		纹理.逮.材("蓝");
	}

	public void 紫(string 串参 = "")
	{
		纹理.逮.材("紫");
	}

	public void 黑(string 串参 = "")
	{
		纹理.逮.材("黑");
	}

	public void 白(string 串参 = "")
	{
		纹理.逮.材("白");
	}

	public void 灰(string 串参 = "")
	{
		纹理.逮.材("灰");
	}

	public void 乌(string 串参 = "")
	{
		纹理.逮.材("乌");
	}

	public void 粉(string 串参 = "")
	{
		纹理.逮.材("粉");
	}

	public void 翠(string 串参 = "")
	{
		纹理.逮.材("翠");
	}

	public void 碧(string 串参 = "")
	{
		纹理.逮.材("碧");
	}

	public void 棕(string 串参 = "")
	{
		纹理.逮.材("棕");
	}

	public void 朱(string 串参 = "")
	{
		纹理.逮.材("朱");
	}

	public void 赤(string 串参 = "")
	{
		纹理.逮.材("赤");
	}

	public void 褐(string 串参 = "")
	{
		纹理.逮.材("褐");
	}

	public void 金(string 串参 = "")
	{
		纹理.逮.材("金");
	}

	public void 铁(string 串参 = "")
	{
		纹理.逮.材("铁");
	}

	public void 木(string 串参 = "")
	{
		纹理.逮.材("木");
	}

	public void 砖(string 串参 = "")
	{
		纹理.逮.材("砖");
	}

	public void 瓷(string 串参 = "")
	{
		纹理.逮.材("瓷");
	}

	public void 瓦(string 串参 = "")
	{
		纹理.逮.材("瓦");
	}

	public void 玻(string 串参 = "")
	{
		纹理.逮.材("玻");
	}

	public void 璃(string 串参 = "")
	{
		纹理.逮.材("璃");
	}

	public void 银(string 串参 = "")
	{
		纹理.逮.材("银");
	}

	public void 铜(string 串参 = "")
	{
		纹理.逮.材("铜");
	}

	public void 板(string 串参 = "")
	{
		纹理.逮.材("板");
	}

	public void 皮(string 串参 = "")
	{
		纹理.逮.材("皮");
	}

	public void 革(string 串参 = "")
	{
		纹理.逮.材("革");
	}

	public void 凝(string 串参 = "")
	{
		纹理.逮.材("凝");
	}

	public void 土(string 串参 = "")
	{
		纹理.逮.材("土");
	}

	public void 山(string 串参 = "")
	{
		纹理.逮.材("山");
	}

	public void 石(string 串参 = "")
	{
		纹理.逮.材("石");
	}

	public void 岩(string 串参 = "")
	{
		纹理.逮.材("岩");
	}

	public void 泥(string 串参 = "")
	{
		纹理.逮.材("泥");
	}

	public void 塑(string 串参 = "")
	{
		纹理.逮.材("塑");
	}

	public void 毁(string 串参 = "")
	{
		UnityEngine.Object.Destroy(该);
	}

	public void 删(string 串参 = "")
	{
		振();
		if (佑.逮.公尤阵选.Count > 1)
		{
			for (int i = 0; i < 佑.逮.公尤阵选.Count; i++)
			{
				MonoBehaviour.print("删");
				GameObject gameObject = 佑.逮.公尤阵选[i].gameObject;
				if ((bool)gameObject)
				{
					UnityEngine.Object.Destroy(gameObject);
				}
			}
		}
		else
		{
			佑.逮.改造啥("删");
			佑.逮.置态("删");
		}
	}

	public void 飞(string 串参 = "")
	{
	}

	public void 闪(string 串参 = "")
	{
	}

	public void 走(string 串参 = "")
	{
	}

	public void 图(string 串参 = "")
	{
	}

	public void 销毁魔方(string 串参 = "")
	{
		魔方.SetActive(value: false);
	}

	public void 消(string 串参 = "")
	{
		StartCoroutine("恢复");
	}

	public IEnumerator 恢复()
	{
		yield return null;
		foreach (GameObject item in 佑.逮.公尤阵选)
		{
			if (佑.逮.公队.Count > 0)
			{
				Material material = 佑.逮.公队.Dequeue();
				if ((bool)item)
				{
					item.GetComponentInChildren<MeshRenderer>().material = material;
				}
			}
		}
		佑.逮.公尤阵选.Clear();
	}

	public void 隆(string 串参 = "")
	{
		float x = 该.transform.localPosition.x;
		float y = 该.transform.localPosition.y + 该.transform.localScale.y * 0.1f;
		float z = 该.transform.localPosition.z;
		GameObject gameObject = UnityEngine.Object.Instantiate(逮.该, new Vector3(x, y, z), 逮.该.transform.localRotation);
		string text = 逮.该.name.Substring(0, 1);
		GameObject gameObject2 = GameObject.Find("/=造/-组啥/组" + text);
		gameObject.transform.SetParent(gameObject2.transform);
		gameObject.name = text + gameObject2.transform.childCount;
		该 = gameObject;
	}

	public void 仿(string 串参 = "")
	{
		佑.逮.它.transform.localRotation = 该.transform.localRotation;
		佑.逮.它.transform.localScale = 该.transform.localScale;
	}

	public void 亮(string 串参 = "")
	{
		公平行光.GetComponent<Light>().intensity += 0.1f;
	}

	public void 阴(string 串参 = "")
	{
		公平行光.GetComponent<Light>().intensity = 1f;
	}

	public void 暗(string 串参 = "")
	{
		公平行光.GetComponent<Light>().intensity -= 0.1f;
	}

	public void 廓(string 串参 = "")
	{
		该.AddComponent<Outline>();
	}

	public void 色(string 串参 = "")
	{
		ColorUtility.TryParseHtmlString(串参, out var color);
		该.GetComponentInChildren<MeshRenderer>().material.color = color;
	}

	public void 钟(string 串参 = "")
	{
		公告.text = 类脑.取时间();
	}

	public void 刚(string 串参 = "")
	{
		if (佑.逮.公尤阵选.Count > 1)
		{
			for (int i = 0; i < 佑.逮.公尤阵选.Count; i++)
			{
				GameObject obj = 佑.逮.公尤阵选[i].gameObject;
				obj.AddComponent<Rigidbody>();
				obj.GetComponent<Rigidbody>().useGravity = true;
			}
		}
		else if (!该.GetComponent<Rigidbody>())
		{
			该.AddComponent<Rigidbody>();
			该.GetComponent<Rigidbody>().useGravity = true;
		}
	}

	public void 冈(string 串参 = "")
	{
		if (佑.逮.公尤阵选.Count > 1)
		{
			for (int i = 0; i < 佑.逮.公尤阵选.Count; i++)
			{
				UnityEngine.Object.Destroy(佑.逮.公尤阵选[i].gameObject.GetComponent<Rigidbody>());
			}
		}
		else
		{
			UnityEngine.Object.Destroy(该.GetComponent<Rigidbody>());
		}
	}

	public void 岗(string 串参 = "")
	{
		BoxCollider boxCollider = 该.AddComponent<BoxCollider>();
		boxCollider.isTrigger = true;
		boxCollider.size = new Vector2(0.1f, 0.1f);
	}

	public void 碰(string 串参 = "")
	{
		该.AddComponent<BoxCollider>();
	}

	public void 宝(string 串参 = "")
	{
		if (该.GetComponent<Rigidbody>() == null)
		{
			该.AddComponent<Rigidbody>();
			该.GetComponent<Rigidbody>().useGravity = true;
		}
		该.AddComponent<BoxCollider>();
	}

	public void 贝(string 串参 = "")
	{
		UnityEngine.Object.Destroy(该.GetComponent<Rigidbody>());
		UnityEngine.Object.Destroy(该.GetComponent<BoxCollider>());
	}

	public void 当吕北改(float 浮参)
	{
		GameObject obj = GameObject.Find("/=虚/-单字");
		公告.text = 浮参.ToString();
		obj.transform.localScale = new Vector3(浮参, 浮参, 浮参);
	}

	public void 摊(string 串参 = "")
	{
		if ((bool)该)
		{
			该.transform.localPosition = new Vector3(该.transform.localPosition.x, 0f, 该.transform.localPosition.y);
		}
	}

	public void 天(string 串参 = "")
	{
		if ((bool)该)
		{
			该.transform.localPosition = new Vector3(该.transform.localPosition.x, 3f, 该.transform.localPosition.z);
		}
	}

	public void 地(string 串参 = "")
	{
		if ((bool)该)
		{
			该.transform.localPosition = new Vector3(该.transform.localPosition.x, 0f, 该.transform.localPosition.z);
		}
	}

	public void 桌(string 串参 = "")
	{
		if ((bool)该)
		{
			该.transform.localPosition = new Vector3(该.transform.localPosition.x, 0.8f, 该.transform.localPosition.z);
		}
	}

	public void 椅(string 串参 = "")
	{
		if ((bool)该)
		{
			该.transform.localPosition = new Vector3(该.transform.localPosition.x, 0.4f, 该.transform.localPosition.z);
		}
	}

	public void 显(string 串参 = "")
	{
		if ((bool)该)
		{
			该.SetActive(value: true);
		}
	}

	public void 隐(string 串参 = "")
	{
		if ((bool)该)
		{
			该.SetActive(value: false);
		}
	}

	public void 墙(string 串参 = "")
	{
		GameObject gameObject = GameObject.Find("/=座/-墙/院东");
		GameObject gameObject2 = GameObject.Find("/=座/-墙/院南");
		GameObject gameObject3 = GameObject.Find("/=座/-墙/院西");
		GameObject obj = GameObject.Find("/=座/-墙/院北");
		GameObject gameObject4 = GameObject.Find("/=座/-墙/院穹");
		bool active = !obj.activeSelf;
		gameObject.SetActive(active);
		gameObject2.SetActive(active);
		gameObject3.SetActive(active);
		obj.SetActive(active);
		gameObject4.SetActive(active);
	}

	public void 墙显(string 串参 = "")
	{
		GameObject gameObject = GameObject.Find("/=座/-墙/院东");
		GameObject gameObject2 = GameObject.Find("/=座/-墙/院南");
		GameObject gameObject3 = GameObject.Find("/=座/-墙/院西");
		GameObject gameObject4 = GameObject.Find("/=座/-墙/院北");
		GameObject obj = GameObject.Find("/=座/-墙/院穹");
		gameObject.SetActive(value: true);
		gameObject2.SetActive(value: true);
		gameObject3.SetActive(value: true);
		gameObject4.SetActive(value: true);
		obj.SetActive(value: true);
	}

	public void 墙隐(string 串参 = "")
	{
		GameObject gameObject = GameObject.Find("/=座/-墙/院东");
		GameObject gameObject2 = GameObject.Find("/=座/-墙/院南");
		GameObject gameObject3 = GameObject.Find("/=座/-墙/院西");
		GameObject gameObject4 = GameObject.Find("/=座/-墙/院北");
		GameObject obj = GameObject.Find("/=座/-墙/院穹");
		gameObject.SetActive(value: false);
		gameObject2.SetActive(value: false);
		gameObject3.SetActive(value: false);
		gameObject4.SetActive(value: false);
		obj.SetActive(value: false);
	}

	public void 涯(string 串参 = "")
	{
		GameObject obj = GameObject.Find("/=座/-墙/院东");
		GameObject gameObject = GameObject.Find("/=座/-墙/院南");
		GameObject gameObject2 = GameObject.Find("/=座/-墙/院西");
		GameObject gameObject3 = GameObject.Find("/=座/-墙/院北");
		GameObject gameObject4 = GameObject.Find("/=座/-墙/院穹");
		obj.transform.localPosition = new Vector3(12.5f, 12.5f, 0f);
		gameObject.transform.localPosition = new Vector3(0f, 12.5f, -12.5f);
		gameObject2.transform.localPosition = new Vector3(-12.5f, 12.5f, 0f);
		gameObject3.transform.localPosition = new Vector3(0f, 12.5f, 12.5f);
		gameObject4.transform.localPosition = new Vector3(0f, 25f, 0f);
		obj.transform.localRotation = Quaternion.Euler(0f, 90f, 0f);
		gameObject.transform.localRotation = Quaternion.Euler(0f, 180f, 0f);
		gameObject2.transform.localRotation = Quaternion.Euler(0f, 270f, 0f);
		gameObject3.transform.localRotation = Quaternion.Euler(0f, 0f, 0f);
		gameObject4.transform.localRotation = Quaternion.Euler(0f, 270f, 0f);
		obj.transform.localScale = new Vector3(25f, 25f, 1f);
		gameObject.transform.localScale = new Vector3(25f, 25f, 1f);
		gameObject2.transform.localScale = new Vector3(25f, 25f, 1f);
		gameObject3.transform.localScale = new Vector3(25f, 25f, 1f);
		gameObject4.transform.localScale = new Vector3(25f, 25f, 1f);
	}

	public void 东(string 串参 = "")
	{
		GameObject gameObject = GameObject.Find("/=座/-墙/院东");
		gameObject.SetActive(!gameObject.activeSelf);
		逮.该 = gameObject;
	}

	public void 南(string 串参 = "")
	{
		GameObject gameObject = GameObject.Find("/=座/-墙/院南");
		gameObject.SetActive(!gameObject.activeSelf);
		逮.该 = gameObject;
	}

	public void 西(string 串参 = "")
	{
		GameObject gameObject = GameObject.Find("/=座/-墙/院西");
		gameObject.SetActive(!gameObject.activeSelf);
		逮.该 = gameObject;
	}

	public void 北(string 串参 = "")
	{
		GameObject gameObject = GameObject.Find("/=座/-墙/院北");
		gameObject.SetActive(!gameObject.activeSelf);
		逮.该 = gameObject;
	}

	public void 芯(string 串参 = "")
	{
		GameObject gameObject = GameObject.Find("/=座/-墙/院芯");
		GameObject obj = GameObject.Find("/=座/-墙/院虚世");
		gameObject.SetActive(!gameObject.activeSelf);
		obj.SetActive(gameObject.activeSelf);
		逮.该 = gameObject;
	}

	public void 穹(string 串参 = "")
	{
		GameObject gameObject = GameObject.Find("/=座/-墙/院穹");
		gameObject.SetActive(!gameObject.activeSelf);
		逮.该 = gameObject;
	}

	public void 春(string 串参 = "")
	{
		Material material = Resources.Load("天空盒/春/春") as Material;
		if (!(material == null))
		{
			RenderSettings.skybox = material;
			DynamicGI.UpdateEnvironment();
		}
	}

	public void 夏(string 串参 = "")
	{
		Material material = Resources.Load("天空盒/夏/夏") as Material;
		if (!(material == null))
		{
			RenderSettings.skybox = material;
			DynamicGI.UpdateEnvironment();
		}
	}

	public void 秋(string 串参 = "")
	{
		RenderSettings.skybox = Resources.Load("天空盒/秋/秋") as Material;
		DynamicGI.UpdateEnvironment();
	}

	public void 冬(string 串参 = "")
	{
		Material material = Resources.Load("天空盒/冬/冬") as Material;
		if (!(material == null))
		{
			RenderSettings.skybox = material;
			DynamicGI.UpdateEnvironment();
		}
	}

	public void 遍(string 串参 = "")
	{
		if (该.transform.childCount > 0)
		{
			for (int i = 0; i < 该.transform.childCount; i++)
			{
				_ = 该.transform.GetChild(i).gameObject;
			}
		}
	}

	protected void 生典(string 串参)
	{
		string[] array = Regex.Split(串参, "\\r\\n|\\n");
		公典帮.Clear();
		string[] array2 = array;
		for (int i = 0; i < array2.Length; i++)
		{
			string text = array2[i].ToString();
			if (!(text.Trim() == ""))
			{
				string key = text.Substring(1, 1);
				string value = text.Substring(3);
				公典帮.Add(key, value);
			}
		}
	}

	public Vector3 位不重叠(Vector3 仨参)
	{
		float x = 仨参.x;
		float y = 仨参.y;
		float z = 仨参.z;
		int layerMask = 256;
		float radius = 0.0495f;
		尤碰撞物 = Physics.OverlapSphere(new Vector3(x + 0.05f, y + 0.05f, z - 0.05f), radius, layerMask);
		if (尤碰撞物.Length != 0)
		{
			y += 0.1f;
			return new Vector3(x, y, z);
		}
		return new Vector3(x, y, z);
	}

	public Vector3 位撞(Collision collision)
	{
		ContactPoint contactPoint = collision.contacts[0];
		Quaternion.FromToRotation(Vector3.up, contactPoint.normal);
		return contactPoint.point;
	}

	public float 改横(float a)
	{
		float num = a * (float)几倍;
		float num2 = Mathf.Round(num);
		if (num < num2 && num2 % (float)几余 != 0f)
		{
			num2 -= 1f;
			return num2 / (float)几倍;
		}
		if (num < num2 && num2 % (float)几余 == 0f)
		{
			return num2 / (float)几倍;
		}
		if (num > num2 && num2 % (float)几余 != 0f)
		{
			num2 += 1f;
			return num2 / (float)几倍;
		}
		if (num > num2 && num2 % (float)几余 == 0f)
		{
			return num2 / (float)几倍;
		}
		return 0f;
	}

	public float 改纵(float a)
	{
		float num = a * (float)几倍;
		float num2 = Mathf.Round(num);
		if (num < num2 && num2 % (float)几余 != 0f)
		{
			num2 -= 1f;
			return num2 / (float)几倍;
		}
		if (num < num2 && num2 % (float)几余 == 0f)
		{
			return num2 / (float)几倍;
		}
		if (num > num2 && num2 % (float)几余 != 0f)
		{
			num2 += 1f;
			return num2 / (float)几倍;
		}
		if (num > num2 && num2 % (float)几余 == 0f)
		{
			return num2 / (float)几倍;
		}
		return 0f;
	}

	public float 改深(float a)
	{
		float num = a * (float)几倍;
		float num2 = Mathf.Round(num);
		if (num < num2 && num2 % (float)几余 != 0f)
		{
			num2 -= 1f;
			return num2 / (float)几倍;
		}
		if (num < num2 && num2 % (float)几余 == 0f)
		{
			return num2 / (float)几倍;
		}
		if (num > num2 && num2 % (float)几余 != 0f)
		{
			num2 += 1f;
			return num2 / (float)几倍;
		}
		if (num > num2 && num2 % (float)几余 == 0f)
		{
			return num2 / (float)几倍;
		}
		return 0f;
	}

	public void 保存数据()
	{
		MonoBehaviour.print("---------------------------保存数据():" + 公据);
		new Dictionary<string, string>()["data"] = 公据;
		MonoBehaviour.print("保存的数据" + 公据);
	}

	public void Save(string Path, string 串信息参)
	{
		MonoBehaviour.print("---------------------------Save():" + 串信息参);
		StreamWriter streamWriter = new StreamWriter(new FileStream(Path ?? "", FileMode.Open));
		streamWriter.Write(串信息参);
		streamWriter.Close();
		streamWriter.Dispose();
	}

	public void 开始录音()
	{
		UnityEngine.Debug.Log("⒈开始录音");
		公讲.text = "请【执】行...";
		公韵.clip = Microphone.Start(Microphone.devices[0], loop: false, 10, 8000);
	}

	public void 结束录音()
	{
		if (Microphone.devices.Length != 0)
		{
			Microphone.End(Microphone.devices[0]);
		}
	}

	public void 处理录音()
	{
		公韵.Play();
		float[] array = new float[公韵.clip.samples];
		公韵.clip.GetData(array, 0);
		short[] array2 = new short[array.Length];
		byte[] array3 = new byte[array.Length * 2];
		int num = 32767;
		for (int i = 0; i < array.Length; i++)
		{
			array2[i] = (short)(array[i] * (float)num);
			_ = new byte[2];
			BitConverter.GetBytes(array2[i]).CopyTo(array3, i * 2);
		}
		StartCoroutine(公语.语音识别(array3));
	}

	public void 脑搁(string 串参 = "")
	{
		公尤丸 = Resources.Load("预制/" + 逮.造啥) as GameObject;
		GameObject gameObject = UnityEngine.Object.Instantiate(公尤丸, 子弹方向.transform.position, 佑.逮.它.transform.localRotation);
		GameObject gameObject2 = gameObject.transform.GetChild(0).gameObject;
		if (佑.逮.公队.Count > 0)
		{
			逮.消();
		}
		GameObject gameObject3 = 该;
		该 = gameObject2;
		刚();
		该 = gameObject3;
		gameObject2.AddComponent<BulletController>();
		gameObject.transform.localPosition = 公仨搁;
		string text = gameObject.name.Substring(0, 1);
		gameObject.transform.localScale = 佑.逮.它.transform.localScale;
		GameObject gameObject4 = GameObject.Find("/=造/-组啥/组" + text);
		gameObject.transform.SetParent(gameObject4.transform);
		该 = gameObject;
	}

	public void 脑喷(string 串参 = "")
	{
		公尤丸 = Resources.Load("预制/" + 逮.造啥) as GameObject;
		GameObject gameObject = UnityEngine.Object.Instantiate(公尤丸, 子弹方向.transform.position, 佑.逮.它.transform.localRotation);
		GameObject gameObject2 = gameObject.transform.GetChild(0).gameObject;
		if (佑.逮.公队.Count > 0)
		{
			逮.消();
		}
		GameObject gameObject3 = 该;
		该 = gameObject2;
		刚();
		该 = gameObject3;
		gameObject2.AddComponent<BulletController>();
		gameObject.GetComponentInChildren<BulletController>().AddForce(子弹方向.transform.forward * 公几力);
		string text = gameObject.name.Substring(0, 1);
		gameObject.transform.localScale = 佑.逮.它.transform.localScale;
		GameObject gameObject4 = GameObject.Find("/=造/-组啥/组" + text);
		gameObject.transform.SetParent(gameObject4.transform);
		该 = gameObject;
	}

	public void 析(string 串参 = "")
	{
		Regex regex = new Regex("\\r\\n");
		私串阵个 = regex.Split(串参);
		for (int i = 0; i < 私串阵个.Length; i++)
		{
			string text = 私串阵个[i].Trim();
			if (text.Trim() == "")
			{
				continue;
			}
			MatchCollection matchCollection = Regex.Matches(text, "([横纵深纠拧转宽高厚]\\-?[\\d\\.]+)|(材.)");
			私典.Clear();
			foreach (Match item in matchCollection)
			{
				string text2 = item.ToString();
				string key = text2.Substring(0, 1);
				string value = text2.Substring(1);
				私典.Add(key, value);
			}
			if (!私典.ContainsKey("横"))
			{
				continue;
			}
			float x = 析横(私典);
			float y = 析纵(私典);
			float z = 析深(私典);
			float x2 = 析纠(私典);
			float y2 = 析拧(私典);
			float z2 = 析转(私典);
			float x3 = 析宽(私典);
			float y3 = 析高(私典);
			float z3 = 析厚(私典);
			string text3 = 析材(私典);
			析签(私典);
			私串令 = text.Substring(0, 1);
			私串参 = text.Substring(1, 1);
			物体的坐标 = new Vector3(x, y, z);
			GameObject gameObject;
			if (私串令 == "造")
			{
				gameObject = UnityEngine.Object.Instantiate(Resources.Load("预制/" + 私串参) as GameObject, 物体的坐标, Quaternion.identity);
				gameObject.transform.localRotation = Quaternion.Euler(x2, y2, z2);
				gameObject.transform.localScale = new Vector3(x3, y3, z3);
				GameObject gameObject2 = GameObject.Find("/=造/-组啥/组" + 私串参);
				if (!gameObject2)
				{
					逮.枝("组" + 私串参, "/=造/-组啥");
					gameObject2 = GameObject.Find("/=造/-组啥/组" + 私串参);
				}
				gameObject.transform.SetParent(gameObject2.transform);
			}
			else if (私串令 == "广")
			{
				gameObject = UnityEngine.Object.Instantiate(GameObject.Find("/=虚/-单字/" + 私串参 + "(Clone)"), new Vector3(x, y, z), Quaternion.identity);
				gameObject.name = 私串参;
				gameObject.transform.localRotation = Quaternion.Euler(x2, y2, z2);
				gameObject.transform.localScale = new Vector3(x3, y3, z3);
				gameObject.layer = 8;
				gameObject.transform.localRotation = Quaternion.Euler(0f, 180f, 0f);
				GameObject gameObject3 = GameObject.Find("/=造/-组啥/组广");
				gameObject.transform.SetParent(gameObject3.transform);
				UnityEngine.Object.Destroy(gameObject.gameObject.GetComponent<射线>());
				UnityEngine.Object.Destroy(gameObject.gameObject.GetComponent<XRSimpleInteractable>());
			}
			else
			{
				gameObject = null;
				MonoBehaviour.print("非造非广，不应该来到这里");
			}
			该 = gameObject;
			Material[] materials = new Material[1] { Resources.Load("材质/" + text3) as Material };
			gameObject.GetComponentInChildren<MeshRenderer>().materials = materials;
		}
	}

	private float 析横(Dictionary<string, string> 典参)
	{
		string value = "";
		if (典参.TryGetValue("横", out value))
		{
			return float.Parse(value);
		}
		return 0f;
	}

	private float 析纵(Dictionary<string, string> 典参)
	{
		string value = "";
		if (典参.TryGetValue("纵", out value))
		{
			return float.Parse(value);
		}
		return 0f;
	}

	private float 析深(Dictionary<string, string> 典参)
	{
		string value = "";
		if (典参.TryGetValue("深", out value))
		{
			return float.Parse(value);
		}
		return 0f;
	}

	private float 析纠(Dictionary<string, string> 典参)
	{
		string value = "";
		if (典参.TryGetValue("纠", out value))
		{
			return float.Parse(value);
		}
		return 0f;
	}

	private float 析拧(Dictionary<string, string> 典参)
	{
		string value = "";
		if (典参.TryGetValue("拧", out value))
		{
			return float.Parse(value);
		}
		return 0f;
	}

	private float 析转(Dictionary<string, string> 典参)
	{
		string value = "";
		if (典参.TryGetValue("转", out value))
		{
			return float.Parse(value);
		}
		return 0f;
	}

	private float 析宽(Dictionary<string, string> 典参)
	{
		string value = "";
		if (典参.TryGetValue("宽", out value))
		{
			return float.Parse(value);
		}
		return 1f;
	}

	private float 析高(Dictionary<string, string> 典参)
	{
		string value = "";
		if (典参.TryGetValue("高", out value))
		{
			return float.Parse(value);
		}
		return 1f;
	}

	private float 析厚(Dictionary<string, string> 典参)
	{
		string value = "";
		if (典参.TryGetValue("厚", out value))
		{
			return float.Parse(value);
		}
		return 1f;
	}

	private string 析材(Dictionary<string, string> 典参)
	{
		string value = "";
		if (典参.TryGetValue("材", out value))
		{
			return value;
		}
		return "白";
	}

	private string 析签(Dictionary<string, string> 典参)
	{
		string value = "";
		if (典参.TryGetValue("签", out value))
		{
			return value;
		}
		return "";
	}

	public void 洗(string 串参 = "")
	{
		object[] array = GameObject.FindGameObjectsWithTag("Cube");
		array = array;
		for (int i = 0; i < array.Length; i++)
		{
			GameObject gameObject = (GameObject)array[i];
			if (gameObject != null)
			{
				gameObject.SetActive(value: false);
			}
		}
	}

	public void 脑佐(string 串参 = "")
	{
	}

	public void 脑佑(string 串参 = "")
	{
	}

	public void 振(string 串参 = "")
	{
		PXR_Input.SendHapticImpulse(PXR_Input.VibrateType.RightController, 0.5f, 500, 100);
	}

	public void 尤显(string 串参 = "")
	{
		string[] array = new Regex(",").Split(串参);
		for (int i = 0; i < array.Length; i++)
		{
			GameObject gameObject = GameObject.Find(array[i]).gameObject;
			if ((bool)gameObject)
			{
				gameObject.transform.localPosition += new Vector3(0f, 1000000f, 0f);
			}
		}
	}

	public void 尤隐(string 串参 = "")
	{
		string[] array = new Regex(",").Split(串参);
		for (int i = 0; i < array.Length; i++)
		{
			GameObject gameObject = GameObject.Find(array[i]).gameObject;
			if ((bool)gameObject)
			{
				gameObject.transform.localPosition -= new Vector3(0f, 1000000f, 0f);
			}
		}
	}

	public void 深加(string 串参 = "")
	{
		if (佑.逮.公为哪)
		{
			深();
		}
		if (佑.逮.公为那)
		{
			扭();
		}
		if (佑.逮.公为啊)
		{
			薄();
		}
	}

	public void 深减(string 串参 = "")
	{
		if (佑.逮.公为哪)
		{
			浅();
		}
		if (佑.逮.公为那)
		{
			拧();
		}
		if (佑.逮.公为啊)
		{
			厚();
		}
	}

	public void 透(string 串参 = "")
	{
		PXR_Boundary.EnableSeeThroughManual(value: true);
		GameObject.Find("/=布编程/-域");
		尤隐("/=布编程/-域,/=布编程/-帮助/帮,/=布讲告,/=布编程/-帮助/略");
		墙隐();
		GameObject gameObject = GameObject.Find("/=座/-墙/院芯");
		GameObject obj = GameObject.Find("/=座/-墙/院虚世");
		gameObject.SetActive(value: false);
		obj.SetActive(value: false);
		公为透 = true;
		虚乌();
		透天空盒();
	}

	public void 透天空盒(string 串参 = "")
	{
		RenderSettings.skybox = null;
		DynamicGI.UpdateEnvironment();
	}

	public void 封(string 串参 = "")
	{
		PXR_Boundary.EnableSeeThroughManual(value: false);
		GameObject.Find("/=布编程/-域");
		尤显("/=布编程/-域,/=布编程/-帮助/帮,/=布讲告,/=布编程/-帮助/略");
		GameObject gameObject = GameObject.Find("/=座/-墙/院芯");
		GameObject obj = GameObject.Find("/=座/-墙/院虚世");
		gameObject.SetActive(value: true);
		obj.SetActive(value: true);
		公为透 = false;
		虚白();
		春();
	}

	public void 水(string 串参 = "")
	{
	}

	public void 火(string 串参 = "")
	{
	}

	public void 起(string 串参 = "")
	{
	}

	public void 落(string 串参 = "")
	{
	}

	public void 扔(string 串参 = "")
	{
	}

	public void 捡(string 串参 = "")
	{
	}

	public void 枝(string 串参 = "", string 串父 = "")
	{
		GameObject obj = new GameObject(串参);
		obj.transform.position = new Vector3(0f, 0f, 0f);
		UnityEngine.Object.Instantiate(obj);
		GameObject gameObject = GameObject.Find(串父);
		obj.transform.SetParent(gameObject.transform);
	}

	public void 随(string 串参 = "")
	{
		for (int i = 1; i <= 公几随; i++)
		{
			float x = UnityEngine.Random.Range(公变左下.position.x, 公变右上.position.x);
			float z = UnityEngine.Random.Range(公变左下.position.z, 公变右上.position.z);
			float y = 公变左下.position.y;
			GameObject obj = UnityEngine.Object.Instantiate(position: new Vector3(x, y, z), original: Resources.Load("预制/" + 逮.造啥) as GameObject, rotation: Quaternion.identity);
			GameObject gameObject = GameObject.Find("/=造/-组啥/组" + 逮.造啥);
			obj.transform.SetParent(gameObject.transform);
		}
	}

	public void 随色(string 串参 = "")
	{
		for (int i = 0; i < 3; i++)
		{
			switch (i)
			{
			case 0:
				公色 = Color.red;
				break;
			case 1:
				公色 = Color.green;
				break;
			case 2:
				公色 = Color.blue;
				break;
			}
			置色(公色);
		}
	}

	private void 置色(Color 色参)
	{
		GetComponent<Renderer>().material.color = 色参;
	}

	private IEnumerator 载图(string 串参 = "")
	{
		UnityWebRequest www = UnityWebRequestTexture.GetTexture(串参);
		yield return www.SendWebRequest();
		if (www.isNetworkError || www.isHttpError)
		{
			UnityEngine.Debug.Log(www.error);
			yield break;
		}
		Texture texture = ((DownloadHandlerTexture)www.downloadHandler).texture;
		GetComponent<Renderer>().material.mainTexture = texture;
	}

	private IEnumerator 载文(string 串参 = "")
	{
		MonoBehaviour.print(串参);
		UnityWebRequest www = UnityWebRequest.Get(串参);
		yield return www.SendWebRequest();
		if (www.isNetworkError || www.isHttpError)
		{
			UnityEngine.Debug.Log(www.error);
		}
		else
		{
			MonoBehaviour.print(www.downloadHandler.text);
		}
	}

	private IEnumerator 载汉(string 串参 = "")
	{
		UnityWebRequest www = UnityWebRequest.Get(串参);
		yield return www.SendWebRequest();
		if (www.isNetworkError || www.isHttpError)
		{
			UnityEngine.Debug.Log(www.error);
			yield break;
		}
		string text = www.downloadHandler.text;
		私串汉 = text;
		汉();
	}

	private IEnumerator 载英(string 串参 = "")
	{
		UnityWebRequest www = UnityWebRequest.Get(串参);
		yield return www.SendWebRequest();
		if (www.isNetworkError || www.isHttpError)
		{
			UnityEngine.Debug.Log(www.error);
			yield break;
		}
		string text = www.downloadHandler.text;
		私串英 = text;
	}

	public string 简繁(string 串参 = "")
	{
		string text = "";
		string text2 = "";
		for (int i = 0; i < 串参.Length; i++)
		{
			if (私串汉库.IndexOf(串参[i].ToString()) != -1)
			{
				text2 = 私串繁库[私串汉库.IndexOf(串参[i])].ToString();
				text += text2;
			}
			else
			{
				text += 串参[i];
			}
		}
		return text;
	}

	public string 繁简(string 串参 = "")
	{
		MonoBehaviour.print("繁简: " + 串参);
		string text = "";
		for (int i = 0; i < 串参.Length; i++)
		{
			text = ((私串繁库.IndexOf(串参[i].ToString()) == -1) ? (text + 串参[i]) : (text + 私串汉库[私串繁库.IndexOf(串参[i])]));
		}
		MonoBehaviour.print(text);
		return text;
	}

	public void 签播(string 串参 = "")
	{
	}

	public void 签刷(string 串参 = "")
	{
		私尤横集 = GameObject.FindGameObjectsWithTag("横");
		私尤平集 = GameObject.FindGameObjectsWithTag("平");
		私尤纵集 = GameObject.FindGameObjectsWithTag("纵");
		私尤垂集 = GameObject.FindGameObjectsWithTag("垂");
		私尤深集 = GameObject.FindGameObjectsWithTag("深");
		私尤浅集 = GameObject.FindGameObjectsWithTag("浅");
		私尤迁集 = GameObject.FindGameObjectsWithTag("迁");
		私尤徒集 = GameObject.FindGameObjectsWithTag("徒");
		私尤沧集 = GameObject.FindGameObjectsWithTag("沧");
		私尤桑集 = GameObject.FindGameObjectsWithTag("桑");
		私尤抬集 = GameObject.FindGameObjectsWithTag("抬");
		私尤坠集 = GameObject.FindGameObjectsWithTag("坠");
		私尤徘集 = GameObject.FindGameObjectsWithTag("徘");
		私尤徊集 = GameObject.FindGameObjectsWithTag("徊");
		私尤纠集 = GameObject.FindGameObjectsWithTag("纠");
		私尤缠集 = GameObject.FindGameObjectsWithTag("缠");
		私尤拧集 = GameObject.FindGameObjectsWithTag("拧");
		私尤扭集 = GameObject.FindGameObjectsWithTag("扭");
		私尤转集 = GameObject.FindGameObjectsWithTag("转");
		私尤旋集 = GameObject.FindGameObjectsWithTag("旋");
		私尤羡集 = GameObject.FindGameObjectsWithTag("羡");
		私尤慕集 = GameObject.FindGameObjectsWithTag("慕");
		私尤跌集 = GameObject.FindGameObjectsWithTag("跌");
		私尤摔集 = GameObject.FindGameObjectsWithTag("摔");
		私尤糟集 = GameObject.FindGameObjectsWithTag("糟");
		私尤糕集 = GameObject.FindGameObjectsWithTag("糕");
		私尤凯集 = GameObject.FindGameObjectsWithTag("凯");
		私尤涡集 = GameObject.FindGameObjectsWithTag("涡");
		私尤宽集 = GameObject.FindGameObjectsWithTag("宽");
		私尤窄集 = GameObject.FindGameObjectsWithTag("窄");
		私尤高集 = GameObject.FindGameObjectsWithTag("高");
		私尤矮集 = GameObject.FindGameObjectsWithTag("矮");
		私尤厚集 = GameObject.FindGameObjectsWithTag("厚");
		私尤薄集 = GameObject.FindGameObjectsWithTag("薄");
		私尤肥集 = GameObject.FindGameObjectsWithTag("肥");
		私尤腻集 = GameObject.FindGameObjectsWithTag("腻");
		私尤胖集 = GameObject.FindGameObjectsWithTag("胖");
		私尤瘦集 = GameObject.FindGameObjectsWithTag("瘦");
		私尤挺集 = GameObject.FindGameObjectsWithTag("挺");
		私尤扁集 = GameObject.FindGameObjectsWithTag("扁");
		私尤放集 = GameObject.FindGameObjectsWithTag("放");
		私尤缩集 = GameObject.FindGameObjectsWithTag("缩");
		MonoBehaviour.print("签刷()私尤转集" + 私尤转集.Length);
	}

	public void 签转(string 串参 = "")
	{
		私尤转集 = GameObject.FindGameObjectsWithTag("转");
		for (int i = 0; i < 私尤转集.Length; i++)
		{
		}
	}

	public void 签上(string 串参 = "")
	{
		for (int i = 0; i < 私尤转集.Length; i++)
		{
			私尤转集[i].GetComponent<Transform>().Translate(Vector3.up * 2f, Space.Self);
		}
	}

	public void 签下(string 串参 = "")
	{
		for (int i = 0; i < 私尤转集.Length; i++)
		{
			私尤转集[i].GetComponent<Transform>().Translate(Vector3.up * -2f, Space.Self);
		}
	}

	public void 虚乌(string 串参 = "")
	{
		foreach (string key in 公典虚.Keys)
		{
			Material[] materials = new Material[1] { Resources.Load("材质/乌") as Material };
			公典虚[key].GetComponentInChildren<MeshRenderer>().materials = materials;
		}
	}

	public void 虚白(string 串参 = "")
	{
		foreach (string key in 公典虚.Keys)
		{
			Material[] materials = new Material[1] { Resources.Load("材质/白") as Material };
			公典虚[key].GetComponentInChildren<MeshRenderer>().materials = materials;
		}
	}

	private void OnTriggerEnter(Collider coll)
	{
		MonoBehaviour.print("当触发确");
		if (coll.gameObject.name.Substring(0, 1) == "方")
		{
			签上();
		}
	}

	private void OnTriggerExit(Collider coll)
	{
		MonoBehaviour.print("当触发离");
		if (coll.gameObject.name.Substring(0, 1) == "方")
		{
			签下();
		}
	}
}
public class 佑 : MonoBehaviour
{
	public enum 复制种类
	{
		正方体,
		球,
		绿色正方体,
		重力球,
		重力块
	}

	public static 佑 逮;

	public LineRenderer 公射线;

	public Transform 仨射线起始点;

	private Vector3 仨靶位;

	private GameObject 尤靶;

	private RaycastHit 仨射线目标点;

	public GameObject 魔方;

	public GameObject 公丸;

	public GameObject 公盒;

	public bool 公为扳机;

	public bool 公为抓握;

	public bool 公为主键;

	public bool 公为次键;

	public bool 控制UI显隐;

	public bool 公为选;

	public bool 公为创;

	public bool 公为造;

	public bool 公为删;

	public bool 公为移;

	public bool 公为挪;

	public bool 公为撑;

	public bool 公为哪;

	public bool 公为那;

	public bool 公为啊;

	public bool 公为搬;

	public bool 公为洗;

	public bool 公为开;

	public bool 公为签;

	public bool 公为摆;

	public bool 公为搁;

	public bool 公为喷;

	public bool 公为广;

	public bool 锁定XY;

	public bool 锁定XZ;

	public bool 锁定YZ;

	public bool 无锁定;

	public Transform 玩家;

	public GameObject 公组;

	public GameObject 愚;

	public 复制种类 选择的种类;

	public GameObject 它;

	public List<GameObject> 公尤阵选 = new List<GameObject>();

	private Vector3 仨位旧;

	private Vector3 仨位新;

	public float 公几倍 = 0.1f;

	public float 公几尴 = 0.01f;

	public float 公几尬 = 10f;

	public Material 公材醒;

	public Queue<Material> 公队 = new Queue<Material>();

	public bool 公为消;

	public int 缩放的比例 = 5;

	public float 几锁深 = 0.1f;

	public bool 为创 = true;

	public Material 红;

	public Material 绿;

	public Material 蓝;

	public Material 青;

	public Material 黑;

	public Material 白;

	public Material 灰;

	public Material 橙;

	public Material 紫;

	public Material 黄;

	public Material 金;

	public Material 银;

	public Text 公告;

	public Text 调试;

	public int 公几广;

	public int 公几它倍 = 1;

	private UnityEngine.XR.InputDevice device;

	public bool 置公为造
	{
		get
		{
			return 公为造;
		}
		set
		{
			公为造 = value;
		}
	}

	public bool 置公为喷
	{
		get
		{
			return 公为喷;
		}
		set
		{
			公为喷 = value;
		}
	}

	public bool 置公为摆
	{
		get
		{
			return 公为摆;
		}
		set
		{
			公为摆 = value;
		}
	}

	public bool 置公为开
	{
		get
		{
			return 公为开;
		}
		set
		{
			公为开 = value;
		}
	}

	public bool 置公为签
	{
		get
		{
			return 公为签;
		}
		set
		{
			公为签 = value;
		}
	}

	public bool 置公为搬
	{
		get
		{
			return 公为搬;
		}
		set
		{
			公为搬 = value;
		}
	}

	public bool 置公为洗
	{
		get
		{
			return 公为洗;
		}
		set
		{
			公为洗 = value;
		}
	}

	public bool 置公为选
	{
		get
		{
			return 公为选;
		}
		set
		{
			公为选 = value;
		}
	}

	public bool 置公为移
	{
		get
		{
			return 公为移;
		}
		set
		{
			公为移 = value;
		}
	}

	public bool 置公为挪
	{
		get
		{
			return 公为挪;
		}
		set
		{
			公为挪 = value;
		}
	}

	public bool 置公为撑
	{
		get
		{
			return 公为撑;
		}
		set
		{
			公为撑 = value;
		}
	}

	public bool 置公为哪
	{
		get
		{
			return 公为哪;
		}
		set
		{
			公为哪 = value;
		}
	}

	public bool 置公为那
	{
		get
		{
			return 公为那;
		}
		set
		{
			公为那 = value;
		}
	}

	public bool 置公为啊
	{
		get
		{
			return 公为啊;
		}
		set
		{
			公为啊 = value;
		}
	}

	public bool 置公为删
	{
		get
		{
			return 公为删;
		}
		set
		{
			公为删 = value;
		}
	}

	public bool 置公为搁
	{
		get
		{
			return 公为搁;
		}
		set
		{
			公为搁 = value;
		}
	}

	public bool 置公为广
	{
		get
		{
			return 公为广;
		}
		set
		{
			公为广 = value;
		}
	}

	private void Awake()
	{
		逮 = this;
		始();
	}

	private void Start()
	{
	}

	private void OnEnable()
	{
	}

	private void 始()
	{
		公为扳机 = false;
		公为造 = false;
		公为喷 = false;
		控制UI显隐 = false;
		公为删 = false;
		公为搬 = true;
		选择的种类 = 复制种类.正方体;
		公为洗 = false;
		公为摆 = false;
		公为搁 = false;
		锁定XY = false;
		锁定XZ = false;
		锁定YZ = false;
		无锁定 = true;
	}

	private void FixedUpdate()
	{
		if (Time.frameCount % 5 != 0)
		{
			return;
		}
		device = InputDevices.GetDeviceAtXRNode(XRNode.RightHand);
		Vector2 value = default(Vector2);
		device.TryGetFeatureValue(UnityEngine.XR.CommonUsages.primary2DAxis, out value);
		float num = 矢量角度(new Vector2(1f, 0f), value);
		if (value.x == 0f && value.y == 0f)
		{
			return;
		}
		if (num > -45f && num <= 45f)
		{
			if (公为哪)
			{
				佐.逮.横();
			}
			if (公为那)
			{
				佐.逮.转();
			}
			if (公为啊)
			{
				佐.逮.宽();
			}
		}
		else if (num > 45f && num <= 135f)
		{
			佐.逮.公为摇 = true;
			if (公为哪)
			{
				佐.逮.垂();
			}
			if (公为那)
			{
				佐.逮.缠();
			}
			if (公为啊)
			{
				佐.逮.矮();
			}
			佐.逮.公为摇 = false;
		}
		else if (num > -135f && num <= -45f)
		{
			佐.逮.公为摇 = true;
			if (公为哪)
			{
				佐.逮.纵();
			}
			if (公为那)
			{
				佐.逮.纠();
			}
			if (公为啊)
			{
				佐.逮.高();
			}
			佐.逮.公为摇 = false;
		}
		else if (num > 135f || num <= -135f)
		{
			佐.逮.公为摇 = true;
			if (公为哪)
			{
				佐.逮.平();
			}
			if (公为那)
			{
				佐.逮.旋();
			}
			if (公为啊)
			{
				佐.逮.窄();
			}
			佐.逮.公为摇 = false;
		}
		else
		{
			MonoBehaviour.print("什么情况？？？？？？？" + num);
		}
	}

	private float 矢量角度(Vector2 from, Vector2 to)
	{
		Vector3 vector = Vector3.Cross(from, to);
		float num = Vector2.Angle(from, to);
		if (!(vector.z > 0f))
		{
			return num;
		}
		return 0f - num;
	}

	public void 主锁迁()
	{
		锁定XY = true;
		锁定XZ = false;
		锁定YZ = false;
		无锁定 = false;
	}

	public void 主锁沧()
	{
		锁定XY = false;
		锁定XZ = true;
		锁定YZ = false;
		无锁定 = false;
	}

	public void 主锁抬()
	{
		锁定XY = false;
		锁定XZ = false;
		锁定YZ = true;
		无锁定 = false;
	}

	public void 主锁无()
	{
		锁定XY = false;
		锁定XZ = false;
		锁定YZ = false;
		无锁定 = true;
	}

	public void 改态(string 串参 = "造")
	{
		GameObject.Find("/XR Origin/Camera Offset/RightHand Controller/-态/造").SetActive(value: false);
		GameObject.Find("/XR Origin/Camera Offset/RightHand Controller/-态/广").SetActive(value: false);
		GameObject.Find("/XR Origin/Camera Offset/RightHand Controller/-态/删").SetActive(value: false);
		GameObject.Find("/XR Origin/Camera Offset/RightHand Controller/-态/选").SetActive(value: false);
		GameObject.Find("/XR Origin/Camera Offset/RightHand Controller/-态/摆").SetActive(value: false);
		GameObject.Find("/XR Origin/Camera Offset/RightHand Controller/-态/喷").SetActive(value: false);
		GameObject.Find("/XR Origin/Camera Offset/RightHand Controller/-态/" + 串参).SetActive(value: true);
	}

	public void 置佑摇(string 参数 = "")
	{
		公为哪 = false;
		公为那 = false;
		公为啊 = false;
		GetType().GetProperty("置公为" + 参数).SetValue(this, true);
	}

	public void 醒(GameObject go, Material mat)
	{
		Material material = go.GetComponentInChildren<MeshRenderer>().material;
		公队.Enqueue(material);
		go.GetComponentInChildren<MeshRenderer>().material = mat;
	}

	private void Update()
	{
		device = InputDevices.GetDeviceAtXRNode(XRNode.RightHand);
		device.TryGetFeatureValue(UnityEngine.XR.CommonUsages.triggerButton, out 公为扳机);
	}

	public void 置态(string 参数 = "")
	{
		佐.逮.公态 = 参数;
		公为创 = false;
		公为造 = false;
		公为喷 = false;
		公为摆 = false;
		公为开 = false;
		公为签 = false;
		公为搬 = false;
		公为洗 = false;
		公为选 = false;
		公为移 = false;
		公为挪 = false;
		公为撑 = false;
		公为删 = false;
		公为搁 = false;
		公为广 = false;
		GetType().GetProperty("置公为" + 参数).SetValue(this, true);
	}

	public void 改造啥(string 串参 = "")
	{
		if (串参 != "删")
		{
			公组 = GameObject.Find("/=造/-组啥/组" + 串参);
			if (!公组)
			{
				佐.逮.枝("组" + 串参, "/=造/-组啥");
				公组 = GameObject.Find("/=造/-组啥/组" + 串参);
			}
		}
		GameObject original = Resources.Load("预制/" + 串参) as GameObject;
		GameObject gameObject = UnityEngine.Object.Instantiate(original);
		gameObject.name = 串参;
		GameObject gameObject2 = GameObject.Find("/=造/-造啥");
		if (gameObject2.transform.childCount > 0)
		{
			UnityEngine.Object.Destroy(gameObject2.transform.GetChild(0).gameObject);
		}
		gameObject.transform.SetParent(gameObject2.transform);
		gameObject.AddComponent<妥造>();
		UnityEngine.Object.Destroy(gameObject.GetComponentInChildren<Collider>());
		gameObject.GetComponent<妥造>().它 = original;
		它 = gameObject;
		GameObject gameObject3 = GameObject.Find("/=造/-组啥/组" + 佐.逮.造啥);
		gameObject.GetComponent<妥造>().公组 = gameObject3;
	}
}
public class 叹 : MonoBehaviour
{
	private int number;

	public Image dotweenLogo;

	public Image circleOutline;

	public Text text;

	public Text relativeText;

	public Text scrambledText;

	public Slider slider;

	private void Start()
	{
		叹二();
	}

	private void 叹一()
	{
		UnityEngine.Debug.Log("叹一");
		DOTween.To(() => base.transform.position, delegate(Vector3 r)
		{
			base.transform.position = r;
		}, new Vector3(1f, 1f, 1f), 1f);
		((Tween)DOTween.To(() => number, delegate(int x)
		{
			number = x;
		}, 100, 5f)).OnUpdate((TweenCallback)delegate
		{
			UpdateTween(number);
		});
	}

	private void UpdateTween(int num)
	{
		UnityEngine.Debug.Log("UpdateTween之num：" + num);
	}

	private void 叹二()
	{
		base.transform.DOBlendableLocalMoveBy(new Vector3(1f, 1f, 1f), 50f);
	}

	private void CallBack()
	{
		Tweener t = DOTween.To(() => number, delegate(int x)
		{
			number = x;
		}, 100, 5f);
		((Tween)t).OnStart((TweenCallback)OnStartTween).OnKill(OnKill).OnPause(OnPause)
			.OnPlay(OnPlay)
			.OnRewind(OnRewind);
		((Tween)t).OnStepComplete((TweenCallback)OnStepComplete).OnUpdate(UpdateTweenEd).OnComplete(OnComplete);
		((Tween)t).OnUpdate((TweenCallback)delegate
		{
			UpdateTweenED(number);
		});
	}

	private void UpdateTweenED(int num)
	{
		UnityEngine.Debug.Log("UpdateTweenED之num：" + num);
	}

	private void OnComplete()
	{
		UnityEngine.Debug.Log("OnComplete");
	}

	private void OnKill()
	{
		UnityEngine.Debug.Log("OnKill");
	}

	private void OnPlay()
	{
		UnityEngine.Debug.Log("OnPlay");
	}

	private void OnPause()
	{
		UnityEngine.Debug.Log("OnPause");
	}

	private void OnRewind()
	{
		UnityEngine.Debug.Log("OnRewind");
	}

	private void OnStartTween()
	{
		UnityEngine.Debug.Log("StartTween");
	}

	private void OnStepComplete()
	{
		UnityEngine.Debug.Log("OnStepComplete");
	}

	private void UpdateTweenEd()
	{
		UnityEngine.Debug.Log(number);
	}

	private void OnWayPointChange()
	{
		UnityEngine.Debug.Log("OnWayPointChange");
	}

	private void 叹置()
	{
		Vector3 pos = Vector3.zero;
		Tween asTween = DOTween.To(() => pos, delegate(Vector3 r)
		{
			pos = r;
		}, new Vector3(5f, 5f, 5f), 1f).SetLoops(-1, LoopType.Yoyo).SetEase(Ease.InOutCirc);
		DOTween.To(() => base.transform.position, delegate(Vector3 r)
		{
			base.transform.position = r;
		}, new Vector3(15f, 15f, 15f), 2f).SetAs(asTween);
		base.transform.DOMoveX(20f, 5f).SetAutoKill(autoKillOnCompletion: true).SetDelay(3f)
			.SetEase(Ease.InOutCirc)
			.SetId("superTween")
			.SetLoops(-1, LoopType.Yoyo)
			.SetRecyclable()
			.SetRelative()
			.SetSpeedBased()
			.SetTarget(base.transform)
			.SetUpdate(UpdateType.Normal, isIndependentUpdate: true);
	}

	private void 叹队列()
	{
		float num = 5f;
		Sequence sequence = DOTween.Sequence();
		sequence.Append(base.transform.DOMoveX(6f, 3f).SetRelative().SetEase(Ease.InOutQuad));
		sequence.Insert(0f, base.transform.DORotate(new Vector3(0f, 45f, 0f), num / 2f).SetEase(Ease.InQuad).SetLoops(100, LoopType.Yoyo));
		sequence.Insert(num / 2f, base.transform.GetComponent<Renderer>().material.DOColor(Color.yellow, num / 2f));
		sequence.SetLoops(-1, LoopType.Yoyo);
	}

	private void 叹图像冷却()
	{
		circleOutline = GetComponent<Image>();
		if (!(circleOutline == null))
		{
			circleOutline.DOColor(RandomColor(), 1.5f).SetEase(Ease.Linear).Pause();
			circleOutline.DOFillAmount(0f, 1.5f).SetEase(Ease.Linear).SetLoops(-1, LoopType.Yoyo)
				.OnStepComplete(delegate
				{
					circleOutline.fillClockwise = !circleOutline.fillClockwise;
					circleOutline.DOColor(RandomColor(), 1.5f).SetEase(Ease.Linear);
				})
				.Pause();
			dotweenLogo = GetComponent<Image>();
			if (!(dotweenLogo == null))
			{
				dotweenLogo.DOFade(0f, 1.5f).SetAutoKill(autoKillOnCompletion: false).Pause();
			}
		}
	}

	private Color RandomColor()
	{
		return new Color(UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f), 1f);
	}

	private void FunctionText()
	{
		text = GetComponent<Text>();
		text.DOText("This text will replace the existing one", 2f).SetEase(Ease.Linear).SetAutoKill(autoKillOnCompletion: false)
			.Pause();
		relativeText = GetComponent<Text>();
		relativeText.DOText(" - This text will be added to the existing one", 2f).SetRelative().SetEase(Ease.Linear)
			.SetAutoKill(autoKillOnCompletion: false)
			.Pause();
		scrambledText = GetComponent<Text>();
		scrambledText.DOText("This text will appear from scrambled chars", 2f).SetEase(Ease.Linear).SetAutoKill(autoKillOnCompletion: false)
			.Pause();
	}

	private void FunctionSlider()
	{
		slider = GetComponent<Slider>();
		slider.DOValue(1f, 1.5f).SetEase(Ease.InOutQuad).SetLoops(-1, LoopType.Yoyo)
			.Pause();
	}

	private void FunctionDOTween()
	{
		DOTween.PlayAll();
		DOTween.RestartAll();
	}
}
public class 射线 : MonoBehaviour
{
	private GameObject 私讲;

	private GameObject 私告;

	private XRSimpleInteractable 交互;

	private ControllerUITest 佐佑;

	private void Awake()
	{
		佐佑 = UnityEngine.Object.FindObjectOfType<ControllerUITest>();
	}

	private void Start()
	{
		交互 = base.gameObject.GetComponent<XRSimpleInteractable>();
		if (!交互)
		{
			交互 = base.gameObject.AddComponent<XRSimpleInteractable>();
			交互.hoverEntered.AddListener(HoverEntered);
			交互.hoverExited.AddListener(HoverExited);
			交互.selectEntered.AddListener(SelectEntered);
			交互.selectExited.AddListener(SelectExited);
		}
	}

	protected void OnEnable()
	{
		私讲 = GameObject.Find("-单字/布讲告/讲");
		私告 = GameObject.Find("-单字/布讲告/告");
	}

	public void HoverEntered(HoverEnterEventArgs inter)
	{
		string value = new Regex("[一-龥]+").Matches(inter.interactableObject.transform.name)[0].Value;
		if (佐.逮.公为繁)
		{
			私告.GetComponent<Text>().text = "【" + 佐.逮.简繁(value) + "】" + 佐.逮.简繁(佐.逮.公典帮[value]);
		}
		else
		{
			私告.GetComponent<Text>().text = "【" + value + "】" + 佐.逮.公典帮[value];
		}
		inter.interactableObject.transform.localScale = new Vector3(佐.逮.公几速虚, 佐.逮.公几速虚, 佐.逮.公几速虚 * 5f);
	}

	public void HoverExited(HoverExitEventArgs inter)
	{
		inter.interactableObject.transform.localScale = new Vector3(佐.逮.公几速虚, 佐.逮.公几速虚, 佐.逮.公几速虚);
	}

	public void SelectEntered(SelectEnterEventArgs inter)
	{
		GameObject 该 = 佐.逮.该;
		佐.逮.该 = base.gameObject;
		佐.逮.色("#EEC981");
		佐.逮.该 = 该;
		Regex regex = new Regex("[一-龥]+");
		string value = regex.Matches(inter.interactableObject.transform.name)[0].Value;
		佐.逮.GetComponent<佐>().选啥 = value;
		if (佐.逮.公串造.IndexOf(value) != -1)
		{
			佐.逮.GetComponent<佐>().造啥 = value;
		}
		if (佐.逮.公为繁)
		{
			私讲.GetComponent<Text>().text = "【" + 佐.逮.简繁(value) + "( )】" + 佐.逮.简繁(佐.逮.公典帮[value]);
		}
		else
		{
			私讲.GetComponent<Text>().text = "【" + value + "】" + 佐.逮.公典帮[value];
		}
		佐佑.公讲(value + "( )", 为佐参: true);
		私告.GetComponent<Text>().text = 佐.逮.公典帮[value];
		佐.逮.GetComponent<佐>().脑执(value);
		if ((bool)佐.逮.该已)
		{
			value = regex.Matches(佐.逮.该已.name)[0].Value;
			该 = 佐.逮.该;
			佐.逮.该 = 佐.逮.该已;
			佐.逮.色("#eeeeee");
			佐.逮.该 = 该;
		}
		佐.逮.该已 = base.gameObject;
	}

	public void SelectExited(SelectExitEventArgs inter)
	{
	}
}
public class 类走 : LocomotionProvider
{
	[SerializeField]
	private float 私浮移速 = 1f;

	[SerializeField]
	private float 私浮转速 = 180f;

	[SerializeField]
	private InputActionProperty moveAction;

	[SerializeField]
	private InputActionProperty verticalMoveAction;

	private UnityEngine.XR.InputDevice device;

	public bool 公为主键;

	public bool 公为次键;

	public static 类走 逮;

	private float 浮升降;

	private void Update()
	{
		Vector2 vector = 取移动方向();
		Vector3 vector2 = new Vector3(vector.x, 0f, vector.y);
		Vector3 vector3 = new Vector3(0f, 浮升降, 0f);
		if (CanBeginLocomotion() && BeginLocomotion())
		{
			XROrigin xrOrigin = base.system.xrOrigin;
			if (xrOrigin != null)
			{
				xrOrigin.RotateAroundCameraUsingOriginUp(取旋转方向() * 私浮转速 * Time.deltaTime);
			}
			xrOrigin.transform.Translate((vector2 + vector3) * 私浮移速 * Time.deltaTime, Space.Self);
			EndLocomotion();
		}
	}

	private Vector2 取移动方向()
	{
		return moveAction.action?.ReadValue<Vector2>() ?? Vector2.zero;
	}

	public float 取垂直移动方向(string 串参 = "悬")
	{
		if (串参 == "升")
		{
			浮升降 = 0.5f;
			return 0.5f;
		}
		if (串参 == "降")
		{
			浮升降 = -0.5f;
			return -0.5f;
		}
		_ = 串参 == "悬";
		浮升降 = 0f;
		return 0f;
	}

	private float 取旋转方向()
	{
		return 0f;
	}

	private void OnEnable()
	{
		moveAction.EnableDirectAction();
		verticalMoveAction.EnableDirectAction();
		device = InputDevices.GetDeviceAtXRNode(XRNode.LeftHand);
	}

	private void OnDisable()
	{
		moveAction.DisableDirectAction();
		verticalMoveAction.DisableDirectAction();
	}

	private new void Awake()
	{
		逮 = this;
	}
}
public class 纹理 : MonoBehaviour
{
	public static 纹理 逮;

	public GameObject 公纹理;

	public GameObject item;

	public GridLayoutGroup grid;

	private float ex;

	private bool isEx;

	private int intX;

	private int intEx;

	private int intY;

	private int intExY;

	private float exy;

	public Image[] array;

	public int currentNum;

	public 佐 第一级UI;

	public UnityEngine.XR.InputDevice device;

	private WWW bundle;

	private AssetBundle 公捆;

	public string webpath;

	public Sprite[] 材质贴图;

	private int length;

	private void Awake()
	{
		公纹理.SetActive(value: true);
		逮 = this;
		length = 材质贴图.Length;
	}

	private void Start()
	{
	}

	private void 加图()
	{
		array = new Image[length];
		currentNum = (int)Mathf.Round((float)length * 0.5f);
		for (int i = 0; i < length; i++)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(item, grid.transform.position, Quaternion.identity);
			gameObject.transform.SetParent(grid.transform);
			gameObject.transform.localScale = new Vector3(1f, 1f, 1f);
			gameObject.name = "图";
			gameObject.transform.localRotation = Quaternion.identity;
			gameObject.GetComponent<Image>().overrideSprite = 材质贴图[i];
			array[i] = gameObject.GetComponent<Image>();
		}
		array[currentNum].DOFade(1f, 0.1f);
	}

	private void LateUpdate()
	{
		device.TryGetFeatureValue(UnityEngine.XR.CommonUsages.menuButton, out var value);
		if (value)
		{
			公纹理.SetActive(value: false);
			base.enabled = false;
			第一级UI.enabled = true;
		}
		device.TryGetFeatureValue(UnityEngine.XR.CommonUsages.triggerButton, out var value2);
		if (value2)
		{
			string methodName = array[currentNum].name;
			SendMessage(methodName);
		}
	}

	public void 材(string 串材参)
	{
		if (佐.逮.公敬 == "已")
		{
			Material[] materials = new Material[1] { Resources.Load("材质/" + 串材参) as Material };
			GameObject gameObject = GameObject.Find("/=造/-组啥/组" + 佐.逮.造啥);
			if (gameObject.transform.childCount > 0)
			{
				for (int i = 0; i < gameObject.transform.childCount; i++)
				{
					gameObject.transform.GetChild(i).gameObject.GetComponentInChildren<MeshRenderer>().materials = materials;
				}
			}
		}
		else if (佐.逮.公敬 == "仅")
		{
			if ((bool)佐.逮.该)
			{
				Material[] materials2 = new Material[1] { Resources.Load("材质/" + 串材参) as Material };
				佐.逮.该.GetComponentInChildren<MeshRenderer>().materials = materials2;
			}
		}
		else if (佐.逮.公敬 == "然")
		{
			Material[] array = new Material[1] { Resources.Load("材质/" + 串材参) as Material };
			MonoBehaviour.print(佑.逮.它);
			佑.逮.它.GetComponentInChildren<MeshRenderer>().materials = array;
			佑.逮.它.GetComponent<妥造>().它.GetComponentInChildren<MeshRenderer>().sharedMaterials = array;
		}
		else
		{
			MonoBehaviour.print("应该不会来到这里才对");
		}
	}

	public void 改材质贴图(int 几号图 = 0)
	{
		GameObject 它 = 佑.逮.它;
		MonoBehaviour.print("////////////////几号图:" + 几号图);
		Texture texture = 材质贴图[几号图].texture;
		它.GetComponentInChildren<MeshRenderer>().material.mainTexture = texture;
		它.GetComponent<妥造>().它.GetComponentInChildren<MeshRenderer>().sharedMaterial.mainTexture = texture;
		第一级UI.enabled = true;
		base.enabled = false;
		公纹理.SetActive(value: false);
		Caching.ClearCache();
	}
}
public class 类脑
{
	public static GameObject 主角;

	public static string 微我号;

	public static string socketId;

	public ArrayList 阵在线用户;

	private static int hour;

	private static int minute;

	private static int second;

	private static int year;

	private static int month;

	private static int day;

	public static string 取时间()
	{
		hour = DateTime.Now.Hour;
		minute = DateTime.Now.Minute;
		second = DateTime.Now.Second;
		year = DateTime.Now.Year;
		month = DateTime.Now.Month;
		day = DateTime.Now.Day;
		return $"{hour:D2}:{minute:D2}:{second:D2} ";
	}
}
public class 语 : MonoBehaviour
{
	public Text T;

	public GameObject 发送消息;

	public string url = "https://openapi.baidu.com/oauth/2.0/token";

	public string token;

	private IEnumerator Start()
	{
		WWWForm wWWForm = new WWWForm();
		wWWForm.AddField("grant_type", "25client_credentials");
		wWWForm.AddField("client_id", "25xZOmb7xgblGZXeyg0OSxIW4z");
		wWWForm.AddField("client_secret", "25z67jsE0tKEGigSOViaV11Eo6Qj669dGy");
		using UnityWebRequest getData = UnityWebRequest.Post(url, wWWForm);
		yield return getData.SendWebRequest();
		if (getData.result != UnityWebRequest.Result.Success)
		{
			UnityEngine.Debug.Log("【语】错：" + getData.error);
			yield break;
		}
		JsonData jsonData = JsonMapper.ToObject(getData.downloadHandler.text);
		token = (string)jsonData["access_token"];
	}

	public IEnumerator 语音识别(byte[] postData)
	{
		WWWForm wWWForm = new WWWForm();
		T.text = "准备发送数据";
		wWWForm.AddBinaryData("fileUpload", postData, "flacFile", "audio/wav; rate=8000");
		using UnityWebRequest getData = UnityWebRequest.Post("http://vop.baidu.com/server_api?lan=zh&cuid=vr&token=" + token, wWWForm);
		getData.SetRequestHeader("Content-Type", "audio/wav; rate=8000");
		yield return getData.SendWebRequest();
		if (getData.result != UnityWebRequest.Result.Success)
		{
			T.text = getData.error;
			UnityEngine.Debug.Log("⒈【语】错：" + getData.error);
			yield break;
		}
		UnityEngine.Debug.Log("⒉【语】肉：" + getData.downloadHandler.text);
		Regex regex = new Regex("[一-龥]+");
		string text = "";
		foreach (Match item in regex.Matches(getData.downloadHandler.text))
		{
			text += item.Value;
			switch (item.Value)
			{
			case "开灯":
				佐.逮.亮();
				break;
			case "关灯":
				佐.逮.暗();
				break;
			case "跑":
				发送消息.SendMessage("跑", "");
				break;
			case "泡":
				发送消息.SendMessage("跑", "");
				break;
			case "炮":
				发送消息.SendMessage("跑", "");
				break;
			case "好":
				发送消息.SendMessage("跑", "");
				break;
			case "抛":
				发送消息.SendMessage("猫", "");
				break;
			case "熊猫":
				发送消息.SendMessage("猫", "");
				break;
			case "猫":
				发送消息.SendMessage("猫", "");
				break;
			case "毛":
				发送消息.SendMessage("猫", "");
				break;
			case "包":
				发送消息.SendMessage("猫", "");
				break;
			case "矛":
				发送消息.SendMessage("猫", "");
				break;
			case "么":
				发送消息.SendMessage("猫", "");
				break;
			case "滚":
				发送消息.SendMessage("滚", "");
				break;
			case "棍":
				发送消息.SendMessage("滚", "");
				break;
			case "关":
				发送消息.SendMessage("滚", "");
				break;
			case "个":
				发送消息.SendMessage("滚", "");
				break;
			case "摇头":
				发送消息.SendMessage("摇头", "");
				break;
			case "躺下":
				发送消息.SendMessage("躺下", "");
				break;
			case "方":
				佐.逮.方();
				break;
			case "球":
				佐.逮.球();
				break;
			case "胶":
				佐.逮.胶();
				break;
			case "柱":
				佐.逮.柱();
				break;
			case "锥":
				佐.逮.锥();
				break;
			case "删":
				佐.逮.删();
				break;
			case "清":
				佐.逮.清();
				break;
			case "大":
				佐.逮.大();
				break;
			case "咋":
				佐.逮.大();
				break;
			case "中":
				佐.逮.中();
				break;
			case "小":
				佐.逮.小();
				break;
			case "亮":
				佐.逮.亮();
				break;
			case "暗":
				佐.逮.暗();
				break;
			case "灰":
				佐.逮.灰();
				break;
			case "黑":
				佐.逮.黑();
				break;
			case "白":
				佐.逮.白();
				break;
			case "红":
				佐.逮.红();
				break;
			case "橙":
				佐.逮.橙();
				break;
			case "黄":
				佐.逮.黄();
				break;
			case "青":
				佐.逮.青();
				break;
			case "蓝":
				佐.逮.蓝();
				break;
			case "紫":
				佐.逮.紫();
				break;
			case "金":
				佐.逮.金();
				break;
			case "铁":
				佐.逮.铁();
				break;
			case "木":
				佐.逮.木();
				break;
			case "砖":
				佐.逮.砖();
				break;
			case "图":
				佐.逮.图();
				break;
			case "瓷":
				佐.逮.瓷();
				break;
			case "瓦":
				佐.逮.瓦();
				break;
			case "闪":
				佐.逮.闪();
				break;
			case "走":
				佐.逮.走();
				break;
			case "飞":
				佐.逮.飞();
				break;
			case "游":
				佐.逮.游();
				break;
			case "正方体":
				佐.逮.方();
				break;
			case "正方形":
				佐.逮.方();
				break;
			case "球体":
				佐.逮.球();
				break;
			case "胶囊":
				佐.逮.胶();
				break;
			case "圆柱体":
				佐.逮.柱();
				break;
			case "圆锥":
				佐.逮.锥();
				break;
			case "圆锥体":
				佐.逮.锥();
				break;
			case "删除":
				佐.逮.删();
				break;
			case "清除":
				佐.逮.清();
				break;
			case "变大":
				佐.逮.大();
				break;
			case "变中":
				佐.逮.中();
				break;
			case "变小":
				佐.逮.小();
				break;
			case "变亮":
				佐.逮.亮();
				break;
			case "变量":
				佐.逮.亮();
				break;
			case "电量":
				佐.逮.亮();
				break;
			case "变暗":
				佐.逮.暗();
				break;
			case "电焊":
				佐.逮.暗();
				break;
			case "变灰":
				佐.逮.灰();
				break;
			case "变黑":
				佐.逮.黑();
				break;
			case "变白":
				佐.逮.白();
				break;
			case "变红":
				佐.逮.红();
				break;
			case "变橙":
				佐.逮.橙();
				break;
			case "变黄":
				佐.逮.黄();
				break;
			case "变青":
				佐.逮.青();
				break;
			case "变蓝":
				佐.逮.蓝();
				break;
			case "变紫":
				佐.逮.紫();
				break;
			case "变金":
				佐.逮.金();
				break;
			case "灰色":
				佐.逮.灰();
				break;
			case "黑色":
				佐.逮.黑();
				break;
			case "白色":
				佐.逮.白();
				break;
			case "红色":
				佐.逮.红();
				break;
			case "橙色":
				佐.逮.橙();
				break;
			case "黄色":
				佐.逮.黄();
				break;
			case "青色":
				佐.逮.青();
				break;
			case "蓝色":
				佐.逮.蓝();
				break;
			case "紫色":
				佐.逮.紫();
				break;
			case "金色":
				佐.逮.金();
				break;
			case "变铁":
				佐.逮.铁();
				break;
			case "变木":
				佐.逮.木();
				break;
			case "变砖":
				佐.逮.砖();
				break;
			case "变图":
				佐.逮.图();
				break;
			case "变瓷":
				佐.逮.瓷();
				break;
			case "变瓦":
				佐.逮.瓦();
				break;
			case "闪吧":
				佐.逮.闪();
				break;
			case "走吧":
				佐.逮.走();
				break;
			case "飞吧":
				佐.逮.飞();
				break;
			case "游戏":
				佐.逮.游();
				break;
			}
		}
		T.text = text;
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.A))
		{
			base.gameObject.SendMessage("关灯", "");
			UnityEngine.Debug.Log("A 关灯：");
		}
		if (Input.GetKeyDown(KeyCode.B))
		{
			base.gameObject.SendMessage("跑", "");
			UnityEngine.Debug.Log("B 跑：");
		}
		if (Input.GetKeyDown(KeyCode.C))
		{
			base.gameObject.SendMessage("猫", "");
			UnityEngine.Debug.Log("C 猫：");
		}
		if (Input.GetKeyDown(KeyCode.D))
		{
			base.gameObject.SendMessage("开灯", "");
			UnityEngine.Debug.Log("D 开灯：");
		}
	}
}
public class TourCamera : MonoBehaviour
{
	public Transform tourCamera;

	public float moveSpeed = 1f;

	public float rotateSpeed = 90f;

	public float shiftRate = 2f;

	public float minDistance = 0.5f;

	private Vector3 direction = Vector3.zero;

	private Vector3 speedForward;

	private Vector3 speedBack;

	private Vector3 speedLeft;

	private Vector3 speedRight;

	private Vector3 speedUp;

	private Vector3 speedDown;

	private void Start()
	{
		if (tourCamera == null)
		{
			tourCamera = base.gameObject.transform;
		}
	}

	private void Update()
	{
		GetDirection();
		RaycastHit hitInfo;
		while (Physics.Raycast(tourCamera.position, direction, out hitInfo, minDistance))
		{
			float num = Vector3.Angle(direction, hitInfo.normal);
			float num2 = Vector3.Magnitude(direction) * Mathf.Cos(MathF.PI / 180f * (180f - num));
			direction += hitInfo.normal * num2;
		}
		tourCamera.Translate(direction * moveSpeed * Time.deltaTime, Space.World);
	}

	private void GetDirection()
	{
		if (Input.GetKeyDown(KeyCode.LeftShift))
		{
			moveSpeed *= shiftRate;
		}
		if (Input.GetKeyUp(KeyCode.LeftShift))
		{
			moveSpeed /= shiftRate;
		}
		speedForward = Vector3.zero;
		speedBack = Vector3.zero;
		speedLeft = Vector3.zero;
		speedRight = Vector3.zero;
		speedUp = Vector3.zero;
		speedDown = Vector3.zero;
		if (Input.GetKey(KeyCode.W))
		{
			speedForward = tourCamera.forward;
		}
		if (Input.GetKey(KeyCode.S))
		{
			speedBack = -tourCamera.forward;
		}
		if (Input.GetKey(KeyCode.A))
		{
			speedLeft = -tourCamera.right;
		}
		if (Input.GetKey(KeyCode.D))
		{
			speedRight = tourCamera.right;
		}
		if (Input.GetKey(KeyCode.E))
		{
			speedUp = Vector3.up;
		}
		if (Input.GetKey(KeyCode.Q))
		{
			speedDown = Vector3.down;
		}
		direction = speedForward + speedBack + speedLeft + speedRight + speedUp + speedDown;
		if (Input.GetMouseButton(1))
		{
			tourCamera.RotateAround(tourCamera.position, Vector3.up, Input.GetAxis("Mouse X") * rotateSpeed * Time.deltaTime);
			tourCamera.RotateAround(tourCamera.position, tourCamera.right, (0f - Input.GetAxis("Mouse Y")) * rotateSpeed * Time.deltaTime);
			direction = V3RotateAround(direction, Vector3.up, Input.GetAxis("Mouse X") * rotateSpeed * Time.deltaTime);
			direction = V3RotateAround(direction, tourCamera.right, (0f - Input.GetAxis("Mouse Y")) * rotateSpeed * Time.deltaTime);
		}
	}

	public Vector3 V3RotateAround(Vector3 source, Vector3 axis, float angle)
	{
		return Quaternion.AngleAxis(angle, axis) * source;
	}
}
namespace MiniJSON
{
	public static class Json
	{
		private sealed class Parser : IDisposable
		{
			private enum TOKEN
			{
				NONE,
				CURLY_OPEN,
				CURLY_CLOSE,
				SQUARED_OPEN,
				SQUARED_CLOSE,
				COLON,
				COMMA,
				STRING,
				NUMBER,
				TRUE,
				FALSE,
				NULL
			}

			private const string WORD_BREAK = "{}[],:\"";

			private StringReader json;

			private char PeekChar => Convert.ToChar(json.Peek());

			private char NextChar => Convert.ToChar(json.Read());

			private string NextWord
			{
				get
				{
					StringBuilder stringBuilder = new StringBuilder();
					while (!IsWordBreak(PeekChar))
					{
						stringBuilder.Append(NextChar);
						if (json.Peek() == -1)
						{
							break;
						}
					}
					return stringBuilder.ToString();
				}
			}

			private TOKEN NextToken
			{
				get
				{
					EatWhitespace();
					if (json.Peek() == -1)
					{
						return TOKEN.NONE;
					}
					switch (PeekChar)
					{
					case '{':
						return TOKEN.CURLY_OPEN;
					case '}':
						json.Read();
						return TOKEN.CURLY_CLOSE;
					case '[':
						return TOKEN.SQUARED_OPEN;
					case ']':
						json.Read();
						return TOKEN.SQUARED_CLOSE;
					case ',':
						json.Read();
						return TOKEN.COMMA;
					case '"':
						return TOKEN.STRING;
					case ':':
						return TOKEN.COLON;
					case '-':
					case '0':
					case '1':
					case '2':
					case '3':
					case '4':
					case '5':
					case '6':
					case '7':
					case '8':
					case '9':
						return TOKEN.NUMBER;
					default:
						return NextWord switch
						{
							"false" => TOKEN.FALSE, 
							"true" => TOKEN.TRUE, 
							"null" => TOKEN.NULL, 
							_ => TOKEN.NONE, 
						};
					}
				}
			}

			public static bool IsWordBreak(char c)
			{
				if (!char.IsWhiteSpace(c))
				{
					return "{}[],:\"".IndexOf(c) != -1;
				}
				return true;
			}

			private Parser(string jsonString)
			{
				json = new StringReader(jsonString);
			}

			public static object Parse(string jsonString)
			{
				using Parser parser = new Parser(jsonString);
				return parser.ParseValue();
			}

			public void Dispose()
			{
				json.Dispose();
				json = null;
			}

			private Dictionary<string, object> ParseObject()
			{
				Dictionary<string, object> dictionary = new Dictionary<string, object>();
				json.Read();
				while (true)
				{
					switch (NextToken)
					{
					case TOKEN.COMMA:
						continue;
					case TOKEN.NONE:
						return null;
					case TOKEN.CURLY_CLOSE:
						return dictionary;
					}
					string text = ParseString();
					if (text == null)
					{
						return null;
					}
					if (NextToken != TOKEN.COLON)
					{
						return null;
					}
					json.Read();
					dictionary[text] = ParseValue();
				}
			}

			private List<object> ParseArray()
			{
				List<object> list = new List<object>();
				json.Read();
				bool flag = true;
				while (flag)
				{
					TOKEN nextToken = NextToken;
					switch (nextToken)
					{
					case TOKEN.NONE:
						return null;
					case TOKEN.SQUARED_CLOSE:
						flag = false;
						break;
					default:
					{
						object item = ParseByToken(nextToken);
						list.Add(item);
						break;
					}
					case TOKEN.COMMA:
						break;
					}
				}
				return list;
			}

			private object ParseValue()
			{
				TOKEN nextToken = NextToken;
				return ParseByToken(nextToken);
			}

			private object ParseByToken(TOKEN token)
			{
				return token switch
				{
					TOKEN.STRING => ParseString(), 
					TOKEN.NUMBER => ParseNumber(), 
					TOKEN.CURLY_OPEN => ParseObject(), 
					TOKEN.SQUARED_OPEN => ParseArray(), 
					TOKEN.TRUE => true, 
					TOKEN.FALSE => false, 
					TOKEN.NULL => null, 
					_ => null, 
				};
			}

			private string ParseString()
			{
				StringBuilder stringBuilder = new StringBuilder();
				json.Read();
				bool flag = true;
				while (flag)
				{
					if (json.Peek() == -1)
					{
						flag = false;
						break;
					}
					char nextChar = NextChar;
					switch (nextChar)
					{
					case '"':
						flag = false;
						break;
					case '\\':
						if (json.Peek() == -1)
						{
							flag = false;
							break;
						}
						nextChar = NextChar;
						switch (nextChar)
						{
						case '"':
						case '/':
						case '\\':
							stringBuilder.Append(nextChar);
							break;
						case 'b':
							stringBuilder.Append('\b');
							break;
						case 'f':
							stringBuilder.Append('\f');
							break;
						case 'n':
							stringBuilder.Append('\n');
							break;
						case 'r':
							stringBuilder.Append('\r');
							break;
						case 't':
							stringBuilder.Append('\t');
							break;
						case 'u':
						{
							char[] array = new char[4];
							for (int i = 0; i < 4; i++)
							{
								array[i] = NextChar;
							}
							stringBuilder.Append((char)Convert.ToInt32(new string(array), 16));
							break;
						}
						}
						break;
					default:
						stringBuilder.Append(nextChar);
						break;
					}
				}
				return stringBuilder.ToString();
			}

			private object ParseNumber()
			{
				string nextWord = NextWord;
				if (nextWord.IndexOf('.') == -1)
				{
					long.TryParse(nextWord, out var result);
					return result;
				}
				double.TryParse(nextWord, out var result2);
				return result2;
			}

			private void EatWhitespace()
			{
				while (char.IsWhiteSpace(PeekChar))
				{
					json.Read();
					if (json.Peek() == -1)
					{
						break;
					}
				}
			}
		}

		private sealed class Serializer
		{
			private StringBuilder builder;

			private Serializer()
			{
				builder = new StringBuilder();
			}

			public static string Serialize(object obj)
			{
				Serializer serializer = new Serializer();
				serializer.SerializeValue(obj);
				return serializer.builder.ToString();
			}

			private void SerializeValue(object value)
			{
				if (value == null)
				{
					builder.Append("null");
				}
				else if (value is string str)
				{
					SerializeString(str);
				}
				else if (value is bool)
				{
					builder.Append(((bool)value) ? "true" : "false");
				}
				else if (value is IList anArray)
				{
					SerializeArray(anArray);
				}
				else if (value is IDictionary obj)
				{
					SerializeObject(obj);
				}
				else if (value is char)
				{
					SerializeString(new string((char)value, 1));
				}
				else
				{
					SerializeOther(value);
				}
			}

			private void SerializeObject(IDictionary obj)
			{
				bool flag = true;
				builder.Append('{');
				foreach (object key in obj.Keys)
				{
					if (!flag)
					{
						builder.Append(',');
					}
					SerializeString(key.ToString());
					builder.Append(':');
					SerializeValue(obj[key]);
					flag = false;
				}
				builder.Append('}');
			}

			private void SerializeArray(IList anArray)
			{
				builder.Append('[');
				bool flag = true;
				foreach (object item in anArray)
				{
					if (!flag)
					{
						builder.Append(',');
					}
					SerializeValue(item);
					flag = false;
				}
				builder.Append(']');
			}

			private void SerializeString(string str)
			{
				builder.Append('"');
				char[] array = str.ToCharArray();
				foreach (char c in array)
				{
					switch (c)
					{
					case '"':
						builder.Append("\\\"");
						continue;
					case '\\':
						builder.Append("\\\\");
						continue;
					case '\b':
						builder.Append("\\b");
						continue;
					case '\f':
						builder.Append("\\f");
						continue;
					case '\n':
						builder.Append("\\n");
						continue;
					case '\r':
						builder.Append("\\r");
						continue;
					case '\t':
						builder.Append("\\t");
						continue;
					}
					int num = Convert.ToInt32(c);
					if (num >= 32 && num <= 126)
					{
						builder.Append(c);
						continue;
					}
					builder.Append("\\u");
					builder.Append(num.ToString("x4"));
				}
				builder.Append('"');
			}

			private void SerializeOther(object value)
			{
				if (value is float)
				{
					builder.Append(((float)value).ToString("R"));
				}
				else if (value is int || value is uint || value is long || value is sbyte || value is byte || value is short || value is ushort || value is ulong)
				{
					builder.Append(value);
				}
				else if (value is double || value is decimal)
				{
					builder.Append(Convert.ToDouble(value).ToString("R"));
				}
				else
				{
					SerializeString(value.ToString());
				}
			}
		}

		public static object Deserialize(string json)
		{
			if (json == null)
			{
				return null;
			}
			return Parser.Parse(json);
		}

		public static string Serialize(object obj)
		{
			return Serializer.Serialize(obj);
		}
	}
}
namespace UnityEngine.UI
{
	[AddComponentMenu("")]
	[DisallowMultipleComponent]
	[RequireComponent(typeof(RectTransform))]
	public abstract class LoopScrollRect : UIBehaviour, IInitializePotentialDragHandler, IEventSystemHandler, IBeginDragHandler, IEndDragHandler, IDragHandler, IScrollHandler, ICanvasElement, ILayoutElement, ILayoutGroup, ILayoutController
	{
		public delegate string prefabNameDelegate(int idx);

		public delegate int prefabCountDelegate(int idx);

		public enum MovementType
		{
			Unrestricted,
			Elastic,
			Clamped
		}

		public enum ScrollbarVisibility
		{
			Permanent,
			AutoHide,
			AutoHideAndExpandViewport
		}

		[Serializable]
		public class ScrollRectEvent : UnityEvent<Vector2>
		{
		}

		[Tooltip("Prefab Name in Resources")]
		public string prefabName;

		[HideInInspector]
		public prefabNameDelegate prefabNameFunc;

		[HideInInspector]
		public prefabCountDelegate prefabCountFunc;

		[Tooltip("Total count, negative means INFINITE mode")]
		public int totalCount;

		[HideInInspector]
		public int poolSize = 5;

		[NonSerialized]
		[HideInInspector]
		public object[] objectsToFill;

		[Tooltip("Threshold for preloading")]
		public float threshold = 100f;

		[Tooltip("Reverse direction for dragging")]
		public bool reverseDirection;

		[Tooltip("Rubber scale for outside")]
		public float rubberScale = 1f;

		protected int itemTypeStart;

		protected int itemTypeEnd;

		protected int directionSign;

		private float m_ContentSpacing = -1f;

		protected GridLayoutGroup m_GridLayout;

		private int m_ContentConstraintCount;

		[SerializeField]
		private RectTransform m_Content;

		[SerializeField]
		private bool m_Horizontal = true;

		[SerializeField]
		private bool m_Vertical = true;

		[SerializeField]
		private MovementType m_MovementType = MovementType.Elastic;

		[SerializeField]
		private float m_Elasticity = 0.1f;

		[SerializeField]
		private bool m_Inertia = true;

		[SerializeField]
		private float m_DecelerationRate = 0.135f;

		[SerializeField]
		private float m_ScrollSensitivity = 1f;

		[SerializeField]
		private RectTransform m_Viewport;

		[SerializeField]
		private Scrollbar m_HorizontalScrollbar;

		[SerializeField]
		private Scrollbar m_VerticalScrollbar;

		[SerializeField]
		private ScrollbarVisibility m_HorizontalScrollbarVisibility;

		[SerializeField]
		private ScrollbarVisibility m_VerticalScrollbarVisibility;

		[SerializeField]
		private float m_HorizontalScrollbarSpacing;

		[SerializeField]
		private float m_VerticalScrollbarSpacing;

		[SerializeField]
		private ScrollRectEvent m_OnValueChanged = new ScrollRectEvent();

		private Vector2 m_PointerStartLocalCursor = Vector2.zero;

		private Vector2 m_ContentStartPosition = Vector2.zero;

		private RectTransform m_ViewRect;

		private Bounds m_ContentBounds;

		private Bounds m_ViewBounds;

		private Vector2 m_Velocity;

		private bool m_Dragging;

		private Vector2 m_PrevPosition = Vector2.zero;

		private Bounds m_PrevContentBounds;

		private Bounds m_PrevViewBounds;

		[NonSerialized]
		private bool m_HasRebuiltLayout;

		private bool m_HSliderExpand;

		private bool m_VSliderExpand;

		private float m_HSliderHeight;

		private float m_VSliderWidth;

		[NonSerialized]
		private RectTransform m_Rect;

		private RectTransform m_HorizontalScrollbarRect;

		private RectTransform m_VerticalScrollbarRect;

		private DrivenRectTransformTracker m_Tracker;

		private readonly Vector3[] m_Corners = new Vector3[4];

		protected float contentSpacing
		{
			get
			{
				if (m_ContentSpacing >= 0f)
				{
					return m_ContentSpacing;
				}
				m_ContentSpacing = 0f;
				if (content != null)
				{
					HorizontalOrVerticalLayoutGroup component = content.GetComponent<HorizontalOrVerticalLayoutGroup>();
					if (component != null)
					{
						m_ContentSpacing = component.spacing;
					}
					m_GridLayout = content.GetComponent<GridLayoutGroup>();
					if (m_GridLayout != null)
					{
						m_ContentSpacing = GetDimension(m_GridLayout.spacing);
					}
				}
				return m_ContentSpacing;
			}
		}

		protected int contentConstraintCount
		{
			get
			{
				if (m_ContentConstraintCount > 0)
				{
					return m_ContentConstraintCount;
				}
				m_ContentConstraintCount = 1;
				if (content != null)
				{
					GridLayoutGroup component = content.GetComponent<GridLayoutGroup>();
					if (component != null)
					{
						if (component.constraint == GridLayoutGroup.Constraint.Flexible)
						{
							Debug.LogWarning("[LoopScrollRect] Flexible not supported yet");
						}
						m_ContentConstraintCount = component.constraintCount;
					}
				}
				return m_ContentConstraintCount;
			}
		}

		public RectTransform content
		{
			get
			{
				return m_Content;
			}
			set
			{
				m_Content = value;
			}
		}

		public bool horizontal
		{
			get
			{
				return m_Horizontal;
			}
			set
			{
				m_Horizontal = value;
			}
		}

		public bool vertical
		{
			get
			{
				return m_Vertical;
			}
			set
			{
				m_Vertical = value;
			}
		}

		public MovementType movementType
		{
			get
			{
				return m_MovementType;
			}
			set
			{
				m_MovementType = value;
			}
		}

		public float elasticity
		{
			get
			{
				return m_Elasticity;
			}
			set
			{
				m_Elasticity = value;
			}
		}

		public bool inertia
		{
			get
			{
				return m_Inertia;
			}
			set
			{
				m_Inertia = value;
			}
		}

		public float decelerationRate
		{
			get
			{
				return m_DecelerationRate;
			}
			set
			{
				m_DecelerationRate = value;
			}
		}

		public float scrollSensitivity
		{
			get
			{
				return m_ScrollSensitivity;
			}
			set
			{
				m_ScrollSensitivity = value;
			}
		}

		public RectTransform viewport
		{
			get
			{
				return m_Viewport;
			}
			set
			{
				m_Viewport = value;
				SetDirtyCaching();
			}
		}

		public Scrollbar horizontalScrollbar
		{
			get
			{
				return m_HorizontalScrollbar;
			}
			set
			{
				if ((bool)m_HorizontalScrollbar)
				{
					m_HorizontalScrollbar.onValueChanged.RemoveListener(SetHorizontalNormalizedPosition);
				}
				m_HorizontalScrollbar = value;
				if ((bool)m_HorizontalScrollbar)
				{
					m_HorizontalScrollbar.onValueChanged.AddListener(SetHorizontalNormalizedPosition);
				}
				SetDirtyCaching();
			}
		}

		public Scrollbar verticalScrollbar
		{
			get
			{
				return m_VerticalScrollbar;
			}
			set
			{
				if ((bool)m_VerticalScrollbar)
				{
					m_VerticalScrollbar.onValueChanged.RemoveListener(SetVerticalNormalizedPosition);
				}
				m_VerticalScrollbar = value;
				if ((bool)m_VerticalScrollbar)
				{
					m_VerticalScrollbar.onValueChanged.AddListener(SetVerticalNormalizedPosition);
				}
				SetDirtyCaching();
			}
		}

		public ScrollbarVisibility horizontalScrollbarVisibility
		{
			get
			{
				return m_HorizontalScrollbarVisibility;
			}
			set
			{
				m_HorizontalScrollbarVisibility = value;
				SetDirtyCaching();
			}
		}

		public ScrollbarVisibility verticalScrollbarVisibility
		{
			get
			{
				return m_VerticalScrollbarVisibility;
			}
			set
			{
				m_VerticalScrollbarVisibility = value;
				SetDirtyCaching();
			}
		}

		public float horizontalScrollbarSpacing
		{
			get
			{
				return m_HorizontalScrollbarSpacing;
			}
			set
			{
				m_HorizontalScrollbarSpacing = value;
				SetDirty();
			}
		}

		public float verticalScrollbarSpacing
		{
			get
			{
				return m_VerticalScrollbarSpacing;
			}
			set
			{
				m_VerticalScrollbarSpacing = value;
				SetDirty();
			}
		}

		public ScrollRectEvent onValueChanged
		{
			get
			{
				return m_OnValueChanged;
			}
			set
			{
				m_OnValueChanged = value;
			}
		}

		protected RectTransform viewRect
		{
			get
			{
				if (m_ViewRect == null)
				{
					m_ViewRect = m_Viewport;
				}
				if (m_ViewRect == null)
				{
					m_ViewRect = (RectTransform)base.transform;
				}
				return m_ViewRect;
			}
		}

		public Vector2 velocity
		{
			get
			{
				return m_Velocity;
			}
			set
			{
				m_Velocity = value;
			}
		}

		private RectTransform rectTransform
		{
			get
			{
				if (m_Rect == null)
				{
					m_Rect = GetComponent<RectTransform>();
				}
				return m_Rect;
			}
		}

		public Vector2 normalizedPosition
		{
			get
			{
				return new Vector2(horizontalNormalizedPosition, verticalNormalizedPosition);
			}
			set
			{
				SetNormalizedPosition(value.x, 0);
				SetNormalizedPosition(value.y, 1);
			}
		}

		public float horizontalNormalizedPosition
		{
			get
			{
				UpdateBounds();
				if (totalCount > 0 && itemTypeEnd > itemTypeStart)
				{
					float num = m_ContentBounds.size.x / (float)(itemTypeEnd - itemTypeStart);
					float num2 = num * (float)totalCount;
					float num3 = m_ContentBounds.min.x - num * (float)itemTypeStart;
					if (num2 <= m_ViewBounds.size.x)
					{
						return (m_ViewBounds.min.x > num3) ? 1 : 0;
					}
					return (m_ViewBounds.min.x - num3) / (num2 - m_ViewBounds.size.x);
				}
				return 0.5f;
			}
			set
			{
				SetNormalizedPosition(value, 0);
			}
		}

		public float verticalNormalizedPosition
		{
			get
			{
				UpdateBounds();
				if (totalCount > 0 && itemTypeEnd > itemTypeStart)
				{
					float num = m_ContentBounds.size.y / (float)(itemTypeEnd - itemTypeStart);
					float num2 = num * (float)totalCount;
					float num3 = m_ContentBounds.max.y + num * (float)itemTypeStart;
					if (num2 <= m_ViewBounds.size.y)
					{
						return (num3 > m_ViewBounds.max.y) ? 1 : 0;
					}
					return (num3 - m_ViewBounds.max.y) / (num2 - m_ViewBounds.size.y);
				}
				return 0.5f;
			}
			set
			{
				SetNormalizedPosition(value, 1);
			}
		}

		private bool hScrollingNeeded
		{
			get
			{
				if (Application.isPlaying)
				{
					return m_ContentBounds.size.x > m_ViewBounds.size.x + 0.01f;
				}
				return true;
			}
		}

		private bool vScrollingNeeded
		{
			get
			{
				if (Application.isPlaying)
				{
					return m_ContentBounds.size.y > m_ViewBounds.size.y + 0.01f;
				}
				return true;
			}
		}

		public virtual float minWidth => -1f;

		public virtual float preferredWidth => -1f;

		public virtual float flexibleWidth { get; private set; }

		public virtual float minHeight => -1f;

		public virtual float preferredHeight => -1f;

		public virtual float flexibleHeight => -1f;

		public virtual int layoutPriority => -1;

		protected abstract float GetSize(RectTransform item);

		protected abstract float GetDimension(Vector2 vector);

		protected abstract Vector2 GetVector(float value);

		protected virtual bool UpdateItems(Bounds viewBounds, Bounds contentBounds)
		{
			return false;
		}

		protected LoopScrollRect()
		{
			flexibleWidth = -1f;
		}

		private void SendMessageToNewObject(Transform go, int idx)
		{
			go.SendMessage("ScrollCellIndex", idx);
			if (objectsToFill != null)
			{
				object value = null;
				if (idx >= 0 && idx < objectsToFill.Length)
				{
					value = objectsToFill[idx];
				}
				go.SendMessage("ScrollCellContent", value, SendMessageOptions.DontRequireReceiver);
			}
		}

		private void ReturnObjectAndSendMessage(Transform go)
		{
			Debug.Log("haha...");
			go.SendMessage("ScrollCellReturn", SendMessageOptions.DontRequireReceiver);
			ResourceManager.Instance.ReturnObjectToPool(go.gameObject);
		}

		public void ClearCells()
		{
			if (Application.isPlaying)
			{
				itemTypeStart = 0;
				itemTypeEnd = 0;
				totalCount = 0;
				objectsToFill = null;
				for (int num = content.childCount - 1; num >= 0; num--)
				{
					ReturnObjectAndSendMessage(content.GetChild(num));
				}
			}
		}

		public void RefreshCells()
		{
			Debug.Log("haha...");
			if (!Application.isPlaying || !base.isActiveAndEnabled)
			{
				return;
			}
			itemTypeEnd = itemTypeStart;
			for (int i = 0; i < content.childCount; i++)
			{
				if (itemTypeEnd < totalCount)
				{
					SendMessageToNewObject(content.GetChild(i), itemTypeEnd);
					itemTypeEnd++;
				}
				else
				{
					ReturnObjectAndSendMessage(content.GetChild(i));
					i--;
				}
			}
		}

		public void RefillCells(int startIdx = 0)
		{
			if (!Application.isPlaying)
			{
				return;
			}
			StopMovement();
			itemTypeStart = (reverseDirection ? (totalCount - startIdx) : startIdx);
			itemTypeEnd = itemTypeStart;
			if (prefabNameFunc != null)
			{
				int num;
				for (num = 0; num < content.childCount; num++)
				{
					ReturnObjectAndSendMessage(content.GetChild(num));
					num--;
				}
			}
			else
			{
				for (int i = 0; i < content.childCount; i++)
				{
					if (totalCount >= 0 && itemTypeEnd >= totalCount)
					{
						ReturnObjectAndSendMessage(content.GetChild(i));
						i--;
					}
					else
					{
						SendMessageToNewObject(content.GetChild(i), itemTypeEnd);
						itemTypeEnd++;
					}
				}
			}
			Vector2 anchoredPosition = content.anchoredPosition;
			if (directionSign == -1)
			{
				anchoredPosition.y = 0f;
			}
			else if (directionSign == 1)
			{
				anchoredPosition.x = 0f;
			}
			content.anchoredPosition = anchoredPosition;
		}

		protected float NewItemAtStart()
		{
			if (totalCount >= 0 && itemTypeStart - contentConstraintCount < 0)
			{
				return 0f;
			}
			float num = 0f;
			for (int i = 0; i < contentConstraintCount; i++)
			{
				itemTypeStart--;
				RectTransform rectTransform = InstantiateNextItem(itemTypeStart);
				rectTransform.SetAsFirstSibling();
				num = Mathf.Max(GetSize(rectTransform), num);
			}
			if (!reverseDirection)
			{
				Vector2 vector = GetVector(num);
				content.anchoredPosition += vector;
				m_PrevPosition += vector;
				m_ContentStartPosition += vector;
			}
			return num;
		}

		protected float DeleteItemAtStart()
		{
			if ((totalCount >= 0 && itemTypeEnd >= totalCount - 1) || content.childCount == 0)
			{
				return 0f;
			}
			float num = 0f;
			for (int i = 0; i < contentConstraintCount; i++)
			{
				RectTransform rectTransform = content.GetChild(0) as RectTransform;
				num = Mathf.Max(GetSize(rectTransform), num);
				ReturnObjectAndSendMessage(rectTransform);
				itemTypeStart++;
				if (content.childCount == 0)
				{
					break;
				}
			}
			if (!reverseDirection)
			{
				Vector2 vector = GetVector(num);
				content.anchoredPosition -= vector;
				m_PrevPosition -= vector;
				m_ContentStartPosition -= vector;
			}
			return num;
		}

		protected float NewItemAtEnd()
		{
			if (totalCount >= 0 && itemTypeEnd >= totalCount)
			{
				return 0f;
			}
			float num = 0f;
			int num2 = contentConstraintCount - content.childCount % contentConstraintCount;
			for (int i = 0; i < num2; i++)
			{
				RectTransform item = InstantiateNextItem(itemTypeEnd);
				num = Mathf.Max(GetSize(item), num);
				itemTypeEnd++;
				if (totalCount >= 0 && itemTypeEnd >= totalCount)
				{
					break;
				}
			}
			if (reverseDirection)
			{
				Vector2 vector = GetVector(num);
				content.anchoredPosition -= vector;
				m_PrevPosition -= vector;
				m_ContentStartPosition -= vector;
			}
			return num;
		}

		protected float DeleteItemAtEnd()
		{
			if ((totalCount >= 0 && itemTypeStart < contentConstraintCount) || content.childCount == 0)
			{
				return 0f;
			}
			float num = 0f;
			for (int i = 0; i < contentConstraintCount; i++)
			{
				RectTransform rectTransform = content.GetChild(content.childCount - 1) as RectTransform;
				num = Mathf.Max(GetSize(rectTransform), num);
				ReturnObjectAndSendMessage(rectTransform);
				itemTypeEnd--;
				if (itemTypeEnd % contentConstraintCount == 0 || content.childCount == 0)
				{
					break;
				}
			}
			if (reverseDirection)
			{
				Vector2 vector = GetVector(num);
				content.anchoredPosition += vector;
				m_PrevPosition += vector;
				m_ContentStartPosition += vector;
			}
			return num;
		}

		private RectTransform InstantiateNextItem(int itemIdx)
		{
			string poolName = prefabName;
			int autoCreate = poolSize;
			if (prefabNameFunc != null)
			{
				poolName = prefabNameFunc(itemIdx);
			}
			if (prefabCountFunc != null)
			{
				autoCreate = prefabCountFunc(itemIdx);
			}
			RectTransform component = ResourceManager.Instance.GetObjectFromPool(poolName, autoActive: true, autoCreate).GetComponent<RectTransform>();
			component.transform.SetParent(content, worldPositionStays: false);
			component.gameObject.SetActive(value: true);
			SendMessageToNewObject(component, itemIdx);
			return component;
		}

		public virtual void Rebuild(CanvasUpdate executing)
		{
			if (executing == CanvasUpdate.Prelayout)
			{
				UpdateCachedData();
			}
			if (executing == CanvasUpdate.PostLayout)
			{
				UpdateBounds(updateItems: false);
				UpdateScrollbars(Vector2.zero);
				UpdatePrevData();
				m_HasRebuiltLayout = true;
			}
		}

		public virtual void LayoutComplete()
		{
		}

		public virtual void GraphicUpdateComplete()
		{
		}

		private void UpdateCachedData()
		{
			Transform transform = base.transform;
			m_HorizontalScrollbarRect = ((m_HorizontalScrollbar == null) ? null : (m_HorizontalScrollbar.transform as RectTransform));
			m_VerticalScrollbarRect = ((m_VerticalScrollbar == null) ? null : (m_VerticalScrollbar.transform as RectTransform));
			bool num = viewRect.parent == transform;
			bool flag = !m_HorizontalScrollbarRect || m_HorizontalScrollbarRect.parent == transform;
			bool flag2 = !m_VerticalScrollbarRect || m_VerticalScrollbarRect.parent == transform;
			bool flag3 = num && flag && flag2;
			m_HSliderExpand = flag3 && (bool)m_HorizontalScrollbarRect && horizontalScrollbarVisibility == ScrollbarVisibility.AutoHideAndExpandViewport;
			m_VSliderExpand = flag3 && (bool)m_VerticalScrollbarRect && verticalScrollbarVisibility == ScrollbarVisibility.AutoHideAndExpandViewport;
			m_HSliderHeight = ((m_HorizontalScrollbarRect == null) ? 0f : m_HorizontalScrollbarRect.rect.height);
			m_VSliderWidth = ((m_VerticalScrollbarRect == null) ? 0f : m_VerticalScrollbarRect.rect.width);
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			if ((bool)m_HorizontalScrollbar)
			{
				m_HorizontalScrollbar.onValueChanged.AddListener(SetHorizontalNormalizedPosition);
			}
			if ((bool)m_VerticalScrollbar)
			{
				m_VerticalScrollbar.onValueChanged.AddListener(SetVerticalNormalizedPosition);
			}
			CanvasUpdateRegistry.RegisterCanvasElementForLayoutRebuild(this);
		}

		protected override void OnDisable()
		{
			CanvasUpdateRegistry.UnRegisterCanvasElementForRebuild(this);
			if ((bool)m_HorizontalScrollbar)
			{
				m_HorizontalScrollbar.onValueChanged.RemoveListener(SetHorizontalNormalizedPosition);
			}
			if ((bool)m_VerticalScrollbar)
			{
				m_VerticalScrollbar.onValueChanged.RemoveListener(SetVerticalNormalizedPosition);
			}
			m_HasRebuiltLayout = false;
			m_Tracker.Clear();
			m_Velocity = Vector2.zero;
			LayoutRebuilder.MarkLayoutForRebuild(rectTransform);
			base.OnDisable();
		}

		public override bool IsActive()
		{
			if (base.IsActive())
			{
				return m_Content != null;
			}
			return false;
		}

		private void EnsureLayoutHasRebuilt()
		{
			if (!m_HasRebuiltLayout && !CanvasUpdateRegistry.IsRebuildingLayout())
			{
				Canvas.ForceUpdateCanvases();
			}
		}

		public virtual void StopMovement()
		{
			m_Velocity = Vector2.zero;
		}

		public virtual void OnScroll(PointerEventData data)
		{
			if (!IsActive())
			{
				return;
			}
			EnsureLayoutHasRebuilt();
			UpdateBounds();
			Vector2 scrollDelta = data.scrollDelta;
			scrollDelta.y *= -1f;
			if (vertical && !horizontal)
			{
				if (Mathf.Abs(scrollDelta.x) > Mathf.Abs(scrollDelta.y))
				{
					scrollDelta.y = scrollDelta.x;
				}
				scrollDelta.x = 0f;
			}
			if (horizontal && !vertical)
			{
				if (Mathf.Abs(scrollDelta.y) > Mathf.Abs(scrollDelta.x))
				{
					scrollDelta.x = scrollDelta.y;
				}
				scrollDelta.y = 0f;
			}
			Vector2 anchoredPosition = m_Content.anchoredPosition;
			anchoredPosition += scrollDelta * m_ScrollSensitivity;
			if (m_MovementType == MovementType.Clamped)
			{
				anchoredPosition += CalculateOffset(anchoredPosition - m_Content.anchoredPosition);
			}
			SetContentAnchoredPosition(anchoredPosition);
			UpdateBounds();
		}

		public virtual void OnInitializePotentialDrag(PointerEventData eventData)
		{
			if (eventData.button == PointerEventData.InputButton.Left)
			{
				m_Velocity = Vector2.zero;
			}
		}

		public virtual void OnBeginDrag(PointerEventData eventData)
		{
			if (eventData.button == PointerEventData.InputButton.Left && IsActive())
			{
				UpdateBounds();
				m_PointerStartLocalCursor = Vector2.zero;
				RectTransformUtility.ScreenPointToLocalPointInRectangle(viewRect, eventData.position, eventData.pressEventCamera, out m_PointerStartLocalCursor);
				m_ContentStartPosition = m_Content.anchoredPosition;
				m_Dragging = true;
			}
		}

		public virtual void OnEndDrag(PointerEventData eventData)
		{
			if (eventData.button == PointerEventData.InputButton.Left)
			{
				m_Dragging = false;
			}
		}

		public virtual void OnDrag(PointerEventData eventData)
		{
			if (eventData.button != 0 || !IsActive() || !RectTransformUtility.ScreenPointToLocalPointInRectangle(viewRect, eventData.position, eventData.pressEventCamera, out var localPoint))
			{
				return;
			}
			UpdateBounds();
			Vector2 vector = localPoint - m_PointerStartLocalCursor;
			Vector2 vector2 = m_ContentStartPosition + vector;
			Vector2 vector3 = CalculateOffset(vector2 - m_Content.anchoredPosition);
			vector2 += vector3;
			if (m_MovementType == MovementType.Elastic)
			{
				if (vector3.x != 0f)
				{
					vector2.x -= RubberDelta(vector3.x, m_ViewBounds.size.x) * rubberScale;
				}
				if (vector3.y != 0f)
				{
					vector2.y -= RubberDelta(vector3.y, m_ViewBounds.size.y) * rubberScale;
				}
			}
			SetContentAnchoredPosition(vector2);
		}

		protected virtual void SetContentAnchoredPosition(Vector2 position)
		{
			if (!m_Horizontal)
			{
				position.x = m_Content.anchoredPosition.x;
			}
			if (!m_Vertical)
			{
				position.y = m_Content.anchoredPosition.y;
			}
			if (position != m_Content.anchoredPosition)
			{
				m_Content.anchoredPosition = position;
				UpdateBounds();
			}
		}

		protected virtual void LateUpdate()
		{
			if (!m_Content)
			{
				return;
			}
			EnsureLayoutHasRebuilt();
			UpdateScrollbarVisibility();
			UpdateBounds();
			float unscaledDeltaTime = Time.unscaledDeltaTime;
			Vector2 vector = CalculateOffset(Vector2.zero);
			if (!m_Dragging && (vector != Vector2.zero || m_Velocity != Vector2.zero))
			{
				Vector2 anchoredPosition = m_Content.anchoredPosition;
				for (int i = 0; i < 2; i++)
				{
					if (m_MovementType == MovementType.Elastic && vector[i] != 0f)
					{
						float currentVelocity = m_Velocity[i];
						anchoredPosition[i] = Mathf.SmoothDamp(m_Content.anchoredPosition[i], m_Content.anchoredPosition[i] + vector[i], ref currentVelocity, m_Elasticity, float.PositiveInfinity, unscaledDeltaTime);
						m_Velocity[i] = currentVelocity;
					}
					else if (m_Inertia)
					{
						m_Velocity[i] *= Mathf.Pow(m_DecelerationRate, unscaledDeltaTime);
						if (Mathf.Abs(m_Velocity[i]) < 1f)
						{
							m_Velocity[i] = 0f;
						}
						anchoredPosition[i] += m_Velocity[i] * unscaledDeltaTime;
					}
					else
					{
						m_Velocity[i] = 0f;
					}
				}
				if (m_Velocity != Vector2.zero)
				{
					if (m_MovementType == MovementType.Clamped)
					{
						vector = CalculateOffset(anchoredPosition - m_Content.anchoredPosition);
						anchoredPosition += vector;
					}
					SetContentAnchoredPosition(anchoredPosition);
				}
			}
			if (m_Dragging && m_Inertia)
			{
				Vector3 b = (m_Content.anchoredPosition - m_PrevPosition) / unscaledDeltaTime;
				m_Velocity = Vector3.Lerp(m_Velocity, b, unscaledDeltaTime * 10f);
			}
			if (m_ViewBounds != m_PrevViewBounds || m_ContentBounds != m_PrevContentBounds || m_Content.anchoredPosition != m_PrevPosition)
			{
				UpdateScrollbars(vector);
				m_OnValueChanged.Invoke(normalizedPosition);
				UpdatePrevData();
			}
		}

		private void UpdatePrevData()
		{
			if (m_Content == null)
			{
				m_PrevPosition = Vector2.zero;
			}
			else
			{
				m_PrevPosition = m_Content.anchoredPosition;
			}
			m_PrevViewBounds = m_ViewBounds;
			m_PrevContentBounds = m_ContentBounds;
		}

		private void UpdateScrollbars(Vector2 offset)
		{
			if ((bool)m_HorizontalScrollbar)
			{
				if (m_ContentBounds.size.x > 0f && totalCount > 0)
				{
					m_HorizontalScrollbar.size = Mathf.Clamp01((m_ViewBounds.size.x - Mathf.Abs(offset.x)) / m_ContentBounds.size.x * (float)(itemTypeEnd - itemTypeStart) / (float)totalCount);
				}
				else
				{
					m_HorizontalScrollbar.size = 1f;
				}
				m_HorizontalScrollbar.value = horizontalNormalizedPosition;
			}
			if ((bool)m_VerticalScrollbar)
			{
				if (m_ContentBounds.size.y > 0f && totalCount > 0)
				{
					m_VerticalScrollbar.size = Mathf.Clamp01((m_ViewBounds.size.y - Mathf.Abs(offset.y)) / m_ContentBounds.size.y * (float)(itemTypeEnd - itemTypeStart) / (float)totalCount);
				}
				else
				{
					m_VerticalScrollbar.size = 1f;
				}
				m_VerticalScrollbar.value = verticalNormalizedPosition;
			}
		}

		private void SetHorizontalNormalizedPosition(float value)
		{
			SetNormalizedPosition(value, 0);
		}

		private void SetVerticalNormalizedPosition(float value)
		{
			SetNormalizedPosition(value, 1);
		}

		private void SetNormalizedPosition(float value, int axis)
		{
			if (totalCount > 0 && itemTypeEnd > itemTypeStart)
			{
				EnsureLayoutHasRebuilt();
				UpdateBounds();
				Vector3 localPosition = m_Content.localPosition;
				float num = localPosition[axis];
				switch (axis)
				{
				case 0:
				{
					float num5 = m_ContentBounds.size.x / (float)(itemTypeEnd - itemTypeStart);
					float num6 = num5 * (float)totalCount;
					float num7 = m_ContentBounds.min.x - num5 * (float)itemTypeStart;
					num += m_ViewBounds.min.x - value * (num6 - m_ViewBounds.size[axis]) - num7;
					break;
				}
				case 1:
				{
					float num2 = m_ContentBounds.size.y / (float)(itemTypeEnd - itemTypeStart);
					float num3 = num2 * (float)totalCount;
					float num4 = m_ContentBounds.max.y + num2 * (float)itemTypeStart;
					num -= num4 - value * (num3 - m_ViewBounds.size.y) - m_ViewBounds.max.y;
					break;
				}
				}
				if (Mathf.Abs(localPosition[axis] - num) > 0.01f)
				{
					localPosition[axis] = num;
					m_Content.localPosition = localPosition;
					m_Velocity[axis] = 0f;
					UpdateBounds();
				}
			}
		}

		private static float RubberDelta(float overStretching, float viewSize)
		{
			return (1f - 1f / (Mathf.Abs(overStretching) * 0.55f / viewSize + 1f)) * viewSize * Mathf.Sign(overStretching);
		}

		protected override void OnRectTransformDimensionsChange()
		{
			SetDirty();
		}

		public virtual void CalculateLayoutInputHorizontal()
		{
		}

		public virtual void CalculateLayoutInputVertical()
		{
		}

		public virtual void SetLayoutHorizontal()
		{
			m_Tracker.Clear();
			if (m_HSliderExpand || m_VSliderExpand)
			{
				m_Tracker.Add(this, viewRect, DrivenTransformProperties.Anchors | DrivenTransformProperties.AnchoredPosition | DrivenTransformProperties.SizeDelta);
				viewRect.anchorMin = Vector2.zero;
				viewRect.anchorMax = Vector2.one;
				viewRect.sizeDelta = Vector2.zero;
				viewRect.anchoredPosition = Vector2.zero;
				LayoutRebuilder.ForceRebuildLayoutImmediate(content);
				m_ViewBounds = new Bounds(viewRect.rect.center, viewRect.rect.size);
				m_ContentBounds = GetBounds();
			}
			if (m_VSliderExpand && vScrollingNeeded)
			{
				viewRect.sizeDelta = new Vector2(0f - (m_VSliderWidth + m_VerticalScrollbarSpacing), viewRect.sizeDelta.y);
				LayoutRebuilder.ForceRebuildLayoutImmediate(content);
				m_ViewBounds = new Bounds(viewRect.rect.center, viewRect.rect.size);
				m_ContentBounds = GetBounds();
			}
			if (m_HSliderExpand && hScrollingNeeded)
			{
				viewRect.sizeDelta = new Vector2(viewRect.sizeDelta.x, 0f - (m_HSliderHeight + m_HorizontalScrollbarSpacing));
				m_ViewBounds = new Bounds(viewRect.rect.center, viewRect.rect.size);
				m_ContentBounds = GetBounds();
			}
			if (m_VSliderExpand && vScrollingNeeded && viewRect.sizeDelta.x == 0f && viewRect.sizeDelta.y < 0f)
			{
				viewRect.sizeDelta = new Vector2(0f - (m_VSliderWidth + m_VerticalScrollbarSpacing), viewRect.sizeDelta.y);
			}
		}

		public virtual void SetLayoutVertical()
		{
			UpdateScrollbarLayout();
			m_ViewBounds = new Bounds(viewRect.rect.center, viewRect.rect.size);
			m_ContentBounds = GetBounds();
		}

		private void UpdateScrollbarVisibility()
		{
			if ((bool)m_VerticalScrollbar && m_VerticalScrollbarVisibility != 0 && m_VerticalScrollbar.gameObject.activeSelf != vScrollingNeeded)
			{
				m_VerticalScrollbar.gameObject.SetActive(vScrollingNeeded);
			}
			if ((bool)m_HorizontalScrollbar && m_HorizontalScrollbarVisibility != 0 && m_HorizontalScrollbar.gameObject.activeSelf != hScrollingNeeded)
			{
				m_HorizontalScrollbar.gameObject.SetActive(hScrollingNeeded);
			}
		}

		private void UpdateScrollbarLayout()
		{
			if (m_VSliderExpand && (bool)m_HorizontalScrollbar)
			{
				m_Tracker.Add(this, m_HorizontalScrollbarRect, DrivenTransformProperties.AnchoredPositionX | DrivenTransformProperties.AnchorMinX | DrivenTransformProperties.AnchorMaxX | DrivenTransformProperties.SizeDeltaX);
				m_HorizontalScrollbarRect.anchorMin = new Vector2(0f, m_HorizontalScrollbarRect.anchorMin.y);
				m_HorizontalScrollbarRect.anchorMax = new Vector2(1f, m_HorizontalScrollbarRect.anchorMax.y);
				m_HorizontalScrollbarRect.anchoredPosition = new Vector2(0f, m_HorizontalScrollbarRect.anchoredPosition.y);
				if (vScrollingNeeded)
				{
					m_HorizontalScrollbarRect.sizeDelta = new Vector2(0f - (m_VSliderWidth + m_VerticalScrollbarSpacing), m_HorizontalScrollbarRect.sizeDelta.y);
				}
				else
				{
					m_HorizontalScrollbarRect.sizeDelta = new Vector2(0f, m_HorizontalScrollbarRect.sizeDelta.y);
				}
			}
			if (m_HSliderExpand && (bool)m_VerticalScrollbar)
			{
				m_Tracker.Add(this, m_VerticalScrollbarRect, DrivenTransformProperties.AnchoredPositionY | DrivenTransformProperties.AnchorMinY | DrivenTransformProperties.AnchorMaxY | DrivenTransformProperties.SizeDeltaY);
				m_VerticalScrollbarRect.anchorMin = new Vector2(m_VerticalScrollbarRect.anchorMin.x, 0f);
				m_VerticalScrollbarRect.anchorMax = new Vector2(m_VerticalScrollbarRect.anchorMax.x, 1f);
				m_VerticalScrollbarRect.anchoredPosition = new Vector2(m_VerticalScrollbarRect.anchoredPosition.x, 0f);
				if (hScrollingNeeded)
				{
					m_VerticalScrollbarRect.sizeDelta = new Vector2(m_VerticalScrollbarRect.sizeDelta.x, 0f - (m_HSliderHeight + m_HorizontalScrollbarSpacing));
				}
				else
				{
					m_VerticalScrollbarRect.sizeDelta = new Vector2(m_VerticalScrollbarRect.sizeDelta.x, 0f);
				}
			}
		}

		private void UpdateBounds(bool updateItems = true)
		{
			m_ViewBounds = new Bounds(viewRect.rect.center, viewRect.rect.size);
			m_ContentBounds = GetBounds();
			if (!(m_Content == null))
			{
				if (Application.isPlaying && updateItems && UpdateItems(m_ViewBounds, m_ContentBounds))
				{
					Canvas.ForceUpdateCanvases();
					m_ContentBounds = GetBounds();
				}
				Vector3 size = m_ContentBounds.size;
				Vector3 center = m_ContentBounds.center;
				Vector3 vector = m_ViewBounds.size - size;
				if (vector.x > 0f)
				{
					center.x -= vector.x * (m_Content.pivot.x - 0.5f);
					size.x = m_ViewBounds.size.x;
				}
				if (vector.y > 0f)
				{
					center.y -= vector.y * (m_Content.pivot.y - 0.5f);
					size.y = m_ViewBounds.size.y;
				}
				m_ContentBounds.size = size;
				m_ContentBounds.center = center;
			}
		}

		private Bounds GetBounds()
		{
			if (m_Content == null)
			{
				return default(Bounds);
			}
			Vector3 vector = new Vector3(float.MaxValue, float.MaxValue, float.MaxValue);
			Vector3 vector2 = new Vector3(float.MinValue, float.MinValue, float.MinValue);
			Matrix4x4 worldToLocalMatrix = viewRect.worldToLocalMatrix;
			m_Content.GetWorldCorners(m_Corners);
			for (int i = 0; i < 4; i++)
			{
				Vector3 lhs = worldToLocalMatrix.MultiplyPoint3x4(m_Corners[i]);
				vector = Vector3.Min(lhs, vector);
				vector2 = Vector3.Max(lhs, vector2);
			}
			Bounds result = new Bounds(vector, Vector3.zero);
			result.Encapsulate(vector2);
			return result;
		}

		private Vector2 CalculateOffset(Vector2 delta)
		{
			Vector2 zero = Vector2.zero;
			if (m_MovementType == MovementType.Unrestricted)
			{
				return zero;
			}
			Vector2 vector = m_ContentBounds.min;
			Vector2 vector2 = m_ContentBounds.max;
			if (m_Horizontal)
			{
				vector.x += delta.x;
				vector2.x += delta.x;
				if (vector.x > m_ViewBounds.min.x)
				{
					zero.x = m_ViewBounds.min.x - vector.x;
				}
				else if (vector2.x < m_ViewBounds.max.x)
				{
					zero.x = m_ViewBounds.max.x - vector2.x;
				}
			}
			if (m_Vertical)
			{
				vector.y += delta.y;
				vector2.y += delta.y;
				if (vector2.y < m_ViewBounds.max.y)
				{
					zero.y = m_ViewBounds.max.y - vector2.y;
				}
				else if (vector.y > m_ViewBounds.min.y)
				{
					zero.y = m_ViewBounds.min.y - vector.y;
				}
			}
			return zero;
		}

		protected void SetDirty()
		{
			if (IsActive())
			{
				LayoutRebuilder.MarkLayoutForRebuild(rectTransform);
			}
		}

		protected void SetDirtyCaching()
		{
			if (IsActive())
			{
				CanvasUpdateRegistry.RegisterCanvasElementForLayoutRebuild(this);
				LayoutRebuilder.MarkLayoutForRebuild(rectTransform);
			}
		}

		[SpecialName]
		Transform ICanvasElement.get_transform()
		{
			return base.transform;
		}
	}
	[AddComponentMenu("UI/Loop Vertical Scroll Rect", 51)]
	[DisallowMultipleComponent]
	public class LoopVerticalScrollRect : LoopScrollRect
	{
		protected override float GetSize(RectTransform item)
		{
			Debug.Log("fassssonga ....");
			float num = base.contentSpacing;
			if (m_GridLayout != null)
			{
				return num + m_GridLayout.cellSize.y;
			}
			return num + LayoutUtility.GetPreferredHeight(item);
		}

		protected override float GetDimension(Vector2 vector)
		{
			return vector.y;
		}

		protected override Vector2 GetVector(float value)
		{
			return new Vector2(0f, value);
		}

		protected override void Awake()
		{
			base.Awake();
			directionSign = -1;
			GridLayoutGroup component = base.content.GetComponent<GridLayoutGroup>();
			if (component != null && component.constraint != GridLayoutGroup.Constraint.FixedColumnCount)
			{
				Debug.Log("[LoopHorizontalScrollRect] unsupported GridLayoutGroup constraint");
			}
		}

		protected override bool UpdateItems(Bounds viewBounds, Bounds contentBounds)
		{
			bool result = false;
			if (viewBounds.min.y < contentBounds.min.y + 1f)
			{
				float num = NewItemAtEnd();
				if (num > 0f)
				{
					if (threshold < num)
					{
						threshold = num * 1.1f;
					}
					result = true;
				}
			}
			else if (viewBounds.min.y > contentBounds.min.y + threshold && DeleteItemAtEnd() > 0f)
			{
				result = true;
			}
			if (viewBounds.max.y > contentBounds.max.y - 1f)
			{
				float num2 = NewItemAtStart();
				if (num2 > 0f)
				{
					if (threshold < num2)
					{
						threshold = num2 * 1.1f;
					}
					result = true;
				}
			}
			else if (viewBounds.max.y < contentBounds.max.y - threshold && DeleteItemAtStart() > 0f)
			{
				result = true;
			}
			return result;
		}
	}
}
namespace MarchingBytes
{
	public class PoolObject : MonoBehaviour
	{
		public string poolName;

		public bool isPooled;
	}
}
namespace DG.Tweening
{
	[AddComponentMenu("DOTween/DOTween Animation")]
	public class DOTweenAnimation : ABSAnimationComponent
	{
		public float delay;

		public float duration = 1f;

		public Ease easeType = Ease.OutQuad;

		public AnimationCurve easeCurve = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(1f, 1f));

		public LoopType loopType;

		public int loops = 1;

		public string id = "";

		public bool isRelative;

		public bool isFrom;

		public bool isIndependentUpdate;

		public bool autoKill = true;

		public bool isActive = true;

		public bool isValid;

		public UnityEngine.Component target;

		public DOTweenAnimationType animationType;

		public bool autoPlay = true;

		public float endValueFloat;

		public Vector3 endValueV3;

		public Color endValueColor = new Color(1f, 1f, 1f, 1f);

		public string endValueString = "";

		public Rect endValueRect = new Rect(0f, 0f, 0f, 0f);

		public bool optionalBool0;

		public float optionalFloat0;

		public int optionalInt0;

		public RotateMode optionalRotationMode;

		public ScrambleMode optionalScrambleMode;

		public string optionalString;

		private int _playCount = -1;

		private void Awake()
		{
			if (isActive && isValid)
			{
				CreateTween();
			}
		}

		private void OnDestroy()
		{
			if (tween != null && tween.IsActive())
			{
				tween.Kill();
			}
			tween = null;
		}

		public void CreateTween()
		{
			if (target == null)
			{
				UnityEngine.Debug.LogWarning($"{base.gameObject.name} :: This tween's target is NULL, because the animation was created with a DOTween Pro version older than 0.9.255. To fix this, exit Play mode then simply select this object, and it will update automatically", base.gameObject);
				return;
			}
			Type type = target.GetType();
			switch (animationType)
			{
			case DOTweenAnimationType.Move:
				if (type.IsSameOrSubclassOf(typeof(RectTransform)))
				{
					tween = ((RectTransform)target).DOAnchorPos3D(endValueV3, duration, optionalBool0);
				}
				else if (type.IsSameOrSubclassOf(typeof(Transform)))
				{
					tween = ((Transform)target).DOMove(endValueV3, duration, optionalBool0);
				}
				else if (type.IsSameOrSubclassOf(typeof(Rigidbody2D)))
				{
					tween = ((Rigidbody2D)target).DOMove(endValueV3, duration, optionalBool0);
				}
				else if (type.IsSameOrSubclassOf(typeof(Rigidbody)))
				{
					tween = ((Rigidbody)target).DOMove(endValueV3, duration, optionalBool0);
				}
				break;
			case DOTweenAnimationType.LocalMove:
				tween = base.transform.DOLocalMove(endValueV3, duration, optionalBool0);
				break;
			case DOTweenAnimationType.Rotate:
				if (type.IsSameOrSubclassOf(typeof(Transform)))
				{
					tween = ((Transform)target).DORotate(endValueV3, duration, optionalRotationMode);
				}
				else if (type.IsSameOrSubclassOf(typeof(Rigidbody2D)))
				{
					tween = ((Rigidbody2D)target).DORotate(endValueFloat, duration);
				}
				else if (type.IsSameOrSubclassOf(typeof(Rigidbody)))
				{
					tween = ((Rigidbody)target).DORotate(endValueV3, duration, optionalRotationMode);
				}
				break;
			case DOTweenAnimationType.LocalRotate:
				tween = base.transform.DOLocalRotate(endValueV3, duration, optionalRotationMode);
				break;
			case DOTweenAnimationType.Scale:
				tween = base.transform.DOScale(optionalBool0 ? new Vector3(endValueFloat, endValueFloat, endValueFloat) : endValueV3, duration);
				break;
			case DOTweenAnimationType.Color:
				isRelative = false;
				if (type.IsSameOrSubclassOf(typeof(SpriteRenderer)))
				{
					tween = ((SpriteRenderer)target).DOColor(endValueColor, duration);
				}
				else if (type.IsSameOrSubclassOf(typeof(Renderer)))
				{
					tween = ((Renderer)target).material.DOColor(endValueColor, duration);
				}
				else if (type.IsSameOrSubclassOf(typeof(Image)))
				{
					tween = ((Image)target).DOColor(endValueColor, duration);
				}
				else if (type.IsSameOrSubclassOf(typeof(Text)))
				{
					tween = ((Text)target).DOColor(endValueColor, duration);
				}
				break;
			case DOTweenAnimationType.Fade:
				isRelative = false;
				if (type.IsSameOrSubclassOf(typeof(SpriteRenderer)))
				{
					tween = ((SpriteRenderer)target).DOFade(endValueFloat, duration);
				}
				else if (type.IsSameOrSubclassOf(typeof(Renderer)))
				{
					tween = ((Renderer)target).material.DOFade(endValueFloat, duration);
				}
				else if (type.IsSameOrSubclassOf(typeof(Image)))
				{
					tween = ((Image)target).DOFade(endValueFloat, duration);
				}
				else if (type.IsSameOrSubclassOf(typeof(Text)))
				{
					tween = ((Text)target).DOFade(endValueFloat, duration);
				}
				break;
			case DOTweenAnimationType.Text:
				if (type.IsSameOrSubclassOf(typeof(Text)))
				{
					tween = ((Text)target).DOText(endValueString, duration, optionalBool0, optionalScrambleMode, optionalString);
				}
				break;
			case DOTweenAnimationType.PunchPosition:
				if (type.IsSameOrSubclassOf(typeof(RectTransform)))
				{
					tween = ((RectTransform)target).DOPunchAnchorPos(endValueV3, duration, optionalInt0, optionalFloat0, optionalBool0);
				}
				else if (type.IsSameOrSubclassOf(typeof(Transform)))
				{
					tween = ((Transform)target).DOPunchPosition(endValueV3, duration, optionalInt0, optionalFloat0, optionalBool0);
				}
				break;
			case DOTweenAnimationType.PunchScale:
				tween = base.transform.DOPunchScale(endValueV3, duration, optionalInt0, optionalFloat0);
				break;
			case DOTweenAnimationType.PunchRotation:
				tween = base.transform.DOPunchRotation(endValueV3, duration, optionalInt0, optionalFloat0);
				break;
			case DOTweenAnimationType.ShakePosition:
				if (type.IsSameOrSubclassOf(typeof(RectTransform)))
				{
					tween = ((RectTransform)target).DOShakeAnchorPos(duration, endValueV3, optionalInt0, optionalFloat0, optionalBool0);
				}
				if (type.IsSameOrSubclassOf(typeof(Transform)))
				{
					tween = ((Transform)target).DOShakePosition(duration, endValueV3, optionalInt0, optionalFloat0, optionalBool0);
				}
				break;
			case DOTweenAnimationType.ShakeScale:
				tween = base.transform.DOShakeScale(duration, endValueV3, optionalInt0, optionalFloat0);
				break;
			case DOTweenAnimationType.ShakeRotation:
				tween = base.transform.DOShakeRotation(duration, endValueV3, optionalInt0, optionalFloat0);
				break;
			case DOTweenAnimationType.CameraAspect:
				tween = ((Camera)target).DOAspect(endValueFloat, duration);
				break;
			case DOTweenAnimationType.CameraBackgroundColor:
				tween = ((Camera)target).DOColor(endValueColor, duration);
				break;
			case DOTweenAnimationType.CameraFieldOfView:
				tween = ((Camera)target).DOFieldOfView(endValueFloat, duration);
				break;
			case DOTweenAnimationType.CameraOrthoSize:
				tween = ((Camera)target).DOOrthoSize(endValueFloat, duration);
				break;
			case DOTweenAnimationType.CameraPixelRect:
				tween = ((Camera)target).DOPixelRect(endValueRect, duration);
				break;
			case DOTweenAnimationType.CameraRect:
				tween = ((Camera)target).DORect(endValueRect, duration);
				break;
			}
			if (tween == null)
			{
				return;
			}
			if (isFrom)
			{
				((Tweener)tween).From(isRelative);
			}
			else
			{
				tween.SetRelative(isRelative);
			}
			tween.SetTarget(base.gameObject).SetDelay(delay).SetLoops(loops, loopType)
				.SetAutoKill(autoKill)
				.OnKill(delegate
				{
					tween = null;
				});
			if (easeType == Ease.INTERNAL_Custom)
			{
				tween.SetEase(easeCurve);
			}
			else
			{
				tween.SetEase(easeType);
			}
			if (!string.IsNullOrEmpty(id))
			{
				tween.SetId(id);
			}
			tween.SetUpdate(isIndependentUpdate);
			if (hasOnStart)
			{
				if (onStart != null)
				{
					tween.OnStart(onStart.Invoke);
				}
			}
			else
			{
				onStart = null;
			}
			if (hasOnPlay)
			{
				if (onPlay != null)
				{
					tween.OnPlay(onPlay.Invoke);
				}
			}
			else
			{
				onPlay = null;
			}
			if (hasOnUpdate)
			{
				if (onUpdate != null)
				{
					tween.OnUpdate(onUpdate.Invoke);
				}
			}
			else
			{
				onUpdate = null;
			}
			if (hasOnStepComplete)
			{
				if (onStepComplete != null)
				{
					tween.OnStepComplete(onStepComplete.Invoke);
				}
			}
			else
			{
				onStepComplete = null;
			}
			if (hasOnComplete)
			{
				if (onComplete != null)
				{
					tween.OnComplete(onComplete.Invoke);
				}
			}
			else
			{
				onComplete = null;
			}
			if (autoPlay)
			{
				tween.Play();
			}
			else
			{
				tween.Pause();
			}
		}

		public override void DOPlay()
		{
			DOTween.Play(base.gameObject);
		}

		public override void DOPlayBackwards()
		{
			DOTween.PlayBackwards(base.gameObject);
		}

		public override void DOPlayForward()
		{
			DOTween.PlayForward(base.gameObject);
		}

		public override void DOPause()
		{
			DOTween.Pause(base.gameObject);
		}

		public override void DOTogglePause()
		{
			DOTween.TogglePause(base.gameObject);
		}

		public override void DORewind()
		{
			_playCount = -1;
			DOTweenAnimation[] components = base.gameObject.GetComponents<DOTweenAnimation>();
			for (int num = components.Length - 1; num > -1; num--)
			{
				Tween tween = components[num].tween;
				if (tween != null && tween.IsInitialized())
				{
					components[num].tween.Rewind();
				}
			}
		}

		public override void DORestart(bool fromHere = false)
		{
			_playCount = -1;
			if (tween == null)
			{
				if (DG.Tweening.Core.Debugger.logPriority > 1)
				{
					DG.Tweening.Core.Debugger.LogNullTween(tween);
				}
				return;
			}
			if (fromHere && isRelative)
			{
				ReEvaluateRelativeTween();
			}
			DOTween.Restart(base.gameObject);
		}

		public override void DOComplete()
		{
			DOTween.Complete(base.gameObject);
		}

		public override void DOKill()
		{
			DOTween.Kill(base.gameObject);
			tween = null;
		}

		public void DOPlayById(string id)
		{
			DOTween.Play(base.gameObject, id);
		}

		public void DOPlayAllById(string id)
		{
			DOTween.Play(id);
		}

		public void DOPlayNext()
		{
			DOTweenAnimation[] components = GetComponents<DOTweenAnimation>();
			while (_playCount < components.Length - 1)
			{
				_playCount++;
				DOTweenAnimation dOTweenAnimation = components[_playCount];
				if (dOTweenAnimation != null && dOTweenAnimation.tween != null && !dOTweenAnimation.tween.IsPlaying() && !dOTweenAnimation.tween.IsComplete())
				{
					dOTweenAnimation.tween.Play();
					break;
				}
			}
		}

		public void DORewindAndPlayNext()
		{
			_playCount = -1;
			DOTween.Rewind(base.gameObject);
			DOPlayNext();
		}

		public void DORestartById(string id)
		{
			_playCount = -1;
			DOTween.Restart(base.gameObject, id);
		}

		public void DORestartAllById(string id)
		{
			_playCount = -1;
			DOTween.Restart(id);
		}

		public List<Tween> GetTweens()
		{
			return DOTween.TweensByTarget(base.gameObject);
		}

		private void ReEvaluateRelativeTween()
		{
			if (animationType == DOTweenAnimationType.Move)
			{
				((Tweener)tween).ChangeEndValue(base.transform.position + endValueV3, snapStartValue: true);
			}
			else if (animationType == DOTweenAnimationType.LocalMove)
			{
				((Tweener)tween).ChangeEndValue(base.transform.localPosition + endValueV3, snapStartValue: true);
			}
		}
	}
	public static class DOTweenAnimationExtensions
	{
		public static bool IsSameOrSubclassOf(this Type t, Type tBase)
		{
			if (!t.IsSubclassOf(tBase))
			{
				return t == tBase;
			}
			return true;
		}
	}
}
namespace Painter
{
	public class ColorAtlas : MonoBehaviour
	{
		[SerializeField]
		private Color color = Color.white;

		public RawImage ColorZone;

		public Vector2 ColorZoneEdga = Vector2.zero;

		public RawImage ColorHue;

		public Slider HueSlider;

		public RectTransform cursor;

		public Image view;

		[HideInInspector]
		public Texture2D _colorZone;

		public Transform rightHand;

		public Color Color
		{
			get
			{
				return color;
			}
			set
			{
				if (this.ChangeColor != null)
				{
					this.ChangeColor(this, value);
				}
				color = value;
			}
		}

		public ColorAtlasDye ColorAtlasDye { get; private set; }

		public ColorAtlasSlider ColorAtlasSlider { get; private set; }

		public event Action<ColorAtlas, Color> ChangeColor;

		private void Awake()
		{
			HueSlider.maxValue = 0.999f;
			HueSlider.minValue = 0f;
			HueSlider.onValueChanged.AddListener(UpdateColorAtlas);
			ColorAtlasDye = ColorZone.gameObject.AddComponent<ColorAtlasDye>();
			ColorAtlasDye.colorAtlas = this;
			ColorAtlasSlider = HueSlider.gameObject.AddComponent<ColorAtlasSlider>();
			ColorAtlasSlider.colorAtlas = this;
			ColorAtlasSlider.rightHand = rightHand;
			_colorZone = new Texture2D(640, 640, TextureFormat.ARGB32, mipChain: false);
			ColorZone.texture = _colorZone;
			UpdateColorAtlas(0f);
			ColorHue.texture = CreateHue(4, 32);
		}

		private void Start()
		{
			Color = color;
		}

		public void UpdateColorAtlas(float i)
		{
			i = Mathf.Abs(i % 1f);
			Color[] array = new Color[_colorZone.GetPixels().Length];
			int num = (int)Mathf.Sqrt(array.Length);
			for (int j = 0; j < _colorZone.height; j++)
			{
				for (int k = 0; k < _colorZone.width; k++)
				{
					array[k + j * num] = Color.HSVToRGB(i, (float)k / (float)_colorZone.width, (float)j / (float)_colorZone.height);
				}
			}
			_colorZone.SetPixels(array);
			_colorZone.Apply();
		}

		private Texture2D CreateHue(int width, int height)
		{
			Texture2D texture2D = new Texture2D(width, height, TextureFormat.RGBA32, mipChain: false);
			Color[] array = new Color[width * height];
			for (int i = 0; i < height; i++)
			{
				for (int j = 0; j < width; j++)
				{
					array[j + i * width] = Color.HSVToRGB((float)i / (float)height, 1f, 1f);
				}
			}
			texture2D.SetPixels(array);
			texture2D.Apply();
			return texture2D;
		}
	}
	public class ColorAtlasDye : MonoBehaviour, IPointerDownHandler, IEventSystemHandler, IDragHandler, IPointerUpHandler
	{
		public ColorAtlas colorAtlas;

		private RectTransform _m;

		private Color final;

		private CanvasScaler _c;

		private void Start()
		{
			_m = GetComponent<RectTransform>();
			_c = base.transform.GetComponentInParent<CanvasScaler>();
			if (_c == null)
			{
				do
				{
					_c = _c.GetComponentInParent<CanvasScaler>();
				}
				while (!(_c != null));
			}
			colorAtlas.ChangeColor += SetCursorPos;
		}

		public void OnPointerDown(PointerEventData eventData)
		{
			DyePaint(eventData);
		}

		public void OnDrag(PointerEventData eventData)
		{
			DyePaint(eventData);
		}

		public void OnPointerUp(PointerEventData eventData)
		{
			colorAtlas.Color = final;
		}

		private void DyePaint(PointerEventData eventData)
		{
			Vector2 pos = eventData.position;
			Vector2 cursorUV = GetCursorUV(ref pos);
			if (colorAtlas.cursor != null)
			{
				colorAtlas.cursor.position = pos;
			}
			final = colorAtlas._colorZone.GetPixelBilinear(cursorUV.x, cursorUV.y);
			if (colorAtlas.view != null)
			{
				colorAtlas.view.color = final;
			}
		}

		public void SetCursorPos(ColorAtlas sender, Color color)
		{
			Rect rect = MyRectToScreen();
			Vector3 zero = Vector3.zero;
			Color.RGBToHSV(color, out zero.z, out zero.x, out zero.y);
			Vector2 vector = new Vector2(Mathf.Clamp(Mathf.Lerp(rect.xMin, rect.xMax, zero.x), rect.xMin + colorAtlas.ColorZoneEdga.x, rect.xMax - colorAtlas.ColorZoneEdga.x), Mathf.Clamp(Mathf.Lerp(rect.yMin, rect.yMax, zero.y), rect.yMin + colorAtlas.ColorZoneEdga.y, rect.yMax - colorAtlas.ColorZoneEdga.y));
			if (colorAtlas.cursor != null)
			{
				colorAtlas.cursor.position = vector;
			}
		}

		public Color GetCursorColor()
		{
			_ = Color.white;
			Vector2 pos = new Vector2(colorAtlas.cursor.position.x, colorAtlas.cursor.position.y);
			Vector2 cursorUV = GetCursorUV(ref pos);
			return colorAtlas._colorZone.GetPixelBilinear(cursorUV.x, cursorUV.y);
		}

		private Vector2 GetCursorUV(ref Vector2 pos)
		{
			Rect rect = MyRectToScreen();
			pos = new Vector2(Mathf.Clamp(pos.x, rect.xMin + colorAtlas.ColorZoneEdga.x, rect.xMax - colorAtlas.ColorZoneEdga.x), Mathf.Clamp(pos.y, rect.yMin + colorAtlas.ColorZoneEdga.y, rect.yMax - colorAtlas.ColorZoneEdga.y));
			return new Vector2(Mathf.InverseLerp(rect.xMin, rect.xMax, pos.x), Mathf.InverseLerp(rect.yMin, rect.yMax, pos.y));
		}

		private Rect MyRectToScreen()
		{
			Vector2 size = new Vector2(_m.rect.width / _c.referenceResolution.x * (float)UnityEngine.Screen.width, _m.rect.height / _c.referenceResolution.y * (float)UnityEngine.Screen.height);
			Vector2 position = new Vector2(_m.position.x - size.x / 2f, _m.position.y - size.y / 2f);
			return new Rect(position, size);
		}
	}
	public class ColorAtlasSlider : MonoBehaviour, IPointerDownHandler, IEventSystemHandler, IDragHandler, IPointerUpHandler
	{
		public ColorAtlas colorAtlas;

		public Transform rightHand;

		private LineRenderer lineRenderer;

		private bool isPress;

		private Slider _s;

		private void Start()
		{
			_s = base.gameObject.GetComponent<Slider>();
			colorAtlas.ChangeColor += delegate(ColorAtlas a, Color c)
			{
				Color color = default(Color);
				Color.RGBToHSV(c, out color.r, out color.g, out color.b);
				_s.value = color.r;
			};
			lineRenderer = rightHand.GetComponent<LineRenderer>();
		}

		private void Update()
		{
			if (Physics.Raycast(new Ray(rightHand.position, rightHand.forward), out var hitInfo, 600f, 1 << LayerMask.NameToLayer("JingUI")))
			{
				lineRenderer.enabled = true;
				lineRenderer.SetPosition(0, rightHand.position);
				lineRenderer.SetPosition(1, hitInfo.point);
				if (isPress && colorAtlas.view != null)
				{
					colorAtlas.view.color = colorAtlas.ColorAtlasDye.GetCursorColor();
				}
			}
			else
			{
				lineRenderer.enabled = false;
			}
		}

		public void OnPointerDown(PointerEventData eventData)
		{
			if (colorAtlas.view != null)
			{
				colorAtlas.view.color = colorAtlas.ColorAtlasDye.GetCursorColor();
			}
		}

		public void OnDrag(PointerEventData eventData)
		{
			if (colorAtlas.view != null)
			{
				colorAtlas.view.color = colorAtlas.ColorAtlasDye.GetCursorColor();
			}
		}

		public void OnPointerUp(PointerEventData eventData)
		{
			colorAtlas.Color = colorAtlas.ColorAtlasDye.GetCursorColor();
		}
	}
}
namespace VRTK.Examples
{
	public class UI_Keyboard : MonoBehaviour
	{
		private InputField input;

		public ShuRufa 拼音输入法;

		private bool 是否中文 = true;

		private bool 是否小写;

		public Text 内容文本;

		public void 选字(int character)
		{
			if (拼音输入法.返回输入状态())
			{
				内容文本.text += Static.选字[character];
				拼音输入法.输入结束();
			}
		}

		public void 空格()
		{
			if (拼音输入法.返回输入状态())
			{
				ClickKey("1");
			}
			else
			{
				内容文本.text += " ";
			}
		}

		public void ClickKey(string character)
		{
			MonoBehaviour.print("88888888拼音输入的字母：" + character);
			MonoBehaviour.print(GUI.GetNameOfFocusedControl());
			InputField component = GameObject.Find("/=布编程/拼音/杜").GetComponent<InputField>();
			if (!是否中文)
			{
				if (是否小写)
				{
					component.text += character.ToLower();
				}
				return;
			}
			string pattern = "^[a-zA-Z0-9]*$";
			if (Regex.IsMatch(character, pattern))
			{
				string text = 拼音输入法.输入(character.ToLower());
				MonoBehaviour.print(text);
				component.text += text;
			}
			else if (character == "-" || character == "=")
			{
				if (character == "-")
				{
					拼音输入法.上一页();
				}
				else
				{
					拼音输入法.下一页();
				}
			}
			else
			{
				component.text += character;
			}
		}

		public void Backspace()
		{
			if (!拼音输入法.回删键() && 内容文本.text.Length > 0)
			{
				内容文本.text = 内容文本.text.Substring(0, 内容文本.text.Length - 1);
			}
		}

		public void 大小写切换()
		{
			if (是否小写)
			{
				是否小写 = false;
			}
			else
			{
				是否小写 = true;
			}
		}

		public void 中英切换()
		{
			if (是否中文)
			{
				是否中文 = false;
				是否小写 = true;
			}
			else
			{
				是否中文 = true;
			}
		}

		public void Enter()
		{
			内容文本.text += "\n";
		}

		public void 确定键()
		{
			if (井模块._instance.是否编辑模式)
			{
				Shurufa._instance.获取修改内容();
			}
			else
			{
				Shurufa._instance.获取输入法内容();
			}
			内容文本.text = "";
		}

		public void 取消输入法()
		{
			Shurufa._instance.取消输入法();
			内容文本.text = "";
		}

		public void 回删键()
		{
			拼音输入法.回删键();
		}

		public void 上一页()
		{
			拼音输入法.上一页();
		}

		public void 下一页()
		{
			拼音输入法.下一页();
		}

		private IEnumerator 开始()
		{
			yield return new WaitForSeconds(1f);
		}

		public void 爆(string 参数)
		{
			GameObject gameObject = GameObject.Find(参数).gameObject;
			gameObject.SetActive(value: false);
			GameObject original = Resources.Load("boom", typeof(GameObject)) as GameObject;
			Vector3 position = gameObject.transform.localPosition + new Vector3(0f, 0.09f, 0f);
			UnityEngine.Object.Instantiate(original, position, gameObject.transform.rotation);
		}

		public void 踪(GameObject 尤参)
		{
			_ = UnityEngine.Object.Instantiate(Resources.Load("Trail", typeof(GameObject)) as GameObject, 尤参.transform).gameObject;
		}

		public void 碰(GameObject 参数)
		{
			参数.AddComponent<BoxCollider>();
		}

		public void 宝(GameObject 参数)
		{
			if (参数.GetComponent<Rigidbody>() == null)
			{
				参数.AddComponent<Rigidbody>();
				参数.GetComponent<Rigidbody>().useGravity = true;
			}
			参数.AddComponent<BoxCollider>();
		}

		public void 贝(GameObject 参数)
		{
		}
	}
	public class UI_Keyboard2 : MonoBehaviour
	{
		public Text input;

		public Text 笔画;

		public Text[] 选取字;

		public WuBi2 五笔;

		private bool 是否中文 = true;

		private bool 是否小写;

		private string 字母;

		private List<string> 选取字列表 = new List<string>();

		public GameObject[] 选取字背景;

		public GameObject 五笔键盘;

		public GameObject 拼音键盘;

		public void 切换输入法()
		{
			五笔键盘.transform.localPosition = new Vector3(-100f, -100f, -100f);
			拼音键盘.transform.localPosition = new Vector3(-0.2608948f, 0.04000866f, 0.8564412f);
			初始化输入();
		}

		public void ClickKey(string character)
		{
			if (!是否中文)
			{
				if (是否小写)
				{
					input.text += character.ToLower();
				}
				else
				{
					input.text += character.ToUpper();
				}
				return;
			}
			string pattern = "^[a-zA-Z0-9]*$";
			if (Regex.IsMatch(character, pattern))
			{
				string pattern2 = "^[0-9]*$";
				if (Regex.IsMatch(character, pattern2))
				{
					int num = int.Parse(character) - 1;
					if (num < 0)
					{
						num = 9;
					}
					if (选取字列表.Count > 1)
					{
						input.text += 选取字列表[num];
						初始化输入();
					}
					else
					{
						input.text += character;
					}
				}
				else
				{
					字母 += character.ToLower();
					笔画.text = 字母;
					选取字列表 = 五笔.输入(字母);
					显示选取字();
				}
			}
			else
			{
				input.text += character;
			}
		}

		public void 空格()
		{
			if (选取字列表.Count > 0)
			{
				ClickKey("1");
			}
			else
			{
				input.text += " ";
			}
		}

		public void 显示选取字()
		{
			for (int i = 0; i < 选取字列表.Count && !(选取字列表[i] == ""); i++)
			{
				选取字[i].text = 选取字列表[i];
			}
		}

		public void 删除()
		{
			if (字母.Length >= 1)
			{
				字母 = 字母.Substring(0, 字母.Length - 1);
				笔画.text = 字母;
				if (字母.Length == 0)
				{
					初始化输入();
					return;
				}
				选取字列表 = 五笔.输入(字母);
				显示选取字();
			}
			else if (input.text.Length > 0)
			{
				input.text = input.text.Substring(0, input.text.Length - 1);
			}
		}

		public void 初始化输入()
		{
			字母 = "";
			选取字列表.Clear();
			笔画.text = 字母;
			for (int i = 0; i < 选取字.Length; i++)
			{
				选取字[i].text = "";
			}
		}

		public void 模拟输入(string character)
		{
			string pattern = "^[a-zA-Z0-9]*$";
			if (Regex.IsMatch(character, pattern))
			{
				string pattern2 = "^[0-9]*$";
				if (Regex.IsMatch(character, pattern2))
				{
					int num = int.Parse(character) - 1;
					if (num < 0)
					{
						num = 9;
					}
					if (选取字列表.Count > 1)
					{
						input.text += 选取字列表[num];
						初始化输入();
					}
					else
					{
						input.text += character;
					}
				}
				else
				{
					字母 += character;
					笔画.text = 字母;
					选取字列表 = 五笔.输入(字母);
					显示选取字();
				}
			}
			else
			{
				input.text += character;
			}
		}

		public void 大小写切换()
		{
			if (是否小写)
			{
				是否小写 = false;
			}
			else
			{
				是否小写 = true;
			}
		}

		public void 中英切换()
		{
			if (是否中文)
			{
				是否中文 = false;
				是否小写 = true;
			}
			else
			{
				是否中文 = true;
			}
		}

		public void Backspace()
		{
			if (input.text.Length > 0)
			{
				input.text = input.text.Substring(0, input.text.Length - 1);
			}
		}

		public void 确定键()
		{
			if (JingHand._instance.编辑模式)
			{
				Shurufa._instance.获取修改内容();
			}
			else
			{
				Shurufa._instance.获取输入法内容();
			}
			input.text = "";
		}

		public void Enter()
		{
			UnityEngine.Debug.Log("You've typed [" + input.text + "]");
			input.text = "";
		}

		private void Start()
		{
			五笔键盘.transform.position = new Vector3(-100f, -100f, -100f);
		}

		public void 取消输入法()
		{
			Shurufa._instance.取消输入法();
			input.text = "";
		}
	}
}
namespace StarterAssets
{
	[RequireComponent(typeof(CharacterController))]
	[RequireComponent(typeof(PlayerInput))]
	public class FirstPersonController : MonoBehaviour
	{
		[Header("Player")]
		[Tooltip("Move speed of the character in m/s")]
		public float MoveSpeed = 4f;

		[Tooltip("Sprint speed of the character in m/s")]
		public float SprintSpeed = 6f;

		[Tooltip("Rotation speed of the character")]
		public float RotationSpeed = 1f;

		[Tooltip("Acceleration and deceleration")]
		public float SpeedChangeRate = 10f;

		[Space(10f)]
		[Tooltip("The height the player can jump")]
		public float JumpHeight = 1.2f;

		[Tooltip("The character uses its own gravity value. The engine default is -9.81f")]
		public float Gravity = -15f;

		[Space(10f)]
		[Tooltip("Time required to pass before being able to jump again. Set to 0f to instantly jump again")]
		public float JumpTimeout = 0.1f;

		[Tooltip("Time required to pass before entering the fall state. Useful for walking down stairs")]
		public float FallTimeout = 0.15f;

		[Header("Player Grounded")]
		[Tooltip("If the character is grounded or not. Not part of the CharacterController built in grounded check")]
		public bool Grounded = true;

		[Tooltip("Useful for rough ground")]
		public float GroundedOffset = -0.14f;

		[Tooltip("The radius of the grounded check. Should match the radius of the CharacterController")]
		public float GroundedRadius = 0.5f;

		[Tooltip("What layers the character uses as ground")]
		public LayerMask GroundLayers;

		[Header("Cinemachine")]
		[Tooltip("The follow target set in the Cinemachine Virtual Camera that the camera will follow")]
		public GameObject CinemachineCameraTarget;

		[Tooltip("How far in degrees can you move the camera up")]
		public float TopClamp = 90f;

		[Tooltip("How far in degrees can you move the camera down")]
		public float BottomClamp = -90f;

		private float _cinemachineTargetPitch;

		private float _speed;

		private float _rotationVelocity;

		private float _verticalVelocity;

		private float _terminalVelocity = 53f;

		private float _jumpTimeoutDelta;

		private float _fallTimeoutDelta;

		private PlayerInput _playerInput;

		private CharacterController _controller;

		private StarterAssetsInputs _input;

		private GameObject _mainCamera;

		private const float _threshold = 0.01f;

		private bool IsCurrentDeviceMouse => _playerInput.currentControlScheme == "KeyboardMouse";

		private void Awake()
		{
			if (_mainCamera == null)
			{
				_mainCamera = GameObject.FindGameObjectWithTag("MainCamera");
			}
		}

		private void Start()
		{
			_controller = GetComponent<CharacterController>();
			_input = GetComponent<StarterAssetsInputs>();
			_playerInput = GetComponent<PlayerInput>();
			_jumpTimeoutDelta = JumpTimeout;
			_fallTimeoutDelta = FallTimeout;
		}

		private void Update()
		{
			JumpAndGravity();
			GroundedCheck();
			Move();
		}

		private void LateUpdate()
		{
			CameraRotation();
		}

		private void GroundedCheck()
		{
			Vector3 position = new Vector3(base.transform.position.x, base.transform.position.y - GroundedOffset, base.transform.position.z);
			Grounded = Physics.CheckSphere(position, GroundedRadius, GroundLayers, QueryTriggerInteraction.Ignore);
		}

		private void CameraRotation()
		{
			if (_input.look.sqrMagnitude >= 0.01f)
			{
				float num = (IsCurrentDeviceMouse ? 1f : Time.deltaTime);
				_cinemachineTargetPitch += _input.look.y * RotationSpeed * num;
				_rotationVelocity = _input.look.x * RotationSpeed * num;
				_cinemachineTargetPitch = ClampAngle(_cinemachineTargetPitch, BottomClamp, TopClamp);
				CinemachineCameraTarget.transform.localRotation = Quaternion.Euler(_cinemachineTargetPitch, 0f, 0f);
				base.transform.Rotate(Vector3.up * _rotationVelocity);
			}
		}

		private void Move()
		{
			float num = (_input.sprint ? SprintSpeed : MoveSpeed);
			if (_input.move == Vector2.zero)
			{
				num = 0f;
			}
			float magnitude = new Vector3(_controller.velocity.x, 0f, _controller.velocity.z).magnitude;
			float num2 = 0.1f;
			float num3 = (_input.analogMovement ? _input.move.magnitude : 1f);
			if (magnitude < num - num2 || magnitude > num + num2)
			{
				_speed = Mathf.Lerp(magnitude, num * num3, Time.deltaTime * SpeedChangeRate);
				_speed = Mathf.Round(_speed * 1000f) / 1000f;
			}
			else
			{
				_speed = num;
			}
			Vector3 vector = new Vector3(_input.move.x, 0f, _input.move.y).normalized;
			if (_input.move != Vector2.zero)
			{
				vector = base.transform.right * _input.move.x + base.transform.forward * _input.move.y;
			}
			_controller.Move(vector.normalized * (_speed * Time.deltaTime) + new Vector3(0f, _verticalVelocity, 0f) * Time.deltaTime);
		}

		private void JumpAndGravity()
		{
			if (Grounded)
			{
				_fallTimeoutDelta = FallTimeout;
				if (_verticalVelocity < 0f)
				{
					_verticalVelocity = -2f;
				}
				if (_input.jump && _jumpTimeoutDelta <= 0f)
				{
					_verticalVelocity = Mathf.Sqrt(JumpHeight * -2f * Gravity);
				}
				if (_jumpTimeoutDelta >= 0f)
				{
					_jumpTimeoutDelta -= Time.deltaTime;
				}
			}
			else
			{
				_jumpTimeoutDelta = JumpTimeout;
				if (_fallTimeoutDelta >= 0f)
				{
					_fallTimeoutDelta -= Time.deltaTime;
				}
				_input.jump = false;
			}
			if (_verticalVelocity < _terminalVelocity)
			{
				_verticalVelocity += Gravity * Time.deltaTime;
			}
		}

		private static float ClampAngle(float lfAngle, float lfMin, float lfMax)
		{
			if (lfAngle < -360f)
			{
				lfAngle += 360f;
			}
			if (lfAngle > 360f)
			{
				lfAngle -= 360f;
			}
			return Mathf.Clamp(lfAngle, lfMin, lfMax);
		}

		private void OnDrawGizmosSelected()
		{
			Color color = new Color(0f, 1f, 0f, 0.35f);
			Color color2 = new Color(1f, 0f, 0f, 0.35f);
			if (Grounded)
			{
				Gizmos.color = color;
			}
			else
			{
				Gizmos.color = color2;
			}
			Gizmos.DrawSphere(new Vector3(base.transform.position.x, base.transform.position.y - GroundedOffset, base.transform.position.z), GroundedRadius);
		}
	}
	public class StarterAssetsInputs : MonoBehaviour
	{
		[Header("Character Input Values")]
		public Vector2 move;

		public Vector2 look;

		public bool jump;

		public bool sprint;

		[Header("Movement Settings")]
		public bool analogMovement;

		[Header("Mouse Cursor Settings")]
		public bool cursorLocked = true;

		public bool cursorInputForLook = true;

		public void OnMove(InputValue value)
		{
			MoveInput(value.Get<Vector2>());
		}

		public void OnLook(InputValue value)
		{
			if (cursorInputForLook)
			{
				LookInput(value.Get<Vector2>());
			}
		}

		public void OnJump(InputValue value)
		{
			JumpInput(value.isPressed);
		}

		public void OnSprint(InputValue value)
		{
			SprintInput(value.isPressed);
		}

		public void MoveInput(Vector2 newMoveDirection)
		{
			move = newMoveDirection;
		}

		public void LookInput(Vector2 newLookDirection)
		{
			look = newLookDirection;
		}

		public void JumpInput(bool newJumpState)
		{
			jump = newJumpState;
		}

		public void SprintInput(bool newSprintState)
		{
			sprint = newSprintState;
		}

		private void OnApplicationFocus(bool hasFocus)
		{
			SetCursorState(cursorLocked);
		}

		private void SetCursorState(bool newState)
		{
			UnityEngine.Cursor.lockState = (newState ? CursorLockMode.Locked : CursorLockMode.None);
		}
	}
	public class UICanvasControllerInput : MonoBehaviour
	{
		[Header("Output")]
		public StarterAssetsInputs starterAssetsInputs;

		public void VirtualMoveInput(Vector2 virtualMoveDirection)
		{
			starterAssetsInputs.MoveInput(virtualMoveDirection);
		}

		public void VirtualLookInput(Vector2 virtualLookDirection)
		{
			starterAssetsInputs.LookInput(virtualLookDirection);
		}

		public void VirtualJumpInput(bool virtualJumpState)
		{
			starterAssetsInputs.JumpInput(virtualJumpState);
		}

		public void VirtualSprintInput(bool virtualSprintState)
		{
			starterAssetsInputs.SprintInput(virtualSprintState);
		}
	}
	[RequireComponent(typeof(CharacterController))]
	[RequireComponent(typeof(PlayerInput))]
	public class ThirdPersonController : MonoBehaviour
	{
		[Header("Player")]
		[Tooltip("Move speed of the character in m/s")]
		public float MoveSpeed = 2f;

		[Tooltip("Sprint speed of the character in m/s")]
		public float SprintSpeed = 5.335f;

		[Tooltip("How fast the character turns to face movement direction")]
		[Range(0f, 0.3f)]
		public float RotationSmoothTime = 0.12f;

		[Tooltip("Acceleration and deceleration")]
		public float SpeedChangeRate = 10f;

		public AudioClip LandingAudioClip;

		public AudioClip[] FootstepAudioClips;

		[Range(0f, 1f)]
		public float FootstepAudioVolume = 0.5f;

		[Space(10f)]
		[Tooltip("The height the player can jump")]
		public float JumpHeight = 1.2f;

		[Tooltip("The character uses its own gravity value. The engine default is -9.81f")]
		public float Gravity = -15f;

		[Space(10f)]
		[Tooltip("Time required to pass before being able to jump again. Set to 0f to instantly jump again")]
		public float JumpTimeout = 0.5f;

		[Tooltip("Time required to pass before entering the fall state. Useful for walking down stairs")]
		public float FallTimeout = 0.15f;

		[Header("Player Grounded")]
		[Tooltip("If the character is grounded or not. Not part of the CharacterController built in grounded check")]
		public bool Grounded = true;

		[Tooltip("Useful for rough ground")]
		public float GroundedOffset = -0.14f;

		[Tooltip("The radius of the grounded check. Should match the radius of the CharacterController")]
		public float GroundedRadius = 0.28f;

		[Tooltip("What layers the character uses as ground")]
		public LayerMask GroundLayers;

		[Header("Cinemachine")]
		[Tooltip("The follow target set in the Cinemachine Virtual Camera that the camera will follow")]
		public GameObject CinemachineCameraTarget;

		[Tooltip("How far in degrees can you move the camera up")]
		public float TopClamp = 70f;

		[Tooltip("How far in degrees can you move the camera down")]
		public float BottomClamp = -30f;

		[Tooltip("Additional degress to override the camera. Useful for fine tuning camera position when locked")]
		public float CameraAngleOverride;

		[Tooltip("For locking the camera position on all axis")]
		public bool LockCameraPosition;

		private float _cinemachineTargetYaw;

		private float _cinemachineTargetPitch;

		private float _speed;

		private float _animationBlend;

		private float _targetRotation;

		private float _rotationVelocity;

		private float _verticalVelocity;

		private float _terminalVelocity = 53f;

		private float _jumpTimeoutDelta;

		private float _fallTimeoutDelta;

		private int _animIDSpeed;

		private int _animIDGrounded;

		private int _animIDJump;

		private int _animIDFreeFall;

		private int _animIDMotionSpeed;

		private PlayerInput _playerInput;

		private Animator _animator;

		private CharacterController _controller;

		private StarterAssetsInputs _input;

		private GameObject _mainCamera;

		private const float _threshold = 0.01f;

		private bool _hasAnimator;

		private bool IsCurrentDeviceMouse => _playerInput.currentControlScheme == "KeyboardMouse";

		private void Awake()
		{
			if (_mainCamera == null)
			{
				_mainCamera = GameObject.FindGameObjectWithTag("MainCamera");
			}
		}

		private void Start()
		{
			_cinemachineTargetYaw = CinemachineCameraTarget.transform.rotation.eulerAngles.y;
			_hasAnimator = TryGetComponent<Animator>(out _animator);
			_controller = GetComponent<CharacterController>();
			_input = GetComponent<StarterAssetsInputs>();
			_playerInput = GetComponent<PlayerInput>();
			AssignAnimationIDs();
			_jumpTimeoutDelta = JumpTimeout;
			_fallTimeoutDelta = FallTimeout;
		}

		private void Update()
		{
			_hasAnimator = TryGetComponent<Animator>(out _animator);
			JumpAndGravity();
			GroundedCheck();
			Move();
		}

		private void LateUpdate()
		{
			CameraRotation();
		}

		private void AssignAnimationIDs()
		{
			_animIDSpeed = Animator.StringToHash("Speed");
			_animIDGrounded = Animator.StringToHash("Grounded");
			_animIDJump = Animator.StringToHash("Jump");
			_animIDFreeFall = Animator.StringToHash("FreeFall");
			_animIDMotionSpeed = Animator.StringToHash("MotionSpeed");
		}

		private void GroundedCheck()
		{
			Vector3 position = new Vector3(base.transform.position.x, base.transform.position.y - GroundedOffset, base.transform.position.z);
			Grounded = Physics.CheckSphere(position, GroundedRadius, GroundLayers, QueryTriggerInteraction.Ignore);
			if (_hasAnimator)
			{
				_animator.SetBool(_animIDGrounded, Grounded);
			}
		}

		private void CameraRotation()
		{
			if (_input.look.sqrMagnitude >= 0.01f && !LockCameraPosition)
			{
				float num = (IsCurrentDeviceMouse ? 1f : Time.deltaTime);
				_cinemachineTargetYaw += _input.look.x * num;
				_cinemachineTargetPitch += _input.look.y * num;
			}
			_cinemachineTargetYaw = ClampAngle(_cinemachineTargetYaw, float.MinValue, float.MaxValue);
			_cinemachineTargetPitch = ClampAngle(_cinemachineTargetPitch, BottomClamp, TopClamp);
			CinemachineCameraTarget.transform.rotation = Quaternion.Euler(_cinemachineTargetPitch + CameraAngleOverride, _cinemachineTargetYaw, 0f);
		}

		private void Move()
		{
			float num = (_input.sprint ? SprintSpeed : MoveSpeed);
			if (_input.move == Vector2.zero)
			{
				num = 0f;
			}
			float magnitude = new Vector3(_controller.velocity.x, 0f, _controller.velocity.z).magnitude;
			float num2 = 0.1f;
			float num3 = (_input.analogMovement ? _input.move.magnitude : 1f);
			if (magnitude < num - num2 || magnitude > num + num2)
			{
				_speed = Mathf.Lerp(magnitude, num * num3, Time.deltaTime * SpeedChangeRate);
				_speed = Mathf.Round(_speed * 1000f) / 1000f;
			}
			else
			{
				_speed = num;
			}
			_animationBlend = Mathf.Lerp(_animationBlend, num, Time.deltaTime * SpeedChangeRate);
			if (_animationBlend < 0.01f)
			{
				_animationBlend = 0f;
			}
			Vector3 normalized = new Vector3(_input.move.x, 0f, _input.move.y).normalized;
			if (_input.move != Vector2.zero)
			{
				_targetRotation = Mathf.Atan2(normalized.x, normalized.z) * 57.29578f + _mainCamera.transform.eulerAngles.y;
				float y = Mathf.SmoothDampAngle(base.transform.eulerAngles.y, _targetRotation, ref _rotationVelocity, RotationSmoothTime);
				base.transform.rotation = Quaternion.Euler(0f, y, 0f);
			}
			Vector3 vector = Quaternion.Euler(0f, _targetRotation, 0f) * Vector3.forward;
			_controller.Move(vector.normalized * (_speed * Time.deltaTime) + new Vector3(0f, _verticalVelocity, 0f) * Time.deltaTime);
			if (_hasAnimator)
			{
				_animator.SetFloat(_animIDSpeed, _animationBlend);
				_animator.SetFloat(_animIDMotionSpeed, num3);
			}
		}

		private void JumpAndGravity()
		{
			if (Grounded)
			{
				_fallTimeoutDelta = FallTimeout;
				if (_hasAnimator)
				{
					_animator.SetBool(_animIDJump, value: false);
					_animator.SetBool(_animIDFreeFall, value: false);
				}
				if (_verticalVelocity < 0f)
				{
					_verticalVelocity = -2f;
				}
				if (_input.jump && _jumpTimeoutDelta <= 0f)
				{
					_verticalVelocity = Mathf.Sqrt(JumpHeight * -2f * Gravity);
					if (_hasAnimator)
					{
						_animator.SetBool(_animIDJump, value: true);
					}
				}
				if (_jumpTimeoutDelta >= 0f)
				{
					_jumpTimeoutDelta -= Time.deltaTime;
				}
			}
			else
			{
				_jumpTimeoutDelta = JumpTimeout;
				if (_fallTimeoutDelta >= 0f)
				{
					_fallTimeoutDelta -= Time.deltaTime;
				}
				else if (_hasAnimator)
				{
					_animator.SetBool(_animIDFreeFall, value: true);
				}
				_input.jump = false;
			}
			if (_verticalVelocity < _terminalVelocity)
			{
				_verticalVelocity += Gravity * Time.deltaTime;
			}
		}

		private static float ClampAngle(float lfAngle, float lfMin, float lfMax)
		{
			if (lfAngle < -360f)
			{
				lfAngle += 360f;
			}
			if (lfAngle > 360f)
			{
				lfAngle -= 360f;
			}
			return Mathf.Clamp(lfAngle, lfMin, lfMax);
		}

		private void OnDrawGizmosSelected()
		{
			Color color = new Color(0f, 1f, 0f, 0.35f);
			Color color2 = new Color(1f, 0f, 0f, 0.35f);
			if (Grounded)
			{
				Gizmos.color = color;
			}
			else
			{
				Gizmos.color = color2;
			}
			Gizmos.DrawSphere(new Vector3(base.transform.position.x, base.transform.position.y - GroundedOffset, base.transform.position.z), GroundedRadius);
		}

		private void OnFootstep(AnimationEvent animationEvent)
		{
			if (animationEvent.animatorClipInfo.weight > 0.5f && FootstepAudioClips.Length != 0)
			{
				int num = UnityEngine.Random.Range(0, FootstepAudioClips.Length);
				AudioSource.PlayClipAtPoint(FootstepAudioClips[num], base.transform.TransformPoint(_controller.center), FootstepAudioVolume);
			}
		}

		private void OnLand(AnimationEvent animationEvent)
		{
			if (animationEvent.animatorClipInfo.weight > 0.5f)
			{
				AudioSource.PlayClipAtPoint(LandingAudioClip, base.transform.TransformPoint(_controller.center), FootstepAudioVolume);
			}
		}
	}
}
namespace WebSocketSharp
{
	public enum ByteOrder : byte
	{
		Little,
		Big
	}
	public class CloseEventArgs : EventArgs
	{
		private bool _clean;

		private ushort _code;

		private string _reason;

		public ushort Code => _code;

		public string Reason => _reason;

		public bool WasClean
		{
			get
			{
				return _clean;
			}
			internal set
			{
				_clean = value;
			}
		}

		internal CloseEventArgs(PayloadData payload)
		{
			byte[] applicationData = payload.ApplicationData;
			int num = applicationData.Length;
			_code = (ushort)((num > 1) ? applicationData.SubArray(0, 2).ToUInt16(ByteOrder.Big) : 1005);
			_reason = ((num > 2) ? Encoding.UTF8.GetString(applicationData.SubArray(2, num - 2)) : string.Empty);
		}
	}
	public enum CloseStatusCode : ushort
	{
		Normal = 1000,
		Away = 1001,
		ProtocolError = 1002,
		IncorrectData = 1003,
		Undefined = 1004,
		NoStatusCode = 1005,
		Abnormal = 1006,
		InconsistentData = 1007,
		PolicyViolation = 1008,
		TooBig = 1009,
		IgnoreExtension = 1010,
		ServerError = 1011,
		TlsHandshakeFailure = 1015
	}
	public enum CompressionMethod : byte
	{
		None,
		Deflate
	}
	public class ErrorEventArgs : EventArgs
	{
		private string _message;

		public string Message => _message;

		internal ErrorEventArgs(string message)
		{
			_message = message;
		}
	}
	public static class Ext
	{
		private const string _tspecials = "()<>@,;:\\\"/[]?={} \t";

		private static byte[] compress(this byte[] value)
		{
			if (value.LongLength == 0L)
			{
				return value;
			}
			using MemoryStream stream = new MemoryStream(value);
			return stream.compressToArray();
		}

		private static MemoryStream compress(this Stream stream)
		{
			MemoryStream memoryStream = new MemoryStream();
			if (stream.Length == 0L)
			{
				return memoryStream;
			}
			stream.Position = 0L;
			using DeflateStream deflateStream = new DeflateStream(memoryStream, CompressionMode.Compress, leaveOpen: true);
			stream.CopyTo(deflateStream);
			deflateStream.Close();
			memoryStream.Position = 0L;
			return memoryStream;
		}

		private static byte[] compressToArray(this Stream stream)
		{
			using MemoryStream memoryStream = stream.compress();
			memoryStream.Close();
			return memoryStream.ToArray();
		}

		private static byte[] decompress(this byte[] value)
		{
			if (value.LongLength == 0L)
			{
				return value;
			}
			using MemoryStream stream = new MemoryStream(value);
			return stream.decompressToArray();
		}

		private static MemoryStream decompress(this Stream stream)
		{
			MemoryStream memoryStream = new MemoryStream();
			if (stream.Length == 0L)
			{
				return memoryStream;
			}
			stream.Position = 0L;
			using DeflateStream src = new DeflateStream(stream, CompressionMode.Decompress, leaveOpen: true);
			src.CopyTo(memoryStream, setDefaultPosition: true);
			return memoryStream;
		}

		private static byte[] decompressToArray(this Stream stream)
		{
			using MemoryStream memoryStream = stream.decompress();
			memoryStream.Close();
			return memoryStream.ToArray();
		}

		private static byte[] readBytes(this Stream stream, byte[] buffer, int offset, int length)
		{
			int i = stream.Read(buffer, offset, length);
			if (i < 1)
			{
				return buffer.SubArray(0, offset);
			}
			int num = 0;
			for (; i < length; i += num)
			{
				num = stream.Read(buffer, offset + i, length - i);
				if (num < 1)
				{
					break;
				}
			}
			if (i >= length)
			{
				return buffer;
			}
			return buffer.SubArray(0, offset + i);
		}

		private static bool readBytes(this Stream stream, byte[] buffer, int offset, int length, Stream dest)
		{
			byte[] array = stream.readBytes(buffer, offset, length);
			int num = array.Length;
			dest.Write(array, 0, num);
			return num == offset + length;
		}

		private static void times(this ulong n, Action act)
		{
			for (ulong num = 0uL; num < n; num++)
			{
				act();
			}
		}

		internal static byte[] Append(this ushort code, string reason)
		{
			using MemoryStream memoryStream = new MemoryStream();
			byte[] buffer = code.ToByteArrayInternally(ByteOrder.Big);
			memoryStream.Write(buffer, 0, 2);
			if (reason != null && reason.Length > 0)
			{
				buffer = Encoding.UTF8.GetBytes(reason);
				memoryStream.Write(buffer, 0, buffer.Length);
			}
			memoryStream.Close();
			return memoryStream.ToArray();
		}

		internal static string CheckIfCanRead(this Stream stream)
		{
			if (stream != null)
			{
				if (stream.CanRead)
				{
					return null;
				}
				return "'stream' cannot be read.";
			}
			return "'stream' must not be null.";
		}

		internal static string CheckIfClosable(this WebSocketState state)
		{
			return state switch
			{
				WebSocketState.Closed => "The WebSocket connection has already been closed.", 
				WebSocketState.Closing => "While closing the WebSocket connection.", 
				_ => null, 
			};
		}

		internal static string CheckIfConnectable(this WebSocketState state)
		{
			if (state != WebSocketState.Open && state != WebSocketState.Closing)
			{
				return null;
			}
			return "A WebSocket connection has already been established.";
		}

		internal static string CheckIfOpen(this WebSocketState state)
		{
			return state switch
			{
				WebSocketState.Closed => "The WebSocket connection has already been closed.", 
				WebSocketState.Closing => "While closing the WebSocket connection.", 
				WebSocketState.Connecting => "A WebSocket connection isn't established.", 
				_ => null, 
			};
		}

		internal static string CheckIfValidCloseStatusCode(this ushort code)
		{
			if (code.IsCloseStatusCode())
			{
				return null;
			}
			return "Invalid close status code.";
		}

		internal static string CheckIfValidControlData(this byte[] data, string paramName)
		{
			if (data.Length <= 125)
			{
				return null;
			}
			return $"'{paramName}' length must be less.";
		}

		internal static string CheckIfValidProtocols(this string[] protocols)
		{
			if (!protocols.Contains((string protocol) => protocol == null || protocol.Length == 0 || !protocol.IsToken()))
			{
				if (!protocols.ContainsTwice())
				{
					return null;
				}
				return "Contains a value twice.";
			}
			return "Contains an invalid value.";
		}

		internal static string CheckIfValidSendData(this byte[] data)
		{
			if (data != null)
			{
				return null;
			}
			return "'data' must not be null.";
		}

		internal static string CheckIfValidSendData(this FileInfo file)
		{
			if (file != null)
			{
				return null;
			}
			return "'file' must not be null.";
		}

		internal static string CheckIfValidSendData(this string data)
		{
			if (data != null)
			{
				return null;
			}
			return "'data' must not be null.";
		}

		internal static string CheckIfValidServicePath(this string servicePath)
		{
			if (servicePath != null && servicePath.Length != 0)
			{
				if (servicePath[0] == '/')
				{
					if (servicePath.IndexOfAny(new char[2] { '?', '#' }) == -1)
					{
						return null;
					}
					return "'servicePath' must not contain either or both query and fragment components.";
				}
				return "'servicePath' not absolute path.";
			}
			return "'servicePath' must not be null or empty.";
		}

		internal static string CheckIfValidSessionID(this string id)
		{
			if (id != null && id.Length != 0)
			{
				return null;
			}
			return "'id' must not be null or empty.";
		}

		internal static void Close(this WebSocketSharp.Net.HttpListenerResponse response, WebSocketSharp.Net.HttpStatusCode code)
		{
			response.StatusCode = (int)code;
			response.OutputStream.Close();
		}

		internal static void CloseWithAuthChallenge(this WebSocketSharp.Net.HttpListenerResponse response, string challenge)
		{
			response.Headers.SetInternally("WWW-Authenticate", challenge, response: true);
			response.Close(WebSocketSharp.Net.HttpStatusCode.Unauthorized);
		}

		internal static byte[] Compress(this byte[] value, CompressionMethod method)
		{
			if (method != CompressionMethod.Deflate)
			{
				return value;
			}
			return value.compress();
		}

		internal static Stream Compress(this Stream stream, CompressionMethod method)
		{
			if (method != CompressionMethod.Deflate)
			{
				return stream;
			}
			return stream.compress();
		}

		internal static byte[] CompressToArray(this Stream stream, CompressionMethod method)
		{
			if (method != CompressionMethod.Deflate)
			{
				return stream.ToByteArray();
			}
			return stream.compressToArray();
		}

		internal static bool Contains<T>(this IEnumerable<T> source, Func<T, bool> condition)
		{
			foreach (T item in source)
			{
				if (condition(item))
				{
					return true;
				}
			}
			return false;
		}

		internal static bool ContainsTwice(this string[] values)
		{
			int len = values.Length;
			Func<int, bool> contains = null;
			contains = delegate(int index)
			{
				if (index < len - 1)
				{
					for (int i = index + 1; i < len; i++)
					{
						if (values[i] == values[index])
						{
							return true;
						}
					}
					return contains(++index);
				}
				return false;
			};
			return contains(0);
		}

		internal static T[] Copy<T>(this T[] src, long length)
		{
			T[] array = new T[length];
			Array.Copy(src, 0L, array, 0L, length);
			return array;
		}

		internal static void CopyTo(this Stream src, Stream dest)
		{
			src.CopyTo(dest, setDefaultPosition: false);
		}

		internal static void CopyTo(this Stream src, Stream dest, bool setDefaultPosition)
		{
			int num = 0;
			int num2 = 256;
			byte[] buffer = new byte[num2];
			while ((num = src.Read(buffer, 0, num2)) > 0)
			{
				dest.Write(buffer, 0, num);
			}
			if (setDefaultPosition)
			{
				dest.Position = 0L;
			}
		}

		internal static byte[] Decompress(this byte[] value, CompressionMethod method)
		{
			if (method != CompressionMethod.Deflate)
			{
				return value;
			}
			return value.decompress();
		}

		internal static Stream Decompress(this Stream stream, CompressionMethod method)
		{
			if (method != CompressionMethod.Deflate)
			{
				return stream;
			}
			return stream.decompress();
		}

		internal static byte[] DecompressToArray(this Stream stream, CompressionMethod method)
		{
			if (method != CompressionMethod.Deflate)
			{
				return stream.ToByteArray();
			}
			return stream.decompressToArray();
		}

		internal static bool EqualsWith(this int value, char c, Action<int> action)
		{
			if (value < 0 || value > 255)
			{
				throw new ArgumentOutOfRangeException("value");
			}
			action(value);
			return value == c;
		}

		internal static string GetAbsolutePath(this Uri uri)
		{
			if (uri.IsAbsoluteUri)
			{
				return uri.AbsolutePath;
			}
			string originalString = uri.OriginalString;
			if (originalString[0] != '/')
			{
				return null;
			}
			int num = originalString.IndexOfAny(new char[2] { '?', '#' });
			if (num <= 0)
			{
				return originalString;
			}
			return originalString.Substring(0, num);
		}

		internal static string GetMessage(this CloseStatusCode code)
		{
			return code switch
			{
				CloseStatusCode.TlsHandshakeFailure => "An error has occurred while handshaking.", 
				CloseStatusCode.ServerError => "WebSocket server got an internal error.", 
				CloseStatusCode.IgnoreExtension => "WebSocket client did not receive expected extension(s).", 
				CloseStatusCode.TooBig => "A too big data has been received.", 
				CloseStatusCode.PolicyViolation => "A policy violation has occurred.", 
				CloseStatusCode.InconsistentData => "An inconsistent data has been received.", 
				CloseStatusCode.Abnormal => "An exception has occurred.", 
				CloseStatusCode.IncorrectData => "An incorrect data has been received.", 
				CloseStatusCode.ProtocolError => "A WebSocket protocol error has occurred.", 
				_ => string.Empty, 
			};
		}

		internal static string GetNameInternal(this string nameAndValue, string separator)
		{
			int num = nameAndValue.IndexOf(separator);
			if (num <= 0)
			{
				return null;
			}
			return nameAndValue.Substring(0, num).Trim();
		}

		internal static string GetValueInternal(this string nameAndValue, string separator)
		{
			int num = nameAndValue.IndexOf(separator);
			if (num < 0 || num >= nameAndValue.Length - 1)
			{
				return null;
			}
			return nameAndValue.Substring(num + 1).Trim();
		}

		internal static TcpListenerWebSocketContext GetWebSocketContext(this TcpClient client, string protocol, bool secure, X509Certificate cert, Logger logger)
		{
			return new TcpListenerWebSocketContext(client, protocol, secure, cert, logger);
		}

		internal static bool IsCompressionExtension(this string value)
		{
			return value.StartsWith("permessage-");
		}

		internal static bool IsPortNumber(this int value)
		{
			if (value > 0)
			{
				return value < 65536;
			}
			return false;
		}

		internal static bool IsReserved(this ushort code)
		{
			if (code != 1004 && code != 1005 && code != 1006)
			{
				return code == 1015;
			}
			return true;
		}

		internal static bool IsReserved(this CloseStatusCode code)
		{
			if (code != CloseStatusCode.Undefined && code != CloseStatusCode.NoStatusCode && code != CloseStatusCode.Abnormal)
			{
				return code == CloseStatusCode.TlsHandshakeFailure;
			}
			return true;
		}

		internal static bool IsText(this string value)
		{
			int length = value.Length;
			for (int i = 0; i < length; i++)
			{
				char c = value[i];
				if (c < ' ' && !"\r\n\t".Contains(c))
				{
					return false;
				}
				switch (c)
				{
				case '\u007f':
					return false;
				case '\n':
					if (++i < length)
					{
						c = value[i];
						if (!" \t".Contains(c))
						{
							return false;
						}
					}
					break;
				}
			}
			return true;
		}

		internal static bool IsToken(this string value)
		{
			foreach (char c in value)
			{
				if (c < ' ' || c >= '\u007f' || "()<>@,;:\\\"/[]?={} \t".Contains(c))
				{
					return false;
				}
			}
			return true;
		}

		internal static string Quote(this string value)
		{
			if (!value.IsToken())
			{
				return string.Format("\"{0}\"", value.Replace("\"", "\\\""));
			}
			return value;
		}

		internal static byte[] ReadBytes(this Stream stream, int length)
		{
			return stream.readBytes(new byte[length], 0, length);
		}

		internal static byte[] ReadBytes(this Stream stream, long length, int bufferLength)
		{
			using MemoryStream memoryStream = new MemoryStream();
			long num = length / bufferLength;
			int num2 = (int)(length % bufferLength);
			byte[] buffer = new byte[bufferLength];
			bool flag = false;
			for (long num3 = 0L; num3 < num; num3++)
			{
				if (!stream.readBytes(buffer, 0, bufferLength, memoryStream))
				{
					flag = true;
					break;
				}
			}
			if (!flag && num2 > 0)
			{
				stream.readBytes(new byte[num2], 0, num2, memoryStream);
			}
			memoryStream.Close();
			return memoryStream.ToArray();
		}

		internal static void ReadBytesAsync(this Stream stream, int length, Action<byte[]> completed, Action<Exception> error)
		{
			byte[] buffer = new byte[length];
			stream.BeginRead(buffer, 0, length, delegate(IAsyncResult ar)
			{
				try
				{
					int num = stream.EndRead(ar);
					byte[] obj = ((num < 1) ? new byte[0] : ((num < length) ? stream.readBytes(buffer, num, length - num) : buffer));
					if (completed != null)
					{
						completed(obj);
					}
				}
				catch (Exception obj2)
				{
					if (error != null)
					{
						error(obj2);
					}
				}
			}, null);
		}

		internal static string RemovePrefix(this string value, params string[] prefixes)
		{
			int num = 0;
			foreach (string text in prefixes)
			{
				if (value.StartsWith(text))
				{
					num = text.Length;
					break;
				}
			}
			if (num <= 0)
			{
				return value;
			}
			return value.Substring(num);
		}

		internal static T[] Reverse<T>(this T[] array)
		{
			int num = array.Length;
			T[] array2 = new T[num];
			int num2 = num - 1;
			for (int i = 0; i <= num2; i++)
			{
				array2[i] = array[num2 - i];
			}
			return array2;
		}

		internal static IEnumerable<string> SplitHeaderValue(this string value, params char[] separator)
		{
			int len = value.Length;
			string separators = new string(separator);
			StringBuilder buffer = new StringBuilder(32);
			bool quoted = false;
			bool escaped = false;
			for (int i = 0; i < len; i++)
			{
				char c = value[i];
				switch (c)
				{
				case '"':
					if (escaped)
					{
						escaped = !escaped;
					}
					else
					{
						quoted = !quoted;
					}
					break;
				case '\\':
					if (i < len - 1 && value[i + 1] == '"')
					{
						escaped = true;
					}
					break;
				default:
					if (separators.Contains(c) && !quoted)
					{
						yield return buffer.ToString();
						buffer.Length = 0;
						continue;
					}
					break;
				}
				buffer.Append(c);
			}
			if (buffer.Length > 0)
			{
				yield return buffer.ToString();
			}
		}

		internal static byte[] ToByteArray(this Stream stream)
		{
			using MemoryStream memoryStream = new MemoryStream();
			stream.Position = 0L;
			stream.CopyTo(memoryStream);
			memoryStream.Close();
			return memoryStream.ToArray();
		}

		internal static byte[] ToByteArrayInternally(this ushort value, ByteOrder order)
		{
			byte[] bytes = BitConverter.GetBytes(value);
			if (!order.IsHostOrder())
			{
				Array.Reverse(bytes);
			}
			return bytes;
		}

		internal static byte[] ToByteArrayInternally(this ulong value, ByteOrder order)
		{
			byte[] bytes = BitConverter.GetBytes(value);
			if (!order.IsHostOrder())
			{
				Array.Reverse(bytes);
			}
			return bytes;
		}

		internal static CompressionMethod ToCompressionMethod(this string value)
		{
			foreach (CompressionMethod value2 in Enum.GetValues(typeof(CompressionMethod)))
			{
				if (value2.ToExtensionString() == value)
				{
					return value2;
				}
			}
			return CompressionMethod.None;
		}

		internal static string ToExtensionString(this CompressionMethod method)
		{
			if (method == CompressionMethod.None)
			{
				return string.Empty;
			}
			return $"permessage-{method.ToString().ToLower()}";
		}

		internal static IPAddress ToIPAddress(this string hostNameOrAddress)
		{
			try
			{
				return Dns.GetHostAddresses(hostNameOrAddress)[0];
			}
			catch
			{
				return null;
			}
		}

		internal static List<TSource> ToList<TSource>(this IEnumerable<TSource> source)
		{
			return new List<TSource>(source);
		}

		internal static ushort ToUInt16(this byte[] src, ByteOrder srcOrder)
		{
			return BitConverter.ToUInt16(src.ToHostOrder(srcOrder), 0);
		}

		internal static ulong ToUInt64(this byte[] src, ByteOrder srcOrder)
		{
			return BitConverter.ToUInt64(src.ToHostOrder(srcOrder), 0);
		}

		internal static string TrimEndSlash(this string value)
		{
			value = value.TrimEnd('/');
			if (value.Length <= 0)
			{
				return "/";
			}
			return value;
		}

		internal static bool TryCreateWebSocketUri(this string uriString, out Uri result, out string message)
		{
			result = null;
			if (uriString.Length == 0)
			{
				message = "Must not be empty.";
				return false;
			}
			Uri uri = uriString.ToUri();
			if (!uri.IsAbsoluteUri)
			{
				message = "Must be the absolute URI: " + uriString;
				return false;
			}
			string scheme = uri.Scheme;
			if (scheme != "ws" && scheme != "wss")
			{
				message = "The scheme part must be 'ws' or 'wss': " + scheme;
				return false;
			}
			if (uri.Fragment.Length > 0)
			{
				message = "Must not contain the fragment component: " + uriString;
				return false;
			}
			int port = uri.Port;
			if (port > 0)
			{
				if (port > 65535)
				{
					message = "The port part must be between 1 and 65535: " + port;
					return false;
				}
				if ((scheme == "ws" && port == 443) || (scheme == "wss" && port == 80))
				{
					message = $"Invalid pair of scheme and port: {scheme}, {port}";
					return false;
				}
			}
			else
			{
				port = ((scheme == "ws") ? 80 : 443);
				uri = $"{scheme}://{uri.Host}:{port}{uri.PathAndQuery}".ToUri();
			}
			result = uri;
			message = string.Empty;
			return true;
		}

		internal static string Unquote(this string value)
		{
			int num = value.IndexOf('"');
			int num2 = value.LastIndexOf('"');
			if (num < num2)
			{
				value = value.Substring(num + 1, num2 - num - 1).Replace("\\\"", "\"");
			}
			return value.Trim();
		}

		internal static void WriteBytes(this Stream stream, byte[] value)
		{
			using MemoryStream memoryStream = new MemoryStream(value);
			memoryStream.CopyTo(stream);
		}

		public static bool Contains(this string value, params char[] chars)
		{
			if (chars != null && chars.Length != 0)
			{
				if (value != null && value.Length != 0)
				{
					return value.IndexOfAny(chars) != -1;
				}
				return false;
			}
			return true;
		}

		public static bool Contains(this NameValueCollection collection, string name)
		{
			if (collection != null && collection.Count != 0)
			{
				return collection[name] != null;
			}
			return false;
		}

		public static bool Contains(this NameValueCollection collection, string name, string value)
		{
			if (collection == null || collection.Count == 0)
			{
				return false;
			}
			string text = collection[name];
			if (text == null)
			{
				return false;
			}
			string[] array = text.Split(',');
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i].Trim().Equals(value, StringComparison.OrdinalIgnoreCase))
				{
					return true;
				}
			}
			return false;
		}

		public static void Emit(this EventHandler eventHandler, object sender, EventArgs e)
		{
			eventHandler?.Invoke(sender, e);
		}

		public static void Emit<TEventArgs>(this EventHandler<TEventArgs> eventHandler, object sender, TEventArgs e) where TEventArgs : EventArgs
		{
			eventHandler?.Invoke(sender, e);
		}

		public static WebSocketSharp.Net.CookieCollection GetCookies(this NameValueCollection headers, bool response)
		{
			string name = (response ? "Set-Cookie" : "Cookie");
			if (headers != null && headers.Contains(name))
			{
				return WebSocketSharp.Net.CookieCollection.Parse(headers[name], response);
			}
			return new WebSocketSharp.Net.CookieCollection();
		}

		public static string GetDescription(this WebSocketSharp.Net.HttpStatusCode code)
		{
			return ((int)code).GetStatusDescription();
		}

		public static string GetName(this string nameAndValue, string separator)
		{
			if (nameAndValue == null || nameAndValue.Length <= 0 || separator == null || separator.Length <= 0)
			{
				return null;
			}
			return nameAndValue.GetNameInternal(separator);
		}

		public static KeyValuePair<string, string> GetNameAndValue(this string nameAndValue, string separator)
		{
			string name = nameAndValue.GetName(separator);
			string value = nameAndValue.GetValue(separator);
			if (name == null)
			{
				return new KeyValuePair<string, string>(null, null);
			}
			return new KeyValuePair<string, string>(name, value);
		}

		public static string GetStatusDescription(this int code)
		{
			return code switch
			{
				100 => "Continue", 
				101 => "Switching Protocols", 
				102 => "Processing", 
				200 => "OK", 
				201 => "Created", 
				202 => "Accepted", 
				203 => "Non-Authoritative Information", 
				204 => "No Content", 
				205 => "Reset Content", 
				206 => "Partial Content", 
				207 => "Multi-Status", 
				300 => "Multiple Choices", 
				301 => "Moved Permanently", 
				302 => "Found", 
				303 => "See Other", 
				304 => "Not Modified", 
				305 => "Use Proxy", 
				307 => "Temporary Redirect", 
				400 => "Bad Request", 
				401 => "Unauthorized", 
				402 => "Payment Required", 
				403 => "Forbidden", 
				404 => "Not Found", 
				405 => "Method Not Allowed", 
				406 => "Not Acceptable", 
				407 => "Proxy Authentication Required", 
				408 => "Request Timeout", 
				409 => "Conflict", 
				410 => "Gone", 
				411 => "Length Required", 
				412 => "Precondition Failed", 
				413 => "Request Entity Too Large", 
				414 => "Request-Uri Too Long", 
				415 => "Unsupported Media Type", 
				416 => "Requested Range Not Satisfiable", 
				417 => "Expectation Failed", 
				422 => "Unprocessable Entity", 
				423 => "Locked", 
				424 => "Failed Dependency", 
				500 => "Internal Server Error", 
				501 => "Not Implemented", 
				502 => "Bad Gateway", 
				503 => "Service Unavailable", 
				504 => "Gateway Timeout", 
				505 => "Http Version Not Supported", 
				507 => "Insufficient Storage", 
				_ => string.Empty, 
			};
		}

		public static string GetValue(this string nameAndValue, string separator)
		{
			if (nameAndValue == null || nameAndValue.Length <= 0 || separator == null || separator.Length <= 0)
			{
				return null;
			}
			return nameAndValue.GetValueInternal(separator);
		}

		public static bool IsCloseStatusCode(this ushort value)
		{
			if (value > 999)
			{
				return value < 5000;
			}
			return false;
		}

		public static bool IsEnclosedIn(this string value, char c)
		{
			if (value != null && value.Length > 1 && value[0] == c)
			{
				return value[value.Length - 1] == c;
			}
			return false;
		}

		public static bool IsHostOrder(this ByteOrder order)
		{
			return BitConverter.IsLittleEndian == (order == ByteOrder.Little);
		}

		public static bool IsLocal(this IPAddress address)
		{
			if (address == null)
			{
				throw new ArgumentNullException("address");
			}
			if (address.Equals(IPAddress.Any) || IPAddress.IsLoopback(address))
			{
				return true;
			}
			IPAddress[] hostAddresses = Dns.GetHostAddresses(Dns.GetHostName());
			foreach (IPAddress obj in hostAddresses)
			{
				if (address.Equals(obj))
				{
					return true;
				}
			}
			return false;
		}

		public static bool IsNullOrEmpty(this string value)
		{
			if (value != null)
			{
				return value.Length == 0;
			}
			return true;
		}

		public static bool IsPredefinedScheme(this string value)
		{
			if (value == null || value.Length < 2)
			{
				return false;
			}
			char c = value[0];
			switch (c)
			{
			case 'h':
				if (!(value == "http"))
				{
					return value == "https";
				}
				return true;
			case 'w':
				if (!(value == "ws"))
				{
					return value == "wss";
				}
				return true;
			case 'f':
				if (!(value == "file"))
				{
					return value == "ftp";
				}
				return true;
			case 'n':
				c = value[1];
				if (c != 'e')
				{
					return value == "nntp";
				}
				if (!(value == "news") && !(value == "net.pipe"))
				{
					return value == "net.tcp";
				}
				return true;
			case 'g':
				if (value == "gopher")
				{
					return true;
				}
				goto default;
			default:
				if (c == 'm')
				{
					return value == "mailto";
				}
				return false;
			}
		}

		public static bool IsUpgradeTo(this WebSocketSharp.Net.HttpListenerRequest request, string protocol)
		{
			if (request == null)
			{
				throw new ArgumentNullException("request");
			}
			if (protocol == null)
			{
				throw new ArgumentNullException("protocol");
			}
			if (protocol.Length == 0)
			{
				throw new ArgumentException("Must not be empty.", "protocol");
			}
			if (request.Headers.Contains("Upgrade", protocol))
			{
				return request.Headers.Contains("Connection", "Upgrade");
			}
			return false;
		}

		public static bool MaybeUri(this string value)
		{
			if (value == null || value.Length == 0)
			{
				return false;
			}
			int num = value.IndexOf(':');
			if (num == -1)
			{
				return false;
			}
			if (num >= 10)
			{
				return false;
			}
			return value.Substring(0, num).IsPredefinedScheme();
		}

		public static T[] SubArray<T>(this T[] array, int startIndex, int length)
		{
			if (array == null || array.Length == 0)
			{
				return new T[0];
			}
			if (startIndex < 0 || length <= 0)
			{
				return new T[0];
			}
			if (startIndex + length > array.Length)
			{
				return new T[0];
			}
			if (startIndex == 0 && array.Length == length)
			{
				return array;
			}
			T[] array2 = new T[length];
			Array.Copy(array, startIndex, array2, 0, length);
			return array2;
		}

		public static void Times(this int n, Action act)
		{
			if (n > 0 && act != null)
			{
				((ulong)n).times(act);
			}
		}

		public static void Times(this long n, Action act)
		{
			if (n > 0 && act != null)
			{
				((ulong)n).times(act);
			}
		}

		public static void Times(this uint n, Action act)
		{
			if (n != 0 && act != null)
			{
				times(n, act);
			}
		}

		public static void Times(this ulong n, Action act)
		{
			if (n != 0 && act != null)
			{
				n.times(act);
			}
		}

		public static void Times(this int n, Action<int> act)
		{
			if (n > 0 && act != null)
			{
				for (int i = 0; i < n; i++)
				{
					act(i);
				}
			}
		}

		public static void Times(this long n, Action<long> act)
		{
			if (n > 0 && act != null)
			{
				for (long num = 0L; num < n; num++)
				{
					act(num);
				}
			}
		}

		public static void Times(this uint n, Action<uint> act)
		{
			if (n != 0 && act != null)
			{
				for (uint num = 0u; num < n; num++)
				{
					act(num);
				}
			}
		}

		public static void Times(this ulong n, Action<ulong> act)
		{
			if (n != 0 && act != null)
			{
				for (ulong num = 0uL; num < n; num++)
				{
					act(num);
				}
			}
		}

		public static T To<T>(this byte[] src, ByteOrder srcOrder) where T : struct
		{
			if (src == null)
			{
				throw new ArgumentNullException("src");
			}
			if (src.Length == 0)
			{
				return default(T);
			}
			Type typeFromHandle = typeof(T);
			byte[] value = src.ToHostOrder(srcOrder);
			if (!(typeFromHandle == typeof(bool)))
			{
				if (!(typeFromHandle == typeof(char)))
				{
					if (!(typeFromHandle == typeof(double)))
					{
						if (!(typeFromHandle == typeof(short)))
						{
							if (!(typeFromHandle == typeof(int)))
							{
								if (!(typeFromHandle == typeof(long)))
								{
									if (!(typeFromHandle == typeof(float)))
									{
										if (!(typeFromHandle == typeof(ushort)))
										{
											if (!(typeFromHandle == typeof(uint)))
											{
												if (!(typeFromHandle == typeof(ulong)))
												{
													return default(T);
												}
												return (T)(object)BitConverter.ToUInt64(value, 0);
											}
											return (T)(object)BitConverter.ToUInt32(value, 0);
										}
										return (T)(object)BitConverter.ToUInt16(value, 0);
									}
									return (T)(object)BitConverter.ToSingle(value, 0);
								}
								return (T)(object)BitConverter.ToInt64(value, 0);
							}
							return (T)(object)BitConverter.ToInt32(value, 0);
						}
						return (T)(object)BitConverter.ToInt16(value, 0);
					}
					return (T)(object)BitConverter.ToDouble(value, 0);
				}
				return (T)(object)BitConverter.ToChar(value, 0);
			}
			return (T)(object)BitConverter.ToBoolean(value, 0);
		}

		public static byte[] ToByteArray<T>(this T value, ByteOrder order) where T : struct
		{
			Type typeFromHandle = typeof(T);
			byte[] array = ((typeFromHandle == typeof(bool)) ? BitConverter.GetBytes((bool)(object)value) : ((!(typeFromHandle == typeof(byte))) ? ((typeFromHandle == typeof(char)) ? BitConverter.GetBytes((char)(object)value) : ((typeFromHandle == typeof(double)) ? BitConverter.GetBytes((double)(object)value) : ((typeFromHandle == typeof(short)) ? BitConverter.GetBytes((short)(object)value) : ((typeFromHandle == typeof(int)) ? BitConverter.GetBytes((int)(object)value) : ((typeFromHandle == typeof(long)) ? BitConverter.GetBytes((long)(object)value) : ((typeFromHandle == typeof(float)) ? BitConverter.GetBytes((float)(object)value) : ((typeFromHandle == typeof(ushort)) ? BitConverter.GetBytes((ushort)(object)value) : ((typeFromHandle == typeof(uint)) ? BitConverter.GetBytes((uint)(object)value) : ((typeFromHandle == typeof(ulong)) ? BitConverter.GetBytes((ulong)(object)value) : new byte[0]))))))))) : new byte[1] { (byte)(object)value }));
			if (array.Length > 1 && !order.IsHostOrder())
			{
				Array.Reverse(array);
			}
			return array;
		}

		public static byte[] ToHostOrder(this byte[] src, ByteOrder srcOrder)
		{
			if (src == null)
			{
				throw new ArgumentNullException("src");
			}
			if (src.Length <= 1 || srcOrder.IsHostOrder())
			{
				return src;
			}
			return src.Reverse();
		}

		public static string ToString<T>(this T[] array, string separator)
		{
			if (array == null)
			{
				throw new ArgumentNullException("array");
			}
			int num = array.Length;
			if (num == 0)
			{
				return string.Empty;
			}
			if (separator == null)
			{
				separator = string.Empty;
			}
			StringBuilder buffer = new StringBuilder(64);
			(num - 1).Times(delegate(int i)
			{
				buffer.AppendFormat("{0}{1}", array[i].ToString(), separator);
			});
			buffer.Append(array[num - 1].ToString());
			return buffer.ToString();
		}

		public static Uri ToUri(this string uriString)
		{
			if (!Uri.TryCreate(uriString, uriString.MaybeUri() ? UriKind.Absolute : UriKind.Relative, out var result))
			{
				return null;
			}
			return result;
		}

		public static string UrlDecode(this string value)
		{
			if (value != null && value.Length != 0)
			{
				return HttpUtility.UrlDecode(value);
			}
			return value;
		}

		public static string UrlEncode(this string value)
		{
			if (value != null && value.Length != 0)
			{
				return HttpUtility.UrlEncode(value);
			}
			return value;
		}

		public static void WriteContent(this WebSocketSharp.Net.HttpListenerResponse response, byte[] content)
		{
			if (response == null)
			{
				throw new ArgumentNullException("response");
			}
			if (content != null && content.Length != 0)
			{
				Stream outputStream = response.OutputStream;
				response.ContentLength64 = content.Length;
				outputStream.Write(content, 0, content.Length);
				outputStream.Close();
			}
		}
	}
	internal enum Fin : byte
	{
		More,
		Final
	}
	internal abstract class HandshakeBase
	{
		private NameValueCollection _headers;

		private Version _version;

		internal byte[] EntityBodyData;

		protected const string CrLf = "\r\n";

		public string EntityBody
		{
			get
			{
				if (EntityBodyData == null || EntityBodyData.LongLength <= 0)
				{
					return string.Empty;
				}
				return getEncoding(_headers["Content-Type"]).GetString(EntityBodyData);
			}
		}

		public NameValueCollection Headers => _headers;

		public Version ProtocolVersion => _version;

		protected HandshakeBase(Version version, NameValueCollection headers)
		{
			_version = version;
			_headers = headers;
		}

		private static Encoding getEncoding(string contentType)
		{
			if (contentType == null || contentType.Length == 0)
			{
				return Encoding.UTF8;
			}
			int num = contentType.IndexOf("charset=", StringComparison.Ordinal);
			if (num == -1)
			{
				return Encoding.UTF8;
			}
			string text = contentType.Substring(num + 8);
			num = text.IndexOf(';');
			if (num != -1)
			{
				text = text.Substring(0, num);
			}
			return Encoding.GetEncoding(text);
		}

		public byte[] ToByteArray()
		{
			return Encoding.UTF8.GetBytes(ToString());
		}
	}
	internal class HandshakeRequest : HandshakeBase
	{
		private string _method;

		private string _uri;

		private bool _websocketRequest;

		private bool _websocketRequestWasSet;

		public AuthenticationResponse AuthResponse
		{
			get
			{
				string text = base.Headers["Authorization"];
				if (text == null || text.Length <= 0)
				{
					return null;
				}
				return AuthenticationResponse.Parse(text);
			}
		}

		public WebSocketSharp.Net.CookieCollection Cookies => base.Headers.GetCookies(response: false);

		public string HttpMethod => _method;

		public bool IsWebSocketRequest
		{
			get
			{
				if (!_websocketRequestWasSet)
				{
					NameValueCollection headers = base.Headers;
					_websocketRequest = _method == "GET" && base.ProtocolVersion > WebSocketSharp.Net.HttpVersion.Version10 && headers.Contains("Upgrade", "websocket") && headers.Contains("Connection", "Upgrade");
					_websocketRequestWasSet = true;
				}
				return _websocketRequest;
			}
		}

		public string RequestUri => _uri;

		private HandshakeRequest(Version version, NameValueCollection headers)
			: base(version, headers)
		{
		}

		internal HandshakeRequest(string pathAndQuery)
			: base(WebSocketSharp.Net.HttpVersion.Version11, new NameValueCollection())
		{
			_uri = pathAndQuery;
			_method = "GET";
			NameValueCollection headers = base.Headers;
			headers["User-Agent"] = "websocket-sharp/1.0";
			headers["Upgrade"] = "websocket";
			headers["Connection"] = "Upgrade";
		}

		internal static HandshakeRequest Parse(string[] headerParts)
		{
			string[] array = headerParts[0].Split(new char[1] { ' ' }, 3);
			if (array.Length != 3)
			{
				throw new ArgumentException("Invalid request line: " + headerParts[0]);
			}
			WebSocketSharp.Net.WebHeaderCollection webHeaderCollection = new WebSocketSharp.Net.WebHeaderCollection();
			for (int i = 1; i < headerParts.Length; i++)
			{
				webHeaderCollection.SetInternally(headerParts[i], response: false);
			}
			return new HandshakeRequest(new Version(array[2].Substring(5)), webHeaderCollection)
			{
				_method = array[0],
				_uri = array[1]
			};
		}

		public void SetCookies(WebSocketSharp.Net.CookieCollection cookies)
		{
			if (cookies == null || cookies.Count == 0)
			{
				return;
			}
			StringBuilder stringBuilder = new StringBuilder(64);
			foreach (WebSocketSharp.Net.Cookie item in cookies.Sorted)
			{
				if (!item.Expired)
				{
					stringBuilder.AppendFormat("{0}; ", item.ToString());
				}
			}
			int length = stringBuilder.Length;
			if (length > 2)
			{
				stringBuilder.Length = length - 2;
				base.Headers["Cookie"] = stringBuilder.ToString();
			}
		}

		public override string ToString()
		{
			StringBuilder stringBuilder = new StringBuilder(64);
			stringBuilder.AppendFormat("{0} {1} HTTP/{2}{3}", _method, _uri, base.ProtocolVersion, "\r\n");
			NameValueCollection headers = base.Headers;
			string[] allKeys = headers.AllKeys;
			foreach (string text in allKeys)
			{
				stringBuilder.AppendFormat("{0}: {1}{2}", text, headers[text], "\r\n");
			}
			stringBuilder.Append("\r\n");
			string entityBody = base.EntityBody;
			if (entityBody.Length > 0)
			{
				stringBuilder.Append(entityBody);
			}
			return stringBuilder.ToString();
		}
	}
	internal class HandshakeResponse : HandshakeBase
	{
		private string _code;

		private string _reason;

		public AuthenticationChallenge AuthChallenge
		{
			get
			{
				string text = base.Headers["WWW-Authenticate"];
				if (text == null || text.Length <= 0)
				{
					return null;
				}
				return AuthenticationChallenge.Parse(text);
			}
		}

		public WebSocketSharp.Net.CookieCollection Cookies => base.Headers.GetCookies(response: true);

		public bool IsUnauthorized => _code == "401";

		public bool IsWebSocketResponse
		{
			get
			{
				NameValueCollection headers = base.Headers;
				if (base.ProtocolVersion > WebSocketSharp.Net.HttpVersion.Version10 && _code == "101" && headers.Contains("Upgrade", "websocket"))
				{
					return headers.Contains("Connection", "Upgrade");
				}
				return false;
			}
		}

		public string Reason => _reason;

		public string StatusCode => _code;

		private HandshakeResponse(Version version, NameValueCollection headers)
			: base(version, headers)
		{
		}

		internal HandshakeResponse(WebSocketSharp.Net.HttpStatusCode code)
			: base(WebSocketSharp.Net.HttpVersion.Version11, new NameValueCollection())
		{
			int num = (int)code;
			_code = num.ToString();
			_reason = code.GetDescription();
			NameValueCollection headers = base.Headers;
			headers["Server"] = "websocket-sharp/1.0";
			if (code == WebSocketSharp.Net.HttpStatusCode.SwitchingProtocols)
			{
				headers["Upgrade"] = "websocket";
				headers["Connection"] = "Upgrade";
			}
		}

		internal static HandshakeResponse CreateCloseResponse(WebSocketSharp.Net.HttpStatusCode code)
		{
			HandshakeResponse handshakeResponse = new HandshakeResponse(code);
			handshakeResponse.Headers["Connection"] = "close";
			return handshakeResponse;
		}

		internal static HandshakeResponse Parse(string[] headerParts)
		{
			string[] array = headerParts[0].Split(new char[1] { ' ' }, 3);
			if (array.Length != 3)
			{
				throw new ArgumentException("Invalid status line: " + headerParts[0]);
			}
			WebSocketSharp.Net.WebHeaderCollection webHeaderCollection = new WebSocketSharp.Net.WebHeaderCollection();
			for (int i = 1; i < headerParts.Length; i++)
			{
				webHeaderCollection.SetInternally(headerParts[i], response: true);
			}
			return new HandshakeResponse(new Version(array[0].Substring(5)), webHeaderCollection)
			{
				_code = array[1],
				_reason = array[2]
			};
		}

		public void SetCookies(WebSocketSharp.Net.CookieCollection cookies)
		{
			if (cookies == null || cookies.Count == 0)
			{
				return;
			}
			NameValueCollection headers = base.Headers;
			foreach (WebSocketSharp.Net.Cookie item in cookies.Sorted)
			{
				headers.Add("Set-Cookie", item.ToResponseString());
			}
		}

		public override string ToString()
		{
			StringBuilder stringBuilder = new StringBuilder(64);
			stringBuilder.AppendFormat("HTTP/{0} {1} {2}{3}", base.ProtocolVersion, _code, _reason, "\r\n");
			NameValueCollection headers = base.Headers;
			string[] allKeys = headers.AllKeys;
			foreach (string text in allKeys)
			{
				stringBuilder.AppendFormat("{0}: {1}{2}", text, headers[text], "\r\n");
			}
			stringBuilder.Append("\r\n");
			string entityBody = base.EntityBody;
			if (entityBody.Length > 0)
			{
				stringBuilder.Append(entityBody);
			}
			return stringBuilder.ToString();
		}
	}
	public class LogData
	{
		private StackFrame _caller;

		private DateTime _date;

		private LogLevel _level;

		private string _message;

		public StackFrame Caller => _caller;

		public DateTime Date => _date;

		public LogLevel Level => _level;

		public string Message => _message;

		internal LogData(LogLevel level, StackFrame caller, string message)
		{
			_level = level;
			_caller = caller;
			_message = message ?? string.Empty;
			_date = DateTime.Now;
		}

		public override string ToString()
		{
			string text = $"{_date}|{_level,-5}|";
			MethodBase method = _caller.GetMethod();
			Type declaringType = method.DeclaringType;
			string arg = $"{text}{declaringType.Name}.{method.Name}|";
			string[] array = _message.Replace("\r\n", "\n").TrimEnd('\n').Split('\n');
			if (array.Length <= 1)
			{
				return $"{arg}{_message}";
			}
			StringBuilder stringBuilder = new StringBuilder($"{arg}{array[0]}\n", 64);
			int length = text.Length;
			string format = $"{{0,{length}}}{{1}}\n";
			for (int i = 1; i < array.Length; i++)
			{
				stringBuilder.AppendFormat(format, "", array[i]);
			}
			stringBuilder.Length--;
			return stringBuilder.ToString();
		}
	}
	public class Logger
	{
		private volatile string _file;

		private volatile LogLevel _level;

		private Action<LogData, string> _output;

		private object _sync;

		public string File
		{
			get
			{
				return _file;
			}
			set
			{
				lock (_sync)
				{
					_file = value;
					Warn($"The current path to the log file has been changed to {_file}.");
				}
			}
		}

		public LogLevel Level
		{
			get
			{
				return _level;
			}
			set
			{
				lock (_sync)
				{
					_level = value;
					Warn($"The current logging level has been changed to {_level}.");
				}
			}
		}

		public Action<LogData, string> Output
		{
			get
			{
				return _output;
			}
			set
			{
				lock (_sync)
				{
					_output = value ?? new Action<LogData, string>(defaultOutput);
					Warn("The current output action has been changed.");
				}
			}
		}

		public Logger()
			: this(LogLevel.Error, null, null)
		{
		}

		public Logger(LogLevel level)
			: this(level, null, null)
		{
		}

		public Logger(LogLevel level, string file, Action<LogData, string> output)
		{
			_level = level;
			_file = file;
			_output = output ?? new Action<LogData, string>(defaultOutput);
			_sync = new object();
		}

		private static void defaultOutput(LogData data, string path)
		{
			string value = data.ToString();
			Console.WriteLine(value);
			if (path != null && path.Length > 0)
			{
				writeToFile(path, value);
			}
		}

		private void output(string message, LogLevel level)
		{
			lock (_sync)
			{
				if (_level > level)
				{
					return;
				}
				LogData logData = null;
				try
				{
					logData = new LogData(level, new StackFrame(2, fNeedFileInfo: true), message);
					_output(logData, _file);
				}
				catch (Exception ex)
				{
					logData = new LogData(LogLevel.Fatal, new StackFrame(0, fNeedFileInfo: true), ex.Message);
					Console.WriteLine(logData.ToString());
				}
			}
		}

		private static void writeToFile(string path, string value)
		{
			using StreamWriter writer = new StreamWriter(path, append: true);
			using TextWriter textWriter = TextWriter.Synchronized(writer);
			textWriter.WriteLine(value);
		}

		public void Debug(string message)
		{
			if (_level <= LogLevel.Debug)
			{
				output(message, LogLevel.Debug);
			}
		}

		public void Error(string message)
		{
			if (_level <= LogLevel.Error)
			{
				output(message, LogLevel.Error);
			}
		}

		public void Fatal(string message)
		{
			output(message, LogLevel.Fatal);
		}

		public void Info(string message)
		{
			if (_level <= LogLevel.Info)
			{
				output(message, LogLevel.Info);
			}
		}

		public void Trace(string message)
		{
			if (_level <= LogLevel.Trace)
			{
				output(message, LogLevel.Trace);
			}
		}

		public void Warn(string message)
		{
			if (_level <= LogLevel.Warn)
			{
				output(message, LogLevel.Warn);
			}
		}
	}
	public enum LogLevel
	{
		Trace,
		Debug,
		Info,
		Warn,
		Error,
		Fatal
	}
	internal enum Mask : byte
	{
		Unmask,
		Mask
	}
	public class MessageEventArgs : EventArgs
	{
		private string _data;

		private Opcode _opcode;

		private byte[] _rawData;

		public string Data => _data;

		public byte[] RawData => _rawData;

		public Opcode Type => _opcode;

		internal MessageEventArgs(Opcode opcode, byte[] data)
		{
			if ((ulong)data.LongLength > 9223372036854775807uL)
			{
				throw new WebSocketException(CloseStatusCode.TooBig);
			}
			_opcode = opcode;
			_rawData = data;
			_data = convertToString(opcode, data);
		}

		internal MessageEventArgs(Opcode opcode, PayloadData payload)
		{
			_opcode = opcode;
			_rawData = payload.ApplicationData;
			_data = convertToString(opcode, _rawData);
		}

		private static string convertToString(Opcode opcode, byte[] data)
		{
			if (data.LongLength != 0L)
			{
				if (opcode != Opcode.Text)
				{
					return opcode.ToString();
				}
				return Encoding.UTF8.GetString(data);
			}
			return string.Empty;
		}
	}
	public enum Opcode : byte
	{
		Cont = 0,
		Text = 1,
		Binary = 2,
		Close = 8,
		Ping = 9,
		Pong = 10
	}
	internal class PayloadData : IEnumerable<byte>, IEnumerable
	{
		private byte[] _applicationData;

		private byte[] _extensionData;

		private bool _masked;

		public const ulong MaxLength = 9223372036854775807uL;

		internal bool ContainsReservedCloseStatusCode
		{
			get
			{
				if (_applicationData.Length > 1)
				{
					return _applicationData.SubArray(0, 2).ToUInt16(ByteOrder.Big).IsReserved();
				}
				return false;
			}
		}

		public byte[] ApplicationData => _applicationData;

		public byte[] ExtensionData => _extensionData;

		public bool IsMasked => _masked;

		public ulong Length => (ulong)(_extensionData.LongLength + _applicationData.LongLength);

		public PayloadData()
			: this(new byte[0], new byte[0], masked: false)
		{
		}

		public PayloadData(byte[] applicationData)
			: this(new byte[0], applicationData, masked: false)
		{
		}

		public PayloadData(string applicationData)
			: this(new byte[0], Encoding.UTF8.GetBytes(applicationData), masked: false)
		{
		}

		public PayloadData(byte[] applicationData, bool masked)
			: this(new byte[0], applicationData, masked)
		{
		}

		public PayloadData(byte[] extensionData, byte[] applicationData, bool masked)
		{
			if ((ulong)(extensionData.LongLength + applicationData.LongLength) > 9223372036854775807uL)
			{
				throw new ArgumentOutOfRangeException("The length of 'extensionData' plus 'applicationData' is greater than MaxLength.");
			}
			_extensionData = extensionData;
			_applicationData = applicationData;
			_masked = masked;
		}

		private static void mask(byte[] src, byte[] key)
		{
			for (long num = 0L; num < src.LongLength; num++)
			{
				src[num] ^= key[num % 4];
			}
		}

		public IEnumerator<byte> GetEnumerator()
		{
			byte[] extensionData = _extensionData;
			for (int i = 0; i < extensionData.Length; i++)
			{
				yield return extensionData[i];
			}
			extensionData = _applicationData;
			for (int i = 0; i < extensionData.Length; i++)
			{
				yield return extensionData[i];
			}
		}

		public void Mask(byte[] maskingKey)
		{
			if (_extensionData.LongLength > 0)
			{
				mask(_extensionData, maskingKey);
			}
			if (_applicationData.LongLength > 0)
			{
				mask(_applicationData, maskingKey);
			}
			_masked = !_masked;
		}

		public byte[] ToByteArray()
		{
			if (_extensionData.LongLength <= 0)
			{
				return _applicationData;
			}
			return new List<byte>(this).ToArray();
		}

		public override string ToString()
		{
			return BitConverter.ToString(ToByteArray());
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}
	internal enum Rsv : byte
	{
		Off,
		On
	}
	public class WebSocket : IDisposable
	{
		private const string _guid = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";

		private const string _version = "13";

		private AuthenticationChallenge _authChallenge;

		private string _base64Key;

		private RemoteCertificateValidationCallback _certValidationCallback;

		private bool _client;

		private Action _closeContext;

		private CompressionMethod _compression;

		private WebSocketContext _context;

		private WebSocketSharp.Net.CookieCollection _cookies;

		private WebSocketSharp.Net.NetworkCredential _credentials;

		private string _extensions;

		private AutoResetEvent _exitReceiving;

		private object _forConn;

		private object _forEvent;

		private object _forMessageEventQueue;

		private object _forSend;

		private Func<WebSocketContext, string> _handshakeRequestChecker;

		private volatile Logger _logger;

		private Queue<MessageEventArgs> _messageEventQueue;

		private uint _nonceCount;

		private string _origin;

		private bool _preAuth;

		private string _protocol;

		private string[] _protocols;

		private volatile WebSocketState _readyState;

		private AutoResetEvent _receivePong;

		private bool _secure;

		private WebSocketStream _stream;

		private TcpClient _tcpClient;

		private Uri _uri;

		internal const int FragmentLength = 1016;

		internal WebSocketSharp.Net.CookieCollection CookieCollection => _cookies;

		internal Func<WebSocketContext, string> CustomHandshakeRequestChecker
		{
			get
			{
				return _handshakeRequestChecker ?? ((Func<WebSocketContext, string>)((WebSocketContext context) => (string)null));
			}
			set
			{
				_handshakeRequestChecker = value;
			}
		}

		internal bool IsConnected
		{
			get
			{
				if (_readyState != WebSocketState.Open)
				{
					return _readyState == WebSocketState.Closing;
				}
				return true;
			}
		}

		public CompressionMethod Compression
		{
			get
			{
				return _compression;
			}
			set
			{
				lock (_forConn)
				{
					string text = checkIfAvailable("Set operation of Compression", availableAsServer: false, availableAsConnected: false);
					if (text != null)
					{
						_logger.Error(text);
						error(text);
					}
					else
					{
						_compression = value;
					}
				}
			}
		}

		public IEnumerable<WebSocketSharp.Net.Cookie> Cookies
		{
			get
			{
				lock (_cookies.SyncRoot)
				{
					foreach (WebSocketSharp.Net.Cookie cookie in _cookies)
					{
						yield return cookie;
					}
				}
			}
		}

		public WebSocketSharp.Net.NetworkCredential Credentials => _credentials;

		public string Extensions => _extensions ?? string.Empty;

		public bool IsAlive => Ping();

		public bool IsSecure => _secure;

		public Logger Log
		{
			get
			{
				return _logger;
			}
			internal set
			{
				_logger = value;
			}
		}

		public string Origin
		{
			get
			{
				return _origin;
			}
			set
			{
				lock (_forConn)
				{
					string text = checkIfAvailable("Set operation of Origin", availableAsServer: false, availableAsConnected: false);
					if (text == null)
					{
						if (value.IsNullOrEmpty())
						{
							_origin = value;
							return;
						}
						if (!Uri.TryCreate(value, UriKind.Absolute, out var result) || result.Segments.Length > 1)
						{
							text = "The syntax of Origin must be '<scheme>://<host>[:<port>]'.";
						}
					}
					if (text != null)
					{
						_logger.Error(text);
						error(text);
					}
					else
					{
						_origin = value.TrimEnd('/');
					}
				}
			}
		}

		public string Protocol
		{
			get
			{
				return _protocol ?? string.Empty;
			}
			internal set
			{
				_protocol = value;
			}
		}

		public WebSocketState ReadyState => _readyState;

		public RemoteCertificateValidationCallback ServerCertificateValidationCallback
		{
			get
			{
				return _certValidationCallback;
			}
			set
			{
				lock (_forConn)
				{
					string text = checkIfAvailable("Set operation of ServerCertificateValidationCallback", availableAsServer: false, availableAsConnected: false);
					if (text != null)
					{
						_logger.Error(text);
						error(text);
					}
					else
					{
						_certValidationCallback = value;
					}
				}
			}
		}

		public Uri Url
		{
			get
			{
				if (!_client)
				{
					return _context.RequestUri;
				}
				return _uri;
			}
		}

		public event EventHandler<CloseEventArgs> OnClose;

		public event EventHandler<ErrorEventArgs> OnError;

		public event EventHandler<MessageEventArgs> OnMessage;

		public event EventHandler OnOpen;

		internal WebSocket(HttpListenerWebSocketContext context, string protocol, Logger logger)
		{
			_context = context;
			_protocol = protocol;
			_logger = logger;
			_closeContext = context.Close;
			_secure = context.IsSecureConnection;
			_stream = context.Stream;
			init();
		}

		internal WebSocket(TcpListenerWebSocketContext context, string protocol, Logger logger)
		{
			_context = context;
			_protocol = protocol;
			_logger = logger;
			_closeContext = context.Close;
			_secure = context.IsSecureConnection;
			_stream = context.Stream;
			init();
		}

		public WebSocket(string url, params string[] protocols)
		{
			if (url == null)
			{
				throw new ArgumentNullException("url");
			}
			if (!url.TryCreateWebSocketUri(out _uri, out var message))
			{
				throw new ArgumentException(message, "url");
			}
			if (protocols != null && protocols.Length != 0)
			{
				message = protocols.CheckIfValidProtocols();
				if (message != null)
				{
					throw new ArgumentException(message, "protocols");
				}
				_protocols = protocols;
			}
			_base64Key = CreateBase64Key();
			_client = true;
			_logger = new Logger();
			_secure = _uri.Scheme == "wss";
			init();
		}

		private bool acceptCloseFrame(WebSocketFrame frame)
		{
			PayloadData payloadData = frame.PayloadData;
			close(payloadData, !payloadData.ContainsReservedCloseStatusCode, wait: false);
			return false;
		}

		private bool acceptDataFrame(WebSocketFrame frame)
		{
			MessageEventArgs e = (frame.IsCompressed ? new MessageEventArgs(frame.Opcode, frame.PayloadData.ApplicationData.Decompress(_compression)) : new MessageEventArgs(frame.Opcode, frame.PayloadData));
			enqueueToMessageEventQueue(e);
			return true;
		}

		private void acceptException(Exception exception, string message)
		{
			CloseStatusCode closeStatusCode = CloseStatusCode.Abnormal;
			string text = message;
			if (exception is WebSocketException)
			{
				WebSocketException obj = (WebSocketException)exception;
				closeStatusCode = obj.Code;
				text = obj.Message;
			}
			if (closeStatusCode == CloseStatusCode.Abnormal || closeStatusCode == CloseStatusCode.TlsHandshakeFailure)
			{
				_logger.Fatal(exception.ToString());
			}
			else
			{
				_logger.Error(text);
			}
			error(message ?? closeStatusCode.GetMessage());
			if (_readyState == WebSocketState.Connecting && !_client)
			{
				Close(WebSocketSharp.Net.HttpStatusCode.BadRequest);
			}
			else
			{
				close(closeStatusCode, text ?? closeStatusCode.GetMessage(), wait: false);
			}
		}

		private bool acceptFragmentedFrame(WebSocketFrame frame)
		{
			if (!frame.IsContinuation)
			{
				return acceptFragments(frame);
			}
			return true;
		}

		private bool acceptFragments(WebSocketFrame first)
		{
			using MemoryStream memoryStream = new MemoryStream();
			memoryStream.WriteBytes(first.PayloadData.ApplicationData);
			if (!concatenateFragmentsInto(memoryStream))
			{
				return false;
			}
			byte[] data;
			if (_compression != 0)
			{
				data = memoryStream.DecompressToArray(_compression);
			}
			else
			{
				memoryStream.Close();
				data = memoryStream.ToArray();
			}
			enqueueToMessageEventQueue(new MessageEventArgs(first.Opcode, data));
			return true;
		}

		private bool acceptFrame(WebSocketFrame frame)
		{
			if (!frame.IsCompressed || _compression != 0)
			{
				if (!frame.IsFragmented)
				{
					if (!frame.IsData)
					{
						if (!frame.IsPing)
						{
							if (!frame.IsPong)
							{
								if (!frame.IsClose)
								{
									return acceptUnsupportedFrame(frame, CloseStatusCode.PolicyViolation, null);
								}
								return acceptCloseFrame(frame);
							}
							return acceptPongFrame(frame);
						}
						return acceptPingFrame(frame);
					}
					return acceptDataFrame(frame);
				}
				return acceptFragmentedFrame(frame);
			}
			return acceptUnsupportedFrame(frame, CloseStatusCode.IncorrectData, "A compressed data has been received without available decompression method.");
		}

		private bool acceptHandshake()
		{
			_logger.Debug($"A WebSocket connection request from {_context.UserEndPoint}:\n{_context}");
			string text = checkIfValidHandshakeRequest(_context);
			if (text != null)
			{
				_logger.Error(text);
				error("An error has occurred while connecting.");
				Close(WebSocketSharp.Net.HttpStatusCode.BadRequest);
				return false;
			}
			if (_protocol != null && !_context.SecWebSocketProtocols.Contains((string protocol) => protocol == _protocol))
			{
				_protocol = null;
			}
			string text2 = _context.Headers["Sec-WebSocket-Extensions"];
			if (text2 != null && text2.Length > 0)
			{
				acceptSecWebSocketExtensionsHeader(text2);
			}
			return send(createHandshakeResponse());
		}

		private bool acceptPingFrame(WebSocketFrame frame)
		{
			Mask mask = (_client ? Mask.Mask : Mask.Unmask);
			if (send(WebSocketFrame.CreatePongFrame(mask, frame.PayloadData)))
			{
				_logger.Trace("Returned a Pong.");
			}
			return true;
		}

		private bool acceptPongFrame(WebSocketFrame frame)
		{
			_receivePong.Set();
			_logger.Trace("Received a Pong.");
			return true;
		}

		private void acceptSecWebSocketExtensionsHeader(string value)
		{
			StringBuilder stringBuilder = new StringBuilder(32);
			bool flag = false;
			foreach (string item in value.SplitHeaderValue(','))
			{
				string text = item.Trim();
				string value2 = text.RemovePrefix("x-webkit-");
				if (!flag && value2.IsCompressionExtension())
				{
					CompressionMethod compressionMethod = value2.ToCompressionMethod();
					if (compressionMethod != 0)
					{
						_compression = compressionMethod;
						flag = true;
						stringBuilder.Append(text + ", ");
					}
				}
			}
			int length = stringBuilder.Length;
			if (length > 0)
			{
				stringBuilder.Length = length - 2;
				_extensions = stringBuilder.ToString();
			}
		}

		private bool acceptUnsupportedFrame(WebSocketFrame frame, CloseStatusCode code, string reason)
		{
			_logger.Debug("Unsupported frame:\n" + frame.PrintToString(dumped: false));
			acceptException(new WebSocketException(code, reason), null);
			return false;
		}

		private string checkIfAvailable(string operation, bool availableAsServer, bool availableAsConnected)
		{
			if (_client || availableAsServer)
			{
				if (availableAsConnected)
				{
					return null;
				}
				return _readyState.CheckIfConnectable();
			}
			return operation + " isn't available as a server.";
		}

		private string checkIfCanConnect()
		{
			if (_client || _readyState != WebSocketState.Closed)
			{
				return _readyState.CheckIfConnectable();
			}
			return "Connect isn't available to reconnect as a server.";
		}

		private string checkIfValidHandshakeRequest(WebSocketContext context)
		{
			NameValueCollection headers = context.Headers;
			if (!(context.RequestUri == null))
			{
				if (context.IsWebSocketRequest)
				{
					if (validateSecWebSocketKeyHeader(headers["Sec-WebSocket-Key"]))
					{
						if (validateSecWebSocketVersionClientHeader(headers["Sec-WebSocket-Version"]))
						{
							return CustomHandshakeRequestChecker(context);
						}
						return "Invalid Sec-WebSocket-Version header.";
					}
					return "Invalid Sec-WebSocket-Key header.";
				}
				return "Not WebSocket connection request.";
			}
			return "Invalid request url.";
		}

		private string checkIfValidHandshakeResponse(HandshakeResponse response)
		{
			NameValueCollection headers = response.Headers;
			if (!response.IsUnauthorized)
			{
				if (response.IsWebSocketResponse)
				{
					if (validateSecWebSocketAcceptHeader(headers["Sec-WebSocket-Accept"]))
					{
						if (validateSecWebSocketProtocolHeader(headers["Sec-WebSocket-Protocol"]))
						{
							if (validateSecWebSocketExtensionsHeader(headers["Sec-WebSocket-Extensions"]))
							{
								if (validateSecWebSocketVersionServerHeader(headers["Sec-WebSocket-Version"]))
								{
									return null;
								}
								return "Invalid Sec-WebSocket-Version header.";
							}
							return "Invalid Sec-WebSocket-Extensions header.";
						}
						return "Invalid Sec-WebSocket-Protocol header.";
					}
					return "Invalid Sec-WebSocket-Accept header.";
				}
				return "Not WebSocket connection response.";
			}
			return $"HTTP {response.AuthChallenge.Scheme} authorization is required.";
		}

		private void close(CloseStatusCode code, string reason, bool wait)
		{
			close(new PayloadData(((ushort)code).Append(reason)), !code.IsReserved(), wait);
		}

		private void close(PayloadData payload, bool send, bool wait)
		{
			lock (_forConn)
			{
				if (_readyState == WebSocketState.Closing || _readyState == WebSocketState.Closed)
				{
					_logger.Info("Closing the WebSocket connection has already been done.");
					return;
				}
				_readyState = WebSocketState.Closing;
			}
			_logger.Trace("Start closing handshake.");
			CloseEventArgs closeEventArgs = new CloseEventArgs(payload);
			closeEventArgs.WasClean = (_client ? closeHandshake(send ? WebSocketFrame.CreateCloseFrame(Mask.Mask, payload).ToByteArray() : null, wait ? 5000 : 0, closeClientResources) : closeHandshake(send ? WebSocketFrame.CreateCloseFrame(Mask.Unmask, payload).ToByteArray() : null, wait ? 1000 : 0, closeServerResources));
			_logger.Trace("End closing handshake.");
			_readyState = WebSocketState.Closed;
			try
			{
				this.OnClose.Emit(this, closeEventArgs);
			}
			catch (Exception ex)
			{
				_logger.Fatal(ex.ToString());
				error("An exception has occurred while OnClose.");
			}
		}

		private void closeAsync(PayloadData payload, bool send, bool wait)
		{
			Action<PayloadData, bool, bool> closer = close;
			closer.BeginInvoke(payload, send, wait, delegate(IAsyncResult ar)
			{
				closer.EndInvoke(ar);
			}, null);
		}

		private void closeClientResources()
		{
			if (_stream != null)
			{
				_stream.Dispose();
				_stream = null;
			}
			if (_tcpClient != null)
			{
				_tcpClient.Close();
				_tcpClient = null;
			}
		}

		private bool closeHandshake(byte[] frame, int timeout, Action release)
		{
			bool flag = frame != null && _stream.Write(frame);
			bool flag2 = timeout == 0 || (flag && _exitReceiving != null && _exitReceiving.WaitOne(timeout));
			release();
			if (_receivePong != null)
			{
				_receivePong.Close();
				_receivePong = null;
			}
			if (_exitReceiving != null)
			{
				_exitReceiving.Close();
				_exitReceiving = null;
			}
			bool flag3 = flag && flag2;
			_logger.Debug($"Was clean?: {flag3}\nsent: {flag} received: {flag2}");
			return flag3;
		}

		private void closeServerResources()
		{
			if (_closeContext != null)
			{
				_closeContext();
				_closeContext = null;
				_stream = null;
				_context = null;
			}
		}

		private bool concatenateFragmentsInto(Stream dest)
		{
			WebSocketFrame webSocketFrame;
			while (true)
			{
				webSocketFrame = _stream.ReadFrame();
				if (webSocketFrame.IsFinal)
				{
					if (webSocketFrame.IsContinuation)
					{
						dest.WriteBytes(webSocketFrame.PayloadData.ApplicationData);
						return true;
					}
					if (webSocketFrame.IsPing)
					{
						acceptPingFrame(webSocketFrame);
						continue;
					}
					if (!webSocketFrame.IsPong)
					{
						if (!webSocketFrame.IsClose)
						{
							break;
						}
						return acceptCloseFrame(webSocketFrame);
					}
					acceptPongFrame(webSocketFrame);
				}
				else
				{
					if (!webSocketFrame.IsContinuation)
					{
						break;
					}
					dest.WriteBytes(webSocketFrame.PayloadData.ApplicationData);
				}
			}
			return acceptUnsupportedFrame(webSocketFrame, CloseStatusCode.IncorrectData, "An incorrect data has been received while receiving fragmented data.");
		}

		private bool connect()
		{
			lock (_forConn)
			{
				string text = _readyState.CheckIfConnectable();
				if (text != null)
				{
					_logger.Error(text);
					error(text);
					return false;
				}
				try
				{
					if (_client ? doHandshake() : acceptHandshake())
					{
						_readyState = WebSocketState.Open;
						return true;
					}
				}
				catch (Exception exception)
				{
					acceptException(exception, "An exception has occurred while connecting.");
				}
				return false;
			}
		}

		private string createExtensionsRequest()
		{
			StringBuilder stringBuilder = new StringBuilder(32);
			if (_compression != 0)
			{
				stringBuilder.Append(_compression.ToExtensionString());
			}
			if (stringBuilder.Length <= 0)
			{
				return null;
			}
			return stringBuilder.ToString();
		}

		private HandshakeRequest createHandshakeRequest()
		{
			string pathAndQuery = _uri.PathAndQuery;
			string value = ((_uri.Port == 80) ? _uri.DnsSafeHost : _uri.Authority);
			HandshakeRequest handshakeRequest = new HandshakeRequest(pathAndQuery);
			NameValueCollection headers = handshakeRequest.Headers;
			headers["Host"] = value;
			if (!_origin.IsNullOrEmpty())
			{
				headers["Origin"] = _origin;
			}
			headers["Sec-WebSocket-Key"] = _base64Key;
			if (_protocols != null)
			{
				headers["Sec-WebSocket-Protocol"] = _protocols.ToString(", ");
			}
			string text = createExtensionsRequest();
			if (text != null)
			{
				headers["Sec-WebSocket-Extensions"] = text;
			}
			headers["Sec-WebSocket-Version"] = "13";
			AuthenticationResponse authenticationResponse = null;
			if (_authChallenge != null && _credentials != null)
			{
				authenticationResponse = new AuthenticationResponse(_authChallenge, _credentials, _nonceCount);
				_nonceCount = authenticationResponse.NonceCount;
			}
			else if (_preAuth)
			{
				authenticationResponse = new AuthenticationResponse(_credentials);
			}
			if (authenticationResponse != null)
			{
				headers["Authorization"] = authenticationResponse.ToString();
			}
			if (_cookies.Count > 0)
			{
				handshakeRequest.SetCookies(_cookies);
			}
			return handshakeRequest;
		}

		private HandshakeResponse createHandshakeResponse()
		{
			HandshakeResponse handshakeResponse = new HandshakeResponse(WebSocketSharp.Net.HttpStatusCode.SwitchingProtocols);
			NameValueCollection headers = handshakeResponse.Headers;
			headers["Sec-WebSocket-Accept"] = CreateResponseKey(_base64Key);
			if (_protocol != null)
			{
				headers["Sec-WebSocket-Protocol"] = _protocol;
			}
			if (_extensions != null)
			{
				headers["Sec-WebSocket-Extensions"] = _extensions;
			}
			if (_cookies.Count > 0)
			{
				handshakeResponse.SetCookies(_cookies);
			}
			return handshakeResponse;
		}

		private HandshakeResponse createHandshakeResponse(WebSocketSharp.Net.HttpStatusCode code)
		{
			HandshakeResponse handshakeResponse = HandshakeResponse.CreateCloseResponse(code);
			handshakeResponse.Headers["Sec-WebSocket-Version"] = "13";
			return handshakeResponse;
		}

		private MessageEventArgs dequeueFromMessageEventQueue()
		{
			lock (_forMessageEventQueue)
			{
				return (_messageEventQueue.Count > 0) ? _messageEventQueue.Dequeue() : null;
			}
		}

		private bool doHandshake()
		{
			setClientStream();
			HandshakeResponse handshakeResponse = sendHandshakeRequest();
			string text = checkIfValidHandshakeResponse(handshakeResponse);
			if (text != null)
			{
				_logger.Error(text);
				text = "An error has occurred while connecting.";
				error(text);
				close(CloseStatusCode.Abnormal, text, wait: false);
				return false;
			}
			WebSocketSharp.Net.CookieCollection cookies = handshakeResponse.Cookies;
			if (cookies.Count > 0)
			{
				_cookies.SetOrRemove(cookies);
			}
			return true;
		}

		private void enqueueToMessageEventQueue(MessageEventArgs e)
		{
			lock (_forMessageEventQueue)
			{
				_messageEventQueue.Enqueue(e);
			}
		}

		private void error(string message)
		{
			try
			{
				this.OnError.Emit(this, new ErrorEventArgs(message));
			}
			catch (Exception ex)
			{
				_logger.Fatal("An exception has occurred while OnError:\n" + ex.ToString());
			}
		}

		private void init()
		{
			_compression = CompressionMethod.None;
			_cookies = new WebSocketSharp.Net.CookieCollection();
			_forConn = new object();
			_forEvent = new object();
			_forSend = new object();
			_messageEventQueue = new Queue<MessageEventArgs>();
			_forMessageEventQueue = ((ICollection)_messageEventQueue).SyncRoot;
			_readyState = WebSocketState.Connecting;
		}

		private void open()
		{
			try
			{
				startReceiving();
				lock (_forEvent)
				{
					try
					{
						this.OnOpen.Emit(this, EventArgs.Empty);
					}
					catch (Exception exception)
					{
						acceptException(exception, "An exception has occurred while OnOpen.");
					}
				}
			}
			catch (Exception exception2)
			{
				acceptException(exception2, "An exception has occurred while opening.");
			}
		}

		private HandshakeResponse receiveHandshakeResponse()
		{
			HandshakeResponse handshakeResponse = _stream.ReadHandshakeResponse();
			_logger.Debug("A response to this WebSocket connection request:\n" + handshakeResponse.ToString());
			return handshakeResponse;
		}

		private bool send(byte[] frame)
		{
			lock (_forConn)
			{
				if (_readyState != WebSocketState.Open)
				{
					_logger.Warn("Sending has been interrupted.");
					return false;
				}
				return _stream.Write(frame);
			}
		}

		private void send(HandshakeRequest request)
		{
			_logger.Debug($"A WebSocket connection request to {_uri}:\n{request}");
			_stream.WriteHandshake(request);
		}

		private bool send(HandshakeResponse response)
		{
			_logger.Debug("A response to the WebSocket connection request:\n" + response.ToString());
			return _stream.WriteHandshake(response);
		}

		private bool send(WebSocketFrame frame)
		{
			lock (_forConn)
			{
				if (_readyState != WebSocketState.Open)
				{
					_logger.Warn("Sending has been interrupted.");
					return false;
				}
				return _stream.Write(frame.ToByteArray());
			}
		}

		private bool send(Opcode opcode, byte[] data)
		{
			lock (_forSend)
			{
				bool result = false;
				try
				{
					bool compressed = false;
					if (_compression != 0)
					{
						data = data.Compress(_compression);
						compressed = true;
					}
					Mask mask = (_client ? Mask.Mask : Mask.Unmask);
					result = send(WebSocketFrame.CreateFrame(Fin.Final, opcode, mask, data, compressed));
				}
				catch (Exception ex)
				{
					_logger.Fatal(ex.ToString());
					error("An exception has occurred while sending a data.");
				}
				return result;
			}
		}

		private bool send(Opcode opcode, Stream stream)
		{
			lock (_forSend)
			{
				bool result = false;
				Stream stream2 = stream;
				bool flag = false;
				try
				{
					if (_compression != 0)
					{
						stream = stream.Compress(_compression);
						flag = true;
					}
					Mask mask = (_client ? Mask.Mask : Mask.Unmask);
					result = sendFragmented(opcode, stream, mask, flag);
				}
				catch (Exception ex)
				{
					_logger.Fatal(ex.ToString());
					error("An exception has occurred while sending a data.");
				}
				finally
				{
					if (flag)
					{
						stream.Dispose();
					}
					stream2.Dispose();
				}
				return result;
			}
		}

		private void sendAsync(Opcode opcode, byte[] data, Action<bool> completed)
		{
			Func<Opcode, byte[], bool> sender = send;
			sender.BeginInvoke(opcode, data, delegate(IAsyncResult ar)
			{
				try
				{
					bool obj = sender.EndInvoke(ar);
					if (completed != null)
					{
						completed(obj);
					}
				}
				catch (Exception ex)
				{
					_logger.Fatal(ex.ToString());
					error("An exception has occurred while callback.");
				}
			}, null);
		}

		private void sendAsync(Opcode opcode, Stream stream, Action<bool> completed)
		{
			Func<Opcode, Stream, bool> sender = send;
			sender.BeginInvoke(opcode, stream, delegate(IAsyncResult ar)
			{
				try
				{
					bool obj = sender.EndInvoke(ar);
					if (completed != null)
					{
						completed(obj);
					}
				}
				catch (Exception ex)
				{
					_logger.Fatal(ex.ToString());
					error("An exception has occurred while callback.");
				}
			}, null);
		}

		private bool sendFragmented(Opcode opcode, Stream stream, Mask mask, bool compressed)
		{
			long length = stream.Length;
			long num = length / 1016;
			int num2 = (int)(length % 1016);
			long num3 = ((num2 == 0) ? (num - 2) : (num - 1));
			byte[] array = null;
			if (num == 0L)
			{
				array = new byte[num2];
				if (stream.Read(array, 0, num2) == num2)
				{
					return send(WebSocketFrame.CreateFrame(Fin.Final, opcode, mask, array, compressed));
				}
				return false;
			}
			array = new byte[1016];
			if (stream.Read(array, 0, 1016) != 1016 || !send(WebSocketFrame.CreateFrame(Fin.More, opcode, mask, array, compressed)))
			{
				return false;
			}
			for (long num4 = 0L; num4 < num3; num4++)
			{
				if (stream.Read(array, 0, 1016) != 1016 || !send(WebSocketFrame.CreateFrame(Fin.More, Opcode.Cont, mask, array, compressed)))
				{
					return false;
				}
			}
			int num5 = 1016;
			if (num2 != 0)
			{
				array = new byte[num5 = num2];
			}
			if (stream.Read(array, 0, num5) == num5)
			{
				return send(WebSocketFrame.CreateFrame(Fin.Final, Opcode.Cont, mask, array, compressed));
			}
			return false;
		}

		private HandshakeResponse sendHandshakeRequest()
		{
			HandshakeRequest handshakeRequest = createHandshakeRequest();
			HandshakeResponse handshakeResponse = sendHandshakeRequest(handshakeRequest);
			if (handshakeResponse.IsUnauthorized)
			{
				_authChallenge = handshakeResponse.AuthChallenge;
				if (_credentials != null && (!_preAuth || _authChallenge.Scheme == WebSocketSharp.Net.AuthenticationSchemes.Digest))
				{
					if (handshakeResponse.Headers.Contains("Connection", "close"))
					{
						closeClientResources();
						setClientStream();
					}
					AuthenticationResponse authenticationResponse = new AuthenticationResponse(_authChallenge, _credentials, _nonceCount);
					_nonceCount = authenticationResponse.NonceCount;
					handshakeRequest.Headers["Authorization"] = authenticationResponse.ToString();
					handshakeResponse = sendHandshakeRequest(handshakeRequest);
				}
			}
			return handshakeResponse;
		}

		private HandshakeResponse sendHandshakeRequest(HandshakeRequest request)
		{
			send(request);
			return receiveHandshakeResponse();
		}

		private void setClientStream()
		{
			string dnsSafeHost = _uri.DnsSafeHost;
			int port = _uri.Port;
			_tcpClient = new TcpClient(dnsSafeHost, port);
			_stream = WebSocketStream.CreateClientStream(_tcpClient, _secure, dnsSafeHost, _certValidationCallback);
		}

		private void startReceiving()
		{
			if (_messageEventQueue.Count > 0)
			{
				_messageEventQueue.Clear();
			}
			_exitReceiving = new AutoResetEvent(initialState: false);
			_receivePong = new AutoResetEvent(initialState: false);
			Action receive = null;
			receive = delegate
			{
				_stream.ReadFrameAsync(delegate(WebSocketFrame frame)
				{
					if (acceptFrame(frame) && _readyState != WebSocketState.Closed)
					{
						receive();
						if (frame.IsData)
						{
							lock (_forEvent)
							{
								try
								{
									MessageEventArgs messageEventArgs = dequeueFromMessageEventQueue();
									if (messageEventArgs != null && _readyState == WebSocketState.Open)
									{
										this.OnMessage.Emit(this, messageEventArgs);
									}
								}
								catch (Exception exception)
								{
									acceptException(exception, "An exception has occurred while OnMessage.");
								}
							}
						}
					}
					else if (_exitReceiving != null)
					{
						_exitReceiving.Set();
					}
				}, delegate(Exception ex)
				{
					acceptException(ex, "An exception has occurred while receiving a message.");
				});
			};
			receive();
		}

		private bool validateSecWebSocketAcceptHeader(string value)
		{
			if (value != null)
			{
				return value == CreateResponseKey(_base64Key);
			}
			return false;
		}

		private bool validateSecWebSocketExtensionsHeader(string value)
		{
			bool flag = _compression != CompressionMethod.None;
			if (value == null || value.Length == 0)
			{
				if (flag)
				{
					_compression = CompressionMethod.None;
				}
				return true;
			}
			if (!flag)
			{
				return false;
			}
			if (value.SplitHeaderValue(',').Contains((string extension) => extension.Trim() != _compression.ToExtensionString()))
			{
				return false;
			}
			_extensions = value;
			return true;
		}

		private bool validateSecWebSocketKeyHeader(string value)
		{
			if (value == null || value.Length == 0)
			{
				return false;
			}
			_base64Key = value;
			return true;
		}

		private bool validateSecWebSocketProtocolHeader(string value)
		{
			if (value == null)
			{
				return _protocols == null;
			}
			if (_protocols == null || !_protocols.Contains((string protocol) => protocol == value))
			{
				return false;
			}
			_protocol = value;
			return true;
		}

		private bool validateSecWebSocketVersionClientHeader(string value)
		{
			if (value != null)
			{
				return value == "13";
			}
			return false;
		}

		private bool validateSecWebSocketVersionServerHeader(string value)
		{
			if (value != null)
			{
				return value == "13";
			}
			return true;
		}

		internal void Close(HandshakeResponse response)
		{
			_readyState = WebSocketState.Closing;
			send(response);
			closeServerResources();
			_readyState = WebSocketState.Closed;
		}

		internal void Close(WebSocketSharp.Net.HttpStatusCode code)
		{
			Close(createHandshakeResponse(code));
		}

		internal void Close(CloseEventArgs e, byte[] frame, int timeout)
		{
			lock (_forConn)
			{
				if (_readyState == WebSocketState.Closing || _readyState == WebSocketState.Closed)
				{
					_logger.Info("Closing the WebSocket connection has already been done.");
					return;
				}
				_readyState = WebSocketState.Closing;
			}
			e.WasClean = closeHandshake(frame, timeout, closeServerResources);
			_readyState = WebSocketState.Closed;
			try
			{
				this.OnClose.Emit(this, e);
			}
			catch (Exception ex)
			{
				_logger.Fatal("An exception has occurred while OnClose:\n" + ex.ToString());
			}
		}

		internal void ConnectAsServer()
		{
			try
			{
				if (acceptHandshake())
				{
					_readyState = WebSocketState.Open;
					open();
				}
			}
			catch (Exception exception)
			{
				acceptException(exception, "An exception has occurred while connecting.");
			}
		}

		internal static string CreateBase64Key()
		{
			byte[] array = new byte[16];
			new System.Random().NextBytes(array);
			return Convert.ToBase64String(array);
		}

		internal static string CreateResponseKey(string base64Key)
		{
			StringBuilder stringBuilder = new StringBuilder(base64Key, 64);
			stringBuilder.Append("258EAFA5-E914-47DA-95CA-C5AB0DC85B11");
			return Convert.ToBase64String(new SHA1CryptoServiceProvider().ComputeHash(Encoding.UTF8.GetBytes(stringBuilder.ToString())));
		}

		internal bool Ping(byte[] frame, int timeout)
		{
			try
			{
				AutoResetEvent receivePong;
				return _readyState == WebSocketState.Open && send(frame) && (receivePong = _receivePong) != null && receivePong.WaitOne(timeout);
			}
			catch (Exception ex)
			{
				_logger.Fatal("An exception has occurred while Ping:\n" + ex.ToString());
				return false;
			}
		}

		internal void Send(Opcode opcode, byte[] data, Dictionary<CompressionMethod, byte[]> cache)
		{
			lock (_forSend)
			{
				lock (_forConn)
				{
					if (_readyState != WebSocketState.Open)
					{
						return;
					}
					try
					{
						if (!cache.TryGetValue(_compression, out var value))
						{
							value = WebSocketFrame.CreateFrame(Fin.Final, opcode, Mask.Unmask, data.Compress(_compression), _compression != CompressionMethod.None).ToByteArray();
							cache.Add(_compression, value);
						}
						_stream.Write(value);
					}
					catch (Exception ex)
					{
						_logger.Fatal(ex.ToString());
						error("An exception has occurred while sending a data.");
					}
				}
			}
		}

		internal void Send(Opcode opcode, Stream stream, Dictionary<CompressionMethod, Stream> cache)
		{
			lock (_forSend)
			{
				try
				{
					if (!cache.TryGetValue(_compression, out var value))
					{
						value = stream.Compress(_compression);
						cache.Add(_compression, value);
					}
					else
					{
						value.Position = 0L;
					}
					if (_readyState == WebSocketState.Open)
					{
						sendFragmented(opcode, value, Mask.Unmask, _compression != CompressionMethod.None);
					}
				}
				catch (Exception ex)
				{
					_logger.Fatal(ex.ToString());
					error("An exception has occurred while sending a data.");
				}
			}
		}

		public void Close()
		{
			string text = _readyState.CheckIfClosable();
			if (text != null)
			{
				_logger.Error(text);
				error(text);
			}
			else
			{
				bool wait = _readyState == WebSocketState.Open;
				close(new PayloadData(), wait, wait);
			}
		}

		public void Close(ushort code)
		{
			Close(code, null);
		}

		public void Close(CloseStatusCode code)
		{
			Close(code, null);
		}

		public void Close(ushort code, string reason)
		{
			byte[] applicationData = null;
			string text = _readyState.CheckIfClosable() ?? code.CheckIfValidCloseStatusCode() ?? (applicationData = code.Append(reason)).CheckIfValidControlData("reason");
			if (text != null)
			{
				_logger.Error($"{text}\ncode: {code} reason: {reason}");
				error(text);
			}
			else
			{
				bool wait = _readyState == WebSocketState.Open && !code.IsReserved();
				close(new PayloadData(applicationData), wait, wait);
			}
		}

		public void Close(CloseStatusCode code, string reason)
		{
			byte[] applicationData = null;
			string text = _readyState.CheckIfClosable() ?? (applicationData = ((ushort)code).Append(reason)).CheckIfValidControlData("reason");
			if (text != null)
			{
				_logger.Error($"{text}\ncode: {code} reason: {reason}");
				error(text);
			}
			else
			{
				bool wait = _readyState == WebSocketState.Open && !code.IsReserved();
				close(new PayloadData(applicationData), wait, wait);
			}
		}

		public void CloseAsync()
		{
			string text = _readyState.CheckIfClosable();
			if (text != null)
			{
				_logger.Error(text);
				error(text);
			}
			else
			{
				bool wait = _readyState == WebSocketState.Open;
				closeAsync(new PayloadData(), wait, wait);
			}
		}

		public void CloseAsync(ushort code)
		{
			CloseAsync(code, null);
		}

		public void CloseAsync(CloseStatusCode code)
		{
			CloseAsync(code, null);
		}

		public void CloseAsync(ushort code, string reason)
		{
			byte[] applicationData = null;
			string text = _readyState.CheckIfClosable() ?? code.CheckIfValidCloseStatusCode() ?? (applicationData = code.Append(reason)).CheckIfValidControlData("reason");
			if (text != null)
			{
				_logger.Error($"{text}\ncode: {code} reason: {reason}");
				error(text);
			}
			else
			{
				bool wait = _readyState == WebSocketState.Open && !code.IsReserved();
				closeAsync(new PayloadData(applicationData), wait, wait);
			}
		}

		public void CloseAsync(CloseStatusCode code, string reason)
		{
			byte[] applicationData = null;
			string text = _readyState.CheckIfClosable() ?? (applicationData = ((ushort)code).Append(reason)).CheckIfValidControlData("reason");
			if (text != null)
			{
				_logger.Error($"{text}\ncode: {code} reason: {reason}");
				error(text);
			}
			else
			{
				bool wait = _readyState == WebSocketState.Open && !code.IsReserved();
				closeAsync(new PayloadData(applicationData), wait, wait);
			}
		}

		public void Connect()
		{
			string text = checkIfCanConnect();
			if (text != null)
			{
				_logger.Error(text);
				error(text);
			}
			else if (connect())
			{
				open();
			}
		}

		public void ConnectAsync()
		{
			string text = checkIfCanConnect();
			if (text != null)
			{
				_logger.Error(text);
				error(text);
				return;
			}
			Func<bool> connector = connect;
			connector.BeginInvoke(delegate(IAsyncResult ar)
			{
				if (connector.EndInvoke(ar))
				{
					open();
				}
			}, null);
		}

		public bool Ping()
		{
			if (!_client)
			{
				return Ping(WebSocketFrame.EmptyUnmaskPingData, 1000);
			}
			return Ping(WebSocketFrame.CreatePingFrame(Mask.Mask).ToByteArray(), 5000);
		}

		public bool Ping(string message)
		{
			if (message == null || message.Length == 0)
			{
				return Ping();
			}
			byte[] bytes = Encoding.UTF8.GetBytes(message);
			string text = bytes.CheckIfValidControlData("message");
			if (text != null)
			{
				_logger.Error(text);
				error(text);
				return false;
			}
			if (!_client)
			{
				return Ping(WebSocketFrame.CreatePingFrame(Mask.Unmask, bytes).ToByteArray(), 1000);
			}
			return Ping(WebSocketFrame.CreatePingFrame(Mask.Mask, bytes).ToByteArray(), 5000);
		}

		public void Send(byte[] data)
		{
			string text = _readyState.CheckIfOpen() ?? data.CheckIfValidSendData();
			if (text != null)
			{
				_logger.Error(text);
				error(text);
				return;
			}
			long num = data.LongLength;
			if (num <= 1016)
			{
				send(Opcode.Binary, (num > 0 && _client && _compression == CompressionMethod.None) ? data.Copy(num) : data);
			}
			else
			{
				send(Opcode.Binary, new MemoryStream(data));
			}
		}

		public void Send(FileInfo file)
		{
			string text = _readyState.CheckIfOpen() ?? file.CheckIfValidSendData();
			if (text != null)
			{
				_logger.Error(text);
				error(text);
			}
			else
			{
				send(Opcode.Binary, file.OpenRead());
			}
		}

		public void Send(string data)
		{
			string text = _readyState.CheckIfOpen() ?? data.CheckIfValidSendData();
			if (text != null)
			{
				_logger.Error(text);
				error(text);
				return;
			}
			byte[] bytes = Encoding.UTF8.GetBytes(data);
			if (bytes.LongLength <= 1016)
			{
				send(Opcode.Text, bytes);
			}
			else
			{
				send(Opcode.Text, new MemoryStream(bytes));
			}
		}

		public void SendAsync(byte[] data, Action<bool> completed)
		{
			string text = _readyState.CheckIfOpen() ?? data.CheckIfValidSendData();
			if (text != null)
			{
				_logger.Error(text);
				error(text);
				return;
			}
			long num = data.LongLength;
			if (num <= 1016)
			{
				sendAsync(Opcode.Binary, (num > 0 && _client && _compression == CompressionMethod.None) ? data.Copy(num) : data, completed);
			}
			else
			{
				sendAsync(Opcode.Binary, new MemoryStream(data), completed);
			}
		}

		public void SendAsync(FileInfo file, Action<bool> completed)
		{
			string text = _readyState.CheckIfOpen() ?? file.CheckIfValidSendData();
			if (text != null)
			{
				_logger.Error(text);
				error(text);
			}
			else
			{
				sendAsync(Opcode.Binary, file.OpenRead(), completed);
			}
		}

		public void SendAsync(string data, Action<bool> completed)
		{
			string text = _readyState.CheckIfOpen() ?? data.CheckIfValidSendData();
			if (text != null)
			{
				_logger.Error(text);
				error(text);
				return;
			}
			byte[] bytes = Encoding.UTF8.GetBytes(data);
			if (bytes.LongLength <= 1016)
			{
				sendAsync(Opcode.Text, bytes, completed);
			}
			else
			{
				sendAsync(Opcode.Text, new MemoryStream(bytes), completed);
			}
		}

		public void SendAsync(Stream stream, int length, Action<bool> completed)
		{
			string msg = _readyState.CheckIfOpen() ?? stream.CheckIfCanRead() ?? ((length < 1) ? "'length' must be greater than 0." : null);
			if (msg != null)
			{
				_logger.Error(msg);
				error(msg);
				return;
			}
			stream.ReadBytesAsync(length, delegate(byte[] data)
			{
				int num = data.Length;
				if (num == 0)
				{
					msg = "A data cannot be read from 'stream'.";
					_logger.Error(msg);
					error(msg);
				}
				else
				{
					if (num < length)
					{
						_logger.Warn($"A data with 'length' cannot be read from 'stream'.\nexpected: {length} actual: {num}");
					}
					bool obj = ((num <= 1016) ? send(Opcode.Binary, data) : send(Opcode.Binary, new MemoryStream(data)));
					if (completed != null)
					{
						completed(obj);
					}
				}
			}, delegate(Exception ex)
			{
				_logger.Fatal(ex.ToString());
				error("An exception has occurred while sending a data.");
			});
		}

		public void SetCookie(WebSocketSharp.Net.Cookie cookie)
		{
			lock (_forConn)
			{
				string text = checkIfAvailable("SetCookie", availableAsServer: false, availableAsConnected: false) ?? ((cookie == null) ? "'cookie' must not be null." : null);
				if (text != null)
				{
					_logger.Error(text);
					error(text);
					return;
				}
				lock (_cookies.SyncRoot)
				{
					_cookies.SetOrRemove(cookie);
				}
			}
		}

		public void SetCredentials(string username, string password, bool preAuth)
		{
			lock (_forConn)
			{
				string text = checkIfAvailable("SetCredentials", availableAsServer: false, availableAsConnected: false);
				if (text == null)
				{
					if (username.IsNullOrEmpty())
					{
						_credentials = null;
						_preAuth = false;
						_logger.Warn("Credentials was set back to the default.");
						return;
					}
					text = ((username.Contains(':') || !username.IsText()) ? "'username' contains an invalid character." : ((!password.IsNullOrEmpty() && !password.IsText()) ? "'password' contains an invalid character." : null));
				}
				if (text != null)
				{
					_logger.Error(text);
					error(text);
				}
				else
				{
					_credentials = new WebSocketSharp.Net.NetworkCredential(username, password, _uri.PathAndQuery);
					_preAuth = preAuth;
				}
			}
		}

		void IDisposable.Dispose()
		{
			Close(CloseStatusCode.Away, null);
		}
	}
	public class WebSocketException : Exception
	{
		public CloseStatusCode Code { get; private set; }

		internal WebSocketException()
			: this(CloseStatusCode.Abnormal, null, null)
		{
		}

		internal WebSocketException(string message)
			: this(CloseStatusCode.Abnormal, message, null)
		{
		}

		internal WebSocketException(CloseStatusCode code)
			: this(code, null, null)
		{
		}

		internal WebSocketException(string message, Exception innerException)
			: this(CloseStatusCode.Abnormal, message, innerException)
		{
		}

		internal WebSocketException(CloseStatusCode code, string message)
			: this(code, message, null)
		{
		}

		internal WebSocketException(CloseStatusCode code, string message, Exception innerException)
			: base(message ?? code.GetMessage(), innerException)
		{
			Code = code;
		}
	}
	internal class WebSocketFrame : IEnumerable<byte>, IEnumerable
	{
		private byte[] _extPayloadLength;

		private Fin _fin;

		private Mask _mask;

		private byte[] _maskingKey;

		private Opcode _opcode;

		private PayloadData _payloadData;

		private byte _payloadLength;

		private Rsv _rsv1;

		private Rsv _rsv2;

		private Rsv _rsv3;

		internal static readonly byte[] EmptyUnmaskPingData;

		public byte[] ExtendedPayloadLength => _extPayloadLength;

		public Fin Fin => _fin;

		public bool IsBinary => _opcode == Opcode.Binary;

		public bool IsClose => _opcode == Opcode.Close;

		public bool IsCompressed => _rsv1 == Rsv.On;

		public bool IsContinuation => _opcode == Opcode.Cont;

		public bool IsControl
		{
			get
			{
				if (_opcode != Opcode.Close && _opcode != Opcode.Ping)
				{
					return _opcode == Opcode.Pong;
				}
				return true;
			}
		}

		public bool IsData
		{
			get
			{
				if (_opcode != Opcode.Binary)
				{
					return _opcode == Opcode.Text;
				}
				return true;
			}
		}

		public bool IsFinal => _fin == Fin.Final;

		public bool IsFragmented
		{
			get
			{
				if (_fin != 0)
				{
					return _opcode == Opcode.Cont;
				}
				return true;
			}
		}

		public bool IsMasked => _mask == Mask.Mask;

		public bool IsPerMessageCompressed
		{
			get
			{
				if (_opcode == Opcode.Binary || _opcode == Opcode.Text)
				{
					return _rsv1 == Rsv.On;
				}
				return false;
			}
		}

		public bool IsPing => _opcode == Opcode.Ping;

		public bool IsPong => _opcode == Opcode.Pong;

		public bool IsText => _opcode == Opcode.Text;

		public ulong Length => (ulong)(2L + (long)(_extPayloadLength.Length + _maskingKey.Length)) + _payloadData.Length;

		public Mask Mask => _mask;

		public byte[] MaskingKey => _maskingKey;

		public Opcode Opcode => _opcode;

		public PayloadData PayloadData => _payloadData;

		public byte PayloadLength => _payloadLength;

		public Rsv Rsv1 => _rsv1;

		public Rsv Rsv2 => _rsv2;

		public Rsv Rsv3 => _rsv3;

		static WebSocketFrame()
		{
			EmptyUnmaskPingData = CreatePingFrame(Mask.Unmask).ToByteArray();
		}

		private WebSocketFrame()
		{
		}

		public WebSocketFrame(Opcode opcode, PayloadData payload)
			: this(Fin.Final, opcode, Mask.Mask, payload, compressed: false)
		{
		}

		public WebSocketFrame(Opcode opcode, Mask mask, PayloadData payload)
			: this(Fin.Final, opcode, mask, payload, compressed: false)
		{
		}

		public WebSocketFrame(Fin fin, Opcode opcode, Mask mask, PayloadData payload)
			: this(fin, opcode, mask, payload, compressed: false)
		{
		}

		public WebSocketFrame(Fin fin, Opcode opcode, Mask mask, PayloadData payload, bool compressed)
		{
			_fin = fin;
			_rsv1 = ((isData(opcode) && compressed) ? Rsv.On : Rsv.Off);
			_rsv2 = Rsv.Off;
			_rsv3 = Rsv.Off;
			_opcode = opcode;
			_mask = mask;
			ulong length = payload.Length;
			if (length < 126)
			{
				_payloadLength = (byte)length;
				_extPayloadLength = new byte[0];
			}
			else if (length < 65536)
			{
				_payloadLength = 126;
				_extPayloadLength = ((ushort)length).ToByteArrayInternally(ByteOrder.Big);
			}
			else
			{
				_payloadLength = 127;
				_extPayloadLength = length.ToByteArrayInternally(ByteOrder.Big);
			}
			if (mask == Mask.Mask)
			{
				_maskingKey = createMaskingKey();
				payload.Mask(_maskingKey);
			}
			else
			{
				_maskingKey = new byte[0];
			}
			_payloadData = payload;
		}

		private static byte[] createMaskingKey()
		{
			byte[] array = new byte[4];
			new System.Random().NextBytes(array);
			return array;
		}

		private static string dump(WebSocketFrame frame)
		{
			ulong length = frame.Length;
			long num = (long)(length / 4);
			int num2 = (int)(length % 4);
			int num3;
			string arg5;
			if (num < 10000)
			{
				num3 = 4;
				arg5 = "{0,4}";
			}
			else if (num < 65536)
			{
				num3 = 4;
				arg5 = "{0,4:X}";
			}
			else if (num < 4294967296L)
			{
				num3 = 8;
				arg5 = "{0,8:X}";
			}
			else
			{
				num3 = 16;
				arg5 = "{0,16:X}";
			}
			string arg6 = $"{{0,{num3}}}";
			string format = string.Format("{0} 01234567 89ABCDEF 01234567 89ABCDEF\n{0}+--------+--------+--------+--------+\\n", arg6);
			string lineFmt = $"{arg5}|{{1,8}} {{2,8}} {{3,8}} {{4,8}}|\n";
			string format2 = $"{arg6}+--------+--------+--------+--------+";
			StringBuilder output = new StringBuilder(64);
			Func<Action<string, string, string, string>> func = delegate
			{
				long lineCnt = 0L;
				return delegate(string arg1, string arg2, string arg3, string arg4)
				{
					output.AppendFormat(lineFmt, ++lineCnt, arg1, arg2, arg3, arg4);
				};
			};
			output.AppendFormat(format, string.Empty);
			Action<string, string, string, string> action = func();
			byte[] array = frame.ToByteArray();
			for (long num4 = 0L; num4 <= num; num4++)
			{
				long num5 = num4 * 4;
				if (num4 < num)
				{
					action(Convert.ToString(array[num5], 2).PadLeft(8, '0'), Convert.ToString(array[num5 + 1], 2).PadLeft(8, '0'), Convert.ToString(array[num5 + 2], 2).PadLeft(8, '0'), Convert.ToString(array[num5 + 3], 2).PadLeft(8, '0'));
				}
				else if (num2 > 0)
				{
					action(Convert.ToString(array[num5], 2).PadLeft(8, '0'), (num2 >= 2) ? Convert.ToString(array[num5 + 1], 2).PadLeft(8, '0') : string.Empty, (num2 == 3) ? Convert.ToString(array[num5 + 2], 2).PadLeft(8, '0') : string.Empty, string.Empty);
				}
			}
			output.AppendFormat(format2, string.Empty);
			return output.ToString();
		}

		private static bool isControl(Opcode opcode)
		{
			if (opcode != Opcode.Close && opcode != Opcode.Ping)
			{
				return opcode == Opcode.Pong;
			}
			return true;
		}

		private static bool isData(Opcode opcode)
		{
			if (opcode != Opcode.Text)
			{
				return opcode == Opcode.Binary;
			}
			return true;
		}

		private static WebSocketFrame parse(byte[] header, Stream stream, bool unmask)
		{
			Fin fin = (((header[0] & 0x80) == 128) ? Fin.Final : Fin.More);
			Rsv rsv = (((header[0] & 0x40) == 64) ? Rsv.On : Rsv.Off);
			Rsv rsv2 = (((header[0] & 0x20) == 32) ? Rsv.On : Rsv.Off);
			Rsv rsv3 = (((header[0] & 0x10) == 16) ? Rsv.On : Rsv.Off);
			Opcode opcode = (Opcode)(header[0] & 0xFu);
			Mask mask = (((header[1] & 0x80) == 128) ? Mask.Mask : Mask.Unmask);
			byte b = (byte)(header[1] & 0x7Fu);
			string text = ((isControl(opcode) && fin == Fin.More) ? "A control frame is fragmented." : ((!isData(opcode) && rsv == Rsv.On) ? "A non data frame is compressed." : null));
			if (text != null)
			{
				throw new WebSocketException(CloseStatusCode.IncorrectData, text);
			}
			if (isControl(opcode) && b > 125)
			{
				throw new WebSocketException(CloseStatusCode.InconsistentData, "The length of payload data of a control frame is greater than 125 bytes.");
			}
			WebSocketFrame webSocketFrame = new WebSocketFrame();
			webSocketFrame._fin = fin;
			webSocketFrame._rsv1 = rsv;
			webSocketFrame._rsv2 = rsv2;
			webSocketFrame._rsv3 = rsv3;
			webSocketFrame._opcode = opcode;
			webSocketFrame._mask = mask;
			webSocketFrame._payloadLength = b;
			int num = ((b >= 126) ? ((b == 126) ? 2 : 8) : 0);
			byte[] array = ((num > 0) ? stream.ReadBytes(num) : new byte[0]);
			if (num > 0 && array.Length != num)
			{
				throw new WebSocketException("The 'Extended Payload Length' of a frame cannot be read from the data source.");
			}
			webSocketFrame._extPayloadLength = array;
			bool flag = mask == Mask.Mask;
			byte[] array2 = (flag ? stream.ReadBytes(4) : new byte[0]);
			if (flag && array2.Length != 4)
			{
				throw new WebSocketException("The 'Masking Key' of a frame cannot be read from the data source.");
			}
			webSocketFrame._maskingKey = array2;
			ulong num2 = ((b < 126) ? b : ((b == 126) ? array.ToUInt16(ByteOrder.Big) : array.ToUInt64(ByteOrder.Big)));
			byte[] array3 = null;
			if (num2 != 0)
			{
				if (b > 126 && num2 > long.MaxValue)
				{
					throw new WebSocketException(CloseStatusCode.TooBig, "The length of 'Payload Data' of a frame is greater than the allowable length.");
				}
				array3 = ((b > 126) ? stream.ReadBytes((long)num2, 1024) : stream.ReadBytes((int)num2));
				if (array3.LongLength != (long)num2)
				{
					throw new WebSocketException("The 'Payload Data' of a frame cannot be read from the data source.");
				}
			}
			else
			{
				array3 = new byte[0];
			}
			PayloadData payloadData = new PayloadData(array3, flag);
			if (flag && unmask)
			{
				payloadData.Mask(array2);
				webSocketFrame._mask = Mask.Unmask;
				webSocketFrame._maskingKey = new byte[0];
			}
			webSocketFrame._payloadData = payloadData;
			return webSocketFrame;
		}

		private static string print(WebSocketFrame frame)
		{
			string text = frame._opcode.ToString();
			byte payloadLength = frame._payloadLength;
			byte[] extPayloadLength = frame._extPayloadLength;
			int num = extPayloadLength.Length;
			string text2 = num switch
			{
				8 => extPayloadLength.ToUInt64(ByteOrder.Big).ToString(), 
				2 => extPayloadLength.ToUInt16(ByteOrder.Big).ToString(), 
				_ => string.Empty, 
			};
			bool isMasked = frame.IsMasked;
			string text3 = (isMasked ? BitConverter.ToString(frame._maskingKey) : string.Empty);
			string text4 = ((payloadLength == 0) ? string.Empty : ((num > 0) ? $"A {text.ToLower()} frame." : ((!isMasked && !frame.IsFragmented && frame.IsText) ? Encoding.UTF8.GetString(frame._payloadData.ApplicationData) : frame._payloadData.ToString())));
			return $"                    FIN: {frame._fin}\n                   RSV1: {frame._rsv1}\n                   RSV2: {frame._rsv2}\n                   RSV3: {frame._rsv3}\n                 Opcode: {text}\n                   MASK: {frame._mask}\n         Payload Length: {payloadLength}\nExtended Payload Length: {text2}\n            Masking Key: {text3}\n           Payload Data: {text4}";
		}

		internal static WebSocketFrame CreateCloseFrame(Mask mask, PayloadData payload)
		{
			return new WebSocketFrame(Opcode.Close, mask, payload);
		}

		internal static WebSocketFrame CreatePongFrame(Mask mask, PayloadData payload)
		{
			return new WebSocketFrame(Opcode.Pong, mask, payload);
		}

		public static WebSocketFrame CreateCloseFrame(Mask mask, byte[] data)
		{
			return new WebSocketFrame(Opcode.Close, mask, new PayloadData(data));
		}

		public static WebSocketFrame CreateCloseFrame(Mask mask, CloseStatusCode code, string reason)
		{
			return new WebSocketFrame(Opcode.Close, mask, new PayloadData(((ushort)code).Append(reason)));
		}

		public static WebSocketFrame CreateFrame(Fin fin, Opcode opcode, Mask mask, byte[] data, bool compressed)
		{
			return new WebSocketFrame(fin, opcode, mask, new PayloadData(data), compressed);
		}

		public static WebSocketFrame CreatePingFrame(Mask mask)
		{
			return new WebSocketFrame(Opcode.Ping, mask, new PayloadData());
		}

		public static WebSocketFrame CreatePingFrame(Mask mask, byte[] data)
		{
			return new WebSocketFrame(Opcode.Ping, mask, new PayloadData(data));
		}

		public IEnumerator<byte> GetEnumerator()
		{
			byte[] array = ToByteArray();
			for (int i = 0; i < array.Length; i++)
			{
				yield return array[i];
			}
		}

		public static WebSocketFrame Parse(byte[] src)
		{
			return Parse(src, unmask: true);
		}

		public static WebSocketFrame Parse(Stream stream)
		{
			return Parse(stream, unmask: true);
		}

		public static WebSocketFrame Parse(byte[] src, bool unmask)
		{
			using MemoryStream stream = new MemoryStream(src);
			return Parse(stream, unmask);
		}

		public static WebSocketFrame Parse(Stream stream, bool unmask)
		{
			byte[] array = stream.ReadBytes(2);
			if (array.Length != 2)
			{
				throw new WebSocketException("The header part of a frame cannot be read from the data source.");
			}
			return parse(array, stream, unmask);
		}

		public static void ParseAsync(Stream stream, Action<WebSocketFrame> completed)
		{
			ParseAsync(stream, unmask: true, completed, null);
		}

		public static void ParseAsync(Stream stream, Action<WebSocketFrame> completed, Action<Exception> error)
		{
			ParseAsync(stream, unmask: true, completed, error);
		}

		public static void ParseAsync(Stream stream, bool unmask, Action<WebSocketFrame> completed, Action<Exception> error)
		{
			stream.ReadBytesAsync(2, delegate(byte[] header)
			{
				if (header.Length != 2)
				{
					throw new WebSocketException("The header part of a frame cannot be read from the data source.");
				}
				WebSocketFrame obj = parse(header, stream, unmask);
				if (completed != null)
				{
					completed(obj);
				}
			}, error);
		}

		public void Print(bool dumped)
		{
			Console.WriteLine(dumped ? dump(this) : print(this));
		}

		public string PrintToString(bool dumped)
		{
			if (!dumped)
			{
				return print(this);
			}
			return dump(this);
		}

		public byte[] ToByteArray()
		{
			using MemoryStream memoryStream = new MemoryStream();
			int fin = (int)_fin;
			fin = (fin << 1) + (int)_rsv1;
			fin = (fin << 1) + (int)_rsv2;
			fin = (fin << 1) + (int)_rsv3;
			fin = (fin << 4) + (int)_opcode;
			fin = (fin << 1) + (int)_mask;
			fin = (fin << 7) + _payloadLength;
			memoryStream.Write(((ushort)fin).ToByteArrayInternally(ByteOrder.Big), 0, 2);
			if (_payloadLength > 125)
			{
				memoryStream.Write(_extPayloadLength, 0, _extPayloadLength.Length);
			}
			if (_mask == Mask.Mask)
			{
				memoryStream.Write(_maskingKey, 0, _maskingKey.Length);
			}
			if (_payloadLength > 0)
			{
				byte[] array = _payloadData.ToByteArray();
				if (_payloadLength < 127)
				{
					memoryStream.Write(array, 0, array.Length);
				}
				else
				{
					memoryStream.WriteBytes(array);
				}
			}
			memoryStream.Close();
			return memoryStream.ToArray();
		}

		public override string ToString()
		{
			return BitConverter.ToString(ToByteArray());
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}
	public enum WebSocketState : ushort
	{
		Connecting,
		Open,
		Closing,
		Closed
	}
	internal class WebSocketStream : IDisposable
	{
		private const int _handshakeHeadersLimitLen = 8192;

		private object _forWrite;

		private Stream _innerStream;

		private bool _secure;

		public bool DataAvailable
		{
			get
			{
				if (!_secure)
				{
					return ((NetworkStream)_innerStream).DataAvailable;
				}
				return ((WebSocketSharp.Net.Security.SslStream)_innerStream).DataAvailable;
			}
		}

		public bool IsSecure => _secure;

		internal WebSocketStream(Stream innerStream, bool secure)
		{
			_innerStream = innerStream;
			_secure = secure;
			_forWrite = new object();
		}

		public WebSocketStream(NetworkStream innerStream)
			: this(innerStream, secure: false)
		{
		}

		public WebSocketStream(WebSocketSharp.Net.Security.SslStream innerStream)
			: this(innerStream, secure: true)
		{
		}

		private static byte[] readHandshakeEntityBody(Stream stream, string length)
		{
			if (!long.TryParse(length, out var result))
			{
				throw new ArgumentException("Cannot be parsed.", "length");
			}
			if (result < 0)
			{
				throw new ArgumentOutOfRangeException("length", "Less than zero.");
			}
			if (result <= 1024)
			{
				if (result <= 0)
				{
					return null;
				}
				return stream.ReadBytes((int)result);
			}
			return stream.ReadBytes(result, 1024);
		}

		private static string[] readHandshakeHeaders(Stream stream)
		{
			List<byte> buff = new List<byte>();
			int count = 0;
			Action<int> action = delegate(int i)
			{
				buff.Add((byte)i);
				count++;
			};
			bool flag = false;
			while (count < 8192)
			{
				if (stream.ReadByte().EqualsWith('\r', action) && stream.ReadByte().EqualsWith('\n', action) && stream.ReadByte().EqualsWith('\r', action) && stream.ReadByte().EqualsWith('\n', action))
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				throw new WebSocketException("The header part of a handshake is greater than the limit length.");
			}
			string text = "\r\n";
			return Encoding.UTF8.GetString(buff.ToArray()).Replace(text + " ", " ").Replace(text + "\t", " ")
				.Split(new string[1] { text }, StringSplitOptions.RemoveEmptyEntries);
		}

		internal T ReadHandshake<T>(Func<string[], T> parser, int millisecondsTimeout) where T : HandshakeBase
		{
			bool timeout = false;
			System.Threading.Timer timer = new System.Threading.Timer(delegate
			{
				timeout = true;
				_innerStream.Close();
			}, null, millisecondsTimeout, -1);
			T val = null;
			Exception ex = null;
			try
			{
				val = parser(readHandshakeHeaders(_innerStream));
				string text = val.Headers["Content-Length"];
				if (text != null && text.Length > 0)
				{
					val.EntityBodyData = readHandshakeEntityBody(_innerStream, text);
				}
			}
			catch (Exception ex2)
			{
				ex = ex2;
			}
			finally
			{
				timer.Change(-1, -1);
				timer.Dispose();
			}
			string text2 = (timeout ? "A timeout has occurred while receiving a handshake." : ((ex != null) ? "An exception has occurred while receiving a handshake." : null));
			if (text2 != null)
			{
				throw new WebSocketException(text2, ex);
			}
			return val;
		}

		internal bool Write(byte[] data)
		{
			lock (_forWrite)
			{
				try
				{
					_innerStream.Write(data, 0, data.Length);
					return true;
				}
				catch
				{
					return false;
				}
			}
		}

		public void Close()
		{
			_innerStream.Close();
		}

		public static WebSocketStream CreateClientStream(TcpClient client, bool secure, string host, RemoteCertificateValidationCallback validationCallback)
		{
			NetworkStream stream = client.GetStream();
			if (secure)
			{
				if (validationCallback == null)
				{
					validationCallback = (object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors) => true;
				}
				WebSocketSharp.Net.Security.SslStream sslStream = new WebSocketSharp.Net.Security.SslStream(stream, leaveInnerStreamOpen: false, validationCallback);
				sslStream.AuthenticateAsClient(host);
				return new WebSocketStream(sslStream);
			}
			return new WebSocketStream(stream);
		}

		public static WebSocketStream CreateServerStream(TcpClient client, bool secure, X509Certificate cert)
		{
			NetworkStream stream = client.GetStream();
			if (secure)
			{
				WebSocketSharp.Net.Security.SslStream sslStream = new WebSocketSharp.Net.Security.SslStream(stream, leaveInnerStreamOpen: false);
				sslStream.AuthenticateAsServer(cert);
				return new WebSocketStream(sslStream);
			}
			return new WebSocketStream(stream);
		}

		public void Dispose()
		{
			_innerStream.Dispose();
		}

		public WebSocketFrame ReadFrame()
		{
			return WebSocketFrame.Parse(_innerStream, unmask: true);
		}

		public void ReadFrameAsync(Action<WebSocketFrame> completed, Action<Exception> error)
		{
			WebSocketFrame.ParseAsync(_innerStream, unmask: true, completed, error);
		}

		public HandshakeRequest ReadHandshakeRequest()
		{
			return ReadHandshake(HandshakeRequest.Parse, 90000);
		}

		public HandshakeResponse ReadHandshakeResponse()
		{
			return ReadHandshake(HandshakeResponse.Parse, 90000);
		}

		public bool WriteFrame(WebSocketFrame frame)
		{
			return Write(frame.ToByteArray());
		}

		public bool WriteHandshake(HandshakeBase handshake)
		{
			return Write(handshake.ToByteArray());
		}
	}
}
namespace WebSocketSharp.Net
{
	internal abstract class AuthenticationBase
	{
		private AuthenticationSchemes _scheme;

		internal NameValueCollection Parameters;

		public string Algorithm => Parameters["algorithm"];

		public string Nonce => Parameters["nonce"];

		public string Opaque => Parameters["opaque"];

		public string Qop => Parameters["qop"];

		public string Realm => Parameters["realm"];

		public AuthenticationSchemes Scheme => _scheme;

		protected AuthenticationBase(AuthenticationSchemes scheme, NameValueCollection parameters)
		{
			_scheme = scheme;
			Parameters = parameters;
		}

		internal static string CreateNonceValue()
		{
			byte[] array = new byte[16];
			new System.Random().NextBytes(array);
			StringBuilder stringBuilder = new StringBuilder(32);
			byte[] array2 = array;
			foreach (byte b in array2)
			{
				stringBuilder.Append(b.ToString("x2"));
			}
			return stringBuilder.ToString();
		}

		internal static NameValueCollection ParseParameters(string value)
		{
			NameValueCollection nameValueCollection = new NameValueCollection();
			foreach (string item in value.SplitHeaderValue(','))
			{
				int num = item.IndexOf('=');
				string name = ((num > 0) ? item.Substring(0, num).Trim() : null);
				string value2 = ((num < 0) ? item.Trim().Trim('"') : ((num < item.Length - 1) ? item.Substring(num + 1).Trim().Trim('"') : string.Empty));
				nameValueCollection.Add(name, value2);
			}
			return nameValueCollection;
		}

		internal abstract string ToBasicString();

		internal abstract string ToDigestString();

		public override string ToString()
		{
			if (_scheme != AuthenticationSchemes.Basic)
			{
				if (_scheme != AuthenticationSchemes.Digest)
				{
					return string.Empty;
				}
				return ToDigestString();
			}
			return ToBasicString();
		}
	}
	internal class AuthenticationChallenge : AuthenticationBase
	{
		public string Domain => Parameters["domain"];

		public string Stale => Parameters["stale"];

		private AuthenticationChallenge(AuthenticationSchemes scheme, NameValueCollection parameters)
			: base(scheme, parameters)
		{
		}

		internal AuthenticationChallenge(AuthenticationSchemes scheme, string realm)
			: base(scheme, new NameValueCollection())
		{
			Parameters["realm"] = realm;
			if (scheme == AuthenticationSchemes.Digest)
			{
				Parameters["nonce"] = AuthenticationBase.CreateNonceValue();
				Parameters["algorithm"] = "MD5";
				Parameters["qop"] = "auth";
			}
		}

		internal static AuthenticationChallenge CreateBasicChallenge(string realm)
		{
			return new AuthenticationChallenge(AuthenticationSchemes.Basic, realm);
		}

		internal static AuthenticationChallenge CreateDigestChallenge(string realm)
		{
			return new AuthenticationChallenge(AuthenticationSchemes.Digest, realm);
		}

		internal static AuthenticationChallenge Parse(string value)
		{
			string[] array = value.Split(new char[1] { ' ' }, 2);
			if (array.Length != 2)
			{
				return null;
			}
			string text = array[0].ToLower();
			if (!(text == "basic"))
			{
				if (!(text == "digest"))
				{
					return null;
				}
				return new AuthenticationChallenge(AuthenticationSchemes.Digest, AuthenticationBase.ParseParameters(array[1]));
			}
			return new AuthenticationChallenge(AuthenticationSchemes.Basic, AuthenticationBase.ParseParameters(array[1]));
		}

		internal override string ToBasicString()
		{
			return string.Format("Basic realm=\"{0}\"", Parameters["realm"]);
		}

		internal override string ToDigestString()
		{
			StringBuilder stringBuilder = new StringBuilder(128);
			string text = Parameters["domain"];
			if (text != null)
			{
				stringBuilder.AppendFormat("Digest realm=\"{0}\", domain=\"{1}\", nonce=\"{2}\"", Parameters["realm"], text, Parameters["nonce"]);
			}
			else
			{
				stringBuilder.AppendFormat("Digest realm=\"{0}\", nonce=\"{1}\"", Parameters["realm"], Parameters["nonce"]);
			}
			string text2 = Parameters["opaque"];
			if (text2 != null)
			{
				stringBuilder.AppendFormat(", opaque=\"{0}\"", text2);
			}
			string text3 = Parameters["stale"];
			if (text3 != null)
			{
				stringBuilder.AppendFormat(", stale={0}", text3);
			}
			string text4 = Parameters["algorithm"];
			if (text4 != null)
			{
				stringBuilder.AppendFormat(", algorithm={0}", text4);
			}
			string text5 = Parameters["qop"];
			if (text5 != null)
			{
				stringBuilder.AppendFormat(", qop=\"{0}\"", text5);
			}
			return stringBuilder.ToString();
		}
	}
	internal class AuthenticationResponse : AuthenticationBase
	{
		private uint _nonceCount;

		internal uint NonceCount
		{
			get
			{
				if (_nonceCount >= uint.MaxValue)
				{
					return 0u;
				}
				return _nonceCount;
			}
		}

		public string Cnonce => Parameters["cnonce"];

		public string Nc => Parameters["nc"];

		public string Password => Parameters["password"];

		public string Response => Parameters["response"];

		public string Uri => Parameters["uri"];

		public string UserName => Parameters["username"];

		private AuthenticationResponse(AuthenticationSchemes scheme, NameValueCollection parameters)
			: base(scheme, parameters)
		{
		}

		internal AuthenticationResponse(NetworkCredential credentials)
			: this(AuthenticationSchemes.Basic, new NameValueCollection(), credentials, 0u)
		{
		}

		internal AuthenticationResponse(AuthenticationChallenge challenge, NetworkCredential credentials, uint nonceCount)
			: this(challenge.Scheme, challenge.Parameters, credentials, nonceCount)
		{
		}

		internal AuthenticationResponse(AuthenticationSchemes scheme, NameValueCollection parameters, NetworkCredential credentials, uint nonceCount)
			: base(scheme, parameters)
		{
			Parameters["username"] = credentials.UserName;
			Parameters["password"] = credentials.Password;
			Parameters["uri"] = credentials.Domain;
			_nonceCount = nonceCount;
			if (scheme == AuthenticationSchemes.Digest)
			{
				initAsDigest();
			}
		}

		private static string createA1(string username, string password, string realm)
		{
			return $"{username}:{realm}:{password}";
		}

		private static string createA1(string username, string password, string realm, string nonce, string cnonce)
		{
			return $"{hash(createA1(username, password, realm))}:{nonce}:{cnonce}";
		}

		private static string createA2(string method, string uri)
		{
			return $"{method}:{uri}";
		}

		private static string createA2(string method, string uri, string entity)
		{
			return $"{method}:{uri}:{hash(entity)}";
		}

		private static string hash(string value)
		{
			byte[] bytes = Encoding.UTF8.GetBytes(value);
			byte[] array = MD5.Create().ComputeHash(bytes);
			StringBuilder stringBuilder = new StringBuilder(64);
			byte[] array2 = array;
			foreach (byte b in array2)
			{
				stringBuilder.Append(b.ToString("x2"));
			}
			return stringBuilder.ToString();
		}

		private void initAsDigest()
		{
			string text = Parameters["qop"];
			if (text != null)
			{
				if (text.Split(',').Contains((string qop) => qop.Trim().ToLower() == "auth"))
				{
					Parameters["qop"] = "auth";
					Parameters["cnonce"] = AuthenticationBase.CreateNonceValue();
					Parameters["nc"] = $"{++_nonceCount:x8}";
				}
				else
				{
					Parameters["qop"] = null;
				}
			}
			Parameters["method"] = "GET";
			Parameters["response"] = CreateRequestDigest(Parameters);
		}

		internal static string CreateRequestDigest(NameValueCollection parameters)
		{
			string username = parameters["username"];
			string password = parameters["password"];
			string realm = parameters["realm"];
			string text = parameters["nonce"];
			string uri = parameters["uri"];
			string text2 = parameters["algorithm"];
			string text3 = parameters["qop"];
			string text4 = parameters["cnonce"];
			string text5 = parameters["nc"];
			string method = parameters["method"];
			string value = ((text2 != null && text2.ToLower() == "md5-sess") ? createA1(username, password, realm, text, text4) : createA1(username, password, realm));
			string value2 = ((text3 != null && text3.ToLower() == "auth-int") ? createA2(method, uri, parameters["entity"]) : createA2(method, uri));
			string arg = hash(value);
			string arg2 = ((text3 != null) ? $"{text}:{text5}:{text4}:{text3}:{hash(value2)}" : $"{text}:{hash(value2)}");
			return hash($"{arg}:{arg2}");
		}

		internal static AuthenticationResponse Parse(string value)
		{
			try
			{
				string[] array = value.Split(new char[1] { ' ' }, 2);
				if (array.Length != 2)
				{
					return null;
				}
				string text = array[0].ToLower();
				return (text == "basic") ? new AuthenticationResponse(AuthenticationSchemes.Basic, ParseBasicCredentials(array[1])) : ((text == "digest") ? new AuthenticationResponse(AuthenticationSchemes.Digest, AuthenticationBase.ParseParameters(array[1])) : null);
			}
			catch
			{
			}
			return null;
		}

		internal static NameValueCollection ParseBasicCredentials(string value)
		{
			string @string = Encoding.Default.GetString(Convert.FromBase64String(value));
			int num = @string.IndexOf(':');
			string text = @string.Substring(0, num);
			string value2 = ((num < @string.Length - 1) ? @string.Substring(num + 1) : string.Empty);
			num = text.IndexOf('\\');
			if (num > -1)
			{
				text = text.Substring(num + 1);
			}
			return new NameValueCollection
			{
				["username"] = text,
				["password"] = value2
			};
		}

		internal override string ToBasicString()
		{
			string s = string.Format("{0}:{1}", Parameters["username"], Parameters["password"]);
			string text = Convert.ToBase64String(Encoding.UTF8.GetBytes(s));
			return "Basic " + text;
		}

		internal override string ToDigestString()
		{
			StringBuilder stringBuilder = new StringBuilder(256);
			stringBuilder.AppendFormat("Digest username=\"{0}\", realm=\"{1}\", nonce=\"{2}\", uri=\"{3}\", response=\"{4}\"", Parameters["username"], Parameters["realm"], Parameters["nonce"], Parameters["uri"], Parameters["response"]);
			string text = Parameters["opaque"];
			if (text != null)
			{
				stringBuilder.AppendFormat(", opaque=\"{0}\"", text);
			}
			string text2 = Parameters["algorithm"];
			if (text2 != null)
			{
				stringBuilder.AppendFormat(", algorithm={0}", text2);
			}
			string text3 = Parameters["qop"];
			if (text3 != null)
			{
				stringBuilder.AppendFormat(", qop={0}, cnonce=\"{1}\", nc={2}", text3, Parameters["cnonce"], Parameters["nc"]);
			}
			return stringBuilder.ToString();
		}

		public IIdentity ToIdentity()
		{
			AuthenticationSchemes scheme = base.Scheme;
			if (scheme != AuthenticationSchemes.Basic)
			{
				return (scheme == AuthenticationSchemes.Digest) ? new HttpDigestIdentity(Parameters) : null;
			}
			return new HttpBasicIdentity(Parameters["username"], Parameters["password"]);
		}
	}
	[Flags]
	public enum AuthenticationSchemes
	{
		None = 0,
		Digest = 1,
		Basic = 8,
		Anonymous = 0x8000
	}
	internal class Chunk
	{
		private byte[] _data;

		private int _offset;

		public int ReadLeft => _data.Length - _offset;

		public Chunk(byte[] data)
		{
			_data = data;
		}

		public int Read(byte[] buffer, int offset, int size)
		{
			int num = _data.Length - _offset;
			if (num == 0)
			{
				return num;
			}
			if (size > num)
			{
				size = num;
			}
			Buffer.BlockCopy(_data, _offset, buffer, offset, size);
			_offset += size;
			return size;
		}
	}
	internal class ChunkedRequestStream : RequestStream
	{
		private const int _bufferSize = 8192;

		private HttpListenerContext _context;

		private ChunkStream _decoder;

		private bool _disposed;

		private bool _noMoreData;

		public ChunkStream Decoder
		{
			get
			{
				return _decoder;
			}
			set
			{
				_decoder = value;
			}
		}

		public ChunkedRequestStream(HttpListenerContext context, Stream stream, byte[] buffer, int offset, int length)
			: base(stream, buffer, offset, length)
		{
			_context = context;
			_decoder = new ChunkStream((WebHeaderCollection)context.Request.Headers);
		}

		private void onRead(IAsyncResult asyncResult)
		{
			ReadBufferState readBufferState = (ReadBufferState)asyncResult.AsyncState;
			HttpStreamAsyncResult asyncResult2 = readBufferState.AsyncResult;
			try
			{
				int size = base.EndRead(asyncResult);
				_decoder.Write(asyncResult2.Buffer, asyncResult2.Offset, size);
				size = _decoder.Read(readBufferState.Buffer, readBufferState.Offset, readBufferState.Count);
				readBufferState.Offset += size;
				readBufferState.Count -= size;
				if (readBufferState.Count == 0 || !_decoder.WantMore || size == 0)
				{
					_noMoreData = !_decoder.WantMore && size == 0;
					asyncResult2.Count = readBufferState.InitialCount - readBufferState.Count;
					asyncResult2.Complete();
				}
				else
				{
					asyncResult2.Offset = 0;
					asyncResult2.Count = Math.Min(8192, _decoder.ChunkLeft + 6);
					base.BeginRead(asyncResult2.Buffer, asyncResult2.Offset, asyncResult2.Count, (AsyncCallback)onRead, (object)readBufferState);
				}
			}
			catch (Exception ex)
			{
				_context.Connection.SendError(ex.Message, 400);
				asyncResult2.Complete(ex);
			}
		}

		public override IAsyncResult BeginRead(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
		{
			if (_disposed)
			{
				throw new ObjectDisposedException(GetType().ToString());
			}
			if (buffer == null)
			{
				throw new ArgumentNullException("buffer");
			}
			int num = buffer.Length;
			if (offset < 0 || offset > num)
			{
				throw new ArgumentOutOfRangeException("'offset' exceeds the size of buffer.");
			}
			if (count < 0 || offset > num - count)
			{
				throw new ArgumentOutOfRangeException("'offset' + 'count' exceeds the size of buffer.");
			}
			HttpStreamAsyncResult httpStreamAsyncResult = new HttpStreamAsyncResult(callback, state);
			if (_noMoreData)
			{
				httpStreamAsyncResult.Complete();
				return httpStreamAsyncResult;
			}
			int num2 = _decoder.Read(buffer, offset, count);
			offset += num2;
			count -= num2;
			if (count == 0)
			{
				httpStreamAsyncResult.Count = num2;
				httpStreamAsyncResult.Complete();
				return httpStreamAsyncResult;
			}
			if (!_decoder.WantMore)
			{
				_noMoreData = num2 == 0;
				httpStreamAsyncResult.Count = num2;
				httpStreamAsyncResult.Complete();
				return httpStreamAsyncResult;
			}
			httpStreamAsyncResult.Buffer = new byte[8192];
			httpStreamAsyncResult.Offset = 0;
			httpStreamAsyncResult.Count = 8192;
			ReadBufferState readBufferState = new ReadBufferState(buffer, offset, count, httpStreamAsyncResult);
			readBufferState.InitialCount += num2;
			base.BeginRead(httpStreamAsyncResult.Buffer, httpStreamAsyncResult.Offset, httpStreamAsyncResult.Count, (AsyncCallback)onRead, (object)readBufferState);
			return httpStreamAsyncResult;
		}

		public override void Close()
		{
			if (!_disposed)
			{
				_disposed = true;
				base.Close();
			}
		}

		public override int EndRead(IAsyncResult asyncResult)
		{
			if (_disposed)
			{
				throw new ObjectDisposedException(GetType().ToString());
			}
			if (asyncResult == null)
			{
				throw new ArgumentNullException("asyncResult");
			}
			if (!(asyncResult is HttpStreamAsyncResult httpStreamAsyncResult))
			{
				throw new ArgumentException("Wrong IAsyncResult.", "asyncResult");
			}
			if (!httpStreamAsyncResult.IsCompleted)
			{
				httpStreamAsyncResult.AsyncWaitHandle.WaitOne();
			}
			if (httpStreamAsyncResult.Error != null)
			{
				throw new HttpListenerException(400, "I/O operation aborted.");
			}
			return httpStreamAsyncResult.Count;
		}

		public override int Read(byte[] buffer, int offset, int count)
		{
			IAsyncResult asyncResult = BeginRead(buffer, offset, count, null, null);
			return EndRead(asyncResult);
		}
	}
	internal class ChunkStream
	{
		private int _chunkRead;

		private int _chunkSize;

		private List<Chunk> _chunks;

		private bool _gotit;

		private WebHeaderCollection _headers;

		private StringBuilder _saved;

		private bool _sawCR;

		private InputChunkState _state;

		private int _trailerState;

		internal WebHeaderCollection Headers => _headers;

		public int ChunkLeft => _chunkSize - _chunkRead;

		public bool WantMore
		{
			get
			{
				if (_chunkRead == _chunkSize && _chunkSize == 0)
				{
					return _state != InputChunkState.None;
				}
				return true;
			}
		}

		public ChunkStream(byte[] buffer, int offset, int size, WebHeaderCollection headers)
			: this(headers)
		{
			Write(buffer, offset, size);
		}

		public ChunkStream(WebHeaderCollection headers)
		{
			_headers = headers;
			_chunkSize = -1;
			_chunks = new List<Chunk>();
			_saved = new StringBuilder();
		}

		private InputChunkState readCRLF(byte[] buffer, ref int offset, int size)
		{
			if (!_sawCR)
			{
				if (buffer[offset++] != 13)
				{
					throwProtocolViolation("Expecting \\r.");
				}
				_sawCR = true;
				if (offset == size)
				{
					return InputChunkState.BodyFinished;
				}
			}
			if (buffer[offset++] != 10)
			{
				throwProtocolViolation("Expecting \\n.");
			}
			return InputChunkState.None;
		}

		private int readFromChunks(byte[] buffer, int offset, int size)
		{
			int count = _chunks.Count;
			int num = 0;
			for (int i = 0; i < count; i++)
			{
				Chunk chunk = _chunks[i];
				if (chunk == null)
				{
					continue;
				}
				if (chunk.ReadLeft == 0)
				{
					_chunks[i] = null;
					continue;
				}
				num += chunk.Read(buffer, offset + num, size - num);
				if (num == size)
				{
					break;
				}
			}
			return num;
		}

		private InputChunkState readTrailer(byte[] buffer, ref int offset, int size)
		{
			char c = '\0';
			if (_trailerState == 2 && buffer[offset] == 13 && _saved.Length == 0)
			{
				offset++;
				if (offset < size && buffer[offset] == 10)
				{
					offset++;
					return InputChunkState.None;
				}
				offset--;
			}
			int num = _trailerState;
			string text = "\r\n\r";
			while (offset < size && num < 4)
			{
				c = (char)buffer[offset++];
				if ((num == 0 || num == 2) && c == '\r')
				{
					num++;
				}
				else if ((num == 1 || num == 3) && c == '\n')
				{
					num++;
				}
				else if (num > 0)
				{
					_saved.Append(text.Substring(0, (_saved.Length == 0) ? (num - 2) : num));
					num = 0;
					if (_saved.Length > 4196)
					{
						throwProtocolViolation("Error reading trailer (too long).");
					}
				}
			}
			if (num < 4)
			{
				_trailerState = num;
				if (offset < size)
				{
					throwProtocolViolation("Error reading trailer.");
				}
				return InputChunkState.Trailer;
			}
			StringReader stringReader = new StringReader(_saved.ToString());
			string text2;
			while ((text2 = stringReader.ReadLine()) != null && text2 != "")
			{
				_headers.Add(text2);
			}
			return InputChunkState.None;
		}

		private static string removeChunkExtension(string input)
		{
			int num = input.IndexOf(';');
			if (num <= -1)
			{
				return input;
			}
			return input.Substring(0, num);
		}

		private InputChunkState setChunkSize(byte[] buffer, ref int offset, int size)
		{
			char c = '\0';
			while (offset < size)
			{
				c = (char)buffer[offset++];
				if (c == '\r')
				{
					if (_sawCR)
					{
						throwProtocolViolation("2 CR found.");
					}
					_sawCR = true;
					continue;
				}
				if (_sawCR && c == '\n')
				{
					break;
				}
				if (c == ' ')
				{
					_gotit = true;
				}
				if (!_gotit)
				{
					_saved.Append(c);
				}
				if (_saved.Length > 20)
				{
					throwProtocolViolation("Chunk size too long.");
				}
			}
			if (!_sawCR || c != '\n')
			{
				if (offset < size)
				{
					throwProtocolViolation("Missing \\n.");
				}
				try
				{
					if (_saved.Length > 0)
					{
						_chunkSize = int.Parse(removeChunkExtension(_saved.ToString()), NumberStyles.HexNumber);
					}
				}
				catch
				{
					throwProtocolViolation("Cannot parse chunk size.");
				}
				return InputChunkState.None;
			}
			_chunkRead = 0;
			try
			{
				_chunkSize = int.Parse(removeChunkExtension(_saved.ToString()), NumberStyles.HexNumber);
			}
			catch
			{
				throwProtocolViolation("Cannot parse chunk size.");
			}
			if (_chunkSize == 0)
			{
				_trailerState = 2;
				return InputChunkState.Trailer;
			}
			return InputChunkState.Body;
		}

		private static void throwProtocolViolation(string message)
		{
			throw new WebException(message, null, WebExceptionStatus.ServerProtocolViolation, null);
		}

		private void write(byte[] buffer, ref int offset, int size)
		{
			if (_state == InputChunkState.None)
			{
				_state = setChunkSize(buffer, ref offset, size);
				if (_state == InputChunkState.None)
				{
					return;
				}
				_saved.Length = 0;
				_sawCR = false;
				_gotit = false;
			}
			if (_state == InputChunkState.Body && offset < size)
			{
				_state = writeBody(buffer, ref offset, size);
				if (_state == InputChunkState.Body)
				{
					return;
				}
			}
			if (_state == InputChunkState.BodyFinished && offset < size)
			{
				_state = readCRLF(buffer, ref offset, size);
				if (_state == InputChunkState.BodyFinished)
				{
					return;
				}
				_sawCR = false;
			}
			if (_state == InputChunkState.Trailer && offset < size)
			{
				_state = readTrailer(buffer, ref offset, size);
				if (_state == InputChunkState.Trailer)
				{
					return;
				}
				_saved.Length = 0;
				_sawCR = false;
				_gotit = false;
			}
			if (offset < size)
			{
				write(buffer, ref offset, size);
			}
		}

		private InputChunkState writeBody(byte[] buffer, ref int offset, int size)
		{
			if (_chunkSize == 0)
			{
				return InputChunkState.BodyFinished;
			}
			int num = size - offset;
			if (num + _chunkRead > _chunkSize)
			{
				num = _chunkSize - _chunkRead;
			}
			byte[] array = new byte[num];
			Buffer.BlockCopy(buffer, offset, array, 0, num);
			_chunks.Add(new Chunk(array));
			offset += num;
			_chunkRead += num;
			if (_chunkRead != _chunkSize)
			{
				return InputChunkState.Body;
			}
			return InputChunkState.BodyFinished;
		}

		public int Read(byte[] buffer, int offset, int size)
		{
			return readFromChunks(buffer, offset, size);
		}

		public void ResetBuffer()
		{
			_chunkSize = -1;
			_chunkRead = 0;
			_chunks.Clear();
		}

		public void Write(byte[] buffer, int offset, int size)
		{
			write(buffer, ref offset, size);
		}

		public void WriteAndReadBack(byte[] buffer, int offset, int size, ref int read)
		{
			if (offset + read > 0)
			{
				Write(buffer, offset, offset + read);
			}
			read = readFromChunks(buffer, offset, size);
		}
	}
	[Serializable]
	public sealed class Cookie
	{
		private static char[] _reservedCharsForName = new char[7] { ' ', '=', ';', ',', '\n', '\r', '\t' };

		private static char[] _reservedCharsForValue = new char[2] { ';', ',' };

		private string _comment;

		private Uri _commentUri;

		private bool _discard;

		private string _domain;

		private DateTime _expires;

		private bool _httpOnly;

		private string _name;

		private string _path;

		private string _port;

		private int[] _ports;

		private bool _secure;

		private DateTime _timestamp;

		private string _value;

		private int _version;

		internal bool ExactDomain { get; set; }

		internal int MaxAge
		{
			get
			{
				if (_expires == DateTime.MinValue)
				{
					return 0;
				}
				TimeSpan timeSpan = ((_expires.Kind != DateTimeKind.Local) ? _expires.ToLocalTime() : _expires) - DateTime.Now;
				if (!(timeSpan > TimeSpan.Zero))
				{
					return 0;
				}
				return (int)timeSpan.TotalSeconds;
			}
		}

		internal int[] Ports => _ports;

		public string Comment
		{
			get
			{
				return _comment;
			}
			set
			{
				_comment = value ?? string.Empty;
			}
		}

		public Uri CommentUri
		{
			get
			{
				return _commentUri;
			}
			set
			{
				_commentUri = value;
			}
		}

		public bool Discard
		{
			get
			{
				return _discard;
			}
			set
			{
				_discard = value;
			}
		}

		public string Domain
		{
			get
			{
				return _domain;
			}
			set
			{
				if (value.IsNullOrEmpty())
				{
					_domain = string.Empty;
					ExactDomain = true;
				}
				else
				{
					_domain = value;
					ExactDomain = value[0] != '.';
				}
			}
		}

		public bool Expired
		{
			get
			{
				if (_expires != DateTime.MinValue)
				{
					return _expires <= DateTime.Now;
				}
				return false;
			}
			set
			{
				_expires = (value ? DateTime.Now : DateTime.MinValue);
			}
		}

		public DateTime Expires
		{
			get
			{
				return _expires;
			}
			set
			{
				_expires = value;
			}
		}

		public bool HttpOnly
		{
			get
			{
				return _httpOnly;
			}
			set
			{
				_httpOnly = value;
			}
		}

		public string Name
		{
			get
			{
				return _name;
			}
			set
			{
				if (!canSetName(value, out var message))
				{
					throw new CookieException(message);
				}
				_name = value;
			}
		}

		public string Path
		{
			get
			{
				return _path;
			}
			set
			{
				_path = value ?? string.Empty;
			}
		}

		public string Port
		{
			get
			{
				return _port;
			}
			set
			{
				if (value.IsNullOrEmpty())
				{
					_port = string.Empty;
					_ports = new int[0];
					return;
				}
				if (!value.IsEnclosedIn('"'))
				{
					throw new CookieException("The value of Port attribute must be enclosed in double quotes.");
				}
				if (!tryCreatePorts(value, out _ports, out var parseError))
				{
					throw new CookieException($"The value specified for a Port attribute contains an invalid value: {parseError}");
				}
				_port = value;
			}
		}

		public bool Secure
		{
			get
			{
				return _secure;
			}
			set
			{
				_secure = value;
			}
		}

		public DateTime TimeStamp => _timestamp;

		public string Value
		{
			get
			{
				return _value;
			}
			set
			{
				if (!canSetValue(value, out var message))
				{
					throw new CookieException(message);
				}
				_value = ((value.Length > 0) ? value : "\"\"");
			}
		}

		public int Version
		{
			get
			{
				return _version;
			}
			set
			{
				if (value < 0 || value > 1)
				{
					throw new ArgumentOutOfRangeException("value", "Must be 0 or 1.");
				}
				_version = value;
			}
		}

		public Cookie()
		{
			_comment = string.Empty;
			_domain = string.Empty;
			_expires = DateTime.MinValue;
			_name = string.Empty;
			_path = string.Empty;
			_port = string.Empty;
			_ports = new int[0];
			_timestamp = DateTime.Now;
			_value = string.Empty;
			_version = 0;
		}

		public Cookie(string name, string value)
			: this()
		{
			Name = name;
			Value = value;
		}

		public Cookie(string name, string value, string path)
			: this(name, value)
		{
			Path = path;
		}

		public Cookie(string name, string value, string path, string domain)
			: this(name, value, path)
		{
			Domain = domain;
		}

		private static bool canSetName(string name, out string message)
		{
			if (name.IsNullOrEmpty())
			{
				message = "Name must not be null or empty.";
				return false;
			}
			if (name[0] == '$' || name.Contains(_reservedCharsForName))
			{
				message = "The value specified for a Name contains an invalid character.";
				return false;
			}
			message = string.Empty;
			return true;
		}

		private static bool canSetValue(string value, out string message)
		{
			if (value == null)
			{
				message = "Value must not be null.";
				return false;
			}
			if (value.Contains(_reservedCharsForValue) && !value.IsEnclosedIn('"'))
			{
				message = "The value specified for a Value contains an invalid character.";
				return false;
			}
			message = string.Empty;
			return true;
		}

		private static int hash(int i, int j, int k, int l, int m)
		{
			return i ^ ((j << 13) | (j >> 19)) ^ ((k << 26) | (k >> 6)) ^ ((l << 7) | (l >> 25)) ^ ((m << 20) | (m >> 12));
		}

		private string toResponseStringVersion0()
		{
			StringBuilder stringBuilder = new StringBuilder(64);
			stringBuilder.AppendFormat("{0}={1}", _name, _value);
			if (_expires != DateTime.MinValue)
			{
				stringBuilder.AppendFormat("; Expires={0}", _expires.ToUniversalTime().ToString("ddd, dd'-'MMM'-'yyyy HH':'mm':'ss 'GMT'", CultureInfo.CreateSpecificCulture("en-US")));
			}
			if (!_path.IsNullOrEmpty())
			{
				stringBuilder.AppendFormat("; Path={0}", _path);
			}
			if (!_domain.IsNullOrEmpty())
			{
				stringBuilder.AppendFormat("; Domain={0}", _domain);
			}
			if (_secure)
			{
				stringBuilder.Append("; Secure");
			}
			if (_httpOnly)
			{
				stringBuilder.Append("; HttpOnly");
			}
			return stringBuilder.ToString();
		}

		private string toResponseStringVersion1()
		{
			StringBuilder stringBuilder = new StringBuilder(64);
			stringBuilder.AppendFormat("{0}={1}; Version={2}", _name, _value, _version);
			if (_expires != DateTime.MinValue)
			{
				stringBuilder.AppendFormat("; Max-Age={0}", MaxAge);
			}
			if (!_path.IsNullOrEmpty())
			{
				stringBuilder.AppendFormat("; Path={0}", _path);
			}
			if (!_domain.IsNullOrEmpty())
			{
				stringBuilder.AppendFormat("; Domain={0}", _domain);
			}
			if (!_port.IsNullOrEmpty())
			{
				if (_port == "\"\"")
				{
					stringBuilder.Append("; Port");
				}
				else
				{
					stringBuilder.AppendFormat("; Port={0}", _port);
				}
			}
			if (!_comment.IsNullOrEmpty())
			{
				stringBuilder.AppendFormat("; Comment={0}", _comment.UrlEncode());
			}
			if (_commentUri != null)
			{
				stringBuilder.AppendFormat("; CommentURL={0}", _commentUri.OriginalString.Quote());
			}
			if (_discard)
			{
				stringBuilder.Append("; Discard");
			}
			if (_secure)
			{
				stringBuilder.Append("; Secure");
			}
			return stringBuilder.ToString();
		}

		private static bool tryCreatePorts(string value, out int[] result, out string parseError)
		{
			string[] array = value.Trim('"').Split(',');
			int[] array2 = new int[array.Length];
			for (int i = 0; i < array.Length; i++)
			{
				array2[i] = int.MinValue;
				string text = array[i].Trim();
				if (text.Length != 0 && !int.TryParse(text, out array2[i]))
				{
					result = new int[0];
					parseError = text;
					return false;
				}
			}
			result = array2;
			parseError = string.Empty;
			return true;
		}

		internal string ToRequestString(Uri uri)
		{
			if (_name.Length == 0)
			{
				return string.Empty;
			}
			if (_version == 0)
			{
				return $"{_name}={_value}";
			}
			StringBuilder stringBuilder = new StringBuilder(64);
			stringBuilder.AppendFormat("$Version={0}; {1}={2}", _version, _name, _value);
			if (!_path.IsNullOrEmpty())
			{
				stringBuilder.AppendFormat("; $Path={0}", _path);
			}
			else if (uri != null)
			{
				stringBuilder.AppendFormat("; $Path={0}", uri.GetAbsolutePath());
			}
			else
			{
				stringBuilder.Append("; $Path=/");
			}
			if ((uri == null || uri.Host != _domain) && !_domain.IsNullOrEmpty())
			{
				stringBuilder.AppendFormat("; $Domain={0}", _domain);
			}
			if (!_port.IsNullOrEmpty())
			{
				if (_port == "\"\"")
				{
					stringBuilder.Append("; $Port");
				}
				else
				{
					stringBuilder.AppendFormat("; $Port={0}", _port);
				}
			}
			return stringBuilder.ToString();
		}

		internal string ToResponseString()
		{
			if (_name.Length <= 0)
			{
				return string.Empty;
			}
			if (_version != 0)
			{
				return toResponseStringVersion1();
			}
			return toResponseStringVersion0();
		}

		public override bool Equals(object comparand)
		{
			if (comparand is Cookie cookie && _name.Equals(cookie.Name, StringComparison.InvariantCultureIgnoreCase) && _value.Equals(cookie.Value, StringComparison.InvariantCulture) && _path.Equals(cookie.Path, StringComparison.InvariantCulture) && _domain.Equals(cookie.Domain, StringComparison.InvariantCultureIgnoreCase))
			{
				return _version == cookie.Version;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return hash(StringComparer.InvariantCultureIgnoreCase.GetHashCode(_name), _value.GetHashCode(), _path.GetHashCode(), StringComparer.InvariantCultureIgnoreCase.GetHashCode(_domain), _version);
		}

		public override string ToString()
		{
			return ToRequestString(null);
		}
	}
	[Serializable]
	public class CookieCollection : ICollection, IEnumerable
	{
		private List<Cookie> _list;

		private object _sync;

		internal IList<Cookie> List => _list;

		internal IEnumerable<Cookie> Sorted
		{
			get
			{
				List<Cookie> list = new List<Cookie>(_list);
				if (list.Count > 1)
				{
					list.Sort(compareCookieWithinSorted);
				}
				return list;
			}
		}

		public int Count => _list.Count;

		public bool IsReadOnly => true;

		public bool IsSynchronized => false;

		public Cookie this[int index]
		{
			get
			{
				if (index < 0 || index >= _list.Count)
				{
					throw new ArgumentOutOfRangeException("index");
				}
				return _list[index];
			}
		}

		public Cookie this[string name]
		{
			get
			{
				if (name == null)
				{
					throw new ArgumentNullException("name");
				}
				foreach (Cookie item in Sorted)
				{
					if (item.Name.Equals(name, StringComparison.InvariantCultureIgnoreCase))
					{
						return item;
					}
				}
				return null;
			}
		}

		public object SyncRoot => _sync ?? (_sync = ((ICollection)_list).SyncRoot);

		public CookieCollection()
		{
			_list = new List<Cookie>();
		}

		private static int compareCookieWithinSort(Cookie x, Cookie y)
		{
			return x.Name.Length + x.Value.Length - (y.Name.Length + y.Value.Length);
		}

		private static int compareCookieWithinSorted(Cookie x, Cookie y)
		{
			int num = 0;
			if ((num = x.Version - y.Version) == 0)
			{
				if ((num = x.Name.CompareTo(y.Name)) == 0)
				{
					return y.Path.Length - x.Path.Length;
				}
				return num;
			}
			return num;
		}

		private static CookieCollection parseRequest(string value)
		{
			CookieCollection cookieCollection = new CookieCollection();
			Cookie cookie = null;
			int num = 0;
			string[] array = splitCookieHeaderValue(value);
			for (int i = 0; i < array.Length; i++)
			{
				string text = array[i].Trim();
				if (text.Length == 0)
				{
					continue;
				}
				if (text.StartsWith("$version", StringComparison.InvariantCultureIgnoreCase))
				{
					num = int.Parse(text.GetValueInternal("=").Trim('"'));
					continue;
				}
				if (text.StartsWith("$path", StringComparison.InvariantCultureIgnoreCase))
				{
					if (cookie != null)
					{
						cookie.Path = text.GetValueInternal("=");
					}
					continue;
				}
				if (text.StartsWith("$domain", StringComparison.InvariantCultureIgnoreCase))
				{
					if (cookie != null)
					{
						cookie.Domain = text.GetValueInternal("=");
					}
					continue;
				}
				if (text.StartsWith("$port", StringComparison.InvariantCultureIgnoreCase))
				{
					string port = (text.Equals("$port", StringComparison.InvariantCultureIgnoreCase) ? "\"\"" : text.GetValueInternal("="));
					if (cookie != null)
					{
						cookie.Port = port;
					}
					continue;
				}
				if (cookie != null)
				{
					cookieCollection.Add(cookie);
				}
				string value2 = string.Empty;
				int num2 = text.IndexOf('=');
				string name;
				if (num2 == -1)
				{
					name = text;
				}
				else if (num2 == text.Length - 1)
				{
					name = text.Substring(0, num2).TrimEnd(' ');
				}
				else
				{
					name = text.Substring(0, num2).TrimEnd(' ');
					value2 = text.Substring(num2 + 1).TrimStart(' ');
				}
				cookie = new Cookie(name, value2);
				if (num != 0)
				{
					cookie.Version = num;
				}
			}
			if (cookie != null)
			{
				cookieCollection.Add(cookie);
			}
			return cookieCollection;
		}

		private static CookieCollection parseResponse(string value)
		{
			CookieCollection cookieCollection = new CookieCollection();
			Cookie cookie = null;
			string[] array = splitCookieHeaderValue(value);
			for (int i = 0; i < array.Length; i++)
			{
				string text = array[i].Trim();
				if (text.Length == 0)
				{
					continue;
				}
				if (text.StartsWith("version", StringComparison.InvariantCultureIgnoreCase))
				{
					if (cookie != null)
					{
						cookie.Version = int.Parse(text.GetValueInternal("=").Trim('"'));
					}
					continue;
				}
				if (text.StartsWith("expires", StringComparison.InvariantCultureIgnoreCase))
				{
					StringBuilder stringBuilder = new StringBuilder(text.GetValueInternal("="), 32);
					if (i < array.Length - 1)
					{
						stringBuilder.AppendFormat(", {0}", array[++i].Trim());
					}
					if (!DateTime.TryParseExact(stringBuilder.ToString(), new string[2] { "ddd, dd'-'MMM'-'yyyy HH':'mm':'ss 'GMT'", "r" }, CultureInfo.CreateSpecificCulture("en-US"), DateTimeStyles.AdjustToUniversal | DateTimeStyles.AssumeUniversal, out var result))
					{
						result = DateTime.Now;
					}
					if (cookie != null && cookie.Expires == DateTime.MinValue)
					{
						cookie.Expires = result.ToLocalTime();
					}
					continue;
				}
				if (text.StartsWith("max-age", StringComparison.InvariantCultureIgnoreCase))
				{
					int num = int.Parse(text.GetValueInternal("=").Trim('"'));
					DateTime expires = DateTime.Now.AddSeconds(num);
					if (cookie != null)
					{
						cookie.Expires = expires;
					}
					continue;
				}
				if (text.StartsWith("path", StringComparison.InvariantCultureIgnoreCase))
				{
					if (cookie != null)
					{
						cookie.Path = text.GetValueInternal("=");
					}
					continue;
				}
				if (text.StartsWith("domain", StringComparison.InvariantCultureIgnoreCase))
				{
					if (cookie != null)
					{
						cookie.Domain = text.GetValueInternal("=");
					}
					continue;
				}
				if (text.StartsWith("port", StringComparison.InvariantCultureIgnoreCase))
				{
					string port = (text.Equals("port", StringComparison.InvariantCultureIgnoreCase) ? "\"\"" : text.GetValueInternal("="));
					if (cookie != null)
					{
						cookie.Port = port;
					}
					continue;
				}
				if (text.StartsWith("comment", StringComparison.InvariantCultureIgnoreCase))
				{
					if (cookie != null)
					{
						cookie.Comment = text.GetValueInternal("=").UrlDecode();
					}
					continue;
				}
				if (text.StartsWith("commenturl", StringComparison.InvariantCultureIgnoreCase))
				{
					if (cookie != null)
					{
						cookie.CommentUri = text.GetValueInternal("=").Trim('"').ToUri();
					}
					continue;
				}
				if (text.StartsWith("discard", StringComparison.InvariantCultureIgnoreCase))
				{
					if (cookie != null)
					{
						cookie.Discard = true;
					}
					continue;
				}
				if (text.StartsWith("secure", StringComparison.InvariantCultureIgnoreCase))
				{
					if (cookie != null)
					{
						cookie.Secure = true;
					}
					continue;
				}
				if (text.StartsWith("httponly", StringComparison.InvariantCultureIgnoreCase))
				{
					if (cookie != null)
					{
						cookie.HttpOnly = true;
					}
					continue;
				}
				if (cookie != null)
				{
					cookieCollection.Add(cookie);
				}
				string value2 = string.Empty;
				int num2 = text.IndexOf('=');
				string name;
				if (num2 == -1)
				{
					name = text;
				}
				else if (num2 == text.Length - 1)
				{
					name = text.Substring(0, num2).TrimEnd(' ');
				}
				else
				{
					name = text.Substring(0, num2).TrimEnd(' ');
					value2 = text.Substring(num2 + 1).TrimStart(' ');
				}
				cookie = new Cookie(name, value2);
			}
			if (cookie != null)
			{
				cookieCollection.Add(cookie);
			}
			return cookieCollection;
		}

		private int searchCookie(Cookie cookie)
		{
			string name = cookie.Name;
			string path = cookie.Path;
			string domain = cookie.Domain;
			int version = cookie.Version;
			for (int num = _list.Count - 1; num >= 0; num--)
			{
				Cookie cookie2 = _list[num];
				if (cookie2.Name.Equals(name, StringComparison.InvariantCultureIgnoreCase) && cookie2.Path.Equals(path, StringComparison.InvariantCulture) && cookie2.Domain.Equals(domain, StringComparison.InvariantCultureIgnoreCase) && cookie2.Version == version)
				{
					return num;
				}
			}
			return -1;
		}

		private static string[] splitCookieHeaderValue(string value)
		{
			return new List<string>(value.SplitHeaderValue(',', ';')).ToArray();
		}

		internal static CookieCollection Parse(string value, bool response)
		{
			if (!response)
			{
				return parseRequest(value);
			}
			return parseResponse(value);
		}

		internal void SetOrRemove(Cookie cookie)
		{
			int num = searchCookie(cookie);
			if (num == -1)
			{
				if (!cookie.Expired)
				{
					_list.Add(cookie);
				}
			}
			else if (!cookie.Expired)
			{
				_list[num] = cookie;
			}
			else
			{
				_list.RemoveAt(num);
			}
		}

		internal void SetOrRemove(CookieCollection cookies)
		{
			foreach (Cookie cookie in cookies)
			{
				SetOrRemove(cookie);
			}
		}

		internal void Sort()
		{
			if (_list.Count > 1)
			{
				_list.Sort(compareCookieWithinSort);
			}
		}

		public void Add(Cookie cookie)
		{
			if (cookie == null)
			{
				throw new ArgumentNullException("cookie");
			}
			int num = searchCookie(cookie);
			if (num == -1)
			{
				_list.Add(cookie);
			}
			else
			{
				_list[num] = cookie;
			}
		}

		public void Add(CookieCollection cookies)
		{
			if (cookies == null)
			{
				throw new ArgumentNullException("cookies");
			}
			foreach (Cookie cookie in cookies)
			{
				Add(cookie);
			}
		}

		public void CopyTo(Array array, int index)
		{
			if (array == null)
			{
				throw new ArgumentNullException("array");
			}
			if (index < 0)
			{
				throw new ArgumentOutOfRangeException("index", "Less than zero.");
			}
			if (array.Rank > 1)
			{
				throw new ArgumentException("Multidimensional.", "array");
			}
			if (array.Length - index < _list.Count)
			{
				throw new ArgumentException("The number of elements in this collection is greater than the available space of the destination array.");
			}
			if (!array.GetType().GetElementType().IsAssignableFrom(typeof(Cookie)))
			{
				throw new InvalidCastException("The elements in this collection cannot be cast automatically to the type of the destination array.");
			}
			((ICollection)_list).CopyTo(array, index);
		}

		public void CopyTo(Cookie[] array, int index)
		{
			if (array == null)
			{
				throw new ArgumentNullException("array");
			}
			if (index < 0)
			{
				throw new ArgumentOutOfRangeException("index", "Less than zero.");
			}
			if (array.Length - index < _list.Count)
			{
				throw new ArgumentException("The number of elements in this collection is greater than the available space of the destination array.");
			}
			_list.CopyTo(array, index);
		}

		public IEnumerator GetEnumerator()
		{
			return _list.GetEnumerator();
		}
	}
	[Serializable]
	public class CookieException : FormatException, ISerializable
	{
		internal CookieException(string message)
			: base(message)
		{
		}

		internal CookieException(string message, Exception innerException)
			: base(message, innerException)
		{
		}

		protected CookieException(SerializationInfo serializationInfo, StreamingContext streamingContext)
			: base(serializationInfo, streamingContext)
		{
		}

		public CookieException()
		{
		}

		public override void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
		{
			base.GetObjectData(serializationInfo, streamingContext);
		}

		void ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
		{
			base.GetObjectData(serializationInfo, streamingContext);
		}
	}
	internal sealed class EndPointListener
	{
		private static readonly string _defaultCertFolderPath = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);

		private List<ListenerPrefix> _all;

		private X509Certificate2 _cert;

		private IPEndPoint _endpoint;

		private Dictionary<ListenerPrefix, HttpListener> _prefixes;

		private bool _secure;

		private Socket _socket;

		private List<ListenerPrefix> _unhandled;

		private Dictionary<HttpConnection, HttpConnection> _unregistered;

		public X509Certificate2 Certificate => _cert;

		public bool IsSecure => _secure;

		public EndPointListener(IPAddress address, int port, bool secure, string certFolderPath, X509Certificate2 defaultCert)
		{
			if (secure)
			{
				_secure = secure;
				_cert = getCertificate(port, certFolderPath, defaultCert);
				if (_cert == null)
				{
					throw new ArgumentException("No server certificate found.");
				}
			}
			_endpoint = new IPEndPoint(address, port);
			_prefixes = new Dictionary<ListenerPrefix, HttpListener>();
			_unregistered = new Dictionary<HttpConnection, HttpConnection>();
			_socket = new Socket(address.AddressFamily, SocketType.Stream, ProtocolType.Tcp);
			_socket.Bind(_endpoint);
			_socket.Listen(500);
			SocketAsyncEventArgs socketAsyncEventArgs = new SocketAsyncEventArgs();
			socketAsyncEventArgs.UserToken = this;
			socketAsyncEventArgs.Completed += onAccept;
			_socket.AcceptAsync(socketAsyncEventArgs);
		}

		private static void addSpecial(List<ListenerPrefix> prefixes, ListenerPrefix prefix)
		{
			if (prefixes == null)
			{
				return;
			}
			string path = prefix.Path;
			foreach (ListenerPrefix prefix2 in prefixes)
			{
				if (prefix2.Path == path)
				{
					throw new HttpListenerException(400, "Prefix already in use.");
				}
			}
			prefixes.Add(prefix);
		}

		private void checkIfRemove()
		{
			if (_prefixes.Count <= 0 && (_unhandled == null || _unhandled.Count <= 0) && (_all == null || _all.Count <= 0))
			{
				EndPointManager.RemoveEndPoint(this, _endpoint);
			}
		}

		private static RSACryptoServiceProvider createRSAFromFile(string filename)
		{
			byte[] array = null;
			using (FileStream fileStream = File.Open(filename, FileMode.Open, FileAccess.Read, FileShare.Read))
			{
				array = new byte[fileStream.Length];
				fileStream.Read(array, 0, array.Length);
			}
			RSACryptoServiceProvider rSACryptoServiceProvider = new RSACryptoServiceProvider();
			rSACryptoServiceProvider.ImportCspBlob(array);
			return rSACryptoServiceProvider;
		}

		private static X509Certificate2 getCertificate(int port, string certFolderPath, X509Certificate2 defaultCert)
		{
			if (certFolderPath == null || certFolderPath.Length == 0)
			{
				certFolderPath = _defaultCertFolderPath;
			}
			try
			{
				string text = Path.Combine(certFolderPath, $"{port}.cer");
				string text2 = Path.Combine(certFolderPath, $"{port}.key");
				if (File.Exists(text) && File.Exists(text2))
				{
					return new X509Certificate2(text)
					{
						PrivateKey = createRSAFromFile(text2)
					};
				}
			}
			catch
			{
			}
			return defaultCert;
		}

		private static HttpListener matchFromList(string host, string path, List<ListenerPrefix> list, out ListenerPrefix prefix)
		{
			prefix = null;
			if (list == null)
			{
				return null;
			}
			HttpListener result = null;
			int num = -1;
			foreach (ListenerPrefix item in list)
			{
				string path2 = item.Path;
				if (path2.Length >= num && path.StartsWith(path2))
				{
					num = path2.Length;
					result = item.Listener;
					prefix = item;
				}
			}
			return result;
		}

		private static void onAccept(object sender, EventArgs e)
		{
			SocketAsyncEventArgs socketAsyncEventArgs = (SocketAsyncEventArgs)e;
			EndPointListener endPointListener = (EndPointListener)socketAsyncEventArgs.UserToken;
			Socket socket = null;
			if (socketAsyncEventArgs.SocketError == SocketError.Success)
			{
				socket = socketAsyncEventArgs.AcceptSocket;
				socketAsyncEventArgs.AcceptSocket = null;
			}
			try
			{
				endPointListener._socket.AcceptAsync(socketAsyncEventArgs);
			}
			catch
			{
				socket?.Close();
				return;
			}
			if (socket == null)
			{
				return;
			}
			HttpConnection httpConnection = null;
			try
			{
				httpConnection = new HttpConnection(socket, endPointListener);
				lock (((ICollection)endPointListener._unregistered).SyncRoot)
				{
					endPointListener._unregistered[httpConnection] = httpConnection;
				}
				httpConnection.BeginReadRequest();
			}
			catch
			{
				if (httpConnection != null)
				{
					httpConnection.Close(force: true);
				}
				else
				{
					socket.Close();
				}
			}
		}

		private static bool removeSpecial(List<ListenerPrefix> prefixes, ListenerPrefix prefix)
		{
			if (prefixes == null)
			{
				return false;
			}
			string path = prefix.Path;
			int count = prefixes.Count;
			for (int i = 0; i < count; i++)
			{
				if (prefixes[i].Path == path)
				{
					prefixes.RemoveAt(i);
					return true;
				}
			}
			return false;
		}

		private HttpListener searchListener(Uri uri, out ListenerPrefix prefix)
		{
			prefix = null;
			if (uri == null)
			{
				return null;
			}
			string host = uri.Host;
			int port = uri.Port;
			string text = HttpUtility.UrlDecode(uri.AbsolutePath);
			string text2 = ((text[text.Length - 1] == '/') ? text : (text + "/"));
			HttpListener result = null;
			int num = -1;
			if (host != null && host.Length > 0)
			{
				foreach (ListenerPrefix key in _prefixes.Keys)
				{
					string path = key.Path;
					if (path.Length >= num && !(key.Host != host) && key.Port == port && (text.StartsWith(path) || text2.StartsWith(path)))
					{
						num = path.Length;
						result = _prefixes[key];
						prefix = key;
					}
				}
				if (num != -1)
				{
					return result;
				}
			}
			List<ListenerPrefix> unhandled = _unhandled;
			result = matchFromList(host, text, unhandled, out prefix);
			if (text != text2 && result == null)
			{
				result = matchFromList(host, text2, unhandled, out prefix);
			}
			if (result != null)
			{
				return result;
			}
			unhandled = _all;
			result = matchFromList(host, text, unhandled, out prefix);
			if (text != text2 && result == null)
			{
				result = matchFromList(host, text2, unhandled, out prefix);
			}
			if (result != null)
			{
				return result;
			}
			return null;
		}

		internal static bool CertificateExists(int port, string certFolderPath)
		{
			if (certFolderPath == null || certFolderPath.Length == 0)
			{
				certFolderPath = _defaultCertFolderPath;
			}
			string path = Path.Combine(certFolderPath, $"{port}.cer");
			string path2 = Path.Combine(certFolderPath, $"{port}.key");
			if (File.Exists(path))
			{
				return File.Exists(path2);
			}
			return false;
		}

		internal void RemoveConnection(HttpConnection connection)
		{
			lock (((ICollection)_unregistered).SyncRoot)
			{
				_unregistered.Remove(connection);
			}
		}

		public void AddPrefix(ListenerPrefix prefix, HttpListener listener)
		{
			if (prefix.Host == "*")
			{
				List<ListenerPrefix> unhandled;
				List<ListenerPrefix> list;
				do
				{
					unhandled = _unhandled;
					list = ((unhandled != null) ? new List<ListenerPrefix>(unhandled) : new List<ListenerPrefix>());
					prefix.Listener = listener;
					addSpecial(list, prefix);
				}
				while (Interlocked.CompareExchange(ref _unhandled, list, unhandled) != unhandled);
				return;
			}
			if (prefix.Host == "+")
			{
				List<ListenerPrefix> unhandled;
				List<ListenerPrefix> list;
				do
				{
					unhandled = _all;
					list = ((unhandled != null) ? new List<ListenerPrefix>(unhandled) : new List<ListenerPrefix>());
					prefix.Listener = listener;
					addSpecial(list, prefix);
				}
				while (Interlocked.CompareExchange(ref _all, list, unhandled) != unhandled);
				return;
			}
			Dictionary<ListenerPrefix, HttpListener> prefixes;
			Dictionary<ListenerPrefix, HttpListener> dictionary;
			do
			{
				prefixes = _prefixes;
				if (prefixes.ContainsKey(prefix))
				{
					if (prefixes[prefix] != listener)
					{
						throw new HttpListenerException(400, "There's another listener for " + prefix);
					}
					break;
				}
				dictionary = new Dictionary<ListenerPrefix, HttpListener>(prefixes);
				dictionary[prefix] = listener;
			}
			while (Interlocked.CompareExchange(ref _prefixes, dictionary, prefixes) != prefixes);
		}

		public bool BindContext(HttpListenerContext context)
		{
			ListenerPrefix prefix;
			HttpListener httpListener = searchListener(context.Request.Url, out prefix);
			if (httpListener == null)
			{
				return false;
			}
			context.Listener = httpListener;
			context.Connection.Prefix = prefix;
			return true;
		}

		public void Close()
		{
			_socket.Close();
			lock (((ICollection)_unregistered).SyncRoot)
			{
				List<HttpConnection> list = new List<HttpConnection>(_unregistered.Keys);
				_unregistered.Clear();
				foreach (HttpConnection item in list)
				{
					item.Close(force: true);
				}
				list.Clear();
			}
		}

		public void RemovePrefix(ListenerPrefix prefix, HttpListener listener)
		{
			if (prefix.Host == "*")
			{
				List<ListenerPrefix> unhandled;
				List<ListenerPrefix> list;
				do
				{
					unhandled = _unhandled;
					list = ((unhandled != null) ? new List<ListenerPrefix>(unhandled) : new List<ListenerPrefix>());
				}
				while (removeSpecial(list, prefix) && Interlocked.CompareExchange(ref _unhandled, list, unhandled) != unhandled);
				checkIfRemove();
				return;
			}
			if (prefix.Host == "+")
			{
				List<ListenerPrefix> unhandled;
				List<ListenerPrefix> list;
				do
				{
					unhandled = _all;
					list = ((unhandled != null) ? new List<ListenerPrefix>(unhandled) : new List<ListenerPrefix>());
				}
				while (removeSpecial(list, prefix) && Interlocked.CompareExchange(ref _all, list, unhandled) != unhandled);
				checkIfRemove();
				return;
			}
			Dictionary<ListenerPrefix, HttpListener> prefixes;
			Dictionary<ListenerPrefix, HttpListener> dictionary;
			do
			{
				prefixes = _prefixes;
				if (!prefixes.ContainsKey(prefix))
				{
					break;
				}
				dictionary = new Dictionary<ListenerPrefix, HttpListener>(prefixes);
				dictionary.Remove(prefix);
			}
			while (Interlocked.CompareExchange(ref _prefixes, dictionary, prefixes) != prefixes);
			checkIfRemove();
		}

		public void UnbindContext(HttpListenerContext context)
		{
			if (context != null && context.Listener != null)
			{
				context.Listener.UnregisterContext(context);
			}
		}
	}
	internal sealed class EndPointManager
	{
		private static Dictionary<IPAddress, Dictionary<int, EndPointListener>> _ipToEndpoints = new Dictionary<IPAddress, Dictionary<int, EndPointListener>>();

		private EndPointManager()
		{
		}

		private static void addPrefix(string uriPrefix, HttpListener httpListener)
		{
			ListenerPrefix listenerPrefix = new ListenerPrefix(uriPrefix);
			if (listenerPrefix.Path.IndexOf('%') != -1)
			{
				throw new HttpListenerException(400, "Invalid path.");
			}
			if (listenerPrefix.Path.IndexOf("//", StringComparison.Ordinal) != -1)
			{
				throw new HttpListenerException(400, "Invalid path.");
			}
			getEndPointListener(IPAddress.Any, listenerPrefix.Port, httpListener, listenerPrefix.Secure).AddPrefix(listenerPrefix, httpListener);
		}

		private static EndPointListener getEndPointListener(IPAddress address, int port, HttpListener httpListener, bool secure)
		{
			Dictionary<int, EndPointListener> dictionary = null;
			if (_ipToEndpoints.ContainsKey(address))
			{
				dictionary = _ipToEndpoints[address];
			}
			else
			{
				dictionary = new Dictionary<int, EndPointListener>();
				_ipToEndpoints[address] = dictionary;
			}
			EndPointListener endPointListener = null;
			return dictionary.ContainsKey(port) ? dictionary[port] : (dictionary[port] = new EndPointListener(address, port, secure, httpListener.CertificateFolderPath, httpListener.DefaultCertificate));
		}

		private static void removePrefix(string uriPrefix, HttpListener httpListener)
		{
			ListenerPrefix listenerPrefix = new ListenerPrefix(uriPrefix);
			if (listenerPrefix.Path.IndexOf('%') == -1 && listenerPrefix.Path.IndexOf("//", StringComparison.Ordinal) == -1)
			{
				getEndPointListener(IPAddress.Any, listenerPrefix.Port, httpListener, listenerPrefix.Secure).RemovePrefix(listenerPrefix, httpListener);
			}
		}

		public static void AddListener(HttpListener httpListener)
		{
			List<string> list = new List<string>();
			lock (((ICollection)_ipToEndpoints).SyncRoot)
			{
				try
				{
					foreach (string prefix in httpListener.Prefixes)
					{
						addPrefix(prefix, httpListener);
						list.Add(prefix);
					}
				}
				catch
				{
					foreach (string item in list)
					{
						removePrefix(item, httpListener);
					}
					throw;
				}
			}
		}

		public static void AddPrefix(string uriPrefix, HttpListener httpListener)
		{
			lock (((ICollection)_ipToEndpoints).SyncRoot)
			{
				addPrefix(uriPrefix, httpListener);
			}
		}

		public static void RemoveEndPoint(EndPointListener epListener, IPEndPoint endpoint)
		{
			lock (((ICollection)_ipToEndpoints).SyncRoot)
			{
				Dictionary<int, EndPointListener> dictionary = _ipToEndpoints[endpoint.Address];
				dictionary.Remove(endpoint.Port);
				if (dictionary.Count == 0)
				{
					_ipToEndpoints.Remove(endpoint.Address);
				}
				epListener.Close();
			}
		}

		public static void RemoveListener(HttpListener httpListener)
		{
			lock (((ICollection)_ipToEndpoints).SyncRoot)
			{
				foreach (string prefix in httpListener.Prefixes)
				{
					removePrefix(prefix, httpListener);
				}
			}
		}

		public static void RemovePrefix(string uriPrefix, HttpListener httpListener)
		{
			lock (((ICollection)_ipToEndpoints).SyncRoot)
			{
				removePrefix(uriPrefix, httpListener);
			}
		}
	}
	public class HttpBasicIdentity : GenericIdentity
	{
		private string _password;

		public virtual string Password => _password;

		internal HttpBasicIdentity(string username, string password)
			: base(username, "Basic")
		{
			_password = password;
		}
	}
	internal sealed class HttpConnection
	{
		private const int _bufferSize = 8192;

		private byte[] _buffer;

		private bool _chunked;

		private HttpListenerContext _context;

		private bool _contextWasBound;

		private StringBuilder _currentLine;

		private InputState _inputState;

		private RequestStream _inputStream;

		private HttpListener _lastListener;

		private LineState _lineState;

		private EndPointListener _listener;

		private ResponseStream _outputStream;

		private int _position;

		private ListenerPrefix _prefix;

		private MemoryStream _requestBuffer;

		private int _reuses;

		private bool _secure;

		private Socket _socket;

		private Stream _stream;

		private object _sync;

		private int _timeout;

		private System.Threading.Timer _timer;

		private WebSocketStream _websocketStream;

		public bool IsClosed => _socket == null;

		public bool IsSecure => _secure;

		public IPEndPoint LocalEndPoint => (IPEndPoint)_socket.LocalEndPoint;

		public ListenerPrefix Prefix
		{
			get
			{
				return _prefix;
			}
			set
			{
				_prefix = value;
			}
		}

		public IPEndPoint RemoteEndPoint => (IPEndPoint)_socket.RemoteEndPoint;

		public int Reuses => _reuses;

		public Stream Stream => _stream;

		public HttpConnection(Socket socket, EndPointListener listener)
		{
			_socket = socket;
			_listener = listener;
			_secure = listener.IsSecure;
			NetworkStream networkStream = new NetworkStream(socket, ownsSocket: false);
			if (_secure)
			{
				WebSocketSharp.Net.Security.SslStream sslStream = new WebSocketSharp.Net.Security.SslStream(networkStream, leaveInnerStreamOpen: false);
				sslStream.AuthenticateAsServer(listener.Certificate);
				_stream = sslStream;
			}
			else
			{
				_stream = networkStream;
			}
			_sync = new object();
			_timeout = 90000;
			_timer = new System.Threading.Timer(onTimeout, this, -1, -1);
			init();
		}

		private void close()
		{
			lock (_sync)
			{
				if (_socket == null)
				{
					return;
				}
				disposeTimer();
				disposeRequestBuffer();
				disposeStream();
				closeSocket();
			}
			unbind();
			removeConnection();
		}

		private void closeSocket()
		{
			try
			{
				_socket.Shutdown(SocketShutdown.Both);
			}
			catch
			{
			}
			_socket.Close();
			_socket = null;
		}

		private void disposeRequestBuffer()
		{
			if (_requestBuffer != null)
			{
				_requestBuffer.Dispose();
				_requestBuffer = null;
			}
		}

		private void disposeStream()
		{
			if (_stream != null)
			{
				_inputStream = null;
				_outputStream = null;
				_websocketStream = null;
				_stream.Dispose();
				_stream = null;
			}
		}

		private void disposeTimer()
		{
			if (_timer != null)
			{
				try
				{
					_timer.Change(-1, -1);
				}
				catch
				{
				}
				_timer.Dispose();
				_timer = null;
			}
		}

		private void init()
		{
			_chunked = false;
			_context = new HttpListenerContext(this);
			_inputState = InputState.RequestLine;
			_inputStream = null;
			_lineState = LineState.None;
			_outputStream = null;
			_position = 0;
			_prefix = null;
			_requestBuffer = new MemoryStream();
		}

		private static void onRead(IAsyncResult asyncResult)
		{
			HttpConnection httpConnection = (HttpConnection)asyncResult.AsyncState;
			if (httpConnection._socket == null)
			{
				return;
			}
			lock (httpConnection._sync)
			{
				if (httpConnection._socket == null)
				{
					return;
				}
				int num = -1;
				try
				{
					httpConnection._timer.Change(-1, -1);
					num = httpConnection._stream.EndRead(asyncResult);
					httpConnection._requestBuffer.Write(httpConnection._buffer, 0, num);
					if (httpConnection._requestBuffer.Length > 32768)
					{
						httpConnection.SendError("Bad request", 400);
						httpConnection.Close(force: true);
						return;
					}
				}
				catch
				{
					if (httpConnection._requestBuffer != null && httpConnection._requestBuffer.Length > 0)
					{
						httpConnection.SendError();
					}
					httpConnection.close();
					return;
				}
				if (num <= 0)
				{
					httpConnection.close();
				}
				else if (httpConnection.processInput(httpConnection._requestBuffer.GetBuffer()))
				{
					if (!httpConnection._context.HasError)
					{
						httpConnection._context.Request.FinishInitialization();
					}
					if (httpConnection._context.HasError)
					{
						httpConnection.SendError();
						httpConnection.Close(force: true);
						return;
					}
					if (!httpConnection._listener.BindContext(httpConnection._context))
					{
						httpConnection.SendError("Invalid host", 400);
						httpConnection.Close(force: true);
						return;
					}
					HttpListener listener = httpConnection._context.Listener;
					if (httpConnection._lastListener != listener)
					{
						httpConnection.removeConnection();
						listener.AddConnection(httpConnection);
						httpConnection._lastListener = listener;
					}
					httpConnection._contextWasBound = true;
					listener.RegisterContext(httpConnection._context);
				}
				else
				{
					httpConnection._stream.BeginRead(httpConnection._buffer, 0, 8192, onRead, httpConnection);
				}
			}
		}

		private static void onTimeout(object state)
		{
			((HttpConnection)state).close();
		}

		private bool processInput(byte[] data)
		{
			int num = data.Length;
			int used = 0;
			try
			{
				string text;
				while ((text = readLine(data, _position, num - _position, ref used)) != null)
				{
					_position += used;
					if (text.Length == 0)
					{
						if (_inputState != 0)
						{
							_currentLine = null;
							return true;
						}
						continue;
					}
					if (_inputState == InputState.RequestLine)
					{
						_context.Request.SetRequestLine(text);
						_inputState = InputState.Headers;
					}
					else
					{
						_context.Request.AddHeader(text);
					}
					if (_context.HasError)
					{
						return true;
					}
				}
			}
			catch (Exception ex)
			{
				_context.ErrorMessage = ex.Message;
				return true;
			}
			_position += used;
			if (used == num)
			{
				_requestBuffer.SetLength(0L);
				_position = 0;
			}
			return false;
		}

		private string readLine(byte[] buffer, int offset, int length, ref int used)
		{
			if (_currentLine == null)
			{
				_currentLine = new StringBuilder();
			}
			int num = offset + length;
			used = 0;
			for (int i = offset; i < num; i++)
			{
				if (_lineState == LineState.LF)
				{
					break;
				}
				used++;
				byte b = buffer[i];
				switch (b)
				{
				case 13:
					_lineState = LineState.CR;
					break;
				case 10:
					_lineState = LineState.LF;
					break;
				default:
					_currentLine.Append((char)b);
					break;
				}
			}
			string result = null;
			if (_lineState == LineState.LF)
			{
				_lineState = LineState.None;
				result = _currentLine.ToString();
				_currentLine.Length = 0;
			}
			return result;
		}

		private void removeConnection()
		{
			if (_lastListener == null)
			{
				_listener.RemoveConnection(this);
			}
			else
			{
				_lastListener.RemoveConnection(this);
			}
		}

		private void unbind()
		{
			if (_contextWasBound)
			{
				_listener.UnbindContext(_context);
				_contextWasBound = false;
			}
		}

		internal void Close(bool force)
		{
			if (_socket == null)
			{
				return;
			}
			lock (_sync)
			{
				if (_socket == null)
				{
					return;
				}
				if (!force)
				{
					GetResponseStream().Close();
					HttpListenerRequest request = _context.Request;
					HttpListenerResponse response = _context.Response;
					if (request.KeepAlive && !response.CloseConnection && request.FlushInput() && (!_chunked || (_chunked && !response.ForceCloseChunked)))
					{
						_reuses++;
						disposeRequestBuffer();
						unbind();
						init();
						BeginReadRequest();
						return;
					}
				}
				close();
			}
		}

		public void BeginReadRequest()
		{
			if (_buffer == null)
			{
				_buffer = new byte[8192];
			}
			if (_reuses == 1)
			{
				_timeout = 15000;
			}
			try
			{
				_timer.Change(_timeout, -1);
				_stream.BeginRead(_buffer, 0, 8192, onRead, this);
			}
			catch
			{
				close();
			}
		}

		public void Close()
		{
			Close(force: false);
		}

		public RequestStream GetRequestStream(bool chunked, long contentlength)
		{
			if (_inputStream != null || _socket == null)
			{
				return _inputStream;
			}
			lock (_sync)
			{
				if (_socket == null)
				{
					return _inputStream;
				}
				byte[] buffer = _requestBuffer.GetBuffer();
				int num = buffer.Length;
				disposeRequestBuffer();
				if (chunked)
				{
					_chunked = true;
					_context.Response.SendChunked = true;
					_inputStream = new ChunkedRequestStream(_context, _stream, buffer, _position, num - _position);
				}
				else
				{
					_inputStream = new RequestStream(_stream, buffer, _position, num - _position, contentlength);
				}
				return _inputStream;
			}
		}

		public ResponseStream GetResponseStream()
		{
			if (_outputStream != null || _socket == null)
			{
				return _outputStream;
			}
			lock (_sync)
			{
				if (_socket == null)
				{
					return _outputStream;
				}
				bool ignoreErrors = _context.Listener?.IgnoreWriteExceptions ?? true;
				_outputStream = new ResponseStream(_stream, _context.Response, ignoreErrors);
				return _outputStream;
			}
		}

		public WebSocketStream GetWebSocketStream()
		{
			if (_websocketStream != null || _socket == null)
			{
				return _websocketStream;
			}
			lock (_sync)
			{
				if (_socket == null)
				{
					return _websocketStream;
				}
				_websocketStream = new WebSocketStream(_stream, _secure);
				return _websocketStream;
			}
		}

		public void SendError()
		{
			SendError(_context.ErrorMessage, _context.ErrorStatus);
		}

		public void SendError(string message, int status)
		{
			if (_socket == null)
			{
				return;
			}
			lock (_sync)
			{
				if (_socket == null)
				{
					return;
				}
				try
				{
					HttpListenerResponse response = _context.Response;
					response.StatusCode = status;
					response.ContentType = "text/html";
					string statusDescription = status.GetStatusDescription();
					string s = ((message != null && message.Length > 0) ? $"<h1>{statusDescription} ({message})</h1>" : $"<h1>{statusDescription}</h1>");
					byte[] bytes = response.ContentEncoding.GetBytes(s);
					response.Close(bytes, willBlock: false);
				}
				catch
				{
				}
			}
		}
	}
	public class HttpDigestIdentity : GenericIdentity
	{
		private NameValueCollection _parameters;

		public string Algorithm => _parameters["algorithm"];

		public string Cnonce => _parameters["cnonce"];

		public string Nc => _parameters["nc"];

		public string Nonce => _parameters["nonce"];

		public string Opaque => _parameters["opaque"];

		public string Qop => _parameters["qop"];

		public string Realm => _parameters["realm"];

		public string Response => _parameters["response"];

		public string Uri => _parameters["uri"];

		internal HttpDigestIdentity(NameValueCollection parameters)
			: base(parameters["username"], "Digest")
		{
			_parameters = parameters;
		}

		internal bool IsValid(string password, string realm, string method, string entity)
		{
			NameValueCollection nameValueCollection = new NameValueCollection(_parameters);
			nameValueCollection["password"] = password;
			nameValueCollection["realm"] = realm;
			nameValueCollection["method"] = method;
			nameValueCollection["entity"] = entity;
			return _parameters["response"] == AuthenticationResponse.CreateRequestDigest(nameValueCollection);
		}
	}
	internal class HttpHeaderInfo
	{
		private HttpHeaderType _type;

		internal bool IsMultiValueInRequest => (_type & HttpHeaderType.MultiValueInRequest) == HttpHeaderType.MultiValueInRequest;

		internal bool IsMultiValueInResponse => (_type & HttpHeaderType.MultiValueInResponse) == HttpHeaderType.MultiValueInResponse;

		public bool IsRequest => (_type & HttpHeaderType.Request) == HttpHeaderType.Request;

		public bool IsResponse => (_type & HttpHeaderType.Response) == HttpHeaderType.Response;

		public string Name { get; set; }

		public HttpHeaderType Type
		{
			get
			{
				return _type;
			}
			set
			{
				_type = value;
			}
		}

		public bool IsMultiValue(bool response)
		{
			if ((_type & HttpHeaderType.MultiValue) == HttpHeaderType.MultiValue)
			{
				if (!response)
				{
					return IsRequest;
				}
				return IsResponse;
			}
			if (!response)
			{
				return IsMultiValueInRequest;
			}
			return IsMultiValueInResponse;
		}

		public bool IsRestricted(bool response)
		{
			if ((_type & HttpHeaderType.Restricted) == HttpHeaderType.Restricted)
			{
				if (!response)
				{
					return IsRequest;
				}
				return IsResponse;
			}
			return false;
		}
	}
	[Flags]
	internal enum HttpHeaderType
	{
		Unspecified = 0,
		Request = 1,
		Response = 2,
		Restricted = 4,
		MultiValue = 8,
		MultiValueInRequest = 0x10,
		MultiValueInResponse = 0x20
	}
	public sealed class HttpListener : IDisposable
	{
		private AuthenticationSchemes _authSchemes;

		private Func<HttpListenerRequest, AuthenticationSchemes> _authSchemeSelector;

		private string _certFolderPath;

		private Dictionary<HttpConnection, HttpConnection> _connections;

		private List<HttpListenerContext> _contextQueue;

		private Func<IIdentity, NetworkCredential> _credentialsFinder;

		private X509Certificate2 _defaultCert;

		private bool _disposed;

		private bool _ignoreWriteExceptions;

		private bool _listening;

		private HttpListenerPrefixCollection _prefixes;

		private string _realm;

		private Dictionary<HttpListenerContext, HttpListenerContext> _registry;

		private List<ListenerAsyncResult> _waitQueue;

		internal bool IsDisposed => _disposed;

		public AuthenticationSchemes AuthenticationSchemes
		{
			get
			{
				CheckDisposed();
				return _authSchemes;
			}
			set
			{
				CheckDisposed();
				_authSchemes = value;
			}
		}

		public Func<HttpListenerRequest, AuthenticationSchemes> AuthenticationSchemeSelector
		{
			get
			{
				CheckDisposed();
				return _authSchemeSelector;
			}
			set
			{
				CheckDisposed();
				_authSchemeSelector = value;
			}
		}

		public string CertificateFolderPath
		{
			get
			{
				CheckDisposed();
				return _certFolderPath;
			}
			set
			{
				CheckDisposed();
				_certFolderPath = value;
			}
		}

		public X509Certificate2 DefaultCertificate
		{
			get
			{
				CheckDisposed();
				return _defaultCert;
			}
			set
			{
				CheckDisposed();
				_defaultCert = value;
			}
		}

		public bool IgnoreWriteExceptions
		{
			get
			{
				CheckDisposed();
				return _ignoreWriteExceptions;
			}
			set
			{
				CheckDisposed();
				_ignoreWriteExceptions = value;
			}
		}

		public bool IsListening => _listening;

		public static bool IsSupported => true;

		public HttpListenerPrefixCollection Prefixes
		{
			get
			{
				CheckDisposed();
				return _prefixes;
			}
		}

		public string Realm
		{
			get
			{
				CheckDisposed();
				if (_realm != null && _realm.Length != 0)
				{
					return _realm;
				}
				return _realm = "SECRET AREA";
			}
			set
			{
				CheckDisposed();
				_realm = value;
			}
		}

		public bool UnsafeConnectionNtlmAuthentication
		{
			get
			{
				throw new NotSupportedException();
			}
			set
			{
				throw new NotSupportedException();
			}
		}

		public Func<IIdentity, NetworkCredential> UserCredentialsFinder
		{
			get
			{
				CheckDisposed();
				return (IIdentity identity) => (NetworkCredential)null;
			}
			set
			{
				CheckDisposed();
				_credentialsFinder = value;
			}
		}

		public HttpListener()
		{
			_authSchemes = AuthenticationSchemes.Anonymous;
			_connections = new Dictionary<HttpConnection, HttpConnection>();
			_contextQueue = new List<HttpListenerContext>();
			_prefixes = new HttpListenerPrefixCollection(this);
			_registry = new Dictionary<HttpListenerContext, HttpListenerContext>();
			_waitQueue = new List<ListenerAsyncResult>();
		}

		private void cleanup(bool force)
		{
			lock (((ICollection)_registry).SyncRoot)
			{
				if (!force)
				{
					sendServiceUnavailable();
				}
				cleanupContextRegistry();
				cleanupConnections();
				cleanupWaitQueue();
			}
		}

		private void cleanupConnections()
		{
			lock (((ICollection)_connections).SyncRoot)
			{
				if (_connections.Count != 0)
				{
					Dictionary<HttpConnection, HttpConnection>.KeyCollection keys = _connections.Keys;
					HttpConnection[] array = new HttpConnection[keys.Count];
					keys.CopyTo(array, 0);
					_connections.Clear();
					for (int num = array.Length - 1; num >= 0; num--)
					{
						array[num].Close(force: true);
					}
				}
			}
		}

		private void cleanupContextRegistry()
		{
			lock (((ICollection)_registry).SyncRoot)
			{
				if (_registry.Count != 0)
				{
					Dictionary<HttpListenerContext, HttpListenerContext>.KeyCollection keys = _registry.Keys;
					HttpListenerContext[] array = new HttpListenerContext[keys.Count];
					keys.CopyTo(array, 0);
					_registry.Clear();
					for (int num = array.Length - 1; num >= 0; num--)
					{
						array[num].Connection.Close(force: true);
					}
				}
			}
		}

		private void cleanupWaitQueue()
		{
			lock (((ICollection)_waitQueue).SyncRoot)
			{
				if (_waitQueue.Count == 0)
				{
					return;
				}
				ObjectDisposedException exception = new ObjectDisposedException(GetType().ToString());
				foreach (ListenerAsyncResult item in _waitQueue)
				{
					item.Complete(exception);
				}
				_waitQueue.Clear();
			}
		}

		private void close(bool force)
		{
			EndPointManager.RemoveListener(this);
			cleanup(force);
		}

		private HttpListenerContext getContextFromQueue()
		{
			if (_contextQueue.Count == 0)
			{
				return null;
			}
			HttpListenerContext result = _contextQueue[0];
			_contextQueue.RemoveAt(0);
			return result;
		}

		private void sendServiceUnavailable()
		{
			lock (((ICollection)_contextQueue).SyncRoot)
			{
				if (_contextQueue.Count != 0)
				{
					HttpListenerContext[] array = _contextQueue.ToArray();
					_contextQueue.Clear();
					HttpListenerContext[] array2 = array;
					for (int i = 0; i < array2.Length; i++)
					{
						HttpListenerResponse response = array2[i].Response;
						response.StatusCode = 503;
						response.Close();
					}
				}
			}
		}

		internal void AddConnection(HttpConnection connection)
		{
			lock (((ICollection)_connections).SyncRoot)
			{
				_connections[connection] = connection;
			}
		}

		internal ListenerAsyncResult BeginGetContext(ListenerAsyncResult asyncResult)
		{
			CheckDisposed();
			if (_prefixes.Count == 0)
			{
				throw new InvalidOperationException("Please, call AddPrefix before using this method.");
			}
			if (!_listening)
			{
				throw new InvalidOperationException("Please, call Start before using this method.");
			}
			lock (((ICollection)_waitQueue).SyncRoot)
			{
				lock (((ICollection)_contextQueue).SyncRoot)
				{
					HttpListenerContext contextFromQueue = getContextFromQueue();
					if (contextFromQueue != null)
					{
						asyncResult.Complete(contextFromQueue, syncCompleted: true);
						return asyncResult;
					}
				}
				_waitQueue.Add(asyncResult);
				return asyncResult;
			}
		}

		internal void CheckDisposed()
		{
			if (_disposed)
			{
				throw new ObjectDisposedException(GetType().ToString());
			}
		}

		internal void RegisterContext(HttpListenerContext context)
		{
			lock (((ICollection)_registry).SyncRoot)
			{
				_registry[context] = context;
			}
			ListenerAsyncResult listenerAsyncResult = null;
			lock (((ICollection)_waitQueue).SyncRoot)
			{
				if (_waitQueue.Count == 0)
				{
					lock (((ICollection)_contextQueue).SyncRoot)
					{
						_contextQueue.Add(context);
					}
				}
				else
				{
					listenerAsyncResult = _waitQueue[0];
					_waitQueue.RemoveAt(0);
				}
			}
			listenerAsyncResult?.Complete(context);
		}

		internal void RemoveConnection(HttpConnection connection)
		{
			lock (((ICollection)_connections).SyncRoot)
			{
				_connections.Remove(connection);
			}
		}

		internal AuthenticationSchemes SelectAuthenticationScheme(HttpListenerContext context)
		{
			if (AuthenticationSchemeSelector == null)
			{
				return _authSchemes;
			}
			return AuthenticationSchemeSelector(context.Request);
		}

		internal void UnregisterContext(HttpListenerContext context)
		{
			lock (((ICollection)_registry).SyncRoot)
			{
				_registry.Remove(context);
			}
			lock (((ICollection)_contextQueue).SyncRoot)
			{
				int num = _contextQueue.IndexOf(context);
				if (num >= 0)
				{
					_contextQueue.RemoveAt(num);
				}
			}
		}

		public void Abort()
		{
			if (!_disposed)
			{
				close(force: true);
				_disposed = true;
			}
		}

		public IAsyncResult BeginGetContext(AsyncCallback callback, object state)
		{
			return BeginGetContext(new ListenerAsyncResult(callback, state));
		}

		public void Close()
		{
			if (!_disposed)
			{
				close(force: false);
				_disposed = true;
			}
		}

		public HttpListenerContext EndGetContext(IAsyncResult asyncResult)
		{
			CheckDisposed();
			if (asyncResult == null)
			{
				throw new ArgumentNullException("asyncResult");
			}
			if (!(asyncResult is ListenerAsyncResult listenerAsyncResult))
			{
				throw new ArgumentException("Wrong IAsyncResult.", "asyncResult");
			}
			if (listenerAsyncResult.EndCalled)
			{
				throw new InvalidOperationException("Cannot reuse this IAsyncResult.");
			}
			listenerAsyncResult.EndCalled = true;
			if (!listenerAsyncResult.IsCompleted)
			{
				listenerAsyncResult.AsyncWaitHandle.WaitOne();
			}
			lock (((ICollection)_waitQueue).SyncRoot)
			{
				int num = _waitQueue.IndexOf(listenerAsyncResult);
				if (num >= 0)
				{
					_waitQueue.RemoveAt(num);
				}
			}
			HttpListenerContext context = listenerAsyncResult.GetContext();
			AuthenticationSchemes authenticationSchemes = SelectAuthenticationScheme(context);
			if (authenticationSchemes != AuthenticationSchemes.Anonymous)
			{
				context.SetUser(authenticationSchemes, Realm, UserCredentialsFinder);
			}
			return context;
		}

		public HttpListenerContext GetContext()
		{
			ListenerAsyncResult listenerAsyncResult = BeginGetContext(new ListenerAsyncResult(null, null));
			listenerAsyncResult.InGet = true;
			return EndGetContext(listenerAsyncResult);
		}

		public void Start()
		{
			CheckDisposed();
			if (!_listening)
			{
				EndPointManager.AddListener(this);
				_listening = true;
			}
		}

		public void Stop()
		{
			CheckDisposed();
			if (_listening)
			{
				_listening = false;
				EndPointManager.RemoveListener(this);
				sendServiceUnavailable();
			}
		}

		void IDisposable.Dispose()
		{
			if (!_disposed)
			{
				close(force: true);
				_disposed = true;
			}
		}
	}
	public sealed class HttpListenerContext
	{
		private HttpConnection _connection;

		private string _error;

		private int _errorStatus;

		private HttpListenerRequest _request;

		private HttpListenerResponse _response;

		private IPrincipal _user;

		internal HttpListener Listener;

		internal HttpConnection Connection => _connection;

		internal string ErrorMessage
		{
			get
			{
				return _error;
			}
			set
			{
				_error = value;
			}
		}

		internal int ErrorStatus
		{
			get
			{
				return _errorStatus;
			}
			set
			{
				_errorStatus = value;
			}
		}

		internal bool HasError => _error != null;

		public HttpListenerRequest Request => _request;

		public HttpListenerResponse Response => _response;

		public IPrincipal User => _user;

		internal HttpListenerContext(HttpConnection connection)
		{
			_connection = connection;
			_errorStatus = 400;
			_request = new HttpListenerRequest(this);
			_response = new HttpListenerResponse(this);
		}

		internal void SetUser(AuthenticationSchemes scheme, string realm, Func<IIdentity, NetworkCredential> credentialsFinder)
		{
			AuthenticationResponse authenticationResponse = AuthenticationResponse.Parse(_request.Headers["Authorization"]);
			if (authenticationResponse == null)
			{
				return;
			}
			IIdentity identity = authenticationResponse.ToIdentity();
			if (identity == null)
			{
				return;
			}
			NetworkCredential networkCredential = null;
			try
			{
				networkCredential = credentialsFinder(identity);
			}
			catch
			{
			}
			if (networkCredential != null)
			{
				bool num;
				switch (scheme)
				{
				case AuthenticationSchemes.Digest:
					num = ((HttpDigestIdentity)identity).IsValid(networkCredential.Password, realm, _request.HttpMethod, null);
					break;
				case AuthenticationSchemes.Basic:
					num = ((HttpBasicIdentity)identity).Password == networkCredential.Password;
					break;
				default:
					return;
				}
				if (num)
				{
					_user = new GenericPrincipal(identity, networkCredential.Roles);
				}
			}
		}

		public HttpListenerWebSocketContext AcceptWebSocket(string protocol, Logger logger)
		{
			if (protocol != null)
			{
				if (protocol.Length == 0)
				{
					throw new ArgumentException("An empty string.", "protocol");
				}
				if (!protocol.IsToken())
				{
					throw new ArgumentException("Contains an invalid character.", "protocol");
				}
			}
			return new HttpListenerWebSocketContext(this, protocol, logger ?? new Logger());
		}
	}
	[Serializable]
	public class HttpListenerException : Win32Exception
	{
		public override int ErrorCode => base.NativeErrorCode;

		protected HttpListenerException(SerializationInfo serializationInfo, StreamingContext streamingContext)
			: base(serializationInfo, streamingContext)
		{
		}

		public HttpListenerException()
		{
		}

		public HttpListenerException(int errorCode)
			: base(errorCode)
		{
		}

		public HttpListenerException(int errorCode, string message)
			: base(errorCode, message)
		{
		}
	}
	public class HttpListenerPrefixCollection : ICollection<string>, IEnumerable<string>, IEnumerable
	{
		private HttpListener _listener;

		private List<string> _prefixes;

		public int Count => _prefixes.Count;

		public bool IsReadOnly => false;

		public bool IsSynchronized => false;

		private HttpListenerPrefixCollection()
		{
			_prefixes = new List<string>();
		}

		internal HttpListenerPrefixCollection(HttpListener listener)
			: this()
		{
			_listener = listener;
		}

		public void Add(string uriPrefix)
		{
			_listener.CheckDisposed();
			ListenerPrefix.CheckUriPrefix(uriPrefix);
			if (!_prefixes.Contains(uriPrefix))
			{
				_prefixes.Add(uriPrefix);
				if (_listener.IsListening)
				{
					EndPointManager.AddPrefix(uriPrefix, _listener);
				}
			}
		}

		public void Clear()
		{
			_listener.CheckDisposed();
			_prefixes.Clear();
			if (_listener.IsListening)
			{
				EndPointManager.RemoveListener(_listener);
			}
		}

		public bool Contains(string uriPrefix)
		{
			_listener.CheckDisposed();
			if (uriPrefix == null)
			{
				throw new ArgumentNullException("uriPrefix");
			}
			return _prefixes.Contains(uriPrefix);
		}

		public void CopyTo(Array array, int offset)
		{
			_listener.CheckDisposed();
			((ICollection)_prefixes).CopyTo(array, offset);
		}

		public void CopyTo(string[] array, int offset)
		{
			_listener.CheckDisposed();
			_prefixes.CopyTo(array, offset);
		}

		public IEnumerator<string> GetEnumerator()
		{
			return _prefixes.GetEnumerator();
		}

		public bool Remove(string uriPrefix)
		{
			_listener.CheckDisposed();
			if (uriPrefix == null)
			{
				throw new ArgumentNullException("uriPrefix");
			}
			bool num = _prefixes.Remove(uriPrefix);
			if (num && _listener.IsListening)
			{
				EndPointManager.RemovePrefix(uriPrefix, _listener);
			}
			return num;
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return _prefixes.GetEnumerator();
		}
	}
	public sealed class HttpListenerRequest
	{
		private static byte[] _100continue = Encoding.ASCII.GetBytes("HTTP/1.1 100 Continue\r\n\r\n");

		private string[] _acceptTypes;

		private bool _chunked;

		private Encoding _contentEncoding;

		private long _contentLength;

		private bool _contentLengthWasSet;

		private HttpListenerContext _context;

		private CookieCollection _cookies;

		private WebHeaderCollection _headers;

		private Guid _identifier;

		private Stream _inputStream;

		private bool _keepAlive;

		private bool _keepAliveWasSet;

		private string _method;

		private NameValueCollection _queryString;

		private Uri _referer;

		private string _uri;

		private Uri _url;

		private string[] _userLanguages;

		private Version _version;

		private bool _websocketRequest;

		private bool _websocketRequestWasSet;

		public string[] AcceptTypes => _acceptTypes;

		public int ClientCertificateError => 0;

		public Encoding ContentEncoding => _contentEncoding ?? (_contentEncoding = Encoding.Default);

		public long ContentLength64 => _contentLength;

		public string ContentType => _headers["Content-Type"];

		public CookieCollection Cookies => _cookies ?? (_cookies = _headers.GetCookies(response: false));

		public bool HasEntityBody
		{
			get
			{
				if (_contentLength <= 0)
				{
					return _chunked;
				}
				return true;
			}
		}

		public NameValueCollection Headers => _headers;

		public string HttpMethod => _method;

		public Stream InputStream => _inputStream ?? (_inputStream = (HasEntityBody ? _context.Connection.GetRequestStream(_chunked, _contentLength) : Stream.Null));

		public bool IsAuthenticated => _context.User?.Identity.IsAuthenticated ?? false;

		public bool IsLocal => RemoteEndPoint.Address.IsLocal();

		public bool IsSecureConnection => _context.Connection.IsSecure;

		public bool IsWebSocketRequest
		{
			get
			{
				if (!_websocketRequestWasSet)
				{
					_websocketRequest = _method == "GET" && _version > HttpVersion.Version10 && _headers.Contains("Upgrade", "websocket") && _headers.Contains("Connection", "Upgrade");
					_websocketRequestWasSet = true;
				}
				return _websocketRequest;
			}
		}

		public bool KeepAlive
		{
			get
			{
				if (!_keepAliveWasSet)
				{
					string text;
					_keepAlive = _version > HttpVersion.Version10 || _headers.Contains("Connection", "keep-alive") || ((text = _headers["Keep-Alive"]) != null && text != "closed");
					_keepAliveWasSet = true;
				}
				return _keepAlive;
			}
		}

		public IPEndPoint LocalEndPoint => _context.Connection.LocalEndPoint;

		public Version ProtocolVersion => _version;

		public NameValueCollection QueryString => _queryString ?? (_queryString = HttpUtility.ParseQueryStringInternally(_url.Query, Encoding.UTF8));

		public string RawUrl => _url.PathAndQuery;

		public IPEndPoint RemoteEndPoint => _context.Connection.RemoteEndPoint;

		public Guid RequestTraceIdentifier => _identifier;

		public Uri Url => _url;

		public Uri UrlReferrer => _referer;

		public string UserAgent => _headers["User-Agent"];

		public string UserHostAddress => LocalEndPoint.ToString();

		public string UserHostName => _headers["Host"];

		public string[] UserLanguages => _userLanguages;

		internal HttpListenerRequest(HttpListenerContext context)
		{
			_context = context;
			_contentLength = -1L;
			_headers = new WebHeaderCollection();
			_identifier = Guid.NewGuid();
		}

		private static bool tryCreateVersion(string version, out Version result)
		{
			result = null;
			try
			{
				result = new Version(version);
				return true;
			}
			catch
			{
				return false;
			}
		}

		internal void AddHeader(string header)
		{
			int num = header.IndexOf(':');
			if (num == -1)
			{
				_context.ErrorMessage = "Invalid header";
				return;
			}
			string text = header.Substring(0, num).Trim();
			string text2 = header.Substring(num + 1).Trim();
			_headers.SetInternally(text, text2, response: false);
			switch (text.ToLower(CultureInfo.InvariantCulture))
			{
			case "accept":
				_acceptTypes = new List<string>(text2.SplitHeaderValue(',')).ToArray();
				break;
			case "accept-language":
				_userLanguages = text2.Split(',');
				break;
			case "content-length":
			{
				if (long.TryParse(text2, out var result) && result >= 0)
				{
					_contentLength = result;
					_contentLengthWasSet = true;
				}
				else
				{
					_context.ErrorMessage = "Invalid Content-Length header";
				}
				break;
			}
			case "content-type":
			{
				string[] array = text2.Split(';');
				for (int i = 0; i < array.Length; i++)
				{
					string text3 = array[i].Trim();
					if (text3.StartsWith("charset"))
					{
						string value = text3.GetValue("=");
						if (value != null && value.Length > 0)
						{
							try
							{
								_contentEncoding = Encoding.GetEncoding(value);
								break;
							}
							catch
							{
								_context.ErrorMessage = "Invalid Content-Type header";
								break;
							}
						}
						break;
					}
				}
				break;
			}
			case "referer":
				_referer = text2.ToUri();
				break;
			}
		}

		internal void FinishInitialization()
		{
			string text = _headers["Host"];
			bool flag = text == null || text.Length == 0;
			if (_version > HttpVersion.Version10 && flag)
			{
				_context.ErrorMessage = "Invalid Host header";
				return;
			}
			if (flag)
			{
				text = UserHostAddress;
			}
			_url = HttpUtility.CreateRequestUrl(_uri, text, IsWebSocketRequest, IsSecureConnection);
			if (_url == null)
			{
				_context.ErrorMessage = "Invalid request url";
				return;
			}
			string text2 = Headers["Transfer-Encoding"];
			if (_version > HttpVersion.Version10 && text2 != null && text2.Length > 0)
			{
				_chunked = text2.ToLower() == "chunked";
				if (!_chunked)
				{
					_context.ErrorMessage = string.Empty;
					_context.ErrorStatus = 501;
					return;
				}
			}
			if (!_chunked && !_contentLengthWasSet)
			{
				string text3 = _method.ToLower();
				if (text3 == "post" || text3 == "put")
				{
					_context.ErrorMessage = string.Empty;
					_context.ErrorStatus = 411;
					return;
				}
			}
			string text4 = Headers["Expect"];
			if (text4 != null && text4.Length > 0 && text4.ToLower() == "100-continue")
			{
				_context.Connection.GetResponseStream().WriteInternally(_100continue, 0, _100continue.Length);
			}
		}

		internal bool FlushInput()
		{
			if (!HasEntityBody)
			{
				return true;
			}
			int num = 2048;
			if (_contentLength > 0)
			{
				num = (int)Math.Min(_contentLength, num);
			}
			byte[] buffer = new byte[num];
			while (true)
			{
				try
				{
					IAsyncResult asyncResult = InputStream.BeginRead(buffer, 0, num, null, null);
					if (!asyncResult.IsCompleted && !asyncResult.AsyncWaitHandle.WaitOne(100))
					{
						return false;
					}
					if (InputStream.EndRead(asyncResult) <= 0)
					{
						return true;
					}
				}
				catch
				{
					return false;
				}
			}
		}

		internal void SetRequestLine(string requestLine)
		{
			string[] array = requestLine.Split(new char[1] { ' ' }, 3);
			if (array.Length != 3)
			{
				_context.ErrorMessage = "Invalid request line (parts)";
				return;
			}
			_method = array[0];
			if (!_method.IsToken())
			{
				_context.ErrorMessage = "Invalid request line (method)";
				return;
			}
			_uri = array[1];
			if (array[2].Length != 8 || !array[2].StartsWith("HTTP/") || !tryCreateVersion(array[2].Substring(5), out _version) || _version.Major < 1)
			{
				_context.ErrorMessage = "Invalid request line (version)";
			}
		}

		public IAsyncResult BeginGetClientCertificate(AsyncCallback requestCallback, object state)
		{
			throw new NotImplementedException();
		}

		public X509Certificate2 EndGetClientCertificate(IAsyncResult asyncResult)
		{
			throw new NotImplementedException();
		}

		public X509Certificate2 GetClientCertificate()
		{
			throw new NotImplementedException();
		}

		public override string ToString()
		{
			StringBuilder stringBuilder = new StringBuilder(64);
			stringBuilder.AppendFormat("{0} {1} HTTP/{2}\r\n", _method, _uri, _version);
			stringBuilder.Append(_headers.ToString());
			return stringBuilder.ToString();
		}
	}
	public sealed class HttpListenerResponse : IDisposable
	{
		private bool _chunked;

		private Encoding _contentEncoding;

		private long _contentLength;

		private bool _contentLengthSet;

		private string _contentType;

		private HttpListenerContext _context;

		private CookieCollection _cookies;

		private bool _disposed;

		private bool _forceCloseChunked;

		private WebHeaderCollection _headers;

		private bool _headersSent;

		private bool _keepAlive;

		private string _location;

		private ResponseStream _outputStream;

		private int _statusCode;

		private string _statusDescription;

		private Version _version;

		internal bool CloseConnection => _headers["Connection"] == "close";

		internal bool ForceCloseChunked => _forceCloseChunked;

		internal bool HeadersSent => _headersSent;

		public Encoding ContentEncoding
		{
			get
			{
				checkDisposed();
				return _contentEncoding;
			}
			set
			{
				checkDisposedOrHeadersSent();
				_contentEncoding = value;
			}
		}

		public long ContentLength64
		{
			get
			{
				checkDisposed();
				return _contentLength;
			}
			set
			{
				checkDisposedOrHeadersSent();
				if (value < 0)
				{
					throw new ArgumentOutOfRangeException("Less than zero.", "value");
				}
				_contentLengthSet = true;
				_contentLength = value;
			}
		}

		public string ContentType
		{
			get
			{
				checkDisposed();
				return _contentType;
			}
			set
			{
				checkDisposedOrHeadersSent();
				if (value == null)
				{
					throw new ArgumentNullException("value");
				}
				if (value.Length == 0)
				{
					throw new ArgumentException("An empty string.", "value");
				}
				_contentType = value;
			}
		}

		public CookieCollection Cookies
		{
			get
			{
				checkDisposed();
				return _cookies ?? (_cookies = new CookieCollection());
			}
			set
			{
				checkDisposedOrHeadersSent();
				_cookies = value;
			}
		}

		public WebHeaderCollection Headers
		{
			get
			{
				checkDisposed();
				return _headers;
			}
			set
			{
				checkDisposedOrHeadersSent();
				if (value == null)
				{
					throw new ArgumentNullException("value");
				}
				_headers = value;
			}
		}

		public bool KeepAlive
		{
			get
			{
				checkDisposed();
				return _keepAlive;
			}
			set
			{
				checkDisposedOrHeadersSent();
				_keepAlive = value;
			}
		}

		public Stream OutputStream
		{
			get
			{
				checkDisposed();
				return _outputStream ?? (_outputStream = _context.Connection.GetResponseStream());
			}
		}

		public Version ProtocolVersion
		{
			get
			{
				checkDisposed();
				return _version;
			}
			set
			{
				checkDisposedOrHeadersSent();
				if (value == null)
				{
					throw new ArgumentNullException("value");
				}
				if (value.Major != 1 || (value.Minor != 0 && value.Minor != 1))
				{
					throw new ArgumentException("Neither 1.0 nor 1.1.", "value");
				}
				_version = value;
			}
		}

		public string RedirectLocation
		{
			get
			{
				checkDisposed();
				return _location;
			}
			set
			{
				checkDisposedOrHeadersSent();
				if (value.Length == 0)
				{
					throw new ArgumentException("An empty string.", "value");
				}
				_location = value;
			}
		}

		public bool SendChunked
		{
			get
			{
				return _chunked;
			}
			set
			{
				checkDisposedOrHeadersSent();
				_chunked = value;
			}
		}

		public int StatusCode
		{
			get
			{
				checkDisposed();
				return _statusCode;
			}
			set
			{
				checkDisposedOrHeadersSent();
				if (value < 100 || value > 999)
				{
					throw new ProtocolViolationException("StatusCode must be between 100 and 999.");
				}
				_statusCode = value;
				_statusDescription = value.GetStatusDescription();
			}
		}

		public string StatusDescription
		{
			get
			{
				checkDisposed();
				return _statusDescription;
			}
			set
			{
				checkDisposedOrHeadersSent();
				_statusDescription = ((value == null || value.Length == 0) ? _statusCode.GetStatusDescription() : value);
			}
		}

		internal HttpListenerResponse(HttpListenerContext context)
		{
			_context = context;
			_headers = new WebHeaderCollection();
			_keepAlive = true;
			_statusCode = 200;
			_statusDescription = "OK";
			_version = HttpVersion.Version11;
		}

		private bool canAddOrUpdate(Cookie cookie)
		{
			if (_cookies == null || _cookies.Count == 0)
			{
				return true;
			}
			List<Cookie> list = findCookie(cookie).ToList();
			if (list.Count == 0)
			{
				return true;
			}
			int version = cookie.Version;
			foreach (Cookie item in list)
			{
				if (item.Version == version)
				{
					return true;
				}
			}
			return false;
		}

		private void checkDisposed()
		{
			if (_disposed)
			{
				throw new ObjectDisposedException(GetType().ToString());
			}
		}

		private void checkDisposedOrHeadersSent()
		{
			if (_disposed)
			{
				throw new ObjectDisposedException(GetType().ToString());
			}
			if (_headersSent)
			{
				throw new InvalidOperationException("Cannot be changed after headers are sent.");
			}
		}

		private void close(bool force)
		{
			_disposed = true;
			_context.Connection.Close(force);
		}

		private IEnumerable<Cookie> findCookie(Cookie cookie)
		{
			string name = cookie.Name;
			string domain = cookie.Domain;
			string path = cookie.Path;
			if (_cookies == null)
			{
				yield break;
			}
			foreach (Cookie cookie2 in _cookies)
			{
				if (cookie2.Name.Equals(name, StringComparison.OrdinalIgnoreCase) && cookie2.Domain.Equals(domain, StringComparison.OrdinalIgnoreCase) && cookie2.Path.Equals(path, StringComparison.Ordinal))
				{
					yield return cookie2;
				}
			}
		}

		internal void SendHeaders(bool closing, MemoryStream stream)
		{
			if (_contentType != null)
			{
				string value = ((_contentEncoding != null && _contentType.IndexOf("charset=", StringComparison.Ordinal) == -1) ? (_contentType + "; charset=" + _contentEncoding.WebName) : _contentType);
				_headers.SetInternally("Content-Type", value, response: true);
			}
			if (_headers["Server"] == null)
			{
				_headers.SetInternally("Server", "websocket-sharp/1.0", response: true);
			}
			CultureInfo invariantCulture = CultureInfo.InvariantCulture;
			if (_headers["Date"] == null)
			{
				_headers.SetInternally("Date", DateTime.UtcNow.ToString("r", invariantCulture), response: true);
			}
			if (!_chunked)
			{
				if (!_contentLengthSet && closing)
				{
					_contentLengthSet = true;
					_contentLength = 0L;
				}
				if (_contentLengthSet)
				{
					_headers.SetInternally("Content-Length", _contentLength.ToString(invariantCulture), response: true);
				}
			}
			Version protocolVersion = _context.Request.ProtocolVersion;
			if (!_contentLengthSet && !_chunked && protocolVersion >= HttpVersion.Version11)
			{
				_chunked = true;
			}
			bool flag = _statusCode == 400 || _statusCode == 408 || _statusCode == 411 || _statusCode == 413 || _statusCode == 414 || _statusCode == 500 || _statusCode == 503;
			if (!flag)
			{
				flag = !_context.Request.KeepAlive;
			}
			if (!_keepAlive || flag)
			{
				_headers.SetInternally("Connection", "close", response: true);
				flag = true;
			}
			if (_chunked)
			{
				_headers.SetInternally("Transfer-Encoding", "chunked", response: true);
			}
			int reuses = _context.Connection.Reuses;
			if (reuses >= 100)
			{
				_forceCloseChunked = true;
				if (!flag)
				{
					_headers.SetInternally("Connection", "close", response: true);
					flag = true;
				}
			}
			if (!flag)
			{
				_headers.SetInternally("Keep-Alive", $"timeout=15,max={100 - reuses}", response: true);
				if (_context.Request.ProtocolVersion <= HttpVersion.Version10)
				{
					_headers.SetInternally("Connection", "keep-alive", response: true);
				}
			}
			if (_location != null)
			{
				_headers.SetInternally("Location", _location, response: true);
			}
			if (_cookies != null)
			{
				foreach (Cookie cookie in _cookies)
				{
					_headers.SetInternally("Set-Cookie", cookie.ToResponseString(), response: true);
				}
			}
			Encoding encoding = _contentEncoding ?? Encoding.Default;
			StreamWriter streamWriter = new StreamWriter(stream, encoding, 256);
			streamWriter.Write("HTTP/{0} {1} {2}\r\n", _version, _statusCode, _statusDescription);
			string value2 = _headers.ToStringMultiValue(response: true);
			streamWriter.Write(value2);
			streamWriter.Flush();
			int num = ((encoding.CodePage == 65001) ? 3 : encoding.GetPreamble().Length);
			if (_outputStream == null)
			{
				_outputStream = _context.Connection.GetResponseStream();
			}
			stream.Position = num;
			_headersSent = true;
		}

		public void Abort()
		{
			if (!_disposed)
			{
				close(force: true);
			}
		}

		public void AddHeader(string name, string value)
		{
			checkDisposedOrHeadersSent();
			_headers.Set(name, value);
		}

		public void AppendCookie(Cookie cookie)
		{
			checkDisposedOrHeadersSent();
			Cookies.Add(cookie);
		}

		public void AppendHeader(string name, string value)
		{
			checkDisposedOrHeadersSent();
			_headers.Add(name, value);
		}

		public void Close()
		{
			if (!_disposed)
			{
				close(force: false);
			}
		}

		public void Close(byte[] responseEntity, bool willBlock)
		{
			if (responseEntity == null)
			{
				throw new ArgumentNullException("responseEntity");
			}
			int num = responseEntity.Length;
			ContentLength64 = num;
			Stream output = OutputStream;
			if (willBlock)
			{
				output.Write(responseEntity, 0, num);
				close(force: false);
				return;
			}
			output.BeginWrite(responseEntity, 0, num, delegate(IAsyncResult ar)
			{
				output.EndWrite(ar);
				close(force: false);
			}, null);
		}

		public void CopyFrom(HttpListenerResponse templateResponse)
		{
			checkDisposedOrHeadersSent();
			_headers.Clear();
			_headers.Add(templateResponse._headers);
			_contentLength = templateResponse._contentLength;
			_statusCode = templateResponse._statusCode;
			_statusDescription = templateResponse._statusDescription;
			_keepAlive = templateResponse._keepAlive;
			_version = templateResponse._version;
		}

		public void Redirect(string url)
		{
			StatusCode = 302;
			_location = url;
		}

		public void SetCookie(Cookie cookie)
		{
			checkDisposedOrHeadersSent();
			if (cookie == null)
			{
				throw new ArgumentNullException("cookie");
			}
			if (!canAddOrUpdate(cookie))
			{
				throw new ArgumentException("Cannot be replaced.", "cookie");
			}
			Cookies.Add(cookie);
		}

		void IDisposable.Dispose()
		{
			if (!_disposed)
			{
				close(force: true);
			}
		}
	}
	public enum HttpStatusCode
	{
		Continue = 100,
		SwitchingProtocols = 101,
		OK = 200,
		Created = 201,
		Accepted = 202,
		NonAuthoritativeInformation = 203,
		NoContent = 204,
		ResetContent = 205,
		PartialContent = 206,
		MultipleChoices = 300,
		Ambiguous = 300,
		MovedPermanently = 301,
		Moved = 301,
		Found = 302,
		Redirect = 302,
		SeeOther = 303,
		RedirectMethod = 303,
		NotModified = 304,
		UseProxy = 305,
		Unused = 306,
		TemporaryRedirect = 307,
		RedirectKeepVerb = 307,
		BadRequest = 400,
		Unauthorized = 401,
		PaymentRequired = 402,
		Forbidden = 403,
		NotFound = 404,
		MethodNotAllowed = 405,
		NotAcceptable = 406,
		ProxyAuthenticationRequired = 407,
		RequestTimeout = 408,
		Conflict = 409,
		Gone = 410,
		LengthRequired = 411,
		PreconditionFailed = 412,
		RequestEntityTooLarge = 413,
		RequestUriTooLong = 414,
		UnsupportedMediaType = 415,
		RequestedRangeNotSatisfiable = 416,
		ExpectationFailed = 417,
		InternalServerError = 500,
		NotImplemented = 501,
		BadGateway = 502,
		ServiceUnavailable = 503,
		GatewayTimeout = 504,
		HttpVersionNotSupported = 505
	}
	internal class HttpStreamAsyncResult : IAsyncResult
	{
		private AsyncCallback _callback;

		private bool _completed;

		private object _state;

		private object _sync;

		private ManualResetEvent _waitHandle;

		internal byte[] Buffer;

		internal int Count;

		internal Exception Error;

		internal int Offset;

		internal int SyncRead;

		public object AsyncState => _state;

		public WaitHandle AsyncWaitHandle
		{
			get
			{
				lock (_sync)
				{
					return _waitHandle ?? (_waitHandle = new ManualResetEvent(_completed));
				}
			}
		}

		public bool CompletedSynchronously => SyncRead == Count;

		public bool IsCompleted
		{
			get
			{
				lock (_sync)
				{
					return _completed;
				}
			}
		}

		public HttpStreamAsyncResult(AsyncCallback callback, object state)
		{
			_callback = callback;
			_state = state;
			_sync = new object();
		}

		public void Complete()
		{
			lock (_sync)
			{
				if (_completed)
				{
					return;
				}
				_completed = true;
				if (_waitHandle != null)
				{
					_waitHandle.Set();
				}
				if (_callback != null)
				{
					_callback.BeginInvoke(this, delegate(IAsyncResult ar)
					{
						_callback.EndInvoke(ar);
					}, null);
				}
			}
		}

		public void Complete(Exception exception)
		{
			Error = exception;
			Complete();
		}
	}
	internal sealed class HttpUtility
	{
		private static Dictionary<string, char> _entities;

		private static char[] _hexChars = "0123456789abcdef".ToCharArray();

		private static object _sync = new object();

		private static Dictionary<string, char> Entities
		{
			get
			{
				lock (_sync)
				{
					if (_entities == null)
					{
						initEntities();
					}
					return _entities;
				}
			}
		}

		private static int getChar(byte[] bytes, int offset, int length)
		{
			int num = 0;
			int num2 = length + offset;
			for (int i = offset; i < num2; i++)
			{
				int @int = getInt(bytes[i]);
				if (@int == -1)
				{
					return -1;
				}
				num = (num << 4) + @int;
			}
			return num;
		}

		private static int getChar(string s, int offset, int length)
		{
			int num = 0;
			int num2 = length + offset;
			for (int i = offset; i < num2; i++)
			{
				char c = s[i];
				if (c > '\u007f')
				{
					return -1;
				}
				int @int = getInt((byte)c);
				if (@int == -1)
				{
					return -1;
				}
				num = (num << 4) + @int;
			}
			return num;
		}

		private static char[] getChars(MemoryStream buffer, Encoding encoding)
		{
			return encoding.GetChars(buffer.GetBuffer(), 0, (int)buffer.Length);
		}

		private static int getInt(byte b)
		{
			char c = (char)b;
			if (c < '0' || c > '9')
			{
				if (c < 'a' || c > 'f')
				{
					if (c < 'A' || c > 'F')
					{
						return -1;
					}
					return c - 65 + 10;
				}
				return c - 97 + 10;
			}
			return c - 48;
		}

		private static void initEntities()
		{
			_entities = new Dictionary<string, char>();
			_entities.Add("nbsp", '\u00a0');
			_entities.Add("iexcl", '¡');
			_entities.Add("cent", '¢');
			_entities.Add("pound", '£');
			_entities.Add("curren", '¤');
			_entities.Add("yen", '¥');
			_entities.Add("brvbar", '¦');
			_entities.Add("sect", '§');
			_entities.Add("uml", '\u00a8');
			_entities.Add("copy", '©');
			_entities.Add("ordf", 'ª');
			_entities.Add("laquo", '«');
			_entities.Add("not", '¬');
			_entities.Add("shy", '\u00ad');
			_entities.Add("reg", '®');
			_entities.Add("macr", '\u00af');
			_entities.Add("deg", '°');
			_entities.Add("plusmn", '±');
			_entities.Add("sup2", '²');
			_entities.Add("sup3", '³');
			_entities.Add("acute", '\u00b4');
			_entities.Add("micro", 'µ');
			_entities.Add("para", '¶');
			_entities.Add("middot", '·');
			_entities.Add("cedil", '\u00b8');
			_entities.Add("sup1", '¹');
			_entities.Add("ordm", 'º');
			_entities.Add("raquo", '»');
			_entities.Add("frac14", '¼');
			_entities.Add("frac12", '½');
			_entities.Add("frac34", '¾');
			_entities.Add("iquest", '¿');
			_entities.Add("Agrave", 'À');
			_entities.Add("Aacute", 'Á');
			_entities.Add("Acirc", 'Â');
			_entities.Add("Atilde", 'Ã');
			_entities.Add("Auml", 'Ä');
			_entities.Add("Aring", 'Å');
			_entities.Add("AElig", 'Æ');
			_entities.Add("Ccedil", 'Ç');
			_entities.Add("Egrave", 'È');
			_entities.Add("Eacute", 'É');
			_entities.Add("Ecirc", 'Ê');
			_entities.Add("Euml", 'Ë');
			_entities.Add("Igrave", 'Ì');
			_entities.Add("Iacute", 'Í');
			_entities.Add("Icirc", 'Î');
			_entities.Add("Iuml", 'Ï');
			_entities.Add("ETH", 'Ð');
			_entities.Add("Ntilde", 'Ñ');
			_entities.Add("Ograve", 'Ò');
			_entities.Add("Oacute", 'Ó');
			_entities.Add("Ocirc", 'Ô');
			_entities.Add("Otilde", 'Õ');
			_entities.Add("Ouml", 'Ö');
			_entities.Add("times", '×');
			_entities.Add("Oslash", 'Ø');
			_entities.Add("Ugrave", 'Ù');
			_entities.Add("Uacute", 'Ú');
			_entities.Add("Ucirc", 'Û');
			_entities.Add("Uuml", 'Ü');
			_entities.Add("Yacute", 'Ý');
			_entities.Add("THORN", 'Þ');
			_entities.Add("szlig", 'ß');
			_entities.Add("agrave", 'à');
			_entities.Add("aacute", 'á');
			_entities.Add("acirc", 'â');
			_entities.Add("atilde", 'ã');
			_entities.Add("auml", 'ä');
			_entities.Add("aring", 'å');
			_entities.Add("aelig", 'æ');
			_entities.Add("ccedil", 'ç');
			_entities.Add("egrave", 'è');
			_entities.Add("eacute", 'é');
			_entities.Add("ecirc", 'ê');
			_entities.Add("euml", 'ë');
			_entities.Add("igrave", 'ì');
			_entities.Add("iacute", 'í');
			_entities.Add("icirc", 'î');
			_entities.Add("iuml", 'ï');
			_entities.Add("eth", 'ð');
			_entities.Add("ntilde", 'ñ');
			_entities.Add("ograve", 'ò');
			_entities.Add("oacute", 'ó');
			_entities.Add("ocirc", 'ô');
			_entities.Add("otilde", 'õ');
			_entities.Add("ouml", 'ö');
			_entities.Add("divide", '÷');
			_entities.Add("oslash", 'ø');
			_entities.Add("ugrave", 'ù');
			_entities.Add("uacute", 'ú');
			_entities.Add("ucirc", 'û');
			_entities.Add("uuml", 'ü');
			_entities.Add("yacute", 'ý');
			_entities.Add("thorn", 'þ');
			_entities.Add("yuml", 'ÿ');
			_entities.Add("fnof", 'ƒ');
			_entities.Add("Alpha", 'Α');
			_entities.Add("Beta", 'Β');
			_entities.Add("Gamma", 'Γ');
			_entities.Add("Delta", 'Δ');
			_entities.Add("Epsilon", 'Ε');
			_entities.Add("Zeta", 'Ζ');
			_entities.Add("Eta", 'Η');
			_entities.Add("Theta", 'Θ');
			_entities.Add("Iota", 'Ι');
			_entities.Add("Kappa", 'Κ');
			_entities.Add("Lambda", 'Λ');
			_entities.Add("Mu", 'Μ');
			_entities.Add("Nu", 'Ν');
			_entities.Add("Xi", 'Ξ');
			_entities.Add("Omicron", 'Ο');
			_entities.Add("Pi", 'Π');
			_entities.Add("Rho", 'Ρ');
			_entities.Add("Sigma", 'Σ');
			_entities.Add("Tau", 'Τ');
			_entities.Add("Upsilon", 'Υ');
			_entities.Add("Phi", 'Φ');
			_entities.Add("Chi", 'Χ');
			_entities.Add("Psi", 'Ψ');
			_entities.Add("Omega", 'Ω');
			_entities.Add("alpha", 'α');
			_entities.Add("beta", 'β');
			_entities.Add("gamma", 'γ');
			_entities.Add("delta", 'δ');
			_entities.Add("epsilon", 'ε');
			_entities.Add("zeta", 'ζ');
			_entities.Add("eta", 'η');
			_entities.Add("theta", 'θ');
			_entities.Add("iota", 'ι');
			_entities.Add("kappa", 'κ');
			_entities.Add("lambda", 'λ');
			_entities.Add("mu", 'μ');
			_entities.Add("nu", 'ν');
			_entities.Add("xi", 'ξ');
			_entities.Add("omicron", 'ο');
			_entities.Add("pi", 'π');
			_entities.Add("rho", 'ρ');
			_entities.Add("sigmaf", 'ς');
			_entities.Add("sigma", 'σ');
			_entities.Add("tau", 'τ');
			_entities.Add("upsilon", 'υ');
			_entities.Add("phi", 'φ');
			_entities.Add("chi", 'χ');
			_entities.Add("psi", 'ψ');
			_entities.Add("omega", 'ω');
			_entities.Add("thetasym", 'ϑ');
			_entities.Add("upsih", 'ϒ');
			_entities.Add("piv", 'ϖ');
			_entities.Add("bull", '•');
			_entities.Add("hellip", '…');
			_entities.Add("prime", '′');
			_entities.Add("Prime", '″');
			_entities.Add("oline", '‾');
			_entities.Add("frasl", '⁄');
			_entities.Add("weierp", '℘');
			_entities.Add("image", 'ℑ');
			_entities.Add("real", 'ℜ');
			_entities.Add("trade", '™');
			_entities.Add("alefsym", 'ℵ');
			_entities.Add("larr", '←');
			_entities.Add("uarr", '↑');
			_entities.Add("rarr", '→');
			_entities.Add("darr", '↓');
			_entities.Add("harr", '↔');
			_entities.Add("crarr", '↵');
			_entities.Add("lArr", '⇐');
			_entities.Add("uArr", '⇑');
			_entities.Add("rArr", '⇒');
			_entities.Add("dArr", '⇓');
			_entities.Add("hArr", '⇔');
			_entities.Add("forall", '∀');
			_entities.Add("part", '∂');
			_entities.Add("exist", '∃');
			_entities.Add("empty", '∅');
			_entities.Add("nabla", '∇');
			_entities.Add("isin", '∈');
			_entities.Add("notin", '∉');
			_entities.Add("ni", '∋');
			_entities.Add("prod", '∏');
			_entities.Add("sum", '∑');
			_entities.Add("minus", '−');
			_entities.Add("lowast", '∗');
			_entities.Add("radic", '√');
			_entities.Add("prop", '∝');
			_entities.Add("infin", '∞');
			_entities.Add("ang", '∠');
			_entities.Add("and", '∧');
			_entities.Add("or", '∨');
			_entities.Add("cap", '∩');
			_entities.Add("cup", '∪');
			_entities.Add("int", '∫');
			_entities.Add("there4", '∴');
			_entities.Add("sim", '∼');
			_entities.Add("cong", '≅');
			_entities.Add("asymp", '≈');
			_entities.Add("ne", '≠');
			_entities.Add("equiv", '≡');
			_entities.Add("le", '≤');
			_entities.Add("ge", '≥');
			_entities.Add("sub", '⊂');
			_entities.Add("sup", '⊃');
			_entities.Add("nsub", '⊄');
			_entities.Add("sube", '⊆');
			_entities.Add("supe", '⊇');
			_entities.Add("oplus", '⊕');
			_entities.Add("otimes", '⊗');
			_entities.Add("perp", '⊥');
			_entities.Add("sdot", '⋅');
			_entities.Add("lceil", '⌈');
			_entities.Add("rceil", '⌉');
			_entities.Add("lfloor", '⌊');
			_entities.Add("rfloor", '⌋');
			_entities.Add("lang", '〈');
			_entities.Add("rang", '〉');
			_entities.Add("loz", '◊');
			_entities.Add("spades", '♠');
			_entities.Add("clubs", '♣');
			_entities.Add("hearts", '♥');
			_entities.Add("diams", '♦');
			_entities.Add("quot", '"');
			_entities.Add("amp", '&');
			_entities.Add("lt", '<');
			_entities.Add("gt", '>');
			_entities.Add("OElig", 'Œ');
			_entities.Add("oelig", 'œ');
			_entities.Add("Scaron", 'Š');
			_entities.Add("scaron", 'š');
			_entities.Add("Yuml", 'Ÿ');
			_entities.Add("circ", 'ˆ');
			_entities.Add("tilde", '\u02dc');
			_entities.Add("ensp", '\u2002');
			_entities.Add("emsp", '\u2003');
			_entities.Add("thinsp", '\u2009');
			_entities.Add("zwnj", '\u200c');
			_entities.Add("zwj", '\u200d');
			_entities.Add("lrm", '\u200e');
			_entities.Add("rlm", '\u200f');
			_entities.Add("ndash", '–');
			_entities.Add("mdash", '—');
			_entities.Add("lsquo", '‘');
			_entities.Add("rsquo", '’');
			_entities.Add("sbquo", '‚');
			_entities.Add("ldquo", '“');
			_entities.Add("rdquo", '”');
			_entities.Add("bdquo", '„');
			_entities.Add("dagger", '†');
			_entities.Add("Dagger", '‡');
			_entities.Add("permil", '‰');
			_entities.Add("lsaquo", '‹');
			_entities.Add("rsaquo", '›');
			_entities.Add("euro", '€');
		}

		private static bool notEncoded(char c)
		{
			if (c != '!' && c != '\'' && c != '(' && c != ')' && c != '*' && c != '-' && c != '.')
			{
				return c == '_';
			}
			return true;
		}

		private static void urlEncodeChar(char c, Stream result, bool isUnicode)
		{
			if (c > 'ÿ')
			{
				result.WriteByte(37);
				result.WriteByte(117);
				int num = (int)c >> 12;
				result.WriteByte((byte)_hexChars[num]);
				num = ((int)c >> 8) & 0xF;
				result.WriteByte((byte)_hexChars[num]);
				num = ((int)c >> 4) & 0xF;
				result.WriteByte((byte)_hexChars[num]);
				num = c & 0xF;
				result.WriteByte((byte)_hexChars[num]);
			}
			else if (c > ' ' && notEncoded(c))
			{
				result.WriteByte((byte)c);
			}
			else if (c == ' ')
			{
				result.WriteByte(43);
			}
			else if (c < '0' || (c < 'A' && c > '9') || (c > 'Z' && c < 'a') || c > 'z')
			{
				if (isUnicode && c > '\u007f')
				{
					result.WriteByte(37);
					result.WriteByte(117);
					result.WriteByte(48);
					result.WriteByte(48);
				}
				else
				{
					result.WriteByte(37);
				}
				int num2 = (int)c >> 4;
				result.WriteByte((byte)_hexChars[num2]);
				num2 = c & 0xF;
				result.WriteByte((byte)_hexChars[num2]);
			}
			else
			{
				result.WriteByte((byte)c);
			}
		}

		private static void urlPathEncodeChar(char c, Stream result)
		{
			if (c < '!' || c > '~')
			{
				byte[] bytes = Encoding.UTF8.GetBytes(c.ToString());
				foreach (byte num in bytes)
				{
					result.WriteByte(37);
					int num2 = num >> 4;
					result.WriteByte((byte)_hexChars[num2]);
					num2 = num & 0xF;
					result.WriteByte((byte)_hexChars[num2]);
				}
			}
			else if (c == ' ')
			{
				result.WriteByte(37);
				result.WriteByte(50);
				result.WriteByte(48);
			}
			else
			{
				result.WriteByte((byte)c);
			}
		}

		private static void writeCharBytes(IList buffer, char c, Encoding encoding)
		{
			if (c > 'ÿ')
			{
				byte[] bytes = encoding.GetBytes(new char[1] { c });
				foreach (byte b in bytes)
				{
					buffer.Add(b);
				}
			}
			else
			{
				buffer.Add((byte)c);
			}
		}

		internal static Uri CreateRequestUrl(string requestUri, string host, bool websocketRequest, bool secure)
		{
			if (requestUri == null || requestUri.Length == 0 || host == null || host.Length == 0)
			{
				return null;
			}
			string text = null;
			string arg = null;
			if (requestUri.StartsWith("/"))
			{
				arg = requestUri;
			}
			else if (requestUri.MaybeUri())
			{
				if (!Uri.TryCreate(requestUri, UriKind.Absolute, out var result) || ((!(text = result.Scheme).StartsWith("http") || websocketRequest) && !(text.StartsWith("ws") && websocketRequest)))
				{
					return null;
				}
				host = result.Authority;
				arg = result.PathAndQuery;
			}
			else if (!(requestUri == "*"))
			{
				host = requestUri;
			}
			if (text == null)
			{
				text = (websocketRequest ? "ws" : "http") + (secure ? "s" : string.Empty);
			}
			if (host.IndexOf(':') == -1)
			{
				host = string.Format("{0}:{1}", host, (text == "http" || text == "ws") ? 80 : 443);
			}
			if (!Uri.TryCreate($"{text}://{host}{arg}", UriKind.Absolute, out var result2))
			{
				return null;
			}
			return result2;
		}

		internal static NameValueCollection ParseQueryStringInternally(string query, Encoding encoding)
		{
			int length;
			if (query == null || (length = query.Length) == 0 || (length == 1 && query[0] == '?'))
			{
				return new NameValueCollection(1);
			}
			if (query[0] == '?')
			{
				query = query.Substring(1);
			}
			QueryStringCollection queryStringCollection = new QueryStringCollection();
			string[] array = query.Split('&');
			foreach (string text in array)
			{
				int num = text.IndexOf('=');
				if (num > -1)
				{
					string name = UrlDecode(text.Substring(0, num), encoding);
					string value = ((text.Length > num + 1) ? UrlDecode(text.Substring(num + 1), encoding) : string.Empty);
					queryStringCollection.Add(name, value);
				}
				else
				{
					queryStringCollection.Add(null, UrlDecode(text, encoding));
				}
			}
			return queryStringCollection;
		}

		internal static string UrlDecodeInternally(byte[] bytes, int offset, int count, Encoding encoding)
		{
			StringBuilder stringBuilder = new StringBuilder();
			using (MemoryStream memoryStream = new MemoryStream())
			{
				int num = count + offset;
				for (int i = offset; i < num; i++)
				{
					if (bytes[i] == 37 && i + 2 < count && bytes[i + 1] != 37)
					{
						int @char;
						if (bytes[i + 1] == 117 && i + 5 < num)
						{
							if (memoryStream.Length > 0)
							{
								stringBuilder.Append(getChars(memoryStream, encoding));
								memoryStream.SetLength(0L);
							}
							@char = getChar(bytes, i + 2, 4);
							if (@char != -1)
							{
								stringBuilder.Append((char)@char);
								i += 5;
								continue;
							}
						}
						else if ((@char = getChar(bytes, i + 1, 2)) != -1)
						{
							memoryStream.WriteByte((byte)@char);
							i += 2;
							continue;
						}
					}
					if (memoryStream.Length > 0)
					{
						stringBuilder.Append(getChars(memoryStream, encoding));
						memoryStream.SetLength(0L);
					}
					if (bytes[i] == 43)
					{
						stringBuilder.Append(' ');
					}
					else
					{
						stringBuilder.Append((char)bytes[i]);
					}
				}
				if (memoryStream.Length > 0)
				{
					stringBuilder.Append(getChars(memoryStream, encoding));
				}
			}
			return stringBuilder.ToString();
		}

		internal static byte[] UrlDecodeToBytesInternally(byte[] bytes, int offset, int count)
		{
			using MemoryStream memoryStream = new MemoryStream();
			int num = offset + count;
			for (int i = offset; i < num; i++)
			{
				char c = (char)bytes[i];
				switch (c)
				{
				case '+':
					c = ' ';
					break;
				case '%':
					if (i < num - 2)
					{
						int @char = getChar(bytes, i + 1, 2);
						if (@char != -1)
						{
							c = (char)@char;
							i += 2;
						}
					}
					break;
				}
				memoryStream.WriteByte((byte)c);
			}
			memoryStream.Close();
			return memoryStream.ToArray();
		}

		internal static byte[] UrlEncodeToBytesInternally(byte[] bytes, int offset, int count)
		{
			using MemoryStream memoryStream = new MemoryStream();
			int num = offset + count;
			for (int i = offset; i < num; i++)
			{
				urlEncodeChar((char)bytes[i], memoryStream, isUnicode: false);
			}
			memoryStream.Close();
			return memoryStream.ToArray();
		}

		internal static byte[] UrlEncodeUnicodeToBytesInternally(string s)
		{
			using MemoryStream memoryStream = new MemoryStream();
			for (int i = 0; i < s.Length; i++)
			{
				urlEncodeChar(s[i], memoryStream, isUnicode: true);
			}
			memoryStream.Close();
			return memoryStream.ToArray();
		}

		public static string HtmlAttributeEncode(string s)
		{
			if (s == null || s.Length == 0 || !s.Contains('&', '"', '<', '>'))
			{
				return s;
			}
			StringBuilder stringBuilder = new StringBuilder();
			for (int i = 0; i < s.Length; i++)
			{
				char c = s[i];
				stringBuilder.Append(c switch
				{
					'>' => "&gt;", 
					'<' => "&lt;", 
					'"' => "&quot;", 
					'&' => "&amp;", 
					_ => c.ToString(), 
				});
			}
			return stringBuilder.ToString();
		}

		public static void HtmlAttributeEncode(string s, TextWriter output)
		{
			if (output == null)
			{
				throw new ArgumentNullException("output");
			}
			output.Write(HtmlAttributeEncode(s));
		}

		public static string HtmlDecode(string s)
		{
			if (s == null || s.Length == 0 || !s.Contains('&'))
			{
				return s;
			}
			StringBuilder stringBuilder = new StringBuilder();
			StringBuilder stringBuilder2 = new StringBuilder();
			int num = 0;
			int num2 = 0;
			bool flag = false;
			foreach (char c in s)
			{
				if (num == 0)
				{
					if (c == '&')
					{
						stringBuilder.Append(c);
						num = 1;
					}
					else
					{
						stringBuilder2.Append(c);
					}
					continue;
				}
				if (c == '&')
				{
					num = 1;
					if (flag)
					{
						stringBuilder.Append(num2.ToString(CultureInfo.InvariantCulture));
						flag = false;
					}
					stringBuilder2.Append(stringBuilder.ToString());
					stringBuilder.Length = 0;
					stringBuilder.Append('&');
					continue;
				}
				switch (num)
				{
				case 1:
					if (c == ';')
					{
						num = 0;
						stringBuilder2.Append(stringBuilder.ToString());
						stringBuilder2.Append(c);
						stringBuilder.Length = 0;
					}
					else
					{
						num2 = 0;
						num = ((c == '#') ? 3 : 2);
						stringBuilder.Append(c);
					}
					break;
				case 2:
					stringBuilder.Append(c);
					if (c == ';')
					{
						string text = stringBuilder.ToString();
						if (text.Length > 1 && Entities.ContainsKey(text.Substring(1, text.Length - 2)))
						{
							text = Entities[text.Substring(1, text.Length - 2)].ToString();
						}
						stringBuilder2.Append(text);
						num = 0;
						stringBuilder.Length = 0;
					}
					break;
				case 3:
					if (c == ';')
					{
						if (num2 > 65535)
						{
							stringBuilder2.Append("&#");
							stringBuilder2.Append(num2.ToString(CultureInfo.InvariantCulture));
							stringBuilder2.Append(";");
						}
						else
						{
							stringBuilder2.Append((char)num2);
						}
						num = 0;
						stringBuilder.Length = 0;
						flag = false;
					}
					else if (char.IsDigit(c))
					{
						num2 = num2 * 10 + (c - 48);
						flag = true;
					}
					else
					{
						num = 2;
						if (flag)
						{
							stringBuilder.Append(num2.ToString(CultureInfo.InvariantCulture));
							flag = false;
						}
						stringBuilder.Append(c);
					}
					break;
				}
			}
			if (stringBuilder.Length > 0)
			{
				stringBuilder2.Append(stringBuilder.ToString());
			}
			else if (flag)
			{
				stringBuilder2.Append(num2.ToString(CultureInfo.InvariantCulture));
			}
			return stringBuilder2.ToString();
		}

		public static void HtmlDecode(string s, TextWriter output)
		{
			if (output == null)
			{
				throw new ArgumentNullException("output");
			}
			output.Write(HtmlDecode(s));
		}

		public static string HtmlEncode(string s)
		{
			if (s == null || s.Length == 0)
			{
				return s;
			}
			bool flag = false;
			string text = s;
			foreach (char c in text)
			{
				if (c == '&' || c == '"' || c == '<' || c == '>' || c > '\u009f')
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				return s;
			}
			StringBuilder stringBuilder = new StringBuilder();
			text = s;
			foreach (char c2 in text)
			{
				if (c2 == '&')
				{
					stringBuilder.Append("&amp;");
				}
				else if (c2 == '"')
				{
					stringBuilder.Append("&quot;");
				}
				else if (c2 == '<')
				{
					stringBuilder.Append("&lt;");
				}
				else if (c2 == '>')
				{
					stringBuilder.Append("&gt;");
				}
				else if (c2 > '\u009f')
				{
					stringBuilder.Append("&#");
					int num = c2;
					stringBuilder.Append(num.ToString(CultureInfo.InvariantCulture));
					stringBuilder.Append(";");
				}
				else
				{
					stringBuilder.Append(c2);
				}
			}
			return stringBuilder.ToString();
		}

		public static void HtmlEncode(string s, TextWriter output)
		{
			if (output == null)
			{
				throw new ArgumentNullException("output");
			}
			output.Write(HtmlEncode(s));
		}

		public static NameValueCollection ParseQueryString(string query)
		{
			if (query == null)
			{
				throw new ArgumentNullException("query");
			}
			return ParseQueryStringInternally(query, Encoding.UTF8);
		}

		public static NameValueCollection ParseQueryString(string query, Encoding encoding)
		{
			if (query == null)
			{
				throw new ArgumentNullException("query");
			}
			if (encoding == null)
			{
				throw new ArgumentNullException("encoding");
			}
			return ParseQueryStringInternally(query, encoding);
		}

		public static string UrlDecode(string s)
		{
			return UrlDecode(s, Encoding.UTF8);
		}

		public static string UrlDecode(string s, Encoding encoding)
		{
			if (s == null || s.Length == 0 || !s.Contains('%', '+'))
			{
				return s;
			}
			if (encoding == null)
			{
				encoding = Encoding.UTF8;
			}
			int length = s.Length;
			List<byte> list = new List<byte>();
			for (int i = 0; i < length; i++)
			{
				char c = s[i];
				if (c == '%' && i + 2 < length && s[i + 1] != '%')
				{
					int @char;
					if (s[i + 1] == 'u' && i + 5 < length)
					{
						@char = getChar(s, i + 2, 4);
						if (@char != -1)
						{
							writeCharBytes(list, (char)@char, encoding);
							i += 5;
						}
						else
						{
							writeCharBytes(list, '%', encoding);
						}
					}
					else if ((@char = getChar(s, i + 1, 2)) != -1)
					{
						writeCharBytes(list, (char)@char, encoding);
						i += 2;
					}
					else
					{
						writeCharBytes(list, '%', encoding);
					}
				}
				else if (c == '+')
				{
					writeCharBytes(list, ' ', encoding);
				}
				else
				{
					writeCharBytes(list, c, encoding);
				}
			}
			return encoding.GetString(list.ToArray());
		}

		public static string UrlDecode(byte[] bytes, Encoding encoding)
		{
			if (bytes == null)
			{
				return null;
			}
			int num = bytes.Length;
			if (num == 0)
			{
				return string.Empty;
			}
			if (encoding == null)
			{
				encoding = Encoding.UTF8;
			}
			return UrlDecodeInternally(bytes, 0, num, encoding);
		}

		public static string UrlDecode(byte[] bytes, int offset, int count, Encoding encoding)
		{
			if (bytes == null)
			{
				return null;
			}
			int num = bytes.Length;
			if (num == 0 || count == 0)
			{
				return string.Empty;
			}
			if (offset < 0 || offset >= num)
			{
				throw new ArgumentOutOfRangeException("offset");
			}
			if (count < 0 || count > num - offset)
			{
				throw new ArgumentOutOfRangeException("count");
			}
			if (encoding == null)
			{
				encoding = Encoding.UTF8;
			}
			return UrlDecodeInternally(bytes, offset, count, encoding);
		}

		public static byte[] UrlDecodeToBytes(byte[] bytes)
		{
			int count;
			if (bytes == null || (count = bytes.Length) <= 0)
			{
				return bytes;
			}
			return UrlDecodeToBytesInternally(bytes, 0, count);
		}

		public static byte[] UrlDecodeToBytes(string s)
		{
			return UrlDecodeToBytes(s, Encoding.UTF8);
		}

		public static byte[] UrlDecodeToBytes(string s, Encoding encoding)
		{
			if (s == null)
			{
				return null;
			}
			if (s.Length == 0)
			{
				return new byte[0];
			}
			if (encoding == null)
			{
				encoding = Encoding.UTF8;
			}
			byte[] bytes = encoding.GetBytes(s);
			return UrlDecodeToBytesInternally(bytes, 0, bytes.Length);
		}

		public static byte[] UrlDecodeToBytes(byte[] bytes, int offset, int count)
		{
			int num;
			if (bytes == null || (num = bytes.Length) == 0)
			{
				return bytes;
			}
			if (count == 0)
			{
				return new byte[0];
			}
			if (offset < 0 || offset >= num)
			{
				throw new ArgumentOutOfRangeException("offset");
			}
			if (count < 0 || count > num - offset)
			{
				throw new ArgumentOutOfRangeException("count");
			}
			return UrlDecodeToBytesInternally(bytes, offset, count);
		}

		public static string UrlEncode(byte[] bytes)
		{
			if (bytes != null)
			{
				int count;
				if ((count = bytes.Length) != 0)
				{
					return Encoding.ASCII.GetString(UrlEncodeToBytesInternally(bytes, 0, count));
				}
				return string.Empty;
			}
			return null;
		}

		public static string UrlEncode(string s)
		{
			return UrlEncode(s, Encoding.UTF8);
		}

		public static string UrlEncode(string s, Encoding encoding)
		{
			int length;
			if (s == null || (length = s.Length) == 0)
			{
				return s;
			}
			bool flag = false;
			foreach (char c in s)
			{
				if ((c < '0' || (c < 'A' && c > '9') || (c > 'Z' && c < 'a') || c > 'z') && !notEncoded(c))
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				return s;
			}
			if (encoding == null)
			{
				encoding = Encoding.UTF8;
			}
			byte[] bytes = new byte[encoding.GetMaxByteCount(length)];
			int bytes2 = encoding.GetBytes(s, 0, length, bytes, 0);
			return Encoding.ASCII.GetString(UrlEncodeToBytesInternally(bytes, 0, bytes2));
		}

		public static string UrlEncode(byte[] bytes, int offset, int count)
		{
			byte[] array = UrlEncodeToBytes(bytes, offset, count);
			if (array != null)
			{
				if (array.Length != 0)
				{
					return Encoding.ASCII.GetString(array);
				}
				return string.Empty;
			}
			return null;
		}

		public static byte[] UrlEncodeToBytes(byte[] bytes)
		{
			int count;
			if (bytes == null || (count = bytes.Length) <= 0)
			{
				return bytes;
			}
			return UrlEncodeToBytesInternally(bytes, 0, count);
		}

		public static byte[] UrlEncodeToBytes(string s)
		{
			return UrlEncodeToBytes(s, Encoding.UTF8);
		}

		public static byte[] UrlEncodeToBytes(string s, Encoding encoding)
		{
			if (s == null)
			{
				return null;
			}
			if (s.Length == 0)
			{
				return new byte[0];
			}
			if (encoding == null)
			{
				encoding = Encoding.UTF8;
			}
			byte[] bytes = encoding.GetBytes(s);
			return UrlEncodeToBytesInternally(bytes, 0, bytes.Length);
		}

		public static byte[] UrlEncodeToBytes(byte[] bytes, int offset, int count)
		{
			int num;
			if (bytes == null || (num = bytes.Length) == 0)
			{
				return bytes;
			}
			if (count == 0)
			{
				return new byte[0];
			}
			if (offset < 0 || offset >= num)
			{
				throw new ArgumentOutOfRangeException("offset");
			}
			if (count < 0 || count > num - offset)
			{
				throw new ArgumentOutOfRangeException("count");
			}
			return UrlEncodeToBytesInternally(bytes, offset, count);
		}

		public static string UrlEncodeUnicode(string s)
		{
			if (s == null || s.Length <= 0)
			{
				return s;
			}
			return Encoding.ASCII.GetString(UrlEncodeUnicodeToBytesInternally(s));
		}

		public static byte[] UrlEncodeUnicodeToBytes(string s)
		{
			if (s != null)
			{
				if (s.Length != 0)
				{
					return UrlEncodeUnicodeToBytesInternally(s);
				}
				return new byte[0];
			}
			return null;
		}

		public static string UrlPathEncode(string s)
		{
			if (s == null || s.Length == 0)
			{
				return s;
			}
			using MemoryStream memoryStream = new MemoryStream();
			for (int i = 0; i < s.Length; i++)
			{
				urlPathEncodeChar(s[i], memoryStream);
			}
			memoryStream.Close();
			return Encoding.ASCII.GetString(memoryStream.ToArray());
		}
	}
	public class HttpVersion
	{
		public static readonly Version Version10 = new Version(1, 0);

		public static readonly Version Version11 = new Version(1, 1);
	}
	internal enum InputChunkState
	{
		None,
		Body,
		BodyFinished,
		Trailer
	}
	internal enum InputState
	{
		RequestLine,
		Headers
	}
	internal enum LineState
	{
		None,
		CR,
		LF
	}
	internal class ListenerAsyncResult : IAsyncResult
	{
		private AsyncCallback _callback;

		private bool _completed;

		private HttpListenerContext _context;

		private Exception _exception;

		private ManualResetEvent _waitHandle;

		private object _state;

		private object _sync;

		private bool _syncCompleted;

		internal bool EndCalled;

		internal bool InGet;

		public object AsyncState => _state;

		public WaitHandle AsyncWaitHandle
		{
			get
			{
				lock (_sync)
				{
					return _waitHandle ?? (_waitHandle = new ManualResetEvent(_completed));
				}
			}
		}

		public bool CompletedSynchronously => _syncCompleted;

		public bool IsCompleted
		{
			get
			{
				lock (_sync)
				{
					return _completed;
				}
			}
		}

		public ListenerAsyncResult(AsyncCallback callback, object state)
		{
			_callback = callback;
			_state = state;
			_sync = new object();
		}

		private static void invokeCallback(object state)
		{
			try
			{
				ListenerAsyncResult listenerAsyncResult = (ListenerAsyncResult)state;
				listenerAsyncResult._callback(listenerAsyncResult);
			}
			catch
			{
			}
		}

		internal void Complete(Exception exception)
		{
			_exception = ((InGet && exception is ObjectDisposedException) ? new HttpListenerException(500, "Listener closed.") : exception);
			lock (_sync)
			{
				_completed = true;
				if (_waitHandle != null)
				{
					_waitHandle.Set();
				}
				if (_callback != null)
				{
					ThreadPool.QueueUserWorkItem(invokeCallback, this);
				}
			}
		}

		internal void Complete(HttpListenerContext context)
		{
			Complete(context, syncCompleted: false);
		}

		internal void Complete(HttpListenerContext context, bool syncCompleted)
		{
			HttpListener listener = context.Listener;
			AuthenticationSchemes authenticationSchemes = listener.SelectAuthenticationScheme(context);
			if (authenticationSchemes == AuthenticationSchemes.None)
			{
				context.Response.Close(HttpStatusCode.Forbidden);
				listener.BeginGetContext(this);
				return;
			}
			string text = context.Request.Headers["Authorization"];
			if (authenticationSchemes == AuthenticationSchemes.Basic && (text == null || !text.StartsWith("basic", StringComparison.OrdinalIgnoreCase)))
			{
				context.Response.CloseWithAuthChallenge(AuthenticationChallenge.CreateBasicChallenge(listener.Realm).ToBasicString());
				listener.BeginGetContext(this);
				return;
			}
			if (authenticationSchemes == AuthenticationSchemes.Digest && (text == null || !text.StartsWith("digest", StringComparison.OrdinalIgnoreCase)))
			{
				context.Response.CloseWithAuthChallenge(AuthenticationChallenge.CreateDigestChallenge(listener.Realm).ToDigestString());
				listener.BeginGetContext(this);
				return;
			}
			_context = context;
			_syncCompleted = syncCompleted;
			lock (_sync)
			{
				_completed = true;
				if (_waitHandle != null)
				{
					_waitHandle.Set();
				}
				if (_callback != null)
				{
					ThreadPool.QueueUserWorkItem(invokeCallback, this);
				}
			}
		}

		internal HttpListenerContext GetContext()
		{
			if (_exception != null)
			{
				throw _exception;
			}
			return _context;
		}
	}
	internal sealed class ListenerPrefix
	{
		private IPAddress[] _addresses;

		private string _host;

		private string _original;

		private string _path;

		private ushort _port;

		private bool _secure;

		public HttpListener Listener;

		public IPAddress[] Addresses
		{
			get
			{
				return _addresses;
			}
			set
			{
				_addresses = value;
			}
		}

		public string Host => _host;

		public string Path => _path;

		public int Port => _port;

		public bool Secure => _secure;

		public ListenerPrefix(string uriPrefix)
		{
			_original = uriPrefix;
			parse(uriPrefix);
		}

		private void parse(string uriPrefix)
		{
			int num = (uriPrefix.StartsWith("https://") ? 443 : 80);
			if (num == 443)
			{
				_secure = true;
			}
			int length = uriPrefix.Length;
			int num2 = uriPrefix.IndexOf(':') + 3;
			int num3 = uriPrefix.IndexOf(':', num2, length - num2);
			if (num3 > 0)
			{
				int num4 = uriPrefix.IndexOf('/', num3, length - num3);
				_host = uriPrefix.Substring(num2, num3 - num2);
				_port = (ushort)int.Parse(uriPrefix.Substring(num3 + 1, num4 - num3 - 1));
				_path = uriPrefix.Substring(num4);
			}
			else
			{
				int num4 = uriPrefix.IndexOf('/', num2, length - num2);
				_host = uriPrefix.Substring(num2, num4 - num2);
				_port = (ushort)num;
				_path = uriPrefix.Substring(num4);
			}
			if (_path.Length > 1)
			{
				_path = _path.Substring(0, _path.Length - 1);
			}
		}

		public static void CheckUriPrefix(string uriPrefix)
		{
			if (uriPrefix == null)
			{
				throw new ArgumentNullException("uriPrefix");
			}
			if (!uriPrefix.StartsWith("http://") && !uriPrefix.StartsWith("https://"))
			{
				throw new ArgumentException("Only 'http' and 'https' schemes are supported.");
			}
			int length = uriPrefix.Length;
			int num = uriPrefix.IndexOf(':') + 3;
			if (num >= length)
			{
				throw new ArgumentException("No host specified.");
			}
			int num2 = uriPrefix.IndexOf(':', num, length - num);
			if (num == num2)
			{
				throw new ArgumentException("No host specified.");
			}
			if (num2 > 0)
			{
				int num3 = uriPrefix.IndexOf('/', num2, length - num2);
				if (num3 == -1)
				{
					throw new ArgumentException("No path specified.");
				}
				if (!int.TryParse(uriPrefix.Substring(num2 + 1, num3 - num2 - 1), out var result) || result <= 0 || result >= 65536)
				{
					throw new ArgumentException("Invalid port.");
				}
			}
			else
			{
				int num3 = uriPrefix.IndexOf('/', num, length - num);
				if (num3 == -1)
				{
					throw new ArgumentException("No path specified.");
				}
			}
			if (uriPrefix[uriPrefix.Length - 1] != '/')
			{
				throw new ArgumentException("The URI prefix must end with '/'.");
			}
		}

		public override bool Equals(object obj)
		{
			if (!(obj is ListenerPrefix listenerPrefix))
			{
				return false;
			}
			return _original == listenerPrefix._original;
		}

		public override int GetHashCode()
		{
			return _original.GetHashCode();
		}

		public override string ToString()
		{
			return _original;
		}
	}
	public class NetworkCredential
	{
		private string _domain;

		private string _password;

		private string[] _roles;

		private string _username;

		public string Domain
		{
			get
			{
				return _domain ?? string.Empty;
			}
			internal set
			{
				_domain = value;
			}
		}

		public string Password
		{
			get
			{
				return _password ?? string.Empty;
			}
			internal set
			{
				_password = value;
			}
		}

		public string[] Roles
		{
			get
			{
				return _roles;
			}
			internal set
			{
				_roles = value;
			}
		}

		public string UserName
		{
			get
			{
				return _username;
			}
			internal set
			{
				_username = value;
			}
		}

		public NetworkCredential(string username, string password)
			: this(username, password, null)
		{
		}

		public NetworkCredential(string username, string password, string domain, params string[] roles)
		{
			if (username == null || username.Length == 0)
			{
				throw new ArgumentException("Must not be null or empty.", "username");
			}
			_username = username;
			_password = password;
			_domain = domain;
			_roles = roles;
		}
	}
	internal sealed class QueryStringCollection : NameValueCollection
	{
		public override string ToString()
		{
			if (Count == 0)
			{
				return string.Empty;
			}
			StringBuilder stringBuilder = new StringBuilder();
			string[] allKeys = AllKeys;
			foreach (string text in allKeys)
			{
				stringBuilder.AppendFormat("{0}={1}&", text, base[text]);
			}
			if (stringBuilder.Length > 0)
			{
				stringBuilder.Length--;
			}
			return stringBuilder.ToString();
		}
	}
	internal class ReadBufferState
	{
		public HttpStreamAsyncResult AsyncResult { get; set; }

		public byte[] Buffer { get; set; }

		public int Count { get; set; }

		public int InitialCount { get; set; }

		public int Offset { get; set; }

		public ReadBufferState(byte[] buffer, int offset, int count, HttpStreamAsyncResult asyncResult)
		{
			Buffer = buffer;
			Offset = offset;
			Count = count;
			InitialCount = count;
			AsyncResult = asyncResult;
		}
	}
	internal class RequestStream : Stream
	{
		private byte[] _buffer;

		private bool _disposed;

		private int _length;

		private int _offset;

		private long _remainingBody;

		private Stream _stream;

		public override bool CanRead => true;

		public override bool CanSeek => false;

		public override bool CanWrite => false;

		public override long Length
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public override long Position
		{
			get
			{
				throw new NotSupportedException();
			}
			set
			{
				throw new NotSupportedException();
			}
		}

		internal RequestStream(Stream stream, byte[] buffer, int offset, int length)
			: this(stream, buffer, offset, length, -1L)
		{
		}

		internal RequestStream(Stream stream, byte[] buffer, int offset, int length, long contentlength)
		{
			_stream = stream;
			_buffer = buffer;
			_offset = offset;
			_length = length;
			_remainingBody = contentlength;
		}

		private int fillFromBuffer(byte[] buffer, int offset, int count)
		{
			if (buffer == null)
			{
				throw new ArgumentNullException("buffer");
			}
			if (offset < 0)
			{
				throw new ArgumentOutOfRangeException("offset", "Less than zero.");
			}
			if (count < 0)
			{
				throw new ArgumentOutOfRangeException("count", "Less than zero.");
			}
			int num = buffer.Length;
			if (offset > num)
			{
				throw new ArgumentException("'offset' is greater than 'buffer' size.");
			}
			if (offset > num - count)
			{
				throw new ArgumentException("Reading would overrun 'buffer'.");
			}
			if (_remainingBody == 0L)
			{
				return -1;
			}
			if (_length == 0)
			{
				return 0;
			}
			int num2 = ((_length < count) ? _length : count);
			if (_remainingBody > 0 && _remainingBody < num2)
			{
				num2 = (int)_remainingBody;
			}
			int num3 = _buffer.Length - _offset;
			if (num3 < num2)
			{
				num2 = num3;
			}
			if (num2 == 0)
			{
				return 0;
			}
			Buffer.BlockCopy(_buffer, _offset, buffer, offset, num2);
			_offset += num2;
			_length -= num2;
			if (_remainingBody > 0)
			{
				_remainingBody -= num2;
			}
			return num2;
		}

		public override IAsyncResult BeginRead(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
		{
			if (_disposed)
			{
				throw new ObjectDisposedException(GetType().ToString());
			}
			int num = fillFromBuffer(buffer, offset, count);
			if (num > 0 || num == -1)
			{
				HttpStreamAsyncResult httpStreamAsyncResult = new HttpStreamAsyncResult(callback, state);
				httpStreamAsyncResult.Buffer = buffer;
				httpStreamAsyncResult.Offset = offset;
				httpStreamAsyncResult.Count = count;
				httpStreamAsyncResult.SyncRead = num;
				httpStreamAsyncResult.Complete();
				return httpStreamAsyncResult;
			}
			if (_remainingBody >= 0 && _remainingBody < count)
			{
				count = (int)_remainingBody;
			}
			return _stream.BeginRead(buffer, offset, count, callback, state);
		}

		public override IAsyncResult BeginWrite(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
		{
			throw new NotSupportedException();
		}

		public override void Close()
		{
			_disposed = true;
		}

		public override int EndRead(IAsyncResult asyncResult)
		{
			if (_disposed)
			{
				throw new ObjectDisposedException(GetType().ToString());
			}
			if (asyncResult == null)
			{
				throw new ArgumentNullException("asyncResult");
			}
			if (asyncResult is HttpStreamAsyncResult)
			{
				HttpStreamAsyncResult httpStreamAsyncResult = (HttpStreamAsyncResult)asyncResult;
				if (!httpStreamAsyncResult.IsCompleted)
				{
					httpStreamAsyncResult.AsyncWaitHandle.WaitOne();
				}
				return httpStreamAsyncResult.SyncRead;
			}
			int num = _stream.EndRead(asyncResult);
			if (num > 0 && _remainingBody > 0)
			{
				_remainingBody -= num;
			}
			return num;
		}

		public override void EndWrite(IAsyncResult asyncResult)
		{
			throw new NotSupportedException();
		}

		public override void Flush()
		{
		}

		public override int Read(byte[] buffer, int offset, int count)
		{
			if (_disposed)
			{
				throw new ObjectDisposedException(GetType().ToString());
			}
			int num = fillFromBuffer(buffer, offset, count);
			if (num == -1)
			{
				return 0;
			}
			if (num > 0)
			{
				return num;
			}
			num = _stream.Read(buffer, offset, count);
			if (num > 0 && _remainingBody > 0)
			{
				_remainingBody -= num;
			}
			return num;
		}

		public override long Seek(long offset, SeekOrigin origin)
		{
			throw new NotSupportedException();
		}

		public override void SetLength(long value)
		{
			throw new NotSupportedException();
		}

		public override void Write(byte[] buffer, int offset, int count)
		{
			throw new NotSupportedException();
		}
	}
	internal class ResponseStream : Stream
	{
		private static byte[] _crlf = new byte[2] { 13, 10 };

		private bool _disposed;

		private bool _ignoreErrors;

		private HttpListenerResponse _response;

		private Stream _stream;

		private bool _trailerSent;

		public override bool CanRead => false;

		public override bool CanSeek => false;

		public override bool CanWrite => true;

		public override long Length
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public override long Position
		{
			get
			{
				throw new NotSupportedException();
			}
			set
			{
				throw new NotSupportedException();
			}
		}

		internal ResponseStream(Stream stream, HttpListenerResponse response, bool ignoreErrors)
		{
			_stream = stream;
			_response = response;
			_ignoreErrors = ignoreErrors;
		}

		private static byte[] getChunkSizeBytes(int size, bool final)
		{
			return Encoding.ASCII.GetBytes(string.Format("{0:x}\r\n{1}", size, final ? "\r\n" : ""));
		}

		private MemoryStream getHeaders(bool closing)
		{
			if (_response.HeadersSent)
			{
				return null;
			}
			MemoryStream memoryStream = new MemoryStream();
			_response.SendHeaders(closing, memoryStream);
			return memoryStream;
		}

		internal void WriteInternally(byte[] buffer, int offset, int count)
		{
			if (_ignoreErrors)
			{
				try
				{
					_stream.Write(buffer, offset, count);
					return;
				}
				catch
				{
					return;
				}
			}
			_stream.Write(buffer, offset, count);
		}

		public override IAsyncResult BeginRead(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
		{
			throw new NotSupportedException();
		}

		public override IAsyncResult BeginWrite(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
		{
			if (_disposed)
			{
				throw new ObjectDisposedException(GetType().ToString());
			}
			MemoryStream headers = getHeaders(closing: false);
			bool sendChunked = _response.SendChunked;
			byte[] array = null;
			if (headers != null)
			{
				using (headers)
				{
					long position = headers.Position;
					headers.Position = headers.Length;
					if (sendChunked)
					{
						array = getChunkSizeBytes(count, final: false);
						headers.Write(array, 0, array.Length);
					}
					headers.Write(buffer, offset, count);
					buffer = headers.GetBuffer();
					offset = (int)position;
					count = (int)(headers.Position - position);
				}
			}
			else if (sendChunked)
			{
				array = getChunkSizeBytes(count, final: false);
				WriteInternally(array, 0, array.Length);
			}
			return _stream.BeginWrite(buffer, offset, count, callback, state);
		}

		public override void Close()
		{
			if (_disposed)
			{
				return;
			}
			_disposed = true;
			MemoryStream headers = getHeaders(closing: true);
			bool sendChunked = _response.SendChunked;
			byte[] array = null;
			if (headers != null)
			{
				using (headers)
				{
					long position = headers.Position;
					if (sendChunked && !_trailerSent)
					{
						array = getChunkSizeBytes(0, final: true);
						headers.Position = headers.Length;
						headers.Write(array, 0, array.Length);
					}
					WriteInternally(headers.GetBuffer(), (int)position, (int)(headers.Length - position));
				}
				_trailerSent = true;
			}
			else if (sendChunked && !_trailerSent)
			{
				array = getChunkSizeBytes(0, final: true);
				WriteInternally(array, 0, array.Length);
				_trailerSent = true;
			}
			_response.Close();
		}

		public override int EndRead(IAsyncResult asyncResult)
		{
			throw new NotSupportedException();
		}

		public override void EndWrite(IAsyncResult asyncResult)
		{
			if (_disposed)
			{
				throw new ObjectDisposedException(GetType().ToString());
			}
			Action<IAsyncResult> action = delegate(IAsyncResult ares)
			{
				_stream.EndWrite(ares);
				if (_response.SendChunked)
				{
					_stream.Write(_crlf, 0, 2);
				}
			};
			if (_ignoreErrors)
			{
				try
				{
					action(asyncResult);
					return;
				}
				catch
				{
					return;
				}
			}
			action(asyncResult);
		}

		public override void Flush()
		{
		}

		public override int Read(byte[] buffer, int offset, int count)
		{
			throw new NotSupportedException();
		}

		public override long Seek(long offset, SeekOrigin origin)
		{
			throw new NotSupportedException();
		}

		public override void SetLength(long value)
		{
			throw new NotSupportedException();
		}

		public override void Write(byte[] buffer, int offset, int count)
		{
			if (_disposed)
			{
				throw new ObjectDisposedException(GetType().ToString());
			}
			MemoryStream headers = getHeaders(closing: false);
			bool sendChunked = _response.SendChunked;
			byte[] array = null;
			if (headers != null)
			{
				using (headers)
				{
					long position = headers.Position;
					headers.Position = headers.Length;
					if (sendChunked)
					{
						array = getChunkSizeBytes(count, final: false);
						headers.Write(array, 0, array.Length);
					}
					int num = Math.Min(count, 16384 - (int)headers.Position + (int)position);
					headers.Write(buffer, offset, num);
					count -= num;
					offset += num;
					WriteInternally(headers.GetBuffer(), (int)position, (int)(headers.Length - position));
				}
			}
			else if (sendChunked)
			{
				array = getChunkSizeBytes(count, final: false);
				WriteInternally(array, 0, array.Length);
			}
			if (count > 0)
			{
				WriteInternally(buffer, offset, count);
			}
			if (sendChunked)
			{
				WriteInternally(_crlf, 0, 2);
			}
		}
	}
	[Serializable]
	[ComVisible(true)]
	public class WebHeaderCollection : NameValueCollection, ISerializable
	{
		private static readonly Dictionary<string, HttpHeaderInfo> _headers;

		private bool _internallyCreated;

		private HttpHeaderType _state;

		public override string[] AllKeys => base.AllKeys;

		public override int Count => base.Count;

		public string this[HttpRequestHeader header]
		{
			get
			{
				return Get(Convert(header));
			}
			set
			{
				Add(header, value);
			}
		}

		public string this[HttpResponseHeader header]
		{
			get
			{
				return Get(Convert(header));
			}
			set
			{
				Add(header, value);
			}
		}

		public override KeysCollection Keys => base.Keys;

		static WebHeaderCollection()
		{
			_headers = new Dictionary<string, HttpHeaderInfo>(StringComparer.InvariantCultureIgnoreCase)
			{
				{
					"Accept",
					new HttpHeaderInfo
					{
						Name = "Accept",
						Type = (HttpHeaderType.Request | HttpHeaderType.Restricted | HttpHeaderType.MultiValue)
					}
				},
				{
					"AcceptCharset",
					new HttpHeaderInfo
					{
						Name = "Accept-Charset",
						Type = (HttpHeaderType.Request | HttpHeaderType.MultiValue)
					}
				},
				{
					"AcceptEncoding",
					new HttpHeaderInfo
					{
						Name = "Accept-Encoding",
						Type = (HttpHeaderType.Request | HttpHeaderType.MultiValue)
					}
				},
				{
					"AcceptLanguage",
					new HttpHeaderInfo
					{
						Name = "Accept-language",
						Type = (HttpHeaderType.Request | HttpHeaderType.MultiValue)
					}
				},
				{
					"AcceptRanges",
					new HttpHeaderInfo
					{
						Name = "Accept-Ranges",
						Type = (HttpHeaderType.Response | HttpHeaderType.MultiValue)
					}
				},
				{
					"Age",
					new HttpHeaderInfo
					{
						Name = "Age",
						Type = HttpHeaderType.Response
					}
				},
				{
					"Allow",
					new HttpHeaderInfo
					{
						Name = "Allow",
						Type = (HttpHeaderType.Request | HttpHeaderType.Response | HttpHeaderType.MultiValue)
					}
				},
				{
					"Authorization",
					new HttpHeaderInfo
					{
						Name = "Authorization",
						Type = (HttpHeaderType.Request | HttpHeaderType.MultiValue)
					}
				},
				{
					"CacheControl",
					new HttpHeaderInfo
					{
						Name = "Cache-Control",
						Type = (HttpHeaderType.Request | HttpHeaderType.Response | HttpHeaderType.MultiValue)
					}
				},
				{
					"Connection",
					new HttpHeaderInfo
					{
						Name = "Connection",
						Type = (HttpHeaderType.Request | HttpHeaderType.Response | HttpHeaderType.Restricted | HttpHeaderType.MultiValue)
					}
				},
				{
					"ContentEncoding",
					new HttpHeaderInfo
					{
						Name = "Content-Encoding",
						Type = (HttpHeaderType.Request | HttpHeaderType.Response | HttpHeaderType.MultiValue)
					}
				},
				{
					"ContentLanguage",
					new HttpHeaderInfo
					{
						Name = "Content-Language",
						Type = (HttpHeaderType.Request | HttpHeaderType.Response | HttpHeaderType.MultiValue)
					}
				},
				{
					"ContentLength",
					new HttpHeaderInfo
					{
						Name = "Content-Length",
						Type = (HttpHeaderType.Request | HttpHeaderType.Response | HttpHeaderType.Restricted)
					}
				},
				{
					"ContentLocation",
					new HttpHeaderInfo
					{
						Name = "Content-Location",
						Type = (HttpHeaderType.Request | HttpHeaderType.Response)
					}
				},
				{
					"ContentMd5",
					new HttpHeaderInfo
					{
						Name = "Content-MD5",
						Type = (HttpHeaderType.Request | HttpHeaderType.Response)
					}
				},
				{
					"ContentRange",
					new HttpHeaderInfo
					{
						Name = "Content-Range",
						Type = (HttpHeaderType.Request | HttpHeaderType.Response)
					}
				},
				{
					"ContentType",
					new HttpHeaderInfo
					{
						Name = "Content-Type",
						Type = (HttpHeaderType.Request | HttpHeaderType.Response | HttpHeaderType.Restricted)
					}
				},
				{
					"Cookie",
					new HttpHeaderInfo
					{
						Name = "Cookie",
						Type = HttpHeaderType.Request
					}
				},
				{
					"Cookie2",
					new HttpHeaderInfo
					{
						Name = "Cookie2",
						Type = HttpHeaderType.Request
					}
				},
				{
					"Date",
					new HttpHeaderInfo
					{
						Name = "Date",
						Type = (HttpHeaderType.Request | HttpHeaderType.Response | HttpHeaderType.Restricted)
					}
				},
				{
					"Expect",
					new HttpHeaderInfo
					{
						Name = "Expect",
						Type = (HttpHeaderType.Request | HttpHeaderType.Restricted | HttpHeaderType.MultiValue)
					}
				},
				{
					"Expires",
					new HttpHeaderInfo
					{
						Name = "Expires",
						Type = (HttpHeaderType.Request | HttpHeaderType.Response)
					}
				},
				{
					"ETag",
					new HttpHeaderInfo
					{
						Name = "ETag",
						Type = HttpHeaderType.Response
					}
				},
				{
					"From",
					new HttpHeaderInfo
					{
						Name = "From",
						Type = HttpHeaderType.Request
					}
				},
				{
					"Host",
					new HttpHeaderInfo
					{
						Name = "Host",
						Type = (HttpHeaderType.Request | HttpHeaderType.Restricted)
					}
				},
				{
					"IfMatch",
					new HttpHeaderInfo
					{
						Name = "If-Match",
						Type = (HttpHeaderType.Request | HttpHeaderType.MultiValue)
					}
				},
				{
					"IfModifiedSince",
					new HttpHeaderInfo
					{
						Name = "If-Modified-Since",
						Type = (HttpHeaderType.Request | HttpHeaderType.Restricted)
					}
				},
				{
					"IfNoneMatch",
					new HttpHeaderInfo
					{
						Name = "If-None-Match",
						Type = (HttpHeaderType.Request | HttpHeaderType.MultiValue)
					}
				},
				{
					"IfRange",
					new HttpHeaderInfo
					{
						Name = "If-Range",
						Type = HttpHeaderType.Request
					}
				},
				{
					"IfUnmodifiedSince",
					new HttpHeaderInfo
					{
						Name = "If-Unmodified-Since",
						Type = HttpHeaderType.Request
					}
				},
				{
					"KeepAlive",
					new HttpHeaderInfo
					{
						Name = "Keep-Alive",
						Type = (HttpHeaderType.Request | HttpHeaderType.Response | HttpHeaderType.MultiValue)
					}
				},
				{
					"LastModified",
					new HttpHeaderInfo
					{
						Name = "Last-Modified",
						Type = (HttpHeaderType.Request | HttpHeaderType.Response)
					}
				},
				{
					"Location",
					new HttpHeaderInfo
					{
						Name = "Location",
						Type = HttpHeaderType.Response
					}
				},
				{
					"MaxForwards",
					new HttpHeaderInfo
					{
						Name = "Max-Forwards",
						Type = HttpHeaderType.Request
					}
				},
				{
					"Pragma",
					new HttpHeaderInfo
					{
						Name = "Pragma",
						Type = (HttpHeaderType.Request | HttpHeaderType.Response)
					}
				},
				{
					"ProxyConnection",
					new HttpHeaderInfo
					{
						Name = "Proxy-Connection",
						Type = (HttpHeaderType.Request | HttpHeaderType.Response | HttpHeaderType.Restricted)
					}
				},
				{
					"ProxyAuthenticate",
					new HttpHeaderInfo
					{
						Name = "Proxy-Authenticate",
						Type = (HttpHeaderType.Response | HttpHeaderType.MultiValue)
					}
				},
				{
					"ProxyAuthorization",
					new HttpHeaderInfo
					{
						Name = "Proxy-Authorization",
						Type = HttpHeaderType.Request
					}
				},
				{
					"Public",
					new HttpHeaderInfo
					{
						Name = "Public",
						Type = (HttpHeaderType.Response | HttpHeaderType.MultiValue)
					}
				},
				{
					"Range",
					new HttpHeaderInfo
					{
						Name = "Range",
						Type = (HttpHeaderType.Request | HttpHeaderType.Restricted | HttpHeaderType.MultiValue)
					}
				},
				{
					"Referer",
					new HttpHeaderInfo
					{
						Name = "Referer",
						Type = (HttpHeaderType.Request | HttpHeaderType.Restricted)
					}
				},
				{
					"RetryAfter",
					new HttpHeaderInfo
					{
						Name = "Retry-After",
						Type = HttpHeaderType.Response
					}
				},
				{
					"SecWebSocketAccept",
					new HttpHeaderInfo
					{
						Name = "Sec-WebSocket-Accept",
						Type = (HttpHeaderType.Response | HttpHeaderType.Restricted)
					}
				},
				{
					"SecWebSocketExtensions",
					new HttpHeaderInfo
					{
						Name = "Sec-WebSocket-Extensions",
						Type = (HttpHeaderType.Request | HttpHeaderType.Response | HttpHeaderType.Restricted | HttpHeaderType.MultiValueInRequest)
					}
				},
				{
					"SecWebSocketKey",
					new HttpHeaderInfo
					{
						Name = "Sec-WebSocket-Key",
						Type = (HttpHeaderType.Request | HttpHeaderType.Restricted)
					}
				},
				{
					"SecWebSocketProtocol",
					new HttpHeaderInfo
					{
						Name = "Sec-WebSocket-Protocol",
						Type = (HttpHeaderType.Request | HttpHeaderType.Response | HttpHeaderType.MultiValueInRequest)
					}
				},
				{
					"SecWebSocketVersion",
					new HttpHeaderInfo
					{
						Name = "Sec-WebSocket-Version",
						Type = (HttpHeaderType.Request | HttpHeaderType.Response | HttpHeaderType.Restricted | HttpHeaderType.MultiValueInResponse)
					}
				},
				{
					"Server",
					new HttpHeaderInfo
					{
						Name = "Server",
						Type = HttpHeaderType.Response
					}
				},
				{
					"SetCookie",
					new HttpHeaderInfo
					{
						Name = "Set-Cookie",
						Type = (HttpHeaderType.Response | HttpHeaderType.MultiValue)
					}
				},
				{
					"SetCookie2",
					new HttpHeaderInfo
					{
						Name = "Set-Cookie2",
						Type = (HttpHeaderType.Response | HttpHeaderType.MultiValue)
					}
				},
				{
					"Te",
					new HttpHeaderInfo
					{
						Name = "TE",
						Type = HttpHeaderType.Request
					}
				},
				{
					"Trailer",
					new HttpHeaderInfo
					{
						Name = "Trailer",
						Type = (HttpHeaderType.Request | HttpHeaderType.Response)
					}
				},
				{
					"TransferEncoding",
					new HttpHeaderInfo
					{
						Name = "Transfer-Encoding",
						Type = (HttpHeaderType.Request | HttpHeaderType.Response | HttpHeaderType.Restricted | HttpHeaderType.MultiValue)
					}
				},
				{
					"Translate",
					new HttpHeaderInfo
					{
						Name = "Translate",
						Type = HttpHeaderType.Request
					}
				},
				{
					"Upgrade",
					new HttpHeaderInfo
					{
						Name = "Upgrade",
						Type = (HttpHeaderType.Request | HttpHeaderType.Response | HttpHeaderType.MultiValue)
					}
				},
				{
					"UserAgent",
					new HttpHeaderInfo
					{
						Name = "User-Agent",
						Type = (HttpHeaderType.Request | HttpHeaderType.Restricted)
					}
				},
				{
					"Vary",
					new HttpHeaderInfo
					{
						Name = "Vary",
						Type = (HttpHeaderType.Response | HttpHeaderType.MultiValue)
					}
				},
				{
					"Via",
					new HttpHeaderInfo
					{
						Name = "Via",
						Type = (HttpHeaderType.Request | HttpHeaderType.Response | HttpHeaderType.MultiValue)
					}
				},
				{
					"Warning",
					new HttpHeaderInfo
					{
						Name = "Warning",
						Type = (HttpHeaderType.Request | HttpHeaderType.Response | HttpHeaderType.MultiValue)
					}
				},
				{
					"WwwAuthenticate",
					new HttpHeaderInfo
					{
						Name = "WWW-Authenticate",
						Type = (HttpHeaderType.Response | HttpHeaderType.Restricted | HttpHeaderType.MultiValue)
					}
				}
			};
		}

		internal WebHeaderCollection(bool internallyCreated)
		{
			_internallyCreated = internallyCreated;
			_state = HttpHeaderType.Unspecified;
		}

		protected WebHeaderCollection(SerializationInfo serializationInfo, StreamingContext streamingContext)
		{
			if (serializationInfo == null)
			{
				throw new ArgumentNullException("serializationInfo");
			}
			try
			{
				_internallyCreated = serializationInfo.GetBoolean("InternallyCreated");
				_state = (HttpHeaderType)serializationInfo.GetInt32("State");
				int @int = serializationInfo.GetInt32("Count");
				for (int i = 0; i < @int; i++)
				{
					base.Add(serializationInfo.GetString(i.ToString()), serializationInfo.GetString((@int + i).ToString()));
				}
			}
			catch (SerializationException ex)
			{
				throw new ArgumentException(ex.Message, "serializationInfo", ex);
			}
		}

		public WebHeaderCollection()
		{
			_internallyCreated = false;
			_state = HttpHeaderType.Unspecified;
		}

		private void add(string name, string value, bool ignoreRestricted)
		{
			Action<string, string> action = ((!ignoreRestricted) ? new Action<string, string>(addWithoutCheckingName) : new Action<string, string>(addWithoutCheckingNameAndRestricted));
			doWithCheckingState(action, checkName(name), value, setState: true);
		}

		private void addWithoutCheckingName(string name, string value)
		{
			doWithoutCheckingName(base.Add, name, value);
		}

		private void addWithoutCheckingNameAndRestricted(string name, string value)
		{
			base.Add(name, checkValue(value));
		}

		private static int checkColonSeparated(string header)
		{
			int num = header.IndexOf(':');
			if (num == -1)
			{
				throw new ArgumentException("No colon found.", "header");
			}
			return num;
		}

		private static HttpHeaderType checkHeaderType(string name)
		{
			HttpHeaderInfo headerInfo = getHeaderInfo(name);
			if (headerInfo != null)
			{
				if (!headerInfo.IsRequest || headerInfo.IsResponse)
				{
					if (headerInfo.IsRequest || !headerInfo.IsResponse)
					{
						return HttpHeaderType.Unspecified;
					}
					return HttpHeaderType.Response;
				}
				return HttpHeaderType.Request;
			}
			return HttpHeaderType.Unspecified;
		}

		private static string checkName(string name)
		{
			if (name == null || name.Length == 0)
			{
				throw new ArgumentNullException("name");
			}
			name = name.Trim();
			if (!IsHeaderName(name))
			{
				throw new ArgumentException("Contains invalid characters.", "name");
			}
			return name;
		}

		private void checkRestricted(string name)
		{
			if (!_internallyCreated && isRestricted(name, response: true))
			{
				throw new ArgumentException("This header must be modified with the appropiate property.");
			}
		}

		private void checkState(bool response)
		{
			if (_state != 0)
			{
				if (response && _state == HttpHeaderType.Request)
				{
					throw new InvalidOperationException("This collection has already been used to store the request headers.");
				}
				if (!response && _state == HttpHeaderType.Response)
				{
					throw new InvalidOperationException("This collection has already been used to store the response headers.");
				}
			}
		}

		private static string checkValue(string value)
		{
			if (value == null || value.Length == 0)
			{
				return string.Empty;
			}
			value = value.Trim();
			if (value.Length > 65535)
			{
				throw new ArgumentOutOfRangeException("value", "Greater than 65,535 characters.");
			}
			if (!IsHeaderValue(value))
			{
				throw new ArgumentException("Contains invalid characters.", "value");
			}
			return value;
		}

		private static string convert(string key)
		{
			if (!_headers.TryGetValue(key, out var value))
			{
				return string.Empty;
			}
			return value.Name;
		}

		private void doWithCheckingState(Action<string, string> action, string name, string value, bool setState)
		{
			switch (checkHeaderType(name))
			{
			case HttpHeaderType.Request:
				doWithCheckingState(action, name, value, response: false, setState);
				break;
			case HttpHeaderType.Response:
				doWithCheckingState(action, name, value, response: true, setState);
				break;
			default:
				action(name, value);
				break;
			}
		}

		private void doWithCheckingState(Action<string, string> action, string name, string value, bool response, bool setState)
		{
			checkState(response);
			action(name, value);
			if (setState && _state == HttpHeaderType.Unspecified)
			{
				_state = ((!response) ? HttpHeaderType.Request : HttpHeaderType.Response);
			}
		}

		private void doWithoutCheckingName(Action<string, string> action, string name, string value)
		{
			checkRestricted(name);
			action(name, checkValue(value));
		}

		private static HttpHeaderInfo getHeaderInfo(string name)
		{
			foreach (HttpHeaderInfo value in _headers.Values)
			{
				if (value.Name.Equals(name, StringComparison.InvariantCultureIgnoreCase))
				{
					return value;
				}
			}
			return null;
		}

		private static bool isRestricted(string name, bool response)
		{
			return getHeaderInfo(name)?.IsRestricted(response) ?? false;
		}

		private void removeWithoutCheckingName(string name, string unuse)
		{
			checkRestricted(name);
			base.Remove(name);
		}

		private void setWithoutCheckingName(string name, string value)
		{
			doWithoutCheckingName(base.Set, name, value);
		}

		internal static string Convert(HttpRequestHeader header)
		{
			return convert(header.ToString());
		}

		internal static string Convert(HttpResponseHeader header)
		{
			return convert(header.ToString());
		}

		internal static bool IsHeaderName(string name)
		{
			if (name != null && name.Length > 0)
			{
				return name.IsToken();
			}
			return false;
		}

		internal static bool IsHeaderValue(string value)
		{
			return value.IsText();
		}

		internal static bool IsMultiValue(string headerName, bool response)
		{
			if (headerName == null || headerName.Length == 0)
			{
				return false;
			}
			return getHeaderInfo(headerName)?.IsMultiValue(response) ?? false;
		}

		internal void RemoveInternally(string name)
		{
			base.Remove(name);
		}

		internal void SetInternally(string header, bool response)
		{
			int num = checkColonSeparated(header);
			SetInternally(header.Substring(0, num), header.Substring(num + 1), response);
		}

		internal void SetInternally(string name, string value, bool response)
		{
			value = checkValue(value);
			if (IsMultiValue(name, response))
			{
				base.Add(name, value);
			}
			else
			{
				base.Set(name, value);
			}
		}

		internal string ToStringMultiValue(bool response)
		{
			StringBuilder buff = new StringBuilder();
			Count.Times(delegate(int i)
			{
				string key = GetKey(i);
				if (IsMultiValue(key, response))
				{
					string[] values = GetValues(i);
					foreach (string arg in values)
					{
						buff.AppendFormat("{0}: {1}\r\n", key, arg);
					}
				}
				else
				{
					buff.AppendFormat("{0}: {1}\r\n", key, Get(i));
				}
			});
			return buff.Append("\r\n").ToString();
		}

		protected void AddWithoutValidate(string headerName, string headerValue)
		{
			add(headerName, headerValue, ignoreRestricted: true);
		}

		public void Add(string header)
		{
			if (header.IsNullOrEmpty())
			{
				throw new ArgumentNullException("header");
			}
			int num = checkColonSeparated(header);
			add(header.Substring(0, num), header.Substring(num + 1), ignoreRestricted: false);
		}

		public void Add(HttpRequestHeader header, string value)
		{
			doWithCheckingState(addWithoutCheckingName, Convert(header), value, response: false, setState: true);
		}

		public void Add(HttpResponseHeader header, string value)
		{
			doWithCheckingState(addWithoutCheckingName, Convert(header), value, response: true, setState: true);
		}

		public override void Add(string name, string value)
		{
			add(name, value, ignoreRestricted: false);
		}

		public override void Clear()
		{
			base.Clear();
			_state = HttpHeaderType.Unspecified;
		}

		public override string Get(int index)
		{
			return base.Get(index);
		}

		public override string Get(string name)
		{
			return base.Get(name);
		}

		public override IEnumerator GetEnumerator()
		{
			return base.GetEnumerator();
		}

		public override string GetKey(int index)
		{
			return base.GetKey(index);
		}

		public override string[] GetValues(int index)
		{
			string[] values = base.GetValues(index);
			if (values == null || values.Length == 0)
			{
				return null;
			}
			return values;
		}

		public override string[] GetValues(string header)
		{
			string[] values = base.GetValues(header);
			if (values == null || values.Length == 0)
			{
				return null;
			}
			return values;
		}

		public override void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
		{
			if (serializationInfo == null)
			{
				throw new ArgumentNullException("serializationInfo");
			}
			serializationInfo.AddValue("InternallyCreated", _internallyCreated);
			serializationInfo.AddValue("State", (int)_state);
			int count = Count;
			serializationInfo.AddValue("Count", count);
			count.Times(delegate(int i)
			{
				serializationInfo.AddValue(i.ToString(), GetKey(i));
				serializationInfo.AddValue((count + i).ToString(), Get(i));
			});
		}

		public static bool IsRestricted(string headerName)
		{
			return isRestricted(checkName(headerName), response: false);
		}

		public static bool IsRestricted(string headerName, bool response)
		{
			return isRestricted(checkName(headerName), response);
		}

		public override void OnDeserialization(object sender)
		{
		}

		public void Remove(HttpRequestHeader header)
		{
			doWithCheckingState(removeWithoutCheckingName, Convert(header), null, response: false, setState: false);
		}

		public void Remove(HttpResponseHeader header)
		{
			doWithCheckingState(removeWithoutCheckingName, Convert(header), null, response: true, setState: false);
		}

		public override void Remove(string name)
		{
			doWithCheckingState(removeWithoutCheckingName, checkName(name), null, setState: false);
		}

		public void Set(HttpRequestHeader header, string value)
		{
			doWithCheckingState(setWithoutCheckingName, Convert(header), value, response: false, setState: true);
		}

		public void Set(HttpResponseHeader header, string value)
		{
			doWithCheckingState(setWithoutCheckingName, Convert(header), value, response: true, setState: true);
		}

		public override void Set(string name, string value)
		{
			doWithCheckingState(setWithoutCheckingName, checkName(name), value, setState: true);
		}

		public byte[] ToByteArray()
		{
			return Encoding.UTF8.GetBytes(ToString());
		}

		public override string ToString()
		{
			StringBuilder buff = new StringBuilder();
			Count.Times(delegate(int i)
			{
				buff.AppendFormat("{0}: {1}\r\n", GetKey(i), Get(i));
			});
			return buff.Append("\r\n").ToString();
		}

		void ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
		{
			GetObjectData(serializationInfo, streamingContext);
		}
	}
}
namespace WebSocketSharp.Net.WebSockets
{
	public class HttpListenerWebSocketContext : WebSocketContext
	{
		private HttpListenerContext _context;

		private WebSocket _websocket;

		internal WebSocketStream Stream => _context.Connection.GetWebSocketStream();

		public override CookieCollection CookieCollection => _context.Request.Cookies;

		public override NameValueCollection Headers => _context.Request.Headers;

		public override string Host => _context.Request.Headers["Host"];

		public override bool IsAuthenticated => _context.Request.IsAuthenticated;

		public override bool IsLocal => _context.Request.IsLocal;

		public override bool IsSecureConnection => _context.Connection.IsSecure;

		public override bool IsWebSocketRequest => _context.Request.IsWebSocketRequest;

		public override string Origin => _context.Request.Headers["Origin"];

		public override NameValueCollection QueryString => _context.Request.QueryString;

		public override Uri RequestUri => _context.Request.Url;

		public override string SecWebSocketKey => _context.Request.Headers["Sec-WebSocket-Key"];

		public override IEnumerable<string> SecWebSocketProtocols
		{
			get
			{
				string text = _context.Request.Headers["Sec-WebSocket-Protocol"];
				if (text != null)
				{
					string[] array = text.Split(',');
					foreach (string text2 in array)
					{
						yield return text2.Trim();
					}
				}
			}
		}

		public override string SecWebSocketVersion => _context.Request.Headers["Sec-WebSocket-Version"];

		public override IPEndPoint ServerEndPoint => _context.Connection.LocalEndPoint;

		public override IPrincipal User => _context.User;

		public override IPEndPoint UserEndPoint => _context.Connection.RemoteEndPoint;

		public override WebSocket WebSocket => _websocket;

		internal HttpListenerWebSocketContext(HttpListenerContext context, string protocol, Logger logger)
		{
			_context = context;
			_websocket = new WebSocket(this, protocol, logger);
		}

		internal void Close()
		{
			_context.Connection.Close(force: true);
		}

		internal void Close(HttpStatusCode code)
		{
			_context.Response.Close(code);
		}

		public override string ToString()
		{
			return _context.Request.ToString();
		}
	}
	public class TcpListenerWebSocketContext : WebSocketContext
	{
		private TcpClient _client;

		private CookieCollection _cookies;

		private NameValueCollection _queryString;

		private HandshakeRequest _request;

		private bool _secure;

		private WebSocketStream _stream;

		private Uri _uri;

		private IPrincipal _user;

		private WebSocket _websocket;

		internal WebSocketStream Stream => _stream;

		public override CookieCollection CookieCollection => _cookies ?? (_cookies = _request.Cookies);

		public override NameValueCollection Headers => _request.Headers;

		public override string Host => _request.Headers["Host"];

		public override bool IsAuthenticated
		{
			get
			{
				if (_user != null)
				{
					return _user.Identity.IsAuthenticated;
				}
				return false;
			}
		}

		public override bool IsLocal => UserEndPoint.Address.IsLocal();

		public override bool IsSecureConnection => _secure;

		public override bool IsWebSocketRequest => _request.IsWebSocketRequest;

		public override string Origin => _request.Headers["Origin"];

		public override NameValueCollection QueryString => _queryString ?? (_queryString = HttpUtility.ParseQueryStringInternally((_uri != null) ? _uri.Query : null, Encoding.UTF8));

		public override Uri RequestUri => _uri;

		public override string SecWebSocketKey => _request.Headers["Sec-WebSocket-Key"];

		public override IEnumerable<string> SecWebSocketProtocols
		{
			get
			{
				string text = _request.Headers["Sec-WebSocket-Protocol"];
				if (text != null)
				{
					string[] array = text.Split(',');
					foreach (string text2 in array)
					{
						yield return text2.Trim();
					}
				}
			}
		}

		public override string SecWebSocketVersion => _request.Headers["Sec-WebSocket-Version"];

		public override IPEndPoint ServerEndPoint => (IPEndPoint)_client.Client.LocalEndPoint;

		public override IPrincipal User => _user;

		public override IPEndPoint UserEndPoint => (IPEndPoint)_client.Client.RemoteEndPoint;

		public override WebSocket WebSocket => _websocket;

		internal TcpListenerWebSocketContext(TcpClient client, string protocol, bool secure, X509Certificate cert, Logger logger)
		{
			_client = client;
			_secure = secure;
			_stream = WebSocketStream.CreateServerStream(client, secure, cert);
			_request = _stream.ReadHandshake(HandshakeRequest.Parse, 90000);
			_uri = HttpUtility.CreateRequestUrl(_request.RequestUri, _request.Headers["Host"], _request.IsWebSocketRequest, secure);
			_websocket = new WebSocket(this, protocol, logger);
		}

		internal void Close()
		{
			_stream.Close();
			_client.Close();
		}

		internal void Close(HttpStatusCode code)
		{
			_websocket.Close(HandshakeResponse.CreateCloseResponse(code));
		}

		internal void SendAuthChallenge(string challenge)
		{
			HandshakeResponse handshakeResponse = new HandshakeResponse(HttpStatusCode.Unauthorized);
			handshakeResponse.Headers["WWW-Authenticate"] = challenge;
			_stream.WriteHandshake(handshakeResponse);
			_request = _stream.ReadHandshake(HandshakeRequest.Parse, 15000);
		}

		internal void SetUser(AuthenticationSchemes scheme, string realm, Func<IIdentity, NetworkCredential> credentialsFinder)
		{
			AuthenticationResponse authResponse = _request.AuthResponse;
			if (authResponse == null)
			{
				return;
			}
			IIdentity identity = authResponse.ToIdentity();
			if (identity == null)
			{
				return;
			}
			NetworkCredential networkCredential = null;
			try
			{
				networkCredential = credentialsFinder(identity);
			}
			catch
			{
			}
			if (networkCredential != null)
			{
				bool num;
				switch (scheme)
				{
				case AuthenticationSchemes.Digest:
					num = ((HttpDigestIdentity)identity).IsValid(networkCredential.Password, realm, _request.HttpMethod, null);
					break;
				case AuthenticationSchemes.Basic:
					num = ((HttpBasicIdentity)identity).Password == networkCredential.Password;
					break;
				default:
					return;
				}
				if (num)
				{
					_user = new GenericPrincipal(identity, networkCredential.Roles);
				}
			}
		}

		public override string ToString()
		{
			return _request.ToString();
		}
	}
	public abstract class WebSocketContext
	{
		public abstract CookieCollection CookieCollection { get; }

		public abstract NameValueCollection Headers { get; }

		public abstract string Host { get; }

		public abstract bool IsAuthenticated { get; }

		public abstract bool IsLocal { get; }

		public abstract bool IsSecureConnection { get; }

		public abstract bool IsWebSocketRequest { get; }

		public abstract string Origin { get; }

		public abstract NameValueCollection QueryString { get; }

		public abstract Uri RequestUri { get; }

		public abstract string SecWebSocketKey { get; }

		public abstract IEnumerable<string> SecWebSocketProtocols { get; }

		public abstract string SecWebSocketVersion { get; }

		public abstract IPEndPoint ServerEndPoint { get; }

		public abstract IPrincipal User { get; }

		public abstract IPEndPoint UserEndPoint { get; }

		public abstract WebSocket WebSocket { get; }
	}
}
namespace WebSocketSharp.Net.Security
{
	internal class SslStream : System.Net.Security.SslStream
	{
		public bool DataAvailable => ((NetworkStream)base.InnerStream).DataAvailable;

		public SslStream(NetworkStream innerStream)
			: base(innerStream)
		{
		}

		public SslStream(NetworkStream innerStream, bool leaveInnerStreamOpen)
			: base(innerStream, leaveInnerStreamOpen)
		{
		}

		public SslStream(NetworkStream innerStream, bool leaveInnerStreamOpen, RemoteCertificateValidationCallback userCertificateValidationCallback)
			: base(innerStream, leaveInnerStreamOpen, userCertificateValidationCallback)
		{
		}

		public SslStream(NetworkStream innerStream, bool leaveInnerStreamOpen, RemoteCertificateValidationCallback userCertificateValidationCallback, LocalCertificateSelectionCallback userCertificateSelectionCallback)
			: base(innerStream, leaveInnerStreamOpen, userCertificateValidationCallback, userCertificateSelectionCallback)
		{
		}
	}
}
namespace SocketIO
{
	public class Ack
	{
		public int packetId;

		public DateTime time;

		private Action<JSONObject> action;

		public Ack(int packetId, Action<JSONObject> action)
		{
			this.packetId = packetId;
			time = DateTime.Now;
			this.action = action;
		}

		public void Invoke(JSONObject ev)
		{
			action(ev);
		}

		public override string ToString()
		{
			return $"[Ack: packetId={packetId}, time={time}, action={action}]";
		}
	}
	public class Decoder
	{
		public Packet Decode(MessageEventArgs e)
		{
			try
			{
				string data = e.Data;
				Packet packet = new Packet();
				int num = 0;
				if ((packet.enginePacketType = (EnginePacketType)int.Parse(data.Substring(num, 1))) == EnginePacketType.MESSAGE)
				{
					int socketPacketType = int.Parse(data.Substring(++num, 1));
					packet.socketPacketType = (SocketPacketType)socketPacketType;
				}
				if (data.Length <= 2)
				{
					return packet;
				}
				if ('/' == data[num + 1])
				{
					StringBuilder stringBuilder = new StringBuilder();
					while (num < data.Length - 1 && data[++num] != ',')
					{
						stringBuilder.Append(data[num]);
					}
					packet.nsp = stringBuilder.ToString();
				}
				else
				{
					packet.nsp = "/";
				}
				char c = data[num + 1];
				if (c != ' ' && char.IsNumber(c))
				{
					StringBuilder stringBuilder2 = new StringBuilder();
					while (num < data.Length - 1)
					{
						char c2 = data[++num];
						if (char.IsNumber(c2))
						{
							stringBuilder2.Append(c2);
							continue;
						}
						num--;
						break;
					}
					packet.id = int.Parse(stringBuilder2.ToString());
				}
				if (++num < data.Length - 1)
				{
					try
					{
						packet.json = new JSONObject(data.Substring(num));
					}
					catch (Exception exception)
					{
						UnityEngine.Debug.LogException(exception);
					}
				}
				return packet;
			}
			catch (Exception innerException)
			{
				throw new SocketIOException("Packet decoding failed: " + e.Data, innerException);
			}
		}
	}
	public class Encoder
	{
		public string Encode(Packet packet)
		{
			try
			{
				StringBuilder stringBuilder = new StringBuilder();
				stringBuilder.Append((int)packet.enginePacketType);
				if (!packet.enginePacketType.Equals(EnginePacketType.MESSAGE))
				{
					return stringBuilder.ToString();
				}
				stringBuilder.Append((int)packet.socketPacketType);
				if (packet.socketPacketType == SocketPacketType.BINARY_EVENT || packet.socketPacketType == SocketPacketType.BINARY_ACK)
				{
					stringBuilder.Append(packet.attachments);
					stringBuilder.Append('-');
				}
				if (!string.IsNullOrEmpty(packet.nsp) && !packet.nsp.Equals("/"))
				{
					stringBuilder.Append(packet.nsp);
					stringBuilder.Append(',');
				}
				if (packet.id > -1)
				{
					stringBuilder.Append(packet.id);
				}
				if (packet.json != null && !packet.json.ToString().Equals("null"))
				{
					stringBuilder.Append(packet.json.ToString());
				}
				return stringBuilder.ToString();
			}
			catch (Exception innerException)
			{
				throw new SocketIOException("Packet encoding failed: " + packet, innerException);
			}
		}
	}
	public enum EnginePacketType
	{
		UNKNOWN = -1,
		OPEN,
		CLOSE,
		PING,
		PONG,
		MESSAGE,
		UPGRADE,
		NOOP
	}
	public class Packet
	{
		public EnginePacketType enginePacketType;

		public SocketPacketType socketPacketType;

		public int attachments;

		public string nsp;

		public int id;

		public JSONObject json;

		public Packet()
			: this(EnginePacketType.UNKNOWN, SocketPacketType.UNKNOWN, -1, "/", -1, null)
		{
		}

		public Packet(EnginePacketType enginePacketType)
			: this(enginePacketType, SocketPacketType.UNKNOWN, -1, "/", -1, null)
		{
		}

		public Packet(EnginePacketType enginePacketType, SocketPacketType socketPacketType, int attachments, string nsp, int id, JSONObject json)
		{
			this.enginePacketType = enginePacketType;
			this.socketPacketType = socketPacketType;
			this.attachments = attachments;
			this.nsp = nsp;
			this.id = id;
			this.json = json;
		}

		public override string ToString()
		{
			return $"[Packet: enginePacketType={enginePacketType}, socketPacketType={socketPacketType}, attachments={attachments}, nsp={nsp}, id={id}, json={json}]";
		}
	}
	public class Parser
	{
		public SocketIOEvent Parse(JSONObject json)
		{
			if (json.Count < 1 || json.Count > 2)
			{
				throw new SocketIOException("Invalid number of parameters received: " + json.Count);
			}
			if (json[0].type != JSONObject.Type.STRING)
			{
				throw new SocketIOException("Invalid parameter type. " + json[0].type.ToString() + " received while expecting " + JSONObject.Type.STRING);
			}
			if (json.Count == 1)
			{
				return new SocketIOEvent(json[0].str);
			}
			if (json[1].type != JSONObject.Type.OBJECT)
			{
				throw new SocketIOException("Invalid argument type. " + json[1].type.ToString() + " received while expecting " + JSONObject.Type.OBJECT);
			}
			return new SocketIOEvent(json[0].str, json[1]);
		}
	}
	public class SocketIOComponent : MonoBehaviour
	{
		public string url = "ws://127.0.0.1:4567/socket.io/?EIO=4&transport=websocket";

		public bool autoConnect = true;

		public int reconnectDelay = 5;

		public float ackExpirationTime = 1800f;

		public float pingInterval = 25f;

		public float pingTimeout = 60f;

		private volatile bool connected;

		private volatile bool thPinging;

		private volatile bool thPong;

		private volatile bool wsConnected;

		private Thread socketThread;

		private Thread pingThread;

		private WebSocket ws;

		private Encoder encoder;

		private Decoder decoder;

		private Parser parser;

		private Dictionary<string, List<Action<SocketIOEvent>>> handlers;

		private List<Ack> ackList;

		private int packetId;

		private object eventQueueLock;

		private Queue<SocketIOEvent> eventQueue;

		private object ackQueueLock;

		private Queue<Packet> ackQueue;

		public WebSocket socket => ws;

		public string sid { get; set; }

		public bool IsConnected => connected;

		public void Awake()
		{
			encoder = new Encoder();
			decoder = new Decoder();
			parser = new Parser();
			handlers = new Dictionary<string, List<Action<SocketIOEvent>>>();
			ackList = new List<Ack>();
			sid = null;
			packetId = 0;
			ws = new WebSocket(url);
			ws.OnOpen += OnOpen;
			ws.OnMessage += OnMessage;
			ws.OnError += OnError;
			ws.OnClose += OnClose;
			wsConnected = false;
			eventQueueLock = new object();
			eventQueue = new Queue<SocketIOEvent>();
			ackQueueLock = new object();
			ackQueue = new Queue<Packet>();
			connected = false;
		}

		public void Start()
		{
			if (autoConnect)
			{
				Connect();
			}
		}

		public void Update()
		{
			lock (eventQueueLock)
			{
				while (eventQueue.Count > 0)
				{
					EmitEvent(eventQueue.Dequeue());
				}
			}
			lock (ackQueueLock)
			{
				while (ackQueue.Count > 0)
				{
					InvokeAck(ackQueue.Dequeue());
				}
			}
			if (wsConnected != ws.IsConnected)
			{
				wsConnected = ws.IsConnected;
				if (wsConnected)
				{
					EmitEvent("connect");
				}
				else
				{
					EmitEvent("disconnect");
				}
			}
			if (ackList.Count != 0 && !(DateTime.Now.Subtract(ackList[0].time).TotalSeconds < (double)ackExpirationTime))
			{
				ackList.RemoveAt(0);
			}
		}

		public void OnDestroy()
		{
			if (socketThread != null)
			{
				socketThread.Abort();
			}
			if (pingThread != null)
			{
				pingThread.Abort();
			}
		}

		public void OnApplicationQuit()
		{
			Close();
		}

		public void Connect()
		{
			connected = true;
			socketThread = new Thread(RunSocketThread);
			socketThread.Start(ws);
			pingThread = new Thread(RunPingThread);
			pingThread.Start(ws);
		}

		public void Close()
		{
			EmitClose();
			connected = false;
		}

		public void On(string ev, Action<SocketIOEvent> callback)
		{
			if (!handlers.ContainsKey(ev))
			{
				handlers[ev] = new List<Action<SocketIOEvent>>();
			}
			handlers[ev].Add(callback);
		}

		public void Off(string ev, Action<SocketIOEvent> callback)
		{
			if (!handlers.ContainsKey(ev))
			{
				return;
			}
			List<Action<SocketIOEvent>> list = handlers[ev];
			if (list.Contains(callback))
			{
				list.Remove(callback);
				if (list.Count == 0)
				{
					handlers.Remove(ev);
				}
			}
		}

		public void Emit(string ev)
		{
			EmitMessage(-1, $"[\"{ev}\"]");
		}

		public void Emit(string ev, Action<JSONObject> action)
		{
			EmitMessage(++packetId, $"[\"{ev}\"]");
			ackList.Add(new Ack(packetId, action));
		}

		public void Emit(string ev, JSONObject data)
		{
			EmitMessage(-1, $"[\"{ev}\",{data}]");
		}

		public void Emit(string ev, JSONObject data, Action<JSONObject> action)
		{
			EmitMessage(++packetId, $"[\"{ev}\",{data}]");
			ackList.Add(new Ack(packetId, action));
		}

		private void RunSocketThread(object obj)
		{
			WebSocket webSocket = (WebSocket)obj;
			while (connected)
			{
				if (webSocket.IsConnected)
				{
					Thread.Sleep(reconnectDelay);
				}
				else
				{
					webSocket.Connect();
				}
			}
			webSocket.Close();
		}

		private void RunPingThread(object obj)
		{
			WebSocket webSocket = (WebSocket)obj;
			int num = Mathf.FloorToInt(pingTimeout * 1000f);
			int millisecondsTimeout = Mathf.FloorToInt(pingInterval * 1000f);
			while (connected)
			{
				if (!wsConnected)
				{
					Thread.Sleep(reconnectDelay);
					continue;
				}
				thPinging = true;
				thPong = false;
				EmitPacket(new Packet(EnginePacketType.PING));
				DateTime now = DateTime.Now;
				while (webSocket.IsConnected && thPinging && DateTime.Now.Subtract(now).TotalSeconds < (double)num)
				{
					Thread.Sleep(200);
				}
				if (!thPong)
				{
					webSocket.Close();
				}
				Thread.Sleep(millisecondsTimeout);
			}
		}

		private void EmitMessage(int id, string raw)
		{
			EmitPacket(new Packet(EnginePacketType.MESSAGE, SocketPacketType.EVENT, 0, "/", id, new JSONObject(raw)));
		}

		private void EmitClose()
		{
			EmitPacket(new Packet(EnginePacketType.MESSAGE, SocketPacketType.DISCONNECT, 0, "/", -1, new JSONObject("")));
			EmitPacket(new Packet(EnginePacketType.CLOSE));
		}

		private void EmitPacket(Packet packet)
		{
			try
			{
				ws.Send(encoder.Encode(packet));
			}
			catch (SocketIOException)
			{
			}
		}

		private void OnOpen(object sender, EventArgs e)
		{
			EmitEvent("open");
		}

		private void OnMessage(object sender, MessageEventArgs e)
		{
			Packet packet = decoder.Decode(e);
			switch (packet.enginePacketType)
			{
			case EnginePacketType.OPEN:
				HandleOpen(packet);
				break;
			case EnginePacketType.CLOSE:
				EmitEvent("close");
				break;
			case EnginePacketType.PING:
				HandlePing();
				break;
			case EnginePacketType.PONG:
				HandlePong();
				break;
			case EnginePacketType.MESSAGE:
				HandleMessage(packet);
				break;
			}
		}

		private void HandleOpen(Packet packet)
		{
			sid = packet.json["sid"].str;
			EmitEvent("open");
		}

		private void HandlePing()
		{
			EmitPacket(new Packet(EnginePacketType.PONG));
		}

		private void HandlePong()
		{
			thPong = true;
			thPinging = false;
		}

		private void HandleMessage(Packet packet)
		{
			if (packet.json == null)
			{
				return;
			}
			if (packet.socketPacketType == SocketPacketType.ACK)
			{
				for (int i = 0; i < ackList.Count; i++)
				{
					if (ackList[i].packetId == packet.id)
					{
						lock (ackQueueLock)
						{
							ackQueue.Enqueue(packet);
							return;
						}
					}
				}
			}
			if (packet.socketPacketType != SocketPacketType.EVENT)
			{
				return;
			}
			SocketIOEvent item = parser.Parse(packet.json);
			lock (eventQueueLock)
			{
				eventQueue.Enqueue(item);
			}
		}

		private void OnError(object sender, WebSocketSharp.ErrorEventArgs e)
		{
			EmitEvent("error");
		}

		private void OnClose(object sender, CloseEventArgs e)
		{
			EmitEvent("close");
		}

		private void EmitEvent(string type)
		{
			EmitEvent(new SocketIOEvent(type));
		}

		private void EmitEvent(SocketIOEvent ev)
		{
			if (!handlers.ContainsKey(ev.name))
			{
				return;
			}
			foreach (Action<SocketIOEvent> item in handlers[ev.name])
			{
				try
				{
					item(ev);
				}
				catch (Exception)
				{
				}
			}
		}

		private void InvokeAck(Packet packet)
		{
			for (int i = 0; i < ackList.Count; i++)
			{
				if (ackList[i].packetId == packet.id)
				{
					Ack ack = ackList[i];
					ackList.RemoveAt(i);
					ack.Invoke(packet.json);
					break;
				}
			}
		}
	}
	public class SocketIOEvent
	{
		public string name { get; set; }

		public JSONObject data { get; set; }

		public SocketIOEvent(string name)
			: this(name, null)
		{
		}

		public SocketIOEvent(string name, JSONObject data)
		{
			this.name = name;
			this.data = data;
		}

		public override string ToString()
		{
			return $"[SocketIOEvent: name={name}, data={data}]";
		}
	}
	public class SocketIOException : Exception
	{
		public SocketIOException()
		{
		}

		public SocketIOException(string message)
			: base(message)
		{
		}

		public SocketIOException(string message, Exception innerException)
			: base(message, innerException)
		{
		}
	}
	public enum SocketPacketType
	{
		UNKNOWN = -1,
		CONNECT,
		DISCONNECT,
		EVENT,
		ACK,
		ERROR,
		BINARY_EVENT,
		BINARY_ACK,
		CONTROL
	}
}
namespace Cinemachine.Examples
{
	[RequireComponent(typeof(CinemachineTargetGroup))]
	public class LoseSightWhenTargetsFallsOffThePlatform : MonoBehaviour
	{
		[Tooltip("The platform from which LoseSightAtRange is calculated")]
		public Transform LowerPlatform;

		[Tooltip("The weight of a transform in the target group is 1 when above the Lower Platform. When a transform is below the Lower Platform, then its weight decreases based on the distance between the transform and the Lower Platform and it reaches 0 at LoseSightAtRange. If you set this value to 0, then the transform is removed instantly when below the Lower Platform.")]
		[Range(0f, 30f)]
		public float LoseSightAtRange = 20f;

		private CinemachineTargetGroup m_TargetGroup;

		private void Awake()
		{
			m_TargetGroup = GetComponent<CinemachineTargetGroup>();
		}

		private void Update()
		{
			for (int i = 0; i < m_TargetGroup.m_Targets.Length; i++)
			{
				if (m_TargetGroup.m_Targets[i].target != null)
				{
					float num = LowerPlatform.position.y - m_TargetGroup.m_Targets[i].target.position.y;
					float weight = Mathf.Clamp(1f - num / Mathf.Max(0.001f, LoseSightAtRange), 0f, 1f);
					m_TargetGroup.m_Targets[i].weight = weight;
				}
			}
		}
	}
	[RequireComponent(typeof(CinemachineVirtualCamera))]
	[SaveDuringPlay]
	public class MouseScrollZoom2D : MonoBehaviour
	{
		[Range(0f, 10f)]
		public float ZoomMultiplier = 1f;

		[Range(0f, 100f)]
		public float MinZoom = 1f;

		[Range(0f, 100f)]
		public float MaxZoom = 50f;

		private CinemachineVirtualCamera m_VirtualCamera;

		private float m_OriginalOrthoSize;

		private void Awake()
		{
			m_VirtualCamera = GetComponent<CinemachineVirtualCamera>();
			m_OriginalOrthoSize = m_VirtualCamera.m_Lens.OrthographicSize;
		}

		private void OnValidate()
		{
			MaxZoom = Mathf.Max(MinZoom, MaxZoom);
		}

		private void Update()
		{
			float value = m_VirtualCamera.m_Lens.OrthographicSize + Input.mouseScrollDelta.y * ZoomMultiplier;
			m_VirtualCamera.m_Lens.OrthographicSize = Mathf.Clamp(value, MinZoom, MaxZoom);
		}
	}
	[AddComponentMenu("")]
	[ExecuteAlways]
	public class CinemachineFadeOutNearbyObjects : CinemachineExtension
	{
		[Tooltip("Radius of the look at target.")]
		public float m_LookAtTargetRadius = 1f;

		[Tooltip("Minimum distance to have fading out effect in front of the camera.")]
		public float m_MinDistance;

		[Tooltip("Maximum distance to have fading out effect in front of the camera.")]
		public float m_MaxDistance = 8f;

		[Tooltip("If true, MaxDistance will be set to distance between this virtual camera and LookAt target minus LookAtTargetRadius.")]
		public bool m_SetToCameraToLookAtDistance;

		[Tooltip("Material using the FadeOut shader.")]
		public Material m_FadeOutMaterial;

		private static readonly int k_MaxDistanceID = Shader.PropertyToID("_MaxDistance");

		private static readonly int k_MinDistanceID = Shader.PropertyToID("_MinDistance");

		protected override void PostPipelineStageCallback(CinemachineVirtualCameraBase vcam, CinemachineCore.Stage stage, ref CameraState state, float deltaTime)
		{
			if (stage == CinemachineCore.Stage.Finalize && !(m_FadeOutMaterial == null) && m_FadeOutMaterial.HasProperty(k_MaxDistanceID) && m_FadeOutMaterial.HasProperty(k_MinDistanceID))
			{
				if (m_SetToCameraToLookAtDistance && vcam.LookAt != null)
				{
					m_MaxDistance = Vector3.Distance(vcam.transform.position, vcam.LookAt.position) - m_LookAtTargetRadius;
				}
				m_FadeOutMaterial.SetFloat(k_MaxDistanceID, m_MaxDistance);
				m_FadeOutMaterial.SetFloat(k_MinDistanceID, m_MinDistance);
			}
		}

		private void OnValidate()
		{
			m_LookAtTargetRadius = Math.Max(0f, m_LookAtTargetRadius);
			m_MinDistance = Math.Max(0f, m_MinDistance);
			m_MaxDistance = Math.Max(0f, m_MaxDistance);
		}
	}
	public class ScriptingExample : MonoBehaviour
	{
		private CinemachineVirtualCamera vcam;

		private CinemachineFreeLook freelook;

		private float lastSwapTime;

		private void Start()
		{
			CinemachineBrain cinemachineBrain = GameObject.Find("Main Camera").AddComponent<CinemachineBrain>();
			cinemachineBrain.m_ShowDebugText = true;
			cinemachineBrain.m_DefaultBlend.m_Time = 1f;
			vcam = new GameObject("VirtualCamera").AddComponent<CinemachineVirtualCamera>();
			vcam.m_LookAt = GameObject.Find("Cube").transform;
			vcam.m_Priority = 10;
			vcam.gameObject.transform.position = new Vector3(0f, 1f, 0f);
			CinemachineComposer cinemachineComposer = vcam.AddCinemachineComponent<CinemachineComposer>();
			cinemachineComposer.m_ScreenX = 0.3f;
			cinemachineComposer.m_ScreenY = 0.35f;
			freelook = new GameObject("FreeLook").AddComponent<CinemachineFreeLook>();
			freelook.m_LookAt = GameObject.Find("Cylinder/Sphere").transform;
			freelook.m_Follow = GameObject.Find("Cylinder").transform;
			freelook.m_Priority = 11;
			CinemachineVirtualCamera rig = freelook.GetRig(0);
			CinemachineVirtualCamera rig2 = freelook.GetRig(1);
			CinemachineVirtualCamera rig3 = freelook.GetRig(2);
			rig.GetCinemachineComponent<CinemachineComposer>().m_ScreenY = 0.35f;
			rig2.GetCinemachineComponent<CinemachineComposer>().m_ScreenY = 0.25f;
			rig3.GetCinemachineComponent<CinemachineComposer>().m_ScreenY = 0.15f;
		}

		private void Update()
		{
			if (Time.realtimeSinceStartup - lastSwapTime > 5f)
			{
				freelook.enabled = !freelook.enabled;
				lastSwapTime = Time.realtimeSinceStartup;
			}
		}
	}
	[AddComponentMenu("")]
	public class CharacterMovement : MonoBehaviour
	{
		public bool useCharacterForward;

		public bool lockToCameraForward;

		public float turnSpeed = 10f;

		public KeyCode sprintJoystick = KeyCode.JoystickButton2;

		public KeyCode sprintKeyboard = KeyCode.Space;

		private float turnSpeedMultiplier;

		private float speed;

		private float direction;

		private bool isSprinting;

		private Animator anim;

		private Vector3 targetDirection;

		private Vector2 input;

		private Quaternion freeRotation;

		private Camera mainCamera;

		private float velocity;

		private void Start()
		{
			anim = GetComponent<Animator>();
			mainCamera = Camera.main;
		}

		private void FixedUpdate()
		{
			input.x = Input.GetAxis("Horizontal");
			input.y = Input.GetAxis("Vertical");
			if (useCharacterForward)
			{
				speed = Mathf.Abs(input.x) + input.y;
			}
			else
			{
				speed = Mathf.Abs(input.x) + Mathf.Abs(input.y);
			}
			speed = Mathf.Clamp(speed, 0f, 1f);
			speed = Mathf.SmoothDamp(anim.GetFloat("Speed"), speed, ref velocity, 0.1f);
			anim.SetFloat("Speed", speed);
			if (input.y < 0f && useCharacterForward)
			{
				direction = input.y;
			}
			else
			{
				direction = 0f;
			}
			anim.SetFloat("Direction", direction);
			isSprinting = (Input.GetKey(sprintJoystick) || Input.GetKey(sprintKeyboard)) && input != Vector2.zero && direction >= 0f;
			anim.SetBool("isSprinting", isSprinting);
			UpdateTargetDirection();
			if (input != Vector2.zero && targetDirection.magnitude > 0.1f)
			{
				Vector3 normalized = targetDirection.normalized;
				freeRotation = Quaternion.LookRotation(normalized, base.transform.up);
				float num = freeRotation.eulerAngles.y - base.transform.eulerAngles.y;
				float y = base.transform.eulerAngles.y;
				if (num < 0f || num > 0f)
				{
					y = freeRotation.eulerAngles.y;
				}
				Vector3 euler = new Vector3(0f, y, 0f);
				base.transform.rotation = Quaternion.Slerp(base.transform.rotation, Quaternion.Euler(euler), turnSpeed * turnSpeedMultiplier * Time.deltaTime);
			}
		}

		public virtual void UpdateTargetDirection()
		{
			if (!useCharacterForward)
			{
				turnSpeedMultiplier = 1f;
				Vector3 vector = mainCamera.transform.TransformDirection(Vector3.forward);
				vector.y = 0f;
				Vector3 vector2 = mainCamera.transform.TransformDirection(Vector3.right);
				targetDirection = input.x * vector2 + input.y * vector;
			}
			else
			{
				turnSpeedMultiplier = 0.2f;
				Vector3 vector3 = base.transform.TransformDirection(Vector3.forward);
				vector3.y = 0f;
				Vector3 vector4 = base.transform.TransformDirection(Vector3.right);
				targetDirection = input.x * vector4 + Mathf.Abs(input.y) * vector3;
			}
		}
	}
	[AddComponentMenu("")]
	public class CharacterMovement2D : MonoBehaviour
	{
		public KeyCode sprintJoystick = KeyCode.JoystickButton2;

		public KeyCode jumpJoystick = KeyCode.JoystickButton0;

		public KeyCode sprintKeyboard = KeyCode.LeftShift;

		public KeyCode jumpKeyboard = KeyCode.Space;

		public float jumpVelocity = 7f;

		public float groundTolerance = 0.2f;

		public bool checkGroundForJump = true;

		private float speed;

		private bool isSprinting;

		private Animator anim;

		private Vector2 input;

		private float velocity;

		private bool headingleft;

		private Quaternion targetrot;

		private Rigidbody rigbody;

		private void Start()
		{
			anim = GetComponent<Animator>();
			rigbody = GetComponent<Rigidbody>();
			targetrot = base.transform.rotation;
		}

		private void FixedUpdate()
		{
			input.x = Input.GetAxis("Horizontal");
			if ((input.x < 0f && !headingleft) || (input.x > 0f && headingleft))
			{
				if (input.x < 0f)
				{
					targetrot = Quaternion.Euler(0f, 270f, 0f);
				}
				if (input.x > 0f)
				{
					targetrot = Quaternion.Euler(0f, 90f, 0f);
				}
				headingleft = !headingleft;
			}
			base.transform.rotation = Quaternion.Lerp(base.transform.rotation, targetrot, Time.deltaTime * 20f);
			speed = Mathf.Abs(input.x);
			speed = Mathf.SmoothDamp(anim.GetFloat("Speed"), speed, ref velocity, 0.1f);
			anim.SetFloat("Speed", speed);
			if ((Input.GetKeyDown(sprintJoystick) || Input.GetKeyDown(sprintKeyboard)) && input != Vector2.zero)
			{
				isSprinting = true;
			}
			if (Input.GetKeyUp(sprintJoystick) || Input.GetKeyUp(sprintKeyboard) || input == Vector2.zero)
			{
				isSprinting = false;
			}
			anim.SetBool("isSprinting", isSprinting);
		}

		private void Update()
		{
			if (Input.GetKeyDown(jumpJoystick) || Input.GetKeyDown(jumpKeyboard))
			{
				rigbody.AddForce(new Vector3(0f, jumpVelocity, 0f), ForceMode.Impulse);
			}
		}

		public bool isGrounded()
		{
			if (checkGroundForJump)
			{
				return Physics.Raycast(base.transform.position, Vector3.down, groundTolerance);
			}
			return true;
		}
	}
	[AddComponentMenu("")]
	public class ActivateCameraWithDistance : MonoBehaviour
	{
		public GameObject objectToCheck;

		public float distanceToObject = 15f;

		public CinemachineVirtualCameraBase initialActiveCam;

		public CinemachineVirtualCameraBase switchCameraTo;

		private CinemachineBrain brain;

		private void Start()
		{
			brain = Camera.main.GetComponent<CinemachineBrain>();
			SwitchCam(initialActiveCam);
		}

		private void Update()
		{
			if ((bool)objectToCheck && (bool)switchCameraTo)
			{
				if (Vector3.Distance(base.transform.position, objectToCheck.transform.position) < distanceToObject)
				{
					SwitchCam(switchCameraTo);
				}
				else
				{
					SwitchCam(initialActiveCam);
				}
			}
		}

		public void SwitchCam(CinemachineVirtualCameraBase vcam)
		{
			if (!(brain == null) && !(vcam == null) && brain.ActiveVirtualCamera != vcam)
			{
				vcam.MoveToTopOfPrioritySubqueue();
			}
		}
	}
	[AddComponentMenu("")]
	public class ActivateCamOnPlay : MonoBehaviour
	{
		public CinemachineVirtualCameraBase vcam;

		private void Start()
		{
			if ((bool)vcam)
			{
				vcam.MoveToTopOfPrioritySubqueue();
			}
		}
	}
	[AddComponentMenu("")]
	public class ExampleHelpWindow : MonoBehaviour
	{
		public string m_Title;

		[TextArea(10, 50)]
		public string m_Description;

		private bool mShowingHelpWindow = true;

		private const float kPadding = 40f;

		private void OnGUI()
		{
			if (mShowingHelpWindow)
			{
				Vector2 vector = GUI.skin.label.CalcSize(new GUIContent(m_Description));
				Vector2 vector2 = vector * 0.5f;
				float maxWidth = Mathf.Min((float)UnityEngine.Screen.width - 40f, vector.x);
				float x = (float)UnityEngine.Screen.width * 0.5f - maxWidth * 0.5f;
				float y = (float)UnityEngine.Screen.height * 0.4f - vector2.y;
				Rect screenRect = new Rect(x, y, maxWidth, vector.y);
				GUILayout.Window(400, screenRect, delegate(int id)
				{
					DrawWindow(id, maxWidth);
				}, m_Title);
			}
		}

		private void DrawWindow(int id, float maxWidth)
		{
			GUILayout.BeginVertical(GUI.skin.box);
			GUILayout.Label(m_Description);
			GUILayout.EndVertical();
			if (GUILayout.Button("Got it!"))
			{
				mShowingHelpWindow = false;
			}
		}
	}
	public class InvokeEventFromInspector : MonoBehaviour
	{
		public UnityEvent Event = new UnityEvent();

		public void Invoke()
		{
			Event.Invoke();
		}
	}
	[AddComponentMenu("")]
	public class MixingCameraBlend : MonoBehaviour
	{
		public enum AxisEnum
		{
			X,
			Z,
			XZ
		}

		public Transform followTarget;

		public float initialBottomWeight = 20f;

		public AxisEnum axisToTrack;

		private CinemachineMixingCamera vcam;

		private void Start()
		{
			if ((bool)followTarget)
			{
				vcam = GetComponent<CinemachineMixingCamera>();
				vcam.m_Weight0 = initialBottomWeight;
			}
		}

		private void Update()
		{
			if ((bool)followTarget)
			{
				switch (axisToTrack)
				{
				case AxisEnum.X:
					vcam.m_Weight1 = Mathf.Abs(followTarget.transform.position.x);
					break;
				case AxisEnum.Z:
					vcam.m_Weight1 = Mathf.Abs(followTarget.transform.position.z);
					break;
				case AxisEnum.XZ:
					vcam.m_Weight1 = Mathf.Abs(Mathf.Abs(followTarget.transform.position.x) + Mathf.Abs(followTarget.transform.position.z));
					break;
				}
			}
		}
	}
	[SaveDuringPlay]
	public class ThirdPersonFollowDistanceModifier : MonoBehaviour
	{
		[Tooltip("Camera angle that corresponds to the start of the distance graph")]
		public float MinAngle;

		[Tooltip("Camera angle that corresponds to the end of the distance graph")]
		public float MaxAngle;

		[Tooltip("Defines how the camera distance scales as a function of vertical camera angle.  X axis of graph go from 0 to 1, Y axis is the multiplier that will be applied to the base distance.")]
		public AnimationCurve DistanceScale;

		private Cinemachine3rdPersonFollow TpsFollow;

		private Transform FollowTarget;

		private float BaseDistance;

		private void Reset()
		{
			MinAngle = -90f;
			MaxAngle = 90f;
			DistanceScale = AnimationCurve.EaseInOut(0f, 0.5f, 1f, 2f);
		}

		private void OnEnable()
		{
			CinemachineVirtualCamera componentInChildren = GetComponentInChildren<CinemachineVirtualCamera>();
			if (componentInChildren != null)
			{
				TpsFollow = componentInChildren.GetCinemachineComponent<Cinemachine3rdPersonFollow>();
				FollowTarget = componentInChildren.Follow;
			}
			if (TpsFollow != null)
			{
				BaseDistance = TpsFollow.CameraDistance;
			}
		}

		private void OnDisable()
		{
			if (TpsFollow != null)
			{
				TpsFollow.CameraDistance = BaseDistance;
			}
		}

		private void Update()
		{
			if (TpsFollow != null && FollowTarget != null)
			{
				float num = FollowTarget.rotation.eulerAngles.x;
				if (num > 180f)
				{
					num -= 360f;
				}
				float time = (num - MinAngle) / (MaxAngle - MinAngle);
				TpsFollow.CameraDistance = BaseDistance * DistanceScale.Evaluate(time);
			}
		}
	}
}
namespace UnityStandardAssets.Utility
{
	public class ActivateTrigger : MonoBehaviour
	{
		public enum Mode
		{
			Trigger,
			Replace,
			Activate,
			Enable,
			Animate,
			Deactivate
		}

		public Mode action = Mode.Activate;

		public UnityEngine.Object target;

		public GameObject source;

		public int triggerCount = 1;

		public bool repeatTrigger;

		private void DoActivateTrigger()
		{
			triggerCount--;
			if (triggerCount != 0 && !repeatTrigger)
			{
				return;
			}
			UnityEngine.Object obj = target ?? base.gameObject;
			Behaviour behaviour = obj as Behaviour;
			GameObject gameObject = obj as GameObject;
			if (behaviour != null)
			{
				gameObject = behaviour.gameObject;
			}
			switch (action)
			{
			case Mode.Trigger:
				if (gameObject != null)
				{
					gameObject.BroadcastMessage("DoActivateTrigger");
				}
				break;
			case Mode.Replace:
				if (source != null && gameObject != null)
				{
					UnityEngine.Object.Instantiate(source, gameObject.transform.position, gameObject.transform.rotation);
					UnityEngine.Object.DestroyObject(gameObject);
				}
				break;
			case Mode.Activate:
				if (gameObject != null)
				{
					gameObject.SetActive(value: true);
				}
				break;
			case Mode.Enable:
				if (behaviour != null)
				{
					behaviour.enabled = true;
				}
				break;
			case Mode.Animate:
				if (gameObject != null)
				{
					gameObject.GetComponent<Animation>().Play();
				}
				break;
			case Mode.Deactivate:
				if (gameObject != null)
				{
					gameObject.SetActive(value: false);
				}
				break;
			}
		}

		private void OnTriggerEnter(Collider other)
		{
			DoActivateTrigger();
		}
	}
	public class AutoMobileShaderSwitch : MonoBehaviour
	{
		[Serializable]
		public class ReplacementDefinition
		{
			public Shader original;

			public Shader replacement;
		}

		[Serializable]
		public class ReplacementList
		{
			public ReplacementDefinition[] items = new ReplacementDefinition[0];
		}

		[SerializeField]
		private ReplacementList m_ReplacementList;

		private void OnEnable()
		{
			Renderer[] array = UnityEngine.Object.FindObjectsOfType<Renderer>();
			UnityEngine.Debug.Log(array.Length + " renderers");
			List<Material> list = new List<Material>();
			List<Material> list2 = new List<Material>();
			int num = 0;
			int num2 = 0;
			ReplacementDefinition[] items = m_ReplacementList.items;
			foreach (ReplacementDefinition replacementDefinition in items)
			{
				Renderer[] array2 = array;
				foreach (Renderer renderer in array2)
				{
					Material[] array3 = null;
					for (int k = 0; k < renderer.sharedMaterials.Length; k++)
					{
						Material material = renderer.sharedMaterials[k];
						if (material.shader == replacementDefinition.original)
						{
							if (array3 == null)
							{
								array3 = renderer.materials;
							}
							if (!list.Contains(material))
							{
								list.Add(material);
								Material material2 = UnityEngine.Object.Instantiate(material);
								material2.shader = replacementDefinition.replacement;
								list2.Add(material2);
								num++;
							}
							UnityEngine.Debug.Log("replacing " + renderer.gameObject.name + " renderer " + k + " with " + list2[list.IndexOf(material)].name);
							array3[k] = list2[list.IndexOf(material)];
							num2++;
						}
					}
					if (array3 != null)
					{
						renderer.materials = array3;
					}
				}
			}
			UnityEngine.Debug.Log(num2 + " material instances replaced");
			UnityEngine.Debug.Log(num + " materials replaced");
			for (int l = 0; l < list.Count; l++)
			{
				UnityEngine.Debug.Log(list[l].name + " (" + list[l].shader.name + ") replaced with " + list2[l].name + " (" + list2[l].shader.name + ")");
			}
		}
	}
	public class AutoMoveAndRotate : MonoBehaviour
	{
		[Serializable]
		public class Vector3andSpace
		{
			public Vector3 value;

			public Space space = Space.Self;
		}

		public Vector3andSpace moveUnitsPerSecond;

		public Vector3andSpace rotateDegreesPerSecond;

		public bool ignoreTimescale;

		private float m_LastRealTime;

		private void Start()
		{
			m_LastRealTime = Time.realtimeSinceStartup;
		}

		private void Update()
		{
			float num = Time.deltaTime;
			if (ignoreTimescale)
			{
				num = Time.realtimeSinceStartup - m_LastRealTime;
				m_LastRealTime = Time.realtimeSinceStartup;
			}
			base.transform.Translate(moveUnitsPerSecond.value * num, moveUnitsPerSecond.space);
			base.transform.Rotate(rotateDegreesPerSecond.value * num, moveUnitsPerSecond.space);
		}
	}
	public class CameraRefocus
	{
		public Camera Camera;

		public Vector3 Lookatpoint;

		public Transform Parent;

		private Vector3 m_OrigCameraPos;

		private bool m_Refocus;

		public CameraRefocus(Camera camera, Transform parent, Vector3 origCameraPos)
		{
			m_OrigCameraPos = origCameraPos;
			Camera = camera;
			Parent = parent;
		}

		public void ChangeCamera(Camera camera)
		{
			Camera = camera;
		}

		public void ChangeParent(Transform parent)
		{
			Parent = parent;
		}

		public void GetFocusPoint()
		{
			if (Physics.Raycast(Parent.transform.position + m_OrigCameraPos, Parent.transform.forward, out var hitInfo, 100f))
			{
				Lookatpoint = hitInfo.point;
				m_Refocus = true;
			}
			else
			{
				m_Refocus = false;
			}
		}

		public void SetFocusPoint()
		{
			if (m_Refocus)
			{
				Camera.transform.LookAt(Lookatpoint);
			}
		}
	}
	[Serializable]
	public class CurveControlledBob
	{
		public float HorizontalBobRange = 0.33f;

		public float VerticalBobRange = 0.33f;

		public AnimationCurve Bobcurve = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(0.5f, 1f), new Keyframe(1f, 0f), new Keyframe(1.5f, -1f), new Keyframe(2f, 0f));

		public float VerticaltoHorizontalRatio = 1f;

		private float m_CyclePositionX;

		private float m_CyclePositionY;

		private float m_BobBaseInterval;

		private Vector3 m_OriginalCameraPosition;

		private float m_Time;

		public void Setup(Camera camera, float bobBaseInterval)
		{
			m_BobBaseInterval = bobBaseInterval;
			m_OriginalCameraPosition = camera.transform.localPosition;
			m_Time = Bobcurve[Bobcurve.length - 1].time;
		}

		public Vector3 DoHeadBob(float speed)
		{
			float x = m_OriginalCameraPosition.x + Bobcurve.Evaluate(m_CyclePositionX) * HorizontalBobRange;
			float y = m_OriginalCameraPosition.y + Bobcurve.Evaluate(m_CyclePositionY) * VerticalBobRange;
			m_CyclePositionX += speed * Time.deltaTime / m_BobBaseInterval;
			m_CyclePositionY += speed * Time.deltaTime / m_BobBaseInterval * VerticaltoHorizontalRatio;
			if (m_CyclePositionX > m_Time)
			{
				m_CyclePositionX -= m_Time;
			}
			if (m_CyclePositionY > m_Time)
			{
				m_CyclePositionY -= m_Time;
			}
			return new Vector3(x, y, 0f);
		}
	}
	public class DragRigidbody : MonoBehaviour
	{
		private const float k_Spring = 50f;

		private const float k_Damper = 5f;

		private const float k_Drag = 10f;

		private const float k_AngularDrag = 5f;

		private const float k_Distance = 0.2f;

		private const bool k_AttachToCenterOfMass = false;

		private SpringJoint m_SpringJoint;

		private void Update()
		{
			if (!Input.GetMouseButtonDown(0))
			{
				return;
			}
			Camera camera = FindCamera();
			RaycastHit hitInfo = default(RaycastHit);
			if (Physics.Raycast(camera.ScreenPointToRay(Input.mousePosition).origin, camera.ScreenPointToRay(Input.mousePosition).direction, out hitInfo, 100f, -5) && (bool)hitInfo.rigidbody && !hitInfo.rigidbody.isKinematic)
			{
				if (!m_SpringJoint)
				{
					GameObject gameObject = new GameObject("Rigidbody dragger");
					Rigidbody rigidbody = gameObject.AddComponent<Rigidbody>();
					m_SpringJoint = gameObject.AddComponent<SpringJoint>();
					rigidbody.isKinematic = true;
				}
				m_SpringJoint.transform.position = hitInfo.point;
				m_SpringJoint.anchor = Vector3.zero;
				m_SpringJoint.spring = 50f;
				m_SpringJoint.damper = 5f;
				m_SpringJoint.maxDistance = 0.2f;
				m_SpringJoint.connectedBody = hitInfo.rigidbody;
				StartCoroutine("DragObject", hitInfo.distance);
			}
		}

		private IEnumerator DragObject(float distance)
		{
			float oldDrag = m_SpringJoint.connectedBody.drag;
			float oldAngularDrag = m_SpringJoint.connectedBody.angularDrag;
			m_SpringJoint.connectedBody.drag = 10f;
			m_SpringJoint.connectedBody.angularDrag = 5f;
			Camera mainCamera = FindCamera();
			while (Input.GetMouseButton(0))
			{
				Ray ray = mainCamera.ScreenPointToRay(Input.mousePosition);
				m_SpringJoint.transform.position = ray.GetPoint(distance);
				yield return null;
			}
			if ((bool)m_SpringJoint.connectedBody)
			{
				m_SpringJoint.connectedBody.drag = oldDrag;
				m_SpringJoint.connectedBody.angularDrag = oldAngularDrag;
				m_SpringJoint.connectedBody = null;
			}
		}

		private Camera FindCamera()
		{
			if ((bool)GetComponent<Camera>())
			{
				return GetComponent<Camera>();
			}
			return Camera.main;
		}
	}
	public class DynamicShadowSettings : MonoBehaviour
	{
		public Light sunLight;

		public float minHeight = 10f;

		public float minShadowDistance = 80f;

		public float minShadowBias = 1f;

		public float maxHeight = 1000f;

		public float maxShadowDistance = 10000f;

		public float maxShadowBias = 0.1f;

		public float adaptTime = 1f;

		private float m_SmoothHeight;

		private float m_ChangeSpeed;

		private float m_OriginalStrength = 1f;

		private void Start()
		{
			m_OriginalStrength = sunLight.shadowStrength;
		}

		private void Update()
		{
			Ray ray = new Ray(Camera.main.transform.position, -Vector3.up);
			float num = base.transform.position.y;
			if (Physics.Raycast(ray, out var hitInfo))
			{
				num = hitInfo.distance;
			}
			if (Mathf.Abs(num - m_SmoothHeight) > 1f)
			{
				m_SmoothHeight = Mathf.SmoothDamp(m_SmoothHeight, num, ref m_ChangeSpeed, adaptTime);
			}
			float num2 = Mathf.InverseLerp(minHeight, maxHeight, m_SmoothHeight);
			QualitySettings.shadowDistance = Mathf.Lerp(minShadowDistance, maxShadowDistance, num2);
			sunLight.shadowBias = Mathf.Lerp(minShadowBias, maxShadowBias, 1f - (1f - num2) * (1f - num2));
			sunLight.shadowStrength = Mathf.Lerp(m_OriginalStrength, 0f, num2);
		}
	}
	public class FollowTarget : MonoBehaviour
	{
		public Transform target;

		public Vector3 offset = new Vector3(0f, 7.5f, 0f);

		private void LateUpdate()
		{
			base.transform.position = target.position + offset;
		}
	}
	[Serializable]
	public class FOVKick
	{
		public Camera Camera;

		[HideInInspector]
		public float originalFov;

		public float FOVIncrease = 3f;

		public float TimeToIncrease = 1f;

		public float TimeToDecrease = 1f;

		public AnimationCurve IncreaseCurve;

		public void Setup(Camera camera)
		{
			CheckStatus(camera);
			Camera = camera;
			originalFov = camera.fieldOfView;
		}

		private void CheckStatus(Camera camera)
		{
			if (camera == null)
			{
				throw new Exception("FOVKick camera is null, please supply the camera to the constructor");
			}
			if (IncreaseCurve == null)
			{
				throw new Exception("FOVKick Increase curve is null, please define the curve for the field of view kicks");
			}
		}

		public void ChangeCamera(Camera camera)
		{
			Camera = camera;
		}

		public IEnumerator FOVKickUp()
		{
			float t = Mathf.Abs((Camera.fieldOfView - originalFov) / FOVIncrease);
			while (t < TimeToIncrease)
			{
				Camera.fieldOfView = originalFov + IncreaseCurve.Evaluate(t / TimeToIncrease) * FOVIncrease;
				t += Time.deltaTime;
				yield return new WaitForEndOfFrame();
			}
		}

		public IEnumerator FOVKickDown()
		{
			float t = Mathf.Abs((Camera.fieldOfView - originalFov) / FOVIncrease);
			while (t > 0f)
			{
				Camera.fieldOfView = originalFov + IncreaseCurve.Evaluate(t / TimeToDecrease) * FOVIncrease;
				t -= Time.deltaTime;
				yield return new WaitForEndOfFrame();
			}
			Camera.fieldOfView = originalFov;
		}
	}
	[RequireComponent(typeof(Text))]
	public class FPSCounter : MonoBehaviour
	{
		private const float fpsMeasurePeriod = 0.5f;

		private int m_FpsAccumulator;

		private float m_FpsNextPeriod;

		private int m_CurrentFps;

		private const string display = "{0} FPS";

		private Text m_Text;

		private void Start()
		{
			m_FpsNextPeriod = Time.realtimeSinceStartup + 0.5f;
			m_Text = GetComponent<Text>();
		}

		private void Update()
		{
			m_FpsAccumulator++;
			if (Time.realtimeSinceStartup > m_FpsNextPeriod)
			{
				m_CurrentFps = (int)((float)m_FpsAccumulator / 0.5f);
				m_FpsAccumulator = 0;
				m_FpsNextPeriod += 0.5f;
				m_Text.text = $"{m_CurrentFps} FPS";
			}
		}
	}
	[Serializable]
	public class LerpControlledBob
	{
		public float BobDuration;

		public float BobAmount;

		private float m_Offset;

		public float Offset()
		{
			return m_Offset;
		}

		public IEnumerator DoBobCycle()
		{
			float t2 = 0f;
			while (t2 < BobDuration)
			{
				m_Offset = Mathf.Lerp(0f, BobAmount, t2 / BobDuration);
				t2 += Time.deltaTime;
				yield return new WaitForFixedUpdate();
			}
			t2 = 0f;
			while (t2 < BobDuration)
			{
				m_Offset = Mathf.Lerp(BobAmount, 0f, t2 / BobDuration);
				t2 += Time.deltaTime;
				yield return new WaitForFixedUpdate();
			}
			m_Offset = 0f;
		}
	}
	public class ObjectResetter : MonoBehaviour
	{
		private Vector3 originalPosition;

		private Quaternion originalRotation;

		private List<Transform> originalStructure;

		private Rigidbody Rigidbody;

		private void Start()
		{
			originalStructure = new List<Transform>(GetComponentsInChildren<Transform>());
			originalPosition = base.transform.position;
			originalRotation = base.transform.rotation;
			Rigidbody = GetComponent<Rigidbody>();
		}

		public void DelayedReset(float delay)
		{
			StartCoroutine(ResetCoroutine(delay));
		}

		public IEnumerator ResetCoroutine(float delay)
		{
			yield return new WaitForSeconds(delay);
			Transform[] componentsInChildren = GetComponentsInChildren<Transform>();
			foreach (Transform transform in componentsInChildren)
			{
				if (!originalStructure.Contains(transform))
				{
					transform.parent = null;
				}
			}
			base.transform.position = originalPosition;
			base.transform.rotation = originalRotation;
			if ((bool)Rigidbody)
			{
				Rigidbody.velocity = Vector3.zero;
				Rigidbody.angularVelocity = Vector3.zero;
			}
			SendMessage("Reset");
		}
	}
	public class ParticleSystemDestroyer : MonoBehaviour
	{
		public float minDuration = 8f;

		public float maxDuration = 10f;

		private float m_MaxLifetime;

		private bool m_EarlyStop;

		private IEnumerator Start()
		{
			ParticleSystem[] systems = GetComponentsInChildren<ParticleSystem>();
			ParticleSystem[] array = systems;
			foreach (ParticleSystem particleSystem in array)
			{
				m_MaxLifetime = Mathf.Max(particleSystem.startLifetime, m_MaxLifetime);
			}
			float stopTime = Time.time + UnityEngine.Random.Range(minDuration, maxDuration);
			while (Time.time < stopTime || m_EarlyStop)
			{
				yield return null;
			}
			UnityEngine.Debug.Log("stopping " + base.name);
			array = systems;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].enableEmission = false;
			}
			BroadcastMessage("Extinguish", SendMessageOptions.DontRequireReceiver);
			yield return new WaitForSeconds(m_MaxLifetime);
			UnityEngine.Object.Destroy(base.gameObject);
		}

		public void Stop()
		{
			m_EarlyStop = true;
		}
	}
	public class PlatformSpecificContent : MonoBehaviour
	{
		private enum BuildTargetGroup
		{
			Standalone,
			Mobile
		}

		[SerializeField]
		private BuildTargetGroup m_BuildTargetGroup;

		[SerializeField]
		private GameObject[] m_Content = new GameObject[0];

		[SerializeField]
		private MonoBehaviour[] m_MonoBehaviours = new MonoBehaviour[0];

		[SerializeField]
		private bool m_ChildrenOfThisObject;

		private void OnEnable()
		{
			CheckEnableContent();
		}

		private void CheckEnableContent()
		{
			if (m_BuildTargetGroup == BuildTargetGroup.Mobile)
			{
				EnableContent(enabled: true);
			}
			else
			{
				EnableContent(enabled: false);
			}
		}

		private void EnableContent(bool enabled)
		{
			if (m_Content.Length != 0)
			{
				GameObject[] content = m_Content;
				foreach (GameObject gameObject in content)
				{
					if (gameObject != null)
					{
						gameObject.SetActive(enabled);
					}
				}
			}
			if (m_ChildrenOfThisObject)
			{
				foreach (Transform item in base.transform)
				{
					item.gameObject.SetActive(enabled);
				}
			}
			if (m_MonoBehaviours.Length != 0)
			{
				MonoBehaviour[] monoBehaviours = m_MonoBehaviours;
				for (int i = 0; i < monoBehaviours.Length; i++)
				{
					monoBehaviours[i].enabled = enabled;
				}
			}
		}
	}
	public class SimpleActivatorMenu : MonoBehaviour
	{
		public Text camSwitchButton;

		public GameObject[] objects;

		private int m_CurrentActiveObject;

		private void OnEnable()
		{
			m_CurrentActiveObject = 0;
			camSwitchButton.text = objects[m_CurrentActiveObject].name;
		}

		public void NextCamera()
		{
			int num = ((m_CurrentActiveObject + 1 < objects.Length) ? (m_CurrentActiveObject + 1) : 0);
			for (int i = 0; i < objects.Length; i++)
			{
				objects[i].SetActive(i == num);
			}
			m_CurrentActiveObject = num;
			camSwitchButton.text = objects[m_CurrentActiveObject].name;
		}
	}
	public class SimpleMouseRotator : MonoBehaviour
	{
		public Vector2 rotationRange = new Vector3(70f, 70f);

		public float rotationSpeed = 10f;

		public float dampingTime = 0.2f;

		public bool autoZeroVerticalOnMobile = true;

		public bool autoZeroHorizontalOnMobile;

		public bool relative = true;

		private Vector3 m_TargetAngles;

		private Vector3 m_FollowAngles;

		private Vector3 m_FollowVelocity;

		private Quaternion m_OriginalRotation;

		private void Start()
		{
			m_OriginalRotation = base.transform.localRotation;
		}

		private void Update()
		{
			base.transform.localRotation = m_OriginalRotation;
			if (relative)
			{
				float axis = CrossPlatformInputManager.GetAxis("Mouse X");
				float axis2 = CrossPlatformInputManager.GetAxis("Mouse Y");
				if (m_TargetAngles.y > 180f)
				{
					m_TargetAngles.y -= 360f;
					m_FollowAngles.y -= 360f;
				}
				if (m_TargetAngles.x > 180f)
				{
					m_TargetAngles.x -= 360f;
					m_FollowAngles.x -= 360f;
				}
				if (m_TargetAngles.y < -180f)
				{
					m_TargetAngles.y += 360f;
					m_FollowAngles.y += 360f;
				}
				if (m_TargetAngles.x < -180f)
				{
					m_TargetAngles.x += 360f;
					m_FollowAngles.x += 360f;
				}
				m_TargetAngles.y += axis * rotationSpeed;
				m_TargetAngles.x += axis2 * rotationSpeed;
				m_TargetAngles.y = Mathf.Clamp(m_TargetAngles.y, (0f - rotationRange.y) * 0.5f, rotationRange.y * 0.5f);
				m_TargetAngles.x = Mathf.Clamp(m_TargetAngles.x, (0f - rotationRange.x) * 0.5f, rotationRange.x * 0.5f);
			}
			else
			{
				float axis = Input.mousePosition.x;
				float axis2 = Input.mousePosition.y;
				m_TargetAngles.y = Mathf.Lerp((0f - rotationRange.y) * 0.5f, rotationRange.y * 0.5f, axis / (float)UnityEngine.Screen.width);
				m_TargetAngles.x = Mathf.Lerp((0f - rotationRange.x) * 0.5f, rotationRange.x * 0.5f, axis2 / (float)UnityEngine.Screen.height);
			}
			m_FollowAngles = Vector3.SmoothDamp(m_FollowAngles, m_TargetAngles, ref m_FollowVelocity, dampingTime);
			base.transform.localRotation = m_OriginalRotation * Quaternion.Euler(0f - m_FollowAngles.x, m_FollowAngles.y, 0f);
		}
	}
	public class SmoothFollow : MonoBehaviour
	{
		[SerializeField]
		private Transform target;

		[SerializeField]
		private float distance = 10f;

		[SerializeField]
		private float height = 5f;

		[SerializeField]
		private float rotationDamping;

		[SerializeField]
		private float heightDamping;

		private void Start()
		{
		}

		private void LateUpdate()
		{
			if ((bool)target)
			{
				float y = target.eulerAngles.y;
				float b = target.position.y + height;
				float y2 = base.transform.eulerAngles.y;
				float y3 = base.transform.position.y;
				y2 = Mathf.LerpAngle(y2, y, rotationDamping * Time.deltaTime);
				y3 = Mathf.Lerp(y3, b, heightDamping * Time.deltaTime);
				Quaternion quaternion = Quaternion.Euler(0f, y2, 0f);
				base.transform.position = target.position;
				base.transform.position -= quaternion * Vector3.forward * distance;
				base.transform.position = new Vector3(base.transform.position.x, y3, base.transform.position.z);
				base.transform.LookAt(target);
			}
		}
	}
	public class TimedObjectActivator : MonoBehaviour
	{
		public enum Action
		{
			Activate,
			Deactivate,
			Destroy,
			ReloadLevel,
			Call
		}

		[Serializable]
		public class Entry
		{
			public GameObject target;

			public Action action;

			public float delay;
		}

		[Serializable]
		public class Entries
		{
			public Entry[] entries;
		}

		public Entries entries = new Entries();

		private void Awake()
		{
			Entry[] array = entries.entries;
			foreach (Entry entry in array)
			{
				switch (entry.action)
				{
				case Action.Activate:
					StartCoroutine(Activate(entry));
					break;
				case Action.Deactivate:
					StartCoroutine(Deactivate(entry));
					break;
				case Action.Destroy:
					UnityEngine.Object.Destroy(entry.target, entry.delay);
					break;
				case Action.ReloadLevel:
					StartCoroutine(ReloadLevel(entry));
					break;
				}
			}
		}

		private IEnumerator Activate(Entry entry)
		{
			yield return new WaitForSeconds(entry.delay);
			entry.target.SetActive(value: true);
		}

		private IEnumerator Deactivate(Entry entry)
		{
			yield return new WaitForSeconds(entry.delay);
			entry.target.SetActive(value: false);
		}

		private IEnumerator ReloadLevel(Entry entry)
		{
			yield return new WaitForSeconds(entry.delay);
			UnityEngine.Application.LoadLevel(UnityEngine.Application.loadedLevel);
		}
	}
	public class TimedObjectDestructor : MonoBehaviour
	{
		[SerializeField]
		private float m_TimeOut = 1f;

		[SerializeField]
		private bool m_DetachChildren;

		private void Awake()
		{
			Invoke("DestroyNow", m_TimeOut);
		}

		private void DestroyNow()
		{
			if (m_DetachChildren)
			{
				base.transform.DetachChildren();
			}
			UnityEngine.Object.DestroyObject(base.gameObject);
		}
	}
	public class WaypointCircuit : MonoBehaviour
	{
		[Serializable]
		public class WaypointList
		{
			public WaypointCircuit circuit;

			public Transform[] items = new Transform[0];
		}

		public struct RoutePoint
		{
			public Vector3 position;

			public Vector3 direction;

			public RoutePoint(Vector3 position, Vector3 direction)
			{
				this.position = position;
				this.direction = direction;
			}
		}

		public WaypointList waypointList = new WaypointList();

		[SerializeField]
		private bool smoothRoute = true;

		private int numPoints;

		private Vector3[] points;

		private float[] distances;

		public float editorVisualisationSubsteps = 100f;

		private int p0n;

		private int p1n;

		private int p2n;

		private int p3n;

		private float i;

		private Vector3 P0;

		private Vector3 P1;

		private Vector3 P2;

		private Vector3 P3;

		public float Length { get; private set; }

		public Transform[] Waypoints => waypointList.items;

		private void Awake()
		{
			if (Waypoints.Length > 1)
			{
				CachePositionsAndDistances();
			}
			numPoints = Waypoints.Length;
		}

		public RoutePoint GetRoutePoint(float dist)
		{
			Vector3 routePosition = GetRoutePosition(dist);
			return new RoutePoint(routePosition, (GetRoutePosition(dist + 0.1f) - routePosition).normalized);
		}

		public Vector3 GetRoutePosition(float dist)
		{
			int i = 0;
			if (Length == 0f)
			{
				Length = distances[distances.Length - 1];
			}
			for (dist = Mathf.Repeat(dist, Length); distances[i] < dist; i++)
			{
			}
			p1n = (i - 1 + numPoints) % numPoints;
			p2n = i;
			this.i = Mathf.InverseLerp(distances[p1n], distances[p2n], dist);
			if (smoothRoute)
			{
				p0n = (i - 2 + numPoints) % numPoints;
				p3n = (i + 1) % numPoints;
				p2n %= numPoints;
				P0 = points[p0n];
				P1 = points[p1n];
				P2 = points[p2n];
				P3 = points[p3n];
				return CatmullRom(P0, P1, P2, P3, this.i);
			}
			p1n = (i - 1 + numPoints) % numPoints;
			p2n = i;
			return Vector3.Lerp(points[p1n], points[p2n], this.i);
		}

		private Vector3 CatmullRom(Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3, float i)
		{
			return 0.5f * (2f * p1 + (-p0 + p2) * i + (2f * p0 - 5f * p1 + 4f * p2 - p3) * i * i + (-p0 + 3f * p1 - 3f * p2 + p3) * i * i * i);
		}

		private void CachePositionsAndDistances()
		{
			points = new Vector3[Waypoints.Length + 1];
			distances = new float[Waypoints.Length + 1];
			float num = 0f;
			for (int i = 0; i < points.Length; i++)
			{
				Transform transform = Waypoints[i % Waypoints.Length];
				Transform transform2 = Waypoints[(i + 1) % Waypoints.Length];
				if (transform != null && transform2 != null)
				{
					Vector3 position = transform.position;
					Vector3 position2 = transform2.position;
					points[i] = Waypoints[i % Waypoints.Length].position;
					distances[i] = num;
					num += (position - position2).magnitude;
				}
			}
		}

		private void OnDrawGizmos()
		{
			DrawGizmos(selected: false);
		}

		private void OnDrawGizmosSelected()
		{
			DrawGizmos(selected: true);
		}

		private void DrawGizmos(bool selected)
		{
			waypointList.circuit = this;
			if (Waypoints.Length <= 1)
			{
				return;
			}
			numPoints = Waypoints.Length;
			CachePositionsAndDistances();
			Length = distances[distances.Length - 1];
			Gizmos.color = (selected ? Color.yellow : new Color(1f, 1f, 0f, 0.5f));
			Vector3 from = Waypoints[0].position;
			if (smoothRoute)
			{
				for (float num = 0f; num < Length; num += Length / editorVisualisationSubsteps)
				{
					Vector3 routePosition = GetRoutePosition(num + 1f);
					Gizmos.DrawLine(from, routePosition);
					from = routePosition;
				}
				Gizmos.DrawLine(from, Waypoints[0].position);
			}
			else
			{
				for (int i = 0; i < Waypoints.Length; i++)
				{
					Vector3 position = Waypoints[(i + 1) % Waypoints.Length].position;
					Gizmos.DrawLine(from, position);
					from = position;
				}
			}
		}
	}
	public class WaypointProgressTracker : MonoBehaviour
	{
		public enum ProgressStyle
		{
			SmoothAlongRoute,
			PointToPoint
		}

		[SerializeField]
		private WaypointCircuit circuit;

		[SerializeField]
		private float lookAheadForTargetOffset = 5f;

		[SerializeField]
		private float lookAheadForTargetFactor = 0.1f;

		[SerializeField]
		private float lookAheadForSpeedOffset = 10f;

		[SerializeField]
		private float lookAheadForSpeedFactor = 0.2f;

		[SerializeField]
		private ProgressStyle progressStyle;

		[SerializeField]
		private float pointToPointThreshold = 4f;

		public Transform target;

		private float progressDistance;

		private int progressNum;

		private Vector3 lastPosition;

		private float speed;

		public WaypointCircuit.RoutePoint targetPoint { get; private set; }

		public WaypointCircuit.RoutePoint speedPoint { get; private set; }

		public WaypointCircuit.RoutePoint progressPoint { get; private set; }

		private void Start()
		{
			if (target == null)
			{
				target = new GameObject(base.name + " Waypoint Target").transform;
			}
			Reset();
		}

		public void Reset()
		{
			progressDistance = 0f;
			progressNum = 0;
			if (progressStyle == ProgressStyle.PointToPoint)
			{
				target.position = circuit.Waypoints[progressNum].position;
				target.rotation = circuit.Waypoints[progressNum].rotation;
			}
		}

		private void Update()
		{
			if (progressStyle == ProgressStyle.SmoothAlongRoute)
			{
				if (Time.deltaTime > 0f)
				{
					speed = Mathf.Lerp(speed, (lastPosition - base.transform.position).magnitude / Time.deltaTime, Time.deltaTime);
				}
				target.position = circuit.GetRoutePoint(progressDistance + lookAheadForTargetOffset + lookAheadForTargetFactor * speed).position;
				target.rotation = Quaternion.LookRotation(circuit.GetRoutePoint(progressDistance + lookAheadForSpeedOffset + lookAheadForSpeedFactor * speed).direction);
				progressPoint = circuit.GetRoutePoint(progressDistance);
				Vector3 lhs = progressPoint.position - base.transform.position;
				if (Vector3.Dot(lhs, progressPoint.direction) < 0f)
				{
					progressDistance += lhs.magnitude * 0.5f;
				}
				lastPosition = base.transform.position;
			}
			else
			{
				if ((target.position - base.transform.position).magnitude < pointToPointThreshold)
				{
					progressNum = (progressNum + 1) % circuit.Waypoints.Length;
				}
				target.position = circuit.Waypoints[progressNum].position;
				target.rotation = circuit.Waypoints[progressNum].rotation;
				progressPoint = circuit.GetRoutePoint(progressDistance);
				Vector3 lhs2 = progressPoint.position - base.transform.position;
				if (Vector3.Dot(lhs2, progressPoint.direction) < 0f)
				{
					progressDistance += lhs2.magnitude;
				}
				lastPosition = base.transform.position;
			}
		}

		private void OnDrawGizmos()
		{
			if (UnityEngine.Application.isPlaying)
			{
				Gizmos.color = Color.green;
				Gizmos.DrawLine(base.transform.position, target.position);
				Gizmos.DrawWireSphere(circuit.GetRoutePosition(progressDistance), 1f);
				Gizmos.color = Color.yellow;
				Gizmos.DrawLine(target.position, target.position + target.forward);
			}
		}
	}
}
namespace UnityStandardAssets.ImageEffects
{
	public enum AAMode
	{
		FXAA2,
		FXAA3Console,
		FXAA1PresetA,
		FXAA1PresetB,
		NFAA,
		SSAA,
		DLAA
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Other/Antialiasing")]
	public class Antialiasing : PostEffectsBase
	{
		public AAMode mode = AAMode.FXAA3Console;

		public bool showGeneratedNormals;

		public float offsetScale = 0.2f;

		public float blurRadius = 18f;

		public float edgeThresholdMin = 0.05f;

		public float edgeThreshold = 0.2f;

		public float edgeSharpness = 4f;

		public bool dlaaSharp;

		public Shader ssaaShader;

		private Material ssaa;

		public Shader dlaaShader;

		private Material dlaa;

		public Shader nfaaShader;

		private Material nfaa;

		public Shader shaderFXAAPreset2;

		private Material materialFXAAPreset2;

		public Shader shaderFXAAPreset3;

		private Material materialFXAAPreset3;

		public Shader shaderFXAAII;

		private Material materialFXAAII;

		public Shader shaderFXAAIII;

		private Material materialFXAAIII;

		public Material CurrentAAMaterial()
		{
			Material material = null;
			return mode switch
			{
				AAMode.FXAA3Console => materialFXAAIII, 
				AAMode.FXAA2 => materialFXAAII, 
				AAMode.FXAA1PresetA => materialFXAAPreset2, 
				AAMode.FXAA1PresetB => materialFXAAPreset3, 
				AAMode.NFAA => nfaa, 
				AAMode.SSAA => ssaa, 
				AAMode.DLAA => dlaa, 
				_ => null, 
			};
		}

		public override bool CheckResources()
		{
			CheckSupport(needDepth: false);
			materialFXAAPreset2 = CreateMaterial(shaderFXAAPreset2, materialFXAAPreset2);
			materialFXAAPreset3 = CreateMaterial(shaderFXAAPreset3, materialFXAAPreset3);
			materialFXAAII = CreateMaterial(shaderFXAAII, materialFXAAII);
			materialFXAAIII = CreateMaterial(shaderFXAAIII, materialFXAAIII);
			nfaa = CreateMaterial(nfaaShader, nfaa);
			ssaa = CreateMaterial(ssaaShader, ssaa);
			dlaa = CreateMaterial(dlaaShader, dlaa);
			if (!ssaaShader.isSupported)
			{
				NotSupported();
				ReportAutoDisable();
			}
			return isSupported;
		}

		public void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources())
			{
				Graphics.Blit(source, destination);
			}
			else if (mode == AAMode.FXAA3Console && materialFXAAIII != null)
			{
				materialFXAAIII.SetFloat("_EdgeThresholdMin", edgeThresholdMin);
				materialFXAAIII.SetFloat("_EdgeThreshold", edgeThreshold);
				materialFXAAIII.SetFloat("_EdgeSharpness", edgeSharpness);
				Graphics.Blit(source, destination, materialFXAAIII);
			}
			else if (mode == AAMode.FXAA1PresetB && materialFXAAPreset3 != null)
			{
				Graphics.Blit(source, destination, materialFXAAPreset3);
			}
			else if (mode == AAMode.FXAA1PresetA && materialFXAAPreset2 != null)
			{
				source.anisoLevel = 4;
				Graphics.Blit(source, destination, materialFXAAPreset2);
				source.anisoLevel = 0;
			}
			else if (mode == AAMode.FXAA2 && materialFXAAII != null)
			{
				Graphics.Blit(source, destination, materialFXAAII);
			}
			else if (mode == AAMode.SSAA && ssaa != null)
			{
				Graphics.Blit(source, destination, ssaa);
			}
			else if (mode == AAMode.DLAA && dlaa != null)
			{
				source.anisoLevel = 0;
				RenderTexture temporary = RenderTexture.GetTemporary(source.width, source.height);
				Graphics.Blit(source, temporary, dlaa, 0);
				Graphics.Blit(temporary, destination, dlaa, (!dlaaSharp) ? 1 : 2);
				RenderTexture.ReleaseTemporary(temporary);
			}
			else if (mode == AAMode.NFAA && nfaa != null)
			{
				source.anisoLevel = 0;
				nfaa.SetFloat("_OffsetScale", offsetScale);
				nfaa.SetFloat("_BlurRadius", blurRadius);
				Graphics.Blit(source, destination, nfaa, showGeneratedNormals ? 1 : 0);
			}
			else
			{
				Graphics.Blit(source, destination);
			}
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Bloom and Glow/Bloom")]
	public class Bloom : PostEffectsBase
	{
		public enum LensFlareStyle
		{
			Ghosting,
			Anamorphic,
			Combined
		}

		public enum TweakMode
		{
			Basic,
			Complex
		}

		public enum HDRBloomMode
		{
			Auto,
			On,
			Off
		}

		public enum BloomScreenBlendMode
		{
			Screen,
			Add
		}

		public enum BloomQuality
		{
			Cheap,
			High
		}

		public TweakMode tweakMode;

		public BloomScreenBlendMode screenBlendMode = BloomScreenBlendMode.Add;

		public HDRBloomMode hdr;

		private bool doHdr;

		public float sepBlurSpread = 2.5f;

		public BloomQuality quality = BloomQuality.High;

		public float bloomIntensity = 0.5f;

		public float bloomThreshold = 0.5f;

		public Color bloomThresholdColor = Color.white;

		public int bloomBlurIterations = 2;

		public int hollywoodFlareBlurIterations = 2;

		public float flareRotation;

		public LensFlareStyle lensflareMode = LensFlareStyle.Anamorphic;

		public float hollyStretchWidth = 2.5f;

		public float lensflareIntensity;

		public float lensflareThreshold = 0.3f;

		public float lensFlareSaturation = 0.75f;

		public Color flareColorA = new Color(0.4f, 0.4f, 0.8f, 0.75f);

		public Color flareColorB = new Color(0.4f, 0.8f, 0.8f, 0.75f);

		public Color flareColorC = new Color(0.8f, 0.4f, 0.8f, 0.75f);

		public Color flareColorD = new Color(0.8f, 0.4f, 0f, 0.75f);

		public Texture2D lensFlareVignetteMask;

		public Shader lensFlareShader;

		private Material lensFlareMaterial;

		public Shader screenBlendShader;

		private Material screenBlend;

		public Shader blurAndFlaresShader;

		private Material blurAndFlaresMaterial;

		public Shader brightPassFilterShader;

		private Material brightPassFilterMaterial;

		public override bool CheckResources()
		{
			CheckSupport(needDepth: false);
			screenBlend = CheckShaderAndCreateMaterial(screenBlendShader, screenBlend);
			lensFlareMaterial = CheckShaderAndCreateMaterial(lensFlareShader, lensFlareMaterial);
			blurAndFlaresMaterial = CheckShaderAndCreateMaterial(blurAndFlaresShader, blurAndFlaresMaterial);
			brightPassFilterMaterial = CheckShaderAndCreateMaterial(brightPassFilterShader, brightPassFilterMaterial);
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		public void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources())
			{
				Graphics.Blit(source, destination);
				return;
			}
			doHdr = false;
			if (hdr == HDRBloomMode.Auto)
			{
				doHdr = source.format == RenderTextureFormat.ARGBHalf && GetComponent<Camera>().allowHDR;
			}
			else
			{
				doHdr = hdr == HDRBloomMode.On;
			}
			doHdr = doHdr && supportHDRTextures;
			BloomScreenBlendMode bloomScreenBlendMode = screenBlendMode;
			if (doHdr)
			{
				bloomScreenBlendMode = BloomScreenBlendMode.Add;
			}
			RenderTextureFormat format = (doHdr ? RenderTextureFormat.ARGBHalf : RenderTextureFormat.Default);
			int width = source.width / 2;
			int height = source.height / 2;
			int width2 = source.width / 4;
			int height2 = source.height / 4;
			float num = 1f * (float)source.width / (1f * (float)source.height);
			float num2 = 0.001953125f;
			RenderTexture temporary = RenderTexture.GetTemporary(width2, height2, 0, format);
			RenderTexture temporary2 = RenderTexture.GetTemporary(width, height, 0, format);
			if (quality > BloomQuality.Cheap)
			{
				Graphics.Blit(source, temporary2, screenBlend, 2);
				RenderTexture temporary3 = RenderTexture.GetTemporary(width2, height2, 0, format);
				Graphics.Blit(temporary2, temporary3, screenBlend, 2);
				Graphics.Blit(temporary3, temporary, screenBlend, 6);
				RenderTexture.ReleaseTemporary(temporary3);
			}
			else
			{
				Graphics.Blit(source, temporary2);
				Graphics.Blit(temporary2, temporary, screenBlend, 6);
			}
			RenderTexture.ReleaseTemporary(temporary2);
			RenderTexture renderTexture = RenderTexture.GetTemporary(width2, height2, 0, format);
			BrightFilter(bloomThreshold * bloomThresholdColor, temporary, renderTexture);
			if (bloomBlurIterations < 1)
			{
				bloomBlurIterations = 1;
			}
			else if (bloomBlurIterations > 10)
			{
				bloomBlurIterations = 10;
			}
			for (int i = 0; i < bloomBlurIterations; i++)
			{
				float num3 = (1f + (float)i * 0.25f) * sepBlurSpread;
				RenderTexture temporary4 = RenderTexture.GetTemporary(width2, height2, 0, format);
				blurAndFlaresMaterial.SetVector("_Offsets", new Vector4(0f, num3 * num2, 0f, 0f));
				Graphics.Blit(renderTexture, temporary4, blurAndFlaresMaterial, 4);
				RenderTexture.ReleaseTemporary(renderTexture);
				renderTexture = temporary4;
				temporary4 = RenderTexture.GetTemporary(width2, height2, 0, format);
				blurAndFlaresMaterial.SetVector("_Offsets", new Vector4(num3 / num * num2, 0f, 0f, 0f));
				Graphics.Blit(renderTexture, temporary4, blurAndFlaresMaterial, 4);
				RenderTexture.ReleaseTemporary(renderTexture);
				renderTexture = temporary4;
				if (quality > BloomQuality.Cheap)
				{
					if (i == 0)
					{
						Graphics.SetRenderTarget(temporary);
						GL.Clear(clearDepth: false, clearColor: true, Color.black);
						Graphics.Blit(renderTexture, temporary);
					}
					else
					{
						temporary.MarkRestoreExpected();
						Graphics.Blit(renderTexture, temporary, screenBlend, 10);
					}
				}
			}
			if (quality > BloomQuality.Cheap)
			{
				Graphics.SetRenderTarget(renderTexture);
				GL.Clear(clearDepth: false, clearColor: true, Color.black);
				Graphics.Blit(temporary, renderTexture, screenBlend, 6);
			}
			if (lensflareIntensity > Mathf.Epsilon)
			{
				RenderTexture temporary5 = RenderTexture.GetTemporary(width2, height2, 0, format);
				if (lensflareMode == LensFlareStyle.Ghosting)
				{
					BrightFilter(lensflareThreshold, renderTexture, temporary5);
					if (quality > BloomQuality.Cheap)
					{
						blurAndFlaresMaterial.SetVector("_Offsets", new Vector4(0f, 1.5f / (1f * (float)temporary.height), 0f, 0f));
						Graphics.SetRenderTarget(temporary);
						GL.Clear(clearDepth: false, clearColor: true, Color.black);
						Graphics.Blit(temporary5, temporary, blurAndFlaresMaterial, 4);
						blurAndFlaresMaterial.SetVector("_Offsets", new Vector4(1.5f / (1f * (float)temporary.width), 0f, 0f, 0f));
						Graphics.SetRenderTarget(temporary5);
						GL.Clear(clearDepth: false, clearColor: true, Color.black);
						Graphics.Blit(temporary, temporary5, blurAndFlaresMaterial, 4);
					}
					Vignette(0.975f, temporary5, temporary5);
					BlendFlares(temporary5, renderTexture);
				}
				else
				{
					float num4 = 1f * Mathf.Cos(flareRotation);
					float num5 = 1f * Mathf.Sin(flareRotation);
					float num6 = hollyStretchWidth * 1f / num * num2;
					blurAndFlaresMaterial.SetVector("_Offsets", new Vector4(num4, num5, 0f, 0f));
					blurAndFlaresMaterial.SetVector("_Threshhold", new Vector4(lensflareThreshold, 1f, 0f, 0f));
					blurAndFlaresMaterial.SetVector("_TintColor", new Vector4(flareColorA.r, flareColorA.g, flareColorA.b, flareColorA.a) * flareColorA.a * lensflareIntensity);
					blurAndFlaresMaterial.SetFloat("_Saturation", lensFlareSaturation);
					temporary.DiscardContents();
					Graphics.Blit(temporary5, temporary, blurAndFlaresMaterial, 2);
					temporary5.DiscardContents();
					Graphics.Blit(temporary, temporary5, blurAndFlaresMaterial, 3);
					blurAndFlaresMaterial.SetVector("_Offsets", new Vector4(num4 * num6, num5 * num6, 0f, 0f));
					blurAndFlaresMaterial.SetFloat("_StretchWidth", hollyStretchWidth);
					temporary.DiscardContents();
					Graphics.Blit(temporary5, temporary, blurAndFlaresMaterial, 1);
					blurAndFlaresMaterial.SetFloat("_StretchWidth", hollyStretchWidth * 2f);
					temporary5.DiscardContents();
					Graphics.Blit(temporary, temporary5, blurAndFlaresMaterial, 1);
					blurAndFlaresMaterial.SetFloat("_StretchWidth", hollyStretchWidth * 4f);
					temporary.DiscardContents();
					Graphics.Blit(temporary5, temporary, blurAndFlaresMaterial, 1);
					for (int j = 0; j < hollywoodFlareBlurIterations; j++)
					{
						num6 = hollyStretchWidth * 2f / num * num2;
						blurAndFlaresMaterial.SetVector("_Offsets", new Vector4(num6 * num4, num6 * num5, 0f, 0f));
						temporary5.DiscardContents();
						Graphics.Blit(temporary, temporary5, blurAndFlaresMaterial, 4);
						blurAndFlaresMaterial.SetVector("_Offsets", new Vector4(num6 * num4, num6 * num5, 0f, 0f));
						temporary.DiscardContents();
						Graphics.Blit(temporary5, temporary, blurAndFlaresMaterial, 4);
					}
					if (lensflareMode == LensFlareStyle.Anamorphic)
					{
						AddTo(1f, temporary, renderTexture);
					}
					else
					{
						Vignette(1f, temporary, temporary5);
						BlendFlares(temporary5, temporary);
						AddTo(1f, temporary, renderTexture);
					}
				}
				RenderTexture.ReleaseTemporary(temporary5);
			}
			int pass = (int)bloomScreenBlendMode;
			screenBlend.SetFloat("_Intensity", bloomIntensity);
			screenBlend.SetTexture("_ColorBuffer", source);
			if (quality > BloomQuality.Cheap)
			{
				RenderTexture temporary6 = RenderTexture.GetTemporary(width, height, 0, format);
				Graphics.Blit(renderTexture, temporary6);
				Graphics.Blit(temporary6, destination, screenBlend, pass);
				RenderTexture.ReleaseTemporary(temporary6);
			}
			else
			{
				Graphics.Blit(renderTexture, destination, screenBlend, pass);
			}
			RenderTexture.ReleaseTemporary(temporary);
			RenderTexture.ReleaseTemporary(renderTexture);
		}

		private void AddTo(float intensity_, RenderTexture from, RenderTexture to)
		{
			screenBlend.SetFloat("_Intensity", intensity_);
			to.MarkRestoreExpected();
			Graphics.Blit(from, to, screenBlend, 9);
		}

		private void BlendFlares(RenderTexture from, RenderTexture to)
		{
			lensFlareMaterial.SetVector("colorA", new Vector4(flareColorA.r, flareColorA.g, flareColorA.b, flareColorA.a) * lensflareIntensity);
			lensFlareMaterial.SetVector("colorB", new Vector4(flareColorB.r, flareColorB.g, flareColorB.b, flareColorB.a) * lensflareIntensity);
			lensFlareMaterial.SetVector("colorC", new Vector4(flareColorC.r, flareColorC.g, flareColorC.b, flareColorC.a) * lensflareIntensity);
			lensFlareMaterial.SetVector("colorD", new Vector4(flareColorD.r, flareColorD.g, flareColorD.b, flareColorD.a) * lensflareIntensity);
			to.MarkRestoreExpected();
			Graphics.Blit(from, to, lensFlareMaterial);
		}

		private void BrightFilter(float thresh, RenderTexture from, RenderTexture to)
		{
			brightPassFilterMaterial.SetVector("_Threshhold", new Vector4(thresh, thresh, thresh, thresh));
			Graphics.Blit(from, to, brightPassFilterMaterial, 0);
		}

		private void BrightFilter(Color threshColor, RenderTexture from, RenderTexture to)
		{
			brightPassFilterMaterial.SetVector("_Threshhold", threshColor);
			Graphics.Blit(from, to, brightPassFilterMaterial, 1);
		}

		private void Vignette(float amount, RenderTexture from, RenderTexture to)
		{
			if ((bool)lensFlareVignetteMask)
			{
				screenBlend.SetTexture("_ColorBuffer", lensFlareVignetteMask);
				to.MarkRestoreExpected();
				Graphics.Blit((from == to) ? null : from, to, screenBlend, (from == to) ? 7 : 3);
			}
			else if (from != to)
			{
				Graphics.SetRenderTarget(to);
				GL.Clear(clearDepth: false, clearColor: true, Color.black);
				Graphics.Blit(from, to);
			}
		}
	}
	public enum LensflareStyle34
	{
		Ghosting,
		Anamorphic,
		Combined
	}
	public enum TweakMode34
	{
		Basic,
		Complex
	}
	public enum HDRBloomMode
	{
		Auto,
		On,
		Off
	}
	public enum BloomScreenBlendMode
	{
		Screen,
		Add
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Bloom and Glow/BloomAndFlares (3.5, Deprecated)")]
	public class BloomAndFlares : PostEffectsBase
	{
		public TweakMode34 tweakMode;

		public BloomScreenBlendMode screenBlendMode = BloomScreenBlendMode.Add;

		public HDRBloomMode hdr;

		private bool doHdr;

		public float sepBlurSpread = 1.5f;

		public float useSrcAlphaAsMask = 0.5f;

		public float bloomIntensity = 1f;

		public float bloomThreshold = 0.5f;

		public int bloomBlurIterations = 2;

		public bool lensflares;

		public int hollywoodFlareBlurIterations = 2;

		public LensflareStyle34 lensflareMode = LensflareStyle34.Anamorphic;

		public float hollyStretchWidth = 3.5f;

		public float lensflareIntensity = 1f;

		public float lensflareThreshold = 0.3f;

		public Color flareColorA = new Color(0.4f, 0.4f, 0.8f, 0.75f);

		public Color flareColorB = new Color(0.4f, 0.8f, 0.8f, 0.75f);

		public Color flareColorC = new Color(0.8f, 0.4f, 0.8f, 0.75f);

		public Color flareColorD = new Color(0.8f, 0.4f, 0f, 0.75f);

		public Texture2D lensFlareVignetteMask;

		public Shader lensFlareShader;

		private Material lensFlareMaterial;

		public Shader vignetteShader;

		private Material vignetteMaterial;

		public Shader separableBlurShader;

		private Material separableBlurMaterial;

		public Shader addBrightStuffOneOneShader;

		private Material addBrightStuffBlendOneOneMaterial;

		public Shader screenBlendShader;

		private Material screenBlend;

		public Shader hollywoodFlaresShader;

		private Material hollywoodFlaresMaterial;

		public Shader brightPassFilterShader;

		private Material brightPassFilterMaterial;

		public override bool CheckResources()
		{
			CheckSupport(needDepth: false);
			screenBlend = CheckShaderAndCreateMaterial(screenBlendShader, screenBlend);
			lensFlareMaterial = CheckShaderAndCreateMaterial(lensFlareShader, lensFlareMaterial);
			vignetteMaterial = CheckShaderAndCreateMaterial(vignetteShader, vignetteMaterial);
			separableBlurMaterial = CheckShaderAndCreateMaterial(separableBlurShader, separableBlurMaterial);
			addBrightStuffBlendOneOneMaterial = CheckShaderAndCreateMaterial(addBrightStuffOneOneShader, addBrightStuffBlendOneOneMaterial);
			hollywoodFlaresMaterial = CheckShaderAndCreateMaterial(hollywoodFlaresShader, hollywoodFlaresMaterial);
			brightPassFilterMaterial = CheckShaderAndCreateMaterial(brightPassFilterShader, brightPassFilterMaterial);
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources())
			{
				Graphics.Blit(source, destination);
				return;
			}
			doHdr = false;
			if (hdr == HDRBloomMode.Auto)
			{
				doHdr = source.format == RenderTextureFormat.ARGBHalf && GetComponent<Camera>().allowHDR;
			}
			else
			{
				doHdr = hdr == HDRBloomMode.On;
			}
			doHdr = doHdr && supportHDRTextures;
			BloomScreenBlendMode pass = screenBlendMode;
			if (doHdr)
			{
				pass = BloomScreenBlendMode.Add;
			}
			RenderTextureFormat format = (doHdr ? RenderTextureFormat.ARGBHalf : RenderTextureFormat.Default);
			RenderTexture temporary = RenderTexture.GetTemporary(source.width / 2, source.height / 2, 0, format);
			RenderTexture temporary2 = RenderTexture.GetTemporary(source.width / 4, source.height / 4, 0, format);
			RenderTexture temporary3 = RenderTexture.GetTemporary(source.width / 4, source.height / 4, 0, format);
			RenderTexture temporary4 = RenderTexture.GetTemporary(source.width / 4, source.height / 4, 0, format);
			float num = 1f * (float)source.width / (1f * (float)source.height);
			float num2 = 0.001953125f;
			Graphics.Blit(source, temporary, screenBlend, 2);
			Graphics.Blit(temporary, temporary2, screenBlend, 2);
			RenderTexture.ReleaseTemporary(temporary);
			BrightFilter(bloomThreshold, useSrcAlphaAsMask, temporary2, temporary3);
			temporary2.DiscardContents();
			if (bloomBlurIterations < 1)
			{
				bloomBlurIterations = 1;
			}
			for (int i = 0; i < bloomBlurIterations; i++)
			{
				float num3 = (1f + (float)i * 0.5f) * sepBlurSpread;
				separableBlurMaterial.SetVector("offsets", new Vector4(0f, num3 * num2, 0f, 0f));
				RenderTexture obj = ((i == 0) ? temporary3 : temporary2);
				Graphics.Blit(obj, temporary4, separableBlurMaterial);
				obj.DiscardContents();
				separableBlurMaterial.SetVector("offsets", new Vector4(num3 / num * num2, 0f, 0f, 0f));
				Graphics.Blit(temporary4, temporary2, separableBlurMaterial);
				temporary4.DiscardContents();
			}
			if (lensflares)
			{
				if (lensflareMode == LensflareStyle34.Ghosting)
				{
					BrightFilter(lensflareThreshold, 0f, temporary2, temporary4);
					temporary2.DiscardContents();
					Vignette(0.975f, temporary4, temporary3);
					temporary4.DiscardContents();
					BlendFlares(temporary3, temporary2);
					temporary3.DiscardContents();
				}
				else
				{
					hollywoodFlaresMaterial.SetVector("_threshold", new Vector4(lensflareThreshold, 1f / (1f - lensflareThreshold), 0f, 0f));
					hollywoodFlaresMaterial.SetVector("tintColor", new Vector4(flareColorA.r, flareColorA.g, flareColorA.b, flareColorA.a) * flareColorA.a * lensflareIntensity);
					Graphics.Blit(temporary4, temporary3, hollywoodFlaresMaterial, 2);
					temporary4.DiscardContents();
					Graphics.Blit(temporary3, temporary4, hollywoodFlaresMaterial, 3);
					temporary3.DiscardContents();
					hollywoodFlaresMaterial.SetVector("offsets", new Vector4(sepBlurSpread * 1f / num * num2, 0f, 0f, 0f));
					hollywoodFlaresMaterial.SetFloat("stretchWidth", hollyStretchWidth);
					Graphics.Blit(temporary4, temporary3, hollywoodFlaresMaterial, 1);
					temporary4.DiscardContents();
					hollywoodFlaresMaterial.SetFloat("stretchWidth", hollyStretchWidth * 2f);
					Graphics.Blit(temporary3, temporary4, hollywoodFlaresMaterial, 1);
					temporary3.DiscardContents();
					hollywoodFlaresMaterial.SetFloat("stretchWidth", hollyStretchWidth * 4f);
					Graphics.Blit(temporary4, temporary3, hollywoodFlaresMaterial, 1);
					temporary4.DiscardContents();
					if (lensflareMode == LensflareStyle34.Anamorphic)
					{
						for (int j = 0; j < hollywoodFlareBlurIterations; j++)
						{
							separableBlurMaterial.SetVector("offsets", new Vector4(hollyStretchWidth * 2f / num * num2, 0f, 0f, 0f));
							Graphics.Blit(temporary3, temporary4, separableBlurMaterial);
							temporary3.DiscardContents();
							separableBlurMaterial.SetVector("offsets", new Vector4(hollyStretchWidth * 2f / num * num2, 0f, 0f, 0f));
							Graphics.Blit(temporary4, temporary3, separableBlurMaterial);
							temporary4.DiscardContents();
						}
						AddTo(1f, temporary3, temporary2);
						temporary3.DiscardContents();
					}
					else
					{
						for (int k = 0; k < hollywoodFlareBlurIterations; k++)
						{
							separableBlurMaterial.SetVector("offsets", new Vector4(hollyStretchWidth * 2f / num * num2, 0f, 0f, 0f));
							Graphics.Blit(temporary3, temporary4, separableBlurMaterial);
							temporary3.DiscardContents();
							separableBlurMaterial.SetVector("offsets", new Vector4(hollyStretchWidth * 2f / num * num2, 0f, 0f, 0f));
							Graphics.Blit(temporary4, temporary3, separableBlurMaterial);
							temporary4.DiscardContents();
						}
						Vignette(1f, temporary3, temporary4);
						temporary3.DiscardContents();
						BlendFlares(temporary4, temporary3);
						temporary4.DiscardContents();
						AddTo(1f, temporary3, temporary2);
						temporary3.DiscardContents();
					}
				}
			}
			screenBlend.SetFloat("_Intensity", bloomIntensity);
			screenBlend.SetTexture("_ColorBuffer", source);
			Graphics.Blit(temporary2, destination, screenBlend, (int)pass);
			RenderTexture.ReleaseTemporary(temporary2);
			RenderTexture.ReleaseTemporary(temporary3);
			RenderTexture.ReleaseTemporary(temporary4);
		}

		private void AddTo(float intensity_, RenderTexture from, RenderTexture to)
		{
			addBrightStuffBlendOneOneMaterial.SetFloat("_Intensity", intensity_);
			Graphics.Blit(from, to, addBrightStuffBlendOneOneMaterial);
		}

		private void BlendFlares(RenderTexture from, RenderTexture to)
		{
			lensFlareMaterial.SetVector("colorA", new Vector4(flareColorA.r, flareColorA.g, flareColorA.b, flareColorA.a) * lensflareIntensity);
			lensFlareMaterial.SetVector("colorB", new Vector4(flareColorB.r, flareColorB.g, flareColorB.b, flareColorB.a) * lensflareIntensity);
			lensFlareMaterial.SetVector("colorC", new Vector4(flareColorC.r, flareColorC.g, flareColorC.b, flareColorC.a) * lensflareIntensity);
			lensFlareMaterial.SetVector("colorD", new Vector4(flareColorD.r, flareColorD.g, flareColorD.b, flareColorD.a) * lensflareIntensity);
			Graphics.Blit(from, to, lensFlareMaterial);
		}

		private void BrightFilter(float thresh, float useAlphaAsMask, RenderTexture from, RenderTexture to)
		{
			if (doHdr)
			{
				brightPassFilterMaterial.SetVector("threshold", new Vector4(thresh, 1f, 0f, 0f));
			}
			else
			{
				brightPassFilterMaterial.SetVector("threshold", new Vector4(thresh, 1f / (1f - thresh), 0f, 0f));
			}
			brightPassFilterMaterial.SetFloat("useSrcAlphaAsMask", useAlphaAsMask);
			Graphics.Blit(from, to, brightPassFilterMaterial);
		}

		private void Vignette(float amount, RenderTexture from, RenderTexture to)
		{
			if ((bool)lensFlareVignetteMask)
			{
				screenBlend.SetTexture("_ColorBuffer", lensFlareVignetteMask);
				Graphics.Blit(from, to, screenBlend, 3);
			}
			else
			{
				vignetteMaterial.SetFloat("vignetteIntensity", amount);
				Graphics.Blit(from, to, vignetteMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Bloom and Glow/Bloom (Optimized)")]
	public class BloomOptimized : PostEffectsBase
	{
		public enum Resolution
		{
			Low,
			High
		}

		public enum BlurType
		{
			Standard,
			Sgx
		}

		[Range(0f, 1.5f)]
		public float threshold = 0.25f;

		[Range(0f, 2.5f)]
		public float intensity = 0.75f;

		[Range(0.25f, 5.5f)]
		public float blurSize = 1f;

		private Resolution resolution;

		[Range(1f, 4f)]
		public int blurIterations = 1;

		public BlurType blurType;

		public Shader fastBloomShader;

		private Material fastBloomMaterial;

		public override bool CheckResources()
		{
			CheckSupport(needDepth: false);
			fastBloomMaterial = CheckShaderAndCreateMaterial(fastBloomShader, fastBloomMaterial);
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		private void OnDisable()
		{
			if ((bool)fastBloomMaterial)
			{
				UnityEngine.Object.DestroyImmediate(fastBloomMaterial);
			}
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources())
			{
				Graphics.Blit(source, destination);
				return;
			}
			int num = ((resolution == Resolution.Low) ? 4 : 2);
			float num2 = ((resolution == Resolution.Low) ? 0.5f : 1f);
			fastBloomMaterial.SetVector("_Parameter", new Vector4(blurSize * num2, 0f, threshold, intensity));
			source.filterMode = FilterMode.Bilinear;
			int width = source.width / num;
			int height = source.height / num;
			RenderTexture renderTexture = RenderTexture.GetTemporary(width, height, 0, source.format);
			renderTexture.filterMode = FilterMode.Bilinear;
			Graphics.Blit(source, renderTexture, fastBloomMaterial, 1);
			int num3 = ((blurType != 0) ? 2 : 0);
			for (int i = 0; i < blurIterations; i++)
			{
				fastBloomMaterial.SetVector("_Parameter", new Vector4(blurSize * num2 + (float)i * 1f, 0f, threshold, intensity));
				RenderTexture temporary = RenderTexture.GetTemporary(width, height, 0, source.format);
				temporary.filterMode = FilterMode.Bilinear;
				Graphics.Blit(renderTexture, temporary, fastBloomMaterial, 2 + num3);
				RenderTexture.ReleaseTemporary(renderTexture);
				renderTexture = temporary;
				temporary = RenderTexture.GetTemporary(width, height, 0, source.format);
				temporary.filterMode = FilterMode.Bilinear;
				Graphics.Blit(renderTexture, temporary, fastBloomMaterial, 3 + num3);
				RenderTexture.ReleaseTemporary(renderTexture);
				renderTexture = temporary;
			}
			fastBloomMaterial.SetTexture("_Bloom", renderTexture);
			Graphics.Blit(source, destination, fastBloomMaterial, 0);
			RenderTexture.ReleaseTemporary(renderTexture);
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Image Effects/Blur/Blur")]
	public class Blur : MonoBehaviour
	{
		public int iterations = 3;

		public float blurSpread = 0.6f;

		public Shader blurShader;

		private static Material m_Material;

		protected Material material
		{
			get
			{
				if (m_Material == null)
				{
					m_Material = new Material(blurShader);
					m_Material.hideFlags = HideFlags.DontSave;
				}
				return m_Material;
			}
		}

		protected void OnDisable()
		{
			if ((bool)m_Material)
			{
				UnityEngine.Object.DestroyImmediate(m_Material);
			}
		}

		protected void Start()
		{
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
			else if (!blurShader || !material.shader.isSupported)
			{
				base.enabled = false;
			}
		}

		public void FourTapCone(RenderTexture source, RenderTexture dest, int iteration)
		{
			float num = 0.5f + (float)iteration * blurSpread;
			Graphics.BlitMultiTap(source, dest, material, new Vector2(0f - num, 0f - num), new Vector2(0f - num, num), new Vector2(num, num), new Vector2(num, 0f - num));
		}

		private void DownSample4x(RenderTexture source, RenderTexture dest)
		{
			float num = 1f;
			Graphics.BlitMultiTap(source, dest, material, new Vector2(0f - num, 0f - num), new Vector2(0f - num, num), new Vector2(num, num), new Vector2(num, 0f - num));
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			int width = source.width / 4;
			int height = source.height / 4;
			RenderTexture renderTexture = RenderTexture.GetTemporary(width, height, 0);
			DownSample4x(source, renderTexture);
			for (int i = 0; i < iterations; i++)
			{
				RenderTexture temporary = RenderTexture.GetTemporary(width, height, 0);
				FourTapCone(renderTexture, temporary, i);
				RenderTexture.ReleaseTemporary(renderTexture);
				renderTexture = temporary;
			}
			Graphics.Blit(renderTexture, destination);
			RenderTexture.ReleaseTemporary(renderTexture);
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Blur/Blur (Optimized)")]
	public class BlurOptimized : PostEffectsBase
	{
		public enum BlurType
		{
			StandardGauss,
			SgxGauss
		}

		[Range(0f, 2f)]
		public int downsample = 1;

		[Range(0f, 10f)]
		public float blurSize = 3f;

		[Range(1f, 4f)]
		public int blurIterations = 2;

		public BlurType blurType;

		public Shader blurShader;

		private Material blurMaterial;

		public override bool CheckResources()
		{
			CheckSupport(needDepth: false);
			blurMaterial = CheckShaderAndCreateMaterial(blurShader, blurMaterial);
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		public void OnDisable()
		{
			if ((bool)blurMaterial)
			{
				UnityEngine.Object.DestroyImmediate(blurMaterial);
			}
		}

		public void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources())
			{
				Graphics.Blit(source, destination);
				return;
			}
			float num = 1f / (1f * (float)(1 << downsample));
			blurMaterial.SetVector("_Parameter", new Vector4(blurSize * num, (0f - blurSize) * num, 0f, 0f));
			source.filterMode = FilterMode.Bilinear;
			int width = source.width >> downsample;
			int height = source.height >> downsample;
			RenderTexture renderTexture = RenderTexture.GetTemporary(width, height, 0, source.format);
			renderTexture.filterMode = FilterMode.Bilinear;
			Graphics.Blit(source, renderTexture, blurMaterial, 0);
			int num2 = ((blurType != 0) ? 2 : 0);
			for (int i = 0; i < blurIterations; i++)
			{
				float num3 = (float)i * 1f;
				blurMaterial.SetVector("_Parameter", new Vector4(blurSize * num + num3, (0f - blurSize) * num - num3, 0f, 0f));
				RenderTexture temporary = RenderTexture.GetTemporary(width, height, 0, source.format);
				temporary.filterMode = FilterMode.Bilinear;
				Graphics.Blit(renderTexture, temporary, blurMaterial, 1 + num2);
				RenderTexture.ReleaseTemporary(renderTexture);
				renderTexture = temporary;
				temporary = RenderTexture.GetTemporary(width, height, 0, source.format);
				temporary.filterMode = FilterMode.Bilinear;
				Graphics.Blit(renderTexture, temporary, blurMaterial, 2 + num2);
				RenderTexture.ReleaseTemporary(renderTexture);
				renderTexture = temporary;
			}
			Graphics.Blit(renderTexture, destination);
			RenderTexture.ReleaseTemporary(renderTexture);
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Camera/Camera Motion Blur")]
	public class CameraMotionBlur : PostEffectsBase
	{
		public enum MotionBlurFilter
		{
			CameraMotion,
			LocalBlur,
			Reconstruction,
			ReconstructionDX11,
			ReconstructionDisc
		}

		private static float MAX_RADIUS = 10f;

		public MotionBlurFilter filterType = MotionBlurFilter.Reconstruction;

		public bool preview;

		public Vector3 previewScale = Vector3.one;

		public float movementScale;

		public float rotationScale = 1f;

		public float maxVelocity = 8f;

		public float minVelocity = 0.1f;

		public float velocityScale = 0.375f;

		public float softZDistance = 0.005f;

		public int velocityDownsample = 1;

		public LayerMask excludeLayers = 0;

		private GameObject tmpCam;

		public Shader shader;

		public Shader dx11MotionBlurShader;

		public Shader replacementClear;

		private Material motionBlurMaterial;

		private Material dx11MotionBlurMaterial;

		public Texture2D noiseTexture;

		public float jitter = 0.05f;

		public bool showVelocity;

		public float showVelocityScale = 1f;

		private Matrix4x4 currentViewProjMat;

		private Matrix4x4 prevViewProjMat;

		private int prevFrameCount;

		private bool wasActive;

		private Vector3 prevFrameForward = Vector3.forward;

		private Vector3 prevFrameUp = Vector3.up;

		private Vector3 prevFramePos = Vector3.zero;

		private Camera _camera;

		private void CalculateViewProjection()
		{
			Matrix4x4 worldToCameraMatrix = _camera.worldToCameraMatrix;
			Matrix4x4 gPUProjectionMatrix = GL.GetGPUProjectionMatrix(_camera.projectionMatrix, renderIntoTexture: true);
			currentViewProjMat = gPUProjectionMatrix * worldToCameraMatrix;
		}

		private new void Start()
		{
			CheckResources();
			if (_camera == null)
			{
				_camera = GetComponent<Camera>();
			}
			wasActive = base.gameObject.activeInHierarchy;
			CalculateViewProjection();
			Remember();
			wasActive = false;
		}

		private void OnEnable()
		{
			if (_camera == null)
			{
				_camera = GetComponent<Camera>();
			}
			_camera.depthTextureMode |= DepthTextureMode.Depth;
		}

		private void OnDisable()
		{
			if (null != motionBlurMaterial)
			{
				UnityEngine.Object.DestroyImmediate(motionBlurMaterial);
				motionBlurMaterial = null;
			}
			if (null != dx11MotionBlurMaterial)
			{
				UnityEngine.Object.DestroyImmediate(dx11MotionBlurMaterial);
				dx11MotionBlurMaterial = null;
			}
			if (null != tmpCam)
			{
				UnityEngine.Object.DestroyImmediate(tmpCam);
				tmpCam = null;
			}
		}

		public override bool CheckResources()
		{
			CheckSupport(needDepth: true, needHdr: true);
			motionBlurMaterial = CheckShaderAndCreateMaterial(shader, motionBlurMaterial);
			if (supportDX11 && filterType == MotionBlurFilter.ReconstructionDX11)
			{
				dx11MotionBlurMaterial = CheckShaderAndCreateMaterial(dx11MotionBlurShader, dx11MotionBlurMaterial);
			}
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources())
			{
				Graphics.Blit(source, destination);
				return;
			}
			if (filterType == MotionBlurFilter.CameraMotion)
			{
				StartFrame();
			}
			RenderTextureFormat format = (SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.RGHalf) ? RenderTextureFormat.RGHalf : RenderTextureFormat.ARGBHalf);
			RenderTexture temporary = RenderTexture.GetTemporary(divRoundUp(source.width, velocityDownsample), divRoundUp(source.height, velocityDownsample), 0, format);
			int num = 1;
			int num2 = 1;
			maxVelocity = Mathf.Max(2f, maxVelocity);
			float num3 = maxVelocity;
			bool flag = filterType == MotionBlurFilter.ReconstructionDX11 && dx11MotionBlurMaterial == null;
			if (filterType == MotionBlurFilter.Reconstruction || flag || filterType == MotionBlurFilter.ReconstructionDisc)
			{
				maxVelocity = Mathf.Min(maxVelocity, MAX_RADIUS);
				num = divRoundUp(temporary.width, (int)maxVelocity);
				num2 = divRoundUp(temporary.height, (int)maxVelocity);
				num3 = temporary.width / num;
			}
			else
			{
				num = divRoundUp(temporary.width, (int)maxVelocity);
				num2 = divRoundUp(temporary.height, (int)maxVelocity);
				num3 = temporary.width / num;
			}
			RenderTexture temporary2 = RenderTexture.GetTemporary(num, num2, 0, format);
			RenderTexture temporary3 = RenderTexture.GetTemporary(num, num2, 0, format);
			temporary.filterMode = FilterMode.Point;
			temporary2.filterMode = FilterMode.Point;
			temporary3.filterMode = FilterMode.Point;
			if ((bool)noiseTexture)
			{
				noiseTexture.filterMode = FilterMode.Point;
			}
			source.wrapMode = TextureWrapMode.Clamp;
			temporary.wrapMode = TextureWrapMode.Clamp;
			temporary3.wrapMode = TextureWrapMode.Clamp;
			temporary2.wrapMode = TextureWrapMode.Clamp;
			CalculateViewProjection();
			if (base.gameObject.activeInHierarchy && !wasActive)
			{
				Remember();
			}
			wasActive = base.gameObject.activeInHierarchy;
			Matrix4x4 matrix4x = Matrix4x4.Inverse(currentViewProjMat);
			motionBlurMaterial.SetMatrix("_InvViewProj", matrix4x);
			motionBlurMaterial.SetMatrix("_PrevViewProj", prevViewProjMat);
			motionBlurMaterial.SetMatrix("_ToPrevViewProjCombined", prevViewProjMat * matrix4x);
			motionBlurMaterial.SetFloat("_MaxVelocity", num3);
			motionBlurMaterial.SetFloat("_MaxRadiusOrKInPaper", num3);
			motionBlurMaterial.SetFloat("_MinVelocity", minVelocity);
			motionBlurMaterial.SetFloat("_VelocityScale", velocityScale);
			motionBlurMaterial.SetFloat("_Jitter", jitter);
			motionBlurMaterial.SetTexture("_NoiseTex", noiseTexture);
			motionBlurMaterial.SetTexture("_VelTex", temporary);
			motionBlurMaterial.SetTexture("_NeighbourMaxTex", temporary3);
			motionBlurMaterial.SetTexture("_TileTexDebug", temporary2);
			if (preview)
			{
				Matrix4x4 worldToCameraMatrix = _camera.worldToCameraMatrix;
				Matrix4x4 identity = Matrix4x4.identity;
				identity.SetTRS(previewScale * 0.3333f, Quaternion.identity, Vector3.one);
				Matrix4x4 gPUProjectionMatrix = GL.GetGPUProjectionMatrix(_camera.projectionMatrix, renderIntoTexture: true);
				prevViewProjMat = gPUProjectionMatrix * identity * worldToCameraMatrix;
				motionBlurMaterial.SetMatrix("_PrevViewProj", prevViewProjMat);
				motionBlurMaterial.SetMatrix("_ToPrevViewProjCombined", prevViewProjMat * matrix4x);
			}
			if (filterType == MotionBlurFilter.CameraMotion)
			{
				Vector4 zero = Vector4.zero;
				float num4 = Vector3.Dot(base.transform.up, Vector3.up);
				Vector3 rhs = prevFramePos - base.transform.position;
				float magnitude = rhs.magnitude;
				float num5 = 1f;
				num5 = Vector3.Angle(base.transform.up, prevFrameUp) / _camera.fieldOfView * ((float)source.width * 0.75f);
				zero.x = rotationScale * num5;
				num5 = Vector3.Angle(base.transform.forward, prevFrameForward) / _camera.fieldOfView * ((float)source.width * 0.75f);
				zero.y = rotationScale * num4 * num5;
				num5 = Vector3.Angle(base.transform.forward, prevFrameForward) / _camera.fieldOfView * ((float)source.width * 0.75f);
				zero.z = rotationScale * (1f - num4) * num5;
				if (magnitude > Mathf.Epsilon && movementScale > Mathf.Epsilon)
				{
					zero.w = movementScale * Vector3.Dot(base.transform.forward, rhs) * ((float)source.width * 0.5f);
					zero.x += movementScale * Vector3.Dot(base.transform.up, rhs) * ((float)source.width * 0.5f);
					zero.y += movementScale * Vector3.Dot(base.transform.right, rhs) * ((float)source.width * 0.5f);
				}
				if (preview)
				{
					motionBlurMaterial.SetVector("_BlurDirectionPacked", new Vector4(previewScale.y, previewScale.x, 0f, previewScale.z) * 0.5f * _camera.fieldOfView);
				}
				else
				{
					motionBlurMaterial.SetVector("_BlurDirectionPacked", zero);
				}
			}
			else
			{
				Graphics.Blit(source, temporary, motionBlurMaterial, 0);
				Camera camera = null;
				if (excludeLayers.value != 0)
				{
					camera = GetTmpCam();
				}
				if ((bool)camera && excludeLayers.value != 0 && (bool)replacementClear && replacementClear.isSupported)
				{
					camera.targetTexture = temporary;
					camera.cullingMask = excludeLayers;
					camera.RenderWithShader(replacementClear, "");
				}
			}
			if (!preview && Time.frameCount != prevFrameCount)
			{
				prevFrameCount = Time.frameCount;
				Remember();
			}
			source.filterMode = FilterMode.Bilinear;
			if (showVelocity)
			{
				motionBlurMaterial.SetFloat("_DisplayVelocityScale", showVelocityScale);
				Graphics.Blit(temporary, destination, motionBlurMaterial, 1);
			}
			else if (filterType == MotionBlurFilter.ReconstructionDX11 && !flag)
			{
				dx11MotionBlurMaterial.SetFloat("_MinVelocity", minVelocity);
				dx11MotionBlurMaterial.SetFloat("_VelocityScale", velocityScale);
				dx11MotionBlurMaterial.SetFloat("_Jitter", jitter);
				dx11MotionBlurMaterial.SetTexture("_NoiseTex", noiseTexture);
				dx11MotionBlurMaterial.SetTexture("_VelTex", temporary);
				dx11MotionBlurMaterial.SetTexture("_NeighbourMaxTex", temporary3);
				dx11MotionBlurMaterial.SetFloat("_SoftZDistance", Mathf.Max(0.00025f, softZDistance));
				dx11MotionBlurMaterial.SetFloat("_MaxRadiusOrKInPaper", num3);
				Graphics.Blit(temporary, temporary2, dx11MotionBlurMaterial, 0);
				Graphics.Blit(temporary2, temporary3, dx11MotionBlurMaterial, 1);
				Graphics.Blit(source, destination, dx11MotionBlurMaterial, 2);
			}
			else if (filterType == MotionBlurFilter.Reconstruction || flag)
			{
				motionBlurMaterial.SetFloat("_SoftZDistance", Mathf.Max(0.00025f, softZDistance));
				Graphics.Blit(temporary, temporary2, motionBlurMaterial, 2);
				Graphics.Blit(temporary2, temporary3, motionBlurMaterial, 3);
				Graphics.Blit(source, destination, motionBlurMaterial, 4);
			}
			else if (filterType == MotionBlurFilter.CameraMotion)
			{
				Graphics.Blit(source, destination, motionBlurMaterial, 6);
			}
			else if (filterType == MotionBlurFilter.ReconstructionDisc)
			{
				motionBlurMaterial.SetFloat("_SoftZDistance", Mathf.Max(0.00025f, softZDistance));
				Graphics.Blit(temporary, temporary2, motionBlurMaterial, 2);
				Graphics.Blit(temporary2, temporary3, motionBlurMaterial, 3);
				Graphics.Blit(source, destination, motionBlurMaterial, 7);
			}
			else
			{
				Graphics.Blit(source, destination, motionBlurMaterial, 5);
			}
			RenderTexture.ReleaseTemporary(temporary);
			RenderTexture.ReleaseTemporary(temporary2);
			RenderTexture.ReleaseTemporary(temporary3);
		}

		private void Remember()
		{
			prevViewProjMat = currentViewProjMat;
			prevFrameForward = base.transform.forward;
			prevFrameUp = base.transform.up;
			prevFramePos = base.transform.position;
		}

		private Camera GetTmpCam()
		{
			if (tmpCam == null)
			{
				string text = "_" + _camera.name + "_MotionBlurTmpCam";
				GameObject gameObject = GameObject.Find(text);
				if (null == gameObject)
				{
					tmpCam = new GameObject(text, typeof(Camera));
				}
				else
				{
					tmpCam = gameObject;
				}
			}
			tmpCam.hideFlags = HideFlags.DontSave;
			tmpCam.transform.position = _camera.transform.position;
			tmpCam.transform.rotation = _camera.transform.rotation;
			tmpCam.transform.localScale = _camera.transform.localScale;
			tmpCam.GetComponent<Camera>().CopyFrom(_camera);
			tmpCam.GetComponent<Camera>().enabled = false;
			tmpCam.GetComponent<Camera>().depthTextureMode = DepthTextureMode.None;
			tmpCam.GetComponent<Camera>().clearFlags = CameraClearFlags.Nothing;
			return tmpCam.GetComponent<Camera>();
		}

		private void StartFrame()
		{
			prevFramePos = Vector3.Slerp(prevFramePos, base.transform.position, 0.75f);
		}

		private static int divRoundUp(int x, int d)
		{
			return (x + d - 1) / d;
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Image Effects/Color Adjustments/Color Correction (Curves, Saturation)")]
	public class ColorCorrectionCurves : PostEffectsBase
	{
		public enum ColorCorrectionMode
		{
			Simple,
			Advanced
		}

		public AnimationCurve redChannel = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(1f, 1f));

		public AnimationCurve greenChannel = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(1f, 1f));

		public AnimationCurve blueChannel = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(1f, 1f));

		public bool useDepthCorrection;

		public AnimationCurve zCurve = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(1f, 1f));

		public AnimationCurve depthRedChannel = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(1f, 1f));

		public AnimationCurve depthGreenChannel = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(1f, 1f));

		public AnimationCurve depthBlueChannel = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(1f, 1f));

		private Material ccMaterial;

		private Material ccDepthMaterial;

		private Material selectiveCcMaterial;

		private Texture2D rgbChannelTex;

		private Texture2D rgbDepthChannelTex;

		private Texture2D zCurveTex;

		public float saturation = 1f;

		public bool selectiveCc;

		public Color selectiveFromColor = Color.white;

		public Color selectiveToColor = Color.white;

		public ColorCorrectionMode mode;

		public bool updateTextures = true;

		public Shader colorCorrectionCurvesShader;

		public Shader simpleColorCorrectionCurvesShader;

		public Shader colorCorrectionSelectiveShader;

		private bool updateTexturesOnStartup = true;

		private new void Start()
		{
			base.Start();
			updateTexturesOnStartup = true;
		}

		private void Awake()
		{
		}

		public override bool CheckResources()
		{
			CheckSupport(mode == ColorCorrectionMode.Advanced);
			ccMaterial = CheckShaderAndCreateMaterial(simpleColorCorrectionCurvesShader, ccMaterial);
			ccDepthMaterial = CheckShaderAndCreateMaterial(colorCorrectionCurvesShader, ccDepthMaterial);
			selectiveCcMaterial = CheckShaderAndCreateMaterial(colorCorrectionSelectiveShader, selectiveCcMaterial);
			if (!rgbChannelTex)
			{
				rgbChannelTex = new Texture2D(256, 4, TextureFormat.ARGB32, mipChain: false, linear: true);
			}
			if (!rgbDepthChannelTex)
			{
				rgbDepthChannelTex = new Texture2D(256, 4, TextureFormat.ARGB32, mipChain: false, linear: true);
			}
			if (!zCurveTex)
			{
				zCurveTex = new Texture2D(256, 1, TextureFormat.ARGB32, mipChain: false, linear: true);
			}
			rgbChannelTex.hideFlags = HideFlags.DontSave;
			rgbDepthChannelTex.hideFlags = HideFlags.DontSave;
			zCurveTex.hideFlags = HideFlags.DontSave;
			rgbChannelTex.wrapMode = TextureWrapMode.Clamp;
			rgbDepthChannelTex.wrapMode = TextureWrapMode.Clamp;
			zCurveTex.wrapMode = TextureWrapMode.Clamp;
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		public void UpdateParameters()
		{
			CheckResources();
			if (redChannel != null && greenChannel != null && blueChannel != null)
			{
				for (float num = 0f; num <= 1f; num += 0.003921569f)
				{
					float num2 = Mathf.Clamp(redChannel.Evaluate(num), 0f, 1f);
					float num3 = Mathf.Clamp(greenChannel.Evaluate(num), 0f, 1f);
					float num4 = Mathf.Clamp(blueChannel.Evaluate(num), 0f, 1f);
					rgbChannelTex.SetPixel((int)Mathf.Floor(num * 255f), 0, new Color(num2, num2, num2));
					rgbChannelTex.SetPixel((int)Mathf.Floor(num * 255f), 1, new Color(num3, num3, num3));
					rgbChannelTex.SetPixel((int)Mathf.Floor(num * 255f), 2, new Color(num4, num4, num4));
					float num5 = Mathf.Clamp(zCurve.Evaluate(num), 0f, 1f);
					zCurveTex.SetPixel((int)Mathf.Floor(num * 255f), 0, new Color(num5, num5, num5));
					num2 = Mathf.Clamp(depthRedChannel.Evaluate(num), 0f, 1f);
					num3 = Mathf.Clamp(depthGreenChannel.Evaluate(num), 0f, 1f);
					num4 = Mathf.Clamp(depthBlueChannel.Evaluate(num), 0f, 1f);
					rgbDepthChannelTex.SetPixel((int)Mathf.Floor(num * 255f), 0, new Color(num2, num2, num2));
					rgbDepthChannelTex.SetPixel((int)Mathf.Floor(num * 255f), 1, new Color(num3, num3, num3));
					rgbDepthChannelTex.SetPixel((int)Mathf.Floor(num * 255f), 2, new Color(num4, num4, num4));
				}
				rgbChannelTex.Apply();
				rgbDepthChannelTex.Apply();
				zCurveTex.Apply();
			}
		}

		private void UpdateTextures()
		{
			UpdateParameters();
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources())
			{
				Graphics.Blit(source, destination);
				return;
			}
			if (updateTexturesOnStartup)
			{
				UpdateParameters();
				updateTexturesOnStartup = false;
			}
			if (useDepthCorrection)
			{
				GetComponent<Camera>().depthTextureMode |= DepthTextureMode.Depth;
			}
			RenderTexture renderTexture = destination;
			if (selectiveCc)
			{
				renderTexture = RenderTexture.GetTemporary(source.width, source.height);
			}
			if (useDepthCorrection)
			{
				ccDepthMaterial.SetTexture("_RgbTex", rgbChannelTex);
				ccDepthMaterial.SetTexture("_ZCurve", zCurveTex);
				ccDepthMaterial.SetTexture("_RgbDepthTex", rgbDepthChannelTex);
				ccDepthMaterial.SetFloat("_Saturation", saturation);
				Graphics.Blit(source, renderTexture, ccDepthMaterial);
			}
			else
			{
				ccMaterial.SetTexture("_RgbTex", rgbChannelTex);
				ccMaterial.SetFloat("_Saturation", saturation);
				Graphics.Blit(source, renderTexture, ccMaterial);
			}
			if (selectiveCc)
			{
				selectiveCcMaterial.SetColor("selColor", selectiveFromColor);
				selectiveCcMaterial.SetColor("targetColor", selectiveToColor);
				Graphics.Blit(renderTexture, destination, selectiveCcMaterial);
				RenderTexture.ReleaseTemporary(renderTexture);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Image Effects/Color Adjustments/Color Correction (3D Lookup Texture)")]
	public class ColorCorrectionLookup : PostEffectsBase
	{
		public Shader shader;

		private Material material;

		public Texture3D converted3DLut;

		public string basedOnTempTex = "";

		public override bool CheckResources()
		{
			CheckSupport(needDepth: false);
			material = CheckShaderAndCreateMaterial(shader, material);
			if (!isSupported || !SystemInfo.supports3DTextures)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		private void OnDisable()
		{
			if ((bool)material)
			{
				UnityEngine.Object.DestroyImmediate(material);
				material = null;
			}
		}

		private void OnDestroy()
		{
			if ((bool)converted3DLut)
			{
				UnityEngine.Object.DestroyImmediate(converted3DLut);
			}
			converted3DLut = null;
		}

		public void SetIdentityLut()
		{
			int num = 16;
			Color[] array = new Color[num * num * num];
			float num2 = 1f / (1f * (float)num - 1f);
			for (int i = 0; i < num; i++)
			{
				for (int j = 0; j < num; j++)
				{
					for (int k = 0; k < num; k++)
					{
						array[i + j * num + k * num * num] = new Color((float)i * 1f * num2, (float)j * 1f * num2, (float)k * 1f * num2, 1f);
					}
				}
			}
			if ((bool)converted3DLut)
			{
				UnityEngine.Object.DestroyImmediate(converted3DLut);
			}
			converted3DLut = new Texture3D(num, num, num, TextureFormat.ARGB32, mipChain: false);
			converted3DLut.SetPixels(array);
			converted3DLut.Apply();
			basedOnTempTex = "";
		}

		public bool ValidDimensions(Texture2D tex2d)
		{
			if (!tex2d)
			{
				return false;
			}
			if (tex2d.height != Mathf.FloorToInt(Mathf.Sqrt(tex2d.width)))
			{
				return false;
			}
			return true;
		}

		public void Convert(Texture2D temp2DTex, string path)
		{
			if ((bool)temp2DTex)
			{
				int num = temp2DTex.width * temp2DTex.height;
				num = temp2DTex.height;
				if (!ValidDimensions(temp2DTex))
				{
					UnityEngine.Debug.LogWarning("The given 2D texture " + temp2DTex.name + " cannot be used as a 3D LUT.");
					basedOnTempTex = "";
					return;
				}
				Color[] pixels = temp2DTex.GetPixels();
				Color[] array = new Color[pixels.Length];
				for (int i = 0; i < num; i++)
				{
					for (int j = 0; j < num; j++)
					{
						for (int k = 0; k < num; k++)
						{
							int num2 = num - j - 1;
							array[i + j * num + k * num * num] = pixels[k * num + i + num2 * num * num];
						}
					}
				}
				if ((bool)converted3DLut)
				{
					UnityEngine.Object.DestroyImmediate(converted3DLut);
				}
				converted3DLut = new Texture3D(num, num, num, TextureFormat.ARGB32, mipChain: false);
				converted3DLut.SetPixels(array);
				converted3DLut.Apply();
				basedOnTempTex = path;
			}
			else
			{
				UnityEngine.Debug.LogError("Couldn't color correct with 3D LUT texture. Image Effect will be disabled.");
			}
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources() || !SystemInfo.supports3DTextures)
			{
				Graphics.Blit(source, destination);
				return;
			}
			if (converted3DLut == null)
			{
				SetIdentityLut();
			}
			int width = converted3DLut.width;
			converted3DLut.wrapMode = TextureWrapMode.Clamp;
			material.SetFloat("_Scale", (float)(width - 1) / (1f * (float)width));
			material.SetFloat("_Offset", 1f / (2f * (float)width));
			material.SetTexture("_ClutTex", converted3DLut);
			Graphics.Blit(source, destination, material, (QualitySettings.activeColorSpace == ColorSpace.Linear) ? 1 : 0);
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Image Effects/Color Adjustments/Color Correction (Ramp)")]
	public class ColorCorrectionRamp : ImageEffectBase
	{
		public Texture textureRamp;

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			base.material.SetTexture("_RampTex", textureRamp);
			Graphics.Blit(source, destination, base.material);
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Color Adjustments/Contrast Enhance (Unsharp Mask)")]
	internal class ContrastEnhance : PostEffectsBase
	{
		public float intensity = 0.5f;

		public float threshold;

		private Material separableBlurMaterial;

		private Material contrastCompositeMaterial;

		public float blurSpread = 1f;

		public Shader separableBlurShader;

		public Shader contrastCompositeShader;

		public override bool CheckResources()
		{
			CheckSupport(needDepth: false);
			contrastCompositeMaterial = CheckShaderAndCreateMaterial(contrastCompositeShader, contrastCompositeMaterial);
			separableBlurMaterial = CheckShaderAndCreateMaterial(separableBlurShader, separableBlurMaterial);
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources())
			{
				Graphics.Blit(source, destination);
				return;
			}
			int width = source.width;
			int height = source.height;
			RenderTexture temporary = RenderTexture.GetTemporary(width / 2, height / 2, 0);
			Graphics.Blit(source, temporary);
			RenderTexture temporary2 = RenderTexture.GetTemporary(width / 4, height / 4, 0);
			Graphics.Blit(temporary, temporary2);
			RenderTexture.ReleaseTemporary(temporary);
			separableBlurMaterial.SetVector("offsets", new Vector4(0f, blurSpread * 1f / (float)temporary2.height, 0f, 0f));
			RenderTexture temporary3 = RenderTexture.GetTemporary(width / 4, height / 4, 0);
			Graphics.Blit(temporary2, temporary3, separableBlurMaterial);
			RenderTexture.ReleaseTemporary(temporary2);
			separableBlurMaterial.SetVector("offsets", new Vector4(blurSpread * 1f / (float)temporary2.width, 0f, 0f, 0f));
			temporary2 = RenderTexture.GetTemporary(width / 4, height / 4, 0);
			Graphics.Blit(temporary3, temporary2, separableBlurMaterial);
			RenderTexture.ReleaseTemporary(temporary3);
			contrastCompositeMaterial.SetTexture("_MainTexBlurred", temporary2);
			contrastCompositeMaterial.SetFloat("intensity", intensity);
			contrastCompositeMaterial.SetFloat("threshhold", threshold);
			Graphics.Blit(source, destination, contrastCompositeMaterial);
			RenderTexture.ReleaseTemporary(temporary2);
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Image Effects/Color Adjustments/Contrast Stretch")]
	public class ContrastStretch : MonoBehaviour
	{
		public float adaptationSpeed = 0.02f;

		public float limitMinimum = 0.2f;

		public float limitMaximum = 0.6f;

		private RenderTexture[] adaptRenderTex = new RenderTexture[2];

		private int curAdaptIndex;

		public Shader shaderLum;

		private Material m_materialLum;

		public Shader shaderReduce;

		private Material m_materialReduce;

		public Shader shaderAdapt;

		private Material m_materialAdapt;

		public Shader shaderApply;

		private Material m_materialApply;

		protected Material materialLum
		{
			get
			{
				if (m_materialLum == null)
				{
					m_materialLum = new Material(shaderLum);
					m_materialLum.hideFlags = HideFlags.HideAndDontSave;
				}
				return m_materialLum;
			}
		}

		protected Material materialReduce
		{
			get
			{
				if (m_materialReduce == null)
				{
					m_materialReduce = new Material(shaderReduce);
					m_materialReduce.hideFlags = HideFlags.HideAndDontSave;
				}
				return m_materialReduce;
			}
		}

		protected Material materialAdapt
		{
			get
			{
				if (m_materialAdapt == null)
				{
					m_materialAdapt = new Material(shaderAdapt);
					m_materialAdapt.hideFlags = HideFlags.HideAndDontSave;
				}
				return m_materialAdapt;
			}
		}

		protected Material materialApply
		{
			get
			{
				if (m_materialApply == null)
				{
					m_materialApply = new Material(shaderApply);
					m_materialApply.hideFlags = HideFlags.HideAndDontSave;
				}
				return m_materialApply;
			}
		}

		private void Start()
		{
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
			else if (!shaderAdapt.isSupported || !shaderApply.isSupported || !shaderLum.isSupported || !shaderReduce.isSupported)
			{
				base.enabled = false;
			}
		}

		private void OnEnable()
		{
			for (int i = 0; i < 2; i++)
			{
				if (!adaptRenderTex[i])
				{
					adaptRenderTex[i] = new RenderTexture(1, 1, 0);
					adaptRenderTex[i].hideFlags = HideFlags.HideAndDontSave;
				}
			}
		}

		private void OnDisable()
		{
			for (int i = 0; i < 2; i++)
			{
				UnityEngine.Object.DestroyImmediate(adaptRenderTex[i]);
				adaptRenderTex[i] = null;
			}
			if ((bool)m_materialLum)
			{
				UnityEngine.Object.DestroyImmediate(m_materialLum);
			}
			if ((bool)m_materialReduce)
			{
				UnityEngine.Object.DestroyImmediate(m_materialReduce);
			}
			if ((bool)m_materialAdapt)
			{
				UnityEngine.Object.DestroyImmediate(m_materialAdapt);
			}
			if ((bool)m_materialApply)
			{
				UnityEngine.Object.DestroyImmediate(m_materialApply);
			}
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			RenderTexture renderTexture = RenderTexture.GetTemporary(source.width / 1, source.height / 1);
			Graphics.Blit(source, renderTexture, materialLum);
			while (renderTexture.width > 1 || renderTexture.height > 1)
			{
				int num = renderTexture.width / 2;
				if (num < 1)
				{
					num = 1;
				}
				int num2 = renderTexture.height / 2;
				if (num2 < 1)
				{
					num2 = 1;
				}
				RenderTexture temporary = RenderTexture.GetTemporary(num, num2);
				Graphics.Blit(renderTexture, temporary, materialReduce);
				RenderTexture.ReleaseTemporary(renderTexture);
				renderTexture = temporary;
			}
			CalculateAdaptation(renderTexture);
			materialApply.SetTexture("_AdaptTex", adaptRenderTex[curAdaptIndex]);
			Graphics.Blit(source, destination, materialApply);
			RenderTexture.ReleaseTemporary(renderTexture);
		}

		private void CalculateAdaptation(Texture curTexture)
		{
			int num = curAdaptIndex;
			curAdaptIndex = (curAdaptIndex + 1) % 2;
			float value = 1f - Mathf.Pow(1f - adaptationSpeed, 30f * Time.deltaTime);
			value = Mathf.Clamp(value, 0.01f, 1f);
			materialAdapt.SetTexture("_CurTex", curTexture);
			materialAdapt.SetVector("_AdaptParams", new Vector4(value, limitMinimum, limitMaximum, 0f));
			Graphics.SetRenderTarget(adaptRenderTex[curAdaptIndex]);
			GL.Clear(clearDepth: false, clearColor: true, Color.black);
			Graphics.Blit(adaptRenderTex[num], adaptRenderTex[curAdaptIndex], materialAdapt);
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Edge Detection/Crease Shading")]
	internal class CreaseShading : PostEffectsBase
	{
		public float intensity = 0.5f;

		public int softness = 1;

		public float spread = 1f;

		public Shader blurShader;

		private Material blurMaterial;

		public Shader depthFetchShader;

		private Material depthFetchMaterial;

		public Shader creaseApplyShader;

		private Material creaseApplyMaterial;

		public override bool CheckResources()
		{
			CheckSupport(needDepth: true);
			blurMaterial = CheckShaderAndCreateMaterial(blurShader, blurMaterial);
			depthFetchMaterial = CheckShaderAndCreateMaterial(depthFetchShader, depthFetchMaterial);
			creaseApplyMaterial = CheckShaderAndCreateMaterial(creaseApplyShader, creaseApplyMaterial);
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources())
			{
				Graphics.Blit(source, destination);
				return;
			}
			int width = source.width;
			int height = source.height;
			float num = 1f * (float)width / (1f * (float)height);
			float num2 = 0.001953125f;
			RenderTexture temporary = RenderTexture.GetTemporary(width, height, 0);
			RenderTexture renderTexture = RenderTexture.GetTemporary(width / 2, height / 2, 0);
			Graphics.Blit(source, temporary, depthFetchMaterial);
			Graphics.Blit(temporary, renderTexture);
			for (int i = 0; i < softness; i++)
			{
				RenderTexture temporary2 = RenderTexture.GetTemporary(width / 2, height / 2, 0);
				blurMaterial.SetVector("offsets", new Vector4(0f, spread * num2, 0f, 0f));
				Graphics.Blit(renderTexture, temporary2, blurMaterial);
				RenderTexture.ReleaseTemporary(renderTexture);
				renderTexture = temporary2;
				temporary2 = RenderTexture.GetTemporary(width / 2, height / 2, 0);
				blurMaterial.SetVector("offsets", new Vector4(spread * num2 / num, 0f, 0f, 0f));
				Graphics.Blit(renderTexture, temporary2, blurMaterial);
				RenderTexture.ReleaseTemporary(renderTexture);
				renderTexture = temporary2;
			}
			creaseApplyMaterial.SetTexture("_HrDepthTex", temporary);
			creaseApplyMaterial.SetTexture("_LrDepthTex", renderTexture);
			creaseApplyMaterial.SetFloat("intensity", intensity);
			Graphics.Blit(source, destination, creaseApplyMaterial);
			RenderTexture.ReleaseTemporary(temporary);
			RenderTexture.ReleaseTemporary(renderTexture);
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Camera/Depth of Field (Lens Blur, Scatter, DX11)")]
	public class DepthOfField : PostEffectsBase
	{
		public enum BlurType
		{
			DiscBlur,
			DX11
		}

		public enum BlurSampleCount
		{
			Low,
			Medium,
			High
		}

		public bool visualizeFocus;

		public float focalLength = 10f;

		public float focalSize = 0.05f;

		public float aperture = 11.5f;

		public Transform focalTransform;

		public float maxBlurSize = 2f;

		public bool highResolution;

		public BlurType blurType;

		public BlurSampleCount blurSampleCount = BlurSampleCount.High;

		public bool nearBlur;

		public float foregroundOverlap = 1f;

		public Shader dofHdrShader;

		private Material dofHdrMaterial;

		public Shader dx11BokehShader;

		private Material dx11bokehMaterial;

		public float dx11BokehThreshold = 0.5f;

		public float dx11SpawnHeuristic = 0.0875f;

		public Texture2D dx11BokehTexture;

		public float dx11BokehScale = 1.2f;

		public float dx11BokehIntensity = 2.5f;

		private float focalDistance01 = 10f;

		private ComputeBuffer cbDrawArgs;

		private ComputeBuffer cbPoints;

		private float internalBlurWidth = 1f;

		public override bool CheckResources()
		{
			CheckSupport(needDepth: true);
			dofHdrMaterial = CheckShaderAndCreateMaterial(dofHdrShader, dofHdrMaterial);
			if (supportDX11 && blurType == BlurType.DX11)
			{
				dx11bokehMaterial = CheckShaderAndCreateMaterial(dx11BokehShader, dx11bokehMaterial);
				CreateComputeResources();
			}
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		private void OnEnable()
		{
			GetComponent<Camera>().depthTextureMode |= DepthTextureMode.Depth;
		}

		private void OnDisable()
		{
			ReleaseComputeResources();
			if ((bool)dofHdrMaterial)
			{
				UnityEngine.Object.DestroyImmediate(dofHdrMaterial);
			}
			dofHdrMaterial = null;
			if ((bool)dx11bokehMaterial)
			{
				UnityEngine.Object.DestroyImmediate(dx11bokehMaterial);
			}
			dx11bokehMaterial = null;
		}

		private void ReleaseComputeResources()
		{
			if (cbDrawArgs != null)
			{
				cbDrawArgs.Release();
			}
			cbDrawArgs = null;
			if (cbPoints != null)
			{
				cbPoints.Release();
			}
			cbPoints = null;
		}

		private void CreateComputeResources()
		{
			if (cbDrawArgs == null)
			{
				cbDrawArgs = new ComputeBuffer(1, 16, ComputeBufferType.DrawIndirect);
				int[] data = new int[4] { 0, 1, 0, 0 };
				cbDrawArgs.SetData(data);
			}
			if (cbPoints == null)
			{
				cbPoints = new ComputeBuffer(90000, 28, ComputeBufferType.Append);
			}
		}

		private float FocalDistance01(float worldDist)
		{
			return GetComponent<Camera>().WorldToViewportPoint((worldDist - GetComponent<Camera>().nearClipPlane) * GetComponent<Camera>().transform.forward + GetComponent<Camera>().transform.position).z / (GetComponent<Camera>().farClipPlane - GetComponent<Camera>().nearClipPlane);
		}

		private void WriteCoc(RenderTexture fromTo, bool fgDilate)
		{
			dofHdrMaterial.SetTexture("_FgOverlap", null);
			if (nearBlur && fgDilate)
			{
				int width = fromTo.width / 2;
				int height = fromTo.height / 2;
				RenderTexture temporary = RenderTexture.GetTemporary(width, height, 0, fromTo.format);
				Graphics.Blit(fromTo, temporary, dofHdrMaterial, 4);
				float num = internalBlurWidth * foregroundOverlap;
				dofHdrMaterial.SetVector("_Offsets", new Vector4(0f, num, 0f, num));
				RenderTexture temporary2 = RenderTexture.GetTemporary(width, height, 0, fromTo.format);
				Graphics.Blit(temporary, temporary2, dofHdrMaterial, 2);
				RenderTexture.ReleaseTemporary(temporary);
				dofHdrMaterial.SetVector("_Offsets", new Vector4(num, 0f, 0f, num));
				temporary = RenderTexture.GetTemporary(width, height, 0, fromTo.format);
				Graphics.Blit(temporary2, temporary, dofHdrMaterial, 2);
				RenderTexture.ReleaseTemporary(temporary2);
				dofHdrMaterial.SetTexture("_FgOverlap", temporary);
				fromTo.MarkRestoreExpected();
				Graphics.Blit(fromTo, fromTo, dofHdrMaterial, 13);
				RenderTexture.ReleaseTemporary(temporary);
			}
			else
			{
				fromTo.MarkRestoreExpected();
				Graphics.Blit(fromTo, fromTo, dofHdrMaterial, 0);
			}
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources())
			{
				Graphics.Blit(source, destination);
				return;
			}
			if (aperture < 0f)
			{
				aperture = 0f;
			}
			if (maxBlurSize < 0.1f)
			{
				maxBlurSize = 0.1f;
			}
			focalSize = Mathf.Clamp(focalSize, 0f, 2f);
			internalBlurWidth = Mathf.Max(maxBlurSize, 0f);
			focalDistance01 = (focalTransform ? (GetComponent<Camera>().WorldToViewportPoint(focalTransform.position).z / GetComponent<Camera>().farClipPlane) : FocalDistance01(focalLength));
			dofHdrMaterial.SetVector("_CurveParams", new Vector4(1f, focalSize, aperture / 10f, focalDistance01));
			RenderTexture renderTexture = null;
			RenderTexture renderTexture2 = null;
			RenderTexture renderTexture3 = null;
			RenderTexture renderTexture4 = null;
			float num = internalBlurWidth * foregroundOverlap;
			if (visualizeFocus)
			{
				WriteCoc(source, fgDilate: true);
				Graphics.Blit(source, destination, dofHdrMaterial, 16);
			}
			else if (blurType == BlurType.DX11 && (bool)dx11bokehMaterial)
			{
				if (highResolution)
				{
					internalBlurWidth = ((internalBlurWidth < 0.1f) ? 0.1f : internalBlurWidth);
					num = internalBlurWidth * foregroundOverlap;
					renderTexture = RenderTexture.GetTemporary(source.width, source.height, 0, source.format);
					RenderTexture temporary = RenderTexture.GetTemporary(source.width, source.height, 0, source.format);
					WriteCoc(source, fgDilate: false);
					renderTexture3 = RenderTexture.GetTemporary(source.width >> 1, source.height >> 1, 0, source.format);
					renderTexture4 = RenderTexture.GetTemporary(source.width >> 1, source.height >> 1, 0, source.format);
					Graphics.Blit(source, renderTexture3, dofHdrMaterial, 15);
					dofHdrMaterial.SetVector("_Offsets", new Vector4(0f, 1.5f, 0f, 1.5f));
					Graphics.Blit(renderTexture3, renderTexture4, dofHdrMaterial, 19);
					dofHdrMaterial.SetVector("_Offsets", new Vector4(1.5f, 0f, 0f, 1.5f));
					Graphics.Blit(renderTexture4, renderTexture3, dofHdrMaterial, 19);
					if (nearBlur)
					{
						Graphics.Blit(source, renderTexture4, dofHdrMaterial, 4);
					}
					dx11bokehMaterial.SetTexture("_BlurredColor", renderTexture3);
					dx11bokehMaterial.SetFloat("_SpawnHeuristic", dx11SpawnHeuristic);
					dx11bokehMaterial.SetVector("_BokehParams", new Vector4(dx11BokehScale, dx11BokehIntensity, Mathf.Clamp(dx11BokehThreshold, 0.005f, 4f), internalBlurWidth));
					dx11bokehMaterial.SetTexture("_FgCocMask", nearBlur ? renderTexture4 : null);
					Graphics.SetRandomWriteTarget(1, cbPoints);
					Graphics.Blit(source, renderTexture, dx11bokehMaterial, 0);
					Graphics.ClearRandomWriteTargets();
					if (nearBlur)
					{
						dofHdrMaterial.SetVector("_Offsets", new Vector4(0f, num, 0f, num));
						Graphics.Blit(renderTexture4, renderTexture3, dofHdrMaterial, 2);
						dofHdrMaterial.SetVector("_Offsets", new Vector4(num, 0f, 0f, num));
						Graphics.Blit(renderTexture3, renderTexture4, dofHdrMaterial, 2);
						Graphics.Blit(renderTexture4, renderTexture, dofHdrMaterial, 3);
					}
					Graphics.Blit(renderTexture, temporary, dofHdrMaterial, 20);
					dofHdrMaterial.SetVector("_Offsets", new Vector4(internalBlurWidth, 0f, 0f, internalBlurWidth));
					Graphics.Blit(renderTexture, source, dofHdrMaterial, 5);
					dofHdrMaterial.SetVector("_Offsets", new Vector4(0f, internalBlurWidth, 0f, internalBlurWidth));
					Graphics.Blit(source, temporary, dofHdrMaterial, 21);
					Graphics.SetRenderTarget(temporary);
					ComputeBuffer.CopyCount(cbPoints, cbDrawArgs, 0);
					dx11bokehMaterial.SetBuffer("pointBuffer", cbPoints);
					dx11bokehMaterial.SetTexture("_MainTex", dx11BokehTexture);
					dx11bokehMaterial.SetVector("_Screen", new Vector3(1f / (1f * (float)source.width), 1f / (1f * (float)source.height), internalBlurWidth));
					dx11bokehMaterial.SetPass(2);
					Graphics.DrawProceduralIndirectNow(MeshTopology.Points, cbDrawArgs);
					Graphics.Blit(temporary, destination);
					RenderTexture.ReleaseTemporary(temporary);
					RenderTexture.ReleaseTemporary(renderTexture3);
					RenderTexture.ReleaseTemporary(renderTexture4);
				}
				else
				{
					renderTexture = RenderTexture.GetTemporary(source.width >> 1, source.height >> 1, 0, source.format);
					renderTexture2 = RenderTexture.GetTemporary(source.width >> 1, source.height >> 1, 0, source.format);
					num = internalBlurWidth * foregroundOverlap;
					WriteCoc(source, fgDilate: false);
					source.filterMode = FilterMode.Bilinear;
					Graphics.Blit(source, renderTexture, dofHdrMaterial, 6);
					renderTexture3 = RenderTexture.GetTemporary(renderTexture.width >> 1, renderTexture.height >> 1, 0, renderTexture.format);
					renderTexture4 = RenderTexture.GetTemporary(renderTexture.width >> 1, renderTexture.height >> 1, 0, renderTexture.format);
					Graphics.Blit(renderTexture, renderTexture3, dofHdrMaterial, 15);
					dofHdrMaterial.SetVector("_Offsets", new Vector4(0f, 1.5f, 0f, 1.5f));
					Graphics.Blit(renderTexture3, renderTexture4, dofHdrMaterial, 19);
					dofHdrMaterial.SetVector("_Offsets", new Vector4(1.5f, 0f, 0f, 1.5f));
					Graphics.Blit(renderTexture4, renderTexture3, dofHdrMaterial, 19);
					RenderTexture renderTexture5 = null;
					if (nearBlur)
					{
						renderTexture5 = RenderTexture.GetTemporary(source.width >> 1, source.height >> 1, 0, source.format);
						Graphics.Blit(source, renderTexture5, dofHdrMaterial, 4);
					}
					dx11bokehMaterial.SetTexture("_BlurredColor", renderTexture3);
					dx11bokehMaterial.SetFloat("_SpawnHeuristic", dx11SpawnHeuristic);
					dx11bokehMaterial.SetVector("_BokehParams", new Vector4(dx11BokehScale, dx11BokehIntensity, Mathf.Clamp(dx11BokehThreshold, 0.005f, 4f), internalBlurWidth));
					dx11bokehMaterial.SetTexture("_FgCocMask", renderTexture5);
					Graphics.SetRandomWriteTarget(1, cbPoints);
					Graphics.Blit(renderTexture, renderTexture2, dx11bokehMaterial, 0);
					Graphics.ClearRandomWriteTargets();
					RenderTexture.ReleaseTemporary(renderTexture3);
					RenderTexture.ReleaseTemporary(renderTexture4);
					if (nearBlur)
					{
						dofHdrMaterial.SetVector("_Offsets", new Vector4(0f, num, 0f, num));
						Graphics.Blit(renderTexture5, renderTexture, dofHdrMaterial, 2);
						dofHdrMaterial.SetVector("_Offsets", new Vector4(num, 0f, 0f, num));
						Graphics.Blit(renderTexture, renderTexture5, dofHdrMaterial, 2);
						Graphics.Blit(renderTexture5, renderTexture2, dofHdrMaterial, 3);
					}
					dofHdrMaterial.SetVector("_Offsets", new Vector4(internalBlurWidth, 0f, 0f, internalBlurWidth));
					Graphics.Blit(renderTexture2, renderTexture, dofHdrMaterial, 5);
					dofHdrMaterial.SetVector("_Offsets", new Vector4(0f, internalBlurWidth, 0f, internalBlurWidth));
					Graphics.Blit(renderTexture, renderTexture2, dofHdrMaterial, 5);
					Graphics.SetRenderTarget(renderTexture2);
					ComputeBuffer.CopyCount(cbPoints, cbDrawArgs, 0);
					dx11bokehMaterial.SetBuffer("pointBuffer", cbPoints);
					dx11bokehMaterial.SetTexture("_MainTex", dx11BokehTexture);
					dx11bokehMaterial.SetVector("_Screen", new Vector3(1f / (1f * (float)renderTexture2.width), 1f / (1f * (float)renderTexture2.height), internalBlurWidth));
					dx11bokehMaterial.SetPass(1);
					Graphics.DrawProceduralIndirectNow(MeshTopology.Points, cbDrawArgs);
					dofHdrMaterial.SetTexture("_LowRez", renderTexture2);
					dofHdrMaterial.SetTexture("_FgOverlap", renderTexture5);
					dofHdrMaterial.SetVector("_Offsets", 1f * (float)source.width / (1f * (float)renderTexture2.width) * internalBlurWidth * Vector4.one);
					Graphics.Blit(source, destination, dofHdrMaterial, 9);
					if ((bool)renderTexture5)
					{
						RenderTexture.ReleaseTemporary(renderTexture5);
					}
				}
			}
			else
			{
				source.filterMode = FilterMode.Bilinear;
				if (highResolution)
				{
					internalBlurWidth *= 2f;
				}
				WriteCoc(source, fgDilate: true);
				renderTexture = RenderTexture.GetTemporary(source.width >> 1, source.height >> 1, 0, source.format);
				renderTexture2 = RenderTexture.GetTemporary(source.width >> 1, source.height >> 1, 0, source.format);
				int pass = ((blurSampleCount == BlurSampleCount.High || blurSampleCount == BlurSampleCount.Medium) ? 17 : 11);
				if (highResolution)
				{
					dofHdrMaterial.SetVector("_Offsets", new Vector4(0f, internalBlurWidth, 0.025f, internalBlurWidth));
					Graphics.Blit(source, destination, dofHdrMaterial, pass);
				}
				else
				{
					dofHdrMaterial.SetVector("_Offsets", new Vector4(0f, internalBlurWidth, 0.1f, internalBlurWidth));
					Graphics.Blit(source, renderTexture, dofHdrMaterial, 6);
					Graphics.Blit(renderTexture, renderTexture2, dofHdrMaterial, pass);
					dofHdrMaterial.SetTexture("_LowRez", renderTexture2);
					dofHdrMaterial.SetTexture("_FgOverlap", null);
					dofHdrMaterial.SetVector("_Offsets", Vector4.one * (1f * (float)source.width / (1f * (float)renderTexture2.width)) * internalBlurWidth);
					Graphics.Blit(source, destination, dofHdrMaterial, (blurSampleCount == BlurSampleCount.High) ? 18 : 12);
				}
			}
			if ((bool)renderTexture)
			{
				RenderTexture.ReleaseTemporary(renderTexture);
			}
			if ((bool)renderTexture2)
			{
				RenderTexture.ReleaseTemporary(renderTexture2);
			}
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Camera/Depth of Field (deprecated)")]
	public class DepthOfFieldDeprecated : PostEffectsBase
	{
		public enum Dof34QualitySetting
		{
			OnlyBackground = 1,
			BackgroundAndForeground
		}

		public enum DofResolution
		{
			High = 2,
			Medium,
			Low
		}

		public enum DofBlurriness
		{
			Low = 1,
			High = 2,
			VeryHigh = 4
		}

		public enum BokehDestination
		{
			Background = 1,
			Foreground,
			BackgroundAndForeground
		}

		private static int SMOOTH_DOWNSAMPLE_PASS = 6;

		private static float BOKEH_EXTRA_BLUR = 2f;

		public Dof34QualitySetting quality = Dof34QualitySetting.OnlyBackground;

		public DofResolution resolution = DofResolution.Low;

		public bool simpleTweakMode = true;

		public float focalPoint = 1f;

		public float smoothness = 0.5f;

		public float focalZDistance;

		public float focalZStartCurve = 1f;

		public float focalZEndCurve = 1f;

		private float focalStartCurve = 2f;

		private float focalEndCurve = 2f;

		private float focalDistance01 = 0.1f;

		public Transform objectFocus;

		public float focalSize;

		public DofBlurriness bluriness = DofBlurriness.High;

		public float maxBlurSpread = 1.75f;

		public float foregroundBlurExtrude = 1.15f;

		public Shader dofBlurShader;

		private Material dofBlurMaterial;

		public Shader dofShader;

		private Material dofMaterial;

		public bool visualize;

		public BokehDestination bokehDestination = BokehDestination.Background;

		private float widthOverHeight = 1.25f;

		private float oneOverBaseSize = 0.001953125f;

		public bool bokeh;

		public bool bokehSupport = true;

		public Shader bokehShader;

		public Texture2D bokehTexture;

		public float bokehScale = 2.4f;

		public float bokehIntensity = 0.15f;

		public float bokehThresholdContrast = 0.1f;

		public float bokehThresholdLuminance = 0.55f;

		public int bokehDownsample = 1;

		private Material bokehMaterial;

		private Camera _camera;

		private RenderTexture foregroundTexture;

		private RenderTexture mediumRezWorkTexture;

		private RenderTexture finalDefocus;

		private RenderTexture lowRezWorkTexture;

		private RenderTexture bokehSource;

		private RenderTexture bokehSource2;

		private void CreateMaterials()
		{
			dofBlurMaterial = CheckShaderAndCreateMaterial(dofBlurShader, dofBlurMaterial);
			dofMaterial = CheckShaderAndCreateMaterial(dofShader, dofMaterial);
			bokehSupport = bokehShader.isSupported;
			if (bokeh && bokehSupport && (bool)bokehShader)
			{
				bokehMaterial = CheckShaderAndCreateMaterial(bokehShader, bokehMaterial);
			}
		}

		public override bool CheckResources()
		{
			CheckSupport(needDepth: true);
			dofBlurMaterial = CheckShaderAndCreateMaterial(dofBlurShader, dofBlurMaterial);
			dofMaterial = CheckShaderAndCreateMaterial(dofShader, dofMaterial);
			bokehSupport = bokehShader.isSupported;
			if (bokeh && bokehSupport && (bool)bokehShader)
			{
				bokehMaterial = CheckShaderAndCreateMaterial(bokehShader, bokehMaterial);
			}
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		private void OnDisable()
		{
			Quads.Cleanup();
		}

		private void OnEnable()
		{
			_camera = GetComponent<Camera>();
			_camera.depthTextureMode |= DepthTextureMode.Depth;
		}

		private float FocalDistance01(float worldDist)
		{
			return _camera.WorldToViewportPoint((worldDist - _camera.nearClipPlane) * _camera.transform.forward + _camera.transform.position).z / (_camera.farClipPlane - _camera.nearClipPlane);
		}

		private int GetDividerBasedOnQuality()
		{
			int result = 1;
			if (resolution == DofResolution.Medium)
			{
				result = 2;
			}
			else if (resolution == DofResolution.Low)
			{
				result = 2;
			}
			return result;
		}

		private int GetLowResolutionDividerBasedOnQuality(int baseDivider)
		{
			int num = baseDivider;
			if (resolution == DofResolution.High)
			{
				num *= 2;
			}
			if (resolution == DofResolution.Low)
			{
				num *= 2;
			}
			return num;
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources())
			{
				Graphics.Blit(source, destination);
				return;
			}
			if (smoothness < 0.1f)
			{
				smoothness = 0.1f;
			}
			bokeh = bokeh && bokehSupport;
			float num = (bokeh ? BOKEH_EXTRA_BLUR : 1f);
			bool flag = quality > Dof34QualitySetting.OnlyBackground;
			float num2 = focalSize / (_camera.farClipPlane - _camera.nearClipPlane);
			if (simpleTweakMode)
			{
				focalDistance01 = (objectFocus ? (_camera.WorldToViewportPoint(objectFocus.position).z / _camera.farClipPlane) : FocalDistance01(focalPoint));
				focalStartCurve = focalDistance01 * smoothness;
				focalEndCurve = focalStartCurve;
				flag = flag && focalPoint > _camera.nearClipPlane + Mathf.Epsilon;
			}
			else
			{
				if ((bool)objectFocus)
				{
					Vector3 vector = _camera.WorldToViewportPoint(objectFocus.position);
					vector.z /= _camera.farClipPlane;
					focalDistance01 = vector.z;
				}
				else
				{
					focalDistance01 = FocalDistance01(focalZDistance);
				}
				focalStartCurve = focalZStartCurve;
				focalEndCurve = focalZEndCurve;
				flag = flag && focalPoint > _camera.nearClipPlane + Mathf.Epsilon;
			}
			widthOverHeight = 1f * (float)source.width / (1f * (float)source.height);
			oneOverBaseSize = 0.001953125f;
			dofMaterial.SetFloat("_ForegroundBlurExtrude", foregroundBlurExtrude);
			dofMaterial.SetVector("_CurveParams", new Vector4(simpleTweakMode ? (1f / focalStartCurve) : focalStartCurve, simpleTweakMode ? (1f / focalEndCurve) : focalEndCurve, num2 * 0.5f, focalDistance01));
			dofMaterial.SetVector("_InvRenderTargetSize", new Vector4(1f / (1f * (float)source.width), 1f / (1f * (float)source.height), 0f, 0f));
			int dividerBasedOnQuality = GetDividerBasedOnQuality();
			int lowResolutionDividerBasedOnQuality = GetLowResolutionDividerBasedOnQuality(dividerBasedOnQuality);
			AllocateTextures(flag, source, dividerBasedOnQuality, lowResolutionDividerBasedOnQuality);
			Graphics.Blit(source, source, dofMaterial, 3);
			Downsample(source, mediumRezWorkTexture);
			Blur(mediumRezWorkTexture, mediumRezWorkTexture, DofBlurriness.Low, 4, maxBlurSpread);
			if (bokeh && (BokehDestination.Foreground & bokehDestination) != 0)
			{
				dofMaterial.SetVector("_Threshhold", new Vector4(bokehThresholdContrast, bokehThresholdLuminance, 0.95f, 0f));
				Graphics.Blit(mediumRezWorkTexture, bokehSource2, dofMaterial, 11);
				Graphics.Blit(mediumRezWorkTexture, lowRezWorkTexture);
				Blur(lowRezWorkTexture, lowRezWorkTexture, bluriness, 0, maxBlurSpread * num);
			}
			else
			{
				Downsample(mediumRezWorkTexture, lowRezWorkTexture);
				Blur(lowRezWorkTexture, lowRezWorkTexture, bluriness, 0, maxBlurSpread);
			}
			dofBlurMaterial.SetTexture("_TapLow", lowRezWorkTexture);
			dofBlurMaterial.SetTexture("_TapMedium", mediumRezWorkTexture);
			Graphics.Blit(null, finalDefocus, dofBlurMaterial, 3);
			if (bokeh && (BokehDestination.Foreground & bokehDestination) != 0)
			{
				AddBokeh(bokehSource2, bokehSource, finalDefocus);
			}
			dofMaterial.SetTexture("_TapLowBackground", finalDefocus);
			dofMaterial.SetTexture("_TapMedium", mediumRezWorkTexture);
			Graphics.Blit(source, flag ? foregroundTexture : destination, dofMaterial, visualize ? 2 : 0);
			if (flag)
			{
				Graphics.Blit(foregroundTexture, source, dofMaterial, 5);
				Downsample(source, mediumRezWorkTexture);
				BlurFg(mediumRezWorkTexture, mediumRezWorkTexture, DofBlurriness.Low, 2, maxBlurSpread);
				if (bokeh && (BokehDestination.Foreground & bokehDestination) != 0)
				{
					dofMaterial.SetVector("_Threshhold", new Vector4(bokehThresholdContrast * 0.5f, bokehThresholdLuminance, 0f, 0f));
					Graphics.Blit(mediumRezWorkTexture, bokehSource2, dofMaterial, 11);
					Graphics.Blit(mediumRezWorkTexture, lowRezWorkTexture);
					BlurFg(lowRezWorkTexture, lowRezWorkTexture, bluriness, 1, maxBlurSpread * num);
				}
				else
				{
					BlurFg(mediumRezWorkTexture, lowRezWorkTexture, bluriness, 1, maxBlurSpread);
				}
				Graphics.Blit(lowRezWorkTexture, finalDefocus);
				dofMaterial.SetTexture("_TapLowForeground", finalDefocus);
				Graphics.Blit(source, destination, dofMaterial, visualize ? 1 : 4);
				if (bokeh && (BokehDestination.Foreground & bokehDestination) != 0)
				{
					AddBokeh(bokehSource2, bokehSource, destination);
				}
			}
			ReleaseTextures();
		}

		private void Blur(RenderTexture from, RenderTexture to, DofBlurriness iterations, int blurPass, float spread)
		{
			RenderTexture temporary = RenderTexture.GetTemporary(to.width, to.height);
			if (iterations > DofBlurriness.Low)
			{
				BlurHex(from, to, blurPass, spread, temporary);
				if (iterations > DofBlurriness.High)
				{
					dofBlurMaterial.SetVector("offsets", new Vector4(0f, spread * oneOverBaseSize, 0f, 0f));
					Graphics.Blit(to, temporary, dofBlurMaterial, blurPass);
					dofBlurMaterial.SetVector("offsets", new Vector4(spread / widthOverHeight * oneOverBaseSize, 0f, 0f, 0f));
					Graphics.Blit(temporary, to, dofBlurMaterial, blurPass);
				}
			}
			else
			{
				dofBlurMaterial.SetVector("offsets", new Vector4(0f, spread * oneOverBaseSize, 0f, 0f));
				Graphics.Blit(from, temporary, dofBlurMaterial, blurPass);
				dofBlurMaterial.SetVector("offsets", new Vector4(spread / widthOverHeight * oneOverBaseSize, 0f, 0f, 0f));
				Graphics.Blit(temporary, to, dofBlurMaterial, blurPass);
			}
			RenderTexture.ReleaseTemporary(temporary);
		}

		private void BlurFg(RenderTexture from, RenderTexture to, DofBlurriness iterations, int blurPass, float spread)
		{
			dofBlurMaterial.SetTexture("_TapHigh", from);
			RenderTexture temporary = RenderTexture.GetTemporary(to.width, to.height);
			if (iterations > DofBlurriness.Low)
			{
				BlurHex(from, to, blurPass, spread, temporary);
				if (iterations > DofBlurriness.High)
				{
					dofBlurMaterial.SetVector("offsets", new Vector4(0f, spread * oneOverBaseSize, 0f, 0f));
					Graphics.Blit(to, temporary, dofBlurMaterial, blurPass);
					dofBlurMaterial.SetVector("offsets", new Vector4(spread / widthOverHeight * oneOverBaseSize, 0f, 0f, 0f));
					Graphics.Blit(temporary, to, dofBlurMaterial, blurPass);
				}
			}
			else
			{
				dofBlurMaterial.SetVector("offsets", new Vector4(0f, spread * oneOverBaseSize, 0f, 0f));
				Graphics.Blit(from, temporary, dofBlurMaterial, blurPass);
				dofBlurMaterial.SetVector("offsets", new Vector4(spread / widthOverHeight * oneOverBaseSize, 0f, 0f, 0f));
				Graphics.Blit(temporary, to, dofBlurMaterial, blurPass);
			}
			RenderTexture.ReleaseTemporary(temporary);
		}

		private void BlurHex(RenderTexture from, RenderTexture to, int blurPass, float spread, RenderTexture tmp)
		{
			dofBlurMaterial.SetVector("offsets", new Vector4(0f, spread * oneOverBaseSize, 0f, 0f));
			Graphics.Blit(from, tmp, dofBlurMaterial, blurPass);
			dofBlurMaterial.SetVector("offsets", new Vector4(spread / widthOverHeight * oneOverBaseSize, 0f, 0f, 0f));
			Graphics.Blit(tmp, to, dofBlurMaterial, blurPass);
			dofBlurMaterial.SetVector("offsets", new Vector4(spread / widthOverHeight * oneOverBaseSize, spread * oneOverBaseSize, 0f, 0f));
			Graphics.Blit(to, tmp, dofBlurMaterial, blurPass);
			dofBlurMaterial.SetVector("offsets", new Vector4(spread / widthOverHeight * oneOverBaseSize, (0f - spread) * oneOverBaseSize, 0f, 0f));
			Graphics.Blit(tmp, to, dofBlurMaterial, blurPass);
		}

		private void Downsample(RenderTexture from, RenderTexture to)
		{
			dofMaterial.SetVector("_InvRenderTargetSize", new Vector4(1f / (1f * (float)to.width), 1f / (1f * (float)to.height), 0f, 0f));
			Graphics.Blit(from, to, dofMaterial, SMOOTH_DOWNSAMPLE_PASS);
		}

		private void AddBokeh(RenderTexture bokehInfo, RenderTexture tempTex, RenderTexture finalTarget)
		{
			if (!bokehMaterial)
			{
				return;
			}
			Mesh[] meshes = Quads.GetMeshes(tempTex.width, tempTex.height);
			RenderTexture.active = tempTex;
			GL.Clear(clearDepth: false, clearColor: true, new Color(0f, 0f, 0f, 0f));
			GL.PushMatrix();
			GL.LoadIdentity();
			bokehInfo.filterMode = FilterMode.Point;
			float num = (float)bokehInfo.width * 1f / ((float)bokehInfo.height * 1f);
			float num2 = 2f / (1f * (float)bokehInfo.width);
			num2 += bokehScale * maxBlurSpread * BOKEH_EXTRA_BLUR * oneOverBaseSize;
			bokehMaterial.SetTexture("_Source", bokehInfo);
			bokehMaterial.SetTexture("_MainTex", bokehTexture);
			bokehMaterial.SetVector("_ArScale", new Vector4(num2, num2 * num, 0.5f, 0.5f * num));
			bokehMaterial.SetFloat("_Intensity", bokehIntensity);
			bokehMaterial.SetPass(0);
			Mesh[] array = meshes;
			foreach (Mesh mesh in array)
			{
				if ((bool)mesh)
				{
					Graphics.DrawMeshNow(mesh, Matrix4x4.identity);
				}
			}
			GL.PopMatrix();
			Graphics.Blit(tempTex, finalTarget, dofMaterial, 8);
			bokehInfo.filterMode = FilterMode.Bilinear;
		}

		private void ReleaseTextures()
		{
			if ((bool)foregroundTexture)
			{
				RenderTexture.ReleaseTemporary(foregroundTexture);
			}
			if ((bool)finalDefocus)
			{
				RenderTexture.ReleaseTemporary(finalDefocus);
			}
			if ((bool)mediumRezWorkTexture)
			{
				RenderTexture.ReleaseTemporary(mediumRezWorkTexture);
			}
			if ((bool)lowRezWorkTexture)
			{
				RenderTexture.ReleaseTemporary(lowRezWorkTexture);
			}
			if ((bool)bokehSource)
			{
				RenderTexture.ReleaseTemporary(bokehSource);
			}
			if ((bool)bokehSource2)
			{
				RenderTexture.ReleaseTemporary(bokehSource2);
			}
		}

		private void AllocateTextures(bool blurForeground, RenderTexture source, int divider, int lowTexDivider)
		{
			foregroundTexture = null;
			if (blurForeground)
			{
				foregroundTexture = RenderTexture.GetTemporary(source.width, source.height, 0);
			}
			mediumRezWorkTexture = RenderTexture.GetTemporary(source.width / divider, source.height / divider, 0);
			finalDefocus = RenderTexture.GetTemporary(source.width / divider, source.height / divider, 0);
			lowRezWorkTexture = RenderTexture.GetTemporary(source.width / lowTexDivider, source.height / lowTexDivider, 0);
			bokehSource = null;
			bokehSource2 = null;
			if (bokeh)
			{
				bokehSource = RenderTexture.GetTemporary(source.width / (lowTexDivider * bokehDownsample), source.height / (lowTexDivider * bokehDownsample), 0, RenderTextureFormat.ARGBHalf);
				bokehSource2 = RenderTexture.GetTemporary(source.width / (lowTexDivider * bokehDownsample), source.height / (lowTexDivider * bokehDownsample), 0, RenderTextureFormat.ARGBHalf);
				bokehSource.filterMode = FilterMode.Bilinear;
				bokehSource2.filterMode = FilterMode.Bilinear;
				RenderTexture.active = bokehSource2;
				GL.Clear(clearDepth: false, clearColor: true, new Color(0f, 0f, 0f, 0f));
			}
			source.filterMode = FilterMode.Bilinear;
			finalDefocus.filterMode = FilterMode.Bilinear;
			mediumRezWorkTexture.filterMode = FilterMode.Bilinear;
			lowRezWorkTexture.filterMode = FilterMode.Bilinear;
			if ((bool)foregroundTexture)
			{
				foregroundTexture.filterMode = FilterMode.Bilinear;
			}
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Edge Detection/Edge Detection")]
	public class EdgeDetection : PostEffectsBase
	{
		public enum EdgeDetectMode
		{
			TriangleDepthNormals,
			RobertsCrossDepthNormals,
			SobelDepth,
			SobelDepthThin,
			TriangleLuminance
		}

		public EdgeDetectMode mode = EdgeDetectMode.SobelDepthThin;

		public float sensitivityDepth = 1f;

		public float sensitivityNormals = 1f;

		public float lumThreshold = 0.2f;

		public float edgeExp = 1f;

		public float sampleDist = 1f;

		public float edgesOnly;

		public Color edgesOnlyBgColor = Color.white;

		public Shader edgeDetectShader;

		private Material edgeDetectMaterial;

		private EdgeDetectMode oldMode = EdgeDetectMode.SobelDepthThin;

		public override bool CheckResources()
		{
			CheckSupport(needDepth: true);
			edgeDetectMaterial = CheckShaderAndCreateMaterial(edgeDetectShader, edgeDetectMaterial);
			if (mode != oldMode)
			{
				SetCameraFlag();
			}
			oldMode = mode;
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		private new void Start()
		{
			oldMode = mode;
		}

		private void SetCameraFlag()
		{
			if (mode == EdgeDetectMode.SobelDepth || mode == EdgeDetectMode.SobelDepthThin)
			{
				GetComponent<Camera>().depthTextureMode |= DepthTextureMode.Depth;
			}
			else if (mode == EdgeDetectMode.TriangleDepthNormals || mode == EdgeDetectMode.RobertsCrossDepthNormals)
			{
				GetComponent<Camera>().depthTextureMode |= DepthTextureMode.DepthNormals;
			}
		}

		private void OnEnable()
		{
			SetCameraFlag();
		}

		[ImageEffectOpaque]
		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources())
			{
				Graphics.Blit(source, destination);
				return;
			}
			Vector2 vector = new Vector2(sensitivityDepth, sensitivityNormals);
			edgeDetectMaterial.SetVector("_Sensitivity", new Vector4(vector.x, vector.y, 1f, vector.y));
			edgeDetectMaterial.SetFloat("_BgFade", edgesOnly);
			edgeDetectMaterial.SetFloat("_SampleDistance", sampleDist);
			edgeDetectMaterial.SetVector("_BgColor", edgesOnlyBgColor);
			edgeDetectMaterial.SetFloat("_Exponent", edgeExp);
			edgeDetectMaterial.SetFloat("_Threshold", lumThreshold);
			Graphics.Blit(source, destination, edgeDetectMaterial, (int)mode);
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Displacement/Fisheye")]
	internal class Fisheye : PostEffectsBase
	{
		public float strengthX = 0.05f;

		public float strengthY = 0.05f;

		public Shader fishEyeShader;

		private Material fisheyeMaterial;

		public override bool CheckResources()
		{
			CheckSupport(needDepth: false);
			fisheyeMaterial = CheckShaderAndCreateMaterial(fishEyeShader, fisheyeMaterial);
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources())
			{
				Graphics.Blit(source, destination);
				return;
			}
			float num = 5f / 32f;
			float num2 = (float)source.width * 1f / ((float)source.height * 1f);
			fisheyeMaterial.SetVector("intensity", new Vector4(strengthX * num2 * num, strengthY * num, strengthX * num2 * num, strengthY * num));
			Graphics.Blit(source, destination, fisheyeMaterial);
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Rendering/Global Fog")]
	internal class GlobalFog : PostEffectsBase
	{
		[Tooltip("Apply distance-based fog?")]
		public bool distanceFog = true;

		[Tooltip("Distance fog is based on radial distance from camera when checked")]
		public bool useRadialDistance;

		[Tooltip("Apply height-based fog?")]
		public bool heightFog = true;

		[Tooltip("Fog top Y coordinate")]
		public float height = 1f;

		[Range(0.001f, 10f)]
		public float heightDensity = 2f;

		[Tooltip("Push fog away from the camera by this amount")]
		public float startDistance;

		public Shader fogShader;

		private Material fogMaterial;

		public override bool CheckResources()
		{
			CheckSupport(needDepth: true);
			fogMaterial = CheckShaderAndCreateMaterial(fogShader, fogMaterial);
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		[ImageEffectOpaque]
		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources() || (!distanceFog && !heightFog))
			{
				Graphics.Blit(source, destination);
				return;
			}
			Camera component = GetComponent<Camera>();
			Transform transform = component.transform;
			float nearClipPlane = component.nearClipPlane;
			float farClipPlane = component.farClipPlane;
			float fieldOfView = component.fieldOfView;
			float aspect = component.aspect;
			Matrix4x4 identity = Matrix4x4.identity;
			float num = fieldOfView * 0.5f;
			Vector3 vector = transform.right * nearClipPlane * Mathf.Tan(num * (MathF.PI / 180f)) * aspect;
			Vector3 vector2 = transform.up * nearClipPlane * Mathf.Tan(num * (MathF.PI / 180f));
			Vector3 vector3 = transform.forward * nearClipPlane - vector + vector2;
			float num2 = vector3.magnitude * farClipPlane / nearClipPlane;
			vector3.Normalize();
			vector3 *= num2;
			Vector3 vector4 = transform.forward * nearClipPlane + vector + vector2;
			vector4.Normalize();
			vector4 *= num2;
			Vector3 vector5 = transform.forward * nearClipPlane + vector - vector2;
			vector5.Normalize();
			vector5 *= num2;
			Vector3 vector6 = transform.forward * nearClipPlane - vector - vector2;
			vector6.Normalize();
			vector6 *= num2;
			identity.SetRow(0, vector3);
			identity.SetRow(1, vector4);
			identity.SetRow(2, vector5);
			identity.SetRow(3, vector6);
			Vector3 position = transform.position;
			float num3 = position.y - height;
			float z = ((num3 <= 0f) ? 1f : 0f);
			fogMaterial.SetMatrix("_FrustumCornersWS", identity);
			fogMaterial.SetVector("_CameraWS", position);
			fogMaterial.SetVector("_HeightParams", new Vector4(height, num3, z, heightDensity * 0.5f));
			fogMaterial.SetVector("_DistanceParams", new Vector4(0f - Mathf.Max(startDistance, 0f), 0f, 0f, 0f));
			FogMode fogMode = RenderSettings.fogMode;
			float fogDensity = RenderSettings.fogDensity;
			float fogStartDistance = RenderSettings.fogStartDistance;
			float fogEndDistance = RenderSettings.fogEndDistance;
			bool flag = fogMode == FogMode.Linear;
			float num4 = (flag ? (fogEndDistance - fogStartDistance) : 0f);
			float num5 = ((Mathf.Abs(num4) > 0.0001f) ? (1f / num4) : 0f);
			Vector4 value = default(Vector4);
			value.x = fogDensity * 1.2011224f;
			value.y = fogDensity * 1.442695f;
			value.z = (flag ? (0f - num5) : 0f);
			value.w = (flag ? (fogEndDistance * num5) : 0f);
			fogMaterial.SetVector("_SceneFogParams", value);
			fogMaterial.SetVector("_SceneFogMode", new Vector4((float)fogMode, useRadialDistance ? 1 : 0, 0f, 0f));
			int num6 = 0;
			CustomGraphicsBlit(passNr: (!distanceFog || !heightFog) ? (distanceFog ? 1 : 2) : 0, source: source, dest: destination, fxMaterial: fogMaterial);
		}

		private static void CustomGraphicsBlit(RenderTexture source, RenderTexture dest, Material fxMaterial, int passNr)
		{
			RenderTexture.active = dest;
			fxMaterial.SetTexture("_MainTex", source);
			GL.PushMatrix();
			GL.LoadOrtho();
			fxMaterial.SetPass(passNr);
			GL.Begin(7);
			GL.MultiTexCoord2(0, 0f, 0f);
			GL.Vertex3(0f, 0f, 3f);
			GL.MultiTexCoord2(0, 1f, 0f);
			GL.Vertex3(1f, 0f, 2f);
			GL.MultiTexCoord2(0, 1f, 1f);
			GL.Vertex3(1f, 1f, 1f);
			GL.MultiTexCoord2(0, 0f, 1f);
			GL.Vertex3(0f, 1f, 0f);
			GL.End();
			GL.PopMatrix();
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Image Effects/Color Adjustments/Grayscale")]
	public class Grayscale : ImageEffectBase
	{
		public Texture textureRamp;

		public float rampOffset;

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			base.material.SetTexture("_RampTex", textureRamp);
			base.material.SetFloat("_RampOffset", rampOffset);
			Graphics.Blit(source, destination, base.material);
		}
	}
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("")]
	public class ImageEffectBase : MonoBehaviour
	{
		public Shader shader;

		private Material m_Material;

		protected Material material
		{
			get
			{
				if (m_Material == null)
				{
					m_Material = new Material(shader);
					m_Material.hideFlags = HideFlags.HideAndDontSave;
				}
				return m_Material;
			}
		}

		protected virtual void Start()
		{
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
			else if (!shader || !shader.isSupported)
			{
				base.enabled = false;
			}
		}

		protected virtual void OnDisable()
		{
			if ((bool)m_Material)
			{
				UnityEngine.Object.DestroyImmediate(m_Material);
			}
		}
	}
	[AddComponentMenu("")]
	public class ImageEffects
	{
		public static void RenderDistortion(Material material, RenderTexture source, RenderTexture destination, float angle, Vector2 center, Vector2 radius)
		{
			if (source.texelSize.y < 0f)
			{
				center.y = 1f - center.y;
				angle = 0f - angle;
			}
			Matrix4x4 value = Matrix4x4.TRS(Vector3.zero, Quaternion.Euler(0f, 0f, angle), Vector3.one);
			material.SetMatrix("_RotationMatrix", value);
			material.SetVector("_CenterRadius", new Vector4(center.x, center.y, radius.x, radius.y));
			material.SetFloat("_Angle", angle * (MathF.PI / 180f));
			Graphics.Blit(source, destination, material);
		}

		[Obsolete("Use Graphics.Blit(source,dest) instead")]
		public static void Blit(RenderTexture source, RenderTexture dest)
		{
			Graphics.Blit(source, dest);
		}

		[Obsolete("Use Graphics.Blit(source, destination, material) instead")]
		public static void BlitWithMaterial(Material material, RenderTexture source, RenderTexture dest)
		{
			Graphics.Blit(source, dest, material);
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Image Effects/Blur/Motion Blur (Color Accumulation)")]
	[RequireComponent(typeof(Camera))]
	public class MotionBlur : ImageEffectBase
	{
		public float blurAmount = 0.8f;

		public bool extraBlur;

		private RenderTexture accumTexture;

		protected override void Start()
		{
			if (!SystemInfo.supportsRenderTextures)
			{
				base.enabled = false;
			}
			else
			{
				base.Start();
			}
		}

		protected override void OnDisable()
		{
			base.OnDisable();
			UnityEngine.Object.DestroyImmediate(accumTexture);
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (accumTexture == null || accumTexture.width != source.width || accumTexture.height != source.height)
			{
				UnityEngine.Object.DestroyImmediate(accumTexture);
				accumTexture = new RenderTexture(source.width, source.height, 0);
				accumTexture.hideFlags = HideFlags.HideAndDontSave;
				Graphics.Blit(source, accumTexture);
			}
			if (extraBlur)
			{
				RenderTexture temporary = RenderTexture.GetTemporary(source.width / 4, source.height / 4, 0);
				accumTexture.MarkRestoreExpected();
				Graphics.Blit(accumTexture, temporary);
				Graphics.Blit(temporary, accumTexture);
				RenderTexture.ReleaseTemporary(temporary);
			}
			blurAmount = Mathf.Clamp(blurAmount, 0f, 0.92f);
			base.material.SetTexture("_MainTex", accumTexture);
			base.material.SetFloat("_AccumOrig", 1f - blurAmount);
			accumTexture.MarkRestoreExpected();
			Graphics.Blit(source, accumTexture, base.material);
			Graphics.Blit(accumTexture, destination);
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Noise/Noise And Grain (Filmic)")]
	public class NoiseAndGrain : PostEffectsBase
	{
		public float intensityMultiplier = 0.25f;

		public float generalIntensity = 0.5f;

		public float blackIntensity = 1f;

		public float whiteIntensity = 1f;

		public float midGrey = 0.2f;

		public bool dx11Grain;

		public float softness;

		public bool monochrome;

		public Vector3 intensities = new Vector3(1f, 1f, 1f);

		public Vector3 tiling = new Vector3(64f, 64f, 64f);

		public float monochromeTiling = 64f;

		public FilterMode filterMode = FilterMode.Bilinear;

		public Texture2D noiseTexture;

		public Shader noiseShader;

		private Material noiseMaterial;

		public Shader dx11NoiseShader;

		private Material dx11NoiseMaterial;

		private static float TILE_AMOUNT = 64f;

		public override bool CheckResources()
		{
			CheckSupport(needDepth: false);
			noiseMaterial = CheckShaderAndCreateMaterial(noiseShader, noiseMaterial);
			if (dx11Grain && supportDX11)
			{
				dx11NoiseMaterial = CheckShaderAndCreateMaterial(dx11NoiseShader, dx11NoiseMaterial);
			}
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources() || null == noiseTexture)
			{
				Graphics.Blit(source, destination);
				if (null == noiseTexture)
				{
					UnityEngine.Debug.LogWarning("Noise & Grain effect failing as noise texture is not assigned. please assign.", base.transform);
				}
				return;
			}
			softness = Mathf.Clamp(softness, 0f, 0.99f);
			if (dx11Grain && supportDX11)
			{
				dx11NoiseMaterial.SetFloat("_DX11NoiseTime", Time.frameCount);
				dx11NoiseMaterial.SetTexture("_NoiseTex", noiseTexture);
				dx11NoiseMaterial.SetVector("_NoisePerChannel", monochrome ? Vector3.one : intensities);
				dx11NoiseMaterial.SetVector("_MidGrey", new Vector3(midGrey, 1f / (1f - midGrey), -1f / midGrey));
				dx11NoiseMaterial.SetVector("_NoiseAmount", new Vector3(generalIntensity, blackIntensity, whiteIntensity) * intensityMultiplier);
				if (softness > Mathf.Epsilon)
				{
					RenderTexture temporary = RenderTexture.GetTemporary((int)((float)source.width * (1f - softness)), (int)((float)source.height * (1f - softness)));
					DrawNoiseQuadGrid(source, temporary, dx11NoiseMaterial, noiseTexture, monochrome ? 3 : 2);
					dx11NoiseMaterial.SetTexture("_NoiseTex", temporary);
					Graphics.Blit(source, destination, dx11NoiseMaterial, 4);
					RenderTexture.ReleaseTemporary(temporary);
				}
				else
				{
					DrawNoiseQuadGrid(source, destination, dx11NoiseMaterial, noiseTexture, monochrome ? 1 : 0);
				}
				return;
			}
			if ((bool)noiseTexture)
			{
				noiseTexture.wrapMode = TextureWrapMode.Repeat;
				noiseTexture.filterMode = filterMode;
			}
			noiseMaterial.SetTexture("_NoiseTex", noiseTexture);
			noiseMaterial.SetVector("_NoisePerChannel", monochrome ? Vector3.one : intensities);
			noiseMaterial.SetVector("_NoiseTilingPerChannel", monochrome ? (Vector3.one * monochromeTiling) : tiling);
			noiseMaterial.SetVector("_MidGrey", new Vector3(midGrey, 1f / (1f - midGrey), -1f / midGrey));
			noiseMaterial.SetVector("_NoiseAmount", new Vector3(generalIntensity, blackIntensity, whiteIntensity) * intensityMultiplier);
			if (softness > Mathf.Epsilon)
			{
				RenderTexture temporary2 = RenderTexture.GetTemporary((int)((float)source.width * (1f - softness)), (int)((float)source.height * (1f - softness)));
				DrawNoiseQuadGrid(source, temporary2, noiseMaterial, noiseTexture, 2);
				noiseMaterial.SetTexture("_NoiseTex", temporary2);
				Graphics.Blit(source, destination, noiseMaterial, 1);
				RenderTexture.ReleaseTemporary(temporary2);
			}
			else
			{
				DrawNoiseQuadGrid(source, destination, noiseMaterial, noiseTexture, 0);
			}
		}

		private static void DrawNoiseQuadGrid(RenderTexture source, RenderTexture dest, Material fxMaterial, Texture2D noise, int passNr)
		{
			RenderTexture.active = dest;
			float num = (float)noise.width * 1f;
			float num2 = 1f * (float)source.width / TILE_AMOUNT;
			fxMaterial.SetTexture("_MainTex", source);
			GL.PushMatrix();
			GL.LoadOrtho();
			float num3 = 1f * (float)source.width / (1f * (float)source.height);
			float num4 = 1f / num2;
			float num5 = num4 * num3;
			float num6 = num / ((float)noise.width * 1f);
			fxMaterial.SetPass(passNr);
			GL.Begin(7);
			for (float num7 = 0f; num7 < 1f; num7 += num4)
			{
				for (float num8 = 0f; num8 < 1f; num8 += num5)
				{
					float num9 = UnityEngine.Random.Range(0f, 1f);
					float num10 = UnityEngine.Random.Range(0f, 1f);
					num9 = Mathf.Floor(num9 * num) / num;
					num10 = Mathf.Floor(num10 * num) / num;
					float num11 = 1f / num;
					GL.MultiTexCoord2(0, num9, num10);
					GL.MultiTexCoord2(1, 0f, 0f);
					GL.Vertex3(num7, num8, 0.1f);
					GL.MultiTexCoord2(0, num9 + num6 * num11, num10);
					GL.MultiTexCoord2(1, 1f, 0f);
					GL.Vertex3(num7 + num4, num8, 0.1f);
					GL.MultiTexCoord2(0, num9 + num6 * num11, num10 + num6 * num11);
					GL.MultiTexCoord2(1, 1f, 1f);
					GL.Vertex3(num7 + num4, num8 + num5, 0.1f);
					GL.MultiTexCoord2(0, num9, num10 + num6 * num11);
					GL.MultiTexCoord2(1, 0f, 1f);
					GL.Vertex3(num7, num8 + num5, 0.1f);
				}
			}
			GL.End();
			GL.PopMatrix();
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Noise/Noise and Scratches")]
	public class NoiseAndScratches : MonoBehaviour
	{
		public bool monochrome = true;

		private bool rgbFallback;

		public float grainIntensityMin = 0.1f;

		public float grainIntensityMax = 0.2f;

		public float grainSize = 2f;

		public float scratchIntensityMin = 0.05f;

		public float scratchIntensityMax = 0.25f;

		public float scratchFPS = 10f;

		public float scratchJitter = 0.01f;

		public Texture grainTexture;

		public Texture scratchTexture;

		public Shader shaderRGB;

		public Shader shaderYUV;

		private Material m_MaterialRGB;

		private Material m_MaterialYUV;

		private float scratchTimeLeft;

		private float scratchX;

		private float scratchY;

		protected Material material
		{
			get
			{
				if (m_MaterialRGB == null)
				{
					m_MaterialRGB = new Material(shaderRGB);
					m_MaterialRGB.hideFlags = HideFlags.HideAndDontSave;
				}
				if (m_MaterialYUV == null && !rgbFallback)
				{
					m_MaterialYUV = new Material(shaderYUV);
					m_MaterialYUV.hideFlags = HideFlags.HideAndDontSave;
				}
				if (rgbFallback || monochrome)
				{
					return m_MaterialRGB;
				}
				return m_MaterialYUV;
			}
		}

		protected void Start()
		{
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
			else if (shaderRGB == null || shaderYUV == null)
			{
				UnityEngine.Debug.Log("Noise shaders are not set up! Disabling noise effect.");
				base.enabled = false;
			}
			else if (!shaderRGB.isSupported)
			{
				base.enabled = false;
			}
			else if (!shaderYUV.isSupported)
			{
				rgbFallback = true;
			}
		}

		protected void OnDisable()
		{
			if ((bool)m_MaterialRGB)
			{
				UnityEngine.Object.DestroyImmediate(m_MaterialRGB);
			}
			if ((bool)m_MaterialYUV)
			{
				UnityEngine.Object.DestroyImmediate(m_MaterialYUV);
			}
		}

		private void SanitizeParameters()
		{
			grainIntensityMin = Mathf.Clamp(grainIntensityMin, 0f, 5f);
			grainIntensityMax = Mathf.Clamp(grainIntensityMax, 0f, 5f);
			scratchIntensityMin = Mathf.Clamp(scratchIntensityMin, 0f, 5f);
			scratchIntensityMax = Mathf.Clamp(scratchIntensityMax, 0f, 5f);
			scratchFPS = Mathf.Clamp(scratchFPS, 1f, 30f);
			scratchJitter = Mathf.Clamp(scratchJitter, 0f, 1f);
			grainSize = Mathf.Clamp(grainSize, 0.1f, 50f);
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			SanitizeParameters();
			if (scratchTimeLeft <= 0f)
			{
				scratchTimeLeft = UnityEngine.Random.value * 2f / scratchFPS;
				scratchX = UnityEngine.Random.value;
				scratchY = UnityEngine.Random.value;
			}
			scratchTimeLeft -= Time.deltaTime;
			Material material = this.material;
			material.SetTexture("_GrainTex", grainTexture);
			material.SetTexture("_ScratchTex", scratchTexture);
			float num = 1f / grainSize;
			material.SetVector("_GrainOffsetScale", new Vector4(UnityEngine.Random.value, UnityEngine.Random.value, (float)UnityEngine.Screen.width / (float)grainTexture.width * num, (float)UnityEngine.Screen.height / (float)grainTexture.height * num));
			material.SetVector("_ScratchOffsetScale", new Vector4(scratchX + UnityEngine.Random.value * scratchJitter, scratchY + UnityEngine.Random.value * scratchJitter, (float)UnityEngine.Screen.width / (float)scratchTexture.width, (float)UnityEngine.Screen.height / (float)scratchTexture.height));
			material.SetVector("_Intensity", new Vector4(UnityEngine.Random.Range(grainIntensityMin, grainIntensityMax), UnityEngine.Random.Range(scratchIntensityMin, scratchIntensityMax), 0f, 0f));
			Graphics.Blit(source, destination, material);
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	public class PostEffectsBase : MonoBehaviour
	{
		protected bool supportHDRTextures = true;

		protected bool supportDX11;

		protected bool isSupported = true;

		protected Material CheckShaderAndCreateMaterial(Shader s, Material m2Create)
		{
			if (!s)
			{
				UnityEngine.Debug.Log("Missing shader in " + ToString());
				base.enabled = false;
				return null;
			}
			if (s.isSupported && (bool)m2Create && m2Create.shader == s)
			{
				return m2Create;
			}
			if (!s.isSupported)
			{
				NotSupported();
				UnityEngine.Debug.Log("The shader " + s.ToString() + " on effect " + ToString() + " is not supported on this platform!");
				return null;
			}
			m2Create = new Material(s);
			m2Create.hideFlags = HideFlags.DontSave;
			if ((bool)m2Create)
			{
				return m2Create;
			}
			return null;
		}

		protected Material CreateMaterial(Shader s, Material m2Create)
		{
			if (!s)
			{
				UnityEngine.Debug.Log("Missing shader in " + ToString());
				return null;
			}
			if ((bool)m2Create && m2Create.shader == s && s.isSupported)
			{
				return m2Create;
			}
			if (!s.isSupported)
			{
				return null;
			}
			m2Create = new Material(s);
			m2Create.hideFlags = HideFlags.DontSave;
			if ((bool)m2Create)
			{
				return m2Create;
			}
			return null;
		}

		private void OnEnable()
		{
			isSupported = true;
		}

		protected bool CheckSupport()
		{
			return CheckSupport(needDepth: false);
		}

		public virtual bool CheckResources()
		{
			UnityEngine.Debug.LogWarning("CheckResources () for " + ToString() + " should be overwritten.");
			return isSupported;
		}

		protected void Start()
		{
			CheckResources();
		}

		protected bool CheckSupport(bool needDepth)
		{
			isSupported = true;
			supportHDRTextures = SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.ARGBHalf);
			supportDX11 = SystemInfo.graphicsShaderLevel >= 50 && SystemInfo.supportsComputeShaders;
			if (!SystemInfo.supportsImageEffects || !SystemInfo.supportsRenderTextures)
			{
				NotSupported();
				return false;
			}
			if (needDepth && !SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.Depth))
			{
				NotSupported();
				return false;
			}
			if (needDepth)
			{
				GetComponent<Camera>().depthTextureMode |= DepthTextureMode.Depth;
			}
			return true;
		}

		protected bool CheckSupport(bool needDepth, bool needHdr)
		{
			if (!CheckSupport(needDepth))
			{
				return false;
			}
			if (needHdr && !supportHDRTextures)
			{
				NotSupported();
				return false;
			}
			return true;
		}

		public bool Dx11Support()
		{
			return supportDX11;
		}

		protected void ReportAutoDisable()
		{
			UnityEngine.Debug.LogWarning("The image effect " + ToString() + " has been disabled as it's not supported on the current platform.");
		}

		private bool CheckShader(Shader s)
		{
			UnityEngine.Debug.Log("The shader " + s.ToString() + " on effect " + ToString() + " is not part of the Unity 3.2+ effects suite anymore. For best performance and quality, please ensure you are using the latest Standard Assets Image Effects (Pro only) package.");
			if (!s.isSupported)
			{
				NotSupported();
				return false;
			}
			return false;
		}

		protected void NotSupported()
		{
			base.enabled = false;
			isSupported = false;
		}

		protected void DrawBorder(RenderTexture dest, Material material)
		{
			RenderTexture.active = dest;
			bool flag = true;
			GL.PushMatrix();
			GL.LoadOrtho();
			for (int i = 0; i < material.passCount; i++)
			{
				material.SetPass(i);
				float y;
				float y2;
				if (flag)
				{
					y = 1f;
					y2 = 0f;
				}
				else
				{
					y = 0f;
					y2 = 1f;
				}
				float x = 0f + 1f / ((float)dest.width * 1f);
				float y3 = 0f;
				float y4 = 1f;
				GL.Begin(7);
				GL.TexCoord2(0f, y);
				GL.Vertex3(0f, y3, 0.1f);
				GL.TexCoord2(1f, y);
				GL.Vertex3(x, y3, 0.1f);
				GL.TexCoord2(1f, y2);
				GL.Vertex3(x, y4, 0.1f);
				GL.TexCoord2(0f, y2);
				GL.Vertex3(0f, y4, 0.1f);
				float x2 = 1f - 1f / ((float)dest.width * 1f);
				x = 1f;
				y3 = 0f;
				y4 = 1f;
				GL.TexCoord2(0f, y);
				GL.Vertex3(x2, y3, 0.1f);
				GL.TexCoord2(1f, y);
				GL.Vertex3(x, y3, 0.1f);
				GL.TexCoord2(1f, y2);
				GL.Vertex3(x, y4, 0.1f);
				GL.TexCoord2(0f, y2);
				GL.Vertex3(x2, y4, 0.1f);
				x = 1f;
				y3 = 0f;
				y4 = 0f + 1f / ((float)dest.height * 1f);
				GL.TexCoord2(0f, y);
				GL.Vertex3(0f, y3, 0.1f);
				GL.TexCoord2(1f, y);
				GL.Vertex3(x, y3, 0.1f);
				GL.TexCoord2(1f, y2);
				GL.Vertex3(x, y4, 0.1f);
				GL.TexCoord2(0f, y2);
				GL.Vertex3(0f, y4, 0.1f);
				x = 1f;
				y3 = 1f - 1f / ((float)dest.height * 1f);
				y4 = 1f;
				GL.TexCoord2(0f, y);
				GL.Vertex3(0f, y3, 0.1f);
				GL.TexCoord2(1f, y);
				GL.Vertex3(x, y3, 0.1f);
				GL.TexCoord2(1f, y2);
				GL.Vertex3(x, y4, 0.1f);
				GL.TexCoord2(0f, y2);
				GL.Vertex3(0f, y4, 0.1f);
				GL.End();
			}
			GL.PopMatrix();
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	internal class PostEffectsHelper : MonoBehaviour
	{
		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			UnityEngine.Debug.Log("OnRenderImage in Helper called ...");
		}

		private static void DrawLowLevelPlaneAlignedWithCamera(float dist, RenderTexture source, RenderTexture dest, Material material, Camera cameraForProjectionMatrix)
		{
			RenderTexture.active = dest;
			material.SetTexture("_MainTex", source);
			bool flag = true;
			GL.PushMatrix();
			GL.LoadIdentity();
			GL.LoadProjectionMatrix(cameraForProjectionMatrix.projectionMatrix);
			float f = cameraForProjectionMatrix.fieldOfView * 0.5f * (MathF.PI / 180f);
			float num = Mathf.Cos(f) / Mathf.Sin(f);
			float aspect = cameraForProjectionMatrix.aspect;
			float num2 = aspect / (0f - num);
			float num3 = aspect / num;
			float num4 = 1f / (0f - num);
			float num5 = 1f / num;
			float num6 = 1f;
			num2 *= dist * num6;
			num3 *= dist * num6;
			num4 *= dist * num6;
			num5 *= dist * num6;
			float z = 0f - dist;
			for (int i = 0; i < material.passCount; i++)
			{
				material.SetPass(i);
				GL.Begin(7);
				float y;
				float y2;
				if (flag)
				{
					y = 1f;
					y2 = 0f;
				}
				else
				{
					y = 0f;
					y2 = 1f;
				}
				GL.TexCoord2(0f, y);
				GL.Vertex3(num2, num4, z);
				GL.TexCoord2(1f, y);
				GL.Vertex3(num3, num4, z);
				GL.TexCoord2(1f, y2);
				GL.Vertex3(num3, num5, z);
				GL.TexCoord2(0f, y2);
				GL.Vertex3(num2, num5, z);
				GL.End();
			}
			GL.PopMatrix();
		}

		private static void DrawBorder(RenderTexture dest, Material material)
		{
			RenderTexture.active = dest;
			bool flag = true;
			GL.PushMatrix();
			GL.LoadOrtho();
			for (int i = 0; i < material.passCount; i++)
			{
				material.SetPass(i);
				float y;
				float y2;
				if (flag)
				{
					y = 1f;
					y2 = 0f;
				}
				else
				{
					y = 0f;
					y2 = 1f;
				}
				float x = 0f + 1f / ((float)dest.width * 1f);
				float y3 = 0f;
				float y4 = 1f;
				GL.Begin(7);
				GL.TexCoord2(0f, y);
				GL.Vertex3(0f, y3, 0.1f);
				GL.TexCoord2(1f, y);
				GL.Vertex3(x, y3, 0.1f);
				GL.TexCoord2(1f, y2);
				GL.Vertex3(x, y4, 0.1f);
				GL.TexCoord2(0f, y2);
				GL.Vertex3(0f, y4, 0.1f);
				float x2 = 1f - 1f / ((float)dest.width * 1f);
				x = 1f;
				y3 = 0f;
				y4 = 1f;
				GL.TexCoord2(0f, y);
				GL.Vertex3(x2, y3, 0.1f);
				GL.TexCoord2(1f, y);
				GL.Vertex3(x, y3, 0.1f);
				GL.TexCoord2(1f, y2);
				GL.Vertex3(x, y4, 0.1f);
				GL.TexCoord2(0f, y2);
				GL.Vertex3(x2, y4, 0.1f);
				x = 1f;
				y3 = 0f;
				y4 = 0f + 1f / ((float)dest.height * 1f);
				GL.TexCoord2(0f, y);
				GL.Vertex3(0f, y3, 0.1f);
				GL.TexCoord2(1f, y);
				GL.Vertex3(x, y3, 0.1f);
				GL.TexCoord2(1f, y2);
				GL.Vertex3(x, y4, 0.1f);
				GL.TexCoord2(0f, y2);
				GL.Vertex3(0f, y4, 0.1f);
				x = 1f;
				y3 = 1f - 1f / ((float)dest.height * 1f);
				y4 = 1f;
				GL.TexCoord2(0f, y);
				GL.Vertex3(0f, y3, 0.1f);
				GL.TexCoord2(1f, y);
				GL.Vertex3(x, y3, 0.1f);
				GL.TexCoord2(1f, y2);
				GL.Vertex3(x, y4, 0.1f);
				GL.TexCoord2(0f, y2);
				GL.Vertex3(0f, y4, 0.1f);
				GL.End();
			}
			GL.PopMatrix();
		}

		private static void DrawLowLevelQuad(float x1, float x2, float y1, float y2, RenderTexture source, RenderTexture dest, Material material)
		{
			RenderTexture.active = dest;
			material.SetTexture("_MainTex", source);
			bool flag = true;
			GL.PushMatrix();
			GL.LoadOrtho();
			for (int i = 0; i < material.passCount; i++)
			{
				material.SetPass(i);
				GL.Begin(7);
				float y3;
				float y4;
				if (flag)
				{
					y3 = 1f;
					y4 = 0f;
				}
				else
				{
					y3 = 0f;
					y4 = 1f;
				}
				GL.TexCoord2(0f, y3);
				GL.Vertex3(x1, y1, 0.1f);
				GL.TexCoord2(1f, y3);
				GL.Vertex3(x2, y1, 0.1f);
				GL.TexCoord2(1f, y4);
				GL.Vertex3(x2, y2, 0.1f);
				GL.TexCoord2(0f, y4);
				GL.Vertex3(x1, y2, 0.1f);
				GL.End();
			}
			GL.PopMatrix();
		}
	}
	internal class Quads
	{
		private static Mesh[] meshes;

		private static int currentQuads;

		private static bool HasMeshes()
		{
			if (meshes == null)
			{
				return false;
			}
			Mesh[] array = meshes;
			foreach (Mesh mesh in array)
			{
				if (null == mesh)
				{
					return false;
				}
			}
			return true;
		}

		public static void Cleanup()
		{
			if (meshes == null)
			{
				return;
			}
			for (int i = 0; i < meshes.Length; i++)
			{
				if (null != meshes[i])
				{
					UnityEngine.Object.DestroyImmediate(meshes[i]);
					meshes[i] = null;
				}
			}
			meshes = null;
		}

		public static Mesh[] GetMeshes(int totalWidth, int totalHeight)
		{
			if (HasMeshes() && currentQuads == totalWidth * totalHeight)
			{
				return meshes;
			}
			int num = 10833;
			int num2 = (currentQuads = totalWidth * totalHeight);
			meshes = new Mesh[Mathf.CeilToInt(1f * (float)num2 / (1f * (float)num))];
			int num3 = 0;
			int num4 = 0;
			for (num3 = 0; num3 < num2; num3 += num)
			{
				int triCount = Mathf.FloorToInt(Mathf.Clamp(num2 - num3, 0, num));
				meshes[num4] = GetMesh(triCount, num3, totalWidth, totalHeight);
				num4++;
			}
			return meshes;
		}

		private static Mesh GetMesh(int triCount, int triOffset, int totalWidth, int totalHeight)
		{
			Mesh mesh = new Mesh();
			mesh.hideFlags = HideFlags.DontSave;
			Vector3[] array = new Vector3[triCount * 4];
			Vector2[] array2 = new Vector2[triCount * 4];
			Vector2[] array3 = new Vector2[triCount * 4];
			int[] array4 = new int[triCount * 6];
			for (int i = 0; i < triCount; i++)
			{
				int num = i * 4;
				int num2 = i * 6;
				int num3 = triOffset + i;
				float num4 = Mathf.Floor(num3 % totalWidth) / (float)totalWidth;
				float num5 = Mathf.Floor(num3 / totalWidth) / (float)totalHeight;
				array[num + 3] = (array[num + 2] = (array[num + 1] = (array[num] = new Vector3(num4 * 2f - 1f, num5 * 2f - 1f, 1f))));
				array2[num] = new Vector2(0f, 0f);
				array2[num + 1] = new Vector2(1f, 0f);
				array2[num + 2] = new Vector2(0f, 1f);
				array2[num + 3] = new Vector2(1f, 1f);
				array3[num] = new Vector2(num4, num5);
				array3[num + 1] = new Vector2(num4, num5);
				array3[num + 2] = new Vector2(num4, num5);
				array3[num + 3] = new Vector2(num4, num5);
				array4[num2] = num;
				array4[num2 + 1] = num + 1;
				array4[num2 + 2] = num + 2;
				array4[num2 + 3] = num + 1;
				array4[num2 + 4] = num + 2;
				array4[num2 + 5] = num + 3;
			}
			mesh.vertices = array;
			mesh.triangles = array4;
			mesh.uv = array2;
			mesh.uv2 = array3;
			return mesh;
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Other/Screen Overlay")]
	public class ScreenOverlay : PostEffectsBase
	{
		public enum OverlayBlendMode
		{
			Additive,
			ScreenBlend,
			Multiply,
			Overlay,
			AlphaBlend
		}

		public OverlayBlendMode blendMode = OverlayBlendMode.Overlay;

		public float intensity = 1f;

		public Texture2D texture;

		public Shader overlayShader;

		private Material overlayMaterial;

		public override bool CheckResources()
		{
			CheckSupport(needDepth: false);
			overlayMaterial = CheckShaderAndCreateMaterial(overlayShader, overlayMaterial);
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources())
			{
				Graphics.Blit(source, destination);
				return;
			}
			Vector4 value = new Vector4(1f, 0f, 0f, 1f);
			overlayMaterial.SetVector("_UV_Transform", value);
			overlayMaterial.SetFloat("_Intensity", intensity);
			overlayMaterial.SetTexture("_Overlay", texture);
			Graphics.Blit(source, destination, overlayMaterial, (int)blendMode);
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Rendering/Screen Space Ambient Obscurance")]
	internal class ScreenSpaceAmbientObscurance : PostEffectsBase
	{
		[Range(0f, 3f)]
		public float intensity = 0.5f;

		[Range(0.1f, 3f)]
		public float radius = 0.2f;

		[Range(0f, 3f)]
		public int blurIterations = 1;

		[Range(0f, 5f)]
		public float blurFilterDistance = 1.25f;

		[Range(0f, 1f)]
		public int downsample;

		public Texture2D rand;

		public Shader aoShader;

		private Material aoMaterial;

		public override bool CheckResources()
		{
			CheckSupport(needDepth: true);
			aoMaterial = CheckShaderAndCreateMaterial(aoShader, aoMaterial);
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		private void OnDisable()
		{
			if ((bool)aoMaterial)
			{
				UnityEngine.Object.DestroyImmediate(aoMaterial);
			}
			aoMaterial = null;
		}

		[ImageEffectOpaque]
		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources())
			{
				Graphics.Blit(source, destination);
				return;
			}
			Matrix4x4 projectionMatrix = GetComponent<Camera>().projectionMatrix;
			Matrix4x4 inverse = projectionMatrix.inverse;
			Vector4 value = new Vector4(-2f / ((float)UnityEngine.Screen.width * projectionMatrix[0]), -2f / ((float)UnityEngine.Screen.height * projectionMatrix[5]), (1f - projectionMatrix[2]) / projectionMatrix[0], (1f + projectionMatrix[6]) / projectionMatrix[5]);
			aoMaterial.SetVector("_ProjInfo", value);
			aoMaterial.SetMatrix("_ProjectionInv", inverse);
			aoMaterial.SetTexture("_Rand", rand);
			aoMaterial.SetFloat("_Radius", radius);
			aoMaterial.SetFloat("_Radius2", radius * radius);
			aoMaterial.SetFloat("_Intensity", intensity);
			aoMaterial.SetFloat("_BlurFilterDistance", blurFilterDistance);
			int width = source.width;
			int height = source.height;
			RenderTexture renderTexture = RenderTexture.GetTemporary(width >> downsample, height >> downsample);
			Graphics.Blit(source, renderTexture, aoMaterial, 0);
			if (downsample > 0)
			{
				RenderTexture temporary = RenderTexture.GetTemporary(width, height);
				Graphics.Blit(renderTexture, temporary, aoMaterial, 4);
				RenderTexture.ReleaseTemporary(renderTexture);
				renderTexture = temporary;
			}
			for (int i = 0; i < blurIterations; i++)
			{
				aoMaterial.SetVector("_Axis", new Vector2(1f, 0f));
				RenderTexture temporary = RenderTexture.GetTemporary(width, height);
				Graphics.Blit(renderTexture, temporary, aoMaterial, 1);
				RenderTexture.ReleaseTemporary(renderTexture);
				aoMaterial.SetVector("_Axis", new Vector2(0f, 1f));
				renderTexture = RenderTexture.GetTemporary(width, height);
				Graphics.Blit(temporary, renderTexture, aoMaterial, 1);
				RenderTexture.ReleaseTemporary(temporary);
			}
			aoMaterial.SetTexture("_AOTex", renderTexture);
			Graphics.Blit(source, destination, aoMaterial, 2);
			RenderTexture.ReleaseTemporary(renderTexture);
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Rendering/Screen Space Ambient Occlusion")]
	public class ScreenSpaceAmbientOcclusion : MonoBehaviour
	{
		public enum SSAOSamples
		{
			Low,
			Medium,
			High
		}

		public float m_Radius = 0.4f;

		public SSAOSamples m_SampleCount = SSAOSamples.Medium;

		public float m_OcclusionIntensity = 1.5f;

		public int m_Blur = 2;

		public int m_Downsampling = 2;

		public float m_OcclusionAttenuation = 1f;

		public float m_MinZ = 0.01f;

		public Shader m_SSAOShader;

		private Material m_SSAOMaterial;

		public Texture2D m_RandomTexture;

		private bool m_Supported;

		private static Material CreateMaterial(Shader shader)
		{
			if (!shader)
			{
				return null;
			}
			return new Material(shader)
			{
				hideFlags = HideFlags.HideAndDontSave
			};
		}

		private static void DestroyMaterial(Material mat)
		{
			if ((bool)mat)
			{
				UnityEngine.Object.DestroyImmediate(mat);
				mat = null;
			}
		}

		private void OnDisable()
		{
			DestroyMaterial(m_SSAOMaterial);
		}

		private void Start()
		{
			if (!SystemInfo.supportsImageEffects || !SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.Depth))
			{
				m_Supported = false;
				base.enabled = false;
				return;
			}
			CreateMaterials();
			if (!m_SSAOMaterial || m_SSAOMaterial.passCount != 5)
			{
				m_Supported = false;
				base.enabled = false;
			}
			else
			{
				m_Supported = true;
			}
		}

		private void OnEnable()
		{
			GetComponent<Camera>().depthTextureMode |= DepthTextureMode.DepthNormals;
		}

		private void CreateMaterials()
		{
			if (!m_SSAOMaterial && m_SSAOShader.isSupported)
			{
				m_SSAOMaterial = CreateMaterial(m_SSAOShader);
				m_SSAOMaterial.SetTexture("_RandomTexture", m_RandomTexture);
			}
		}

		[ImageEffectOpaque]
		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!m_Supported || !m_SSAOShader.isSupported)
			{
				base.enabled = false;
				return;
			}
			CreateMaterials();
			m_Downsampling = Mathf.Clamp(m_Downsampling, 1, 6);
			m_Radius = Mathf.Clamp(m_Radius, 0.05f, 1f);
			m_MinZ = Mathf.Clamp(m_MinZ, 1E-05f, 0.5f);
			m_OcclusionIntensity = Mathf.Clamp(m_OcclusionIntensity, 0.5f, 4f);
			m_OcclusionAttenuation = Mathf.Clamp(m_OcclusionAttenuation, 0.2f, 2f);
			m_Blur = Mathf.Clamp(m_Blur, 0, 4);
			RenderTexture renderTexture = RenderTexture.GetTemporary(source.width / m_Downsampling, source.height / m_Downsampling, 0);
			float fieldOfView = GetComponent<Camera>().fieldOfView;
			float farClipPlane = GetComponent<Camera>().farClipPlane;
			float num = Mathf.Tan(fieldOfView * (MathF.PI / 180f) * 0.5f) * farClipPlane;
			float x = num * GetComponent<Camera>().aspect;
			m_SSAOMaterial.SetVector("_FarCorner", new Vector3(x, num, farClipPlane));
			int num2;
			int num3;
			if ((bool)m_RandomTexture)
			{
				num2 = m_RandomTexture.width;
				num3 = m_RandomTexture.height;
			}
			else
			{
				num2 = 1;
				num3 = 1;
			}
			m_SSAOMaterial.SetVector("_NoiseScale", new Vector3((float)renderTexture.width / (float)num2, (float)renderTexture.height / (float)num3, 0f));
			m_SSAOMaterial.SetVector("_Params", new Vector4(m_Radius, m_MinZ, 1f / m_OcclusionAttenuation, m_OcclusionIntensity));
			bool num4 = m_Blur > 0;
			Graphics.Blit(num4 ? null : source, renderTexture, m_SSAOMaterial, (int)m_SampleCount);
			if (num4)
			{
				RenderTexture temporary = RenderTexture.GetTemporary(source.width, source.height, 0);
				m_SSAOMaterial.SetVector("_TexelOffsetScale", new Vector4((float)m_Blur / (float)source.width, 0f, 0f, 0f));
				m_SSAOMaterial.SetTexture("_SSAO", renderTexture);
				Graphics.Blit(null, temporary, m_SSAOMaterial, 3);
				RenderTexture.ReleaseTemporary(renderTexture);
				RenderTexture temporary2 = RenderTexture.GetTemporary(source.width, source.height, 0);
				m_SSAOMaterial.SetVector("_TexelOffsetScale", new Vector4(0f, (float)m_Blur / (float)source.height, 0f, 0f));
				m_SSAOMaterial.SetTexture("_SSAO", temporary);
				Graphics.Blit(source, temporary2, m_SSAOMaterial, 3);
				RenderTexture.ReleaseTemporary(temporary);
				renderTexture = temporary2;
			}
			m_SSAOMaterial.SetTexture("_SSAO", renderTexture);
			Graphics.Blit(source, destination, m_SSAOMaterial, 4);
			RenderTexture.ReleaseTemporary(renderTexture);
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Image Effects/Color Adjustments/Sepia Tone")]
	public class SepiaTone : ImageEffectBase
	{
		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			Graphics.Blit(source, destination, base.material);
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Rendering/Sun Shafts")]
	public class SunShafts : PostEffectsBase
	{
		public enum SunShaftsResolution
		{
			Low,
			Normal,
			High
		}

		public enum ShaftsScreenBlendMode
		{
			Screen,
			Add
		}

		public SunShaftsResolution resolution = SunShaftsResolution.Normal;

		public ShaftsScreenBlendMode screenBlendMode;

		public Transform sunTransform;

		public int radialBlurIterations = 2;

		public Color sunColor = Color.white;

		public Color sunThreshold = new Color(0.87f, 0.74f, 0.65f);

		public float sunShaftBlurRadius = 2.5f;

		public float sunShaftIntensity = 1.15f;

		public float maxRadius = 0.75f;

		public bool useDepthTexture = true;

		public Shader sunShaftsShader;

		private Material sunShaftsMaterial;

		public Shader simpleClearShader;

		private Material simpleClearMaterial;

		public override bool CheckResources()
		{
			CheckSupport(useDepthTexture);
			sunShaftsMaterial = CheckShaderAndCreateMaterial(sunShaftsShader, sunShaftsMaterial);
			simpleClearMaterial = CheckShaderAndCreateMaterial(simpleClearShader, simpleClearMaterial);
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources())
			{
				Graphics.Blit(source, destination);
				return;
			}
			if (useDepthTexture)
			{
				GetComponent<Camera>().depthTextureMode |= DepthTextureMode.Depth;
			}
			int num = 4;
			if (resolution == SunShaftsResolution.Normal)
			{
				num = 2;
			}
			else if (resolution == SunShaftsResolution.High)
			{
				num = 1;
			}
			Vector3 vector = Vector3.one * 0.5f;
			vector = ((!sunTransform) ? new Vector3(0.5f, 0.5f, 0f) : GetComponent<Camera>().WorldToViewportPoint(sunTransform.position));
			int width = source.width / num;
			int height = source.height / num;
			RenderTexture temporary = RenderTexture.GetTemporary(width, height, 0);
			sunShaftsMaterial.SetVector("_BlurRadius4", new Vector4(1f, 1f, 0f, 0f) * sunShaftBlurRadius);
			sunShaftsMaterial.SetVector("_SunPosition", new Vector4(vector.x, vector.y, vector.z, maxRadius));
			sunShaftsMaterial.SetVector("_SunThreshold", sunThreshold);
			if (!useDepthTexture)
			{
				RenderTextureFormat format = (GetComponent<Camera>().allowHDR ? RenderTextureFormat.DefaultHDR : RenderTextureFormat.Default);
				RenderTexture renderTexture = (RenderTexture.active = RenderTexture.GetTemporary(source.width, source.height, 0, format));
				GL.ClearWithSkybox(clearDepth: false, GetComponent<Camera>());
				sunShaftsMaterial.SetTexture("_Skybox", renderTexture);
				Graphics.Blit(source, temporary, sunShaftsMaterial, 3);
				RenderTexture.ReleaseTemporary(renderTexture);
			}
			else
			{
				Graphics.Blit(source, temporary, sunShaftsMaterial, 2);
			}
			DrawBorder(temporary, simpleClearMaterial);
			radialBlurIterations = Mathf.Clamp(radialBlurIterations, 1, 4);
			float num2 = sunShaftBlurRadius * 0.0013020834f;
			sunShaftsMaterial.SetVector("_BlurRadius4", new Vector4(num2, num2, 0f, 0f));
			sunShaftsMaterial.SetVector("_SunPosition", new Vector4(vector.x, vector.y, vector.z, maxRadius));
			for (int i = 0; i < radialBlurIterations; i++)
			{
				RenderTexture temporary3 = RenderTexture.GetTemporary(width, height, 0);
				Graphics.Blit(temporary, temporary3, sunShaftsMaterial, 1);
				RenderTexture.ReleaseTemporary(temporary);
				num2 = sunShaftBlurRadius * (((float)i * 2f + 1f) * 6f) / 768f;
				sunShaftsMaterial.SetVector("_BlurRadius4", new Vector4(num2, num2, 0f, 0f));
				temporary = RenderTexture.GetTemporary(width, height, 0);
				Graphics.Blit(temporary3, temporary, sunShaftsMaterial, 1);
				RenderTexture.ReleaseTemporary(temporary3);
				num2 = sunShaftBlurRadius * (((float)i * 2f + 2f) * 6f) / 768f;
				sunShaftsMaterial.SetVector("_BlurRadius4", new Vector4(num2, num2, 0f, 0f));
			}
			if (vector.z >= 0f)
			{
				sunShaftsMaterial.SetVector("_SunColor", new Vector4(sunColor.r, sunColor.g, sunColor.b, sunColor.a) * sunShaftIntensity);
			}
			else
			{
				sunShaftsMaterial.SetVector("_SunColor", Vector4.zero);
			}
			sunShaftsMaterial.SetTexture("_ColorBuffer", temporary);
			Graphics.Blit(source, destination, sunShaftsMaterial, (screenBlendMode != 0) ? 4 : 0);
			RenderTexture.ReleaseTemporary(temporary);
		}
	}
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Camera/Tilt Shift (Lens Blur)")]
	internal class TiltShift : PostEffectsBase
	{
		public enum TiltShiftMode
		{
			TiltShiftMode,
			IrisMode
		}

		public enum TiltShiftQuality
		{
			Preview,
			Normal,
			High
		}

		public TiltShiftMode mode;

		public TiltShiftQuality quality = TiltShiftQuality.Normal;

		[Range(0f, 15f)]
		public float blurArea = 1f;

		[Range(0f, 25f)]
		public float maxBlurSize = 5f;

		[Range(0f, 1f)]
		public int downsample;

		public Shader tiltShiftShader;

		private Material tiltShiftMaterial;

		public override bool CheckResources()
		{
			CheckSupport(needDepth: true);
			tiltShiftMaterial = CheckShaderAndCreateMaterial(tiltShiftShader, tiltShiftMaterial);
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources())
			{
				Graphics.Blit(source, destination);
				return;
			}
			tiltShiftMaterial.SetFloat("_BlurSize", (maxBlurSize < 0f) ? 0f : maxBlurSize);
			tiltShiftMaterial.SetFloat("_BlurArea", blurArea);
			source.filterMode = FilterMode.Bilinear;
			RenderTexture renderTexture = destination;
			if ((float)downsample > 0f)
			{
				renderTexture = RenderTexture.GetTemporary(source.width >> downsample, source.height >> downsample, 0, source.format);
				renderTexture.filterMode = FilterMode.Bilinear;
			}
			int num = (int)quality;
			num *= 2;
			Graphics.Blit(source, renderTexture, tiltShiftMaterial, (mode == TiltShiftMode.TiltShiftMode) ? num : (num + 1));
			if (downsample > 0)
			{
				tiltShiftMaterial.SetTexture("_Blurred", renderTexture);
				Graphics.Blit(source, destination, tiltShiftMaterial, 6);
			}
			if (renderTexture != destination)
			{
				RenderTexture.ReleaseTemporary(renderTexture);
			}
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Color Adjustments/Tonemapping")]
	public class Tonemapping : PostEffectsBase
	{
		public enum TonemapperType
		{
			SimpleReinhard,
			UserCurve,
			Hable,
			Photographic,
			OptimizedHejiDawson,
			AdaptiveReinhard,
			AdaptiveReinhardAutoWhite
		}

		public enum AdaptiveTexSize
		{
			Square16 = 0x10,
			Square32 = 0x20,
			Square64 = 0x40,
			Square128 = 0x80,
			Square256 = 0x100,
			Square512 = 0x200,
			Square1024 = 0x400
		}

		public TonemapperType type = TonemapperType.Photographic;

		public AdaptiveTexSize adaptiveTextureSize = AdaptiveTexSize.Square256;

		public AnimationCurve remapCurve;

		private Texture2D curveTex;

		public float exposureAdjustment = 1.5f;

		public float middleGrey = 0.4f;

		public float white = 2f;

		public float adaptionSpeed = 1.5f;

		public Shader tonemapper;

		public bool validRenderTextureFormat = true;

		private Material tonemapMaterial;

		private RenderTexture rt;

		private RenderTextureFormat rtFormat = RenderTextureFormat.ARGBHalf;

		public override bool CheckResources()
		{
			CheckSupport(needDepth: false, needHdr: true);
			tonemapMaterial = CheckShaderAndCreateMaterial(tonemapper, tonemapMaterial);
			if (!curveTex && type == TonemapperType.UserCurve)
			{
				curveTex = new Texture2D(256, 1, TextureFormat.ARGB32, mipChain: false, linear: true);
				curveTex.filterMode = FilterMode.Bilinear;
				curveTex.wrapMode = TextureWrapMode.Clamp;
				curveTex.hideFlags = HideFlags.DontSave;
			}
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		public float UpdateCurve()
		{
			float num = 1f;
			if (remapCurve.keys.Length < 1)
			{
				remapCurve = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(2f, 1f));
			}
			if (remapCurve != null)
			{
				if (remapCurve.length > 0)
				{
					num = remapCurve[remapCurve.length - 1].time;
				}
				for (float num2 = 0f; num2 <= 1f; num2 += 0.003921569f)
				{
					float num3 = remapCurve.Evaluate(num2 * 1f * num);
					curveTex.SetPixel((int)Mathf.Floor(num2 * 255f), 0, new Color(num3, num3, num3));
				}
				curveTex.Apply();
			}
			return 1f / num;
		}

		private void OnDisable()
		{
			if ((bool)rt)
			{
				UnityEngine.Object.DestroyImmediate(rt);
				rt = null;
			}
			if ((bool)tonemapMaterial)
			{
				UnityEngine.Object.DestroyImmediate(tonemapMaterial);
				tonemapMaterial = null;
			}
			if ((bool)curveTex)
			{
				UnityEngine.Object.DestroyImmediate(curveTex);
				curveTex = null;
			}
		}

		private bool CreateInternalRenderTexture()
		{
			if ((bool)rt)
			{
				return false;
			}
			rtFormat = (SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.RGHalf) ? RenderTextureFormat.RGHalf : RenderTextureFormat.ARGBHalf);
			rt = new RenderTexture(1, 1, 0, rtFormat);
			rt.hideFlags = HideFlags.DontSave;
			return true;
		}

		[ImageEffectTransformsToLDR]
		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources())
			{
				Graphics.Blit(source, destination);
				return;
			}
			exposureAdjustment = ((exposureAdjustment < 0.001f) ? 0.001f : exposureAdjustment);
			if (type == TonemapperType.UserCurve)
			{
				float value = UpdateCurve();
				tonemapMaterial.SetFloat("_RangeScale", value);
				tonemapMaterial.SetTexture("_Curve", curveTex);
				Graphics.Blit(source, destination, tonemapMaterial, 4);
				return;
			}
			if (type == TonemapperType.SimpleReinhard)
			{
				tonemapMaterial.SetFloat("_ExposureAdjustment", exposureAdjustment);
				Graphics.Blit(source, destination, tonemapMaterial, 6);
				return;
			}
			if (type == TonemapperType.Hable)
			{
				tonemapMaterial.SetFloat("_ExposureAdjustment", exposureAdjustment);
				Graphics.Blit(source, destination, tonemapMaterial, 5);
				return;
			}
			if (type == TonemapperType.Photographic)
			{
				tonemapMaterial.SetFloat("_ExposureAdjustment", exposureAdjustment);
				Graphics.Blit(source, destination, tonemapMaterial, 8);
				return;
			}
			if (type == TonemapperType.OptimizedHejiDawson)
			{
				tonemapMaterial.SetFloat("_ExposureAdjustment", 0.5f * exposureAdjustment);
				Graphics.Blit(source, destination, tonemapMaterial, 7);
				return;
			}
			bool flag = CreateInternalRenderTexture();
			RenderTexture temporary = RenderTexture.GetTemporary((int)adaptiveTextureSize, (int)adaptiveTextureSize, 0, rtFormat);
			Graphics.Blit(source, temporary);
			int num = (int)Mathf.Log((float)temporary.width * 1f, 2f);
			int num2 = 2;
			RenderTexture[] array = new RenderTexture[num];
			for (int i = 0; i < num; i++)
			{
				array[i] = RenderTexture.GetTemporary(temporary.width / num2, temporary.width / num2, 0, rtFormat);
				num2 *= 2;
			}
			RenderTexture source2 = array[num - 1];
			Graphics.Blit(temporary, array[0], tonemapMaterial, 1);
			if (type == TonemapperType.AdaptiveReinhardAutoWhite)
			{
				for (int j = 0; j < num - 1; j++)
				{
					Graphics.Blit(array[j], array[j + 1], tonemapMaterial, 9);
					source2 = array[j + 1];
				}
			}
			else if (type == TonemapperType.AdaptiveReinhard)
			{
				for (int k = 0; k < num - 1; k++)
				{
					Graphics.Blit(array[k], array[k + 1]);
					source2 = array[k + 1];
				}
			}
			adaptionSpeed = ((adaptionSpeed < 0.001f) ? 0.001f : adaptionSpeed);
			tonemapMaterial.SetFloat("_AdaptionSpeed", adaptionSpeed);
			rt.MarkRestoreExpected();
			Graphics.Blit(source2, rt, tonemapMaterial, flag ? 3 : 2);
			middleGrey = ((middleGrey < 0.001f) ? 0.001f : middleGrey);
			tonemapMaterial.SetVector("_HdrParams", new Vector4(middleGrey, middleGrey, middleGrey, white * white));
			tonemapMaterial.SetTexture("_SmallTex", rt);
			if (type == TonemapperType.AdaptiveReinhard)
			{
				Graphics.Blit(source, destination, tonemapMaterial, 0);
			}
			else if (type == TonemapperType.AdaptiveReinhardAutoWhite)
			{
				Graphics.Blit(source, destination, tonemapMaterial, 10);
			}
			else
			{
				UnityEngine.Debug.LogError("No valid adaptive tonemapper type found!");
				Graphics.Blit(source, destination);
			}
			for (int l = 0; l < num; l++)
			{
				RenderTexture.ReleaseTemporary(array[l]);
			}
			RenderTexture.ReleaseTemporary(temporary);
		}
	}
	internal class Triangles
	{
		private static Mesh[] meshes;

		private static int currentTris;

		private static bool HasMeshes()
		{
			if (meshes == null)
			{
				return false;
			}
			for (int i = 0; i < meshes.Length; i++)
			{
				if (null == meshes[i])
				{
					return false;
				}
			}
			return true;
		}

		private static void Cleanup()
		{
			if (meshes == null)
			{
				return;
			}
			for (int i = 0; i < meshes.Length; i++)
			{
				if (null != meshes[i])
				{
					UnityEngine.Object.DestroyImmediate(meshes[i]);
					meshes[i] = null;
				}
			}
			meshes = null;
		}

		private static Mesh[] GetMeshes(int totalWidth, int totalHeight)
		{
			if (HasMeshes() && currentTris == totalWidth * totalHeight)
			{
				return meshes;
			}
			int num = 21666;
			int num2 = (currentTris = totalWidth * totalHeight);
			meshes = new Mesh[Mathf.CeilToInt(1f * (float)num2 / (1f * (float)num))];
			int num3 = 0;
			int num4 = 0;
			for (num3 = 0; num3 < num2; num3 += num)
			{
				int triCount = Mathf.FloorToInt(Mathf.Clamp(num2 - num3, 0, num));
				meshes[num4] = GetMesh(triCount, num3, totalWidth, totalHeight);
				num4++;
			}
			return meshes;
		}

		private static Mesh GetMesh(int triCount, int triOffset, int totalWidth, int totalHeight)
		{
			Mesh mesh = new Mesh();
			mesh.hideFlags = HideFlags.DontSave;
			Vector3[] array = new Vector3[triCount * 3];
			Vector2[] array2 = new Vector2[triCount * 3];
			Vector2[] array3 = new Vector2[triCount * 3];
			int[] array4 = new int[triCount * 3];
			for (int i = 0; i < triCount; i++)
			{
				int num = i * 3;
				int num2 = triOffset + i;
				float num3 = Mathf.Floor(num2 % totalWidth) / (float)totalWidth;
				float num4 = Mathf.Floor(num2 / totalWidth) / (float)totalHeight;
				array[num + 2] = (array[num + 1] = (array[num] = new Vector3(num3 * 2f - 1f, num4 * 2f - 1f, 1f)));
				array2[num] = new Vector2(0f, 0f);
				array2[num + 1] = new Vector2(1f, 0f);
				array2[num + 2] = new Vector2(0f, 1f);
				array3[num] = new Vector2(num3, num4);
				array3[num + 1] = new Vector2(num3, num4);
				array3[num + 2] = new Vector2(num3, num4);
				array4[num] = num;
				array4[num + 1] = num + 1;
				array4[num + 2] = num + 2;
			}
			mesh.vertices = array;
			mesh.triangles = array4;
			mesh.uv = array2;
			mesh.uv2 = array3;
			return mesh;
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Image Effects/Displacement/Twirl")]
	public class Twirl : ImageEffectBase
	{
		public Vector2 radius = new Vector2(0.3f, 0.3f);

		public float angle = 50f;

		public Vector2 center = new Vector2(0.5f, 0.5f);

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			ImageEffects.RenderDistortion(base.material, source, destination, angle, center, radius);
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Camera/Vignette and Chromatic Aberration")]
	public class VignetteAndChromaticAberration : PostEffectsBase
	{
		public enum AberrationMode
		{
			Simple,
			Advanced
		}

		public AberrationMode mode;

		public float intensity = 0.375f;

		public float chromaticAberration = 0.2f;

		public float axialAberration = 0.5f;

		public float blur;

		public float blurSpread = 0.75f;

		public float luminanceDependency = 0.25f;

		public float blurDistance = 2.5f;

		public Shader vignetteShader;

		public Shader separableBlurShader;

		public Shader chromAberrationShader;

		private Material m_VignetteMaterial;

		private Material m_SeparableBlurMaterial;

		private Material m_ChromAberrationMaterial;

		public override bool CheckResources()
		{
			CheckSupport(needDepth: false);
			m_VignetteMaterial = CheckShaderAndCreateMaterial(vignetteShader, m_VignetteMaterial);
			m_SeparableBlurMaterial = CheckShaderAndCreateMaterial(separableBlurShader, m_SeparableBlurMaterial);
			m_ChromAberrationMaterial = CheckShaderAndCreateMaterial(chromAberrationShader, m_ChromAberrationMaterial);
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources())
			{
				Graphics.Blit(source, destination);
				return;
			}
			int width = source.width;
			int height = source.height;
			bool flag = Mathf.Abs(blur) > 0f || Mathf.Abs(intensity) > 0f;
			float num = 1f * (float)width / (1f * (float)height);
			RenderTexture renderTexture = null;
			RenderTexture renderTexture2 = null;
			if (flag)
			{
				renderTexture = RenderTexture.GetTemporary(width, height, 0, source.format);
				if (Mathf.Abs(blur) > 0f)
				{
					renderTexture2 = RenderTexture.GetTemporary(width / 2, height / 2, 0, source.format);
					Graphics.Blit(source, renderTexture2, m_ChromAberrationMaterial, 0);
					for (int i = 0; i < 2; i++)
					{
						m_SeparableBlurMaterial.SetVector("offsets", new Vector4(0f, blurSpread * 0.001953125f, 0f, 0f));
						RenderTexture temporary = RenderTexture.GetTemporary(width / 2, height / 2, 0, source.format);
						Graphics.Blit(renderTexture2, temporary, m_SeparableBlurMaterial);
						RenderTexture.ReleaseTemporary(renderTexture2);
						m_SeparableBlurMaterial.SetVector("offsets", new Vector4(blurSpread * 0.001953125f / num, 0f, 0f, 0f));
						renderTexture2 = RenderTexture.GetTemporary(width / 2, height / 2, 0, source.format);
						Graphics.Blit(temporary, renderTexture2, m_SeparableBlurMaterial);
						RenderTexture.ReleaseTemporary(temporary);
					}
				}
				m_VignetteMaterial.SetFloat("_Intensity", intensity);
				m_VignetteMaterial.SetFloat("_Blur", blur);
				m_VignetteMaterial.SetTexture("_VignetteTex", renderTexture2);
				Graphics.Blit(source, renderTexture, m_VignetteMaterial, 0);
			}
			m_ChromAberrationMaterial.SetFloat("_ChromaticAberration", chromaticAberration);
			m_ChromAberrationMaterial.SetFloat("_AxialAberration", axialAberration);
			m_ChromAberrationMaterial.SetVector("_BlurDistance", new Vector2(0f - blurDistance, blurDistance));
			m_ChromAberrationMaterial.SetFloat("_Luminance", 1f / Mathf.Max(Mathf.Epsilon, luminanceDependency));
			if (flag)
			{
				renderTexture.wrapMode = TextureWrapMode.Clamp;
			}
			else
			{
				source.wrapMode = TextureWrapMode.Clamp;
			}
			Graphics.Blit(flag ? renderTexture : source, destination, m_ChromAberrationMaterial, (mode != AberrationMode.Advanced) ? 1 : 2);
			RenderTexture.ReleaseTemporary(renderTexture);
			RenderTexture.ReleaseTemporary(renderTexture2);
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Image Effects/Displacement/Vortex")]
	public class Vortex : ImageEffectBase
	{
		public Vector2 radius = new Vector2(0.4f, 0.4f);

		public float angle = 50f;

		public Vector2 center = new Vector2(0.5f, 0.5f);

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			ImageEffects.RenderDistortion(base.material, source, destination, angle, center, radius);
		}
	}
}
namespace UnityStandardAssets.CrossPlatformInput
{
	public class AxisTouchButton : MonoBehaviour, IPointerDownHandler, IEventSystemHandler, IPointerUpHandler
	{
		public string axisName = "Horizontal";

		public float axisValue = 1f;

		public float responseSpeed = 3f;

		public float returnToCentreSpeed = 3f;

		private AxisTouchButton m_PairedWith;

		private CrossPlatformInputManager.VirtualAxis m_Axis;

		private void OnEnable()
		{
			if (!CrossPlatformInputManager.AxisExists(axisName))
			{
				m_Axis = new CrossPlatformInputManager.VirtualAxis(axisName);
				CrossPlatformInputManager.RegisterVirtualAxis(m_Axis);
			}
			else
			{
				m_Axis = CrossPlatformInputManager.VirtualAxisReference(axisName);
			}
			FindPairedButton();
		}

		private void FindPairedButton()
		{
			if (!(UnityEngine.Object.FindObjectsOfType(typeof(AxisTouchButton)) is AxisTouchButton[] array))
			{
				return;
			}
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i].axisName == axisName && array[i] != this)
				{
					m_PairedWith = array[i];
				}
			}
		}

		private void OnDisable()
		{
			m_Axis.Remove();
		}

		public void OnPointerDown(PointerEventData data)
		{
			if (m_PairedWith == null)
			{
				FindPairedButton();
			}
			m_Axis.Update(Mathf.MoveTowards(m_Axis.GetValue, axisValue, responseSpeed * Time.deltaTime));
		}

		public void OnPointerUp(PointerEventData data)
		{
			m_Axis.Update(Mathf.MoveTowards(m_Axis.GetValue, 0f, responseSpeed * Time.deltaTime));
		}
	}
	public class ButtonHandler : MonoBehaviour
	{
		public string Name;

		private void OnEnable()
		{
		}

		public void SetDownState()
		{
			CrossPlatformInputManager.SetButtonDown(Name);
		}

		public void SetUpState()
		{
			CrossPlatformInputManager.SetButtonUp(Name);
		}

		public void SetAxisPositiveState()
		{
			CrossPlatformInputManager.SetAxisPositive(Name);
		}

		public void SetAxisNeutralState()
		{
			CrossPlatformInputManager.SetAxisZero(Name);
		}

		public void SetAxisNegativeState()
		{
			CrossPlatformInputManager.SetAxisNegative(Name);
		}

		public void Update()
		{
		}
	}
	public static class CrossPlatformInputManager
	{
		public enum ActiveInputMethod
		{
			Hardware,
			Touch
		}

		public class VirtualAxis
		{
			private float m_Value;

			public string name { get; private set; }

			public bool matchWithInputManager { get; private set; }

			public float GetValue => m_Value;

			public float GetValueRaw => m_Value;

			public VirtualAxis(string name)
				: this(name, matchToInputSettings: true)
			{
			}

			public VirtualAxis(string name, bool matchToInputSettings)
			{
				this.name = name;
				matchWithInputManager = matchToInputSettings;
			}

			public void Remove()
			{
				UnRegisterVirtualAxis(name);
			}

			public void Update(float value)
			{
				m_Value = value;
			}
		}

		public class VirtualButton
		{
			private int m_LastPressedFrame = -5;

			private int m_ReleasedFrame = -5;

			private bool m_Pressed;

			public string name { get; private set; }

			public bool matchWithInputManager { get; private set; }

			public bool GetButton => m_Pressed;

			public bool GetButtonDown => m_LastPressedFrame - Time.frameCount == -1;

			public bool GetButtonUp => m_ReleasedFrame == Time.frameCount - 1;

			public VirtualButton(string name)
				: this(name, matchToInputSettings: true)
			{
			}

			public VirtualButton(string name, bool matchToInputSettings)
			{
				this.name = name;
				matchWithInputManager = matchToInputSettings;
			}

			public void Pressed()
			{
				if (!m_Pressed)
				{
					m_Pressed = true;
					m_LastPressedFrame = Time.frameCount;
				}
			}

			public void Released()
			{
				m_Pressed = false;
				m_ReleasedFrame = Time.frameCount;
			}

			public void Remove()
			{
				UnRegisterVirtualButton(name);
			}
		}

		private static VirtualInput activeInput;

		private static VirtualInput s_TouchInput;

		private static VirtualInput s_HardwareInput;

		public static Vector3 mousePosition => activeInput.MousePosition();

		static CrossPlatformInputManager()
		{
			s_TouchInput = new MobileInput();
			s_HardwareInput = new StandaloneInput();
			activeInput = s_HardwareInput;
		}

		public static void SwitchActiveInputMethod(ActiveInputMethod activeInputMethod)
		{
			switch (activeInputMethod)
			{
			case ActiveInputMethod.Hardware:
				activeInput = s_HardwareInput;
				break;
			case ActiveInputMethod.Touch:
				activeInput = s_TouchInput;
				break;
			}
		}

		public static bool AxisExists(string name)
		{
			return activeInput.AxisExists(name);
		}

		public static bool ButtonExists(string name)
		{
			return activeInput.ButtonExists(name);
		}

		public static void RegisterVirtualAxis(VirtualAxis axis)
		{
			activeInput.RegisterVirtualAxis(axis);
		}

		public static void RegisterVirtualButton(VirtualButton button)
		{
			activeInput.RegisterVirtualButton(button);
		}

		public static void UnRegisterVirtualAxis(string name)
		{
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}
			activeInput.UnRegisterVirtualAxis(name);
		}

		public static void UnRegisterVirtualButton(string name)
		{
			activeInput.UnRegisterVirtualButton(name);
		}

		public static VirtualAxis VirtualAxisReference(string name)
		{
			return activeInput.VirtualAxisReference(name);
		}

		public static float GetAxis(string name)
		{
			return GetAxis(name, raw: false);
		}

		public static float GetAxisRaw(string name)
		{
			return GetAxis(name, raw: true);
		}

		private static float GetAxis(string name, bool raw)
		{
			return activeInput.GetAxis(name, raw);
		}

		public static bool GetButton(string name)
		{
			return activeInput.GetButton(name);
		}

		public static bool GetButtonDown(string name)
		{
			return activeInput.GetButtonDown(name);
		}

		public static bool GetButtonUp(string name)
		{
			return activeInput.GetButtonUp(name);
		}

		public static void SetButtonDown(string name)
		{
			activeInput.SetButtonDown(name);
		}

		public static void SetButtonUp(string name)
		{
			activeInput.SetButtonUp(name);
		}

		public static void SetAxisPositive(string name)
		{
			activeInput.SetAxisPositive(name);
		}

		public static void SetAxisNegative(string name)
		{
			activeInput.SetAxisNegative(name);
		}

		public static void SetAxisZero(string name)
		{
			activeInput.SetAxisZero(name);
		}

		public static void SetAxis(string name, float value)
		{
			activeInput.SetAxis(name, value);
		}

		public static void SetVirtualMousePositionX(float f)
		{
			activeInput.SetVirtualMousePositionX(f);
		}

		public static void SetVirtualMousePositionY(float f)
		{
			activeInput.SetVirtualMousePositionY(f);
		}

		public static void SetVirtualMousePositionZ(float f)
		{
			activeInput.SetVirtualMousePositionZ(f);
		}
	}
	public class InputAxisScrollbar : MonoBehaviour
	{
		public string axis;

		private void Update()
		{
		}

		public void HandleInput(float value)
		{
			CrossPlatformInputManager.SetAxis(axis, value * 2f - 1f);
		}
	}
	public class Joystick : MonoBehaviour, IPointerDownHandler, IEventSystemHandler, IPointerUpHandler, IDragHandler
	{
		public enum AxisOption
		{
			Both,
			OnlyHorizontal,
			OnlyVertical
		}

		public int MovementRange = 100;

		public AxisOption axesToUse;

		public string horizontalAxisName = "Horizontal";

		public string verticalAxisName = "Vertical";

		private Vector3 m_StartPos;

		private bool m_UseX;

		private bool m_UseY;

		private CrossPlatformInputManager.VirtualAxis m_HorizontalVirtualAxis;

		private CrossPlatformInputManager.VirtualAxis m_VerticalVirtualAxis;

		private void OnEnable()
		{
			m_StartPos = base.transform.position;
			CreateVirtualAxes();
		}

		private void UpdateVirtualAxes(Vector3 value)
		{
			Vector3 vector = m_StartPos - value;
			vector.y = 0f - vector.y;
			vector /= (float)MovementRange;
			if (m_UseX)
			{
				m_HorizontalVirtualAxis.Update(0f - vector.x);
			}
			if (m_UseY)
			{
				m_VerticalVirtualAxis.Update(vector.y);
			}
		}

		private void CreateVirtualAxes()
		{
			m_UseX = axesToUse == AxisOption.Both || axesToUse == AxisOption.OnlyHorizontal;
			m_UseY = axesToUse == AxisOption.Both || axesToUse == AxisOption.OnlyVertical;
			if (m_UseX)
			{
				m_HorizontalVirtualAxis = new CrossPlatformInputManager.VirtualAxis(horizontalAxisName);
				CrossPlatformInputManager.RegisterVirtualAxis(m_HorizontalVirtualAxis);
			}
			if (m_UseY)
			{
				m_VerticalVirtualAxis = new CrossPlatformInputManager.VirtualAxis(verticalAxisName);
				CrossPlatformInputManager.RegisterVirtualAxis(m_VerticalVirtualAxis);
			}
		}

		public void OnDrag(PointerEventData data)
		{
			Vector3 zero = Vector3.zero;
			if (m_UseX)
			{
				int value = (int)(data.position.x - m_StartPos.x);
				value = Mathf.Clamp(value, -MovementRange, MovementRange);
				zero.x = value;
			}
			if (m_UseY)
			{
				int value2 = (int)(data.position.y - m_StartPos.y);
				value2 = Mathf.Clamp(value2, -MovementRange, MovementRange);
				zero.y = value2;
			}
			base.transform.position = new Vector3(m_StartPos.x + zero.x, m_StartPos.y + zero.y, m_StartPos.z + zero.z);
			UpdateVirtualAxes(base.transform.position);
		}

		public void OnPointerUp(PointerEventData data)
		{
			base.transform.position = m_StartPos;
			UpdateVirtualAxes(m_StartPos);
		}

		public void OnPointerDown(PointerEventData data)
		{
		}

		private void OnDisable()
		{
			if (m_UseX)
			{
				m_HorizontalVirtualAxis.Remove();
			}
			if (m_UseY)
			{
				m_VerticalVirtualAxis.Remove();
			}
		}
	}
	[ExecuteInEditMode]
	public class MobileControlRig : MonoBehaviour
	{
		private void OnEnable()
		{
			CheckEnableControlRig();
		}

		private void CheckEnableControlRig()
		{
			EnableControlRig(enabled: false);
		}

		private void EnableControlRig(bool enabled)
		{
			foreach (Transform item in base.transform)
			{
				item.gameObject.SetActive(enabled);
			}
		}
	}
	public class TiltInput : MonoBehaviour
	{
		public enum AxisOptions
		{
			ForwardAxis,
			SidewaysAxis
		}

		[Serializable]
		public class AxisMapping
		{
			public enum MappingType
			{
				NamedAxis,
				MousePositionX,
				MousePositionY,
				MousePositionZ
			}

			public MappingType type;

			public string axisName;
		}

		public AxisMapping mapping;

		public AxisOptions tiltAroundAxis;

		public float fullTiltAngle = 25f;

		public float centreAngleOffset;

		private CrossPlatformInputManager.VirtualAxis m_SteerAxis;

		private void OnEnable()
		{
			if (mapping.type == AxisMapping.MappingType.NamedAxis)
			{
				m_SteerAxis = new CrossPlatformInputManager.VirtualAxis(mapping.axisName);
				CrossPlatformInputManager.RegisterVirtualAxis(m_SteerAxis);
			}
		}

		private void Update()
		{
			float value = 0f;
			if (Input.acceleration != Vector3.zero)
			{
				switch (tiltAroundAxis)
				{
				case AxisOptions.ForwardAxis:
					value = Mathf.Atan2(Input.acceleration.x, 0f - Input.acceleration.y) * 57.29578f + centreAngleOffset;
					break;
				case AxisOptions.SidewaysAxis:
					value = Mathf.Atan2(Input.acceleration.z, 0f - Input.acceleration.y) * 57.29578f + centreAngleOffset;
					break;
				}
			}
			float num = Mathf.InverseLerp(0f - fullTiltAngle, fullTiltAngle, value) * 2f - 1f;
			switch (mapping.type)
			{
			case AxisMapping.MappingType.NamedAxis:
				m_SteerAxis.Update(num);
				break;
			case AxisMapping.MappingType.MousePositionX:
				CrossPlatformInputManager.SetVirtualMousePositionX(num * (float)UnityEngine.Screen.width);
				break;
			case AxisMapping.MappingType.MousePositionY:
				CrossPlatformInputManager.SetVirtualMousePositionY(num * (float)UnityEngine.Screen.width);
				break;
			case AxisMapping.MappingType.MousePositionZ:
				CrossPlatformInputManager.SetVirtualMousePositionZ(num * (float)UnityEngine.Screen.width);
				break;
			}
		}

		private void OnDisable()
		{
			m_SteerAxis.Remove();
		}
	}
	[RequireComponent(typeof(Image))]
	public class TouchPad : MonoBehaviour, IPointerDownHandler, IEventSystemHandler, IPointerUpHandler
	{
		public enum AxisOption
		{
			Both,
			OnlyHorizontal,
			OnlyVertical
		}

		public enum ControlStyle
		{
			Absolute,
			Relative,
			Swipe
		}

		public AxisOption axesToUse;

		public ControlStyle controlStyle;

		public string horizontalAxisName = "Horizontal";

		public string verticalAxisName = "Vertical";

		public float Xsensitivity = 1f;

		public float Ysensitivity = 1f;

		private Vector3 m_StartPos;

		private Vector2 m_PreviousDelta;

		private Vector3 m_JoytickOutput;

		private bool m_UseX;

		private bool m_UseY;

		private CrossPlatformInputManager.VirtualAxis m_HorizontalVirtualAxis;

		private CrossPlatformInputManager.VirtualAxis m_VerticalVirtualAxis;

		private bool m_Dragging;

		private int m_Id = -1;

		private Vector2 m_PreviousTouchPos;

		private Vector3 m_Center;

		private Image m_Image;

		private void OnEnable()
		{
			CreateVirtualAxes();
			m_Image = GetComponent<Image>();
			m_Center = m_Image.transform.position;
		}

		private void CreateVirtualAxes()
		{
			m_UseX = axesToUse == AxisOption.Both || axesToUse == AxisOption.OnlyHorizontal;
			m_UseY = axesToUse == AxisOption.Both || axesToUse == AxisOption.OnlyVertical;
			if (m_UseX)
			{
				m_HorizontalVirtualAxis = new CrossPlatformInputManager.VirtualAxis(horizontalAxisName);
				CrossPlatformInputManager.RegisterVirtualAxis(m_HorizontalVirtualAxis);
			}
			if (m_UseY)
			{
				m_VerticalVirtualAxis = new CrossPlatformInputManager.VirtualAxis(verticalAxisName);
				CrossPlatformInputManager.RegisterVirtualAxis(m_VerticalVirtualAxis);
			}
		}

		private void UpdateVirtualAxes(Vector3 value)
		{
			value = value.normalized;
			if (m_UseX)
			{
				m_HorizontalVirtualAxis.Update(value.x);
			}
			if (m_UseY)
			{
				m_VerticalVirtualAxis.Update(value.y);
			}
		}

		public void OnPointerDown(PointerEventData data)
		{
			m_Dragging = true;
			m_Id = data.pointerId;
			if (controlStyle != 0)
			{
				m_Center = data.position;
			}
		}

		private void Update()
		{
			if (m_Dragging && Input.touchCount >= m_Id + 1 && m_Id != -1)
			{
				if (controlStyle == ControlStyle.Swipe)
				{
					m_Center = m_PreviousTouchPos;
					m_PreviousTouchPos = Input.touches[m_Id].position;
				}
				Vector2 normalized = new Vector2(Input.touches[m_Id].position.x - m_Center.x, Input.touches[m_Id].position.y - m_Center.y).normalized;
				normalized.x *= Xsensitivity;
				normalized.y *= Ysensitivity;
				UpdateVirtualAxes(new Vector3(normalized.x, normalized.y, 0f));
			}
		}

		public void OnPointerUp(PointerEventData data)
		{
			m_Dragging = false;
			m_Id = -1;
			UpdateVirtualAxes(Vector3.zero);
		}

		private void OnDisable()
		{
			if (CrossPlatformInputManager.AxisExists(horizontalAxisName))
			{
				CrossPlatformInputManager.UnRegisterVirtualAxis(horizontalAxisName);
			}
			if (CrossPlatformInputManager.AxisExists(verticalAxisName))
			{
				CrossPlatformInputManager.UnRegisterVirtualAxis(verticalAxisName);
			}
		}
	}
	public abstract class VirtualInput
	{
		protected Dictionary<string, CrossPlatformInputManager.VirtualAxis> m_VirtualAxes = new Dictionary<string, CrossPlatformInputManager.VirtualAxis>();

		protected Dictionary<string, CrossPlatformInputManager.VirtualButton> m_VirtualButtons = new Dictionary<string, CrossPlatformInputManager.VirtualButton>();

		protected List<string> m_AlwaysUseVirtual = new List<string>();

		public Vector3 virtualMousePosition { get; private set; }

		public bool AxisExists(string name)
		{
			return m_VirtualAxes.ContainsKey(name);
		}

		public bool ButtonExists(string name)
		{
			return m_VirtualButtons.ContainsKey(name);
		}

		public void RegisterVirtualAxis(CrossPlatformInputManager.VirtualAxis axis)
		{
			if (m_VirtualAxes.ContainsKey(axis.name))
			{
				UnityEngine.Debug.LogError("There is already a virtual axis named " + axis.name + " registered.");
				return;
			}
			m_VirtualAxes.Add(axis.name, axis);
			if (!axis.matchWithInputManager)
			{
				m_AlwaysUseVirtual.Add(axis.name);
			}
		}

		public void RegisterVirtualButton(CrossPlatformInputManager.VirtualButton button)
		{
			if (m_VirtualButtons.ContainsKey(button.name))
			{
				UnityEngine.Debug.LogError("There is already a virtual button named " + button.name + " registered.");
				return;
			}
			m_VirtualButtons.Add(button.name, button);
			if (!button.matchWithInputManager)
			{
				m_AlwaysUseVirtual.Add(button.name);
			}
		}

		public void UnRegisterVirtualAxis(string name)
		{
			if (m_VirtualAxes.ContainsKey(name))
			{
				m_VirtualAxes.Remove(name);
			}
		}

		public void UnRegisterVirtualButton(string name)
		{
			if (m_VirtualButtons.ContainsKey(name))
			{
				m_VirtualButtons.Remove(name);
			}
		}

		public CrossPlatformInputManager.VirtualAxis VirtualAxisReference(string name)
		{
			if (!m_VirtualAxes.ContainsKey(name))
			{
				return null;
			}
			return m_VirtualAxes[name];
		}

		public void SetVirtualMousePositionX(float f)
		{
			virtualMousePosition = new Vector3(f, virtualMousePosition.y, virtualMousePosition.z);
		}

		public void SetVirtualMousePositionY(float f)
		{
			virtualMousePosition = new Vector3(virtualMousePosition.x, f, virtualMousePosition.z);
		}

		public void SetVirtualMousePositionZ(float f)
		{
			virtualMousePosition = new Vector3(virtualMousePosition.x, virtualMousePosition.y, f);
		}

		public abstract float GetAxis(string name, bool raw);

		public abstract bool GetButton(string name);

		public abstract bool GetButtonDown(string name);

		public abstract bool GetButtonUp(string name);

		public abstract void SetButtonDown(string name);

		public abstract void SetButtonUp(string name);

		public abstract void SetAxisPositive(string name);

		public abstract void SetAxisNegative(string name);

		public abstract void SetAxisZero(string name);

		public abstract void SetAxis(string name, float value);

		public abstract Vector3 MousePosition();
	}
}
namespace UnityStandardAssets.CrossPlatformInput.PlatformSpecific
{
	public class MobileInput : VirtualInput
	{
		private void AddButton(string name)
		{
			CrossPlatformInputManager.RegisterVirtualButton(new CrossPlatformInputManager.VirtualButton(name));
		}

		private void AddAxes(string name)
		{
			CrossPlatformInputManager.RegisterVirtualAxis(new CrossPlatformInputManager.VirtualAxis(name));
		}

		public override float GetAxis(string name, bool raw)
		{
			if (!m_VirtualAxes.ContainsKey(name))
			{
				AddAxes(name);
			}
			return m_VirtualAxes[name].GetValue;
		}

		public override void SetButtonDown(string name)
		{
			if (!m_VirtualButtons.ContainsKey(name))
			{
				AddButton(name);
			}
			m_VirtualButtons[name].Pressed();
		}

		public override void SetButtonUp(string name)
		{
			if (!m_VirtualButtons.ContainsKey(name))
			{
				AddButton(name);
			}
			m_VirtualButtons[name].Released();
		}

		public override void SetAxisPositive(string name)
		{
			if (!m_VirtualAxes.ContainsKey(name))
			{
				AddAxes(name);
			}
			m_VirtualAxes[name].Update(1f);
		}

		public override void SetAxisNegative(string name)
		{
			if (!m_VirtualAxes.ContainsKey(name))
			{
				AddAxes(name);
			}
			m_VirtualAxes[name].Update(-1f);
		}

		public override void SetAxisZero(string name)
		{
			if (!m_VirtualAxes.ContainsKey(name))
			{
				AddAxes(name);
			}
			m_VirtualAxes[name].Update(0f);
		}

		public override void SetAxis(string name, float value)
		{
			if (!m_VirtualAxes.ContainsKey(name))
			{
				AddAxes(name);
			}
			m_VirtualAxes[name].Update(value);
		}

		public override bool GetButtonDown(string name)
		{
			if (m_VirtualButtons.ContainsKey(name))
			{
				return m_VirtualButtons[name].GetButtonDown;
			}
			AddButton(name);
			return m_VirtualButtons[name].GetButtonDown;
		}

		public override bool GetButtonUp(string name)
		{
			if (m_VirtualButtons.ContainsKey(name))
			{
				return m_VirtualButtons[name].GetButtonUp;
			}
			AddButton(name);
			return m_VirtualButtons[name].GetButtonUp;
		}

		public override bool GetButton(string name)
		{
			if (m_VirtualButtons.ContainsKey(name))
			{
				return m_VirtualButtons[name].GetButton;
			}
			AddButton(name);
			return m_VirtualButtons[name].GetButton;
		}

		public override Vector3 MousePosition()
		{
			return base.virtualMousePosition;
		}
	}
	public class StandaloneInput : VirtualInput
	{
		public override float GetAxis(string name, bool raw)
		{
			if (!raw)
			{
				return Input.GetAxis(name);
			}
			return Input.GetAxisRaw(name);
		}

		public override bool GetButton(string name)
		{
			return Input.GetButton(name);
		}

		public override bool GetButtonDown(string name)
		{
			return Input.GetButtonDown(name);
		}

		public override bool GetButtonUp(string name)
		{
			return Input.GetButtonUp(name);
		}

		public override void SetButtonDown(string name)
		{
			throw new Exception(" This is not possible to be called for standalone input. Please check your platform and code where this is called");
		}

		public override void SetButtonUp(string name)
		{
			throw new Exception(" This is not possible to be called for standalone input. Please check your platform and code where this is called");
		}

		public override void SetAxisPositive(string name)
		{
			throw new Exception(" This is not possible to be called for standalone input. Please check your platform and code where this is called");
		}

		public override void SetAxisNegative(string name)
		{
			throw new Exception(" This is not possible to be called for standalone input. Please check your platform and code where this is called");
		}

		public override void SetAxisZero(string name)
		{
			throw new Exception(" This is not possible to be called for standalone input. Please check your platform and code where this is called");
		}

		public override void SetAxis(string name, float value)
		{
			throw new Exception(" This is not possible to be called for standalone input. Please check your platform and code where this is called");
		}

		public override Vector3 MousePosition()
		{
			return Input.mousePosition;
		}
	}
}
namespace UnityStandardAssets.Vehicles.Ball
{
	public class Ball : MonoBehaviour
	{
		[SerializeField]
		private float m_MovePower = 5f;

		[SerializeField]
		private bool m_UseTorque = true;

		[SerializeField]
		private float m_MaxAngularVelocity = 25f;

		[SerializeField]
		private float m_JumpPower = 2f;

		private const float k_GroundRayLength = 1f;

		private Rigidbody m_Rigidbody;

		private void Start()
		{
			m_Rigidbody = GetComponent<Rigidbody>();
			GetComponent<Rigidbody>().maxAngularVelocity = m_MaxAngularVelocity;
		}

		public void Move(Vector3 moveDirection, bool jump)
		{
			if (m_UseTorque)
			{
				m_Rigidbody.AddTorque(new Vector3(moveDirection.z, 0f, 0f - moveDirection.x) * m_MovePower);
			}
			else
			{
				m_Rigidbody.AddForce(moveDirection * m_MovePower);
			}
			if (Physics.Raycast(base.transform.position, -Vector3.up, 1f) && jump)
			{
				m_Rigidbody.AddForce(Vector3.up * m_JumpPower, ForceMode.Impulse);
			}
		}
	}
	public class BallUserControl : MonoBehaviour
	{
		private Ball ball;

		private Vector3 move;

		private Transform cam;

		private Vector3 camForward;

		private bool jump;

		private void Awake()
		{
			ball = GetComponent<Ball>();
			if (Camera.main != null)
			{
				cam = Camera.main.transform;
			}
			else
			{
				UnityEngine.Debug.LogWarning("Warning: no main camera found. Ball needs a Camera tagged \"MainCamera\", for camera-relative controls.");
			}
		}

		private void Update()
		{
			float axis = CrossPlatformInputManager.GetAxis("Horizontal");
			float axis2 = CrossPlatformInputManager.GetAxis("Vertical");
			jump = CrossPlatformInputManager.GetButton("Jump");
			if (cam != null)
			{
				camForward = Vector3.Scale(cam.forward, new Vector3(1f, 0f, 1f)).normalized;
				move = (axis2 * camForward + axis * cam.right).normalized;
			}
			else
			{
				move = (axis2 * Vector3.forward + axis * Vector3.right).normalized;
			}
		}

		private void FixedUpdate()
		{
			ball.Move(move, jump);
			jump = false;
		}
	}
}
namespace UnityStandardAssets.Characters.ThirdPerson
{
	[RequireComponent(typeof(NavMeshAgent))]
	[RequireComponent(typeof(ThirdPersonCharacter))]
	public class AICharacterControl : MonoBehaviour
	{
		public Transform target;

		public NavMeshAgent agent { get; private set; }

		public ThirdPersonCharacter character { get; private set; }

		private void Start()
		{
			agent = GetComponentInChildren<NavMeshAgent>();
			character = GetComponent<ThirdPersonCharacter>();
			agent.updateRotation = false;
			agent.updatePosition = true;
		}

		private void Update()
		{
			if (target != null)
			{
				agent.SetDestination(target.position);
				character.Move(agent.desiredVelocity, crouch: false, jump: false);
			}
			else
			{
				character.Move(Vector3.zero, crouch: false, jump: false);
			}
		}

		public void SetTarget(Transform target)
		{
			this.target = target;
		}
	}
	[RequireComponent(typeof(Rigidbody))]
	[RequireComponent(typeof(CapsuleCollider))]
	[RequireComponent(typeof(Animator))]
	public class ThirdPersonCharacter : MonoBehaviour
	{
		[SerializeField]
		private float m_MovingTurnSpeed = 360f;

		[SerializeField]
		private float m_StationaryTurnSpeed = 180f;

		[SerializeField]
		private float m_JumpPower = 12f;

		[Range(1f, 4f)]
		[SerializeField]
		private float m_GravityMultiplier = 2f;

		[SerializeField]
		private float m_RunCycleLegOffset = 0.2f;

		[SerializeField]
		private float m_MoveSpeedMultiplier = 1f;

		[SerializeField]
		private float m_AnimSpeedMultiplier = 1f;

		[SerializeField]
		private float m_GroundCheckDistance = 0.1f;

		private Rigidbody m_Rigidbody;

		private Animator m_Animator;

		private bool m_IsGrounded;

		private float m_OrigGroundCheckDistance;

		private const float k_Half = 0.5f;

		private float m_TurnAmount;

		private float m_ForwardAmount;

		private Vector3 m_GroundNormal;

		private float m_CapsuleHeight;

		private Vector3 m_CapsuleCenter;

		private CapsuleCollider m_Capsule;

		private bool m_Crouching;

		private void Start()
		{
			m_Animator = GetComponent<Animator>();
			m_Rigidbody = GetComponent<Rigidbody>();
			m_Capsule = GetComponent<CapsuleCollider>();
			m_CapsuleHeight = m_Capsule.height;
			m_CapsuleCenter = m_Capsule.center;
			m_Rigidbody.constraints = RigidbodyConstraints.FreezeRotation;
			m_OrigGroundCheckDistance = m_GroundCheckDistance;
		}

		public void Move(Vector3 move, bool crouch, bool jump)
		{
			if (move.magnitude > 1f)
			{
				move.Normalize();
			}
			move = base.transform.InverseTransformDirection(move);
			CheckGroundStatus();
			move = Vector3.ProjectOnPlane(move, m_GroundNormal);
			m_TurnAmount = Mathf.Atan2(move.x, move.z);
			m_ForwardAmount = move.z;
			ApplyExtraTurnRotation();
			if (m_IsGrounded)
			{
				HandleGroundedMovement(crouch, jump);
			}
			else
			{
				HandleAirborneMovement();
			}
			ScaleCapsuleForCrouching(crouch);
			PreventStandingInLowHeadroom();
			UpdateAnimator(move);
		}

		private void ScaleCapsuleForCrouching(bool crouch)
		{
			if (m_IsGrounded && crouch)
			{
				if (!m_Crouching)
				{
					m_Capsule.height /= 2f;
					m_Capsule.center /= 2f;
					m_Crouching = true;
				}
			}
			else if (Physics.SphereCast(new Ray(m_Rigidbody.position + Vector3.up * m_Capsule.radius * 0.5f, Vector3.up), maxDistance: m_CapsuleHeight - m_Capsule.radius * 0.5f, radius: m_Capsule.radius * 0.5f))
			{
				m_Crouching = true;
			}
			else
			{
				m_Capsule.height = m_CapsuleHeight;
				m_Capsule.center = m_CapsuleCenter;
				m_Crouching = false;
			}
		}

		private void PreventStandingInLowHeadroom()
		{
			if (!m_Crouching && Physics.SphereCast(new Ray(m_Rigidbody.position + Vector3.up * m_Capsule.radius * 0.5f, Vector3.up), maxDistance: m_CapsuleHeight - m_Capsule.radius * 0.5f, radius: m_Capsule.radius * 0.5f))
			{
				m_Crouching = true;
			}
		}

		private void UpdateAnimator(Vector3 move)
		{
			m_Animator.SetFloat("Forward", m_ForwardAmount, 0.1f, Time.deltaTime);
			m_Animator.SetFloat("Turn", m_TurnAmount, 0.1f, Time.deltaTime);
			m_Animator.SetBool("Crouch", m_Crouching);
			m_Animator.SetBool("OnGround", m_IsGrounded);
			if (!m_IsGrounded)
			{
				m_Animator.SetFloat("Jump", m_Rigidbody.velocity.y);
			}
			float value = (float)((Mathf.Repeat(m_Animator.GetCurrentAnimatorStateInfo(0).normalizedTime + m_RunCycleLegOffset, 1f) < 0.5f) ? 1 : (-1)) * m_ForwardAmount;
			if (m_IsGrounded)
			{
				m_Animator.SetFloat("JumpLeg", value);
			}
			if (m_IsGrounded && move.magnitude > 0f)
			{
				m_Animator.speed = m_AnimSpeedMultiplier;
			}
			else
			{
				m_Animator.speed = 1f;
			}
		}

		private void HandleAirborneMovement()
		{
			Vector3 force = Physics.gravity * m_GravityMultiplier - Physics.gravity;
			m_Rigidbody.AddForce(force);
			m_GroundCheckDistance = ((m_Rigidbody.velocity.y < 0f) ? m_OrigGroundCheckDistance : 0.01f);
		}

		private void HandleGroundedMovement(bool crouch, bool jump)
		{
			if (jump && !crouch && m_Animator.GetCurrentAnimatorStateInfo(0).IsName("Grounded"))
			{
				m_Rigidbody.velocity = new Vector3(m_Rigidbody.velocity.x, m_JumpPower, m_Rigidbody.velocity.z);
				m_IsGrounded = false;
				m_Animator.applyRootMotion = false;
				m_GroundCheckDistance = 0.1f;
			}
		}

		private void ApplyExtraTurnRotation()
		{
			float num = Mathf.Lerp(m_StationaryTurnSpeed, m_MovingTurnSpeed, m_ForwardAmount);
			base.transform.Rotate(0f, m_TurnAmount * num * Time.deltaTime, 0f);
		}

		public void OnAnimatorMove()
		{
			if (m_IsGrounded && Time.deltaTime > 0f)
			{
				Vector3 velocity = m_Animator.deltaPosition * m_MoveSpeedMultiplier / Time.deltaTime;
				velocity.y = m_Rigidbody.velocity.y;
				m_Rigidbody.velocity = velocity;
			}
		}

		private void CheckGroundStatus()
		{
			if (Physics.Raycast(base.transform.position + Vector3.up * 0.1f, Vector3.down, out var hitInfo, m_GroundCheckDistance))
			{
				m_GroundNormal = hitInfo.normal;
				m_IsGrounded = true;
				m_Animator.applyRootMotion = true;
			}
			else
			{
				m_IsGrounded = false;
				m_GroundNormal = Vector3.up;
				m_Animator.applyRootMotion = false;
			}
		}
	}
	[RequireComponent(typeof(ThirdPersonCharacter))]
	public class ThirdPersonUserControl : MonoBehaviour
	{
		private ThirdPersonCharacter m_Character;

		private Transform m_Cam;

		private Vector3 m_CamForward;

		private Vector3 m_Move;

		private bool m_Jump;

		private void Start()
		{
			if (Camera.main != null)
			{
				m_Cam = Camera.main.transform;
			}
			else
			{
				UnityEngine.Debug.LogWarning("Warning: no main camera found. Third person character needs a Camera tagged \"MainCamera\", for camera-relative controls.");
			}
			m_Character = GetComponent<ThirdPersonCharacter>();
		}

		private void Update()
		{
			if (!m_Jump)
			{
				m_Jump = CrossPlatformInputManager.GetButtonDown("Jump");
			}
		}

		private void FixedUpdate()
		{
			float axis = CrossPlatformInputManager.GetAxis("Horizontal");
			float axis2 = CrossPlatformInputManager.GetAxis("Vertical");
			bool key = Input.GetKey(KeyCode.C);
			if (m_Cam != null)
			{
				m_CamForward = Vector3.Scale(m_Cam.forward, new Vector3(1f, 0f, 1f)).normalized;
				m_Move = axis2 * m_CamForward + axis * m_Cam.right;
			}
			else
			{
				m_Move = axis2 * Vector3.forward + axis * Vector3.right;
			}
			if (Input.GetKey(KeyCode.LeftShift))
			{
				m_Move *= 0.5f;
			}
			m_Character.Move(m_Move, key, m_Jump);
			m_Jump = false;
		}
	}
}
namespace UnityStandardAssets.Characters.FirstPerson
{
	[RequireComponent(typeof(CharacterController))]
	[RequireComponent(typeof(AudioSource))]
	public class FirstPersonController : MonoBehaviour
	{
		[SerializeField]
		private bool m_IsWalking;

		[SerializeField]
		private float m_WalkSpeed;

		[SerializeField]
		private float m_RunSpeed;

		[SerializeField]
		[Range(0f, 1f)]
		private float m_RunstepLenghten;

		[SerializeField]
		private float m_JumpSpeed;

		[SerializeField]
		private float m_StickToGroundForce;

		[SerializeField]
		private float m_GravityMultiplier;

		[SerializeField]
		private MouseLook m_MouseLook;

		[SerializeField]
		private bool m_UseFovKick;

		[SerializeField]
		private FOVKick m_FovKick = new FOVKick();

		[SerializeField]
		private bool m_UseHeadBob;

		[SerializeField]
		private CurveControlledBob m_HeadBob = new CurveControlledBob();

		[SerializeField]
		private LerpControlledBob m_JumpBob = new LerpControlledBob();

		[SerializeField]
		private float m_StepInterval;

		[SerializeField]
		private AudioClip[] m_FootstepSounds;

		[SerializeField]
		private AudioClip m_JumpSound;

		[SerializeField]
		private AudioClip m_LandSound;

		private Camera m_Camera;

		private bool m_Jump;

		private float m_YRotation;

		private Vector2 m_Input;

		private Vector3 m_MoveDir = Vector3.zero;

		private CharacterController m_CharacterController;

		private CollisionFlags m_CollisionFlags;

		private bool m_PreviouslyGrounded;

		private Vector3 m_OriginalCameraPosition;

		private float m_StepCycle;

		private float m_NextStep;

		private bool m_Jumping;

		private AudioSource m_AudioSource;

		private void Start()
		{
			m_CharacterController = GetComponent<CharacterController>();
			m_Camera = Camera.main;
			m_OriginalCameraPosition = m_Camera.transform.localPosition;
			m_FovKick.Setup(m_Camera);
			m_HeadBob.Setup(m_Camera, m_StepInterval);
			m_StepCycle = 0f;
			m_NextStep = m_StepCycle / 2f;
			m_Jumping = false;
			m_AudioSource = GetComponent<AudioSource>();
			m_MouseLook.Init(base.transform, m_Camera.transform);
		}

		private void Update()
		{
			RotateView();
			if (!m_Jump)
			{
				m_Jump = CrossPlatformInputManager.GetButtonDown("Jump");
			}
			if (!m_PreviouslyGrounded && m_CharacterController.isGrounded)
			{
				StartCoroutine(m_JumpBob.DoBobCycle());
				PlayLandingSound();
				m_MoveDir.y = 0f;
				m_Jumping = false;
			}
			if (!m_CharacterController.isGrounded && !m_Jumping && m_PreviouslyGrounded)
			{
				m_MoveDir.y = 0f;
			}
			m_PreviouslyGrounded = m_CharacterController.isGrounded;
		}

		private void PlayLandingSound()
		{
			m_AudioSource.clip = m_LandSound;
			m_AudioSource.Play();
			m_NextStep = m_StepCycle + 0.5f;
		}

		private void FixedUpdate()
		{
			GetInput(out var speed);
			Vector3 vector = base.transform.forward * m_Input.y + base.transform.right * m_Input.x;
			Physics.SphereCast(base.transform.position, m_CharacterController.radius, Vector3.down, out var hitInfo, m_CharacterController.height / 2f);
			vector = Vector3.ProjectOnPlane(vector, hitInfo.normal).normalized;
			m_MoveDir.x = vector.x * speed;
			m_MoveDir.z = vector.z * speed;
			if (m_CharacterController.isGrounded)
			{
				m_MoveDir.y = 0f - m_StickToGroundForce;
				if (m_Jump)
				{
					m_MoveDir.y = m_JumpSpeed;
					PlayJumpSound();
					m_Jump = false;
					m_Jumping = true;
				}
			}
			else
			{
				m_MoveDir += Physics.gravity * m_GravityMultiplier * Time.fixedDeltaTime;
			}
			m_CollisionFlags = m_CharacterController.Move(m_MoveDir * Time.fixedDeltaTime);
			ProgressStepCycle(speed);
			UpdateCameraPosition(speed);
		}

		private void PlayJumpSound()
		{
			m_AudioSource.clip = m_JumpSound;
			m_AudioSource.Play();
		}

		private void ProgressStepCycle(float speed)
		{
			if (m_CharacterController.velocity.sqrMagnitude > 0f && (m_Input.x != 0f || m_Input.y != 0f))
			{
				m_StepCycle += (m_CharacterController.velocity.magnitude + speed * (m_IsWalking ? 1f : m_RunstepLenghten)) * Time.fixedDeltaTime;
			}
			if (m_StepCycle > m_NextStep)
			{
				m_NextStep = m_StepCycle + m_StepInterval;
				PlayFootStepAudio();
			}
		}

		private void PlayFootStepAudio()
		{
			if (m_CharacterController.isGrounded)
			{
				int num = UnityEngine.Random.Range(1, m_FootstepSounds.Length);
				m_AudioSource.clip = m_FootstepSounds[num];
				m_AudioSource.PlayOneShot(m_AudioSource.clip);
				m_FootstepSounds[num] = m_FootstepSounds[0];
				m_FootstepSounds[0] = m_AudioSource.clip;
			}
		}

		private void UpdateCameraPosition(float speed)
		{
			if (m_UseHeadBob)
			{
				Vector3 localPosition;
				if (m_CharacterController.velocity.magnitude > 0f && m_CharacterController.isGrounded)
				{
					m_Camera.transform.localPosition = m_HeadBob.DoHeadBob(m_CharacterController.velocity.magnitude + speed * (m_IsWalking ? 1f : m_RunstepLenghten));
					localPosition = m_Camera.transform.localPosition;
					localPosition.y = m_Camera.transform.localPosition.y - m_JumpBob.Offset();
				}
				else
				{
					localPosition = m_Camera.transform.localPosition;
					localPosition.y = m_OriginalCameraPosition.y - m_JumpBob.Offset();
				}
				m_Camera.transform.localPosition = localPosition;
			}
		}

		private void GetInput(out float speed)
		{
			float axis = CrossPlatformInputManager.GetAxis("Horizontal");
			float axis2 = CrossPlatformInputManager.GetAxis("Vertical");
			bool isWalking = m_IsWalking;
			m_IsWalking = !Input.GetKey(KeyCode.LeftShift);
			speed = (m_IsWalking ? m_WalkSpeed : m_RunSpeed);
			m_Input = new Vector2(axis, axis2);
			if (m_Input.sqrMagnitude > 1f)
			{
				m_Input.Normalize();
			}
			if (m_IsWalking != isWalking && m_UseFovKick && m_CharacterController.velocity.sqrMagnitude > 0f)
			{
				StopAllCoroutines();
				StartCoroutine((!m_IsWalking) ? m_FovKick.FOVKickUp() : m_FovKick.FOVKickDown());
			}
		}

		private void RotateView()
		{
			m_MouseLook.LookRotation(base.transform, m_Camera.transform);
		}

		private void OnControllerColliderHit(ControllerColliderHit hit)
		{
			Rigidbody attachedRigidbody = hit.collider.attachedRigidbody;
			if (m_CollisionFlags != CollisionFlags.Below && !(attachedRigidbody == null) && !attachedRigidbody.isKinematic)
			{
				attachedRigidbody.AddForceAtPosition(m_CharacterController.velocity * 0.1f, hit.point, ForceMode.Impulse);
			}
		}
	}
	public class HeadBob : MonoBehaviour
	{
		public Camera Camera;

		public CurveControlledBob motionBob = new CurveControlledBob();

		public LerpControlledBob jumpAndLandingBob = new LerpControlledBob();

		public RigidbodyFirstPersonController rigidbodyFirstPersonController;

		public float StrideInterval;

		[Range(0f, 1f)]
		public float RunningStrideLengthen;

		private bool m_PreviouslyGrounded;

		private Vector3 m_OriginalCameraPosition;

		private void Start()
		{
			motionBob.Setup(Camera, StrideInterval);
			m_OriginalCameraPosition = Camera.transform.localPosition;
		}

		private void Update()
		{
			Vector3 localPosition;
			if (rigidbodyFirstPersonController.Velocity.magnitude > 0f && rigidbodyFirstPersonController.Grounded)
			{
				Camera.transform.localPosition = motionBob.DoHeadBob(rigidbodyFirstPersonController.Velocity.magnitude * (rigidbodyFirstPersonController.Running ? RunningStrideLengthen : 1f));
				localPosition = Camera.transform.localPosition;
				localPosition.y = Camera.transform.localPosition.y - jumpAndLandingBob.Offset();
			}
			else
			{
				localPosition = Camera.transform.localPosition;
				localPosition.y = m_OriginalCameraPosition.y - jumpAndLandingBob.Offset();
			}
			Camera.transform.localPosition = localPosition;
			if (!m_PreviouslyGrounded && rigidbodyFirstPersonController.Grounded)
			{
				StartCoroutine(jumpAndLandingBob.DoBobCycle());
			}
			m_PreviouslyGrounded = rigidbodyFirstPersonController.Grounded;
		}
	}
	[Serializable]
	public class MouseLook
	{
		public float XSensitivity = 2f;

		public float YSensitivity = 2f;

		public bool clampVerticalRotation = true;

		public float MinimumX = -90f;

		public float MaximumX = 90f;

		public bool smooth;

		public float smoothTime = 5f;

		private Quaternion m_CharacterTargetRot;

		private Quaternion m_CameraTargetRot;

		public void Init(Transform character, Transform camera)
		{
			m_CharacterTargetRot = character.localRotation;
			m_CameraTargetRot = camera.localRotation;
		}

		public void LookRotation(Transform character, Transform camera)
		{
			float y = CrossPlatformInputManager.GetAxis("Mouse X") * XSensitivity;
			float num = CrossPlatformInputManager.GetAxis("Mouse Y") * YSensitivity;
			m_CharacterTargetRot *= Quaternion.Euler(0f, y, 0f);
			m_CameraTargetRot *= Quaternion.Euler(0f - num, 0f, 0f);
			if (clampVerticalRotation)
			{
				m_CameraTargetRot = ClampRotationAroundXAxis(m_CameraTargetRot);
			}
			if (smooth)
			{
				character.localRotation = Quaternion.Slerp(character.localRotation, m_CharacterTargetRot, smoothTime * Time.deltaTime);
				camera.localRotation = Quaternion.Slerp(camera.localRotation, m_CameraTargetRot, smoothTime * Time.deltaTime);
			}
			else
			{
				character.localRotation = m_CharacterTargetRot;
				camera.localRotation = m_CameraTargetRot;
			}
		}

		private Quaternion ClampRotationAroundXAxis(Quaternion q)
		{
			q.x /= q.w;
			q.y /= q.w;
			q.z /= q.w;
			q.w = 1f;
			float value = 114.59156f * Mathf.Atan(q.x);
			value = Mathf.Clamp(value, MinimumX, MaximumX);
			q.x = Mathf.Tan(MathF.PI / 360f * value);
			return q;
		}
	}
	[RequireComponent(typeof(Rigidbody))]
	[RequireComponent(typeof(CapsuleCollider))]
	public class RigidbodyFirstPersonController : MonoBehaviour
	{
		[Serializable]
		public class MovementSettings
		{
			public float ForwardSpeed = 8f;

			public float BackwardSpeed = 4f;

			public float StrafeSpeed = 4f;

			public float RunMultiplier = 2f;

			public KeyCode RunKey = KeyCode.LeftShift;

			public float JumpForce = 30f;

			public AnimationCurve SlopeCurveModifier = new AnimationCurve(new Keyframe(-90f, 1f), new Keyframe(0f, 1f), new Keyframe(90f, 0f));

			[HideInInspector]
			public float CurrentTargetSpeed = 8f;

			private bool m_Running;

			public bool Running => m_Running;

			public void UpdateDesiredTargetSpeed(Vector2 input)
			{
				if (!(input == Vector2.zero))
				{
					if (input.x > 0f || input.x < 0f)
					{
						CurrentTargetSpeed = StrafeSpeed;
					}
					if (input.y < 0f)
					{
						CurrentTargetSpeed = BackwardSpeed;
					}
					if (input.y > 0f)
					{
						CurrentTargetSpeed = ForwardSpeed;
					}
					if (Input.GetKey(RunKey))
					{
						CurrentTargetSpeed *= RunMultiplier;
						m_Running = true;
					}
					else
					{
						m_Running = false;
					}
				}
			}
		}

		[Serializable]
		public class AdvancedSettings
		{
			public float groundCheckDistance = 0.01f;

			public float stickToGroundHelperDistance = 0.5f;

			public float slowDownRate = 20f;

			public bool airControl;
		}

		public Camera cam;

		public MovementSettings movementSettings = new MovementSettings();

		public MouseLook mouseLook = new MouseLook();

		public AdvancedSettings advancedSettings = new AdvancedSettings();

		private Rigidbody m_RigidBody;

		private CapsuleCollider m_Capsule;

		private float m_YRotation;

		private Vector3 m_GroundContactNormal;

		private bool m_Jump;

		private bool m_PreviouslyGrounded;

		private bool m_Jumping;

		private bool m_IsGrounded;

		public Vector3 Velocity => m_RigidBody.velocity;

		public bool Grounded => m_IsGrounded;

		public bool Jumping => m_Jumping;

		public bool Running => movementSettings.Running;

		private void Start()
		{
			m_RigidBody = GetComponent<Rigidbody>();
			m_Capsule = GetComponent<CapsuleCollider>();
			mouseLook.Init(base.transform, cam.transform);
		}

		private void Update()
		{
			RotateView();
			if (CrossPlatformInputManager.GetButtonDown("Jump") && !m_Jump)
			{
				m_Jump = true;
			}
		}

		private void FixedUpdate()
		{
			GroundCheck();
			Vector2 input = GetInput();
			if ((Mathf.Abs(input.x) > float.Epsilon || Mathf.Abs(input.y) > float.Epsilon) && (advancedSettings.airControl || m_IsGrounded))
			{
				Vector3 vector = cam.transform.forward * input.y + cam.transform.right * input.x;
				vector = Vector3.ProjectOnPlane(vector, m_GroundContactNormal).normalized;
				vector.x *= movementSettings.CurrentTargetSpeed;
				vector.z *= movementSettings.CurrentTargetSpeed;
				vector.y *= movementSettings.CurrentTargetSpeed;
				if (m_RigidBody.velocity.sqrMagnitude < movementSettings.CurrentTargetSpeed * movementSettings.CurrentTargetSpeed)
				{
					m_RigidBody.AddForce(vector * SlopeMultiplier(), ForceMode.Impulse);
				}
			}
			if (m_IsGrounded)
			{
				m_RigidBody.drag = 5f;
				if (m_Jump)
				{
					m_RigidBody.drag = 0f;
					m_RigidBody.velocity = new Vector3(m_RigidBody.velocity.x, 0f, m_RigidBody.velocity.z);
					m_RigidBody.AddForce(new Vector3(0f, movementSettings.JumpForce, 0f), ForceMode.Impulse);
					m_Jumping = true;
				}
				if (!m_Jumping && Mathf.Abs(input.x) < float.Epsilon && Mathf.Abs(input.y) < float.Epsilon && m_RigidBody.velocity.magnitude < 1f)
				{
					m_RigidBody.Sleep();
				}
			}
			else
			{
				m_RigidBody.drag = 0f;
				if (m_PreviouslyGrounded && !m_Jumping)
				{
					StickToGroundHelper();
				}
			}
			m_Jump = false;
		}

		private float SlopeMultiplier()
		{
			float time = Vector3.Angle(m_GroundContactNormal, Vector3.up);
			return movementSettings.SlopeCurveModifier.Evaluate(time);
		}

		private void StickToGroundHelper()
		{
			if (Physics.SphereCast(base.transform.position, m_Capsule.radius, Vector3.down, out var hitInfo, m_Capsule.height / 2f - m_Capsule.radius + advancedSettings.stickToGroundHelperDistance) && Mathf.Abs(Vector3.Angle(hitInfo.normal, Vector3.up)) < 85f)
			{
				m_RigidBody.velocity = Vector3.ProjectOnPlane(m_RigidBody.velocity, hitInfo.normal);
			}
		}

		private Vector2 GetInput()
		{
			Vector2 vector = default(Vector2);
			vector.x = CrossPlatformInputManager.GetAxis("Horizontal");
			vector.y = CrossPlatformInputManager.GetAxis("Vertical");
			Vector2 vector2 = vector;
			movementSettings.UpdateDesiredTargetSpeed(vector2);
			return vector2;
		}

		private void RotateView()
		{
			if (!(Mathf.Abs(Time.timeScale) < float.Epsilon))
			{
				float y = base.transform.eulerAngles.y;
				mouseLook.LookRotation(base.transform, cam.transform);
				if (m_IsGrounded || advancedSettings.airControl)
				{
					Quaternion quaternion = Quaternion.AngleAxis(base.transform.eulerAngles.y - y, Vector3.up);
					m_RigidBody.velocity = quaternion * m_RigidBody.velocity;
				}
			}
		}

		private void GroundCheck()
		{
			m_PreviouslyGrounded = m_IsGrounded;
			if (Physics.SphereCast(base.transform.position, m_Capsule.radius, Vector3.down, out var hitInfo, m_Capsule.height / 2f - m_Capsule.radius + advancedSettings.groundCheckDistance))
			{
				m_IsGrounded = true;
				m_GroundContactNormal = hitInfo.normal;
			}
			else
			{
				m_IsGrounded = false;
				m_GroundContactNormal = Vector3.up;
			}
			if (!m_PreviouslyGrounded && m_IsGrounded && m_Jumping)
			{
				m_Jumping = false;
			}
		}
	}
}
namespace UnityStandardAssets.Cameras
{
	public abstract class AbstractTargetFollower : MonoBehaviour
	{
		public enum UpdateType
		{
			FixedUpdate,
			LateUpdate,
			ManualUpdate
		}

		[SerializeField]
		protected Transform m_Target;

		[SerializeField]
		private bool m_AutoTargetPlayer = true;

		[SerializeField]
		private UpdateType m_UpdateType;

		protected Rigidbody targetRigidbody;

		public Transform Target => m_Target;

		protected virtual void Start()
		{
			if (m_AutoTargetPlayer)
			{
				FindAndTargetPlayer();
			}
			if (!(m_Target == null))
			{
				targetRigidbody = m_Target.GetComponent<Rigidbody>();
			}
		}

		private void FixedUpdate()
		{
			if (m_AutoTargetPlayer && (m_Target == null || !m_Target.gameObject.activeSelf))
			{
				FindAndTargetPlayer();
			}
			if (m_UpdateType == UpdateType.FixedUpdate)
			{
				FollowTarget(Time.deltaTime);
			}
		}

		private void LateUpdate()
		{
			if (m_AutoTargetPlayer && (m_Target == null || !m_Target.gameObject.activeSelf))
			{
				FindAndTargetPlayer();
			}
			if (m_UpdateType == UpdateType.LateUpdate)
			{
				FollowTarget(Time.deltaTime);
			}
		}

		public void ManualUpdate()
		{
			if (m_AutoTargetPlayer && (m_Target == null || !m_Target.gameObject.activeSelf))
			{
				FindAndTargetPlayer();
			}
			if (m_UpdateType == UpdateType.ManualUpdate)
			{
				FollowTarget(Time.deltaTime);
			}
		}

		protected abstract void FollowTarget(float deltaTime);

		public void FindAndTargetPlayer()
		{
			GameObject gameObject = GameObject.FindGameObjectWithTag("Player");
			if ((bool)gameObject)
			{
				SetTarget(gameObject.transform);
			}
		}

		public virtual void SetTarget(Transform newTransform)
		{
			m_Target = newTransform;
		}
	}
	public class FreeLookCam : PivotBasedCameraRig
	{
		[SerializeField]
		private float m_MoveSpeed = 1f;

		[Range(0f, 10f)]
		[SerializeField]
		private float m_TurnSpeed = 1.5f;

		[SerializeField]
		private float m_TurnSmoothing;

		[SerializeField]
		private float m_TiltMax = 75f;

		[SerializeField]
		private float m_TiltMin = 45f;

		[SerializeField]
		private bool m_LockCursor;

		[SerializeField]
		private bool m_VerticalAutoReturn;

		private float m_LookAngle;

		private float m_TiltAngle;

		private const float k_LookDistance = 100f;

		private Vector3 m_PivotEulers;

		private Quaternion m_PivotTargetRot;

		private Quaternion m_TransformTargetRot;

		protected override void Awake()
		{
			base.Awake();
			UnityEngine.Cursor.lockState = (m_LockCursor ? CursorLockMode.Locked : CursorLockMode.None);
			UnityEngine.Cursor.visible = !m_LockCursor;
			m_PivotEulers = m_Pivot.rotation.eulerAngles;
			m_PivotTargetRot = m_Pivot.transform.localRotation;
			m_TransformTargetRot = base.transform.localRotation;
		}

		protected void Update()
		{
			HandleRotationMovement();
			if (m_LockCursor && Input.GetMouseButtonUp(0))
			{
				UnityEngine.Cursor.lockState = (m_LockCursor ? CursorLockMode.Locked : CursorLockMode.None);
				UnityEngine.Cursor.visible = !m_LockCursor;
			}
		}

		private void OnDisable()
		{
			UnityEngine.Cursor.lockState = CursorLockMode.None;
			UnityEngine.Cursor.visible = true;
		}

		protected override void FollowTarget(float deltaTime)
		{
			if (!(m_Target == null))
			{
				base.transform.position = Vector3.Lerp(base.transform.position, m_Target.position, deltaTime * m_MoveSpeed);
			}
		}

		private void HandleRotationMovement()
		{
			if (!(Time.timeScale < float.Epsilon))
			{
				float axis = Input.GetAxis("Mouse X");
				float axis2 = Input.GetAxis("Mouse Y");
				m_LookAngle += axis * m_TurnSpeed;
				m_TransformTargetRot = Quaternion.Euler(0f, m_LookAngle, 0f);
				if (m_VerticalAutoReturn)
				{
					m_TiltAngle = ((axis2 > 0f) ? Mathf.Lerp(0f, 0f - m_TiltMin, axis2) : Mathf.Lerp(0f, m_TiltMax, 0f - axis2));
				}
				else
				{
					m_TiltAngle -= axis2 * m_TurnSpeed;
					m_TiltAngle = Mathf.Clamp(m_TiltAngle, 0f - m_TiltMin, m_TiltMax);
				}
				m_PivotTargetRot = Quaternion.Euler(m_TiltAngle, m_PivotEulers.y, m_PivotEulers.z);
				if (m_TurnSmoothing > 0f)
				{
					m_Pivot.localRotation = Quaternion.Slerp(m_Pivot.localRotation, m_PivotTargetRot, m_TurnSmoothing * Time.deltaTime);
					base.transform.localRotation = Quaternion.Slerp(base.transform.localRotation, m_TransformTargetRot, m_TurnSmoothing * Time.deltaTime);
				}
				else
				{
					m_Pivot.localRotation = m_PivotTargetRot;
					base.transform.localRotation = m_TransformTargetRot;
				}
			}
		}
	}
	public abstract class PivotBasedCameraRig : AbstractTargetFollower
	{
		protected Transform m_Cam;

		protected Transform m_Pivot;

		protected Vector3 m_LastTargetPosition;

		protected virtual void Awake()
		{
			m_Cam = GetComponentInChildren<Camera>().transform;
			m_Pivot = m_Cam.parent;
		}
	}
}
namespace HedgehogTeam.EasyTouch
{
	[Serializable]
	[AddComponentMenu("EasyTouch/Trigger")]
	public class EasyTouchTrigger : MonoBehaviour
	{
		public enum ETTParameter
		{
			None,
			Gesture,
			Finger_Id,
			Touch_Count,
			Start_Position,
			Position,
			Delta_Position,
			Swipe_Type,
			Swipe_Length,
			Swipe_Vector,
			Delta_Pinch,
			Twist_Anlge,
			ActionTime,
			DeltaTime,
			PickedObject,
			PickedUIElement
		}

		public enum ETTType
		{
			Object3D,
			UI
		}

		[Serializable]
		public class EasyTouchReceiver
		{
			public bool enable;

			public ETTType triggerType;

			public string name;

			public bool restricted;

			public GameObject gameObject;

			public bool otherReceiver;

			public GameObject gameObjectReceiver;

			public EasyTouch.EvtType eventName;

			public string methodName;

			public ETTParameter parameter;
		}

		[SerializeField]
		public List<EasyTouchReceiver> receivers = new List<EasyTouchReceiver>();

		private void Start()
		{
			EasyTouch.SetEnableAutoSelect(value: true);
		}

		private void OnEnable()
		{
			SubscribeEasyTouchEvent();
		}

		private void OnDisable()
		{
			UnsubscribeEasyTouchEvent();
		}

		private void OnDestroy()
		{
			UnsubscribeEasyTouchEvent();
		}

		private void SubscribeEasyTouchEvent()
		{
			if (IsRecevier4(EasyTouch.EvtType.On_Cancel))
			{
				EasyTouch.On_Cancel += On_Cancel;
			}
			if (IsRecevier4(EasyTouch.EvtType.On_TouchStart))
			{
				EasyTouch.On_TouchStart += On_TouchStart;
			}
			if (IsRecevier4(EasyTouch.EvtType.On_TouchDown))
			{
				EasyTouch.On_TouchDown += On_TouchDown;
			}
			if (IsRecevier4(EasyTouch.EvtType.On_TouchUp))
			{
				EasyTouch.On_TouchUp += On_TouchUp;
			}
			if (IsRecevier4(EasyTouch.EvtType.On_SimpleTap))
			{
				EasyTouch.On_SimpleTap += On_SimpleTap;
			}
			if (IsRecevier4(EasyTouch.EvtType.On_LongTapStart))
			{
				EasyTouch.On_LongTapStart += On_LongTapStart;
			}
			if (IsRecevier4(EasyTouch.EvtType.On_LongTap))
			{
				EasyTouch.On_LongTap += On_LongTap;
			}
			if (IsRecevier4(EasyTouch.EvtType.On_LongTapEnd))
			{
				EasyTouch.On_LongTapEnd += On_LongTapEnd;
			}
			if (IsRecevier4(EasyTouch.EvtType.On_DoubleTap))
			{
				EasyTouch.On_DoubleTap += On_DoubleTap;
			}
			if (IsRecevier4(EasyTouch.EvtType.On_DragStart))
			{
				EasyTouch.On_DragStart += On_DragStart;
			}
			if (IsRecevier4(EasyTouch.EvtType.On_Drag))
			{
				EasyTouch.On_Drag += On_Drag;
			}
			if (IsRecevier4(EasyTouch.EvtType.On_DragEnd))
			{
				EasyTouch.On_DragEnd += On_DragEnd;
			}
			if (IsRecevier4(EasyTouch.EvtType.On_SwipeStart))
			{
				EasyTouch.On_SwipeStart += On_SwipeStart;
			}
			if (IsRecevier4(EasyTouch.EvtType.On_Swipe))
			{
				EasyTouch.On_Swipe += On_Swipe;
			}
			if (IsRecevier4(EasyTouch.EvtType.On_SwipeEnd))
			{
				EasyTouch.On_SwipeEnd += On_SwipeEnd;
			}
			if (IsRecevier4(EasyTouch.EvtType.On_TouchStart2Fingers))
			{
				EasyTouch.On_TouchStart2Fingers += On_TouchStart2Fingers;
			}
			if (IsRecevier4(EasyTouch.EvtType.On_TouchDown2Fingers))
			{
				EasyTouch.On_TouchDown2Fingers += On_TouchDown2Fingers;
			}
			if (IsRecevier4(EasyTouch.EvtType.On_TouchUp2Fingers))
			{
				EasyTouch.On_TouchUp2Fingers += On_TouchUp2Fingers;
			}
			if (IsRecevier4(EasyTouch.EvtType.On_SimpleTap2Fingers))
			{
				EasyTouch.On_SimpleTap2Fingers += On_SimpleTap2Fingers;
			}
			if (IsRecevier4(EasyTouch.EvtType.On_LongTapStart2Fingers))
			{
				EasyTouch.On_LongTapStart2Fingers += On_LongTapStart2Fingers;
			}
			if (IsRecevier4(EasyTouch.EvtType.On_LongTap2Fingers))
			{
				EasyTouch.On_LongTap2Fingers += On_LongTap2Fingers;
			}
			if (IsRecevier4(EasyTouch.EvtType.On_LongTapEnd2Fingers))
			{
				EasyTouch.On_LongTapEnd2Fingers += On_LongTapEnd2Fingers;
			}
			if (IsRecevier4(EasyTouch.EvtType.On_DoubleTap2Fingers))
			{
				EasyTouch.On_DoubleTap2Fingers += On_DoubleTap2Fingers;
			}
			if (IsRecevier4(EasyTouch.EvtType.On_SwipeStart2Fingers))
			{
				EasyTouch.On_SwipeStart2Fingers += On_SwipeStart2Fingers;
			}
			if (IsRecevier4(EasyTouch.EvtType.On_Swipe2Fingers))
			{
				EasyTouch.On_Swipe2Fingers += On_Swipe2Fingers;
			}
			if (IsRecevier4(EasyTouch.EvtType.On_SwipeEnd2Fingers))
			{
				EasyTouch.On_SwipeEnd2Fingers += On_SwipeEnd2Fingers;
			}
			if (IsRecevier4(EasyTouch.EvtType.On_DragStart2Fingers))
			{
				EasyTouch.On_DragStart2Fingers += On_DragStart2Fingers;
			}
			if (IsRecevier4(EasyTouch.EvtType.On_Drag2Fingers))
			{
				EasyTouch.On_Drag2Fingers += On_Drag2Fingers;
			}
			if (IsRecevier4(EasyTouch.EvtType.On_DragEnd2Fingers))
			{
				EasyTouch.On_DragEnd2Fingers += On_DragEnd2Fingers;
			}
			if (IsRecevier4(EasyTouch.EvtType.On_Pinch))
			{
				EasyTouch.On_Pinch += On_Pinch;
			}
			if (IsRecevier4(EasyTouch.EvtType.On_PinchIn))
			{
				EasyTouch.On_PinchIn += On_PinchIn;
			}
			if (IsRecevier4(EasyTouch.EvtType.On_PinchOut))
			{
				EasyTouch.On_PinchOut += On_PinchOut;
			}
			if (IsRecevier4(EasyTouch.EvtType.On_PinchEnd))
			{
				EasyTouch.On_PinchEnd += On_PinchEnd;
			}
			if (IsRecevier4(EasyTouch.EvtType.On_Twist))
			{
				EasyTouch.On_Twist += On_Twist;
			}
			if (IsRecevier4(EasyTouch.EvtType.On_TwistEnd))
			{
				EasyTouch.On_TwistEnd += On_TwistEnd;
			}
			if (IsRecevier4(EasyTouch.EvtType.On_OverUIElement))
			{
				EasyTouch.On_OverUIElement += On_OverUIElement;
			}
			if (IsRecevier4(EasyTouch.EvtType.On_UIElementTouchUp))
			{
				EasyTouch.On_UIElementTouchUp += On_UIElementTouchUp;
			}
		}

		private void UnsubscribeEasyTouchEvent()
		{
			EasyTouch.On_Cancel -= On_Cancel;
			EasyTouch.On_TouchStart -= On_TouchStart;
			EasyTouch.On_TouchDown -= On_TouchDown;
			EasyTouch.On_TouchUp -= On_TouchUp;
			EasyTouch.On_SimpleTap -= On_SimpleTap;
			EasyTouch.On_LongTapStart -= On_LongTapStart;
			EasyTouch.On_LongTap -= On_LongTap;
			EasyTouch.On_LongTapEnd -= On_LongTapEnd;
			EasyTouch.On_DoubleTap -= On_DoubleTap;
			EasyTouch.On_DragStart -= On_DragStart;
			EasyTouch.On_Drag -= On_Drag;
			EasyTouch.On_DragEnd -= On_DragEnd;
			EasyTouch.On_SwipeStart -= On_SwipeStart;
			EasyTouch.On_Swipe -= On_Swipe;
			EasyTouch.On_SwipeEnd -= On_SwipeEnd;
			EasyTouch.On_TouchStart2Fingers -= On_TouchStart2Fingers;
			EasyTouch.On_TouchDown2Fingers -= On_TouchDown2Fingers;
			EasyTouch.On_TouchUp2Fingers -= On_TouchUp2Fingers;
			EasyTouch.On_SimpleTap2Fingers -= On_SimpleTap2Fingers;
			EasyTouch.On_LongTapStart2Fingers -= On_LongTapStart2Fingers;
			EasyTouch.On_LongTap2Fingers -= On_LongTap2Fingers;
			EasyTouch.On_LongTapEnd2Fingers -= On_LongTapEnd2Fingers;
			EasyTouch.On_DoubleTap2Fingers -= On_DoubleTap2Fingers;
			EasyTouch.On_SwipeStart2Fingers -= On_SwipeStart2Fingers;
			EasyTouch.On_Swipe2Fingers -= On_Swipe2Fingers;
			EasyTouch.On_SwipeEnd2Fingers -= On_SwipeEnd2Fingers;
			EasyTouch.On_DragStart2Fingers -= On_DragStart2Fingers;
			EasyTouch.On_Drag2Fingers -= On_Drag2Fingers;
			EasyTouch.On_DragEnd2Fingers -= On_DragEnd2Fingers;
			EasyTouch.On_Pinch -= On_Pinch;
			EasyTouch.On_PinchIn -= On_PinchIn;
			EasyTouch.On_PinchOut -= On_PinchOut;
			EasyTouch.On_PinchEnd -= On_PinchEnd;
			EasyTouch.On_Twist -= On_Twist;
			EasyTouch.On_TwistEnd -= On_TwistEnd;
			EasyTouch.On_OverUIElement += On_OverUIElement;
			EasyTouch.On_UIElementTouchUp += On_UIElementTouchUp;
		}

		private void On_TouchStart(Gesture gesture)
		{
			TriggerScheduler(EasyTouch.EvtType.On_TouchStart, gesture);
		}

		private void On_TouchDown(Gesture gesture)
		{
			TriggerScheduler(EasyTouch.EvtType.On_TouchDown, gesture);
		}

		private void On_TouchUp(Gesture gesture)
		{
			TriggerScheduler(EasyTouch.EvtType.On_TouchUp, gesture);
		}

		private void On_SimpleTap(Gesture gesture)
		{
			TriggerScheduler(EasyTouch.EvtType.On_SimpleTap, gesture);
		}

		private void On_DoubleTap(Gesture gesture)
		{
			TriggerScheduler(EasyTouch.EvtType.On_DoubleTap, gesture);
		}

		private void On_LongTapStart(Gesture gesture)
		{
			TriggerScheduler(EasyTouch.EvtType.On_LongTapStart, gesture);
		}

		private void On_LongTap(Gesture gesture)
		{
			TriggerScheduler(EasyTouch.EvtType.On_LongTap, gesture);
		}

		private void On_LongTapEnd(Gesture gesture)
		{
			TriggerScheduler(EasyTouch.EvtType.On_LongTapEnd, gesture);
		}

		private void On_SwipeStart(Gesture gesture)
		{
			TriggerScheduler(EasyTouch.EvtType.On_SwipeStart, gesture);
		}

		private void On_Swipe(Gesture gesture)
		{
			TriggerScheduler(EasyTouch.EvtType.On_Swipe, gesture);
		}

		private void On_SwipeEnd(Gesture gesture)
		{
			TriggerScheduler(EasyTouch.EvtType.On_SwipeEnd, gesture);
		}

		private void On_DragStart(Gesture gesture)
		{
			TriggerScheduler(EasyTouch.EvtType.On_DragStart, gesture);
		}

		private void On_Drag(Gesture gesture)
		{
			TriggerScheduler(EasyTouch.EvtType.On_Drag, gesture);
		}

		private void On_DragEnd(Gesture gesture)
		{
			TriggerScheduler(EasyTouch.EvtType.On_DragEnd, gesture);
		}

		private void On_Cancel(Gesture gesture)
		{
			TriggerScheduler(EasyTouch.EvtType.On_Cancel, gesture);
		}

		private void On_TouchStart2Fingers(Gesture gesture)
		{
			TriggerScheduler(EasyTouch.EvtType.On_TouchStart2Fingers, gesture);
		}

		private void On_TouchDown2Fingers(Gesture gesture)
		{
			TriggerScheduler(EasyTouch.EvtType.On_TouchDown2Fingers, gesture);
		}

		private void On_TouchUp2Fingers(Gesture gesture)
		{
			TriggerScheduler(EasyTouch.EvtType.On_TouchUp2Fingers, gesture);
		}

		private void On_LongTapStart2Fingers(Gesture gesture)
		{
			TriggerScheduler(EasyTouch.EvtType.On_LongTapStart2Fingers, gesture);
		}

		private void On_LongTap2Fingers(Gesture gesture)
		{
			TriggerScheduler(EasyTouch.EvtType.On_LongTap2Fingers, gesture);
		}

		private void On_LongTapEnd2Fingers(Gesture gesture)
		{
			TriggerScheduler(EasyTouch.EvtType.On_LongTapEnd2Fingers, gesture);
		}

		private void On_DragStart2Fingers(Gesture gesture)
		{
			TriggerScheduler(EasyTouch.EvtType.On_DragStart2Fingers, gesture);
		}

		private void On_Drag2Fingers(Gesture gesture)
		{
			TriggerScheduler(EasyTouch.EvtType.On_Drag2Fingers, gesture);
		}

		private void On_DragEnd2Fingers(Gesture gesture)
		{
			TriggerScheduler(EasyTouch.EvtType.On_DragEnd2Fingers, gesture);
		}

		private void On_SwipeStart2Fingers(Gesture gesture)
		{
			TriggerScheduler(EasyTouch.EvtType.On_SwipeStart2Fingers, gesture);
		}

		private void On_Swipe2Fingers(Gesture gesture)
		{
			TriggerScheduler(EasyTouch.EvtType.On_Swipe2Fingers, gesture);
		}

		private void On_SwipeEnd2Fingers(Gesture gesture)
		{
			TriggerScheduler(EasyTouch.EvtType.On_SwipeEnd2Fingers, gesture);
		}

		private void On_Twist(Gesture gesture)
		{
			TriggerScheduler(EasyTouch.EvtType.On_Twist, gesture);
		}

		private void On_TwistEnd(Gesture gesture)
		{
			TriggerScheduler(EasyTouch.EvtType.On_TwistEnd, gesture);
		}

		private void On_Pinch(Gesture gesture)
		{
			TriggerScheduler(EasyTouch.EvtType.On_Pinch, gesture);
		}

		private void On_PinchOut(Gesture gesture)
		{
			TriggerScheduler(EasyTouch.EvtType.On_PinchOut, gesture);
		}

		private void On_PinchIn(Gesture gesture)
		{
			TriggerScheduler(EasyTouch.EvtType.On_PinchIn, gesture);
		}

		private void On_PinchEnd(Gesture gesture)
		{
			TriggerScheduler(EasyTouch.EvtType.On_PinchEnd, gesture);
		}

		private void On_SimpleTap2Fingers(Gesture gesture)
		{
			TriggerScheduler(EasyTouch.EvtType.On_SimpleTap2Fingers, gesture);
		}

		private void On_DoubleTap2Fingers(Gesture gesture)
		{
			TriggerScheduler(EasyTouch.EvtType.On_DoubleTap2Fingers, gesture);
		}

		private void On_UIElementTouchUp(Gesture gesture)
		{
			TriggerScheduler(EasyTouch.EvtType.On_UIElementTouchUp, gesture);
		}

		private void On_OverUIElement(Gesture gesture)
		{
			TriggerScheduler(EasyTouch.EvtType.On_OverUIElement, gesture);
		}

		public void AddTrigger(EasyTouch.EvtType ev)
		{
			EasyTouchReceiver easyTouchReceiver = new EasyTouchReceiver();
			easyTouchReceiver.enable = true;
			easyTouchReceiver.restricted = true;
			easyTouchReceiver.eventName = ev;
			easyTouchReceiver.gameObject = null;
			easyTouchReceiver.otherReceiver = false;
			easyTouchReceiver.name = "New trigger";
			receivers.Add(easyTouchReceiver);
			if (UnityEngine.Application.isPlaying)
			{
				UnsubscribeEasyTouchEvent();
				SubscribeEasyTouchEvent();
			}
		}

		public bool SetTriggerEnable(string triggerName, bool value)
		{
			EasyTouchReceiver trigger = GetTrigger(triggerName);
			if (trigger != null)
			{
				trigger.enable = value;
				return true;
			}
			return false;
		}

		public bool GetTriggerEnable(string triggerName)
		{
			return GetTrigger(triggerName)?.enable ?? false;
		}

		private void TriggerScheduler(EasyTouch.EvtType evnt, Gesture gesture)
		{
			foreach (EasyTouchReceiver receiver in receivers)
			{
				if (!receiver.enable || receiver.eventName != evnt || ((!receiver.restricted || ((!(gesture.pickedObject == base.gameObject) || receiver.triggerType != 0) && (!(gesture.pickedUIElement == base.gameObject) || receiver.triggerType != ETTType.UI))) && (receiver.restricted || (!(receiver.gameObject == null) && (!(receiver.gameObject == gesture.pickedObject) || receiver.triggerType != 0) && (!(gesture.pickedUIElement == receiver.gameObject) || receiver.triggerType != ETTType.UI)))))
				{
					continue;
				}
				GameObject gameObjectReceiver = base.gameObject;
				if (receiver.otherReceiver && receiver.gameObjectReceiver != null)
				{
					gameObjectReceiver = receiver.gameObjectReceiver;
				}
				switch (receiver.parameter)
				{
				case ETTParameter.None:
					gameObjectReceiver.SendMessage(receiver.methodName, SendMessageOptions.DontRequireReceiver);
					break;
				case ETTParameter.ActionTime:
					gameObjectReceiver.SendMessage(receiver.methodName, gesture.actionTime, SendMessageOptions.DontRequireReceiver);
					break;
				case ETTParameter.Delta_Pinch:
					gameObjectReceiver.SendMessage(receiver.methodName, gesture.deltaPinch, SendMessageOptions.DontRequireReceiver);
					break;
				case ETTParameter.Delta_Position:
					gameObjectReceiver.SendMessage(receiver.methodName, gesture.deltaPosition, SendMessageOptions.DontRequireReceiver);
					break;
				case ETTParameter.DeltaTime:
					gameObjectReceiver.SendMessage(receiver.methodName, gesture.deltaTime, SendMessageOptions.DontRequireReceiver);
					break;
				case ETTParameter.Finger_Id:
					gameObjectReceiver.SendMessage(receiver.methodName, gesture.fingerIndex, SendMessageOptions.DontRequireReceiver);
					break;
				case ETTParameter.Gesture:
					gameObjectReceiver.SendMessage(receiver.methodName, gesture, SendMessageOptions.DontRequireReceiver);
					break;
				case ETTParameter.PickedObject:
					if (gesture.pickedObject != null)
					{
						gameObjectReceiver.SendMessage(receiver.methodName, gesture.pickedObject, SendMessageOptions.DontRequireReceiver);
					}
					break;
				case ETTParameter.PickedUIElement:
					if (gesture.pickedUIElement != null)
					{
						gameObjectReceiver.SendMessage(receiver.methodName, gesture.pickedObject, SendMessageOptions.DontRequireReceiver);
					}
					break;
				case ETTParameter.Position:
					gameObjectReceiver.SendMessage(receiver.methodName, gesture.position, SendMessageOptions.DontRequireReceiver);
					break;
				case ETTParameter.Start_Position:
					gameObjectReceiver.SendMessage(receiver.methodName, gesture.startPosition, SendMessageOptions.DontRequireReceiver);
					break;
				case ETTParameter.Swipe_Length:
					gameObjectReceiver.SendMessage(receiver.methodName, gesture.swipeLength, SendMessageOptions.DontRequireReceiver);
					break;
				case ETTParameter.Swipe_Type:
					gameObjectReceiver.SendMessage(receiver.methodName, gesture.swipe, SendMessageOptions.DontRequireReceiver);
					break;
				case ETTParameter.Swipe_Vector:
					gameObjectReceiver.SendMessage(receiver.methodName, gesture.swipeVector, SendMessageOptions.DontRequireReceiver);
					break;
				case ETTParameter.Touch_Count:
					gameObjectReceiver.SendMessage(receiver.methodName, gesture.touchCount, SendMessageOptions.DontRequireReceiver);
					break;
				case ETTParameter.Twist_Anlge:
					gameObjectReceiver.SendMessage(receiver.methodName, gesture.twistAngle, SendMessageOptions.DontRequireReceiver);
					break;
				}
			}
		}

		private bool IsRecevier4(EasyTouch.EvtType evnt)
		{
			if (receivers.FindIndex((EasyTouchReceiver e) => e.eventName == evnt) > -1)
			{
				return true;
			}
			return false;
		}

		private EasyTouchReceiver GetTrigger(string triggerName)
		{
			return receivers.Find((EasyTouchReceiver n) => n.name == triggerName);
		}
	}
	public class QuickBase : MonoBehaviour
	{
		protected enum GameObjectType
		{
			Auto,
			Obj_3D,
			Obj_2D,
			UI
		}

		public enum DirectAction
		{
			None,
			Rotate,
			RotateLocal,
			Translate,
			TranslateLocal,
			Scale
		}

		public enum AffectedAxesAction
		{
			X,
			Y,
			Z,
			XY,
			XZ,
			YZ,
			XYZ
		}

		public string quickActionName;

		public bool isMultiTouch;

		public bool is2Finger;

		public bool isOnTouch;

		public bool enablePickOverUI;

		public bool resetPhysic;

		public DirectAction directAction;

		public AffectedAxesAction axesAction;

		public float sensibility = 1f;

		public CharacterController directCharacterController;

		public bool inverseAxisValue;

		protected Rigidbody cachedRigidBody;

		protected bool isKinematic;

		protected Rigidbody2D cachedRigidBody2D;

		protected bool isKinematic2D;

		protected GameObjectType realType;

		protected int fingerIndex = -1;

		private void Awake()
		{
			cachedRigidBody = GetComponent<Rigidbody>();
			if ((bool)cachedRigidBody)
			{
				isKinematic = cachedRigidBody.isKinematic;
			}
			cachedRigidBody2D = GetComponent<Rigidbody2D>();
			if ((bool)cachedRigidBody2D)
			{
				isKinematic2D = cachedRigidBody2D.isKinematic;
			}
		}

		public virtual void Start()
		{
			EasyTouch.SetEnableAutoSelect(value: true);
			realType = GameObjectType.Obj_3D;
			if ((bool)GetComponent<Collider>())
			{
				realType = GameObjectType.Obj_3D;
			}
			else if ((bool)GetComponent<Collider2D>())
			{
				realType = GameObjectType.Obj_2D;
			}
			else if ((bool)GetComponent<CanvasRenderer>())
			{
				realType = GameObjectType.UI;
			}
			switch (realType)
			{
			case GameObjectType.Obj_3D:
				EasyTouch.Set3DPickableLayer((int)EasyTouch.Get3DPickableLayer() | (1 << base.gameObject.layer));
				break;
			case GameObjectType.Obj_2D:
				EasyTouch.SetEnable2DCollider(value: true);
				EasyTouch.Set2DPickableLayer((int)EasyTouch.Get2DPickableLayer() | (1 << base.gameObject.layer));
				break;
			case GameObjectType.UI:
				EasyTouch.instance.enableUIMode = true;
				EasyTouch.SetUICompatibily(value: false);
				break;
			}
			if (enablePickOverUI)
			{
				EasyTouch.instance.enableUIMode = true;
				EasyTouch.SetUICompatibily(value: false);
			}
		}

		public virtual void OnEnable()
		{
		}

		public virtual void OnDisable()
		{
		}

		protected Vector3 GetInfluencedAxis()
		{
			Vector3 result = Vector3.zero;
			switch (axesAction)
			{
			case AffectedAxesAction.X:
				result = new Vector3(1f, 0f, 0f);
				break;
			case AffectedAxesAction.Y:
				result = new Vector3(0f, 1f, 0f);
				break;
			case AffectedAxesAction.Z:
				result = new Vector3(0f, 0f, 1f);
				break;
			case AffectedAxesAction.XY:
				result = new Vector3(1f, 1f, 0f);
				break;
			case AffectedAxesAction.XYZ:
				result = new Vector3(1f, 1f, 1f);
				break;
			case AffectedAxesAction.XZ:
				result = new Vector3(1f, 0f, 1f);
				break;
			case AffectedAxesAction.YZ:
				result = new Vector3(0f, 1f, 1f);
				break;
			}
			return result;
		}

		protected void DoDirectAction(float value)
		{
			Vector3 influencedAxis = GetInfluencedAxis();
			switch (directAction)
			{
			case DirectAction.Rotate:
				base.transform.Rotate(influencedAxis * value, Space.World);
				break;
			case DirectAction.RotateLocal:
				base.transform.Rotate(influencedAxis * value, Space.Self);
				break;
			case DirectAction.Translate:
			{
				if (directCharacterController == null)
				{
					base.transform.Translate(influencedAxis * value, Space.World);
					break;
				}
				Vector3 motion2 = influencedAxis * value;
				directCharacterController.Move(motion2);
				break;
			}
			case DirectAction.TranslateLocal:
			{
				if (directCharacterController == null)
				{
					base.transform.Translate(influencedAxis * value, Space.Self);
					break;
				}
				Vector3 motion = directCharacterController.transform.TransformDirection(influencedAxis) * value;
				directCharacterController.Move(motion);
				break;
			}
			case DirectAction.Scale:
				base.transform.localScale += influencedAxis * value;
				break;
			}
		}

		public void EnabledQuickComponent(string quickActionName)
		{
			QuickBase[] components = GetComponents<QuickBase>();
			foreach (QuickBase quickBase in components)
			{
				if (quickBase.quickActionName == quickActionName)
				{
					quickBase.enabled = true;
				}
			}
		}

		public void DisabledQuickComponent(string quickActionName)
		{
			QuickBase[] components = GetComponents<QuickBase>();
			foreach (QuickBase quickBase in components)
			{
				if (quickBase.quickActionName == quickActionName)
				{
					quickBase.enabled = false;
				}
			}
		}

		public void DisabledAllSwipeExcepted(string quickActionName)
		{
			QuickSwipe[] array = UnityEngine.Object.FindObjectsOfType(typeof(QuickSwipe)) as QuickSwipe[];
			foreach (QuickSwipe quickSwipe in array)
			{
				if (quickSwipe.quickActionName != quickActionName || (quickSwipe.quickActionName == quickActionName && quickSwipe.gameObject != base.gameObject))
				{
					quickSwipe.enabled = false;
				}
			}
		}
	}
	[AddComponentMenu("EasyTouch/Quick Drag")]
	public class QuickDrag : QuickBase
	{
		[Serializable]
		public class OnDragStart : UnityEvent<Gesture>
		{
		}

		[Serializable]
		public class OnDrag : UnityEvent<Gesture>
		{
		}

		[Serializable]
		public class OnDragEnd : UnityEvent<Gesture>
		{
		}

		[SerializeField]
		public OnDragStart onDragStart;

		[SerializeField]
		public OnDrag onDrag;

		[SerializeField]
		public OnDragEnd onDragEnd;

		public bool isStopOncollisionEnter;

		private Vector3 deltaPosition;

		private bool isOnDrag;

		private Gesture lastGesture;

		public QuickDrag()
		{
			quickActionName = "QuickDrag" + GetInstanceID();
			axesAction = AffectedAxesAction.XY;
		}

		public override void OnEnable()
		{
			base.OnEnable();
			EasyTouch.On_TouchStart += On_TouchStart;
			EasyTouch.On_TouchDown += On_TouchDown;
			EasyTouch.On_TouchUp += On_TouchUp;
			EasyTouch.On_Drag += On_Drag;
			EasyTouch.On_DragStart += On_DragStart;
			EasyTouch.On_DragEnd += On_DragEnd;
		}

		public override void OnDisable()
		{
			base.OnDisable();
			UnsubscribeEvent();
		}

		private void OnDestroy()
		{
			UnsubscribeEvent();
		}

		private void UnsubscribeEvent()
		{
			EasyTouch.On_TouchStart -= On_TouchStart;
			EasyTouch.On_TouchDown -= On_TouchDown;
			EasyTouch.On_TouchUp -= On_TouchUp;
			EasyTouch.On_Drag -= On_Drag;
			EasyTouch.On_DragStart -= On_DragStart;
			EasyTouch.On_DragEnd -= On_DragEnd;
		}

		private void OnCollisionEnter()
		{
			if (isStopOncollisionEnter && isOnDrag)
			{
				StopDrag();
			}
		}

		private void On_TouchStart(Gesture gesture)
		{
			if (realType == GameObjectType.UI && gesture.isOverGui && (gesture.pickedUIElement == base.gameObject || gesture.pickedUIElement.transform.IsChildOf(base.transform)) && fingerIndex == -1)
			{
				fingerIndex = gesture.fingerIndex;
				base.transform.SetAsLastSibling();
				onDragStart.Invoke(gesture);
				isOnDrag = true;
			}
		}

		private void On_TouchDown(Gesture gesture)
		{
			if (isOnDrag && fingerIndex == gesture.fingerIndex && realType == GameObjectType.UI && gesture.isOverGui && (gesture.pickedUIElement == base.gameObject || gesture.pickedUIElement.transform.IsChildOf(base.transform)))
			{
				base.transform.position += (Vector3)gesture.deltaPosition;
				if (gesture.deltaPosition != Vector2.zero)
				{
					onDrag.Invoke(gesture);
				}
				lastGesture = gesture;
			}
		}

		private void On_TouchUp(Gesture gesture)
		{
			if (fingerIndex == gesture.fingerIndex && realType == GameObjectType.UI)
			{
				lastGesture = gesture;
				StopDrag();
			}
		}

		private void On_DragStart(Gesture gesture)
		{
			if (realType == GameObjectType.UI || ((enablePickOverUI || !(gesture.pickedUIElement == null)) && !enablePickOverUI) || !(gesture.pickedObject == base.gameObject) || isOnDrag)
			{
				return;
			}
			isOnDrag = true;
			fingerIndex = gesture.fingerIndex;
			Vector3 touchToWorldPoint = gesture.GetTouchToWorldPoint(gesture.pickedObject.transform.position);
			deltaPosition = touchToWorldPoint - base.transform.position;
			if (resetPhysic)
			{
				if ((bool)cachedRigidBody)
				{
					cachedRigidBody.isKinematic = true;
				}
				if ((bool)cachedRigidBody2D)
				{
					cachedRigidBody2D.isKinematic = true;
				}
			}
			onDragStart.Invoke(gesture);
		}

		private void On_Drag(Gesture gesture)
		{
			if (fingerIndex == gesture.fingerIndex && (realType == GameObjectType.Obj_2D || realType == GameObjectType.Obj_3D) && gesture.pickedObject == base.gameObject && fingerIndex == gesture.fingerIndex)
			{
				Vector3 position = gesture.GetTouchToWorldPoint(gesture.pickedObject.transform.position) - deltaPosition;
				base.transform.position = GetPositionAxes(position);
				if (gesture.deltaPosition != Vector2.zero)
				{
					onDrag.Invoke(gesture);
				}
				lastGesture = gesture;
			}
		}

		private void On_DragEnd(Gesture gesture)
		{
			if (fingerIndex == gesture.fingerIndex)
			{
				lastGesture = gesture;
				StopDrag();
			}
		}

		private Vector3 GetPositionAxes(Vector3 position)
		{
			Vector3 result = position;
			switch (axesAction)
			{
			case AffectedAxesAction.X:
				result = new Vector3(position.x, base.transform.position.y, base.transform.position.z);
				break;
			case AffectedAxesAction.Y:
				result = new Vector3(base.transform.position.x, position.y, base.transform.position.z);
				break;
			case AffectedAxesAction.Z:
				result = new Vector3(base.transform.position.x, base.transform.position.y, position.z);
				break;
			case AffectedAxesAction.XY:
				result = new Vector3(position.x, position.y, base.transform.position.z);
				break;
			case AffectedAxesAction.XZ:
				result = new Vector3(position.x, base.transform.position.y, position.z);
				break;
			case AffectedAxesAction.YZ:
				result = new Vector3(base.transform.position.x, position.y, position.z);
				break;
			}
			return result;
		}

		public void StopDrag()
		{
			fingerIndex = -1;
			if (resetPhysic)
			{
				if ((bool)cachedRigidBody)
				{
					cachedRigidBody.isKinematic = isKinematic;
				}
				if ((bool)cachedRigidBody2D)
				{
					cachedRigidBody2D.isKinematic = isKinematic2D;
				}
			}
			isOnDrag = false;
			onDragEnd.Invoke(lastGesture);
		}
	}
	[AddComponentMenu("EasyTouch/Quick Enter-Over-Exit")]
	public class QuickEnterOverExist : QuickBase
	{
		[Serializable]
		public class OnTouchEnter : UnityEvent<Gesture>
		{
		}

		[Serializable]
		public class OnTouchOver : UnityEvent<Gesture>
		{
		}

		[Serializable]
		public class OnTouchExit : UnityEvent<Gesture>
		{
		}

		[SerializeField]
		public OnTouchEnter onTouchEnter;

		[SerializeField]
		public OnTouchOver onTouchOver;

		[SerializeField]
		public OnTouchExit onTouchExit;

		private bool[] fingerOver = new bool[100];

		public QuickEnterOverExist()
		{
			quickActionName = "QuickEnterOverExit" + GetInstanceID();
		}

		private void Awake()
		{
			for (int i = 0; i < 100; i++)
			{
				fingerOver[i] = false;
			}
		}

		public override void OnEnable()
		{
			base.OnEnable();
			EasyTouch.On_TouchDown += On_TouchDown;
			EasyTouch.On_TouchUp += On_TouchUp;
		}

		public override void OnDisable()
		{
			base.OnDisable();
			UnsubscribeEvent();
		}

		private void OnDestroy()
		{
			UnsubscribeEvent();
		}

		private void UnsubscribeEvent()
		{
			EasyTouch.On_TouchDown -= On_TouchDown;
			EasyTouch.On_TouchUp -= On_TouchUp;
		}

		private void On_TouchDown(Gesture gesture)
		{
			if (realType != GameObjectType.UI)
			{
				if ((!enablePickOverUI && gesture.GetCurrentFirstPickedUIElement() == null) || enablePickOverUI)
				{
					if (gesture.GetCurrentPickedObject() == base.gameObject)
					{
						if (!fingerOver[gesture.fingerIndex] && ((!isOnTouch && !isMultiTouch) || isMultiTouch))
						{
							fingerOver[gesture.fingerIndex] = true;
							onTouchEnter.Invoke(gesture);
							isOnTouch = true;
						}
						else if (fingerOver[gesture.fingerIndex])
						{
							onTouchOver.Invoke(gesture);
						}
					}
					else if (fingerOver[gesture.fingerIndex])
					{
						fingerOver[gesture.fingerIndex] = false;
						onTouchExit.Invoke(gesture);
						if (!isMultiTouch)
						{
							isOnTouch = false;
						}
					}
				}
				else if (gesture.GetCurrentPickedObject() == base.gameObject && !enablePickOverUI && gesture.GetCurrentFirstPickedUIElement() != null && fingerOver[gesture.fingerIndex])
				{
					fingerOver[gesture.fingerIndex] = false;
					onTouchExit.Invoke(gesture);
					if (!isMultiTouch)
					{
						isOnTouch = false;
					}
				}
			}
			else if (gesture.GetCurrentFirstPickedUIElement() == base.gameObject)
			{
				if (!fingerOver[gesture.fingerIndex] && ((!isOnTouch && !isMultiTouch) || isMultiTouch))
				{
					fingerOver[gesture.fingerIndex] = true;
					onTouchEnter.Invoke(gesture);
					isOnTouch = true;
				}
				else if (fingerOver[gesture.fingerIndex])
				{
					onTouchOver.Invoke(gesture);
				}
			}
			else if (fingerOver[gesture.fingerIndex])
			{
				fingerOver[gesture.fingerIndex] = false;
				onTouchExit.Invoke(gesture);
				if (!isMultiTouch)
				{
					isOnTouch = false;
				}
			}
		}

		private void On_TouchUp(Gesture gesture)
		{
			if (fingerOver[gesture.fingerIndex])
			{
				fingerOver[gesture.fingerIndex] = false;
				onTouchExit.Invoke(gesture);
				if (!isMultiTouch)
				{
					isOnTouch = false;
				}
			}
		}
	}
	[AddComponentMenu("EasyTouch/Quick LongTap")]
	public class QuickLongTap : QuickBase
	{
		[Serializable]
		public class OnLongTap : UnityEvent<Gesture>
		{
		}

		public enum ActionTriggering
		{
			Start,
			InProgress,
			End
		}

		[SerializeField]
		public OnLongTap onLongTap;

		public ActionTriggering actionTriggering;

		private Gesture currentGesture;

		public QuickLongTap()
		{
			quickActionName = "QuickLongTap" + GetInstanceID();
		}

		private void Update()
		{
			currentGesture = EasyTouch.current;
			if (!is2Finger)
			{
				if (currentGesture.type == EasyTouch.EvtType.On_TouchStart && fingerIndex == -1 && IsOverMe(currentGesture))
				{
					fingerIndex = currentGesture.fingerIndex;
				}
				if (currentGesture.type == EasyTouch.EvtType.On_LongTapStart && actionTriggering == ActionTriggering.Start && (currentGesture.fingerIndex == fingerIndex || isMultiTouch))
				{
					DoAction(currentGesture);
				}
				if (currentGesture.type == EasyTouch.EvtType.On_LongTap && actionTriggering == ActionTriggering.InProgress && (currentGesture.fingerIndex == fingerIndex || isMultiTouch))
				{
					DoAction(currentGesture);
				}
				if (currentGesture.type == EasyTouch.EvtType.On_LongTapEnd && actionTriggering == ActionTriggering.End && (currentGesture.fingerIndex == fingerIndex || isMultiTouch))
				{
					DoAction(currentGesture);
					fingerIndex = -1;
				}
			}
			else
			{
				if (currentGesture.type == EasyTouch.EvtType.On_LongTapStart2Fingers && actionTriggering == ActionTriggering.Start)
				{
					DoAction(currentGesture);
				}
				if (currentGesture.type == EasyTouch.EvtType.On_LongTap2Fingers && actionTriggering == ActionTriggering.InProgress)
				{
					DoAction(currentGesture);
				}
				if (currentGesture.type == EasyTouch.EvtType.On_LongTapEnd2Fingers && actionTriggering == ActionTriggering.End)
				{
					DoAction(currentGesture);
				}
			}
		}

		private void DoAction(Gesture gesture)
		{
			if (IsOverMe(gesture))
			{
				onLongTap.Invoke(gesture);
			}
		}

		private bool IsOverMe(Gesture gesture)
		{
			bool result = false;
			if (realType == GameObjectType.UI)
			{
				if (gesture.isOverGui && (gesture.pickedUIElement == base.gameObject || gesture.pickedUIElement.transform.IsChildOf(base.transform)))
				{
					result = true;
				}
			}
			else if (((!enablePickOverUI && gesture.pickedUIElement == null) || enablePickOverUI) && EasyTouch.GetGameObjectAt(gesture.position, is2Finger) == base.gameObject)
			{
				result = true;
			}
			return result;
		}
	}
	[AddComponentMenu("EasyTouch/Quick Pinch")]
	public class QuickPinch : QuickBase
	{
		[Serializable]
		public class OnPinchAction : UnityEvent<Gesture>
		{
		}

		public enum ActionTiggering
		{
			InProgress,
			End
		}

		public enum ActionPinchDirection
		{
			All,
			PinchIn,
			PinchOut
		}

		[SerializeField]
		public OnPinchAction onPinchAction;

		public bool isGestureOnMe;

		public ActionTiggering actionTriggering;

		public ActionPinchDirection pinchDirection;

		private float axisActionValue;

		public bool enableSimpleAction;

		public QuickPinch()
		{
			quickActionName = "QuickPinch" + GetInstanceID();
		}

		public override void OnEnable()
		{
			EasyTouch.On_Pinch += On_Pinch;
			EasyTouch.On_PinchIn += On_PinchIn;
			EasyTouch.On_PinchOut += On_PinchOut;
			EasyTouch.On_PinchEnd += On_PichEnd;
		}

		public override void OnDisable()
		{
			UnsubscribeEvent();
		}

		private void OnDestroy()
		{
			UnsubscribeEvent();
		}

		private void UnsubscribeEvent()
		{
			EasyTouch.On_Pinch -= On_Pinch;
			EasyTouch.On_PinchIn -= On_PinchIn;
			EasyTouch.On_PinchOut -= On_PinchOut;
			EasyTouch.On_PinchEnd -= On_PichEnd;
		}

		private void On_Pinch(Gesture gesture)
		{
			if (actionTriggering == ActionTiggering.InProgress && pinchDirection == ActionPinchDirection.All)
			{
				DoAction(gesture);
			}
		}

		private void On_PinchIn(Gesture gesture)
		{
			if ((actionTriggering == ActionTiggering.InProgress) & (pinchDirection == ActionPinchDirection.PinchIn))
			{
				DoAction(gesture);
			}
		}

		private void On_PinchOut(Gesture gesture)
		{
			if ((actionTriggering == ActionTiggering.InProgress) & (pinchDirection == ActionPinchDirection.PinchOut))
			{
				DoAction(gesture);
			}
		}

		private void On_PichEnd(Gesture gesture)
		{
			if (actionTriggering == ActionTiggering.End)
			{
				DoAction(gesture);
			}
		}

		private void DoAction(Gesture gesture)
		{
			axisActionValue = gesture.deltaPinch * sensibility * Time.deltaTime;
			if (isGestureOnMe)
			{
				if (realType == GameObjectType.UI)
				{
					if (gesture.isOverGui && (gesture.pickedUIElement == base.gameObject || gesture.pickedUIElement.transform.IsChildOf(base.transform)))
					{
						onPinchAction.Invoke(gesture);
						if (enableSimpleAction)
						{
							DoDirectAction(axisActionValue);
						}
					}
				}
				else if (((!enablePickOverUI && gesture.pickedUIElement == null) || enablePickOverUI) && gesture.GetCurrentPickedObject(isTwoFinger: true) == base.gameObject)
				{
					onPinchAction.Invoke(gesture);
					if (enableSimpleAction)
					{
						DoDirectAction(axisActionValue);
					}
				}
			}
			else if ((!enablePickOverUI && gesture.pickedUIElement == null) || enablePickOverUI)
			{
				onPinchAction.Invoke(gesture);
				if (enableSimpleAction)
				{
					DoDirectAction(axisActionValue);
				}
			}
		}
	}
	[AddComponentMenu("EasyTouch/Quick Swipe")]
	public class QuickSwipe : QuickBase
	{
		[Serializable]
		public class OnSwipeAction : UnityEvent<Gesture>
		{
		}

		public enum ActionTriggering
		{
			InProgress,
			End
		}

		public enum SwipeDirection
		{
			Vertical,
			Horizontal,
			DiagonalRight,
			DiagonalLeft,
			Up,
			UpRight,
			Right,
			DownRight,
			Down,
			DownLeft,
			Left,
			UpLeft,
			All
		}

		[SerializeField]
		public OnSwipeAction onSwipeAction;

		public bool allowSwipeStartOverMe = true;

		public ActionTriggering actionTriggering;

		public SwipeDirection swipeDirection = SwipeDirection.All;

		private float axisActionValue;

		public bool enableSimpleAction;

		public QuickSwipe()
		{
			quickActionName = "QuickSwipe" + GetInstanceID();
		}

		public override void OnEnable()
		{
			base.OnEnable();
			EasyTouch.On_Drag += On_Drag;
			EasyTouch.On_Swipe += On_Swipe;
			EasyTouch.On_DragEnd += On_DragEnd;
			EasyTouch.On_SwipeEnd += On_SwipeEnd;
		}

		public override void OnDisable()
		{
			base.OnDisable();
			UnsubscribeEvent();
		}

		private void OnDestroy()
		{
			UnsubscribeEvent();
		}

		private void UnsubscribeEvent()
		{
			EasyTouch.On_Swipe -= On_Swipe;
			EasyTouch.On_SwipeEnd -= On_SwipeEnd;
		}

		private void On_Swipe(Gesture gesture)
		{
			if (gesture.touchCount != 1 || ((!(gesture.pickedObject != base.gameObject) || allowSwipeStartOverMe) && !allowSwipeStartOverMe))
			{
				return;
			}
			fingerIndex = gesture.fingerIndex;
			if (actionTriggering == ActionTriggering.InProgress && isRightDirection(gesture))
			{
				onSwipeAction.Invoke(gesture);
				if (enableSimpleAction)
				{
					DoAction(gesture);
				}
			}
		}

		private void On_SwipeEnd(Gesture gesture)
		{
			if (actionTriggering == ActionTriggering.End && isRightDirection(gesture))
			{
				onSwipeAction.Invoke(gesture);
				if (enableSimpleAction)
				{
					DoAction(gesture);
				}
			}
			if (fingerIndex == gesture.fingerIndex)
			{
				fingerIndex = -1;
			}
		}

		private void On_DragEnd(Gesture gesture)
		{
			if (gesture.pickedObject == base.gameObject && allowSwipeStartOverMe)
			{
				On_SwipeEnd(gesture);
			}
		}

		private void On_Drag(Gesture gesture)
		{
			if (gesture.pickedObject == base.gameObject && allowSwipeStartOverMe)
			{
				On_Swipe(gesture);
			}
		}

		private bool isRightDirection(Gesture gesture)
		{
			float num = -1f;
			if (inverseAxisValue)
			{
				num = 1f;
			}
			axisActionValue = 0f;
			switch (swipeDirection)
			{
			case SwipeDirection.All:
				axisActionValue = gesture.deltaPosition.magnitude * num;
				return true;
			case SwipeDirection.Horizontal:
				if (gesture.swipe == EasyTouch.SwipeDirection.Left || gesture.swipe == EasyTouch.SwipeDirection.Right)
				{
					axisActionValue = gesture.deltaPosition.x * num;
					return true;
				}
				break;
			case SwipeDirection.Vertical:
				if (gesture.swipe == EasyTouch.SwipeDirection.Up || gesture.swipe == EasyTouch.SwipeDirection.Down)
				{
					axisActionValue = gesture.deltaPosition.y * num;
					return true;
				}
				break;
			case SwipeDirection.DiagonalLeft:
				if (gesture.swipe == EasyTouch.SwipeDirection.UpLeft || gesture.swipe == EasyTouch.SwipeDirection.DownRight)
				{
					axisActionValue = gesture.deltaPosition.magnitude * num;
					return true;
				}
				break;
			case SwipeDirection.DiagonalRight:
				if (gesture.swipe == EasyTouch.SwipeDirection.UpRight || gesture.swipe == EasyTouch.SwipeDirection.DownLeft)
				{
					axisActionValue = gesture.deltaPosition.magnitude * num;
					return true;
				}
				break;
			case SwipeDirection.Left:
				if (gesture.swipe == EasyTouch.SwipeDirection.Left)
				{
					axisActionValue = gesture.deltaPosition.x * num;
					return true;
				}
				break;
			case SwipeDirection.Right:
				if (gesture.swipe == EasyTouch.SwipeDirection.Right)
				{
					axisActionValue = gesture.deltaPosition.x * num;
					return true;
				}
				break;
			case SwipeDirection.DownLeft:
				if (gesture.swipe == EasyTouch.SwipeDirection.DownLeft)
				{
					axisActionValue = gesture.deltaPosition.magnitude * num;
					return true;
				}
				break;
			case SwipeDirection.DownRight:
				if (gesture.swipe == EasyTouch.SwipeDirection.DownRight)
				{
					axisActionValue = gesture.deltaPosition.magnitude * num;
					return true;
				}
				break;
			case SwipeDirection.UpLeft:
				if (gesture.swipe == EasyTouch.SwipeDirection.UpLeft)
				{
					axisActionValue = gesture.deltaPosition.magnitude * num;
					return true;
				}
				break;
			case SwipeDirection.UpRight:
				if (gesture.swipe == EasyTouch.SwipeDirection.UpRight)
				{
					axisActionValue = gesture.deltaPosition.magnitude * num;
					return true;
				}
				break;
			case SwipeDirection.Up:
				if (gesture.swipe == EasyTouch.SwipeDirection.Up)
				{
					axisActionValue = gesture.deltaPosition.y * num;
					return true;
				}
				break;
			case SwipeDirection.Down:
				if (gesture.swipe == EasyTouch.SwipeDirection.Down)
				{
					axisActionValue = gesture.deltaPosition.y * num;
					return true;
				}
				break;
			}
			axisActionValue = 0f;
			return false;
		}

		private void DoAction(Gesture gesture)
		{
			switch (directAction)
			{
			case DirectAction.Rotate:
			case DirectAction.RotateLocal:
				axisActionValue *= sensibility;
				break;
			case DirectAction.Translate:
			case DirectAction.TranslateLocal:
			case DirectAction.Scale:
				axisActionValue /= UnityEngine.Screen.dpi;
				axisActionValue *= sensibility;
				break;
			}
			DoDirectAction(axisActionValue);
		}
	}
	[AddComponentMenu("EasyTouch/Quick Tap")]
	public class QuickTap : QuickBase
	{
		[Serializable]
		public class OnTap : UnityEvent<Gesture>
		{
		}

		public enum ActionTriggering
		{
			Simple_Tap,
			Double_Tap
		}

		[SerializeField]
		public OnTap onTap;

		public ActionTriggering actionTriggering;

		private Gesture currentGesture;

		public QuickTap()
		{
			quickActionName = "QuickTap" + GetInstanceID();
		}

		private void Update()
		{
			currentGesture = EasyTouch.current;
			if (!is2Finger)
			{
				if (currentGesture.type == EasyTouch.EvtType.On_DoubleTap && actionTriggering == ActionTriggering.Double_Tap)
				{
					DoAction(currentGesture);
				}
				if (currentGesture.type == EasyTouch.EvtType.On_SimpleTap && actionTriggering == ActionTriggering.Simple_Tap)
				{
					DoAction(currentGesture);
				}
			}
			else
			{
				if (currentGesture.type == EasyTouch.EvtType.On_DoubleTap2Fingers && actionTriggering == ActionTriggering.Double_Tap)
				{
					DoAction(currentGesture);
				}
				if (currentGesture.type == EasyTouch.EvtType.On_SimpleTap2Fingers && actionTriggering == ActionTriggering.Simple_Tap)
				{
					DoAction(currentGesture);
				}
			}
		}

		private void DoAction(Gesture gesture)
		{
			if (realType == GameObjectType.UI)
			{
				if (gesture.isOverGui && (gesture.pickedUIElement == base.gameObject || gesture.pickedUIElement.transform.IsChildOf(base.transform)))
				{
					onTap.Invoke(gesture);
				}
			}
			else if (((!enablePickOverUI && gesture.pickedUIElement == null) || enablePickOverUI) && EasyTouch.GetGameObjectAt(gesture.position, is2Finger) == base.gameObject)
			{
				onTap.Invoke(gesture);
			}
		}
	}
	[AddComponentMenu("EasyTouch/Quick Touch")]
	public class QuickTouch : QuickBase
	{
		[Serializable]
		public class OnTouch : UnityEvent<Gesture>
		{
		}

		[Serializable]
		public class OnTouchNotOverMe : UnityEvent<Gesture>
		{
		}

		public enum ActionTriggering
		{
			Start,
			Down,
			Up
		}

		[SerializeField]
		public OnTouch onTouch;

		public OnTouchNotOverMe onTouchNotOverMe;

		public ActionTriggering actionTriggering;

		private Gesture currentGesture;

		public QuickTouch()
		{
			quickActionName = "QuickTouch" + GetInstanceID();
		}

		private void Update()
		{
			currentGesture = EasyTouch.current;
			if (!is2Finger)
			{
				if (currentGesture.type == EasyTouch.EvtType.On_TouchStart && fingerIndex == -1 && IsOverMe(currentGesture))
				{
					fingerIndex = currentGesture.fingerIndex;
				}
				if (currentGesture.type == EasyTouch.EvtType.On_TouchStart && actionTriggering == ActionTriggering.Start && (currentGesture.fingerIndex == fingerIndex || isMultiTouch))
				{
					DoAction(currentGesture);
				}
				if (currentGesture.type == EasyTouch.EvtType.On_TouchDown && actionTriggering == ActionTriggering.Down && (currentGesture.fingerIndex == fingerIndex || isMultiTouch))
				{
					DoAction(currentGesture);
				}
				if (currentGesture.type != EasyTouch.EvtType.On_TouchUp)
				{
					return;
				}
				if (actionTriggering == ActionTriggering.Up && (currentGesture.fingerIndex == fingerIndex || isMultiTouch))
				{
					if (IsOverMe(currentGesture))
					{
						onTouch.Invoke(currentGesture);
					}
					else
					{
						onTouchNotOverMe.Invoke(currentGesture);
					}
				}
				if (currentGesture.fingerIndex == fingerIndex)
				{
					fingerIndex = -1;
				}
			}
			else
			{
				if (currentGesture.type == EasyTouch.EvtType.On_TouchStart2Fingers && actionTriggering == ActionTriggering.Start)
				{
					DoAction(currentGesture);
				}
				if (currentGesture.type == EasyTouch.EvtType.On_TouchDown2Fingers && actionTriggering == ActionTriggering.Down)
				{
					DoAction(currentGesture);
				}
				if (currentGesture.type == EasyTouch.EvtType.On_TouchUp2Fingers && actionTriggering == ActionTriggering.Up)
				{
					DoAction(currentGesture);
				}
			}
		}

		private void DoAction(Gesture gesture)
		{
			if (IsOverMe(gesture))
			{
				onTouch.Invoke(gesture);
			}
		}

		private bool IsOverMe(Gesture gesture)
		{
			bool result = false;
			if (realType == GameObjectType.UI)
			{
				if (gesture.isOverGui && (gesture.pickedUIElement == base.gameObject || gesture.pickedUIElement.transform.IsChildOf(base.transform)))
				{
					result = true;
				}
			}
			else if (((!enablePickOverUI && gesture.pickedUIElement == null) || enablePickOverUI) && EasyTouch.GetGameObjectAt(gesture.position, is2Finger) == base.gameObject)
			{
				result = true;
			}
			return result;
		}
	}
	[AddComponentMenu("EasyTouch/Quick Twist")]
	public class QuickTwist : QuickBase
	{
		[Serializable]
		public class OnTwistAction : UnityEvent<Gesture>
		{
		}

		public enum ActionTiggering
		{
			InProgress,
			End
		}

		public enum ActionRotationDirection
		{
			All,
			Clockwise,
			Counterclockwise
		}

		[SerializeField]
		public OnTwistAction onTwistAction;

		public bool isGestureOnMe;

		public ActionTiggering actionTriggering;

		public ActionRotationDirection rotationDirection;

		private float axisActionValue;

		public bool enableSimpleAction;

		public QuickTwist()
		{
			quickActionName = "QuickTwist" + GetInstanceID();
		}

		public override void OnEnable()
		{
			EasyTouch.On_Twist += On_Twist;
			EasyTouch.On_TwistEnd += On_TwistEnd;
		}

		public override void OnDisable()
		{
			UnsubscribeEvent();
		}

		private void OnDestroy()
		{
			UnsubscribeEvent();
		}

		private void UnsubscribeEvent()
		{
			EasyTouch.On_Twist -= On_Twist;
			EasyTouch.On_TwistEnd -= On_TwistEnd;
		}

		private void On_Twist(Gesture gesture)
		{
			if (actionTriggering == ActionTiggering.InProgress && IsRightRotation(gesture))
			{
				DoAction(gesture);
			}
		}

		private void On_TwistEnd(Gesture gesture)
		{
			if (actionTriggering == ActionTiggering.End && IsRightRotation(gesture))
			{
				DoAction(gesture);
			}
		}

		private bool IsRightRotation(Gesture gesture)
		{
			axisActionValue = 0f;
			float num = 1f;
			if (inverseAxisValue)
			{
				num = -1f;
			}
			switch (rotationDirection)
			{
			case ActionRotationDirection.All:
				axisActionValue = gesture.twistAngle * sensibility * num;
				return true;
			case ActionRotationDirection.Clockwise:
				if (gesture.twistAngle < 0f)
				{
					axisActionValue = gesture.twistAngle * sensibility * num;
					return true;
				}
				break;
			case ActionRotationDirection.Counterclockwise:
				if (gesture.twistAngle > 0f)
				{
					axisActionValue = gesture.twistAngle * sensibility * num;
					return true;
				}
				break;
			}
			return false;
		}

		private void DoAction(Gesture gesture)
		{
			if (isGestureOnMe)
			{
				if (realType == GameObjectType.UI)
				{
					if (gesture.isOverGui && (gesture.pickedUIElement == base.gameObject || gesture.pickedUIElement.transform.IsChildOf(base.transform)))
					{
						onTwistAction.Invoke(gesture);
						if (enableSimpleAction)
						{
							DoDirectAction(axisActionValue);
						}
					}
				}
				else if (((!enablePickOverUI && gesture.pickedUIElement == null) || enablePickOverUI) && gesture.GetCurrentPickedObject(isTwoFinger: true) == base.gameObject)
				{
					onTwistAction.Invoke(gesture);
					if (enableSimpleAction)
					{
						DoDirectAction(axisActionValue);
					}
				}
			}
			else if ((!enablePickOverUI && gesture.pickedUIElement == null) || enablePickOverUI)
			{
				onTwistAction.Invoke(gesture);
				if (enableSimpleAction)
				{
					DoDirectAction(axisActionValue);
				}
			}
		}
	}
	public class BaseFinger
	{
		public int fingerIndex;

		public int touchCount;

		public Vector2 startPosition;

		public Vector2 position;

		public Vector2 deltaPosition;

		public float actionTime;

		public float deltaTime;

		public Camera pickedCamera;

		public GameObject pickedObject;

		public bool isGuiCamera;

		public bool isOverGui;

		public GameObject pickedUIElement;

		public Gesture GetGesture()
		{
			return new Gesture
			{
				fingerIndex = fingerIndex,
				touchCount = touchCount,
				startPosition = startPosition,
				position = position,
				deltaPosition = deltaPosition,
				actionTime = actionTime,
				deltaTime = deltaTime,
				isOverGui = isOverGui,
				pickedCamera = pickedCamera,
				pickedObject = pickedObject,
				isGuiCamera = isGuiCamera,
				pickedUIElement = pickedUIElement
			};
		}
	}
	public class EasyTouch : MonoBehaviour
	{
		[Serializable]
		private class DoubleTap
		{
			public bool inDoubleTap;

			public bool inWait;

			public float time;

			public int count;

			public Finger finger;

			public void Stop()
			{
				inDoubleTap = false;
				inWait = false;
				time = 0f;
				count = 0;
			}
		}

		private class PickedObject
		{
			public GameObject pickedObj;

			public Camera pickedCamera;

			public bool isGUI;
		}

		public delegate void TouchCancelHandler(Gesture gesture);

		public delegate void Cancel2FingersHandler(Gesture gesture);

		public delegate void TouchStartHandler(Gesture gesture);

		public delegate void TouchDownHandler(Gesture gesture);

		public delegate void TouchUpHandler(Gesture gesture);

		public delegate void SimpleTapHandler(Gesture gesture);

		public delegate void DoubleTapHandler(Gesture gesture);

		public delegate void LongTapStartHandler(Gesture gesture);

		public delegate void LongTapHandler(Gesture gesture);

		public delegate void LongTapEndHandler(Gesture gesture);

		public delegate void DragStartHandler(Gesture gesture);

		public delegate void DragHandler(Gesture gesture);

		public delegate void DragEndHandler(Gesture gesture);

		public delegate void SwipeStartHandler(Gesture gesture);

		public delegate void SwipeHandler(Gesture gesture);

		public delegate void SwipeEndHandler(Gesture gesture);

		public delegate void TouchStart2FingersHandler(Gesture gesture);

		public delegate void TouchDown2FingersHandler(Gesture gesture);

		public delegate void TouchUp2FingersHandler(Gesture gesture);

		public delegate void SimpleTap2FingersHandler(Gesture gesture);

		public delegate void DoubleTap2FingersHandler(Gesture gesture);

		public delegate void LongTapStart2FingersHandler(Gesture gesture);

		public delegate void LongTap2FingersHandler(Gesture gesture);

		public delegate void LongTapEnd2FingersHandler(Gesture gesture);

		public delegate void TwistHandler(Gesture gesture);

		public delegate void TwistEndHandler(Gesture gesture);

		public delegate void PinchInHandler(Gesture gesture);

		public delegate void PinchOutHandler(Gesture gesture);

		public delegate void PinchEndHandler(Gesture gesture);

		public delegate void PinchHandler(Gesture gesture);

		public delegate void DragStart2FingersHandler(Gesture gesture);

		public delegate void Drag2FingersHandler(Gesture gesture);

		public delegate void DragEnd2FingersHandler(Gesture gesture);

		public delegate void SwipeStart2FingersHandler(Gesture gesture);

		public delegate void Swipe2FingersHandler(Gesture gesture);

		public delegate void SwipeEnd2FingersHandler(Gesture gesture);

		public delegate void EasyTouchIsReadyHandler();

		public delegate void OverUIElementHandler(Gesture gesture);

		public delegate void UIElementTouchUpHandler(Gesture gesture);

		public enum GesturePriority
		{
			Tap,
			Slips
		}

		public enum DoubleTapDetection
		{
			BySystem,
			ByTime
		}

		public enum GestureType
		{
			Tap,
			Drag,
			Swipe,
			None,
			LongTap,
			Pinch,
			Twist,
			Cancel,
			Acquisition
		}

		public enum SwipeDirection
		{
			None,
			Left,
			Right,
			Up,
			Down,
			UpLeft,
			UpRight,
			DownLeft,
			DownRight,
			Other,
			All
		}

		public enum TwoFingerPickMethod
		{
			Finger,
			Average
		}

		public enum EvtType
		{
			None,
			On_TouchStart,
			On_TouchDown,
			On_TouchUp,
			On_SimpleTap,
			On_DoubleTap,
			On_LongTapStart,
			On_LongTap,
			On_LongTapEnd,
			On_DragStart,
			On_Drag,
			On_DragEnd,
			On_SwipeStart,
			On_Swipe,
			On_SwipeEnd,
			On_TouchStart2Fingers,
			On_TouchDown2Fingers,
			On_TouchUp2Fingers,
			On_SimpleTap2Fingers,
			On_DoubleTap2Fingers,
			On_LongTapStart2Fingers,
			On_LongTap2Fingers,
			On_LongTapEnd2Fingers,
			On_Twist,
			On_TwistEnd,
			On_Pinch,
			On_PinchIn,
			On_PinchOut,
			On_PinchEnd,
			On_DragStart2Fingers,
			On_Drag2Fingers,
			On_DragEnd2Fingers,
			On_SwipeStart2Fingers,
			On_Swipe2Fingers,
			On_SwipeEnd2Fingers,
			On_EasyTouchIsReady,
			On_Cancel,
			On_Cancel2Fingers,
			On_OverUIElement,
			On_UIElementTouchUp
		}

		private static EasyTouch _instance;

		private Gesture _currentGesture = new Gesture();

		private List<Gesture> _currentGestures = new List<Gesture>();

		public bool enable;

		public bool enableRemote;

		public GesturePriority gesturePriority;

		public float StationaryTolerance;

		public float longTapTime;

		public float swipeTolerance;

		public float minPinchLength;

		public float minTwistAngle;

		public DoubleTapDetection doubleTapDetection;

		public float doubleTapTime;

		public bool alwaysSendSwipe;

		public bool enable2FingersGesture;

		public bool enableTwist;

		public bool enablePinch;

		public bool enable2FingersSwipe;

		public TwoFingerPickMethod twoFingerPickMethod;

		public List<ECamera> touchCameras;

		public bool autoSelect;

		public LayerMask pickableLayers3D;

		public bool enable2D;

		public LayerMask pickableLayers2D;

		public bool autoUpdatePickedObject;

		public bool allowUIDetection;

		public bool enableUIMode;

		public bool autoUpdatePickedUI;

		public bool enabledNGuiMode;

		public LayerMask nGUILayers;

		public List<Camera> nGUICameras;

		public bool enableSimulation;

		public KeyCode twistKey;

		public KeyCode swipeKey;

		public bool showGuiInspector;

		public bool showSelectInspector;

		public bool showGestureInspector;

		public bool showTwoFingerInspector;

		public bool showSecondFingerInspector;

		private EasyTouchInput input = new EasyTouchInput();

		private Finger[] fingers = new Finger[100];

		public Texture secondFingerTexture;

		private TwoFingerGesture twoFinger = new TwoFingerGesture();

		private int oldTouchCount;

		private DoubleTap[] singleDoubleTap = new DoubleTap[100];

		private Finger[] tmpArray = new Finger[100];

		private PickedObject pickedObject = new PickedObject();

		private List<RaycastResult> uiRaycastResultCache = new List<RaycastResult>();

		private PointerEventData uiPointerEventData;

		private EventSystem uiEventSystem;

		public static EasyTouch instance
		{
			get
			{
				if (!_instance)
				{
					_instance = UnityEngine.Object.FindObjectOfType(typeof(EasyTouch)) as EasyTouch;
					if (!_instance)
					{
						_instance = new GameObject("Easytouch").AddComponent<EasyTouch>();
					}
				}
				return _instance;
			}
		}

		public static Gesture current => instance._currentGesture;

		public static event TouchCancelHandler On_Cancel;

		public static event Cancel2FingersHandler On_Cancel2Fingers;

		public static event TouchStartHandler On_TouchStart;

		public static event TouchDownHandler On_TouchDown;

		public static event TouchUpHandler On_TouchUp;

		public static event SimpleTapHandler On_SimpleTap;

		public static event DoubleTapHandler On_DoubleTap;

		public static event LongTapStartHandler On_LongTapStart;

		public static event LongTapHandler On_LongTap;

		public static event LongTapEndHandler On_LongTapEnd;

		public static event DragStartHandler On_DragStart;

		public static event DragHandler On_Drag;

		public static event DragEndHandler On_DragEnd;

		public static event SwipeStartHandler On_SwipeStart;

		public static event SwipeHandler On_Swipe;

		public static event SwipeEndHandler On_SwipeEnd;

		public static event TouchStart2FingersHandler On_TouchStart2Fingers;

		public static event TouchDown2FingersHandler On_TouchDown2Fingers;

		public static event TouchUp2FingersHandler On_TouchUp2Fingers;

		public static event SimpleTap2FingersHandler On_SimpleTap2Fingers;

		public static event DoubleTap2FingersHandler On_DoubleTap2Fingers;

		public static event LongTapStart2FingersHandler On_LongTapStart2Fingers;

		public static event LongTap2FingersHandler On_LongTap2Fingers;

		public static event LongTapEnd2FingersHandler On_LongTapEnd2Fingers;

		public static event TwistHandler On_Twist;

		public static event TwistEndHandler On_TwistEnd;

		public static event PinchHandler On_Pinch;

		public static event PinchInHandler On_PinchIn;

		public static event PinchOutHandler On_PinchOut;

		public static event PinchEndHandler On_PinchEnd;

		public static event DragStart2FingersHandler On_DragStart2Fingers;

		public static event Drag2FingersHandler On_Drag2Fingers;

		public static event DragEnd2FingersHandler On_DragEnd2Fingers;

		public static event SwipeStart2FingersHandler On_SwipeStart2Fingers;

		public static event Swipe2FingersHandler On_Swipe2Fingers;

		public static event SwipeEnd2FingersHandler On_SwipeEnd2Fingers;

		public static event EasyTouchIsReadyHandler On_EasyTouchIsReady;

		public static event OverUIElementHandler On_OverUIElement;

		public static event UIElementTouchUpHandler On_UIElementTouchUp;

		public EasyTouch()
		{
			enable = true;
			allowUIDetection = true;
			enableUIMode = true;
			autoUpdatePickedUI = false;
			enabledNGuiMode = false;
			nGUICameras = new List<Camera>();
			autoSelect = true;
			touchCameras = new List<ECamera>();
			pickableLayers3D = 1;
			enable2D = false;
			pickableLayers2D = 1;
			gesturePriority = GesturePriority.Tap;
			StationaryTolerance = 15f;
			longTapTime = 1f;
			doubleTapDetection = DoubleTapDetection.BySystem;
			doubleTapTime = 0.3f;
			swipeTolerance = 0.85f;
			alwaysSendSwipe = false;
			enable2FingersGesture = true;
			twoFingerPickMethod = TwoFingerPickMethod.Finger;
			enable2FingersSwipe = true;
			enablePinch = true;
			minPinchLength = 0f;
			enableTwist = true;
			minTwistAngle = 0f;
			enableSimulation = true;
			twistKey = KeyCode.LeftAlt;
			swipeKey = KeyCode.LeftControl;
		}

		private void OnEnable()
		{
			if (UnityEngine.Application.isPlaying && UnityEngine.Application.isEditor)
			{
				Init();
			}
		}

		private void Awake()
		{
			Init();
		}

		private void Start()
		{
			for (int i = 0; i < 100; i++)
			{
				singleDoubleTap[i] = new DoubleTap();
			}
			if (touchCameras.FindIndex((ECamera c) => c.camera == Camera.main) < 0)
			{
				touchCameras.Add(new ECamera(Camera.main, gui: false));
			}
			if (EasyTouch.On_EasyTouchIsReady != null)
			{
				EasyTouch.On_EasyTouchIsReady();
			}
			_currentGestures.Add(new Gesture());
		}

		private void Init()
		{
		}

		private void OnDrawGizmos()
		{
		}

		private void Update()
		{
			if (!enable || !(instance == this))
			{
				return;
			}
			if (UnityEngine.Application.isPlaying && Input.touchCount > 0)
			{
				enableRemote = true;
			}
			if (UnityEngine.Application.isPlaying && Input.touchCount == 0)
			{
				enableRemote = false;
			}
			int num = input.TouchCount();
			if (oldTouchCount == 2 && num != 2 && num > 0)
			{
				CreateGesture2Finger(EvtType.On_Cancel2Fingers, Vector2.zero, Vector2.zero, Vector2.zero, 0f, SwipeDirection.None, 0f, Vector2.zero, 0f, 0f, 0f);
			}
			UpdateTouches(realTouch: true, num);
			twoFinger.oldPickedObject = twoFinger.pickedObject;
			if (enable2FingersGesture && num == 2)
			{
				TwoFinger();
			}
			for (int i = 0; i < 100; i++)
			{
				if (fingers[i] != null)
				{
					OneFinger(i);
				}
			}
			oldTouchCount = num;
		}

		private void LateUpdate()
		{
			if (_currentGestures.Count > 1)
			{
				_currentGestures.RemoveAt(0);
			}
			else
			{
				_currentGestures[0] = new Gesture();
			}
			_currentGesture = _currentGestures[0];
		}

		private void UpdateTouches(bool realTouch, int touchCount)
		{
			fingers.CopyTo(tmpArray, 0);
			if (realTouch || enableRemote)
			{
				ResetTouches();
				for (int i = 0; i < touchCount; i++)
				{
					UnityEngine.Touch touch = Input.GetTouch(i);
					for (int j = 0; j < 100; j++)
					{
						if (fingers[i] != null)
						{
							break;
						}
						if (tmpArray[j] != null && tmpArray[j].fingerIndex == touch.fingerId)
						{
							fingers[i] = tmpArray[j];
						}
					}
					if (fingers[i] == null)
					{
						fingers[i] = new Finger();
						fingers[i].fingerIndex = touch.fingerId;
						fingers[i].gesture = GestureType.None;
						fingers[i].phase = UnityEngine.TouchPhase.Began;
					}
					else
					{
						fingers[i].phase = touch.phase;
					}
					if (fingers[i].phase != 0)
					{
						fingers[i].deltaPosition = touch.position - fingers[i].position;
					}
					else
					{
						fingers[i].deltaPosition = Vector2.zero;
					}
					fingers[i].position = touch.position;
					fingers[i].tapCount = touch.tapCount;
					fingers[i].deltaTime = touch.deltaTime;
					fingers[i].touchCount = touchCount;
				}
			}
			else
			{
				for (int k = 0; k < touchCount; k++)
				{
					fingers[k] = input.GetMouseTouch(k, fingers[k]);
					fingers[k].touchCount = touchCount;
				}
			}
		}

		private void ResetTouches()
		{
			for (int i = 0; i < 100; i++)
			{
				fingers[i] = null;
			}
		}

		private void OneFinger(int fingerIndex)
		{
			if (fingers[fingerIndex].gesture == GestureType.None)
			{
				if (!singleDoubleTap[fingerIndex].inDoubleTap)
				{
					singleDoubleTap[fingerIndex].inDoubleTap = true;
					singleDoubleTap[fingerIndex].time = 0f;
					singleDoubleTap[fingerIndex].count = 1;
				}
				fingers[fingerIndex].startTimeAction = Time.realtimeSinceStartup;
				fingers[fingerIndex].gesture = GestureType.Acquisition;
				fingers[fingerIndex].startPosition = fingers[fingerIndex].position;
				if (autoSelect && GetPickedGameObject(fingers[fingerIndex]))
				{
					fingers[fingerIndex].pickedObject = pickedObject.pickedObj;
					fingers[fingerIndex].isGuiCamera = pickedObject.isGUI;
					fingers[fingerIndex].pickedCamera = pickedObject.pickedCamera;
				}
				if (allowUIDetection)
				{
					fingers[fingerIndex].isOverGui = IsScreenPositionOverUI(fingers[fingerIndex].position);
					fingers[fingerIndex].pickedUIElement = GetFirstUIElementFromCache();
				}
				CreateGesture(fingerIndex, EvtType.On_TouchStart, fingers[fingerIndex], SwipeDirection.None, 0f, Vector2.zero);
			}
			if (singleDoubleTap[fingerIndex].inDoubleTap)
			{
				singleDoubleTap[fingerIndex].time += Time.deltaTime;
			}
			fingers[fingerIndex].actionTime = Time.realtimeSinceStartup - fingers[fingerIndex].startTimeAction;
			if (fingers[fingerIndex].phase == UnityEngine.TouchPhase.Canceled)
			{
				fingers[fingerIndex].gesture = GestureType.Cancel;
			}
			if (fingers[fingerIndex].phase != UnityEngine.TouchPhase.Ended && fingers[fingerIndex].phase != UnityEngine.TouchPhase.Canceled)
			{
				if (fingers[fingerIndex].phase == UnityEngine.TouchPhase.Stationary && fingers[fingerIndex].actionTime >= longTapTime && fingers[fingerIndex].gesture == GestureType.Acquisition)
				{
					fingers[fingerIndex].gesture = GestureType.LongTap;
					CreateGesture(fingerIndex, EvtType.On_LongTapStart, fingers[fingerIndex], SwipeDirection.None, 0f, Vector2.zero);
				}
				if (((fingers[fingerIndex].gesture == GestureType.Acquisition || fingers[fingerIndex].gesture == GestureType.LongTap) && fingers[fingerIndex].phase == UnityEngine.TouchPhase.Moved && gesturePriority == GesturePriority.Slips) || ((fingers[fingerIndex].gesture == GestureType.Acquisition || fingers[fingerIndex].gesture == GestureType.LongTap) && !FingerInTolerance(fingers[fingerIndex]) && gesturePriority == GesturePriority.Tap))
				{
					if (fingers[fingerIndex].gesture == GestureType.LongTap)
					{
						fingers[fingerIndex].gesture = GestureType.Cancel;
						CreateGesture(fingerIndex, EvtType.On_LongTapEnd, fingers[fingerIndex], SwipeDirection.None, 0f, Vector2.zero);
						fingers[fingerIndex].gesture = GestureType.Acquisition;
					}
					else
					{
						fingers[fingerIndex].oldSwipeType = SwipeDirection.None;
						if ((bool)fingers[fingerIndex].pickedObject)
						{
							fingers[fingerIndex].gesture = GestureType.Drag;
							CreateGesture(fingerIndex, EvtType.On_DragStart, fingers[fingerIndex], SwipeDirection.None, 0f, Vector2.zero);
							if (alwaysSendSwipe)
							{
								CreateGesture(fingerIndex, EvtType.On_SwipeStart, fingers[fingerIndex], SwipeDirection.None, 0f, Vector2.zero);
							}
						}
						else
						{
							fingers[fingerIndex].gesture = GestureType.Swipe;
							CreateGesture(fingerIndex, EvtType.On_SwipeStart, fingers[fingerIndex], SwipeDirection.None, 0f, Vector2.zero);
						}
					}
				}
				EvtType evtType = EvtType.None;
				switch (fingers[fingerIndex].gesture)
				{
				case GestureType.LongTap:
					evtType = EvtType.On_LongTap;
					break;
				case GestureType.Drag:
					evtType = EvtType.On_Drag;
					break;
				case GestureType.Swipe:
					evtType = EvtType.On_Swipe;
					break;
				}
				SwipeDirection swipeDirection = SwipeDirection.None;
				swipeDirection = GetSwipe(new Vector2(0f, 0f), fingers[fingerIndex].deltaPosition);
				if (evtType != 0)
				{
					fingers[fingerIndex].oldSwipeType = swipeDirection;
					CreateGesture(fingerIndex, evtType, fingers[fingerIndex], swipeDirection, 0f, fingers[fingerIndex].deltaPosition);
					if (evtType == EvtType.On_Drag && alwaysSendSwipe)
					{
						CreateGesture(fingerIndex, EvtType.On_Swipe, fingers[fingerIndex], swipeDirection, 0f, fingers[fingerIndex].deltaPosition);
					}
				}
				CreateGesture(fingerIndex, EvtType.On_TouchDown, fingers[fingerIndex], swipeDirection, 0f, fingers[fingerIndex].deltaPosition);
				return;
			}
			switch (fingers[fingerIndex].gesture)
			{
			case GestureType.Acquisition:
				if (doubleTapDetection == DoubleTapDetection.BySystem)
				{
					if (FingerInTolerance(fingers[fingerIndex]))
					{
						if (fingers[fingerIndex].tapCount < 2)
						{
							CreateGesture(fingerIndex, EvtType.On_SimpleTap, fingers[fingerIndex], SwipeDirection.None, 0f, Vector2.zero);
						}
						else
						{
							CreateGesture(fingerIndex, EvtType.On_DoubleTap, fingers[fingerIndex], SwipeDirection.None, 0f, Vector2.zero);
						}
					}
				}
				else if (!singleDoubleTap[fingerIndex].inWait)
				{
					singleDoubleTap[fingerIndex].finger = fingers[fingerIndex];
					StartCoroutine(SingleOrDouble(fingerIndex));
				}
				else
				{
					singleDoubleTap[fingerIndex].count++;
				}
				break;
			case GestureType.LongTap:
				CreateGesture(fingerIndex, EvtType.On_LongTapEnd, fingers[fingerIndex], SwipeDirection.None, 0f, Vector2.zero);
				break;
			case GestureType.Drag:
				CreateGesture(fingerIndex, EvtType.On_DragEnd, fingers[fingerIndex], GetSwipe(fingers[fingerIndex].startPosition, fingers[fingerIndex].position), (fingers[fingerIndex].startPosition - fingers[fingerIndex].position).magnitude, fingers[fingerIndex].position - fingers[fingerIndex].startPosition);
				if (alwaysSendSwipe)
				{
					CreateGesture(fingerIndex, EvtType.On_SwipeEnd, fingers[fingerIndex], GetSwipe(fingers[fingerIndex].startPosition, fingers[fingerIndex].position), (fingers[fingerIndex].position - fingers[fingerIndex].startPosition).magnitude, fingers[fingerIndex].position - fingers[fingerIndex].startPosition);
				}
				break;
			case GestureType.Swipe:
				CreateGesture(fingerIndex, EvtType.On_SwipeEnd, fingers[fingerIndex], GetSwipe(fingers[fingerIndex].startPosition, fingers[fingerIndex].position), (fingers[fingerIndex].position - fingers[fingerIndex].startPosition).magnitude, fingers[fingerIndex].position - fingers[fingerIndex].startPosition);
				break;
			case GestureType.Cancel:
				CreateGesture(fingerIndex, EvtType.On_Cancel, fingers[fingerIndex], SwipeDirection.None, 0f, Vector2.zero);
				break;
			}
			CreateGesture(fingerIndex, EvtType.On_TouchUp, fingers[fingerIndex], SwipeDirection.None, 0f, Vector2.zero);
			fingers[fingerIndex] = null;
		}

		private IEnumerator SingleOrDouble(int fingerIndex)
		{
			singleDoubleTap[fingerIndex].inWait = true;
			float num = doubleTapTime - singleDoubleTap[fingerIndex].finger.actionTime;
			if (num < 0f)
			{
				num = 0f;
			}
			yield return new WaitForSeconds(num);
			if (singleDoubleTap[fingerIndex].count < 2)
			{
				CreateGesture(fingerIndex, EvtType.On_SimpleTap, singleDoubleTap[fingerIndex].finger, SwipeDirection.None, 0f, singleDoubleTap[fingerIndex].finger.deltaPosition);
			}
			else
			{
				CreateGesture(fingerIndex, EvtType.On_DoubleTap, singleDoubleTap[fingerIndex].finger, SwipeDirection.None, 0f, singleDoubleTap[fingerIndex].finger.deltaPosition);
			}
			singleDoubleTap[fingerIndex].Stop();
			StopCoroutine("SingleOrDouble");
		}

		private void CreateGesture(int touchIndex, EvtType message, Finger finger, SwipeDirection swipe, float swipeLength, Vector2 swipeVector)
		{
			bool flag = true;
			if (autoUpdatePickedUI && allowUIDetection)
			{
				finger.isOverGui = IsScreenPositionOverUI(finger.position);
				finger.pickedUIElement = GetFirstUIElementFromCache();
			}
			if (enabledNGuiMode && message == EvtType.On_TouchStart)
			{
				finger.isOverGui = finger.isOverGui || IsTouchOverNGui(finger.position);
			}
			if (enableUIMode || enabledNGuiMode)
			{
				flag = !finger.isOverGui;
			}
			Gesture gesture = finger.GetGesture();
			if (autoUpdatePickedObject && autoSelect && message != EvtType.On_Drag && message != EvtType.On_DragEnd && message != EvtType.On_DragStart)
			{
				if (GetPickedGameObject(finger))
				{
					gesture.pickedObject = pickedObject.pickedObj;
					gesture.pickedCamera = pickedObject.pickedCamera;
					gesture.isGuiCamera = pickedObject.isGUI;
				}
				else
				{
					gesture.pickedObject = null;
					gesture.pickedCamera = null;
					gesture.isGuiCamera = false;
				}
			}
			gesture.swipe = swipe;
			gesture.swipeLength = swipeLength;
			gesture.swipeVector = swipeVector;
			gesture.deltaPinch = 0f;
			gesture.twistAngle = 0f;
			if (flag)
			{
				RaiseEvent(message, gesture);
			}
			else if (finger.isOverGui)
			{
				if (message == EvtType.On_TouchUp)
				{
					RaiseEvent(EvtType.On_UIElementTouchUp, gesture);
				}
				else
				{
					RaiseEvent(EvtType.On_OverUIElement, gesture);
				}
			}
		}

		private void TwoFinger()
		{
			bool flag = false;
			if (twoFinger.currentGesture == GestureType.None)
			{
				if (!singleDoubleTap[99].inDoubleTap)
				{
					singleDoubleTap[99].inDoubleTap = true;
					singleDoubleTap[99].time = 0f;
					singleDoubleTap[99].count = 1;
				}
				twoFinger.finger0 = GetTwoFinger(-1);
				twoFinger.finger1 = GetTwoFinger(twoFinger.finger0);
				twoFinger.startTimeAction = Time.realtimeSinceStartup;
				twoFinger.currentGesture = GestureType.Acquisition;
				fingers[twoFinger.finger0].startPosition = fingers[twoFinger.finger0].position;
				fingers[twoFinger.finger1].startPosition = fingers[twoFinger.finger1].position;
				fingers[twoFinger.finger0].oldPosition = fingers[twoFinger.finger0].position;
				fingers[twoFinger.finger1].oldPosition = fingers[twoFinger.finger1].position;
				twoFinger.oldFingerDistance = Mathf.Abs(Vector2.Distance(fingers[twoFinger.finger0].position, fingers[twoFinger.finger1].position));
				twoFinger.startPosition = new Vector2((fingers[twoFinger.finger0].position.x + fingers[twoFinger.finger1].position.x) / 2f, (fingers[twoFinger.finger0].position.y + fingers[twoFinger.finger1].position.y) / 2f);
				twoFinger.position = twoFinger.startPosition;
				twoFinger.oldStartPosition = twoFinger.startPosition;
				twoFinger.deltaPosition = Vector2.zero;
				twoFinger.startDistance = twoFinger.oldFingerDistance;
				if (autoSelect)
				{
					if (GetTwoFingerPickedObject())
					{
						twoFinger.pickedObject = pickedObject.pickedObj;
						twoFinger.pickedCamera = pickedObject.pickedCamera;
						twoFinger.isGuiCamera = pickedObject.isGUI;
					}
					else
					{
						twoFinger.ClearPickedObjectData();
					}
				}
				if (allowUIDetection)
				{
					if (GetTwoFingerPickedUIElement())
					{
						twoFinger.pickedUIElement = pickedObject.pickedObj;
						twoFinger.isOverGui = true;
					}
					else
					{
						twoFinger.ClearPickedUIData();
					}
				}
				CreateGesture2Finger(EvtType.On_TouchStart2Fingers, twoFinger.startPosition, twoFinger.startPosition, twoFinger.deltaPosition, twoFinger.timeSinceStartAction, SwipeDirection.None, 0f, Vector2.zero, 0f, 0f, twoFinger.oldFingerDistance);
			}
			if (singleDoubleTap[99].inDoubleTap)
			{
				singleDoubleTap[99].time += Time.deltaTime;
			}
			twoFinger.timeSinceStartAction = Time.realtimeSinceStartup - twoFinger.startTimeAction;
			twoFinger.position = new Vector2((fingers[twoFinger.finger0].position.x + fingers[twoFinger.finger1].position.x) / 2f, (fingers[twoFinger.finger0].position.y + fingers[twoFinger.finger1].position.y) / 2f);
			twoFinger.deltaPosition = twoFinger.position - twoFinger.oldStartPosition;
			twoFinger.fingerDistance = Mathf.Abs(Vector2.Distance(fingers[twoFinger.finger0].position, fingers[twoFinger.finger1].position));
			if (fingers[twoFinger.finger0].phase == UnityEngine.TouchPhase.Canceled || fingers[twoFinger.finger1].phase == UnityEngine.TouchPhase.Canceled)
			{
				twoFinger.currentGesture = GestureType.Cancel;
			}
			if (fingers[twoFinger.finger0].phase != UnityEngine.TouchPhase.Ended && fingers[twoFinger.finger1].phase != UnityEngine.TouchPhase.Ended && twoFinger.currentGesture != GestureType.Cancel)
			{
				if (twoFinger.currentGesture == GestureType.Acquisition && twoFinger.timeSinceStartAction >= longTapTime && FingerInTolerance(fingers[twoFinger.finger0]) && FingerInTolerance(fingers[twoFinger.finger1]))
				{
					twoFinger.currentGesture = GestureType.LongTap;
					CreateGesture2Finger(EvtType.On_LongTapStart2Fingers, twoFinger.startPosition, twoFinger.position, twoFinger.deltaPosition, twoFinger.timeSinceStartAction, SwipeDirection.None, 0f, Vector2.zero, 0f, 0f, twoFinger.fingerDistance);
				}
				if (((!FingerInTolerance(fingers[twoFinger.finger0]) || !FingerInTolerance(fingers[twoFinger.finger1])) && gesturePriority == GesturePriority.Tap) || ((fingers[twoFinger.finger0].phase == UnityEngine.TouchPhase.Moved || fingers[twoFinger.finger1].phase == UnityEngine.TouchPhase.Moved) && gesturePriority == GesturePriority.Slips))
				{
					flag = true;
				}
				if (flag && twoFinger.currentGesture != 0)
				{
					Vector2 currentDistance = fingers[twoFinger.finger0].position - fingers[twoFinger.finger1].position;
					Vector2 previousDistance = fingers[twoFinger.finger0].oldPosition - fingers[twoFinger.finger1].oldPosition;
					float currentDelta = currentDistance.magnitude - previousDistance.magnitude;
					if (enable2FingersSwipe)
					{
						float num = Vector2.Dot(fingers[twoFinger.finger0].deltaPosition.normalized, fingers[twoFinger.finger1].deltaPosition.normalized);
						if (num > 0f)
						{
							if (twoFinger.oldGesture == GestureType.LongTap)
							{
								CreateStateEnd2Fingers(twoFinger.currentGesture, twoFinger.startPosition, twoFinger.position, twoFinger.deltaPosition, twoFinger.timeSinceStartAction, realEnd: false, twoFinger.fingerDistance);
								twoFinger.startTimeAction = Time.realtimeSinceStartup;
							}
							if ((bool)twoFinger.pickedObject && !twoFinger.dragStart && !alwaysSendSwipe)
							{
								twoFinger.currentGesture = GestureType.Drag;
								CreateGesture2Finger(EvtType.On_DragStart2Fingers, twoFinger.startPosition, twoFinger.position, twoFinger.deltaPosition, twoFinger.timeSinceStartAction, SwipeDirection.None, 0f, Vector2.zero, 0f, 0f, twoFinger.fingerDistance);
								CreateGesture2Finger(EvtType.On_SwipeStart2Fingers, twoFinger.startPosition, twoFinger.position, twoFinger.deltaPosition, twoFinger.timeSinceStartAction, SwipeDirection.None, 0f, Vector2.zero, 0f, 0f, twoFinger.fingerDistance);
								twoFinger.dragStart = true;
							}
							else if (!twoFinger.pickedObject && !twoFinger.swipeStart)
							{
								twoFinger.currentGesture = GestureType.Swipe;
								CreateGesture2Finger(EvtType.On_SwipeStart2Fingers, twoFinger.startPosition, twoFinger.position, twoFinger.deltaPosition, twoFinger.timeSinceStartAction, SwipeDirection.None, 0f, Vector2.zero, 0f, 0f, twoFinger.fingerDistance);
								twoFinger.swipeStart = true;
							}
						}
						else if (num < 0f)
						{
							twoFinger.dragStart = false;
							twoFinger.swipeStart = false;
						}
						if (twoFinger.dragStart)
						{
							CreateGesture2Finger(EvtType.On_Drag2Fingers, twoFinger.startPosition, twoFinger.position, twoFinger.deltaPosition, twoFinger.timeSinceStartAction, GetSwipe(twoFinger.oldStartPosition, twoFinger.position), 0f, twoFinger.deltaPosition, 0f, 0f, twoFinger.fingerDistance);
							CreateGesture2Finger(EvtType.On_Swipe2Fingers, twoFinger.startPosition, twoFinger.position, twoFinger.deltaPosition, twoFinger.timeSinceStartAction, GetSwipe(twoFinger.oldStartPosition, twoFinger.position), 0f, twoFinger.deltaPosition, 0f, 0f, twoFinger.fingerDistance);
						}
						if (twoFinger.swipeStart)
						{
							CreateGesture2Finger(EvtType.On_Swipe2Fingers, twoFinger.startPosition, twoFinger.position, twoFinger.deltaPosition, twoFinger.timeSinceStartAction, GetSwipe(twoFinger.oldStartPosition, twoFinger.position), 0f, twoFinger.deltaPosition, 0f, 0f, twoFinger.fingerDistance);
						}
					}
					DetectPinch(currentDelta);
					DetecTwist(previousDistance, currentDistance, currentDelta);
				}
				else if (twoFinger.currentGesture == GestureType.LongTap)
				{
					CreateGesture2Finger(EvtType.On_LongTap2Fingers, twoFinger.startPosition, twoFinger.position, twoFinger.deltaPosition, twoFinger.timeSinceStartAction, SwipeDirection.None, 0f, Vector2.zero, 0f, 0f, twoFinger.fingerDistance);
				}
				CreateGesture2Finger(EvtType.On_TouchDown2Fingers, twoFinger.startPosition, twoFinger.position, twoFinger.deltaPosition, twoFinger.timeSinceStartAction, GetSwipe(twoFinger.oldStartPosition, twoFinger.position), 0f, twoFinger.deltaPosition, 0f, 0f, twoFinger.fingerDistance);
				fingers[twoFinger.finger0].oldPosition = fingers[twoFinger.finger0].position;
				fingers[twoFinger.finger1].oldPosition = fingers[twoFinger.finger1].position;
				twoFinger.oldFingerDistance = twoFinger.fingerDistance;
				twoFinger.oldStartPosition = twoFinger.position;
				twoFinger.oldGesture = twoFinger.currentGesture;
			}
			else if (twoFinger.currentGesture != GestureType.Acquisition && twoFinger.currentGesture != 0)
			{
				CreateStateEnd2Fingers(twoFinger.currentGesture, twoFinger.startPosition, twoFinger.position, twoFinger.deltaPosition, twoFinger.timeSinceStartAction, realEnd: true, twoFinger.fingerDistance);
				twoFinger.currentGesture = GestureType.None;
				twoFinger.pickedObject = null;
				twoFinger.swipeStart = false;
				twoFinger.dragStart = false;
			}
			else
			{
				twoFinger.currentGesture = GestureType.Tap;
				CreateStateEnd2Fingers(twoFinger.currentGesture, twoFinger.startPosition, twoFinger.position, twoFinger.deltaPosition, twoFinger.timeSinceStartAction, realEnd: true, twoFinger.fingerDistance);
			}
		}

		private void DetectPinch(float currentDelta)
		{
			if (!enablePinch)
			{
				return;
			}
			if ((Mathf.Abs(twoFinger.fingerDistance - twoFinger.startDistance) >= minPinchLength && twoFinger.currentGesture != GestureType.Pinch) || twoFinger.currentGesture == GestureType.Pinch)
			{
				if (currentDelta != 0f && twoFinger.oldGesture == GestureType.LongTap)
				{
					CreateStateEnd2Fingers(twoFinger.currentGesture, twoFinger.startPosition, twoFinger.position, twoFinger.deltaPosition, twoFinger.timeSinceStartAction, realEnd: false, twoFinger.fingerDistance);
					twoFinger.startTimeAction = Time.realtimeSinceStartup;
				}
				twoFinger.currentGesture = GestureType.Pinch;
				if (currentDelta > 0f)
				{
					CreateGesture2Finger(EvtType.On_PinchOut, twoFinger.startPosition, twoFinger.position, twoFinger.deltaPosition, twoFinger.timeSinceStartAction, GetSwipe(twoFinger.startPosition, twoFinger.position), 0f, Vector2.zero, 0f, Mathf.Abs(twoFinger.fingerDistance - twoFinger.oldFingerDistance), twoFinger.fingerDistance);
				}
				if (currentDelta < 0f)
				{
					CreateGesture2Finger(EvtType.On_PinchIn, twoFinger.startPosition, twoFinger.position, twoFinger.deltaPosition, twoFinger.timeSinceStartAction, GetSwipe(twoFinger.startPosition, twoFinger.position), 0f, Vector2.zero, 0f, Mathf.Abs(twoFinger.fingerDistance - twoFinger.oldFingerDistance), twoFinger.fingerDistance);
				}
				if (currentDelta < 0f || currentDelta > 0f)
				{
					CreateGesture2Finger(EvtType.On_Pinch, twoFinger.startPosition, twoFinger.position, twoFinger.deltaPosition, twoFinger.timeSinceStartAction, GetSwipe(twoFinger.startPosition, twoFinger.position), 0f, Vector2.zero, 0f, currentDelta, twoFinger.fingerDistance);
				}
			}
			twoFinger.lastPinch = ((currentDelta > 0f) ? currentDelta : twoFinger.lastPinch);
		}

		private void DetecTwist(Vector2 previousDistance, Vector2 currentDistance, float currentDelta)
		{
			if (!enableTwist)
			{
				return;
			}
			float num = Vector2.Angle(previousDistance, currentDistance);
			if (previousDistance == currentDistance)
			{
				num = 0f;
			}
			if ((Mathf.Abs(num) >= minTwistAngle && twoFinger.currentGesture != GestureType.Twist) || twoFinger.currentGesture == GestureType.Twist)
			{
				if (twoFinger.oldGesture == GestureType.LongTap)
				{
					CreateStateEnd2Fingers(twoFinger.currentGesture, twoFinger.startPosition, twoFinger.position, twoFinger.deltaPosition, twoFinger.timeSinceStartAction, realEnd: false, twoFinger.fingerDistance);
					twoFinger.startTimeAction = Time.realtimeSinceStartup;
				}
				twoFinger.currentGesture = GestureType.Twist;
				if (num != 0f)
				{
					num *= Mathf.Sign(Vector3.Cross(previousDistance, currentDistance).z);
				}
				CreateGesture2Finger(EvtType.On_Twist, twoFinger.startPosition, twoFinger.position, twoFinger.deltaPosition, twoFinger.timeSinceStartAction, SwipeDirection.None, 0f, Vector2.zero, num, 0f, twoFinger.fingerDistance);
			}
			twoFinger.lastTwistAngle = ((num != 0f) ? num : twoFinger.lastTwistAngle);
		}

		private void CreateStateEnd2Fingers(GestureType gesture, Vector2 startPosition, Vector2 position, Vector2 deltaPosition, float time, bool realEnd, float fingerDistance, float twist = 0f, float pinch = 0f)
		{
			switch (gesture)
			{
			case GestureType.Tap:
			case GestureType.Acquisition:
				if (doubleTapDetection == DoubleTapDetection.BySystem)
				{
					if (fingers[twoFinger.finger0].tapCount < 2 && fingers[twoFinger.finger1].tapCount < 2)
					{
						CreateGesture2Finger(EvtType.On_SimpleTap2Fingers, startPosition, position, deltaPosition, time, SwipeDirection.None, 0f, Vector2.zero, 0f, 0f, fingerDistance);
					}
					else
					{
						CreateGesture2Finger(EvtType.On_DoubleTap2Fingers, startPosition, position, deltaPosition, time, SwipeDirection.None, 0f, Vector2.zero, 0f, 0f, fingerDistance);
					}
					twoFinger.currentGesture = GestureType.None;
					twoFinger.pickedObject = null;
					twoFinger.swipeStart = false;
					twoFinger.dragStart = false;
					singleDoubleTap[99].Stop();
					StopCoroutine("SingleOrDouble2Fingers");
				}
				else if (!singleDoubleTap[99].inWait)
				{
					StartCoroutine("SingleOrDouble2Fingers");
				}
				else
				{
					singleDoubleTap[99].count++;
				}
				break;
			case GestureType.LongTap:
				CreateGesture2Finger(EvtType.On_LongTapEnd2Fingers, startPosition, position, deltaPosition, time, SwipeDirection.None, 0f, Vector2.zero, 0f, 0f, fingerDistance);
				break;
			case GestureType.Pinch:
				CreateGesture2Finger(EvtType.On_PinchEnd, startPosition, position, deltaPosition, time, SwipeDirection.None, 0f, Vector2.zero, 0f, twoFinger.lastPinch, fingerDistance);
				break;
			case GestureType.Twist:
				CreateGesture2Finger(EvtType.On_TwistEnd, startPosition, position, deltaPosition, time, SwipeDirection.None, 0f, Vector2.zero, twoFinger.lastTwistAngle, 0f, fingerDistance);
				break;
			}
			if (realEnd)
			{
				if (twoFinger.dragStart)
				{
					CreateGesture2Finger(EvtType.On_DragEnd2Fingers, startPosition, position, deltaPosition, time, GetSwipe(startPosition, position), (position - startPosition).magnitude, position - startPosition, 0f, 0f, fingerDistance);
				}
				if (twoFinger.swipeStart)
				{
					CreateGesture2Finger(EvtType.On_SwipeEnd2Fingers, startPosition, position, deltaPosition, time, GetSwipe(startPosition, position), (position - startPosition).magnitude, position - startPosition, 0f, 0f, fingerDistance);
				}
				CreateGesture2Finger(EvtType.On_TouchUp2Fingers, startPosition, position, deltaPosition, time, SwipeDirection.None, 0f, Vector2.zero, 0f, 0f, fingerDistance);
			}
		}

		private IEnumerator SingleOrDouble2Fingers()
		{
			singleDoubleTap[99].inWait = true;
			yield return new WaitForSeconds(doubleTapTime);
			if (singleDoubleTap[99].count < 2)
			{
				CreateGesture2Finger(EvtType.On_SimpleTap2Fingers, twoFinger.startPosition, twoFinger.position, twoFinger.deltaPosition, twoFinger.timeSinceStartAction, SwipeDirection.None, 0f, Vector2.zero, 0f, 0f, twoFinger.fingerDistance);
			}
			else
			{
				CreateGesture2Finger(EvtType.On_DoubleTap2Fingers, twoFinger.startPosition, twoFinger.position, twoFinger.deltaPosition, twoFinger.timeSinceStartAction, SwipeDirection.None, 0f, Vector2.zero, 0f, 0f, twoFinger.fingerDistance);
			}
			twoFinger.currentGesture = GestureType.None;
			twoFinger.pickedObject = null;
			twoFinger.swipeStart = false;
			twoFinger.dragStart = false;
			singleDoubleTap[99].Stop();
			StopCoroutine("SingleOrDouble2Fingers");
		}

		private void CreateGesture2Finger(EvtType message, Vector2 startPosition, Vector2 position, Vector2 deltaPosition, float actionTime, SwipeDirection swipe, float swipeLength, Vector2 swipeVector, float twist, float pinch, float twoDistance)
		{
			bool flag = true;
			Gesture gesture = new Gesture();
			gesture.isOverGui = false;
			if (enabledNGuiMode && message == EvtType.On_TouchStart2Fingers)
			{
				gesture.isOverGui = gesture.isOverGui || (IsTouchOverNGui(twoFinger.position) && IsTouchOverNGui(twoFinger.position));
			}
			gesture.touchCount = 2;
			gesture.fingerIndex = -1;
			gesture.startPosition = startPosition;
			gesture.position = position;
			gesture.deltaPosition = deltaPosition;
			gesture.actionTime = actionTime;
			gesture.deltaTime = Time.deltaTime;
			gesture.swipe = swipe;
			gesture.swipeLength = swipeLength;
			gesture.swipeVector = swipeVector;
			gesture.deltaPinch = pinch;
			gesture.twistAngle = twist;
			gesture.twoFingerDistance = twoDistance;
			gesture.pickedObject = twoFinger.pickedObject;
			gesture.pickedCamera = twoFinger.pickedCamera;
			gesture.isGuiCamera = twoFinger.isGuiCamera;
			if (autoUpdatePickedObject && message != EvtType.On_Drag && message != EvtType.On_DragEnd && message != EvtType.On_Twist && message != EvtType.On_TwistEnd && message != EvtType.On_Pinch && message != EvtType.On_PinchEnd && message != EvtType.On_PinchIn && message != EvtType.On_PinchOut)
			{
				if (GetTwoFingerPickedObject())
				{
					gesture.pickedObject = pickedObject.pickedObj;
					gesture.pickedCamera = pickedObject.pickedCamera;
					gesture.isGuiCamera = pickedObject.isGUI;
				}
				else
				{
					twoFinger.ClearPickedObjectData();
				}
			}
			gesture.pickedUIElement = twoFinger.pickedUIElement;
			gesture.isOverGui = twoFinger.isOverGui;
			if (allowUIDetection && autoUpdatePickedUI && message != EvtType.On_Drag && message != EvtType.On_DragEnd && message != EvtType.On_Twist && message != EvtType.On_TwistEnd && message != EvtType.On_Pinch && message != EvtType.On_PinchEnd && message != EvtType.On_PinchIn && message != EvtType.On_PinchOut && message == EvtType.On_SimpleTap2Fingers)
			{
				if (GetTwoFingerPickedUIElement())
				{
					gesture.pickedUIElement = pickedObject.pickedObj;
					gesture.isOverGui = true;
				}
				else
				{
					twoFinger.ClearPickedUIData();
				}
			}
			if (enableUIMode || (enabledNGuiMode && allowUIDetection))
			{
				flag = !gesture.isOverGui;
			}
			if (flag)
			{
				RaiseEvent(message, gesture);
			}
			else if (gesture.isOverGui)
			{
				if (message == EvtType.On_TouchUp2Fingers)
				{
					RaiseEvent(EvtType.On_UIElementTouchUp, gesture);
				}
				else
				{
					RaiseEvent(EvtType.On_OverUIElement, gesture);
				}
			}
		}

		private int GetTwoFinger(int index)
		{
			int i = index + 1;
			bool flag = false;
			for (; i < 10; i++)
			{
				if (flag)
				{
					break;
				}
				if (fingers[i] != null && i >= index)
				{
					flag = true;
				}
			}
			return i - 1;
		}

		private bool GetTwoFingerPickedObject()
		{
			bool result = false;
			if (twoFingerPickMethod == TwoFingerPickMethod.Finger)
			{
				if (GetPickedGameObject(fingers[twoFinger.finger0]))
				{
					GameObject pickedObj = pickedObject.pickedObj;
					if (GetPickedGameObject(fingers[twoFinger.finger1]) && pickedObj == pickedObject.pickedObj)
					{
						result = true;
					}
				}
			}
			else if (GetPickedGameObject(fingers[twoFinger.finger0], isTowFinger: true))
			{
				result = true;
			}
			return result;
		}

		private bool GetTwoFingerPickedUIElement()
		{
			bool result = false;
			if (fingers[twoFinger.finger0] == null)
			{
				return false;
			}
			if (twoFingerPickMethod == TwoFingerPickMethod.Finger)
			{
				if (IsScreenPositionOverUI(fingers[twoFinger.finger0].position))
				{
					GameObject firstUIElementFromCache = GetFirstUIElementFromCache();
					if (IsScreenPositionOverUI(fingers[twoFinger.finger1].position))
					{
						GameObject firstUIElementFromCache2 = GetFirstUIElementFromCache();
						if (firstUIElementFromCache2 == firstUIElementFromCache || firstUIElementFromCache2.transform.IsChildOf(firstUIElementFromCache.transform) || firstUIElementFromCache.transform.IsChildOf(firstUIElementFromCache2.transform))
						{
							pickedObject.pickedObj = firstUIElementFromCache;
							pickedObject.isGUI = true;
							result = true;
						}
					}
				}
			}
			else if (IsScreenPositionOverUI(twoFinger.position))
			{
				pickedObject.pickedObj = GetFirstUIElementFromCache();
				pickedObject.isGUI = true;
				result = true;
			}
			return result;
		}

		private void RaiseEvent(EvtType evnt, Gesture gesture)
		{
			gesture.type = evnt;
			switch (evnt)
			{
			case EvtType.On_Cancel:
				if (EasyTouch.On_Cancel != null)
				{
					EasyTouch.On_Cancel(gesture);
				}
				break;
			case EvtType.On_Cancel2Fingers:
				if (EasyTouch.On_Cancel2Fingers != null)
				{
					EasyTouch.On_Cancel2Fingers(gesture);
				}
				break;
			case EvtType.On_TouchStart:
				if (EasyTouch.On_TouchStart != null)
				{
					EasyTouch.On_TouchStart(gesture);
				}
				break;
			case EvtType.On_TouchDown:
				if (EasyTouch.On_TouchDown != null)
				{
					EasyTouch.On_TouchDown(gesture);
				}
				break;
			case EvtType.On_TouchUp:
				if (EasyTouch.On_TouchUp != null)
				{
					EasyTouch.On_TouchUp(gesture);
				}
				break;
			case EvtType.On_SimpleTap:
				if (EasyTouch.On_SimpleTap != null)
				{
					EasyTouch.On_SimpleTap(gesture);
				}
				break;
			case EvtType.On_DoubleTap:
				if (EasyTouch.On_DoubleTap != null)
				{
					EasyTouch.On_DoubleTap(gesture);
				}
				break;
			case EvtType.On_LongTapStart:
				if (EasyTouch.On_LongTapStart != null)
				{
					EasyTouch.On_LongTapStart(gesture);
				}
				break;
			case EvtType.On_LongTap:
				if (EasyTouch.On_LongTap != null)
				{
					EasyTouch.On_LongTap(gesture);
				}
				break;
			case EvtType.On_LongTapEnd:
				if (EasyTouch.On_LongTapEnd != null)
				{
					EasyTouch.On_LongTapEnd(gesture);
				}
				break;
			case EvtType.On_DragStart:
				if (EasyTouch.On_DragStart != null)
				{
					EasyTouch.On_DragStart(gesture);
				}
				break;
			case EvtType.On_Drag:
				if (EasyTouch.On_Drag != null)
				{
					EasyTouch.On_Drag(gesture);
				}
				break;
			case EvtType.On_DragEnd:
				if (EasyTouch.On_DragEnd != null)
				{
					EasyTouch.On_DragEnd(gesture);
				}
				break;
			case EvtType.On_SwipeStart:
				if (EasyTouch.On_SwipeStart != null)
				{
					EasyTouch.On_SwipeStart(gesture);
				}
				break;
			case EvtType.On_Swipe:
				if (EasyTouch.On_Swipe != null)
				{
					EasyTouch.On_Swipe(gesture);
				}
				break;
			case EvtType.On_SwipeEnd:
				if (EasyTouch.On_SwipeEnd != null)
				{
					EasyTouch.On_SwipeEnd(gesture);
				}
				break;
			case EvtType.On_TouchStart2Fingers:
				if (EasyTouch.On_TouchStart2Fingers != null)
				{
					EasyTouch.On_TouchStart2Fingers(gesture);
				}
				break;
			case EvtType.On_TouchDown2Fingers:
				if (EasyTouch.On_TouchDown2Fingers != null)
				{
					EasyTouch.On_TouchDown2Fingers(gesture);
				}
				break;
			case EvtType.On_TouchUp2Fingers:
				if (EasyTouch.On_TouchUp2Fingers != null)
				{
					EasyTouch.On_TouchUp2Fingers(gesture);
				}
				break;
			case EvtType.On_SimpleTap2Fingers:
				if (EasyTouch.On_SimpleTap2Fingers != null)
				{
					EasyTouch.On_SimpleTap2Fingers(gesture);
				}
				break;
			case EvtType.On_DoubleTap2Fingers:
				if (EasyTouch.On_DoubleTap2Fingers != null)
				{
					EasyTouch.On_DoubleTap2Fingers(gesture);
				}
				break;
			case EvtType.On_LongTapStart2Fingers:
				if (EasyTouch.On_LongTapStart2Fingers != null)
				{
					EasyTouch.On_LongTapStart2Fingers(gesture);
				}
				break;
			case EvtType.On_LongTap2Fingers:
				if (EasyTouch.On_LongTap2Fingers != null)
				{
					EasyTouch.On_LongTap2Fingers(gesture);
				}
				break;
			case EvtType.On_LongTapEnd2Fingers:
				if (EasyTouch.On_LongTapEnd2Fingers != null)
				{
					EasyTouch.On_LongTapEnd2Fingers(gesture);
				}
				break;
			case EvtType.On_Twist:
				if (EasyTouch.On_Twist != null)
				{
					EasyTouch.On_Twist(gesture);
				}
				break;
			case EvtType.On_TwistEnd:
				if (EasyTouch.On_TwistEnd != null)
				{
					EasyTouch.On_TwistEnd(gesture);
				}
				break;
			case EvtType.On_Pinch:
				if (EasyTouch.On_Pinch != null)
				{
					EasyTouch.On_Pinch(gesture);
				}
				break;
			case EvtType.On_PinchIn:
				if (EasyTouch.On_PinchIn != null)
				{
					EasyTouch.On_PinchIn(gesture);
				}
				break;
			case EvtType.On_PinchOut:
				if (EasyTouch.On_PinchOut != null)
				{
					EasyTouch.On_PinchOut(gesture);
				}
				break;
			case EvtType.On_PinchEnd:
				if (EasyTouch.On_PinchEnd != null)
				{
					EasyTouch.On_PinchEnd(gesture);
				}
				break;
			case EvtType.On_DragStart2Fingers:
				if (EasyTouch.On_DragStart2Fingers != null)
				{
					EasyTouch.On_DragStart2Fingers(gesture);
				}
				break;
			case EvtType.On_Drag2Fingers:
				if (EasyTouch.On_Drag2Fingers != null)
				{
					EasyTouch.On_Drag2Fingers(gesture);
				}
				break;
			case EvtType.On_DragEnd2Fingers:
				if (EasyTouch.On_DragEnd2Fingers != null)
				{
					EasyTouch.On_DragEnd2Fingers(gesture);
				}
				break;
			case EvtType.On_SwipeStart2Fingers:
				if (EasyTouch.On_SwipeStart2Fingers != null)
				{
					EasyTouch.On_SwipeStart2Fingers(gesture);
				}
				break;
			case EvtType.On_Swipe2Fingers:
				if (EasyTouch.On_Swipe2Fingers != null)
				{
					EasyTouch.On_Swipe2Fingers(gesture);
				}
				break;
			case EvtType.On_SwipeEnd2Fingers:
				if (EasyTouch.On_SwipeEnd2Fingers != null)
				{
					EasyTouch.On_SwipeEnd2Fingers(gesture);
				}
				break;
			case EvtType.On_OverUIElement:
				if (EasyTouch.On_OverUIElement != null)
				{
					EasyTouch.On_OverUIElement(gesture);
				}
				break;
			case EvtType.On_UIElementTouchUp:
				if (EasyTouch.On_UIElementTouchUp != null)
				{
					EasyTouch.On_UIElementTouchUp(gesture);
				}
				break;
			}
			int num = _currentGestures.FindIndex((Gesture obj) => obj.type == gesture.type && obj.fingerIndex == gesture.fingerIndex);
			if (num > -1)
			{
				_currentGestures[num].touchCount = gesture.touchCount;
				_currentGestures[num].position = gesture.position;
				_currentGestures[num].actionTime = gesture.actionTime;
				_currentGestures[num].pickedCamera = gesture.pickedCamera;
				_currentGestures[num].pickedObject = gesture.pickedObject;
				_currentGestures[num].pickedUIElement = gesture.pickedUIElement;
				_currentGestures[num].isOverGui = gesture.isOverGui;
				_currentGestures[num].isGuiCamera = gesture.isGuiCamera;
				_currentGestures[num].deltaPinch += gesture.deltaPinch;
				_currentGestures[num].deltaPosition += gesture.deltaPosition;
				_currentGestures[num].deltaTime += gesture.deltaTime;
				_currentGestures[num].twistAngle += gesture.twistAngle;
			}
			if (num == -1)
			{
				_currentGestures.Add((Gesture)gesture.Clone());
				if (_currentGestures.Count > 0)
				{
					_currentGesture = _currentGestures[0];
				}
			}
		}

		private bool GetPickedGameObject(Finger finger, bool isTowFinger = false)
		{
			if (finger == null && !isTowFinger)
			{
				return false;
			}
			pickedObject.isGUI = false;
			pickedObject.pickedObj = null;
			pickedObject.pickedCamera = null;
			if (touchCameras.Count > 0)
			{
				for (int i = 0; i < touchCameras.Count; i++)
				{
					if (touchCameras[i].camera != null && touchCameras[i].camera.enabled)
					{
						Vector2 zero = Vector2.zero;
						zero = (isTowFinger ? twoFinger.position : finger.position);
						if (GetGameObjectAt(zero, touchCameras[i].camera, touchCameras[i].guiCamera))
						{
							return true;
						}
					}
				}
			}
			else
			{
				UnityEngine.Debug.LogWarning("No camera is assigned to EasyTouch");
			}
			return false;
		}

		private bool GetGameObjectAt(Vector2 position, Camera cam, bool isGuiCam)
		{
			Ray ray = cam.ScreenPointToRay(position);
			if (enable2D)
			{
				LayerMask layerMask = pickableLayers2D;
				RaycastHit2D[] array = new RaycastHit2D[1];
				if (Physics2D.GetRayIntersectionNonAlloc(ray, array, float.PositiveInfinity, layerMask) > 0)
				{
					pickedObject.pickedCamera = cam;
					pickedObject.isGUI = isGuiCam;
					pickedObject.pickedObj = array[0].collider.gameObject;
					return true;
				}
			}
			LayerMask layerMask2 = pickableLayers3D;
			if (Physics.Raycast(ray, out var hitInfo, float.MaxValue, layerMask2))
			{
				pickedObject.pickedCamera = cam;
				pickedObject.isGUI = isGuiCam;
				pickedObject.pickedObj = hitInfo.collider.gameObject;
				return true;
			}
			return false;
		}

		private SwipeDirection GetSwipe(Vector2 start, Vector2 end)
		{
			Vector2 normalized = (end - start).normalized;
			if (Vector2.Dot(normalized, Vector2.up) >= swipeTolerance)
			{
				return SwipeDirection.Up;
			}
			if (Vector2.Dot(normalized, -Vector2.up) >= swipeTolerance)
			{
				return SwipeDirection.Down;
			}
			if (Vector2.Dot(normalized, Vector2.right) >= swipeTolerance)
			{
				return SwipeDirection.Right;
			}
			if (Vector2.Dot(normalized, -Vector2.right) >= swipeTolerance)
			{
				return SwipeDirection.Left;
			}
			if (Vector2.Dot(normalized, new Vector2(0.5f, 0.5f).normalized) >= swipeTolerance)
			{
				return SwipeDirection.UpRight;
			}
			if (Vector2.Dot(normalized, new Vector2(0.5f, -0.5f).normalized) >= swipeTolerance)
			{
				return SwipeDirection.DownRight;
			}
			if (Vector2.Dot(normalized, new Vector2(-0.5f, 0.5f).normalized) >= swipeTolerance)
			{
				return SwipeDirection.UpLeft;
			}
			if (Vector2.Dot(normalized, new Vector2(-0.5f, -0.5f).normalized) >= swipeTolerance)
			{
				return SwipeDirection.DownLeft;
			}
			return SwipeDirection.Other;
		}

		private bool FingerInTolerance(Finger finger)
		{
			if ((finger.position - finger.startPosition).sqrMagnitude <= StationaryTolerance * StationaryTolerance)
			{
				return true;
			}
			return false;
		}

		private bool IsTouchOverNGui(Vector2 position, bool isTwoFingers = false)
		{
			bool flag = false;
			if (enabledNGuiMode)
			{
				LayerMask layerMask = nGUILayers;
				int num = 0;
				while (!flag && num < nGUICameras.Count)
				{
					Vector2 zero = Vector2.zero;
					zero = (isTwoFingers ? twoFinger.position : position);
					flag = Physics.Raycast(nGUICameras[num].ScreenPointToRay(zero), out var _, float.MaxValue, layerMask);
					num++;
				}
			}
			return flag;
		}

		private Finger GetFinger(int finderId)
		{
			int i = 0;
			Finger finger = null;
			for (; i < 10; i++)
			{
				if (finger != null)
				{
					break;
				}
				if (fingers[i] != null && fingers[i].fingerIndex == finderId)
				{
					finger = fingers[i];
				}
			}
			return finger;
		}

		private bool IsScreenPositionOverUI(Vector2 position)
		{
			uiEventSystem = EventSystem.current;
			if (uiEventSystem != null)
			{
				uiPointerEventData = new PointerEventData(uiEventSystem);
				uiPointerEventData.position = position;
				uiEventSystem.RaycastAll(uiPointerEventData, uiRaycastResultCache);
				if (uiRaycastResultCache.Count > 0)
				{
					return true;
				}
				return false;
			}
			return false;
		}

		private GameObject GetFirstUIElementFromCache()
		{
			if (uiRaycastResultCache.Count > 0)
			{
				return uiRaycastResultCache[0].gameObject;
			}
			return null;
		}

		private GameObject GetFirstUIElement(Vector2 position)
		{
			if (IsScreenPositionOverUI(position))
			{
				return GetFirstUIElementFromCache();
			}
			return null;
		}

		public static bool IsFingerOverUIElement(int fingerIndex)
		{
			if (instance != null)
			{
				Finger finger = instance.GetFinger(fingerIndex);
				if (finger != null)
				{
					return instance.IsScreenPositionOverUI(finger.position);
				}
				return false;
			}
			return false;
		}

		public static GameObject GetCurrentPickedUIElement(int fingerIndex, bool isTwoFinger)
		{
			if (instance != null)
			{
				Finger finger = instance.GetFinger(fingerIndex);
				if (finger != null || isTwoFinger)
				{
					Vector2 zero = Vector2.zero;
					zero = (isTwoFinger ? instance.twoFinger.position : finger.position);
					return instance.GetFirstUIElement(zero);
				}
				return null;
			}
			return null;
		}

		public static GameObject GetCurrentPickedObject(int fingerIndex, bool isTwoFinger)
		{
			if (instance != null)
			{
				Finger finger = instance.GetFinger(fingerIndex);
				if ((finger != null || isTwoFinger) && instance.GetPickedGameObject(finger, isTwoFinger))
				{
					return instance.pickedObject.pickedObj;
				}
				return null;
			}
			return null;
		}

		public static GameObject GetGameObjectAt(Vector2 position, bool isTwoFinger = false)
		{
			if (instance != null)
			{
				if (isTwoFinger)
				{
					position = instance.twoFinger.position;
				}
				if (instance.touchCameras.Count > 0)
				{
					for (int i = 0; i < instance.touchCameras.Count; i++)
					{
						if (instance.touchCameras[i].camera != null && instance.touchCameras[i].camera.enabled)
						{
							if (instance.GetGameObjectAt(position, instance.touchCameras[i].camera, instance.touchCameras[i].guiCamera))
							{
								return instance.pickedObject.pickedObj;
							}
							return null;
						}
					}
				}
			}
			return null;
		}

		public static int GetTouchCount()
		{
			if ((bool)instance)
			{
				return instance.input.TouchCount();
			}
			return 0;
		}

		public static void ResetTouch(int fingerIndex)
		{
			if ((bool)instance)
			{
				instance.GetFinger(fingerIndex).gesture = GestureType.None;
			}
		}

		public static void SetEnabled(bool enable)
		{
			instance.enable = enable;
			if (enable)
			{
				instance.ResetTouches();
			}
		}

		public static bool GetEnabled()
		{
			if ((bool)instance)
			{
				return instance.enable;
			}
			return false;
		}

		public static void SetEnableUIDetection(bool enable)
		{
			if (instance != null)
			{
				instance.allowUIDetection = enable;
			}
		}

		public static bool GetEnableUIDetection()
		{
			if ((bool)instance)
			{
				return instance.allowUIDetection;
			}
			return false;
		}

		public static void SetUICompatibily(bool value)
		{
			if (instance != null)
			{
				instance.enableUIMode = value;
			}
		}

		public static bool GetUIComptability()
		{
			if (instance != null)
			{
				return instance.enableUIMode;
			}
			return false;
		}

		public static void SetAutoUpdateUI(bool value)
		{
			if ((bool)instance)
			{
				instance.autoUpdatePickedUI = value;
			}
		}

		public static bool GetAutoUpdateUI()
		{
			if ((bool)instance)
			{
				return instance.autoUpdatePickedUI;
			}
			return false;
		}

		public static void SetNGUICompatibility(bool value)
		{
			if ((bool)instance)
			{
				instance.enabledNGuiMode = value;
			}
		}

		public static bool GetNGUICompatibility()
		{
			if ((bool)instance)
			{
				return instance.enabledNGuiMode;
			}
			return false;
		}

		public static void SetEnableAutoSelect(bool value)
		{
			if ((bool)instance)
			{
				instance.autoSelect = value;
			}
		}

		public static bool GetEnableAutoSelect()
		{
			if ((bool)instance)
			{
				return instance.autoSelect;
			}
			return false;
		}

		public static void SetAutoUpdatePickedObject(bool value)
		{
			if ((bool)instance)
			{
				instance.autoUpdatePickedObject = value;
			}
		}

		public static bool GetAutoUpdatePickedObject()
		{
			if ((bool)instance)
			{
				return instance.autoUpdatePickedObject;
			}
			return false;
		}

		public static void Set3DPickableLayer(LayerMask mask)
		{
			if ((bool)instance)
			{
				instance.pickableLayers3D = mask;
			}
		}

		public static LayerMask Get3DPickableLayer()
		{
			if ((bool)instance)
			{
				return instance.pickableLayers3D;
			}
			return LayerMask.GetMask("Default");
		}

		public static void AddCamera(Camera cam, bool guiCam = false)
		{
			if ((bool)instance)
			{
				instance.touchCameras.Add(new ECamera(cam, guiCam));
			}
		}

		public static void RemoveCamera(Camera cam)
		{
			if ((bool)instance)
			{
				int num = instance.touchCameras.FindIndex((ECamera c) => c.camera == cam);
				if (num > -1)
				{
					instance.touchCameras[num] = null;
					instance.touchCameras.RemoveAt(num);
				}
			}
		}

		public static Camera GetCamera(int index = 0)
		{
			if ((bool)instance)
			{
				if (index < instance.touchCameras.Count)
				{
					return instance.touchCameras[index].camera;
				}
				return null;
			}
			return null;
		}

		public static void SetEnable2DCollider(bool value)
		{
			if ((bool)instance)
			{
				instance.enable2D = value;
			}
		}

		public static bool GetEnable2DCollider()
		{
			if ((bool)instance)
			{
				return instance.enable2D;
			}
			return false;
		}

		public static void Set2DPickableLayer(LayerMask mask)
		{
			if ((bool)instance)
			{
				instance.pickableLayers2D = mask;
			}
		}

		public static LayerMask Get2DPickableLayer()
		{
			if ((bool)instance)
			{
				return instance.pickableLayers2D;
			}
			return LayerMask.GetMask("Default");
		}

		public static void SetGesturePriority(GesturePriority value)
		{
			if ((bool)instance)
			{
				instance.gesturePriority = value;
			}
		}

		public static GesturePriority GetGesturePriority()
		{
			if ((bool)instance)
			{
				return instance.gesturePriority;
			}
			return GesturePriority.Tap;
		}

		public static void SetStationaryTolerance(float tolerance)
		{
			if ((bool)instance)
			{
				instance.StationaryTolerance = tolerance;
			}
		}

		public static float GetStationaryTolerance()
		{
			if ((bool)instance)
			{
				return instance.StationaryTolerance;
			}
			return -1f;
		}

		public static void SetLongTapTime(float time)
		{
			if ((bool)instance)
			{
				instance.longTapTime = time;
			}
		}

		public static float GetlongTapTime()
		{
			if ((bool)instance)
			{
				return instance.longTapTime;
			}
			return -1f;
		}

		public static void SetDoubleTapTime(float time)
		{
			if ((bool)instance)
			{
				instance.doubleTapTime = time;
			}
		}

		public static float GetDoubleTapTime()
		{
			if ((bool)instance)
			{
				return instance.doubleTapTime;
			}
			return -1f;
		}

		public static void SetDoubleTapMethod(DoubleTapDetection detection)
		{
			if ((bool)instance)
			{
				instance.doubleTapDetection = detection;
			}
		}

		public static DoubleTapDetection GetDoubleTapMethod()
		{
			if ((bool)instance)
			{
				return instance.doubleTapDetection;
			}
			return DoubleTapDetection.BySystem;
		}

		public static void SetSwipeTolerance(float tolerance)
		{
			if ((bool)instance)
			{
				instance.swipeTolerance = tolerance;
			}
		}

		public static float GetSwipeTolerance()
		{
			if ((bool)instance)
			{
				return instance.swipeTolerance;
			}
			return -1f;
		}

		public static void SetEnable2FingersGesture(bool enable)
		{
			if ((bool)instance)
			{
				instance.enable2FingersGesture = enable;
			}
		}

		public static bool GetEnable2FingersGesture()
		{
			if ((bool)instance)
			{
				return instance.enable2FingersGesture;
			}
			return false;
		}

		public static void SetTwoFingerPickMethod(TwoFingerPickMethod pickMethod)
		{
			if ((bool)instance)
			{
				instance.twoFingerPickMethod = pickMethod;
			}
		}

		public static TwoFingerPickMethod GetTwoFingerPickMethod()
		{
			if ((bool)instance)
			{
				return instance.twoFingerPickMethod;
			}
			return TwoFingerPickMethod.Finger;
		}

		public static void SetEnablePinch(bool enable)
		{
			if ((bool)instance)
			{
				instance.enablePinch = enable;
			}
		}

		public static bool GetEnablePinch()
		{
			if ((bool)instance)
			{
				return instance.enablePinch;
			}
			return false;
		}

		public static void SetMinPinchLength(float length)
		{
			if ((bool)instance)
			{
				instance.minPinchLength = length;
			}
		}

		public static float GetMinPinchLength()
		{
			if ((bool)instance)
			{
				return instance.minPinchLength;
			}
			return -1f;
		}

		public static void SetEnableTwist(bool enable)
		{
			if ((bool)instance)
			{
				instance.enableTwist = enable;
			}
		}

		public static bool GetEnableTwist()
		{
			if ((bool)instance)
			{
				return instance.enableTwist;
			}
			return false;
		}

		public static void SetMinTwistAngle(float angle)
		{
			if ((bool)instance)
			{
				instance.minTwistAngle = angle;
			}
		}

		public static float GetMinTwistAngle()
		{
			if ((bool)instance)
			{
				return instance.minTwistAngle;
			}
			return -1f;
		}

		public static bool GetSecondeFingerSimulation()
		{
			if (instance != null)
			{
				return instance.enableSimulation;
			}
			return false;
		}

		public static void SetSecondFingerSimulation(bool value)
		{
			if (instance != null)
			{
				instance.enableSimulation = value;
			}
		}
	}
	public class EasyTouchInput
	{
		private Vector2[] oldMousePosition = new Vector2[2];

		private int[] tapCount = new int[2];

		private float[] startActionTime = new float[2];

		private float[] deltaTime = new float[2];

		private float[] tapeTime = new float[2];

		private bool bComplex;

		private Vector2 deltaFingerPosition;

		private Vector2 oldFinger2Position;

		private Vector2 complexCenter;

		public int TouchCount()
		{
			return getTouchCount(realTouch: true);
		}

		private int getTouchCount(bool realTouch)
		{
			int num = 0;
			if (realTouch || EasyTouch.instance.enableRemote)
			{
				num = Input.touchCount;
			}
			else if (Input.GetMouseButton(0) || Input.GetMouseButtonUp(0))
			{
				num = 1;
				if (EasyTouch.GetSecondeFingerSimulation())
				{
					if (Input.GetKey(KeyCode.LeftAlt) || Input.GetKey(EasyTouch.instance.twistKey) || Input.GetKey(KeyCode.LeftControl) || Input.GetKey(EasyTouch.instance.swipeKey))
					{
						num = 2;
					}
					if (Input.GetKeyUp(KeyCode.LeftAlt) || Input.GetKeyUp(EasyTouch.instance.twistKey) || Input.GetKeyUp(KeyCode.LeftControl) || Input.GetKeyUp(EasyTouch.instance.swipeKey))
					{
						num = 2;
					}
				}
				if (num == 0)
				{
					complexCenter = Vector2.zero;
					oldMousePosition[0] = new Vector2(-1f, -1f);
					oldMousePosition[1] = new Vector2(-1f, -1f);
				}
			}
			return num;
		}

		public Finger GetMouseTouch(int fingerIndex, Finger myFinger)
		{
			Finger finger;
			if (myFinger != null)
			{
				finger = myFinger;
			}
			else
			{
				finger = new Finger();
				finger.gesture = EasyTouch.GestureType.None;
			}
			if (fingerIndex == 1 && (Input.GetKeyUp(KeyCode.LeftAlt) || Input.GetKeyUp(EasyTouch.instance.twistKey) || Input.GetKeyUp(KeyCode.LeftControl) || Input.GetKeyUp(EasyTouch.instance.swipeKey)))
			{
				finger.fingerIndex = fingerIndex;
				finger.position = oldFinger2Position;
				finger.deltaPosition = finger.position - oldFinger2Position;
				finger.tapCount = tapCount[fingerIndex];
				finger.deltaTime = Time.realtimeSinceStartup - deltaTime[fingerIndex];
				finger.phase = UnityEngine.TouchPhase.Ended;
				return finger;
			}
			if (Input.GetMouseButton(0))
			{
				finger.fingerIndex = fingerIndex;
				finger.position = GetPointerPosition(fingerIndex);
				if ((double)(Time.realtimeSinceStartup - tapeTime[fingerIndex]) > 0.5)
				{
					tapCount[fingerIndex] = 0;
				}
				if (Input.GetMouseButtonDown(0) || (fingerIndex == 1 && (Input.GetKeyDown(KeyCode.LeftAlt) || Input.GetKeyDown(EasyTouch.instance.twistKey) || Input.GetKeyDown(KeyCode.LeftControl) || Input.GetKeyDown(EasyTouch.instance.swipeKey))))
				{
					finger.position = GetPointerPosition(fingerIndex);
					finger.deltaPosition = Vector2.zero;
					tapCount[fingerIndex]++;
					finger.tapCount = tapCount[fingerIndex];
					startActionTime[fingerIndex] = Time.realtimeSinceStartup;
					deltaTime[fingerIndex] = startActionTime[fingerIndex];
					finger.deltaTime = 0f;
					finger.phase = UnityEngine.TouchPhase.Began;
					if (fingerIndex == 1)
					{
						oldFinger2Position = finger.position;
						oldMousePosition[fingerIndex] = finger.position;
					}
					else
					{
						oldMousePosition[fingerIndex] = finger.position;
					}
					if (tapCount[fingerIndex] == 1)
					{
						tapeTime[fingerIndex] = Time.realtimeSinceStartup;
					}
					return finger;
				}
				finger.deltaPosition = finger.position - oldMousePosition[fingerIndex];
				finger.tapCount = tapCount[fingerIndex];
				finger.deltaTime = Time.realtimeSinceStartup - deltaTime[fingerIndex];
				if (finger.deltaPosition.sqrMagnitude < 1f)
				{
					finger.phase = UnityEngine.TouchPhase.Stationary;
				}
				else
				{
					finger.phase = UnityEngine.TouchPhase.Moved;
				}
				oldMousePosition[fingerIndex] = finger.position;
				deltaTime[fingerIndex] = Time.realtimeSinceStartup;
				return finger;
			}
			if (Input.GetMouseButtonUp(0))
			{
				finger.fingerIndex = fingerIndex;
				finger.position = GetPointerPosition(fingerIndex);
				finger.deltaPosition = finger.position - oldMousePosition[fingerIndex];
				finger.tapCount = tapCount[fingerIndex];
				finger.deltaTime = Time.realtimeSinceStartup - deltaTime[fingerIndex];
				finger.phase = UnityEngine.TouchPhase.Ended;
				oldMousePosition[fingerIndex] = finger.position;
				return finger;
			}
			return null;
		}

		public Vector2 GetSecondFingerPosition()
		{
			Vector2 result = new Vector2(-1f, -1f);
			if ((Input.GetKey(KeyCode.LeftAlt) || Input.GetKey(EasyTouch.instance.twistKey)) && (Input.GetKey(KeyCode.LeftControl) || Input.GetKey(EasyTouch.instance.swipeKey)))
			{
				if (!bComplex)
				{
					bComplex = true;
					deltaFingerPosition = (Vector2)Input.mousePosition - oldFinger2Position;
				}
				return GetComplex2finger();
			}
			if (Input.GetKey(KeyCode.LeftAlt) || Input.GetKey(EasyTouch.instance.twistKey))
			{
				result = GetPinchTwist2Finger();
				bComplex = false;
				return result;
			}
			if (Input.GetKey(KeyCode.LeftControl) || Input.GetKey(EasyTouch.instance.swipeKey))
			{
				result = GetComplex2finger();
				bComplex = false;
				return result;
			}
			return result;
		}

		private Vector2 GetPointerPosition(int index)
		{
			if (index == 0)
			{
				return Input.mousePosition;
			}
			return GetSecondFingerPosition();
		}

		private Vector2 GetPinchTwist2Finger(bool newSim = false)
		{
			Vector2 result = default(Vector2);
			if (complexCenter == Vector2.zero)
			{
				result.x = (float)UnityEngine.Screen.width / 2f - (Input.mousePosition.x - (float)UnityEngine.Screen.width / 2f);
				result.y = (float)UnityEngine.Screen.height / 2f - (Input.mousePosition.y - (float)UnityEngine.Screen.height / 2f);
			}
			else
			{
				result.x = complexCenter.x - (Input.mousePosition.x - complexCenter.x);
				result.y = complexCenter.y - (Input.mousePosition.y - complexCenter.y);
			}
			oldFinger2Position = result;
			return result;
		}

		private Vector2 GetComplex2finger()
		{
			Vector2 result = default(Vector2);
			result.x = Input.mousePosition.x - deltaFingerPosition.x;
			result.y = Input.mousePosition.y - deltaFingerPosition.y;
			complexCenter = new Vector2((Input.mousePosition.x + result.x) / 2f, (Input.mousePosition.y + result.y) / 2f);
			oldFinger2Position = result;
			return result;
		}
	}
	[Serializable]
	public class ECamera
	{
		public Camera camera;

		public bool guiCamera;

		public ECamera(Camera cam, bool gui)
		{
			camera = cam;
			guiCamera = gui;
		}
	}
	public class Finger : BaseFinger
	{
		public float startTimeAction;

		public Vector2 oldPosition;

		public int tapCount;

		public UnityEngine.TouchPhase phase;

		public EasyTouch.GestureType gesture;

		public EasyTouch.SwipeDirection oldSwipeType;
	}
	public class Gesture : BaseFinger, ICloneable
	{
		public EasyTouch.SwipeDirection swipe;

		public float swipeLength;

		public Vector2 swipeVector;

		public float deltaPinch;

		public float twistAngle;

		public float twoFingerDistance;

		public EasyTouch.EvtType type;

		public object Clone()
		{
			return MemberwiseClone();
		}

		public Vector3 GetTouchToWorldPoint(float z)
		{
			return Camera.main.ScreenToWorldPoint(new Vector3(position.x, position.y, z));
		}

		public Vector3 GetTouchToWorldPoint(Vector3 position3D)
		{
			return Camera.main.ScreenToWorldPoint(new Vector3(position.x, position.y, Camera.main.transform.InverseTransformPoint(position3D).z));
		}

		public float GetSwipeOrDragAngle()
		{
			return Mathf.Atan2(swipeVector.normalized.y, swipeVector.normalized.x) * 57.29578f;
		}

		public Vector2 NormalizedPosition()
		{
			return new Vector2(100f / (float)UnityEngine.Screen.width * position.x / 100f, 100f / (float)UnityEngine.Screen.height * position.y / 100f);
		}

		public bool IsOverUIElement()
		{
			return EasyTouch.IsFingerOverUIElement(fingerIndex);
		}

		public bool IsOverRectTransform(RectTransform tr, Camera camera = null)
		{
			if (camera == null)
			{
				return RectTransformUtility.RectangleContainsScreenPoint(tr, position, null);
			}
			return RectTransformUtility.RectangleContainsScreenPoint(tr, position, camera);
		}

		public GameObject GetCurrentFirstPickedUIElement(bool isTwoFinger = false)
		{
			return EasyTouch.GetCurrentPickedUIElement(fingerIndex, isTwoFinger);
		}

		public GameObject GetCurrentPickedObject(bool isTwoFinger = false)
		{
			return EasyTouch.GetCurrentPickedObject(fingerIndex, isTwoFinger);
		}
	}
	public class TwoFingerGesture
	{
		public EasyTouch.GestureType currentGesture = EasyTouch.GestureType.None;

		public EasyTouch.GestureType oldGesture = EasyTouch.GestureType.None;

		public int finger0;

		public int finger1;

		public float startTimeAction;

		public float timeSinceStartAction;

		public Vector2 startPosition;

		public Vector2 position;

		public Vector2 deltaPosition;

		public Vector2 oldStartPosition;

		public float startDistance;

		public float fingerDistance;

		public float oldFingerDistance;

		public bool lockPinch;

		public bool lockTwist = true;

		public float lastPinch;

		public float lastTwistAngle;

		public GameObject pickedObject;

		public GameObject oldPickedObject;

		public Camera pickedCamera;

		public bool isGuiCamera;

		public bool isOverGui;

		public GameObject pickedUIElement;

		public bool dragStart;

		public bool swipeStart;

		public bool inSingleDoubleTaps;

		public float tapCurentTime;

		public void ClearPickedObjectData()
		{
			pickedObject = null;
			oldPickedObject = null;
			pickedCamera = null;
			isGuiCamera = false;
		}

		public void ClearPickedUIData()
		{
			isOverGui = false;
			pickedUIElement = null;
		}
	}
}
