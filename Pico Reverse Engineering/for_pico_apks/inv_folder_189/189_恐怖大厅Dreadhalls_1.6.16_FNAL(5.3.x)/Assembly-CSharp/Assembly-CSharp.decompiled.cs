using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Serialization.Formatters.Binary;
using System.Security;
using System.Security.Permissions;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using AOT;
using BoundarySystem_Ext;
using LitJson;
using MapBrushes;
using MapTags;
using OvrTouch.Controllers;
using Pvr_UnitySDKAPI;
using Pvr_UnitySDKAPI.Achievement;
using Triangulator.Geometry;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.Experimental.Rendering;
using UnityEngine.Rendering;
using UnityEngine.UI;
using UnityEngine.XR;

[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: SecurityPermission(SecurityAction.RequestMinimum, SkipVerification = true)]
[assembly: AssemblyVersion("0.0.0.0")]
[module: UnverifiableCode]
public class FixedTileBorders : MonoBehaviour
{
	public float innerWidth = 0.2f;

	public float innerHeight = 0.2f;

	public float borderWidth = 0.2f;

	public float borderHeight = 0.2f;

	public float innerborderWidth = 0.2f;

	public float innerborderHeight = 0.2f;

	public float textureBorderWidth = 0.2f;

	public float textureBorderHeight = 0.2f;

	public float textureInnerBorderWidth = 0.2f;

	public float textureInnerBorderHeight = 0.2f;

	public float textureInnerWidth = 0.2f;

	public float textureInnerHeight = 0.2f;

	public float xOffset;

	public float yOffset;

	private void Start()
	{
		Mesh mesh = new Mesh();
		Vector3[] vertices = SetVertices();
		mesh.vertices = vertices;
		int[] triangles = new int[150]
		{
			0, 1, 2, 3, 2, 1, 1, 4, 3, 6,
			3, 4, 4, 5, 6, 7, 6, 5, 5, 8,
			7, 10, 7, 8, 8, 9, 10, 11, 10, 9,
			2, 3, 12, 13, 12, 3, 3, 6, 13, 16,
			13, 6, 6, 7, 16, 17, 16, 7, 7, 10,
			17, 20, 17, 10, 10, 11, 20, 21, 20, 11,
			12, 13, 14, 15, 14, 13, 13, 16, 15, 18,
			15, 16, 16, 17, 18, 19, 18, 17, 17, 20,
			19, 22, 19, 20, 20, 21, 22, 23, 22, 21,
			14, 15, 24, 25, 24, 15, 15, 18, 25, 28,
			25, 18, 18, 19, 28, 29, 28, 19, 19, 22,
			29, 32, 29, 22, 22, 23, 32, 33, 32, 23,
			24, 25, 26, 27, 26, 25, 25, 28, 27, 30,
			27, 28, 28, 29, 30, 31, 30, 29, 29, 32,
			31, 34, 31, 32, 32, 33, 34, 35, 34, 33
		};
		mesh.triangles = triangles;
		mesh.uv = new Vector2[36]
		{
			new Vector2(0f, 1f),
			new Vector2(textureBorderWidth, 1f),
			new Vector2(0f, textureBorderHeight + 2f * textureInnerHeight + textureInnerBorderHeight),
			new Vector2(textureBorderWidth, 1f - textureBorderHeight),
			new Vector2(textureBorderWidth + textureInnerWidth, 1f),
			new Vector2(textureBorderWidth + textureInnerWidth + textureInnerBorderWidth, 1f),
			new Vector2(textureBorderWidth + textureInnerWidth, 1f - textureBorderHeight),
			new Vector2(textureBorderWidth + textureInnerWidth + textureInnerBorderWidth, 1f - textureBorderHeight),
			new Vector2(textureBorderWidth + textureInnerWidth * 2f + textureInnerBorderWidth, 1f),
			new Vector2(1f, 1f),
			new Vector2(textureBorderWidth + textureInnerWidth * 2f + textureInnerBorderWidth, 1f - textureBorderHeight),
			new Vector2(1f, 1f - textureBorderHeight),
			new Vector2(0f, 1f - textureBorderHeight - textureInnerHeight),
			new Vector2(textureBorderWidth, 1f - textureBorderHeight - textureInnerHeight),
			new Vector2(0f, textureBorderHeight + textureInnerHeight),
			new Vector2(textureBorderWidth, textureBorderHeight + textureInnerHeight),
			new Vector2(textureBorderWidth + textureInnerWidth, 1f - textureBorderHeight - textureInnerHeight),
			new Vector2(textureBorderWidth + textureInnerWidth + textureInnerBorderWidth, 1f - textureBorderHeight - textureInnerHeight),
			new Vector2(textureBorderWidth + textureInnerWidth, textureBorderHeight + textureInnerHeight),
			new Vector2(textureBorderWidth + textureInnerWidth + textureInnerBorderWidth, textureBorderHeight + textureInnerHeight),
			new Vector2(textureBorderWidth + textureInnerWidth * 2f + textureInnerBorderWidth, 1f - textureBorderHeight - textureInnerHeight),
			new Vector2(1f, 1f - textureBorderHeight - textureInnerHeight),
			new Vector2(textureBorderWidth + textureInnerWidth * 2f + textureInnerBorderWidth, textureBorderHeight + textureInnerHeight),
			new Vector2(1f, 1f - textureBorderHeight - textureInnerHeight - textureInnerBorderHeight),
			new Vector2(0f, textureBorderHeight),
			new Vector2(textureBorderWidth, textureBorderHeight),
			new Vector2(0f, 0f),
			new Vector2(textureBorderWidth, 0f),
			new Vector2(textureBorderWidth + textureInnerWidth, textureBorderHeight),
			new Vector2(textureBorderWidth + textureInnerWidth + textureInnerBorderWidth, textureBorderHeight),
			new Vector2(textureBorderWidth + textureInnerWidth, 0f),
			new Vector2(textureBorderWidth + textureInnerWidth + textureInnerBorderWidth, 0f),
			new Vector2(textureBorderWidth + textureInnerWidth * 2f + textureInnerBorderWidth, textureBorderHeight),
			new Vector2(1f, textureBorderHeight),
			new Vector2(textureBorderWidth + textureInnerWidth * 2f + textureInnerBorderWidth, 0f),
			new Vector2(1f, 0f)
		};
		Vector3[] array = new Vector3[36];
		for (int i = 0; i < 36; i++)
		{
			ref Vector3 reference = ref array[i];
			reference = Vector3.forward;
		}
		mesh.normals = array;
		GetComponent<MeshFilter>().mesh = mesh;
		if ((bool)GetComponent<MeshCollider>())
		{
			GetComponent<MeshCollider>().sharedMesh = GetComponent<MeshFilter>().mesh;
		}
	}

	private void Update()
	{
	}

	private Vector3[] SetVertices()
	{
		return new Vector3[36]
		{
			new Vector3(xOffset, yOffset, 0f),
			new Vector3(borderWidth + xOffset, yOffset, 0f),
			new Vector3(xOffset, borderHeight + yOffset, 0f),
			new Vector3(borderWidth + xOffset, borderHeight + yOffset, 0f),
			new Vector3(borderWidth + innerWidth + xOffset, yOffset, 0f),
			new Vector3(borderWidth + innerWidth + innerborderWidth + xOffset, yOffset, 0f),
			new Vector3(borderWidth + innerWidth + xOffset, borderHeight + yOffset, 0f),
			new Vector3(borderWidth + innerWidth + innerborderWidth + xOffset, borderHeight + yOffset, 0f),
			new Vector3(borderWidth + innerborderWidth + innerWidth * 2f + xOffset, yOffset, 0f),
			new Vector3(borderWidth * 2f + innerborderWidth + innerWidth * 2f + xOffset, yOffset, 0f),
			new Vector3(borderWidth + innerborderWidth + innerWidth * 2f + xOffset, borderHeight + yOffset, 0f),
			new Vector3(borderWidth * 2f + innerborderWidth + innerWidth * 2f + xOffset, borderHeight + yOffset, 0f),
			new Vector3(xOffset, borderHeight + innerHeight + yOffset, 0f),
			new Vector3(borderWidth + xOffset, borderHeight + innerHeight + yOffset, 0f),
			new Vector3(xOffset, borderHeight + innerHeight + innerborderHeight + yOffset, 0f),
			new Vector3(borderWidth + xOffset, borderHeight + innerHeight + innerborderHeight + yOffset, 0f),
			new Vector3(borderWidth + innerWidth + xOffset, borderHeight + innerHeight + yOffset, 0f),
			new Vector3(borderWidth + innerWidth + innerborderWidth + xOffset, borderHeight + innerHeight + yOffset, 0f),
			new Vector3(borderWidth + innerWidth + xOffset, borderHeight + innerHeight + innerborderHeight + yOffset, 0f),
			new Vector3(borderWidth + innerWidth + innerborderWidth + xOffset, borderHeight + innerHeight + innerborderHeight + yOffset, 0f),
			new Vector3(borderWidth + innerborderWidth + innerWidth * 2f + xOffset, borderHeight + innerHeight + yOffset, 0f),
			new Vector3(borderWidth * 2f + innerborderWidth + innerWidth * 2f + xOffset, borderHeight + innerHeight + yOffset, 0f),
			new Vector3(borderWidth + innerborderWidth + innerWidth * 2f + xOffset, borderHeight + innerHeight + innerborderHeight + yOffset, 0f),
			new Vector3(borderWidth * 2f + innerborderWidth + innerWidth * 2f + xOffset, borderHeight + innerHeight + innerborderHeight + yOffset, 0f),
			new Vector3(xOffset, borderHeight + innerHeight * 2f + innerborderHeight + yOffset, 0f),
			new Vector3(borderWidth + xOffset, borderHeight + innerHeight * 2f + innerborderHeight + yOffset, 0f),
			new Vector3(xOffset, borderHeight * 2f + innerHeight * 2f + innerborderHeight + yOffset, 0f),
			new Vector3(borderWidth + xOffset, borderHeight * 2f + innerHeight * 2f + innerborderHeight + yOffset, 0f),
			new Vector3(borderWidth + innerWidth + xOffset, borderHeight + innerHeight * 2f + innerborderHeight + yOffset, 0f),
			new Vector3(borderWidth + innerWidth + innerborderWidth + xOffset, borderHeight + innerHeight * 2f + innerborderHeight + yOffset, 0f),
			new Vector3(borderWidth + innerWidth + xOffset, borderHeight * 2f + innerHeight * 2f + innerborderHeight + yOffset, 0f),
			new Vector3(borderWidth + innerWidth + innerborderWidth + xOffset, borderHeight * 2f + innerHeight * 2f + innerborderHeight + yOffset, 0f),
			new Vector3(borderWidth + innerborderWidth + innerWidth * 2f + xOffset, borderHeight + innerHeight * 2f + innerborderHeight + yOffset, 0f),
			new Vector3(borderWidth * 2f + innerborderWidth + innerWidth * 2f + xOffset, borderHeight + innerHeight * 2f + innerborderHeight + yOffset, 0f),
			new Vector3(borderWidth + innerborderWidth + innerWidth * 2f + xOffset, borderHeight * 2f + innerHeight * 2f + innerborderHeight + yOffset, 0f),
			new Vector3(borderWidth * 2f + innerborderWidth + innerWidth * 2f + xOffset, borderHeight * 2f + innerHeight * 2f + innerborderHeight + yOffset, 0f)
		};
	}
}
public class OptionsMenuController : TimeIndependentBehaviour
{
	private TextMesh volumeValue;

	private TextMesh musicVolumeValue;

	private TextMesh languageValue;

	private UIButton3D comfortToggle;

	private UIButton3D tankModeToggle;

	private UIButton3D tutorialToggle;

	private UIButton3D touchButton;

	private bool changedTouchValues;

	private bool touchLeftHanded;

	private bool touchEnabled;

	private string[] validLanguages;

	private int languageIndex;

	private bool reposition;

	private Vector3 oldPos;

	private Quaternion oldRot;

	private void Start()
	{
		UIDreadHallsMenu component = GetComponent<UIDreadHallsMenu>();
		volumeValue = base.transform.Find("text_volume_value").GetComponent<TextMesh>();
		musicVolumeValue = base.transform.Find("text_musicvolume_value").GetComponent<TextMesh>();
		languageValue = base.transform.Find("text_language_value").GetComponent<TextMesh>();
		int num = Mathf.RoundToInt(Config.Audio().masterVolume * 10f) * 10;
		volumeValue.text = num.ToString();
		int num2 = Mathf.RoundToInt(Config.Audio().musicVolume * 10f) * 10;
		musicVolumeValue.text = num2.ToString();
		languageValue.text = Translate.Get("LANGUAGE");
		validLanguages = Translate.ListLanguages();
		string language = Translate.GetLanguage();
		languageIndex = 0;
		while (languageIndex < validLanguages.Length && !(validLanguages[languageIndex] == language))
		{
			languageIndex++;
		}
		component.GetButton("button_volume_left").SetAction(OnVolumeLeftArrow);
		component.GetButton("button_volume_right").SetAction(OnVolumeRightArrow);
		component.GetButton("button_musicvolume_left").SetAction(OnMusicVolumeLeftArrow);
		component.GetButton("button_musicvolume_right").SetAction(OnMusicVolumeRightArrow);
		component.GetButton("button_language_left").SetAction(OnLanguageLeftArrow);
		component.GetButton("button_language_right").SetAction(OnLanguageRightArrow);
		comfortToggle = component.GetButton("button_comfort");
		comfortToggle.SetAction(OnButtonComfort);
		comfortToggle.text = ((!Config.Input().comfortRotation) ? Translate.Get("MENU_NO") : Translate.Get("MENU_YES"));
		tankModeToggle = component.GetButton("button_tankmode");
		tankModeToggle.SetAction(OnButtonTankMode);
		tankModeToggle.initialText = (Config.Input().tankMode ? "MENU_NO" : "MENU_YES");
		tankModeToggle.text = Translate.Get(tankModeToggle.initialText);
		tutorialToggle = component.GetButton("button_tutorials");
		tutorialToggle.SetAction(OnButtonTutorials);
		tutorialToggle.text = ((!Config.General().tutorials) ? Translate.Get("MENU_NO") : Translate.Get("MENU_YES"));
		touchButton = component.GetButton("button_touch");
		touchButton.SetAction(OnButtonTouch);
		changedTouchValues = false;
		touchLeftHanded = Config.Input().leftHanded;
		touchEnabled = InputExt.UsingHandControllers;
		string buttonTouchTextKey = GetButtonTouchTextKey();
		touchButton.initialText = buttonTouchTextKey;
		touchButton.text = Translate.Get(buttonTouchTextKey);
		component.OnShowAction = OnShow;
		if (!GameController.Get().IsInGameScene())
		{
			component.OnHideAction = OnHide;
		}
	}

	private void OnShow()
	{
		changedTouchValues = false;
		touchLeftHanded = Config.Input().leftHanded;
		touchEnabled = InputExt.UsingHandControllers;
		string buttonTouchTextKey = GetButtonTouchTextKey();
		touchButton.initialText = buttonTouchTextKey;
		touchButton.text = Translate.Get(buttonTouchTextKey);
	}

	private void OnHide()
	{
		ApplyTouchChanges();
	}

	private new void Update()
	{
		if (reposition)
		{
			base.transform.position = oldPos;
			base.transform.rotation = oldRot;
			reposition = false;
		}
	}

	private void OnVolumeLeftArrow()
	{
		Config.Audio().masterVolume = OnButtonArrow(Config.Audio().masterVolume, volumeValue, -10);
		GameController.Get().UpdateAudioVolume();
		Config.Save();
	}

	private void OnVolumeRightArrow()
	{
		Config.Audio().masterVolume = OnButtonArrow(Config.Audio().masterVolume, volumeValue);
		GameController.Get().UpdateAudioVolume();
		Config.Save();
	}

	private void OnMusicVolumeLeftArrow()
	{
		Config.Audio().musicVolume = OnButtonArrow(Config.Audio().musicVolume, musicVolumeValue, -10);
		GameController.Get().UpdateAudioVolume();
		Config.Save();
	}

	private void OnMusicVolumeRightArrow()
	{
		Config.Audio().musicVolume = OnButtonArrow(Config.Audio().musicVolume, musicVolumeValue);
		GameController.Get().UpdateAudioVolume();
		Config.Save();
	}

	private void OnLanguageLeftArrow()
	{
		languageIndex--;
		if (languageIndex < 0)
		{
			languageIndex = validLanguages.Length - 1;
		}
		GameController.SetLanguage(validLanguages[languageIndex]);
		languageValue.text = Translate.Get("LANGUAGE");
	}

	private void OnLanguageRightArrow()
	{
		languageIndex++;
		if (languageIndex >= validLanguages.Length)
		{
			languageIndex = 0;
		}
		GameController.SetLanguage(validLanguages[languageIndex]);
		languageValue.text = Translate.Get("LANGUAGE");
	}

	private void OnButtonComfort()
	{
		Config.Input().comfortRotation = OnCheckbox(Config.Input().comfortRotation, comfortToggle);
		GameController.Get().UpdateInput();
		Config.Save();
	}

	private void OnButtonTankMode()
	{
		Config.Input().tankMode = !OnCheckbox(!Config.Input().tankMode, tankModeToggle);
		oldPos = base.transform.position;
		oldRot = base.transform.rotation;
		reposition = true;
		GameController.Get().UpdateInput();
		Config.Save();
	}

	private void OnButtonTutorials()
	{
		Config.General().tutorials = OnCheckbox(Config.General().tutorials, tutorialToggle);
		Config.Save();
	}

	public bool ApplyTouchChanges()
	{
		if (changedTouchValues)
		{
			Config.Input().leftHanded = touchLeftHanded;
			Config.Save();
			if (!GameController.Get().IsInGameScene())
			{
				Player.ResetPlayerHands();
				Debug.Log("Re-Loading Intro scene");
				Application.LoadLevel("Intro");
				return true;
			}
			return true;
		}
		return false;
	}

	private void OnButtonTouch()
	{
		if (InputExt.HasHandControllers)
		{
			touchEnabled = true;
			touchLeftHanded = !touchLeftHanded;
			changedTouchValues = true;
		}
		string buttonTouchTextKey = GetButtonTouchTextKey();
		touchButton.initialText = buttonTouchTextKey;
		touchButton.text = Translate.Get(buttonTouchTextKey);
	}

	private string GetButtonTouchTextKey()
	{
		if (!InputExt.HasHandControllers)
		{
			return "MENU_OPTIONS_TOUCH_NONE";
		}
		if (!touchEnabled)
		{
			return "MENU_OPTIONS_TOUCH_DISABLED";
		}
		return (!touchLeftHanded) ? "MENU_OPTIONS_TOUCH_RH" : "MENU_OPTIONS_TOUCH_LH";
	}

	private float OnButtonArrow(float curValue, TextMesh tMesh, int step = 10)
	{
		int num = Mathf.RoundToInt(curValue * 10f) * 10;
		num = Mathf.Clamp(num + step, 0, 100);
		curValue = (float)num / 100f;
		tMesh.text = num.ToString();
		return curValue;
	}

	private int OnButtonArrow(int curValue, TextMesh tMesh, int min, int max, int step = 1)
	{
		int result = Mathf.Clamp(curValue + step, min, max);
		tMesh.text = result.ToString();
		return result;
	}

	private bool OnCheckbox(bool curValue, UIButton3D but)
	{
		curValue = !curValue;
		but.initialText = ((!curValue) ? "MENU_NO" : "MENU_YES");
		but.text = ((!curValue) ? Translate.Get("MENU_NO") : Translate.Get("MENU_YES"));
		return curValue;
	}
}
public class PauseMenuController : TimeIndependentBehaviour
{
	public UIMenuStack pauseMenuStack;

	public UICrosshair3D crosshair;

	public LocalizedTexture controlTextures;

	public GameObject controlsFramePad;

	public GameObject controlsFrameOculusGoPad;

	public GameObject controlsFrameGearVR3DOF;

	public GameObject controlsFrameOculusGo3DOF;

	public GameObject controlsFrameTouchRight;

	public GameObject controlsFrameTouchLeft;

	private UIButton3DList pauseButtons;

	private bool showing;

	private bool skipInput;

	public AntiBodyDelta antiDelta;

	private void Start()
	{
		showing = true;
		UIDreadHallsMenu menu = pauseMenuStack.GetMenu("PauseMenu");
		pauseButtons = menu.transform.Find("ButtonList").GetComponent<UIButton3DList>();
		menu.GetButton("button_resume").SetAction(OnButtonResume);
		menu.GetButton("button_controls").SetAction(OnButtonControls);
		menu.GetButton("button_options").SetAction(OnButtonOptions);
		menu.GetButton("button_back").SetAction(OnButtonBack);
		menu.SetOnBackAction(OnButtonResume, applyToHeadset: false);
		menu.SetOnHeadsetBackAction(OnButtonHome);
		UIDreadHallsMenu menu2 = pauseMenuStack.GetMenu("ControlsMenu");
		menu2.SetOnBackAction(OnBackToPauseMenu);
		UIDreadHallsMenu menu3 = pauseMenuStack.GetMenu("OptionsMenu");
		menu3.SetOnBackAction(OnOptionsBackToPauseMenu);
		menu3.GetButton("button_back").SetAction(OnOptionsBackToPauseMenu);
		controlTextures.enabled = true;
		crosshair.gameObject.SetActive(value: false);
	}

	protected override void OnEnable()
	{
		base.OnEnable();
	}

	private void OnDisable()
	{
	}

	protected new void Update()
	{
		base.Update();
		bool backButtonDown = GameController.GetBackButtonDown();
		bool buttonDown = InputExt.GetButtonDown(InputExt.Button.Start);
		if (!skipInput && buttonDown)
		{
			if (!GameController.Get().Paused && !showing)
			{
				GameController.Get().EnterPause();
			}
			else if (showing)
			{
				GameController.Get().ExitPause();
			}
		}
		if (!skipInput && backButtonDown && !GameController.Get().Paused)
		{
			GameController.Get().EnterPause();
		}
		if (GameController.Get().Paused != showing)
		{
			ShowMenu(GameController.Get().Paused);
		}
		skipInput = false;
	}

	private void LostFocus()
	{
		SetFocus(focusStatus: false);
	}

	private void AcquiredFocus()
	{
		SetFocus(focusStatus: true);
	}

	private void SetFocus(bool focusStatus)
	{
		Debug.Log((!focusStatus) ? "PMC - Application lost focus" : "PMC - Application has focus");
		if (!focusStatus && !GameController.Get().Paused)
		{
			GameController.Get().EnterPause();
		}
	}

	private void ShowMenu(bool show)
	{
		showing = show;
		if (show)
		{
			if (antiDelta != null)
			{
				antiDelta.enabled = true;
			}
			pauseMenuStack.ShowMenu("PauseMenu");
			pauseButtons.ResetButtons();
		}
		else
		{
			pauseMenuStack.CloseMenu();
			if (antiDelta != null)
			{
				antiDelta.enabled = false;
			}
		}
		crosshair.gameObject.SetActive(show);
		DarkenTutorials(show);
	}

	private void DarkenTutorials(bool darken)
	{
		GameObject[] array = GameObject.FindGameObjectsWithTag(Tags.TutorialUI);
		for (int i = 0; i < array.Length; i++)
		{
			TextLabel component = array[i].GetComponent<TextLabel>();
			if (component != null)
			{
				component.SetDarkened(darken);
			}
		}
	}

	private void OnButtonResume()
	{
		GameController.Get().ExitPause();
		if (GameController.Get().Paused != showing)
		{
			ShowMenu(GameController.Get().Paused);
		}
		skipInput = true;
	}

	private void OnButtonControls()
	{
		if (showing)
		{
			bool active = false;
			bool active2 = false;
			bool active3 = false;
			bool active4 = !InputExt.UsingHandControllers;
			bool active5 = InputExt.UsingHandControllers && !InputExt.LeftHanded;
			bool active6 = InputExt.UsingHandControllers && InputExt.LeftHanded;
			controlsFramePad.SetActive(active);
			controlsFrameOculusGoPad.SetActive(active4);
			controlsFrameGearVR3DOF.SetActive(active2);
			controlsFrameOculusGo3DOF.SetActive(active3);
			controlsFrameTouchRight.SetActive(active5);
			controlsFrameTouchLeft.SetActive(active6);
			pauseMenuStack.ShowMenu("ControlsMenu");
		}
	}

	private void OnButtonOptions()
	{
		if (showing)
		{
			pauseMenuStack.ShowMenu("OptionsMenu");
		}
	}

	private void OnHeadsetBack()
	{
		GameController.Get().ExitGame();
	}

	private void OnBackToPauseMenu()
	{
		pauseMenuStack.ShowMenu("PauseMenu");
	}

	private void OnOptionsBackToPauseMenu()
	{
		UIDreadHallsMenu menu = pauseMenuStack.GetMenu("OptionsMenu");
		OptionsMenuController component = menu.GetComponent<OptionsMenuController>();
		if (component != null && component.ApplyTouchChanges())
		{
			pauseMenuStack.ShowMenu("Dialog").SetDialog(Translate.Get("MENU_VIDEO_CONFIRM"), Translate.Get("MENU_YES"), Translate.Get("MENU_NO"), OnConfirmBack, OnBackToPauseMenu);
		}
		else
		{
			pauseMenuStack.ShowMenu("PauseMenu");
		}
	}

	private void OnButtonBack()
	{
		if (showing)
		{
			bool flag = !GameController.Get().levelOptions.IsMetaMap();
			pauseMenuStack.ShowMenu("Dialog").SetDialog(Translate.Get((!flag) ? "MENU_GAME_CONFIRM_EXIT" : "MENU_GAME_CONFIRM_EXIT_PROGRESS"), Translate.Get("MENU_YES"), Translate.Get("MENU_NO"), OnConfirmBack, OnBackToPauseMenu);
		}
	}

	private void OnConfirmBack()
	{
		Fader component = GameObject.Find("Fader").GetComponent<Fader>();
		component.FadeOut(4f, fadeAudio: true, null, OnEndExitFade);
		pauseMenuStack.CloseMenu();
	}

	private void OnEndExitFade()
	{
		GameController.Get().ExitGame();
	}

	private void OnButtonHome()
	{
		Debug.Log("OnButtonHome");
	}

	private void OnConfirmHome()
	{
		Application.Quit();
	}
}
public class TextMeshNormals : MonoBehaviour
{
	private TextMesh textMesh;

	private void Start()
	{
		textMesh = base.transform.GetComponent<TextMesh>();
		GetComponent<Renderer>().material.mainTexture = textMesh.font.material.mainTexture;
	}

	private void Update()
	{
		GetComponent<Renderer>().material.SetVector("Text Normal", new Vector4(0f, 0f, -1f, 1f));
	}
}
public class UIButton3D : TimeIndependentBehaviour
{
	private Action buttonAction = delegate
	{
	};

	protected float progressOver;

	protected float progressPressed;

	protected bool bPressendOnCoroutine;

	public float deltaOver = 4.8f;

	public float deltaPressed = 4.8f;

	private bool bManaged;

	protected UIButton3DManager manager;

	private bool bSelected;

	protected bool hasBeenPressed;

	public Collider myCollider;

	private GameObject lookDirection;

	public int layerNumber;

	protected GameObject textObject;

	public string initialText = "Button";

	protected Color textColor;

	public Color textColorOver = Color.white;

	private bool textColorIsOver;

	public bool IsManaged
	{
		get
		{
			return bManaged;
		}
		set
		{
			bManaged = value;
		}
	}

	public UIButton3DManager Manager
	{
		set
		{
			manager = value;
		}
	}

	public bool IsSelected
	{
		get
		{
			return bSelected;
		}
		set
		{
			bSelected = value;
		}
	}

	public string text
	{
		get
		{
			return textObject.GetComponent<TextMesh>().text;
		}
		set
		{
			textObject.GetComponent<TextMesh>().text = value;
		}
	}

	private void Start()
	{
		base.gameObject.tag = "UI";
	}

	protected override void Update()
	{
		base.Update();
		bool flag = false;
		lookDirection = Player.GetLook(interaction: true).gameObject;
		if ((bool)lookDirection)
		{
			int layerMask = 1 << layerNumber;
			if (Physics.Raycast(lookDirection.transform.position, lookDirection.transform.forward, out var hitInfo, 200f, layerMask) && hitInfo.collider == myCollider)
			{
				flag = true;
			}
		}
		if (flag && (bool)manager)
		{
			flag = manager.NotifyOver(this);
		}
		bool flag2 = Input.GetMouseButtonUp(0) || InputExt.GetButtonUp(InputExt.Button.Action) || InputExt.GetButtonUp(InputExt.Button.UIAction);
		bool flag3 = Input.GetMouseButton(0) || InputExt.GetButton(InputExt.Button.Action) || InputExt.GetButton(InputExt.Button.UIAction);
		if (!hasBeenPressed && (bSelected || (flag && !bManaged)))
		{
			hasBeenPressed = Input.GetMouseButtonDown(0) || InputExt.GetButtonDown(InputExt.Button.Action) || InputExt.GetButtonDown(InputExt.Button.UIAction);
		}
		bool flag4 = hasBeenPressed;
		if (flag2 && !hasBeenPressed)
		{
			flag2 = false;
		}
		if (hasBeenPressed && !flag3)
		{
			hasBeenPressed = false;
		}
		if (!bPressendOnCoroutine && (bSelected || (flag && !bManaged)) && flag2 && flag4)
		{
			bPressendOnCoroutine = true;
			StartCoroutine(ExecutePressed());
		}
		else if (!bPressendOnCoroutine && (bSelected || (flag && !bManaged)) && flag3)
		{
			progressPressed = ((!(progressPressed + deltaPressed * base.deltaTime > 1f)) ? (progressPressed + deltaPressed * base.deltaTime) : 1f);
		}
		else if (!bPressendOnCoroutine)
		{
			progressPressed = ((!(progressPressed - deltaPressed * base.deltaTime < 0f)) ? (progressPressed - deltaPressed * base.deltaTime) : 0f);
		}
		if ((flag && !bManaged) || bSelected)
		{
			progressOver = ((!(progressOver + deltaOver * base.deltaTime > 1f)) ? (progressOver + deltaOver * base.deltaTime) : 1f);
		}
		else
		{
			progressOver = ((!(progressOver - deltaOver * base.deltaTime < 0f)) ? (progressOver - deltaOver * base.deltaTime) : 0f);
		}
		if ((flag || IsSelected) && !textColorIsOver)
		{
			SetTextColor(textColorOver);
			textColorIsOver = true;
		}
		else if (!flag && !IsSelected && textColorIsOver)
		{
			SetTextColor(textColor);
			textColorIsOver = false;
		}
	}

	public void SetAction(Action newAction)
	{
		buttonAction = newAction;
	}

	private IEnumerator ExecutePressed()
	{
		while (progressPressed < 1f)
		{
			progressPressed += deltaPressed * base.deltaTime;
			yield return null;
		}
		while (progressPressed > 0f)
		{
			progressPressed = ((!(progressPressed - deltaPressed * base.deltaTime < 0f)) ? (progressPressed - deltaPressed * base.deltaTime) : 0f);
			yield return null;
		}
		if (buttonAction != null)
		{
			buttonAction();
		}
		bPressendOnCoroutine = false;
	}

	private void SetTextColor(Color c)
	{
		float a = textObject.GetComponent<Renderer>().material.color.a;
		textObject.GetComponent<Renderer>().material.color = new Color(c.r, c.g, c.b, a);
	}

	public void RefreshText()
	{
		if (textObject != null)
		{
			text = Translate.Get(initialText);
		}
	}

	public virtual void Reset()
	{
		progressPressed = 0f;
		progressOver = 0f;
	}
}
public class UIButton3DGrid : UIButton3DManager
{
	[Serializable]
	public class Row
	{
		public List<UIButton3D> buttons = new List<UIButton3D>();
	}

	public List<Row> buttonRows;

	private int selected = -1;

	private int selectedRow = -1;

	private int lastOver = -1;

	private int lastOverRow = -1;

	private bool focusInKey;

	private bool noOver;

	private AxisEvents axisVertical = new AxisEvents("Vertical", "Vertical_btn");

	private AxisEvents axisHorizontal = new AxisEvents("Horizontal", "Horizontal_btn");

	private void Start()
	{
		for (int i = 0; i < buttonRows.Count; i++)
		{
			foreach (UIButton3D button in buttonRows[i].buttons)
			{
				button.Manager = this;
			}
		}
	}

	protected override void Update()
	{
		base.Update();
		axisVertical.Update();
		axisHorizontal.Update();
		bool flag = false;
		bool flag2 = false;
		bool flag3 = false;
		bool flag4 = false;
		flag = Input.GetKeyDown(KeyCode.DownArrow) || axisVertical.GetDownButtonDown();
		flag2 = Input.GetKeyDown(KeyCode.UpArrow) || axisVertical.GetUpButtonDown();
		flag3 = Input.GetKeyDown(KeyCode.RightArrow) || axisHorizontal.GetUpButtonDown();
		flag4 = Input.GetKeyDown(KeyCode.LeftArrow) || axisHorizontal.GetDownButtonDown();
		if (selectedRow != -1 && buttonRows[selectedRow].buttons.Count > 0 && (flag3 || flag4))
		{
			flag2 = (flag = false);
		}
		if (!focusInKey && (flag || flag2 || flag3 || flag4))
		{
			focusInKey = true;
		}
		if (flag)
		{
			if (selectedRow == -1 || selectedRow >= buttonRows.Count - 1)
			{
				selectedRow = 0;
				selected = Mathf.Clamp(selected, 0, buttonRows[selectedRow].buttons.Count - 1);
				for (int i = 0; i < buttonRows.Count; i++)
				{
					for (int j = 0; j < buttonRows[i].buttons.Count; j++)
					{
						buttonRows[i].buttons[j].IsManaged = true;
						if (i == selectedRow && j == selected)
						{
							buttonRows[i].buttons[j].IsSelected = true;
						}
						else
						{
							buttonRows[i].buttons[j].IsSelected = false;
						}
					}
				}
			}
			else
			{
				buttonRows[selectedRow].buttons[selected].IsSelected = false;
				selectedRow++;
				selected = Mathf.Clamp(selected, 0, buttonRows[selectedRow].buttons.Count - 1);
				buttonRows[selectedRow].buttons[selected].IsSelected = true;
			}
		}
		else if (flag2)
		{
			if (selectedRow == -1 || selectedRow <= 0)
			{
				selectedRow = buttonRows.Count - 1;
				selected = Mathf.Clamp(selected, 0, buttonRows[selectedRow].buttons.Count - 1);
				for (int k = 0; k < buttonRows.Count; k++)
				{
					for (int l = 0; l < buttonRows[k].buttons.Count; l++)
					{
						buttonRows[k].buttons[l].IsManaged = true;
						if (k == selectedRow && l == selected)
						{
							buttonRows[k].buttons[l].IsSelected = true;
						}
						else
						{
							buttonRows[k].buttons[l].IsSelected = false;
						}
					}
				}
			}
			else
			{
				buttonRows[selectedRow].buttons[selected].IsSelected = false;
				selectedRow--;
				selected = Mathf.Clamp(selected, 0, buttonRows[selectedRow].buttons.Count - 1);
				buttonRows[selectedRow].buttons[selected].IsSelected = true;
			}
		}
		else if (flag3 && selectedRow != -1 && selected < buttonRows[selectedRow].buttons.Count - 1 && selected != -1)
		{
			buttonRows[selectedRow].buttons[selected].IsSelected = false;
			selected++;
			buttonRows[selectedRow].buttons[selected].IsSelected = true;
		}
		else if (flag4 && selectedRow != -1 && selected > 0)
		{
			buttonRows[selectedRow].buttons[selected].IsSelected = false;
			selected--;
			buttonRows[selectedRow].buttons[selected].IsSelected = true;
		}
		if (noOver)
		{
			lastOver = -1;
		}
		noOver = true;
	}

	public override bool NotifyOver(UIButton3D button)
	{
		for (int i = 0; i < buttonRows.Count; i++)
		{
			for (int j = 0; j < buttonRows[i].buttons.Count; j++)
			{
				if (buttonRows[i].buttons[j] == button)
				{
					noOver = false;
				}
				if (buttonRows[i].buttons[j] == button && (j != lastOver || i != lastOverRow))
				{
					lastOver = j;
					lastOverRow = i;
					focusInKey = false;
					selected = j;
					selectedRow = i;
					for (int k = 0; k < buttonRows.Count; k++)
					{
						foreach (UIButton3D button2 in buttonRows[k].buttons)
						{
							button2.IsManaged = false;
							button2.IsSelected = false;
						}
					}
				}
				if (buttonRows[i].buttons[j] == button && j == lastOver && i == lastOverRow && focusInKey)
				{
					return false;
				}
			}
		}
		return true;
	}

	public override void ResetButtons()
	{
		selected = -1;
		lastOver = -1;
		focusInKey = false;
		for (int i = 0; i < buttonRows.Count; i++)
		{
			for (int j = 0; j < buttonRows[i].buttons.Count; j++)
			{
				buttonRows[i].buttons[j].Reset();
			}
		}
	}
}
public class UIButton3DList : UIButton3DManager
{
	public List<UIButton3D> buttons = new List<UIButton3D>();

	public bool horizontal;

	private int selected = -1;

	private int lastOver = -1;

	private bool focusInKey;

	private bool noOver;

	private AxisEvents axisVertical = new AxisEvents("Vertical", "Vertical_btn");

	private AxisEvents axisHorizontal = new AxisEvents("Horizontal", "Horizontal_btn");

	private void Start()
	{
		foreach (UIButton3D button in buttons)
		{
			button.Manager = this;
		}
	}

	protected override void Update()
	{
		base.Update();
		axisVertical.Update();
		axisHorizontal.Update();
		bool flag = false;
		bool flag2 = false;
		if (!horizontal)
		{
			flag = Input.GetKeyDown(KeyCode.DownArrow) || axisVertical.GetDownButtonDown();
			flag2 = Input.GetKeyDown(KeyCode.UpArrow) || axisVertical.GetUpButtonDown();
		}
		else
		{
			flag = Input.GetKeyDown(KeyCode.RightArrow) || axisHorizontal.GetUpButtonDown();
			flag2 = Input.GetKeyDown(KeyCode.LeftArrow) || axisHorizontal.GetDownButtonDown();
		}
		if (!focusInKey && (flag || flag2))
		{
			focusInKey = true;
		}
		if (flag)
		{
			if (selected == -1 || selected >= buttons.Count - 1)
			{
				for (int i = 0; i < buttons.Count; i++)
				{
					buttons[i].IsManaged = true;
					if (i == 0)
					{
						buttons[i].IsSelected = true;
					}
					else
					{
						buttons[i].IsSelected = false;
					}
				}
				selected = 0;
			}
			else
			{
				buttons[selected].IsSelected = false;
				selected++;
				buttons[selected].IsSelected = true;
			}
		}
		else if (flag2)
		{
			if (selected == -1 || selected <= 0)
			{
				for (int j = 0; j < buttons.Count; j++)
				{
					buttons[j].IsManaged = true;
					if (j == buttons.Count - 1)
					{
						buttons[j].IsSelected = true;
					}
					else
					{
						buttons[j].IsSelected = false;
					}
				}
				selected = buttons.Count - 1;
			}
			else
			{
				buttons[selected].IsSelected = false;
				selected--;
				buttons[selected].IsSelected = true;
			}
		}
		if (noOver)
		{
			lastOver = -1;
		}
		noOver = true;
	}

	public void AddButton(UIButton3D button)
	{
		buttons.Add(button);
		button.Manager = this;
	}

	public override bool NotifyOver(UIButton3D button)
	{
		for (int i = 0; i < buttons.Count; i++)
		{
			if (buttons[i] == button)
			{
				noOver = false;
			}
			if (buttons[i] == button && i != lastOver)
			{
				lastOver = i;
				focusInKey = false;
				selected = i;
				foreach (UIButton3D button2 in buttons)
				{
					button2.IsManaged = false;
					button2.IsSelected = false;
				}
			}
			if (buttons[i] == button && i == lastOver && focusInKey)
			{
				return false;
			}
		}
		return true;
	}

	public override void ResetButtons()
	{
		selected = -1;
		lastOver = -1;
		focusInKey = false;
		for (int i = 0; i < buttons.Count; i++)
		{
			buttons[i].Reset();
		}
	}
}
public class UIButton3DManager : TimeIndependentBehaviour
{
	public virtual bool NotifyOver(UIButton3D button)
	{
		return true;
	}

	public virtual void ResetButtons()
	{
	}
}
public class UICamChaser : TimeIndependentBehaviour
{
	public GameObject lookDirection;

	public GameObject centerObj;

	private Vector3 centerPos;

	public bool keepCentered = true;

	public float maxAngle = 45f;

	public float desiredDistance = 2f;

	public bool recenterOnStart;

	public bool recenterOnHMDReset;

	public bool testCollisions;

	public LayerMask collisionMask;

	public bool testCollisionsSides;

	public bool testCollisionsBetweenSides;

	public bool rotateOnCollision;

	private AntiBodyDelta antiDelta;

	private void Start()
	{
		if (lookDirection == null)
		{
			lookDirection = GameObject.FindGameObjectWithTag("LookDirection");
		}
		if (centerObj == null)
		{
			centerObj = lookDirection;
		}
		centerPos = centerObj.transform.position;
		if (recenterOnStart)
		{
			StartCoroutine(Recenter_co());
		}
		antiDelta = GetComponent<AntiBodyDelta>();
	}

	protected override void Update()
	{
		base.Update();
		if (recenterOnHMDReset && GameController.Get().HasJustRecentered)
		{
			StartCoroutine(Recenter_co());
			return;
		}
		if (keepCentered)
		{
			centerPos = centerObj.transform.position;
		}
		Vector3 forward = lookDirection.transform.forward;
		Vector3 vector = -base.transform.forward;
		Vector3 vector2 = centerPos;
		forward.y = 0f;
		vector.y = 0f;
		vector2.y = 0f;
		float num = Vector3.Angle(forward, vector);
		if (Vector3.Cross(forward, vector).y < 0f)
		{
			num = 0f - num;
		}
		if (num > maxAngle || num < 0f - maxAngle)
		{
			base.transform.RotateAround(vector2, Vector3.up, (0f - num) * base.deltaTime);
		}
		Vector3 position = base.transform.position;
		position.y = 0f;
		Vector3 vector3 = vector2 + (position - vector2).normalized * desiredDistance;
		Vector3 worldPosition = vector2;
		worldPosition.y = base.transform.position.y;
		base.transform.LookAt(worldPosition);
		vector3.y = base.transform.position.y;
		if (testCollisions)
		{
			Vector3 position2 = centerObj.transform.position;
			position2.y = vector3.y;
			Vector3 vector4 = vector3 - position2;
			float magnitude = vector4.magnitude;
			vector4.Normalize();
			float num2 = 1f;
			bool flag = false;
			float num3 = magnitude + 0.2f;
			Vector3 a = base.transform.forward;
			if (Physics.Raycast(position2, vector4, out var hitInfo, magnitude + 0.2f, collisionMask))
			{
				flag = true;
				num3 = hitInfo.distance;
				a = hitInfo.normal;
			}
			if (testCollisionsSides)
			{
				Collider component = GetComponent<Collider>();
				if (component != null)
				{
					float num4 = component.bounds.size.x;
					BoxCollider boxCollider = component as BoxCollider;
					if (boxCollider != null)
					{
						num4 = boxCollider.size.x * 0.5f * base.transform.lossyScale.x;
					}
					Vector3 direction = vector3 - base.transform.right * num4 - position2;
					Vector3 direction2 = vector3 + base.transform.right * num4 - position2;
					if (Physics.Raycast(position2, direction, out var hitInfo2, magnitude + 0.2f, collisionMask))
					{
						flag = true;
						if (hitInfo2.distance * 0.9f < num3)
						{
							num3 = hitInfo2.distance * 0.9f;
							a = hitInfo2.normal;
						}
					}
					if (Physics.Raycast(position2, direction2, out hitInfo2, magnitude + 0.2f, collisionMask))
					{
						flag = true;
						if (hitInfo2.distance * 0.9f < num3)
						{
							num3 = hitInfo2.distance * 0.9f;
							a = hitInfo2.normal;
						}
					}
					if (flag)
					{
						num2 = (num3 - 0.05f) / magnitude;
						num2 = Mathf.Clamp(num2, 0.5f, 1f);
						vector3 = position2 + vector4 * magnitude * num2;
						Vector3 vector5 = Vector3.Lerp(a, base.transform.forward, num2 * num2);
						if (rotateOnCollision)
						{
							base.transform.LookAt(base.transform.position + vector5);
						}
						flag = false;
					}
					if (testCollisionsBetweenSides)
					{
						Vector3 start = vector3 - base.transform.right * component.bounds.size.x;
						Vector3 end = vector3 + base.transform.right * component.bounds.size.x;
						if (Physics.Linecast(start, end, out hitInfo2, collisionMask))
						{
							Vector3 direction3 = hitInfo2.point - position2;
							if (Physics.Raycast(position2, direction3, out hitInfo2, magnitude + 0.2f, collisionMask))
							{
								flag = true;
								if (hitInfo2.distance * 0.9f < num3)
								{
									num3 = hitInfo2.distance * 0.8f;
									a = hitInfo2.normal;
								}
							}
						}
					}
				}
			}
			if (flag)
			{
				num2 = (num3 - 0.05f) / magnitude;
				num2 = Mathf.Clamp(num2, 0.5f, 1f);
				vector3 = position2 + vector4 * magnitude * num2;
				Vector3 vector6 = Vector3.Lerp(a, base.transform.forward, num2 * num2);
				if (rotateOnCollision)
				{
					base.transform.LookAt(base.transform.position + vector6);
				}
			}
		}
		base.transform.position = vector3;
	}

	public void Recenter()
	{
		Vector3 vector = centerObj.transform.position + lookDirection.transform.forward * desiredDistance;
		vector.y = base.transform.position.y;
		vector = centerObj.transform.position + (vector - lookDirection.transform.position).normalized * desiredDistance;
		vector.y = base.transform.position.y;
		base.transform.position = vector;
		Vector3 position = centerObj.transform.position;
		position.y = base.transform.position.y;
		base.transform.LookAt(position);
		centerPos = centerObj.transform.position;
	}

	private IEnumerator Recenter_co()
	{
		yield return 0;
		Recenter();
	}

	private new void OnEnable()
	{
		if ((bool)antiDelta)
		{
			antiDelta.enabled = true;
		}
	}

	private void OnDisable()
	{
		if ((bool)antiDelta)
		{
			antiDelta.enabled = false;
		}
	}
}
public class UIClock : TimeIndependentBehaviour
{
	public TextMesh dateMesh;

	private void Start()
	{
		if (!dateMesh)
		{
			dateMesh = GetComponent<TextMesh>();
		}
	}

	protected override void Update()
	{
		base.Update();
		if ((bool)dateMesh)
		{
			DateTime now = DateTime.Now;
			dateMesh.text = now.ToString("HH:mm:ss");
		}
	}
}
public class UICrosshair3D : TimeIndependentBehaviour
{
	public float maxDepth = 3f;

	public float offsetFromCollision = 0.1f;

	public Pvr_UnitySDKManager cameraController;

	public Transform trackedController;

	private float fadeProgress;

	public float fadeStepAmount = 0.1f;

	public bool bShow;

	public bool increaseRenderQueue;

	private void Start()
	{
		if (cameraController == null)
		{
			cameraController = UnityEngine.Object.FindObjectOfType<Pvr_UnitySDKManager>();
		}
		if (InputExt.Using3DOFController && trackedController == null)
		{
			trackedController = Player.Get3DOFController();
		}
		else if (InputExt.UsingHandControllers && trackedController == null)
		{
			trackedController = Player.GetLook(interaction: true);
		}
		if (increaseRenderQueue)
		{
			GetComponent<Renderer>().material.renderQueue = 3500;
		}
	}

	protected override void Update()
	{
		base.Update();
		Vector3 vector = -base.transform.forward;
		Transform transform;
		if (InputExt.Using3DOFController)
		{
			trackedController = Player.Get3DOFController();
			transform = trackedController.transform;
		}
		else if (InputExt.UsingHandControllers)
		{
			trackedController = Player.GetLook(interaction: true);
			transform = trackedController;
		}
		else if (InputExt.UsingGamepad)
		{
			trackedController = null;
			transform = cameraController.transform.Find("Head").transform;
		}
		else
		{
			transform = cameraController.transform.Find("Head").transform;
		}
		Vector3 position = transform.position;
		vector = transform.forward;
		Ray ray = new Ray(position, vector);
		RaycastHit[] array = Physics.RaycastAll(ray, maxDepth);
		RaycastHit raycastHit = default(RaycastHit);
		bool flag = false;
		RaycastHit[] array2 = array;
		for (int i = 0; i < array2.Length; i++)
		{
			RaycastHit raycastHit2 = array2[i];
			if (raycastHit2.collider.gameObject.tag == "UI" && (!flag || raycastHit.distance > raycastHit2.distance))
			{
				raycastHit = raycastHit2;
				flag = true;
			}
		}
		if (flag)
		{
			bShow = true;
			base.transform.position = raycastHit.point;
		}
		else
		{
			bShow = false;
			base.transform.position = position + vector * maxDepth;
		}
		base.transform.forward = vector;
		if (bShow && fadeProgress < 1f)
		{
			fadeProgress = ((!(fadeProgress + fadeStepAmount > 1f)) ? (fadeProgress + fadeStepAmount) : 1f);
		}
		else if (!bShow && fadeProgress > 0f)
		{
			fadeProgress = ((!(fadeProgress - fadeStepAmount < 0f)) ? (fadeProgress - fadeStepAmount) : 0f);
		}
		Color color = GetComponent<Renderer>().material.GetColor("_Tint");
		color.a = fadeProgress;
		GetComponent<Renderer>().material.SetColor("_Tint", color);
	}
}
public class UIDialog3D : TimeIndependentBehaviour
{
	private void Start()
	{
	}

	protected override void Update()
	{
		base.Update();
	}
}
public class UIDreadHallsButton : UIButton3D
{
	private Vector3 originalPosition;

	public float overDistance = 0.4f;

	public float pressedDistance = -0.1f;

	private BoxCollider boxCollider;

	public bool dontMoveCollider;

	public AudioClip soundOver;

	public AudioClip soundPressed;

	private bool bSoundOver = true;

	private bool bSoundPressed = true;

	private void Start()
	{
		originalPosition = base.transform.localPosition;
		if (myCollider == null)
		{
			myCollider = GetComponent<Collider>();
		}
		else if ((bool)(BoxCollider)myCollider)
		{
			boxCollider = (BoxCollider)myCollider;
			boxCollider.size = new Vector3(GetComponent<FixedTileBorders>().xOffset * -2f * base.transform.localScale.x, GetComponent<FixedTileBorders>().yOffset * -2f * base.transform.localScale.y, 0.2f * base.transform.localScale.z);
		}
		textObject = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("DUI/3DText"));
		textObject.transform.parent = base.transform;
		textObject.transform.localRotation = Quaternion.AngleAxis(180f, Vector3.up);
		textColor = textObject.GetComponent<Renderer>().material.color;
		base.text = Translate.Get(initialText);
		if (!GetComponent<Renderer>().enabled)
		{
			textObject.GetComponent<Renderer>().enabled = false;
		}
	}

	protected override void Update()
	{
		base.Update();
		Vector3 localPosition = default(Vector3);
		localPosition.x = originalPosition.x * base.transform.localScale.x;
		localPosition.y = originalPosition.y * base.transform.localScale.y;
		localPosition.z = originalPosition.z * base.transform.localScale.z + progressOver * overDistance * base.transform.localScale.z + progressPressed * pressedDistance * base.transform.localScale.z;
		base.transform.localPosition = localPosition;
		if ((bool)boxCollider)
		{
			Vector3 zero = Vector3.zero;
			if (dontMoveCollider)
			{
				boxCollider.center = Vector3.zero;
			}
			else
			{
				boxCollider.center = (0f - progressOver) * Vector3.forward * overDistance - progressPressed * Vector3.forward * (0f - pressedDistance);
			}
			zero.x = GetComponent<FixedTileBorders>().xOffset * -2f * base.transform.localScale.x;
			zero.y = GetComponent<FixedTileBorders>().yOffset * -2f * base.transform.localScale.y;
			zero.z = 0.2f * base.transform.localScale.z;
			boxCollider.size = zero;
		}
		textObject.transform.localPosition = Vector3.zero;
		textObject.transform.localScale = base.transform.localScale;
		GetComponent<Renderer>().material.SetFloat("_Value", progressOver);
		if (bSoundOver && progressOver > 0f)
		{
			bSoundOver = false;
			PlayClipAtPoint(soundOver, base.transform.position);
		}
		else if (!bSoundOver && progressOver == 0f)
		{
			bSoundOver = true;
		}
		if (bSoundPressed && progressPressed > 0f)
		{
			bSoundPressed = false;
			if (hasBeenPressed)
			{
				PlayClipAtPoint(soundPressed, base.transform.position);
			}
		}
		else if (!bSoundPressed && progressPressed == 0f && !hasBeenPressed)
		{
			bSoundPressed = true;
		}
	}

	public override void Reset()
	{
		progressPressed = 0f;
		progressOver = 0f;
		base.transform.localPosition = originalPosition;
	}
}
public class UIDreadHallsMainButton : UIButton3D
{
	private Vector3 originalPosition;

	private Vector3 originalPosOrnament;

	private Vector3 originalPosBack;

	public float overDistance = 0.4f;

	public float pressedDistance = -0.1f;

	public Vector3 overSeparation;

	public bool dontMoveCollider;

	public AudioClip soundOver;

	public AudioClip soundPressed;

	private bool bSoundOver = true;

	private bool bSoundPressed = true;

	public float soundVolume = 1f;

	public GameObject ornament;

	public GameObject background;

	public GameObject claws;

	public string textObjName = "DUI/3DText";

	public float textMargin;

	private void Start()
	{
		originalPosition = base.transform.position - ((!base.transform.parent) ? Vector3.zero : base.transform.parent.position);
		originalPosOrnament = ornament.transform.localPosition;
		originalPosBack = ornament.transform.localPosition;
		if (myCollider == null)
		{
			myCollider = GetComponent<Collider>();
		}
		else if ((bool)(BoxCollider)myCollider)
		{
			((BoxCollider)myCollider).size = background.GetComponent<Renderer>().bounds.size;
		}
		textObject = UnityEngine.Object.Instantiate(Resources.Load<GameObject>(textObjName), base.transform.position, base.transform.rotation);
		textObject.transform.Rotate(base.transform.up, 180f);
		textObject.GetComponent<TextMesh>().anchor = TextAnchor.MiddleLeft;
		textObject.transform.parent = base.transform;
		textColor = textObject.GetComponent<Renderer>().material.color;
		base.text = Translate.Get(initialText);
	}

	protected override void Update()
	{
		base.Update();
		Vector3 position = default(Vector3);
		position.x = ((!base.transform.parent) ? Vector3.zero : base.transform.parent.position).x + originalPosition.x * base.transform.localScale.x + progressOver * base.transform.forward.x * overDistance * base.transform.localScale.x + progressPressed * base.transform.forward.x * pressedDistance * base.transform.localScale.x;
		position.y = ((!base.transform.parent) ? Vector3.zero : base.transform.parent.position).y + originalPosition.y * base.transform.localScale.y + progressOver * base.transform.forward.y * overDistance * base.transform.localScale.y + progressPressed * base.transform.forward.y * pressedDistance * base.transform.localScale.y;
		position.z = ((!base.transform.parent) ? Vector3.zero : base.transform.parent.position).z + originalPosition.z * base.transform.localScale.z + progressOver * base.transform.forward.z * overDistance * base.transform.localScale.z + progressPressed * base.transform.forward.z * pressedDistance * base.transform.localScale.z;
		base.transform.position = position;
		Vector3 localPosition = default(Vector3);
		localPosition.x = originalPosOrnament.x + Mathf.Sin(progressOver * (float)Math.PI) * overSeparation.x * base.transform.localScale.x;
		localPosition.y = originalPosOrnament.y + Mathf.Sin(progressOver * (float)Math.PI) * overSeparation.y * base.transform.localScale.y;
		localPosition.z = originalPosOrnament.z + Mathf.Sin(progressOver * (float)Math.PI) * overSeparation.z * base.transform.localScale.z;
		ornament.transform.localPosition = localPosition;
		Vector3 localPosition2 = default(Vector3);
		localPosition2.x = originalPosBack.x + Mathf.Sin(progressOver * (float)Math.PI) * -1f * overSeparation.x * base.transform.localScale.x;
		localPosition2.y = originalPosBack.y + Mathf.Sin(progressOver * (float)Math.PI) * -1f * overSeparation.y * base.transform.localScale.y;
		localPosition2.z = originalPosBack.z + Mathf.Sin(progressOver * (float)Math.PI) * -1f * overSeparation.z * base.transform.localScale.z;
		background.transform.localPosition = localPosition2;
		if ((bool)(BoxCollider)myCollider)
		{
			Vector3 zero = Vector3.zero;
			if (dontMoveCollider)
			{
				((BoxCollider)myCollider).center = Vector3.zero;
			}
			else
			{
				((BoxCollider)myCollider).center = background.transform.localPosition - progressOver * Vector3.forward * overDistance - progressPressed * Vector3.forward * (0f - pressedDistance);
			}
			zero = background.GetComponent<Renderer>().bounds.size;
			if ((bool)base.transform.parent)
			{
				zero.x = background.GetComponent<Renderer>().bounds.size.x / base.transform.parent.localScale.x;
				zero.y = background.GetComponent<Renderer>().bounds.size.y / base.transform.parent.localScale.y;
			}
			zero.z = 0.3f * base.transform.localScale.z;
			((BoxCollider)myCollider).size = zero;
		}
		textObject.transform.position = base.transform.position + new Vector3(textMargin, 0f, 0f);
		textObject.transform.localScale = base.transform.localScale;
		background.GetComponent<Renderer>().material.SetFloat("_Value", progressOver);
		ornament.GetComponent<Renderer>().material.SetFloat("_Value", progressOver);
		claws.GetComponent<Renderer>().material.SetFloat("_Progress", Mathf.Sqrt(progressOver));
		if (bSoundOver && progressOver > 0f)
		{
			bSoundOver = false;
			PlayClipAtPoint(soundOver, base.transform.position, soundVolume);
		}
		else if (!bSoundOver && progressOver == 0f)
		{
			bSoundOver = true;
		}
		if (bSoundPressed && progressPressed > 0f)
		{
			bSoundPressed = false;
			if (hasBeenPressed)
			{
				PlayClipAtPoint(soundPressed, base.transform.position, soundVolume);
			}
		}
		else if (!bSoundPressed && progressPressed == 0f && !hasBeenPressed)
		{
			bSoundPressed = true;
		}
	}
}
public class UIDreadHallsMenu : UIMenu3D
{
	private bool bVisible = true;

	private GameObject lookDirection;

	private UICamChaser chaser;

	private bool waitOnDetect = true;

	public bool actionPressAsOnBack;

	private Action onBackAction;

	private Action onHeadsetBackAction;

	public bool receiveButtonEvents = true;

	public Action OnShowAction;

	public Action OnHideAction;

	public bool Visible
	{
		get
		{
			return bVisible;
		}
		set
		{
			bVisible = value;
			if (GetComponent<Renderer>() != null)
			{
				GetComponent<Renderer>().enabled = bVisible;
			}
			Renderer[] componentsInChildren = GetComponentsInChildren<Renderer>();
			for (int i = 0; i < componentsInChildren.GetLength(0); i++)
			{
				componentsInChildren[i].enabled = bVisible;
			}
			SetCollidersEnabled(bVisible);
			if (bVisible && OnShowAction != null)
			{
				OnShowAction();
			}
			if (!bVisible && OnHideAction != null)
			{
				OnHideAction();
			}
		}
	}

	private void Start()
	{
		lookDirection = Player.GetLook(interaction: true).gameObject;
		chaser = GetComponent<UICamChaser>();
		if (GetComponent<Collider>() != null && (bool)GetComponent<FixedTileBorders>())
		{
			((BoxCollider)GetComponent<Collider>()).size = new Vector3(GetComponent<FixedTileBorders>().xOffset * -2f * base.transform.localScale.x, GetComponent<FixedTileBorders>().yOffset * -2f * base.transform.localScale.y, 0.02f * base.transform.localScale.z);
		}
		Visible = false;
	}

	private new void OnEnable()
	{
		base.OnEnable();
		waitOnDetect = true;
	}

	protected override void Update()
	{
		base.Update();
		lookDirection = Player.GetLook(interaction: true).gameObject;
		if (!waitOnDetect && receiveButtonEvents)
		{
			if (GameController.GetBackButtonDown() && onHeadsetBackAction != null)
			{
				onHeadsetBackAction();
			}
			if (InputExt.GetButtonDown(InputExt.Button.Cancel) && onBackAction != null)
			{
				onBackAction();
			}
			if (actionPressAsOnBack && (Input.GetMouseButtonUp(0) || InputExt.GetButtonUp(InputExt.Button.Action) || InputExt.GetButtonUp(InputExt.Button.UIAction)) && onBackAction != null)
			{
				onBackAction();
			}
		}
		else
		{
			waitOnDetect = false;
		}
	}

	public override void LongPress()
	{
		if (!bVisible)
		{
			float num = ((!chaser) ? 2f : chaser.desiredDistance);
			Vector3 vector = lookDirection.transform.position + lookDirection.transform.forward * num;
			vector.y = base.transform.position.y;
			vector = lookDirection.transform.position + (vector - lookDirection.transform.position).normalized * num;
			base.transform.position = vector;
			base.transform.forward = lookDirection.transform.forward;
			SetVisible();
		}
		else
		{
			SetInvisible();
		}
	}

	public override void DoubleTap()
	{
		Debug.Log("DoubleTap");
	}

	public override void ShortPress()
	{
		if (Visible)
		{
			SetInvisible();
		}
	}

	public void SetVisible()
	{
		Visible = true;
	}

	public void SetInvisible()
	{
		Visible = false;
	}

	public void FadeIn()
	{
		Animator component = GetComponent<Animator>();
		component.SetInteger("FadeState", 2);
	}

	public void FadeOut()
	{
		Animator component = GetComponent<Animator>();
		component.SetInteger("FadeState", 1);
	}

	public void SetCollidersEnabled(bool enabled)
	{
		Collider[] componentsInChildren = GetComponentsInChildren<Collider>();
		for (int i = 0; i < componentsInChildren.GetLength(0); i++)
		{
			componentsInChildren[i].enabled = enabled;
		}
	}

	public void SetOnBackAction(Action newAction, bool applyToHeadset = true)
	{
		onBackAction = newAction;
		if (applyToHeadset)
		{
			onHeadsetBackAction = newAction;
		}
	}

	public void SetOnHeadsetBackAction(Action newAction)
	{
		onHeadsetBackAction = newAction;
	}

	public UIButton3D GetButton(string name)
	{
		return base.transform.Find(name).GetComponent<UIButton3D>();
	}

	public TextMesh GetText(string name)
	{
		Transform transform = base.transform.Find("main_text");
		if (transform != null)
		{
			TextMesh component = transform.GetComponent<TextMesh>();
			if (component != null)
			{
				return component;
			}
		}
		return null;
	}

	public void SetText(string elementName, string newText)
	{
		TextMesh text = GetText(elementName);
		if (text != null)
		{
			text.text = newText;
		}
	}

	public void SetTextWrap(string elementName, string newText, float wrapLimit = 1f)
	{
		TextMesh text = GetText(elementName);
		if (text != null)
		{
			text.text = Utils.WordWrap(newText, text, wrapLimit);
		}
	}

	public void SetDialog(string text, string captionYes, string captionNo, Action onYes = null, Action onNo = null)
	{
		SetText("main_text", text);
		UIButton3D button = GetButton("button_yes");
		UIButton3D button2 = GetButton("button_no");
		if (button != null)
		{
			button.text = captionYes;
			button.SetAction(onYes);
		}
		if (button2 != null)
		{
			button2.text = captionNo;
			button2.SetAction(onNo);
		}
		SetOnBackAction(onNo);
	}
}
public class UIEscapeBehaviour : TimeIndependentBehaviour
{
	public float longPressTimer = 0.75f;

	public float doubleTapTimer = 0.25f;

	private float longPressTimerProgress;

	private float doubleTapTimerProgress;

	private bool bDoubleTapping;

	public UIMenu3D menu;

	private GameObject progressCircle;

	public float progressCircleOffset = 2f;

	private GameObject lookDirection;

	private void Start()
	{
		if (!menu)
		{
			menu = UnityEngine.Object.FindObjectOfType<UIMenu3D>();
		}
		progressCircle = UnityEngine.Object.Instantiate(Resources.Load("DUI/ProgressCircle")) as GameObject;
		lookDirection = GameObject.FindGameObjectWithTag("LookDirection");
		progressCircle.GetComponent<Renderer>().material.SetFloat("-Value", 0f);
	}

	protected override void Update()
	{
		base.Update();
		progressCircle.transform.position = lookDirection.transform.position + lookDirection.transform.forward * progressCircleOffset;
		progressCircle.transform.forward = lookDirection.transform.forward;
		progressCircle.GetComponent<Renderer>().material.SetFloat("_Value", 2f * longPressTimerProgress / longPressTimer);
		if (Input.GetKeyUp(KeyCode.Escape) || InputExt.GetButtonUp(InputExt.Button.Back))
		{
			if (longPressTimerProgress > longPressTimer)
			{
				menu.LongPress();
				doubleTapTimerProgress = 0f;
			}
			else if (bDoubleTapping)
			{
				menu.DoubleTap();
				doubleTapTimerProgress = 0f;
				bDoubleTapping = false;
			}
			else
			{
				bDoubleTapping = true;
			}
			longPressTimerProgress = 0f;
		}
		else if (Input.GetKey(KeyCode.Escape) || InputExt.GetButton(InputExt.Button.Back))
		{
			longPressTimerProgress += base.deltaTime;
		}
		if (bDoubleTapping)
		{
			if (doubleTapTimerProgress > doubleTapTimer + base.deltaTime)
			{
				doubleTapTimerProgress = 0f;
				bDoubleTapping = false;
				menu.ShortPress();
			}
			else
			{
				doubleTapTimerProgress += base.deltaTime;
			}
		}
	}
}
public class UIMenu3D : TimeIndependentBehaviour
{
	private void Start()
	{
	}

	protected override void Update()
	{
		base.Update();
	}

	public virtual void LongPress()
	{
		Debug.Log("LongPress");
	}

	public virtual void DoubleTap()
	{
		Debug.Log("DoubleTap");
	}

	public virtual void ShortPress()
	{
		Debug.Log("ShortPress");
	}
}
public class UIMenuAnimator : TimeIndependentBehaviour
{
	private float progress = 1f;

	public bool fadeIn = true;

	public float speedIn = 1f;

	public float speedOut = 1f;

	public bool animateSize = true;

	private Action onEndAnim;

	public AnimationCurve curve;

	public bool multiMaterialTexts;

	private Vector3 frameScale;

	private void Start()
	{
		frameScale = base.transform.localScale;
	}

	public void FadeIn(bool reset = true, Action endAction = null)
	{
		if (reset)
		{
			progress = 0f;
		}
		fadeIn = true;
		onEndAnim = endAction;
	}

	public void FadeOut(bool reset = true, Action endAction = null)
	{
		if (reset)
		{
			progress = 1f;
		}
		fadeIn = false;
		onEndAnim = endAction;
	}

	protected new void Update()
	{
		base.Update();
		bool flag = false;
		if (fadeIn && progress < 1f)
		{
			progress += speedIn * base.deltaTime;
			flag = true;
			if (progress >= 1f && onEndAnim != null)
			{
				onEndAnim();
			}
		}
		else if (!fadeIn && progress > 0f)
		{
			progress -= speedOut * base.deltaTime;
			flag = true;
			if (progress <= 0f && onEndAnim != null)
			{
				onEndAnim();
			}
		}
		if (flag)
		{
			progress = Mathf.Clamp01(progress);
			float alpha = progress;
			float num = EvalCurve(curve, progress);
			float num2 = num;
			float num3 = num;
			float num4 = num;
			float num5 = num;
			if (animateSize)
			{
				base.transform.localScale = new Vector3(frameScale.x * num2, frameScale.y * num3, frameScale.z);
			}
			ApplyAlpha(alpha);
		}
	}

	public void ApplyAlpha(float alpha)
	{
		if (GetComponent<Renderer>() != null)
		{
			Color color = GetComponent<Renderer>().material.GetColor("_Tint");
			color.a = alpha;
			GetComponent<Renderer>().material.SetColor("_Tint", color);
		}
		Renderer[] componentsInChildren = GetComponentsInChildren<Renderer>();
		Renderer[] array = componentsInChildren;
		foreach (Renderer renderer in array)
		{
			if (renderer.material.HasProperty("_Tint"))
			{
				Color color2 = renderer.material.GetColor("_Tint");
				color2.a = alpha;
				renderer.material.SetColor("_Tint", color2);
			}
		}
		TextMesh[] componentsInChildren2 = GetComponentsInChildren<TextMesh>();
		TextMesh[] array2 = componentsInChildren2;
		foreach (TextMesh textMesh in array2)
		{
			Color color3 = textMesh.color;
			color3.a = alpha;
			textMesh.color = color3;
			if (multiMaterialTexts)
			{
				for (int k = 0; k < textMesh.GetComponent<Renderer>().materials.Length; k++)
				{
					color3 = textMesh.GetComponent<Renderer>().materials[k].color;
					color3.a = alpha;
					textMesh.GetComponent<Renderer>().materials[k].color = color3;
				}
			}
			else
			{
				color3 = textMesh.GetComponent<Renderer>().material.color;
				color3.a = alpha;
				textMesh.GetComponent<Renderer>().material.color = color3;
			}
		}
	}

	private float EvalCurve(AnimationCurve curve, float f)
	{
		float time = curve.keys[curve.length - 1].time;
		return curve.Evaluate(time * f);
	}
}
public class UIMenuStack : TimeIndependentBehaviour
{
	public UIDreadHallsMenu[] menus;

	private UIMenuAnimator[] animators;

	private int activeIdx = -1;

	private bool initClose = true;

	private List<int> toClose = new List<int>();

	public AudioClip openSound;

	public AudioClip closeSound;

	public AudioClip switchSound;

	private void Start()
	{
		animators = new UIMenuAnimator[menus.Length];
		for (int i = 0; i < menus.Length; i++)
		{
			animators[i] = menus[i].GetComponent<UIMenuAnimator>();
		}
	}

	private new void Update()
	{
		base.Update();
		if (initClose)
		{
			for (int i = 0; i < menus.Length; i++)
			{
				animators[i].ApplyAlpha(0f);
				menus[i].gameObject.SetActive(value: false);
				menus[i].receiveButtonEvents = true;
			}
			initClose = false;
		}
	}

	public UIDreadHallsMenu ShowMenu(int idx)
	{
		if (activeIdx == idx)
		{
			if (activeIdx != -1)
			{
				return menus[activeIdx];
			}
			return null;
		}
		if (activeIdx == -1 && idx != -1 && openSound != null)
		{
			PlayClipAtPoint(openSound, base.transform.position);
		}
		else if (activeIdx != -1 && idx != -1 && switchSound != null)
		{
			PlayClipAtPoint(switchSound, base.transform.position);
		}
		else if (activeIdx != -1 && idx == -1 && closeSound != null)
		{
			PlayClipAtPoint(closeSound, base.transform.position);
		}
		if (activeIdx != -1)
		{
			menus[activeIdx].receiveButtonEvents = false;
			animators[activeIdx].FadeOut(reset: false, OnEndCloseAnim);
			toClose.Add(activeIdx);
		}
		activeIdx = idx;
		if (toClose.Contains(idx))
		{
			toClose.Remove(idx);
		}
		if (activeIdx != -1)
		{
			menus[activeIdx].receiveButtonEvents = true;
			menus[activeIdx].gameObject.SetActive(value: true);
			UICamChaser component = menus[activeIdx].GetComponent<UICamChaser>();
			if (component != null)
			{
				component.Recenter();
			}
			menus[activeIdx].Visible = true;
			animators[activeIdx].FadeIn(reset: true, OnEndOpenAnim);
			return menus[activeIdx];
		}
		return null;
	}

	public UIDreadHallsMenu ShowMenu(string name)
	{
		return ShowMenu(GetMenuIdx(name));
	}

	public void CloseMenu()
	{
		ShowMenu(-1);
	}

	private void OnEndCloseAnim()
	{
		while (toClose.Count > 0)
		{
			menus[toClose[0]].gameObject.SetActive(value: false);
			toClose.RemoveAt(0);
		}
	}

	private void OnEndOpenAnim()
	{
	}

	public UIDreadHallsMenu GetCurrentMenu()
	{
		if (activeIdx == -1)
		{
			return null;
		}
		return menus[activeIdx];
	}

	private int GetMenuIdx(string name)
	{
		for (int i = 0; i < menus.Length; i++)
		{
			if (menus[i].gameObject.name == name)
			{
				return i;
			}
		}
		return -1;
	}

	public UIDreadHallsMenu GetMenu(string name)
	{
		int menuIdx = GetMenuIdx(name);
		if (menuIdx == -1)
		{
			return null;
		}
		return menus[menuIdx];
	}
}
public class UIText : TimeIndependentBehaviour
{
	public string initialText = "Text";

	private void Start()
	{
		RefreshText();
	}

	public void RefreshText()
	{
		TextMesh component = GetComponent<TextMesh>();
		if (component != null)
		{
			component.text = Translate.Get(initialText);
		}
	}
}
public class UITextLabel3D : TimeIndependentBehaviour
{
	private TextMesh textMesh;

	private MeshRenderer meshRenderer;

	public float fadeSpeed = 0.05f;

	public float fadeTarget = 1f;

	public string text
	{
		get
		{
			return textMesh.text;
		}
		set
		{
			textMesh.text = value;
		}
	}

	public Color color
	{
		get
		{
			return meshRenderer.material.color;
		}
		set
		{
			meshRenderer.material.color = color;
		}
	}

	public float alpha
	{
		get
		{
			return meshRenderer.material.color.a;
		}
		set
		{
			Color color = meshRenderer.material.color;
			color.a = Mathf.Clamp(value, 0f, 1f);
			meshRenderer.material.color = color;
		}
	}

	private void Start()
	{
		textMesh = base.gameObject.AddComponent<TextMesh>();
		meshRenderer = GetComponent<MeshRenderer>();
		if (!meshRenderer)
		{
			meshRenderer = base.gameObject.AddComponent<MeshRenderer>();
		}
		meshRenderer.material = Resources.Load<Material>("UI/Materials/FontMaterial");
		textMesh.text = "Hello <i>world</i>";
		textMesh.font = Resources.Load<Font>("UI/trebuc2");
		textMesh.anchor = TextAnchor.MiddleCenter;
	}

	protected override void Update()
	{
		base.Update();
		if (fadeTarget != alpha)
		{
			if (fadeTarget < alpha - fadeSpeed)
			{
				alpha -= fadeSpeed;
			}
			else if (fadeTarget > alpha + fadeSpeed)
			{
				alpha += fadeSpeed;
			}
			else
			{
				alpha = fadeTarget;
			}
		}
		if (Input.GetMouseButtonDown(0))
		{
			FadeIn();
		}
		else if (Input.GetMouseButtonDown(1))
		{
			FadeOut();
		}
	}

	public void FadeIn()
	{
		fadeTarget = 1f;
	}

	public void FadeOut()
	{
		fadeTarget = 0f;
	}
}
public class Torchelight : MonoBehaviour
{
	public GameObject TorchLight;

	public GameObject MainFlame;

	public GameObject BaseFlame;

	public GameObject Etincelles;

	public GameObject Fumee;

	public float MaxLightIntensity;

	public float IntensityLight;

	private void Start()
	{
		TorchLight.GetComponent<Light>().intensity = IntensityLight;
		MainFlame.GetComponent<ParticleSystem>().emissionRate = IntensityLight * 20f;
		BaseFlame.GetComponent<ParticleSystem>().emissionRate = IntensityLight * 15f;
		Etincelles.GetComponent<ParticleSystem>().emissionRate = IntensityLight * 7f;
		Fumee.GetComponent<ParticleSystem>().emissionRate = IntensityLight * 12f;
	}

	private void Update()
	{
		if (IntensityLight < 0f)
		{
			IntensityLight = 0f;
		}
		if (IntensityLight > MaxLightIntensity)
		{
			IntensityLight = MaxLightIntensity;
		}
		TorchLight.GetComponent<Light>().intensity = IntensityLight / 2f + Mathf.Lerp(IntensityLight - 0.1f, IntensityLight + 0.1f, Mathf.Cos(Time.time * 30f));
		TorchLight.GetComponent<Light>().color = new Color(Mathf.Min(IntensityLight / 1.5f, 1f), Mathf.Min(IntensityLight / 2f, 1f), 0f);
		MainFlame.GetComponent<ParticleSystem>().emissionRate = IntensityLight * 20f;
		BaseFlame.GetComponent<ParticleSystem>().emissionRate = IntensityLight * 15f;
		Etincelles.GetComponent<ParticleSystem>().emissionRate = IntensityLight * 7f;
		Fumee.GetComponent<ParticleSystem>().emissionRate = IntensityLight * 12f;
	}
}
namespace OvrTouch.Controllers
{
	public enum HandednessId
	{
		Left,
		Right
	}
	public class TrackedController : MonoBehaviour
	{
		private static class Const
		{
			public const float TriggerDebounceTime = 0.05f;

			public const float ThumbDebounceTime = 0.15f;
		}

		[SerializeField]
		private HandednessId m_handedness;

		[SerializeField]
		private Transform m_trackedTransform;

		private bool m_initialized;

		private int m_controllerType = 1;

		private bool m_point;

		private bool m_thumbsUp;

		private float m_lastPoint = -1f;

		private float m_lastNonPoint = -1f;

		private float m_lastThumb = -1f;

		private float m_lastNonThumb = -1f;

		private float m_hapticDuration = -1f;

		private float m_hapticStartTime = -1f;

		public HandednessId Handedness => m_handedness;

		public bool IsLeft => m_handedness == HandednessId.Left;

		public bool IsPoint => false;

		public bool IsThumbsUp => false;

		public bool Button1 => (m_controllerType != 1) ? Controller.UPvr_GetKey(m_controllerType, Pvr_KeyCode.X) : Controller.UPvr_GetKey(m_controllerType, Pvr_KeyCode.A);

		public bool Button2 => (m_controllerType != 1) ? Controller.UPvr_GetKey(m_controllerType, Pvr_KeyCode.Y) : Controller.UPvr_GetKey(m_controllerType, Pvr_KeyCode.B);

		public bool ButtonJoystick => Controller.UPvr_GetKey(m_controllerType, Pvr_KeyCode.TOUCHPAD);

		public float Trigger => (float)Controller.UPvr_GetControllerTriggerValue(m_controllerType) * 0.003921569f;

		public float GripTrigger => (m_controllerType == 1) ? ((!Controller.UPvr_GetKey(m_controllerType, Pvr_KeyCode.Right)) ? 0f : 1f) : ((!Controller.UPvr_GetKey(m_controllerType, Pvr_KeyCode.Left)) ? 0f : 1f);

		public Vector2 Joystick => (!(Controller.UPvr_GetTouchPadPosition(m_controllerType) == Vector2.zero)) ? new Vector2(Mathf.Clamp((Controller.UPvr_GetTouchPadPosition(m_controllerType).y - 127f) * (1f / 127f), -1f, 1f), Mathf.Clamp((Controller.UPvr_GetTouchPadPosition(m_controllerType).x - 127f) * (1f / 127f), -1f, 1f)) : Vector2.zero;

		public static TrackedController FindOrCreate(HandednessId handedness)
		{
			TrackedController[] array = UnityEngine.Object.FindObjectsOfType<TrackedController>();
			TrackedController[] array2 = array;
			foreach (TrackedController trackedController in array2)
			{
				if (trackedController.Handedness == handedness)
				{
					return trackedController;
				}
			}
			GameObject gameObject = new GameObject("TrackedController");
			TrackedController trackedController2 = gameObject.AddComponent<TrackedController>();
			Transform trackedTransform = null;
			Pvr_UnitySDKManager pvr_UnitySDKManager = UnityEngine.Object.FindObjectOfType<Pvr_UnitySDKManager>();
			if (pvr_UnitySDKManager != null)
			{
				trackedTransform = ((handedness != 0) ? pvr_UnitySDKManager.transform.Find("ControllerManager/PvrController1/RightHandAnchor") : pvr_UnitySDKManager.transform.Find("ControllerManager/PvrController0/LeftHandAnchor"));
			}
			trackedController2.Initialize(handedness, trackedTransform);
			return trackedController2;
		}

		public void PlayHapticEvent(float frequency, float amplitude, float duration)
		{
			m_hapticStartTime = Time.realtimeSinceStartup;
			m_hapticDuration = duration;
			Controller.UPvr_VibrateNeo2Controller(Mathf.Clamp01(amplitude), (int)(duration * 1000f), m_controllerType);
		}

		private void Awake()
		{
			if (m_trackedTransform != null)
			{
				Initialize(m_handedness, m_trackedTransform);
			}
		}

		private void LateUpdate()
		{
			if (m_trackedTransform != null)
			{
				base.transform.position = m_trackedTransform.position;
				base.transform.rotation = m_trackedTransform.rotation;
			}
			float num = Time.realtimeSinceStartup - m_hapticStartTime;
			if (num >= m_hapticDuration)
			{
				Controller.UPvr_VibrateNeo2Controller(0f, 0, m_controllerType);
			}
			float realtimeSinceStartup = Time.realtimeSinceStartup;
			bool flag = false;
			if (flag)
			{
				m_lastPoint = realtimeSinceStartup;
			}
			else
			{
				m_lastNonPoint = realtimeSinceStartup;
			}
			bool flag2 = false;
			if (flag2)
			{
				m_lastThumb = realtimeSinceStartup;
			}
			else
			{
				m_lastNonThumb = realtimeSinceStartup;
			}
			if (flag != IsPoint && ((flag && realtimeSinceStartup - m_lastNonPoint > 0.05f) || (!flag && realtimeSinceStartup - m_lastPoint > 0.05f)))
			{
				m_point = flag;
			}
			if (flag2 != IsThumbsUp && ((flag2 && realtimeSinceStartup - m_lastNonThumb > 0.15f) || (!flag2 && realtimeSinceStartup - m_lastThumb > 0.15f)))
			{
				m_thumbsUp = flag2;
			}
		}

		private void Initialize(HandednessId handedness, Transform trackedTransform)
		{
			if (!m_initialized)
			{
				m_handedness = handedness;
				m_controllerType = ((m_handedness != 0) ? 1 : 0);
				if (trackedTransform != null)
				{
					m_trackedTransform = trackedTransform;
					base.transform.position = m_trackedTransform.position;
					base.transform.rotation = m_trackedTransform.rotation;
				}
				m_initialized = true;
			}
		}
	}
}
namespace OvrTouch.Hands
{
	public enum HandPoseId
	{
		Default,
		Generic,
		PingPongBall
	}
	public enum HandPoseAttachType
	{
		None,
		Snap,
		SnapPosition
	}
	public class HandPose : MonoBehaviour
	{
		[SerializeField]
		private bool m_allowPointing;

		[SerializeField]
		private bool m_allowThumbsUp;

		[SerializeField]
		private HandPoseId m_poseId;

		[SerializeField]
		private HandPoseAttachType m_attachType;

		public bool AllowPointing => m_allowPointing;

		public bool AllowThumbsUp => m_allowThumbsUp;

		public HandPoseId PoseId => m_poseId;

		public HandPoseAttachType AttachType => m_attachType;
	}
}
public class OVRWaitCursor : MonoBehaviour
{
	public Vector3 rotateSpeeds = new Vector3(0f, 0f, -60f);

	private void Update()
	{
		base.transform.Rotate(rotateSpeeds * Time.smoothDeltaTime);
	}
}
public class GUIView : MonoBehaviour
{
	private float progress;

	private bool muted;

	private int score;

	private string playername = "Noname";

	private const string PROGRESS_KEY = "Progress";

	private const string MUTED_KEY = "IsSoundMuted";

	private const string SCORE_KEY = "Highscore";

	private const string PLAYERNAME_KEY = "PlayerName";

	private void Start()
	{
		RefreshData();
	}

	private void Update()
	{
		if (Input.anyKeyDown)
		{
			RefreshData();
		}
	}

	private void OnGUI()
	{
		int num = 450;
		int num2 = 400;
		GUILayout.BeginArea(new Rect(Screen.width / 2 - num / 2, Screen.height / 2 - num2 / 2, num, num2));
		GUILayout.BeginVertical();
		string text = "Unfortunately, this will take a a few seconds. This is due Unity working different on a Mac :(";
		GUILayout.TextArea(string.Format("Instructions: {0} 1) Open the Advanced PlayerPrefs Window and dock it somewhere. {0} 2) Change the values in the scene using the gui widgets. {0} 3) Go back to the Advanced PlayerPrefs Window and click the refresh button. " + ((Application.platform != 0) ? string.Empty : text) + " {0} 4) Observe that the values in the Advanced PlayerPrefs Window has changed to your scene input. {0}{0} 5) Now in the Advanced PlayerPrefs Window, change the values and save those changes {0} 6) Go give the scene focus by clicking in the sceneview. {0} 7) Watch the gui values update to your changes", Environment.NewLine));
		GUILayout.Space(12f);
		GUILayout.Label("Progress: " + (int)progress + "%");
		float a = GUILayout.HorizontalSlider(progress, 0f, 100f);
		if (!Mathf.Approximately(a, progress))
		{
			progress = a;
			SaveData();
		}
		GUILayout.Space(12f);
		bool flag = GUILayout.Toggle(muted, "Is Audio Muted?");
		if (flag != muted)
		{
			muted = flag;
			SaveData();
		}
		GUILayout.Space(12f);
		GUILayout.Label("Highscore: " + score);
		GUILayout.Space(12f);
		GUILayout.Label("Playername");
		string text2 = GUILayout.TextField(playername);
		if (text2 != playername)
		{
			playername = text2;
			SaveData();
		}
		GUILayout.EndVertical();
		GUILayout.EndArea();
	}

	public void RefreshData()
	{
		progress = PlayerPrefs.GetFloat("Progress", 100f);
		muted = PlayerPrefs.GetString("IsSoundMuted", "true") == "true";
		score = PlayerPrefs.GetInt("Highscore", 123);
		playername = PlayerPrefs.GetString("PlayerName", "Noname");
	}

	public void SaveData()
	{
		PlayerPrefs.SetFloat("Progress", progress);
		PlayerPrefs.SetString("IsSoundMuted", (!muted) ? "false" : "true");
		PlayerPrefs.SetInt("Highscore", score);
		PlayerPrefs.SetString("PlayerName", playername);
	}
}
public class CameraController : MonoBehaviour
{
	public List<Camera> Cameras = new List<Camera>();

	private int m_CurrentIndex;

	public void Awake()
	{
		for (int i = 0; i < Cameras.Count; i++)
		{
			Cameras[i].enabled = false;
			if (i == m_CurrentIndex)
			{
				Cameras[i].enabled = true;
			}
		}
	}

	private void OnGUI()
	{
		if (!GUI.Button(new Rect((float)Screen.width / 2.3f, (float)Screen.height / 1.15f, 150f, 40f), "NEXT"))
		{
			return;
		}
		m_CurrentIndex++;
		if (m_CurrentIndex >= Cameras.Count)
		{
			m_CurrentIndex = 0;
		}
		for (int i = 0; i < Cameras.Count; i++)
		{
			Cameras[i].enabled = false;
			if (i == m_CurrentIndex)
			{
				Cameras[i].enabled = true;
			}
		}
	}
}
public class Cleanup : MonoBehaviour
{
	public float TimeBeforeCleanup;

	private void Awake()
	{
		StartCoroutine(CleanupObject());
	}

	public IEnumerator CleanupObject()
	{
		yield return new WaitForSeconds(TimeBeforeCleanup);
		UnityEngine.Object.DestroyObject(base.gameObject);
	}
}
[RequireComponent(typeof(AudioSource))]
public class Lightning : MonoBehaviour
{
	public Light TargetLight;

	public bool Enabled;

	public float MinWaitTime;

	public float MaxWaitTime;

	public AudioSource Sound;

	public void Awake()
	{
		if (!(TargetLight == null) && Enabled)
		{
			StartCoroutine(PlayLightning());
		}
	}

	private IEnumerator PlayLightning()
	{
		while (Enabled)
		{
			yield return new WaitForSeconds(UnityEngine.Random.Range(MinWaitTime, MaxWaitTime));
			TargetLight.intensity = 0f;
			if (Sound != null)
			{
				Sound.Play();
			}
			while (TargetLight.intensity < 0.3f)
			{
				TargetLight.intensity = Mathf.Lerp(TargetLight.intensity, 0.4f, Time.deltaTime * 15f);
				yield return new WaitForSeconds(0f);
			}
			while (TargetLight.intensity > 0f)
			{
				TargetLight.intensity = Mathf.Lerp(TargetLight.intensity, -0.1f, Time.deltaTime * 3f);
				yield return new WaitForSeconds(0f);
			}
			TargetLight.intensity = 0f;
		}
	}
}
public class PlayEffect : MonoBehaviour
{
	public GameObject Effect;

	public Transform Node;

	public float OverrideTime;

	private float m_Time;

	public void Awake()
	{
		m_Time = Time.time;
	}

	private void Update()
	{
		if (Effect == null)
		{
			return;
		}
		if (OverrideTime > 0f)
		{
			if (Time.time >= m_Time + OverrideTime)
			{
				UnityEngine.Object.Instantiate(Effect, Node.position, Node.rotation);
				m_Time = Time.time;
			}
		}
		else if (Time.time >= m_Time + 1.5f)
		{
			UnityEngine.Object.Instantiate(Effect, Node.position, Node.rotation);
			m_Time = Time.time;
		}
	}
}
public class Visual : MonoBehaviour
{
	public float DontChangeThis;

	private void OnDrawGizmosSelected()
	{
		Gizmos.color = new Color(1f, 1f, 1f, 0.5f);
		Gizmos.DrawCube(base.transform.position, new Vector3(15f, DontChangeThis, 15f));
	}
}
namespace DCM
{
	public class DrawCallMinimizer : MonoBehaviour
	{
		[SerializeField]
		private DrawCallMinimizerInfo _textureAtlasProperties = new DrawCallMinimizerInfo();

		[SerializeField]
		private bool destroyOriginalGameObject;

		public const string VERSION = "2.0";

		public DrawCallMinimizerInfo textureAtlasProperties
		{
			get
			{
				return _textureAtlasProperties;
			}
			set
			{
				_textureAtlasProperties = value;
			}
		}

		private void Start()
		{
			MeshFilter[] componentsInChildren = GetComponentsInChildren<MeshFilter>();
			Matrix4x4 worldToLocalMatrix = base.transform.worldToLocalMatrix;
			Dictionary<string, Dictionary<Material, List<MeshInstance>>> allMeshesAndMaterials = new Dictionary<string, Dictionary<Material, List<MeshInstance>>>();
			OrganizeObjects(componentsInChildren, worldToLocalMatrix, allMeshesAndMaterials);
			CreateBatchedObjects(allMeshesAndMaterials);
			if (destroyOriginalGameObject)
			{
				UnityEngine.Object.Destroy(base.gameObject);
				return;
			}
			MeshFilter[] array = componentsInChildren;
			foreach (MeshFilter obj in array)
			{
				UnityEngine.Object.Destroy(obj);
			}
			Renderer[] componentsInChildren2 = GetComponentsInChildren<Renderer>();
			foreach (Renderer renderer in componentsInChildren2)
			{
				renderer.enabled = false;
			}
			UnityEngine.Object.Destroy(this);
		}

		private static void OrganizeObjects(MeshFilter[] filters, Matrix4x4 myTransform, IDictionary<string, Dictionary<Material, List<MeshInstance>>> allMeshesAndMaterials)
		{
			for (int i = 0; i < filters.Length; i++)
			{
				Renderer component = filters[i].GetComponent<Renderer>();
				MeshInstance item = default(MeshInstance);
				item.mesh = filters[i].mesh;
				if (component != null && component.enabled && item.mesh != null)
				{
					item.transform = myTransform * filters[i].transform.localToWorldMatrix;
					Material[] sharedMaterials = component.sharedMaterials;
					for (int j = 0; j < sharedMaterials.Length; j++)
					{
						ConfirmDictionaryKeys(allMeshesAndMaterials, sharedMaterials[j]);
						item.subMeshIndex = Mathf.Min(j, item.mesh.subMeshCount - 1);
						allMeshesAndMaterials[sharedMaterials[j].shader.ToString()][sharedMaterials[j]].Add(item);
					}
				}
			}
		}

		private static void ConfirmDictionaryKeys(IDictionary<string, Dictionary<Material, List<MeshInstance>>> allMeshesAndMaterials, Material mat)
		{
			if (!allMeshesAndMaterials.ContainsKey(mat.shader.ToString()))
			{
				allMeshesAndMaterials.Add(mat.shader.ToString(), new Dictionary<Material, List<MeshInstance>>());
			}
			if (!allMeshesAndMaterials[mat.shader.ToString()].ContainsKey(mat))
			{
				allMeshesAndMaterials[mat.shader.ToString()].Add(mat, new List<MeshInstance>());
			}
		}

		private void CreateBatchedObjects(IDictionary<string, Dictionary<Material, List<MeshInstance>>> allMeshesAndMaterials)
		{
			foreach (KeyValuePair<string, Dictionary<Material, List<MeshInstance>>> allMeshesAndMaterial in allMeshesAndMaterials)
			{
				List<Material> combines = new List<Material>(allMeshesAndMaterial.Value.Keys);
				TextureCombineOutput textureCombineOutput = TextureCombineUtility.Combine(combines, _textureAtlasProperties);
				if (textureCombineOutput == null || textureCombineOutput.texturePositions == null)
				{
					continue;
				}
				List<MeshInstance> list = new List<MeshInstance>();
				foreach (KeyValuePair<Material, List<MeshInstance>> item in allMeshesAndMaterial.Value)
				{
					TexturePosition referenceTexturePosition = GetReferenceTexturePosition(textureCombineOutput.texturePositions, item.Key.mainTexture.name);
					for (int i = 0; i < item.Value.Count; i++)
					{
						OffsetUvs(item.Value[i].mesh, referenceTexturePosition.position);
						list.Add(item.Value[i]);
					}
				}
				IList<Mesh> list2 = MeshCombineUtility.Combine(list);
				GameObject gameObject = new GameObject("Combined " + base.gameObject.name + " " + allMeshesAndMaterial.Key + " Mesh Parent");
				gameObject.transform.position = base.transform.position;
				gameObject.transform.rotation = base.transform.rotation;
				for (int j = 0; j < list2.Count; j++)
				{
					GameObject gameObject2 = new GameObject("Combined " + base.gameObject.name + " Mesh");
					gameObject2.transform.parent = gameObject.transform;
					gameObject2.tag = base.gameObject.tag;
					gameObject2.layer = base.gameObject.layer;
					gameObject2.transform.localScale = Vector3.one;
					gameObject2.transform.localRotation = Quaternion.identity;
					gameObject2.transform.localPosition = Vector3.zero;
					MeshFilter meshFilter = gameObject2.AddComponent<MeshFilter>();
					gameObject2.AddComponent<MeshRenderer>().sharedMaterial = textureCombineOutput.combinedMaterial;
					meshFilter.mesh = list2[j];
				}
			}
		}

		private static TexturePosition GetReferenceTexturePosition(IList<TexturePosition> textureUVPositions, string textureName)
		{
			TexturePosition result = textureUVPositions[0];
			for (int i = 0; i < textureUVPositions.Count; i++)
			{
				if (textureName.Length == textureUVPositions[i].textures[0].name.Length && textureName == textureUVPositions[i].textures[0].name)
				{
					result = textureUVPositions[i];
					break;
				}
			}
			return result;
		}

		private static void OffsetUvs(Mesh modifiedMesh, Rect referencedTexturePosition)
		{
			Vector2[] uv = modifiedMesh.uv;
			for (int i = 0; i < uv.Length; i++)
			{
				uv[i].x = referencedTexturePosition.x + uv[i].x * referencedTexturePosition.width;
				uv[i].y = referencedTexturePosition.y + uv[i].y * referencedTexturePosition.height;
			}
			modifiedMesh.uv = uv;
			uv = modifiedMesh.uv2;
			for (int j = 0; j < uv.Length; j++)
			{
				uv[j].x = referencedTexturePosition.x + uv[j].x * referencedTexturePosition.width;
				uv[j].y = referencedTexturePosition.y + uv[j].y * referencedTexturePosition.height;
			}
			modifiedMesh.uv2 = uv;
		}
	}
	[Serializable]
	public enum CommonShaderProperties
	{
		_MainTex,
		_BumpMap,
		_Cube,
		_DecalTex,
		_Detail,
		_ParallaxMap,
		Other
	}
	[Serializable]
	public class DrawCallMinimizerInfo
	{
		[SerializeField]
		private int _anisoLevel = 1;

		[SerializeField]
		private bool _readableTexture;

		[SerializeField]
		private FilterMode _filterMode = FilterMode.Bilinear;

		[SerializeField]
		private bool _ignoreTransparency;

		[SerializeField]
		private TextureWrapMode _wrapMode = TextureWrapMode.Clamp;

		[SerializeField]
		private List<ShaderProperties> _shaderPropertiesToLookFor = new List<ShaderProperties>
		{
			new ShaderProperties(normal: false, "_MainTex"),
			new ShaderProperties(normal: true, "_BumpMap"),
			new ShaderProperties(normal: false, "_Cube"),
			new ShaderProperties(normal: false, "_DecalTex"),
			new ShaderProperties(normal: false, "_Detail"),
			new ShaderProperties(normal: false, "_ParallaxMap")
		};

		[SerializeField]
		private int _maxTextureSize = 2048;

		[SerializeField]
		private int _padding;

		public int anisoLevel
		{
			get
			{
				return _anisoLevel;
			}
			set
			{
				_anisoLevel = value;
			}
		}

		public bool readableTexture
		{
			get
			{
				return _readableTexture;
			}
			set
			{
				_readableTexture = value;
			}
		}

		public FilterMode filterMode
		{
			get
			{
				return _filterMode;
			}
			set
			{
				_filterMode = value;
			}
		}

		public bool ignoreTransparency
		{
			get
			{
				return _ignoreTransparency;
			}
			set
			{
				_ignoreTransparency = value;
			}
		}

		public TextureWrapMode wrapMode
		{
			get
			{
				return _wrapMode;
			}
			set
			{
				_wrapMode = value;
			}
		}

		public IList<ShaderProperties> shaderPropertiesToLookFor
		{
			get
			{
				return _shaderPropertiesToLookFor;
			}
			set
			{
				_shaderPropertiesToLookFor = (List<ShaderProperties>)value;
			}
		}

		public int maxTextureSize
		{
			get
			{
				return _maxTextureSize;
			}
			set
			{
				_maxTextureSize = value;
			}
		}

		public int padding
		{
			get
			{
				return _padding;
			}
			set
			{
				_padding = value;
			}
		}
	}
	public static class MatrixExtension
	{
		public static Vector3 GetScale(this Matrix4x4 mat)
		{
			return new Vector3(Vector3.Magnitude(new Vector3(mat.m00, mat.m01, mat.m02)), Vector3.Magnitude(new Vector3(mat.m10, mat.m11, mat.m12)), Vector3.Magnitude(new Vector3(mat.m20, mat.m21, mat.m22)));
		}

		public static float GetDeterminant(this Matrix4x4 mat)
		{
			return mat.m00 * mat.m11 * mat.m22 + mat.m01 * mat.m12 * mat.m20 + mat.m02 * mat.m10 * mat.m21 - mat.m02 * mat.m11 * mat.m20 - mat.m01 * mat.m10 * mat.m22 - mat.m00 * mat.m12 * mat.m21;
		}
	}
	public static class MeshCombineUtility
	{
		public static IList<Mesh> Combine(IList<MeshInstance> combines)
		{
			return Combine(combines, 65000);
		}

		public static IList<Mesh> Combine(IList<MeshInstance> combines, int maximumVertices)
		{
			float num = 0f;
			int num2 = 0;
			for (int i = 0; i < combines.Count; i++)
			{
				if (combines[i].mesh != null)
				{
					num += (float)combines[i].mesh.vertexCount;
					num2 += combines[i].mesh.triangles.Length;
				}
			}
			int j = 0;
			int num3 = Mathf.CeilToInt(num / (float)maximumVertices);
			int num4 = (int)(num / (float)num3);
			List<Mesh> list = new List<Mesh>();
			for (int k = 1; k <= num3; k++)
			{
				List<Vector3> list2 = new List<Vector3>(num4);
				List<Vector3> list3 = new List<Vector3>(num4);
				List<Vector4> list4 = new List<Vector4>(num4);
				List<Vector2> list5 = new List<Vector2>(num4);
				List<Vector2> list6 = new List<Vector2>(num4);
				List<Color> list7 = new List<Color>(num4);
				List<int> list8 = new List<int>(num2 / num3);
				int num5 = 0;
				for (; j < combines.Count; j++)
				{
					if (num5 > num4)
					{
						break;
					}
					if (!(combines[j].mesh != null))
					{
						continue;
					}
					Matrix4x4 transform = combines[j].transform;
					Copy(combines[j].mesh.vertices, list2, combines[j].transform);
					transform = transform.inverse.transpose;
					if (combines[j].mesh.normals.Length != combines[j].mesh.vertexCount)
					{
						combines[j].mesh.RecalculateNormals();
					}
					CopyNormal(combines[j].mesh.normals, list3, transform);
					if (combines[j].mesh.tangents.Length != combines[j].mesh.vertexCount)
					{
						CalculateTangents(combines[j].mesh);
					}
					CopyTangents(combines[j].mesh.tangents, list4, transform);
					Copy(combines[j].mesh.uv, list5);
					if (combines[j].mesh.uv2.Length == combines[j].mesh.vertexCount)
					{
						Copy(combines[j].mesh.uv2, list6);
					}
					else
					{
						Vector2 zero = Vector2.zero;
						for (int l = 0; l < combines[j].mesh.vertexCount; l++)
						{
							list6.Add(zero);
						}
					}
					if (combines[j].mesh.colors.Length == combines[j].mesh.vertexCount)
					{
						CopyColors(combines[j].mesh.colors, list7);
					}
					else
					{
						Color white = Color.white;
						for (int m = 0; m < combines[j].mesh.vertexCount; m++)
						{
							list7.Add(white);
						}
					}
					CopyTriangles(combines[j].mesh.triangles, list8, num5, combines[j].transform.GetDeterminant() < 0f);
					num5 += combines[j].mesh.vertexCount;
				}
				Mesh mesh = new Mesh();
				mesh.name = "Combined Mesh";
				mesh.vertices = list2.ToArray();
				mesh.normals = list3.ToArray();
				mesh.colors = list7.ToArray();
				mesh.uv = list5.ToArray();
				mesh.uv2 = list6.ToArray();
				mesh.tangents = list4.ToArray();
				mesh.triangles = list8.ToArray();
				list.Add(mesh);
			}
			return list.ToArray();
		}

		private static void Copy(Vector3[] src, ICollection<Vector3> dst, Matrix4x4 transform)
		{
			for (int i = 0; i < src.Length; i++)
			{
				dst.Add(transform.MultiplyPoint(src[i]));
			}
		}

		private static void CopyNormal(Vector3[] src, ICollection<Vector3> dst, Matrix4x4 transform)
		{
			for (int i = 0; i < src.Length; i++)
			{
				dst.Add(transform.MultiplyVector(src[i]).normalized);
			}
		}

		private static void Copy(Vector2[] src, ICollection<Vector2> dst)
		{
			for (int i = 0; i < src.Length; i++)
			{
				dst.Add(src[i]);
			}
		}

		private static void CopyColors(Color[] src, ICollection<Color> dst)
		{
			for (int i = 0; i < src.Length; i++)
			{
				dst.Add(src[i]);
			}
		}

		private static void CopyTangents(Vector4[] src, ICollection<Vector4> dst, Matrix4x4 transform)
		{
			for (int i = 0; i < src.Length; i++)
			{
				Vector4 vector = src[i];
				Vector3 vector2 = new Vector3(vector.x, vector.y, vector.z);
				vector2 = transform.MultiplyVector(vector2).normalized;
				dst.Add(new Vector4(vector2.x, vector2.y, vector2.z, vector.w));
			}
		}

		private static void CopyTriangles(int[] src, ICollection<int> dst, int vertexOffset, bool isNegativeScale)
		{
			if (isNegativeScale)
			{
				for (int i = 0; i < src.Length; i += 3)
				{
					dst.Add(src[i] + vertexOffset);
					dst.Add(src[i + 2] + vertexOffset);
					dst.Add(src[i + 1] + vertexOffset);
				}
			}
			else
			{
				for (int j = 0; j < src.Length; j++)
				{
					dst.Add(src[j] + vertexOffset);
				}
			}
		}

		private static void CalculateTangents(Mesh mesh)
		{
			int vertexCount = mesh.vertexCount;
			Vector3[] vertices = mesh.vertices;
			Vector3[] normals = mesh.normals;
			Vector2[] uv = mesh.uv;
			int[] triangles = mesh.triangles;
			int num = triangles.Length / 3;
			Vector4[] array = new Vector4[vertexCount];
			Vector3[] array2 = new Vector3[vertexCount];
			Vector3[] array3 = new Vector3[vertexCount];
			int num2 = 0;
			for (int i = 0; i < num; i++)
			{
				int num3 = triangles[num2];
				int num4 = triangles[num2 + 1];
				int num5 = triangles[num2 + 2];
				Vector3 vector = vertices[num3];
				Vector3 vector2 = vertices[num4];
				Vector3 vector3 = vertices[num5];
				Vector2 vector4 = uv[num3];
				Vector2 vector5 = uv[num4];
				Vector2 vector6 = uv[num5];
				float num6 = vector2.x - vector.x;
				float num7 = vector3.x - vector.x;
				float num8 = vector2.y - vector.y;
				float num9 = vector3.y - vector.y;
				float num10 = vector2.z - vector.z;
				float num11 = vector3.z - vector.z;
				float num12 = vector5.x - vector4.x;
				float num13 = vector6.x - vector4.x;
				float num14 = vector5.y - vector4.y;
				float num15 = vector6.y - vector4.y;
				float num16 = 1f / (num12 * num15 - num13 * num14);
				Vector3 vector7 = new Vector3((num15 * num6 - num14 * num7) * num16, (num15 * num8 - num14 * num9) * num16, (num15 * num10 - num14 * num11) * num16);
				Vector3 vector8 = new Vector3((num12 * num7 - num13 * num6) * num16, (num12 * num9 - num13 * num8) * num16, (num12 * num11 - num13 * num10) * num16);
				array2[num3] += vector7;
				array2[num4] += vector7;
				array2[num5] += vector7;
				array3[num3] += vector8;
				array3[num4] += vector8;
				array3[num5] += vector8;
				num2 += 3;
			}
			for (int j = 0; j < vertexCount; j++)
			{
				Vector3 normal = normals[j];
				Vector3 tangent = array2[j];
				Vector3.OrthoNormalize(ref normal, ref tangent);
				array[j].x = tangent.x;
				array[j].y = tangent.y;
				array[j].z = tangent.z;
				array[j].w = ((!(Vector3.Dot(Vector3.Cross(normal, tangent), array3[j]) < 0f)) ? 1f : (-1f));
			}
			mesh.tangents = array;
		}
	}
	public class MeshExporter
	{
		public static string MeshToString(Mesh m)
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append("g Exported Mesh " + m.name + " \n");
			Matrix4x4 matrix4x = Matrix4x4.TRS(Vector3.zero, Quaternion.identity, new Vector3(-1f, 1f, 1f));
			Vector3[] vertices = m.vertices;
			foreach (Vector3 point in vertices)
			{
				Vector3 vector = matrix4x.MultiplyPoint(point);
				stringBuilder.Append($"v {vector.x} {vector.y} {vector.z}\n");
			}
			stringBuilder.Append("\n");
			Vector3[] normals = m.normals;
			foreach (Vector3 vector2 in normals)
			{
				Vector3 vector3 = matrix4x.MultiplyVector(vector2);
				stringBuilder.Append($"vn {vector3.x} {vector3.y} {vector3.z}\n");
			}
			stringBuilder.Append("\n");
			Vector2[] uv = m.uv;
			for (int k = 0; k < uv.Length; k++)
			{
				Vector2 vector4 = uv[k];
				stringBuilder.Append($"vt {vector4.x} {vector4.y}\n");
			}
			stringBuilder.Append("\n");
			Vector2[] uv2 = m.uv2;
			for (int l = 0; l < uv2.Length; l++)
			{
				Vector2 vector5 = uv2[l];
				stringBuilder.Append($"vt1 {vector5.x} {vector5.y}\n");
			}
			stringBuilder.Append("\n");
			Vector2[] uv3 = m.uv2;
			for (int n = 0; n < uv3.Length; n++)
			{
				Vector2 vector6 = uv3[n];
				stringBuilder.Append($"vt2 {vector6.x} {vector6.y}\n");
			}
			stringBuilder.Append("\n");
			Color[] colors = m.colors;
			for (int num = 0; num < colors.Length; num++)
			{
				Color color = colors[num];
				stringBuilder.Append($"vc {color.r} {color.g} {color.b} {color.a}\n");
			}
			for (int num2 = 0; num2 < m.triangles.Length; num2 += 3)
			{
				stringBuilder.Append(string.Format("f {0}/{0}/{0} {1}/{1}/{1} {2}/{2}/{2}\n", m.triangles[num2] + 1, m.triangles[num2 + 2] + 1, m.triangles[num2 + 1] + 1));
			}
			return stringBuilder.ToString();
		}

		public static void MeshToFile(Mesh m, string filename)
		{
			try
			{
				using StreamWriter streamWriter = new StreamWriter(filename);
				streamWriter.WriteLine(MeshToString(m));
			}
			catch (Exception ex)
			{
				Debug.LogError(ex.Message);
			}
		}
	}
	public struct MeshInstance
	{
		[SerializeField]
		private Mesh _mesh;

		[SerializeField]
		private int _subMeshIndex;

		[SerializeField]
		private Matrix4x4 _transform;

		public Mesh mesh
		{
			get
			{
				return _mesh;
			}
			set
			{
				_mesh = value;
			}
		}

		public int subMeshIndex
		{
			get
			{
				return _subMeshIndex;
			}
			set
			{
				_subMeshIndex = value;
			}
		}

		public Matrix4x4 transform
		{
			get
			{
				return _transform;
			}
			set
			{
				_transform = value;
			}
		}
	}
	[Serializable]
	public class ShaderProperties
	{
		[SerializeField]
		private bool _markAsNormal;

		[SerializeField]
		private string _propertyName;

		public bool markAsNormal
		{
			get
			{
				return _markAsNormal;
			}
			set
			{
				_markAsNormal = value;
			}
		}

		public string propertyName
		{
			get
			{
				return _propertyName;
			}
			set
			{
				_propertyName = value;
			}
		}

		public ShaderProperties(bool normal, string name)
		{
			_markAsNormal = normal;
			_propertyName = name;
		}
	}
	public class TextureCombineOutput
	{
		[SerializeField]
		private Material _combinedMaterial;

		[SerializeField]
		private TexturePosition[] _texturePositions;

		public Material combinedMaterial
		{
			get
			{
				return _combinedMaterial;
			}
			set
			{
				_combinedMaterial = value;
			}
		}

		public TexturePosition[] texturePositions
		{
			get
			{
				return _texturePositions;
			}
			set
			{
				_texturePositions = value;
			}
		}
	}
	public static class TextureCombineUtility
	{
		private static Texture2D _defaultTexture;

		public static Texture2D defaultTexture
		{
			get
			{
				if (_defaultTexture == null)
				{
					_defaultTexture = new Texture2D(32, 32, TextureFormat.RGB24, mipmap: false);
					Color[] array = new Color[1024];
					Color white = Color.white;
					for (int i = 0; i < array.Length; i++)
					{
						array[i] = white;
					}
					_defaultTexture.SetPixels(array);
					_defaultTexture.Apply();
				}
				return _defaultTexture;
			}
		}

		public static TextureCombineOutput Combine(IList<Material> combines, DrawCallMinimizerInfo atlasInfo)
		{
			if (atlasInfo == null || atlasInfo.shaderPropertiesToLookFor == null || atlasInfo.shaderPropertiesToLookFor.Count <= 0)
			{
				Debug.LogError("You need to enter some shader properties to look for into Atlas Info. Cannot combine with 0 properties");
				return null;
			}
			TextureCombineOutput textureCombineOutput = new TextureCombineOutput();
			IList<ShaderProperties> shaderProperties = GetShaderProperties(combines, atlasInfo);
			for (int i = 0; i < combines.Count; i++)
			{
				FillInNullMainTexture(combines[i]);
				for (int j = 0; j < shaderProperties.Count; j++)
				{
					FillInNulls(combines[i], shaderProperties[j]);
				}
			}
			textureCombineOutput.texturePositions = SetTexturePositions(combines, shaderProperties);
			Texture2D texture2D = new Texture2D(atlasInfo.maxTextureSize, atlasInfo.maxTextureSize, (!atlasInfo.ignoreTransparency || shaderProperties[0].markAsNormal) ? TextureFormat.ARGB32 : TextureFormat.RGB24, mipmap: true);
			Rect[] array = PackOriginalTexture(textureCombineOutput.texturePositions, texture2D, atlasInfo);
			if (array != null)
			{
				Material material = new Material(combines[0]);
				material.SetTexture(shaderProperties[0].propertyName, texture2D);
				for (int k = 1; k < shaderProperties.Count; k++)
				{
					Texture2D value = PackAdditionalTexture(GetTexturesAsArray(textureCombineOutput.texturePositions, k), texture2D.width, texture2D.height, atlasInfo, array, shaderProperties[k].markAsNormal);
					material.SetTexture(shaderProperties[k].propertyName, value);
				}
				textureCombineOutput.combinedMaterial = material;
				return textureCombineOutput;
			}
			Debug.LogError("There was some sort of issue while trying to pack the textures...");
			return null;
		}

		private static void FillInNulls(Material mat, ShaderProperties property)
		{
			if (mat.HasProperty(property.propertyName) && mat.GetTexture(property.propertyName) == null)
			{
				mat.SetTexture(property.propertyName, defaultTexture);
			}
		}

		private static void FillInNullMainTexture(Material mat)
		{
			if (mat.mainTexture == null)
			{
				mat.mainTexture = defaultTexture;
			}
		}

		public static TextureCombineOutput Combine(IList<Material> combines, DrawCallMinimizerInfo atlasInfo, bool readableOveride)
		{
			atlasInfo.readableTexture = readableOveride;
			return Combine(combines, atlasInfo);
		}

		private static IList<ShaderProperties> GetShaderProperties(IList<Material> combines, DrawCallMinimizerInfo atlasInfo)
		{
			return GetShaderProperties(combines[0], atlasInfo);
		}

		public static IList<ShaderProperties> GetShaderProperties(Material material, DrawCallMinimizerInfo atlasInfo)
		{
			List<ShaderProperties> list = new List<ShaderProperties>();
			for (int i = 0; i < atlasInfo.shaderPropertiesToLookFor.Count; i++)
			{
				if (material.HasProperty(atlasInfo.shaderPropertiesToLookFor[i].propertyName))
				{
					list.Add(atlasInfo.shaderPropertiesToLookFor[i]);
				}
			}
			return list.AsReadOnly();
		}

		private static Texture2D[] GetTexturesAsArray(IList<TexturePosition> texturePositions, int index)
		{
			if (texturePositions == null || texturePositions.Count == 0)
			{
				Debug.LogError("No TexturePositions exist in list passed to GetTexturesAsArray. Exiting out of batching operation... Check to see that objects being batched are not missing textures");
				return null;
			}
			if (texturePositions[0].textures == null || texturePositions[0].textures.Count == 0)
			{
				Debug.LogError("Could not find textures to batch during GetTexturesAsArray. Exiting out of batching operation... Check to see that objects being batched are not missing textures");
				return null;
			}
			if (index < 0 || index >= texturePositions[0].textures.Count)
			{
				Debug.LogError("Index passed into GetTexturesAsArray is out of bounds...Not quite sure how that could have happened, double check that your textures are set properly on your objects, and if they are, email johnjrpurdy@gmail.com with the Debug.Log output and what you are trying to do");
				return null;
			}
			Texture2D[] array = new Texture2D[texturePositions.Count];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = texturePositions[i].textures[index];
			}
			return array;
		}

		private static TexturePosition[] SetTexturePositions(IList<Material> combines, IList<ShaderProperties> properties)
		{
			TexturePosition[] array = new TexturePosition[combines.Count];
			for (int i = 0; i < combines.Count; i++)
			{
				TexturePosition texturePosition = default(TexturePosition);
				texturePosition.textures = new List<Texture2D>(properties.Count);
				for (int j = 0; j < properties.Count; j++)
				{
					if (combines[i].GetTexture(properties[j].propertyName) == null)
					{
						Debug.LogError("Cannot combine textures when using Unity's default material texture");
						return null;
					}
					texturePosition.textures.Add(combines[i].GetTexture(properties[j].propertyName) as Texture2D);
				}
				array[i] = texturePosition;
			}
			return array;
		}

		private static Rect[] PackOriginalTexture(TexturePosition[] texturePositions, Texture2D textureAtlas, DrawCallMinimizerInfo atlasInfo)
		{
			textureAtlas.anisoLevel = atlasInfo.anisoLevel;
			textureAtlas.filterMode = atlasInfo.filterMode;
			textureAtlas.wrapMode = atlasInfo.wrapMode;
			Rect[] array = textureAtlas.PackTextures(GetTexturesAsArray(texturePositions, 0), atlasInfo.padding, atlasInfo.maxTextureSize, !atlasInfo.readableTexture);
			for (int i = 0; i < texturePositions.Length; i++)
			{
				texturePositions[i].position = array[i];
			}
			return array;
		}

		private static Texture2D PackAdditionalTexture(IList<Texture2D> textures, int textureWidth, int textureHeight, DrawCallMinimizerInfo atlasInfo, IList<Rect> UVs, bool markAsNormal)
		{
			Texture2D texture2D = new Texture2D(textureWidth, textureHeight, (!atlasInfo.ignoreTransparency || markAsNormal) ? TextureFormat.ARGB32 : TextureFormat.RGB24, mipmap: true);
			texture2D.anisoLevel = atlasInfo.anisoLevel;
			texture2D.filterMode = atlasInfo.filterMode;
			texture2D.wrapMode = atlasInfo.wrapMode;
			for (int i = 0; i < textures.Count; i++)
			{
				if (!Mathf.Approximately(textures[i].width, (float)textureWidth * UVs[i].width) || !Mathf.Approximately(textures[i].height, (float)textureHeight * UVs[i].height))
				{
					textures[i] = ScaleTexture(textures[i], (int)(UVs[i].width * (float)textureWidth), (int)(UVs[i].height * (float)textureHeight));
				}
				try
				{
					texture2D.SetPixels((int)(UVs[i].x * (float)textureWidth), (int)((float)textureHeight * UVs[i].y), (int)(UVs[i].width * (float)textureWidth), (int)((float)textureHeight * UVs[i].height), textures[i].GetPixels());
				}
				catch (Exception exception)
				{
					Debug.LogException(exception);
					return null;
				}
			}
			texture2D.Apply(updateMipmaps: true, !atlasInfo.readableTexture);
			return texture2D;
		}

		private static Texture2D ScaleTexture(Texture2D oldTexture, int width, int height)
		{
			Color[] pixels = oldTexture.GetPixels();
			Color[] array = new Color[width * height];
			float num = 1f / ((float)width / (float)(oldTexture.width - 1));
			float num2 = 1f / ((float)height / (float)(oldTexture.height - 1));
			int width2 = oldTexture.width;
			for (int i = 0; i < height; i++)
			{
				int num3 = Mathf.FloorToInt((float)i * num2);
				int num4 = num3 * width2;
				int num5 = (num3 + 1) * width2;
				int num6 = i * width;
				for (int j = 0; j < width; j++)
				{
					int num7 = Mathf.FloorToInt((float)j * num);
					float v = (float)j * num - (float)num7;
					ref Color reference = ref array[num6 + j];
					reference = ColorLerpUnclamped(ColorLerpUnclamped(pixels[num4 + num7], pixels[num4 + num7 + 1], v), ColorLerpUnclamped(pixels[num5 + num7], pixels[num5 + num7 + 1], v), (float)i * num2 - (float)num3);
				}
			}
			Texture2D texture2D = new Texture2D(width, height, oldTexture.format, mipmap: false);
			texture2D.SetPixels(array);
			texture2D.Apply();
			return texture2D;
		}

		private static Color ColorLerpUnclamped(Color color1, Color color2, float v)
		{
			return new Color(color1.r + (color2.r - color1.r) * v, color1.g + (color2.g - color1.g) * v, color1.b + (color2.b - color1.b) * v, color1.a + (color2.a - color1.a) * v);
		}
	}
	public struct TexturePosition
	{
		[SerializeField]
		private List<Texture2D> _textures;

		[SerializeField]
		private Rect _position;

		public IList<Texture2D> textures
		{
			get
			{
				return _textures;
			}
			set
			{
				_textures = (List<Texture2D>)value;
			}
		}

		public Rect position
		{
			get
			{
				return _position;
			}
			set
			{
				_position = value;
			}
		}
	}
}
namespace DCM.Old
{
	[Serializable]
	[Obsolete("This Class is obsolete")]
	public class ShaderProperties
	{
		public bool markAsNormal;

		public string propertyName;

		public ShaderProperties(bool normal, string name)
		{
			markAsNormal = normal;
			propertyName = name;
		}
	}
	[Serializable]
	[Obsolete("This Class is obsolete")]
	public class TextureAtlasInfo
	{
		public int anisoLevel;

		public bool compressTexturesInMemory;

		public FilterMode filterMode;

		public bool ignoreAlpha;

		public TextureWrapMode wrapMode;

		public ShaderProperties[] shaderPropertiesToLookFor;

		public TextureAtlasInfo()
		{
			anisoLevel = 1;
			compressTexturesInMemory = true;
			filterMode = FilterMode.Trilinear;
			ignoreAlpha = true;
			wrapMode = TextureWrapMode.Clamp;
			shaderPropertiesToLookFor = new ShaderProperties[6]
			{
				new ShaderProperties(normal: false, "_MainTex"),
				new ShaderProperties(normal: true, "_BumpMap"),
				new ShaderProperties(normal: false, "_Cube"),
				new ShaderProperties(normal: false, "_DecalTex"),
				new ShaderProperties(normal: false, "_Detail"),
				new ShaderProperties(normal: false, "_ParallaxMap")
			};
		}
	}
	[Obsolete("This Class is obsolete")]
	public class MeshCombineUtility
	{
		public struct MeshInstance
		{
			public Mesh mesh;

			public int subMeshIndex;

			public Matrix4x4 transform;
		}

		public static Mesh[] Combine(MeshInstance[] combines)
		{
			int num = 0;
			int num2 = 0;
			for (int i = 0; i < combines.Length; i++)
			{
				if (combines[i].mesh != null)
				{
					num += combines[i].mesh.vertexCount;
					num2 += combines[i].mesh.GetTriangles(combines[i].subMeshIndex).Length;
				}
			}
			int j = 0;
			int num3 = Mathf.CeilToInt((float)num / 60000f);
			int num4 = num / num3;
			List<Mesh> list = new List<Mesh>();
			for (int k = 1; k <= num3; k++)
			{
				List<Vector3> list2 = new List<Vector3>(num4);
				List<Vector3> list3 = new List<Vector3>(num4);
				List<Vector4> list4 = new List<Vector4>(num4);
				List<Vector2> list5 = new List<Vector2>(num4);
				List<Vector2> list6 = new List<Vector2>(num4);
				List<Vector2> list7 = new List<Vector2>(num4);
				List<Color> list8 = new List<Color>(num4);
				List<int> list9 = new List<int>(num2 / num3);
				int num5 = 0;
				for (; j < combines.Length; j++)
				{
					if (num5 > num4)
					{
						break;
					}
					if (!(combines[j].mesh != null))
					{
						continue;
					}
					Copy(combines[j].mesh.vertices, list2, combines[j].transform);
					Matrix4x4 transform = combines[j].transform;
					transform = transform.inverse.transpose;
					CopyNormal(combines[j].mesh.normals, list3, transform);
					CopyTangents(combines[j].mesh.tangents, list4, transform);
					Copy(combines[j].mesh.uv, list5);
					Copy(combines[j].mesh.uv2, list6);
					Copy(combines[j].mesh.uv2, list7);
					if (combines[j].mesh.colors.Length == combines[j].mesh.vertexCount)
					{
						CopyColors(combines[j].mesh.colors, list8);
					}
					else
					{
						Color[] array = new Color[combines[j].mesh.vertexCount];
						for (int l = 0; l < array.Length; l++)
						{
							ref Color reference = ref array[l];
							reference = Color.white;
						}
						CopyColors(array, list8);
					}
					CopyTriangles(combines[j].mesh.GetTriangles(combines[j].subMeshIndex), list9, num5);
					num5 += combines[j].mesh.vertexCount;
				}
				Mesh mesh = new Mesh();
				mesh.name = "Combined Mesh";
				mesh.vertices = list2.ToArray();
				mesh.normals = list3.ToArray();
				mesh.colors = list8.ToArray();
				mesh.uv = list5.ToArray();
				mesh.uv2 = list6.ToArray();
				mesh.uv2 = list7.ToArray();
				mesh.tangents = list4.ToArray();
				mesh.triangles = list9.ToArray();
				list.Add(mesh);
			}
			return list.ToArray();
		}

		private static void Copy(Vector3[] src, List<Vector3> dst, Matrix4x4 transform)
		{
			for (int i = 0; i < src.Length; i++)
			{
				dst.Add(transform.MultiplyPoint(src[i]));
			}
		}

		private static void CopyNormal(Vector3[] src, List<Vector3> dst, Matrix4x4 transform)
		{
			for (int i = 0; i < src.Length; i++)
			{
				dst.Add(transform.MultiplyVector(src[i]).normalized);
			}
		}

		private static void Copy(Vector2[] src, List<Vector2> dst)
		{
			for (int i = 0; i < src.Length; i++)
			{
				dst.Add(src[i]);
			}
		}

		private static void CopyColors(Color[] src, List<Color> dst)
		{
			for (int i = 0; i < src.Length; i++)
			{
				dst.Add(src[i]);
			}
		}

		private static void CopyTangents(Vector4[] src, List<Vector4> dst, Matrix4x4 transform)
		{
			for (int i = 0; i < src.Length; i++)
			{
				Vector4 vector = src[i];
				Vector3 vector2 = new Vector3(vector.x, vector.y, vector.z);
				vector2 = transform.MultiplyVector(vector2).normalized;
				dst.Add(new Vector4(vector2.x, vector2.y, vector2.z, vector.w));
			}
		}

		private static void CopyTriangles(int[] src, List<int> dst, int vertexOffset)
		{
			for (int i = 0; i < src.Length; i++)
			{
				dst.Add(src[i] + vertexOffset);
			}
		}
	}
	[Obsolete("This Class is obsolete")]
	[AddComponentMenu("Mesh/Optimized Combine Children")]
	public class OptimizedCombineChildren : MonoBehaviour
	{
		public TextureAtlasInfo textureAtlasProperties;

		private void Start()
		{
			MeshFilter[] componentsInChildren = GetComponentsInChildren<MeshFilter>();
			Matrix4x4 worldToLocalMatrix = base.transform.worldToLocalMatrix;
			Dictionary<string, Dictionary<Material, List<MeshCombineUtility.MeshInstance>>> dictionary = new Dictionary<string, Dictionary<Material, List<MeshCombineUtility.MeshInstance>>>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				Renderer component = componentsInChildren[i].GetComponent<Renderer>();
				MeshCombineUtility.MeshInstance item = default(MeshCombineUtility.MeshInstance);
				item.mesh = componentsInChildren[i].mesh;
				if (!(component != null) || !component.enabled || !(item.mesh != null))
				{
					continue;
				}
				item.transform = worldToLocalMatrix * componentsInChildren[i].transform.localToWorldMatrix;
				Material[] sharedMaterials = component.sharedMaterials;
				for (int j = 0; j < sharedMaterials.Length; j++)
				{
					item.subMeshIndex = Math.Min(j, item.mesh.subMeshCount - 1);
					if (!dictionary.ContainsKey(sharedMaterials[j].shader.ToString()))
					{
						dictionary.Add(sharedMaterials[j].shader.ToString(), new Dictionary<Material, List<MeshCombineUtility.MeshInstance>>());
					}
					if (!dictionary[sharedMaterials[j].shader.ToString()].ContainsKey(sharedMaterials[j]))
					{
						dictionary[sharedMaterials[j].shader.ToString()].Add(sharedMaterials[j], new List<MeshCombineUtility.MeshInstance>());
					}
					dictionary[sharedMaterials[j].shader.ToString()][sharedMaterials[j]].Add(item);
				}
			}
			foreach (KeyValuePair<string, Dictionary<Material, List<MeshCombineUtility.MeshInstance>>> item2 in dictionary)
			{
				Material[] array = new Material[item2.Value.Keys.Count];
				int num = 0;
				foreach (KeyValuePair<Material, List<MeshCombineUtility.MeshInstance>> item3 in item2.Value)
				{
					array[num] = item3.Key;
					num++;
				}
				TextureCombineUtility.TexturePosition[] texturePositions;
				Material material = TextureCombineUtility.combine(array, out texturePositions, textureAtlasProperties);
				if (texturePositions == null)
				{
					continue;
				}
				List<MeshCombineUtility.MeshInstance> list = new List<MeshCombineUtility.MeshInstance>();
				foreach (KeyValuePair<Material, List<MeshCombineUtility.MeshInstance>> item4 in item2.Value)
				{
					TextureCombineUtility.TexturePosition texturePosition = texturePositions[0];
					for (int k = 0; k < texturePositions.Length; k++)
					{
						if (item4.Key.mainTexture.name == texturePositions[k].textures[0].name)
						{
							texturePosition = texturePositions[k];
							break;
						}
					}
					for (int l = 0; l < item4.Value.Count; l++)
					{
						Vector2[] uv = item4.Value[l].mesh.uv;
						for (int m = 0; m < uv.Length; m++)
						{
							uv[m].x = texturePosition.position.x + uv[m].x * texturePosition.position.width;
							uv[m].y = texturePosition.position.y + uv[m].y * texturePosition.position.height;
						}
						item4.Value[l].mesh.uv = uv;
						uv = item4.Value[l].mesh.uv2;
						for (int n = 0; n < uv.Length; n++)
						{
							uv[n].x = texturePosition.position.x + uv[n].x * texturePosition.position.width;
							uv[n].y = texturePosition.position.y + uv[n].y * texturePosition.position.height;
						}
						item4.Value[l].mesh.uv2 = uv;
						uv = item4.Value[l].mesh.uv2;
						for (int num2 = 0; num2 < uv.Length; num2++)
						{
							uv[num2].x = texturePosition.position.x + uv[num2].x * texturePosition.position.width;
							uv[num2].y = texturePosition.position.y + uv[num2].y * texturePosition.position.height;
						}
						item4.Value[l].mesh.uv2 = uv;
						list.Add(item4.Value[l]);
					}
				}
				Material sharedMaterial = material;
				Mesh[] array2 = MeshCombineUtility.Combine(list.ToArray());
				GameObject gameObject = new GameObject("Combined " + base.gameObject.name + " " + item2.Key + " Mesh Parent");
				gameObject.transform.position = base.transform.position;
				gameObject.transform.rotation = base.transform.rotation;
				for (int num3 = 0; num3 < array2.Length; num3++)
				{
					GameObject gameObject2 = new GameObject("Combined " + base.gameObject.name + " Mesh");
					gameObject2.transform.parent = gameObject.transform;
					gameObject2.tag = base.gameObject.tag;
					gameObject2.layer = base.gameObject.layer;
					gameObject2.transform.localScale = Vector3.one;
					gameObject2.transform.localRotation = Quaternion.identity;
					gameObject2.transform.localPosition = Vector3.zero;
					MeshFilter meshFilter = gameObject2.AddComponent<MeshFilter>();
					gameObject2.AddComponent<MeshRenderer>();
					gameObject2.GetComponent<Renderer>().sharedMaterial = sharedMaterial;
					meshFilter.mesh = array2[num3];
				}
			}
			MeshFilter[] array3 = componentsInChildren;
			foreach (MeshFilter obj in array3)
			{
				UnityEngine.Object.Destroy(obj);
			}
			Renderer[] componentsInChildren2 = GetComponentsInChildren<Renderer>();
			foreach (Renderer renderer in componentsInChildren2)
			{
				renderer.enabled = false;
			}
		}
	}
	[Obsolete("This Class is obsolete")]
	public class TextureCombineUtility
	{
		public struct TexturePosition
		{
			public Texture2D[] textures;

			public Rect position;
		}

		public static Material combine(Material[] combines, out TexturePosition[] texturePositions, TextureAtlasInfo atlasInfo)
		{
			if (atlasInfo == null)
			{
				Debug.LogError("atlasInfo is null. Try removing and reattaching combine children component");
				texturePositions = null;
				return null;
			}
			if (atlasInfo.shaderPropertiesToLookFor.Length <= 0)
			{
				Debug.LogError("You need to enter some shader properties to look for into Atlas Info. Cannot combine with 0 properties");
				texturePositions = null;
				return null;
			}
			List<ShaderProperties> list = new List<ShaderProperties>();
			for (int i = 0; i < atlasInfo.shaderPropertiesToLookFor.Length; i++)
			{
				if (combines[0].HasProperty(atlasInfo.shaderPropertiesToLookFor[i].propertyName))
				{
					list.Add(atlasInfo.shaderPropertiesToLookFor[i]);
				}
			}
			texturePositions = new TexturePosition[combines.Length];
			for (int j = 0; j < combines.Length; j++)
			{
				TexturePosition texturePosition = default(TexturePosition);
				texturePosition.textures = new Texture2D[list.Count];
				for (int k = 0; k < list.Count; k++)
				{
					if (combines[j].GetTexture(list[k].propertyName) == null)
					{
						Debug.LogError("Cannot combine textures when using Unity's default material texture");
						texturePositions = null;
						return null;
					}
					texturePosition.textures[k] = UnityEngine.Object.Instantiate(combines[j].GetTexture(list[k].propertyName)) as Texture2D;
					texturePosition.textures[k].name = texturePosition.textures[k].name.Remove(texturePosition.textures[k].name.IndexOf("(Clone)", StringComparison.Ordinal));
				}
				texturePositions[j] = texturePosition;
			}
			textureQuickSort(texturePositions, 0, texturePositions.Length - 1);
			for (int l = 0; l < texturePositions.Length; l++)
			{
				for (int m = 1; m < texturePositions[l].textures.Length; m++)
				{
					texturePositions[l].textures[m] = scaleTexture(texturePositions[l].textures[m], texturePositions[l].textures[0].width, texturePositions[l].textures[0].height);
				}
			}
			ref Rect position = ref texturePositions[0].position;
			float num = 0f;
			texturePositions[0].position.y = num;
			position.x = num;
			texturePositions[0].position.width = texturePositions[0].textures[0].width;
			texturePositions[0].position.height = texturePositions[0].textures[0].height;
			int num2 = texturePositions[0].textures[0].height;
			int num3 = texturePositions[0].textures[0].width;
			int num4 = num3;
			int num5 = 0;
			bool flag = true;
			for (int n = 1; n < texturePositions.Length; n++)
			{
				texturePositions[n].position.x = num4;
				texturePositions[n].position.y = num5;
				texturePositions[n].position.width = texturePositions[n].textures[0].width;
				texturePositions[n].position.height = texturePositions[n].textures[0].height;
				if (flag)
				{
					if (num4 + texturePositions[n].textures[0].width > num3)
					{
						num3 = num4 + texturePositions[n].textures[0].width;
					}
					num5 += texturePositions[n].textures[0].height;
					if (num5 >= num2)
					{
						flag = false;
						num2 = num5;
						num5 = num2;
						num4 = 0;
					}
				}
				else
				{
					if (num5 + texturePositions[n].textures[0].height > num2)
					{
						num2 = num5 + texturePositions[n].textures[0].height;
					}
					num4 += texturePositions[n].textures[0].width;
					if (num4 >= num3)
					{
						flag = true;
						num3 = num4;
						num4 = num3;
						num5 = 0;
					}
				}
			}
			if (num2 > num3)
			{
				num3 = num2;
			}
			else
			{
				num2 = num3;
			}
			float num6 = 1f / (float)num2;
			Material material = new Material(combines[0]);
			for (int num7 = 0; num7 < list.Count; num7++)
			{
				Texture2D texture2D = new Texture2D(num3, num2, (!atlasInfo.ignoreAlpha || list[num7].markAsNormal) ? TextureFormat.ARGB32 : TextureFormat.RGB24, mipmap: true);
				texture2D.anisoLevel = atlasInfo.anisoLevel;
				texture2D.filterMode = atlasInfo.filterMode;
				texture2D.wrapMode = atlasInfo.wrapMode;
				for (int num8 = 0; num8 < texturePositions.Length; num8++)
				{
					texture2D.SetPixels((int)texturePositions[num8].position.x, (int)texturePositions[num8].position.y, texturePositions[num8].textures[num7].width, texturePositions[num8].textures[num7].height, texturePositions[num8].textures[num7].GetPixels());
				}
				texture2D.Apply();
				if (atlasInfo.compressTexturesInMemory)
				{
					texture2D.Compress(highQuality: true);
				}
				material.SetTexture(list[num7].propertyName, texture2D);
			}
			for (int num9 = 0; num9 < texturePositions.Length; num9++)
			{
				texturePositions[num9].position.x = texturePositions[num9].position.x * num6;
				texturePositions[num9].position.y = texturePositions[num9].position.y * num6;
				texturePositions[num9].position.width = texturePositions[num9].position.width * num6;
				texturePositions[num9].position.height = texturePositions[num9].position.height * num6;
			}
			return material;
		}

		private static void textureQuickSort(TexturePosition[] textures, int low, int high)
		{
			if (low < high)
			{
				int num = partition(textures, low, high);
				textureQuickSort(textures, low, num - 1);
				textureQuickSort(textures, num + 1, high);
			}
		}

		private static int partition(TexturePosition[] texturePositions, int low, int high)
		{
			int num = low;
			TexturePosition texturePosition = texturePositions[num];
			for (int i = low + 1; i <= high; i++)
			{
				if (texturePositions[i].textures[0].height > texturePosition.textures[0].height)
				{
					num++;
					swap(texturePositions, num, i);
				}
			}
			swap(texturePositions, low, num);
			return num;
		}

		private static void swap(TexturePosition[] textures, int i, int j)
		{
			TexturePosition texturePosition = textures[i];
			ref TexturePosition reference = ref textures[i];
			reference = textures[j];
			textures[j] = texturePosition;
		}

		private static Texture2D scaleTexture(Texture2D oldTexture, int width, int height)
		{
			Color[] pixels = oldTexture.GetPixels();
			Color[] array = new Color[width * height];
			float num = 1f / ((float)width / (float)(oldTexture.width - 1));
			float num2 = 1f / ((float)height / (float)(oldTexture.height - 1));
			int width2 = oldTexture.width;
			for (int i = 0; i < height; i++)
			{
				int num3 = Mathf.FloorToInt((float)i * num2);
				int num4 = num3 * width2;
				int num5 = (num3 + 1) * width2;
				int num6 = i * width;
				for (int j = 0; j < width; j++)
				{
					int num7 = Mathf.FloorToInt((float)j * num);
					float v = (float)j * num - (float)num7;
					ref Color reference = ref array[num6 + j];
					reference = colorLerpUnclamped(colorLerpUnclamped(pixels[num4 + num7], pixels[num4 + num7 + 1], v), colorLerpUnclamped(pixels[num5 + num7], pixels[num5 + num7 + 1], v), (float)i * num2 - (float)num3);
				}
			}
			Texture2D texture2D = new Texture2D(width, height, oldTexture.format, mipmap: false);
			texture2D.SetPixels(array);
			texture2D.Apply();
			return texture2D;
		}

		private static Color colorLerpUnclamped(Color color1, Color color2, float v)
		{
			return new Color(color1.r + (color2.r - color1.r) * v, color1.g + (color2.g - color1.g) * v, color1.b + (color2.b - color1.b) * v, color1.a + (color2.a - color1.a) * v);
		}
	}
}
public class IOCcam : MonoBehaviour
{
	public LayerMask layerMsk;

	public string iocTag;

	public int samples;

	public float raysFov;

	public bool preCullCheck;

	public float viewDistance;

	public int hideDelay;

	public bool realtimeShadows;

	public float lod1Distance;

	public float lod2Distance;

	public float lodMargin;

	private RaycastHit hit;

	private Ray r;

	private int layerMask;

	private IOClod l;

	private int haltonIndex;

	private float[] hx;

	private float[] hy;

	private int pixels;

	private Camera cam;

	private Camera rayCaster;

	private void Awake()
	{
		cam = GetComponent<Camera>();
		hit = default(RaycastHit);
		if (viewDistance == 0f)
		{
			viewDistance = 100f;
		}
		cam.farClipPlane = viewDistance;
		haltonIndex = 0;
		if (GetComponent<SphereCollider>() == null)
		{
			SphereCollider sphereCollider = base.gameObject.AddComponent<SphereCollider>();
			sphereCollider.radius = 1f;
			sphereCollider.isTrigger = true;
		}
	}

	private void Start()
	{
		pixels = Mathf.FloorToInt((float)(Screen.width * Screen.height) / 4f);
		hx = new float[pixels];
		hy = new float[pixels];
		for (int i = 0; i < pixels; i++)
		{
			hx[i] = HaltonSequence(i, 2);
			hy[i] = HaltonSequence(i, 3);
		}
		UnityEngine.Object[] array = UnityEngine.Object.FindObjectsOfType(typeof(GameObject));
		for (int j = 0; j < array.Length; j++)
		{
			GameObject gameObject = (GameObject)array[j];
			if (gameObject.tag == iocTag && gameObject.GetComponent<IOClod>() == null)
			{
				gameObject.AddComponent<IOClod>();
			}
		}
		GameObject gameObject2 = new GameObject("RayCaster");
		gameObject2.transform.Translate(base.transform.position);
		gameObject2.transform.rotation = base.transform.rotation;
		rayCaster = gameObject2.AddComponent<Camera>();
		rayCaster.enabled = false;
		rayCaster.clearFlags = CameraClearFlags.Nothing;
		rayCaster.cullingMask = 0;
		rayCaster.aspect = cam.aspect;
		rayCaster.nearClipPlane = cam.nearClipPlane;
		rayCaster.farClipPlane = cam.farClipPlane;
		rayCaster.fieldOfView = raysFov;
		gameObject2.transform.parent = base.transform;
	}

	private void Update()
	{
		for (int i = 0; i <= samples; i++)
		{
			r = rayCaster.ViewportPointToRay(new Vector3(hx[haltonIndex], hy[haltonIndex], 0f));
			haltonIndex++;
			if (haltonIndex >= pixels)
			{
				haltonIndex = 0;
			}
			if (Physics.Raycast(r, out hit, viewDistance, layerMsk.value))
			{
				if ((bool)(l = hit.transform.GetComponent<IOClod>()))
				{
					l.UnHide(hit);
				}
				else if ((bool)(l = hit.transform.parent.GetComponent<IOClod>()))
				{
					l.UnHide(hit);
				}
			}
		}
	}

	private float HaltonSequence(int index, int b)
	{
		float num = 0f;
		float num2 = 1f / (float)b;
		int num3 = index;
		while (num3 > 0)
		{
			num += num2 * (float)(num3 % b);
			num3 = Mathf.FloorToInt(num3 / b);
			num2 /= (float)b;
		}
		return num;
	}
}
public class IOClod : MonoBehaviour
{
	public float Lod1;

	public float Lod2;

	public float LodMargin;

	public bool LodOnly;

	private Vector3 hitPoint;

	private float lod_1;

	private float lod_2;

	private float lodMargin;

	private bool realtimeShadows;

	private IOCcam iocCam;

	private int counter;

	private Renderer[] rs0;

	private Renderer[] rs1;

	private Renderer[] rs2;

	private Renderer[] rs;

	private bool hidden;

	private int currentLod;

	private float prevDist;

	private float distOffset;

	private int lods;

	private float dt;

	private float hitTimeOffset;

	private float prevHitTime;

	private bool sleeping;

	private Shader shInvisible;

	private Shader[][] sh;

	private Shader[][] sh0;

	private float distanceFromCam;

	private float shadowDistance;

	private int frameInterval;

	private RaycastHit h;

	private Ray r;

	private bool visible;

	private void Awake()
	{
		shadowDistance = QualitySettings.shadowDistance * 2f;
		iocCam = Camera.main.GetComponent<IOCcam>();
		if (iocCam == null)
		{
			base.enabled = false;
			return;
		}
		prevDist = 0f;
		prevHitTime = Time.time;
		sleeping = true;
		h = default(RaycastHit);
	}

	private void Start()
	{
		UpdateValues();
		if ((bool)base.transform.Find("Lod_0"))
		{
			lods = 1;
			rs0 = base.transform.Find("Lod_0").GetComponentsInChildren<Renderer>(includeInactive: false);
			sh0 = new Shader[rs0.Length][];
			for (int i = 0; i < rs0.Length; i++)
			{
				sh0[i] = new Shader[rs0[i].materials.Length];
				for (int j = 0; j < rs0[i].materials.Length; j++)
				{
					sh0[i][j] = rs0[i].materials[j].shader;
				}
			}
			if ((bool)base.transform.Find("Lod_1"))
			{
				lods++;
				rs1 = base.transform.Find("Lod_1").GetComponentsInChildren<Renderer>(includeInactive: false);
				if ((bool)base.transform.Find("Lod_2"))
				{
					lods++;
					rs2 = base.transform.Find("Lod_2").GetComponentsInChildren<Renderer>(includeInactive: false);
				}
			}
		}
		else
		{
			lods = 0;
		}
		rs = GetComponentsInChildren<Renderer>(includeInactive: false);
		sh = new Shader[rs.Length][];
		for (int k = 0; k < rs.Length; k++)
		{
			sh[k] = new Shader[rs[k].materials.Length];
			for (int l = 0; l < rs[k].materials.Length; l++)
			{
				sh[k][l] = rs[k].materials[l].shader;
			}
		}
		shInvisible = Shader.Find("Custom/Invisible");
		Initialize();
	}

	public void Initialize()
	{
		if (iocCam.enabled)
		{
			HideAll();
			return;
		}
		base.enabled = false;
		ShowLod(1f);
	}

	private void Update()
	{
		frameInterval = Time.frameCount % 4;
		if (frameInterval == 0)
		{
			switch (LodOnly)
			{
			case false:
				if (hidden || Time.frameCount - counter <= iocCam.hideDelay)
				{
					break;
				}
				switch (currentLod)
				{
				case 0:
					visible = rs0[0].isVisible;
					break;
				case 1:
					visible = rs1[0].isVisible;
					break;
				case 2:
					visible = rs2[0].isVisible;
					break;
				default:
					visible = rs[0].isVisible;
					break;
				}
				if (iocCam.preCullCheck && visible)
				{
					Vector3 vector = base.transform.localToWorldMatrix.MultiplyPoint(hitPoint);
					r = new Ray(vector, iocCam.transform.position - vector);
					if (Physics.Raycast(r, out h, iocCam.viewDistance))
					{
						if (h.transform.tag != iocCam.tag)
						{
							Hide();
						}
						else
						{
							counter = Time.frameCount;
						}
					}
				}
				else
				{
					Hide();
				}
				break;
			case true:
				if (!sleeping && Time.frameCount - counter > iocCam.hideDelay)
				{
					ShowLod(3000f);
					sleeping = true;
				}
				break;
			}
		}
		else
		{
			if (!realtimeShadows || frameInterval != 2)
			{
				return;
			}
			distanceFromCam = Vector3.Distance(base.transform.position, iocCam.transform.position);
			if (!hidden)
			{
				return;
			}
			if (lods == 0)
			{
				if (distanceFromCam > shadowDistance)
				{
					if (!rs[0].enabled)
					{
						return;
					}
					for (int i = 0; i < rs.Length; i++)
					{
						rs[i].enabled = false;
						for (int j = 0; j < rs[i].materials.Length; j++)
						{
							rs[i].materials[j].shader = sh[i][j];
						}
					}
				}
				else
				{
					if (rs[0].enabled)
					{
						return;
					}
					for (int k = 0; k < rs.Length; k++)
					{
						Material[] materials = rs[k].materials;
						foreach (Material material in materials)
						{
							material.shader = shInvisible;
						}
						rs[k].enabled = true;
					}
				}
			}
			else if (distanceFromCam > shadowDistance)
			{
				if (!rs0[0].enabled)
				{
					return;
				}
				for (int m = 0; m < rs0.Length; m++)
				{
					rs0[m].enabled = false;
					for (int n = 0; n < rs0[m].materials.Length; n++)
					{
						rs0[m].materials[n].shader = sh0[m][n];
					}
				}
			}
			else
			{
				if (rs0[0].enabled)
				{
					return;
				}
				for (int num = 0; num < rs0.Length; num++)
				{
					Material[] materials2 = rs0[num].materials;
					foreach (Material material2 in materials2)
					{
						material2.shader = shInvisible;
					}
					rs0[num].enabled = true;
				}
			}
		}
	}

	public void UpdateValues()
	{
		if (Lod1 != 0f)
		{
			lod_1 = Lod1;
		}
		else
		{
			lod_1 = iocCam.lod1Distance;
		}
		if (Lod2 != 0f)
		{
			lod_2 = Lod2;
		}
		else
		{
			lod_2 = iocCam.lod2Distance;
		}
		if (LodMargin != 0f)
		{
			lodMargin = LodMargin;
		}
		else
		{
			lodMargin = iocCam.lodMargin;
		}
		realtimeShadows = iocCam.realtimeShadows;
	}

	public void UnHide(RaycastHit h)
	{
		counter = Time.frameCount;
		hitPoint = base.transform.worldToLocalMatrix.MultiplyPoint(h.point);
		if (hidden)
		{
			hidden = false;
			ShowLod(h.distance);
		}
		else if (lods > 0)
		{
			distOffset = prevDist - h.distance;
			hitTimeOffset = Time.time - prevHitTime;
			prevHitTime = Time.time;
			if ((Mathf.Abs(distOffset) > lodMargin) | (hitTimeOffset > 1f))
			{
				ShowLod(h.distance);
				prevDist = h.distance;
				sleeping = false;
			}
		}
	}

	public void ShowLod(float d)
	{
		int num = 0;
		switch (lods)
		{
		case 0:
			currentLod = -1;
			break;
		case 2:
			if (d < lod_1)
			{
				currentLod = 0;
			}
			else
			{
				currentLod = 1;
			}
			break;
		case 3:
			if (d < lod_1)
			{
				currentLod = 0;
			}
			else if ((d > lod_1) & (d < lod_2))
			{
				currentLod = 1;
			}
			else
			{
				currentLod = 2;
			}
			break;
		}
		switch (currentLod)
		{
		case 0:
			if (!LodOnly && rs0[0].enabled)
			{
				for (num = 0; num < rs0.Length; num++)
				{
					for (int k = 0; k < rs0[num].materials.Length; k++)
					{
						rs0[num].materials[k].shader = sh0[num][k];
					}
				}
			}
			else
			{
				for (num = 0; num < rs0.Length; num++)
				{
					rs0[num].enabled = true;
				}
			}
			for (num = 0; num < rs1.Length; num++)
			{
				rs1[num].enabled = false;
			}
			if (lods == 3)
			{
				for (num = 0; num < rs2.Length; num++)
				{
					rs2[num].enabled = false;
				}
			}
			return;
		case 1:
			for (num = 0; num < rs1.Length; num++)
			{
				rs1[num].enabled = true;
			}
			for (num = 0; num < rs0.Length; num++)
			{
				rs0[num].enabled = false;
				if (!LodOnly && realtimeShadows)
				{
					for (int i = 0; i < rs0[num].materials.Length; i++)
					{
						rs0[num].materials[i].shader = sh0[num][i];
					}
				}
			}
			if (lods == 3)
			{
				for (num = 0; num < rs2.Length; num++)
				{
					rs2[num].enabled = false;
				}
			}
			return;
		case 2:
			for (num = 0; num < rs2.Length; num++)
			{
				rs2[num].enabled = true;
			}
			for (num = 0; num < rs0.Length; num++)
			{
				rs0[num].enabled = false;
				if (!LodOnly && realtimeShadows)
				{
					for (int j = 0; j < rs0[num].materials.Length; j++)
					{
						rs0[num].materials[j].shader = sh0[num][j];
					}
				}
			}
			for (num = 0; num < rs1.Length; num++)
			{
				rs1[num].enabled = false;
			}
			return;
		}
		if (!LodOnly && rs[0].enabled)
		{
			for (num = 0; num < rs.Length; num++)
			{
				for (int l = 0; l < rs[num].materials.Length; l++)
				{
					rs[num].materials[l].shader = sh[num][l];
				}
			}
		}
		else
		{
			for (num = 0; num < rs.Length; num++)
			{
				rs[num].enabled = true;
			}
		}
	}

	public void Hide()
	{
		int num = 0;
		hidden = true;
		switch (currentLod)
		{
		case 0:
			if (realtimeShadows && distanceFromCam <= shadowDistance)
			{
				for (num = 0; num < rs0.Length; num++)
				{
					Material[] materials = rs0[num].materials;
					foreach (Material material in materials)
					{
						material.shader = shInvisible;
					}
				}
			}
			else
			{
				for (num = 0; num < rs0.Length; num++)
				{
					rs0[num].enabled = false;
				}
			}
			return;
		case 1:
			for (num = 0; num < rs1.Length; num++)
			{
				rs1[num].enabled = false;
			}
			return;
		case 2:
			for (num = 0; num < rs2.Length; num++)
			{
				rs2[num].enabled = false;
			}
			return;
		}
		if (realtimeShadows && distanceFromCam <= shadowDistance)
		{
			for (num = 0; num < rs.Length; num++)
			{
				Material[] materials2 = rs[num].materials;
				foreach (Material material2 in materials2)
				{
					material2.shader = shInvisible;
				}
			}
		}
		else
		{
			for (num = 0; num < rs.Length; num++)
			{
				rs[num].enabled = false;
			}
		}
	}

	public void HideAll()
	{
		int num = 0;
		switch (LodOnly)
		{
		case false:
			hidden = true;
			if (lods == 0 && rs != null)
			{
				for (num = 0; num < rs.Length; num++)
				{
					rs[num].enabled = false;
					if (realtimeShadows)
					{
						for (int i = 0; i < rs[num].materials.Length; i++)
						{
							rs[num].materials[i].shader = sh[num][i];
						}
					}
				}
				break;
			}
			for (num = 0; num < rs0.Length; num++)
			{
				rs0[num].enabled = false;
				if (realtimeShadows)
				{
					for (int j = 0; j < rs0[num].materials.Length; j++)
					{
						rs0[num].materials[j].shader = sh0[num][j];
					}
				}
			}
			for (num = 0; num < rs1.Length; num++)
			{
				rs1[num].enabled = false;
			}
			if (rs2 != null)
			{
				for (num = 0; num < rs2.Length; num++)
				{
					rs2[num].enabled = false;
				}
			}
			break;
		case true:
			prevHitTime -= 3f;
			ShowLod(3000f);
			break;
		}
	}
}
public class IOChud : MonoBehaviour
{
	private Texture2D Icon;

	private bool iocActive;

	private IOCcam ioc;

	private bool realtimeShadows;

	private bool hud;

	private bool dirty;

	private void Awake()
	{
		Icon = (Texture2D)Resources.Load("Icon");
		hud = false;
		dirty = false;
	}

	private void Start()
	{
		ioc = Camera.main.transform.GetComponent<IOCcam>();
		iocActive = ioc.enabled;
	}

	private void Update()
	{
		if (Input.GetKeyUp(KeyCode.I))
		{
			iocActive = !iocActive;
			ToggleIOC();
		}
		if (Input.GetKeyUp(KeyCode.Escape))
		{
			ToggleHUD();
		}
		if (Input.GetMouseButtonUp(0) && dirty)
		{
			ToggleIOC();
			dirty = false;
		}
	}

	private void OnGUI()
	{
		GUI.Label(new Rect(25f, 10f, 360f, 20f), "Press 'i' to toggle InstantOC - Press 'Esc' to toggle HUD");
		if (hud)
		{
			GUI.Label(new Rect(25f, 35f, 320f, 20f), "Samples");
			ioc.samples = Mathf.RoundToInt(GUI.HorizontalSlider(new Rect(25f, 55f, 150f, 20f), ioc.samples, 10f, 1500f));
			GUI.Label(new Rect(180f, 50f, 50f, 20f), ioc.samples.ToString());
			GUI.Label(new Rect(25f, 65f, 320f, 20f), "Hide delay");
			ioc.hideDelay = Mathf.RoundToInt(GUI.HorizontalSlider(new Rect(25f, 85f, 150f, 20f), ioc.hideDelay, 10f, 300f));
			GUI.Label(new Rect(180f, 80f, 50f, 20f), ioc.hideDelay.ToString());
			GUI.Label(new Rect(25f, 95f, 320f, 20f), "View Distance");
			ioc.viewDistance = Mathf.RoundToInt(GUI.HorizontalSlider(new Rect(25f, 115f, 150f, 20f), ioc.viewDistance, 100f, 3000f));
			GUI.Label(new Rect(180f, 110f, 50f, 20f), ioc.viewDistance.ToString());
			GUI.Label(new Rect(25f, 125f, 320f, 20f), "Lod 1");
			ioc.lod1Distance = Mathf.Round(GUI.HorizontalSlider(new Rect(25f, 145f, 150f, 20f), ioc.lod1Distance, 10f, 300f));
			GUI.Label(new Rect(180f, 140f, 50f, 20f), ioc.lod1Distance.ToString());
			GUI.Label(new Rect(25f, 155f, 320f, 20f), "Lod 2");
			ioc.lod2Distance = Mathf.Round(GUI.HorizontalSlider(new Rect(25f, 175f, 150f, 20f), ioc.lod2Distance, 10f, 600f));
			GUI.Label(new Rect(180f, 170f, 50f, 20f), ioc.lod2Distance.ToString());
			GUI.Label(new Rect(25f, 185f, 320f, 20f), "Lod margin");
			ioc.lodMargin = Mathf.Round(GUI.HorizontalSlider(new Rect(25f, 205f, 150f, 20f), ioc.lodMargin, 1f, 100f));
			GUI.Label(new Rect(180f, 200f, 50f, 20f), ioc.lodMargin.ToString());
		}
		if (iocActive)
		{
			GUI.Label(new Rect((float)Screen.width - 74f, 10f, 64f, 64f), Icon);
		}
		if (GUI.changed)
		{
			dirty = true;
		}
	}

	private void ToggleHUD()
	{
		hud = !hud;
		try
		{
			ioc.GetComponent<MouseLook>().enabled = !ioc.GetComponent<MouseLook>().enabled;
			ioc.transform.parent.GetComponent<MouseLook>().enabled = !ioc.transform.parent.GetComponent<MouseLook>().enabled;
		}
		catch
		{
		}
	}

	private void ToggleIOC()
	{
		ioc.enabled = iocActive;
		GameObject[] array = UnityEngine.Object.FindObjectsOfType(typeof(GameObject)) as GameObject[];
		GameObject[] array2 = array;
		foreach (GameObject gameObject in array2)
		{
			IOClod component = gameObject.GetComponent<IOClod>();
			if (component != null)
			{
				switch (iocActive)
				{
				case true:
					component.UpdateValues();
					component.Initialize();
					component.enabled = true;
					break;
				case false:
					component.enabled = false;
					component.UpdateValues();
					component.Initialize();
					break;
				}
			}
		}
	}
}
public class iTween : MonoBehaviour
{
	private delegate float EasingFunction(float start, float end, float value);

	private delegate void ApplyTween();

	public enum EaseType
	{
		easeInQuad,
		easeOutQuad,
		easeInOutQuad,
		easeInCubic,
		easeOutCubic,
		easeInOutCubic,
		easeInQuart,
		easeOutQuart,
		easeInOutQuart,
		easeInQuint,
		easeOutQuint,
		easeInOutQuint,
		easeInSine,
		easeOutSine,
		easeInOutSine,
		easeInExpo,
		easeOutExpo,
		easeInOutExpo,
		easeInCirc,
		easeOutCirc,
		easeInOutCirc,
		linear,
		spring,
		easeInBounce,
		easeOutBounce,
		easeInOutBounce,
		easeInBack,
		easeOutBack,
		easeInOutBack,
		easeInElastic,
		easeOutElastic,
		easeInOutElastic,
		punch
	}

	public enum LoopType
	{
		none,
		loop,
		pingPong
	}

	public enum NamedValueColor
	{
		_Color,
		_SpecColor,
		_Emission,
		_ReflectColor
	}

	public static class Defaults
	{
		public static float time = 1f;

		public static float delay = 0f;

		public static NamedValueColor namedColorValue = NamedValueColor._Color;

		public static LoopType loopType = LoopType.none;

		public static EaseType easeType = EaseType.easeOutExpo;

		public static float lookSpeed = 3f;

		public static bool isLocal = false;

		public static Space space = Space.Self;

		public static bool orientToPath = false;

		public static Color color = Color.white;

		public static float updateTimePercentage = 0.05f;

		public static float updateTime = 1f * updateTimePercentage;

		public static int cameraFadeDepth = 999999;

		public static float lookAhead = 0.05f;

		public static bool useRealTime = false;

		public static Vector3 up = Vector3.up;
	}

	private class CRSpline
	{
		public Vector3[] pts;

		public CRSpline(params Vector3[] pts)
		{
			this.pts = new Vector3[pts.Length];
			Array.Copy(pts, this.pts, pts.Length);
		}

		public Vector3 Interp(float t)
		{
			int num = pts.Length - 3;
			int num2 = Mathf.Min(Mathf.FloorToInt(t * (float)num), num - 1);
			float num3 = t * (float)num - (float)num2;
			Vector3 vector = pts[num2];
			Vector3 vector2 = pts[num2 + 1];
			Vector3 vector3 = pts[num2 + 2];
			Vector3 vector4 = pts[num2 + 3];
			return 0.5f * ((-vector + 3f * vector2 - 3f * vector3 + vector4) * (num3 * num3 * num3) + (2f * vector - 5f * vector2 + 4f * vector3 - vector4) * (num3 * num3) + (-vector + vector3) * num3 + 2f * vector2);
		}
	}

	public static ArrayList tweens = new ArrayList();

	private static GameObject cameraFade;

	public string id;

	public string type;

	public string method;

	public EaseType easeType;

	public float time;

	public float delay;

	public LoopType loopType;

	public bool isRunning;

	public bool isPaused;

	public string _name;

	private float runningTime;

	private float percentage;

	private float delayStarted;

	private bool kinematic;

	private bool isLocal;

	private bool loop;

	private bool reverse;

	private bool wasPaused;

	private bool physics;

	private Hashtable tweenArguments;

	private Space space;

	private EasingFunction ease;

	private ApplyTween apply;

	private AudioSource audioSource;

	private Vector3[] vector3s;

	private Vector2[] vector2s;

	private Color[,] colors;

	private float[] floats;

	private Rect[] rects;

	private CRSpline path;

	private Vector3 preUpdate;

	private Vector3 postUpdate;

	private NamedValueColor namedcolorvalue;

	private float lastRealTime;

	private bool useRealTime;

	public static void Init(GameObject target)
	{
		MoveBy(target, Vector3.zero, 0f);
	}

	public static void CameraFadeFrom(float amount, float time)
	{
		if ((bool)cameraFade)
		{
			CameraFadeFrom(Hash("amount", amount, "time", time));
		}
		else
		{
			Debug.LogError("iTween Error: You must first add a camera fade object with CameraFadeAdd() before atttempting to use camera fading.");
		}
	}

	public static void CameraFadeFrom(Hashtable args)
	{
		if ((bool)cameraFade)
		{
			ColorFrom(cameraFade, args);
		}
		else
		{
			Debug.LogError("iTween Error: You must first add a camera fade object with CameraFadeAdd() before atttempting to use camera fading.");
		}
	}

	public static void CameraFadeTo(float amount, float time)
	{
		if ((bool)cameraFade)
		{
			CameraFadeTo(Hash("amount", amount, "time", time));
		}
		else
		{
			Debug.LogError("iTween Error: You must first add a camera fade object with CameraFadeAdd() before atttempting to use camera fading.");
		}
	}

	public static void CameraFadeTo(Hashtable args)
	{
		if ((bool)cameraFade)
		{
			ColorTo(cameraFade, args);
		}
		else
		{
			Debug.LogError("iTween Error: You must first add a camera fade object with CameraFadeAdd() before atttempting to use camera fading.");
		}
	}

	public static void ValueTo(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		if (!args.Contains("onupdate") || !args.Contains("from") || !args.Contains("to"))
		{
			Debug.LogError("iTween Error: ValueTo() requires an 'onupdate' callback function and a 'from' and 'to' property.  The supplied 'onupdate' callback must accept a single argument that is the same type as the supplied 'from' and 'to' properties!");
			return;
		}
		args["type"] = "value";
		if (args["from"].GetType() == typeof(Vector2))
		{
			args["method"] = "vector2";
		}
		else if (args["from"].GetType() == typeof(Vector3))
		{
			args["method"] = "vector3";
		}
		else if (args["from"].GetType() == typeof(Rect))
		{
			args["method"] = "rect";
		}
		else if (args["from"].GetType() == typeof(float))
		{
			args["method"] = "float";
		}
		else
		{
			if (args["from"].GetType() != typeof(Color))
			{
				Debug.LogError("iTween Error: ValueTo() only works with interpolating Vector3s, Vector2s, floats, ints, Rects and Colors!");
				return;
			}
			args["method"] = "color";
		}
		if (!args.Contains("easetype"))
		{
			args.Add("easetype", EaseType.linear);
		}
		Launch(target, args);
	}

	public static void FadeFrom(GameObject target, float alpha, float time)
	{
		FadeFrom(target, Hash("alpha", alpha, "time", time));
	}

	public static void FadeFrom(GameObject target, Hashtable args)
	{
		ColorFrom(target, args);
	}

	public static void FadeTo(GameObject target, float alpha, float time)
	{
		FadeTo(target, Hash("alpha", alpha, "time", time));
	}

	public static void FadeTo(GameObject target, Hashtable args)
	{
		ColorTo(target, args);
	}

	public static void ColorFrom(GameObject target, Color color, float time)
	{
		ColorFrom(target, Hash("color", color, "time", time));
	}

	public static void ColorFrom(GameObject target, Hashtable args)
	{
		Color color = default(Color);
		Color color2 = default(Color);
		args = CleanArgs(args);
		if (!args.Contains("includechildren") || (bool)args["includechildren"])
		{
			foreach (Transform item in target.transform)
			{
				Hashtable hashtable = (Hashtable)args.Clone();
				hashtable["ischild"] = true;
				ColorFrom(item.gameObject, hashtable);
			}
		}
		if (!args.Contains("easetype"))
		{
			args.Add("easetype", EaseType.linear);
		}
		if ((bool)target.GetComponent(typeof(GUITexture)))
		{
			color2 = (color = target.GetComponent<GUITexture>().color);
		}
		else if ((bool)target.GetComponent(typeof(GUIText)))
		{
			color2 = (color = target.GetComponent<GUIText>().material.color);
		}
		else if ((bool)target.GetComponent<Renderer>())
		{
			color2 = (color = target.GetComponent<Renderer>().material.color);
		}
		else if ((bool)target.GetComponent<Light>())
		{
			color2 = (color = target.GetComponent<Light>().color);
		}
		if (args.Contains("color"))
		{
			color = (Color)args["color"];
		}
		else
		{
			if (args.Contains("r"))
			{
				color.r = (float)args["r"];
			}
			if (args.Contains("g"))
			{
				color.g = (float)args["g"];
			}
			if (args.Contains("b"))
			{
				color.b = (float)args["b"];
			}
			if (args.Contains("a"))
			{
				color.a = (float)args["a"];
			}
		}
		if (args.Contains("amount"))
		{
			color.a = (float)args["amount"];
			args.Remove("amount");
		}
		else if (args.Contains("alpha"))
		{
			color.a = (float)args["alpha"];
			args.Remove("alpha");
		}
		if ((bool)target.GetComponent(typeof(GUITexture)))
		{
			target.GetComponent<GUITexture>().color = color;
		}
		else if ((bool)target.GetComponent(typeof(GUIText)))
		{
			target.GetComponent<GUIText>().material.color = color;
		}
		else if ((bool)target.GetComponent<Renderer>())
		{
			target.GetComponent<Renderer>().material.color = color;
		}
		else if ((bool)target.GetComponent<Light>())
		{
			target.GetComponent<Light>().color = color;
		}
		args["color"] = color2;
		args["type"] = "color";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void ColorTo(GameObject target, Color color, float time)
	{
		ColorTo(target, Hash("color", color, "time", time));
	}

	public static void ColorTo(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		if (!args.Contains("includechildren") || (bool)args["includechildren"])
		{
			foreach (Transform item in target.transform)
			{
				Hashtable hashtable = (Hashtable)args.Clone();
				hashtable["ischild"] = true;
				ColorTo(item.gameObject, hashtable);
			}
		}
		if (!args.Contains("easetype"))
		{
			args.Add("easetype", EaseType.linear);
		}
		args["type"] = "color";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void AudioFrom(GameObject target, float volume, float pitch, float time)
	{
		AudioFrom(target, Hash("volume", volume, "pitch", pitch, "time", time));
	}

	public static void AudioFrom(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		AudioSource audioSource;
		if (args.Contains("audiosource"))
		{
			audioSource = (AudioSource)args["audiosource"];
		}
		else
		{
			if (!target.GetComponent(typeof(AudioSource)))
			{
				Debug.LogError("iTween Error: AudioFrom requires an AudioSource.");
				return;
			}
			audioSource = target.GetComponent<AudioSource>();
		}
		Vector2 vector = default(Vector2);
		Vector2 vector2 = default(Vector2);
		vector.x = (vector2.x = audioSource.volume);
		vector.y = (vector2.y = audioSource.pitch);
		if (args.Contains("volume"))
		{
			vector2.x = (float)args["volume"];
		}
		if (args.Contains("pitch"))
		{
			vector2.y = (float)args["pitch"];
		}
		audioSource.volume = vector2.x;
		audioSource.pitch = vector2.y;
		args["volume"] = vector.x;
		args["pitch"] = vector.y;
		if (!args.Contains("easetype"))
		{
			args.Add("easetype", EaseType.linear);
		}
		args["type"] = "audio";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void AudioTo(GameObject target, float volume, float pitch, float time)
	{
		AudioTo(target, Hash("volume", volume, "pitch", pitch, "time", time));
	}

	public static void AudioTo(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		if (!args.Contains("easetype"))
		{
			args.Add("easetype", EaseType.linear);
		}
		args["type"] = "audio";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void Stab(GameObject target, AudioClip audioclip, float delay)
	{
		Stab(target, Hash("audioclip", audioclip, "delay", delay));
	}

	public static void Stab(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "stab";
		Launch(target, args);
	}

	public static void LookFrom(GameObject target, Vector3 looktarget, float time)
	{
		LookFrom(target, Hash("looktarget", looktarget, "time", time));
	}

	public static void LookFrom(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		Vector3 eulerAngles = target.transform.eulerAngles;
		if (args["looktarget"].GetType() == typeof(Transform))
		{
			Transform obj = target.transform;
			Transform target2 = (Transform)args["looktarget"];
			Vector3? vector = (Vector3?)args["up"];
			obj.LookAt(target2, (!vector.HasValue) ? Defaults.up : vector.Value);
		}
		else if (args["looktarget"].GetType() == typeof(Vector3))
		{
			Transform obj2 = target.transform;
			Vector3 worldPosition = (Vector3)args["looktarget"];
			Vector3? vector2 = (Vector3?)args["up"];
			obj2.LookAt(worldPosition, (!vector2.HasValue) ? Defaults.up : vector2.Value);
		}
		if (args.Contains("axis"))
		{
			Vector3 eulerAngles2 = target.transform.eulerAngles;
			switch ((string)args["axis"])
			{
			case "x":
				eulerAngles2.y = eulerAngles.y;
				eulerAngles2.z = eulerAngles.z;
				break;
			case "y":
				eulerAngles2.x = eulerAngles.x;
				eulerAngles2.z = eulerAngles.z;
				break;
			case "z":
				eulerAngles2.x = eulerAngles.x;
				eulerAngles2.y = eulerAngles.y;
				break;
			}
			target.transform.eulerAngles = eulerAngles2;
		}
		args["rotation"] = eulerAngles;
		args["type"] = "rotate";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void LookTo(GameObject target, Vector3 looktarget, float time)
	{
		LookTo(target, Hash("looktarget", looktarget, "time", time));
	}

	public static void LookTo(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		if (args.Contains("looktarget") && args["looktarget"].GetType() == typeof(Transform))
		{
			Transform transform = (Transform)args["looktarget"];
			args["position"] = new Vector3(transform.position.x, transform.position.y, transform.position.z);
			args["rotation"] = new Vector3(transform.eulerAngles.x, transform.eulerAngles.y, transform.eulerAngles.z);
		}
		args["type"] = "look";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void MoveTo(GameObject target, Vector3 position, float time)
	{
		MoveTo(target, Hash("position", position, "time", time));
	}

	public static void MoveTo(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		if (args.Contains("position") && args["position"].GetType() == typeof(Transform))
		{
			Transform transform = (Transform)args["position"];
			args["position"] = new Vector3(transform.position.x, transform.position.y, transform.position.z);
			args["rotation"] = new Vector3(transform.eulerAngles.x, transform.eulerAngles.y, transform.eulerAngles.z);
			args["scale"] = new Vector3(transform.localScale.x, transform.localScale.y, transform.localScale.z);
		}
		args["type"] = "move";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void MoveFrom(GameObject target, Vector3 position, float time)
	{
		MoveFrom(target, Hash("position", position, "time", time));
	}

	public static void MoveFrom(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		bool flag = ((!args.Contains("islocal")) ? Defaults.isLocal : ((bool)args["islocal"]));
		if (args.Contains("path"))
		{
			Vector3[] array2;
			if (args["path"].GetType() == typeof(Vector3[]))
			{
				Vector3[] array = (Vector3[])args["path"];
				array2 = new Vector3[array.Length];
				Array.Copy(array, array2, array.Length);
			}
			else
			{
				Transform[] array3 = (Transform[])args["path"];
				array2 = new Vector3[array3.Length];
				for (int i = 0; i < array3.Length; i++)
				{
					ref Vector3 reference = ref array2[i];
					reference = array3[i].position;
				}
			}
			if (array2[array2.Length - 1] != target.transform.position)
			{
				Vector3[] array4 = new Vector3[array2.Length + 1];
				Array.Copy(array2, array4, array2.Length);
				if (flag)
				{
					ref Vector3 reference2 = ref array4[array4.Length - 1];
					reference2 = target.transform.localPosition;
					target.transform.localPosition = array4[0];
				}
				else
				{
					ref Vector3 reference3 = ref array4[array4.Length - 1];
					reference3 = target.transform.position;
					target.transform.position = array4[0];
				}
				args["path"] = array4;
			}
			else
			{
				if (flag)
				{
					target.transform.localPosition = array2[0];
				}
				else
				{
					target.transform.position = array2[0];
				}
				args["path"] = array2;
			}
		}
		else
		{
			Vector3 vector;
			Vector3 vector2 = ((!flag) ? (vector = target.transform.position) : (vector = target.transform.localPosition));
			if (args.Contains("position"))
			{
				if (args["position"].GetType() == typeof(Transform))
				{
					Transform transform = (Transform)args["position"];
					vector = transform.position;
				}
				else if (args["position"].GetType() == typeof(Vector3))
				{
					vector = (Vector3)args["position"];
				}
			}
			else
			{
				if (args.Contains("x"))
				{
					vector.x = (float)args["x"];
				}
				if (args.Contains("y"))
				{
					vector.y = (float)args["y"];
				}
				if (args.Contains("z"))
				{
					vector.z = (float)args["z"];
				}
			}
			if (flag)
			{
				target.transform.localPosition = vector;
			}
			else
			{
				target.transform.position = vector;
			}
			args["position"] = vector2;
		}
		args["type"] = "move";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void MoveAdd(GameObject target, Vector3 amount, float time)
	{
		MoveAdd(target, Hash("amount", amount, "time", time));
	}

	public static void MoveAdd(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "move";
		args["method"] = "add";
		Launch(target, args);
	}

	public static void MoveBy(GameObject target, Vector3 amount, float time)
	{
		MoveBy(target, Hash("amount", amount, "time", time));
	}

	public static void MoveBy(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "move";
		args["method"] = "by";
		Launch(target, args);
	}

	public static void ScaleTo(GameObject target, Vector3 scale, float time)
	{
		ScaleTo(target, Hash("scale", scale, "time", time));
	}

	public static void ScaleTo(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		if (args.Contains("scale") && args["scale"].GetType() == typeof(Transform))
		{
			Transform transform = (Transform)args["scale"];
			args["position"] = new Vector3(transform.position.x, transform.position.y, transform.position.z);
			args["rotation"] = new Vector3(transform.eulerAngles.x, transform.eulerAngles.y, transform.eulerAngles.z);
			args["scale"] = new Vector3(transform.localScale.x, transform.localScale.y, transform.localScale.z);
		}
		args["type"] = "scale";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void ScaleFrom(GameObject target, Vector3 scale, float time)
	{
		ScaleFrom(target, Hash("scale", scale, "time", time));
	}

	public static void ScaleFrom(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		Vector3 localScale;
		Vector3 vector = (localScale = target.transform.localScale);
		if (args.Contains("scale"))
		{
			if (args["scale"].GetType() == typeof(Transform))
			{
				Transform transform = (Transform)args["scale"];
				localScale = transform.localScale;
			}
			else if (args["scale"].GetType() == typeof(Vector3))
			{
				localScale = (Vector3)args["scale"];
			}
		}
		else
		{
			if (args.Contains("x"))
			{
				localScale.x = (float)args["x"];
			}
			if (args.Contains("y"))
			{
				localScale.y = (float)args["y"];
			}
			if (args.Contains("z"))
			{
				localScale.z = (float)args["z"];
			}
		}
		target.transform.localScale = localScale;
		args["scale"] = vector;
		args["type"] = "scale";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void ScaleAdd(GameObject target, Vector3 amount, float time)
	{
		ScaleAdd(target, Hash("amount", amount, "time", time));
	}

	public static void ScaleAdd(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "scale";
		args["method"] = "add";
		Launch(target, args);
	}

	public static void ScaleBy(GameObject target, Vector3 amount, float time)
	{
		ScaleBy(target, Hash("amount", amount, "time", time));
	}

	public static void ScaleBy(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "scale";
		args["method"] = "by";
		Launch(target, args);
	}

	public static void RotateTo(GameObject target, Vector3 rotation, float time)
	{
		RotateTo(target, Hash("rotation", rotation, "time", time));
	}

	public static void RotateTo(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		if (args.Contains("rotation") && args["rotation"].GetType() == typeof(Transform))
		{
			Transform transform = (Transform)args["rotation"];
			args["position"] = new Vector3(transform.position.x, transform.position.y, transform.position.z);
			args["rotation"] = new Vector3(transform.eulerAngles.x, transform.eulerAngles.y, transform.eulerAngles.z);
			args["scale"] = new Vector3(transform.localScale.x, transform.localScale.y, transform.localScale.z);
		}
		args["type"] = "rotate";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void RotateFrom(GameObject target, Vector3 rotation, float time)
	{
		RotateFrom(target, Hash("rotation", rotation, "time", time));
	}

	public static void RotateFrom(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		bool flag = ((!args.Contains("islocal")) ? Defaults.isLocal : ((bool)args["islocal"]));
		Vector3 vector;
		Vector3 vector2 = ((!flag) ? (vector = target.transform.eulerAngles) : (vector = target.transform.localEulerAngles));
		if (args.Contains("rotation"))
		{
			if (args["rotation"].GetType() == typeof(Transform))
			{
				Transform transform = (Transform)args["rotation"];
				vector = transform.eulerAngles;
			}
			else if (args["rotation"].GetType() == typeof(Vector3))
			{
				vector = (Vector3)args["rotation"];
			}
		}
		else
		{
			if (args.Contains("x"))
			{
				vector.x = (float)args["x"];
			}
			if (args.Contains("y"))
			{
				vector.y = (float)args["y"];
			}
			if (args.Contains("z"))
			{
				vector.z = (float)args["z"];
			}
		}
		if (flag)
		{
			target.transform.localEulerAngles = vector;
		}
		else
		{
			target.transform.eulerAngles = vector;
		}
		args["rotation"] = vector2;
		args["type"] = "rotate";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void RotateAdd(GameObject target, Vector3 amount, float time)
	{
		RotateAdd(target, Hash("amount", amount, "time", time));
	}

	public static void RotateAdd(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "rotate";
		args["method"] = "add";
		Launch(target, args);
	}

	public static void RotateBy(GameObject target, Vector3 amount, float time)
	{
		RotateBy(target, Hash("amount", amount, "time", time));
	}

	public static void RotateBy(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "rotate";
		args["method"] = "by";
		Launch(target, args);
	}

	public static void ShakePosition(GameObject target, Vector3 amount, float time)
	{
		ShakePosition(target, Hash("amount", amount, "time", time));
	}

	public static void ShakePosition(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "shake";
		args["method"] = "position";
		Launch(target, args);
	}

	public static void ShakeScale(GameObject target, Vector3 amount, float time)
	{
		ShakeScale(target, Hash("amount", amount, "time", time));
	}

	public static void ShakeScale(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "shake";
		args["method"] = "scale";
		Launch(target, args);
	}

	public static void ShakeRotation(GameObject target, Vector3 amount, float time)
	{
		ShakeRotation(target, Hash("amount", amount, "time", time));
	}

	public static void ShakeRotation(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "shake";
		args["method"] = "rotation";
		Launch(target, args);
	}

	public static void PunchPosition(GameObject target, Vector3 amount, float time)
	{
		PunchPosition(target, Hash("amount", amount, "time", time));
	}

	public static void PunchPosition(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "punch";
		args["method"] = "position";
		args["easetype"] = EaseType.punch;
		Launch(target, args);
	}

	public static void PunchRotation(GameObject target, Vector3 amount, float time)
	{
		PunchRotation(target, Hash("amount", amount, "time", time));
	}

	public static void PunchRotation(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "punch";
		args["method"] = "rotation";
		args["easetype"] = EaseType.punch;
		Launch(target, args);
	}

	public static void PunchScale(GameObject target, Vector3 amount, float time)
	{
		PunchScale(target, Hash("amount", amount, "time", time));
	}

	public static void PunchScale(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "punch";
		args["method"] = "scale";
		args["easetype"] = EaseType.punch;
		Launch(target, args);
	}

	private void GenerateTargets()
	{
		switch (type)
		{
		case "value":
			switch (method)
			{
			case "float":
				GenerateFloatTargets();
				apply = ApplyFloatTargets;
				break;
			case "vector2":
				GenerateVector2Targets();
				apply = ApplyVector2Targets;
				break;
			case "vector3":
				GenerateVector3Targets();
				apply = ApplyVector3Targets;
				break;
			case "color":
				GenerateColorTargets();
				apply = ApplyColorTargets;
				break;
			case "rect":
				GenerateRectTargets();
				apply = ApplyRectTargets;
				break;
			}
			break;
		case "color":
		{
			string text2 = method;
			if (text2 != null && text2 == "to")
			{
				GenerateColorToTargets();
				apply = ApplyColorToTargets;
			}
			break;
		}
		case "audio":
		{
			string text3 = method;
			if (text3 != null && text3 == "to")
			{
				GenerateAudioToTargets();
				apply = ApplyAudioToTargets;
			}
			break;
		}
		case "move":
			switch (method)
			{
			case "to":
				if (tweenArguments.Contains("path"))
				{
					GenerateMoveToPathTargets();
					apply = ApplyMoveToPathTargets;
				}
				else
				{
					GenerateMoveToTargets();
					apply = ApplyMoveToTargets;
				}
				break;
			case "by":
			case "add":
				GenerateMoveByTargets();
				apply = ApplyMoveByTargets;
				break;
			}
			break;
		case "scale":
			switch (method)
			{
			case "to":
				GenerateScaleToTargets();
				apply = ApplyScaleToTargets;
				break;
			case "by":
				GenerateScaleByTargets();
				apply = ApplyScaleToTargets;
				break;
			case "add":
				GenerateScaleAddTargets();
				apply = ApplyScaleToTargets;
				break;
			}
			break;
		case "rotate":
			switch (method)
			{
			case "to":
				GenerateRotateToTargets();
				apply = ApplyRotateToTargets;
				break;
			case "add":
				GenerateRotateAddTargets();
				apply = ApplyRotateAddTargets;
				break;
			case "by":
				GenerateRotateByTargets();
				apply = ApplyRotateAddTargets;
				break;
			}
			break;
		case "shake":
			switch (method)
			{
			case "position":
				GenerateShakePositionTargets();
				apply = ApplyShakePositionTargets;
				break;
			case "scale":
				GenerateShakeScaleTargets();
				apply = ApplyShakeScaleTargets;
				break;
			case "rotation":
				GenerateShakeRotationTargets();
				apply = ApplyShakeRotationTargets;
				break;
			}
			break;
		case "punch":
			switch (method)
			{
			case "position":
				GeneratePunchPositionTargets();
				apply = ApplyPunchPositionTargets;
				break;
			case "rotation":
				GeneratePunchRotationTargets();
				apply = ApplyPunchRotationTargets;
				break;
			case "scale":
				GeneratePunchScaleTargets();
				apply = ApplyPunchScaleTargets;
				break;
			}
			break;
		case "look":
		{
			string text = method;
			if (text != null && text == "to")
			{
				GenerateLookToTargets();
				apply = ApplyLookToTargets;
			}
			break;
		}
		case "stab":
			GenerateStabTargets();
			apply = ApplyStabTargets;
			break;
		}
	}

	private void GenerateRectTargets()
	{
		rects = new Rect[3];
		ref Rect reference = ref rects[0];
		reference = (Rect)tweenArguments["from"];
		ref Rect reference2 = ref rects[1];
		reference2 = (Rect)tweenArguments["to"];
	}

	private void GenerateColorTargets()
	{
		colors = new Color[1, 3];
		ref Color reference = ref colors[0, 0];
		reference = (Color)tweenArguments["from"];
		ref Color reference2 = ref colors[0, 1];
		reference2 = (Color)tweenArguments["to"];
	}

	private void GenerateVector3Targets()
	{
		vector3s = new Vector3[3];
		ref Vector3 reference = ref vector3s[0];
		reference = (Vector3)tweenArguments["from"];
		ref Vector3 reference2 = ref vector3s[1];
		reference2 = (Vector3)tweenArguments["to"];
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateVector2Targets()
	{
		vector2s = new Vector2[3];
		ref Vector2 reference = ref vector2s[0];
		reference = (Vector2)tweenArguments["from"];
		ref Vector2 reference2 = ref vector2s[1];
		reference2 = (Vector2)tweenArguments["to"];
		if (tweenArguments.Contains("speed"))
		{
			Vector3 a = new Vector3(vector2s[0].x, vector2s[0].y, 0f);
			Vector3 b = new Vector3(vector2s[1].x, vector2s[1].y, 0f);
			float num = Math.Abs(Vector3.Distance(a, b));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateFloatTargets()
	{
		floats = new float[3];
		floats[0] = (float)tweenArguments["from"];
		floats[1] = (float)tweenArguments["to"];
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(floats[0] - floats[1]);
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateColorToTargets()
	{
		if ((bool)GetComponent(typeof(GUITexture)))
		{
			colors = new Color[1, 3];
			ref Color reference = ref colors[0, 0];
			ref Color reference2 = ref colors[0, 1];
			reference = (reference2 = GetComponent<GUITexture>().color);
		}
		else if ((bool)GetComponent(typeof(GUIText)))
		{
			colors = new Color[1, 3];
			ref Color reference3 = ref colors[0, 0];
			ref Color reference4 = ref colors[0, 1];
			reference3 = (reference4 = GetComponent<GUIText>().material.color);
		}
		else if ((bool)GetComponent<Renderer>())
		{
			colors = new Color[GetComponent<Renderer>().materials.Length, 3];
			for (int i = 0; i < GetComponent<Renderer>().materials.Length; i++)
			{
				ref Color reference5 = ref colors[i, 0];
				reference5 = GetComponent<Renderer>().materials[i].GetColor(namedcolorvalue.ToString());
				ref Color reference6 = ref colors[i, 1];
				reference6 = GetComponent<Renderer>().materials[i].GetColor(namedcolorvalue.ToString());
			}
		}
		else if ((bool)GetComponent<Light>())
		{
			colors = new Color[1, 3];
			ref Color reference7 = ref colors[0, 0];
			ref Color reference8 = ref colors[0, 1];
			reference7 = (reference8 = GetComponent<Light>().color);
		}
		else
		{
			colors = new Color[1, 3];
		}
		if (tweenArguments.Contains("color"))
		{
			for (int j = 0; j < colors.GetLength(0); j++)
			{
				ref Color reference9 = ref colors[j, 1];
				reference9 = (Color)tweenArguments["color"];
			}
		}
		else
		{
			if (tweenArguments.Contains("r"))
			{
				for (int k = 0; k < colors.GetLength(0); k++)
				{
					colors[k, 1].r = (float)tweenArguments["r"];
				}
			}
			if (tweenArguments.Contains("g"))
			{
				for (int l = 0; l < colors.GetLength(0); l++)
				{
					colors[l, 1].g = (float)tweenArguments["g"];
				}
			}
			if (tweenArguments.Contains("b"))
			{
				for (int m = 0; m < colors.GetLength(0); m++)
				{
					colors[m, 1].b = (float)tweenArguments["b"];
				}
			}
			if (tweenArguments.Contains("a"))
			{
				for (int n = 0; n < colors.GetLength(0); n++)
				{
					colors[n, 1].a = (float)tweenArguments["a"];
				}
			}
		}
		if (tweenArguments.Contains("amount"))
		{
			for (int num = 0; num < colors.GetLength(0); num++)
			{
				colors[num, 1].a = (float)tweenArguments["amount"];
			}
		}
		else if (tweenArguments.Contains("alpha"))
		{
			for (int num2 = 0; num2 < colors.GetLength(0); num2++)
			{
				colors[num2, 1].a = (float)tweenArguments["alpha"];
			}
		}
	}

	private void GenerateAudioToTargets()
	{
		vector2s = new Vector2[3];
		if (tweenArguments.Contains("audiosource"))
		{
			audioSource = (AudioSource)tweenArguments["audiosource"];
		}
		else if ((bool)GetComponent(typeof(AudioSource)))
		{
			audioSource = GetComponent<AudioSource>();
		}
		else
		{
			Debug.LogError("iTween Error: AudioTo requires an AudioSource.");
			Dispose();
		}
		ref Vector2 reference = ref vector2s[0];
		ref Vector2 reference2 = ref vector2s[1];
		reference = (reference2 = new Vector2(audioSource.volume, audioSource.pitch));
		if (tweenArguments.Contains("volume"))
		{
			vector2s[1].x = (float)tweenArguments["volume"];
		}
		if (tweenArguments.Contains("pitch"))
		{
			vector2s[1].y = (float)tweenArguments["pitch"];
		}
	}

	private void GenerateStabTargets()
	{
		if (tweenArguments.Contains("audiosource"))
		{
			audioSource = (AudioSource)tweenArguments["audiosource"];
		}
		else if ((bool)GetComponent(typeof(AudioSource)))
		{
			audioSource = GetComponent<AudioSource>();
		}
		else
		{
			base.gameObject.AddComponent(typeof(AudioSource));
			audioSource = GetComponent<AudioSource>();
			audioSource.playOnAwake = false;
		}
		audioSource.clip = (AudioClip)tweenArguments["audioclip"];
		if (tweenArguments.Contains("pitch"))
		{
			audioSource.pitch = (float)tweenArguments["pitch"];
		}
		if (tweenArguments.Contains("volume"))
		{
			audioSource.volume = (float)tweenArguments["volume"];
		}
		time = audioSource.clip.length / audioSource.pitch;
	}

	private void GenerateLookToTargets()
	{
		vector3s = new Vector3[3];
		ref Vector3 reference = ref vector3s[0];
		reference = base.transform.eulerAngles;
		if (tweenArguments.Contains("looktarget"))
		{
			if (tweenArguments["looktarget"].GetType() == typeof(Transform))
			{
				Transform obj = base.transform;
				Transform target = (Transform)tweenArguments["looktarget"];
				Vector3? vector = (Vector3?)tweenArguments["up"];
				obj.LookAt(target, (!vector.HasValue) ? Defaults.up : vector.Value);
			}
			else if (tweenArguments["looktarget"].GetType() == typeof(Vector3))
			{
				Transform obj2 = base.transform;
				Vector3 worldPosition = (Vector3)tweenArguments["looktarget"];
				Vector3? vector2 = (Vector3?)tweenArguments["up"];
				obj2.LookAt(worldPosition, (!vector2.HasValue) ? Defaults.up : vector2.Value);
			}
		}
		else
		{
			Debug.LogError("iTween Error: LookTo needs a 'looktarget' property!");
			Dispose();
		}
		ref Vector3 reference2 = ref vector3s[1];
		reference2 = base.transform.eulerAngles;
		base.transform.eulerAngles = vector3s[0];
		if (tweenArguments.Contains("axis"))
		{
			switch ((string)tweenArguments["axis"])
			{
			case "x":
				vector3s[1].y = vector3s[0].y;
				vector3s[1].z = vector3s[0].z;
				break;
			case "y":
				vector3s[1].x = vector3s[0].x;
				vector3s[1].z = vector3s[0].z;
				break;
			case "z":
				vector3s[1].x = vector3s[0].x;
				vector3s[1].y = vector3s[0].y;
				break;
			}
		}
		ref Vector3 reference3 = ref vector3s[1];
		reference3 = new Vector3(clerp(vector3s[0].x, vector3s[1].x, 1f), clerp(vector3s[0].y, vector3s[1].y, 1f), clerp(vector3s[0].z, vector3s[1].z, 1f));
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateMoveToPathTargets()
	{
		Vector3[] array2;
		if (tweenArguments["path"].GetType() == typeof(Vector3[]))
		{
			Vector3[] array = (Vector3[])tweenArguments["path"];
			if (array.Length == 1)
			{
				Debug.LogError("iTween Error: Attempting a path movement with MoveTo requires an array of more than 1 entry!");
				Dispose();
			}
			array2 = new Vector3[array.Length];
			Array.Copy(array, array2, array.Length);
		}
		else
		{
			Transform[] array3 = (Transform[])tweenArguments["path"];
			if (array3.Length == 1)
			{
				Debug.LogError("iTween Error: Attempting a path movement with MoveTo requires an array of more than 1 entry!");
				Dispose();
			}
			array2 = new Vector3[array3.Length];
			for (int i = 0; i < array3.Length; i++)
			{
				ref Vector3 reference = ref array2[i];
				reference = array3[i].position;
			}
		}
		bool flag;
		int num;
		if (base.transform.position != array2[0])
		{
			if (!tweenArguments.Contains("movetopath") || (bool)tweenArguments["movetopath"])
			{
				flag = true;
				num = 3;
			}
			else
			{
				flag = false;
				num = 2;
			}
		}
		else
		{
			flag = false;
			num = 2;
		}
		vector3s = new Vector3[array2.Length + num];
		if (flag)
		{
			ref Vector3 reference2 = ref vector3s[1];
			reference2 = base.transform.position;
			num = 2;
		}
		else
		{
			num = 1;
		}
		Array.Copy(array2, 0, vector3s, num, array2.Length);
		ref Vector3 reference3 = ref vector3s[0];
		reference3 = vector3s[1] + (vector3s[1] - vector3s[2]);
		ref Vector3 reference4 = ref vector3s[vector3s.Length - 1];
		reference4 = vector3s[vector3s.Length - 2] + (vector3s[vector3s.Length - 2] - vector3s[vector3s.Length - 3]);
		if (vector3s[1] == vector3s[vector3s.Length - 2])
		{
			Vector3[] array4 = new Vector3[vector3s.Length];
			Array.Copy(vector3s, array4, vector3s.Length);
			ref Vector3 reference5 = ref array4[0];
			reference5 = array4[array4.Length - 3];
			ref Vector3 reference6 = ref array4[array4.Length - 1];
			reference6 = array4[2];
			vector3s = new Vector3[array4.Length];
			Array.Copy(array4, vector3s, array4.Length);
		}
		path = new CRSpline(vector3s);
		if (tweenArguments.Contains("speed"))
		{
			float num2 = PathLength(vector3s);
			time = num2 / (float)tweenArguments["speed"];
		}
	}

	private void GenerateMoveToTargets()
	{
		vector3s = new Vector3[3];
		if (isLocal)
		{
			ref Vector3 reference = ref vector3s[0];
			ref Vector3 reference2 = ref vector3s[1];
			reference = (reference2 = base.transform.localPosition);
		}
		else
		{
			ref Vector3 reference3 = ref vector3s[0];
			ref Vector3 reference4 = ref vector3s[1];
			reference3 = (reference4 = base.transform.position);
		}
		if (tweenArguments.Contains("position"))
		{
			if (tweenArguments["position"].GetType() == typeof(Transform))
			{
				Transform transform = (Transform)tweenArguments["position"];
				ref Vector3 reference5 = ref vector3s[1];
				reference5 = transform.position;
			}
			else if (tweenArguments["position"].GetType() == typeof(Vector3))
			{
				ref Vector3 reference6 = ref vector3s[1];
				reference6 = (Vector3)tweenArguments["position"];
			}
		}
		else
		{
			if (tweenArguments.Contains("x"))
			{
				vector3s[1].x = (float)tweenArguments["x"];
			}
			if (tweenArguments.Contains("y"))
			{
				vector3s[1].y = (float)tweenArguments["y"];
			}
			if (tweenArguments.Contains("z"))
			{
				vector3s[1].z = (float)tweenArguments["z"];
			}
		}
		if (tweenArguments.Contains("orienttopath") && (bool)tweenArguments["orienttopath"])
		{
			tweenArguments["looktarget"] = vector3s[1];
		}
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateMoveByTargets()
	{
		vector3s = new Vector3[6];
		ref Vector3 reference = ref vector3s[4];
		reference = base.transform.eulerAngles;
		ref Vector3 reference2 = ref vector3s[0];
		ref Vector3 reference3 = ref vector3s[1];
		ref Vector3 reference4 = ref vector3s[3];
		reference2 = (reference3 = (reference4 = base.transform.position));
		if (tweenArguments.Contains("amount"))
		{
			ref Vector3 reference5 = ref vector3s[1];
			reference5 = vector3s[0] + (Vector3)tweenArguments["amount"];
		}
		else
		{
			if (tweenArguments.Contains("x"))
			{
				vector3s[1].x = vector3s[0].x + (float)tweenArguments["x"];
			}
			if (tweenArguments.Contains("y"))
			{
				vector3s[1].y = vector3s[0].y + (float)tweenArguments["y"];
			}
			if (tweenArguments.Contains("z"))
			{
				vector3s[1].z = vector3s[0].z + (float)tweenArguments["z"];
			}
		}
		base.transform.Translate(vector3s[1], space);
		ref Vector3 reference6 = ref vector3s[5];
		reference6 = base.transform.position;
		base.transform.position = vector3s[0];
		if (tweenArguments.Contains("orienttopath") && (bool)tweenArguments["orienttopath"])
		{
			tweenArguments["looktarget"] = vector3s[1];
		}
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateScaleToTargets()
	{
		vector3s = new Vector3[3];
		ref Vector3 reference = ref vector3s[0];
		ref Vector3 reference2 = ref vector3s[1];
		reference = (reference2 = base.transform.localScale);
		if (tweenArguments.Contains("scale"))
		{
			if (tweenArguments["scale"].GetType() == typeof(Transform))
			{
				Transform transform = (Transform)tweenArguments["scale"];
				ref Vector3 reference3 = ref vector3s[1];
				reference3 = transform.localScale;
			}
			else if (tweenArguments["scale"].GetType() == typeof(Vector3))
			{
				ref Vector3 reference4 = ref vector3s[1];
				reference4 = (Vector3)tweenArguments["scale"];
			}
		}
		else
		{
			if (tweenArguments.Contains("x"))
			{
				vector3s[1].x = (float)tweenArguments["x"];
			}
			if (tweenArguments.Contains("y"))
			{
				vector3s[1].y = (float)tweenArguments["y"];
			}
			if (tweenArguments.Contains("z"))
			{
				vector3s[1].z = (float)tweenArguments["z"];
			}
		}
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateScaleByTargets()
	{
		vector3s = new Vector3[3];
		ref Vector3 reference = ref vector3s[0];
		ref Vector3 reference2 = ref vector3s[1];
		reference = (reference2 = base.transform.localScale);
		if (tweenArguments.Contains("amount"))
		{
			ref Vector3 reference3 = ref vector3s[1];
			reference3 = Vector3.Scale(vector3s[1], (Vector3)tweenArguments["amount"]);
		}
		else
		{
			if (tweenArguments.Contains("x"))
			{
				vector3s[1].x *= (float)tweenArguments["x"];
			}
			if (tweenArguments.Contains("y"))
			{
				vector3s[1].y *= (float)tweenArguments["y"];
			}
			if (tweenArguments.Contains("z"))
			{
				vector3s[1].z *= (float)tweenArguments["z"];
			}
		}
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateScaleAddTargets()
	{
		vector3s = new Vector3[3];
		ref Vector3 reference = ref vector3s[0];
		ref Vector3 reference2 = ref vector3s[1];
		reference = (reference2 = base.transform.localScale);
		if (tweenArguments.Contains("amount"))
		{
			vector3s[1] += (Vector3)tweenArguments["amount"];
		}
		else
		{
			if (tweenArguments.Contains("x"))
			{
				vector3s[1].x += (float)tweenArguments["x"];
			}
			if (tweenArguments.Contains("y"))
			{
				vector3s[1].y += (float)tweenArguments["y"];
			}
			if (tweenArguments.Contains("z"))
			{
				vector3s[1].z += (float)tweenArguments["z"];
			}
		}
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateRotateToTargets()
	{
		vector3s = new Vector3[3];
		if (isLocal)
		{
			ref Vector3 reference = ref vector3s[0];
			ref Vector3 reference2 = ref vector3s[1];
			reference = (reference2 = base.transform.localEulerAngles);
		}
		else
		{
			ref Vector3 reference3 = ref vector3s[0];
			ref Vector3 reference4 = ref vector3s[1];
			reference3 = (reference4 = base.transform.eulerAngles);
		}
		if (tweenArguments.Contains("rotation"))
		{
			if (tweenArguments["rotation"].GetType() == typeof(Transform))
			{
				Transform transform = (Transform)tweenArguments["rotation"];
				ref Vector3 reference5 = ref vector3s[1];
				reference5 = transform.eulerAngles;
			}
			else if (tweenArguments["rotation"].GetType() == typeof(Vector3))
			{
				ref Vector3 reference6 = ref vector3s[1];
				reference6 = (Vector3)tweenArguments["rotation"];
			}
		}
		else
		{
			if (tweenArguments.Contains("x"))
			{
				vector3s[1].x = (float)tweenArguments["x"];
			}
			if (tweenArguments.Contains("y"))
			{
				vector3s[1].y = (float)tweenArguments["y"];
			}
			if (tweenArguments.Contains("z"))
			{
				vector3s[1].z = (float)tweenArguments["z"];
			}
		}
		ref Vector3 reference7 = ref vector3s[1];
		reference7 = new Vector3(clerp(vector3s[0].x, vector3s[1].x, 1f), clerp(vector3s[0].y, vector3s[1].y, 1f), clerp(vector3s[0].z, vector3s[1].z, 1f));
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateRotateAddTargets()
	{
		vector3s = new Vector3[5];
		ref Vector3 reference = ref vector3s[0];
		ref Vector3 reference2 = ref vector3s[1];
		ref Vector3 reference3 = ref vector3s[3];
		reference = (reference2 = (reference3 = base.transform.eulerAngles));
		if (tweenArguments.Contains("amount"))
		{
			vector3s[1] += (Vector3)tweenArguments["amount"];
		}
		else
		{
			if (tweenArguments.Contains("x"))
			{
				vector3s[1].x += (float)tweenArguments["x"];
			}
			if (tweenArguments.Contains("y"))
			{
				vector3s[1].y += (float)tweenArguments["y"];
			}
			if (tweenArguments.Contains("z"))
			{
				vector3s[1].z += (float)tweenArguments["z"];
			}
		}
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateRotateByTargets()
	{
		vector3s = new Vector3[4];
		ref Vector3 reference = ref vector3s[0];
		ref Vector3 reference2 = ref vector3s[1];
		ref Vector3 reference3 = ref vector3s[3];
		reference = (reference2 = (reference3 = base.transform.eulerAngles));
		if (tweenArguments.Contains("amount"))
		{
			vector3s[1] += Vector3.Scale((Vector3)tweenArguments["amount"], new Vector3(360f, 360f, 360f));
		}
		else
		{
			if (tweenArguments.Contains("x"))
			{
				vector3s[1].x += 360f * (float)tweenArguments["x"];
			}
			if (tweenArguments.Contains("y"))
			{
				vector3s[1].y += 360f * (float)tweenArguments["y"];
			}
			if (tweenArguments.Contains("z"))
			{
				vector3s[1].z += 360f * (float)tweenArguments["z"];
			}
		}
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateShakePositionTargets()
	{
		vector3s = new Vector3[4];
		ref Vector3 reference = ref vector3s[3];
		reference = base.transform.eulerAngles;
		ref Vector3 reference2 = ref vector3s[0];
		reference2 = base.transform.position;
		if (tweenArguments.Contains("amount"))
		{
			ref Vector3 reference3 = ref vector3s[1];
			reference3 = (Vector3)tweenArguments["amount"];
			return;
		}
		if (tweenArguments.Contains("x"))
		{
			vector3s[1].x = (float)tweenArguments["x"];
		}
		if (tweenArguments.Contains("y"))
		{
			vector3s[1].y = (float)tweenArguments["y"];
		}
		if (tweenArguments.Contains("z"))
		{
			vector3s[1].z = (float)tweenArguments["z"];
		}
	}

	private void GenerateShakeScaleTargets()
	{
		vector3s = new Vector3[3];
		ref Vector3 reference = ref vector3s[0];
		reference = base.transform.localScale;
		if (tweenArguments.Contains("amount"))
		{
			ref Vector3 reference2 = ref vector3s[1];
			reference2 = (Vector3)tweenArguments["amount"];
			return;
		}
		if (tweenArguments.Contains("x"))
		{
			vector3s[1].x = (float)tweenArguments["x"];
		}
		if (tweenArguments.Contains("y"))
		{
			vector3s[1].y = (float)tweenArguments["y"];
		}
		if (tweenArguments.Contains("z"))
		{
			vector3s[1].z = (float)tweenArguments["z"];
		}
	}

	private void GenerateShakeRotationTargets()
	{
		vector3s = new Vector3[3];
		ref Vector3 reference = ref vector3s[0];
		reference = base.transform.eulerAngles;
		if (tweenArguments.Contains("amount"))
		{
			ref Vector3 reference2 = ref vector3s[1];
			reference2 = (Vector3)tweenArguments["amount"];
			return;
		}
		if (tweenArguments.Contains("x"))
		{
			vector3s[1].x = (float)tweenArguments["x"];
		}
		if (tweenArguments.Contains("y"))
		{
			vector3s[1].y = (float)tweenArguments["y"];
		}
		if (tweenArguments.Contains("z"))
		{
			vector3s[1].z = (float)tweenArguments["z"];
		}
	}

	private void GeneratePunchPositionTargets()
	{
		vector3s = new Vector3[5];
		ref Vector3 reference = ref vector3s[4];
		reference = base.transform.eulerAngles;
		ref Vector3 reference2 = ref vector3s[0];
		reference2 = base.transform.position;
		ref Vector3 reference3 = ref vector3s[1];
		ref Vector3 reference4 = ref vector3s[3];
		reference3 = (reference4 = Vector3.zero);
		if (tweenArguments.Contains("amount"))
		{
			ref Vector3 reference5 = ref vector3s[1];
			reference5 = (Vector3)tweenArguments["amount"];
			return;
		}
		if (tweenArguments.Contains("x"))
		{
			vector3s[1].x = (float)tweenArguments["x"];
		}
		if (tweenArguments.Contains("y"))
		{
			vector3s[1].y = (float)tweenArguments["y"];
		}
		if (tweenArguments.Contains("z"))
		{
			vector3s[1].z = (float)tweenArguments["z"];
		}
	}

	private void GeneratePunchRotationTargets()
	{
		vector3s = new Vector3[4];
		ref Vector3 reference = ref vector3s[0];
		reference = base.transform.eulerAngles;
		ref Vector3 reference2 = ref vector3s[1];
		ref Vector3 reference3 = ref vector3s[3];
		reference2 = (reference3 = Vector3.zero);
		if (tweenArguments.Contains("amount"))
		{
			ref Vector3 reference4 = ref vector3s[1];
			reference4 = (Vector3)tweenArguments["amount"];
			return;
		}
		if (tweenArguments.Contains("x"))
		{
			vector3s[1].x = (float)tweenArguments["x"];
		}
		if (tweenArguments.Contains("y"))
		{
			vector3s[1].y = (float)tweenArguments["y"];
		}
		if (tweenArguments.Contains("z"))
		{
			vector3s[1].z = (float)tweenArguments["z"];
		}
	}

	private void GeneratePunchScaleTargets()
	{
		vector3s = new Vector3[3];
		ref Vector3 reference = ref vector3s[0];
		reference = base.transform.localScale;
		ref Vector3 reference2 = ref vector3s[1];
		reference2 = Vector3.zero;
		if (tweenArguments.Contains("amount"))
		{
			ref Vector3 reference3 = ref vector3s[1];
			reference3 = (Vector3)tweenArguments["amount"];
			return;
		}
		if (tweenArguments.Contains("x"))
		{
			vector3s[1].x = (float)tweenArguments["x"];
		}
		if (tweenArguments.Contains("y"))
		{
			vector3s[1].y = (float)tweenArguments["y"];
		}
		if (tweenArguments.Contains("z"))
		{
			vector3s[1].z = (float)tweenArguments["z"];
		}
	}

	private void ApplyRectTargets()
	{
		rects[2].x = ease(rects[0].x, rects[1].x, percentage);
		rects[2].y = ease(rects[0].y, rects[1].y, percentage);
		rects[2].width = ease(rects[0].width, rects[1].width, percentage);
		rects[2].height = ease(rects[0].height, rects[1].height, percentage);
		tweenArguments["onupdateparams"] = rects[2];
		if (percentage == 1f)
		{
			tweenArguments["onupdateparams"] = rects[1];
		}
	}

	private void ApplyColorTargets()
	{
		colors[0, 2].r = ease(colors[0, 0].r, colors[0, 1].r, percentage);
		colors[0, 2].g = ease(colors[0, 0].g, colors[0, 1].g, percentage);
		colors[0, 2].b = ease(colors[0, 0].b, colors[0, 1].b, percentage);
		colors[0, 2].a = ease(colors[0, 0].a, colors[0, 1].a, percentage);
		tweenArguments["onupdateparams"] = colors[0, 2];
		if (percentage == 1f)
		{
			tweenArguments["onupdateparams"] = colors[0, 1];
		}
	}

	private void ApplyVector3Targets()
	{
		vector3s[2].x = ease(vector3s[0].x, vector3s[1].x, percentage);
		vector3s[2].y = ease(vector3s[0].y, vector3s[1].y, percentage);
		vector3s[2].z = ease(vector3s[0].z, vector3s[1].z, percentage);
		tweenArguments["onupdateparams"] = vector3s[2];
		if (percentage == 1f)
		{
			tweenArguments["onupdateparams"] = vector3s[1];
		}
	}

	private void ApplyVector2Targets()
	{
		vector2s[2].x = ease(vector2s[0].x, vector2s[1].x, percentage);
		vector2s[2].y = ease(vector2s[0].y, vector2s[1].y, percentage);
		tweenArguments["onupdateparams"] = vector2s[2];
		if (percentage == 1f)
		{
			tweenArguments["onupdateparams"] = vector2s[1];
		}
	}

	private void ApplyFloatTargets()
	{
		floats[2] = ease(floats[0], floats[1], percentage);
		tweenArguments["onupdateparams"] = floats[2];
		if (percentage == 1f)
		{
			tweenArguments["onupdateparams"] = floats[1];
		}
	}

	private void ApplyColorToTargets()
	{
		for (int i = 0; i < colors.GetLength(0); i++)
		{
			colors[i, 2].r = ease(colors[i, 0].r, colors[i, 1].r, percentage);
			colors[i, 2].g = ease(colors[i, 0].g, colors[i, 1].g, percentage);
			colors[i, 2].b = ease(colors[i, 0].b, colors[i, 1].b, percentage);
			colors[i, 2].a = ease(colors[i, 0].a, colors[i, 1].a, percentage);
		}
		if ((bool)GetComponent(typeof(GUITexture)))
		{
			GetComponent<GUITexture>().color = colors[0, 2];
		}
		else if ((bool)GetComponent(typeof(GUIText)))
		{
			GetComponent<GUIText>().material.color = colors[0, 2];
		}
		else if ((bool)GetComponent<Renderer>())
		{
			for (int j = 0; j < colors.GetLength(0); j++)
			{
				GetComponent<Renderer>().materials[j].SetColor(namedcolorvalue.ToString(), colors[j, 2]);
			}
		}
		else if ((bool)GetComponent<Light>())
		{
			GetComponent<Light>().color = colors[0, 2];
		}
		if (percentage != 1f)
		{
			return;
		}
		if ((bool)GetComponent(typeof(GUITexture)))
		{
			GetComponent<GUITexture>().color = colors[0, 1];
		}
		else if ((bool)GetComponent(typeof(GUIText)))
		{
			GetComponent<GUIText>().material.color = colors[0, 1];
		}
		else if ((bool)GetComponent<Renderer>())
		{
			for (int k = 0; k < colors.GetLength(0); k++)
			{
				GetComponent<Renderer>().materials[k].SetColor(namedcolorvalue.ToString(), colors[k, 1]);
			}
		}
		else if ((bool)GetComponent<Light>())
		{
			GetComponent<Light>().color = colors[0, 1];
		}
	}

	private void ApplyAudioToTargets()
	{
		vector2s[2].x = ease(vector2s[0].x, vector2s[1].x, percentage);
		vector2s[2].y = ease(vector2s[0].y, vector2s[1].y, percentage);
		audioSource.volume = vector2s[2].x;
		audioSource.pitch = vector2s[2].y;
		if (percentage == 1f)
		{
			audioSource.volume = vector2s[1].x;
			audioSource.pitch = vector2s[1].y;
		}
	}

	private void ApplyStabTargets()
	{
	}

	private void ApplyMoveToPathTargets()
	{
		preUpdate = base.transform.position;
		float value = ease(0f, 1f, percentage);
		if (isLocal)
		{
			base.transform.localPosition = path.Interp(Mathf.Clamp(value, 0f, 1f));
		}
		else
		{
			base.transform.position = path.Interp(Mathf.Clamp(value, 0f, 1f));
		}
		if (tweenArguments.Contains("orienttopath") && (bool)tweenArguments["orienttopath"])
		{
			float num = ((!tweenArguments.Contains("lookahead")) ? Defaults.lookAhead : ((float)tweenArguments["lookahead"]));
			float value2 = ease(0f, 1f, Mathf.Min(1f, percentage + num));
			tweenArguments["looktarget"] = path.Interp(Mathf.Clamp(value2, 0f, 1f));
		}
		postUpdate = base.transform.position;
		if (physics)
		{
			base.transform.position = preUpdate;
			GetComponent<Rigidbody>().MovePosition(postUpdate);
		}
	}

	private void ApplyMoveToTargets()
	{
		preUpdate = base.transform.position;
		vector3s[2].x = ease(vector3s[0].x, vector3s[1].x, percentage);
		vector3s[2].y = ease(vector3s[0].y, vector3s[1].y, percentage);
		vector3s[2].z = ease(vector3s[0].z, vector3s[1].z, percentage);
		if (isLocal)
		{
			base.transform.localPosition = vector3s[2];
		}
		else
		{
			base.transform.position = vector3s[2];
		}
		if (percentage == 1f)
		{
			if (isLocal)
			{
				base.transform.localPosition = vector3s[1];
			}
			else
			{
				base.transform.position = vector3s[1];
			}
		}
		postUpdate = base.transform.position;
		if (physics)
		{
			base.transform.position = preUpdate;
			GetComponent<Rigidbody>().MovePosition(postUpdate);
		}
	}

	private void ApplyMoveByTargets()
	{
		preUpdate = base.transform.position;
		Vector3 eulerAngles = default(Vector3);
		if (tweenArguments.Contains("looktarget"))
		{
			eulerAngles = base.transform.eulerAngles;
			base.transform.eulerAngles = vector3s[4];
		}
		vector3s[2].x = ease(vector3s[0].x, vector3s[1].x, percentage);
		vector3s[2].y = ease(vector3s[0].y, vector3s[1].y, percentage);
		vector3s[2].z = ease(vector3s[0].z, vector3s[1].z, percentage);
		base.transform.Translate(vector3s[2] - vector3s[3], space);
		ref Vector3 reference = ref vector3s[3];
		reference = vector3s[2];
		if (tweenArguments.Contains("looktarget"))
		{
			base.transform.eulerAngles = eulerAngles;
		}
		postUpdate = base.transform.position;
		if (physics)
		{
			base.transform.position = preUpdate;
			GetComponent<Rigidbody>().MovePosition(postUpdate);
		}
	}

	private void ApplyScaleToTargets()
	{
		vector3s[2].x = ease(vector3s[0].x, vector3s[1].x, percentage);
		vector3s[2].y = ease(vector3s[0].y, vector3s[1].y, percentage);
		vector3s[2].z = ease(vector3s[0].z, vector3s[1].z, percentage);
		base.transform.localScale = vector3s[2];
		if (percentage == 1f)
		{
			base.transform.localScale = vector3s[1];
		}
	}

	private void ApplyLookToTargets()
	{
		vector3s[2].x = ease(vector3s[0].x, vector3s[1].x, percentage);
		vector3s[2].y = ease(vector3s[0].y, vector3s[1].y, percentage);
		vector3s[2].z = ease(vector3s[0].z, vector3s[1].z, percentage);
		if (isLocal)
		{
			base.transform.localRotation = Quaternion.Euler(vector3s[2]);
		}
		else
		{
			base.transform.rotation = Quaternion.Euler(vector3s[2]);
		}
	}

	private void ApplyRotateToTargets()
	{
		preUpdate = base.transform.eulerAngles;
		vector3s[2].x = ease(vector3s[0].x, vector3s[1].x, percentage);
		vector3s[2].y = ease(vector3s[0].y, vector3s[1].y, percentage);
		vector3s[2].z = ease(vector3s[0].z, vector3s[1].z, percentage);
		if (isLocal)
		{
			base.transform.localRotation = Quaternion.Euler(vector3s[2]);
		}
		else
		{
			base.transform.rotation = Quaternion.Euler(vector3s[2]);
		}
		if (percentage == 1f)
		{
			if (isLocal)
			{
				base.transform.localRotation = Quaternion.Euler(vector3s[1]);
			}
			else
			{
				base.transform.rotation = Quaternion.Euler(vector3s[1]);
			}
		}
		postUpdate = base.transform.eulerAngles;
		if (physics)
		{
			base.transform.eulerAngles = preUpdate;
			GetComponent<Rigidbody>().MoveRotation(Quaternion.Euler(postUpdate));
		}
	}

	private void ApplyRotateAddTargets()
	{
		preUpdate = base.transform.eulerAngles;
		vector3s[2].x = ease(vector3s[0].x, vector3s[1].x, percentage);
		vector3s[2].y = ease(vector3s[0].y, vector3s[1].y, percentage);
		vector3s[2].z = ease(vector3s[0].z, vector3s[1].z, percentage);
		base.transform.Rotate(vector3s[2] - vector3s[3], space);
		ref Vector3 reference = ref vector3s[3];
		reference = vector3s[2];
		postUpdate = base.transform.eulerAngles;
		if (physics)
		{
			base.transform.eulerAngles = preUpdate;
			GetComponent<Rigidbody>().MoveRotation(Quaternion.Euler(postUpdate));
		}
	}

	private void ApplyShakePositionTargets()
	{
		if (isLocal)
		{
			preUpdate = base.transform.localPosition;
		}
		else
		{
			preUpdate = base.transform.position;
		}
		Vector3 eulerAngles = default(Vector3);
		if (tweenArguments.Contains("looktarget"))
		{
			eulerAngles = base.transform.eulerAngles;
			base.transform.eulerAngles = vector3s[3];
		}
		if (percentage == 0f)
		{
			base.transform.Translate(vector3s[1], space);
		}
		if (isLocal)
		{
			base.transform.localPosition = vector3s[0];
		}
		else
		{
			base.transform.position = vector3s[0];
		}
		float num = 1f - percentage;
		vector3s[2].x = UnityEngine.Random.Range((0f - vector3s[1].x) * num, vector3s[1].x * num);
		vector3s[2].y = UnityEngine.Random.Range((0f - vector3s[1].y) * num, vector3s[1].y * num);
		vector3s[2].z = UnityEngine.Random.Range((0f - vector3s[1].z) * num, vector3s[1].z * num);
		if (isLocal)
		{
			base.transform.localPosition += vector3s[2];
		}
		else
		{
			base.transform.position += vector3s[2];
		}
		if (tweenArguments.Contains("looktarget"))
		{
			base.transform.eulerAngles = eulerAngles;
		}
		postUpdate = base.transform.position;
		if (physics)
		{
			base.transform.position = preUpdate;
			GetComponent<Rigidbody>().MovePosition(postUpdate);
		}
	}

	private void ApplyShakeScaleTargets()
	{
		if (percentage == 0f)
		{
			base.transform.localScale = vector3s[1];
		}
		base.transform.localScale = vector3s[0];
		float num = 1f - percentage;
		vector3s[2].x = UnityEngine.Random.Range((0f - vector3s[1].x) * num, vector3s[1].x * num);
		vector3s[2].y = UnityEngine.Random.Range((0f - vector3s[1].y) * num, vector3s[1].y * num);
		vector3s[2].z = UnityEngine.Random.Range((0f - vector3s[1].z) * num, vector3s[1].z * num);
		base.transform.localScale += vector3s[2];
	}

	private void ApplyShakeRotationTargets()
	{
		preUpdate = base.transform.eulerAngles;
		if (percentage == 0f)
		{
			base.transform.Rotate(vector3s[1], space);
		}
		base.transform.eulerAngles = vector3s[0];
		float num = 1f - percentage;
		vector3s[2].x = UnityEngine.Random.Range((0f - vector3s[1].x) * num, vector3s[1].x * num);
		vector3s[2].y = UnityEngine.Random.Range((0f - vector3s[1].y) * num, vector3s[1].y * num);
		vector3s[2].z = UnityEngine.Random.Range((0f - vector3s[1].z) * num, vector3s[1].z * num);
		base.transform.Rotate(vector3s[2], space);
		postUpdate = base.transform.eulerAngles;
		if (physics)
		{
			base.transform.eulerAngles = preUpdate;
			GetComponent<Rigidbody>().MoveRotation(Quaternion.Euler(postUpdate));
		}
	}

	private void ApplyPunchPositionTargets()
	{
		preUpdate = base.transform.position;
		Vector3 eulerAngles = default(Vector3);
		if (tweenArguments.Contains("looktarget"))
		{
			eulerAngles = base.transform.eulerAngles;
			base.transform.eulerAngles = vector3s[4];
		}
		if (vector3s[1].x > 0f)
		{
			vector3s[2].x = punch(vector3s[1].x, percentage);
		}
		else if (vector3s[1].x < 0f)
		{
			vector3s[2].x = 0f - punch(Mathf.Abs(vector3s[1].x), percentage);
		}
		if (vector3s[1].y > 0f)
		{
			vector3s[2].y = punch(vector3s[1].y, percentage);
		}
		else if (vector3s[1].y < 0f)
		{
			vector3s[2].y = 0f - punch(Mathf.Abs(vector3s[1].y), percentage);
		}
		if (vector3s[1].z > 0f)
		{
			vector3s[2].z = punch(vector3s[1].z, percentage);
		}
		else if (vector3s[1].z < 0f)
		{
			vector3s[2].z = 0f - punch(Mathf.Abs(vector3s[1].z), percentage);
		}
		base.transform.Translate(vector3s[2] - vector3s[3], space);
		ref Vector3 reference = ref vector3s[3];
		reference = vector3s[2];
		if (tweenArguments.Contains("looktarget"))
		{
			base.transform.eulerAngles = eulerAngles;
		}
		postUpdate = base.transform.position;
		if (physics)
		{
			base.transform.position = preUpdate;
			GetComponent<Rigidbody>().MovePosition(postUpdate);
		}
	}

	private void ApplyPunchRotationTargets()
	{
		preUpdate = base.transform.eulerAngles;
		if (vector3s[1].x > 0f)
		{
			vector3s[2].x = punch(vector3s[1].x, percentage);
		}
		else if (vector3s[1].x < 0f)
		{
			vector3s[2].x = 0f - punch(Mathf.Abs(vector3s[1].x), percentage);
		}
		if (vector3s[1].y > 0f)
		{
			vector3s[2].y = punch(vector3s[1].y, percentage);
		}
		else if (vector3s[1].y < 0f)
		{
			vector3s[2].y = 0f - punch(Mathf.Abs(vector3s[1].y), percentage);
		}
		if (vector3s[1].z > 0f)
		{
			vector3s[2].z = punch(vector3s[1].z, percentage);
		}
		else if (vector3s[1].z < 0f)
		{
			vector3s[2].z = 0f - punch(Mathf.Abs(vector3s[1].z), percentage);
		}
		base.transform.Rotate(vector3s[2] - vector3s[3], space);
		ref Vector3 reference = ref vector3s[3];
		reference = vector3s[2];
		postUpdate = base.transform.eulerAngles;
		if (physics)
		{
			base.transform.eulerAngles = preUpdate;
			GetComponent<Rigidbody>().MoveRotation(Quaternion.Euler(postUpdate));
		}
	}

	private void ApplyPunchScaleTargets()
	{
		if (vector3s[1].x > 0f)
		{
			vector3s[2].x = punch(vector3s[1].x, percentage);
		}
		else if (vector3s[1].x < 0f)
		{
			vector3s[2].x = 0f - punch(Mathf.Abs(vector3s[1].x), percentage);
		}
		if (vector3s[1].y > 0f)
		{
			vector3s[2].y = punch(vector3s[1].y, percentage);
		}
		else if (vector3s[1].y < 0f)
		{
			vector3s[2].y = 0f - punch(Mathf.Abs(vector3s[1].y), percentage);
		}
		if (vector3s[1].z > 0f)
		{
			vector3s[2].z = punch(vector3s[1].z, percentage);
		}
		else if (vector3s[1].z < 0f)
		{
			vector3s[2].z = 0f - punch(Mathf.Abs(vector3s[1].z), percentage);
		}
		base.transform.localScale = vector3s[0] + vector3s[2];
	}

	private IEnumerator TweenDelay()
	{
		delayStarted = Time.time;
		yield return new WaitForSeconds(delay);
		if (wasPaused)
		{
			wasPaused = false;
			TweenStart();
		}
	}

	private void TweenStart()
	{
		CallBack("onstart");
		if (!loop)
		{
			ConflictCheck();
			GenerateTargets();
		}
		if (type == "stab")
		{
			audioSource.PlayOneShot(audioSource.clip);
		}
		if (type == "move" || type == "scale" || type == "rotate" || type == "punch" || type == "shake" || type == "curve" || type == "look")
		{
			EnableKinematic();
		}
		isRunning = true;
	}

	private IEnumerator TweenRestart()
	{
		if (delay > 0f)
		{
			delayStarted = Time.time;
			yield return new WaitForSeconds(delay);
		}
		loop = true;
		TweenStart();
	}

	private void TweenUpdate()
	{
		apply();
		CallBack("onupdate");
		UpdatePercentage();
	}

	private void TweenComplete()
	{
		isRunning = false;
		if (percentage > 0.5f)
		{
			percentage = 1f;
		}
		else
		{
			percentage = 0f;
		}
		apply();
		if (type == "value")
		{
			CallBack("onupdate");
		}
		if (loopType == LoopType.none)
		{
			Dispose();
		}
		else
		{
			TweenLoop();
		}
		CallBack("oncomplete");
	}

	private void TweenLoop()
	{
		DisableKinematic();
		switch (loopType)
		{
		case LoopType.loop:
			percentage = 0f;
			runningTime = 0f;
			apply();
			StartCoroutine("TweenRestart");
			break;
		case LoopType.pingPong:
			reverse = !reverse;
			runningTime = 0f;
			StartCoroutine("TweenRestart");
			break;
		}
	}

	public static Rect RectUpdate(Rect currentValue, Rect targetValue, float speed)
	{
		return new Rect(FloatUpdate(currentValue.x, targetValue.x, speed), FloatUpdate(currentValue.y, targetValue.y, speed), FloatUpdate(currentValue.width, targetValue.width, speed), FloatUpdate(currentValue.height, targetValue.height, speed));
	}

	public static Vector3 Vector3Update(Vector3 currentValue, Vector3 targetValue, float speed)
	{
		Vector3 vector = targetValue - currentValue;
		currentValue += vector * speed * Time.deltaTime;
		return currentValue;
	}

	public static Vector2 Vector2Update(Vector2 currentValue, Vector2 targetValue, float speed)
	{
		Vector2 vector = targetValue - currentValue;
		currentValue += vector * speed * Time.deltaTime;
		return currentValue;
	}

	public static float FloatUpdate(float currentValue, float targetValue, float speed)
	{
		float num = targetValue - currentValue;
		currentValue += num * speed * Time.deltaTime;
		return currentValue;
	}

	public static void FadeUpdate(GameObject target, Hashtable args)
	{
		args["a"] = args["alpha"];
		ColorUpdate(target, args);
	}

	public static void FadeUpdate(GameObject target, float alpha, float time)
	{
		FadeUpdate(target, Hash("alpha", alpha, "time", time));
	}

	public static void ColorUpdate(GameObject target, Hashtable args)
	{
		CleanArgs(args);
		Color[] array = new Color[4];
		if (!args.Contains("includechildren") || (bool)args["includechildren"])
		{
			foreach (Transform item in target.transform)
			{
				ColorUpdate(item.gameObject, args);
			}
		}
		float num;
		if (args.Contains("time"))
		{
			num = (float)args["time"];
			num *= Defaults.updateTimePercentage;
		}
		else
		{
			num = Defaults.updateTime;
		}
		if ((bool)target.GetComponent(typeof(GUITexture)))
		{
			ref Color reference = ref array[0];
			ref Color reference2 = ref array[1];
			reference = (reference2 = target.GetComponent<GUITexture>().color);
		}
		else if ((bool)target.GetComponent(typeof(GUIText)))
		{
			ref Color reference3 = ref array[0];
			ref Color reference4 = ref array[1];
			reference3 = (reference4 = target.GetComponent<GUIText>().material.color);
		}
		else if ((bool)target.GetComponent<Renderer>())
		{
			ref Color reference5 = ref array[0];
			ref Color reference6 = ref array[1];
			reference5 = (reference6 = target.GetComponent<Renderer>().material.color);
		}
		else if ((bool)target.GetComponent<Light>())
		{
			ref Color reference7 = ref array[0];
			ref Color reference8 = ref array[1];
			reference7 = (reference8 = target.GetComponent<Light>().color);
		}
		if (args.Contains("color"))
		{
			ref Color reference9 = ref array[1];
			reference9 = (Color)args["color"];
		}
		else
		{
			if (args.Contains("r"))
			{
				array[1].r = (float)args["r"];
			}
			if (args.Contains("g"))
			{
				array[1].g = (float)args["g"];
			}
			if (args.Contains("b"))
			{
				array[1].b = (float)args["b"];
			}
			if (args.Contains("a"))
			{
				array[1].a = (float)args["a"];
			}
		}
		array[3].r = Mathf.SmoothDamp(array[0].r, array[1].r, ref array[2].r, num);
		array[3].g = Mathf.SmoothDamp(array[0].g, array[1].g, ref array[2].g, num);
		array[3].b = Mathf.SmoothDamp(array[0].b, array[1].b, ref array[2].b, num);
		array[3].a = Mathf.SmoothDamp(array[0].a, array[1].a, ref array[2].a, num);
		if ((bool)target.GetComponent(typeof(GUITexture)))
		{
			target.GetComponent<GUITexture>().color = array[3];
		}
		else if ((bool)target.GetComponent(typeof(GUIText)))
		{
			target.GetComponent<GUIText>().material.color = array[3];
		}
		else if ((bool)target.GetComponent<Renderer>())
		{
			target.GetComponent<Renderer>().material.color = array[3];
		}
		else if ((bool)target.GetComponent<Light>())
		{
			target.GetComponent<Light>().color = array[3];
		}
	}

	public static void ColorUpdate(GameObject target, Color color, float time)
	{
		ColorUpdate(target, Hash("color", color, "time", time));
	}

	public static void AudioUpdate(GameObject target, Hashtable args)
	{
		CleanArgs(args);
		Vector2[] array = new Vector2[4];
		float num;
		if (args.Contains("time"))
		{
			num = (float)args["time"];
			num *= Defaults.updateTimePercentage;
		}
		else
		{
			num = Defaults.updateTime;
		}
		AudioSource audioSource;
		if (args.Contains("audiosource"))
		{
			audioSource = (AudioSource)args["audiosource"];
		}
		else
		{
			if (!target.GetComponent(typeof(AudioSource)))
			{
				Debug.LogError("iTween Error: AudioUpdate requires an AudioSource.");
				return;
			}
			audioSource = target.GetComponent<AudioSource>();
		}
		ref Vector2 reference = ref array[0];
		ref Vector2 reference2 = ref array[1];
		reference = (reference2 = new Vector2(audioSource.volume, audioSource.pitch));
		if (args.Contains("volume"))
		{
			array[1].x = (float)args["volume"];
		}
		if (args.Contains("pitch"))
		{
			array[1].y = (float)args["pitch"];
		}
		array[3].x = Mathf.SmoothDampAngle(array[0].x, array[1].x, ref array[2].x, num);
		array[3].y = Mathf.SmoothDampAngle(array[0].y, array[1].y, ref array[2].y, num);
		audioSource.volume = array[3].x;
		audioSource.pitch = array[3].y;
	}

	public static void AudioUpdate(GameObject target, float volume, float pitch, float time)
	{
		AudioUpdate(target, Hash("volume", volume, "pitch", pitch, "time", time));
	}

	public static void RotateUpdate(GameObject target, Hashtable args)
	{
		CleanArgs(args);
		Vector3[] array = new Vector3[4];
		Vector3 eulerAngles = target.transform.eulerAngles;
		float num;
		if (args.Contains("time"))
		{
			num = (float)args["time"];
			num *= Defaults.updateTimePercentage;
		}
		else
		{
			num = Defaults.updateTime;
		}
		bool flag = ((!args.Contains("islocal")) ? Defaults.isLocal : ((bool)args["islocal"]));
		if (flag)
		{
			ref Vector3 reference = ref array[0];
			reference = target.transform.localEulerAngles;
		}
		else
		{
			ref Vector3 reference2 = ref array[0];
			reference2 = target.transform.eulerAngles;
		}
		if (args.Contains("rotation"))
		{
			if (args["rotation"].GetType() == typeof(Transform))
			{
				Transform transform = (Transform)args["rotation"];
				ref Vector3 reference3 = ref array[1];
				reference3 = transform.eulerAngles;
			}
			else if (args["rotation"].GetType() == typeof(Vector3))
			{
				ref Vector3 reference4 = ref array[1];
				reference4 = (Vector3)args["rotation"];
			}
		}
		array[3].x = Mathf.SmoothDampAngle(array[0].x, array[1].x, ref array[2].x, num);
		array[3].y = Mathf.SmoothDampAngle(array[0].y, array[1].y, ref array[2].y, num);
		array[3].z = Mathf.SmoothDampAngle(array[0].z, array[1].z, ref array[2].z, num);
		if (flag)
		{
			target.transform.localEulerAngles = array[3];
		}
		else
		{
			target.transform.eulerAngles = array[3];
		}
		if (target.GetComponent<Rigidbody>() != null)
		{
			Vector3 eulerAngles2 = target.transform.eulerAngles;
			target.transform.eulerAngles = eulerAngles;
			target.GetComponent<Rigidbody>().MoveRotation(Quaternion.Euler(eulerAngles2));
		}
	}

	public static void RotateUpdate(GameObject target, Vector3 rotation, float time)
	{
		RotateUpdate(target, Hash("rotation", rotation, "time", time));
	}

	public static void ScaleUpdate(GameObject target, Hashtable args)
	{
		CleanArgs(args);
		Vector3[] array = new Vector3[4];
		float num;
		if (args.Contains("time"))
		{
			num = (float)args["time"];
			num *= Defaults.updateTimePercentage;
		}
		else
		{
			num = Defaults.updateTime;
		}
		ref Vector3 reference = ref array[0];
		ref Vector3 reference2 = ref array[1];
		reference = (reference2 = target.transform.localScale);
		if (args.Contains("scale"))
		{
			if (args["scale"].GetType() == typeof(Transform))
			{
				Transform transform = (Transform)args["scale"];
				ref Vector3 reference3 = ref array[1];
				reference3 = transform.localScale;
			}
			else if (args["scale"].GetType() == typeof(Vector3))
			{
				ref Vector3 reference4 = ref array[1];
				reference4 = (Vector3)args["scale"];
			}
		}
		else
		{
			if (args.Contains("x"))
			{
				array[1].x = (float)args["x"];
			}
			if (args.Contains("y"))
			{
				array[1].y = (float)args["y"];
			}
			if (args.Contains("z"))
			{
				array[1].z = (float)args["z"];
			}
		}
		array[3].x = Mathf.SmoothDamp(array[0].x, array[1].x, ref array[2].x, num);
		array[3].y = Mathf.SmoothDamp(array[0].y, array[1].y, ref array[2].y, num);
		array[3].z = Mathf.SmoothDamp(array[0].z, array[1].z, ref array[2].z, num);
		target.transform.localScale = array[3];
	}

	public static void ScaleUpdate(GameObject target, Vector3 scale, float time)
	{
		ScaleUpdate(target, Hash("scale", scale, "time", time));
	}

	public static void MoveUpdate(GameObject target, Hashtable args)
	{
		CleanArgs(args);
		Vector3[] array = new Vector3[4];
		Vector3 position = target.transform.position;
		float num;
		if (args.Contains("time"))
		{
			num = (float)args["time"];
			num *= Defaults.updateTimePercentage;
		}
		else
		{
			num = Defaults.updateTime;
		}
		bool flag = ((!args.Contains("islocal")) ? Defaults.isLocal : ((bool)args["islocal"]));
		if (flag)
		{
			ref Vector3 reference = ref array[0];
			ref Vector3 reference2 = ref array[1];
			reference = (reference2 = target.transform.localPosition);
		}
		else
		{
			ref Vector3 reference3 = ref array[0];
			ref Vector3 reference4 = ref array[1];
			reference3 = (reference4 = target.transform.position);
		}
		if (args.Contains("position"))
		{
			if (args["position"].GetType() == typeof(Transform))
			{
				Transform transform = (Transform)args["position"];
				ref Vector3 reference5 = ref array[1];
				reference5 = transform.position;
			}
			else if (args["position"].GetType() == typeof(Vector3))
			{
				ref Vector3 reference6 = ref array[1];
				reference6 = (Vector3)args["position"];
			}
		}
		else
		{
			if (args.Contains("x"))
			{
				array[1].x = (float)args["x"];
			}
			if (args.Contains("y"))
			{
				array[1].y = (float)args["y"];
			}
			if (args.Contains("z"))
			{
				array[1].z = (float)args["z"];
			}
		}
		array[3].x = Mathf.SmoothDamp(array[0].x, array[1].x, ref array[2].x, num);
		array[3].y = Mathf.SmoothDamp(array[0].y, array[1].y, ref array[2].y, num);
		array[3].z = Mathf.SmoothDamp(array[0].z, array[1].z, ref array[2].z, num);
		if (args.Contains("orienttopath") && (bool)args["orienttopath"])
		{
			args["looktarget"] = array[3];
		}
		if (args.Contains("looktarget"))
		{
			LookUpdate(target, args);
		}
		if (flag)
		{
			target.transform.localPosition = array[3];
		}
		else
		{
			target.transform.position = array[3];
		}
		if (target.GetComponent<Rigidbody>() != null)
		{
			Vector3 position2 = target.transform.position;
			target.transform.position = position;
			target.GetComponent<Rigidbody>().MovePosition(position2);
		}
	}

	public static void MoveUpdate(GameObject target, Vector3 position, float time)
	{
		MoveUpdate(target, Hash("position", position, "time", time));
	}

	public static void LookUpdate(GameObject target, Hashtable args)
	{
		CleanArgs(args);
		Vector3[] array = new Vector3[5];
		float num;
		if (args.Contains("looktime"))
		{
			num = (float)args["looktime"];
			num *= Defaults.updateTimePercentage;
		}
		else if (args.Contains("time"))
		{
			num = (float)args["time"] * 0.15f;
			num *= Defaults.updateTimePercentage;
		}
		else
		{
			num = Defaults.updateTime;
		}
		ref Vector3 reference = ref array[0];
		reference = target.transform.eulerAngles;
		if (args.Contains("looktarget"))
		{
			if (args["looktarget"].GetType() == typeof(Transform))
			{
				Transform obj = target.transform;
				Transform target2 = (Transform)args["looktarget"];
				Vector3? vector = (Vector3?)args["up"];
				obj.LookAt(target2, (!vector.HasValue) ? Defaults.up : vector.Value);
			}
			else if (args["looktarget"].GetType() == typeof(Vector3))
			{
				Transform obj2 = target.transform;
				Vector3 worldPosition = (Vector3)args["looktarget"];
				Vector3? vector2 = (Vector3?)args["up"];
				obj2.LookAt(worldPosition, (!vector2.HasValue) ? Defaults.up : vector2.Value);
			}
			ref Vector3 reference2 = ref array[1];
			reference2 = target.transform.eulerAngles;
			target.transform.eulerAngles = array[0];
			array[3].x = Mathf.SmoothDampAngle(array[0].x, array[1].x, ref array[2].x, num);
			array[3].y = Mathf.SmoothDampAngle(array[0].y, array[1].y, ref array[2].y, num);
			array[3].z = Mathf.SmoothDampAngle(array[0].z, array[1].z, ref array[2].z, num);
			target.transform.eulerAngles = array[3];
			if (args.Contains("axis"))
			{
				ref Vector3 reference3 = ref array[4];
				reference3 = target.transform.eulerAngles;
				switch ((string)args["axis"])
				{
				case "x":
					array[4].y = array[0].y;
					array[4].z = array[0].z;
					break;
				case "y":
					array[4].x = array[0].x;
					array[4].z = array[0].z;
					break;
				case "z":
					array[4].x = array[0].x;
					array[4].y = array[0].y;
					break;
				}
				target.transform.eulerAngles = array[4];
			}
		}
		else
		{
			Debug.LogError("iTween Error: LookUpdate needs a 'looktarget' property!");
		}
	}

	public static void LookUpdate(GameObject target, Vector3 looktarget, float time)
	{
		LookUpdate(target, Hash("looktarget", looktarget, "time", time));
	}

	public static float PathLength(Transform[] path)
	{
		Vector3[] array = new Vector3[path.Length];
		float num = 0f;
		for (int i = 0; i < path.Length; i++)
		{
			ref Vector3 reference = ref array[i];
			reference = path[i].position;
		}
		Vector3[] pts = PathControlPointGenerator(array);
		Vector3 a = Interp(pts, 0f);
		int num2 = path.Length * 20;
		for (int j = 1; j <= num2; j++)
		{
			float t = (float)j / (float)num2;
			Vector3 vector = Interp(pts, t);
			num += Vector3.Distance(a, vector);
			a = vector;
		}
		return num;
	}

	public static float PathLength(Vector3[] path)
	{
		float num = 0f;
		Vector3[] pts = PathControlPointGenerator(path);
		Vector3 a = Interp(pts, 0f);
		int num2 = path.Length * 20;
		for (int i = 1; i <= num2; i++)
		{
			float t = (float)i / (float)num2;
			Vector3 vector = Interp(pts, t);
			num += Vector3.Distance(a, vector);
			a = vector;
		}
		return num;
	}

	public static Texture2D CameraTexture(Color color)
	{
		Texture2D texture2D = new Texture2D(Screen.width, Screen.height, TextureFormat.ARGB32, mipmap: false);
		Color[] array = new Color[Screen.width * Screen.height];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = color;
		}
		texture2D.SetPixels(array);
		texture2D.Apply();
		return texture2D;
	}

	public static void PutOnPath(GameObject target, Vector3[] path, float percent)
	{
		target.transform.position = Interp(PathControlPointGenerator(path), percent);
	}

	public static void PutOnPath(Transform target, Vector3[] path, float percent)
	{
		target.position = Interp(PathControlPointGenerator(path), percent);
	}

	public static void PutOnPath(GameObject target, Transform[] path, float percent)
	{
		Vector3[] array = new Vector3[path.Length];
		for (int i = 0; i < path.Length; i++)
		{
			ref Vector3 reference = ref array[i];
			reference = path[i].position;
		}
		target.transform.position = Interp(PathControlPointGenerator(array), percent);
	}

	public static void PutOnPath(Transform target, Transform[] path, float percent)
	{
		Vector3[] array = new Vector3[path.Length];
		for (int i = 0; i < path.Length; i++)
		{
			ref Vector3 reference = ref array[i];
			reference = path[i].position;
		}
		target.position = Interp(PathControlPointGenerator(array), percent);
	}

	public static Vector3 PointOnPath(Transform[] path, float percent)
	{
		Vector3[] array = new Vector3[path.Length];
		for (int i = 0; i < path.Length; i++)
		{
			ref Vector3 reference = ref array[i];
			reference = path[i].position;
		}
		return Interp(PathControlPointGenerator(array), percent);
	}

	public static void DrawLine(Vector3[] line)
	{
		if (line.Length > 0)
		{
			DrawLineHelper(line, Defaults.color, "gizmos");
		}
	}

	public static void DrawLine(Vector3[] line, Color color)
	{
		if (line.Length > 0)
		{
			DrawLineHelper(line, color, "gizmos");
		}
	}

	public static void DrawLine(Transform[] line)
	{
		if (line.Length > 0)
		{
			Vector3[] array = new Vector3[line.Length];
			for (int i = 0; i < line.Length; i++)
			{
				ref Vector3 reference = ref array[i];
				reference = line[i].position;
			}
			DrawLineHelper(array, Defaults.color, "gizmos");
		}
	}

	public static void DrawLine(Transform[] line, Color color)
	{
		if (line.Length > 0)
		{
			Vector3[] array = new Vector3[line.Length];
			for (int i = 0; i < line.Length; i++)
			{
				ref Vector3 reference = ref array[i];
				reference = line[i].position;
			}
			DrawLineHelper(array, color, "gizmos");
		}
	}

	public static void DrawLineGizmos(Vector3[] line)
	{
		if (line.Length > 0)
		{
			DrawLineHelper(line, Defaults.color, "gizmos");
		}
	}

	public static void DrawLineGizmos(Vector3[] line, Color color)
	{
		if (line.Length > 0)
		{
			DrawLineHelper(line, color, "gizmos");
		}
	}

	public static void DrawLineGizmos(Transform[] line)
	{
		if (line.Length > 0)
		{
			Vector3[] array = new Vector3[line.Length];
			for (int i = 0; i < line.Length; i++)
			{
				ref Vector3 reference = ref array[i];
				reference = line[i].position;
			}
			DrawLineHelper(array, Defaults.color, "gizmos");
		}
	}

	public static void DrawLineGizmos(Transform[] line, Color color)
	{
		if (line.Length > 0)
		{
			Vector3[] array = new Vector3[line.Length];
			for (int i = 0; i < line.Length; i++)
			{
				ref Vector3 reference = ref array[i];
				reference = line[i].position;
			}
			DrawLineHelper(array, color, "gizmos");
		}
	}

	public static void DrawLineHandles(Vector3[] line)
	{
		if (line.Length > 0)
		{
			DrawLineHelper(line, Defaults.color, "handles");
		}
	}

	public static void DrawLineHandles(Vector3[] line, Color color)
	{
		if (line.Length > 0)
		{
			DrawLineHelper(line, color, "handles");
		}
	}

	public static void DrawLineHandles(Transform[] line)
	{
		if (line.Length > 0)
		{
			Vector3[] array = new Vector3[line.Length];
			for (int i = 0; i < line.Length; i++)
			{
				ref Vector3 reference = ref array[i];
				reference = line[i].position;
			}
			DrawLineHelper(array, Defaults.color, "handles");
		}
	}

	public static void DrawLineHandles(Transform[] line, Color color)
	{
		if (line.Length > 0)
		{
			Vector3[] array = new Vector3[line.Length];
			for (int i = 0; i < line.Length; i++)
			{
				ref Vector3 reference = ref array[i];
				reference = line[i].position;
			}
			DrawLineHelper(array, color, "handles");
		}
	}

	public static Vector3 PointOnPath(Vector3[] path, float percent)
	{
		return Interp(PathControlPointGenerator(path), percent);
	}

	public static void DrawPath(Vector3[] path)
	{
		if (path.Length > 0)
		{
			DrawPathHelper(path, Defaults.color, "gizmos");
		}
	}

	public static void DrawPath(Vector3[] path, Color color)
	{
		if (path.Length > 0)
		{
			DrawPathHelper(path, color, "gizmos");
		}
	}

	public static void DrawPath(Transform[] path)
	{
		if (path.Length > 0)
		{
			Vector3[] array = new Vector3[path.Length];
			for (int i = 0; i < path.Length; i++)
			{
				ref Vector3 reference = ref array[i];
				reference = path[i].position;
			}
			DrawPathHelper(array, Defaults.color, "gizmos");
		}
	}

	public static void DrawPath(Transform[] path, Color color)
	{
		if (path.Length > 0)
		{
			Vector3[] array = new Vector3[path.Length];
			for (int i = 0; i < path.Length; i++)
			{
				ref Vector3 reference = ref array[i];
				reference = path[i].position;
			}
			DrawPathHelper(array, color, "gizmos");
		}
	}

	public static void DrawPathGizmos(Vector3[] path)
	{
		if (path.Length > 0)
		{
			DrawPathHelper(path, Defaults.color, "gizmos");
		}
	}

	public static void DrawPathGizmos(Vector3[] path, Color color)
	{
		if (path.Length > 0)
		{
			DrawPathHelper(path, color, "gizmos");
		}
	}

	public static void DrawPathGizmos(Transform[] path)
	{
		if (path.Length > 0)
		{
			Vector3[] array = new Vector3[path.Length];
			for (int i = 0; i < path.Length; i++)
			{
				ref Vector3 reference = ref array[i];
				reference = path[i].position;
			}
			DrawPathHelper(array, Defaults.color, "gizmos");
		}
	}

	public static void DrawPathGizmos(Transform[] path, Color color)
	{
		if (path.Length > 0)
		{
			Vector3[] array = new Vector3[path.Length];
			for (int i = 0; i < path.Length; i++)
			{
				ref Vector3 reference = ref array[i];
				reference = path[i].position;
			}
			DrawPathHelper(array, color, "gizmos");
		}
	}

	public static void DrawPathHandles(Vector3[] path)
	{
		if (path.Length > 0)
		{
			DrawPathHelper(path, Defaults.color, "handles");
		}
	}

	public static void DrawPathHandles(Vector3[] path, Color color)
	{
		if (path.Length > 0)
		{
			DrawPathHelper(path, color, "handles");
		}
	}

	public static void DrawPathHandles(Transform[] path)
	{
		if (path.Length > 0)
		{
			Vector3[] array = new Vector3[path.Length];
			for (int i = 0; i < path.Length; i++)
			{
				ref Vector3 reference = ref array[i];
				reference = path[i].position;
			}
			DrawPathHelper(array, Defaults.color, "handles");
		}
	}

	public static void DrawPathHandles(Transform[] path, Color color)
	{
		if (path.Length > 0)
		{
			Vector3[] array = new Vector3[path.Length];
			for (int i = 0; i < path.Length; i++)
			{
				ref Vector3 reference = ref array[i];
				reference = path[i].position;
			}
			DrawPathHelper(array, color, "handles");
		}
	}

	public static void CameraFadeDepth(int depth)
	{
		if ((bool)cameraFade)
		{
			cameraFade.transform.position = new Vector3(cameraFade.transform.position.x, cameraFade.transform.position.y, depth);
		}
	}

	public static void CameraFadeDestroy()
	{
		if ((bool)cameraFade)
		{
			UnityEngine.Object.Destroy(cameraFade);
		}
	}

	public static void CameraFadeSwap(Texture2D texture)
	{
		if ((bool)cameraFade)
		{
			cameraFade.GetComponent<GUITexture>().texture = texture;
		}
	}

	public static GameObject CameraFadeAdd(Texture2D texture, int depth)
	{
		if ((bool)cameraFade)
		{
			return null;
		}
		cameraFade = new GameObject("iTween Camera Fade");
		cameraFade.transform.position = new Vector3(0.5f, 0.5f, depth);
		cameraFade.AddComponent<GUITexture>();
		cameraFade.GetComponent<GUITexture>().texture = texture;
		cameraFade.GetComponent<GUITexture>().color = new Color(0.5f, 0.5f, 0.5f, 0f);
		return cameraFade;
	}

	public static GameObject CameraFadeAdd(Texture2D texture)
	{
		if ((bool)cameraFade)
		{
			return null;
		}
		cameraFade = new GameObject("iTween Camera Fade");
		cameraFade.transform.position = new Vector3(0.5f, 0.5f, Defaults.cameraFadeDepth);
		cameraFade.AddComponent<GUITexture>();
		cameraFade.GetComponent<GUITexture>().texture = texture;
		cameraFade.GetComponent<GUITexture>().color = new Color(0.5f, 0.5f, 0.5f, 0f);
		return cameraFade;
	}

	public static GameObject CameraFadeAdd()
	{
		if ((bool)cameraFade)
		{
			return null;
		}
		cameraFade = new GameObject("iTween Camera Fade");
		cameraFade.transform.position = new Vector3(0.5f, 0.5f, Defaults.cameraFadeDepth);
		cameraFade.AddComponent<GUITexture>();
		cameraFade.GetComponent<GUITexture>().texture = CameraTexture(Color.black);
		cameraFade.GetComponent<GUITexture>().color = new Color(0.5f, 0.5f, 0.5f, 0f);
		return cameraFade;
	}

	public static void Resume(GameObject target)
	{
		Component[] components = target.GetComponents(typeof(iTween));
		Component[] array = components;
		for (int i = 0; i < array.Length; i++)
		{
			iTween iTween2 = (iTween)array[i];
			iTween2.enabled = true;
		}
	}

	public static void Resume(GameObject target, bool includechildren)
	{
		Resume(target);
		if (!includechildren)
		{
			return;
		}
		foreach (Transform item in target.transform)
		{
			Resume(item.gameObject, includechildren: true);
		}
	}

	public static void Resume(GameObject target, string type)
	{
		Component[] components = target.GetComponents(typeof(iTween));
		Component[] array = components;
		for (int i = 0; i < array.Length; i++)
		{
			iTween iTween2 = (iTween)array[i];
			string text = iTween2.type + iTween2.method;
			text = text.Substring(0, type.Length);
			if (text.ToLower() == type.ToLower())
			{
				iTween2.enabled = true;
			}
		}
	}

	public static void Resume(GameObject target, string type, bool includechildren)
	{
		Component[] components = target.GetComponents(typeof(iTween));
		Component[] array = components;
		for (int i = 0; i < array.Length; i++)
		{
			iTween iTween2 = (iTween)array[i];
			string text = iTween2.type + iTween2.method;
			text = text.Substring(0, type.Length);
			if (text.ToLower() == type.ToLower())
			{
				iTween2.enabled = true;
			}
		}
		if (!includechildren)
		{
			return;
		}
		foreach (Transform item in target.transform)
		{
			Resume(item.gameObject, type, includechildren: true);
		}
	}

	public static void Resume()
	{
		for (int i = 0; i < tweens.Count; i++)
		{
			Hashtable hashtable = (Hashtable)tweens[i];
			GameObject target = (GameObject)hashtable["target"];
			Resume(target);
		}
	}

	public static void Resume(string type)
	{
		ArrayList arrayList = new ArrayList();
		for (int i = 0; i < tweens.Count; i++)
		{
			Hashtable hashtable = (Hashtable)tweens[i];
			GameObject value = (GameObject)hashtable["target"];
			arrayList.Insert(arrayList.Count, value);
		}
		for (int j = 0; j < arrayList.Count; j++)
		{
			Resume((GameObject)arrayList[j], type);
		}
	}

	public static void Pause(GameObject target)
	{
		Component[] components = target.GetComponents(typeof(iTween));
		Component[] array = components;
		for (int i = 0; i < array.Length; i++)
		{
			iTween iTween2 = (iTween)array[i];
			if (iTween2.delay > 0f)
			{
				iTween2.delay -= Time.time - iTween2.delayStarted;
				iTween2.StopCoroutine("TweenDelay");
			}
			iTween2.isPaused = true;
			iTween2.enabled = false;
		}
	}

	public static void Pause(GameObject target, bool includechildren)
	{
		Pause(target);
		if (!includechildren)
		{
			return;
		}
		foreach (Transform item in target.transform)
		{
			Pause(item.gameObject, includechildren: true);
		}
	}

	public static void Pause(GameObject target, string type)
	{
		Component[] components = target.GetComponents(typeof(iTween));
		Component[] array = components;
		for (int i = 0; i < array.Length; i++)
		{
			iTween iTween2 = (iTween)array[i];
			string text = iTween2.type + iTween2.method;
			text = text.Substring(0, type.Length);
			if (text.ToLower() == type.ToLower())
			{
				if (iTween2.delay > 0f)
				{
					iTween2.delay -= Time.time - iTween2.delayStarted;
					iTween2.StopCoroutine("TweenDelay");
				}
				iTween2.isPaused = true;
				iTween2.enabled = false;
			}
		}
	}

	public static void Pause(GameObject target, string type, bool includechildren)
	{
		Component[] components = target.GetComponents(typeof(iTween));
		Component[] array = components;
		for (int i = 0; i < array.Length; i++)
		{
			iTween iTween2 = (iTween)array[i];
			string text = iTween2.type + iTween2.method;
			text = text.Substring(0, type.Length);
			if (text.ToLower() == type.ToLower())
			{
				if (iTween2.delay > 0f)
				{
					iTween2.delay -= Time.time - iTween2.delayStarted;
					iTween2.StopCoroutine("TweenDelay");
				}
				iTween2.isPaused = true;
				iTween2.enabled = false;
			}
		}
		if (!includechildren)
		{
			return;
		}
		foreach (Transform item in target.transform)
		{
			Pause(item.gameObject, type, includechildren: true);
		}
	}

	public static void Pause()
	{
		for (int i = 0; i < tweens.Count; i++)
		{
			Hashtable hashtable = (Hashtable)tweens[i];
			GameObject target = (GameObject)hashtable["target"];
			Pause(target);
		}
	}

	public static void Pause(string type)
	{
		ArrayList arrayList = new ArrayList();
		for (int i = 0; i < tweens.Count; i++)
		{
			Hashtable hashtable = (Hashtable)tweens[i];
			GameObject value = (GameObject)hashtable["target"];
			arrayList.Insert(arrayList.Count, value);
		}
		for (int j = 0; j < arrayList.Count; j++)
		{
			Pause((GameObject)arrayList[j], type);
		}
	}

	public static int Count()
	{
		return tweens.Count;
	}

	public static int Count(string type)
	{
		int num = 0;
		for (int i = 0; i < tweens.Count; i++)
		{
			Hashtable hashtable = (Hashtable)tweens[i];
			string text = (string)hashtable["type"] + (string)hashtable["method"];
			text = text.Substring(0, type.Length);
			if (text.ToLower() == type.ToLower())
			{
				num++;
			}
		}
		return num;
	}

	public static int Count(GameObject target)
	{
		Component[] components = target.GetComponents(typeof(iTween));
		return components.Length;
	}

	public static int Count(GameObject target, string type)
	{
		int num = 0;
		Component[] components = target.GetComponents(typeof(iTween));
		Component[] array = components;
		for (int i = 0; i < array.Length; i++)
		{
			iTween iTween2 = (iTween)array[i];
			string text = iTween2.type + iTween2.method;
			text = text.Substring(0, type.Length);
			if (text.ToLower() == type.ToLower())
			{
				num++;
			}
		}
		return num;
	}

	public static void Stop()
	{
		for (int i = 0; i < tweens.Count; i++)
		{
			Hashtable hashtable = (Hashtable)tweens[i];
			GameObject target = (GameObject)hashtable["target"];
			Stop(target);
		}
		tweens.Clear();
	}

	public static void Stop(string type)
	{
		ArrayList arrayList = new ArrayList();
		for (int i = 0; i < tweens.Count; i++)
		{
			Hashtable hashtable = (Hashtable)tweens[i];
			GameObject value = (GameObject)hashtable["target"];
			arrayList.Insert(arrayList.Count, value);
		}
		for (int j = 0; j < arrayList.Count; j++)
		{
			Stop((GameObject)arrayList[j], type);
		}
	}

	public static void StopByName(string name)
	{
		ArrayList arrayList = new ArrayList();
		for (int i = 0; i < tweens.Count; i++)
		{
			Hashtable hashtable = (Hashtable)tweens[i];
			GameObject value = (GameObject)hashtable["target"];
			arrayList.Insert(arrayList.Count, value);
		}
		for (int j = 0; j < arrayList.Count; j++)
		{
			StopByName((GameObject)arrayList[j], name);
		}
	}

	public static void Stop(GameObject target)
	{
		Component[] components = target.GetComponents(typeof(iTween));
		Component[] array = components;
		for (int i = 0; i < array.Length; i++)
		{
			iTween iTween2 = (iTween)array[i];
			iTween2.Dispose();
		}
	}

	public static void Stop(GameObject target, bool includechildren)
	{
		Stop(target);
		if (!includechildren)
		{
			return;
		}
		foreach (Transform item in target.transform)
		{
			Stop(item.gameObject, includechildren: true);
		}
	}

	public static void Stop(GameObject target, string type)
	{
		Component[] components = target.GetComponents(typeof(iTween));
		Component[] array = components;
		for (int i = 0; i < array.Length; i++)
		{
			iTween iTween2 = (iTween)array[i];
			string text = iTween2.type + iTween2.method;
			text = text.Substring(0, type.Length);
			if (text.ToLower() == type.ToLower())
			{
				iTween2.Dispose();
			}
		}
	}

	public static void StopByName(GameObject target, string name)
	{
		Component[] components = target.GetComponents(typeof(iTween));
		Component[] array = components;
		for (int i = 0; i < array.Length; i++)
		{
			iTween iTween2 = (iTween)array[i];
			if (iTween2._name == name)
			{
				iTween2.Dispose();
			}
		}
	}

	public static void Stop(GameObject target, string type, bool includechildren)
	{
		Component[] components = target.GetComponents(typeof(iTween));
		Component[] array = components;
		for (int i = 0; i < array.Length; i++)
		{
			iTween iTween2 = (iTween)array[i];
			string text = iTween2.type + iTween2.method;
			text = text.Substring(0, type.Length);
			if (text.ToLower() == type.ToLower())
			{
				iTween2.Dispose();
			}
		}
		if (!includechildren)
		{
			return;
		}
		foreach (Transform item in target.transform)
		{
			Stop(item.gameObject, type, includechildren: true);
		}
	}

	public static void StopByName(GameObject target, string name, bool includechildren)
	{
		Component[] components = target.GetComponents(typeof(iTween));
		Component[] array = components;
		for (int i = 0; i < array.Length; i++)
		{
			iTween iTween2 = (iTween)array[i];
			if (iTween2._name == name)
			{
				iTween2.Dispose();
			}
		}
		if (!includechildren)
		{
			return;
		}
		foreach (Transform item in target.transform)
		{
			StopByName(item.gameObject, name, includechildren: true);
		}
	}

	public static Hashtable Hash(params object[] args)
	{
		Hashtable hashtable = new Hashtable(args.Length / 2);
		if (args.Length % 2 != 0)
		{
			Debug.LogError("Tween Error: Hash requires an even number of arguments!");
			return null;
		}
		for (int i = 0; i < args.Length - 1; i += 2)
		{
			hashtable.Add(args[i], args[i + 1]);
		}
		return hashtable;
	}

	private void Awake()
	{
		RetrieveArgs();
		lastRealTime = Time.realtimeSinceStartup;
	}

	private IEnumerator Start()
	{
		if (delay > 0f)
		{
			yield return StartCoroutine("TweenDelay");
		}
		TweenStart();
	}

	private void Update()
	{
		if (!isRunning || physics)
		{
			return;
		}
		if (!reverse)
		{
			if (percentage < 1f)
			{
				TweenUpdate();
			}
			else
			{
				TweenComplete();
			}
		}
		else if (percentage > 0f)
		{
			TweenUpdate();
		}
		else
		{
			TweenComplete();
		}
	}

	private void FixedUpdate()
	{
		if (!isRunning || !physics)
		{
			return;
		}
		if (!reverse)
		{
			if (percentage < 1f)
			{
				TweenUpdate();
			}
			else
			{
				TweenComplete();
			}
		}
		else if (percentage > 0f)
		{
			TweenUpdate();
		}
		else
		{
			TweenComplete();
		}
	}

	private void LateUpdate()
	{
		if (tweenArguments.Contains("looktarget") && isRunning && (type == "move" || type == "shake" || type == "punch"))
		{
			LookUpdate(base.gameObject, tweenArguments);
		}
	}

	private void OnEnable()
	{
		if (isRunning)
		{
			EnableKinematic();
		}
		if (isPaused)
		{
			isPaused = false;
			if (delay > 0f)
			{
				wasPaused = true;
				ResumeDelay();
			}
		}
	}

	private void OnDisable()
	{
		DisableKinematic();
	}

	private static void DrawLineHelper(Vector3[] line, Color color, string method)
	{
		Gizmos.color = color;
		for (int i = 0; i < line.Length - 1; i++)
		{
			if (method == "gizmos")
			{
				Gizmos.DrawLine(line[i], line[i + 1]);
			}
			else if (method == "handles")
			{
				Debug.LogError("iTween Error: Drawing a line with Handles is temporarily disabled because of compatability issues with Unity 2.6!");
			}
		}
	}

	private static void DrawPathHelper(Vector3[] path, Color color, string method)
	{
		Vector3[] pts = PathControlPointGenerator(path);
		Vector3 to = Interp(pts, 0f);
		Gizmos.color = color;
		int num = path.Length * 20;
		for (int i = 1; i <= num; i++)
		{
			float t = (float)i / (float)num;
			Vector3 vector = Interp(pts, t);
			if (method == "gizmos")
			{
				Gizmos.DrawLine(vector, to);
			}
			else if (method == "handles")
			{
				Debug.LogError("iTween Error: Drawing a path with Handles is temporarily disabled because of compatability issues with Unity 2.6!");
			}
			to = vector;
		}
	}

	private static Vector3[] PathControlPointGenerator(Vector3[] path)
	{
		int num = 2;
		Vector3[] array = new Vector3[path.Length + num];
		Array.Copy(path, 0, array, 1, path.Length);
		ref Vector3 reference = ref array[0];
		reference = array[1] + (array[1] - array[2]);
		ref Vector3 reference2 = ref array[array.Length - 1];
		reference2 = array[array.Length - 2] + (array[array.Length - 2] - array[array.Length - 3]);
		if (array[1] == array[array.Length - 2])
		{
			Vector3[] array2 = new Vector3[array.Length];
			Array.Copy(array, array2, array.Length);
			ref Vector3 reference3 = ref array2[0];
			reference3 = array2[array2.Length - 3];
			ref Vector3 reference4 = ref array2[array2.Length - 1];
			reference4 = array2[2];
			array = new Vector3[array2.Length];
			Array.Copy(array2, array, array2.Length);
		}
		return array;
	}

	private static Vector3 Interp(Vector3[] pts, float t)
	{
		int num = pts.Length - 3;
		int num2 = Mathf.Min(Mathf.FloorToInt(t * (float)num), num - 1);
		float num3 = t * (float)num - (float)num2;
		Vector3 vector = pts[num2];
		Vector3 vector2 = pts[num2 + 1];
		Vector3 vector3 = pts[num2 + 2];
		Vector3 vector4 = pts[num2 + 3];
		return 0.5f * ((-vector + 3f * vector2 - 3f * vector3 + vector4) * (num3 * num3 * num3) + (2f * vector - 5f * vector2 + 4f * vector3 - vector4) * (num3 * num3) + (-vector + vector3) * num3 + 2f * vector2);
	}

	private static void Launch(GameObject target, Hashtable args)
	{
		if (!args.Contains("id"))
		{
			args["id"] = GenerateID();
		}
		if (!args.Contains("target"))
		{
			args["target"] = target;
		}
		tweens.Insert(0, args);
		target.AddComponent<iTween>();
	}

	private static Hashtable CleanArgs(Hashtable args)
	{
		Hashtable hashtable = new Hashtable(args.Count);
		Hashtable hashtable2 = new Hashtable(args.Count);
		foreach (DictionaryEntry arg in args)
		{
			hashtable.Add(arg.Key, arg.Value);
		}
		foreach (DictionaryEntry item in hashtable)
		{
			if (item.Value.GetType() == typeof(int))
			{
				int num = (int)item.Value;
				float num2 = num;
				args[item.Key] = num2;
			}
			if (item.Value.GetType() == typeof(double))
			{
				double num3 = (double)item.Value;
				float num4 = (float)num3;
				args[item.Key] = num4;
			}
		}
		foreach (DictionaryEntry arg2 in args)
		{
			hashtable2.Add(arg2.Key.ToString().ToLower(), arg2.Value);
		}
		args = hashtable2;
		return args;
	}

	private static string GenerateID()
	{
		int num = 15;
		char[] array = new char[61]
		{
			'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',
			'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
			'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D',
			'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',
			'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
			'Y', 'Z', '0', '1', '2', '3', '4', '5', '6', '7',
			'8'
		};
		int max = array.Length - 1;
		string text = string.Empty;
		for (int i = 0; i < num; i++)
		{
			text += array[(int)Mathf.Floor(UnityEngine.Random.Range(0, max))];
		}
		return text;
	}

	private void RetrieveArgs()
	{
		foreach (Hashtable tween in tweens)
		{
			if ((GameObject)tween["target"] == base.gameObject)
			{
				tweenArguments = tween;
				break;
			}
		}
		id = (string)tweenArguments["id"];
		type = (string)tweenArguments["type"];
		_name = (string)tweenArguments["name"];
		method = (string)tweenArguments["method"];
		if (tweenArguments.Contains("time"))
		{
			time = (float)tweenArguments["time"];
		}
		else
		{
			time = Defaults.time;
		}
		if (GetComponent<Rigidbody>() != null)
		{
			physics = true;
		}
		if (tweenArguments.Contains("delay"))
		{
			delay = (float)tweenArguments["delay"];
		}
		else
		{
			delay = Defaults.delay;
		}
		if (tweenArguments.Contains("namedcolorvalue"))
		{
			if (tweenArguments["namedcolorvalue"].GetType() == typeof(NamedValueColor))
			{
				namedcolorvalue = (NamedValueColor)tweenArguments["namedcolorvalue"];
			}
			else
			{
				try
				{
					namedcolorvalue = (NamedValueColor)Enum.Parse(typeof(NamedValueColor), (string)tweenArguments["namedcolorvalue"], ignoreCase: true);
				}
				catch
				{
					Debug.LogWarning("iTween: Unsupported namedcolorvalue supplied! Default will be used.");
					namedcolorvalue = NamedValueColor._Color;
				}
			}
		}
		else
		{
			namedcolorvalue = Defaults.namedColorValue;
		}
		if (tweenArguments.Contains("looptype"))
		{
			if (tweenArguments["looptype"].GetType() == typeof(LoopType))
			{
				loopType = (LoopType)tweenArguments["looptype"];
			}
			else
			{
				try
				{
					loopType = (LoopType)Enum.Parse(typeof(LoopType), (string)tweenArguments["looptype"], ignoreCase: true);
				}
				catch
				{
					Debug.LogWarning("iTween: Unsupported loopType supplied! Default will be used.");
					loopType = LoopType.none;
				}
			}
		}
		else
		{
			loopType = LoopType.none;
		}
		if (tweenArguments.Contains("easetype"))
		{
			if (tweenArguments["easetype"].GetType() == typeof(EaseType))
			{
				easeType = (EaseType)tweenArguments["easetype"];
			}
			else
			{
				try
				{
					easeType = (EaseType)Enum.Parse(typeof(EaseType), (string)tweenArguments["easetype"], ignoreCase: true);
				}
				catch
				{
					Debug.LogWarning("iTween: Unsupported easeType supplied! Default will be used.");
					easeType = Defaults.easeType;
				}
			}
		}
		else
		{
			easeType = Defaults.easeType;
		}
		if (tweenArguments.Contains("space"))
		{
			if (tweenArguments["space"].GetType() == typeof(Space))
			{
				space = (Space)tweenArguments["space"];
			}
			else
			{
				try
				{
					space = (Space)Enum.Parse(typeof(Space), (string)tweenArguments["space"], ignoreCase: true);
				}
				catch
				{
					Debug.LogWarning("iTween: Unsupported space supplied! Default will be used.");
					space = Defaults.space;
				}
			}
		}
		else
		{
			space = Defaults.space;
		}
		if (tweenArguments.Contains("islocal"))
		{
			isLocal = (bool)tweenArguments["islocal"];
		}
		else
		{
			isLocal = Defaults.isLocal;
		}
		if (tweenArguments.Contains("ignoretimescale"))
		{
			useRealTime = (bool)tweenArguments["ignoretimescale"];
		}
		else
		{
			useRealTime = Defaults.useRealTime;
		}
		GetEasingFunction();
	}

	private void GetEasingFunction()
	{
		switch (easeType)
		{
		case EaseType.easeInQuad:
			ease = easeInQuad;
			break;
		case EaseType.easeOutQuad:
			ease = easeOutQuad;
			break;
		case EaseType.easeInOutQuad:
			ease = easeInOutQuad;
			break;
		case EaseType.easeInCubic:
			ease = easeInCubic;
			break;
		case EaseType.easeOutCubic:
			ease = easeOutCubic;
			break;
		case EaseType.easeInOutCubic:
			ease = easeInOutCubic;
			break;
		case EaseType.easeInQuart:
			ease = easeInQuart;
			break;
		case EaseType.easeOutQuart:
			ease = easeOutQuart;
			break;
		case EaseType.easeInOutQuart:
			ease = easeInOutQuart;
			break;
		case EaseType.easeInQuint:
			ease = easeInQuint;
			break;
		case EaseType.easeOutQuint:
			ease = easeOutQuint;
			break;
		case EaseType.easeInOutQuint:
			ease = easeInOutQuint;
			break;
		case EaseType.easeInSine:
			ease = easeInSine;
			break;
		case EaseType.easeOutSine:
			ease = easeOutSine;
			break;
		case EaseType.easeInOutSine:
			ease = easeInOutSine;
			break;
		case EaseType.easeInExpo:
			ease = easeInExpo;
			break;
		case EaseType.easeOutExpo:
			ease = easeOutExpo;
			break;
		case EaseType.easeInOutExpo:
			ease = easeInOutExpo;
			break;
		case EaseType.easeInCirc:
			ease = easeInCirc;
			break;
		case EaseType.easeOutCirc:
			ease = easeOutCirc;
			break;
		case EaseType.easeInOutCirc:
			ease = easeInOutCirc;
			break;
		case EaseType.linear:
			ease = linear;
			break;
		case EaseType.spring:
			ease = spring;
			break;
		case EaseType.easeInBounce:
			ease = easeInBounce;
			break;
		case EaseType.easeOutBounce:
			ease = easeOutBounce;
			break;
		case EaseType.easeInOutBounce:
			ease = easeInOutBounce;
			break;
		case EaseType.easeInBack:
			ease = easeInBack;
			break;
		case EaseType.easeOutBack:
			ease = easeOutBack;
			break;
		case EaseType.easeInOutBack:
			ease = easeInOutBack;
			break;
		case EaseType.easeInElastic:
			ease = easeInElastic;
			break;
		case EaseType.easeOutElastic:
			ease = easeOutElastic;
			break;
		case EaseType.easeInOutElastic:
			ease = easeInOutElastic;
			break;
		}
	}

	private void UpdatePercentage()
	{
		if (useRealTime)
		{
			runningTime += Time.realtimeSinceStartup - lastRealTime;
		}
		else
		{
			runningTime += Time.deltaTime;
		}
		if (reverse)
		{
			percentage = 1f - runningTime / time;
		}
		else
		{
			percentage = runningTime / time;
		}
		lastRealTime = Time.realtimeSinceStartup;
	}

	private void CallBack(string callbackType)
	{
		if (tweenArguments.Contains(callbackType) && !tweenArguments.Contains("ischild"))
		{
			GameObject gameObject = ((!tweenArguments.Contains(callbackType + "target")) ? base.gameObject : ((GameObject)tweenArguments[callbackType + "target"]));
			if (tweenArguments[callbackType].GetType() == typeof(string))
			{
				gameObject.SendMessage((string)tweenArguments[callbackType], tweenArguments[callbackType + "params"], SendMessageOptions.DontRequireReceiver);
				return;
			}
			Debug.LogError("iTween Error: Callback method references must be passed as a String!");
			UnityEngine.Object.Destroy(this);
		}
	}

	private void Dispose()
	{
		for (int i = 0; i < tweens.Count; i++)
		{
			Hashtable hashtable = (Hashtable)tweens[i];
			if ((string)hashtable["id"] == id)
			{
				tweens.RemoveAt(i);
				break;
			}
		}
		UnityEngine.Object.Destroy(this);
	}

	private void ConflictCheck()
	{
		Component[] components = GetComponents(typeof(iTween));
		Component[] array = components;
		for (int i = 0; i < array.Length; i++)
		{
			iTween iTween2 = (iTween)array[i];
			if (iTween2.type == "value")
			{
				break;
			}
			if (!iTween2.isRunning || !(iTween2.type == type))
			{
				continue;
			}
			if (iTween2.method != method)
			{
				break;
			}
			if (iTween2.tweenArguments.Count != tweenArguments.Count)
			{
				iTween2.Dispose();
				break;
			}
			foreach (DictionaryEntry tweenArgument in tweenArguments)
			{
				if (!iTween2.tweenArguments.Contains(tweenArgument.Key))
				{
					iTween2.Dispose();
					return;
				}
				if (!iTween2.tweenArguments[tweenArgument.Key].Equals(tweenArguments[tweenArgument.Key]) && (string)tweenArgument.Key != "id")
				{
					iTween2.Dispose();
					return;
				}
			}
			Dispose();
		}
	}

	private void EnableKinematic()
	{
	}

	private void DisableKinematic()
	{
	}

	private void ResumeDelay()
	{
		StartCoroutine("TweenDelay");
	}

	private float linear(float start, float end, float value)
	{
		return Mathf.Lerp(start, end, value);
	}

	private float clerp(float start, float end, float value)
	{
		float num = 0f;
		float num2 = 360f;
		float num3 = Mathf.Abs((num2 - num) / 2f);
		float num4 = 0f;
		float num5 = 0f;
		if (end - start < 0f - num3)
		{
			num5 = (num2 - start + end) * value;
			return start + num5;
		}
		if (end - start > num3)
		{
			num5 = (0f - (num2 - end + start)) * value;
			return start + num5;
		}
		return start + (end - start) * value;
	}

	private float spring(float start, float end, float value)
	{
		value = Mathf.Clamp01(value);
		value = (Mathf.Sin(value * (float)Math.PI * (0.2f + 2.5f * value * value * value)) * Mathf.Pow(1f - value, 2.2f) + value) * (1f + 1.2f * (1f - value));
		return start + (end - start) * value;
	}

	private float easeInQuad(float start, float end, float value)
	{
		end -= start;
		return end * value * value + start;
	}

	private float easeOutQuad(float start, float end, float value)
	{
		end -= start;
		return (0f - end) * value * (value - 2f) + start;
	}

	private float easeInOutQuad(float start, float end, float value)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return end / 2f * value * value + start;
		}
		value -= 1f;
		return (0f - end) / 2f * (value * (value - 2f) - 1f) + start;
	}

	private float easeInCubic(float start, float end, float value)
	{
		end -= start;
		return end * value * value * value + start;
	}

	private float easeOutCubic(float start, float end, float value)
	{
		value -= 1f;
		end -= start;
		return end * (value * value * value + 1f) + start;
	}

	private float easeInOutCubic(float start, float end, float value)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return end / 2f * value * value * value + start;
		}
		value -= 2f;
		return end / 2f * (value * value * value + 2f) + start;
	}

	private float easeInQuart(float start, float end, float value)
	{
		end -= start;
		return end * value * value * value * value + start;
	}

	private float easeOutQuart(float start, float end, float value)
	{
		value -= 1f;
		end -= start;
		return (0f - end) * (value * value * value * value - 1f) + start;
	}

	private float easeInOutQuart(float start, float end, float value)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return end / 2f * value * value * value * value + start;
		}
		value -= 2f;
		return (0f - end) / 2f * (value * value * value * value - 2f) + start;
	}

	private float easeInQuint(float start, float end, float value)
	{
		end -= start;
		return end * value * value * value * value * value + start;
	}

	private float easeOutQuint(float start, float end, float value)
	{
		value -= 1f;
		end -= start;
		return end * (value * value * value * value * value + 1f) + start;
	}

	private float easeInOutQuint(float start, float end, float value)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return end / 2f * value * value * value * value * value + start;
		}
		value -= 2f;
		return end / 2f * (value * value * value * value * value + 2f) + start;
	}

	private float easeInSine(float start, float end, float value)
	{
		end -= start;
		return (0f - end) * Mathf.Cos(value / 1f * ((float)Math.PI / 2f)) + end + start;
	}

	private float easeOutSine(float start, float end, float value)
	{
		end -= start;
		return end * Mathf.Sin(value / 1f * ((float)Math.PI / 2f)) + start;
	}

	private float easeInOutSine(float start, float end, float value)
	{
		end -= start;
		return (0f - end) / 2f * (Mathf.Cos((float)Math.PI * value / 1f) - 1f) + start;
	}

	private float easeInExpo(float start, float end, float value)
	{
		end -= start;
		return end * Mathf.Pow(2f, 10f * (value / 1f - 1f)) + start;
	}

	private float easeOutExpo(float start, float end, float value)
	{
		end -= start;
		return end * (0f - Mathf.Pow(2f, -10f * value / 1f) + 1f) + start;
	}

	private float easeInOutExpo(float start, float end, float value)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return end / 2f * Mathf.Pow(2f, 10f * (value - 1f)) + start;
		}
		value -= 1f;
		return end / 2f * (0f - Mathf.Pow(2f, -10f * value) + 2f) + start;
	}

	private float easeInCirc(float start, float end, float value)
	{
		end -= start;
		return (0f - end) * (Mathf.Sqrt(1f - value * value) - 1f) + start;
	}

	private float easeOutCirc(float start, float end, float value)
	{
		value -= 1f;
		end -= start;
		return end * Mathf.Sqrt(1f - value * value) + start;
	}

	private float easeInOutCirc(float start, float end, float value)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return (0f - end) / 2f * (Mathf.Sqrt(1f - value * value) - 1f) + start;
		}
		value -= 2f;
		return end / 2f * (Mathf.Sqrt(1f - value * value) + 1f) + start;
	}

	private float easeInBounce(float start, float end, float value)
	{
		end -= start;
		float num = 1f;
		return end - easeOutBounce(0f, end, num - value) + start;
	}

	private float easeOutBounce(float start, float end, float value)
	{
		value /= 1f;
		end -= start;
		if (value < 0.36363637f)
		{
			return end * (7.5625f * value * value) + start;
		}
		if (value < 0.72727275f)
		{
			value -= 0.54545456f;
			return end * (7.5625f * value * value + 0.75f) + start;
		}
		if ((double)value < 0.9090909090909091)
		{
			value -= 0.8181818f;
			return end * (7.5625f * value * value + 0.9375f) + start;
		}
		value -= 21f / 22f;
		return end * (7.5625f * value * value + 63f / 64f) + start;
	}

	private float easeInOutBounce(float start, float end, float value)
	{
		end -= start;
		float num = 1f;
		if (value < num / 2f)
		{
			return easeInBounce(0f, end, value * 2f) * 0.5f + start;
		}
		return easeOutBounce(0f, end, value * 2f - num) * 0.5f + end * 0.5f + start;
	}

	private float easeInBack(float start, float end, float value)
	{
		end -= start;
		value /= 1f;
		float num = 1.70158f;
		return end * value * value * ((num + 1f) * value - num) + start;
	}

	private float easeOutBack(float start, float end, float value)
	{
		float num = 1.70158f;
		end -= start;
		value = value / 1f - 1f;
		return end * (value * value * ((num + 1f) * value + num) + 1f) + start;
	}

	private float easeInOutBack(float start, float end, float value)
	{
		float num = 1.70158f;
		end -= start;
		value /= 0.5f;
		if (value < 1f)
		{
			num *= 1.525f;
			return end / 2f * (value * value * ((num + 1f) * value - num)) + start;
		}
		value -= 2f;
		num *= 1.525f;
		return end / 2f * (value * value * ((num + 1f) * value + num) + 2f) + start;
	}

	private float punch(float amplitude, float value)
	{
		float num = 9f;
		if (value == 0f)
		{
			return 0f;
		}
		if (value == 1f)
		{
			return 0f;
		}
		float num2 = 0.3f;
		num = num2 / ((float)Math.PI * 2f) * Mathf.Asin(0f);
		return amplitude * Mathf.Pow(2f, -10f * value) * Mathf.Sin((value * 1f - num) * ((float)Math.PI * 2f) / num2);
	}

	private float easeInElastic(float start, float end, float value)
	{
		end -= start;
		float num = 1f;
		float num2 = num * 0.3f;
		float num3 = 0f;
		float num4 = 0f;
		if (value == 0f)
		{
			return start;
		}
		if ((value /= num) == 1f)
		{
			return start + end;
		}
		if (num4 == 0f || num4 < Mathf.Abs(end))
		{
			num4 = end;
			num3 = num2 / 4f;
		}
		else
		{
			num3 = num2 / ((float)Math.PI * 2f) * Mathf.Asin(end / num4);
		}
		return 0f - num4 * Mathf.Pow(2f, 10f * (value -= 1f)) * Mathf.Sin((value * num - num3) * ((float)Math.PI * 2f) / num2) + start;
	}

	private float easeOutElastic(float start, float end, float value)
	{
		end -= start;
		float num = 1f;
		float num2 = num * 0.3f;
		float num3 = 0f;
		float num4 = 0f;
		if (value == 0f)
		{
			return start;
		}
		if ((value /= num) == 1f)
		{
			return start + end;
		}
		if (num4 == 0f || num4 < Mathf.Abs(end))
		{
			num4 = end;
			num3 = num2 / 4f;
		}
		else
		{
			num3 = num2 / ((float)Math.PI * 2f) * Mathf.Asin(end / num4);
		}
		return num4 * Mathf.Pow(2f, -10f * value) * Mathf.Sin((value * num - num3) * ((float)Math.PI * 2f) / num2) + end + start;
	}

	private float easeInOutElastic(float start, float end, float value)
	{
		end -= start;
		float num = 1f;
		float num2 = num * 0.3f;
		float num3 = 0f;
		float num4 = 0f;
		if (value == 0f)
		{
			return start;
		}
		if ((value /= num / 2f) == 2f)
		{
			return start + end;
		}
		if (num4 == 0f || num4 < Mathf.Abs(end))
		{
			num4 = end;
			num3 = num2 / 4f;
		}
		else
		{
			num3 = num2 / ((float)Math.PI * 2f) * Mathf.Asin(end / num4);
		}
		if (value < 1f)
		{
			return -0.5f * (num4 * Mathf.Pow(2f, 10f * (value -= 1f)) * Mathf.Sin((value * num - num3) * ((float)Math.PI * 2f) / num2)) + start;
		}
		return num4 * Mathf.Pow(2f, -10f * (value -= 1f)) * Mathf.Sin((value * num - num3) * ((float)Math.PI * 2f) / num2) * 0.5f + end + start;
	}
}
public static class iT
{
	public static class CameraFadeFrom
	{
		public const string amount = "amount";

		public const string time = "time";

		public const string delay = "delay";

		public const string easetype = "easetype";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class CameraFadeTo
	{
		public const string amount = "amount";

		public const string time = "time";

		public const string delay = "delay";

		public const string easetype = "easetype";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class ValueTo
	{
		public const string from = "from";

		public const string to = "to";

		public const string time = "time";

		public const string speed = "speed";

		public const string delay = "delay";

		public const string easetype = "easetype";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class FadeFrom
	{
		public const string alpha = "alpha";

		public const string amount = "amount";

		public const string includechildren = "includechildren";

		public const string time = "time";

		public const string delay = "delay";

		public const string easetype = "easetype";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class FadeTo
	{
		public const string alpha = "alpha";

		public const string amount = "amount";

		public const string includechildren = "includechildren";

		public const string time = "time";

		public const string delay = "delay";

		public const string easetype = "easetype";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class ColorFrom
	{
		public const string color = "color";

		public const string r = "r";

		public const string g = "g";

		public const string b = "b";

		public const string a = "a";

		public const string namedcolorvalue = "namedcolorvalue";

		public const string includechildren = "includechildren";

		public const string time = "time";

		public const string delay = "delay";

		public const string easetype = "easetype";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class ColorTo
	{
		public const string color = "color";

		public const string r = "r";

		public const string g = "g";

		public const string b = "b";

		public const string a = "a";

		public const string namedcolorvalue = "namedcolorvalue";

		public const string includechildren = "includechildren";

		public const string time = "time";

		public const string delay = "delay";

		public const string easetype = "easetype";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class AudioFrom
	{
		public const string audiosource = "audiosource";

		public const string volume = "volume";

		public const string pitch = "pitch";

		public const string time = "time";

		public const string delay = "delay";

		public const string easetype = "easetype";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class AudioTo
	{
		public const string audiosource = "audiosource";

		public const string volume = "volume";

		public const string pitch = "pitch";

		public const string time = "time";

		public const string delay = "delay";

		public const string easetype = "easetype";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class Stab
	{
		public const string audioclip = "audioclip";

		public const string audiosource = "audiosource";

		public const string volume = "volume";

		public const string pitch = "pitch";

		public const string delay = "delay";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class LookFrom
	{
		public const string looktarget = "looktarget";

		public const string axis = "axis";

		public const string time = "time";

		public const string speed = "speed";

		public const string delay = "delay";

		public const string easetype = "easetype";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class LookTo
	{
		public const string looktarget = "looktarget";

		public const string axis = "axis";

		public const string time = "time";

		public const string speed = "speed";

		public const string delay = "delay";

		public const string easetype = "easetype";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class MoveTo
	{
		public const string position = "position";

		public const string path = "path";

		public const string movetopath = "movetopath";

		public const string x = "x";

		public const string y = "y";

		public const string z = "z";

		public const string orienttopath = "orienttopath";

		public const string looktarget = "looktarget";

		public const string looktime = "looktime";

		public const string lookahead = "lookahead";

		public const string axis = "axis";

		public const string islocal = "islocal";

		public const string time = "time";

		public const string speed = "speed";

		public const string delay = "delay";

		public const string easetype = "easetype";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class MoveFrom
	{
		public const string position = "position";

		public const string path = "path";

		public const string movetopath = "movetopath";

		public const string x = "x";

		public const string y = "y";

		public const string z = "z";

		public const string orienttopath = "orienttopath";

		public const string looktarget = "looktarget";

		public const string looktime = "looktime";

		public const string lookahead = "lookahead";

		public const string islocal = "islocal";

		public const string time = "time";

		public const string speed = "speed";

		public const string delay = "delay";

		public const string easetype = "easetype";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class MoveAdd
	{
		public const string amount = "amount";

		public const string x = "x";

		public const string y = "y";

		public const string z = "z";

		public const string orienttopath = "orienttopath";

		public const string looktarget = "looktarget";

		public const string looktime = "looktime";

		public const string axis = "axis";

		public const string space = "space";

		public const string time = "time";

		public const string speed = "speed";

		public const string delay = "delay";

		public const string easetype = "easetype";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class MoveBy
	{
		public const string amount = "amount";

		public const string x = "x";

		public const string y = "y";

		public const string z = "z";

		public const string orienttopath = "orienttopath";

		public const string looktarget = "looktarget";

		public const string looktime = "looktime";

		public const string axis = "axis";

		public const string space = "space";

		public const string time = "time";

		public const string speed = "speed";

		public const string delay = "delay";

		public const string easetype = "easetype";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class ScaleTo
	{
		public const string scale = "scale";

		public const string x = "x";

		public const string y = "y";

		public const string z = "z";

		public const string time = "time";

		public const string speed = "speed";

		public const string delay = "delay";

		public const string easetype = "easetype";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class ScaleFrom
	{
		public const string scale = "scale";

		public const string x = "x";

		public const string y = "y";

		public const string z = "z";

		public const string time = "time";

		public const string speed = "speed";

		public const string delay = "delay";

		public const string easetype = "easetype";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class ScaleAdd
	{
		public const string amount = "amount";

		public const string x = "x";

		public const string y = "y";

		public const string z = "z";

		public const string time = "time";

		public const string speed = "speed";

		public const string delay = "delay";

		public const string easetype = "easetype";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class ScaleBy
	{
		public const string amount = "amount";

		public const string x = "x";

		public const string y = "y";

		public const string z = "z";

		public const string time = "time";

		public const string speed = "speed";

		public const string delay = "delay";

		public const string easetype = "easetype";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class RotateTo
	{
		public const string rotation = "rotation";

		public const string x = "x";

		public const string y = "y";

		public const string z = "z";

		public const string islocal = "islocal";

		public const string time = "time";

		public const string speed = "speed";

		public const string delay = "delay";

		public const string easetype = "easetype";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class RotateFrom
	{
		public const string rotation = "rotation";

		public const string x = "x";

		public const string y = "y";

		public const string z = "z";

		public const string islocal = "islocal";

		public const string time = "time";

		public const string speed = "speed";

		public const string delay = "delay";

		public const string easetype = "easetype";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class RotateAdd
	{
		public const string amount = "amount";

		public const string x = "x";

		public const string y = "y";

		public const string z = "z";

		public const string space = "space";

		public const string time = "time";

		public const string speed = "speed";

		public const string delay = "delay";

		public const string easetype = "easetype";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class RotateBy
	{
		public const string amount = "amount";

		public const string x = "x";

		public const string y = "y";

		public const string z = "z";

		public const string space = "space";

		public const string islocal = "islocal";

		public const string time = "time";

		public const string speed = "speed";

		public const string delay = "delay";

		public const string easetype = "easetype";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class ShakePosition
	{
		public const string amount = "amount";

		public const string x = "x";

		public const string y = "y";

		public const string z = "z";

		public const string space = "space";

		public const string orienttopath = "orienttopath";

		public const string looktarget = "looktarget";

		public const string looktime = "looktime";

		public const string time = "time";

		public const string delay = "delay";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class ShakeScale
	{
		public const string amount = "amount";

		public const string x = "x";

		public const string y = "y";

		public const string z = "z";

		public const string time = "time";

		public const string delay = "delay";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class ShakeRotation
	{
		public const string amount = "amount";

		public const string x = "x";

		public const string y = "y";

		public const string z = "z";

		public const string space = "space";

		public const string time = "time";

		public const string delay = "delay";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class PunchPosition
	{
		public const string amount = "amount";

		public const string x = "x";

		public const string y = "y";

		public const string z = "z";

		public const string space = "space";

		public const string looktarget = "looktarget";

		public const string looktime = "looktime";

		public const string time = "time";

		public const string delay = "delay";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class PunchRotation
	{
		public const string amount = "amount";

		public const string x = "x";

		public const string y = "y";

		public const string z = "z";

		public const string space = "space";

		public const string time = "time";

		public const string delay = "delay";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class PunchScale
	{
		public const string amount = "amount";

		public const string x = "x";

		public const string y = "y";

		public const string z = "z";

		public const string time = "time";

		public const string delay = "delay";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class FadeUpdate
	{
		public const string alpha = "alpha";

		public const string includechildren = "includechildren";

		public const string time = "time";
	}

	public static class ColorUpdate
	{
		public const string color = "color";

		public const string r = "r";

		public const string g = "g";

		public const string b = "b";

		public const string a = "a";

		public const string namedcolorvalue = "namedcolorvalue";

		public const string includechildren = "includechildren";

		public const string time = "time";
	}

	public static class AudioUpdate
	{
		public const string audiosource = "audiosource";

		public const string volume = "volume";

		public const string pitch = "pitch";

		public const string time = "time";
	}

	public static class RotateUpdate
	{
		public const string rotation = "rotation";

		public const string x = "x";

		public const string y = "y";

		public const string z = "z";

		public const string islocal = "islocal";

		public const string time = "time";
	}

	public static class ScaleUpdate
	{
		public const string scale = "scale";

		public const string x = "x";

		public const string y = "y";

		public const string z = "z";

		public const string time = "time";
	}

	public static class MoveUpdate
	{
		public const string position = "position";

		public const string x = "x";

		public const string y = "y";

		public const string z = "z";

		public const string time = "time";

		public const string islocal = "islocal";

		public const string orienttopath = "orienttopath";

		public const string looktarget = "looktarget";

		public const string looktime = "looktime";

		public const string axis = "axis";
	}

	public static class LookUpdate
	{
		public const string looktarget = "looktarget";

		public const string axis = "axis";

		public const string time = "time";
	}
}
public class MoveSample : MonoBehaviour
{
	private void Start()
	{
		iTween.MoveBy(base.gameObject, iTween.Hash("x", 2, "easeType", "easeInOutExpo", "loopType", "pingPong", "delay", 0.1));
	}
}
public class RotateSample : MonoBehaviour
{
	private void Start()
	{
		iTween.RotateBy(base.gameObject, iTween.Hash("x", 0.25, "easeType", "easeInOutBack", "loopType", "pingPong", "delay", 0.4));
	}
}
public class SampleInfo : MonoBehaviour
{
	private void OnGUI()
	{
		GUILayout.Label("iTween can spin, shake, punch, move, handle audio, fade color and transparency \nand much more with each task needing only one line of code.");
		GUILayout.BeginHorizontal();
		GUILayout.Label("iTween works with C#, JavaScript and Boo. For full documentation and examples visit:");
		if (GUILayout.Button("http://itween.pixelplacement.com"))
		{
			Application.OpenURL("http://itween.pixelplacement.com");
		}
		GUILayout.EndHorizontal();
	}
}
[ExecuteInEditMode]
public class EffectScaler : MonoBehaviour
{
}
public class EffectLightsFade : MonoBehaviour
{
	public float totalTime;

	public float fadeInTime;

	public float fadeOutTime;

	private Light dynamicLight;

	private void Awake()
	{
		dynamicLight = GetComponent<Light>();
		if (!(dynamicLight != null))
		{
			return;
		}
		float intensity = dynamicLight.intensity;
		Animation component = GetComponent<Animation>();
		if (!(component == null))
		{
			return;
		}
		base.gameObject.AddComponent<Animation>();
		if (fadeInTime < 0f)
		{
			fadeInTime = 0f;
		}
		if (fadeInTime > totalTime)
		{
			fadeInTime = totalTime;
		}
		if (fadeOutTime < 0f)
		{
			fadeOutTime = 0f;
		}
		if (fadeOutTime > totalTime)
		{
			fadeOutTime = totalTime;
		}
		if (fadeInTime + fadeOutTime > totalTime)
		{
			fadeInTime = 0f;
		}
		List<Keyframe> list = new List<Keyframe>();
		if (fadeInTime != 0f)
		{
			AnimationCurve animationCurve = AnimationCurve.Linear(0f, 0f, fadeInTime, intensity);
			list.Add(animationCurve[0]);
			list.Add(animationCurve[1]);
		}
		if (fadeOutTime != 0f)
		{
			AnimationCurve animationCurve2 = AnimationCurve.Linear(totalTime - fadeOutTime, intensity, totalTime, 0f);
			if (fadeInTime == 0f || fadeInTime != totalTime - fadeOutTime)
			{
				list.Add(animationCurve2[0]);
			}
			else
			{
				Keyframe value = list[1];
				value.outTangent = animationCurve2[0].outTangent;
				list[1] = value;
			}
			list.Add(animationCurve2[1]);
		}
		AnimationCurve curve = new AnimationCurve(list.ToArray());
		AnimationClip animationClip = new AnimationClip();
		animationClip.SetCurve(string.Empty, typeof(Light), "m_Intensity", curve);
		GetComponent<Animation>().clip = animationClip;
		GetComponent<Animation>().clip.name = "light_fade";
		base.gameObject.SetActive(value: false);
		base.gameObject.SetActive(value: true);
	}

	private void Update()
	{
		Animation component = GetComponent<Animation>();
		if ((bool)component && !component.isPlaying && (bool)dynamicLight)
		{
			dynamicLight.enabled = false;
		}
	}

	private void OnEnable()
	{
		if ((bool)dynamicLight)
		{
			dynamicLight.enabled = true;
		}
	}

	private void Reset()
	{
		totalTime = 1f;
		fadeInTime = 0f;
		fadeOutTime = 1f;
	}
}
public class EffectNWayMotion : MonoBehaviour
{
	public int DirectionWay = 8;

	public Transform WayChild;

	public bool UseSpreadDirection;

	public int SpreadAngle = 120;

	public float StopEffectsTime;

	private GameObject effectRoot;

	private void CreateWayMotion()
	{
		if (WayChild == null)
		{
			Debug.Log("WayChild is Null!");
			return;
		}
		if (StopEffectsTime > 0f)
		{
			StopCoroutine("StopEffects");
			StartCoroutine(StopEffects(StopEffectsTime));
		}
		if (effectRoot == null)
		{
			effectRoot = new GameObject();
			effectRoot.name = "effectRoot(clone)";
			effectRoot.transform.parent = base.transform;
		}
		float num = 0f;
		if (!UseSpreadDirection)
		{
			WayChild.gameObject.SetActive(value: true);
			num = 360 / DirectionWay;
			for (int i = 1; i < DirectionWay; i++)
			{
				Quaternion rotation = Quaternion.Euler(new Vector3(0f, base.transform.localEulerAngles.y + num * (float)i, 0f));
				Transform transform = UnityEngine.Object.Instantiate(WayChild, base.transform.position, rotation);
				transform.parent = effectRoot.transform;
			}
			return;
		}
		WayChild.gameObject.SetActive(value: false);
		num = SpreadAngle / DirectionWay;
		for (int j = 0; j < DirectionWay; j++)
		{
			float num2 = 0f;
			if (DirectionWay % 2 == 0)
			{
				num2 = num / 2f;
			}
			Quaternion rotation2 = Quaternion.Euler(new Vector3(0f, base.transform.localEulerAngles.y + num2 + num * (float)(-DirectionWay / 2 + j), 0f));
			Transform transform2 = UnityEngine.Object.Instantiate(WayChild, base.transform.position, rotation2);
			transform2.parent = effectRoot.transform;
			transform2.gameObject.SetActive(value: true);
		}
	}

	private void OnEnable()
	{
		CreateWayMotion();
	}

	private void OnDisable()
	{
		if (effectRoot != null)
		{
			UnityEngine.Object.Destroy(effectRoot);
		}
	}

	private IEnumerator StopEffects(float waitTime)
	{
		yield return new WaitForSeconds(waitTime);
		WayChild.gameObject.SetActive(value: false);
		effectRoot.gameObject.SetActive(value: false);
		OnDisable();
	}
}
public class EffectPlay : MonoBehaviour
{
	public Transform surround_point;

	public Transform ground;

	public Transform[] effects = new Transform[1];

	private int effectIndex;

	private int goIndex;

	private int fpsNumber;

	private float repeatTime = 4f;

	private float timer;

	private float fpsTimer;

	private Transform effect;

	private float fps;

	private float fpsTotal;

	private bool isRepeat = true;

	private string effectName;

	private void Start()
	{
		InitEffect();
	}

	private void OnGUI()
	{
		GUILayout.Label("Effect Name : " + effectName.Replace("(Clone)", string.Empty));
		GUILayout.Label("Effect Index : " + effectIndex);
		GUILayout.Label("Total Effects : " + effects.Length);
		GUILayout.BeginHorizontal();
		if (GUILayout.Button("Go Effect Index", GUILayout.Width(120f)))
		{
			if (goIndex == effectIndex || goIndex < 0 || goIndex >= effects.Length)
			{
				return;
			}
			if (effect != null)
			{
				UnityEngine.Object.Destroy(effect.gameObject);
			}
			effectIndex = goIndex;
			InitEffect();
		}
		GUILayout.Label(" ==> ", GUILayout.Width(30f));
		goIndex = int.Parse(GUILayout.TextField(goIndex.ToString(), GUILayout.MaxWidth(50f)));
		GUILayout.EndHorizontal();
		GUILayout.BeginHorizontal();
		GUILayout.Label("Repeat Time : ", GUILayout.MaxWidth(85f));
		repeatTime = float.Parse(GUILayout.TextField(repeatTime.ToString(), GUILayout.MaxWidth(50f)));
		GUILayout.EndHorizontal();
		if (GUILayout.Button("Show/Hide Ground", GUILayout.Width(120f)) && ground != null)
		{
			ground.gameObject.SetActive(!ground.gameObject.activeSelf);
		}
		GUILayout.Space(6f);
		if (GUILayout.Button("Previous Effect", GUILayout.Width(120f)))
		{
			if (effect != null)
			{
				UnityEngine.Object.Destroy(effect.gameObject);
			}
			effectIndex--;
			if (effectIndex < 0)
			{
				effectIndex = effects.Length - 1;
			}
			InitEffect();
		}
		else if (GUILayout.Button("Next Effect", GUILayout.Width(120f)))
		{
			if (effect != null)
			{
				UnityEngine.Object.Destroy(effect.gameObject);
			}
			effectIndex++;
			if (effectIndex >= effects.Length)
			{
				effectIndex = 0;
			}
			InitEffect();
		}
		GUILayout.Space(6f);
		GUILayout.Label("fps = " + fps);
	}

	private void Update()
	{
		if (timer >= repeatTime && isRepeat)
		{
			if (effect != null)
			{
				effect.gameObject.SetActive(value: false);
				StartCoroutine(DelayActive(effect.gameObject));
			}
			timer = 0f;
		}
		else
		{
			timer += Time.deltaTime;
		}
		if (Time.time > fpsTimer)
		{
			fps = fpsTotal / (float)fpsNumber;
			fpsTimer = Time.time + 0.5f;
		}
		else
		{
			fpsTotal += 1f / Time.deltaTime;
			fpsNumber++;
		}
	}

	private void InitEffect()
	{
		effect = null;
		effect = effects[effectIndex];
		if (effect != null)
		{
			effect = UnityEngine.Object.Instantiate(effect);
			effect.gameObject.SetActive(value: true);
		}
		if (effectIndex >= 8 && effectIndex <= 28)
		{
			if (surround_point != null)
			{
				effect.parent = surround_point;
				if (effectIndex >= 8 && effectIndex <= 12)
				{
					effect.localPosition = new Vector3(0f, effect.localPosition.y, 0f);
				}
				else
				{
					effect.localPosition = Vector3.zero;
				}
				isRepeat = false;
			}
		}
		else if ((effectIndex >= 22 && effectIndex <= 24) || effectIndex >= 47)
		{
			isRepeat = false;
		}
		else
		{
			isRepeat = true;
		}
		if (effectIndex >= 38 && effectIndex <= 42)
		{
			effect.localEulerAngles = new Vector3(0f, -45f, 0f);
		}
		timer = 0f;
		effectName = effect.name;
	}

	private IEnumerator DelayActive(GameObject effect)
	{
		yield return new WaitForSeconds(0.1f);
		if (effect != null)
		{
			effect.SetActive(value: true);
		}
	}
}
[RequireComponent(typeof(LineRenderer))]
public class LineRenderContrl : MonoBehaviour
{
	public Transform Target;

	public Vector3 TargetOffset;

	public float TexMoverTotalTime = 1f;

	public float TexSheetTotalTime = 1f;

	public int TexSheetCount = 1;

	public int TexTilingVector = -1;

	public bool TexSheetRandom;

	public bool TexAutoDistanceDiv;

	public float TexDistanceDivValue = 4f;

	private LineRenderer lineRer;

	private GameObject lineRerTarget;

	private Material mat;

	private Vector2 texOffset;

	private float[] sheetCoordinates;

	private float timerMover;

	private float timerSheet;

	private int sheetIndex;

	private int texMoverVector = 1;

	private int texAutoDistDiv = 1;

	private void Awake()
	{
		lineRer = GetComponent<LineRenderer>();
		lineRer.SetVertexCount(2);
		lineRer.SetPosition(0, Vector3.zero);
		lineRer.useWorldSpace = false;
		mat = lineRer.materials[0];
		if ((bool)mat)
		{
			sheetCoordinates = new float[TexSheetCount];
			for (int i = 0; i < sheetCoordinates.Length; i++)
			{
				sheetCoordinates[i] = ((float)i + 1f) / (float)TexSheetCount;
			}
			mat.SetTextureScale("_MainTex", new Vector2(TexTilingVector, 1f / (float)TexSheetCount));
			lineRerTarget = new GameObject("lineRerTarget");
			lineRerTarget.transform.parent = base.transform;
		}
	}

	private void Update()
	{
		LineRenderer lineRenderer = lineRer;
		if ((bool)Target)
		{
			Transform transform = lineRerTarget.transform;
			transform.position = Target.position;
			lineRenderer.SetPosition(1, transform.localPosition + TargetOffset);
			if (TexAutoDistanceDiv)
			{
				float num = Vector3.Distance(transform.position, base.transform.position);
				if (num > TexDistanceDivValue)
				{
					texAutoDistDiv = (int)(num / TexDistanceDivValue);
				}
				else
				{
					texAutoDistDiv = 1;
				}
			}
		}
		Material material = mat;
		if (!material)
		{
			return;
		}
		if (timerMover >= TexMoverTotalTime)
		{
			timerMover = 0f;
			texOffset.x = 0f;
		}
		else
		{
			texOffset.x += (float)texMoverVector * Time.deltaTime / TexMoverTotalTime;
		}
		if (timerSheet >= TexSheetTotalTime / (float)TexSheetCount)
		{
			timerSheet = 0f;
			if (!TexSheetRandom)
			{
				if (sheetIndex == sheetCoordinates.Length)
				{
					sheetIndex = 0;
				}
				texOffset.y = sheetCoordinates[sheetIndex];
				sheetIndex++;
			}
			else
			{
				texOffset.y = sheetCoordinates[UnityEngine.Random.Range(0, sheetCoordinates.Length)];
			}
			material.SetTextureScale("_MainTex", new Vector2(TexTilingVector * texAutoDistDiv, 1f / (float)TexSheetCount));
		}
		else
		{
			timerSheet += Time.deltaTime;
		}
		material.SetTextureOffset("_MainTex", texOffset);
	}
}
public class SplineComponent : MonoBehaviour
{
	[Serializable]
	public class SplineComponentSegment
	{
		public Vector3 m_startpos;

		public Vector3 m_endpos;

		public float m_startlen;

		public float m_endlen;

		public SplineComponentSegment[] m_subsegments;
	}

	[Serializable]
	public class SplineComponentPoint
	{
		public Vector3 m_point;

		public Vector3 m_control1;

		public Vector3 m_control2;

		public BaseSpline.SplinePointType m_type;

		public SplineComponentPoint(Vector3 p, Vector3 c1, Vector3 c2, BaseSpline.SplinePointType t)
		{
			m_point = p;
			m_control1 = c1;
			m_control2 = c2;
			m_type = t;
		}
	}

	public List<SplineComponentPoint> m_points = new List<SplineComponentPoint>();

	[SerializeField]
	private int m_numsteps = 4;

	[SerializeField]
	private BaseSpline.SplineWrapMode m_wrapmode;

	[SerializeField]
	private float m_length;

	[SerializeField]
	private SplineComponentSegment[] m_segments;

	public int InterpolationSteps
	{
		get
		{
			return m_numsteps;
		}
		set
		{
			if (m_numsteps <= 0)
			{
				throw new ArgumentOutOfRangeException();
			}
			m_numsteps = value;
		}
	}

	public SplineComponentSegment[] Segments => m_segments;

	public float Length => m_length;

	public BaseSpline.SplineWrapMode WrapMode
	{
		get
		{
			return m_wrapmode;
		}
		set
		{
			m_wrapmode = value;
		}
	}

	public void AppendPoint(Vector3 pos, BaseSpline.SplinePointType type, Vector3 cp1, Vector3 cp2)
	{
		m_points.Add(new SplineComponentPoint(pos, cp1, cp2, type));
	}

	public void RemoveLastPoint()
	{
		m_points.RemoveAt(m_points.Count - 1);
	}

	public void RemoveAllPoints()
	{
		m_points.Clear();
	}

	public void ReversePoints()
	{
		m_points.Reverse();
		for (int i = 0; i < m_points.Count; i++)
		{
			Vector3 control = m_points[i].m_control1;
			m_points[i].m_control1 = m_points[i].m_control2;
			m_points[i].m_control2 = control;
		}
	}

	public void InsertPoint(int idx, Vector3 pos, BaseSpline.SplinePointType type, Vector3 cp1, Vector3 cp2)
	{
		if (idx < 0 || idx > m_points.Count)
		{
			throw new IndexOutOfRangeException();
		}
		m_points.Insert(idx, new SplineComponentPoint(pos, cp1, cp2, type));
	}

	public void Build()
	{
		SplineComponentPoint splineComponentPoint = null;
		SplineComponentPoint splineComponentPoint2 = null;
		SplineComponentPoint splineComponentPoint3 = null;
		if (m_points.Count < 2)
		{
			m_segments = null;
			m_length = 0f;
			return;
		}
		int num = ((m_wrapmode != BaseSpline.SplineWrapMode.Loop) ? (m_points.Count - 1) : m_points.Count);
		int i;
		for (i = 0; i < m_points.Count; i++)
		{
			splineComponentPoint = m_points[i];
			switch (splineComponentPoint.m_type)
			{
			case BaseSpline.SplinePointType.Corner:
				splineComponentPoint.m_control1 = Vector3.zero;
				splineComponentPoint.m_control2 = Vector3.zero;
				break;
			case BaseSpline.SplinePointType.Bezier:
				splineComponentPoint.m_control2 = -splineComponentPoint.m_control1;
				break;
			case BaseSpline.SplinePointType.Smooth:
				if (m_wrapmode == BaseSpline.SplineWrapMode.Loop)
				{
					int index;
					int index2;
					if (i == 0)
					{
						index = i + 1;
						index2 = m_points.Count - 1;
					}
					else if (i == m_points.Count - 1)
					{
						index = 0;
						index2 = i - 1;
					}
					else
					{
						index = i + 1;
						index2 = i - 1;
					}
					splineComponentPoint2 = m_points[index];
					splineComponentPoint3 = m_points[index2];
					splineComponentPoint.m_control2 = -(splineComponentPoint3.m_point - splineComponentPoint2.m_point) * 0.25f;
					splineComponentPoint.m_control1 = -splineComponentPoint.m_control2;
				}
				else if (i == 0)
				{
					splineComponentPoint.m_control1 = Vector3.zero;
					splineComponentPoint.m_control2 = Vector3.zero;
				}
				else if (i == m_points.Count - 1)
				{
					splineComponentPoint.m_control1 = Vector3.zero;
					splineComponentPoint.m_control2 = Vector3.zero;
				}
				else
				{
					int index = i + 1;
					int index2 = i - 1;
					splineComponentPoint2 = m_points[index];
					splineComponentPoint3 = m_points[index2];
					splineComponentPoint.m_control2 = -(splineComponentPoint3.m_point - splineComponentPoint2.m_point) * 0.25f;
					splineComponentPoint.m_control1 = -splineComponentPoint.m_control2;
				}
				break;
			}
		}
		m_segments = new SplineComponentSegment[num];
		m_length = 0f;
		i = 0;
		int num2 = 0;
		for (; i < m_points.Count; i++)
		{
			splineComponentPoint2 = m_points[i];
			if (i > 0)
			{
				m_segments[num2] = new SplineComponentSegment();
				BuildSegment(m_segments[num2], splineComponentPoint, splineComponentPoint2);
				num2++;
			}
			splineComponentPoint = splineComponentPoint2;
		}
		if (m_wrapmode == BaseSpline.SplineWrapMode.Loop)
		{
			splineComponentPoint2 = m_points[0];
			m_segments[num2] = new SplineComponentSegment();
			BuildSegment(m_segments[num2], splineComponentPoint, splineComponentPoint2);
		}
	}

	private void BuildSegment(SplineComponentSegment ss, SplineComponentPoint spt1, SplineComponentPoint spt2)
	{
		ss.m_startpos = spt1.m_point;
		ss.m_endpos = spt2.m_point;
		ss.m_startlen = m_length;
		if (spt1.m_type == BaseSpline.SplinePointType.Corner && spt2.m_type == BaseSpline.SplinePointType.Corner)
		{
			ss.m_subsegments = null;
			m_length += (ss.m_endpos - ss.m_startpos).magnitude;
		}
		else
		{
			ss.m_subsegments = new SplineComponentSegment[m_numsteps];
			for (int i = 0; i < m_numsteps; i++)
			{
				SplineComponentSegment splineComponentSegment = new SplineComponentSegment();
				splineComponentSegment.m_subsegments = null;
				splineComponentSegment.m_startlen = m_length;
				splineComponentSegment.m_startpos = GetBezierPoint(spt1, spt2, i);
				splineComponentSegment.m_endpos = GetBezierPoint(spt1, spt2, i + 1);
				m_length += (splineComponentSegment.m_endpos - splineComponentSegment.m_startpos).magnitude;
				splineComponentSegment.m_endlen = m_length;
				ss.m_subsegments[i] = splineComponentSegment;
			}
		}
		ss.m_endlen = m_length;
	}

	private Vector3 GetBezierPoint(SplineComponentPoint spt1, SplineComponentPoint spt2, int segidx)
	{
		Vector3 zero = Vector3.zero;
		if (segidx == 0)
		{
			return spt1.m_point;
		}
		if (segidx == m_numsteps)
		{
			return spt2.m_point;
		}
		Vector3 vector = spt1.m_point + spt1.m_control2;
		Vector3 vector2 = spt2.m_point + spt2.m_control1;
		float num = (float)segidx / (float)m_numsteps;
		float num2 = 1f - num;
		return num2 * num2 * num2 * spt1.m_point + 3f * num2 * num2 * num * vector + 3f * num2 * num * num * vector2 + num * num * num * spt2.m_point;
	}

	private void OnDrawGizmosSelected()
	{
		DrawGizmos(Color.red, new Color(1f, 0.5f, 0.5f, 1f));
	}

	private void OnDrawGizmos()
	{
		DrawGizmos(Color.white, Color.white);
	}

	public void DrawGizmos(Color color1, Color color2)
	{
		Gizmos.matrix = base.transform.localToWorldMatrix;
		if (m_segments == null)
		{
			return;
		}
		SplineComponentSegment splineComponentSegment = null;
		SplineComponentSegment splineComponentSegment2 = null;
		for (int i = 0; i < m_segments.Length; i++)
		{
			splineComponentSegment = m_segments[i];
			if (splineComponentSegment.m_subsegments == null || splineComponentSegment.m_subsegments.Length == 0)
			{
				Gizmos.color = color1;
				Gizmos.DrawLine(splineComponentSegment.m_startpos, splineComponentSegment.m_endpos);
				continue;
			}
			for (int j = 0; j < splineComponentSegment.m_subsegments.Length; j++)
			{
				if (j % 2 == 0)
				{
					Gizmos.color = color1;
				}
				else
				{
					Gizmos.color = color2;
				}
				splineComponentSegment2 = splineComponentSegment.m_subsegments[j];
				Gizmos.DrawLine(splineComponentSegment2.m_startpos, splineComponentSegment2.m_endpos);
			}
		}
	}

	public Vector3 GetPosition(float pos)
	{
		Vector3 point = Vector3.zero;
		SplineComponentSegment splineComponentSegment = null;
		bool flag = false;
		SplineComponentSegment[] ssarr = m_segments;
		if (m_segments != null)
		{
			pos = SplineUtil.WrapPosition(m_wrapmode, pos, m_length);
			if (pos <= 0f)
			{
				point = m_segments[0].m_startpos;
			}
			else if (pos >= m_length)
			{
				point = m_segments[m_segments.Length - 1].m_endpos;
			}
			else
			{
				while (!flag)
				{
					splineComponentSegment = FindSegment(ssarr, pos);
					if (splineComponentSegment.m_subsegments == null || splineComponentSegment.m_subsegments.Length == 0)
					{
						flag = true;
					}
					else
					{
						ssarr = splineComponentSegment.m_subsegments;
					}
				}
				float num = splineComponentSegment.m_endlen - splineComponentSegment.m_startlen;
				if (num == 0f)
				{
					point = splineComponentSegment.m_endpos;
				}
				else
				{
					float num2 = (pos - splineComponentSegment.m_startlen) / num;
					point = splineComponentSegment.m_startpos + (splineComponentSegment.m_endpos - splineComponentSegment.m_startpos) * num2;
				}
			}
		}
		return base.transform.localToWorldMatrix.MultiplyPoint(point);
	}

	private SplineComponentSegment FindSegment(SplineComponentSegment[] ssarr, float pos)
	{
		SplineComponentSegment result = null;
		for (int i = 0; i < ssarr.Length; i++)
		{
			if (pos > ssarr[i].m_startlen && pos <= ssarr[i].m_endlen)
			{
				result = ssarr[i];
				break;
			}
		}
		return result;
	}
}
public class SplineTest : MonoBehaviour
{
	public SplineComponent m_spline;

	public float m_position;

	public float m_speed = 1f;

	private void Update()
	{
		m_position += m_speed * Time.deltaTime;
		base.transform.position = m_spline.GetPosition(m_position);
	}
}
public abstract class BaseSpline
{
	public enum UniSplineType
	{
		CatmullRom,
		Hermite,
		KochanekBartels
	}

	public enum SplineWrapMode
	{
		Once,
		Repeat,
		PingPong,
		Loop
	}

	public enum SplinePointType
	{
		Corner,
		Smooth,
		Bezier,
		BezierCorner
	}

	public enum SplineSegmentType
	{
		Linear,
		Curve
	}

	public enum SplineReparamType
	{
		None,
		Simple,
		RungeKutta
	}

	public class SplineIterator
	{
		private Transform m_transform;

		private BaseSpline m_spline;

		private int m_segidx;

		private int m_startidx;

		private int m_endidx;

		private bool m_reverse;

		private bool m_back;

		private bool m_onceout;

		private float m_segpos;

		internal SplineIterator(BaseSpline spline, bool reverse, int startidx, int endidx)
		{
			m_spline = spline;
			m_reverse = reverse;
			m_startidx = Mathf.Min(startidx, endidx);
			m_endidx = Mathf.Max(startidx, endidx);
			Reset();
		}

		public void SetTransform(Transform trnsfrm)
		{
			m_transform = trnsfrm;
		}

		public Vector3 GetPosition()
		{
			if (m_transform != null)
			{
				return m_transform.localToWorldMatrix.MultiplyPoint(m_spline.GetPosition(m_segidx, m_segpos));
			}
			return m_spline.GetPosition(m_segidx, m_segpos);
		}

		public Vector3 GetTangent()
		{
			if (m_transform != null)
			{
				if (m_reverse)
				{
					return m_transform.localRotation * -m_spline.GetTangent(m_segidx, m_segpos);
				}
				return m_transform.localRotation * m_spline.GetTangent(m_segidx, m_segpos);
			}
			if (m_reverse)
			{
				return -m_spline.GetTangent(m_segidx, m_segpos);
			}
			return m_spline.GetTangent(m_segidx, m_segpos);
		}

		public Vector3 GetNormal()
		{
			if (m_transform != null)
			{
				return m_transform.localRotation * m_spline.GetNormal(m_segidx, m_segpos);
			}
			return m_spline.GetNormal(m_segidx, m_segpos);
		}

		public bool IsOnceOut()
		{
			return m_onceout;
		}

		public void Reset()
		{
			if (m_reverse)
			{
				SetToEnd();
			}
			else
			{
				SetToStart();
			}
			m_back = false;
			m_onceout = false;
		}

		public void SetOffset(float offset)
		{
			offset = SplineUtil.WrapPosition(m_spline.WrapMode, offset, m_spline.Length);
			m_segidx = m_spline.FindSegment(offset);
			m_segpos = offset - m_spline.GetSegmentStartLength(m_segidx);
		}

		public float GetOffset()
		{
			return m_spline.GetSegmentStartLength(m_segidx) + m_segpos;
		}

		public void SetOffsetPercent(float offset)
		{
			offset = SplineUtil.WrapPosition(m_spline.WrapMode, offset, m_spline.Length);
			m_segidx = m_spline.FindSegment(offset * m_spline.Length);
			m_segpos = offset - m_spline.GetSegmentStartLength(m_segidx);
		}

		public float GetOffsetPercent()
		{
			if (m_reverse)
			{
				return 1f - (m_spline.GetSegmentStartLength(m_segidx) + m_segpos) / m_spline.Length;
			}
			return (m_spline.GetSegmentStartLength(m_segidx) + m_segpos) / m_spline.Length;
		}

		public void Iterate(float length)
		{
			bool flag = false;
			bool flag2 = false;
			if (m_reverse)
			{
				length = 0f - length;
			}
			if (length < 0f)
			{
				flag2 = !m_back;
				length = 0f - length;
			}
			else
			{
				flag2 = m_back;
			}
			if (flag2)
			{
				while (m_segpos - length < 0f && !flag)
				{
					length -= m_segpos;
					if (m_segidx - 1 < m_startidx)
					{
						switch (m_spline.WrapMode)
						{
						case SplineWrapMode.Loop:
							SetToEnd();
							break;
						case SplineWrapMode.Once:
							SetToStart();
							flag = true;
							m_onceout = true;
							break;
						case SplineWrapMode.Repeat:
							SetToEnd();
							break;
						case SplineWrapMode.PingPong:
							SetToStart();
							m_back = !m_back;
							flag = true;
							break;
						}
					}
					else
					{
						m_segidx--;
						m_segpos = m_spline.GetSegmentLength(m_segidx);
					}
				}
				if (!flag)
				{
					m_segpos -= length;
				}
				return;
			}
			while (m_segpos + length > m_spline.GetSegmentLength(m_segidx) && !flag)
			{
				length -= m_spline.GetSegmentLength(m_segidx) - m_segpos;
				if (m_segidx + 1 >= m_endidx)
				{
					switch (m_spline.m_wrapmode)
					{
					case SplineWrapMode.Loop:
						SetToStart();
						break;
					case SplineWrapMode.Once:
						SetToEnd();
						flag = true;
						m_onceout = true;
						break;
					case SplineWrapMode.Repeat:
						SetToStart();
						break;
					case SplineWrapMode.PingPong:
						SetToEnd();
						m_back = !m_back;
						flag = true;
						break;
					}
				}
				else
				{
					m_segidx++;
					m_segpos = 0f;
				}
			}
			if (!flag)
			{
				m_segpos += length;
			}
		}

		private void SetToStart()
		{
			m_segidx = m_startidx;
			m_segpos = 0f;
		}

		private void SetToEnd()
		{
			m_segidx = m_endidx - 1;
			m_segpos = m_spline.GetSegmentLength(m_segidx);
		}
	}

	[SerializeField]
	protected SplineWrapMode m_wrapmode;

	[SerializeField]
	protected float m_length;

	[SerializeField]
	protected int m_stepcount = 8;

	[SerializeField]
	protected SplineReparamType m_reparam;

	protected int m_buildnum;

	public int BuildNum => m_buildnum;

	public float Length => m_length;

	public SplineWrapMode WrapMode
	{
		get
		{
			return m_wrapmode;
		}
		set
		{
			m_wrapmode = value;
		}
	}

	public int StepCount
	{
		get
		{
			return m_stepcount;
		}
		set
		{
			if (value > 1)
			{
				m_stepcount = value;
			}
		}
	}

	public SplineReparamType ReparamType
	{
		get
		{
			return m_reparam;
		}
		set
		{
			m_reparam = value;
		}
	}

	public abstract void Build();

	public abstract int GetPointCount();

	public abstract int GetSegmentCount();

	protected abstract float GetSegmentLength(int segidx);

	protected abstract float GetSegmentStartLength(int segidx);

	protected abstract float GetSegmentEndLength(int segidx);

	protected abstract int FindSegment(float offset);

	protected abstract Vector3 GetDrawPosition(int segidx, float segpos);

	protected abstract Vector3 GetPosition(int segidx, float segpos);

	protected abstract Vector3 GetTangent(int segidx, float segpos);

	protected abstract Vector3 GetNormal(int segidx, float segpos);

	public SplineIterator GetIterator()
	{
		return new SplineIterator(this, reverse: false, 0, GetSegmentCount());
	}

	public SplineIterator GetReverseIterator()
	{
		return new SplineIterator(this, reverse: true, 0, GetSegmentCount());
	}

	public SplineIterator GetPartialIterator(int startidx, int endidx)
	{
		return new SplineIterator(this, reverse: false, startidx, endidx);
	}

	public SplineIterator GetPartialReverseIterator(int startidx, int endidx)
	{
		return new SplineIterator(this, reverse: true, startidx, endidx);
	}

	public Vector3[] GenerateDrawPoints(int divs)
	{
		int segmentCount = GetSegmentCount();
		int num = 0;
		Vector3[] array = new Vector3[segmentCount * divs + 1];
		float num2 = 1f / (float)divs;
		ref Vector3 reference = ref array[num];
		reference = GetDrawPosition(0, 0f);
		num++;
		for (int i = 0; i < segmentCount; i++)
		{
			for (int j = 1; j < divs + 1; j++)
			{
				ref Vector3 reference2 = ref array[num];
				reference2 = GetDrawPosition(i, (float)j * num2);
				num++;
			}
		}
		return array;
	}
}
[Serializable]
public class BezierSpline : BaseSpline
{
	public class EditHelper
	{
		private BezierSpline m_spline;

		private int m_idx = -1;

		private int m_selidx = -1;

		private int m_selcpidx = -1;

		public BezierSplinePoint Point
		{
			get
			{
				return m_spline.m_points[m_idx];
			}
			set
			{
				m_spline.m_points[m_idx] = value;
			}
		}

		public BezierSplinePoint SelectedPoint
		{
			get
			{
				return m_spline.m_points[m_selidx];
			}
			set
			{
				m_spline.m_points[m_selidx] = value;
			}
		}

		public bool Selected
		{
			get
			{
				return m_idx == m_selidx;
			}
			set
			{
				if (value)
				{
					m_selidx = m_idx;
				}
				else
				{
					m_selidx = -1;
				}
				m_selcpidx = -1;
			}
		}

		public bool ControlPoint1Selected
		{
			get
			{
				return m_selcpidx == 0;
			}
			set
			{
				if (value)
				{
					m_selcpidx = 0;
				}
				else
				{
					m_selcpidx = -1;
				}
			}
		}

		public bool ControlPoint2Selected
		{
			get
			{
				return m_selcpidx == 1;
			}
			set
			{
				if (value)
				{
					m_selcpidx = 1;
				}
				else
				{
					m_selcpidx = -1;
				}
			}
		}

		public bool ControlPointsVisible
		{
			get
			{
				if (m_selidx == -1)
				{
					return false;
				}
				return m_spline.m_points[m_selidx].m_type == SplinePointType.Bezier || m_spline.m_points[m_selidx].m_type == SplinePointType.BezierCorner;
			}
		}

		public bool SomethingSelected => m_selidx != -1;

		public int Index => m_idx;

		public int SelectedIndex => m_selidx;

		internal EditHelper(BezierSpline spline)
		{
			m_spline = spline;
		}

		public bool MoveNext()
		{
			m_idx++;
			if (m_idx < m_spline.m_points.Count)
			{
				return true;
			}
			return false;
		}

		public void Reset()
		{
			m_idx = -1;
		}

		public void AppendPoint()
		{
			if (m_spline.m_points.Count == 0)
			{
				m_spline.AppendPoint(Vector3.zero, SplinePointType.Corner, Vector3.zero, Vector3.zero);
			}
			else
			{
				m_spline.AppendPoint(m_spline.m_points[m_spline.m_points.Count - 1].m_point + Vector3.right, SplinePointType.Corner, Vector3.zero, Vector3.zero);
			}
			m_selidx = m_spline.m_points.Count - 1;
		}

		public void InsertBefore()
		{
			if (m_spline.m_points.Count == 1)
			{
				m_spline.InsertPoint(0, m_spline.m_points[m_spline.m_points.Count - 1].m_point + Vector3.right, SplinePointType.Corner, Vector3.zero, Vector3.zero);
				return;
			}
			int selidx = m_selidx;
			m_selidx--;
			if (m_selidx < 0)
			{
				m_selidx = m_spline.m_points.Count - 1;
			}
			m_spline.InsertPoint(selidx, (m_spline.m_points[m_selidx].m_point + m_spline.m_points[selidx].m_point) * 0.5f, SplinePointType.Corner, Vector3.zero, Vector3.zero);
			m_selidx = selidx;
		}

		public void InsertAfter()
		{
			if (m_spline.m_points.Count == 1)
			{
				m_spline.InsertPoint(0, m_spline.m_points[m_spline.m_points.Count - 1].m_point + Vector3.right, SplinePointType.Corner, Vector3.zero, Vector3.zero);
				return;
			}
			int selidx = m_selidx;
			m_selidx++;
			if (m_selidx == m_spline.m_points.Count)
			{
				m_selidx = m_spline.m_points.Count - 1;
			}
			m_spline.InsertPoint(m_selidx, (m_spline.m_points[m_selidx].m_point + m_spline.m_points[selidx].m_point) * 0.5f, SplinePointType.Corner, Vector3.zero, Vector3.zero);
		}

		public void Remove()
		{
			m_spline.m_points.RemoveAt(m_selidx);
			if (m_selidx >= m_spline.m_points.Count)
			{
				m_selidx = m_spline.m_points.Count - 1;
			}
		}

		public void RemoveLast()
		{
			if (m_spline.m_points.Count > 0)
			{
				m_spline.RemoveLastPoint();
			}
			if (m_selidx >= m_spline.m_points.Count)
			{
				m_selidx = m_spline.m_points.Count - 1;
			}
		}

		public void SelectFirst()
		{
			if (m_spline.m_points.Count > 0)
			{
				m_selidx = 0;
			}
			else
			{
				m_selidx = -1;
			}
		}

		public void SelectNext()
		{
			if (m_selidx < m_spline.m_points.Count - 1)
			{
				m_selidx++;
			}
			else
			{
				m_selidx = 0;
			}
		}

		public void SelectPrev()
		{
			if (m_selidx > 0)
			{
				m_selidx--;
			}
			else
			{
				m_selidx = m_spline.m_points.Count - 1;
			}
		}
	}

	[Serializable]
	public class BezierSplineSegment
	{
		public Vector3 m_startpos;

		public Vector3 m_endpos;

		public Vector3 m_startctrl;

		public Vector3 m_endctrl;

		public float m_startlen;

		public float m_endlen;

		public float m_length;

		public SplineSegmentType m_type;

		public float[] m_params;

		public float[] m_precomps;
	}

	[Serializable]
	public class BezierSplinePoint
	{
		public Vector3 m_point;

		public Vector3 m_prevctrl;

		public Vector3 m_nextctrl;

		public SplinePointType m_type;

		public BezierSplinePoint(Vector3 p, Vector3 c1, Vector3 c2, SplinePointType t)
		{
			m_point = p;
			m_prevctrl = c1;
			m_nextctrl = c2;
			m_type = t;
		}
	}

	public List<BezierSplinePoint> m_points = new List<BezierSplinePoint>();

	[SerializeField]
	private BezierSplineSegment[] m_segments;

	[SerializeField]
	private float m_precompdiv = 1f;

	public void AppendPoint(Vector3 pos, SplinePointType type, Vector3 cp1, Vector3 cp2)
	{
		m_points.Add(new BezierSplinePoint(pos, cp1, cp2, type));
	}

	public void RemoveLastPoint()
	{
		m_points.RemoveAt(m_points.Count - 1);
	}

	public void RemoveAllPoints()
	{
		m_points.Clear();
	}

	public void ReversePoints()
	{
		m_points.Reverse();
		for (int i = 0; i < m_points.Count; i++)
		{
			Vector3 nextctrl = m_points[i].m_nextctrl;
			m_points[i].m_nextctrl = m_points[i].m_prevctrl;
			m_points[i].m_prevctrl = nextctrl;
		}
	}

	public void InsertPoint(int idx, Vector3 pos, SplinePointType type, Vector3 cp1, Vector3 cp2)
	{
		if (idx < 0 || idx > m_points.Count)
		{
			throw new IndexOutOfRangeException();
		}
		m_points.Insert(idx, new BezierSplinePoint(pos, cp1, cp2, type));
	}

	public override void Build()
	{
		if (m_points.Count < 2)
		{
			m_segments = null;
			m_length = 0f;
			return;
		}
		int num = ((m_wrapmode != SplineWrapMode.Loop) ? (m_points.Count - 1) : m_points.Count);
		m_segments = new BezierSplineSegment[num];
		m_length = 0f;
		int i = 0;
		if (m_wrapmode == SplineWrapMode.Loop)
		{
			for (; i < num; i++)
			{
				BezierSplinePoint pp = m_points[SplineUtil.WrapIndex(i - 1, m_points.Count)];
				BezierSplinePoint sp = m_points[SplineUtil.WrapIndex(i, m_points.Count)];
				BezierSplinePoint ep = m_points[SplineUtil.WrapIndex(i + 1, m_points.Count)];
				BezierSplinePoint np = m_points[SplineUtil.WrapIndex(i + 2, m_points.Count)];
				m_segments[i] = new BezierSplineSegment();
				BuildSegment(m_segments[i], pp, sp, ep, np);
			}
		}
		else
		{
			for (; i < num; i++)
			{
				BezierSplinePoint pp = m_points[SplineUtil.ClampIndex(i - 1, m_points.Count)];
				BezierSplinePoint sp = m_points[SplineUtil.ClampIndex(i, m_points.Count)];
				BezierSplinePoint ep = m_points[SplineUtil.ClampIndex(i + 1, m_points.Count)];
				BezierSplinePoint np = m_points[SplineUtil.ClampIndex(i + 2, m_points.Count)];
				m_segments[i] = new BezierSplineSegment();
				BuildSegment(m_segments[i], pp, sp, ep, np);
			}
		}
		m_buildnum++;
	}

	private void BuildSegment(BezierSplineSegment ss, BezierSplinePoint pp, BezierSplinePoint sp, BezierSplinePoint ep, BezierSplinePoint np)
	{
		PreparePoint(pp, sp, ep);
		PreparePoint(sp, ep, np);
		ss.m_startpos = sp.m_point;
		ss.m_endpos = ep.m_point;
		ss.m_startctrl = ss.m_startpos + sp.m_nextctrl;
		ss.m_endctrl = ss.m_endpos + ep.m_prevctrl;
		if (sp.m_type == SplinePointType.Corner && ep.m_type == SplinePointType.Corner)
		{
			ss.m_type = SplineSegmentType.Linear;
		}
		else
		{
			ss.m_type = SplineSegmentType.Curve;
		}
		ss.m_startlen = m_length;
		float length = GetLength(ss);
		m_length += length;
		ss.m_length = length;
		ss.m_endlen = m_length;
		switch (m_reparam)
		{
		case SplineReparamType.None:
			ss.m_params = null;
			ss.m_precomps = null;
			break;
		case SplineReparamType.Simple:
		{
			m_precompdiv = 1f / (float)m_stepcount;
			float num3 = 0f;
			float num4 = 0f;
			ss.m_params = new float[m_stepcount + 1];
			ss.m_precomps = new float[m_stepcount + 1];
			for (int j = 1; j < m_stepcount + 1; j++)
			{
				Vector3 position = GetPosition(ss, num3);
				num3 += m_precompdiv;
				Vector3 position2 = GetPosition(ss, num3);
				num4 += (position2 - position).magnitude;
				ss.m_precomps[j] = num4 / length;
				ss.m_params[j] = num3;
			}
			ss.m_params[0] = 0f;
			ss.m_params[m_stepcount] = 1f;
			ss.m_precomps[0] = 0f;
			ss.m_precomps[m_stepcount] = 1f;
			m_precompdiv = 1f / (float)m_stepcount;
			break;
		}
		case SplineReparamType.RungeKutta:
		{
			float num = length / (float)m_stepcount;
			float num2 = 0f;
			ss.m_params = new float[m_stepcount + 1];
			ss.m_precomps = new float[m_stepcount + 1];
			for (int i = 0; i < m_stepcount + 1; i++)
			{
				ss.m_params[i] = GetReparamRungeKutta(ss, num2);
				ss.m_precomps[i] = num2 / length;
				num2 += num;
			}
			ss.m_params[0] = 0f;
			ss.m_params[m_stepcount] = 1f;
			ss.m_precomps[0] = 0f;
			ss.m_precomps[m_stepcount] = 1f;
			m_precompdiv = 1f / (float)m_stepcount;
			break;
		}
		}
	}

	private void PreparePoint(BezierSplinePoint pp, BezierSplinePoint pt, BezierSplinePoint np)
	{
		switch (pt.m_type)
		{
		case SplinePointType.Bezier:
			pt.m_nextctrl = -pt.m_prevctrl;
			break;
		case SplinePointType.Smooth:
			pt.m_prevctrl = -0.25f * (np.m_point - pp.m_point);
			pt.m_nextctrl = -0.25f * (pp.m_point - np.m_point);
			break;
		case SplinePointType.Corner:
			pt.m_prevctrl = Vector3.zero;
			pt.m_nextctrl = Vector3.zero;
			break;
		case SplinePointType.BezierCorner:
			break;
		}
	}

	private float GetLength(BezierSplineSegment ss)
	{
		switch (ss.m_type)
		{
		case SplineSegmentType.Linear:
			return (ss.m_endpos - ss.m_startpos).magnitude;
		case SplineSegmentType.Curve:
		{
			float num = 0f;
			float num2 = 0f;
			float num3 = 1f / (float)m_stepcount;
			int i = 0;
			Vector3 vector = ss.m_startpos;
			for (; i < m_stepcount; i++)
			{
				num2 += num3;
				Vector3 position = GetPosition(ss, num2);
				num += (position - vector).magnitude;
				vector = position;
			}
			return num;
		}
		default:
			return 0f;
		}
	}

	public Vector3 GetPosition(BezierSplineSegment ss, float t)
	{
		switch (ss.m_type)
		{
		case SplineSegmentType.Linear:
			return ss.m_startpos + (ss.m_endpos - ss.m_startpos) * t;
		case SplineSegmentType.Curve:
		{
			float num = 1f - t;
			float num2 = num * num;
			float num3 = t * t;
			return ss.m_startpos * num * num2 + ss.m_startctrl * 3f * num2 * t + ss.m_endctrl * 3f * num * num3 + ss.m_endpos * num3 * t;
		}
		default:
			return Vector3.zero;
		}
	}

	public Vector3 GetTangent(BezierSplineSegment ss, float t)
	{
		switch (ss.m_type)
		{
		case SplineSegmentType.Linear:
			return ss.m_endpos - ss.m_startpos;
		case SplineSegmentType.Curve:
		{
			float num = 1f - t;
			float num2 = num * num;
			float num3 = t * t;
			return ss.m_startpos * -3f * num2 + ss.m_startctrl * (-6f * num * t + 3f * num2) + ss.m_endctrl * (6f * num * t - 3f * num3) + ss.m_endpos * 3f * num3;
		}
		default:
			return Vector3.zero;
		}
	}

	private Vector3 GetNormal(BezierSplineSegment ss, float t)
	{
		return ss.m_type switch
		{
			SplineSegmentType.Linear => Vector3.zero, 
			SplineSegmentType.Curve => -6f * (ss.m_startpos * (1f - t) + ss.m_startctrl * (2f - 3f * t) + 3f * ss.m_endctrl * t - ss.m_endctrl - ss.m_endpos * t), 
			_ => Vector3.zero, 
		};
	}

	private float GetReparamRungeKutta(BezierSplineSegment ss, float u)
	{
		float num = 0f;
		float num2 = u / (float)m_stepcount;
		for (int i = 1; i <= m_stepcount; i++)
		{
			float magnitude = GetTangent(ss, num).magnitude;
			float num3;
			float num4;
			float num5;
			float num6;
			if (magnitude == 0f)
			{
				num3 = 0f;
				num4 = 0f;
				num5 = 0f;
				num6 = 0f;
			}
			else
			{
				num3 = num2 / GetTangent(ss, num).magnitude;
				num4 = num2 / GetTangent(ss, num + num3 * 0.5f).magnitude;
				num5 = num2 / GetTangent(ss, num + num4 * 0.5f).magnitude;
				num6 = num2 / GetTangent(ss, num + num5).magnitude;
			}
			num += (num3 + 2f * (num4 + num5) + num6) * (1f / 6f);
		}
		return num;
	}

	private float GetReparam(BezierSplineSegment ss, float u)
	{
		if (u <= 0f)
		{
			return 0f;
		}
		if (u >= 1f)
		{
			return 1f;
		}
		switch (m_reparam)
		{
		case SplineReparamType.RungeKutta:
		{
			int num2 = (int)(u * (float)m_stepcount);
			float t2 = (u - ss.m_precomps[num2]) / m_precompdiv;
			return Mathf.Lerp(ss.m_params[num2], ss.m_params[num2 + 1], t2);
		}
		case SplineReparamType.Simple:
		{
			int num = 0;
			for (int i = 1; i < m_stepcount + 1; i++)
			{
				if (ss.m_precomps[i] > u)
				{
					num = i - 1;
					break;
				}
			}
			float t = (u - ss.m_precomps[num]) / (ss.m_precomps[num + 1] - ss.m_precomps[num]);
			return Mathf.Lerp(ss.m_params[num], ss.m_params[num + 1], t);
		}
		default:
			return 0f;
		}
	}

	public override int GetPointCount()
	{
		return m_points.Count;
	}

	public override int GetSegmentCount()
	{
		if (m_segments != null)
		{
			return m_segments.Length;
		}
		return 0;
	}

	protected override float GetSegmentLength(int segidx)
	{
		return m_segments[segidx].m_length;
	}

	protected override float GetSegmentStartLength(int segidx)
	{
		return m_segments[segidx].m_startlen;
	}

	protected override float GetSegmentEndLength(int segidx)
	{
		return m_segments[segidx].m_endlen;
	}

	protected override int FindSegment(float offset)
	{
		for (int i = 0; i < m_segments.Length; i++)
		{
			if (m_segments[i].m_startlen <= offset && m_segments[i].m_endlen > offset)
			{
				return i;
			}
		}
		return m_segments.Length - 1;
	}

	protected override Vector3 GetDrawPosition(int segidx, float t)
	{
		BezierSplineSegment ss = m_segments[segidx];
		return GetPosition(ss, t);
	}

	protected override Vector3 GetPosition(int segidx, float segpos)
	{
		BezierSplineSegment bezierSplineSegment = m_segments[segidx];
		if (m_reparam == SplineReparamType.None)
		{
			return GetPosition(bezierSplineSegment, segpos / bezierSplineSegment.m_length);
		}
		return GetPosition(bezierSplineSegment, GetReparam(bezierSplineSegment, segpos / bezierSplineSegment.m_length));
	}

	protected override Vector3 GetTangent(int segidx, float segpos)
	{
		BezierSplineSegment bezierSplineSegment = m_segments[segidx];
		if (m_reparam == SplineReparamType.None)
		{
			return GetTangent(bezierSplineSegment, segpos / bezierSplineSegment.m_length);
		}
		return GetTangent(bezierSplineSegment, GetReparam(bezierSplineSegment, segpos / bezierSplineSegment.m_length));
	}

	protected override Vector3 GetNormal(int segidx, float segpos)
	{
		BezierSplineSegment bezierSplineSegment = m_segments[segidx];
		if (m_reparam == SplineReparamType.None)
		{
			return GetNormal(bezierSplineSegment, segpos / bezierSplineSegment.m_length);
		}
		return GetNormal(bezierSplineSegment, GetReparam(bezierSplineSegment, segpos / bezierSplineSegment.m_length));
	}

	public EditHelper GetEditHelper()
	{
		return new EditHelper(this);
	}
}
public class BezierSplineComponent : MonoBehaviour
{
	[SerializeField]
	private BezierSpline m_spline = new BezierSpline();

	private int m_buildnum = -1;

	private Vector3[] m_drawcache;

	public BezierSpline Spline => m_spline;

	private void OnDrawGizmosSelected()
	{
		DrawGizmos(Color.red);
	}

	private void OnDrawGizmos()
	{
		DrawGizmos(Color.white);
	}

	private void DrawGizmos(Color color)
	{
		int buildNum = m_spline.BuildNum;
		if (m_spline.GetSegmentCount() <= 0)
		{
			return;
		}
		if (m_buildnum != buildNum)
		{
			m_drawcache = m_spline.GenerateDrawPoints(16);
			m_buildnum = buildNum;
		}
		if (m_drawcache == null)
		{
			return;
		}
		Gizmos.matrix = base.transform.localToWorldMatrix;
		Gizmos.color = color;
		Vector3 from = Vector3.zero;
		Vector3 zero = Vector3.zero;
		for (int i = 0; i < m_drawcache.Length; i++)
		{
			zero = m_drawcache[i];
			if (i != 0)
			{
				Gizmos.DrawLine(from, zero);
			}
			from = zero;
		}
	}
}
public class BezierSplinePartialTest : MonoBehaviour
{
	public BezierSplineComponent m_spline;

	public float m_speed = 1f;

	public Vector3 m_up = Vector3.up;

	private BaseSpline.SplineIterator m_iter;

	private void Awake()
	{
		m_iter = m_spline.Spline.GetPartialIterator(0, 1);
		m_iter.SetTransform(m_spline.transform);
	}

	private void Update()
	{
		m_iter.Iterate(m_speed * Time.deltaTime);
		Vector3 position = base.transform.position;
		base.transform.position = m_iter.GetPosition();
		base.transform.rotation = Quaternion.LookRotation(m_iter.GetTangent(), m_up);
	}
}
public class BezierSplineTest : MonoBehaviour
{
	public BezierSplineComponent m_spline;

	public float m_speed = 1f;

	public float m_curspeed;

	public Vector3 m_up = Vector3.up;

	private BaseSpline.SplineIterator m_iter;

	private void Awake()
	{
		m_iter = m_spline.Spline.GetIterator();
		m_iter.SetTransform(m_spline.transform);
	}

	private void Update()
	{
		m_iter.Iterate(m_speed * Time.deltaTime);
		Vector3 position = base.transform.position;
		base.transform.position = m_iter.GetPosition();
		base.transform.rotation = Quaternion.LookRotation(m_iter.GetTangent(), m_up);
		m_curspeed = (base.transform.position - position).magnitude / Time.deltaTime;
	}
}
public static class Ease
{
	public enum Easing
	{
		Linear,
		InQuad,
		OutQuad,
		InOutQuad,
		OutInQuad,
		InCubic,
		OutCubic,
		InOutCubic,
		OutInCubic,
		InQuart,
		OutQuart,
		InOutQuart,
		OutInQuart,
		InQuint,
		OutQuint,
		InOutQuint,
		OutInQuint,
		InSin,
		OutSin,
		InOutSin,
		OutInSin,
		InExp,
		OutExp,
		InOutExp,
		OutInExp,
		InCirc,
		OutCirc,
		InOutCirc,
		OutInCirc,
		InElastic,
		OutElastic,
		InOutElastic,
		OutInElastic,
		InBounce,
		OutBounce,
		InOutBounce,
		OutInBounce,
		InBack,
		OutBack,
		InOutBack,
		OutInBack
	}

	public static float EaseByType(Easing e, float start, float end, float t)
	{
		return e switch
		{
			Easing.Linear => Linear(start, end, t), 
			Easing.InQuad => InQuad(start, end, t), 
			Easing.OutQuad => OutQuad(start, end, t), 
			Easing.InOutQuad => InOutQuad(start, end, t), 
			Easing.OutInQuad => OutInQuad(start, end, t), 
			Easing.InCubic => InCubic(start, end, t), 
			Easing.OutCubic => OutCubic(start, end, t), 
			Easing.InOutCubic => InOutCubic(start, end, t), 
			Easing.OutInCubic => OutInCubic(start, end, t), 
			Easing.InQuart => InQuart(start, end, t), 
			Easing.OutQuart => OutQuart(start, end, t), 
			Easing.InOutQuart => InOutQuart(start, end, t), 
			Easing.OutInQuart => OutInQuart(start, end, t), 
			Easing.InQuint => InQuint(start, end, t), 
			Easing.OutQuint => OutQuint(start, end, t), 
			Easing.InOutQuint => InOutQuint(start, end, t), 
			Easing.OutInQuint => OutInQuint(start, end, t), 
			Easing.InSin => InSin(start, end, t), 
			Easing.OutSin => OutSin(start, end, t), 
			Easing.InOutSin => InOutSin(start, end, t), 
			Easing.OutInSin => OutInSin(start, end, t), 
			Easing.InExp => InExp(start, end, t), 
			Easing.OutExp => OutExp(start, end, t), 
			Easing.InOutExp => InOutExp(start, end, t), 
			Easing.OutInExp => OutInExp(start, end, t), 
			Easing.InCirc => InCirc(start, end, t), 
			Easing.OutCirc => OutCirc(start, end, t), 
			Easing.InOutCirc => InOutCirc(start, end, t), 
			Easing.OutInCirc => OutInCirc(start, end, t), 
			Easing.InElastic => InElastic(start, end, t), 
			Easing.OutElastic => OutElastic(start, end, t), 
			Easing.InOutElastic => InOutElastic(start, end, t), 
			Easing.OutInElastic => OutInElastic(start, end, t), 
			Easing.InBounce => InBounce(start, end, t), 
			Easing.OutBounce => OutBounce(start, end, t), 
			Easing.InOutBounce => InOutBounce(start, end, t), 
			Easing.OutInBounce => OutInBounce(start, end, t), 
			Easing.InBack => InBack(start, end, t), 
			Easing.OutBack => OutBack(start, end, t), 
			Easing.InOutBack => InOutBack(start, end, t), 
			Easing.OutInBack => OutInBack(start, end, t), 
			_ => 0f, 
		};
	}

	public static float Linear(float start, float end, float t)
	{
		return t * (end - start) + start;
	}

	public static float InQuad(float start, float end, float t)
	{
		return t * t * (end - start) + start;
	}

	public static float OutQuad(float start, float end, float t)
	{
		return (0f - t * (t - 2f)) * (end - start) + start;
	}

	public static float InOutQuad(float start, float end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			return 0.5f * t * t * (end - start) + start;
		}
		t -= 1f;
		return -0.5f * (t * (t - 2f) - 1f) * (end - start) + start;
	}

	public static float OutInQuad(float start, float end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			return (-0.5f * (t * (t - 2f) - 1f) - 0.5f) * (end - start) + start;
		}
		t -= 1f;
		return (0.5f * t * t + 0.5f) * (end - start) + start;
	}

	public static float InCubic(float start, float end, float t)
	{
		return t * t * t * (end - start) + start;
	}

	public static float OutCubic(float start, float end, float t)
	{
		t -= 1f;
		return (t * t * t + 1f) * (end - start) + start;
	}

	public static float InOutCubic(float start, float end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			return 0.5f * t * t * t * (end - start) + start;
		}
		t -= 2f;
		return 0.5f * (t * t * t + 2f) * (end - start) + start;
	}

	public static float OutInCubic(float start, float end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			t -= 1f;
			return (0.5f * (t * t * t + 2f) - 0.5f) * (end - start) + start;
		}
		t -= 1f;
		return (0.5f * t * t * t + 0.5f) * (end - start) + start;
	}

	public static float InQuart(float start, float end, float t)
	{
		return t * t * t * t * (end - start) + start;
	}

	public static float OutQuart(float start, float end, float t)
	{
		t -= 1f;
		return (0f - (t * t * t * t - 1f)) * (end - start) + start;
	}

	public static float InOutQuart(float start, float end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			return 0.5f * t * t * t * t * (end - start) + start;
		}
		t -= 2f;
		return -0.5f * (t * t * t * t - 2f) * (end - start) + start;
	}

	public static float OutInQuart(float start, float end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			t -= 1f;
			return (-0.5f * t * t * t * t + 0.5f) * (end - start) + start;
		}
		t -= 1f;
		return (0.5f * t * t * t * t + 0.5f) * (end - start) + start;
	}

	public static float InQuint(float start, float end, float t)
	{
		return t * t * t * t * t * (end - start) + start;
	}

	public static float OutQuint(float start, float end, float t)
	{
		t -= 1f;
		return (t * t * t * t * t + 1f) * (end - start) + start;
	}

	public static float InOutQuint(float start, float end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			return 0.5f * t * t * t * t * t * (end - start) + start;
		}
		t -= 2f;
		return (0.5f * t * t * t * t * t + 1f) * (end - start) + start;
	}

	public static float OutInQuint(float start, float end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			t -= 1f;
			return (0.5f * (t * t * t * t * t) + 0.5f) * (end - start) + start;
		}
		t -= 1f;
		return (0.5f * t * t * t * t * t + 0.5f) * (end - start) + start;
	}

	public static float InSin(float start, float end, float t)
	{
		return (0f - Mathf.Cos(t * (float)Math.PI * 0.5f)) * (end - start) + end;
	}

	public static float OutSin(float start, float end, float t)
	{
		return Mathf.Sin(t * (float)Math.PI * 0.5f) * (end - start) + start;
	}

	public static float InOutSin(float start, float end, float t)
	{
		return (-0.5f * Mathf.Cos(t * (float)Math.PI) + 0.5f) * (end - start) + start;
	}

	public static float OutInSin(float start, float end, float t)
	{
		return (t - (-0.5f * Mathf.Cos(t * (float)Math.PI) + 0.5f - t)) * (end - start) + start;
	}

	public static float InExp(float start, float end, float t)
	{
		return Mathf.Pow(2f, 10f * (t - 1f)) * (end - start) + start;
	}

	public static float OutExp(float start, float end, float t)
	{
		return (1f - Mathf.Pow(2f, -10f * t)) * (end - start) + start;
	}

	public static float InOutExp(float start, float end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			return 0.5f * Mathf.Pow(2f, 10f * (t - 1f)) * (end - start) + start;
		}
		t -= 1f;
		return 0.5f * (2f - Mathf.Pow(2f, -10f * t)) * (end - start) + start;
	}

	public static float OutInExp(float start, float end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			return (0.5f * (2f - Mathf.Pow(2f, -10f * t)) - 0.5f) * (end - start) + start;
		}
		t -= 1f;
		return (0.5f * Mathf.Pow(2f, 10f * (t - 1f)) + 0.5f) * (end - start) + start;
	}

	public static float InCirc(float start, float end, float t)
	{
		return (0f - (Mathf.Sqrt(1f - t * t) - 1f)) * (end - start) + start;
	}

	public static float OutCirc(float start, float end, float t)
	{
		t -= 1f;
		return Mathf.Sqrt(1f - t * t) * (end - start) + start;
	}

	public static float InOutCirc(float start, float end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			return -0.5f * (Mathf.Sqrt(1f - t * t) - 1f) * (end - start) + start;
		}
		t -= 2f;
		return 0.5f * (Mathf.Sqrt(1f - t * t) + 1f) * (end - start) + start;
	}

	public static float OutInCirc(float start, float end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			t -= 1f;
			return 0.5f * Mathf.Sqrt(1f - t * t) * (end - start) + start;
		}
		t -= 1f;
		return (-0.5f * Mathf.Sqrt(1f - t * t) + 1f) * (end - start) + start;
	}

	public static float InElastic(float start, float end, float t)
	{
		float num = 0.3f;
		float num2 = 0.075f;
		t -= 1f;
		return (0f - Mathf.Pow(2f, 10f * t)) * Mathf.Sin((t - num2) * ((float)Math.PI * 2f) / num) * (end - start) + start;
	}

	public static float OutElastic(float start, float end, float t)
	{
		float num = 0.3f;
		float num2 = 0.075f;
		return Mathf.Pow(2f, -10f * t) * Mathf.Sin((t - num2) * ((float)Math.PI * 2f) / num) * (end - start) + end;
	}

	public static float InOutElastic(float start, float end, float t)
	{
		float num = 0.3f;
		float num2 = 0.075f;
		t *= 2f;
		if (t < 1f)
		{
			t -= 1f;
			return -0.5f * Mathf.Pow(2f, 10f * t) * Mathf.Sin((t - num2) * ((float)Math.PI * 2f) / num) * (end - start) + start;
		}
		t -= 1f;
		return 0.5f * Mathf.Pow(2f, -10f * t) * Mathf.Sin((t - num2) * ((float)Math.PI * 2f) / num) * (end - start) + end;
	}

	public static float OutInElastic(float start, float end, float t)
	{
		float num = 0.3f;
		float num2 = 0.075f;
		t *= 2f;
		if (t < 1f)
		{
			return (0.5f * Mathf.Pow(2f, -10f * t) * Mathf.Sin((t - num2) * ((float)Math.PI * 2f) / num) - 0.5f) * (end - start) + end;
		}
		t -= 2f;
		return (-0.5f * Mathf.Pow(2f, 10f * t) * Mathf.Sin((t - num2) * ((float)Math.PI * 2f) / num) + 0.5f) * (end - start) + start;
	}

	public static float InBounce(float start, float end, float t)
	{
		t = 1f - t;
		if (t < 0.36363637f)
		{
			return (-7.5625f * t * t + 1f) * (end - start) + start;
		}
		if (t < 0.72727275f)
		{
			t -= 0.54545456f;
			return (-7.5625f * t * t - 0.75f + 1f) * (end - start) + start;
		}
		if (t < 0.90909094f)
		{
			t -= 0.8181818f;
			return (-7.5625f * t * t - 0.9375f + 1f) * (end - start) + start;
		}
		t -= 21f / 22f;
		return (-7.5625f * t * t - 63f / 64f + 1f) * (end - start) + start;
	}

	public static float OutBounce(float start, float end, float t)
	{
		if (t < 0.36363637f)
		{
			return 7.5625f * t * t * (end - start) + start;
		}
		if (t < 0.72727275f)
		{
			t -= 0.54545456f;
			return (7.5625f * t * t + 0.75f) * (end - start) + start;
		}
		if (t < 0.90909094f)
		{
			t -= 0.8181818f;
			return (7.5625f * t * t + 0.9375f) * (end - start) + start;
		}
		t -= 21f / 22f;
		return (7.5625f * t * t + 63f / 64f) * (end - start) + start;
	}

	public static float InOutBounce(float start, float end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			t = 1f - t;
			if (t < 0.36363637f)
			{
				return (-3.78125f * t * t + 0.5f) * (end - start) + start;
			}
			if (t < 0.72727275f)
			{
				t -= 0.54545456f;
				return (-0.5f * (7.5625f * t * t + 0.75f) + 0.5f) * (end - start) + start;
			}
			if (t < 0.90909094f)
			{
				t -= 0.8181818f;
				return (-0.5f * (7.5625f * t * t + 0.9375f) + 0.5f) * (end - start) + start;
			}
			t -= 21f / 22f;
			return (-0.5f * (7.5625f * t * t + 63f / 64f) + 0.5f) * (end - start) + start;
		}
		t -= 1f;
		if (t < 0.36363637f)
		{
			return (3.78125f * t * t + 0.5f) * (end - start) + start;
		}
		if (t < 0.72727275f)
		{
			t -= 0.54545456f;
			return (0.5f * (7.5625f * t * t + 0.75f) + 0.5f) * (end - start) + start;
		}
		if (t < 0.90909094f)
		{
			t -= 0.8181818f;
			return (0.5f * (7.5625f * t * t + 0.9375f) + 0.5f) * (end - start) + start;
		}
		t -= 21f / 22f;
		return (0.5f * (7.5625f * t * t + 63f / 64f) + 0.5f) * (end - start) + start;
	}

	public static float OutInBounce(float start, float end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			if (t < 0.36363637f)
			{
				return 3.78125f * t * t * (end - start) + start;
			}
			if (t < 0.72727275f)
			{
				t -= 0.54545456f;
				return 0.5f * (7.5625f * t * t + 0.75f) * (end - start) + start;
			}
			if (t < 0.90909094f)
			{
				t -= 0.8181818f;
				return 0.5f * (7.5625f * t * t + 0.9375f) * (end - start) + start;
			}
			t -= 21f / 22f;
			return 0.5f * (7.5625f * t * t + 63f / 64f) * (end - start) + start;
		}
		t = 2f - t;
		if (t < 0.36363637f)
		{
			return (-3.78125f * t * t + 1f) * (end - start) + start;
		}
		if (t < 0.72727275f)
		{
			t -= 0.54545456f;
			return (-0.5f * (7.5625f * t * t + 0.75f) + 1f) * (end - start) + start;
		}
		if (t < 0.90909094f)
		{
			t -= 0.8181818f;
			return (-0.5f * (7.5625f * t * t + 0.9375f) + 1f) * (end - start) + start;
		}
		t -= 21f / 22f;
		return (-0.5f * (7.5625f * t * t + 63f / 64f) + 1f) * (end - start) + start;
	}

	public static float InBack(float start, float end, float t)
	{
		return t * t * (2.70158f * t - 1.70158f) * (end - start) + start;
	}

	public static float OutBack(float start, float end, float t)
	{
		t -= 1f;
		return (1f - t * t * (-2.70158f * t - 1.70158f)) * (end - start) + start;
	}

	public static float InOutBack(float start, float end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			return 0.5f * t * t * (2.70158f * t - 1.70158f) * (end - start) + start;
		}
		t -= 2f;
		return (1f - 0.5f * t * t * (-2.70158f * t - 1.70158f)) * (end - start) + start;
	}

	public static float OutInBack(float start, float end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			t -= 1f;
			return (0.5f - 0.5f * t * t * (-2.70158f * t - 1.70158f)) * (end - start) + start;
		}
		t -= 1f;
		return (0.5f * t * t * (2.70158f * t - 1.70158f) + 0.5f) * (end - start) + start;
	}

	public static Vector3 EaseByType(Easing e, Vector3 start, Vector3 end, float t)
	{
		return e switch
		{
			Easing.Linear => Linear(start, end, t), 
			Easing.InQuad => InQuad(start, end, t), 
			Easing.OutQuad => OutQuad(start, end, t), 
			Easing.InOutQuad => InOutQuad(start, end, t), 
			Easing.OutInQuad => OutInQuad(start, end, t), 
			Easing.InCubic => InCubic(start, end, t), 
			Easing.OutCubic => OutCubic(start, end, t), 
			Easing.InOutCubic => InOutCubic(start, end, t), 
			Easing.OutInCubic => OutInCubic(start, end, t), 
			Easing.InQuart => InQuart(start, end, t), 
			Easing.OutQuart => OutQuart(start, end, t), 
			Easing.InOutQuart => InOutQuart(start, end, t), 
			Easing.OutInQuart => OutInQuart(start, end, t), 
			Easing.InQuint => InQuint(start, end, t), 
			Easing.OutQuint => OutQuint(start, end, t), 
			Easing.InOutQuint => InOutQuint(start, end, t), 
			Easing.OutInQuint => OutInQuint(start, end, t), 
			Easing.InSin => InSin(start, end, t), 
			Easing.OutSin => OutSin(start, end, t), 
			Easing.InOutSin => InOutSin(start, end, t), 
			Easing.OutInSin => OutInSin(start, end, t), 
			Easing.InExp => InExp(start, end, t), 
			Easing.OutExp => OutExp(start, end, t), 
			Easing.InOutExp => InOutExp(start, end, t), 
			Easing.OutInExp => OutInExp(start, end, t), 
			Easing.InCirc => InCirc(start, end, t), 
			Easing.OutCirc => OutCirc(start, end, t), 
			Easing.InOutCirc => InOutCirc(start, end, t), 
			Easing.OutInCirc => OutInCirc(start, end, t), 
			Easing.InElastic => InElastic(start, end, t), 
			Easing.OutElastic => OutElastic(start, end, t), 
			Easing.InOutElastic => InOutElastic(start, end, t), 
			Easing.OutInElastic => OutInElastic(start, end, t), 
			Easing.InBounce => InBounce(start, end, t), 
			Easing.OutBounce => OutBounce(start, end, t), 
			Easing.InOutBounce => InOutBounce(start, end, t), 
			Easing.OutInBounce => OutInBounce(start, end, t), 
			Easing.InBack => InBack(start, end, t), 
			Easing.OutBack => OutBack(start, end, t), 
			Easing.InOutBack => InOutBack(start, end, t), 
			Easing.OutInBack => OutInBack(start, end, t), 
			_ => Vector3.zero, 
		};
	}

	public static Vector3 Linear(Vector3 start, Vector3 end, float t)
	{
		return t * (end - start) + start;
	}

	public static Vector3 InQuad(Vector3 start, Vector3 end, float t)
	{
		return t * t * (end - start) + start;
	}

	public static Vector3 OutQuad(Vector3 start, Vector3 end, float t)
	{
		return (0f - t * (t - 2f)) * (end - start) + start;
	}

	public static Vector3 InOutQuad(Vector3 start, Vector3 end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			return 0.5f * t * t * (end - start) + start;
		}
		t -= 1f;
		return -0.5f * (t * (t - 2f) - 1f) * (end - start) + start;
	}

	public static Vector3 OutInQuad(Vector3 start, Vector3 end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			return (-0.5f * (t * (t - 2f) - 1f) - 0.5f) * (end - start) + start;
		}
		t -= 1f;
		return (0.5f * t * t + 0.5f) * (end - start) + start;
	}

	public static Vector3 InCubic(Vector3 start, Vector3 end, float t)
	{
		return t * t * t * (end - start) + start;
	}

	public static Vector3 OutCubic(Vector3 start, Vector3 end, float t)
	{
		t -= 1f;
		return (t * t * t + 1f) * (end - start) + start;
	}

	public static Vector3 InOutCubic(Vector3 start, Vector3 end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			return 0.5f * t * t * t * (end - start) + start;
		}
		t -= 2f;
		return 0.5f * (t * t * t + 2f) * (end - start) + start;
	}

	public static Vector3 OutInCubic(Vector3 start, Vector3 end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			t -= 1f;
			return (0.5f * (t * t * t + 2f) - 0.5f) * (end - start) + start;
		}
		t -= 1f;
		return (0.5f * t * t * t + 0.5f) * (end - start) + start;
	}

	public static Vector3 InQuart(Vector3 start, Vector3 end, float t)
	{
		return t * t * t * t * (end - start) + start;
	}

	public static Vector3 OutQuart(Vector3 start, Vector3 end, float t)
	{
		t -= 1f;
		return (0f - (t * t * t * t - 1f)) * (end - start) + start;
	}

	public static Vector3 InOutQuart(Vector3 start, Vector3 end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			return 0.5f * t * t * t * t * (end - start) + start;
		}
		t -= 2f;
		return -0.5f * (t * t * t * t - 2f) * (end - start) + start;
	}

	public static Vector3 OutInQuart(Vector3 start, Vector3 end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			t -= 1f;
			return (-0.5f * t * t * t * t + 0.5f) * (end - start) + start;
		}
		t -= 1f;
		return (0.5f * t * t * t * t + 0.5f) * (end - start) + start;
	}

	public static Vector3 InQuint(Vector3 start, Vector3 end, float t)
	{
		return t * t * t * t * t * (end - start) + start;
	}

	public static Vector3 OutQuint(Vector3 start, Vector3 end, float t)
	{
		t -= 1f;
		return (t * t * t * t * t + 1f) * (end - start) + start;
	}

	public static Vector3 InOutQuint(Vector3 start, Vector3 end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			return 0.5f * t * t * t * t * t * (end - start) + start;
		}
		t -= 2f;
		return (0.5f * t * t * t * t * t + 1f) * (end - start) + start;
	}

	public static Vector3 OutInQuint(Vector3 start, Vector3 end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			t -= 1f;
			return (0.5f * (t * t * t * t * t) + 0.5f) * (end - start) + start;
		}
		t -= 1f;
		return (0.5f * t * t * t * t * t + 0.5f) * (end - start) + start;
	}

	public static Vector3 InSin(Vector3 start, Vector3 end, float t)
	{
		return (0f - Mathf.Cos(t * (float)Math.PI * 0.5f)) * (end - start) + end;
	}

	public static Vector3 OutSin(Vector3 start, Vector3 end, float t)
	{
		return Mathf.Sin(t * (float)Math.PI * 0.5f) * (end - start) + start;
	}

	public static Vector3 InOutSin(Vector3 start, Vector3 end, float t)
	{
		return (-0.5f * Mathf.Cos(t * (float)Math.PI) + 0.5f) * (end - start) + start;
	}

	public static Vector3 OutInSin(Vector3 start, Vector3 end, float t)
	{
		return (t - (-0.5f * Mathf.Cos(t * (float)Math.PI) + 0.5f - t)) * (end - start) + start;
	}

	public static Vector3 InExp(Vector3 start, Vector3 end, float t)
	{
		return Mathf.Pow(2f, 10f * (t - 1f)) * (end - start) + start;
	}

	public static Vector3 OutExp(Vector3 start, Vector3 end, float t)
	{
		return (1f - Mathf.Pow(2f, -10f * t)) * (end - start) + start;
	}

	public static Vector3 InOutExp(Vector3 start, Vector3 end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			return 0.5f * Mathf.Pow(2f, 10f * (t - 1f)) * (end - start) + start;
		}
		t -= 1f;
		return 0.5f * (2f - Mathf.Pow(2f, -10f * t)) * (end - start) + start;
	}

	public static Vector3 OutInExp(Vector3 start, Vector3 end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			return (0.5f * (2f - Mathf.Pow(2f, -10f * t)) - 0.5f) * (end - start) + start;
		}
		t -= 1f;
		return (0.5f * Mathf.Pow(2f, 10f * (t - 1f)) + 0.5f) * (end - start) + start;
	}

	public static Vector3 InCirc(Vector3 start, Vector3 end, float t)
	{
		return (0f - (Mathf.Sqrt(1f - t * t) - 1f)) * (end - start) + start;
	}

	public static Vector3 OutCirc(Vector3 start, Vector3 end, float t)
	{
		t -= 1f;
		return Mathf.Sqrt(1f - t * t) * (end - start) + start;
	}

	public static Vector3 InOutCirc(Vector3 start, Vector3 end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			return -0.5f * (Mathf.Sqrt(1f - t * t) - 1f) * (end - start) + start;
		}
		t -= 2f;
		return 0.5f * (Mathf.Sqrt(1f - t * t) + 1f) * (end - start) + start;
	}

	public static Vector3 OutInCirc(Vector3 start, Vector3 end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			t -= 1f;
			return 0.5f * Mathf.Sqrt(1f - t * t) * (end - start) + start;
		}
		t -= 1f;
		return (-0.5f * Mathf.Sqrt(1f - t * t) + 1f) * (end - start) + start;
	}

	public static Vector3 InElastic(Vector3 start, Vector3 end, float t)
	{
		float num = 0.3f;
		float num2 = 0.075f;
		t -= 1f;
		return (0f - Mathf.Pow(2f, 10f * t)) * Mathf.Sin((t - num2) * ((float)Math.PI * 2f) / num) * (end - start) + start;
	}

	public static Vector3 OutElastic(Vector3 start, Vector3 end, float t)
	{
		float num = 0.3f;
		float num2 = 0.075f;
		return Mathf.Pow(2f, -10f * t) * Mathf.Sin((t - num2) * ((float)Math.PI * 2f) / num) * (end - start) + end;
	}

	public static Vector3 InOutElastic(Vector3 start, Vector3 end, float t)
	{
		float num = 0.3f;
		float num2 = 0.075f;
		t *= 2f;
		if (t < 1f)
		{
			t -= 1f;
			return -0.5f * Mathf.Pow(2f, 10f * t) * Mathf.Sin((t - num2) * ((float)Math.PI * 2f) / num) * (end - start) + start;
		}
		t -= 1f;
		return 0.5f * Mathf.Pow(2f, -10f * t) * Mathf.Sin((t - num2) * ((float)Math.PI * 2f) / num) * (end - start) + end;
	}

	public static Vector3 OutInElastic(Vector3 start, Vector3 end, float t)
	{
		float num = 0.3f;
		float num2 = 0.075f;
		t *= 2f;
		if (t < 1f)
		{
			return (0.5f * Mathf.Pow(2f, -10f * t) * Mathf.Sin((t - num2) * ((float)Math.PI * 2f) / num) - 0.5f) * (end - start) + end;
		}
		t -= 2f;
		return (-0.5f * Mathf.Pow(2f, 10f * t) * Mathf.Sin((t - num2) * ((float)Math.PI * 2f) / num) + 0.5f) * (end - start) + start;
	}

	public static Vector3 InBounce(Vector3 start, Vector3 end, float t)
	{
		t = 1f - t;
		if (t < 0.36363637f)
		{
			return (-7.5625f * t * t + 1f) * (end - start) + start;
		}
		if (t < 0.72727275f)
		{
			t -= 0.54545456f;
			return (-7.5625f * t * t - 0.75f + 1f) * (end - start) + start;
		}
		if (t < 0.90909094f)
		{
			t -= 0.8181818f;
			return (-7.5625f * t * t - 0.9375f + 1f) * (end - start) + start;
		}
		t -= 21f / 22f;
		return (-7.5625f * t * t - 63f / 64f + 1f) * (end - start) + start;
	}

	public static Vector3 OutBounce(Vector3 start, Vector3 end, float t)
	{
		if (t < 0.36363637f)
		{
			return 7.5625f * t * t * (end - start) + start;
		}
		if (t < 0.72727275f)
		{
			t -= 0.54545456f;
			return (7.5625f * t * t + 0.75f) * (end - start) + start;
		}
		if (t < 0.90909094f)
		{
			t -= 0.8181818f;
			return (7.5625f * t * t + 0.9375f) * (end - start) + start;
		}
		t -= 21f / 22f;
		return (7.5625f * t * t + 63f / 64f) * (end - start) + start;
	}

	public static Vector3 InOutBounce(Vector3 start, Vector3 end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			t = 1f - t;
			if (t < 0.36363637f)
			{
				return (-3.78125f * t * t + 0.5f) * (end - start) + start;
			}
			if (t < 0.72727275f)
			{
				t -= 0.54545456f;
				return (-0.5f * (7.5625f * t * t + 0.75f) + 0.5f) * (end - start) + start;
			}
			if (t < 0.90909094f)
			{
				t -= 0.8181818f;
				return (-0.5f * (7.5625f * t * t + 0.9375f) + 0.5f) * (end - start) + start;
			}
			t -= 21f / 22f;
			return (-0.5f * (7.5625f * t * t + 63f / 64f) + 0.5f) * (end - start) + start;
		}
		t -= 1f;
		if (t < 0.36363637f)
		{
			return (3.78125f * t * t + 0.5f) * (end - start) + start;
		}
		if (t < 0.72727275f)
		{
			t -= 0.54545456f;
			return (0.5f * (7.5625f * t * t + 0.75f) + 0.5f) * (end - start) + start;
		}
		if (t < 0.90909094f)
		{
			t -= 0.8181818f;
			return (0.5f * (7.5625f * t * t + 0.9375f) + 0.5f) * (end - start) + start;
		}
		t -= 21f / 22f;
		return (0.5f * (7.5625f * t * t + 63f / 64f) + 0.5f) * (end - start) + start;
	}

	public static Vector3 OutInBounce(Vector3 start, Vector3 end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			if (t < 0.36363637f)
			{
				return 3.78125f * t * t * (end - start) + start;
			}
			if (t < 0.72727275f)
			{
				t -= 0.54545456f;
				return 0.5f * (7.5625f * t * t + 0.75f) * (end - start) + start;
			}
			if (t < 0.90909094f)
			{
				t -= 0.8181818f;
				return 0.5f * (7.5625f * t * t + 0.9375f) * (end - start) + start;
			}
			t -= 21f / 22f;
			return 0.5f * (7.5625f * t * t + 63f / 64f) * (end - start) + start;
		}
		t = 2f - t;
		if (t < 0.36363637f)
		{
			return (-3.78125f * t * t + 1f) * (end - start) + start;
		}
		if (t < 0.72727275f)
		{
			t -= 0.54545456f;
			return (-0.5f * (7.5625f * t * t + 0.75f) + 1f) * (end - start) + start;
		}
		if (t < 0.90909094f)
		{
			t -= 0.8181818f;
			return (-0.5f * (7.5625f * t * t + 0.9375f) + 1f) * (end - start) + start;
		}
		t -= 21f / 22f;
		return (-0.5f * (7.5625f * t * t + 63f / 64f) + 1f) * (end - start) + start;
	}

	public static Vector3 InBack(Vector3 start, Vector3 end, float t)
	{
		return t * t * (2.70158f * t - 1.70158f) * (end - start) + start;
	}

	public static Vector3 OutBack(Vector3 start, Vector3 end, float t)
	{
		t -= 1f;
		return (1f - t * t * (-2.70158f * t - 1.70158f)) * (end - start) + start;
	}

	public static Vector3 InOutBack(Vector3 start, Vector3 end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			return 0.5f * t * t * (2.70158f * t - 1.70158f) * (end - start) + start;
		}
		t -= 2f;
		return (1f - 0.5f * t * t * (-2.70158f * t - 1.70158f)) * (end - start) + start;
	}

	public static Vector3 OutInBack(Vector3 start, Vector3 end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			t -= 1f;
			return (0.5f - 0.5f * t * t * (-2.70158f * t - 1.70158f)) * (end - start) + start;
		}
		t -= 1f;
		return (0.5f * t * t * (2.70158f * t - 1.70158f) + 0.5f) * (end - start) + start;
	}
}
public class SplineUtil
{
	public static int ClampIndex(int idx, int len)
	{
		if (idx < 0)
		{
			idx = 0;
		}
		else if (idx > len - 1)
		{
			idx = len - 1;
		}
		return idx;
	}

	public static int WrapIndex(int idx, int len)
	{
		if (idx < 0)
		{
			idx = len + idx % len;
		}
		else if (idx >= len - 1)
		{
			idx %= len;
		}
		return idx;
	}

	public static float WrapPosition(BaseSpline.SplineWrapMode wrapmode, float pos, float len)
	{
		switch (wrapmode)
		{
		case BaseSpline.SplineWrapMode.Loop:
			if (pos < 0f)
			{
				int num3 = (int)((0f - pos) / len) + 1;
				pos += (float)num3 * len;
			}
			else if (pos >= len)
			{
				int num4 = (int)(pos / len);
				pos -= (float)num4 * len;
			}
			break;
		case BaseSpline.SplineWrapMode.PingPong:
			if (pos < 0f)
			{
				int num5 = (int)((0f - pos) / len) + 1;
				pos = ((num5 % 2 != 0) ? (len - (pos + (float)num5 * len)) : (pos + (float)num5 * len));
			}
			else if (pos >= len)
			{
				int num6 = (int)(pos / len);
				pos = ((num6 % 2 != 0) ? (len - (pos - (float)num6 * len)) : (pos - (float)num6 * len));
			}
			break;
		case BaseSpline.SplineWrapMode.Repeat:
			if (pos < 0f)
			{
				int num = (int)((0f - pos) / len) + 1;
				pos += (float)num * len;
			}
			else if (pos >= len)
			{
				int num2 = (int)(pos / len);
				pos -= (float)num2 * len;
			}
			break;
		case BaseSpline.SplineWrapMode.Once:
			if (pos < 0f)
			{
				pos = 0f;
			}
			else if (pos > len)
			{
				pos = len;
			}
			break;
		}
		return pos;
	}
}
[Serializable]
public class UniSpline : BaseSpline
{
	public class EditHelper
	{
		private UniSpline m_spline;

		private int m_idx = -1;

		private int m_selidx = -1;

		public Vector3 Point
		{
			get
			{
				return m_spline.m_points[m_idx];
			}
			set
			{
				m_spline.m_points[m_idx] = value;
			}
		}

		public Vector3 SelectedPoint
		{
			get
			{
				return m_spline.m_points[m_selidx];
			}
			set
			{
				m_spline.m_points[m_selidx] = value;
			}
		}

		public bool Selected
		{
			get
			{
				return m_idx == m_selidx;
			}
			set
			{
				if (value)
				{
					m_selidx = m_idx;
				}
				else
				{
					m_selidx = -1;
				}
			}
		}

		public bool SomethingSelected => m_selidx != -1;

		public int Index => m_idx;

		public int SelectedIndex => m_selidx;

		internal EditHelper(UniSpline spline)
		{
			m_spline = spline;
		}

		public bool MoveNext()
		{
			m_idx++;
			if (m_idx < m_spline.m_points.Count)
			{
				return true;
			}
			return false;
		}

		public void Reset()
		{
			m_idx = -1;
		}

		public void AppendPoint()
		{
			if (m_spline.m_points.Count == 0)
			{
				m_spline.AppendPoint(Vector3.zero);
			}
			else
			{
				m_spline.AppendPoint(m_spline.m_points[m_spline.m_points.Count - 1] + Vector3.right);
			}
			m_selidx = m_spline.m_points.Count - 1;
		}

		public void InsertBefore()
		{
			if (m_spline.m_points.Count == 1)
			{
				m_spline.InsertPoint(0, m_spline.m_points[m_spline.m_points.Count - 1] + Vector3.right);
				return;
			}
			int selidx = m_selidx;
			m_selidx--;
			if (m_selidx < 0)
			{
				m_selidx = m_spline.m_points.Count - 1;
			}
			m_spline.InsertPoint(selidx, (m_spline.m_points[m_selidx] + m_spline.m_points[selidx]) * 0.5f);
			m_selidx = selidx;
		}

		public void InsertAfter()
		{
			if (m_spline.m_points.Count == 1)
			{
				m_spline.InsertPoint(0, m_spline.m_points[m_spline.m_points.Count - 1] + Vector3.right);
				return;
			}
			int selidx = m_selidx;
			m_selidx++;
			if (m_selidx == m_spline.m_points.Count)
			{
				m_selidx = m_spline.m_points.Count - 1;
			}
			m_spline.InsertPoint(m_selidx, (m_spline.m_points[m_selidx] + m_spline.m_points[selidx]) * 0.5f);
		}

		public void Remove()
		{
			m_spline.m_points.RemoveAt(m_selidx);
			if (m_selidx >= m_spline.m_points.Count)
			{
				m_selidx = m_spline.m_points.Count - 1;
			}
		}

		public void RemoveLast()
		{
			if (m_spline.m_points.Count > 0)
			{
				m_spline.RemoveLastPoint();
			}
			if (m_selidx >= m_spline.m_points.Count)
			{
				m_selidx = m_spline.m_points.Count - 1;
			}
		}

		public void SelectFirst()
		{
			if (m_spline.m_points.Count > 0)
			{
				m_selidx = 0;
			}
			else
			{
				m_selidx = -1;
			}
		}

		public void SelectNext()
		{
			if (m_selidx < m_spline.m_points.Count - 1)
			{
				m_selidx++;
			}
			else
			{
				m_selidx = 0;
			}
		}

		public void SelectPrev()
		{
			if (m_selidx > 0)
			{
				m_selidx--;
			}
			else
			{
				m_selidx = m_spline.m_points.Count - 1;
			}
		}
	}

	[Serializable]
	public class UniSplineSegment
	{
		public Vector3 m_startpos;

		public Vector3 m_startctrl;

		public Vector3 m_endctrl;

		public Vector3 m_endpos;

		public float m_startlen;

		public float m_endlen;

		public float m_length;

		public float[] m_params;

		public float[] m_precomps;
	}

	[SerializeField]
	private UniSplineType m_type;

	[SerializeField]
	private List<Vector3> m_points = new List<Vector3>();

	[SerializeField]
	private UniSplineSegment[] m_segments;

	[SerializeField]
	private float m_bias;

	[SerializeField]
	private float m_tension;

	[SerializeField]
	private float m_continuity;

	[SerializeField]
	private float m_precompdiv = 1f;

	public UniSplineType SplineType
	{
		get
		{
			return m_type;
		}
		set
		{
			m_type = value;
		}
	}

	public float Bias
	{
		get
		{
			return m_bias;
		}
		set
		{
			if (value < -1f)
			{
				m_bias = -1f;
			}
			else if (value > 1f)
			{
				m_bias = 1f;
			}
			else
			{
				m_bias = value;
			}
		}
	}

	public float Continuity
	{
		get
		{
			return m_continuity;
		}
		set
		{
			if (value < -1f)
			{
				m_continuity = -1f;
			}
			else if (value > 1f)
			{
				m_continuity = 1f;
			}
			else
			{
				m_continuity = value;
			}
		}
	}

	public float Tension
	{
		get
		{
			return m_tension;
		}
		set
		{
			if (value < -1f)
			{
				m_tension = -1f;
			}
			else if (value > 1f)
			{
				m_tension = 1f;
			}
			else
			{
				m_tension = value;
			}
		}
	}

	public void AppendPoint(Vector3 pos)
	{
		m_points.Add(pos);
	}

	public void RemoveLastPoint()
	{
		m_points.RemoveAt(m_points.Count - 1);
	}

	public void RemoveAllPoints()
	{
		m_points.Clear();
	}

	public void ReversePoints()
	{
		m_points.Reverse();
	}

	public void InsertPoint(int idx, Vector3 pos)
	{
		if (idx < 0 || idx > m_points.Count)
		{
			throw new IndexOutOfRangeException();
		}
		m_points.Insert(idx, pos);
	}

	public override void Build()
	{
		Vector3 zero = Vector3.zero;
		Vector3 zero2 = Vector3.zero;
		Vector3 zero3 = Vector3.zero;
		Vector3 zero4 = Vector3.zero;
		if (m_points.Count < 2)
		{
			m_segments = null;
			m_length = 0f;
			return;
		}
		int num = ((m_wrapmode != SplineWrapMode.Loop) ? (m_points.Count - 1) : m_points.Count);
		m_segments = new UniSplineSegment[num];
		m_length = 0f;
		int i = 0;
		if (m_wrapmode == SplineWrapMode.Loop)
		{
			for (; i < num; i++)
			{
				zero = m_points[SplineUtil.WrapIndex(i, m_points.Count)];
				zero2 = m_points[SplineUtil.WrapIndex(i - 1, m_points.Count)];
				zero3 = m_points[SplineUtil.WrapIndex(i + 2, m_points.Count)];
				zero4 = m_points[SplineUtil.WrapIndex(i + 1, m_points.Count)];
				m_segments[i] = new UniSplineSegment();
				BuildSegment(m_segments[i], zero, zero2, zero3, zero4);
			}
		}
		else
		{
			for (; i < num; i++)
			{
				zero = m_points[SplineUtil.ClampIndex(i, m_points.Count)];
				zero2 = m_points[SplineUtil.ClampIndex(i - 1, m_points.Count)];
				zero3 = m_points[SplineUtil.ClampIndex(i + 2, m_points.Count)];
				zero4 = m_points[SplineUtil.ClampIndex(i + 1, m_points.Count)];
				m_segments[i] = new UniSplineSegment();
				BuildSegment(m_segments[i], zero, zero2, zero3, zero4);
			}
		}
		m_buildnum++;
	}

	private void BuildSegment(UniSplineSegment ss, Vector3 sp, Vector3 sc, Vector3 ec, Vector3 ep)
	{
		ss.m_startpos = sp;
		ss.m_endpos = ep;
		switch (m_type)
		{
		case UniSplineType.CatmullRom:
			ss.m_startctrl = sc;
			ss.m_endctrl = ec;
			break;
		case UniSplineType.Hermite:
		{
			float num5 = (1f - m_tension) * 0.5f;
			float num6 = (1f + m_bias) * num5;
			float num7 = (1f - m_bias) * num5;
			ss.m_startctrl = (sp - sc) * num6 + (ep - sp) * num7;
			ss.m_endctrl = (ep - sp) * num6 + (ec - ep) * num7;
			break;
		}
		case UniSplineType.KochanekBartels:
		{
			float num = (1f - m_tension) * (1f + m_bias) * (1f + m_continuity) * 0.5f;
			float num2 = (1f - m_tension) * (1f - m_bias) * (1f - m_continuity) * 0.5f;
			float num3 = (1f - m_tension) * (1f + m_bias) * (1f - m_continuity) * 0.5f;
			float num4 = (1f - m_tension) * (1f - m_bias) * (1f + m_continuity) * 0.5f;
			ss.m_startctrl = num * (sp - sc) + num2 * (ep - sp);
			ss.m_endctrl = num3 * (ep - sp) + num4 * (ec - ep);
			break;
		}
		}
		ss.m_startlen = m_length;
		float length = GetLength(ss);
		m_length += length;
		ss.m_length = length;
		ss.m_endlen = m_length;
		switch (m_reparam)
		{
		case SplineReparamType.None:
			ss.m_params = null;
			ss.m_precomps = null;
			break;
		case SplineReparamType.Simple:
		{
			m_precompdiv = 1f / (float)m_stepcount;
			float num10 = 0f;
			float num11 = 0f;
			ss.m_params = new float[m_stepcount + 1];
			ss.m_precomps = new float[m_stepcount + 1];
			for (int j = 1; j < m_stepcount + 1; j++)
			{
				Vector3 position = GetPosition(ss, num10);
				num10 += m_precompdiv;
				Vector3 position2 = GetPosition(ss, num10);
				num11 += (position2 - position).magnitude;
				ss.m_precomps[j] = num11 / length;
				ss.m_params[j] = num10;
			}
			ss.m_params[0] = 0f;
			ss.m_params[m_stepcount] = 1f;
			ss.m_precomps[0] = 0f;
			ss.m_precomps[m_stepcount] = 1f;
			m_precompdiv = 1f / (float)m_stepcount;
			break;
		}
		case SplineReparamType.RungeKutta:
		{
			float num8 = length / (float)m_stepcount;
			float num9 = 0f;
			ss.m_params = new float[m_stepcount + 1];
			ss.m_precomps = new float[m_stepcount + 1];
			for (int i = 0; i < m_stepcount + 1; i++)
			{
				ss.m_params[i] = GetReparamRungeKutta(ss, num9);
				ss.m_precomps[i] = num9 / length;
				num9 += num8;
			}
			ss.m_params[0] = 0f;
			ss.m_params[m_stepcount] = 1f;
			ss.m_precomps[0] = 0f;
			ss.m_precomps[m_stepcount] = 1f;
			m_precompdiv = 1f / (float)m_stepcount;
			break;
		}
		}
	}

	private float GetLength(UniSplineSegment ss)
	{
		float num = 0f;
		float num2 = 0f;
		float num3 = 1f / (float)m_stepcount;
		int i = 0;
		Vector3 vector = ss.m_startpos;
		for (; i < m_stepcount; i++)
		{
			num2 += num3;
			Vector3 position = GetPosition(ss, num2);
			num += (position - vector).magnitude;
			vector = position;
		}
		return num;
	}

	private Vector3 GetPosition(UniSplineSegment ss, float t)
	{
		switch (m_type)
		{
		case UniSplineType.CatmullRom:
		{
			float num5 = t * t;
			float num6 = num5 * t;
			return ss.m_startpos * (1.5f * num6 - 2.5f * num5 + 1f) + ss.m_startctrl * (-0.5f * num6 + num5 - 0.5f * t) + ss.m_endctrl * (0.5f * num6 - 0.5f * num5) + ss.m_endpos * (-1.5f * num6 + 2f * num5 + 0.5f * t);
		}
		case UniSplineType.Hermite:
		{
			float num3 = t * t;
			float num4 = num3 * t;
			return ss.m_startpos * (2f * num4 - 3f * num3 + 1f) + ss.m_startctrl * (num4 - 2f * num3 + t) + ss.m_endctrl * (num4 - num3) + ss.m_endpos * (-2f * num4 + 3f * num3);
		}
		case UniSplineType.KochanekBartels:
		{
			float num = t * t;
			float num2 = num * t;
			return ss.m_startpos * (2f * num2 - 3f * num + 1f) + ss.m_startctrl * (num2 - 2f * num + t) + ss.m_endctrl * (num2 - num) + ss.m_endpos * (-2f * num2 + 3f * num);
		}
		default:
			return Vector3.zero;
		}
	}

	private Vector3 GetTangent(UniSplineSegment ss, float t)
	{
		switch (m_type)
		{
		case UniSplineType.CatmullRom:
		{
			float num3 = t * t;
			return ss.m_startpos * (4.5f * t - 5f) * t + ss.m_startctrl * (-1.5f * num3 + 2f * t - 0.5f) + ss.m_endctrl * (1.5f * t - 1f) * t + ss.m_endpos * (-4.5f * num3 + 4f * t + 0.5f);
		}
		case UniSplineType.Hermite:
		{
			float num2 = t * t;
			return ss.m_startpos * (6f * num2 - 6f * t) + ss.m_startctrl * (3f * num2 - 4f * t + 1f) + ss.m_endctrl * (3f * num2 - 2f * t) + ss.m_endpos * (-6f * num2 + 6f * t);
		}
		case UniSplineType.KochanekBartels:
		{
			float num = t * t;
			return ss.m_startpos * (6f * num - 6f * t) + ss.m_startctrl * (3f * num - 4f * t + 1f) + ss.m_endctrl * (3f * num - 2f * t) + ss.m_endpos * (-6f * num + 6f * t);
		}
		default:
			return Vector3.zero;
		}
	}

	private Vector3 GetNormal(UniSplineSegment ss, float t)
	{
		return m_type switch
		{
			UniSplineType.CatmullRom => ss.m_startpos * (9f * t - 5f) - ss.m_startctrl * (2f - 3f * t) + 9f * ss.m_endpos * t + 3f * ss.m_endctrl * t + 4f * ss.m_endpos - ss.m_endctrl, 
			UniSplineType.Hermite => ss.m_startpos * (12f * t - 6f) + ss.m_startctrl * (6f * t - 4f) + ss.m_endctrl * (6f * t - 2f) + ss.m_endpos * (-12f * t + 6f), 
			UniSplineType.KochanekBartels => ss.m_startpos * (12f * t - 6f) + ss.m_startctrl * (6f * t - 4f) + ss.m_endctrl * (6f * t - 2f) + ss.m_endpos * (-12f * t + 6f), 
			_ => Vector3.zero, 
		};
	}

	private float GetReparamRungeKutta(UniSplineSegment ss, float u)
	{
		float num = 0f;
		float num2 = u / (float)m_stepcount;
		for (int i = 1; i <= m_stepcount; i++)
		{
			float magnitude = GetTangent(ss, num).magnitude;
			float num3;
			float num4;
			float num5;
			float num6;
			if (magnitude == 0f)
			{
				num3 = 0f;
				num4 = 0f;
				num5 = 0f;
				num6 = 0f;
			}
			else
			{
				num3 = num2 / GetTangent(ss, num).magnitude;
				num4 = num2 / GetTangent(ss, num + num3 * 0.5f).magnitude;
				num5 = num2 / GetTangent(ss, num + num4 * 0.5f).magnitude;
				num6 = num2 / GetTangent(ss, num + num5).magnitude;
			}
			num += (num3 + 2f * (num4 + num5) + num6) * (1f / 6f);
		}
		return num;
	}

	private float GetReparam(UniSplineSegment ss, float u)
	{
		if (u <= 0f)
		{
			return 0f;
		}
		if (u >= 1f)
		{
			return 1f;
		}
		switch (m_reparam)
		{
		case SplineReparamType.RungeKutta:
		{
			int num2 = (int)(u * (float)m_stepcount);
			float t2 = (u - ss.m_precomps[num2]) / m_precompdiv;
			return Mathf.Lerp(ss.m_params[num2], ss.m_params[num2 + 1], t2);
		}
		case SplineReparamType.Simple:
		{
			int num = 0;
			for (int i = 1; i < m_stepcount + 1; i++)
			{
				if (ss.m_precomps[i] > u)
				{
					num = i - 1;
					break;
				}
			}
			float t = (u - ss.m_precomps[num]) / (ss.m_precomps[num + 1] - ss.m_precomps[num]);
			return Mathf.Lerp(ss.m_params[num], ss.m_params[num + 1], t);
		}
		default:
			return 0f;
		}
	}

	public override int GetPointCount()
	{
		return m_points.Count;
	}

	public override int GetSegmentCount()
	{
		if (m_segments != null)
		{
			return m_segments.Length;
		}
		return 0;
	}

	protected override float GetSegmentLength(int segidx)
	{
		return m_segments[segidx].m_length;
	}

	protected override float GetSegmentStartLength(int segidx)
	{
		return m_segments[segidx].m_startlen;
	}

	protected override float GetSegmentEndLength(int segidx)
	{
		return m_segments[segidx].m_endlen;
	}

	protected override int FindSegment(float offset)
	{
		for (int i = 0; i < m_segments.Length; i++)
		{
			if (m_segments[i].m_startlen <= offset && m_segments[i].m_endlen > offset)
			{
				return i;
			}
		}
		return m_segments.Length - 1;
	}

	protected override Vector3 GetDrawPosition(int segidx, float t)
	{
		UniSplineSegment ss = m_segments[segidx];
		return GetPosition(ss, t);
	}

	protected override Vector3 GetPosition(int segidx, float segpos)
	{
		UniSplineSegment uniSplineSegment = m_segments[segidx];
		if (m_reparam == SplineReparamType.None)
		{
			return GetPosition(uniSplineSegment, segpos / uniSplineSegment.m_length);
		}
		return GetPosition(uniSplineSegment, GetReparam(uniSplineSegment, segpos / uniSplineSegment.m_length));
	}

	protected override Vector3 GetTangent(int segidx, float segpos)
	{
		UniSplineSegment uniSplineSegment = m_segments[segidx];
		if (m_reparam == SplineReparamType.None)
		{
			return GetTangent(uniSplineSegment, segpos / uniSplineSegment.m_length);
		}
		return GetTangent(uniSplineSegment, GetReparam(uniSplineSegment, segpos / uniSplineSegment.m_length));
	}

	protected override Vector3 GetNormal(int segidx, float segpos)
	{
		UniSplineSegment uniSplineSegment = m_segments[segidx];
		if (m_reparam == SplineReparamType.None)
		{
			return GetNormal(uniSplineSegment, segpos / uniSplineSegment.m_length);
		}
		return GetNormal(uniSplineSegment, GetReparam(uniSplineSegment, segpos / uniSplineSegment.m_length));
	}

	public EditHelper GetEditHelper()
	{
		return new EditHelper(this);
	}
}
public class UniSplineComponent : MonoBehaviour
{
	[SerializeField]
	private UniSpline m_spline = new UniSpline();

	private int m_buildnum = -1;

	private Vector3[] m_drawcache;

	public UniSpline Spline => m_spline;

	private void OnDrawGizmosSelected()
	{
		DrawGizmos(Color.red);
	}

	private void OnDrawGizmos()
	{
		DrawGizmos(Color.white);
	}

	public void DrawGizmos(Color color)
	{
		int buildNum = m_spline.BuildNum;
		if (m_spline.GetSegmentCount() <= 0)
		{
			return;
		}
		if (m_buildnum != buildNum)
		{
			m_drawcache = m_spline.GenerateDrawPoints(16);
			m_buildnum = buildNum;
		}
		if (m_drawcache == null)
		{
			return;
		}
		Gizmos.matrix = base.transform.localToWorldMatrix;
		Gizmos.color = color;
		Vector3 from = Vector3.zero;
		Vector3 zero = Vector3.zero;
		for (int i = 0; i < m_drawcache.Length; i++)
		{
			zero = m_drawcache[i];
			if (i != 0)
			{
				Gizmos.DrawLine(from, zero);
			}
			from = zero;
		}
	}
}
public class UniSplineTest : MonoBehaviour
{
	public UniSplineComponent m_spline;

	public float m_speed = 1f;

	public float m_curspeed;

	public float m_position;

	public Vector3 m_up = Vector3.up;

	public Ease.Easing m_easing;

	private BaseSpline.SplineIterator m_iter;

	private void Awake()
	{
		m_iter = m_spline.Spline.GetIterator();
		m_iter.SetTransform(m_spline.transform);
	}

	private void Update()
	{
		m_position += m_speed * Time.deltaTime;
		m_iter.SetOffset(Ease.EaseByType(m_easing, 0f, m_spline.Spline.Length, m_position / m_spline.Spline.Length));
		Vector3 position = base.transform.position;
		base.transform.position = m_iter.GetPosition();
		base.transform.rotation = Quaternion.LookRotation(m_iter.GetTangent(), m_up);
		m_curspeed = (base.transform.position - position).magnitude / Time.deltaTime;
	}
}
namespace Pvr_UnitySDKAPI.Achievement
{
	public sealed class AchievementCore
	{
		private static bool IsPlatformInitialized = true;

		public static bool LogMessages;

		public static bool IsInitialized()
		{
			return IsPlatformInitialized;
		}

		public static void Initialize()
		{
		}

		public static void RegisterNetwork()
		{
			Pvr_AchievementAPI.RegisterNetwork();
		}

		public static void UnRegisterNetwork()
		{
			Pvr_AchievementAPI.UnRegisterNetwork();
		}
	}
	public static class Achievements
	{
		public static Pvr_Request<Pvr_AchievementUpdate> Init()
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementUpdate>(Pvr_AchievementAPI.Init());
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementUpdate> AddCount(string name, long count)
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementUpdate>(Pvr_AchievementAPI.pvr_Achievements_AddCount(name, count));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementUpdate> AddFields(string name, string fields)
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementUpdate>(Pvr_AchievementAPI.pvr_Achievements_AddFields(name, fields));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementDefinitionList> GetAllDefinitions()
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementDefinitionList>(Pvr_AchievementAPI.pvr_Achievements_GetAllDefinitions());
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementProgressList> GetAllProgress()
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementProgressList>(Pvr_AchievementAPI.pvr_Achievements_GetAllProgress());
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementDefinitionList> GetDefinitionsByName(string[] names)
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementDefinitionList>(Pvr_AchievementAPI.pvr_Achievements_GetDefinitionsByName(names, (names != null) ? names.Length : 0));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementProgressList> GetProgressByName(string[] names)
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementProgressList>(Pvr_AchievementAPI.pvr_Achievements_GetProgressByName(names, (names != null) ? names.Length : 0));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementUpdate> Unlock(string name)
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementUpdate>(Pvr_AchievementAPI.pvr_Achievements_Unlock(name));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementDefinitionList> GetNextAchievementDefinitionListPage(Pvr_AchievementDefinitionList list)
		{
			if (!list.HasNextPage)
			{
				Debug.LogWarning("Platform.GetNextAchievementDefinitionListPage: List has no next page");
				return null;
			}
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementDefinitionList>(Pvr_AchievementAPI.pvr_HTTP_GetWithMessageType(list.NextUrl, Pvr_Message.MessageType.Achievements_GetNextAchievementDefinitionArrayPage));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementProgressList> GetNextAchievementProgressListPage(Pvr_AchievementProgressList list)
		{
			if (!list.HasNextPage)
			{
				Debug.LogWarning("Platform.GetNextAchievementProgressListPage: List has no next page");
				return null;
			}
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementProgressList>(Pvr_AchievementAPI.pvr_HTTP_GetWithMessageType(list.NextUrl, Pvr_Message.MessageType.Achievements_GetNextAchievementProgressArrayPage));
			}
			return null;
		}
	}
	public enum AchievementType
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("SIMPLE")]
		Simple,
		[Description("BITFIELD")]
		Bitfield,
		[Description("COUNT")]
		Count
	}
	public class Pvr_AchievementAPI
	{
		private static AndroidJavaClass achievementAPI = new AndroidJavaClass("com.pico.achievenment.AchievementAPI");

		private static AndroidJavaClass definitionArrayHandle = new AndroidJavaClass("com.picovr.achievement.utils.pvrAchievementDefinitionArrayHandle");

		private static AndroidJavaClass definitionHandle = new AndroidJavaClass("com.picovr.achievement.utils.pvrAchievementDefinitionHandle");

		private static AndroidJavaClass progressArrayHandle = new AndroidJavaClass("com.picovr.achievement.utils.pvrAchievementProgressArrayHandle");

		private static AndroidJavaClass progressHandle = new AndroidJavaClass("com.picovr.achievement.utils.pvrAchievementProgressHandle");

		private static AndroidJavaClass updateHandle = new AndroidJavaClass("com.picovr.achievement.utils.pvrAchievementUpdateHandle");

		private static AndroidJavaObject errorHandle = new AndroidJavaObject("com.picovr.achievement.utils.pvrAchievementErrorHandle");

		private static AndroidJavaObject unityInterface = new AndroidJavaObject("com.pico.loginpaysdk.UnityInterface");

		private static string openId;

		private static string accessToken;

		private static string appId = Pvr_UnitySDKPlatformSetting.Instance.appID;

		internal static long Init()
		{
			long num = 0L;
			AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
			AndroidJavaObject @static = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
			unityInterface.Call("init", @static);
			unityInterface.Call("authSSO");
			AndroidJavaClass androidJavaClass2 = new AndroidJavaClass("com.pico.loginpaysdk.utils.PicoAccessTokenKeeper");
			AndroidJavaObject androidJavaObject = androidJavaClass2.CallStatic<AndroidJavaObject>("readAccessToken", new object[1] { @static });
			accessToken = androidJavaObject.Call<string>("getAccessToken", new object[0]);
			openId = androidJavaObject.Call<string>("getOpenId", new object[0]);
			return achievementAPI.CallStatic<long>("init", new object[3] { accessToken, openId, @static });
		}

		internal static void RegisterNetwork()
		{
			AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
			AndroidJavaObject @static = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
			achievementAPI.CallStatic("registerNetwork", @static);
		}

		internal static void UnRegisterNetwork()
		{
			achievementAPI.CallStatic("unregisterNetwork");
		}

		internal static AndroidJavaObject PopMessage()
		{
			return achievementAPI.CallStatic<AndroidJavaObject>("pvr_PopMessage", new object[0]);
		}

		internal static string pvr_Error_GetMessage(AndroidJavaObject popMessage)
		{
			string empty = string.Empty;
			return errorHandle.CallStatic<string>("pvr_Error_GetMessage", new object[1] { popMessage });
		}

		internal static int pvr_Error_GetHttpCode(AndroidJavaObject popMessage)
		{
			int num = 0;
			return errorHandle.CallStatic<int>("pvr_Error_GetHttpCode", new object[1] { popMessage });
		}

		internal static int pvr_Error_GetCode(AndroidJavaObject popMessage)
		{
			int num = 0;
			return errorHandle.CallStatic<int>("pvr_Error_GetCode", new object[1] { popMessage });
		}

		internal static long pvr_Achievements_AddCount(string name, long count)
		{
			long num = 0L;
			return achievementAPI.CallStatic<long>("pvr_Achievements_AddCount", new object[3] { name, count, accessToken });
		}

		internal static long pvr_Achievements_AddFields(string name, string fields)
		{
			long num = 0L;
			return achievementAPI.CallStatic<long>("pvr_Achievements_AddFields", new object[3] { name, fields, accessToken });
		}

		internal static long pvr_Achievements_GetAllDefinitions()
		{
			long num = 0L;
			AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
			AndroidJavaObject @static = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
			return achievementAPI.CallStatic<long>("pvr_Achievements_GetAllDefinitions", new object[2] { appId, @static });
		}

		internal static long pvr_Achievements_GetAllProgress()
		{
			long num = 0L;
			return achievementAPI.CallStatic<long>("pvr_Achievements_GetAllProgress", new object[1] { accessToken });
		}

		internal static long pvr_Achievements_GetDefinitionsByName(string[] names, int v)
		{
			long num = 0L;
			AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
			AndroidJavaObject @static = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
			return achievementAPI.CallStatic<long>("pvr_Achievements_GetDefinitionsByName", new object[2] { names, @static });
		}

		internal static long pvr_Achievements_GetProgressByName(string[] names, int v)
		{
			long num = 0L;
			return achievementAPI.CallStatic<long>("pvr_Achievements_GetProgressByName", new object[2] { names, accessToken });
		}

		internal static long pvr_Achievements_Unlock(string name)
		{
			long num = 0L;
			return achievementAPI.CallStatic<long>("pvr_Achievements_Unlock", new object[2] { name, accessToken });
		}

		internal static long pvr_HTTP_GetWithMessageType(string nextUrl, Pvr_Message.MessageType messageType)
		{
			long result = 0L;
			switch (messageType)
			{
			case Pvr_Message.MessageType.Achievements_GetNextAchievementDefinitionArrayPage:
			{
				AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
				AndroidJavaObject @static = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
				result = achievementAPI.CallStatic<long>("pvr_Achievements_GetAllDefinitionsByUrl", new object[2] { nextUrl, @static });
				break;
			}
			case Pvr_Message.MessageType.Achievements_GetNextAchievementProgressArrayPage:
				result = achievementAPI.CallStatic<long>("pvr_Achievements_GetAllProgressByUrl", new object[1] { nextUrl });
				break;
			}
			return result;
		}

		internal static long pvr_Message_GetType(AndroidJavaObject popMessage)
		{
			long num = 0L;
			return popMessage.Call<AndroidJavaObject>("getHandleType", new object[0]).Call<long>("getIndex", new object[0]);
		}

		internal static bool pvr_Message_IsError(AndroidJavaObject popMessage)
		{
			return popMessage.Call<bool>("isMessage_IsError", new object[0]);
		}

		internal static long pvr_Message_GetRequestID(AndroidJavaObject popMessage)
		{
			long num = 0L;
			return popMessage.Call<long>("getId", new object[0]);
		}

		internal static string pvr_Message_GetString(AndroidJavaObject popMessage)
		{
			string empty = string.Empty;
			return popMessage.Call<string>("getContent", new object[0]);
		}

		internal static bool pvr_AchievementUpdate_GetJustUnlocked(AndroidJavaObject popMessage)
		{
			bool flag = true;
			return updateHandle.CallStatic<bool>("pvr_AchievementUpdate_GetJustUnlocked", new object[1] { popMessage });
		}

		internal static string pvr_AchievementUpdate_GetName(AndroidJavaObject popMessage)
		{
			string empty = string.Empty;
			return updateHandle.CallStatic<string>("pvr_AchievementUpdate_GetName", new object[1] { popMessage });
		}

		internal static int pvr_AchievementProgressArray_GetSize(AndroidJavaObject msg)
		{
			int num = 0;
			return progressArrayHandle.CallStatic<int>("pvr_AchievementProgressArray_GetSize", new object[1] { msg });
		}

		internal static AndroidJavaObject pvr_AchievementProgressArray_GetElement(AndroidJavaObject msg, int index)
		{
			return progressArrayHandle.CallStatic<AndroidJavaObject>("pvr_AchievementProgressArray_GetElement", new object[2] { msg, index });
		}

		internal static string pvr_AchievementProgressArray_GetNextUrl(AndroidJavaObject msg)
		{
			string empty = string.Empty;
			return progressArrayHandle.CallStatic<string>("pvr_AchievementProgressArray_GetNextUrl", new object[1] { msg });
		}

		internal static string pvr_AchievementProgress_GetBitfield(AndroidJavaObject msg)
		{
			string empty = string.Empty;
			return progressHandle.CallStatic<string>("pvr_AchievementProgress_GetBitfield", new object[1] { msg });
		}

		internal static long pvr_AchievementProgress_GetCount(AndroidJavaObject msg)
		{
			long num = 0L;
			return progressHandle.CallStatic<long>("pvr_AchievementProgress_GetCount", new object[1] { msg });
		}

		internal static bool pvr_AchievementProgress_GetIsUnlocked(AndroidJavaObject msg)
		{
			bool flag = true;
			return progressHandle.CallStatic<bool>("pvr_AchievementProgress_GetIsUnlocked", new object[1] { msg });
		}

		internal static string pvr_AchievementProgress_GetName(AndroidJavaObject msg)
		{
			string empty = string.Empty;
			return progressHandle.CallStatic<string>("pvr_AchievementProgress_GetName", new object[1] { msg });
		}

		internal static DateTime pvr_AchievementProgress_GetUnlockTime(AndroidJavaObject msg)
		{
			DateTime dateTime = new DateTime(1970, 1, 1, 0, 0, 0, 0);
			return DateTimeFromNative(progressHandle.CallStatic<long>("pvr_AchievementProgress_GetUnlockTime", new object[1] { msg }));
		}

		internal static DateTime DateTimeFromNative(long seconds_since_the_one_true_epoch)
		{
			return new DateTime(1970, 1, 1, 0, 0, 0, 0).AddSeconds(seconds_since_the_one_true_epoch).ToLocalTime();
		}

		internal static int pvr_AchievementDefinitionArray_GetSize(AndroidJavaObject msg)
		{
			int num = 0;
			return definitionArrayHandle.CallStatic<int>("pvr_AchievementDefinitionArray_GetSize", new object[1] { msg });
		}

		internal static AndroidJavaObject pvr_AchievementDefinitionArray_GetElement(AndroidJavaObject msg, int index)
		{
			return definitionArrayHandle.CallStatic<AndroidJavaObject>("pvr_AchievementDefinitionArray_GetElement", new object[2] { msg, index });
		}

		internal static string pvr_AchievementDefinitionArray_GetNextUrl(AndroidJavaObject msg)
		{
			string empty = string.Empty;
			return definitionArrayHandle.CallStatic<string>("pvr_AchievementDefinitionArray_GetNextUrl", new object[1] { msg });
		}

		internal static AchievementType pvr_AchievementDefinition_GetType(AndroidJavaObject msg)
		{
			AchievementType achievementType = AchievementType.Bitfield;
			AndroidJavaObject androidJavaObject = definitionHandle.CallStatic<AndroidJavaObject>("pvr_AchievementDefinition_GetType", new object[1] { msg });
			return (AchievementType)androidJavaObject.Call<int>("getIndex", new object[0]);
		}

		internal static string pvr_AchievementDefinition_GetName(AndroidJavaObject msg)
		{
			string empty = string.Empty;
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetName", new object[1] { msg });
		}

		internal static int pvr_AchievementDefinition_GetBitfieldLength(AndroidJavaObject msg)
		{
			int num = 0;
			return definitionHandle.CallStatic<int>("pvr_AchievementDefinition_GetBitfieldLength", new object[1] { msg });
		}

		internal static long pvr_AchievementDefinition_GetTarget(AndroidJavaObject msg)
		{
			long num = 0L;
			return definitionHandle.CallStatic<long>("pvr_AchievementDefinition_GetTarget", new object[1] { msg });
		}

		internal static string pvr_AchievementDefinition_GetTitle(AndroidJavaObject msg)
		{
			string empty = string.Empty;
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetTitle", new object[1] { msg });
		}

		internal static string pvr_AchievementDefinition_GetUnlockedDescription(AndroidJavaObject msg)
		{
			string empty = string.Empty;
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetUnlocked_description", new object[1] { msg });
		}

		internal static string pvr_AchievementDefinition_GetLockedIcon(AndroidJavaObject msg)
		{
			string empty = string.Empty;
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetLocked_image", new object[1] { msg });
		}

		internal static bool pvr_AchievementDefinition_GetIsSecrect(AndroidJavaObject msg)
		{
			bool flag = false;
			return definitionHandle.CallStatic<bool>("pvr_AchievementDefinition_GetIs_secret", new object[1] { msg });
		}

		internal static string pvr_AchievementDefinition_GetUnlockedIcon(AndroidJavaObject msg)
		{
			string empty = string.Empty;
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetUnlocked_image", new object[1] { msg });
		}

		internal static string pvr_AchievementDefinition_GetDescription(AndroidJavaObject msg)
		{
			string empty = string.Empty;
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetDescription", new object[1] { msg });
		}
	}
}
public class AchievementSample : MonoBehaviour
{
	public Text dataOutput;

	public InputField getDefinitionsByNameInputField;

	public InputField getProgressByNameInputField;

	public InputField unLockInputField;

	public InputField addCountInputField;

	public InputField addFieldsInputField;

	private void Start()
	{
		AchievementCore.RegisterNetwork();
	}

	private void OnDestroy()
	{
		AchievementCore.UnRegisterNetwork();
	}

	private void OnApplicationPause(bool pause)
	{
		if (!pause)
		{
			printOutputLine("Achievement Init");
			achievementInit();
		}
	}

	private void Update()
	{
		Request.RunCallbacks();
	}

	public void AsyncInitialize()
	{
		dataOutput.text = "> ";
		printOutputLine("AsyncInitialize");
		achievementInit();
	}

	public void GetDefinitionsByName()
	{
		dataOutput.text = "> ";
		printOutputLine("GetDefinitionsByName");
		string text = getDefinitionsByNameInputField.text;
		if (text != string.Empty)
		{
			string[] achievementNames = text.Split(',');
			getAchievementDefinition(achievementNames);
			getDefinitionsByNameInputField.text = string.Empty;
		}
		else
		{
			printOutputLine("Invalid Command");
		}
	}

	public void GetProgressByName()
	{
		dataOutput.text = "> ";
		printOutputLine("GetProgressByName");
		string text = getProgressByNameInputField.text;
		if (text != string.Empty)
		{
			string[] achievementNames = text.Split(',');
			getAchievementProgress(achievementNames);
			getProgressByNameInputField.text = string.Empty;
		}
		else
		{
			printOutputLine("Invalid Command");
		}
	}

	public void GetAllDefinitions()
	{
		dataOutput.text = "> ";
		printOutputLine("GetAllDefinitions");
		getAchievementAllDefinition();
	}

	public void GetAllProgress()
	{
		dataOutput.text = "> ";
		printOutputLine("GetAllProgress");
		getAchievementAllProgress();
	}

	public void UnLock()
	{
		dataOutput.text = "> ";
		printOutputLine("UnLock");
		string text = unLockInputField.text;
		if (text != string.Empty)
		{
			unlockAchievement(text);
			unLockInputField.text = string.Empty;
		}
		else
		{
			printOutputLine("Invalid Command");
		}
	}

	public void AddCount()
	{
		dataOutput.text = "> ";
		printOutputLine("AddCount");
		string text = addCountInputField.text;
		if (text != string.Empty)
		{
			string[] array = text.Split(',');
			if (array.Length > 1)
			{
				try
				{
					Convert.ToInt64(array[1]);
				}
				catch (Exception)
				{
					printOutputLine("Invalid Command");
					throw;
				}
				addCountAchievement(array[0], array[1]);
				addCountInputField.text = string.Empty;
			}
			else
			{
				printOutputLine("Invalid Command");
			}
		}
		else
		{
			printOutputLine("Invalid Command");
		}
	}

	public void AddFields()
	{
		dataOutput.text = "> ";
		printOutputLine("AddFields");
		string text = addFieldsInputField.text;
		if (text != string.Empty)
		{
			string[] array = text.Split(',');
			if (array.Length > 1)
			{
				addFieldsAchievement(array[0], array[1]);
				addFieldsInputField.text = string.Empty;
			}
			else
			{
				printOutputLine("Invalid Command");
			}
		}
		else
		{
			printOutputLine("Invalid Command");
		}
	}

	private void achievementInit()
	{
		Achievements.Init().OnComplete(initAchievementCallback);
	}

	private void getAchievementAllDefinition()
	{
		Achievements.GetAllDefinitions().OnComplete(achievementAllDefinitionCallback);
	}

	private void getAchievementAllProgress()
	{
		Achievements.GetAllProgress().OnComplete(achievementAllProgressCallback);
	}

	private void addFieldsAchievement(string achievementName, string fields)
	{
		Achievements.AddFields(achievementName, fields).OnComplete(achievementFieldsCallback);
	}

	private void addCountAchievement(string achievementName, string count)
	{
		Achievements.AddCount(achievementName, Convert.ToInt64(count)).OnComplete(achievementCountCallback);
	}

	private void unlockAchievement(string achievementName)
	{
		Achievements.Unlock(achievementName).OnComplete(achievementUnlockCallback);
	}

	private void getAchievementProgress(string[] achievementNames)
	{
		Achievements.GetProgressByName(achievementNames).OnComplete(achievementProgressCallback);
	}

	private void getAchievementDefinition(string[] achievementNames)
	{
		Achievements.GetDefinitionsByName(achievementNames).OnComplete(achievementDefinitionCallback);
	}

	private void printOutputLine(string newLine)
	{
		dataOutput.text = "> " + newLine + Environment.NewLine + dataOutput.text;
	}

	private void achievementAllDefinitionCallback(Pvr_Message<Pvr_AchievementDefinitionList> msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Received achievement definitions success");
			Pvr_AchievementDefinitionList achievementDefinitions = msg.GetAchievementDefinitions();
			if (achievementDefinitions.HasNextPage)
			{
				Achievements.GetNextAchievementDefinitionListPage(achievementDefinitions).OnComplete(achievementAllDefinitionCallback);
			}
			{
				foreach (Pvr_AchievementDefinition item in achievementDefinitions)
				{
					printOutputLine("Bitfield Name: " + item.Name.ToString());
					switch (item.Type)
					{
					case AchievementType.Simple:
						printOutputLine("Achievement Type: Simple");
						break;
					case AchievementType.Bitfield:
						printOutputLine("Achievement Type: Bitfield");
						printOutputLine("Bitfield Length: " + item.BitfieldLength);
						printOutputLine("Target: " + item.Target);
						break;
					case AchievementType.Count:
						printOutputLine("Achievement Type: Count");
						printOutputLine("Target: " + item.Target);
						break;
					default:
						printOutputLine("Achievement Type: Unknown");
						break;
					}
					printOutputLine("Bitfield Title: " + item.Title.ToString());
					printOutputLine("Bitfield Description: " + item.Description.ToString());
					printOutputLine("Bitfield UnlockedDescription: " + item.UnlockedDescription.ToString());
					printOutputLine("Bitfield UnlockedIcon: " + item.UnlockedIcon.ToString());
					printOutputLine("Bitfield LockedIcon: " + item.LockedIcon.ToString());
					printOutputLine("Bitfield IsSecrect: " + item.IsSecrect);
				}
				return;
			}
		}
		printOutputLine("Received achievement definitions error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementAllProgressCallback(Pvr_Message<Pvr_AchievementProgressList> msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Received achievement progress success");
			Pvr_AchievementProgressList achievementProgressList = msg.GetAchievementProgressList();
			if (achievementProgressList.HasNextPage)
			{
				Achievements.GetNextAchievementProgressListPage(achievementProgressList).OnComplete(achievementAllProgressCallback);
			}
			{
				foreach (Pvr_AchievementProgress item in achievementProgressList)
				{
					printOutputLine("Current Name: " + item.Name.ToString());
					if (item.IsUnlocked)
					{
						printOutputLine("Achievement Unlocked");
					}
					else
					{
						printOutputLine("Achievement Locked");
					}
					printOutputLine("Current Bitfield: " + item.Bitfield.ToString());
					printOutputLine("Current Count: " + item.Count);
					printOutputLine("Current UnlockTime: " + item.UnlockTime.ToString());
				}
				return;
			}
		}
		printOutputLine("Received achievement progress error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementFieldsCallback(Pvr_Message msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Achievement fields added.");
			return;
		}
		printOutputLine("Received achievement fields add error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementCountCallback(Pvr_Message msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Achievement count added.");
			return;
		}
		printOutputLine("Received achievement count add error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementUnlockCallback(Pvr_Message msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Achievement unlocked");
			return;
		}
		printOutputLine("Received achievement unlock error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementProgressCallback(Pvr_Message<Pvr_AchievementProgressList> msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Received achievement progress success");
			Pvr_AchievementProgressList achievementProgressList = msg.GetAchievementProgressList();
			{
				foreach (Pvr_AchievementProgress item in achievementProgressList)
				{
					if (item.IsUnlocked)
					{
						printOutputLine("Achievement Unlocked");
					}
					else
					{
						printOutputLine("Achievement Locked");
					}
					printOutputLine("Current Bitfield: " + item.Bitfield.ToString());
					printOutputLine("Current Count: " + item.Count);
				}
				return;
			}
		}
		printOutputLine("Received achievement progress error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementDefinitionCallback(Pvr_Message<Pvr_AchievementDefinitionList> msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Received achievement definitions success");
			Pvr_AchievementDefinitionList achievementDefinitions = msg.GetAchievementDefinitions();
			{
				foreach (Pvr_AchievementDefinition item in achievementDefinitions)
				{
					switch (item.Type)
					{
					case AchievementType.Simple:
						printOutputLine("Achievement Type: Simple");
						break;
					case AchievementType.Bitfield:
						printOutputLine("Achievement Type: Bitfield");
						printOutputLine("Bitfield Length: " + item.BitfieldLength);
						printOutputLine("Target: " + item.Target);
						break;
					case AchievementType.Count:
						printOutputLine("Achievement Type: Count");
						printOutputLine("Target: " + item.Target);
						break;
					default:
						printOutputLine("Achievement Type: Unknown");
						break;
					}
				}
				return;
			}
		}
		printOutputLine("Received achievement definitions error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void initAchievementCallback(Pvr_Message msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Received init success");
			return;
		}
		printOutputLine("Received init error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void LoginCallback(string LoginInfo)
	{
		Debug.Log("Received loginCallback:" + LoginInfo);
		printOutputLine("Received loginCallback: " + LoginInfo);
	}
}
namespace Pvr_UnitySDKAPI.Achievement
{
	public class Pvr_AchievementDefinition
	{
		public readonly AchievementType Type;

		public readonly string Name;

		public readonly int BitfieldLength;

		public readonly long Target;

		public readonly string Title;

		public readonly string Description;

		public readonly string UnlockedDescription;

		public readonly string UnlockedIcon;

		public readonly string LockedIcon;

		public readonly bool IsSecrect;

		public Pvr_AchievementDefinition(AndroidJavaObject msg)
		{
			Type = Pvr_AchievementAPI.pvr_AchievementDefinition_GetType(msg);
			Name = Pvr_AchievementAPI.pvr_AchievementDefinition_GetName(msg);
			BitfieldLength = Pvr_AchievementAPI.pvr_AchievementDefinition_GetBitfieldLength(msg);
			Target = Pvr_AchievementAPI.pvr_AchievementDefinition_GetTarget(msg);
			Title = Pvr_AchievementAPI.pvr_AchievementDefinition_GetTitle(msg);
			Description = Pvr_AchievementAPI.pvr_AchievementDefinition_GetDescription(msg);
			UnlockedDescription = Pvr_AchievementAPI.pvr_AchievementDefinition_GetUnlockedDescription(msg);
			UnlockedIcon = Pvr_AchievementAPI.pvr_AchievementDefinition_GetUnlockedIcon(msg);
			LockedIcon = Pvr_AchievementAPI.pvr_AchievementDefinition_GetLockedIcon(msg);
			IsSecrect = Pvr_AchievementAPI.pvr_AchievementDefinition_GetIsSecrect(msg);
		}
	}
	public class Pvr_AchievementDefinitionList : Pvr_DeserializableList<Pvr_AchievementDefinition>
	{
		public Pvr_AchievementDefinitionList(AndroidJavaObject msg)
		{
			int num = Pvr_AchievementAPI.pvr_AchievementDefinitionArray_GetSize(msg);
			data = new List<Pvr_AchievementDefinition>(num);
			for (int i = 0; i < num; i++)
			{
				data.Add(new Pvr_AchievementDefinition(Pvr_AchievementAPI.pvr_AchievementDefinitionArray_GetElement(msg, i)));
			}
			nextUrl = Pvr_AchievementAPI.pvr_AchievementDefinitionArray_GetNextUrl(msg);
		}
	}
	public class Pvr_AchievementProgress
	{
		public readonly string Bitfield;

		public readonly long Count;

		public readonly bool IsUnlocked;

		public readonly string Name;

		public readonly DateTime UnlockTime;

		public Pvr_AchievementProgress(AndroidJavaObject msg)
		{
			Bitfield = Pvr_AchievementAPI.pvr_AchievementProgress_GetBitfield(msg);
			Count = Pvr_AchievementAPI.pvr_AchievementProgress_GetCount(msg);
			IsUnlocked = Pvr_AchievementAPI.pvr_AchievementProgress_GetIsUnlocked(msg);
			Name = Pvr_AchievementAPI.pvr_AchievementProgress_GetName(msg);
			UnlockTime = Pvr_AchievementAPI.pvr_AchievementProgress_GetUnlockTime(msg);
		}
	}
	public class Pvr_AchievementProgressList : Pvr_DeserializableList<Pvr_AchievementProgress>
	{
		public Pvr_AchievementProgressList(AndroidJavaObject msg)
		{
			int num = Pvr_AchievementAPI.pvr_AchievementProgressArray_GetSize(msg);
			data = new List<Pvr_AchievementProgress>(num);
			for (int i = 0; i < num; i++)
			{
				data.Add(new Pvr_AchievementProgress(Pvr_AchievementAPI.pvr_AchievementProgressArray_GetElement(msg, i)));
			}
			nextUrl = Pvr_AchievementAPI.pvr_AchievementProgressArray_GetNextUrl(msg);
		}
	}
	public class Pvr_AchievementUpdate
	{
		public readonly bool JustUnlocked;

		public readonly string Name;

		public Pvr_AchievementUpdate(AndroidJavaObject msg)
		{
			JustUnlocked = Pvr_AchievementAPI.pvr_AchievementUpdate_GetJustUnlocked(msg);
			Name = Pvr_AchievementAPI.pvr_AchievementUpdate_GetName(msg);
		}
	}
	public class Pvr_DeserializableList<T> : IList<T>, ICollection<T>, IEnumerable<T>, IEnumerable
	{
		protected List<T> data;

		protected string nextUrl;

		protected string previousUrl;

		bool ICollection<T>.IsReadOnly => ((ICollection<T>)data).IsReadOnly;

		public int Count => data.Count;

		public T this[int index]
		{
			get
			{
				return data[index];
			}
			set
			{
				data[index] = value;
			}
		}

		public bool HasNextPage => !string.IsNullOrEmpty(NextUrl);

		public bool HasPreviousPage => !string.IsNullOrEmpty(PreviousUrl);

		public string NextUrl => nextUrl;

		public string PreviousUrl => previousUrl;

		public int IndexOf(T obj)
		{
			return data.IndexOf(obj);
		}

		public void Add(T item)
		{
			data.Add(item);
		}

		public void Clear()
		{
			data.Clear();
		}

		public bool Contains(T item)
		{
			return data.Contains(item);
		}

		public void CopyTo(T[] array, int arrayIndex)
		{
			data.CopyTo(array, arrayIndex);
		}

		public IEnumerator<T> GetEnumerator()
		{
			return data.GetEnumerator();
		}

		public void Insert(int index, T item)
		{
			data.Insert(index, item);
		}

		public bool Remove(T item)
		{
			return data.Remove(item);
		}

		public void RemoveAt(int index)
		{
			data.RemoveAt(index);
		}

		private IEnumerator GetEnumerator1()
		{
			return GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator1();
		}
	}
	public static class Pvr_Callback
	{
		private class RequestCallback
		{
			private Pvr_Message.Callback messageCallback;

			public RequestCallback()
			{
			}

			public RequestCallback(Pvr_Message.Callback callback)
			{
				messageCallback = callback;
			}

			public virtual void HandleMessage(Pvr_Message msg)
			{
				if (messageCallback != null)
				{
					messageCallback(msg);
				}
			}
		}

		private sealed class RequestCallback<T> : RequestCallback
		{
			private Pvr_Message<T>.Callback callback;

			public RequestCallback(Pvr_Message<T>.Callback callback)
			{
				this.callback = callback;
			}

			public override void HandleMessage(Pvr_Message msg)
			{
				if (callback != null)
				{
					if (msg is Pvr_Message<T>)
					{
						callback((Pvr_Message<T>)msg);
					}
					else
					{
						Debug.LogError("Unable to handle message: " + msg.GetType());
					}
				}
			}
		}

		private static Dictionary<long, Request> requestIDsToRequests = new Dictionary<long, Request>();

		private static Dictionary<Pvr_Message.MessageType, RequestCallback> notificationCallbacks = new Dictionary<Pvr_Message.MessageType, RequestCallback>();

		internal static void AddRequest(Request request)
		{
			if (request.RequestID <= 2)
			{
				long requestID = request.RequestID;
				if (requestID >= 0 && requestID <= 2)
				{
					switch (requestID)
					{
					case 0L:
						Debug.LogError("An PARAM_INVALIDE error occurred. Request failed.");
						return;
					case 1L:
						Debug.LogError("An NETWORK_INVALIDE error occurred. Request failed.");
						return;
					case 2L:
						Debug.LogError("An NOT_INTIALIZE error occurred. Request failed.");
						return;
					}
				}
				Debug.LogError("An unknown error occurred. Request failed.");
			}
			else
			{
				requestIDsToRequests[request.RequestID] = request;
			}
		}

		internal static void RunCallbacks()
		{
			while (true)
			{
				Pvr_Message pvr_Message = Pvr_Message.PopMessage();
				if (pvr_Message == null)
				{
					break;
				}
				HandleMessage(pvr_Message);
			}
		}

		internal static void RunLimitedCallbacks(uint limit)
		{
			for (int i = 0; i < limit; i++)
			{
				Pvr_Message pvr_Message = Pvr_Message.PopMessage();
				if (pvr_Message == null)
				{
					break;
				}
				HandleMessage(pvr_Message);
			}
		}

		internal static void OnApplicationQuit()
		{
			requestIDsToRequests.Clear();
			notificationCallbacks.Clear();
		}

		internal static void HandleMessage(Pvr_Message msg)
		{
			if (msg.RequestID != 0 && requestIDsToRequests.TryGetValue(msg.RequestID, out var value))
			{
				try
				{
					value.HandleMessage(msg);
					return;
				}
				finally
				{
					requestIDsToRequests.Remove(msg.RequestID);
				}
			}
			if (notificationCallbacks.TryGetValue(msg.Type, out var value2))
			{
				value2.HandleMessage(msg);
			}
		}
	}
	public class Pvr_CallbackRunner : MonoBehaviour
	{
		public bool IsPersistantBetweenSceneLoads = true;

		private void Awake()
		{
			Pvr_CallbackRunner pvr_CallbackRunner = UnityEngine.Object.FindObjectOfType<Pvr_CallbackRunner>();
			if (pvr_CallbackRunner != this)
			{
				Debug.LogWarning("You only need one instance of CallbackRunner");
			}
			if (IsPersistantBetweenSceneLoads)
			{
				UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
			}
		}

		private void Update()
		{
			Request.RunCallbacks();
		}

		private void OnApplicationQuit()
		{
			Pvr_Callback.OnApplicationQuit();
		}
	}
	public abstract class Pvr_Message<T> : Pvr_Message
	{
		public new delegate void Callback(Pvr_Message<T> message);

		private T data;

		public T Data => data;

		public Pvr_Message(AndroidJavaObject msg)
			: base(msg)
		{
			if (!base.IsError)
			{
				data = GetDataFromMessage(msg);
			}
		}

		protected abstract T GetDataFromMessage(AndroidJavaObject msg);
	}
	public class Pvr_Message
	{
		public delegate void Callback(Pvr_Message message);

		public enum MessageType : uint
		{
			Unknown = 0u,
			Achievements_AddCount = 65495601u,
			Achievements_AddFields = 346693929u,
			Achievements_GetAllDefinitions = 64177549u,
			Achievements_GetAllProgress = 1335877149u,
			Achievements_GetDefinitionsByName = 1653670332u,
			Achievements_GetNextAchievementDefinitionArrayPage = 712888917u,
			Achievements_GetNextAchievementProgressArrayPage = 792913703u,
			Achievements_GetProgressByName = 354837425u,
			Achievements_Unlock = 1497156573u,
			Achievements_WriteAchievementProgress = 121027549u,
			Achievements_VerifyAccessToken = 53284924u
		}

		internal delegate Pvr_Message ExtraMessageTypesHandler(AndroidJavaObject messageHandle, MessageType message_type);

		private MessageType type;

		private long requestID;

		private Error error;

		public MessageType Type => type;

		public bool IsError => error != null;

		public long RequestID => requestID;

		internal static ExtraMessageTypesHandler HandleExtraMessageTypes { private get; set; }

		public Pvr_Message(AndroidJavaObject msg)
		{
			type = (MessageType)Pvr_AchievementAPI.pvr_Message_GetType(msg);
			bool flag = Pvr_AchievementAPI.pvr_Message_IsError(msg);
			requestID = Pvr_AchievementAPI.pvr_Message_GetRequestID(msg);
			if (flag)
			{
				error = new Error(Pvr_AchievementAPI.pvr_Error_GetCode(msg), Pvr_AchievementAPI.pvr_Error_GetMessage(msg), Pvr_AchievementAPI.pvr_Error_GetHttpCode(msg));
			}
			else if (AchievementCore.LogMessages)
			{
				string text = Pvr_AchievementAPI.pvr_Message_GetString(msg);
				if (text != null)
				{
					Debug.Log(text);
				}
				else
				{
					Debug.Log($"null message string {msg}");
				}
			}
		}

		public virtual Error GetError()
		{
			return error;
		}

		public virtual Pvr_AchievementDefinitionList GetAchievementDefinitions()
		{
			return null;
		}

		public virtual Pvr_AchievementProgressList GetAchievementProgressList()
		{
			return null;
		}

		public virtual Pvr_AchievementUpdate GetAchievementUpdate()
		{
			return null;
		}

		public virtual string GetString()
		{
			return null;
		}

		internal static Pvr_Message ParseMessageHandle(AndroidJavaObject messageHandle)
		{
			if (messageHandle == null)
			{
				return null;
			}
			Pvr_Message result = null;
			switch ((MessageType)Pvr_AchievementAPI.pvr_Message_GetType(messageHandle))
			{
			case MessageType.Achievements_GetAllDefinitions:
			case MessageType.Achievements_GetNextAchievementDefinitionArrayPage:
			case MessageType.Achievements_GetDefinitionsByName:
				result = new MessageWithAchievementDefinitions(messageHandle);
				break;
			case MessageType.Achievements_GetProgressByName:
			case MessageType.Achievements_GetNextAchievementProgressArrayPage:
			case MessageType.Achievements_GetAllProgress:
				result = new MessageWithAchievementProgressList(messageHandle);
				break;
			case MessageType.Achievements_VerifyAccessToken:
			case MessageType.Achievements_AddCount:
			case MessageType.Achievements_AddFields:
			case MessageType.Achievements_Unlock:
				result = new MessageWithAchievementUpdate(messageHandle);
				break;
			}
			return result;
		}

		public static Pvr_Message PopMessage()
		{
			AndroidJavaObject messageHandle = Pvr_AchievementAPI.PopMessage();
			return ParseMessageHandle(messageHandle);
		}
	}
	public class MessageWithAchievementDefinitions : Pvr_Message<Pvr_AchievementDefinitionList>
	{
		public MessageWithAchievementDefinitions(AndroidJavaObject msg)
			: base(msg)
		{
		}

		public override Pvr_AchievementDefinitionList GetAchievementDefinitions()
		{
			return base.Data;
		}

		protected override Pvr_AchievementDefinitionList GetDataFromMessage(AndroidJavaObject msg)
		{
			return new Pvr_AchievementDefinitionList(msg);
		}
	}
	public class MessageWithAchievementProgressList : Pvr_Message<Pvr_AchievementProgressList>
	{
		public MessageWithAchievementProgressList(AndroidJavaObject msg)
			: base(msg)
		{
		}

		public override Pvr_AchievementProgressList GetAchievementProgressList()
		{
			return base.Data;
		}

		protected override Pvr_AchievementProgressList GetDataFromMessage(AndroidJavaObject msg)
		{
			return new Pvr_AchievementProgressList(msg);
		}
	}
	public class MessageWithAchievementUpdate : Pvr_Message<Pvr_AchievementUpdate>
	{
		public MessageWithAchievementUpdate(AndroidJavaObject msg)
			: base(msg)
		{
		}

		public override Pvr_AchievementUpdate GetAchievementUpdate()
		{
			return base.Data;
		}

		protected override Pvr_AchievementUpdate GetDataFromMessage(AndroidJavaObject msg)
		{
			return new Pvr_AchievementUpdate(msg);
		}
	}
	public class MessageWithString : Pvr_Message<string>
	{
		public MessageWithString(AndroidJavaObject msg)
			: base(msg)
		{
		}

		public override string GetString()
		{
			return base.Data;
		}

		protected override string GetDataFromMessage(AndroidJavaObject msg)
		{
			return Pvr_AchievementAPI.pvr_Message_GetString(msg);
		}
	}
	public class Error
	{
		public readonly int Code;

		public readonly int HttpCode;

		public readonly string Message;

		public Error(int code, string message, int httpCode)
		{
			Message = message;
			Code = code;
			HttpCode = httpCode;
		}
	}
	public sealed class Pvr_Request<T> : Request
	{
		private Pvr_Message<T>.Callback callback_;

		public Pvr_Request(long requestID)
			: base(requestID)
		{
		}

		public Pvr_Request<T> OnComplete(Pvr_Message<T>.Callback callback)
		{
			if (callback_ != null)
			{
				throw new UnityException("Attempted to attach multiple handlers to a Request.  This is not allowed.");
			}
			callback_ = callback;
			Pvr_Callback.AddRequest(this);
			return this;
		}

		public override void HandleMessage(Pvr_Message msg)
		{
			if (!(msg is Pvr_Message<T>))
			{
				Debug.LogError("Unable to handle message: " + msg.GetType());
				return;
			}
			if (callback_ != null)
			{
				callback_((Pvr_Message<T>)msg);
				return;
			}
			throw new UnityException("Request with no handler.  This should never happen.");
		}
	}
	public class Request
	{
		private Pvr_Message.Callback callback_;

		public long RequestID { get; set; }

		public Request(long requestID)
		{
			RequestID = requestID;
		}

		public Request OnComplete(Pvr_Message.Callback callback)
		{
			callback_ = callback;
			Pvr_Callback.AddRequest(this);
			return this;
		}

		public virtual void HandleMessage(Pvr_Message msg)
		{
			if (callback_ != null)
			{
				callback_(msg);
				return;
			}
			throw new UnityException("Request with no handler.  This should never happen.");
		}

		public static void RunCallbacks(uint limit = 0u)
		{
			if (limit == 0)
			{
				Pvr_Callback.RunCallbacks();
			}
			else
			{
				Pvr_Callback.RunLimitedCallbacks(limit);
			}
		}
	}
}
namespace BoundarySystem_Ext
{
	internal static class Pvr_BoundaryAPI
	{
		private const string LibFileName = "Pvr_UnitySDK";

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_StartSDKBoundary();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_ShutdownSDKBoundary();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetMainSensorStateExt(ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz, ref float vfov, ref float hfov, ref int viewNumber);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr Pvr_GetCameraData_Ext();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_ResetVrModebyForce();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_ResumeBoundaryForSTS();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_PauseBoundaryForSTS();

		public static int UPvr_GetMainSensorStateExt(ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz, ref float vfov, ref float hfov, ref int viewNumber)
		{
			return Pvr_GetMainSensorStateExt(ref x, ref y, ref z, ref w, ref px, ref py, ref pz, ref vfov, ref hfov, ref viewNumber);
		}

		public static IntPtr UPvr_GetCameraData_Ext()
		{
			IntPtr zero = IntPtr.Zero;
			return Pvr_GetCameraData_Ext();
		}

		public static bool UPvr_ResumeBoundaryForSTS()
		{
			bool flag = false;
			return Pvr_ResumeBoundaryForSTS();
		}

		public static void UPvr_PauseBoundaryForSTS()
		{
			Pvr_PauseBoundaryForSTS();
		}

		public static IntPtr StructToIntPtr<T>(T info)
		{
			int cb = Marshal.SizeOf(info);
			IntPtr intPtr = Marshal.AllocHGlobal(cb);
			Marshal.StructureToPtr(info, intPtr, fDeleteOld: true);
			return intPtr;
		}

		public static T IntPtrToStruct<T>(IntPtr info)
		{
			return (T)Marshal.PtrToStructure(info, typeof(T));
		}
	}
	internal static class Pvr_SafeAreaAlgoAPI
	{
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		public delegate void SafeAreaCallback(IntPtr lineCollectionPtr, IntPtr safeAreaRectPtr);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		public delegate void SafeAreaCallbackShrink(IntPtr lineCollectionPtr, IntPtr safeAreaDetailRectPtr);

		public struct GSAPoint3i
		{
			public int x;

			public int y;

			public int z;
		}

		public struct GSALine
		{
			public IntPtr pointArray;

			public int pointCount;
		}

		public struct GSALineCollection
		{
			public IntPtr lineArray;

			public int lineCount;
		}

		public struct GSALegalData
		{
			public int overMaxRange;

			public int includeBigGrap;

			public int bigGapNum;

			public int centerOut;

			public int removeNarrow;

			public int overMaxRange_more;

			public int validShrinkArea;
		}

		public struct GSARect
		{
			public GSAPoint3i leftup;

			public GSAPoint3i leftdown;

			public GSAPoint3i rightup;

			public GSAPoint3i rightdown;

			public GSAPoint3i center;

			public uint width;

			public uint height;

			public int isLegal;

			public GSALegalData legalData;
		}

		private const string LibFileName = "SafetyArea";

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSAInit(int width, int height);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSAShutDown();

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSASetCallback(SafeAreaCallback cb);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSASetCallbackShrink(SafeAreaCallbackShrink cb);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSAUpDateData(IntPtr lineCollectionPtr);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSASetConfigFilePath(IntPtr configPath);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool GSAGetClosedAreaUpdateFlag();

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSALoadSafetyArea(IntPtr lineCollectionPtr);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern double GSABoundaryDetector(ref GSAPoint3i pointPtr);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSALoadSafetyArea2(IntPtr lineCollectionPtr, bool isPlayArea);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern double GSABoundaryDetector2(ref GSAPoint3i point, bool isPlayArea, ref GSAPoint3i closestPoint, ref GSAPoint3i normalDir);

		public static int Pvr_GSAInit(int width, int height)
		{
			int num = -1;
			return GSAInit(width, height);
		}

		public static int Pvr_GSASetCallback(SafeAreaCallback cb)
		{
			int num = -1;
			return GSASetCallback(cb);
		}

		public static int Pvr_GSASetCallbackShrink(SafeAreaCallbackShrink cb)
		{
			int num = -1;
			return GSASetCallbackShrink(cb);
		}

		public static int Pvr_GSAUpDateData(IntPtr lineCollectionPtr)
		{
			int num = -1;
			return GSAUpDateData(lineCollectionPtr);
		}

		public static bool Pvr_GSAGetClosedAreaUpdateFlag()
		{
			bool flag = false;
			return GSAGetClosedAreaUpdateFlag();
		}

		public static int Pvr_GSASetConfigFilePath(string configPath)
		{
			int num = -1;
			IntPtr intPtr = Marshal.StringToHGlobalAnsi(configPath);
			num = GSASetConfigFilePath(intPtr);
			Marshal.FreeHGlobal(intPtr);
			return num;
		}

		public static int Pvr_GSALoadSafetyArea(IntPtr lineCollectionPtr)
		{
			int num = -1;
			return GSALoadSafetyArea(lineCollectionPtr);
		}

		public static double Pvr_GSABoundaryDetector(ref GSAPoint3i point)
		{
			double num = 0.0;
			return GSABoundaryDetector(ref point);
		}

		public static int Pvr_GSAShutDown()
		{
			int num = -1;
			return GSAShutDown();
		}

		public static int Pvr_GSALoadSafetyArea2(IntPtr lineCollectionPtr, bool isPlayArea)
		{
			int num = -1;
			return GSALoadSafetyArea2(lineCollectionPtr, isPlayArea);
		}

		public static double Pvr_GSABoundaryDetector2(ref GSAPoint3i point, bool isPlayArea, ref GSAPoint3i closestPoint, ref GSAPoint3i normalDir)
		{
			double num = 0.0;
			return GSABoundaryDetector2(ref point, isPlayArea, ref closestPoint, ref normalDir);
		}
	}
	public class Pvr_BoundarySystem
	{
		private static Pvr_BoundarySystem instance;

		public const int CameraImageWidth = 1280;

		public const int CameraImageHeight = 400;

		public IntPtr CameraFramePtr = IntPtr.Zero;

		public static Pvr_BoundarySystem Instance
		{
			get
			{
				if (instance == null)
				{
					instance = new Pvr_BoundarySystem();
				}
				return instance;
			}
		}

		public void OpenBoundary()
		{
			Pvr_BoundaryAPI.Pvr_StartSDKBoundary();
		}

		public void CloseBoundary()
		{
			Pvr_BoundaryAPI.Pvr_ShutdownSDKBoundary();
		}

		public void Reset6Dof()
		{
			Pvr_BoundaryAPI.Pvr_ResetVrModebyForce();
		}

		public float[] GetControllerFixedPoseData(int hand)
		{
			float[] result = new float[7] { 0f, 0f, 0f, 1f, 0f, 0f, 0f };
			if (Pvr_ControllerManager.controllerlink != null)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, Pvr_ControllerManager.controllerlink.javaCVClass, "getControllerFixedSensorState", hand);
			}
			result[2] = 0f - result[2];
			result[3] = 0f - result[3];
			return result;
		}
	}
	public class Pvr_SafeAreaAlgoModule
	{
		public struct ExtraInfo
		{
			public bool overMaxRange;

			public bool includeBigGap;

			public int bigGapNum;

			public bool centerOut;

			public bool removeNarrow;

			public bool overMaxRange_more;

			public int validShrinkArea;
		}

		public struct BoundaryPlayerArea
		{
			public Vector3 lowerleft;

			public Vector3 upperleft;

			public Vector3 upperRight;

			public Vector3 lowerRight;

			public Vector3 center;

			public uint width;

			public uint height;

			public bool isLegal;

			public ExtraInfo extraInfo;
		}

		public delegate void BoundarySystemCallback(BoundaryPlayerArea playAreaInfo, List<Vector3> boundaryPoints, List<List<Vector3>> unusedLines);

		public delegate void BoundarySystemCallbackShrink(List<Vector3> rectPoints, List<Vector3> boundaryPoints, List<List<Vector3>> unusedLines);

		private static Pvr_SafeAreaAlgoModule instance;

		private BoundarySystemCallback boundarySystemCallback;

		private BoundarySystemCallbackShrink boundarySystemCallbackShrink;

		public static Pvr_SafeAreaAlgoModule Instance
		{
			get
			{
				if (instance == null)
				{
					instance = new Pvr_SafeAreaAlgoModule();
				}
				return instance;
			}
		}

		public void RegisterCallBack(BoundarySystemCallback callback)
		{
			boundarySystemCallback = callback;
		}

		public void RegisterCallBackShrink(BoundarySystemCallbackShrink callback)
		{
			boundarySystemCallbackShrink = callback;
		}

		public bool Start()
		{
			int num = Pvr_SafeAreaAlgoAPI.Pvr_GSASetCallback(_SafeAreaCallback);
			int num2 = Pvr_SafeAreaAlgoAPI.Pvr_GSASetCallbackShrink(_SafeAreaCallbackShrink);
			if (num != 0 || num2 != 0)
			{
				Debug.LogError("BoundarySystem register callback failed!");
				return false;
			}
			if (Pvr_SafeAreaAlgoAPI.Pvr_GSAInit(300, 300) != 0)
			{
				Debug.LogError("BoundarySystem init failed!");
				return false;
			}
			return true;
		}

		public bool CommitNewLineData(bool isFistLine, Vector3[] points)
		{
			Pvr_SafeAreaAlgoAPI.GSALineCollection info = default(Pvr_SafeAreaAlgoAPI.GSALineCollection);
			info.lineCount = 2;
			Pvr_SafeAreaAlgoAPI.GSALine[] array = new Pvr_SafeAreaAlgoAPI.GSALine[2];
			if (isFistLine)
			{
				array[0].pointArray = IntPtr.Zero;
				array[0].pointCount = 0;
			}
			else
			{
				Pvr_SafeAreaAlgoAPI.GSAPoint3i[] arr = new Pvr_SafeAreaAlgoAPI.GSAPoint3i[1]
				{
					new Pvr_SafeAreaAlgoAPI.GSAPoint3i
					{
						x = 0,
						y = 0,
						z = 0
					}
				};
				array[0].pointArray = Marshal.UnsafeAddrOfPinnedArrayElement(arr, 0);
				array[0].pointCount = 1;
			}
			Pvr_SafeAreaAlgoAPI.GSAPoint3i[] array2 = new Pvr_SafeAreaAlgoAPI.GSAPoint3i[points.Length];
			for (int i = 0; i < points.Length; i++)
			{
				Pvr_SafeAreaAlgoAPI.GSAPoint3i gSAPoint3i = default(Pvr_SafeAreaAlgoAPI.GSAPoint3i);
				gSAPoint3i.x = (int)(points[i].x * 1000f);
				gSAPoint3i.y = (int)(points[i].y * 1000f);
				gSAPoint3i.z = (int)(points[i].z * 1000f);
				array2[i] = gSAPoint3i;
			}
			array[1].pointArray = Marshal.UnsafeAddrOfPinnedArrayElement(array2, 0);
			array[1].pointCount = array2.Length;
			info.lineArray = Marshal.UnsafeAddrOfPinnedArrayElement(array, 0);
			IntPtr intPtr = Pvr_BoundaryAPI.StructToIntPtr(info);
			int num = Pvr_SafeAreaAlgoAPI.Pvr_GSAUpDateData(intPtr);
			Marshal.FreeHGlobal(intPtr);
			if (num != 0)
			{
				Debug.LogError("BoundarySystem commit new line data failed!");
				return false;
			}
			return true;
		}

		public bool Shutdown()
		{
			if (Pvr_SafeAreaAlgoAPI.Pvr_GSAShutDown() != 0)
			{
				Debug.LogError("BoundarySystem shutdown failed!");
				return false;
			}
			return true;
		}

		public double QueryDistanceOfPoint(Vector3 point)
		{
			Pvr_SafeAreaAlgoAPI.GSAPoint3i point2 = default(Pvr_SafeAreaAlgoAPI.GSAPoint3i);
			point2.x = (int)(point.x * 1000f);
			point2.y = (int)(point.y * 1000f);
			point2.z = (int)(point.z * 1000f);
			double num = Pvr_SafeAreaAlgoAPI.Pvr_GSABoundaryDetector(ref point2);
			return num / 1000.0;
		}

		public double QueryDistanceOfPoint(Vector3 point, bool isPlayArea, ref Vector3 closestPoint, ref Vector3 normalDir)
		{
			Pvr_SafeAreaAlgoAPI.GSAPoint3i point2 = default(Pvr_SafeAreaAlgoAPI.GSAPoint3i);
			point2.x = (int)(point.x * 1000f);
			point2.y = (int)(point.y * 1000f);
			point2.z = (int)(point.z * 1000f);
			Pvr_SafeAreaAlgoAPI.GSAPoint3i closestPoint2 = default(Pvr_SafeAreaAlgoAPI.GSAPoint3i);
			Pvr_SafeAreaAlgoAPI.GSAPoint3i normalDir2 = default(Pvr_SafeAreaAlgoAPI.GSAPoint3i);
			double num = Pvr_SafeAreaAlgoAPI.Pvr_GSABoundaryDetector2(ref point2, isPlayArea, ref closestPoint2, ref normalDir2);
			closestPoint.x = (float)closestPoint2.x / 1000f;
			closestPoint.y = (float)closestPoint2.y / 1000f;
			closestPoint.z = (float)closestPoint2.z / 1000f;
			normalDir.x = (float)normalDir2.x / 1000f;
			normalDir.y = (float)normalDir2.y / 1000f;
			normalDir.z = (float)normalDir2.z / 1000f;
			return num / 1000.0;
		}

		[MonoPInvokeCallback(typeof(Pvr_SafeAreaAlgoAPI.SafeAreaCallback))]
		private static void _SafeAreaCallback(IntPtr lineCollectionPtr, IntPtr safeAreaRectPtr)
		{
			if (lineCollectionPtr == IntPtr.Zero || safeAreaRectPtr == IntPtr.Zero)
			{
				Debug.LogError("BoundarySystem callback is inValid!");
			}
			else
			{
				if (instance.boundarySystemCallback == null)
				{
					return;
				}
				List<Vector3> boundaryPoints = new List<Vector3>();
				List<List<Vector3>> list = new List<List<Vector3>>();
				int num = Marshal.SizeOf(typeof(Pvr_SafeAreaAlgoAPI.GSALine));
				int num2 = Marshal.SizeOf(typeof(Pvr_SafeAreaAlgoAPI.GSAPoint3i));
				Pvr_SafeAreaAlgoAPI.GSALineCollection gSALineCollection = Pvr_BoundaryAPI.IntPtrToStruct<Pvr_SafeAreaAlgoAPI.GSALineCollection>(lineCollectionPtr);
				for (int i = 0; i < gSALineCollection.lineCount; i++)
				{
					IntPtr ptr = new IntPtr(gSALineCollection.lineArray.ToInt64() + num * i);
					Pvr_SafeAreaAlgoAPI.GSALine gSALine = (Pvr_SafeAreaAlgoAPI.GSALine)Marshal.PtrToStructure(ptr, typeof(Pvr_SafeAreaAlgoAPI.GSALine));
					List<Vector3> list2 = new List<Vector3>();
					for (int j = 0; j < gSALine.pointCount; j++)
					{
						IntPtr ptr2 = new IntPtr(gSALine.pointArray.ToInt64() + num2 * j);
						Pvr_SafeAreaAlgoAPI.GSAPoint3i gSAPoint3i = (Pvr_SafeAreaAlgoAPI.GSAPoint3i)Marshal.PtrToStructure(ptr2, typeof(Pvr_SafeAreaAlgoAPI.GSAPoint3i));
						list2.Add(new Vector3((float)gSAPoint3i.x / 1000f, (float)gSAPoint3i.y / 1000f, (float)gSAPoint3i.z / 1000f));
					}
					if (i == 0)
					{
						boundaryPoints = list2;
					}
					else
					{
						list.Add(list2);
					}
				}
				Pvr_SafeAreaAlgoAPI.GSARect gSARect = Pvr_BoundaryAPI.IntPtrToStruct<Pvr_SafeAreaAlgoAPI.GSARect>(safeAreaRectPtr);
				BoundaryPlayerArea playAreaInfo = default(BoundaryPlayerArea);
				playAreaInfo.lowerleft = new Vector3((float)gSARect.leftup.x / 1000f, (float)gSARect.leftup.y / 1000f, (float)gSARect.leftup.z / 1000f);
				playAreaInfo.upperleft = new Vector3((float)gSARect.leftdown.x / 1000f, (float)gSARect.leftdown.y / 1000f, (float)gSARect.leftdown.z / 1000f);
				playAreaInfo.upperRight = new Vector3((float)gSARect.rightdown.x / 1000f, (float)gSARect.rightdown.y / 1000f, (float)gSARect.rightdown.z / 1000f);
				playAreaInfo.lowerRight = new Vector3((float)gSARect.rightup.x / 1000f, (float)gSARect.rightup.y / 1000f, (float)gSARect.rightup.z / 1000f);
				playAreaInfo.center = new Vector3((float)gSARect.center.x / 1000f, (float)gSARect.center.y / 1000f, (float)gSARect.center.z / 1000f);
				playAreaInfo.width = gSARect.width;
				playAreaInfo.height = gSARect.height;
				playAreaInfo.isLegal = ((gSARect.isLegal != 0) ? true : false);
				playAreaInfo.extraInfo.overMaxRange = ((gSARect.legalData.overMaxRange != 0) ? true : false);
				playAreaInfo.extraInfo.includeBigGap = ((gSARect.legalData.includeBigGrap != 0) ? true : false);
				playAreaInfo.extraInfo.bigGapNum = gSARect.legalData.bigGapNum;
				playAreaInfo.extraInfo.centerOut = ((gSARect.legalData.centerOut != 0) ? true : false);
				playAreaInfo.extraInfo.removeNarrow = ((gSARect.legalData.removeNarrow != 0) ? true : false);
				playAreaInfo.extraInfo.overMaxRange_more = ((gSARect.legalData.overMaxRange_more != 0) ? true : false);
				playAreaInfo.extraInfo.validShrinkArea = gSARect.legalData.validShrinkArea;
				instance.boundarySystemCallback(playAreaInfo, boundaryPoints, list);
			}
		}

		[MonoPInvokeCallback(typeof(Pvr_SafeAreaAlgoAPI.SafeAreaCallbackShrink))]
		private static void _SafeAreaCallbackShrink(IntPtr lineCollectionPtr, IntPtr safeAreaDetailRectPtr)
		{
			if (lineCollectionPtr == IntPtr.Zero || safeAreaDetailRectPtr == IntPtr.Zero)
			{
				Debug.LogError("BoundarySystem callback is inValid!");
			}
			else
			{
				if (instance.boundarySystemCallbackShrink == null)
				{
					return;
				}
				List<Vector3> boundaryPoints = new List<Vector3>();
				List<List<Vector3>> list = new List<List<Vector3>>();
				int num = Marshal.SizeOf(typeof(Pvr_SafeAreaAlgoAPI.GSALine));
				int num2 = Marshal.SizeOf(typeof(Pvr_SafeAreaAlgoAPI.GSAPoint3i));
				Pvr_SafeAreaAlgoAPI.GSALineCollection gSALineCollection = Pvr_BoundaryAPI.IntPtrToStruct<Pvr_SafeAreaAlgoAPI.GSALineCollection>(lineCollectionPtr);
				for (int i = 0; i < gSALineCollection.lineCount; i++)
				{
					IntPtr ptr = new IntPtr(gSALineCollection.lineArray.ToInt64() + num * i);
					Pvr_SafeAreaAlgoAPI.GSALine gSALine = (Pvr_SafeAreaAlgoAPI.GSALine)Marshal.PtrToStructure(ptr, typeof(Pvr_SafeAreaAlgoAPI.GSALine));
					List<Vector3> list2 = new List<Vector3>();
					for (int j = 0; j < gSALine.pointCount; j++)
					{
						IntPtr ptr2 = new IntPtr(gSALine.pointArray.ToInt64() + num2 * j);
						Pvr_SafeAreaAlgoAPI.GSAPoint3i gSAPoint3i = (Pvr_SafeAreaAlgoAPI.GSAPoint3i)Marshal.PtrToStructure(ptr2, typeof(Pvr_SafeAreaAlgoAPI.GSAPoint3i));
						list2.Add(new Vector3((float)gSAPoint3i.x / 1000f, (float)gSAPoint3i.y / 1000f, (float)gSAPoint3i.z / 1000f));
					}
					if (i == 0)
					{
						boundaryPoints = list2;
					}
					else
					{
						list.Add(list2);
					}
				}
				List<Vector3> list3 = new List<Vector3>();
				Pvr_SafeAreaAlgoAPI.GSALineCollection gSALineCollection2 = Pvr_BoundaryAPI.IntPtrToStruct<Pvr_SafeAreaAlgoAPI.GSALineCollection>(safeAreaDetailRectPtr);
				for (int k = 0; k < gSALineCollection2.lineCount; k++)
				{
					IntPtr ptr3 = new IntPtr(gSALineCollection2.lineArray.ToInt64() + num * k);
					Pvr_SafeAreaAlgoAPI.GSALine gSALine2 = (Pvr_SafeAreaAlgoAPI.GSALine)Marshal.PtrToStructure(ptr3, typeof(Pvr_SafeAreaAlgoAPI.GSALine));
					for (int l = 0; l < gSALine2.pointCount; l++)
					{
						IntPtr ptr4 = new IntPtr(gSALine2.pointArray.ToInt64() + num2 * l);
						Pvr_SafeAreaAlgoAPI.GSAPoint3i gSAPoint3i2 = (Pvr_SafeAreaAlgoAPI.GSAPoint3i)Marshal.PtrToStructure(ptr4, typeof(Pvr_SafeAreaAlgoAPI.GSAPoint3i));
						list3.Add(new Vector3((float)gSAPoint3i2.x / 1000f, (float)gSAPoint3i2.y / 1000f, (float)gSAPoint3i2.z / 1000f));
					}
				}
				instance.boundarySystemCallbackShrink(list3, boundaryPoints, list);
			}
		}
	}
}
namespace Pvr_UnitySDKAPI
{
	public class PvrControllerKey
	{
		public bool State;

		public bool PressedDown;

		public bool PressedUp;

		public bool LongPressed;

		public bool Click;

		public bool Touch;

		public bool TouchDown;

		public bool TouchUp;

		public PvrControllerKey()
		{
			State = false;
			PressedDown = false;
			PressedUp = false;
			LongPressed = false;
			Click = false;
			Touch = false;
			TouchDown = false;
			TouchUp = false;
		}
	}
	public class ControllerHand
	{
		public PvrControllerKey App;

		public PvrControllerKey Touch;

		public PvrControllerKey Home;

		public PvrControllerKey VolumeDown;

		public PvrControllerKey VolumeUp;

		public PvrControllerKey Trigger;

		public PvrControllerKey X;

		public PvrControllerKey Y;

		public PvrControllerKey A;

		public PvrControllerKey B;

		public PvrControllerKey Left;

		public PvrControllerKey Right;

		public PvrControllerKey Thumbrest;

		public Vector2 TouchPadPosition;

		public int TriggerNum;

		public int GripValue;

		public Quaternion Rotation;

		public Vector3 Position;

		public int Battery;

		public ControllerState ConnectState;

		public SwipeDirection SwipeDirection;

		public TouchPadClick TouchPadClick;

		public bool isShowBoundary;

		public ControllerHand()
		{
			App = new PvrControllerKey();
			Touch = new PvrControllerKey();
			Home = new PvrControllerKey();
			VolumeDown = new PvrControllerKey();
			VolumeUp = new PvrControllerKey();
			Trigger = new PvrControllerKey();
			A = new PvrControllerKey();
			B = new PvrControllerKey();
			X = new PvrControllerKey();
			Y = new PvrControllerKey();
			Left = new PvrControllerKey();
			Right = new PvrControllerKey();
			Thumbrest = new PvrControllerKey();
			TouchPadPosition = default(Vector2);
			Rotation = default(Quaternion);
			Position = default(Vector3);
			Battery = 0;
			TriggerNum = 0;
			GripValue = 0;
			ConnectState = ControllerState.Error;
			SwipeDirection = SwipeDirection.No;
			TouchPadClick = TouchPadClick.No;
			isShowBoundary = false;
		}
	}
	public enum ControllerState
	{
		Error = -1,
		DisConnected,
		Connected
	}
	public enum Pvr_KeyCode
	{
		APP = 1,
		TOUCHPAD,
		HOME,
		VOLUMEUP,
		VOLUMEDOWN,
		TRIGGER,
		A,
		B,
		X,
		Y,
		Left,
		Right,
		Thumbrest
	}
	public enum SwipeDirection
	{
		No,
		SwipeUp,
		SwipeDown,
		SwipeLeft,
		SwipeRight
	}
	public enum TouchPadClick
	{
		No,
		ClickUp,
		ClickDown,
		ClickLeft,
		ClickRight
	}
	[StructLayout(0, Size = 1)]
	public struct Controller
	{
		public const string LibFileName = "Pvr_UnitySDK";

		public static Vector2 UPvr_GetTouchPadPosition(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition, 
				_ => new Vector2(0f, 0f), 
			};
		}

		public static float UPvr_GetAxis1D(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.TRIGGER => (float)Pvr_ControllerManager.controllerlink.Controller0.TriggerNum / 255f, 
					Pvr_KeyCode.Left => (float)Pvr_ControllerManager.controllerlink.Controller0.GripValue / 255f, 
					_ => 0f, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.TRIGGER => (float)Pvr_ControllerManager.controllerlink.Controller1.TriggerNum / 255f, 
					Pvr_KeyCode.Right => (float)Pvr_ControllerManager.controllerlink.Controller1.GripValue / 255f, 
					_ => 0f, 
				}, 
				_ => 0f, 
			};
		}

		public static Vector2 UPvr_GetAxis2D(int hand)
		{
			switch (hand)
			{
			case 0:
				if (Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition != Vector2.zero)
				{
					return new Vector2(Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.x / 128f - 1f, Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.y / 128f - 1f);
				}
				return Vector2.zero;
			case 1:
				if (Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition != Vector2.zero)
				{
					return new Vector2(Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.x / 128f - 1f, Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.y / 128f - 1f);
				}
				return Vector2.zero;
			default:
				return Vector2.zero;
			}
		}

		public static ControllerState UPvr_GetControllerState(int hand)
		{
			return hand switch
			{
				0 => (ControllerState)Convert.ToInt16(Pvr_ControllerManager.controllerlink.controller0Connected), 
				1 => (ControllerState)Convert.ToInt16(Pvr_ControllerManager.controllerlink.controller1Connected), 
				_ => ControllerState.Error, 
			};
		}

		public static Quaternion UPvr_GetControllerQUA(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.Rotation, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.Rotation, 
				_ => new Quaternion(0f, 0f, 0f, 1f), 
			};
		}

		public static Vector3 UPvr_GetControllerPOS(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.Position, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.Position, 
				_ => new Vector3(0f, 0f, 0f), 
			};
		}

		public static int UPvr_GetControllerTriggerValue(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.TriggerNum, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.TriggerNum, 
				_ => 0, 
			};
		}

		public static int UPvr_GetControllerPower(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.Battery, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.Battery, 
				_ => 0, 
			};
		}

		public static SwipeDirection UPvr_GetSwipeDirection(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.SwipeDirection, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.SwipeDirection, 
				_ => SwipeDirection.No, 
			};
		}

		public static TouchPadClick UPvr_GetTouchPadClick(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.TouchPadClick, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.TouchPadClick, 
				_ => TouchPadClick.No, 
			};
		}

		public static bool UPvr_GetKey(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller0.App.State, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller0.Home.State, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.State, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller0.VolumeUp.State, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller0.VolumeDown.State, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.State, 
					Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.State, 
					Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.State, 
					Pvr_KeyCode.Left => Pvr_ControllerManager.controllerlink.Controller0.Left.State, 
					_ => false, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller1.App.State, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller1.Home.State, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.State, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller1.VolumeUp.State, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller1.VolumeDown.State, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.State, 
					Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.State, 
					Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.State, 
					Pvr_KeyCode.Right => Pvr_ControllerManager.controllerlink.Controller1.Right.State, 
					_ => false, 
				}, 
				_ => false, 
			};
		}

		public static bool UPvr_GetKeyDown(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller0.App.PressedDown, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller0.Home.PressedDown, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.PressedDown, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller0.VolumeUp.PressedDown, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller0.VolumeDown.PressedDown, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.PressedDown, 
					Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.PressedDown, 
					Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.PressedDown, 
					Pvr_KeyCode.Left => Pvr_ControllerManager.controllerlink.Controller0.Left.PressedDown, 
					_ => false, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller1.App.PressedDown, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller1.Home.PressedDown, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.PressedDown, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller1.VolumeUp.PressedDown, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller1.VolumeDown.PressedDown, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.PressedDown, 
					Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.PressedDown, 
					Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.PressedDown, 
					Pvr_KeyCode.Right => Pvr_ControllerManager.controllerlink.Controller1.Right.PressedDown, 
					_ => false, 
				}, 
				_ => false, 
			};
		}

		public static bool UPvr_GetKeyUp(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller0.App.PressedUp, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller0.Home.PressedUp, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.PressedUp, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller0.VolumeUp.PressedUp, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller0.VolumeDown.PressedUp, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.PressedUp, 
					Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.PressedUp, 
					Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.PressedUp, 
					Pvr_KeyCode.Left => Pvr_ControllerManager.controllerlink.Controller0.Left.PressedUp, 
					_ => false, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller1.App.PressedUp, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller1.Home.PressedUp, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.PressedUp, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller1.VolumeUp.PressedUp, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller1.VolumeDown.PressedUp, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.PressedUp, 
					Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.PressedUp, 
					Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.PressedUp, 
					Pvr_KeyCode.Right => Pvr_ControllerManager.controllerlink.Controller1.Right.PressedUp, 
					_ => false, 
				}, 
				_ => false, 
			};
		}

		public static bool UPvr_GetTouch(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.Touch, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.Touch, 
					Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.Touch, 
					Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.Touch, 
					Pvr_KeyCode.Thumbrest => Pvr_ControllerManager.controllerlink.Controller0.Thumbrest.Touch, 
					_ => false, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.Touch, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.Touch, 
					Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.Touch, 
					Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.Touch, 
					Pvr_KeyCode.Thumbrest => Pvr_ControllerManager.controllerlink.Controller1.Thumbrest.Touch, 
					_ => false, 
				}, 
				_ => false, 
			};
		}

		public static bool UPvr_GetTouchDown(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.TouchDown, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.TouchDown, 
					Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.TouchDown, 
					Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.TouchDown, 
					Pvr_KeyCode.Thumbrest => Pvr_ControllerManager.controllerlink.Controller0.Thumbrest.TouchDown, 
					_ => false, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.TouchDown, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.TouchDown, 
					Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.TouchDown, 
					Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.TouchDown, 
					Pvr_KeyCode.Thumbrest => Pvr_ControllerManager.controllerlink.Controller1.Thumbrest.TouchDown, 
					_ => false, 
				}, 
				_ => false, 
			};
		}

		public static bool UPvr_GetTouchUp(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.TouchUp, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.TouchUp, 
					Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.TouchUp, 
					Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.TouchUp, 
					Pvr_KeyCode.Thumbrest => Pvr_ControllerManager.controllerlink.Controller0.Thumbrest.TouchUp, 
					_ => false, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.TouchUp, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.TouchUp, 
					Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.TouchUp, 
					Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.TouchUp, 
					Pvr_KeyCode.Thumbrest => Pvr_ControllerManager.controllerlink.Controller1.Thumbrest.TouchUp, 
					_ => false, 
				}, 
				_ => false, 
			};
		}

		public static bool UPvr_GetKeyClick(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller0.App.Click, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller0.Home.Click, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.Click, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller0.VolumeUp.Click, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller0.VolumeDown.Click, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.Click, 
					Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.Click, 
					Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.Click, 
					Pvr_KeyCode.Left => Pvr_ControllerManager.controllerlink.Controller0.Left.Click, 
					_ => false, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller1.App.Click, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller1.Home.Click, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.Click, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller1.VolumeUp.Click, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller1.VolumeDown.Click, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.Click, 
					Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.Click, 
					Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.Click, 
					Pvr_KeyCode.Right => Pvr_ControllerManager.controllerlink.Controller1.Right.Click, 
					_ => false, 
				}, 
				_ => false, 
			};
		}

		public static bool UPvr_GetKeyLongPressed(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller0.App.LongPressed, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller0.Home.LongPressed, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.LongPressed, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller0.VolumeUp.LongPressed, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller0.VolumeDown.LongPressed, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.LongPressed, 
					Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.LongPressed, 
					Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.LongPressed, 
					Pvr_KeyCode.Left => Pvr_ControllerManager.controllerlink.Controller0.Left.LongPressed, 
					_ => false, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller1.App.LongPressed, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller1.Home.LongPressed, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.LongPressed, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller1.VolumeUp.LongPressed, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller1.VolumeDown.LongPressed, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.LongPressed, 
					Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.LongPressed, 
					Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.LongPressed, 
					Pvr_KeyCode.Right => Pvr_ControllerManager.controllerlink.Controller1.Right.LongPressed, 
					_ => false, 
				}, 
				_ => false, 
			};
		}

		public static bool UPvr_IsTouching(int hand)
		{
			return hand switch
			{
				0 => Math.Abs(Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.x) > 0f || Math.Abs(Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.y) > 0f, 
				1 => Math.Abs(Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.x) > 0f || Math.Abs(Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.y) > 0f, 
				_ => false, 
			};
		}

		public static void UPvr_SetHandNess(Pvr_Controller.UserHandNess hand)
		{
			if (Pvr_ControllerManager.controllerlink.getHandness() != (int)hand)
			{
				Pvr_ControllerManager.controllerlink.setHandness((int)hand);
			}
		}

		public static Pvr_Controller.UserHandNess UPvr_GetHandNess()
		{
			return Pvr_ControllerManager.controllerlink.handness;
		}

		public static int UPvr_GetPreferenceDevice()
		{
			int trackingmode = Pvr_ControllerManager.controllerlink.trackingmode;
			int systemProp = Pvr_ControllerManager.controllerlink.systemProp;
			if (trackingmode == 0 || trackingmode == 1 || ((trackingmode == 3 || trackingmode == 5 || trackingmode == 6) && (systemProp == 1 || systemProp == 3)))
			{
				return 1;
			}
			return 2;
		}

		public static bool UPvr_IsEnbleTrigger()
		{
			return Pvr_ControllerManager.controllerlink.IsEnbleTrigger();
		}

		public static int UPvr_GetDeviceType()
		{
			return Pvr_ControllerManager.controllerlink.controllerType;
		}

		public static int UPvr_GetMainHandNess()
		{
			return Pvr_ControllerManager.controllerlink.mainHandID;
		}

		public static void UPvr_SetMainHandNess(int hand)
		{
			Pvr_ControllerManager.controllerlink.SetMainController(hand);
		}

		public static int UPvr_GetControllerAbility(int hand)
		{
			return Pvr_ControllerManager.controllerlink.GetControllerAbility(hand);
		}

		public static void UPvr_VibrateNeo2Controller(float strength, int time, int hand)
		{
			Pvr_ControllerManager.controllerlink.VibrateNeo2Controller(strength, time, hand);
		}

		public static int UPvr_GetControllerBindingState(int hand)
		{
			return Pvr_ControllerManager.controllerlink.GetControllerBindingState(hand);
		}

		public static Vector3 UPvr_GetVelocity(int hand)
		{
			return Pvr_ControllerManager.controllerlink.GetVelocity(hand);
		}

		public static Vector3 UPvr_GetAngularVelocity(int hand)
		{
			return Pvr_ControllerManager.controllerlink.GetAngularVelocity(hand);
		}

		public static Vector3 UPvr_GetAcceleration(int hand)
		{
			return Pvr_ControllerManager.controllerlink.GetAcceleration(hand);
		}

		public static void UPvr_ScanController()
		{
			Pvr_ControllerManager.controllerlink.StartScan();
		}

		public static void UPvr_StopScanController()
		{
			Pvr_ControllerManager.controllerlink.StopScan();
		}

		public static void UPvr_ConnectController(string mac)
		{
			if (mac != string.Empty)
			{
				Pvr_ControllerManager.controllerlink.hummingBirdMac = mac;
			}
			Pvr_ControllerManager.controllerlink.ConnectBLE();
		}

		public static void UPvr_DisConnectController()
		{
			Pvr_ControllerManager.controllerlink.DisConnectBLE();
		}

		public static void UPvr_ResetController(int hand)
		{
			Pvr_ControllerManager.controllerlink.ResetController(hand);
		}

		public static string UPvr_GetControllerVersion()
		{
			return Pvr_ControllerManager.controllerlink.GetControllerVersion();
		}

		public static void UPvr_GetDeviceVersion(int deviceType)
		{
			Pvr_ControllerManager.controllerlink.GetDeviceVersion(deviceType);
		}

		public static void UPvr_GetControllerSnCode(int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.GetControllerSnCode(controllerSerialNum);
		}

		public static void UPvr_SetControllerUnbind(int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.SetControllerUnbind(controllerSerialNum);
		}

		public static void UPvr_SetStationRestart()
		{
			Pvr_ControllerManager.controllerlink.SetStationRestart();
		}

		public static void UPvr_StartStationOtaUpdate()
		{
			Pvr_ControllerManager.controllerlink.StartStationOtaUpdate();
		}

		public static void UPvr_StartControllerOtaUpdate(int mode, int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.StartControllerOtaUpdate(mode, controllerSerialNum);
		}

		public static void UPvr_EnterPairMode(int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.EnterPairMode(controllerSerialNum);
		}

		public static void UPvr_SetControllerShutdown(int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.SetControllerShutdown(controllerSerialNum);
		}

		public static int UPvr_GetStationPairState()
		{
			return Pvr_ControllerManager.controllerlink.GetStationPairState();
		}

		public static int UPvr_GetStationOtaUpdateProgress()
		{
			return Pvr_ControllerManager.controllerlink.GetStationOtaUpdateProgress();
		}

		public static int UPvr_GetControllerOtaUpdateProgress()
		{
			return Pvr_ControllerManager.controllerlink.GetControllerOtaUpdateProgress();
		}

		public static void UPvr_GetControllerVersionAndSN(int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.GetControllerVersionAndSN(controllerSerialNum);
		}

		public static void UPvr_GetControllerUniqueID()
		{
			Pvr_ControllerManager.controllerlink.GetControllerUniqueID();
		}

		public void UPvr_InterruptStationPairMode()
		{
			Pvr_ControllerManager.controllerlink.InterruptStationPairMode();
		}

		public void UPvr_StartCV2PairingMode(int deviceType)
		{
			Pvr_ControllerManager.controllerlink.StartCV2PairingMode(deviceType);
		}

		public void UPvr_StopCV2PairingMode(int deviceType)
		{
			Pvr_ControllerManager.controllerlink.StopCV2PairingMode(deviceType);
		}

		public static void UPvr_SetArmModelParameters(int hand, int gazeType, float elbowHeight, float elbowDepth, float pointerTiltAngle)
		{
			Pvr_SetArmModelParameters(hand, gazeType, elbowHeight, elbowDepth, pointerTiltAngle);
		}

		public static void UPvr_CalcArmModelParameters(float[] headOrientation, float[] controllerOrientation, float[] controllerPrimary)
		{
			Pvr_CalcArmModelParameters(headOrientation, controllerOrientation, controllerPrimary);
		}

		public static void UPvr_GetPointerPose(float[] rotation, float[] position)
		{
			Pvr_GetPointerPose(rotation, position);
		}

		public static void UPvr_GetElbowPose(float[] rotation, float[] position)
		{
			Pvr_GetElbowPose(rotation, position);
		}

		public static void UPvr_GetWristPose(float[] rotation, float[] position)
		{
			Pvr_GetWristPose(rotation, position);
		}

		public static void UPvr_GetShoulderPose(float[] rotation, float[] position)
		{
			Pvr_GetShoulderPose(rotation, position);
		}

		public static void UPvr_IsEnbleHomeKey(bool state)
		{
			Pvr_ControllerManager.controllerlink.setIsEnbleHomeKey(state);
		}

		public static void UPvr_SwitchHomeKey(bool state)
		{
			Pvr_ControllerManager.controllerlink.SwitchHomeKey(state);
		}

		public static int UPvr_GetControllerSensorStatus(int id)
		{
			return Pvr_ControllerManager.controllerlink.getControllerSensorStatus(id);
		}

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_CalcArmModelParameters(float[] headOrientation, float[] controllerOrientation, float[] gyro);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_GetPointerPose(float[] rotation, float[] position);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_GetElbowPose(float[] rotation, float[] position);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_GetWristPose(float[] rotation, float[] position);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_GetShoulderPose(float[] rotation, float[] position);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetArmModelParameters(int hand, int gazeType, float elbowHeight, float elbowDepth, float pointerTiltAngle);
	}
}
public class Pvr_Controller : MonoBehaviour
{
	public enum UserHandNess
	{
		Right,
		Left
	}

	public enum GazeType
	{
		Never,
		DuringMotion,
		Always
	}

	public enum ControllerAxis
	{
		Controller,
		Wrist,
		Elbow,
		Shoulder
	}

	public GameObject controller0;

	public GameObject controller1;

	private static UserHandNess handness;

	public ControllerAxis Axis;

	public GazeType Gazetype;

	[Range(0f, 0.2f)]
	public float ElbowHeight;

	[Range(0f, 0.2f)]
	public float ElbowDepth;

	[Range(0f, 30f)]
	public float PointerTiltAngle = 15f;

	private float mouseX;

	private float mouseY;

	private float mouseZ;

	private Vector3[] inputDirection = new Vector3[2];

	public static Vector3 pointerPosition { get; set; }

	public static Quaternion pointerRotation { get; set; }

	public static Vector3 elbowPosition { get; set; }

	public static Quaternion elbowRotation { get; set; }

	public static Vector3 wristPosition { get; set; }

	public static Quaternion wristRotation { get; set; }

	public static Vector3 shoulderPosition { get; set; }

	public static Quaternion shoulderRotation { get; set; }

	private void Awake()
	{
		Pvr_ControllerManager.PvrServiceStartSuccessEvent += ServiceStartSuccess;
		Pvr_ControllerManager.SetControllerAbilityEvent += CheckControllerState;
		Pvr_ControllerManager.ChangeMainControllerCallBackEvent += MainControllerChanged;
		Pvr_ControllerManager.ChangeHandNessCallBackEvent += HandnessChanged;
	}

	private void Start()
	{
		handness = Controller.UPvr_GetHandNess();
		if (handness == (UserHandNess)(-1))
		{
			handness = UserHandNess.Right;
		}
	}

	private void OnDestroy()
	{
		Pvr_ControllerManager.PvrServiceStartSuccessEvent -= ServiceStartSuccess;
		Pvr_ControllerManager.SetControllerAbilityEvent -= CheckControllerState;
		Pvr_ControllerManager.ChangeMainControllerCallBackEvent -= MainControllerChanged;
		Pvr_ControllerManager.ChangeHandNessCallBackEvent -= HandnessChanged;
	}

	private void MainControllerChanged(string index)
	{
		RefreshHandness();
	}

	private void HandnessChanged(string index)
	{
		RefreshHandness();
	}

	private void ServiceStartSuccess()
	{
		RefreshHandness();
	}

	private void RefreshHandness()
	{
		handness = Controller.UPvr_GetHandNess();
		if (Controller.UPvr_GetMainHandNess() == 1)
		{
			ChangeHandNess();
		}
	}

	private void OnApplicationPause(bool pause)
	{
		if (!pause)
		{
			if (controller0 != null)
			{
				controller0.transform.localScale = Vector3.zero;
			}
			if (controller1 != null)
			{
				controller1.transform.localScale = Vector3.zero;
			}
		}
		Invoke("ShowController", 0.1f * Time.timeScale);
	}

	private void ShowController()
	{
		if (controller0 != null)
		{
			controller0.transform.localScale = Vector3.one;
		}
		if (controller1 != null)
		{
			controller1.transform.localScale = Vector3.one;
		}
	}

	private void CheckControllerState(string data)
	{
		bool flag = Convert.ToBoolean(Convert.ToInt16(data.Substring(4, 1)));
		short num = Convert.ToInt16(data.Substring(0, 1));
		if (flag && num == 1)
		{
			RefreshHandness();
		}
	}

	private void Update()
	{
		if (Pvr_UnitySDKManager.SDK.ControllerOnlyrot)
		{
			DoUpdateControler0();
			DoUpdateControler1();
			UpdateControlloerRay();
			return;
		}
		if (Controller.UPvr_GetPreferenceDevice() == 1)
		{
			DoUpdateControler0();
			DoUpdateControler1();
			UpdateControlloerRay();
			return;
		}
		if (controller0 != null)
		{
			controller0.transform.localRotation = Controller.UPvr_GetControllerQUA(0);
			controller0.transform.localPosition = Controller.UPvr_GetControllerPOS(0);
			UpdateControlloerRay(update0: true, update1: false);
		}
		if (controller1 != null)
		{
			controller1.transform.localRotation = Controller.UPvr_GetControllerQUA(1);
			controller1.transform.localPosition = Controller.UPvr_GetControllerPOS(1);
			UpdateControlloerRay(update0: false);
		}
	}

	public static void ChangeHandNess()
	{
		handness = ((handness == UserHandNess.Right) ? UserHandNess.Left : UserHandNess.Right);
	}

	private void DoUpdateControler0()
	{
		SetArmParaToSo((int)handness, (int)Gazetype, ElbowHeight, ElbowDepth, PointerTiltAngle);
		CalcArmModelfromSo(0);
		UpdateControllerDataSO(0);
	}

	private void DoUpdateControler1()
	{
		int hand = ((handness != UserHandNess.Left) ? 1 : 0);
		SetArmParaToSo(hand, (int)Gazetype, ElbowHeight, ElbowDepth, PointerTiltAngle);
		CalcArmModelfromSo(1);
		UpdateControllerDataSO(1);
	}

	private void UpdateControlloerRay(bool update0 = true, bool update1 = true)
	{
		if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
		{
			if (update0 && controller0 != null)
			{
				controller0.GetComponent<Pvr_ControllerModuleInit>().UpdateRay();
			}
			if (update1 && controller1 != null)
			{
				controller1.GetComponent<Pvr_ControllerModuleInit>().UpdateRay();
			}
		}
	}

	private Quaternion UpdateSimulatedFrameParams()
	{
		if (Input.GetKey(KeyCode.LeftShift))
		{
			mouseX += Input.GetAxis("Mouse X") * 5f;
			if (mouseX <= -180f)
			{
				mouseX += 360f;
			}
			else if (mouseX > 180f)
			{
				mouseX -= 360f;
			}
			mouseY -= Input.GetAxis("Mouse Y") * 2.4f;
			mouseY = Mathf.Clamp(mouseY, -80f, 80f);
		}
		else if (Input.GetKey(KeyCode.RightShift))
		{
			mouseZ += Input.GetAxis("Mouse X") * 5f;
			mouseZ = Mathf.Clamp(mouseZ, -80f, 80f);
		}
		return Quaternion.Euler(mouseY, mouseX, mouseZ);
	}

	private void SetArmParaToSo(int hand, int gazeType, float elbowHeight, float elbowDepth, float pointerTiltAngle)
	{
		Controller.UPvr_SetArmModelParameters(hand, gazeType, elbowHeight, elbowDepth, pointerTiltAngle);
	}

	private void CalcArmModelfromSo(int hand)
	{
		float[] array = new float[4];
		float[] array2 = new float[4];
		float[] array3 = new float[3];
		Quaternion quaternion = default(Quaternion);
		quaternion = Controller.UPvr_GetControllerQUA(hand);
		Vector3 vector = Controller.UPvr_GetAngularVelocity(hand);
		array2[0] = quaternion.x;
		array2[1] = quaternion.y;
		array2[2] = quaternion.z;
		array2[3] = quaternion.w;
		array3[0] = vector.x;
		array3[1] = vector.y;
		array3[2] = vector.z;
		if (Gazetype == GazeType.DuringMotion)
		{
			Vector3 b = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation * Vector3.forward;
			b.y = 0f;
			b.Normalize();
			float magnitude = vector.magnitude;
			float t = Mathf.Clamp((magnitude - 0.2f) / 45f, 0f, 0.1f);
			ref Vector3 reference = ref inputDirection[hand];
			reference = Vector3.Slerp(inputDirection[hand], b, t);
			if (Controller.UPvr_GetKeyLongPressed(hand, Pvr_KeyCode.HOME))
			{
				inputDirection[hand] = default(Vector3);
			}
			Quaternion quaternion2 = Quaternion.FromToRotation(Vector3.forward, inputDirection[hand]);
			array[0] = quaternion2.x;
			array[1] = quaternion2.y;
			array[2] = quaternion2.z;
			array[3] = quaternion2.w;
		}
		else
		{
			array[0] = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.x;
			array[1] = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.y;
			array[2] = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.z;
			array[3] = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.w;
		}
		Controller.UPvr_CalcArmModelParameters(array, array2, array3);
	}

	public void UpdateControllerDataSO(int hand)
	{
		float[] array = new float[4];
		float[] array2 = new float[3];
		Vector3 vector;
		Quaternion localRotation;
		switch (Axis)
		{
		case ControllerAxis.Controller:
			Controller.UPvr_GetPointerPose(array, array2);
			pointerPosition = new Vector3(array2[0], array2[1], array2[2]);
			pointerRotation = new Quaternion(array[0], array[1], array[2], array[3]);
			vector = pointerPosition;
			localRotation = pointerRotation;
			break;
		case ControllerAxis.Wrist:
			Controller.UPvr_GetWristPose(array, array2);
			wristPosition = new Vector3(array2[0], array2[1], array2[2]);
			wristRotation = new Quaternion(array[0], array[1], array[2], array[3]);
			vector = wristPosition;
			localRotation = wristRotation;
			break;
		case ControllerAxis.Elbow:
			Controller.UPvr_GetElbowPose(array, array2);
			elbowPosition = new Vector3(array2[0], array2[1], array2[2]);
			elbowRotation = new Quaternion(array[0], array[1], array[2], array[3]);
			vector = elbowPosition;
			localRotation = elbowRotation;
			break;
		case ControllerAxis.Shoulder:
			Controller.UPvr_GetShoulderPose(array, array2);
			shoulderPosition = new Vector3(array2[0], array2[1], array2[2]);
			shoulderRotation = new Quaternion(array[0], array[1], array[2], array[3]);
			vector = shoulderPosition;
			localRotation = shoulderRotation;
			break;
		default:
			throw new Exception("Invalid FromJoint.");
		}
		if (hand == 0)
		{
			if (controller0 != null)
			{
				if (!Pvr_UnitySDKManager.SDK.HmdOnlyrot)
				{
					controller0.transform.localPosition = vector + Pvr_UnitySDKSensor.Instance.HeadPose.Position;
				}
				else if (Pvr_UnitySDKManager.SDK.TrackingOrigin == TrackingOrigin.FloorLevel)
				{
					controller0.transform.localPosition = vector + Pvr_UnitySDKSensor.Instance.HeadPose.Position;
				}
				else
				{
					controller0.transform.localPosition = vector;
				}
				controller0.transform.localRotation = localRotation;
			}
		}
		else if (controller1 != null)
		{
			if (!Pvr_UnitySDKManager.SDK.HmdOnlyrot)
			{
				controller1.transform.localPosition = vector + Pvr_UnitySDKSensor.Instance.HeadPose.Position;
			}
			else if (Pvr_UnitySDKManager.SDK.TrackingOrigin == TrackingOrigin.FloorLevel)
			{
				controller1.transform.localPosition = vector + Pvr_UnitySDKSensor.Instance.HeadPose.Position;
			}
			else
			{
				controller1.transform.localPosition = vector;
			}
			controller1.transform.localRotation = localRotation;
		}
	}
}
public class Pvr_ControllerDemo : MonoBehaviour
{
	public GameObject HeadSetController;

	public GameObject controller0;

	public GameObject controller1;

	public GameObject cube;

	private Ray ray;

	private GameObject currentController;

	private Transform lastHit;

	private Transform currentHit;

	[SerializeField]
	private Material normat;

	[SerializeField]
	private Material gazemat;

	[SerializeField]
	private Material clickmat;

	private bool noClick;

	private GameObject referenceObj;

	public float rayDefaultLength = 4f;

	private bool isHasController;

	private bool headcontrolmode;

	private RaycastHit hit;

	private GameObject rayLine;

	private GameObject dot;

	private Transform dragObj;

	private float disX;

	private float disY;

	private float disZ;

	private void Start()
	{
		ray = default(Ray);
		hit = default(RaycastHit);
		if (Pvr_UnitySDKManager.SDK.isHasController)
		{
			Pvr_ControllerManager.PvrServiceStartSuccessEvent += ServiceStartSuccess;
			Pvr_ControllerManager.SetControllerStateChangedEvent += ControllerStateListener;
			Pvr_ControllerManager.ControllerStatusChangeEvent += CheckControllerStateForGoblin;
			isHasController = true;
		}
		referenceObj = new GameObject("ReferenceObj");
	}

	private void OnDestroy()
	{
		if (isHasController)
		{
			Pvr_ControllerManager.PvrServiceStartSuccessEvent -= ServiceStartSuccess;
			Pvr_ControllerManager.SetControllerStateChangedEvent -= ControllerStateListener;
			Pvr_ControllerManager.ControllerStatusChangeEvent -= CheckControllerStateForGoblin;
		}
	}

	private void Update()
	{
		if (HeadSetController.activeSelf)
		{
			HeadSetController.transform.parent.localRotation = Quaternion.Euler(Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.eulerAngles.x, Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.eulerAngles.y, 0f);
			HeadSetController.transform.parent.localPosition = Pvr_UnitySDKSensor.Instance.HeadPose.Position;
			ray.direction = HeadSetController.transform.position - HeadSetController.transform.parent.parent.Find("Head").position;
			ray.origin = HeadSetController.transform.parent.parent.Find("Head").position;
			if (Physics.Raycast(ray, out hit))
			{
				if (HeadSetController.name == "SightPointer")
				{
					HeadSetController.transform.localScale = new Vector3(0.09f, 0.09f, 0.09f);
				}
				currentHit = hit.transform;
				if (currentHit != null && lastHit != null && currentHit != lastHit && (bool)lastHit.GetComponent<Pvr_UIGraphicRaycaster>() && lastHit.transform.gameObject.activeInHierarchy && lastHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled)
				{
					lastHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled = false;
				}
				if (currentHit != null && lastHit != null && currentHit == lastHit && (bool)currentHit.GetComponent<Pvr_UIGraphicRaycaster>() && !currentHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled)
				{
					currentHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled = true;
				}
				if (1 << hit.transform.gameObject.layer == LayerMask.GetMask("Water") && !noClick)
				{
					hit.transform.GetComponent<Renderer>().material = gazemat;
				}
				lastHit = hit.transform;
				if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
				{
					HeadSetController.transform.position = hit.point;
					HeadSetController.transform.position -= (hit.point - HeadSetController.transform.parent.parent.Find("Head").position).normalized * 0.02f;
					float num = 0.008f * hit.distance / 4f;
					Mathf.Clamp(num, 0.002f, 0.008f);
					HeadSetController.transform.localScale = new Vector3(num, num, 1f);
				}
			}
			else
			{
				if (HeadSetController.name == "SightPointer")
				{
					HeadSetController.transform.localScale = Vector3.zero;
				}
				if (lastHit != null && 1 << lastHit.transform.gameObject.layer == LayerMask.GetMask("Water"))
				{
					lastHit.transform.GetComponent<Renderer>().material = normat;
				}
				currentHit = null;
				noClick = false;
				if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
				{
					HeadSetController.transform.position = HeadSetController.transform.parent.parent.Find("Head").position + ray.direction.normalized * (0.5f + rayDefaultLength);
					HeadSetController.transform.localScale = new Vector3(0.008f, 0.008f, 1f);
				}
			}
			if ((Input.GetKeyDown(KeyCode.JoystickButton0) || Input.GetMouseButtonDown(0)) && lastHit != null && 1 << lastHit.transform.gameObject.layer == LayerMask.GetMask("Water") && currentHit != null)
			{
				lastHit.transform.GetComponent<Renderer>().material = clickmat;
				noClick = true;
			}
			return;
		}
		if (currentController != null)
		{
			ray.direction = currentController.transform.forward - currentController.transform.up * 0.25f;
			ray.origin = currentController.transform.Find("start").position;
			if (Physics.Raycast(ray, out hit))
			{
				currentHit = hit.transform;
				if (currentHit != null && lastHit != null && currentHit != lastHit && (bool)lastHit.GetComponent<Pvr_UIGraphicRaycaster>() && lastHit.transform.gameObject.activeInHierarchy && lastHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled)
				{
					lastHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled = false;
				}
				if (currentHit != null && lastHit != null && currentHit == lastHit && (bool)currentHit.GetComponent<Pvr_UIGraphicRaycaster>() && !currentHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled)
				{
					currentHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled = true;
				}
				if (1 << hit.transform.gameObject.layer == LayerMask.GetMask("Water"))
				{
					if (!noClick)
					{
						hit.transform.GetComponent<Renderer>().material = gazemat;
					}
					if (Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.TOUCHPAD) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TOUCHPAD) || Input.GetMouseButtonDown(0))
					{
						referenceObj.transform.position = hit.point;
						disX = hit.transform.position.x - referenceObj.transform.position.x;
						disY = hit.transform.position.y - referenceObj.transform.position.y;
						dragObj = hit.transform;
					}
					if ((Controller.UPvr_GetKey(0, Pvr_KeyCode.TOUCHPAD) || Controller.UPvr_GetKey(1, Pvr_KeyCode.TOUCHPAD) || Input.GetMouseButton(0)) && hit.transform == dragObj.transform)
					{
						referenceObj.transform.position = new Vector3(hit.point.x, hit.point.y, hit.transform.position.z);
						dragObj.position = new Vector3(referenceObj.transform.position.x + disX, referenceObj.transform.position.y + disY, hit.transform.position.z);
					}
				}
				lastHit = hit.transform;
				currentController.transform.Find("dot").position = hit.point;
				if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
				{
					float num2 = 0.178f * currentController.transform.Find("dot").localPosition.z / 3.3f;
					Mathf.Clamp(num2, 0.05f, 0.178f);
					currentController.transform.Find("dot").localScale = new Vector3(num2, num2, 1f);
				}
			}
			else
			{
				if (lastHit != null && 1 << lastHit.transform.gameObject.layer == LayerMask.GetMask("Water"))
				{
					lastHit.transform.GetComponent<Renderer>().material = normat;
				}
				currentHit = null;
				noClick = false;
				if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
				{
					currentController.transform.Find("dot").localScale = new Vector3(0.178f, 0.178f, 1f);
				}
			}
		}
		if ((Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.TOUCHPAD) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TOUCHPAD) || Input.GetMouseButtonDown(0)) && lastHit != null && 1 << lastHit.transform.gameObject.layer == LayerMask.GetMask("Water") && currentHit != null)
		{
			lastHit.transform.GetComponent<Renderer>().material = clickmat;
			noClick = true;
		}
	}

	private void ServiceStartSuccess()
	{
		if (Controller.UPvr_GetControllerState(0) == ControllerState.Connected || Controller.UPvr_GetControllerState(1) == ControllerState.Connected)
		{
			HeadSetController.SetActive(value: false);
		}
		else
		{
			HeadSetController.SetActive(value: true);
		}
		if (Controller.UPvr_GetMainHandNess() == 0)
		{
			currentController = controller0;
		}
		if (Controller.UPvr_GetMainHandNess() == 1)
		{
			currentController = controller1;
		}
	}

	private void ControllerStateListener(string data)
	{
		if (Controller.UPvr_GetControllerState(0) == ControllerState.Connected || Controller.UPvr_GetControllerState(1) == ControllerState.Connected)
		{
			HeadSetController.SetActive(value: false);
		}
		else
		{
			HeadSetController.SetActive(value: true);
		}
		if (Controller.UPvr_GetMainHandNess() == 0)
		{
			currentController = controller0;
		}
		if (Controller.UPvr_GetMainHandNess() == 1)
		{
			currentController = controller1;
		}
	}

	private void CheckControllerStateForGoblin(string state)
	{
		HeadSetController.SetActive(Convert.ToInt16(state) != 1);
	}

	public void SwitchControlMode()
	{
	}
}
public class Pvr_ControllerEventsExamples : MonoBehaviour
{
	private void Start()
	{
		if (!(GetComponent<Pvr_UIPointer>() == null))
		{
			GetComponent<Pvr_UIPointer>().UIPointerElementEnter += UIPointerElementEnter;
			GetComponent<Pvr_UIPointer>().UIPointerElementExit += UIPointerElementExit;
			GetComponent<Pvr_UIPointer>().UIPointerElementClick += UIPointerElementClick;
			GetComponent<Pvr_UIPointer>().UIPointerElementDragStart += UIPointerElementDragStart;
			GetComponent<Pvr_UIPointer>().UIPointerElementDragEnd += UIPointerElementDragEnd;
		}
	}

	private void UIPointerElementEnter(object sender, UIPointerEventArgs e)
	{
		PLOG.I("UI Pointer entered" + e.currentTarget.name);
	}

	private void UIPointerElementExit(object sender, UIPointerEventArgs e)
	{
		PLOG.I("UI Pointer exited" + e.currentTarget.name);
	}

	private void UIPointerElementClick(object sender, UIPointerEventArgs e)
	{
		PLOG.I("UI Pointer clicked" + e.currentTarget.name);
	}

	private void UIPointerElementDragStart(object sender, UIPointerEventArgs e)
	{
		PLOG.I("UI Pointer started dragging" + e.currentTarget.name);
	}

	private void UIPointerElementDragEnd(object sender, UIPointerEventArgs e)
	{
		PLOG.I("UI Pointer stopped dragging" + e.currentTarget.name);
	}
}
public class Pvr_ControllerInit : MonoBehaviour
{
	private ControllerVariety Variety;

	private bool isCustomModel;

	[SerializeField]
	private GameObject goblin;

	[SerializeField]
	private GameObject g2;

	[SerializeField]
	private GameObject neo2L;

	[SerializeField]
	private GameObject neo2R;

	[SerializeField]
	private GameObject neo3L;

	[SerializeField]
	private GameObject neo3R;

	[SerializeField]
	private Material standardMat;

	[SerializeField]
	private Material unlitMat;

	private int controllerType = -1;

	[HideInInspector]
	public bool loadModelSuccess;

	private int systemOrUnity;

	private JsonData curControllerData;

	private string modelName = string.Empty;

	private string texFormat = string.Empty;

	private string prePath = string.Empty;

	private string modelFilePath = "/system/media/PvrRes/controller/";

	private const string goblinTexbasePath = "Controller/controller1/controller1";

	private const string g2TexbasePath = "Controller/controller3/controller3";

	private const string neo2TexbasePath = "Controller/controller4/controller4";

	private const string neo3TexbasePath = "Controller/controller5/controller5";

	private void Awake()
	{
		int configsenum = 15;
		Render.UPvr_GetIntConfig(configsenum, ref systemOrUnity);
		Variety = base.transform.GetComponentInParent<Pvr_ControllerModuleInit>().Variety;
		isCustomModel = base.transform.GetComponentInParent<Pvr_ControllerModuleInit>().IsCustomModel;
		if (!isCustomModel)
		{
			Pvr_ControllerManager.PvrServiceStartSuccessEvent += ServiceStartSuccess;
			Pvr_ControllerManager.SetControllerAbilityEvent += CheckControllerStateOfAbility;
			Pvr_ControllerManager.ControllerStatusChangeEvent += CheckControllerStateForGoblin;
		}
	}

	private void OnDestroy()
	{
		Pvr_ControllerManager.PvrServiceStartSuccessEvent -= ServiceStartSuccess;
		Pvr_ControllerManager.SetControllerAbilityEvent -= CheckControllerStateOfAbility;
		Pvr_ControllerManager.ControllerStatusChangeEvent -= CheckControllerStateForGoblin;
	}

	private void OnApplicationPause(bool pause)
	{
		if (pause)
		{
			DestroyLocalController();
		}
	}

	private void ServiceStartSuccess()
	{
		int num = Controller.UPvr_GetDeviceType();
		if (controllerType != num && num != 0)
		{
			controllerType = num;
		}
		LoadResFromJson();
		if (Pvr_ControllerManager.controllerlink.neoserviceStarted)
		{
			if (Variety == ControllerVariety.Controller0)
			{
				if (Pvr_ControllerManager.controllerlink.controller0Connected)
				{
					StartCoroutine(RefreshController(0));
				}
				else
				{
					DestroyLocalController();
				}
			}
			if (Variety == ControllerVariety.Controller1)
			{
				if (Pvr_ControllerManager.controllerlink.controller1Connected)
				{
					StartCoroutine(RefreshController(1));
				}
				else
				{
					DestroyLocalController();
				}
			}
		}
		if (Pvr_ControllerManager.controllerlink.goblinserviceStarted && Variety == ControllerVariety.Controller0)
		{
			if (Pvr_ControllerManager.controllerlink.controller0Connected)
			{
				StartCoroutine(RefreshController(0));
			}
			else
			{
				DestroyLocalController();
			}
		}
	}

	private void LoadResFromJson()
	{
		string text = Pvr_UnitySDKAPI.System.UPvr_GetObjectOrArray("config.controller", 7);
		if (text != null)
		{
			JsonData jsonData = JsonMapper.ToObject(text);
			if (controllerType >= 0 && jsonData.Count >= controllerType)
			{
				curControllerData = jsonData[controllerType - 1];
				modelFilePath = (string)curControllerData["base_path"];
				modelName = (string)curControllerData["model_name"] + "_sys";
			}
		}
		else
		{
			PLOG.E("PvrLog LoadJsonFromSystem Error");
		}
	}

	private void CheckControllerStateForGoblin(string state)
	{
		int num = Controller.UPvr_GetDeviceType();
		if (Variety != 0)
		{
			return;
		}
		if (Convert.ToInt16(state) == 1)
		{
			if (controllerType != num)
			{
				DestroySysController();
				controllerType = num;
			}
			StartCoroutine(RefreshController(0));
		}
		else
		{
			DestroyLocalController();
		}
	}

	private void CheckControllerStateOfAbility(string data)
	{
		bool flag = Convert.ToBoolean(Convert.ToInt16(data.Substring(4, 1)));
		short num = Convert.ToInt16(data.Substring(0, 1));
		int num2 = Controller.UPvr_GetDeviceType();
		if (flag)
		{
			controllerType = num2;
			switch (num)
			{
			case 0:
				if (Variety == ControllerVariety.Controller0)
				{
					StartCoroutine(RefreshController(0));
				}
				break;
			case 1:
				if (Variety == ControllerVariety.Controller1)
				{
					StartCoroutine(RefreshController(1));
				}
				break;
			}
			return;
		}
		switch (num)
		{
		case 0:
			if (Variety == ControllerVariety.Controller0)
			{
				DestroyLocalController();
			}
			break;
		case 1:
			if (Variety == ControllerVariety.Controller1)
			{
				DestroyLocalController();
			}
			break;
		}
	}

	private void DestroyLocalController()
	{
		foreach (Transform item in base.transform)
		{
			UnityEngine.Object.Destroy(item.gameObject);
			loadModelSuccess = false;
		}
	}

	private void DestroySysController()
	{
		foreach (Transform item in base.transform)
		{
			if (item.name == modelName)
			{
				UnityEngine.Object.Destroy(item.gameObject);
				loadModelSuccess = false;
			}
		}
	}

	private IEnumerator RefreshController(int id)
	{
		yield return null;
		yield return null;
		if (Controller.UPvr_GetControllerState(id) != ControllerState.Connected)
		{
			yield break;
		}
		if (systemOrUnity == 0)
		{
			LoadControllerFromPrefab();
			if (!loadModelSuccess)
			{
				LoadControllerFromSystem(id);
			}
		}
		else
		{
			bool flag = false;
			foreach (Transform item in base.transform)
			{
				if (item.name == modelName)
				{
					flag = true;
				}
			}
			if (!flag)
			{
				LoadControllerFromSystem(id);
				if (!loadModelSuccess)
				{
					LoadControllerFromPrefab();
				}
			}
			else
			{
				Transform transform2 = base.transform.Find(modelName);
				transform2.gameObject.SetActive(value: true);
			}
		}
		Pvr_ToolTips.RefreshTips();
		PLOG.I("PvrLog Controller Refresh Success");
	}

	private void LoadControllerFromPrefab()
	{
		switch (controllerType)
		{
		case 1:
		{
			GameObject gameObject3 = UnityEngine.Object.Instantiate(goblin, base.transform, worldPositionStays: false);
			Pvr_ControllerVisual pvr_ControllerVisual3 = gameObject3.AddComponent<Pvr_ControllerVisual>();
			pvr_ControllerVisual3.currentDevice = ControllerDevice.Goblin;
			LoadTexture(pvr_ControllerVisual3, "Controller/controller1/controller1", fromRes: true);
			loadModelSuccess = true;
			break;
		}
		case 3:
		{
			GameObject gameObject2 = UnityEngine.Object.Instantiate(g2, base.transform, worldPositionStays: false);
			Pvr_ControllerVisual pvr_ControllerVisual2 = gameObject2.AddComponent<Pvr_ControllerVisual>();
			pvr_ControllerVisual2.currentDevice = ControllerDevice.G2;
			LoadTexture(pvr_ControllerVisual2, "Controller/controller3/controller3", fromRes: true);
			loadModelSuccess = true;
			break;
		}
		case 4:
		{
			GameObject gameObject4 = UnityEngine.Object.Instantiate((Variety != 0) ? neo2R : neo2L, base.transform, worldPositionStays: false);
			Pvr_ControllerVisual pvr_ControllerVisual4 = gameObject4.AddComponent<Pvr_ControllerVisual>();
			pvr_ControllerVisual4.currentDevice = ControllerDevice.Neo2;
			LoadTexture(pvr_ControllerVisual4, "Controller/controller4/controller4", fromRes: true);
			loadModelSuccess = true;
			break;
		}
		case 5:
		{
			GameObject gameObject = UnityEngine.Object.Instantiate((Variety != 0) ? neo3R : neo3L, base.transform, worldPositionStays: false);
			Pvr_ControllerVisual pvr_ControllerVisual = gameObject.AddComponent<Pvr_ControllerVisual>();
			pvr_ControllerVisual.currentDevice = ControllerDevice.Neo3;
			LoadTexture(pvr_ControllerVisual, "Controller/controller5/controller5", fromRes: true);
			loadModelSuccess = true;
			break;
		}
		default:
			loadModelSuccess = false;
			break;
		}
	}

	private void LoadControllerFromSystem(int id)
	{
		string text = controllerType.ToString() + id + ".obj";
		string text2 = modelFilePath + text;
		if (!File.Exists(text2))
		{
			PLOG.I("PvrLog Obj File does not exist==" + text2);
			return;
		}
		GameObject gameObject = new GameObject();
		gameObject.name = modelName;
		MeshFilter meshFilter = gameObject.AddComponent<MeshFilter>();
		meshFilter.mesh = Pvr_ObjImporter.Instance.ImportFile(text2);
		gameObject.transform.SetParent(base.transform);
		gameObject.transform.localPosition = Vector3.zero;
		MeshRenderer meshRenderer = gameObject.AddComponent<MeshRenderer>();
		int num = (int)curControllerData["material_type"];
		meshRenderer.material = ((num != 0) ? unlitMat : standardMat);
		loadModelSuccess = true;
		Pvr_ControllerVisual pvr_ControllerVisual = gameObject.AddComponent<Pvr_ControllerVisual>();
		switch (controllerType)
		{
		case 1:
			pvr_ControllerVisual.currentDevice = ControllerDevice.Goblin;
			break;
		case 3:
			pvr_ControllerVisual.currentDevice = ControllerDevice.G2;
			break;
		case 4:
			pvr_ControllerVisual.currentDevice = ControllerDevice.Neo2;
			break;
		case 5:
			pvr_ControllerVisual.currentDevice = ControllerDevice.Neo3;
			break;
		default:
			pvr_ControllerVisual.currentDevice = ControllerDevice.NewController;
			break;
		}
		pvr_ControllerVisual.variety = Variety;
		LoadTexture(pvr_ControllerVisual, controllerType.ToString() + id, fromRes: false);
		gameObject.transform.localRotation = Quaternion.Euler(new Vector3(0f, 180f, 0f));
		gameObject.transform.localScale = new Vector3(-0.01f, 0.01f, 0.01f);
	}

	private void LoadTexture(Pvr_ControllerVisual visual, string controllerName, bool fromRes)
	{
		if (fromRes)
		{
			texFormat = string.Empty;
			prePath = controllerName;
		}
		else
		{
			texFormat = "." + (string)curControllerData["tex_format"];
			prePath = modelFilePath + controllerName;
		}
		string filepath = prePath + "_idle" + texFormat;
		visual.m_idle = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_app" + texFormat;
		visual.m_app = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_home" + texFormat;
		visual.m_home = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_touch" + texFormat;
		visual.m_touchpad = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_volume_down" + texFormat;
		visual.m_volDn = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_volume_up" + texFormat;
		visual.m_volUp = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_trigger" + texFormat;
		visual.m_trigger = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_a" + texFormat;
		visual.m_a = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_b" + texFormat;
		visual.m_b = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_x" + texFormat;
		visual.m_x = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_y" + texFormat;
		visual.m_y = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_grip" + texFormat;
		visual.m_grip = LoadOneTexture(filepath, fromRes);
	}

	private Texture2D LoadOneTexture(string filepath, bool fromRes)
	{
		if (fromRes)
		{
			return Resources.Load<Texture2D>(filepath);
		}
		int width = (int)curControllerData["tex_width"];
		int height = (int)curControllerData["tex_height"];
		Texture2D texture2D = new Texture2D(width, height);
		texture2D.LoadImage(ReadPNG(filepath));
		return texture2D;
	}

	private byte[] ReadPNG(string path)
	{
		FileStream fileStream = new FileStream(path, FileMode.Open, FileAccess.Read);
		fileStream.Seek(0L, SeekOrigin.Begin);
		byte[] array = new byte[fileStream.Length];
		fileStream.Read(array, 0, (int)fileStream.Length);
		fileStream.Close();
		fileStream.Dispose();
		fileStream = null;
		return array;
	}
}
public class Pvr_ControllerLink
{
	public AndroidJavaClass javaHummingbirdClass;

	public AndroidJavaClass javaPico2ReceiverClass;

	public AndroidJavaClass javaserviceClass;

	public AndroidJavaClass javavractivityclass;

	public AndroidJavaClass javaCVClass;

	public AndroidJavaObject activity;

	public string gameobjname = string.Empty;

	public bool picoDevice;

	public string hummingBirdMac;

	public int hummingBirdRSSI;

	public bool goblinserviceStarted;

	public bool neoserviceStarted;

	public bool controller0Connected;

	public bool controller1Connected;

	public int mainHandID;

	public Pvr_Controller.UserHandNess handness;

	public int controllerType;

	public ControllerHand Controller0;

	public ControllerHand Controller1;

	public int platFormType = -1;

	public int trackingmode = -1;

	public int systemProp = -1;

	public int enablehand6dofbyhead = -1;

	public bool switchHomeKey = true;

	private int iPhoneHMDModeEnabled;

	private float[] hbPoseData = new float[4];

	private float[] sensorData = new float[28];

	private int[] keyData = new int[134];

	private int[] neo3TouchValue = new int[15];

	private float[] fixedState = new float[7] { 0f, 0f, 0f, 1f, 0f, 0f, 0f };

	private float[] neoposeData = new float[7] { 0f, 0f, 0f, 1f, 0f, 0f, 0f };

	private int[] goblinKeyArray = new int[47];

	private int[] neoKeyArray = new int[67];

	private int[] neotriggerV = new int[9];

	private float[] velocity = new float[3];

	private float[] angularVelocity = new float[3];

	private float[] acceData = new float[3];

	public Pvr_ControllerLink(string name)
	{
		gameobjname = name;
		hummingBirdMac = string.Empty;
		hummingBirdRSSI = 0;
		Debug.Log("PvrLog Controller GameObject:" + gameobjname);
		StartHummingBirdService();
		Controller0 = new ControllerHand();
		Controller0.Position = new Vector3(0f, Pvr_UnitySDKSensor.Instance.HeadPose.Position.y, 0f) + new Vector3(-0.1f, -0.3f, 0.3f);
		Controller1 = new ControllerHand();
		Controller1.Position = new Vector3(0f, Pvr_UnitySDKSensor.Instance.HeadPose.Position.y, 0f) + new Vector3(0.1f, -0.3f, 0.3f);
	}

	private void StartHummingBirdService()
	{
		try
		{
			AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
			activity = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
			javaHummingbirdClass = new AndroidJavaClass("com.picovr.picovrlib.hummingbirdclient.HbClientActivity");
			javaCVClass = new AndroidJavaClass("com.picovr.picovrlib.cvcontrollerclient.ControllerClient");
			javavractivityclass = new AndroidJavaClass("com.psmart.vrlib.VrActivity");
			javaserviceClass = new AndroidJavaClass("com.picovr.picovrlib.hummingbirdclient.UnityClient");
			Pvr_UnitySDKAPI.System.Pvr_SetInitActivity(activity.GetRawObject(), javaHummingbirdClass.GetRawClass());
			int configsenum = 4;
			Render.UPvr_GetIntConfig(configsenum, ref platFormType);
			Debug.Log("PvrLog platform" + platFormType);
			configsenum = 5;
			Render.UPvr_GetIntConfig(configsenum, ref trackingmode);
			Debug.Log("PvrLog trackingmode" + trackingmode);
			systemProp = GetSysproc();
			Debug.Log("PvrLog systemProp" + systemProp);
			configsenum = 7;
			Render.UPvr_GetIntConfig(configsenum, ref enablehand6dofbyhead);
			Debug.Log("PvrLog enablehand6dofbyhead" + enablehand6dofbyhead);
			if (trackingmode == 0 || trackingmode == 1 || ((trackingmode == 3 || trackingmode == 5 || trackingmode == 6) && (systemProp == 1 || systemProp == 3)))
			{
				picoDevice = platFormType != 0;
				javaPico2ReceiverClass = new AndroidJavaClass("com.picovr.picovrlib.hummingbirdclient.HbClientReceiver");
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaPico2ReceiverClass, "startReceiver", activity, gameobjname);
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "setPlatformType", platFormType);
			}
			else
			{
				picoDevice = true;
				SetGameObjectToJar(gameobjname);
			}
			Render.UPvr_GetIntConfig(16, ref iPhoneHMDModeEnabled);
			if (iPhoneHMDModeEnabled == 1)
			{
				BindService();
			}
			else if (IsServiceExisted())
			{
				BindService();
			}
		}
		catch (AndroidJavaException ex)
		{
			PLOG.E("ConnectToAndriod--catch" + ex.Message);
		}
	}

	public bool IsServiceExisted()
	{
		bool result = false;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaserviceClass, "isServiceExisted", activity, trackingmode);
		Debug.Log("PvrLog ServiceExisted ?" + result);
		return result;
	}

	public void SetGameObjectToJar(string name)
	{
		Debug.Log("PvrLog SetGameObjectToJar " + name);
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setGameObjectCallback", name);
	}

	public void BindService()
	{
		Debug.Log("PvrLog Bind Service");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaserviceClass, "bindService", activity, trackingmode);
	}

	public void UnBindService()
	{
		Debug.Log("PvrLog UnBind Service");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaserviceClass, "unbindService", activity, trackingmode);
	}

	public void StopLark2Receiver()
	{
		Debug.Log("PvrLog StopLark2Receiver");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaPico2ReceiverClass, "stopReceiver", activity);
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaPico2ReceiverClass, "stopOnBootReceiver", activity);
	}

	public void StartLark2Receiver()
	{
		Debug.Log("PvrLog StartLark2Receiver");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaPico2ReceiverClass, "startReceiver", activity, gameobjname);
	}

	public void StopLark2Service()
	{
		Debug.Log("PvrLog StopLark2Service");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaPico2ReceiverClass, "stopReceiver", activity);
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "unbindHbService", activity);
	}

	public void StartLark2Service()
	{
		Debug.Log("PvrLog StartLark2Service");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaPico2ReceiverClass, "startReceiver", activity, gameobjname);
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "bindHbService", activity);
	}

	public int getHandness()
	{
		int result = -1;
		if (iPhoneHMDModeEnabled == 0)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javavractivityclass, "getPvrHandness", activity);
		}
		else
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getHbHandednessInSP");
		}
		PLOG.I("PvrLog GetHandness =" + result);
		return result;
	}

	public void setHandness(int hand)
	{
		PLOG.I("PvrLog SetHandness =" + hand);
		if (iPhoneHMDModeEnabled == 1)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "setHbHandednessInSP", hand);
		}
	}

	public void StartScan()
	{
		PLOG.I("PvrLog ScanHBController");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "scanHbDevice", true);
	}

	public void StopScan()
	{
		PLOG.I("PvrLog StopScanHBController");
		if (iPhoneHMDModeEnabled == 0)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "scanHbDevice", false);
		}
	}

	public int GetSysproc()
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaserviceClass, "getSysproc");
		PLOG.I("PvrLog GetSysproc" + result);
		return result;
	}

	public void ResetController(int num)
	{
		Debug.Log("PvrLog ResetController" + num);
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "resetControllerSensorState", num);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "resetHbSensorState");
		}
	}

	public void ConnectBLE()
	{
		Debug.Log("PvrLog ConnectHBController" + hummingBirdMac);
		if (hummingBirdMac != string.Empty)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "connectHbController", hummingBirdMac);
		}
	}

	public void DisConnectBLE()
	{
		Debug.Log("PvrLog DisConnectHBController");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "disconnectHbController");
	}

	public bool StartUpgrade()
	{
		Debug.Log("PvrLog StartUpgradeHBController");
		bool result = false;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "startUpgrade");
		return result;
	}

	public void setBinPath(string path, bool isasset)
	{
		Debug.Log("PvrLog setBinPath" + path + isasset);
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "setBinPath", path, isasset);
	}

	public string GetBLEImageType()
	{
		string result = string.Empty;
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getBLEImageType");
		}
		Debug.Log("PvrLog GetBLEImageType" + result);
		return result;
	}

	public long GetBLEVersion()
	{
		long result = 0L;
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getBLEVersion");
		}
		Debug.Log("PvrLog GetBLEVersion" + result);
		return result;
	}

	public string GetFileImageType()
	{
		string result = string.Empty;
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getFileImageType");
		}
		Debug.Log("PvrLog GetFileImageType" + result);
		return result;
	}

	public long GetFileVersion()
	{
		long result = 0L;
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getFileVersion");
		}
		Debug.Log("PvrLog GetFileVersion" + result);
		return result;
	}

	public int GetControllerConnectionState(int num)
	{
		int result = -1;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerConnectionState", num);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getHbConnectionState");
		}
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog GetControllerState:" + num + "state:" + result);
		}
		return result;
	}

	public void RebackToLauncher()
	{
		Debug.Log("PvrLog RebackToLauncher");
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "startLauncher");
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "startLauncher");
		}
	}

	public void TurnUpVolume()
	{
		Debug.Log("PvrLog TurnUpVolume");
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "turnUpVolume", activity);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "turnUpVolume", activity);
		}
	}

	public void TurnDownVolume()
	{
		Debug.Log("PvrLog TurnDownVolume");
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "turnDownVolume", activity);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "turnDownVolume", activity);
		}
	}

	public float[] GetHBControllerPoseData()
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref hbPoseData, javaHummingbirdClass, "getHBSensorPose");
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog HBControllerData" + hbPoseData[0] + "," + hbPoseData[1] + "," + hbPoseData[2] + "," + hbPoseData[3]);
		}
		return hbPoseData;
	}

	public float[] GetControllerSensorData()
	{
		if (enablehand6dofbyhead == 1)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref sensorData, javaCVClass, "getControllerDataInfoBySharmem", Pvr_UnitySDKManager.SDK.headData);
		}
		else
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref sensorData, javaCVClass, "getControllerDataInfoBySharmem");
		}
		return sensorData;
	}

	public int[] GetControllerKeyData()
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref keyData, javaCVClass, "getDoubleControllerKeyEventUnityExtBySharmem");
		return keyData;
	}

	public int[] GetNeo3TouchData(int hand)
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref neo3TouchValue, javaCVClass, "getControllerTouchEvent", hand);
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog Neo3Touch hand:" + hand + "-" + neo3TouchValue[0] + neo3TouchValue[1] + neo3TouchValue[2] + neo3TouchValue[3] + neo3TouchValue[4] + "," + neo3TouchValue[5] + neo3TouchValue[6] + neo3TouchValue[7] + neo3TouchValue[8] + neo3TouchValue[9] + "," + neo3TouchValue[10] + neo3TouchValue[11] + neo3TouchValue[12] + neo3TouchValue[13] + neo3TouchValue[14]);
		}
		return neo3TouchValue;
	}

	public int GetNeo3GripValue(int hand)
	{
		int result = 0;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerGripValue", hand);
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog Neo3GripValue:" + result);
		}
		return result;
	}

	public float[] GetControllerFixedSensorState(int hand)
	{
		if (trackingmode == 2 || trackingmode == 3)
		{
			return fixedState;
		}
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref fixedState, javaCVClass, "getControllerFixedSensorState", hand);
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog GetControllerFixedSensorState " + hand + "Rotation:" + fixedState[0] + "," + fixedState[1] + "," + fixedState[2] + "," + fixedState[3] + "Position:" + fixedState[4] + "," + fixedState[5] + "," + fixedState[6]);
		}
		return fixedState;
	}

	public float[] GetCvControllerPoseData(int hand)
	{
		if (enablehand6dofbyhead == 1)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref neoposeData, javaCVClass, "getControllerSensorState", hand, Pvr_UnitySDKManager.SDK.headData);
		}
		else
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref neoposeData, javaCVClass, "getControllerSensorState", hand);
		}
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog CVControllerData :" + neoposeData[0] + "," + neoposeData[1] + "," + neoposeData[2] + "," + neoposeData[3] + "," + neoposeData[4] + "," + neoposeData[5] + "," + neoposeData[6]);
		}
		return neoposeData;
	}

	public int[] GetHBControllerKeyData()
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref goblinKeyArray, javaHummingbirdClass, "getHBKeyEventUnityExt");
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog HBControllerKey" + goblinKeyArray[0] + goblinKeyArray[1] + goblinKeyArray[2] + goblinKeyArray[3] + goblinKeyArray[4] + "," + goblinKeyArray[5] + goblinKeyArray[6] + goblinKeyArray[7] + goblinKeyArray[8] + goblinKeyArray[9] + "," + goblinKeyArray[10] + goblinKeyArray[11] + goblinKeyArray[12] + goblinKeyArray[13] + goblinKeyArray[14] + "," + goblinKeyArray[15] + goblinKeyArray[16] + goblinKeyArray[17] + goblinKeyArray[18] + goblinKeyArray[19] + "," + goblinKeyArray[20] + goblinKeyArray[21] + goblinKeyArray[22] + goblinKeyArray[23] + goblinKeyArray[24] + "," + goblinKeyArray[25] + goblinKeyArray[26] + goblinKeyArray[27] + goblinKeyArray[28] + goblinKeyArray[29] + "," + goblinKeyArray[30] + goblinKeyArray[31] + goblinKeyArray[32] + goblinKeyArray[33] + goblinKeyArray[34] + "," + goblinKeyArray[35] + goblinKeyArray[36] + goblinKeyArray[37] + goblinKeyArray[38] + goblinKeyArray[39] + "," + goblinKeyArray[40] + goblinKeyArray[41] + goblinKeyArray[42] + goblinKeyArray[43] + goblinKeyArray[44] + "," + goblinKeyArray[45] + goblinKeyArray[46]);
		}
		return goblinKeyArray;
	}

	public int GetHBKeyValue()
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getTriggerKeyEvent");
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog GoblinControllerTriggerKey:" + result);
		}
		return result;
	}

	public int[] GetCvControllerKeyData(int hand)
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref neoKeyArray, javaCVClass, "getControllerKeyEventUnityExt", hand);
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog CVControllerKey hand:" + hand + "-" + neoKeyArray[0] + neoKeyArray[1] + neoKeyArray[2] + neoKeyArray[3] + neoKeyArray[4] + "," + neoKeyArray[5] + neoKeyArray[6] + neoKeyArray[7] + neoKeyArray[8] + neoKeyArray[9] + "," + neoKeyArray[10] + neoKeyArray[11] + neoKeyArray[12] + neoKeyArray[13] + neoKeyArray[14] + "," + neoKeyArray[15] + neoKeyArray[16] + neoKeyArray[17] + neoKeyArray[18] + neoKeyArray[19] + "," + neoKeyArray[20] + neoKeyArray[21] + neoKeyArray[22] + neoKeyArray[23] + neoKeyArray[24] + "," + neoKeyArray[25] + neoKeyArray[26] + neoKeyArray[27] + neoKeyArray[28] + neoKeyArray[29] + "," + neoKeyArray[30] + neoKeyArray[31] + neoKeyArray[32] + neoKeyArray[33] + neoKeyArray[34] + "," + neoKeyArray[35] + neoKeyArray[36] + neoKeyArray[37] + neoKeyArray[38] + neoKeyArray[39] + "," + neoKeyArray[40] + neoKeyArray[41] + neoKeyArray[42] + neoKeyArray[43] + neoKeyArray[44] + "," + neoKeyArray[45] + neoKeyArray[46] + neoKeyArray[47] + neoKeyArray[48] + neoKeyArray[49] + "," + neoKeyArray[50] + neoKeyArray[51] + neoKeyArray[52] + neoKeyArray[53] + neoKeyArray[54] + "," + neoKeyArray[55] + neoKeyArray[56] + neoKeyArray[57] + neoKeyArray[58] + neoKeyArray[59] + "," + neoKeyArray[60] + neoKeyArray[61] + neoKeyArray[62] + neoKeyArray[63] + neoKeyArray[64] + "," + neoKeyArray[65] + neoKeyArray[66]);
		}
		return neoKeyArray;
	}

	public int GetCVTriggerValue(int hand)
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref neotriggerV, javaCVClass, "getControllerKeyEvent", hand);
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog CVTriggerValue " + neotriggerV[7]);
		}
		return neotriggerV[7];
	}

	public void AutoConnectHbController(int scanTimeMs)
	{
		PLOG.I("PvrLog AutoConnectHbController" + scanTimeMs);
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "autoConnectHbController", scanTimeMs, gameobjname);
	}

	public void StartControllerThread(int headSensorState, int handSensorState)
	{
		if (BoundarySystem.UPvr_IsBoundaryEnable())
		{
			headSensorState = 1;
			handSensorState = 1;
		}
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "startControllerThread", headSensorState, handSensorState);
		Debug.Log("PvrLog StartControllerThread" + headSensorState + handSensorState);
	}

	public void StopControllerThread(int headSensorState, int handSensorState)
	{
		if (BoundarySystem.UPvr_IsBoundaryEnable())
		{
			headSensorState = 1;
			handSensorState = 1;
		}
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "stopControllerThread", headSensorState, handSensorState);
		Debug.Log("PvrLog StopControllerThread" + headSensorState + handSensorState);
	}

	public void SetUnityVersionToJar(string version)
	{
		if (trackingmode == 4 || trackingmode == 5 || trackingmode == 6)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setUnityVersion", version);
		}
		Debug.Log("PvrLog SetUnityVersionToJar" + version);
	}

	public Vector3 GetVelocity(int num)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref velocity, javaCVClass, "getControllerLinearVelocity", num);
		}
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog Velocity" + velocity[0] + "," + velocity[1] + "," + velocity[2]);
		}
		return new Vector3(velocity[0], velocity[1], 0f - velocity[2]);
	}

	public Vector3 GetAngularVelocity(int num)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref angularVelocity, javaCVClass, "getControllerAngularVelocity", num);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref angularVelocity, javaHummingbirdClass, "getHbAngularVelocity");
		}
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog Gyro:" + angularVelocity[0] + "," + angularVelocity[1] + "," + angularVelocity[2]);
		}
		return new Vector3(0f, 0f, 0f);
	}

	public Vector3 GetAcceleration(int num)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref acceData, javaCVClass, "getControllerAcceleration", num);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref acceData, javaHummingbirdClass, "getHbAcceleration");
		}
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog Acce:" + acceData[0] + acceData[1] + acceData[2]);
		}
		return new Vector3(0f, 0f, 0f);
	}

	public string GetConnectedDeviceMac()
	{
		string result = string.Empty;
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getConnectedDeviceMac");
		}
		PLOG.I("PvrLog ConnectedDeviceMac:" + result);
		return result;
	}

	public void VibrateNeo2Controller(float strength, int time, int hand)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "vibrateCV2ControllerStrength", strength, time, hand);
		}
		PLOG.I("PvrLog VibrateNeo2Controller:" + strength + time + hand);
	}

	public int GetMainControllerIndex()
	{
		int result = 0;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getMainControllerIndex");
		}
		PLOG.I("PvrLog GetMainControllerIndex:" + result);
		return result;
	}

	public void SetMainController(int index)
	{
		PLOG.I("PvrLog SetMainController:" + index);
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setMainController", index);
		}
	}

	public void ResetHeadSensorForController()
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "resetHeadSensorForController");
		}
		PLOG.I("PvrLog ResetHeadSensorForController:");
	}

	public void GetDeviceVersion(int deviceType)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "getDeviceVersion", deviceType);
		}
		PLOG.I("PvrLog GetDeviceVersion:" + deviceType);
	}

	public void GetControllerSnCode(int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "getControllerSnCode", controllerSerialNum);
		}
		PLOG.I("PvrLog GetControllerSnCode:" + controllerSerialNum);
	}

	public void SetControllerUnbind(int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setControllerUnbind", controllerSerialNum);
		}
		PLOG.I("PvrLog SetControllerUnbind:" + controllerSerialNum);
	}

	public void SetStationRestart()
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setStationRestart");
		}
		PLOG.I("PvrLog SetStationRestart");
	}

	public void StartStationOtaUpdate()
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "startStationOtaUpdate");
		}
		PLOG.I("PvrLog StartStationOtaUpdate");
	}

	public void StartControllerOtaUpdate(int mode, int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "startControllerOtaUpdate", mode, controllerSerialNum);
		}
		PLOG.I("PvrLog StartControllerOtaUpdate" + mode + controllerSerialNum);
	}

	public void EnterPairMode(int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "enterPairMode", controllerSerialNum);
		}
		PLOG.I("PvrLog EnterPairMode" + controllerSerialNum);
	}

	public void SetControllerShutdown(int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setControllerShutdown", controllerSerialNum);
		}
		PLOG.I("PvrLog SetControllerShutdown" + controllerSerialNum);
	}

	public int GetStationPairState()
	{
		int result = -1;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getStationPairState");
		}
		PLOG.I("PvrLog StationPairState" + result);
		return result;
	}

	public int GetStationOtaUpdateProgress()
	{
		int result = -1;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getStationOtaUpdateProgress");
		}
		PLOG.I("PvrLog StationOtaUpdateProgress" + result);
		return result;
	}

	public int GetControllerOtaUpdateProgress()
	{
		int result = -1;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerOtaUpdateProgress");
		}
		PLOG.I("PvrLog ControllerOtaUpdateProgress" + result);
		return result;
	}

	public void GetControllerVersionAndSN(int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "getControllerVersionAndSN", controllerSerialNum);
		}
		PLOG.I("PvrLog GetControllerVersionAndSN" + controllerSerialNum);
	}

	public void GetControllerUniqueID()
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "getControllerUniqueID");
		}
		PLOG.I("PvrLog GetControllerUniqueID");
	}

	public void InterruptStationPairMode()
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "interruptStationPairMode");
		}
		PLOG.I("PvrLog InterruptStationPairMode");
	}

	public int GetControllerAbility(int controllerSerialNum)
	{
		int result = -1;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerAbility", controllerSerialNum);
		}
		PLOG.I("PvrLog ControllerAbility:" + result);
		return result;
	}

	public void SwitchHomeKey(bool state)
	{
		PLOG.I("PvrLog SwitchHomeKey:" + state);
		switchHomeKey = state;
	}

	public void SetBootReconnect()
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "setBootReconnect");
		PLOG.I("PvrLog SetBootReconnect");
	}

	public int GetTemperature()
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getTemperature");
		PLOG.I("PvrLog Temperature:" + result);
		return result;
	}

	public int GetDeviceType()
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getDeviceType");
		PLOG.I("PvrLog DeviceType:" + result);
		return result;
	}

	public int GetControllerType()
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getControllerType");
		return result;
	}

	public string GetHummingBird2SN()
	{
		string result = string.Empty;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getHummingBird2SN");
		PLOG.I("PvrLog HummingBird2SN:" + result);
		return result;
	}

	public string GetControllerVersion()
	{
		string result = string.Empty;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getControllerVersion");
		PLOG.I("PvrLog ControllerVersion:" + result);
		return result;
	}

	public bool IsEnbleTrigger()
	{
		bool result = false;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "isEnbleTrigger");
		PLOG.I("PvrLog IsEnbleTrigger:" + result);
		return result;
	}

	public void StartCV2PairingMode(int devicetype)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "startCV2PairingMode", devicetype);
		}
		PLOG.I("PvrLog StartCV2PairingMode:" + devicetype);
	}

	public void StopCV2PairingMode(int devicetype)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "stopCV2PairingMode", devicetype);
		}
		PLOG.I("PvrLog StopCV2PairingMode:" + devicetype);
	}

	public int GetControllerBindingState(int id)
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerBindingState", id);
		PLOG.I("PvrLog getControllerBindingState:" + result);
		return result;
	}

	public void setIsEnbleHomeKey(bool state)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setIsEnbleHomeKey", state);
		}
		PLOG.I("PvrLog setIsEnbleHomeKey:" + state);
	}

	public int getControllerSensorStatus(int id)
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerSensorStatus", id);
		PLOG.I("PvrLog getControllerSensorStatus:" + result);
		return result;
	}
}
public class Pvr_ControllerManager : MonoBehaviour
{
	public delegate void PvrServiceStartSuccess();

	public delegate void PvrControllerStateChanged(string data);

	public delegate void ChangeMainControllerCallBack(string index);

	public delegate void ChangeHandNessCallBack(string index);

	public delegate void SetHbServiceBindState();

	public delegate void ControllerThreadStartedCallback();

	public delegate void SetControllerServiceBindState();

	public delegate void ControllerStatusChange(string isconnect);

	public delegate void SetControllerAbility(string data);

	public delegate void SetControllerStateChanged(string data);

	public delegate void SetHbControllerMac(string mac);

	public delegate void ControllerDeviceVersionCallback(string data);

	public delegate void ControllerSnCodeCallback(string data);

	public delegate void ControllerUnbindCallback(string status);

	public delegate void ControllerStationStatusCallback(string status);

	public delegate void ControllerStationBusyCallback(string status);

	public delegate void ControllerOtaStartCodeCallback(string data);

	public delegate void ControllerDeviceVersionAndSNCallback(string data);

	public delegate void ControllerUniqueIDCallback(string data);

	public delegate void ControllerCombinedKeyUnbindCallback(string data);

	private static Pvr_ControllerManager instance;

	public static Pvr_ControllerLink controllerlink;

	private float cTime = 1f;

	private bool stopConnect;

	public Text toast;

	private bool controllerServicestate;

	private float disConnectTime;

	public bool LengthAdaptiveRay;

	private float[] sensorData = new float[28];

	private int[] keyData = new int[134];

	private float[] g2SensorData = new float[4];

	private int[] g2KeyData = new int[47];

	private int keyOffset;

	private int rotControllerMode = 1;

	[CompilerGenerated]
	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private static PvrServiceStartSuccess m_PvrServiceStartSuccessEvent;

	[CompilerGenerated]
	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private static PvrControllerStateChanged m_PvrControllerStateChangedEvent;

	[CompilerGenerated]
	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private static ChangeMainControllerCallBack m_ChangeMainControllerCallBackEvent;

	[CompilerGenerated]
	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private static ChangeHandNessCallBack m_ChangeHandNessCallBackEvent;

	[CompilerGenerated]
	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private static SetHbServiceBindState m_SetHbServiceBindStateEvent;

	[CompilerGenerated]
	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private static ControllerThreadStartedCallback m_ControllerThreadStartedCallbackEvent;

	[CompilerGenerated]
	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private static SetControllerServiceBindState m_SetControllerServiceBindStateEvent;

	[CompilerGenerated]
	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private static ControllerStatusChange m_ControllerStatusChangeEvent;

	[CompilerGenerated]
	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private static SetControllerAbility m_SetControllerAbilityEvent;

	[CompilerGenerated]
	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private static SetControllerStateChanged m_SetControllerStateChangedEvent;

	[CompilerGenerated]
	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private static SetHbControllerMac m_SetHbControllerMacEvent;

	[CompilerGenerated]
	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private static ControllerDeviceVersionCallback m_ControllerDeviceVersionCallbackEvent;

	[CompilerGenerated]
	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private static ControllerSnCodeCallback m_ControllerSnCodeCallbackEvent;

	[CompilerGenerated]
	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private static ControllerUnbindCallback m_ControllerUnbindCallbackEvent;

	[CompilerGenerated]
	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private static ControllerStationStatusCallback m_ControllerStationStatusCallbackEvent;

	[CompilerGenerated]
	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private static ControllerStationBusyCallback m_ControllerStationBusyCallbackEvent;

	[CompilerGenerated]
	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private static ControllerOtaStartCodeCallback m_ControllerOtaStartCodeCallbackEvent;

	[CompilerGenerated]
	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private static ControllerDeviceVersionAndSNCallback m_ControllerDeviceVersionAndSNCallbackEvent;

	[CompilerGenerated]
	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private static ControllerUniqueIDCallback m_ControllerUniqueIDCallbackEvent;

	[CompilerGenerated]
	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private static ControllerCombinedKeyUnbindCallback m_ControllerCombinedKeyUnbindCallbackEvent;

	public static Pvr_ControllerManager Instance
	{
		get
		{
			if (instance == null)
			{
				instance = UnityEngine.Object.FindObjectOfType<Pvr_ControllerManager>();
			}
			if (instance == null)
			{
				GameObject gameObject = new GameObject("GameObject");
				instance = gameObject.AddComponent<Pvr_ControllerManager>();
				gameObject.transform.localPosition = Vector3.zero;
			}
			return instance;
		}
	}

	public static event PvrServiceStartSuccess PvrServiceStartSuccessEvent
	{
		add
		{
			PvrServiceStartSuccess pvrServiceStartSuccess = Pvr_ControllerManager.m_PvrServiceStartSuccessEvent;
			PvrServiceStartSuccess pvrServiceStartSuccess2;
			do
			{
				pvrServiceStartSuccess2 = pvrServiceStartSuccess;
				pvrServiceStartSuccess = Interlocked.CompareExchange(ref Pvr_ControllerManager.m_PvrServiceStartSuccessEvent, (PvrServiceStartSuccess)Delegate.Combine(pvrServiceStartSuccess2, value), pvrServiceStartSuccess);
			}
			while (pvrServiceStartSuccess != pvrServiceStartSuccess2);
		}
		remove
		{
			PvrServiceStartSuccess pvrServiceStartSuccess = Pvr_ControllerManager.m_PvrServiceStartSuccessEvent;
			PvrServiceStartSuccess pvrServiceStartSuccess2;
			do
			{
				pvrServiceStartSuccess2 = pvrServiceStartSuccess;
				pvrServiceStartSuccess = Interlocked.CompareExchange(ref Pvr_ControllerManager.m_PvrServiceStartSuccessEvent, (PvrServiceStartSuccess)Delegate.Remove(pvrServiceStartSuccess2, value), pvrServiceStartSuccess);
			}
			while (pvrServiceStartSuccess != pvrServiceStartSuccess2);
		}
	}

	public static event PvrControllerStateChanged PvrControllerStateChangedEvent
	{
		add
		{
			PvrControllerStateChanged pvrControllerStateChanged = Pvr_ControllerManager.m_PvrControllerStateChangedEvent;
			PvrControllerStateChanged pvrControllerStateChanged2;
			do
			{
				pvrControllerStateChanged2 = pvrControllerStateChanged;
				pvrControllerStateChanged = Interlocked.CompareExchange(ref Pvr_ControllerManager.m_PvrControllerStateChangedEvent, (PvrControllerStateChanged)Delegate.Combine(pvrControllerStateChanged2, value), pvrControllerStateChanged);
			}
			while (pvrControllerStateChanged != pvrControllerStateChanged2);
		}
		remove
		{
			PvrControllerStateChanged pvrControllerStateChanged = Pvr_ControllerManager.m_PvrControllerStateChangedEvent;
			PvrControllerStateChanged pvrControllerStateChanged2;
			do
			{
				pvrControllerStateChanged2 = pvrControllerStateChanged;
				pvrControllerStateChanged = Interlocked.CompareExchange(ref Pvr_ControllerManager.m_PvrControllerStateChangedEvent, (PvrControllerStateChanged)Delegate.Remove(pvrControllerStateChanged2, value), pvrControllerStateChanged);
			}
			while (pvrControllerStateChanged != pvrControllerStateChanged2);
		}
	}

	public static event ChangeMainControllerCallBack ChangeMainControllerCallBackEvent
	{
		add
		{
			ChangeMainControllerCallBack changeMainControllerCallBack = Pvr_ControllerManager.m_ChangeMainControllerCallBackEvent;
			ChangeMainControllerCallBack changeMainControllerCallBack2;
			do
			{
				changeMainControllerCallBack2 = changeMainControllerCallBack;
				changeMainControllerCallBack = Interlocked.CompareExchange(ref Pvr_ControllerManager.m_ChangeMainControllerCallBackEvent, (ChangeMainControllerCallBack)Delegate.Combine(changeMainControllerCallBack2, value), changeMainControllerCallBack);
			}
			while (changeMainControllerCallBack != changeMainControllerCallBack2);
		}
		remove
		{
			ChangeMainControllerCallBack changeMainControllerCallBack = Pvr_ControllerManager.m_ChangeMainControllerCallBackEvent;
			ChangeMainControllerCallBack changeMainControllerCallBack2;
			do
			{
				changeMainControllerCallBack2 = changeMainControllerCallBack;
				changeMainControllerCallBack = Interlocked.CompareExchange(ref Pvr_ControllerManager.m_ChangeMainControllerCallBackEvent, (ChangeMainControllerCallBack)Delegate.Remove(changeMainControllerCallBack2, value), changeMainControllerCallBack);
			}
			while (changeMainControllerCallBack != changeMainControllerCallBack2);
		}
	}

	public static event ChangeHandNessCallBack ChangeHandNessCallBackEvent
	{
		add
		{
			ChangeHandNessCallBack changeHandNessCallBack = Pvr_ControllerManager.m_ChangeHandNessCallBackEvent;
			ChangeHandNessCallBack changeHandNessCallBack2;
			do
			{
				changeHandNessCallBack2 = changeHandNessCallBack;
				changeHandNessCallBack = Interlocked.CompareExchange(ref Pvr_ControllerManager.m_ChangeHandNessCallBackEvent, (ChangeHandNessCallBack)Delegate.Combine(changeHandNessCallBack2, value), changeHandNessCallBack);
			}
			while (changeHandNessCallBack != changeHandNessCallBack2);
		}
		remove
		{
			ChangeHandNessCallBack changeHandNessCallBack = Pvr_ControllerManager.m_ChangeHandNessCallBackEvent;
			ChangeHandNessCallBack changeHandNessCallBack2;
			do
			{
				changeHandNessCallBack2 = changeHandNessCallBack;
				changeHandNessCallBack = Interlocked.CompareExchange(ref Pvr_ControllerManager.m_ChangeHandNessCallBackEvent, (ChangeHandNessCallBack)Delegate.Remove(changeHandNessCallBack2, value), changeHandNessCallBack);
			}
			while (changeHandNessCallBack != changeHandNessCallBack2);
		}
	}

	public static event SetHbServiceBindState SetHbServiceBindStateEvent
	{
		add
		{
			SetHbServiceBindState setHbServiceBindState = Pvr_ControllerManager.m_SetHbServiceBindStateEvent;
			SetHbServiceBindState setHbServiceBindState2;
			do
			{
				setHbServiceBindState2 = setHbServiceBindState;
				setHbServiceBindState = Interlocked.CompareExchange(ref Pvr_ControllerManager.m_SetHbServiceBindStateEvent, (SetHbServiceBindState)Delegate.Combine(setHbServiceBindState2, value), setHbServiceBindState);
			}
			while (setHbServiceBindState != setHbServiceBindState2);
		}
		remove
		{
			SetHbServiceBindState setHbServiceBindState = Pvr_ControllerManager.m_SetHbServiceBindStateEvent;
			SetHbServiceBindState setHbServiceBindState2;
			do
			{
				setHbServiceBindState2 = setHbServiceBindState;
				setHbServiceBindState = Interlocked.CompareExchange(ref Pvr_ControllerManager.m_SetHbServiceBindStateEvent, (SetHbServiceBindState)Delegate.Remove(setHbServiceBindState2, value), setHbServiceBindState);
			}
			while (setHbServiceBindState != setHbServiceBindState2);
		}
	}

	public static event ControllerThreadStartedCallback ControllerThreadStartedCallbackEvent
	{
		add
		{
			ControllerThreadStartedCallback controllerThreadStartedCallback = Pvr_ControllerManager.m_ControllerThreadStartedCallbackEvent;
			ControllerThreadStartedCallback controllerThreadStartedCallback2;
			do
			{
				controllerThreadStartedCallback2 = controllerThreadStartedCallback;
				controllerThreadStartedCallback = Interlocked.CompareExchange(ref Pvr_ControllerManager.m_ControllerThreadStartedCallbackEvent, (ControllerThreadStartedCallback)Delegate.Combine(controllerThreadStartedCallback2, value), controllerThreadStartedCallback);
			}
			while (controllerThreadStartedCallback != controllerThreadStartedCallback2);
		}
		remove
		{
			ControllerThreadStartedCallback controllerThreadStartedCallback = Pvr_ControllerManager.m_ControllerThreadStartedCallbackEvent;
			ControllerThreadStartedCallback controllerThreadStartedCallback2;
			do
			{
				controllerThreadStartedCallback2 = controllerThreadStartedCallback;
				controllerThreadStartedCallback = Interlocked.CompareExchange(ref Pvr_ControllerManager.m_ControllerThreadStartedCallbackEvent, (ControllerThreadStartedCallback)Delegate.Remove(controllerThreadStartedCallback2, value), controllerThreadStartedCallback);
			}
			while (controllerThreadStartedCallback != controllerThreadStartedCallback2);
		}
	}

	public static event SetControllerServiceBindState SetControllerServiceBindStateEvent
	{
		add
		{
			SetControllerServiceBindState setControllerServiceBindState = Pvr_ControllerManager.m_SetControllerServiceBindStateEvent;
			SetControllerServiceBindState setControllerServiceBindState2;
			do
			{
				setControllerServiceBindState2 = setControllerServiceBindState;
				setControllerServiceBindState = Interlocked.CompareExchange(ref Pvr_ControllerManager.m_SetControllerServiceBindStateEvent, (SetControllerServiceBindState)Delegate.Combine(setControllerServiceBindState2, value), setControllerServiceBindState);
			}
			while (setControllerServiceBindState != setControllerServiceBindState2);
		}
		remove
		{
			SetControllerServiceBindState setControllerServiceBindState = Pvr_ControllerManager.m_SetControllerServiceBindStateEvent;
			SetControllerServiceBindState setControllerServiceBindState2;
			do
			{
				setControllerServiceBindState2 = setControllerServiceBindState;
				setControllerServiceBindState = Interlocked.CompareExchange(ref Pvr_ControllerManager.m_SetControllerServiceBindStateEvent, (SetControllerServiceBindState)Delegate.Remove(setControllerServiceBindState2, value), setControllerServiceBindState);
			}
			while (setControllerServiceBindState != setControllerServiceBindState2);
		}
	}

	public static event ControllerStatusChange ControllerStatusChangeEvent
	{
		add
		{
			ControllerStatusChange controllerStatusChange = Pvr_ControllerManager.m_ControllerStatusChangeEvent;
			ControllerStatusChange controllerStatusChange2;
			do
			{
				controllerStatusChange2 = controllerStatusChange;
				controllerStatusChange = Interlocked.CompareExchange(ref Pvr_ControllerManager.m_ControllerStatusChangeEvent, (ControllerStatusChange)Delegate.Combine(controllerStatusChange2, value), controllerStatusChange);
			}
			while (controllerStatusChange != controllerStatusChange2);
		}
		remove
		{
			ControllerStatusChange controllerStatusChange = Pvr_ControllerManager.m_ControllerStatusChangeEvent;
			ControllerStatusChange controllerStatusChange2;
			do
			{
				controllerStatusChange2 = controllerStatusChange;
				controllerStatusChange = Interlocked.CompareExchange(ref Pvr_ControllerManager.m_ControllerStatusChangeEvent, (ControllerStatusChange)Delegate.Remove(controllerStatusChange2, value), controllerStatusChange);
			}
			while (controllerStatusChange != controllerStatusChange2);
		}
	}

	public static event SetControllerAbility SetControllerAbilityEvent
	{
		add
		{
			SetControllerAbility setControllerAbility = Pvr_ControllerManager.m_SetControllerAbilityEvent;
			SetControllerAbility setControllerAbility2;
			do
			{
				setControllerAbility2 = setControllerAbility;
				setControllerAbility = Interlocked.CompareExchange(ref Pvr_ControllerManager.m_SetControllerAbilityEvent, (SetControllerAbility)Delegate.Combine(setControllerAbility2, value), setControllerAbility);
			}
			while (setControllerAbility != setControllerAbility2);
		}
		remove
		{
			SetControllerAbility setControllerAbility = Pvr_ControllerManager.m_SetControllerAbilityEvent;
			SetControllerAbility setControllerAbility2;
			do
			{
				setControllerAbility2 = setControllerAbility;
				setControllerAbility = Interlocked.CompareExchange(ref Pvr_ControllerManager.m_SetControllerAbilityEvent, (SetControllerAbility)Delegate.Remove(setControllerAbility2, value), setControllerAbility);
			}
			while (setControllerAbility != setControllerAbility2);
		}
	}

	public static event SetControllerStateChanged SetControllerStateChangedEvent
	{
		add
		{
			SetControllerStateChanged setControllerStateChanged = Pvr_ControllerManager.m_SetControllerStateChangedEvent;
			SetControllerStateChanged setControllerStateChanged2;
			do
			{
				setControllerStateChanged2 = setControllerStateChanged;
				setControllerStateChanged = Interlocked.CompareExchange(ref Pvr_ControllerManager.m_SetControllerStateChangedEvent, (SetControllerStateChanged)Delegate.Combine(setControllerStateChanged2, value), setControllerStateChanged);
			}
			while (setControllerStateChanged != setControllerStateChanged2);
		}
		remove
		{
			SetControllerStateChanged setControllerStateChanged = Pvr_ControllerManager.m_SetControllerStateChangedEvent;
			SetControllerStateChanged setControllerStateChanged2;
			do
			{
				setControllerStateChanged2 = setControllerStateChanged;
				setControllerStateChanged = Interlocked.CompareExchange(ref Pvr_ControllerManager.m_SetControllerStateChangedEvent, (SetControllerStateChanged)Delegate.Remove(setControllerStateChanged2, value), setControllerStateChanged);
			}
			while (setControllerStateChanged != setControllerStateChanged2);
		}
	}

	public static event SetHbControllerMac SetHbControllerMacEvent
	{
		add
		{
			SetHbControllerMac setHbControllerMac = Pvr_ControllerManager.m_SetHbControllerMacEvent;
			SetHbControllerMac setHbControllerMac2;
			do
			{
				setHbControllerMac2 = setHbControllerMac;
				setHbControllerMac = Interlocked.CompareExchange(ref Pvr_ControllerManager.m_SetHbControllerMacEvent, (SetHbControllerMac)Delegate.Combine(setHbControllerMac2, value), setHbControllerMac);
			}
			while (setHbControllerMac != setHbControllerMac2);
		}
		remove
		{
			SetHbControllerMac setHbControllerMac = Pvr_ControllerManager.m_SetHbControllerMacEvent;
			SetHbControllerMac setHbControllerMac2;
			do
			{
				setHbControllerMac2 = setHbControllerMac;
				setHbControllerMac = Interlocked.CompareExchange(ref Pvr_ControllerManager.m_SetHbControllerMacEvent, (SetHbControllerMac)Delegate.Remove(setHbControllerMac2, value), setHbControllerMac);
			}
			while (setHbControllerMac != setHbControllerMac2);
		}
	}

	public static event ControllerDeviceVersionCallback ControllerDeviceVersionCallbackEvent
	{
		add
		{
			ControllerDeviceVersionCallback controllerDeviceVersionCallback = Pvr_ControllerManager.m_ControllerDeviceVersionCallbackEvent;
			ControllerDeviceVersionCallback controllerDeviceVersionCallback2;
			do
			{
				controllerDeviceVersionCallback2 = controllerDeviceVersionCallback;
				controllerDeviceVersionCallback = Interlocked.CompareExchange(ref Pvr_ControllerManager.m_ControllerDeviceVersionCallbackEvent, (ControllerDeviceVersionCallback)Delegate.Combine(controllerDeviceVersionCallback2, value), controllerDeviceVersionCallback);
			}
			while (controllerDeviceVersionCallback != controllerDeviceVersionCallback2);
		}
		remove
		{
			ControllerDeviceVersionCallback controllerDeviceVersionCallback = Pvr_ControllerManager.m_ControllerDeviceVersionCallbackEvent;
			ControllerDeviceVersionCallback controllerDeviceVersionCallback2;
			do
			{
				controllerDeviceVersionCallback2 = controllerDeviceVersionCallback;
				controllerDeviceVersionCallback = Interlocked.CompareExchange(ref Pvr_ControllerManager.m_ControllerDeviceVersionCallbackEvent, (ControllerDeviceVersionCallback)Delegate.Remove(controllerDeviceVersionCallback2, value), controllerDeviceVersionCallback);
			}
			while (controllerDeviceVersionCallback != controllerDeviceVersionCallback2);
		}
	}

	public static event ControllerSnCodeCallback ControllerSnCodeCallbackEvent
	{
		add
		{
			ControllerSnCodeCallback controllerSnCodeCallback = Pvr_ControllerManager.m_ControllerSnCodeCallbackEvent;
			ControllerSnCodeCallback controllerSnCodeCallback2;
			do
			{
				controllerSnCodeCallback2 = controllerSnCodeCallback;
				controllerSnCodeCallback = Interlocked.CompareExchange(ref Pvr_ControllerManager.m_ControllerSnCodeCallbackEvent, (ControllerSnCodeCallback)Delegate.Combine(controllerSnCodeCallback2, value), controllerSnCodeCallback);
			}
			while (controllerSnCodeCallback != controllerSnCodeCallback2);
		}
		remove
		{
			ControllerSnCodeCallback controllerSnCodeCallback = Pvr_ControllerManager.m_ControllerSnCodeCallbackEvent;
			ControllerSnCodeCallback controllerSnCodeCallback2;
			do
			{
				controllerSnCodeCallback2 = controllerSnCodeCallback;
				controllerSnCodeCallback = Interlocked.CompareExchange(ref Pvr_ControllerManager.m_ControllerSnCodeCallbackEvent, (ControllerSnCodeCallback)Delegate.Remove(controllerSnCodeCallback2, value), controllerSnCodeCallback);
			}
			while (controllerSnCodeCallback != controllerSnCodeCallback2);
		}
	}

	public static event ControllerUnbindCallback ControllerUnbindCallbackEvent
	{
		add
		{
			ControllerUnbindCallback controllerUnbindCallback = Pvr_ControllerManager.m_ControllerUnbindCallbackEvent;
			ControllerUnbindCallback controllerUnbindCallback2;
			do
			{
				controllerUnbindCallback2 = controllerUnbindCallback;
				controllerUnbindCallback = Interlocked.CompareExchange(ref Pvr_ControllerManager.m_ControllerUnbindCallbackEvent, (ControllerUnbindCallback)Delegate.Combine(controllerUnbindCallback2, value), controllerUnbindCallback);
			}
			while (controllerUnbindCallback != controllerUnbindCallback2);
		}
		remove
		{
			ControllerUnbindCallback controllerUnbindCallback = Pvr_ControllerManager.m_ControllerUnbindCallbackEvent;
			ControllerUnbindCallback controllerUnbindCallback2;
			do
			{
				controllerUnbindCallback2 = controllerUnbindCallback;
				controllerUnbindCallback = Interlocked.CompareExchange(ref Pvr_ControllerManager.m_ControllerUnbindCallbackEvent, (ControllerUnbindCallback)Delegate.Remove(controllerUnbindCallback2, value), controllerUnbindCallback);
			}
			while (controllerUnbindCallback != controllerUnbindCallback2);
		}
	}

	public static event ControllerStationStatusCallback ControllerStationStatusCallbackEvent
	{
		add
		{
			ControllerStationStatusCallback controllerStationStatusCallback = Pvr_ControllerManager.m_ControllerStationStatusCallbackEvent;
			ControllerStationStatusCallback controllerStationStatusCallback2;
			do
			{
				controllerStationStatusCallback2 = controllerStationStatusCallback;
				controllerStationStatusCallback = Interlocked.CompareExchange(ref Pvr_ControllerManager.m_ControllerStationStatusCallbackEvent, (ControllerStationStatusCallback)Delegate.Combine(controllerStationStatusCallback2, value), controllerStationStatusCallback);
			}
			while (controllerStationStatusCallback != controllerStationStatusCallback2);
		}
		remove
		{
			ControllerStationStatusCallback controllerStationStatusCallback = Pvr_ControllerManager.m_ControllerStationStatusCallbackEvent;
			ControllerStationStatusCallback controllerStationStatusCallback2;
			do
			{
				controllerStationStatusCallback2 = controllerStationStatusCallback;
				controllerStationStatusCallback = Interlocked.CompareExchange(ref Pvr_ControllerManager.m_ControllerStationStatusCallbackEvent, (ControllerStationStatusCallback)Delegate.Remove(controllerStationStatusCallback2, value), controllerStationStatusCallback);
			}
			while (controllerStationStatusCallback != controllerStationStatusCallback2);
		}
	}

	public static event ControllerStationBusyCallback ControllerStationBusyCallbackEvent
	{
		add
		{
			ControllerStationBusyCallback controllerStationBusyCallback = Pvr_ControllerManager.m_ControllerStationBusyCallbackEvent;
			ControllerStationBusyCallback controllerStationBusyCallback2;
			do
			{
				controllerStationBusyCallback2 = controllerStationBusyCallback;
				controllerStationBusyCallback = Interlocked.CompareExchange(ref Pvr_ControllerManager.m_ControllerStationBusyCallbackEvent, (ControllerStationBusyCallback)Delegate.Combine(controllerStationBusyCallback2, value), controllerStationBusyCallback);
			}
			while (controllerStationBusyCallback != controllerStationBusyCallback2);
		}
		remove
		{
			ControllerStationBusyCallback controllerStationBusyCallback = Pvr_ControllerManager.m_ControllerStationBusyCallbackEvent;
			ControllerStationBusyCallback controllerStationBusyCallback2;
			do
			{
				controllerStationBusyCallback2 = controllerStationBusyCallback;
				controllerStationBusyCallback = Interlocked.CompareExchange(ref Pvr_ControllerManager.m_ControllerStationBusyCallbackEvent, (ControllerStationBusyCallback)Delegate.Remove(controllerStationBusyCallback2, value), controllerStationBusyCallback);
			}
			while (controllerStationBusyCallback != controllerStationBusyCallback2);
		}
	}

	public static event ControllerOtaStartCodeCallback ControllerOtaStartCodeCallbackEvent
	{
		add
		{
			ControllerOtaStartCodeCallback controllerOtaStartCodeCallback = Pvr_ControllerManager.m_ControllerOtaStartCodeCallbackEvent;
			ControllerOtaStartCodeCallback controllerOtaStartCodeCallback2;
			do
			{
				controllerOtaStartCodeCallback2 = controllerOtaStartCodeCallback;
				controllerOtaStartCodeCallback = Interlocked.CompareExchange(ref Pvr_ControllerManager.m_ControllerOtaStartCodeCallbackEvent, (ControllerOtaStartCodeCallback)Delegate.Combine(controllerOtaStartCodeCallback2, value), controllerOtaStartCodeCallback);
			}
			while (controllerOtaStartCodeCallback != controllerOtaStartCodeCallback2);
		}
		remove
		{
			ControllerOtaStartCodeCallback controllerOtaStartCodeCallback = Pvr_ControllerManager.m_ControllerOtaStartCodeCallbackEvent;
			ControllerOtaStartCodeCallback controllerOtaStartCodeCallback2;
			do
			{
				controllerOtaStartCodeCallback2 = controllerOtaStartCodeCallback;
				controllerOtaStartCodeCallback = Interlocked.CompareExchange(ref Pvr_ControllerManager.m_ControllerOtaStartCodeCallbackEvent, (ControllerOtaStartCodeCallback)Delegate.Remove(controllerOtaStartCodeCallback2, value), controllerOtaStartCodeCallback);
			}
			while (controllerOtaStartCodeCallback != controllerOtaStartCodeCallback2);
		}
	}

	public static event ControllerDeviceVersionAndSNCallback ControllerDeviceVersionAndSNCallbackEvent
	{
		add
		{
			ControllerDeviceVersionAndSNCallback controllerDeviceVersionAndSNCallback = Pvr_ControllerManager.m_ControllerDeviceVersionAndSNCallbackEvent;
			ControllerDeviceVersionAndSNCallback controllerDeviceVersionAndSNCallback2;
			do
			{
				controllerDeviceVersionAndSNCallback2 = controllerDeviceVersionAndSNCallback;
				controllerDeviceVersionAndSNCallback = Interlocked.CompareExchange(ref Pvr_ControllerManager.m_ControllerDeviceVersionAndSNCallbackEvent, (ControllerDeviceVersionAndSNCallback)Delegate.Combine(controllerDeviceVersionAndSNCallback2, value), controllerDeviceVersionAndSNCallback);
			}
			while (controllerDeviceVersionAndSNCallback != controllerDeviceVersionAndSNCallback2);
		}
		remove
		{
			ControllerDeviceVersionAndSNCallback controllerDeviceVersionAndSNCallback = Pvr_ControllerManager.m_ControllerDeviceVersionAndSNCallbackEvent;
			ControllerDeviceVersionAndSNCallback controllerDeviceVersionAndSNCallback2;
			do
			{
				controllerDeviceVersionAndSNCallback2 = controllerDeviceVersionAndSNCallback;
				controllerDeviceVersionAndSNCallback = Interlocked.CompareExchange(ref Pvr_ControllerManager.m_ControllerDeviceVersionAndSNCallbackEvent, (ControllerDeviceVersionAndSNCallback)Delegate.Remove(controllerDeviceVersionAndSNCallback2, value), controllerDeviceVersionAndSNCallback);
			}
			while (controllerDeviceVersionAndSNCallback != controllerDeviceVersionAndSNCallback2);
		}
	}

	public static event ControllerUniqueIDCallback ControllerUniqueIDCallbackEvent
	{
		add
		{
			ControllerUniqueIDCallback controllerUniqueIDCallback = Pvr_ControllerManager.m_ControllerUniqueIDCallbackEvent;
			ControllerUniqueIDCallback controllerUniqueIDCallback2;
			do
			{
				controllerUniqueIDCallback2 = controllerUniqueIDCallback;
				controllerUniqueIDCallback = Interlocked.CompareExchange(ref Pvr_ControllerManager.m_ControllerUniqueIDCallbackEvent, (ControllerUniqueIDCallback)Delegate.Combine(controllerUniqueIDCallback2, value), controllerUniqueIDCallback);
			}
			while (controllerUniqueIDCallback != controllerUniqueIDCallback2);
		}
		remove
		{
			ControllerUniqueIDCallback controllerUniqueIDCallback = Pvr_ControllerManager.m_ControllerUniqueIDCallbackEvent;
			ControllerUniqueIDCallback controllerUniqueIDCallback2;
			do
			{
				controllerUniqueIDCallback2 = controllerUniqueIDCallback;
				controllerUniqueIDCallback = Interlocked.CompareExchange(ref Pvr_ControllerManager.m_ControllerUniqueIDCallbackEvent, (ControllerUniqueIDCallback)Delegate.Remove(controllerUniqueIDCallback2, value), controllerUniqueIDCallback);
			}
			while (controllerUniqueIDCallback != controllerUniqueIDCallback2);
		}
	}

	public static event ControllerCombinedKeyUnbindCallback ControllerCombinedKeyUnbindCallbackEvent
	{
		add
		{
			ControllerCombinedKeyUnbindCallback controllerCombinedKeyUnbindCallback = Pvr_ControllerManager.m_ControllerCombinedKeyUnbindCallbackEvent;
			ControllerCombinedKeyUnbindCallback controllerCombinedKeyUnbindCallback2;
			do
			{
				controllerCombinedKeyUnbindCallback2 = controllerCombinedKeyUnbindCallback;
				controllerCombinedKeyUnbindCallback = Interlocked.CompareExchange(ref Pvr_ControllerManager.m_ControllerCombinedKeyUnbindCallbackEvent, (ControllerCombinedKeyUnbindCallback)Delegate.Combine(controllerCombinedKeyUnbindCallback2, value), controllerCombinedKeyUnbindCallback);
			}
			while (controllerCombinedKeyUnbindCallback != controllerCombinedKeyUnbindCallback2);
		}
		remove
		{
			ControllerCombinedKeyUnbindCallback controllerCombinedKeyUnbindCallback = Pvr_ControllerManager.m_ControllerCombinedKeyUnbindCallbackEvent;
			ControllerCombinedKeyUnbindCallback controllerCombinedKeyUnbindCallback2;
			do
			{
				controllerCombinedKeyUnbindCallback2 = controllerCombinedKeyUnbindCallback;
				controllerCombinedKeyUnbindCallback = Interlocked.CompareExchange(ref Pvr_ControllerManager.m_ControllerCombinedKeyUnbindCallbackEvent, (ControllerCombinedKeyUnbindCallback)Delegate.Remove(controllerCombinedKeyUnbindCallback2, value), controllerCombinedKeyUnbindCallback);
			}
			while (controllerCombinedKeyUnbindCallback != controllerCombinedKeyUnbindCallback2);
		}
	}

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
		if (instance != this)
		{
			PLOG.E("instance object should be a singleton.");
			return;
		}
		if (controllerlink == null)
		{
			controllerlink = new Pvr_ControllerLink(base.gameObject.name);
			return;
		}
		controllerlink.SetGameObjectToJar(base.gameObject.name);
		BindService();
	}

	private void Start()
	{
		if (controllerlink.trackingmode < 2)
		{
			Invoke("CheckControllerService", 10f);
		}
		Render.UPvr_GetIntConfig(23, ref rotControllerMode);
	}

	private void Update()
	{
		if (controllerlink.neoserviceStarted)
		{
			sensorData = controllerlink.GetControllerSensorData();
			keyData = controllerlink.GetControllerKeyData();
			if (controllerlink.controller0Connected)
			{
				if (Pvr_UnitySDKManager.SDK.ShowVideoSeethrough)
				{
					sensorData[2] = 0f - sensorData[2];
					sensorData[3] = 0f - sensorData[3];
					controllerlink.Controller0.Rotation.Set(sensorData[0], sensorData[1], sensorData[2], sensorData[3]);
					if (rotControllerMode == 0)
					{
						controllerlink.Controller0.Rotation *= Quaternion.Euler(34f, 0f, 0f);
					}
					controllerlink.Controller0.Position.Set(sensorData[4] / 1000f, sensorData[5] / 1000f, (0f - sensorData[6]) / 1000f);
				}
				else
				{
					controllerlink.Controller0.Rotation.Set(sensorData[7], sensorData[8], sensorData[9], sensorData[10]);
					if (rotControllerMode == 0)
					{
						controllerlink.Controller0.Rotation *= Quaternion.Euler(34f, 0f, 0f);
					}
					controllerlink.Controller0.Position.Set(sensorData[11] / 1000f, sensorData[12] / 1000f, (0f - sensorData[13]) / 1000f);
				}
				if (!controllerlink.Controller0.isShowBoundary)
				{
					if (controllerlink.getControllerSensorStatus(0) == 0)
					{
						Sensor.UPvr_SetReinPosition(sensorData[0], sensorData[1], sensorData[2], sensorData[3], sensorData[4], sensorData[5], sensorData[6], 0, valid: false, 0);
					}
					else
					{
						controllerlink.Controller0.isShowBoundary = true;
						Sensor.UPvr_SetReinPosition(sensorData[0], sensorData[1], sensorData[2], sensorData[3], sensorData[4], sensorData[5], sensorData[6], 0, valid: true, Convert.ToInt32(Convert.ToString(keyData[35]) + Convert.ToString(keyData[15]) + "00", 2));
					}
				}
				else
				{
					Sensor.UPvr_SetReinPosition(sensorData[0], sensorData[1], sensorData[2], sensorData[3], sensorData[4], sensorData[5], sensorData[6], 0, valid: true, Convert.ToInt32(Convert.ToString(keyData[35]) + Convert.ToString(keyData[15]) + "00", 2));
				}
				TransformData(controllerlink.Controller0, 0, keyData);
			}
			else
			{
				Sensor.UPvr_SetReinPosition(sensorData[0], sensorData[1], sensorData[2], sensorData[3], sensorData[4], sensorData[5], sensorData[6], 0, valid: false, 0);
			}
			if (controllerlink.controller1Connected)
			{
				if (Pvr_UnitySDKManager.SDK.ShowVideoSeethrough)
				{
					sensorData[16] = 0f - sensorData[16];
					sensorData[17] = 0f - sensorData[17];
					controllerlink.Controller1.Rotation.Set(sensorData[14], sensorData[15], sensorData[16], sensorData[17]);
					if (rotControllerMode == 0)
					{
						controllerlink.Controller1.Rotation *= Quaternion.Euler(34f, 0f, 0f);
					}
					controllerlink.Controller1.Position.Set(sensorData[18] / 1000f, sensorData[19] / 1000f, (0f - sensorData[20]) / 1000f);
				}
				else
				{
					controllerlink.Controller1.Rotation.Set(sensorData[21], sensorData[22], sensorData[23], sensorData[24]);
					if (rotControllerMode == 0)
					{
						controllerlink.Controller1.Rotation *= Quaternion.Euler(34f, 0f, 0f);
					}
					controllerlink.Controller1.Position.Set(sensorData[25] / 1000f, sensorData[26] / 1000f, (0f - sensorData[27]) / 1000f);
				}
				if (!controllerlink.Controller1.isShowBoundary)
				{
					if (controllerlink.getControllerSensorStatus(1) == 0)
					{
						Sensor.UPvr_SetReinPosition(sensorData[14], sensorData[15], sensorData[16], sensorData[17], sensorData[18], sensorData[19], sensorData[20], 1, valid: false, 0);
					}
					else
					{
						controllerlink.Controller1.isShowBoundary = true;
						Sensor.UPvr_SetReinPosition(sensorData[14], sensorData[15], sensorData[16], sensorData[17], sensorData[18], sensorData[19], sensorData[20], 1, valid: true, Convert.ToInt32(Convert.ToString(keyData[102]) + Convert.ToString(keyData[82]) + "00", 2));
					}
				}
				else
				{
					Sensor.UPvr_SetReinPosition(sensorData[14], sensorData[15], sensorData[16], sensorData[17], sensorData[18], sensorData[19], sensorData[20], 1, valid: true, Convert.ToInt32(Convert.ToString(keyData[102]) + Convert.ToString(keyData[82]) + "00", 2));
				}
				TransformData(controllerlink.Controller1, 1, keyData);
			}
			else
			{
				Sensor.UPvr_SetReinPosition(sensorData[14], sensorData[15], sensorData[16], sensorData[17], sensorData[18], sensorData[19], sensorData[20], 1, valid: false, 0);
			}
		}
		if (controllerlink.goblinserviceStarted && controllerlink.controller0Connected)
		{
			g2SensorData = controllerlink.GetHBControllerPoseData();
			controllerlink.Controller0.Rotation.Set(g2SensorData[0], g2SensorData[1], g2SensorData[2], g2SensorData[3]);
			g2KeyData = controllerlink.GetHBControllerKeyData();
			TransformData(controllerlink.Controller0, 0, g2KeyData);
		}
		SetSystemKey();
	}

	private void OnApplicationPause(bool pause)
	{
		int headSensorState = ((!Pvr_UnitySDKManager.SDK.HmdOnlyrot) ? 1 : 0);
		int handSensorState = ((!Pvr_UnitySDKManager.SDK.ControllerOnlyrot) ? 1 : 0);
		if (pause)
		{
			if (controllerlink.neoserviceStarted)
			{
				controllerlink.SetGameObjectToJar(string.Empty);
				controllerlink.StopControllerThread(headSensorState, handSensorState);
			}
			if (controllerlink.goblinserviceStarted)
			{
				controllerlink.StopLark2Receiver();
			}
			return;
		}
		controllerlink.Controller0 = new ControllerHand();
		controllerlink.Controller1 = new ControllerHand();
		if (controllerlink.neoserviceStarted)
		{
			controllerlink.SetGameObjectToJar(base.gameObject.name);
			controllerlink.SetUnityVersionToJar("2.8.9.10");
			controllerlink.StartControllerThread(headSensorState, handSensorState);
		}
		if (controllerlink.goblinserviceStarted)
		{
			controllerlink.StartLark2Receiver();
			controllerlink.controller0Connected = GetControllerConnectionState(0) == 1;
			controllerlink.controllerType = controllerlink.GetControllerType();
			controllerlink.handness = (Pvr_Controller.UserHandNess)controllerlink.getHandness();
			if (Pvr_ControllerManager.PvrServiceStartSuccessEvent != null)
			{
				Pvr_ControllerManager.PvrServiceStartSuccessEvent();
			}
		}
	}

	private void OnDestroy()
	{
		controllerlink.UnBindService();
		Sensor.UPvr_SetReinPosition(0f, 0f, 0f, 1f, 0f, 0f, 0f, 0, valid: false, 0);
		Sensor.UPvr_SetReinPosition(0f, 0f, 0f, 1f, 0f, 0f, 0f, 1, valid: false, 0);
	}

	private void OnApplicationQuit()
	{
		int headSensorState = ((!Pvr_UnitySDKManager.SDK.HmdOnlyrot) ? 1 : 0);
		int handSensorState = ((!Pvr_UnitySDKManager.SDK.ControllerOnlyrot) ? 1 : 0);
		if (controllerlink.neoserviceStarted)
		{
			controllerlink.SetGameObjectToJar(string.Empty);
			controllerlink.StopControllerThread(headSensorState, handSensorState);
		}
	}

	public void StopLark2Service()
	{
		if (controllerlink != null)
		{
			controllerlink.StopLark2Service();
		}
	}

	public Vector3 GetAngularVelocity(int num)
	{
		if (controllerlink != null)
		{
			return controllerlink.GetAngularVelocity(num);
		}
		return new Vector3(0f, 0f, 0f);
	}

	public Vector3 GetAcceleration(int num)
	{
		if (controllerlink != null)
		{
			return controllerlink.GetAcceleration(num);
		}
		return new Vector3(0f, 0f, 0f);
	}

	public void BindService()
	{
		if (controllerlink != null)
		{
			controllerlink.BindService();
		}
	}

	public void StartScan()
	{
		if (controllerlink != null)
		{
			controllerlink.StartScan();
		}
	}

	public void StopScan()
	{
		if (controllerlink != null)
		{
			controllerlink.StopScan();
		}
	}

	public void ResetController(int num)
	{
		if (controllerlink != null)
		{
			controllerlink.ResetController(num);
		}
	}

	public static int GetControllerConnectionState(int num)
	{
		return controllerlink.GetControllerConnectionState(num);
	}

	public void ConnectBLE()
	{
		if (controllerlink != null)
		{
			controllerlink.ConnectBLE();
		}
	}

	public void DisConnectBLE()
	{
		if (controllerlink != null)
		{
			controllerlink.DisConnectBLE();
		}
	}

	public void SetBinPath(string path, bool isAsset)
	{
		if (controllerlink != null)
		{
			controllerlink.setBinPath(path, isAsset);
		}
	}

	public void StartUpgrade()
	{
		if (controllerlink != null)
		{
			controllerlink.StartUpgrade();
		}
	}

	public static string GetBLEImageType()
	{
		return controllerlink.GetBLEImageType();
	}

	public static long GetBLEVersion()
	{
		return controllerlink.GetBLEVersion();
	}

	public static string GetFileImageType()
	{
		return controllerlink.GetFileImageType();
	}

	public static long GetFileVersion()
	{
		return controllerlink.GetFileVersion();
	}

	public static void AutoConnectHbController(int scans)
	{
		if (controllerlink != null)
		{
			controllerlink.AutoConnectHbController(scans);
		}
	}

	public static string GetConnectedDeviceMac()
	{
		string result = string.Empty;
		if (controllerlink != null)
		{
			result = controllerlink.GetConnectedDeviceMac();
		}
		return result;
	}

	public void setHbControllerMac(string mac)
	{
		PLOG.I("PvrLog HBMacRSSI" + mac);
		controllerlink.hummingBirdMac = mac.Substring(0, 17);
		controllerlink.hummingBirdRSSI = Convert.ToInt16(mac.Remove(0, 18));
		if (Pvr_ControllerManager.SetHbControllerMacEvent != null)
		{
			Pvr_ControllerManager.SetHbControllerMacEvent(mac.Substring(0, 17));
		}
	}

	public int GetControllerRSSI()
	{
		return controllerlink.hummingBirdRSSI;
	}

	public void setHbServiceBindState(string state)
	{
		PLOG.I("PvrLog HBBindCallBack" + state);
		controllerServicestate = true;
		if (Convert.ToInt16(state) == 0)
		{
			Invoke("BindService", 0.5f);
			controllerlink.goblinserviceStarted = false;
		}
		else if (Convert.ToInt16(state) == 1)
		{
			controllerlink.goblinserviceStarted = true;
			controllerlink.controller0Connected = GetControllerConnectionState(0) == 1;
			controllerlink.controllerType = controllerlink.GetControllerType();
			controllerlink.handness = (Pvr_Controller.UserHandNess)controllerlink.getHandness();
			if (Pvr_ControllerManager.SetHbServiceBindStateEvent != null)
			{
				Pvr_ControllerManager.SetHbServiceBindStateEvent();
			}
			if (Pvr_ControllerManager.PvrServiceStartSuccessEvent != null)
			{
				Pvr_ControllerManager.PvrServiceStartSuccessEvent();
			}
		}
	}

	public void setControllerServiceBindState(string state)
	{
		PLOG.I("PvrLog CVBindCallBack" + state);
		if (Convert.ToInt16(state) == 0)
		{
			Invoke("BindService", 0.5f);
			controllerlink.neoserviceStarted = false;
		}
		else if (Convert.ToInt16(state) == 1)
		{
			controllerlink.SetUnityVersionToJar("2.8.9.10");
			controllerlink.neoserviceStarted = true;
			int headSensorState = ((!Pvr_UnitySDKManager.SDK.HmdOnlyrot) ? 1 : 0);
			int handSensorState = ((!Pvr_UnitySDKManager.SDK.ControllerOnlyrot) ? 1 : 0);
			controllerlink.StartControllerThread(headSensorState, handSensorState);
			if (Pvr_ControllerManager.SetControllerServiceBindStateEvent != null)
			{
				Pvr_ControllerManager.SetControllerServiceBindStateEvent();
			}
		}
	}

	public void setHbControllerConnectState(string isconnect)
	{
		PLOG.I("PvrLog HBControllerConnect" + isconnect);
		controllerlink.controller0Connected = Convert.ToInt16(isconnect) == 1;
		if (!controllerlink.controller0Connected)
		{
			controllerlink.Controller0 = new ControllerHand();
		}
		else
		{
			ResetController(0);
			controllerlink.controllerType = controllerlink.GetControllerType();
			controllerlink.handness = (Pvr_Controller.UserHandNess)controllerlink.getHandness();
		}
		stopConnect = false;
		if (Pvr_ControllerManager.ControllerStatusChangeEvent != null)
		{
			Pvr_ControllerManager.ControllerStatusChangeEvent(isconnect);
		}
		if (Pvr_ControllerManager.PvrControllerStateChangedEvent != null)
		{
			Pvr_ControllerManager.PvrControllerStateChangedEvent(isconnect);
		}
	}

	public void setControllerStateChanged(string state)
	{
		PLOG.I("PvrLog CVControllerStateChanged" + state);
		int num = Convert.ToInt16(state.Substring(0, 1));
		if (num == 0)
		{
			controllerlink.controller0Connected = Convert.ToBoolean(Convert.ToInt16(state.Substring(2, 1)));
			if (!controllerlink.controller0Connected)
			{
				controllerlink.Controller0 = new ControllerHand();
				controllerlink.Controller0.Position = new Vector3(0f, Pvr_UnitySDKSensor.Instance.HeadPose.Position.y, 0f) + new Vector3(-0.1f, -0.3f, 0.3f);
			}
		}
		else
		{
			controllerlink.controller1Connected = Convert.ToBoolean(Convert.ToInt16(state.Substring(2, 1)));
			if (!controllerlink.controller1Connected)
			{
				controllerlink.Controller1 = new ControllerHand();
				controllerlink.Controller1.Position = new Vector3(0f, Pvr_UnitySDKSensor.Instance.HeadPose.Position.y, 0f) + new Vector3(0.1f, -0.3f, 0.3f);
			}
		}
		if (Convert.ToBoolean(Convert.ToInt16(state.Substring(2, 1))))
		{
			controllerlink.controllerType = controllerlink.GetControllerType();
			controllerlink.ResetController(num);
		}
		controllerlink.handness = (Pvr_Controller.UserHandNess)controllerlink.getHandness();
		controllerlink.mainHandID = controllerlink.GetMainControllerIndex();
		if (Pvr_ControllerManager.SetControllerStateChangedEvent != null)
		{
			Pvr_ControllerManager.SetControllerStateChangedEvent(state);
		}
		if (Pvr_ControllerManager.PvrControllerStateChangedEvent != null)
		{
			Pvr_ControllerManager.PvrControllerStateChangedEvent(state);
		}
	}

	public void setControllerAbility(string data)
	{
		PLOG.I("PvrLog setControllerAbility" + data);
		if (Pvr_ControllerManager.SetControllerAbilityEvent != null)
		{
			Pvr_ControllerManager.SetControllerAbilityEvent(data);
		}
	}

	public void controllerThreadStartedCallback()
	{
		PLOG.I("PvrLog ThreadStartSuccess");
		GetCVControllerState();
		if (Pvr_ControllerManager.ControllerThreadStartedCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerThreadStartedCallbackEvent();
		}
		if (Pvr_ControllerManager.PvrServiceStartSuccessEvent != null)
		{
			Pvr_ControllerManager.PvrServiceStartSuccessEvent();
		}
	}

	public void controllerDeviceVersionCallback(string data)
	{
		PLOG.I("PvrLog VersionCallBack" + data);
		if (Pvr_ControllerManager.ControllerDeviceVersionCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerDeviceVersionCallbackEvent(data);
		}
	}

	public void controllerSnCodeCallback(string data)
	{
		PLOG.I("PvrLog SNCodeCallBack" + data);
		if (Pvr_ControllerManager.ControllerSnCodeCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerSnCodeCallbackEvent(data);
		}
	}

	public void controllerUnbindCallback(string status)
	{
		PLOG.I("PvrLog ControllerUnBindCallBack" + status);
		if (Pvr_ControllerManager.ControllerUnbindCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerUnbindCallbackEvent(status);
		}
	}

	public void controllerStationStatusCallback(string status)
	{
		PLOG.I("PvrLog StationStatusCallBack" + status);
		if (Pvr_ControllerManager.ControllerStationStatusCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerStationStatusCallbackEvent(status);
		}
	}

	public void controllerStationBusyCallback(string status)
	{
		PLOG.I("PvrLog StationBusyCallBack" + status);
		if (Pvr_ControllerManager.ControllerStationBusyCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerStationBusyCallbackEvent(status);
		}
	}

	public void controllerOTAStartCodeCallback(string data)
	{
		PLOG.I("PvrLog OTAUpdateCallBack" + data);
		if (Pvr_ControllerManager.ControllerOtaStartCodeCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerOtaStartCodeCallbackEvent(data);
		}
	}

	public void controllerDeviceVersionAndSNCallback(string data)
	{
		PLOG.I("PvrLog DeviceVersionAndSNCallback" + data);
		if (Pvr_ControllerManager.ControllerDeviceVersionAndSNCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerDeviceVersionAndSNCallbackEvent(data);
		}
	}

	public void controllerUniqueIDCallback(string data)
	{
		PLOG.I("PvrLog controllerUniqueIDCallback" + data);
		if (Pvr_ControllerManager.ControllerUniqueIDCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerUniqueIDCallbackEvent(data);
		}
	}

	public void controllerCombinedKeyUnbindCallback(string controllerSerialNum)
	{
		if (Pvr_ControllerManager.ControllerCombinedKeyUnbindCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerCombinedKeyUnbindCallbackEvent(controllerSerialNum);
		}
	}

	public void setupdateFailed()
	{
	}

	public void setupdateSuccess()
	{
	}

	public void setupdateProgress(string progress)
	{
	}

	public void setHbAutoConnectState(string state)
	{
		PLOG.I("PvrLog HBAutoConnectState" + state);
		controllerServicestate = true;
		if (Convert.ToInt16(state) == 0 && GetControllerConnectionState(0) == 0)
		{
			ShowToast(2);
		}
		if (Convert.ToInt16(state) == 2)
		{
			ShowToast(3);
		}
	}

	public void callbackControllerServiceState(string state)
	{
		PLOG.I("PvrLog HBServiceState" + state);
		controllerServicestate = true;
		if (Convert.ToInt16(state) == 0)
		{
			ShowToast(0);
		}
		if (Convert.ToInt16(state) == 1)
		{
			BindService();
		}
		if (Convert.ToInt16(state) == 2)
		{
			ShowToast(1);
		}
	}

	public void changeMainControllerCallback(string index)
	{
		PLOG.I("PvrLog MainControllerCallBack" + index);
		controllerlink.mainHandID = Convert.ToInt16(index);
		if (Pvr_ControllerManager.ChangeMainControllerCallBackEvent != null)
		{
			Pvr_ControllerManager.ChangeMainControllerCallBackEvent(index);
		}
	}

	public void changeHandnessCallback(string index)
	{
		PLOG.I("PvrLog changeHandnessCallback" + index);
		controllerlink.handness = (Pvr_Controller.UserHandNess)Convert.ToInt16(index);
		if (Pvr_ControllerManager.ChangeHandNessCallBackEvent != null)
		{
			Pvr_ControllerManager.ChangeHandNessCallBackEvent(index);
		}
	}

	private void ShowToast(int type)
	{
		if (toast != null)
		{
			switch (type)
			{
			case 0:
				toast.text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("servicetip0");
				Invoke("HideToast", 5f);
				break;
			case 1:
				toast.text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("servicetip1");
				Invoke("HideToast", 5f);
				break;
			case 2:
				toast.text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("servicetip2");
				AutoConnectHbController(6000);
				Invoke("HideToast", 5f);
				break;
			case 3:
				toast.text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("servicetip3");
				AutoConnectHbController(6000);
				Invoke("HideToast", 5f);
				break;
			case 4:
				toast.text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("servicetip4");
				Invoke("HideToast", 10f);
				break;
			}
		}
	}

	private void HideToast()
	{
		if (toast != null)
		{
			toast.text = string.Empty;
		}
	}

	private void CheckControllerService()
	{
		if (!controllerServicestate)
		{
			ShowToast(4);
		}
	}

	private void GetCVControllerState()
	{
		int controllerConnectionState = GetControllerConnectionState(0);
		int controllerConnectionState2 = GetControllerConnectionState(1);
		PLOG.I("PvrLog CVconnect" + controllerConnectionState + controllerConnectionState2);
		if (controllerConnectionState == -1 && controllerConnectionState2 == -1)
		{
			Invoke("GetCVControllerState", 0.02f);
		}
		if (controllerConnectionState != -1 && controllerConnectionState2 != -1)
		{
			controllerlink.controller0Connected = controllerConnectionState == 1;
			controllerlink.controller1Connected = controllerConnectionState2 == 1;
			if (!controllerlink.controller0Connected && controllerlink.controller1Connected && controllerlink.GetMainControllerIndex() == 0)
			{
				Controller.UPvr_SetMainHandNess(1);
			}
			if (controllerlink.controller0Connected || controllerlink.controller1Connected)
			{
				controllerlink.controllerType = controllerlink.GetControllerType();
			}
			controllerlink.mainHandID = controllerlink.GetMainControllerIndex();
			controllerlink.handness = (Pvr_Controller.UserHandNess)controllerlink.getHandness();
		}
	}

	private void SetSystemKey()
	{
		if (controllerlink.switchHomeKey && (Controller.UPvr_GetKeyLongPressed(0, Pvr_KeyCode.HOME) || Controller.UPvr_GetKeyLongPressed(1, Pvr_KeyCode.HOME)))
		{
			if (Pvr_UnitySDKManager.SDK.HmdOnlyrot)
			{
				Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 0);
			}
			else if (controllerlink.trackingmode == 0 || controllerlink.trackingmode == 1)
			{
				Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
			}
			else
			{
				Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
			}
			if (Pvr_UnitySDKManager.SDK.ControllerOnlyrot || (controllerlink.controller0Connected && Controller.UPvr_GetControllerPOS(0).Equals(Vector3.zero)) || (controllerlink.controller1Connected && Controller.UPvr_GetControllerPOS(1).Equals(Vector3.zero)))
			{
				if (Controller.UPvr_GetKeyLongPressed(0, Pvr_KeyCode.HOME))
				{
					ResetController(0);
				}
				if (Controller.UPvr_GetKeyLongPressed(1, Pvr_KeyCode.HOME))
				{
					ResetController(1);
				}
			}
		}
		if (controllerlink.picoDevice)
		{
			if (controllerlink.switchHomeKey && (Controller.UPvr_GetKeyClick(0, Pvr_KeyCode.HOME) || (Controller.UPvr_GetKeyClick(1, Pvr_KeyCode.HOME) && !stopConnect)))
			{
				controllerlink.RebackToLauncher();
			}
			if (Controller.UPvr_GetKeyClick(0, Pvr_KeyCode.VOLUMEUP) || Controller.UPvr_GetKeyClick(1, Pvr_KeyCode.VOLUMEUP))
			{
				controllerlink.TurnUpVolume();
			}
			if (Controller.UPvr_GetKeyClick(0, Pvr_KeyCode.VOLUMEDOWN) || Controller.UPvr_GetKeyClick(1, Pvr_KeyCode.VOLUMEDOWN))
			{
				controllerlink.TurnDownVolume();
			}
			if (!Controller.UPvr_GetKey(0, Pvr_KeyCode.VOLUMEUP) && !Controller.UPvr_GetKey(0, Pvr_KeyCode.VOLUMEDOWN) && !Controller.UPvr_GetKey(1, Pvr_KeyCode.VOLUMEUP) && !Controller.UPvr_GetKey(1, Pvr_KeyCode.VOLUMEDOWN))
			{
				cTime = 1f;
			}
			if (Controller.UPvr_GetKey(0, Pvr_KeyCode.VOLUMEUP) || Controller.UPvr_GetKey(1, Pvr_KeyCode.VOLUMEUP))
			{
				cTime -= Time.deltaTime;
				if (cTime <= 0f)
				{
					cTime = 0.2f;
					controllerlink.TurnUpVolume();
				}
			}
			if (!Controller.UPvr_GetKey(0, Pvr_KeyCode.HOME) && !Controller.UPvr_GetKey(1, Pvr_KeyCode.HOME) && (Controller.UPvr_GetKey(0, Pvr_KeyCode.VOLUMEDOWN) || Controller.UPvr_GetKey(1, Pvr_KeyCode.VOLUMEDOWN)))
			{
				cTime -= Time.deltaTime;
				if (cTime <= 0f)
				{
					cTime = 0.2f;
					controllerlink.TurnDownVolume();
				}
			}
		}
		if (controllerlink.goblinserviceStarted && Controller.UPvr_GetKey(0, Pvr_KeyCode.HOME) && Controller.UPvr_GetKey(0, Pvr_KeyCode.VOLUMEDOWN) && !stopConnect)
		{
			disConnectTime += Time.deltaTime;
			if ((double)disConnectTime > 1.0)
			{
				DisConnectBLE();
				controllerlink.hummingBirdMac = string.Empty;
				stopConnect = true;
				disConnectTime = 0f;
			}
		}
	}

	private void TransformData(ControllerHand hand, int handId, int[] data)
	{
		keyOffset = ((handId == 1) ? 67 : 0);
		hand.TouchPadPosition.x = data[keyOffset];
		hand.TouchPadPosition.y = data[5 + keyOffset];
		TransSingleKey(hand.Home, 10 + keyOffset, data);
		TransSingleKey(hand.App, 15 + keyOffset, data);
		TransSingleKey(hand.Touch, 20 + keyOffset, data);
		TransSingleKey(hand.VolumeUp, 25 + keyOffset, data);
		TransSingleKey(hand.VolumeDown, 30 + keyOffset, data);
		TransSingleKey(hand.Trigger, 35 + keyOffset, data);
		if (controllerlink.goblinserviceStarted && !controllerlink.neoserviceStarted)
		{
			hand.TriggerNum = controllerlink.GetHBKeyValue();
		}
		if (!controllerlink.goblinserviceStarted && controllerlink.neoserviceStarted)
		{
			hand.TriggerNum = controllerlink.GetCVTriggerValue(handId);
		}
		hand.Battery = data[40 + keyOffset];
		if (data.Length == 47)
		{
			hand.SwipeDirection = (SwipeDirection)data[45];
			hand.TouchPadClick = (TouchPadClick)data[46];
		}
		else
		{
			switch (handId)
			{
			case 0:
				TransSingleKey(hand.X, 45 + keyOffset, data);
				TransSingleKey(hand.Y, 50 + keyOffset, data);
				TransSingleKey(hand.Left, 60 + keyOffset, data);
				break;
			case 1:
				TransSingleKey(hand.A, 45 + keyOffset, data);
				TransSingleKey(hand.B, 50 + keyOffset, data);
				TransSingleKey(hand.Right, 55 + keyOffset, data);
				break;
			}
			hand.SwipeDirection = (SwipeDirection)data[65 + keyOffset];
			hand.TouchPadClick = (TouchPadClick)data[66 + keyOffset];
		}
		hand.GripValue = controllerlink.GetNeo3GripValue(handId);
		TransformTouchData(hand, handId, controllerlink.GetNeo3TouchData(handId));
	}

	private void TransSingleKey(PvrControllerKey key, int beginIndex, int[] data)
	{
		key.State = Convert.ToBoolean(data[beginIndex]);
		key.PressedDown = Convert.ToBoolean(data[beginIndex + 1]);
		key.PressedUp = Convert.ToBoolean(data[beginIndex + 2]);
		key.LongPressed = Convert.ToBoolean(data[beginIndex + 3]);
		key.Click = Convert.ToBoolean(data[beginIndex + 4]);
	}

	private void TransformTouchData(ControllerHand hand, int handId, int[] data)
	{
		switch (handId)
		{
		case 0:
			TransSingleTouchValue(hand.X, 0, data);
			TransSingleTouchValue(hand.Y, 3, data);
			break;
		case 1:
			TransSingleTouchValue(hand.A, 0, data);
			TransSingleTouchValue(hand.B, 3, data);
			break;
		}
		TransSingleTouchValue(hand.Touch, 6, data);
		TransSingleTouchValue(hand.Trigger, 9, data);
		TransSingleTouchValue(hand.Thumbrest, 12, data);
	}

	private void TransSingleTouchValue(PvrControllerKey key, int beginIndex, int[] data)
	{
		key.Touch = Convert.ToBoolean(data[beginIndex]);
		key.TouchDown = Convert.ToBoolean(data[beginIndex + 1]);
		key.TouchUp = Convert.ToBoolean(data[beginIndex + 2]);
	}
}
namespace Pvr_UnitySDKAPI
{
	public enum ControllerVariety
	{
		Controller0,
		Controller1
	}
}
public class Pvr_ControllerModuleInit : MonoBehaviour
{
	public ControllerVariety Variety;

	public bool IsCustomModel;

	[SerializeField]
	private GameObject dot;

	[SerializeField]
	private GameObject rayLine;

	[SerializeField]
	private GameObject controller;

	private bool moduleState = true;

	private void Awake()
	{
		Pvr_ControllerManager.PvrServiceStartSuccessEvent += ServiceStartSuccess;
		Pvr_ControllerManager.PvrControllerStateChangedEvent += ControllerStateChanged;
		Pvr_ControllerManager.ChangeMainControllerCallBackEvent += MainControllerIDChanged;
		if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
		{
			rayLine = base.transform.GetComponentInChildren<LineRenderer>(includeInactive: true).gameObject;
			rayLine.GetComponent<LineRenderer>().startWidth = 0.003f;
			rayLine.GetComponent<LineRenderer>().endWidth = 0.0015f;
		}
	}

	private void OnDestroy()
	{
		Pvr_ControllerManager.PvrServiceStartSuccessEvent -= ServiceStartSuccess;
		Pvr_ControllerManager.PvrControllerStateChangedEvent -= ControllerStateChanged;
		Pvr_ControllerManager.ChangeMainControllerCallBackEvent -= MainControllerIDChanged;
	}

	private void ServiceStartSuccess()
	{
		RefreshRay();
	}

	private void ControllerStateChanged(string data)
	{
		if (Pvr_ControllerManager.controllerlink.controller0Connected || Pvr_ControllerManager.controllerlink.controller1Connected)
		{
			moduleState = true;
			controller.transform.localScale = Vector3.one;
		}
		RefreshRay();
	}

	private void MainControllerIDChanged(string data)
	{
		RefreshRay();
	}

	private void RefreshRay()
	{
		if (Variety == ControllerVariety.Controller0)
		{
			StartCoroutine(ShowOrHideRay(0));
		}
		if (Variety == ControllerVariety.Controller1)
		{
			StartCoroutine(ShowOrHideRay(1));
		}
	}

	private IEnumerator ShowOrHideRay(int id)
	{
		yield return null;
		yield return null;
		if (moduleState)
		{
			bool active = Controller.UPvr_GetMainHandNess() == id && Controller.UPvr_GetControllerState(id) == ControllerState.Connected;
			dot.SetActive(active);
			rayLine.SetActive(active);
		}
	}

	public void ForceHideOrShow(bool state)
	{
		dot.SetActive(state);
		rayLine.SetActive(state);
		controller.transform.localScale = ((!state) ? Vector3.zero : Vector3.one);
		moduleState = state;
	}

	public void UpdateRay()
	{
		if (!Pvr_ControllerManager.Instance.LengthAdaptiveRay)
		{
			return;
		}
		bool flag = false;
		flag = ((Pvr_ControllerManager.controllerlink.controller0Connected || Pvr_ControllerManager.controllerlink.controller1Connected) ? true : false);
		if (flag && rayLine != null && rayLine.gameObject.activeSelf)
		{
			int num = Controller.UPvr_GetDeviceType();
			if (num == 1)
			{
				rayLine.GetComponent<LineRenderer>().SetPosition(0, base.transform.TransformPoint(0f, 0f, 0.058f));
			}
			else
			{
				rayLine.GetComponent<LineRenderer>().SetPosition(0, base.transform.TransformPoint(0f, 0.009f, 0.055f));
			}
			rayLine.GetComponent<LineRenderer>().SetPosition(1, dot.transform.position);
		}
	}
}
public class Pvr_ControllerPower : MonoBehaviour
{
	[SerializeField]
	private Sprite power1;

	[SerializeField]
	private Sprite power2;

	[SerializeField]
	private Sprite power3;

	[SerializeField]
	private Sprite power4;

	[SerializeField]
	private Sprite power5;

	[HideInInspector]
	public ControllerVariety variety;

	[HideInInspector]
	public ControllerDevice currentDevice;

	private Image powerImage;

	private int powerValue;

	private float power;

	private void Start()
	{
		powerImage = base.transform.GetComponent<Image>();
		powerValue = -1;
		variety = base.transform.GetComponentInParent<Pvr_ControllerModuleInit>().Variety;
		currentDevice = base.transform.GetComponentInParent<Pvr_ControllerVisual>().currentDevice;
	}

	private void Update()
	{
		RefreshPower((variety != 0) ? 1 : 0);
	}

	private void RefreshPower(int hand)
	{
		if (powerValue != Controller.UPvr_GetControllerPower(hand))
		{
			switch (Controller.UPvr_GetControllerPower(hand))
			{
			case 1:
				powerImage.sprite = power1;
				powerImage.color = Color.red;
				break;
			case 2:
				powerImage.sprite = power2;
				powerImage.color = Color.white;
				break;
			case 3:
				powerImage.sprite = power3;
				powerImage.color = Color.white;
				break;
			case 4:
				powerImage.sprite = power4;
				powerImage.color = Color.white;
				break;
			case 5:
				powerImage.sprite = power5;
				powerImage.color = Color.white;
				break;
			default:
				powerImage.sprite = power1;
				powerImage.color = Color.white;
				break;
			}
			powerValue = Controller.UPvr_GetControllerPower(hand);
		}
	}
}
namespace Pvr_UnitySDKAPI
{
	public enum ControllerDevice
	{
		Goblin,
		Neo,
		G2,
		Neo2,
		Neo3,
		NewController
	}
}
public class Pvr_ControllerVisual : MonoBehaviour
{
	public ControllerDevice currentDevice;

	public Texture2D m_idle;

	public Texture2D m_app;

	public Texture2D m_home;

	public Texture2D m_touchpad;

	public Texture2D m_volUp;

	public Texture2D m_volDn;

	public Texture2D m_trigger;

	public Texture2D m_a;

	public Texture2D m_b;

	public Texture2D m_x;

	public Texture2D m_y;

	public Texture2D m_grip;

	private Renderer controllerRenderMat;

	[HideInInspector]
	public ControllerVariety variety;

	private void Awake()
	{
		controllerRenderMat = GetComponent<Renderer>();
	}

	private void Start()
	{
		variety = base.transform.GetComponentInParent<Pvr_ControllerModuleInit>().Variety;
	}

	private void Update()
	{
		ChangeKeyEffects((variety != 0) ? 1 : 0);
	}

	private void ChangeKeyEffects(int hand)
	{
		if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.TOUCHPAD))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_touchpad);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.APP))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_app);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.HOME))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_home);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.VOLUMEUP))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_volUp);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.VOLUMEDOWN))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_volDn);
		}
		else if (Controller.UPvr_GetControllerTriggerValue(hand) > 0 || Controller.UPvr_GetKey(hand, Pvr_KeyCode.TRIGGER))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_trigger);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.X))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_x);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.Y))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_y);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.A))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_a);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.B))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_b);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.Left) || Controller.UPvr_GetKey(hand, Pvr_KeyCode.Right))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_grip);
		}
		else if (controllerRenderMat.material.GetTexture("_MainTex") != m_idle)
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_idle);
		}
	}
}
public class Pvr_ToolTips : MonoBehaviour
{
	public enum TipBtn
	{
		app,
		touchpad,
		home,
		volup,
		voldown,
		trigger,
		grip
	}

	private ControllerDevice currentDevice;

	private float tipsAlpha;

	public static Pvr_ToolTips tooltips;

	public void ChangeTipsText(TipBtn tip, string key)
	{
		switch (tip)
		{
		case TipBtn.app:
			base.transform.Find("apptip/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.touchpad:
			base.transform.Find("touchtip/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.home:
			base.transform.Find("hometip/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.volup:
			base.transform.Find("volup/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.voldown:
			base.transform.Find("voldown/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.trigger:
			base.transform.Find("triggertip/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.grip:
			base.transform.Find("grip/btn/Text").GetComponent<Text>().text = key;
			break;
		}
	}

	private void Awake()
	{
		tooltips = base.transform.GetComponent<Pvr_ToolTips>();
	}

	private void Update()
	{
		switch (currentDevice)
		{
		case ControllerDevice.Goblin:
		case ControllerDevice.G2:
			tipsAlpha = (330f - base.transform.parent.parent.parent.localRotation.eulerAngles.x) / 45f;
			if (base.transform.parent.parent.parent.localRotation.eulerAngles.x >= 270f && base.transform.parent.parent.parent.localRotation.eulerAngles.x <= 330f)
			{
				tipsAlpha = Mathf.Max(0f, tipsAlpha);
				tipsAlpha = ((!(tipsAlpha > 1f)) ? tipsAlpha : 1f);
			}
			else
			{
				tipsAlpha = 0f;
			}
			GetComponent<CanvasGroup>().alpha = tipsAlpha;
			break;
		case ControllerDevice.Neo2:
		case ControllerDevice.Neo3:
			tipsAlpha = (330f - base.transform.parent.parent.parent.localRotation.eulerAngles.x) / 45f;
			if (base.transform.parent.parent.parent.localRotation.eulerAngles.x >= 270f && base.transform.parent.parent.parent.localRotation.eulerAngles.x <= 330f)
			{
				tipsAlpha = Mathf.Max(0f, tipsAlpha);
				tipsAlpha = ((!(tipsAlpha > 1f)) ? tipsAlpha : 1f);
			}
			else
			{
				tipsAlpha = 0f;
			}
			GetComponent<CanvasGroup>().alpha = tipsAlpha;
			break;
		case ControllerDevice.Neo:
			break;
		}
	}

	private void LoadTextFromJson()
	{
		currentDevice = base.transform.GetComponentInParent<Pvr_ControllerVisual>().currentDevice;
		base.transform.Find("apptip/btn/Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("apptip");
		base.transform.Find("touchtip/btn/Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("touchtip");
		base.transform.Find("hometip/btn/Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("hometip");
		Transform transform = base.transform.Find("volup/btn/Text");
		if (transform != null)
		{
			transform.GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("voluptip");
		}
		Transform transform2 = base.transform.Find("voldown/btn/Text");
		if (transform2 != null)
		{
			transform2.GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("voldowntip");
		}
		Transform transform3 = base.transform.Find("triggertip/btn/Text");
		if (transform3 != null)
		{
			transform3.GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("triggertip");
		}
		Transform transform4 = base.transform.Find("grip/btn/Text");
		if (transform4 != null)
		{
			transform4.GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("griptip");
		}
	}

	public static void RefreshTips()
	{
		if (tooltips != null)
		{
			tooltips.LoadTextFromJson();
		}
	}
}
public class Pvr_TouchPadScroll : MonoBehaviour
{
	private ScrollRect scrollRect;

	private bool isHoving;

	private int mainHand;

	private SwipeDirection direction;

	private Vector2 currPos;

	private Vector2 tarPos;

	private float lerpSpeed = 10f;

	private Transform tranViewport;

	private float ignoreDis = 3f;

	private Vector2 lastTouchDownPos;

	private Vector2 lastTouchUpPos;

	private bool isTouching;

	private bool isClosed = true;

	private Vector2 vecOrigin = Vector2.zero;

	private Vector2 vecOriginNeo2 = new Vector2(128f, 128f);

	private void Awake()
	{
		scrollRect = base.gameObject.GetComponent<ScrollRect>();
		tranViewport = base.transform.Find("Viewport");
	}

	private void Update()
	{
		Process();
		UpdateTargetPos();
		UpdatePos();
	}

	private bool IsControllerConnect()
	{
		mainHand = Controller.UPvr_GetMainHandNess();
		if (mainHand == 0 && Pvr_ControllerManager.controllerlink.controller0Connected)
		{
			return true;
		}
		if (mainHand == 1 && Pvr_ControllerManager.controllerlink.controller1Connected)
		{
			return true;
		}
		return false;
	}

	private void UpdateTargetPos()
	{
		if (Controller.UPvr_GetKey(0, Pvr_KeyCode.TOUCHPAD) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TOUCHPAD))
		{
			ResetParameter();
		}
		else if (isHoving)
		{
			if (Pvr_ControllerManager.controllerlink.GetControllerType() == 3)
			{
				ComputeTouchPos();
			}
			else
			{
				ComputeRockerPos();
			}
			if ((currPos - tarPos).sqrMagnitude <= 10f)
			{
				isClosed = true;
			}
		}
	}

	private void ComputeTouchPos()
	{
		mainHand = Controller.UPvr_GetMainHandNess();
		currPos = scrollRect.content.localPosition;
		Vector2 vector = vecOrigin;
		if (mainHand == 0 && Pvr_ControllerManager.controllerlink.controller0Connected)
		{
			vector = Controller.UPvr_GetTouchPadPosition(mainHand);
		}
		if (mainHand == 1 && Pvr_ControllerManager.controllerlink.controller1Connected)
		{
			vector = Controller.UPvr_GetTouchPadPosition(mainHand);
		}
		if ((vector - vecOrigin).sqrMagnitude >= 1f)
		{
			if (!isTouching)
			{
				lastTouchDownPos = vector;
				isTouching = true;
			}
			lastTouchUpPos.x = vector.x;
			float num = Mathf.Abs(lastTouchUpPos.x - lastTouchDownPos.x);
			if (num > ignoreDis)
			{
				Vector2 vector2 = new Vector2((lastTouchUpPos.x - lastTouchDownPos.x) * 10f, 0f);
				lastTouchDownPos.x = lastTouchUpPos.x;
				if (isClosed)
				{
					tarPos = currPos + vector2;
					isClosed = false;
				}
				else
				{
					tarPos += vector2;
				}
			}
		}
		else
		{
			lastTouchDownPos = vecOrigin;
			lastTouchUpPos = vecOrigin;
			isTouching = false;
			if ((double)scrollRect.horizontalScrollbar.value >= 0.999 || (double)scrollRect.horizontalScrollbar.value <= 0.0001)
			{
				isClosed = true;
			}
		}
	}

	private void ComputeRockerPos()
	{
		mainHand = Controller.UPvr_GetMainHandNess();
		currPos = scrollRect.content.localPosition;
		Vector2 vector = vecOriginNeo2;
		if (mainHand == 0 && Pvr_ControllerManager.controllerlink.controller0Connected)
		{
			vector = Controller.UPvr_GetTouchPadPosition(mainHand);
		}
		if (mainHand == 1 && Pvr_ControllerManager.controllerlink.controller1Connected)
		{
			vector = Controller.UPvr_GetTouchPadPosition(mainHand);
		}
		if (VerifyNeo2TouchValid(vector) && (vector - vecOriginNeo2).sqrMagnitude >= 1f)
		{
			if (!isTouching)
			{
				lastTouchDownPos = vector;
				isTouching = true;
			}
			lastTouchUpPos.x = vector.x;
			float num = Mathf.Abs(lastTouchUpPos.x - lastTouchDownPos.x);
			if (num > ignoreDis)
			{
				Vector2 vector2 = new Vector2((lastTouchUpPos.x - lastTouchDownPos.x) * 10f, 0f);
				lastTouchDownPos.x = lastTouchUpPos.x;
				if (isClosed)
				{
					tarPos = currPos + vector2;
					isClosed = false;
				}
				else
				{
					tarPos += vector2;
				}
			}
		}
		else
		{
			lastTouchDownPos = vecOriginNeo2;
			lastTouchUpPos = vecOriginNeo2;
			isTouching = false;
			if ((double)scrollRect.horizontalScrollbar.value >= 0.999 || (double)scrollRect.horizontalScrollbar.value <= 0.0001)
			{
				isClosed = true;
			}
		}
	}

	private bool VerifyNeo2TouchValid(Vector2 nowTouchPos)
	{
		if (nowTouchPos.x > vecOriginNeo2.x && nowTouchPos.x > lastTouchDownPos.x)
		{
			return true;
		}
		if (nowTouchPos.x < vecOriginNeo2.x && nowTouchPos.x < lastTouchDownPos.x)
		{
			return true;
		}
		return false;
	}

	private void UpdatePos()
	{
		if (Controller.UPvr_GetKey(0, Pvr_KeyCode.TOUCHPAD) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TOUCHPAD))
		{
			ResetParameter();
		}
		else if (!isClosed && IsControllerConnect())
		{
			if ((double)scrollRect.horizontalScrollbar.value >= 0.9999 && tarPos.x <= currPos.x)
			{
				isClosed = true;
				return;
			}
			if ((double)scrollRect.horizontalScrollbar.value <= 0.0001 && tarPos.x >= currPos.x)
			{
				isClosed = true;
				return;
			}
			currPos.x = Mathf.Lerp(currPos.x, tarPos.x, lerpSpeed * Time.deltaTime);
			currPos.y = Mathf.Lerp(currPos.y, tarPos.y, lerpSpeed * Time.deltaTime);
			scrollRect.content.localPosition = currPos;
		}
	}

	private void ResetParameter()
	{
		currPos = scrollRect.content.localPosition;
		tarPos = scrollRect.content.localPosition;
		isClosed = true;
	}

	private void Process()
	{
		for (int i = 0; i < Pvr_InputModule.pointers.Count; i++)
		{
			Pvr_UIPointer pvr_UIPointer = Pvr_InputModule.pointers[i];
			if (pvr_UIPointer.gameObject.activeInHierarchy && pvr_UIPointer.enabled)
			{
				isHoving = IsHovering(pvr_UIPointer);
			}
		}
	}

	private bool IsHovering(Pvr_UIPointer pointer)
	{
		if (!IsControllerConnect())
		{
			return false;
		}
		foreach (GameObject item in pointer.pointerEventData.hovered)
		{
			if (FindTree(item.transform))
			{
				mainHand = Controller.UPvr_GetMainHandNess();
				if (mainHand == 0 && Pvr_ControllerManager.controllerlink.controller0Connected)
				{
					return true;
				}
				if (mainHand == 1 && Pvr_ControllerManager.controllerlink.controller1Connected)
				{
					return true;
				}
			}
		}
		return false;
	}

	private bool FindTree(Transform tran)
	{
		if (tran == base.transform || tran == tranViewport)
		{
			return true;
		}
		if (tran.IsChildOf(tranViewport))
		{
			return true;
		}
		return false;
	}
}
public class Pvr_TouchVisual : MonoBehaviour
{
	[HideInInspector]
	public ControllerDevice currentDevice;

	[HideInInspector]
	public ControllerVariety variety;

	private MeshRenderer touchRenderer;

	private void Start()
	{
		variety = base.transform.GetComponentInParent<Pvr_ControllerModuleInit>().Variety;
		currentDevice = GetComponentInParent<Pvr_ControllerVisual>().currentDevice;
		touchRenderer = GetComponent<MeshRenderer>();
	}

	private void Update()
	{
		ChangeEffects((variety != 0) ? 1 : 0);
	}

	private void ChangeEffects(int hand)
	{
		ControllerDevice controllerDevice = currentDevice;
		if (controllerDevice == ControllerDevice.G2)
		{
			if (Controller.UPvr_IsTouching(0))
			{
				touchRenderer.enabled = true;
				base.transform.localPosition = new Vector3(1.3f - Controller.UPvr_GetTouchPadPosition(hand).x * 0.01f, 1.6f, -1.7f - Controller.UPvr_GetTouchPadPosition(hand).y * 0.01f);
			}
			else
			{
				touchRenderer.enabled = false;
			}
		}
	}
}
public class DemoController : MonoBehaviour
{
	public delegate void showLoadingEventHandler();

	private Callback callback;

	private GameObject msg;

	private Pvr_UnitySDKManager picoVrManager;

	private string currentOrderID;

	public GameObject loading;

	public GameObject BG;

	public GameObject InputPanel;

	public static showLoadingEventHandler showLoading;

	private void Awake()
	{
		Debug.Log(loading.name);
		Debug.Log(BG.name);
		showLoading = (showLoadingEventHandler)Delegate.Combine(showLoading, new showLoadingEventHandler(StopLoading));
		InputManager.doEnter = (InputManager.doEnterEventHandler)Delegate.Combine(InputManager.doEnter, new InputManager.doEnterEventHandler(DoPayByCode));
		currentOrderID = string.Empty;
	}

	private void Start()
	{
		msg = GameObject.Find("MassageInfo");
		InitDelegate();
		callback = new Callback();
		picoVrManager = GameObject.Find("Pvr_UnitySDK").GetComponent<Pvr_UnitySDKManager>();
		InputPanel.SetActive(value: false);
	}

	private void Update()
	{
		if (picoVrManager != null && (Input.GetKeyDown(KeyCode.Y) || Input.GetKeyDown(KeyCode.Joystick1Button2)))
		{
			Debug.Log("update");
			Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
		}
		if (Input.GetKeyDown(KeyCode.Joystick1Button1) || Input.GetKeyDown(KeyCode.Escape))
		{
			if (InputPanel.activeInHierarchy)
			{
				InputPanel.SetActive(value: false);
			}
			else
			{
				Application.Quit();
			}
		}
	}

	private void InitDelegate()
	{
		ArrayList arrayList = new ArrayList();
		arrayList.Add("Login");
		arrayList.Add("GetUserAPI");
		arrayList.Add("PayOne");
		arrayList.Add("PayCode");
		arrayList.Add("QueryOrder");
		foreach (string item in arrayList)
		{
			GameObject btnObj = GameObject.Find(item);
			Button component = btnObj.GetComponent<Button>();
			component.onClick.AddListener(delegate
			{
				OnClick(btnObj);
			});
		}
	}

	private void OnClick(GameObject btnObj)
	{
		switch (btnObj.name)
		{
		case "Login":
			StartLoading();
			LoginSDK.Login();
			break;
		case "PayOne":
			CommonDic.getInstance().setParameters("subject", "game");
			CommonDic.getInstance().setParameters("body", "gamePay");
			CommonDic.getInstance().setParameters("order_id", getRamdomTestOrderID());
			CommonDic.getInstance().setParameters("total", "1");
			CommonDic.getInstance().setParameters("goods_tag", "game");
			CommonDic.getInstance().setParameters("notify_url", "www.picovr.com");
			CommonDic.getInstance().setParameters("pay_code", string.Empty);
			StartLoading();
			PicoPaymentSDK.Pay(CommonDic.getInstance().PayOrderString());
			break;
		case "PayCode":
			InputPanel.SetActive(value: true);
			break;
		case "QueryOrder":
			StartLoading();
			PicoPaymentSDK.QueryOrder(currentOrderID);
			break;
		case "GetUserAPI":
			StartLoading();
			LoginSDK.GetUserAPI();
			break;
		}
	}

	public string getRamdomTestOrderID()
	{
		currentOrderID = (UnityEngine.Random.value * 65535f).ToString();
		return currentOrderID;
	}

	private void StartLoading()
	{
		loading.SetActive(value: true);
		BG.SetActive(value: true);
	}

	public void StopLoading()
	{
		if ((bool)loading && (bool)BG)
		{
			loading.SetActive(value: false);
			BG.SetActive(value: false);
		}
		else
		{
			Debug.LogError("demo");
		}
	}

	public void DoPayByCode()
	{
		CommonDic.getInstance().setParameters("subject", "game");
		CommonDic.getInstance().setParameters("body", "gamePay");
		CommonDic.getInstance().setParameters("order_id", getRamdomTestOrderID());
		CommonDic.getInstance().setParameters("total", "0");
		CommonDic.getInstance().setParameters("goods_tag", "game");
		CommonDic.getInstance().setParameters("notify_url", "www.picovr.com");
		CommonDic.getInstance().setParameters("pay_code", GameObject.Find("CodeText").GetComponent<Text>().text);
		Debug.Log("" + GameObject.Find("CodeText").GetComponent<Text>().text);
		StartLoading();
		GameObject.Find("CodeText").GetComponent<Text>().text = string.Empty;
		InputPanel.SetActive(value: false);
		PicoPaymentSDK.Pay(CommonDic.getInstance().PayOrderString());
	}

	private bool VerifyLocalToken()
	{
		if (CommonDic.getInstance().access_token.Equals(string.Empty))
		{
			GameObject.Find("MassageInfo").GetComponent<Text>().text = "{code:exception,msg:}";
			currentOrderID = string.Empty;
			StopLoading();
			return false;
		}
		return true;
	}
}
public class LoadingRatation : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
		base.gameObject.transform.Rotate(new Vector3(0f, 0f, -4f));
	}
}
public class InputManager : MonoBehaviour
{
	public delegate void doEnterEventHandler();

	public static doEnterEventHandler doEnter;

	private StringBuilder sb = new StringBuilder();

	private ArrayList btnsName = new ArrayList();

	private GameObject enter;

	private void Awake()
	{
		InitKeyBoard();
	}

	private void Start()
	{
	}

	private void Update()
	{
	}

	private void InitKeyBoard()
	{
		btnsName.Add("1");
		btnsName.Add("2");
		btnsName.Add("3");
		btnsName.Add("4");
		btnsName.Add("5");
		btnsName.Add("6");
		btnsName.Add("7");
		btnsName.Add("8");
		btnsName.Add("9");
		btnsName.Add("0");
		btnsName.Add("Q");
		btnsName.Add("W");
		btnsName.Add("E");
		btnsName.Add("R");
		btnsName.Add("T");
		btnsName.Add("Y");
		btnsName.Add("U");
		btnsName.Add("I");
		btnsName.Add("O");
		btnsName.Add("P");
		btnsName.Add("A");
		btnsName.Add("S");
		btnsName.Add("D");
		btnsName.Add("F");
		btnsName.Add("G");
		btnsName.Add("H");
		btnsName.Add("J");
		btnsName.Add("K");
		btnsName.Add("L");
		btnsName.Add("Z");
		btnsName.Add("X");
		btnsName.Add("C");
		btnsName.Add("V");
		btnsName.Add("B");
		btnsName.Add("N");
		btnsName.Add("M");
		btnsName.Add("Clear");
		btnsName.Add("Capslock");
		btnsName.Add("Enter");
		foreach (string item in btnsName)
		{
			GameObject btnObj = GameObject.Find(item);
			Button component = btnObj.GetComponent<Button>();
			component.onClick.AddListener(delegate
			{
				OnClick(btnObj);
			});
		}
		enter = GameObject.Find("Enter");
		enter.SetActive(sb.Length > 0);
	}

	private void OnClick(GameObject btnObj)
	{
		if (btnObj.name.Equals("Capslock"))
		{
			if (GameObject.Find("Q").transform.GetChild(0).GetComponent<Text>().text.Equals("Q"))
			{
				DoCapslock(IsUpper: true);
			}
			else
			{
				DoCapslock(IsUpper: false);
			}
		}
		else if (btnObj.name.Equals("Clear"))
		{
			GameObject.Find("CodeText").GetComponent<Text>().text = string.Empty;
			ClearBuffer();
		}
		else if (btnObj.name.Equals("Enter"))
		{
			ClearBuffer();
			doEnter();
		}
		else
		{
			EnterChar(btnObj.transform.GetChild(0).GetComponent<Text>().text);
		}
	}

	private void EnterChar(string s)
	{
		sb.Append(s);
		GameObject.Find("CodeText").GetComponent<Text>().text = sb.ToString();
		enter.SetActive(sb.Length > 0);
	}

	private void DoCapslock(bool IsUpper)
	{
		if (IsUpper)
		{
			foreach (string item in btnsName)
			{
				GameObject gameObject = GameObject.Find(item);
				Text component = gameObject.transform.GetChild(0).GetComponent<Text>();
				component.text = component.text.ToLower();
			}
			return;
		}
		foreach (string item2 in btnsName)
		{
			GameObject gameObject2 = GameObject.Find(item2);
			Text component2 = gameObject2.transform.GetChild(0).GetComponent<Text>();
			component2.text = component2.text.ToUpper();
		}
	}

	private void ClearBuffer()
	{
		sb.Remove(0, sb.Length);
		enter.SetActive(sb.Length > 0);
	}
}
public class Callback : MonoBehaviour
{
	private static string IS_SUCCESS = "isSuccess";

	private static string MSG = "msg";

	private static string CODE = "code";

	public void LoginCallback(string LoginInfo)
	{
		JsonData jsonData = JsonMapper.ToObject(LoginInfo);
		SetMassage(LoginInfo);
		DemoController.showLoading();
		if (jsonData[IS_SUCCESS] != null)
		{
			CommonDic.getInstance().isSuccess = jsonData[IS_SUCCESS].ToString();
		}
		if (jsonData[MSG] != null)
		{
			CommonDic.getInstance().loginMsg = jsonData[MSG].ToString();
		}
		Debug.Log("login:" + LoginInfo);
	}

	public void QueryOrPayCallback(string queryOrPayInfo)
	{
		JsonData jsonData = JsonMapper.ToObject(queryOrPayInfo);
		if (jsonData[CODE] != null)
		{
			CommonDic.getInstance().code = jsonData["code"].ToString();
		}
		if (jsonData[MSG] != null)
		{
			CommonDic.getInstance().msg = jsonData["msg"].ToString();
		}
		if (jsonData != null)
		{
			CommonDic.getInstance().order_info = jsonData[1].ToString();
		}
		SetMassage(queryOrPayInfo);
		DemoController.showLoading();
		Debug.Log("pay:" + queryOrPayInfo);
	}

	public void UserInfoCallback(string userInfo)
	{
		CommonDic.getInstance().user_info = userInfo;
		SetMassage(userInfo);
		DemoController.showLoading();
		Debug.Log("userInfo:" + userInfo);
	}

	public void SetMassage(string massage)
	{
		if (!GetCurrentGameObject().Equals(null))
		{
			GetCurrentGameObject().GetComponent<Text>().text = massage;
		}
		else
		{
			Debug.LogError("Message");
		}
	}

	public GameObject GetCurrentGameObject()
	{
		return GameObject.Find("MassageInfo");
	}

	public void ActivityForResultCallback(string activity)
	{
		PicoPaymentSDK.jo.Call("authCallback", activity);
	}
}
public class CommonDic
{
	private static CommonDic dic;

	private static Dictionary<string, string> mydic;

	private string _app_ID;

	private string _app_Key;

	private string _user_token;

	private string _access_token = string.Empty;

	private string _open_id;

	private string _refresh_token;

	private string _expires_in;

	private string _user_info;

	private string _subject;

	private string _body;

	private string _order_id;

	private string _total;

	private string _goods_tag;

	private string _notify_url;

	private string _trade_type;

	private string _pay_code = string.Empty;

	private string _order_info;

	private string _code;

	private string _msg = "null";

	private string _merchant_ID;

	private string _payKey;

	private string _isSuucess;

	private string _loginMsg;

	public string subject
	{
		get
		{
			return _subject;
		}
		set
		{
			_subject = value;
		}
	}

	public string body
	{
		get
		{
			return _body;
		}
		set
		{
			_body = value;
		}
	}

	public string order_id
	{
		get
		{
			return _order_id;
		}
		set
		{
			_order_id = value;
		}
	}

	public string total
	{
		get
		{
			return _total;
		}
		set
		{
			_total = value;
		}
	}

	public string goods_tag
	{
		get
		{
			return _goods_tag;
		}
		set
		{
			_goods_tag = value;
		}
	}

	public string notify_url
	{
		get
		{
			return _notify_url;
		}
		set
		{
			_notify_url = value;
		}
	}

	public string pay_code
	{
		get
		{
			return _pay_code;
		}
		set
		{
			_pay_code = value;
		}
	}

	public string trade_type
	{
		get
		{
			return _trade_type;
		}
		set
		{
			_trade_type = value;
		}
	}

	public string user_token
	{
		get
		{
			return _user_token;
		}
		set
		{
			_user_token = value;
		}
	}

	public string access_token
	{
		get
		{
			return _access_token;
		}
		set
		{
			_access_token = value;
		}
	}

	public string open_id
	{
		get
		{
			return _open_id;
		}
		set
		{
			_open_id = value;
		}
	}

	public string refresh_token
	{
		get
		{
			return _refresh_token;
		}
		set
		{
			_refresh_token = value;
		}
	}

	public string expires_in
	{
		get
		{
			return _expires_in;
		}
		set
		{
			_expires_in = value;
		}
	}

	public string isSuccess
	{
		get
		{
			return _isSuucess;
		}
		set
		{
			_isSuucess = value;
		}
	}

	public string loginMsg
	{
		get
		{
			return _loginMsg;
		}
		set
		{
			_loginMsg = value;
		}
	}

	public string user_info
	{
		get
		{
			return _user_info;
		}
		set
		{
			_user_info = value;
		}
	}

	public string order_info
	{
		get
		{
			return _order_info;
		}
		set
		{
			_order_info = value;
		}
	}

	public string code
	{
		get
		{
			return _code;
		}
		set
		{
			_code = value;
		}
	}

	public string msg
	{
		get
		{
			return _msg;
		}
		set
		{
			_msg = value;
		}
	}

	public string app_ID
	{
		get
		{
			return _app_ID;
		}
		set
		{
			_app_ID = value;
		}
	}

	public string app_Key
	{
		get
		{
			return _app_Key;
		}
		set
		{
			_app_Key = value;
		}
	}

	public string merchant_ID
	{
		get
		{
			return _merchant_ID;
		}
		set
		{
			_merchant_ID = value;
		}
	}

	public string paykey
	{
		get
		{
			return _payKey;
		}
		set
		{
			_payKey = value;
		}
	}

	public static CommonDic getInstance()
	{
		if (dic == null)
		{
			dic = new CommonDic();
		}
		if (mydic == null)
		{
			mydic = new Dictionary<string, string>();
			InitDicData(mydic);
		}
		return dic;
	}

	public Dictionary<string, string> getDic()
	{
		return mydic;
	}

	public void setParameters(string name, string value)
	{
		if (name.Equals("subject"))
		{
			subject = value;
		}
		if (name.Equals("body"))
		{
			body = value;
		}
		if (name.Equals("order_id"))
		{
			order_id = value;
		}
		if (name.Equals("total"))
		{
			total = value;
		}
		if (name.Equals("goods_tag"))
		{
			goods_tag = value;
		}
		if (name.Equals("notify_url"))
		{
			notify_url = value;
		}
		if (name.Equals("trade_type"))
		{
			trade_type = value;
		}
		if (name.Equals("pay_code"))
		{
			pay_code = value;
		}
	}

	public string PayOrderString()
	{
		return JsonMapper.ToJson(getInstance());
	}

	public static void InitDicData(Dictionary<string, string> mydic)
	{
		mydic.Add("00000", "");
		mydic.Add("10000", "");
		mydic.Add("10001", "");
		mydic.Add("10002", "");
		mydic.Add("10003", "");
		mydic.Add("11000", "");
		mydic.Add("11001", "");
		mydic.Add("11002", "");
		mydic.Add("11003", "");
		mydic.Add("12000", "");
		mydic.Add("12001", "");
		mydic.Add("12003", "P");
		mydic.Add("12004", "");
		mydic.Add("13000", "");
		mydic.Add("13001", "");
		mydic.Add("13002", "");
		mydic.Add("14000", "");
		mydic.Add("14001", "/");
		mydic.Add("14002", "");
		mydic.Add("15000", "");
		mydic.Add("15001", "ID");
		mydic.Add("15002", "Pico");
		mydic.Add("NOAUTH", "");
		mydic.Add("SYSTEMERROR", "");
		mydic.Add("APP_ID_NOT_EXIST", "APP_ID");
		mydic.Add("MCHID_NOT_EXIST", "MCHID");
		mydic.Add("APP_ID_MCHID_NOT_MATCH", "app_idmch_idID");
		mydic.Add("LACK_PARAMS", "");
		mydic.Add("SIGNERROR", "");
		mydic.Add("NO_DATA", "");
	}
}
public class LoginSDK
{
	public static void Login()
	{
		PicoPaymentSDK.Login();
	}

	public static void GetUserAPI()
	{
		PicoPaymentSDK.GetUserAPI();
	}
}
public class PicoPaymentSDK
{
	private static AndroidJavaObject _jo = new AndroidJavaObject("com.pico.loginpaysdk.UnityInterface");

	public static AndroidJavaObject jo
	{
		get
		{
			return _jo;
		}
		set
		{
			_jo = value;
		}
	}

	public static void Login()
	{
		AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
		AndroidJavaObject @static = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
		jo.Call("init", @static);
		jo.Call("authSSO");
	}

	public static void Pay(string payOrderJson)
	{
		AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
		AndroidJavaObject @static = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
		jo.Call("init", @static);
		jo.Call("pay", payOrderJson);
	}

	public static void QueryOrder(string orderId)
	{
		AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
		AndroidJavaObject @static = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
		jo.Call("init", @static);
		jo.Call("queryOrder", orderId);
	}

	public static void GetUserAPI()
	{
		AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
		AndroidJavaObject @static = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
		jo.Call("init", @static);
		jo.Call("getUserAPI");
	}
}
namespace Pvr_UnitySDKAPI
{
	public enum PBS_SystemInfoEnum
	{
		ELECTRIC_QUANTITY,
		PUI_VERSION,
		EQUIPMENT_MODEL,
		EQUIPMENT_SN,
		CUSTOMER_SN,
		INTERNAL_STORAGE_SPACE_OF_THE_DEVICE,
		DEVICE_BLUETOOTH_STATUS,
		BLUETOOTH_NAME_CONNECTED,
		BLUETOOTH_MAC_ADDRESS,
		DEVICE_WIFI_STATUS,
		WIFI_NAME_CONNECTED,
		WLAN_MAC_ADDRESS,
		DEVICE_IP
	}
	public enum PBS_DeviceControlEnum
	{
		DEVICE_CONTROL_REBOOT,
		DEVICE_CONTROL_SHUTDOWN
	}
	public enum PBS_PackageControlEnum
	{
		PACKAGE_SILENCE_INSTALL,
		PACKAGE_SILENCE_UNINSTALL
	}
	public enum PBS_SwitchEnum
	{
		S_ON,
		S_OFF
	}
	public enum PBS_HomeEventEnum
	{
		SINGLE_CLICK,
		DOUBLE_CLICK,
		LONG_PRESS
	}
	public enum PBS_HomeFunctionEnum
	{
		VALUE_HOME_GO_TO_SETTING,
		VALUE_HOME_BACK,
		VALUE_HOME_RECENTER,
		VALUE_HOME_OPEN_APP,
		VALUE_HOME_DISABLE,
		VALUE_HOME_GO_TO_HOME,
		VALUE_HOME_SEND_BROADCAST,
		VALUE_HOME_CLEAN_MEMORY
	}
	public enum PBS_ScreenOffDelayTimeEnum
	{
		THREE = 3,
		TEN = 10,
		THIRTY = 30,
		SIXTY = 60,
		THREE_HUNDRED = 300,
		SIX_HUNDRED = 600,
		NEVER = -1
	}
	public enum PBS_SleepDelayTimeEnum
	{
		FIFTEEN = 15,
		THIRTY = 30,
		SIXTY = 60,
		THREE_HUNDRED = 300,
		SIX_HUNDRED = 600,
		ONE_THOUSAND_AND_EIGHT_HUNDRED = 1800,
		NEVER = -1
	}
	public enum PBS_SystemFunctionSwitchEnum
	{
		SFS_USB,
		SFS_AUTOSLEEP,
		SFS_SCREENON_CHARGING,
		SFS_OTG_CHARGING,
		SFS_RETURN_MENU_IN_2DMODE,
		SFS_COMBINATION_KEY,
		SFS_CALIBRATION_WITH_POWER_ON,
		SFS_SYSTEM_UPDATE,
		SFS_CAST_SERVICE,
		SFS_EYE_PROTECTION,
		SFS_SECURITY_ZONE_PERMANENTLY,
		SFS_GLOBAL_CALIBRATION,
		SFS_Auto_Calibration,
		SFS_USB_BOOT
	}
	public enum PBS_USBConfigModeEnum
	{
		MTP,
		CHARGE
	}
	public struct ToBService
	{
		public static Action<bool> BoolCallback;

		public static Action<int> IntCallback;

		public static Action<long> LongCallback;

		private static AndroidJavaClass unityPlayer;

		private static AndroidJavaObject currentActivity;

		private static AndroidJavaObject tobHelper;

		private static AndroidJavaClass tobHelperClass;

		public static void UPvr_InitToBService()
		{
			tobHelperClass = new AndroidJavaClass("com.pvr.tobservice.ToBServiceHelper");
			tobHelper = tobHelperClass.CallStatic<AndroidJavaObject>("getInstance", new object[0]);
			unityPlayer = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
			currentActivity = unityPlayer.GetStatic<AndroidJavaObject>("currentActivity");
		}

		public static void UPvr_SetUnityObjectName(string obj)
		{
			System.UPvr_CallMethod(tobHelper, "setUnityObjectName", obj);
		}

		public static void UPvr_BindToBService()
		{
			System.UPvr_CallMethod(tobHelper, "bindTobService", currentActivity);
		}

		public static void UPvr_UnBindToBService()
		{
			System.UPvr_CallMethod(tobHelper, "unBindTobService", currentActivity);
		}

		private static AndroidJavaObject GetEnumType(Enum enumType)
		{
			AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.pvr.tobservice.enums" + enumType.GetType().ToString().Replace("Pvr_UnitySDKAPI", string.Empty));
			return androidJavaClass.GetStatic<AndroidJavaObject>(enumType.ToString());
		}

		public static string UPvr_StateGetDeviceInfo(PBS_SystemInfoEnum type)
		{
			string result = string.Empty;
			System.UPvr_CallMethod(ref result, tobHelper, "pbsStateGetDeviceInfo", GetEnumType(type), 0);
			return result;
		}

		public static void UPvr_ControlSetDeviceAction(PBS_DeviceControlEnum deviceControl, Action<int> callback)
		{
			if (callback != null)
			{
				IntCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsControlSetDeviceAction", GetEnumType(deviceControl), null);
		}

		public static void UPvr_ControlAPPManger(PBS_PackageControlEnum packageControl, string path, Action<int> callback)
		{
			if (callback != null)
			{
				IntCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsControlAPPManger", GetEnumType(packageControl), path, 0, null);
		}

		public static void UPvr_ControlSetAutoConnectWIFI(string ssid, string pwd, Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsControlSetAutoConnectWIFI", ssid, pwd, 0, null);
		}

		public static void UPvr_ControlClearAutoConnectWIFI(Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsControlClearAutoConnectWIFI", null);
		}

		public static void UPvr_PropertySetHomeKey(PBS_HomeEventEnum eventEnum, PBS_HomeFunctionEnum function, Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsPropertySetHomeKey", GetEnumType(eventEnum), GetEnumType(function), null);
		}

		public static void UPvr_PropertySetHomeKeyAll(PBS_HomeEventEnum eventEnum, PBS_HomeFunctionEnum function, int timesetup, string pkg, string className, Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsPropertySetHomeKeyAll", GetEnumType(eventEnum), GetEnumType(function), timesetup, pkg, className, null);
		}

		public static void UPvr_PropertyDisablePowerKey(bool isSingleTap, bool enable, Action<int> callback)
		{
			if (callback != null)
			{
				IntCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsPropertyDisablePowerKey", isSingleTap, enable, null);
		}

		public static void UPvr_PropertySetScreenOffDelay(PBS_ScreenOffDelayTimeEnum timeEnum, Action<int> callback)
		{
			if (callback != null)
			{
				IntCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsPropertySetScreenOffDelay", GetEnumType(timeEnum), null);
		}

		public static void UPvr_PropertySetSleepDelay(PBS_SleepDelayTimeEnum timeEnum)
		{
			System.UPvr_CallMethod(tobHelper, "pbsPropertySetSleepDelay", GetEnumType(timeEnum));
		}

		public static void UPvr_SwitchSystemFunction(PBS_SystemFunctionSwitchEnum systemFunction, PBS_SwitchEnum switchEnum)
		{
			System.UPvr_CallMethod(tobHelper, "pbsSwitchSystemFunction", GetEnumType(systemFunction), GetEnumType(switchEnum), 0);
		}

		public static void UPvr_SwitchSetUsbConfigurationOption(PBS_USBConfigModeEnum uSBConfigModeEnum)
		{
			System.UPvr_CallMethod(tobHelper, "pbsSwitchSetUsbConfigurationOption", GetEnumType(uSBConfigModeEnum), 0);
		}

		public static void UPvr_ScreenOn()
		{
			System.UPvr_CallMethod(tobHelper, "pbsScreenOn");
		}

		public static void UPvr_ScreenOff()
		{
			System.UPvr_CallMethod(tobHelper, "pbsScreenOff");
		}

		public static void UPvr_AcquireWakeLock()
		{
			System.UPvr_CallMethod(tobHelper, "pbsAcquireWakeLock");
		}

		public static void UPvr_ReleaseWakeLock()
		{
			System.UPvr_CallMethod(tobHelper, "pbsReleaseWakeLock");
		}

		public static void UPvr_EnableEnterKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsEnableEnterKey");
		}

		public static void UPvr_DisableEnterKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsDisableEnterKey");
		}

		public static void UPvr_EnableVolumeKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsEnableVolumeKey");
		}

		public static void UPvr_DisableVolumeKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsDisableVolumeKey");
		}

		public static void UPvr_EnableBackKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsEnableBackKey");
		}

		public static void UPvr_DisableBackKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsDisableBackKey");
		}

		public static void UPvr_WriteConfigFileToDataLocal(string path, string content, Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsWriteConfigFileToDataLocal", path, content, null);
		}

		public static void UPvr_ResetAllKeyToDefault(Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsResetAllKeyToDefault", null);
		}
	}
}
public class Pvr_ToBService : MonoBehaviour
{
	public Text deviceInfoText;

	private void Awake()
	{
		InitToBService();
	}

	private void Start()
	{
		BindToBService();
	}

	private void OnDestory()
	{
		UnBindToBService();
	}

	private void InitToBService()
	{
		ToBService.UPvr_InitToBService();
		ToBService.UPvr_SetUnityObjectName(base.name);
	}

	private void BindToBService()
	{
		ToBService.UPvr_BindToBService();
	}

	private void UnBindToBService()
	{
		ToBService.UPvr_UnBindToBService();
	}

	private void BoolCallback(string value)
	{
		if (ToBService.BoolCallback != null)
		{
			ToBService.BoolCallback(bool.Parse(value));
		}
		ToBService.BoolCallback = null;
	}

	private void IntCallback(string value)
	{
		if (ToBService.IntCallback != null)
		{
			ToBService.IntCallback(int.Parse(value));
		}
		ToBService.IntCallback = null;
	}

	private void LongCallback(string value)
	{
		if (ToBService.LongCallback != null)
		{
			ToBService.LongCallback(int.Parse(value));
		}
		ToBService.LongCallback = null;
	}

	public void StateGetDeviceInfo()
	{
		string text = ToBService.UPvr_StateGetDeviceInfo(PBS_SystemInfoEnum.PUI_VERSION);
		deviceInfoText.text = "PUI_VERSION:" + text;
	}

	public void ControlSetDeviceAction()
	{
		ToBService.UPvr_ControlSetDeviceAction(PBS_DeviceControlEnum.DEVICE_CONTROL_SHUTDOWN, ControlSetDeviceActionCallBack);
	}

	private void ControlSetDeviceActionCallBack(int value)
	{
		Debug.Log("ControlSetDeviceActionCallBack : " + value);
	}

	public void AppManager()
	{
		ToBService.UPvr_ControlAPPManger(PBS_PackageControlEnum.PACKAGE_SILENCE_UNINSTALL, "com.pico.ipd.test", AppManagerCallBack);
	}

	private void AppManagerCallBack(int value)
	{
		Debug.Log("AppManagerCallBack : " + value);
	}
}
namespace Pvr_UnitySDKAPI
{
	public enum GlobalIntConfigs
	{
		EYE_TEXTURE_RESOLUTION0,
		EYE_TEXTURE_RESOLUTION1,
		SEENSOR_COUNT,
		ABILITY6DOF,
		PLATFORM_TYPE,
		TRACKING_MODE,
		LOG_LEVEL,
		ENBLE_HAND6DOF_BY_HEAD,
		ENBLE_6DOF_GLOBAL_TRACKING,
		TARGET_FRAME_RATE,
		iShowFPS,
		SensorMode,
		LOGICFLOW,
		EYE_TEXTURE_RES_HIGH,
		EYE_TEXTURE_RES_NORMAL,
		iCtrlModelLoadingPri,
		iPhoneHMDModeEnabled,
		isEnableBoundary,
		Enable_Activity_Rotation,
		GetDisplay_Orientation,
		GetWaitFrameNum,
		GetResetFrameNum,
		EnableFFRBYSYS,
		RotControllerMode
	}
	public enum GlobalFloatConfigs
	{
		IPD,
		VFOV,
		HFOV,
		NECK_MODEL_X,
		NECK_MODEL_Y,
		NECK_MODEL_Z,
		DISPLAY_REFRESH_RATE
	}
	public enum RenderTextureAntiAliasing
	{
		X_1 = 1,
		X_2 = 2,
		X_4 = 4,
		X_8 = 8
	}
	public enum PlatForm
	{
		Android = 1,
		IOS,
		Win,
		Notsupport
	}
	public enum RenderTextureDepth
	{
		BD_0 = 0,
		BD_16 = 16,
		BD_24 = 24
	}
	public enum RenderTextureLevel
	{
		Normal,
		High
	}
	public enum Sensorindex
	{
		Default,
		FirstSensor,
		SecondSensor
	}
	public enum Eye
	{
		LeftEye,
		RightEye,
		BothEye
	}
	public enum ResUtilsType
	{
		TYPE_TEXTSIZE,
		TYPE_COLOR,
		TYPE_TEXT,
		TYPE_FONT,
		TYPE_VALUE,
		TYPE_DRAWABLE,
		TYPE_OBJECT,
		TYPR_OBJECTARRAY
	}
	public enum TrackingOrigin
	{
		EyeLevel,
		FloorLevel,
		StageLevel
	}
	public enum EFoveationLevel
	{
		Low,
		Med,
		High,
		Top_High
	}
	public enum StereoRenderingPathPico
	{
		MultiPass,
		SinglePass
	}
	public enum pvrEyePoseStatus
	{
		kGazePointValid = 1,
		kGazeVectorValid = 2,
		kEyeOpennessValid = 4,
		kEyePupilDilationValid = 8,
		kEyePositionGuideValid = 0x10
	}
	public enum TrackingMode
	{
		PVR_TRACKING_MODE_ROTATION = 1,
		PVR_TRACKING_MODE_POSITION = 2,
		PVR_TRACKING_MODE_EYE = 4
	}
	public struct EyeTrackingData
	{
		public int leftEyePoseStatus;

		public int rightEyePoseStatus;

		public int combinedEyePoseStatus;

		public Vector3 leftEyeGazePoint;

		public Vector3 rightEyeGazePoint;

		public Vector3 combinedEyeGazePoint;

		public Vector3 leftEyeGazeVector;

		public Vector3 rightEyeGazeVector;

		public Vector3 combinedEyeGazeVector;

		public float leftEyeOpenness;

		public float rightEyeOpenness;

		public float leftEyePupilDilation;

		public float rightEyePupilDilation;

		public Vector3 leftEyePositionGuide;

		public Vector3 rightEyePositionGuide;

		public Vector3 foveatedGazeDirection;

		public int foveatedGazeTrackingState;

		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]
		public byte[] reserved;
	}
	public struct EyeTrackingGazeRay
	{
		public Vector3 Direction;

		public bool IsValid;

		public Vector3 Origin;
	}
	public struct EyeDeviceInfo
	{
		public ViewFrustum targetFrustumLeft;

		public ViewFrustum targetFrustumRight;
	}
	public struct ViewFrustum
	{
		public float left;

		public float right;

		public float top;

		public float bottom;

		public float near;

		public float far;
	}
	public struct EyeSetting
	{
		public Transform eyelocalPosition;

		public Rect eyeRect;

		public float eyeFov;

		public float eyeAspect;

		public Matrix4x4 eyeProjectionMatrix;

		public Shader eyeShader;
	}
	public struct Sensor
	{
		public const string LibFileName = "Pvr_UnitySDK";

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_Enable6DofModule(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_OptionalResetSensor(int index, int resetRot, int resetPos);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_Init(int index);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_StartSensor(int index);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_StopSensor(int index);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_ResetSensor(int index);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_ResetSensorAll(int index);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetSensorState(int index, ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetMainSensorState(ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz, ref float vfov, ref float hfov, ref int viewNumber);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetPsensorState();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetHmdPSensorStatus();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetSensorGyroscope(int index, ref float x, ref float y, ref float z);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetSensorMagnet(int index, ref float x, ref float y, ref float z);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_Get6DofSensorQualityStatus();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_Get6DofSafePanelFlag();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetReinPosition(float x, float y, float z, float w, float px, float py, float pz, int hand, bool valid, int key);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_SetTrackingOriginType(TrackingOrigin trackingOriginType);

		public static bool UPvr_Pvr_Get6DofSafePanelFlag()
		{
			return Pvr_Get6DofSafePanelFlag();
		}

		public static int UPvr_Init(int index)
		{
			return Pvr_Init(index);
		}

		public static void UPvr_InitPsensor()
		{
			Pvr_InitPsensor();
		}

		public static int UPvr_GetPsensorState()
		{
			int res = -1;
			int configsenum = 4;
			Render.UPvr_GetIntConfig(configsenum, ref res);
			if (res == 1)
			{
				return Pvr_GetPsensorState();
			}
			int num = Pvr_GetAndroidPsensorState();
			if (num != 0 && num != -1)
			{
				num = 1;
			}
			return num;
		}

		public static int UPvr_GetPSensorStatus()
		{
			return Pvr_GetHmdPSensorStatus();
		}

		public static void UPvr_UnregisterPsensor()
		{
			Pvr_UnregisterPsensor();
		}

		public static int UPvr_StartSensor(int index)
		{
			return Pvr_StartSensor(index);
		}

		public static int UPvr_StopSensor(int index)
		{
			return Pvr_StopSensor(index);
		}

		public static int UPvr_ResetSensor(int index)
		{
			Pvr_UnitySDKManager.SDK.resetBasePos = default(Vector3);
			return Pvr_ResetSensor(index);
		}

		public static int UPvr_OptionalResetSensor(int index, int resetRot, int resetPos)
		{
			return Pvr_OptionalResetSensor(index, resetRot, resetPos);
		}

		public static int UPvr_GetSensorState(int index, ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz)
		{
			return Pvr_GetSensorState(index, ref x, ref y, ref z, ref w, ref px, ref py, ref pz);
		}

		public static int UPvr_GetMainSensorState(ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz, ref float vfov, ref float hfov, ref int viewNumber)
		{
			return Pvr_GetMainSensorState(ref x, ref y, ref z, ref w, ref px, ref py, ref pz, ref vfov, ref hfov, ref viewNumber);
		}

		public static int UPvr_GetSensorGyroscope(int index, ref float x, ref float y, ref float z)
		{
			return Pvr_GetSensorGyroscope(index, ref x, ref y, ref z);
		}

		public static int UPvr_GetSensorMagnet(int index, ref float x, ref float y, ref float z)
		{
			return Pvr_GetSensorMagnet(index, ref x, ref y, ref z);
		}

		public static int UPvr_Get6DofSensorQualityStatus()
		{
			return Pvr_Get6DofSensorQualityStatus();
		}

		public static int UPvr_Enable6DofModule(bool enable)
		{
			return Pvr_Enable6DofModule(enable);
		}

		public static void Pvr_InitPsensor()
		{
			try
			{
				System.UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaSysActivityClass, "initPsensor", Pvr_UnitySDKRender.Instance.activity);
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
		}

		public static bool Pvr_IsHead6dofReset()
		{
			int res = 0;
			Render.UPvr_GetIntConfig(17, ref res);
			if (res > 0)
			{
				return false;
			}
			bool result = false;
			try
			{
				System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaSysActivityClass, "isHead6dofReset", Pvr_UnitySDKRender.Instance.activity);
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
			return result;
		}

		public static int Pvr_GetAndroidPsensorState()
		{
			int result = -1;
			try
			{
				System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaSysActivityClass, "getPsensorState");
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
			return result;
		}

		public static void Pvr_UnregisterPsensor()
		{
			try
			{
				System.UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaSysActivityClass, "unregisterListener");
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
		}

		public static int UPvr_ResetSensorAll(int index)
		{
			return Pvr_ResetSensorAll(index);
		}

		public static void UPvr_SetReinPosition(float x, float y, float z, float w, float px, float py, float pz, int hand, bool valid, int key)
		{
			if (PLOG.logLevel > 2)
			{
				PLOG.D("PvrLog UPvr_SetReinPosition" + x + y + z + w + px + py + pz + hand + valid + key);
			}
			Pvr_SetReinPosition(x, y, z, w, px, py, pz, hand, valid, key);
		}

		public static bool UPvr_SetTrackingOriginType(TrackingOrigin trackingOriginType)
		{
			bool flag = true;
			return Pvr_SetTrackingOriginType(trackingOriginType);
		}
	}
	public struct Render
	{
		public const string LibFileName = "Pvr_UnitySDK";

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_ChangeScreenParameters(string model, int width, int height, double xppi, double yppi, double densityDpi);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_SetRatio(float midH, float midV);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_SetPupillaryPoint(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr Pvr_GetSupportHMDTypes();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetCurrentHMDType([MarshalAs(UnmanagedType.LPStr)] string type);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetIntConfig(int configsenum, ref int res);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetFloatConfig(int configsenum, ref float res);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetupLayerData(int layerIndex, int sideMask, int textureId, int textureType, int layerFlags, float[] colorScaleAndOffset);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetupLayerCoords(int layerIndex, int sideMask, float[] lowerLeft, float[] lowerRight, float[] upperLeft, float[] upperRight);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetOverlayModelViewMatrix(int overlayType, int overlayShape, int texId, int eyeSide, int layerIndex, bool isHeadLocked, int layerFlags, float[] mvMatrix, float[] modelS, float[] modelR, float[] modelT, float[] cameraR, float[] cameraT, float[] colorScaleAndOffset);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_EnableFoveation(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetFoveationParameters(int textureId, int previousId, float focalPointX, float focalPointY, float foveationGainX, float foveationGainY, float foveationArea, float foveationMinimum);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetFoveationResource(int textureId, int previousId, float focalPointX, float focalPointY);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetFoveationParameters2(float foveationGainX, float foveationGainY, float foveationArea, float foveationMinimum);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetFoveationLevel(EFoveationLevel level);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern EFoveationLevel Pvr_GetFoveationLevel();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_GetIntSysProc(string property, ref int res);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetColorspaceType(int colorspaceType);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetCastingColorspaceType(int colorspaceType);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr Pvr_CreateLayerAndroidSurface(int layerType, int layerIndex);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr Pvr_GetLayerAndroidSurface(int layerType, int layerIndex);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetMonoMode(bool openMono);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_GetStencilMesh(int eye, ref int vertexCount, ref int triangleCount, ref IntPtr vertexData, ref IntPtr indexData);

		public static void UPvr_ChangeScreenParameters(string model, int width, int height, double xppi, double yppi, double densityDpi)
		{
			Pvr_ChangeScreenParameters(model, width, height, xppi, yppi, densityDpi);
		}

		public static int UPvr_SetRatio(float midH, float midV)
		{
			return Pvr_SetRatio(midH, midV);
		}

		public static void UPvr_EnableFoveation(bool enable)
		{
			if (Pvr_UnitySDKManager.SDK.SystemFFRLevel != -1 || Pvr_UnitySDKManager.SDK.SystemDebugFFRLevel != -1)
			{
				enable = true;
			}
			Pvr_EnableFoveation(enable);
		}

		[Obsolete("This API will be removed in later versions")]
		public static void UPvr_SetFoveationParameters(int textureId, int previousId, float focalPointX, float focalPointY, float foveationGainX, float foveationGainY, float foveationArea, float foveationMinimum)
		{
			Pvr_SetFoveationParameters(textureId, previousId, focalPointX, focalPointY, foveationGainX, foveationGainY, foveationArea, foveationMinimum);
		}

		public static void UPvr_SetFoveationResource(int textureId, int previousId, float focalPointX, float focalPointY)
		{
			Pvr_SetFoveationResource(textureId, previousId, focalPointX, focalPointY);
		}

		public static void SetFoveatedRenderingLevel(EFoveationLevel level)
		{
			if (Pvr_UnitySDKManager.SDK.SystemDebugFFRLevel != -1)
			{
				Pvr_SetFoveationLevel((EFoveationLevel)Pvr_UnitySDKManager.SDK.SystemDebugFFRLevel);
			}
			else if (Pvr_UnitySDKManager.SDK.SystemFFRLevel != -1)
			{
				Pvr_SetFoveationLevel((EFoveationLevel)Pvr_UnitySDKManager.SDK.SystemFFRLevel);
			}
			else
			{
				Pvr_SetFoveationLevel(level);
			}
		}

		public static EFoveationLevel GetFoveatedRenderingLevel()
		{
			return Pvr_GetFoveationLevel();
		}

		public static void SetFoveatedRenderingParameters(Vector2 ffrGainValue, float ffrAreaValue, float ffrMinimumValue)
		{
			if (Pvr_UnitySDKManager.SDK.SystemDebugFFRLevel != -1)
			{
				Pvr_SetFoveationLevel((EFoveationLevel)Pvr_UnitySDKManager.SDK.SystemDebugFFRLevel);
			}
			else if (Pvr_UnitySDKManager.SDK.SystemFFRLevel != -1)
			{
				Pvr_SetFoveationLevel((EFoveationLevel)Pvr_UnitySDKManager.SDK.SystemFFRLevel);
			}
			else
			{
				Pvr_SetFoveationParameters2(ffrGainValue.x, ffrGainValue.y, ffrAreaValue, ffrMinimumValue);
			}
		}

		public static bool UPvr_GetIntSysProc(string property, ref int res)
		{
			bool flag = false;
			return Pvr_GetIntSysProc(property, ref res);
		}

		public static int UPvr_GetIntConfig(int configsenum, ref int res)
		{
			return Pvr_GetIntConfig(configsenum, ref res);
		}

		public static int UPvr_GetFloatConfig(int configsenum, ref float res)
		{
			return Pvr_GetFloatConfig(configsenum, ref res);
		}

		public static string UPvr_GetSupportHMDTypes()
		{
			IntPtr intPtr = Pvr_GetSupportHMDTypes();
			if (intPtr != IntPtr.Zero)
			{
				return Marshal.PtrToStringAnsi(intPtr);
			}
			return null;
		}

		public static void UPvr_SetCurrentHMDType(string type)
		{
			Pvr_SetCurrentHMDType(type);
		}

		public static void UPvr_SetupLayerData(int layerIndex, int sideMask, int textureId, int textureType, int layerFlags, Vector4 colorScale, Vector4 colorOffset)
		{
			Pvr_SetupLayerData(layerIndex, sideMask, textureId, textureType, layerFlags, new float[8] { colorScale.x, colorScale.y, colorScale.z, colorScale.w, colorOffset.x, colorOffset.y, colorOffset.z, colorOffset.w });
		}

		public static void UPvr_SetupLayerCoords(int layerIndex, int sideMask, float[] lowerLeft, float[] lowerRight, float[] upperLeft, float[] upperRight)
		{
			Pvr_SetupLayerCoords(layerIndex, sideMask, lowerLeft, lowerRight, upperLeft, upperRight);
		}

		public static void UPvr_SetOverlayModelViewMatrix(int overlayType, int overlayShape, int texId, int eyeSide, int layerIndex, bool isHeadLocked, int layerFlags, Matrix4x4 mvMatrix, Vector3 modelS, Quaternion modelR, Vector3 modelT, Quaternion cameraR, Vector3 cameraT, Vector4 colorScale, Vector4 colorOffset)
		{
			Pvr_SetOverlayModelViewMatrix(overlayType, overlayShape, texId, eyeSide, layerIndex, isHeadLocked, layerFlags, new float[16]
			{
				mvMatrix.m00, mvMatrix.m01, mvMatrix.m02, mvMatrix.m03, mvMatrix.m10, mvMatrix.m11, mvMatrix.m12, mvMatrix.m13, mvMatrix.m20, mvMatrix.m21,
				mvMatrix.m22, mvMatrix.m23, mvMatrix.m30, mvMatrix.m31, mvMatrix.m32, mvMatrix.m33
			}, new float[3] { modelS.x, modelS.y, modelS.z }, new float[4] { modelR.x, modelR.y, modelR.z, modelR.w }, new float[3] { modelT.x, modelT.y, modelT.z }, new float[4] { cameraR.x, cameraR.y, cameraR.z, cameraR.w }, new float[3] { cameraT.x, cameraT.y, cameraT.z }, new float[8] { colorScale.x, colorScale.y, colorScale.z, colorScale.w, colorOffset.x, colorOffset.y, colorOffset.z, colorOffset.w });
		}

		public static void UPvr_SetColorspaceType(int colorspaceType)
		{
			Pvr_SetColorspaceType(colorspaceType);
		}

		public static void UPvr_SetCastingColorspaceType(int colorspaceType)
		{
			Pvr_SetCastingColorspaceType(colorspaceType);
		}

		public static IntPtr UPvr_CreateLayerAndroidSurface(int layerType, int layerIndex)
		{
			return Pvr_CreateLayerAndroidSurface(layerType, layerIndex);
		}

		public static IntPtr UPvr_GetLayerAndroidSurface(int layerType, int layerIndex)
		{
			return Pvr_GetLayerAndroidSurface(layerType, layerIndex);
		}

		public static void UPvr_SetMonoMode(bool openMono)
		{
			Pvr_SetMonoMode(openMono);
		}

		public static void UPvr_GetStencilMesh(int eye, ref int vertexCount, ref int triangleCount, ref IntPtr vertexDataPtr, ref IntPtr indexDataPtr)
		{
			Pvr_GetStencilMesh(eye, ref vertexCount, ref triangleCount, ref vertexDataPtr, ref indexDataPtr);
		}
	}
	public struct System
	{
		public const string LibFileName = "Pvr_UnitySDK";

		public const string UnitySDKVersion = "2.8.9.10";

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_SetInitActivity(IntPtr activity, IntPtr vrActivityClass);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr Pvr_GetSDKVersion();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int Pvr_GetHmdHardwareVersion();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr Pvr_GetHmdFirmwareVersion();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr Pvr_GetHmdSerialNumber();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int PVR_GetHmdBatteryStatus();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern float PVR_GetHmdBatteryTemperature();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int PVR_SetHmdAudioStatus(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_GetEyeTrackingData(ref int leftEyePoseStatus, ref int rightEyePoseStatus, ref int combinedEyePoseStatus, ref float leftEyeGazePointX, ref float leftEyeGazePointY, ref float leftEyeGazePointZ, ref float rightEyeGazePointX, ref float rightEyeGazePointY, ref float rightEyeGazePointZ, ref float combinedEyeGazePointX, ref float combinedEyeGazePointY, ref float combinedEyeGazePointZ, ref float leftEyeGazeVectorX, ref float leftEyeGazeVectorY, ref float leftEyeGazeVectorZ, ref float rightEyeGazeVectorX, ref float rightEyeGazeVectorY, ref float rightEyeGazeVectorZ, ref float combinedEyeGazeVectorX, ref float combinedEyeGazeVectorY, ref float combinedEyeGazeVectorZ, ref float leftEyeOpenness, ref float rightEyeOpenness, ref float leftEyePupilDilation, ref float rightEyePupilDilation, ref float leftEyePositionGuideX, ref float leftEyePositionGuideY, ref float leftEyePositionGuideZ, ref float rightEyePositionGuideX, ref float rightEyePositionGuideY, ref float rightEyePositionGuideZ, ref float foveatedGazeDirectionX, ref float foveatedGazeDirectionY, ref float foveatedGazeDirectionZ, ref int foveatedGazeTrackingState);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_SetTrackingMode(int trackingMode);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int Pvr_GetTrackingMode();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr GetRenderEventFunc();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void UnityEventData(long data);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_EnableSinglePass(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_SetAntiAliasing(int antiAliasing);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_SinglePassBeforeForwardOpaque();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_SetCurrentRenderTexture(uint textureId);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_SetSinglePassDepthBufferWidthHeight(int width, int height);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int PVR_setPerformanceLevels(int cpuLevel, int gpuLevel);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_SetIPD(float distance);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern float Pvr_GetIPD();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_SetTrackingIPDEnabled(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_GetTrackingIPDEnabled();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_GetEyeTrackingAutoIPD(ref float autoIPD);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int PVR_GetHmdAudioStatus();

		public static bool UPvr_CallStaticMethod<T>(ref T result, AndroidJavaClass jclass, string name, params object[] args)
		{
			try
			{
				result = jclass.CallStatic<T>(name, args);
				return true;
			}
			catch (AndroidJavaException ex)
			{
				PLOG.E("Exception calling static method " + name + ": " + ex);
				return false;
			}
		}

		public static bool UPvr_CallStaticMethod(AndroidJavaObject jobj, string name, params object[] args)
		{
			try
			{
				jobj.CallStatic(name, args);
				return true;
			}
			catch (AndroidJavaException ex)
			{
				PLOG.E("CallStaticMethod  Exception calling activity method " + name + ": " + ex);
				return false;
			}
		}

		public static bool UPvr_CallMethod<T>(ref T result, AndroidJavaObject jobj, string name, params object[] args)
		{
			try
			{
				result = jobj.Call<T>(name, args);
				return true;
			}
			catch (AndroidJavaException ex)
			{
				PLOG.E("Exception calling activity method " + name + ": " + ex);
				return false;
			}
		}

		public static bool UPvr_CallMethod(AndroidJavaObject jobj, string name, params object[] args)
		{
			try
			{
				jobj.Call(name, args);
				return true;
			}
			catch (AndroidJavaException ex)
			{
				PLOG.E(" Exception calling activity method " + name + ": " + ex);
				return false;
			}
		}

		public static string UPvr_GetSDKVersion()
		{
			IntPtr intPtr = Pvr_GetSDKVersion();
			if (intPtr != IntPtr.Zero)
			{
				return Marshal.PtrToStringAnsi(intPtr);
			}
			return string.Empty;
		}

		public static string UPvr_GetUnitySDKVersion()
		{
			return "2.8.9.10";
		}

		public static string UPvr_GetDeviceMode()
		{
			string empty = string.Empty;
			return SystemInfo.deviceModel;
		}

		public static string UPvr_GetDeviceModel()
		{
			return SystemInfo.deviceModel;
		}

		public static string UPvr_GetDeviceSN()
		{
			string result = "UNKONWN";
			UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaSysActivityClass, "getDeviceSN");
			return result;
		}

		public static AndroidJavaObject UPvr_GetCurrentActivity()
		{
			AndroidJavaObject androidJavaObject = null;
			AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
			return androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
		}

		public static bool UPvr_SetMonoPresentation()
		{
			bool flag = false;
			return UPvr_CallMethod(UPvr_GetCurrentActivity(), "Pvr_setMonoPresentation");
		}

		public static bool UPvr_IsPresentationExisted()
		{
			bool flag = false;
			bool result = false;
			return UPvr_CallMethod(ref result, UPvr_GetCurrentActivity(), "Pvr_isPresentationExisted") && result;
		}

		public static bool UPvr_GetMainActivityPauseStatus()
		{
			bool flag = false;
			bool result = false;
			return UPvr_CallMethod(ref result, UPvr_GetCurrentActivity(), "Pvr_getMainActivityPauseStatus") && result;
		}

		public static void UPvr_Sleep()
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaSysActivityClass, "Pvr_Sleep");
		}

		public static bool UPvr_StartHomeKeyReceiver(string startreceivre)
		{
			try
			{
				if (Pvr_UnitySDKRender.Instance != null)
				{
					UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityLongReceiver, "Pvr_StartReceiver", Pvr_UnitySDKRender.Instance.activity, startreceivre);
					PLOG.I("Start home key Receiver");
					return true;
				}
			}
			catch (Exception ex)
			{
				PLOG.E("Start home key  Receiver  Error :" + ex.ToString());
				return false;
			}
			return true;
		}

		public static bool UPvr_StopHomeKeyReceiver()
		{
			try
			{
				if (Pvr_UnitySDKRender.Instance != null)
				{
					UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityLongReceiver, "Pvr_StopReceiver", Pvr_UnitySDKRender.Instance.activity);
					PLOG.I("Stop home key Receiver");
					return true;
				}
			}
			catch (Exception ex)
			{
				PLOG.E("Stop home key Receiver Error :" + ex.ToString());
				return false;
			}
			return true;
		}

		public static void UPvr_StartVRModel()
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityClass, "startVRModel");
		}

		public static void UPvr_RemovePlatformLogo()
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityClass, "removePlatformLogo");
		}

		public static void UPvr_ShowPlatformLogo()
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityClass, "showPlatformLogo");
		}

		public static bool UPvr_IsPicoActivity()
		{
			bool flag = false;
			bool result = false;
			return UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "isPicoActivity", UPvr_GetCurrentActivity()) && result;
		}

		public static void UPvr_StopVRModel()
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityClass, "stopVRModel");
		}

		public static string UPvr_GetCountryCode()
		{
			string result = string.Empty;
			UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getCountryCode", UPvr_GetCurrentActivity());
			return result;
		}

		public static bool UPvr_SetIPD(float distance)
		{
			bool flag = false;
			flag = Pvr_SetIPD(distance);
			if (flag)
			{
				for (int i = 0; i < Pvr_UnitySDKEyeManager.Instance.Eyes.Length; i++)
				{
					Pvr_UnitySDKEyeManager.Instance.Eyes[i].RefreshCameraPosition(distance);
				}
			}
			return flag;
		}

		public static float UPvr_GetIPD()
		{
			float num = Pvr_GetIPD();
			Debug.Log("DISFT IPD:" + num);
			return num;
		}

		public static bool UPvr_SetTrackingIPDEnabled(bool enable)
		{
			return Pvr_SetTrackingIPDEnabled(enable);
		}

		public static bool UPvr_GetTrackingIPDEnabled()
		{
			return Pvr_GetTrackingIPDEnabled();
		}

		public static bool UPvr_GetEyeTrackingAutoIPD(ref float autoipd)
		{
			return Pvr_GetEyeTrackingAutoIPD(ref autoipd);
		}

		public static void UPvr_UnityEventData(long data)
		{
			UnityEventData(data);
		}

		public static long UPvr_GetEyeBufferData(int id)
		{
			return ((long)Pvr_UnitySDKRender.Instance.RenderviewNumber << 32) | id;
		}

		public static bool UPvr_checkDevice(string packagename)
		{
			bool result = false;
			UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "checkDevice", packagename, UPvr_GetCurrentActivity());
			return result;
		}

		public static int UPvr_GetHmdHardwareVersion()
		{
			return Pvr_GetHmdHardwareVersion();
		}

		public static string UPvr_GetHmdFirmwareVersion()
		{
			IntPtr intPtr = Pvr_GetHmdFirmwareVersion();
			if (intPtr != IntPtr.Zero)
			{
				return Marshal.PtrToStringAnsi(intPtr);
			}
			return string.Empty;
		}

		public static string UPvr_GetHmdSerialNumber()
		{
			IntPtr intPtr = Pvr_GetHmdSerialNumber();
			if (intPtr != IntPtr.Zero)
			{
				return Marshal.PtrToStringAnsi(intPtr);
			}
			return string.Empty;
		}

		public static int UPvr_GetHmdBatteryStatus()
		{
			return PVR_GetHmdBatteryStatus();
		}

		public static float UPvr_GetHmdBatteryTemperature()
		{
			return PVR_GetHmdBatteryTemperature();
		}

		public static int UPvr_SetHmdAudioStatus(bool enable)
		{
			return PVR_SetHmdAudioStatus(enable);
		}

		public static int UPvr_GetTrackingMode()
		{
			int num = 0;
			return Pvr_GetTrackingMode();
		}

		public static bool UPvr_setTrackingMode(int trackingMode)
		{
			return Pvr_SetTrackingMode(trackingMode);
		}

		public static bool UPvr_getEyeTrackingData(ref EyeTrackingData trackingData)
		{
			if (!Pvr_UnitySDKEyeManager.supportEyeTracking)
			{
				PLOG.E("The device is not supported");
				return false;
			}
			if (!Pvr_UnitySDKEyeManager.Instance.EyeTracking)
			{
				PLOG.E("Please Enable \"Pvr_UnitySDK/Head/Pvr_UnitySDKEyeManager.cs/EyeTracking\"option first.");
				return false;
			}
			bool result = Pvr_GetEyeTrackingData(ref trackingData.leftEyePoseStatus, ref trackingData.rightEyePoseStatus, ref trackingData.combinedEyePoseStatus, ref trackingData.leftEyeGazePoint.x, ref trackingData.leftEyeGazePoint.y, ref trackingData.leftEyeGazePoint.z, ref trackingData.rightEyeGazePoint.x, ref trackingData.rightEyeGazePoint.y, ref trackingData.rightEyeGazePoint.z, ref trackingData.combinedEyeGazePoint.x, ref trackingData.combinedEyeGazePoint.y, ref trackingData.combinedEyeGazePoint.z, ref trackingData.leftEyeGazeVector.x, ref trackingData.leftEyeGazeVector.y, ref trackingData.leftEyeGazeVector.z, ref trackingData.rightEyeGazeVector.x, ref trackingData.rightEyeGazeVector.y, ref trackingData.rightEyeGazeVector.z, ref trackingData.combinedEyeGazeVector.x, ref trackingData.combinedEyeGazeVector.y, ref trackingData.combinedEyeGazeVector.z, ref trackingData.leftEyeOpenness, ref trackingData.rightEyeOpenness, ref trackingData.leftEyePupilDilation, ref trackingData.rightEyePupilDilation, ref trackingData.leftEyePositionGuide.x, ref trackingData.leftEyePositionGuide.y, ref trackingData.leftEyePositionGuide.z, ref trackingData.rightEyePositionGuide.x, ref trackingData.rightEyePositionGuide.y, ref trackingData.rightEyePositionGuide.z, ref trackingData.foveatedGazeDirection.x, ref trackingData.foveatedGazeDirection.y, ref trackingData.foveatedGazeDirection.z, ref trackingData.foveatedGazeTrackingState);
			trackingData.leftEyeGazeVector.z = 0f - trackingData.leftEyeGazeVector.z;
			trackingData.rightEyeGazeVector.z = 0f - trackingData.rightEyeGazeVector.z;
			trackingData.combinedEyeGazeVector.z = 0f - trackingData.combinedEyeGazeVector.z;
			trackingData.leftEyeGazePoint.z = 0f - trackingData.leftEyeGazePoint.z;
			trackingData.rightEyeGazePoint.z = 0f - trackingData.rightEyeGazePoint.z;
			trackingData.combinedEyeGazePoint.z = 0f - trackingData.combinedEyeGazePoint.z;
			trackingData.foveatedGazeDirection.z = 0f - trackingData.foveatedGazeDirection.z;
			return result;
		}

		public static bool UPvr_getEyeTrackingGazeRay(ref EyeTrackingGazeRay gazeRay)
		{
			if (!Pvr_UnitySDKEyeManager.supportEyeTracking)
			{
				PLOG.E("The device is not supported");
				return false;
			}
			if (!Pvr_UnitySDKEyeManager.Instance.EyeTracking)
			{
				PLOG.E("Please Enable \"Pvr_UnitySDK/Head/Pvr_UnitySDKEyeManager.cs/EyeTracking\"option first.");
				return false;
			}
			EyeTrackingData trackingData = default(EyeTrackingData);
			bool flag = UPvr_getEyeTrackingData(ref trackingData);
			gazeRay.IsValid = ((uint)trackingData.combinedEyePoseStatus & (true ? 1u : 0u)) != 0 && (trackingData.combinedEyePoseStatus & 2) != 0;
			if (gazeRay.IsValid)
			{
				gazeRay.Direction = trackingData.combinedEyeGazeVector;
				gazeRay.Origin = trackingData.combinedEyeGazePoint;
				gazeRay.Origin = Pvr_UnitySDKSensor.Instance.HeadPose.Matrix.MultiplyPoint(gazeRay.Origin);
				gazeRay.Direction = Pvr_UnitySDKSensor.Instance.HeadPose.Matrix.MultiplyVector(gazeRay.Direction);
				return true;
			}
			return false;
		}

		public static bool UPvr_getEyeTrackingGazeRayWorld(ref EyeTrackingGazeRay gazeRay)
		{
			if (!Pvr_UnitySDKEyeManager.supportEyeTracking)
			{
				PLOG.E("The device is not supported");
				return false;
			}
			if (!Pvr_UnitySDKEyeManager.Instance.EyeTracking)
			{
				PLOG.E("Please Enable \"Pvr_UnitySDK/Head/Pvr_UnitySDKEyeManager.cs/EyeTracking\"option first.");
				return false;
			}
			Transform transform = Pvr_UnitySDKEyeManager.Instance.transform;
			Matrix4x4 matrix4x = Matrix4x4.TRS(transform.position, transform.rotation, Vector3.one);
			EyeTrackingData trackingData = default(EyeTrackingData);
			bool flag = UPvr_getEyeTrackingData(ref trackingData);
			gazeRay.IsValid = ((uint)trackingData.combinedEyePoseStatus & (true ? 1u : 0u)) != 0 && (trackingData.combinedEyePoseStatus & 2) != 0;
			if (gazeRay.IsValid)
			{
				gazeRay.Direction = trackingData.combinedEyeGazeVector;
				gazeRay.Origin = trackingData.combinedEyeGazePoint;
				gazeRay.Origin = matrix4x.MultiplyPoint(gazeRay.Origin);
				gazeRay.Direction = matrix4x.MultiplyVector(gazeRay.Direction);
				return true;
			}
			return false;
		}

		public static Vector3 UPvr_getEyeTrackingPos()
		{
			if (!Pvr_UnitySDKEyeManager.supportEyeTracking)
			{
				PLOG.E("The device is not supported");
				return Vector3.zero;
			}
			if (!Pvr_UnitySDKEyeManager.Instance.EyeTracking)
			{
				PLOG.E("Please Enable \"Pvr_UnitySDK/Head/Pvr_UnitySDKEyeManager.cs/EyeTracking\"option first.");
				return Vector3.zero;
			}
			return Pvr_UnitySDKEyeManager.Instance.GetEyeTrackingPos();
		}

		public static int UPvr_GetPhoneScreenBrightness()
		{
			int result = 0;
			UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClientClass, "Pvr_GetScreen_Brightness", UPvr_GetCurrentActivity());
			return result;
		}

		public static void UPvr_SetPhoneScreenBrightness(int level)
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityClientClass, "Pvr_setAPPScreen_Brightness", UPvr_GetCurrentActivity(), level);
		}

		public static bool UPvr_IsPicoDefaultActivity()
		{
			using (AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer"))
			{
				using AndroidJavaObject androidJavaObject = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
				string text = androidJavaObject.Call<string>("getLocalClassName", new object[0]);
				if (text == "com.unity3d.player.UnityPlayerNativeActivityPico")
				{
					return true;
				}
			}
			return false;
		}

		public static bool UPvr_EnableSinglePass(bool enable)
		{
			return Pvr_EnableSinglePass(enable);
		}

		public static void UPvr_SetAntiAliasing(int antiAliasing)
		{
			Pvr_SetAntiAliasing(antiAliasing);
		}

		public static void UPvr_SinglePassBeforeForwardOpaque()
		{
			Pvr_SinglePassBeforeForwardOpaque();
		}

		public static void UPvr_SetCurrentRenderTexture(uint textureId)
		{
			Pvr_SetCurrentRenderTexture(textureId);
		}

		public static bool UPvr_SetSinglePassDepthBufferWidthHeight(int width, int height)
		{
			bool flag = false;
			return Pvr_SetSinglePassDepthBufferWidthHeight(width, height);
		}

		public static int UPVR_setPerformanceLevels(int cpuLevel, int gpuLevel)
		{
			int num = -1;
			return PVR_setPerformanceLevels(cpuLevel, gpuLevel);
		}

		public static int UPvr_GetColorRes(string name)
		{
			int result = -1;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getColorRes", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetColorResError :" + ex.ToString());
			}
			return result;
		}

		public static int UPvr_GetConfigInt(string name)
		{
			int result = -1;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getConfigInt", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetConfigIntError :" + ex.ToString());
			}
			return result;
		}

		public static string UPvr_GetConfigString(string name)
		{
			string result = string.Empty;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getConfigString", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetConfigStringError :" + ex.ToString());
			}
			return result;
		}

		public static string UPvr_GetDrawableLocation(string name)
		{
			string result = string.Empty;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getDrawableLocation", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetDrawableLocationError :" + ex.ToString());
			}
			return result;
		}

		public static int UPvr_GetTextSize(string name)
		{
			int result = -1;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getTextSize", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetTextSizeError :" + ex.ToString());
			}
			return result;
		}

		public static string UPvr_GetLangString(string name)
		{
			string result = string.Empty;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getLangString", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetLangStringError :" + ex.ToString());
			}
			return result;
		}

		public static string UPvr_GetStringValue(string id, int type)
		{
			string result = string.Empty;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getStringValue", id, type);
			}
			catch (Exception ex)
			{
				PLOG.E("GetStringValueError :" + ex.ToString());
			}
			return result;
		}

		public static int UPvr_GetIntValue(string id, int type)
		{
			int result = -1;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getIntValue", id, type);
			}
			catch (Exception ex)
			{
				PLOG.E("GetIntValueError :" + ex.ToString());
			}
			return result;
		}

		public static float UPvr_GetFloatValue(string id)
		{
			float result = -1f;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getFloatValue", id);
			}
			catch (Exception ex)
			{
				PLOG.E("GetFloatValueError :" + ex.ToString());
			}
			return result;
		}

		public static string UPvr_GetObjectOrArray(string id, int type)
		{
			string result = string.Empty;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getObjectOrArray", id, type);
			}
			catch (Exception ex)
			{
				PLOG.E("GetObjectOrArrayError :" + ex.ToString());
			}
			return result;
		}

		public static int UPvr_GetCharSpace(string id)
		{
			int result = -1;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getCharSpace", id);
			}
			catch (Exception ex)
			{
				PLOG.E("GetCharSpaceError :" + ex.ToString());
			}
			return result;
		}
	}
	public struct BoundarySystem
	{
		public enum BoundaryType
		{
			OuterBoundary,
			PlayArea
		}

		public struct BoundaryTestResult
		{
			public bool IsTriggering;

			public float ClosestDistance;

			public Vector3 ClosestPoint;

			public Vector3 ClosestPointNormal;
		}

		public enum BoundaryTrackingNode
		{
			HandLeft,
			HandRight,
			Head
		}

		public enum BoundaryTrackingState
		{
			PVR_NOREASON,
			PVRRELOCATION_IN_PROGRESS,
			PVRLOW_FEATURE_COUNT_ERROR,
			PVRLOW_LIGHT_ERROR,
			PVRBRIGHT_LIGHT_ERROR,
			PVRSTEREO_CAMERA_CALIBRATION_ERROR
		}

		public const string LibFileName = "Pvr_UnitySDK";

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern float Pvr_GetFloorHeight();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetSeeThroughState();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_BoundarySetSTBackground(bool value);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetTrackingState();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_GetFrameRateLimit();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_IsBoundaryEnable();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_BoundaryGetConfigured();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_BoundaryTestNode(int node, bool isPlayArea, ref bool isTriggering, ref float closestDistance, ref float px, ref float py, ref float pz, ref float nx, ref float ny, ref float nz);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_BoundaryTestPoint(float x, float y, float z, bool isPlayArea, ref bool isTriggering, ref float closestDistance, ref float px, ref float py, ref float pz, ref float nx, ref float ny, ref float nz);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_BoundaryGetGeometry(out IntPtr handle, bool isPlayArea);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_BoundaryGetDimensions(ref float x, ref float y, ref float z, bool isPlayArea);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_BoundaryGetEnabled();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_BoundarySetVisible(bool value);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_BoundaryGetVisible();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_EnableLWRP(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_SetViewportSize(int w, int h);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_BoundarySetSeeThroughVisible(bool value);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void PVR_SetCameraImageRect(int width, int height);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetGuardianSystemDisable(bool value);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetDialogState();

		public static float UPvr_GetFloorHeight()
		{
			float num = 0f;
			return Pvr_GetFloorHeight();
		}

		public static int UPvr_GetSeeThroughState()
		{
			int num = 0;
			return Pvr_GetSeeThroughState();
		}

		public static void UPvr_EnableSeeThroughManual(bool enable)
		{
			Pvr_BoundarySetSTBackground(enable);
		}

		public static BoundaryTrackingState UPvr_GetTrackingState()
		{
			BoundaryTrackingState boundaryTrackingState = BoundaryTrackingState.PVR_NOREASON;
			return (BoundaryTrackingState)Pvr_GetTrackingState();
		}

		public static bool UPvr_GetFrameRateLimit()
		{
			bool flag = false;
			return Pvr_GetFrameRateLimit();
		}

		public static bool UPvr_IsBoundaryEnable()
		{
			bool flag = false;
			return Pvr_IsBoundaryEnable();
		}

		public static bool UPvr_BoundaryGetConfigured()
		{
			bool flag = false;
			return Pvr_BoundaryGetConfigured();
		}

		public static BoundaryTestResult UPvr_BoundaryTestNode(BoundaryTrackingNode node, BoundaryType boundaryType)
		{
			BoundaryTestResult result = default(BoundaryTestResult);
			bool flag = Pvr_BoundaryTestNode((int)node, boundaryType == BoundaryType.PlayArea, ref result.IsTriggering, ref result.ClosestDistance, ref result.ClosestPoint.x, ref result.ClosestPoint.y, ref result.ClosestPoint.z, ref result.ClosestPointNormal.x, ref result.ClosestPointNormal.y, ref result.ClosestPointNormal.z);
			result.ClosestPoint.z = 0f - result.ClosestPoint.z;
			result.ClosestPointNormal.z = 0f - result.ClosestPointNormal.z;
			if (!flag)
			{
				Debug.LogError($"UPvr_BoundaryTestNode({node}, {boundaryType}) API call failed!");
			}
			return result;
		}

		public static BoundaryTestResult UPvr_BoundaryTestPoint(Vector3 point, BoundaryType boundaryType)
		{
			BoundaryTestResult result = default(BoundaryTestResult);
			if (!Pvr_BoundaryTestPoint(point.x, point.y, 0f - point.z, boundaryType == BoundaryType.PlayArea, ref result.IsTriggering, ref result.ClosestDistance, ref result.ClosestPoint.x, ref result.ClosestPoint.y, ref result.ClosestPoint.z, ref result.ClosestPointNormal.x, ref result.ClosestPointNormal.y, ref result.ClosestPointNormal.z))
			{
				Debug.LogError($"UPvr_BoundaryTestPoint({point}, {boundaryType}) API call failed!");
			}
			return result;
		}

		public static Vector3[] UPvr_BoundaryGetGeometry(BoundaryType boundaryType)
		{
			IntPtr handle = IntPtr.Zero;
			int num = Pvr_BoundaryGetGeometry(out handle, boundaryType == BoundaryType.PlayArea);
			if (num <= 0)
			{
				Debug.LogError("Boundary geometry point count is " + num);
				return null;
			}
			int num2 = num * 3;
			float[] array = new float[num2];
			Marshal.Copy(handle, array, 0, num2);
			Vector3[] array2 = new Vector3[num];
			for (int i = 0; i < num; i++)
			{
				ref Vector3 reference = ref array2[i];
				reference = new Vector3
				{
					x = array[3 * i],
					y = array[3 * i + 1],
					z = 0f - array[3 * i + 2]
				};
			}
			return array2;
		}

		public static Vector3 UPvr_BoundaryGetDimensions(BoundaryType boundaryType)
		{
			float x = 0f;
			float y = 0f;
			float z = 0f;
			Pvr_BoundaryGetDimensions(ref x, ref y, ref z, boundaryType == BoundaryType.PlayArea);
			return new Vector3(x, y, z);
		}

		public static bool UPvr_BoundaryGetEnabled()
		{
			bool flag = false;
			return Pvr_BoundaryGetEnabled();
		}

		public static void UPvr_BoundarySetVisible(bool value)
		{
			Pvr_BoundarySetVisible(value);
		}

		public static bool UPvr_BoundaryGetVisible()
		{
			return Pvr_BoundaryGetVisible();
		}

		public static bool UPvr_EnableLWRP(bool enable)
		{
			return Pvr_EnableLWRP(enable);
		}

		public static bool UPvr_SetViewportSize(int width, int height)
		{
			return Pvr_SetViewportSize(width, height);
		}

		public static void UPvr_StartCameraFrame()
		{
			try
			{
				Pvr_UnitySDKPluginEvent.Issue(RenderEventType.StartCameraFrame);
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_StartCameraFrame :" + ex.ToString());
			}
		}

		public static void UPvr_StopCameraFrame()
		{
			try
			{
				Pvr_UnitySDKPluginEvent.Issue(RenderEventType.StopCameraFrame);
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_StopCameraFrame :" + ex.ToString());
			}
		}

		public static void UPvr_BoundaryGetSeeThroughData(int cameraIndex, RenderTexture renderTexture)
		{
			try
			{
				if (renderTexture.IsCreated())
				{
					long data = renderTexture.GetNativeTexturePtr().ToInt32();
					System.UPvr_UnityEventData(data);
					switch (cameraIndex)
					{
					case 0:
						Pvr_UnitySDKPluginEvent.Issue(RenderEventType.CameraFrameLeft);
						break;
					case 1:
						Pvr_UnitySDKPluginEvent.Issue(RenderEventType.CameraFrameRight);
						break;
					}
				}
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_BoundaryGetSeeThroughDataError :" + ex.ToString());
			}
		}

		public static void UPvr_BoundarySetCameraImageRect(int width, int height)
		{
			try
			{
				PVR_SetCameraImageRect(width, height);
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_BoundarySetCameraImageRectError :" + ex.ToString());
			}
		}

		public static void UPvr_BoundarySetSeeThroughVisible(bool value)
		{
			try
			{
				Pvr_BoundarySetSeeThroughVisible(value);
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_BoundarySetSeeThroughVisibleError :" + ex.ToString());
			}
		}

		public static void UPvr_SetGuardianSystemDisable(bool value)
		{
			try
			{
				Pvr_SetGuardianSystemDisable(value);
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_SetGuardianSystemDisableError :" + ex.ToString());
			}
		}

		public static int UPvr_GetDialogState()
		{
			int result = 0;
			try
			{
				result = Pvr_GetDialogState();
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_GetDialogStateError :" + ex.ToString());
			}
			return result;
		}
	}
	[StructLayout(0, Size = 1)]
	public struct PlatformSettings
	{
		public static Pvr_UnitySDKPlatformSetting.simulationType UPvr_IsCurrentDeviceValid()
		{
			if (Pvr_UnitySDKPlatformSetting.Entitlementchecksimulation)
			{
				if (Pvr_UnitySDKPlatformSetting.Instance.deviceSN.Count <= 0)
				{
					Debug.Log("DISFT Entitlement Check Simulation deviceSN is Null");
					return Pvr_UnitySDKPlatformSetting.simulationType.Null;
				}
				foreach (string item in Pvr_UnitySDKPlatformSetting.Instance.deviceSN)
				{
					if (System.UPvr_GetDeviceSN() == item)
					{
						return Pvr_UnitySDKPlatformSetting.simulationType.Valid;
					}
				}
				Debug.Log("DISFT Entitlement Check Simulation deviceSN is Invalid");
				return Pvr_UnitySDKPlatformSetting.simulationType.Invalid;
			}
			Debug.Log("DISFT Entitlement Check Simulation DO NOT Enable");
			return Pvr_UnitySDKPlatformSetting.simulationType.Invalid;
		}

		public static bool UPvr_AppEntitlementCheck(string appid)
		{
			bool result = false;
			try
			{
				System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "verifyAPP", System.UPvr_GetCurrentActivity(), appid, string.Empty);
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
			Debug.Log("PvrLog UPvr_AppEntitlementCheck" + result);
			return result;
		}

		[Obsolete("This API will be removed in later versions")]
		public static bool UPvr_KeyEntitlementCheck(string publicKey)
		{
			bool result = false;
			try
			{
				System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "verifyAPP", System.UPvr_GetCurrentActivity(), string.Empty, publicKey);
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
			Debug.Log("PvrLog UPvr_KeyEntitlementCheck" + result);
			return result;
		}

		public static int UPvr_AppEntitlementCheckExtra(string appid)
		{
			return 0;
		}

		public static int UPvr_KeyEntitlementCheckExtra(string publicKey)
		{
			int result = -1;
			try
			{
				System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "verifyAPPExt", System.UPvr_GetCurrentActivity(), string.Empty, publicKey);
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
			Debug.Log("PvrLog UPvr_KeyEntitlementCheck" + result);
			return result;
		}

		public static int UPvr_GetHmdAudioStatus()
		{
			return System.PVR_GetHmdAudioStatus();
		}
	}
}
public class PLOG : MonoBehaviour
{
	public static int logLevel;

	public static void getConfigTraceLevel()
	{
		int configsenum = 6;
		Render.UPvr_GetIntConfig(configsenum, ref logLevel);
	}

	public static void D(string msg)
	{
		if (logLevel > 2)
		{
			Debug.Log(msg);
		}
	}

	public static void I(string msg)
	{
		if (logLevel > 1)
		{
			Debug.Log(msg);
		}
	}

	public static void W(string msg)
	{
		if (logLevel > 0)
		{
			Debug.LogWarning(msg);
		}
	}

	public static void E(string msg)
	{
		Debug.LogError(msg);
	}
}
public class CPicoSDKSettingAsset : ScriptableObject
{
	public bool IgnoreSDKSetting;

	public bool DontshowBuildWaring;

	public bool AppIDChecked;
}
[Serializable]
public class Pvr_UnitySDKProjectSetting : ScriptableObject
{
	public RenderTextureAntiAliasing rtAntiAlising;

	public RenderTextureDepth rtBitDepth;

	public RenderTextureFormat rtFormat;

	public bool usedefaultRenderTexture;

	public Vector2 customRTSize;

	public bool usedefaultfps;

	public int customfps;

	public bool usesinglepass;

	public bool usecontentprotect;

	public static Pvr_UnitySDKProjectSetting GetProjectConfig()
	{
		return Resources.Load<Pvr_UnitySDKProjectSetting>("ProjectSetting");
	}
}
public sealed class Pvr_UnitySDKPlatformSetting : ScriptableObject
{
	public enum simulationType
	{
		Null,
		Invalid,
		Valid
	}

	[SerializeField]
	private bool entitlementchecksimulation;

	[SerializeField]
	private bool startTimeEntitlementCheck;

	[SerializeField]
	public string appID;

	public List<string> deviceSN = new List<string>();

	private static Pvr_UnitySDKPlatformSetting instance;

	public static bool Entitlementchecksimulation
	{
		get
		{
			return Instance.entitlementchecksimulation;
		}
		set
		{
			if (Instance.entitlementchecksimulation != value)
			{
				Instance.entitlementchecksimulation = value;
			}
		}
	}

	public static bool StartTimeEntitlementCheck
	{
		get
		{
			return Instance.startTimeEntitlementCheck;
		}
		set
		{
			if (Instance.startTimeEntitlementCheck != value)
			{
				Instance.startTimeEntitlementCheck = value;
			}
		}
	}

	public static Pvr_UnitySDKPlatformSetting Instance
	{
		get
		{
			if (instance == null)
			{
				instance = Resources.Load<Pvr_UnitySDKPlatformSetting>("PlatformSettings");
			}
			return instance;
		}
		set
		{
			instance = value;
		}
	}
}
public class Pvr_UnitySDKManager : MonoBehaviour
{
	public delegate void EntitlementCheckResult(int ReturnValue);

	public static PlatForm platform;

	private static Pvr_UnitySDKManager sdk;

	[HideInInspector]
	public float EyesAspect = 1f;

	[HideInInspector]
	public int posStatus;

	[HideInInspector]
	public bool ismirroring;

	[HideInInspector]
	public Vector3 resetBasePos = default(Vector3);

	[HideInInspector]
	public int trackingmode = -1;

	[HideInInspector]
	public int systemprop = -1;

	[HideInInspector]
	public bool systemFPS;

	[HideInInspector]
	public float[] headData = new float[7];

	[SerializeField]
	private bool rotfoldout;

	[SerializeField]
	private bool hmdOnlyrot;

	[SerializeField]
	private bool controllerOnlyrot;

	[SerializeField]
	private TrackingOrigin trackingOrigin;

	public bool ResetTrackerOnLoad;

	[HideInInspector]
	public Vector3 leftEyeOffset;

	[HideInInspector]
	public Vector3 rightEyeOffset;

	[HideInInspector]
	public Rect leftEyeRect;

	[HideInInspector]
	public Rect rightEyeRect;

	[HideInInspector]
	public Matrix4x4 leftEyeView;

	[HideInInspector]
	public Matrix4x4 rightEyeView;

	[HideInInspector]
	public Pvr_UnitySDKEditor pvr_UnitySDKEditor;

	[SerializeField]
	private bool vrModeEnabled = true;

	[HideInInspector]
	public Material Eyematerial;

	[HideInInspector]
	public Material Middlematerial;

	[HideInInspector]
	public bool newPicovrTriggered;

	[SerializeField]
	private bool showFPS;

	[HideInInspector]
	public Vector3 neckOffset = new Vector3(0f, 0.075f, 0.0805f);

	[SerializeField]
	private bool pVRNeck = true;

	[HideInInspector]
	public bool UseCustomNeckPara;

	[HideInInspector]
	public bool onResume;

	[HideInInspector]
	public bool isEnterVRMode;

	public bool isHasController;

	public Pvr_UnitySDKConfigProfile pvr_UnitySDKConfig;

	private GameObject calltoast;

	private GameObject msgtoast;

	private GameObject lowhmdBatterytoast;

	private GameObject lowphoneBatterytoast;

	private GameObject LowPhoneHealthtoast;

	private GameObject LowcontrollerBatterytoast;

	private bool lowControllerpowerstate;

	private float controllerpowershowtime;

	private bool UseToast = true;

	private int iPhoneHMDModeEnabled;

	private GameObject G3LiteTips;

	[SerializeField]
	private bool monoscopic;

	private bool mIsAndroid7;

	public static Func<bool> eventEnterVRMode;

	[HideInInspector]
	public bool ShowVideoSeethrough;

	public int SystemDebugFFRLevel = -1;

	public int SystemFFRLevel = -1;

	public int AppCheckResult = 100;

	[CompilerGenerated]
	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private static EntitlementCheckResult m_EntitlementCheckResultEvent;

	public Action longPressHomeKeyAction;

	public static Pvr_UnitySDKManager SDK
	{
		get
		{
			if (sdk == null)
			{
				sdk = UnityEngine.Object.FindObjectOfType<Pvr_UnitySDKManager>();
			}
			return sdk;
		}
	}

	public bool Rotfoldout
	{
		get
		{
			return rotfoldout;
		}
		set
		{
			if (value != rotfoldout)
			{
				rotfoldout = value;
			}
		}
	}

	public bool HmdOnlyrot
	{
		get
		{
			return hmdOnlyrot;
		}
		set
		{
			if (value != hmdOnlyrot)
			{
				hmdOnlyrot = value;
			}
		}
	}

	public bool ControllerOnlyrot
	{
		get
		{
			return controllerOnlyrot;
		}
		set
		{
			if (value != controllerOnlyrot)
			{
				controllerOnlyrot = value;
			}
		}
	}

	public TrackingOrigin TrackingOrigin
	{
		get
		{
			return trackingOrigin;
		}
		set
		{
			if (value != trackingOrigin)
			{
				trackingOrigin = value;
				Sensor.UPvr_SetTrackingOriginType(value);
			}
		}
	}

	[HideInInspector]
	public bool VRModeEnabled
	{
		get
		{
			return vrModeEnabled;
		}
		set
		{
			if (value != vrModeEnabled)
			{
				vrModeEnabled = value;
			}
		}
	}

	[HideInInspector]
	public bool picovrTriggered { get; set; }

	public bool ShowFPS
	{
		get
		{
			return showFPS;
		}
		set
		{
			if (value != showFPS)
			{
				showFPS = value;
			}
		}
	}

	public bool PVRNeck
	{
		get
		{
			return pVRNeck;
		}
		set
		{
			if (value != pVRNeck)
			{
				pVRNeck = value;
			}
		}
	}

	[HideInInspector]
	public bool Monoscopic
	{
		get
		{
			return monoscopic;
		}
		set
		{
			if (value != monoscopic)
			{
				monoscopic = value;
				Render.UPvr_SetMonoMode(monoscopic);
			}
		}
	}

	public static event EntitlementCheckResult EntitlementCheckResultEvent
	{
		add
		{
			EntitlementCheckResult entitlementCheckResult = Pvr_UnitySDKManager.m_EntitlementCheckResultEvent;
			EntitlementCheckResult entitlementCheckResult2;
			do
			{
				entitlementCheckResult2 = entitlementCheckResult;
				entitlementCheckResult = Interlocked.CompareExchange(ref Pvr_UnitySDKManager.m_EntitlementCheckResultEvent, (EntitlementCheckResult)Delegate.Combine(entitlementCheckResult2, value), entitlementCheckResult);
			}
			while (entitlementCheckResult != entitlementCheckResult2);
		}
		remove
		{
			EntitlementCheckResult entitlementCheckResult = Pvr_UnitySDKManager.m_EntitlementCheckResultEvent;
			EntitlementCheckResult entitlementCheckResult2;
			do
			{
				entitlementCheckResult2 = entitlementCheckResult;
				entitlementCheckResult = Interlocked.CompareExchange(ref Pvr_UnitySDKManager.m_EntitlementCheckResultEvent, (EntitlementCheckResult)Delegate.Remove(entitlementCheckResult2, value), entitlementCheckResult);
			}
			while (entitlementCheckResult != entitlementCheckResult2);
		}
	}

	public void ChangeDefaultCustomRtSize(int w, int h)
	{
		Pvr_UnitySDKProjectSetting.GetProjectConfig().customRTSize = new Vector2(w, h);
	}

	public Vector3 EyeOffset(Eye eye)
	{
		return (eye != 0) ? rightEyeOffset : leftEyeOffset;
	}

	public Rect EyeRect(Eye eye)
	{
		return (eye != 0) ? rightEyeRect : leftEyeRect;
	}

	private bool SDKManagerInit()
	{
		if (SDKManagerInitConfigProfile())
		{
			mIsAndroid7 = SystemInfo.operatingSystem.Contains("Android OS 7.");
			PLOG.I("Android 7 = " + mIsAndroid7);
			if (SDKManagerInitCoreAbility())
			{
				return true;
			}
			return false;
		}
		return false;
	}

	private bool SDKManagerInitCoreAbility()
	{
		Sensor.UPvr_SetTrackingOriginType(trackingOrigin);
		Render.UPvr_SetMonoMode(monoscopic);
		if (Pvr_UnitySDKRender.Instance == null)
		{
			PLOG.I("pvr_UnitySDKRender init failed");
		}
		if (Pvr_UnitySDKSensor.Instance == null)
		{
			PLOG.I("pvr_UnitySDKSensor init failed");
		}
		Pvr_UnitySDKAPI.System.UPvr_StartHomeKeyReceiver(base.gameObject.name);
		return true;
	}

	public void smsReceivedCallback(string msg)
	{
		PLOG.I("PvrLog MSG" + msg);
		JsonData jsonData = JsonMapper.ToObject(msg);
		string text = string.Empty;
		if (msg.Contains("messageSender"))
		{
			text = (string)jsonData["messageSender"];
		}
		string text2 = string.Empty;
		if (msg.Contains("messageAdr"))
		{
			text2 = (string)jsonData["messageAdr"];
			if (text2.Substring(0, 3) == "+82")
			{
				text2 = "0" + text2.Remove(0, 3);
				text2 = TransformNumber(text2);
			}
			else if (text2.Substring(0, 1) != "+")
			{
				text2 = TransformNumber(text2);
			}
		}
		if (UseToast)
		{
			msgtoast.transform.Find("number").GetComponent<Text>().text = text2;
			msgtoast.transform.Find("name").GetComponent<Text>().text = text;
			if (text.Length == 0)
			{
				msgtoast.transform.Find("number").transform.localPosition = new Vector3(0f, 0f, 0f);
			}
			else
			{
				msgtoast.transform.Find("number").transform.localPosition = new Vector3(60f, 0f, 0f);
			}
			StartCoroutine(ToastManager(2, state: true, 0f));
			StartCoroutine(ToastManager(2, state: false, 5f));
		}
	}

	public void phoneStateCallback(string state)
	{
		PLOG.I("PvrLog phone" + state);
		JsonData jsonData = JsonMapper.ToObject(state);
		string text = string.Empty;
		if (state.Contains("phoneNumber"))
		{
			text = (string)jsonData["phoneNumber"];
			if (text.Substring(0, 3) == "+82")
			{
				text = "0" + text.Remove(0, 3);
				text = TransformNumber(text);
			}
			else if (text.Substring(0, 1) != "+")
			{
				text = TransformNumber(text);
			}
		}
		string text2 = string.Empty;
		if (state.Contains("contactName"))
		{
			text2 = (string)jsonData["contactName"];
		}
		if (UseToast)
		{
			calltoast.transform.Find("number").GetComponent<Text>().text = text;
			calltoast.transform.Find("name").GetComponent<Text>().text = text2;
			if (text2.Length == 0)
			{
				calltoast.transform.Find("number").transform.localPosition = new Vector3(0f, 0f, 0f);
			}
			else
			{
				calltoast.transform.Find("number").transform.localPosition = new Vector3(60f, 0f, 0f);
			}
			StartCoroutine(ToastManager(1, state: true, 0f));
			StartCoroutine(ToastManager(1, state: false, 5f));
		}
	}

	public void phoneBatteryStateCallback(string state)
	{
		PLOG.I("PvrLog phoneBatteryState" + state);
		JsonData jsonData = JsonMapper.ToObject(state);
		string value = string.Empty;
		if (state.Contains("phoneBatteryLevel"))
		{
			value = (string)jsonData["phoneBatteryLevel"];
		}
		string value2 = string.Empty;
		if (state.Contains("phoneBatteryHealth"))
		{
			value2 = (string)jsonData["phoneBatteryHealth"];
		}
		if (!UseToast)
		{
			return;
		}
		if (Convert.ToInt16(value) <= 5)
		{
			if (!lowhmdBatterytoast.activeSelf)
			{
				StartCoroutine(ToastManager(4, state: true, 0f));
				StartCoroutine(ToastManager(4, state: false, 3f));
			}
			else
			{
				StartCoroutine(ToastManager(4, state: true, 5f));
				StartCoroutine(ToastManager(4, state: false, 8f));
			}
		}
		if (Convert.ToInt16(value2) == 3)
		{
			StartCoroutine(ToastManager(5, state: true, 0f));
			StartCoroutine(ToastManager(5, state: false, 5f));
		}
	}

	public void hmdLowBatteryCallback(string level)
	{
		PLOG.I("PvrLog hmdLowBatteryCallback" + level);
		if (UseToast)
		{
			if (!lowphoneBatterytoast.activeSelf)
			{
				StartCoroutine(ToastManager(3, state: true, 0f));
				StartCoroutine(ToastManager(3, state: false, 3f));
			}
			else
			{
				StartCoroutine(ToastManager(3, state: true, 5f));
				StartCoroutine(ToastManager(3, state: false, 8f));
			}
		}
	}

	private string TransformNumber(string number)
	{
		if (number.Length == 11)
		{
			string text = number.Substring(0, 3);
			string text2 = number.Substring(3, 4);
			string text3 = number.Substring(7, 4);
			number = text + "-" + text2 + "-" + text3;
		}
		else if (number.Length == 10)
		{
			if (number.Substring(1, 1) == "1")
			{
				string text4 = number.Substring(0, 3);
				string text5 = number.Substring(3, 3);
				string text6 = number.Substring(6, 4);
				number = text4 + "-" + text5 + "-" + text6;
			}
			else
			{
				string text7 = number.Substring(0, 2);
				string text8 = number.Substring(2, 4);
				string text9 = number.Substring(6, 4);
				number = text7 + "-" + text8 + "-" + text9;
			}
		}
		else if (number.Length == 9)
		{
			if (number.Substring(1, 1) == "2")
			{
				string text10 = number.Substring(0, 2);
				string text11 = number.Substring(2, 3);
				string text12 = number.Substring(5, 4);
				number = text10 + "-" + text11 + "-" + text12;
			}
			else
			{
				number = "+82" + number.Remove(0, 1);
			}
		}
		return number;
	}

	public void onHmdOrientationReseted()
	{
	}

	private IEnumerator ToastManager(int type, bool state, float time)
	{
		yield return new WaitForSeconds(time);
		switch (type)
		{
		case 1:
			calltoast.SetActive(state);
			break;
		case 2:
			msgtoast.SetActive(state);
			break;
		case 3:
			lowhmdBatterytoast.SetActive(state);
			break;
		case 4:
			lowphoneBatterytoast.SetActive(state);
			break;
		case 5:
			LowPhoneHealthtoast.SetActive(state);
			break;
		case 6:
			LowcontrollerBatterytoast.SetActive(state);
			break;
		}
	}

	private void CheckControllerStateForG2(string state)
	{
		if (iPhoneHMDModeEnabled == 1 && Convert.ToBoolean(Convert.ToInt16(state)) && Controller.UPvr_GetControllerPower(0) == 0 && Pvr_ControllerManager.controllerlink.Controller0.Rotation.eulerAngles != Vector3.zero)
		{
			StartCoroutine(ToastManager(6, state: true, 0f));
			StartCoroutine(ToastManager(6, state: false, 3f));
		}
	}

	public void notificationCallback(string data)
	{
		JsonData jsonData = JsonMapper.ToObject(data);
		if (G3LiteTips == null)
		{
			G3LiteTips = UnityEngine.Object.Instantiate(Resources.Load("Prefabs/G3LiteTips") as GameObject, base.transform.Find("Head"), worldPositionStays: false);
		}
		string json = jsonData["str"].ToString();
		JsonData jsonData2 = JsonMapper.ToObject(json);
		switch ((int)jsonData["type"])
		{
		case -1:
			break;
		case 0:
			SetProperty(0, jsonData2, "Sms");
			break;
		case 1:
			SetProperty(1, jsonData2, "Call");
			break;
		case 2:
			SetProperty(2, jsonData2, "Warnning");
			break;
		case 3:
			SetProperty(3, jsonData2, "Warnning");
			break;
		case 4:
			SetProperty(4, jsonData2, "Warnning");
			break;
		case 5:
		{
			Transform transform = G3LiteTips.transform.Find("Onlyimage");
			SetBaseProperty(transform, jsonData2["General"], string.Empty);
			SetImageProperty(transform, jsonData2["General"], string.Empty);
			transform.gameObject.SetActive(value: true);
			StartCoroutine(G3TipsManager(transform.gameObject, (int)jsonData2["General"]["time"]));
			break;
		}
		}
	}

	private Sprite LoadSprite(Vector2 size, string filepath)
	{
		int width = (int)size.x;
		int height = (int)size.y;
		Texture2D texture2D = new Texture2D(width, height);
		texture2D.LoadImage(ReadTex(filepath));
		return Sprite.Create(texture2D, new Rect(0f, 0f, texture2D.width, texture2D.height), new Vector2(0.5f, 0.5f));
	}

	private byte[] ReadTex(string path)
	{
		if (path == string.Empty)
		{
			return new byte[0];
		}
		FileStream fileStream = new FileStream(path, FileMode.Open, FileAccess.Read);
		fileStream.Seek(0L, SeekOrigin.Begin);
		byte[] array = new byte[fileStream.Length];
		fileStream.Read(array, 0, (int)fileStream.Length);
		fileStream.Close();
		fileStream.Dispose();
		fileStream = null;
		return array;
	}

	private void SetProperty(int type, JsonData data, string value)
	{
		Transform trans = G3LiteTips.transform.Find(value);
		SetBaseProperty(trans, data, string.Empty);
		SetImageProperty(trans, data, string.Empty);
		trans.gameObject.SetActive(value: true);
		StartCoroutine(G3TipsManager(trans.gameObject, (int)data["time"]));
		Transform transform = trans.transform.Find("icon");
		SetBaseProperty(transform, data, "icon_");
		SetImageProperty(transform, data, "icon_");
		Transform transform2 = trans.transform.Find("title");
		SetBaseProperty(transform2, data, "title_");
		SetTextProperty(transform2, data, "title_");
		if (type != 1)
		{
			Transform transform3 = trans.transform.Find("details");
			SetBaseProperty(transform3, data, "details_");
			SetTextProperty(transform3, data, "details_");
			Transform transform4 = trans.transform.Find("image1");
			SetBaseProperty(transform4, data, "image1_");
			SetImageProperty(transform4, data, "image1_");
		}
		if (type == 0 || type == 1)
		{
			Transform transform5 = trans.transform.Find("explain");
			SetBaseProperty(transform5, data, "explain_");
			SetTextProperty(transform5, data, "explain_");
			Transform transform6 = trans.transform.Find("source");
			SetBaseProperty(transform6, data, "source_");
			SetTextProperty(transform6, data, "source_");
		}
		if (type == 0)
		{
			Transform transform7 = trans.transform.Find("time");
			SetBaseProperty(transform7, data, "system_time_");
			SetTextProperty(transform7, data, "system_time_");
		}
		Transform transform8 = trans.transform.Find("Button");
		SetBaseProperty(transform8, data, "button_");
		SetImageProperty(transform8, data, "button_");
		transform8.GetComponent<Button>().onClick.AddListener(delegate
		{
			StartCoroutine(G3TipsManager(trans.gameObject, 0f));
		});
		Transform transform9 = transform8.transform.Find("Text");
		SetBaseProperty(transform9, data, "button_text_");
		SetTextProperty(transform9, data, "button_text_");
	}

	private void SetBaseProperty(Transform trans, JsonData data, string value)
	{
		string prop_name = value + "pos";
		string prop_name2 = value + "angles";
		string prop_name3 = value + "size";
		string prop_name4 = value + "scale";
		trans.GetComponent<RectTransform>().anchoredPosition3D = new Vector3(JsonToFloat(data[prop_name][0]), JsonToFloat(data[prop_name][1]), JsonToFloat(data[prop_name][2]));
		trans.GetComponent<RectTransform>().eulerAngles = new Vector3(JsonToFloat(data[prop_name2][0]), JsonToFloat(data[prop_name2][1]), JsonToFloat(data[prop_name2][2]));
		trans.GetComponent<RectTransform>().sizeDelta = new Vector2(JsonToFloat(data[prop_name3][0]), JsonToFloat(data[prop_name3][1]));
		trans.GetComponent<RectTransform>().localScale = new Vector3(JsonToFloat(data[prop_name4][0]), JsonToFloat(data[prop_name4][1]), JsonToFloat(data[prop_name4][2]));
	}

	private void SetImageProperty(Transform image, JsonData data, string value)
	{
		string prop_name = value + "sprite";
		string prop_name2 = value + "color";
		string prop_name3 = value + "size";
		image.GetComponent<Image>().sprite = LoadSprite(new Vector2(JsonToFloat(data[prop_name3][0]), JsonToFloat(data[prop_name3][1])), (string)data[prop_name]);
		image.GetComponent<Image>().color = new Color(JsonToFloat(data[prop_name2][0]), JsonToFloat(data[prop_name2][1]), JsonToFloat(data[prop_name2][2]), JsonToFloat(data[prop_name2][3]));
	}

	private void SetTextProperty(Transform text, JsonData data, string value)
	{
		string prop_name = value + "color";
		string prop_name2 = value + "font_size";
		string prop_name3 = value + "font_style";
		string prop_name4 = value + "text";
		text.GetComponent<Text>().text = (string)data[prop_name4];
		text.GetComponent<Text>().color = new Color(JsonToFloat(data[prop_name][0]), JsonToFloat(data[prop_name][1]), JsonToFloat(data[prop_name][2]), JsonToFloat(data[prop_name][3]));
		text.GetComponent<Text>().fontSize = (int)data[prop_name2];
		text.GetComponent<Text>().fontStyle = (FontStyle)(int)data[prop_name3];
	}

	private IEnumerator G3TipsManager(GameObject tip, float time)
	{
		yield return new WaitForSeconds(time);
		tip.SetActive(value: false);
	}

	private float JsonToFloat(JsonData data)
	{
		return Convert.ToSingle((string)data);
	}

	private bool SDKManagerInitFPS()
	{
		Transform[] componentsInChildren = GetComponentsInChildren<Transform>(includeInactive: true);
		GameObject gameObject = null;
		Transform[] array = componentsInChildren;
		foreach (Transform transform in array)
		{
			if (transform.gameObject.name == "FPS")
			{
				gameObject = transform.gameObject;
			}
		}
		if (gameObject != null)
		{
			if (systemFPS)
			{
				gameObject.SetActive(value: true);
				return true;
			}
			int res = 0;
			int configsenum = 10;
			Render.UPvr_GetIntConfig(configsenum, ref res);
			if (Convert.ToBoolean(res))
			{
				gameObject.SetActive(value: true);
				return true;
			}
			if (ShowFPS)
			{
				gameObject.SetActive(value: true);
				return true;
			}
			return false;
		}
		return false;
	}

	private bool SDKManagerInitConfigProfile()
	{
		pvr_UnitySDKConfig = Pvr_UnitySDKConfigProfile.Default;
		return true;
	}

	private bool SDKManagerInitEditor()
	{
		if (pvr_UnitySDKEditor == null)
		{
			pvr_UnitySDKEditor = base.gameObject.AddComponent<Pvr_UnitySDKEditor>();
		}
		else
		{
			pvr_UnitySDKEditor = null;
			pvr_UnitySDKEditor = base.gameObject.AddComponent<Pvr_UnitySDKEditor>();
		}
		return true;
	}

	private bool SDKManagerInitPara()
	{
		return true;
	}

	public void SDKManagerLongHomeKey()
	{
		if (Pvr_UnitySDKSensor.Instance == null)
		{
			return;
		}
		if (isHasController)
		{
			if (Controller.UPvr_GetControllerState(0) == ControllerState.Connected || Controller.UPvr_GetControllerState(1) == ControllerState.Connected)
			{
				Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(0, 1);
			}
			else
			{
				Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
			}
		}
		else
		{
			Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
		}
	}

	private void setLongHomeKey()
	{
		if (sdk.HmdOnlyrot)
		{
			if (Pvr_UnitySDKSensor.Instance != null)
			{
				PLOG.I((!Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor()) ? "Long Home Key to Reset Sensor Failed!" : "Long Home Key to Reset Sensor Success!");
			}
			return;
		}
		if (trackingmode == 4 || trackingmode == 5 || trackingmode == 6)
		{
			Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
		}
		else
		{
			if (trackingmode == 2 || trackingmode == 3)
			{
				if (isHasController && (Controller.UPvr_GetControllerState(0) == ControllerState.Connected || Controller.UPvr_GetControllerState(1) == ControllerState.Connected))
				{
					Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(0, 1);
				}
				else
				{
					Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
				}
			}
			if (trackingmode == 0 || trackingmode == 1)
			{
				Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
			}
		}
		if (longPressHomeKeyAction != null)
		{
			longPressHomeKeyAction();
		}
	}

	public void verifyAPPCallback(string code)
	{
		Debug.Log("PvrLog verifyAPPCallback" + code);
		AppCheckResult = Convert.ToInt32(code);
		if (Pvr_UnitySDKManager.EntitlementCheckResultEvent != null)
		{
			Pvr_UnitySDKManager.EntitlementCheckResultEvent(AppCheckResult);
		}
	}

	public void IpdRefreshCallBack(string ipd)
	{
		Debug.Log("PvrLog IpdRefreshCallBack");
		Pvr_UnitySDKEye[] eyes = Pvr_UnitySDKEyeManager.Instance.Eyes;
		foreach (Pvr_UnitySDKEye pvr_UnitySDKEye in eyes)
		{
			pvr_UnitySDKEye.RefreshCameraPosition(Convert.ToSingle(ipd));
		}
	}

	private void Awake()
	{
		Debug.Log("DISFT Unity Version:" + Application.unityVersion);
		Debug.Log("DISFT Customize NeckOffset:" + neckOffset);
		Debug.Log("DISFT MSAA :" + Pvr_UnitySDKProjectSetting.GetProjectConfig().rtAntiAlising);
		if (GraphicsSettings.renderPipelineAsset != null)
		{
			Debug.Log("DISFT LWRP = Enable");
		}
		Debug.Log("DISFT Content Proctect :" + Pvr_UnitySDKProjectSetting.GetProjectConfig().usecontentprotect);
		int res = 0;
		int num = 0;
		LoadIsMirroringValue();
		if (!ismirroring)
		{
			num = 18;
			Render.UPvr_GetIntConfig(num, ref res);
			if (res == 1)
			{
				Debug.Log("DISFT ScreenOrientation.Portrait = Enable");
				Screen.orientation = ScreenOrientation.Portrait;
			}
		}
		else
		{
			num = 19;
			Render.UPvr_GetIntConfig(num, ref res);
			Screen.orientation = ((res == 0) ? ScreenOrientation.Portrait : ScreenOrientation.LandscapeLeft);
		}
		AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.psmart.vrlib.VrActivity");
		AndroidJavaClass androidJavaClass2 = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
		AndroidJavaObject @static = androidJavaClass2.GetStatic<AndroidJavaObject>("currentActivity");
		Pvr_ControllerManager pvr_ControllerManager = UnityEngine.Object.FindObjectOfType<Pvr_ControllerManager>();
		isHasController = pvr_ControllerManager != null;
		PLOG.getConfigTraceLevel();
		int configsenum = 5;
		Render.UPvr_GetIntConfig(configsenum, ref trackingmode);
		Application.targetFrameRate = 61;
		int res2 = 0;
		configsenum = 3;
		Render.UPvr_GetIntConfig(configsenum, ref res2);
		if (res2 == 0)
		{
			SDK.HmdOnlyrot = true;
		}
		int res3 = -1;
		int configsenum2 = 9;
		Render.UPvr_GetIntConfig(configsenum2, ref res3);
		float res4 = 0f;
		int configsenum3 = 6;
		Render.UPvr_GetFloatConfig(configsenum3, ref res4);
		Application.targetFrameRate = ((res3 <= 0) ? ((int)res4) : res3);
		if (!Pvr_UnitySDKProjectSetting.GetProjectConfig().usedefaultfps)
		{
			if ((float)Pvr_UnitySDKProjectSetting.GetProjectConfig().customfps <= res4)
			{
				Application.targetFrameRate = Pvr_UnitySDKProjectSetting.GetProjectConfig().customfps;
			}
			else
			{
				Application.targetFrameRate = (int)res4;
			}
		}
		Debug.Log("DISFT Customize FPS :" + Application.targetFrameRate);
		if (!UseCustomNeckPara)
		{
			float res5 = 0f;
			float res6 = 0f;
			float res7 = 0f;
			int configsenum4 = 3;
			int configsenum5 = 4;
			int configsenum6 = 5;
			Render.UPvr_GetFloatConfig(configsenum4, ref res5);
			Render.UPvr_GetFloatConfig(configsenum5, ref res6);
			Render.UPvr_GetFloatConfig(configsenum6, ref res7);
			if (res5 != 0f || res6 != 0f || res7 != 0f)
			{
				neckOffset = new Vector3(res5, res6, res7);
			}
		}
		Render.UPvr_GetIntConfig(16, ref iPhoneHMDModeEnabled);
		Pvr_ControllerManager.ControllerStatusChangeEvent += CheckControllerStateForG2;
		InitUI();
		RefreshTextByLanguage();
	}

	private IEnumerator Start()
	{
		if (SDKManagerInit())
		{
			PLOG.I("SDK Init success.");
		}
		else
		{
			PLOG.E("SDK Init Failed.");
			Application.Quit();
		}
		if (Pvr_UnitySDKRender.Instance != null)
		{
			Pvr_UnitySDKRender.Instance.ReInit();
		}
		SDKManagerInitFPS();
		if (Pvr_UnitySDKPlatformSetting.StartTimeEntitlementCheck)
		{
			if (PlatformSettings.UPvr_IsCurrentDeviceValid() != Pvr_UnitySDKPlatformSetting.simulationType.Valid)
			{
				Debug.Log("DISFT Entitlement Check Simulation DO NOT PASS");
				string appID = Pvr_UnitySDKPlatformSetting.Instance.appID;
				Debug.Log("DISFT Start-time Entitlement Check Enable");
				PLOG.I("DISFT Start-time Entitlement Check APPID :" + appID);
				PlatformSettings.UPvr_AppEntitlementCheckExtra(appID);
			}
			else
			{
				Debug.Log("DISFT Entitlement Check Simulation PASS");
			}
		}
		yield return StartCoroutine(InitRenderThreadRoutine());
	}

	private IEnumerator InitRenderThreadRoutine()
	{
		PLOG.I("InitRenderThreadRoutine begin");
		for (int i = 0; i < 2; i++)
		{
			yield return null;
		}
		Debug.Log("InitRenderThreadRoutine after a wait");
		if (Pvr_UnitySDKRender.Instance != null)
		{
			Pvr_UnitySDKRender.Instance.IssueRenderThread();
		}
		else
		{
			Debug.Log("InitRenderThreadRoutine pvr_UnitySDKRender == null");
		}
		Debug.Log("InitRenderThreadRoutine end");
	}

	private void Update()
	{
		if (isHasController && iPhoneHMDModeEnabled == 1 && Controller.UPvr_GetControllerPower(0) == 0 && Pvr_ControllerManager.controllerlink.controller0Connected && Pvr_ControllerManager.controllerlink.Controller0.Rotation.eulerAngles != Vector3.zero)
		{
			if (!lowControllerpowerstate)
			{
				StartCoroutine(ToastManager(6, state: true, 0f));
				StartCoroutine(ToastManager(6, state: false, 3f));
				lowControllerpowerstate = true;
			}
			controllerpowershowtime += Time.deltaTime;
			if (controllerpowershowtime >= 3600f)
			{
				lowControllerpowerstate = false;
				controllerpowershowtime = 0f;
			}
		}
		if (Input.touchCount == 1 && Input.touches[0].phase == TouchPhase.Began)
		{
			newPicovrTriggered = true;
		}
		if (Input.GetKeyDown(KeyCode.JoystickButton0))
		{
			newPicovrTriggered = true;
		}
		if (Pvr_UnitySDKSensor.Instance != null)
		{
			Pvr_UnitySDKSensor.Instance.SensorUpdate();
		}
		picovrTriggered = newPicovrTriggered;
		newPicovrTriggered = false;
	}

	private void OnDestroy()
	{
		if (sdk == this)
		{
			sdk = null;
		}
		RenderTexture.active = null;
		Resources.UnloadUnusedAssets();
		GC.Collect();
		Pvr_ControllerManager.ControllerStatusChangeEvent -= CheckControllerStateForG2;
	}

	private void OnEnable()
	{
		if (sdk == null)
		{
			sdk = this;
		}
		else if (sdk != this)
		{
			sdk = this;
		}
	}

	private void OnDisable()
	{
		StopAllCoroutines();
	}

	private void OnPause()
	{
		Pvr_UnitySDKAPI.System.UPvr_StopHomeKeyReceiver();
		LeaveVRMode();
		if (Pvr_UnitySDKSensor.Instance != null)
		{
			Pvr_UnitySDKSensor.Instance.StopUnitySDKSensor();
		}
	}

	private void OnApplicationPause(bool pause)
	{
		bool flag = pause;
		Debug.Log("OnApplicationPause-------------------------" + ((!flag) ? "false" : "true"));
		if (Pvr_UnitySDKAPI.System.UPvr_IsPicoActivity() && !Pvr_UnitySDKRender.Instance.isShellMode)
		{
			bool flag2 = Pvr_UnitySDKAPI.System.UPvr_GetMainActivityPauseStatus();
			Debug.Log("OnApplicationPause-------------------------Activity Pause State:" + flag2);
			pause = flag2;
		}
		if (flag == pause)
		{
			if (pause)
			{
				onResume = false;
				OnPause();
			}
			else
			{
				onResume = true;
				GL.InvalidateState();
				StartCoroutine(OnResume());
			}
		}
		else if (pause)
		{
			Debug.Log("OnApplicationPause-------------------------Activity pause Unity resume");
			GL.InvalidateState();
			StartCoroutine(OnResume());
			onResume = false;
			OnPause();
		}
		else
		{
			Debug.Log("OnApplicationPause-------------------------Activity resume Unity pause");
			OnPause();
			onResume = true;
			GL.InvalidateState();
			StartCoroutine(OnResume());
		}
	}

	public void EnterVRMode()
	{
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.Resume);
		isEnterVRMode = true;
		if (eventEnterVRMode != null)
		{
			eventEnterVRMode();
		}
	}

	public void LeaveVRMode()
	{
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.Pause);
		isEnterVRMode = false;
	}

	public void SixDofForceQuit()
	{
		Application.Quit();
	}

	private void InitUI()
	{
		if (iPhoneHMDModeEnabled == 1)
		{
			Transform transform = UnityEngine.Object.Instantiate(Resources.Load("Prefabs/flamingo2Tips") as GameObject, base.transform.Find("Head"), worldPositionStays: false).transform;
			calltoast = transform.Find("Call").gameObject;
			msgtoast = transform.Find("Msg").gameObject;
			lowhmdBatterytoast = transform.Find("LowHmdBattery").gameObject;
			lowphoneBatterytoast = transform.Find("LowPhoneBattery").gameObject;
			LowPhoneHealthtoast = transform.Find("LowPhoneHealth").gameObject;
			LowcontrollerBatterytoast = transform.Find("LowControllerBattery").gameObject;
		}
	}

	private void RefreshTextByLanguage()
	{
		if (msgtoast != null)
		{
			msgtoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("msgtoast0");
			msgtoast.transform.Find("string").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("msgtoast1");
			calltoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("calltoast0");
			calltoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("calltoast1");
			lowhmdBatterytoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("lowhmdBatterytoast");
			lowphoneBatterytoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("lowphoneBatterytoast");
			LowPhoneHealthtoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("LowPhoneHealthtoast");
			LowcontrollerBatterytoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("LowcontrollerBatterytoast");
		}
	}

	private void LoadIsMirroringValue()
	{
		AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
		AndroidJavaObject @static = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
		AndroidJavaObject androidJavaObject = @static.Call<AndroidJavaObject>("getPackageManager", new object[0]);
		string text = @static.Call<string>("getPackageName", new object[0]);
		AndroidJavaObject androidJavaObject2 = androidJavaObject.Call<AndroidJavaObject>("getApplicationInfo", new object[2] { text, 128 });
		AndroidJavaObject androidJavaObject3 = androidJavaObject2.Get<AndroidJavaObject>("metaData");
		ismirroring = Convert.ToBoolean(androidJavaObject3.Call<int>("getInt", new object[2] { "bypass_presentation", 0 }));
	}

	private IEnumerator OnResume()
	{
		int ability6dof = 0;
		int enumindex = 3;
		Render.UPvr_GetIntConfig(enumindex, ref ability6dof);
		RefreshTextByLanguage();
		if (Pvr_UnitySDKSensor.Instance != null)
		{
			Pvr_UnitySDKSensor.Instance.StartUnitySDKSensor();
			int res = -1;
			int configsenum = 8;
			Render.UPvr_GetIntConfig(configsenum, ref res);
			if (res != 1)
			{
				int res2 = -1;
				int configsenum2 = 11;
				Render.UPvr_GetIntConfig(configsenum2, ref res2);
				if (res2 != 8)
				{
					Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
				}
			}
		}
		if (Pvr_UnitySDKAPI.System.UPvr_IsPicoActivity())
		{
			PLOG.I("onresume set monoPresentation success ?-------------" + Pvr_UnitySDKAPI.System.UPvr_SetMonoPresentation());
			PLOG.I("onresume presentation existed ?-------------" + Pvr_UnitySDKAPI.System.UPvr_IsPresentationExisted());
		}
		for (int j = 0; j < Pvr_UnitySDKEyeManager.Instance.Eyes.Length; j++)
		{
			Pvr_UnitySDKEyeManager.Instance.Eyes[j].RefreshCameraPosition(Pvr_UnitySDKAPI.System.UPvr_GetIPD());
		}
		int waitNum = 15;
		Render.UPvr_GetIntConfig(20, ref waitNum);
		int resetNum = 10;
		Render.UPvr_GetIntConfig(21, ref resetNum);
		for (int i = 0; i < waitNum; i++)
		{
			if (i == resetNum && ResetTrackerOnLoad && ability6dof == 1)
			{
				Debug.Log("Reset Tracker OnLoad");
				Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
			}
			yield return null;
		}
		EnterVRMode();
		Pvr_UnitySDKAPI.System.UPvr_StartHomeKeyReceiver(base.gameObject.name);
		Pvr_UnitySDKEye.setLevel = false;
		if (longPressHomeKeyAction != null)
		{
			longPressHomeKeyAction();
		}
		if (Render.UPvr_GetIntSysProc("pvrsist.foveation.level", ref SystemDebugFFRLevel))
		{
			Render.SetFoveatedRenderingLevel((EFoveationLevel)SystemDebugFFRLevel);
			Debug.Log("DISFT OnResume Get System Debug ffr level is : " + SystemDebugFFRLevel);
		}
		else
		{
			Debug.Log("DISFT OnResume Get System Debug ffr level Error,ffr level is : " + SystemDebugFFRLevel);
		}
		if (SystemDebugFFRLevel == -1)
		{
			Render.UPvr_GetIntConfig(22, ref SystemFFRLevel);
			if (SystemFFRLevel != -1)
			{
				Render.SetFoveatedRenderingLevel((EFoveationLevel)SystemFFRLevel);
				Debug.Log("DISFT OnResume Get System ffr level is : " + SystemFFRLevel);
			}
		}
	}
}
public class QuitGame : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Escape))
		{
			Application.Quit();
		}
	}
}
public class Pvr_UnityEyeMask : MonoBehaviour
{
	private class EyeMaskData
	{
		public Eye eyeSide;

		public Camera camera;

		public CommandBuffer cmdBuf;
	}

	private Shader eyeMaskShader;

	private Material eyeMaskMaterial;

	private Mesh eyeMaskMeshLeft;

	private Mesh eyeMaskMeshRight;

	private Mesh eyeMaskMeshBoth;

	private float zDir = -1f;

	private Color eyeMaskColor = Color.black;

	private List<EyeMaskData> cameraDataList = new List<EyeMaskData>();

	private void Awake()
	{
		Debug.Log("DISFT EyeMask = Enable");
		if (SystemInfo.graphicsDeviceType == GraphicsDeviceType.OpenGLES3 || SystemInfo.graphicsDeviceType == GraphicsDeviceType.OpenGLES2)
		{
			zDir = -1f;
		}
		else if (SystemInfo.usesReversedZBuffer)
		{
			zDir = 1f;
		}
		else
		{
			zDir = 0f;
		}
	}

	private void OnEnable()
	{
		if (eyeMaskShader == null)
		{
			eyeMaskShader = Shader.Find("Pvr_UnitySDK/Pvr_EyeMask");
		}
		if (eyeMaskMaterial == null && eyeMaskShader != null)
		{
			eyeMaskMaterial = new Material(eyeMaskShader);
			eyeMaskMaterial.SetColor("_Color", eyeMaskColor);
		}
		if (eyeMaskMaterial == null)
		{
			base.enabled = false;
			Debug.LogWarning("EyeMask materil is null or EyeMask shader not found!");
		}
		else
		{
			PrepareCameras();
			Camera.onPreRender = (Camera.CameraCallback)Delegate.Combine(Camera.onPreRender, new Camera.CameraCallback(OnCustomPreRender));
			CreateCommandBuffer();
		}
	}

	private void OnDisable()
	{
		Camera.onPreRender = (Camera.CameraCallback)Delegate.Remove(Camera.onPreRender, new Camera.CameraCallback(OnCustomPreRender));
		foreach (EyeMaskData cameraData in cameraDataList)
		{
			if (cameraData.camera != null && cameraData.cmdBuf != null)
			{
				RemoveCameraCommandBuffer(cameraData);
			}
		}
		CleanEyeMask();
	}

	private void CreateCommandBuffer()
	{
		if (VerifyCommadBuffer())
		{
			return;
		}
		if (eyeMaskMeshLeft == null || eyeMaskMeshRight == null)
		{
			eyeMaskMeshLeft = GetStencilMesh(Eye.LeftEye);
			eyeMaskMeshRight = GetStencilMesh(Eye.RightEye);
			if (eyeMaskMeshLeft == null || eyeMaskMeshRight == null)
			{
				Debug.LogWarning("Stencil Mesh is not exist, disable EyeMask.");
				base.enabled = false;
				return;
			}
		}
		foreach (EyeMaskData cameraData in cameraDataList)
		{
			if (cameraData.eyeSide == Eye.LeftEye)
			{
				CommandBuffer commandBuffer = new CommandBuffer();
				commandBuffer.name = "EyeMaskLeft";
				commandBuffer.DrawMesh(eyeMaskMeshLeft, Matrix4x4.identity, eyeMaskMaterial, 0, 0);
				cameraData.cmdBuf = commandBuffer;
			}
			else if (cameraData.eyeSide == Eye.RightEye)
			{
				CommandBuffer commandBuffer2 = new CommandBuffer();
				commandBuffer2.name = "EyeMaskRight";
				commandBuffer2.DrawMesh(eyeMaskMeshRight, Matrix4x4.identity, eyeMaskMaterial, 0, 0);
				cameraData.cmdBuf = commandBuffer2;
			}
			else if (cameraData.eyeSide == Eye.BothEye)
			{
				if (eyeMaskMeshBoth == null)
				{
					eyeMaskMeshBoth = GetStencilMeshBoth(eyeMaskMeshLeft, eyeMaskMeshRight);
					float value = Mathf.Max(Mathf.Abs(eyeMaskMeshLeft.bounds.max.x), Mathf.Abs(eyeMaskMeshRight.bounds.min.x));
					eyeMaskMaterial.SetFloat("_MeshOffsetX", value);
				}
				CommandBuffer commandBuffer3 = new CommandBuffer();
				commandBuffer3.name = "EyeMaskBoth";
				commandBuffer3.DrawMesh(eyeMaskMeshBoth, Matrix4x4.identity, eyeMaskMaterial, 0, 1);
				cameraData.cmdBuf = commandBuffer3;
			}
		}
	}

	private void OnCustomPreRender(Camera cam)
	{
		if (!VerifyCommadBuffer())
		{
			Debug.LogWarning("Verify CommandBuffer failed!");
			return;
		}
		foreach (EyeMaskData cameraData in cameraDataList)
		{
			if (!(cameraData.camera != cam))
			{
				RemoveCameraCommandBuffer(cameraData);
				AddCameraCommandBuffer(cameraData);
			}
		}
	}

	private Mesh GetStencilMesh(Eye eyeSide)
	{
		int vertexCount = 0;
		int triangleCount = 0;
		IntPtr vertexDataPtr = IntPtr.Zero;
		IntPtr indexDataPtr = IntPtr.Zero;
		Render.UPvr_GetStencilMesh((int)eyeSide, ref vertexCount, ref triangleCount, ref vertexDataPtr, ref indexDataPtr);
		if (vertexCount <= 0 || triangleCount <= 0 || vertexDataPtr == IntPtr.Zero || indexDataPtr == IntPtr.Zero)
		{
			return null;
		}
		Vector3[] array = new Vector3[vertexCount];
		int[] array2 = new int[triangleCount * 3];
		float[] array3 = new float[vertexCount * 3];
		int[] array4 = new int[triangleCount * 3];
		Marshal.Copy(vertexDataPtr, array3, 0, vertexCount * 3);
		Marshal.Copy(indexDataPtr, array4, 0, triangleCount * 3);
		for (int i = 0; i < vertexCount; i++)
		{
			ref Vector3 reference = ref array[i];
			reference = new Vector3(array3[3 * i], array3[3 * i + 1], zDir);
		}
		for (int j = 0; j < triangleCount; j++)
		{
			array2[3 * j] = array4[3 * j + 2];
			array2[3 * j + 1] = array4[3 * j + 1];
			array2[3 * j + 2] = array4[3 * j];
		}
		Mesh mesh = new Mesh();
		mesh.name = "EyeMaskMesh";
		mesh.vertices = array;
		mesh.SetIndices(array2, MeshTopology.Triangles, 0);
		return mesh;
	}

	private Mesh GetStencilMeshBoth(Mesh leftMesh, Mesh rightMesh)
	{
		float num = Mathf.Max(Mathf.Abs(leftMesh.bounds.max.x), Mathf.Abs(rightMesh.bounds.min.x));
		Mesh mesh = new Mesh();
		mesh.name = "EyeMaskBoth";
		CombineInstance combineInstance = default(CombineInstance);
		combineInstance.mesh = leftMesh;
		Matrix4x4 identity = Matrix4x4.identity;
		identity.SetTRS(Vector3.left * num, Quaternion.identity, Vector3.one);
		combineInstance.transform = identity;
		CombineInstance combineInstance2 = default(CombineInstance);
		combineInstance2.mesh = rightMesh;
		Matrix4x4 identity2 = Matrix4x4.identity;
		identity2.SetTRS(Vector3.right * num, Quaternion.identity, Vector3.one);
		combineInstance2.transform = identity2;
		CombineInstance[] combine = new CombineInstance[2] { combineInstance, combineInstance2 };
		mesh.CombineMeshes(combine);
		return mesh;
	}

	private bool VerifyCommadBuffer()
	{
		if (cameraDataList == null || cameraDataList.Count <= 0)
		{
			return false;
		}
		foreach (EyeMaskData cameraData in cameraDataList)
		{
			if (cameraData == null || cameraData.cmdBuf == null)
			{
				return false;
			}
		}
		return true;
	}

	private void PrepareCameras()
	{
		cameraDataList.Clear();
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			if (Pvr_UnitySDKEyeManager.Instance.BothEyeCamera == null)
			{
				Debug.LogWarning("BothEye Camera is null!");
				return;
			}
			EyeMaskData eyeMaskData = new EyeMaskData();
			eyeMaskData.eyeSide = Eye.BothEye;
			eyeMaskData.camera = Pvr_UnitySDKEyeManager.Instance.BothEyeCamera;
			cameraDataList.Add(eyeMaskData);
		}
		else if (Pvr_UnitySDKEyeManager.Instance.LeftEyeCamera == null || Pvr_UnitySDKEyeManager.Instance.RightEyeCamera == null)
		{
			Debug.LogWarning("LeftEye or RightEye Camera is null!");
		}
		else
		{
			EyeMaskData eyeMaskData2 = new EyeMaskData();
			eyeMaskData2.eyeSide = Eye.LeftEye;
			eyeMaskData2.camera = Pvr_UnitySDKEyeManager.Instance.LeftEyeCamera;
			eyeMaskData2.cmdBuf = null;
			cameraDataList.Add(eyeMaskData2);
			EyeMaskData eyeMaskData3 = new EyeMaskData();
			eyeMaskData3.eyeSide = Eye.RightEye;
			eyeMaskData3.camera = Pvr_UnitySDKEyeManager.Instance.RightEyeCamera;
			eyeMaskData3.cmdBuf = null;
			cameraDataList.Add(eyeMaskData3);
		}
	}

	private void AddCameraCommandBuffer(EyeMaskData data)
	{
		data.camera.AddCommandBuffer(CameraEvent.BeforeForwardOpaque, data.cmdBuf);
	}

	private void RemoveCameraCommandBuffer(EyeMaskData data)
	{
		data.camera.RemoveCommandBuffer(CameraEvent.BeforeForwardOpaque, data.cmdBuf);
	}

	private void CleanEyeMask()
	{
		cameraDataList.Clear();
		eyeMaskMeshLeft = null;
		eyeMaskMeshRight = null;
		eyeMaskMeshBoth = null;
		eyeMaskShader = null;
		eyeMaskMaterial = null;
	}
}
[RequireComponent(typeof(Camera))]
public class Pvr_UnitySDKEye : MonoBehaviour
{
	public static List<Pvr_UnitySDKEye> Instances = new List<Pvr_UnitySDKEye>();

	public Eye eyeSide;

	private int eyeCameraOriginCullingMask;

	private CameraClearFlags eyeCameraOriginClearFlag;

	private Color eyeCameraOriginBackgroundColor;

	private int lastBoundaryState;

	private Matrix4x4 realProj = Matrix4x4.identity;

	private const int bufferSize = 3;

	private int IDIndex;

	private RenderEventType eventType;

	private int previousId;

	public static bool setLevel = false;

	private Material mat_Vignette;

	public Camera eyecamera { get; private set; }

	private void Awake()
	{
		Instances.Add(this);
		eyecamera = GetComponent<Camera>();
	}

	private void Start()
	{
		Setup(eyeSide);
		SetupUpdate();
		if (eyecamera != null)
		{
			eyeCameraOriginCullingMask = eyecamera.cullingMask;
			eyeCameraOriginClearFlag = eyecamera.clearFlags;
			eyeCameraOriginBackgroundColor = eyecamera.backgroundColor;
		}
	}

	private void Update()
	{
		if (!(eyecamera != null) || !eyecamera.enabled)
		{
			return;
		}
		int num = BoundarySystem.UPvr_GetSeeThroughState();
		if (num == lastBoundaryState)
		{
			return;
		}
		switch (num)
		{
		case 2:
			eyeCameraOriginCullingMask = eyecamera.cullingMask;
			eyeCameraOriginClearFlag = eyecamera.clearFlags;
			eyeCameraOriginBackgroundColor = eyecamera.backgroundColor;
			eyecamera.cullingMask = 0;
			eyecamera.clearFlags = CameraClearFlags.Color;
			eyecamera.backgroundColor = Color.black;
			break;
		case 1:
			if (lastBoundaryState == 2)
			{
				if (eyecamera.cullingMask == 0)
				{
					eyecamera.cullingMask = eyeCameraOriginCullingMask;
				}
				if (eyecamera.clearFlags == CameraClearFlags.Color)
				{
					eyecamera.clearFlags = eyeCameraOriginClearFlag;
				}
				if (eyecamera.backgroundColor == Color.black)
				{
					eyecamera.backgroundColor = eyeCameraOriginBackgroundColor;
				}
			}
			break;
		default:
			if (lastBoundaryState == 2 || lastBoundaryState == 1)
			{
				if (eyecamera.cullingMask == 0)
				{
					eyecamera.cullingMask = eyeCameraOriginCullingMask;
				}
				if (eyecamera.clearFlags == CameraClearFlags.Color)
				{
					eyecamera.clearFlags = eyeCameraOriginClearFlag;
				}
				if (eyecamera.backgroundColor == Color.black)
				{
					eyecamera.backgroundColor = eyeCameraOriginBackgroundColor;
				}
			}
			break;
		}
		lastBoundaryState = num;
	}

	private void OnEnable()
	{
	}

	private void OnDisable()
	{
	}

	private void OnDestroy()
	{
		Instances.Remove(this);
	}

	public void MyPreRender(Camera camera)
	{
		if (!(camera.gameObject != base.gameObject))
		{
			OnPreRender();
		}
	}

	public void MyPreRender(ScriptableRenderContext context, Camera camera)
	{
		if (!(camera.gameObject != base.gameObject))
		{
			OnPreRender();
		}
	}

	public void MyPostRender(ScriptableRenderContext context, Camera camera)
	{
		if (!(camera.gameObject != base.gameObject))
		{
			OnPostRender();
		}
	}

	private void OnPreRender()
	{
		if (!eyecamera.enabled)
		{
			return;
		}
		if (Pvr_UnitySDKRender.Instance.StereoRendering != null)
		{
			if (Pvr_UnitySDKRender.Instance.isSwitchSDK)
			{
				return;
			}
			Pvr_UnitySDKRender.Instance.StereoRendering.OnSDKPreRender();
		}
		SetFFRParameter();
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.BeginEye);
	}

	private void OnPostRender()
	{
		if (!eyecamera.enabled)
		{
			return;
		}
		Pvr_UnitySDKAPI.System.UPvr_UnityEventData(Pvr_UnitySDKAPI.System.UPvr_GetEyeBufferData(Pvr_UnitySDKRender.Instance.eyeTextureIds[IDIndex]));
		Pvr_UnitySDKPluginEvent.Issue(eventType);
		if (Pvr_UnitySDKRender.Instance.StereoRendering != null)
		{
			if (Pvr_UnitySDKRender.Instance.isSwitchSDK)
			{
				return;
			}
			Pvr_UnitySDKRender.Instance.StereoRendering.OnSDKPostRender();
		}
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.EndEye);
	}

	public void EyeRender()
	{
		SetupUpdate();
		if (Pvr_UnitySDKRender.Instance.eyeTextures[IDIndex] != null)
		{
			Pvr_UnitySDKRender.Instance.eyeTextures[IDIndex].DiscardContents();
			eyecamera.targetTexture = Pvr_UnitySDKRender.Instance.eyeTextures[IDIndex];
		}
	}

	private void Setup(Eye eyeSide)
	{
		eyecamera = GetComponent<Camera>();
		switch (eyeSide)
		{
		case Eye.LeftEye:
		case Eye.RightEye:
			base.transform.localPosition = Pvr_UnitySDKManager.SDK.EyeOffset(eyeSide);
			break;
		case Eye.BothEye:
			base.transform.localPosition = Vector3.zero;
			break;
		}
		eyecamera.aspect = Pvr_UnitySDKManager.SDK.EyesAspect;
		eyecamera.rect = new Rect(0f, 0f, 1f, 1f);
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.MultiPass)
		{
			eventType = ((eyeSide != 0) ? RenderEventType.RightEyeEndFrame : RenderEventType.LeftEyeEndFrame);
		}
		else
		{
			eventType = RenderEventType.BothEyeEndFrame;
		}
	}

	private void SetupUpdate()
	{
		if (eyeSide == Eye.LeftEye || eyeSide == Eye.RightEye)
		{
			eyecamera.enabled = !Pvr_UnitySDKManager.SDK.Monoscopic && Pvr_UnitySDKRender.Instance.StereoRenderPath != StereoRenderingPathPico.SinglePass;
		}
		else if (eyeSide == Eye.BothEye)
		{
			eyecamera.enabled = Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass;
		}
		eyecamera.fieldOfView = Pvr_UnitySDKRender.Instance.EyeVFoV;
		eyecamera.aspect = Pvr_UnitySDKManager.SDK.EyesAspect;
		if (eyeSide == Eye.LeftEye || eyeSide == Eye.RightEye)
		{
			IDIndex = Pvr_UnitySDKRender.Instance.currEyeTextureIdx + (int)eyeSide * 3;
		}
		else if (eyeSide == Eye.BothEye)
		{
			IDIndex = Pvr_UnitySDKRender.Instance.currEyeTextureIdx;
			Pvr_UnitySDKRender.Instance.isSwitchSDK = Pvr_UnitySDKRender.Instance.lastEyeTextureIdx == Pvr_UnitySDKRender.Instance.currEyeTextureIdx;
			Pvr_UnitySDKRender.Instance.lastEyeTextureIdx = Pvr_UnitySDKRender.Instance.currEyeTextureIdx;
		}
	}

	public void RefreshCameraPosition(float ipd)
	{
		Pvr_UnitySDKManager.SDK.leftEyeOffset = new Vector3((0f - ipd) / 2f, 0f, 0f);
		Pvr_UnitySDKManager.SDK.rightEyeOffset = new Vector3(ipd / 2f, 0f, 0f);
		if (eyeSide == Eye.LeftEye || eyeSide == Eye.RightEye)
		{
			base.transform.localPosition = Pvr_UnitySDKManager.SDK.EyeOffset(eyeSide);
		}
		else if (eyeSide == Eye.BothEye)
		{
			eyecamera.stereoSeparation = ipd;
		}
	}

	private void DrawVignetteLine()
	{
		if (null == mat_Vignette)
		{
			mat_Vignette = new Material(Shader.Find("Diffuse"));
			if (null == mat_Vignette)
			{
				return;
			}
		}
		GL.PushMatrix();
		mat_Vignette.SetPass(0);
		GL.LoadOrtho();
		vignette();
		GL.PopMatrix();
	}

	private void vignette()
	{
		GL.Begin(7);
		GL.Color(Color.black);
		GL.Vertex3(0f, 1f, 0f);
		GL.Vertex3(1f, 1f, 0f);
		GL.Vertex3(1f, 0.995f, 0f);
		GL.Vertex3(0f, 0.995f, 0f);
		GL.Vertex3(0f, 0f, 0f);
		GL.Vertex3(0f, 0.005f, 0f);
		GL.Vertex3(1f, 0.005f, 0f);
		GL.Vertex3(1f, 0f, 0f);
		GL.Vertex(new Vector3(0f, 1f, 0f));
		GL.Vertex(new Vector3(0.005f, 1f, 0f));
		GL.Vertex(new Vector3(0.005f, 0f, 0f));
		GL.Vertex(new Vector3(0f, 0f, 0f));
		GL.Vertex(new Vector3(0.995f, 1f, 0f));
		GL.Vertex(new Vector3(1f, 1f, 0f));
		GL.Vertex(new Vector3(1f, 0f, 0f));
		GL.Vertex(new Vector3(0.995f, 0f, 0f));
		GL.End();
	}

	private void SetFFRParameter()
	{
		Vector3 vector = Vector3.zero;
		if (Pvr_UnitySDKManager.SDK.isEnterVRMode && Pvr_UnitySDKEyeManager.supportEyeTracking && Pvr_UnitySDKEyeManager.Instance.EyeTracking)
		{
			vector = Pvr_UnitySDKAPI.System.UPvr_getEyeTrackingPos();
		}
		int textureId = Pvr_UnitySDKRender.Instance.eyeTextureIds[IDIndex];
		Render.UPvr_SetFoveationResource(textureId, previousId, vector.x, vector.y);
		previousId = textureId;
	}
}
public class Pvr_UnitySDKEyeManager : MonoBehaviour
{
	private static Pvr_UnitySDKEyeManager instance;

	private Pvr_UnitySDKEye[] eyes;

	[HideInInspector]
	public Camera LeftEyeCamera;

	[HideInInspector]
	public Camera RightEyeCamera;

	[HideInInspector]
	public Camera MonoEyeCamera;

	[HideInInspector]
	public Camera BothEyeCamera;

	private int MonoEyeTextureID;

	private readonly int WaitSplashScreenFrames = 3;

	private int frameNum;

	[SerializeField]
	[HideInInspector]
	private bool foveatedRendering;

	[SerializeField]
	[HideInInspector]
	private EFoveationLevel foveationLevel;

	private int eyeTextureId;

	private RenderEventType eventType = RenderEventType.LeftEyeEndFrame;

	private Pvr_UnitySDKEyeOverlay compositeLayer;

	private int overlayLayerDepth = 1;

	private int underlayLayerDepth;

	private bool isHeadLocked;

	private int layerFlags;

	[HideInInspector]
	public bool EyeTracking;

	[HideInInspector]
	public Vector3 eyePoint;

	private EyeTrackingData eyePoseData;

	[HideInInspector]
	public static bool supportEyeTracking;

	[Tooltip("If true, specific color gradient when switching scenes.")]
	public bool screenFade;

	[Tooltip("Define the duration of screen fade.")]
	public float fadeTime = 5f;

	[Tooltip("Define the color of screen fade.")]
	public Color fadeColor = new Color(0f, 0f, 0f, 1f);

	public int renderQueue = 5000;

	private MeshRenderer fadeMeshRenderer;

	private MeshFilter fadeMeshFilter;

	private Material fadeMaterial;

	private float elapsedTime;

	private bool isFading;

	private float currentAlpha;

	private float nowFadeAlpha;

	public static Pvr_UnitySDKEyeManager Instance
	{
		get
		{
			if (instance == null)
			{
				PLOG.E("Pvr_UnitySDKEyeManager instance is not init yet...");
			}
			return instance;
		}
	}

	public Pvr_UnitySDKEye[] Eyes
	{
		get
		{
			if (eyes == null)
			{
				eyes = Pvr_UnitySDKEye.Instances.ToArray();
			}
			return eyes;
		}
	}

	[HideInInspector]
	public bool FoveatedRendering
	{
		get
		{
			return foveatedRendering;
		}
		set
		{
			if (value == foveatedRendering)
			{
				return;
			}
			foveatedRendering = value;
			if (Application.isPlaying)
			{
				Render.UPvr_EnableFoveation(enable: true);
				if (!foveatedRendering)
				{
					Render.SetFoveatedRenderingLevel((EFoveationLevel)(-1));
				}
			}
		}
	}

	[HideInInspector]
	public EFoveationLevel FoveationLevel
	{
		get
		{
			return foveationLevel;
		}
		set
		{
			if (value != foveationLevel)
			{
				foveationLevel = value;
			}
		}
	}

	private void SetCameraEnableEditor()
	{
		MonoEyeCamera.enabled = !Pvr_UnitySDKManager.SDK.VRModeEnabled || Pvr_UnitySDKManager.SDK.Monoscopic;
		for (int i = 0; i < Eyes.Length; i++)
		{
			if (Eyes[i].eyeSide == Eye.LeftEye || Eyes[i].eyeSide == Eye.RightEye)
			{
				Eyes[i].eyecamera.enabled = Pvr_UnitySDKManager.SDK.VRModeEnabled;
			}
			else if (Eyes[i].eyeSide == Eye.BothEye)
			{
				Eyes[i].eyecamera.enabled = false;
			}
		}
	}

	private void SetCamerasEnableByStereoRendering()
	{
		MonoEyeCamera.enabled = Pvr_UnitySDKManager.SDK.Monoscopic && Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.MultiPass;
	}

	private void SetupMonoCamera()
	{
		base.transform.localPosition = Vector3.zero;
		MonoEyeCamera.aspect = Pvr_UnitySDKManager.SDK.EyesAspect;
		MonoEyeCamera.rect = new Rect(0f, 0f, 1f, 1f);
	}

	private void SetupUpdate()
	{
		MonoEyeCamera.fieldOfView = Pvr_UnitySDKRender.Instance.EyeVFoV;
		MonoEyeCamera.aspect = Pvr_UnitySDKManager.SDK.EyesAspect;
		MonoEyeTextureID = Pvr_UnitySDKRender.Instance.currEyeTextureIdx;
	}

	private void MonoEyeRender()
	{
		SetupUpdate();
		if (Pvr_UnitySDKRender.Instance.eyeTextures[MonoEyeTextureID] != null)
		{
			Pvr_UnitySDKRender.Instance.eyeTextures[MonoEyeTextureID].DiscardContents();
			MonoEyeCamera.targetTexture = Pvr_UnitySDKRender.Instance.eyeTextures[MonoEyeTextureID];
		}
	}

	private void Awake()
	{
		if (MonoEyeCamera == null)
		{
			MonoEyeCamera = GetComponent<Camera>();
		}
		if (LeftEyeCamera == null)
		{
			LeftEyeCamera = base.gameObject.transform.Find("LeftEye").GetComponent<Camera>();
		}
		if (RightEyeCamera == null)
		{
			RightEyeCamera = base.gameObject.transform.Find("RightEye").GetComponent<Camera>();
		}
		if (BothEyeCamera == null)
		{
			BothEyeCamera = base.gameObject.transform.Find("BothEye").GetComponent<Camera>();
		}
		if (BothEyeCamera != null)
		{
			BothEyeCamera.transform.GetComponent<Pvr_UnitySDKEye>().eyeSide = Eye.BothEye;
		}
		CreateFadeMesh();
		SetCurrentAlpha(0f);
		Render.UPvr_EnableFoveation(enable: true);
		if (foveatedRendering)
		{
			Render.SetFoveatedRenderingLevel(foveationLevel);
		}
		else
		{
			Render.SetFoveatedRenderingLevel((EFoveationLevel)(-1));
		}
		Pvr_UnitySDKManager.eventEnterVRMode = (Func<bool>)Delegate.Combine(Pvr_UnitySDKManager.eventEnterVRMode, new Func<bool>(SetEyeTrackingMode));
	}

	private void OnEnable()
	{
		if (instance == null)
		{
			instance = this;
		}
		else if (instance != this)
		{
			instance = this;
		}
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			Pvr_UnitySDKRender.Instance.StereoRendering.InitEye(BothEyeCamera);
		}
		foreach (Pvr_UnitySDKEyeOverlay instance in Pvr_UnitySDKEyeOverlay.Instances)
		{
			instance.RefreshCamera();
			if (instance.overlayType == Pvr_UnitySDKEyeOverlay.OverlayType.Overlay)
			{
				if (instance.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Cylinder)
				{
					Debug.Log("DISFT Cylinder OverLay = Enable");
				}
				if (instance.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Equirect)
				{
					Debug.Log("DISFT 360 OverLay= Enable");
				}
				if (instance.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Quad)
				{
					Debug.Log("DISFT 2D OverLay= Enable");
				}
			}
			if (instance.overlayType == Pvr_UnitySDKEyeOverlay.OverlayType.Underlay)
			{
				Debug.Log("DISFT UnderLay= Enable");
			}
		}
		GfxDeviceAdvanceFrameGLES();
		StartCoroutine("EndOfFrame");
		if (screenFade)
		{
			StartCoroutine(ScreenFade(1f, 0f));
		}
	}

	private void Start()
	{
		SetCamerasEnableByStereoRendering();
		SetupMonoCamera();
	}

	private void Update()
	{
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			for (int i = 0; i < Eyes.Length; i++)
			{
				if (Eyes[i].isActiveAndEnabled && Eyes[i].eyeSide == Eye.BothEye)
				{
					Eyes[i].EyeRender();
				}
			}
		}
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath != 0)
		{
			return;
		}
		if (!Pvr_UnitySDKManager.SDK.Monoscopic)
		{
			for (int j = 0; j < Eyes.Length; j++)
			{
				if (Eyes[j].isActiveAndEnabled && Eyes[j].eyeSide != Eye.BothEye)
				{
					Eyes[j].EyeRender();
				}
			}
		}
		else
		{
			MonoEyeRender();
		}
	}

	private void OnPause()
	{
		Pvr_UnitySDKManager.eventEnterVRMode = (Func<bool>)Delegate.Remove(Pvr_UnitySDKManager.eventEnterVRMode, new Func<bool>(SetEyeTrackingMode));
	}

	private void OnDisable()
	{
		StopAllCoroutines();
	}

	private void OnDestroy()
	{
		DestoryFadeMesh();
	}

	private void OnPostRender()
	{
		long data = Pvr_UnitySDKAPI.System.UPvr_GetEyeBufferData(Pvr_UnitySDKRender.Instance.eyeTextureIds[Pvr_UnitySDKRender.Instance.currEyeTextureIdx]);
		Pvr_UnitySDKAPI.System.UPvr_UnityEventData(data);
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.LeftEyeEndFrame);
		Pvr_UnitySDKAPI.System.UPvr_UnityEventData(data);
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.RightEyeEndFrame);
	}

	private IEnumerator EndOfFrame()
	{
		while (true)
		{
			yield return new WaitForEndOfFrame();
			if (!Pvr_UnitySDKManager.SDK.isEnterVRMode)
			{
				GL.Clear(clearDepth: false, clearColor: true, Color.black);
			}
			if (Pvr_UnitySDKRender.Instance.isFirstStartup && frameNum == WaitSplashScreenFrames)
			{
				Pvr_UnitySDKAPI.System.UPvr_RemovePlatformLogo();
				if (Pvr_UnitySDKManager.SDK.ResetTrackerOnLoad)
				{
					Debug.Log("Reset Tracker OnLoad");
					Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
				}
				Pvr_UnitySDKAPI.System.UPvr_StartVRModel();
				Pvr_UnitySDKRender.Instance.isFirstStartup = false;
			}
			else if (Pvr_UnitySDKRender.Instance.isFirstStartup && frameNum < WaitSplashScreenFrames)
			{
				PLOG.I("frameNum:" + frameNum);
				frameNum++;
			}
			int boundaryState = BoundarySystem.UPvr_GetSeeThroughState();
			if (Pvr_UnitySDKEyeOverlay.Instances.Count > 0 && boundaryState != 2)
			{
				overlayLayerDepth = 1;
				underlayLayerDepth = 0;
				Pvr_UnitySDKEyeOverlay.Instances.Sort();
				for (int i = 0; i < Pvr_UnitySDKEyeOverlay.Instances.Count; i++)
				{
					compositeLayer = Pvr_UnitySDKEyeOverlay.Instances[i];
					if (!compositeLayer.isActiveAndEnabled || (compositeLayer.layerTextures[0] == null && compositeLayer.layerTextures[1] == null && !compositeLayer.isExternalAndroidSurface) || (compositeLayer.layerTransform != null && !compositeLayer.layerTransform.gameObject.activeSelf))
					{
						continue;
					}
					layerFlags = 0;
					if (compositeLayer.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Quad || compositeLayer.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Cylinder)
					{
						if (compositeLayer.overlayType == Pvr_UnitySDKEyeOverlay.OverlayType.Overlay)
						{
							isHeadLocked = false;
							if (compositeLayer.layerTransform != null && compositeLayer.layerTransform.parent == base.transform)
							{
								isHeadLocked = true;
							}
							if (compositeLayer.isExternalAndroidSurface)
							{
								layerFlags |= 1;
								CreateExternalSurface(compositeLayer, overlayLayerDepth);
							}
							Render.UPvr_SetOverlayModelViewMatrix((int)compositeLayer.overlayType, (int)compositeLayer.overlayShape, compositeLayer.layerTextureIds[0], 0, overlayLayerDepth, isHeadLocked, layerFlags, compositeLayer.MVMatrixs[0], compositeLayer.ModelScales[0], compositeLayer.ModelRotations[0], compositeLayer.ModelTranslations[0], compositeLayer.CameraRotations[0], compositeLayer.CameraTranslations[0], compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
							Render.UPvr_SetOverlayModelViewMatrix((int)compositeLayer.overlayType, (int)compositeLayer.overlayShape, compositeLayer.layerTextureIds[1], 1, overlayLayerDepth, isHeadLocked, layerFlags, compositeLayer.MVMatrixs[1], compositeLayer.ModelScales[1], compositeLayer.ModelRotations[1], compositeLayer.ModelTranslations[1], compositeLayer.CameraRotations[1], compositeLayer.CameraTranslations[1], compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
							overlayLayerDepth++;
						}
						else if (compositeLayer.overlayType == Pvr_UnitySDKEyeOverlay.OverlayType.Underlay)
						{
							if (compositeLayer.isExternalAndroidSurface)
							{
								layerFlags |= 1;
								CreateExternalSurface(compositeLayer, underlayLayerDepth);
							}
							Render.UPvr_SetOverlayModelViewMatrix((int)compositeLayer.overlayType, (int)compositeLayer.overlayShape, compositeLayer.layerTextureIds[0], 0, underlayLayerDepth, isHeadLocked: false, layerFlags, compositeLayer.MVMatrixs[0], compositeLayer.ModelScales[0], compositeLayer.ModelRotations[0], compositeLayer.ModelTranslations[0], compositeLayer.CameraRotations[0], compositeLayer.CameraTranslations[0], compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
							Render.UPvr_SetOverlayModelViewMatrix((int)compositeLayer.overlayType, (int)compositeLayer.overlayShape, compositeLayer.layerTextureIds[1], 1, underlayLayerDepth, isHeadLocked: false, layerFlags, compositeLayer.MVMatrixs[1], compositeLayer.ModelScales[1], compositeLayer.ModelRotations[1], compositeLayer.ModelTranslations[1], compositeLayer.CameraRotations[1], compositeLayer.CameraTranslations[1], compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
							underlayLayerDepth++;
						}
					}
					else if (compositeLayer.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Equirect)
					{
						if (compositeLayer.isExternalAndroidSurface)
						{
							layerFlags |= 1;
							CreateExternalSurface(compositeLayer, 0);
						}
						Render.UPvr_SetupLayerData(0, 0, compositeLayer.layerTextureIds[0], (int)compositeLayer.overlayShape, layerFlags, compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
						Render.UPvr_SetupLayerData(0, 1, compositeLayer.layerTextureIds[1], (int)compositeLayer.overlayShape, layerFlags, compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
					}
				}
			}
			Pvr_UnitySDKAPI.System.UPvr_UnityEventData(Pvr_UnitySDKAPI.System.UPvr_GetEyeBufferData(0));
			Pvr_UnitySDKPluginEvent.Issue(RenderEventType.TimeWarp);
			Pvr_UnitySDKRender.Instance.currEyeTextureIdx = Pvr_UnitySDKRender.Instance.nextEyeTextureIdx;
			Pvr_UnitySDKRender.Instance.nextEyeTextureIdx = (Pvr_UnitySDKRender.Instance.nextEyeTextureIdx + 1) % 3;
		}
	}

	private void CreateExternalSurface(Pvr_UnitySDKEyeOverlay overlayInstance, int layerDepth)
	{
		if (overlayInstance.externalAndroidSurfaceObject == IntPtr.Zero)
		{
			overlayInstance.externalAndroidSurfaceObject = Render.UPvr_CreateLayerAndroidSurface((int)overlayInstance.overlayType, layerDepth);
			Debug.LogFormat("CreateExternalSurface: Overlay Type:{0}, LayerDepth:{1}, SurfaceObject:{2}", overlayInstance.overlayType, layerDepth, overlayInstance.externalAndroidSurfaceObject);
			if (overlayInstance.externalAndroidSurfaceObject != IntPtr.Zero && overlayInstance.externalAndroidSurfaceObjectCreated != null)
			{
				overlayInstance.externalAndroidSurfaceObjectCreated();
			}
		}
	}

	public bool SetEyeTrackingMode()
	{
		int num = Pvr_UnitySDKAPI.System.UPvr_GetTrackingMode();
		supportEyeTracking = (num & 4) != 0;
		bool flag = false;
		if (EyeTracking && supportEyeTracking)
		{
			flag = Pvr_UnitySDKAPI.System.UPvr_setTrackingMode(6);
		}
		Debug.Log("SetEyeTrackingMode EyeTracking " + EyeTracking + " supportEyeTracking " + supportEyeTracking + " result " + flag);
		return flag;
	}

	public Vector3 GetEyeTrackingPos()
	{
		if (!Instance.EyeTracking)
		{
			return Vector3.zero;
		}
		bool flag = Pvr_UnitySDKAPI.System.UPvr_getEyeTrackingData(ref eyePoseData);
		if (!flag)
		{
			PLOG.E("UPvr_getEyeTrackingData failed " + flag);
			return Vector3.zero;
		}
		EyeDeviceInfo deviceInfo = GetDeviceInfo();
		Vector3 zero = Vector3.zero;
		zero.x = 0.5f * (deviceInfo.targetFrustumLeft.right - deviceInfo.targetFrustumLeft.left);
		zero.y = 0.5f * (deviceInfo.targetFrustumLeft.top - deviceInfo.targetFrustumLeft.bottom);
		zero.z = deviceInfo.targetFrustumLeft.near;
		Vector3 foveatedGazeDirection = eyePoseData.foveatedGazeDirection;
		float num = Vector3.Dot(foveatedGazeDirection, Vector3.forward);
		if (num > float.Epsilon)
		{
			eyePoint = foveatedGazeDirection * (zero.z / num);
			eyePoint.x /= zero.x;
			eyePoint.y /= zero.y;
		}
		return eyePoint;
	}

	private EyeDeviceInfo GetDeviceInfo()
	{
		float eyeVFoV = Pvr_UnitySDKRender.Instance.EyeVFoV;
		float num = Mathf.Tan(eyeVFoV / 2f * ((float)Math.PI / 180f));
		float eyeHFoV = Pvr_UnitySDKRender.Instance.EyeHFoV;
		float num2 = Mathf.Tan(eyeHFoV / 2f * ((float)Math.PI / 180f));
		EyeDeviceInfo result = default(EyeDeviceInfo);
		result.targetFrustumLeft.left = 0f - LeftEyeCamera.nearClipPlane * num2;
		result.targetFrustumLeft.right = LeftEyeCamera.nearClipPlane * num2;
		result.targetFrustumLeft.top = LeftEyeCamera.nearClipPlane * num;
		result.targetFrustumLeft.bottom = 0f - LeftEyeCamera.nearClipPlane * num;
		result.targetFrustumLeft.near = LeftEyeCamera.nearClipPlane;
		result.targetFrustumLeft.far = LeftEyeCamera.farClipPlane;
		result.targetFrustumRight.left = 0f - RightEyeCamera.nearClipPlane * num2;
		result.targetFrustumRight.right = RightEyeCamera.nearClipPlane * num2;
		result.targetFrustumRight.top = RightEyeCamera.nearClipPlane * num;
		result.targetFrustumRight.bottom = 0f - RightEyeCamera.nearClipPlane * num;
		result.targetFrustumRight.near = RightEyeCamera.nearClipPlane;
		result.targetFrustumRight.far = RightEyeCamera.farClipPlane;
		return result;
	}

	private void CreateFadeMesh()
	{
		fadeMaterial = new Material(Shader.Find("Pvr_UnitySDK/Fade"));
		fadeMeshFilter = base.gameObject.AddComponent<MeshFilter>();
		fadeMeshRenderer = base.gameObject.AddComponent<MeshRenderer>();
		Mesh mesh = new Mesh();
		fadeMeshFilter.mesh = mesh;
		Vector3[] array = new Vector3[4];
		float num = 2f;
		float num2 = 2f;
		float z = 1f;
		ref Vector3 reference = ref array[0];
		reference = new Vector3(0f - num, 0f - num2, z);
		ref Vector3 reference2 = ref array[1];
		reference2 = new Vector3(num, 0f - num2, z);
		ref Vector3 reference3 = ref array[2];
		reference3 = new Vector3(0f - num, num2, z);
		ref Vector3 reference4 = ref array[3];
		reference4 = new Vector3(num, num2, z);
		mesh.vertices = array;
		mesh.triangles = new int[6] { 0, 2, 1, 2, 3, 1 };
		mesh.normals = new Vector3[4]
		{
			-Vector3.forward,
			-Vector3.forward,
			-Vector3.forward,
			-Vector3.forward
		};
		mesh.uv = new Vector2[4]
		{
			new Vector2(0f, 0f),
			new Vector2(1f, 0f),
			new Vector2(0f, 1f),
			new Vector2(1f, 1f)
		};
	}

	private void DestoryFadeMesh()
	{
		if (fadeMeshRenderer != null)
		{
			UnityEngine.Object.Destroy(fadeMeshRenderer);
		}
		if (fadeMaterial != null)
		{
			UnityEngine.Object.Destroy(fadeMaterial);
		}
		if (fadeMeshFilter != null)
		{
			UnityEngine.Object.Destroy(fadeMeshFilter);
		}
	}

	public void SetCurrentAlpha(float alpha)
	{
		currentAlpha = alpha;
		SetMaterialAlpha();
	}

	private IEnumerator ScreenFade(float startAlpha, float endAlpha)
	{
		float elapsedTime = 0f;
		while (elapsedTime < fadeTime)
		{
			elapsedTime += Time.deltaTime;
			nowFadeAlpha = Mathf.Lerp(startAlpha, endAlpha, Mathf.Clamp01(elapsedTime / fadeTime));
			SetMaterialAlpha();
			yield return new WaitForEndOfFrame();
		}
	}

	private void SetMaterialAlpha()
	{
		Color color = fadeColor;
		color.a = Mathf.Max(currentAlpha, nowFadeAlpha);
		isFading = color.a > 0f;
		if (fadeMaterial != null)
		{
			fadeMaterial.color = color;
			fadeMaterial.renderQueue = renderQueue;
			fadeMeshRenderer.material = fadeMaterial;
			fadeMeshRenderer.enabled = isFading;
		}
	}

	public bool GfxDeviceAdvanceFrameGLES()
	{
		return false;
	}
}
public class Pvr_UnitySDKEyeOverlay : MonoBehaviour, IComparable<Pvr_UnitySDKEyeOverlay>
{
	public delegate void ExternalAndroidSurfaceObjectCreated();

	public enum OverlayShape
	{
		Quad,
		Cylinder,
		Equirect
	}

	public enum OverlayType
	{
		Overlay,
		Underlay
	}

	public enum OverlayTexFilterMode
	{
		NotCare,
		Nearest,
		Linear,
		Nearest_Mipmap_Nearest,
		Linear_Mipmap_Nearest,
		Nearest_Mipmap_Linear,
		Linear_Mipmap_Linear
	}

	public static List<Pvr_UnitySDKEyeOverlay> Instances = new List<Pvr_UnitySDKEyeOverlay>();

	public int layerIndex;

	public OverlayType overlayType;

	public OverlayShape overlayShape;

	public Transform layerTransform;

	public Texture[] layerTextures = new Texture[2];

	public int[] layerTextureIds = new int[2];

	public Matrix4x4[] MVMatrixs = new Matrix4x4[2];

	public Vector3[] ModelScales = new Vector3[2];

	public Quaternion[] ModelRotations = new Quaternion[2];

	public Vector3[] ModelTranslations = new Vector3[2];

	public Quaternion[] CameraRotations = new Quaternion[2];

	public Vector3[] CameraTranslations = new Vector3[2];

	public Camera[] layerEyeCamera = new Camera[2];

	public bool overrideColorScaleAndOffset;

	public Vector4 colorScale = Vector4.one;

	public Vector4 colorOffset = Vector4.zero;

	private Vector4 overlayLayerColorScaleDefault = Vector4.one;

	private Vector4 overlayLayerColorOffsetDefault = Vector4.zero;

	public bool isExternalAndroidSurface;

	public IntPtr externalAndroidSurfaceObject = IntPtr.Zero;

	public ExternalAndroidSurfaceObjectCreated externalAndroidSurfaceObjectCreated;

	public int CompareTo(Pvr_UnitySDKEyeOverlay other)
	{
		return layerIndex.CompareTo(other.layerIndex);
	}

	private void Awake()
	{
		Instances.Add(this);
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.BothEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.BothEyeCamera;
		}
		else if (Pvr_UnitySDKManager.SDK.Monoscopic)
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.MonoEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.MonoEyeCamera;
		}
		else
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.LeftEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.RightEyeCamera;
		}
		layerTransform = GetComponent<Transform>();
		if (layerTransform != null)
		{
			MeshRenderer component = layerTransform.GetComponent<MeshRenderer>();
			if (component != null)
			{
				component.enabled = false;
			}
		}
		InitializeBuffer();
	}

	private void LateUpdate()
	{
		UpdateCoords();
	}

	private void OnDestroy()
	{
		Instances.Remove(this);
	}

	public void RefreshCamera()
	{
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.BothEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.BothEyeCamera;
		}
		else if (Pvr_UnitySDKManager.SDK.Monoscopic)
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.MonoEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.MonoEyeCamera;
		}
		else
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.LeftEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.RightEyeCamera;
		}
	}

	private void InitializeBuffer()
	{
		switch (overlayShape)
		{
		case OverlayShape.Quad:
		case OverlayShape.Cylinder:
		case OverlayShape.Equirect:
		{
			for (int i = 0; i < layerTextureIds.Length; i++)
			{
				if (layerTextures[i] != null)
				{
					layerTextureIds[i] = layerTextures[i].GetNativeTexturePtr().ToInt32();
				}
				else
				{
					Debug.LogWarning($"{(Eye)i} Texture is null!");
				}
			}
			break;
		}
		}
	}

	private void UpdateCoords()
	{
		if (layerTransform == null || !layerTransform.gameObject.activeSelf || layerEyeCamera[0] == null || layerEyeCamera[1] == null)
		{
			return;
		}
		for (int i = 0; i < MVMatrixs.Length; i++)
		{
			if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
			{
				Matrix4x4[] stereoWorldToCameraMat = Pvr_UnitySDKSinglePass.GetStereoWorldToCameraMat();
				ref Matrix4x4 reference = ref MVMatrixs[i];
				reference = stereoWorldToCameraMat[i] * layerTransform.localToWorldMatrix;
			}
			else
			{
				ref Matrix4x4 reference2 = ref MVMatrixs[i];
				reference2 = layerEyeCamera[i].worldToCameraMatrix * layerTransform.localToWorldMatrix;
			}
			ref Vector3 reference3 = ref ModelScales[i];
			reference3 = layerTransform.localScale;
			ref Quaternion reference4 = ref ModelRotations[i];
			reference4 = layerTransform.rotation;
			ref Vector3 reference5 = ref ModelTranslations[i];
			reference5 = layerTransform.position;
			ref Quaternion reference6 = ref CameraRotations[i];
			reference6 = layerEyeCamera[i].transform.rotation;
			ref Vector3 reference7 = ref CameraTranslations[i];
			reference7 = layerEyeCamera[i].transform.position;
		}
	}

	public void SetTexture(Texture texture)
	{
		for (int i = 0; i < layerTextures.Length; i++)
		{
			layerTextures[i] = texture;
		}
		InitializeBuffer();
	}

	public void SetLayerColorScaleAndOffset(Vector4 scale, Vector4 offset)
	{
		colorScale = scale;
		colorOffset = offset;
	}

	public Vector4 GetLayerColorScale()
	{
		if (!overrideColorScaleAndOffset)
		{
			return overlayLayerColorScaleDefault;
		}
		return colorScale;
	}

	public Vector4 GetLayerColorOffset()
	{
		if (!overrideColorScaleAndOffset)
		{
			return overlayLayerColorOffsetDefault;
		}
		return colorOffset;
	}
}
public class Pvr_UnitySDKRender
{
	private static Pvr_UnitySDKRender instance;

	public AndroidJavaObject activity;

	public static AndroidJavaClass javaVrActivityClass;

	public static AndroidJavaClass javaSysActivityClass;

	public static AndroidJavaClass javaserviceClass;

	public static AndroidJavaClass javaVrActivityLongReceiver;

	public static AndroidJavaClass javaVrActivityClientClass;

	private bool canConnecttoActivity;

	private bool isInitrenderThread = true;

	private string model;

	private Vector2 prefinger1 = new Vector2(0f, 0f);

	private Vector2 prefinger2 = new Vector2(0f, 0f);

	public int eyeTextureCount = 6;

	public RenderTexture[] eyeTextures;

	public int[] eyeTextureIds;

	public int currEyeTextureIdx;

	public int nextEyeTextureIdx = 1;

	public int lastEyeTextureIdx;

	public bool isSwitchSDK;

	public int RenderviewNumber;

	public bool isFirstStartup = true;

	public bool isShellMode;

	private StereoRenderingPathPico stereoRenderPath;

	private float rtScaleFactor = 1f;

	private float eyeVFov = 90f;

	private float eyeHFov = 90f;

	public static Pvr_UnitySDKRender Instance
	{
		get
		{
			if (instance == null)
			{
				instance = new Pvr_UnitySDKRender();
			}
			return instance;
		}
		set
		{
			instance = value;
		}
	}

	public StereoRenderingPathPico StereoRenderPath => stereoRenderPath;

	public SDKStereoRendering StereoRendering { get; private set; }

	public float RtScaleFactor
	{
		get
		{
			return rtScaleFactor;
		}
		set
		{
			if (value != rtScaleFactor)
			{
				rtScaleFactor = value;
				ReCreateEyeBuffer();
			}
		}
	}

	public float EyeVFoV
	{
		get
		{
			return eyeVFov;
		}
		set
		{
			if (value != eyeVFov)
			{
				eyeVFov = value;
			}
		}
	}

	public float EyeHFoV
	{
		get
		{
			return eyeHFov;
		}
		set
		{
			if (value != eyeHFov)
			{
				eyeHFov = value;
			}
		}
	}

	public Pvr_UnitySDKRender()
	{
		if (!canConnecttoActivity)
		{
			ConnectToAndriod();
			PLOG.I("PvrLog Init Render Ability Success!");
			isInitrenderThread = false;
		}
		Init();
	}

	public void ConnectToAndriod()
	{
		try
		{
			Debug.Log("PvrLog SDK Version :  " + Pvr_UnitySDKAPI.System.UPvr_GetSDKVersion().ToString() + "  Unity Script Version :" + Pvr_UnitySDKAPI.System.UPvr_GetUnitySDKVersion().ToString());
			AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
			activity = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
			javaVrActivityClass = new AndroidJavaClass("com.psmart.vrlib.VrActivity");
			javaserviceClass = new AndroidJavaClass("com.picovr.picovrlib.hummingbirdclient.UnityClient");
			javaVrActivityLongReceiver = new AndroidJavaClass("com.psmart.vrlib.HomeKeyReceiver");
			javaSysActivityClass = new AndroidJavaClass("com.psmart.aosoperation.SysActivity");
			javaVrActivityClientClass = new AndroidJavaClass("com.psmart.vrlib.PvrClient");
			Pvr_UnitySDKAPI.System.Pvr_SetInitActivity(activity.GetRawObject(), javaVrActivityClass.GetRawClass());
			model = javaVrActivityClass.CallStatic<string>("Pvr_GetBuildModel", new object[0]);
			double[] result = new double[5];
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaVrActivityClass, "getDPIParameters", activity);
			int res = -1;
			int configsenum = 4;
			Render.UPvr_GetIntConfig(configsenum, ref res);
			string result2 = string.Empty;
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result2, javaserviceClass, "getSysproc", "persist.pvr.debug.appfps");
			if (result2 != string.Empty)
			{
				Pvr_UnitySDKManager.SDK.systemFPS = Convert.ToBoolean(Convert.ToInt16(result2));
			}
			if (res == 0)
			{
				Render.UPvr_ChangeScreenParameters(model, (int)result[0], (int)result[1], result[2], result[3], result[4]);
				Screen.sleepTimeout = -1;
			}
			if (Pvr_UnitySDKAPI.System.UPvr_IsPicoActivity())
			{
				Debug.Log("ConnectToAndriod set monoPresentation success ?-------------" + Pvr_UnitySDKAPI.System.UPvr_SetMonoPresentation());
				Debug.Log("ConnectToAndriod presentation existed ?-------------" + Pvr_UnitySDKAPI.System.UPvr_IsPresentationExisted());
			}
			isShellMode = GetIsShellMode();
			Debug.Log("ConnectToAndriod isShellMode ?-------------" + isShellMode);
		}
		catch (AndroidJavaException ex)
		{
			PLOG.E("ConnectToAndriod--catch" + ex.Message);
		}
		canConnecttoActivity = true;
	}

	public void Init()
	{
		if (InitRenderAbility())
		{
			Debug.Log("PvrLog Init Render Ability Success!");
			isInitrenderThread = false;
		}
		else
		{
			Debug.Log("PvrLog Init Render Ability Failed!");
		}
	}

	private bool InitRenderAbility()
	{
		if (UpdateRenderParaFrame() && CreateEyeBuffer())
		{
			float num = Pvr_UnitySDKAPI.System.UPvr_GetIPD();
			Pvr_UnitySDKManager.SDK.leftEyeOffset = new Vector3((0f - num) / 2f, 0f, 0f);
			Pvr_UnitySDKManager.SDK.rightEyeOffset = new Vector3(num / 2f, 0f, 0f);
			return true;
		}
		return false;
	}

	private bool UpdateRenderParaFrame()
	{
		EyeVFoV = GetEyeVFOV();
		EyeHFoV = GetEyeHFOV();
		Pvr_UnitySDKManager.SDK.EyesAspect = EyeHFoV / EyeVFoV;
		return true;
	}

	private bool CreateEyeBuffer()
	{
		Vector2 eyeBufferResolution = GetEyeBufferResolution();
		if (isFirstStartup)
		{
			InitSinglePass();
			Pvr_UnitySDKAPI.System.UPvr_SetSinglePassDepthBufferWidthHeight((int)eyeBufferResolution.x, (int)eyeBufferResolution.y);
		}
		eyeTextures = new RenderTexture[eyeTextureCount];
		eyeTextureIds = new int[eyeTextureCount];
		for (int i = 0; i < eyeTextureCount; i++)
		{
			if (null == eyeTextures[i])
			{
				try
				{
					ConfigureEyeBuffer(i, eyeBufferResolution);
				}
				catch (Exception ex)
				{
					PLOG.E("ConfigureEyeBuffer ERROR " + ex.Message);
					throw;
				}
			}
			if (!eyeTextures[i].IsCreated())
			{
				eyeTextures[i].Create();
				eyeTextureIds[i] = eyeTextures[i].GetNativeTexturePtr().ToInt32();
			}
			eyeTextureIds[i] = eyeTextures[i].GetNativeTexturePtr().ToInt32();
		}
		return true;
	}

	private void InitSinglePass()
	{
		bool flag = true;
		if (Pvr_UnitySDKProjectSetting.GetProjectConfig().usesinglepass)
		{
			bool flag2 = false;
			if (flag)
			{
				flag2 = Pvr_UnitySDKAPI.System.UPvr_EnableSinglePass(enable: true);
			}
			if (flag2)
			{
				StereoRendering = new Pvr_UnitySDKSinglePass();
				stereoRenderPath = StereoRenderingPathPico.SinglePass;
				eyeTextureCount = 3;
			}
			Debug.Log("EnableSinglePass supportSinglePass " + flag.ToString() + " result " + flag2);
		}
	}

	public float GetEyeVFOV()
	{
		float res = 102f;
		try
		{
			int configsenum = 1;
			Render.UPvr_GetFloatConfig(configsenum, ref res);
			if (res <= 0f)
			{
				res = 102f;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("GetEyeVFOV ERROR! " + ex.Message);
			throw;
		}
		return res;
	}

	public float GetEyeHFOV()
	{
		float res = 102f;
		try
		{
			int configsenum = 2;
			Render.UPvr_GetFloatConfig(configsenum, ref res);
			if (res <= 0f)
			{
				res = 102f;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("GetEyeHFOV ERROR! " + ex.Message);
			throw;
		}
		return res;
	}

	private void ConfigureEyeBuffer(int eyeTextureIndex, Vector2 resolution)
	{
		int width = (int)resolution.x;
		int height = (int)resolution.y;
		eyeTextures[eyeTextureIndex] = new RenderTexture(width, height, (int)Pvr_UnitySDKProjectSetting.GetProjectConfig().rtBitDepth, Pvr_UnitySDKProjectSetting.GetProjectConfig().rtFormat);
		if (StereoRenderPath == StereoRenderingPathPico.MultiPass)
		{
			eyeTextures[eyeTextureIndex].anisoLevel = 0;
			eyeTextures[eyeTextureIndex].antiAliasing = Mathf.Max(QualitySettings.antiAliasing, (int)Pvr_UnitySDKProjectSetting.GetProjectConfig().rtAntiAlising);
			Debug.Log("MultiPass ConfigureEyeBuffer eyeTextureIndex " + eyeTextureIndex);
		}
		else if (StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			eyeTextures[eyeTextureIndex].useMipMap = false;
			eyeTextures[eyeTextureIndex].wrapMode = TextureWrapMode.Clamp;
			eyeTextures[eyeTextureIndex].filterMode = FilterMode.Bilinear;
			eyeTextures[eyeTextureIndex].anisoLevel = 1;
			eyeTextures[eyeTextureIndex].dimension = TextureDimension.Tex2DArray;
			eyeTextures[eyeTextureIndex].volumeDepth = 2;
			Debug.Log("SinglePass ConfigureEyeBuffer eyeTextureIndex " + eyeTextureIndex);
		}
		eyeTextures[eyeTextureIndex].Create();
		if (eyeTextures[eyeTextureIndex].IsCreated())
		{
			eyeTextureIds[eyeTextureIndex] = eyeTextures[eyeTextureIndex].GetNativeTexturePtr().ToInt32();
			Debug.Log("eyeTextureIndex : " + eyeTextureIndex);
		}
	}

	public bool ReCreateEyeBuffer()
	{
		if (!Pvr_UnitySDKProjectSetting.GetProjectConfig().usedefaultRenderTexture)
		{
			for (int i = 0; i < eyeTextureCount; i++)
			{
				if (eyeTextures[i] != null)
				{
					eyeTextures[i].Release();
				}
			}
			Array.Clear(eyeTextures, 0, eyeTextures.Length);
			return CreateEyeBuffer();
		}
		return false;
	}

	public void ReInit()
	{
		if (canConnecttoActivity && isInitrenderThread)
		{
			Init();
		}
	}

	public void IssueRenderThread()
	{
		if (canConnecttoActivity && !isInitrenderThread)
		{
			switch (QualitySettings.activeColorSpace)
			{
			case ColorSpace.Gamma:
				Render.UPvr_SetColorspaceType(0);
				break;
			case ColorSpace.Linear:
				Render.UPvr_SetColorspaceType(1);
				break;
			}
			Pvr_UnitySDKPluginEvent.Issue(RenderEventType.InitRenderThread);
			isInitrenderThread = true;
			if (StereoRendering != null)
			{
				StereoRendering.OnSDKRenderInited();
			}
			Debug.Log("PvrLog IssueRenderThread end");
		}
		else
		{
			PLOG.I("PvrLog IssueRenderThread  canConnecttoActivity = " + canConnecttoActivity);
		}
	}

	private void AutoAdpatForPico1s()
	{
		Vector2 position = Input.touches[0].position;
		Vector2 position2 = Input.touches[1].position;
		if (Vector2.Distance(prefinger1, position) > 2f && Vector2.Distance(prefinger2, position2) > 2f)
		{
			float midH = (Input.touches[0].position.x + Input.touches[1].position.x) / (float)Screen.width - 1f;
			float midV = (Input.touches[0].position.y + Input.touches[1].position.y) / (float)Screen.height - 1f;
			Render.UPvr_SetRatio(midH, midV);
		}
		prefinger1 = position;
		prefinger2 = position2;
	}

	public Vector2 GetEyeBufferResolution()
	{
		int res = 1024;
		int res2 = 1024;
		if (Pvr_UnitySDKProjectSetting.GetProjectConfig().usedefaultRenderTexture)
		{
			try
			{
				int configsenum = 0;
				Render.UPvr_GetIntConfig(configsenum, ref res);
				configsenum = 1;
				Render.UPvr_GetIntConfig(configsenum, ref res2);
			}
			catch (Exception ex)
			{
				PLOG.E("GetEyeBufferResolution ERROR! " + ex.Message);
				throw;
			}
		}
		else
		{
			res = (int)(Pvr_UnitySDKProjectSetting.GetProjectConfig().customRTSize.x * RtScaleFactor);
			res2 = (int)(Pvr_UnitySDKProjectSetting.GetProjectConfig().customRTSize.y * RtScaleFactor);
		}
		Vector2 vector = new Vector2(res, res2);
		Debug.Log(string.Concat("DISFT Customize RenderTexture:", vector, ", scaleFactor: ", RtScaleFactor));
		return vector;
	}

	public bool GetUsePredictedMatrix()
	{
		return true;
	}

	public bool GetIsShellMode()
	{
		if (activity == null)
		{
			return false;
		}
		AndroidJavaObject androidJavaObject = activity.Call<AndroidJavaObject>("getPackageManager", new object[0]);
		using (AndroidJavaObject androidJavaObject2 = androidJavaObject.Call<AndroidJavaObject>("getApplicationInfo", new object[2]
		{
			activity.Call<string>("getPackageName", new object[0]),
			128
		}))
		{
			AndroidJavaObject androidJavaObject3 = androidJavaObject2.Get<AndroidJavaObject>("metaData");
			if (androidJavaObject3 != null)
			{
				int num = 0;
				num = androidJavaObject3.Call<int>("getInt", new object[1] { "shell_mode" });
				if (num == 1)
				{
					return true;
				}
				return false;
			}
		}
		return false;
	}
}
public class Pvr_UnitySDKSinglePass : SDKStereoRendering
{
	private static Camera bothCamera;

	private Matrix4x4[] unity_StereoMatrixP = new Matrix4x4[2];

	private Matrix4x4[] unity_StereoMatrixInvP = new Matrix4x4[2];

	private static Matrix4x4[] unity_StereoWorldToCamera = new Matrix4x4[2];

	private Matrix4x4[] unity_StereoCameraToWorld = new Matrix4x4[2];

	private Matrix4x4[] unity_StereoMatrixVP = new Matrix4x4[2];

	private Vector3[] eyesOffset = new Vector3[2];

	private static Matrix4x4[] eyesOffsetMatrix = new Matrix4x4[2];

	private CommandBuffer commandBufferBeforeForwardOpaque;

	private CommandBuffer commandBufferBeforeSkybox;

	private CommandBuffer commandBufferAfterSkybox;

	public override void InitEye(Camera eye)
	{
		bothCamera = eye;
		bothCamera.stereoSeparation = 0.0625f;
		bothCamera.stereoConvergence = 0f;
		bothCamera.allowHDR = false;
		bothCamera.allowDynamicResolution = false;
		SetEyesPosition();
		SetEyeProjection();
		Pvr_UnitySDKSensor.EyeFovChanged = (Action)Delegate.Combine(Pvr_UnitySDKSensor.EyeFovChanged, new Action(SetEyeProjection));
		Debug.Log("SinglePass Init success! CameraName = " + eye.transform.name + " eye.eyeSide " + eye.GetComponent<Pvr_UnitySDKEye>().eyeSide);
	}

	public override void OnSDKRenderInited()
	{
		OnSDKRenderInited_SinglePass();
	}

	public override void OnSDKPreRender()
	{
		SinglePassPreRender();
	}

	public override void OnSDKPostRender()
	{
		SwitchKeywordAndDeviceView(enable: false);
	}

	public void OnSDKRenderInited_SinglePass()
	{
		Shader.SetGlobalVectorArray("unity_StereoScaleOffset", new Vector4[2]
		{
			new Vector4(1f, 1f, 0f, 0f),
			new Vector4(1f, 1f, 0.5f, 0f)
		});
		SetAntiAliasing();
		Debug.Log("OnSDKRenderInited_SinglePass");
	}

	private void SetAntiAliasing()
	{
		int num = Mathf.Max(QualitySettings.antiAliasing, (int)Pvr_UnitySDKProjectSetting.GetProjectConfig().rtAntiAlising);
		Pvr_UnitySDKAPI.System.UPvr_SetAntiAliasing(num);
		Debug.Log("SetAntiAliasing  antiAliasing = " + num);
	}

	public void SetEyesPosition()
	{
		float res = 0.0625f;
		int configsenum = 0;
		if (Render.UPvr_GetFloatConfig(configsenum, ref res) != 0)
		{
			PLOG.E("Cannot get ipd");
			res = 0.0625f;
		}
		bothCamera.stereoSeparation = res;
		Vector3 vector = new Vector3((0f - res) / 2f, 0f, 0f);
		Vector3 vector2 = new Vector3(res / 2f, 0f, 0f);
		Vector3 vector3 = (vector + vector2) / 2f;
		bothCamera.transform.localPosition = vector3;
		bothCamera.transform.localRotation = Quaternion.identity;
		Vector3 vector4 = vector - vector3;
		Vector3 vector5 = vector2 - vector3;
		eyesOffset[0] = vector4;
		eyesOffset[1] = vector5;
		ref Matrix4x4 reference = ref eyesOffsetMatrix[0];
		reference = Matrix4x4.TRS(vector4, Quaternion.identity, Vector3.one);
		ref Matrix4x4 reference2 = ref eyesOffsetMatrix[1];
		reference2 = Matrix4x4.TRS(vector5, Quaternion.identity, Vector3.one);
	}

	public void SetEyeProjection()
	{
		Matrix4x4 projection = GetProjection(bothCamera.nearClipPlane, bothCamera.farClipPlane);
		Matrix4x4 projection2 = GetProjection(bothCamera.nearClipPlane, bothCamera.farClipPlane);
		SetStereoProjectionMatrix(projection, projection2);
	}

	private static Matrix4x4 GetProjection(float near, float far)
	{
		if (near < 0.01f)
		{
			near = 0.01f;
		}
		if (far < 0.02f)
		{
			far = 0.02f;
		}
		Matrix4x4 identity = Matrix4x4.identity;
		return MakeProjection(near, far);
	}

	public static Matrix4x4 MakeProjection(float n, float f)
	{
		Vector2 eyeBufferResolution = Pvr_UnitySDKRender.Instance.GetEyeBufferResolution();
		float eyeVFoV = Pvr_UnitySDKRender.Instance.EyeVFoV;
		float num = Mathf.Tan(eyeVFoV / 2f * ((float)Math.PI / 180f));
		float num2 = 1f / num;
		Matrix4x4 zero = Matrix4x4.zero;
		zero[0, 0] = num2 / (eyeBufferResolution.x / eyeBufferResolution.y);
		zero[1, 1] = num2;
		zero[2, 2] = (0f - (f + n)) / (f - n);
		zero[2, 3] = -2f * f * n / (f - n);
		zero[3, 2] = -1f;
		return zero;
	}

	public void SetStereoProjectionMatrix(Matrix4x4 left, Matrix4x4 right)
	{
		unity_StereoMatrixP[0] = left;
		ref Matrix4x4 reference = ref unity_StereoMatrixInvP[0];
		reference = left.inverse;
		unity_StereoMatrixP[1] = right;
		ref Matrix4x4 reference2 = ref unity_StereoMatrixInvP[1];
		reference2 = right.inverse;
	}

	private void SwitchKeywordAndDeviceView(bool enable)
	{
		if (enable)
		{
			Shader.EnableKeyword("STEREO_MULTIVIEW_ON");
			Shader.EnableKeyword("UNITY_SINGLE_PASS_STEREO");
			XRSettings.showDeviceView = false;
		}
		else
		{
			XRSettings.showDeviceView = true;
			Shader.DisableKeyword("UNITY_SINGLE_PASS_STEREO");
			Shader.DisableKeyword("STEREO_MULTIVIEW_ON");
		}
	}

	public static Matrix4x4[] GetStereoWorldToCameraMat()
	{
		Matrix4x4 worldToCameraMatrix = bothCamera.worldToCameraMatrix;
		ref Matrix4x4 reference = ref unity_StereoWorldToCamera[0];
		reference = eyesOffsetMatrix[0].inverse * worldToCameraMatrix;
		ref Matrix4x4 reference2 = ref unity_StereoWorldToCamera[1];
		reference2 = eyesOffsetMatrix[1].inverse * worldToCameraMatrix;
		return unity_StereoWorldToCamera;
	}

	public void SinglePassPreRender()
	{
		SwitchKeywordAndDeviceView(enable: true);
		Shader.SetGlobalMatrixArray("unity_StereoCameraProjection", unity_StereoMatrixP);
		Shader.SetGlobalMatrixArray("unity_StereoCameraInvProjection", unity_StereoMatrixInvP);
		Shader.SetGlobalMatrixArray("unity_StereoMatrixP", unity_StereoMatrixP);
		Matrix4x4 worldToCameraMatrix = bothCamera.worldToCameraMatrix;
		Matrix4x4 cameraToWorldMatrix = bothCamera.cameraToWorldMatrix;
		ref Matrix4x4 reference = ref unity_StereoCameraToWorld[0];
		reference = cameraToWorldMatrix * eyesOffsetMatrix[0];
		ref Matrix4x4 reference2 = ref unity_StereoCameraToWorld[1];
		reference2 = cameraToWorldMatrix * eyesOffsetMatrix[1];
		Shader.SetGlobalMatrixArray("unity_StereoCameraToWorld", unity_StereoCameraToWorld);
		ref Matrix4x4 reference3 = ref unity_StereoWorldToCamera[0];
		reference3 = eyesOffsetMatrix[0].inverse * worldToCameraMatrix;
		ref Matrix4x4 reference4 = ref unity_StereoWorldToCamera[1];
		reference4 = eyesOffsetMatrix[1].inverse * worldToCameraMatrix;
		Shader.SetGlobalMatrixArray("unity_StereoWorldToCamera", unity_StereoWorldToCamera);
		Vector4[] values = new Vector4[2]
		{
			bothCamera.transform.position + eyesOffset[0],
			bothCamera.transform.position + eyesOffset[1]
		};
		Shader.SetGlobalVectorArray("unity_StereoWorldSpaceCameraPos", values);
		Shader.SetGlobalMatrixArray("unity_StereoMatrixV", unity_StereoWorldToCamera);
		Shader.SetGlobalMatrixArray("unity_StereoMatrixInvV", unity_StereoCameraToWorld);
		ref Matrix4x4 reference5 = ref unity_StereoMatrixVP[0];
		reference5 = unity_StereoMatrixP[0] * unity_StereoWorldToCamera[0];
		ref Matrix4x4 reference6 = ref unity_StereoMatrixVP[1];
		reference6 = unity_StereoMatrixP[1] * unity_StereoWorldToCamera[1];
		Shader.SetGlobalMatrixArray("unity_StereoMatrixVP", unity_StereoMatrixVP);
		SetRenderTextureWithDepth();
		SetCommandBuffers();
	}

	private void SetCommandBuffers()
	{
		if (commandBufferBeforeForwardOpaque == null)
		{
			commandBufferBeforeForwardOpaque = new CommandBuffer();
			Pvr_UnitySDKPluginEvent.SetSinglePassBeforeForwardOpaque(commandBufferBeforeForwardOpaque);
			commandBufferBeforeForwardOpaque.ClearRenderTarget(clearDepth: true, clearColor: true, bothCamera.backgroundColor);
			commandBufferBeforeForwardOpaque.name = "SinglePassPrepare";
		}
		bothCamera.RemoveCommandBuffer(CameraEvent.BeforeForwardOpaque, commandBufferBeforeForwardOpaque);
		bothCamera.AddCommandBuffer(CameraEvent.BeforeForwardOpaque, commandBufferBeforeForwardOpaque);
		if (commandBufferAfterSkybox == null)
		{
			commandBufferAfterSkybox = new CommandBuffer();
		}
		bothCamera.RemoveCommandBuffer(CameraEvent.AfterSkybox, commandBufferAfterSkybox);
		commandBufferAfterSkybox.Clear();
		commandBufferAfterSkybox.SetGlobalMatrixArray("unity_StereoMatrixVP", unity_StereoMatrixVP);
		commandBufferAfterSkybox.name = "SinglePassAfterSkyBox";
		bothCamera.AddCommandBuffer(CameraEvent.AfterSkybox, commandBufferAfterSkybox);
		if (commandBufferBeforeSkybox == null)
		{
			commandBufferBeforeSkybox = new CommandBuffer();
		}
		Matrix4x4 transpose = (Matrix4x4.LookAt(Vector3.zero, bothCamera.transform.forward, bothCamera.transform.up) * Matrix4x4.Scale(new Vector3(1f, 1f, -1f))).transpose;
		Matrix4x4 matrix4x = unity_StereoMatrixP[0];
		Matrix4x4 matrix4x2 = unity_StereoMatrixP[1];
		matrix4x.m22 = -1f;
		matrix4x2.m22 = -1f;
		Matrix4x4[] values = new Matrix4x4[2]
		{
			matrix4x * transpose,
			matrix4x2 * transpose
		};
		bothCamera.RemoveCommandBuffer(CameraEvent.BeforeSkybox, commandBufferBeforeSkybox);
		commandBufferBeforeSkybox.Clear();
		commandBufferBeforeSkybox.SetGlobalMatrixArray("unity_StereoMatrixVP", values);
		commandBufferBeforeSkybox.name = "SinglePassAfterSkybox";
		bothCamera.AddCommandBuffer(CameraEvent.BeforeSkybox, commandBufferBeforeSkybox);
	}

	private void SetRenderTextureWithDepth()
	{
		Pvr_UnitySDKAPI.System.UPvr_SetCurrentRenderTexture((uint)Pvr_UnitySDKRender.Instance.eyeTextureIds[Pvr_UnitySDKRender.Instance.currEyeTextureIdx]);
	}
}
public abstract class SDKStereoRendering
{
	public abstract void InitEye(Camera eye);

	public abstract void OnSDKRenderInited();

	public abstract void OnSDKPreRender();

	public abstract void OnSDKPostRender();
}
public class HighlightAtGaze : MonoBehaviour
{
	public Color HighlightColor = Color.red;

	public float AnimationTime = 0.1f;

	private Renderer myRenderer;

	private Color originalColor;

	private Color targetColor;

	private EyeTrackingGazeRay gazeRay;

	private void Start()
	{
		myRenderer = GetComponent<Renderer>();
		originalColor = myRenderer.material.color;
		targetColor = originalColor;
	}

	private void Update()
	{
		Pvr_UnitySDKAPI.System.UPvr_getEyeTrackingGazeRay(ref gazeRay);
		Ray ray = new Ray(gazeRay.Origin, gazeRay.Direction);
		if (Physics.Raycast(ray, out var hitInfo))
		{
			if (hitInfo.transform.name == base.transform.name)
			{
				if (targetColor != HighlightColor)
				{
					targetColor = HighlightColor;
				}
			}
			else if (targetColor != originalColor)
			{
				targetColor = originalColor;
			}
		}
		else if (targetColor != originalColor)
		{
			targetColor = originalColor;
		}
		myRenderer.material.color = Color.Lerp(myRenderer.material.color, targetColor, Time.deltaTime * (1f / AnimationTime));
	}
}
public class RayVisualizer : MonoBehaviour
{
	private LineRenderer _line;

	private EyeTrackingGazeRay gazeRay;

	private void Start()
	{
		_line = base.gameObject.GetComponent<LineRenderer>();
		_line.startWidth = 0.002f;
		_line.endWidth = 0.002f;
	}

	private void Update()
	{
		Matrix4x4 matrix = Pvr_UnitySDKSensor.Instance.HeadPose.Matrix;
		Pvr_UnitySDKAPI.System.UPvr_getEyeTrackingGazeRay(ref gazeRay);
		_line.SetPosition(0, matrix.MultiplyPoint(new Vector3(0f, -0.05f, 0.2f)));
		_line.SetPosition(1, gazeRay.Origin + gazeRay.Direction * 20f);
	}
}
public class GetSeeThroughImage : MonoBehaviour
{
	public RawImage viewImage_left;

	public RawImage viewImage_right;

	private int width;

	private int height;

	private RenderTexture cameraTex_left;

	private RenderTexture cameraTex_right;

	private bool cameraPreview;

	private void Start()
	{
		CreateTexture();
	}

	private void Update()
	{
		if (Input.GetKey(KeyCode.JoystickButton0))
		{
			DrawTexture();
		}
	}

	private void OnDestory()
	{
		if (cameraPreview)
		{
			cameraPreview = false;
			BoundarySystem.UPvr_StopCameraFrame();
		}
	}

	private void CreateTexture()
	{
		width = 600;
		height = 600;
		BoundarySystem.UPvr_BoundarySetCameraImageRect(width, height);
		cameraTex_left = new RenderTexture(width, height, 24, RenderTextureFormat.Default);
		cameraTex_right = new RenderTexture(width, height, 24, RenderTextureFormat.Default);
		cameraTex_left.Create();
		cameraTex_right.Create();
		viewImage_left.texture = cameraTex_left;
		viewImage_right.texture = cameraTex_right;
	}

	private void DrawTexture()
	{
		if (!cameraPreview)
		{
			cameraPreview = true;
			BoundarySystem.UPvr_StartCameraFrame();
		}
		BoundarySystem.UPvr_BoundaryGetSeeThroughData(0, cameraTex_left);
		BoundarySystem.UPvr_BoundaryGetSeeThroughData(1, cameraTex_right);
	}
}
public class OverlayExternalSurfaceDemo : MonoBehaviour
{
	public string movieName;

	public Pvr_UnitySDKEyeOverlay.OverlayType overlayType;

	public Pvr_UnitySDKEyeOverlay.OverlayShape overlayShape;

	private Pvr_UnitySDKEyeOverlay overlay;

	private const string TAG = "[ExternalSurface]>>>>>>";

	private void Awake()
	{
		overlay = GetComponent<Pvr_UnitySDKEyeOverlay>();
		if (overlay == null)
		{
			Debug.LogError("[ExternalSurface]>>>>>>Overlay is null!");
			overlay = base.gameObject.AddComponent<Pvr_UnitySDKEyeOverlay>();
		}
		overlay.overlayType = overlayType;
		overlay.overlayShape = overlayShape;
		overlay.isExternalAndroidSurface = true;
	}

	private void Start()
	{
		if (!string.IsNullOrEmpty(movieName))
		{
			StartPlay(Application.streamingAssetsPath + "/" + movieName, null);
		}
	}

	private void StartPlay(string moviePath, string licenceUrl)
	{
		if (moviePath != string.Empty)
		{
			if (overlay.isExternalAndroidSurface)
			{
				Pvr_UnitySDKEyeOverlay.ExternalAndroidSurfaceObjectCreated externalAndroidSurfaceObjectCreated = delegate
				{
					Debug.Log("[ExternalSurface]>>>>>>SurfaceObject created callback is Invoke().");
				};
				if (overlay.externalAndroidSurfaceObject == IntPtr.Zero)
				{
					Debug.Log("[ExternalSurface]>>>>>>Register surfaceObject crreated callback");
					overlay.externalAndroidSurfaceObjectCreated = externalAndroidSurfaceObjectCreated;
				}
				else
				{
					Debug.Log("[ExternalSurface]>>>>>>SurfaceObject is already created! Invoke callback");
					externalAndroidSurfaceObjectCreated();
				}
			}
		}
		else
		{
			Debug.LogError("[ExternalSurface]>>>>>>Movie path is null!");
		}
	}
}
public class MoveCylinder : MonoBehaviour
{
	private Vector3 startingPosition;

	private Quaternion startingRotation;

	private void Start()
	{
		startingPosition = base.transform.localPosition;
		startingRotation = base.transform.rotation;
	}

	public void Reset()
	{
		base.transform.localPosition = startingPosition;
		base.transform.rotation = startingRotation;
	}
}
[RequireComponent(typeof(Collider))]
public class MoveSphere : MonoBehaviour
{
	private Vector3 startingPosition;

	private void Start()
	{
		startingPosition = base.transform.localPosition;
		SetGazedAt(gazedAt: false);
		base.gameObject.GetComponent<Rigidbody>().AddForce(Vector3.right * 120f);
	}

	private void OnTriggerEnter(Collider other)
	{
	}

	public void SetGazedAt(bool gazedAt)
	{
		GetComponent<Renderer>().material.color = ((!gazedAt) ? Color.blue : Color.yellow);
	}

	public void Reset()
	{
		base.transform.localPosition = startingPosition;
		SetGazedAt(gazedAt: false);
		base.gameObject.GetComponent<Rigidbody>().Sleep();
		base.gameObject.GetComponent<Rigidbody>().AddForce(Vector3.right * 120f);
	}

	public void TeleportRandomly()
	{
		Vector3 onUnitSphere = UnityEngine.Random.onUnitSphere;
		onUnitSphere.y = Mathf.Clamp(onUnitSphere.y, 0.5f, 1f);
		float num = 2f * UnityEngine.Random.value + 1.5f;
		base.transform.localPosition = onUnitSphere * num;
	}
}
public class Resetbutton : MonoBehaviour
{
	public void DemoResetTracking()
	{
		if (Pvr_UnitySDKSensor.Instance != null)
		{
			Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
		}
	}
}
public class UserEntitlementCheck : MonoBehaviour
{
	private void OnEnable()
	{
		Pvr_UnitySDKManager.EntitlementCheckResultEvent += HandelEntitlementCheckResult;
	}

	private void OnDisable()
	{
		Pvr_UnitySDKManager.EntitlementCheckResultEvent -= HandelEntitlementCheckResult;
	}

	private void HandelEntitlementCheckResult(int resultCode)
	{
		Debug.Log("The User Entitlement Check Result is :" + resultCode);
		switch (resultCode)
		{
		case 0:
			Debug.Log("The User Entitlement Check Result is: success");
			break;
		case -1:
			Debug.Log("The User Entitlement Check Result is: invalid params");
			break;
		case -2:
			Debug.Log("The User Entitlement Check Result is: service not exist");
			break;
		case -3:
			Debug.Log("The User Entitlement Check Result is: bind failed");
			break;
		case -4:
			Debug.Log("The User Entitlement Check Result is: exception");
			break;
		case -5:
			Debug.Log("The User Entitlement Check Result is: timeout");
			break;
		case 10:
			Debug.Log("The User Entitlement Check Result is: missing package name");
			break;
		case 11:
			Debug.Log("The User Entitlement Check Result is: missing appid");
			break;
		case 13:
			Debug.Log("The User Entitlement Check Result is: appid and package name not match");
			break;
		case 20:
			Debug.Log("The User Entitlement Check Result is: not login");
			break;
		case 21:
			Debug.Log("The User Entitlement Check Result is: not pay");
			break;
		case 31:
			Debug.Log("The User Entitlement Check Result is: invalid sn");
			break;
		default:
			Debug.Log("The User Entitlement Check Result is: unknown");
			break;
		}
	}
}
public class Pvr_UnitySDKHeadTrack : MonoBehaviour
{
	[Tooltip("If true, head tracking will affect the rotation of each Pvr_UnitySDK's cameras.")]
	public bool trackRotation = true;

	[Tooltip("If true, head tracking will affect the position of each Pvr_UnitySDK's cameras.")]
	public bool trackPosition = true;

	public Transform target;

	private bool updated;

	private bool dataClock;

	public Ray Gaze
	{
		get
		{
			UpdateHead();
			return new Ray(base.transform.position, base.transform.forward);
		}
	}

	private void Update()
	{
		updated = false;
		UpdateHead();
	}

	private void UpdateHead()
	{
		if (updated)
		{
			return;
		}
		updated = true;
		if (Pvr_UnitySDKManager.SDK == null)
		{
			return;
		}
		if (trackRotation)
		{
			Quaternion orientation = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation;
			if (target == null)
			{
				base.transform.localRotation = orientation;
			}
			else
			{
				base.transform.rotation = orientation * target.rotation;
			}
		}
		else
		{
			Quaternion orientation2 = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation;
			if (target == null)
			{
				base.transform.localRotation = Quaternion.identity;
			}
			else
			{
				base.transform.rotation = orientation2 * target.rotation;
			}
		}
		if (trackPosition)
		{
			Vector3 position = Pvr_UnitySDKSensor.Instance.HeadPose.Position;
			if (target == null)
			{
				base.transform.localPosition = position;
			}
			else
			{
				base.transform.position = target.position + target.rotation * position;
			}
		}
	}
}
public class Pvr_UnitySDKPose
{
	protected static readonly Matrix4x4 flipZ = Matrix4x4.Scale(new Vector3(1f, 1f, -1f));

	public Matrix4x4 RightHandedMatrix => flipZ * Matrix * flipZ;

	public Vector3 Position { get; protected set; }

	public Quaternion Orientation { get; protected set; }

	public Matrix4x4 Matrix { get; protected set; }

	public Pvr_UnitySDKPose(Matrix4x4 matrix)
	{
		Set(matrix);
	}

	public Pvr_UnitySDKPose(Vector3 position, Quaternion orientation)
	{
		Set(position, orientation);
	}

	public void Set(Vector3 position, Quaternion orientation)
	{
		Position = position;
		Orientation = orientation;
		Matrix = Matrix4x4.TRS(position, orientation, Vector3.one);
	}

	protected void Set(Matrix4x4 matrix)
	{
		Matrix = matrix;
		Position = matrix.GetColumn(3);
		Orientation = Quaternion.LookRotation(matrix.GetColumn(2), matrix.GetColumn(1));
	}

	private Quaternion NormalizeQuaternion(ref Quaternion q)
	{
		float num = 0f;
		for (int i = 0; i < 4; i++)
		{
			num += q[i] * q[i];
		}
		float num2 = 1f / Mathf.Sqrt(num);
		for (int j = 0; j < 4; j++)
		{
			q[j] *= num2;
		}
		return q;
	}
}
public class Pvr_UnitySDKSensor
{
	public delegate void Enter3DofModel();

	public delegate void Exit3DofModel();

	private static Pvr_UnitySDKSensor instance;

	private bool SensorStart;

	private bool SensorInit;

	private Quaternion UnityQuaternion = Quaternion.identity;

	private Vector3 UnityPosition = Vector3.zero;

	private Sensorindex sensorIndex;

	private bool dofClock;

	public static Action EyeFovChanged;

	public Pvr_UnitySDKPose HeadPose;

	[CompilerGenerated]
	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private static Enter3DofModel m_Enter3DofModelEvent;

	[CompilerGenerated]
	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private static Exit3DofModel m_Exit3DofModelEvent;

	private float vfov = 102f;

	private float hfov = 102f;

	private float w;

	private float x;

	private float y;

	private float z;

	private float px;

	private float py;

	private float pz;

	public static Pvr_UnitySDKSensor Instance
	{
		get
		{
			if (instance == null)
			{
				instance = new Pvr_UnitySDKSensor();
			}
			return instance;
		}
		set
		{
			instance = value;
		}
	}

	public static event Enter3DofModel Enter3DofModelEvent
	{
		add
		{
			Enter3DofModel enter3DofModel = Pvr_UnitySDKSensor.m_Enter3DofModelEvent;
			Enter3DofModel enter3DofModel2;
			do
			{
				enter3DofModel2 = enter3DofModel;
				enter3DofModel = Interlocked.CompareExchange(ref Pvr_UnitySDKSensor.m_Enter3DofModelEvent, (Enter3DofModel)Delegate.Combine(enter3DofModel2, value), enter3DofModel);
			}
			while (enter3DofModel != enter3DofModel2);
		}
		remove
		{
			Enter3DofModel enter3DofModel = Pvr_UnitySDKSensor.m_Enter3DofModelEvent;
			Enter3DofModel enter3DofModel2;
			do
			{
				enter3DofModel2 = enter3DofModel;
				enter3DofModel = Interlocked.CompareExchange(ref Pvr_UnitySDKSensor.m_Enter3DofModelEvent, (Enter3DofModel)Delegate.Remove(enter3DofModel2, value), enter3DofModel);
			}
			while (enter3DofModel != enter3DofModel2);
		}
	}

	public static event Exit3DofModel Exit3DofModelEvent
	{
		add
		{
			Exit3DofModel exit3DofModel = Pvr_UnitySDKSensor.m_Exit3DofModelEvent;
			Exit3DofModel exit3DofModel2;
			do
			{
				exit3DofModel2 = exit3DofModel;
				exit3DofModel = Interlocked.CompareExchange(ref Pvr_UnitySDKSensor.m_Exit3DofModelEvent, (Exit3DofModel)Delegate.Combine(exit3DofModel2, value), exit3DofModel);
			}
			while (exit3DofModel != exit3DofModel2);
		}
		remove
		{
			Exit3DofModel exit3DofModel = Pvr_UnitySDKSensor.m_Exit3DofModelEvent;
			Exit3DofModel exit3DofModel2;
			do
			{
				exit3DofModel2 = exit3DofModel;
				exit3DofModel = Interlocked.CompareExchange(ref Pvr_UnitySDKSensor.m_Exit3DofModelEvent, (Exit3DofModel)Delegate.Remove(exit3DofModel2, value), exit3DofModel);
			}
			while (exit3DofModel != exit3DofModel2);
		}
	}

	public Pvr_UnitySDKSensor()
	{
		Init();
	}

	public void Init()
	{
		InitUnitySDK6DofSensor();
		SensorInit = InitUnitySDKSensor();
		SensorStart = StartUnitySDKSensor();
		HeadPose = new Pvr_UnitySDKPose(Vector3.zero, Quaternion.identity);
	}

	public void SensorUpdate()
	{
		if (GetUnitySDKSensorState())
		{
			HeadPose.Set(UnityPosition, UnityQuaternion);
		}
	}

	public bool InitUnitySDKSensor()
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_Init((int)sensorIndex) == 0)
			{
				result = true;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("InitUnitySDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool InitUnitySDK6DofSensor()
	{
		bool result = false;
		try
		{
			int res = 0;
			int configsenum = 3;
			Render.UPvr_GetIntConfig(configsenum, ref res);
			if (res == 1)
			{
				if (Sensor.UPvr_Enable6DofModule(!Pvr_UnitySDKManager.SDK.HmdOnlyrot) == 0 && !Pvr_UnitySDKManager.SDK.HmdOnlyrot)
				{
					result = true;
					Pvr_UnitySDKManager.SDK.PVRNeck = false;
				}
			}
			else
			{
				Debug.LogWarning("This platform does not support 6 Dof !");
			}
		}
		catch (Exception ex)
		{
			PLOG.E("InitUnity6DofSDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool StartUnitySDKSensor()
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_StartSensor((int)sensorIndex) == 0)
			{
				result = true;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("StartUnitySDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool StopUnitySDKSensor()
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_StopSensor((int)sensorIndex) == 0)
			{
				result = true;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("StopUnitySDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool ResetUnitySDKSensor()
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_ResetSensor((int)sensorIndex) == 0)
			{
				result = true;
				PLOG.E("ResetUnitySDKSensor OK! ");
			}
		}
		catch (Exception ex)
		{
			PLOG.E("ResetUnitySDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool OptionalResetUnitySDKSensor(int resetRot, int resetPos)
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_OptionalResetSensor((int)sensorIndex, resetRot, resetPos) == 0)
			{
				result = true;
				Debug.Log("PvrLog OptionalResetUnitySDKSensor OK!" + resetRot + resetPos);
			}
		}
		catch (Exception ex)
		{
			Debug.LogError("OptionalResetUnitySDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool GetUnitySDKSensorState()
	{
		bool result = false;
		if (SensorInit && SensorStart)
		{
			try
			{
				int num = -1;
				if (Pvr_UnitySDKManager.SDK.ShowVideoSeethrough)
				{
					Pvr_BoundarySystem.Instance.CameraFramePtr = Pvr_BoundaryAPI.UPvr_GetCameraData_Ext();
					num = Pvr_BoundaryAPI.UPvr_GetMainSensorStateExt(ref x, ref y, ref z, ref w, ref px, ref py, ref pz, ref vfov, ref hfov, ref Pvr_UnitySDKRender.Instance.RenderviewNumber);
				}
				else
				{
					num = Sensor.UPvr_GetMainSensorState(ref x, ref y, ref z, ref w, ref px, ref py, ref pz, ref vfov, ref hfov, ref Pvr_UnitySDKRender.Instance.RenderviewNumber);
				}
				Pvr_UnitySDKManager.SDK.posStatus = Sensor.UPvr_Get6DofSensorQualityStatus();
				if (num == 0)
				{
					if (!Convert.ToBoolean(Pvr_UnitySDKManager.SDK.posStatus & 2))
					{
						if (!dofClock)
						{
							if (Pvr_UnitySDKSensor.Enter3DofModelEvent != null)
							{
								Pvr_UnitySDKSensor.Enter3DofModelEvent();
							}
							dofClock = true;
						}
					}
					else if (dofClock)
					{
						if (Pvr_UnitySDKSensor.Exit3DofModelEvent != null)
						{
							Pvr_UnitySDKSensor.Exit3DofModelEvent();
						}
						dofClock = false;
					}
					RefreshHeadData(x, y, z, w, px, py, pz);
					UnityQuaternion.Set(x, y, 0f - z, 0f - w);
					if (Pvr_UnitySDKRender.Instance.EyeVFoV != vfov)
					{
						Pvr_UnitySDKRender.Instance.EyeVFoV = vfov;
						if (EyeFovChanged != null)
						{
							EyeFovChanged();
						}
					}
					Pvr_UnitySDKRender.Instance.EyeHFoV = hfov;
					Pvr_UnitySDKManager.SDK.EyesAspect = hfov / vfov;
					result = true;
					if (Pvr_UnitySDKManager.SDK.HmdOnlyrot)
					{
						if (Pvr_UnitySDKManager.SDK.PVRNeck)
						{
							if (Pvr_UnitySDKManager.SDK.TrackingOrigin == TrackingOrigin.FloorLevel)
							{
								UnityPosition.Set(0f, py, 0f);
								UnityPosition += UnityQuaternion * Pvr_UnitySDKManager.SDK.neckOffset - Pvr_UnitySDKManager.SDK.neckOffset.y * Vector3.up;
							}
							else
							{
								UnityPosition = UnityQuaternion * Pvr_UnitySDKManager.SDK.neckOffset - Pvr_UnitySDKManager.SDK.neckOffset.y * Vector3.up;
							}
						}
					}
					else
					{
						UnityPosition.Set(px, py, 0f - pz);
					}
					if (PLOG.logLevel > 2)
					{
						PLOG.D("posStatus=" + Pvr_UnitySDKManager.SDK.posStatus);
						PLOG.D("PvrLog 6DoFHeadRotation:" + x + "," + y + "," + (0f - z) + "," + (0f - w) + ",Position:" + px + "," + py + "," + (0f - pz) + ",eulerAngles:" + UnityQuaternion.eulerAngles);
					}
				}
				if (num == -1)
				{
					PLOG.I("PvrLog Sensor update --- GetUnitySDKSensorState  -1 ");
				}
			}
			catch (Exception ex)
			{
				PLOG.E("GetUnitySDKSensorState ERROR! " + ex.Message);
				throw;
			}
		}
		return result;
	}

	public bool GetUnitySDKPSensorState()
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_ResetSensor((int)sensorIndex) == 0)
			{
				result = true;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("GetUnitySDKPSensorState ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	private void RefreshHeadData(float x, float y, float z, float w, float px, float py, float pz)
	{
		Pvr_UnitySDKManager.SDK.headData[0] = x;
		Pvr_UnitySDKManager.SDK.headData[1] = y;
		Pvr_UnitySDKManager.SDK.headData[2] = z;
		Pvr_UnitySDKManager.SDK.headData[3] = w;
		Pvr_UnitySDKManager.SDK.headData[4] = px;
		Pvr_UnitySDKManager.SDK.headData[5] = py;
		Pvr_UnitySDKManager.SDK.headData[6] = pz;
	}
}
public class CLoadingAsset : ScriptableObject
{
	public int SplashScreenType;

	public List<Texture2D> splashImage = new List<Texture2D>();

	public Texture2D Inside_background;

	public bool UseSplashText;

	public string DefaultText;

	public string ChineseText;

	public string EnglishText;

	public string JapaneseText;

	public string KoreanText;

	public string FontSize;

	public Color FontColor;

	public string TextHeight;

	public bool UseCarousel;

	public int SplashTextAlignment;
}
[Serializable]
public class Pvr_UnitySDKConfigProfile
{
	public struct Lenses
	{
		public float separation;

		public float offset;

		public float distance;

		public int alignment;

		public const int AlignTop = -1;

		public const int AlignCenter = 0;

		public const int AlignBottom = 1;
	}

	public struct MaxFOV
	{
		public float upper;

		public float lower;

		public float inner;

		public float outer;
	}

	public struct Distortion
	{
		public float k1;

		public float k2;

		public float k3;

		public float k4;

		public float k5;

		public float k6;

		public float distort(float r)
		{
			return 0f;
		}

		public float distort(float r, float dist)
		{
			float num = r * dist * 1000f;
			float num2 = k1 * Mathf.Pow(num, 5f) + k2 * Mathf.Pow(num, 4f) + k3 * Mathf.Pow(num, 3f) + k4 * Mathf.Pow(num, 2f) + k5 * num + k6;
			return num2 / 1000f / dist;
		}

		public float diatortInv(float radious)
		{
			return 0f;
		}
	}

	public struct Device
	{
		public Lenses devLenses;

		public MaxFOV devMaxFov;

		public Distortion devDistortion;

		public Distortion devDistortionInv;
	}

	public static readonly Device SimulateDevice = new Device
	{
		devLenses = 
		{
			separation = 0.062f,
			offset = 0f,
			distance = 0.0403196f,
			alignment = 0
		},
		devMaxFov = 
		{
			upper = 40f,
			lower = 40f,
			inner = 40f,
			outer = 40f
		},
		devDistortion = 
		{
			k1 = 2.333E-06f,
			k2 = -0.000126f,
			k3 = 0.002978f,
			k4 = -0.02615f,
			k5 = 1.089f,
			k6 = -0.0337f
		},
		devDistortionInv = 
		{
			k1 = 1.342E-08f,
			k2 = 1.665E-06f,
			k3 = -0.0002797f,
			k4 = 0.001166f,
			k5 = 0.9945f,
			k6 = 0.004805f
		}
	};

	public Device device;

	public static readonly Pvr_UnitySDKConfigProfile Default = new Pvr_UnitySDKConfigProfile
	{
		device = SimulateDevice
	};

	public Pvr_UnitySDKConfigProfile Clone()
	{
		Pvr_UnitySDKConfigProfile pvr_UnitySDKConfigProfile = new Pvr_UnitySDKConfigProfile();
		pvr_UnitySDKConfigProfile.device = device;
		return pvr_UnitySDKConfigProfile;
	}

	public static Pvr_UnitySDKConfigProfile GetPicoProfile()
	{
		Pvr_UnitySDKConfigProfile pvr_UnitySDKConfigProfile = new Pvr_UnitySDKConfigProfile();
		pvr_UnitySDKConfigProfile.device = SimulateDevice;
		return pvr_UnitySDKConfigProfile;
	}

	public float[] GetLeftEyeVisibleTanAngles(float width, float height)
	{
		float val = (float)Math.Tan((double)(0f - device.devMaxFov.outer) * Math.PI / 180.0);
		float val2 = (float)Math.Tan((double)device.devMaxFov.upper * Math.PI / 180.0);
		float val3 = (float)Math.Tan((double)device.devMaxFov.inner * Math.PI / 180.0);
		float val4 = (float)Math.Tan((double)(0f - device.devMaxFov.lower) * Math.PI / 180.0);
		float num = width / 4f;
		float num2 = height / 2f;
		float num3 = device.devLenses.separation / 2f - num;
		float num4 = 0f;
		float distance = device.devLenses.distance;
		float val5 = device.devDistortion.distort((num3 - num) / distance, device.devLenses.distance);
		float val6 = device.devDistortion.distort((num4 + num2) / distance, device.devLenses.distance);
		float val7 = device.devDistortion.distort((num3 + num) / distance, device.devLenses.distance);
		float val8 = device.devDistortion.distort((num4 - num) / distance, device.devLenses.distance);
		float num5 = Math.Max(val, val5);
		float num6 = Math.Min(val2, val6);
		float num7 = Math.Min(val3, val7);
		float num8 = Math.Max(val4, val8);
		return new float[4] { num5, num6, num7, num8 };
	}

	public float[] GetLeftEyeNoLensTanAngles(float width, float height)
	{
		float val = device.devDistortionInv.distort((float)Math.Tan((double)(0f - device.devMaxFov.outer) * Math.PI / 180.0), device.devLenses.distance);
		float val2 = device.devDistortionInv.distort((float)Math.Tan((double)device.devMaxFov.upper * Math.PI / 180.0), device.devLenses.distance);
		float val3 = device.devDistortionInv.distort((float)Math.Tan((double)device.devMaxFov.inner * Math.PI / 180.0), device.devLenses.distance);
		float val4 = device.devDistortionInv.distort((float)Math.Tan((double)(0f - device.devMaxFov.lower) * Math.PI / 180.0), device.devLenses.distance);
		float num = width / 4f;
		float num2 = height / 2f;
		float num3 = device.devLenses.separation / 2f - num;
		float num4 = 0f;
		float distance = device.devLenses.distance;
		float val5 = (num3 - num) / distance;
		float val6 = (num4 + num2) / distance;
		float val7 = (num3 + num) / distance;
		float val8 = (num4 - num) / distance;
		float num5 = Math.Min(val, val5);
		float num6 = Math.Min(val2, val6);
		float num7 = Math.Min(val3, val7);
		float num8 = Math.Max(val4, val8);
		return new float[4] { num5, num6, num7, num8 };
	}

	public Rect GetLeftEyeVisibleScreenRect(float[] undistortedFrustum, float width, float height)
	{
		float distance = device.devLenses.distance;
		float num = (width - device.devLenses.separation) / 2f;
		float num2 = height / 2f;
		float num3 = (undistortedFrustum[0] * distance + num) / width;
		float num4 = (undistortedFrustum[1] * distance + num2) / height;
		float num5 = (undistortedFrustum[2] * distance + num) / width;
		float num6 = (undistortedFrustum[3] * distance + num2) / height;
		return new Rect(num3, num6, num5 - num3, num4 - num6);
	}
}
[RequireComponent(typeof(Text))]
public class Pvr_UnitySDKFPS : MonoBehaviour
{
	public Text fpsText;

	private float updateInterval = 0.5f;

	private float accum;

	private int frames;

	private float timeLeft;

	private string strFps;

	private void Update()
	{
		if (fpsText != null)
		{
			ShowFps();
		}
	}

	private void ShowFps()
	{
		timeLeft -= Time.unscaledDeltaTime;
		accum += Time.unscaledDeltaTime;
		frames++;
		if ((double)timeLeft <= 0.0)
		{
			float num = (float)frames / accum;
			strFps = $"FPS: {num:f0}";
			fpsText.text = strFps;
			timeLeft += updateInterval;
			accum = 0f;
			frames = 0;
		}
	}
}
public class Pvr_GazeFuse : MonoBehaviour
{
	public GameObject gazeGameObject;

	private Image image;

	private void Start()
	{
		image = GetComponent<Image>();
	}

	private void Update()
	{
		if (gazeGameObject == null || Pvr_GazeInputModule.gazeGameObject == gazeGameObject)
		{
			FuseAmountChanged(Pvr_GazeInputModule.gazeFraction);
		}
	}

	private void FuseAmountChanged(float fuseAmount)
	{
		if (image != null)
		{
			image.fillAmount = fuseAmount;
		}
	}
}
public class Pvr_GazeInputModule : PointerInputModule
{
	public enum Mode
	{
		Click,
		Gaze
	}

	public Mode mode;

	[Header("Click Settings")]
	public string ClickInputName = "Submit";

	[Header("Gaze Settings")]
	public float GazeTimeInSeconds = 2f;

	public RaycastResult CurrentRaycast;

	private PointerEventData pointerEventData;

	private GameObject currentLookAtHandler;

	private float currentLookAtHandlerClickTime;

	public static float gazeFraction { get; private set; }

	public static GameObject gazeGameObject { get; private set; }

	public override void Process()
	{
		HandleLook();
		HandleSelection();
	}

	private void HandleLook()
	{
		if (pointerEventData == null)
		{
			pointerEventData = new PointerEventData(base.eventSystem);
		}
		pointerEventData.position = new Vector2(Screen.width / 2, Screen.height / 2);
		pointerEventData.delta = Vector2.zero;
		List<RaycastResult> list = new List<RaycastResult>();
		base.eventSystem.RaycastAll(pointerEventData, list);
		RaycastResult raycastResult = BaseInputModule.FindFirstRaycast(list);
		pointerEventData.pointerCurrentRaycast = raycastResult;
		CurrentRaycast = raycastResult;
		ProcessMove(pointerEventData);
	}

	private void HandleSelection()
	{
		gazeFraction = 0f;
		if (pointerEventData.pointerEnter != null)
		{
			GameObject eventHandler = ExecuteEvents.GetEventHandler<IPointerClickHandler>(pointerEventData.pointerEnter);
			if (currentLookAtHandler != eventHandler)
			{
				gazeGameObject = (currentLookAtHandler = eventHandler);
				currentLookAtHandlerClickTime = Time.realtimeSinceStartup + GazeTimeInSeconds;
			}
			if (mode == Mode.Gaze && currentLookAtHandler != null)
			{
				gazeFraction = Mathf.Clamp01(1f - (currentLookAtHandlerClickTime - Time.realtimeSinceStartup) / GazeTimeInSeconds);
			}
			if ((currentLookAtHandler != null && mode == Mode.Gaze && Time.realtimeSinceStartup > currentLookAtHandlerClickTime) || (mode == Mode.Click && Input.GetButtonDown(ClickInputName)))
			{
				if (EventSystem.current.currentSelectedGameObject != null)
				{
				}
				EventSystem.current.SetSelectedGameObject(currentLookAtHandler);
				gazeFraction = 0f;
				ExecuteEvents.ExecuteHierarchy(currentLookAtHandler, pointerEventData, ExecuteEvents.pointerClickHandler);
				currentLookAtHandlerClickTime = float.MaxValue;
				ExecuteEvents.ExecuteHierarchy(EventSystem.current.currentSelectedGameObject, pointerEventData, ExecuteEvents.deselectHandler);
			}
		}
		else
		{
			gazeGameObject = (currentLookAtHandler = null);
		}
	}
}
[RequireComponent(typeof(Pvr_GazeInputModule))]
public class Pvr_GazeInputModuleCrosshair : MonoBehaviour
{
	public static bool DisplayCrosshair = true;

	[Tooltip("Crosshair GameObject attached to your VR Camera")]
	public Transform Crosshair;

	private Pvr_GazeInputModule gazeInputModule;

	private Vector3 CrosshairOriginalScale;

	private float CrosshairOriginalDistance;

	private void Awake()
	{
		gazeInputModule = GetComponent<Pvr_GazeInputModule>();
	}

	private void Start()
	{
		CrosshairOriginalScale = Crosshair.localScale;
		CrosshairOriginalDistance = Crosshair.localPosition.z;
		Crosshair.gameObject.SetActive(value: false);
	}

	private void Update()
	{
		Crosshair.gameObject.SetActive(DisplayCrosshair);
		if (DisplayCrosshair)
		{
			float crossHairAtDistance = CrosshairOriginalDistance;
			if (gazeInputModule.CurrentRaycast.isValid)
			{
				crossHairAtDistance = gazeInputModule.CurrentRaycast.distance * 0.8f - 0.5f;
			}
			SetCrossHairAtDistance(crossHairAtDistance);
		}
	}

	private void SetCrossHairAtDistance(float dist)
	{
		Vector3 localPosition = Crosshair.localPosition;
		Crosshair.localPosition = new Vector3(localPosition.x, localPosition.y, dist);
		Crosshair.localScale = CrosshairOriginalScale * dist;
	}
}
public enum RenderEventType
{
	InitRenderThread = 1024,
	Pause,
	Resume,
	LeftEyeEndFrame,
	RightEyeEndFrame,
	TimeWarp,
	ResetVrModeParms,
	ShutdownRenderThread,
	BeginEye,
	EndEye,
	BoundaryRenderLeft,
	BoundaryRenderRight,
	BothEyeEndFrame,
	CameraFrameLeft,
	CameraFrameRight,
	StartCameraFrame,
	StopCameraFrame
}
public static class Pvr_UnitySDKPluginEvent
{
	private delegate void RenderEventDelegate(int eventId);

	private const uint IS_DATA_FLAG = 2147483648u;

	private const uint DATA_POS_MASK = 1073741824u;

	private const int DATA_POS_SHIFT = 30;

	private const uint EVENT_TYPE_MASK = 1056899072u;

	private const int EVENT_TYPE_SHIFT = 17;

	private const uint PAYLOAD_MASK = 65535u;

	private const int PAYLOAD_SHIFT = 16;

	private static RenderEventDelegate SetSinglePassBeforeForwardOpaqueHandle = SetSinglePassBeforeForwardOpaque;

	private static IntPtr SetSinglePassBeforeForwardOpaquePtr = Marshal.GetFunctionPointerForDelegate(SetSinglePassBeforeForwardOpaqueHandle);

	public static void Issue(RenderEventType eventType)
	{
		GL.IssuePluginEvent(Pvr_UnitySDKAPI.System.GetRenderEventFunc(), (int)eventType);
	}

	private static int EncodeType(int eventType)
	{
		return eventType & 0x7FFFFFFF;
	}

	private static int EncodeData(int eventId, int eventData, int pos)
	{
		uint num = 0u;
		num |= 0x80000000u;
		num |= (uint)(pos << 30) & 0x40000000u;
		num |= (uint)(eventId << 17) & 0x3EFF0000u;
		return (int)num | ((eventData >>> pos * 16) & 0xFFFF);
	}

	private static int DecodeData(int eventData)
	{
		uint num = (uint)(eventData & 0x40000000) >> 30;
		return (eventData & 0xFFFF) << (int)(16 * num);
	}

	[MonoPInvokeCallback(typeof(RenderEventDelegate))]
	private static void SetSinglePassBeforeForwardOpaque(int eventId)
	{
		Pvr_UnitySDKAPI.System.UPvr_SinglePassBeforeForwardOpaque();
	}

	public static void SetSinglePassBeforeForwardOpaque(CommandBuffer cmd)
	{
		cmd.IssuePluginEvent(SetSinglePassBeforeForwardOpaquePtr, 0);
	}
}
public class Pvr_UnitySDKSightInputModule : BaseInputModule
{
	[Tooltip("Optional object to place at raycast intersections as a 3D cursor. Be sure it is on a layer that raycasts will ignore.")]
	public GameObject cursor;

	public int trigger;

	[HideInInspector]
	public float clickTime = 0.1f;

	[HideInInspector]
	public Vector2 hotspot = new Vector2(0.5f, 0.5f);

	private PointerEventData pointerData;

	public override bool ShouldActivateModule()
	{
		if (!base.ShouldActivateModule())
		{
			return false;
		}
		return Pvr_UnitySDKManager.SDK.VRModeEnabled;
	}

	public override void DeactivateModule()
	{
		base.DeactivateModule();
		if (pointerData != null)
		{
			HandlePendingClick();
			HandlePointerExitAndEnter(pointerData, null);
			pointerData = null;
		}
		base.eventSystem.SetSelectedGameObject(null, GetBaseEventData());
		if (cursor != null)
		{
			cursor.SetActive(value: false);
		}
	}

	public override bool IsPointerOverGameObject(int pointerId)
	{
		return pointerData != null && pointerData.pointerEnter != null;
	}

	public override void Process()
	{
		CastRayFromGaze();
		UpdateCurrentObject();
		PlaceCursor();
		HandlePendingClick();
		HandleTrigger();
	}

	private void CastRayFromGaze()
	{
		if (pointerData == null)
		{
			pointerData = new PointerEventData(base.eventSystem);
		}
		pointerData.Reset();
		pointerData.position = new Vector2(hotspot.x * (float)Screen.width, hotspot.y * (float)Screen.height);
		base.eventSystem.RaycastAll(pointerData, m_RaycastResultCache);
		pointerData.pointerCurrentRaycast = BaseInputModule.FindFirstRaycast(m_RaycastResultCache);
		m_RaycastResultCache.Clear();
	}

	private void UpdateCurrentObject()
	{
		GameObject gameObject = pointerData.pointerCurrentRaycast.gameObject;
		HandlePointerExitAndEnter(pointerData, gameObject);
		GameObject eventHandler = ExecuteEvents.GetEventHandler<ISelectHandler>(gameObject);
		if (eventHandler == base.eventSystem.currentSelectedGameObject)
		{
			ExecuteEvents.Execute(base.eventSystem.currentSelectedGameObject, GetBaseEventData(), ExecuteEvents.updateSelectedHandler);
		}
		else
		{
			base.eventSystem.SetSelectedGameObject(null, pointerData);
		}
	}

	private void PlaceCursor()
	{
		if (!(cursor == null))
		{
			GameObject gameObject = pointerData.pointerCurrentRaycast.gameObject;
			cursor.SetActive(gameObject != null);
			if (cursor.activeInHierarchy)
			{
				Camera enterEventCamera = pointerData.enterEventCamera;
				float num = pointerData.pointerCurrentRaycast.distance + enterEventCamera.nearClipPlane - 0.1f;
				cursor.transform.position = enterEventCamera.transform.position + enterEventCamera.transform.forward * num;
			}
		}
	}

	private void HandlePendingClick()
	{
		if (pointerData.eligibleForClick && (Pvr_UnitySDKManager.SDK.picovrTriggered || !(Time.unscaledTime - pointerData.clickTime < clickTime)))
		{
			ExecuteEvents.Execute(pointerData.pointerPress, pointerData, ExecuteEvents.pointerUpHandler);
			ExecuteEvents.Execute(pointerData.pointerPress, pointerData, ExecuteEvents.pointerClickHandler);
			pointerData.pointerPress = null;
			pointerData.rawPointerPress = null;
			pointerData.eligibleForClick = false;
			pointerData.clickCount = 0;
		}
	}

	private void HandleTrigger()
	{
		if (Pvr_UnitySDKManager.SDK.picovrTriggered)
		{
			GameObject gameObject = pointerData.pointerCurrentRaycast.gameObject;
			if (!(gameObject == null) && !(ExecuteEvents.GetEventHandler<IPointerClickHandler>(gameObject) == null))
			{
				pointerData.pointerPress = ExecuteEvents.GetEventHandler<IPointerClickHandler>(gameObject);
				pointerData.pressPosition = pointerData.position;
				pointerData.pointerPressRaycast = pointerData.pointerCurrentRaycast;
				pointerData.pointerPress = ExecuteEvents.ExecuteHierarchy(gameObject, pointerData, ExecuteEvents.pointerDownHandler) ?? ExecuteEvents.GetEventHandler<IPointerClickHandler>(gameObject);
				pointerData.rawPointerPress = gameObject;
				pointerData.eligibleForClick = true;
				pointerData.clickCount = 1;
				pointerData.clickTime = Time.unscaledTime;
			}
		}
	}
}
public class Pvr_ObjImporter
{
	private static Pvr_ObjImporter _instance;

	private List<int> triangles;

	private List<Vector3> vertices;

	private List<Vector2> uv;

	private List<Vector3> normals;

	private List<PvrVector3Int> faceData;

	private List<int> intArray;

	private const int MIN_POW_10 = -16;

	private const int MAX_POW_10 = 16;

	private const int NUM_POWS_10 = 33;

	private static readonly float[] pow10 = GenerateLookupTable();

	public static Pvr_ObjImporter Instance => _instance ?? (_instance = new Pvr_ObjImporter());

	public Mesh ImportFile(string filePath)
	{
		triangles = new List<int>();
		vertices = new List<Vector3>();
		uv = new List<Vector2>();
		normals = new List<Vector3>();
		faceData = new List<PvrVector3Int>();
		intArray = new List<int>();
		LoadMeshData(filePath);
		Vector3[] array = new Vector3[faceData.Count];
		Vector2[] array2 = new Vector2[faceData.Count];
		Vector3[] array3 = new Vector3[faceData.Count];
		for (int i = 0; i < faceData.Count; i++)
		{
			ref Vector3 reference = ref array[i];
			reference = vertices[faceData[i].x - 1];
			if (faceData[i].y >= 1)
			{
				ref Vector2 reference2 = ref array2[i];
				reference2 = uv[faceData[i].y - 1];
			}
			if (faceData[i].z >= 1)
			{
				ref Vector3 reference3 = ref array3[i];
				reference3 = normals[faceData[i].z - 1];
			}
		}
		Mesh mesh = new Mesh();
		mesh.vertices = array;
		mesh.uv = array2;
		mesh.normals = array3;
		mesh.triangles = triangles.ToArray();
		mesh.RecalculateBounds();
		return mesh;
	}

	private void LoadMeshData(string fileName)
	{
		StringBuilder stringBuilder = new StringBuilder();
		string text = File.ReadAllText(fileName);
		int num = 0;
		string text2 = null;
		int num2 = 0;
		StringBuilder sbInt = new StringBuilder();
		for (int i = 0; i < text.Length; i++)
		{
			if (text[i] != '\n')
			{
				continue;
			}
			stringBuilder.Remove(0, stringBuilder.Length);
			stringBuilder.Append(text, num + 1, i - num);
			num = i;
			if (stringBuilder[0] == 'o' && stringBuilder[1] == ' ')
			{
				sbInt.Remove(0, sbInt.Length);
				for (int j = 2; j < stringBuilder.Length; j++)
				{
					text2 += stringBuilder[j];
				}
			}
			else if (stringBuilder[0] == 'v' && stringBuilder[1] == ' ')
			{
				int start = 2;
				vertices.Add(new Vector3(GetFloat(stringBuilder, ref start, ref sbInt), GetFloat(stringBuilder, ref start, ref sbInt), GetFloat(stringBuilder, ref start, ref sbInt)));
			}
			else if (stringBuilder[0] == 'v' && stringBuilder[1] == 't' && stringBuilder[2] == ' ')
			{
				int start2 = 3;
				uv.Add(new Vector2(GetFloat(stringBuilder, ref start2, ref sbInt), GetFloat(stringBuilder, ref start2, ref sbInt)));
			}
			else if (stringBuilder[0] == 'v' && stringBuilder[1] == 'n' && stringBuilder[2] == ' ')
			{
				int start3 = 3;
				normals.Add(new Vector3(GetFloat(stringBuilder, ref start3, ref sbInt), GetFloat(stringBuilder, ref start3, ref sbInt), GetFloat(stringBuilder, ref start3, ref sbInt)));
			}
			else if (stringBuilder[0] == 'f' && stringBuilder[1] == ' ')
			{
				int start4 = 2;
				int num3 = 1;
				intArray.Clear();
				int num4 = 0;
				while (start4 < stringBuilder.Length && char.IsDigit(stringBuilder[start4]))
				{
					faceData.Add(new PvrVector3Int(GetInt(stringBuilder, ref start4, ref sbInt), GetInt(stringBuilder, ref start4, ref sbInt), GetInt(stringBuilder, ref start4, ref sbInt)));
					num3++;
					intArray.Add(num2);
					num2++;
				}
				num4 += num3;
				for (num3 = 1; num3 + 2 < num4; num3++)
				{
					triangles.Add(intArray[0]);
					triangles.Add(intArray[num3]);
					triangles.Add(intArray[num3 + 1]);
				}
			}
		}
	}

	private float GetFloat(StringBuilder sb, ref int start, ref StringBuilder sbFloat)
	{
		sbFloat.Remove(0, sbFloat.Length);
		while (start < sb.Length && (char.IsDigit(sb[start]) || sb[start] == '-' || sb[start] == '.'))
		{
			sbFloat.Append(sb[start]);
			start++;
		}
		start++;
		return ParseFloat(sbFloat);
	}

	private int GetInt(StringBuilder sb, ref int start, ref StringBuilder sbInt)
	{
		sbInt.Remove(0, sbInt.Length);
		while (start < sb.Length && char.IsDigit(sb[start]))
		{
			sbInt.Append(sb[start]);
			start++;
		}
		start++;
		return IntParseFast(sbInt);
	}

	private static float[] GenerateLookupTable()
	{
		float[] array = new float[320];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = (float)(i / 33) * Mathf.Pow(10f, i % 33 + -16);
		}
		return array;
	}

	private float ParseFloat(StringBuilder value)
	{
		float num = 0f;
		bool flag = false;
		int length = value.Length;
		int num2 = value.Length;
		for (int num3 = length - 1; num3 >= 0; num3--)
		{
			if (value[num3] == '.')
			{
				num2 = num3;
				break;
			}
		}
		int num4 = 16 + num2;
		for (int i = 0; i < num2; i++)
		{
			if (i != num2 && value[i] != '-')
			{
				num += pow10[(value[i] - 48) * 33 + num4 - i - 1];
			}
			else if (value[i] == '-')
			{
				flag = true;
			}
		}
		for (int j = num2 + 1; j < length; j++)
		{
			if (j != num2)
			{
				num += pow10[(value[j] - 48) * 33 + num4 - j];
			}
		}
		if (flag)
		{
			num = 0f - num;
		}
		return num;
	}

	private int IntParseFast(StringBuilder value)
	{
		int num = 0;
		for (int i = 0; i < value.Length; i++)
		{
			num = 10 * num + (value[i] - 48);
		}
		return num;
	}
}
public sealed class PvrVector3Int
{
	public int x { get; set; }

	public int y { get; set; }

	public int z { get; set; }

	public PvrVector3Int()
	{
	}

	public PvrVector3Int(int x, int y, int z)
	{
		this.x = x;
		this.y = y;
		this.z = z;
	}
}
public class Pvr_EnumFlags : PropertyAttribute
{
}
public enum ConfirmBtn
{
	App = 1,
	TouchPad = 2,
	Trigger = 4
}
public class Pvr_InputModule : PointerInputModule
{
	public static List<Pvr_UIPointer> pointers = new List<Pvr_UIPointer>();

	[Pvr_EnumFlags]
	public ConfirmBtn confirmBtn = ConfirmBtn.TouchPad;

	private List<RaycastResult> rayCasts = new List<RaycastResult>();

	private RaycastResult rayCastResult = default(RaycastResult);

	public virtual void Initialise()
	{
		pointers.Clear();
	}

	public static void AddPoint(Pvr_UIPointer point)
	{
		if (!pointers.Contains(point))
		{
			pointers.Add(point);
		}
	}

	public static void RemovePoint(Pvr_UIPointer point)
	{
		if (pointers.Contains(point))
		{
			pointers.Remove(point);
		}
	}

	public override void Process()
	{
		if (Pvr_UnitySDKManager.SDK.isHasController)
		{
			if ((confirmBtn & ConfirmBtn.App) == ConfirmBtn.App)
			{
				Pvr_UIPointer.AppBtnValue = Controller.UPvr_GetKey(Pvr_ControllerManager.controllerlink.mainHandID, Pvr_KeyCode.APP);
			}
			if ((confirmBtn & ConfirmBtn.TouchPad) == ConfirmBtn.TouchPad)
			{
				Pvr_UIPointer.TouchBtnValue = Controller.UPvr_GetKey(Pvr_ControllerManager.controllerlink.mainHandID, Pvr_KeyCode.TOUCHPAD);
			}
			if ((confirmBtn & ConfirmBtn.Trigger) == ConfirmBtn.Trigger)
			{
				Pvr_UIPointer.TriggerBtnValue = Controller.UPvr_GetKey(Pvr_ControllerManager.controllerlink.mainHandID, Pvr_KeyCode.TRIGGER);
			}
		}
		for (int i = 0; i < pointers.Count; i++)
		{
			Pvr_UIPointer pvr_UIPointer = pointers[i];
			if (pvr_UIPointer.gameObject.activeInHierarchy && pvr_UIPointer.enabled)
			{
				List<RaycastResult> results = new List<RaycastResult>();
				if (pvr_UIPointer.PointerActive())
				{
					results = CheckRaycasts(pvr_UIPointer);
				}
				Hover(pvr_UIPointer, results);
				Click(pvr_UIPointer, results);
				Drag(pvr_UIPointer, results);
			}
		}
	}

	protected virtual List<RaycastResult> CheckRaycasts(Pvr_UIPointer pointer)
	{
		rayCastResult.worldPosition = pointer.GetOriginPosition();
		rayCastResult.worldNormal = pointer.GetOriginForward();
		pointer.pointerEventData.pointerCurrentRaycast = rayCastResult;
		base.eventSystem.RaycastAll(pointer.pointerEventData, rayCasts);
		return rayCasts;
	}

	protected virtual bool CheckTransformTree(Transform target, Transform source)
	{
		if (target == null)
		{
			return false;
		}
		if (target.Equals(source))
		{
			return true;
		}
		return CheckTransformTree(target.transform.parent, source);
	}

	protected virtual bool NoValidCollision(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		return results.Count == 0 || !CheckTransformTree(results[0].gameObject.transform, pointer.pointerEventData.pointerEnter.transform);
	}

	protected virtual bool IsHovering(Pvr_UIPointer pointer)
	{
		foreach (GameObject item in pointer.pointerEventData.hovered)
		{
			if ((bool)pointer.pointerEventData.pointerEnter && (bool)item && CheckTransformTree(item.transform, pointer.pointerEventData.pointerEnter.transform))
			{
				return true;
			}
		}
		return false;
	}

	protected virtual bool ValidElement(GameObject obj)
	{
		Pvr_UICanvas componentInParent = obj.GetComponentInParent<Pvr_UICanvas>();
		return ((bool)componentInParent && componentInParent.enabled) ? true : false;
	}

	protected virtual void CheckPointerHoverClick(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		if (pointer.hoverDurationTimer > 0f)
		{
			pointer.hoverDurationTimer -= Time.deltaTime;
		}
		if (pointer.canClickOnHover && pointer.hoverDurationTimer <= 0f)
		{
			pointer.canClickOnHover = false;
			ClickOnDown(pointer, results, forceClick: true);
		}
	}

	protected virtual void Hover(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		if ((bool)pointer.pointerEventData.pointerEnter)
		{
			CheckPointerHoverClick(pointer, results);
			if (!ValidElement(pointer.pointerEventData.pointerEnter))
			{
				pointer.pointerEventData.pointerEnter = null;
				return;
			}
			if (NoValidCollision(pointer, results))
			{
				ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerEnter, pointer.pointerEventData, ExecuteEvents.pointerExitHandler);
				pointer.pointerEventData.hovered.Remove(pointer.pointerEventData.pointerEnter);
				pointer.pointerEventData.pointerEnter = null;
			}
			if (results.Count <= 0 || !(pointer.pointerEventData.pointerEnter != results[0].gameObject))
			{
				return;
			}
			{
				foreach (RaycastResult result in results)
				{
					if (!ValidElement(result.gameObject))
					{
						continue;
					}
					GameObject gameObject = ExecuteEvents.ExecuteHierarchy(result.gameObject, pointer.pointerEventData, ExecuteEvents.pointerEnterHandler);
					if (gameObject != null)
					{
						Selectable component = gameObject.GetComponent<Selectable>();
						if ((bool)component)
						{
							Navigation navigation = default(Navigation);
							navigation.mode = Navigation.Mode.None;
							component.navigation = navigation;
						}
						pointer.pointerEventData.hovered.Remove(pointer.pointerEventData.pointerEnter);
						pointer.OnUIPointerElementEnter(pointer.SetUIPointerEvent(result, gameObject, pointer.hoveringElement));
						pointer.hoveringElement = gameObject;
						pointer.pointerEventData.pointerCurrentRaycast = result;
						pointer.pointerEventData.pointerEnter = gameObject;
						pointer.pointerEventData.hovered.Add(pointer.pointerEventData.pointerEnter);
						break;
					}
					if (result.gameObject != pointer.hoveringElement)
					{
						pointer.OnUIPointerElementEnter(pointer.SetUIPointerEvent(result, result.gameObject, pointer.hoveringElement));
					}
					pointer.hoveringElement = result.gameObject;
				}
				return;
			}
		}
		foreach (RaycastResult result2 in results)
		{
			if (!ValidElement(result2.gameObject))
			{
				continue;
			}
			GameObject gameObject2 = ExecuteEvents.ExecuteHierarchy(result2.gameObject, pointer.pointerEventData, ExecuteEvents.pointerEnterHandler);
			if (gameObject2 != null)
			{
				Selectable component2 = gameObject2.GetComponent<Selectable>();
				if ((bool)component2)
				{
					Navigation navigation2 = default(Navigation);
					navigation2.mode = Navigation.Mode.None;
					component2.navigation = navigation2;
				}
				pointer.OnUIPointerElementEnter(pointer.SetUIPointerEvent(result2, gameObject2, pointer.hoveringElement));
				pointer.hoveringElement = gameObject2;
				pointer.pointerEventData.pointerCurrentRaycast = result2;
				pointer.pointerEventData.pointerEnter = gameObject2;
				pointer.pointerEventData.hovered.Add(pointer.pointerEventData.pointerEnter);
				break;
			}
			if (result2.gameObject != pointer.hoveringElement)
			{
				pointer.OnUIPointerElementEnter(pointer.SetUIPointerEvent(result2, result2.gameObject, pointer.hoveringElement));
			}
			pointer.hoveringElement = result2.gameObject;
		}
		if ((bool)pointer.hoveringElement && results.Count == 0)
		{
			pointer.OnUIPointerElementExit(pointer.SetUIPointerEvent(default(RaycastResult), null, pointer.hoveringElement));
			pointer.hoveringElement = null;
		}
	}

	protected virtual void Click(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		switch (pointer.clickMethod)
		{
		case Pvr_UIPointer.ClickMethods.ClickOnButtonUp:
			ClickOnUp(pointer, results);
			break;
		case Pvr_UIPointer.ClickMethods.ClickOnButtonDown:
			ClickOnDown(pointer, results);
			break;
		}
	}

	protected virtual void ClickOnUp(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		pointer.pointerEventData.eligibleForClick = pointer.ValidClick(checkLastClick: false);
		if (!AttemptClick(pointer))
		{
			IsEligibleClick(pointer, results);
		}
	}

	protected virtual void ClickOnDown(Pvr_UIPointer pointer, List<RaycastResult> results, bool forceClick = false)
	{
		pointer.pointerEventData.eligibleForClick = forceClick || pointer.ValidClick(checkLastClick: true);
		if (IsEligibleClick(pointer, results))
		{
			pointer.pointerEventData.eligibleForClick = false;
			AttemptClick(pointer);
		}
	}

	protected virtual bool IsEligibleClick(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		if (pointer.pointerEventData.eligibleForClick)
		{
			foreach (RaycastResult result in results)
			{
				if (ValidElement(result.gameObject))
				{
					GameObject gameObject = ExecuteEvents.ExecuteHierarchy(result.gameObject, pointer.pointerEventData, ExecuteEvents.pointerDownHandler);
					if (gameObject != null)
					{
						pointer.pointerEventData.pressPosition = pointer.pointerEventData.position;
						pointer.pointerEventData.pointerPressRaycast = result;
						pointer.pointerEventData.pointerPress = gameObject;
						return true;
					}
				}
			}
		}
		return false;
	}

	protected virtual bool AttemptClick(Pvr_UIPointer pointer)
	{
		if ((bool)pointer.pointerEventData.pointerPress)
		{
			if (!ValidElement(pointer.pointerEventData.pointerPress))
			{
				pointer.pointerEventData.pointerPress = null;
				return true;
			}
			if (pointer.pointerEventData.eligibleForClick)
			{
				if (!IsHovering(pointer))
				{
					ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerPress, pointer.pointerEventData, ExecuteEvents.pointerUpHandler);
					pointer.pointerEventData.pointerPress = null;
				}
			}
			else
			{
				pointer.OnUIPointerElementClick(pointer.SetUIPointerEvent(pointer.pointerEventData.pointerPressRaycast, pointer.pointerEventData.pointerPress));
				ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerPress, pointer.pointerEventData, ExecuteEvents.pointerClickHandler);
				ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerPress, pointer.pointerEventData, ExecuteEvents.pointerUpHandler);
				pointer.pointerEventData.pointerPress = null;
			}
			return true;
		}
		return false;
	}

	protected virtual void Drag(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		pointer.pointerEventData.dragging = pointer.IsSelectionButtonPressed() && pointer.pointerEventData.delta != Vector2.zero;
		if ((bool)pointer.pointerEventData.pointerDrag)
		{
			if (!ValidElement(pointer.pointerEventData.pointerDrag))
			{
				pointer.pointerEventData.pointerDrag = null;
				return;
			}
			if (pointer.pointerEventData.dragging)
			{
				if (IsHovering(pointer))
				{
					ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerDrag, pointer.pointerEventData, ExecuteEvents.dragHandler);
				}
				return;
			}
			ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerDrag, pointer.pointerEventData, ExecuteEvents.dragHandler);
			ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerDrag, pointer.pointerEventData, ExecuteEvents.endDragHandler);
			foreach (RaycastResult result in results)
			{
				ExecuteEvents.ExecuteHierarchy(result.gameObject, pointer.pointerEventData, ExecuteEvents.dropHandler);
			}
			pointer.pointerEventData.pointerDrag = null;
		}
		else
		{
			if (!pointer.pointerEventData.dragging)
			{
				return;
			}
			foreach (RaycastResult result2 in results)
			{
				if (ValidElement(result2.gameObject))
				{
					ExecuteEvents.ExecuteHierarchy(result2.gameObject, pointer.pointerEventData, ExecuteEvents.initializePotentialDrag);
					ExecuteEvents.ExecuteHierarchy(result2.gameObject, pointer.pointerEventData, ExecuteEvents.beginDragHandler);
					GameObject gameObject = ExecuteEvents.ExecuteHierarchy(result2.gameObject, pointer.pointerEventData, ExecuteEvents.dragHandler);
					if (gameObject != null)
					{
						pointer.pointerEventData.pointerDrag = gameObject;
						break;
					}
				}
			}
		}
	}
}
public class Pvr_UICanvas : MonoBehaviour
{
	public bool clickOnPointerCollision;

	public float autoActivateWithinDistance;

	protected BoxCollider canvasBoxCollider;

	protected Rigidbody canvasRigidBody;

	protected Coroutine draggablePanelCreation;

	protected const string CANVAS_DRAGGABLE_PANEL = "UICANVAS_DRAGGABLE_PANEL";

	protected virtual void OnEnable()
	{
		SetupCanvas();
	}

	protected virtual void OnDisable()
	{
		RemoveCanvas();
	}

	protected virtual void OnDestroy()
	{
		RemoveCanvas();
	}

	protected virtual void SetupCanvas()
	{
		Canvas component = GetComponent<Canvas>();
		if ((bool)component && component.renderMode == RenderMode.WorldSpace)
		{
			RectTransform component2 = component.GetComponent<RectTransform>();
			Vector2 sizeDelta = component2.sizeDelta;
			GraphicRaycaster component3 = component.gameObject.GetComponent<GraphicRaycaster>();
			Pvr_UIGraphicRaycaster pvr_UIGraphicRaycaster = component.gameObject.GetComponent<Pvr_UIGraphicRaycaster>();
			if (!pvr_UIGraphicRaycaster)
			{
				pvr_UIGraphicRaycaster = component.gameObject.AddComponent<Pvr_UIGraphicRaycaster>();
			}
			if ((bool)component3 && component3.enabled)
			{
				pvr_UIGraphicRaycaster.ignoreReversedGraphics = component3.ignoreReversedGraphics;
				pvr_UIGraphicRaycaster.blockingObjects = component3.blockingObjects;
				component3.enabled = false;
			}
			if (!component.gameObject.GetComponent<BoxCollider>())
			{
				float num = 0.1f;
				float z = num / component2.localScale.z;
				canvasBoxCollider = component.gameObject.AddComponent<BoxCollider>();
				canvasBoxCollider.size = new Vector3(sizeDelta.x, sizeDelta.y, z);
				canvasBoxCollider.isTrigger = true;
			}
			if (!component.gameObject.GetComponent<Rigidbody>())
			{
				canvasRigidBody = component.gameObject.AddComponent<Rigidbody>();
				canvasRigidBody.isKinematic = true;
			}
			draggablePanelCreation = StartCoroutine(CreateDraggablePanel(component, sizeDelta));
		}
	}

	protected virtual IEnumerator CreateDraggablePanel(Canvas canvas, Vector2 canvasSize)
	{
		if ((bool)canvas && !canvas.transform.Find("UICANVAS_DRAGGABLE_PANEL"))
		{
			yield return null;
			GameObject draggablePanel = new GameObject("UICANVAS_DRAGGABLE_PANEL", typeof(RectTransform));
			draggablePanel.AddComponent<LayoutElement>().ignoreLayout = true;
			draggablePanel.AddComponent<Image>().color = Color.clear;
			draggablePanel.AddComponent<EventTrigger>();
			draggablePanel.transform.SetParent(canvas.transform);
			draggablePanel.GetComponent<RectTransform>().sizeDelta = canvasSize;
			draggablePanel.transform.localPosition = Vector3.zero;
			draggablePanel.transform.localRotation = Quaternion.identity;
			draggablePanel.transform.localScale = Vector3.one;
			draggablePanel.transform.SetAsFirstSibling();
		}
	}

	protected virtual void RemoveCanvas()
	{
		Canvas component = GetComponent<Canvas>();
		if ((bool)component)
		{
			GraphicRaycaster component2 = component.gameObject.GetComponent<GraphicRaycaster>();
			Pvr_UIGraphicRaycaster component3 = component.gameObject.GetComponent<Pvr_UIGraphicRaycaster>();
			if ((bool)component3)
			{
				UnityEngine.Object.Destroy(component3);
			}
			if ((bool)component2 && !component2.enabled)
			{
				component2.enabled = true;
			}
			if ((bool)canvasBoxCollider)
			{
				UnityEngine.Object.Destroy(canvasBoxCollider);
			}
			if ((bool)canvasRigidBody)
			{
				UnityEngine.Object.Destroy(canvasRigidBody);
			}
			StopCoroutine(draggablePanelCreation);
			Transform transform = component.transform.Find("UICANVAS_DRAGGABLE_PANEL");
			if ((bool)transform)
			{
				UnityEngine.Object.Destroy(transform.gameObject);
			}
		}
	}
}
public struct UIDraggableItemEventArgs
{
	public GameObject target;
}
public delegate void UIDraggableItemEventHandler(object sender, UIDraggableItemEventArgs e);
public class Pvr_UIDraggableItem : MonoBehaviour, IBeginDragHandler, IDragHandler, IEndDragHandler, IEventSystemHandler
{
	public bool restrictToDropZone;

	public bool restrictToOriginalCanvas;

	public float moveOffset = 0.1f;

	[HideInInspector]
	public GameObject validDropZone;

	[CompilerGenerated]
	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private UIDraggableItemEventHandler m_DraggableItemDropped;

	[CompilerGenerated]
	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private UIDraggableItemEventHandler m_DraggableItemReset;

	protected RectTransform dragTransform;

	protected Vector3 startPosition;

	protected Quaternion startRotation;

	protected GameObject startDropZone;

	protected Transform startParent;

	protected Canvas startCanvas;

	protected CanvasGroup canvasGroup;

	protected Pvr_InputModule currentInputmodule;

	public event UIDraggableItemEventHandler DraggableItemDropped
	{
		add
		{
			UIDraggableItemEventHandler uIDraggableItemEventHandler = this.m_DraggableItemDropped;
			UIDraggableItemEventHandler uIDraggableItemEventHandler2;
			do
			{
				uIDraggableItemEventHandler2 = uIDraggableItemEventHandler;
				uIDraggableItemEventHandler = Interlocked.CompareExchange(ref this.m_DraggableItemDropped, (UIDraggableItemEventHandler)Delegate.Combine(uIDraggableItemEventHandler2, value), uIDraggableItemEventHandler);
			}
			while (uIDraggableItemEventHandler != uIDraggableItemEventHandler2);
		}
		remove
		{
			UIDraggableItemEventHandler uIDraggableItemEventHandler = this.m_DraggableItemDropped;
			UIDraggableItemEventHandler uIDraggableItemEventHandler2;
			do
			{
				uIDraggableItemEventHandler2 = uIDraggableItemEventHandler;
				uIDraggableItemEventHandler = Interlocked.CompareExchange(ref this.m_DraggableItemDropped, (UIDraggableItemEventHandler)Delegate.Remove(uIDraggableItemEventHandler2, value), uIDraggableItemEventHandler);
			}
			while (uIDraggableItemEventHandler != uIDraggableItemEventHandler2);
		}
	}

	public event UIDraggableItemEventHandler DraggableItemReset
	{
		add
		{
			UIDraggableItemEventHandler uIDraggableItemEventHandler = this.m_DraggableItemReset;
			UIDraggableItemEventHandler uIDraggableItemEventHandler2;
			do
			{
				uIDraggableItemEventHandler2 = uIDraggableItemEventHandler;
				uIDraggableItemEventHandler = Interlocked.CompareExchange(ref this.m_DraggableItemReset, (UIDraggableItemEventHandler)Delegate.Combine(uIDraggableItemEventHandler2, value), uIDraggableItemEventHandler);
			}
			while (uIDraggableItemEventHandler != uIDraggableItemEventHandler2);
		}
		remove
		{
			UIDraggableItemEventHandler uIDraggableItemEventHandler = this.m_DraggableItemReset;
			UIDraggableItemEventHandler uIDraggableItemEventHandler2;
			do
			{
				uIDraggableItemEventHandler2 = uIDraggableItemEventHandler;
				uIDraggableItemEventHandler = Interlocked.CompareExchange(ref this.m_DraggableItemReset, (UIDraggableItemEventHandler)Delegate.Remove(uIDraggableItemEventHandler2, value), uIDraggableItemEventHandler);
			}
			while (uIDraggableItemEventHandler != uIDraggableItemEventHandler2);
		}
	}

	public virtual void OnDraggableItemDropped(UIDraggableItemEventArgs e)
	{
		if (this.DraggableItemDropped != null)
		{
			this.DraggableItemDropped(this, e);
		}
	}

	public virtual void OnDraggableItemReset(UIDraggableItemEventArgs e)
	{
		if (this.DraggableItemReset != null)
		{
			this.DraggableItemReset(this, e);
		}
	}

	public void OnBeginDrag(PointerEventData eventData)
	{
		startPosition = base.transform.position;
		startRotation = base.transform.rotation;
		startParent = base.transform.parent;
		startCanvas = GetComponentInParent<Canvas>();
		canvasGroup.blocksRaycasts = false;
		if (restrictToDropZone)
		{
			startDropZone = GetComponentInParent<Pvr_UIDropZone>().gameObject;
			validDropZone = startDropZone;
		}
		SetDragPosition(eventData);
		Pvr_UIPointer pointer = GetPointer();
		if (pointer != null)
		{
			pointer.OnUIPointerElementDragStart(pointer.SetUIPointerEvent(pointer.pointerEventData.pointerPressRaycast, base.gameObject));
		}
	}

	public void OnDrag(PointerEventData eventData)
	{
		SetDragPosition(eventData);
	}

	public void OnEndDrag(PointerEventData eventData)
	{
		canvasGroup.blocksRaycasts = true;
		dragTransform = null;
		base.transform.position += base.transform.forward * moveOffset;
		bool flag = true;
		if (restrictToDropZone)
		{
			if (validDropZone != null && validDropZone != startDropZone)
			{
				base.transform.SetParent(validDropZone.transform);
			}
			else
			{
				ResetElement();
				flag = false;
			}
		}
		Canvas canvas = ((!(eventData.pointerEnter != null)) ? null : eventData.pointerEnter.GetComponentInParent<Canvas>());
		if (restrictToOriginalCanvas && canvas != null && canvas != startCanvas)
		{
			ResetElement();
			flag = false;
		}
		if (canvas == null)
		{
			ResetElement();
			flag = false;
		}
		if (flag)
		{
			Pvr_UIPointer pointer = GetPointer();
			if (pointer != null)
			{
				pointer.OnUIPointerElementDragEnd(pointer.SetUIPointerEvent(pointer.pointerEventData.pointerPressRaycast, base.gameObject));
			}
			OnDraggableItemDropped(SetEventPayload(validDropZone));
		}
		validDropZone = null;
		startParent = null;
		startCanvas = null;
	}

	protected virtual void OnEnable()
	{
		canvasGroup = GetComponent<CanvasGroup>();
		if (restrictToDropZone && GetComponentInParent<Pvr_UIDropZone>() == null)
		{
			base.enabled = false;
		}
		currentInputmodule = UnityEngine.Object.FindObjectOfType<Pvr_InputModule>();
	}

	protected virtual Pvr_UIPointer GetPointer()
	{
		foreach (Pvr_UIPointer pointer in Pvr_InputModule.pointers)
		{
			if (pointer.gameObject.activeInHierarchy && (bool)pointer)
			{
				return pointer;
			}
		}
		return null;
	}

	protected virtual void SetDragPosition(PointerEventData eventData)
	{
		if (eventData.pointerEnter != null && eventData.pointerEnter.transform as RectTransform != null)
		{
			dragTransform = eventData.pointerEnter.transform as RectTransform;
		}
		if (dragTransform != null && RectTransformUtility.ScreenPointToWorldPointInRectangle(dragTransform, eventData.position, eventData.pressEventCamera, out var worldPoint))
		{
			base.transform.position = worldPoint - base.transform.forward * moveOffset;
			base.transform.rotation = dragTransform.rotation;
		}
	}

	protected virtual void ResetElement()
	{
		base.transform.position = startPosition;
		base.transform.rotation = startRotation;
		base.transform.SetParent(startParent);
		OnDraggableItemReset(SetEventPayload(startParent.gameObject));
	}

	protected virtual UIDraggableItemEventArgs SetEventPayload(GameObject target)
	{
		UIDraggableItemEventArgs result = default(UIDraggableItemEventArgs);
		result.target = target;
		return result;
	}
}
public class Pvr_UIDropZone : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler, IEventSystemHandler
{
	protected Pvr_UIDraggableItem droppableItem;

	public void OnPointerEnter(PointerEventData eventData)
	{
		if ((bool)eventData.pointerDrag)
		{
			Pvr_UIDraggableItem component = eventData.pointerDrag.GetComponent<Pvr_UIDraggableItem>();
			if ((bool)component && component.restrictToDropZone)
			{
				component.validDropZone = base.gameObject;
				droppableItem = component;
			}
		}
	}

	public void OnPointerExit(PointerEventData eventData)
	{
		if ((bool)droppableItem)
		{
			droppableItem.validDropZone = null;
		}
		droppableItem = null;
	}
}
public class Pvr_UIGraphicRaycaster : GraphicRaycaster
{
	protected Canvas currentCanvas;

	protected Vector2 lastKnownPosition;

	protected const float UI_CONTROL_OFFSET = 1E-05f;

	[NonSerialized]
	private static List<RaycastResult> s_RaycastResults = new List<RaycastResult>();

	protected virtual Canvas canvas
	{
		get
		{
			if (currentCanvas != null)
			{
				return currentCanvas;
			}
			currentCanvas = base.gameObject.GetComponent<Canvas>();
			return currentCanvas;
		}
	}

	public override void Raycast(PointerEventData eventData, List<RaycastResult> resultAppendList)
	{
		if (!(canvas == null))
		{
			Ray ray = new Ray(eventData.pointerCurrentRaycast.worldPosition, eventData.pointerCurrentRaycast.worldNormal);
			Raycast(canvas, eventCamera, ray, ref s_RaycastResults);
			SetNearestRaycast(ref eventData, ref resultAppendList, ref s_RaycastResults);
			s_RaycastResults.Clear();
		}
	}

	protected virtual void SetNearestRaycast(ref PointerEventData eventData, ref List<RaycastResult> resultAppendList, ref List<RaycastResult> raycastResults)
	{
		RaycastResult? raycastResult = null;
		for (int i = 0; i < raycastResults.Count; i++)
		{
			RaycastResult raycastResult2 = raycastResults[i];
			raycastResult2.index = resultAppendList.Count;
			if (!raycastResult.HasValue || raycastResult2.distance < raycastResult.Value.distance)
			{
				raycastResult = raycastResult2;
			}
			resultAppendList.Add(raycastResult2);
		}
		if (raycastResult.HasValue)
		{
			eventData.position = raycastResult.Value.screenPosition;
			eventData.delta = eventData.position - lastKnownPosition;
			lastKnownPosition = eventData.position;
			eventData.pointerCurrentRaycast = raycastResult.Value;
		}
	}

	protected virtual float GetHitDistance(Ray ray)
	{
		float result = float.MaxValue;
		if (canvas.renderMode != 0 && base.blockingObjects != 0)
		{
			float num = Vector3.Distance(ray.origin, canvas.transform.position);
			if (base.blockingObjects == BlockingObjects.ThreeD || base.blockingObjects == BlockingObjects.All)
			{
				Physics.Raycast(ray, out var hitInfo, num);
				if ((bool)hitInfo.collider)
				{
					result = hitInfo.distance;
				}
			}
			if (base.blockingObjects == BlockingObjects.TwoD || base.blockingObjects == BlockingObjects.All)
			{
				RaycastHit2D raycastHit2D = Physics2D.Raycast(ray.origin, ray.direction, num);
				if (raycastHit2D.collider != null)
				{
					result = raycastHit2D.fraction * num;
				}
			}
		}
		return result;
	}

	protected virtual void Raycast(Canvas canvas, Camera eventCamera, Ray ray, ref List<RaycastResult> results)
	{
		float hitDistance = GetHitDistance(ray);
		IList<Graphic> graphicsForCanvas = GraphicRegistry.GetGraphicsForCanvas(canvas);
		for (int i = 0; i < graphicsForCanvas.Count; i++)
		{
			Graphic graphic = graphicsForCanvas[i];
			if (graphic.depth == -1 || !graphic.raycastTarget)
			{
				continue;
			}
			Transform transform = graphic.transform;
			Vector3 forward = transform.forward;
			float num = Vector3.Dot(forward, transform.position - ray.origin) / Vector3.Dot(forward, ray.direction);
			if (!(num < 0f) && !(num - 1E-05f > hitDistance))
			{
				Vector3 point = ray.GetPoint(num);
				Vector2 vector = eventCamera.WorldToScreenPoint(point);
				if (RectTransformUtility.RectangleContainsScreenPoint(graphic.rectTransform, vector, eventCamera) && graphic.Raycast(vector, eventCamera))
				{
					RaycastResult raycastResult = default(RaycastResult);
					raycastResult.gameObject = graphic.gameObject;
					raycastResult.module = this;
					raycastResult.distance = num;
					raycastResult.screenPosition = vector;
					raycastResult.worldPosition = point;
					raycastResult.depth = graphic.depth;
					raycastResult.sortingLayer = canvas.sortingLayerID;
					raycastResult.sortingOrder = canvas.sortingOrder;
					RaycastResult item = raycastResult;
					results.Add(item);
				}
			}
		}
		results.Sort((RaycastResult g1, RaycastResult g2) => g2.depth.CompareTo(g1.depth));
	}
}
public struct UIPointerEventArgs
{
	public bool isActive;

	public GameObject currentTarget;

	public GameObject previousTarget;

	public RaycastResult raycastResult;
}
public delegate void UIPointerEventHandler(object sender, UIPointerEventArgs e);
public class Pvr_UIPointer : MonoBehaviour
{
	public enum ClickMethods
	{
		ClickOnButtonUp,
		ClickOnButtonDown
	}

	public ClickMethods clickMethod;

	[HideInInspector]
	public bool collisionClick;

	[HideInInspector]
	public bool pressToDrag;

	[HideInInspector]
	public GameObject autoActivatingCanvas;

	[HideInInspector]
	public PointerEventData pointerEventData;

	[HideInInspector]
	public GameObject hoveringElement;

	[HideInInspector]
	public float hoverDurationTimer;

	[HideInInspector]
	public bool canClickOnHover;

	public Transform pointerOriginTransform;

	protected bool pointerClicked;

	protected bool beamEnabledState;

	protected bool lastPointerPressState;

	protected bool lastPointerClickState;

	protected GameObject currentTarget;

	protected EventSystem cachedEventSystem;

	protected Pvr_InputModule cachedVRInputModule;

	protected Transform originalPointerOriginTransform;

	[CompilerGenerated]
	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private UIPointerEventHandler m_UIPointerElementEnter;

	[CompilerGenerated]
	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private UIPointerEventHandler m_UIPointerElementExit;

	[CompilerGenerated]
	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private UIPointerEventHandler m_UIPointerElementClick;

	[CompilerGenerated]
	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private UIPointerEventHandler m_UIPointerElementDragStart;

	[CompilerGenerated]
	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private UIPointerEventHandler m_UIPointerElementDragEnd;

	public static bool TouchBtnValue;

	public static bool AppBtnValue;

	public static bool TriggerBtnValue;

	public event UIPointerEventHandler UIPointerElementEnter
	{
		add
		{
			UIPointerEventHandler uIPointerEventHandler = this.m_UIPointerElementEnter;
			UIPointerEventHandler uIPointerEventHandler2;
			do
			{
				uIPointerEventHandler2 = uIPointerEventHandler;
				uIPointerEventHandler = Interlocked.CompareExchange(ref this.m_UIPointerElementEnter, (UIPointerEventHandler)Delegate.Combine(uIPointerEventHandler2, value), uIPointerEventHandler);
			}
			while (uIPointerEventHandler != uIPointerEventHandler2);
		}
		remove
		{
			UIPointerEventHandler uIPointerEventHandler = this.m_UIPointerElementEnter;
			UIPointerEventHandler uIPointerEventHandler2;
			do
			{
				uIPointerEventHandler2 = uIPointerEventHandler;
				uIPointerEventHandler = Interlocked.CompareExchange(ref this.m_UIPointerElementEnter, (UIPointerEventHandler)Delegate.Remove(uIPointerEventHandler2, value), uIPointerEventHandler);
			}
			while (uIPointerEventHandler != uIPointerEventHandler2);
		}
	}

	public event UIPointerEventHandler UIPointerElementExit
	{
		add
		{
			UIPointerEventHandler uIPointerEventHandler = this.m_UIPointerElementExit;
			UIPointerEventHandler uIPointerEventHandler2;
			do
			{
				uIPointerEventHandler2 = uIPointerEventHandler;
				uIPointerEventHandler = Interlocked.CompareExchange(ref this.m_UIPointerElementExit, (UIPointerEventHandler)Delegate.Combine(uIPointerEventHandler2, value), uIPointerEventHandler);
			}
			while (uIPointerEventHandler != uIPointerEventHandler2);
		}
		remove
		{
			UIPointerEventHandler uIPointerEventHandler = this.m_UIPointerElementExit;
			UIPointerEventHandler uIPointerEventHandler2;
			do
			{
				uIPointerEventHandler2 = uIPointerEventHandler;
				uIPointerEventHandler = Interlocked.CompareExchange(ref this.m_UIPointerElementExit, (UIPointerEventHandler)Delegate.Remove(uIPointerEventHandler2, value), uIPointerEventHandler);
			}
			while (uIPointerEventHandler != uIPointerEventHandler2);
		}
	}

	public event UIPointerEventHandler UIPointerElementClick
	{
		add
		{
			UIPointerEventHandler uIPointerEventHandler = this.m_UIPointerElementClick;
			UIPointerEventHandler uIPointerEventHandler2;
			do
			{
				uIPointerEventHandler2 = uIPointerEventHandler;
				uIPointerEventHandler = Interlocked.CompareExchange(ref this.m_UIPointerElementClick, (UIPointerEventHandler)Delegate.Combine(uIPointerEventHandler2, value), uIPointerEventHandler);
			}
			while (uIPointerEventHandler != uIPointerEventHandler2);
		}
		remove
		{
			UIPointerEventHandler uIPointerEventHandler = this.m_UIPointerElementClick;
			UIPointerEventHandler uIPointerEventHandler2;
			do
			{
				uIPointerEventHandler2 = uIPointerEventHandler;
				uIPointerEventHandler = Interlocked.CompareExchange(ref this.m_UIPointerElementClick, (UIPointerEventHandler)Delegate.Remove(uIPointerEventHandler2, value), uIPointerEventHandler);
			}
			while (uIPointerEventHandler != uIPointerEventHandler2);
		}
	}

	public event UIPointerEventHandler UIPointerElementDragStart
	{
		add
		{
			UIPointerEventHandler uIPointerEventHandler = this.m_UIPointerElementDragStart;
			UIPointerEventHandler uIPointerEventHandler2;
			do
			{
				uIPointerEventHandler2 = uIPointerEventHandler;
				uIPointerEventHandler = Interlocked.CompareExchange(ref this.m_UIPointerElementDragStart, (UIPointerEventHandler)Delegate.Combine(uIPointerEventHandler2, value), uIPointerEventHandler);
			}
			while (uIPointerEventHandler != uIPointerEventHandler2);
		}
		remove
		{
			UIPointerEventHandler uIPointerEventHandler = this.m_UIPointerElementDragStart;
			UIPointerEventHandler uIPointerEventHandler2;
			do
			{
				uIPointerEventHandler2 = uIPointerEventHandler;
				uIPointerEventHandler = Interlocked.CompareExchange(ref this.m_UIPointerElementDragStart, (UIPointerEventHandler)Delegate.Remove(uIPointerEventHandler2, value), uIPointerEventHandler);
			}
			while (uIPointerEventHandler != uIPointerEventHandler2);
		}
	}

	public event UIPointerEventHandler UIPointerElementDragEnd
	{
		add
		{
			UIPointerEventHandler uIPointerEventHandler = this.m_UIPointerElementDragEnd;
			UIPointerEventHandler uIPointerEventHandler2;
			do
			{
				uIPointerEventHandler2 = uIPointerEventHandler;
				uIPointerEventHandler = Interlocked.CompareExchange(ref this.m_UIPointerElementDragEnd, (UIPointerEventHandler)Delegate.Combine(uIPointerEventHandler2, value), uIPointerEventHandler);
			}
			while (uIPointerEventHandler != uIPointerEventHandler2);
		}
		remove
		{
			UIPointerEventHandler uIPointerEventHandler = this.m_UIPointerElementDragEnd;
			UIPointerEventHandler uIPointerEventHandler2;
			do
			{
				uIPointerEventHandler2 = uIPointerEventHandler;
				uIPointerEventHandler = Interlocked.CompareExchange(ref this.m_UIPointerElementDragEnd, (UIPointerEventHandler)Delegate.Remove(uIPointerEventHandler2, value), uIPointerEventHandler);
			}
			while (uIPointerEventHandler != uIPointerEventHandler2);
		}
	}

	public virtual bool PointerActive()
	{
		return true;
	}

	public virtual bool IsSelectionButtonPressed()
	{
		return Input.GetMouseButton(0) || Input.GetKey(KeyCode.JoystickButton0) || TouchBtnValue || AppBtnValue || TriggerBtnValue;
	}

	public virtual Vector3 GetOriginPosition()
	{
		return (!pointerOriginTransform) ? base.transform.position : pointerOriginTransform.position;
	}

	public virtual Vector3 GetOriginForward()
	{
		return (!pointerOriginTransform) ? base.transform.forward : pointerOriginTransform.forward;
	}

	public virtual bool ValidClick(bool checkLastClick, bool lastClickState = false)
	{
		bool flag = ((!collisionClick) ? IsSelectionButtonPressed() : collisionClick);
		return (!checkLastClick) ? flag : flag;
	}

	protected virtual void ResetHoverTimer()
	{
		hoverDurationTimer = 0f;
		canClickOnHover = false;
	}

	public virtual void OnUIPointerElementEnter(UIPointerEventArgs e)
	{
		if (e.currentTarget != currentTarget)
		{
			ResetHoverTimer();
		}
		currentTarget = e.currentTarget;
		if (this.UIPointerElementEnter != null)
		{
			this.UIPointerElementEnter(this, e);
		}
	}

	public virtual void OnUIPointerElementExit(UIPointerEventArgs e)
	{
		if (e.previousTarget == currentTarget)
		{
			ResetHoverTimer();
		}
		if (this.UIPointerElementExit != null)
		{
			this.UIPointerElementExit(this, e);
		}
	}

	public virtual void OnUIPointerElementClick(UIPointerEventArgs e)
	{
		if (e.currentTarget == currentTarget)
		{
			ResetHoverTimer();
		}
		if (this.UIPointerElementClick != null)
		{
			this.UIPointerElementClick(this, e);
		}
	}

	public virtual void OnUIPointerElementDragStart(UIPointerEventArgs e)
	{
		if (this.UIPointerElementDragStart != null)
		{
			this.UIPointerElementDragStart(this, e);
		}
	}

	public virtual void OnUIPointerElementDragEnd(UIPointerEventArgs e)
	{
		if (this.UIPointerElementDragEnd != null)
		{
			this.UIPointerElementDragEnd(this, e);
		}
	}

	public virtual UIPointerEventArgs SetUIPointerEvent(RaycastResult currentRaycastResult, GameObject currentTarget, GameObject lastTarget = null)
	{
		UIPointerEventArgs result = default(UIPointerEventArgs);
		result.isActive = PointerActive();
		result.currentTarget = currentTarget;
		result.previousTarget = lastTarget;
		result.raycastResult = currentRaycastResult;
		return result;
	}

	protected virtual void Awake()
	{
		originalPointerOriginTransform = pointerOriginTransform;
	}

	protected virtual void OnEnable()
	{
		pointerOriginTransform = originalPointerOriginTransform;
		ConfigureEventSystem();
		pointerClicked = false;
		lastPointerPressState = false;
		lastPointerClickState = false;
		beamEnabledState = false;
	}

	protected virtual void OnDisable()
	{
		Pvr_InputModule.RemovePoint(this);
	}

	protected virtual void ConfigureEventSystem()
	{
		if (!cachedEventSystem)
		{
			cachedEventSystem = UnityEngine.Object.FindObjectOfType<EventSystem>();
		}
		if (!cachedVRInputModule)
		{
			cachedVRInputModule = cachedEventSystem.GetComponent<Pvr_InputModule>();
		}
		if ((bool)cachedEventSystem && (bool)cachedVRInputModule && pointerEventData == null)
		{
			pointerEventData = new PointerEventData(cachedEventSystem);
		}
		Pvr_InputModule.AddPoint(this);
	}
}
[ExecuteInEditMode]
public class Pvr_UnitySDKEditor : MonoBehaviour
{
	private bool vrModeEnabled = true;

	private float mouseX;

	private float mouseY;

	private float mouseZ;

	private float neckModelScale;

	private bool autoUntiltHead;

	private static readonly Vector3 neckOffset = new Vector3(0f, 0.075f, 0.0805f);

	[HideInInspector]
	public Matrix4x4 headView;

	[HideInInspector]
	public Matrix4x4 leftEyeUndistortedProj;

	[HideInInspector]
	public Matrix4x4 rightEyeUndistortedProj;

	[HideInInspector]
	public Matrix4x4 leftEyeProj;

	[HideInInspector]
	public Matrix4x4 rightEyeProj;

	private const float TOUCH_TIME_LIMIT = 0.2f;

	private float touchStartTime;

	public Matrix4x4 UndistortedProjection(Eye eye)
	{
		return (eye != 0) ? rightEyeUndistortedProj : leftEyeUndistortedProj;
	}

	public Matrix4x4 Projection(Eye eye)
	{
		return (eye != 0) ? rightEyeProj : leftEyeProj;
	}

	private void Awake()
	{
		InitEyePara();
		InitEditorSensorPara();
	}

	private void Update()
	{
		SimulateInput();
		Pvr_UnitySDKManager.SDK.picovrTriggered = Pvr_UnitySDKManager.SDK.newPicovrTriggered;
		Pvr_UnitySDKManager.SDK.newPicovrTriggered = false;
	}

	public void InitEyePara()
	{
		ComputeEyesFromProfile();
		InitForEye(ref Pvr_UnitySDKManager.SDK.Eyematerial, ref Pvr_UnitySDKManager.SDK.Middlematerial);
		if (Pvr_UnitySDKRender.Instance == null)
		{
			PLOG.I("pvr_UnitySDKRender init failed");
		}
		if (Pvr_UnitySDKSensor.Instance == null)
		{
			PLOG.I("pvr_UnitySDKSensor init failed");
		}
		FovAdjust();
	}

	private void InitEditorSensorPara()
	{
		Pvr_UnitySDKManager.SDK.picovrTriggered = Pvr_UnitySDKManager.SDK.newPicovrTriggered;
		Pvr_UnitySDKManager.SDK.newPicovrTriggered = false;
	}

	public static Matrix4x4 MakeProjection(float l, float t, float r, float b, float n, float f)
	{
		Matrix4x4 zero = Matrix4x4.zero;
		zero[0, 0] = 2f * n / (r - l);
		zero[1, 1] = 2f * n / (t - b);
		zero[0, 2] = (r + l) / (r - l);
		zero[1, 2] = (t + b) / (t - b);
		zero[2, 2] = (n + f) / (n - f);
		zero[2, 3] = 2f * n * f / (n - f);
		zero[3, 2] = -1f;
		return zero;
	}

	public bool UpdateStatesensor()
	{
		UpdateSimulatedSensor();
		return true;
	}

	public void ComputeEyesFromProfile()
	{
		Vector2 vector = new Vector2(0.11f, 0.062f);
		Pvr_UnitySDKManager.SDK.leftEyeView = Matrix4x4.identity;
		Pvr_UnitySDKManager.SDK.leftEyeView[0, 3] = (0f - Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.device.devLenses.separation) / 2f;
		float[] leftEyeVisibleTanAngles = Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.GetLeftEyeVisibleTanAngles(vector.x, vector.y);
		leftEyeProj = MakeProjection(leftEyeVisibleTanAngles[0], leftEyeVisibleTanAngles[1], leftEyeVisibleTanAngles[2], leftEyeVisibleTanAngles[3], 1f, 1000f);
		leftEyeVisibleTanAngles = Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.GetLeftEyeNoLensTanAngles(vector.x, vector.y);
		leftEyeUndistortedProj = MakeProjection(leftEyeVisibleTanAngles[0], leftEyeVisibleTanAngles[1], leftEyeVisibleTanAngles[2], leftEyeVisibleTanAngles[3], 1f, 1000f);
		Pvr_UnitySDKManager.SDK.leftEyeRect = Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.GetLeftEyeVisibleScreenRect(leftEyeVisibleTanAngles, vector.x, vector.y);
		Pvr_UnitySDKManager.SDK.rightEyeView = Pvr_UnitySDKManager.SDK.leftEyeView;
		Pvr_UnitySDKManager.SDK.rightEyeView[0, 3] *= -1f;
		rightEyeProj = leftEyeProj;
		rightEyeProj[0, 2] *= -1f;
		rightEyeUndistortedProj = leftEyeUndistortedProj;
		rightEyeUndistortedProj[0, 2] *= -1f;
		Rect leftEyeRect = new Rect(0f, 0f, 0.5f, 1f);
		Rect rightEyeRect = new Rect(0.5f, 0f, 0.5f, 1f);
		Pvr_UnitySDKManager.SDK.leftEyeRect = leftEyeRect;
		Pvr_UnitySDKManager.SDK.rightEyeRect = rightEyeRect;
		Pvr_UnitySDKManager.SDK.leftEyeOffset = new Vector3((0f - Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.device.devLenses.separation) / 2f, 0f, 0f);
		Pvr_UnitySDKManager.SDK.rightEyeOffset = new Vector3(Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.device.devLenses.separation / 2f, 0f, 0f);
	}

	public bool ResetUnitySDKSensor()
	{
		mouseX = (mouseY = (mouseZ = 0f));
		return true;
	}

	private void SimulateInput()
	{
		if (Input.GetMouseButtonDown(0) && (Input.GetKey(KeyCode.LeftAlt) || Input.GetKey(KeyCode.RightAlt)))
		{
			EnableVEmodel();
		}
		if (Input.GetMouseButtonDown(0))
		{
			touchStartTime = Time.time;
		}
		else if (Input.GetMouseButtonUp(0))
		{
			if (Time.time - touchStartTime <= 0.2f)
			{
				Pvr_UnitySDKManager.SDK.newPicovrTriggered = true;
			}
			touchStartTime = 0f;
		}
		UpdateSimulatedSensor();
	}

	private void FovAdjust()
	{
		Pvr_UnitySDKRender.Instance.EyeVFoV = 2f * Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.device.devMaxFov.upper;
	}

	private Rect RectAdjust(Rect eyeRect)
	{
		Rect result = new Rect(0f, 0f, 0.5f, 1f);
		result.width *= 2f * eyeRect.width;
		result.x = eyeRect.x + 2f * result.x * eyeRect.width;
		result.height *= eyeRect.height;
		result.y = eyeRect.y + result.y * eyeRect.height;
		return result;
	}

	private void UpdateSimulatedSensor()
	{
		bool flag = false;
		if (Input.GetKey(KeyCode.LeftAlt) || Input.GetKey(KeyCode.RightAlt))
		{
			mouseX += Input.GetAxis("Mouse X") * 5f;
			if (mouseX <= -180f)
			{
				mouseX += 360f;
			}
			else if (mouseX > 180f)
			{
				mouseX -= 360f;
			}
			mouseY -= Input.GetAxis("Mouse Y") * 2.4f;
			mouseY = Mathf.Clamp(mouseY, -91f, 91f);
		}
		else if (Input.GetKey(KeyCode.LeftControl) || Input.GetKey(KeyCode.RightControl))
		{
			flag = true;
			mouseZ += Input.GetAxis("Mouse X") * 5f;
			mouseZ = Mathf.Clamp(mouseZ, -91f, 91f);
		}
		if (!flag && autoUntiltHead)
		{
			mouseZ = Mathf.Lerp(mouseZ, 0f, Time.deltaTime / (Time.deltaTime + 0.1f));
		}
		Quaternion quaternion = Quaternion.Euler(mouseY, mouseX, mouseZ);
		Vector3 vector = quaternion * neckOffset;
		Vector3 vector2 = neckOffset;
		Vector3 pos = (vector - vector2.y * Vector3.up) * neckModelScale;
		Matrix4x4 matrix = Matrix4x4.TRS(pos, quaternion, Vector3.one);
		Pvr_UnitySDKSensor.Instance.HeadPose = new Pvr_UnitySDKPose(matrix);
	}

	private void InitForEye(ref Material mat, ref Material mat1)
	{
		Shader shader = Shader.Find("Pvr_UnitySDK/Undistortion");
		Shader shader2 = Shader.Find("Pvr_UnitySDK/FillColor");
		if (shader == null || shader2 == null)
		{
			PLOG.E("Ths Shader Missing ");
			return;
		}
		mat = new Material(shader);
		mat1 = new Material(shader2);
	}

	private void EnableVEmodel()
	{
		vrModeEnabled = !vrModeEnabled;
		Pvr_UnitySDKManager.SDK.VRModeEnabled = vrModeEnabled;
	}
}
namespace Pvr_UnitySDKAPI
{
	public enum DeviceCommand
	{
		SET_PICO_NEO_HMD_BRIGHTNESS = 12,
		SET_PICO_NEO_HMD_SLEEPDELAY
	}
	public enum BrightnessLevel
	{
		VR_BRIGHTNESS_LEVEL_MIN = 1,
		VR_BRIGHTNESS_LEVEL_MAX = 100,
		VR_BRIGHTNESS_LEVEL_DOWN = 1000,
		VR_BRIGHTNESS_LEVEL_UP = 1001,
		VR_BRIGHTNESS_LEVEL_SCREEN_OFF = -100
	}
	public struct VolumePowerBrightness
	{
		public const string LibFileName = "Pvr_UnitySDK";

		public AndroidJavaObject activity;

		public static AndroidJavaClass javaSysActivityClass;

		private static AndroidJavaClass batteryjavaVrActivityClass;

		private static AndroidJavaClass volumejavaVrActivityClass;

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_SetInitActivity(IntPtr activity, IntPtr vrActivityClass);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_IsHmdExist();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetHmdScreenBrightness();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_SetHmdScreenBrightness(int brightness);

		public static bool UPvr_IsHmdExist()
		{
			return Pvr_IsHmdExist();
		}

		public static int UPvr_GetHmdScreenBrightness()
		{
			return Pvr_GetHmdScreenBrightness();
		}

		public static bool UPvr_SetHmdScreenBrightness(int brightness)
		{
			return Pvr_SetHmdScreenBrightness(brightness);
		}

		public static bool UPvr_SetCommonBrightness(int brightness)
		{
			bool flag = false;
			if (UPvr_IsHmdExist())
			{
				return UPvr_SetHmdScreenBrightness(brightness);
			}
			return UPvr_SetBrightness(brightness);
		}

		public static int UPvr_GetCommonBrightness()
		{
			int num = 0;
			if (UPvr_IsHmdExist())
			{
				return UPvr_GetHmdScreenBrightness();
			}
			return UPvr_GetCurrentBrightness();
		}

		public static int[] UPvr_GetScreenBrightnessLevel()
		{
			return Pvr_GetScreenBrightnessLevel();
		}

		public static void UPvr_SetScreenBrightnessLevel(int vrBrightness, int level)
		{
			Pvr_SetScreenBrightnessLevel(vrBrightness, level);
		}

		public static bool UPvr_SetDevicePropForUser(DeviceCommand deviceid, string number)
		{
			return setDevicePropForUser(deviceid, number);
		}

		public static string UPvr_GetDevicePropForUser(DeviceCommand deviceid)
		{
			return getDevicePropForUser(deviceid);
		}

		public static bool UPvr_InitBatteryClass()
		{
			try
			{
				if (javaSysActivityClass == null)
				{
					javaSysActivityClass = new AndroidJavaClass("com.psmart.aosoperation.SysActivity");
				}
				if (javaSysActivityClass != null && Pvr_UnitySDKRender.Instance.activity != null)
				{
					if (batteryjavaVrActivityClass == null)
					{
						batteryjavaVrActivityClass = new AndroidJavaClass("com.psmart.aosoperation.BatteryReceiver");
					}
					return true;
				}
				return false;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_InitBatteryVolClass()
		{
			try
			{
				javaSysActivityClass = new AndroidJavaClass("com.psmart.aosoperation.SysActivity");
				if (javaSysActivityClass != null && Pvr_UnitySDKRender.Instance.activity != null)
				{
					batteryjavaVrActivityClass = new AndroidJavaClass("com.psmart.aosoperation.BatteryReceiver");
					volumejavaVrActivityClass = new AndroidJavaClass("com.psmart.aosoperation.AudioReceiver");
					System.UPvr_CallStaticMethod(javaSysActivityClass, "Pvr_InitAudioDevice", Pvr_UnitySDKRender.Instance.activity);
					return true;
				}
				return false;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_StartBatteryReceiver(string startreceivre)
		{
			try
			{
				System.UPvr_CallStaticMethod(batteryjavaVrActivityClass, "Pvr_StartReceiver", Pvr_UnitySDKRender.Instance.activity, startreceivre);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_StopBatteryReceiver()
		{
			try
			{
				System.UPvr_CallStaticMethod(batteryjavaVrActivityClass, "Pvr_StopReceiver", Pvr_UnitySDKRender.Instance.activity);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_SetBrightness(int brightness)
		{
			try
			{
				System.UPvr_CallStaticMethod(javaSysActivityClass, "Pvr_SetScreen_Brightness", brightness, Pvr_UnitySDKRender.Instance.activity);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
				return false;
			}
		}

		public static int UPvr_GetCurrentBrightness()
		{
			int result = 0;
			try
			{
				System.UPvr_CallStaticMethod(ref result, javaSysActivityClass, "Pvr_GetScreen_Brightness", Pvr_UnitySDKRender.Instance.activity);
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
			}
			return result;
		}

		public static int[] Pvr_GetScreenBrightnessLevel()
		{
			int[] result = new int[1];
			try
			{
				System.UPvr_CallStaticMethod(ref result, javaSysActivityClass, "getScreenBrightnessLevel");
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
			}
			return result;
		}

		public static void Pvr_SetScreenBrightnessLevel(int vrBrightness, int level)
		{
			try
			{
				System.UPvr_CallStaticMethod(javaSysActivityClass, "setScreenBrightnessLevel", vrBrightness, level);
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
			}
		}

		public static bool UPvr_StartAudioReceiver(string startreceivre)
		{
			try
			{
				System.UPvr_CallStaticMethod(volumejavaVrActivityClass, "Pvr_StartReceiver", Pvr_UnitySDKRender.Instance.activity, startreceivre);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_StopAudioReceiver()
		{
			try
			{
				System.UPvr_CallStaticMethod(volumejavaVrActivityClass, "Pvr_StopReceiver", Pvr_UnitySDKRender.Instance.activity);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static int UPvr_GetMaxVolumeNumber()
		{
			int result = 0;
			try
			{
				System.UPvr_CallStaticMethod(ref result, javaSysActivityClass, "Pvr_GetMaxAudionumber");
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
			}
			return result;
		}

		public static int UPvr_GetCurrentVolumeNumber()
		{
			int result = 0;
			try
			{
				System.UPvr_CallStaticMethod(ref result, javaSysActivityClass, "Pvr_GetAudionumber");
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
			}
			return result;
		}

		public static bool UPvr_VolumeUp()
		{
			try
			{
				System.UPvr_CallStaticMethod(javaSysActivityClass, "Pvr_UpAudio");
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_VolumeDown()
		{
			try
			{
				System.UPvr_CallStaticMethod(javaSysActivityClass, "Pvr_DownAudio");
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_SetVolumeNum(int volume)
		{
			try
			{
				System.UPvr_CallStaticMethod(javaSysActivityClass, "Pvr_ChangeAudio", volume);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_SetAudio(string s)
		{
			return false;
		}

		public static bool UPvr_SetBattery(string s)
		{
			return false;
		}

		private static string getDevicePropForUser(DeviceCommand deviceid)
		{
			string result = "0";
			System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getDevicePropForUser", (int)deviceid);
			return result;
		}

		private static bool setDevicePropForUser(DeviceCommand deviceid, string number)
		{
			bool result = false;
			System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "setDevicePropForUser", (int)deviceid, number);
			return result;
		}
	}
}
public class Pvr_VolumePowerBrightness : MonoBehaviour
{
	private bool VolEnable;

	private bool BattEnable;

	public Text showResult;

	public Text setVolumnum;

	public Text setBrightnum;

	public string MusicPath;

	private void Awake()
	{
		InitBatteryVolClass();
		string startreceivre = base.gameObject.name;
		StartBatteryReceiver(startreceivre);
		StartAudioReceiver(startreceivre);
	}

	private void OnDisable()
	{
		if (VolEnable)
		{
			StopAudioReceiver();
		}
		if (BattEnable)
		{
			StopBatteryReceiver();
		}
	}

	public void GetMaxVolumeNumber()
	{
		int num = 0;
		num = VolumePowerBrightness.UPvr_GetMaxVolumeNumber();
		showResult.text = "Maximum volume: " + num;
	}

	public void GetCurrentVolumeNumber()
	{
		int num = 0;
		num = VolumePowerBrightness.UPvr_GetCurrentVolumeNumber();
		showResult.text = "Current volume" + num;
	}

	public void VolumeUp()
	{
		bool flag = false;
		if (!VolumePowerBrightness.UPvr_VolumeUp())
		{
			PLOG.E("VolumeUp Error");
		}
	}

	public void VolumeDown()
	{
		bool flag = false;
		if (!VolumePowerBrightness.UPvr_VolumeDown())
		{
			PLOG.E("VolumeDown Error");
		}
	}

	public void SetVolumeNum()
	{
		bool flag = false;
		System.Random random = new System.Random();
		int volume = random.Next(0, 15);
		setVolumnum.text = "Random number" + volume;
		if (!VolumePowerBrightness.UPvr_SetVolumeNum(volume))
		{
			PLOG.E("SetVolumeNum Error");
		}
	}

	public void SetBrightness()
	{
		bool flag = false;
		System.Random random = new System.Random();
		int brightness = random.Next(0, 255);
		setBrightnum.text = "Random number" + brightness;
		if (!VolumePowerBrightness.UPvr_SetCommonBrightness(brightness))
		{
			PLOG.E("SetBrightness Error");
		}
	}

	public void GetCurrentBrightness()
	{
		int num = 0;
		num = VolumePowerBrightness.UPvr_GetCommonBrightness();
		showResult.text = "Current brightness" + num;
	}

	public bool setAudio(string s)
	{
		PLOG.I(s.ToString());
		return true;
	}

	public bool setBattery(string s)
	{
		PLOG.I(s.ToString());
		return true;
	}

	private bool InitBatteryVolClass()
	{
		return VolumePowerBrightness.UPvr_InitBatteryVolClass();
	}

	private bool StartBatteryReceiver(string startreceivre)
	{
		BattEnable = VolumePowerBrightness.UPvr_StartBatteryReceiver(startreceivre);
		return BattEnable;
	}

	private bool StopBatteryReceiver()
	{
		return VolumePowerBrightness.UPvr_StopBatteryReceiver();
	}

	private bool StartAudioReceiver(string startreceivre)
	{
		VolEnable = VolumePowerBrightness.UPvr_StartAudioReceiver(startreceivre);
		return VolEnable;
	}

	private bool StopAudioReceiver()
	{
		return VolumePowerBrightness.UPvr_StopAudioReceiver();
	}
}
[RequireComponent(typeof(CharacterController))]
public class PicoPlayerController : MonoBehaviour
{
	protected CharacterController Controller;

	protected Transform CameraController;

	public float Acceleration = 0.1f;

	public float Damping = 0.15f;

	public float BackAndSideDampen = 0.5f;

	public float JumpForce = 0.3f;

	public float RotationAmount = 1.5f;

	public float GravityModifier = 0.379f;

	public float GamepadRotateFactor = 1.5f;

	private float MoveScale = 1f;

	private Vector3 MoveThrottle = Vector3.zero;

	private float FallSpeed;

	public bool updateRotationFromHMD = true;

	private Quaternion OrientationOffset = Quaternion.identity;

	private float YRotation;

	private float XRotation;

	protected Transform DirXform;

	private float MoveScaleMultiplier = 2f;

	private float RotationScaleMultiplierPad = 1f;

	private float RotationScaleMultiplierMouse = 1f;

	private bool SkipMouseRotation;

	private bool HaltUpdateMovement;

	public float lastThrottleSpeed;

	private float RotationRatchet = 30f;

	private bool prevHatLeft;

	private bool prevHatRight;

	private float leftHatTimer;

	private float rightHatTimer;

	public Vector3 adjustBodyMove = Vector3.zero;

	public bool adjustBodyToggle;

	public Vector3 actualBodyMove = Vector3.zero;

	private bool controllerGrounded;

	public Transform moveReferenceObject;

	private static float sDeltaRotationOld;

	public void Awake()
	{
		Controller = base.gameObject.GetComponent<CharacterController>();
		if (Controller == null)
		{
			Debug.LogWarning("OVRPlayerController: No CharacterController attached.");
		}
		Pvr_UnitySDKManager[] componentsInChildren = base.gameObject.GetComponentsInChildren<Pvr_UnitySDKManager>();
		Vector3 position = componentsInChildren[0].transform.Find("Head").position;
		if (componentsInChildren.Length == 0)
		{
			Debug.LogWarning("Pvr_UnitySDKManager: No Pvr_UnitySDKManager attached.");
		}
		else if (componentsInChildren.Length > 1)
		{
			Debug.LogWarning("Pvr_UnitySDKManager: More then 1 Pvr_UnitySDKManager attached.");
		}
		else
		{
			CameraController = componentsInChildren[0].transform;
		}
		DirXform = null;
		Transform[] componentsInChildren2 = base.gameObject.GetComponentsInChildren<Transform>();
		for (int i = 0; i < componentsInChildren2.Length; i++)
		{
			if (componentsInChildren2[i].name == "ForwardDirection")
			{
				DirXform = componentsInChildren2[i];
				break;
			}
		}
		if (DirXform == null)
		{
			Debug.LogWarning("Pvr_UnitySDKManager: ForwardDirection game object not found. Do not use.");
		}
	}

	public void Start()
	{
		InitializeInputs();
		SetCameras();
	}

	public void Update()
	{
		UpdateMovement();
		Vector3 zero = Vector3.zero;
		float num = 60f;
		float num2 = 1f + Damping * num * Time.deltaTime;
		MoveThrottle.x /= num2;
		MoveThrottle.y = ((!(MoveThrottle.y > 0f)) ? MoveThrottle.y : (MoveThrottle.y / num2));
		MoveThrottle.z /= num2;
		zero += MoveThrottle * num * Time.deltaTime;
		if (Controller.isGrounded && FallSpeed <= 0f)
		{
			FallSpeed = Physics.gravity.y * (GravityModifier * 0.002f);
		}
		else
		{
			FallSpeed += Physics.gravity.y * (GravityModifier * 0.002f) * num * Time.deltaTime;
		}
		zero.y += FallSpeed * num * Time.deltaTime;
		float num3 = 0f;
		if (Controller.isGrounded && MoveThrottle.y <= 0.001f)
		{
			num3 = Mathf.Max(Controller.stepOffset, new Vector3(zero.x, 0f, zero.z).magnitude);
			zero -= num3 * Vector3.up;
		}
		Vector3 vector = Vector3.Scale(Controller.transform.localPosition + zero, new Vector3(1f, 0f, 1f));
		bool flag = false;
		Vector3 position = base.transform.position;
		Controller.Move(zero);
		if (zero.y <= 0f && base.transform.position.y > position.y + 0.2f)
		{
			base.transform.position = position;
		}
		else
		{
			float magnitude = zero.ToGround().magnitude;
			float magnitude2 = (base.transform.position - position).ToGround().magnitude;
			if (magnitude2 > 0.01f && (double)magnitude2 > (double)magnitude * 1.5)
			{
				flag = true;
			}
		}
		Vector3 vector2 = Vector3.Scale(Controller.transform.localPosition, new Vector3(1f, 0f, 1f));
		if (vector != vector2 && !flag)
		{
			MoveThrottle += (vector2 - vector) / (num * Time.deltaTime);
		}
		controllerGrounded = Controller.isGrounded;
		if (adjustBodyToggle && !GameController.Get().Paused)
		{
			Vector3 position2 = base.transform.position;
			Controller.Move(adjustBodyMove);
			Vector3 vector3 = (actualBodyMove = (base.transform.position - position2).ToGround());
			CameraController.transform.position -= vector3;
			adjustBodyMove = Vector3.zero;
		}
		UpdatePlayerForwardDirTransform();
	}

	public virtual void UpdateMovement()
	{
		if (HaltUpdateMovement)
		{
			return;
		}
		float num = 60f;
		bool flag = false;
		bool flag2 = false;
		bool flag3 = false;
		bool flag4 = false;
		MoveScale = 1f;
		if ((flag && flag2) || (flag && flag3) || (flag4 && flag2) || (flag4 && flag3))
		{
			MoveScale = 0.70710677f;
		}
		if (!controllerGrounded)
		{
			MoveScale = 0f;
		}
		MoveScale *= num * Time.deltaTime;
		float num2 = Acceleration * 0.1f * MoveScale * MoveScaleMultiplier;
		if (DirXform != null)
		{
			if (moveReferenceObject == null)
			{
				if (flag)
				{
					MoveThrottle += DirXform.TransformDirection(Vector3.forward * num2 * base.transform.lossyScale.z);
				}
				if (flag4)
				{
					MoveThrottle += DirXform.TransformDirection(Vector3.back * num2 * base.transform.lossyScale.z) * BackAndSideDampen;
				}
				if (flag2)
				{
					MoveThrottle += DirXform.TransformDirection(Vector3.left * num2 * base.transform.lossyScale.x) * BackAndSideDampen;
				}
				if (flag3)
				{
					MoveThrottle += DirXform.TransformDirection(Vector3.right * num2 * base.transform.lossyScale.x) * BackAndSideDampen;
				}
			}
			else
			{
				Vector3 vector = moveReferenceObject.forward;
				if (vector.x == 0f && vector.y == 0f)
				{
					vector = moveReferenceObject.up;
				}
				vector.y = 0f;
				vector.Normalize();
				if (InputExt.IsOculusGo && CameraController != null)
				{
					Transform transform = CameraController.Find("BothEye").transform;
					Vector3 vector2 = transform.forward;
					if (vector2.x == 0f && vector2.y == 0f)
					{
						vector2 = transform.up;
					}
					vector2.y = 0f;
					vector2.Normalize();
					vector = 0.8f * vector + 0.2f * vector2;
				}
				Vector3 vector3 = Vector3.Cross(Vector3.up, vector);
				if (flag)
				{
					MoveThrottle += vector * num2;
				}
				if (flag4)
				{
					MoveThrottle -= vector * num2 * BackAndSideDampen;
				}
				if (flag2)
				{
					MoveThrottle -= vector3 * num2 * BackAndSideDampen;
				}
				if (flag3)
				{
					MoveThrottle += vector3 * num2 * BackAndSideDampen;
				}
			}
		}
		float num3 = num * Time.deltaTime * RotationAmount * RotationScaleMultiplierMouse;
		float num4 = num * Time.deltaTime * RotationAmount * RotationScaleMultiplierPad;
		if (Input.GetKey(KeyCode.Q))
		{
			YRotation -= num4 * 0.5f;
		}
		if (Input.GetKey(KeyCode.E))
		{
			YRotation += num4 * 0.5f;
		}
		num2 = num * Time.deltaTime * Acceleration * 0.1f * MoveScale * MoveScaleMultiplier;
		if (DirXform != null)
		{
			float y = InputExt.GetAxisPad(InputExt.Axis2D.LeftThumbstick).y;
			float x = InputExt.GetAxisPad(InputExt.Axis2D.LeftThumbstick).x;
			if (moveReferenceObject == null)
			{
				if (y > 0f)
				{
					MoveThrottle += y * DirXform.TransformDirection(Vector3.forward * num2);
				}
				if (y < 0f)
				{
					MoveThrottle += Mathf.Abs(y) * DirXform.TransformDirection(Vector3.back * num2) * BackAndSideDampen;
				}
				if (x < 0f)
				{
					MoveThrottle += Mathf.Abs(x) * DirXform.TransformDirection(Vector3.left * num2) * BackAndSideDampen;
				}
				if (x > 0f)
				{
					MoveThrottle += x * DirXform.TransformDirection(Vector3.right * num2) * BackAndSideDampen;
				}
			}
			else
			{
				Vector3 vector4 = moveReferenceObject.forward;
				if (vector4.x == 0f && vector4.y == 0f)
				{
					vector4 = moveReferenceObject.up;
				}
				vector4.y = 0f;
				vector4.Normalize();
				Vector3 vector5 = Vector3.Cross(Vector3.up, vector4);
				if (y > 0f)
				{
					MoveThrottle += y * vector4 * num2;
				}
				if (y < 0f)
				{
					MoveThrottle -= Mathf.Abs(y) * vector4 * num2 * BackAndSideDampen;
				}
				if (x < 0f)
				{
					MoveThrottle -= Mathf.Abs(x) * vector5 * num2 * BackAndSideDampen;
				}
				if (x > 0f)
				{
					MoveThrottle += x * vector5 * num2 * BackAndSideDampen;
				}
			}
		}
		lastThrottleSpeed = MoveThrottle.magnitude;
		float x2 = InputExt.GetAxisPad(InputExt.Axis2D.RightThumbstick).x;
		float num5 = 0f;
		YRotation += x2 * num4 * GamepadRotateFactor;
		XRotation += num5 * num4 * GamepadRotateFactor;
		SetCameras();
	}

	public virtual void UpdatePlayerForwardDirTransform()
	{
		if (DirXform != null && CameraController != null)
		{
			Quaternion identity = Quaternion.identity;
			if (updateRotationFromHMD)
			{
				Transform transform = CameraController.Find("Head").transform;
				float y = transform.rotation.eulerAngles.y;
				DirXform.rotation = Quaternion.Euler(0f, y, 0f);
			}
			else
			{
				float y2 = DirXform.rotation.eulerAngles.y;
				Vector3 eulerAngles = CameraController.transform.rotation.eulerAngles;
				eulerAngles.y = y2;
				CameraController.transform.rotation = Quaternion.Euler(eulerAngles);
			}
		}
	}

	public bool Jump()
	{
		if (!controllerGrounded)
		{
			return false;
		}
		MoveThrottle += new Vector3(0f, JumpForce, 0f);
		return true;
	}

	public void Stop()
	{
		Controller.Move(Vector3.zero);
		MoveThrottle = Vector3.zero;
		FallSpeed = 0f;
	}

	public void InitializeInputs()
	{
		OrientationOffset = base.transform.rotation;
		YRotation = OrientationOffset.eulerAngles.y;
	}

	public void SetCameras()
	{
		if (CameraController != null)
		{
			Vector3 eulerAngles = CameraController.transform.rotation.eulerAngles;
			eulerAngles.y = YRotation;
			CameraController.transform.rotation = Quaternion.Euler(eulerAngles);
		}
	}

	public void GetMoveScaleMultiplier(ref float moveScaleMultiplier)
	{
		moveScaleMultiplier = MoveScaleMultiplier;
	}

	public void SetMoveScaleMultiplier(float moveScaleMultiplier)
	{
		MoveScaleMultiplier = moveScaleMultiplier;
	}

	public void GetRotationScaleMultiplierMouse(ref float rotationScaleMultiplier)
	{
		rotationScaleMultiplier = RotationScaleMultiplierMouse;
	}

	public void SetRotationScaleMultiplierMouse(float rotationScaleMultiplier)
	{
		RotationScaleMultiplierMouse = rotationScaleMultiplier;
	}

	public void GetRotationScaleMultiplierPad(ref float rotationScaleMultiplier)
	{
		rotationScaleMultiplier = RotationScaleMultiplierPad;
	}

	public void SetRotationScaleMultiplierPad(float rotationScaleMultiplier)
	{
		RotationScaleMultiplierPad = rotationScaleMultiplier;
	}

	public void GetRotationScaleMultiplier(ref float rotationScaleMultiplier)
	{
		rotationScaleMultiplier = RotationScaleMultiplierMouse;
	}

	public void SetRotationScaleMultiplier(float rotationScaleMultiplier)
	{
		RotationScaleMultiplierMouse = rotationScaleMultiplier;
		RotationScaleMultiplierPad = rotationScaleMultiplier;
	}

	public void GetSkipMouseRotation(ref bool skipMouseRotation)
	{
		skipMouseRotation = SkipMouseRotation;
	}

	public void SetSkipMouseRotation(bool skipMouseRotation)
	{
		SkipMouseRotation = skipMouseRotation;
	}

	public void GetHaltUpdateMovement(ref bool haltUpdateMovement)
	{
		haltUpdateMovement = HaltUpdateMovement;
	}

	public void SetHaltUpdateMovement(bool haltUpdateMovement)
	{
		HaltUpdateMovement = haltUpdateMovement;
	}

	public void ResetOrientation()
	{
		YRotation = 0f;
		XRotation = 0f;
	}

	public void GetYRotation(ref float rot)
	{
		rot = YRotation;
	}

	public void SetYRotation(float rot)
	{
		YRotation = rot;
	}
}
public class BlackoutScreen : MonoBehaviour
{
	public int waitFrames = 1;

	public bool disableOnWaitFrames = true;

	private int curFrames;

	public Color fadeColor = new Color(0f, 0f, 0f, 1f);

	private Material fadeMaterial;

	private void Awake()
	{
		curFrames = 0;
		fadeMaterial = new Material(Shader.Find("Oculus/Unlit Transparent Color"));
		fadeMaterial.color = fadeColor;
	}

	private void OnDestroy()
	{
		if (fadeMaterial != null)
		{
			UnityEngine.Object.Destroy(fadeMaterial);
		}
	}

	private void Update()
	{
		if (disableOnWaitFrames && curFrames > waitFrames)
		{
			base.enabled = false;
			disableOnWaitFrames = false;
		}
	}

	private void OnPostRender()
	{
		if (disableOnWaitFrames)
		{
			curFrames++;
		}
		fadeMaterial.SetPass(0);
		GL.PushMatrix();
		GL.LoadOrtho();
		GL.Color(fadeMaterial.color);
		GL.Begin(7);
		GL.Vertex3(0f, 0f, -12f);
		GL.Vertex3(0f, 1f, -12f);
		GL.Vertex3(1f, 1f, -12f);
		GL.Vertex3(1f, 0f, -12f);
		GL.End();
		GL.PopMatrix();
	}

	public void SetColor(Color color)
	{
		fadeColor = color;
		fadeMaterial.color = color;
	}
}
public class ClearMemory : MonoBehaviour
{
	private static List<Texture> runtimeTextures = new List<Texture>();

	private static List<Material> runtimeMaterials = new List<Material>();

	private void Awake()
	{
		Clear();
		UnityEngine.Object.Destroy(this);
	}

	public static void Clear()
	{
		float realtimeSinceStartup = Time.realtimeSinceStartup;
		for (int i = 0; i < runtimeMaterials.Count; i++)
		{
			UnityEngine.Object.Destroy(runtimeMaterials[i]);
		}
		runtimeMaterials.Clear();
		for (int j = 0; j < runtimeTextures.Count; j++)
		{
			UnityEngine.Object.Destroy(runtimeTextures[j]);
		}
		runtimeTextures.Clear();
		TextureAtlas.Clear();
		Map.Clear();
		AmbientManager.Clear();
		Jukebox.Clear();
		VisibilityProbeManager.Clear();
		VisibilityProbe.Clear();
		CollectableSpawn.Clear();
		PlayerStats.Clear();
		MapChunk.Clear();
		Player.Clear();
		GameController.Clear();
		Pathfinder.Clear();
		Debug.Log("Allocated memory before collect:" + GC.GetTotalMemory(forceFullCollection: false));
		GC.Collect();
		Debug.Log("Allocated memory after collect:" + GC.GetTotalMemory(forceFullCollection: true));
		Debug.Log("Time - ClearMemory " + (Time.realtimeSinceStartup - realtimeSinceStartup).ToString("F2"));
	}

	public static void AddRuntimeTexture(Texture tex)
	{
		runtimeTextures.Add(tex);
	}

	public static void AddRuntimeMaterial(Material mat)
	{
		runtimeMaterials.Add(mat);
	}
}
public class ClockMode
{
	public enum Mode
	{
		Standard,
		High,
		Low,
		CPUIntensive,
		GPUIntensive,
		PowerSave
	}

	private static Mode currentMode = Mode.PowerSave;

	public static void Set(Mode mode)
	{
		if (mode != currentMode)
		{
			currentMode = mode;
			Debug.Log("ClockMode: " + mode);
		}
	}
}
public class Config
{
	[Serializable]
	public class GeneralCfg
	{
		public string language = string.Empty;

		public bool tutorials = true;

		public bool oracleSubtitles = true;

		public bool endingCredits;

		public bool randomModeUnlocked;

		public void Serialize(string key)
		{
			PlayerPrefs.SetString(key + ".language", language);
			PlayerPrefs.SetInt(key + ".tutorials", tutorials ? 1 : 0);
			PlayerPrefs.SetInt(key + ".endingCredits", endingCredits ? 1 : 0);
			PlayerPrefs.SetInt(key + ".randomModeUnlocked", randomModeUnlocked ? 1 : 0);
		}

		public void Deserialize(string key)
		{
			language = PlayerPrefs.GetString(key + ".language", language);
			tutorials = PlayerPrefs.GetInt(key + ".tutorials", tutorials ? 1 : 0) == 1;
			endingCredits = PlayerPrefs.GetInt(key + ".endingCredits", endingCredits ? 1 : 0) == 1;
			randomModeUnlocked = PlayerPrefs.GetInt(key + ".randomModeUnlocked", randomModeUnlocked ? 1 : 0) == 1;
		}
	}

	[Serializable]
	public class VideoCfg
	{
		public void Serialize(string key)
		{
		}

		public void Deserialize(string key)
		{
		}
	}

	[Serializable]
	public class InputCfg
	{
		public float mouseSensitivity = 0.75f;

		public float gamepadSensitivity = 1.25f;

		public bool comfortRotation = true;

		public bool tankMode;

		public int rotationSpeed = 3;

		public bool leftHanded;

		public void Serialize(string key)
		{
			PlayerPrefs.SetInt(key + ".comfortRotation", comfortRotation ? 1 : 0);
			PlayerPrefs.SetInt(key + ".rotationSpeed", rotationSpeed);
			PlayerPrefs.SetInt(key + ".tankMode", tankMode ? 1 : 0);
			PlayerPrefs.SetInt(key + ".leftHanded", leftHanded ? 1 : 0);
		}

		public void Deserialize(string key)
		{
			comfortRotation = PlayerPrefs.GetInt(key + ".comfortRotation", comfortRotation ? 1 : 0) == 1;
			rotationSpeed = PlayerPrefs.GetInt(key + ".rotationSpeed", rotationSpeed);
			tankMode = PlayerPrefs.GetInt(key + ".tankMode", tankMode ? 1 : 0) == 1;
			leftHanded = PlayerPrefs.GetInt(key + ".leftHanded", leftHanded ? 1 : 0) == 1;
		}
	}

	[Serializable]
	public class AudioCfg
	{
		public float masterVolume = 1f;

		public float musicVolume = 1f;

		public void Serialize(string key)
		{
			PlayerPrefs.SetFloat(key + ".masterVolume", masterVolume);
			PlayerPrefs.SetFloat(key + ".musicVolume", musicVolume);
		}

		public void Deserialize(string key)
		{
			masterVolume = PlayerPrefs.GetFloat(key + ".masterVolume", masterVolume);
			musicVolume = PlayerPrefs.GetFloat(key + ".musicVolume", musicVolume);
		}
	}

	private static Config instance;

	private GeneralCfg general;

	private VideoCfg video;

	private InputCfg input;

	private AudioCfg audio;

	private Config()
	{
		general = new GeneralCfg();
		video = new VideoCfg();
		input = new InputCfg();
		audio = new AudioCfg();
	}

	public static Config Get()
	{
		if (instance == null)
		{
			instance = new Config();
		}
		return instance;
	}

	public static void Reset()
	{
		instance = null;
	}

	public static GeneralCfg General()
	{
		return Get().general;
	}

	public static VideoCfg Video()
	{
		return Get().video;
	}

	public static InputCfg Input()
	{
		return Get().input;
	}

	public static AudioCfg Audio()
	{
		return Get().audio;
	}

	public static void Load()
	{
		Config config = Get();
		config.general.Deserialize("GeneralCfg");
		config.video.Deserialize("VideoCfg");
		config.input.Deserialize("InputCfg");
		config.audio.Deserialize("AudioCfg");
	}

	public static void Save()
	{
		Config config = Get();
		config.general.Serialize("GeneralCfg");
		config.video.Serialize("VideoCfg");
		config.input.Serialize("InputCfg");
		config.audio.Serialize("AudioCfg");
	}
}
public class AnimStepSounds : MonoBehaviour
{
	public AudioClip[] sounds;

	public float minDistance = 1f;

	public float maxDistance = 15f;

	public float spread;

	public bool logarithmic = true;

	public bool playing = true;

	private int soundIndex;

	public void PlayStepSound()
	{
		if (playing)
		{
			Utils.PlayClipAt(sounds[soundIndex], base.transform.position, minDistance, maxDistance, spread, (!logarithmic) ? AudioRolloffMode.Linear : AudioRolloffMode.Logarithmic);
			int num = soundIndex;
			do
			{
				soundIndex = UnityEngine.Random.Range(0, sounds.Length);
			}
			while (soundIndex == num && sounds.Length > 1);
		}
	}
}
public class AnimWarper : MonoBehaviour
{
	private class BoneState
	{
		public Transform transform;

		public int depth;

		public Vector3 deltaPos;

		public Vector3 deltaScale;

		public Vector3 startPos;

		public Quaternion startRot;

		public BoneState(Transform bone, int boneDepth)
		{
			transform = bone;
			depth = boneDepth;
			deltaPos = Vector3.zero;
			deltaScale = Vector3.one;
			startPos = bone.localPosition;
			startRot = bone.localRotation;
		}

		public void AddPos(Vector3 delta)
		{
			deltaPos += delta;
		}

		public void AddScale(float scale)
		{
			deltaScale *= scale;
		}

		public void AddScale(Vector3 scale)
		{
			deltaScale = new Vector3(deltaScale.x * scale.x, deltaScale.y * scale.y, deltaScale.z * scale.z);
		}
	}

	public Transform head;

	public Transform root;

	public Renderer bodyRenderer;

	public Renderer eyesRenderer;

	private Dictionary<int, BoneState> bonesDict;

	public Transform[] warpWave;

	private List<Transform>[] warpWaveBones;

	[Range(0f, 1f)]
	public float warpIntensity = 1f;

	public Transform[] warpScale;

	private List<Transform>[] warpScaleBones;

	[Range(0f, 1f)]
	public float scaleIntensity = 1f;

	public Vector3 curveDirection = new Vector3(0f, 0f, -1f);

	[Range(0f, 1f)]
	public float curveIntensity = 1f;

	[Range(0f, 1f)]
	public float headTracking;

	[Range(0f, 1f)]
	public float verticalCollapse;

	private CapsuleCollider capCollider;

	private float capsuleHeight;

	private Vector3 capsuleCenter;

	public float minColliderFactor = 0.6f;

	private float waiter = 5f;

	private bool inited;

	private void Start()
	{
		bodyRenderer.enabled = false;
		if (eyesRenderer != null)
		{
			eyesRenderer.enabled = false;
		}
		capCollider = GetComponent<CapsuleCollider>();
		if (capCollider != null)
		{
			capsuleHeight = capCollider.height;
			capsuleCenter = capCollider.center;
		}
	}

	private void AddBonesToDict(Transform bone, int depth = 0)
	{
		bonesDict[bone.GetInstanceID()] = new BoneState(bone, depth);
		for (int i = 0; i < bone.childCount; i++)
		{
			AddBonesToDict(bone.GetChild(i).transform, depth + 1);
		}
	}

	private void AddBonesToList(Transform bone, List<Transform> list)
	{
		list.Add(bone);
		for (int i = 0; i < bone.childCount; i++)
		{
			AddBonesToList(bone.GetChild(i).transform, list);
		}
	}

	private void Update()
	{
		if (!inited)
		{
			inited = true;
			bonesDict = new Dictionary<int, BoneState>();
			AddBonesToDict(root);
			warpWaveBones = new List<Transform>[warpWave.Length];
			for (int i = 0; i < warpWave.Length; i++)
			{
				warpWaveBones[i] = new List<Transform>();
				AddBonesToList(warpWave[i], warpWaveBones[i]);
			}
			warpScaleBones = new List<Transform>[warpScale.Length];
			for (int j = 0; j < warpScale.Length; j++)
			{
				warpScaleBones[j] = new List<Transform>();
				AddBonesToList(warpScale[j], warpScaleBones[j]);
			}
			bodyRenderer.enabled = true;
			if (eyesRenderer != null)
			{
				eyesRenderer.enabled = true;
			}
		}
		else
		{
			if (waiter > 0f)
			{
				waiter -= Time.deltaTime;
			}
			ApplyVerticalCollapse();
		}
	}

	private void LateUpdate()
	{
		if (!inited)
		{
			return;
		}
		ApplyWarpWave();
		ApplyWarpScale();
		ApplyCurve();
		foreach (BoneState value in bonesDict.Values)
		{
			value.transform.localPosition = value.startPos + value.deltaPos;
			value.transform.localScale = value.deltaScale;
			value.deltaPos = Vector3.zero;
			value.deltaScale = Vector3.one;
		}
		Vector3 forward = Player.GetCenterEye() - head.position;
		forward.Normalize();
		Quaternion b = Quaternion.LookRotation(forward, base.transform.up) * Quaternion.Euler(0f, -90f, -90f);
		head.rotation = Quaternion.Slerp(GetBone(head).transform.rotation, b, headTracking);
	}

	private void OnDisable()
	{
	}

	private void ApplyWarpWave()
	{
		for (int i = 0; i < warpWaveBones.Length; i++)
		{
			for (int j = 0; j < warpWaveBones[i].Count; j++)
			{
				int num = (j + 1) * (i + 1);
				float num2 = Mathf.PerlinNoise(num, Time.time * 0.25f) * 2f - 1f;
				float num3 = Mathf.PerlinNoise(num, Time.time * 0.25f + 1.5f) * 2f - 1f;
				float num4 = Mathf.PerlinNoise(num, Time.time * 0.25f + 2f) * 2f - 1f;
				GetBone(warpWaveBones[i][j]).AddPos(new Vector3(num2 * 0.1f, num3 * 0.1f, num4 * 0.1f) * warpIntensity);
			}
		}
	}

	private void ApplyWarpScale()
	{
		for (int i = 0; i < warpScaleBones.Length; i++)
		{
			for (int j = 0; j < warpScaleBones[i].Count; j++)
			{
				int num = (j + 1) * (i + 1);
				float num2 = Mathf.PerlinNoise(num, Time.time * 0.15f) * 2f - 1f;
				float num3 = Mathf.PerlinNoise(num, Time.time * 0.15f + 1.5f) * 2f - 1f;
				float num4 = Mathf.PerlinNoise(num, Time.time * 0.15f + 2f) * 2f - 1f;
				GetBone(warpScaleBones[i][j]).AddScale(Vector3.one + new Vector3(num2 * 0.05f * scaleIntensity, num3 * 0.05f * scaleIntensity, num4 * 0.05f * scaleIntensity));
			}
		}
	}

	private void ApplyCurve()
	{
		Vector3 vec = curveDirection;
		vec = vec.ToGround();
		vec.Normalize();
		foreach (BoneState value in bonesDict.Values)
		{
			float num = Mathf.Abs(value.transform.position.y - base.transform.position.y);
			float num2 = Mathf.Clamp01(num - 0.15f);
			Vector3 direction = vec * Mathf.Sin(num * 0.25f) * curveIntensity * 0.16f * num2;
			direction = value.transform.InverseTransformDirection(direction);
			value.AddPos(direction);
		}
	}

	public void ApplyVerticalCollapse()
	{
		Material material = bodyRenderer.material;
		material.SetFloat("_CollapseShift", Mathf.Lerp(0f, 2.5f, Interpolate.EaseInOut(verticalCollapse)));
		material.SetFloat("_RimIntensity", Mathf.Lerp(0.02f, 0f, verticalCollapse));
		material.SetFloat("_WarpCenter", Mathf.Clamp01(verticalCollapse * 2f));
		if (eyesRenderer != null)
		{
			eyesRenderer.enabled = verticalCollapse <= 0.05f;
		}
		if (capCollider != null)
		{
			float num = Mathf.Clamp(verticalCollapse, 0f, 1f - minColliderFactor);
			capCollider.height = capsuleHeight * (1f - num);
			capCollider.center = Vector3.Lerp(capsuleCenter, Vector3.zero, num);
			capCollider.enabled = (minColliderFactor > 0f && capCollider.height > 0.2f) || capCollider.height > 1f;
		}
	}

	private BoneState GetBone(Transform bone)
	{
		return bonesDict[bone.GetInstanceID()];
	}
}
public class Bat : MonoBehaviour
{
	public Room room;

	public float displacementMin = 1f;

	public float displacementMax = 4f;

	public float speedMin = 0.3f;

	public float speedMax = 0.5f;

	public float controlInitMin = 15f;

	public float controlInitMax = 18f;

	public float controlEndMin = -9f;

	public float controlEndMax = -2f;

	public float minWait;

	public float maxWait = 0.6f;

	private Vector3 initPos;

	private Vector3 endPos;

	private Vector3 controlPointInit;

	private Vector3 controlPointEnd;

	private float progress;

	private float speed;

	private float wait;

	private static List<Point> pitCandidates = new List<Point>();

	private static List<Point> shaftCandidates = new List<Point>();

	private static Room candidatesRoom;

	private void Start()
	{
		if (room == null)
		{
			room = Map.Get().At(base.transform.position).Room;
			if (room == null)
			{
				UnityEngine.Object.Destroy(base.gameObject);
				return;
			}
		}
		if (candidatesRoom != room)
		{
			pitCandidates.Clear();
			shaftCandidates.Clear();
			candidatesRoom = room;
			for (int i = room.Start.Y; i < room.Start.Y + room.Size.Y; i++)
			{
				for (int j = room.Start.X; j < room.Start.X + room.Size.X; j++)
				{
					Cell cell = Map.Get().At(j, i);
					if (cell.Room == room)
					{
						if (cell.IsPit())
						{
							pitCandidates.Add(new Point(j, i));
						}
						if (cell.CeilingShaft)
						{
							shaftCandidates.Add(new Point(j, i));
						}
					}
				}
			}
		}
		if (pitCandidates.Count == 0 || shaftCandidates.Count == 0)
		{
			UnityEngine.Object.Destroy(base.gameObject);
			return;
		}
		Point cellPos = RandomExt.Choice(pitCandidates);
		Point cellPos2 = RandomExt.Choice(shaftCandidates);
		initPos = Map.Get().CellToWorld(cellPos) - Vector3.up * 13.5f;
		Vector2 vector = UnityEngine.Random.insideUnitCircle * 1.5f / 2f;
		initPos.x += vector.x;
		initPos.z += vector.y;
		endPos = Map.Get().CellToWorld(cellPos2) + Vector3.up * 13.5f;
		vector = UnityEngine.Random.insideUnitCircle * 1.5f / 2f;
		endPos.x += vector.x;
		endPos.z += vector.y;
		float num = UnityEngine.Random.Range(controlInitMin, controlInitMax);
		float num2 = UnityEngine.Random.Range(controlEndMin, controlEndMax);
		controlPointInit = Map.Get().CellToWorld(cellPos) + Vector3.up * num;
		controlPointEnd = Map.Get().CellToWorld(cellPos2) + Vector3.up * num2;
		base.transform.position = initPos;
		progress = 0f;
		speed = UnityEngine.Random.Range(speedMin, speedMax);
		wait = UnityEngine.Random.Range(minWait, maxWait);
	}

	private void Update()
	{
		if (wait > 0f)
		{
			wait -= Time.deltaTime;
			if (wait > 0f)
			{
				return;
			}
			GetComponent<Animation>().Rewind();
			if (UnityEngine.Random.value <= 0.3f)
			{
				GetComponent<AudioSource>().Play();
			}
		}
		progress += Time.deltaTime * speed;
		if (progress > 1f)
		{
			UnityEngine.Object.Destroy(base.gameObject);
			return;
		}
		Vector3 position = base.transform.position;
		Vector3 vector = Interpolate.Bezier(initPos, controlPointInit, controlPointEnd, endPos, progress);
		Vector3 vector2 = vector - position;
		vector2.Normalize();
		base.transform.position = vector;
		base.transform.rotation = Quaternion.LookRotation(-vector2, Vector3.up);
	}
}
public class BellyLight : MonoBehaviour
{
	public Renderer bodyRenderer;

	public Light pointLight;

	public float lightLevel;

	public float lightRate = 0.1f;

	private Material bodyMaterial;

	private float maxEmission;

	private float maxLightIntensity;

	private float levelTarget;

	private void Start()
	{
		bodyMaterial = bodyRenderer.material;
		maxEmission = bodyMaterial.GetFloat("_EmissionIntensity");
		maxLightIntensity = pointLight.intensity;
	}

	private void Update()
	{
		bodyMaterial.SetFloat("_EmissionIntensity", maxEmission * lightLevel);
		pointLight.intensity = maxLightIntensity * lightLevel;
		if (lightLevel >= levelTarget)
		{
			lightLevel -= lightRate * Time.deltaTime;
			levelTarget = 0f;
		}
		else
		{
			lightLevel += lightRate * 5f * Time.deltaTime;
		}
		lightLevel = Mathf.Clamp01(lightLevel);
	}

	public void AddLight()
	{
		levelTarget = 1f;
	}
}
public class CreatureCounter : MonoBehaviour
{
	public enum CreatureType
	{
		Floater,
		Gargoyle,
		Ghost,
		LightEater,
		Shadow
	}

	public CreatureType creatureType;

	private Point lastPos;

	private Room lastRoom;

	private void Start()
	{
		lastPos = new Point(0, 0);
		lastRoom = null;
	}

	private void Update()
	{
		Point point = Map.Get().WorldToCell(base.transform.position);
		if (!(point != lastPos))
		{
			return;
		}
		Room room = ((!Map.Get().InRange(point)) ? null : Map.Get().At(point).Room);
		if (room != lastRoom)
		{
			if (lastRoom != null)
			{
				lastRoom.creatures.Remove(this);
			}
			room?.creatures.Add(this);
			lastRoom = room;
		}
		lastPos = point;
	}

	private void OnDestroy()
	{
		if (lastRoom != null)
		{
			lastRoom.creatures.Remove(this);
		}
	}

	public static int GetInRoom(Room room)
	{
		return room.creatures.Count;
	}

	public static int GetInRoom(Point pos)
	{
		Room room = Map.Get().At(pos).Room;
		if (room != null)
		{
			return GetInRoom(room);
		}
		return 0;
	}

	public static int GetInRoom(Room room, CreatureType ctype)
	{
		int num = 0;
		for (int i = 0; i < room.creatures.Count; i++)
		{
			if (room.creatures[i].creatureType == ctype)
			{
				num++;
			}
		}
		return num;
	}

	public static int GetInRoom(Point pos, CreatureType ctype)
	{
		Room room = Map.Get().At(pos).Room;
		if (room != null)
		{
			return GetInRoom(room, ctype);
		}
		return 0;
	}
}
public class CreatureVisibility : MonoBehaviour
{
	public bool autoHide;

	public bool showOnPlayerRoom;

	public bool showOnAdjacent;

	public List<Component> disableComponentsOnHidden;

	public List<GameObject> disableObjsOnHidden;

	private bool isHidden;

	public bool Hidden
	{
		get
		{
			return isHidden;
		}
		set
		{
			SetHidden(value);
		}
	}

	private void Update()
	{
		if (autoHide)
		{
			bool flag = !CheckVisibilize();
			if (isHidden != flag)
			{
				SetHidden(flag);
			}
		}
	}

	public void SetHidden(bool hidden)
	{
		isHidden = hidden;
		foreach (MonoBehaviour item in disableComponentsOnHidden)
		{
			item.enabled = !hidden;
		}
		foreach (GameObject item2 in disableObjsOnHidden)
		{
			item2.SetActive(!hidden);
		}
		GetComponent<Collider>().enabled = !hidden;
	}

	public bool CheckVisibilize()
	{
		Point curCell = Map.Get().WorldToCell(base.transform.position);
		return CheckVisibilize(curCell);
	}

	public bool CheckVisibilize(Point curCell)
	{
		if (!showOnAdjacent && MapChunk.At(curCell).Visible)
		{
			return true;
		}
		if (showOnAdjacent && MapChunk.CheckCellNextToVisible(curCell))
		{
			return true;
		}
		if (showOnPlayerRoom)
		{
			Room room = Map.Get().At(curCell).Room;
			if (room != null && room.PlayerInside)
			{
				return true;
			}
			if (showOnAdjacent)
			{
				for (int i = curCell.Y - 1; i <= curCell.Y + 1; i += 2)
				{
					Room room2 = Map.Get().At(curCell.X, i).Room;
					if (room2 != null && room2.PlayerInside)
					{
						return true;
					}
				}
				for (int j = curCell.X - 1; j <= curCell.X + 1; j += 2)
				{
					Room room3 = Map.Get().At(j, curCell.Y).Room;
					if (room3 != null && room3.PlayerInside)
					{
						return true;
					}
				}
			}
		}
		return false;
	}
}
public class Eyes : FSMComponent<Eyes.States>
{
	public enum States
	{
		Closed,
		LookAhead,
		LookAtPlayer
	}

	public Transform leftEye;

	public Transform rightEye;

	public Transform[] linkedObjs;

	public float closeSpeed = 2f;

	public float openSpeed = 2f;

	public float lookPlayerSpeed = 2f;

	public bool invertedStart;

	public float lookHeightOffset;

	private Quaternion lookAhead;

	private Quaternion lookBehind;

	private Transform playerTarget;

	public void SetClosed()
	{
		base.State = States.Closed;
	}

	public void SetLookAhead()
	{
		base.State = States.LookAhead;
	}

	public void SetLookAtPlayer()
	{
		base.State = States.LookAtPlayer;
	}

	private void Start()
	{
		lookAhead = leftEye.localRotation;
		lookBehind = Quaternion.Inverse(lookAhead);
		if (invertedStart)
		{
			lookBehind = lookAhead * Quaternion.AngleAxis(181f, new Vector3(0f, 0f, 1f));
		}
		playerTarget = Player.GetLook();
		Init(States.Closed);
	}

	private void Closed_Update()
	{
		SetBothRotations(lookBehind, closeSpeed);
	}

	private void LookAhead_Update()
	{
		SetBothRotations(lookAhead, openSpeed);
	}

	private void LookAtPlayer_Update()
	{
		Vector3 target = playerTarget.position + Vector3.up * lookHeightOffset;
		RotateEyeTowards(leftEye, target, lookPlayerSpeed);
		RotateEyeTowards(rightEye, target, lookPlayerSpeed);
		RotateLinkedTowards(target, lookPlayerSpeed);
	}

	private void SetBothRotations(Quaternion targetRot, float speed)
	{
		leftEye.localRotation = Interpolate.Slerp(leftEye.localRotation, targetRot, Time.deltaTime * speed);
		rightEye.localRotation = Interpolate.Slerp(rightEye.localRotation, targetRot, Time.deltaTime * speed);
		for (int i = 0; i < linkedObjs.Length; i++)
		{
			linkedObjs[i].localRotation = Interpolate.Slerp(linkedObjs[i].localRotation, targetRot, Time.deltaTime * speed);
		}
	}

	private void RotateEyeTowards(Transform eye, Vector3 target, float speed)
	{
		Vector3 forward = target - eye.position;
		forward.Normalize();
		Quaternion to = Quaternion.LookRotation(forward, -Vector3.up) * Quaternion.AngleAxis(90f, Vector3.up);
		eye.rotation = Interpolate.Slerp(eye.rotation, to, Time.deltaTime * speed);
	}

	private void RotateLinkedTowards(Vector3 target, float speed)
	{
		for (int i = 0; i < linkedObjs.Length; i++)
		{
			Vector3 forward = target - linkedObjs[i].position;
			forward.Normalize();
			Quaternion to = Quaternion.LookRotation(forward, -Vector3.up) * Quaternion.AngleAxis(90f, Vector3.up);
			linkedObjs[i].rotation = Interpolate.Slerp(linkedObjs[i].rotation, to, Time.deltaTime * speed);
		}
	}
}
public class Floater : FSMComponent<Floater.States>
{
	public enum States
	{
		StalkRoom,
		Patrol,
		AngryLook,
		Attack,
		WaitWell,
		RaiseWell
	}

	public float floatHeight = 1.9f;

	public float patrolSpeed = 1f;

	public float patrolTurnSpeed = 1f;

	private float patrolProgress;

	private Vector3 patrolOrigin;

	private float patrolProgressRot;

	private Quaternion patrolOriginRot;

	public Room room;

	private CreatureVisibility cVisibility;

	private PathWalker pathWalker;

	private Eyes eyes;

	private Jaw jaw;

	private CapsuleCollider capCollider;

	private RandomSounds randomSounds;

	private SoundLoop screechSound;

	public AudioSource attackSound;

	private GameObject player;

	private Transform playerLook;

	private VisibilityProbe probe;

	private float timer;

	private float cooldownTimer;

	private bool waiting;

	private Vector3 targetPos;

	private float detectedMotion;

	private Vector3 lastPlayerPos;

	private Quaternion lastPlayerRot;

	private Vector3 lastLeftHandPos;

	private Vector3 lastRightHandPos;

	private Quaternion lastLeftHandRot;

	private Quaternion lastRightHandRot;

	private float playerEvadedCooldown;

	private bool firstTimeSeen = true;

	public Light spotLight;

	private List<int> listOrder = new List<int>();

	private int detectMotionFrame;

	private void Start()
	{
		player = Player.Get();
		playerLook = Player.GetLook();
		pathWalker = GetComponent<PathWalker>();
		pathWalker.canFloat = true;
		cVisibility = GetComponent<CreatureVisibility>();
		eyes = GetComponent<Eyes>();
		jaw = GetComponent<Jaw>();
		capCollider = GetComponent<CapsuleCollider>();
		randomSounds = GetComponent<RandomSounds>();
		screechSound = GetComponent<SoundLoop>();
		screechSound.targetVolume = 0f;
		firstTimeSeen = true;
		if (room != null)
		{
			Init(States.StalkRoom);
		}
		else
		{
			Init(States.WaitWell);
		}
	}

	private void StalkRoom_Enter()
	{
		randomSounds.Playing = false;
		int num = 0;
		while (num++ < 30)
		{
			Point randomPoint = room.GetRandomPoint(central: true);
			if (Map.Get().At(randomPoint).IsVisible() || Map.Get().At(randomPoint).Occupied)
			{
				continue;
			}
			if (Map.Get().Tags.GetStyle(Map.Get().mapStyles, randomPoint).arched)
			{
				Cell cell = Map.Get().At(randomPoint);
				bool flag = cell.CheckAdjacency(AdjacencyCode.LeftCenter) && cell.CheckAdjacency(AdjacencyCode.RightCenter);
				flag |= cell.CheckAdjacency(AdjacencyCode.CenterTop) && cell.CheckAdjacency(AdjacencyCode.CenterBottom);
				flag |= cell.CheckAdjacency(AdjacencyCode.LeftCenter) && cell.CheckAdjacency(AdjacencyCode.CenterTop) && cell.CheckAdjacency(AdjacencyCode.RightBottom);
				flag |= cell.CheckAdjacency(AdjacencyCode.CenterTop) && cell.CheckAdjacency(AdjacencyCode.RightCenter) && cell.CheckAdjacency(AdjacencyCode.LeftBottom);
				flag |= cell.CheckAdjacency(AdjacencyCode.LeftTop) && cell.CheckAdjacency(AdjacencyCode.RightCenter) && cell.CheckAdjacency(AdjacencyCode.CenterBottom);
				if (flag | (cell.CheckAdjacency(AdjacencyCode.LeftCenter) && cell.CheckAdjacency(AdjacencyCode.RightTop) && cell.CheckAdjacency(AdjacencyCode.CenterBottom)))
				{
					continue;
				}
			}
			base.transform.position = Map.Get().CellToWorld(randomPoint) + Vector3.up * floatHeight;
			base.transform.rotation = Quaternion.AngleAxis(UnityEngine.Random.Range(0, 360), Vector3.up);
			probe = Map.Get().At(randomPoint).Probe;
			eyes.SetClosed();
			jaw.targetOpenPos = 0f;
			timer = 0f;
			waiting = false;
			room.HasLocalEnemy = true;
			return;
		}
		UnityEngine.Object.Destroy(base.gameObject);
	}

	private void StalkRoom_Update()
	{
		if (waiting)
		{
			timer -= Time.deltaTime;
			if (timer <= 0f)
			{
				base.State = States.Patrol;
				if (IsPlayerVisible())
				{
					SpookSounds.Get().PlayScare();
				}
			}
		}
		else if (room.PlayerInside && probe.IsVisible)
		{
			waiting = true;
			timer = ((!firstTimeSeen) ? UnityEngine.Random.Range(2f, 4.5f) : UnityEngine.Random.Range(3f, 9f));
			randomSounds.Playing = true;
			firstTimeSeen = false;
		}
		base.transform.position = new Vector3(base.transform.position.x, floatHeight + GetFloatBobbing(), base.transform.position.z);
	}

	private IEnumerator ShowTutorial_co(string textCode)
	{
		yield return new WaitForSeconds(3f);
		if (Config.General().tutorials)
		{
			Tutorial.Get().ShowTextForTime(Translate.Get(textCode), 5f);
		}
	}

	private void Patrol_Enter()
	{
		eyes.SetLookAhead();
		jaw.targetOpenPos = 0f;
		probe = null;
		waiting = true;
		timer = UnityEngine.Random.Range(1f, 4f);
		cooldownTimer = 6f;
		DetectMotion(forceUpdate: true);
		detectedMotion = 0f;
		randomSounds.Playing = true;
		if (!Tutorial.HasBeenShownBefore("TUTO_FLOATER", add: true) && (room.PlayerInside || Map.Get().At(base.transform.position).IsVisible()))
		{
			StartCoroutine(ShowTutorial_co("TUTO_FLOATER"));
		}
	}

	private void Patrol_Update()
	{
		bool flag = IsPlayerVisible();
		if (flag)
		{
			eyes.SetLookAtPlayer();
			if (playerEvadedCooldown > 0f)
			{
				playerEvadedCooldown -= Time.deltaTime;
			}
		}
		else
		{
			eyes.SetLookAhead();
			Room room = Map.Get().At(Player.GetPos()).Room;
			if (room != this.room)
			{
				playerEvadedCooldown = 4f;
			}
		}
		if (this.room.PlayerInside || Map.Get().At(base.transform.position).IsVisible())
		{
			Jukebox.Get().SetTension();
			FearEffect.Get().Scare();
			cooldownTimer = 6f;
		}
		else
		{
			cooldownTimer -= Time.deltaTime;
			if (cooldownTimer <= 0f)
			{
				base.State = States.StalkRoom;
				return;
			}
		}
		if (waiting)
		{
			timer -= Time.deltaTime;
			if (timer <= 0f)
			{
				waiting = false;
				targetPos = GetPatrolTarget();
				patrolProgress = 0f;
				patrolProgressRot = 0f;
				patrolOrigin = base.transform.position;
				patrolOriginRot = base.transform.rotation;
				if ((targetPos - base.transform.position).sqrMagnitude <= 0.09f)
				{
					waiting = true;
					timer = 1f;
				}
			}
		}
		else if (patrolProgressRot < 1f)
		{
			patrolProgressRot = LookAtSmooth(patrolOriginRot, targetPos, patrolProgressRot, patrolTurnSpeed);
		}
		else
		{
			patrolProgress = MoveSmooth(targetPos, patrolOrigin, patrolProgress, patrolSpeed);
			if (patrolProgress >= 1f)
			{
				waiting = true;
				timer = UnityEngine.Random.Range(2f, 5f);
			}
		}
		base.transform.position = new Vector3(base.transform.position.x, floatHeight + GetFloatBobbing(), base.transform.position.z);
		float num = DetectMotion();
		if (num >= 0.5f && flag)
		{
			base.State = States.AngryLook;
		}
		else if (!flag)
		{
			detectedMotion = 0f;
		}
	}

	private void AngryLook_Enter()
	{
		waiting = true;
		if (detectedMotion >= 1f)
		{
			timer = UnityEngine.Random.Range(1f, 3f);
		}
		else
		{
			timer = UnityEngine.Random.Range(1f, 6f);
		}
		screechSound.targetVolume = 0f;
	}

	private void AngryLook_Update()
	{
		bool flag = IsPlayerVisible();
		if (flag)
		{
			eyes.SetLookAtPlayer();
			if (playerEvadedCooldown > 0f)
			{
				playerEvadedCooldown -= Time.deltaTime;
			}
		}
		else
		{
			eyes.SetLookAhead();
		}
		Jukebox.Get().SetTension();
		FearEffect.Get().Scare();
		screechSound.targetVolume = 1f;
		pathWalker.LookAt(playerLook.position, patrolTurnSpeed * 6f);
		if (detectedMotion < 1f)
		{
			jaw.targetOpenPos = 0.3f;
			DetectMotion();
			if (detectedMotion >= 1f && flag && playerEvadedCooldown <= 0f)
			{
				base.State = States.Attack;
			}
		}
		else
		{
			jaw.targetOpenPos = 1f;
		}
		base.transform.position = new Vector3(base.transform.position.x, floatHeight + GetFloatBobbing(), base.transform.position.z);
		timer -= Time.deltaTime;
		if (timer <= 0f)
		{
			screechSound.targetVolume = 0f;
			if (detectedMotion >= 1f && playerEvadedCooldown <= 0f)
			{
				base.State = States.Attack;
				return;
			}
			detectedMotion = 0f;
			base.State = States.Patrol;
		}
	}

	private void Attack_Enter()
	{
		SpookSounds.Get().PlayScare(intense: true);
		attackSound.Play();
		pathWalker.Reset();
		pathWalker.ClearPath();
		pathWalker.radiusFactor = 0.4f;
		eyes.SetClosed();
	}

	private void Attack_Update()
	{
		Jukebox.Get().SetTension();
		FearEffect.Get().Scare();
		jaw.targetOpenPos = 1f;
		Vector3 vector = (targetPos = playerLook.position - Vector3.up * (capCollider.height / 2f - 0.25f));
		bool flag = false;
		if (pathWalker.CheckLineOfWalkToPlayer(vector))
		{
			targetPos = vector;
			pathWalker.ClearPath();
			flag = true;
		}
		else
		{
			if (pathWalker.CanSetPath(updateTimeout: true))
			{
				Point closestWalkable = Map.Get().GetClosestWalkable(vector);
				pathWalker.SetPath(closestWalkable, PathWalker.CheckTraversalFloater, PathWalker.GetTraversalCost);
			}
			targetPos = pathWalker.GetNextNode();
			targetPos.y = playerLook.position.y - (capCollider.height / 2f - 0.25f);
		}
		Point originPos = Map.Get().WorldToCell(base.transform.position);
		Vector3 vector2 = (targetPos - base.transform.position).GroundNormalize();
		Point destPos = Map.Get().WorldToCell(base.transform.position + vector2 * 1.5f);
		Door doorBetweenTiles = Map.Get().GetDoorBetweenTiles(originPos, destPos);
		if ((bool)doorBetweenTiles && !doorBetweenTiles.IsOpen)
		{
			doorBetweenTiles.Bash();
			doorBetweenTiles.OpenFast(base.transform);
		}
		Vector3 vector3 = targetPos - base.transform.position;
		vector3.Normalize();
		if (flag)
		{
			targetPos -= vector3 * capCollider.radius * 1.2f;
		}
		if (flag && (targetPos - base.transform.position).sqrMagnitude <= 0.040000003f)
		{
			Player.GetController().ApplyAttack(2f, "GAMEOVER_FLOATER");
		}
		else if ((vector - base.transform.position).sqrMagnitudeGround() <= 0.09f)
		{
			Player.GetController().ApplyAttack(2f, "GAMEOVER_FLOATER");
		}
		else
		{
			if (!flag && (targetPos - base.transform.position).sqrMagnitudeGround() <= 0.0225f)
			{
				pathWalker.AdvanceNode();
			}
			base.transform.position += vector3 * Time.deltaTime * patrolSpeed * 20f;
		}
		pathWalker.LookAt(targetPos, patrolTurnSpeed * 20f);
	}

	private void WaitWell_Enter()
	{
		base.transform.rotation = Quaternion.AngleAxis(UnityEngine.Random.Range(0, 360), Vector3.up);
		room = Map.Get().At(base.transform.position).Room;
		if (room != null)
		{
			room.HasLocalEnemy = true;
		}
		probe = Map.Get().At(base.transform.position).Probe;
		eyes.SetClosed();
		jaw.targetOpenPos = 0f;
		timer = 0f;
		waiting = false;
		randomSounds.Playing = false;
	}

	private void WaitWell_Update()
	{
		if (waiting)
		{
			timer -= Time.deltaTime;
			if (timer <= 0f)
			{
				if (room.PlayerInside)
				{
					base.State = States.RaiseWell;
				}
				else
				{
					waiting = false;
				}
			}
		}
		else if (room.PlayerInside)
		{
			waiting = true;
			if (room.Template.size == RoomTemplate.SizeType.Small)
			{
				timer = UnityEngine.Random.Range(1f, 3f);
			}
			else if (room.Template.size == RoomTemplate.SizeType.Medium)
			{
				timer = UnityEngine.Random.Range(1f, 7f);
			}
			else
			{
				timer = UnityEngine.Random.Range(1f, 11f);
			}
		}
	}

	private void RaiseWell_Enter()
	{
		patrolOrigin = base.transform.position;
		patrolProgress = 0f;
		targetPos = patrolOrigin;
		targetPos.y = floatHeight;
		randomSounds.Playing = true;
	}

	private void RaiseWell_Update()
	{
		targetPos.y = floatHeight + GetFloatBobbing();
		patrolProgress = MoveSmooth(targetPos, patrolOrigin, patrolProgress, patrolSpeed * 0.7f);
		if (patrolProgress >= 1f)
		{
			base.State = States.Patrol;
			if (IsPlayerVisible())
			{
				SpookSounds.Get().PlayScare();
			}
		}
	}

	private bool IsPlayerVisible()
	{
		return Utils.IsPlayerVisible(base.transform, 85f, checkOnlyAngle: false, (!(playerEvadedCooldown > 0f)) ? 8f : 4f);
	}

	private Vector3 GetPatrolTarget()
	{
		List<Point> listValidPos = room.GetListValidPos();
		listOrder.Clear();
		for (int i = 0; i < listValidPos.Count; i++)
		{
			listOrder.Add(i);
		}
		listOrder.Shuffle();
		Point point = Map.Get().WorldToCell(base.transform.position);
		for (int j = 0; j < listOrder.Count; j++)
		{
			Point point2 = listValidPos[listOrder[j]];
			if (!(point2 == point))
			{
				Vector3 result = Map.Get().CellToWorld(point2) + Vector3.up * floatHeight;
				if (pathWalker.CheckLineOfWalk(base.transform.position - Vector3.up + Vector3.up * capCollider.height / 2f, result, checkNoPlayer: true))
				{
					return result;
				}
			}
		}
		return base.transform.position;
	}

	private float MoveSmooth(Vector3 target, Vector3 origin, float progress, float speed)
	{
		progress += speed * Time.deltaTime;
		if (progress >= 1f)
		{
			progress = 1f;
		}
		base.transform.position = Interpolate.EaseInOut(origin, target, progress);
		return progress;
	}

	private float LookAtSmooth(Quaternion rotOriginal, Vector3 pos, float progress, float turnSpeed)
	{
		progress += turnSpeed * Time.deltaTime;
		if (progress >= 1f)
		{
			progress = 1f;
		}
		Vector3 forward = Vector3Ext.GroundVector(pos, base.transform.position);
		forward.Normalize();
		Quaternion to = Quaternion.LookRotation(forward, Vector3.up);
		base.transform.rotation = Interpolate.Slerp(rotOriginal, to, Interpolate.EaseInOut(progress));
		return progress;
	}

	private float DetectMotion(bool forceUpdate = false)
	{
		if (detectMotionFrame == 0 || forceUpdate)
		{
			float num = 1f;
			float num2 = 1f;
			if (!Map.Get().At(base.transform.position).IsVisible())
			{
				num *= 0.4f;
				num2 *= 0.2f;
			}
			detectedMotion -= Time.deltaTime * 20f * 0.15f;
			Vector3 position = player.transform.position;
			Quaternion rotation = playerLook.rotation;
			detectedMotion += GetObjectMotion(lastPlayerPos, lastPlayerRot, position, rotation, 0.0016f, 4f, num, num2);
			if (InputExt.UsingHandControllers)
			{
				Vector3 localPosition = Player.GetLeftHandTransform().localPosition;
				Quaternion localRotation = Player.GetLeftHandTransform().localRotation;
				Vector3 localPosition2 = Player.GetRightHandTransform().localPosition;
				Quaternion localRotation2 = Player.GetLeftHandTransform().localRotation;
				detectedMotion += GetObjectMotion(lastLeftHandPos, lastLeftHandRot, localPosition, localRotation, 0.0001f, 8f, num * 0.75f, num2 * 0.5f) * 0.5f;
				detectedMotion += GetObjectMotion(lastRightHandPos, lastRightHandRot, localPosition2, localRotation2, 0.0001f, 8f, num * 0.75f, num2 * 0.5f) * 0.5f;
				lastLeftHandPos = localPosition;
				lastLeftHandRot = localRotation;
				lastRightHandPos = localPosition2;
				lastRightHandRot = localRotation2;
			}
			detectedMotion = Mathf.Clamp01(detectedMotion);
			lastPlayerPos = position;
			lastPlayerRot = rotation;
		}
		detectMotionFrame++;
		if (detectMotionFrame >= 20)
		{
			detectMotionFrame = 0;
		}
		return detectedMotion;
	}

	private static float GetObjectMotion(Vector3 lastPos, Quaternion lastRot, Vector3 newPos, Quaternion newRot, float minTranslateSq, float minRotate, float rateMovement, float rateRotation)
	{
		float num = 0f;
		Vector3 vector = newPos - lastPos;
		float num2 = Mathf.Abs(Quaternion.Angle(newRot, lastRot));
		if (vector.sqrMagnitude >= minTranslateSq)
		{
			num += 1.5f * rateMovement * Time.deltaTime * 20f;
		}
		if (num2 >= minRotate)
		{
			num += 0.9f * rateRotation * Time.deltaTime * 20f;
		}
		return num;
	}

	private float GetFloatBobbing()
	{
		return Mathf.Cos(Time.realtimeSinceStartup * 0.5f) * 0.075f;
	}

	public static Floater SpawnInRandomRoom(Floater floaterPrefab)
	{
		int num = 0;
		while (num++ < 50)
		{
			Room room = RandomExt.Choice(Map.Get().Rooms);
			if (!room.Safe && !room.PlayerInside && room.floaters.Count == 0 && room.Template.size != 0)
			{
				Floater floater = UnityEngine.Object.Instantiate(floaterPrefab);
				floater.room = room;
				room.floaters.Add(floater);
				return floater;
			}
		}
		return null;
	}

	public static Floater SpawnInWell(Transform spawnPos, Floater floaterPrefab)
	{
		Floater floater = UnityEngine.Object.Instantiate(floaterPrefab, spawnPos.transform.position, Quaternion.identity);
		Map.Get().At(spawnPos.position).Room.floaters.Add(floater);
		return floater;
	}
}
public class GargoyleBehaviour : MonoBehaviour
{
	public bool Standing;

	public bool Discovered;

	public bool CanMove;

	public Renderer ModelRenderer;

	public VisibilityProbe LocalProbe;

	public PlayerGameController player;

	public AnimationClip[] standingPoses;

	public AnimationClip[] crouchingPoses;

	public AnimationClip[] walkingPoses;

	public AnimationClip[] attackPoses;

	private Vector3 LastPosition;

	private bool PlayScare;

	private bool DecidedScare;

	private bool IncreaseMoves;

	private int NumMoves;

	private float ChangePositionTimer;

	private Vector3 InitPosition;

	private Quaternion InitRotation;

	private Transform InitParent;

	public Transform HeadModel;

	public float TurnHeadTime = 6f;

	private float TurnTime;

	private Quaternion LastRotation;

	private bool CanTurn;

	private bool TurnedHead;

	private Pathfinder pathfinder;

	private List<Vector3> path;

	private LayerMask sightMask;

	private bool updateLookAt = true;

	private bool firstAttack = true;

	private void Start()
	{
		Standing = true;
		Discovered = false;
		CanMove = false;
		LocalProbe = Map.Get().At(base.transform.position).Probe;
		player = Player.GetController();
		ModelRenderer = GetComponentInChildren<Renderer>();
		LastPosition = base.transform.position;
		InitParent = base.transform.parent;
		InitPosition = base.transform.position;
		InitRotation = base.transform.rotation;
		TurnTime = TurnHeadTime;
		CanTurn = false;
		TurnedHead = false;
		PlayScare = false;
		DecidedScare = false;
		NumMoves = 0;
		pathfinder = Pathfinder.Get();
		path = new List<Vector3>();
		sightMask = LayerMaskExtensions.NamesToMask("StaticGeometry", "Prop");
		AnimationClip[] arrItems = standingPoses;
		if (CheckLowCeiling())
		{
			arrItems = crouchingPoses;
		}
		string animation = RandomExt.Choice(arrItems).name;
		GetComponent<Animation>().Play(animation);
		GetComponent<Animation>().Sample();
		GetComponent<Animation>().Stop();
		Room room = Map.Get().At(base.transform.position).Room;
		if (room != null && room.Safe)
		{
			base.enabled = false;
		}
	}

	private void Update()
	{
		float sqrMagnitude = (Player.GetPos() - base.transform.position).sqrMagnitude;
		if (!Discovered)
		{
			if (LocalProbe.IsVisible && sqrMagnitude <= 36f)
			{
				if (!Discovered && UnityEngine.Random.value < 0.3f)
				{
					Jukebox.Get().PlaySilence();
				}
				Discovered = true;
				CanMove = true;
			}
			return;
		}
		if (!ModelRenderer.isVisible)
		{
			if (sqrMagnitude >= 225f)
			{
				ResetToInit();
				return;
			}
			if (CanMove && ChangePosition())
			{
				if (!DecidedScare)
				{
					if (Standing)
					{
						PlayScare = true;
					}
					else
					{
						PlayScare = UnityEngine.Random.value < 0.6f;
					}
					float value = UnityEngine.Random.value;
					if (((NumMoves == 0 && value < 0.3f) || (NumMoves == 1 && value < 0.7f) || (NumMoves == 2 && value < 0.8f) || NumMoves >= 3 || !firstAttack) && (Player.GetPos() - base.transform.position).sqrMagnitude <= 5.76f)
					{
						StartCoroutine(TryAttack());
					}
				}
				DecidedScare = true;
				Standing = false;
				IncreaseMoves = true;
			}
			if (!Standing && updateLookAt)
			{
				base.transform.LookAt(new Vector3(Player.GetPos().x, 0f, Player.GetPos().z));
			}
			TurnTime = TurnHeadTime;
			CanTurn = UnityEngine.Random.value < 0.6f;
			TurnedHead = false;
			return;
		}
		CanMove = true;
		LastPosition = base.transform.position;
		ChangePositionTimer = 0f;
		if (LocalProbe.IsVisible && Utils.CheckBoundsInFrustrum(GetComponent<Collider>().bounds))
		{
			if (PlayScare)
			{
				player.GetComponent<SpookSounds>().PlayScare();
			}
			PlayScare = false;
			DecidedScare = false;
			if (IncreaseMoves)
			{
				NumMoves++;
			}
			IncreaseMoves = false;
		}
	}

	private void LateUpdate()
	{
		if (Discovered && ModelRenderer.isVisible && (CanTurn || TurnedHead))
		{
			if (CanTurn)
			{
				Transform transform = GameObject.FindWithTag(Tags.MainCamera).transform;
				Vector3 vector = LastRotation * new Vector3(-1f, 0f, 0f);
				vector.y = 0f;
				Vector3 dir = transform.transform.position - HeadModel.position;
				float sqrMagnitude = dir.sqrMagnitude;
				dir.y = 0f;
				float num = Vector3.Dot(vector, dir.normalized);
				Debug.DrawRay(HeadModel.position, vector, Color.red);
				Debug.DrawRay(HeadModel.position, dir, Color.yellow);
				if (sqrMagnitude <= 6.25f && num >= 0.2f)
				{
					TurnTime -= Time.deltaTime;
					if (TurnTime <= 0f)
					{
						Vector3 fromDirection = transform.position - HeadModel.position;
						fromDirection.y = 0f;
						fromDirection.Normalize();
						vector.y = 0f;
						vector.Normalize();
						Quaternion b = HeadModel.rotation * Quaternion.FromToRotation(fromDirection, vector);
						HeadModel.rotation = Quaternion.Slerp(LastRotation, b, Time.deltaTime * 50.1f);
						TurnedHead = true;
						if (num >= 0.85f)
						{
							CanTurn = false;
						}
					}
				}
			}
			else
			{
				HeadModel.rotation = LastRotation;
			}
		}
		LastRotation = HeadModel.rotation;
	}

	private bool ChangePosition()
	{
		if (ChangePositionTimer > 0f)
		{
			ChangePositionTimer -= Time.deltaTime;
			return false;
		}
		ChangePositionTimer = 0.2f;
		base.transform.parent = null;
		float min = 0.3f;
		float max = 0.6f;
		Room room = Map.Get().At(LastPosition).Room;
		Vector3 vector = Player.GetPos() - LastPosition;
		vector.y = 0f;
		if (vector.sqrMagnitude >= 100f)
		{
			CanMove = false;
		}
		else if (vector.sqrMagnitude < 4f)
		{
			if (Standing)
			{
				return false;
			}
			return true;
		}
		bool flag = false;
		Point point = default(Point);
		bool flag2 = CheckCanSeePlayer();
		Vector3 vector2 = Player.GetPos();
		if (flag2)
		{
			if (Standing || UnityEngine.Random.value <= 0.2f)
			{
				min = 0.1f;
				max = 0.3f;
			}
			else if (NumMoves >= 1 && (NumMoves < 3 || UnityEngine.Random.value <= 0.5f))
			{
				min = 0.4f;
				max = 0.8f;
			}
			else if (NumMoves >= 3)
			{
				min = 0.8f;
				max = 0.9f;
			}
			Debug.DrawLine(LastPosition, LastPosition + Vector3.up * 2f, Color.blue, 5f);
			for (int i = 0; i < 10; i++)
			{
				if (flag)
				{
					break;
				}
				float num = UnityEngine.Random.Range(min, max);
				Vector3 vector3 = vector * num;
				Vector3 vector4 = LastPosition + vector3;
				Vector2 vector5 = UnityEngine.Random.insideUnitCircle * UnityEngine.Random.Range(0f, 1f);
				Vector3 vWorldPos = vector4 + new Vector3(vector5.x, 0f, vector5.y);
				Point point2 = Map.Get().WorldToCell(vWorldPos);
				if (CheckCellIsValidToMove(point2, room))
				{
					flag = true;
					point = point2;
					updateLookAt = true;
				}
			}
		}
		else
		{
			if (Standing || UnityEngine.Random.value <= 0.3f)
			{
				min = 0.1f;
				max = 0.5f;
			}
			else if (NumMoves >= 1)
			{
				min = 0.5f;
				max = 0.8f;
			}
			path.Clear();
			Pathfinder.Query query = pathfinder.AddQuery(Map.Get().WorldToCell(LastPosition), Map.Get().WorldToCell(Player.GetPos()), null, PathWalker.CheckTraversal, PathWalker.GetTraversalCost, null, 0.5f);
			if (pathfinder.RunAStar(query))
			{
				if (query.State == Pathfinder.Query.EState.Success)
				{
					foreach (Point item in query.Path)
					{
						path.Add(Map.Get().CellToWorld(item.X, item.Y));
					}
				}
				pathfinder.FreeQuery(query);
			}
			for (int j = 1; j < path.Count; j++)
			{
				DebugExt.DrawPoint(path[j], Color.green, 0.7f, 5f);
				Debug.DrawLine(path[j - 1], path[j], Color.green, 5f);
			}
			if (path.Count > 1)
			{
				for (int k = 0; k < 10; k++)
				{
					if (flag)
					{
						break;
					}
					int value = (int)((float)path.Count * 100f * UnityEngine.Random.Range(min, max)) / 100;
					value = Mathf.Clamp(value, 0, path.Count - 1);
					Vector3 vector6 = path[value];
					Debug.DrawLine(vector6, vector6 + Vector3.up, Color.yellow, 5f);
					Point point3 = Map.Get().WorldToCell(vector6);
					if (CheckCellIsValidToMove(point3, room))
					{
						flag = true;
						point = point3;
						updateLookAt = false;
						if (value < path.Count - 1)
						{
							vector2 = path[value + 1];
						}
					}
				}
			}
		}
		if (flag)
		{
			Cell cell = Map.Get().At(base.transform.position);
			Cell cell2 = Map.Get().At(InitPosition);
			if (cell.Occupied && cell != cell2)
			{
				cell.Occupied = false;
			}
			Cell cell3 = Map.Get().At(point);
			Vector3 zero = Vector3.zero;
			if (cell3.CheckAdjacency(AdjacencyCode.LeftCenter))
			{
				zero += new Vector3(0.25f, 0f, 0f);
			}
			if (cell3.CheckAdjacency(AdjacencyCode.RightCenter))
			{
				zero += new Vector3(-0.25f, 0f, 0f);
			}
			if (cell3.CheckAdjacency(AdjacencyCode.CenterTop))
			{
				zero += new Vector3(0f, 0f, -0.25f);
			}
			if (cell3.CheckAdjacency(AdjacencyCode.CenterBottom))
			{
				zero += new Vector3(0f, 0f, 0.25f);
			}
			Vector3 position = Map.Get().CellToWorld(point) + zero;
			position.y = Map.Get().FloorHeight(position);
			base.transform.position = position;
			base.transform.LookAt(new Vector3(vector2.x, 0f, vector2.z));
			cell3.Occupied = true;
			LocalProbe = cell3.Probe;
			GetComponent<Animation>().Play(RandomExt.Choice(walkingPoses).name);
			GetComponent<Animation>().Sample();
			GetComponent<Animation>().Stop();
			return true;
		}
		return false;
	}

	private bool CheckCanSeePlayer()
	{
		if (MapLoS.LineOfWalk(LastPosition, Player.GetPos(), canTraverseCorners: true))
		{
			Vector3 direction = Player.GetPos() - LastPosition;
			direction.y = 0f;
			float magnitude = direction.magnitude;
			direction /= magnitude;
			if (!Physics.SphereCast(LastPosition + Vector3.up, 0.4f, direction, out var _, magnitude, sightMask))
			{
				return true;
			}
		}
		return false;
	}

	private bool CheckCellIsValidToMove(Point cellPos, Room curRoom)
	{
		Cell cell = Map.Get().At(cellPos);
		if (cell.Occupied || cell.Room != curRoom || !cell.Probe || cell.Probe.IsVisible || player.IsInExitPath(cellPos) || Map.Get().IsReservedDoor(cellPos))
		{
			return false;
		}
		if (Map.Get().At(cellPos.X - 1, cellPos.Y).IsDoor || Map.Get().At(cellPos.X, cellPos.Y).IsDoor || Map.Get().At(cellPos.X, cellPos.Y - 1).IsDoor || Map.Get().At(cellPos.X, cellPos.Y + 1).IsDoor)
		{
			return false;
		}
		Point pos = new Point(cellPos.X - 1, cellPos.Y + 1);
		Point pos2 = new Point(cellPos.X + 1, cellPos.Y + 1);
		Point pos3 = new Point(cellPos.X - 1, cellPos.Y - 1);
		Point pos4 = new Point(cellPos.X + 1, cellPos.Y - 1);
		if (Map.Get().At(pos).Door != null)
		{
			return false;
		}
		if (Map.Get().At(pos2).Door != null)
		{
			return false;
		}
		if (Map.Get().At(pos3).Door != null)
		{
			return false;
		}
		if (Map.Get().At(pos4).Door != null)
		{
			return false;
		}
		return true;
	}

	private IEnumerator TryAttack()
	{
		yield return new WaitForSeconds(UnityEngine.Random.Range(0.25f, 0.75f));
		if ((!ModelRenderer.isVisible || !LocalProbe.IsVisible) && CanMove)
		{
			Cell cell = Map.Get().At(Player.GetPos());
			Cell cell2 = Map.Get().At(base.transform.position);
			if (cell.Room == cell2.Room && (Player.GetPos() - base.transform.position).sqrMagnitude <= 5.76f)
			{
				float value = UnityEngine.Random.value;
				bool flag = !firstAttack || (NumMoves == 1 && value < 0.35f) || (NumMoves == 2 && value < 0.7f) || (NumMoves > 2 && value < 0.9f);
				player.GetComponent<PlayerGameController>().ApplyAttack((!flag) ? 0.9f : 2f, "GAMEOVER_GARGOYLE");
				GetComponent<Animation>().Play(RandomExt.Choice(attackPoses).name);
				GetComponent<Animation>().Sample();
				GetComponent<Animation>().Stop();
				firstAttack = false;
			}
		}
	}

	private void ResetToInit()
	{
		Cell cell = Map.Get().At(base.transform.position);
		Cell cell2 = Map.Get().At(InitPosition);
		if (cell.Occupied && cell != cell2)
		{
			cell.Occupied = false;
		}
		if ((bool)InitParent)
		{
			base.transform.parent = InitParent;
		}
		base.transform.position = InitPosition;
		base.transform.rotation = InitRotation;
		LastPosition = base.transform.position;
		Standing = true;
		Discovered = false;
		CanMove = false;
		LocalProbe = Map.Get().At(base.transform.position).Probe;
		CanTurn = false;
		TurnedHead = false;
		PlayScare = false;
		DecidedScare = false;
		NumMoves = 0;
		firstAttack = true;
		AnimationClip[] arrItems = standingPoses;
		if (CheckLowCeiling())
		{
			arrItems = crouchingPoses;
		}
		GetComponent<Animation>().Play(RandomExt.Choice(arrItems).name);
		GetComponent<Animation>().Sample();
		GetComponent<Animation>().Stop();
	}

	private bool CheckLowCeiling()
	{
		MapStyle style = Map.Get().Tags.GetStyle(Map.Get().mapStyles, Map.Get().WorldToCell(base.transform.position));
		if (style.ceilingHeight <= 3.4f || Map.Get().At(base.transform.position).GetNumAdjacentWallsNoCorners() >= 3)
		{
			return true;
		}
		if (style.arched)
		{
			Cell cell = Map.Get().At(base.transform.position);
			if ((cell.CheckAdjacency(AdjacencyCode.LeftCenter) && cell.CheckAdjacency(AdjacencyCode.RightCenter)) || (cell.CheckAdjacency(AdjacencyCode.CenterTop) && cell.CheckAdjacency(AdjacencyCode.CenterBottom)))
			{
				return true;
			}
		}
		return false;
	}
}
public class Ghost : MonoBehaviour
{
	private enum EState
	{
		Hidden,
		Discovered,
		StareDown,
		Crying,
		Scream,
		Chase,
		ChaseStretchIn,
		ChaseStretchOut,
		Attack,
		VisionDisappear,
		VisionScare,
		Vanish,
		Appear
	}

	public AudioClip[] SpawnSounds;

	public AudioClip ScreamSound;

	public AudioClip VisionScareSound;

	public AudioClip[] distortSounds;

	public GameObject disappearEffect;

	public RandomSounds AngrySounds;

	public RandomSounds DiscoveredSounds;

	public float ChaseSpeed = 1.5f;

	public float ChaseTurnSpeed = 3f;

	public float ChaseTimeout = 20f;

	public bool isVision;

	public bool isAngryAppear;

	public bool canStretch;

	private bool isCrying;

	private bool isTutorial;

	public Transform vanishPoint;

	public Renderer bodyRenderer;

	public Renderer headRenderer;

	public ShadowCloud shadowCloudPrefab;

	private GhostSpawner GhostSpawner;

	private VisibilityProbe LocalProbe;

	private GameObject player;

	private SpookSounds SpookSounds;

	private Animation meshAnimation;

	private Material bodyVanishMat;

	private Material headVanishMat;

	private CapsuleCollider collider;

	private float colliderRadius;

	private EState State;

	private float TimeOut;

	private float DiscoveredAwareness;

	private float MinDiscovered;

	private bool WasLooking;

	private PathWalker pathWalker;

	private bool rotatingAnim;

	private Vector3 stretchOrigin;

	private Vector3 stretchDest;

	private float stretchFactor;

	private const float stretchInSpeed = 4.7f;

	private const float stretchOutSpeed = 1.6f;

	private bool visionScare;

	private AudioSource visionScream;

	private const float vanishTimeout = 0.3f;

	private void Awake()
	{
		canStretch = GameController.Get().levelOptions.ghostCanStretch && UnityEngine.Random.value <= 0.5f;
	}

	private void Start()
	{
		base.transform.position = new Vector3(base.transform.position.x, Map.Get().FloorHeight(base.transform.position), base.transform.position.z);
		meshAnimation = base.transform.GetComponentInChildren<Animation>();
		LocalProbe = Map.Get().At(base.transform.position).Probe;
		player = Player.Get();
		SpookSounds = player.GetComponent<SpookSounds>();
		GhostSpawner = GameController.Get().GetComponent<GhostSpawner>();
		pathWalker = GetComponent<PathWalker>();
		pathWalker.doorForceChance = 0.25f;
		pathWalker.onBlockedByDoor = OnBlockedByDoor;
		pathWalker.applyFloorNoise = true;
		collider = GetComponent<CapsuleCollider>();
		colliderRadius = collider.radius;
		collider.radius = 1.25f * colliderRadius;
		if (!isAngryAppear)
		{
			InitHidden();
		}
		else
		{
			InitAppear();
		}
	}

	private void Update()
	{
		switch (State)
		{
		case EState.Hidden:
			UpdateHidden();
			break;
		case EState.Discovered:
			UpdateDiscovered();
			break;
		case EState.Crying:
			UpdateCrying();
			break;
		case EState.StareDown:
			UpdateStareDown();
			break;
		case EState.Scream:
			UpdateScream();
			break;
		case EState.Chase:
			UpdateChase();
			break;
		case EState.ChaseStretchIn:
			UpdateChaseStretchIn();
			break;
		case EState.ChaseStretchOut:
			UpdateChaseStretchOut();
			break;
		case EState.Attack:
			UpdateAttack();
			break;
		case EState.VisionDisappear:
			UpdateVisionDisappear();
			break;
		case EState.VisionScare:
			UpdateVisionScare();
			break;
		case EState.Vanish:
			UpdateVanish();
			break;
		case EState.Appear:
			UpdateAppear();
			break;
		}
	}

	private void InitHidden()
	{
		State = EState.Hidden;
		TimeOut = 16f;
		AngrySounds.Playing = false;
		DiscoveredSounds.Playing = false;
		MinDiscovered = ((!(UnityEngine.Random.value < 0.3f)) ? 0f : 0.9f);
		if (!Tutorial.HasBeenShownBefore("TUTO_GHOSTGIRL", add: false) && Config.General().tutorials)
		{
			MinDiscovered = 0f;
			isTutorial = true;
		}
		if (UnityEngine.Random.value <= 0.7f)
		{
			AudioSource.PlayClipAtPoint(RandomExt.Choice(SpawnSounds), base.transform.position);
		}
		if (!isTutorial && UnityEngine.Random.value <= 0.35f)
		{
			MinDiscovered = UnityEngine.Random.Range(0.8f, 1.2f);
			meshAnimation.Play("Idle02");
			isCrying = true;
		}
	}

	private void UpdateHidden()
	{
		GetPlayerPos(out var vToPlayer, out var fPlayerDistSq);
		LookAway(vToPlayer, MinDiscovered);
		if (LocalProbe.IsVisible && fPlayerDistSq <= 36f)
		{
			InitDiscovered();
			return;
		}
		TimeOut -= Time.deltaTime;
		if (TimeOut <= 0f)
		{
			GhostSpawner.OnDisappear(this);
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	private void InitDiscovered()
	{
		State = EState.Discovered;
		GhostSpawner.OnDiscovered();
		TimeOut = UnityEngine.Random.Range(10f, 20f);
		DiscoveredAwareness = MinDiscovered;
		rotatingAnim = false;
		WasLooking = false;
		AngrySounds.Playing = false;
		DiscoveredSounds.Playing = true;
		float value = UnityEngine.Random.value;
		if (value < 0.3f)
		{
			SpookSounds.PlayScare();
		}
		else
		{
			FearEffect.Get().Scare(jumpScare: true);
		}
		if (value < 0.5f)
		{
			Jukebox.Get().PlaySilence();
		}
		GetPlayerPos(out var vToPlayer, out var _);
		LookAway(vToPlayer, DiscoveredAwareness);
		if (!Tutorial.HasBeenShownBefore("TUTO_GHOSTGIRL", add: true))
		{
			StartCoroutine(ShowTutorial_co("TUTO_GHOSTGIRL"));
		}
		if (isCrying)
		{
			State = EState.Crying;
		}
	}

	private void UpdateDiscovered()
	{
		GetPlayerPos(out var vToPlayer, out var fPlayerDistSq);
		LookAway(vToPlayer, DiscoveredAwareness);
		if (!LocalProbe.IsVisible && fPlayerDistSq >= 16f)
		{
			TimeOut -= Time.deltaTime;
			if (TimeOut <= 0f)
			{
				GhostSpawner.OnDisappear(this);
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}
		else if (LocalProbe.IsVisible)
		{
			GhostSpawner.OnDiscovered();
		}
		bool flag = (WasLooking = GetIsPlayerLooking(vToPlayer));
		if (flag)
		{
			DiscoveredAwareness += Time.deltaTime * ((!isTutorial) ? 0.35f : 0.15f);
		}
		DiscoveredAwareness = Mathf.Clamp(DiscoveredAwareness, MinDiscovered, 1f);
		if (DiscoveredAwareness >= 0.3f)
		{
			Jukebox.Get().PlaySilence();
		}
		if (!flag && rotatingAnim)
		{
			meshAnimation.CrossFade("Idle01", 0.6f);
			rotatingAnim = false;
		}
		else if (flag && !rotatingAnim)
		{
			Vector3 normalized = vToPlayer.normalized;
			Vector2 vector = -base.transform.forward.GroundNormalize();
			float y = Vector3.Cross(normalized, vector).y;
			if (y < 0f)
			{
				meshAnimation.CrossFade("TurnRightNoRot", 0.3f);
			}
			else
			{
				meshAnimation.CrossFade("TurnLeftNoRot", 0.3f);
			}
			rotatingAnim = true;
		}
		if (DiscoveredAwareness >= 1f)
		{
			if (UnityEngine.Random.value <= 0.4f)
			{
				InitStareDown();
			}
			else
			{
				InitScream();
			}
		}
	}

	private void UpdateCrying()
	{
		GetPlayerPos(out var vToPlayer, out var _);
		if (!LocalProbe.IsVisible)
		{
			TimeOut -= Time.deltaTime;
			if (TimeOut <= 0f)
			{
				GhostSpawner.OnDisappear(this);
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}
		else if (LocalProbe.IsVisible)
		{
			GhostSpawner.OnDiscovered();
			if (DiscoveredAwareness >= 0.3f)
			{
				Jukebox.Get().PlaySilence();
				FearEffect.Get().Scare();
				Jukebox.Get().SetScreech(10f);
			}
		}
		if (WasLooking = GetIsPlayerLooking(vToPlayer))
		{
			DiscoveredAwareness += Time.deltaTime * ((!isTutorial) ? 0.2f : 0.15f);
		}
		else
		{
			DiscoveredAwareness -= Time.deltaTime * 0.05f;
		}
		DiscoveredAwareness = Mathf.Clamp(DiscoveredAwareness, MinDiscovered, 1f);
		if (DiscoveredAwareness >= 1f)
		{
			if (isVision || UnityEngine.Random.value <= 0.3f)
			{
				InitVanish();
			}
			else
			{
				InitScream();
			}
		}
	}

	private void InitStareDown()
	{
		State = EState.StareDown;
		meshAnimation.CrossFade("Idle01", 0.6f);
		TimeOut = UnityEngine.Random.Range(4f, 6f);
	}

	private void UpdateStareDown()
	{
		GetPlayerPos(out var vToPlayer, out var _);
		LookAway(vToPlayer, 1f);
		FearEffect.Get().Scare();
		Jukebox.Get().SetScreech(10f);
		TimeOut -= Time.deltaTime;
		if (TimeOut <= 0f)
		{
			if (isVision && UnityEngine.Random.value <= 0.4f)
			{
				InitVanish();
			}
			else
			{
				InitScream();
			}
		}
	}

	private void InitScream()
	{
		State = EState.Scream;
		meshAnimation.CrossFade("Scream", 0.2f);
		TimeOut = meshAnimation.GetComponent<Animation>()["Scream"].length - 0.4f;
		SpookSounds.PlayScare(intense: true);
		if (!isVision)
		{
			Jukebox.Get().SetIntense();
		}
		GhostSpawner.OnDiscovered();
		DiscoveredSounds.Playing = false;
		AudioSource.PlayClipAtPoint(ScreamSound, base.transform.position + Vector3.up);
	}

	private void UpdateScream()
	{
		GetPlayerPos(out var vToPlayer, out var _);
		LookAway(vToPlayer, 1f);
		TimeOut -= Time.deltaTime;
		if (TimeOut <= 0f)
		{
			if (isVision)
			{
				InitVanish();
			}
			else
			{
				InitChase();
			}
		}
	}

	private void InitChase()
	{
		State = EState.Chase;
		meshAnimation.CrossFade("Walk", 0.4f);
		pathWalker.Reset();
		pathWalker.ClearPath();
		AngrySounds.Playing = true;
		DiscoveredSounds.Playing = false;
		TimeOut = 0f;
		collider.radius = colliderRadius;
	}

	private void UpdateChase()
	{
		Jukebox.Get().SetIntense();
		GhostSpawner.OnDiscovered();
		Vector3 vToPlayer;
		float fPlayerDistSq;
		Vector3 playerPos = GetPlayerPos(out vToPlayer, out fPlayerDistSq);
		float num = colliderRadius + player.GetComponent<CharacterController>().radius + 0.3f;
		if (fPlayerDistSq <= num * num)
		{
			InitAttack();
			return;
		}
		if (pathWalker.CheckLineOfWalkToPlayer(playerPos))
		{
			pathWalker.MoveTowards(playerPos, ChaseSpeed, ChaseTurnSpeed);
			pathWalker.ClearPath();
			if (canStretch && fPlayerDistSq >= 4f && UnityEngine.Random.value <= 0.0015f)
			{
				InitChaseStretch();
			}
		}
		else
		{
			if (pathWalker.CanSetPath(updateTimeout: true))
			{
				Point closestWalkable = Map.Get().GetClosestWalkable(playerPos);
				pathWalker.SetPath(closestWalkable, CheckTraversal, GetTraversalCost);
			}
			pathWalker.FollowPath(ChaseSpeed, ChaseTurnSpeed, openDoorForce: true);
		}
		bool flag = false;
		if (Physics.Raycast(base.transform.position + Vector3.up, vToPlayer, out var hitInfo, 10f))
		{
			flag = hitInfo.collider.gameObject == player;
		}
		if (!flag)
		{
			TimeOut += Time.deltaTime;
			if (TimeOut >= ChaseTimeout && !meshAnimation.GetComponentInChildren<SkinnedMeshRenderer>().GetComponent<Renderer>().isVisible)
			{
				GhostSpawner.OnDisappear(this);
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}
		else
		{
			TimeOut = 0f;
		}
	}

	private void OnBlockedByDoor(Door door)
	{
		GhostSpawner.OnDisappear(this);
		UnityEngine.Object.Destroy(base.gameObject);
	}

	private void InitChaseStretch()
	{
		Vector3 groundPos = Player.GetGroundPos();
		Vector3 toPosGround = Player.GetToPosGround(base.transform.position);
		Vector3 vector = (toPosGround /= 2f);
		Vector3 normalized = vector.normalized;
		float magnitude = vector.magnitude;
		float num = ((!(UnityEngine.Random.value <= 0.7f)) ? 4f : 2f);
		if (magnitude > num)
		{
			vector = normalized * num;
		}
		stretchOrigin = base.transform.position.ToGround();
		stretchDest = stretchOrigin + vector;
		SetStretchVector(-normalized);
		stretchFactor = 0f;
		if (Map.Get().At(stretchOrigin).IsVisible() || Map.Get().At(stretchDest).IsVisible() || UnityEngine.Random.value <= 0.5f)
		{
			AudioSource.PlayClipAtPoint(RandomExt.Choice(distortSounds), base.transform.position + Vector3.up);
		}
		State = EState.ChaseStretchIn;
	}

	private void UpdateChaseStretchIn()
	{
		stretchFactor = Mathf.Clamp01(stretchFactor + Time.deltaTime * 4.7f);
		float num = Interpolate.EaseOut(stretchFactor);
		Vector3 position = Vector3.Lerp(stretchOrigin, stretchDest, num);
		position.y = Map.Get().FloorHeight(position);
		base.transform.position = position;
		SetStretchFactor((stretchDest - stretchOrigin).magnitude * num);
		SetDistortFactor((0f - num) * 0.15f);
		if (stretchFactor >= 1f)
		{
			State = EState.ChaseStretchOut;
		}
		pathWalker.LookAt(Player.GetPos(), ChaseTurnSpeed * 2f);
	}

	private void UpdateChaseStretchOut()
	{
		stretchFactor = Mathf.Clamp01(stretchFactor - Time.deltaTime * 1.6f);
		float num = Interpolate.EaseOut(stretchFactor);
		SetStretchFactor((stretchDest - stretchOrigin).magnitude * num);
		float num2 = Interpolate.EaseOut(Mathf.Clamp01(stretchFactor * 2f - 1f));
		SetDistortFactor((0f - num2) * 0.15f);
		if (stretchFactor <= 0f)
		{
			State = EState.Chase;
		}
		pathWalker.LookAt(Player.GetPos(), ChaseTurnSpeed);
	}

	private void InitAttack()
	{
		State = EState.Attack;
		meshAnimation.CrossFade("Attack", 0.4f);
		TimeOut = meshAnimation.GetComponent<Animation>()["Attack"].length;
		GhostSpawner.OnDiscovered();
	}

	private void UpdateAttack()
	{
		GetPlayerPos(out var vToPlayer, out var _);
		LookAway(vToPlayer, 1f);
		TimeOut -= Time.deltaTime;
		if (TimeOut <= 0f)
		{
			InitChase();
		}
	}

	private void DoAttack()
	{
		Vector3 vector = Player.GetPos() - base.transform.position;
		vector.y = 0f;
		if (vector.sqrMagnitude <= 4f)
		{
			player.GetComponent<PlayerGameController>().ApplyAttack(1.9f, "GAMEOVER_GHOST");
		}
	}

	private void InitVision()
	{
		State = EState.VisionDisappear;
		GhostSpawner.OnDiscovered();
		TimeOut = UnityEngine.Random.Range(1.5f, 2.5f);
		AngrySounds.Playing = false;
		DiscoveredSounds.Playing = false;
		visionScare = UnityEngine.Random.value <= 0.4f;
		visionScream = null;
		float value = UnityEngine.Random.value;
		if (value < 0.3f)
		{
			SpookSounds.PlayScare();
		}
		else
		{
			FearEffect.Get().Scare(jumpScare: true);
		}
		if (value < 0.5f)
		{
			Jukebox.Get().PlaySilence();
		}
	}

	private void UpdateVisionDisappear()
	{
		GhostSpawner.OnDiscovered();
		GetPlayerPos(out var vToPlayer, out var _);
		LookAway(vToPlayer, 0f);
		TimeOut -= Time.deltaTime;
		if (TimeOut <= 0.1f && !disappearEffect.activeSelf)
		{
			disappearEffect.SetActive(value: true);
			disappearEffect.transform.parent = null;
		}
		if (TimeOut <= 0f)
		{
			if (visionScare)
			{
				InitVisionScare();
			}
			else
			{
				InitVanish();
			}
		}
	}

	private void InitVisionScare()
	{
		State = EState.VisionScare;
		TimeOut = 0.3f;
		meshAnimation.Stop();
		meshAnimation.Play("Scream");
		meshAnimation["Scream"].time = meshAnimation["Scream"].length - 0.4f - 0.2f;
		visionScream = Utils.PlayClipAt(VisionScareSound, base.transform.position);
	}

	private void UpdateVisionScare()
	{
		GhostSpawner.OnDiscovered();
		GetPlayerPos(out var vToPlayer, out var _);
		LookAway(vToPlayer, 1f);
		TimeOut -= Time.deltaTime;
		if (TimeOut <= 0f)
		{
			InitVanish();
		}
	}

	private Vector3 InitVanish()
	{
		State = EState.Vanish;
		TimeOut = 0.3f;
		bodyVanishMat = bodyRenderer.material;
		headVanishMat = headRenderer.material;
		Vector4 vector = vanishPoint.transform.position;
		vector.w = 1f;
		bodyVanishMat.SetVector("_DisappearPoint", vector);
		headVanishMat.SetVector("_DisappearPoint", vector);
		ShadowCloud shadowCloud = UnityEngine.Object.Instantiate(shadowCloudPrefab, vector, Quaternion.identity);
		shadowCloud.initWait = 0.1f;
		if ((bool)visionScream)
		{
			visionScream.transform.parent = shadowCloud.transform;
		}
		return vanishPoint.transform.position;
	}

	private void UpdateVanish()
	{
		TimeOut -= Time.deltaTime;
		float value = Mathf.Clamp01((0.3f - TimeOut) / 0.3f);
		bodyVanishMat.SetFloat("_DisappearFactor", value);
		headVanishMat.SetFloat("_DisappearFactor", value);
		if (TimeOut <= 0f)
		{
			if (!Tutorial.HasBeenShownBefore("TUTO_GHOSTGIRL", add: true) && Config.General().tutorials)
			{
				Tutorial.Get().ShowTextForTime(Translate.Get("TUTO_GHOSTGIRL"), 5f);
			}
			GhostSpawner.OnDisappear(this);
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	private void InitAppear()
	{
		State = EState.Appear;
		TimeOut = 0.3f;
		AngrySounds.Playing = false;
		DiscoveredSounds.Playing = false;
		MinDiscovered = 0.9f;
		DiscoveredAwareness = 1f;
		bodyVanishMat = bodyRenderer.material;
		headVanishMat = headRenderer.material;
		Vector4 value = vanishPoint.transform.position;
		value.w = 1f;
		bodyVanishMat.SetVector("_DisappearPoint", value);
		headVanishMat.SetVector("_DisappearPoint", value);
		bodyVanishMat.SetFloat("_DisappearFactor", 1f);
		headVanishMat.SetFloat("_DisappearFactor", 1f);
	}

	private void UpdateAppear()
	{
		TimeOut -= Time.deltaTime;
		float value = 1f - Mathf.Clamp01((0.3f - TimeOut) / 0.3f);
		bodyVanishMat.SetFloat("_DisappearFactor", value);
		headVanishMat.SetFloat("_DisappearFactor", value);
		if (TimeOut <= 0f)
		{
			InitScream();
		}
	}

	private void LookAway(Vector3 vToPlayer, float factor)
	{
		vToPlayer.Normalize();
		Quaternion quaternion = Quaternion.LookRotation(-vToPlayer, Vector3.up);
		float angle = 180f * factor;
		Quaternion quaternion2 = Quaternion.AngleAxis(angle, Vector3.up);
		base.transform.rotation = quaternion * quaternion2;
	}

	private Vector3 GetPlayerPos(out Vector3 vToPlayer, out float fPlayerDistSq)
	{
		Vector3 groundPos = Player.GetGroundPos();
		vToPlayer = groundPos - base.transform.position;
		fPlayerDistSq = vToPlayer.sqrMagnitude;
		return groundPos;
	}

	private bool GetIsPlayerLooking(Vector3 vToPlayer)
	{
		bool result = false;
		if (LocalProbe.IsVisible)
		{
			Vector3 forward = GameObject.FindWithTag(Tags.LookDirection).transform.forward;
			forward.GroundNormalize();
			float num = Vector3.Angle(forward, -vToPlayer.normalized);
			if (((!WasLooking && num < 35f) || (WasLooking && num < 45f)) && Utils.IsPlayerVisible(base.transform, float.MaxValue, checkOnlyAngle: false, 20f, 1f))
			{
				result = true;
			}
		}
		return result;
	}

	public static float GetTraversalCost(Point from, Point end, object movementDesc)
	{
		Map map = Map.Get();
		if (from.X < 0 || from.X >= map.Width || from.Y < 0 || from.Y >= map.Height || end.X < 0 || end.X >= map.Width || end.Y < 0 || end.Y >= map.Height)
		{
			return float.MaxValue;
		}
		if (map.At(end).IsBehindDoor != 0 && ((from.X == end.X && from.Y == end.Y + 1 && map.At(end).IsBehindDoor == AdjacencyCode.CenterBottom) || (from.X == end.X && from.Y == end.Y - 1 && map.At(end).IsBehindDoor == AdjacencyCode.CenterTop) || (from.Y == end.Y && from.X == end.X - 1 && map.At(end).IsBehindDoor == AdjacencyCode.LeftCenter) || (from.Y == end.Y && from.X == end.X + 1 && map.At(end).IsBehindDoor == AdjacencyCode.RightCenter)))
		{
			return 8f;
		}
		return 1f;
	}

	public static bool CheckTraversal(Point from, Point end, object movementDesc)
	{
		Map map = Map.Get();
		if (from.X <= 0 || from.X >= map.Width - 1 || from.Y <= 0 || from.Y >= map.Height - 1 || end.X <= 0 || end.X >= map.Width - 1 || end.Y <= 0 || end.Y >= map.Height - 1)
		{
			return false;
		}
		Cell cell = map.At(end.X, end.Y);
		if (!cell.CanWalk() || (cell.Occupied && cell.Room != null && cell.Door == null && !cell.IsDoor))
		{
			return false;
		}
		if (from.X != end.X && from.Y != end.Y)
		{
			return false;
		}
		return true;
	}

	public bool IsHidden()
	{
		return State == EState.Hidden;
	}

	public void OnGhostDiscovered()
	{
		if (IsHidden())
		{
			TimeOut = 0f;
		}
	}

	private IEnumerator ShowTutorial_co(string textCode)
	{
		yield return new WaitForSeconds(0.25f);
		if (Config.General().tutorials)
		{
			Tutorial.Get().ShowTextForTime(Translate.Get(textCode), 5f);
		}
	}

	private void SetStretchVector(Vector3 v)
	{
		Renderer[] array = new Renderer[2] { bodyRenderer, headRenderer };
		for (int i = 0; i < 1; i++)
		{
			Transform rootBone = array[i].GetComponent<SkinnedMeshRenderer>().rootBone;
			v = rootBone.transform.InverseTransformDirection(v);
			Vector4 value = new Vector4(v.x, v.y, v.z, 0f);
			for (int j = 0; j < array[i].materials.Length; j++)
			{
				array[i].materials[j].SetVector("_StretchVector", value);
			}
		}
	}

	private void SetStretchFactor(float f)
	{
		Renderer[] array = new Renderer[2] { bodyRenderer, headRenderer };
		for (int i = 0; i < 1; i++)
		{
			for (int j = 0; j < array[i].materials.Length; j++)
			{
				array[i].materials[j].SetFloat("_StretchFactor", f);
			}
		}
	}

	private void SetDistortFactor(float f)
	{
		Renderer[] array = new Renderer[2] { bodyRenderer, headRenderer };
		for (int i = 0; i < array.Length; i++)
		{
			array[i].material.SetFloat("_DistortFactor", f);
		}
	}
}
public class GhostPointing : FSMComponent<GhostPointing.States>
{
	public enum States
	{
		Hidden,
		Pointing,
		Vanish
	}

	public Animator animator;

	public GameObject disappearEffect;

	public Transform vanishPoint;

	public Renderer[] renderers;

	private List<Material> renderMaterials;

	public ShadowCloud shadowCloudPrefab;

	public Vector3 shadowCloudTarget;

	public Transform tutorialPlace;

	private VisibilityProbe localProbe;

	private float TimeOut;

	private const float vanishTimeout = 0.3f;

	private void Start()
	{
		localProbe = Map.Get().At(base.transform.position).Probe;
		renderMaterials = new List<Material>();
		renderMaterials.Clear();
		for (int i = 0; i < renderers.Length; i++)
		{
			for (int j = 0; j < renderers[i].materials.Length; j++)
			{
				renderMaterials.Add(renderers[i].materials[j]);
			}
		}
		if (GameController.Get().gameState.checkPoint != 0)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
		Init(States.Hidden);
	}

	private void Hidden_Enter()
	{
		animator.speed = 0f;
	}

	private void Hidden_Update()
	{
		if (localProbe != null && localProbe.IsVisible)
		{
			base.State = States.Pointing;
		}
	}

	private void Pointing_Enter()
	{
		animator.speed = 1f;
		TimeOut = 9f;
		FearEffect.Get().Scare();
		RandomSounds component = GetComponent<RandomSounds>();
		component.Playing = true;
	}

	private void Pointing_Update()
	{
		Jukebox.Get().SetTension();
		TimeOut -= Time.deltaTime;
		if (TimeOut <= 0f)
		{
			base.State = States.Vanish;
			return;
		}
		float sqrMagnitude = (Player.GetGroundPos() - base.transform.position.ToGround()).sqrMagnitude;
		if (sqrMagnitude <= 9f)
		{
			base.State = States.Vanish;
		}
	}

	private void Vanish_Enter()
	{
		TimeOut = 0.3f;
		Vector4 vector = vanishPoint.transform.position;
		vector.w = 1f;
		for (int i = 0; i < renderMaterials.Count; i++)
		{
			renderMaterials[i].SetVector("_DisappearPoint", vector);
		}
		ShadowCloud shadowCloud = UnityEngine.Object.Instantiate(shadowCloudPrefab, vector, Quaternion.identity);
		shadowCloud.ForceTargetPath(Map.Get().WorldToCell(shadowCloudTarget));
		shadowCloud.initWait = 0.1f;
		RandomSounds component = GetComponent<RandomSounds>();
		component.Playing = false;
	}

	private void Vanish_Update()
	{
		TimeOut -= Time.deltaTime;
		float value = Mathf.Clamp01((0.3f - TimeOut) / 0.3f);
		for (int i = 0; i < renderMaterials.Count; i++)
		{
			renderMaterials[i].SetFloat("_DisappearFactor", value);
		}
		if (TimeOut <= 0f)
		{
			ShowTutorial();
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	private void ShowTutorial()
	{
		TextLabel textLabel = Tutorial.ShowInPlace("TUTO_META_COLLECTOR", Vector3.zero, Quaternion.identity, tutorialPlace, 1f, facePlayer: true);
		if ((bool)textLabel)
		{
			textLabel.gameObject.AddComponent<DistanceDestroyer>();
		}
	}
}
public class GhostSpawner : MonoBehaviour
{
	public GameObject GhostPrefab;

	public float MinWaitShort = 7f;

	public float MaxWaitShort = 25f;

	public float MinWaitLong = 30f;

	public float MaxWaitLong = 90f;

	public float MinDistance = 3f;

	public float MaxDistance = 9f;

	public bool canSpawn = true;

	private float WaitFactor;

	private bool CoolDown;

	private VisibilityProbe[] Spawns;

	private Ghost CurrentPhantom;

	private bool ghostCreatures = true;

	private bool ghostVisions;

	private void Start()
	{
		GameObject[] array = GameObject.FindGameObjectsWithTag(Tags.GhostSpawn);
		Spawns = new VisibilityProbe[array.Length];
		for (int i = 0; i < array.Length; i++)
		{
			Spawns[i] = array[i].GetComponent<VisibilityProbe>();
		}
		WaitFactor = 1f;
		CoolDown = false;
		LevelOptions levelOptions = GameController.Get().levelOptions;
		ghostCreatures = levelOptions.ghosts;
		ghostVisions = levelOptions.ghostVisions;
		if (ghostCreatures || ghostVisions)
		{
			float num = UnityEngine.Random.Range(levelOptions.ghostsMinDelay, levelOptions.ghostsMaxDelay);
			if (num > 0f)
			{
				StartCoroutine(DelayedEnable_co(num));
			}
			StartCoroutine(TrySpawn());
		}
	}

	public void OnDiscovered()
	{
		WaitFactor = UnityEngine.Random.Range(1.5f, 2.5f);
		if (ghostVisions && !ghostCreatures)
		{
			WaitFactor = UnityEngine.Random.Range(1f, 1.5f);
		}
		CoolDown = true;
		GameObject[] array = GameObject.FindGameObjectsWithTag(Tags.Ghost);
		for (int i = 0; i < array.Length; i++)
		{
			Ghost component = array[i].GetComponent<Ghost>();
			if (component != null)
			{
				component.OnGhostDiscovered();
			}
		}
	}

	public void OnDisappear(Ghost ghost)
	{
		if (ghost == CurrentPhantom)
		{
			CurrentPhantom = null;
		}
	}

	private IEnumerator TrySpawn()
	{
		bool bFirst = true;
		while (true)
		{
			if (!canSpawn)
			{
				yield return new WaitForSeconds(5f);
				continue;
			}
			bool bWaitShort = !bFirst && UnityEngine.Random.value < 0.3f;
			bFirst = false;
			float maxWait = ((!bWaitShort) ? MaxWaitLong : MaxWaitShort);
			float minWait2 = ((!bWaitShort) ? MinWaitLong : MinWaitShort);
			maxWait *= WaitFactor;
			minWait2 *= WaitFactor;
			float nextWait = UnityEngine.Random.Range(minWait2, maxWait);
			yield return new WaitForSeconds(nextWait);
			if (CoolDown)
			{
				CoolDown = false;
				continue;
			}
			WaitFactor *= 0.85f;
			WaitFactor = Mathf.Clamp(WaitFactor, 0.1f, 1f);
			if ((bool)CurrentPhantom && CurrentPhantom.IsHidden())
			{
				UnityEngine.Object.Destroy(CurrentPhantom.gameObject);
				CurrentPhantom = null;
			}
			CurrentPhantom = Spawn();
		}
	}

	public Ghost Spawn()
	{
		PlayerGameController controller = Player.GetController();
		Vector3 groundPos = Player.GetGroundPos();
		Vector3 forward = GameObject.FindWithTag(Tags.LookDirection).transform.forward;
		forward.y = 0f;
		forward.Normalize();
		GameObject[] array = GameObject.FindGameObjectsWithTag(Tags.Ghost);
		List<VisibilityProbe> list = new List<VisibilityProbe>();
		VisibilityProbe[] spawns = Spawns;
		foreach (VisibilityProbe visibilityProbe in spawns)
		{
			if (visibilityProbe.IsVisible)
			{
				continue;
			}
			Vector3 to = visibilityProbe.transform.position - groundPos;
			float sqrMagnitude = to.sqrMagnitude;
			if (!(sqrMagnitude <= MaxDistance * MaxDistance) || !(sqrMagnitude >= MinDistance * MinDistance))
			{
				continue;
			}
			to.Normalize();
			float num = Vector3.Angle(forward, to);
			if (!(num < 100f) && (!(sqrMagnitude <= MaxDistance * 0.75f * (MaxDistance * 0.75f)) || !(sqrMagnitude >= MinDistance / 2f * (MinDistance / 2f))))
			{
				continue;
			}
			bool flag = false;
			int num2 = 0;
			while (!flag && num2 < array.Length)
			{
				float sqrMagnitude2 = (array[num2].transform.position - visibilityProbe.transform.position).sqrMagnitude;
				if (sqrMagnitude2 <= 49f)
				{
					flag = true;
				}
				num2++;
			}
			Point pos = Map.Get().WorldToCell(visibilityProbe.transform.position);
			Cell cell = Map.Get().At(pos);
			if (!cell.Occupied && (cell.Room == null || !cell.Room.HasLocalEnemy) && CreatureCounter.GetInRoom(pos) <= 0 && !flag && !controller.IsInExitPath(Map.Get().WorldToCell(visibilityProbe.transform.position)))
			{
				list.Add(visibilityProbe);
			}
		}
		if (list.Count > 0)
		{
			VisibilityProbe visibilityProbe2 = RandomExt.Choice(list);
			GameObject gameObject = UnityEngine.Object.Instantiate(GhostPrefab, visibilityProbe2.transform.position, Quaternion.identity);
			Ghost component = gameObject.GetComponent<Ghost>();
			if (!ghostCreatures && ghostVisions)
			{
				component.isVision = true;
			}
			else if (ghostCreatures && !ghostVisions)
			{
				component.isVision = false;
			}
			else if (ghostCreatures && ghostVisions)
			{
				component.isVision = UnityEngine.Random.value <= 0.2f;
			}
			if (GameController.Get().levelOptions.ghostCanStretch)
			{
				component.canStretch = UnityEngine.Random.value <= 0.7f;
			}
			return component;
		}
		return null;
	}

	private IEnumerator DelayedEnable_co(float delayTime)
	{
		canSpawn = false;
		yield return new WaitForSeconds(delayTime);
		canSpawn = true;
	}
}
public class Jaw : MonoBehaviour
{
	public Transform jawBone;

	public float maxOpenAngle = 10f;

	private float initAngle;

	public float targetOpenPos;

	private float openPos;

	public float speed = 2f;

	private void Start()
	{
		initAngle = jawBone.localRotation.eulerAngles.z;
		targetOpenPos = (openPos = 0f);
	}

	private void Update()
	{
		openPos = Interpolate.Approach(openPos, targetOpenPos, Time.deltaTime * speed);
		Vector3 eulerAngles = jawBone.transform.localRotation.eulerAngles;
		eulerAngles.z = Interpolate.Clerp(initAngle, initAngle + maxOpenAngle, openPos);
		jawBone.transform.localRotation = Quaternion.Euler(eulerAngles);
	}

	public float GetOpenPos()
	{
		return openPos;
	}
}
[RequireComponent(typeof(Light))]
public class LightEatEffect : MonoBehaviour
{
	public Transform target;

	public float displacementMin = 0.1f;

	public float displacementMax = 0.6f;

	public float speed = 0.5f;

	public float factor;

	public LensFlare flare;

	private Vector3 initPos;

	private Vector3 controlPointInit;

	private Vector3 controlPointEnd;

	private bool extinguishing;

	private void Start()
	{
		if (target == null)
		{
			UnityEngine.Object.Destroy(base.gameObject);
			return;
		}
		Vector3 position = target.position;
		initPos = base.transform.position;
		Vector3 vector = position - initPos;
		float magnitude = vector.magnitude;
		vector.Normalize();
		Vector3 vector2 = Vector3.Cross(vector, Vector3.up);
		Vector3 vector3 = Vector3.Cross(vector2, vector);
		Vector3 vector4 = UnityEngine.Random.Range(-1f, 1f) * vector2 + UnityEngine.Random.Range(-1f, 1f) * vector3;
		vector4.Normalize();
		controlPointInit = initPos + vector * magnitude * UnityEngine.Random.Range(0.1f, 0.25f) + vector4 * UnityEngine.Random.Range(displacementMin, displacementMax);
		controlPointEnd = initPos + vector * magnitude * UnityEngine.Random.Range(0.75f, 0.9f) + vector4 * UnityEngine.Random.Range(displacementMin / 3f, displacementMax / 3f);
		factor = 0f;
		flare.color = GetComponent<Light>().color;
		flare.brightness = 0f;
		extinguishing = false;
	}

	private void Update()
	{
		Vector3 position = target.position;
		Vector3 position2 = Interpolate.Bezier(initPos, controlPointInit, controlPointEnd, position, factor);
		base.transform.position = position2;
		factor += speed * Time.deltaTime;
		factor = Mathf.Clamp01(factor);
		flare.brightness = Mathf.Lerp(flare.brightness, GetComponent<Light>().intensity / 2f, 2f * Time.deltaTime);
		if (factor >= 1f || extinguishing)
		{
			GetComponent<Light>().intensity -= GetComponent<Light>().intensity * 2.55f * Time.deltaTime;
			if (GetComponent<Light>().intensity <= 0.1f)
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}
	}

	public void Extinguish()
	{
		extinguishing = true;
	}
}
public class LightEater : FSMComponent<LightEater.States>
{
	public enum States
	{
		HiddenWait,
		HiddenPatrol,
		Patrol,
		Sniff,
		SniffPlayer,
		WalkToLight,
		EatLight,
		Scream,
		Chase,
		Attack,
		SearchPlayer,
		Cooldown,
		StalkRoom
	}

	public float hiddenWalkSpeed = 1f;

	public float hiddenTurnSpeed = 1f;

	public float walkSpeed = 1f;

	public float walkTurnSpeed = 1f;

	public AudioClip[] reactSounds;

	public AudioClip[] screamSounds;

	public RandomSounds patrolSounds;

	public RandomSounds angrySounds;

	public RandomSounds searchSounds;

	private AnimStepSounds animStepSounds;

	public float chaseSpeed = 2f;

	public float chaseTurnSpeed = 2f;

	public float chaseTimeout = 5f;

	public float searchTimeoutMin = 8f;

	public float searchTimeoutMax = 12f;

	public float searchMaxAngle = 40f;

	public float searchMinDist = 0.5f;

	public float searchMaxDist = 2f;

	public float searchAbandonDistance = 24f;

	public float cooldownMinTime = 10f;

	public float cooldownMaxTime = 60f;

	public Room stalkRoom;

	private CreatureVisibility cVisibility;

	public LightEatEffect transitionLightPrefab;

	public Transform lightEndTarget;

	public ParticleSystem eatParticles;

	private GameObject player;

	private TorchFuel playerTorch;

	private SpookSounds spookSounds;

	private Animator animator;

	private BellyLight bellyLight;

	public float aggroLevel;

	private float timer;

	private float timer2;

	private float searchTimer;

	private bool needsCooldown;

	private bool destroyOnCooldown;

	private float timesChased;

	private float detectionFactor = 1f;

	private PathWalker pathWalker;

	private InteractiveLightEx targetLight;

	private LightEatEffect transitionLightFX;

	private void Start()
	{
		player = Player.Get();
		playerTorch = GameObject.FindWithTag(Tags.PlayerTorch).GetComponent<TorchFuel>();
		spookSounds = player.GetComponent<SpookSounds>();
		pathWalker = GetComponent<PathWalker>();
		pathWalker.applyFloorNoise = true;
		animator = GetComponent<Animator>();
		bellyLight = GetComponent<BellyLight>();
		cVisibility = GetComponent<CreatureVisibility>();
		animStepSounds = GetComponent<AnimStepSounds>();
		if (stalkRoom != null)
		{
			Init(States.StalkRoom);
		}
		else if (searchTimer > 1f)
		{
			Init(States.SearchPlayer);
			angrySounds.PlayNow();
		}
		else
		{
			Init(States.HiddenPatrol);
		}
	}

	protected override void Update()
	{
		animator.SetFloat("Speed", 0f);
		pathWalker.applyFloorNoise = !cVisibility.Hidden;
		base.Update();
	}

	private void HiddenPatrol_Enter()
	{
		pathWalker.Reset();
		cVisibility.SetHidden(hidden: true);
		patrolSounds.Playing = true;
		angrySounds.Playing = false;
		searchSounds.Playing = false;
		animStepSounds.playing = false;
		float num = Mathf.Max(0.1f, timesChased * 0.7f);
		if (UnityEngine.Random.value < num)
		{
			needsCooldown = true;
		}
	}

	private void HiddenPatrol_Update()
	{
		if (cVisibility.CheckVisibilize())
		{
			base.State = States.Patrol;
			return;
		}
		if (needsCooldown)
		{
			base.State = States.Cooldown;
			return;
		}
		if (pathWalker.CanSetPath(updateTimeout: true))
		{
			Point patrolTarget = GetPatrolTarget();
			pathWalker.SetPath(patrolTarget, CheckTraversal_Hidden, GetTraversalCost_Hidden);
		}
		if (pathWalker.FollowPath(hiddenWalkSpeed, hiddenTurnSpeed, openDoorForce: false, ignoreDoors: true))
		{
			base.State = States.HiddenWait;
		}
	}

	private float GetTraversalCost_Hidden(Point from, Point end, object movementDesc)
	{
		Map map = Map.Get();
		if (from.X < 0 || from.X >= map.Width || from.Y < 0 || from.Y >= map.Height || end.X < 0 || end.X >= map.Width || end.Y < 0 || end.Y >= map.Height)
		{
			return float.MaxValue;
		}
		return 1f;
	}

	private bool CheckTraversal_Hidden(Point from, Point end, object movementDesc)
	{
		Map map = Map.Get();
		if (from.X <= 0 || from.X >= map.Width - 1 || from.Y <= 0 || from.Y >= map.Height - 1 || end.X <= 0 || end.X >= map.Width - 1 || end.Y <= 0 || end.Y >= map.Height - 1)
		{
			return false;
		}
		Cell cell = map.At(end.X, end.Y);
		if (!cell.CanWalk() || (cell.Occupied && cell.Room != null && cell.Door == null && !cell.IsDoor))
		{
			return false;
		}
		if (from.X != end.X && from.Y != end.Y)
		{
			return false;
		}
		return true;
	}

	private void HiddenWait_Enter()
	{
		timer = UnityEngine.Random.Range(2f, 8f);
		cVisibility.SetHidden(hidden: true);
	}

	private void HiddenWait_Update()
	{
		if (cVisibility.CheckVisibilize())
		{
			base.State = States.Sniff;
			return;
		}
		timer -= Time.deltaTime;
		if (timer <= 0f)
		{
			base.State = States.HiddenPatrol;
		}
	}

	private void Patrol_Enter()
	{
		pathWalker.Reset();
		cVisibility.SetHidden(hidden: false);
		patrolSounds.Playing = true;
		angrySounds.Playing = false;
		searchSounds.Playing = false;
		animStepSounds.playing = true;
	}

	private void Patrol_Update()
	{
		if (!cVisibility.CheckVisibilize())
		{
			base.State = States.HiddenPatrol;
			return;
		}
		SetTensionIfVisible();
		if (pathWalker.CanSetPath(updateTimeout: true))
		{
			Point patrolTarget = GetPatrolTarget();
			pathWalker.SetPath(patrolTarget);
		}
		if (pathWalker.FollowPath(walkSpeed, walkTurnSpeed))
		{
			base.State = States.Sniff;
		}
		else if (UpdateAggro())
		{
			base.State = States.Scream;
		}
		else if (aggroLevel >= 0.5f)
		{
			AudioSource.PlayClipAtPoint(RandomExt.Choice(reactSounds), base.transform.position + Vector3.up);
			base.State = States.SniffPlayer;
		}
	}

	private void Sniff_Enter()
	{
		timer = UnityEngine.Random.Range(2f, 8f);
		cVisibility.SetHidden(hidden: false);
		patrolSounds.Playing = true;
		angrySounds.Playing = false;
		searchSounds.Playing = false;
		animStepSounds.playing = false;
	}

	private void Sniff_Update()
	{
		SetTensionIfVisible();
		timer -= Time.deltaTime;
		if (timer <= 0f)
		{
			Point pos = Map.Get().WorldToCell(base.transform.position);
			List<InteractiveLightEx> list = new List<InteractiveLightEx>();
			Room room = Map.Get().At(pos).Room;
			if (room != null)
			{
				foreach (InteractiveLightEx light in room.lights)
				{
					if (light.lightOn && !light.invulnerable)
					{
						list.Add(light);
					}
				}
			}
			if (list.Count == 0)
			{
				base.State = States.HiddenPatrol;
			}
			else
			{
				targetLight = RandomExt.Choice(list);
				base.State = States.WalkToLight;
			}
		}
		if (UpdateAggro())
		{
			base.State = States.Scream;
		}
	}

	private void SniffPlayer_Enter()
	{
		timer = UnityEngine.Random.Range(2f, 8f);
		cVisibility.SetHidden(hidden: false);
		patrolSounds.Playing = false;
		angrySounds.Playing = false;
		searchSounds.Playing = true;
		animStepSounds.playing = true;
		timesChased += 0.3f;
	}

	private void SniffPlayer_Update()
	{
		FearEffect.Get().Scare();
		SetTensionIfVisible();
		timer -= Time.deltaTime;
		if (timer <= 0f)
		{
			if (searchTimer > 0f)
			{
				base.State = States.SearchPlayer;
			}
			else
			{
				detectionFactor = 1f;
				base.State = States.Patrol;
			}
		}
		if (UpdateAggro())
		{
			detectionFactor = 1f;
			base.State = States.Scream;
		}
	}

	private void WalkToLight_Enter()
	{
		pathWalker.Reset();
		cVisibility.SetHidden(hidden: false);
		patrolSounds.Playing = true;
		angrySounds.Playing = false;
		searchSounds.Playing = false;
		animStepSounds.playing = true;
	}

	private void WalkToLight_Update()
	{
		if (!cVisibility.CheckVisibilize())
		{
			base.State = States.HiddenPatrol;
			return;
		}
		SetTensionIfVisible();
		if (Vector3Ext.GroundVector(base.transform.position, targetLight.transform.position).sqrMagnitude <= 0.25f)
		{
			base.State = States.EatLight;
		}
		else if (pathWalker.CanSetPath(updateTimeout: true))
		{
			Point point = Map.Get().WorldToCell(base.transform.position);
			Point lightPos = Map.Get().WorldToCell(targetLight.transform.position);
			Point lightEatTarget = GetLightEatTarget(lightPos);
			if (point == lightEatTarget)
			{
				base.State = States.EatLight;
			}
			else if (!pathWalker.SetPath(lightEatTarget))
			{
				base.State = States.Patrol;
			}
		}
		if (pathWalker.FollowPath(walkSpeed, walkTurnSpeed))
		{
			base.State = States.EatLight;
		}
		if (UpdateAggro())
		{
			base.State = States.Scream;
		}
	}

	private void EatLight_Enter()
	{
		cVisibility.SetHidden(hidden: false);
		patrolSounds.Playing = false;
		angrySounds.Playing = false;
		searchSounds.Playing = false;
		animStepSounds.playing = true;
		SetParticles(enabled: true);
		timer = 6.6f;
		timer2 = 1f;
		transitionLightFX = null;
	}

	private void EatLight_Update()
	{
		SetTensionIfVisible();
		animator.SetBool("EatLight", value: true);
		timer -= Time.deltaTime;
		if (timer <= 0f)
		{
			base.State = States.Sniff;
			SetParticles(enabled: false);
			return;
		}
		timer2 -= Time.deltaTime;
		if (timer2 <= 0f)
		{
			timer2 = 60f;
			transitionLightFX = UnityEngine.Object.Instantiate(transitionLightPrefab);
			transitionLightFX.target = lightEndTarget;
			Light component = transitionLightFX.GetComponent<Light>();
			Light light = targetLight.GetLight();
			component.range = light.range;
			component.color = light.color;
			component.intensity = light.intensity;
			component.shadows = light.shadows;
			component.shadowStrength = light.shadowStrength;
			component.shadowSoftness = light.shadowSoftness;
			component.shadowSoftnessFade = light.shadowSoftnessFade;
			component.shadowBias = light.shadowBias;
			component.cullingMask = light.cullingMask;
			component.transform.position = light.transform.position;
			component.enabled = true;
			targetLight.TurnOff(fast: true);
		}
		LookAt(targetLight.transform.position, walkTurnSpeed);
		if (UpdateAggro())
		{
			if (transitionLightFX != null)
			{
				transitionLightFX.Extinguish();
				transitionLightFX = null;
			}
			base.State = States.Scream;
		}
	}

	private void EatLight_Exit()
	{
		animator.SetBool("EatLight", value: false);
		SetParticles(enabled: false);
		targetLight = null;
		transitionLightFX = null;
	}

	private void Scream_Enter()
	{
		animator.SetBool("ReactToPlayer", value: true);
		timer = 3.23f;
		AudioSource.PlayClipAtPoint(RandomExt.Choice(screamSounds), base.transform.position + Vector3.up);
		patrolSounds.Playing = false;
		angrySounds.Playing = true;
		searchSounds.Playing = false;
		animStepSounds.playing = true;
		spookSounds.PlayScare(intense: true);
		Jukebox.Get().SetIntense();
	}

	private void Scream_Update()
	{
		Jukebox.Get().SetIntense();
		LookAt(Player.GetPos(), chaseTurnSpeed);
		timer -= Time.deltaTime;
		if (timer <= 0f)
		{
			base.State = States.Chase;
		}
	}

	private void Scream_Exit()
	{
		animator.SetBool("ReactToPlayer", value: false);
	}

	private void Chase_Enter()
	{
		pathWalker.Reset();
		pathWalker.ClearPath();
		timer = chaseTimeout;
		timesChased += 1f;
		patrolSounds.Playing = false;
		angrySounds.Playing = true;
		searchSounds.Playing = false;
		animStepSounds.playing = true;
	}

	private void Chase_Update()
	{
		Jukebox.Get().SetIntense();
		FearEffect.Get().Scare();
		Vector3 groundPos = Player.GetGroundPos();
		float sqrMagnitude = Player.GetToPosGround(base.transform.position).sqrMagnitude;
		float num = GetComponent<CapsuleCollider>().radius + player.GetComponent<CharacterController>().radius + 0.5f;
		if (sqrMagnitude <= num * num)
		{
			base.State = States.Attack;
			return;
		}
		if (pathWalker.CheckLineOfWalkToPlayer(groundPos))
		{
			pathWalker.MoveTowards(groundPos, chaseSpeed, chaseTurnSpeed);
			pathWalker.ClearPath();
		}
		else
		{
			if (pathWalker.CanSetPath(updateTimeout: true))
			{
				Point closestWalkable = Map.Get().GetClosestWalkable(groundPos);
				pathWalker.SetPath(closestWalkable);
			}
			if (pathWalker.FollowPath(chaseSpeed, chaseTurnSpeed, openDoorForce: true))
			{
				pathWalker.ClearPath();
			}
		}
		if (CheckPlayerInLoS())
		{
			timer = chaseTimeout;
			return;
		}
		timer -= Time.deltaTime;
		if (timer <= 0f)
		{
			SetSearchTimer();
			base.State = States.SearchPlayer;
		}
	}

	private void Chase_Exit()
	{
		pathWalker.ClearPath();
	}

	private void Attack_Enter()
	{
		animator.SetBool("AttackPlayer", value: true);
		timer = 1.4f;
		timesChased += 5f;
	}

	private void Attack_Update()
	{
		LookAt(Player.GetPos(), chaseTurnSpeed);
		timer -= Time.deltaTime;
		if (timer < 0f)
		{
			base.State = States.Chase;
		}
	}

	private void Attack_Exit()
	{
		animator.SetBool("AttackPlayer", value: false);
	}

	public void DoAttack()
	{
		if (Vector3Ext.GroundVector(Player.GetPos(), base.transform.position).sqrMagnitude <= 4f)
		{
			player.GetComponent<PlayerGameController>().ApplyAttack(0.6f, "GAMEOVER_LIGHTEATER");
		}
	}

	private void SearchPlayer_Enter()
	{
		pathWalker.Reset();
		pathWalker.ClearPath();
		timesChased += 0.3f;
		detectionFactor = 0.5f;
		cVisibility.SetHidden(hidden: false);
		patrolSounds.Playing = false;
		angrySounds.Playing = false;
		searchSounds.Playing = true;
		animStepSounds.playing = true;
		Tutorial.Get().DoTutorialLight();
	}

	private void SearchPlayer_Update()
	{
		Jukebox.Get().SetTension();
		searchTimer -= Time.deltaTime;
		if (searchTimer <= 0f)
		{
			base.State = States.SniffPlayer;
			return;
		}
		if (Vector3Ext.GroundVector(Player.GetPos(), base.transform.position).sqrMagnitude >= searchAbandonDistance * searchAbandonDistance)
		{
			searchTimer = 0f;
			base.State = States.SniffPlayer;
			return;
		}
		if (pathWalker.CanSetPath(updateTimeout: true))
		{
			Point searchTarget = GetSearchTarget();
			if (searchTarget == Map.Get().WorldToCell(base.transform.position))
			{
				searchTimer = 0f;
				base.State = States.Patrol;
				return;
			}
			pathWalker.SetPath(searchTarget);
		}
		if (pathWalker.FollowPath(walkSpeed, walkTurnSpeed))
		{
			Room room = Map.Get().At(base.transform.position).Room;
			if (room != null && room.PlayerInside)
			{
				searchTimer /= 2f;
			}
			base.State = States.SniffPlayer;
		}
		else if (UpdateAggro())
		{
			detectionFactor = 1f;
			base.State = States.Scream;
		}
		else if (aggroLevel >= 0.5f)
		{
			AudioSource.PlayClipAtPoint(RandomExt.Choice(reactSounds), base.transform.position + Vector3.up);
			base.State = States.SniffPlayer;
		}
	}

	private void Cooldown_Enter()
	{
		cVisibility.SetHidden(hidden: true);
		patrolSounds.Playing = false;
		angrySounds.Playing = false;
		searchSounds.Playing = false;
		animStepSounds.playing = false;
		pathWalker.Reset();
		pathWalker.ClearPath();
		timer = UnityEngine.Random.Range(cooldownMinTime, cooldownMaxTime);
		TeleportRandomRoom();
		if (destroyOnCooldown)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	private void Cooldown_Update()
	{
		timer -= Time.deltaTime;
		if (timer <= 0f && !cVisibility.CheckVisibilize())
		{
			base.State = States.HiddenPatrol;
		}
	}

	private void Cooldown_Exit()
	{
		needsCooldown = false;
		timesChased = 0f;
	}

	private void StalkRoom_Enter()
	{
		Point randomPoint = stalkRoom.GetRandomPoint(central: true);
		if (randomPoint.X != -1 && randomPoint.Y != -1)
		{
			Vector3 vector = Map.Get().CellToWorld(randomPoint);
			base.transform.position = vector + Vector3.up * Map.Get().FloorHeight(vector);
		}
		patrolSounds.Playing = true;
		angrySounds.Playing = false;
		searchSounds.Playing = false;
		animStepSounds.playing = false;
	}

	private void StalkRoom_Update()
	{
		if (GetComponent<Collider>().enabled && !cVisibility.CheckVisibilize())
		{
			cVisibility.SetHidden(hidden: true);
		}
		else if (!GetComponent<Collider>().enabled && cVisibility.CheckVisibilize())
		{
			cVisibility.SetHidden(hidden: false);
		}
		if (Map.Get().At(base.transform.position).IsVisible())
		{
			AudioSource.PlayClipAtPoint(RandomExt.Choice(reactSounds), base.transform.position + Vector3.up);
			base.State = States.SniffPlayer;
		}
	}

	private void StalkRoom_Exit()
	{
		stalkRoom = null;
	}

	private Point GetPatrolTarget()
	{
		Vector3 position = base.transform.position;
		Room room = Map.Get().At(position).Room;
		Point point = new Point(-1, -1);
		int num = 5;
		do
		{
			List<Tuple<Point, Room, float>> list = new List<Tuple<Point, Room, float>>();
			foreach (Room room2 in Map.Get().Rooms)
			{
				if (room2 != room && !room2.Safe)
				{
					Point randomPoint = room2.GetRandomPoint(central: true);
					if (randomPoint.X != -1 && randomPoint.Y != -1)
					{
						float sqrMagnitude = (Map.Get().CellToWorld(randomPoint) - position).sqrMagnitude;
						list.Add(new Tuple<Point, Room, float>(randomPoint, room2, sqrMagnitude));
					}
				}
			}
			list.Sort((Tuple<Point, Room, float> p1, Tuple<Point, Room, float> p2) => (p1.Item3 < p2.Item3) ? (-1) : ((p1.Item3 > p2.Item3) ? 1 : 0));
			point = list[UnityEngine.Random.Range(0, Mathf.Min(3, list.Count))].Item1;
		}
		while ((point.X == -1 || point.Y == -1) && num-- > 0);
		return point;
	}

	private Point GetLightEatTarget(Point lightPos)
	{
		if (!Map.IsBlockedToEnemy(Map.Get().At(lightPos)))
		{
			return lightPos;
		}
		Point point = lightPos;
		int num = 4;
		for (int i = lightPos.X - 1; i <= lightPos.X + 1; i++)
		{
			Point point2 = new Point(i, lightPos.Y);
			if (!Map.IsBlockedToEnemy(Map.Get().At(point2)))
			{
				int numAdjacentWalls = Map.Get().At(point2).GetNumAdjacentWalls();
				if (numAdjacentWalls < num)
				{
					point = point2;
					num = numAdjacentWalls;
				}
			}
		}
		for (int j = lightPos.Y - 1; j <= lightPos.Y + 1; j++)
		{
			Point point3 = new Point(lightPos.X, j);
			if (!Map.IsBlockedToEnemy(Map.Get().At(point3)))
			{
				int numAdjacentWalls2 = Map.Get().At(point3).GetNumAdjacentWalls();
				if (numAdjacentWalls2 < num)
				{
					point = point3;
					num = numAdjacentWalls2;
				}
			}
		}
		if (point == lightPos)
		{
			point = Map.Get().GetClosestWalkable(lightPos);
		}
		return point;
	}

	private Point GetSearchTarget()
	{
		Vector3 vector = Vector3Ext.GroundVector(base.transform.position);
		Vector3 groundPos = Player.GetGroundPos();
		Vector3 vector2 = groundPos - vector;
		float magnitude = vector2.magnitude;
		vector2 /= magnitude;
		int num = 10;
		Vector3 vector3 = vector;
		while (num-- > 0)
		{
			float y = UnityEngine.Random.value * searchMaxAngle - searchMaxAngle / 2f;
			Vector3 vector4 = Quaternion.Euler(0f, y, 0f) * vector2;
			float num2 = UnityEngine.Random.Range(searchMinDist, searchMaxDist);
			num2 *= magnitude;
			vector3 = vector + vector4 * num2;
			Point point = Map.Get().WorldToCell(vector3);
			Cell cell = Map.Get().At(point);
			if (cell != null && cell.CanWalk() && (!cell.Occupied || cell.Room == null || !(cell.Door == null) || cell.IsDoor) && (Map.Get().CellToWorld(point) - groundPos).sqrMagnitude >= 9f)
			{
				return point;
			}
		}
		return Map.Get().WorldToCell(vector);
	}

	private bool UpdateAggro()
	{
		float num = -0.2f;
		bool flag = false;
		Point point = Map.Get().WorldToCell(base.transform.position);
		float sqrMagnitude = Vector3Ext.GroundVector(Player.GetPos(), base.transform.position).sqrMagnitude;
		if (sqrMagnitude <= 225f)
		{
			bool flag2 = Utils.IsPlayerVisible(base.transform, float.MaxValue, checkOnlyAngle: false, 20f, 1f);
			flag = flag2;
			bool flag3 = playerTorch.IsLightOn();
			bool burning = playerTorch.burning;
			if (sqrMagnitude <= 1.44f)
			{
				num = ((!flag3) ? (num + 1.5f * detectionFactor) : (num + 30f * detectionFactor));
			}
			else if (sqrMagnitude <= 3.0625f)
			{
				num = (burning ? (num + 20f * detectionFactor) : ((!flag3) ? (num + 0.5f * detectionFactor) : (num + 2f * detectionFactor)));
			}
			else if (sqrMagnitude <= 9f)
			{
				if (burning)
				{
					num += 0.9f * detectionFactor;
				}
				else if (flag3)
				{
					num += 0.4f * detectionFactor;
				}
				else
				{
					Room room = Map.Get().At(Player.GetPos()).Room;
					if (room == null || room.Template.size != 0)
					{
						num += 0.3f * detectionFactor;
					}
				}
			}
			else if (sqrMagnitude <= 36f)
			{
				if (burning)
				{
					num += 0.9f * detectionFactor;
				}
				else if (flag3)
				{
					num += 0.4f * detectionFactor;
				}
			}
		}
		aggroLevel += Time.deltaTime * num;
		aggroLevel = Mathf.Clamp01(aggroLevel);
		return aggroLevel >= 1f && flag;
	}

	private void SetTensionIfVisible(bool scareEffect = true)
	{
		Point point = Map.Get().WorldToCell(base.transform.position);
		if (point.X < 0 || point.Y < 0 || point.X >= Map.Get().Width || point.Y >= Map.Get().Height)
		{
			base.State = States.Cooldown;
			return;
		}
		bool flag = false;
		Cell cell = Map.Get().At(base.transform.position);
		flag = cell.IsVisible();
		if (!flag && cell.Room != null)
		{
			flag = cell.Room.PlayerInside;
		}
		if (flag)
		{
			Jukebox.Get().SetTension();
			if (scareEffect)
			{
				FearEffect.Get().Scare();
			}
		}
	}

	public void TeleportRandomRoom()
	{
		Vector3 position = base.transform.position;
		Room room = Map.Get().At(position).Room;
		Point point = new Point(-1, -1);
		int num = 5;
		do
		{
			List<Tuple<Point, Room, float>> list = new List<Tuple<Point, Room, float>>();
			foreach (Room room2 in Map.Get().Rooms)
			{
				if (room2 != room && !room2.Safe)
				{
					Point randomPoint = room2.GetRandomPoint(central: true);
					if (randomPoint.X != -1 && randomPoint.Y != -1 && !cVisibility.CheckVisibilize(randomPoint))
					{
						float sqrMagnitude = (Map.Get().CellToWorld(randomPoint) - position).sqrMagnitude;
						list.Add(new Tuple<Point, Room, float>(randomPoint, room2, sqrMagnitude));
					}
				}
			}
			list.Sort((Tuple<Point, Room, float> p1, Tuple<Point, Room, float> p2) => (p1.Item3 < p2.Item3) ? (-1) : ((p1.Item3 > p2.Item3) ? 1 : 0));
			point = list[UnityEngine.Random.Range(0, Mathf.Min(5, list.Count))].Item1;
		}
		while ((point.X == -1 || point.Y == -1) && num-- > 0);
		if (point.X != -1 && point.Y != -1)
		{
			Vector3 vector = Map.Get().CellToWorld(point);
			base.transform.position = vector + Vector3.up * Map.Get().FloorHeight(vector);
		}
	}

	public void SetStalk(Room room)
	{
		stalkRoom = room;
	}

	private bool CheckPlayerInLoS()
	{
		Vector3 vector = Vector3Ext.GroundVector(Player.GetPos()) + Vector3.up;
		Vector3 direction = vector - base.transform.position + Vector3.up;
		if (direction.sqrMagnitude > 256f)
		{
			return false;
		}
		float magnitude = direction.magnitude;
		direction /= magnitude;
		if (Physics.Raycast(base.transform.position + Vector3.up, direction, out var hitInfo, magnitude))
		{
			return hitInfo.collider.gameObject == player.gameObject;
		}
		return false;
	}

	private void SetParticles(bool enabled)
	{
		ParticleSystem[] componentsInChildren = eatParticles.GetComponentsInChildren<ParticleSystem>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].enableEmission = enabled;
		}
		eatParticles.enableEmission = enabled;
	}

	private void LookAt(Vector3 pos, float turnSpeed)
	{
		Vector3 forward = Vector3Ext.GroundVector(pos, base.transform.position);
		forward.Normalize();
		base.transform.rotation = Quaternion.Slerp(base.transform.rotation, Quaternion.LookRotation(forward, Vector3.up), Time.deltaTime * turnSpeed);
	}

	private void SetSearchTimer()
	{
		searchTimer = RandomExt.GaussianRange(searchTimeoutMin, searchTimeoutMax);
	}

	public static LightEater SpawnNextToRoom(Room room)
	{
		MapBuilder component = GameObject.FindWithTag(Tags.GameController).GetComponent<MapBuilder>();
		LightEater lightEaterPrefab = component.lightEaterPrefab;
		Point randomPoint = room.GetRandomPoint(central: true);
		Point point = randomPoint;
		List<Point> list = new List<Point>();
		List<Point> list2 = new List<Point>();
		list2.Add(randomPoint);
		while (list2.Count > 0)
		{
			int index = UnityEngine.Random.Range(0, list2.Count);
			Point curTile = list2[index];
			list2.RemoveAt(index);
			if (list.Exists((Point e) => e == curTile))
			{
				continue;
			}
			list.Add(curTile);
			Cell cell = Map.Get().At(curTile);
			if (cell != null && cell.CanWalk() && (!cell.Occupied || cell.Room == null || !(cell.Door == null) || cell.IsDoor))
			{
				if (cell.Room != room && !cell.IsVisible())
				{
					point = curTile;
					break;
				}
				list2.Add(new Point(curTile.X - 1, curTile.Y));
				list2.Add(new Point(curTile.X + 1, curTile.Y));
				list2.Add(new Point(curTile.X, curTile.Y - 1));
				list2.Add(new Point(curTile.X, curTile.Y + 1));
			}
		}
		if (point == randomPoint)
		{
			return null;
		}
		LightEater lightEater = UnityEngine.Object.Instantiate(lightEaterPrefab, Map.Get().CellToWorld(point), Quaternion.identity);
		lightEater.destroyOnCooldown = true;
		lightEater.SetSearchTimer();
		lightEater.State = States.SearchPlayer;
		return lightEater;
	}

	public static LightEater SpawnNextToPlayer(bool destroy = true, bool setInSearch = true)
	{
		MapBuilder component = GameObject.FindWithTag(Tags.GameController).GetComponent<MapBuilder>();
		LightEater lightEaterPrefab = component.lightEaterPrefab;
		Vector3 pos = Player.GetPos();
		Point point = Map.Get().WorldToCell(pos);
		Point point2 = point;
		Room room = Map.Get().At(point).Room;
		List<Point> list = new List<Point>();
		List<Point> list2 = new List<Point>();
		list2.Add(point);
		while (list2.Count > 0)
		{
			int index = UnityEngine.Random.Range(0, list2.Count);
			Point curTile = list2[index];
			list2.RemoveAt(index);
			if (list.Exists((Point e) => e == curTile))
			{
				continue;
			}
			list.Add(curTile);
			Cell cell = Map.Get().At(curTile);
			if (cell != null && cell.CanWalk())
			{
				if ((!cell.Occupied || cell.Room == null || !(cell.Door == null) || cell.IsDoor) && !cell.IsVisible() && (cell.Room != room || room == null) && (Map.Get().CellToWorld(curTile) - pos).sqrMagnitude > 64f && !cell.CheckLoS(Player.GetCenterEye()))
				{
					point2 = curTile;
					break;
				}
				list2.Add(new Point(curTile.X - 1, curTile.Y));
				list2.Add(new Point(curTile.X + 1, curTile.Y));
				list2.Add(new Point(curTile.X, curTile.Y - 1));
				list2.Add(new Point(curTile.X, curTile.Y + 1));
			}
		}
		if (point2 == point)
		{
			return null;
		}
		Pathfinder pathfinder = Pathfinder.Get();
		Pathfinder.Query query = pathfinder.AddQuery(point2, point, null, PathWalker.CheckTraversal, PathWalker.GetTraversalCost, null, 0.5f);
		if (pathfinder.RunAStar(query))
		{
			if (query.State != Pathfinder.Query.EState.Success)
			{
				pathfinder.FreeQuery(query);
				return null;
			}
			pathfinder.FreeQuery(query);
		}
		LightEater lightEater = UnityEngine.Object.Instantiate(lightEaterPrefab, Map.Get().CellToWorld(point2), Quaternion.identity);
		lightEater.destroyOnCooldown = destroy;
		if (setInSearch)
		{
			lightEater.SetSearchTimer();
			lightEater.searchTimer = 10f;
		}
		return lightEater;
	}
}
public class MusicMoodSetter : MonoBehaviour
{
	public bool tension;

	public bool intense;

	public bool fear;

	public bool setIfSameRoom = true;

	public float updateRate = 0.25f;

	private void Start()
	{
		StartCoroutine(Update_co());
	}

	private IEnumerator Update_co()
	{
		while (true)
		{
			if (intense || tension || fear)
			{
				Cell cell = Map.Get().At(base.transform.position);
				bool flag = cell.IsVisible();
				if (!setIfSameRoom && cell.Room != null)
				{
					flag |= cell.Room.PlayerInside;
				}
				if (flag)
				{
					if (intense)
					{
						Jukebox.Get().SetIntense();
					}
					else if (tension)
					{
						Jukebox.Get().SetTension();
					}
					if (fear)
					{
						FearEffect.Get().Scare();
					}
				}
			}
			yield return new WaitForSeconds(updateRate);
		}
	}
}
public class NavGraph : MonoBehaviour
{
	public GameObject NodePrefab;

	public List<Transform> SpawnPositions;

	public List<NavNode> Nodes;

	private Queue<NavNode> nodeQueue;

	private Dictionary<string, Pair<bool, NavNode>> visitedNodes;

	private Stack<NavNode> pathStack;

	private void Awake()
	{
		SpawnPositions = new List<Transform>();
		Nodes = new List<NavNode>();
		for (int i = 0; i < 2; i++)
		{
			for (int j = i; j < Map.Get().Height - 1; j += 2)
			{
				for (int k = i; k < Map.Get().Width - 1; k += 2)
				{
					Cell cell = Map.Get().At(k, j);
					Cell cell2 = Map.Get().At(k + 1, j);
					Cell cell3 = Map.Get().At(k, j + 1);
					Cell cell4 = Map.Get().At(k + 1, j + 1);
					if (cell.IsClear() && (!cell.Occupied || cell.IsDoor || cell.IsCorridor()) && cell.IsNextToDoor == AdjacencyCode.Clear && cell2.IsClear() && (!cell2.Occupied || cell2.IsDoor || cell2.IsCorridor()) && cell2.IsNextToDoor == AdjacencyCode.Clear && cell3.IsClear() && (!cell3.Occupied || cell3.IsDoor || cell3.IsCorridor()) && cell3.IsNextToDoor == AdjacencyCode.Clear && cell4.IsClear() && (!cell4.Occupied || cell4.IsDoor || cell4.IsCorridor()) && cell4.IsNextToDoor == AdjacencyCode.Clear)
					{
						Vector3 localPosition = Map.Get().CellToWorld(k, j) + new Vector3(Map.Get().TileSize.x, 0f, 0f - Map.Get().TileSize.y) / 2f;
						GameObject gameObject = UnityEngine.Object.Instantiate(NodePrefab);
						gameObject.name = "NavNode_" + k + "_" + j;
						gameObject.transform.parent = base.transform;
						gameObject.transform.localPosition = localPosition;
						NavNode component = gameObject.GetComponent<NavNode>();
						if (component != null)
						{
							Nodes.Add(component);
						}
						if (cell.IsCorridor())
						{
							SpawnPositions.Add(gameObject.transform);
						}
					}
				}
			}
		}
	}

	public bool SearchPath(NavNode from, NavNode to, Queue<NavNode> outPath)
	{
		outPath.Clear();
		if (nodeQueue == null)
		{
			nodeQueue = new Queue<NavNode>();
		}
		nodeQueue.Clear();
		if (visitedNodes == null)
		{
			visitedNodes = new Dictionary<string, Pair<bool, NavNode>>();
		}
		visitedNodes.Clear();
		nodeQueue.Enqueue(from);
		visitedNodes[from.name] = new Pair<bool, NavNode>(first: true, null);
		while (nodeQueue.Count > 0)
		{
			NavNode navNode = nodeQueue.Dequeue();
			if (navNode == to)
			{
				if (pathStack == null)
				{
					pathStack = new Stack<NavNode>();
				}
				pathStack.Clear();
				while (navNode != null)
				{
					pathStack.Push(navNode);
					navNode = visitedNodes[navNode.name].Second;
				}
				outPath.Clear();
				foreach (NavNode item in pathStack)
				{
					outPath.Enqueue(item);
				}
				return true;
			}
			foreach (NavNode neighbour in navNode.Neighbours)
			{
				if (!visitedNodes.ContainsKey(neighbour.name))
				{
					nodeQueue.Enqueue(neighbour);
					visitedNodes[neighbour.name] = new Pair<bool, NavNode>(first: true, navNode);
				}
			}
		}
		return false;
	}

	public NavNode GetClosestNode(Vector3 point)
	{
		NavNode navNode = null;
		float num = float.MaxValue;
		for (int i = 0; i < Nodes.Count; i++)
		{
			NavNode navNode2 = Nodes[i];
			float sqrMagnitude = (navNode2.transform.position - point).sqrMagnitude;
			if (sqrMagnitude < num)
			{
				navNode = navNode2;
				num = sqrMagnitude;
			}
		}
		if (!navNode)
		{
			return null;
		}
		return navNode;
	}
}
public class NavNode : MonoBehaviour
{
	public List<NavNode> Neighbours;

	public int nodeGroup = -1;

	private bool initialized;

	private void Awake()
	{
		Neighbours = new List<NavNode>();
		initialized = false;
	}

	private void Start()
	{
		if (!initialized)
		{
			InitNeighbours();
		}
	}

	private void InitNeighbours()
	{
		initialized = true;
		Collider[] array = Physics.OverlapSphere(base.transform.position, Map.Get().TileSize.x * 1.2f);
		Collider[] array2 = array;
		foreach (Collider collider in array2)
		{
			NavNode component = collider.GetComponent<NavNode>();
			if (component != null && component != this)
			{
				Neighbours.Add(component);
			}
		}
	}

	public int SetGroup(int group)
	{
		if (nodeGroup != group)
		{
			if (!initialized)
			{
				InitNeighbours();
			}
			nodeGroup = group;
			int num = 1;
			for (int i = 0; i < Neighbours.Count; i++)
			{
				num += Neighbours[i].SetGroup(group);
			}
			return num;
		}
		return 0;
	}
}
public class PathWalker : MonoBehaviour
{
	public delegate void OnBlockedByDoor(Door door);

	public Pathfinder pathfinder;

	public List<Vector3> path;

	private List<Vector3> tempPath;

	public float pathTimeout;

	public bool waitingDoor;

	public float doorTimeout;

	public float doorForceChance = 1f;

	public bool doorForceFast;

	public OnBlockedByDoor onBlockedByDoor;

	public bool canFloat;

	public Animator animator;

	public float radiusFactor = 1.1f;

	private LayerMask sightMask;

	public float nodeRange = 0.5f;

	private float nodeRangeSq;

	public float backwardsNodeRange = 0.5f;

	private float backwardsNodeRangeSq;

	public bool applyFloorNoise;

	private void Awake()
	{
		nodeRangeSq = nodeRange * nodeRange;
		if (backwardsNodeRange <= 0f)
		{
			backwardsNodeRange = nodeRange;
		}
		backwardsNodeRangeSq = backwardsNodeRange * backwardsNodeRange;
		path = new List<Vector3>();
		tempPath = new List<Vector3>();
		pathfinder = Pathfinder.Get();
		pathTimeout = 0f;
		if (animator == null)
		{
			animator = GetComponent<Animator>();
		}
		sightMask = LayerMaskExtensions.NamesToMask("StaticGeometry", "Prop", "Default", "Creature");
	}

	public void Reset()
	{
		pathTimeout = 0f;
		waitingDoor = false;
	}

	public void ClearPath()
	{
		path.Clear();
	}

	public bool SetPath(Point target, Pathfinder.CheckTraversalHandler checkTraversal = null, Pathfinder.GetCostHandler traversalCost = null)
	{
		if (target.X != -1 && target.Y != -1)
		{
			if (!BuildPath(path, target, checkTraversal, traversalCost))
			{
				pathTimeout = 2f;
				return false;
			}
			pathTimeout = 0f;
			return true;
		}
		pathTimeout = 0.1f;
		return false;
	}

	public bool BuildPath(List<Vector3> pathRef, Point target, Pathfinder.CheckTraversalHandler checkTraversal, Pathfinder.GetCostHandler traversalCost)
	{
		if (checkTraversal == null)
		{
			checkTraversal = ((!canFloat) ? new Pathfinder.CheckTraversalHandler(CheckTraversal) : new Pathfinder.CheckTraversalHandler(CheckTraversalFloater));
		}
		if (traversalCost == null)
		{
			traversalCost = GetTraversalCost;
		}
		Vector3 vWorldPos = GetPos().ToGround();
		Pathfinder.Query query = pathfinder.AddQuery(Map.Get().WorldToCell(vWorldPos), target, null, checkTraversal, traversalCost, null, 0.5f);
		if (pathfinder.RunAStar(query))
		{
			if (query.State == Pathfinder.Query.EState.Success)
			{
				foreach (Point item in query.Path)
				{
					path.Add(Map.Get().CellToWorld(item.X, item.Y));
				}
				OptimizePath();
			}
			pathfinder.FreeQuery(query);
			return true;
		}
		return false;
	}

	public bool FollowPath(float speed, float turnSpeed, bool openDoorForce = false, bool ignoreDoors = false)
	{
		Vector3 vector = GetPos().ToGround();
		Vector3 vector2 = GetPos();
		if (path.Count != 0)
		{
			Vector3 vector3 = vector;
			if (path.Count >= 1 && CheckNodeInRange(path[0], vector))
			{
				path.RemoveAt(0);
			}
			foreach (Vector3 item in path)
			{
				vector3 = item;
			}
			if (path.Count == 0)
			{
				return true;
			}
			vector2 = path[0].ToGround();
		}
		bool flag = true;
		if ((vector2 - GetPos()).sqrMagnitude <= 3.2399998f)
		{
			Door doorBetweenTiles = Map.Get().GetDoorBetweenTiles(Map.Get().WorldToCell(GetPos()), Map.Get().WorldToCell(vector2));
			if ((bool)doorBetweenTiles && (!doorBetweenTiles.IsOpen || waitingDoor))
			{
				flag = false;
				if (!waitingDoor)
				{
					waitingDoor = true;
					if (openDoorForce)
					{
						bool flag2 = true;
						VisibilityProbe probe = Map.Get().At(base.transform.position).Probe;
						if (probe != null)
						{
							flag2 = !probe.IsVisible;
						}
						if (UnityEngine.Random.value < doorForceChance || !flag2)
						{
							if (doorForceFast)
							{
								doorBetweenTiles.Bash();
								doorBetweenTiles.OpenFast(base.transform);
								doorTimeout = 0f;
							}
							else
							{
								doorBetweenTiles.PlayBashAndOpen(bDoOpen: true, base.transform);
								doorTimeout = 2f;
							}
						}
						else
						{
							doorBetweenTiles.PlayBashAndOpen(bDoOpen: false, base.transform);
							if (onBlockedByDoor != null)
							{
								onBlockedByDoor(doorBetweenTiles);
							}
						}
					}
					else
					{
						doorBetweenTiles.Open(base.transform);
						doorTimeout = 2.5f;
					}
				}
				else
				{
					doorTimeout -= Time.deltaTime;
					if (doorTimeout <= 0f && doorBetweenTiles.IsOpen)
					{
						waitingDoor = false;
					}
				}
			}
			else
			{
				waitingDoor = false;
			}
		}
		if (vector2 != vector && flag && MoveTowards(vector2, vector, speed, turnSpeed))
		{
			if (path.Count > 0)
			{
				path.RemoveAt(0);
			}
			if (path.Count == 0)
			{
				return true;
			}
		}
		return false;
	}

	public bool CanSetPath(bool updateTimeout = false)
	{
		if (path.Count == 0 && pathTimeout <= 0f)
		{
			return true;
		}
		if (updateTimeout && pathTimeout > 0f)
		{
			pathTimeout -= Time.deltaTime;
		}
		return false;
	}

	public Vector3 GetNextNode(bool advanceNodes = true)
	{
		Vector3 vector = GetPos().ToGround();
		Vector3 result = GetPos();
		if (path.Count != 0)
		{
			Vector3 vector2 = vector;
			if (path.Count >= 1 && advanceNodes && CheckNodeInRange(path[0], vector))
			{
				path.RemoveAt(0);
			}
			foreach (Vector3 item in path)
			{
				vector2 = item;
			}
			if (path.Count != 0)
			{
				result = path[0].ToGround();
			}
		}
		return result;
	}

	public bool AdvanceNode()
	{
		if (path.Count > 0)
		{
			path.RemoveAt(0);
		}
		if (path.Count == 0)
		{
			return true;
		}
		return false;
	}

	public bool CheckLineOfWalk(Vector3 targetPos, bool checkNoPlayer = false)
	{
		return CheckLineOfWalk(GetPos(), targetPos, checkNoPlayer);
	}

	public bool CheckLineOfWalk(Vector3 pos, Vector3 targetPos, bool checkNoPlayer = false)
	{
		if (MapLoS.LineOfWalk(pos, targetPos, canTraverseCorners: false, checkNoPlayer, canFloat))
		{
			Vector3 direction = targetPos - pos;
			direction.y = 0f;
			float magnitude = direction.magnitude;
			direction /= magnitude;
			if (!Physics.SphereCast(pos + Vector3.up, GetComponent<CapsuleCollider>().radius * radiusFactor, direction, out var _, (targetPos - pos).magnitude, sightMask))
			{
				return true;
			}
		}
		return false;
	}

	public bool CheckLineOfWalkToPlayer(Vector3 playerPos)
	{
		Vector3 pos = GetPos();
		if (!CheckLineOfWalk(pos, playerPos))
		{
			Point point = Map.Get().WorldToCell(pos);
			Point point2 = Map.Get().WorldToCell(playerPos);
			if (Mathf.Abs(point.X - point2.X) <= 1 && Mathf.Abs(point.Y - point2.Y) <= 1)
			{
				bool flag = true;
				if (Mathf.Abs(point.X - point2.X) == 1 && Mathf.Abs(point.Y - point2.Y) == 1)
				{
					Point point3 = new Point(Mathf.Min(point.X, point2.X), Mathf.Min(point.Y, point2.Y));
					Point point4 = new Point(Mathf.Min(point.X, point2.X), Mathf.Max(point.Y, point2.Y));
					Point point5 = new Point(Mathf.Max(point.X, point2.X), Mathf.Min(point.Y, point2.Y));
					Point point6 = new Point(Mathf.Max(point.X, point2.X), Mathf.Max(point.Y, point2.Y));
					if (!canFloat)
					{
						flag = (Map.Get().At(point3).CanWalk() && !Map.Get().At(point3).Occupied) || point3 == point2 || point3 == point;
						flag &= (Map.Get().At(point4).CanWalk() && !Map.Get().At(point4).Occupied) || point4 == point2 || point4 == point;
						flag &= (Map.Get().At(point5).CanWalk() && !Map.Get().At(point5).Occupied) || point5 == point2 || point5 == point;
						flag &= (Map.Get().At(point6).CanWalk() && !Map.Get().At(point6).Occupied) || point6 == point2 || point6 == point;
					}
					else
					{
						flag = (Map.Get().At(point3).CanWalk() && (!Map.Get().At(point3).Occupied || Map.Get().At(point3).CanFloatOver)) || point3 == point2 || point3 == point;
						flag &= (Map.Get().At(point4).CanWalk() && (!Map.Get().At(point4).Occupied || Map.Get().At(point4).CanFloatOver)) || point4 == point2 || point4 == point;
						flag &= (Map.Get().At(point5).CanWalk() && (!Map.Get().At(point5).Occupied || Map.Get().At(point5).CanFloatOver)) || point5 == point2 || point5 == point;
						flag &= (Map.Get().At(point6).CanWalk() && (!Map.Get().At(point6).Occupied || Map.Get().At(point6).CanFloatOver)) || point6 == point2 || point6 == point;
					}
				}
				if (flag && !Map.Get().At(point).IsDoor && Map.Get().At(point).Door == null && !Map.Get().At(point2).IsDoor)
				{
					return true;
				}
			}
			return false;
		}
		return true;
	}

	public void LookAt(Vector3 pos, float turnSpeed)
	{
		Vector3 vector = Vector3Ext.GroundVector(pos, GetPos());
		if (!(vector == Vector3.zero))
		{
			vector.Normalize();
			SetRot(Quaternion.Slerp(GetRot(), Quaternion.LookRotation(vector, Vector3.up), Time.deltaTime * turnSpeed));
		}
	}

	public bool MoveTowards(Vector3 vTarget, float speed, float turnSpeed)
	{
		vTarget = vTarget.ToGround();
		Vector3 vector = GetPos().ToGround();
		Debug.DrawLine(vector + Vector3.up, vTarget + Vector3.up, Color.cyan);
		return MoveTowards(vTarget, vector, speed, turnSpeed);
	}

	public bool MoveTowards(Vector3 vTarget, Vector3 curPos, float speed, float turnSpeed)
	{
		Vector3 vector = vTarget - curPos;
		vector.Normalize();
		SetPos(GetPos() + vector * Time.deltaTime * speed);
		LookAt(vTarget, turnSpeed);
		if (animator != null)
		{
			animator.SetFloat("Speed", speed);
		}
		return CheckNodeInRange(vTarget, curPos);
	}

	public static float GetTraversalCost(Point from, Point end, object movementDesc)
	{
		Map map = Map.Get();
		if (from.X < 0 || from.X >= map.Width || from.Y < 0 || from.Y >= map.Height || end.X < 0 || end.X >= map.Width || end.Y < 0 || end.Y >= map.Height)
		{
			return float.MaxValue;
		}
		if (map.At(end).IsBehindDoor != 0 && ((from.X == end.X && from.Y == end.Y + 1 && map.At(end).IsBehindDoor == AdjacencyCode.CenterBottom) || (from.X == end.X && from.Y == end.Y - 1 && map.At(end).IsBehindDoor == AdjacencyCode.CenterTop) || (from.Y == end.Y && from.X == end.X - 1 && map.At(end).IsBehindDoor == AdjacencyCode.LeftCenter) || (from.Y == end.Y && from.X == end.X + 1 && map.At(end).IsBehindDoor == AdjacencyCode.RightCenter)))
		{
			return 8f;
		}
		return 1f;
	}

	public static float GetTraversalCostIgnoreBehindDoors(Point from, Point end, object movementDesc)
	{
		Map map = Map.Get();
		if (from.X < 0 || from.X >= map.Width || from.Y < 0 || from.Y >= map.Height || end.X < 0 || end.X >= map.Width || end.Y < 0 || end.Y >= map.Height)
		{
			return float.MaxValue;
		}
		return 1f;
	}

	public static bool CheckTraversal(Point from, Point end, object movementDesc)
	{
		Map map = Map.Get();
		if (from.X <= 0 || from.X >= map.Width - 1 || from.Y <= 0 || from.Y >= map.Height - 1 || end.X <= 0 || end.X >= map.Width - 1 || end.Y <= 0 || end.Y >= map.Height - 1)
		{
			return false;
		}
		Cell cell = map.At(end.X, end.Y);
		if (!cell.CanWalk() || (cell.Occupied && cell.Room != null && cell.Door == null && !cell.IsDoor))
		{
			return false;
		}
		if (from.X != end.X && from.Y != end.Y)
		{
			return false;
		}
		return true;
	}

	public static bool CheckTraversalFloater(Point from, Point end, object movementDesc)
	{
		Map map = Map.Get();
		if (from.X <= 0 || from.X >= map.Width - 1 || from.Y <= 0 || from.Y >= map.Height - 1 || end.X <= 0 || end.X >= map.Width - 1 || end.Y <= 0 || end.Y >= map.Height - 1)
		{
			return false;
		}
		Cell cell = map.At(end.X, end.Y);
		if (!cell.CanWalk() || (cell.Occupied && !cell.CanFloatOver && cell.Room != null && cell.Door == null && !cell.IsDoor))
		{
			return false;
		}
		if (from.X != end.X && from.Y != end.Y)
		{
			return false;
		}
		return true;
	}

	protected virtual Vector3 GetPos()
	{
		return base.transform.position;
	}

	protected virtual void SetPos(Vector3 position)
	{
		if (applyFloorNoise)
		{
			base.transform.position = new Vector3(position.x, Map.Get().FloorHeight(position), position.z);
		}
		else
		{
			base.transform.position = position;
		}
	}

	protected virtual Quaternion GetRot()
	{
		return base.transform.rotation;
	}

	protected virtual void SetRot(Quaternion rotation)
	{
		base.transform.rotation = rotation;
	}

	private void OptimizePath()
	{
		tempPath.Clear();
		if (path.Count <= 2)
		{
			return;
		}
		tempPath.Add(path[0]);
		int num = 1;
		int num2 = 0;
		while (num < path.Count)
		{
			if (num - num2 < 5 && CheckLineOfWalk(path[num2], path[num]))
			{
				if (num == path.Count - 1)
				{
					num2 = num;
					tempPath.Add(path[num]);
				}
				num++;
				continue;
			}
			num2 = num - 1;
			tempPath.Add(path[num - 1]);
			if (num == path.Count - 1)
			{
				tempPath.Add(path[num]);
			}
			num++;
		}
		List<Vector3> list = path;
		path = tempPath;
		tempPath = list;
	}

	private bool CheckNodeInRange(Vector3 target, Vector3 curPos)
	{
		Vector3 vector = target - curPos;
		float num = vector.sqrMagnitudeGround();
		if (num <= nodeRangeSq)
		{
			return true;
		}
		if (Vector3.Dot(base.transform.forward, vector) < 0f)
		{
			return num <= backwardsNodeRangeSq;
		}
		return false;
	}
}
public class PathWalkerStopMotion : PathWalker
{
	public StopMotionAnimator stopMotion;

	protected override Vector3 GetPos()
	{
		return stopMotion.position;
	}

	protected override void SetPos(Vector3 position)
	{
		stopMotion.position = position;
	}

	protected override Quaternion GetRot()
	{
		return stopMotion.rotation;
	}

	protected override void SetRot(Quaternion rotation)
	{
		stopMotion.rotation = rotation;
	}
}
public class Prowler : MonoBehaviour
{
	private enum EState
	{
		Prowling,
		Angry,
		Chasing,
		Attacking,
		CoolDown
	}

	public float WalkSpeed = 1f;

	public float WalkTurnSpeed = 1f;

	public float ChaseSpeed = 2f;

	public float ChaseTurnSpeed = 2f;

	public RandomSounds BreathSounds;

	public RandomSounds AngrySounds;

	public float SightDistance = 8f;

	public float SightFOV = 55f;

	public float AttackDistance = 0.15f;

	public AudioClip AngryRoar;

	public string animWalk = "ProwlEv";

	public string animReaction = "Idle_standing";

	public string animIdle = "Idle_standing";

	public string animRun = "gallop";

	public string animAttack = "AttackEv";

	private EState State;

	private Animation meshAnimation;

	private float TimeOut;

	private NavGraph NavGraph;

	private CreatureVisibility visibility;

	private NavNode NextNode;

	private NavNode LastNode;

	private float NextBreath;

	private bool TargetInView;

	private Transform Target;

	private Vector3 LastTargetPosition;

	private NavNode TargetNode;

	private Queue<NavNode> PathToTarget;

	private float MinDistanceToTarget;

	private bool playScareCue = true;

	private float timeInChase;

	private float loseInterest;

	private bool playerMagnet;

	private float standardColliderRadius;

	private float timeInAttack;

	private bool reactivateOnVisible;

	private static List<int> usedSpawns = new List<int>();

	private void Start()
	{
		meshAnimation = base.transform.GetComponentInChildren<Animation>();
		visibility = GetComponent<CreatureVisibility>();
		NavGraph = GameObject.FindWithTag(Tags.NavGraph).GetComponent<NavGraph>();
		standardColliderRadius = GetComponent<CapsuleCollider>().radius;
		PathToTarget = new Queue<NavNode>();
		InitProwling();
	}

	private void Update()
	{
		Transform transform = CheckPlayerInView();
		TargetInView = transform != null;
		if (TargetInView)
		{
			Target = transform;
			LastTargetPosition = transform.position;
		}
		if (loseInterest > 0f)
		{
			loseInterest -= Time.deltaTime;
		}
		if (State == EState.Prowling)
		{
			UpdateProwling();
		}
		else if (State == EState.Angry)
		{
			UpdateAngry();
		}
		else if (State == EState.Chasing)
		{
			UpdateChase();
		}
		else if (State == EState.Attacking)
		{
			UpdateAttack();
		}
		else if (State == EState.CoolDown)
		{
			UpdateCoolDown();
		}
	}

	private void InitProwling()
	{
		State = EState.Prowling;
		meshAnimation.CrossFade(animWalk);
		Collider[] array = Physics.OverlapSphere(base.transform.position, Map.Get().TileSize.x * 0.5f);
		Collider[] array2 = array;
		foreach (Collider collider in array2)
		{
			NavNode component = collider.GetComponent<NavNode>();
			if (component != null)
			{
				NextNode = (LastNode = component);
				break;
			}
		}
		AngrySounds.Playing = false;
		BreathSounds.Playing = true;
		playScareCue = true;
	}

	private void UpdateProwling()
	{
		if ((NextNode.transform.position - base.transform.position).sqrMagnitudeGround() <= 0.25f)
		{
			NavNode nextNode = NextNode;
			float value = UnityEngine.Random.value;
			bool flag = visibility.Hidden && value <= 0.05f;
			bool flag2 = !flag && visibility.Hidden && value <= 0.125f;
			if (flag)
			{
				NextNode = LastNode;
			}
			else if (flag2)
			{
				InitCoolDown(UnityEngine.Random.Range(4f, 14f), activateVisible: true);
			}
			else if (NextNode.Neighbours.Count > 0)
			{
				List<Pair<NavNode, int>> list = new List<Pair<NavNode, int>>();
				foreach (NavNode neighbour in nextNode.Neighbours)
				{
					if (!(neighbour == LastNode) || nextNode.Neighbours.Count <= 1)
					{
						int second = 100;
						Vector3 rhs = neighbour.transform.position - nextNode.transform.position;
						rhs.Normalize();
						float num = Vector3.Dot(base.transform.forward, rhs);
						if (num < -0.1f)
						{
							second = 1;
						}
						list.Add(new Pair<NavNode, int>(neighbour, second));
					}
				}
				NextNode = RandomExt.WeightedChoice(list);
			}
			LastNode = nextNode;
		}
		Vector3 vector = NextNode.transform.position - base.transform.position;
		vector.Normalize();
		Vector3 position = base.transform.position + vector * Time.deltaTime * WalkSpeed;
		if (!visibility.Hidden)
		{
			position.y = Map.Get().FloorHeight(position);
		}
		base.transform.position = position;
		base.transform.rotation = Quaternion.Slerp(base.transform.rotation, Quaternion.LookRotation(vector, Vector3.up), Time.deltaTime * WalkTurnSpeed);
		if (TargetInView)
		{
			InitAngry();
		}
	}

	private void InitAngry()
	{
		State = EState.Angry;
		meshAnimation.CrossFade(animReaction);
		TimeOut = 2f;
		MinDistanceToTarget = standardColliderRadius + Target.GetComponent<CharacterController>().radius + AttackDistance;
		AudioSource.PlayClipAtPoint(AngryRoar, base.transform.position);
		if (playScareCue)
		{
			Target.GetComponent<SpookSounds>().PlayScare(intense: true);
			playScareCue = false;
		}
		Jukebox.Get().SetIntense();
	}

	private void UpdateAngry()
	{
		Vector3 vec = LastTargetPosition - base.transform.position;
		vec = vec.GroundNormalize();
		base.transform.rotation = Quaternion.Slerp(base.transform.rotation, Quaternion.LookRotation(vec, Vector3.up), Time.deltaTime * WalkTurnSpeed);
		TimeOut -= Time.deltaTime;
		if (TimeOut <= 0f)
		{
			InitChase();
		}
	}

	private void InitChase()
	{
		State = EState.Chasing;
		meshAnimation.CrossFade(animRun);
		TargetNode = null;
		AngrySounds.Playing = true;
		BreathSounds.Playing = false;
		timeInChase = 0f;
	}

	private void UpdateChase()
	{
		Jukebox.Get().SetIntense();
		timeInChase += Time.deltaTime;
		NavNode closestNode = NavGraph.GetClosestNode(LastTargetPosition);
		if (TargetNode == null || closestNode.name != TargetNode.name)
		{
			TargetNode = closestNode;
			if (!NavGraph.SearchPath(NextNode, TargetNode, PathToTarget))
			{
				if (timeInChase <= 0.5f)
				{
					loseInterest = 6f;
				}
				InitAttack();
				return;
			}
			PathToTarget.Enqueue(closestNode);
			NextNode = PathToTarget.Dequeue();
		}
		if ((NextNode.transform.position - base.transform.position).sqrMagnitude <= 0.25f)
		{
			LastNode = NextNode;
			if (PathToTarget.Count <= 0)
			{
				if (timeInChase <= 0.5f)
				{
					loseInterest = 6f;
				}
				InitAttack();
				return;
			}
			NextNode = PathToTarget.Dequeue();
		}
		Vector3 vector = NextNode.transform.position - base.transform.position;
		vector.Normalize();
		Vector3 position = base.transform.position + vector * Time.deltaTime * ChaseSpeed;
		if (!visibility.Hidden)
		{
			position.y = Map.Get().FloorHeight(position);
		}
		base.transform.position = position;
		base.transform.rotation = Quaternion.Slerp(base.transform.rotation, Quaternion.LookRotation(vector.GroundNormalize(), Vector3.up), Time.deltaTime * ChaseTurnSpeed);
		Vector3 vector2 = Target.position - base.transform.position;
		vector2.y = 0f;
		if (vector2.sqrMagnitudeGround() <= MinDistanceToTarget * MinDistanceToTarget)
		{
			vector2.Normalize();
			Vector3 position2 = Target.position - vector2 * MinDistanceToTarget;
			position2.y = Map.Get().FloorHeight(position2);
			base.transform.position = position2;
			if (timeInChase <= 0.5f)
			{
				loseInterest = 6f;
			}
			InitAttack();
		}
		if (PathToTarget.Count <= 0)
		{
			return;
		}
		foreach (NavNode item in PathToTarget)
		{
			Debug.DrawLine(item.transform.position, item.transform.position + Vector3.up * 3f, Color.red);
		}
	}

	private void InitAttack()
	{
		State = EState.Attacking;
		if (CheckPlayerInView(bIgnoreFOV: true) == null && visibility.Hidden)
		{
			InitCoolDown(6f, activateVisible: true);
		}
		meshAnimation.CrossFade(animAttack);
		CapsuleCollider component = GetComponent<CapsuleCollider>();
		component.radius = Target.GetComponent<CharacterController>().radius + AttackDistance;
		component.height *= 2f;
		timeInAttack = 0f;
		playerMagnet = true;
	}

	private void UpdateAttack()
	{
		Vector3 vector = Target.position - base.transform.position;
		vector.y = 0f;
		if (!TargetInView && visibility.Hidden)
		{
			CapsuleCollider component = GetComponent<CapsuleCollider>();
			component.radius = standardColliderRadius;
			component.height /= 2f;
			InitCoolDown(6f, activateVisible: true);
			return;
		}
		if (vector.sqrMagnitude <= 9f)
		{
			Jukebox.Get().SetIntense();
			vector.Normalize();
			Vector3 vector2 = Target.position - vector * MinDistanceToTarget;
			vector2.y = Map.Get().FloorHeight(vector2);
			float num = Vector3.Dot(base.transform.forward, (vector2 - base.transform.position).GroundNormalize());
			if (num >= 0.7f && playerMagnet)
			{
				base.transform.position = vector2;
				Player.GetController().ForceTired();
			}
			base.transform.rotation = Quaternion.Slerp(base.transform.rotation, Quaternion.LookRotation(vector.GroundNormalize(), Vector3.up), Time.deltaTime * ChaseTurnSpeed);
		}
		else
		{
			base.transform.rotation = Quaternion.Slerp(base.transform.rotation, Quaternion.LookRotation(vector.GroundNormalize(), Vector3.up), Time.deltaTime * ChaseTurnSpeed);
		}
		timeInAttack += Time.deltaTime;
		if (!(timeInAttack >= 4f))
		{
			return;
		}
		CapsuleCollider component2 = GetComponent<CapsuleCollider>();
		component2.radius = standardColliderRadius;
		component2.height /= 2f;
		playerMagnet = false;
		if (loseInterest > 0f)
		{
			if (visibility.Hidden)
			{
				InitCoolDown(6f, activateVisible: true);
			}
			else
			{
				InitProwling();
			}
		}
		else
		{
			InitAngry();
		}
	}

	private void DoAttack()
	{
		Vector3 vector = Target.position - base.transform.position;
		vector.y = 0f;
		if (vector.sqrMagnitude <= 9f)
		{
			Target.GetComponent<PlayerGameController>().ApplyAttack(2f, "GAMEOVER_PROWLER");
		}
	}

	private void SetPlayerMagnet(bool active)
	{
		playerMagnet = active;
	}

	private void InitCoolDown(float duration = 6f, bool activateVisible = false)
	{
		State = EState.CoolDown;
		meshAnimation.CrossFade(animIdle);
		reactivateOnVisible = activateVisible;
		TimeOut = duration;
		AngrySounds.Playing = false;
		BreathSounds.Playing = false;
	}

	private void UpdateCoolDown()
	{
		TimeOut -= Time.deltaTime;
		if (TargetInView || CheckVisible())
		{
			InitAngry();
		}
		else if (TimeOut < 0f)
		{
			if (visibility.Hidden && UnityEngine.Random.value <= 0.65f && GetSpawnPoint(out var vSpawn, NavGraph, checkVisibility: true))
			{
				base.transform.position = vSpawn;
			}
			InitProwling();
		}
		else if (reactivateOnVisible && !visibility.Hidden)
		{
			InitProwling();
		}
	}

	private Transform CheckPlayerInView(bool bIgnoreFOV = false)
	{
		if (loseInterest > 0f)
		{
			return null;
		}
		float num = SightDistance * ((State != 0) ? 2f : 1f);
		if (!bIgnoreFOV)
		{
			Quaternion quaternion = Quaternion.AngleAxis(SightFOV / 2f, Vector3.up);
			Quaternion quaternion2 = Quaternion.AngleAxis((0f - SightFOV) / 2f, Vector3.up);
			Vector3 vector = quaternion * base.transform.forward;
			Vector3 vector2 = quaternion2 * base.transform.forward;
			Debug.DrawLine(base.transform.position, base.transform.position + vector * num, Color.magenta);
			Debug.DrawLine(base.transform.position, base.transform.position + vector2 * num, Color.magenta);
			Debug.DrawLine(base.transform.position + vector * num, base.transform.position + vector2 * num, Color.magenta);
		}
		Vector3 pos = Player.GetPos();
		Vector3 rhs = pos - base.transform.position;
		float sqrMagnitude = rhs.sqrMagnitude;
		if (sqrMagnitude <= num * num)
		{
			rhs.Normalize();
			float num2 = Vector3.Dot(base.transform.forward, rhs);
			float num3 = Mathf.Cos((float)Math.PI / 180f * SightFOV / 2f);
			if ((bIgnoreFOV || num2 > num3 || sqrMagnitude <= 16f) && (!Physics.Linecast(base.transform.position + Vector3.up, pos + Vector3.up, out var hitInfo) || hitInfo.collider.gameObject.CompareTag(Tags.Player) || hitInfo.collider.gameObject == base.gameObject))
			{
				return Player.Get().transform;
			}
		}
		return null;
	}

	private bool CheckVisible()
	{
		VisibilityProbe probe = Map.Get().At(base.transform.position).Probe;
		if (probe != null && probe.IsVisible)
		{
			return true;
		}
		probe = Map.Get().At(base.transform.position + base.transform.forward).Probe;
		if (probe != null && probe.IsVisible)
		{
			return true;
		}
		probe = Map.Get().At(base.transform.position - base.transform.forward).Probe;
		if (probe != null && probe.IsVisible)
		{
			return true;
		}
		return false;
	}

	private static bool GetSpawnPoint(out Vector3 vSpawn, NavGraph navGraph, bool checkVisibility = false)
	{
		usedSpawns.Clear();
		int num = 10;
		while (num-- > 0)
		{
			int num2 = UnityEngine.Random.Range(0, navGraph.SpawnPositions.Count);
			if (!usedSpawns.Contains(num2))
			{
				usedSpawns.Add(num2);
				vSpawn = navGraph.SpawnPositions[num2].position;
				if (!checkVisibility || !MapChunk.At(Map.Get().WorldToCell(vSpawn)).Visible)
				{
					return true;
				}
			}
		}
		vSpawn = Vector3.zero;
		return false;
	}
}
public class ShadowChaser : FSMComponent<ShadowChaser.States>
{
	public enum States
	{
		Hidden,
		Raise_Idle,
		Raise,
		Idle,
		Idle_Distort,
		Chase_Stretch_In,
		Chase_Stretch_Out,
		Go_Under_Door,
		Disappearing,
		Destroying
	}

	private VisibilityProbe probe;

	private Transform playerLook;

	private AnimWarper animWarper;

	private Animator animator;

	private PathWalker pathWalker;

	private CreatureVisibility cVisibility;

	public ParticleSystem groundSmoke;

	public Material solidMaterial;

	public Material transparentMaterial;

	private bool hasTransparentMaterial = true;

	private float materialAlpha = 1f;

	public bool raiseFast;

	public bool isVision;

	public bool isAngry;

	public bool superAggressive;

	private bool discovered;

	public float chaseSpeed = 1f;

	public float chaseTurnSpeed = 1f;

	private Vector3 stretchOrigin;

	private Vector3 stretchDest;

	private float stretchFactor;

	private const float stretchInSpeed = 4.7f;

	private const float stretchOutSpeed = 1.6f;

	private Vector3 originalCurveDir;

	private Vector3 newCurveDir;

	private float originalCurveIntensity;

	private float newCurveIntensity;

	private float originalNarrowFactor;

	private float newNarrowFactor;

	private const float timeFactor = 0.5f;

	private float timeIdle;

	public AudioSource chaseSound;

	public AudioClip[] chaseSoundClips;

	public AudioClip[] distortClips;

	public SoundLoop raiseSound;

	public SoundLoop whisperSound;

	private MusicMoodSetter moodSetter;

	private float timer;

	private void Start()
	{
		probe = Map.Get().At(base.transform.position).Probe;
		playerLook = Player.GetLook();
		animWarper = GetComponent<AnimWarper>();
		animator = GetComponent<Animator>();
		pathWalker = GetComponent<PathWalker>();
		cVisibility = GetComponent<CreatureVisibility>();
		moodSetter = GetComponent<MusicMoodSetter>();
		Init(States.Hidden);
	}

	private void Hidden_Enter()
	{
		raiseFast = false;
		if (isAngry)
		{
			raiseFast = true;
		}
		float value = UnityEngine.Random.value;
		animWarper.curveDirection = GetNewCurveDir(base.transform.position);
		LookAtPlayer();
		timer = UnityEngine.Random.Range(8f, 16f);
		if (!probe.IsVisible && value <= 0.5f)
		{
			animWarper.verticalCollapse = 0f;
			base.State = States.Idle;
			SetBodyAlpha(1f);
		}
		else if (!probe.IsVisible && value <= 0.8f)
		{
			animWarper.verticalCollapse = 1f - UnityEngine.Random.Range(0.3f, 0.5f);
			SetBodyAlpha(1f);
		}
		else
		{
			SetBodyAlpha(0f);
		}
		Room room = Map.Get().At(base.transform.position).Room;
		if (room != null && room.PlayerInside)
		{
			value = UnityEngine.Random.value;
			if (value <= 0.2f)
			{
				Jukebox.Get().PlaySilence();
			}
			else if (value <= 0.4f && !superAggressive)
			{
				moodSetter.tension = true;
			}
		}
	}

	private void Hidden_Update()
	{
		if (probe.IsVisible)
		{
			if (UnityEngine.Random.value <= 0.7f && !raiseFast)
			{
				base.State = States.Raise_Idle;
			}
			else
			{
				base.State = States.Raise;
			}
			return;
		}
		timer -= Time.deltaTime;
		if (timer <= 0f)
		{
			base.State = States.Disappearing;
		}
	}

	private void Raise_Idle_Enter()
	{
		timer = UnityEngine.Random.Range(1.5f, 3.5f) * 0.5f;
	}

	private void Raise_Idle_Update()
	{
		timer -= Time.deltaTime;
		if (timer <= 0f)
		{
			base.State = States.Raise;
		}
		AddBodyAlpha(Time.deltaTime * 0.15f);
		animator.speed = 1f - animWarper.verticalCollapse;
		UpdateHeadTracking();
	}

	private void Raise_Enter()
	{
		groundSmoke.enableEmission = false;
		if (discovered || UnityEngine.Random.value <= 0.6f)
		{
			raiseSound.targetVolume = 1f;
		}
		whisperSound.targetVolume = 0f;
	}

	private void Raise_Update()
	{
		float num = 0.1f * ((!raiseFast) ? 1.5f : 2f) * ((!superAggressive) ? 1f : 2f);
		animWarper.verticalCollapse -= Time.deltaTime * num;
		animWarper.verticalCollapse = Mathf.Clamp01(animWarper.verticalCollapse);
		if (animWarper.verticalCollapse <= 0f)
		{
			base.State = States.Idle;
		}
		AddBodyAlpha(Time.deltaTime * 0.25f * ((!raiseFast) ? 1f : 2f) * ((!superAggressive) ? 1f : 2f));
		animator.speed = 1f - animWarper.verticalCollapse;
		UpdateHeadTracking();
		if (UpdateDiscovered())
		{
			raiseSound.targetVolume = 1f;
		}
	}

	private void Raise_Exit()
	{
		raiseSound.targetVolume = 0f;
	}

	private void Idle_Enter()
	{
		groundSmoke.enableEmission = false;
		timer = UnityEngine.Random.Range(2f, 4f) * 0.5f;
		animator.speed = 1f;
		whisperSound.targetVolume = ((!(UnityEngine.Random.value <= 0.75f)) ? 0f : 1f);
		if (!superAggressive)
		{
			moodSetter.tension = true;
		}
		timeIdle = 0f;
	}

	private void Idle_Update()
	{
		bool flag = false;
		bool hidden = cVisibility.Hidden;
		timer -= Time.deltaTime;
		timeIdle += Time.deltaTime;
		if (timer <= 0f)
		{
			float value = UnityEngine.Random.value;
			if (!isAngry && !isVision)
			{
				Cell cell = Map.Get().At(base.transform.position);
				flag = !hidden && IsPlayerVisible();
				bool flag2 = cell.Room != null && cell.Room.PlayerInside;
				if (value <= 0.1f || (!flag && !flag2 && timeIdle > 15f))
				{
					base.State = States.Disappearing;
				}
				else if (value <= 0.4f && flag && discovered)
				{
					base.State = States.Chase_Stretch_In;
				}
				else if (value <= 0.6f && cell.IsVisible())
				{
					base.State = States.Idle_Distort;
				}
				else
				{
					timer = UnityEngine.Random.Range(2f, 6f) * 0.5f;
					whisperSound.targetVolume = ((!(UnityEngine.Random.value <= 0.65f)) ? 0f : 1f);
				}
			}
			else if (isAngry && !superAggressive)
			{
				if (hidden && value <= 0.4f)
				{
					base.State = States.Disappearing;
				}
				else if (value <= 0.05f)
				{
					base.State = States.Disappearing;
				}
				else if (value <= 0.25f)
				{
					base.State = States.Idle_Distort;
				}
				else if (value <= 0.85f)
				{
					base.State = States.Chase_Stretch_In;
				}
				else
				{
					timer = UnityEngine.Random.Range(1f, 3f) * 0.5f;
					whisperSound.targetVolume = ((!(UnityEngine.Random.value <= 0.65f)) ? 0f : 1f);
				}
			}
			else if (isAngry && superAggressive)
			{
				if (value <= 0.25f)
				{
					base.State = States.Idle_Distort;
				}
				else if (value <= 0.85f)
				{
					base.State = States.Chase_Stretch_In;
				}
				else
				{
					timer = UnityEngine.Random.Range(0.5f, 1.5f) * 0.5f;
					whisperSound.targetVolume = ((!(UnityEngine.Random.value <= 0.65f)) ? 0f : 1f);
				}
			}
			else if (isVision)
			{
				Cell cell2 = Map.Get().At(base.transform.position);
				flag = !hidden && IsPlayerVisible();
				if (value <= 0.4f)
				{
					base.State = States.Disappearing;
				}
				else if (value <= 0.6f && cell2.IsVisible())
				{
					base.State = States.Idle_Distort;
				}
				else
				{
					timer = UnityEngine.Random.Range(1f, 4f);
					whisperSound.targetVolume = ((!(UnityEngine.Random.value <= 0.65f)) ? 0f : 1f);
				}
			}
		}
		UpdateHeadTracking(flag);
		UpdateDiscovered();
	}

	private void Idle_Distort_Enter()
	{
		stretchFactor = 0f;
		animator.speed = 1f;
		originalCurveDir = animWarper.curveDirection;
		if (UnityEngine.Random.value <= 0.5f)
		{
			newCurveDir = GetNewCurveDir(base.transform.position);
		}
		else
		{
			newCurveDir = originalCurveDir;
		}
		chaseSound.Stop();
		chaseSound.clip = RandomExt.Choice(distortClips);
		chaseSound.Play();
	}

	private void Idle_Distort_Update()
	{
		stretchFactor = Mathf.Clamp01(stretchFactor + Time.deltaTime * 4.7f);
		float t = Interpolate.EaseOut(stretchFactor);
		float num = stretchFactor * 2f;
		if (num > 1f)
		{
			num = 2f - num;
		}
		num = Interpolate.EaseOut(Mathf.Clamp01(num));
		animWarper.bodyRenderer.material.SetFloat("_DistortFactor", num * 0.45f + Mathf.PerlinNoise(0f, Time.time * 20f) * num * 0.1f);
		animWarper.curveDirection = Vector3.Slerp(originalCurveDir, newCurveDir, t);
		animWarper.verticalCollapse -= Time.deltaTime * 3f;
		animWarper.verticalCollapse = Mathf.Clamp01(animWarper.verticalCollapse);
		if (stretchFactor >= 1f)
		{
			base.State = States.Idle;
		}
		pathWalker.LookAt(Player.GetPos(), chaseTurnSpeed * 20f);
	}

	private void Chase_Stretch_In_Enter()
	{
		pathWalker.Reset();
		pathWalker.ClearPath();
		Vector3 groundPos = Player.GetGroundPos();
		Vector3 toPosGround = Player.GetToPosGround(base.transform.position);
		Vector3 vector = Vector3.zero;
		if (pathWalker.CheckLineOfWalkToPlayer(groundPos))
		{
			vector = toPosGround;
			if (!isAngry)
			{
				vector /= 2f;
			}
		}
		else
		{
			Point closestWalkable = Map.Get().GetClosestWalkable(groundPos);
			if (pathWalker.SetPath(closestWalkable))
			{
				if (cVisibility.Hidden && isAngry && UnityEngine.Random.value <= 0.7f)
				{
					for (int num = pathWalker.path.Count - 1; num > 0; num--)
					{
						Vector3 vector2 = pathWalker.path[num];
						if (!Map.Get().At(vector2).IsVisible())
						{
							base.transform.position = Map.Get().CellToWorld(Map.Get().WorldToCell(vector2));
							base.State = States.Idle;
							return;
						}
					}
				}
				bool flag = false;
				for (int i = 0; i < pathWalker.path.Count; i++)
				{
					if (flag)
					{
						break;
					}
					Vector3 vector3 = pathWalker.path[i];
					if (Map.Get().At(vector3).DoorSide != 0)
					{
						vector3 = Map.Get().CellToWorld(Map.Get().WorldToCell(vector3));
					}
					vector = (vector3 - base.transform.position).ToGround();
					if (vector.sqrMagnitude >= 0.36f)
					{
						flag = true;
					}
				}
				if (!flag)
				{
					vector = toPosGround;
				}
				pathWalker.ClearPath();
			}
			else
			{
				base.State = States.Idle;
			}
		}
		Vector3 normalized = vector.normalized;
		float magnitude = vector.magnitude;
		float num2 = ((!isAngry) ? 2f : ((!(UnityEngine.Random.value <= 0.7f)) ? 4f : 2f));
		if (magnitude > num2)
		{
			vector = normalized * num2;
		}
		stretchOrigin = base.transform.position.ToGround();
		stretchDest = stretchOrigin + vector;
		SetStretchVector(-normalized);
		stretchFactor = 0f;
		originalCurveDir = animWarper.curveDirection;
		newCurveDir = GetNewCurveDir(stretchDest);
		bool flag2 = CheckNarrow(stretchDest);
		originalNarrowFactor = animator.GetFloat("Narrow");
		newNarrowFactor = ((!flag2) ? 0f : 1f);
		originalCurveIntensity = animWarper.curveIntensity;
		newCurveIntensity = ((!flag2) ? UnityEngine.Random.Range(0.7f, 1f) : UnityEngine.Random.Range(0.2f, 0.5f));
		Door doorBetweenTiles = Map.Get().GetDoorBetweenTiles(Map.Get().WorldToCell(stretchOrigin), Map.Get().WorldToCell(stretchDest));
		if (doorBetweenTiles != null && !doorBetweenTiles.IsOpen)
		{
			base.State = States.Go_Under_Door;
		}
		else if (!cVisibility.Hidden || Map.Get().At(stretchOrigin).IsVisible() || Map.Get().At(stretchDest).IsVisible() || UnityEngine.Random.value <= 0.5f)
		{
			chaseSound.Stop();
			chaseSound.clip = RandomExt.Choice(chaseSoundClips);
			chaseSound.Play();
		}
		isAngry = isAngry || UnityEngine.Random.value <= 0.6f;
	}

	private void Chase_Stretch_In_Update()
	{
		stretchFactor = Mathf.Clamp01(stretchFactor + Time.deltaTime * 4.7f);
		float num = Interpolate.EaseOut(stretchFactor);
		Vector3 position = Vector3.Lerp(stretchOrigin, stretchDest, num);
		base.transform.position = position;
		SetStretchFactor((stretchDest - stretchOrigin).magnitude * num);
		animWarper.bodyRenderer.material.SetFloat("_DistortFactor", num * 0.45f + Mathf.PerlinNoise(0f, Time.time * 20f) * num * 0.1f);
		animWarper.curveDirection = Vector3.Slerp(originalCurveDir, newCurveDir, num);
		animator.SetFloat("Narrow", Mathf.Lerp(originalNarrowFactor, newNarrowFactor, num));
		animWarper.curveIntensity = Mathf.Lerp(originalCurveIntensity, newCurveIntensity, num);
		if (stretchFactor >= 1f)
		{
			base.State = States.Chase_Stretch_Out;
		}
		pathWalker.LookAt(Player.GetPos(), chaseTurnSpeed * 2f);
		if ((Player.GroundPos - base.transform.position.ToGround()).sqrMagnitude <= 0.80999994f)
		{
			Player.GetController().ApplyAttack(2f, "GAMEOVER_SHADOW", 6f);
		}
	}

	private void Chase_Stretch_Out_Update()
	{
		stretchFactor = Mathf.Clamp01(stretchFactor - Time.deltaTime * 1.6f);
		float num = Interpolate.EaseOut(stretchFactor);
		SetStretchFactor((stretchDest - stretchOrigin).magnitude * num);
		float num2 = Interpolate.EaseOut(Mathf.Clamp01(stretchFactor * 2f - 1f));
		animWarper.bodyRenderer.material.SetFloat("_DistortFactor", num2 * 0.45f + Mathf.PerlinNoise(0f, Time.time * 20f) * num2 * 0.1f);
		if (stretchFactor <= 0f)
		{
			base.State = States.Idle;
		}
		pathWalker.LookAt(Player.GetPos(), chaseTurnSpeed);
	}

	private void Go_Under_Door_Enter()
	{
		stretchDest = Map.Get().CellToWorld(Map.Get().WorldToCell(stretchDest));
		animWarper.verticalCollapse = 1f;
		groundSmoke.enableEmission = true;
		animator.speed = 1f - animWarper.verticalCollapse;
		stretchFactor = 0f;
		raiseFast = true;
		whisperSound.targetVolume = 0f;
	}

	private void Go_Under_Door_Update()
	{
		stretchFactor = Mathf.Clamp01(stretchFactor + Time.deltaTime * 0.25f);
		float t = Interpolate.EaseInOut(stretchFactor);
		Vector3 position = Vector3.Lerp(stretchOrigin, stretchDest, t);
		base.transform.position = position;
		pathWalker.LookAt(Player.GetPos(), chaseTurnSpeed * 2f);
		animator.SetFloat("Narrow", Mathf.Lerp(originalNarrowFactor, newNarrowFactor, t));
		animWarper.curveIntensity = Mathf.Lerp(originalCurveIntensity, newCurveIntensity, t);
		if (stretchFactor >= 1f)
		{
			base.State = States.Raise;
		}
	}

	private void Disappearing_Enter()
	{
		groundSmoke.enableEmission = true;
		if (!cVisibility.Hidden)
		{
			raiseSound.targetVolume = 1f;
		}
		whisperSound.targetVolume = 0f;
		moodSetter.tension = false;
		animWarper.minColliderFactor = 0f;
	}

	private void Disappearing_Update()
	{
		float verticalCollapse = animWarper.verticalCollapse;
		animWarper.verticalCollapse += Time.deltaTime * 0.05f;
		animWarper.verticalCollapse = Mathf.Clamp01(animWarper.verticalCollapse);
		if (verticalCollapse <= 0.4f && animWarper.verticalCollapse > 0.4f && UnityEngine.Random.value <= 0.15f && !cVisibility.Hidden)
		{
			base.State = States.Idle_Distort;
		}
		else if (animWarper.verticalCollapse >= 1f)
		{
			base.State = States.Destroying;
		}
		animator.speed = 1f - animWarper.verticalCollapse;
	}

	private void Disappearing_Exit()
	{
		raiseSound.targetVolume = 0f;
		groundSmoke.enableEmission = false;
		animWarper.minColliderFactor = 0.6f;
	}

	private void Destroying_Enter()
	{
		groundSmoke.enableEmission = false;
		animWarper.minColliderFactor = 0f;
	}

	private void Destroying_Update()
	{
		if (AddBodyAlpha((0f - Time.deltaTime) * 0.5f) <= 0f && groundSmoke.particleCount <= 0)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	private Vector3 LookAtPlayer()
	{
		Vector3 vector = Vector3Ext.GroundVector(playerLook.position, base.transform.position);
		vector.Normalize();
		Quaternion rotation = Quaternion.LookRotation(vector, Vector3.up);
		base.transform.rotation = rotation;
		return vector;
	}

	private Vector3 GetNewCurveDir(Vector3 refPosition)
	{
		Vector3 result = originalCurveDir;
		Cell cell = Map.Get().At(refPosition);
		for (int i = 0; i < 8; i++)
		{
			Vector2 insideUnitCircle = UnityEngine.Random.insideUnitCircle;
			Vector3 vector = new Vector3(insideUnitCircle.x, 0f, insideUnitCircle.y);
			bool flag = true;
			if ((Mathf.Abs(vector.x) > Mathf.Abs(vector.z)) ? ((!(vector.x > 0f)) ? (!cell.CheckAdjacency(AdjacencyCode.LeftCenter)) : (!cell.CheckAdjacency(AdjacencyCode.RightCenter))) : ((!(vector.z > 0f)) ? (!cell.CheckAdjacency(AdjacencyCode.CenterBottom)) : (!cell.CheckAdjacency(AdjacencyCode.CenterTop))))
			{
				result = vector;
				break;
			}
		}
		return result;
	}

	private void SetBodyAlpha(float alpha)
	{
		materialAlpha = alpha;
		if (alpha >= 1f && hasTransparentMaterial)
		{
			SetBodyMaterial(solidMaterial);
			hasTransparentMaterial = false;
		}
		else if (alpha < 1f && !hasTransparentMaterial)
		{
			SetBodyMaterial(transparentMaterial);
			hasTransparentMaterial = true;
		}
		Material material = animWarper.bodyRenderer.material;
		material.SetFloat("_Alpha", alpha);
	}

	private float AddBodyAlpha(float deltaAlpha)
	{
		float num = Mathf.Clamp01(materialAlpha + deltaAlpha);
		SetBodyAlpha(num);
		return num;
	}

	private void SetBodyMaterial(Material newMat)
	{
		animWarper.bodyRenderer.material = newMat;
		animWarper.ApplyVerticalCollapse();
	}

	private void SetStretchVector(Vector3 v)
	{
		Transform rootBone = animWarper.bodyRenderer.GetComponent<SkinnedMeshRenderer>().rootBone;
		v = rootBone.transform.InverseTransformDirection(v);
		animWarper.bodyRenderer.material.SetVector("_StretchVector", new Vector4(v.x, v.y, v.z, 0f));
	}

	private void SetStretchFactor(float f)
	{
		animWarper.bodyRenderer.material.SetFloat("_StretchFactor", f);
	}

	private void UpdateHeadTracking(bool playerVisible = false)
	{
		animWarper.headTracking = Interpolate.Approach(animWarper.headTracking, (!playerVisible && !IsPlayerInFront()) ? 0f : 1f, Time.deltaTime * 2f);
	}

	private bool UpdateDiscovered()
	{
		if (!discovered && animWarper.verticalCollapse <= 0.7f && Map.Get().At(base.transform.position).IsVisible())
		{
			discovered = true;
			FearEffect.Get().Scare(jumpScare: true);
			GameController.Get().GetComponent<ShadowFolkManager>().OnChaserDiscovered();
			return true;
		}
		return false;
	}

	private bool IsPlayerVisible()
	{
		return Utils.IsPlayerVisible(base.transform, 190f, checkOnlyAngle: false, 16f, 1f);
	}

	private bool IsPlayerInFront()
	{
		return Utils.IsPlayerVisible(base.transform, 85f, checkOnlyAngle: true, 16f, 1f);
	}

	private bool CheckNarrow(Vector3 pos)
	{
		Cell cell = Map.Get().At(pos);
		return (cell.CheckAdjacency(AdjacencyCode.RightCenter) && cell.CheckAdjacency(AdjacencyCode.LeftCenter)) || (cell.CheckAdjacency(AdjacencyCode.CenterTop) && cell.CheckAdjacency(AdjacencyCode.CenterBottom));
	}
}
public class ShadowCloud : MonoBehaviour
{
	public bool disappearing;

	private float floatingHeight;

	private List<Vector3> path = new List<Vector3>();

	private int idxPath;

	private float interpolationFactor;

	public float speed = 1f;

	public float initWait;

	public ParticleSystem[] trailParticles;

	private void Start()
	{
		floatingHeight = base.transform.position.y;
		if ((path == null || path.Count == 0) && !FindTargetPos(path))
		{
			UnityEngine.Object.Destroy(base.gameObject);
			return;
		}
		for (int i = 0; i < trailParticles.Length; i++)
		{
			trailParticles[i].enableEmission = true;
		}
	}

	private void Update()
	{
		if (initWait > 0f)
		{
			initWait -= Time.deltaTime;
		}
		else if (!disappearing)
		{
			Vector3 vP = ((idxPath != 0) ? path[idxPath - 1] : path[0]);
			Vector3 vP2 = path[idxPath];
			Vector3 vP3 = path[idxPath + 1];
			Vector3 vP4 = ((idxPath != path.Count - 2) ? path[idxPath + 2] : path[idxPath + 1]);
			interpolationFactor = Mathf.Clamp01(interpolationFactor + Time.deltaTime * speed);
			base.transform.position = Interpolate.CatmullRom(vP, vP2, vP3, vP4, interpolationFactor);
			if (!(interpolationFactor >= 1f))
			{
				return;
			}
			interpolationFactor = 0f;
			idxPath++;
			if (idxPath == path.Count - 1)
			{
				disappearing = true;
				for (int i = 0; i < trailParticles.Length; i++)
				{
					trailParticles[i].enableEmission = false;
				}
				UnityEngine.Object.Destroy(base.gameObject, 5f);
			}
		}
		else
		{
			GetComponent<AudioSource>().volume -= Time.deltaTime / 4f;
		}
	}

	private bool FindTargetPos(List<Vector3> outputList)
	{
		outputList.Clear();
		Vector3 pos = Player.GetPos();
		Point point = Map.Get().WorldToCell(base.transform.position);
		Point despawnPos = point;
		List<Point> list = new List<Point>();
		List<Point> list2 = new List<Point>();
		list2.Add(point);
		while (list2.Count > 0)
		{
			int index = UnityEngine.Random.Range(0, list2.Count);
			Point curTile = list2[index];
			list2.RemoveAt(index);
			if (list.Exists((Point e) => e == curTile))
			{
				continue;
			}
			list.Add(curTile);
			Cell cell = Map.Get().At(curTile);
			if (cell == null || !cell.CanWalk())
			{
				continue;
			}
			if ((!cell.Occupied || cell.Room == null || !(cell.Door == null) || cell.IsDoor) && !cell.IsVisible() && !cell.IsDiscovered())
			{
				Debug.DrawLine(Map.Get().CellToWorld(curTile), Map.Get().CellToWorld(curTile) + Vector3.up, Color.yellow, 3f);
				if ((Map.Get().CellToWorld(curTile) - pos).sqrMagnitude > 100f && !cell.CheckLoS(Player.GetCenterEye()))
				{
					Debug.DrawLine(Map.Get().CellToWorld(curTile), Map.Get().CellToWorld(curTile) + Vector3.up * 1.5f, Color.green, 3f);
					despawnPos = curTile;
					break;
				}
			}
			else
			{
				Debug.DrawLine(Map.Get().CellToWorld(curTile), Map.Get().CellToWorld(curTile) + Vector3.up, Color.red, 3f);
			}
			list2.Add(new Point(curTile.X - 1, curTile.Y));
			list2.Add(new Point(curTile.X + 1, curTile.Y));
			list2.Add(new Point(curTile.X, curTile.Y - 1));
			list2.Add(new Point(curTile.X, curTile.Y + 1));
		}
		if (SetTargetPath(despawnPos, outputList))
		{
			return true;
		}
		return false;
	}

	public bool ForceTargetPath(Point despawnPos)
	{
		floatingHeight = base.transform.position.y;
		return SetTargetPath(despawnPos, path);
	}

	private bool SetTargetPath(Point despawnPos, List<Vector3> outputList)
	{
		Point end = Map.Get().WorldToCell(base.transform.position);
		Pathfinder pathfinder = Pathfinder.Get();
		Pathfinder.Query query = pathfinder.AddQuery(despawnPos, end, null, PathWalker.CheckTraversal, PathWalker.GetTraversalCost, null, 0.5f);
		if (pathfinder.RunAStar(query))
		{
			if (query.State == Pathfinder.Query.EState.Success)
			{
				outputList.Add(base.transform.position);
				for (int num = query.Path.Count - 1; num >= 0; num--)
				{
					Vector3 item = Map.Get().CellToWorld(query.Path[num]);
					item += Vector3.up * floatingHeight;
					item += Vector3.up * UnityEngine.Random.Range(-0.4f, 0.4f);
					outputList.Add(item);
				}
				pathfinder.FreeQuery(query);
				return true;
			}
			pathfinder.FreeQuery(query);
		}
		return false;
	}
}
public class ShadowFolkManager : MonoBehaviour
{
	public GameObject[] shadowWatchers;

	public int watcherSpawnRange = 4;

	private float MinWaitWatcherShort = 7f;

	private float MaxWaitWatcherShort = 25f;

	private float MinWaitWatcherLong = 30f;

	private float MaxWaitWatcherLong = 90f;

	public ShadowChaser shadowChaser;

	public int chaserSpawnRange = 6;

	public bool chaserVisions;

	public bool chaserCreatures;

	private float MinWaitChaserShort = 7f;

	private float MaxWaitChaserShort = 25f;

	private float MinWaitChaserLong = 40f;

	private float MaxWaitChaserLong = 130f;

	private float chaserWaitFactor = 1f;

	public bool canSpawnWatchers = true;

	public bool canSpawnChasers = true;

	private void Start()
	{
		LevelOptions levelOptions = GameController.Get().levelOptions;
		if (levelOptions.shadowWatchers)
		{
			float num = UnityEngine.Random.Range(levelOptions.shadowWatchersMinDelay, levelOptions.shadowWatchersMaxDelay);
			if (num > 0f)
			{
				StartCoroutine(DelayedEnableWatchers_co(num));
			}
			StartCoroutine(SpawnWatchers_co());
		}
		chaserCreatures = levelOptions.shadowChasers;
		chaserVisions = levelOptions.shadowChasersVisions;
		if (chaserCreatures || chaserVisions)
		{
			float num2 = UnityEngine.Random.Range(levelOptions.shadowChasersMinDelay, levelOptions.shadowChasersMaxDelay);
			if (num2 > 0f)
			{
				StartCoroutine(DelayedEnableChasers_co(num2));
			}
			StartCoroutine(SpawnChasers_co());
		}
	}

	private IEnumerator SpawnWatchers_co()
	{
		bool bFirst = true;
		while (true)
		{
			if (!canSpawnWatchers)
			{
				yield return new WaitForSeconds(5f);
				continue;
			}
			bool bWaitShort = !bFirst && UnityEngine.Random.value < 0.3f;
			bFirst = false;
			float maxWait = ((!bWaitShort) ? MaxWaitWatcherLong : MaxWaitWatcherShort);
			float minWait = ((!bWaitShort) ? MinWaitWatcherLong : MinWaitWatcherShort);
			float nextWait = UnityEngine.Random.Range(minWait, maxWait);
			yield return new WaitForSeconds(nextWait);
			SpawnWatcher();
		}
	}

	private IEnumerator SpawnChasers_co()
	{
		bool bFirst = true;
		while (true)
		{
			if (!canSpawnChasers)
			{
				yield return new WaitForSeconds(5f);
				continue;
			}
			bool bWaitShort = !bFirst && UnityEngine.Random.value < 0.3f;
			bFirst = false;
			float maxWait = ((!bWaitShort) ? MaxWaitChaserLong : MaxWaitChaserShort);
			float minWait2 = ((!bWaitShort) ? MinWaitChaserLong : MinWaitChaserShort);
			maxWait *= chaserWaitFactor;
			minWait2 *= chaserWaitFactor;
			chaserWaitFactor *= 0.85f;
			chaserWaitFactor = Mathf.Clamp(chaserWaitFactor, 0.1f, 1.5f);
			float nextWait = UnityEngine.Random.Range(minWait2, maxWait);
			yield return new WaitForSeconds(nextWait);
			if (canSpawnChasers)
			{
				bool isVision = false;
				if (chaserVisions && chaserCreatures)
				{
					isVision = UnityEngine.Random.value <= 0.3f;
				}
				else if (chaserVisions)
				{
					isVision = true;
				}
				SpawnChaser(isVision);
			}
		}
	}

	public void OnChaserDiscovered()
	{
		chaserWaitFactor = UnityEngine.Random.Range(1.25f, 2f);
		if (chaserVisions && !chaserCreatures)
		{
			chaserWaitFactor = UnityEngine.Random.Range(1.5f, 1.75f);
		}
		StartCoroutine(DelayedEnableChasers_co(UnityEngine.Random.Range(20f, 60f)));
		StartCoroutine(DelayedEnableWatchers_co(UnityEngine.Random.Range(15f, 30f)));
	}

	public GameObject SpawnWatcher()
	{
		if (Player.IsSafe())
		{
			return null;
		}
		Transform transform = GameObject.FindWithTag(Tags.LookDirection).transform;
		Vector3 groundPos = Player.GetGroundPos();
		Point point = Map.Get().WorldToCell(groundPos);
		List<Pair<Point, int>> list = new List<Pair<Point, int>>();
		for (int i = point.Y - watcherSpawnRange; i <= point.Y + watcherSpawnRange; i++)
		{
			for (int j = point.X - watcherSpawnRange; j <= point.X + watcherSpawnRange; j++)
			{
				if (!Map.Get().InRange(j, i))
				{
					continue;
				}
				Cell cell = Map.Get().At(j, i);
				if (cell.Occupied || !cell.IsClear() || !cell.Probe || cell.IsVisible() || cell.Room == null || cell.Room.Safe || !cell.CheckLoS(transform.position))
				{
					continue;
				}
				int numAdjacentWalls = cell.GetNumAdjacentWalls();
				int num = Math.Abs(j - point.X) + Math.Abs(i - point.Y);
				if (num == 0)
				{
					continue;
				}
				int second = 10;
				if (numAdjacentWalls > 1 || cell.IsDoor || cell.DoorSide != 0)
				{
					second = 60;
				}
				else if (numAdjacentWalls == 1)
				{
					second = 20;
				}
				if (num <= 2)
				{
					second = 5;
					Vector3 vec = Map.Get().CellToWorld(j, i) - groundPos;
					if (vec.sqrMagnitudeGround() <= 1.21f)
					{
						continue;
					}
				}
				list.Add(new Pair<Point, int>(new Point(j, i), second));
			}
		}
		if (list.Count == 0)
		{
			return null;
		}
		Point cellPos = RandomExt.WeightedChoice(list);
		Vector3 vector = Map.Get().CellToWorld(cellPos);
		Vector3 forward = groundPos - vector;
		forward.Normalize();
		return UnityEngine.Object.Instantiate(shadowWatchers[0], vector, Quaternion.LookRotation(forward));
	}

	public GameObject SpawnChaser(bool isVision = false)
	{
		if (Player.IsSafe())
		{
			return null;
		}
		Transform transform = GameObject.FindWithTag(Tags.LookDirection).transform;
		Vector3 groundPos = Player.GetGroundPos();
		Point point = Map.Get().WorldToCell(groundPos);
		List<Pair<Point, int>> list = new List<Pair<Point, int>>();
		for (int i = point.Y - chaserSpawnRange; i <= point.Y + chaserSpawnRange; i++)
		{
			for (int j = point.X - chaserSpawnRange; j <= point.X + chaserSpawnRange; j++)
			{
				if (!Map.Get().InRange(j, i))
				{
					continue;
				}
				Point pos = new Point(j, i);
				Cell cell = Map.Get().At(j, i);
				if (cell.Occupied || !cell.IsClear() || !cell.Probe || (cell.Room != null && cell.Room.Safe) || (cell.Room != null && cell.Room.HasLocalEnemy))
				{
					continue;
				}
				int inRoom = CreatureCounter.GetInRoom(pos);
				if (inRoom > 0)
				{
					int inRoom2 = CreatureCounter.GetInRoom(pos, CreatureCounter.CreatureType.Shadow);
					inRoom -= inRoom2;
					if (inRoom2 > 1 || inRoom > 0)
					{
						continue;
					}
				}
				if (cell.IsDoor || Map.Get().IsReservedDoor(pos))
				{
					continue;
				}
				bool flag = cell.CheckLoS(transform.position);
				if (!flag && UnityEngine.Random.value <= 0.5f)
				{
					continue;
				}
				int numAdjacentWalls = cell.GetNumAdjacentWalls();
				int num = Math.Abs(j - point.X) + Math.Abs(i - point.Y);
				if (num == 0)
				{
					continue;
				}
				int num2 = 0;
				if (cell.Room != null && cell.Room.PlayerInside)
				{
					num2 += 60;
				}
				if (cell.IsVisible())
				{
					num2 += 40;
				}
				else if (flag)
				{
					num2 += 20;
				}
				if (numAdjacentWalls == 0)
				{
					num2 = 10;
				}
				if (num <= 2)
				{
					num2 -= 10;
					Vector3 vec = Map.Get().CellToWorld(j, i) - groundPos;
					if (vec.sqrMagnitudeGround() <= 1.21f)
					{
						continue;
					}
				}
				list.Add(new Pair<Point, int>(new Point(j, i), num2));
			}
		}
		if (list.Count == 0)
		{
			return null;
		}
		Point cellPos = RandomExt.WeightedChoice(list);
		Vector3 position = Map.Get().CellToWorld(cellPos);
		ShadowChaser shadowChaser = UnityEngine.Object.Instantiate(this.shadowChaser, position, Quaternion.identity);
		shadowChaser.isVision = isVision;
		return shadowChaser.gameObject;
	}

	private IEnumerator DelayedEnableWatchers_co(float delayTime)
	{
		canSpawnWatchers = false;
		yield return new WaitForSeconds(delayTime);
		canSpawnWatchers = true;
	}

	private IEnumerator DelayedEnableChasers_co(float delayTime)
	{
		canSpawnChasers = false;
		yield return new WaitForSeconds(delayTime);
		canSpawnChasers = true;
	}
}
public class ShadowWatcher : FSMComponent<ShadowWatcher.States>
{
	public enum States
	{
		Hidden,
		InPeriphery,
		InFullView,
		Disappearing,
		Destroying
	}

	public SpookEvent lightFlicker;

	private VisibilityProbe probe;

	private Transform playerLook;

	private SpookSounds spookSounds;

	private RandomSounds randomSounds;

	private ParticleSystem[] particles;

	public Renderer body;

	public Renderer eyes;

	public Animator animator;

	[Range(0f, 1f)]
	public float narrowFactor;

	private bool longDisappear;

	private bool soundOnStart;

	private float timer;

	public bool infiniteTimer;

	private void Start()
	{
		Init(States.Hidden);
	}

	private void Hidden_Enter()
	{
		probe = Map.Get().At(base.transform.position).Probe;
		playerLook = Player.GetLook();
		randomSounds = GetComponent<RandomSounds>();
		spookSounds = Player.GetComponent<SpookSounds>();
		particles = GetComponentsInChildren<ParticleSystem>();
		if (body == null)
		{
			body = base.transform.Find("shadowfolk_body").GetComponent<Renderer>();
		}
		if (eyes == null)
		{
			eyes = base.transform.Find("shadowfolk_eyes").GetComponent<Renderer>();
		}
		longDisappear = UnityEngine.Random.value <= 0.3f;
		soundOnStart = UnityEngine.Random.value <= 0.3f;
		if (soundOnStart)
		{
			randomSounds.PlayNow();
		}
		else
		{
			randomSounds.Playing = false;
		}
		if (UnityEngine.Random.value <= 0.4f)
		{
			Jukebox.Get().PlaySilence();
		}
		timer = UnityEngine.Random.Range(8f, 16f);
		if ((bool)animator)
		{
			animator.SetFloat("Narrow", narrowFactor);
		}
	}

	private void Hidden_Update()
	{
		LookAtPlayer();
		if (probe.IsVisible)
		{
			base.State = States.InPeriphery;
		}
		else if (!infiniteTimer)
		{
			timer -= Time.deltaTime;
			if (timer <= 0f)
			{
				base.State = States.Disappearing;
			}
		}
	}

	private void InPeriphery_Enter()
	{
		if (UnityEngine.Random.value <= 0.3f)
		{
			base.State = States.Disappearing;
		}
		randomSounds.Playing = true;
		if (!soundOnStart && UnityEngine.Random.value <= 0.5f)
		{
			randomSounds.PlayNow();
		}
	}

	private void InPeriphery_Update()
	{
		Vector3 vector = LookAtPlayer();
		if (!probe.IsVisible)
		{
			base.State = States.Disappearing;
			return;
		}
		Vector3 forward = playerLook.forward;
		forward.Normalize();
		float num = Vector3.Angle(forward, -vector);
		if (num < 35f)
		{
			base.State = States.InFullView;
		}
	}

	private void InFullView_Enter()
	{
		if (UnityEngine.Random.value <= 0.3f)
		{
			timer = UnityEngine.Random.Range(2f, 4f);
			SpookManager.Get().PlayEvent(lightFlicker);
			longDisappear = true;
			eyes.enabled = false;
			spookSounds.PlayScare();
		}
		else
		{
			timer = UnityEngine.Random.Range(0.1f, 2f);
			if (UnityEngine.Random.value <= 0.5f)
			{
				spookSounds.PlayScare();
			}
			else
			{
				FearEffect.Get().Scare(jumpScare: true);
			}
		}
	}

	private void InFullView_Update()
	{
		timer -= Time.deltaTime;
		if (timer <= 0f)
		{
			base.State = States.Disappearing;
		}
	}

	private void Disappearing_Enter()
	{
		randomSounds.Playing = false;
		eyes.enabled = false;
		for (int i = 0; i < particles.Length; i++)
		{
			particles[i].enableEmission = false;
		}
	}

	private void Disappearing_Update()
	{
		float @float = body.material.GetFloat("_Alpha");
		@float -= 2f * Time.deltaTime;
		body.material.SetFloat("_Alpha", @float);
		int num = 0;
		for (int i = 0; i < particles.Length; i++)
		{
			num += particles[i].particleCount;
			if (!longDisappear)
			{
			}
		}
		if (num == 0)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	private Vector3 LookAtPlayer()
	{
		Vector3 vector = Vector3Ext.GroundVector(playerLook.position, base.transform.position);
		vector.Normalize();
		Quaternion rotation = Quaternion.LookRotation(vector, Vector3.up);
		base.transform.rotation = rotation;
		return vector;
	}
}
public class SoundLoop : MonoBehaviour
{
	public AudioSource source;

	public float targetVolume;

	private float curVolume;

	private void Start()
	{
		curVolume = source.volume;
		source.volume = targetVolume;
		if (targetVolume <= 0f && source.isPlaying)
		{
			source.Stop();
		}
		else if (targetVolume > 0f && !source.isPlaying)
		{
			source.Play();
		}
	}

	private void Update()
	{
		source.volume = Interpolate.Approach(source.volume, targetVolume, Time.deltaTime * 3f);
		if (!source.isPlaying && source.volume > 0.01f)
		{
			source.Play();
		}
		else if (source.isPlaying && source.volume <= 0.01f)
		{
			source.Stop();
		}
	}
}
public class StopMotionAnimator : MonoBehaviour
{
	public float framesPerSecond = 15f;

	private float timeLastFrame;

	private Animation meshAnimation;

	private AnimationState currentAnim;

	private AnimationState prevAnim;

	private float fadeLength;

	private float fadeTime;

	public Vector3 position;

	public Quaternion rotation;

	public bool controlPosition = true;

	public void Play(string animName)
	{
		currentAnim.enabled = false;
		currentAnim.weight = 0f;
		currentAnim = meshAnimation[animName];
		currentAnim.time = 0f;
		currentAnim.weight = 1f;
	}

	public void CrossFade(string animName, float fadeLength)
	{
		prevAnim = currentAnim;
		prevAnim.weight = 1f;
		currentAnim = meshAnimation[animName];
		currentAnim.time = 0f;
		currentAnim.weight = 0f;
		this.fadeLength = fadeLength;
		fadeTime = 0f;
	}

	private void Awake()
	{
		meshAnimation = base.transform.GetComponentInChildren<Animation>();
		currentAnim = meshAnimation[meshAnimation.clip.name];
		meshAnimation.Stop();
	}

	private void Start()
	{
		position = base.transform.position;
		rotation = base.transform.rotation;
	}

	private void Update()
	{
		if (currentAnim != null)
		{
			currentAnim.time += Time.deltaTime;
		}
		if (prevAnim != null)
		{
			prevAnim.time += Time.deltaTime;
			fadeTime += Time.deltaTime;
			if (fadeTime >= fadeLength)
			{
				currentAnim.weight = 1f;
				prevAnim = null;
			}
			else
			{
				currentAnim.weight = Mathf.Lerp(0f, 1f, fadeTime / fadeLength);
				prevAnim.weight = Mathf.Lerp(1f, 0f, fadeTime / fadeLength);
			}
		}
		timeLastFrame += Time.deltaTime;
		float num = 1f / framesPerSecond;
		if (timeLastFrame >= num)
		{
			timeLastFrame -= num;
			if (currentAnim != null)
			{
				currentAnim.enabled = true;
			}
			if (prevAnim != null)
			{
				prevAnim.enabled = true;
			}
			meshAnimation.Sample();
			if (currentAnim != null)
			{
				currentAnim.enabled = false;
			}
			if (prevAnim != null)
			{
				prevAnim.enabled = false;
			}
			if (controlPosition)
			{
				base.transform.position = position;
				base.transform.rotation = rotation;
			}
		}
	}
}
public class AfterBuild : MonoBehaviour
{
	private static AfterBuild instance;

	public ShadowWatcher shadowWatcher;

	public Transform doorOpenTrigger;

	public Transform doorCloseTrigger;

	public Transform gateTrigger;

	public Transform monsterTrigger;

	public Transform batsTrigger;

	public Transform ghostViewCover;

	public static AfterBuild Get()
	{
		if (instance == null)
		{
			instance = GameObject.Find("GameController").GetComponent<AfterBuild>();
		}
		return instance;
	}

	public void Awake()
	{
		instance = this;
	}

	public void DoBuild()
	{
		Debug.Log("AfterBuild - DoBuild");
		SpawnShadow();
		SpawnDoorTriggers();
		SpawnGateTrigger();
		SpawnTrigger(monsterTrigger, 18, 52);
		SpawnTrigger(batsTrigger, 36, 16);
		TurnLightsOn();
		UnityEngine.Object.Instantiate(ghostViewCover, new Vector3(33f, 1.75f, -15.75f), Quaternion.identity);
		Debug.Log("AfterBuild - DoBuild end");
	}

	private void SpawnShadow()
	{
		Point cellPos = new Point(23, 11);
		Vector3 position = Map.Get().CellToWorld(cellPos);
		ShadowWatcher shadowWatcher = UnityEngine.Object.Instantiate(rotation: Quaternion.LookRotation(new Vector3(0f, 0f, 1f)), original: this.shadowWatcher, position: position);
		shadowWatcher.infiniteTimer = true;
	}

	private void SpawnDoorTriggers()
	{
		UnityEngine.Object.Instantiate(doorOpenTrigger, Map.Get().CellToWorld(10, 12), Quaternion.identity);
		UnityEngine.Object.Instantiate(doorCloseTrigger, new Vector3(16.7f, 0f, -25.2f), Quaternion.Euler(0f, 300f, 0f));
	}

	private void SpawnGateTrigger()
	{
		UnityEngine.Object.Instantiate(gateTrigger, new Vector3(47.03f, 0f, -13.79f), Quaternion.Euler(0f, 270f, 0f));
	}

	private void SpawnTrigger(Transform trigger, int tileX, int tileY)
	{
		UnityEngine.Object.Instantiate(trigger, Map.Get().CellToWorld(tileX, tileY), Quaternion.identity);
	}

	private void TurnLightsOn()
	{
		Room[] array = new Room[2]
		{
			Map.Get().At(27, 7).Room,
			Map.Get().At(24, 7).Room
		};
		Room[] array2 = array;
		foreach (Room room in array2)
		{
			foreach (PropInfo prop in room.props)
			{
				InteractiveLightEx componentInChildren = prop.GetComponentInChildren<InteractiveLightEx>();
				if (componentInChildren != null)
				{
					componentInChildren.lightOn = true;
					componentInChildren.invulnerable = true;
					componentInChildren.endlessFuel = true;
				}
			}
		}
	}

	public static void AdjustSpawnRotation(Transform spawnPoint, float increment = 45f)
	{
		float y = spawnPoint.transform.localRotation.eulerAngles.y;
		List<float> list = new List<float>();
		float num = float.MaxValue;
		float y2 = y;
		for (float num2 = 0f; num2 < 360f; num2 += increment)
		{
			float num3 = Mathf.Abs(Mathf.DeltaAngle(y, num2));
			if (num3 < num)
			{
				num = num3;
				y2 = num2;
			}
		}
		Vector3 eulerAngles = spawnPoint.transform.localRotation.eulerAngles;
		Quaternion localRotation = Quaternion.Euler(eulerAngles.x, y2, eulerAngles.z);
		spawnPoint.transform.localRotation = localRotation;
	}
}
public class ColorCorrectionDbg : MonoBehaviour
{
	public Texture2D[] textures;

	public int index;

	private ColorCorrectionLut clut;

	private void Start()
	{
		index = 0;
		clut = GetComponent<ColorCorrectionLut>();
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.F5))
		{
			index = (index - 1) % textures.Length;
			if (index < 0)
			{
				index = textures.Length - 1;
			}
			SetLUT();
		}
		if (Input.GetKeyDown(KeyCode.F6))
		{
			index = (index + 1) % textures.Length;
			SetLUT();
		}
	}

	private void SetLUT()
	{
		Texture2D texture2D = textures[index];
		clut.Convert(texture2D, texture2D.name);
		Tutorial.Get().ShowTextForTime("Color grading: " + texture2D.name, 3f);
	}
}
public class DemoTimeout : MonoBehaviour
{
	public int timeRemaining = 180;

	public bool spawnMonster = true;

	public LightEater monster;

	private void Start()
	{
		StopCoroutine("Timeout_co");
		StartCoroutine("Timeout_co");
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Alpha1))
		{
			timeRemaining = 60;
			StopCoroutine("Timeout_co");
			StartCoroutine("Timeout_co");
			Tutorial.Get().ShowTextForTime("1 minute left", 5f);
		}
		if (Input.GetKeyDown(KeyCode.Alpha2))
		{
			timeRemaining = 120;
			StopCoroutine("Timeout_co");
			StartCoroutine("Timeout_co");
			Tutorial.Get().ShowTextForTime("2 minutes left", 5f);
		}
		if (Input.GetKeyDown(KeyCode.Alpha3))
		{
			timeRemaining = 180;
			StopCoroutine("Timeout_co");
			StartCoroutine("Timeout_co");
			Tutorial.Get().ShowTextForTime("3 minutes left", 5f);
		}
		if (Input.GetKeyDown(KeyCode.Alpha0))
		{
			timeRemaining = 0;
			StopCoroutine("Timeout_co");
			Tutorial.Get().ShowTextForTime("No timeout", 5f);
		}
		if (monster != null)
		{
			float sqrMagnitude = (Player.GetGroundPos() - monster.transform.position.ToGround()).sqrMagnitude;
			if (sqrMagnitude <= 4f)
			{
				Debug.Log("Demo Timeout - Ending level by monster proximity");
				GameController.Get().EndLevel(win: true);
				StopCoroutine("Timeout_co");
				base.enabled = false;
			}
		}
	}

	private IEnumerator Timeout_co()
	{
		yield return new WaitForSeconds(timeRemaining - 20);
		Debug.Log("Demo Timeout - Spawning monster");
		float secsWasted = 0f;
		while (monster == null && secsWasted < 17f)
		{
			monster = LightEater.SpawnNextToPlayer();
			if (monster != null)
			{
				break;
			}
			secsWasted += 3f;
			yield return new WaitForSeconds(3f);
		}
		yield return new WaitForSeconds(20f - secsWasted);
		Debug.Log("Demo Timeout - Ending level");
		GameController.Get().EndLevel(win: true);
	}

	public void Stop()
	{
		StopAllCoroutines();
	}
}
[RequireComponent(typeof(Trigger))]
public class DemoTriggerBats : MonoBehaviour
{
	public Bat batPrefab;

	public int numBats = 64;

	public AudioClip deepSound;

	public void OnTrigger(PlayerGameController player)
	{
		StartCoroutine(Trigger_co());
	}

	private IEnumerator Trigger_co()
	{
		Vector3 vDirection = Vector3.down;
		vDirection *= 20f;
		Utils.PlayClipAt(pos: base.transform.position + vDirection, clip: deepSound, minDistance: 70f, maxDistance: 100f);
		yield return new WaitForSeconds(1.5f);
		Transform playerPos = Player.Get().transform;
		Vector3 curPos = Player.GetGroundPos();
		for (int i = 0; i < numBats; i++)
		{
			UnityEngine.Object.Instantiate(batPrefab, curPos, playerPos.rotation);
		}
	}
}
[RequireComponent(typeof(Trigger))]
public class DemoTriggerDoorClose : MonoBehaviour
{
	public string doorName = "Door_5";

	public void OnTrigger(PlayerGameController player)
	{
		Door component = GameObject.Find(doorName).GetComponent<Door>();
		component.CloseFastWithWind();
	}
}
[RequireComponent(typeof(Trigger))]
public class DemoTriggerDoorOpen : MonoBehaviour
{
	public string doorName = "Door_2";

	public void OnTrigger(PlayerGameController player)
	{
		Door component = GameObject.Find(doorName).GetComponent<Door>();
		component.OpenWithCreak(player.transform);
	}
}
[RequireComponent(typeof(Trigger))]
public class DemoTriggerGate : MonoBehaviour
{
	private MechGate gate;

	private void Start()
	{
		Room room = Map.Get().At(base.transform.position).Room;
		foreach (PropInfo prop in room.props)
		{
			gate = prop.GetComponentInChildren<MechGate>();
			if (gate != null)
			{
				break;
			}
		}
		if (gate == null)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
		Serializer.Add(this, OnSerialize, OnDeserialize);
	}

	private void OnSerialize(BinaryWriter writer)
	{
		writer.Write(GetComponent<Collider>().enabled);
	}

	private void OnDeserialize(BinaryReader reader)
	{
		GetComponent<Collider>().enabled = reader.ReadBoolean();
	}

	public void OnTrigger(PlayerGameController player)
	{
		if (gate.progressOpen >= 0.9f)
		{
			gate.speed = 4f;
			gate.SetProgress(0.62f);
			FearEffect.Get().Scare(jumpScare: true);
		}
	}
}
[RequireComponent(typeof(Trigger))]
public class DemoTriggerMonster : MonoBehaviour
{
	public void OnTrigger(PlayerGameController player)
	{
		DemoTimeout component = GameController.Get().GetComponent<DemoTimeout>();
		if (component != null && component.monster == null)
		{
			component.monster = LightEater.SpawnNextToPlayer();
		}
	}
}
public class AmbientManager : TimeIndependentBehaviour
{
	private static AmbientManager instance;

	public bool drawDebug;

	public ParticleSystem[] dustEffect;

	public List<AmbientStyle> ambientStyles;

	public AmbientStyle curAmbient;

	private AmbientStyle lastAmbient;

	public string defaultAmbientName = "default";

	private AmbientStyle defaultAmbient;

	public bool updateFromPosition = true;

	private Transform playerPosition;

	private TorchLight playerTorch;

	private Light playerTorchLight;

	private Light playerMapLight;

	private Pvr_UnitySDKManager picoCamController;

	private Camera[] playerCameras;

	private float maxSeeingDistance = 60f;

	private bool dustEnabled;

	private bool dustEmission;

	private float interpolation;

	private float interpolationTime;

	private float ambientFactor = 0.5f;

	public static float configIntensity = 1f;

	public static float configRange = 1.4f;

	public AmbientStyle Style
	{
		get
		{
			return curAmbient;
		}
		set
		{
			SetStyle(value);
		}
	}

	public static AmbientManager Get()
	{
		if (instance == null)
		{
			instance = GameObject.Find("AmbientManager").GetComponent<AmbientManager>();
		}
		return instance;
	}

	public static void Clear()
	{
		instance = null;
	}

	protected new void Awake()
	{
		base.Awake();
		instance = this;
		interpolation = (interpolationTime = 1f);
		defaultAmbient = ambientStyles[0];
	}

	public void SetStyle(AmbientStyle style, float time = 2f)
	{
		if (style == null)
		{
			style = defaultAmbient;
		}
		if (!(style == curAmbient))
		{
			lastAmbient = curAmbient;
			curAmbient = style;
			if (time > 0f)
			{
				interpolation = 0f;
				interpolationTime = time;
			}
			else
			{
				interpolation = (interpolationTime = 1f);
			}
			Jukebox.Get().SetBaseMood((!(style.ambientTrack != string.Empty)) ? "ambience" : style.ambientTrack);
		}
	}

	public void SetStyle(string name, float time = 2f)
	{
		AmbientStyle style = GetStyle(name);
		if (style != null)
		{
			SetStyle(style, time);
		}
	}

	public AmbientStyle GetStyle(string name)
	{
		foreach (AmbientStyle ambientStyle in ambientStyles)
		{
			if (ambientStyle.styleName == name)
			{
				return ambientStyle;
			}
		}
		return null;
	}

	private void Start()
	{
		defaultAmbient = GetStyle(defaultAmbientName);
		if (!defaultAmbient)
		{
			defaultAmbient = ambientStyles[0];
		}
		lastAmbient = (curAmbient = defaultAmbient);
		playerPosition = Player.Get().transform;
		GameObject gameObject = GameObject.FindWithTag(Tags.PlayerTorch);
		if ((bool)gameObject)
		{
			playerTorchLight = gameObject.GetComponent<Light>();
			playerTorch = gameObject.GetComponent<TorchLight>();
			playerMapLight = gameObject.transform.Find("MapLight").GetComponent<Light>();
		}
		ResetPlayerCameras();
		if (updateFromPosition)
		{
			SetStyle(Map.Get().At(playerPosition.position).Ambient);
		}
	}

	public void ResetPlayerCameras()
	{
		picoCamController = playerPosition.gameObject.GetComponentInChildren<Pvr_UnitySDKManager>();
		playerCameras = Utils.GetPlayerCameras().ToArray();
	}

	protected new void Update()
	{
		base.Update();
		if (updateFromPosition)
		{
			SetStyle(Map.Get().At(playerPosition.position).Ambient);
		}
		interpolation = Mathf.Clamp(interpolation + base.deltaTime, 0f, interpolationTime);
		UpdateRenderSettings();
	}

	public void UpdateRenderSettings(bool editMode = false)
	{
		float t = Mathf.Clamp01(interpolation / interpolationTime);
		if (lastAmbient == null)
		{
			lastAmbient = curAmbient;
		}
		float to = 0.5f;
		float to2 = 1f;
		if (GameController.Get().Paused)
		{
			to2 = 0.1f;
			to = 0f;
		}
		TorchLight.globalFactor = Interpolate.Approach(TorchLight.globalFactor, to2, base.deltaTime * 4f);
		ambientFactor = Interpolate.Approach(ambientFactor, to, base.deltaTime * 2f);
		Vector4[] shaderConstants = curAmbient.SHLighting.GetShaderConstants();
		Vector4[] shaderConstants2 = lastAmbient.SHLighting.GetShaderConstants();
		Shader.SetGlobalVector("_DirAmbient_SHAr", Vector4.Lerp(shaderConstants2[0], shaderConstants[0], t));
		Shader.SetGlobalVector("_DirAmbient_SHAg", Vector4.Lerp(shaderConstants2[1], shaderConstants[1], t));
		Shader.SetGlobalVector("_DirAmbient_SHAb", Vector4.Lerp(shaderConstants2[2], shaderConstants[2], t));
		Shader.SetGlobalVector("_DirAmbient_SHBr", Vector4.Lerp(shaderConstants2[3], shaderConstants[3], t));
		Shader.SetGlobalVector("_DirAmbient_SHBg", Vector4.Lerp(shaderConstants2[4], shaderConstants[4], t));
		Shader.SetGlobalVector("_DirAmbient_SHBb", Vector4.Lerp(shaderConstants2[5], shaderConstants[5], t));
		Shader.SetGlobalVector("_DirAmbient_SHC", Vector4.Lerp(shaderConstants2[6], shaderConstants[6], t));
		Shader.SetGlobalFloat("_DirAmbient_Factor", ambientFactor);
		Color color = Color.Lerp(lastAmbient.fogColor, curAmbient.fogColor, t);
		color.a = 1f;
		RenderSettings.fogColor = color;
		RenderSettings.fogStartDistance = Mathf.Lerp(lastAmbient.fogStart, curAmbient.fogStart, t);
		float num2 = (RenderSettings.fogEndDistance = Mathf.Lerp(lastAmbient.fogEnd, curAmbient.fogEnd, t));
		if (playerCameras != null && picoCamController != null)
		{
			for (int i = 0; i < playerCameras.Length; i++)
			{
				playerCameras[i].backgroundColor = color;
			}
			picoCamController.transform.Find("Head/LeftEye").GetComponent<Camera>().backgroundColor = color;
			picoCamController.transform.Find("Head/RightEye").GetComponent<Camera>().backgroundColor = color;
		}
		if (playerTorch != null)
		{
			playerTorch.factor2 = Mathf.Lerp(lastAmbient.playerTorchIntensity, curAmbient.playerTorchIntensity, t) * configIntensity;
			playerTorch.range = Mathf.Lerp(lastAmbient.playerTorchRange, curAmbient.playerTorchRange, t) * configRange;
			playerTorchLight.color = Color.Lerp(lastAmbient.playerTorchColor, curAmbient.playerTorchColor, t);
			playerMapLight.color = playerTorchLight.color;
			playerTorch.SetSlaveLightFactor(0, Mathf.Lerp(lastAmbient.playerMapLightFactor, curAmbient.playerMapLightFactor, t) * configIntensity);
			if (editMode)
			{
				playerTorch.Update();
			}
		}
		maxSeeingDistance = 60f;
		if (num2 >= 1f)
		{
			maxSeeingDistance = Mathf.Min(maxSeeingDistance, num2);
		}
		maxSeeingDistance = Mathf.Min(maxSeeingDistance, playerTorch.range * 1.5f);
		if (dustEmission != curAmbient.dustParticles)
		{
			for (int j = 0; j < dustEffect.Length; j++)
			{
				dustEffect[j].enableEmission = curAmbient.dustParticles;
			}
			dustEmission = curAmbient.dustParticles;
		}
		if (curAmbient.dustParticles && !dustEnabled)
		{
			for (int k = 0; k < dustEffect.Length; k++)
			{
				dustEffect[k].gameObject.SetActive(value: true);
			}
			dustEnabled = true;
		}
		else
		{
			if (curAmbient.dustParticles || !dustEnabled)
			{
				return;
			}
			int num3 = 0;
			for (int l = 0; l < dustEffect.Length; l++)
			{
				num3 += dustEffect[l].particleCount;
			}
			if (num3 == 0)
			{
				for (int m = 0; m < dustEffect.Length; m++)
				{
					dustEffect[m].gameObject.SetActive(value: false);
				}
				dustEnabled = false;
			}
		}
	}

	public float GetMaxSeeingDistance()
	{
		return maxSeeingDistance;
	}

	public void OnDrawGizmosSelected()
	{
		if (Map.Get() == null || !drawDebug)
		{
			return;
		}
		for (int i = 0; i < Map.Get().Height; i++)
		{
			for (int j = 0; j < Map.Get().Height; j++)
			{
				AmbientStyle ambient = Map.Get().At(j, i).Ambient;
				if (ambient != null && ambient != defaultAmbient)
				{
					float num2;
					float num;
					float num3 = (num2 = (num = 0f));
					num3 += ambient.ambientX.r;
					num2 += ambient.ambientX.g;
					num += ambient.ambientX.b;
					num3 += ambient.ambientXNeg.r;
					num2 += ambient.ambientXNeg.g;
					num += ambient.ambientXNeg.b;
					num3 += ambient.ambientY.r;
					num2 += ambient.ambientY.g;
					num += ambient.ambientY.b;
					num3 += ambient.ambientYNeg.r;
					num2 += ambient.ambientYNeg.g;
					num += ambient.ambientYNeg.b;
					num3 += ambient.ambientZ.r;
					num2 += ambient.ambientZ.g;
					num += ambient.ambientZ.b;
					num3 += ambient.ambientZNeg.r;
					num2 += ambient.ambientZNeg.g;
					num += ambient.ambientZNeg.b;
					Color color = new Color(num3 / 6f, num2 / 6f, num / 6f, 0.5f);
					Gizmos.color = color;
					Gizmos.DrawCube(Map.Get().CellToWorld(j, i) + Vector3.up * 1.5f, new Vector3(1.5f, 3f, 1.5f));
				}
			}
		}
	}

	public float GetFogDistance()
	{
		if (RenderSettings.fogMode == FogMode.Linear)
		{
			return RenderSettings.fogEndDistance;
		}
		if (RenderSettings.fogMode == FogMode.Exponential && RenderSettings.fogDensity > 0f)
		{
			return Mathf.Log(526.3158f) / RenderSettings.fogDensity;
		}
		if (RenderSettings.fogMode == FogMode.ExponentialSquared && RenderSettings.fogDensity > 0f)
		{
			return Mathf.Sqrt(Mathf.Log(526.3158f)) / RenderSettings.fogDensity;
		}
		return float.MaxValue;
	}
}
public class AmbientStyle : ScriptableObject
{
	public string styleName;

	public Quaternion directionalRot;

	public Color directionalColor;

	public float directionalIntensity;

	public Color ambientX;

	public Color ambientXNeg;

	public Color ambientY;

	public Color ambientYNeg;

	public Color ambientZ;

	public Color ambientZNeg;

	public float ambientIntensity;

	public bool isHub;

	public Color fogColor;

	public float fogStart;

	public float fogEnd;

	public Color playerTorchColor;

	public float playerTorchRange;

	public float playerTorchIntensity;

	public float playerMapLightFactor = 1f;

	public string ambientTrack;

	public bool dustParticles;

	private SHLighting shLighting;

	public SHLighting SHLighting => shLighting;

	protected virtual void OnEnable()
	{
		shLighting = new SHLighting();
		ComputeSH();
	}

	public void ComputeSH()
	{
		shLighting.Clear();
		shLighting.AddDirectionalLight(ambientX, new Vector3(1f, 0f, 0f), ambientIntensity);
		shLighting.AddDirectionalLight(ambientXNeg, new Vector3(-1f, 0f, 0f), ambientIntensity);
		shLighting.AddDirectionalLight(ambientY, new Vector3(0f, 1f, 0f), ambientIntensity);
		shLighting.AddDirectionalLight(ambientYNeg, new Vector3(0f, -1f, 0f), ambientIntensity);
		shLighting.AddDirectionalLight(ambientZ, new Vector3(0f, 0f, 1f), ambientIntensity);
		shLighting.AddDirectionalLight(ambientZNeg, new Vector3(0f, 0f, -1f), ambientIntensity);
		shLighting.UpdateShaderConstants();
	}

	public void Clone(AmbientStyle original)
	{
		directionalRot = original.directionalRot;
		directionalColor = original.directionalColor;
		directionalIntensity = original.directionalIntensity;
		ambientX = original.ambientX;
		ambientXNeg = original.ambientXNeg;
		ambientY = original.ambientY;
		ambientYNeg = original.ambientYNeg;
		ambientZ = original.ambientZ;
		ambientZNeg = original.ambientZNeg;
		ambientIntensity = original.ambientIntensity;
		fogColor = original.fogColor;
		fogStart = original.fogStart;
		fogEnd = original.fogEnd;
		playerTorchColor = original.playerTorchColor;
		playerTorchRange = original.playerTorchRange;
		playerTorchIntensity = original.playerTorchIntensity;
		playerMapLightFactor = original.playerMapLightFactor;
		isHub = original.isHub;
	}
}
[ExecuteInEditMode]
public class AmbientTest : MonoBehaviour
{
	public Color lightX;

	public Color lightXNeg;

	public Color lightY;

	public Color lightYNeg;

	public Color lightZ;

	public Color lightZNeg;

	public float intensity = 1f;

	private void Start()
	{
		base.gameObject.transform.parent = null;
	}

	private void Update()
	{
		Shader.SetGlobalFloat("_DirAmbient_Intensity", intensity);
		Shader.SetGlobalColor("_DirAmbient_X", lightX);
		Shader.SetGlobalColor("_DirAmbient_X_Neg", lightXNeg);
		Shader.SetGlobalColor("_DirAmbient_Y", lightY);
		Shader.SetGlobalColor("_DirAmbient_Y_Neg", lightYNeg);
		Shader.SetGlobalColor("_DirAmbient_Z", lightZ);
		Shader.SetGlobalColor("_DirAmbient_Z_Neg", lightZNeg);
	}
}
[Serializable]
public class SHLighting
{
	public float[] coefficients = new float[27];

	private Vector4[] constants = new Vector4[7];

	public void Clear()
	{
		for (int i = 0; i < 27; i++)
		{
			coefficients[i] = 0f;
		}
	}

	public void AddAmbientLight(Color color)
	{
		float num = 3.5449078f;
		coefficients[0] += color.r * num;
		coefficients[1] += color.g * num;
		coefficients[2] += color.b * num;
	}

	public void AddDirectionalLight(Color color, Vector3 direction, float intensity)
	{
		float num = 0.2820948f;
		float num2 = 0.48860252f;
		float num3 = 1.0925485f;
		float num4 = 0.9461747f;
		float num5 = 0.54627424f;
		float num6 = 1f / 3f;
		float[] array = new float[9]
		{
			num,
			(0f - direction.y) * num2,
			direction.z * num2,
			(0f - direction.x) * num2,
			direction.x * direction.y * num3,
			(0f - direction.y) * direction.z * num3,
			(direction.z * direction.z - num6) * num4,
			(0f - direction.x) * direction.z * num3,
			(direction.x * direction.x - direction.y * direction.y) * num5
		};
		float num7 = 2.956793f;
		intensity *= 2f;
		float num8 = color.r * intensity * num7;
		float num9 = color.g * intensity * num7;
		float num10 = color.b * intensity * num7;
		for (int i = 0; i < 9; i++)
		{
			float num11 = array[i];
			coefficients[3 * i] += num11 * num8;
			coefficients[3 * i + 1] += num11 * num9;
			coefficients[3 * i + 2] += num11 * num10;
		}
	}

	public void AddPointLight(Color color, Vector3 position, float range, float intensity, Vector3 probePos)
	{
		Vector3 vector = position - probePos;
		float num = 1f / (1f + 25f * vector.sqrMagnitude / range * range);
		AddDirectionalLight(color, vector.normalized, intensity * num);
	}

	public Vector4[] GetShaderConstants()
	{
		return constants;
	}

	public void UpdateShaderConstants()
	{
		float num = Mathf.Sqrt((float)Math.PI);
		float num2 = 1f / (2f * num);
		float num3 = Mathf.Sqrt(3f) / (3f * num);
		float num4 = Mathf.Sqrt(15f) / (8f * num);
		float num5 = Mathf.Sqrt(5f) / (16f * num);
		float num6 = 0.5f * num4;
		for (int i = 0; i < 3; i++)
		{
			constants[i].x = (0f - num3) * coefficients[i + 9];
			constants[i].y = (0f - num3) * coefficients[i + 3];
			constants[i].z = num3 * coefficients[i + 6];
			constants[i].w = num2 * coefficients[i] - num5 * coefficients[i + 18];
		}
		for (int j = 0; j < 3; j++)
		{
			constants[j + 3].x = num4 * coefficients[j + 12];
			constants[j + 3].y = (0f - num4) * coefficients[j + 15];
			constants[j + 3].z = 3f * num5 * coefficients[j + 18];
			constants[j + 3].w = (0f - num4) * coefficients[j + 21];
		}
		constants[6].x = num6 * coefficients[24];
		constants[6].y = num6 * coefficients[25];
		constants[6].z = num6 * coefficients[26];
		constants[6].w = 1f;
	}
}
public class DisableOnPause : MonoBehaviour
{
	public List<GameObject> targetObjs;

	private bool[] prevEnabled;

	private bool isPaused;

	private void Start()
	{
		if (targetObjs == null)
		{
			targetObjs = new List<GameObject>();
		}
	}

	private void Update()
	{
		if (targetObjs.Count == 0)
		{
			return;
		}
		if (prevEnabled == null || prevEnabled.Length != targetObjs.Count)
		{
			prevEnabled = new bool[targetObjs.Count];
		}
		if (!isPaused && GameController.Get().wasJustPaused)
		{
			isPaused = true;
			for (int i = 0; i < targetObjs.Count; i++)
			{
				if (targetObjs[i] != null)
				{
					prevEnabled[i] = targetObjs[i].activeSelf;
					if (prevEnabled[i])
					{
						targetObjs[i].SetActive(value: false);
					}
				}
			}
		}
		else
		{
			if (!isPaused || GameController.Get().Paused)
			{
				return;
			}
			isPaused = false;
			for (int j = 0; j < targetObjs.Count; j++)
			{
				if (targetObjs[j] != null && prevEnabled[j])
				{
					targetObjs[j].SetActive(value: true);
				}
			}
		}
	}
}
public class HighlightEffect : MonoBehaviour
{
	private class CachedRenderer
	{
		private List<Material> originalMaterials;

		private Renderer rend;

		public CachedRenderer(Renderer rend)
		{
			this.rend = rend;
			originalMaterials = new List<Material>();
			originalMaterials.AddRange(rend.sharedMaterials);
		}

		public void Restore()
		{
			rend.sharedMaterials = originalMaterials.ToArray();
		}

		public void AddMaterial(Material newMat)
		{
			Material[] array = new Material[rend.sharedMaterials.Length + 1];
			for (int i = 0; i < rend.sharedMaterials.Length; i++)
			{
				array[i] = rend.sharedMaterials[i];
			}
			array[array.Length - 1] = newMat;
			rend.sharedMaterials = array;
		}
	}

	public Material highlightMaterial;

	private bool destroyMaterial;

	private bool state;

	private float curValue;

	private float targetValue;

	private float fadeSpeed = 4f;

	private List<CachedRenderer> cachedRenderers;

	private void Start()
	{
		if (highlightMaterial == null)
		{
			highlightMaterial = UnityEngine.Object.Instantiate(Resources.Load<Material>("Materials/highlight"));
			destroyMaterial = true;
		}
		cachedRenderers = new List<CachedRenderer>();
		MeshRenderer[] componentsInChildren = GetComponentsInChildren<MeshRenderer>();
		MeshRenderer[] array = componentsInChildren;
		foreach (MeshRenderer rend in array)
		{
			cachedRenderers.Add(new CachedRenderer(rend));
		}
	}

	private void Update()
	{
		if (state)
		{
			curValue = Mathf.Lerp(curValue, targetValue, Time.deltaTime * fadeSpeed);
			if (targetValue <= 0f && curValue <= 0.01f)
			{
				TurnOff();
			}
			else
			{
				highlightMaterial.SetFloat("_Intensity", curValue);
			}
		}
	}

	private void OnDestroy()
	{
		if (destroyMaterial)
		{
			UnityEngine.Object.DestroyImmediate(highlightMaterial);
		}
	}

	private void TurnOff()
	{
		state = false;
		curValue = (targetValue = 0f);
		foreach (CachedRenderer cachedRenderer in cachedRenderers)
		{
			cachedRenderer.Restore();
		}
	}

	public void FadeOut()
	{
		targetValue = 0f;
	}

	private void TurnOn()
	{
		targetValue = 1f;
		if (state)
		{
			return;
		}
		state = true;
		foreach (CachedRenderer cachedRenderer in cachedRenderers)
		{
			cachedRenderer.AddMaterial(highlightMaterial);
		}
	}

	public void FadeIn()
	{
		TurnOn();
	}
}
[ExecuteInEditMode]
public class Monochromize : ImageEffectBase
{
	[Range(0f, 1f)]
	public float intensity;

	public float brightnessFactor = 1f;

	protected override void OnDisable()
	{
	}

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		base.material.SetFloat("_Intensity", intensity);
		base.material.SetFloat("_BrightnessFactor", brightnessFactor);
		Graphics.Blit(source, destination, base.material);
	}
}
public class SetCamera2World : MonoBehaviour
{
	private Camera camera;

	private void Start()
	{
		camera = GetComponent<Camera>();
	}

	private void OnPreCull()
	{
		Shader.SetGlobalMatrix("_Camera2World", camera.cameraToWorldMatrix);
	}
}
public class EndingController : FSMComponent<EndingController.States>
{
	public enum States
	{
		InitDelay,
		Credits,
		CreditsEnd,
		Final
	}

	public UIDreadHallsMenu creditsMenu;

	private UIMenuAnimator creditsMenuAnimator;

	private float creditsTimeout;

	private int creditsIndex;

	private bool canContinue;

	private const float creditsShowTime = 7f;

	private void Start()
	{
		GC.Collect();
		Config.General().endingCredits = true;
		Config.General().randomModeUnlocked = true;
		Config.Save();
		creditsMenuAnimator = creditsMenu.GetComponent<UIMenuAnimator>();
		creditsMenuAnimator.ApplyAlpha(0f);
		Init(States.InitDelay);
	}

	private new void Update()
	{
		base.Update();
		ExitOnBack();
	}

	private void InitDelay_Enter()
	{
		creditsTimeout = 3f;
	}

	private void InitDelay_Update()
	{
		creditsTimeout -= Time.deltaTime;
		if (creditsTimeout <= 0f)
		{
			base.State = States.Credits;
		}
	}

	private void Credits_Enter()
	{
		creditsMenu.gameObject.SetActive(value: true);
		creditsMenu.Visible = true;
		creditsMenu.SetCollidersEnabled(enabled: true);
		creditsMenuAnimator.FadeIn();
		SetText(Translate.Get("MENU_ENDING_TITLE"));
		creditsIndex = 0;
		creditsTimeout = 7f;
	}

	private void Credits_Update()
	{
		creditsTimeout -= Time.deltaTime;
		if (creditsTimeout <= 0f)
		{
			canContinue = false;
			creditsMenuAnimator.FadeOut(reset: false, OnEndCreditsSectionFade);
		}
	}

	private void SetText(string txt)
	{
		string newText = "<material=1>" + txt + "</material>";
		creditsMenu.SetText("main_text", newText);
	}

	private void OnEndCreditsSectionFade()
	{
		string creditsString = GetCreditsString(creditsIndex);
		if (creditsString != string.Empty)
		{
			SetText(creditsString);
			creditsMenuAnimator.FadeIn();
			creditsIndex++;
			creditsTimeout = 7f;
			canContinue = true;
		}
		else
		{
			base.State = States.CreditsEnd;
		}
	}

	private string GetCreditsString(int idx)
	{
		string key = "MENU_CREDITS_SECTION_" + idx;
		if (!Translate.Check(key))
		{
			return string.Empty;
		}
		return Translate.Get(key);
	}

	private void CreditsEnd_Enter()
	{
		creditsTimeout = 12f;
		SetText(Translate.GetForInput("MENU_ENDING_EXIT"));
		creditsMenuAnimator.FadeIn();
	}

	private void OnEndCredits()
	{
		creditsMenu.gameObject.SetActive(value: false);
	}

	private void ExitOnBack()
	{
		if (InputExt.GetButtonDown(InputExt.Button.Cancel) || GameController.GetBackButtonDown() || InputExt.GetButtonDown(InputExt.Button.Action) || InputExt.GetButtonDown(InputExt.Button.UIAction))
		{
			GameController.Get().fader.SetColor(Color.black);
			GameController.Get().EndLevel();
		}
	}
}
public class ErrorMessage : MonoBehaviour
{
	public static string displayText = string.Empty;

	public TextLabel textLabel;

	private bool fading;

	public static void Display(string text, string errorMsgScene = "ErrorMessage")
	{
		displayText = text;
		Application.LoadLevel(errorMsgScene);
	}

	private void Start()
	{
		textLabel.Text = displayText;
		textLabel.FadeIn();
	}

	private void Update()
	{
		bool flag = InputExt.GetButtonDown(InputExt.Button.Action) || InputExt.GetButtonDown(InputExt.Button.Back) || Input.GetButtonDown("Fire1") || Input.anyKeyDown || Input.GetKeyDown(KeyCode.Escape) || Input.GetButtonDown("Cancel") || Utils.IsAnyButtonDown() || InputExt.GetButtonDown(InputExt.Button.Action) || InputExt.GetButtonDown(InputExt.Button.UIAction) || InputExt.GetButtonDown(InputExt.Button.Cancel);
		if (!fading && flag)
		{
			Exit_OnEndFade();
		}
	}

	private void Exit_OnEndFade()
	{
		Application.Quit();
	}
}
public class Fader : TimeIndependentBehaviour
{
	public Texture2D FadeTexture;

	public float FromOpacity;

	public float ToOpacity = 1f;

	public float Speed = 1f;

	public bool FadeAudio;

	public GameObject Listener;

	private float Progress;

	private Material material;

	private Action onEndDelegate;

	public void FadeOut(float speed = 1f, bool fadeAudio = false, GameObject listener = null, Action onEnd = null)
	{
		FromOpacity = 0f;
		ToOpacity = 1f;
		Speed = speed;
		Progress = 0f;
		FadeAudio = fadeAudio;
		Listener = listener;
		onEndDelegate = onEnd;
	}

	public void FadeIn(float speed = 1f, bool fadeAudio = false, GameObject listener = null, Action onEnd = null)
	{
		FromOpacity = 1f;
		ToOpacity = 0f;
		Speed = speed;
		Progress = 0f;
		FadeAudio = fadeAudio;
		Listener = listener;
		onEndDelegate = onEnd;
	}

	private new void Awake()
	{
		base.Awake();
		material = GetComponent<Renderer>().material;
		material.color = GetCurColor();
		GetComponent<Renderer>().enabled = material.color.a >= 0.01f;
	}

	private void Start()
	{
		Progress = 0f;
	}

	private new void Update()
	{
		base.Update();
		bool flag = Progress >= 1f;
		Progress += base.deltaTime * Speed;
		Progress = Mathf.Clamp01(Progress);
		if (FadeAudio && GameController.Get() != null)
		{
			AudioListener.volume = Mathf.Lerp(ToOpacity * Config.Audio().masterVolume * GameController.Get().VolumeMultiplier, FromOpacity * Config.Audio().masterVolume * GameController.Get().VolumeMultiplier, Progress);
		}
		material.color = GetCurColor();
		GetComponent<Renderer>().enabled = material.color.a >= 0.01f;
		if (flag)
		{
			if ((bool)Listener)
			{
				Listener.SendMessage("OnEndFade", this);
				Listener = null;
			}
			if (onEndDelegate != null)
			{
				onEndDelegate();
				onEndDelegate = null;
			}
		}
	}

	private Color GetCurColor()
	{
		float a = Mathf.Lerp(FromOpacity, ToOpacity, Progress);
		return new Color(material.color.r, material.color.g, material.color.b, a);
	}

	public void SetColor(Color color)
	{
		material.color = new Color(color.r, color.g, color.b, material.color.a);
	}

	public void ForceAlpha(float val)
	{
		material.color = new Color(material.color.r, material.color.g, material.color.b, val);
		GetComponent<Renderer>().enabled = material.color.a >= 0.01f;
	}
}
public class AnimEvents : MonoBehaviour
{
	public AudioClip[] Sounds;

	public float MinDistance = 1f;

	public float MaxDistance = 15f;

	public float Spread;

	public bool Logarithmic = true;

	private void PlaySound(int index)
	{
		if (index >= 0 && index < Sounds.Length)
		{
			Utils.PlayClipAt(Sounds[index], base.transform.position, MinDistance, MaxDistance, Spread, (!Logarithmic) ? AudioRolloffMode.Linear : AudioRolloffMode.Logarithmic);
		}
	}

	private void PerformAttack()
	{
		Debug.Log("AnimEvents: PerformAttack()");
		SendMessageUpwards("DoAttack");
	}

	private void SetPlayerMagnetOn()
	{
		SendMessageUpwards("SetPlayerMagnet", true);
	}

	private void SetPlayerMagnetOff()
	{
		SendMessageUpwards("SetPlayerMagnet", false);
	}
}
public class DbgUtils
{
	[Conditional("UNITY_EDITOR")]
	public static void Assert(bool condition)
	{
		if (!condition)
		{
			throw new Exception();
		}
	}
}
namespace Prison
{
	public class DiamondSquare
	{
		public static float[] Generate(int size, System.Random rgen)
		{
			return Generate(size, rgen, 400f, 2f);
		}

		public static float[] Generate(int size, System.Random rgen, float range, float hardness)
		{
			float[] map = new float[size * size];
			int num = size - 1;
			map[size * 0] = 128f;
			map[size * 0 + (size - 1)] = 128f;
			map[size * (size - 1)] = 128f;
			map[size * (size - 1) + (size - 1)] = 128f;
			while (num > 1)
			{
				for (int i = 0; i < size - 1; i += num)
				{
					for (int j = 0; j < size - 1; j += num)
					{
						Point center = new Point(i + num / 2, j + num / 2);
						ComputeColor(center, new Point[4]
						{
							new Point(i, j),
							new Point(i + num, j),
							new Point(i, j + num),
							new Point(i + num, j + num)
						}, range, ref map, size, rgen);
					}
				}
				for (int k = 0; k < size - 1; k += num)
				{
					for (int l = 0; l < size - 1; l += num)
					{
						int num2 = num / 2;
						Point center2 = new Point(k + num2, l);
						Point center3 = new Point(k, l + num2);
						ComputeColor(center2, new Point[4]
						{
							new Point(center2.X - num2, center2.Y),
							new Point(center2.X, center2.Y - num2),
							new Point(center2.X + num2, center2.Y),
							new Point(center2.X, center2.Y + num2)
						}, range, ref map, size, rgen);
						ComputeColor(center3, new Point[4]
						{
							new Point(center3.X - num2, center3.Y),
							new Point(center3.X, center3.Y - num2),
							new Point(center3.X + num2, center3.Y),
							new Point(center3.X, center3.Y + num2)
						}, range, ref map, size, rgen);
					}
				}
				range /= hardness;
				num /= 2;
			}
			return map;
		}

		private static void ComputeColor(Point center, Point[] points, float range, ref float[] map, int size, System.Random rgen)
		{
			float num = 0f;
			for (int i = 0; i < 4; i++)
			{
				if (points[i].X < 0)
				{
					points[i].X += size - 1;
				}
				else if (points[i].X >= size)
				{
					points[i].X -= size - 1;
				}
				if (points[i].Y < 0)
				{
					points[i].Y += size - 1;
				}
				else if (points[i].Y >= size)
				{
					points[i].Y -= size - 1;
				}
				num += map[size * points[i].Y + points[i].X];
			}
			num /= 4f;
			num += (float)rgen.NextDouble() * range - range / 2f;
			num = Mathf.Clamp(num, 0f, 255f);
			map[size * center.Y + center.X] = num;
			if (center.X == 0)
			{
				map[size * center.Y + (size - 1)] = num;
			}
			else if (center.X == size - 1)
			{
				map[size * center.Y] = num;
			}
			if (center.Y == 0)
			{
				map[size * (size - 1) + center.X] = num;
			}
			else if (center.Y == size - 1)
			{
				map[size * 0 + center.X] = num;
			}
		}
	}
}
public static class ColorExt
{
	public static Vector3 ToVector3_RGB(this Color color)
	{
		return new Vector3(color.r, color.g, color.b);
	}

	public static Vector4 ToVector4_RGBA(this Color color)
	{
		return new Vector4(color.r, color.g, color.b, color.a);
	}

	public static Vector4 ToVector4_ARGB(this Color color)
	{
		return new Vector4(color.a, color.r, color.g, color.b);
	}

	public static float Luminance(this Color color)
	{
		Vector3 rhs = new Vector3(0.22f, 0.707f, 0.071f);
		Vector3 lhs = color.ToVector3_RGB();
		return Vector3.Dot(lhs, rhs);
	}

	public static float LuminanceAlpha(this Color color)
	{
		Vector3 rhs = new Vector3(0.22f, 0.707f, 0.071f);
		Vector3 lhs = color.ToVector3_RGB();
		lhs.x *= color.a;
		lhs.y *= color.a;
		lhs.z *= color.a;
		return Vector3.Dot(lhs, rhs);
	}

	public static Color FromValue(uint value)
	{
		Color result = default(Color);
		result.r = 0.003921569f * (float)(int)(byte)(value >> 16);
		result.g = 0.003921569f * (float)(int)(byte)(value >> 8);
		result.b = 0.003921569f * (float)(int)(byte)(value >> 0);
		result.a = 0.003921569f * (float)(int)(byte)(value >> 24);
		return result;
	}

	public static string ToHex(this Color color)
	{
		Color32 color2 = color;
		return color2.a.ToString("X2") + color2.r.ToString("X2") + color2.g.ToString("X2") + color2.b.ToString("X2");
	}

	public static Color FromHexString(string hex)
	{
		byte a = byte.Parse(hex.Substring(0, 2), NumberStyles.HexNumber);
		byte r = byte.Parse(hex.Substring(2, 2), NumberStyles.HexNumber);
		byte g = byte.Parse(hex.Substring(4, 2), NumberStyles.HexNumber);
		byte b = byte.Parse(hex.Substring(6, 2), NumberStyles.HexNumber);
		return new Color32(r, g, b, a);
	}

	public static Color WithAlpha(this Color color, float newAlpha)
	{
		return new Color(color.r, color.g, color.b, newAlpha);
	}
}
public static class DebugExt
{
	public static void DrawCube(Vector3 pos, Color col, Vector3 scale, float duration = 0f)
	{
		Vector3 vector = scale * 0.5f;
		Vector3[] array = new Vector3[8]
		{
			pos + new Vector3(vector.x, vector.y, vector.z),
			pos + new Vector3(0f - vector.x, vector.y, vector.z),
			pos + new Vector3(0f - vector.x, 0f - vector.y, vector.z),
			pos + new Vector3(vector.x, 0f - vector.y, vector.z),
			pos + new Vector3(vector.x, vector.y, 0f - vector.z),
			pos + new Vector3(0f - vector.x, vector.y, 0f - vector.z),
			pos + new Vector3(0f - vector.x, 0f - vector.y, 0f - vector.z),
			pos + new Vector3(vector.x, 0f - vector.y, 0f - vector.z)
		};
		Debug.DrawLine(array[0], array[1], col, duration);
		Debug.DrawLine(array[1], array[2], col, duration);
		Debug.DrawLine(array[2], array[3], col, duration);
		Debug.DrawLine(array[3], array[0], col, duration);
		Debug.DrawLine(array[4], array[5], col, duration);
		Debug.DrawLine(array[5], array[6], col, duration);
		Debug.DrawLine(array[6], array[7], col, duration);
		Debug.DrawLine(array[7], array[4], col, duration);
		Debug.DrawLine(array[0], array[4], col, duration);
		Debug.DrawLine(array[1], array[5], col, duration);
		Debug.DrawLine(array[2], array[6], col, duration);
		Debug.DrawLine(array[3], array[7], col, duration);
	}

	public static void DrawRect(Rect rect, Color col, float duration = 0f)
	{
		Vector3 pos = new Vector3(rect.x + rect.width / 2f, rect.y + rect.height / 2f, 0f);
		Vector3 scale = new Vector3(rect.width, rect.height, 0f);
		DrawRect(pos, col, scale, duration);
	}

	public static void DrawRect(Vector3 pos, Color col, Vector3 scale, float duration = 0f)
	{
		Vector3 vector = scale * 0.5f;
		Vector3[] array = new Vector3[4]
		{
			pos + new Vector3(vector.x, vector.y, vector.z),
			pos + new Vector3(0f - vector.x, vector.y, vector.z),
			pos + new Vector3(0f - vector.x, 0f - vector.y, vector.z),
			pos + new Vector3(vector.x, 0f - vector.y, vector.z)
		};
		Debug.DrawLine(array[0], array[1], col, duration);
		Debug.DrawLine(array[1], array[2], col, duration);
		Debug.DrawLine(array[2], array[3], col, duration);
		Debug.DrawLine(array[3], array[0], col, duration);
	}

	public static void DrawPoint(Vector3 pos, Color col, float scale, float duration = 0f)
	{
		Vector3[] array = new Vector3[6]
		{
			pos + Vector3.up * scale,
			pos - Vector3.up * scale,
			pos + Vector3.right * scale,
			pos - Vector3.right * scale,
			pos + Vector3.forward * scale,
			pos - Vector3.forward * scale
		};
		Debug.DrawLine(array[0], array[1], col, duration);
		Debug.DrawLine(array[2], array[3], col, duration);
		Debug.DrawLine(array[4], array[5], col, duration);
	}

	public static void DrawSphere(Vector3 pos, Color col, float radius = 1f, float duration = 0f)
	{
		float num = (float)Math.PI / 30f;
		Vector3 vector = Vector3.zero;
		for (float num2 = 0f; num2 <= (float)Math.PI * 2f + num / 2f; num2 += num)
		{
			Vector3 vector2 = new Vector3(radius * Mathf.Cos(num2), radius * Mathf.Sin(num2), 0f);
			vector2 += pos;
			if (vector != Vector3.zero)
			{
				Debug.DrawLine(vector, vector2, col, duration);
			}
			vector = vector2;
		}
		vector = Vector3.zero;
		for (float num3 = 0f; num3 <= (float)Math.PI * 2f + num / 2f; num3 += num)
		{
			Vector3 vector3 = new Vector3(radius * Mathf.Cos(num3), 0f, radius * Mathf.Sin(num3));
			vector3 += pos;
			if (vector != Vector3.zero)
			{
				Debug.DrawLine(vector, vector3, col, duration);
			}
			vector = vector3;
		}
		vector = Vector3.zero;
		for (float num4 = 0f; num4 <= (float)Math.PI * 2f + num / 2f; num4 += num)
		{
			Vector3 vector4 = new Vector3(0f, radius * Mathf.Cos(num4), radius * Mathf.Sin(num4));
			vector4 += pos;
			if (vector != Vector3.zero)
			{
				Debug.DrawLine(vector, vector4, col, duration);
			}
			vector = vector4;
		}
	}
}
public static class LayerMaskExtensions
{
	public static LayerMask Create(params string[] layerNames)
	{
		return NamesToMask(layerNames);
	}

	public static LayerMask Create(params int[] layerNumbers)
	{
		return LayerNumbersToMask(layerNumbers);
	}

	public static LayerMask NamesToMask(params string[] layerNames)
	{
		LayerMask layerMask = 0;
		foreach (string layerName in layerNames)
		{
			layerMask = (int)layerMask | (1 << LayerMask.NameToLayer(layerName));
		}
		return layerMask;
	}

	public static LayerMask LayerNumbersToMask(params int[] layerNumbers)
	{
		LayerMask layerMask = 0;
		foreach (int num in layerNumbers)
		{
			layerMask = (int)layerMask | (1 << num);
		}
		return layerMask;
	}

	public static LayerMask Inverse(this LayerMask original)
	{
		return ~(int)original;
	}

	public static LayerMask AddToMask(this LayerMask original, params string[] layerNames)
	{
		return (int)original | (int)NamesToMask(layerNames);
	}

	public static LayerMask RemoveFromMask(this LayerMask original, params string[] layerNames)
	{
		LayerMask layerMask = ~(int)original;
		return ~((int)layerMask | (int)NamesToMask(layerNames));
	}

	public static string[] MaskToNames(this LayerMask original)
	{
		List<string> list = new List<string>();
		for (int i = 0; i < 32; i++)
		{
			int num = 1 << i;
			if (((int)original & num) == num)
			{
				string text = LayerMask.LayerToName(i);
				if (!string.IsNullOrEmpty(text))
				{
					list.Add(text);
				}
			}
		}
		return list.ToArray();
	}

	public static string MaskToString(this LayerMask original)
	{
		return original.MaskToString(", ");
	}

	public static string MaskToString(this LayerMask original, string delimiter)
	{
		return string.Join(delimiter, original.MaskToNames());
	}
}
public static class ListExtensions
{
	public static void Reverse_NoHeapAlloc<T>(this List<T> list)
	{
		int count = list.Count;
		for (int i = 0; i < count / 2; i++)
		{
			T value = list[i];
			list[i] = list[count - i - 1];
			list[count - i - 1] = value;
		}
	}

	public static int GetOrderIndependentHashCode<T>(this List<T> list)
	{
		int num = 0;
		foreach (T item in list)
		{
			num ^= EqualityComparer<T>.Default.GetHashCode(item);
		}
		return num;
	}

	public static void AddIfNotInside<T>(this List<T> list, T item)
	{
		if (!list.Contains(item))
		{
			list.Add(item);
		}
	}

	public static void Shuffle<T>(this List<T> list)
	{
		int num = list.Count;
		while (num > 1)
		{
			num--;
			int index = UnityEngine.Random.Range(0, num + 1);
			T value = list[index];
			list[index] = list[num];
			list[num] = value;
		}
	}
}
public class StringBuilderEx
{
	public StringBuilder Builder;

	public StringBuilderEx(int capacity)
	{
		Builder = new StringBuilder(capacity);
		InitInnerStr();
	}

	public StringBuilderEx(int capacity, int maxCapacity)
	{
		Builder = new StringBuilder(capacity, maxCapacity);
		InitInnerStr();
	}

	private void InitInnerStr()
	{
	}

	public StringBuilder Get()
	{
		return Builder;
	}

	public override string ToString()
	{
		return Builder.ToString();
	}
}
public static class StringBuilderExtensions
{
	private static readonly char[] ms_digits = new char[16]
	{
		'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
		'A', 'B', 'C', 'D', 'E', 'F'
	};

	private static readonly uint ms_default_decimal_places = 5u;

	private static readonly char ms_default_pad_char = '0';

	public static StringBuilder ConcatFormat<A>(this StringBuilder string_builder, string format_string, A arg1) where A : IConvertible
	{
		return string_builder.ConcatFormat(format_string, arg1, 0, 0, 0);
	}

	public static StringBuilder ConcatFormat<A, B>(this StringBuilder string_builder, string format_string, A arg1, B arg2) where A : IConvertible where B : IConvertible
	{
		return string_builder.ConcatFormat(format_string, arg1, arg2, 0, 0);
	}

	public static StringBuilder ConcatFormat<A, B, C>(this StringBuilder string_builder, string format_string, A arg1, B arg2, C arg3) where A : IConvertible where B : IConvertible where C : IConvertible
	{
		return string_builder.ConcatFormat(format_string, arg1, arg2, arg3, 0);
	}

	public static StringBuilder ConcatFormat<A, B, C, D>(this StringBuilder string_builder, string format_string, A arg1, B arg2, C arg3, D arg4) where A : IConvertible where B : IConvertible where C : IConvertible where D : IConvertible
	{
		int num = 0;
		for (int i = 0; i < format_string.Length; i++)
		{
			if (format_string[i] != '{')
			{
				continue;
			}
			if (num < i)
			{
				string_builder.Append(format_string, num, i - num);
			}
			uint base_value = 10u;
			uint num2 = 0u;
			uint num3 = 5u;
			i++;
			char c = format_string[i];
			if (c == '{')
			{
				string_builder.Append('{');
				i++;
			}
			else
			{
				i++;
				if (format_string[i] == ':')
				{
					i++;
					while (format_string[i] == '0')
					{
						i++;
						num2++;
					}
					if (format_string[i] == 'X')
					{
						i++;
						base_value = 16u;
						if (format_string[i] >= '0' && format_string[i] <= '9')
						{
							num2 = (uint)(format_string[i] - 48);
							i++;
						}
					}
					else if (format_string[i] == '.')
					{
						i++;
						num3 = 0u;
						while (format_string[i] == '0')
						{
							i++;
							num3++;
						}
					}
				}
				for (; format_string[i] != '}'; i++)
				{
				}
				switch (c)
				{
				case '0':
					string_builder.ConcatFormatValue(arg1, num2, base_value, num3);
					break;
				case '1':
					string_builder.ConcatFormatValue(arg2, num2, base_value, num3);
					break;
				case '2':
					string_builder.ConcatFormatValue(arg3, num2, base_value, num3);
					break;
				case '3':
					string_builder.ConcatFormatValue(arg4, num2, base_value, num3);
					break;
				}
			}
			num = i + 1;
		}
		if (num < format_string.Length)
		{
			string_builder.Append(format_string, num, format_string.Length - num);
		}
		return string_builder;
	}

	private static void ConcatFormatValue<T>(this StringBuilder string_builder, T arg, uint padding, uint base_value, uint decimal_places) where T : IConvertible
	{
		switch (arg.GetTypeCode())
		{
		case TypeCode.UInt32:
			string_builder.Concat(arg.ToUInt32(NumberFormatInfo.CurrentInfo), padding, '0', base_value);
			break;
		case TypeCode.Int32:
			string_builder.Concat(arg.ToInt32(NumberFormatInfo.CurrentInfo), padding, '0', base_value);
			break;
		case TypeCode.Single:
			string_builder.Concat(arg.ToSingle(NumberFormatInfo.CurrentInfo), decimal_places, padding, '0');
			break;
		case TypeCode.String:
			string_builder.Append(Convert.ToString(arg));
			break;
		}
	}

	public static StringBuilder Concat(this StringBuilder string_builder, uint uint_val, uint pad_amount, char pad_char, uint base_val)
	{
		uint num = 0u;
		uint num2 = uint_val;
		do
		{
			num2 /= base_val;
			num++;
		}
		while (num2 != 0);
		string_builder.Append(pad_char, (int)Math.Max(pad_amount, num));
		int num3 = string_builder.Length;
		while (num != 0)
		{
			num3--;
			string_builder[num3] = ms_digits[uint_val % base_val];
			uint_val /= base_val;
			num--;
		}
		return string_builder;
	}

	public static StringBuilder Concat(this StringBuilder string_builder, uint uint_val)
	{
		string_builder.Concat(uint_val, 0u, ms_default_pad_char, 10u);
		return string_builder;
	}

	public static StringBuilder Concat(this StringBuilder string_builder, uint uint_val, uint pad_amount)
	{
		string_builder.Concat(uint_val, pad_amount, ms_default_pad_char, 10u);
		return string_builder;
	}

	public static StringBuilder Concat(this StringBuilder string_builder, uint uint_val, uint pad_amount, char pad_char)
	{
		string_builder.Concat(uint_val, pad_amount, pad_char, 10u);
		return string_builder;
	}

	public static StringBuilder Concat(this StringBuilder string_builder, int int_val, uint pad_amount, char pad_char, uint base_val)
	{
		if (int_val < 0)
		{
			string_builder.Append('-');
			uint uint_val = (uint)(-1 - int_val + 1);
			string_builder.Concat(uint_val, pad_amount, pad_char, base_val);
		}
		else
		{
			string_builder.Concat((uint)int_val, pad_amount, pad_char, base_val);
		}
		return string_builder;
	}

	public static StringBuilder Concat(this StringBuilder string_builder, int int_val)
	{
		string_builder.Concat(int_val, 0u, ms_default_pad_char, 10u);
		return string_builder;
	}

	public static StringBuilder Concat(this StringBuilder string_builder, int int_val, uint pad_amount)
	{
		string_builder.Concat(int_val, pad_amount, ms_default_pad_char, 10u);
		return string_builder;
	}

	public static StringBuilder Concat(this StringBuilder string_builder, int int_val, uint pad_amount, char pad_char)
	{
		string_builder.Concat(int_val, pad_amount, pad_char, 10u);
		return string_builder;
	}

	public static StringBuilder Concat(this StringBuilder string_builder, float float_val, uint decimal_places, uint pad_amount, char pad_char)
	{
		if (decimal_places == 0)
		{
			int int_val = ((!(float_val >= 0f)) ? ((int)(float_val - 0.5f)) : ((int)(float_val + 0.5f)));
			string_builder.Concat(int_val, pad_amount, pad_char, 10u);
		}
		else
		{
			int num = (int)float_val;
			string_builder.Concat(num, pad_amount, pad_char, 10u);
			string_builder.Append('.');
			float num2 = Math.Abs(float_val - (float)num);
			do
			{
				num2 *= 10f;
				decimal_places--;
			}
			while (decimal_places != 0);
			num2 += 0.5f;
			string_builder.Concat((uint)num2, 0u, '0', 10u);
		}
		return string_builder;
	}

	public static StringBuilder Concat(this StringBuilder string_builder, float float_val)
	{
		string_builder.Concat(float_val, ms_default_decimal_places, 0u, ms_default_pad_char);
		return string_builder;
	}

	public static StringBuilder Concat(this StringBuilder string_builder, float float_val, uint decimal_places)
	{
		string_builder.Concat(float_val, decimal_places, 0u, ms_default_pad_char);
		return string_builder;
	}

	public static StringBuilder Concat(this StringBuilder string_builder, float float_val, uint decimal_places, uint pad_amount)
	{
		string_builder.Concat(float_val, decimal_places, pad_amount, ms_default_pad_char);
		return string_builder;
	}
}
public static class TextureExt
{
	public static void SaveToFile(this Texture2D texture, string filename)
	{
		byte[] array = texture.EncodeToPNG();
		FileStream fileStream = File.OpenWrite(Application.dataPath + "/" + filename);
		fileStream.Write(array, 0, array.Length);
		fileStream.Close();
	}
}
public static class Vector3Ext
{
	public static Vector3 ToGround(this Vector3 vec)
	{
		Vector3 result = vec;
		result.y = 0f;
		return result;
	}

	public static Vector3 GroundNormalize(this Vector3 vec)
	{
		vec.y = 0f;
		vec.Normalize();
		return vec;
	}

	public static float magnitudeGround(this Vector3 vec)
	{
		return GroundVector(vec).magnitude;
	}

	public static float sqrMagnitudeGround(this Vector3 vec)
	{
		return GroundVector(vec).sqrMagnitude;
	}

	public static Vector3 GroundVector(Vector3 vec)
	{
		return new Vector3(vec.x, 0f, vec.z);
	}

	public static Vector3 GroundVector(Vector3 to, Vector3 from)
	{
		Vector3 vec = to - from;
		return vec.ToGround();
	}

	public static Vector3 Approach(this Vector3 vec, Vector3 to, float speed)
	{
		return vec + (to - vec) * speed;
	}

	public static Vector3 MajorAxis(this Vector3 vec)
	{
		float num = Mathf.Abs(vec.x);
		float num2 = Mathf.Abs(vec.y);
		float num3 = Mathf.Abs(vec.z);
		if (num > num2 && num > num3)
		{
			return new Vector3(1f, 0f, 0f) * Mathf.Sign(vec.x);
		}
		if (num2 > num && num2 > num3)
		{
			return new Vector3(0f, 1f, 0f) * Mathf.Sign(vec.y);
		}
		return new Vector3(0f, 0f, 1f) * Mathf.Sign(vec.z);
	}
}
public class FSM<T> where T : IComparable
{
	public class StateInfo
	{
		public Action Enter;

		public Action Exit;

		public Action Update;

		public Action FixedUpdate;

		public Action LateUpdate;

		public Action OnTimer;

		public StateInfo()
		{
			Enter = Nop;
			Exit = Nop;
			Update = Nop;
			FixedUpdate = Nop;
			LateUpdate = Nop;
			OnTimer = Nop;
		}

		public static void Nop()
		{
		}
	}

	private Dictionary<T, StateInfo> states = new Dictionary<T, StateInfo>();

	private T currentState = default(T);

	private StateInfo currentInfo;

	private float timer;

	private bool timerActive;

	public StateInfo this[T state]
	{
		get
		{
			if (states.TryGetValue(state, out var value))
			{
				return value;
			}
			value = new StateInfo();
			states[state] = value;
			return value;
		}
		set
		{
			states[state] = value;
		}
	}

	public T State
	{
		get
		{
			return currentState;
		}
		set
		{
			SetState(value);
		}
	}

	public FSM(object owner)
	{
		states.Clear();
		T[] array = (T[])Enum.GetValues(typeof(T));
		foreach (T state in array)
		{
			this[state] = new StateInfo();
			Action action = FindDelegate(owner, state, "Enter");
			if (action != null)
			{
				this[state].Enter = action;
			}
			action = FindDelegate(owner, state, "Exit");
			if (action != null)
			{
				this[state].Exit = action;
			}
			action = FindDelegate(owner, state, "Update");
			if (action != null)
			{
				this[state].Update = action;
			}
			action = FindDelegate(owner, state, "FixedUpdate");
			if (action != null)
			{
				this[state].FixedUpdate = action;
			}
			action = FindDelegate(owner, state, "LateUpdate");
			if (action != null)
			{
				this[state].LateUpdate = action;
			}
			action = FindDelegate(owner, state, "OnTimer");
			if (action != null)
			{
				this[state].OnTimer = action;
			}
		}
	}

	public void Clear()
	{
		states.Clear();
		currentInfo = null;
		ClearTimer();
	}

	public void ClearTimer()
	{
		timer = 0f;
		timerActive = false;
	}

	public void SetTimer(float time)
	{
		timer = time;
		timerActive = true;
	}

	public void Init(T initState)
	{
		currentState = initState;
		states.TryGetValue(currentState, out currentInfo);
		OnEnter();
	}

	private void SetState(T newState)
	{
		if (newState.CompareTo(currentState) != 0)
		{
			OnExit();
			currentState = newState;
			ClearTimer();
			states.TryGetValue(currentState, out currentInfo);
			OnEnter();
		}
	}

	private Action FindDelegate(object owner, T state, string type)
	{
		string name = state.ToString() + "_" + type;
		MethodInfo method = owner.GetType().GetMethod(name, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.InvokeMethod);
		if (method != null)
		{
			return Delegate.CreateDelegate(typeof(Action), owner, method) as Action;
		}
		return null;
	}

	private void OnEnter()
	{
		if (currentInfo != null)
		{
			currentInfo.Enter();
		}
	}

	private void OnExit()
	{
		if (currentInfo != null)
		{
			currentInfo.Exit();
		}
	}

	public void Update()
	{
		if (currentInfo != null)
		{
			currentInfo.Update();
		}
		if (timerActive)
		{
			timer -= Time.deltaTime;
			if (timer <= 0f)
			{
				ClearTimer();
				OnTimer();
			}
		}
	}

	public void FixedUpdate()
	{
		if (currentInfo != null)
		{
			currentInfo.FixedUpdate();
		}
	}

	public void LateUpdate()
	{
		if (currentInfo != null)
		{
			currentInfo.LateUpdate();
		}
	}

	public void OnTimer()
	{
		if (currentInfo != null)
		{
			currentInfo.OnTimer();
		}
	}
}
public class FSMComponent<T> : MonoBehaviour where T : IComparable
{
	protected FSM<T> fsm;

	public string curState;

	public T State
	{
		get
		{
			return fsm.State;
		}
		set
		{
			fsm.State = value;
		}
	}

	protected virtual void Awake()
	{
		fsm = new FSM<T>(this);
	}

	protected void Init(T startState)
	{
		fsm.Init(startState);
	}

	protected virtual void Update()
	{
		fsm.Update();
	}

	protected virtual void FixedUpdate()
	{
		fsm.FixedUpdate();
	}

	protected virtual void LateUpdate()
	{
		fsm.LateUpdate();
	}

	protected void ClearTimer()
	{
		fsm.ClearTimer();
	}

	protected void SetTimer(float time)
	{
		fsm.SetTimer(time);
	}
}
public class FSMTest : FSMComponent<FSMTest.States>
{
	public enum States
	{
		StateOne,
		StateTwo,
		StateThree
	}

	public void Start()
	{
		Init(States.StateOne);
	}

	private void StateOne_Enter()
	{
	}

	private void StateOne_Update()
	{
		base.State = States.StateThree;
	}

	private void StateOne_Exit()
	{
	}

	private void StateTwo_Enter()
	{
	}

	private void StateTwo_Update()
	{
	}

	private void StateTwo_Exit()
	{
	}
}
public class TimeIdependentFSMComponent<T> : TimeIndependentBehaviour where T : IComparable
{
	protected FSM<T> fsm;

	public string curState;

	public T State
	{
		get
		{
			return fsm.State;
		}
		set
		{
			fsm.State = value;
		}
	}

	protected override void Awake()
	{
		base.Awake();
		fsm = new FSM<T>(this);
	}

	protected void Init(T startState)
	{
		fsm.Init(startState);
	}

	protected override void Update()
	{
		base.Update();
		fsm.Update();
	}

	protected virtual void FixedUpdate()
	{
		fsm.FixedUpdate();
	}

	protected virtual void LateUpdate()
	{
		fsm.LateUpdate();
	}

	protected void ClearTimer()
	{
		fsm.ClearTimer();
	}

	protected void SetTimer(float time)
	{
		fsm.SetTimer(time);
	}
}
public class Interpolate
{
	public static float Lerp(float from, float to, float t)
	{
		return from + t * (to - from);
	}

	public static Vector3 Lerp(Vector3 from, Vector3 to, float t)
	{
		return Vector3.Lerp(from, to, t);
	}

	public static Vector2 Lerp(Vector2 from, Vector2 to, float t)
	{
		return Vector2.Lerp(from, to, t);
	}

	public static Color Lerp(Color from, Color to, float t)
	{
		return Color.Lerp(from, to, t);
	}

	public static float SmoothStep(float t)
	{
		return t * t * (3f - 2f * t);
	}

	public static float SmoothStep(float from, float to, float t)
	{
		return Lerp(from, to, SmoothStep(t));
	}

	public static Vector3 SmoothStep(Vector3 from, Vector3 to, float t)
	{
		return Lerp(from, to, SmoothStep(t));
	}

	public static Vector2 SmoothStep(Vector2 from, Vector2 to, float t)
	{
		return Lerp(from, to, SmoothStep(t));
	}

	public static Color SmoothStep(Color from, Color to, float t)
	{
		return Lerp(from, to, SmoothStep(t));
	}

	public static float EaseIn(float t)
	{
		return t * t;
	}

	public static float EaseOut(float t)
	{
		return 0f - t * (t - 2f);
	}

	public static float EaseInOut(float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			return 0.5f * t * t;
		}
		t -= 1f;
		return -0.5f * (t * (t - 2f) - 1f);
	}

	public static float EaseIn(float from, float to, float t)
	{
		return Lerp(from, to, EaseIn(t));
	}

	public static float EaseOut(float from, float to, float t)
	{
		return Lerp(from, to, EaseOut(t));
	}

	public static float EaseInOut(float from, float to, float t)
	{
		return Lerp(from, to, EaseInOut(t));
	}

	public static Vector3 EaseIn(Vector3 from, Vector3 to, float t)
	{
		return Lerp(from, to, EaseIn(t));
	}

	public static Vector3 EaseOut(Vector3 from, Vector3 to, float t)
	{
		return Lerp(from, to, EaseOut(t));
	}

	public static Vector3 EaseInOut(Vector3 from, Vector3 to, float t)
	{
		return Lerp(from, to, EaseInOut(t));
	}

	public static Vector2 EaseIn(Vector2 from, Vector2 to, float t)
	{
		return Lerp(from, to, EaseIn(t));
	}

	public static Vector2 EaseOut(Vector2 from, Vector2 to, float t)
	{
		return Lerp(from, to, EaseOut(t));
	}

	public static Vector2 EaseInOut(Vector2 from, Vector2 to, float t)
	{
		return Lerp(from, to, EaseInOut(t));
	}

	public static Color EaseIn(Color from, Color to, float t)
	{
		return Lerp(from, to, EaseIn(t));
	}

	public static Color EaseOut(Color from, Color to, float t)
	{
		return Lerp(from, to, EaseOut(t));
	}

	public static Color EaseInOut(Color from, Color to, float t)
	{
		return Lerp(from, to, EaseInOut(t));
	}

	public static float EaseInCubic(float t)
	{
		return t * t * t;
	}

	public static float EaseOutCubic(float t)
	{
		t -= 1f;
		return t * t * t + 1f;
	}

	public static float EaseInOutCubic(float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			return 0.5f * t * t * t;
		}
		t -= 2f;
		return 0.5f * (t * t * t + 2f);
	}

	public static float EaseInCubic(float from, float to, float t)
	{
		return Lerp(from, to, EaseInCubic(t));
	}

	public static float EaseOutCubic(float from, float to, float t)
	{
		return Lerp(from, to, EaseOutCubic(t));
	}

	public static float EaseInOutCubic(float from, float to, float t)
	{
		return Lerp(from, to, EaseInOutCubic(t));
	}

	public static Vector3 EaseInCubic(Vector3 from, Vector3 to, float t)
	{
		return Lerp(from, to, EaseInCubic(t));
	}

	public static Vector3 EaseOutCubic(Vector3 from, Vector3 to, float t)
	{
		return Lerp(from, to, EaseOutCubic(t));
	}

	public static Vector3 EaseInOutCubic(Vector3 from, Vector3 to, float t)
	{
		return Lerp(from, to, EaseInOutCubic(t));
	}

	public static Vector2 EaseInCubic(Vector2 from, Vector2 to, float t)
	{
		return Lerp(from, to, EaseInCubic(t));
	}

	public static Vector2 EaseOutCubic(Vector2 from, Vector2 to, float t)
	{
		return Lerp(from, to, EaseOutCubic(t));
	}

	public static Vector2 EaseInOutCubic(Vector2 from, Vector2 to, float t)
	{
		return Lerp(from, to, EaseInOutCubic(t));
	}

	public static Color EaseInCubic(Color from, Color to, float t)
	{
		return Lerp(from, to, EaseInCubic(t));
	}

	public static Color EaseOutCubic(Color from, Color to, float t)
	{
		return Lerp(from, to, EaseOutCubic(t));
	}

	public static Color EaseInOutCubic(Color from, Color to, float t)
	{
		return Lerp(from, to, EaseInOutCubic(t));
	}

	public static float EaseInQuart(float t)
	{
		return t * t * t * t;
	}

	public static float EaseOutQuart(float t)
	{
		t -= 1f;
		return 0f - (t * t * t * t - 1f);
	}

	public static float EaseInOutQuart(float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			return 0.5f * t * t * t * t;
		}
		t -= 2f;
		return -0.5f * (t * t * t * t - 2f);
	}

	public static float EaseInQuart(float from, float to, float t)
	{
		return Lerp(from, to, EaseInQuart(t));
	}

	public static float EaseOutQuart(float from, float to, float t)
	{
		return Lerp(from, to, EaseOutQuart(t));
	}

	public static float EaseInOutQuart(float from, float to, float t)
	{
		return Lerp(from, to, EaseInOutQuart(t));
	}

	public static Vector3 EaseInQuart(Vector3 from, Vector3 to, float t)
	{
		return Lerp(from, to, EaseInQuart(t));
	}

	public static Vector3 EaseOutQuart(Vector3 from, Vector3 to, float t)
	{
		return Lerp(from, to, EaseOutQuart(t));
	}

	public static Vector3 EaseInOutQuart(Vector3 from, Vector3 to, float t)
	{
		return Lerp(from, to, EaseInOutQuart(t));
	}

	public static Vector2 EaseInQuart(Vector2 from, Vector2 to, float t)
	{
		return Lerp(from, to, EaseInQuart(t));
	}

	public static Vector2 EaseOutQuart(Vector2 from, Vector2 to, float t)
	{
		return Lerp(from, to, EaseOutQuart(t));
	}

	public static Vector2 EaseInOutQuart(Vector2 from, Vector2 to, float t)
	{
		return Lerp(from, to, EaseInOutQuart(t));
	}

	public static Color EaseInQuart(Color from, Color to, float t)
	{
		return Lerp(from, to, EaseInQuart(t));
	}

	public static Color EaseOutQuart(Color from, Color to, float t)
	{
		return Lerp(from, to, EaseOutQuart(t));
	}

	public static Color EaseInOutQuart(Color from, Color to, float t)
	{
		return Lerp(from, to, EaseInOutQuart(t));
	}

	public static float EaseInQuintic(float t)
	{
		return t * t * t * t * t;
	}

	public static float EaseOutQuintic(float t)
	{
		t -= 1f;
		return t * t * t * t * t + 1f;
	}

	public static float EaseInOutQuintic(float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			return 0.5f * t * t * t * t * t;
		}
		t -= 2f;
		return 0.5f * (t * t * t * t * t + 2f);
	}

	public static float EaseInQuintic(float from, float to, float t)
	{
		return Lerp(from, to, EaseInQuintic(t));
	}

	public static float EaseOutQuintic(float from, float to, float t)
	{
		return Lerp(from, to, EaseOutQuintic(t));
	}

	public static float EaseInOutQuintic(float from, float to, float t)
	{
		return Lerp(from, to, EaseInOutQuintic(t));
	}

	public static Vector3 EaseInQuintic(Vector3 from, Vector3 to, float t)
	{
		return Lerp(from, to, EaseInQuintic(t));
	}

	public static Vector3 EaseOutQuintic(Vector3 from, Vector3 to, float t)
	{
		return Lerp(from, to, EaseOutQuintic(t));
	}

	public static Vector3 EaseInOutQuintic(Vector3 from, Vector3 to, float t)
	{
		return Lerp(from, to, EaseInOutQuintic(t));
	}

	public static Vector2 EaseInQuintic(Vector2 from, Vector2 to, float t)
	{
		return Lerp(from, to, EaseInQuintic(t));
	}

	public static Vector2 EaseOutQuintic(Vector2 from, Vector2 to, float t)
	{
		return Lerp(from, to, EaseOutQuintic(t));
	}

	public static Vector2 EaseInOutQuintic(Vector2 from, Vector2 to, float t)
	{
		return Lerp(from, to, EaseInOutQuintic(t));
	}

	public static Color EaseInQuintic(Color from, Color to, float t)
	{
		return Lerp(from, to, EaseInQuintic(t));
	}

	public static Color EaseOutQuintic(Color from, Color to, float t)
	{
		return Lerp(from, to, EaseOutQuintic(t));
	}

	public static Color EaseInOutQuintic(Color from, Color to, float t)
	{
		return Lerp(from, to, EaseInOutQuintic(t));
	}

	public static float EaseInSine(float t)
	{
		return 1f - Mathf.Cos(t * (float)Math.PI / 2f);
	}

	public static float EaseOutSine(float t)
	{
		return Mathf.Sin(t * (float)Math.PI / 2f);
	}

	public static float EaseInOutSine(float t)
	{
		return -0.5f * (Mathf.Cos(t * (float)Math.PI) - 1f);
	}

	public static float EaseInSine(float from, float to, float t)
	{
		return Lerp(from, to, EaseInSine(t));
	}

	public static float EaseOutSine(float from, float to, float t)
	{
		return Lerp(from, to, EaseOutSine(t));
	}

	public static float EaseInOutSine(float from, float to, float t)
	{
		return Lerp(from, to, EaseInOutSine(t));
	}

	public static Vector3 EaseInSine(Vector3 from, Vector3 to, float t)
	{
		return Lerp(from, to, EaseInSine(t));
	}

	public static Vector3 EaseOutSine(Vector3 from, Vector3 to, float t)
	{
		return Lerp(from, to, EaseOutSine(t));
	}

	public static Vector3 EaseInOutSine(Vector3 from, Vector3 to, float t)
	{
		return Lerp(from, to, EaseInOutSine(t));
	}

	public static Vector2 EaseInSine(Vector2 from, Vector2 to, float t)
	{
		return Lerp(from, to, EaseInSine(t));
	}

	public static Vector2 EaseOutSine(Vector2 from, Vector2 to, float t)
	{
		return Lerp(from, to, EaseOutSine(t));
	}

	public static Vector2 EaseInOutSine(Vector2 from, Vector2 to, float t)
	{
		return Lerp(from, to, EaseInOutSine(t));
	}

	public static Color EaseInSine(Color from, Color to, float t)
	{
		return Lerp(from, to, EaseInSine(t));
	}

	public static Color EaseOutSine(Color from, Color to, float t)
	{
		return Lerp(from, to, EaseOutSine(t));
	}

	public static Color EaseInOutSine(Color from, Color to, float t)
	{
		return Lerp(from, to, EaseInOutSine(t));
	}

	public static float EaseInCircular(float t)
	{
		return 0f - (Mathf.Sqrt(1f - t * t) - 1f);
	}

	public static float EaseOutCircular(float t)
	{
		t -= 1f;
		return Mathf.Sqrt(1f - t * t);
	}

	public static float EaseInOutCircular(float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			return -0.5f * (Mathf.Sqrt(1f - t * t) - 1f);
		}
		t -= 2f;
		return 0.5f * (Mathf.Sqrt(1f - t * t) + 1f);
	}

	public static float EaseInCircular(float from, float to, float t)
	{
		return Lerp(from, to, EaseInCircular(t));
	}

	public static float EaseOutCircular(float from, float to, float t)
	{
		return Lerp(from, to, EaseOutCircular(t));
	}

	public static float EaseInOutCircular(float from, float to, float t)
	{
		return Lerp(from, to, EaseInOutCircular(t));
	}

	public static Vector3 EaseInCircular(Vector3 from, Vector3 to, float t)
	{
		return Lerp(from, to, EaseInCircular(t));
	}

	public static Vector3 EaseOutCircular(Vector3 from, Vector3 to, float t)
	{
		return Lerp(from, to, EaseOutCircular(t));
	}

	public static Vector3 EaseInOutCircular(Vector3 from, Vector3 to, float t)
	{
		return Lerp(from, to, EaseInOutCircular(t));
	}

	public static Vector2 EaseInCircular(Vector2 from, Vector2 to, float t)
	{
		return Lerp(from, to, EaseInCircular(t));
	}

	public static Vector2 EaseOutCircular(Vector2 from, Vector2 to, float t)
	{
		return Lerp(from, to, EaseOutCircular(t));
	}

	public static Vector2 EaseInOutCircular(Vector2 from, Vector2 to, float t)
	{
		return Lerp(from, to, EaseInOutCircular(t));
	}

	public static Color EaseInCircular(Color from, Color to, float t)
	{
		return Lerp(from, to, EaseInCircular(t));
	}

	public static Color EaseOutCircular(Color from, Color to, float t)
	{
		return Lerp(from, to, EaseOutCircular(t));
	}

	public static Color EaseInOutCircular(Color from, Color to, float t)
	{
		return Lerp(from, to, EaseInOutCircular(t));
	}

	public static Vector2 Slerp(Vector2 from, Vector2 to, float t)
	{
		if (from == to)
		{
			return from;
		}
		float value = Vector2.Dot(from, to);
		value = Mathf.Clamp(value, -0.999f, 1f);
		float num = Mathf.Acos(value);
		if (num == 0f)
		{
			return from;
		}
		double num2 = Mathf.Sin(num);
		return (float)((double)Mathf.Sin((1f - t) * num) / num2) * from + (float)((double)Mathf.Sin(t * num) / num2) * to;
	}

	public static Vector3 Slerp(Vector3 from, Vector3 to, float t)
	{
		return Vector3.Slerp(from, to, t);
	}

	public static Quaternion Slerp(Quaternion from, Quaternion to, float t)
	{
		return Quaternion.Slerp(from, to, t);
	}

	public static float Approach(float current, float to, float speed)
	{
		return Lerp(current, to, speed);
	}

	public static Vector3 Approach(Vector3 current, Vector3 to, float speed)
	{
		return Vector3.Lerp(current, to, speed);
	}

	public static Vector2 Approach(Vector2 current, Vector2 to, float speed)
	{
		return Vector2.Lerp(current, to, speed);
	}

	public static Color Approach(Color current, Color to, float speed)
	{
		return Color.Lerp(current, to, speed);
	}

	public static float ApproachExp(float actual, float to, float speed)
	{
		return actual + (to - actual) * speed;
	}

	public static Vector3 ApproachExp(Vector3 actual, Vector3 to, float speed)
	{
		return actual + (to - actual) * speed;
	}

	public static Vector2 ApproachExp(Vector2 actual, Vector2 to, float speed)
	{
		return actual + (to - actual) * speed;
	}

	public static Color ApproachExp(Color actual, Color to, float speed)
	{
		return actual + (to - actual) * speed;
	}

	public static Vector3 Bezier(Vector3 vP1, Vector3 vP2, Vector3 vP3, Vector3 vP4, float t)
	{
		float num = 1f - t;
		float num2 = t * t;
		float num3 = num * num;
		float num4 = num2 * t;
		float num5 = 3f * num2 * num;
		float num6 = 3f * t * num3;
		float num7 = num3 * num;
		return num7 * vP1 + num6 * vP2 + num5 * vP3 + num4 * vP4;
	}

	public static Vector3 CatmullRom(Vector3 vP0, Vector3 vP1, Vector3 vP2, Vector3 vP3, float t)
	{
		return 0.5f * (2f * vP1 + (-vP0 + vP2) * t + (2f * vP0 - 5f * vP1 + 4f * vP2 - vP3) * t * t + (-vP0 + 3f * vP1 - 3f * vP2 + vP3) * t * t * t);
	}

	public static float Hermite(float start, float end, float value)
	{
		return Mathf.Lerp(start, end, value * value * (3f - 2f * value));
	}

	public static float Sinerp(float start, float end, float value)
	{
		return Mathf.Lerp(start, end, Mathf.Sin(value * (float)Math.PI * 0.5f));
	}

	public static float Coserp(float start, float end, float value)
	{
		return Mathf.Lerp(start, end, 1f - Mathf.Cos(value * (float)Math.PI * 0.5f));
	}

	public static float Berp(float start, float end, float value)
	{
		value = Mathf.Clamp01(value);
		value = (Mathf.Sin(value * (float)Math.PI * (0.2f + 2.5f * value * value * value)) * Mathf.Pow(1f - value, 2.2f) + value) * (1f + 1.2f * (1f - value));
		return start + (end - start) * value;
	}

	public static float Bounce(float x)
	{
		return Mathf.Abs(Mathf.Sin(6.28f * (x + 1f) * (x + 1f)) * (1f - x));
	}

	public static float Clerp(float start, float end, float value)
	{
		float num = 0f;
		float num2 = 360f;
		float num3 = Mathf.Abs((num2 - num) / 2f);
		float num4 = 0f;
		float num5 = 0f;
		if (end - start < 0f - num3)
		{
			num5 = (num2 - start + end) * value;
			return start + num5;
		}
		if (end - start > num3)
		{
			num5 = (0f - (num2 - end + start)) * value;
			return start + num5;
		}
		return start + (end - start) * value;
	}
}
public class LinearBlur
{
	private float _rSum;

	private float _gSum;

	private float _bSum;

	private Texture2D _sourceImage;

	private int _sourceWidth;

	private int _sourceHeight;

	private int _windowSize;

	public Texture2D Blur(Texture2D image, int radius, int iterations)
	{
		_windowSize = radius * 2 + 1;
		_sourceWidth = image.width;
		_sourceHeight = image.height;
		Texture2D texture2D = image;
		for (int i = 0; i < iterations; i++)
		{
			texture2D = OneDimensialBlur(texture2D, radius, horizontal: true);
			texture2D = OneDimensialBlur(texture2D, radius, horizontal: false);
		}
		return texture2D;
	}

	private Texture2D OneDimensialBlur(Texture2D image, int radius, bool horizontal)
	{
		_sourceImage = image;
		Texture2D texture2D = new Texture2D(image.width, image.height, image.format, mipmap: false);
		if (horizontal)
		{
			for (int i = 0; i < _sourceHeight; i++)
			{
				ResetSum();
				for (int j = 0; j < _sourceWidth; j++)
				{
					if (j == 0)
					{
						for (int k = radius * -1; k <= radius; k++)
						{
							AddPixel(GetPixelWithXCheck(k, i));
						}
					}
					else
					{
						Color pixelWithXCheck = GetPixelWithXCheck(j - radius - 1, i);
						Color pixelWithXCheck2 = GetPixelWithXCheck(j + radius, i);
						SubstPixel(pixelWithXCheck);
						AddPixel(pixelWithXCheck2);
					}
					texture2D.SetPixel(j, i, CalcPixelFromSum());
				}
			}
		}
		else
		{
			for (int l = 0; l < _sourceWidth; l++)
			{
				ResetSum();
				for (int m = 0; m < _sourceHeight; m++)
				{
					if (m == 0)
					{
						for (int n = radius * -1; n <= radius; n++)
						{
							AddPixel(GetPixelWithYCheck(l, n));
						}
					}
					else
					{
						Color pixelWithYCheck = GetPixelWithYCheck(l, m - radius - 1);
						Color pixelWithYCheck2 = GetPixelWithYCheck(l, m + radius);
						SubstPixel(pixelWithYCheck);
						AddPixel(pixelWithYCheck2);
					}
					texture2D.SetPixel(l, m, CalcPixelFromSum());
				}
			}
		}
		texture2D.Apply();
		return texture2D;
	}

	private Color GetPixelWithXCheck(int x, int y)
	{
		if (x <= 0)
		{
			return _sourceImage.GetPixel(0, y);
		}
		if (x >= _sourceWidth)
		{
			return _sourceImage.GetPixel(_sourceWidth - 1, y);
		}
		return _sourceImage.GetPixel(x, y);
	}

	private Color GetPixelWithYCheck(int x, int y)
	{
		if (y <= 0)
		{
			return _sourceImage.GetPixel(x, 0);
		}
		if (y >= _sourceHeight)
		{
			return _sourceImage.GetPixel(x, _sourceHeight - 1);
		}
		return _sourceImage.GetPixel(x, y);
	}

	private void AddPixel(Color pixel)
	{
		_rSum += pixel.r;
		_gSum += pixel.g;
		_bSum += pixel.b;
	}

	private void SubstPixel(Color pixel)
	{
		_rSum -= pixel.r;
		_gSum -= pixel.g;
		_bSum -= pixel.b;
	}

	private void ResetSum()
	{
		_rSum = 0f;
		_gSum = 0f;
		_bSum = 0f;
	}

	private Color CalcPixelFromSum()
	{
		return new Color(_rSum / (float)_windowSize, _gSum / (float)_windowSize, _bSum / (float)_windowSize);
	}
}
public class LinkedPrefab : MonoBehaviour
{
	public GameObject prefab;

	private void Awake()
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(prefab);
		gameObject.transform.parent = base.transform.parent;
		gameObject.transform.position = base.transform.position;
		gameObject.transform.rotation = base.transform.rotation;
		gameObject.name = base.gameObject.name;
		UnityEngine.Object.Destroy(base.gameObject);
	}
}
public class LSystem<T> where T : new()
{
	public struct Symbol
	{
		public Action<int, LSeq> rule;

		public T leaf;

		public bool hasValidLeaf;

		public Symbol(Action<int, LSeq> rule)
		{
			this.rule = rule;
			leaf = new T();
			hasValidLeaf = false;
		}

		public Symbol(T leaf)
		{
			rule = null;
			this.leaf = leaf;
			hasValidLeaf = true;
		}

		public bool IsRule()
		{
			return rule != null;
		}

		public bool IsTerminal()
		{
			return rule == null && hasValidLeaf;
		}

		public bool IsEmpty()
		{
			return rule == null && !hasValidLeaf;
		}

		public void ApplyRule(int capacity, LSeq seq)
		{
			rule(capacity, seq);
		}
	}

	public class LSeq
	{
		public List<Symbol> symbols;

		public LSeq()
		{
			symbols = new List<Symbol>();
		}

		public void Add(Symbol symbol)
		{
			symbols.Add(symbol);
		}

		public void Add(T leafSymbol)
		{
			symbols.Add(new Symbol(leafSymbol));
		}

		public void Add(Action<int, LSeq> ruleSymbol)
		{
			symbols.Add(new Symbol(ruleSymbol));
		}

		public int GetTerminalLength()
		{
			int num = 0;
			for (int i = 0; i < symbols.Count; i++)
			{
				if (symbols[i].IsTerminal())
				{
					num++;
				}
			}
			return num;
		}

		public void Expand(int idx, LSeq newSymbols)
		{
			symbols.RemoveAt(idx);
			for (int num = newSymbols.symbols.Count - 1; num >= 0; num--)
			{
				symbols.Insert(idx, newSymbols.symbols[num]);
			}
		}

		public List<T> Resolve()
		{
			List<T> list = new List<T>();
			for (int i = 0; i < symbols.Count; i++)
			{
				if (symbols[i].IsTerminal())
				{
					list.Add(symbols[i].leaf);
				}
			}
			return list;
		}
	}

	public List<T> Process(int capacity)
	{
		LSeq lSeq = new LSeq();
		Axiom(capacity, lSeq);
		List<Pair<int, LSeq>> list = new List<Pair<int, LSeq>>();
		bool flag = true;
		while (flag && capacity > lSeq.GetTerminalLength())
		{
			int num = 0;
			flag = false;
			int capacity2 = capacity - lSeq.GetTerminalLength();
			for (int i = 0; i < lSeq.symbols.Count; i++)
			{
				if (lSeq.symbols[i].IsRule())
				{
					if (num >= list.Count)
					{
						list.Add(new Pair<int, LSeq>(-1, new LSeq()));
					}
					list[num] = new Pair<int, LSeq>(i, list[num].Second);
					list[num].Second.symbols.Clear();
					lSeq.symbols[i].ApplyRule(capacity2, list[num].Second);
					num++;
					flag = true;
				}
			}
			for (int j = 0; j < num; j++)
			{
				lSeq.Expand(list[j].First, list[j].Second);
			}
		}
		return lSeq.Resolve();
	}

	public virtual void Axiom(int capacity, LSeq seq)
	{
	}

	protected Symbol Delay(Symbol delayed)
	{
		Action<int, LSeq> rule = delegate(int capacity, LSeq seq)
		{
			seq.Add(delayed);
		};
		return new Symbol(rule);
	}

	protected Symbol Delay(Action<int, LSeq> ruleSymbol)
	{
		return Delay(new Symbol(ruleSymbol));
	}

	protected Symbol Delay(T leafSymbol)
	{
		return Delay(new Symbol(leafSymbol));
	}

	protected void Choose(params Action[] options)
	{
		int num = UnityEngine.Random.Range(0, options.Length);
		options[num]();
	}

	public virtual string GetName()
	{
		return GetType().Name;
	}
}
public class TestGrammar : LSystem<char>
{
	public override void Axiom(int capacity, LSeq seq)
	{
		if (capacity <= 4)
		{
			seq.Add(H);
			return;
		}
		seq.Add('A');
		seq.Add('A');
		seq.Add('B');
		seq.Add(Delay(Axiom));
	}

	public void H(int capacity, LSeq seq)
	{
		if (capacity >= 1)
		{
			seq.Add('A');
			seq.Add(Delay(H));
		}
	}

	public void G(int capacity, LSeq seq)
	{
		if (capacity >= 1)
		{
			Choose(delegate
			{
				seq.Add('A');
			}, delegate
			{
				seq.Add('C');
			});
			seq.Add(Delay(G));
		}
	}
}
public class Pathfinder
{
	public class Node : IComparable<Node>
	{
		public enum EDirection
		{
			None,
			North,
			NorthEast,
			East,
			SouthEast,
			South,
			SouthWest,
			West,
			NorthWest
		}

		public Point Pos;

		public Node Parent;

		public float CostToNode;

		public float TotalCost;

		public bool InOpen;

		public bool InClosed;

		public EDirection LastDirection;

		public int CompareTo(Node tNode)
		{
			if (TotalCost < tNode.TotalCost)
			{
				return -1;
			}
			if (TotalCost > tNode.TotalCost)
			{
				return 1;
			}
			return 0;
		}

		public static EDirection ComputeDirection(Point prev, Point next)
		{
			Point point = new Point(next.X - prev.X, next.Y - prev.Y);
			if (point.X == 0 && point.Y < 0)
			{
				return EDirection.North;
			}
			if (point.X > 0 && point.Y < 0)
			{
				return EDirection.NorthEast;
			}
			if (point.X > 0 && point.Y == 0)
			{
				return EDirection.East;
			}
			if (point.X > 0 && point.Y > 0)
			{
				return EDirection.SouthEast;
			}
			if (point.X == 0 && point.Y > 0)
			{
				return EDirection.South;
			}
			if (point.X < 0 && point.Y > 0)
			{
				return EDirection.SouthWest;
			}
			if (point.X < 0 && point.Y == 0)
			{
				return EDirection.West;
			}
			if (point.X < 0 && point.Y < 0)
			{
				return EDirection.NorthWest;
			}
			return EDirection.None;
		}
	}

	public delegate float GetCostHandler(Point init, Point end, object movementDesc);

	public delegate bool CheckTraversalHandler(Point from, Point end, object movementDesc);

	public class Query
	{
		public enum EState
		{
			Pending,
			Running,
			Success,
			Failure
		}

		private Pathfinder Owner;

		public Point Init;

		public Point End;

		public EState State;

		public List<Point> Path;

		public object MovementDesc;

		public int numUpdates;

		public GetCostHandler EstimateCost;

		public GetCostHandler TraversalCost;

		public CheckTraversalHandler CheckTraversal;

		public float ChangeDirectionCost;

		public Query(Pathfinder owner)
		{
			Owner = owner;
			Path = new List<Point>(50);
			EstimateCost = (TraversalCost = null);
			CheckTraversal = null;
			ChangeDirectionCost = 0f;
			numUpdates = 0;
		}

		public void Initialize(Point init, Point end, object movementDesc, CheckTraversalHandler checkTraversal, GetCostHandler traversalCost, GetCostHandler estimateCost, float changeDirectionCost)
		{
			Init = init;
			End = end;
			State = EState.Pending;
			MovementDesc = movementDesc;
			CheckTraversal = checkTraversal;
			TraversalCost = traversalCost;
			EstimateCost = estimateCost;
			Path.Clear();
			ChangeDirectionCost = changeDirectionCost;
			numUpdates = 0;
		}

		public void Initialize(Point init, Point end, object movementDesc)
		{
			Initialize(init, end, movementDesc, null, null, null, 0f);
		}

		public void Initialize(Point init, Point end, object movementDesc, CheckTraversalHandler checkTraversal)
		{
			Initialize(init, end, movementDesc, checkTraversal, null, null, 0f);
		}

		public bool IsFinished()
		{
			return State == EState.Success || State == EState.Failure;
		}

		public bool IsSuccess()
		{
			return State == EState.Success;
		}

		public void Free()
		{
			Owner.FreeQuery(this);
		}
	}

	private static Pathfinder instance;

	public int iterationLimit = 120;

	private List<Node> m_CachedNodes = new List<Node>(1500);

	private int m_NextNode;

	private Dictionary<Point, Node> m_ActiveNodes = new Dictionary<Point, Node>(1500);

	private BinaryHeap<Node> m_OpenList = new BinaryHeap<Node>();

	private Queue<Query> m_PendingQueries = new Queue<Query>(16);

	private Query m_ActiveQuery;

	private GetCostHandler EstimateCostDelegate;

	private GetCostHandler TraversalCostDelegate;

	private CheckTraversalHandler CheckTraversalDelegate;

	private List<Query> m_listFreeQueries = new List<Query>(16);

	public Pathfinder(int iterationLimit = 120)
	{
		EstimateCostDelegate = DefaultEstimateCost;
		TraversalCostDelegate = DefaultGetTraversalCost;
		CheckTraversalDelegate = DefaultCheckTraversal;
		this.iterationLimit = iterationLimit;
	}

	public static Pathfinder Get()
	{
		if (instance == null)
		{
			instance = new Pathfinder();
		}
		return instance;
	}

	public static void Clear()
	{
		instance = null;
	}

	public Query AddQuery(Point init, Point end, object movementDesc, CheckTraversalHandler checkTraversal, GetCostHandler traversalCost, GetCostHandler estimateCost, float changeDirectionCost)
	{
		Query query = null;
		if (m_listFreeQueries.Count > 0)
		{
			query = m_listFreeQueries[0];
			m_listFreeQueries.RemoveAt(0);
		}
		else
		{
			query = new Query(this);
		}
		query.Initialize(init, end, movementDesc, checkTraversal, traversalCost, estimateCost, changeDirectionCost);
		m_PendingQueries.Enqueue(query);
		return query;
	}

	public Query AddQuery(Point init, Point end, object movementDesc, CheckTraversalHandler checkTraversal)
	{
		return AddQuery(init, end, movementDesc, checkTraversal, null, null, 0f);
	}

	public Query AddQuery(Point init, Point end, object movementDesc)
	{
		return AddQuery(init, end, movementDesc, null, null, null, 0f);
	}

	private Node AddNode(Point pos)
	{
		Node node = null;
		if (m_NextNode < m_CachedNodes.Count)
		{
			node = m_CachedNodes[m_NextNode++];
		}
		else
		{
			node = new Node();
			m_CachedNodes.Add(node);
			m_NextNode++;
		}
		node.Pos = pos;
		node.Parent = null;
		node.CostToNode = 0f;
		node.TotalCost = 0f;
		node.InOpen = false;
		node.InClosed = false;
		m_ActiveNodes[pos] = node;
		return node;
	}

	private void AddToOpen(Node tNode)
	{
		tNode.InOpen = true;
		m_OpenList.Push(tNode);
	}

	public float DefaultEstimateCost(Point init, Point end, object movementDesc)
	{
		return (new Vector2(init.X, init.Y) - new Vector2(end.X, end.Y)).magnitude;
	}

	public float DefaultGetTraversalCost(Point from, Point end, object movementDesc)
	{
		return (new Vector2(end.X, end.Y) - new Vector2(from.X, from.Y)).magnitude;
	}

	public bool DefaultCheckTraversal(Point from, Point end, object movementDesc)
	{
		return true;
	}

	public void Update()
	{
		if (m_ActiveQuery == null && m_PendingQueries.Count > 0)
		{
			m_ActiveQuery = m_PendingQueries.Dequeue();
		}
		if (m_ActiveQuery != null)
		{
			m_ActiveQuery.numUpdates++;
			if (RunAStar(m_ActiveQuery, iterationLimit))
			{
				m_ActiveQuery = null;
			}
		}
	}

	public bool RunAStar(Query query)
	{
		return RunAStar(query, int.MaxValue);
	}

	public bool RunAStar(Query query, int iterationLimit)
	{
		if (query.IsFinished())
		{
			return true;
		}
		if (query.State == Query.EState.Pending)
		{
			query.State = Query.EState.Running;
			m_NextNode = 0;
			m_ActiveNodes.Clear();
			m_OpenList.Clear();
			if (query.EstimateCost == null)
			{
				query.EstimateCost = EstimateCostDelegate;
			}
			if (query.TraversalCost == null)
			{
				query.TraversalCost = TraversalCostDelegate;
			}
			if (query.CheckTraversal == null)
			{
				query.CheckTraversal = CheckTraversalDelegate;
			}
			Node node = AddNode(query.Init);
			node.CostToNode = 0f;
			node.TotalCost = query.EstimateCost(query.Init, query.End, query.MovementDesc);
			node.Parent = null;
			AddToOpen(node);
		}
		for (int i = 0; i < iterationLimit; i++)
		{
			if (m_OpenList.Count == 0)
			{
				query.State = Query.EState.Failure;
				m_NextNode = 0;
				m_ActiveNodes.Clear();
				m_OpenList.Clear();
				return true;
			}
			Node node2 = m_OpenList.Pop();
			node2.InOpen = false;
			if (node2.Pos == query.End)
			{
				query.State = Query.EState.Success;
				query.Path.Clear();
				for (Node node3 = node2; node3 != null; node3 = node3.Parent)
				{
					query.Path.Insert(0, node3.Pos);
				}
				m_NextNode = 0;
				m_ActiveNodes.Clear();
				m_OpenList.Clear();
				return true;
			}
			for (int j = node2.Pos.X - 1; j <= node2.Pos.X + 1; j++)
			{
				for (int k = node2.Pos.Y - 1; k <= node2.Pos.Y + 1; k++)
				{
					Point point = new Point(j, k);
					if (node2.Pos == point || !query.CheckTraversal(node2.Pos, point, query.MovementDesc))
					{
						continue;
					}
					Node.EDirection eDirection = Node.ComputeDirection(node2.Pos, point);
					float num = node2.CostToNode + query.TraversalCost(node2.Pos, point, query.MovementDesc);
					if (eDirection != node2.LastDirection)
					{
						num += query.ChangeDirectionCost;
					}
					Node value = null;
					if (m_ActiveNodes.TryGetValue(point, out value))
					{
						if (value.CostToNode <= num)
						{
							continue;
						}
					}
					else
					{
						value = AddNode(point);
					}
					value.Parent = node2;
					value.CostToNode = num;
					value.TotalCost = num + query.EstimateCost(value.Pos, query.End, query.MovementDesc);
					value.InClosed = false;
					value.LastDirection = eDirection;
					if (value.InOpen)
					{
						int index = m_OpenList.IndexOf(value);
						m_OpenList.SiftUp(index);
					}
					else
					{
						AddToOpen(value);
					}
				}
			}
			node2.InClosed = true;
		}
		return false;
	}

	public void FreeQuery(Query query)
	{
		m_listFreeQueries.Add(query);
	}
}
public class Permutator
{
	private int Hits;

	private int SeqLength;

	private int InitWait;

	private int MaxStreak;

	private List<bool> Sequence;

	public bool Next
	{
		get
		{
			if (Sequence.Count == 0)
			{
				GenerateSequence();
			}
			bool result = Sequence[0];
			Sequence.RemoveAt(0);
			return result;
		}
	}

	public Permutator(int hits, int seqLength, int initWait = 0)
	{
		Hits = hits;
		SeqLength = seqLength;
		InitWait = initWait;
		if (SeqLength - InitWait < Hits)
		{
			Hits = SeqLength - InitWait;
		}
		Sequence = new List<bool>();
		GenerateSequence();
	}

	public bool PeekNext()
	{
		if (Sequence.Count == 0)
		{
			GenerateSequence();
		}
		return Sequence[0];
	}

	private void GenerateSequence()
	{
		for (int i = 0; i < SeqLength; i++)
		{
			Sequence.Add(item: false);
		}
		for (int j = 0; j < Hits; j++)
		{
			int index;
			do
			{
				index = UnityEngine.Random.Range(InitWait, SeqLength);
			}
			while (Sequence[index]);
			Sequence[index] = true;
		}
	}
}
[AddComponentMenu("Rendering/SetRenderQueue")]
public class SetRenderQueue : MonoBehaviour
{
	[SerializeField]
	protected int[] m_queues = new int[1] { 2020 };

	protected void Awake()
	{
		Material[] materials = GetComponent<Renderer>().materials;
		for (int i = 0; i < materials.Length && i < m_queues.Length; i++)
		{
			materials[i].renderQueue += m_queues[i];
		}
	}
}
public class Singleton : MonoBehaviour
{
	protected static Singleton instance;

	protected void Awake()
	{
		if (instance != null && instance != this)
		{
			UnityEngine.Object.DestroyImmediate(base.gameObject);
			return;
		}
		instance = this;
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
	}
}
public class TimeIndependentAnimation : TimeIndependentBehaviour
{
	public bool playOnStart;

	public string playOnStartStateName;

	private AnimationState currentState;

	private Action currentCompletionHandler;

	private float elapsedTime;

	private bool playing;

	private void Start()
	{
		if (playOnStart)
		{
			Play(playOnStartStateName);
		}
	}

	protected override void Update()
	{
		base.Update();
		if (!playing)
		{
			return;
		}
		elapsedTime += base.deltaTime;
		currentState.normalizedTime = elapsedTime / currentState.length;
		if (elapsedTime >= currentState.length)
		{
			playing = false;
			if (currentState.wrapMode == WrapMode.Loop)
			{
				Play(currentState.name);
			}
			else if (currentCompletionHandler != null)
			{
				currentCompletionHandler();
			}
		}
	}

	public void Play(string stateName, Action completionHandler = null)
	{
		elapsedTime = 0f;
		currentState = GetComponent<Animation>()[stateName];
		currentState.normalizedTime = 0f;
		currentState.enabled = true;
		currentState.weight = 1f;
		currentCompletionHandler = completionHandler;
		playing = true;
	}
}
public class TimeIndependentBehaviour : MonoBehaviour
{
	public bool pausable;

	private float previousTimeSinceStartup;

	public float deltaTime { get; private set; }

	protected virtual void Awake()
	{
		previousTimeSinceStartup = Time.realtimeSinceStartup;
	}

	protected virtual void OnEnable()
	{
		previousTimeSinceStartup = Time.realtimeSinceStartup;
	}

	protected virtual void Update()
	{
		float realtimeSinceStartup = Time.realtimeSinceStartup;
		deltaTime = Mathf.Clamp(realtimeSinceStartup - previousTimeSinceStartup, 0f, 0.33333f);
		previousTimeSinceStartup = realtimeSinceStartup;
		if (deltaTime < 0f)
		{
			deltaTime = 0f;
		}
		if (pausable && GameController.Get().Paused)
		{
			deltaTime = 0f;
		}
	}

	public IEnumerator TimeIndependentWaitForSeconds(float seconds)
	{
		for (float elapsedTime = 0f; elapsedTime < seconds; elapsedTime += deltaTime)
		{
			yield return null;
		}
	}

	protected void PlayClipAtPoint(AudioClip clip, Vector3 pos)
	{
		float timeScale = Time.timeScale;
		bool flag = timeScale == 0f;
		if (flag)
		{
			Time.timeScale = 1f;
		}
		AudioSource.PlayClipAtPoint(clip, pos);
		if (flag)
		{
			Time.timeScale = timeScale;
		}
	}

	protected void PlayClipAtPoint(AudioClip clip, Vector3 pos, float volume)
	{
		float timeScale = Time.timeScale;
		bool flag = timeScale == 0f;
		if (flag)
		{
			Time.timeScale = 1f;
		}
		AudioSource.PlayClipAtPoint(clip, pos, volume);
		if (flag)
		{
			Time.timeScale = timeScale;
		}
	}

	protected void UpdateTimeSinceStartup()
	{
		previousTimeSinceStartup = Time.realtimeSinceStartup;
	}
}
public class TimeIndependentParticleSystem : TimeIndependentBehaviour
{
	protected override void Update()
	{
		base.Update();
		GetComponent<ParticleSystem>().Simulate(base.deltaTime, withChildren: true, restart: false);
	}
}
public class Translate
{
	private static Translate instance;

	private Dictionary<string, Dictionary<string, string>> langTables;

	private Dictionary<string, string> curTable;

	private string curLangIndex = string.Empty;

	private Translate()
	{
		langTables = new Dictionary<string, Dictionary<string, string>>();
	}

	public static Translate Instance()
	{
		if (instance == null)
		{
			instance = new Translate();
		}
		return instance;
	}

	public static void LoadBaseFolder(string basePath)
	{
		Translate translate = Instance();
		SystemLanguage[] array = (SystemLanguage[])Enum.GetValues(typeof(SystemLanguage));
		for (int i = 0; i < array.Length; i++)
		{
			SystemLanguage systemLanguage = array[i];
			string text = systemLanguage.ToString().ToLower();
			translate.LoadFolder(basePath + "/" + text, text);
		}
		translate.curLangIndex = "english";
		translate.curTable = translate.langTables["english"];
	}

	private bool LoadFolder(string path, string langName = "english")
	{
		TextAsset[] array = Resources.LoadAll<TextAsset>(path);
		if (array.Length == 0)
		{
			return false;
		}
		if (!langTables.TryGetValue(langName, out var value))
		{
			value = new Dictionary<string, string>();
			langTables[langName] = value;
		}
		TextAsset[] array2 = array;
		foreach (TextAsset textAsset in array2)
		{
			ProcessFile(textAsset, value);
		}
		return true;
	}

	private void ProcessFile(TextAsset textAsset, Dictionary<string, string> langTable)
	{
		StringReader stringReader = new StringReader(textAsset.text);
		char[] trimChars = new char[2] { ' ', '\t' };
		string text;
		while ((text = stringReader.ReadLine()) != null)
		{
			text = text.TrimEnd(trimChars);
			if (text.Length >= 2 && text[0] == '"')
			{
				int num = text.IndexOf('"', 1);
				string key = text.Substring(1, num - 1);
				int num2 = text.IndexOf('"', num + 1);
				string str = text.Substring(num2 + 1, text.Length - 1 - (num2 + 1));
				str = Regex.Unescape(str);
				langTable[key] = str;
			}
		}
	}

	public static bool SetLanguage(string index)
	{
		if (Instance().langTables.ContainsKey(index))
		{
			Instance().curLangIndex = index;
			Instance().curTable = Instance().langTables[index];
			return true;
		}
		return false;
	}

	public static string GetLanguage()
	{
		return Instance().curLangIndex;
	}

	public static void SetSystemLanguage()
	{
		SystemLanguage systemLanguage = Application.systemLanguage;
		string language = systemLanguage.ToString().ToLower();
		if (systemLanguage == SystemLanguage.ChineseTraditional || systemLanguage == SystemLanguage.ChineseSimplified)
		{
			language = "chinese";
		}
		SetLanguage(language);
	}

	public static string[] ListLanguages()
	{
		Dictionary<string, Dictionary<string, string>>.KeyCollection keys = Instance().langTables.Keys;
		string[] array = new string[keys.Count];
		int num = 0;
		foreach (string item in keys)
		{
			array[num++] = item;
		}
		return array;
	}

	public static string Get(string key)
	{
		Translate translate = Instance();
		if (translate.curTable == null)
		{
			return "[[NO LANGUAGE SELECTED]]";
		}
		if (!translate.curTable.TryGetValue(key, out var value))
		{
			return "[[" + key + "]]";
		}
		return value;
	}

	public static string GetOrKey(string key)
	{
		return Get(key);
	}

	public static string GetForInput(string key)
	{
		if (InputExt.UsingHandControllers)
		{
			bool leftHanded = InputExt.LeftHanded;
			string key2 = key + "_TOUCH" + ((!leftHanded) ? "_RIGHT" : "_LEFT");
			if (Check(key2))
			{
				return Get(key2);
			}
			key2 = key + "_TOUCH";
			if (Check(key2))
			{
				return Get(key2);
			}
		}
		else if (InputExt.Using3DOFController)
		{
			string key3 = key + "_3DOF";
			if (Check(key3))
			{
				return Get(key3);
			}
		}
		return GetOrKey(key);
	}

	public static bool Check(string key)
	{
		Translate translate = Instance();
		return translate.curTable.ContainsKey(key);
	}
}
public class BinaryHeap<T> where T : IComparable<T>
{
	private List<T> m_Elements = new List<T>();

	public int Count => m_Elements.Count;

	public void Clear()
	{
		m_Elements.Clear();
	}

	public void Push(T item)
	{
		m_Elements.Add(item);
		SiftUp(m_Elements.Count - 1);
	}

	public T Peek()
	{
		return m_Elements[0];
	}

	public T Pop()
	{
		T result = m_Elements[0];
		m_Elements[0] = m_Elements[m_Elements.Count - 1];
		m_Elements.RemoveAt(m_Elements.Count - 1);
		SiftDown(0);
		return result;
	}

	public int IndexOf(T item)
	{
		return m_Elements.IndexOf(item);
	}

	public void SiftUp(int index)
	{
		while (index != 0 && m_Elements[index].CompareTo(m_Elements[index / 2]) < 0)
		{
			T value = m_Elements[index];
			m_Elements[index] = m_Elements[index / 2];
			m_Elements[index / 2] = value;
			index /= 2;
		}
	}

	public void SiftDown(int indexSwap)
	{
		while (true)
		{
			int num = indexSwap;
			if (2 * num + 1 <= m_Elements.Count - 1)
			{
				if (m_Elements[num * 2].CompareTo(m_Elements[num]) < 0)
				{
					indexSwap = num * 2;
				}
				if (m_Elements[num * 2 + 1].CompareTo(m_Elements[indexSwap]) < 0)
				{
					indexSwap = num * 2 + 1;
				}
			}
			else if (2 * num <= m_Elements.Count - 1 && m_Elements[num * 2].CompareTo(m_Elements[num]) < 0)
			{
				indexSwap = num * 2;
			}
			if (num == indexSwap)
			{
				break;
			}
			T value = m_Elements[num];
			m_Elements[num] = m_Elements[indexSwap];
			m_Elements[indexSwap] = value;
		}
	}
}
[Serializable]
public class CPoint : IEquatable<CPoint>
{
	public int X;

	public int Y;

	public static CPoint Zero => new CPoint(0, 0);

	public CPoint(int x, int y)
	{
		X = x;
		Y = y;
	}

	public CPoint(Point point)
	{
		X = point.X;
		Y = point.Y;
	}

	public static bool operator !=(CPoint a, CPoint b)
	{
		return a.X != b.X || a.Y != b.Y;
	}

	public static bool operator ==(CPoint a, CPoint b)
	{
		return a.X == b.X && a.Y == b.Y;
	}

	public override bool Equals(object obj)
	{
		if (obj is CPoint)
		{
			return Equals((CPoint)obj);
		}
		return false;
	}

	public bool Equals(CPoint other)
	{
		return X == other.X && Y == other.Y;
	}

	public override int GetHashCode()
	{
		int num = 17;
		num = num * 23 + X.GetHashCode();
		return num * 23 + Y.GetHashCode();
	}

	public static CPoint operator +(CPoint p1, CPoint p2)
	{
		return new CPoint(p1.X + p2.X, p1.Y + p2.Y);
	}

	public static CPoint operator -(CPoint p1, CPoint p2)
	{
		return new CPoint(p1.X - p2.X, p1.Y - p2.Y);
	}

	public static CPoint operator /(CPoint p1, int v)
	{
		return new CPoint(p1.X / v, p1.Y / v);
	}

	public static CPoint operator *(CPoint p1, int v)
	{
		return new CPoint(p1.X * v, p1.Y * v);
	}

	public void Set(CPoint point)
	{
		X = point.X;
		Y = point.Y;
	}

	public void Set(Point point)
	{
		X = point.X;
		Y = point.Y;
	}

	public Point ToPoint()
	{
		return new Point(X, Y);
	}
}
public struct IntRect
{
	private int _xMin;

	private int _xMax;

	private int _yMin;

	private int _yMax;

	public int bottom => _yMax;

	public int height
	{
		get
		{
			return _yMax - _yMin;
		}
		set
		{
			_yMax = _yMin + value;
		}
	}

	public int left => _xMin;

	public int right => _xMax;

	public int top => _yMin;

	public int width
	{
		get
		{
			return _xMax - _xMin;
		}
		set
		{
			_xMax = _xMin + value;
		}
	}

	public int x
	{
		get
		{
			return _xMin;
		}
		set
		{
			_xMin = value;
		}
	}

	public int xMax
	{
		get
		{
			return _xMax;
		}
		set
		{
			_xMax = value;
		}
	}

	public int xMin
	{
		get
		{
			return _xMin;
		}
		set
		{
			_xMin = value;
		}
	}

	public int y
	{
		get
		{
			return _yMin;
		}
		set
		{
			_yMin = value;
		}
	}

	public int yMax
	{
		get
		{
			return _yMax;
		}
		set
		{
			_yMax = value;
		}
	}

	public int yMin
	{
		get
		{
			return _yMin;
		}
		set
		{
			_yMin = value;
		}
	}

	public IntRect(IntRect source)
	{
		_xMin = source.xMin;
		_xMax = source.xMax;
		_yMin = source.yMin;
		_yMax = source.yMax;
	}

	public IntRect(int left, int top, int width, int height)
	{
		_xMin = left;
		_yMin = top;
		_xMax = left + width;
		_yMax = top + height;
	}

	public static bool operator !=(IntRect lhs, IntRect rhs)
	{
		return lhs.xMin != rhs.xMin || lhs.yMin != rhs.yMin || lhs.xMax != rhs.xMax || lhs.yMax != rhs.yMax;
	}

	public static bool operator ==(IntRect lhs, IntRect rhs)
	{
		return lhs.xMin == rhs.xMin && lhs.yMin == rhs.yMin && lhs.xMax == rhs.xMax && lhs.yMax == rhs.yMax;
	}

	public bool Contains(Point point)
	{
		return point.X >= _xMin && point.X < _xMax && point.Y >= _yMin && point.Y < _yMax;
	}

	public override bool Equals(object other)
	{
		if (other is IntRect)
		{
			return (IntRect)other == this;
		}
		return false;
	}

	public override int GetHashCode()
	{
		int num = 17;
		num = num * 23 + _xMin.GetHashCode();
		num = num * 23 + _yMin.GetHashCode();
		num = num * 23 + _xMax.GetHashCode();
		return num * 23 + _yMax.GetHashCode();
	}

	public void Set(int left, int top, int width, int height)
	{
		_xMin = left;
		_yMin = top;
		_xMax = left + width;
		_yMax = top + height;
	}

	public override string ToString()
	{
		return "(" + _xMin + ", " + _yMin + ", " + width + ", " + height + ")";
	}
}
public struct Pair<T, U>
{
	public T First;

	public U Second;

	public Pair(T first, U second)
	{
		First = first;
		Second = second;
	}
}
public struct Point : IEquatable<Point>
{
	public int X;

	public int Y;

	public static Point Zero => new Point(0, 0);

	public Point(int x, int y)
	{
		X = x;
		Y = y;
	}

	public Point(CPoint cp)
	{
		X = cp.X;
		Y = cp.Y;
	}

	public static bool operator !=(Point a, Point b)
	{
		return a.X != b.X || a.Y != b.Y;
	}

	public static bool operator ==(Point a, Point b)
	{
		return a.X == b.X && a.Y == b.Y;
	}

	public override bool Equals(object obj)
	{
		if (obj is Point)
		{
			return Equals((Point)obj);
		}
		return false;
	}

	public bool Equals(Point other)
	{
		return X == other.X && Y == other.Y;
	}

	public override int GetHashCode()
	{
		int num = 17;
		num = num * 23 + X.GetHashCode();
		return num * 23 + Y.GetHashCode();
	}

	public static Point operator +(Point p1, Point p2)
	{
		return new Point(p1.X + p2.X, p1.Y + p2.Y);
	}

	public static Point operator -(Point p1, Point p2)
	{
		return new Point(p1.X - p2.X, p1.Y - p2.Y);
	}

	public static Point operator /(Point p1, int v)
	{
		return new Point(p1.X / v, p1.Y / v);
	}

	public static Point operator *(Point p1, int v)
	{
		return new Point(p1.X * v, p1.Y * v);
	}

	public float DistanceSq()
	{
		int num = Mathf.Abs(X);
		int num2 = Mathf.Abs(Y);
		return num * num + num2 * num2;
	}
}
public class Pool<T> where T : class, new()
{
	private List<T> items;

	private List<bool> availability;

	public Pool()
	{
		items = new List<T>();
		availability = new List<bool>();
	}

	public Pool(int capacity)
	{
		items = new List<T>(capacity);
		availability = new List<bool>(capacity);
		for (int i = 0; i < capacity; i++)
		{
			items.Add(new T());
			availability.Add(item: true);
		}
	}

	public T Get()
	{
		for (int i = 0; i < items.Count; i++)
		{
			if (availability[i])
			{
				availability[i] = false;
				return items[i];
			}
		}
		T val = new T();
		items.Add(val);
		availability.Add(item: false);
		return val;
	}

	public void Free(T item)
	{
		for (int i = 0; i < items.Count; i++)
		{
			if (items[i] == item)
			{
				availability[i] = true;
				break;
			}
		}
	}
}
namespace System
{
	public class Tuple<TItem1, TItem2>
	{
		public TItem1 Item1 { get; private set; }

		public TItem2 Item2 { get; private set; }

		public Tuple(TItem1 item1, TItem2 item2)
		{
			Item1 = item1;
			Item2 = item2;
		}

		public override bool Equals(object obj)
		{
			if (obj is Tuple<TItem1, TItem2>)
			{
				Tuple<TItem1, TItem2> tuple = (Tuple<TItem1, TItem2>)obj;
				return object.Equals(Item1, tuple.Item1) && object.Equals(Item2, tuple.Item2);
			}
			return false;
		}

		public override int GetHashCode()
		{
			return ((Item1 != null) ? Item1.GetHashCode() : 0) ^ ((Item2 != null) ? Item2.GetHashCode() : 0);
		}

		public static bool operator ==(Tuple<TItem1, TItem2> left, Tuple<TItem1, TItem2> right)
		{
			return left.Equals(right);
		}

		public static bool operator !=(Tuple<TItem1, TItem2> left, Tuple<TItem1, TItem2> right)
		{
			return !left.Equals(right);
		}
	}
	public class Tuple<TItem1, TItem2, TItem3>
	{
		public TItem1 Item1 { get; private set; }

		public TItem2 Item2 { get; private set; }

		public TItem3 Item3 { get; private set; }

		public Tuple(TItem1 item1, TItem2 item2, TItem3 item3)
		{
			Item1 = item1;
			Item2 = item2;
			Item3 = item3;
		}

		public override bool Equals(object obj)
		{
			if (obj is Tuple<TItem1, TItem2, TItem3>)
			{
				Tuple<TItem1, TItem2, TItem3> tuple = (Tuple<TItem1, TItem2, TItem3>)obj;
				return object.Equals(Item1, tuple.Item1) && object.Equals(Item2, tuple.Item2) && object.Equals(Item3, tuple.Item3);
			}
			return false;
		}

		public override int GetHashCode()
		{
			return ((Item1 != null) ? Item1.GetHashCode() : 0) ^ ((Item2 != null) ? Item2.GetHashCode() : 0) ^ ((Item3 != null) ? Item3.GetHashCode() : 0);
		}

		public static bool operator ==(Tuple<TItem1, TItem2, TItem3> left, Tuple<TItem1, TItem2, TItem3> right)
		{
			return left.Equals(right);
		}

		public static bool operator ==(Tuple<TItem1, TItem2, TItem3> left, object right)
		{
			return left.Equals(right);
		}

		public static bool operator !=(Tuple<TItem1, TItem2, TItem3> left, Tuple<TItem1, TItem2, TItem3> right)
		{
			return !left.Equals(right);
		}

		public static bool operator !=(Tuple<TItem1, TItem2, TItem3> left, object right)
		{
			return !left.Equals(right);
		}
	}
}
public class GameController : MonoBehaviour
{
	private static GameController instance;

	private static bool isFirstLoad = true;

	private bool firstUpdate = true;

	public bool UsingGamepad;

	public bool Win;

	public TextMesh debugText;

	public GameObject testObj;

	public LevelOptions levelOptions;

	public static LevelOptions nextOptions;

	public GameState gameState;

	private bool inGameScene;

	public Serializer serializer;

	public Fader fader;

	public Fader faderWin;

	public ClockMode.Mode clockMode;

	private bool needsRecenter;

	private bool paused;

	public bool wasJustPaused;

	private bool justRecentered;

	private float volumeMultiplier = 1f;

	private bool wasRightHanded;

	private float dpadAdjustTimer;

	private string gameOverText = string.Empty;

	private static bool checkedEntitlement;

	public bool Paused => paused;

	public bool HasJustRecentered => justRecentered;

	public float VolumeMultiplier
	{
		get
		{
			return volumeMultiplier;
		}
		set
		{
			if (volumeMultiplier != value)
			{
				volumeMultiplier = value;
				AudioListener.volume = Config.Audio().masterVolume * volumeMultiplier;
			}
		}
	}

	public bool IsInGameScene()
	{
		return inGameScene;
	}

	public static GameController Get()
	{
		return instance;
	}

	public static void Clear()
	{
		instance = null;
	}

	private void Awake()
	{
		Debug.Log("Starting Game Controller");
		instance = this;
		string[] joystickNames = Input.GetJoystickNames();
		Debug.Log("GameController - Loading config");
		Config.Load();
		InitializeTexts();
		AudioListener.volume = Config.Audio().masterVolume * volumeMultiplier;
		serializer = new Serializer();
		gameState = GameState.Get();
		UsingGamepad = joystickNames.Length > 0;
		Cursor.visible = false;
		Screen.lockCursor = true;
		Screen.sleepTimeout = -1;
		MapBuilder component = GetComponent<MapBuilder>();
		if (component != null)
		{
			if (nextOptions != null)
			{
				levelOptions = nextOptions;
				nextOptions = null;
			}
			component.generatorType = levelOptions.generatorType;
			component.levelOptions = levelOptions;
		}
		inGameScene = component != null;
		Win = false;
		Time.timeScale = 1f;
		ClockMode.Set(clockMode);
		Debug.Log("GameController - DebugAwake");
		DebugAwake();
		Debug.Log("GameController - End Awake");
	}

	private void DebugAwake()
	{
		GetComponent<Screenshot>().enabled = false;
	}

	public static void InitializeTexts()
	{
		Debug.Log("GameController - Loading translate tables");
		Translate.LoadBaseFolder("Text");
		if (Config.General().language == string.Empty)
		{
			Translate.SetSystemLanguage();
			Config.General().language = Translate.GetLanguage();
			Config.Save();
		}
		else
		{
			Translate.SetLanguage(Config.General().language);
		}
	}

	private void Start()
	{
		Debug.Log("GameController - Start");
		if (isFirstLoad)
		{
			Debug.Log("First Load ResetVROrientation");
			ResetVROrientation();
		}
		if (isFirstLoad)
		{
			Debug.Log("Setting Foveated Rendering to: Low");
		}
		isFirstLoad = false;
		InputExt.ResetLeftHanded();
		UpdateInput(forceUpdate: true);
		if (InputExt.HasHandControllers)
		{
			InputExt.ResetLeftHanded();
		}
		Debug.Log("GameController - End Start");
	}

	private void LogHandler(string message, string stacktrace, LogType type)
	{
		if (type == LogType.Error || type == LogType.Exception)
		{
			StackTrace stackTrace = new StackTrace(1, fNeedFileInfo: true);
			Debug.Log("-+- STACK TRACE -+-\n" + stackTrace.ToString());
			using StreamWriter streamWriter = new StreamWriter("stack_trace.txt");
			streamWriter.WriteLine(message);
			streamWriter.WriteLine("------");
			streamWriter.WriteLine(stacktrace);
			streamWriter.WriteLine("--- STACK TRACE ---");
			streamWriter.WriteLine(StackTraceUtility.ExtractStackTrace());
			streamWriter.WriteLine("------");
			streamWriter.Write(stackTrace.ToString());
		}
	}

	private void OnEnable()
	{
	}

	private void OnDisable()
	{
	}

	private void Update()
	{
		if (firstUpdate)
		{
			firstUpdate = false;
			InputExt.ResetLeftHanded();
		}
		justRecentered = false;
		if (needsRecenter)
		{
			Debug.Log("Auto-recenter");
			ResetVROrientation();
			needsRecenter = false;
		}
		if (Input.GetKeyDown(KeyCode.F11))
		{
			Screen.fullScreen = !Screen.fullScreen;
		}
		if (GetBackButtonDown() && Application.loadedLevelName == "Intro")
		{
			IntroMenuController component = GetComponent<IntroMenuController>();
			if ((bool)component)
			{
				component.OnBackButton();
			}
			else
			{
				ExitGame();
			}
		}
		if (Input.GetMouseButtonDown(0))
		{
			Cursor.visible = false;
		}
		if (InputExt.Using3DOFController && ((wasRightHanded && !InputExt.RightHanded) || (!wasRightHanded && InputExt.RightHanded)))
		{
			UpdateInput();
		}
		if (!paused)
		{
			wasJustPaused = false;
		}
	}

	public void ResetVROrientation()
	{
		Sensor.UPvr_ResetSensor(0);
		justRecentered = true;
	}

	public void EnterPause()
	{
		if (!paused || !(Time.timeScale <= 0f))
		{
			paused = true;
			wasJustPaused = true;
			Time.timeScale = 0f;
		}
	}

	public void ExitPause()
	{
		paused = false;
		wasJustPaused = true;
		Time.timeScale = 1f;
	}

	private void LostFocus()
	{
		SetFocus(focusStatus: false);
	}

	private void AcquiredFocus()
	{
		SetFocus(focusStatus: true);
	}

	private void OnApplicationPause(bool pauseStatus)
	{
		Debug.Log((!pauseStatus) ? "Application resumed" : "Application paused");
	}

	private void SetFocus(bool focusStatus)
	{
		Debug.Log((!focusStatus) ? "GC - Focus lost - Paused" : "GC - Focus acquired");
		if (!focusStatus)
		{
			AudioListener.volume = 0f;
		}
		else
		{
			Get().UpdateAudioVolume();
		}
	}

	public void ExitGame()
	{
		if (Application.loadedLevelName == "Intro")
		{
			Debug.Log("Closing Application");
			return;
		}
		Tutorial.Get().Save();
		Debug.Log("Loading Intro scene");
		Application.LoadLevel("Intro");
	}

	[Conditional("DH_DEBUG")]
	private void DebugUpdate()
	{
		if (Input.GetKeyDown(KeyCode.R) && (Input.GetKey(KeyCode.LeftControl) || Input.GetKey(KeyCode.RightControl)))
		{
			Loader.LoadLevel("Dungeon");
			return;
		}
		if (Input.GetKeyDown(KeyCode.F9))
		{
			Loader.LoadLevel("Dungeon");
			return;
		}
		if (Input.GetKeyDown(KeyCode.R))
		{
			GameObject gameObject = GameObject.FindWithTag(Tags.Minimap);
			if ((bool)gameObject)
			{
				gameObject.GetComponent<Minimap>().ResetMask(1f);
			}
		}
		if (Input.GetKeyDown(KeyCode.F1) || Input.GetButtonDown("Select"))
		{
		}
		if (Input.GetKeyDown(KeyCode.Q))
		{
			GameObject gameObject2 = GameObject.FindWithTag(Tags.PlayerTorch);
			gameObject2.GetComponent<TorchFuel>().AddFuel(50f);
		}
		if (Input.GetKeyDown(KeyCode.V))
		{
		}
		if (Input.GetKeyDown(KeyCode.T))
		{
			TiltPeek componentInChildren = Player.Get().GetComponentInChildren<TiltPeek>();
			if (componentInChildren != null)
			{
				componentInChildren.SetToStart();
				componentInChildren.enabled = !componentInChildren.enabled;
			}
		}
	}

	[Conditional("DH_DEBUG")]
	private void DebugTest()
	{
	}

	public void UpdateAudioVolume()
	{
		AudioListener.volume = Config.Audio().masterVolume * volumeMultiplier;
		if ((bool)Jukebox.Get())
		{
			Jukebox.Get().volume = Config.Audio().musicVolume;
		}
		GameObject gameObject = GameObject.Find("Music");
		if (gameObject != null)
		{
			MusicVolume component = gameObject.GetComponent<MusicVolume>();
			if ((bool)component)
			{
				component.UpdateVolume();
			}
		}
	}

	public void UpdateInput(bool forceUpdate = false)
	{
		InputExt.Get().lockedActiveController = Application.loadedLevelName != "Intro";
		if (InputExt.Using3DOFController)
		{
			wasRightHanded = InputExt.RightHanded;
		}
		GameObject gameObject = GameObject.FindGameObjectWithTag(Tags.Player);
		if (!(gameObject != null))
		{
			return;
		}
		gameObject.GetComponent<RatchetRotation>().IsActive = Config.Input().comfortRotation;
		if (InputExt.UsingHandControllers)
		{
			gameObject.GetComponent<PicoPlayerController>().moveReferenceObject = Player.GetLeftHandTransform();
		}
		PicoPlayerController component = Player.GetComponent<PicoPlayerController>();
		bool flag = component.moveReferenceObject != null;
		if (flag != Config.Input().tankMode)
		{
			Debug.Log("Tank Mode: " + ((!flag) ? "OFF" : "ON"));
			if (Config.Input().tankMode && InputExt.UsingHandControllers)
			{
				component.moveReferenceObject = Player.GetLeftHandTransform();
			}
			else
			{
				component.moveReferenceObject = null;
			}
		}
	}

	[Conditional("DH_DEBUG")]
	private void ToggleVR()
	{
	}

	public void EndLevel(bool win = false)
	{
		gameOverText = string.Empty;
		Win = win;
		Fader fader = ((!win) ? this.fader : faderWin);
		fader.FadeOut((!win) ? 4f : 1f, fadeAudio: true, base.gameObject);
	}

	public void ShowGameOver(string text)
	{
		gameOverText = text;
		Tutorial.Get().Save();
		fader.FadeOut(4f, fadeAudio: true, base.gameObject);
	}

	public void OnEndFade(Fader fader)
	{
		if (!(Application.loadedLevelName == "Intro"))
		{
			AudioListener.volume = Config.Audio().masterVolume * volumeMultiplier;
			if (levelOptions != null && levelOptions.isRandomMode)
			{
				Application.LoadLevel("BriefingRandomMap");
			}
			else if (gameOverText == string.Empty)
			{
				Application.LoadLevel("Intro");
			}
			else
			{
				GameOver.Display(gameOverText, (!levelOptions.isDemo) ? string.Empty : "Intro");
			}
		}
	}

	public void EnterHub(bool saveCheckpoint = false)
	{
		if (saveCheckpoint)
		{
			GameState.Get().checkPoint++;
			Get().SaveGame(overwriteMap: false);
			Tutorial.Get().Save();
		}
		fader.FadeOut(2f, fadeAudio: true, null, OnEndFadeEnterHub);
	}

	private void OnEndFadeEnterHub()
	{
		LevelOptions metaLevelOptions = LevelOptions.GetMetaLevelOptions(GameState.Get().metaMap);
		nextOptions = metaLevelOptions;
		Loader.LoadLevel("Dungeon");
	}

	public void SaveGame(bool overwriteMap = true, string gameName = "SavedGame_00")
	{
		serializer.SaveGame(gameName, overwriteMap);
	}

	public bool LoadGame(string gameName = "SavedGame_00")
	{
		return serializer.LoadGame(gameName);
	}

	public void NewGame(string gameName = "SavedGame_00", bool liteVersion = false)
	{
		GameState.Get().Reset();
		GameState.Get().liteVersion = liteVersion;
		serializer = new Serializer();
		serializer.SaveGame(gameName, overwriteMap: false, refreshData: false);
		Tutorial.ResetAndSave();
		serializer.LoadGame(gameName);
	}

	public bool CheckGame(string gameName = "SavedGame_00")
	{
		return GameState.Check(gameName);
	}

	public void StartDemo()
	{
		GameState.Get().Reset();
		serializer = new Serializer();
		serializer.SaveGame("SavedGame_00", overwriteMap: false, refreshData: false);
		Tutorial.ResetAndSave();
		fader.FadeOut(4f, fadeAudio: true, null, StartDemo_OnEndFade);
	}

	private void StartDemo_OnEndFade()
	{
		LevelOptions byName = LevelOptions.GetByName("demo");
		nextOptions = byName;
		Loader.LoadLevel("Dungeon");
	}

	public void StartRandomMap()
	{
		Fader component = GameObject.Find("Fader").GetComponent<Fader>();
		component.FadeOut(4f, fadeAudio: true, null, StartRandomMap_OnEndFade);
	}

	private void StartRandomMap_OnEndFade()
	{
		GameState.Get().SetRandomMode();
		LevelOptions randomFromFolder = LevelOptionsList.GetRandomFromFolder("random");
		randomFromFolder.isRandomMode = true;
		nextOptions = randomFromFolder;
		Loader.LoadLevel("Dungeon");
	}

	public static bool GetBackButtonDown()
	{
		return InputExt.BackButtonDown;
	}

	public static void SetLanguage(string langIndex, bool saveConfig = true)
	{
		if (!Translate.SetLanguage(langIndex))
		{
			return;
		}
		if (saveConfig)
		{
			Config.General().language = Translate.GetLanguage();
			Config.Save();
		}
		if (Application.loadedLevelName == "Dungeon")
		{
			UIText[] componentsInChildren = Player.Get().GetComponentsInChildren<UIText>(includeInactive: true);
			UIText[] array = componentsInChildren;
			foreach (UIText uIText in array)
			{
				uIText.RefreshText();
			}
			UIButton3D[] componentsInChildren2 = Player.Get().GetComponentsInChildren<UIButton3D>(includeInactive: true);
			UIButton3D[] array2 = componentsInChildren2;
			foreach (UIButton3D uIButton3D in array2)
			{
				uIButton3D.RefreshText();
			}
			LocalizedTexture[] componentsInChildren3 = Player.Get().GetComponentsInChildren<LocalizedTexture>(includeInactive: true);
			LocalizedTexture[] array3 = componentsInChildren3;
			foreach (LocalizedTexture localizedTexture in array3)
			{
				localizedTexture.RefreshTextures();
			}
		}
		else
		{
			if (!(Application.loadedLevelName == "Intro"))
			{
				return;
			}
			GameObject[] array4 = new GameObject[2]
			{
				GameObject.Find("UI"),
				GameObject.Find("OptionsContainer")
			};
			foreach (GameObject gameObject in array4)
			{
				UIText[] componentsInChildren4 = gameObject.GetComponentsInChildren<UIText>(includeInactive: true);
				UIText[] array5 = componentsInChildren4;
				foreach (UIText uIText2 in array5)
				{
					uIText2.RefreshText();
				}
				UIButton3D[] componentsInChildren5 = gameObject.GetComponentsInChildren<UIButton3D>(includeInactive: true);
				UIButton3D[] array6 = componentsInChildren5;
				foreach (UIButton3D uIButton3D2 in array6)
				{
					uIButton3D2.RefreshText();
				}
				LocalizedTexture[] componentsInChildren6 = gameObject.GetComponentsInChildren<LocalizedTexture>(includeInactive: true);
				LocalizedTexture[] array7 = componentsInChildren6;
				foreach (LocalizedTexture localizedTexture2 in array7)
				{
					localizedTexture2.RefreshTextures();
				}
			}
		}
	}

	[Conditional("CHECK_ENTITLEMENT")]
	private void CheckEntitlement()
	{
		if (!checkedEntitlement)
		{
		}
	}

	[Conditional("DH_DEBUG")]
	public void DebugText(string text, Vector3 vPos, Vector3 vForwards, float time = 0f)
	{
		TextMesh textMesh = UnityEngine.Object.Instantiate(debugText, vPos, Quaternion.LookRotation(vForwards));
		textMesh.text = text;
		if (time > 0f)
		{
			UnityEngine.Object.Destroy(textMesh.gameObject, time);
		}
	}
}
public class GameOver : MonoBehaviour
{
	public static string displayTextCode = "GAMEOVER_DEFAULT";

	public static string nextLevel = "Intro";

	public TextLabel textLabel;

	private bool fading;

	public static void Display(string textCode, string level, string gameOverLevel = "GameOver")
	{
		displayTextCode = textCode;
		nextLevel = level;
		Application.LoadLevel(gameOverLevel);
	}

	private void Start()
	{
		string text = Translate.GetForInput(displayTextCode) + "\n\n" + Translate.GetForInput("GAMEOVER_CONTINUE");
		textLabel.Text = text;
		textLabel.FadeIn();
	}

	private void Update()
	{
		if (!fading && (InputExt.GetButtonDown(InputExt.Button.Action) || InputExt.GetButtonDown(InputExt.Button.UIAction)))
		{
			fading = true;
			textLabel.FadeOut();
			if (nextLevel != null && nextLevel != string.Empty)
			{
				Fader component = GameObject.Find("Fader").GetComponent<Fader>();
				component.FadeOut(2f, fadeAudio: true, null, LoadNextLevel_OnEndFade);
			}
			else
			{
				GameController.Get().LoadGame();
			}
		}
	}

	private void LoadNextLevel_OnEndFade()
	{
		Loader.LoadLevel(nextLevel);
	}
}
[Serializable]
public class GameState
{
	private static GameState instance;

	public string versionCode;

	public bool liteVersion;

	public int metaMap;

	public int checkPoint;

	public int[] inventory;

	public float fuel;

	public int lampDescriptions;

	public List<string> oracleTags;

	public int oracleNumAsked;

	public List<string> playerNotes;

	public int lockpicsUsedSuccesfully;

	public float[] minimap;

	public List<string> objectsIds;

	public List<string> objectsData;

	public List<string> removedObjs;

	public GameState()
	{
		Reset();
	}

	public static GameState Get()
	{
		if (instance == null)
		{
			instance = new GameState();
		}
		return instance;
	}

	public void Reset()
	{
		versionCode = GlobalParams.savegameVersion;
		liteVersion = false;
		metaMap = 1;
		checkPoint = 0;
		inventory = new int[Enum.GetNames(typeof(Collectable.EItemType)).Length];
		for (int i = 0; i < inventory.Length; i++)
		{
			inventory[i] = 0;
		}
		fuel = 0.75f;
		lampDescriptions = 3;
		oracleTags = new List<string>();
		oracleNumAsked = 0;
		playerNotes = new List<string>();
		lockpicsUsedSuccesfully = 0;
		minimap = null;
		objectsIds = new List<string>();
		objectsData = new List<string>();
		removedObjs = new List<string>();
	}

	public void SetRandomMode()
	{
		Reset();
		fuel = 0.6f;
		lampDescriptions = 0;
		lockpicsUsedSuccesfully = 5;
	}

	public void SetCheckpoint(int metaMap, int checkPoint)
	{
		this.metaMap = metaMap;
		this.checkPoint = checkPoint;
	}

	public void Refresh(bool overwriteMap = true)
	{
		Inventory component = GameObject.FindWithTag(Tags.Inventory).GetComponent<Inventory>();
		SetInventory(component);
		TorchFuel component2 = GameObject.FindWithTag(Tags.PlayerTorch).GetComponent<TorchFuel>();
		fuel = component2.Fuel;
		if (overwriteMap)
		{
			Minimap component3 = GameObject.FindWithTag(Tags.Minimap).GetComponent<Minimap>();
			component3.Serialize(this);
		}
	}

	public void SetInventory(Inventory inv)
	{
		inventory = CopyInventory(inv.NumItems, inventory);
	}

	public void GetInventory(Inventory inv)
	{
		inv.NumItems = CopyInventory(inventory, inv.NumItems);
	}

	private static int[] CopyInventory(int[] source, int[] dest)
	{
		if (dest.Length != source.Length)
		{
			dest = new int[source.Length];
		}
		for (int i = 0; i < source.Length; i++)
		{
			dest[i] = source[i];
		}
		return dest;
	}

	public static bool Load(string gameName = "SavedGame_00")
	{
		GameState defaultValue = new GameState();
		defaultValue = Serializer.DeserializeObject(gameName, defaultValue);
		if (defaultValue.versionCode == GlobalParams.savegameVersion)
		{
			instance = defaultValue;
			return true;
		}
		return false;
	}

	public static void Save(string gameName = "SavedGame_00")
	{
		Serializer.SerializeObject(instance, gameName);
		PlayerPrefs.SetString(gameName + "_version", GlobalParams.savegameVersion);
	}

	public static bool Check(string gameName = "SavedGame_00")
	{
		if (PlayerPrefs.HasKey(gameName))
		{
			string key = gameName + "_version";
			if (PlayerPrefs.HasKey(key))
			{
				return GlobalParams.savegameVersion == PlayerPrefs.GetString(key);
			}
		}
		return false;
	}

	public static void Delete(string gameName = "SavedGame_00")
	{
		PlayerPrefs.DeleteKey(gameName);
		PlayerPrefs.DeleteKey(gameName + "_version");
	}
}
public class GlobalParams : MonoBehaviour
{
	[Serializable]
	public class LightParams
	{
		public float fuelDuration = 180f;

		public float fuelConsumption = 0.05f;
	}

	private static GlobalParams instance;

	public LightParams lightParams;

	public static string savegameVersion = "DHGS_0_14";

	public static string tutorialStateVersion = "DHTS_0_4";

	public static float touchControllersDistanceFactor = 0.8f;

	private void Awake()
	{
		instance = this;
	}

	public static GlobalParams Get()
	{
		return instance;
	}
}
public class InputExt : TimeIndependentBehaviour
{
	public class TouchpadStatus
	{
		public enum TouchPosition
		{
			UP,
			DOWN,
			NONE
		}

		public enum SwipeDir
		{
			LEFT,
			RIGHT
		}

		public bool isTouching;

		public TouchPosition touchPos;

		public bool isSwiping;

		public SwipeDir swipeDir;

		public Vector2 touchDelta;

		public Vector2 v2touch;

		public bool Click;

		public bool ClickDown;

		public bool ClickUp;

		public bool DoubleClick;

		public bool ClickBottom;

		public bool ClickBottomDown;

		public bool ClickBottomUp;

		private float lastClickTime;

		private float catchTime = 0.25f;

		private Vector2 lastTouchVector = Vector2.zero;

		public void Update(int controller)
		{
			Vector2 vector = Controller.UPvr_GetAxis2D(controller);
			if (Controller.UPvr_GetKeyDown(controller, Pvr_KeyCode.TOUCHPAD))
			{
				v2touch = vector;
				isSwiping = false;
			}
			if (Controller.UPvr_GetKey(controller, Pvr_KeyCode.TOUCHPAD))
			{
				isTouching = true;
				lastTouchVector = vector;
				if (vector.y > 0.5f)
				{
					touchPos = TouchPosition.UP;
				}
				else
				{
					touchPos = TouchPosition.DOWN;
				}
			}
			else
			{
				isTouching = false;
				touchPos = TouchPosition.NONE;
				touchDelta = v2touch - lastTouchVector;
				bool flag = Mathf.Abs(touchDelta.x) > 0.6f;
				if (touchDelta.x > 0f && flag)
				{
					swipeDir = SwipeDir.RIGHT;
					isSwiping = true;
				}
				else if (touchDelta.y > 127f && flag)
				{
					swipeDir = SwipeDir.LEFT;
					isSwiping = true;
				}
				v2touch = lastTouchVector;
			}
			if (Controller.UPvr_GetKey(controller, Pvr_KeyCode.TOUCHPAD) && touchPos == TouchPosition.DOWN)
			{
				if (Controller.UPvr_GetKeyDown(controller, Pvr_KeyCode.TOUCHPAD))
				{
					ClickBottomDown = true;
				}
				else
				{
					ClickBottomDown = false;
				}
				if (Controller.UPvr_GetKey(controller, Pvr_KeyCode.TOUCHPAD))
				{
					ClickBottom = true;
				}
				else
				{
					ClickBottom = false;
				}
			}
			if (Controller.UPvr_GetKeyDown(controller, Pvr_KeyCode.TOUCHPAD))
			{
				ClickDown = true;
				if (Time.time - lastClickTime < catchTime)
				{
					DoubleClick = true;
				}
				else
				{
					DoubleClick = false;
				}
				lastClickTime = Time.time;
			}
			else
			{
				ClickDown = false;
			}
			if (Controller.UPvr_GetKey(controller, Pvr_KeyCode.TOUCHPAD))
			{
				Click = true;
			}
			else
			{
				Click = false;
			}
			if (Controller.UPvr_GetKeyUp(controller, Pvr_KeyCode.TOUCHPAD))
			{
				ClickUp = true;
				DoubleClick = false;
				if (touchPos == TouchPosition.DOWN)
				{
					ClickBottomUp = true;
				}
			}
			else
			{
				ClickUp = false;
				ClickBottomUp = false;
			}
		}
	}

	public enum Button
	{
		Action,
		Inventory,
		Cancel,
		Light,
		Start,
		Select,
		Lockpick,
		HideMap,
		Submit,
		ResetTracking,
		UIAction,
		Back
	}

	public enum Axis2D
	{
		LeftThumbstick,
		RightThumbstick,
		Dpad
	}

	public enum Axis1D
	{
		LeftTrigger,
		RightTrigger
	}

	private static InputExt instance = null;

	public static bool _HasGamepad = false;

	private float gamepadCheckTime;

	public bool justLostGamepad;

	private static bool _Has3DOFController = false;

	private static bool _isOculusGo;

	public static bool _HasHandControllers = false;

	public static int controllerHandLeftIndex = 0;

	public static int controllerHandRightIndex = 1;

	private static bool _HandControllerLeftHanded = false;

	public static bool BackButtonDown = false;

	private static bool activeControllerIs3DOF = false;

	private static bool activeControllerIsHand = false;

	public bool lockedActiveController;

	public static TouchpadStatus touchpadStatus = new TouchpadStatus();

	public static bool HasGamepad
	{
		get
		{
			instance.CheckControllers();
			return _HasGamepad;
		}
	}

	public static bool UsingGamepad
	{
		get
		{
			instance.CheckControllers();
			return _HasGamepad && !activeControllerIs3DOF;
		}
	}

	public static bool Has3DOFController
	{
		get
		{
			instance.CheckControllers();
			return _Has3DOFController;
		}
	}

	public static bool Using3DOFController
	{
		get
		{
			Get().CheckControllers();
			return _Has3DOFController && activeControllerIs3DOF;
		}
	}

	public static bool LeftHanded => _HandControllerLeftHanded;

	public static bool RightHanded => !_HandControllerLeftHanded;

	public static bool IsOculusGo => _isOculusGo;

	public static bool HasHandControllers
	{
		get
		{
			instance.CheckControllers();
			return _HasHandControllers;
		}
	}

	public static bool UsingHandControllers
	{
		get
		{
			Get().CheckControllers();
			return _HasHandControllers && activeControllerIsHand;
		}
	}

	public static InputExt Get()
	{
		if (instance == null)
		{
			GameObject gameObject = new GameObject("_InputExt(dynamic)");
			instance = gameObject.AddComponent<InputExt>();
		}
		return instance;
	}

	private new void Awake()
	{
		if (instance != null && instance != this)
		{
			UnityEngine.Object.Destroy(instance);
		}
		instance = this;
		int num = 0;
		string[] joystickNames = Input.GetJoystickNames();
		for (int i = 0; i < joystickNames.Length; i++)
		{
			Debug.Log(joystickNames[i]);
			num += ((joystickNames[i].Length > 0) ? 1 : 0);
		}
	}

	private new void OnEnable()
	{
		CheckControllers();
	}

	public static void ResetLeftHanded()
	{
		_HandControllerLeftHanded = Config.Input().leftHanded;
	}

	private void CheckControllers()
	{
		if (Time.realtimeSinceStartup - instance.gamepadCheckTime >= 2.5f)
		{
			instance.gamepadCheckTime = Time.realtimeSinceStartup;
			activeControllerIsHand = true;
			activeControllerIs3DOF = false;
			_HasHandControllers = true;
			_Has3DOFController = false;
			_HasGamepad = false;
		}
	}

	private new void Update()
	{
		base.Update();
		CheckControllers();
		if (justLostGamepad)
		{
			justLostGamepad = false;
		}
		BackButtonDown = false;
		if (Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.APP) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.APP))
		{
			BackButtonDown |= true;
		}
	}

	public static bool GetButton(Button btn)
	{
		bool flag = false;
		return GetHandControllersBtn(btn);
	}

	public static bool GetButtonDown(Button btn)
	{
		bool flag = false;
		return GetHandControllersBtnDown(btn);
	}

	public static bool GetButtonUp(Button btn)
	{
		bool flag = false;
		return GetHandControllersBtnUp(btn);
	}

	private static bool GetHandControllersBtn(Button btn)
	{
		if (!LeftHanded)
		{
			return btn switch
			{
				Button.Action => Controller.UPvr_GetKey(1, Pvr_KeyCode.TRIGGER) || Input.GetMouseButton(1), 
				Button.UIAction => Controller.UPvr_GetKey(1, Pvr_KeyCode.TRIGGER) || Input.GetMouseButton(1), 
				Button.Light => Controller.UPvr_GetKey(0, Pvr_KeyCode.TRIGGER) || Input.GetMouseButton(0), 
				Button.Inventory => Controller.UPvr_GetKey(0, Pvr_KeyCode.X), 
				Button.Cancel => (Controller.UPvr_GetKey(0, Pvr_KeyCode.APP) | Controller.UPvr_GetKey(1, Pvr_KeyCode.APP)) || Controller.UPvr_GetKey(0, Pvr_KeyCode.Y), 
				Button.Submit => Controller.UPvr_GetKey(1, Pvr_KeyCode.A), 
				Button.HideMap => Controller.UPvr_GetKey(1, Pvr_KeyCode.A), 
				Button.Start => Controller.UPvr_GetKey(1, Pvr_KeyCode.HOME), 
				_ => false, 
			};
		}
		return btn switch
		{
			Button.Action => Controller.UPvr_GetKey(0, Pvr_KeyCode.TRIGGER) || Input.GetMouseButton(0), 
			Button.UIAction => Controller.UPvr_GetKey(0, Pvr_KeyCode.TRIGGER) || Input.GetMouseButton(0), 
			Button.Light => Controller.UPvr_GetKey(1, Pvr_KeyCode.TRIGGER) || Input.GetMouseButton(1), 
			Button.Inventory => Controller.UPvr_GetKey(1, Pvr_KeyCode.A), 
			Button.Cancel => (Controller.UPvr_GetKey(0, Pvr_KeyCode.APP) | Controller.UPvr_GetKey(1, Pvr_KeyCode.APP)) || Controller.UPvr_GetKey(1, Pvr_KeyCode.B), 
			Button.Submit => Controller.UPvr_GetKey(0, Pvr_KeyCode.X), 
			Button.HideMap => Controller.UPvr_GetKey(0, Pvr_KeyCode.X), 
			Button.Start => Controller.UPvr_GetKey(0, Pvr_KeyCode.HOME), 
			_ => false, 
		};
	}

	private static bool GetHandControllersBtnDown(Button btn)
	{
		if (!LeftHanded)
		{
			return btn switch
			{
				Button.Action => Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TRIGGER) || Input.GetMouseButtonDown(1), 
				Button.UIAction => Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TRIGGER) || Input.GetMouseButtonDown(1), 
				Button.Light => Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.TRIGGER) || Input.GetMouseButtonDown(0), 
				Button.Inventory => Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.X), 
				Button.Cancel => (Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.APP) | Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.APP)) || Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.Y), 
				Button.Submit => Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.A), 
				Button.HideMap => Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.A), 
				Button.Start => Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.HOME), 
				_ => false, 
			};
		}
		return btn switch
		{
			Button.Action => Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.TRIGGER) || Input.GetMouseButtonDown(0), 
			Button.UIAction => Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.TRIGGER) || Input.GetMouseButtonDown(0), 
			Button.Light => Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TRIGGER) || Input.GetMouseButtonDown(1), 
			Button.Inventory => Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.A), 
			Button.Cancel => (Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.APP) | Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.APP)) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.B), 
			Button.Submit => Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.X), 
			Button.HideMap => Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.X), 
			Button.Start => Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.HOME), 
			_ => false, 
		};
	}

	private static bool GetHandControllersBtnUp(Button btn)
	{
		if (!LeftHanded)
		{
			return btn switch
			{
				Button.Action => Controller.UPvr_GetKeyUp(1, Pvr_KeyCode.TRIGGER) || Input.GetMouseButtonUp(1), 
				Button.UIAction => Controller.UPvr_GetKeyUp(1, Pvr_KeyCode.TRIGGER) || Input.GetMouseButtonUp(1), 
				Button.Light => Controller.UPvr_GetKeyUp(0, Pvr_KeyCode.TRIGGER) || Input.GetMouseButtonUp(0), 
				Button.Inventory => Controller.UPvr_GetKeyUp(0, Pvr_KeyCode.X), 
				Button.Cancel => (Controller.UPvr_GetKeyUp(0, Pvr_KeyCode.APP) | Controller.UPvr_GetKeyUp(1, Pvr_KeyCode.APP)) || Controller.UPvr_GetKeyUp(0, Pvr_KeyCode.Y), 
				Button.Submit => Controller.UPvr_GetKeyUp(1, Pvr_KeyCode.A), 
				Button.HideMap => Controller.UPvr_GetKeyUp(1, Pvr_KeyCode.A), 
				Button.Start => Controller.UPvr_GetKeyUp(1, Pvr_KeyCode.HOME), 
				_ => false, 
			};
		}
		return btn switch
		{
			Button.Action => Controller.UPvr_GetKeyUp(0, Pvr_KeyCode.TRIGGER) || Input.GetMouseButtonUp(0), 
			Button.UIAction => Controller.UPvr_GetKeyUp(0, Pvr_KeyCode.TRIGGER) || Input.GetMouseButtonUp(0), 
			Button.Light => Controller.UPvr_GetKeyUp(1, Pvr_KeyCode.TRIGGER) || Input.GetMouseButtonUp(1), 
			Button.Inventory => Controller.UPvr_GetKeyUp(1, Pvr_KeyCode.A), 
			Button.Cancel => (Controller.UPvr_GetKeyUp(0, Pvr_KeyCode.APP) | Controller.UPvr_GetKeyUp(1, Pvr_KeyCode.APP)) || Controller.UPvr_GetKeyUp(1, Pvr_KeyCode.B), 
			Button.Submit => Controller.UPvr_GetKeyUp(0, Pvr_KeyCode.X), 
			Button.HideMap => Controller.UPvr_GetKeyUp(0, Pvr_KeyCode.X), 
			Button.Start => Controller.UPvr_GetKeyUp(0, Pvr_KeyCode.HOME), 
			_ => false, 
		};
	}

	private static string GetUnityBtn(Button btn)
	{
		switch (btn)
		{
		case Button.Action:
		case Button.UIAction:
			return "Fire1";
		case Button.Inventory:
			return "Inventory";
		case Button.Cancel:
			return "Cancel";
		case Button.Light:
			return "Light";
		case Button.Start:
			return "Start";
		case Button.Select:
			return "Select";
		case Button.Lockpick:
			return "Lockpick";
		case Button.HideMap:
			return "HideMap";
		case Button.Submit:
			return "Submit";
		case Button.ResetTracking:
			return "ResetTracking";
		default:
			return string.Empty;
		}
	}

	public static bool GetRunButton()
	{
		if (UsingHandControllers)
		{
			return Controller.UPvr_GetKey(1, Pvr_KeyCode.Right) || Controller.UPvr_GetKey(0, Pvr_KeyCode.Left);
		}
		if (Using3DOFController)
		{
			return touchpadStatus.DoubleClick;
		}
		return Input.GetButton("Run") || Input.GetButton("Run_key") || Controller.UPvr_GetKey(1, Pvr_KeyCode.Right);
	}

	public static Vector2 GetAxisPad(Axis2D axis)
	{
		if (!UsingGamepad && !UsingHandControllers)
		{
			return Vector2.zero;
		}
		return axis switch
		{
			Axis2D.Dpad => Vector2.zero, 
			Axis2D.LeftThumbstick => Controller.UPvr_GetAxis2D(0), 
			_ => Controller.UPvr_GetAxis2D(1), 
		};
	}

	public static float GetAxisPad(Axis1D axis)
	{
		if (!UsingGamepad && !UsingHandControllers)
		{
			return 0f;
		}
		float result = 0f;
		switch (axis)
		{
		case Axis1D.LeftTrigger:
			result = Mathf.Clamp01((float)Controller.UPvr_GetControllerTriggerValue(0) * 0.003921569f);
			break;
		case Axis1D.RightTrigger:
			result = Mathf.Clamp01((float)Controller.UPvr_GetControllerTriggerValue(1) * 0.003921569f);
			break;
		}
		return result;
	}

	public static Vector2 GetAxisPadRatchet(Axis2D axis)
	{
		if (!UsingGamepad && !UsingHandControllers)
		{
			return Vector2.zero;
		}
		Vector2 result = Vector2.zero;
		switch (axis)
		{
		case Axis2D.LeftThumbstick:
			result = ((!(Controller.UPvr_GetAxis2D(0) == Vector2.zero)) ? Controller.UPvr_GetAxis2D(0) : Vector2.zero);
			break;
		case Axis2D.RightThumbstick:
			result = ((!(Controller.UPvr_GetAxis2D(1) == Vector2.zero)) ? Controller.UPvr_GetAxis2D(1) : Vector2.zero);
			break;
		}
		return result;
	}
}
public class IntroMenuController : FSMComponent<IntroMenuController.States>
{
	public enum States
	{
		Logo,
		Menu,
		ConfirmOverwrite,
		Disclaimer,
		Credits,
		Controls,
		Fading,
		Options,
		ConfirmRandomMode,
		ControllerCheck
	}

	public Renderer logoRenderer;

	public Renderer controlsKeyboard;

	public Renderer controlsPad;

	public Renderer controlsOculusGoPad;

	public Renderer controlsGearVR3DOF;

	public Renderer controlsOculusGo3DOF;

	public Renderer controlsTouchRight;

	public Renderer controlsTouchLeft;

	public Renderer controlsNeo2Right;

	public Renderer controlsNeo2Left;

	public Renderer controlsNeo3Right;

	public Renderer controlsNeo3Left;

	public Renderer continueKeyboard;

	public Renderer continuePad;

	public Renderer continueGearVR3DOF;

	public Renderer continueOculusgo3DOF;

	public Renderer continueTouch;

	public UIDreadHallsMenu mainMenu;

	private UIMenuAnimator mainMenuAnimator;

	public UIDreadHallsMenu dialogMenu;

	private UIMenuAnimator dialogMenuAnimator;

	public UIDreadHallsMenu disclaimerMenu;

	private UIMenuAnimator disclaimerMenuAnimator;

	public UIDreadHallsMenu creditsMenu;

	private UIMenuAnimator creditsMenuAnimator;

	public UIDreadHallsMenu optionsMenu;

	private UIMenuAnimator optionsMenuAnimator;

	public UIDreadHallsMenu noControllerMenu;

	private UIMenuAnimator noControllerMenuAnimator;

	public UICrosshair3D crosshairFar;

	public UICrosshair3D crosshairNear;

	private Fader fader;

	public float FadeInSpeed = 0.6f;

	public float FadeOutSpeed = 0.6f;

	private bool menuActive;

	private bool dialogActive;

	private bool disclaimerActive;

	private float disclaimerTimeout;

	private float creditsTimeout;

	private int creditsIndex;

	private bool fast;

	private bool canContinue;

	private bool hasSaveGame;

	private bool enterDemo;

	private bool enterLite;

	private bool randomMapMode;

	private const float creditsShowTime = 6f;

	private void Start()
	{
		fader = GameObject.Find("Fader").GetComponent<Fader>();
		mainMenuAnimator = mainMenu.GetComponent<UIMenuAnimator>();
		mainMenuAnimator.ApplyAlpha(0f);
		dialogMenuAnimator = dialogMenu.GetComponent<UIMenuAnimator>();
		dialogMenuAnimator.ApplyAlpha(0f);
		disclaimerMenuAnimator = disclaimerMenu.GetComponent<UIMenuAnimator>();
		disclaimerMenuAnimator.ApplyAlpha(0f);
		creditsMenuAnimator = creditsMenu.GetComponent<UIMenuAnimator>();
		creditsMenuAnimator.ApplyAlpha(0f);
		optionsMenuAnimator = optionsMenu.GetComponent<UIMenuAnimator>();
		optionsMenuAnimator.ApplyAlpha(0f);
		noControllerMenuAnimator = noControllerMenu.GetComponent<UIMenuAnimator>();
		noControllerMenuAnimator.ApplyAlpha(0f);
		hasSaveGame = GameController.Get().CheckGame();
		UIButton3D button = GetButton("button_continue");
		if (!hasSaveGame && button != null)
		{
			button.gameObject.SetActive(value: false);
		}
		else if (button != null)
		{
			button.SetAction(OnButton_Continue);
		}
		UIButton3D button2 = GetButton("button_new");
		if (button2 != null)
		{
			button2.SetAction(OnButton_New);
		}
		UIButton3D button3 = GetButton("button_exit");
		if (button3 != null)
		{
			button3.SetAction(OnButton_Exit);
		}
		UIButton3D button4 = GetButton("button_demo");
		if (button4 != null)
		{
			button4.SetAction(OnButton_Demo);
		}
		UIButton3D button5 = GetButton("button_lite");
		if (button5 != null)
		{
			button5.SetAction(OnButton_Lite);
		}
		UIButton3D button6 = GetButton("button_random");
		if (button6 != null)
		{
			button6.SetAction(OnButton_RandomMap);
		}
		UIButton3D button7 = GetButton("button_options");
		if (button7 != null)
		{
			button7.SetAction(OnButton_Options);
		}
		UIButton3D button8 = GetButton("button_credits");
		if (button8 != null)
		{
			button8.SetAction(OnButton_Credits);
		}
		Init(States.Logo);
	}

	private void Logo_Enter()
	{
		fast = false;
		mainMenu.gameObject.SetActive(value: false);
		dialogMenuAnimator.gameObject.SetActive(value: false);
		disclaimerMenuAnimator.gameObject.SetActive(value: false);
		creditsMenuAnimator.gameObject.SetActive(value: false);
		optionsMenuAnimator.gameObject.SetActive(value: false);
		noControllerMenuAnimator.gameObject.SetActive(value: false);
		crosshairFar.gameObject.SetActive(value: false);
		crosshairNear.gameObject.SetActive(value: false);
		StartCoroutine(Logo_co());
	}

	private IEnumerator Logo_co()
	{
		if (!fast)
		{
			yield return new WaitForSeconds(3f);
		}
		yield return StartCoroutine(FadeIn(logoRenderer));
		if (!fast)
		{
			yield return new WaitForSeconds(3f);
		}
		yield return StartCoroutine(FadeOut(logoRenderer));
		base.State = States.ControllerCheck;
	}

	private void Logo_Update()
	{
		if (InputExt.GetButtonDown(InputExt.Button.Action) || InputExt.GetButtonDown(InputExt.Button.UIAction))
		{
			fast = true;
		}
	}

	private void Logo_Exit()
	{
		fast = false;
	}

	private void Menu_Enter()
	{
		mainMenu.gameObject.SetActive(value: true);
		mainMenu.Visible = true;
		mainMenu.SetCollidersEnabled(enabled: true);
		mainMenuAnimator.FadeIn();
		menuActive = true;
		crosshairFar.gameObject.SetActive(value: true);
	}

	private void Menu_Exit()
	{
		mainMenuAnimator.FadeOut(reset: false, OnEndMenuFade);
		mainMenu.SetCollidersEnabled(enabled: false);
	}

	private void OnEndMenuFade()
	{
		mainMenu.gameObject.SetActive(value: false);
	}

	private void OnButton_Continue()
	{
		if (menuActive)
		{
			Debug.Log("OnButton_Continue");
			GameController.Get().LoadGame();
			menuActive = false;
		}
	}

	private void OnButton_New()
	{
		if (menuActive)
		{
			Debug.Log("OnButton_New");
			if (hasSaveGame)
			{
				base.State = States.ConfirmOverwrite;
			}
			else
			{
				base.State = States.Disclaimer;
			}
			menuActive = false;
		}
	}

	private void OnButton_Exit()
	{
		if (menuActive)
		{
			Debug.Log("OnButton_Exit");
			Application.Quit();
		}
	}

	private void OnButton_Demo()
	{
		if (menuActive)
		{
			Debug.Log("OnButton_Demo");
			menuActive = false;
			base.State = States.Disclaimer;
			enterDemo = true;
		}
	}

	private void OnButton_Lite()
	{
		if (menuActive)
		{
			Debug.Log("OnButton_Lite");
			menuActive = false;
			base.State = States.Disclaimer;
			enterDemo = false;
			enterLite = true;
		}
	}

	private void OnButton_Options()
	{
		if (menuActive)
		{
			Debug.Log("OnButton_Options");
			menuActive = false;
			base.State = States.Options;
		}
	}

	private void OnButton_RandomMap()
	{
		if (menuActive)
		{
			Debug.Log("OnButton_RandomMap");
			menuActive = false;
			if (!Config.General().randomModeUnlocked)
			{
				base.State = States.ConfirmRandomMode;
				return;
			}
			randomMapMode = true;
			base.State = States.Controls;
		}
	}

	private void OnButton_Credits()
	{
		if (menuActive)
		{
			Debug.Log("OnButton_Credits");
			menuActive = false;
			if (!Config.General().endingCredits)
			{
				base.State = States.Credits;
				return;
			}
			Fader component = GameObject.Find("Fader").GetComponent<Fader>();
			component.SetColor(Color.white);
			component.FadeOut(2f, fadeAudio: true, null, OnEndFade_EndingCredits);
		}
	}

	public void OnEndFade_EndingCredits()
	{
		Loader.nextScene = "Ending";
		Application.LoadLevel("LoadingEnd");
	}

	private void ConfirmOverwrite_Enter()
	{
		dialogMenu.gameObject.SetActive(value: true);
		dialogMenu.Visible = true;
		dialogMenu.SetCollidersEnabled(enabled: true);
		dialogMenuAnimator.FadeIn();
		dialogActive = true;
		dialogMenu.SetDialog(Translate.Get("MENU_INTRO_OVERWRITE"), Translate.Get("MENU_YES"), Translate.Get("MENU_NO"), OnConfirmOverwrite_Yes, OnConfirmOverwrite_No);
		crosshairFar.gameObject.SetActive(value: true);
	}

	private void ConfirmOverwrite_Exit()
	{
		dialogMenuAnimator.FadeOut(reset: false, OnEndDialogFade);
		dialogMenu.SetCollidersEnabled(enabled: false);
	}

	private void OnEndDialogFade()
	{
		dialogMenu.gameObject.SetActive(value: false);
	}

	private void OnConfirmOverwrite_Yes()
	{
		if (dialogActive)
		{
			base.State = States.Disclaimer;
			dialogActive = false;
		}
	}

	private void OnConfirmOverwrite_No()
	{
		if (dialogActive)
		{
			base.State = States.Menu;
			dialogActive = false;
		}
	}

	private void ConfirmRandomMode_Enter()
	{
		dialogMenu.gameObject.SetActive(value: true);
		dialogMenu.Visible = true;
		dialogMenu.SetCollidersEnabled(enabled: true);
		dialogMenuAnimator.FadeIn();
		dialogActive = true;
		dialogMenu.SetDialog(Translate.Get("MENU_INTRO_RANDOM_SPOILERS"), Translate.Get("MENU_INTRO_RANDOM_YES"), Translate.Get("MENU_INTRO_RANDOM_NO"), OnConfirmRandomMode_Yes, OnConfirmRandomMode_No);
		crosshairFar.gameObject.SetActive(value: true);
	}

	private void ConfirmRandomMode_Exit()
	{
		dialogMenuAnimator.FadeOut(reset: false, OnEndDialogFade);
		dialogMenu.SetCollidersEnabled(enabled: false);
	}

	private void OnConfirmRandomMode_Yes()
	{
		if (dialogActive)
		{
			Config.General().randomModeUnlocked = true;
			Config.Save();
			randomMapMode = true;
			base.State = States.Disclaimer;
			dialogActive = false;
		}
	}

	private void OnConfirmRandomMode_No()
	{
		if (dialogActive)
		{
			base.State = States.Menu;
			dialogActive = false;
		}
	}

	private void Disclaimer_Enter()
	{
		disclaimerMenu.gameObject.SetActive(value: true);
		disclaimerMenu.Visible = true;
		disclaimerMenu.SetCollidersEnabled(enabled: true);
		disclaimerMenuAnimator.FadeIn();
		disclaimerActive = true;
		disclaimerMenu.SetText("main_text", Translate.Get("MENU_INTRO_DISCLAIMER"));
		disclaimerTimeout = 8f;
		crosshairFar.gameObject.SetActive(value: false);
	}

	private void Disclaimer_Exit()
	{
		disclaimerMenuAnimator.FadeOut(reset: false, OnEndDisclaimerFade);
		disclaimerMenu.SetCollidersEnabled(enabled: false);
		canContinue = false;
	}

	private void Disclaimer_Update()
	{
		disclaimerTimeout -= Time.deltaTime;
		if (disclaimerTimeout <= 0f || (canContinue && (InputExt.GetButtonDown(InputExt.Button.Action) || InputExt.GetButtonDown(InputExt.Button.UIAction))))
		{
			base.State = States.Controls;
		}
		if (!canContinue && disclaimerTimeout <= 6f)
		{
			canContinue = true;
		}
	}

	private void OnEndDisclaimerFade()
	{
		disclaimerMenu.gameObject.SetActive(value: false);
	}

	private void ControllerCheck_Enter()
	{
		if (!HasValidController())
		{
			noControllerMenu.gameObject.SetActive(value: true);
			noControllerMenu.Visible = true;
			noControllerMenu.SetCollidersEnabled(enabled: true);
			noControllerMenuAnimator.FadeIn();
			noControllerMenu.SetText("main_text", Translate.Get("GAMEPAD_LOST") + "\n\n" + Translate.Get("GAMEPAD_LOST_TIP"));
			crosshairFar.gameObject.SetActive(value: false);
		}
	}

	private void ControllerCheck_Exit()
	{
		noControllerMenu.gameObject.SetActive(value: false);
		noControllerMenu.SetCollidersEnabled(enabled: false);
		canContinue = true;
	}

	private void ControllerCheck_Update()
	{
		if (HasValidController())
		{
			base.State = States.Menu;
		}
	}

	private bool HasValidController()
	{
		return InputExt.HasHandControllers || InputExt.Has3DOFController || InputExt.HasGamepad;
	}

	private void Credits_Enter()
	{
		creditsMenu.gameObject.SetActive(value: true);
		creditsMenu.Visible = true;
		creditsMenu.SetCollidersEnabled(enabled: true);
		creditsMenuAnimator.FadeIn();
		creditsMenu.SetText("main_text", GetCreditsString(0));
		creditsTimeout = 6f;
		creditsIndex = 1;
		crosshairFar.gameObject.SetActive(value: false);
		canContinue = true;
	}

	private void Credits_Exit()
	{
		creditsMenu.gameObject.SetActive(value: false);
		creditsMenu.SetCollidersEnabled(enabled: false);
	}

	private void Credits_Update()
	{
		creditsTimeout -= Time.deltaTime;
		if (canContinue && (InputExt.GetButtonDown(InputExt.Button.Action) || InputExt.GetButtonDown(InputExt.Button.UIAction) || InputExt.GetButtonDown(InputExt.Button.Cancel) || GameController.GetBackButtonDown()))
		{
			canContinue = false;
			creditsMenuAnimator.FadeOut(reset: false, OnEndCreditsFade);
		}
		else if (canContinue && creditsTimeout <= 0f)
		{
			canContinue = false;
			creditsMenuAnimator.FadeOut(reset: false, OnEndCreditsSectionFade);
		}
	}

	private void OnEndCreditsFade()
	{
		base.State = States.Menu;
	}

	private void OnEndCreditsSectionFade()
	{
		string creditsString = GetCreditsString(creditsIndex);
		if (creditsString != string.Empty)
		{
			creditsMenu.SetText("main_text", creditsString);
			creditsMenuAnimator.FadeIn();
			creditsIndex++;
			creditsTimeout = 6f;
			canContinue = true;
		}
		else
		{
			base.State = States.Menu;
		}
	}

	private string GetCreditsString(int idx)
	{
		string key = "MENU_CREDITS_SECTION_" + idx;
		if (!Translate.Check(key))
		{
			return string.Empty;
		}
		return Translate.Get(key);
	}

	private void Controls_Enter()
	{
		canContinue = true;
		fast = false;
		crosshairFar.gameObject.SetActive(value: false);
		InputExt.Get().lockedActiveController = true;
		StartCoroutine(Controls_co());
	}

	private IEnumerator Controls_co()
	{
		Renderer toFade3 = controlsOculusGoPad;
		if (Pvr_UnitySDKAPI.System.UPvr_GetDeviceModel().Contains("Neo 2"))
		{
			if (InputExt.UsingHandControllers)
			{
				toFade3 = ((!InputExt.LeftHanded) ? controlsNeo2Right : controlsNeo2Left);
			}
		}
		else if (InputExt.UsingHandControllers)
		{
			toFade3 = ((!InputExt.LeftHanded) ? controlsNeo3Right : controlsNeo3Left);
		}
		StartCoroutine(FadeIn(toFade3));
		yield return new WaitForSeconds(4f);
		toFade3 = continueTouch;
		toFade3 = ((!InputExt.UsingHandControllers) ? continuePad : continueTouch);
		StartCoroutine(FadeIn(toFade3));
	}

	private void Controls_Update()
	{
		bool flag = InputExt.GetButtonDown(InputExt.Button.Action) || InputExt.GetButtonDown(InputExt.Button.UIAction);
		if (InputExt.UsingHandControllers)
		{
			flag |= InputExt.GetButtonDown(InputExt.Button.Action) || InputExt.GetButtonDown(InputExt.Button.Light);
		}
		if (canContinue && flag)
		{
			canContinue = false;
			if (!enterDemo && !randomMapMode)
			{
				GameController.Get().NewGame("SavedGame_00", enterLite);
			}
			else if (randomMapMode)
			{
				GameController.Get().StartRandomMap();
			}
			else if (enterDemo)
			{
				GameController.Get().StartDemo();
				GameState.Get().Reset();
			}
		}
	}

	private void Controls_Exit()
	{
	}

	private void Options_Enter()
	{
		optionsMenu.gameObject.SetActive(value: true);
		optionsMenu.Visible = true;
		optionsMenu.SetCollidersEnabled(enabled: true);
		optionsMenu.GetButton("button_back").SetAction(OnOptions_Back);
		optionsMenuAnimator.FadeIn();
		crosshairFar.gameObject.SetActive(value: false);
		crosshairNear.gameObject.SetActive(value: true);
		dialogActive = true;
	}

	private void Options_Exit()
	{
		optionsMenuAnimator.FadeOut(reset: false, OnEndOptionsFade);
		optionsMenu.SetCollidersEnabled(enabled: false);
		crosshairNear.gameObject.SetActive(value: false);
	}

	private void OnEndOptionsFade()
	{
		optionsMenu.Visible = false;
		optionsMenu.gameObject.SetActive(value: false);
	}

	private void OnOptions_Back()
	{
		if (dialogActive)
		{
			base.State = States.Menu;
			dialogActive = false;
		}
	}

	public void OnBackButton()
	{
		if (base.State == States.Options)
		{
			OnOptions_Back();
		}
		else if (base.State == States.ConfirmOverwrite)
		{
			OnConfirmOverwrite_No();
		}
		else
		{
			GameController.Get().ExitGame();
		}
	}

	private IEnumerator FadeIn(Renderer renderer)
	{
		renderer.enabled = true;
		Color cInit = renderer.material.color;
		cInit.a = 0f;
		renderer.material.color = cInit;
		while (renderer.material.color.a < 1f)
		{
			Color c = renderer.material.color;
			c.a = Mathf.Clamp(c.a + FadeInSpeed * Time.deltaTime * ((!fast) ? 1f : 10f), 0f, 1f);
			renderer.material.color = c;
			yield return new WaitForEndOfFrame();
		}
	}

	private IEnumerator FadeOut(Renderer renderer)
	{
		while (renderer.material.color.a > 0f)
		{
			Color c = renderer.material.color;
			c.a = Mathf.Clamp(c.a - FadeOutSpeed * Time.deltaTime * ((!fast) ? 1f : 10f), 0f, 1f);
			renderer.material.color = c;
			yield return new WaitForEndOfFrame();
		}
		renderer.enabled = false;
	}

	private UIButton3D GetButton(string name)
	{
		Transform transform = mainMenu.transform.Find(name);
		if (transform == null)
		{
			return null;
		}
		return transform.GetComponent<UIDreadHallsMainButton>();
	}
}
public class Chest : MonoBehaviour
{
	public Transform TopCover;

	public bool IsOpen;

	public List<GameObject> ItemSpawns;

	public GameObject unlock;

	public Renderer tableMesh;

	private static Permutator EmptySeq;

	private bool firstUpdate = true;

	private TextLabel tutorialText;

	private bool checkTutorial;

	private Room room;

	private void Start()
	{
		if (EmptySeq == null)
		{
			EmptySeq = new Permutator(3, 10, 1);
		}
		IsOpen = false;
		tableMesh.enabled = false;
		float z = base.transform.localScale.z;
		if (z < 1f)
		{
			float num = 1f / z;
			unlock.transform.localScale = new Vector3(unlock.transform.localScale.x * num, unlock.transform.localScale.y, unlock.transform.localScale.z);
		}
	}

	private void Open()
	{
		IsOpen = true;
		tableMesh.enabled = true;
		if (!EmptySeq.Next)
		{
			int num = UnityEngine.Random.Range(1, 4);
			for (int i = 0; i < num; i++)
			{
				int index = UnityEngine.Random.Range(0, ItemSpawns.Count);
				GameObject gameObject = ItemSpawns[index];
				ItemSpawns.RemoveAt(index);
				gameObject.SetActive(value: true);
			}
		}
		TopCover.GetComponent<Collider>().enabled = false;
		if (tutorialText != null)
		{
			tutorialText.FadeOut(4f, disableOnFadeOut: true, destroyOnFadeOut: true);
			tutorialText = null;
		}
	}

	private void Update()
	{
		if (IsOpen)
		{
			Quaternion b = Quaternion.Euler(0f, 0f, 52f);
			TopCover.localRotation = Quaternion.Slerp(TopCover.localRotation, b, Time.deltaTime);
			float num = Quaternion.Angle(TopCover.localRotation, b);
			if (num <= 0.01f)
			{
				base.enabled = false;
			}
		}
		else if (checkTutorial && room != null && room.PlayerInside && Config.General().tutorials)
		{
			float num2 = (Player.GetGroundPos() - base.transform.position).sqrMagnitudeGround();
			if (num2 <= 6.25f)
			{
				ShowTutorial("TUTO_CHEST");
				checkTutorial = false;
			}
		}
		if (firstUpdate)
		{
			checkTutorial = Config.General().tutorials && !Tutorial.HasBeenShownBefore("TUTO_CHEST", add: false);
			room = Map.Get().At(base.transform.position).Room;
			firstUpdate = false;
		}
	}

	private void ShowTutorial(string tutoCode)
	{
		Vector3 localPos = base.transform.position + Vector3.up * 1.2f;
		Quaternion localRot = Quaternion.AngleAxis(25f, base.transform.forward) * Quaternion.LookRotation(-base.transform.right, Vector3.up);
		tutorialText = Tutorial.ShowInPlace(tutoCode, localPos, localRot);
	}
}
public class Collectable : InteractionListener
{
	public enum EItemType
	{
		Oil,
		Potion,
		Lamp,
		Coin,
		Note,
		Lockpick,
		Meta01,
		Meta02,
		Meta03,
		Meta04,
		Undefined
	}

	public EItemType itemType;

	public AudioClip pickupSound;

	private bool isExamining;

	private bool isMoving;

	private Inventory playerInventory;

	private MinimapPosition minimapPos;

	private Vector3 deltaCenter;

	public float examineDistance = 0.6f;

	private bool listenEndExamining;

	private TextLabel tutorialText;

	private Transform initParent;

	private TextLabel highlightTutorialText;

	private List<GameObject> objectsToNotify;

	private List<Collectable> enableWhenPicked;

	public Collectable pickAfter;

	private static bool alreadyPickedUp;

	private new void Awake()
	{
		base.Awake();
		enableWhenPicked = new List<Collectable>();
	}

	private new void Start()
	{
		base.Start();
		isMoving = false;
		initParent = base.transform.parent;
		Serializer.Add(this, OnSerialize, OnDeserialize);
		PlayerStats.Get().AddItem();
		if (pickAfter != null)
		{
			pickAfter.enableWhenPicked.Add(this);
			GetComponent<Collider>().enabled = false;
		}
	}

	private void OnSerialize(BinaryWriter writer)
	{
	}

	private void OnDeserialize(BinaryReader reader)
	{
	}

	private new void Update()
	{
		base.Update();
		if (isMoving)
		{
			PickUp_Update();
		}
		else if (isExamining)
		{
			Examine_Update();
		}
	}

	private void LateUpdate()
	{
		alreadyPickedUp = false;
	}

	private void Examine(string textCode)
	{
		isExamining = true;
		isMoving = false;
		listenEndExamining = false;
		GetComponent<Collider>().enabled = false;
		playerInventory = GameObject.FindWithTag(Tags.Inventory).GetComponent<Inventory>();
		minimapPos = GameObject.FindWithTag(Tags.Minimap).GetComponent<MinimapPosition>();
		playerInventory.Reorient();
		base.transform.parent = playerInventory.transform;
		float num = 0f;
		Renderer[] componentsInChildren = GetComponentsInChildren<Renderer>();
		deltaCenter = Vector3.zero;
		if (componentsInChildren.Length > 0)
		{
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				deltaCenter += componentsInChildren[i].bounds.center;
				if (componentsInChildren[i].bounds.extents.y > num)
				{
					num = componentsInChildren[i].bounds.extents.y;
				}
			}
			deltaCenter /= (float)componentsInChildren.Length;
			deltaCenter = base.transform.InverseTransformPoint(deltaCenter);
		}
		Vector3 vector = playerInventory.transform.forward * examineDistance + playerInventory.transform.up * 0.15f;
		Vector3 vector2 = Vector3.forward * examineDistance;
		vector2.y = vector.y;
		tutorialText = Tutorial.ShowInPlace(textCode, vector2, Quaternion.Euler(0f, 0f, 0f), playerInventory.transform);
		tutorialText.transform.localScale = new Vector3(0.5f, 0.5f, 0.5f);
		float y = tutorialText.GetComponent<Renderer>().bounds.extents.y;
		vector2.y = vector.y + num + y + 0.15f;
		tutorialText.transform.localPosition = vector2;
		Vector3 eulerAngles = tutorialText.transform.rotation.eulerAngles;
		tutorialText.transform.rotation = Quaternion.Euler(0f, eulerAngles.y, 0f);
		Player.GetController().BlockMovement(blockRotation: false);
		playerInventory.Block();
	}

	private void Examine_Update()
	{
		Vector3 vector = base.transform.TransformPoint(deltaCenter) - base.transform.position;
		Vector3 b = playerInventory.transform.position + playerInventory.transform.forward * examineDistance + playerInventory.transform.up * 0.15f;
		base.transform.position = Vector3.Lerp(base.transform.position + vector, b, Time.deltaTime * 4f) - vector;
		float angle = 57.29578f * Time.deltaTime * 0.5f;
		Vector3 axis = base.transform.TransformDirection(new Vector3(0f, 1f, 0f));
		base.transform.RotateAround(base.transform.position + vector, axis, angle);
		minimapPos.Hide = true;
		if (listenEndExamining && (InputExt.GetButtonDown(InputExt.Button.Action) || InputExt.GetButtonDown(InputExt.Button.Cancel) || InputExt.GetButtonDown(InputExt.Button.Inventory)))
		{
			tutorialText.FadeOut(4f, disableOnFadeOut: true, destroyOnFadeOut: true);
			Player.GetController().UnblockMovement(unBlockRotation: false);
			playerInventory.Unblock();
			base.transform.parent = null;
			PickUp();
		}
		else if (!listenEndExamining)
		{
			listenEndExamining = true;
		}
	}

	private void PickUp()
	{
		isMoving = true;
		isExamining = false;
		GetComponent<Collider>().enabled = false;
		AudioSource.PlayClipAtPoint(pickupSound, base.transform.position);
		if (itemType == EItemType.Note)
		{
			PlayerNotes component = GameObject.FindWithTag(Tags.PlayerNotes).GetComponent<PlayerNotes>();
			if ((bool)component)
			{
				component.SetPreShowNote();
			}
		}
		if (enableWhenPicked != null)
		{
			for (int i = 0; i < enableWhenPicked.Count; i++)
			{
				enableWhenPicked[i].OnTopColledted();
			}
		}
	}

	private void PickUp_Update()
	{
		Vector3 vector = Player.GetLook().position - Vector3.up * 0.5f;
		Vector3 vector2 = vector - base.transform.position;
		if (vector2.sqrMagnitude <= 0.01f)
		{
			Inventory componentInChildren = Player.Get().GetComponentInChildren<Inventory>();
			componentInChildren.AddItem(itemType);
			if (itemType == EItemType.Note)
			{
				componentInChildren.UseItem(itemType);
			}
			Serializer.Remove(this);
			if (InputExt.UsingHandControllers)
			{
				Player.GetActionHand().PlayHapticCollect();
			}
			if (objectsToNotify != null)
			{
				for (int i = 0; i < objectsToNotify.Count; i++)
				{
					objectsToNotify[i].SendMessage("OnColledted", this, SendMessageOptions.DontRequireReceiver);
				}
			}
			PlayerStats.Get().AddCollectedItem();
			UnityEngine.Object.Destroy(base.gameObject);
		}
		else
		{
			float num = vector2.magnitude / 2f;
			num = 1f / num;
			base.transform.position = base.transform.position + vector2.normalized * num * Time.deltaTime * 2f;
		}
	}

	protected override bool OnInteraction()
	{
		if (itemType == EItemType.Note)
		{
			PlayerNotes component = GameObject.FindWithTag(Tags.PlayerNotes).GetComponent<PlayerNotes>();
			if ((bool)component && component.IsShowingNote)
			{
				return false;
			}
		}
		if (Player.GetInventory().IsBlocked())
		{
			return false;
		}
		if (alreadyPickedUp)
		{
			return false;
		}
		canInteract = false;
		alreadyPickedUp = true;
		string textCode = ("TUTO_ITEM_" + itemType).ToUpper();
		if (!Tutorial.HasBeenShownBefore(textCode, add: false))
		{
			Examine(textCode);
		}
		else
		{
			PickUp();
		}
		if (highlightTutorialText != null)
		{
			highlightTutorialText.FadeOut(4f, disableOnFadeOut: true, destroyOnFadeOut: true);
			highlightTutorialText = null;
		}
		return true;
	}

	protected override void OnHighlight()
	{
		if (!Tutorial.Get().tutoState.tutorialCollect)
		{
			Tutorial.Get().tutoState.tutorialCollect = true;
			Vector3 vector = base.transform.position + Vector3.up * 0.45f;
			Vector3 vector2 = (Player.GetCenterEye() - vector).GroundNormalize();
			Quaternion localRot = Quaternion.LookRotation(-vector2, Vector3.up);
			highlightTutorialText = Tutorial.ShowInPlace("TUTO_COLLECT", vector, localRot);
		}
	}

	public void NotifyOnPickUp(GameObject obj)
	{
		if (objectsToNotify == null)
		{
			objectsToNotify = new List<GameObject>();
		}
		objectsToNotify.Add(obj);
	}

	public void OnTopColledted()
	{
		GetComponent<Collider>().enabled = true;
	}
}
public class CollectableGroup : MonoBehaviour
{
	public List<Collectable.EItemType> spawnItems;

	private int idx;

	private void Awake()
	{
		if (spawnItems != null)
		{
			CollectableSpawnController component = GameObject.FindWithTag(Tags.GameController).GetComponent<CollectableSpawnController>();
			component.AddSpawnGroup(this);
			idx = 0;
		}
	}

	public Collectable.EItemType GetNext()
	{
		if (idx >= spawnItems.Count)
		{
			return Collectable.EItemType.Undefined;
		}
		Collectable.EItemType result = spawnItems[idx];
		idx++;
		return result;
	}
}
public class CollectableOld : MonoBehaviour
{
	public enum EItemType
	{
		Oil,
		Potion,
		Coin,
		Note
	}

	public EItemType ItemType;

	public float PickupDistance = 1.5f;

	public AudioClip PickupSound;

	public LayerMask LayerMask;

	private Transform PlayerLook;

	private bool IsMoving;

	private void Start()
	{
		PlayerLook = Player.GetLook();
		IsMoving = false;
	}

	private void Update()
	{
		if (!IsMoving)
		{
			Vector3 vector = PlayerLook.position - base.transform.position;
			vector.y = 0f;
			if (vector.sqrMagnitude <= PickupDistance * PickupDistance && Physics.Raycast(PlayerLook.position, PlayerLook.forward, out var hitInfo, PickupDistance, LayerMask) && hitInfo.collider == GetComponent<Collider>())
			{
				IsMoving = true;
				GetComponent<Collider>().enabled = false;
			}
			return;
		}
		Vector3 vector2 = PlayerLook.position - Vector3.up * 0.5f;
		Vector3 vector3 = vector2 - base.transform.position;
		if (vector3.sqrMagnitude <= 0.01f)
		{
			AudioSource.PlayClipAtPoint(PickupSound, base.transform.position);
			UnityEngine.Object.Destroy(base.gameObject);
		}
		else
		{
			float num = vector3.magnitude / 2f;
			num = 1f / num;
			base.transform.position = base.transform.position + vector3.normalized * num * Time.deltaTime * 2f;
		}
	}
}
public class CollectableSpawn : MonoBehaviour
{
	public float SpawnProbability = 0.8f;

	public float distanceFactor = 1f;

	public float radiusFactor = 1f;

	public bool parentToParent;

	private static CollectableSpawnController controller;

	private GameObject prefab;

	private void Awake()
	{
		if (!controller)
		{
			controller = GameObject.FindWithTag(Tags.GameController).GetComponent<CollectableSpawnController>();
		}
	}

	private void Start()
	{
		bool fromGroup = false;
		if ((bool)controller)
		{
			prefab = controller.GetCollectable(base.transform.position, out fromGroup);
		}
		if ((bool)prefab)
		{
			if (!fromGroup)
			{
				bool flag = false;
				Point point = Map.Get().WorldToCell(base.transform.position);
				for (int i = point.Y - 1; i <= point.Y + 1; i++)
				{
					if (flag)
					{
						break;
					}
					for (int j = point.X - 1; j <= point.X + 1; j++)
					{
						if (flag)
						{
							break;
						}
						if (j != point.X || i != point.Y)
						{
							Cell cell = Map.Get().At(j, i);
							if (cell.CanWalk() && !cell.Occupied)
							{
								flag = true;
							}
						}
					}
				}
				if (!flag)
				{
					UnityEngine.Object.Destroy(base.gameObject);
					return;
				}
			}
			GameObject gameObject = UnityEngine.Object.Instantiate(prefab, Vector3.zero, Quaternion.identity);
			if (parentToParent)
			{
				gameObject.transform.parent = base.transform.parent.parent;
			}
			else
			{
				gameObject.transform.parent = base.transform.parent;
			}
			gameObject.transform.position = base.transform.position - Vector3.up * (GetComponent<Renderer>().bounds.size.y / 2f);
			gameObject.transform.rotation = base.transform.rotation;
			if (distanceFactor != 1f)
			{
				Collectable component = gameObject.GetComponent<Collectable>();
				if (component != null)
				{
					component.distance *= distanceFactor;
				}
			}
			if (radiusFactor != 1f)
			{
				SphereCollider component2 = gameObject.GetComponent<SphereCollider>();
				if (component2 != null)
				{
					component2.radius *= radiusFactor;
				}
			}
		}
		UnityEngine.Object.Destroy(base.gameObject);
	}

	public static void Clear()
	{
		controller = null;
	}

	private void OnDrawGizmos()
	{
		CollectableSpawnController component = controller;
		if (!component)
		{
			component = GameObject.FindWithTag(Tags.GameController).GetComponent<CollectableSpawnController>();
		}
		if (!component)
		{
			return;
		}
		GameObject[] array = new GameObject[5];
		Quaternion[] array2 = new Quaternion[5];
		array[0] = component.OilPrefabs[0];
		array[1] = component.LockpickPrefabs[0];
		array[2] = component.NotesPrefabs[0];
		array[3] = component.TreasuryPrefabs[0];
		array[4] = component.TreasuryPrefabs[1];
		Matrix4x4 matrix4x = default(Matrix4x4);
		matrix4x.SetTRS(base.transform.position, base.transform.rotation, Vector3.one);
		for (int i = 0; i < array.Length; i++)
		{
			MeshFilter[] componentsInChildren = array[i].GetComponentsInChildren<MeshFilter>(includeInactive: true);
			for (int j = 0; j < componentsInChildren.Length; j++)
			{
				Mesh sharedMesh = componentsInChildren[j].sharedMesh;
				Matrix4x4 matrix4x2 = matrix4x;
				Vector3 localPosition = componentsInChildren[j].transform.localPosition;
				localPosition -= Vector3.up * (GetComponent<Renderer>().bounds.size.y / 2f);
				Quaternion localRotation = componentsInChildren[j].transform.localRotation;
				localPosition = matrix4x2.MultiplyPoint(localPosition);
				Quaternion quaternion = Quaternion.LookRotation(matrix4x2.GetColumn(2), matrix4x2.GetColumn(1));
				if (sharedMesh != null)
				{
					Matrix4x4 matrix = default(Matrix4x4);
					matrix.SetTRS(localPosition, quaternion * localRotation, componentsInChildren[j].transform.localScale);
					Graphics.DrawMeshNow(sharedMesh, matrix);
					Gizmos.color = new Color(0f, 0f, 0f, 0f);
					Gizmos.DrawCube(sharedMesh.bounds.center, sharedMesh.bounds.size);
				}
			}
		}
	}
}
public class CollectableSpawnController : MonoBehaviour
{
	public GameObject[] TreasuryPrefabs;

	public GameObject[] LockpickPrefabs;

	public GameObject[] OilPrefabs;

	public GameObject[] NotesPrefabs;

	public float SpawnProbability = 0.8f;

	public float ProbTreasury = 0.5f;

	public float ProbLockpick;

	public float ProbOil = 0.4f;

	public float ProbNote = 0.1f;

	public float RandomModeProbTreasury = 0.5f;

	public float RandomModeProbLockpick;

	public float RandomModeProbOil = 0.4f;

	public float RandomModeProbNote = 0.1f;

	public int TotalTreasury;

	public int TotalLockpicks;

	public int TotalOil;

	public int TotalNotes;

	private Dictionary<Point, CollectableGroup> collectableGroups = new Dictionary<Point, CollectableGroup>();

	private System.Random randomGen;

	private void Awake()
	{
		if (GameController.Get().levelOptions.isDemo)
		{
			ProbTreasury = 0.42000002f;
			ProbLockpick = 0f;
			ProbOil = 0.58000004f;
			ProbNote = 0f;
		}
		else if (GameController.Get().levelOptions.isRandomMode)
		{
			ProbTreasury = RandomModeProbTreasury;
			ProbLockpick = RandomModeProbLockpick;
			ProbOil = RandomModeProbOil;
			ProbNote = RandomModeProbNote;
		}
		else if (GameController.Get().levelOptions.generatorType != 0)
		{
			ProbTreasury = 0.24f;
			ProbLockpick = 0.285f;
			ProbOil = 0.325f;
			ProbNote = 0.15f;
		}
		randomGen = new System.Random(UnityEngine.Random.Range(0, 32000));
	}

	public GameObject GetCollectable(Vector3 pos, out bool fromGroup)
	{
		GameObject result = null;
		Collectable.EItemType eItemType = Collectable.EItemType.Undefined;
		Point point = Map.Get().WorldToCell(pos);
		if (collectableGroups.TryGetValue(point, out var value))
		{
			eItemType = value.GetNext();
			fromGroup = true;
			if (eItemType == Collectable.EItemType.Undefined)
			{
				return null;
			}
		}
		fromGroup = false;
		float num = 1f;
		Room room = Map.Get().At(point).Room;
		if (room != null && !room.IsSpawnRoom && room.IsDeadEnd)
		{
			num = ((room.Template.size != 0) ? 1.15f : 1.5f);
		}
		if (eItemType == Collectable.EItemType.Undefined && (float)randomGen.NextDouble() < SpawnProbability * GameController.Get().levelOptions.collectableSpawnFactor * num)
		{
			GameObject[] array = null;
			float num2 = (float)randomGen.NextDouble();
			if (num2 <= ProbTreasury)
			{
				array = TreasuryPrefabs;
				TotalTreasury++;
			}
			else if (num2 <= ProbTreasury + ProbOil)
			{
				array = OilPrefabs;
				TotalOil++;
			}
			else if (num2 <= ProbTreasury + ProbOil + ProbLockpick)
			{
				array = LockpickPrefabs;
				TotalLockpicks++;
			}
			else
			{
				array = NotesPrefabs;
				TotalNotes++;
			}
			result = array[randomGen.Next(0, array.Length)];
		}
		else if (eItemType != Collectable.EItemType.Undefined)
		{
			GameObject[] array2 = null;
			switch (eItemType)
			{
			case Collectable.EItemType.Coin:
				array2 = TreasuryPrefabs;
				TotalTreasury++;
				break;
			case Collectable.EItemType.Oil:
				array2 = OilPrefabs;
				TotalOil++;
				break;
			case Collectable.EItemType.Lockpick:
				array2 = LockpickPrefabs;
				TotalLockpicks++;
				break;
			case Collectable.EItemType.Note:
				array2 = NotesPrefabs;
				TotalNotes++;
				break;
			default:
				return null;
			}
			result = array2[randomGen.Next(0, array2.Length)];
		}
		return result;
	}

	public void AddSpawnGroup(CollectableGroup group)
	{
		Point key = Map.Get().WorldToCell(group.transform.position);
		collectableGroups[key] = group;
	}
}
public class FadeOnEyeClip : MonoBehaviour
{
	public float clipRange = 0.3f;

	public float falloffRange = 0.1f;

	private Vector3 deltaCenter;

	private List<Material> materials;

	private Transform[] playerEyes;

	private void Start()
	{
		Renderer[] componentsInChildren = GetComponentsInChildren<Renderer>();
		deltaCenter = Vector3.zero;
		materials = new List<Material>();
		if (componentsInChildren.Length > 0)
		{
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				deltaCenter += componentsInChildren[i].bounds.center;
				for (int j = 0; j < componentsInChildren[i].materials.Length; j++)
				{
					materials.Add(componentsInChildren[i].materials[j]);
				}
			}
			deltaCenter /= (float)componentsInChildren.Length;
			deltaCenter = base.transform.InverseTransformPoint(deltaCenter);
		}
		playerEyes = new Transform[2];
		Transform transform = Player.Get().transform.Find("Pvr_UnitySDK").transform;
		playerEyes[0] = transform.Find("Head/LeftEye");
		playerEyes[1] = transform.Find("Head/RightEye");
		if (playerEyes[0] == null || playerEyes[1] == null)
		{
			Debug.Log("no eyes");
			Debug.Break();
		}
	}

	private void Update()
	{
		float num = 1f;
		Vector3 vector = base.transform.position + deltaCenter;
		float num2 = clipRange + falloffRange;
		for (int i = 0; i < playerEyes.Length; i++)
		{
			float sqrMagnitude = (playerEyes[i].position - vector).sqrMagnitude;
			if (sqrMagnitude <= num2 * num2)
			{
				if (sqrMagnitude <= clipRange * clipRange)
				{
					num = 0f;
					continue;
				}
				float num3 = Mathf.Sqrt(sqrMagnitude);
				float value = (num3 - clipRange) / falloffRange;
				num = Mathf.Min(num, Mathf.Clamp01(value));
			}
		}
		for (int j = 0; j < materials.Count; j++)
		{
			materials[j].SetFloat("_Fade", num);
		}
		DebugExt.DrawPoint(vector, Color.blue, 0.1f);
		DebugExt.DrawSphere(vector, Color.blue, clipRange);
	}
}
public class Inventory : MonoBehaviour
{
	[Serializable]
	public class ItemProxyInfo
	{
		public bool grabbable;

		public float scaleFactor = 1f;

		public Vector3 posDelta = Vector3.zero;
	}

	public int[] NumItems;

	public List<GameObject> ItemPrefabs;

	public List<string> ItemLabels;

	public List<ItemProxyInfo> ItemProxyInfos;

	public GameObject optionsItemPrefab;

	public string optionsItemLabel;

	public float DisplayArcDistance = 1f;

	public float HighlightArcDistance = 0.6f;

	public float DisplayArcAngle = 100f;

	private float currentArcAngle;

	public GameObject LabelPrefab;

	public LayerMask LayerMask;

	public bool checkCollisions;

	public LayerMask CollisionLayerMask;

	public AudioClip OpenSound;

	public AudioClip CloseSound;

	public AudioClip HightlightSound;

	private bool Showing;

	private int blocked;

	private bool unblockWhenClosed;

	private List<GameObject> ItemInstances;

	private List<Vector3> ItemPositions;

	private List<string> ItemTexts;

	private List<int> ItemTypes;

	private GameObject HighlightedItem;

	private GameObject LastHighlightedItem;

	private GameObject HighlightedLabel;

	private Material lampMaterial;

	private GameObject HighlightCoolDownItem;

	private float HighlightCoolDown;

	private Transform ForwardDirection;

	private Transform LookDirection;

	private MinimapPosition MinimapPos;

	public AntiBodyDelta antiDelta;

	private Collider[] colliderBuffer = new Collider[12];

	private void Start()
	{
		NumItems = new int[Enum.GetNames(typeof(Collectable.EItemType)).Length];
		GameState.Get().GetInventory(this);
		if (GameController.Get().levelOptions.isDemo)
		{
			NumItems[0] = 1;
		}
		else if (GameController.Get().levelOptions.isRandomMode)
		{
			NumItems[0] = 1;
		}
		NumItems[2] = 1;
		ItemInstances = new List<GameObject>();
		ItemPositions = new List<Vector3>();
		Showing = false;
		blocked = 0;
		HighlightedItem = null;
		LastHighlightedItem = null;
		HighlightCoolDownItem = null;
		ForwardDirection = GameObject.FindWithTag(Tags.ForwardDirection).transform;
		LookDirection = Player.GetLook(interaction: true);
		MinimapPos = GameObject.FindWithTag(Tags.Minimap).GetComponent<MinimapPosition>();
		HighlightedLabel = UnityEngine.Object.Instantiate(LabelPrefab);
		HighlightedLabel.transform.parent = base.transform;
		HighlightedLabel.GetComponent<Renderer>().enabled = false;
		currentArcAngle = DisplayArcAngle;
		lampMaterial = null;
		if (antiDelta != null)
		{
			antiDelta.enabled = true;
			antiDelta.enabled = false;
		}
	}

	private void Update()
	{
		bool flag = false;
		flag = ((!Showing) ? (InputExt.GetButtonDown(InputExt.Button.Inventory) && blocked == 0) : (InputExt.GetButton(InputExt.Button.Inventory) && blocked == 0));
		LookDirection = Player.GetLook(interaction: true);
		if (!Showing && flag)
		{
			Showing = true;
			HighlightCoolDownItem = null;
			List<Tuple<GameObject, string, int>> list = BuildItemList();
			if (list.Count == 0)
			{
				Showing = false;
			}
			else
			{
				ItemTexts = new List<string>(list.Count);
				ItemTypes = new List<int>(list.Count);
				Reorient(enableAntiDelta: true);
				float num = currentArcAngle / (float)(list.Count + 1);
				float num2 = (0f - currentArcAngle) / 2f;
				for (int i = 0; i < list.Count; i++)
				{
					float angle = num2 + num * (float)(i + 1);
					Quaternion quaternion = Quaternion.AngleAxis(angle, Vector3.up);
					Vector3 vector = Vector3.forward * DisplayArcDistance;
					vector = quaternion * vector;
					bool flag2 = list[i].Item3 == 2;
					GameObject gameObject = UnityEngine.Object.Instantiate(list[i].Item1);
					gameObject.transform.parent = base.transform;
					gameObject.transform.localPosition = Vector3.zero + Vector3.down * 0.25f;
					if (flag2)
					{
						lampMaterial = gameObject.transform.Find("lantern_body").GetComponent<Renderer>().materials[1];
						lampMaterial.SetFloat("_Level", Player.GetTorchFuel().GetFuelLevelNormalized());
						lampMaterial.SetFloat("_EmissionIntensity", (!Player.GetTorchFuel().lightOn) ? 0.3f : 1f);
					}
					if (InputExt.Using3DOFController || InputExt.UsingHandControllers)
					{
						SphereCollider[] componentsInChildren = gameObject.GetComponentsInChildren<SphereCollider>();
						SphereCollider[] array = componentsInChildren;
						foreach (SphereCollider sphereCollider in array)
						{
							sphereCollider.center += Vector3.down * 0.025f;
							sphereCollider.radius += 0.05f;
						}
					}
					Collectable[] componentsInChildren2 = GetComponentsInChildren<Collectable>();
					Collectable[] array2 = componentsInChildren2;
					foreach (Collectable collectable in array2)
					{
						collectable.enabled = false;
					}
					ItemInstances.Add(gameObject);
					ItemPositions.Add(vector);
					ItemTexts.Add(list[i].Item2);
					ItemTypes.Add(list[i].Item3);
				}
				AudioSource.PlayClipAtPoint(OpenSound, base.transform.position);
			}
		}
		if (Showing)
		{
			if (flag)
			{
				GameObject highlightedItem = GetHighlightedItem();
				if ((bool)highlightedItem && highlightedItem != HighlightedItem)
				{
					AudioSource.PlayClipAtPoint(HightlightSound, highlightedItem.transform.position);
				}
				if ((bool)HighlightedItem && highlightedItem != HighlightedItem)
				{
					HighlightCoolDownItem = HighlightedItem;
					HighlightCoolDown = 0.4f;
				}
				HighlightedItem = highlightedItem;
				if (InputExt.UsingHandControllers && InputExt.GetButtonDown(InputExt.Button.Action) && (bool)HighlightedItem)
				{
					int index = 0;
					for (int l = 0; l < ItemInstances.Count; l++)
					{
						if (ItemInstances[l] == HighlightedItem)
						{
							index = l;
						}
					}
					if (ItemTypes[index] == -1)
					{
						OpenOptionsMenu();
					}
					else
					{
						ItemProxyInfo itemProxyInfo = ItemProxyInfos[ItemTypes[index]];
						if (itemProxyInfo.grabbable)
						{
							AudioSource.PlayClipAtPoint(CloseSound, base.transform.position);
							Block();
							Block();
							unblockWhenClosed = true;
							InventoryHandProxy.Create(HighlightedItem, (Collectable.EItemType)ItemTypes[index], itemProxyInfo.scaleFactor, itemProxyInfo.posDelta);
							HighlightedItem = null;
							flag = false;
						}
					}
				}
			}
			else
			{
				if (InputExt.GetButtonUp(InputExt.Button.Inventory) && !IsBlocked())
				{
					AudioSource.PlayClipAtPoint(CloseSound, base.transform.position);
					if ((bool)HighlightedItem && !InputExt.UsingHandControllers)
					{
						int index2 = 0;
						for (int m = 0; m < ItemInstances.Count; m++)
						{
							if (ItemInstances[m] == HighlightedItem)
							{
								index2 = m;
							}
						}
						if (ItemTypes[index2] == -1)
						{
							OpenOptionsMenu();
						}
						else
						{
							UseItem((Collectable.EItemType)ItemTypes[index2]);
						}
					}
				}
				HighlightedItem = null;
			}
			if (checkCollisions)
			{
				Vector3 direction = base.transform.forward * DisplayArcDistance;
				float magnitude = direction.magnitude;
				direction.Normalize();
				float t = 1f;
				if (Physics.Raycast(base.transform.position, direction, out var hitInfo, magnitude, CollisionLayerMask))
				{
					t = hitInfo.distance / magnitude;
					t = Mathf.Clamp01((t - 0.5f) * 2f);
				}
				currentArcAngle = Mathf.Lerp(DisplayArcAngle * 1.5f, DisplayArcAngle, t);
			}
			if (lampMaterial != null)
			{
				lampMaterial.SetFloat("_Level", Player.GetTorchFuel().GetFuelLevelNormalized());
				lampMaterial.SetFloat("_EmissionIntensity", (!Player.GetTorchFuel().lightOn) ? 0.3f : 1f);
			}
			bool flag3 = false;
			for (int n = 0; n < ItemInstances.Count; n++)
			{
				if (flag)
				{
					ItemPositions[n] = GetItemPosition(n, ItemInstances[n] == HighlightedItem);
				}
				else
				{
					ItemPositions[n] = Vector3.zero + Vector3.down * 0.25f;
				}
				Vector3 vector2 = ItemPositions[n] - ItemInstances[n].transform.localPosition;
				ItemInstances[n].transform.localPosition += vector2 * Time.deltaTime * ((!flag) ? 8f : 4f);
				ItemInstances[n].transform.localRotation *= Quaternion.Euler(0f, 57.29578f * Time.deltaTime * 0.5f, 0f);
				if (!flag && vector2.sqrMagnitude <= 0.0001f)
				{
					flag3 = true;
				}
			}
			if (HighlightedItem != null)
			{
				HighlightedLabel.GetComponent<Renderer>().enabled = true;
				HighlightedLabel.transform.localPosition = HighlightedItem.transform.localPosition - Vector3.up * 0.05f;
				Vector3 vector3 = -HighlightedLabel.transform.localPosition;
				vector3.Normalize();
				HighlightedLabel.transform.localPosition += vector3 * 0.1f;
				HighlightedLabel.transform.localRotation = Quaternion.LookRotation(-HighlightedLabel.transform.localPosition, Vector3.up) * Quaternion.AngleAxis(180f, Vector3.up);
				Color color = HighlightedLabel.GetComponent<Renderer>().material.color;
				float a = Mathf.Clamp(color.a + Time.deltaTime * 2.5f, 0f, 1f);
				if (LastHighlightedItem != HighlightedItem)
				{
					a = 0f;
					int index3 = 0;
					for (int num3 = 0; num3 < ItemInstances.Count; num3++)
					{
						if (ItemInstances[num3] == HighlightedItem)
						{
							index3 = num3;
						}
					}
					HighlightedLabel.GetComponent<TextLabel>().Text = ItemTexts[index3];
					if (ItemTypes[index3] == 2)
					{
						LampSwing componentInChildren = HighlightedItem.GetComponentInChildren<LampSwing>();
						if ((bool)componentInChildren)
						{
							componentInChildren.ResetAngles(componentInChildren.maxAngle * 0.5f);
						}
					}
					for (int num4 = 0; num4 < ItemInstances.Count; num4++)
					{
						if (ItemInstances[num4] == LastHighlightedItem && ItemTypes[num4] == 2)
						{
							LampSwing componentInChildren2 = LastHighlightedItem.GetComponentInChildren<LampSwing>();
							if ((bool)componentInChildren2)
							{
								componentInChildren2.ResetAngles(componentInChildren2.maxAngle * 0.5f);
							}
						}
					}
				}
				color.a = a;
				HighlightedLabel.GetComponent<Renderer>().material.color = color;
				LastHighlightedItem = HighlightedItem;
			}
			else
			{
				Color color2 = HighlightedLabel.GetComponent<Renderer>().material.color;
				float num5 = (color2.a = Mathf.Clamp(color2.a - Time.deltaTime * 4f, 0f, 1f));
				HighlightedLabel.GetComponent<Renderer>().material.color = color2;
				if (num5 <= 0f)
				{
					HighlightedLabel.GetComponent<Renderer>().enabled = false;
				}
				for (int num6 = 0; num6 < ItemInstances.Count; num6++)
				{
					if (ItemInstances[num6] == LastHighlightedItem && ItemTypes[num6] == 2)
					{
						LampSwing componentInChildren3 = LastHighlightedItem.GetComponentInChildren<LampSwing>();
						if ((bool)componentInChildren3)
						{
							componentInChildren3.ResetAngles(componentInChildren3.maxAngle * 0.5f);
						}
					}
				}
				LastHighlightedItem = null;
			}
			if (flag3)
			{
				foreach (GameObject itemInstance in ItemInstances)
				{
					UnityEngine.Object.Destroy(itemInstance);
				}
				ItemInstances.Clear();
				ItemPositions.Clear();
				Showing = false;
				lampMaterial = null;
				if (antiDelta != null)
				{
					antiDelta.enabled = false;
				}
			}
			if ((bool)HighlightCoolDownItem)
			{
				HighlightCoolDown -= Time.deltaTime;
				if (HighlightCoolDown <= 0f)
				{
					HighlightCoolDownItem = null;
					HighlightCoolDown = 0f;
				}
			}
		}
		if (flag)
		{
			MinimapPos.Hide = true;
		}
		if (!Showing && unblockWhenClosed)
		{
			Unblock();
			unblockWhenClosed = false;
		}
	}

	private void OpenOptionsMenu()
	{
		StartCoroutine(OpenOptionsMenu_co());
	}

	private IEnumerator OpenOptionsMenu_co()
	{
		Block();
		yield return new WaitForSeconds(0.6f);
		GameController.Get().EnterPause();
		Unblock();
	}

	public void Reorient(bool enableAntiDelta = false)
	{
		Vector3 toDirection = Player.GetLook().forward.GroundNormalize();
		Vector3 forward = base.transform.forward;
		forward.y = 0f;
		forward.Normalize();
		base.transform.rotation = Quaternion.FromToRotation(forward, toDirection) * base.transform.rotation;
		if (antiDelta != null && enableAntiDelta)
		{
			antiDelta.enabled = true;
		}
	}

	private Vector3 GetItemPosition(int index, bool highlighted = false)
	{
		float num = currentArcAngle / (float)(ItemInstances.Count + 1);
		float num2 = (0f - currentArcAngle) / 2f;
		float angle = num2 + num * (float)(index + 1);
		Quaternion quaternion = Quaternion.AngleAxis(angle, Vector3.up);
		Vector3 vector = Vector3.forward * ((!highlighted) ? DisplayArcDistance : HighlightArcDistance);
		if (!highlighted)
		{
			vector += Vector3.up * 0.06f;
		}
		else
		{
			vector += Vector3.up * 0.16f;
		}
		vector = quaternion * vector;
		if (checkCollisions)
		{
			Vector3 vector2 = base.transform.TransformPoint(vector);
			Vector3 position = vector2;
			Vector3 normalized = (vector2 - base.transform.position).normalized;
			float num3 = 0.16f;
			float num4 = vector.magnitude + num3;
			float num5 = 0f;
			if (Physics.Raycast(base.transform.position, normalized, out var hitInfo, num4, CollisionLayerMask))
			{
				position = base.transform.position + normalized * (hitInfo.distance - num3);
				num5 = Mathf.Clamp01(1f - (hitInfo.distance / num4 - 0.5f) * 2f);
			}
			position = base.transform.InverseTransformPoint(position);
			if (num5 > 0f)
			{
				bool flag = false;
				bool flag2 = false;
				if (ItemInstances.Count % 2 == 0)
				{
					flag = index < ItemInstances.Count / 2;
					flag2 = !flag;
				}
				else
				{
					flag = index < ItemInstances.Count / 2;
					flag2 = index > ItemInstances.Count / 2;
				}
				Vector3 vector3 = ((!flag) ? Vector3.right : (-Vector3.right));
				if (flag || flag2)
				{
					vector3 *= num5 * 0.05f;
					position += vector3;
				}
			}
			return position;
		}
		return vector;
	}

	private GameObject GetHighlightedItem()
	{
		if (Physics.Raycast(LookDirection.transform.position, LookDirection.forward, out var hitInfo, DisplayArcDistance * 1.5f, LayerMask))
		{
			foreach (GameObject itemInstance in ItemInstances)
			{
				if ((itemInstance == hitInfo.collider.gameObject || (hitInfo.collider.transform.parent != null && itemInstance == hitInfo.collider.transform.parent.gameObject)) && itemInstance != HighlightCoolDownItem)
				{
					return itemInstance;
				}
			}
		}
		else if (InputExt.UsingHandControllers)
		{
			foreach (GameObject itemInstance2 in ItemInstances)
			{
				SphereCollider component = itemInstance2.GetComponent<SphereCollider>();
				if (component == null && itemInstance2.transform.parent != null)
				{
					component = itemInstance2.transform.parent.GetComponent<SphereCollider>();
				}
				if (component != null)
				{
					float sqrMagnitude = (LookDirection.transform.position - component.transform.localToWorldMatrix.MultiplyPoint(component.center)).sqrMagnitude;
					if (sqrMagnitude <= component.radius * component.radius)
					{
						return itemInstance2;
					}
				}
			}
		}
		return null;
	}

	private List<Tuple<GameObject, string, int>> BuildItemList()
	{
		List<Tuple<GameObject, string, int>> list = new List<Tuple<GameObject, string, int>>();
		for (int i = 0; i < NumItems.Length; i++)
		{
			Collectable.EItemType eItemType = (Collectable.EItemType)i;
			if (eItemType == Collectable.EItemType.Lamp)
			{
				if (!InputExt.UsingHandControllers)
				{
					string descriptionText = Player.GetTorchFuel().GetDescriptionText();
					list.Add(new Tuple<GameObject, string, int>(ItemPrefabs[i], descriptionText, i));
				}
			}
			else if (NumItems[i] > 0)
			{
				string text = ItemLabels[i];
				if (NumItems[i] == 1)
				{
					text += "_1";
				}
				string item = string.Format(Translate.Get(text), NumItems[i]);
				list.Add(new Tuple<GameObject, string, int>(ItemPrefabs[i], item, i));
			}
		}
		if (optionsItemPrefab != null && (InputExt.Using3DOFController || InputExt.UsingHandControllers))
		{
			string item2 = Translate.Get(optionsItemLabel);
			list.Add(new Tuple<GameObject, string, int>(optionsItemPrefab, item2, -1));
		}
		return list;
	}

	public void AddItem(Collectable.EItemType eType, int iPicked = 1)
	{
		NumItems[(int)eType] += iPicked;
	}

	public bool ConsumeItem(Collectable.EItemType eType, int iToUse = 1)
	{
		if (NumItems[(int)eType] >= iToUse)
		{
			NumItems[(int)eType] -= iToUse;
			return true;
		}
		return false;
	}

	public int GetNumItems(Collectable.EItemType eType)
	{
		return NumItems[(int)eType];
	}

	public void UseItem(Collectable.EItemType eType, bool block = true)
	{
		switch (eType)
		{
		case Collectable.EItemType.Oil:
			if (NumItems[(int)eType] > 0)
			{
				NumItems[(int)eType]--;
				UseOil(block);
			}
			break;
		case Collectable.EItemType.Note:
			if (NumItems[(int)eType] > 0)
			{
				NumItems[(int)eType]--;
				UseNote(block);
			}
			break;
		case Collectable.EItemType.Lockpick:
			if (NumItems[(int)eType] > 0 && (InputExt.Using3DOFController || InputExt.UsingHandControllers) && Unlockable.UseLockpick())
			{
				NumItems[(int)eType]--;
			}
			break;
		case Collectable.EItemType.Lamp:
			if (InputExt.Using3DOFController || InputExt.UsingHandControllers)
			{
				UseLamp(block);
			}
			break;
		case Collectable.EItemType.Potion:
		case Collectable.EItemType.Coin:
			break;
		}
	}

	public void Block()
	{
		blocked++;
		if (antiDelta != null)
		{
			antiDelta.enabled = true;
		}
	}

	public void Unblock()
	{
		blocked--;
		if (antiDelta != null)
		{
			antiDelta.enabled = false;
		}
	}

	public bool IsBlocked()
	{
		return blocked > 0;
	}

	private void UseOil(bool block = true)
	{
		GameObject.FindWithTag(Tags.PlayerTorch).GetComponent<TorchFuel>().AddFuel();
		if (block)
		{
			unblockWhenClosed = true;
			Block();
		}
	}

	private void UseNote(bool block = true)
	{
		GameObject.FindWithTag(Tags.PlayerNotes).GetComponent<PlayerNotes>().ShowNote();
		if (block)
		{
			unblockWhenClosed = true;
			Block();
		}
	}

	private void UseLamp(bool block = true)
	{
		GameObject.FindWithTag(Tags.PlayerTorch).GetComponent<TorchFuel>().ToggleLight();
		if (block)
		{
			unblockWhenClosed = true;
			Block();
		}
	}

	public bool HasMetaItems()
	{
		for (int i = 6; i < NumItems.Length; i++)
		{
			if (NumItems[i] > 0)
			{
				return true;
			}
		}
		return false;
	}

	public GameObject GetItemPrefab(Collectable.EItemType itemType)
	{
		return ItemPrefabs[(int)itemType];
	}
}
public class InventoryHandProxy : FSMComponent<InventoryHandProxy.States>
{
	public enum States
	{
		Carried,
		Release,
		UseDisappear
	}

	public Collectable.EItemType itemType;

	private PlayerHand hand;

	private Transform handTransform;

	private Vector3 targetScale;

	private Vector3 targetPosDelta;

	private LayerMask layerMask;

	private bool isInReceptor;

	private Collider[] colliderBuffer = new Collider[4];

	private InventoryHandReceptor targetReceptor;

	private void Start()
	{
		hand = Player.GetActionHand();
		handTransform = Player.GetActionHandTransform();
		hand.IsVisible = false;
		layerMask = LayerMaskExtensions.Create("PlayerHandReceptor");
		base.transform.parent = Player.Get().transform;
		Init(States.Carried);
	}

	private void Carried_Enter()
	{
		if (Config.General().tutorials)
		{
			if (itemType == Collectable.EItemType.Oil && !Tutorial.HasBeenShownBefore("TUTO_PROXY_TOUCH_OIL", add: true))
			{
				Tutorial.Get().ShowTextForTime(Translate.Get("TUTO_PROXY_TOUCH_OIL"), 5f);
			}
			else if (itemType == Collectable.EItemType.Lockpick && Unlockable.waitingForProxyTutorial != null)
			{
				Unlockable.waitingForProxyTutorial.ShowProxyLockpickTutorial();
			}
		}
	}

	private void Carried_Update()
	{
		if (base.transform.parent != handTransform)
		{
			Vector3 vector = handTransform.position + targetPosDelta;
			base.transform.position = Interpolate.ApproachExp(base.transform.position, vector, Time.deltaTime * 20f);
			if ((base.transform.position - vector).sqrMagnitude <= 0.0004f)
			{
				base.transform.parent = handTransform;
			}
		}
		base.transform.localScale = Interpolate.ApproachExp(base.transform.localScale, targetScale * ((!isInReceptor) ? 1f : 0.9f), Time.deltaTime * 10f);
		int num = Physics.OverlapSphereNonAlloc(base.transform.position, 0.05f, colliderBuffer, layerMask, QueryTriggerInteraction.Collide);
		InventoryHandReceptor inventoryHandReceptor = null;
		for (int i = 0; i < num; i++)
		{
			InventoryHandReceptor component = colliderBuffer[i].GetComponent<InventoryHandReceptor>();
			if (component != null && component.acceptedItemType == itemType)
			{
				inventoryHandReceptor = component;
				if (!isInReceptor)
				{
					isInReceptor = true;
				}
				hand.PlayPositionalHaptic(colliderBuffer[i].transform.position, (colliderBuffer[i] as SphereCollider).radius, 0.2f, 0.4f, 0.05f, 0.15f);
				break;
			}
		}
		if (inventoryHandReceptor == null)
		{
			isInReceptor = false;
		}
		if (InputExt.GetButtonUp(InputExt.Button.Action))
		{
			hand.IsVisible = true;
			Player.GetInventory().Unblock();
			if (isInReceptor)
			{
				inventoryHandReceptor.UseItem(this);
				targetReceptor = inventoryHandReceptor;
				base.State = States.UseDisappear;
			}
			else
			{
				base.State = States.Release;
			}
		}
	}

	private void Release_Enter()
	{
		base.transform.parent = Player.Get().transform;
	}

	private void Release_Update()
	{
		Vector3 vector = Player.GetLook().position - Vector3.up * 0.5f;
		Vector3 vector2 = vector - base.transform.position;
		if (vector2.sqrMagnitude <= 0.01f)
		{
			UnityEngine.Object.Destroy(base.gameObject);
			base.enabled = false;
		}
		else
		{
			float num = vector2.magnitude / 2f;
			num = 1f / num;
			base.transform.position = base.transform.position + vector2.normalized * num * Time.deltaTime * 1f;
		}
	}

	private void UseDisappear_Enter()
	{
		base.transform.parent = null;
	}

	private void UseDisappear_Update()
	{
		Vector3 position = targetReceptor.transform.position;
		Vector3 vector = position - base.transform.position;
		if (vector.sqrMagnitude <= 0.01f)
		{
			UnityEngine.Object.Destroy(base.gameObject);
			base.enabled = false;
		}
		else
		{
			float num = vector.magnitude / 2f;
			num = 1f / num;
			base.transform.position = base.transform.position + vector.normalized * num * Time.deltaTime * 1f;
		}
		base.transform.localScale = Interpolate.ApproachExp(base.transform.localScale, Vector3.zero, Time.deltaTime);
	}

	public static InventoryHandProxy Create(GameObject inventoryItem, Collectable.EItemType itemType, float scaleFactor, Vector3 posDelta)
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(inventoryItem, null);
		gameObject.transform.position = inventoryItem.transform.position;
		gameObject.transform.rotation = inventoryItem.transform.rotation;
		InventoryHandProxy inventoryHandProxy = gameObject.AddComponent<InventoryHandProxy>();
		inventoryHandProxy.itemType = itemType;
		inventoryHandProxy.targetScale = inventoryItem.transform.localScale * scaleFactor;
		inventoryHandProxy.targetPosDelta = posDelta;
		inventoryItem.SetActive(value: false);
		return inventoryHandProxy;
	}
}
public class InventoryHandReceptor : MonoBehaviour
{
	public Collectable.EItemType acceptedItemType;

	public AudioClip hapticsClip;

	public void UseItem(InventoryHandProxy handProxy)
	{
		if (handProxy.itemType != acceptedItemType)
		{
			return;
		}
		switch (acceptedItemType)
		{
		case Collectable.EItemType.Oil:
			Player.GetInventory().UseItem(acceptedItemType, block: false);
			break;
		case Collectable.EItemType.Lockpick:
			if (Player.GetInventory().ConsumeItem(acceptedItemType))
			{
				GameObject gameObject2 = base.gameObject;
				if (base.transform.parent != null)
				{
					gameObject2 = base.transform.parent.gameObject;
				}
				gameObject2.SendMessage("OnUseHandLockpick", handProxy.gameObject, SendMessageOptions.DontRequireReceiver);
			}
			break;
		case Collectable.EItemType.Meta01:
		{
			GameObject gameObject = base.gameObject;
			if (base.transform.parent != null)
			{
				gameObject = base.transform.parent.gameObject;
			}
			gameObject.SendMessage("Unlock");
			break;
		}
		}
	}
}
[RequireComponent(typeof(HingeJoint))]
public class LampAnchorFix : TimeIndependentBehaviour
{
	private HingeJoint joint;

	private void Start()
	{
		joint = GetComponent<HingeJoint>();
	}

	private new void Update()
	{
		base.Update();
		Transform transform = joint.connectedBody.transform;
		Vector3 position = transform.position;
		Vector3 vector = transform.TransformVector(joint.connectedAnchor);
		position += vector;
		position -= joint.anchor;
		base.transform.position = position;
		if (GameController.Get().Paused)
		{
			float y = transform.rotation.eulerAngles.y;
			Vector3 eulerAngles = base.transform.rotation.eulerAngles;
			base.transform.rotation = Quaternion.Euler(eulerAngles.x, y, eulerAngles.z);
		}
	}
}
public class LampHandHandle : MonoBehaviour
{
	private void Update()
	{
		float y = Quaternion.LookRotation(base.transform.parent.forward, Vector3.up).eulerAngles.y;
		base.transform.rotation = Quaternion.Euler(0f, y, 0f);
	}
}
[RequireComponent(typeof(HingeJoint))]
public class LampHandWalkSwing : TimeIndependentBehaviour
{
	public float period = 0.8f;

	public float velocity = 10f;

	public float force = 1f;

	public float walkSpeedThreshold = 0.2f;

	public float runSpeedThreshold = 0.2f;

	public float periodRun = 0.8f;

	public float velocityRun = 10f;

	public float forceRun = 1f;

	private HingeJoint joint;

	private Vector3 lastSpeed;

	private Vector3 lastPosition;

	private float timer;

	private void Start()
	{
		joint = GetComponent<HingeJoint>();
		lastPosition = Player.Get().transform.position;
	}

	private new void Update()
	{
		base.Update();
		Vector3 position = Player.Get().transform.position;
		float num = (position - lastPosition).magnitudeGround() / base.deltaTime;
		if (num < walkSpeedThreshold)
		{
			joint.useMotor = false;
			timer = 0f;
		}
		else
		{
			bool flag = num >= runSpeedThreshold;
			if (flag)
			{
				timer = Mathf.Clamp(timer, 0f - periodRun, periodRun);
			}
			bool flag2 = false;
			if (timer >= 0f)
			{
				timer -= Time.deltaTime;
				if (timer < 0f)
				{
					flag2 = true;
				}
			}
			else
			{
				timer += Time.deltaTime;
				if (timer > 0f)
				{
					flag2 = true;
				}
			}
			if (flag2)
			{
				JointMotor motor = joint.motor;
				motor.freeSpin = true;
				motor.targetVelocity = ((!(timer > 0f)) ? (-1f) : 1f) * ((!flag) ? velocity : velocityRun);
				motor.force = ((!flag) ? force : forceRun);
				joint.motor = motor;
				joint.useMotor = true;
				timer = ((!(timer > 0f)) ? (-1f) : 1f);
				timer *= ((!flag) ? period : periodRun);
			}
		}
		lastPosition = position;
	}
}
public class LampSwing : MonoBehaviour
{
	private float progress;

	private bool moveUp = true;

	public float speed = 1f;

	private int fastMode;

	public float energyFactor = 0.5f;

	public float maxAngle = 15f;

	private float curMaxAngle;

	private Quaternion rotDown;

	private Quaternion rotUp;

	private void Start()
	{
		curMaxAngle = maxAngle;
		RecomputeAngles();
	}

	private void Update()
	{
		progress += ((!moveUp) ? (-1f) : 1f) * speed * ((fastMode <= 0) ? 1f : 1.5f) * Time.deltaTime;
		if (progress >= 1f && moveUp)
		{
			curMaxAngle *= energyFactor;
			RecomputeAngles(recomputeUp: false);
			moveUp = false;
			if (fastMode > 0)
			{
				fastMode--;
			}
		}
		else if (progress <= 0f && !moveUp)
		{
			curMaxAngle *= energyFactor;
			RecomputeAngles(recomputeUp: true, recomputeDown: false);
			moveUp = true;
			if (fastMode > 0)
			{
				fastMode--;
			}
		}
		progress = Mathf.Clamp(progress, 0f, 1f);
		float t = Interpolate.EaseInOut(progress);
		base.transform.localRotation = Quaternion.Slerp(rotDown, rotUp, t);
	}

	public void ResetAngles(float newMaxAngle = 15f)
	{
		curMaxAngle = Mathf.Max(curMaxAngle, newMaxAngle / energyFactor);
		fastMode = 2;
	}

	private void RecomputeAngles(bool recomputeUp = true, bool recomputeDown = true)
	{
		if (recomputeUp)
		{
			rotUp = Quaternion.AngleAxis(curMaxAngle, Vector3.right);
		}
		if (recomputeDown)
		{
			rotDown = Quaternion.AngleAxis(0f - curMaxAngle, Vector3.right);
		}
	}
}
public class RandomMaterials : MonoBehaviour
{
	public Renderer[] renderers;

	public Material[] materials;

	private void Start()
	{
		Material material = RandomExt.Choice(materials);
		Renderer[] array = renderers;
		foreach (Renderer renderer in array)
		{
			renderer.material = material;
		}
	}
}
public class Jukebox : MonoBehaviour
{
	[Serializable]
	public class Mood
	{
		[Serializable]
		public class Song
		{
			public AudioClip clip;

			public float baseVolume = 1f;

			public bool loop;
		}

		public string name;

		public float volume = 1f;

		public float silenceFreq;

		public float silenceMinTime = 5f;

		public float silenceMaxTime = 20f;

		public float timeoutMin = 4f;

		public float timeoutMax = 9f;

		public bool canFirstBeSilence = true;

		public Song[] songs;

		private int lastSong = -1;

		public Song ChooseSong(bool canChooseSilence = true)
		{
			if (canChooseSilence && lastSong != -1 && UnityEngine.Random.value < silenceFreq)
			{
				lastSong = -1;
				return null;
			}
			int num;
			do
			{
				num = UnityEngine.Random.Range(0, songs.Length);
			}
			while (num == lastSong && songs.Length > 1);
			lastSong = num;
			return songs[num];
		}

		public Song GetCurrentSong()
		{
			if (lastSong < 0 || lastSong >= songs.Length)
			{
				return null;
			}
			return songs[lastSong];
		}

		public void SetSilence()
		{
			lastSong = -1;
		}
	}

	public Mood[] moods;

	public AudioSource channelExit;

	public AudioSource channelEnter;

	public AudioSource screechSound;

	private float exitTime = float.MaxValue;

	private float enterTime = float.MaxValue;

	public float volume = 1f;

	private Mood baseMood;

	private Mood enterMood;

	private Mood exitMood;

	private float activeTimeout;

	public float screechTimeout;

	private string wantedMood = string.Empty;

	private static Jukebox instance;

	public static Jukebox Get()
	{
		return instance;
	}

	public static void Clear()
	{
		instance = null;
	}

	private void Awake()
	{
		instance = this;
	}

	private void Start()
	{
		Debug.Log("Jukebox - Start");
		volume = Config.Audio().musicVolume;
		SetBaseMood("ambience");
		Debug.Log("Jukebox - Start end");
	}

	public void SetBaseMood(string moodName)
	{
		if (baseMood != null && baseMood.name == moodName)
		{
			return;
		}
		Mood mood = baseMood;
		Mood mood2 = SearchMood(moodName);
		if (mood2 != null)
		{
			baseMood = mood2;
			if (mood == enterMood)
			{
				SwapMoods();
				SetEnterMood(mood2);
			}
			else if (mood == exitMood)
			{
				SetExitMood(mood2);
			}
		}
	}

	private void SetActiveMood(string moodName, bool setAsWanted = true)
	{
		if (setAsWanted)
		{
			wantedMood = moodName;
			return;
		}
		if (enterMood != null && enterMood.name != moodName)
		{
			Mood mood = SearchMood(moodName);
			if (mood == null)
			{
				return;
			}
			SwapMoods();
			SetEnterMood(mood);
		}
		activeTimeout = UnityEngine.Random.Range(enterMood.timeoutMin, enterMood.timeoutMax);
	}

	public void SetIntense()
	{
		SetActiveMood("intense");
		screechTimeout = 10f;
	}

	public void SetTension()
	{
		SetActiveMood("tension");
	}

	public void SetScreech(float screech)
	{
		screechTimeout = screech;
	}

	private void SetSilence()
	{
		Mood mood = enterMood;
		if (mood != null && mood == baseMood)
		{
			mood.SetSilence();
			enterTime = RandomExt.GaussianRange(mood.silenceMinTime, mood.silenceMaxTime);
		}
	}

	public void PlaySilence(float min, float max)
	{
		if (!(enterMood.name == "intense"))
		{
			Mood mood = enterMood;
			if (mood != null && mood == baseMood)
			{
				mood.SetSilence();
				enterTime = UnityEngine.Random.Range(min, max);
			}
		}
	}

	public void PlaySilence()
	{
		PlaySilence(5f, 20f);
	}

	private void SwapMoods()
	{
		AudioSource audioSource = channelEnter;
		channelEnter = channelExit;
		channelExit = audioSource;
		float num = enterTime;
		enterTime = exitTime;
		exitTime = num;
	}

	private void SetExitMood(Mood mood)
	{
		if (channelExit.volume <= 0.1f)
		{
			exitMood = mood;
			Mood.Song song = mood.ChooseSong(canChooseSilence: false);
			exitTime = SetSongInChannel(channelExit, song);
		}
	}

	private void SetEnterMood(Mood mood)
	{
		enterMood = mood;
		if (mood == null)
		{
			return;
		}
		Mood.Song song = mood.ChooseSong(mood.canFirstBeSilence);
		if (song != null && song.clip == channelEnter.clip && channelEnter.volume >= 0.01f)
		{
			if (!channelEnter.isPlaying)
			{
				channelEnter.Play();
			}
			return;
		}
		if (song == null)
		{
			SetSilence();
		}
		else
		{
			enterTime = SetSongInChannel(channelEnter, song);
		}
		channelEnter.volume = 0f;
	}

	private Mood SearchMood(string moodName)
	{
		Mood[] array = moods;
		foreach (Mood mood in array)
		{
			if (mood.name == moodName)
			{
				return mood;
			}
		}
		return null;
	}

	private float SetSongInChannel(AudioSource channel, Mood.Song song)
	{
		if (channel.isPlaying)
		{
			channel.Stop();
		}
		channel.clip = song.clip;
		channel.loop = song.loop;
		channel.Play();
		return song.clip.length;
	}

	private void Update()
	{
		if (wantedMood != string.Empty)
		{
			SetActiveMood(wantedMood, setAsWanted: false);
			wantedMood = string.Empty;
		}
		float b = 0f;
		float b2 = 0f;
		if (enterMood != null)
		{
			Mood.Song currentSong = enterMood.GetCurrentSong();
			b = ((currentSong == null) ? 0f : (volume * enterMood.volume * currentSong.baseVolume));
		}
		channelEnter.volume = Mathf.Lerp(channelEnter.volume, b, Time.deltaTime);
		channelExit.volume = Mathf.Lerp(channelExit.volume, b2, Time.deltaTime);
		if (enterMood != baseMood)
		{
			activeTimeout -= Time.deltaTime;
			if (activeTimeout <= 0f)
			{
				SwapMoods();
				SetEnterMood(baseMood);
			}
		}
		if (enterMood != null)
		{
			enterTime -= Time.deltaTime;
			if (enterTime <= 0f)
			{
				Mood.Song song = enterMood.ChooseSong();
				if (song == null)
				{
					SetSilence();
				}
				else
				{
					enterTime = SetSongInChannel(channelEnter, song);
				}
			}
		}
		if (channelExit.isPlaying && !channelExit.loop)
		{
			exitTime -= Time.deltaTime;
			if (exitTime <= 0f)
			{
				Mood.Song song2 = enterMood.ChooseSong(canChooseSilence: false);
				exitTime = SetSongInChannel(channelExit, song2);
			}
		}
		if (screechTimeout > 0f || screechSound.isPlaying)
		{
			if (screechTimeout > 0f && !screechSound.isPlaying)
			{
				screechSound.Play();
			}
			screechTimeout -= Time.deltaTime;
			float b3 = ((!(screechTimeout <= 0f)) ? 1f : 0f);
			screechSound.volume = Mathf.Lerp(screechSound.volume, b3, Time.deltaTime);
			if (screechSound.volume <= 0.01f && screechTimeout <= 0f)
			{
				screechSound.Stop();
			}
		}
	}
}
public class LevelOptions : ScriptableObject
{
	[Serializable]
	public class AmbientOptions
	{
		[Range(0f, 5f)]
		public float weight = 1f;

		public AmbientSelector ambientDefault = new AmbientSelector();

		public AmbientSelector ambientRoom = new AmbientSelector();

		public AmbientSelector ambientLarge = new AmbientSelector("defaultFar");

		public AmbientSelector ambientHub = new AmbientSelector("defaultHub");

		public AmbientOptions()
		{
			weight = 1f;
			ambientDefault = new AmbientSelector();
			ambientRoom = new AmbientSelector();
			ambientLarge = new AmbientSelector("defaultFar");
			ambientHub = new AmbientSelector("defaultHub");
		}
	}

	[Serializable]
	public class StyleOptions
	{
		[Range(0f, 5f)]
		public float weight = 1f;

		public MapStyleSelectorList roomSmall;

		public MapStyleSelectorList roomMedium;

		public MapStyleSelectorList roomLarge;

		public MapStyleSelectorList roomHub;

		public MapStyleSelectorList corridorNarrow;

		public MapStyleSelectorList corridorLarge;

		public StyleOptions()
		{
			weight = 1f;
		}
	}

	public string tag = "dungeon";

	public MapBuilder.GeneratorType generatorType;

	public int serializeID;

	public bool isDemo;

	public bool isRandomMode;

	public AmbientOptions[] ambientOptions;

	public StyleOptions[] styleOptions;

	public GameObject[] doorPrefabs;

	public GameObject exitPrefab;

	public GameObject exitCollectablePrefab;

	public float collectableSpawnFactor = 1f;

	public string playerNotesGroup = "01";

	public bool ghosts = true;

	public bool ghostVisions;

	public bool ghostCanStretch;

	public float ghostsMinDelay;

	public float ghostsMaxDelay;

	public bool shadowWatchers = true;

	public float shadowWatchersMinDelay;

	public float shadowWatchersMaxDelay;

	public bool shadowChasers;

	public bool shadowChasersVisions;

	public float shadowChasersMinDelay;

	public float shadowChasersMaxDelay;

	public int maxProwlers = 2;

	public float prowlersMinDelay;

	public float prowlersMaxDelay;

	public int maxLightEaters = 3;

	public float lightEatersMinDelay;

	public float lightEatersMaxDelay;

	public bool spawnNextToPlayer;

	public bool gargoyles = true;

	public int maxFloaters = 2;

	public float floatersMinDelay;

	public float floatersMaxDelay;

	public bool safeMap;

	public string[] startTexts;

	public bool maskNone = true;

	public bool maskSmall;

	public bool maskMedium;

	public bool maskOShaped;

	public bool maskCross;

	public bool maskFortress;

	public bool maskTShaped;

	public bool maskUShaped;

	public string[] seeds;

	public AmbientOptions GetAmbientOptions()
	{
		if (ambientOptions.Length > 1)
		{
			List<Pair<AmbientOptions, float>> list = new List<Pair<AmbientOptions, float>>();
			for (int i = 0; i < ambientOptions.Length; i++)
			{
				list.Add(new Pair<AmbientOptions, float>(ambientOptions[i], ambientOptions[i].weight));
			}
			return RandomExt.WeightedChoice(list);
		}
		if (ambientOptions.Length == 1)
		{
			return ambientOptions[0];
		}
		return null;
	}

	public static LevelOptions GetMetaLevelOptions(int metaMapIdx = 1)
	{
		string path = "LevelOptions/meta_" + metaMapIdx.ToString("D2");
		return Resources.Load<LevelOptions>(path);
	}

	public bool IsMetaMap()
	{
		return generatorType != MapBuilder.GeneratorType.Default;
	}

	public static LevelOptions GetByName(string loName)
	{
		string path = "LevelOptions/" + loName;
		return Resources.Load<LevelOptions>(path);
	}

	public string GetStartText()
	{
		if (startTexts == null || startTexts.Length == 0)
		{
			return string.Empty;
		}
		return Translate.Get(RandomExt.Choice(startTexts));
	}
}
[Serializable]
public class MapStyleSelector
{
	public MapStyle style;
}
[Serializable]
public class MapStyleSelectorList
{
	public MapStyleSelector[] list;

	public bool IsValid()
	{
		return list.Length > 0;
	}

	public string GetStyle()
	{
		return RandomExt.Choice(list).style.name;
	}
}
[Serializable]
public class AmbientSelector
{
	public string ambient;

	public AmbientSelector(string def = "default")
	{
		ambient = def;
	}
}
public class LevelOptionsList : ScriptableObject
{
	public string[] levelOptions;

	public LevelOptions GetRandom()
	{
		string path = RandomExt.Choice(levelOptions);
		return Resources.Load<LevelOptions>(path);
	}

	public static LevelOptions GetRandomFromFolder(string folder)
	{
		string path = "LevelOptions/" + folder + "/_list";
		LevelOptionsList levelOptionsList = Resources.Load<LevelOptionsList>(path);
		if (levelOptionsList == null)
		{
			return null;
		}
		return levelOptionsList.GetRandom();
	}
}
public class Loader : MonoBehaviour
{
	public static string nextScene = "Intro";

	public ShaderVariantCollection shaderWarmUp;

	private void Start()
	{
		StartCoroutine(SceneLoad_co(nextScene));
	}

	private IEnumerator SceneLoad_co(string sceneName)
	{
		yield return 0;
		yield return 0;
		if (shaderWarmUp != null && !shaderWarmUp.isWarmedUp)
		{
			yield return new WaitForEndOfFrame();
			yield return new WaitForEndOfFrame();
			yield return new WaitForSeconds(2f);
			Debug.Log("Warming up shaders");
			shaderWarmUp.WarmUp();
		}
		yield return 0;
		Debug.Log("Loading: " + sceneName);
		float startTime = Time.realtimeSinceStartup;
		yield return Application.LoadLevelAsync(sceneName);
	}

	public static void LoadLevel(string levelName)
	{
		nextScene = levelName;
		Application.LoadLevel("Loading");
	}
}
public class AtlasProp : MonoBehaviour
{
	public bool noAtlas;

	public bool tiling;
}
[Serializable]
public enum CellType
{
	Rock,
	Room,
	Perimeter,
	EntranceMark,
	Door,
	Corridor,
	Blocked,
	Spawn,
	Pit,
	Shaft,
	PitShaft
}
public enum AdjacencyCode
{
	Clear = 0,
	LeftTop = 1,
	CenterTop = 2,
	RightTop = 4,
	LeftCenter = 8,
	RightCenter = 0x10,
	LeftBottom = 0x20,
	CenterBottom = 0x40,
	RightBottom = 0x80
}
public class Cell
{
	public CellType Type;

	public Room Room;

	public Door Door;

	public byte adjacency;

	public byte adjacencyPit;

	public byte adjacencyShaft;

	public byte adjacencyDoor;

	public bool Occupied;

	public bool CanFloatOver;

	public bool IsDoor;

	public AdjacencyCode IsBehindDoor;

	public AdjacencyCode IsNextToDoor;

	public bool CeilingShaft;

	public AdjacencyCode DoorSide;

	public VisibilityProbe Probe;

	public VisibilityProbe Spawn;

	public AmbientStyle Ambient;

	public float floorHeight;

	private static List<Light> lightList = new List<Light>();

	public Cell(CellType type)
	{
		Type = type;
		Room = null;
		Door = null;
		DoorSide = AdjacencyCode.Clear;
		Probe = null;
		Spawn = null;
		Occupied = true;
		Occupied = !IsClear();
		IsDoor = false;
		CanFloatOver = false;
		IsBehindDoor = AdjacencyCode.Clear;
		IsNextToDoor = AdjacencyCode.Clear;
		CeilingShaft = false;
		Ambient = null;
		floorHeight = 0f;
	}

	public void Set(CellType type)
	{
		Type = type;
		Occupied = !IsClear();
	}

	public CellType Get()
	{
		return Type;
	}

	public bool IsClear()
	{
		return Type == CellType.Room || Type == CellType.Corridor || Type == CellType.Spawn;
	}

	public bool CanWalk()
	{
		return IsClear() || Type == CellType.Door;
	}

	public bool CanTunnel()
	{
		return Type != CellType.Blocked && Type != CellType.Perimeter && Type != CellType.Pit;
	}

	public bool IsCorridor()
	{
		return IsClear() && Room == null;
	}

	public bool IsPit()
	{
		return Type == CellType.Pit;
	}

	public bool IsClearOrPit()
	{
		return IsClear() || IsPit();
	}

	public bool IsTransparent()
	{
		return !Occupied || IsClear() || IsPit();
	}

	public bool CheckAdjacency(byte adjMask)
	{
		return (adjacency & adjMask) == adjMask;
	}

	public bool CheckAdjacency(AdjacencyCode adjMask)
	{
		return (adjacency & (byte)adjMask) == (byte)adjMask;
	}

	public bool CheckAdjacencyPit(byte adjMask)
	{
		return (adjacencyPit & adjMask) == adjMask;
	}

	public bool CheckAdjacencyPit(AdjacencyCode adjMask)
	{
		return (adjacencyPit & (byte)adjMask) == (byte)adjMask;
	}

	public bool CheckAdjacencyCeiling(byte adjMask)
	{
		return ((adjacency | adjacencyShaft | adjacencyDoor) & adjMask) == adjMask;
	}

	public bool CheckAdjacencyCeiling(AdjacencyCode adjMask)
	{
		return ((adjacency | adjacencyShaft | adjacencyDoor) & (byte)adjMask) == (byte)adjMask;
	}

	public bool CheckAdjacencyClear(byte adjMask)
	{
		return (adjacency & adjMask) == 0;
	}

	public bool CheckAdjacencyClear(AdjacencyCode adjMask)
	{
		return (adjacency & (byte)adjMask) == 0;
	}

	public bool CheckAdjacencyClearPit(byte adjMask)
	{
		return (adjacencyPit & adjMask) == 0;
	}

	public bool CheckAdjacencyClearPit(AdjacencyCode adjMask)
	{
		return (adjacencyPit & (byte)adjMask) == 0;
	}

	public bool CheckAdjacencyClearCeiling(byte adjMask)
	{
		return ((adjacency | adjacencyShaft | adjacencyDoor) & adjMask) == 0;
	}

	public bool CheckAdjacencyClearCeiling(AdjacencyCode adjMask)
	{
		return ((adjacency | adjacencyShaft | adjacencyDoor) & (byte)adjMask) == 0;
	}

	public static bool CheckAdjacency(byte adjacency, byte adjMask)
	{
		return (adjacency & adjMask) == adjMask;
	}

	public static bool CheckAdjacency(byte adjacency, AdjacencyCode adjMask)
	{
		return (adjacency & (byte)adjMask) == (byte)adjMask;
	}

	public static bool CheckAdjacencyClear(byte adjacency, byte adjMask)
	{
		return (adjacency & adjMask) == 0;
	}

	public static bool CheckAdjacencyClear(byte adjacency, AdjacencyCode adjMask)
	{
		return (adjacency & (byte)adjMask) == 0;
	}

	public int GetNumAdjacentWalls()
	{
		return Utils.NumberOfSetBits(adjacency);
	}

	public int GetNumAdjacentWallsNoCorners()
	{
		int num = 0;
		num += (CheckAdjacency(AdjacencyCode.LeftCenter) ? 1 : 0);
		num += (CheckAdjacency(AdjacencyCode.RightCenter) ? 1 : 0);
		num += (CheckAdjacency(AdjacencyCode.CenterTop) ? 1 : 0);
		return num + (CheckAdjacency(AdjacencyCode.CenterBottom) ? 1 : 0);
	}

	public bool IsVisible()
	{
		if (!Probe)
		{
			return false;
		}
		return Probe.IsVisible;
	}

	public bool IsDiscovered()
	{
		if (!Probe)
		{
			return false;
		}
		return Probe.Discovered;
	}

	public bool CheckLoS(Vector3 cameraPos, int numRays = 1)
	{
		if (!Probe)
		{
			return false;
		}
		return Probe.CheckLoS(cameraPos, numRays);
	}

	public static float GetLightLevel(Point cellPos, bool addPlayerLight = false)
	{
		GetAffectingLights(cellPos, addPlayerLight);
		Color black = Color.black;
		float num = 0f;
		for (int i = 0; i < lightList.Count; i++)
		{
			Light light = lightList[i];
			float range = light.range;
			float num2 = (Map.Get().CellToWorld(cellPos) + Vector3.up * 1.5f - light.transform.position).magnitude / range;
			float num3 = 1f / (1f + 25f * num2 * num2);
			num3 *= light.intensity;
			num += num3;
			Color color = light.color * num3;
			black += color;
		}
		return black.Luminance();
	}

	public static List<Light> GetAffectingLights(Point cellPos, bool addPlayerLight = false)
	{
		lightList.Clear();
		MapChunk mapChunk = MapChunk.At(cellPos);
		for (int i = 0; i < mapChunk.lights.Count; i++)
		{
			if (mapChunk.lights[i].enabled && mapChunk.lights[i].gameObject.activeSelf)
			{
				LightFOV component = mapChunk.lights[i].GetComponent<LightFOV>();
				if ((bool)component && component.CellInFOV(cellPos))
				{
					lightList.Add(mapChunk.lights[i]);
				}
			}
		}
		for (int j = 0; j < mapChunk.linkedChunks.Count; j++)
		{
			MapChunk mapChunk2 = mapChunk.linkedChunks[j];
			for (int k = 0; k < mapChunk2.lights.Count; k++)
			{
				if (mapChunk2.lights[k].enabled && mapChunk2.lights[k].gameObject.activeSelf)
				{
					LightFOV component2 = mapChunk2.lights[k].GetComponent<LightFOV>();
					if ((bool)component2 && component2.CellInFOV(cellPos))
					{
						lightList.Add(mapChunk2.lights[k]);
					}
				}
			}
		}
		if (addPlayerLight)
		{
			GameObject gameObject = GameObject.FindWithTag(Tags.PlayerTorch);
			if ((bool)gameObject && (bool)gameObject.GetComponent<Light>() && gameObject.GetComponent<Light>().enabled)
			{
				VisibilityProbe probe = Map.Get().At(cellPos).Probe;
				if ((bool)probe && probe.IsVisible)
				{
					lightList.Add(gameObject.GetComponent<Light>());
				}
			}
		}
		return lightList;
	}
}
public class ChunkMesh
{
	public static void BuildMeshes(GameObject staticGeometryContainer)
	{
		for (int i = 0; i < MapChunk.chunkMap.Length; i++)
		{
			for (int j = 0; j < MapChunk.chunkMap[i].Length; j++)
			{
				Combine(j, i, staticGeometryContainer);
			}
		}
	}

	private static void Combine(int chunkX, int chunkY, GameObject staticGeometryContainer)
	{
		MapChunk mapChunk = MapChunk.chunkMap[chunkY][chunkX];
		Dictionary<Material, List<CombineInstance>> dictionary = new Dictionary<Material, List<CombineInstance>>();
		for (int i = 0; i < mapChunk.toCombine.Count; i++)
		{
			Renderer component = mapChunk.toCombine[i].GetComponent<Renderer>();
			if (component == null)
			{
				continue;
			}
			Material[] sharedMaterials = component.sharedMaterials;
			foreach (Material material in sharedMaterials)
			{
				if (material != null && !dictionary.ContainsKey(material))
				{
					dictionary.Add(material, new List<CombineInstance>());
				}
			}
		}
		for (int k = 0; k < mapChunk.toCombine.Count; k++)
		{
			MeshFilter meshFilter = mapChunk.toCombine[k];
			if (!(meshFilter != null) || !(meshFilter.mesh != null))
			{
				continue;
			}
			Material[] sharedMaterials2 = meshFilter.GetComponent<Renderer>().sharedMaterials;
			for (int l = 0; l < Mathf.Min(meshFilter.mesh.subMeshCount, sharedMaterials2.Length); l++)
			{
				Material material2 = sharedMaterials2[l];
				if (material2 != null)
				{
					CombineInstance item = default(CombineInstance);
					item.mesh = meshFilter.mesh;
					item.transform = meshFilter.transform.localToWorldMatrix;
					item.subMeshIndex = l;
					dictionary[material2].Add(item);
				}
			}
		}
		foreach (Material key in dictionary.Keys)
		{
			GameObject gameObject = new GameObject("_combined_" + chunkX + "_" + chunkY + "_" + key.name);
			gameObject.transform.parent = staticGeometryContainer.transform;
			gameObject.isStatic = true;
			MeshFilter meshFilter2 = gameObject.AddComponent<MeshFilter>();
			meshFilter2.mesh.CombineMeshes(dictionary[key].ToArray(), mergeSubMeshes: true, useMatrices: true);
			meshFilter2.mesh.RecalculateBounds();
			MeshRenderer meshRenderer = gameObject.GetComponent<MeshRenderer>();
			if (meshRenderer == null)
			{
				meshRenderer = gameObject.AddComponent<MeshRenderer>();
			}
			meshRenderer.material = key;
			mapChunk.AddGeometry(gameObject);
		}
		for (int m = 0; m < mapChunk.toCombine.Count; m++)
		{
			GameObject gameObject2 = mapChunk.toCombine[m].gameObject;
			UnityEngine.Object.Destroy(mapChunk.toCombine[m].GetComponent<Renderer>());
			UnityEngine.Object.Destroy(mapChunk.toCombine[m]);
			gameObject2.isStatic = true;
		}
	}

	private static void PaintColors(Mesh mesh, Texture2D hubHeatMap)
	{
		Color[] array = new Color[mesh.vertices.Length];
		for (int i = 0; i < array.Length; i++)
		{
			Vector3 vector = mesh.vertices[i];
			Vector2 vector2 = new Vector2(vector.x / 64f, 1f - (0f - vector.z) / 64f);
			Color color = new Color(1f, 1f, 1f);
			array[i] = color;
		}
		mesh.colors = array;
	}
}
public class CustomGenerator : GBGenerator
{
	protected List<Tuple<RoomTemplate, Point, int>> roomList;

	protected List<Tuple<int, int, bool>> listConnections;

	protected int startRoom;

	protected int exitRoom;

	protected string mainStyle = "dungeon";

	public CustomGenerator()
	{
		roomList = new List<Tuple<RoomTemplate, Point, int>>();
		listConnections = new List<Tuple<int, int, bool>>();
	}

	protected virtual void DefineMap()
	{
		if (1 == 0)
		{
			AddRoom("m01", 12, 8);
			AddRoom("s01", 4, 4);
			AddRoom("s04", 4, 24);
			AddRoom("s02", 20, 2);
			AddRoom("s03", 24, 10);
			AddRoom("testRoom2", 26, 18);
			AddRoom("m01", 36, 10);
			AddCorridor(0, 1);
			AddCorridor(1, 2);
			AddCorridor(3, 4);
			AddCorridor(2, 5);
			AddCorridor(5, 6, isDouble: true);
			startRoom = 5;
			exitRoom = 1;
		}
		else
		{
			AddRoom("e3s01", 2, 8);
			AddRoom("e3m01", 8, 14);
			AddRoom("e3m02", 18, 6);
			AddRoom("e3m03", 26, 6);
			AddRoom("e3l01", 32, 14);
			AddRoom("e3h01", 8, 20);
			AddRoom("e3s05", 8, 50);
			AddCorridor(0, 1);
			AddCorridor(2, 1);
			AddCorridor(2, 3);
			AddCorridor(3, 4, isDouble: true);
			AddCorridor(4, 5);
			AddCorridor(5, 6);
			startRoom = 0;
			exitRoom = 6;
		}
	}

	public virtual void AfterGeneration()
	{
	}

	public virtual void AfterBuild()
	{
	}

	protected int AddRoom(string name, int x, int y, bool isStart = false, bool isExit = false)
	{
		RoomTemplate roomTemplate = RoomTemplate.FindByName(name);
		if (roomTemplate == null)
		{
			Debug.LogError("Invalid room template: " + name);
			return -1;
		}
		int item = (isStart ? 1 : (isExit ? 2 : 0));
		roomList.Add(new Tuple<RoomTemplate, Point, int>(roomTemplate, new Point(x, y), item));
		return roomList.Count - 1;
	}

	protected void AddCorridor(int from, int to, bool isDouble = false)
	{
		listConnections.Add(new Tuple<int, int, bool>(from, to, isDouble));
	}

	protected void RemoveDoor(Point doorPos)
	{
		DoorPositions.Remove(doorPos);
		EntrancePositions.Add(doorPos);
	}

	public override Map Generate(int w, int h, Texture2D texOut, bool checkDoubleCorridors = true, bool checkRoomConnections = true)
	{
		CellMap = new Cell[Options.Height][];
		for (int i = 0; i < Options.Height; i++)
		{
			CellMap[i] = new Cell[Options.Width];
			for (int j = 0; j < Options.Width; j++)
			{
				CellMap[i][j] = new Cell(CellType.Rock);
			}
		}
		Rooms = new List<Room>();
		PropPositions = new List<RoomTemplate.PropMarker>();
		DoorPositions = new List<Point>();
		EntrancePositions = new List<Point>();
		FogPositions = new List<Point>();
		FakeDoubleEntrances = new List<Point>();
		DebugPoints = new List<Pair<Point, Color>>();
		Tags = new Manager(Options.Width, Options.Height);
		mainStyle = Options.mainTag;
		DefineMap();
		Tags.Set(MapTags.Group.Main, mainStyle, new IntRect(0, 0, w, h));
		ApplyMask();
		GenCustomRooms();
		GenerateConnections();
		Room room = Rooms[startRoom];
		Point pointInRoom = GetPointInRoom(room);
		bool flag = false;
		RoomTemplate.PropMarker propMarker;
		do
		{
			propMarker = RandomExt.Choice(PropPositions);
			flag = true;
			Room room2 = CellMap[propMarker.pos.Y][propMarker.pos.X].Room;
			flag = room2 == Rooms[exitRoom];
		}
		while (propMarker.width != 1 || propMarker.height != 1 || !flag);
		CellMap[pointInRoom.Y][pointInRoom.X].Set(CellType.Spawn);
		room.Safe = true;
		room.IsSpawnRoom = true;
		Point exitPosition = propMarker.pos.ToPoint();
		CleanMapCells();
		List<Point> list = new List<Point>();
		int[] arrItems = new int[6] { 0, 1, 1, 1, 2, 2 };
		int num = RandomExt.Choice(arrItems);
		for (int k = 0; k < num; k++)
		{
			if (list.Count <= 0)
			{
				break;
			}
			int index = UnityEngine.Random.Range(0, list.Count);
			FogPositions.Add(list[index]);
			list.RemoveAt(index);
		}
		AfterGeneration();
		Map map = new Map(Options.Width, Options.Height, CellMap, Rooms, PropPositions, DoorPositions, EntrancePositions, FogPositions, Tags);
		map.ExitPosition = exitPosition;
		map.PrintToTexture(texOut);
		return map;
	}

	private void GenCustomRooms()
	{
		for (int i = 0; i < roomList.Count; i++)
		{
			Room room = RoomTemplate.PlaceRoomTemplated(this, i, roomList[i].Item2, roomList[i].Item1);
			if (room != null)
			{
				if (roomList[i].Item3 != 0)
				{
					room.Safe = true;
				}
				if (room.Template.size == RoomTemplate.SizeType.Hub)
				{
					room.Safe = true;
				}
				Rooms.Add(room);
			}
			else
			{
				Debug.LogError("Could not create room #" + i);
			}
		}
		foreach (Room room2 in Rooms)
		{
			string[] tags = ((room2.Template.size == RoomTemplate.SizeType.Large) ? new string[2] { "room", "large" } : ((room2.Template.size == RoomTemplate.SizeType.Medium) ? new string[2] { "room", "medium" } : ((room2.Template.size == RoomTemplate.SizeType.Small) ? new string[2] { "room", "small" } : ((room2.Template.size != RoomTemplate.SizeType.Hub) ? new string[1] { "room" } : new string[2] { "room", "hub" }))));
			for (int j = room2.Start.Y; j < room2.Start.Y + room2.Size.Y; j++)
			{
				for (int k = room2.Start.X; k < room2.Start.X + room2.Size.X; k++)
				{
					Cell cell = CellMap[j][k];
					if (cell.Room == room2)
					{
						if (room2.Template.size == RoomTemplate.SizeType.Large)
						{
							cell.Ambient = AmbientManager.Get().GetStyle(Options.ambientLarge);
						}
						else if (room2.Template.size == RoomTemplate.SizeType.Hub)
						{
							cell.Ambient = AmbientManager.Get().GetStyle(Options.ambientHub);
						}
						else
						{
							cell.Ambient = AmbientManager.Get().GetStyle(Options.ambientRoom);
						}
						Tags.Set(MapTags.Group.Style, tags, new Point(k, j));
					}
				}
			}
		}
	}

	private void GenerateConnections()
	{
		List<Tuple<Point, Point, bool>> list = new List<Tuple<Point, Point, bool>>();
		for (int i = 0; i < listConnections.Count; i++)
		{
			int item = listConnections[i].Item1;
			int item2 = listConnections[i].Item2;
			Room room = Rooms[item];
			Room room2 = Rooms[item2];
			bool flag = false;
			bool isDouble = listConnections[i].Item3;
			Point doorPos = new Point(0, 0);
			if (isDouble && !GetDoubleDoorInRoom(room, out doorPos))
			{
				isDouble = false;
			}
			if (!isDouble)
			{
				doorPos = GetDoorInRoom(room, out isDouble);
			}
			int num = 0;
			while (!flag)
			{
				num++;
				Point doorPos2 = doorPos;
				if (isDouble)
				{
					flag = GetClosestDoubleDoorInRoom(room2, out doorPos2, doorPos);
					if (!flag && num > 3)
					{
						isDouble = false;
					}
				}
				else
				{
					doorPos2 = GetDoorInRoom(room2, out var _);
					flag = true;
				}
				if (flag)
				{
					list.Add(new Tuple<Point, Point, bool>(doorPos, doorPos2, isDouble));
				}
			}
		}
		int iNumDoubleCorridors = 0;
		TunnelEdges(list, out iNumDoubleCorridors, alwaysSetStyle: true);
	}

	protected void SetSeed(uint seed)
	{
		UnityEngine.Random.seed = (int)seed;
		string text = $"{seed:X}";
		GameController.Get().GetComponent<MapBuilder>().seed = text;
		Debug.Log("Forced seed to: " + text);
	}
}
public class FloorNoise
{
	public static void AddFloorNoise(Map map, GameObject[][] floorPieces, MapBuilder mapBuilder)
	{
		for (int i = 0; i < map.Height; i++)
		{
			for (int j = 0; j < map.Width; j++)
			{
				if (!(floorPieces[i][j] != null))
				{
					continue;
				}
				MapStyle style = Map.Get().Tags.GetStyle(mapBuilder.mapStyles, new Point(j, i));
				if (style.floorNoise)
				{
					MeshFilter meshFilter = floorPieces[i][j].GetComponent<MeshFilter>();
					if (!meshFilter)
					{
						meshFilter = floorPieces[i][j].GetComponentInChildren<MeshFilter>();
					}
					if ((bool)meshFilter)
					{
						AddNoise(meshFilter, map, j, i, style, mapBuilder);
					}
				}
			}
		}
	}

	public static void AddCeilingNoise(Map map, GameObject[][] ceilingPieces, MapBuilder mapBuilder)
	{
		for (int i = 0; i < map.Height; i++)
		{
			for (int j = 0; j < map.Width; j++)
			{
				if (!(ceilingPieces[i][j] != null))
				{
					continue;
				}
				MapStyle style = Map.Get().Tags.GetStyle(mapBuilder.mapStyles, new Point(j, i));
				if (!style.ceilingNoise)
				{
					continue;
				}
				MeshFilter meshFilter = ceilingPieces[i][j].GetComponent<MeshFilter>();
				if (!meshFilter)
				{
					meshFilter = ceilingPieces[i][j].GetComponentInChildren<MeshFilter>();
				}
				if ((bool)meshFilter)
				{
					AdjacencyCode adjMask = (AdjacencyCode)255;
					if (map.At(j, i).CheckAdjacencyClearCeiling(adjMask))
					{
						AddNoise(meshFilter, map, j, i, style, mapBuilder, ceiling: true);
					}
				}
			}
		}
	}

	private static void AddNoise(MeshFilter meshFilter, Map map, int xPos, int yPos, MapStyle style, MapBuilder mapBuilder, bool ceiling = false)
	{
		bool flag = false;
		bool flag2 = false;
		bool flag3 = false;
		bool flag4 = false;
		bool flag5 = false;
		bool flag6 = false;
		bool flag7 = false;
		bool flag8 = false;
		if (!ceiling)
		{
			Point point = new Point(xPos, yPos - 1);
			if (map.At(point).IsClear())
			{
				MapStyle style2 = Map.Get().Tags.GetStyle(mapBuilder.mapStyles, point);
				flag2 = !style2.floorNoise;
			}
			else if (map.At(point).IsPit())
			{
				flag2 = true;
			}
			Point point2 = new Point(xPos, yPos + 1);
			if (map.At(point2).IsClear())
			{
				MapStyle style3 = Map.Get().Tags.GetStyle(mapBuilder.mapStyles, point2);
				flag = !style3.floorNoise;
			}
			else if (map.At(point2).IsPit())
			{
				flag = true;
			}
			Point point3 = new Point(xPos - 1, yPos);
			if (map.At(point3).IsClear())
			{
				MapStyle style4 = Map.Get().Tags.GetStyle(mapBuilder.mapStyles, point3);
				flag3 = !style4.floorNoise;
			}
			else if (map.At(point3).IsPit())
			{
				flag3 = true;
			}
			Point point4 = new Point(xPos + 1, yPos);
			if (map.At(point4).IsClear())
			{
				MapStyle style5 = Map.Get().Tags.GetStyle(mapBuilder.mapStyles, point4);
				flag4 = !style5.floorNoise;
			}
			else if (map.At(point4).IsPit())
			{
				flag4 = true;
			}
			Point point5 = new Point(xPos - 1, yPos - 1);
			if (map.At(point5).IsClear())
			{
				MapStyle style6 = Map.Get().Tags.GetStyle(mapBuilder.mapStyles, point5);
				flag7 = !style6.floorNoise;
			}
			else if (map.At(point5).IsPit())
			{
				flag7 = true;
			}
			Point point6 = new Point(xPos + 1, yPos - 1);
			if (map.At(point6).IsClear())
			{
				MapStyle style7 = Map.Get().Tags.GetStyle(mapBuilder.mapStyles, point6);
				flag8 = !style7.floorNoise;
			}
			else if (map.At(point6).IsPit())
			{
				flag8 = true;
			}
			Point point7 = new Point(xPos - 1, yPos + 1);
			if (map.At(point7).IsClear())
			{
				MapStyle style8 = Map.Get().Tags.GetStyle(mapBuilder.mapStyles, point7);
				flag5 = !style8.floorNoise;
			}
			else if (map.At(point7).IsPit())
			{
				flag5 = true;
			}
			Point point8 = new Point(xPos + 1, yPos + 1);
			if (map.At(point8).IsClear())
			{
				MapStyle style9 = Map.Get().Tags.GetStyle(mapBuilder.mapStyles, point8);
				flag6 = !style9.floorNoise;
			}
			else if (map.At(point8).IsPit())
			{
				flag6 = true;
			}
		}
		if (ceiling)
		{
			AdjacencyCode adjMask = (AdjacencyCode)255;
			flag2 = !map.At(xPos, yPos - 1).CheckAdjacencyClearCeiling(adjMask);
			flag = !map.At(xPos, yPos + 1).CheckAdjacencyClearCeiling(adjMask);
			flag3 = !map.At(xPos - 1, yPos).CheckAdjacencyClearCeiling(adjMask);
			flag4 = !map.At(xPos + 1, yPos).CheckAdjacencyClearCeiling(adjMask);
			flag7 = !map.At(xPos - 1, yPos - 1).CheckAdjacencyClearCeiling(adjMask);
			flag8 = !map.At(xPos + 1, yPos - 1).CheckAdjacencyClearCeiling(adjMask);
			flag5 = !map.At(xPos - 1, yPos + 1).CheckAdjacencyClearCeiling(adjMask);
			flag6 = !map.At(xPos + 1, yPos + 1).CheckAdjacencyClearCeiling(adjMask);
		}
		bool flag9 = false;
		bool flag10 = false;
		bool flag11 = false;
		bool flag12 = false;
		bool flag13 = false;
		bool flag14 = false;
		bool flag15 = false;
		bool flag16 = false;
		if (!ceiling)
		{
			Cell cell = map.At(xPos, yPos);
			flag9 = cell.CheckAdjacency(AdjacencyCode.CenterBottom);
			flag10 = cell.CheckAdjacency(AdjacencyCode.CenterTop);
			flag11 = cell.CheckAdjacency(AdjacencyCode.LeftCenter);
			flag12 = cell.CheckAdjacency(AdjacencyCode.RightCenter);
			flag13 = cell.CheckAdjacency(AdjacencyCode.LeftBottom);
			flag14 = cell.CheckAdjacency(AdjacencyCode.RightBottom);
			flag15 = cell.CheckAdjacency(AdjacencyCode.LeftTop);
			flag16 = cell.CheckAdjacency(AdjacencyCode.RightTop);
		}
		Vector3 position = meshFilter.transform.position;
		Mesh mesh = meshFilter.mesh;
		Vector3[] vertices = mesh.vertices;
		Vector3 vector = meshFilter.transform.InverseTransformDirection(Vector3.up);
		if (ceiling)
		{
			vector = -vector;
		}
		float z = (position + new Vector3(0f, 0f, -1f) * 0.7f).z;
		float z2 = (position + new Vector3(0f, 0f, 1f) * 0.7f).z;
		float x = (position + new Vector3(-1f, 0f, 0f) * 0.7f).x;
		float x2 = (position + new Vector3(1f, 0f, 0f) * 0.7f).x;
		float num = 0f;
		for (int i = 0; i < vertices.Length; i++)
		{
			Vector3 vector2 = vertices[i];
			Vector3 vector3 = meshFilter.transform.TransformPoint(vertices[i]);
			float num2 = 0f;
			if (!ceiling)
			{
				num2 = (Mathf.Sin(vector3.x * 1f) + 1f) * 0.5f * 0.06f + (Mathf.Cos(vector3.z * 2f) + 1f) * 0.5f * 0.05f;
				num2 += (Mathf.Sin(vector3.x * 500f) + 1f) * 0.5f * 0.05f + (Mathf.Cos(vector3.z * 1000f) + 1f) * 0.5f * 0.02f;
			}
			else
			{
				num2 = Mathf.Sin(5f + vector3.x * 2f) * 0.06f + Mathf.Cos(2f + vector3.z * 1f) * 0.05f;
				num2 += Mathf.Sin(1f + vector3.x * 1000f) * 0.05f + Mathf.Cos(0.9f + vector3.z * 500f) * 0.02f;
			}
			if (flag9 && vector3.z <= z)
			{
				num2 += 0.1f;
			}
			else if (flag10 && vector3.z >= z2)
			{
				num2 += 0.1f;
			}
			else if (flag11 && vector3.x <= x)
			{
				num2 += 0.1f;
			}
			else if (flag12 && vector3.x >= x2)
			{
				num2 += 0.1f;
			}
			else if (flag13 && vector3.z <= z && vector3.x <= x)
			{
				num2 += 0.1f;
			}
			else if (flag14 && vector3.z <= z && vector3.x >= x2)
			{
				num2 += 0.1f;
			}
			else if (flag15 && vector3.z >= z2 && vector3.x <= x)
			{
				num2 += 0.1f;
			}
			else if (flag16 && vector3.z >= z2 && vector3.x >= x2)
			{
				num2 += 0.1f;
			}
			if (flag && vector3.z <= z)
			{
				num2 = 0f;
			}
			if (flag2 && vector3.z >= z2)
			{
				num2 = 0f;
			}
			if (flag3 && vector3.x <= x)
			{
				num2 = 0f;
			}
			if (flag4 && vector3.x >= x2)
			{
				num2 = 0f;
			}
			if (flag5 && vector3.z <= z && vector3.x <= x)
			{
				num2 = 0f;
			}
			if (flag6 && vector3.z <= z && vector3.x >= x2)
			{
				num2 = 0f;
			}
			if (flag7 && vector3.z >= z2 && vector3.x <= x)
			{
				num2 = 0f;
			}
			if (flag8 && vector3.z >= z2 && vector3.x >= x2)
			{
				num2 = 0f;
			}
			num += num2;
			ref Vector3 reference = ref vertices[i];
			reference = vector2 + vector * num2;
		}
		mesh.vertices = vertices;
		if (!ceiling)
		{
			map.At(xPos, yPos).floorHeight = num / (float)vertices.Length;
		}
	}

	public static bool CollapseEdge(MeshFilter meshFilter, Vector3 edge)
	{
		return false;
	}
}
public class ShadowCastFOV
{
	public static void Scan(Map map, Point sourcePos, float distance, Action<Map, Cell, Point> callback)
	{
		ExploreTile(map, map.At(sourcePos), sourcePos, callback);
		for (int i = 1; i < 9; i++)
		{
			RecursiveScan(map, sourcePos, distance, 1, i, 1f, 0f, callback);
		}
	}

	private static void RecursiveScan(Map map, Point sourcePos, float distance, int iDepth, int iOctant, float fStartSlope, float fEndSlope, Action<Map, Cell, Point> callback)
	{
		Point point = new Point(0, 0);
		Vector2 vEntityPos = new Vector2((float)sourcePos.X * map.TileSize.x + map.TileSize.x / 2f, (float)sourcePos.Y * map.TileSize.y + map.TileSize.y / 2f);
		float fMaxDistSq = distance * distance;
		Point point2 = new Point(0, 0);
		bool bInvert = false;
		Point point3 = new Point(0, 0);
		Vector2 vector = new Vector2(0f, 0f);
		Vector2 vector2 = new Vector2(0f, 0f);
		bool flag = false;
		float num = 1f;
		switch (iOctant)
		{
		case 1:
			bInvert = false;
			point2 = new Point(-1, 0);
			vector = new Vector2(-0.5f, 0.5f);
			vector2 = new Vector2(-0.5f, -0.5f);
			num = 1f;
			flag = false;
			point3 = new Point(1, 0);
			point.Y = sourcePos.Y - iDepth;
			point.X = sourcePos.X - (int)(fStartSlope * (float)iDepth);
			break;
		case 2:
			bInvert = false;
			point2 = new Point(1, 0);
			vector = new Vector2(0.5f, 0.5f);
			vector2 = new Vector2(0.5f, -0.5f);
			num = -1f;
			flag = true;
			point3 = new Point(-1, 0);
			point.Y = sourcePos.Y - iDepth;
			point.X = sourcePos.X + (int)(fStartSlope * (float)iDepth);
			break;
		case 3:
			bInvert = true;
			point2 = new Point(0, -1);
			vector = new Vector2(-0.5f, -0.5f);
			vector2 = new Vector2(0.5f, -0.5f);
			num = -1f;
			flag = true;
			point3 = new Point(0, 1);
			point.X = sourcePos.X + iDepth;
			point.Y = sourcePos.Y - (int)(fStartSlope * (float)iDepth);
			break;
		case 4:
			bInvert = true;
			point2 = new Point(0, 1);
			vector = new Vector2(-0.5f, 0.5f);
			vector2 = new Vector2(0.5f, 0.5f);
			num = 1f;
			flag = false;
			point3 = new Point(0, -1);
			point.X = sourcePos.X + iDepth;
			point.Y = sourcePos.Y + (int)(fStartSlope * (float)iDepth);
			break;
		case 5:
			bInvert = false;
			point2 = new Point(1, 0);
			vector = new Vector2(0.5f, -0.5f);
			vector2 = new Vector2(0.5f, 0.5f);
			num = 1f;
			flag = false;
			point3 = new Point(-1, 0);
			point.Y = sourcePos.Y + iDepth;
			point.X = sourcePos.X + (int)(fStartSlope * (float)iDepth);
			break;
		case 6:
			bInvert = false;
			point2 = new Point(-1, 0);
			vector = new Vector2(-0.5f, -0.5f);
			vector2 = new Vector2(-0.5f, 0.5f);
			num = -1f;
			flag = true;
			point3 = new Point(1, 0);
			point.Y = sourcePos.Y + iDepth;
			point.X = sourcePos.X - (int)(fStartSlope * (float)iDepth);
			break;
		case 7:
			bInvert = true;
			point2 = new Point(0, 1);
			vector = new Vector2(0.5f, 0.5f);
			vector2 = new Vector2(-0.5f, 0.5f);
			num = -1f;
			flag = true;
			point3 = new Point(0, -1);
			point.X = sourcePos.X - iDepth;
			point.Y = sourcePos.Y + (int)(fStartSlope * (float)iDepth);
			break;
		case 8:
			bInvert = true;
			point2 = new Point(0, -1);
			vector = new Vector2(0.5f, -0.5f);
			vector2 = new Vector2(-0.5f, -0.5f);
			num = 1f;
			flag = false;
			point3 = new Point(0, 1);
			point.X = sourcePos.X - iDepth;
			point.Y = sourcePos.Y - (int)(fStartSlope * (float)iDepth);
			break;
		}
		if (Map.Get().InRange(point))
		{
			while (num * Utils.GetSlope(point.X, point.Y, sourcePos.X, sourcePos.Y, bInvert) >= num * fEndSlope)
			{
				if (CheckTileVisible(map, point, vEntityPos, fMaxDistSq, out var _))
				{
					Cell cell = ((!map.InRange(point)) ? null : map.At(point));
					Point point4 = new Point(point.X + point2.X, point.Y + point2.Y);
					Cell cell2 = ((!map.InRange(point4)) ? null : map.At(point4));
					if (cell == null || !cell.IsTransparent())
					{
						if (cell2 != null && cell2.IsTransparent())
						{
							RecursiveScan(map, sourcePos, distance, iDepth + 1, iOctant, fStartSlope, Utils.GetSlope((float)point.X + vector.x, (float)point.Y + vector.y, sourcePos.X, sourcePos.Y, bInvert), callback);
						}
					}
					else
					{
						if (cell2 == null || !cell2.IsTransparent())
						{
							fStartSlope = Utils.GetSlope((float)point.X + vector2.x, (float)point.Y + vector2.y, sourcePos.X, sourcePos.Y, bInvert);
							fStartSlope = ((!flag) ? fStartSlope : (0f - fStartSlope));
						}
						ExploreTile(map, cell, point, callback);
					}
				}
				point.X += point3.X;
				point.Y += point3.Y;
			}
			point.X -= point3.X;
			point.Y -= point3.Y;
		}
		if (CheckTileVisible(map, point, vEntityPos, fMaxDistSq, out var _))
		{
			Cell cell3 = map.At(point);
			if (cell3.IsTransparent())
			{
				RecursiveScan(map, sourcePos, distance, iDepth + 1, iOctant, fStartSlope, fEndSlope, callback);
			}
		}
	}

	private static bool CheckTileVisible(Map map, Point tPoint, Vector2 vEntityPos, float fMaxDistSq, out float fTileDistSq)
	{
		Vector2 vector = new Vector2((float)tPoint.X * map.TileSize.x + map.TileSize.x / 2f, (float)tPoint.Y * map.TileSize.y + map.TileSize.y / 2f);
		fTileDistSq = (vector - vEntityPos).sqrMagnitude;
		return map.InRange(tPoint) && fTileDistSq <= fMaxDistSq;
	}

	public static void ExploreTile(Map map, Cell tTile, Point tPos, Action<Map, Cell, Point> callback)
	{
		callback(map, tTile, tPos);
	}
}
public class PermissiveFOV
{
	private struct Line
	{
		public int xi;

		public int yi;

		public int xf;

		public int yf;

		public Line(int xi, int yi, int xf, int yf)
		{
			this.xi = xi;
			this.yi = yi;
			this.xf = xf;
			this.yf = yf;
		}

		public int dx()
		{
			return xf - xi;
		}

		public int dy()
		{
			return yf - yi;
		}

		public bool isBelow(int x, int y)
		{
			return relativeSlope(x, y) > 0;
		}

		public bool isBelow(Point pos)
		{
			return isBelow(pos.X, pos.Y);
		}

		public bool isBelowOrCollinear(int x, int y)
		{
			return relativeSlope(x, y) >= 0;
		}

		public bool isBelowOrCollinear(Point pos)
		{
			return isBelowOrCollinear(pos.X, pos.Y);
		}

		public bool isAbove(int x, int y)
		{
			return relativeSlope(x, y) < 0;
		}

		public bool isAbove(Point pos)
		{
			return isAbove(pos.X, pos.Y);
		}

		public bool isAboveOrCollinear(int x, int y)
		{
			return relativeSlope(x, y) <= 0;
		}

		public bool isAboveOrCollinear(Point pos)
		{
			return isAboveOrCollinear(pos.X, pos.Y);
		}

		public bool isCollinear(int x, int y)
		{
			return relativeSlope(x, y) == 0;
		}

		public bool isCollinear(Point pos)
		{
			return isCollinear(pos.X, pos.Y);
		}

		public bool isCollinear(Line line)
		{
			return isCollinear(line.xi, line.yi) && isCollinear(line.xf, line.yf);
		}

		public int relativeSlope(int x, int y)
		{
			return dy() * (xf - x) - dx() * (yf - y);
		}
	}

	private class ViewBump
	{
		public int x;

		public int y;

		public ViewBump parent;

		public int refs;

		public static Pool<ViewBump> pool = new Pool<ViewBump>();

		public void Init(int x, int y, ViewBump parent)
		{
			this.x = x;
			this.y = y;
			this.parent = parent;
			refs = 0;
			if (parent != null)
			{
				parent.refs++;
			}
		}

		public ViewBump Clone()
		{
			ViewBump viewBump = pool.Get();
			viewBump.Init(x, y, parent);
			return viewBump;
		}

		public void Free()
		{
			if (parent != null)
			{
				parent.refs--;
				if (parent.refs == 0)
				{
					parent.Free();
				}
			}
			parent = null;
			pool.Free(this);
		}
	}

	private class View
	{
		public Line shallowLine;

		public Line steepLine;

		public ViewBump shallowBump;

		public ViewBump steepBump;

		public static Pool<View> pool = new Pool<View>();

		public void Init(Line shallow, Line steep)
		{
			shallowLine = shallow;
			steepLine = steep;
			shallowBump = null;
			steepBump = null;
		}

		public View Clone()
		{
			View view = pool.Get();
			view.Init(shallowLine, steepLine);
			view.shallowBump = ((shallowBump == null) ? null : shallowBump.Clone());
			view.steepBump = ((steepBump == null) ? null : steepBump.Clone());
			return view;
		}

		public void Free()
		{
			if (shallowBump != null)
			{
				shallowBump.Free();
			}
			if (steepBump != null)
			{
				steepBump.Free();
			}
			shallowBump = (steepBump = null);
			pool.Free(this);
		}
	}

	public static Action<Map, Cell, Point> callback;

	private static List<View> activeViews = new List<View>();

	public static void Scan(Map map, Point sourcePos, int radius)
	{
		sourcePos = TransformCoord(map, sourcePos);
		ExploreTile(map, sourcePos);
		int extentX = ((sourcePos.X >= radius) ? radius : sourcePos.X);
		int extentX2 = ((map.Width - sourcePos.X - 1 >= radius) ? radius : (map.Width - sourcePos.X - 1));
		int extentY = ((sourcePos.Y >= radius) ? radius : sourcePos.Y);
		int extentY2 = ((map.Height - sourcePos.Y >= radius) ? radius : (map.Height - sourcePos.Y - 1));
		CheckQuadrant(map, sourcePos, 1, 1, extentX2, extentY2);
		CheckQuadrant(map, sourcePos, 1, -1, extentX2, extentY);
		CheckQuadrant(map, sourcePos, -1, -1, extentX, extentY);
		CheckQuadrant(map, sourcePos, -1, 1, extentX, extentY2);
	}

	private static void CheckQuadrant(Map map, Point sourcePos, int deltaX, int deltaY, int extentX, int extentY)
	{
		activeViews.Clear();
		Line shallow = new Line(0, 1, extentX, 0);
		Line steep = new Line(1, 0, 0, extentY);
		View view = View.pool.Get();
		view.Init(shallow, steep);
		activeViews.Add(view);
		int num = 0;
		int num2 = extentX + extentY;
		for (int i = 1; i != num2 + 1; i++)
		{
			if (activeViews.Count <= 0)
			{
				break;
			}
			int num3 = 0;
			int num4 = i;
			num3 = ((0 <= i - extentX) ? (i - extentX) : 0);
			num4 = ((i >= extentY) ? extentY : i);
			for (int j = num3; j != num4 + 1; j++)
			{
				if (num >= activeViews.Count)
				{
					break;
				}
				int x = i - j;
				int y = j;
				VisitCoord(map, sourcePos, x, y, deltaX, deltaY, num, activeViews);
			}
		}
		for (int k = 0; k < activeViews.Count; k++)
		{
			activeViews[k].Free();
		}
		activeViews.Clear();
	}

	private static void VisitCoord(Map map, Point sourcePos, int x, int y, int deltaX, int deltaY, int viewIndex, List<View> activeViews)
	{
		Point pos = new Point(x, y + 1);
		Point pos2 = new Point(x + 1, y);
		while (viewIndex < activeViews.Count && activeViews[viewIndex].steepLine.isBelowOrCollinear(pos2))
		{
			viewIndex++;
		}
		if (viewIndex == activeViews.Count || activeViews[viewIndex].shallowLine.isAboveOrCollinear(pos))
		{
			return;
		}
		bool flag = false;
		int num = x * deltaX;
		int num2 = y * deltaY;
		Point tPos = new Point(sourcePos.X + num, sourcePos.Y + num2);
		ExploreTile(map, tPos);
		if (!CheckBlocked(map, tPos))
		{
			return;
		}
		if (activeViews[viewIndex].shallowLine.isAbove(pos2) && activeViews[viewIndex].steepLine.isBelow(pos))
		{
			activeViews[viewIndex].Free();
			activeViews.RemoveAt(viewIndex);
			return;
		}
		if (activeViews[viewIndex].shallowLine.isAbove(pos2))
		{
			AddShallowBump(pos, activeViews, viewIndex);
			CheckView(activeViews, viewIndex);
			return;
		}
		if (activeViews[viewIndex].steepLine.isBelow(pos))
		{
			AddSteepBump(pos2, activeViews, viewIndex);
			CheckView(activeViews, viewIndex);
			return;
		}
		int num3 = viewIndex;
		viewIndex++;
		int num4 = viewIndex;
		activeViews.Insert(num3, activeViews[num3].Clone());
		AddSteepBump(pos2, activeViews, num3);
		if (!CheckView(activeViews, num3))
		{
			viewIndex--;
			num4--;
		}
		AddShallowBump(pos, activeViews, num4);
		CheckView(activeViews, num4);
	}

	private static void AddShallowBump(Point pos, List<View> activeViews, int viewIndex)
	{
		activeViews[viewIndex].shallowLine.xf = pos.X;
		activeViews[viewIndex].shallowLine.yf = pos.Y;
		ViewBump viewBump = ViewBump.pool.Get();
		viewBump.Init(pos.X, pos.Y, activeViews[viewIndex].shallowBump);
		activeViews[viewIndex].shallowBump = viewBump;
		for (ViewBump viewBump2 = activeViews[viewIndex].steepBump; viewBump2 != null; viewBump2 = viewBump2.parent)
		{
			if (activeViews[viewIndex].shallowLine.isAbove(viewBump2.x, viewBump2.y))
			{
				activeViews[viewIndex].shallowLine.xi = viewBump2.x;
				activeViews[viewIndex].shallowLine.yi = viewBump2.y;
			}
		}
	}

	private static void AddSteepBump(Point pos, List<View> activeViews, int viewIndex)
	{
		activeViews[viewIndex].steepLine.xf = pos.X;
		activeViews[viewIndex].steepLine.yf = pos.Y;
		ViewBump viewBump = ViewBump.pool.Get();
		viewBump.Init(pos.X, pos.Y, activeViews[viewIndex].steepBump);
		activeViews[viewIndex].steepBump = viewBump;
		for (ViewBump viewBump2 = activeViews[viewIndex].shallowBump; viewBump2 != null; viewBump2 = viewBump2.parent)
		{
			if (activeViews[viewIndex].steepLine.isBelow(viewBump2.x, viewBump2.y))
			{
				activeViews[viewIndex].steepLine.xi = viewBump2.x;
				activeViews[viewIndex].steepLine.yi = viewBump2.y;
			}
		}
	}

	private static bool CheckView(List<View> activeViews, int viewIndex)
	{
		View view = activeViews[viewIndex];
		if (view.shallowLine.isCollinear(view.steepLine) && (view.shallowLine.isCollinear(0, 1) || view.shallowLine.isCollinear(1, 0)))
		{
			activeViews[viewIndex].Free();
			activeViews.RemoveAt(viewIndex);
			return false;
		}
		return true;
	}

	private static void ExploreTile(Map map, Point tPos)
	{
		tPos = TransformCoord(map, tPos);
		Cell arg = map.At(tPos);
		callback(map, arg, tPos);
	}

	private static bool CheckBlocked(Map map, Point tPos)
	{
		tPos = TransformCoord(map, tPos);
		Cell cell = map.At(tPos);
		return !cell.IsTransparent();
	}

	private static Point TransformCoord(Map map, Point pos)
	{
		return new Point(pos.X, map.Height - 1 - pos.Y);
	}
}
public class GBGenerator : MapGenerator
{
	public class MapOptions
	{
		public int Width;

		public int Height;

		public int RoomMin;

		public int RoomMax;

		public float PropClutter;

		public float DoorClutter;

		public int EdgeConnectivity;

		public MapStyle[] styles;

		public string mainTag;

		public string ambientDefault;

		public string ambientRoom;

		public string ambientLarge;

		public string ambientHub;

		public LevelOptions.StyleOptions styleOptions;

		public bool maskNone;

		public bool maskSmall;

		public bool maskMedium;

		public bool maskOShaped;

		public bool maskCross;

		public bool maskFortress;

		public bool maskTShaped;

		public bool maskUShaped;

		public RoomTemplate testRoom;

		public MapOptions(int width, int height)
		{
			Width = width;
			Height = height;
			RoomMin = 3;
			RoomMax = 10;
			PropClutter = 0.8f;
			DoorClutter = 0.6f;
			EdgeConnectivity = 3;
			testRoom = null;
			maskNone = true;
			maskSmall = (maskMedium = (maskOShaped = (maskCross = (maskFortress = (maskTShaped = (maskUShaped = false))))));
			mainTag = "dungeon";
			ambientDefault = "default";
			ambientRoom = "default";
			ambientLarge = "defaultFar";
			ambientHub = "defaultHub";
			styleOptions = null;
		}
	}

	private class CMask : List<Vector4>
	{
		public CMask(float fX, float fY, float fW, float fH)
		{
			Add(new Vector4(fX, fY, fW, fH));
		}

		public CMask Push(float fX, float fY, float fW, float fH)
		{
			Add(new Vector4(fX, fY, fW, fH));
			return this;
		}
	}

	public class SEdge : Tuple<int, int, float>
	{
		public SEdge(int start, int end, float fDist)
			: base(start, end, fDist)
		{
		}

		public int CompareTo(SEdge obj)
		{
			return base.Item3.CompareTo(obj.Item3);
		}
	}

	public Cell[][] CellMap;

	public List<Room> Rooms;

	public List<RoomTemplate.PropMarker> PropPositions;

	public List<Point> DoorPositions;

	public List<Point> EntrancePositions;

	public List<Point> FogPositions;

	public List<Point> FakeDoubleEntrances;

	public List<Pair<Point, Color>> DebugPoints;

	public Manager Tags;

	public MapOptions Options;

	public override Map Generate(int w, int h, Texture2D texOut, bool checkDoubleCorridors = true, bool checkRoomConnections = true)
	{
		Debug.Log("Generating new cellmap...");
		CellMap = new Cell[Options.Height][];
		for (int i = 0; i < Options.Height; i++)
		{
			CellMap[i] = new Cell[Options.Width];
			for (int j = 0; j < Options.Width; j++)
			{
				CellMap[i][j] = new Cell(CellType.Rock);
			}
		}
		Rooms = new List<Room>();
		PropPositions = new List<RoomTemplate.PropMarker>();
		DoorPositions = new List<Point>();
		EntrancePositions = new List<Point>();
		FogPositions = new List<Point>();
		FakeDoubleEntrances = new List<Point>();
		DebugPoints = new List<Pair<Point, Color>>();
		Tags = new Manager(Options.Width, Options.Height);
		Tags.Set(MapTags.Group.Main, Options.mainTag, new IntRect(0, 0, w, h));
		if (Options.styleOptions != null)
		{
			LevelOptions.StyleOptions styleOptions = Options.styleOptions;
			if (styleOptions.roomSmall.IsValid())
			{
				SetStyle(new string[3] { Options.mainTag, "room", "small" }, styleOptions.roomSmall.GetStyle());
			}
			if (styleOptions.roomMedium.IsValid())
			{
				SetStyle(new string[3] { Options.mainTag, "room", "medium" }, styleOptions.roomMedium.GetStyle());
			}
			if (styleOptions.roomLarge.IsValid())
			{
				SetStyle(new string[3] { Options.mainTag, "room", "large" }, styleOptions.roomLarge.GetStyle());
			}
			if (styleOptions.roomHub.IsValid())
			{
				SetStyle(new string[3] { Options.mainTag, "room", "hub" }, styleOptions.roomHub.GetStyle());
			}
			if (styleOptions.corridorNarrow.IsValid())
			{
				SetStyle(new string[3] { Options.mainTag, "corridor", "narrow" }, styleOptions.corridorNarrow.GetStyle());
			}
			if (styleOptions.corridorLarge.IsValid())
			{
				SetStyle(new string[3] { Options.mainTag, "corridor", "large" }, styleOptions.corridorLarge.GetStyle());
			}
		}
		ApplyMask();
		bool flag = Options.testRoom != null;
		if (!flag)
		{
			GenTemplatedRooms();
		}
		else
		{
			GenTestRoom(Options.testRoom);
		}
		int iNumDoubleCorridors = 0;
		ConnectRooms(out iNumDoubleCorridors);
		if (!flag && checkDoubleCorridors && iNumDoubleCorridors < 2)
		{
			return null;
		}
		foreach (Point fakeDoubleEntrance in FakeDoubleEntrances)
		{
			if (CellMap[fakeDoubleEntrance.Y][fakeDoubleEntrance.X].Get() != CellType.Door)
			{
				continue;
			}
			int num = 0;
			int num2 = 0;
			for (int k = fakeDoubleEntrance.Y - 1; k <= fakeDoubleEntrance.Y + 1; k++)
			{
				for (int l = fakeDoubleEntrance.X - 1; l <= fakeDoubleEntrance.X + 1; l++)
				{
					if ((l != fakeDoubleEntrance.X || k != fakeDoubleEntrance.Y) && CellMap[k][l].Get() == CellType.Door)
					{
						num++;
					}
					if ((l == fakeDoubleEntrance.X || k == fakeDoubleEntrance.Y) && (l != fakeDoubleEntrance.X || k != fakeDoubleEntrance.Y))
					{
						CellType cellType = CellMap[k][l].Get();
						if (cellType == CellType.Corridor || cellType == CellType.Room || cellType == CellType.Door)
						{
							num2++;
						}
					}
				}
			}
			if (num != 0 && (num2 < 2 || num2 >= 3))
			{
				CellMap[fakeDoubleEntrance.Y][fakeDoubleEntrance.X].Set(CellType.Perimeter);
			}
		}
		FixCorridorWraps();
		if (CheckCorridorBugs())
		{
			Debug.Log("Found continuity gaps in corridor junctions - Discarding cellmap...");
			return null;
		}
		bool flag2 = false;
		List<string> list = new List<string>();
		list.Add(Options.mainTag);
		list.Add("corridor");
		list.Add("large");
		MapStyle style = Tags.GetStyle(Options.styles, list);
		list = new List<string>();
		list.Add(Options.mainTag);
		list.Add("corridor");
		list.Add("narrow");
		MapStyle style2 = Tags.GetStyle(Options.styles, list);
		for (int m = 0; m < Options.Height; m++)
		{
			for (int n = 0; n < Options.Width; n++)
			{
				if (CellMap[m][n].Get() != CellType.Door)
				{
					continue;
				}
				bool flag3 = CellMap[m + 1][n].Get() == CellType.Door;
				if (CellMap[m][n + 1].Get() == CellType.Door)
				{
					if (CellMap[m + 1][n].IsClear() && !CellMap[m + 1][n + 1].IsClear())
					{
						CellMap[m][n + 1].Set(CellType.Perimeter);
						flag2 = true;
					}
					if (CellMap[m - 1][n].IsClear() && !CellMap[m - 1][n + 1].IsClear())
					{
						CellMap[m][n + 1].Set(CellType.Perimeter);
						flag2 = true;
					}
					if (CellMap[m + 1][n].IsClear() && CellMap[m + 1][n + 1].IsClear() && CellMap[m + 1][n + 1].Room == null && Tags.GetStyle(Options.styles, new Point(n + 1, m + 1)) == style2)
					{
						Tags.Set(MapTags.Group.Style, new string[2] { "corridor", "large" }, new Point(n, m + 1));
						Tags.Set(MapTags.Group.Style, new string[2] { "corridor", "large" }, new Point(n + 1, m + 1));
						flag2 = true;
					}
					if (CellMap[m - 1][n].IsClear() && CellMap[m - 1][n + 1].IsClear() && CellMap[m - 1][n + 1].Room == null && Tags.GetStyle(Options.styles, new Point(n + 1, m - 1)) == style2)
					{
						Tags.Set(MapTags.Group.Style, new string[2] { "corridor", "large" }, new Point(n, m - 1));
						Tags.Set(MapTags.Group.Style, new string[2] { "corridor", "large" }, new Point(n + 1, m - 1));
						flag2 = true;
					}
				}
				if (flag3)
				{
					if (CellMap[m][n + 1].IsClear() && !CellMap[m + 1][n + 1].IsClear())
					{
						CellMap[m + 1][n].Set(CellType.Perimeter);
						flag2 = true;
					}
					if (CellMap[m][n - 1].IsClear() && !CellMap[m + 1][n - 1].IsClear())
					{
						CellMap[m + 1][n].Set(CellType.Perimeter);
						flag2 = true;
					}
					if (CellMap[m][n - 1].IsClear() && CellMap[m + 1][n - 1].IsClear() && CellMap[m + 1][n - 1].Room == null && Tags.GetStyle(Options.styles, new Point(n - 1, m + 1)) == style2)
					{
						Tags.Set(MapTags.Group.Style, new string[2] { "corridor", "large" }, new Point(n - 1, m));
						Tags.Set(MapTags.Group.Style, new string[2] { "corridor", "large" }, new Point(n - 1, m + 1));
						flag2 = true;
					}
					if (CellMap[m][n + 1].IsClear() && CellMap[m + 1][n + 1].IsClear() && CellMap[m + 1][n + 1].Room == null && Tags.GetStyle(Options.styles, new Point(n + 1, m + 1)) == style2)
					{
						Tags.Set(MapTags.Group.Style, new string[2] { "corridor", "large" }, new Point(n + 1, m));
						Tags.Set(MapTags.Group.Style, new string[2] { "corridor", "large" }, new Point(n + 1, m + 1));
						flag2 = true;
					}
				}
			}
		}
		if (flag2)
		{
			FixCorridorWraps(1);
		}
		CleanMapCells();
		MarkDoorsInRooms();
		List<Point> list2 = new List<Point>();
		foreach (Room room in Rooms)
		{
			list2.Add(GetPointInRoom(room));
		}
		int[] arrItems = new int[10] { 0, 1, 1, 1, 2, 2, 2, 2, 3, 4 };
		int num3 = RandomExt.Choice(arrItems);
		if (flag)
		{
			num3 = 0;
		}
		for (int num4 = 0; num4 < num3; num4++)
		{
			if (list2.Count <= 0)
			{
				break;
			}
			int index = UnityEngine.Random.Range(0, list2.Count);
			FogPositions.Add(list2[index]);
			list2.RemoveAt(index);
		}
		MapGraph mapGraph = new MapGraph();
		mapGraph.CreateFromMap(CellMap, Options.Width, Options.Height, Rooms, EntrancePositions, DoorPositions);
		if (!mapGraph.CheckConnected())
		{
			Debug.Log("Map graph is not connected - Discarding cellmap...");
			return null;
		}
		if (checkRoomConnections)
		{
			foreach (Room room2 in Rooms)
			{
				int minConnections = room2.Template.flags.minConnections;
				if (minConnections > 1 && mapGraph.GetNumConnections(room2) < minConnections)
				{
					Debug.Log("Insufficient connections in room: " + room2.Template.name);
					return null;
				}
			}
		}
		mapGraph.ComputeDeadEndWeights();
		foreach (Room room3 in Rooms)
		{
			room3.IsDeadEnd = room3.Template.size != RoomTemplate.SizeType.Hub && mapGraph.GetDeadEndWeight(room3) >= 20f;
		}
		foreach (Room room4 in Rooms)
		{
			RoomTemplate.PlaceRoomProps(this, room4);
		}
		if (!SetSpawnAndExit(out var _, out var exitPoint))
		{
			return null;
		}
		MarkProps();
		Map map = new Map(Options.Width, Options.Height, CellMap, Rooms, PropPositions, DoorPositions, EntrancePositions, FogPositions, Tags);
		map.ExitPosition = exitPoint;
		map.graph = mapGraph;
		map.PrintToTexture(texOut);
		return map;
	}

	protected void ApplyMask()
	{
		List<Pair<CMask, int>> list = new List<Pair<CMask, int>>();
		if (Options.maskNone)
		{
			list.Add(new Pair<CMask, int>(new CMask(0f, 0f, 0f, 0f), 5));
		}
		if (Options.maskSmall)
		{
			list.Add(new Pair<CMask, int>(new CMask(0f, 0f, 1f, 0.1f).Push(0f, 0.9f, 1f, 0.1f).Push(0f, 0f, 0.1f, 1f).Push(0.9f, 0f, 0.1f, 1f), 1));
		}
		if (Options.maskMedium)
		{
			list.Add(new Pair<CMask, int>(new CMask(0f, 0f, 1f, 0.05f).Push(0f, 0.95f, 1f, 0.05f).Push(0f, 0f, 0.05f, 1f).Push(0.95f, 0f, 0.05f, 1f), 1));
		}
		if (Options.maskOShaped)
		{
			list.Add(new Pair<CMask, int>(new CMask(0.3f, 0.3f, 0.4f, 0.4f), 1));
		}
		if (Options.maskCross)
		{
			list.Add(new Pair<CMask, int>(new CMask(0f, 0f, 0.3f, 0.3f).Push(0.7f, 0f, 0.3f, 0.3f).Push(0f, 0.7f, 0.3f, 0.3f).Push(0.7f, 0.7f, 0.3f, 0.3f), 1));
		}
		if (Options.maskFortress)
		{
			list.Add(new Pair<CMask, int>(new CMask(0.375f, 0f, 0.25f, 0.25f).Push(0.375f, 0.75f, 0.25f, 0.25f).Push(0f, 0.375f, 0.25f, 0.25f).Push(0.75f, 0.375f, 0.25f, 0.25f), 1));
		}
		if (Options.maskTShaped)
		{
			list.Add(new Pair<CMask, int>(new CMask(0f, 0.5f, 0.3f, 0.5f).Push(0.7f, 0.5f, 0.3f, 0.5f), 1));
			list.Add(new Pair<CMask, int>(new CMask(0f, 0f, 0.3f, 0.5f).Push(0.7f, 0f, 0.3f, 0.5f), 1));
			list.Add(new Pair<CMask, int>(new CMask(0.5f, 0f, 0.5f, 0.3f).Push(0.5f, 0.7f, 0.5f, 0.3f), 1));
			list.Add(new Pair<CMask, int>(new CMask(0f, 0f, 0.5f, 0.3f).Push(0f, 0.7f, 0.5f, 0.3f), 1));
		}
		if (Options.maskUShaped)
		{
			list.Add(new Pair<CMask, int>(new CMask(0.3f, 0f, 0.4f, 0.6f), 1));
			list.Add(new Pair<CMask, int>(new CMask(0.3f, 0.4f, 0.4f, 0.6f), 1));
			list.Add(new Pair<CMask, int>(new CMask(0.4f, 0.3f, 0.6f, 0.4f), 1));
			list.Add(new Pair<CMask, int>(new CMask(0f, 0.3f, 0.6f, 0.4f), 1));
		}
		CMask cMask = RandomExt.WeightedChoice(list);
		foreach (Vector4 item in cMask)
		{
			IntRect blocked = new IntRect((int)(item.x * (float)Options.Width), (int)(item.y * (float)Options.Height), (int)(item.z * (float)Options.Width), (int)(item.w * (float)Options.Height));
			SetBlocked(blocked);
		}
	}

	protected bool SetBlocked(IntRect blockRect)
	{
		for (int i = blockRect.top; i < blockRect.bottom; i++)
		{
			for (int j = blockRect.left; j < blockRect.right; j++)
			{
				if (i >= 0 && i < Options.Height && j >= 0 && j < Options.Width)
				{
					CellMap[i][j].Set(CellType.Blocked);
				}
			}
		}
		return true;
	}

	private void GenTemplatedRooms()
	{
		float num = Options.Width * Options.Height;
		float num2 = Options.RoomMax * Options.RoomMax;
		float num3 = num / num2;
		int num4 = (int)num3;
		List<string> list = new List<string>();
		list.Add(Options.mainTag);
		list.Add("room");
		list.Add("hub");
		MapStyle style = Tags.GetStyle(Options.styles, list);
		List<RoomTemplate> list2 = new List<RoomTemplate>();
		for (int i = 0; i < RoomTemplate.hubTemplates.Count; i++)
		{
			RoomTemplate roomTemplate = RoomTemplate.hubTemplates[i];
			if (roomTemplate.flags.CheckStyle(style))
			{
				list2.Add(roomTemplate);
			}
		}
		if (list2.Count > 0)
		{
			RoomTemplate roomTemplate2 = RandomExt.Choice(list2);
			for (int j = 0; j < 10; j++)
			{
				int num5 = RandomExt.RandInt(1, Options.Width - 2 - roomTemplate2.width);
				int num6 = RandomExt.RandInt(1, Options.Height - 2 - roomTemplate2.height);
				if (num5 % 2 == 1)
				{
					num5++;
				}
				if (num6 % 2 == 1)
				{
					num6++;
				}
				Room room = RoomTemplate.PlaceRoomTemplated(this, Rooms.Count, new Point(num5, num6), roomTemplate2, placeProps: false);
				if (room != null)
				{
					room.Safe = true;
					Rooms.Add(room);
					AddTunnelBlockers(room);
					break;
				}
			}
		}
		list[2] = "small";
		MapStyle style2 = Tags.GetStyle(Options.styles, list);
		list[2] = "medium";
		MapStyle style3 = Tags.GetStyle(Options.styles, list);
		list[2] = "large";
		MapStyle style4 = Tags.GetStyle(Options.styles, list);
		for (int k = 0; k < num4; k++)
		{
			int num7 = RandomExt.RandInt(Options.RoomMin / 2, Options.RoomMax / 2);
			int num8 = RandomExt.RandInt(Options.RoomMin / 2, Options.RoomMax / 2);
			num7 = num7 * 2 + 1;
			num8 = num8 * 2 + 1;
			int num9 = RandomExt.RandInt(1, Options.Width - 2 - num7);
			int num10 = RandomExt.RandInt(1, Options.Height - 2 - num8);
			if (num9 % 2 == 1)
			{
				num9++;
			}
			if (num10 % 2 == 1)
			{
				num10++;
			}
			for (int l = 0; l < 10; l++)
			{
				Room room2 = RoomTemplate.PlaceRoomTemplated(this, Rooms.Count, new Point(num9, num10), style2, style3, style4, placeProps: false);
				if (room2 != null)
				{
					Rooms.Add(room2);
					break;
				}
			}
		}
		foreach (Room room3 in Rooms)
		{
			string[] tags = ((room3.Template.size == RoomTemplate.SizeType.Large) ? new string[2] { "room", "large" } : ((room3.Template.size == RoomTemplate.SizeType.Medium) ? new string[2] { "room", "medium" } : ((room3.Template.size == RoomTemplate.SizeType.Small) ? new string[2] { "room", "small" } : ((room3.Template.size != RoomTemplate.SizeType.Hub) ? new string[1] { "room" } : new string[2] { "room", "hub" }))));
			for (int m = room3.Start.Y; m < room3.Start.Y + room3.Size.Y; m++)
			{
				for (int n = room3.Start.X; n < room3.Start.X + room3.Size.X; n++)
				{
					Cell cell = CellMap[m][n];
					if (cell.Room == room3 && cell.Type != CellType.Door && cell.Type != CellType.EntranceMark && cell.Type != CellType.Perimeter)
					{
						if (room3.Template.size == RoomTemplate.SizeType.Large)
						{
							cell.Ambient = AmbientManager.Get().GetStyle(Options.ambientLarge);
						}
						else if (room3.Template.size == RoomTemplate.SizeType.Hub)
						{
							cell.Ambient = AmbientManager.Get().GetStyle(Options.ambientHub);
						}
						else
						{
							cell.Ambient = AmbientManager.Get().GetStyle(Options.ambientRoom);
						}
						Tags.Set(MapTags.Group.Style, tags, new Point(n, m));
					}
				}
			}
		}
	}

	private void GenTestRoom(RoomTemplate roomTemplate)
	{
		int num = 0;
		int num2 = 0;
		for (int i = 0; i < 10; i++)
		{
			num = (Options.Width - roomTemplate.width) / 2 - 1;
			num2 = (Options.Height - roomTemplate.height) / 2 - 1;
			if (num % 2 == 1)
			{
				num++;
			}
			if (num2 % 2 == 1)
			{
				num2++;
			}
			Room room = RoomTemplate.PlaceRoomTemplated(this, Rooms.Count, new Point(num, num2), roomTemplate, placeProps: false);
			if (room != null)
			{
				Rooms.Add(room);
				break;
			}
		}
		List<RoomTemplate> list = new List<RoomTemplate>();
		for (int j = 0; j < RoomTemplate.roomTemplates.Count; j++)
		{
			RoomTemplate roomTemplate2 = RoomTemplate.roomTemplates[j];
			if (roomTemplate2.flags.canBeSafe && roomTemplate2.size == RoomTemplate.SizeType.Small)
			{
				list.Add(roomTemplate2);
			}
		}
		Point[] array = new Point[2]
		{
			new Point(Mathf.Max(num - 8, 0), num2),
			new Point(Mathf.Max(num - 8, 0), Mathf.Min(num2 + 8, Options.Height - 4))
		};
		for (int k = 0; k < 2; k++)
		{
			int num3 = array[k].X;
			int num4 = array[k].Y;
			if (num3 % 2 == 1)
			{
				num3++;
			}
			if (num4 % 2 == 1)
			{
				num4++;
			}
			for (int l = 0; l < 30; l++)
			{
				RoomTemplate template = list[UnityEngine.Random.Range(0, list.Count)];
				Room room2 = RoomTemplate.PlaceRoomTemplated(this, Rooms.Count, new Point(num3, num4), template, placeProps: false);
				if (room2 != null)
				{
					Rooms.Add(room2);
					break;
				}
			}
		}
		foreach (Room room3 in Rooms)
		{
			string[] tags = ((room3.Template.size == RoomTemplate.SizeType.Large) ? new string[2] { "room", "large" } : ((room3.Template.size == RoomTemplate.SizeType.Medium) ? new string[2] { "room", "medium" } : ((room3.Template.size == RoomTemplate.SizeType.Small) ? new string[2] { "room", "small" } : ((room3.Template.size != RoomTemplate.SizeType.Hub) ? new string[1] { "room" } : new string[2] { "room", "hub" }))));
			for (int m = room3.Start.Y; m < room3.Start.Y + room3.Size.Y; m++)
			{
				for (int n = room3.Start.X; n < room3.Start.X + room3.Size.X; n++)
				{
					Cell cell = CellMap[m][n];
					if (cell.Room == room3)
					{
						if (room3.Template.size == RoomTemplate.SizeType.Large)
						{
							cell.Ambient = AmbientManager.Get().GetStyle(Options.ambientLarge);
						}
						else if (room3.Template.size == RoomTemplate.SizeType.Hub)
						{
							cell.Ambient = AmbientManager.Get().GetStyle(Options.ambientHub);
						}
						else
						{
							cell.Ambient = AmbientManager.Get().GetStyle(Options.ambientRoom);
						}
						Tags.Set(MapTags.Group.Style, tags, new Point(n, m));
					}
				}
			}
		}
	}

	protected void ConnectRooms(out int iNumDoubleCorridors)
	{
		iNumDoubleCorridors = 0;
		List<Room> list = new List<Room>();
		List<Room> list2 = new List<Room>();
		foreach (Room room3 in Rooms)
		{
			list2.Add(room3);
		}
		List<Tuple<Point, Point, bool>> list3 = new List<Tuple<Point, Point, bool>>();
		while (list2.Count > 0)
		{
			Room room = RandomExt.Choice(list2);
			list2.Remove(room);
			Room room2 = null;
			bool flag = list.Count == 0;
			int num = 0;
			bool isDouble;
			Point doorInRoom = GetDoorInRoom(room, out isDouble);
			while (!flag)
			{
				num++;
				room2 = RandomExt.Choice(list);
				Point doorPos = doorInRoom;
				if (isDouble)
				{
					flag = GetDoubleDoorInRoom(room2, out doorPos);
					if (!flag && num > 3)
					{
						isDouble = false;
					}
				}
				else
				{
					doorPos = GetDoorInRoom(room2, out var _);
					flag = true;
				}
				if (flag)
				{
					list3.Add(new Tuple<Point, Point, bool>(doorInRoom, doorPos, isDouble));
				}
			}
			list.Add(room);
		}
		TunnelEdges(list3, out iNumDoubleCorridors);
	}

	protected void TunnelEdges(List<Tuple<Point, Point, bool>> edgesFinal, out int iNumDoubleCorridors, bool alwaysSetStyle = false)
	{
		iNumDoubleCorridors = 0;
		Pathfinder pathfinder = new Pathfinder();
		foreach (Tuple<Point, Point, bool> item3 in edgesFinal)
		{
			Point item = item3.Item1;
			Point item2 = item3.Item2;
			if (!item3.Item3)
			{
				Tunnel(item, item2, alwaysSetStyle);
				continue;
			}
			item.X /= 2;
			item.Y /= 2;
			item2.X /= 2;
			item2.Y /= 2;
			Pathfinder.Query query = pathfinder.AddQuery(item, item2, null, TunnelCheckTraversalDouble, TunnelGetTraversalCostDouble, null, 0.5f);
			if (!pathfinder.RunAStar(query))
			{
				continue;
			}
			if (!query.IsSuccess())
			{
				pathfinder.FreeQuery(query);
				item = item3.Item1;
				item2 = item3.Item2;
				Tunnel(item, item2, alwaysSetStyle);
				continue;
			}
			query.Path.Add(item);
			query.Path.Add(item2);
			foreach (Point item4 in query.Path)
			{
				for (int i = item4.Y * 2; i <= item4.Y * 2 + 1; i++)
				{
					for (int j = item4.X * 2; j <= item4.X * 2 + 1; j++)
					{
						if (CellMap[i][j].Get() == CellType.EntranceMark || CellMap[i][j].Get() == CellType.Door)
						{
							CellMap[i][j].Set(CellType.Door);
							Tags.AddException(MapTags.Group.Style, new Point(j, i));
							Tags.Set(MapTags.Group.Style, new string[2] { "corridor", "large" }, new Point(j, i));
							FakeDoubleEntrances.Remove(new Point(j, i));
						}
						else if (CellMap[i][j].Get() != CellType.Corridor && CellMap[i][j].Get() != CellType.Door && CellMap[i][j].Get() != CellType.Pit && CellMap[i][j].Room == null)
						{
							CellMap[i][j].Set(CellType.Corridor);
							Tags.AddException(MapTags.Group.Style, new Point(j, i));
							Tags.Set(MapTags.Group.Style, new string[2] { "corridor", "large" }, new Point(j, i));
						}
						if (CellMap[i][j].Room == null)
						{
							Tags.SetVariation('A', new Point(j, i));
							Tags.Set(MapTags.Group.Style, new string[2] { "corridor", "large" }, new Point(j, i));
						}
					}
				}
			}
			pathfinder.FreeQuery(query);
			iNumDoubleCorridors++;
		}
	}

	protected void Tunnel(Point start, Point end, bool alwaysSetStyle = false)
	{
		Pathfinder pathfinder = new Pathfinder();
		Pathfinder.Query query = pathfinder.AddQuery(start, end, null, TunnelCheckTraversal, TunnelGetTraversalCost, null, 0.5f);
		if (!pathfinder.RunAStar(query))
		{
			return;
		}
		List<string> list = new List<string>();
		list.Add(Options.mainTag);
		list.Add("corridor");
		list.Add("large");
		MapStyle style = Tags.GetStyle(Options.styles, list);
		Point point = new Point(0, 0);
		if (query.Path.Count >= 2)
		{
			point = new Point(query.Path[1].X - query.Path[0].X, query.Path[1].Y - query.Path[0].Y);
		}
		int num = 0;
		int num2 = 0;
		bool flag = false;
		for (int i = 0; i < query.Path.Count; i++)
		{
			Point point2 = query.Path[i];
			Point point3 = query.Path[num2];
			Point point4 = new Point(point2.X - point3.X, point2.Y - point3.Y);
			bool flag2 = point2 == end;
			if (i == num)
			{
				point4 = point;
			}
			if (point4 != point || flag2 || CellMap[point2.Y][point2.X].Get() == CellType.Corridor)
			{
				if (flag2)
				{
					num2 = i;
					point3 = point2;
				}
				Point point5 = query.Path[num];
				MapStyle style2 = Tags.GetStyle(Options.styles, point5);
				MapBrush mapBrush = style2.ChooseCorridorBrush();
				if (point5 != point3)
				{
					List<char> list2 = null;
					try
					{
						list2 = mapBrush.Grammar.Process(num2 - num + 1);
					}
					catch (Exception)
					{
						Debug.LogError("Key not found: " + mapBrush.id + " " + style2.styleName);
					}
					for (int j = num; j <= num2; j++)
					{
						if (CellMap[point2.Y][point2.X].Room == null)
						{
							Point tile = query.Path[j];
							Tags.SetVariation(list2[j - num], tile);
						}
					}
				}
				num = num2;
			}
			if (CellMap[point2.Y][point2.X].Get() == CellType.EntranceMark)
			{
				if (!flag)
				{
					if (alwaysSetStyle || !Tags.HasStyleSet(point2) || Tags.GetStyle(Options.styles, point2) != style)
					{
						Tags.Set(MapTags.Group.Style, new string[2] { "corridor", "narrow" }, point2);
					}
					CellMap[point2.Y][point2.X].Set(CellType.Door);
					Vector3 vector = new Vector3(1.5f * (float)point2.X + 0.75f, 0f, -1.5f * (float)point2.Y - 0.75f);
					if (CellMap[point2.Y][point2.X + 1].Get() == CellType.EntranceMark && CellMap[point2.Y][point2.X + 1].Room == CellMap[point2.Y][point2.X].Room && (i < 1 || query.Path[i - 1] != new Point(point2.X + 1, point2.Y)) && (i > query.Path.Count - 2 || query.Path[i + 1] != new Point(point2.X + 1, point2.Y)))
					{
						FakeDoubleEntrances.AddIfNotInside(new Point(point2.X + 1, point2.Y));
					}
					if (CellMap[point2.Y][point2.X - 1].Get() == CellType.EntranceMark && CellMap[point2.Y][point2.X - 1].Room == CellMap[point2.Y][point2.X].Room && (i < 1 || query.Path[i - 1] != new Point(point2.X - 1, point2.Y)) && (i > query.Path.Count - 2 || query.Path[i + 1] != new Point(point2.X - 1, point2.Y)))
					{
						FakeDoubleEntrances.AddIfNotInside(new Point(point2.X - 1, point2.Y));
					}
					if (CellMap[point2.Y + 1][point2.X].Get() == CellType.EntranceMark && CellMap[point2.Y + 1][point2.X].Room == CellMap[point2.Y][point2.X].Room && (i < 1 || query.Path[i - 1] != new Point(point2.X, point2.Y + 1)) && (i > query.Path.Count - 2 || query.Path[i + 1] != new Point(point2.X, point2.Y + 1)))
					{
						FakeDoubleEntrances.AddIfNotInside(new Point(point2.X, point2.Y + 1));
					}
					if (CellMap[point2.Y - 1][point2.X].Get() == CellType.EntranceMark && CellMap[point2.Y - 1][point2.X].Room == CellMap[point2.Y][point2.X].Room && (i < 1 || query.Path[i - 1] != new Point(point2.X, point2.Y - 1)) && (i > query.Path.Count - 2 || query.Path[i + 1] != new Point(point2.X, point2.Y - 1)))
					{
						FakeDoubleEntrances.AddIfNotInside(new Point(point2.X, point2.Y - 1));
					}
					if (i == 1)
					{
						FakeDoubleEntrances.Remove(point2);
					}
				}
				if (!flag && i > 0 && i >= query.Path.Count - 2)
				{
					flag = true;
				}
			}
			else if (CellMap[point2.Y][point2.X].Get() != CellType.Corridor && CellMap[point2.Y][point2.X].Get() != CellType.Door && CellMap[point2.Y][point2.X].Get() != CellType.Pit)
			{
				CellMap[point2.Y][point2.X].Set(CellType.Corridor);
				if (CellMap[point2.Y][point2.X].Room == null)
				{
					Tags.Set(MapTags.Group.Style, new string[2] { "corridor", "narrow" }, point2);
				}
			}
			num2 = i;
			point = point4;
		}
		pathfinder.FreeQuery(query);
	}

	protected Point GetDoorInRoom(Room room, out bool isDouble)
	{
		List<CPoint> doors = room.Template.doors;
		List<CPoint> doubleDoors = room.Template.doubleDoors;
		if (doors.Count == 0 && doubleDoors.Count == 0)
		{
			Debug.LogError("Room doesn't have any doors: " + room.Template.name);
			Debug.Break();
		}
		int num = RandomExt.RandInt(0, doors.Count + doubleDoors.Count - 1);
		if (num < doors.Count)
		{
			isDouble = false;
			return doors[num].ToPoint() + room.Start;
		}
		isDouble = true;
		num -= doors.Count;
		return doubleDoors[num].ToPoint() + room.Start;
	}

	protected bool GetDoubleDoorInRoom(Room room, out Point doorPos)
	{
		List<CPoint> doors = room.Template.doors;
		List<CPoint> doubleDoors = room.Template.doubleDoors;
		if (doubleDoors.Count == 0)
		{
			doorPos = RandomExt.Choice(doors).ToPoint() + room.Start;
			return false;
		}
		doorPos = RandomExt.Choice(doubleDoors).ToPoint() + room.Start;
		return true;
	}

	protected bool GetClosestDoubleDoorInRoom(Room room, out Point doorPos, Point refPoint)
	{
		List<CPoint> doors = room.Template.doors;
		List<CPoint> doubleDoors = room.Template.doubleDoors;
		if (doubleDoors.Count == 0)
		{
			float num = float.MaxValue;
			int index = 0;
			for (int i = 0; i < doors.Count; i++)
			{
				float num2 = (doors[i].ToPoint() + room.Start - refPoint).DistanceSq();
				if (num2 < num)
				{
					num = num2;
					index = i;
				}
			}
			doorPos = doors[index].ToPoint() + room.Start;
			return false;
		}
		float num3 = float.MaxValue;
		int index2 = 0;
		for (int j = 0; j < doubleDoors.Count; j++)
		{
			float num4 = (doubleDoors[j].ToPoint() + room.Start - refPoint).DistanceSq();
			if (num4 < num3)
			{
				num3 = num4;
				index2 = j;
			}
		}
		doorPos = doubleDoors[index2].ToPoint() + room.Start;
		return true;
	}

	protected Point GetPointInRoom(Room room)
	{
		List<Point> list = new List<Point>();
		for (int i = room.Start.Y; i < room.Start.Y + room.Size.Y; i++)
		{
			for (int j = room.Start.X; j < room.Start.X + room.Size.X; j++)
			{
				Point item = new Point(j, i);
				if (item.Y > 0 && item.Y < Options.Height - 1 && item.X > 0 && item.X < Options.Width - 1 && CellMap[item.Y][item.X].IsClear() && CellMap[item.Y - 1][item.X].IsClearOrPit() && CellMap[item.Y + 1][item.X].IsClearOrPit() && CellMap[item.Y][item.X - 1].IsClearOrPit() && CellMap[item.Y][item.X + 1].IsClearOrPit())
				{
					list.Add(item);
				}
			}
		}
		if (list.Count == 0)
		{
			Debug.LogError("No hay posiciones validas en la habitacion");
			return new Point(0, 0);
		}
		return RandomExt.Choice(list);
	}

	protected Point GetCentralPointInRoom(Room room)
	{
		List<Point> list = new List<Point>();
		List<Point> list2 = new List<Point>();
		for (int i = room.Start.Y; i < room.Start.Y + room.Size.Y; i++)
		{
			for (int j = room.Start.X; j < room.Start.X + room.Size.X; j++)
			{
				Point item = new Point(j, i);
				if (item.Y <= 0 || item.Y >= Options.Height - 1 || item.X <= 0 || item.X >= Options.Width - 1 || !CellMap[item.Y][item.X].IsClear() || !CellMap[item.Y - 1][item.X].IsClearOrPit() || !CellMap[item.Y + 1][item.X].IsClearOrPit() || !CellMap[item.Y][item.X - 1].IsClearOrPit() || !CellMap[item.Y][item.X + 1].IsClearOrPit())
				{
					continue;
				}
				list.Add(item);
				int num = 0;
				for (int k = item.Y - 1; k <= item.Y + 1; k++)
				{
					if (num != 0)
					{
						break;
					}
					for (int l = item.X - 1; l <= item.X + 1; l++)
					{
						if (num != 0)
						{
							break;
						}
						if ((l != item.X || k != item.Y) && k > 0 && k < Options.Height - 1 && l > 0 && l < Options.Width - 1 && !CellMap[k][l].IsClear())
						{
							num++;
						}
					}
				}
				if (num == 0)
				{
					list2.Add(item);
				}
			}
		}
		if (list.Count == 0)
		{
			Debug.LogError("No hay posiciones validas en la habitacion");
			return new Point(0, 0);
		}
		if (list2.Count > 0)
		{
			return RandomExt.Choice(list2);
		}
		return RandomExt.Choice(list);
	}

	public float TunnelGetTraversalCost(Point from, Point end, object movementDesc)
	{
		if (from.X < 0 || from.X >= Options.Width || from.Y < 0 || from.Y >= Options.Height || end.X < 0 || end.X >= Options.Width || end.Y < 0 || end.Y >= Options.Height)
		{
			return float.MaxValue;
		}
		switch (CellMap[end.Y][end.X].Get())
		{
		case CellType.Perimeter:
			return float.MaxValue;
		case CellType.EntranceMark:
		case CellType.Door:
			return 0.5f;
		case CellType.Room:
			return 0.5f;
		case CellType.Corridor:
			return 0.3f;
		default:
			return 1.5f;
		}
	}

	public bool TunnelCheckTraversal(Point from, Point end, object movementDesc)
	{
		if (from.X <= 0 || from.X >= Options.Width - 1 || from.Y <= 0 || from.Y >= Options.Height - 1 || end.X <= 0 || end.X >= Options.Width - 1 || end.Y <= 0 || end.Y >= Options.Height - 1)
		{
			return false;
		}
		if (!CellMap[end.Y][end.X].CanTunnel())
		{
			return false;
		}
		if (from.X != end.X && from.Y != end.Y)
		{
			return false;
		}
		return true;
	}

	public float TunnelGetTraversalCostDouble(Point from, Point end, object movementDesc)
	{
		float num = 0f;
		for (int i = end.Y * 2; i <= end.Y * 2 + 1; i++)
		{
			for (int j = end.X * 2; j <= end.X * 2 + 1; j++)
			{
				num += TunnelGetTraversalCost(new Point(from.X * 2, from.Y * 2), new Point(j, i), movementDesc);
			}
		}
		return num / 4f;
	}

	public bool TunnelCheckTraversalDouble(Point from, Point end, object movementDesc)
	{
		Point point = new Point(from.X * 2, from.Y * 2);
		Point point2 = new Point(end.X * 2, end.Y * 2);
		if (point.X <= 0 || point.X + 1 >= Options.Width - 1 || point.Y <= 0 || point.Y + 1 >= Options.Height - 1 || point2.X <= 0 || point2.X + 1 >= Options.Width - 1 || point2.Y <= 0 || point2.Y + 1 >= Options.Height - 1)
		{
			return false;
		}
		if (!CellMap[point2.Y][point2.X].CanTunnel() || !CellMap[point2.Y][point2.X + 1].CanTunnel() || !CellMap[point2.Y + 1][point2.X].CanTunnel() || !CellMap[point2.Y + 1][point2.X + 1].CanTunnel())
		{
			return false;
		}
		if (from.X != end.X && from.Y != end.Y)
		{
			return false;
		}
		return true;
	}

	private void AddTunnelBlockers(Room room)
	{
		for (int i = room.Start.Y; i < room.Start.Y + room.Size.Y; i++)
		{
			for (int j = room.Start.X; j < room.Start.X + room.Size.X; j++)
			{
				if (CellMap[i][j].Type != CellType.EntranceMark)
				{
					continue;
				}
				int num = 2;
				Point point = new Point(0, 0);
				if (CellMap[i][j - 1].Type == CellType.Rock)
				{
					point.X = -1;
				}
				else if (CellMap[i][j + 1].Type == CellType.Rock)
				{
					point.X = 1;
				}
				else if (CellMap[i - 1][j].Type == CellType.Rock)
				{
					point.Y = -1;
				}
				else if (CellMap[i + 1][j].Type == CellType.Rock)
				{
					point.Y = 1;
				}
				if (point.X != 0 || point.Y != 0)
				{
					Point point2 = new Point(j, i) + point * UnityEngine.Random.Range(2, 3);
					if (point2.X > 0 && point2.X < Options.Width && point2.Y > 0 && point2.Y < Options.Height && CellMap[point2.Y][point2.X].Type == CellType.Rock)
					{
						CellMap[point2.Y][point2.X].Set(CellType.Perimeter);
					}
				}
			}
		}
	}

	protected bool SetSpawnAndExit(out Point spawnPoint, out Point exitPoint)
	{
		spawnPoint = default(Point);
		exitPoint = default(Point);
		List<Tuple<Room, Point, RoomTemplate.PropMarker>> list = new List<Tuple<Room, Point, RoomTemplate.PropMarker>>();
		for (int i = 0; i < 6; i++)
		{
			List<Room> list2 = new List<Room>();
			foreach (Room room3 in Rooms)
			{
				if (room3.Template.flags.canBeSafe && room3.Template != Options.testRoom && !room3.IsHorror && !room3.IsWellLayout)
				{
					list2.Add(room3);
				}
			}
			if (list2.Count < 2)
			{
				return false;
			}
			Room room = RandomExt.Choice(list2);
			Point centralPointInRoom = GetCentralPointInRoom(room);
			bool flag = false;
			RoomTemplate.PropMarker propMarker;
			do
			{
				propMarker = RandomExt.Choice(PropPositions);
				flag = propMarker.exitMarker != OptionFlag.No;
				if (!flag)
				{
					continue;
				}
				Room room2 = CellMap[propMarker.pos.Y][propMarker.pos.X].Room;
				if (room2 != null)
				{
					flag = room2.Template.size == RoomTemplate.SizeType.Small && room2.Template != Options.testRoom && !room2.IsWellLayout;
					if (flag)
					{
						int num = 0;
						num += ((!CellMap[propMarker.pos.Y][propMarker.pos.X - 1].IsClearOrPit()) ? 1 : 0);
						num += ((!CellMap[propMarker.pos.Y][propMarker.pos.X + 1].IsClearOrPit()) ? 1 : 0);
						num += ((!CellMap[propMarker.pos.Y - 1][propMarker.pos.X].IsClearOrPit()) ? 1 : 0);
						num += ((!CellMap[propMarker.pos.Y + 1][propMarker.pos.X].IsClearOrPit()) ? 1 : 0);
						flag = num > 0;
					}
				}
			}
			while (propMarker.width != 1 || propMarker.height != 1 || !flag);
			list.Add(new Tuple<Room, Point, RoomTemplate.PropMarker>(room, centralPointInRoom, propMarker));
		}
		int num2 = 0;
		Tuple<Room, Point, RoomTemplate.PropMarker> tuple = list[0];
		foreach (Tuple<Room, Point, RoomTemplate.PropMarker> item in list)
		{
			if (!CheckSolutionPath(item.Item2, item.Item3.pos.ToPoint(), out var iLength))
			{
				return false;
			}
			if (iLength > num2)
			{
				num2 = iLength;
				tuple = item;
			}
		}
		if (num2 < 60 && Options.testRoom == null)
		{
			return false;
		}
		CellMap[tuple.Item2.Y][tuple.Item2.X].Set(CellType.Spawn);
		tuple.Item1.Safe = true;
		tuple.Item1.IsSpawnRoom = true;
		RoomTemplate.PropMarker propMarker2 = new RoomTemplate.PropMarker(tuple.Item3.pos, tuple.Item3);
		propMarker2.exitMarker = OptionFlag.Yes;
		PropPositions.Remove(tuple.Item3);
		ProcessExitRoom(propMarker2);
		PropPositions.Add(propMarker2);
		spawnPoint = tuple.Item2;
		exitPoint = tuple.Item3.pos.ToPoint();
		return true;
	}

	protected bool CheckSolutionPath(Point start, Point end, out int iLength)
	{
		iLength = 0;
		Pathfinder pathfinder = new Pathfinder();
		Pathfinder.Query query = pathfinder.AddQuery(start, end, null, SolutionCheckTraversal, SolutionGetTraversalCost, null, 0.5f);
		if (pathfinder.RunAStar(query))
		{
			query.Path.Add(start);
			query.Path.Add(end);
			iLength = query.Path.Count;
			pathfinder.FreeQuery(query);
			return true;
		}
		return false;
	}

	protected float SolutionGetTraversalCost(Point from, Point end, object movementDesc)
	{
		if (from.X < 0 || from.X >= Options.Width || from.Y < 0 || from.Y >= Options.Height || end.X < 0 || end.X >= Options.Width || end.Y < 0 || end.Y >= Options.Height)
		{
			return float.MaxValue;
		}
		return 1f;
	}

	protected bool SolutionCheckTraversal(Point from, Point end, object movementDesc)
	{
		if (from.X <= 0 || from.X >= Options.Width - 1 || from.Y <= 0 || from.Y >= Options.Height - 1 || end.X <= 0 || end.X >= Options.Width - 1 || end.Y <= 0 || end.Y >= Options.Height - 1)
		{
			return false;
		}
		if (!CellMap[end.Y][end.X].CanWalk())
		{
			return false;
		}
		if (from.X != end.X && from.Y != end.Y)
		{
			return false;
		}
		return true;
	}

	protected void CleanMapCells()
	{
		List<string> list = new List<string>();
		list.Add(Options.mainTag);
		list.Add("corridor");
		list.Add("large");
		MapStyle style = Tags.GetStyle(Options.styles, list);
		for (int i = 0; i < Options.Height; i++)
		{
			for (int j = 0; j < Options.Width; j++)
			{
				switch (CellMap[i][j].Get())
				{
				case CellType.Perimeter:
					CellMap[i][j].Set(CellType.Rock);
					break;
				case CellType.EntranceMark:
					CellMap[i][j].Set(CellType.Rock);
					break;
				case CellType.Door:
				{
					bool flag = true;
					if (i <= 0 || i >= Options.Height - 1 || j <= 0 || j >= Options.Width - 1)
					{
						flag = false;
					}
					else if ((!CellMap[i - 1][j].IsClear() || !CellMap[i + 1][j].IsClear() || CellMap[i][j - 1].IsClear() || CellMap[i][j + 1].IsClear()) && (CellMap[i - 1][j].IsClear() || CellMap[i + 1][j].IsClear() || !CellMap[i][j - 1].IsClear() || !CellMap[i][j + 1].IsClear()))
					{
						flag = false;
					}
					if (flag)
					{
						CellMap[i][j].Set(CellType.Room);
						bool flag2 = CellMap[i + 1][j].Get() == CellType.Door;
						bool flag3 = CellMap[i][j + 1].Get() == CellType.Door;
						if (flag3)
						{
							CellMap[i][j + 1].Set(CellType.Room);
							CellMap[i][j + 1].Occupied = true;
							CellMap[i][j + 1].IsDoor = true;
						}
						else if (flag2)
						{
							CellMap[i + 1][j].Set(CellType.Room);
							CellMap[i + 1][j].Occupied = true;
							CellMap[i + 1][j].IsDoor = true;
						}
						if (UnityEngine.Random.value < Options.DoorClutter && !flag3 && !flag2)
						{
							DoorPositions.Add(new Point(j, i));
						}
						else
						{
							EntrancePositions.Add(new Point(j, i));
							if (flag3)
							{
								EntrancePositions.Add(new Point(j + 1, i));
							}
							else if (flag2)
							{
								EntrancePositions.Add(new Point(j, i + 1));
							}
						}
					}
					else
					{
						CellMap[i][j].Set(CellType.Rock);
						bool flag4 = CellMap[i + 1][j].Get() == CellType.Door;
						if (CellMap[i][j + 1].Get() == CellType.Door && Tags.GetStyle(Options.styles, new Point(j + 1, i)) == style)
						{
							Tags.AddException(MapTags.Group.Style, new Point(j + 1, i));
							Tags.Set(MapTags.Group.Style, new string[2] { "corridor", "narrow" }, new Point(j + 1, i));
						}
						if (flag4 && Tags.GetStyle(Options.styles, new Point(j, i + 1)) == style)
						{
							Tags.AddException(MapTags.Group.Style, new Point(j, i + 1));
							Tags.Set(MapTags.Group.Style, new string[2] { "corridor", "narrow" }, new Point(j, i + 1));
						}
					}
					CellMap[i][j].Occupied = true;
					CellMap[i][j].IsDoor = true;
					break;
				}
				case CellType.Corridor:
					CellMap[i][j].Set(CellType.Room);
					CellMap[i][j].Occupied = CellMap[i][j].Room == null;
					break;
				}
			}
		}
		MarkProps();
	}

	private void MarkProps()
	{
		foreach (RoomTemplate.PropMarker propPosition in PropPositions)
		{
			for (int i = 0; i < propPosition.height; i++)
			{
				for (int j = 0; j < propPosition.width; j++)
				{
					CellMap[propPosition.pos.Y + i][propPosition.pos.X + j].Occupied = true;
				}
			}
		}
	}

	private void FixCorridorWraps(int maxCycles = 2)
	{
		List<string> list = new List<string>();
		list.Add(Options.mainTag);
		list.Add("corridor");
		list.Add("large");
		MapStyle style = Tags.GetStyle(Options.styles, list);
		list = new List<string>();
		list.Add(Options.mainTag);
		list.Add("corridor");
		list.Add("narrow");
		MapStyle style2 = Tags.GetStyle(Options.styles, list);
		bool flag = false;
		for (int i = 0; i < maxCycles; i++)
		{
			if (i > 0 && !flag)
			{
				continue;
			}
			flag = false;
			for (int j = 0; j < Options.Height; j++)
			{
				for (int k = 0; k < Options.Width; k++)
				{
					if (CellMap[j][k].Get() != CellType.Corridor || CellMap[j][k].Room != null)
					{
						continue;
					}
					bool flag2 = false;
					MapStyle style3 = Tags.GetStyle(Options.styles, new Point(k, j));
					if (style3 != style)
					{
						if (CellMap[j + 1][k].Get() == CellType.Corridor && Tags.GetStyle(Options.styles, new Point(k, j + 1)) == style && (CellMap[j + 1][k + 1].IsClear() || CellMap[j][k - 1].IsClear()) && (CellMap[j + 1][k - 1].IsClear() || CellMap[j][k + 1].IsClear()))
						{
							flag2 |= CellMap[j][k - 1].Get() == CellType.Corridor || CellMap[j][k + 1].Get() == CellType.Corridor;
						}
						if (CellMap[j - 1][k].Get() == CellType.Corridor && Tags.GetStyle(Options.styles, new Point(k, j - 1)) == style && (CellMap[j - 1][k + 1].IsClear() || CellMap[j][k - 1].IsClear()) && (CellMap[j - 1][k - 1].IsClear() || CellMap[j][k + 1].IsClear()))
						{
							flag2 |= CellMap[j][k - 1].Get() == CellType.Corridor || CellMap[j][k + 1].Get() == CellType.Corridor;
						}
						if (CellMap[j][k + 1].Get() == CellType.Corridor && Tags.GetStyle(Options.styles, new Point(k + 1, j)) == style && (CellMap[j - 1][k + 1].IsClear() || CellMap[j + 1][k].IsClear()) && (CellMap[j + 1][k + 1].IsClear() || CellMap[j - 1][k].IsClear()))
						{
							flag2 |= CellMap[j - 1][k].Get() == CellType.Corridor || CellMap[j + 1][k].Get() == CellType.Corridor;
						}
						if (CellMap[j][k - 1].Get() == CellType.Corridor && Tags.GetStyle(Options.styles, new Point(k - 1, j)) == style && (CellMap[j - 1][k - 1].IsClear() || CellMap[j + 1][k].IsClear()) && (CellMap[j + 1][k - 1].IsClear() || CellMap[j - 1][k].IsClear()))
						{
							flag2 |= CellMap[j - 1][k].Get() == CellType.Corridor || CellMap[j + 1][k].Get() == CellType.Corridor;
						}
					}
					if (flag2)
					{
						Tags.AddException(MapTags.Group.Style, new Point(k, j));
						Tags.Set(MapTags.Group.Style, new string[2] { "corridor", "large" }, new Point(k, j));
						flag = true;
					}
				}
			}
		}
	}

	protected bool CheckCorridorBugs()
	{
		List<string> list = new List<string>();
		list.Add(Options.mainTag);
		list.Add("corridor");
		list.Add("large");
		MapStyle style = Tags.GetStyle(Options.styles, list);
		for (int i = 0; i < Options.Height; i++)
		{
			for (int j = 0; j < Options.Width; j++)
			{
				if (CellMap[i][j].Type == CellType.Corridor)
				{
					MapStyle style2 = Tags.GetStyle(Options.styles, new Point(j, i));
					if (style2 == style && CellMap[i - 1][j].Type == CellType.Corridor && Tags.GetStyle(Options.styles, new Point(j, i - 1)) == style && CellMap[i + 1][j].Type == CellType.Corridor && Tags.GetStyle(Options.styles, new Point(j, i + 1)) == style && CellMap[i][j - 1].Type == CellType.Corridor && Tags.GetStyle(Options.styles, new Point(j - 1, i)) == style && CellMap[i][j + 1].Type == CellType.Corridor && Tags.GetStyle(Options.styles, new Point(j + 1, i)) == style && ((CellMap[i - 1][j - 1].Type != CellType.Corridor && CellMap[i + 1][j + 1].Type != CellType.Corridor) || (CellMap[i + 1][j - 1].Type != CellType.Corridor && CellMap[i - 1][j + 1].Type != CellType.Corridor)))
					{
						return true;
					}
				}
			}
		}
		return false;
	}

	protected void MarkDoorsInRooms()
	{
		for (int i = 0; i < DoorPositions.Count; i++)
		{
			Cell cell = CellMap[DoorPositions[i].Y][DoorPositions[i].X];
			if (cell.Room != null)
			{
				cell.Room.doors.Add(DoorPositions[i]);
			}
		}
		for (int j = 0; j < EntrancePositions.Count; j++)
		{
			Cell cell2 = CellMap[EntrancePositions[j].Y][EntrancePositions[j].X];
			if (cell2.Room != null)
			{
				cell2.Room.entrances.Add(EntrancePositions[j]);
			}
		}
	}

	private void ProcessExitRoom(RoomTemplate.PropMarker newExitProp)
	{
		Point point = new Point(newExitProp.pos.X, newExitProp.pos.Y);
		Cell cell = CellMap[point.Y][point.X];
		Room room = cell.Room;
		Point point2 = point + new Point(-1, 0);
		Point point3 = point + new Point(1, 0);
		Point point4 = point + new Point(0, -1);
		Point point5 = point + new Point(0, 1);
		Cell cell2 = CellMap[point2.Y][point2.X];
		Cell cell3 = CellMap[point3.Y][point3.X];
		Cell cell4 = CellMap[point4.Y][point4.X];
		Cell cell5 = CellMap[point5.Y][point5.X];
		bool flag = cell2.IsClear();
		bool flag2 = cell3.IsClear();
		bool flag3 = cell4.IsClear();
		bool flag4 = cell5.IsClear();
		bool flag5 = cell2.IsClear() && !CheckDoorAdjacent(point2, room);
		bool flag6 = cell3.IsClear() && !CheckDoorAdjacent(point3, room);
		bool flag7 = cell4.IsClear() && !CheckDoorAdjacent(point4, room);
		bool flag8 = cell5.IsClear() && !CheckDoorAdjacent(point5, room);
		Point point6 = point;
		Point point7 = point6;
		bool flag9 = false;
		if (!cell2.IsClear() && !flag9)
		{
			if (!flag3 || !flag4)
			{
				if (!flag7 && flag8)
				{
					point6 = point5;
				}
				else if (flag7 && !flag8)
				{
					point6 = point4;
				}
			}
			point7 = point6 + new Point(1, 0);
			flag9 = point6 != point;
		}
		if (!cell3.IsClear() && !flag9)
		{
			if (!flag3 || !flag4)
			{
				if (!flag7 && flag8)
				{
					point6 = point5;
				}
				else if (flag7 && !flag8)
				{
					point6 = point4;
				}
			}
			point7 = point6 + new Point(-1, 0);
			flag9 = point6 != point;
		}
		if (!cell4.IsClear() && !flag9)
		{
			if (!flag || !flag2)
			{
				if (!flag5 && flag6)
				{
					point6 = point3;
				}
				else if (flag5 && !flag6)
				{
					point6 = point2;
				}
			}
			point7 = point6 + new Point(0, 1);
			flag9 = point6 != point;
		}
		if (!cell5.IsClear() && !flag9)
		{
			if (!flag || !flag2)
			{
				if (!flag5 && flag6)
				{
					point6 = point3;
				}
				else if (flag5 && !flag6)
				{
					point6 = point2;
				}
			}
			point7 = point6 + new Point(0, -1);
			flag9 = point6 != point;
		}
		newExitProp.pos.Set(point6);
		Tags.SetVariation('A', point6);
		for (int i = 0; i < PropPositions.Count; i++)
		{
			RoomTemplate.PropMarker propMarker = PropPositions[i];
			if (CellMap[propMarker.pos.Y][propMarker.pos.X].Room == room)
			{
				if (propMarker.pos.X <= point6.X && propMarker.pos.X + propMarker.width - 1 >= point6.X && propMarker.pos.Y <= point6.Y && propMarker.pos.Y + propMarker.height - 1 >= point6.Y)
				{
					PropPositions.RemoveAt(i);
					i--;
				}
				else if (propMarker.pos.X <= point7.X && propMarker.pos.X + propMarker.width - 1 >= point7.X && propMarker.pos.Y <= point7.Y && propMarker.pos.Y + propMarker.height - 1 >= point7.Y)
				{
					PropPositions.RemoveAt(i);
					i--;
				}
			}
		}
		RoomTemplate.PropMarker propMarker2 = new RoomTemplate.PropMarker(new CPoint(point7), newExitProp);
		propMarker2.exitMarker = OptionFlag.No;
		propMarker2.exitCollectable = OptionFlag.Yes;
		PropPositions.Add(propMarker2);
		room.IsExitRoom = true;
		room.Safe = true;
	}

	private bool CheckDoorAdjacent(Point pos, Room r)
	{
		for (int i = pos.Y - 1; i <= pos.Y + 1; i++)
		{
			for (int j = pos.X - 1; j <= pos.X + 1; j++)
			{
				CellType type = CellMap[i][j].Type;
				if (type == CellType.EntranceMark || type == CellType.Door)
				{
					return true;
				}
				for (int k = 0; k < r.doors.Count; k++)
				{
					if (r.doors[k].X == j && r.doors[k].Y == i)
					{
						return true;
					}
				}
				for (int l = 0; l < r.entrances.Count; l++)
				{
					if (r.entrances[l].X == j && r.entrances[l].Y == i)
					{
						return true;
					}
				}
			}
		}
		return false;
	}

	protected void SetStyle(string[] tags, string styleName)
	{
		Tags.SetStyle(tags, MapStyle.FindByName(Options.styles, styleName));
	}

	[Conditional("DH_DEBUG")]
	public void DrawDebugPoints()
	{
		foreach (Pair<Point, Color> debugPoint in DebugPoints)
		{
			Point first = debugPoint.First;
			DebugExt.DrawPoint(new Vector3((float)first.X * 1.5f + 0.75f, 0.5f, (float)(-first.Y) * 1.5f - 0.75f), debugPoint.Second, 0.5f, 20f);
		}
	}
}
public class LightFOV : MonoBehaviour
{
	public Light lightSource;

	public List<MapChunk> fovArea;

	private TileArea tileArea;

	private void Start()
	{
		if (lightSource == null)
		{
			lightSource = GetComponent<Light>();
		}
		if (lightSource == null)
		{
			UnityEngine.Object.Destroy(this);
			return;
		}
		fovArea = new List<MapChunk>();
		tileArea = new TileArea();
		Point sourcePos = Map.Get().WorldToCell(base.transform.position);
		ShadowCastFOV.Scan(Map.Get(), sourcePos, lightSource.range, ExploreFOVTile);
		MapChunk.At(sourcePos.X, sourcePos.Y).AddLight(lightSource);
		MapChunk.Link(fovArea);
	}

	private void ExploreFOVTile(Map map, Cell cell, Point pos)
	{
		if (Map.Get().At(pos).IsTransparent())
		{
			MapChunk chunk = MapChunk.At(pos.X, pos.Y);
			if (!fovArea.Exists((MapChunk e) => e == chunk))
			{
				fovArea.Add(chunk);
			}
			tileArea.Add(pos);
		}
		if (cell != null)
		{
			if (pos.X > 0)
			{
				ExploreFOVTile(map, null, new Point(pos.X - 1, pos.Y));
			}
			if (pos.X < map.Width - 1)
			{
				ExploreFOVTile(map, null, new Point(pos.X + 1, pos.Y));
			}
			if (pos.Y > 0)
			{
				ExploreFOVTile(map, null, new Point(pos.X, pos.Y - 1));
			}
			if (pos.Y < map.Height - 1)
			{
				ExploreFOVTile(map, null, new Point(pos.X, pos.Y + 1));
			}
		}
	}

	public bool CellInFOV(Point cellPos)
	{
		return tileArea.IsInside(cellPos);
	}

	private void OnDrawGizmosSelected()
	{
		foreach (MapChunk item in fovArea)
		{
			item.DebugRender(lightSource.color);
		}
	}
}
public class Map
{
	public int Width;

	public int Height;

	public Cell[][] CellMap;

	public List<Room> Rooms;

	public List<RoomTemplate.PropMarker> PropPositions;

	public List<Point> DoorPositions;

	public List<Point> EntrancePositions;

	public List<Point> FogPositions;

	public Vector2 TileSize;

	public Point ExitPosition;

	public Manager Tags;

	public MapStyle[] mapStyles;

	public MapGraph graph;

	public Texture2D hubHeatMap;

	private static Map instance;

	private Point[] closestTileLeftOrder = new Point[8]
	{
		new Point(-1, 0),
		new Point(0, 1),
		new Point(0, -1),
		new Point(1, 0),
		new Point(-1, -1),
		new Point(-1, 1),
		new Point(1, -1),
		new Point(1, 1)
	};

	private Point[] closestTileRightOrder = new Point[8]
	{
		new Point(1, 0),
		new Point(0, 1),
		new Point(0, -1),
		new Point(-1, 0),
		new Point(1, -1),
		new Point(1, 1),
		new Point(-1, -1),
		new Point(-1, 1)
	};

	private Point[] closestTileUpOrder = new Point[8]
	{
		new Point(0, -1),
		new Point(1, 0),
		new Point(-1, 0),
		new Point(0, 1),
		new Point(-1, -1),
		new Point(1, -1),
		new Point(-1, 1),
		new Point(1, 1)
	};

	private Point[] closestTileDownOrder = new Point[8]
	{
		new Point(0, 1),
		new Point(1, 0),
		new Point(-1, 0),
		new Point(0, -1),
		new Point(-1, 1),
		new Point(1, 1),
		new Point(-1, -1),
		new Point(1, -1)
	};

	public Map(int w, int h, Cell[][] cellMap, List<Room> rooms, List<RoomTemplate.PropMarker> propPositions, List<Point> doorPositions, List<Point> entrancePositions, List<Point> fogPositions, Manager tags)
	{
		Width = w;
		Height = h;
		CellMap = cellMap;
		Rooms = rooms;
		PropPositions = propPositions;
		DoorPositions = doorPositions;
		EntrancePositions = entrancePositions;
		FogPositions = fogPositions;
		Tags = tags;
		instance = this;
		for (int i = 0; i < Height; i++)
		{
			for (int j = 0; j < Width; j++)
			{
				Cell cell = At(j, i);
				cell.adjacency = ComputeAdjacency(new Point(j, i));
				if (cell.IsPit())
				{
					cell.adjacencyPit = ComputeAdjacency(new Point(j, i), pit: true);
				}
				else
				{
					cell.adjacencyPit = 0;
				}
				cell.adjacencyShaft = ComputeAdjacency(new Point(j, i), pit: false, shaft: true);
				cell.adjacencyDoor = ComputeAdjacency(new Point(j, i), pit: false, shaft: false, door: true);
			}
		}
	}

	public static Map Get()
	{
		return instance;
	}

	public static void Clear()
	{
		instance = null;
	}

	public Cell At(Point pos)
	{
		if (!InRange(pos))
		{
			return null;
		}
		return CellMap[pos.Y][pos.X];
	}

	public Cell At(int x, int y)
	{
		if (!InRange(x, y))
		{
			return null;
		}
		return CellMap[y][x];
	}

	public Cell At(Vector3 vWPos)
	{
		Point tilePos = WorldToCell(vWPos);
		if (!InRange(tilePos))
		{
			return null;
		}
		return CellMap[tilePos.Y][tilePos.X];
	}

	public Point WorldToCell(Vector3 vWorldPos)
	{
		return new Point((int)(vWorldPos.x / TileSize.x), (int)((0f - vWorldPos.z) / TileSize.y));
	}

	public Vector2 WorldToCellFloat(Vector3 vWorldPos)
	{
		return new Vector2(vWorldPos.x / TileSize.x, (0f - vWorldPos.z) / TileSize.y);
	}

	public Vector3 CellToWorld(int x, int y)
	{
		return new Vector3((float)x * TileSize.x + TileSize.x / 2f, 0f, (float)(-y) * TileSize.y - TileSize.y / 2f);
	}

	public Vector3 CellToWorld(Point cellPos)
	{
		return CellToWorld(cellPos.X, cellPos.Y);
	}

	public bool InRange(Point tilePos)
	{
		return InRange(tilePos.X, tilePos.Y);
	}

	public bool InRange(int x, int y)
	{
		return x >= 0 && x < Width && y >= 0 && y < Height;
	}

	public Point GetClosestWalkable(Point cellPos)
	{
		return GetClosestWalkable(CellToWorld(cellPos));
	}

	public Point GetClosestWalkable(Vector3 pos)
	{
		Point point = WorldToCell(pos);
		if (!IsBlockedToEnemy(At(point)))
		{
			return point;
		}
		Vector3 vector = (pos - CellToWorld(point)).ToGround().MajorAxis();
		Point[] array = closestTileLeftOrder;
		if (vector.x >= 1f)
		{
			array = closestTileRightOrder;
		}
		else if (vector.x <= -1f)
		{
			array = closestTileLeftOrder;
		}
		else if (vector.z >= 1f)
		{
			array = closestTileUpOrder;
		}
		else if (vector.z <= -1f)
		{
			array = closestTileDownOrder;
		}
		for (int i = 0; i < array.Length; i++)
		{
			Point point2 = point + array[i];
			if (!IsBlockedToEnemy(At(point2)))
			{
				return point2;
			}
		}
		return point;
	}

	public static bool IsBlockedToEnemy(Cell cell)
	{
		return !cell.CanWalk() || (cell.Occupied && cell.Room != null && cell.Door == null && !cell.IsDoor);
	}

	public Door GetDoorBetweenTiles(Point originPos, Point destPos)
	{
		Cell cell = At(originPos);
		Cell cell2 = At(destPos);
		if (originPos == destPos)
		{
			return null;
		}
		Door result = null;
		AdjacencyCode adjacencyCode = AdjacencyCode.Clear;
		AdjacencyCode adjacencyCode2 = AdjacencyCode.Clear;
		if (originPos.Y == destPos.Y)
		{
			if (originPos.X == destPos.X - 1)
			{
				adjacencyCode = AdjacencyCode.RightCenter;
				adjacencyCode2 = AdjacencyCode.LeftCenter;
			}
			else if (originPos.X == destPos.X + 1)
			{
				adjacencyCode = AdjacencyCode.LeftCenter;
				adjacencyCode2 = AdjacencyCode.RightCenter;
			}
		}
		else if (originPos.X == destPos.X)
		{
			if (originPos.Y == destPos.Y - 1)
			{
				adjacencyCode = AdjacencyCode.CenterBottom;
				adjacencyCode2 = AdjacencyCode.CenterTop;
			}
			else if (originPos.Y == destPos.Y + 1)
			{
				adjacencyCode = AdjacencyCode.CenterTop;
				adjacencyCode2 = AdjacencyCode.CenterBottom;
			}
		}
		if ((bool)cell.Door && cell.DoorSide == adjacencyCode)
		{
			result = cell.Door;
		}
		else if ((bool)cell2.Door && cell2.DoorSide == adjacencyCode2)
		{
			result = cell2.Door;
		}
		return result;
	}

	public bool IsReservedDoor(Point pos)
	{
		if (pos.X < 2 || pos.X >= Width - 2 || pos.Y < 2 || pos.Y >= Height - 2)
		{
			return false;
		}
		Cell cell = Get().At(pos);
		if (cell.IsClear() && cell.Room != null)
		{
			bool isDoor = cell.IsDoor;
			isDoor |= Get().At(pos.X - 1, pos.Y).IsDoor;
			isDoor |= Get().At(pos.X + 1, pos.Y).IsDoor;
			isDoor |= Get().At(pos.X, pos.Y - 1).IsDoor;
			isDoor |= Get().At(pos.X, pos.Y + 1).IsDoor;
			isDoor |= Get().At(pos.X - 2, pos.Y).IsDoor && !Get().At(pos.X - 1, pos.Y - 1).IsClear() && !Get().At(pos.X - 1, pos.Y + 1).IsClear();
			isDoor |= Get().At(pos.X + 2, pos.Y).IsDoor && !Get().At(pos.X + 1, pos.Y - 1).IsClear() && !Get().At(pos.X + 1, pos.Y + 1).IsClear();
			isDoor |= Get().At(pos.X, pos.Y - 2).IsDoor && !Get().At(pos.X - 1, pos.Y - 1).IsClear() && !Get().At(pos.X + 1, pos.Y - 1).IsClear();
			return isDoor | (Get().At(pos.X, pos.Y + 2).IsDoor && !Get().At(pos.X - 1, pos.Y + 1).IsClear() && !Get().At(pos.X + 1, pos.Y + 1).IsClear());
		}
		return false;
	}

	public static Point WalkDirection(Point origin, AdjacencyCode dir, int steps = 1)
	{
		Point result = origin;
		for (int i = 0; i < steps; i++)
		{
			switch (dir)
			{
			case AdjacencyCode.LeftTop:
				result += new Point(-1, -1);
				break;
			case AdjacencyCode.CenterTop:
				result += new Point(0, -1);
				break;
			case AdjacencyCode.RightTop:
				result += new Point(1, -1);
				break;
			case AdjacencyCode.LeftCenter:
				result += new Point(-1, 0);
				break;
			case AdjacencyCode.RightCenter:
				result += new Point(1, 0);
				break;
			case AdjacencyCode.LeftBottom:
				result += new Point(-1, 1);
				break;
			case AdjacencyCode.CenterBottom:
				result += new Point(0, 1);
				break;
			case AdjacencyCode.RightBottom:
				result += new Point(1, 1);
				break;
			}
		}
		return result;
	}

	private byte ComputeAdjacency(Point cellPos, bool pit = false, bool shaft = false, bool door = false)
	{
		int num = 0;
		int num2 = 1;
		bool ceilingShaft = At(cellPos).CeilingShaft;
		bool isDoor = At(cellPos).IsDoor;
		for (int i = cellPos.Y - 1; i <= cellPos.Y + 1; i++)
		{
			for (int j = cellPos.X - 1; j <= cellPos.X + 1; j++)
			{
				if (j == cellPos.X && i == cellPos.Y)
				{
					continue;
				}
				if (j >= 0 && j < Width && i >= 0 && i < Height)
				{
					Cell cell = At(j, i);
					if (!pit && !shaft && !door && !cell.IsClearOrPit())
					{
						num |= num2;
					}
					if (pit && !cell.IsPit())
					{
						num |= num2;
					}
					if (shaft && ceilingShaft != cell.CeilingShaft)
					{
						num |= num2;
					}
					if (door)
					{
						bool isDoor2 = cell.IsDoor;
						if (isDoor != isDoor2)
						{
							num |= num2;
						}
					}
				}
				else
				{
					num |= num2;
				}
				num2 *= 2;
			}
		}
		return (byte)num;
	}

	public float FloorHeight(Vector3 position)
	{
		Point point = WorldToCell(position);
		if (point.X > 0 && point.Y > 0 && point.X < Width - 1 && point.Y < Height - 1)
		{
			return 0f;
		}
		return 0f;
	}

	public void PrintToTexture(Texture2D texOut)
	{
		for (int i = 0; i < texOut.height; i++)
		{
			for (int j = 0; j < texOut.width; j++)
			{
				texOut.SetPixel(j, i, Color.black);
			}
		}
		int num = (texOut.width - Width) / 2;
		int num2 = (texOut.height - Height) / 2;
		for (int k = 0; k < Height; k++)
		{
			int y = num2 + (Height - 1 - k);
			for (int l = 0; l < Width; l++)
			{
				switch (CellMap[k][l].Get())
				{
				case CellType.Rock:
					texOut.SetPixel(num + l, y, Color.black);
					break;
				case CellType.Room:
					texOut.SetPixel(num + l, y, Color.white);
					break;
				case CellType.Perimeter:
					texOut.SetPixel(num + l, y, Color.blue);
					break;
				case CellType.Door:
					texOut.SetPixel(num + l, y, Color.white);
					break;
				case CellType.EntranceMark:
					texOut.SetPixel(num + l, y, Color.white);
					break;
				case CellType.Corridor:
					texOut.SetPixel(num + l, y, Color.white);
					break;
				case CellType.Blocked:
					texOut.SetPixel(num + l, y, Color.black);
					break;
				case CellType.Spawn:
					texOut.SetPixel(num + l, y, Color.white);
					break;
				default:
					texOut.SetPixel(num + l, y, Color.red);
					break;
				}
			}
		}
		texOut.Apply();
	}

	public void PrintHUBHeatmap()
	{
		hubHeatMap = new Texture2D(Width, Height, TextureFormat.RGBA32, mipmap: false);
		hubHeatMap.wrapMode = TextureWrapMode.Clamp;
		for (int i = 0; i < hubHeatMap.height; i++)
		{
			for (int j = 0; j < hubHeatMap.width; j++)
			{
				hubHeatMap.SetPixel(j, i, Color.black);
			}
		}
		Room room = null;
		for (int k = 0; k < Rooms.Count; k++)
		{
			if (Rooms[k].Template.size == RoomTemplate.SizeType.Hub)
			{
				room = Rooms[k];
				break;
			}
		}
		int num = (hubHeatMap.width - Width) / 2;
		int num2 = (hubHeatMap.height - Height) / 2;
		for (int l = 0; l < Height; l++)
		{
			int y = num2 + (Height - 1 - l);
			for (int m = 0; m < Width; m++)
			{
				Cell cell = CellMap[l][m];
				if (cell.Room == room && cell.Type != 0)
				{
					hubHeatMap.SetPixel(num + m, y, Color.white);
				}
			}
		}
		LinearBlur linearBlur = new LinearBlur();
		hubHeatMap = linearBlur.Blur(hubHeatMap, 2, 1);
		hubHeatMap.Apply();
	}
}
public class MapBrushesList : Dictionary<string, LSystem<char>>
{
	private static MapBrushesList instance;

	private MapBrushesList()
	{
		instance = this;
		AddBrush(new BasicA());
		AddBrush(new CorIntervalAB());
		AddBrush(new CorIntervalAC());
		AddBrush(new FullArches());
		AddBrush(new FullSegment());
		AddBrush(new FullSegment('D', 'E', 'F'));
		AddBrush(new RandomAABC());
	}

	public static MapBrushesList Get()
	{
		if (instance == null)
		{
			instance = new MapBrushesList();
		}
		return instance;
	}

	public void AddBrush(LSystem<char> brush)
	{
		Add(brush.GetName(), brush);
	}

	public string GetPreview(string name, int length = 16)
	{
		LSystem<char> lSystem = base[name];
		if (lSystem != null)
		{
			List<char> list = lSystem.Process(length);
			StringBuilder stringBuilder = new StringBuilder();
			foreach (char item in list)
			{
				stringBuilder.Append(item);
			}
			stringBuilder.Append(" : ");
			stringBuilder.Append(name);
			return stringBuilder.ToString();
		}
		return string.Empty;
	}
}
[Serializable]
public class MapBrush
{
	public string id = "BasicA";

	public LSystem<char> Grammar => MapBrushesList.Get()[id];

	public string GetPreview(string name, int length = 16)
	{
		return MapBrushesList.Get().GetPreview(id, length);
	}
}
namespace MapBrushes
{
	public class BasicA : LSystem<char>
	{
		public override void Axiom(int capacity, LSeq seq)
		{
			if (capacity >= 1)
			{
				seq.Add('A');
				seq.Add(Delay(Axiom));
			}
		}
	}
	public class CorIntervalAB : LSystem<char>
	{
		private char cA = 'A';

		private char cB = 'A';

		public CorIntervalAB(char cA = 'A', char cB = 'B')
		{
			this.cA = cA;
			this.cB = cB;
		}

		public override void Axiom(int capacity, LSeq seq)
		{
			if (capacity <= 4)
			{
				seq.Add(End);
				return;
			}
			seq.Add(cA);
			seq.Add(cA);
			seq.Add(cB);
			seq.Add(Delay(Axiom));
		}

		public void End(int capacity, LSeq seq)
		{
			if (capacity >= 1)
			{
				seq.Add(cA);
				seq.Add(Delay(End));
			}
		}

		public override string GetName()
		{
			return "CorInterval" + cA + cB;
		}
	}
	public class CorIntervalAC : CorIntervalAB
	{
		public CorIntervalAC()
			: base('A', 'C')
		{
		}
	}
	public class FullArches : LSystem<char>
	{
		public override void Axiom(int capacity, LSeq seq)
		{
			if (capacity < 2)
			{
				seq.Add('A');
				return;
			}
			seq.Add('A');
			seq.Add(Arch);
			seq.Add('A');
		}

		public void Arch(int capacity, LSeq seq)
		{
			if (capacity >= 2)
			{
				seq.Add('B');
				seq.Add('C');
				seq.Add(Arch);
			}
			else
			{
				seq.Add('A');
			}
		}
	}
	public class FullSegment : LSystem<char>
	{
		private char cA = 'A';

		private char cStart = 'B';

		private char cMiddle = 'C';

		private char cEnd = 'D';

		public FullSegment(char cStart = 'B', char cMiddle = 'C', char cEnd = 'D')
		{
			this.cStart = cStart;
			this.cMiddle = cMiddle;
			this.cEnd = cEnd;
		}

		public override void Axiom(int capacity, LSeq seq)
		{
			if (capacity < 2)
			{
				seq.Add(cA);
				return;
			}
			seq.Add(cA);
			seq.Add(SegmentWrapper);
			seq.Add(cA);
		}

		public void SegmentWrapper(int capacity, LSeq seq)
		{
			if (capacity < 2)
			{
				seq.Add(cA);
				return;
			}
			seq.Add(cA);
			seq.Add(Segment);
			seq.Add(cA);
		}

		public void Segment(int capacity, LSeq seq)
		{
			if (capacity >= 2)
			{
				seq.Add(cStart);
				seq.Add(Middle);
				seq.Add(cEnd);
			}
			else
			{
				seq.Add(cA);
			}
		}

		public void Middle(int capacity, LSeq seq)
		{
			seq.Add(cMiddle);
			seq.Add(Middle);
		}

		public override string GetName()
		{
			return GetType().Name + "_" + cStart + cMiddle + cEnd;
		}
	}
	public class RandomAABC : LSystem<char>
	{
		public override void Axiom(int capacity, LSeq seq)
		{
			if (capacity >= 1)
			{
				switch (UnityEngine.Random.Range(0, 7))
				{
				case 0:
					seq.Add('B');
					break;
				case 1:
					seq.Add('C');
					break;
				default:
					seq.Add('A');
					break;
				}
				seq.Add(Delay(Axiom));
			}
		}
	}
}
public class MapBuilder : MonoBehaviour
{
	public enum GeneratorType
	{
		Default,
		Meta01,
		Meta02,
		Meta03,
		Meta04,
		Demo
	}

	private struct EdgeCollapse
	{
		public Vector3 edge;

		public Point tile;
	}

	private struct SWallInfo
	{
		public bool bWallLeft;

		public bool bWallRight;

		public bool bWallUp;

		public bool bWallDown;

		public bool bHasWall;

		public int GetNumWalls()
		{
			return (bWallLeft ? 1 : 0) + (bWallRight ? 1 : 0) + (bWallUp ? 1 : 0) + (bWallDown ? 1 : 0);
		}

		public bool IsInCorner()
		{
			return (bWallLeft && (bWallUp || bWallDown)) || (bWallRight && (bWallUp || bWallDown)) || (bWallUp && (bWallLeft || bWallRight)) || (bWallDown && (bWallLeft || bWallRight));
		}
	}

	private struct SPropMargins
	{
		public int marginLeft;

		public int marginTop;

		public int marginRight;

		public int marginBottom;

		public SPropMargins(int left = 0, int top = 0, int right = 0, int bottom = 0)
		{
			marginLeft = left;
			marginTop = top;
			marginRight = right;
			marginBottom = bottom;
		}
	}

	private class DeferredMiniTransition
	{
		public Point cellPos;

		public AdjacencyCode transCode;

		public DeferredMiniTransition(Point pos, AdjacencyCode code)
		{
			cellPos = pos;
			transCode = code;
		}
	}

	public Texture2D levelMap;

	public GameObject wallPrefab;

	public GameObject floorPrefab;

	public GameObject ceilingPrefab;

	private Map map;

	public MapStyle[] mapStyles;

	public int currentStyle;

	public LevelOptions levelOptions;

	public GameObject visibilityProbePrefab;

	public GameObject chunkPrefab;

	public LayerMask cullMask;

	public GameObject ghostSpawnPrefab;

	public GameObject[] genericProps;

	public GameObject[] lightProps;

	public GameObject[] horrorProps;

	public GameObject[] treasuryProps;

	public GameObject[] doorPrefabs;

	public GameObject exitPrefab;

	public GameObject fogPrefab;

	private Dictionary<Point, List<GameObject>> indexGenericProps;

	private Dictionary<Point, List<GameObject>> indexLightProps;

	private Dictionary<Point, List<GameObject>> indexHorrorProps;

	private Dictionary<Point, List<GameObject>> indexTreasuryProps;

	private Dictionary<GameObject, int> propCount;

	private List<Point> reservedNoProp;

	public GameObject prowlerPrefab;

	public LightEater lightEaterPrefab;

	public Floater floaterPrefab;

	public Bat batPrefab;

	public string seed;

	public GeneratorType generatorType;

	private GBGenerator customGenerator;

	public MetaMapAfterBuild_01 meta01AfterBuild;

	public MetaMapAfterBuild_02 meta02AfterBuild;

	public MetaMapAfterBuild_03 meta03AfterBuild;

	public MetaMapAfterBuild_04 meta04AfterBuild;

	public RoomTemplate testRoom;

	public List<Texture2D> allTexs;

	private GameObject mapGeometry;

	private GameObject visibilityProbes;

	private GameObject ghostSpawns;

	private GameObject wallContainer;

	private GameObject ceiling;

	private GameObject floor;

	private bool PlacedLightSafe;

	private LayerMask geometryLayer;

	private LayerMask propLayer;

	private LayerMask[] staticLayers;

	private Quaternion rotLWallLeft = Quaternion.Euler(-90f, 90f, 0f);

	private Quaternion rotLWallRight = Quaternion.Euler(-90f, -90f, 0f);

	private Quaternion rotLWallTop = Quaternion.Euler(-90f, 180f, 0f);

	private Quaternion rotLWallBottom = Quaternion.Euler(-90f, 0f, 0f);

	private Quaternion rotInCornerLeftTop = Quaternion.Euler(-90f, 180f, 0f);

	private Quaternion rotInCornerRightTop = Quaternion.Euler(-90f, -90f, 0f);

	private Quaternion rotInCornerLeftBottom = Quaternion.Euler(-90f, 90f, 0f);

	private Quaternion rotInCornerRightBottom = Quaternion.Euler(-90f, 0f, 0f);

	private Quaternion rotOutCornerLeftTop = Quaternion.Euler(-90f, 180f, 0f);

	private Quaternion rotOutCornerRightTop = Quaternion.Euler(-90f, -90f, 0f);

	private Quaternion rotOutCornerLeftBottom = Quaternion.Euler(-90f, 90f, 0f);

	private Quaternion rotOutCornerRightBottom = Quaternion.Euler(-90f, 0f, 0f);

	private Quaternion rotSmSingleV = Quaternion.Euler(-90f, 0f, 0f);

	private Quaternion rotSmSingleVHor = Quaternion.Euler(-90f, 0f, 0f);

	private Quaternion rotSmSingleVVer = Quaternion.Euler(-90f, 90f, 0f);

	private Quaternion rotSmSingleH = Quaternion.Euler(-90f, 90f, 0f);

	private Quaternion rotSmCornerLeftTop = Quaternion.Euler(-90f, 0f, 0f);

	private Quaternion rotSmCornerRightTop = Quaternion.Euler(-90f, 270f, 0f);

	private Quaternion rotSmCornerRightBottom = Quaternion.Euler(-90f, 180f, 0f);

	private Quaternion rotSmCornerLeftBottom = Quaternion.Euler(-90f, 90f, 0f);

	private Quaternion rotSmTCrossTop = Quaternion.Euler(-90f, 0f, 0f);

	private Quaternion rotSmTCrossLeft = Quaternion.Euler(-90f, -90f, 0f);

	private Quaternion rotSmTCrossRight = Quaternion.Euler(-90f, 90f, 0f);

	private Quaternion rotSmTCrossBottom = Quaternion.Euler(-90f, 180f, 0f);

	private Quaternion rotSmDeadendTop = Quaternion.Euler(-90f, 0f, 0f);

	private Quaternion rotSmDeadendLeft = Quaternion.Euler(-90f, -90f, 0f);

	private Quaternion rotSmDeadendRight = Quaternion.Euler(-90f, 90f, 0f);

	private Quaternion rotSmDeadendBottom = Quaternion.Euler(-90f, 180f, 0f);

	private byte[][] ceilingMiniTransitions;

	private List<EdgeCollapse> edgeCollapses;

	public bool drawGraph;

	public Texture2D hubHeatMap;

	private static List<GameObject> tempWallList;

	private void Awake()
	{
		Debug.Log("MapBuilder - Reloading room templates");
		RoomTemplate.ReloadRoomTemplates();
		if (levelOptions.seeds != null && levelOptions.seeds.Length >= 1)
		{
			UnityEngine.Random.seed = UnityEngine.Random.seed;
			seed = RandomExt.Choice(levelOptions.seeds);
		}
		if (seed != string.Empty)
		{
			UnityEngine.Random.seed = int.Parse(seed, NumberStyles.HexNumber);
		}
		else
		{
			UnityEngine.Random.seed = UnityEngine.Random.seed;
		}
		int num = UnityEngine.Random.seed;
		string text = $"{num:X}";
		Debug.Log("Seed: " + text);
		seed = text;
		Debug.Log("MapBuilder - Generating map");
		float realtimeSinceStartup = Time.realtimeSinceStartup;
		Map map = GenerateGB();
		Debug.Log("Time - GenerateGB: " + (Time.realtimeSinceStartup - realtimeSinceStartup).ToString("F2"));
		realtimeSinceStartup = Time.realtimeSinceStartup;
		Generate(map);
		Debug.Log("Time - Generate: " + (Time.realtimeSinceStartup - realtimeSinceStartup).ToString("F2"));
		if (map.graph != null)
		{
			if (map.graph.CheckConnected())
			{
				Debug.Log("Graph is connected");
			}
			else
			{
				Debug.LogError("Graph is NOT connected");
			}
		}
		if (testRoom != null)
		{
			GetComponent<GhostSpawner>().enabled = false;
		}
		Debug.Log("MapBuilder - Awake end");
		if (customGenerator != null && generatorType != 0)
		{
			(customGenerator as CustomGenerator).AfterBuild();
		}
		if (generatorType == GeneratorType.Meta01)
		{
			MetaMapAfterBuild_01 metaMapAfterBuild_ = UnityEngine.Object.Instantiate(meta01AfterBuild);
			metaMapAfterBuild_.DoBuild();
		}
		else if (generatorType == GeneratorType.Meta02)
		{
			MetaMapAfterBuild_02 metaMapAfterBuild_2 = UnityEngine.Object.Instantiate(meta02AfterBuild);
			metaMapAfterBuild_2.DoBuild();
		}
		else if (generatorType == GeneratorType.Meta03)
		{
			MetaMapAfterBuild_03 metaMapAfterBuild_3 = UnityEngine.Object.Instantiate(meta03AfterBuild);
			metaMapAfterBuild_3.DoBuild();
		}
		else if (generatorType == GeneratorType.Meta04)
		{
			MetaMapAfterBuild_04 metaMapAfterBuild_4 = UnityEngine.Object.Instantiate(meta04AfterBuild);
			metaMapAfterBuild_4.DoBuild();
		}
	}

	public void Update()
	{
	}

	public GameObject Generate(Map newMap, bool positionPlayer = true)
	{
		map = newMap;
		float realtimeSinceStartup = Time.realtimeSinceStartup;
		Debug.Log("MapBuilder - Building map");
		map.mapStyles = mapStyles;
		geometryLayer = LayerMask.NameToLayer("StaticGeometry");
		propLayer = LayerMask.NameToLayer("Prop");
		staticLayers = new LayerMask[3];
		ref LayerMask reference = ref staticLayers[0];
		reference = geometryLayer;
		ref LayerMask reference2 = ref staticLayers[1];
		reference2 = propLayer;
		ref LayerMask reference3 = ref staticLayers[2];
		reference3 = LayerMask.NameToLayer("MapHider");
		newMap.PrintHUBHeatmap();
		hubHeatMap = newMap.hubHeatMap;
		GameObject[] array = doorPrefabs;
		if (levelOptions.doorPrefabs != null && levelOptions.doorPrefabs.Length > 0)
		{
			array = levelOptions.doorPrefabs;
		}
		propCount = new Dictionary<GameObject, int>();
		mapGeometry = new GameObject("MapGeometry");
		reservedNoProp = new List<Point>();
		GameObject gameObject = new GameObject("StaticGeometry");
		gameObject.transform.parent = mapGeometry.transform;
		wallContainer = new GameObject("Walls");
		wallContainer.transform.parent = gameObject.transform;
		wallContainer.isStatic = true;
		wallContainer.layer = geometryLayer;
		ceiling = new GameObject("Ceiling");
		ceiling.transform.parent = gameObject.transform;
		ceiling.transform.localPosition = new Vector3(0f, 0f, 0f);
		ceiling.isStatic = true;
		ceiling.layer = geometryLayer;
		floor = new GameObject("Floor");
		floor.transform.parent = gameObject.transform;
		floor.isStatic = true;
		floor.layer = geometryLayer;
		visibilityProbes = new GameObject("VisibilityProbes");
		ghostSpawns = new GameObject("GhostSpawns");
		Vector3 vector = Vector3.zero;
		int width = map.Width;
		int height = map.Height;
		Vector2 vector2 = new Vector2(1.5f, 1.5f);
		map.TileSize = vector2;
		float num = 0f;
		float x = map.TileSize.x;
		Debug.Log("Time - Generate::Init " + (Time.realtimeSinceStartup - realtimeSinceStartup).ToString("F2"));
		realtimeSinceStartup = Time.realtimeSinceStartup;
		byte[][] array2 = new byte[map.Height][];
		for (int i = 0; i < map.Height; i++)
		{
			array2[i] = new byte[map.Width];
			for (int j = 0; j < map.Width; j++)
			{
				array2[i][j] = byte.MaxValue;
			}
		}
		ceilingMiniTransitions = new byte[map.Height][];
		for (int k = 0; k < map.Height; k++)
		{
			ceilingMiniTransitions[k] = new byte[map.Width];
			for (int l = 0; l < map.Width; l++)
			{
				ceilingMiniTransitions[k][l] = 0;
			}
		}
		List<DeferredMiniTransition> list = new List<DeferredMiniTransition>();
		edgeCollapses = new List<EdgeCollapse>();
		GameObject[][] array3 = new GameObject[map.Height][];
		GameObject[][] array4 = new GameObject[map.Height][];
		for (int m = 0; m < map.Height; m++)
		{
			array3[m] = new GameObject[map.Width];
			array4[m] = new GameObject[map.Width];
			for (int n = 0; n < map.Width; n++)
			{
				array3[m][n] = null;
				array4[m][n] = null;
			}
		}
		Debug.Log("Time - Generate::InitArrays " + (Time.realtimeSinceStartup - realtimeSinceStartup).ToString("F2"));
		realtimeSinceStartup = Time.realtimeSinceStartup;
		List<Pair<Point, AdjacencyCode>> list2 = new List<Pair<Point, AdjacencyCode>>();
		List<string> list3 = new List<string>();
		list3.Add(levelOptions.tag);
		list3.Add("corridor");
		list3.Add("narrow");
		MapStyle style = map.Tags.GetStyle(map.mapStyles, list3);
		for (int num2 = 0; num2 < map.Height; num2++)
		{
			for (int num3 = 0; num3 < map.Width; num3++)
			{
				Cell cell = Map.Get().At(num3, num2);
				int numAdjacentWallsNoCorners = cell.GetNumAdjacentWallsNoCorners();
				if (!cell.IsCorridor() || map.EntrancePositions.Contains(new Point(num3, num2)))
				{
					continue;
				}
				MapStyle style2 = Map.Get().Tags.GetStyle(mapStyles, new Point(num3, num2));
				Point point = new Point(num3 - 1, num2);
				Cell cell2 = Map.Get().At(point);
				if (cell2.IsClear())
				{
					MapStyle style3 = Map.Get().Tags.GetStyle(mapStyles, point);
					if (style3 != style2)
					{
						int numAdjacentWallsNoCorners2 = Map.Get().At(point).GetNumAdjacentWallsNoCorners();
						AdjacencyCode second = AdjacencyCode.RightCenter;
						bool flag = numAdjacentWallsNoCorners2 < numAdjacentWallsNoCorners;
						if (numAdjacentWallsNoCorners2 == numAdjacentWallsNoCorners)
						{
							flag = style2 == style;
						}
						if (flag)
						{
							point = new Point(num3, num2);
							second = AdjacencyCode.LeftCenter;
						}
						list2.AddIfNotInside(new Pair<Point, AdjacencyCode>(point, second));
					}
				}
				Point point2 = new Point(num3 + 1, num2);
				Cell cell3 = Map.Get().At(point2);
				if (cell3.IsClear())
				{
					MapStyle style4 = Map.Get().Tags.GetStyle(mapStyles, point2);
					if (style4 != style2)
					{
						int numAdjacentWallsNoCorners3 = Map.Get().At(point2).GetNumAdjacentWallsNoCorners();
						AdjacencyCode second2 = AdjacencyCode.LeftCenter;
						bool flag2 = numAdjacentWallsNoCorners3 < numAdjacentWallsNoCorners;
						if (numAdjacentWallsNoCorners3 == numAdjacentWallsNoCorners)
						{
							flag2 = style2 == style;
						}
						if (flag2)
						{
							point2 = new Point(num3, num2);
							second2 = AdjacencyCode.RightCenter;
						}
						list2.AddIfNotInside(new Pair<Point, AdjacencyCode>(point2, second2));
					}
				}
				Point point3 = new Point(num3, num2 - 1);
				Cell cell4 = Map.Get().At(point3);
				if (cell4.IsClear())
				{
					MapStyle style5 = Map.Get().Tags.GetStyle(mapStyles, point3);
					if (style5 != style2)
					{
						int numAdjacentWallsNoCorners4 = Map.Get().At(point3).GetNumAdjacentWallsNoCorners();
						AdjacencyCode second3 = AdjacencyCode.CenterBottom;
						bool flag3 = numAdjacentWallsNoCorners4 < numAdjacentWallsNoCorners;
						if (numAdjacentWallsNoCorners4 == numAdjacentWallsNoCorners)
						{
							flag3 = style2 == style;
						}
						if (flag3)
						{
							point3 = new Point(num3, num2);
							second3 = AdjacencyCode.CenterTop;
						}
						list2.AddIfNotInside(new Pair<Point, AdjacencyCode>(point3, second3));
					}
				}
				Point point4 = new Point(num3, num2 + 1);
				Cell cell5 = Map.Get().At(point4);
				if (!cell5.IsClear())
				{
					continue;
				}
				MapStyle style6 = Map.Get().Tags.GetStyle(mapStyles, point4);
				if (style6 != style2)
				{
					int numAdjacentWallsNoCorners5 = Map.Get().At(point4).GetNumAdjacentWallsNoCorners();
					AdjacencyCode second4 = AdjacencyCode.CenterTop;
					bool flag4 = numAdjacentWallsNoCorners5 < numAdjacentWallsNoCorners;
					if (numAdjacentWallsNoCorners5 == numAdjacentWallsNoCorners)
					{
						flag4 = style2 == style;
					}
					if (flag4)
					{
						point4 = new Point(num3, num2);
						second4 = AdjacencyCode.CenterBottom;
					}
					list2.AddIfNotInside(new Pair<Point, AdjacencyCode>(point4, second4));
				}
			}
		}
		Debug.Log("Time - Generate::ExtraEntrances " + (Time.realtimeSinceStartup - realtimeSinceStartup).ToString("F2"));
		realtimeSinceStartup = Time.realtimeSinceStartup;
		Debug.Log("MapBuilder - Creating chunks");
		MapChunk.InitChunks(chunkPrefab, mapGeometry.transform);
		Debug.Log("Time - Generate::InitChunks " + (Time.realtimeSinceStartup - realtimeSinceStartup).ToString("F2"));
		realtimeSinceStartup = Time.realtimeSinceStartup;
		Debug.Log("MapBuilder - Creating geometry");
		bool flag5 = false;
		bool flag6 = false;
		List<GameObject> listWalls = new List<GameObject>();
		for (int num4 = 0; num4 < width; num4++)
		{
			for (int num5 = 0; num5 < height; num5++)
			{
				Cell cell6 = map.CellMap[num5][num4];
				MapChunk mapChunk = MapChunk.At(num4, num5);
				MapStyle style7 = Map.Get().Tags.GetStyle(mapStyles, new Point(num4, num5));
				int num6 = Map.Get().Tags.GetVariation(new Point(num4, num5));
				if (num6 >= style7.lWallPrefabs.Length)
				{
					num6 = 0;
				}
				if (cell6.IsClearOrPit())
				{
					if (cell6.Type == CellType.Spawn)
					{
						vector = new Vector3((float)num4 * vector2.x + vector2.x / 2f, 1.05f, (float)(-num5) * vector2.y - vector2.y / 2f);
					}
					if (!cell6.Occupied || cell6.IsClear())
					{
						GameObject gameObject2 = UnityEngine.Object.Instantiate(visibilityProbePrefab);
						gameObject2.name = "Probe_" + num4 + "_" + num5;
						gameObject2.transform.parent = visibilityProbes.transform;
						Vector3 localPosition = new Vector3((float)num4 * vector2.x, 0f, (float)(-num5) * vector2.y);
						localPosition += new Vector3(vector2.x / 2f, 0f, (0f - vector2.y) / 2f);
						gameObject2.transform.localPosition = localPosition;
						cell6.Probe = gameObject2.GetComponent<VisibilityProbe>();
						mapChunk.probeList.Add(cell6.Probe);
						if (num4 % 4 == 0)
						{
							int num7 = num4 - 1;
							if (num7 >= 0)
							{
								MapChunk.At(num7, num5).probeList.Add(cell6.Probe);
							}
						}
						else if (num4 % 4 == 3)
						{
							int num8 = num4 + 1;
							if (num8 < width)
							{
								MapChunk.At(num8, num5).probeList.Add(cell6.Probe);
							}
						}
						if (num5 % 4 == 0)
						{
							int num9 = num5 - 1;
							if (num9 >= 0)
							{
								MapChunk.At(num4, num9).probeList.Add(cell6.Probe);
							}
						}
						else if (num5 % 4 == 3)
						{
							int num10 = num5 + 1;
							if (num10 < height)
							{
								MapChunk.At(num4, num10).probeList.Add(cell6.Probe);
							}
						}
					}
					if (((!cell6.Occupied && cell6.IsClear()) || cell6.IsCorridor()) && (cell6.Room == null || !cell6.Room.Safe) && UnityEngine.Random.value < 0.2f)
					{
						GameObject gameObject3 = UnityEngine.Object.Instantiate(ghostSpawnPrefab);
						gameObject3.name = "spawn_" + num4 + "_" + num5;
						gameObject3.transform.parent = ghostSpawns.transform;
						Vector3 localPosition2 = new Vector3((float)num4 * vector2.x, 0f, (float)(-num5) * vector2.y);
						localPosition2 += new Vector3(vector2.x / 2f, 0f, (0f - vector2.y) / 2f);
						gameObject3.transform.localPosition = localPosition2;
						cell6.Spawn = gameObject3.GetComponent<VisibilityProbe>();
					}
					BuildWalls(num4, num5, cell6.adjacency, style7, mapChunk, num6, x, "WallSection", 0f, listWalls);
					if (cell6.IsPit())
					{
						BuildPitWalls(num4, num5, cell6, style7, mapChunk, x);
					}
					if (cell6.CeilingShaft)
					{
						BuildShaftWalls(num4, num5, cell6, style7, mapChunk, x);
					}
					if (!cell6.CeilingShaft)
					{
						GameObject gameObject4 = null;
						Quaternion localRotation = Quaternion.Euler(-90f, 0f, 0f);
						AdjacencyCode adjacencyCode = AdjacencyCode.Clear;
						if (cell6.CheckAdjacencyClearCeiling((AdjacencyCode)255))
						{
							gameObject4 = style7.ceilingPrefabs.lgSinglePrefab;
							if (style7.ceilingPrefabs.alignToRoomDirection)
							{
								Room room = cell6.Room;
								if (room != null)
								{
									localRotation = ((room.Template.flags.ceilingHint == RoomTemplate.Flags.CeilingHint.Horizontal) ? rotSmSingleVHor : ((room.Template.flags.ceilingHint == RoomTemplate.Flags.CeilingHint.Vertical) ? rotSmSingleVVer : ((room.Template.height <= room.Template.width) ? rotSmSingleVHor : rotSmSingleVVer)));
								}
							}
						}
						else if ((cell6.CheckAdjacencyCeiling(AdjacencyCode.LeftCenter) || cell6.CheckAdjacencyCeiling((AdjacencyCode)33)) && cell6.CheckAdjacencyClearCeiling((AdjacencyCode)214))
						{
							gameObject4 = style7.ceilingPrefabs.lgLWallPrefab;
							localRotation = rotLWallLeft;
							adjacencyCode |= AdjacencyCode.LeftCenter;
						}
						else if ((cell6.CheckAdjacencyCeiling(AdjacencyCode.RightCenter) || cell6.CheckAdjacencyCeiling((AdjacencyCode)132)) && cell6.CheckAdjacencyClearCeiling((AdjacencyCode)107))
						{
							gameObject4 = style7.ceilingPrefabs.lgLWallPrefab;
							localRotation = rotLWallRight;
							adjacencyCode |= AdjacencyCode.RightCenter;
						}
						else if ((cell6.CheckAdjacencyCeiling(AdjacencyCode.CenterTop) || cell6.CheckAdjacencyCeiling((AdjacencyCode)5)) && cell6.CheckAdjacencyClearCeiling((AdjacencyCode)248))
						{
							gameObject4 = style7.ceilingPrefabs.lgLWallPrefab;
							localRotation = rotLWallTop;
							adjacencyCode |= AdjacencyCode.CenterTop;
						}
						else if ((cell6.CheckAdjacencyCeiling(AdjacencyCode.CenterBottom) || cell6.CheckAdjacencyCeiling((AdjacencyCode)160)) && cell6.CheckAdjacencyClearCeiling((AdjacencyCode)31))
						{
							gameObject4 = style7.ceilingPrefabs.lgLWallPrefab;
							localRotation = rotLWallBottom;
							adjacencyCode |= AdjacencyCode.CenterBottom;
						}
						else if ((cell6.CheckAdjacencyCeiling((AdjacencyCode)10) || cell6.CheckAdjacencyCeiling((AdjacencyCode)37) || cell6.CheckAdjacencyCeiling((AdjacencyCode)12) || cell6.CheckAdjacencyCeiling((AdjacencyCode)34)) && cell6.CheckAdjacencyClearCeiling((AdjacencyCode)208))
						{
							gameObject4 = style7.ceilingPrefabs.lgInCornerPrefab;
							localRotation = rotInCornerLeftBottom;
							adjacencyCode |= AdjacencyCode.LeftCenter;
							adjacencyCode |= AdjacencyCode.CenterTop;
						}
						else if ((cell6.CheckAdjacencyCeiling((AdjacencyCode)18) || cell6.CheckAdjacencyCeiling((AdjacencyCode)133) || cell6.CheckAdjacencyCeiling((AdjacencyCode)17) || cell6.CheckAdjacencyCeiling((AdjacencyCode)130)) && cell6.CheckAdjacencyClearCeiling((AdjacencyCode)104))
						{
							gameObject4 = style7.ceilingPrefabs.lgInCornerPrefab;
							localRotation = rotInCornerLeftTop;
							adjacencyCode |= AdjacencyCode.RightCenter;
							adjacencyCode |= AdjacencyCode.CenterTop;
						}
						else if ((cell6.CheckAdjacencyCeiling((AdjacencyCode)72) || cell6.CheckAdjacencyCeiling((AdjacencyCode)161) || cell6.CheckAdjacencyCeiling((AdjacencyCode)136) || cell6.CheckAdjacencyCeiling((AdjacencyCode)65)) && cell6.CheckAdjacencyClearCeiling((AdjacencyCode)22))
						{
							gameObject4 = style7.ceilingPrefabs.lgInCornerPrefab;
							localRotation = rotInCornerRightBottom;
							adjacencyCode |= AdjacencyCode.LeftCenter;
							adjacencyCode |= AdjacencyCode.CenterBottom;
						}
						else if ((cell6.CheckAdjacencyCeiling((AdjacencyCode)80) || cell6.CheckAdjacencyCeiling((AdjacencyCode)164) || cell6.CheckAdjacencyCeiling((AdjacencyCode)48) || cell6.CheckAdjacencyCeiling((AdjacencyCode)68)) && cell6.CheckAdjacencyClearCeiling((AdjacencyCode)11))
						{
							gameObject4 = style7.ceilingPrefabs.lgInCornerPrefab;
							localRotation = rotInCornerRightTop;
							adjacencyCode |= AdjacencyCode.RightCenter;
							adjacencyCode |= AdjacencyCode.CenterBottom;
						}
						else if (cell6.adjacency == 1)
						{
							gameObject4 = style7.ceilingPrefabs.lgOutCornerPrefab;
							localRotation = rotOutCornerLeftTop;
						}
						else if (cell6.adjacency == 4)
						{
							gameObject4 = style7.ceilingPrefabs.lgOutCornerPrefab;
							localRotation = rotOutCornerRightTop;
						}
						else if (cell6.adjacency == 32)
						{
							gameObject4 = style7.ceilingPrefabs.lgOutCornerPrefab;
							localRotation = rotOutCornerLeftBottom;
						}
						else if (cell6.adjacency == 128)
						{
							gameObject4 = style7.ceilingPrefabs.lgOutCornerPrefab;
							localRotation = rotOutCornerRightBottom;
						}
						else
						{
							array2[num5][num4] = 0;
						}
						flag6 = flag6 || style7.ceilingNoise;
						if (gameObject4 != null)
						{
							if (style7.ceilingPrefabs.noRotate)
							{
								localRotation = rotSmSingleV;
							}
							GameObject gameObject5 = UnityEngine.Object.Instantiate(gameObject4, Vector3.zero, Quaternion.identity);
							gameObject5.name = "Ceiling_" + num4 + "_" + num5;
							gameObject5.transform.parent = ceiling.transform;
							float y = style7.ceilingHeight - 3.5f;
							gameObject5.transform.localPosition = new Vector3((float)num4 * x + x / 2f, y, (float)(-num5) * x - x / 2f);
							gameObject5.transform.localRotation = localRotation;
							gameObject5.layer = geometryLayer;
							gameObject5.tag = Tags.MapGeometry;
							mapChunk.AddToCombine(gameObject5);
							StripNonStatic(gameObject5.transform, mapGeometry.transform);
							array3[num5][num4] = gameObject5;
						}
						else
						{
							array2[num5][num4] = 0;
						}
						if (!cell6.IsDoor && adjacencyCode != 0 && style7.arched)
						{
							GameObject ceilingTransitionPrefab = style7.GetCeilingTransitionPrefab();
							float transitionHOffset = style7.transitionHOffset;
							if (Cell.CheckAdjacency((byte)adjacencyCode, AdjacencyCode.RightCenter) && !cell6.CheckAdjacency(AdjacencyCode.RightCenter))
							{
								list.Add(new DeferredMiniTransition(new Point(num4, num5), AdjacencyCode.RightCenter));
							}
							if (Cell.CheckAdjacency((byte)adjacencyCode, AdjacencyCode.LeftCenter) && !cell6.CheckAdjacency(AdjacencyCode.LeftCenter))
							{
								list.Add(new DeferredMiniTransition(new Point(num4, num5), AdjacencyCode.LeftCenter));
							}
							if (Cell.CheckAdjacency((byte)adjacencyCode, AdjacencyCode.CenterTop) && !cell6.CheckAdjacency(AdjacencyCode.CenterTop))
							{
								list.Add(new DeferredMiniTransition(new Point(num4, num5), AdjacencyCode.CenterTop));
							}
							if (Cell.CheckAdjacency((byte)adjacencyCode, AdjacencyCode.CenterBottom) && !cell6.CheckAdjacency(AdjacencyCode.CenterBottom))
							{
								list.Add(new DeferredMiniTransition(new Point(num4, num5), AdjacencyCode.CenterBottom));
							}
						}
					}
					if (!cell6.IsPit())
					{
						GameObject gameObject6 = UnityEngine.Object.Instantiate(style7.floorPrefab, Vector3.zero, Quaternion.identity);
						gameObject6.name = "Floor_" + num4 + "_" + num5;
						gameObject6.transform.parent = floor.transform;
						gameObject6.transform.localPosition = new Vector3((float)num4 * x + x / 2f, 0f, (float)(-num5) * x - x / 2f);
						gameObject6.transform.localRotation = Quaternion.Euler(-90f, 0f, 0f);
						gameObject6.layer = geometryLayer;
						if (gameObject6.tag.Length == 0 || gameObject6.tag == Tags.Untagged)
						{
							gameObject6.tag = Tags.MapGeometry;
						}
						mapChunk.AddToCombine(gameObject6);
						StripNonStatic(gameObject6.transform, mapGeometry.transform);
						array4[num5][num4] = gameObject6;
						flag5 = flag5 || style7.floorNoise;
					}
					continue;
				}
				bool flag7 = true;
				if (!cell6.CheckAdjacency((AdjacencyCode)90) && !cell6.IsPit())
				{
					GameObject gameObject7 = UnityEngine.Object.Instantiate(wallPrefab, Vector3.zero, Quaternion.identity);
					gameObject7.name = "WallSection_" + num4 + "_" + num5;
					gameObject7.transform.parent = wallContainer.transform;
					ProceduralCube component = gameObject7.GetComponent<ProceduralCube>();
					component.Rebuild();
					gameObject7.transform.localPosition = new Vector3((float)num4 * Map.Get().TileSize.x, 0f, (float)(-num5) * Map.Get().TileSize.y - Map.Get().TileSize.y);
					if (component.fSizeY > num)
					{
						num = component.fSizeY;
					}
				}
			}
		}
		Debug.Log("Time - Generate::Main geometry " + (Time.realtimeSinceStartup - realtimeSinceStartup).ToString("F2"));
		realtimeSinceStartup = Time.realtimeSinceStartup;
		Debug.Log("MapBuilder - Creating ceiling (2nd pass)");
		for (int num11 = 0; num11 < map.Height; num11++)
		{
			for (int num12 = 0; num12 < map.Width; num12++)
			{
				if (array2[num11][num12] != 0)
				{
					continue;
				}
				int num13 = 0;
				int num14 = 1;
				MapStyle style8 = Map.Get().Tags.GetStyle(mapStyles, new Point(num12, num11));
				for (int num15 = num11 - 1; num15 <= num11 + 1; num15++)
				{
					for (int num16 = num12 - 1; num16 <= num12 + 1; num16++)
					{
						if (num16 == num12 && num15 == num11)
						{
							continue;
						}
						if (num16 >= 0 && num16 < map.Width && num15 >= 0 && num15 < map.Height)
						{
							if (array2[num15][num16] == byte.MaxValue)
							{
								num13 |= num14;
							}
							else
							{
								MapStyle style9 = Map.Get().Tags.GetStyle(mapStyles, new Point(num16, num15));
								if (style9 != style8)
								{
									num13 |= num14;
								}
							}
						}
						else
						{
							num13 |= num14;
						}
						num14 *= 2;
					}
				}
				if (num13 == 255)
				{
					num13 = 0;
				}
				array2[num11][num12] = (byte)num13;
			}
		}
		for (int num17 = 0; num17 < width; num17++)
		{
			for (int num18 = 0; num18 < height; num18++)
			{
				Cell cell7 = map.CellMap[num18][num17];
				MapChunk mapChunk2 = MapChunk.At(num17, num18);
				GameObject gameObject8 = null;
				MapStyle style10 = Map.Get().Tags.GetStyle(mapStyles, new Point(num17, num18));
				byte b = array2[num18][num17];
				if (!cell7.IsClear() || b == byte.MaxValue)
				{
					continue;
				}
				Quaternion localRotation2 = rotSmSingleV;
				if (Cell.CheckAdjacency(b, (AdjacencyCode)90))
				{
					gameObject8 = style10.ceilingPrefabs.smSinglePrefab;
				}
				else if (Cell.CheckAdjacency(b, (AdjacencyCode)24) && Cell.CheckAdjacencyClear(b, (AdjacencyCode)66))
				{
					gameObject8 = style10.ceilingPrefabs.smLWallPrefab;
				}
				else if (Cell.CheckAdjacency(b, (AdjacencyCode)66) && Cell.CheckAdjacencyClear(b, (AdjacencyCode)24))
				{
					gameObject8 = style10.ceilingPrefabs.smLWallPrefab;
					if (style10.ceilingPrefabs.alignPieces)
					{
						localRotation2 = rotSmSingleH;
					}
				}
				else if (Cell.CheckAdjacency(b, (AdjacencyCode)26) && Cell.CheckAdjacencyClear(b, AdjacencyCode.CenterBottom))
				{
					gameObject8 = style10.ceilingPrefabs.smDeadendPrefab;
					localRotation2 = rotSmDeadendTop;
				}
				else if (Cell.CheckAdjacency(b, (AdjacencyCode)88) && Cell.CheckAdjacencyClear(b, AdjacencyCode.CenterTop))
				{
					gameObject8 = style10.ceilingPrefabs.smDeadendPrefab;
					localRotation2 = rotSmDeadendBottom;
				}
				else if (Cell.CheckAdjacency(b, (AdjacencyCode)74) && Cell.CheckAdjacencyClear(b, AdjacencyCode.RightCenter))
				{
					gameObject8 = style10.ceilingPrefabs.smDeadendPrefab;
					localRotation2 = rotSmDeadendLeft;
				}
				else if (Cell.CheckAdjacency(b, (AdjacencyCode)82) && Cell.CheckAdjacencyClear(b, AdjacencyCode.LeftCenter))
				{
					gameObject8 = style10.ceilingPrefabs.smDeadendPrefab;
					localRotation2 = rotSmDeadendRight;
				}
				else if (Cell.CheckAdjacency(b, (AdjacencyCode)50))
				{
					gameObject8 = style10.ceilingPrefabs.smCornerPrefab;
					localRotation2 = rotSmCornerLeftTop;
				}
				else if (Cell.CheckAdjacency(b, (AdjacencyCode)138))
				{
					gameObject8 = style10.ceilingPrefabs.smCornerPrefab;
					localRotation2 = rotSmCornerRightTop;
				}
				else if (Cell.CheckAdjacency(b, (AdjacencyCode)81))
				{
					gameObject8 = style10.ceilingPrefabs.smCornerPrefab;
					localRotation2 = rotSmCornerLeftBottom;
				}
				else if (Cell.CheckAdjacency(b, (AdjacencyCode)76))
				{
					gameObject8 = style10.ceilingPrefabs.smCornerPrefab;
					localRotation2 = rotSmCornerRightBottom;
				}
				else if (Cell.CheckAdjacency(b, AdjacencyCode.CenterTop) && Cell.CheckAdjacencyClear(b, (AdjacencyCode)88))
				{
					gameObject8 = style10.ceilingPrefabs.smTIntersectionPrefab;
					localRotation2 = rotSmTCrossTop;
				}
				else if (Cell.CheckAdjacency(b, AdjacencyCode.CenterBottom) && Cell.CheckAdjacencyClear(b, (AdjacencyCode)26))
				{
					gameObject8 = style10.ceilingPrefabs.smTIntersectionPrefab;
					localRotation2 = rotSmTCrossBottom;
				}
				else if (Cell.CheckAdjacency(b, AdjacencyCode.LeftCenter) && Cell.CheckAdjacencyClear(b, (AdjacencyCode)82))
				{
					gameObject8 = style10.ceilingPrefabs.smTIntersectionPrefab;
					localRotation2 = rotSmTCrossLeft;
				}
				else if (!Cell.CheckAdjacency(b, AdjacencyCode.RightCenter) || !Cell.CheckAdjacencyClear(b, (AdjacencyCode)74))
				{
					gameObject8 = ((!Cell.CheckAdjacency(b, (AdjacencyCode)165) || !Cell.CheckAdjacencyClear(b, (AdjacencyCode)90)) ? style10.ceilingPrefabs.smSinglePrefab : style10.ceilingPrefabs.sm4IntersectionPrefab);
				}
				else
				{
					gameObject8 = style10.ceilingPrefabs.smTIntersectionPrefab;
					localRotation2 = rotSmTCrossRight;
				}
				if (gameObject8 != null)
				{
					if (style10.ceilingPrefabs.noRotate)
					{
						localRotation2 = rotSmSingleV;
					}
					GameObject gameObject9 = UnityEngine.Object.Instantiate(gameObject8, Vector3.zero, Quaternion.identity);
					gameObject9.name = "Ceiling_" + num17 + "_" + num18;
					gameObject9.transform.parent = ceiling.transform;
					float y2 = style10.ceilingHeight - 3.5f;
					gameObject9.transform.localPosition = new Vector3((float)num17 * x + x / 2f, y2, (float)(-num18) * x - x / 2f);
					gameObject9.transform.localRotation = localRotation2;
					gameObject9.layer = geometryLayer;
					gameObject9.tag = Tags.MapGeometry;
					mapChunk2.AddToCombine(gameObject9);
					StripNonStatic(gameObject9.transform, mapGeometry.transform);
					array3[num18][num17] = gameObject9;
				}
			}
		}
		Debug.Log("Time - Generate::Ceiling 2nd pass " + (Time.realtimeSinceStartup - realtimeSinceStartup).ToString("F2"));
		realtimeSinceStartup = Time.realtimeSinceStartup;
		Debug.Log("MapBuilder - Adding doors");
		for (int num19 = 0; num19 < map.DoorPositions.Count; num19++)
		{
			Point point5 = map.DoorPositions[num19];
			GameObject gameObject10 = array[UnityEngine.Random.Range(0, array.Length)];
			if (!GetEntrancePositioning(point5, out var vPos, out var vLookAt, out var doorSide, gameObject10))
			{
				continue;
			}
			GameObject gameObject11 = UnityEngine.Object.Instantiate(gameObject10, Vector3.zero, Quaternion.LookRotation(vLookAt) * Quaternion.AngleAxis(-90f, Vector3.up));
			gameObject11.transform.parent = mapGeometry.transform;
			gameObject11.transform.localPosition = vPos;
			gameObject11.name = "Door_" + num19;
			map.CellMap[point5.Y][point5.X].Door = gameObject11.GetComponent<Door>();
			map.CellMap[point5.Y][point5.X].DoorSide = doorSide;
			MapChunk.AddGeometry(gameObject11, new Point(point5.X - 1, point5.Y - 1), 3, 3);
			Unlockable componentInChildren = gameObject11.GetComponentInChildren<Unlockable>();
			if (UnityEngine.Random.value < 0.8f)
			{
				componentInChildren.InitLocked();
				if (UnityEngine.Random.value < 0.2f)
				{
					componentInChildren.PlaySilence = true;
				}
			}
			else
			{
				componentInChildren.Locked = false;
			}
			AddDoorFrame(point5, doorSide, hasDoor: true, mapStyles, wallContainer);
		}
		foreach (Point entrancePosition in map.EntrancePositions)
		{
			if (GetEntrancePositioning(entrancePosition, out var _, out var _, out var doorSide2, null))
			{
				AddDoorFrame(entrancePosition, doorSide2, hasDoor: false, mapStyles, wallContainer);
			}
		}
		foreach (Pair<Point, AdjacencyCode> item2 in list2)
		{
			Point first = item2.First;
			AdjacencyCode second5 = item2.Second;
			AddDoorFrame(first, second5, hasDoor: false, mapStyles, wallContainer);
		}
		for (int num20 = 0; num20 < map.Height; num20++)
		{
			for (int num21 = 0; num21 < map.Width; num21++)
			{
				if (map.At(num21, num20).Room == null)
				{
					continue;
				}
				Point point6 = new Point(num21 - 1, num20 + 1);
				Point point7 = new Point(num21 + 1, num20 + 1);
				Point point8 = new Point(num21 - 1, num20 - 1);
				Point point9 = new Point(num21 + 1, num20 - 1);
				AdjacencyCode adjacencyCode2 = AdjacencyCode.Clear;
				if (adjacencyCode2 == AdjacencyCode.Clear && Map.Get().InRange(point6) && map.At(point6).DoorSide == AdjacencyCode.RightCenter)
				{
					adjacencyCode2 = AdjacencyCode.CenterBottom;
				}
				if (adjacencyCode2 == AdjacencyCode.Clear && Map.Get().InRange(point7) && map.At(point7).DoorSide == AdjacencyCode.CenterTop)
				{
					adjacencyCode2 = AdjacencyCode.RightCenter;
				}
				if (adjacencyCode2 == AdjacencyCode.Clear && Map.Get().InRange(point8) && map.At(point8).DoorSide == AdjacencyCode.CenterBottom)
				{
					adjacencyCode2 = AdjacencyCode.LeftCenter;
				}
				if (adjacencyCode2 == AdjacencyCode.Clear && Map.Get().InRange(point9) && map.At(point9).DoorSide == AdjacencyCode.LeftCenter)
				{
					adjacencyCode2 = AdjacencyCode.CenterTop;
				}
				AdjacencyCode adjacencyCode3 = map.At(num21, num20).IsNextToDoor;
				if (adjacencyCode3 == AdjacencyCode.Clear && adjacencyCode2 != 0)
				{
					adjacencyCode3 = adjacencyCode2;
				}
				if (adjacencyCode2 == AdjacencyCode.Clear && adjacencyCode3 == AdjacencyCode.Clear)
				{
					if (adjacencyCode3 == AdjacencyCode.Clear && Map.Get().InRange(point6) && map.At(point6).DoorSide == AdjacencyCode.CenterTop)
					{
						adjacencyCode3 = AdjacencyCode.LeftCenter;
						if (Map.Get().InRange(num21, num20 - 1))
						{
							map.At(num21, num20 - 1).IsNextToDoor = adjacencyCode3;
						}
					}
					if (adjacencyCode3 == AdjacencyCode.Clear && Map.Get().InRange(point7) && map.At(point7).DoorSide == AdjacencyCode.LeftCenter)
					{
						adjacencyCode3 = AdjacencyCode.CenterBottom;
						if (Map.Get().InRange(num21 - 1, num20))
						{
							map.At(num21 - 1, num20).IsNextToDoor = adjacencyCode3;
						}
					}
					if (adjacencyCode3 == AdjacencyCode.Clear && Map.Get().InRange(point8) && map.At(point8).DoorSide == AdjacencyCode.RightCenter)
					{
						adjacencyCode3 = AdjacencyCode.CenterTop;
						if (Map.Get().InRange(num21 + 1, num20))
						{
							map.At(num21 + 1, num20).IsNextToDoor = adjacencyCode3;
						}
					}
					if (adjacencyCode3 == AdjacencyCode.Clear && Map.Get().InRange(point9) && map.At(point9).DoorSide == AdjacencyCode.CenterBottom)
					{
						adjacencyCode3 = AdjacencyCode.RightCenter;
						if (Map.Get().InRange(num21, num20 + 1))
						{
							map.At(num21, num20 + 1).IsNextToDoor = adjacencyCode3;
						}
					}
				}
				map.At(num21, num20).IsBehindDoor = adjacencyCode2;
				map.At(num21, num20).IsNextToDoor = adjacencyCode3;
			}
		}
		foreach (DeferredMiniTransition item3 in list)
		{
			Point cellPos = item3.cellPos;
			int x2 = cellPos.X;
			int y3 = cellPos.Y;
			Cell cell8 = map.CellMap[y3][x2];
			MapStyle style11 = Map.Get().Tags.GetStyle(mapStyles, cellPos);
			GameObject ceilingTransitionPrefab2 = style11.GetCeilingTransitionPrefab();
			float transitionHOffset2 = style11.transitionHOffset;
			float transHeight = style11.ceilingHeight - 1.0999999f;
			if (item3.transCode == AdjacencyCode.RightCenter && Cell.CheckAdjacencyClear(ceilingMiniTransitions[y3][x2], AdjacencyCode.RightCenter))
			{
				AddCeilingTransition(new Point(x2, y3), AdjacencyCode.RightCenter, ceilingTransitionPrefab2, transHeight, transitionHOffset2, 0f);
			}
			if (item3.transCode == AdjacencyCode.LeftCenter && Cell.CheckAdjacencyClear(ceilingMiniTransitions[y3][x2 - 1], AdjacencyCode.RightCenter))
			{
				AddCeilingTransition(new Point(x2, y3), AdjacencyCode.LeftCenter, ceilingTransitionPrefab2, transHeight, transitionHOffset2, 0f);
			}
			if (item3.transCode == AdjacencyCode.CenterTop && Cell.CheckAdjacencyClear(ceilingMiniTransitions[y3 - 1][x2], AdjacencyCode.CenterBottom))
			{
				AddCeilingTransition(new Point(x2, y3), AdjacencyCode.CenterTop, ceilingTransitionPrefab2, transHeight, transitionHOffset2, 0f);
			}
			if (item3.transCode == AdjacencyCode.CenterBottom && Cell.CheckAdjacencyClear(ceilingMiniTransitions[y3][x2], AdjacencyCode.CenterBottom))
			{
				AddCeilingTransition(new Point(x2, y3), AdjacencyCode.CenterBottom, ceilingTransitionPrefab2, transHeight, transitionHOffset2, 0f);
			}
		}
		list.Clear();
		ceilingMiniTransitions = null;
		Debug.Log("Time - Generate::Doors " + (Time.realtimeSinceStartup - realtimeSinceStartup).ToString("F2"));
		realtimeSinceStartup = Time.realtimeSinceStartup;
		Debug.Log("Time - Generate::Geometry Atlas " + (Time.realtimeSinceStartup - realtimeSinceStartup).ToString("F2"));
		realtimeSinceStartup = Time.realtimeSinceStartup;
		Debug.Log("MapBuilder - Adding props");
		indexGenericProps = ProcessPropPrefabs(genericProps, vector2);
		indexHorrorProps = ProcessPropPrefabs(horrorProps, vector2);
		indexLightProps = ProcessPropPrefabs(lightProps, vector2);
		indexTreasuryProps = ProcessPropPrefabs(treasuryProps, vector2);
		PlacedLightSafe = false;
		Dictionary<int, PropInfo> propGroups = new Dictionary<int, PropInfo>();
		Debug.Log("Time - Generate::ProcessPropPrefabs " + (Time.realtimeSinceStartup - realtimeSinceStartup).ToString("F2"));
		realtimeSinceStartup = Time.realtimeSinceStartup;
		List<GameObject> list4 = new List<GameObject>();
		System.Random random = new System.Random(UnityEngine.Random.seed);
		SWallInfo wallInfo = default(SWallInfo);
		foreach (RoomTemplate.PropMarker propPosition in map.PropPositions)
		{
			Point tile = propPosition.pos.ToPoint();
			Room room2 = map.CellMap[tile.Y][tile.X].Room;
			bool flag8 = false;
			int num22 = 0;
			while (!flag8 && num22 < reservedNoProp.Count)
			{
				if (propPosition.IsPositionInside(reservedNoProp[num22]))
				{
					flag8 = true;
				}
				num22++;
			}
			if (flag8)
			{
				continue;
			}
			wallInfo.bWallLeft = !map.CellMap[tile.Y][tile.X - 1].IsClearOrPit();
			wallInfo.bWallRight = !map.CellMap[tile.Y][tile.X + propPosition.width].IsClearOrPit();
			wallInfo.bWallUp = !map.CellMap[tile.Y - 1][tile.X].IsClearOrPit();
			wallInfo.bWallDown = !map.CellMap[tile.Y + propPosition.height][tile.X].IsClearOrPit();
			wallInfo.bHasWall = wallInfo.bWallLeft || wallInfo.bWallRight || wallInfo.bWallUp || wallInfo.bWallDown;
			bool bRotate = false;
			PropInfo propInfo;
			GameObject gameObject12 = SelectPropPrefab(propPosition, room2, wallInfo, out propInfo, out bRotate, propGroups);
			if (!gameObject12)
			{
				continue;
			}
			bool removeFloor = propInfo.removeFloor;
			bool removeCeiling = propInfo.removeCeiling;
			bool hanging = propInfo.hanging;
			bool ignoreWallMargin = propInfo.ignoreWallMargin;
			bool wallProp = propInfo.WallProp;
			Vector3 localPosition3 = new Vector3((float)tile.X * vector2.x, 0f, (float)(-tile.Y) * vector2.y);
			localPosition3 += new Vector3(vector2.x / 2f, 0f, (0f - vector2.y) / 2f);
			if (flag5 && !hanging && !wallProp && !ignoreWallMargin && !removeFloor && !propInfo.isRockColumnBottom)
			{
				MapStyle style12 = Map.Get().Tags.GetStyle(mapStyles, tile);
				if (style12.floorNoise)
				{
					localPosition3.y += 0.06f;
				}
			}
			Vector3 propDirection = GetPropDirection(propPosition, wallInfo);
			Vector3 zero = Vector3.zero;
			float num23 = 0f;
			float num24 = 0f;
			float num25 = 0f;
			float num26 = 0f;
			if (!ignoreWallMargin && (propPosition.width == 1 || propPosition.height == 1))
			{
				bool bWallLeft = wallInfo.bWallLeft;
				bool bWallRight = wallInfo.bWallRight;
				bool bWallUp = wallInfo.bWallUp;
				bool bWallDown = wallInfo.bWallDown;
				bool flag9 = !map.CellMap[tile.Y - 1][tile.X - 1].IsClearOrPit();
				bool flag10 = !map.CellMap[tile.Y - 1][tile.X + propPosition.width].IsClearOrPit();
				bool flag11 = !map.CellMap[tile.Y + propPosition.height][tile.X - 1].IsClearOrPit();
				bool flag12 = !map.CellMap[tile.Y + propPosition.height][tile.X + propPosition.width].IsClearOrPit();
				bool flag13 = wallInfo.GetNumWalls() >= 3;
				bool flag14 = !wallInfo.bWallLeft && map.CellMap[tile.Y][tile.X - 1].Occupied;
				bool flag15 = !wallInfo.bWallRight && map.CellMap[tile.Y][tile.X + 1].Occupied;
				bool flag16 = !wallInfo.bWallUp && map.CellMap[tile.Y - 1][tile.X].Occupied;
				bool flag17 = !wallInfo.bWallDown && map.CellMap[tile.Y + 1][tile.X].Occupied;
				if (bWallLeft)
				{
					bool flag18 = wallInfo.bWallLeft && (wallInfo.bWallUp || wallInfo.bWallDown);
					bool flag19 = (!flag9 || !flag11) && !flag13;
					bool flag20 = (!flag9 || !flag11) && flag13 && propPosition.height == 1;
					MapStyle style13 = Map.Get().Tags.GetStyle(mapStyles, tile);
					float num27 = style13.propMargin + ((!flag18) ? 0f : style13.propMarginInCorner);
					if (flag20 && !flag19 && !propInfo.ignoreOutCornerLatMargin)
					{
						num27 += style13.propMarginOutCornerLat;
					}
					if (flag15 && !bWallRight)
					{
						num27 *= 0.5f;
					}
					num23 += num27;
					num27 += ((!flag19) ? 0f : style13.propMarginOutCorner) * ((!flag15 || bWallRight) ? 1f : 0.5f);
					zero.x += num27;
				}
				else if (propInfo.notInNarrowDeadend && flag13)
				{
					zero.x += Map.Get().Tags.GetStyle(mapStyles, tile).propMargin;
				}
				if (bWallRight)
				{
					bool flag21 = wallInfo.bWallRight && (wallInfo.bWallUp || wallInfo.bWallDown);
					bool flag22 = (!flag10 || !flag12) && !flag13;
					bool flag23 = (!flag10 || !flag12) && flag13 && propPosition.height == 1;
					MapStyle style14 = Map.Get().Tags.GetStyle(mapStyles, new Point(tile.X + propPosition.width - 1, tile.Y));
					float num28 = style14.propMargin + ((!flag21) ? 0f : style14.propMarginInCorner);
					if (flag23 && !flag22 && !propInfo.ignoreOutCornerLatMargin)
					{
						num28 += style14.propMarginOutCornerLat;
					}
					if (flag14 && !bWallLeft)
					{
						num28 *= 0.5f;
					}
					num24 = num23 - num28;
					num23 += num28;
					num28 += ((!flag22) ? 0f : style14.propMarginOutCorner) * ((!flag14 || bWallLeft) ? 1f : 0.5f);
					zero.x -= num28;
				}
				else if (propInfo.notInNarrowDeadend && flag13)
				{
					zero.x -= Map.Get().Tags.GetStyle(mapStyles, tile).propMargin;
				}
				if (bWallUp)
				{
					bool flag24 = wallInfo.bWallUp && (wallInfo.bWallLeft || wallInfo.bWallRight);
					bool flag25 = (!flag9 || !flag10) && !flag13;
					bool flag26 = (!flag9 || !flag10) && flag13 && propPosition.width == 1;
					MapStyle style15 = Map.Get().Tags.GetStyle(mapStyles, tile);
					float num29 = style15.propMargin + ((!flag24) ? 0f : style15.propMarginInCorner);
					if (flag26 && !flag25 && !propInfo.ignoreOutCornerLatMargin)
					{
						num29 += style15.propMarginOutCornerLat;
					}
					if (flag17 && !bWallDown)
					{
						num29 *= 0.5f;
					}
					num25 += num29;
					num29 += ((!flag25) ? 0f : style15.propMarginOutCorner) * ((!flag17 || bWallDown) ? 1f : 0.5f);
					zero.z -= num29;
				}
				else if (propInfo.notInNarrowDeadend && flag13)
				{
					zero.z -= Map.Get().Tags.GetStyle(mapStyles, tile).propMargin;
				}
				if (bWallDown)
				{
					bool flag27 = wallInfo.bWallDown && (wallInfo.bWallLeft || wallInfo.bWallRight);
					bool flag28 = (!flag11 || !flag12) && !flag13;
					bool flag29 = (!flag11 || !flag12) && flag13 && propPosition.width == 1;
					MapStyle style16 = Map.Get().Tags.GetStyle(mapStyles, new Point(tile.X, tile.Y + propPosition.height - 1));
					float num30 = style16.propMargin + ((!flag27) ? 0f : style16.propMarginInCorner);
					if (flag29 && !flag28 && !propInfo.ignoreOutCornerLatMargin)
					{
						num30 += style16.propMarginOutCornerLat;
					}
					if (flag16 && !bWallUp)
					{
						num30 *= 0.5f;
					}
					num26 = num25 - num30;
					num25 += num30;
					num30 += ((!flag28) ? 0f : style16.propMarginOutCorner) * ((!flag16 || bWallUp) ? 1f : 0.5f);
					zero.z += num30;
				}
				else if (propInfo.notInNarrowDeadend && flag13)
				{
					zero.z += Map.Get().Tags.GetStyle(mapStyles, tile).propMargin;
				}
				zero *= propInfo.wallMarginFactor;
				num23 *= propInfo.wallMarginFactor;
				num25 *= propInfo.wallMarginFactor;
				num24 *= propInfo.wallMarginFactor;
				num26 *= propInfo.wallMarginFactor;
				if ((bWallLeft && bWallRight) || (bWallLeft && flag15) || (bWallRight && flag14))
				{
					float num31 = num23;
					num23 = (1.5f * (float)propPosition.width - num23) / (1.5f * (float)propPosition.width);
					num23 = (1f + num23) / 2f;
				}
				else
				{
					num23 = (num24 = 0f);
				}
				if ((bWallDown && bWallUp) || (bWallDown && flag16) || (bWallUp && flag17))
				{
					float num32 = num25;
					num25 = (1.5f * (float)propPosition.height - num25) / (1.5f * (float)propPosition.height);
					num25 = (1f + num25) / 2f;
				}
				else
				{
					num25 = (num26 = 0f);
				}
			}
			AdjacencyCode adjacencyCode4 = AdjacencyCode.Clear;
			for (int num33 = propPosition.pos.Y; num33 < propPosition.pos.Y + propPosition.height; num33++)
			{
				for (int num34 = propPosition.pos.X; num34 < propPosition.pos.X + propPosition.width; num34++)
				{
					if (map.CellMap[num33][num34].IsNextToDoor != 0)
					{
						adjacencyCode4 |= map.CellMap[num33][num34].IsNextToDoor;
					}
				}
			}
			if (adjacencyCode4 != 0)
			{
				if ((adjacencyCode4 & AdjacencyCode.LeftCenter) != 0)
				{
					zero.x = Mathf.Max(zero.x, -0.22f);
				}
				if ((adjacencyCode4 & AdjacencyCode.RightCenter) != 0)
				{
					zero.x = Mathf.Min(zero.x, 0.22f);
				}
				if ((adjacencyCode4 & AdjacencyCode.CenterTop) != 0)
				{
					zero.z = Mathf.Min(zero.z, 0.22f);
				}
				if ((adjacencyCode4 & AdjacencyCode.CenterBottom) != 0)
				{
					zero.z = Mathf.Max(zero.z, -0.22f);
				}
			}
			bool skipIfInCorner = false;
			float latFactor = 1f;
			float pushOutCornerDelta = propInfo.GetPushOutCornerDelta(Map.Get().Tags.GetStyle(mapStyles, tile).styleName, out skipIfInCorner, out latFactor);
			if (wallInfo.IsInCorner())
			{
				if (skipIfInCorner)
				{
					continue;
				}
			}
			else
			{
				latFactor = 1f;
			}
			if (propInfo.applyLateralMargins)
			{
				float num35 = Vector3.Dot(zero, propDirection);
				zero -= num35 * propDirection;
				zero *= latFactor;
			}
			if ((pushOutCornerDelta > 0.001f || pushOutCornerDelta < 0.001f) && wallInfo.GetNumWalls() < 3)
			{
				bool flag30 = !map.CellMap[tile.Y - 1][tile.X - 1].IsClearOrPit();
				bool flag31 = !map.CellMap[tile.Y - 1][tile.X + propPosition.width].IsClearOrPit();
				bool flag32 = !map.CellMap[tile.Y + propPosition.height][tile.X - 1].IsClearOrPit();
				bool flag33 = !map.CellMap[tile.Y + propPosition.height][tile.X + propPosition.width].IsClearOrPit();
				if (propDirection.x >= 0.9f && wallInfo.bWallLeft && (!flag30 || !flag32))
				{
					zero.x += pushOutCornerDelta;
				}
				else if (propDirection.x <= -0.9f && wallInfo.bWallRight && (!flag31 || !flag33))
				{
					zero.x -= pushOutCornerDelta;
				}
				else if (propDirection.z <= -0.9f && wallInfo.bWallUp && (!flag30 || !flag31))
				{
					zero.z -= pushOutCornerDelta;
				}
				else if (propDirection.z >= 0.9f && wallInfo.bWallDown && (!flag32 || !flag33))
				{
					zero.z += pushOutCornerDelta;
				}
			}
			GameObject gameObject13 = UnityEngine.Object.Instantiate(gameObject12);
			gameObject13.name = gameObject12.name + "_" + room2.props.Count;
			if (propPosition.width == 1 && propPosition.height == 1)
			{
				gameObject13.transform.rotation = Quaternion.LookRotation(propDirection) * Quaternion.AngleAxis(-90f, Vector3.up);
				if (wallProp)
				{
					Vector3 wallDecoDeltaVector = propInfo.GetWallDecoDeltaVector(Map.Get().Tags.GetStyle(mapStyles, tile).styleName);
					wallDecoDeltaVector = Quaternion.LookRotation(propDirection) * Quaternion.AngleAxis(180f, Vector3.up) * wallDecoDeltaVector;
					zero += wallDecoDeltaVector;
				}
			}
			else
			{
				if (bRotate)
				{
					gameObject13.transform.rotation = Quaternion.AngleAxis(90f, Vector3.up);
					if (propInfo.SizeX > 1 && propInfo.SizeY > 1)
					{
						int num36 = propInfo.SizeY - 1;
						localPosition3 += Vector3.right * vector2.x * num36;
					}
				}
				bool flag34 = propPosition.width >= propPosition.height;
				bool flag35 = propPosition.direction != 0 && propPosition.direction != RoomTemplate.PropMarker.Direction.Down && propPosition.direction != RoomTemplate.PropMarker.Direction.Left;
				if (((flag34 && wallInfo.bWallDown) || (!flag34 && wallInfo.bWallLeft) || flag35) && propPosition.width != propPosition.height && (propPosition.width == 1 || propPosition.height == 1))
				{
					int num37 = ((!flag34) ? (propPosition.height - 1) : (propPosition.width - 1));
					gameObject13.transform.rotation *= Quaternion.AngleAxis(180f, Vector3.up);
					localPosition3 += -gameObject13.transform.right * vector2.x * num37;
				}
			}
			if (hanging)
			{
				MapStyle style17 = Map.Get().Tags.GetStyle(mapStyles, propPosition.pos.ToPoint());
				localPosition3.y = style17.ceilingHeight + style17.hangingOffset;
			}
			localPosition3 += zero;
			localPosition3.x += propPosition.deltaOffset.x;
			localPosition3.z -= propPosition.deltaOffset.y;
			if (gameObject13.layer == (int)propLayer)
			{
				gameObject13.transform.parent = gameObject.transform;
			}
			else
			{
				gameObject13.transform.parent = mapGeometry.transform;
			}
			gameObject13.transform.localPosition = localPosition3;
			bool flag36 = propInfo.SizeX == 1 && propInfo.SizeY == 1;
			if (propInfo.squeeze && num23 > 0f)
			{
				gameObject13.transform.localScale = new Vector3(gameObject13.transform.localScale.x * ((!flag36) ? num23 : 1f), gameObject13.transform.localScale.y, gameObject13.transform.localScale.z * ((!flag36) ? 1f : num23));
				if (!flag36)
				{
					Vector3 vector3 = gameObject13.transform.TransformDirection(Vector3.right);
					gameObject13.transform.localPosition += vector3 * (1.5f - 1.5f * num23) / 2f;
					gameObject13.transform.localPosition -= vector3 * num24 * num23 * 0.5f;
				}
			}
			if (propInfo.squeeze && num25 > 0f)
			{
				gameObject13.transform.localScale = new Vector3(gameObject13.transform.localScale.x * ((!flag36) ? num25 : 1f), gameObject13.transform.localScale.y, gameObject13.transform.localScale.z * ((!flag36) ? 1f : num25));
				if (!flag36)
				{
					Vector3 vector4 = gameObject13.transform.TransformDirection(Vector3.right);
					gameObject13.transform.localPosition += vector4 * (1.5f - 1.5f * num25) / 2f;
					gameObject13.transform.localPosition -= vector4 * num26 * num25 * 0.5f;
				}
			}
			PropInfo component2 = gameObject13.GetComponent<PropInfo>();
			room2.props.Add(component2);
			if (component2.castsLight)
			{
				room2.numLightcasters++;
			}
			if (component2.isGargoyle)
			{
				room2.gargoyles.Add(gameObject13);
			}
			if (component2.keepFrontClear || component2.isGargoyle)
			{
				Point item = map.WorldToCell(gameObject13.transform.position + propDirection * 1.5f);
				reservedNoProp.Add(item);
			}
			if (component2.makeRoomSafe)
			{
				room2.Safe = true;
			}
			if (component2.maxInMap > 0)
			{
				int value = 0;
				propCount.TryGetValue(gameObject12, out value);
				propCount[gameObject12] = value + 1;
			}
			if (component2.addVerticalOffset)
			{
				float y4 = (float)(random.NextDouble() * 0.025);
				gameObject13.transform.localPosition += new Vector3(0f, y4, 0f);
			}
			list4.Add(gameObject13);
			MapChunk.AddGeometry(gameObject13, propPosition.pos.ToPoint(), propPosition.width, propPosition.height, cullMask);
			if (gameObject13.layer == (int)propLayer)
			{
				StripNonStatic(gameObject13.transform, mapGeometry.transform);
			}
			if (removeFloor || removeCeiling)
			{
				for (int num38 = propPosition.pos.Y; num38 < propPosition.pos.Y + propPosition.height; num38++)
				{
					for (int num39 = propPosition.pos.X; num39 < propPosition.pos.X + propPosition.width; num39++)
					{
						MapChunk mapChunk3 = MapChunk.At(num39, num38);
						if (removeFloor && array4[num38][num39] != null)
						{
							mapChunk3.RemoveGeometry(array4[num38][num39], removeFromCombineList: true);
							UnityEngine.Object.Destroy(array4[num38][num39]);
							array4[num38][num39] = null;
						}
						if (removeCeiling && array3[num38][num39] != null)
						{
							mapChunk3.RemoveGeometry(array3[num38][num39], removeFromCombineList: true);
							UnityEngine.Object.Destroy(array3[num38][num39]);
							array3[num38][num39] = null;
						}
					}
				}
			}
			if (propInfo.canWalkThrough)
			{
				for (int num40 = propPosition.pos.Y; num40 < propPosition.pos.Y + propPosition.height; num40++)
				{
					for (int num41 = propPosition.pos.X; num41 < propPosition.pos.X + propPosition.width; num41++)
					{
						Map.Get().At(num41, num40).Occupied = !Map.Get().At(num41, num40).IsClear();
					}
				}
			}
			if (propInfo.canFloatOver)
			{
				for (int num42 = propPosition.pos.Y; num42 < propPosition.pos.Y + propPosition.height; num42++)
				{
					for (int num43 = propPosition.pos.X; num43 < propPosition.pos.X + propPosition.width; num43++)
					{
						Map.Get().At(num43, num42).CanFloatOver = true;
					}
				}
			}
			gameObject13.GetComponent<PropInfo>().PropMarker = propPosition;
		}
		Debug.Log("Time - Generate::Props " + (Time.realtimeSinceStartup - realtimeSinceStartup).ToString("F2"));
		realtimeSinceStartup = Time.realtimeSinceStartup;
		Debug.Log("Time - Generate::Props Atlas " + (Time.realtimeSinceStartup - realtimeSinceStartup).ToString("F2"));
		realtimeSinceStartup = Time.realtimeSinceStartup;
		for (int num44 = 0; num44 < width; num44++)
		{
			for (int num45 = 0; num45 < height; num45++)
			{
				Cell cell9 = map.CellMap[num45][num44];
				if (cell9.IsClear() && ((!cell9.Occupied && cell9.IsClear()) || cell9.IsCorridor()) && (cell9.Room == null || !cell9.Room.Safe) && UnityEngine.Random.value < 0.2f && !(map.CellMap[num45][num44 - 1].Door != null) && !(map.CellMap[num45][num44 + 1].Door != null) && !(map.CellMap[num45 - 1][num44].Door != null) && !(map.CellMap[num45 + 1][num44].Door != null))
				{
					GameObject gameObject14 = UnityEngine.Object.Instantiate(ghostSpawnPrefab);
					gameObject14.name = "spawn_" + num44 + "_" + num45;
					gameObject14.transform.parent = ghostSpawns.transform;
					Vector3 localPosition4 = new Vector3((float)num44 * vector2.x, 0f, (float)(-num45) * vector2.y);
					localPosition4 += new Vector3(vector2.x / 2f, 0f, (0f - vector2.y) / 2f);
					gameObject14.transform.localPosition = localPosition4;
					cell9.Spawn = gameObject14.GetComponent<VisibilityProbe>();
				}
			}
		}
		Debug.Log("Time - Generate::Spawners " + (Time.realtimeSinceStartup - realtimeSinceStartup).ToString("F2"));
		realtimeSinceStartup = Time.realtimeSinceStartup;
		if (flag5)
		{
			FloorNoise.AddFloorNoise(map, array4, this);
		}
		if (flag6)
		{
			FloorNoise.AddCeilingNoise(map, array3, this);
		}
		for (int num46 = 0; num46 < edgeCollapses.Count; num46++)
		{
			Vector3 vector5 = map.CellToWorld(edgeCollapses[num46].tile);
			List<MeshFilter> toCombine = MapChunk.At(edgeCollapses[num46].tile).toCombine;
			for (int num47 = 0; num47 < toCombine.Count; num47++)
			{
				MeshFilter meshFilter = toCombine[num47];
				float sqrMagnitude = (meshFilter.transform.position - vector5).sqrMagnitude;
				if (sqrMagnitude <= 0.5625f && Utils.IsAncestor(toCombine[num47].transform, wallContainer.transform))
				{
					FloorNoise.CollapseEdge(meshFilter, edgeCollapses[num46].edge);
				}
			}
			Debug.DrawLine(edgeCollapses[num46].edge, edgeCollapses[num46].edge + Vector3.up * 3f, Color.red, 5f);
			Vector3 vector6 = map.CellToWorld(edgeCollapses[num46].tile);
			Debug.DrawLine(vector6, vector6 + Vector3.up, Color.red, 5f);
		}
		Debug.Log("MapBuilder - Combining static meshes");
		ChunkMesh.BuildMeshes(gameObject);
		StaticBatchingUtility.Combine(gameObject);
		tempWallList = null;
		Debug.Log("Time - Generate::Combine geometry " + (Time.realtimeSinceStartup - realtimeSinceStartup).ToString("F2"));
		for (int num48 = 0; num48 < map.Rooms.Count; num48++)
		{
			map.Rooms[num48].BuildValidPosLists();
		}
		realtimeSinceStartup = Time.realtimeSinceStartup;
		Debug.Log("MapBuilder - Positioning player");
		GameObject gameObject15 = Player.Get();
		if ((bool)gameObject15 && positionPlayer)
		{
			gameObject15.transform.position = vector;
			Point pos = Map.Get().WorldToCell(vector);
			Room room3 = Map.Get().At(pos).Room;
			if (room3 != null && (room3.doors.Count > 0 || room3.entrances.Count > 0))
			{
				Point cellPos2 = ((room3.doors.Count <= 0) ? room3.entrances[0] : room3.doors[0]);
				Vector3 vec = (Map.Get().CellToWorld(cellPos2) - vector).GroundNormalize();
				gameObject15.transform.rotation = Quaternion.LookRotation(vec.MajorAxis(), Vector3.up);
			}
			else
			{
				bool flag37 = !Map.Get().At(pos.X - 1, pos.Y).IsClear() || !Map.Get().At(pos.X - 2, pos.Y).IsClear();
				bool flag38 = !Map.Get().At(pos.X + 1, pos.Y).IsClear() || !Map.Get().At(pos.X + 2, pos.Y).IsClear();
				bool flag39 = !Map.Get().At(pos.X, pos.Y - 1).IsClear() || !Map.Get().At(pos.X, pos.Y - 2).IsClear();
				bool flag40 = !Map.Get().At(pos.X, pos.Y + 1).IsClear() || !Map.Get().At(pos.X, pos.Y + 2).IsClear();
				if (!flag37 || !flag38 || !flag39 || !flag40)
				{
					Vector3 forward = Vector3.right;
					if (!flag37)
					{
						forward = new Vector3(-1f, 0f, 0f);
					}
					else if (!flag38)
					{
						forward = new Vector3(1f, 0f, 0f);
					}
					else if (!flag39)
					{
						forward = new Vector3(0f, 0f, 1f);
					}
					else if (!flag40)
					{
						forward = new Vector3(0f, 0f, -1f);
					}
					gameObject15.transform.rotation = Quaternion.LookRotation(forward, Vector3.up);
				}
			}
		}
		Debug.Log("MapBuilder - Map succesfully generated");
		GC.Collect();
		return mapGeometry;
	}

	private GameObject SelectPropPrefab(RoomTemplate.PropMarker prop, Room room, SWallInfo wallInfo, out PropInfo propInfo, out bool bRotate, Dictionary<int, PropInfo> propGroups)
	{
		GameObject gameObject = null;
		GameObject gameObject2 = null;
		propInfo = null;
		bRotate = false;
		if (prop.exitMarker == OptionFlag.Yes)
		{
			gameObject = ((!(levelOptions.exitPrefab != null)) ? exitPrefab : levelOptions.exitPrefab);
			propInfo = gameObject.GetComponent<PropInfo>();
			gameObject2 = gameObject;
		}
		else if (prop.exitCollectable == OptionFlag.Yes)
		{
			gameObject = levelOptions.exitCollectablePrefab;
			if (!gameObject)
			{
				return null;
			}
			propInfo = gameObject.GetComponent<PropInfo>();
			gameObject2 = gameObject;
		}
		else if (prop.propInfo != null)
		{
			gameObject = prop.propInfo.gameObject;
			propInfo = gameObject.GetComponent<PropInfo>();
			if (new Point(Mathf.Max(prop.width, prop.height), Mathf.Min(prop.width, prop.height)).X != prop.width)
			{
				bRotate = true;
			}
			gameObject2 = gameObject;
			if (propInfo.minCeilingHeight > 0.5f && propInfo.minCeilingHeight > Map.Get().Tags.GetStyle(mapStyles, prop.pos.ToPoint()).ceilingHeight)
			{
				return null;
			}
		}
		else
		{
			Point key = new Point(Mathf.Max(prop.width, prop.height), Mathf.Min(prop.width, prop.height));
			int num = 7;
			if (room.IsDeadEnd && !room.IsSpawnRoom && !room.IsExitRoom)
			{
				num = 15;
			}
			for (int i = 0; i < num; i++)
			{
				bool flag = false;
				float value = UnityEngine.Random.value;
				Dictionary<Point, List<GameObject>> dictionary;
				if (room != null && room.Safe)
				{
					bool flag2 = prop.lightCaster != OptionFlag.No;
					flag2 &= room.numLightcasters <= room.Template.flags.maxLightcasters;
					if (PlacedLightSafe || !flag2 || !flag2)
					{
						dictionary = (((!(value < 0.1f) || !flag2) && prop.lightCaster != OptionFlag.Yes) ? indexGenericProps : indexLightProps);
					}
					else
					{
						dictionary = indexLightProps;
						flag = true;
					}
				}
				else
				{
					float num2 = 0.03f;
					float num3 = 0.4f;
					bool flag3 = false;
					if (room.IsDeadEnd && (room.Template.size == RoomTemplate.SizeType.Small || room.Template.size == RoomTemplate.SizeType.Medium) && !room.IsSpawnRoom && !room.IsExitRoom)
					{
						num3 = 0.2f;
						flag3 = true;
					}
					bool flag4 = prop.lightCaster != OptionFlag.No;
					flag4 &= room.numLightcasters <= room.Template.flags.maxLightcasters;
					dictionary = ((flag3 && value <= 0.4f) ? indexTreasuryProps : (((!(value < num2) || !flag4) && prop.lightCaster != OptionFlag.Yes) ? (((!(value <= num3) || prop.horror == OptionFlag.No) && prop.horror != OptionFlag.Yes) ? indexGenericProps : indexHorrorProps) : indexLightProps));
				}
				if (!dictionary.ContainsKey(key))
				{
					continue;
				}
				List<GameObject> list = dictionary[key];
				gameObject = list[UnityEngine.Random.Range(0, list.Count)];
				propInfo = gameObject.GetComponent<PropInfo>();
				if (prop.groupIndex != -1)
				{
					int key2 = room.Id * 1000 + prop.groupIndex;
					PropInfo value2 = null;
					if (propGroups.TryGetValue(key2, out value2))
					{
						propInfo = value2;
						gameObject = propInfo.gameObject;
					}
					else
					{
						propGroups.Add(key2, propInfo);
					}
				}
				if ((bool)propInfo)
				{
					MapStyle style = Map.Get().Tags.GetStyle(mapStyles, prop.pos.ToPoint());
					if (propInfo.disabledProp || (propInfo.WallProp && !wallInfo.bHasWall) || (propInfo.WallProp && prop.wallProp == OptionFlag.No) || (propInfo.standAlone && wallInfo.bHasWall))
					{
						continue;
					}
					if (key.X != prop.width)
					{
						bRotate = true;
					}
					if ((propInfo.isGargoyle && !levelOptions.gargoyles) || (propInfo.isGargoyle && room.IsExitRoom) || (!propInfo.canPlaceInSpawnRoom && room.IsSpawnRoom))
					{
						continue;
					}
					if (propInfo.notBehindDoor)
					{
						Point point = new Point(prop.pos.X - 1, prop.pos.Y + 1);
						Point point2 = new Point(prop.pos.X + 1, prop.pos.Y + 1);
						Point point3 = new Point(prop.pos.X - 1, prop.pos.Y - 1);
						Point point4 = new Point(prop.pos.X + 1, prop.pos.Y - 1);
						bool flag5 = false;
						if (!flag5 && Map.Get().InRange(point))
						{
							flag5 = Map.Get().At(point).Door != null;
						}
						if (!flag5 && Map.Get().InRange(point2))
						{
							flag5 = Map.Get().At(point2).Door != null;
						}
						if (!flag5 && Map.Get().InRange(point3))
						{
							flag5 = Map.Get().At(point3).Door != null;
						}
						if (!flag5 && Map.Get().InRange(point4))
						{
							flag5 = Map.Get().At(point4).Door != null;
						}
						if (!flag5)
						{
							Point exitPosition = Map.Get().ExitPosition;
							flag5 = exitPosition == new Point(prop.pos.X - 1, prop.pos.Y) || exitPosition == new Point(prop.pos.X + 1, prop.pos.Y) || exitPosition == new Point(prop.pos.X, prop.pos.Y - 1) || exitPosition == new Point(prop.pos.X, prop.pos.Y + 1);
						}
						if (flag5)
						{
							continue;
						}
					}
					if (propInfo.WallProp && !style.allowWallPropsInCorners)
					{
						Cell cell = Map.Get().At(prop.pos.ToPoint());
						if (cell.GetNumAdjacentWallsNoCorners() > 1)
						{
							continue;
						}
					}
					if (wallInfo.bHasWall)
					{
						int wallSkipMax = propInfo.GetWallSkipMax(style.styleName);
						if (wallSkipMax >= 0 && wallInfo.GetNumWalls() > wallSkipMax)
						{
							continue;
						}
					}
					if (propInfo.minCeilingHeight > 0.5f && propInfo.minCeilingHeight > style.ceilingHeight)
					{
						continue;
					}
					if (propInfo.notInDeadend || propInfo.notInNarrowDeadend || propInfo.requireHighCeiling)
					{
						Cell cell2 = Map.Get().At(prop.pos.ToPoint());
						if (cell2.GetNumAdjacentWallsNoCorners() == 3 && (propInfo.notInDeadend || (propInfo.notInNarrowDeadend && style.hasNarrowDeadends) || (propInfo.requireHighCeiling && style.arched && style.ceilingHeight <= 3.5f)))
						{
							continue;
						}
						if ((propInfo.notInNarrowDeadend || propInfo.requireHighCeiling) && style.arched)
						{
							bool flag6 = cell2.CheckAdjacency(AdjacencyCode.LeftCenter) && cell2.CheckAdjacency(AdjacencyCode.RightCenter);
							flag6 |= cell2.CheckAdjacency(AdjacencyCode.CenterTop) && cell2.CheckAdjacency(AdjacencyCode.CenterBottom);
							flag6 |= cell2.CheckAdjacency(AdjacencyCode.LeftCenter) && cell2.CheckAdjacency(AdjacencyCode.CenterTop) && cell2.CheckAdjacency(AdjacencyCode.RightBottom);
							flag6 |= cell2.CheckAdjacency(AdjacencyCode.CenterTop) && cell2.CheckAdjacency(AdjacencyCode.RightCenter) && cell2.CheckAdjacency(AdjacencyCode.LeftBottom);
							flag6 |= cell2.CheckAdjacency(AdjacencyCode.LeftTop) && cell2.CheckAdjacency(AdjacencyCode.RightCenter) && cell2.CheckAdjacency(AdjacencyCode.CenterBottom);
							if (flag6 | (cell2.CheckAdjacency(AdjacencyCode.LeftCenter) && cell2.CheckAdjacency(AdjacencyCode.RightTop) && cell2.CheckAdjacency(AdjacencyCode.CenterBottom)))
							{
								continue;
							}
						}
					}
					if ((propInfo.notInHubInCorner && room.Template.size == RoomTemplate.SizeType.Hub && Map.Get().At(prop.pos.ToPoint()).GetNumAdjacentWallsNoCorners() > 1) || (propInfo.hanging && Map.Get().At(prop.pos.ToPoint()).CeilingShaft) || (propInfo.isRockColumnBottom && !style.allowRockColumnsBottom) || (propInfo.isRockColumnTop && !style.allowRockColumnsTop))
					{
						continue;
					}
					if (propInfo.maxInRoom > 0)
					{
						int num4 = 0;
						for (int j = 0; j < room.props.Count; j++)
						{
							if (propInfo.name == room.props[j].name)
							{
								num4++;
							}
						}
						if (num4 >= propInfo.maxInRoom)
						{
							continue;
						}
					}
					if (propInfo.maxInMap > 0)
					{
						int value3 = 0;
						propCount.TryGetValue(gameObject, out value3);
						if (value3 >= propInfo.maxInMap)
						{
							continue;
						}
					}
					if ((propInfo.requireStyleTag != string.Empty && style.GetMainTag() != propInfo.requireStyleTag) || (propInfo.disableInRandomMode && levelOptions.isRandomMode) || (!propInfo.roomSmall && room != null && room.Template.size == RoomTemplate.SizeType.Small) || (!propInfo.roomMedium && room != null && room.Template.size == RoomTemplate.SizeType.Medium) || (!propInfo.roomLarge && room != null && room.Template.size == RoomTemplate.SizeType.Large) || (!propInfo.roomHub && room != null && room.Template.size == RoomTemplate.SizeType.Hub))
					{
						continue;
					}
					if (propInfo.marginTop != 0 || propInfo.marginBottom != 0 || propInfo.marginLeft != 0 || propInfo.marginRight != 0)
					{
						RoomTemplate.PropMarker.Direction direction = ResolvePropDirection(prop, wallInfo);
						SPropMargins sPropMargins = default(SPropMargins);
						if (propInfo.SizeX == propInfo.SizeY && propInfo.SizeX == 1)
						{
							switch (direction)
							{
							case RoomTemplate.PropMarker.Direction.Right:
								sPropMargins = new SPropMargins(propInfo.marginLeft, propInfo.marginTop, propInfo.marginRight, propInfo.marginBottom);
								break;
							case RoomTemplate.PropMarker.Direction.Left:
								sPropMargins = new SPropMargins(propInfo.marginRight, propInfo.marginBottom, propInfo.marginLeft, propInfo.marginTop);
								break;
							case RoomTemplate.PropMarker.Direction.Down:
								sPropMargins = new SPropMargins(propInfo.marginBottom, propInfo.marginLeft, propInfo.marginTop, propInfo.marginRight);
								break;
							case RoomTemplate.PropMarker.Direction.Up:
								sPropMargins = new SPropMargins(propInfo.marginTop, propInfo.marginRight, propInfo.marginBottom, propInfo.marginLeft);
								break;
							}
						}
						else
						{
							switch (direction)
							{
							case RoomTemplate.PropMarker.Direction.Right:
								sPropMargins = new SPropMargins(propInfo.marginBottom, propInfo.marginLeft, propInfo.marginTop, propInfo.marginRight);
								break;
							case RoomTemplate.PropMarker.Direction.Left:
								sPropMargins = new SPropMargins(propInfo.marginTop, propInfo.marginRight, propInfo.marginBottom, propInfo.marginTop);
								break;
							case RoomTemplate.PropMarker.Direction.Down:
								sPropMargins = new SPropMargins(propInfo.marginRight, propInfo.marginBottom, propInfo.marginLeft, propInfo.marginTop);
								break;
							case RoomTemplate.PropMarker.Direction.Up:
								sPropMargins = new SPropMargins(propInfo.marginLeft, propInfo.marginTop, propInfo.marginRight, propInfo.marginBottom);
								break;
							}
						}
						bool flag7 = true;
						int num5 = -sPropMargins.marginTop;
						while (flag7 && num5 < prop.height + sPropMargins.marginBottom)
						{
							int num6 = -sPropMargins.marginLeft;
							while (flag7 && num6 < prop.width + sPropMargins.marginRight)
							{
								if (num6 < 0 || num6 >= prop.width || num5 < 0 || num5 >= prop.height)
								{
									Cell cell3 = map.At(prop.pos.X + num6, prop.pos.Y + num5);
									if (cell3 == null)
									{
										flag7 = false;
									}
									else if (!cell3.IsTransparent())
									{
										flag7 = false;
									}
								}
								num6++;
							}
							num5++;
						}
						if (!flag7)
						{
							continue;
						}
					}
					gameObject2 = gameObject;
				}
				if (flag)
				{
					PlacedLightSafe = true;
				}
				break;
			}
		}
		if (!gameObject2)
		{
			Debug.Log("Could not find a proper prop for (" + prop.width + ", " + prop.height + ")");
		}
		return gameObject2;
	}

	private Vector3 GetPropDirection(RoomTemplate.PropMarker prop, SWallInfo wallInfo)
	{
		RoomTemplate.PropMarker.Direction direction = ResolvePropDirection(prop, wallInfo);
		Vector3 result = new Vector3(0f, 0f, 1f);
		switch (direction)
		{
		case RoomTemplate.PropMarker.Direction.Down:
			result = new Vector3(0f, 0f, -1f);
			break;
		case RoomTemplate.PropMarker.Direction.Up:
			result = new Vector3(0f, 0f, 1f);
			break;
		case RoomTemplate.PropMarker.Direction.Right:
			result = new Vector3(1f, 0f, 0f);
			break;
		case RoomTemplate.PropMarker.Direction.Left:
			result = new Vector3(-1f, 0f, 0f);
			break;
		}
		return result;
	}

	private RoomTemplate.PropMarker.Direction ResolvePropDirection(RoomTemplate.PropMarker prop, SWallInfo wallInfo)
	{
		RoomTemplate.PropMarker.Direction direction = prop.direction;
		if (direction == RoomTemplate.PropMarker.Direction.Auto)
		{
			direction = ((wallInfo.bWallLeft && !wallInfo.bWallRight) ? RoomTemplate.PropMarker.Direction.Right : ((!wallInfo.bWallLeft && wallInfo.bWallRight) ? RoomTemplate.PropMarker.Direction.Left : ((!wallInfo.bWallUp || wallInfo.bWallDown) ? RoomTemplate.PropMarker.Direction.Up : RoomTemplate.PropMarker.Direction.Down)));
		}
		return direction;
	}

	private void BuildWalls(int x, int z, byte adjacency, MapStyle curStyle, MapChunk chunk, int variation, float fTileSize, string prefix = "WallSection", float yOffset = 0f, List<GameObject> listWalls = null)
	{
		listWalls?.Clear();
		if (Cell.CheckAdjacency(adjacency, AdjacencyCode.LeftCenter) && Cell.CheckAdjacencyClear(adjacency, (AdjacencyCode)66))
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(curStyle.lWallPrefabs[variation], Vector3.zero, Quaternion.identity);
			gameObject.name = prefix + "_lw_" + x + "_" + z;
			gameObject.transform.parent = wallContainer.transform;
			gameObject.transform.localPosition = new Vector3((float)x * fTileSize + fTileSize / 2f, yOffset, (float)(-z) * fTileSize - fTileSize / 2f);
			gameObject.transform.localRotation = rotLWallLeft;
			gameObject.layer = geometryLayer;
			gameObject.tag = Tags.MapGeometry;
			chunk.AddToCombine(gameObject);
			StripNonStatic(gameObject.transform, mapGeometry.transform);
			listWalls?.Add(gameObject);
		}
		if (Cell.CheckAdjacency(adjacency, AdjacencyCode.RightCenter) && Cell.CheckAdjacencyClear(adjacency, (AdjacencyCode)66))
		{
			GameObject gameObject2 = UnityEngine.Object.Instantiate(curStyle.lWallPrefabs[variation], Vector3.zero, Quaternion.identity);
			gameObject2.name = prefix + "_rw_" + x + "_" + z;
			gameObject2.transform.parent = wallContainer.transform;
			gameObject2.transform.localPosition = new Vector3((float)x * fTileSize + fTileSize / 2f, yOffset, (float)(-z) * fTileSize - fTileSize / 2f);
			gameObject2.transform.localRotation = rotLWallRight;
			gameObject2.layer = geometryLayer;
			gameObject2.tag = Tags.MapGeometry;
			chunk.AddToCombine(gameObject2);
			StripNonStatic(gameObject2.transform, mapGeometry.transform);
			listWalls?.Add(gameObject2);
		}
		if (Cell.CheckAdjacency(adjacency, AdjacencyCode.CenterTop) && Cell.CheckAdjacencyClear(adjacency, (AdjacencyCode)24))
		{
			GameObject gameObject3 = UnityEngine.Object.Instantiate(curStyle.lWallPrefabs[variation], Vector3.zero, Quaternion.identity);
			gameObject3.name = prefix + "_tw_" + x + "_" + z;
			gameObject3.transform.parent = wallContainer.transform;
			gameObject3.transform.localPosition = new Vector3((float)x * fTileSize + fTileSize / 2f, yOffset, (float)(-z) * fTileSize - fTileSize / 2f);
			gameObject3.transform.localRotation = rotLWallTop;
			gameObject3.layer = geometryLayer;
			gameObject3.tag = Tags.MapGeometry;
			chunk.AddToCombine(gameObject3);
			StripNonStatic(gameObject3.transform, mapGeometry.transform);
			listWalls?.Add(gameObject3);
		}
		if (Cell.CheckAdjacency(adjacency, AdjacencyCode.CenterBottom) && Cell.CheckAdjacencyClear(adjacency, (AdjacencyCode)24))
		{
			GameObject gameObject4 = UnityEngine.Object.Instantiate(curStyle.lWallPrefabs[variation], Vector3.zero, Quaternion.identity);
			gameObject4.name = prefix + "_bw_" + x + "_" + z;
			gameObject4.transform.parent = wallContainer.transform;
			gameObject4.transform.localPosition = new Vector3((float)x * fTileSize + fTileSize / 2f, yOffset, (float)(-z) * fTileSize - fTileSize / 2f);
			gameObject4.transform.localRotation = rotLWallBottom;
			gameObject4.layer = geometryLayer;
			gameObject4.tag = Tags.MapGeometry;
			chunk.AddToCombine(gameObject4);
			StripNonStatic(gameObject4.transform, mapGeometry.transform);
			listWalls?.Add(gameObject4);
		}
		if (Cell.CheckAdjacency(adjacency, (AdjacencyCode)10) && Cell.CheckAdjacencyClear(adjacency, (AdjacencyCode)80))
		{
			GameObject gameObject5 = UnityEngine.Object.Instantiate(curStyle.inCornerPrefab, Vector3.zero, Quaternion.identity);
			gameObject5.name = prefix + "_ic_lt_" + x + "_" + z;
			gameObject5.transform.parent = wallContainer.transform;
			gameObject5.transform.localPosition = new Vector3((float)x * fTileSize + fTileSize / 2f, yOffset, (float)(-z) * fTileSize - fTileSize / 2f);
			gameObject5.transform.localRotation = rotInCornerLeftTop;
			gameObject5.layer = geometryLayer;
			gameObject5.tag = Tags.MapGeometry;
			chunk.AddToCombine(gameObject5);
			StripNonStatic(gameObject5.transform, mapGeometry.transform);
			listWalls?.Add(gameObject5);
		}
		if (Cell.CheckAdjacency(adjacency, (AdjacencyCode)18) && Cell.CheckAdjacencyClear(adjacency, (AdjacencyCode)72))
		{
			GameObject gameObject6 = UnityEngine.Object.Instantiate(curStyle.inCornerPrefab, Vector3.zero, Quaternion.identity);
			gameObject6.name = prefix + "_ic_rt_" + x + "_" + z;
			gameObject6.transform.parent = wallContainer.transform;
			gameObject6.transform.localPosition = new Vector3((float)x * fTileSize + fTileSize / 2f, yOffset, (float)(-z) * fTileSize - fTileSize / 2f);
			gameObject6.transform.localRotation = rotInCornerRightTop;
			gameObject6.layer = geometryLayer;
			gameObject6.tag = Tags.MapGeometry;
			chunk.AddToCombine(gameObject6);
			StripNonStatic(gameObject6.transform, mapGeometry.transform);
			listWalls?.Add(gameObject6);
		}
		if (Cell.CheckAdjacency(adjacency, (AdjacencyCode)72) && Cell.CheckAdjacencyClear(adjacency, (AdjacencyCode)18))
		{
			GameObject gameObject7 = UnityEngine.Object.Instantiate(curStyle.inCornerPrefab, Vector3.zero, Quaternion.identity);
			gameObject7.name = prefix + "_ic_lb_" + x + "_" + z;
			gameObject7.transform.parent = wallContainer.transform;
			gameObject7.transform.localPosition = new Vector3((float)x * fTileSize + fTileSize / 2f, yOffset, (float)(-z) * fTileSize - fTileSize / 2f);
			gameObject7.transform.localRotation = rotInCornerLeftBottom;
			gameObject7.layer = geometryLayer;
			gameObject7.tag = Tags.MapGeometry;
			chunk.AddToCombine(gameObject7);
			StripNonStatic(gameObject7.transform, mapGeometry.transform);
			listWalls?.Add(gameObject7);
		}
		if (Cell.CheckAdjacency(adjacency, (AdjacencyCode)80) && Cell.CheckAdjacencyClear(adjacency, (AdjacencyCode)10))
		{
			GameObject gameObject8 = UnityEngine.Object.Instantiate(curStyle.inCornerPrefab, Vector3.zero, Quaternion.identity);
			gameObject8.name = prefix + "_ic_rb_" + x + "_" + z;
			gameObject8.transform.parent = wallContainer.transform;
			gameObject8.transform.localPosition = new Vector3((float)x * fTileSize + fTileSize / 2f, yOffset, (float)(-z) * fTileSize - fTileSize / 2f);
			gameObject8.transform.localRotation = rotInCornerRightBottom;
			gameObject8.layer = geometryLayer;
			gameObject8.tag = Tags.MapGeometry;
			chunk.AddToCombine(gameObject8);
			StripNonStatic(gameObject8.transform, mapGeometry.transform);
			listWalls?.Add(gameObject8);
		}
		if (Cell.CheckAdjacency(adjacency, AdjacencyCode.LeftTop) && Cell.CheckAdjacencyClear(adjacency, (AdjacencyCode)10))
		{
			GameObject gameObject9 = CheckDoorInOutCorner(x, z, AdjacencyCode.LeftTop, curStyle);
			if (gameObject9 != null)
			{
				GameObject gameObject10 = UnityEngine.Object.Instantiate(gameObject9, Vector3.zero, Quaternion.identity);
				gameObject10.name = prefix + "_oc_lt_" + x + "_" + z;
				gameObject10.transform.parent = wallContainer.transform;
				gameObject10.transform.localPosition = new Vector3((float)x * fTileSize + fTileSize / 2f, yOffset, (float)(-z) * fTileSize - fTileSize / 2f);
				gameObject10.transform.localRotation = rotOutCornerLeftTop;
				gameObject10.layer = geometryLayer;
				gameObject10.tag = Tags.MapGeometry;
				chunk.AddToCombine(gameObject10);
				StripNonStatic(gameObject10.transform, mapGeometry.transform);
				listWalls?.Add(gameObject10);
			}
		}
		if (Cell.CheckAdjacency(adjacency, AdjacencyCode.RightTop) && Cell.CheckAdjacencyClear(adjacency, (AdjacencyCode)18))
		{
			GameObject gameObject11 = CheckDoorInOutCorner(x, z, AdjacencyCode.RightTop, curStyle);
			if (gameObject11 != null)
			{
				GameObject gameObject12 = UnityEngine.Object.Instantiate(gameObject11, Vector3.zero, Quaternion.identity);
				gameObject12.name = prefix + "_oc_rt_" + x + "_" + z;
				gameObject12.transform.parent = wallContainer.transform;
				gameObject12.transform.localPosition = new Vector3((float)x * fTileSize + fTileSize / 2f, yOffset, (float)(-z) * fTileSize - fTileSize / 2f);
				gameObject12.transform.localRotation = rotOutCornerRightTop;
				gameObject12.layer = geometryLayer;
				gameObject12.tag = Tags.MapGeometry;
				chunk.AddToCombine(gameObject12);
				StripNonStatic(gameObject12.transform, mapGeometry.transform);
				listWalls?.Add(gameObject12);
			}
		}
		if (Cell.CheckAdjacency(adjacency, AdjacencyCode.LeftBottom) && Cell.CheckAdjacencyClear(adjacency, (AdjacencyCode)72))
		{
			GameObject gameObject13 = CheckDoorInOutCorner(x, z, AdjacencyCode.LeftBottom, curStyle);
			if (gameObject13 != null)
			{
				GameObject gameObject14 = UnityEngine.Object.Instantiate(gameObject13, Vector3.zero, Quaternion.identity);
				gameObject14.name = prefix + "_oc_lb_" + x + "_" + z;
				gameObject14.transform.parent = wallContainer.transform;
				gameObject14.transform.localPosition = new Vector3((float)x * fTileSize + fTileSize / 2f, yOffset, (float)(-z) * fTileSize - fTileSize / 2f);
				gameObject14.transform.localRotation = rotOutCornerLeftBottom;
				gameObject14.layer = geometryLayer;
				gameObject14.tag = Tags.MapGeometry;
				chunk.AddToCombine(gameObject14);
				StripNonStatic(gameObject14.transform, mapGeometry.transform);
				listWalls?.Add(gameObject14);
			}
		}
		if (Cell.CheckAdjacency(adjacency, AdjacencyCode.RightBottom) && Cell.CheckAdjacencyClear(adjacency, (AdjacencyCode)80))
		{
			GameObject gameObject15 = CheckDoorInOutCorner(x, z, AdjacencyCode.RightBottom, curStyle);
			if (gameObject15 != null)
			{
				GameObject gameObject16 = UnityEngine.Object.Instantiate(gameObject15, Vector3.zero, Quaternion.identity);
				gameObject16.name = prefix + "_oc_rb_" + x + "_" + z;
				gameObject16.transform.parent = wallContainer.transform;
				gameObject16.transform.localPosition = new Vector3((float)x * fTileSize + fTileSize / 2f, yOffset, (float)(-z) * fTileSize - fTileSize / 2f);
				gameObject16.transform.localRotation = rotOutCornerRightBottom;
				gameObject16.layer = geometryLayer;
				gameObject16.tag = Tags.MapGeometry;
				chunk.AddToCombine(gameObject16);
				StripNonStatic(gameObject16.transform, mapGeometry.transform);
				listWalls?.Add(gameObject16);
			}
		}
		if (Cell.CheckAdjacency(adjacency, (AdjacencyCode)74) && Cell.CheckAdjacencyClear(adjacency, AdjacencyCode.RightCenter))
		{
			GameObject gameObject17 = UnityEngine.Object.Instantiate(curStyle.deadendPrefab, Vector3.zero, Quaternion.identity);
			gameObject17.name = prefix + "_dl_" + x + "_" + z;
			gameObject17.transform.parent = wallContainer.transform;
			gameObject17.transform.localPosition = new Vector3((float)x * fTileSize + fTileSize / 2f, yOffset, (float)(-z) * fTileSize - fTileSize / 2f);
			gameObject17.transform.localRotation = Quaternion.Euler(-90f, 90f, 0f);
			gameObject17.layer = geometryLayer;
			gameObject17.tag = Tags.MapGeometry;
			chunk.AddToCombine(gameObject17);
			StripNonStatic(gameObject17.transform, mapGeometry.transform);
			listWalls?.Add(gameObject17);
		}
		if (Cell.CheckAdjacency(adjacency, (AdjacencyCode)82) && Cell.CheckAdjacencyClear(adjacency, AdjacencyCode.LeftCenter))
		{
			GameObject gameObject18 = UnityEngine.Object.Instantiate(curStyle.deadendPrefab, Vector3.zero, Quaternion.identity);
			gameObject18.name = prefix + "_dr_" + x + "_" + z;
			gameObject18.transform.parent = wallContainer.transform;
			gameObject18.transform.localPosition = new Vector3((float)x * fTileSize + fTileSize / 2f, yOffset, (float)(-z) * fTileSize - fTileSize / 2f);
			gameObject18.transform.localRotation = Quaternion.Euler(-90f, -90f, 0f);
			gameObject18.layer = geometryLayer;
			gameObject18.tag = Tags.MapGeometry;
			chunk.AddToCombine(gameObject18);
			StripNonStatic(gameObject18.transform, mapGeometry.transform);
			listWalls?.Add(gameObject18);
		}
		if (Cell.CheckAdjacency(adjacency, (AdjacencyCode)26) && Cell.CheckAdjacencyClear(adjacency, AdjacencyCode.CenterBottom))
		{
			GameObject gameObject19 = UnityEngine.Object.Instantiate(curStyle.deadendPrefab, Vector3.zero, Quaternion.identity);
			gameObject19.name = prefix + "_dt_" + x + "_" + z;
			gameObject19.transform.parent = wallContainer.transform;
			gameObject19.transform.localPosition = new Vector3((float)x * fTileSize + fTileSize / 2f, yOffset, (float)(-z) * fTileSize - fTileSize / 2f);
			gameObject19.transform.localRotation = Quaternion.Euler(-90f, 180f, 0f);
			gameObject19.layer = geometryLayer;
			gameObject19.tag = Tags.MapGeometry;
			chunk.AddToCombine(gameObject19);
			StripNonStatic(gameObject19.transform, mapGeometry.transform);
			listWalls?.Add(gameObject19);
		}
		if (Cell.CheckAdjacency(adjacency, (AdjacencyCode)88) && Cell.CheckAdjacencyClear(adjacency, AdjacencyCode.CenterTop))
		{
			GameObject gameObject20 = UnityEngine.Object.Instantiate(curStyle.deadendPrefab, Vector3.zero, Quaternion.identity);
			gameObject20.name = prefix + "_db_" + x + "_" + z;
			gameObject20.transform.parent = wallContainer.transform;
			gameObject20.transform.localPosition = new Vector3((float)x * fTileSize + fTileSize / 2f, yOffset, (float)(-z) * fTileSize - fTileSize / 2f);
			gameObject20.transform.localRotation = Quaternion.Euler(-90f, 0f, 0f);
			gameObject20.layer = geometryLayer;
			gameObject20.tag = Tags.MapGeometry;
			chunk.AddToCombine(gameObject20);
			StripNonStatic(gameObject20.transform, mapGeometry.transform);
			listWalls?.Add(gameObject20);
		}
	}

	private void BuildPitWalls(int x, int z, Cell cell, MapStyle roomStyle, MapChunk chunk, float fTileSize)
	{
		MapStyle mapStyle = roomStyle.pitStyle;
		if (!mapStyle)
		{
			mapStyle = roomStyle;
		}
		float num = 0f - mapStyle.ceilingHeight;
		BuildWalls(x, z, cell.adjacencyPit, mapStyle, chunk, 0, fTileSize, "WallSectionPit", num);
		GameObject gameObject = UnityEngine.Object.Instantiate(mapStyle.floorPrefab, Vector3.zero, Quaternion.identity);
		gameObject.name = "Floor_" + x + "_" + z;
		gameObject.transform.parent = floor.transform;
		gameObject.transform.localPosition = new Vector3((float)x * fTileSize + fTileSize / 2f, num, (float)(-z) * fTileSize - fTileSize / 2f);
		gameObject.transform.localRotation = Quaternion.Euler(-90f, 0f, 0f);
		gameObject.layer = geometryLayer;
		if (gameObject.tag.Length == 0 || gameObject.tag == Tags.Untagged)
		{
			gameObject.tag = Tags.MapGeometry;
		}
		chunk.AddToCombine(gameObject);
		StripNonStatic(gameObject.transform, mapGeometry.transform);
	}

	private void BuildShaftWalls(int x, int z, Cell cell, MapStyle roomStyle, MapChunk chunk, float fTileSize)
	{
		if (tempWallList == null)
		{
			tempWallList = new List<GameObject>();
		}
		MapStyle mapStyle = roomStyle.shaftSyle;
		if (!mapStyle)
		{
			mapStyle = roomStyle;
		}
		float num = roomStyle.ceilingHeight - 0.15f;
		if (roomStyle.arched)
		{
			num -= 1f;
		}
		BuildWalls(x, z, cell.adjacencyShaft, mapStyle, chunk, 0, fTileSize, "WallSectionShaft", num, tempWallList);
		foreach (GameObject tempWall in tempWallList)
		{
			Renderer[] componentsInChildren = tempWall.GetComponentsInChildren<Renderer>();
			Renderer[] array = componentsInChildren;
			foreach (Renderer renderer in array)
			{
				Material[] sharedMaterials = renderer.sharedMaterials;
				foreach (Material material in sharedMaterials)
				{
					if (material.HasProperty("_PitOffset"))
					{
						material.SetFloat("_PitOffset", num);
					}
				}
			}
		}
	}

	private void StripNonStatic(Transform obj, Transform newContainer)
	{
		for (int i = 0; i < obj.childCount; i++)
		{
			Transform child = obj.GetChild(i);
			bool flag = false;
			int layer = child.gameObject.layer;
			int num = 0;
			while (!flag && num < staticLayers.Length)
			{
				if (layer == (int)staticLayers[num])
				{
					flag = true;
				}
				num++;
			}
			if (!flag)
			{
				child.transform.parent = newContainer;
				i--;
			}
		}
	}

	private GameObject CheckDoorInOutCorner(int x, int z, AdjacencyCode dirCode, MapStyle curStyle)
	{
		if (map.CellMap[z][x].Room != null && (curStyle.removeOutCornersInDoor || curStyle.doorOutCornerPrefab != null))
		{
			Point point;
			Point point2;
			switch (dirCode)
			{
			case AdjacencyCode.RightTop:
				point = new Point(x + 1, z);
				point2 = new Point(x, z - 1);
				break;
			case AdjacencyCode.RightBottom:
				point = new Point(x + 1, z);
				point2 = new Point(x, z + 1);
				break;
			case AdjacencyCode.LeftTop:
				point = new Point(x - 1, z);
				point2 = new Point(x, z - 1);
				break;
			case AdjacencyCode.LeftBottom:
				point = new Point(x - 1, z);
				point2 = new Point(x, z + 1);
				break;
			default:
				return null;
			}
			for (int i = 0; i < map.DoorPositions.Count; i++)
			{
				if (map.DoorPositions[i] == point || map.DoorPositions[i] == point2)
				{
					if (curStyle.removeOutCornersInDoor)
					{
						return null;
					}
					if (curStyle.doorOutCornerPrefab != null)
					{
						return curStyle.doorOutCornerPrefab;
					}
				}
			}
		}
		return curStyle.outCornerPrefab;
	}

	private bool GetEntrancePositioning(Point entrancePos, out Vector3 vPos, out Vector3 vLookAt, out AdjacencyCode doorSide, GameObject doorPrefab)
	{
		vPos = new Vector3((float)entrancePos.X * Map.Get().TileSize.x, 0f, (float)(-entrancePos.Y) * Map.Get().TileSize.y);
		vPos += new Vector3(Map.Get().TileSize.x / 2f, 0f, (0f - Map.Get().TileSize.y) / 2f);
		bool flag = !Map.Get().CellMap[entrancePos.Y][entrancePos.X - 1].IsClear();
		bool flag2 = !Map.Get().CellMap[entrancePos.Y][entrancePos.X + 1].IsClear();
		bool flag3 = !Map.Get().CellMap[entrancePos.Y - 1][entrancePos.X].IsClear();
		bool flag4 = !Map.Get().CellMap[entrancePos.Y + 1][entrancePos.X].IsClear();
		float doorInset = Map.Get().Tags.GetStyle(mapStyles, entrancePos).doorInset;
		doorSide = AdjacencyCode.Clear;
		vLookAt = Vector3.zero;
		if (!flag && !flag2)
		{
			vLookAt = new Vector3(1f, 0f, 0f);
			if (Map.Get().At(entrancePos.X - 1, entrancePos.Y).Room != null)
			{
				doorSide = AdjacencyCode.LeftCenter;
				doorInset = GetDoorInset(entrancePos, doorSide, doorPrefab);
				vPos.x -= Map.Get().TileSize.x / 2f - doorInset;
				vLookAt = new Vector3(-1f, 0f, 0f);
			}
			else
			{
				doorSide = AdjacencyCode.RightCenter;
				doorInset = GetDoorInset(entrancePos, doorSide, doorPrefab);
				vPos.x += Map.Get().TileSize.x / 2f - doorInset;
				vLookAt = new Vector3(1f, 0f, 0f);
			}
		}
		else
		{
			if (flag3 || flag4)
			{
				return false;
			}
			vLookAt = new Vector3(0f, 0f, -1f);
			if (Map.Get().At(entrancePos.X, entrancePos.Y + 1).Room != null)
			{
				doorSide = AdjacencyCode.CenterBottom;
				doorInset = GetDoorInset(entrancePos, doorSide, doorPrefab);
				vPos.z -= Map.Get().TileSize.x / 2f - doorInset;
				vLookAt = new Vector3(0f, 0f, -1f);
			}
			else
			{
				doorSide = AdjacencyCode.CenterTop;
				doorInset = GetDoorInset(entrancePos, doorSide, doorPrefab);
				vPos.z += Map.Get().TileSize.x / 2f - doorInset;
				vLookAt = new Vector3(0f, 0f, 1f);
			}
		}
		return true;
	}

	private float GetDoorInset(Point entrancePos, AdjacencyCode doorSide, GameObject doorPrefab)
	{
		Point tile = Map.WalkDirection(entrancePos, doorSide);
		MapStyle style = Map.Get().Tags.GetStyle(mapStyles, tile);
		float doorInset = style.doorInset;
		if (doorPrefab != null && style.doorInsets.Count > 0)
		{
			string text = doorPrefab.name;
			for (int i = 0; i < style.doorInsets.Count; i++)
			{
				if (style.doorInsets[i].doorType == text)
				{
					return style.doorInsets[i].inset;
				}
			}
		}
		return doorInset;
	}

	private void AddDoorFrame(Point cellPos, AdjacencyCode side, bool hasDoor, MapStyle[] mapStyles, GameObject wallContainer)
	{
		Point point = cellPos;
		Cell cell = Map.Get().At(cellPos);
		MapStyle style = Map.Get().Tags.GetStyle(mapStyles, point);
		Point point2 = Map.WalkDirection(point, side);
		Cell cell2 = Map.Get().At(point2);
		MapStyle style2 = Map.Get().Tags.GetStyle(mapStyles, point2);
		bool flag = style2.arched && style2.ceilingHeight <= 3.5f;
		bool flag2 = style.arched && style.ceilingHeight <= 3.5f;
		if (!hasDoor && style == style2)
		{
			return;
		}
		float x = Map.Get().TileSize.x;
		if (hasDoor || style.ceilingHeight != style2.ceilingHeight || flag2 != flag)
		{
			bool flag3 = (hasDoor || style.ceilingHeight < 3.5f || flag2) && style2.ceilingHeight > 2.5f;
			bool flag4 = (hasDoor || style2.ceilingHeight < 3.5f || flag) && style.ceilingHeight > 2.5f;
			bool flag5 = !hasDoor && style.ceilingHeight <= 3.5f && style2.ceilingHeight > 3.5f;
			bool flag6 = !hasDoor && style2.ceilingHeight <= 3.5f && style.ceilingHeight > 3.5f;
			if (!flag3 && flag4 && style2.ceilingHeight > 2.5f)
			{
				flag5 = false;
				flag3 = true;
			}
			if (!flag4 && flag3 && style.ceilingHeight > 2.5f)
			{
				flag6 = false;
				flag4 = true;
			}
			if (!hasDoor && !flag3 && !flag4 && !flag5 && !flag6 && style.ceilingHeight != style2.ceilingHeight)
			{
				if (style.ceilingHeight > 3.5f && style2.ceilingHeight > 3.5f)
				{
					flag5 = (flag6 = true);
				}
				else
				{
					flag3 = (flag4 = true);
				}
			}
			GameObject gameObject = (flag3 ? style2.doorFrame25Prefab : ((!flag5) ? null : style2.doorFrame35Prefab));
			if ((bool)gameObject)
			{
				GameObject gameObject2 = UnityEngine.Object.Instantiate(gameObject, Vector3.zero, Quaternion.identity);
				gameObject2.name = "WallSection_dframe_" + point2.X + "_" + point2.Y;
				gameObject2.transform.parent = wallContainer.transform;
				gameObject2.transform.localPosition = new Vector3((float)point2.X * x + x / 2f, 0f, (float)(-point2.Y) * x - x / 2f);
				switch (side)
				{
				case AdjacencyCode.LeftCenter:
					gameObject2.transform.localRotation = rotLWallRight;
					break;
				case AdjacencyCode.RightCenter:
					gameObject2.transform.localRotation = rotLWallLeft;
					break;
				case AdjacencyCode.CenterTop:
					gameObject2.transform.localRotation = rotLWallBottom;
					break;
				case AdjacencyCode.CenterBottom:
					gameObject2.transform.localRotation = rotLWallTop;
					break;
				}
				gameObject2.layer = geometryLayer;
				gameObject2.tag = Tags.MapGeometry;
				MapChunk.At(point2.X, point2.Y).AddToCombine(gameObject2);
			}
			GameObject gameObject3 = (flag4 ? style.doorFrame25Prefab : ((!flag6) ? null : style.doorFrame35Prefab));
			if ((bool)gameObject3)
			{
				GameObject gameObject4 = UnityEngine.Object.Instantiate(gameObject3, Vector3.zero, Quaternion.identity);
				gameObject4.name = "WallSection_dframe_" + point.X + "_" + point.Y;
				gameObject4.transform.parent = wallContainer.transform;
				float num = 0.1f;
				Vector3 vector = Vector3.zero;
				switch (side)
				{
				case AdjacencyCode.LeftCenter:
					gameObject4.transform.localRotation = rotLWallLeft;
					vector = new Vector3(1f, 0f, 0f);
					break;
				case AdjacencyCode.RightCenter:
					gameObject4.transform.localRotation = rotLWallRight;
					vector = new Vector3(-1f, 0f, 0f);
					break;
				case AdjacencyCode.CenterTop:
					gameObject4.transform.localRotation = rotLWallTop;
					vector = new Vector3(0f, 0f, -1f);
					break;
				case AdjacencyCode.CenterBottom:
					gameObject4.transform.localRotation = rotLWallBottom;
					vector = new Vector3(0f, 0f, 1f);
					break;
				}
				gameObject4.transform.localPosition = new Vector3((float)point.X * x + x / 2f, 0f, (float)(-point.Y) * x - x / 2f) + vector * num;
				if (style.offsetDoorFrame)
				{
					gameObject4.transform.localPosition += Vector3.up * 0.005f;
				}
				gameObject4.layer = geometryLayer;
				gameObject4.tag = Tags.MapGeometry;
				MapChunk.At(point.X, point.Y).AddToCombine(gameObject4);
			}
			if (!hasDoor && (flag3 || flag5 || flag4 || flag6))
			{
				GameObject topTransitionPrefab = style2.topTransitionPrefab;
				float transHeight = 3.5f;
				if (flag4 || flag3)
				{
					transHeight = 2.4f;
				}
				else if (flag6 || flag5)
				{
					transHeight = 3.4f;
				}
				float transHOffset = Mathf.Min(style.transitionHOffset, style2.transitionHOffset);
				AddCeilingTransition(point, side, topTransitionPrefab, transHeight, transHOffset, style.transitionOutOffset);
			}
		}
		if (hasDoor)
		{
			switch (side)
			{
			case AdjacencyCode.LeftCenter:
				ceilingMiniTransitions[cellPos.Y][cellPos.X - 1] |= 16;
				break;
			case AdjacencyCode.RightCenter:
				ceilingMiniTransitions[cellPos.Y][cellPos.X] |= 16;
				break;
			case AdjacencyCode.CenterTop:
				ceilingMiniTransitions[cellPos.Y - 1][cellPos.X] |= 64;
				break;
			case AdjacencyCode.CenterBottom:
				ceilingMiniTransitions[cellPos.Y][cellPos.X] |= 64;
				break;
			}
		}
		int num2 = 0;
		if (!hasDoor && style != style2)
		{
			bool flag7 = false;
			bool flag8 = false;
			Quaternion identity = Quaternion.identity;
			Quaternion identity2 = Quaternion.identity;
			if (point.X > point2.X)
			{
				if (cell.CheckAdjacency(AdjacencyCode.CenterTop) && cell2.CheckAdjacency(AdjacencyCode.CenterTop))
				{
					flag8 = true;
				}
				if (cell.CheckAdjacency(AdjacencyCode.CenterBottom) && cell2.CheckAdjacency(AdjacencyCode.CenterBottom))
				{
					flag7 = true;
				}
				identity = rotOutCornerLeftBottom;
				identity2 = rotOutCornerLeftTop;
			}
			else if (point.X < point2.X)
			{
				if (cell.CheckAdjacency(AdjacencyCode.CenterTop) && cell2.CheckAdjacency(AdjacencyCode.CenterTop))
				{
					flag7 = true;
				}
				if (cell.CheckAdjacency(AdjacencyCode.CenterBottom) && cell2.CheckAdjacency(AdjacencyCode.CenterBottom))
				{
					flag8 = true;
				}
				identity = rotOutCornerRightTop;
				identity2 = rotOutCornerRightBottom;
			}
			else if (point.Y > point2.Y)
			{
				if (cell.CheckAdjacency(AdjacencyCode.LeftCenter) && cell2.CheckAdjacency(AdjacencyCode.LeftCenter))
				{
					flag7 = true;
				}
				if (cell.CheckAdjacency(AdjacencyCode.RightCenter) && cell2.CheckAdjacency(AdjacencyCode.RightCenter))
				{
					flag8 = true;
				}
				identity = rotOutCornerLeftTop;
				identity2 = rotOutCornerRightTop;
			}
			else if (point.Y < point2.Y)
			{
				if (cell.CheckAdjacency(AdjacencyCode.LeftCenter) && cell2.CheckAdjacency(AdjacencyCode.LeftCenter))
				{
					flag8 = true;
				}
				if (cell.CheckAdjacency(AdjacencyCode.RightCenter) && cell2.CheckAdjacency(AdjacencyCode.RightCenter))
				{
					flag7 = true;
				}
				identity = rotOutCornerRightBottom;
				identity2 = rotOutCornerLeftBottom;
			}
			GameObject outCornerPrefab = style2.outCornerPrefab;
			if (!outCornerPrefab)
			{
				outCornerPrefab = style.outCornerPrefab;
			}
			if (outCornerPrefab != null && flag7)
			{
				GameObject gameObject5 = UnityEngine.Object.Instantiate(outCornerPrefab, Vector3.zero, Quaternion.identity);
				gameObject5.name = "WallSection_trans_left_" + point.X + "_" + point.Y;
				gameObject5.transform.parent = wallContainer.transform;
				gameObject5.transform.localPosition = new Vector3((float)point.X * x + x / 2f, 0f, (float)(-point.Y) * x - x / 2f);
				gameObject5.transform.localRotation = identity;
				gameObject5.layer = geometryLayer;
				gameObject5.tag = Tags.MapGeometry;
				MapChunk.At(point.X, point.Y).AddToCombine(gameObject5);
				num2++;
			}
			if (outCornerPrefab != null && flag8)
			{
				GameObject gameObject6 = UnityEngine.Object.Instantiate(outCornerPrefab, Vector3.zero, Quaternion.identity);
				gameObject6.name = "WallSection_trans_right_" + point.X + "_" + point.Y;
				gameObject6.transform.parent = wallContainer.transform;
				gameObject6.transform.localPosition = new Vector3((float)point.X * x + x / 2f, 0f, (float)(-point.Y) * x - x / 2f);
				gameObject6.transform.localRotation = identity2;
				gameObject6.layer = geometryLayer;
				gameObject6.tag = Tags.MapGeometry;
				MapChunk.At(point.X, point.Y).AddToCombine(gameObject6);
				num2++;
			}
		}
		if (style != style2 && style.collapseEdges != style2.collapseEdges && (style.collapseEdges || style2.collapseEdges) && num2 == 0)
		{
			Point point3 = ((!style.collapseEdges) ? point2 : point);
			if (map.At(point3).GetNumAdjacentWallsNoCorners() >= 2)
			{
				Vector3 vector2 = new Vector3((float)point.X * x + x / 2f, 0f, (float)(-point.Y) * x - x / 2f);
				Vector3 vector3 = new Vector3((float)point2.X * x + x / 2f, 0f, (float)(-point2.Y) * x - x / 2f);
				Vector3 vector4 = (vector3 - vector2).MajorAxis();
				Vector3 vector5 = (vector2 + vector3) / 2f;
				Vector3 vector6 = vector4;
				vector6 = ((!(vector4.x >= 1f) && !(vector4.x <= -1f)) ? new Vector3(1f, 0f, 0f) : new Vector3(0f, 0f, 1f));
				EdgeCollapse item = default(EdgeCollapse);
				item.edge = vector5 + vector6 * x / 2f;
				item.tile = point3;
				EdgeCollapse item2 = default(EdgeCollapse);
				item2.edge = vector5 - vector6 * x / 2f;
				item2.tile = point3;
				edgeCollapses.Add(item);
				edgeCollapses.Add(item2);
			}
		}
		if (num2 < 2)
		{
			AddWallCaps(style, point, point2);
			AddWallCaps(style2, point2, point);
		}
	}

	private void AddWallCaps(MapStyle style, Point insidePos, Point outsidePos)
	{
		if (style.lWallCapLeft == null || style.lWallCapRight == null)
		{
			return;
		}
		AdjacencyCode adjacencyCode = AdjacencyCode.Clear;
		Point point;
		Point point2;
		if (insidePos.X == outsidePos.X)
		{
			if (insidePos.Y < outsidePos.Y)
			{
				point = insidePos + new Point(1, 0);
				point2 = insidePos + new Point(-1, 0);
				adjacencyCode = AdjacencyCode.CenterBottom;
			}
			else
			{
				point = insidePos + new Point(-1, 0);
				point2 = insidePos + new Point(1, 0);
				adjacencyCode = AdjacencyCode.CenterTop;
			}
		}
		else if (insidePos.X < outsidePos.X)
		{
			point = insidePos + new Point(0, -1);
			point2 = insidePos + new Point(0, 1);
			adjacencyCode = AdjacencyCode.RightCenter;
		}
		else
		{
			point = insidePos + new Point(0, 1);
			point2 = insidePos + new Point(0, -1);
			adjacencyCode = AdjacencyCode.LeftCenter;
		}
		for (int i = 0; i < 2; i++)
		{
			Point point3 = ((i != 0) ? point2 : point);
			if (map.At(point3).IsClearOrPit() && map.At(point3).CheckAdjacency(adjacencyCode))
			{
				Quaternion identity = Quaternion.identity;
				switch (adjacencyCode)
				{
				case AdjacencyCode.CenterBottom:
					identity = rotLWallBottom;
					break;
				case AdjacencyCode.CenterTop:
					identity = rotLWallTop;
					break;
				case AdjacencyCode.LeftCenter:
					identity = rotLWallLeft;
					break;
				case AdjacencyCode.RightCenter:
					identity = rotLWallRight;
					break;
				}
				float x = Map.Get().TileSize.x;
				GameObject gameObject = UnityEngine.Object.Instantiate((i != 0) ? style.lWallCapRight : style.lWallCapLeft, Vector3.zero, Quaternion.identity);
				gameObject.name = "WallCap_" + point3.X + "_" + point3.Y;
				gameObject.transform.parent = wallContainer.transform;
				gameObject.transform.localPosition = new Vector3((float)point3.X * x + x / 2f, 0f, (float)(-point3.Y) * x - x / 2f);
				gameObject.transform.localRotation = identity;
				gameObject.layer = geometryLayer;
				gameObject.tag = Tags.MapGeometry;
				MapChunk.At(insidePos.X, insidePos.Y).AddToCombine(gameObject);
				Vector3 vector = Map.Get().CellToWorld(point3);
				Debug.DrawLine(vector, vector + Vector3.up, Color.blue, 5f);
			}
		}
	}

	private GameObject AddCeilingTransition(Point cellPos, AdjacencyCode side, GameObject transitionPrefab, float transHeight = 2.4f, float transHOffset = 0f, float offsetAmount = 0.05f)
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(transitionPrefab, Vector3.zero, Quaternion.identity);
		gameObject.name = "WallSection_trans_top_" + cellPos.X + "_" + cellPos.Y;
		gameObject.transform.parent = wallContainer.transform;
		float x = Map.Get().TileSize.x;
		Vector3 vector = Vector3.zero;
		switch (side)
		{
		case AdjacencyCode.LeftCenter:
			gameObject.transform.localRotation = rotLWallLeft;
			vector = new Vector3(1f, 0f, 0f);
			ceilingMiniTransitions[cellPos.Y][cellPos.X - 1] |= 16;
			break;
		case AdjacencyCode.RightCenter:
			gameObject.transform.localRotation = rotLWallRight;
			vector = new Vector3(-1f, 0f, 0f);
			ceilingMiniTransitions[cellPos.Y][cellPos.X] |= 16;
			break;
		case AdjacencyCode.CenterTop:
			gameObject.transform.localRotation = rotLWallTop;
			vector = new Vector3(0f, 0f, -1f);
			ceilingMiniTransitions[cellPos.Y - 1][cellPos.X] |= 64;
			break;
		case AdjacencyCode.CenterBottom:
			gameObject.transform.localRotation = rotLWallBottom;
			vector = new Vector3(0f, 0f, 1f);
			ceilingMiniTransitions[cellPos.Y][cellPos.X] |= 64;
			break;
		}
		gameObject.transform.localPosition = new Vector3((float)cellPos.X * x + x / 2f, 0f, (float)(-cellPos.Y) * x - x / 2f) + vector * offsetAmount + new Vector3(0f, transHeight + transHOffset, 0f);
		gameObject.layer = geometryLayer;
		gameObject.tag = Tags.MapGeometry;
		MapChunk.At(cellPos.X, cellPos.Y).AddToCombine(gameObject);
		return gameObject;
	}

	private void ListStaticGeometry(GameObject root, ref List<GameObject> staticGeometry)
	{
		Transform transform = root.transform;
		for (int i = 0; i < transform.childCount; i++)
		{
			GameObject gameObject = transform.GetChild(i).gameObject;
			if (gameObject.isStatic)
			{
				staticGeometry.Add(gameObject);
			}
			else
			{
				ListStaticGeometry(gameObject, ref staticGeometry);
			}
		}
	}

	public Map GenerateGB()
	{
		Texture2D texture2D = new Texture2D(128, 128, TextureFormat.RGBA32, mipmap: false);
		ClearMemory.AddRuntimeTexture(texture2D);
		texture2D.filterMode = FilterMode.Point;
		texture2D.wrapMode = TextureWrapMode.Clamp;
		GBGenerator gBGenerator = new GBGenerator();
		if (generatorType == GeneratorType.Meta01)
		{
			gBGenerator = (customGenerator = new MetaMapGenerator_01());
		}
		else if (generatorType == GeneratorType.Meta02)
		{
			gBGenerator = (customGenerator = new MetaMapGenerator_02());
		}
		else if (generatorType == GeneratorType.Meta03)
		{
			gBGenerator = (customGenerator = new MetaMapGenerator_03());
		}
		else if (generatorType == GeneratorType.Meta04)
		{
			gBGenerator = (customGenerator = new MetaMapGenerator_04());
		}
		else if (generatorType == GeneratorType.Demo)
		{
			gBGenerator = (customGenerator = new CustomGenerator());
		}
		gBGenerator.Options = new GBGenerator.MapOptions(64, 64);
		gBGenerator.Options.styles = mapStyles;
		gBGenerator.Options.mainTag = levelOptions.tag;
		LevelOptions.AmbientOptions ambientOptions = levelOptions.GetAmbientOptions();
		if (ambientOptions != null)
		{
			gBGenerator.Options.ambientDefault = ambientOptions.ambientDefault.ambient;
			gBGenerator.Options.ambientRoom = ambientOptions.ambientRoom.ambient;
			gBGenerator.Options.ambientLarge = ambientOptions.ambientLarge.ambient;
			gBGenerator.Options.ambientHub = ambientOptions.ambientHub.ambient;
			AmbientManager.Get().defaultAmbientName = gBGenerator.Options.ambientDefault;
		}
		gBGenerator.Options.testRoom = testRoom;
		gBGenerator.Options.maskNone = levelOptions.maskNone;
		gBGenerator.Options.maskSmall = levelOptions.maskSmall;
		gBGenerator.Options.maskMedium = levelOptions.maskMedium;
		gBGenerator.Options.maskOShaped = levelOptions.maskOShaped;
		gBGenerator.Options.maskCross = levelOptions.maskCross;
		gBGenerator.Options.maskFortress = levelOptions.maskFortress;
		gBGenerator.Options.maskTShaped = levelOptions.maskTShaped;
		gBGenerator.Options.maskUShaped = levelOptions.maskUShaped;
		if (levelOptions.styleOptions.Length > 0)
		{
			List<Pair<LevelOptions.StyleOptions, float>> list = new List<Pair<LevelOptions.StyleOptions, float>>();
			for (int i = 0; i < levelOptions.styleOptions.Length; i++)
			{
				list.Add(new Pair<LevelOptions.StyleOptions, float>(levelOptions.styleOptions[i], levelOptions.styleOptions[i].weight));
			}
			gBGenerator.Options.styleOptions = RandomExt.WeightedChoice(list);
		}
		Map map;
		for (map = null; map == null; map = gBGenerator.Generate(64, 64, texture2D))
		{
		}
		GameObject.FindWithTag(Tags.Minimap).GetComponent<Renderer>().sharedMaterial.SetTexture("_LevelMap", texture2D);
		levelMap = texture2D;
		return map;
	}

	private void Start()
	{
		if (testRoom != null)
		{
			return;
		}
		NavGraph component = GameObject.FindWithTag(Tags.NavGraph).GetComponent<NavGraph>();
		if ((bool)component && component.SpawnPositions.Count > 0)
		{
			int a = Mathf.Max(1, component.SpawnPositions.Count / 30);
			a = Mathf.Min(a, levelOptions.maxProwlers);
			if (a > 0)
			{
				float num = UnityEngine.Random.Range(levelOptions.prowlersMinDelay, levelOptions.prowlersMaxDelay);
				if (num > 0f)
				{
					StartCoroutine(DelayedSpawnProwlers_co(component, a, num));
				}
				else
				{
					SpawnProwlers(component, a);
				}
			}
		}
		int num2 = UnityEngine.Random.Range(1, 5) + UnityEngine.Random.Range(1, 5);
		int a2 = Mathf.RoundToInt((float)num2 / 4f);
		a2 = Mathf.Min(a2, levelOptions.maxLightEaters);
		if (a2 > 0)
		{
			float num3 = UnityEngine.Random.Range(levelOptions.lightEatersMinDelay, levelOptions.lightEatersMaxDelay);
			if (num3 > 0f)
			{
				StartCoroutine(DelayedSpawnLightEaters_co(a2, num3));
			}
			else
			{
				SpawnLightEaters(a2);
			}
		}
		int num4 = UnityEngine.Random.Range(1, 5) + UnityEngine.Random.Range(1, 5);
		int a3 = Mathf.RoundToInt((float)num4 / 3f);
		a3 = Mathf.Min(a3, levelOptions.maxFloaters);
		if (a3 > 0)
		{
			float num5 = UnityEngine.Random.Range(levelOptions.floatersMinDelay, levelOptions.floatersMaxDelay);
			if (num5 > 0f)
			{
				StartCoroutine(DelayedSpawnFloaters_co(a3, num5));
			}
			else
			{
				SpawnFloaters(a3);
			}
		}
	}

	private void SpawnLightEaters(int numEaters, bool checkVisibility = false, bool nearby = false)
	{
		for (int i = 0; i < numEaters; i++)
		{
			int num = 10;
			while (num-- > 0)
			{
				if (i == 0 && nearby)
				{
					LightEater.SpawnNextToPlayer(destroy: false, UnityEngine.Random.value < 0.3f);
					break;
				}
				Room room = RandomExt.Choice(Map.Get().Rooms);
				if (room.Safe || room.IsExitRoom || (checkVisibility && room.PlayerInside))
				{
					continue;
				}
				Point randomPoint = room.GetRandomPoint(central: true);
				if (checkVisibility && Map.Get().At(randomPoint).IsVisible())
				{
					continue;
				}
				LightEater lightEater = UnityEngine.Object.Instantiate(lightEaterPrefab, Map.Get().CellToWorld(randomPoint), Quaternion.identity);
				lightEater.gameObject.name = "LightEater_" + i;
				if (i != 0 && UnityEngine.Random.value <= 0.5f && (!checkVisibility || !room.PlayerEverEntered))
				{
					lightEater.SetStalk(room);
				}
				break;
			}
		}
	}

	private IEnumerator DelayedSpawnLightEaters_co(int numEaters, float delayTime)
	{
		if (numEaters > 0)
		{
			LightEater eater = UnityEngine.Object.Instantiate(lightEaterPrefab, Vector3.zero, Quaternion.identity);
			eater.enabled = false;
			eater.GetComponent<CreatureVisibility>().enabled = false;
			eater.gameObject.name = "LightEater_prewarm";
			yield return null;
			UnityEngine.Object.Destroy(eater.gameObject);
		}
		yield return new WaitForSeconds(delayTime);
		SpawnLightEaters(numEaters, checkVisibility: true, levelOptions.spawnNextToPlayer);
	}

	private void SpawnProwlers(NavGraph navGraph, int numProwlers, bool checkVisibility = false)
	{
		List<int> list = new List<int>();
		for (int i = 0; i < numProwlers; i++)
		{
			int num = 10;
			while (num-- > 0)
			{
				int num2 = UnityEngine.Random.Range(0, navGraph.SpawnPositions.Count);
				if (!list.Contains(num2))
				{
					list.Add(num2);
					Vector3 position = navGraph.SpawnPositions[num2].position;
					if (!checkVisibility || !MapChunk.At(Map.Get().WorldToCell(position)).Visible)
					{
						GameObject gameObject = UnityEngine.Object.Instantiate(prowlerPrefab, position, Quaternion.identity);
						gameObject.name = "Prowler_" + i;
						break;
					}
				}
			}
		}
	}

	private IEnumerator DelayedSpawnProwlers_co(NavGraph navGraph, int numProwlers, float delayTime)
	{
		if (numProwlers > 0)
		{
			Prowler prowler = UnityEngine.Object.Instantiate(prowlerPrefab, Vector3.zero, Quaternion.identity).GetComponent<Prowler>();
			prowler.enabled = false;
			prowler.GetComponent<CreatureVisibility>().enabled = false;
			prowler.gameObject.name = "Prowler_prewarm";
			yield return null;
			UnityEngine.Object.Destroy(prowler.gameObject);
		}
		yield return new WaitForSeconds(delayTime);
		SpawnProwlers(navGraph, numProwlers, checkVisibility: true);
	}

	private void RecursiveRemoveSpawn(List<NavNode> validSpawns, NavNode node)
	{
		if (validSpawns.Contains(node))
		{
			validSpawns.Remove(node);
			for (int i = 0; i < node.Neighbours.Count; i++)
			{
				RecursiveRemoveSpawn(validSpawns, node.Neighbours[i]);
			}
		}
	}

	private void SpawnFloaters(int numFloaters)
	{
		GameObject[] array = GameObject.FindGameObjectsWithTag(Tags.FloaterSpawn);
		List<Transform> list = new List<Transform>();
		for (int i = 0; i < array.Length; i++)
		{
			Cell cell = Map.Get().At(array[i].transform.position);
			Room room = cell.Room;
			if (cell.GetNumAdjacentWallsNoCorners() < 3 && room != null && !room.Safe && room.floaters.Count == 0)
			{
				list.Add(array[i].transform);
			}
		}
		list.Shuffle();
		for (int j = 0; j < numFloaters; j++)
		{
			Floater floater = null;
			if (list.Count > 0 && UnityEngine.Random.value <= 1f)
			{
				do
				{
					Room room2 = Map.Get().At(list[0].position).Room;
					if (room2.floaters.Count == 0)
					{
						floater = Floater.SpawnInWell(list[0], floaterPrefab);
					}
					list.RemoveAt(0);
				}
				while (floater == null && list.Count > 0);
			}
			if (floater == null)
			{
				floater = Floater.SpawnInRandomRoom(floaterPrefab);
			}
			if (floater != null)
			{
				floater.name = "Floater_" + j;
			}
		}
	}

	private IEnumerator DelayedSpawnFloaters_co(int numFloaters, float delayTime)
	{
		yield return new WaitForSeconds(delayTime);
		SpawnFloaters(numFloaters);
	}

	public void SpawnBats(Room room)
	{
		StartCoroutine(SpawnBats_co());
	}

	private IEnumerator SpawnBats_co()
	{
		yield return new WaitForSeconds(4f + UnityEngine.Random.Range(3f, 6f));
		if (UnityEngine.Random.value <= 0.7f)
		{
			SpookSounds.Get().PlayDeepPitSound();
			yield return new WaitForSeconds(1.5f);
		}
		Bat batPrefab = GameController.Get().GetComponent<MapBuilder>().batPrefab;
		Transform playerPos = Player.Get().transform;
		Vector3 curPos = Player.GetGroundPos();
		for (int i = 0; i < 64; i++)
		{
			UnityEngine.Object.Instantiate(batPrefab, curPos, playerPos.rotation);
		}
		yield return new WaitForSeconds(1f);
		FearEffect.Get().Scare(jumpScare: true);
	}

	private Dictionary<Point, List<GameObject>> ProcessPropPrefabs(GameObject[] propPrefabs, Vector2 vTileSize)
	{
		Dictionary<Point, List<GameObject>> dictionary = new Dictionary<Point, List<GameObject>>();
		foreach (GameObject gameObject in propPrefabs)
		{
			PropInfo component = gameObject.GetComponent<PropInfo>();
			Point point;
			if (component == null)
			{
				Bounds bounds = ((!gameObject.GetComponent<Renderer>()) ? gameObject.GetComponent<Collider>().bounds : gameObject.GetComponent<Renderer>().bounds);
				float x = bounds.size.x;
				float z = bounds.size.z;
				point = new Point((int)(x / vTileSize.x), (int)(z / vTileSize.y));
				x -= (float)point.X * vTileSize.x;
				z -= (float)point.Y * vTileSize.y;
				if (x >= 0.3f * vTileSize.x)
				{
					point.X++;
				}
				if (z >= 0.3f * vTileSize.y)
				{
					point.Y++;
				}
			}
			else
			{
				point = new Point(component.SizeX, component.SizeY);
			}
			Point key = new Point(Mathf.Max(point.X, point.Y), Mathf.Min(point.X, point.Y));
			if (!dictionary.ContainsKey(key))
			{
				dictionary[key] = new List<GameObject>();
			}
			dictionary[key].Add(gameObject);
		}
		return dictionary;
	}
}
public class MapChunk : MonoBehaviour
{
	public static MapChunk[][] chunkMap;

	public const int chunkSize = 4;

	public static Dictionary<Renderer, int> rendererStateMap;

	public List<VisibilityProbe> probeList;

	public List<Renderer> renderers;

	public List<Light> lights;

	public List<MapChunk> linkedChunks;

	public List<MeshFilter> toCombine;

	private bool visible;

	public bool nextState;

	private float timeVisible;

	public bool Visible
	{
		get
		{
			return visible;
		}
		set
		{
			nextState = value;
		}
	}

	public static void InitChunks(GameObject chunkPrefab, Transform mapGeometry)
	{
		GameObject gameObject = new GameObject("Chunks");
		gameObject.transform.parent = mapGeometry;
		gameObject.isStatic = true;
		int num = (int)Math.Ceiling((decimal)Map.Get().Width / 4m);
		int num2 = (int)Math.Ceiling((decimal)Map.Get().Height / 4m);
		chunkMap = new MapChunk[num2][];
		for (int i = 0; i < num2; i++)
		{
			chunkMap[i] = new MapChunk[num];
			for (int j = 0; j < num; j++)
			{
				GameObject gameObject2 = UnityEngine.Object.Instantiate(chunkPrefab);
				gameObject2.name = "MapChunk_" + j + "_" + i;
				gameObject2.transform.localPosition = Map.Get().CellToWorld(j * 4, i * 4);
				gameObject2.transform.parent = gameObject.transform;
				chunkMap[i][j] = gameObject2.GetComponent<MapChunk>();
			}
		}
		rendererStateMap = new Dictionary<Renderer, int>();
	}

	public static void Clear()
	{
		chunkMap = null;
		rendererStateMap = null;
	}

	public static MapChunk At(int xCell, int yCell)
	{
		return chunkMap[yCell / 4][xCell / 4];
	}

	public static MapChunk At(Point cellPos)
	{
		return At(cellPos.X, cellPos.Y);
	}

	public void AddToCombine(GameObject obj)
	{
		obj.isStatic = false;
		MeshFilter component = obj.GetComponent<MeshFilter>();
		if (component != null)
		{
			toCombine.Add(component);
		}
		for (int i = 0; i < obj.transform.childCount; i++)
		{
			AddToCombine(obj.transform.GetChild(i).gameObject);
		}
	}

	public void AddGeometry(GameObject obj, bool addTracker = true)
	{
		if ((bool)obj.GetComponent<Renderer>())
		{
			renderers.Add(obj.GetComponent<Renderer>());
			if (visible)
			{
				IncVisibilityCount(obj.GetComponent<Renderer>());
			}
			else
			{
				obj.GetComponent<Renderer>().enabled = false;
			}
		}
		if ((bool)obj.GetComponent<Light>())
		{
			ProcessLight(obj);
		}
		if (addTracker && !obj.isStatic)
		{
			OcclusionTracker.AddToTracker(obj, this);
		}
		for (int i = 0; i < obj.transform.childCount; i++)
		{
			AddGeometry(obj.transform.GetChild(i).gameObject);
		}
	}

	public void AddGeometry(GameObject obj, LayerMask mask, bool addTracker = true, bool tryCombineMesh = false)
	{
		if (!Utils.IsInLayerMask(obj, mask))
		{
			return;
		}
		bool flag = false;
		if ((bool)obj.GetComponent<Renderer>())
		{
			if (obj.isStatic && tryCombineMesh)
			{
				MeshFilter component = obj.GetComponent<MeshFilter>();
				if (component != null)
				{
					toCombine.Add(component);
					flag = true;
				}
			}
			if (!flag)
			{
				renderers.Add(obj.GetComponent<Renderer>());
				if (visible)
				{
					IncVisibilityCount(obj.GetComponent<Renderer>());
				}
				else
				{
					obj.GetComponent<Renderer>().enabled = false;
				}
			}
		}
		if ((bool)obj.GetComponent<Light>())
		{
			ProcessLight(obj);
		}
		if (addTracker && !obj.isStatic && !flag)
		{
			OcclusionTracker.AddToTracker(obj, this);
		}
		for (int i = 0; i < obj.transform.childCount; i++)
		{
			AddGeometry(obj.transform.GetChild(i).gameObject, mask, addTracker: true, tryCombineMesh);
		}
	}

	public static void AddGeometry(GameObject obj, Point pos, int width, int height)
	{
		int num = pos.X / 4;
		int num2 = pos.Y / 4;
		int num3 = (pos.X + width - 1) / 4;
		int num4 = (pos.Y + height - 1) / 4;
		for (int i = num2; i <= num4; i++)
		{
			for (int j = num; j <= num3; j++)
			{
				chunkMap[i][j].AddGeometry(obj);
			}
		}
	}

	public static void AddGeometry(GameObject obj, Point pos, int width, int height, LayerMask mask)
	{
		int num = pos.X / 4;
		int num2 = pos.Y / 4;
		int num3 = (pos.X + width - 1) / 4;
		int num4 = (pos.Y + height - 1) / 4;
		if (num == num3 && num2 == num4)
		{
			chunkMap[num2][num].AddGeometry(obj, mask, addTracker: true, tryCombineMesh: true);
			return;
		}
		for (int i = num2; i <= num4; i++)
		{
			for (int j = num; j <= num3; j++)
			{
				chunkMap[i][j].AddGeometry(obj, mask);
			}
		}
	}

	public void AddLight(Light light)
	{
		lights.Add(light);
	}

	private void ProcessLight(GameObject obj)
	{
		if (obj.GetComponent<LightFOV>() == null)
		{
			obj.AddComponent<LightFOV>();
		}
		Room room = Map.Get().At(obj.transform.position).Room;
		if (room != null && (room.Template.size == RoomTemplate.SizeType.Hub || obj.GetComponent<Light>().range >= 3f) && obj.GetComponent<RoomAmbientLight>() == null)
		{
			obj.AddComponent<RoomAmbientLight>();
		}
	}

	public static void Link(List<MapChunk> chunks)
	{
		for (int num = chunks.Count - 1; num > 0; num--)
		{
			MapChunk mapChunk = chunks[num];
			for (int num2 = num - 1; num2 >= 0; num2--)
			{
				MapChunk mapChunk2 = chunks[num2];
				mapChunk.Link(mapChunk2);
				mapChunk2.Link(mapChunk);
			}
		}
	}

	private void Link(MapChunk other)
	{
	}

	public void RemoveGeometry(GameObject obj, bool removeFromCombineList = false, bool checkVisibilityCount = false)
	{
		if ((bool)obj.GetComponent<Renderer>())
		{
			renderers.Remove(obj.GetComponent<Renderer>());
		}
		if (checkVisibilityCount && visible)
		{
			IncVisibilityCount(obj.GetComponent<Renderer>(), -1);
		}
		if (removeFromCombineList)
		{
			MeshFilter component = obj.GetComponent<MeshFilter>();
			if (component != null)
			{
				toCombine.Remove(component);
			}
		}
		for (int i = 0; i < obj.transform.childCount; i++)
		{
			RemoveGeometry(obj.transform.GetChild(i).gameObject, removeFromCombineList);
		}
	}

	private void Awake()
	{
		nextState = false;
		visible = true;
		timeVisible = -1f;
	}

	public void DoUpdate()
	{
		if (visible && timeVisible > 0f)
		{
			timeVisible -= Time.fixedDeltaTime;
		}
		if (!visible || timeVisible <= 0f)
		{
			for (int i = 0; i < linkedChunks.Count; i++)
			{
				if (nextState)
				{
					linkedChunks[i].nextState = true;
				}
				else if (linkedChunks[i].nextState)
				{
					nextState = true;
				}
			}
			if (nextState != visible)
			{
				visible = nextState;
				for (int j = 0; j < renderers.Count; j++)
				{
					int value = 0;
					value = ((!rendererStateMap.TryGetValue(renderers[j], out value)) ? (visible ? 1 : 0) : ((!visible) ? (value - 1) : (value + 1)));
					rendererStateMap[renderers[j]] = value;
					if (value == 0 || value == 1)
					{
						renderers[j].enabled = value > 0;
					}
				}
				for (int k = 0; k < lights.Count; k++)
				{
					lights[k].enabled = visible;
				}
			}
			if (visible)
			{
				timeVisible = 0.5f;
			}
		}
		nextState = false;
	}

	[Conditional("UNITY_EDITOR")]
	public void Visibilize()
	{
		Visible = true;
		for (int i = 0; i < renderers.Count; i++)
		{
			renderers[i].enabled = true;
		}
		for (int j = 0; j < lights.Count; j++)
		{
			lights[j].enabled = true;
		}
	}

	public static int GetRendererVisibilityCount(Renderer renderer)
	{
		int value = 0;
		if (rendererStateMap == null)
		{
			return 0;
		}
		rendererStateMap.TryGetValue(renderer, out value);
		return value;
	}

	private static void IncVisibilityCount(Renderer renderer, int delta = 1)
	{
		int value = 0;
		rendererStateMap.TryGetValue(renderer, out value);
		rendererStateMap[renderer] = value + delta;
	}

	private void OnDrawGizmosSelected()
	{
		DebugRender((!visible) ? Color.yellow : Color.red);
	}

	public void DebugRender(Color color)
	{
		float num = 4f * Map.Get().TileSize.x;
		DebugExt.DrawCube(base.transform.position - new Vector3(Map.Get().TileSize.x / 2f, 0f, (0f - Map.Get().TileSize.x) / 2f) + new Vector3(num / 2f, 1.75f, (0f - num) / 2f), color, new Vector3(num, 3.5f, num));
	}

	public static bool CheckCellNextToVisible(Point cellPos)
	{
		MapChunk mapChunk = At(cellPos);
		if (mapChunk.Visible)
		{
			return true;
		}
		for (int i = cellPos.Y - 1; i <= cellPos.Y + 1; i += 2)
		{
			mapChunk = At(cellPos.X, i);
			if (mapChunk.Visible)
			{
				return true;
			}
		}
		for (int j = cellPos.X - 1; j <= cellPos.X + 1; j += 2)
		{
			mapChunk = At(j, cellPos.Y);
			if (mapChunk.Visible)
			{
				return true;
			}
		}
		return false;
	}
}
public abstract class MapGenerator
{
	public MapGenerator()
	{
	}

	public abstract Map Generate(int w, int h, Texture2D texOut, bool checkDoubleCorridors = true, bool checkRoomConnections = true);
}
public class MapGraph
{
	public class Node
	{
		public Room room;

		public Point pos;

		public List<Node> edges;

		public List<float> edgesCost;

		public bool doubleCorridor;

		public Node(Point p, Room r = null)
		{
			pos = p;
			room = r;
			edges = new List<Node>();
			edgesCost = new List<float>();
			doubleCorridor = false;
		}

		public void AddEdge(Node n)
		{
			if (!edges.Contains(n))
			{
				float num = Mathf.Abs(n.pos.X - pos.X) + Mathf.Abs(n.pos.Y - pos.Y);
				num *= 1.5f;
				edges.Add(n);
				edgesCost.Add(num);
			}
		}

		public override bool Equals(object obj)
		{
			Node node = (Node)obj;
			return node.pos.X == pos.X && node.pos.Y == pos.Y;
		}
	}

	private class MapInfo
	{
		public Cell[][] CellMap;

		public int Width;

		public int Height;

		public List<Room> rooms;

		public List<Point> entrancePositions;

		public List<Point> doorPositions;

		public Cell At(Point pos)
		{
			if (!InRange(pos))
			{
				return null;
			}
			return CellMap[pos.Y][pos.X];
		}

		public Cell At(int x, int y)
		{
			if (!InRange(x, y))
			{
				return null;
			}
			return CellMap[y][x];
		}

		private bool InRange(Point tilePos)
		{
			return InRange(tilePos.X, tilePos.Y);
		}

		private bool InRange(int x, int y)
		{
			return x >= 0 && x < Width && y >= 0 && y < Height;
		}
	}

	public List<Node> nodes = new List<Node>();

	private Dictionary<Room, Node> dictRooms = new Dictionary<Room, Node>();

	private Dictionary<Point, Node> dictPoints = new Dictionary<Point, Node>();

	private List<Point> open = new List<Point>();

	private bool[][] explored;

	private Dictionary<Room, float> deadendWeights;

	public void CreateFromMap(Cell[][] CellMap, int width, int height, List<Room> rooms, List<Point> entrancePositions, List<Point> doorPositions)
	{
		MapInfo mapInfo = new MapInfo();
		mapInfo.CellMap = CellMap;
		mapInfo.Width = width;
		mapInfo.Height = height;
		mapInfo.rooms = rooms;
		mapInfo.entrancePositions = entrancePositions;
		mapInfo.doorPositions = doorPositions;
		CreateFromMap(mapInfo);
	}

	private void CreateFromMap(MapInfo map)
	{
		nodes.Clear();
		dictRooms.Clear();
		dictPoints.Clear();
		open.Clear();
		explored = new bool[map.Height][];
		for (int i = 0; i < map.Height; i++)
		{
			explored[i] = new bool[map.Width];
		}
		foreach (Room room in map.rooms)
		{
			Point p = room.Start + room.Size / 2;
			Node node = new Node(p, room);
			nodes.Add(node);
			dictRooms[room] = node;
		}
		List<Point> list = new List<Point>();
		list.AddRange(map.entrancePositions);
		list.AddRange(map.doorPositions);
		foreach (Point item in list)
		{
			if (dictPoints.TryGetValue(item, out var value))
			{
				continue;
			}
			Node value2 = null;
			dictPoints.TryGetValue(new Point(item.X - 1, item.Y), out value2);
			if (value2 == null)
			{
				dictPoints.TryGetValue(new Point(item.X, item.Y - 1), out value2);
			}
			if (value2 != null && value2.room == null)
			{
				value2.doubleCorridor = true;
				explored[item.Y][item.X] = true;
				continue;
			}
			value = new Node(item);
			nodes.Add(value);
			open.Add(item);
			dictPoints[item] = value;
			Cell cell = map.At(item);
			if (cell.Room != null)
			{
				Node node2 = dictRooms[cell.Room];
				value.AddEdge(node2);
				node2.AddEdge(value);
			}
		}
		Node[] array = new Node[8];
		while (open.Count > 0)
		{
			Point point = open[0];
			open.RemoveAt(0);
			if (explored[point.Y][point.X])
			{
				continue;
			}
			explored[point.Y][point.X] = true;
			Cell cell2 = map.At(point);
			if (!cell2.CanWalk() || !dictPoints.TryGetValue(point, out var value3))
			{
				continue;
			}
			if (value3.doubleCorridor)
			{
				point = value3.pos;
				explored[point.Y][point.X] = true;
				explored[point.Y][point.X + 1] = true;
				explored[point.Y + 1][point.X] = true;
				explored[point.Y + 1][point.X + 1] = true;
			}
			if (!value3.doubleCorridor)
			{
				array[0] = Explore(map, new Point(point.X - 1, point.Y));
				array[1] = Explore(map, new Point(point.X + 1, point.Y));
				array[2] = Explore(map, new Point(point.X, point.Y - 1));
				array[3] = Explore(map, new Point(point.X, point.Y + 1));
			}
			else
			{
				array[0] = Explore(map, new Point(point.X - 1, point.Y));
				array[1] = Explore(map, new Point(point.X - 1, point.Y + 1));
				array[2] = Explore(map, new Point(point.X, point.Y - 1));
				array[3] = Explore(map, new Point(point.X + 1, point.Y - 1));
				array[4] = Explore(map, new Point(point.X + 2, point.Y));
				array[5] = Explore(map, new Point(point.X + 2, point.Y + 1));
				array[6] = Explore(map, new Point(point.X, point.Y + 2));
				array[7] = Explore(map, new Point(point.X + 1, point.Y + 2));
			}
			int num = ((!value3.doubleCorridor) ? 4 : 8);
			for (int j = 0; j < num; j++)
			{
				Node node3 = array[j];
				if (node3 != null)
				{
					value3.AddEdge(node3);
					node3.AddEdge(value3);
				}
			}
		}
	}

	private Node Explore(MapInfo map, Point pos)
	{
		Cell cell = map.At(pos);
		if (!cell.CanWalk())
		{
			return null;
		}
		bool flag = IsDoubleCorridor(map, pos);
		if (flag)
		{
			pos = MapToDouble(pos);
		}
		Node value = null;
		if (dictPoints.TryGetValue(pos, out value))
		{
			return value;
		}
		if (cell.Room != null)
		{
			return dictRooms[cell.Room];
		}
		if (explored[pos.Y][pos.X])
		{
			return null;
		}
		bool flag2 = false;
		bool flag3;
		bool flag4;
		bool flag5;
		bool flag6;
		if (!flag)
		{
			flag3 = map.At(pos.X, pos.Y - 1).CanWalk();
			flag4 = map.At(pos.X, pos.Y + 1).CanWalk();
			flag5 = map.At(pos.X - 1, pos.Y).CanWalk();
			flag6 = map.At(pos.X + 1, pos.Y).CanWalk();
		}
		else
		{
			flag3 = map.At(pos.X, pos.Y - 1).CanWalk() || map.At(pos.X + 1, pos.Y - 1).CanWalk();
			flag4 = map.At(pos.X, pos.Y + 2).CanWalk() || map.At(pos.X + 1, pos.Y + 2).CanWalk();
			flag5 = map.At(pos.X - 1, pos.Y).CanWalk() || map.At(pos.X - 1, pos.Y + 1).CanWalk();
			flag6 = map.At(pos.X + 2, pos.Y).CanWalk() || map.At(pos.X + 2, pos.Y + 1).CanWalk();
		}
		if ((flag5 && flag6 && flag4) || (flag5 && flag3 && flag4) || (flag3 && flag6 && flag4) || (flag5 && flag3 && flag6))
		{
			flag2 = true;
		}
		if (flag2)
		{
			Node node = new Node(pos);
			node.doubleCorridor = flag;
			nodes.Add(node);
			dictPoints[pos] = node;
			open.Add(pos);
			return node;
		}
		explored[pos.Y][pos.X] = true;
		if (flag)
		{
			explored[pos.Y][pos.X + 1] = true;
			explored[pos.Y + 1][pos.X] = true;
			explored[pos.Y + 1][pos.X + 1] = true;
		}
		Node[] array = new Node[8];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = null;
		}
		if (!flag)
		{
			if (!explored[pos.Y][pos.X - 1])
			{
				array[0] = Explore(map, new Point(pos.X - 1, pos.Y));
			}
			if (!explored[pos.Y][pos.X + 1])
			{
				array[1] = Explore(map, new Point(pos.X + 1, pos.Y));
			}
			if (!explored[pos.Y - 1][pos.X])
			{
				array[2] = Explore(map, new Point(pos.X, pos.Y - 1));
			}
			if (!explored[pos.Y + 1][pos.X])
			{
				array[3] = Explore(map, new Point(pos.X, pos.Y + 1));
			}
		}
		else
		{
			if (!explored[pos.Y][pos.X - 1])
			{
				array[0] = Explore(map, new Point(pos.X - 1, pos.Y));
			}
			if (!explored[pos.Y + 1][pos.X + 1])
			{
				array[1] = Explore(map, new Point(pos.X - 1, pos.Y + 1));
			}
			if (!explored[pos.Y - 1][pos.X])
			{
				array[2] = Explore(map, new Point(pos.X, pos.Y - 1));
			}
			if (!explored[pos.Y - 1][pos.X + 1])
			{
				array[3] = Explore(map, new Point(pos.X + 1, pos.Y - 1));
			}
			if (!explored[pos.Y][pos.X + 2])
			{
				array[4] = Explore(map, new Point(pos.X + 2, pos.Y));
			}
			if (!explored[pos.Y + 1][pos.X + 2])
			{
				array[5] = Explore(map, new Point(pos.X + 2, pos.Y + 1));
			}
			if (!explored[pos.Y + 2][pos.X])
			{
				array[6] = Explore(map, new Point(pos.X, pos.Y + 2));
			}
			if (!explored[pos.Y + 2][pos.X + 1])
			{
				array[7] = Explore(map, new Point(pos.X + 1, pos.Y + 2));
			}
		}
		for (int j = 0; j < array.Length; j++)
		{
			if (array[j] != null)
			{
				return array[j];
			}
		}
		return null;
	}

	private Point MapToDouble(Point pos)
	{
		return new Point(2 * (pos.X / 2), 2 * (pos.Y / 2));
	}

	private bool IsDoubleCorridor(MapInfo map, Point pos)
	{
		Point pos2 = MapToDouble(pos);
		Cell cell = map.At(pos2);
		Cell cell2 = map.At(pos2.X + 1, pos2.Y);
		Cell cell3 = map.At(pos2.X, pos2.Y + 1);
		Cell cell4 = map.At(pos2.X + 1, pos2.Y + 1);
		if (cell.CanWalk() && cell2.CanWalk() && cell3.CanWalk() && cell4.CanWalk())
		{
			return true;
		}
		return false;
	}

	public bool CheckConnected()
	{
		if (nodes.Count == 0)
		{
			return false;
		}
		List<Node> list = new List<Node>();
		List<Node> list2 = new List<Node>();
		list2.Add(nodes[0]);
		while (list2.Count > 0)
		{
			Node node = list2[0];
			list2.RemoveAt(0);
			if (list.Contains(node))
			{
				continue;
			}
			list.Add(node);
			foreach (Node edge in node.edges)
			{
				if (!list2.Contains(edge))
				{
					list2.Add(edge);
				}
			}
		}
		return list.Count == nodes.Count;
	}

	public void ComputeDeadEndWeights()
	{
		deadendWeights = new Dictionary<Room, float>();
		List<Node> list = new List<Node>();
		foreach (Room key in dictRooms.Keys)
		{
			Node node = dictRooms[key];
			float num = 0f;
			Node node2 = node;
			list.Clear();
			while (node2 != null)
			{
				list.Add(node2);
				int num2 = 0;
				int index = -1;
				for (int i = 0; i < node2.edges.Count; i++)
				{
					if (!list.Contains(node2.edges[i]))
					{
						num2++;
						if (num2 == 1)
						{
							index = i;
						}
					}
				}
				if (node2.room != null && node2.room != key)
				{
					node2 = null;
				}
				else if (num2 == 1)
				{
					num += node2.edgesCost[index];
					node2 = node2.edges[index];
				}
				else
				{
					node2 = null;
				}
			}
			deadendWeights[key] = num;
		}
	}

	public float GetDeadEndWeight(Room r)
	{
		float value = 0f;
		deadendWeights.TryGetValue(r, out value);
		return value;
	}

	public int GetNumConnections(Room r)
	{
		if (dictRooms.TryGetValue(r, out var value))
		{
			return value.edges.Count;
		}
		return 0;
	}

	[Conditional("DH_DEBUG")]
	public void DebugDraw(float height = 0.5f, float duration = 0f, bool applyDeadends = false)
	{
		foreach (Node node in nodes)
		{
			Vector3 vector = Map.Get().CellToWorld(node.pos) + Vector3.up * height;
			if (applyDeadends && node.room != null)
			{
				vector += Vector3.up * deadendWeights[node.room];
			}
			Color col = Color.red;
			if (node.room != null)
			{
				col = Color.blue;
				if (node.room.IsDeadEnd)
				{
					col = Color.green;
				}
			}
			DebugExt.DrawSphere(vector, col, 1f, duration);
			foreach (Node edge in node.edges)
			{
				Vector3 end = Map.Get().CellToWorld(edge.pos) + Vector3.up * height;
				if (applyDeadends && edge.room != null)
				{
					end += Vector3.up * deadendWeights[edge.room];
				}
				Debug.DrawLine(vector, end, Color.red, duration);
			}
		}
	}
}
public class MapLoS
{
	public static bool LineOfWalk(Vector3 from, Vector3 to, bool canTraverseCorners = false, bool checkNoPlayer = false, bool canFloat = false)
	{
		return LineOfSight(Map.Get().WorldToCell(from), Map.Get().WorldToCell(to), canTraverseCorners, bWalk: true, checkNoPlayer, canFloat);
	}

	public static bool LineOfWalk(Point from, Point to, bool canTraverseCorners = false, bool checkNoPlayer = false, bool canFloat = false)
	{
		return LineOfSight(from, to, canTraverseCorners, bWalk: true, checkNoPlayer, canFloat);
	}

	public static bool LineOfSight(Point from, Point to, bool canTraverseCorners, bool bWalk, bool checkNoPlayer, bool canFloat)
	{
		Map map = Map.Get();
		int num = Mathf.Abs(to.X - from.X);
		int num2 = Mathf.Abs(to.Y - from.Y);
		Point point = from;
		Point point2 = from;
		int num3 = 1 + num + num2;
		int num4 = ((to.X > from.X) ? 1 : (-1));
		int num5 = ((to.Y > from.Y) ? 1 : (-1));
		int num6 = num - num2;
		num *= 2;
		num2 *= 2;
		Point point3 = new Point(0, 0);
		if (checkNoPlayer)
		{
			point3 = Map.Get().WorldToCell(Player.GetPos());
			if (point3 == from)
			{
				point3 = new Point(0, 0);
			}
		}
		while (num3 > 0)
		{
			num3--;
			Cell cell = map.At(point);
			if (cell == null)
			{
				return false;
			}
			if (bWalk && (!cell.CanWalk() || (cell.Occupied && (!canFloat || !cell.CanFloatOver) && cell.Room != null)))
			{
				if (point != from)
				{
					return false;
				}
			}
			else if (!bWalk && !cell.IsTransparent() && point != from)
			{
				return false;
			}
			if (!canTraverseCorners && bWalk)
			{
				if (point2.X != point.X && point2.Y != point.Y && (!map.At(new Point(point2.X, point.Y)).CanWalk() || !map.At(new Point(point.X, point2.Y)).CanWalk()))
				{
					return false;
				}
				if ((to.X > point.X && !map.At(new Point(point.X + 1, point.Y)).CanWalk()) || (to.X < point.X && !map.At(new Point(point.X - 1, point.Y)).CanWalk()) || (to.Y > point.Y && !map.At(new Point(point.X, point.Y + 1)).CanWalk()) || (to.Y < point.Y && !map.At(new Point(point.X, point.Y - 1)).CanWalk()))
				{
					return false;
				}
			}
			else if (!canTraverseCorners && !bWalk)
			{
				if (point2.X != point.X && point2.Y != point.Y && (!map.At(new Point(point2.X, point.Y)).IsTransparent() || !map.At(new Point(point.X, point2.Y)).IsTransparent()))
				{
					return false;
				}
				if ((to.X > point.X && !map.At(new Point(point.X + 1, point.Y)).CanWalk()) || (to.X < point.X && !map.At(new Point(point.X - 1, point.Y)).CanWalk()) || (to.Y > point.Y && !map.At(new Point(point.X, point.Y + 1)).CanWalk()) || (to.Y < point.Y && !map.At(new Point(point.X, point.Y - 1)).CanWalk()))
				{
					return false;
				}
			}
			if (checkNoPlayer && point == point3)
			{
				return false;
			}
			point2 = point;
			if (num6 > 0)
			{
				point.X += num4;
				num6 -= num2;
			}
			else
			{
				point.Y += num5;
				num6 += num;
			}
		}
		return true;
	}
}
public class MapStyle : ScriptableObject
{
	[Serializable]
	public class DoorInset
	{
		public string doorType;

		public float inset;

		public DoorInset(string dType, float amount)
		{
			doorType = dType;
			inset = amount;
		}
	}

	public string styleName;

	public float ceilingHeight;

	public float hangingOffset;

	public bool arched;

	public string tags;

	[NonSerialized]
	public string[] tagList;

	[Range(0f, 25f)]
	public float weight = 1f;

	public GameObject floorPrefab;

	public string floorStepSound = "default";

	public GameObject[] lWallPrefabs;

	public GameObject lWallCapLeft;

	public GameObject lWallCapRight;

	public GameObject doorFrame25Prefab;

	public GameObject doorFrame35Prefab;

	public bool offsetDoorFrame;

	public GameObject outCornerPrefab;

	public GameObject inCornerPrefab;

	public GameObject deadendPrefab;

	public CeilingPrefabs ceilingPrefabs;

	public GameObject topTransitionPrefab;

	public GameObject ceilingTransitionPrefab;

	public float transitionHOffset;

	public float transitionOutOffset = 0.05f;

	public bool removeOutCornersInDoor;

	public GameObject doorOutCornerPrefab;

	public float doorInset = 0.06f;

	public List<DoorInset> doorInsets;

	public float propMargin;

	public float propMarginInCorner;

	public float propMarginOutCorner;

	public float propMarginOutCornerLat;

	public bool allowWallPropsInCorners = true;

	public bool hasNarrowDeadends;

	public bool allowRockColumnsBottom;

	public bool allowRockColumnsTop;

	public List<MapBrushWeight> corridorBrushes;

	public List<MapBrushWeight> roomWallBrushes;

	public MapStyle pitStyle;

	public MapStyle shaftSyle;

	public bool floorNoise;

	public bool ceilingNoise;

	public bool collapseEdges;

	public void OnEnable()
	{
		tagList = tags.Split(',');
	}

	public static MapStyle FindForTags(MapStyle[] styles, List<string> tags)
	{
		if (styles.Length == 0)
		{
			return null;
		}
		List<MapStyle> list = new List<MapStyle>();
		foreach (MapStyle mapStyle in styles)
		{
			if (mapStyle.tagList == null)
			{
				mapStyle.tagList = mapStyle.tags.Split(',');
			}
			int num = Mathf.Min(mapStyle.tagList.Length, tags.Count);
			bool flag = true;
			int num2 = 0;
			while (flag && num2 < num)
			{
				flag = tags[num2] == mapStyle.tagList[num2];
				num2++;
			}
			if (flag)
			{
				list.Add(mapStyle);
			}
		}
		if (list.Count > 0)
		{
			return ChooseStyle(list);
		}
		return styles[0];
	}

	private static MapStyle ChooseStyle(List<MapStyle> styles)
	{
		if (styles.Count == 0)
		{
			return null;
		}
		if (styles.Count == 1)
		{
			return styles[0];
		}
		float num = 0f;
		foreach (MapStyle style in styles)
		{
			num += style.weight;
		}
		float num2 = UnityEngine.Random.Range(0f, num);
		foreach (MapStyle style2 in styles)
		{
			if (style2.weight > num2)
			{
				return style2;
			}
			num2 -= style2.weight;
		}
		return styles[styles.Count - 1];
	}

	public static MapStyle FindByName(MapStyle[] styles, string styleName)
	{
		for (int i = 0; i < styles.Length; i++)
		{
			if (styles[i].styleName == styleName)
			{
				return styles[i];
			}
		}
		Debug.LogError("Invalid MapStyle: " + styleName);
		return null;
	}

	public MapBrush ChooseCorridorBrush()
	{
		return ChooseBrush(corridorBrushes);
	}

	public MapBrush ChooseRoomWallBrush()
	{
		return ChooseBrush(roomWallBrushes);
	}

	private static MapBrush ChooseBrush(List<MapBrushWeight> brushes)
	{
		if (brushes.Count == 0)
		{
			return null;
		}
		if (brushes.Count == 1)
		{
			return brushes[0].brush;
		}
		float num = 0f;
		foreach (MapBrushWeight brush in brushes)
		{
			num += brush.weight;
		}
		float num2 = UnityEngine.Random.Range(0f, num);
		foreach (MapBrushWeight brush2 in brushes)
		{
			if (brush2.weight > num2)
			{
				return brush2.brush;
			}
			num2 -= brush2.weight;
		}
		return brushes[brushes.Count - 1].brush;
	}

	public GameObject GetCeilingTransitionPrefab()
	{
		if (ceilingTransitionPrefab != null)
		{
			return ceilingTransitionPrefab;
		}
		return topTransitionPrefab;
	}

	public string GetMainTag()
	{
		if (tagList.Length > 0)
		{
			return tagList[0];
		}
		return string.Empty;
	}
}
[Serializable]
public class CeilingPrefabs
{
	public GameObject smSinglePrefab;

	public GameObject smLWallPrefab;

	public GameObject smDeadendPrefab;

	public GameObject smCornerPrefab;

	public GameObject smTIntersectionPrefab;

	public GameObject sm4IntersectionPrefab;

	public GameObject lgSinglePrefab;

	public GameObject lgLWallPrefab;

	public GameObject lgOutCornerPrefab;

	public GameObject lgInCornerPrefab;

	public bool alignPieces;

	public bool noRotate;

	public bool alignToRoomDirection;
}
[Serializable]
public class MapBrushWeight
{
	public MapBrush brush;

	[Range(0f, 10f)]
	public float weight = 1f;
}
namespace MapTags
{
	internal class MapTagArea
	{
		public string[] tags;

		public TileArea area;

		public MapTagArea(string[] tags)
		{
			this.tags = tags;
			area = new TileArea();
		}

		public bool CheckTags(string[] tags)
		{
			foreach (string text in tags)
			{
				bool flag = false;
				for (int j = 0; j < this.tags.Length; j++)
				{
					if (flag)
					{
						break;
					}
					if (this.tags[j] == text)
					{
						flag = true;
					}
				}
				if (!flag)
				{
					return false;
				}
			}
			return true;
		}

		public void AddException(Point tile)
		{
			area.AddException(tile);
		}
	}
	internal class MapTagGroup
	{
		public List<MapTagArea> tagAreas;

		public MapTagGroup()
		{
			tagAreas = new List<MapTagArea>();
		}

		public void Set(string[] tags, IntRect rect)
		{
			for (int i = 0; i < tagAreas.Count; i++)
			{
				if (tagAreas[i].CheckTags(tags))
				{
					tagAreas[i].area.Add(rect);
					return;
				}
			}
			MapTagArea mapTagArea = new MapTagArea(tags);
			mapTagArea.area.Add(rect);
			tagAreas.Add(mapTagArea);
		}

		public void Set(string[] tags, Point tile)
		{
			Set(tags, new IntRect(tile.X, tile.Y, 1, 1));
		}

		public void AddException(string[] tags, Point tile)
		{
			for (int i = 0; i < tagAreas.Count; i++)
			{
				if (tagAreas[i].CheckTags(tags))
				{
					tagAreas[i].area.AddException(tile);
					break;
				}
			}
		}

		public bool GetTags(Point tile, List<string> tags)
		{
			for (int num = tagAreas.Count - 1; num >= 0; num--)
			{
				if (tagAreas[num].area.IsInside(tile))
				{
					tags.AddRange(tagAreas[num].tags);
					return true;
				}
			}
			return false;
		}
	}
	public enum Group
	{
		Main,
		Style,
		Substyle
	}
	public class Manager
	{
		private Dictionary<Group, MapTagGroup> tagGroups;

		private Dictionary<int, MapStyle> styleCache;

		private byte[][] variationMap;

		private List<string> tagsTemp;

		public Manager(int width, int height)
		{
			tagGroups = new Dictionary<Group, MapTagGroup>();
			tagGroups[Group.Main] = new MapTagGroup();
			tagGroups[Group.Style] = new MapTagGroup();
			tagGroups[Group.Substyle] = new MapTagGroup();
			styleCache = new Dictionary<int, MapStyle>();
			tagsTemp = new List<string>();
			variationMap = new byte[height][];
			for (int i = 0; i < height; i++)
			{
				variationMap[i] = new byte[width];
				for (int j = 0; j < width; j++)
				{
					variationMap[i][j] = 0;
				}
			}
		}

		public void Set(Group type, string[] tags, IntRect rect)
		{
			MapTagGroup value = null;
			if (!tagGroups.TryGetValue(type, out value))
			{
				value = new MapTagGroup();
				tagGroups[type] = value;
			}
			value.Set(tags, rect);
		}

		public void Set(Group type, string[] tags, Point tile)
		{
			Set(type, tags, new IntRect(tile.X, tile.Y, 1, 1));
		}

		public void Set(Group type, string tag, IntRect rect)
		{
			Set(type, new string[1] { tag }, rect);
		}

		public void Set(Group type, string tag, Point tile)
		{
			Set(type, new string[1] { tag }, new IntRect(tile.X, tile.Y, 1, 1));
		}

		public void SetVariation(char variation, Point tile)
		{
			variationMap[tile.Y][tile.X] = (byte)(variation - 65);
		}

		public MapStyle GetStyle(MapStyle[] styles, Point tile)
		{
			GetTags(tile, tagsTemp);
			return GetStyle(styles, tagsTemp);
		}

		public bool HasStyleSet(Point tile)
		{
			GetTags(tile, tagsTemp);
			return tagsTemp.Count > 1;
		}

		public MapStyle GetStyle(MapStyle[] styles, List<string> tags)
		{
			int orderIndependentHashCode = tags.GetOrderIndependentHashCode();
			MapStyle value = null;
			if (!styleCache.TryGetValue(orderIndependentHashCode, out value))
			{
				value = MapStyle.FindForTags(styles, tags);
				styleCache[orderIndependentHashCode] = value;
			}
			return value;
		}

		public void SetStyle(List<string> tags, MapStyle style)
		{
			int orderIndependentHashCode = tags.GetOrderIndependentHashCode();
			styleCache[orderIndependentHashCode] = style;
		}

		public void SetStyle(string[] tags, MapStyle style)
		{
			List<string> tags2 = new List<string>(tags);
			SetStyle(tags2, style);
		}

		public byte GetVariation(Point tile)
		{
			return variationMap[tile.Y][tile.X];
		}

		private void GetTags(Point tile, List<string> tags)
		{
			tags.Clear();
			tagGroups[Group.Main].GetTags(tile, tags);
			tagGroups[Group.Style].GetTags(tile, tags);
			tagGroups[Group.Substyle].GetTags(tile, tags);
		}

		private void AddException(Group type, string[] tags, Point tile)
		{
			MapTagGroup value = null;
			if (tagGroups.TryGetValue(type, out value))
			{
				value.AddException(tags, tile);
			}
		}

		public void AddException(Group type, Point tile)
		{
			MapTagGroup value = null;
			if (tagGroups.TryGetValue(type, out value))
			{
				List<string> list = new List<string>();
				value.GetTags(tile, list);
				if (list.Count > 0)
				{
					value.AddException(list.ToArray(), tile);
				}
			}
		}
	}
}
public class OcclusionManager : MonoBehaviour
{
	public Transform player;

	public bool activeOcclusion = true;

	private void Start()
	{
		activeOcclusion = true;
		if (player == null)
		{
			player = Player.Get().transform;
		}
		PermissiveFOV.callback = ExploreTile;
	}

	private void Update()
	{
		if (activeOcclusion)
		{
			float maxSeeingDistance = AmbientManager.Get().GetMaxSeeingDistance();
			PermissiveFOV.Scan(Map.Get(), Map.Get().WorldToCell(player.position), (int)(maxSeeingDistance / Map.Get().TileSize.x) + 1);
		}
		else
		{
			for (int i = 0; i < MapChunk.chunkMap.Length; i++)
			{
				for (int j = 0; j < MapChunk.chunkMap[i].Length; j++)
				{
					MapChunk.chunkMap[i][j].Visible = true;
				}
			}
		}
		for (int k = 0; k < MapChunk.chunkMap.Length; k++)
		{
			for (int l = 0; l < MapChunk.chunkMap[k].Length; l++)
			{
				MapChunk mapChunk = MapChunk.chunkMap[k][l];
				if (mapChunk.nextState || mapChunk.Visible)
				{
					mapChunk.DoUpdate();
				}
			}
		}
	}

	[Conditional("UNITY_EDITOR")]
	public void VisibilizeAll()
	{
		for (int i = 0; i < MapChunk.chunkMap.Length; i++)
		{
			for (int j = 0; j < MapChunk.chunkMap[i].Length; j++)
			{
			}
		}
	}

	public static void ExploreTile(Map map, Cell tTile, Point tPos)
	{
		MapChunk.At(tPos.X, tPos.Y).Visible = true;
	}
}
public class OcclusionTracker : OcclusionTrackerStatic
{
	public bool trackPosition;

	private Point lastCell;

	private new void Start()
	{
		base.Start();
		if (trackPosition)
		{
			lastCell = Map.Get().WorldToCell(base.transform.position);
		}
	}

	private void Update()
	{
		if (!trackPosition || chunks.Count != 1)
		{
			return;
		}
		Point point = Map.Get().WorldToCell(base.transform.position);
		if (point != lastCell)
		{
			lastCell = point;
			MapChunk mapChunk = MapChunk.At(point);
			if (mapChunk != chunks[0])
			{
				chunks[0].RemoveGeometry(base.gameObject, removeFromCombineList: false, checkVisibilityCount: true);
				mapChunk.AddGeometry(base.gameObject, addTracker: false);
				chunks[0] = mapChunk;
			}
		}
	}

	public static void AddToTracker(GameObject obj, MapChunk chunk)
	{
		OcclusionTrackerStatic occlusionTrackerStatic = obj.GetComponent<OcclusionTrackerStatic>();
		if (occlusionTrackerStatic == null)
		{
			occlusionTrackerStatic = obj.AddComponent<OcclusionTrackerStatic>();
		}
		if (occlusionTrackerStatic.margin == 0)
		{
			occlusionTrackerStatic.AddChunk(chunk);
			occlusionTrackerStatic.addOnStart = false;
		}
	}
}
public class OcclusionTrackerStatic : MonoBehaviour
{
	public bool addOnStart = true;

	public int margin;

	protected List<MapChunk> chunks;

	protected void Start()
	{
		if (addOnStart)
		{
			if (margin == 0)
			{
				MapChunk mapChunk = MapChunk.At(Map.Get().WorldToCell(base.transform.position));
				mapChunk.AddGeometry(base.gameObject, addTracker: false);
				AddChunk(mapChunk);
			}
			else
			{
				Point point = Map.Get().WorldToCell(base.transform.position);
				MapChunk.AddGeometry(pos: new Point(point.X - margin, point.Y + margin), obj: base.gameObject, width: margin * 2 + 1, height: margin * 2 + 1);
			}
		}
		addOnStart = false;
	}

	private void OnDestroy()
	{
		if (chunks != null)
		{
			for (int i = 0; i < chunks.Count; i++)
			{
				chunks[i].RemoveGeometry(base.gameObject);
			}
		}
	}

	public void AddChunk(MapChunk chunk)
	{
		if (chunks == null)
		{
			chunks = new List<MapChunk>();
		}
		chunks.Add(chunk);
	}
}
public class Room
{
	public delegate void RoomCallback(Room room);

	public int Id;

	public Point Start;

	public Point Size;

	public RoomTemplate Template;

	public bool Safe;

	public bool IsSpawnRoom;

	public bool IsExitRoom;

	public bool IsHorror;

	public bool IsWellLayout;

	public List<PropInfo> props;

	public List<InteractiveLightEx> lights;

	public int numLightcasters;

	public List<GameObject> gargoyles;

	public List<Floater> floaters;

	public List<CreatureCounter> creatures;

	public bool hasBats;

	public List<Point> doors;

	public List<Point> entrances;

	public RoomCallback OnEnter;

	public RoomCallback OnFirstEnter;

	public RoomCallback OnExit;

	private bool playerEverEntered;

	private bool playerInside;

	public bool IsDeadEnd;

	public bool HasLocalEnemy;

	private List<Point> listValidPos;

	private List<Point> listValidCentralPos;

	public bool PlayerEverEntered => playerEverEntered;

	public bool PlayerInside => playerInside;

	public Room(int roomID, int StartX, int StartY, int SizeX, int SizeY, RoomTemplate template)
	{
		Id = roomID;
		Start = new Point(StartX, StartY);
		Size = new Point(SizeX, SizeY);
		Template = template;
		Safe = false;
		IsSpawnRoom = false;
		IsExitRoom = false;
		IsHorror = false;
		IsWellLayout = false;
		IsDeadEnd = false;
		HasLocalEnemy = false;
		props = new List<PropInfo>();
		lights = new List<InteractiveLightEx>();
		gargoyles = new List<GameObject>();
		floaters = new List<Floater>();
		creatures = new List<CreatureCounter>();
		doors = new List<Point>();
		entrances = new List<Point>();
	}

	public void PlayerEnter()
	{
		playerInside = true;
		if (!playerEverEntered && OnFirstEnter != null)
		{
			OnFirstEnter(this);
		}
		playerEverEntered = true;
		if (OnEnter != null)
		{
			OnEnter(this);
		}
		if (hasBats)
		{
			GameController.Get().GetComponent<MapBuilder>().SpawnBats(this);
			hasBats = false;
		}
	}

	public void PlayerExit()
	{
		playerInside = false;
		if (OnExit != null)
		{
			OnExit(this);
		}
	}

	public void BuildValidPosLists()
	{
		if (listValidPos != null && listValidCentralPos != null)
		{
			return;
		}
		listValidPos = new List<Point>();
		listValidCentralPos = new List<Point>();
		for (int i = Start.Y; i < Start.Y + Size.Y; i++)
		{
			for (int j = Start.X; j < Start.X + Size.X; j++)
			{
				Point point = new Point(j, i);
				if (point.Y > 0 && point.Y < Map.Get().Height - 1 && point.X > 0 && point.X < Map.Get().Width - 1 && Map.Get().At(point.X, point.Y).IsClear() && Map.Get().At(point.X, point.Y).Room == this && !Map.Get().At(point.X, point.Y).IsDoor)
				{
					listValidPos.Add(point);
					if (Map.Get().At(point.X, point.Y - 1).IsClearOrPit() && Map.Get().At(point.X, point.Y + 1).IsClearOrPit() && Map.Get().At(point.X - 1, point.Y).IsClearOrPit() && Map.Get().At(point.X + 1, point.Y).IsClearOrPit() && Map.Get().At(point).GetNumAdjacentWalls() == 0)
					{
						listValidCentralPos.Add(point);
					}
				}
			}
		}
	}

	public Point GetRandomPoint(bool central = false)
	{
		if (listValidPos == null || listValidCentralPos == null)
		{
			BuildValidPosLists();
		}
		if (listValidPos.Count == 0)
		{
			Debug.LogError("No valid positions inside the room");
		}
		if (central && listValidCentralPos.Count > 0)
		{
			return RandomExt.Choice(listValidCentralPos);
		}
		return RandomExt.Choice(listValidPos);
	}

	public List<Point> GetListValidPos()
	{
		if (listValidPos == null)
		{
			GetRandomPoint();
		}
		return listValidPos;
	}

	public List<Point> GetListValidCentralPos()
	{
		if (listValidCentralPos == null)
		{
			GetRandomPoint();
		}
		return listValidCentralPos;
	}
}
public enum OptionFlag
{
	Any,
	Yes,
	No
}
public class RoomTemplate : ScriptableObject
{
	public enum SizeType
	{
		Small,
		Medium,
		Large,
		Hub
	}

	[Serializable]
	public class Flags
	{
		public enum CeilingHint
		{
			None,
			Horizontal,
			Vertical
		}

		public bool canBeSafe;

		public int maxLightcasters = 2;

		public bool enableBats;

		public ClockMode.Mode clockMode;

		public int minConnections;

		public bool dungeonStyle = true;

		public bool templeStyle = true;

		public bool catacombStyle = true;

		public CeilingHint ceilingHint;

		public bool CheckStyle(MapStyle style)
		{
			if (!dungeonStyle && style.GetMainTag() == "dungeon")
			{
				return false;
			}
			if (!templeStyle && style.GetMainTag() == "temple")
			{
				return false;
			}
			if (!catacombStyle && style.GetMainTag() == "catacomb")
			{
				return false;
			}
			return true;
		}
	}

	[Serializable]
	public class PropMarker
	{
		public enum Direction
		{
			Auto,
			Right,
			Down,
			Left,
			Up
		}

		public CPoint pos;

		public int width;

		public int height;

		public PropInfo propInfo;

		public bool propArea;

		public int groupIndex = -1;

		public Direction direction;

		public Vector2 deltaOffset;

		public float probability = 0.8f;

		public OptionFlag exitMarker;

		public OptionFlag exitCollectable;

		public OptionFlag lightCaster;

		public OptionFlag standAlone;

		public OptionFlag important;

		public OptionFlag generic;

		public OptionFlag horror;

		public OptionFlag container;

		public OptionFlag tall;

		public OptionFlag wallProp;

		public List<string> tags;

		public PropMarker(CPoint pos, PropMarker from)
		{
			this.pos = pos;
			width = from.width;
			height = from.height;
			propInfo = from.propInfo;
			propArea = from.propArea;
			groupIndex = from.groupIndex;
			direction = from.direction;
			deltaOffset = from.deltaOffset;
			probability = from.probability;
			exitMarker = from.exitMarker;
			exitCollectable = from.exitCollectable;
			lightCaster = from.lightCaster;
			standAlone = from.standAlone;
			important = from.important;
			generic = from.generic;
			horror = from.horror;
			container = from.container;
			tall = from.tall;
			wallProp = from.wallProp;
			if (from.tags != null)
			{
				tags = new List<string>();
				for (int i = 0; i < from.tags.Count; i++)
				{
					tags.Add(from.tags[i]);
				}
			}
			else
			{
				tags = null;
			}
		}

		public void RotateCW()
		{
			int num = width;
			width = height;
			height = num;
			if (direction != 0)
			{
				direction++;
				if (direction > Direction.Up)
				{
					direction = Direction.Right;
				}
			}
		}

		public void RotateCCW()
		{
			int num = width;
			width = height;
			height = num;
			if (direction != 0)
			{
				direction--;
				if (direction <= Direction.Auto)
				{
					direction = Direction.Up;
				}
			}
		}

		public bool IsPositionInside(Point posCheck)
		{
			return posCheck.X >= pos.X && posCheck.X < pos.X + width && posCheck.Y >= pos.Y && posCheck.Y < pos.Y + width;
		}
	}

	[Serializable]
	public class Layout
	{
		[Serializable]
		public class Flags
		{
			public OptionFlag safe;

			public OptionFlag horror;
		}

		public string name;

		public bool ignore;

		[Range(0f, 10f)]
		public float weight = 1f;

		[Range(0f, 1f)]
		public float propClutter = 1f;

		public List<PropMarker> props;

		public Flags flags;

		public Layout()
		{
			name = string.Empty;
			flags = new Flags();
			props = new List<PropMarker>();
		}
	}

	public int width;

	public int height;

	public bool ignore;

	[Range(0f, 10f)]
	public float weight = 1f;

	public SizeType size;

	public Flags flags;

	public CellType[] baseLayout;

	public List<CPoint> doors;

	public List<CPoint> doubleDoors;

	public List<Layout> layouts;

	public static List<RoomTemplate> roomTemplates;

	public static List<RoomTemplate> hubTemplates;

	public static List<RoomTemplate> ignoredTemplates;

	public void Reset(int w, int h)
	{
		width = w;
		height = h;
		baseLayout = new CellType[h * w];
		for (int i = 0; i < h * w; i++)
		{
			baseLayout[i] = CellType.Rock;
		}
		doors = new List<CPoint>();
		doubleDoors = new List<CPoint>();
		layouts = new List<Layout>();
		flags = new Flags();
		flags.canBeSafe = false;
		size = SizeType.Small;
		base.name = string.Empty;
	}

	public CellType At(int x, int y)
	{
		return baseLayout[y * width + x];
	}

	public CellType At(Point pos)
	{
		return At(pos.X, pos.Y);
	}

	public void Set(int x, int y, CellType type)
	{
		baseLayout[y * width + x] = type;
	}

	public void Set(Point pos, CellType type)
	{
		Set(pos.X, pos.Y, type);
	}

	public static bool ReloadRoomTemplates(string templatesPath = "RoomTemplates")
	{
		RoomTemplate[] array = Resources.LoadAll<RoomTemplate>("RoomTemplates");
		roomTemplates = new List<RoomTemplate>();
		hubTemplates = new List<RoomTemplate>();
		ignoredTemplates = new List<RoomTemplate>();
		RoomTemplate[] array2 = array;
		foreach (RoomTemplate roomTemplate in array2)
		{
			if (roomTemplate.ignore)
			{
				ignoredTemplates.Add(roomTemplate);
			}
			else if (roomTemplate.size == SizeType.Hub)
			{
				hubTemplates.Add(roomTemplate);
			}
			else
			{
				roomTemplates.Add(roomTemplate);
			}
		}
		return true;
	}

	public static Room PlaceRoomTemplated(GBGenerator gen, int roomID, Point roomPos, RoomTemplate template = null, bool placeProps = true)
	{
		if (template == null)
		{
			template = RandomExt.Choice(roomTemplates);
		}
		return template.PlaceRoom(gen, roomID, roomPos, placeProps);
	}

	public static Room PlaceRoomTemplated(GBGenerator gen, int roomID, Point roomPos, MapStyle smallStyle = null, MapStyle mediumStyle = null, MapStyle largeStyle = null, bool placeProps = true)
	{
		RoomTemplate roomTemplate = null;
		int num = 100;
		while (num > 0 && roomTemplate == null)
		{
			num--;
			roomTemplate = RandomExt.Choice(roomTemplates);
			if (roomTemplate.size == SizeType.Small && !roomTemplate.flags.CheckStyle(smallStyle))
			{
				roomTemplate = null;
			}
			else if (roomTemplate.size == SizeType.Medium && !roomTemplate.flags.CheckStyle(mediumStyle))
			{
				roomTemplate = null;
			}
			else if (roomTemplate.size == SizeType.Large && !roomTemplate.flags.CheckStyle(largeStyle))
			{
				roomTemplate = null;
			}
		}
		if (roomTemplate == null)
		{
			return null;
		}
		return roomTemplate.PlaceRoom(gen, roomID, roomPos, placeProps);
	}

	public static RoomTemplate FindByName(string templateName)
	{
		for (int i = 0; i < ignoredTemplates.Count; i++)
		{
			if (ignoredTemplates[i].name == templateName)
			{
				return ignoredTemplates[i];
			}
		}
		for (int j = 0; j < roomTemplates.Count; j++)
		{
			if (roomTemplates[j].name == templateName)
			{
				return roomTemplates[j];
			}
		}
		for (int k = 0; k < hubTemplates.Count; k++)
		{
			if (hubTemplates[k].name == templateName)
			{
				return hubTemplates[k];
			}
		}
		return null;
	}

	public Room PlaceRoom(GBGenerator gen, int roomID, Point roomPos, bool placeProps = true)
	{
		Room room = new Room(roomID, roomPos.X, roomPos.Y, width, height, this);
		IntRect intRect = new IntRect(roomPos.X, roomPos.Y, width, height);
		if (intRect.left < 0 || intRect.right >= gen.Options.Width || intRect.top < 0 || intRect.bottom >= gen.Options.Height)
		{
			return null;
		}
		for (int i = intRect.top; i < intRect.bottom; i++)
		{
			for (int j = intRect.left; j < intRect.right; j++)
			{
				CellType cellType = gen.CellMap[i][j].Get();
				if (cellType == CellType.Room || cellType == CellType.Perimeter || cellType == CellType.Blocked)
				{
					return null;
				}
			}
		}
		for (int k = 0; k < height; k++)
		{
			for (int l = 0; l < width; l++)
			{
				CellType cellType2 = At(l, k);
				gen.CellMap[k + roomPos.Y][l + roomPos.X].Set(cellType2);
				if (cellType2 != 0)
				{
					gen.CellMap[k + roomPos.Y][l + roomPos.X].Room = room;
				}
				switch (cellType2)
				{
				case CellType.Shaft:
					gen.CellMap[k + roomPos.Y][l + roomPos.X].Set(CellType.Room);
					gen.CellMap[k + roomPos.Y][l + roomPos.X].CeilingShaft = true;
					break;
				case CellType.PitShaft:
					gen.CellMap[k + roomPos.Y][l + roomPos.X].Set(CellType.Pit);
					gen.CellMap[k + roomPos.Y][l + roomPos.X].CeilingShaft = true;
					break;
				}
			}
		}
		if (placeProps)
		{
			PlaceRoomProps(gen, room);
		}
		return room;
	}

	public static void PlaceRoomProps(GBGenerator gen, Room room)
	{
		RoomTemplate template = room.Template;
		Point start = room.Start;
		List<Pair<Layout, float>> list = new List<Pair<Layout, float>>();
		for (int i = 0; i < template.layouts.Count; i++)
		{
			if (!template.layouts[i].ignore)
			{
				list.Add(new Pair<Layout, float>(template.layouts[i], template.layouts[i].weight));
			}
		}
		Layout layout = RandomExt.WeightedChoice(list);
		float num = 1f;
		if (room.IsDeadEnd)
		{
			num = ((room.Template.size != 0) ? 1.5f : 2f);
		}
		foreach (PropMarker prop in layout.props)
		{
			float num2 = prop.probability * layout.propClutter * num;
			if (!(prop.propInfo == null) || !(UnityEngine.Random.value > num2))
			{
				gen.PropPositions.Add(new PropMarker(new CPoint(prop.pos.X + start.X, prop.pos.Y + start.Y), prop));
			}
		}
		if (layout.flags.horror == OptionFlag.Yes)
		{
			room.IsHorror = true;
		}
		if (layout.name == "well" || layout.name == "Well")
		{
			room.IsWellLayout = true;
		}
		if (template.flags.enableBats && UnityEngine.Random.value <= 0.4f)
		{
			room.hasBats = true;
		}
	}
}
public class TextureAtlas
{
	private static Dictionary<Shader, List<List<Material>>> dictShaderMats = new Dictionary<Shader, List<List<Material>>>();

	private static Dictionary<Material, Material> newMaterials = new Dictionary<Material, Material>();

	private static Dictionary<Material, Rect> newUVs = new Dictionary<Material, Rect>();

	public static void TestAtlas(Texture2D atlasTest, GameObject mapGeometry, Renderer atlasTestRenderer)
	{
		atlasTest = new Texture2D(4096, 4096);
		List<Texture2D> list = new List<Texture2D>();
		Renderer[] componentsInChildren = mapGeometry.GetComponentsInChildren<Renderer>();
		Renderer[] array = componentsInChildren;
		foreach (Renderer renderer in array)
		{
			Material[] sharedMaterials = renderer.sharedMaterials;
			foreach (Material material in sharedMaterials)
			{
				Texture2D texture2D = material.mainTexture as Texture2D;
				if (texture2D != null && !list.Contains(texture2D))
				{
					list.Add(texture2D);
				}
			}
		}
		Rect[] array2 = atlasTest.PackTextures(list.ToArray(), 0, 4096);
		atlasTestRenderer.material.mainTexture = atlasTest;
	}

	public static void BuildAtlas(GameObject[] geometry, out List<Texture2D> allTexs, bool remapTiling, float minRatio = 0f, List<Texture2D> atlasTexturesOut = null, List<Material> atlasMaterialsOut = null, List<Mesh> atlasMeshesOut = null, List<MeshFilter> atlasFiltersOut = null)
	{
		allTexs = null;
		if (geometry.Length == 0)
		{
			return;
		}
		List<MeshFilter> list = new List<MeshFilter>();
		for (int i = 0; i < geometry.Length; i++)
		{
			AtlasProp component = geometry[i].GetComponent<AtlasProp>();
			if (!(component != null) || !component.noAtlas)
			{
				list.AddRange(geometry[i].GetComponentsInChildren<MeshFilter>(includeInactive: true));
			}
		}
		BuildAtlas(list, out allTexs, remapTiling, minRatio, atlasTexturesOut, atlasMaterialsOut, atlasMeshesOut, atlasFiltersOut);
	}

	public static void BuildAtlas(List<MeshFilter> filters, out List<Texture2D> allTexs, bool remapTiling, float minRatio = 0f, List<Texture2D> atlasTexturesOut = null, List<Material> atlasMaterialsOut = null, List<Mesh> atlasMeshesOut = null, List<MeshFilter> atlasFiltersOut = null)
	{
		allTexs = null;
		dictShaderMats.Clear();
		newMaterials.Clear();
		newUVs.Clear();
		if (filters.Count == 0)
		{
			return;
		}
		AtlasProp[] array = new AtlasProp[filters.Count];
		List<MeshFilter> list = new List<MeshFilter>();
		for (int i = 0; i < filters.Count; i++)
		{
			Renderer component = filters[i].GetComponent<Renderer>();
			if (component == null)
			{
				continue;
			}
			array[i] = filters[i].GetComponent<AtlasProp>();
			if (array[i] != null)
			{
				if (array[i].noAtlas)
				{
					continue;
				}
				if (array[i].tiling != remapTiling)
				{
					list.Add(filters[i]);
					continue;
				}
			}
			Material[] sharedMaterials = component.sharedMaterials;
			Material[] array2 = sharedMaterials;
			foreach (Material material in array2)
			{
				if (material.shader != null && material.mainTexture != null && material.mainTextureOffset == Vector2.zero && material.mainTextureScale == new Vector2(1f, 1f))
				{
					Shader shader = material.shader;
					if (dictShaderMats.ContainsKey(shader))
					{
						dictShaderMats[shader][0].Add(material);
						continue;
					}
					List<Material> list2 = new List<Material>();
					list2.Add(material);
					List<List<Material>> list3 = new List<List<Material>>();
					list3.Add(list2);
					dictShaderMats[shader] = list3;
				}
			}
		}
		foreach (Shader key in dictShaderMats.Keys)
		{
			for (int k = 0; k < dictShaderMats[key].Count; k++)
			{
				float num = 0f;
				List<Material> list4 = dictShaderMats[key][k];
				Dictionary<Texture, Rect> dictionary = new Dictionary<Texture, Rect>();
				List<Material> list5 = new List<Material>();
				List<Material> list6 = new List<Material>();
				Material material2 = new Material(key);
				material2.CopyPropertiesFromMaterial(list4[0]);
				if (atlasMaterialsOut == null)
				{
					ClearMemory.AddRuntimeMaterial(material2);
				}
				else
				{
					atlasMaterialsOut.Add(material2);
				}
				allTexs = new List<Texture2D>();
				for (int l = 0; l < list4.Count; l++)
				{
					Texture2D texture2D = list4[l].mainTexture as Texture2D;
					if (!(texture2D != null))
					{
						continue;
					}
					bool flag = false;
					if (!allTexs.Contains(texture2D))
					{
						float num2 = num + (float)(texture2D.width * texture2D.height);
						float num3 = 16777216f / num2;
						if (num3 >= minRatio)
						{
							allTexs.Add(texture2D);
							if (remapTiling)
							{
								if (!TexturePacker.CheckPack(allTexs.ToArray(), 4096, extraSize: true))
								{
									allTexs.RemoveAt(allTexs.Count - 1);
								}
								else
								{
									num = num2;
									flag = true;
								}
							}
							else
							{
								num = num2;
								flag = true;
							}
						}
					}
					else
					{
						flag = true;
					}
					if (flag)
					{
						newMaterials[list4[l]] = material2;
						list6.Add(list4[l]);
					}
					else
					{
						list5.Add(list4[l]);
					}
				}
				if (list5.Count > 0)
				{
					List<Material> list7 = null;
					if (k + 1 >= dictShaderMats[key].Count)
					{
						list7 = new List<Material>();
						dictShaderMats[key].Add(list7);
					}
					else
					{
						list7 = dictShaderMats[key][k + 1];
					}
					list7.AddRange(list5);
				}
				Rect[] array3 = null;
				Texture2D packTexture;
				if (remapTiling)
				{
					array3 = TexturePacker.Pack(out packTexture, allTexs.ToArray(), 4096, extraSize: true, atlasTexturesOut == null);
				}
				else
				{
					packTexture = new Texture2D(4096, 4096);
					array3 = packTexture.PackTextures(allTexs.ToArray(), 0, 4096, atlasTexturesOut == null);
				}
				if (atlasTexturesOut != null)
				{
					atlasTexturesOut.Add(packTexture);
				}
				else
				{
					ClearMemory.AddRuntimeTexture(packTexture);
				}
				if (array3 == null)
				{
					Debug.LogError("Insufficient space in the atlas texture!");
					return;
				}
				float num4 = packTexture.width * packTexture.height;
				Debug.Log("PackRatio: " + num4 / num + " (" + packTexture.width + "x" + packTexture.height + ") - " + allTexs.Count + " texs");
				for (int m = 0; m < allTexs.Count; m++)
				{
					dictionary[allTexs[m]] = array3[m];
				}
				material2.mainTexture = packTexture;
				for (int n = 0; n < list6.Count; n++)
				{
					newUVs[list6[n]] = dictionary[list6[n].mainTexture];
				}
			}
		}
		for (int num5 = 0; num5 < filters.Count; num5++)
		{
			Renderer component2 = filters[num5].GetComponent<Renderer>();
			if (component2 == null || (array[num5] != null && array[num5].noAtlas) || (array[num5] != null && array[num5].tiling && !remapTiling))
			{
				continue;
			}
			Material[] sharedMaterials2 = component2.sharedMaterials;
			Mesh mesh = UnityEngine.Object.Instantiate(filters[num5].sharedMesh);
			mesh.name = filters[num5].sharedMesh.name + "_" + filters[num5].gameObject.name;
			atlasMeshesOut?.Add(mesh);
			atlasFiltersOut?.Add(filters[num5]);
			int subMeshCount = mesh.subMeshCount;
			Vector2[] array4 = mesh.uv;
			Vector2[] array5 = mesh.uv2;
			Vector2[] array6 = null;
			if (remapTiling)
			{
				array6 = new Vector2[array4.Length];
				array4.CopyTo(array6, 0);
			}
			Color[] array7 = mesh.colors;
			Vector3[] array8 = mesh.vertices;
			Vector3[] array9 = mesh.normals;
			int[][] array10 = new int[mesh.subMeshCount][];
			if (subMeshCount != sharedMaterials2.Length)
			{
				Debug.LogError("numSubMeshes != materials.Length");
			}
			int[] array11 = new int[mesh.uv.Length];
			for (int num6 = 0; num6 < array11.Length; num6++)
			{
				array11[num6] = 1000;
			}
			for (int num7 = 0; num7 < subMeshCount; num7++)
			{
				if (!newUVs.ContainsKey(sharedMaterials2[num7]))
				{
					continue;
				}
				Rect rect = newUVs[sharedMaterials2[num7]];
				array10[num7] = mesh.GetTriangles(num7);
				int[] array12 = array10[num7];
				List<Pair<int, Point>> list8 = new List<Pair<int, Point>>();
				if (remapTiling)
				{
					for (int num8 = 0; num8 < array12.Length / 3; num8++)
					{
						bool flag2 = false;
						Point[] array13 = new Point[3];
						for (int num9 = 0; num9 < 3; num9++)
						{
							ref Point reference = ref array13[num9];
							reference = new Point(0, 0);
							int num10 = array12[num8 * 3 + num9];
							if (flag2 || array11[num10] < num7)
							{
								flag2 = true;
							}
							else if (!float.IsPositiveInfinity(array4[num10].x) && !float.IsNegativeInfinity(array4[num10].x) && !float.IsPositiveInfinity(array4[num10].y) && !float.IsNegativeInfinity(array4[num10].y))
							{
								while (array4[num10].x + (float)array13[num9].X >= 1.5f)
								{
									array13[num9].X--;
								}
								while (array4[num10].x + (float)array13[num9].X < -0.5f)
								{
									array13[num9].X++;
								}
								while (array4[num10].y + (float)array13[num9].Y >= 1.5f)
								{
									array13[num9].Y--;
								}
								while (array4[num10].y + (float)array13[num9].Y < -0.5f)
								{
									array13[num9].Y++;
								}
							}
						}
						if (flag2)
						{
							list8.Add(new Pair<int, Point>(num8, new Point(0, 0)));
						}
						else if (array13[0] != array13[1] || array13[1] != array13[2])
						{
							Point second = array13[0];
							if (second.X == 0 && array13[1].X != 0)
							{
								second.X = array13[1].X;
							}
							if (second.X == 0 && array13[2].X != 0)
							{
								second.X = array13[2].X;
							}
							if (second.Y == 0 && array13[1].Y != 0)
							{
								second.Y = array13[1].Y;
							}
							if (second.Y == 0 && array13[2].Y != 0)
							{
								second.Y = array13[2].Y;
							}
							list8.Add(new Pair<int, Point>(num8, second));
						}
					}
					int num11 = array4.Length;
					int num12 = list8.Count * 3;
					if (num12 > 0)
					{
						Vector3[] array14 = new Vector3[num11 + num12];
						Color[] array15 = new Color[num11 + num12];
						Vector3[] array16 = new Vector3[num11 + num12];
						Vector2[] array17 = new Vector2[num11 + num12];
						Vector2[] array18 = new Vector2[num11 + num12];
						array8.CopyTo(array14, 0);
						array9.CopyTo(array16, 0);
						array4.CopyTo(array17, 0);
						array5.CopyTo(array18, 0);
						array7.CopyTo(array15, 0);
						array4 = array17;
						array5 = array18;
						array7 = array15;
						array8 = array14;
						array9 = array16;
					}
					for (int num13 = 0; num13 < list8.Count; num13++)
					{
						for (int num14 = 0; num14 < 3; num14++)
						{
							int num15 = array12[list8[num13].First * 3 + num14];
							int num16 = num11 + num14;
							ref Vector3 reference2 = ref array8[num16];
							reference2 = array8[num15];
							ref Color reference3 = ref array7[num16];
							reference3 = array7[num15];
							ref Vector3 reference4 = ref array9[num16];
							reference4 = array9[num15];
							ref Vector2 reference5 = ref array4[num16];
							reference5 = array4[num15];
							if (array11[num15] < num7)
							{
								ref Vector2 reference6 = ref array4[num16];
								reference6 = array6[num15];
							}
							array4[num16].x += list8[num13].Second.X;
							array4[num16].y += list8[num13].Second.Y;
							ref Vector2 reference7 = ref array5[num16];
							reference7 = array5[num15];
						}
						int num17 = list8[num13].First * 3;
						array12[num17] = num11;
						array12[num17 + 1] = num11 + 1;
						array12[num17 + 2] = num11 + 2;
						num11 += 3;
					}
				}
				bool[] array19 = new bool[array4.Length];
				for (int num18 = 0; num18 < array19.Length; num18++)
				{
					array19[num18] = false;
				}
				foreach (int num20 in array12)
				{
					if (array19[num20])
					{
						continue;
					}
					if (remapTiling && !float.IsPositiveInfinity(array4[num20].x) && !float.IsNegativeInfinity(array4[num20].x) && !float.IsPositiveInfinity(array4[num20].y) && !float.IsNegativeInfinity(array4[num20].y))
					{
						while (array4[num20].x >= 1.5f)
						{
							array4[num20].x -= 1f;
						}
						while (array4[num20].x < -0.5f)
						{
							array4[num20].x += 1f;
						}
						while (array4[num20].y >= 1.5f)
						{
							array4[num20].y -= 1f;
						}
						while (array4[num20].y < -0.5f)
						{
							array4[num20].y += 1f;
						}
					}
					ref Vector2 reference8 = ref array4[num20];
					reference8 = new Vector2(array4[num20].x * rect.width + rect.x, array4[num20].y * rect.height + rect.y);
					if (num20 < array11.Length)
					{
						array11[num20] = num7;
					}
					array19[num20] = true;
				}
				sharedMaterials2[num7] = newMaterials[sharedMaterials2[num7]];
			}
			if (atlasMaterialsOut == null || atlasFiltersOut != null)
			{
				component2.sharedMaterials = sharedMaterials2;
			}
			if (remapTiling)
			{
				if (array8 != null)
				{
					mesh.vertices = array8;
				}
				if (array9 != null)
				{
					mesh.normals = array9;
				}
				mesh.colors = array7;
				if (array5 != null)
				{
					mesh.uv2 = array5;
				}
			}
			mesh.uv = array4;
			if (remapTiling)
			{
				for (int num21 = 0; num21 < mesh.subMeshCount; num21++)
				{
					mesh.SetTriangles(array10[num21], num21);
				}
			}
		}
		if (list.Count > 0)
		{
			BuildAtlas(list, out allTexs, !remapTiling, minRatio, atlasTexturesOut, atlasMaterialsOut, atlasMeshesOut, atlasFiltersOut);
		}
	}

	public static void SetSimpleMaterials(GameObject obj)
	{
		MeshFilter[] componentsInChildren = obj.GetComponentsInChildren<MeshFilter>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			Renderer component = componentsInChildren[i].GetComponent<Renderer>();
			if (component == null)
			{
				continue;
			}
			Material[] sharedMaterials = component.sharedMaterials;
			Material[] array = sharedMaterials;
			foreach (Material material in array)
			{
				if (material.shader != null && material.mainTexture != null)
				{
					material.shader = Shader.Find("Mobile/Diffuse");
				}
			}
		}
	}

	public static void SetTexturesReadable(List<GameObject> objs, out List<Texture2D> allTexs)
	{
		allTexs = new List<Texture2D>();
		dictShaderMats.Clear();
		newMaterials.Clear();
		newUVs.Clear();
		List<MeshFilter> list = new List<MeshFilter>();
		for (int i = 0; i < objs.Count; i++)
		{
			list.AddRange(objs[i].GetComponentsInChildren<MeshFilter>(includeInactive: true));
		}
		for (int j = 0; j < list.Count; j++)
		{
			Renderer component = list[j].GetComponent<Renderer>();
			if (component == null)
			{
				continue;
			}
			Material[] sharedMaterials = component.sharedMaterials;
			Material[] array = sharedMaterials;
			foreach (Material material in array)
			{
				if (material.shader != null && material.mainTexture != null && material.mainTextureOffset == Vector2.zero && material.mainTextureScale == new Vector2(1f, 1f))
				{
					Shader shader = material.shader;
					if (dictShaderMats.ContainsKey(shader))
					{
						dictShaderMats[shader][0].Add(material);
						continue;
					}
					List<Material> list2 = new List<Material>();
					list2.Add(material);
					List<List<Material>> list3 = new List<List<Material>>();
					list3.Add(list2);
					dictShaderMats[shader] = list3;
				}
			}
		}
		foreach (Shader key in dictShaderMats.Keys)
		{
			List<Material> list4 = dictShaderMats[key][0];
			Dictionary<Texture, Rect> dictionary = new Dictionary<Texture, Rect>();
			for (int l = 0; l < list4.Count; l++)
			{
				Texture2D texture2D = list4[l].mainTexture as Texture2D;
				if (texture2D != null && !allTexs.Contains(texture2D))
				{
					allTexs.Add(texture2D);
				}
			}
		}
	}

	public static void Clear()
	{
		dictShaderMats = new Dictionary<Shader, List<List<Material>>>();
		newMaterials = new Dictionary<Material, Material>();
		newUVs = new Dictionary<Material, Rect>();
	}
}
public class TexturePacker
{
	private class TextureMarker
	{
		public Texture2D texture;

		public int width;

		public int height;
	}

	private class Node
	{
		public Node childLeft;

		public Node childRight;

		public IntRect coords;

		public TextureMarker imageTex;

		public Node()
		{
		}

		public Node(int w, int h)
		{
			coords = new IntRect(0, 0, w, h);
		}

		public Node Insert(TextureMarker img)
		{
			if (childLeft != null || childRight != null)
			{
				Node node = childLeft.Insert(img);
				if (node != null)
				{
					return node;
				}
				return childRight.Insert(img);
			}
			if (imageTex != null)
			{
				return null;
			}
			if (coords.width < img.width || coords.height < img.height)
			{
				return null;
			}
			if (coords.width == img.width && coords.height == img.height)
			{
				imageTex = img;
				return this;
			}
			childLeft = new Node();
			childRight = new Node();
			int num = coords.width - img.width;
			int num2 = coords.height - img.height;
			if (num > num2)
			{
				childLeft.coords = new IntRect(coords.left, coords.top, img.width, coords.height);
				childRight.coords = new IntRect(coords.left + img.width, coords.top, coords.width - img.width, coords.height);
			}
			else
			{
				childLeft.coords = new IntRect(coords.left, coords.top, coords.width, img.height);
				childRight.coords = new IntRect(coords.left, coords.top + img.height, coords.width, coords.height - img.height);
			}
			return childLeft.Insert(img);
		}
	}

	public static Rect[] Pack(out Texture2D packTexture, Texture2D[] images, int maxSize = 4096, bool extraSize = false, bool makeNoLongerReadable = true)
	{
		packTexture = null;
		int sizeW;
		int sizeH;
		IntRect[] intRects;
		TextureMarker[] array = PackRects(images, maxSize, extraSize, out sizeW, out sizeH, out intRects);
		packTexture = new Texture2D(sizeW, sizeH, TextureFormat.ARGB32, mipmap: true);
		packTexture.wrapMode = TextureWrapMode.Clamp;
		packTexture.filterMode = FilterMode.Bilinear;
		for (int i = 0; i < images.Length; i++)
		{
			int num = 0;
			if (!extraSize)
			{
				Color[] pixels = images[i].GetPixels(num);
				packTexture.SetPixels(intRects[i].x >> num, intRects[i].y >> num, intRects[i].width >> num, intRects[i].height >> num, pixels, num);
				continue;
			}
			Pair<IntRect, IntRect>[] array2 = new Pair<IntRect, IntRect>[9];
			IntRect first = new IntRect(0, 0, images[i].width, images[i].height);
			IntRect second = new IntRect(intRects[i].x + intRects[i].width / 4, intRects[i].y + intRects[i].height / 4, images[i].width, images[i].height);
			array2[4].First = first;
			array2[4].Second = second;
			int num2 = first.width / 2;
			int num3 = first.height / 2;
			int width = first.width;
			int height = first.height;
			array2[0].First = new IntRect(first.right - num2, first.bottom - num3, num2, num3);
			array2[0].Second = new IntRect(second.left - num2, second.top - num3, num2, num3);
			array2[1].First = new IntRect(0, num3, width, num3);
			array2[1].Second = new IntRect(second.left, second.top - num3, width, num3);
			array2[2].First = new IntRect(0, first.bottom - num3, num2, num3);
			array2[2].Second = new IntRect(second.right, second.top - num3, num2, num3);
			array2[3].First = new IntRect(first.right - num2, 0, num2, height);
			array2[3].Second = new IntRect(second.left - num2, second.top, num2, height);
			array2[5].First = new IntRect(0, 0, num2, height);
			array2[5].Second = new IntRect(second.right, second.top, num2, height);
			array2[6].First = new IntRect(first.right - num2, 0, num2, num3);
			array2[6].Second = new IntRect(second.left - num2, second.bottom, num2, num3);
			array2[7].First = new IntRect(0, 0, width, num3);
			array2[7].Second = new IntRect(second.left, second.bottom, width, num3);
			array2[8].First = new IntRect(0, 0, num2, num3);
			array2[8].Second = new IntRect(second.right, second.bottom, num2, num3);
			for (int j = 0; j < 9; j++)
			{
				Color[] pixels2 = images[i].GetPixels(array2[j].First.x, array2[j].First.y, array2[j].First.width, array2[j].First.height);
				packTexture.SetPixels(array2[j].Second.x, array2[j].Second.y, array2[j].Second.width, array2[j].Second.height, pixels2, num);
			}
		}
		packTexture.Apply(updateMipmaps: true, makeNoLongerReadable);
		Rect[] array3 = new Rect[images.Length];
		for (int k = 0; k < intRects.Length; k++)
		{
			if (extraSize)
			{
				ref Rect reference = ref array3[k];
				reference = new Rect((float)(intRects[k].left + intRects[k].width / 4) / (float)sizeW, (float)(intRects[k].top + intRects[k].height / 4) / (float)sizeH, (float)(intRects[k].width / 2) / (float)sizeW, (float)(intRects[k].height / 2) / (float)sizeH);
			}
			else
			{
				ref Rect reference2 = ref array3[k];
				reference2 = new Rect((float)intRects[k].left / (float)sizeW, (float)intRects[k].top / (float)sizeH, (float)intRects[k].width / (float)sizeW, (float)intRects[k].height / (float)sizeH);
			}
		}
		return array3;
	}

	public static bool CheckPack(Texture2D[] images, int maxSize = 4096, bool extraSize = false)
	{
		if (PackRects(images, maxSize, extraSize, out var _, out var _, out var _) == null)
		{
			return false;
		}
		return true;
	}

	private static TextureMarker[] PackRects(Texture2D[] images, int maxSize, bool extraSize, out int sizeW, out int sizeH, out IntRect[] intRects)
	{
		TextureMarker[] array = new TextureMarker[images.Length];
		sizeW = 0;
		sizeH = 0;
		for (int i = 0; i < images.Length; i++)
		{
			array[i] = new TextureMarker();
			array[i].texture = images[i];
			array[i].width = images[i].width * ((!extraSize) ? 1 : 2);
			array[i].height = images[i].height * ((!extraSize) ? 1 : 2);
			sizeW = Mathf.Max(sizeW, array[i].width);
			sizeH = Mathf.Max(sizeH, array[i].height);
		}
		intRects = new IntRect[images.Length];
		bool flag = false;
		while (!flag && sizeW <= maxSize && sizeH <= maxSize)
		{
			flag = true;
			Node node = new Node(sizeW, sizeH);
			for (int j = 0; j < images.Length; j++)
			{
				Node node2 = node.Insert(array[j]);
				if (node2 == null)
				{
					flag = false;
					if (sizeW <= sizeH)
					{
						sizeW *= 2;
					}
					else
					{
						sizeH *= 2;
					}
					break;
				}
				ref IntRect reference = ref intRects[j];
				reference = node2.coords;
			}
		}
		if (!flag)
		{
			return null;
		}
		return array;
	}
}
public class Trigger : MonoBehaviour
{
	public bool singleUse = true;

	public int countdown;

	public virtual void OnActivate(PlayerGameController player)
	{
		if (countdown > 0)
		{
			countdown--;
			return;
		}
		if (singleUse)
		{
			GetComponent<Collider>().enabled = false;
		}
		SendMessage("OnTrigger", player);
	}
}
public class VisibilityProbe : MonoBehaviour
{
	public bool IsVisible;

	public bool Discovered;

	private static Camera[] Cameras;

	public const float farDist = 20f;

	public LayerMask RayMask;

	public MapChunk chunk;

	private float timer;

	private float lastTimeChange;

	private bool flicking;

	public Bounds bounds;

	public bool addToStats = true;

	public int probeIndex;

	private static int probeCount;

	private void Start()
	{
		if (Cameras == null)
		{
			GameObject[] array = GameObject.FindGameObjectsWithTag(Tags.MainCamera);
			Cameras = new Camera[array.Length];
			for (int i = 0; i < array.Length; i++)
			{
				Cameras[i] = array[i].GetComponent<Camera>();
			}
		}
		chunk = MapChunk.At(Map.Get().WorldToCell(base.transform.position));
		if (GetComponent<Collider>() != null)
		{
			GetComponent<Collider>().enabled = false;
		}
		bounds.center = new Vector3(base.transform.position.x, bounds.center.y, base.transform.position.z);
		probeIndex = probeCount;
		probeCount++;
		VisibilityProbeManager.Get().AddProbe(this);
		if (addToStats)
		{
			PlayerStats.Get().AddProbe();
		}
	}

	public static void Clear()
	{
		Cameras = null;
	}

	public void CheckVisibility(Plane[][] frustumPlanes, Vector3 camPos)
	{
		if (timer > 0f)
		{
			timer -= Time.deltaTime;
		}
		lastTimeChange += Time.deltaTime;
		bool flag = timer > 0f;
		if (!flag && chunk.Visible)
		{
			float sqrMagnitude = (camPos - base.transform.position).sqrMagnitude;
			if (sqrMagnitude <= 400f)
			{
				bool flag2 = false;
				int num = 0;
				while (!flag2 && num < frustumPlanes.Length)
				{
					Plane[] planes = frustumPlanes[num];
					if (GeometryUtility.TestPlanesAABB(planes, bounds))
					{
						flag2 = true;
					}
					num++;
				}
				if (flag2 && CheckLoS(camPos))
				{
					flag = true;
					timer = ((!flicking) ? 0.15f : 0.55f);
				}
			}
		}
		if (IsVisible != flag)
		{
			if (lastTimeChange <= 0.3f)
			{
				flicking = true;
			}
			else
			{
				flicking = false;
			}
			lastTimeChange = 0f;
		}
		IsVisible = flag;
		if (!Discovered && IsVisible)
		{
			Discovered = true;
			if (addToStats)
			{
				PlayerStats.Get().AddDiscovered(Map.Get().WorldToCell(base.transform.position));
			}
		}
	}

	public bool CheckLoS(Vector3 cameraPos, int numRays = 1)
	{
		for (int i = 0; i < numRays; i++)
		{
			Vector3 position = base.transform.position;
			position.y += UnityEngine.Random.Range(0.2f, 3.3f);
			position.x += UnityEngine.Random.Range((0f - Map.Get().TileSize.x) / 2f, Map.Get().TileSize.x / 2f);
			position.z += UnityEngine.Random.Range((0f - Map.Get().TileSize.y) / 2f, Map.Get().TileSize.y / 2f);
			Vector3 direction = position - cameraPos;
			float magnitude = direction.magnitude;
			direction /= magnitude;
			if (!Physics.Raycast(cameraPos, direction, out var _, magnitude, RayMask))
			{
				return true;
			}
		}
		return false;
	}

	private void OnDrawGizmosSelected()
	{
		Gizmos.color = Color.green;
		Gizmos.DrawWireCube(bounds.center, bounds.size);
	}
}
public class VisibilityProbeManager : MonoBehaviour
{
	private static VisibilityProbeManager instance;

	private List<VisibilityProbe> listProbes;

	private int numProbes;

	private Camera[] cameras;

	private Plane[][] frustumPlanes;

	private int curUpdateGroup;

	public int updateGroups = 4;

	public static VisibilityProbeManager Get()
	{
		return instance;
	}

	public static void Clear()
	{
		instance = null;
	}

	private void Awake()
	{
		instance = this;
		listProbes = new List<VisibilityProbe>();
	}

	private void Start()
	{
		GameObject[] array = GameObject.FindGameObjectsWithTag(Tags.MainCamera);
		cameras = new Camera[array.Length];
		for (int i = 0; i < array.Length; i++)
		{
			cameras[i] = array[i].GetComponent<Camera>();
		}
		frustumPlanes = new Plane[cameras.Length][];
	}

	private void Update()
	{
		for (int i = 0; i < cameras.Length; i++)
		{
			frustumPlanes[i] = GeometryUtility.CalculateFrustumPlanes(cameras[i]);
		}
		Vector3 centerEye = Player.GetCenterEye();
		for (int j = 0; j < listProbes.Count; j++)
		{
			VisibilityProbe visibilityProbe = listProbes[j];
			if (visibilityProbe.probeIndex % updateGroups == curUpdateGroup)
			{
				visibilityProbe.CheckVisibility(frustumPlanes, centerEye);
			}
		}
		curUpdateGroup++;
		if (curUpdateGroup >= updateGroups)
		{
			curUpdateGroup = 0;
		}
	}

	public void AddProbe(VisibilityProbe probe)
	{
		MapChunk chunk = probe.chunk;
		listProbes.Add(probe);
		numProbes++;
	}
}
[RequireComponent(typeof(Trigger))]
public class Checkpoint : MonoBehaviour
{
	public int setCheckpoint;

	public bool incrementCheckpoint;

	public bool setMetaMap;

	public int metaMap = 1;

	private void Start()
	{
		if (GameState.Get().checkPoint >= setCheckpoint && (!setMetaMap || GameState.Get().metaMap == metaMap))
		{
			GetComponent<Collider>().enabled = false;
		}
	}

	public void OnTrigger(PlayerGameController player)
	{
		if (incrementCheckpoint)
		{
			MetaProgress.Get().ActivateNext(Vector3.zero, save: false, 0f);
			GameState.Get().checkPoint++;
		}
		else
		{
			GameState.Get().checkPoint = setCheckpoint;
			MetaProgress.Get().nextToOpen = setCheckpoint;
		}
		if (setMetaMap)
		{
			GameState.Get().metaMap = metaMap;
		}
		GameController.Get().SaveGame();
		Tutorial.Get().Save();
	}
}
[RequireComponent(typeof(Trigger))]
public class EndGameTrigger : MonoBehaviour
{
	public string endingScene = "Ending";

	public void OnTrigger(PlayerGameController player)
	{
		Fader component = GameObject.Find("Fader").GetComponent<Fader>();
		component.SetColor(Color.white);
		component.FadeOut(2f, fadeAudio: true, base.gameObject);
	}

	public void OnEndFade(Fader fader)
	{
		Loader.nextScene = endingScene;
		Application.LoadLevel("LoadingEnd");
	}
}
[RequireComponent(typeof(Trigger))]
public class EndLiteDemoTrigger : MonoBehaviour
{
	public void OnTrigger(PlayerGameController player)
	{
		Fader component = GameObject.Find("Fader").GetComponent<Fader>();
		component.FadeOut(2f, fadeAudio: true, base.gameObject);
	}

	public void OnEndFade(Fader fader)
	{
		GameOver.Display("END_LITE_DEMO", "Intro", "EndLiteDemo");
	}
}
public class EndMetaProgress : FSMComponent<EndMetaProgress.States>
{
	public enum States
	{
		Disabled,
		FirstPillarOn,
		SecondPillarOn
	}

	public Transform exitPortal;

	public EndGameTrigger endTrigger;

	public bool spawnCreatures = true;

	public Transform[] shadowChaserSpawns;

	public Transform ghostSpawn;

	private Pillar pillarLeft;

	private Pillar pillarRight;

	private bool pillarLeftOn;

	private bool pillarRightOn;

	public GameObject portalOpenFX;

	public AudioSource portalLoopSound;

	public AudioSource portarOpenSound;

	private void Start()
	{
		MetaProgress.Get().onActivateNext = OnActivateNext;
		pillarLeft = GameObject.Find("Obelisk_4").GetComponent<Pillar>();
		pillarRight = GameObject.Find("Obelisk_3").GetComponent<Pillar>();
		Init(States.Disabled);
	}

	private void Disabled_Enter()
	{
		exitPortal.gameObject.SetActive(value: false);
		endTrigger.gameObject.SetActive(value: false);
		pillarLeftOn = (pillarRightOn = false);
	}

	private void FirstPillarOn_Enter()
	{
		Pillar closestPillar = GetClosestPillar(Player.GetGroundPos());
		if (closestPillar == pillarLeft)
		{
			pillarLeftOn = true;
			pillarLeft.ActivateEffects();
			Debug.Log("Left Pillar Activated");
		}
		else
		{
			pillarRightOn = true;
			pillarRight.ActivateEffects();
			Debug.Log("Right Pillar Activated");
		}
		Player.GetComponent<SpookSounds>().forceShadowSounds = true;
	}

	private void SecondPillarOn_Enter()
	{
		if (pillarLeftOn)
		{
			pillarRightOn = true;
			pillarRight.ActivateEffects();
			Debug.Log("Right Pillar Activated");
		}
		else
		{
			pillarLeftOn = true;
			pillarLeft.ActivateEffects();
			Debug.Log("Left Pillar Activated");
		}
		StartCoroutine(ActivatePortal_co());
	}

	public void OnActivateNext(Vector3 spawnPos, float delayOpen, bool save, float delaySave)
	{
		StartCoroutine(OnActivateNext_co(spawnPos, delayOpen));
	}

	private IEnumerator OnActivateNext_co(Vector3 spawnPos, float delay = 1f)
	{
		yield return new WaitForSeconds(delay);
		if (base.State == States.Disabled)
		{
			base.State = States.FirstPillarOn;
		}
		else if (base.State == States.FirstPillarOn)
		{
			base.State = States.SecondPillarOn;
		}
	}

	private IEnumerator ActivatePortal_co()
	{
		pillarLeft.ActivateLightning(portalOpenFX.transform);
		pillarRight.ActivateLightning(portalOpenFX.transform);
		portalLoopSound.enabled = true;
		yield return new WaitForSeconds(0.5f);
		portarOpenSound.enabled = true;
		portalOpenFX.SetActive(value: true);
		yield return new WaitForSeconds(0.8f);
		exitPortal.gameObject.SetActive(value: true);
		endTrigger.gameObject.SetActive(value: true);
		StartCoroutine(ScalePortalSize_co());
		if (spawnCreatures)
		{
			yield return new WaitForSeconds(2f);
			SpawnGhost();
			yield return new WaitForSeconds(6f);
			SpawnShadows();
		}
	}

	private IEnumerator ScalePortalSize_co()
	{
		Transform sph = exitPortal.GetChild(0);
		Vector3 curScale = sph.localScale;
		sph.localScale = Vector3.zero;
		float progress = 0f;
		while (progress <= 1f)
		{
			yield return 0;
			progress += Time.deltaTime;
			sph.localScale = Interpolate.EaseOutCubic(Vector3.zero, curScale, progress);
		}
	}

	private void SpawnShadows()
	{
		ShadowChaser shadowChaser = GameController.Get().GetComponent<ShadowFolkManager>().shadowChaser;
		for (int i = 0; i < shadowChaserSpawns.Length; i++)
		{
			ShadowChaser shadowChaser2 = UnityEngine.Object.Instantiate(shadowChaser, shadowChaserSpawns[i].position, shadowChaserSpawns[i].rotation);
			shadowChaser2.isVision = false;
			shadowChaser2.isAngry = true;
			shadowChaser2.superAggressive = true;
		}
	}

	private void SpawnGhost()
	{
		Ghost component = GameController.Get().GetComponent<GhostSpawner>().GhostPrefab.GetComponent<Ghost>();
		Ghost ghost = UnityEngine.Object.Instantiate(component, ghostSpawn.position, ghostSpawn.rotation);
		ghost.isAngryAppear = true;
		ghost.isVision = false;
		ghost.canStretch = true;
	}

	private Pillar GetClosestPillar(Vector3 pos)
	{
		float sqrMagnitude = (pillarLeft.transform.position - pos).sqrMagnitude;
		float sqrMagnitude2 = (pillarRight.transform.position - pos).sqrMagnitude;
		if (sqrMagnitude < sqrMagnitude2)
		{
			return pillarLeft;
		}
		return pillarRight;
	}
}
[RequireComponent(typeof(Trigger))]
public class EnterLevelTrigger : MonoBehaviour
{
	public LevelOptions[] levelOptions;

	public void OnTrigger(PlayerGameController player)
	{
		Fader component = GameObject.Find("Fader").GetComponent<Fader>();
		component.FadeOut(2f, fadeAudio: true, base.gameObject);
	}

	public void OnEndFade(Fader fader)
	{
		LevelOptions nextOptions = RandomExt.Choice(levelOptions);
		GameController.nextOptions = nextOptions;
		GameState.Get().Refresh(overwriteMap: false);
		Loader.LoadLevel("Dungeon");
	}
}
public class MetaMapAfterBuild_01 : MonoBehaviour
{
	public GameObject triggers;

	public void DoBuild()
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(triggers, Vector3.zero, Quaternion.identity);
		bool flag = GameController.Get().levelOptions.serializeID == GameState.Get().metaMap;
		int num = 0;
		if (flag)
		{
			num = GameState.Get().checkPoint;
		}
		Transform transform = gameObject.transform.Find("spawn_" + num);
		if (transform != null)
		{
			if (InputExt.Using3DOFController)
			{
				AfterBuild.AdjustSpawnRotation(transform);
			}
			Transform transform2 = Player.Get().transform;
			Vector3 position = transform.transform.position;
			position.y = transform2.position.y;
			Vector3 forward = transform.transform.forward.GroundNormalize();
			transform2.position = position;
			transform2.rotation = Quaternion.LookRotation(forward, Vector3.up);
		}
		if (GameController.Get().gameState.liteVersion)
		{
			for (char c = 'B'; c <= 'D'; c = (char)(c + 1))
			{
				GameObject gameObject2 = GameObject.Find("exit" + c);
				if (gameObject2 != null)
				{
					EnterLevelTrigger component = gameObject2.GetComponent<EnterLevelTrigger>();
					if ((bool)component)
					{
						UnityEngine.Object.Destroy(component);
					}
					gameObject2.AddComponent<EndLiteDemoTrigger>();
				}
			}
			GameObject gameObject3 = GameObject.Find("exitA");
			EnterLevelTrigger component2 = gameObject3.GetComponent<EnterLevelTrigger>();
			component2.levelOptions[0] = Resources.Load<LevelOptions>("LevelOptions/01_A_Lite");
		}
		if (flag)
		{
			Minimap component3 = GameObject.FindWithTag(Tags.Minimap).GetComponent<Minimap>();
			component3.loadFromSavegame = true;
		}
		if (flag)
		{
			StartCoroutine(DeserializeObjs_co());
		}
		else
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	private IEnumerator DeserializeObjs_co()
	{
		yield return 0;
		GameController.Get().serializer.DeserializeRegisteredObjs();
		UnityEngine.Object.Destroy(base.gameObject);
	}
}
public class MetaMapAfterBuild_02 : MonoBehaviour
{
	public GameObject triggers;

	public void DoBuild()
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(triggers, Vector3.zero, Quaternion.identity);
		bool flag = GameController.Get().levelOptions.serializeID == GameState.Get().metaMap;
		int num = 0;
		if (flag)
		{
			num = GameState.Get().checkPoint;
		}
		Transform transform = gameObject.transform.Find("spawn_" + num);
		if (transform != null)
		{
			if (InputExt.Using3DOFController)
			{
				AfterBuild.AdjustSpawnRotation(transform);
			}
			Transform transform2 = Player.Get().transform;
			Vector3 position = transform.transform.position;
			position.y = transform2.position.y;
			Vector3 forward = transform.transform.forward.GroundNormalize();
			transform2.position = position;
			transform2.rotation = Quaternion.LookRotation(forward, Vector3.up);
		}
		if (flag)
		{
			Minimap component = GameObject.FindWithTag(Tags.Minimap).GetComponent<Minimap>();
			component.loadFromSavegame = true;
		}
		if (flag)
		{
			StartCoroutine(DeserializeObjs_co());
		}
		else
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	private IEnumerator DeserializeObjs_co()
	{
		yield return 0;
		GameController.Get().serializer.DeserializeRegisteredObjs();
		UnityEngine.Object.Destroy(base.gameObject);
	}
}
public class MetaMapAfterBuild_03 : MonoBehaviour
{
	public GameObject triggers;

	public void DoBuild()
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(triggers, Vector3.zero, Quaternion.identity);
		bool flag = GameController.Get().levelOptions.serializeID == GameState.Get().metaMap;
		int num = 0;
		if (flag)
		{
			num = GameState.Get().checkPoint;
		}
		Transform transform = gameObject.transform.Find("spawn_" + num);
		if (transform != null)
		{
			if (InputExt.Using3DOFController)
			{
				AfterBuild.AdjustSpawnRotation(transform);
			}
			Transform transform2 = Player.Get().transform;
			Vector3 position = transform.transform.position;
			position.y = transform2.position.y;
			Vector3 forward = transform.transform.forward.GroundNormalize();
			transform2.position = position;
			transform2.rotation = Quaternion.LookRotation(forward, Vector3.up);
		}
		if (flag)
		{
			Minimap component = GameObject.FindWithTag(Tags.Minimap).GetComponent<Minimap>();
			component.loadFromSavegame = true;
		}
		if (flag)
		{
			StartCoroutine(DeserializeObjs_co());
		}
		else
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	private IEnumerator DeserializeObjs_co()
	{
		yield return 0;
		GameController.Get().serializer.DeserializeRegisteredObjs();
		UnityEngine.Object.Destroy(base.gameObject);
	}
}
public class MetaMapAfterBuild_04 : MonoBehaviour
{
	public GameObject triggers;

	public void DoBuild()
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(triggers, Vector3.zero, Quaternion.identity);
		bool flag = GameController.Get().levelOptions.serializeID == GameState.Get().metaMap;
		int num = 0;
		if (flag)
		{
			num = GameState.Get().checkPoint;
		}
		Transform transform = gameObject.transform.Find("spawn_" + num);
		if (transform != null)
		{
			if (InputExt.Using3DOFController)
			{
				AfterBuild.AdjustSpawnRotation(transform);
			}
			Transform transform2 = Player.Get().transform;
			Vector3 position = transform.transform.position;
			position.y = transform2.position.y;
			Vector3 forward = transform.transform.forward.GroundNormalize();
			transform2.position = position;
			transform2.rotation = Quaternion.LookRotation(forward, Vector3.up);
		}
		if (flag)
		{
			Minimap component = GameObject.FindWithTag(Tags.Minimap).GetComponent<Minimap>();
			component.loadFromSavegame = true;
		}
		if (flag)
		{
			StartCoroutine(DeserializeObjs_co());
		}
		else
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	private IEnumerator DeserializeObjs_co()
	{
		yield return 0;
		GameController.Get().serializer.DeserializeRegisteredObjs();
		UnityEngine.Object.Destroy(base.gameObject);
	}
}
public class MetaMapGenerator_01 : CustomGenerator
{
	protected override void DefineMap()
	{
		SetSeed(2393353562u);
		SetStyle(new string[3] { "dungeon", "room", "small" }, "tunnel_flat_reduced");
		SetStyle(new string[3] { "dungeon", "room", "medium" }, "tunnel_arched_reduced");
		SetStyle(new string[3] { "dungeon", "room", "large" }, "tunnel_arched_reduced");
		SetStyle(new string[3] { "dungeon", "room", "hub" }, "tunnel_high_arched_medium");
		SetStyle(new string[3] { "dungeon", "corridor", "narrow" }, "living_quarters");
		SetStyle(new string[3] { "dungeon", "corridor", "large" }, "tunnel_flat_reduced");
		int from = AddRoom("_meta_01_A", 12, 40);
		int to = AddRoom("_meta_01_B", 12, 34);
		int to2 = AddRoom("_meta_01_C", 20, 36);
		int num = AddRoom("_meta_01_D", 20, 30);
		int to3 = AddRoom("_meta_01_HUB", 26, 18);
		int from2 = AddRoom("_meta_01_exit_A", 18, 18);
		int from3 = AddRoom("_meta_01_exit_B", 30, 12);
		int from4 = AddRoom("_meta_01_exit_C", 42, 18);
		int from5 = AddRoom("_meta_01_exit_D", 30, 34);
		int from6 = AddRoom("_meta_01_E", 38, 30);
		AddCorridor(num, to3);
		AddCorridor(from, to);
		AddCorridor(from, to2);
		AddCorridor(from, num);
		AddCorridor(from2, to3, isDouble: true);
		AddCorridor(from3, to3, isDouble: true);
		AddCorridor(from4, to3, isDouble: true);
		AddCorridor(from5, to3, isDouble: true);
		AddCorridor(from6, to3);
		startRoom = from;
		exitRoom = from6;
		Options.DoorClutter = 1f;
	}

	public override void AfterGeneration()
	{
		RemoveDoor(new Point(38, 27));
		RemoveDoor(new Point(44, 33));
	}

	public override void AfterBuild()
	{
		Map.Get().At(17, 42).Door.SetLocked();
		Map.Get().At(20, 40).Door.SetLocked(locked: false);
		Map.Get().At(20, 32).Door.SetLocked();
		Map.Get().At(26, 27).Door.SetLocked(locked: false);
		Map.Get().At(18, 36).Door.SetLocked();
		Unlockable componentInChildren = Map.Get().At(18, 36).Door.GetComponentInChildren<Unlockable>();
		if (componentInChildren != null)
		{
			componentInChildren.skipTutorialIfTouch = true;
		}
		FixRenderQueue("MapGeometry/01carpet_14");
		FixRenderQueue("MapGeometry/01carpet_12");
	}

	private void FixRenderQueue(string objName)
	{
		GameObject gameObject = GameObject.Find(objName);
		if (gameObject != null)
		{
			Renderer component = gameObject.transform.GetChild(0).gameObject.GetComponent<Renderer>();
			component.material.renderQueue--;
		}
	}
}
public class MetaMapGenerator_02 : CustomGenerator
{
	protected override void DefineMap()
	{
		SetSeed(2506340222u);
		SetStyle(new string[3] { "dungeon", "room", "small" }, "temple_arched");
		SetStyle(new string[3] { "dungeon", "room", "medium" }, "temple_room");
		SetStyle(new string[3] { "dungeon", "room", "large" }, "temple_room");
		SetStyle(new string[3] { "dungeon", "room", "hub" }, "tunnel_high_arched_medium2");
		SetStyle(new string[3] { "dungeon", "corridor", "narrow" }, "temple_room");
		SetStyle(new string[3] { "dungeon", "corridor", "large" }, "temple_arched");
		SetStyle(new string[3] { "catacomb", "corridor", "narrow" }, "catacomb_narrow");
		SetStyle(new string[3] { "catacomb", "room", "small" }, "catacomb");
		int from = AddRoom("_meta_02_A", 8, 36);
		int num = AddRoom("_meta_02_B", 20, 34);
		int to = AddRoom("_meta_02_HUB", 26, 18);
		int from2 = AddRoom("_meta_01_exit_A", 16, 14);
		int from3 = AddRoom("_meta_01_exit_B", 34, 12);
		int from4 = AddRoom("_meta_01_exit_C", 44, 14);
		AddCorridor(from, num);
		AddCorridor(num, to);
		AddCorridor(from2, to, isDouble: true);
		AddCorridor(from3, to);
		AddCorridor(from4, to, isDouble: true);
		startRoom = from;
		exitRoom = num;
		Options.DoorClutter = 1f;
	}

	public override void AfterGeneration()
	{
		for (int i = 17; i <= 20; i++)
		{
			Tags.Set(MapTags.Group.Main, "catacomb", new Point(33, i));
		}
		for (int j = 33; j <= 36; j++)
		{
			Tags.Set(MapTags.Group.Main, "catacomb", new Point(j, 17));
		}
		for (int k = 10; k <= 17; k++)
		{
			for (int l = 36; l <= 40; l++)
			{
				Tags.Set(MapTags.Group.Main, "catacomb", new Point(l, k));
			}
		}
		RemoveDoor(new Point(33, 20));
		RemoveDoor(new Point(36, 16));
	}

	public override void AfterBuild()
	{
	}
}
public class MetaMapGenerator_03 : CustomGenerator
{
	protected override void DefineMap()
	{
		SetSeed(1844614888u);
		SetStyle(new string[3] { "catacomb", "room", "small" }, "oldbrick_reduced_dirtground");
		SetStyle(new string[3] { "catacomb", "room", "medium" }, "catacomb");
		SetStyle(new string[3] { "catacomb", "room", "large" }, "catacomb");
		SetStyle(new string[3] { "catacomb", "room", "hub" }, "catacomb_high");
		SetStyle(new string[3] { "catacomb", "corridor", "narrow" }, "catacomb_narrow");
		SetStyle(new string[3] { "catacomb", "corridor", "large" }, "catacomb_corridor_large");
		int from = AddRoom("_meta_03_A", 8, 12);
		int to = AddRoom("_meta_03_B", 20, 8);
		int to2 = AddRoom("_meta_03_C", 19, 15);
		int to3 = AddRoom("_meta_03_D", 22, 20);
		int num = AddRoom("_meta_03_HUB", 34, 24);
		int from2 = AddRoom("_meta_01_exit_C", 44, 18);
		int from3 = AddRoom("_meta_01_exit_D", 42, 44);
		int from4 = AddRoom("_meta_01_exit_C", 50, 22);
		AddCorridor(from, to3);
		AddCorridor(from, to);
		AddCorridor(from, to2);
		AddCorridor(num, to2);
		AddCorridor(from2, num);
		AddCorridor(from3, num);
		AddCorridor(from4, num);
		startRoom = from;
		exitRoom = to;
		Options.DoorClutter = 1f;
	}

	public override void AfterGeneration()
	{
		RemoveDoor(new Point(40, 38));
		RemoveDoor(new Point(41, 24));
		RemoveDoor(new Point(46, 29));
		RemoveDoor(new Point(44, 23));
		RemoveDoor(new Point(44, 44));
		RemoveDoor(new Point(50, 27));
		RemoveDoor(new Point(25, 29));
	}

	public override void AfterBuild()
	{
		Map.Get().At(34, 31).Door.SetLocked(locked: false);
	}
}
public class MetaMapGenerator_04 : CustomGenerator
{
	protected override void DefineMap()
	{
		SetSeed(1091075578u);
		SetStyle(new string[3] { "dungeon", "room", "small" }, "catacomb");
		SetStyle(new string[3] { "dungeon", "room", "medium" }, "temple_room");
		SetStyle(new string[3] { "dungeon", "room", "large" }, "temple_room");
		SetStyle(new string[3] { "dungeon", "room", "hub" }, "tunnel_high_arched");
		SetStyle(new string[3] { "dungeon", "corridor", "narrow" }, "catacomb_narrow");
		SetStyle(new string[3] { "dungeon", "corridor", "large" }, "temple_arched");
		int num = 12;
		int num2 = AddRoom("_meta_04_A", 8, 32 + num);
		int to = AddRoom("_meta_04_B", 14, 24 + num);
		int from = AddRoom("_meta_04_C", 14, 38 + num);
		int to2 = AddRoom("_meta_01_exit_C", 30, 38 + num);
		int from2 = AddRoom("_meta_04_HUB", 22, 6);
		AddCorridor(from, to2);
		AddCorridor(from, num2);
		AddCorridor(num2, to, isDouble: true);
		AddCorridor(from2, to, isDouble: true);
		startRoom = from;
		exitRoom = to;
		Options.DoorClutter = 1f;
	}

	public override void AfterGeneration()
	{
		RemoveDoor(new Point(19, 53));
		RemoveDoor(new Point(10, 50));
		RemoveDoor(new Point(14, 52));
	}

	public override void AfterBuild()
	{
	}
}
public class MetaOnCollectItem : MonoBehaviour
{
	public string itemName;

	public Transform tutorialPlace;

	public string tutorialText;

	private TextLabel tutorialLabel;

	private void Start()
	{
		StartCoroutine(Start_co());
	}

	private IEnumerator Start_co()
	{
		yield return 0;
		GameObject item = GameObject.Find(itemName);
		if (!item)
		{
			UnityEngine.Object.Destroy(this);
			yield break;
		}
		Collectable component = item.GetComponent<Collectable>();
		if (!component)
		{
			UnityEngine.Object.Destroy(this);
		}
		else
		{
			component.NotifyOnPickUp(base.gameObject);
		}
	}

	private void OnColledted(Collectable collectable)
	{
		tutorialLabel = Tutorial.ShowInPlace(tutorialText, Vector3.zero, Quaternion.identity, tutorialPlace, 4f, facePlayer: true);
		if (tutorialLabel != null)
		{
			StartCoroutine(Update_co());
		}
	}

	private IEnumerator Update_co()
	{
		int curProgress = MetaProgress.Get().nextToOpen;
		while (curProgress == MetaProgress.Get().nextToOpen)
		{
			yield return new WaitForSeconds(0.25f);
		}
		tutorialLabel.FadeOut(4f, disableOnFadeOut: true, destroyOnFadeOut: true);
		tutorialLabel = null;
	}
}
public class MetaProgress : MonoBehaviour
{
	public delegate void OnActivateNext(Vector3 spawnPos, float delayOpen, bool save, float delaySave);

	public string[] gateNames;

	public UniSplineComponent[] paths;

	public UniSplineFollower pathFollowerPrefab;

	public int nextToOpen;

	public bool closeLastActorIfNull;

	private List<MechActor> actors;

	public Dictionary<MechActor, UniSplineComponent> splinesByActors;

	public OnActivateNext onActivateNext;

	private static MetaProgress instance;

	public static MetaProgress Get()
	{
		return instance;
	}

	private void Awake()
	{
		instance = this;
	}

	private void Start()
	{
		int num = 0;
		actors = new List<MechActor>();
		splinesByActors = new Dictionary<MechActor, UniSplineComponent>();
		for (int i = 0; i < gateNames.Length; i++)
		{
			if (gateNames[i] == string.Empty)
			{
				actors.Add(null);
				continue;
			}
			GameObject gameObject = GameObject.Find(gateNames[i]);
			if (gameObject == null)
			{
				Debug.LogError("Gate object not found: " + gateNames[i]);
				actors.Add(null);
				continue;
			}
			MechGate component = gameObject.GetComponent<MechGate>();
			actors.Add(component);
			if (num < paths.Length)
			{
				splinesByActors[component] = paths[num];
				num++;
			}
		}
		nextToOpen = 0;
		Serializer.Add(this, OnSerialize, OnDeserialize);
	}

	private void OnSerialize(BinaryWriter writer)
	{
	}

	private void OnDeserialize(BinaryReader reader)
	{
		int checkPoint = GameState.Get().checkPoint;
		nextToOpen = checkPoint;
		if (actors.Count == 0)
		{
			return;
		}
		for (int i = 0; i < nextToOpen; i++)
		{
			if (actors[i] != null)
			{
				actors[i].SetProgress(1f, instantaneous: true);
			}
			else if (closeLastActorIfNull && i > 0 && actors[i - 1] != null)
			{
				actors[i - 1].SetProgress(0f, instantaneous: true);
			}
		}
	}

	public void ActivateNext(Vector3 spawnPos, float delayOpen = 1f, float delaySave = 2f)
	{
		if (onActivateNext != null)
		{
			onActivateNext(spawnPos, delayOpen, save: true, delaySave);
		}
		else
		{
			StartCoroutine(ActivateNext_co(spawnPos, delayOpen, save: true, delaySave));
		}
	}

	public void ActivateNext(Vector3 spawnPos, bool save, float delayOpen = 1f, float delaySave = 2f)
	{
		if (onActivateNext != null)
		{
			onActivateNext(spawnPos, delayOpen, save, delaySave);
		}
		else
		{
			StartCoroutine(ActivateNext_co(spawnPos, delayOpen, save, delaySave));
		}
	}

	private IEnumerator ActivateNext_co(Vector3 spawnPos, float delayOpen = 1f, bool save = true, float delaySave = 2f)
	{
		if (nextToOpen >= actors.Count)
		{
			yield break;
		}
		if (actors[nextToOpen] != null)
		{
			if (spawnPos != Vector3.zero)
			{
				UniSplineComponent uniSplineComponent = splinesByActors[actors[nextToOpen]];
				if (uniSplineComponent != null && pathFollowerPrefab != null)
				{
					UniSplineFollower uniSplineFollower = UnityEngine.Object.Instantiate(pathFollowerPrefab, spawnPos, Quaternion.identity);
					uniSplineFollower.splineComp = uniSplineComponent;
				}
			}
			yield return new WaitForSeconds(delayOpen);
			actors[nextToOpen].SetProgress();
		}
		else if (closeLastActorIfNull && nextToOpen > 0)
		{
			yield return new WaitForSeconds(delayOpen);
			if (actors[nextToOpen - 1] != null)
			{
				actors[nextToOpen - 1].SetProgress(0f);
			}
		}
		else
		{
			yield return new WaitForSeconds(delayOpen);
		}
		nextToOpen++;
		yield return new WaitForSeconds(delaySave);
		if (save)
		{
			GameState.Get().checkPoint++;
			GameController.Get().SaveGame();
			Tutorial.Get().Save();
		}
	}
}
public class MetaUnlocker : ProgressInteraction
{
	public bool unlocked;

	public AudioClip unlockSound;

	public GameObject[] unlockPrefabs;

	public GameObject[] unlockEnableObjs;

	public Transform unlockSpawnPoint;

	public Collectable.EItemType requiredItem;

	private ParticleSystem[] particles;

	private Inventory inventory;

	private new void Start()
	{
		base.Start();
		particles = GetComponentsInChildren<ParticleSystem>();
		if (!unlocked)
		{
			SetParticlesEmission(enabled: false);
		}
		else
		{
			SetParticlesEmission(enabled: true);
		}
		inventory = GameObject.FindWithTag(Tags.Inventory).GetComponent<Inventory>();
		Serializer.Add(this, OnSerialize, OnDeserialize);
	}

	private void OnSerialize(BinaryWriter writer)
	{
		writer.Write(unlocked);
	}

	private void OnDeserialize(BinaryReader reader)
	{
		bool flag = reader.ReadBoolean();
		if (flag && !unlocked)
		{
			unlocked = flag;
			SetParticlesEmission(enabled: true);
			for (int i = 0; i < unlockEnableObjs.Length; i++)
			{
				unlockEnableObjs[i].gameObject.SetActive(value: true);
			}
		}
	}

	private new void Update()
	{
		base.Update();
		needsProgress = !unlocked && inventory.NumItems[(int)requiredItem] > 0;
		if (InputExt.UsingHandControllers)
		{
			needsProgress = false;
		}
	}

	protected override void OnFinishProgress()
	{
		Unlock();
	}

	public void Unlock()
	{
		if (!unlocked && inventory.ConsumeItem(requiredItem))
		{
			unlocked = true;
			SetParticlesEmission(enabled: true);
			for (int i = 0; i < unlockEnableObjs.Length; i++)
			{
				unlockEnableObjs[i].gameObject.SetActive(value: true);
			}
			if ((bool)unlockSound)
			{
				AudioSource.PlayClipAtPoint(unlockSound, unlockSpawnPoint.position);
			}
			for (int j = 0; j < unlockPrefabs.Length; j++)
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(unlockPrefabs[j]);
				gameObject.transform.position = unlockSpawnPoint.position;
			}
			MetaProgress.Get().ActivateNext(unlockSpawnPoint.position);
		}
	}

	private void SetParticlesEmission(bool enabled)
	{
		for (int i = 0; i < particles.Length; i++)
		{
			particles[i].enableEmission = enabled;
		}
	}
}
[RequireComponent(typeof(Trigger))]
public class OilTutorialTrigger : MonoBehaviour
{
	public bool require3DOF;

	public bool requireTouch;

	public void OnTrigger(PlayerGameController player)
	{
		if ((require3DOF && !InputExt.Using3DOFController) || (requireTouch && !InputExt.UsingHandControllers))
		{
			base.enabled = false;
			return;
		}
		if (Config.General().tutorials)
		{
			Tutorial.Get().ForceTutorialOil();
		}
		base.enabled = false;
	}
}
[RequireComponent(typeof(Trigger))]
public class TutorialTrigger : MonoBehaviour
{
	public string tutorialString;

	public float showTime = 5f;

	public bool require3DOF;

	public bool requireTouch;

	public bool checkStringExists;

	public void OnTrigger(PlayerGameController player)
	{
		if (require3DOF && !InputExt.Using3DOFController)
		{
			base.enabled = false;
			return;
		}
		if (requireTouch && !InputExt.UsingHandControllers)
		{
			base.enabled = false;
			return;
		}
		if (Config.General().tutorials && !Tutorial.HasBeenShownBefore(tutorialString, add: true) && (!checkStringExists || Translate.Check(tutorialString)))
		{
			Tutorial.Get().ShowTextForTime(Translate.GetForInput(tutorialString), showTime);
		}
		base.enabled = false;
	}
}
public class UniSplineFollower : MonoBehaviour
{
	public UniSplineComponent splineComp;

	public bool addStartingPosition;

	private BaseSpline.SplineIterator splineIter;

	public Ease.Easing m_easing;

	public bool destroyOnEnd = true;

	private float progress;

	public float speed = 1f;

	private void Start()
	{
		if (addStartingPosition)
		{
			splineComp.Spline.InsertPoint(0, base.transform.position - splineComp.transform.position);
			splineComp.Spline.Build();
		}
		splineIter = splineComp.Spline.GetIterator();
		splineIter.SetTransform(splineComp.transform);
	}

	private void Update()
	{
		progress += speed * Time.deltaTime;
		splineIter.SetOffset(Ease.EaseByType(m_easing, 0f, splineComp.Spline.Length, progress / splineComp.Spline.Length));
		base.transform.position = splineIter.GetPosition();
		if (destroyOnEnd && progress >= splineComp.Spline.Length)
		{
			UnityEngine.Object.Destroy(base.gameObject, 5f);
			base.enabled = false;
		}
	}
}
[RequireComponent(typeof(Trigger))]
public class WalkTutorialTrigger : MonoBehaviour
{
	public string tutorialString;

	public float waitTime;

	public void OnTrigger(PlayerGameController player)
	{
		if (Config.General().tutorials && Translate.Check(tutorialString) && (InputExt.Using3DOFController || InputExt.UsingHandControllers))
		{
			StartCoroutine(Tutorial_co());
		}
		base.enabled = false;
	}

	private IEnumerator Tutorial_co()
	{
		yield return new WaitForSeconds(waitTime);
		Vector3 playerPos = Player.GetPos();
		TextLabel tutorialLabel = Tutorial.ShowInPlace(tutorialString, Vector3.zero, Quaternion.identity, base.transform, 1f);
		if ((bool)tutorialLabel)
		{
			tutorialLabel.gameObject.AddComponent<DistanceDestroyer>();
			while ((Player.GetPos() - playerPos).sqrMagnitudeGround() <= 0.25f)
			{
				yield return 0;
			}
			tutorialLabel.FadeOut(4f, disableOnFadeOut: true, destroyOnFadeOut: true);
		}
	}
}
public class Minimap : MonoBehaviour
{
	private Texture2D Mask;

	private Point LastCell;

	private Transform player;

	public float reductionFactor = 1f;

	private float mapTexSize;

	public bool loadFromSavegame;

	private Renderer renderer;

	private void Start()
	{
		player = Player.Get().transform;
		LastCell = new Point(0, 0);
		renderer = GetComponent<Renderer>();
		Mask = (Texture2D)renderer.sharedMaterials[0].GetTexture("_LevelMap");
		mapTexSize = 0.5f * reductionFactor;
		float num = 1f / reductionFactor;
		float num2 = (1f - 0.5f * num) / 2f;
		renderer.sharedMaterials[0].SetTextureOffset("_LevelMap", new Vector2(num2, num2));
		renderer.sharedMaterials[0].SetTextureScale("_LevelMap", new Vector2(0.5f * num, 0.5f * num));
		ResetMask();
		if (loadFromSavegame)
		{
			Deserialize(GameState.Get().minimap);
		}
		PlayerStats.Get().SetMinimap(Mask);
	}

	private void Update()
	{
		Point point = Map.Get().WorldToCell(base.transform.position);
		if (point != LastCell)
		{
			UpdateMask(point);
			LastCell = point;
		}
		UpdateMarker();
		if (renderer.enabled && GameController.Get().Paused)
		{
			renderer.enabled = false;
		}
		else if (!renderer.enabled && !GameController.Get().Paused)
		{
			renderer.enabled = true;
		}
	}

	public void ResetMask(float fVisibility = 0f)
	{
		for (int i = 0; i < Mask.height; i++)
		{
			for (int j = 0; j < Mask.width; j++)
			{
				Color pixel = Mask.GetPixel(j, i);
				pixel.a = fVisibility;
				Mask.SetPixel(j, i, pixel);
			}
		}
		Mask.Apply();
	}

	private void UpdateMask(Point cellPos)
	{
		int width = Map.Get().Width;
		int height = Map.Get().Height;
		int num = (Mask.width - width) / 2;
		int num2 = (Mask.height - height) / 2;
		Vector3 vector = Map.Get().CellToWorld(cellPos);
		for (int i = cellPos.Y - 10; i <= cellPos.Y + 10; i++)
		{
			if (i <= 0 || i >= Map.Get().Height - 1)
			{
				continue;
			}
			for (int j = cellPos.X - 10; j <= cellPos.X + 10; j++)
			{
				if (j > 0 && j < Map.Get().Width - 1)
				{
					Point point = new Point(num + j, num2 + (height - 1 - i));
					Color pixel = Mask.GetPixel(point.X, point.Y);
					float magnitude = (Map.Get().CellToWorld(j, i) - vector).magnitude;
					pixel.a = Mathf.Max(pixel.a, Mathf.Lerp(0.4f, 0f, magnitude / 10f));
					Cell cell = Map.Get().At(j, i);
					if (cell.IsDiscovered())
					{
						pixel.a = Mathf.Max(pixel.a, Mathf.Lerp(1f, 0f, magnitude / 10f));
					}
					Mask.SetPixel(point.X, point.Y, pixel);
				}
			}
		}
		Mask.Apply();
	}

	private void UpdateMarker()
	{
		Point point = Map.Get().WorldToCell(player.position);
		float num = renderer.sharedMaterials[0].GetTextureScale("_Marker").x / 64f * reductionFactor;
		float num2 = (float)(-point.X) * num + 0.5f * num;
		float num3 = (float)(-(63 - point.Y)) * num + 0.5f * num;
		num2 -= (64f - reductionFactor * 64f) * 0.5f * num;
		num3 -= (64f - reductionFactor * 64f) * 0.5f * num;
		renderer.sharedMaterials[0].SetTextureOffset("_Marker", new Vector2(num2, num3));
	}

	public void Serialize(GameState gameState)
	{
		gameState.minimap = Serialize();
	}

	public void Deserialize(GameState gameState)
	{
		Deserialize(gameState.minimap);
	}

	private float[] Serialize()
	{
		int width = Map.Get().Width;
		int height = Map.Get().Height;
		int num = (Mask.width - width) / 2;
		int num2 = (Mask.height - height) / 2;
		float[] array = new float[width * height];
		for (int i = 0; i < height; i++)
		{
			for (int j = 0; j < width; j++)
			{
				int num3 = i * width + j;
				Point point = new Point(num + j, num2 + (height - 1 - i));
				float num4 = Mask.GetPixel(point.X, point.Y).a;
				Cell cell = Map.Get().At(j, i);
				if (cell.IsDiscovered() && num4 > 0f)
				{
					num4 = 0f - num4;
				}
				array[num3] = num4;
			}
		}
		return array;
	}

	private void Deserialize(float[] state)
	{
		if (state == null || state.Length == 0)
		{
			ResetMask();
			return;
		}
		int width = Map.Get().Width;
		int height = Map.Get().Height;
		int num = (Mask.width - width) / 2;
		int num2 = (Mask.height - height) / 2;
		for (int i = 0; i < height; i++)
		{
			for (int j = 0; j < width; j++)
			{
				int num3 = i * width + j;
				Point point = new Point(num + j, num2 + (height - 1 - i));
				float num4 = state[num3];
				if (num4 < 0f)
				{
					num4 = 0f - num4;
					Cell cell = Map.Get().At(j, i);
					if (cell.Probe != null)
					{
						cell.Probe.Discovered = true;
					}
				}
				Color pixel = Mask.GetPixel(point.X, point.Y);
				pixel.a = num4;
				Mask.SetPixel(point.X, point.Y, pixel);
			}
		}
		Mask.Apply();
	}
}
public class MinimapHandController : MonoBehaviour
{
	public PlayerHand hand;

	public Transform minimapAnchor;

	private Vector3 visibleScale;

	private Vector3 visiblePosition;

	private Vector3 hiddenPosition;

	private void Start()
	{
		visibleScale = base.transform.localScale;
		visiblePosition = base.transform.localPosition;
		hiddenPosition = base.transform.parent.InverseTransformPoint(minimapAnchor.position);
	}

	private void Update()
	{
		bool flag = !InputExt.GetButton(InputExt.Button.HideMap);
		base.transform.localScale = Interpolate.Approach(base.transform.localScale, (!flag) ? visibleScale : Vector3.zero, Time.deltaTime * 2f * 7f);
		base.transform.localPosition = Interpolate.Approach(base.transform.localPosition, (!flag) ? visiblePosition : hiddenPosition, Time.deltaTime * 2f * 7f);
		hand.mapLocked = !flag;
	}
}
public class MinimapHider : MonoBehaviour
{
	public float HideFactor = 1f;
}
public class MinimapPosition : MonoBehaviour
{
	public Transform LookDirection;

	private Transform _LookDirection;

	public float MinLookAngle = 30f;

	public float MaxLookAngle = 45f;

	public float MinMapAngle = 28.5f;

	public float MaxMapAngle = 49f;

	public float HideMapAngle = 79f;

	public float MapDistance = 0.52f;

	public float MapFrontAngle;

	public LayerMask HiderMask;

	public LayerMask CloseHiderMask;

	public bool checkClipping;

	public LayerMask ClippingMask;

	public float ClippingDistance;

	public bool Hide;

	public bool Minimize;

	public bool IsFolded = true;

	public float FoldedMinLookAngle;

	public float FoldedMaxLookAngle;

	public float FoldedMinMapAngle;

	public float FoldedMaxMapAngle;

	public float FoldLimitMax;

	public float FoldLimitMin;

	public LayerMask CollisionMask;

	public Transform colliderLeft;

	public Transform colliderRight;

	public Transform colliderLeftUp;

	public Transform colliderRightUp;

	private float MinLookCos;

	private float MaxLookCos;

	private float FoldedMinLookCos;

	private float FoldedMaxLookCos;

	private float FoldLimitMinCos;

	private float FoldLimitMaxCos;

	private float MapHiddenFrontAngle;

	private float maxAngle = 1f;

	private Vector3 startScale;

	public float MinLook3DOFAngle = 30f;

	public float MaxLook3DOFAngle = 30f;

	public float FoldedMinLook3DOFAngle;

	public float FoldedMaxLook3DOFAngle;

	private float MinLook3DOFCos;

	private float MaxLook3DOFCos;

	private float FoldedMinLook3DOFCos;

	private float FoldedMaxLook3DOFCos;

	private void Start()
	{
		MinLookCos = Mathf.Cos(MinLookAngle * ((float)Math.PI / 180f));
		MaxLookCos = Mathf.Cos(MaxLookAngle * ((float)Math.PI / 180f));
		FoldedMinLookCos = Mathf.Cos(FoldedMinLookAngle * ((float)Math.PI / 180f));
		FoldedMaxLookCos = Mathf.Cos(FoldedMaxLookAngle * ((float)Math.PI / 180f));
		FoldLimitMinCos = Mathf.Cos(FoldLimitMin * ((float)Math.PI / 180f));
		FoldLimitMaxCos = Mathf.Cos(FoldLimitMax * ((float)Math.PI / 180f));
		MapHiddenFrontAngle = base.transform.localEulerAngles.x;
		IsFolded = true;
		startScale = base.transform.localScale;
		_LookDirection = LookDirection;
		if (InputExt.Using3DOFController)
		{
			_LookDirection = Player.GetLook(interaction: true);
			MinLook3DOFCos = Mathf.Cos(MinLook3DOFAngle * ((float)Math.PI / 180f));
			MaxLook3DOFCos = Mathf.Cos(MaxLook3DOFAngle * ((float)Math.PI / 180f));
			FoldedMinLook3DOFCos = Mathf.Cos(FoldedMinLook3DOFAngle * ((float)Math.PI / 180f));
			FoldedMaxLook3DOFCos = Mathf.Cos(FoldedMaxLook3DOFAngle * ((float)Math.PI / 180f));
		}
	}

	private void Update()
	{
		if (InputExt.Using3DOFController)
		{
			_LookDirection = Player.GetLook(interaction: true);
		}
		Vector3 rhs = Vector3.Cross(_LookDirection.forward, _LookDirection.up);
		Vector3 rhs2 = Vector3.Cross(Vector3.up, rhs);
		rhs2.Normalize();
		float num = Vector3.Dot(_LookDirection.forward, rhs2);
		if (num <= FoldLimitMaxCos)
		{
			IsFolded = false;
		}
		else if (num >= FoldLimitMinCos)
		{
			IsFolded = true;
		}
		float num2 = ((!IsFolded) ? MinLookCos : FoldedMinLookCos);
		float num3 = ((!IsFolded) ? MaxLookCos : FoldedMaxLookCos);
		float b = ((!IsFolded) ? MinMapAngle : FoldedMinMapAngle);
		float a = ((!IsFolded) ? MaxMapAngle : FoldedMaxMapAngle);
		float t = Mathf.Clamp((num - num2) / (num3 - num2), 0f, 1f);
		if (InputExt.Using3DOFController)
		{
			float minLook3DOFCos = MinLook3DOFCos;
			float maxLook3DOFCos = MaxLook3DOFCos;
			b = MinMapAngle;
			a = FoldedMaxMapAngle;
			t = Mathf.Clamp((num - minLook3DOFCos) / (maxLook3DOFCos - minLook3DOFCos), 0f, 1f);
			if (_LookDirection.forward.y < 0f)
			{
				t = 0f;
			}
		}
		else if (_LookDirection.forward.y > 0f)
		{
			t = 0f;
		}
		bool flag = CheckHider();
		float angle = (flag ? HideMapAngle : Mathf.LerpAngle(a, b, t));
		Vector3 vector = Vector3.forward * MapDistance;
		vector = Quaternion.AngleAxis(angle, Vector3.right) * vector;
		float x = (flag ? MapHiddenFrontAngle : Mathf.LerpAngle(MapHiddenFrontAngle, MapFrontAngle, t));
		Vector3 localEulerAngles = base.transform.localEulerAngles;
		localEulerAngles.x = x;
		base.transform.localEulerAngles = localEulerAngles;
		base.transform.localPosition = Vector3.Slerp(base.transform.localPosition, vector, Time.deltaTime * 4f);
		base.transform.localScale = Interpolate.Approach(base.transform.localScale, (!Minimize) ? startScale : Vector3.zero, Time.deltaTime * 7f);
		Hide = false;
		Minimize = false;
	}

	private bool CheckHider()
	{
		if (Hide)
		{
			return true;
		}
		if (InputExt.GetButton(InputExt.Button.HideMap))
		{
			return true;
		}
		Vector3 position = LookDirection.transform.position;
		Vector3 forward = LookDirection.transform.forward;
		if (Physics.Raycast(position, forward, out var hitInfo, 3f, HiderMask))
		{
			MinimapHider[] components = hitInfo.collider.gameObject.GetComponents<MinimapHider>();
			if (components.Length != 0)
			{
				return true;
			}
			if ((CloseHiderMask.value & (1 << hitInfo.collider.gameObject.layer)) != 0)
			{
				float sqrMagnitude = (hitInfo.point - position).sqrMagnitude;
				if (sqrMagnitude <= 4f)
				{
					return true;
				}
			}
		}
		if (Physics.Raycast(position + forward * 3f, -forward, out hitInfo, 3f, HiderMask))
		{
			MinimapHider[] components2 = hitInfo.collider.gameObject.GetComponents<MinimapHider>();
			if (components2.Length != 0)
			{
				return true;
			}
			if ((CloseHiderMask.value & (1 << hitInfo.collider.gameObject.layer)) != 0)
			{
				float sqrMagnitude2 = (hitInfo.point - position).sqrMagnitude;
				if (sqrMagnitude2 <= 4f)
				{
					return true;
				}
			}
		}
		if (checkClipping)
		{
			float num = 0.07f;
			float num2 = 0.13f;
			Vector3 vector = base.transform.parent.position + Vector3.up * num;
			if (Physics.Raycast(vector, base.transform.parent.forward, ClippingDistance, ClippingMask))
			{
				return true;
			}
			if (Physics.Raycast(vector + base.transform.parent.right * 0.18f, base.transform.parent.forward, ClippingDistance, ClippingMask))
			{
				return true;
			}
			if (Physics.Raycast(vector - base.transform.parent.right * 0.18f, base.transform.parent.forward, ClippingDistance, ClippingMask))
			{
				return true;
			}
			Vector3 vector2 = base.transform.parent.position + Vector3.up * num2;
			Vector3 start = vector2 - base.transform.parent.right * 0.18f + base.transform.parent.forward * ClippingDistance;
			Vector3 end = vector2 + base.transform.parent.right * 0.18f + base.transform.parent.forward * ClippingDistance;
			if (Physics.Linecast(start, end, ClippingMask))
			{
				return true;
			}
		}
		return false;
	}

	private float CheckMaxAngle(float curAngle)
	{
		if (Physics.Linecast(colliderLeft.position, colliderRight.position, out var hitInfo, CollisionMask))
		{
			if ((CollisionMask.value & (1 << hitInfo.collider.gameObject.layer)) != 0)
			{
				return maxAngle + 0.2f;
			}
		}
		else if (Physics.Linecast(colliderLeftUp.position, colliderRightUp.position, out hitInfo, CollisionMask) && (CollisionMask.value & (1 << hitInfo.collider.gameObject.layer)) != 0)
		{
			return maxAngle;
		}
		return curAngle;
	}
}
public class MinimapStats : MonoBehaviour
{
	private Texture2D Mask;

	private Texture2D RecentProbes;

	public float reductionFactor = 1f;

	private float mapTexSize;

	private void Start()
	{
		Mask = PlayerStats.stats.levelMap;
		GetComponent<Renderer>().material.SetTexture("_LevelMap", Mask);
		mapTexSize = 0.5f * reductionFactor;
		float num = 1f / reductionFactor;
		float num2 = (1f - 0.5f * num) / 2f;
		GetComponent<Renderer>().material.SetTextureOffset("_LevelMap", new Vector2(num2, num2));
		GetComponent<Renderer>().material.SetTextureScale("_LevelMap", new Vector2(0.5f * num, 0.5f * num));
		RecentProbes = new Texture2D(128, 128, TextureFormat.RGBA32, mipmap: false);
		ClearMemory.AddRuntimeTexture(RecentProbes);
		RecentProbes.filterMode = FilterMode.Point;
		RecentProbes.wrapMode = TextureWrapMode.Clamp;
		GetComponent<Renderer>().material.SetTexture("_RecentProbes", RecentProbes);
		ResetProbes();
		ResetMask();
	}

	private void Update()
	{
		UpdateProbes();
	}

	public void ResetMask(float fVisibility = 0f)
	{
		for (int i = 0; i < Mask.height; i++)
		{
			for (int j = 0; j < Mask.width; j++)
			{
				Color pixel = Mask.GetPixel(j, i);
				pixel.a = fVisibility;
				Mask.SetPixel(j, i, pixel);
			}
		}
		Mask.Apply();
	}

	private void UpdateMask(Point cellPos)
	{
		int num = 64;
		int num2 = 64;
		int num3 = (Mask.width - num) / 2;
		int num4 = (Mask.height - num2) / 2;
		Vector3 vector = CellToWorld(cellPos);
		for (int i = cellPos.Y - 10; i <= cellPos.Y + 10; i++)
		{
			if (i <= 0 || i >= num2 - 1)
			{
				continue;
			}
			for (int j = cellPos.X - 10; j <= cellPos.X + 10; j++)
			{
				if (j > 0 && j < num - 1)
				{
					Point point = new Point(num3 + j, num4 + (num2 - 1 - i));
					Color pixel = Mask.GetPixel(point.X, point.Y);
					float magnitude = (CellToWorld(new Point(j, i)) - vector).magnitude;
					pixel.a = Mathf.Max(pixel.a, Mathf.Lerp(0.4f, 0f, magnitude / 10f));
					Mask.SetPixel(point.X, point.Y, pixel);
				}
			}
		}
		Mask.Apply();
	}

	private Vector3 CellToWorld(Point pos)
	{
		return new Vector3((float)pos.X * 1.5f + 0.75f, 0f, (float)(-pos.Y) * 1.5f - 0.75f);
	}

	private void UpdateMarker(Point markerPos)
	{
		float num = GetComponent<Renderer>().material.GetTextureScale("_Marker").x / 64f * reductionFactor;
		float num2 = (float)(-markerPos.X) * num + 0.5f * num;
		float num3 = (float)(-(63 - markerPos.Y)) * num + 0.5f * num;
		num2 -= (64f - reductionFactor * 64f) * 0.5f * num;
		num3 -= (64f - reductionFactor * 64f) * 0.5f * num;
		GetComponent<Renderer>().material.SetTextureOffset("_Marker", new Vector2(num2, num3));
	}

	public void SetPlayerPos(Point cellPos)
	{
		UpdateMask(cellPos);
		UpdateMarker(cellPos);
	}

	private void ResetProbes()
	{
		for (int i = 0; i < RecentProbes.height; i++)
		{
			for (int j = 0; j < RecentProbes.width; j++)
			{
				RecentProbes.SetPixel(j, i, new Color(0f, 0f, 0f, 0f));
			}
		}
		RecentProbes.Apply();
	}

	public void MarkProbe(int x, int y)
	{
		int num = 64;
		int num2 = 64;
		int num3 = (RecentProbes.width - num) / 2;
		int num4 = (RecentProbes.height - num2) / 2;
		Point point = new Point(num3 + x, num4 + (num2 - 1 - y));
		RecentProbes.SetPixel(point.X, point.Y, new Color(1f, 1f, 1f, 1f));
	}

	public void ApplyProbes()
	{
		RecentProbes.Apply();
	}

	private void UpdateProbes()
	{
		int num = 64;
		int num2 = 64;
		int num3 = (Mask.width - num) / 2;
		int num4 = (Mask.height - num2) / 2;
		Color b = new Color(0f, 0f, 0f, 0f);
		float t = 5f * Time.deltaTime;
		for (int i = 0; i < num2; i++)
		{
			for (int j = 0; j < num; j++)
			{
				Point point = new Point(num3 + j, num4 + (num2 - 1 - i));
				Color pixel = RecentProbes.GetPixel(point.X, point.Y);
				pixel = Color.Lerp(pixel, b, t);
				RecentProbes.SetPixel(point.X, point.Y, pixel);
			}
		}
		RecentProbes.Apply();
	}
}
[RequireComponent(typeof(AudioSource))]
public class MusicVolume : MonoBehaviour
{
	private float baseVolume;

	public float Volume
	{
		get
		{
			return baseVolume;
		}
		set
		{
			baseVolume = value;
			UpdateVolume();
		}
	}

	private void Start()
	{
		baseVolume = GetComponent<AudioSource>().volume;
		UpdateVolume();
	}

	public void UpdateVolume()
	{
		GetComponent<AudioSource>().volume = baseVolume * Config.Audio().musicVolume;
	}
}
[RequireComponent(typeof(InteractionListener))]
public class Book : FSMComponent<Book.States>
{
	public enum States
	{
		Idle,
		PickedUp,
		Reading,
		PageFlip,
		PageFlipBack,
		Closing,
		Returning
	}

	public float posForward = 0.5f;

	public float posUp = 0.5f;

	public float pickedUpRotX = 62f;

	public float pickedUpRotY;

	public float pickedUpRotZ = -90f;

	public Animation anim;

	public AudioClip pickUpSound;

	public AudioClip leaveSound;

	public AudioClip pageFlipSound;

	public PageFlip pageLeft;

	public PageFlip pageRight;

	public PageFlip pageFlip;

	public GUIStyle textStyle;

	public GUIStyle titleStyle;

	public Texture2D[] pagesTest;

	private static RenderTexture[] pages;

	public BookDesc bookDesc;

	private int updatePagesFrom = -1;

	private int pageOffset;

	private InteractionListener listener;

	private Inventory playerInventory;

	private MinimapPosition minimapPos;

	private Vector3 originalPos;

	private Quaternion originalRot;

	private Transform oldParent;

	private float timer;

	private void Start()
	{
		Init(States.Idle);
		listener = GetComponent<InteractionListener>();
		originalPos = base.transform.position;
		originalRot = base.transform.rotation;
		oldParent = null;
		if (pages == null)
		{
			pages = new RenderTexture[4];
			for (int i = 0; i < pages.Length; i++)
			{
				pages[i] = new RenderTexture(512, 512, 24);
			}
		}
		if (!bookDesc)
		{
			BookDesc[] arrItems = Resources.LoadAll<BookDesc>("BookDescs");
			bookDesc = RandomExt.Choice(arrItems);
		}
		bookDesc.Initialize(this);
	}

	private void Idle_Exit()
	{
		playerInventory = GameObject.FindWithTag(Tags.Inventory).GetComponent<Inventory>();
		minimapPos = GameObject.FindWithTag(Tags.Minimap).GetComponent<MinimapPosition>();
		listener.canInteract = false;
		playerInventory.Reorient();
		oldParent = base.transform.parent;
		base.transform.parent = playerInventory.transform;
		anim.Play("Book_Open2");
		timer = anim["Book_Open2"].length - 0.3f;
		Player.GetComponent<PlayerGameController>().BlockMovement(blockRotation: false);
		playerInventory.Block();
		if (pickUpSound != null)
		{
			AudioSource.PlayClipAtPoint(pickUpSound, base.transform.position);
		}
		if (!GameController.Get().UsingGamepad)
		{
			GameObject.FindWithTag(Tags.PlayerTorch).GetComponent<TorchFuel>().btnEnabled = false;
		}
	}

	private void PickedUp_Enter()
	{
		pageLeft.gameObject.SetActive(value: true);
		pageRight.gameObject.SetActive(value: true);
		pageFlip.gameObject.SetActive(value: true);
		updatePagesFrom = 0;
		pageOffset = 0;
		pageLeft.SetPageBack(pages[0]);
		pageFlip.SetPageFront(pages[1]);
		pageFlip.SetPageBack(pages[2]);
		pageRight.SetPageFront(pages[3]);
	}

	private void PickedUp_Update()
	{
		Vector3 b = playerInventory.transform.position + playerInventory.transform.forward * posForward + playerInventory.transform.up * posUp;
		base.transform.position = Vector3.Lerp(base.transform.position, b, Time.deltaTime * 4f);
		Quaternion quaternion = Quaternion.Euler(pickedUpRotX, pickedUpRotY, pickedUpRotZ);
		quaternion = playerInventory.transform.rotation * quaternion;
		base.transform.rotation = Quaternion.Slerp(base.transform.rotation, quaternion, Time.deltaTime * 4f);
		timer -= Time.deltaTime;
		if (timer <= 0f)
		{
			base.State = States.Reading;
		}
		minimapPos.Hide = true;
		if (Input.GetButtonDown("Cancel") || Input.GetButtonDown("Inventory"))
		{
			base.State = States.Closing;
		}
	}

	private void Reading_Update()
	{
		minimapPos.Hide = true;
		if (Input.GetButtonDown("Inventory"))
		{
			base.State = States.Closing;
		}
		if (Input.GetButtonDown("Fire1") || Input.GetButtonDown("NextPage"))
		{
			if (CanFlipPage())
			{
				base.State = States.PageFlip;
			}
			else
			{
				base.State = States.Closing;
			}
		}
		else if ((!GameController.Get().UsingGamepad && Input.GetButtonDown("Cancel")) || Input.GetButtonDown("PrevPage"))
		{
			if (pageOffset > 0)
			{
				base.State = States.PageFlipBack;
			}
			else
			{
				base.State = States.Closing;
			}
		}
		else if (GameController.Get().UsingGamepad && Input.GetButtonDown("Cancel"))
		{
			base.State = States.Closing;
		}
	}

	private void PageFlip_Enter()
	{
		timer = pageFlip.Flip();
		pageRight.SetPageFront(pages[3]);
		if ((bool)pageFlipSound)
		{
			AudioSource.PlayClipAtPoint(pageFlipSound, base.transform.position);
		}
	}

	private void PageFlip_Update()
	{
		timer -= Time.deltaTime;
		if (timer <= 0f)
		{
			base.State = States.Reading;
		}
	}

	private void PageFlip_Exit()
	{
		pageLeft.SetPageBack(pageFlip.GetPageBack());
		pageFlip.SetPageFront(pageRight.GetPageFront());
		pageFlip.Reset();
		Texture texture = pages[0];
		Texture texture2 = pages[1];
		for (int i = 0; i < pages.Length - 2; i++)
		{
			pages[i] = pages[i + 2];
		}
		pages[pages.Length - 2] = (RenderTexture)texture;
		pages[pages.Length - 1] = (RenderTexture)texture2;
		pageFlip.SetPageBack(pages[2]);
		updatePagesFrom = pages.Length - 2;
		pageOffset += 2;
	}

	private void PageFlipBack_Enter()
	{
		updatePagesFrom = 0;
		pageOffset -= 2;
		pageLeft.SetPageBack(pages[0]);
		pageFlip.SetPageFront(pages[1]);
		pageFlip.SetPageBack(pages[2]);
		pageRight.SetPageFront(pages[3]);
		timer = pageFlip.Flip(invert: true);
		if ((bool)pageFlipSound)
		{
			AudioSource.PlayClipAtPoint(pageFlipSound, base.transform.position);
		}
	}

	private void PageFlipBack_Update()
	{
		timer -= Time.deltaTime;
		if (timer <= 0f)
		{
			base.State = States.Reading;
		}
	}

	private void PageFlipBack_Exit()
	{
		pageRight.SetPageFront(pageFlip.GetPageFront());
		pageFlip.Reset();
	}

	private void Closing_Enter()
	{
		Player.GetController().UnblockMovement(unBlockRotation: false);
		playerInventory.Unblock();
		base.transform.parent = oldParent;
		if (leaveSound != null)
		{
			AudioSource.PlayClipAtPoint(leaveSound, base.transform.position);
		}
		anim.Play("Book_Close2");
		timer = 0.9f;
	}

	private void Closing_Update()
	{
		timer -= Time.deltaTime;
		if (timer <= 0f)
		{
			base.State = States.Returning;
		}
	}

	private void Closing_Exit()
	{
		pageLeft.gameObject.SetActive(value: false);
		pageRight.gameObject.SetActive(value: false);
		pageFlip.gameObject.SetActive(value: false);
		if (!GameController.Get().UsingGamepad)
		{
			GameObject.FindWithTag(Tags.PlayerTorch).GetComponent<TorchFuel>().btnEnabled = true;
		}
	}

	private void Returning_Update()
	{
		Vector3 vector = Vector3.Lerp(base.transform.position, originalPos, Time.deltaTime * 2f);
		base.transform.position = vector;
		Quaternion quaternion = Quaternion.Slerp(base.transform.rotation, originalRot, Time.deltaTime * 3f);
		base.transform.rotation = quaternion;
		float num = Quaternion.Angle(quaternion, originalRot);
		if ((vector - originalPos).sqrMagnitude <= 1.0000001E-06f && num <= 1f)
		{
			base.State = States.Idle;
		}
	}

	private void Returning_Exit()
	{
		listener.canInteract = true;
	}

	public void OnPlayerInteraction(InteractionListener listener)
	{
		this.listener = listener;
		if (base.State == States.Idle)
		{
			base.State = States.PickedUp;
		}
	}

	private void OnGUI()
	{
		if (updatePagesFrom < 0 || updatePagesFrom >= pages.Length || Event.current.type != EventType.Repaint)
		{
			return;
		}
		for (int i = updatePagesFrom; i < pages.Length; i++)
		{
			int num = pageOffset + i;
			int num2 = 0;
			BookDesc.BookSection bookSection = bookDesc.sections[num2];
			while (num >= bookSection.firstPage + bookSection.Pages && num2 < bookDesc.sections.Length - 1)
			{
				bookSection = bookDesc.sections[++num2];
			}
			num -= bookSection.firstPage;
			string textPage = ((num >= bookSection.textPages.Length) ? string.Empty : bookSection.textPages[num]);
			FillPageContents(pages[i], textPage, bookSection.image, (bookSection.type != BookDesc.BookSection.SectionType.Title) ? textStyle : titleStyle);
		}
		updatePagesFrom = pages.Length;
	}

	private bool CanFlipPage()
	{
		BookDesc.BookSection bookSection = bookDesc.sections[bookDesc.sections.Length - 1];
		int num = bookSection.firstPage + bookSection.Pages;
		return pageOffset + 2 < num;
	}

	private void FillPageContents(RenderTexture page, string textPage, Texture image, GUIStyle style)
	{
		RenderTexture active = RenderTexture.active;
		Matrix4x4 matrix = GUI.matrix;
		Font font = GUI.skin.font;
		float x = (float)Screen.width / 512f;
		float y = (float)Screen.height / 512f;
		GUI.matrix = Matrix4x4.TRS(Vector3.zero, Quaternion.identity, new Vector3(x, y, 1f));
		RenderTexture.active = page;
		GL.Clear(clearDepth: false, clearColor: true, new Color(0f, 0f, 0f, 0f));
		if (image != null)
		{
			GUI.Box(new Rect(0f, 0f, 512f, 512f), image);
		}
		GUI.Box(new Rect(0f, 0f, 512f, 512f), textPage, style);
		RenderTexture.active = active;
		GUI.matrix = matrix;
		GUI.skin.font = font;
	}
}
public class BookDesc : ScriptableObject
{
	[Serializable]
	public class BookSection
	{
		public enum SectionType
		{
			Content,
			Title,
			BlankPage
		}

		public SectionType type;

		public string fullTextId = "BOOK_TEST";

		public Texture image;

		[NonSerialized]
		public string[] textPages;

		[NonSerialized]
		public int firstPage;

		public int Pages => textPages.Length;
	}

	public BookSection[] sections;

	[NonSerialized]
	public bool initialized;

	public void Initialize(Book book)
	{
		if (initialized)
		{
			return;
		}
		int num = 0;
		BookSection[] array = sections;
		foreach (BookSection bookSection in array)
		{
			bookSection.firstPage = num;
			if (bookSection.type == BookSection.SectionType.BlankPage)
			{
				bookSection.textPages = new string[1];
			}
			else
			{
				SplitTextContent(bookSection, book);
			}
			num += bookSection.Pages;
		}
		initialized = true;
	}

	private void SplitTextContent(BookSection section, Book book)
	{
		string text = Translate.Get(section.fullTextId);
		GUIStyle gUIStyle = ((section.type != BookSection.SectionType.Title) ? book.textStyle : book.titleStyle);
		float num = gUIStyle.CalcHeight(new GUIContent(text), 512f);
		int num2 = Mathf.CeilToInt(num / 512f);
		num += (float)(num2 * (gUIStyle.padding.top + gUIStyle.padding.bottom));
		num2 = Mathf.CeilToInt(num / 512f);
		section.textPages = new string[num2];
		int num3 = 0;
		for (int i = 0; i < num2 - 1; i++)
		{
			while (i > 0 && num3 < text.Length && text[num3] == '\n')
			{
				num3++;
			}
			int num4 = num3;
			while (num4 < text.Length)
			{
				int num5 = num4;
				int j;
				for (j = num5; j < text.Length && text[j] != ' ' && text[j] != '\n'; j++)
				{
				}
				string text2 = text.Substring(num5, j - num5 + 1);
				string text3 = section.textPages[i] + text2;
				float num6 = gUIStyle.CalcHeight(new GUIContent(text3), 512f);
				if (num6 <= 512f)
				{
					section.textPages[i] = text3;
					num4 = j + 1;
					continue;
				}
				break;
			}
			num3 = num4;
		}
		if (section.textPages.Length >= 1)
		{
			section.textPages[section.textPages.Length - 1] = text.Substring(num3, text.Length - num3);
		}
	}
}
public class DistanceDestroyer : MonoBehaviour
{
	public float primeDistance = 2.5f;

	public float destructionDistance = 3.5f;

	public float destructionDistanceMax = 15f;

	private bool primed;

	private void Update()
	{
		float sqrMagnitude = (Player.GetGroundPos() - base.transform.position.ToGround()).sqrMagnitude;
		if (!primed && sqrMagnitude <= primeDistance * primeDistance)
		{
			primed = true;
		}
		else if (primed && sqrMagnitude >= destructionDistance * destructionDistance)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
		else if (sqrMagnitude >= destructionDistanceMax * destructionDistanceMax)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}
}
public class Door : MonoBehaviour
{
	public float OpenDistance = 2f;

	public bool IsOpen;

	public bool IsDestroyed;

	private bool invertedOpen;

	private bool ignoreInteractions;

	public Transform playerLook;

	public AudioClip OpenSound;

	public AudioClip CloseSound;

	private bool playSoundOnClose;

	public GameObject BashEffect;

	public GameObject BashSmallEffect;

	public AudioClip BashScream;

	public AudioClip BashDestroy;

	public AudioClip CreakSound;

	public GameObject WindEffect;

	private Collider safetyCollider;

	private Transform doorObj;

	private bool inCollisionOpen;

	private bool playerContact;

	private BoxCollider mainCollider;

	private Animation animation;

	private void Start()
	{
		IsOpen = false;
		playerLook = Player.GetLook();
		invertedOpen = false;
		safetyCollider = null;
		animation = GetComponent<Animation>();
		ignoreInteractions = false;
		playSoundOnClose = false;
		doorObj = base.transform.Find("wall_02_c/door_01_c");
		Serializer.Add(this, OnSerialize, OnDeserialize);
	}

	private void OnSerialize(BinaryWriter writer)
	{
		writer.Write(IsOpen);
		writer.Write(invertedOpen);
		bool value = false;
		Unlockable componentInChildren = base.gameObject.GetComponentInChildren<Unlockable>();
		if (componentInChildren != null)
		{
			value = componentInChildren.Locked;
		}
		writer.Write(value);
	}

	private void OnDeserialize(BinaryReader reader)
	{
		bool flag = reader.ReadBoolean();
		bool flag2 = reader.ReadBoolean();
		bool locked = reader.ReadBoolean();
		if (flag && !IsOpen)
		{
			string text = ((!flag2) ? "DoorAnimOpen" : "DoorAnimOpen_Inv");
			animation.Play(text);
			animation[text].normalizedTime = 0.9f;
			if (safetyCollider != null)
			{
				safetyCollider.enabled = false;
			}
		}
		IsOpen = flag;
		invertedOpen = flag2;
		Unlockable componentInChildren = base.gameObject.GetComponentInChildren<Unlockable>();
		if (componentInChildren != null)
		{
			componentInChildren.Locked = locked;
		}
	}

	public void OnCollision(GameObject obj, bool isPlayer = false, bool isFront = true, BoxCollider collider = null)
	{
		if (isPlayer)
		{
			playerContact = true;
		}
		if (!IsOpen && animation.isPlaying && (!isPlayer || ((isFront || !invertedOpen) && (!isFront || invertedOpen))))
		{
			playSoundOnClose = false;
			IsOpen = true;
			animation.Stop();
			ignoreInteractions = true;
			bool flag = false;
			if (isPlayer)
			{
				flag = Player.GetController().isRunning;
			}
			if (collider != null)
			{
				mainCollider = collider;
				mainCollider.size = new Vector3(mainCollider.size.x, mainCollider.size.y, mainCollider.size.z * 0.5f);
			}
			inCollisionOpen = true;
		}
	}

	private void FixedUpdate()
	{
		if (inCollisionOpen)
		{
			float y = doorObj.localRotation.eulerAngles.y;
			float num = ((!invertedOpen) ? 84.02932f : 275.97067f);
			float num2 = Interpolate.Approach(y, num, Time.deltaTime * 10f);
			bool flag = Mathf.Abs(num - num2) <= 0.5f;
			doorObj.localEulerAngles = new Vector3(doorObj.localRotation.eulerAngles.x, num2, doorObj.localRotation.eulerAngles.z);
			if (flag)
			{
				inCollisionOpen = false;
			}
		}
		if (!inCollisionOpen && !playerContact && (ignoreInteractions || mainCollider != null))
		{
			if (mainCollider != null)
			{
				mainCollider.size = new Vector3(mainCollider.size.x, mainCollider.size.y, mainCollider.size.z * 2f);
				mainCollider = null;
			}
			ignoreInteractions = false;
		}
		playerContact = false;
	}

	private void SetState(bool bOpen, bool sound = true, Transform actor = null)
	{
		if (bOpen == IsOpen)
		{
			return;
		}
		IsOpen = bOpen;
		if (bOpen)
		{
			invertedOpen = actor != null && !IsInFront(actor.position);
			animation.Play((!invertedOpen) ? "DoorAnimOpen" : "DoorAnimOpen_Inv");
			if (safetyCollider != null)
			{
				safetyCollider.enabled = false;
			}
			if (sound)
			{
				AudioSource.PlayClipAtPoint(OpenSound, base.transform.position + Vector3.up);
			}
		}
		else
		{
			animation.Play((!invertedOpen) ? "DoorAnimClose" : "DoorAnimClose_Inv");
			playSoundOnClose = sound;
		}
	}

	public void PlaySoundClose()
	{
		if (playSoundOnClose)
		{
			AudioSource.PlayClipAtPoint(CloseSound, base.transform.position + Vector3.up);
		}
		playSoundOnClose = false;
	}

	public void OnEndCloseAnimation()
	{
		if (safetyCollider != null)
		{
			safetyCollider.enabled = true;
		}
	}

	public void Open(Transform actor = null)
	{
		if (UnityEngine.Random.value <= 0.05f && !Player.IsSafe() && Player.Get().transform == actor)
		{
			OpenAndCloseFast(actor);
			return;
		}
		Unlockable componentInChildren = base.gameObject.GetComponentInChildren<Unlockable>();
		if (componentInChildren != null)
		{
			componentInChildren.Locked = false;
		}
		SetState(bOpen: true, sound: true, actor);
	}

	public void Close()
	{
		SetState(bOpen: false);
	}

	public void Toggle(Transform actor = null)
	{
		if (!animation.isPlaying && !ignoreInteractions)
		{
			SetState(!IsOpen, sound: true, actor);
		}
	}

	public void Bash(bool small = false)
	{
		Vector3 toPosGround = Player.GetToPosGround(base.transform.position);
		toPosGround.Normalize();
		GameObject obj = UnityEngine.Object.Instantiate(rotation: Quaternion.LookRotation((!(Vector3.Dot(toPosGround, base.transform.right) < Vector3.Dot(toPosGround, -base.transform.right))) ? base.transform.right : (-base.transform.right), Vector3.up), original: (!small) ? BashEffect : BashSmallEffect, position: base.transform.position + Vector3.up * 1.3f);
		UnityEngine.Object.Destroy(obj, 3f);
	}

	public void PlayBashWithMonster()
	{
		StartCoroutine(BashWithMonster());
	}

	private IEnumerator BashWithMonster()
	{
		Bash();
		yield return new WaitForSeconds(0.1f);
		AudioSource.PlayClipAtPoint(BashScream, base.transform.position + Vector3.up);
		yield return new WaitForSeconds(0.2f);
		Bash();
	}

	public void PlayBashAndDestroy(bool bDoDestroy = true)
	{
		StartCoroutine(BashAndDestroy(bDoDestroy));
	}

	private IEnumerator BashAndDestroy(bool bDoDestroy)
	{
		Bash();
		yield return new WaitForSeconds(0.8f);
		Bash();
		yield return new WaitForSeconds(0.4f);
		Bash();
		yield return new WaitForSeconds(0.8f);
		Bash();
		if (bDoDestroy)
		{
			yield return new WaitForSeconds(1.1f);
			Bash();
			AudioSource.PlayClipAtPoint(BashDestroy, base.transform.position + Vector3.up);
			Transform doorObj = base.transform.Find("wall_02_c/door_01_c");
			UnityEngine.Object.Destroy(doorObj.gameObject);
			IsOpen = true;
			IsDestroyed = true;
			if (safetyCollider != null)
			{
				safetyCollider.enabled = false;
			}
		}
	}

	public void PlayBashAndOpen(bool bDoOpen = true, Transform actor = null)
	{
		StartCoroutine(BashAndOpen(bDoOpen, actor));
	}

	private IEnumerator BashAndOpen(bool bDoOpen, Transform actor)
	{
		Bash();
		yield return new WaitForSeconds(0.8f);
		Bash();
		yield return new WaitForSeconds(0.4f);
		Bash();
		yield return new WaitForSeconds(0.8f);
		Bash();
		if (bDoOpen)
		{
			OpenFast(actor);
		}
	}

	public void Creak()
	{
		if (IsOpen && !invertedOpen)
		{
			animation.Play((!invertedOpen) ? "DoorAnimCreak" : "DoorAnimCreak_Inv");
			AudioSource.PlayClipAtPoint(CreakSound, base.transform.position);
		}
	}

	public void OpenWithCreak(Transform actor = null)
	{
		if (IsOpen)
		{
			return;
		}
		Unlockable componentInChildren = base.gameObject.GetComponentInChildren<Unlockable>();
		if (componentInChildren != null)
		{
			if (componentInChildren.IsTutorial)
			{
				return;
			}
			componentInChildren.Locked = false;
		}
		IsOpen = true;
		invertedOpen = actor != null && !IsInFront(actor.position);
		animation.Play((!invertedOpen) ? "DoorAnimOpenSlow" : "DoorAnimOpenSlow_Inv");
		AudioSource.PlayClipAtPoint(CreakSound, base.transform.position);
		if (safetyCollider != null)
		{
			safetyCollider.enabled = false;
		}
	}

	public void OpenFast(Transform actor = null)
	{
		if (!IsOpen)
		{
			Unlockable componentInChildren = base.gameObject.GetComponentInChildren<Unlockable>();
			if (componentInChildren != null)
			{
				componentInChildren.Locked = false;
			}
			IsOpen = true;
			invertedOpen = actor != null && !IsInFront(actor.position);
			animation.Play((!invertedOpen) ? "DoorAnimOpenForce" : "DoorAnimOpenForce_Inv");
			if (safetyCollider != null)
			{
				safetyCollider.enabled = false;
			}
		}
	}

	public void CloseFast()
	{
		if (IsOpen)
		{
			animation.Stop();
			playSoundOnClose = false;
			IsOpen = false;
			Transform transform = base.transform.Find("wall_02_c/door_01_c");
			iTween.RotateTo(transform.gameObject, iTween.Hash("y", 0f, "islocal", true, "speed", 100f, "easetype", iTween.EaseType.easeInCubic, "oncomplete", "CloseFast_End", "oncompletetarget", base.gameObject));
		}
	}

	private void CloseFast_End()
	{
		Bash(small: true);
	}

	public void OpenAndCloseFast(Transform actor)
	{
		StartCoroutine(OpenAndCloseFast_co(actor));
	}

	private IEnumerator OpenAndCloseFast_co(Transform actor)
	{
		SetState(bOpen: true, sound: true, actor);
		AddWind();
		yield return new WaitForSeconds(1.2f);
		if (UnityEngine.Random.value <= 0.2f)
		{
			GameObject.FindWithTag(Tags.PlayerTorch).GetComponent<TorchLight>().FlickerOut(turnOff: true);
		}
		else if (UnityEngine.Random.value <= 0.8f)
		{
			GameObject.FindWithTag(Tags.PlayerTorch).GetComponent<TorchLight>().FlickerOut();
		}
		CloseFast();
	}

	public void CloseFastWithWind()
	{
		StartCoroutine(CloseFastWithWind_co());
	}

	private IEnumerator CloseFastWithWind_co()
	{
		AddWind();
		yield return new WaitForSeconds(0.5f);
		CloseFast();
	}

	public void OpenWithWind(Transform actor = null)
	{
		StartCoroutine(OpenWithWind_co(actor));
	}

	private IEnumerator OpenWithWind_co(Transform actor)
	{
		Unlockable unlockable = base.gameObject.GetComponentInChildren<Unlockable>();
		if (unlockable != null)
		{
			if (unlockable.IsTutorial)
			{
				yield break;
			}
			unlockable.Locked = false;
		}
		AddWind(reverse: true);
		yield return new WaitForSeconds(0.5f);
		SetState(bOpen: true, sound: false, actor);
	}

	public void SetLocked(bool locked = true, Unlockable.Difficulty difLevel = Unlockable.Difficulty.Uninitialized)
	{
		Unlockable componentInChildren = base.gameObject.GetComponentInChildren<Unlockable>();
		if (componentInChildren != null)
		{
			if (componentInChildren.difficultyLevel == Unlockable.Difficulty.Uninitialized)
			{
				componentInChildren.InitLocked(difLevel);
			}
			componentInChildren.Locked = locked;
		}
	}

	private void AddWind(bool reverse = false)
	{
		Vector3 vector = base.transform.right;
		if (reverse)
		{
			vector = -vector;
		}
		UnityEngine.Object.Instantiate(WindEffect, base.transform.position - vector * 2.5f + Vector3.up * 0.5f, Quaternion.LookRotation(vector, Vector3.up));
	}

	public bool IsInFront(Vector3 objPos)
	{
		Vector3 right = base.transform.right;
		Vector3 vec = objPos - base.transform.position;
		vec = vec.GroundNormalize();
		float num = Vector3.Dot(right, vec);
		return num >= 0f;
	}
}
public class DoorCollision : MonoBehaviour
{
	public Door parentDoor;

	public bool buildTrigger = true;

	private BoxCollider mainCollider;

	private BoxCollider triggerColliderFront;

	private BoxCollider triggerColliderBack;

	private void Start()
	{
		Transform parent = base.transform;
		while (parent != null && parentDoor == null)
		{
			parentDoor = parent.GetComponent<Door>();
			parent = parent.parent;
		}
		if (parentDoor == null)
		{
			base.enabled = false;
		}
		else if (buildTrigger)
		{
			BuildTriggerCollider();
		}
	}

	public void OnPlayerCollision(GameObject obj, Collider trigger)
	{
		parentDoor.OnCollision(obj, isPlayer: true, trigger == triggerColliderFront, mainCollider);
	}

	private void OnCollisionEnter(Collision collision)
	{
		parentDoor.OnCollision(collision.gameObject);
	}

	private void OnCollisionStay(Collision collision)
	{
		if (collision.gameObject != Player.Get())
		{
			parentDoor.OnCollision(collision.gameObject);
		}
	}

	private void OnTriggerStay(Collider other)
	{
		if (other.gameObject.CompareTag(Tags.Ghost) || other.gameObject.CompareTag(Tags.Creature))
		{
			parentDoor.OnCollision(other.gameObject);
		}
	}

	private void BuildTriggerCollider()
	{
		GameObject gameObject = new GameObject();
		gameObject.name = "DoorTrigger";
		gameObject.tag = Tags.DoorTrigger;
		gameObject.layer = LayerMask.NameToLayer("Ignore Raycast");
		gameObject.transform.parent = base.transform;
		gameObject.transform.localPosition = Vector3.zero;
		gameObject.transform.localRotation = Quaternion.identity;
		mainCollider = GetComponent<BoxCollider>();
		triggerColliderFront = gameObject.AddComponent<BoxCollider>();
		triggerColliderFront.isTrigger = true;
		triggerColliderFront.center = mainCollider.center;
		triggerColliderFront.size = new Vector3(mainCollider.size.x + 0.05f, mainCollider.size.y, mainCollider.size.z * 3f);
		triggerColliderBack = gameObject.AddComponent<BoxCollider>();
		triggerColliderBack.isTrigger = true;
		triggerColliderBack.center = mainCollider.center;
		triggerColliderBack.size = triggerColliderFront.size;
		triggerColliderFront.center += new Vector3(-0.05f, 0f, triggerColliderFront.size.z / 2f);
		triggerColliderBack.center += new Vector3(-0.05f, 0f, (0f - triggerColliderBack.size.z) / 2f);
		Rigidbody rigidbody = gameObject.AddComponent<Rigidbody>();
		rigidbody.isKinematic = true;
		rigidbody.interpolation = RigidbodyInterpolation.Interpolate;
		DoorCollision doorCollision = gameObject.AddComponent<DoorCollision>();
		doorCollision.parentDoor = parentDoor;
		doorCollision.buildTrigger = false;
	}
}
[RequireComponent(typeof(InteractionListener))]
public class Examinable : FSMComponent<Examinable.States>
{
	public enum States
	{
		Idle,
		PickedUp,
		Returning
	}

	public float highlightDistance = 0.6f;

	public AudioClip pickUpSound;

	public AudioClip leaveSound;

	public string textID;

	public TextLabel descLabelPrefab;

	private InteractionListener listener;

	private Inventory playerInventory;

	private MinimapPosition minimapPos;

	private Vector3 originalPos;

	private Quaternion originalRot;

	private Transform oldParent;

	private Vector3 deltaCenter;

	private static TextLabel textLabel;

	private string descriptionText;

	private void Start()
	{
		Init(States.Idle);
		listener = GetComponent<InteractionListener>();
		originalPos = base.transform.position;
		originalRot = base.transform.rotation;
		oldParent = null;
		deltaCenter = Vector3.zero;
		textLabel = null;
		int num = 0;
		string text = textID;
		text.ToUpper();
		while (Translate.Check("OBJ_" + text + "_" + num))
		{
			num++;
		}
		if (num >= 1)
		{
			int num2 = UnityEngine.Random.Range(0, num);
			text = "OBJ_" + textID + "_" + num2;
			text.ToUpper();
			descriptionText = Translate.Get(text);
		}
	}

	private void PickedUp_Enter()
	{
		playerInventory = GameObject.FindWithTag(Tags.Inventory).GetComponent<Inventory>();
		minimapPos = GameObject.FindWithTag(Tags.Minimap).GetComponent<MinimapPosition>();
		listener.canInteract = false;
		playerInventory.Reorient();
		oldParent = base.transform.parent;
		base.transform.parent = playerInventory.transform;
		if (textLabel == null)
		{
			textLabel = UnityEngine.Object.Instantiate(descLabelPrefab);
			textLabel.transform.parent = playerInventory.transform;
		}
		else
		{
			textLabel.gameObject.SetActive(value: true);
		}
		textLabel.Text = descriptionText;
		Vector3 vector = playerInventory.transform.position + playerInventory.transform.forward * highlightDistance + playerInventory.transform.up * 0.4f;
		textLabel.transform.position = vector;
		textLabel.FadeInDelayed(2f, 0.45f);
		Vector3 position = Player.GetLook().position;
		Vector3 forward = position - vector;
		forward.Normalize();
		Quaternion quaternion = Quaternion.LookRotation(forward, Vector3.up);
		Quaternion quaternion2 = Quaternion.AngleAxis(90f, Vector3.right);
		textLabel.transform.rotation = quaternion * quaternion2;
		Renderer[] componentsInChildren = GetComponentsInChildren<Renderer>();
		deltaCenter = Vector3.zero;
		if (componentsInChildren.Length > 0)
		{
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				deltaCenter += componentsInChildren[i].bounds.center;
			}
			deltaCenter /= (float)componentsInChildren.Length;
			deltaCenter = base.transform.InverseTransformPoint(deltaCenter);
		}
		Player.GetController().BlockMovement(blockRotation: false);
		playerInventory.Block();
		if (pickUpSound != null)
		{
			AudioSource.PlayClipAtPoint(pickUpSound, base.transform.position);
		}
	}

	private void PickedUp_Update()
	{
		Vector3 vector = base.transform.TransformPoint(deltaCenter) - base.transform.position;
		Vector3 b = playerInventory.transform.position + playerInventory.transform.forward * highlightDistance + playerInventory.transform.up * 0.15f;
		base.transform.position = Vector3.Lerp(base.transform.position + vector, b, Time.deltaTime * 4f) - vector;
		float num = 0f;
		float num2 = 0f;
		num = Input.GetAxis("Horizontal") * 140f * Time.deltaTime;
		num2 = Input.GetAxis("Vertical") * 140f * Time.deltaTime;
		Vector3 axis = playerInventory.transform.TransformDirection(new Vector3(1f, 0f, 0f));
		Vector3 axis2 = base.transform.TransformDirection(new Vector3(0f, 1f, 0f));
		base.transform.RotateAround(base.transform.position + vector, axis2, num);
		base.transform.RotateAround(base.transform.position + vector, axis, num2);
		minimapPos.Hide = true;
		if (InputExt.GetButtonDown(InputExt.Button.Action) || InputExt.GetButtonDown(InputExt.Button.Cancel) || InputExt.GetButtonDown(InputExt.Button.Inventory))
		{
			base.State = States.Returning;
		}
	}

	private void PickedUp_Exit()
	{
		textLabel.FadeOut(8f, disableOnFadeOut: true);
		Player.GetController().UnblockMovement(unBlockRotation: false);
		playerInventory.Unblock();
		base.transform.parent = oldParent;
		if (leaveSound != null)
		{
			AudioSource.PlayClipAtPoint(leaveSound, base.transform.position);
		}
	}

	private void Returning_Update()
	{
		Vector3 vector = Vector3.Lerp(base.transform.position, originalPos, Time.deltaTime * 4f);
		base.transform.position = vector;
		Quaternion quaternion = Quaternion.Slerp(base.transform.rotation, originalRot, Time.deltaTime * 6f);
		base.transform.rotation = quaternion;
		float num = Quaternion.Angle(quaternion, originalRot);
		if ((vector - originalPos).sqrMagnitude <= 1.0000001E-06f && num <= 1f)
		{
			base.State = States.Idle;
		}
	}

	private void Returning_Exit()
	{
		listener.canInteract = true;
	}

	public void OnPlayerInteraction(InteractionListener listener)
	{
		this.listener = listener;
		if (base.State == States.Idle)
		{
			base.State = States.PickedUp;
		}
	}
}
public class ExitDoor : MonoBehaviour
{
	public Light exitLight;

	public Collider exitTrigger;

	public AudioClip openSound;

	public string openAnim = "DoorAnimOpen_Inv";

	private Inventory inventory;

	private LayerMask playerMask;

	private void Start()
	{
		exitLight.enabled = false;
		exitTrigger.enabled = false;
		inventory = Player.Get().GetComponentInChildren<Inventory>();
		playerMask = LayerMaskExtensions.NamesToMask("Player");
		StartCoroutine(Wait_co());
	}

	private IEnumerator Wait_co()
	{
		do
		{
			yield return new WaitForSeconds(0.2f);
		}
		while (!inventory.HasMetaItems());
		exitLight.enabled = true;
		exitTrigger.enabled = true;
		GetComponent<Animation>().Play(openAnim);
		if (openSound != null)
		{
			AudioSource.PlayClipAtPoint(openSound, exitLight.transform.position);
		}
		Map.Get().At(base.transform.position).Occupied = true;
		float targetIntensity = exitLight.intensity;
		exitLight.intensity = 0f;
		float progress = 0f;
		bool pausedDoor = false;
		while (progress <= 1f)
		{
			if (progress >= 0.35f && !pausedDoor)
			{
				pausedDoor = true;
				if (!CheckDoorClear())
				{
					StartCoroutine(Pause_Anim());
				}
			}
			progress = Mathf.Clamp01(progress + Time.deltaTime * 0.5f);
			exitLight.intensity = Interpolate.EaseInOut(0f, targetIntensity, progress);
			yield return 0;
		}
	}

	private IEnumerator Pause_Anim()
	{
		GetComponent<Animation>()[openAnim].speed = 0f;
		bool isClear = false;
		while (!isClear)
		{
			isClear = CheckDoorClear();
			yield return new WaitForSeconds(0.2f);
		}
		GetComponent<Animation>()[openAnim].speed = 1f;
	}

	private bool CheckDoorClear()
	{
		Point point = Map.Get().WorldToCell(Player.Get().transform.position);
		Point point2 = Map.Get().WorldToCell(base.transform.position);
		bool flag = point != point2;
		if (flag)
		{
			flag = Physics.OverlapSphere(base.transform.position, 1f, playerMask).Length == 0;
			DebugExt.DrawSphere(base.transform.position, Color.red, 1f, 0.2f);
		}
		return flag;
	}
}
public class FrightLight : MonoBehaviour
{
	private VisibilityProbe probe;

	private Transform playerLook;

	private bool triggered;

	private float maxIntensity;

	private float currentIntensity;

	private void Start()
	{
		GetComponent<Light>().enabled = false;
		maxIntensity = GetComponent<Light>().intensity;
		GetComponent<Light>().intensity = 0f;
		playerLook = GameObject.FindWithTag(Tags.LookDirection).transform;
		probe = Map.Get().At(base.transform.position).Probe;
	}

	private void Update()
	{
		if (!triggered && probe.IsVisible)
		{
			Vector3 forward = playerLook.forward;
			forward.Normalize();
			Vector3 down = Vector3.down;
			down.Normalize();
			float num = Vector3.Angle(forward, down);
			if (num <= 45f && Vector3Ext.GroundVector(playerLook.position, base.transform.position).sqrMagnitude <= 0.36f && (!Physics.Linecast(playerLook.position, base.transform.position, out var hitInfo) || Utils.IsAncestor(base.transform, hitInfo.collider.transform)))
			{
				triggered = true;
				GetComponent<Light>().enabled = true;
				StartCoroutine(Fright_co());
			}
		}
		if (GetComponent<Light>().enabled)
		{
			GetComponent<Light>().intensity = Interpolate.Approach(GetComponent<Light>().intensity, currentIntensity, Time.deltaTime * 4f);
		}
	}

	private IEnumerator Fright_co()
	{
		yield return new WaitForSeconds(1.2f);
		currentIntensity = maxIntensity;
		SpookSounds spooks = Player.GetComponent<SpookSounds>();
		spooks.PlayScare();
		yield return new WaitForSeconds(1f);
		currentIntensity = 0f;
	}
}
public class HighlightTest : MonoBehaviour
{
}
public class InteractionListener : MonoBehaviour
{
	public bool highlight = true;

	public HighlightEffect highlightFX;

	public Color highlightColor1 = new Color(1f, 0.92f, 0.016f, 1f);

	public Color highlightColor2 = new Color(1f, 0.92f, 0.116f, 0.5f);

	public float highlightFreq = 0.55f;

	public bool singleUse;

	public float distance = 1.5f;

	public LayerMask layerMask;

	private bool visible = true;

	protected Transform playerLook;

	private Vector3 colliderCenter;

	private bool selected;

	private Color curHighlightColor;

	public bool canInteract = true;

	private static Collider[] cachedColliders = new Collider[8];

	protected void Awake()
	{
		if (highlight && highlightFX == null)
		{
			highlightFX = base.gameObject.AddComponent<HighlightEffect>();
		}
		curHighlightColor = new Color(highlightColor1.r, highlightColor1.g, highlightColor1.b, 0f);
		layerMask = LayerMaskExtensions.Create("Default", "TransparentFX", "LightCaster", "Collectable", "Prop", "StaticGeometry");
	}

	protected void Start()
	{
		Collider componentInChildren = GetComponentInChildren<Collider>();
		if (componentInChildren != null)
		{
			colliderCenter = componentInChildren.bounds.center;
		}
		else
		{
			colliderCenter = base.transform.position;
		}
		colliderCenter -= base.transform.position;
	}

	protected void Update()
	{
		if (!visible)
		{
			return;
		}
		playerLook = Player.GetLook(interaction: true);
		Vector3 vector = playerLook.position - (base.transform.position + colliderCenter);
		bool flag = false;
		if (canInteract && vector.sqrMagnitude <= distance * distance)
		{
			Collider component = GetComponent<Collider>();
			bool flag2 = false;
			if (Physics.Raycast(playerLook.position, playerLook.forward, out var hitInfo, distance, layerMask) && (hitInfo.collider == component || hitInfo.collider.transform.parent == base.transform))
			{
				flag2 = true;
			}
			else
			{
				int num = Physics.OverlapSphereNonAlloc(playerLook.position, 0.02f, cachedColliders, layerMask);
				for (int i = 0; i < num; i++)
				{
					if (cachedColliders[i] == component || cachedColliders[i].transform.parent == base.transform)
					{
						flag2 = true;
						break;
					}
				}
			}
			if (flag2)
			{
				flag = true;
				Player.GetMinimapPos().Hide = true;
				OnHighlight();
			}
		}
		if ((bool)highlightFX)
		{
			if (flag)
			{
				Color b = Color.Lerp(highlightColor1, highlightColor2, 0.5f * Mathf.Sin(Time.realtimeSinceStartup * highlightFreq * (float)Math.PI * 2f) + 0.5f);
				Color color = Color.Lerp(curHighlightColor, b, Time.deltaTime * 8f);
				curHighlightColor = color;
				highlightFX.FadeIn();
			}
			else
			{
				highlightFX.FadeOut();
			}
		}
		if (flag)
		{
			if (InputExt.GetButtonDown(InputExt.Button.Action) && OnInteraction() && singleUse)
			{
				canInteract = false;
			}
		}
		else if (selected && (bool)highlightFX)
		{
			highlightFX.FadeOut();
		}
		selected = flag;
	}

	private void OnBecameVisible()
	{
		visible = true;
	}

	private void OnBecameInvisible()
	{
		visible = false;
		if ((bool)highlightFX)
		{
			highlightFX.FadeOut();
			curHighlightColor = new Color(highlightColor1.r, highlightColor1.g, highlightColor1.b, 0f);
		}
	}

	protected virtual bool OnInteraction()
	{
		base.gameObject.SendMessage("OnPlayerInteraction", this, SendMessageOptions.DontRequireReceiver);
		return true;
	}

	protected virtual void OnHighlight()
	{
	}
}
public class InteractiveLightEx : ProgressInteraction
{
	public bool lightOn = true;

	public AudioClip lightSound;

	private TorchLight torchLight;

	private ParticleSystem[] particles;

	public bool endlessFuel;

	public float fuelTime;

	public bool invulnerable;

	public Renderer[] illuminatedRenderers;

	private List<Pair<Material, float>> illuminatedMaterials;

	private new void Start()
	{
		base.Start();
		torchLight = GetComponentInChildren<TorchLight>();
		particles = GetComponentsInChildren<ParticleSystem>();
		if (!torchLight)
		{
			Debug.LogError("No TorchLight component in InteractiveLight!");
			UnityEngine.Object.Destroy(this);
			return;
		}
		illuminatedMaterials = new List<Pair<Material, float>>();
		for (int i = 0; i < illuminatedRenderers.Length; i++)
		{
			Material[] materials = illuminatedRenderers[i].materials;
			foreach (Material material in materials)
			{
				if (material.HasProperty("_EmissionIntensity"))
				{
					illuminatedMaterials.Add(new Pair<Material, float>(material, material.GetFloat("_EmissionIntensity")));
				}
			}
		}
		Room room = Map.Get().At(base.transform.position).Room;
		if (room != null)
		{
			if (room.Safe)
			{
				lightOn = UnityEngine.Random.value <= 0.9f;
			}
			else
			{
				lightOn = UnityEngine.Random.value <= 0.35f;
			}
			room.lights.Add(this);
		}
		else
		{
			lightOn = UnityEngine.Random.value <= 0.025f;
		}
		if (invulnerable)
		{
			lightOn = true;
		}
		PropInfo component = GetComponent<PropInfo>();
		if (component != null && component.CheckTag("on"))
		{
			lightOn = true;
		}
		else if (component != null && component.CheckTag("off"))
		{
			lightOn = false;
		}
		if (!lightOn)
		{
			torchLight.factor = 0f;
			SetParticlesEmission(enabled: false);
			endlessFuel = false;
		}
		else
		{
			torchLight.factor = 1f;
			SetParticlesEmission(enabled: true);
			endlessFuel = true;
		}
		fuelTime = 0f;
	}

	private new void Update()
	{
		base.Update();
		if (!endlessFuel && !invulnerable)
		{
			fuelTime -= Time.deltaTime;
			if (fuelTime <= 0f)
			{
				TurnOff();
			}
		}
		needsProgress = !lightOn;
		torchLight.factor = iTween.FloatUpdate(torchLight.factor, (!lightOn) ? 0f : 1f, 0.5f);
		for (int i = 0; i < illuminatedMaterials.Count; i++)
		{
			Material first = illuminatedMaterials[i].First;
			float second = illuminatedMaterials[i].Second;
			float @float = first.GetFloat("_EmissionIntensity");
			@float += ((!lightOn) ? (-0.25f) : 2f) * Time.deltaTime;
			@float = Mathf.Clamp(@float, 0f, second);
			first.SetFloat("_EmissionIntensity", @float);
		}
	}

	protected override void OnFinishProgress()
	{
		TurnOn(perpetual: false);
	}

	public void TurnOn(bool perpetual = true, bool sound = true)
	{
		lightOn = true;
		SetParticlesEmission(enabled: true);
		if (sound && lightSound != null)
		{
			AudioSource.PlayClipAtPoint(lightSound, torchLight.transform.position);
		}
		if (perpetual)
		{
			perpetual = true;
			fuelTime = 0f;
		}
		else
		{
			perpetual = false;
			fuelTime = GlobalParams.Get().lightParams.fuelDuration;
		}
	}

	public void TurnOff(bool fast = false)
	{
		lightOn = false;
		fuelTime = 0f;
		endlessFuel = false;
		SetParticlesEmission(enabled: false);
		if (fast)
		{
			torchLight.factor = 0f;
		}
	}

	private void OnLightTurnOff(TorchLight tlight)
	{
		TurnOff();
	}

	public void FlickerOut(bool turnOff = false)
	{
		if (lightOn)
		{
			torchLight.FlickerOut(turnOff && !invulnerable, base.gameObject);
		}
	}

	private void SetParticlesEmission(bool enabled)
	{
		for (int i = 0; i < particles.Length; i++)
		{
			particles[i].enableEmission = enabled;
		}
	}

	public TorchLight GetTorchLight()
	{
		return torchLight;
	}

	public Light GetLight()
	{
		return torchLight.GetComponent<Light>();
	}
}
public class KillTrigger : PlayerCollision
{
	public override void OnPlayerCollision(GameObject player)
	{
		player.GetComponent<PlayerGameController>().ApplyAttack(100f, "GAMEOVER_PIT");
	}
}
public class MechActor : MonoBehaviour
{
	public virtual void SetProgress(float progress = 1f, bool instantaneous = false, bool playAudio = true)
	{
	}

	public bool CheckTag(string tag)
	{
		PropInfo component = GetComponent<PropInfo>();
		if (component != null)
		{
			return component.CheckTag(tag);
		}
		return false;
	}
}
public class MechChain : InteractionListener
{
	public bool currentState;

	public float speed = 3f;

	public Transform chainObj;

	public float yDelta;

	private Vector3 offPos;

	private Vector3 onPos;

	public List<MechActor> actors;

	public bool addRoomActors = true;

	public AudioClip useClip;

	private new void Start()
	{
		base.Start();
		offPos = chainObj.localPosition;
		onPos = offPos + Vector3.up * yDelta;
		if (actors == null)
		{
			actors = new List<MechActor>();
		}
		if (addRoomActors)
		{
			List<string> tags = GetComponent<PropInfo>().GetTags();
			Room room = Map.Get().At(base.transform.position).Room;
			if (room != null)
			{
				foreach (PropInfo prop in room.props)
				{
					MechActor component = prop.GetComponent<MechActor>();
					if (!(component != null))
					{
						continue;
					}
					bool flag = true;
					if (tags != null && tags.Count > 0)
					{
						flag = false;
						foreach (string item in tags)
						{
							flag |= component.CheckTag(item);
						}
					}
					if (flag)
					{
						actors.Add(component);
					}
				}
			}
		}
		Serializer.Add(this, OnSerialize, OnDeserialize);
	}

	private void OnSerialize(BinaryWriter writer)
	{
		writer.Write(currentState);
		writer.Write(canInteract);
	}

	private void OnDeserialize(BinaryReader reader)
	{
		bool flag = reader.ReadBoolean();
		canInteract = reader.ReadBoolean();
		if (flag == currentState)
		{
			return;
		}
		foreach (MechActor actor in actors)
		{
			actor.SetProgress((!flag) ? 0f : 1f);
		}
		currentState = flag;
	}

	private new void Update()
	{
		base.Update();
		Vector3 to = ((!currentState) ? offPos : onPos);
		chainObj.localPosition = Interpolate.Approach(chainObj.localPosition, to, Time.deltaTime * speed);
	}

	protected override bool OnInteraction()
	{
		currentState = !currentState;
		foreach (MechActor actor in actors)
		{
			actor.SetProgress((!currentState) ? 0f : 1f);
		}
		GetComponentInChildren<AudioSource>().PlayOneShot(useClip);
		return true;
	}
}
public class MechGate : MechActor
{
	public Transform gate;

	public Vector3 closedPos;

	public Vector3 openPos;

	public float speed = 1f;

	public float progressOpen;

	public AudioClip moveClip;

	public AudioClip fallClip;

	private AudioSource audioSource;

	public bool blockTiles = true;

	private Collider collider;

	public bool disableColliderIfOpen;

	private RoomTemplate.PropMarker propMarker;

	private void Start()
	{
		audioSource = GetComponentInChildren<AudioSource>();
		propMarker = GetComponent<PropInfo>().PropMarker;
		collider = GetComponentInChildren<Collider>();
	}

	private void Update()
	{
		Vector3 to = Interpolate.EaseInOut(closedPos, openPos, progressOpen);
		gate.localPosition = Interpolate.Approach(gate.localPosition, to, Time.deltaTime * speed);
	}

	public override void SetProgress(float progress = 1f, bool instantaneous = false, bool playAudio = true)
	{
		if (progress <= 0f || progress >= 1f)
		{
			if (!instantaneous && playAudio)
			{
				audioSource.PlayOneShot(moveClip);
			}
			SetTilesBlocked(progress <= 0f);
		}
		else if (progress < progressOpen && !instantaneous && playAudio)
		{
			audioSource.PlayOneShot(fallClip);
		}
		progressOpen = progress;
		if (instantaneous)
		{
			gate.localPosition = Interpolate.EaseInOut(closedPos, openPos, progressOpen);
		}
	}

	private void SetTilesBlocked(bool blocked)
	{
		if (disableColliderIfOpen)
		{
			collider.enabled = blocked;
		}
		if (!blockTiles)
		{
			return;
		}
		for (int i = propMarker.pos.Y; i < propMarker.pos.Y + propMarker.height; i++)
		{
			for (int j = propMarker.pos.X; j < propMarker.pos.X + propMarker.width; j++)
			{
				Map.Get().At(j, i).Occupied = blocked;
			}
		}
	}
}
public class MechLever : InteractionListener
{
	public bool currentState;

	public float speed = 3f;

	public Transform rotatingObject;

	public float rotAmount = -90f;

	private Quaternion onRot;

	private Quaternion offRot;

	public List<MechActor> actors;

	public bool addRoomActors = true;

	public AudioClip useClip;

	private new void Start()
	{
		base.Start();
		offRot = rotatingObject.localRotation;
		onRot = offRot * Quaternion.AngleAxis(rotAmount, new Vector3(0f, 0f, 1f));
		if (currentState)
		{
			Quaternion quaternion = onRot;
			onRot = offRot;
			offRot = quaternion;
		}
		if (actors == null)
		{
			actors = new List<MechActor>();
		}
		if (addRoomActors)
		{
			List<string> tags = GetComponent<PropInfo>().GetTags();
			Room room = Map.Get().At(base.transform.position).Room;
			if (room != null)
			{
				foreach (PropInfo prop in room.props)
				{
					MechActor component = prop.GetComponent<MechActor>();
					if (!(component != null))
					{
						continue;
					}
					bool flag = true;
					if (tags != null && tags.Count > 0)
					{
						flag = false;
						foreach (string item in tags)
						{
							flag |= component.CheckTag(item);
						}
					}
					if (flag)
					{
						actors.Add(component);
					}
				}
			}
		}
		Serializer.Add(this, OnSerialize, OnDeserialize);
	}

	private void OnSerialize(BinaryWriter writer)
	{
		writer.Write(currentState);
		writer.Write(canInteract);
	}

	private void OnDeserialize(BinaryReader reader)
	{
		bool flag = reader.ReadBoolean();
		canInteract = reader.ReadBoolean();
		if (flag == currentState)
		{
			return;
		}
		foreach (MechActor actor in actors)
		{
			actor.SetProgress((!flag) ? 0f : 1f);
		}
		currentState = flag;
	}

	private new void Update()
	{
		base.Update();
		Quaternion b = ((!currentState) ? offRot : onRot);
		rotatingObject.localRotation = Quaternion.Slerp(rotatingObject.localRotation, b, Time.fixedDeltaTime * speed);
	}

	protected override bool OnInteraction()
	{
		currentState = !currentState;
		foreach (MechActor actor in actors)
		{
			actor.SetProgress((!currentState) ? 0f : 1f);
		}
		GetComponentInChildren<AudioSource>().PlayOneShot(useClip);
		return true;
	}
}
public class MechTileBlocker : MechActor
{
	public float progressOpen;

	private RoomTemplate.PropMarker propMarker;

	private void Start()
	{
		propMarker = GetComponent<PropInfo>().PropMarker;
		SetTilesBlocked(progressOpen <= 0f);
	}

	public override void SetProgress(float progress = 1f, bool instantaneous = false, bool playAudio = true)
	{
		progressOpen = progress;
		if (progress <= 0f || progress >= 1f)
		{
			SetTilesBlocked(progress <= 0f);
		}
	}

	private void SetTilesBlocked(bool blocked)
	{
		for (int i = propMarker.pos.Y; i < propMarker.pos.Y + propMarker.height; i++)
		{
			for (int j = propMarker.pos.X; j < propMarker.pos.X + propMarker.width; j++)
			{
				Map.Get().At(j, i).Occupied = blocked;
			}
		}
	}
}
public class MechWheel : ProgressInteraction
{
	public List<MechActor> actors;

	public bool addRoomActors = true;

	public Transform wheelObj;

	public float deltaAngle;

	public float speed = 1f;

	private Quaternion offRot;

	private Quaternion onRot;

	public AudioSource turnSound;

	public AudioClip mainSound;

	public AudioClip releaseSound;

	public AudioClip finishSound;

	private float curProgress;

	private new void Start()
	{
		base.Start();
		offRot = wheelObj.localRotation;
		onRot = offRot * Quaternion.AngleAxis(deltaAngle, new Vector3(-1f, 0f, 0f));
		if (actors == null)
		{
			actors = new List<MechActor>();
		}
		if (addRoomActors)
		{
			List<string> tags = GetComponent<PropInfo>().GetTags();
			Room room = Map.Get().At(base.transform.position).Room;
			if (room != null)
			{
				foreach (PropInfo prop in room.props)
				{
					MechActor component = prop.GetComponent<MechActor>();
					if (!(component != null))
					{
						continue;
					}
					bool flag = true;
					if (tags != null && tags.Count > 0)
					{
						flag = false;
						foreach (string item in tags)
						{
							flag |= component.CheckTag(item);
						}
					}
					if (flag)
					{
						actors.Add(component);
					}
				}
			}
		}
		Serializer.Add(this, OnSerialize, OnDeserialize);
	}

	private void OnSerialize(BinaryWriter writer)
	{
		writer.Write(needsProgress);
		writer.Write((double)curProgress);
	}

	private void OnDeserialize(BinaryReader reader)
	{
		needsProgress = reader.ReadBoolean();
		curProgress = (float)reader.ReadDouble();
	}

	private new void Update()
	{
		base.Update();
		Quaternion b = Quaternion.Slerp(offRot, onRot, curProgress);
		wheelObj.localRotation = Quaternion.Slerp(wheelObj.localRotation, b, Time.deltaTime * speed);
		if (!IsInteracting() && turnSound.isPlaying)
		{
			float num = Mathf.Abs(Quaternion.Angle(wheelObj.localRotation, offRot));
			if (num <= 15f)
			{
				turnSound.Stop();
			}
		}
	}

	protected override void OnStartProgress()
	{
		turnSound.clip = mainSound;
		turnSound.Play();
	}

	protected override void OnFinishProgress()
	{
		turnSound.Stop();
		curProgress = 1f;
		AudioSource.PlayClipAtPoint(finishSound, wheelObj.position);
		foreach (MechActor actor in actors)
		{
			actor.SetProgress(curProgress, instantaneous: false, playAudio: false);
		}
	}

	protected override void OnProgress(float progress)
	{
		curProgress = progress;
		foreach (MechActor actor in actors)
		{
			actor.SetProgress(curProgress, instantaneous: false, playAudio: false);
		}
	}

	protected override void OnCancelProgress()
	{
		turnSound.Stop();
		turnSound.clip = releaseSound;
		turnSound.Play();
		curProgress = 0f;
		foreach (MechActor actor in actors)
		{
			actor.SetProgress(curProgress, instantaneous: false, playAudio: false);
		}
	}
}
[ExecuteInEditMode]
public class MeshMorpher : MonoBehaviour
{
	public Mesh fromMesh;

	public Mesh toMesh;

	public float factor;

	private Mesh mesh;

	public float Factor
	{
		get
		{
			return factor;
		}
		set
		{
			SetMesh(value);
		}
	}

	private void Awake()
	{
		if (!(fromMesh == null) && !(toMesh == null))
		{
			MeshFilter component = GetComponent<MeshFilter>();
			component.sharedMesh = fromMesh;
			mesh = component.mesh;
		}
	}

	private void Update()
	{
		SetMesh(factor);
	}

	private void SetMesh(float newFactor)
	{
		if (!(fromMesh == null) && !(toMesh == null))
		{
			factor = newFactor;
			Vector3[] vertices = fromMesh.vertices;
			Vector3[] vertices2 = toMesh.vertices;
			Vector3[] array = new Vector3[mesh.vertexCount];
			for (int i = 0; i < array.Length; i++)
			{
				ref Vector3 reference = ref array[i];
				reference = Vector3.Lerp(vertices[i], vertices2[i], factor);
			}
			mesh.vertices = array;
			mesh.RecalculateBounds();
		}
	}
}
public class Oracle : FSMComponent<Oracle.States>
{
	public enum States
	{
		Asleep,
		AsleepClosed,
		Prompt,
		WaitQuestion,
		Replying,
		Closed
	}

	public bool startClosed;

	public AudioSource voiceSource;

	public AudioSource coverSource;

	public AudioClip spectralTone;

	public Transform headObj;

	public Collider coverCollider;

	private Eyes eyes;

	private GameObject player;

	private Transform playerLook;

	private Inventory inventory;

	private VisibilityProbe probe;

	private float timer;

	private bool waiting;

	private int coinPrice;

	private bool pricePaid;

	private bool hasEverSpoken;

	private bool instantClose;

	public string[] promptIDs;

	public AudioClip coverOpen;

	public AudioClip coverClose;

	public OracleQuestions questionDB;

	private List<string> questionIDs;

	private string selectedQuestionID;

	public UIMenuStack dialogMenus;

	private void Start()
	{
		player = Player.Get();
		playerLook = Player.GetLook();
		eyes = GetComponent<Eyes>();
		probe = Map.Get().At(base.transform.position).Probe;
		InitUI();
		Serializer.Add(this, OnSerialize, OnDeserialize);
		if (startClosed)
		{
			Init(States.AsleepClosed);
		}
		else
		{
			Init(States.Asleep);
		}
	}

	private void OnSerialize(BinaryWriter writer)
	{
		writer.Write(coinPrice);
		writer.Write(pricePaid);
		writer.Write(base.State == States.Closed);
		writer.Write(hasEverSpoken);
	}

	private void OnDeserialize(BinaryReader reader)
	{
		coinPrice = reader.ReadInt32();
		pricePaid = reader.ReadBoolean();
		if (reader.ReadBoolean())
		{
			instantClose = true;
			base.State = States.Closed;
		}
		hasEverSpoken = reader.ReadBoolean();
	}

	private void Asleep_Enter()
	{
		eyes.SetClosed();
		dialogMenus.CloseMenu();
		waiting = false;
		if (coverCollider != null)
		{
			coverCollider.enabled = false;
		}
		Player.GetCrosshair().gameObject.SetActive(value: false);
	}

	private void Asleep_Update()
	{
		if (!waiting && probe.IsVisible && PlayerInRange())
		{
			waiting = true;
			timer = UnityEngine.Random.Range(1, 4);
		}
		else
		{
			if (!waiting)
			{
				return;
			}
			timer -= Time.deltaTime;
			if (timer <= 0f)
			{
				if (!pricePaid)
				{
					base.State = States.Prompt;
				}
				else
				{
					base.State = States.WaitQuestion;
				}
			}
		}
	}

	private void AsleepClosed_Enter()
	{
		eyes.SetClosed();
		GetComponent<Animation>().Play("CloseCover");
		dialogMenus.CloseMenu();
		waiting = false;
		if (coverCollider != null)
		{
			coverCollider.enabled = true;
		}
		Player.GetCrosshair().gameObject.SetActive(value: false);
	}

	private void AsleepClosed_Exit()
	{
		GetComponent<Animation>().Play("OpenCover");
		coverSource.Stop();
		coverSource.clip = coverOpen;
		coverSource.Play();
	}

	public void OpenCover()
	{
		if (base.State == States.AsleepClosed)
		{
			base.State = States.Asleep;
			if (coverCollider != null)
			{
				coverCollider.enabled = false;
			}
		}
	}

	private void Prompt_Enter()
	{
		inventory = Player.GetComponentInChildren<Inventory>();
		string idClip = RandomExt.Choice(promptIDs);
		AudioClip soundClip = OracleQuestions.GetSoundClip(idClip);
		voiceSource.clip = soundClip;
		timer = UnityEngine.Random.Range(1f, 3f);
		voiceSource.PlayDelayed(timer);
		coinPrice = GetPrice();
		ShowUIPromptPay(coinPrice, timer);
		timer += soundClip.length + 1f;
		AudioSource.PlayClipAtPoint(spectralTone, playerLook.position);
		if (GameController.Get().gameState.oracleNumAsked == 0 && !hasEverSpoken)
		{
			FearEffect.Get().Scare(jumpScare: true);
		}
		hasEverSpoken = true;
	}

	private void Prompt_Update()
	{
		UpdateEyes();
		if (CheckBackToSleep())
		{
			base.State = States.Asleep;
		}
	}

	private void Prompt_Exit()
	{
		StopAllCoroutines();
		dialogMenus.GetMenu("PromptPay").GetComponent<UIMenuAnimator>().animateSize = false;
	}

	private void Prompt_OnPay()
	{
		inventory.ConsumeItem(Collectable.EItemType.Coin, coinPrice);
		pricePaid = true;
		base.State = States.WaitQuestion;
	}

	private void WaitQuestion_Enter()
	{
		questionIDs = new List<string>();
		questionDB.SelectQuestions(questionIDs, GameController.Get().gameState.oracleTags);
		ShowUIQuestions();
	}

	private void WaitQuestion_Update()
	{
		UpdateEyes();
		if (CheckBackToSleep())
		{
			base.State = States.Asleep;
		}
	}

	private void WaitQuestion_OnSelect(int indexQuestion)
	{
		selectedQuestionID = questionIDs[indexQuestion];
		base.State = States.Replying;
	}

	private void Replying_Enter()
	{
		ShowUISubtitle(selectedQuestionID);
		questionDB.AskQuestion(selectedQuestionID, GameController.Get().gameState.oracleTags);
		GameController.Get().gameState.oracleNumAsked++;
		AudioClip soundClip = OracleQuestions.GetSoundClip(selectedQuestionID);
		timer = UnityEngine.Random.Range(0.1f, 0.5f);
		if (soundClip == null)
		{
			Debug.LogError("Missing Oracle audio file: " + selectedQuestionID);
			return;
		}
		voiceSource.clip = soundClip;
		voiceSource.PlayDelayed(timer);
		timer += soundClip.length + 1.5f;
	}

	private void Replying_Update()
	{
		UpdateEyes();
		timer -= Time.deltaTime;
		if (timer <= 0f)
		{
			base.State = States.Closed;
		}
	}

	private void Replying_Exit()
	{
		dialogMenus.CloseMenu();
	}

	private void Closed_Enter()
	{
		eyes.SetClosed();
		waiting = true;
		timer = UnityEngine.Random.Range(1.5f, 3f);
		dialogMenus.CloseMenu();
		Player.GetCrosshair().gameObject.SetActive(value: false);
		if (instantClose)
		{
			waiting = false;
			GetComponent<Animation>().Play("CloseCover");
			GetComponent<Animation>()["CloseCover"].normalizedTime = 1f;
			GetComponent<Animation>().Sample();
			if (coverCollider != null)
			{
				coverCollider.enabled = true;
			}
			instantClose = false;
		}
	}

	private void Closed_Update()
	{
		if (!waiting)
		{
			return;
		}
		timer -= Time.deltaTime;
		if (!(timer <= 0f))
		{
			return;
		}
		bool flag = false;
		if (coverCollider != null)
		{
			if ((Player.GetGroundPos() - coverCollider.transform.position.ToGround()).sqrMagnitude >= 1.44f)
			{
				flag = true;
			}
		}
		else
		{
			flag = true;
		}
		if (flag)
		{
			waiting = false;
			GetComponent<Animation>().Play("CloseCover");
			coverSource.Stop();
			coverSource.clip = coverClose;
			coverSource.Play();
			if (coverCollider != null)
			{
				coverCollider.enabled = true;
			}
		}
	}

	private void Closed_Exit()
	{
		GetComponent<Animation>().Play("OpenCover");
		coverSource.Stop();
		coverSource.clip = coverOpen;
		coverSource.Play();
	}

	private bool CheckBackToSleep()
	{
		return !PlayerInRange(asleep: false) || (!probe.IsVisible && (playerLook.transform.position - base.transform.position).sqrMagnitudeGround() >= 6.25f);
	}

	private bool PlayerInRange(bool asleep = true)
	{
		float num = ((!asleep) ? 60f : 45f);
		float num2 = ((!asleep) ? 3f : 2.5f);
		float angleToPoint = GetAngleToPoint(playerLook.transform.position, headObj);
		if (Mathf.Abs(angleToPoint) <= num)
		{
			Vector3 position = playerLook.position;
			Vector3 direction = position - base.transform.position;
			if (direction.sqrMagnitude > num2 * num2)
			{
				return false;
			}
			float magnitude = direction.magnitude;
			direction /= magnitude;
			if (Physics.Raycast(base.transform.position, direction, out var hitInfo, magnitude))
			{
				return hitInfo.collider.gameObject == player.gameObject;
			}
		}
		return false;
	}

	private float GetAngleToPoint(Vector3 targetPoint, Transform refTransform)
	{
		Vector3 vec = targetPoint - refTransform.position;
		vec = vec.GroundNormalize();
		return Vector3.Angle(refTransform.right, vec);
	}

	private float UpdateEyes()
	{
		float angleToPoint = GetAngleToPoint(playerLook.transform.position, headObj);
		if (Mathf.Abs(angleToPoint) <= 65f)
		{
			eyes.SetLookAtPlayer();
		}
		else
		{
			eyes.SetLookAhead();
		}
		return angleToPoint;
	}

	private int GetPrice()
	{
		int oracleNumAsked = GameController.Get().gameState.oracleNumAsked;
		return Mathf.Min(4, Mathf.Max(2, Mathf.CeilToInt((float)oracleNumAsked / 1.25f)));
	}

	private void InitUI()
	{
		UIDreadHallsMenu menu = dialogMenus.GetMenu("SelectQuestion");
		menu.GetButton("button_question_0").SetAction(UIQuestions_Select0);
		menu.GetButton("button_question_1").SetAction(UIQuestions_Select1);
		menu.GetButton("button_question_2").SetAction(UIQuestions_Select2);
	}

	private void ShowUIPromptPay(int coins, float timer = 0f)
	{
		int numItems = inventory.GetNumItems(Collectable.EItemType.Coin);
		bool flag = numItems >= coins;
		string newText = ((!flag) ? string.Format(Translate.Get("ORACLE_PROMPT_PAY_NOCOINS"), coins) : string.Format(Translate.Get("ORACLE_PROMPT_PAY"), numItems));
		UIDreadHallsMenu menu = dialogMenus.GetMenu("PromptPay");
		menu.SetText("main_text", newText);
		UIButton3D button = menu.GetButton("button_pay");
		button.text = string.Format(Translate.Get("ORACLE_PROMPT_PAY_BTN"), coins);
		button.SetAction(Prompt_OnPay);
		button.gameObject.SetActive(flag);
		UIMenuAnimator component = menu.GetComponent<UIMenuAnimator>();
		component.ApplyAlpha(0f);
		component.animateSize = true;
		StartCoroutine(ShowUIPromptPay_co(timer));
		Player.GetCrosshair().gameObject.SetActive(value: true);
	}

	private IEnumerator ShowUIPromptPay_co(float waitTime)
	{
		yield return new WaitForSeconds(waitTime);
		dialogMenus.ShowMenu("PromptPay");
	}

	private void ShowUIQuestions()
	{
		UIDreadHallsMenu menu = dialogMenus.GetMenu("SelectQuestion");
		for (int i = 0; i < 3; i++)
		{
			UIButton3D button = menu.GetButton("button_question_" + i);
			if (questionIDs.Count > i)
			{
				button.text = OracleQuestions.GetText(questionIDs[i]);
				button.gameObject.SetActive(value: true);
			}
			else
			{
				button.gameObject.SetActive(value: false);
			}
		}
		dialogMenus.ShowMenu("SelectQuestion");
		dialogMenus.GetMenu("SelectQuestion").SetText("main_text", Translate.Get("ORACLE_SELECT_QUESTION"));
		Player.GetCrosshair().gameObject.SetActive(value: true);
	}

	private void UIQuestions_Select0()
	{
		WaitQuestion_OnSelect(0);
	}

	private void UIQuestions_Select1()
	{
		WaitQuestion_OnSelect(1);
	}

	private void UIQuestions_Select2()
	{
		WaitQuestion_OnSelect(2);
	}

	private void ShowUISubtitle(string questionID)
	{
		if (Config.General().oracleSubtitles)
		{
			UIDreadHallsMenu menu = dialogMenus.GetMenu("SubtitleFrame");
			string replyText = OracleQuestions.GetReplyText(questionID);
			dialogMenus.ShowMenu("SubtitleFrame");
			menu.SetTextWrap("main_text", replyText, 0.3f);
		}
		else
		{
			dialogMenus.CloseMenu();
		}
		Player.GetCrosshair().gameObject.SetActive(value: false);
	}
}
public class OracleQuestions : ScriptableObject
{
	[Serializable]
	public class Question
	{
		public string id;

		public List<string> conditionTags;

		public bool CheckValid(List<string> checkTags)
		{
			for (int i = 0; i < checkTags.Count; i++)
			{
				if (checkTags[i] == id)
				{
					return false;
				}
			}
			for (int j = 0; j < conditionTags.Count; j++)
			{
				bool flag = false;
				if (conditionTags[j] == "EMPTY" && checkTags.Count == 0)
				{
					flag = true;
				}
				for (int k = 0; k < checkTags.Count; k++)
				{
					if (flag)
					{
						break;
					}
					if (checkTags[k] == conditionTags[j])
					{
						flag = true;
					}
				}
				if (!flag)
				{
					return false;
				}
			}
			if (id == "PLACE_HUB")
			{
				return GameController.Get().levelOptions.IsMetaMap() && GameController.Get().gameState.metaMap == 1;
			}
			return true;
		}
	}

	public Question[] questions;

	public void AskQuestion(string idQuestion, List<string> conditionTags)
	{
		for (int i = 0; i < questions.Length; i++)
		{
			if (questions[i].id == idQuestion)
			{
				if (conditionTags.Count == 0)
				{
					conditionTags.Add("ASKED_1");
				}
				conditionTags.Add(idQuestion);
				break;
			}
		}
	}

	public int SelectQuestions(List<string> outQuestions, List<string> conditionTags, int numQuestions = 3)
	{
		outQuestions.Clear();
		for (int i = 0; i < questions.Length; i++)
		{
			if (questions[i].CheckValid(conditionTags))
			{
				outQuestions.Add(questions[i].id);
			}
		}
		while (outQuestions.Count > numQuestions)
		{
			int index = UnityEngine.Random.Range(0, outQuestions.Count);
			outQuestions[index] = outQuestions[outQuestions.Count - 1];
			outQuestions.RemoveAt(outQuestions.Count - 1);
		}
		return outQuestions.Count;
	}

	public static string GetText(string idQuestion)
	{
		return Translate.Get("ORACLE_QUESTION_" + idQuestion);
	}

	public static string GetReplyText(string idQuestion)
	{
		return Translate.Get("ORACLE_QUESTION_REPLY_" + idQuestion);
	}

	public static AudioClip GetSoundClip(string idClip)
	{
		string language = Translate.GetLanguage();
		AudioClip audioClip = LoadClip(idClip, language);
		if (audioClip == null)
		{
			audioClip = LoadClip(idClip);
		}
		return audioClip;
	}

	private static AudioClip LoadClip(string idClip, string language = "english")
	{
		return Resources.Load<AudioClip>("Oracle/" + language + "/" + idClip);
	}
}
public class PageFlip : MonoBehaviour
{
	[Range(0f, 1f)]
	public float scaleX = 1f;

	[Range(0f, 1f)]
	public float scaleY = 1f;

	public float initRotation = 90f;

	public float endRotation = 270f;

	[Range(0f, 1f)]
	public float rotRatio;

	[Range(0f, 90f)]
	public float theta;

	public float apex;

	public Renderer[] pageRenderers;

	private float initTheta;

	private float initApex;

	private void Start()
	{
		Renderer[] array = pageRenderers;
		foreach (Renderer renderer in array)
		{
			renderer.material.SetFloat("_ScaleX", scaleX);
			renderer.material.SetFloat("_ScaleY", scaleY);
		}
		initTheta = theta;
		initApex = apex;
	}

	private void Update()
	{
		float f = theta * ((float)Math.PI / 180f);
		float value = Mathf.Sin(f);
		float value2 = Mathf.Cos(f);
		Renderer[] array = pageRenderers;
		foreach (Renderer renderer in array)
		{
			renderer.material.SetFloat("_SinTheta", value);
			renderer.material.SetFloat("_CosTheta", value2);
			renderer.material.SetFloat("_Apex", apex);
		}
		Quaternion a = Quaternion.Euler(0f, -180f, initRotation);
		Quaternion b = Quaternion.Euler(0f, -180f, endRotation);
		base.transform.localRotation = Quaternion.Slerp(a, b, rotRatio);
	}

	public float Flip(bool invert = false)
	{
		string animation = ((!invert) ? "Book_PageFlip" : "Book_PageFlip_Inv");
		GetComponent<Animation>().Play(animation);
		Renderer[] array = pageRenderers;
		foreach (Renderer renderer in array)
		{
			renderer.material.SetFloat("_FlipDir", (!invert) ? 1f : (-1f));
		}
		return GetComponent<Animation>()[animation].length;
	}

	public void Reset()
	{
		GetComponent<Animation>().Stop();
		rotRatio = 0f;
		theta = initTheta;
		apex = initApex;
	}

	public void SetPageFront(Texture texture)
	{
		if (pageRenderers != null && pageRenderers.Length >= 1)
		{
			pageRenderers[0].material.SetTexture("_ContentTex", texture);
		}
	}

	public void SetPageBack(Texture texture)
	{
		if (pageRenderers != null && pageRenderers.Length >= 2)
		{
			pageRenderers[1].material.SetTexture("_ContentTex", texture);
		}
	}

	public Texture GetPageFront()
	{
		if (pageRenderers != null && pageRenderers.Length >= 1)
		{
			return pageRenderers[0].material.GetTexture("_ContentTex");
		}
		return null;
	}

	public Texture GetPageBack()
	{
		if (pageRenderers != null && pageRenderers.Length >= 2)
		{
			return pageRenderers[1].material.GetTexture("_ContentTex");
		}
		return null;
	}
}
public class Pillar : MonoBehaviour
{
	private ParticleSystem[] particles;

	public LineRenderContrl lightningFX;

	public AudioSource soundLoop;

	private void Start()
	{
		particles = GetComponentsInChildren<ParticleSystem>();
		SetParticlesEmission(enabled: false);
	}

	public void ActivateEffects()
	{
		SetParticlesEmission(enabled: true);
		soundLoop.enabled = true;
	}

	public void ActivateLightning(Transform target)
	{
		lightningFX.Target = target;
		lightningFX.gameObject.SetActive(value: true);
		soundLoop.enabled = false;
	}

	private void SetParticlesEmission(bool enabled)
	{
		for (int i = 0; i < particles.Length; i++)
		{
			particles[i].enableEmission = enabled;
		}
	}
}
public class PlayerNotes : MonoBehaviour
{
	public AudioClip PaperSound;

	public List<string> noteNames;

	private Dictionary<string, List<string>> notesDict;

	private bool showingNote;

	private bool preShowingNote;

	private TextLabel textLabel;

	public UICamChaser camChaser;

	public float minShowingTime = 0.5f;

	private float minShowTimer;

	private bool hidingForInventory;

	public bool IsShowingNote => showingNote || preShowingNote;

	private void Start()
	{
		textLabel = GetComponent<TextLabel>();
		textLabel.HideText();
		camChaser.enabled = false;
		notesDict = new Dictionary<string, List<string>>();
		foreach (string noteName in noteNames)
		{
			string[] array = noteName.Split('_');
			string key = string.Empty;
			if (array.Length >= 2)
			{
				key = array[0];
			}
			if (!notesDict.ContainsKey(key))
			{
				notesDict[key] = new List<string>();
			}
			if (!GameController.Get().gameState.playerNotes.Contains(noteName))
			{
				notesDict[key].Add(noteName);
			}
		}
	}

	private void Update()
	{
		if (!showingNote)
		{
			return;
		}
		if (minShowTimer > 0f)
		{
			minShowTimer -= Time.deltaTime;
		}
		if (minShowTimer <= 0f && (InputExt.GetButtonDown(InputExt.Button.Action) || InputExt.GetButtonDown(InputExt.Button.Cancel)) && !hidingForInventory)
		{
			AudioSource.PlayClipAtPoint(PaperSound, base.transform.position);
			textLabel.FadeOut();
			showingNote = false;
			camChaser.enabled = false;
			Player.GetController().UnblockMovement(unBlockRotation: false);
		}
		Player.GetMinimapPos().Hide = true;
		if (InputExt.GetButton(InputExt.Button.Inventory))
		{
			if (!hidingForInventory)
			{
				hidingForInventory = true;
				textLabel.FadeOut(8f);
			}
		}
		else if (hidingForInventory)
		{
			hidingForInventory = false;
			textLabel.FadeIn(8f);
		}
	}

	public void ShowNote()
	{
		preShowingNote = false;
		if (showingNote)
		{
			Player.GetController().UnblockMovement(unBlockRotation: false);
		}
		string text = GameController.Get().levelOptions.playerNotesGroup;
		if (!notesDict.ContainsKey(text) || notesDict[text].Count == 0)
		{
			text = string.Empty;
		}
		int index = UnityEngine.Random.Range(0, notesDict[text].Count);
		if (text.StartsWith("META"))
		{
			index = 0;
		}
		string text2 = Translate.Get("PLAYERNOTE_" + notesDict[text][index]);
		if (text != string.Empty)
		{
			GameController.Get().gameState.playerNotes.Add(notesDict[text][index]);
			notesDict[text].RemoveAt(index);
		}
		textLabel.Text = text2;
		textLabel.FadeIn();
		AudioSource.PlayClipAtPoint(PaperSound, base.transform.position);
		showingNote = true;
		minShowTimer = minShowingTime;
		camChaser.enabled = true;
		camChaser.Recenter();
		Player.GetController().BlockMovement(blockRotation: false);
		hidingForInventory = false;
	}

	public void SetPreShowNote()
	{
		preShowingNote = true;
	}
}
[RequireComponent(typeof(BoxCollider))]
[RequireComponent(typeof(MeshFilter))]
[RequireComponent(typeof(MeshRenderer))]
public class ProceduralCube : MonoBehaviour
{
	public float fSizeX = 1f;

	public float fSizeY = 1f;

	public float fSizeZ = 1f;

	public float fTileU = 1f;

	public float fTileV = 1f;

	public void Rebuild()
	{
		GetComponent<BoxCollider>().size = new Vector3(fSizeX, fSizeY, fSizeZ);
		GetComponent<BoxCollider>().center = new Vector3(fSizeX / 2f, fSizeY / 2f, fSizeZ / 2f);
	}
}
public class ProgressInteraction : MonoBehaviour
{
	public bool needsProgress = true;

	public bool canInteractAfter;

	public float duration;

	public float UIDistance = 0.146f;

	public Vector3 UIPosOffset = Vector3.zero;

	public float UIScale = 1f;

	public float distance = 1.5f;

	private float maxPlayerDistance;

	public LayerMask layerMask;

	public bool reorientToPlayer = true;

	public GameObject iconPrefab;

	public GameObject progressPrefab;

	public bool highlight = true;

	protected HighlightEffect highlightFX;

	public Color highlightColor1 = new Color(1f, 0.92f, 0.016f, 1f);

	public Color highlightColor2 = new Color(1f, 0.92f, 0.116f, 0.5f);

	public float highlightFreq = 0.55f;

	private bool interacting;

	private float progress;

	protected Transform playerLook;

	private MinimapPosition minimapPos;

	private GameObject interactionIcon;

	private GameObject progressIcon;

	private AudioSource interactionSound;

	private bool visible = true;

	public Collider interactionCollider;

	private Vector3 colliderCenter;

	private bool selected;

	private Color curHighlightColor;

	private DisableOnPause disableOnPause;

	protected void Awake()
	{
		if (highlight)
		{
			highlightFX = base.gameObject.GetComponent<HighlightEffect>();
			if (!highlightFX)
			{
				highlightFX = base.gameObject.AddComponent<HighlightEffect>();
			}
		}
		curHighlightColor = new Color(highlightColor1.r, highlightColor1.g, highlightColor1.b, 0f);
		layerMask = LayerMaskExtensions.Create("Default", "TransparentFX", "LightCaster", "Collectable", "Prop", "StaticGeometry");
		minimapPos = GameObject.FindWithTag(Tags.Minimap).GetComponent<MinimapPosition>();
		interactionIcon = null;
		progressIcon = null;
		interacting = false;
		progress = 0f;
		interactionSound = GetComponent<AudioSource>();
		disableOnPause = GetComponent<DisableOnPause>();
		if (disableOnPause == null)
		{
			disableOnPause = base.gameObject.AddComponent<DisableOnPause>();
		}
	}

	protected void Start()
	{
		if (interactionCollider == null)
		{
			interactionCollider = GetComponentInChildren<Collider>();
		}
		if (interactionCollider != null)
		{
			colliderCenter = interactionCollider.bounds.center;
		}
		else
		{
			colliderCenter = base.transform.position;
		}
	}

	protected void Update()
	{
		if (!visible && !interacting)
		{
			return;
		}
		playerLook = Player.GetLook(interaction: true);
		Vector3 vector = playerLook.position - colliderCenter;
		bool flag = false;
		if ((needsProgress || canInteractAfter) && vector.sqrMagnitude <= distance * distance && Physics.Raycast(playerLook.position, playerLook.forward, out var hitInfo, distance, layerMask) && (hitInfo.collider == interactionCollider || hitInfo.collider.transform.parent == base.transform))
		{
			flag = true;
			minimapPos.Hide = true;
		}
		if ((bool)highlightFX)
		{
			if (flag)
			{
				Color b = Color.Lerp(highlightColor1, highlightColor2, 0.5f * Mathf.Sin(Time.realtimeSinceStartup * highlightFreq * (float)Math.PI * 2f) + 0.5f);
				Color color = Color.Lerp(curHighlightColor, b, Time.deltaTime * 8f);
				curHighlightColor = color;
				highlightFX.FadeIn();
			}
			else
			{
				highlightFX.FadeOut();
			}
		}
		if (flag && needsProgress && !interactionIcon)
		{
			Vector3 vector2 = colliderCenter + UIPosOffset;
			Vector3 vector3 = Player.GetGroundPos() + Vector3.up * 1.8f;
			Vector3 vector4 = vector3 - vector2;
			vector4.Normalize();
			float num = Vector3.Dot(base.transform.forward, vector4);
			Vector3 position = vector2 + vector4 * UIDistance;
			Quaternion quaternion = Quaternion.LookRotation(vector4);
			interactionIcon = UnityEngine.Object.Instantiate(iconPrefab, Vector3.zero, Quaternion.identity);
			interactionIcon.transform.parent = base.transform;
			interactionIcon.transform.position = position;
			interactionIcon.transform.rotation = quaternion;
			progressIcon = UnityEngine.Object.Instantiate(progressPrefab, Vector3.zero, Quaternion.identity);
			progressIcon.transform.parent = base.transform;
			progressIcon.transform.position = position;
			progressIcon.transform.rotation = quaternion * Quaternion.Euler(0f, -90f, 270f);
			progressIcon.GetComponent<Renderer>().material.SetFloat("_Cutoff", 1f);
			interactionIcon.transform.localScale = Vector3.zero;
			progressIcon.transform.localScale = Vector3.zero;
			maxPlayerDistance = Mathf.Max(distance, (Player.GetGroundPos() - base.transform.position.ToGround()).magnitude);
			disableOnPause.targetObjs.Add(interactionIcon);
			disableOnPause.targetObjs.Add(progressIcon);
		}
		if (!interacting && flag && InputExt.GetButtonDown(InputExt.Button.Action))
		{
			if (needsProgress)
			{
				interacting = true;
				progress = 0f;
				if ((bool)interactionSound)
				{
					interactionSound.Play(0uL);
				}
				OnStartProgress();
			}
			else if (canInteractAfter)
			{
				OnSimpleInteraction();
			}
		}
		if (interacting)
		{
			if (InputExt.GetButton(InputExt.Button.Action))
			{
				progress += Time.deltaTime / duration;
				progress = Mathf.Clamp(progress, 0f, 1f);
				if (progress >= 1f)
				{
					interacting = false;
					needsProgress = false;
					if ((bool)interactionSound)
					{
						interactionSound.Stop();
					}
					OnFinishProgress();
				}
				OnProgress(progress);
			}
			else
			{
				if ((bool)interactionSound)
				{
					interactionSound.Stop();
				}
				interacting = false;
				OnCancelProgress();
			}
			ShowProgress(progress);
		}
		if (!interacting && needsProgress && progress > 0f)
		{
			progress -= Time.deltaTime / 0.3f;
			progress = Mathf.Clamp(progress, 0f, 1f);
			ShowProgress(progress);
		}
		bool flag2 = (flag && needsProgress) || interacting;
		if (interacting)
		{
			float sqrMagnitude = (Player.GetGroundPos() - base.transform.position.ToGround()).sqrMagnitude;
			if (sqrMagnitude > maxPlayerDistance * maxPlayerDistance)
			{
				flag2 = false;
				if ((bool)interactionSound)
				{
					interactionSound.Stop();
				}
				interacting = false;
				OnCancelProgress();
			}
		}
		if (flag2)
		{
			interactionIcon.transform.localScale = Vector3.Slerp(interactionIcon.transform.localScale, UIScale * Vector3.one, Time.deltaTime * 10f);
			progressIcon.transform.localScale = Vector3.Slerp(progressIcon.transform.localScale, new Vector3(0.06f, 0.06f, 0.06f) * UIScale, Time.deltaTime * 10f);
			if (reorientToPlayer)
			{
				RepositionIcons(interactionIcon.transform, progressIcon.transform);
			}
		}
		else if ((bool)interactionIcon)
		{
			interactionIcon.transform.localScale = Vector3.Lerp(interactionIcon.transform.localScale, Vector3.zero, Time.deltaTime * 7.5f);
			progressIcon.transform.localScale = Vector3.Lerp(progressIcon.transform.localScale, Vector3.zero, Time.deltaTime * 7.5f);
			if (interactionIcon.transform.localScale.x <= 0.05f)
			{
				UnityEngine.Object.Destroy(interactionIcon);
				UnityEngine.Object.Destroy(progressIcon);
				interactionIcon = null;
				progressIcon = null;
				disableOnPause.targetObjs.Clear();
			}
		}
		if (!flag && selected && (bool)highlightFX)
		{
			highlightFX.FadeOut();
		}
		selected = flag;
	}

	protected virtual void OnSimpleInteraction()
	{
	}

	protected virtual void OnStartProgress()
	{
	}

	protected virtual void OnProgress(float progress)
	{
	}

	protected virtual void OnCancelProgress()
	{
	}

	protected virtual void OnFinishProgress()
	{
	}

	private void ShowProgress(float progress)
	{
		if ((bool)progressIcon)
		{
			progressIcon.GetComponent<Renderer>().material.SetFloat("_Cutoff", 1f - progress * 0.58f);
		}
	}

	private void RepositionIcons(Transform interactionIcon, Transform progressIcon)
	{
		Vector3 vector = colliderCenter + UIPosOffset;
		Vector3 vector2 = Player.GetGroundPos() + Vector3.up * 1.8f;
		Vector3 vector3 = vector2 - vector;
		vector3.Normalize();
		float num = Vector3.Dot(base.transform.forward, vector3);
		float magnitude = (Player.CenterEye - vector).magnitude;
		float num2 = Mathf.Min(UIDistance, magnitude - 0.2f);
		Vector3 position = vector + vector3 * num2;
		Quaternion quaternion = Quaternion.LookRotation(vector3);
		interactionIcon.position = position;
		interactionIcon.rotation = quaternion;
		progressIcon.transform.position = position;
		progressIcon.transform.rotation = quaternion * Quaternion.Euler(0f, -90f, 270f);
	}

	public float GetProgress()
	{
		return progress;
	}

	public bool IsInteracting()
	{
		return interacting;
	}

	private void OnBecameVisible()
	{
		visible = true;
	}

	private void OnBecameInvisible()
	{
		visible = false;
		if ((bool)highlightFX)
		{
			highlightFX.FadeOut();
			curHighlightColor = new Color(highlightColor1.r, highlightColor1.g, highlightColor1.b, 0f);
		}
	}
}
public class PropInfo : MonoBehaviour
{
	[Serializable]
	public class WallDecoDelta
	{
		public string wallStyle;

		public Vector3 delta;

		public WallDecoDelta(string style, Vector3 d)
		{
			wallStyle = style;
			delta = d;
		}
	}

	[Serializable]
	public class PushOutCornerDelta
	{
		public string wallStyle;

		public float delta;

		public bool skipIfInCorner;

		public float latFactorIfInCorner = 1f;

		public PushOutCornerDelta(string style, float d = 0f)
		{
			wallStyle = style;
			delta = d;
			skipIfInCorner = false;
			latFactorIfInCorner = 1f;
		}
	}

	[Serializable]
	public class WallSkipConditions
	{
		public string wallStyle;

		public int maxWalls;

		public WallSkipConditions(string style, int max = 1)
		{
			wallStyle = style;
			maxWalls = max;
		}
	}

	public static bool stagingMode;

	public bool disabledProp;

	public int SizeX = 1;

	public int SizeY = 1;

	public int marginTop;

	public int marginBottom;

	public int marginLeft;

	public int marginRight;

	public bool keepFrontClear;

	public bool WallProp;

	public bool removeFloor;

	public bool removeCeiling;

	public bool hanging;

	public bool ignoreWallMargin;

	public bool ignoreOutCornerLatMargin = true;

	public bool applyLateralMargins;

	public float wallMarginFactor = 1f;

	public bool squeeze;

	public bool standAlone;

	public bool canWalkThrough;

	public bool canFloatOver;

	public bool castsLight;

	public bool isGargoyle;

	public bool makeRoomSafe;

	public bool canPlaceInSpawnRoom = true;

	public bool requireHighCeiling;

	public float minCeilingHeight;

	public bool disableInRandomMode;

	public bool addVerticalOffset;

	public bool notBehindDoor;

	public bool notInDeadend;

	public bool notInNarrowDeadend;

	public bool notInHubInCorner;

	public bool isRockColumnBottom;

	public bool isRockColumnTop;

	public int maxInRoom;

	public int maxInMap;

	public string requireStyleTag = string.Empty;

	public bool roomSmall = true;

	public bool roomMedium = true;

	public bool roomLarge = true;

	public bool roomHub = true;

	public List<WallDecoDelta> wallDecoDeltas;

	public List<PushOutCornerDelta> pushOutCornerDeltas;

	public List<WallSkipConditions> wallSkipConditions;

	private RoomTemplate.PropMarker propMarker;

	public RoomTemplate.PropMarker PropMarker
	{
		get
		{
			return propMarker;
		}
		set
		{
			propMarker = value;
		}
	}

	public bool CheckTag(string tag)
	{
		if (propMarker != null && propMarker.tags != null)
		{
			List<string> tags = propMarker.tags;
			for (int i = 0; i < tags.Count; i++)
			{
				if (tags[i] == tag)
				{
					return true;
				}
			}
		}
		return false;
	}

	public List<string> GetTags()
	{
		if (propMarker != null)
		{
			return propMarker.tags;
		}
		return null;
	}

	public WallDecoDelta GetWallDecoDelta(string styleName)
	{
		for (int i = 0; i < wallDecoDeltas.Count; i++)
		{
			if (wallDecoDeltas[i].wallStyle == styleName)
			{
				return wallDecoDeltas[i];
			}
		}
		return null;
	}

	public Vector3 GetWallDecoDeltaVector(string styleName)
	{
		for (int i = 0; i < wallDecoDeltas.Count; i++)
		{
			if (wallDecoDeltas[i].wallStyle == styleName)
			{
				return wallDecoDeltas[i].delta;
			}
		}
		return Vector3.zero;
	}

	public float GetPushOutCornerDelta(string styleName, out bool skipIfInCorner, out float latFactor)
	{
		for (int i = 0; i < pushOutCornerDeltas.Count; i++)
		{
			if (pushOutCornerDeltas[i].wallStyle == styleName)
			{
				skipIfInCorner = pushOutCornerDeltas[i].skipIfInCorner;
				latFactor = 1f - pushOutCornerDeltas[i].latFactorIfInCorner;
				return pushOutCornerDeltas[i].delta;
			}
		}
		skipIfInCorner = false;
		latFactor = 1f;
		return 0f;
	}

	public int GetWallSkipMax(string styleName)
	{
		for (int i = 0; i < wallSkipConditions.Count; i++)
		{
			if (wallSkipConditions[i].wallStyle == styleName)
			{
				return wallSkipConditions[i].maxWalls;
			}
		}
		return -1;
	}

	private void OnDrawGizmos()
	{
		if (!stagingMode)
		{
			return;
		}
		float num = 1.5f;
		Color color = new Color(0.3f, 0.3f, 0.7f);
		Color color2 = new Color(0.8f, 0.8f, 0.9f);
		for (int i = 0; i < SizeY; i++)
		{
			for (int j = 0; j < SizeX; j++)
			{
				Vector3 center = base.transform.position + new Vector3(num * (float)j, 0f, (0f - num) * (float)i);
				Gizmos.color = (((j + i) % 2 != 0) ? color2 : color);
				Gizmos.DrawCube(center, new Vector3(1.5f, 0f, 1.5f));
			}
		}
		Vector3 size = new Vector3(num * (float)SizeX, 3.5f, num * (float)SizeY);
		Vector3 vector = base.transform.position - new Vector3(num / 2f, 0f, (0f - num) / 2f);
		if (hanging)
		{
			vector.y -= 3.5f;
		}
		Gizmos.color = Color.blue;
		Gizmos.DrawWireCube(vector + new Vector3(size.x / 2f, size.y / 2f, (0f - size.z) / 2f), size);
		Color color3 = new Color(0.7f, 0.3f, 0.3f);
		Color color4 = new Color(0.9f, 0.6f, 0.6f);
		for (int k = -marginTop; k < SizeY + marginBottom; k++)
		{
			for (int l = -marginLeft; l < SizeX + marginRight; l++)
			{
				if (l < 0 || l >= SizeX || k < 0 || k >= SizeY)
				{
					Vector3 center2 = base.transform.position + new Vector3(num * (float)l, 0f, (0f - num) * (float)k);
					Gizmos.color = (((l + k) % 2 != 0) ? color4 : color3);
					Gizmos.DrawCube(center2, new Vector3(1.5f, 0f, 1.5f));
				}
			}
		}
		Gizmos.color = Color.blue;
		if (WallProp)
		{
			Vector3 vector2 = Vector3.right;
			Vector3 vector3 = Vector3.forward;
			if (SizeX > 1 && SizeY == 1)
			{
				vector2 = -Vector3.forward;
				vector3 = Vector3.right;
			}
			Vector3 vector4 = vector + new Vector3(size.x + 0.25f, 0f, (0f - size.z) / 2f);
			if (vector2 != Vector3.right)
			{
				vector4 = vector + new Vector3(size.x / 2f, 0f, 0f - size.z - 0.25f);
			}
			Vector3 from = vector4 + vector2 * 0.7f;
			Vector3 vector5 = vector4 + vector3 * 0.5f;
			Vector3 to = vector4 - vector3 * 0.5f;
			Gizmos.DrawLine(from, vector5);
			Gizmos.DrawLine(from, to);
			Gizmos.DrawLine(vector5, to);
		}
	}
}
public class RetractMetaPodium : MonoBehaviour
{
	private Inventory inventory;

	private bool isDown;

	public ParticleSystem particleSystem;

	public AudioClip moveSound;

	private void Start()
	{
		inventory = Player.Get().GetComponentInChildren<Inventory>();
		if ((bool)particleSystem)
		{
			particleSystem.enableEmission = false;
		}
		StartCoroutine(Wait_co());
		Serializer.Add(this, OnSerialize, OnDeserialize);
	}

	private void OnSerialize(BinaryWriter writer)
	{
		writer.Write(isDown);
	}

	private void OnDeserialize(BinaryReader reader)
	{
		isDown = reader.ReadBoolean();
	}

	private IEnumerator Wait_co()
	{
		do
		{
			yield return new WaitForSeconds(0.2f);
		}
		while (!inventory.HasMetaItems() && !isDown);
		GetComponent<Animation>().Play("RetractPodium");
		if ((bool)particleSystem && !isDown)
		{
			particleSystem.enableEmission = true;
			if ((bool)moveSound)
			{
				AudioSource.PlayClipAtPoint(moveSound, particleSystem.transform.position);
			}
		}
		isDown = true;
		float length = GetComponent<Animation>()["RetractPodium"].length;
		yield return new WaitForSeconds(length);
		if ((bool)particleSystem)
		{
			particleSystem.enableEmission = false;
		}
		BoxCollider hiderCollider = GetComponent<BoxCollider>();
		if (hiderCollider != null)
		{
			hiderCollider.enabled = false;
		}
	}
}
public class RoomAmbientLight : MonoBehaviour
{
	private Room room;

	private TorchLight tLight;

	private bool lightActive;

	private float initRange;

	public float inactiveRange = 0.5f;

	public float hubRange = 1f;

	public float hubIntensity = 1f;

	private void Start()
	{
		room = Map.Get().At(base.transform.position).Room;
		if (room == null)
		{
			UnityEngine.Object.Destroy(this);
			return;
		}
		GetComponent<Light>().shadows = LightShadows.None;
		Room obj = room;
		obj.OnEnter = (Room.RoomCallback)Delegate.Combine(obj.OnEnter, new Room.RoomCallback(OnPlayerEnterRoom));
		Room obj2 = room;
		obj2.OnExit = (Room.RoomCallback)Delegate.Combine(obj2.OnExit, new Room.RoomCallback(OnPlayerExitRoom));
		initRange = GetComponent<Light>().range;
		inactiveRange = Mathf.Min(initRange, inactiveRange);
		tLight = GetComponent<TorchLight>();
		if (room.Template.size == RoomTemplate.SizeType.Hub)
		{
			initRange *= hubRange;
			inactiveRange *= hubRange;
			if (tLight != null)
			{
				tLight.minIntensity *= hubIntensity;
				tLight.maxIntensity *= hubIntensity;
			}
		}
		if (tLight != null)
		{
			tLight.range = inactiveRange;
		}
		GetComponent<Light>().range = inactiveRange;
	}

	private void Update()
	{
		if (GetComponent<Light>().enabled)
		{
			GetComponent<Light>().range = Mathf.Lerp(GetComponent<Light>().range, (!lightActive) ? inactiveRange : initRange, Time.deltaTime * 0.25f);
			if (tLight != null)
			{
				tLight.range = GetComponent<Light>().range;
			}
		}
	}

	private void OnPlayerEnterRoom(Room room)
	{
		lightActive = true;
	}

	private void OnPlayerExitRoom(Room room)
	{
		lightActive = false;
	}
}
[RequireComponent(typeof(Light))]
public class TorchLight : MonoBehaviour
{
	public float minIntensity = 0.6f;

	public float maxIntensity = 1f;

	public float factor = 1f;

	public float factor2 = 1f;

	private float innerFactor = 1f;

	private float innerFactorTarget = 1f;

	private float innerFactorSpeed = 20f;

	private float minFactorFlicker = 1f;

	public float range;

	public float rangeFactor = 1f;

	public static float globalFactor = 1f;

	public Light[] slaveLights;

	private float[] slaveLightFactors;

	private float random;

	private float flickerOilTime;

	private void Start()
	{
		random = UnityEngine.Random.Range(0f, 65535f);
		innerFactor = 1f;
		range = GetComponent<Light>().range;
		if (slaveLights != null)
		{
			slaveLightFactors = new float[slaveLights.Length];
			for (int i = 0; i < slaveLightFactors.Length; i++)
			{
				slaveLightFactors[i] = 1f;
			}
		}
	}

	public void Update()
	{
		float t = Mathf.PerlinNoise(random, Time.time);
		innerFactor = Mathf.Lerp(innerFactor, innerFactorTarget, Time.deltaTime * innerFactorSpeed);
		GetComponent<Light>().intensity = Mathf.Lerp(minIntensity * factor * factor2 * innerFactor * globalFactor * minFactorFlicker, maxIntensity * factor * factor2 * innerFactor * globalFactor, t) * 2f;
		GetComponent<Light>().range = range * rangeFactor;
		if (slaveLights != null)
		{
			for (int i = 0; i < slaveLights.Length; i++)
			{
				slaveLights[i].intensity = Mathf.Lerp(minIntensity * factor * factor2 * innerFactor * globalFactor * minFactorFlicker * slaveLightFactors[i], maxIntensity * factor * factor2 * innerFactor * globalFactor * slaveLightFactors[i], t) * 2f;
			}
		}
		if (flickerOilTime > 0f)
		{
			flickerOilTime -= Time.deltaTime;
			minFactorFlicker = Mathf.Lerp(minFactorFlicker, 0.15f, Time.deltaTime * 5f);
		}
		else if (minFactorFlicker < 1f)
		{
			minFactorFlicker = Mathf.Clamp01(minFactorFlicker + Time.deltaTime * 0.2f);
		}
	}

	public void SetSlaveLightFactor(int idx, float f)
	{
		if (idx < slaveLightFactors.Length)
		{
			slaveLightFactors[idx] = f;
		}
	}

	public float GetSlaveLightFactor(int idx)
	{
		if (idx < slaveLightFactors.Length)
		{
			return slaveLightFactors[idx];
		}
		return 0f;
	}

	public void FlickerOut(bool turnOff = false, GameObject originRef = null)
	{
		StartCoroutine(FlickerOut_co(turnOff, originRef));
	}

	private IEnumerator FlickerOut_co(bool turnOff = false, GameObject originRef = null)
	{
		innerFactorTarget = 1f;
		innerFactorSpeed = 200f;
		float startTime = Time.time;
		float duration = 3f;
		if (originRef == null)
		{
			originRef = base.gameObject;
		}
		ParticleSystem[] particles = originRef.GetComponentsInChildren<ParticleSystem>();
		while (Time.time - startTime <= duration)
		{
			innerFactorTarget = Mathf.PerlinNoise(random / 2f, Time.time) - 0.25f;
			innerFactorTarget = Mathf.Clamp(innerFactorTarget, 0f, 1f);
			ParticleSystem[] array = particles;
			foreach (ParticleSystem particleSystem in array)
			{
				particleSystem.enableEmission = innerFactorTarget > 0f;
			}
			yield return new WaitForSeconds(0.025f);
		}
		if (!turnOff)
		{
			innerFactorTarget = 1f;
			innerFactorSpeed = 1f;
			ParticleSystem[] array2 = particles;
			foreach (ParticleSystem particleSystem2 in array2)
			{
				particleSystem2.enableEmission = true;
			}
		}
		else
		{
			originRef.SendMessage("OnLightTurnOff", this, SendMessageOptions.DontRequireReceiver);
			innerFactorTarget = 1f;
			innerFactorSpeed = 1f;
		}
	}

	public void FlickerOil(float time = 6f)
	{
		flickerOilTime = time;
	}

	public void StopFlickerOil(bool endFlicker = false)
	{
		flickerOilTime = 0f;
		if (endFlicker)
		{
			minFactorFlicker = 1f;
		}
	}
}
public class Unlockable : MonoBehaviour
{
	public enum Difficulty
	{
		Very_Easy,
		Easy,
		Medium,
		Hard,
		Very_Hard,
		Uninitialized
	}

	public bool Locked = true;

	public Difficulty difficultyLevel = Difficulty.Uninitialized;

	public float Strength = 1f;

	public bool PlaySilence;

	public float UIDistance = 0.146f;

	public float OpenDistance = 2f;

	private float maxPlayerDistance;

	public LayerMask layerMask;

	public bool CanToggle = true;

	public bool CanBash;

	public GameObject Door;

	public GameObject LockPrefab;

	public GameObject[] LockPrefabs;

	public GameObject ProgressPrefab;

	public GameObject WedgePregab;

	public AudioClip UnlockSound;

	private bool Picking;

	private float Progress;

	private float BaseProgress;

	private float BashProgress;

	private static Permutator BashChance;

	public bool OnlyForwardDirection;

	private Transform playerLook;

	private Transform playerView;

	private GameObject LockIcon;

	private GameObject ProgressIcon;

	private Vector3 vLocalPos;

	private float fCosForward;

	private AudioSource PickingSound;

	private HighlightEffect highlight;

	private Transform upperWedge;

	private Transform lowerWedge;

	[Range(0f, 0.5f)]
	public float upperWedgeDist = 0.22f;

	[Range(0f, 0.5f)]
	public float lowerWedgeDist = 0.148f;

	private const float wedgeDepth = 0.001f;

	[Range(0f, 360f)]
	public float upperWedgeAngle;

	[Range(0f, 360f)]
	public float lowerWedgeAngle;

	private float upperWedgeAngleTarget;

	private float lowerWedgeAngleTarget;

	private bool upperWedgeCanMove;

	private bool lowerWedgeCanMove = true;

	private bool canUseLockpick;

	private float lockpickTimer;

	private float wedgeMoveFactor = 1f;

	private float failTimer;

	public GameObject lockpickPrefab;

	public AudioClip lockpickSuccessSound;

	public AudioClip lockpickFailSound;

	private TextLabel tutoLabel;

	private bool firstLockpickTutorial;

	private bool hardLockpickTutorial;

	private bool hardLockpickTutorial2;

	private bool showTutoArrows;

	private DisableOnPause disableOnPause;

	public static Unlockable activeUnlockable;

	public static Unlockable waitingForProxyTutorial;

	public bool skipTutorialIfTouch;

	private float previousTouchRoll;

	public bool IsTutorial => firstLockpickTutorial || hardLockpickTutorial || hardLockpickTutorial2 || tutoLabel != null;

	private void Start()
	{
		playerLook = Player.GetLook(interaction: true);
		playerView = Player.GetLook();
		layerMask = LayerMaskExtensions.Create("Default", "TransparentFX", "LightCaster", "Collectable", "Prop", "StaticGeometry");
		LockIcon = null;
		ProgressIcon = null;
		Picking = false;
		Progress = 0f;
		BaseProgress = 0f;
		PickingSound = GetComponent<AudioSource>();
		BashProgress = 1000f;
		if (BashChance == null)
		{
			BashChance = new Permutator(1, 10, 3);
		}
		highlight = base.transform.parent.GetComponentInChildren<HighlightEffect>();
		if (difficultyLevel == Difficulty.Uninitialized)
		{
			InitLocked();
		}
		disableOnPause = GetComponent<DisableOnPause>();
		if (disableOnPause == null)
		{
			disableOnPause = base.gameObject.AddComponent<DisableOnPause>();
		}
		activeUnlockable = null;
		waitingForProxyTutorial = null;
	}

	public void InitLocked(Difficulty dif = Difficulty.Uninitialized)
	{
		Locked = true;
		if (dif == Difficulty.Uninitialized)
		{
			float value = UnityEngine.Random.value;
			if (value < 0.1f)
			{
				difficultyLevel = Difficulty.Very_Easy;
			}
			else if (value < 0.3f)
			{
				difficultyLevel = Difficulty.Easy;
			}
			else if (value < 0.85f)
			{
				difficultyLevel = Difficulty.Medium;
			}
			else if (value < 0.95f)
			{
				difficultyLevel = Difficulty.Hard;
			}
			else
			{
				difficultyLevel = Difficulty.Very_Hard;
			}
		}
		else
		{
			difficultyLevel = dif;
		}
		float min = 0.5f;
		float max = 1f;
		switch (difficultyLevel)
		{
		case Difficulty.Very_Easy:
			min = 0.5f;
			max = 0.75f;
			break;
		case Difficulty.Easy:
			min = 0.75f;
			max = 1.5f;
			break;
		case Difficulty.Medium:
			min = 1.5f;
			max = 2.5f;
			break;
		case Difficulty.Hard:
			min = 3f;
			max = 4f;
			break;
		case Difficulty.Very_Hard:
			min = 5f;
			max = 6f;
			break;
		}
		Strength = UnityEngine.Random.Range(min, max);
	}

	private void Update()
	{
		bool flag = false;
		playerLook = Player.GetLook(interaction: true);
		bool flag2 = false;
		Vector3 vector = playerLook.position - base.transform.position;
		Vector3 vector2 = playerView.position - base.transform.position;
		if ((bool)playerLook && vector.sqrMagnitude <= 25f)
		{
			float num = ((!InputExt.UsingHandControllers) ? 1f : GlobalParams.touchControllersDistanceFactor);
			if (Physics.Raycast(playerLook.position, playerLook.forward, out var hitInfo, OpenDistance * num, layerMask) && base.transform.IsChildOf(hitInfo.collider.transform))
			{
				flag2 = true;
			}
		}
		bool flag3 = false;
		if (OnlyForwardDirection && flag2)
		{
			Vector3 rhs = vector2.ToGround();
			Vector3 lhs = base.transform.forward.ToGround();
			rhs.Normalize();
			lhs.Normalize();
			if (Vector3.Dot(lhs, rhs) < 0f)
			{
				flag2 = false;
				flag3 = true;
			}
		}
		if (failTimer > 0f)
		{
			failTimer -= Time.deltaTime;
			flag2 = false;
		}
		if (highlight != null)
		{
			if (flag2 && (Locked || CanToggle))
			{
				highlight.FadeIn();
			}
			else
			{
				highlight.FadeOut();
			}
		}
		if (Locked && flag2)
		{
			activeUnlockable = this;
		}
		else if (activeUnlockable == this)
		{
			activeUnlockable = null;
		}
		if (showTutoArrows)
		{
			Player.GetController().ShowTutoArrows(flag2);
		}
		if (Locked && flag2 && !LockIcon)
		{
			Vector3 vector3 = new Vector3(0f, 0f, 1f);
			vector2.Normalize();
			fCosForward = Vector3.Dot(base.transform.forward, vector2);
			vLocalPos = vector3 * UIDistance * ((!(fCosForward < 0f)) ? 1f : (-1f));
			LockIcon = UnityEngine.Object.Instantiate(LockPrefabs[(int)difficultyLevel], Vector3.zero, Quaternion.identity);
			LockIcon.transform.parent = base.transform;
			LockIcon.transform.localPosition = vLocalPos;
			LockIcon.transform.localRotation = Quaternion.identity;
			ProgressIcon = UnityEngine.Object.Instantiate(ProgressPrefab, Vector3.zero, Quaternion.identity);
			ProgressIcon.transform.parent = base.transform;
			ProgressIcon.transform.localPosition = vLocalPos;
			ProgressIcon.transform.localRotation = Quaternion.Euler(0f, (!(fCosForward < 0f)) ? (-90f) : 90f, 270f);
			if (fCosForward < 0f)
			{
				LockIcon.transform.localRotation *= Quaternion.Euler(0f, 180f, 0f);
			}
			ProgressIcon.GetComponent<Renderer>().material.SetFloat("_Cutoff", 1f);
			LockIcon.transform.localScale = Vector3.zero;
			ProgressIcon.transform.localScale = Vector3.zero;
			LockIcon.transform.localPosition += Vector3.down * 0.05f;
			disableOnPause.targetObjs.Add(LockIcon);
			disableOnPause.targetObjs.Add(ProgressIcon);
			canUseLockpick = Player.GetInventory().GetNumItems(Collectable.EItemType.Lockpick) >= 1;
			lockpickTimer = 0f;
			if (GameController.Get().gameState.lockpicsUsedSuccesfully < 10)
			{
				upperWedgeCanMove = true;
				lowerWedgeCanMove = false;
			}
			else
			{
				upperWedgeCanMove = true;
				lowerWedgeCanMove = UnityEngine.Random.value <= 0.3f;
			}
			lowerWedgeCanMove = false;
			if (!tutoLabel && ((!InputExt.Using3DOFController && !InputExt.UsingHandControllers) || !skipTutorialIfTouch))
			{
				tutoLabel = Tutorial.ShowInPlace("TUTO_UNLOCK_1", vLocalPos + new Vector3(0f, 0.32f, 0f), Quaternion.Euler(0f, (!(fCosForward < 0f)) ? 180f : 0f, 0f), base.transform);
				if ((bool)tutoLabel && (InputExt.Using3DOFController || InputExt.UsingHandControllers))
				{
					Player.GetController().ShowTutoArrows();
					showTutoArrows = true;
				}
				if (!tutoLabel && canUseLockpick)
				{
					tutoLabel = Tutorial.ShowInPlace("TUTO_UNLOCK_2", vLocalPos + new Vector3(0f, 0.32f, 0f), Quaternion.Euler(0f, (!(fCosForward < 0f)) ? 180f : 0f, 0f), base.transform);
					if ((bool)tutoLabel)
					{
						lowerWedgeCanMove = (upperWedgeCanMove = false);
						firstLockpickTutorial = true;
						wedgeMoveFactor = 0f;
						if (InputExt.UsingHandControllers)
						{
							waitingForProxyTutorial = this;
						}
					}
					else if (!InputExt.Using3DOFController && !InputExt.UsingHandControllers)
					{
						tutoLabel = Tutorial.ShowInPlace("TUTO_UNLOCK_3", vLocalPos + new Vector3(0f, 0.32f, 0f), Quaternion.Euler(0f, (!(fCosForward < 0f)) ? 180f : 0f, 0f), base.transform);
						if ((bool)tutoLabel)
						{
							upperWedgeCanMove = true;
							lowerWedgeCanMove = false;
							wedgeMoveFactor = 0.65f;
							hardLockpickTutorial = true;
						}
					}
				}
			}
			if (InputExt.Using3DOFController || InputExt.UsingHandControllers)
			{
				canUseLockpick = false;
				upperWedgeCanMove = false;
				lowerWedgeCanMove = false;
			}
			upperWedge = UnityEngine.Object.Instantiate(WedgePregab).transform;
			lowerWedge = UnityEngine.Object.Instantiate(WedgePregab).transform;
			lowerWedgeAngle = UnityEngine.Random.Range(5f, 175f);
			upperWedgeAngle = UnityEngine.Random.Range(5f, 175f);
			lowerWedgeAngleTarget = UnityEngine.Random.Range(0f, 180f);
			upperWedgeAngleTarget = UnityEngine.Random.Range(0f, 180f);
			if (!upperWedgeCanMove)
			{
				upperWedgeAngle = (upperWedgeAngleTarget = 90f);
			}
			if (!lowerWedgeCanMove)
			{
				lowerWedgeAngle = (lowerWedgeAngleTarget = 90f);
			}
			lowerWedge.transform.parent = base.transform;
			lowerWedge.transform.localPosition = vLocalPos + new Vector3(0f, lowerWedgeDist, 0.001f * ((!(fCosForward < 0f)) ? 1f : (-1f)));
			lowerWedge.transform.localRotation = Quaternion.Euler(0f, (!(fCosForward < 0f)) ? 180f : 0f, (lowerWedgeAngle - 90f) * ((!(fCosForward > 0f)) ? 1f : (-1f)));
			lowerWedge.GetComponent<Renderer>().material.color = lowerWedge.GetComponent<Renderer>().material.color.WithAlpha(0f);
			upperWedge.transform.parent = base.transform;
			upperWedge.transform.localPosition = vLocalPos + new Vector3(0f, upperWedgeDist, 0.001f * ((!(fCosForward < 0f)) ? 1f : (-1f)));
			upperWedge.transform.localRotation = Quaternion.Euler(0f, (!(fCosForward < 0f)) ? 180f : 0f, (upperWedgeAngle - 90f + 180f) * ((!(fCosForward > 0f)) ? 1f : (-1f)));
			upperWedge.GetComponent<Renderer>().material.color = upperWedge.GetComponent<Renderer>().material.color.WithAlpha(0f);
			maxPlayerDistance = Mathf.Max(OpenDistance, (Player.GetGroundPos() - base.transform.position.ToGround()).magnitude);
			disableOnPause.targetObjs.Add(upperWedge.gameObject);
			disableOnPause.targetObjs.Add(lowerWedge.gameObject);
		}
		bool flag4 = InputExt.GetButton(InputExt.Button.Action);
		if (InputExt.UsingHandControllers && !Player.GetActionHand().IsVisible)
		{
			flag4 = false;
		}
		if (!Picking && flag2 && flag4 && !firstLockpickTutorial)
		{
			if (Locked)
			{
				Picking = true;
				Progress = 0f;
				PickingSound.Play(0uL);
				if (PlaySilence)
				{
					Jukebox.Get().PlaySilence();
				}
				Wiggler component = LockIcon.GetComponent<Wiggler>();
				if (component != null)
				{
					component.enabled = true;
				}
				StartTouchPickingProgress();
				if (CanBash && BashProgress > 1f)
				{
					bool flag5 = BashChance.Next;
					if (GameController.Get().levelOptions.safeMap)
					{
						flag5 = false;
					}
					Room room = Map.Get().At(base.transform.position).Room;
					if (room != null && room.Safe)
					{
						flag5 = false;
					}
					if (!flag5)
					{
						CanBash = false;
					}
					else
					{
						if (Strength <= 0.9f)
						{
							Strength = UnityEngine.Random.Range(1f, 2.5f);
						}
						BashProgress = UnityEngine.Random.Range(0.3f, 0.7f);
					}
				}
			}
			else if (CanToggle && InputExt.GetButtonDown(InputExt.Button.Action) && !GameController.Get().wasJustPaused)
			{
				Door.SendMessage("Toggle", Player.Get().transform);
			}
		}
		if (Picking)
		{
			if (InputExt.GetButton(InputExt.Button.Action))
			{
				float num2 = BaseProgress + Progress;
				if (InputExt.Using3DOFController || InputExt.UsingHandControllers)
				{
					Progress += GetTouchDeltaProgress();
					ApplyTouchHaptics();
				}
				else
				{
					Progress += Time.deltaTime / (2.5f * Strength);
				}
				Progress = Mathf.Clamp(Progress, 0f, 1f - BaseProgress);
				if ((double)(BaseProgress + Progress) + 0.001 >= 1.0)
				{
					PickingOpen();
				}
				if (CanBash && num2 <= BashProgress && BaseProgress + Progress > BashProgress)
				{
					Door.SendMessage("PlayBashWithMonster");
					CanBash = false;
				}
			}
			else
			{
				PickingSound.Stop();
				Picking = false;
			}
			ShowProgress(BaseProgress + Progress);
			if (!Picking)
			{
				Wiggler component2 = LockIcon.GetComponent<Wiggler>();
				if (component2 != null)
				{
					component2.enabled = false;
				}
			}
		}
		if (!Picking && Locked && BaseProgress + Progress > 0f)
		{
			Progress -= Time.deltaTime / 0.3f;
			Progress = Mathf.Clamp(Progress, 0f, 1f - BaseProgress);
			ShowProgress(BaseProgress + Progress);
		}
		flag = (flag2 && Locked) || Picking;
		if (Picking)
		{
			float sqrMagnitude = (Player.GetGroundPos() - base.transform.position.ToGround()).sqrMagnitude;
			if (sqrMagnitude > maxPlayerDistance * maxPlayerDistance || flag3)
			{
				flag = false;
				PickingSound.Stop();
				Picking = false;
			}
		}
		if (flag)
		{
			LockIcon.transform.localScale = Vector3.Slerp(LockIcon.transform.localScale, Vector3.one, Time.deltaTime * 10f);
			ProgressIcon.transform.localScale = Vector3.Slerp(ProgressIcon.transform.localScale, new Vector3(0.06f, 0.06f, 0.06f), Time.deltaTime * 10f);
			Player.GetMinimapPos().Hide = true;
			UpdateWedges();
			if (canUseLockpick && InputExt.GetButtonDown(InputExt.Button.Lockpick))
			{
				if (Player.GetInventory().ConsumeItem(Collectable.EItemType.Lockpick))
				{
					if (lockpickTimer > 0f)
					{
						BaseProgress += 1.5f / Strength;
						BaseProgress = Mathf.Clamp(BaseProgress, 0f, 0.95f);
						lockpickTimer = 0f;
						if ((bool)lockpickSuccessSound)
						{
							AudioSource.PlayClipAtPoint(lockpickSuccessSound, base.transform.position);
						}
						PlayLockpickFade();
						if (firstLockpickTutorial)
						{
							firstLockpickTutorial = false;
							if ((bool)tutoLabel)
							{
								tutoLabel.Text = Translate.GetForInput("TUTO_UNLOCK_2b");
							}
						}
						if (hardLockpickTutorial)
						{
							hardLockpickTutorial = false;
							hardLockpickTutorial2 = true;
							if ((bool)tutoLabel)
							{
								tutoLabel.Text = Translate.GetForInput("TUTO_UNLOCK_3b");
							}
						}
						GameController.Get().gameState.lockpicsUsedSuccesfully++;
					}
					else
					{
						BaseProgress = 0f;
						Progress = 0f;
						if ((bool)lockpickFailSound)
						{
							AudioSource.PlayClipAtPoint(lockpickFailSound, base.transform.position);
						}
						PlayLockpickFade(failed: true);
						failTimer = 0.25f;
						PickingSound.Stop();
						Picking = false;
						if (firstLockpickTutorial)
						{
							firstLockpickTutorial = false;
						}
						if (hardLockpickTutorial)
						{
							hardLockpickTutorial = false;
							hardLockpickTutorial2 = true;
							if ((bool)tutoLabel)
							{
								if (Player.GetInventory().GetNumItems(Collectable.EItemType.Lockpick) >= 1)
								{
									tutoLabel.Text = Translate.GetForInput("TUTO_UNLOCK_3b");
								}
								else
								{
									tutoLabel.Text = Translate.GetForInput("TUTO_UNLOCK_3c");
								}
							}
						}
						else if (hardLockpickTutorial2 && Player.GetInventory().GetNumItems(Collectable.EItemType.Lockpick) <= 0)
						{
							hardLockpickTutorial2 = false;
							if ((bool)tutoLabel)
							{
								tutoLabel.Text = Translate.GetForInput("TUTO_UNLOCK_3d");
							}
						}
					}
					Progress = Mathf.Clamp(Progress, 0f, 1f - BaseProgress);
					ShowProgress(BaseProgress + Progress);
				}
				canUseLockpick = Player.GetInventory().GetNumItems(Collectable.EItemType.Lockpick) >= 1;
			}
		}
		else if ((bool)LockIcon)
		{
			LockIcon.transform.localScale = Vector3.Lerp(LockIcon.transform.localScale, Vector3.zero, Time.deltaTime * 7.5f);
			ProgressIcon.transform.localScale = Vector3.Lerp(ProgressIcon.transform.localScale, Vector3.zero, Time.deltaTime * 7.5f);
			upperWedge.transform.localScale = Vector3.Lerp(upperWedge.transform.localScale, Vector3.zero, Time.deltaTime * 7.5f);
			lowerWedge.transform.localScale = Vector3.Lerp(lowerWedge.transform.localScale, Vector3.zero, Time.deltaTime * 7.5f);
			Color b = upperWedge.GetComponent<Renderer>().material.color.WithAlpha(0f);
			upperWedge.GetComponent<Renderer>().material.color = Color.Lerp(upperWedge.GetComponent<Renderer>().material.color, b, Time.deltaTime * 20f);
			lowerWedge.GetComponent<Renderer>().material.color = Color.Lerp(lowerWedge.GetComponent<Renderer>().material.color, b, Time.deltaTime * 20f);
			if (LockIcon.transform.localScale.x <= 0.05f)
			{
				UnityEngine.Object.Destroy(LockIcon);
				UnityEngine.Object.Destroy(ProgressIcon);
				UnityEngine.Object.Destroy(upperWedge.gameObject);
				UnityEngine.Object.Destroy(lowerWedge.gameObject);
				LockIcon = null;
				ProgressIcon = null;
				upperWedge = null;
				lowerWedge = null;
				disableOnPause.targetObjs.Clear();
			}
		}
		if (!Locked && (bool)tutoLabel)
		{
			tutoLabel.FadeOut(4f, disableOnFadeOut: true, destroyOnFadeOut: true);
			tutoLabel = null;
			if (InputExt.Using3DOFController || InputExt.UsingHandControllers)
			{
				Player.GetController().ShowTutoArrows(visible: false);
				showTutoArrows = false;
			}
		}
	}

	private void PickingOpen()
	{
		Picking = false;
		Locked = false;
		PickingSound.Stop();
		if (InputExt.UsingHandControllers)
		{
			Player.GetActionHand().PlayHapticUnlock();
		}
		AudioSource.PlayClipAtPoint(UnlockSound, base.transform.position);
		Door.SendMessage("Open", Player.Get().transform);
		if ((bool)tutoLabel)
		{
			tutoLabel.FadeOut(4f, disableOnFadeOut: true, destroyOnFadeOut: true);
			tutoLabel = null;
		}
		if (InputExt.Using3DOFController || InputExt.UsingHandControllers)
		{
			Player.GetController().ShowTutoArrows(visible: false);
			showTutoArrows = false;
		}
	}

	private void ShowProgress(float progress)
	{
		if ((bool)ProgressIcon)
		{
			ProgressIcon.GetComponent<Renderer>().material.SetFloat("_Cutoff", 1f - progress * 0.58f);
		}
	}

	private void UpdateWedges()
	{
		float num = 50f;
		if (difficultyLevel <= Difficulty.Easy)
		{
			num = 40f;
		}
		else if (difficultyLevel >= Difficulty.Hard)
		{
			num = 60f;
		}
		num *= wedgeMoveFactor;
		if (upperWedgeCanMove)
		{
			bool flag = upperWedgeAngle < upperWedgeAngleTarget;
			upperWedgeAngle += num * Time.deltaTime * ((!(upperWedgeAngleTarget > upperWedgeAngle)) ? (-1f) : 1f);
			upperWedgeAngle = Mathf.Clamp(upperWedgeAngle, 0f, 180f);
			if (upperWedgeAngle < upperWedgeAngleTarget != flag)
			{
				float num2 = ((difficultyLevel > Difficulty.Medium) ? 15f : 25f);
				int num3 = 5;
				while (num3 > 0 && Mathf.Abs(upperWedgeAngleTarget - upperWedgeAngle) <= num2)
				{
					upperWedgeAngleTarget = UnityEngine.Random.Range(0f, 180f);
					num3--;
				}
			}
		}
		if (lowerWedgeCanMove)
		{
			bool flag2 = lowerWedgeAngle < lowerWedgeAngleTarget;
			lowerWedgeAngle += num * Time.deltaTime * ((!(lowerWedgeAngleTarget > lowerWedgeAngle)) ? (-1f) : 1f);
			lowerWedgeAngle = Mathf.Clamp(lowerWedgeAngle, 0f, 180f);
			if (lowerWedgeAngle < lowerWedgeAngleTarget != flag2)
			{
				float num4 = ((difficultyLevel > Difficulty.Medium) ? 15f : 25f);
				int num5 = 5;
				while (num5 > 0 && Mathf.Abs(lowerWedgeAngleTarget - lowerWedgeAngle) <= num4)
				{
					lowerWedgeAngleTarget = UnityEngine.Random.Range(0f, 180f);
					num5--;
				}
			}
		}
		upperWedge.transform.localScale = Vector3.Slerp(upperWedge.transform.localScale, new Vector3(0.05f, 0.05f, 0.05f), Time.deltaTime * 10f);
		lowerWedge.transform.localScale = Vector3.Slerp(lowerWedge.transform.localScale, new Vector3(0.05f, 0.05f, 0.05f), Time.deltaTime * 10f);
		Color to = ((!canUseLockpick) ? upperWedge.GetComponent<Renderer>().material.color.WithAlpha(0f) : upperWedge.GetComponent<Renderer>().material.color.WithAlpha(1f));
		upperWedge.GetComponent<Renderer>().material.color = Interpolate.EaseInOut(upperWedge.GetComponent<Renderer>().material.color, to, Time.deltaTime * 20f);
		lowerWedge.GetComponent<Renderer>().material.color = Interpolate.EaseInOut(lowerWedge.GetComponent<Renderer>().material.color, to, Time.deltaTime * 20f);
		lowerWedge.transform.localPosition = vLocalPos + new Vector3(Mathf.Cos(lowerWedgeAngle * ((float)Math.PI / 180f)) * lowerWedgeDist, Mathf.Sin(lowerWedgeAngle * ((float)Math.PI / 180f)) * lowerWedgeDist, 0.001f * ((!(fCosForward < 0f)) ? 1f : (-1f)));
		upperWedge.transform.localPosition = vLocalPos + new Vector3(Mathf.Cos(upperWedgeAngle * ((float)Math.PI / 180f)) * upperWedgeDist, Mathf.Sin(upperWedgeAngle * ((float)Math.PI / 180f)) * upperWedgeDist, 0.001f * ((!(fCosForward < 0f)) ? 1f : (-1f)));
		lowerWedge.transform.localRotation = Quaternion.Euler(0f, (!(fCosForward < 0f)) ? 180f : 0f, (lowerWedgeAngle - 90f) * ((!(fCosForward > 0f)) ? 1f : (-1f)));
		upperWedge.transform.localRotation = Quaternion.Euler(0f, (!(fCosForward < 0f)) ? 180f : 0f, (upperWedgeAngle - 90f + 180f) * ((!(fCosForward > 0f)) ? 1f : (-1f)));
		float num6 = 3f;
		float num7 = Mathf.Abs(upperWedgeAngle - lowerWedgeAngle);
		bool flag3 = num7 <= num6;
		float @float = upperWedge.GetComponent<Renderer>().material.GetFloat("_LitProgress");
		@float = ((!flag3) ? Interpolate.Approach(@float, 0f, Time.deltaTime * 5f) : 1f);
		upperWedge.GetComponent<Renderer>().material.SetFloat("_LitProgress", @float);
		lowerWedge.GetComponent<Renderer>().material.SetFloat("_LitProgress", @float);
		if (flag3)
		{
			float num8 = 0.1f;
			num8 += 0.1f;
			if (difficultyLevel <= Difficulty.Very_Easy)
			{
				lockpickTimer = 0.2f + num8;
			}
			else if (difficultyLevel <= Difficulty.Medium)
			{
				lockpickTimer = 0.1f + num8;
			}
			else
			{
				lockpickTimer = 0.1f + num8;
			}
		}
		else if (lockpickTimer > 0f)
		{
			lockpickTimer -= Time.deltaTime;
		}
	}

	private void PlayLockpickFade(bool failed = false)
	{
		Vector3 vector = LockIcon.transform.position - LockIcon.transform.up * 0.25f;
		Vector3 position = Player.GetInventory().transform.position;
		GameObject gameObject = UnityEngine.Object.Instantiate(lockpickPrefab, vector, Quaternion.identity);
		gameObject.transform.parent = base.transform;
		gameObject.transform.localRotation = Quaternion.Euler(40f, 90f, -90f);
		gameObject.transform.parent = null;
		gameObject.transform.position = position;
		gameObject.GetComponent<Collider>().enabled = false;
		StartCoroutine(PlayLockpickFade_co(gameObject, position, vector));
	}

	private IEnumerator PlayLockpickFade_co(GameObject lockpick, Vector3 initPos, Vector3 targetPos)
	{
		float t = 0f;
		Renderer rend = lockpick.GetComponentInChildren<Renderer>();
		for (; t <= 1.5f; t += Time.deltaTime * 1.4f)
		{
			Vector3 newPos = Interpolate.EaseOutCubic(initPos, targetPos, Mathf.Clamp01(t));
			lockpick.transform.position = newPos;
			float alpha = Interpolate.EaseOutCubic(1f, 0f, Mathf.Clamp01(t - 0.2f));
			rend.material.color = new Color(1f, 1f, 1f, alpha);
			yield return new WaitForEndOfFrame();
		}
		UnityEngine.Object.Destroy(lockpick.gameObject);
	}

	private float GetTouchDeltaProgress()
	{
		Transform actionHandTransform = Player.GetActionHandTransform();
		float z = actionHandTransform.parent.localRotation.eulerAngles.z;
		float num = Mathf.Abs(Mathf.DeltaAngle(previousTouchRoll, z));
		previousTouchRoll = z;
		return num * (0.135f * Time.deltaTime / (Strength * 1.5f));
	}

	private void StartTouchPickingProgress()
	{
		Transform actionHandTransform = Player.GetActionHandTransform();
		previousTouchRoll = actionHandTransform.parent.localRotation.eulerAngles.z;
	}

	private void ApplyTouchHaptics()
	{
		float z = Player.GetActionHandTransform().parent.localRotation.eulerAngles.z;
		float num = Mathf.PerlinNoise(z / 36f, 0f);
		if (num < 0.6f)
		{
			num = 0f;
		}
		float t = Mathf.PerlinNoise(z / 36f, 0.5f);
		float freq = Interpolate.Lerp(0.15f, 0.3f, t);
		Player.GetActionHand().PlayHaptic(freq, num * 0.5f, 1f / 60f);
	}

	public static bool UseLockpick()
	{
		if (activeUnlockable == null)
		{
			return false;
		}
		activeUnlockable.BaseProgress = Mathf.Max(activeUnlockable.BaseProgress, 0.95f);
		if ((bool)activeUnlockable.lockpickSuccessSound)
		{
			AudioSource.PlayClipAtPoint(activeUnlockable.lockpickSuccessSound, activeUnlockable.transform.position);
		}
		GameController.Get().gameState.lockpicsUsedSuccesfully++;
		if (activeUnlockable.firstLockpickTutorial)
		{
			activeUnlockable.firstLockpickTutorial = false;
			if ((bool)activeUnlockable.tutoLabel)
			{
				activeUnlockable.tutoLabel.Text = Translate.GetForInput("TUTO_UNLOCK_2b");
			}
		}
		return true;
	}

	private void OnUseHandLockpick(GameObject lockpick)
	{
		Unlockable unlockable = activeUnlockable;
		activeUnlockable = this;
		UseLockpick();
		activeUnlockable = unlockable;
	}

	public void ShowProxyLockpickTutorial()
	{
		if (firstLockpickTutorial && (bool)tutoLabel)
		{
			tutoLabel.Text = Translate.GetForInput("TUTO_UNLOCK_2_PROXY");
			waitingForProxyTutorial = null;
		}
	}
}
public class Wiggler : MonoBehaviour
{
	public Vector3 range;

	public float wiggleTime = 0.2f;

	private Vector3 initPos;

	private float timeToWiggle;

	private void Start()
	{
		initPos = base.transform.localPosition;
	}

	private void Update()
	{
		timeToWiggle += Time.deltaTime;
		if (timeToWiggle >= wiggleTime)
		{
			Vector3 vector = new Vector3(UnityEngine.Random.Range(0f - range.x, range.x), UnityEngine.Random.Range(0f - range.y, range.y), UnityEngine.Random.Range(0f - range.z, range.z));
			base.transform.localPosition = initPos + vector;
			timeToWiggle -= wiggleTime;
		}
	}

	private void OnDisable()
	{
		base.transform.localPosition = initPos;
	}
}
public class AdjustBodyToCamera : MonoBehaviour
{
	public PicoPlayerController playerController;

	public AntiBodyDelta[] antiDeltas;

	private void Start()
	{
		if (InputExt.UsingHandControllers)
		{
			playerController.adjustBodyToggle = true;
		}
	}

	private void Update()
	{
		if (!InputExt.UsingHandControllers || GameController.Get().Paused)
		{
			return;
		}
		Vector3 centerEye = Player.GetCenterEye();
		Vector3 vector = (centerEye - base.transform.position).ToGround();
		if (!(vector != Vector3.zero))
		{
			return;
		}
		playerController.adjustBodyMove = vector;
		playerController.adjustBodyToggle = true;
		for (int i = 0; i < antiDeltas.Length; i++)
		{
			if (antiDeltas[i].enabled)
			{
				antiDeltas[i].AddDelta(playerController.actualBodyMove);
			}
			else
			{
				antiDeltas[i].delta = Vector3.zero;
			}
		}
	}
}
public class AntiBodyDelta : MonoBehaviour
{
	public Vector3 delta = Vector3.zero;

	private Vector3 originalPos;

	private bool hasOriginalPos;

	private Vector3 lastPos;

	private Vector3 targetPos;

	private void Start()
	{
	}

	private void Update()
	{
		if (InputExt.UsingHandControllers)
		{
			base.transform.position -= delta;
			delta = Vector3.zero;
		}
	}

	private void OnEnable()
	{
		if (!hasOriginalPos)
		{
			originalPos = base.transform.localPosition;
			hasOriginalPos = true;
		}
		else if (InputExt.UsingHandControllers)
		{
			base.transform.localPosition = originalPos;
		}
		delta = Vector3.zero;
		lastPos = base.transform.position;
		targetPos = lastPos;
	}

	private void OnDisable()
	{
		delta = Vector3.zero;
	}

	public void AddDelta(Vector3 newDelta)
	{
		delta += newDelta;
	}
}
public class CameraClip : MonoBehaviour
{
	public Vector3 centerPos;

	public float colliderRadius = 0.05f;

	public Vector3 currentPos;

	public LayerMask collisionMask;

	private void Update()
	{
		Vector3 vector = base.transform.TransformPoint(centerPos);
		Vector3 vector2 = base.transform.TransformPoint(currentPos);
		Vector3 vector3 = Clip(vector, vector2, colliderRadius, collisionMask);
		Debug.DrawLine(vector, vector3, Color.green);
		Debug.DrawLine(vector3, vector2, Color.blue);
		DebugExt.DrawSphere(vector3, Color.red, colliderRadius);
	}

	public static Vector3 Clip(Vector3 origin, Vector3 curPos, float radius, LayerMask mask)
	{
		Vector3 vector = curPos - origin;
		float magnitude = vector.magnitude;
		vector /= magnitude;
		if (Physics.Raycast(origin, vector, out var hitInfo, (int)mask))
		{
			float magnitude2 = (hitInfo.point - origin).magnitude;
			float num = magnitude2 - radius;
			if (num < magnitude)
			{
				return origin + vector * num;
			}
		}
		return curPos;
	}
}
public class CameraClipTester : MonoBehaviour
{
	public Vector3 centerPos;

	public float colliderRadius = 0.05f;

	public Vector3 currentPos;

	public LayerMask collisionMask;

	private void Update()
	{
		Vector3 vector = base.transform.TransformPoint(centerPos);
		Vector3 vector2 = base.transform.TransformPoint(currentPos);
		Vector3 vector3 = Clip(vector, vector2, colliderRadius, collisionMask);
		Debug.DrawLine(vector, vector3, Color.green);
		Debug.DrawLine(vector3, vector2, Color.blue);
		DebugExt.DrawSphere(vector3, Color.red, colliderRadius);
	}

	public static Vector3 Clip(Vector3 origin, Vector3 curPos, float radius, LayerMask mask)
	{
		Vector3 vector = curPos - origin;
		float magnitude = vector.magnitude;
		vector /= magnitude;
		if (Physics.Raycast(origin, vector, out var hitInfo, (int)mask))
		{
			float magnitude2 = (hitInfo.point - origin).magnitude;
			float num = magnitude2 - radius;
			if (num < magnitude)
			{
				return origin + vector * num;
			}
		}
		return curPos;
	}
}
public class CenterIPD : MonoBehaviour
{
	private void Start()
	{
		Vector3 localPosition = base.transform.localPosition;
		if ((bool)GameObject.Find("Player/Pvr_SDKManager/Head/LeftEye"))
		{
			float x = GameObject.Find("Player/Pvr_SDKManager/Head/LeftEye").transform.localPosition.x;
			localPosition.x -= x;
			base.transform.localPosition = localPosition;
		}
	}
}
public class ControllerModel : MonoBehaviour
{
	public GameObject m_modelGearVrController;

	public GameObject m_modelOculusGoController;

	public int m_controller;

	private bool m_prevControllerConnected;

	private bool m_prevControllerConnectedCached;

	private void Start()
	{
	}

	private void Update()
	{
		bool flag = InputExt.Using3DOFController && ((InputExt.RightHanded && m_controller == 1) || (!InputExt.RightHanded && m_controller == 0));
		if (flag != m_prevControllerConnected || !m_prevControllerConnectedCached)
		{
			m_modelOculusGoController.SetActive(flag && InputExt.IsOculusGo);
			m_modelGearVrController.SetActive(flag && !InputExt.IsOculusGo);
			m_prevControllerConnected = flag;
			m_prevControllerConnectedCached = true;
		}
		if (flag)
		{
		}
	}
}
public class EyeClip : MonoBehaviour
{
	public Transform originRef;

	public LayerMask collisionMask;

	public float clippingFactor;

	public LayerMask closeClipMask;

	public float closeClipDistance = 0.15f;

	private LayerMask hiderMask;

	private LayerMask hiderMaskClose;

	private static RaycastHit[] hitResults;

	private void Start()
	{
		hiderMask = collisionMask.Inverse();
		hiderMaskClose = closeClipMask.Inverse();
		hitResults = new RaycastHit[32];
	}

	private void Update()
	{
		Vector3 localPosition = GetComponent<Camera>().transform.localPosition;
		Vector3 position = base.transform.position;
		Vector3 position2 = originRef.position;
		clippingFactor = 0f;
		Vector3 vector = Clip(position2, position, 0.1f, collisionMask, hiderMask, out clippingFactor);
	}

	public static Vector3 Clip(Vector3 origin, Vector3 curPos, float radius, LayerMask mask, LayerMask hiderMask, out float clippingFactor)
	{
		clippingFactor = 0f;
		Vector3 vector = curPos - origin;
		float magnitude = vector.magnitude;
		vector /= magnitude;
		int num = Physics.RaycastNonAlloc(origin, vector, hitResults, magnitude + radius * 2f, mask, QueryTriggerInteraction.Ignore);
		for (int i = 0; i < num; i++)
		{
			RaycastHit raycastHit = hitResults[i];
			if ((hiderMask.value & (1 << raycastHit.collider.gameObject.layer)) != 0)
			{
				continue;
			}
			float magnitude2 = (raycastHit.point - origin).magnitude;
			float num2 = magnitude2 - radius;
			if (num2 < magnitude)
			{
				clippingFactor = 1f;
				return origin + vector * num2;
			}
			if (num2 - magnitude <= 0.2f)
			{
				float num3 = Mathf.Lerp(1f, 0f, (num2 - magnitude) / 0.2f);
				num3 *= num3;
				if (num3 > clippingFactor)
				{
					clippingFactor = num3;
				}
			}
		}
		return curPos;
	}

	public static void CloseClip(Vector3 origin, Vector3 direction, float minDist, float maxDist, LayerMask mask, LayerMask hiderMask, out float clipFactor)
	{
		clipFactor = 0f;
		if (Physics.Raycast(origin, direction, out var hitInfo, (int)mask) && (hiderMask.value & (1 << hitInfo.collider.gameObject.layer)) == 0)
		{
			float magnitude = (hitInfo.point - origin).magnitude;
			if (magnitude <= minDist)
			{
				clipFactor = 1f;
			}
			else if (magnitude > minDist && magnitude <= maxDist)
			{
				clipFactor = Mathf.Lerp(1f, 0f, (magnitude - minDist) / (maxDist - minDist));
			}
		}
	}
}
public class FearEffect : MonoBehaviour
{
	public AudioClip[] shortGasps;

	public AudioSource scaredBreathing;

	public Monochromize[] monoEffects;

	public float maxMonoIntensity = 1f;

	public float maxBreathingVolume = 0.4f;

	public float scareTime = 5f;

	public float volumeSpeedIn = 0.5f;

	public float volumeSpeedOut = 0.5f;

	public float monoSpeedIn = 0.5f;

	public float monoSpeedOut = 0.5f;

	private static FearEffect instance;

	public bool inTension;

	private float tensionTimer;

	private float monoIntensity;

	private float breathingVol;

	private void Awake()
	{
		instance = this;
	}

	public static FearEffect Get()
	{
		return instance;
	}

	public void Start()
	{
		inTension = false;
		tensionTimer = 0f;
		scaredBreathing.Stop();
		monoIntensity = 0f;
		breathingVol = 0f;
		monoEffects = new Monochromize[0];
	}

	private void Update()
	{
		float b = 0f;
		float b2 = 0f;
		if (inTension)
		{
			b = maxBreathingVolume;
			b2 = maxMonoIntensity;
			tensionTimer -= Time.deltaTime;
			if (tensionTimer <= 0f)
			{
				inTension = false;
			}
		}
		float num = ((!inTension) ? volumeSpeedOut : volumeSpeedIn);
		float num2 = ((!inTension) ? monoSpeedOut : monoSpeedIn);
		breathingVol = Mathf.Lerp(breathingVol, b, Time.deltaTime * num);
		monoIntensity = Mathf.Lerp(monoIntensity, b2, Time.deltaTime * num2);
		scaredBreathing.volume = breathingVol;
		if (breathingVol > 0f && !scaredBreathing.isPlaying)
		{
			scaredBreathing.Play();
		}
		else if (breathingVol <= 0.01f && scaredBreathing.isPlaying)
		{
			scaredBreathing.Stop();
		}
		for (int i = 0; i < monoEffects.Length; i++)
		{
			Monochromize monochromize = monoEffects[i];
			if (monochromize.enabled != monoIntensity > 0.01f)
			{
				monochromize.enabled = monoIntensity > 0.01f;
			}
			monochromize.intensity = monoIntensity;
			monochromize.brightnessFactor = 1.2f;
		}
	}

	public void Scare(bool jumpScare = false)
	{
		if (!jumpScare)
		{
			inTension = true;
			tensionTimer = Mathf.Max(tensionTimer, scareTime);
			return;
		}
		AudioSource.PlayClipAtPoint(RandomExt.Choice(shortGasps), base.transform.position);
		if (inTension)
		{
			breathingVol = 0f;
		}
	}
}
public class NeckTracker : MonoBehaviour
{
	public Transform picoCamera;

	private void Update()
	{
		Vector3 position = picoCamera.position;
		base.transform.localPosition = position;
	}
}
public class PauseSphere : TimeIndependentBehaviour
{
	private float factor;

	private Vector3 origScale;

	private Material material;

	private void Start()
	{
		origScale = base.transform.localScale;
		material = GetComponent<Renderer>().material;
	}

	protected override void Update()
	{
		base.Update();
		if (GameController.Get().Paused)
		{
			factor += base.deltaTime * 2f;
		}
		else
		{
			factor -= base.deltaTime * 2f;
		}
		factor = Mathf.Clamp01(factor);
		float num = Interpolate.EaseInOutCubic(0f, 1f, factor);
		base.transform.localScale = new Vector3(origScale.x * num, origScale.y, origScale.z * num);
		material.SetFloat("_Opacity", num);
		GetComponent<Renderer>().enabled = num != 0f;
	}
}
public class Player
{
	private static GameObject playerRef;

	private static Transform playerLook;

	private static Transform playerRightHandTransform;

	private static Transform playerLeftHandTransform;

	private static PlayerHand playerRightHand;

	private static PlayerHand playerLeftHand;

	private static Transform playerActionHandTransform;

	private static Transform playerLampHandTransform;

	private static PlayerHand playerActionHand;

	private static PlayerHand playerLampHand;

	private static Transform playerHandLook;

	private static Transform playerForwardDir;

	private static MinimapPosition playerMinimapPos;

	private static Inventory playerInventory;

	private static UICrosshair3D crosshair;

	private static TorchFuel playerTorchFuel;

	public static PlayerGameController Controller => Get().GetComponent<PlayerGameController>();

	public static Transform Look => GetLook();

	public static Vector3 LookDir => GetLook().forward;

	public static Vector3 CenterEye => GetLook().position;

	public static Transform ForwardDirection => GetForwardDirection();

	public static Vector3 Pos => Vector3Ext.GroundVector(Get().transform.position);

	public static Vector3 GroundPos => Vector3Ext.GroundVector(Get().transform.position);

	private static void SetPlayerRef()
	{
		playerRef = GameObject.FindWithTag(Tags.Player);
	}

	private static void SetPlayerLookRef()
	{
		if ((bool)GameObject.FindWithTag(Tags.LookDirection))
		{
			playerLook = GameObject.FindWithTag(Tags.LookDirection).transform;
		}
		else
		{
			playerLook = GameObject.Find("Player/Pvr_UnitySDK/Head/LookDirection").transform;
		}
		if (!playerLook)
		{
			Debug.Log("no look");
			Debug.Break();
		}
	}

	private static void SetPlayerHandsRefs()
	{
		if ((bool)GameObject.FindWithTag(Tags.LeftHand))
		{
			playerLeftHandTransform = GameObject.FindWithTag(Tags.LeftHand).transform;
		}
		else
		{
			playerLeftHandTransform = GameObject.Find("Player/Pvr_UnitySDK/ControllerManager/PvrController0/LeftHandAnchor").transform;
		}
		if ((bool)GameObject.FindWithTag(Tags.RightHand))
		{
			playerRightHandTransform = GameObject.FindWithTag(Tags.RightHand).transform;
		}
		else
		{
			playerRightHandTransform = GameObject.Find("Player/Pvr_UnitySDK/ControllerManager/PvrController1/RightHandAnchor").transform;
		}
		playerLeftHand = playerLeftHandTransform.GetComponentInChildren<PlayerHand>();
		playerRightHand = playerRightHandTransform.GetComponentInChildren<PlayerHand>();
		if (InputExt.HasHandControllers)
		{
			playerActionHandTransform = ((!InputExt.LeftHanded) ? playerRightHandTransform : playerLeftHandTransform);
			playerLampHandTransform = ((!InputExt.LeftHanded) ? playerLeftHandTransform : playerRightHandTransform);
			playerActionHand = ((!InputExt.LeftHanded) ? playerRightHand : playerLeftHand);
			playerLampHand = ((!InputExt.LeftHanded) ? playerLeftHand : playerRightHand);
		}
	}

	public static void ResetPlayerHands()
	{
		playerLeftHandTransform = (playerRightHandTransform = null);
		playerLeftHand = (playerRightHand = null);
		playerActionHandTransform = (playerLampHandTransform = null);
		playerActionHand = (playerLampHand = null);
	}

	private static void SetPlayerHandsLookRefs()
	{
		Transform transform = null;
		Transform transform2 = null;
		transform = ((!GameObject.FindWithTag(Tags.LeftHandLook)) ? GameObject.Find("Player/Pvr_UnitySDK/ControllerManager/PvrController0/LeftHandAnchor/LeftHandLook").transform : GameObject.FindWithTag(Tags.LeftHandLook).transform);
		transform2 = ((!GameObject.FindWithTag(Tags.RightHandLook)) ? GameObject.Find("Player/Pvr_UnitySDK/ControllerManager/PvrController1/RightHandAnchor/RightHandLook").transform : GameObject.FindWithTag(Tags.RightHandLook).transform);
		playerHandLook = ((!InputExt.LeftHanded) ? transform2 : transform);
	}

	private static void SetPlayerForwardDirRef()
	{
		playerForwardDir = GameObject.FindWithTag(Tags.ForwardDirection).transform;
	}

	private static void SetPlayerMinimapPosRef()
	{
		playerMinimapPos = GameObject.FindWithTag(Tags.Minimap).GetComponent<MinimapPosition>();
	}

	private static void SetPlayerInventory()
	{
		playerInventory = GameObject.FindWithTag(Tags.Inventory).GetComponent<Inventory>();
	}

	private static void SetPlayerCrosshair()
	{
		crosshair = Get().transform.Find("Crosshair").GetComponent<UICrosshair3D>();
	}

	private static void SetPlayerTorchFuel()
	{
		playerTorchFuel = GameObject.FindWithTag(Tags.PlayerTorch).GetComponent<TorchFuel>();
	}

	public static GameObject Get()
	{
		if (!playerRef)
		{
			SetPlayerRef();
		}
		return playerRef;
	}

	public static PlayerGameController GetController()
	{
		return Get().GetComponent<PlayerGameController>();
	}

	public static T GetComponent<T>() where T : Component
	{
		return Get().GetComponent<T>();
	}

	public static T GetComponentInChildren<T>() where T : Component
	{
		return Get().GetComponentInChildren<T>();
	}

	public static Transform GetLook(bool interaction = false)
	{
		if (!playerLook)
		{
			SetPlayerLookRef();
		}
		if (interaction && InputExt.UsingHandControllers)
		{
			if (!playerHandLook)
			{
				SetPlayerHandsLookRefs();
			}
			return playerHandLook;
		}
		return playerLook;
	}

	public static Vector3 GetLookDir()
	{
		return GetLook().forward;
	}

	public static Vector3 GetCenterEye()
	{
		return GetLook().position;
	}

	public static Transform Get3DOFController()
	{
		if (InputExt.Using3DOFController)
		{
			if (!playerRightHand && !playerLeftHand)
			{
				SetPlayerHandsRefs();
			}
			return (!InputExt.RightHanded) ? playerLeftHandTransform : playerRightHandTransform;
		}
		return null;
	}

	public static Transform GetLeftHandTransform()
	{
		if (!playerLeftHandTransform)
		{
			SetPlayerHandsRefs();
		}
		return playerLeftHandTransform;
	}

	public static Transform GetRightHandTransform()
	{
		if (!playerRightHandTransform)
		{
			SetPlayerHandsRefs();
		}
		return playerRightHandTransform;
	}

	public static PlayerHand GetLeftHand()
	{
		if (!InputExt.UsingHandControllers)
		{
			return null;
		}
		if (!playerLeftHand)
		{
			SetPlayerHandsRefs();
		}
		return playerLeftHand;
	}

	public static PlayerHand GetRightHand()
	{
		if (!InputExt.UsingHandControllers)
		{
			return null;
		}
		if (!playerRightHand)
		{
			SetPlayerHandsRefs();
		}
		return playerRightHand;
	}

	public static Transform GetActionHandTransform()
	{
		if (!InputExt.UsingHandControllers)
		{
			return null;
		}
		if (!playerActionHandTransform)
		{
			SetPlayerHandsRefs();
		}
		return playerActionHandTransform;
	}

	public static Transform GetLampHandTransform()
	{
		if (!InputExt.UsingHandControllers)
		{
			return null;
		}
		if (!playerLampHandTransform)
		{
			SetPlayerHandsRefs();
		}
		return playerLampHandTransform;
	}

	public static PlayerHand GetActionHand()
	{
		if (!InputExt.UsingHandControllers)
		{
			return null;
		}
		if (!playerActionHand)
		{
			SetPlayerHandsRefs();
		}
		return playerActionHand;
	}

	public static PlayerHand GetLampHand()
	{
		if (!InputExt.UsingHandControllers)
		{
			return null;
		}
		if (!playerLampHand)
		{
			SetPlayerHandsRefs();
		}
		return playerLampHand;
	}

	public static MinimapPosition GetMinimapPos()
	{
		if (!playerMinimapPos)
		{
			SetPlayerMinimapPosRef();
		}
		return playerMinimapPos;
	}

	public static Inventory GetInventory()
	{
		if (!playerInventory)
		{
			SetPlayerInventory();
		}
		return playerInventory;
	}

	public static UICrosshair3D GetCrosshair()
	{
		if (!crosshair)
		{
			SetPlayerCrosshair();
		}
		return crosshair;
	}

	public static TorchFuel GetTorchFuel()
	{
		if (!playerTorchFuel)
		{
			SetPlayerTorchFuel();
		}
		return playerTorchFuel;
	}

	public static Transform GetForwardDirection()
	{
		if (!playerForwardDir)
		{
			SetPlayerForwardDirRef();
		}
		return playerForwardDir;
	}

	public static Vector3 GetPos()
	{
		return Vector3Ext.GroundVector(Get().transform.position);
	}

	public static Vector3 GetGroundPos()
	{
		return Vector3Ext.GroundVector(Get().transform.position);
	}

	public static Vector3 GetToPos(Vector3 from)
	{
		return GetPos() - from;
	}

	public static Vector3 GetToPosGround(Vector3 from)
	{
		return Vector3Ext.GroundVector(GetPos(), from);
	}

	public static bool IsSafe()
	{
		if (GameController.Get().levelOptions.safeMap)
		{
			return true;
		}
		Room room = Map.Get().At(GetPos()).Room;
		if (room != null && room.Safe)
		{
			return true;
		}
		return false;
	}

	public static void Clear()
	{
		playerRef = null;
		playerLook = null;
		playerForwardDir = null;
		playerMinimapPos = null;
		playerInventory = null;
	}
}
public class PlayerCollision : MonoBehaviour
{
	public virtual void OnPlayerCollision(GameObject player)
	{
	}
}
[RequireComponent(typeof(PicoPlayerController))]
public class PlayerGameController : MonoBehaviour
{
	public float WalkSpeed = 1f;

	public float RunSpeedFactor = 2f;

	public float RotationSpeed = 1f;

	public float StaminaConsumptionRate = 0.1f;

	public float StaminaRegenRate = 0.4f;

	public float StaminaTiredRegenRate = 0.2f;

	public float ScaredStaminaConsumptionMultiplier = 0.5f;

	public float TiredSpeedFactor = 0.7f;

	public float RunCooldown = 0.5f;

	private float runCooldownTimer;

	public AudioSource HeavyBreathSound;

	public float HeavyBreathMaxVolume = 1f;

	private float Health;

	public float HealthRegenRate = 0.2f;

	public Texture2D HurtTexture;

	public AudioClip HurtSlashSound;

	public AudioClip HurtSound;

	private Fader hurtEffect;

	private PicoPlayerController PicoController;

	private float Stamina;

	private bool Tired;

	private int movementBlocked;

	private int rotationBlocked;

	public bool isRunning;

	public List<Point> PathToExit;

	public Point CurrentCell;

	private Pathfinder Pathfinder;

	private Pathfinder.Query pathQuery;

	private FearEffect fearEffect;

	private EyeClip[] clipEyes;

	public Texture2D clipTexture;

	private AudioLowPassFilter lowPassFilter;

	public Renderer clipFader;

	public GameObject tutoArrowsLeft;

	public GameObject tutoArrowsRight;

	public GameObject[] handObjects;

	private void Start()
	{
		Debug.Log("PlayerGameController - Start");
		PicoController = GetComponent<PicoPlayerController>();
		PicoController.SetMoveScaleMultiplier(WalkSpeed);
		PicoController.SetRotationScaleMultiplierMouse(RotationSpeed * Config.Input().mouseSensitivity);
		PicoController.SetRotationScaleMultiplierPad(RotationSpeed * Config.Input().gamepadSensitivity);
		PicoController.SetSkipMouseRotation(skipMouseRotation: true);
		fearEffect = GetComponent<FearEffect>();
		clipEyes = GetComponentsInChildren<EyeClip>();
		lowPassFilter = GetComponentInChildren<AudioLowPassFilter>();
		hurtEffect = GameObject.Find("HurtEffect").GetComponent<Fader>();
		Stamina = 1f;
		Tired = false;
		movementBlocked = 0;
		rotationBlocked = 0;
		Health = 1f;
		PathToExit = new List<Point>();
		CurrentCell = new Point(0, 0);
		Pathfinder = new Pathfinder(60);
		UpdateHandObjects();
		Debug.Log("PlayerGameController - End Start");
	}

	private void Update()
	{
		float walkSpeed = WalkSpeed;
		float num = RotationSpeed;
		isRunning = PicoController.lastThrottleSpeed > 0.035f;
		if (InputExt.GetRunButton())
		{
			walkSpeed *= RunSpeedFactor;
			float num2 = ((!fearEffect.inTension) ? 1f : ScaredStaminaConsumptionMultiplier);
			if (!Tired && isRunning)
			{
				Stamina -= StaminaConsumptionRate * num2 * Time.deltaTime;
			}
			else
			{
				Stamina += StaminaTiredRegenRate * Time.deltaTime;
			}
			if (Stamina <= 0f && !Tired)
			{
				Tired = true;
			}
			Player.GetMinimapPos().Hide = true;
			Player.GetMinimapPos().Minimize = true;
			runCooldownTimer = 0f;
		}
		else
		{
			walkSpeed *= 1f;
			if (runCooldownTimer > RunCooldown)
			{
				Stamina += ((!Tired) ? StaminaRegenRate : StaminaTiredRegenRate) * Time.deltaTime;
			}
			else
			{
				runCooldownTimer += Time.deltaTime;
			}
		}
		Stamina = Mathf.Clamp(Stamina, 0f, 1f);
		if (Tired)
		{
			walkSpeed = Mathf.Min(walkSpeed, WalkSpeed * TiredSpeedFactor);
			if (Stamina >= 1f)
			{
				Tired = false;
			}
		}
		else if (Health <= 0.5f)
		{
			walkSpeed = Mathf.Min(walkSpeed, WalkSpeed * TiredSpeedFactor);
		}
		float num3 = 1f - Mathf.Clamp(Stamina / 0.6f, 0f, 1f);
		HeavyBreathSound.volume = Mathf.Lerp(HeavyBreathSound.volume, num3 * HeavyBreathMaxVolume, Time.deltaTime * 3f);
		if (GameController.Get().Paused)
		{
			HeavyBreathSound.volume = 0f;
		}
		float num4 = 0f;
		EyeClip[] array = clipEyes;
		foreach (EyeClip eyeClip in array)
		{
			num4 = Mathf.Max(num4, eyeClip.clippingFactor);
		}
		clipFader.enabled = num4 > 0f;
		clipFader.material.color = new Color(1f, 1f, 1f, num4);
		GameController.Get().VolumeMultiplier = Mathf.Lerp(1f, 0.5f, num4);
		if (Health < 1f && Health > 0f)
		{
			Health += HealthRegenRate * Time.deltaTime;
			Health = Mathf.Clamp(Health, 0f, 1f);
		}
		if (Health <= 0f || movementBlocked > 0)
		{
			walkSpeed = 0f;
		}
		if (Health <= 0f || rotationBlocked > 0)
		{
			num = 0f;
		}
		PicoController.SetMoveScaleMultiplier(walkSpeed);
		PicoController.SetRotationScaleMultiplierMouse(num * Config.Input().mouseSensitivity);
		PicoController.SetRotationScaleMultiplierPad(num * Config.Input().gamepadSensitivity);
		Point point = Map.Get().WorldToCell(base.transform.position);
		if (point != CurrentCell)
		{
			Room room = Map.Get().At(CurrentCell).Room;
			Room room2 = Map.Get().At(point).Room;
			CurrentCell = point;
			if (room != room2)
			{
				room?.PlayerExit();
				if (room2 != null)
				{
					room2.PlayerEnter();
					ClockMode.Set(room2.Template.flags.clockMode);
				}
				else
				{
					ClockMode.Set(ClockMode.Mode.Standard);
				}
			}
			ComputePathToExit();
		}
		UpdatePathfinder();
	}

	private void UpdateHandObjects()
	{
		bool using3DOFController = InputExt.Using3DOFController;
		for (int i = 0; i < handObjects.Length; i++)
		{
			if (handObjects[i].activeSelf != using3DOFController)
			{
				handObjects[i].SetActive(using3DOFController);
			}
		}
	}

	public void ApplyAttack(float fDamage = 0.8f, string gameOverText = "GAMEOVER_DEFAULT", float fadeInSpeed = 1.5f)
	{
		if (!(Health <= 0f))
		{
			Health -= fDamage;
			AudioSource.PlayClipAtPoint(HurtSlashSound, base.transform.position);
			AudioSource.PlayClipAtPoint(HurtSound, base.transform.position);
			hurtEffect.FadeIn(fadeInSpeed);
			if (Health <= 0f)
			{
				PlayerStats.Get().AddDeath();
				GameController.Get().ShowGameOver(gameOverText);
			}
		}
	}

	public void AddHealth(float amount = 1f)
	{
		Health += amount;
	}

	public void ForceTired()
	{
		Tired = true;
		Stamina = 0f;
	}

	public bool IsInExitPath(Point position)
	{
		foreach (Point item in PathToExit)
		{
			if (item == position)
			{
				return true;
			}
		}
		return false;
	}

	private void ComputePathToExit()
	{
		Point exitPosition = Map.Get().ExitPosition;
		Point closestWalkable = Map.Get().GetClosestWalkable(base.transform.position);
		pathQuery = Pathfinder.AddQuery(closestWalkable, exitPosition, null, CheckTraversal, GetTraversalCost, null, 0.5f);
	}

	private void UpdatePathfinder()
	{
		if (pathQuery == null)
		{
			return;
		}
		Pathfinder.Update();
		if (!pathQuery.IsFinished())
		{
			return;
		}
		if (pathQuery.IsSuccess())
		{
			PathToExit.Clear();
			for (int i = 0; i < pathQuery.Path.Count; i++)
			{
				PathToExit.Add(pathQuery.Path[i]);
			}
		}
		else
		{
			Point point = Map.Get().WorldToCell(base.transform.position);
			if (PathToExit.Count == 0 || PathToExit[0] != point)
			{
				PathToExit.Insert(0, point);
			}
		}
		Pathfinder.FreeQuery(pathQuery);
		pathQuery = null;
	}

	private float GetTraversalCost(Point from, Point end, object movementDesc)
	{
		Map map = Map.Get();
		if (from.X < 0 || from.X >= map.Width || from.Y < 0 || from.Y >= map.Height || end.X < 0 || end.X >= map.Width || end.Y < 0 || end.Y >= map.Height)
		{
			return float.MaxValue;
		}
		return 1f;
	}

	private bool CheckTraversal(Point from, Point end, object movementDesc)
	{
		Map map = Map.Get();
		if (from.X <= 0 || from.X >= map.Width - 1 || from.Y <= 0 || from.Y >= map.Height - 1 || end.X <= 0 || end.X >= map.Width - 1 || end.Y <= 0 || end.Y >= map.Height - 1)
		{
			return false;
		}
		Cell cell = map.At(end.X, end.Y);
		if (map.ExitPosition == end)
		{
			return true;
		}
		if (!cell.CanWalk() || (cell.Occupied && cell.Room != null && cell.Door == null && !cell.IsDoor))
		{
			return false;
		}
		if (from.X != end.X && from.Y != end.Y)
		{
			return false;
		}
		return true;
	}

	public void BlockMovement(bool blockRotation = true)
	{
		movementBlocked++;
		if (blockRotation)
		{
			rotationBlocked++;
		}
	}

	public void UnblockMovement(bool unBlockRotation = true)
	{
		movementBlocked--;
		if (unBlockRotation)
		{
			rotationBlocked--;
		}
	}

	public void BlockRotation()
	{
		rotationBlocked++;
	}

	public void UnBlockRotation()
	{
		rotationBlocked--;
	}

	private void OnControllerColliderHit(ControllerColliderHit hit)
	{
		GameObject gameObject = hit.collider.gameObject;
		if (movementBlocked > 0)
		{
			return;
		}
		if (gameObject.CompareTag(Tags.Exit))
		{
			PlayerStats.Get().AddWin();
			if (GameController.Get().levelOptions.isDemo)
			{
				GameController.Get().EndLevel(win: true);
			}
			else if (GameController.Get().levelOptions.isRandomMode)
			{
				GameController.Get().EndLevel();
			}
			else
			{
				GameController.Get().EnterHub(saveCheckpoint: true);
			}
			BlockMovement();
			hit.collider.enabled = false;
		}
		else if (gameObject.CompareTag(Tags.PlayerTrigger))
		{
			PlayerCollision component = gameObject.GetComponent<PlayerCollision>();
			if ((bool)component)
			{
				component.OnPlayerCollision(base.gameObject);
			}
		}
		else if (gameObject.CompareTag(Tags.DoorTrigger))
		{
			DoorCollision component2 = gameObject.GetComponent<DoorCollision>();
			if ((bool)component2)
			{
				component2.OnPlayerCollision(base.gameObject, hit.collider);
			}
		}
	}

	private void OnTriggerEnter(Collider trigger)
	{
		if (trigger.CompareTag(Tags.PlayerTrigger))
		{
			Trigger component = trigger.GetComponent<Trigger>();
			if (component != null)
			{
				component.OnActivate(this);
			}
		}
		else if (trigger.CompareTag(Tags.Exit))
		{
			if (movementBlocked <= 0)
			{
				PlayerStats.Get().AddWin();
				if (GameController.Get().levelOptions.isDemo)
				{
					GameController.Get().EndLevel(win: true);
				}
				else if (GameController.Get().levelOptions.isRandomMode)
				{
					GameController.Get().EndLevel();
				}
				else
				{
					GameController.Get().EnterHub(saveCheckpoint: true);
				}
				BlockMovement();
			}
		}
		else if (trigger.CompareTag(Tags.DoorTrigger))
		{
			DoorCollision component2 = trigger.transform.parent.GetComponent<DoorCollision>();
			if ((bool)component2)
			{
				component2.OnPlayerCollision(base.gameObject, trigger);
			}
		}
	}

	private void OnTriggerStay(Collider trigger)
	{
		if (trigger.CompareTag(Tags.DoorTrigger))
		{
			DoorCollision component = trigger.transform.parent.GetComponent<DoorCollision>();
			if ((bool)component)
			{
				component.OnPlayerCollision(base.gameObject, trigger);
			}
		}
	}

	[Conditional("DH_DEBUG")]
	public void TeleportToExitRoom()
	{
		Room room = Map.Get().At(Map.Get().ExitPosition).Room;
		if (room != null)
		{
			Point randomPoint = room.GetRandomPoint();
			Vector3 vector = Map.Get().CellToWorld(randomPoint).ToGround();
			base.transform.position = vector + Vector3.up * base.transform.position.y;
		}
	}

	public void ShowTutoArrows(bool visible = true)
	{
		if (InputExt.Using3DOFController || InputExt.UsingHandControllers)
		{
			GameObject gameObject = ((!InputExt.RightHanded) ? tutoArrowsLeft : tutoArrowsRight);
			if (gameObject != null)
			{
				gameObject.SetActive(visible);
			}
		}
	}
}
public class PlayerHand : TimeIndependentBehaviour
{
	private static class Const
	{
		public const string AnimLayerNamePoint = "Point Layer";

		public const string AnimLayerNameThumb = "Thumb Layer";

		public const string AnimParamNameFlex = "Flex";

		public const string AnimParamNamePose = "Pose";

		public const float HapticOverlapAmplitude = 0.25f;

		public const float HapticOverlapFrequency = 320f;

		public const float HapticOverlapDuration = 0.05f;

		public const float InputRateChange = 20f;

		public static readonly Vector3 LeftHandPosition = new Vector3(-0.0252f, -0.0174f, -0.038f);

		public static readonly Quaternion LeftHandRotation = Quaternion.Euler(10.844f, -13.027f, 74.278f);

		public static readonly Vector3 RightHandPosition = new Vector3(0.0252f, -0.0174f, -0.038f);

		public static readonly Quaternion RightHandRotation = Quaternion.Euler(10.844f, 13.027f, -74.278f);

		public const float ThreshCollisionFlex = 0.96f;

		public const float ThreshGrabBegin = 0.55f;

		public const float ThreshGrabEnd = 0.35f;

		public const float ThreshThrowSpeed = 1f;
	}

	public bool isRightHand;

	public Animator animator;

	public Transform meshRoot;

	private int animLayerIndexThumb = -1;

	private int animLayerIndexPoint = -1;

	private int animLayerIndexFlex = -1;

	private int animLayerIndexPose = -1;

	private float flex;

	private float point;

	private float thumbsUp;

	public bool IsVisible = true;

	private float visibility;

	private Renderer[] renderers;

	private List<Material> materials;

	private TrackedController trackedController;

	public bool lampLocked;

	public bool mapLocked;

	public GameObject tutoArrows;

	private void Start()
	{
		animLayerIndexPoint = animator.GetLayerIndex("Point Layer");
		animLayerIndexThumb = animator.GetLayerIndex("Thumb Layer");
		animLayerIndexFlex = Animator.StringToHash("Flex");
		animLayerIndexPose = Animator.StringToHash("Pose");
		base.transform.localPosition = ((!isRightHand) ? Const.LeftHandPosition : Const.RightHandPosition);
		base.transform.localRotation = ((!isRightHand) ? Const.LeftHandRotation : Const.RightHandRotation);
		trackedController = TrackedController.FindOrCreate(isRightHand ? HandednessId.Right : HandednessId.Left);
	}

	private new void Update()
	{
		base.Update();
		if (materials == null)
		{
			materials = new List<Material>();
			renderers = GetComponentsInChildren<Renderer>();
			Renderer[] array = renderers;
			foreach (Renderer renderer in array)
			{
				materials.Add(renderer.material);
			}
		}
		visibility = Interpolate.Approach(visibility, (!IsVisible) ? 0f : 1f, base.deltaTime * 10f);
		for (int j = 0; j < materials.Count; j++)
		{
			materials[j].SetFloat("_Fade", visibility);
		}
		if ((!IsVisible && visibility <= 0.01f) || (IsVisible && visibility > 0.01f))
		{
			for (int k = 0; k < renderers.Length; k++)
			{
				renderers[k].enabled = IsVisible;
			}
		}
		float num = flex;
		flex = GetInputFlex();
		point = InputValueRateChange(GetInputPoint(), point);
		thumbsUp = InputValueRateChange(GetInputThumbsUp(), thumbsUp);
		int value = 0;
		animator.SetInteger(animLayerIndexPose, value);
		animator.SetFloat(animLayerIndexFlex, flex);
		animator.SetLayerWeight(animLayerIndexPoint, point);
		animator.SetLayerWeight(animLayerIndexThumb, thumbsUp);
		if (lampLocked)
		{
			Quaternion rotation = base.transform.parent.rotation;
			float y = rotation.eulerAngles.y;
			float x = rotation.eulerAngles.x;
			base.transform.rotation = Quaternion.Euler(x, y, 0f);
		}
	}

	private float GetInputFlex()
	{
		if (mapLocked)
		{
			return 0.4f;
		}
		return (!lampLocked) ? Mathf.Max(trackedController.GripTrigger, trackedController.Trigger) : 1f;
	}

	private bool GetInputPoint()
	{
		if (lampLocked || mapLocked)
		{
			return false;
		}
		return trackedController.IsPoint;
	}

	private bool GetInputThumbsUp()
	{
		if (lampLocked || mapLocked)
		{
			return false;
		}
		return trackedController.IsThumbsUp;
	}

	private float InputValueRateChange(bool isDown, float value)
	{
		float num = base.deltaTime * 20f;
		float num2 = ((!isDown) ? (-1f) : 1f);
		return Mathf.Clamp01(value + num * num2);
	}

	public void ShowTutoArrows(bool visible = true)
	{
		if (tutoArrows != null)
		{
			tutoArrows.SetActive(visible);
		}
	}

	public void PlayHaptic(float freq, float amplitude, float duration)
	{
		trackedController.PlayHapticEvent(freq, amplitude, duration);
	}

	public void PlayHapticSelect()
	{
		trackedController.PlayHapticEvent(0.1f, 0.2f, 0.1f);
	}

	public void PlayHapticCollect()
	{
		trackedController.PlayHapticEvent(0.2f, 0.2f, 0.025f);
	}

	public void PlayHapticUnlock()
	{
		trackedController.PlayHapticEvent(0.125f, 0.5f, 0.1f);
	}

	public void PlayHapticInInteractionArea()
	{
		trackedController.PlayHapticEvent(0.3f, 0.4f, 0.035f);
	}

	public void PlayHapticClip(AudioClip hapticClip)
	{
	}

	public void PlayPositionalHaptic(Vector3 origin, float radius, float maxFreq = 1f, float maxAmplitude = 1f, float minFreq = 0f, float minAmplitude = 0f)
	{
		float magnitude = (base.transform.position - origin).magnitude;
		float t = (radius - magnitude) / radius;
		trackedController.PlayHapticEvent(Interpolate.Lerp(minFreq, maxFreq, t), Interpolate.Lerp(minAmplitude, maxAmplitude, t), 1f / 60f);
	}
}
public class PlayerStats : MonoBehaviour
{
	public class Stats
	{
		public class Event
		{
			public enum EventType
			{
				Position,
				Collect,
				Die,
				Win
			}

			public EventType eventType;

			public uint timeTick;

			public Point position;

			public Event(EventType evType, uint curTime, Point curPos)
			{
				eventType = evType;
				timeTick = curTime;
				position = curPos;
			}
		}

		public int totalItems;

		public int collectedItems;

		public List<Event> events;

		public uint[][] discoveredTiles;

		public int totalProbes;

		public int discoveredProbes;

		public Texture2D levelMap;

		public bool resultWin;

		public uint totalTime;

		public Stats()
		{
			events = new List<Event>();
			events.Capacity = 1024;
			totalItems = (collectedItems = 0);
			totalProbes = (discoveredProbes = 0);
			discoveredTiles = new uint[64][];
			for (int i = 0; i < 64; i++)
			{
				discoveredTiles[i] = new uint[64];
				for (int j = 0; j < 64; j++)
				{
					discoveredTiles[i][j] = uint.MaxValue;
				}
			}
			levelMap = null;
			resultWin = false;
			totalTime = 0u;
		}

		public void AddEvent(Event.EventType evType, uint curTime, Point curPos)
		{
			Event item = new Event(evType, curTime, curPos);
			events.Add(item);
		}
	}

	private static PlayerStats instance;

	public static Stats stats;

	public bool recordStats;

	public uint curTimeTick;

	private float timeCounter;

	public Point lastPos;

	public Point curPos;

	public float curOrientation;

	public static PlayerStats Get()
	{
		return instance;
	}

	public static void Clear()
	{
		instance = null;
		stats = null;
	}

	private void Awake()
	{
		instance = this;
		recordStats = GameController.Get().levelOptions.isRandomMode;
		if (recordStats)
		{
			stats = new Stats();
		}
		else
		{
			stats = null;
			base.enabled = false;
		}
		curTimeTick = 0u;
		timeCounter = 0f;
		lastPos = new Point(0, 0);
		curPos = Map.Get().WorldToCell(base.transform.position);
		curOrientation = base.transform.rotation.eulerAngles.z;
	}

	private void Update()
	{
		bool flag = false;
		timeCounter += Time.deltaTime;
		if (timeCounter >= 0.1f)
		{
			curTimeTick++;
			timeCounter -= 0.1f;
			flag = true;
			stats.totalTime = curTimeTick;
		}
		curPos = Map.Get().WorldToCell(base.transform.position);
		curOrientation = Player.GetForwardDirection().rotation.eulerAngles.y;
		if (curPos != lastPos)
		{
			stats.AddEvent(Stats.Event.EventType.Position, curTimeTick, curPos);
			lastPos = curPos;
		}
	}

	public void SetMinimap(Texture2D levelMap)
	{
		if (recordStats)
		{
			stats.levelMap = levelMap;
		}
	}

	public void AddItem()
	{
		if (recordStats)
		{
			stats.totalItems++;
		}
	}

	public void AddCollectedItem()
	{
		if (recordStats)
		{
			stats.collectedItems++;
			stats.AddEvent(Stats.Event.EventType.Collect, curTimeTick, curPos);
		}
	}

	public void AddProbe()
	{
		if (recordStats)
		{
			stats.totalProbes++;
		}
	}

	public void AddDiscovered(Point tile)
	{
		if (recordStats && stats.discoveredTiles[tile.Y][tile.X] == uint.MaxValue)
		{
			stats.discoveredProbes++;
			stats.discoveredTiles[tile.Y][tile.X] = curTimeTick;
		}
	}

	public void AddDeath()
	{
		if (recordStats)
		{
			stats.AddEvent(Stats.Event.EventType.Position, curTimeTick, curPos);
			stats.AddEvent(Stats.Event.EventType.Die, curTimeTick, curPos);
			stats.resultWin = false;
			stats.totalTime = curTimeTick;
			base.enabled = false;
		}
	}

	public void AddWin()
	{
		if (recordStats)
		{
			stats.AddEvent(Stats.Event.EventType.Position, curTimeTick, curPos);
			stats.AddEvent(Stats.Event.EventType.Win, curTimeTick, curPos);
			stats.resultWin = true;
			stats.totalTime = curTimeTick;
			base.enabled = false;
		}
	}
}
public class RatchetRotation : MonoBehaviour
{
	public enum RotationType
	{
		Immediate,
		ApproachFast,
		Approach,
		Linear
	}

	public PicoPlayerController playerController;

	public Pvr_UnitySDKManager cameraController;

	public float rotationAmount = 45f;

	public float rotationAmount3DOF = 45f;

	public float rotationTimer = 0.35f;

	private float baseRotationAmount;

	private bool isActive;

	public RotationType rotationType;

	public string axisName = "Right_X_Axis";

	private bool prevLeft;

	private bool prevRight;

	private float leftTimer;

	private float rightTimer;

	private float rotDeltaTarget;

	public bool snapToAxis;

	public float snapMargin = 8f;

	[Range(0f, 1f)]
	public float activationPoint = 0.9f;

	[Range(0f, 1f)]
	public float endActivationPoint = 0.1f;

	public bool IsActive
	{
		get
		{
			return isActive;
		}
		set
		{
			if (value != isActive)
			{
				isActive = value;
				if (isActive)
				{
					baseRotationAmount = playerController.RotationAmount;
					playerController.RotationAmount = 0f;
				}
				else
				{
					playerController.RotationAmount = baseRotationAmount;
				}
			}
		}
	}

	private void Awake()
	{
		if (!playerController)
		{
			playerController = GetComponent<PicoPlayerController>();
		}
		if (!cameraController)
		{
			cameraController = Player.Get().GetComponentInChildren<Pvr_UnitySDKManager>();
		}
		baseRotationAmount = Mathf.Max(playerController.RotationAmount, baseRotationAmount);
		if (Config.Input().comfortRotation)
		{
			IsActive = true;
		}
	}

	private void Update()
	{
		float num = ((!isActive) ? 0f : InputExt.GetAxisPadRatchet(InputExt.Axis2D.RightThumbstick).x);
		float num2 = InputExt.GetAxisPad(InputExt.Axis2D.Dpad).x;
		float num3 = rotationAmount;
		InputExt.TouchpadStatus touchpadStatus = null;
		if (InputExt.Using3DOFController)
		{
			touchpadStatus = InputExt.touchpadStatus;
		}
		if (touchpadStatus != null)
		{
			float num4 = 0f;
			if (touchpadStatus.isSwiping)
			{
				if (touchpadStatus.swipeDir == InputExt.TouchpadStatus.SwipeDir.LEFT)
				{
					num4 = -1f;
				}
				else if (touchpadStatus.swipeDir == InputExt.TouchpadStatus.SwipeDir.RIGHT)
				{
					num4 = 1f;
				}
				touchpadStatus.isSwiping = false;
			}
			num2 = num4;
			num3 = rotationAmount3DOF;
		}
		float num5 = 0f;
		bool flag = false;
		if (num <= 0f - (1f - endActivationPoint) || num2 <= 0f - activationPoint)
		{
			flag = true;
			leftTimer -= Time.deltaTime;
		}
		else
		{
			leftTimer = 0f;
		}
		if (flag && (!prevLeft || leftTimer <= 0f))
		{
			num5 -= num3;
			leftTimer = rotationTimer;
		}
		prevLeft = flag;
		bool flag2 = false;
		if (num >= 1f - endActivationPoint || num2 >= activationPoint)
		{
			flag2 = true;
			rightTimer -= Time.deltaTime;
		}
		else
		{
			rightTimer = 0f;
		}
		if (flag2 && (!prevRight || rightTimer <= 0f))
		{
			num5 += num3;
			rightTimer = rotationTimer;
		}
		prevRight = flag2;
		rotDeltaTarget += num5;
		float rot = 0f;
		playerController.GetYRotation(ref rot);
		if (snapToAxis)
		{
			float num6 = rot;
			float num7 = rot + rotDeltaTarget + base.transform.rotation.eulerAngles.y;
			while (num7 > 360f)
			{
				num7 -= 360f;
				num6 -= 360f;
			}
			while (num7 < -360f)
			{
				num7 += 360f;
				num6 += 360f;
			}
			for (int i = 0; i <= 4; i++)
			{
				float num8 = 90f * (float)i;
				if (Mathf.Abs(num7 - num8) <= snapMargin)
				{
					rotDeltaTarget = num8 - num6 - base.transform.rotation.eulerAngles.y;
					break;
				}
			}
		}
		float num9 = 0f;
		if (rotationType == RotationType.Immediate)
		{
			num9 = rotDeltaTarget;
			rotDeltaTarget = 0f;
		}
		else if (rotationType == RotationType.ApproachFast)
		{
			num9 = rotDeltaTarget * Time.deltaTime * 40f;
			rotDeltaTarget -= num9;
		}
		else if (rotationType == RotationType.Approach)
		{
			num9 = rotDeltaTarget * Time.deltaTime * 20f;
			rotDeltaTarget -= num9;
		}
		else if (rotationType == RotationType.Linear)
		{
			float num10 = Mathf.Abs(rotDeltaTarget);
			if (num10 >= 0.01f)
			{
				num9 = Mathf.Clamp(Time.deltaTime * 2f, 0f, num10);
				num9 *= ((!(rotDeltaTarget > 0f)) ? (-1f) : 1f);
				rotDeltaTarget -= num9;
			}
			num9 = rotDeltaTarget * Time.deltaTime * 20f;
			rotDeltaTarget -= num9;
		}
		playerController.SetYRotation(rot + num9);
	}
}
public class RotationGrid : MonoBehaviour
{
	public float maxOpacity = 1f;

	private Material gridMaterial;

	private Color gridColor;

	private float targetOpacity;

	public float fadeInSpeed = 1f;

	public float fadeOutSpeed = 1f;

	private void Start()
	{
		gridMaterial = GetComponent<Renderer>().material;
		gridColor = gridMaterial.color;
		gridColor.a = 0f;
		gridMaterial.color = gridColor;
	}

	private void LateUpdate()
	{
		gridColor.a = Interpolate.Lerp(gridColor.a, targetOpacity, (!(targetOpacity >= 1f)) ? (Time.deltaTime * fadeOutSpeed) : (Time.deltaTime * fadeInSpeed));
		gridMaterial.color = gridColor;
		if (targetOpacity >= 0.1f && !GetComponent<Renderer>().enabled)
		{
			GetComponent<Renderer>().enabled = true;
		}
		else if (targetOpacity <= 0.1f && gridColor.a <= 0.05f && GetComponent<Renderer>().enabled)
		{
			GetComponent<Renderer>().enabled = false;
		}
	}

	public void ShowGrid()
	{
		targetOpacity = 1f;
	}
}
public class SetCameraProps : MonoBehaviour
{
	public Color background = Color.black;

	public float near = 0.15f;

	public float far = 1000f;

	private void Start()
	{
		Pvr_UnitySDKManager component = base.gameObject.GetComponent<Pvr_UnitySDKManager>();
		if ((bool)component)
		{
			component.transform.Find("Head/LeftEye").GetComponent<Camera>().backgroundColor = background;
			component.transform.Find("Head/LeftEye").GetComponent<Camera>().nearClipPlane = near;
			component.transform.Find("Head/LeftEye").GetComponent<Camera>().farClipPlane = far;
			component.transform.Find("Head/RightEye").GetComponent<Camera>().backgroundColor = background;
			component.transform.Find("Head/RightEye").GetComponent<Camera>().nearClipPlane = near;
			component.transform.Find("Head/RightEye").GetComponent<Camera>().farClipPlane = far;
		}
	}
}
public class SetHandControls : MonoBehaviour
{
	public Transform leftHand;

	public Transform rightHand;

	public Transform lanternBody;

	public Transform lanternPivot;

	public Transform minimap;

	public float minimapScaleFactor = 1f;

	private Material lampMaterial;

	private bool usingHandControls;

	private void Start()
	{
		if (!InputExt.UsingHandControllers)
		{
			leftHand.gameObject.SetActive(value: false);
			rightHand.gameObject.SetActive(value: false);
		}
		else
		{
			ConfigureForHandControls();
		}
	}

	private void Update()
	{
		if (usingHandControls && lampMaterial != null)
		{
			lampMaterial.SetFloat("_Level", Player.GetTorchFuel().GetFuelLevelNormalized());
			lampMaterial.SetFloat("_EmissionIntensity", (!Player.GetTorchFuel().lightOn) ? 0.3f : 1f);
		}
		else if (InputExt.UsingHandControllers)
		{
			ConfigureForHandControls();
		}
	}

	private void ConfigureForHandControls()
	{
		usingHandControls = true;
		leftHand.gameObject.SetActive(value: true);
		rightHand.gameObject.SetActive(value: true);
		if (lanternBody != null)
		{
			lanternBody.transform.parent = base.transform;
			lampMaterial = lanternBody.GetComponent<Renderer>().materials[1];
			GameObject gameObject = GameObject.FindWithTag(Tags.PlayerTorch);
			gameObject.transform.parent = lanternBody.transform;
			gameObject.transform.localPosition = new Vector3(0f, -0.08f, 0f);
			gameObject.transform.localRotation = Quaternion.identity;
			if (InputExt.LeftHanded)
			{
				Player.GetLeftHand().lampLocked = false;
				Player.GetRightHand().lampLocked = true;
				Vector3 localPosition = lanternPivot.localPosition;
				localPosition.x = 0f - localPosition.x;
				Quaternion localRotation = lanternPivot.localRotation;
				lanternPivot.parent = rightHand;
				lanternPivot.localPosition = localPosition;
				lanternPivot.localRotation = localRotation;
			}
		}
		if (minimap != null)
		{
			Transform transform = minimap.Find("hand_anchor");
			if (transform == null)
			{
				transform = minimap;
			}
			minimap.GetComponent<MinimapPosition>().enabled = false;
			minimap.localScale *= minimapScaleFactor;
			if (InputExt.LeftHanded)
			{
				minimap.parent = leftHand;
				Vector3 localPosition2 = transform.localPosition;
				localPosition2.x = 0f - localPosition2.x;
				transform.localPosition = localPosition2;
				Vector3 eulerAngles = transform.localRotation.eulerAngles;
				transform.localRotation = Quaternion.Euler(eulerAngles.x, eulerAngles.y, (0f - eulerAngles.z) * 2f);
			}
			else
			{
				minimap.parent = rightHand;
			}
			Vector3 localPosition3 = transform.localPosition;
			localPosition3.Scale(minimap.localScale);
			minimap.localPosition = localPosition3;
			minimap.localRotation = transform.localRotation;
			MinimapHandController minimapHandController = minimap.gameObject.AddComponent<MinimapHandController>();
			minimapHandController.hand = ((!InputExt.LeftHanded) ? Player.GetRightHand() : Player.GetLeftHand());
			minimapHandController.minimapAnchor = transform;
			Material[] materials = minimap.GetComponent<Renderer>().materials;
			for (int i = 0; i < materials.Length; i++)
			{
				materials[i].renderQueue += 2020;
			}
		}
	}
}
public class SetImageEffects : MonoBehaviour
{
	public bool addSSAO = true;

	public bool addGrayscale;

	public bool addMonochromize = true;

	public bool addHighlight = true;

	public bool addOVRLensCorrection = true;

	public bool addAntiAliasing = true;

	public Material OVRLensCorrectionMaterial;

	public Material OVRLensCorrectionMaterial_CA;

	public Material OVRLensCorrectionMaterial_MeshDistort;

	public Shader ssaoShader;

	public Shader aa_SSAA;

	public Shader aa_DLAA;

	public Shader aa_NFAA;

	public Shader aa_FXAAPreset2;

	public Shader aa_FXAAPreset3;

	public Shader aa_FXAAII;

	public Shader aa_FXAAIII;

	public Shader grayscaleShader;

	public Shader monochromizeShader;

	private void Awake()
	{
		Debug.Log("SetImageEffects - Initializing");
		if (addSSAO)
		{
			AddSSAO();
		}
		if (addGrayscale)
		{
			AddGrayscale();
		}
		if (addMonochromize)
		{
			AddMonochromize();
		}
		if (addHighlight)
		{
			AddHightlight();
		}
		AddOVRLens();
		if (addAntiAliasing)
		{
			AddAA();
		}
		Debug.Log("SetImageEffects - Done");
	}

	private void AddOVRLens()
	{
	}

	private void AddSSAO()
	{
		Debug.Log("SetImageEffects - AddSSAO");
		SSAOEffect sSAOEffect = base.gameObject.AddComponent<SSAOEffect>();
		sSAOEffect.m_Radius = 0.4f;
		sSAOEffect.m_SampleCount = SSAOEffect.SSAOSamples.Medium;
		sSAOEffect.m_OcclusionIntensity = 1.5f;
		sSAOEffect.m_Blur = 2;
		sSAOEffect.m_Downsampling = 2;
		sSAOEffect.m_OcclusionAttenuation = 1f;
		sSAOEffect.m_MinZ = 0.01f;
		Debug.Log("SetImageEffects - AddSSAO done");
	}

	private void AddAA()
	{
		Debug.Log("SetImageEffects - AddAA");
		AntialiasingAsPostEffect antialiasingAsPostEffect = base.gameObject.AddComponent<AntialiasingAsPostEffect>();
		antialiasingAsPostEffect.ssaaShader = aa_SSAA;
		antialiasingAsPostEffect.dlaaShader = aa_DLAA;
		antialiasingAsPostEffect.nfaaShader = aa_NFAA;
		antialiasingAsPostEffect.shaderFXAAPreset2 = aa_FXAAPreset2;
		antialiasingAsPostEffect.shaderFXAAPreset3 = aa_FXAAPreset3;
		antialiasingAsPostEffect.shaderFXAAII = aa_FXAAII;
		antialiasingAsPostEffect.shaderFXAAIII = aa_FXAAIII;
		antialiasingAsPostEffect.mode = AAMode.FXAA1PresetA;
		Debug.Log("SetImageEffects - AddAA done");
	}

	private void AddGrayscale()
	{
		Debug.Log("SetImageEffects - AddGrayscale");
		GrayscaleEffect grayscaleEffect = base.gameObject.AddComponent<GrayscaleEffect>();
		grayscaleEffect.shader = grayscaleShader;
		Debug.Log("SetImageEffects - AddGrayscale done");
	}

	private void AddHightlight()
	{
	}

	private void AddMonochromize()
	{
		Debug.Log("SetImageEffects - AddMonochromize");
		Monochromize monochromize = base.gameObject.AddComponent<Monochromize>();
		monochromize.intensity = 0f;
		monochromize.shader = monochromizeShader;
		monochromize.enabled = false;
		Debug.Log("SetImageEffects - AddMonochromize done");
	}
}
[AddComponentMenu("Camera-Control/Smooth Mouse Look")]
public class SmoothMouseLook : MonoBehaviour
{
	public enum RotationAxes
	{
		MouseXAndY,
		MouseX,
		MouseY
	}

	public RotationAxes axes;

	public float sensitivityX = 15f;

	public float sensitivityY = 15f;

	public float minimumX = -360f;

	public float maximumX = 360f;

	public float minimumY = -60f;

	public float maximumY = 60f;

	private float rotationX;

	private float rotationY;

	private List<float> rotArrayX = new List<float>();

	private float rotAverageX;

	private List<float> rotArrayY = new List<float>();

	private float rotAverageY;

	public float frameCounter = 20f;

	private Quaternion originalRotation;

	private void Update()
	{
		if (axes == RotationAxes.MouseXAndY)
		{
			rotAverageY = 0f;
			rotAverageX = 0f;
			rotationY += Input.GetAxis("Mouse Y") * sensitivityY;
			rotationX += Input.GetAxis("Mouse X") * sensitivityX;
			rotArrayY.Add(rotationY);
			rotArrayX.Add(rotationX);
			if ((float)rotArrayY.Count >= frameCounter)
			{
				rotArrayY.RemoveAt(0);
			}
			if ((float)rotArrayX.Count >= frameCounter)
			{
				rotArrayX.RemoveAt(0);
			}
			for (int i = 0; i < rotArrayY.Count; i++)
			{
				rotAverageY += rotArrayY[i];
			}
			for (int j = 0; j < rotArrayX.Count; j++)
			{
				rotAverageX += rotArrayX[j];
			}
			rotAverageY /= rotArrayY.Count;
			rotAverageX /= rotArrayX.Count;
			rotAverageY = ClampAngle(rotAverageY, minimumY, maximumY);
			rotAverageX = ClampAngle(rotAverageX, minimumX, maximumX);
			Quaternion quaternion = Quaternion.AngleAxis(rotAverageY, Vector3.left);
			Quaternion quaternion2 = Quaternion.AngleAxis(rotAverageX, Vector3.up);
			base.transform.localRotation = originalRotation * quaternion2 * quaternion;
		}
		else if (axes == RotationAxes.MouseX)
		{
			rotAverageX = 0f;
			rotationX += Input.GetAxis("Mouse X") * sensitivityX;
			rotArrayX.Add(rotationX);
			if ((float)rotArrayX.Count >= frameCounter)
			{
				rotArrayX.RemoveAt(0);
			}
			for (int k = 0; k < rotArrayX.Count; k++)
			{
				rotAverageX += rotArrayX[k];
			}
			rotAverageX /= rotArrayX.Count;
			rotAverageX = ClampAngle(rotAverageX, minimumX, maximumX);
			Quaternion quaternion3 = Quaternion.AngleAxis(rotAverageX, Vector3.up);
			base.transform.localRotation = originalRotation * quaternion3;
		}
		else
		{
			rotAverageY = 0f;
			rotationY += Input.GetAxis("Mouse Y") * sensitivityY;
			rotArrayY.Add(rotationY);
			if ((float)rotArrayY.Count >= frameCounter)
			{
				rotArrayY.RemoveAt(0);
			}
			for (int l = 0; l < rotArrayY.Count; l++)
			{
				rotAverageY += rotArrayY[l];
			}
			rotAverageY /= rotArrayY.Count;
			rotAverageY = ClampAngle(rotAverageY, minimumY, maximumY);
			Quaternion quaternion4 = Quaternion.AngleAxis(rotAverageY, Vector3.left);
			base.transform.localRotation = originalRotation * quaternion4;
		}
	}

	private void Start()
	{
		if ((bool)GetComponent<Rigidbody>())
		{
			GetComponent<Rigidbody>().freezeRotation = true;
		}
		originalRotation = base.transform.localRotation;
	}

	public static float ClampAngle(float angle, float min, float max)
	{
		angle %= 360f;
		if (angle >= -360f && angle <= 360f)
		{
			if (angle < -360f)
			{
				angle += 360f;
			}
			if (angle > 360f)
			{
				angle -= 360f;
			}
		}
		return Mathf.Clamp(angle, min, max);
	}
}
[RequireComponent(typeof(AudioSource))]
public class SpookSounds : MonoBehaviour
{
	private static SpookSounds instance;

	public AudioClip[] naturalSounds;

	public AudioClip[] ghostSounds;

	public AudioClip[] ghostWhisperSounds;

	public AudioClip[] monsterSounds;

	public float naturalWeight = 1f;

	public float ghostWeight = 0.5f;

	public float ghostWhispersWeight = 0.2f;

	public float monsterWeight = 0.5f;

	public AudioClip[] Scares;

	public AudioClip[] IntenseScares;

	public float SilenceProbability = 0.3f;

	public float ShortWaitMin = 4f;

	public float ShortWaitMax = 8f;

	public float MediumWaitMin = 8f;

	public float MediumWaitMax = 16f;

	public float LongWaitMin = 20f;

	public float LongWaitMax = 40f;

	public float MinDistance = 5f;

	public float MaxDistance = 20f;

	public float ScareCooldown = 30f;

	public float ScareIntenseCooldown = 8f;

	public AudioClip[] DeepSounds;

	public float deepWaitMin = 40f;

	public float deepWaitMax = 180f;

	public bool forceShadowSounds;

	private float LastWait;

	private float LastScare;

	private float LastScareIntense;

	public static SpookSounds Get()
	{
		return instance;
	}

	private void Awake()
	{
		instance = this;
	}

	private void Start()
	{
		StartCoroutine(PlaySpookSound());
		StartCoroutine(PlayDeepSounds());
	}

	private void Update()
	{
		if (LastScare > 0f)
		{
			LastScare -= Time.deltaTime;
		}
		if (LastScareIntense > 0f)
		{
			LastScareIntense -= Time.deltaTime;
		}
	}

	private IEnumerator PlaySpookSound()
	{
		bool bFirstTime = true;
		while (true)
		{
			float fType = UnityEngine.Random.value;
			float nextWait = ((fType < 0.2f) ? UnityEngine.Random.Range(ShortWaitMin, ShortWaitMax) : ((!(fType <= 0.6f)) ? UnityEngine.Random.Range(LongWaitMin, LongWaitMax) : UnityEngine.Random.Range(MediumWaitMin, MediumWaitMax)));
			if (UnityEngine.Random.value < SilenceProbability)
			{
				nextWait = Mathf.Min(nextWait, LastWait / 2f);
			}
			else if (!bFirstTime)
			{
				LevelOptions levelOptions = GameController.Get().levelOptions;
				_ = naturalSounds;
				float num = naturalWeight;
				float num2 = 0.2f * ghostWeight;
				if (levelOptions.shadowWatchers || levelOptions.ghostVisions || levelOptions.ghosts || levelOptions.shadowChasers || levelOptions.shadowChasersVisions)
				{
					num2 = 0.5f * ghostWeight;
					if (levelOptions.ghosts || levelOptions.shadowChasers)
					{
						num2 = ghostWeight;
					}
				}
				if (forceShadowSounds)
				{
					num2 = ghostWeight * 2f;
				}
				float num3 = 0.2f * monsterWeight;
				if (levelOptions.maxFloaters > 0 || levelOptions.maxLightEaters > 0 || levelOptions.maxProwlers > 0)
				{
					num3 = 0.5f * monsterWeight;
					if (levelOptions.maxLightEaters > 0 || levelOptions.maxProwlers > 0)
					{
						num3 = monsterWeight;
					}
				}
				bool flag = false;
				float num4 = num + num2 + num3;
				num /= num4;
				num2 /= num4;
				_ = num3 / num4;
				float value = UnityEngine.Random.value;
				AudioClip[] array;
				if (value <= num)
				{
					array = naturalSounds;
				}
				else if (value <= num + num2)
				{
					if (UnityEngine.Random.value <= ghostWhispersWeight)
					{
						array = ghostWhisperSounds;
						flag = true;
					}
					else
					{
						array = ghostSounds;
					}
				}
				else
				{
					array = monsterSounds;
				}
				AudioClip clip = array[UnityEngine.Random.Range(0, array.Length)];
				Vector2 insideUnitCircle = UnityEngine.Random.insideUnitCircle;
				insideUnitCircle *= UnityEngine.Random.Range(MinDistance, MaxDistance);
				Vector3 position = base.transform.position + new Vector3(insideUnitCircle.x, 0f, insideUnitCircle.y);
				if (!flag)
				{
					AudioSource.PlayClipAtPoint(clip, position);
				}
				else
				{
					AudioSource.PlayClipAtPoint(clip, Player.GetLook().position);
				}
			}
			LastWait = nextWait;
			bFirstTime = false;
			yield return new WaitForSeconds(nextWait);
		}
	}

	private IEnumerator PlayDeepSounds()
	{
		while (true)
		{
			float nextWait = UnityEngine.Random.Range(deepWaitMin, deepWaitMax);
			yield return new WaitForSeconds(nextWait);
			LevelOptions lOptions = GameController.Get().levelOptions;
			Room curRoom = Map.Get().At(Player.Pos).Room;
			if (!lOptions.safeMap && (curRoom == null || !curRoom.Safe))
			{
				AudioClip clip = DeepSounds[UnityEngine.Random.Range(0, DeepSounds.Length)];
				Vector3 insideUnitSphere = UnityEngine.Random.insideUnitSphere;
				insideUnitSphere *= UnityEngine.Random.Range(40f, 100f);
				Vector3 pos = base.transform.position + insideUnitSphere;
				Utils.PlayClipAt(clip, pos, 70f, 100f);
			}
		}
	}

	public void PlayDeepPitSound()
	{
		Vector3 pos = Player.GetPos();
		Vector3 down = Vector3.down;
		down *= 20f;
		Vector3 pos2 = pos + down;
		AudioClip clip = DeepSounds[UnityEngine.Random.Range(0, DeepSounds.Length)];
		Utils.PlayClipAt(clip, pos2, 70f, 100f);
	}

	public void PlayScare(bool intense = false)
	{
		if (LastScare <= 0f || (intense && LastScareIntense <= 0f))
		{
			LastScare = ScareCooldown;
			AudioClip clip;
			if (!intense)
			{
				clip = Scares[UnityEngine.Random.Range(0, Scares.Length)];
			}
			else
			{
				clip = IntenseScares[UnityEngine.Random.Range(0, IntenseScares.Length)];
				LastScareIntense = ScareIntenseCooldown;
			}
			AudioSource.PlayClipAtPoint(clip, base.transform.position);
		}
		FearEffect.Get().Scare(jumpScare: true);
	}
}
public class StepSounds : MonoBehaviour
{
	[Serializable]
	public class StepTypeCollection
	{
		public string name;

		public AudioClip[] sounds;
	}

	public StepTypeCollection[] soundsList;

	private Dictionary<string, AudioClip[]> soundsDict;

	private AudioClip[] curSounds;

	private int SoundIndex;

	private int FootIndex;

	public float SoundInterval = 50f;

	private float MovementSpeed;

	private Vector3 lastPosition;

	private float soundDistance;

	private Point lastCell;

	private void Start()
	{
		soundsDict = new Dictionary<string, AudioClip[]>();
		for (int i = 0; i < soundsList.Length; i++)
		{
			soundsDict[soundsList[i].name] = soundsList[i].sounds;
		}
		curSounds = soundsDict["default"];
		lastPosition = base.transform.position;
		soundDistance = SoundInterval;
		lastCell = Map.Get().WorldToCell(lastPosition);
	}

	private void Update()
	{
		Point point = Map.Get().WorldToCell(base.transform.position);
		if (point != lastCell)
		{
			lastCell = point;
			SetGroundType(Map.Get().Tags.GetStyle(Map.Get().mapStyles, point).floorStepSound);
		}
		if (curSounds.Length < 2)
		{
			return;
		}
		Vector3 position = base.transform.position;
		MovementSpeed = (position - lastPosition).ToGround().magnitude / (1f / 60f);
		lastPosition = position;
		if (MovementSpeed == 0f)
		{
			soundDistance = SoundInterval;
			return;
		}
		soundDistance -= MovementSpeed;
		if (soundDistance <= 0f)
		{
			soundDistance = SoundInterval;
			Vector3 vector = base.transform.position + base.transform.right * 0.1f * ((FootIndex++ % 2 == 0) ? 1 : (-1));
			int soundIndex = SoundIndex;
			do
			{
				SoundIndex = UnityEngine.Random.Range(0, curSounds.Length);
			}
			while (SoundIndex == soundIndex);
			GetComponent<AudioSource>().Stop();
			GetComponent<AudioSource>().clip = curSounds[SoundIndex];
			GetComponent<AudioSource>().Play();
		}
	}

	public void SetGroundType(string gtype)
	{
		if (!soundsDict.TryGetValue(gtype, out curSounds))
		{
			curSounds = soundsDict["default"];
		}
	}
}
public class TextLabel : TimeIndependentBehaviour
{
	[Serializable]
	public class SubstituteFont
	{
		public string language;

		public Font font;

		public Material fontMaterial;

		public int fontSize;
	}

	public string InitText;

	private string _Text;

	public GUIStyle Style;

	public bool wordWrap;

	public float wrapLimit = 1.9f;

	public bool AnimateOpen;

	private float fTargetWidth;

	private bool AnimationStarted;

	private RenderTexture LabelRenderTexture;

	private TextMesh textMesh;

	private Renderer backgroundRenderer;

	public float backgroundHeightFactor = 2.692998f;

	private Vector3 backgroundStartScale;

	private bool IsUpdated;

	private bool fading;

	private float targetFade = 1f;

	private float fadeSpeed = 4f;

	private bool disableOnFadeOut;

	private bool destroyOnFadeOut;

	public Color textColor = Color.white;

	private Color tempTextColor;

	private Color[] tempMatColors;

	private bool isDarkened;

	public bool noDarken;

	public SubstituteFont[] substituteFonts;

	public string Text
	{
		get
		{
			return _Text;
		}
		set
		{
			_Text = value;
			IsUpdated = false;
			if (wordWrap)
			{
				_Text = WordWrap(_Text);
			}
			int num = GetComponent<Renderer>().materials.Length;
			if (num > 1)
			{
				textMesh.text = "<material=" + (num - 1) + ">" + _Text + "</material>";
			}
			else
			{
				textMesh.text = _Text;
			}
		}
	}

	private new void Awake()
	{
		base.Awake();
		textMesh = GetComponent<TextMesh>();
		if (substituteFonts != null)
		{
			SubstituteFont substituteFont = null;
			for (int i = 0; i < substituteFonts.Length; i++)
			{
				if (substituteFont != null)
				{
					break;
				}
				if (substituteFonts[i].language == Translate.GetLanguage())
				{
					substituteFont = substituteFonts[i];
				}
			}
			if (substituteFont != null)
			{
				textMesh.font = substituteFont.font;
				textMesh.fontSize = substituteFont.fontSize;
				Renderer component = GetComponent<Renderer>();
				Material[] array = new Material[component.materials.Length];
				for (int j = 0; j < component.materials.Length; j++)
				{
					array[j] = component.materials[j];
				}
				array[array.Length - 1] = substituteFont.fontMaterial;
				component.materials = array;
			}
		}
		Transform transform = base.transform.Find("background");
		if (transform != null)
		{
			backgroundRenderer = transform.GetComponent<Renderer>();
			backgroundRenderer.enabled = false;
			backgroundStartScale = backgroundRenderer.transform.localScale;
		}
		IsUpdated = false;
		Text = InitText;
		AnimationStarted = false;
		if (AnimateOpen)
		{
			GetComponent<Renderer>().enabled = false;
		}
		targetFade = 1f;
		disableOnFadeOut = false;
		destroyOnFadeOut = false;
		if (textMesh != null)
		{
			textMesh.color = new Color(textMesh.color.r, textMesh.color.g, textMesh.color.b, 0f);
		}
		if (backgroundRenderer != null)
		{
			backgroundRenderer.material.color = new Color(1f, 1f, 1f, 0f);
		}
	}

	private new void Update()
	{
		base.Update();
		if (isDarkened)
		{
			return;
		}
		if (AnimateOpen)
		{
			if (!AnimationStarted && IsUpdated)
			{
				AnimationStarted = true;
				Vector3 localScale = base.transform.localScale;
				localScale.x = 0.0001f;
				base.transform.localScale = localScale;
				GetComponent<Renderer>().enabled = true;
				if (backgroundRenderer != null)
				{
					backgroundRenderer.enabled = true;
				}
			}
			else if (AnimationStarted)
			{
				float num = fTargetWidth - base.transform.localScale.x;
				Vector3 localScale2 = base.transform.localScale;
				localScale2.x += num * 5f * base.deltaTime;
				base.transform.localScale = localScale2;
			}
		}
		if (!fading && !isDarkened)
		{
			textMesh.color = new Color(textColor.r, textColor.g, textColor.b, (!IsUpdated) ? 0f : 1f);
		}
		if (GetComponent<Renderer>().enabled && fading)
		{
			float num2 = Mathf.Lerp(textMesh.color.a, targetFade, base.deltaTime * fadeSpeed);
			textMesh.color = new Color(textColor.r, textColor.g, textColor.b, num2);
			if (GetComponent<Renderer>().materials.Length >= 2)
			{
				for (int i = 0; i < GetComponent<Renderer>().materials.Length; i++)
				{
					GetComponent<Renderer>().materials[i].color = new Color(textColor.r, textColor.g, textColor.b, num2);
				}
			}
			if (backgroundRenderer != null)
			{
				backgroundRenderer.material.color = textMesh.color;
			}
			if (targetFade <= 0f && num2 <= 0.26f)
			{
				GetComponent<Renderer>().enabled = false;
				if (backgroundRenderer != null)
				{
					backgroundRenderer.enabled = false;
				}
				if (disableOnFadeOut)
				{
					base.gameObject.SetActive(value: false);
				}
				if (destroyOnFadeOut)
				{
					UnityEngine.Object.Destroy(base.gameObject);
				}
			}
		}
		if (!IsUpdated)
		{
			if (backgroundRenderer != null)
			{
				Vector3 vector = GetComponent<Renderer>().bounds.extents * 2f;
				float num3 = Mathf.Sqrt(vector.x * vector.x + vector.z * vector.z);
				float y = vector.y;
				Vector3 localScale3 = backgroundStartScale;
				localScale3.y = y * backgroundHeightFactor;
				backgroundRenderer.transform.localScale = localScale3;
			}
			IsUpdated = true;
		}
	}

	public void Close()
	{
		if (AnimateOpen)
		{
			fTargetWidth = 0f;
			UnityEngine.Object.Destroy(base.gameObject, 1f);
		}
		else
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	public void FadeIn(float fadeSpeed = 4f)
	{
		textMesh.color = new Color(1f, 1f, 1f, 0f);
		targetFade = 1f;
		this.fadeSpeed = fadeSpeed;
		GetComponent<Renderer>().enabled = true;
		if (backgroundRenderer != null)
		{
			backgroundRenderer.enabled = true;
			backgroundRenderer.material.color = textMesh.color;
		}
		if (GetComponent<Renderer>().materials.Length >= 2)
		{
			for (int i = 0; i < GetComponent<Renderer>().materials.Length; i++)
			{
				GetComponent<Renderer>().materials[i].color = new Color(1f, 1f, 1f, 0f);
			}
		}
		disableOnFadeOut = false;
		destroyOnFadeOut = false;
		fading = true;
	}

	public void FadeOut(float fadeSpeed = 4f, bool disableOnFadeOut = false, bool destroyOnFadeOut = false)
	{
		targetFade = 0f;
		this.fadeSpeed = fadeSpeed;
		this.disableOnFadeOut = disableOnFadeOut;
		this.destroyOnFadeOut = destroyOnFadeOut;
		fading = true;
	}

	public void FadeInDelayed(float fadeSpeed = 4f, float delay = 1f)
	{
		textMesh.color = new Color(1f, 1f, 1f, 0f);
		GetComponent<Renderer>().enabled = false;
		if (backgroundRenderer != null)
		{
			backgroundRenderer.enabled = true;
			backgroundRenderer.material.color = textMesh.color;
		}
		fading = false;
		StartCoroutine(FadeInDelayed_co(fadeSpeed, delay));
	}

	private IEnumerator FadeInDelayed_co(float fadeSpeed = 4f, float delay = 1f)
	{
		yield return new WaitForSeconds(delay);
		if (!fading)
		{
			FadeIn(fadeSpeed);
		}
	}

	public void ShowText(string text)
	{
		Text = text;
		GetComponent<Renderer>().enabled = true;
		if (backgroundRenderer != null)
		{
			backgroundRenderer.enabled = true;
			Color color = textMesh.color;
			color.a = 1f;
			backgroundRenderer.material.color = color;
		}
	}

	public void HideText()
	{
		GetComponent<Renderer>().enabled = false;
		if (backgroundRenderer != null)
		{
			backgroundRenderer.enabled = false;
		}
	}

	private string WordWrap(string sourceStr)
	{
		return Utils.WordWrap(sourceStr, textMesh, wrapLimit);
	}

	public void SetDarkened(bool darken)
	{
		if (noDarken)
		{
			return;
		}
		if (!isDarkened && darken)
		{
			tempTextColor = textColor;
			textColor.a = 0f;
			isDarkened = darken;
			textMesh.color = textColor;
			Renderer component = GetComponent<Renderer>();
			int num = component.materials.Length;
			tempMatColors = new Color[num];
			for (int i = 0; i < num; i++)
			{
				ref Color reference = ref tempMatColors[i];
				reference = component.materials[i].color;
				component.materials[i].color = component.materials[i].color.WithAlpha(0f);
			}
		}
		else if (isDarkened && !darken)
		{
			textColor = tempTextColor;
			isDarkened = darken;
			textMesh.color = textColor;
			Renderer component2 = GetComponent<Renderer>();
			int num2 = component2.materials.Length;
			for (int j = 0; j < num2; j++)
			{
				component2.materials[j].color = tempMatColors[j];
			}
		}
	}
}
public class TiltPeek : MonoBehaviour
{
	public Transform LookDir;

	public float PeekDistance = 0.1f;

	public float MinAngle = 8f;

	public float MaxAngle = 45f;

	private Vector3 StartNeckPos;

	private Pvr_UnitySDKManager[] CameraController;

	private void Start()
	{
		CameraController = base.transform.GetComponents<Pvr_UnitySDKManager>();
		StartNeckPos = CameraController[0].transform.Find("Head").position;
	}

	private void Update()
	{
		float value = Vector3.Angle(LookDir.right, base.transform.right);
		Vector3 lhs = Vector3.Cross(LookDir.right, base.transform.right);
		bool flag = Vector3.Dot(lhs, base.transform.forward) > 0f;
		float t = (Mathf.Clamp(value, MinAngle, MaxAngle) - MinAngle) / (MaxAngle - MinAngle);
		float num = Mathf.Lerp(0f, PeekDistance, t) * ((!flag) ? (-1f) : 1f);
		for (int i = 0; i < CameraController.Length; i++)
		{
			CameraController[0].transform.Find("Head").position = StartNeckPos + base.transform.right * num;
		}
	}

	public void SetToStart()
	{
		for (int i = 0; i < CameraController.Length; i++)
		{
			CameraController[0].transform.Find("Head").position = StartNeckPos;
		}
	}
}
[RequireComponent(typeof(TorchLight))]
public class TorchFuel : MonoBehaviour
{
	private TorchLight torch;

	public bool lightOn = true;

	public float Fuel = 1f;

	public float FuelConsumption = 0.01f;

	public float NormalIntensity = 1f;

	public float LowIntensity = 0.3f;

	public float LowRangeFactor = 0.375f;

	public float HighBurnIntensity = 2f;

	public float LightSpeed = 0.5f;

	public float LightToggleSpeed = 4f;

	public float LightBurnSpeed = 2f;

	public float LightBurnTime = 0.3f;

	public float BurnFuelConsumptionRate = 4f;

	private float lightCurSpeed;

	private float lightBtnTime;

	public bool burning;

	public bool btnEnabled = true;

	public AudioClip FuelSound;

	public AudioClip OnSound;

	public AudioClip OffSound;

	private AudioSource burningSound;

	private void Start()
	{
		torch = GetComponent<TorchLight>();
		lightOn = true;
		lightCurSpeed = LightSpeed;
		lightBtnTime = 0f;
		burning = false;
		burningSound = GetComponent<AudioSource>();
		Fuel = GameState.Get().fuel;
	}

	private void Update()
	{
		float fuel = Fuel;
		if (lightOn)
		{
			Fuel -= ((!burning) ? 1f : BurnFuelConsumptionRate) * FuelConsumption * Time.deltaTime;
		}
		float b = ((!lightOn) ? LowIntensity : ((!burning) ? NormalIntensity : HighBurnIntensity));
		float b2 = ((!lightOn) ? LowRangeFactor : 1f);
		if (lightOn && Fuel <= 0f)
		{
			b = LowIntensity;
			b2 = LowRangeFactor;
			Fuel = 0f;
			burning = false;
			torch.StopFlickerOil();
		}
		else if (lightOn && ((fuel >= 0.15f && Fuel < 0.15f) || (fuel >= 0.1f && Fuel < 0.1f) || (fuel >= 0.06f && Fuel < 0.06f) || (fuel >= 0.03f && Fuel < 0.03f)))
		{
			torch.FlickerOil();
		}
		torch.factor = Mathf.Lerp(torch.factor, b, Time.deltaTime * lightCurSpeed);
		torch.rangeFactor = Mathf.Lerp(torch.rangeFactor, b2, Time.deltaTime * lightCurSpeed);
		if (lightOn && !burning && torch.factor >= NormalIntensity - 0.01f && torch.factor <= NormalIntensity + 0.5f)
		{
			lightCurSpeed = LightSpeed;
		}
		else if (lightOn && burning)
		{
			lightCurSpeed = LightBurnSpeed;
		}
		else if (!lightOn && torch.factor <= LowIntensity + 0.01f)
		{
			lightCurSpeed = LightSpeed;
		}
		if (btnEnabled && InputExt.GetButtonDown(InputExt.Button.Light))
		{
			ToggleLight();
		}
		UpdateBurningSound();
	}

	public void ToggleLight()
	{
		if (lightOn)
		{
			lightOn = false;
			lightCurSpeed = LightToggleSpeed;
			AudioSource.PlayClipAtPoint(OffSound, base.transform.position);
			if (Config.General().tutorials && !Tutorial.HasBeenShownBefore("TUTO_LIGHT_REENABLE", add: true))
			{
				Tutorial.Get().ShowTextForTime(Translate.GetForInput("TUTO_LIGHT_REENABLE"), 4f);
			}
		}
		else if (Fuel > 0f)
		{
			lightOn = !lightOn;
			lightCurSpeed = LightToggleSpeed;
			AudioSource.PlayClipAtPoint(OnSound, base.transform.position);
		}
	}

	private void UpdateBurningSound()
	{
		if (burning)
		{
			if (!burningSound.isPlaying)
			{
				burningSound.volume = 0f;
				burningSound.Play();
			}
			burningSound.volume = Mathf.Lerp(burningSound.volume, 1f, Time.deltaTime * 4f);
		}
		else
		{
			burningSound.volume = Mathf.Lerp(burningSound.volume, 0f, Time.deltaTime * 2f);
			if (burningSound.volume <= 0.1f)
			{
				burningSound.Stop();
			}
		}
	}

	public void AddFuel(float fuel = 1f)
	{
		Fuel += fuel;
		torch.factor = HighBurnIntensity;
		torch.StopFlickerOil(endFlicker: true);
		AudioSource.PlayClipAtPoint(FuelSound, base.transform.position);
		if (!lightOn)
		{
			lightOn = true;
			lightCurSpeed = LightSpeed;
		}
	}

	public bool RemoveFuel(float fuel = 1f, bool removeOnlyIfEnough = false)
	{
		bool flag = Fuel >= fuel;
		if (flag || !removeOnlyIfEnough)
		{
			Fuel -= fuel;
			if (Fuel <= 0f)
			{
				Fuel = 0f;
			}
		}
		return flag;
	}

	private void OnLightTurnOff(TorchLight tlight)
	{
		lightOn = false;
		lightCurSpeed = LightToggleSpeed;
		lightBtnTime = 0f;
		burning = false;
	}

	public float GetFuelLevelNormalized()
	{
		return Mathf.Clamp01(Fuel / 1.3f);
	}

	public string GetDescriptionText()
	{
		string text = Translate.Get("INV_LAMP_0");
		if (lightOn)
		{
			if (GameController.Get().gameState.lampDescriptions > 0)
			{
				GameController.Get().gameState.lampDescriptions--;
			}
			else if (UnityEngine.Random.value > 0.4f)
			{
				int num = UnityEngine.Random.Range(1, 16);
				string key = "INV_LAMP_" + num;
				text = Translate.Get(key);
			}
		}
		float fuelLevelNormalized = GetFuelLevelNormalized();
		string empty = string.Empty;
		empty = ((fuelLevelNormalized <= 0f) ? Translate.Get("INV_LAMP_LEVEL_0") : ((fuelLevelNormalized <= 0.2f) ? Translate.Get("INV_LAMP_LEVEL_1") : ((fuelLevelNormalized <= 0.6f) ? Translate.Get("INV_LAMP_LEVEL_2") : ((!(fuelLevelNormalized <= 0.9f)) ? Translate.Get("INV_LAMP_LEVEL_4") : Translate.Get("INV_LAMP_LEVEL_3")))));
		return text + "\n" + empty;
	}

	public bool IsLightOn()
	{
		return lightOn && Fuel > 0f;
	}
}
public class TutoLockArrows : TimeIndependentBehaviour
{
	public float rotSpeed = 1f;

	public float rotAmount = 60f;

	public float flipflopTime = 1f;

	public AnimationCurve scaleCurve;

	public float scaleSpeed = 1f;

	private float timer;

	private Quaternion rotTarget;

	private float scaleFactor;

	private void Start()
	{
		base.transform.localScale = Vector3.zero;
	}

	private new void Update()
	{
		base.Update();
		timer -= base.deltaTime;
		if (timer <= 0f)
		{
			base.transform.Rotate(0f, 180f, 0f);
			rotTarget = Quaternion.Euler(base.transform.localRotation.eulerAngles + new Vector3(0f, 0f, rotAmount));
			timer = flipflopTime;
		}
		base.transform.localRotation = Quaternion.Lerp(base.transform.localRotation, rotTarget, base.deltaTime * rotSpeed);
		scaleFactor = Mathf.Clamp01(scaleFactor + base.deltaTime * scaleSpeed);
		if (GameController.Get().Paused)
		{
			scaleFactor = 0f;
		}
		float num = scaleCurve.Evaluate(scaleFactor);
		base.transform.localScale = Vector3.one * num;
	}
}
public class Tutorial : MonoBehaviour
{
	[Serializable]
	public class TutorialState
	{
		public string versionCode;

		public List<string> tutorialStrings;

		public bool tutorialCollect;

		public TutorialState()
		{
			Reset();
		}

		public void Reset()
		{
			versionCode = GlobalParams.tutorialStateVersion;
			tutorialStrings = new List<string>();
			tutorialCollect = false;
		}

		public static TutorialState Load(string stateName = "Tutorials_00")
		{
			TutorialState defaultValue = new TutorialState();
			defaultValue = Serializer.DeserializeObject(stateName, defaultValue);
			if (defaultValue.versionCode == GlobalParams.tutorialStateVersion)
			{
				return defaultValue;
			}
			return null;
		}

		public void Save(string gameName = "Tutorials_00")
		{
			Serializer.SerializeObject(this, gameName);
		}
	}

	private static Tutorial instance;

	private TextLabel TLabel;

	private static bool ShowTutorialOil = true;

	private static bool ShowTutorialLight = true;

	public bool showDemoText;

	public TextLabel inPlacePrefab;

	public TutorialState tutoState;

	private bool forceTutorialOil;

	public static Tutorial Get()
	{
		return instance;
	}

	private void Start()
	{
		instance = this;
		TLabel = GetComponent<TextLabel>();
		tutoState = TutorialState.Load();
		if (tutoState == null)
		{
			tutoState = new TutorialState();
		}
		if (ShowTutorialOil)
		{
			StartCoroutine(DoTutorialOil_co());
		}
		if (GameController.Get().levelOptions.isDemo)
		{
			ShowTutorialLight = false;
			showDemoText = true;
		}
		string startText = GameController.Get().levelOptions.GetStartText();
		if (startText != string.Empty && Config.General().tutorials)
		{
			ShowTextForTime(startText, 6f);
		}
	}

	private IEnumerator DoTutorialOil_co()
	{
		TorchFuel playerTorch = GameObject.FindWithTag(Tags.PlayerTorch).GetComponent<TorchFuel>();
		if (showDemoText)
		{
			yield return new WaitForSeconds(4f);
			ShowTutorialText(Translate.Get("TUTO_DEMO"));
			yield return new WaitForSeconds(4f);
			HideTutorialText();
		}
		while (playerTorch.Fuel > 0f && !forceTutorialOil)
		{
			yield return new WaitForSeconds(1f);
		}
		Inventory inventory = GameObject.FindWithTag(Tags.Inventory).GetComponent<Inventory>();
		while (inventory.NumItems[0] <= 0)
		{
			yield return new WaitForSeconds(1f);
		}
		if ((playerTorch.Fuel <= 0f || forceTutorialOil) && inventory.NumItems[0] > 0)
		{
			ShowTutorialText(Translate.GetForInput("TUTO_OIL_1"));
		}
		float curOil = playerTorch.Fuel;
		float fTime2 = Time.time;
		while ((playerTorch.Fuel <= curOil || forceTutorialOil) && Time.time - fTime2 < 4f)
		{
			yield return new WaitForEndOfFrame();
		}
		if (playerTorch.Fuel <= curOil && inventory.NumItems[0] > 0)
		{
			ShowTutorialText(Translate.GetForInput("TUTO_OIL_2"));
		}
		fTime2 = Time.time;
		while (playerTorch.Fuel <= curOil && Time.time - fTime2 < 20f)
		{
			yield return new WaitForEndOfFrame();
		}
		HideTutorialText();
		ShowTutorialOil = false;
	}

	public void ForceTutorialOil()
	{
		forceTutorialOil = true;
	}

	public void DoTutorialLight()
	{
		if (ShowTutorialLight)
		{
			StartCoroutine(DoTutorialLight_co());
		}
	}

	private IEnumerator DoTutorialLight_co()
	{
		TorchFuel playerTorch = GameObject.FindWithTag(Tags.PlayerTorch).GetComponent<TorchFuel>();
		if (playerTorch.lightOn)
		{
			ShowTutorialText(Translate.GetForInput("TUTO_LIGHT_1"));
		}
		ShowTutorialLight = false;
		float fTime = Time.time;
		while (playerTorch.lightOn && Time.time - fTime < 8f)
		{
			yield return new WaitForEndOfFrame();
		}
		HideTutorialText();
	}

	public void ShowTextForTime(string text, float time)
	{
		StopCoroutine("ShowTextForTime_co");
		StartCoroutine(ShowTextForTime_co(text, time));
	}

	private IEnumerator ShowTextForTime_co(string text, float time)
	{
		TLabel.ShowText(text);
		yield return new WaitForSeconds(time);
		HideTutorialText();
	}

	private void ShowTutorialText(string text)
	{
		if (Config.General().tutorials)
		{
			TLabel.ShowText(text);
		}
	}

	private void HideTutorialText()
	{
		TLabel.HideText();
	}

	public static bool HasBeenShownBefore(string textCode, bool add)
	{
		if (!Config.General().tutorials)
		{
			return true;
		}
		GameState gameState = GameController.Get().gameState;
		if (Get().tutoState.tutorialStrings.Contains(textCode))
		{
			return true;
		}
		if (add)
		{
			Get().tutoState.tutorialStrings.Add(textCode);
		}
		return false;
	}

	public static TextLabel ShowInPlace(string textCode, Vector3 localPos, Quaternion localRot, Transform parent = null, float fadeSpeed = 4f, bool facePlayer = false)
	{
		if (!Config.General().tutorials || HasBeenShownBefore(textCode, add: true))
		{
			return null;
		}
		string forInput = Translate.GetForInput(textCode);
		TextLabel textLabel = UnityEngine.Object.Instantiate(Get().inPlacePrefab);
		if ((bool)parent)
		{
			textLabel.transform.parent = parent;
		}
		textLabel.transform.localPosition = localPos;
		textLabel.transform.localRotation = localRot;
		textLabel.Text = forInput;
		textLabel.FadeIn(fadeSpeed);
		if (facePlayer)
		{
			LookAtTarget lookAtTarget = textLabel.gameObject.AddComponent<LookAtTarget>();
			lookAtTarget.target = Player.GetLook();
			lookAtTarget.inverted = true;
			lookAtTarget.maxAngle = 40f;
		}
		return textLabel;
	}

	public static void ResetAndSave(string stateName = "Tutorials_00")
	{
		TutorialState tutorialState = new TutorialState();
		tutorialState.Reset();
		tutorialState.Save(stateName);
	}

	public void Save(string stateName = "Tutorials_00")
	{
		tutoState.Save(stateName);
	}
}
public class RandomSounds : MonoBehaviour
{
	public AudioClip[] Sounds;

	public float IntervalMin = 8f;

	public float IntervalMax = 40f;

	public float MinDistance = 0.8f;

	public float MaxDistance = 16f;

	public float Spread;

	public bool Playing = true;

	public bool PlayInmediate;

	public bool muteSoundsIfFar;

	public float highDistance;

	public float highDistanceChance;

	private void Start()
	{
		StartCoroutine(PlaySound());
	}

	public void PlayNow()
	{
		AudioClip clip = Sounds[UnityEngine.Random.Range(0, Sounds.Length)];
		float maxDistance = MaxDistance;
		if (highDistanceChance >= 0.05f)
		{
			float value = UnityEngine.Random.value;
			if (value <= highDistanceChance)
			{
				maxDistance = highDistance;
			}
		}
		Utils.PlayClipAt(clip, base.transform.position, MinDistance, maxDistance, Spread);
	}

	private IEnumerator PlaySound()
	{
		bool playFirst = PlayInmediate;
		while (true)
		{
			float nextSound = UnityEngine.Random.Range(IntervalMin, IntervalMax);
			if (!playFirst)
			{
				yield return new WaitForSeconds(nextSound);
			}
			playFirst = false;
			if (Playing)
			{
				PlayNow();
			}
		}
	}
}
public class Recenterer : MonoBehaviour
{
	private static Recenterer instance;

	public bool recenterOnLoad;

	public bool recenterOnFirstFrame;

	private bool firstUpdate = true;

	public static Recenterer Get()
	{
		return instance;
	}

	public static void Clear()
	{
		instance = null;
	}

	private void Awake()
	{
		instance = this;
	}

	private void Start()
	{
		if (recenterOnLoad)
		{
			Recenter();
		}
	}

	private void Update()
	{
		if (firstUpdate)
		{
			firstUpdate = false;
			if (recenterOnFirstFrame)
			{
				Recenter();
			}
		}
	}

	public void Recenter()
	{
	}
}
public class Screenshot : MonoBehaviour
{
	public string folder = "%TEMP%\\";

	public int supersize = 1;

	private int iNumber;

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.P))
		{
			Debug.Log("Imprimiendo screenshot en: \"" + folder + "Screenshot" + iNumber + ".png\"");
			ScreenCapture.CaptureScreenshot(folder + "Screenshot" + iNumber + ".png", supersize);
			iNumber++;
		}
	}
}
public class Intro : MonoBehaviour
{
	public Renderer[] IntroGamepad;

	public Renderer[] IntroKeyboard;

	public float FadeInSpeed = 0.6f;

	public float FadeOutSpeed = 0.6f;

	private bool CanContinue;

	private void Start()
	{
		Renderer[] introSeq = ((!GameController.Get().UsingGamepad) ? IntroKeyboard : IntroGamepad);
		CanContinue = false;
		StartCoroutine(IntroSequence(introSeq));
	}

	private IEnumerator IntroSequence(Renderer[] introSeq)
	{
		CanContinue = true;
		yield return new WaitForSeconds(3f);
		StartCoroutine(FadeIn(introSeq[0]));
		yield return new WaitForSeconds(6f);
		StartCoroutine(FadeOut(introSeq[0]));
		StartCoroutine(FadeIn(introSeq[1]));
		yield return new WaitForSeconds(4f);
		StartCoroutine(FadeIn(introSeq[2]));
	}

	private IEnumerator IntroSequenceDev(Renderer[] introSeq)
	{
		CanContinue = true;
		yield return new WaitForSeconds(3f);
		StartCoroutine(FadeIn(introSeq[0]));
		yield return new WaitForSeconds(6f);
		StartCoroutine(FadeOut(introSeq[0]));
		StartCoroutine(FadeIn(introSeq[1]));
	}

	private IEnumerator FadeIn(Renderer renderer)
	{
		while (renderer.material.color.a < 1f)
		{
			Color c = renderer.material.color;
			c.a = Mathf.Clamp(c.a + FadeInSpeed * Time.deltaTime, 0f, 1f);
			renderer.material.color = c;
			yield return new WaitForEndOfFrame();
		}
	}

	private IEnumerator FadeOut(Renderer renderer)
	{
		while (renderer.material.color.a > 0f)
		{
			Color c = renderer.material.color;
			c.a = Mathf.Clamp(c.a - FadeOutSpeed * Time.deltaTime, 0f, 1f);
			renderer.material.color = c;
			yield return new WaitForEndOfFrame();
		}
	}

	private void Update()
	{
		if (CanContinue && (InputExt.GetButtonDown(InputExt.Button.Action) || InputExt.GetButtonDown(InputExt.Button.UIAction)))
		{
			CanContinue = false;
			Fader component = GameObject.Find("Fader").GetComponent<Fader>();
			component.FadeOut(1f, fadeAudio: true, base.gameObject);
		}
	}

	public void OnEndFade(Fader fader)
	{
		AudioListener.volume = Config.Audio().masterVolume;
		Debug.Log("Loading level: Dungeon");
		Loader.LoadLevel("Dungeon");
	}
}
public class Outro : MonoBehaviour
{
	public TextLabel CreditsLabel1;

	public TextLabel CreditsLabel2;

	public float FadeInSpeed = 0.6f;

	public float FadeOutSpeed = 0.6f;

	private void Start()
	{
		StartCoroutine(OutroSequence());
	}

	private IEnumerator OutroSequence()
	{
		CreditsLabel1.Text = "Design & Development:\n\nSergio Hidalgo";
		StartCoroutine(FadeIn(CreditsLabel1.GetComponent<Renderer>()));
		yield return new WaitForSeconds(8f);
		CreditsLabel2.Text = "Uses models and textures from:\n\nUnity Asset Store\nVeleran\nwww.myfreetextures.com";
		StartCoroutine(FadeOut(CreditsLabel1.GetComponent<Renderer>()));
		StartCoroutine(FadeIn(CreditsLabel2.GetComponent<Renderer>()));
		yield return new WaitForSeconds(6f);
		string sSound5 = "Uses sound and music from:\n\nwww.freesound.org\n";
		sSound5 += "Unfa, Rthtsdf, CGEffex, Solid80,\n";
		sSound5 += "Wolfsinger, Sea Fury, TheGoliath, Yottasounds,\n";
		sSound5 += "ssPatchen, Timmy-h123, Primejunt, Under7dude,\n";
		sSound5 += "Mitchelk, Suonho, Snaginneb, Qubodup\n";
		CreditsLabel1.Text = sSound5;
		StartCoroutine(FadeOut(CreditsLabel2.GetComponent<Renderer>()));
		StartCoroutine(FadeIn(CreditsLabel1.GetComponent<Renderer>()));
		yield return new WaitForSeconds(7f);
		CreditsLabel2.Text = "Thanks for playing.";
		StartCoroutine(FadeOut(CreditsLabel1.GetComponent<Renderer>()));
		StartCoroutine(FadeIn(CreditsLabel2.GetComponent<Renderer>()));
		yield return new WaitForSeconds(6f);
		StartCoroutine(FadeOut(CreditsLabel2.GetComponent<Renderer>()));
		yield return new WaitForSeconds(2f);
		Fader fader = GameObject.Find("Fader").GetComponent<Fader>();
		fader.FadeOut(1f, fadeAudio: false, base.gameObject);
	}

	private IEnumerator FadeIn(Renderer renderer)
	{
		while (renderer.material.color.a < 1f)
		{
			Color c = renderer.material.color;
			c.a = Mathf.Clamp(c.a + FadeInSpeed * Time.deltaTime, 0f, 1f);
			renderer.material.color = c;
			yield return new WaitForEndOfFrame();
		}
	}

	private IEnumerator FadeOut(Renderer renderer)
	{
		while (renderer.material.color.a > 0f)
		{
			Color c = renderer.material.color;
			c.a = Mathf.Clamp(c.a - FadeOutSpeed * Time.deltaTime, 0f, 1f);
			renderer.material.color = c;
			yield return new WaitForEndOfFrame();
		}
	}

	private void Update()
	{
		if (InputExt.GetButtonDown(InputExt.Button.Action) || InputExt.GetButtonDown(InputExt.Button.UIAction))
		{
			Fader component = GameObject.Find("Fader").GetComponent<Fader>();
			component.FadeOut(1f, fadeAudio: false, base.gameObject);
		}
	}

	public void OnEndFade(Fader fader)
	{
		Application.LoadLevel("Intro");
	}
}
public class Serializer
{
	public delegate void OnSerialize(BinaryWriter writer);

	public delegate void OnDeserialize(BinaryReader reader);

	private int serialIdx;

	private Dictionary<string, Tuple<Component, OnSerialize, OnDeserialize>> registeredObjs = new Dictionary<string, Tuple<Component, OnSerialize, OnDeserialize>>();

	private Dictionary<Component, string> objToKey = new Dictionary<Component, string>();

	private List<string> removedObjs = new List<string>();

	public static void Add(Component obj, OnSerialize onSerialize, OnDeserialize onDeserialize)
	{
		if (GameController.Get().levelOptions.serializeID != 0)
		{
			Serializer serializer = GameController.Get().serializer;
			Tuple<Component, OnSerialize, OnDeserialize> value = new Tuple<Component, OnSerialize, OnDeserialize>(obj, onSerialize, onDeserialize);
			string text = obj.name + "-" + serializer.serialIdx;
			serializer.serialIdx++;
			serializer.objToKey[obj] = text;
			if (serializer.removedObjs.Contains(text))
			{
				UnityEngine.Object.Destroy(obj.gameObject);
				serializer.registeredObjs.Remove(text);
			}
			else
			{
				serializer.registeredObjs[text] = value;
			}
		}
	}

	public static void Remove(Component obj)
	{
		if (GameController.Get().levelOptions.serializeID != 0)
		{
			Serializer serializer = GameController.Get().serializer;
			string text = serializer.objToKey[obj];
			serializer.removedObjs.Add(text);
			serializer.registeredObjs.Remove(text);
		}
	}

	public void SaveGame(string gameName = "SavedGame_00", bool overwriteMap = true, bool refreshData = true)
	{
		Debug.Log("Saving game " + gameName);
		if (refreshData)
		{
			GameState.Get().Refresh(overwriteMap);
		}
		if (overwriteMap)
		{
			List<string> list = new List<string>();
			List<string> list2 = new List<string>();
			foreach (string key in registeredObjs.Keys)
			{
				MemoryStream memoryStream = new MemoryStream();
				BinaryWriter writer = new BinaryWriter(memoryStream);
				registeredObjs[key].Item2(writer);
				string item = Convert.ToBase64String(memoryStream.GetBuffer());
				list.Add(key);
				list2.Add(item);
			}
			GameState.Get().objectsIds = list;
			GameState.Get().objectsData = list2;
			GameState.Get().removedObjs = removedObjs;
		}
		GameState.Save(gameName);
	}

	public bool LoadGame(string gameName = "SavedGame_00")
	{
		Debug.Log("Loading game " + gameName);
		if (GameState.Get().liteVersion)
		{
			Debug.Log("Game tagged as LITE version");
		}
		if (!GameState.Load(gameName))
		{
			Debug.LogError("Error loading game " + gameName + " - Incorrect version");
			return false;
		}
		Fader component = GameObject.Find("Fader").GetComponent<Fader>();
		component.FadeOut(4f, fadeAudio: true, null, LoadGame_OnEndFade);
		return true;
	}

	private void LoadGame_OnEndFade()
	{
		LevelOptions metaLevelOptions = LevelOptions.GetMetaLevelOptions(GameState.Get().metaMap);
		GameController.nextOptions = metaLevelOptions;
		Loader.LoadLevel("Dungeon");
	}

	public void DeserializeRegisteredObjs()
	{
		List<string> objectsIds = GameState.Get().objectsIds;
		List<string> objectsData = GameState.Get().objectsData;
		for (int i = 0; i < objectsIds.Count; i++)
		{
			string key = objectsIds[i];
			if (registeredObjs.TryGetValue(key, out var value))
			{
				MemoryStream input = new MemoryStream(Convert.FromBase64String(objectsData[i]));
				BinaryReader reader = new BinaryReader(input);
				value.Item3(reader);
			}
		}
		removedObjs = new List<string>();
		for (int j = 0; j < GameState.Get().removedObjs.Count; j++)
		{
			removedObjs.Add(GameState.Get().removedObjs[j]);
			string key2 = GameState.Get().removedObjs[j];
			if (registeredObjs.TryGetValue(key2, out var value2))
			{
				UnityEngine.Object.Destroy(value2.Item1.gameObject);
				registeredObjs.Remove(key2);
			}
		}
	}

	public static void SerializeObject(object obj, string key)
	{
		BinaryFormatter binaryFormatter = new BinaryFormatter();
		MemoryStream memoryStream = new MemoryStream();
		binaryFormatter.Serialize(memoryStream, obj);
		PlayerPrefs.SetString(key, Convert.ToBase64String(memoryStream.GetBuffer()));
	}

	public static T DeserializeObject<T>(string key, T defaultValue = null) where T : class
	{
		string @string = PlayerPrefs.GetString(key);
		if (@string != string.Empty)
		{
			BinaryFormatter binaryFormatter = new BinaryFormatter();
			MemoryStream serializationStream = new MemoryStream(Convert.FromBase64String(@string));
			return binaryFormatter.Deserialize(serializationStream) as T;
		}
		return defaultValue;
	}
}
namespace SpookEvents
{
	public class DoorCreak : SpookEvent
	{
		public bool withWind;

		public float maxRange = 15f;

		private List<Door> candidates;

		protected override void OnEnable()
		{
			base.OnEnable();
			candidates = new List<Door>();
		}

		public override bool CheckConditions()
		{
			if (GameController.Get().levelOptions.IsMetaMap())
			{
				return false;
			}
			candidates.Clear();
			Transform look = Player.GetLook();
			Point currentCell = Player.GetController().CurrentCell;
			Vector3 vector = Map.Get().CellToWorld(currentCell);
			int num = Mathf.CeilToInt(maxRange / Map.Get().TileSize.x);
			for (int i = currentCell.Y - num / 2; i <= currentCell.Y + num / 2; i++)
			{
				for (int j = currentCell.X - num / 2; j <= currentCell.X + num / 2; j++)
				{
					if (!Map.Get().InRange(j, i))
					{
						continue;
					}
					Door door = Map.Get().At(j, i).Door;
					if ((bool)door && !door.IsDestroyed)
					{
						Vector3 vector2 = Vector3Ext.GroundVector(door.transform.position);
						if ((vector - vector2).sqrMagnitude <= maxRange * maxRange && Map.Get().At(j, i).CheckLoS(look.position))
						{
							candidates.Add(door);
						}
					}
				}
			}
			return candidates.Count > 0;
		}

		public override void Play(SpookManager owner)
		{
			if (candidates.Count != 0)
			{
				Door door = RandomExt.Choice(candidates);
				bool flag = !door.IsOpen;
				if (flag && withWind)
				{
					door.OpenWithWind();
				}
				else if (flag)
				{
					door.OpenWithCreak();
				}
				else if (!flag && withWind && !Player.IsSafe())
				{
					door.CloseFastWithWind();
				}
				else if (!flag)
				{
					door.Creak();
				}
			}
		}
	}
	public class LightFlicker : SpookEvent
	{
		public bool turnOff;

		public float range = 8f;

		public GameObject windEffect;

		public LayerMask layer;

		private List<InteractiveLightEx> lights;

		protected override void OnEnable()
		{
			base.OnEnable();
			lights = new List<InteractiveLightEx>();
		}

		public override bool CheckConditions()
		{
			return true;
		}

		public override void Play(SpookManager owner)
		{
			owner.StartCoroutine(Play_co());
		}

		private IEnumerator Play_co()
		{
			TorchLight torch = GameObject.FindWithTag(Tags.PlayerTorch).GetComponent<TorchLight>();
			Vector3 torchPos = torch.transform.position;
			Vector3 playerLook = Vector3Ext.GroundVector(Player.GetLookDir());
			playerLook.Normalize();
			if ((bool)windEffect)
			{
				Vector3 vector = playerLook;
				Vector3 position = torchPos + vector * 2.5f;
				for (int i = 0; i < 5; i++)
				{
					Vector3 vector2 = new Vector3(UnityEngine.Random.Range(-1f, 1f), 0f, UnityEngine.Random.Range(-1f, 1f));
					vector2.Normalize();
					Vector3 vector3 = torchPos + vector2 * UnityEngine.Random.Range(2f, 3f);
					if (Map.Get().At(vector3).CheckLoS(torchPos))
					{
						vector = vector2;
						position = vector3;
						break;
					}
				}
				UnityEngine.Object.Instantiate(windEffect, position, Quaternion.LookRotation(-vector, Vector3.up));
			}
			yield return new WaitForSeconds(0.5f);
			lights.Clear();
			Collider[] colliders = Physics.OverlapSphere(torchPos, range, layer);
			Collider[] array = colliders;
			foreach (Collider collider in array)
			{
				InteractiveLightEx component = collider.GetComponent<InteractiveLightEx>();
				if (!component)
				{
					component = collider.transform.parent.GetComponent<InteractiveLightEx>();
				}
				if ((bool)component && component.lightOn)
				{
					lights.Add(component);
				}
			}
			foreach (InteractiveLightEx light in lights)
			{
				light.FlickerOut(turnOff);
			}
			torch.FlickerOut();
		}
	}
}
public class SpookEvent : ScriptableObject
{
	[Range(0f, 5f)]
	public float weight = 1f;

	protected virtual void OnEnable()
	{
	}

	public virtual bool CheckConditions()
	{
		return true;
	}

	public virtual void Play(SpookManager owner)
	{
	}
}
namespace SpookEvents
{
	public class SpookEventTest1 : SpookEvent
	{
		public float testA = 20f;
	}
	public class SpookEventTest2 : SpookEvent
	{
		public string sTest = "foobar";
	}
}
public class SpookManager : MonoBehaviour
{
	private static SpookManager instance;

	public SpookEvent[] lowIntensityEvents;

	public SpookEvent[] midIntensityEvents;

	public SpookEvent[] highIntensityEvents;

	private List<SpookEvent> skipList;

	private void Awake()
	{
		skipList = new List<SpookEvent>();
		instance = this;
		StartCoroutine(SpawnEvents_co());
	}

	public static SpookManager Get()
	{
		return instance;
	}

	private IEnumerator SpawnEvents_co()
	{
		bool bFirst = true;
		while (true)
		{
			bool bWaitShort = !bFirst && UnityEngine.Random.value < 0.3f;
			bFirst = false;
			float maxWait = ((!bWaitShort) ? 90f : 50f);
			float minWait = ((!bWaitShort) ? 50f : 14f);
			float nextWait = UnityEngine.Random.Range(minWait, maxWait);
			yield return new WaitForSeconds(nextWait);
			if (UnityEngine.Random.value <= 0.5f)
			{
				bool flag = Player.IsSafe();
				float value = UnityEngine.Random.value;
				if (flag || value <= 0.7f)
				{
					PlayLowIntensity();
				}
				else if (value <= 0.9f)
				{
					PlayMidIntensity();
				}
				else
				{
					PlayHighIntensity();
				}
			}
		}
	}

	public bool PlayLowIntensity()
	{
		return PlayEvent(lowIntensityEvents);
	}

	public bool PlayMidIntensity()
	{
		return PlayEvent(midIntensityEvents);
	}

	public bool PlayHighIntensity()
	{
		return PlayEvent(highIntensityEvents);
	}

	private bool PlayEvent(SpookEvent[] list)
	{
		if (list.Length == 0)
		{
			return false;
		}
		skipList.Clear();
		SpookEvent spookEvent = null;
		while (spookEvent == null && skipList.Count < list.Length)
		{
			SpookEvent spookEvent2 = ChooseRandom(list, skipList);
			if ((bool)spookEvent2 && spookEvent2.CheckConditions())
			{
				spookEvent = spookEvent2;
			}
			else
			{
				skipList.Add(spookEvent2);
			}
		}
		if ((bool)spookEvent)
		{
			spookEvent.Play(this);
			return true;
		}
		return false;
	}

	private SpookEvent ChooseRandom(SpookEvent[] list, List<SpookEvent> skip)
	{
		float num = 0f;
		foreach (SpookEvent spookEvent in list)
		{
			if (!skip.Contains(spookEvent))
			{
				num += spookEvent.weight;
			}
		}
		float num2 = UnityEngine.Random.Range(0f, num);
		foreach (SpookEvent spookEvent2 in list)
		{
			if (!skip.Contains(spookEvent2))
			{
				if (spookEvent2.weight > num2)
				{
					return spookEvent2;
				}
				num2 -= spookEvent2.weight;
			}
		}
		return null;
	}

	public bool PlayEvent(SpookEvent spook)
	{
		if (spook.CheckConditions())
		{
			spook.Play(this);
			return true;
		}
		return false;
	}
}
public class StatsBriefing : FSMComponent<StatsBriefing.States>
{
	public enum States
	{
		FadeIn,
		Counting,
		Finished
	}

	public TextLabel textLabel;

	public TextLabel textDataLabel;

	public TextLabel textTitle;

	public TextLabel textContinue;

	private bool fading;

	public Fader fader;

	public MinimapStats minimap;

	public Color colorSuccess;

	public Color colorFailure;

	private float timer;

	private uint tickCounter;

	private int discoveredProbes;

	private uint lastProbesCount;

	private int collectedItems;

	private int nextEvent;

	private PlayerStats.Stats stats;

	private void Start()
	{
		stats = PlayerStats.stats;
		if (stats == null)
		{
			stats = new PlayerStats.Stats();
		}
		string text = Translate.Get("MENU_BRIEFING_TIME") + "\n" + Translate.Get("MENU_BRIEFING_EXPLORED") + "\n" + Translate.Get("MENU_BRIEFING_ITEMS");
		textLabel.Text = text;
		textLabel.FadeIn();
		textDataLabel.Text = string.Empty;
		textDataLabel.FadeIn();
		textTitle.Text = ((!stats.resultWin) ? Translate.Get("MENU_BRIEFING_FAILURE") : Translate.Get("MENU_BRIEFING_SUCCESS"));
		textTitle.textColor = ((!stats.resultWin) ? colorFailure : colorSuccess);
		textContinue.Text = Translate.GetForInput("MENU_BRIEFING_CONTINUE") + "\n\n" + Translate.GetForInput("MENU_BRIEFING_EXIT");
		Init(States.FadeIn);
	}

	private void FadeIn_Enter()
	{
		textLabel.FadeIn();
		textDataLabel.FadeIn();
		timer = 1f;
		if (stats.events.Count > 0)
		{
			minimap.SetPlayerPos(stats.events[0].position);
		}
	}

	private void FadeIn_Update()
	{
		timer -= Time.deltaTime;
		if (timer <= 0f)
		{
			base.State = States.Counting;
		}
	}

	private void Counting_Enter()
	{
		tickCounter = 0u;
		timer = 0f;
		discoveredProbes = 0;
		collectedItems = 0;
	}

	private void Counting_Update()
	{
		bool flag = false;
		timer += Time.deltaTime;
		if (timer >= 0.1f)
		{
			timer -= 0.1f;
			uint totalTime = stats.totalTime;
			tickCounter += 10u;
			if (tickCounter > totalTime)
			{
				flag = true;
			}
			UpdateStats(tickCounter);
		}
		if (InputExt.GetButtonDown(InputExt.Button.Action) || InputExt.GetButtonDown(InputExt.Button.UIAction) || InputExt.GetButtonDown(InputExt.Button.Cancel) || InputExt.BackButtonDown)
		{
			flag = true;
		}
		if (flag)
		{
			base.State = States.Finished;
		}
	}

	private void Finished_Enter()
	{
		textTitle.FadeIn();
		textContinue.FadeIn();
		UpdateStats(stats.totalTime);
		ShowStatsData(stats.totalTime, stats.discoveredProbes, stats.totalProbes, stats.collectedItems, stats.totalItems);
	}

	private void Finished_Update()
	{
		if (!fading && (InputExt.GetButtonDown(InputExt.Button.Action) || InputExt.GetButtonDown(InputExt.Button.UIAction)))
		{
			fading = true;
			GameController.Get().StartRandomMap();
		}
		else if (!fading && (InputExt.GetButtonDown(InputExt.Button.Cancel) || InputExt.BackButtonDown))
		{
			fading = true;
			fader.FadeOut(4f, fadeAudio: true, null, Exit_OnEndFade);
		}
	}

	private void Exit_OnEndFade()
	{
		GameController.Get().ExitGame();
	}

	private void UpdateStats(uint tick)
	{
		bool flag = false;
		bool flag2 = true;
		while (nextEvent < stats.events.Count && stats.events[nextEvent].timeTick <= tick)
		{
			flag = true;
			PlayerStats.Stats.Event @event = stats.events[nextEvent];
			nextEvent++;
			if (@event.eventType == PlayerStats.Stats.Event.EventType.Collect)
			{
				collectedItems++;
			}
			else if (@event.eventType == PlayerStats.Stats.Event.EventType.Position)
			{
				minimap.SetPlayerPos(@event.position);
			}
		}
		if (flag2)
		{
			flag = true;
			for (int i = 0; i < 64; i++)
			{
				for (int j = 0; j < 64; j++)
				{
					uint num = stats.discoveredTiles[i][j];
					if (num < tick && num >= lastProbesCount)
					{
						discoveredProbes++;
						minimap.MarkProbe(j, i);
					}
				}
			}
			minimap.ApplyProbes();
			lastProbesCount = tickCounter;
		}
		if (flag)
		{
			ShowStatsData(tickCounter, discoveredProbes, stats.totalProbes, collectedItems, stats.totalItems);
		}
	}

	private void ShowStatsData(uint time, int discoveredProbes, int totalProbes, int collectedItems, int totalItems)
	{
		totalProbes = Mathf.Max(discoveredProbes, totalProbes);
		totalItems = Mathf.Max(collectedItems, totalItems);
		float num = (float)discoveredProbes / (float)totalProbes * 100f;
		float num2 = 0f;
		if (totalItems != 0)
		{
			num2 = (float)collectedItems / (float)totalItems * 100f;
		}
		string text = ParseTime(time);
		string text2 = text;
		text = text2 + "\n" + (int)num + "%";
		text2 = text;
		text = text2 + "\n" + (int)num2 + "% (" + collectedItems + "/" + totalItems + ")";
		textDataLabel.Text = text;
	}

	private string ParseTime(uint time)
	{
		uint num = time / 600;
		uint num2 = time - num * 60 * 10;
		uint num3 = num2 / 10;
		num2 -= num3 * 10;
		uint num4 = num2;
		if (num != 0)
		{
			return string.Format(Translate.Get("MENU_BRIEFING_TIME_MINS"), num, num3);
		}
		return string.Format(Translate.Get("MENU_BRIEFING_TIME_SECS"), num3);
	}
}
public class Tags
{
	public static string Untagged = "Untagged";

	public static string Player = "Player";

	public static string GameController = "GameController";

	public static string LookDirection = "LookDirection";

	public static string MainCamera = "MainCamera";

	public static string NavGraph = "NavGraph";

	public static string NavNode = "NavNode";

	public static string Minimap = "Minimap";

	public static string ForwardDirection = "ForwardDirection";

	public static string GhostSpawn = "GhostSpawn";

	public static string PlayerTorch = "PlayerTorch";

	public static string PlayerNotes = "PlayerNotes";

	public static string Inventory = "Inventory";

	public static string Exit = "Exit";

	public static string Ghost = "Ghost";

	public static string MapGeometry = "MapGeometry";

	public static string Door = "Door";

	public static string PlayerTrigger = "PlayerTrigger";

	public static string FloaterSpawn = "FloaterSpawn";

	public static string UI = "UI";

	public static string TutorialUI = "TutorialUI";

	public static string DoorTrigger = "DoorTrigger";

	public static string Creature = "Creature";

	public static string LeftHand = "LeftHand";

	public static string RightHand = "RightHand";

	public static string LeftHandLook = "LeftHandLook";

	public static string RightHandLook = "RightHandLook";

	public static bool IsPlayer(string tag)
	{
		return tag == Player;
	}
}
public class TemplateMap : MonoBehaviour
{
	public delegate Texture GetPropMarkerTextureDelegate(RoomTemplate.PropMarker marker, TemplateMap tmap);

	[Serializable]
	public class PropMarkerPrototype
	{
		public string name;

		public Sprite propSprite;

		public RoomTemplate.PropMarker propMarker;
	}

	public int width = 10;

	public int height = 10;

	[NonSerialized]
	public Point markerPos;

	[NonSerialized]
	public bool showMarker;

	[NonSerialized]
	public Point originPos;

	[NonSerialized]
	public bool showOrigin;

	[NonSerialized]
	public int editLayout = -1;

	[NonSerialized]
	public RoomTemplate.PropMarker overProp;

	[NonSerialized]
	public RoomTemplate.PropMarker selectedProp;

	[NonSerialized]
	public SpriteRenderer[][] cells;

	public Sprite emptySprite;

	public Sprite wallSprite;

	public Sprite groundSprite;

	public Sprite doorSprite;

	public Sprite pitSprite;

	public Sprite pitShaftSprite;

	public Sprite shaftSprite;

	public Sprite propAnySprite;

	public Sprite propOtherSprite;

	public Sprite propLightSprite;

	public Sprite propImportantSprite;

	public Sprite propHorrorSprite;

	public Sprite propTallSprite;

	public Sprite propAreaSprite;

	public GetPropMarkerTextureDelegate getPropMarkerTexture;

	public List<PropMarkerPrototype> propPrototypes;

	[NonSerialized]
	public RoomTemplate roomTemplate;

	private void Awake()
	{
		cells = null;
		foreach (Transform item in base.gameObject.transform)
		{
			UnityEngine.Object.Destroy(item.gameObject);
		}
		Debug.Log("Awoken");
	}

	private void OnDrawGizmosSelected()
	{
		Vector3 position = base.transform.position;
		if (roomTemplate == null || string.IsNullOrEmpty(roomTemplate.name))
		{
			return;
		}
		Gizmos.color = Color.grey;
		Gizmos.color = Color.black;
		Gizmos.DrawLine(position, position + new Vector3(width, 0f, 0f));
		Gizmos.DrawLine(position, position + new Vector3(0f, -height, 0f));
		Gizmos.DrawLine(position + new Vector3(width, 0f, 0f), position + new Vector3(width, -height, 0f));
		Gizmos.DrawLine(position + new Vector3(0f, -height, 0f), position + new Vector3(width, -height, 0f));
		Gizmos.color = new Color(21f / 85f, 21f / 85f, 21f / 85f);
		for (int i = 1; i < width; i++)
		{
			Gizmos.DrawLine(position + new Vector3(i, 0f, 0f), position + new Vector3(i, -height, 0f));
		}
		for (int j = 1; j < height; j++)
		{
			Gizmos.DrawLine(position + new Vector3(0f, -j, 0f), position + new Vector3(width, -j, 0f));
		}
		foreach (CPoint doubleDoor in roomTemplate.doubleDoors)
		{
			bool flag = roomTemplate.At(doubleDoor.X + 1, doubleDoor.Y) == CellType.EntranceMark;
			Vector3 vector = new Vector3((float)doubleDoor.X + 0.5f, (float)(-doubleDoor.Y) - 0.5f, 0f) + ((!flag) ? new Vector3(0f, -0.5f, 0f) : new Vector3(0.5f, 0f, 0f));
			Vector3 size = ((!flag) ? new Vector3(1f, 2f, 1f) : new Vector3(2f, 1f, 1f));
			Gizmos.color = new Color(0.44f, 0.88f, 0.38f);
			if (doubleDoor.X % 2 != 0 || doubleDoor.Y % 2 != 0)
			{
				Gizmos.color = new Color(0.88f, 0.1f, 0.14f, 0.5f);
				Gizmos.DrawCube(position + vector, size);
				Gizmos.color = new Color(0.88f, 0.44f, 0.38f);
			}
			Gizmos.DrawWireCube(position + vector, size);
		}
		int num = editLayout;
		if (num >= 0 && num < roomTemplate.layouts.Count)
		{
			foreach (RoomTemplate.PropMarker prop in roomTemplate.layouts[num].props)
			{
				Vector3 vector2 = new Vector3((float)prop.pos.X + (float)prop.width / 2f, (float)(-prop.pos.Y) - (float)prop.height / 2f, 0f);
				Gizmos.color = GetPropMarkerColor(prop);
				Gizmos.DrawCube(position + vector2, new Vector3(prop.width, prop.height, 1f));
				Texture propMarkerTexture = GetPropMarkerTexture(prop);
				if (propMarkerTexture != null)
				{
					Gizmos.DrawGUITexture(new Rect(prop.pos.X, -prop.pos.Y, prop.width, -prop.height), GetPropMarkerTexture(prop));
				}
				if (prop == selectedProp)
				{
					Gizmos.color = (((int)(Time.realtimeSinceStartup * 4f) % 2 != 0) ? Color.yellow : Color.white);
					Gizmos.DrawWireCube(position + vector2, new Vector3(prop.width, prop.height, 1f));
				}
				if (prop == overProp)
				{
					Gizmos.color = Color.red;
					Gizmos.DrawWireCube(position + vector2, new Vector3(prop.width, prop.height, 1f));
				}
				if ((prop == selectedProp || prop == overProp) && prop.direction != 0)
				{
					bool flag2 = prop.direction == RoomTemplate.PropMarker.Direction.Right;
					bool flag3 = prop.direction == RoomTemplate.PropMarker.Direction.Left;
					bool flag4 = prop.direction == RoomTemplate.PropMarker.Direction.Up;
					bool flag5 = prop.direction == RoomTemplate.PropMarker.Direction.Down;
					Vector3 vector3 = position + vector2;
					if (flag2)
					{
						vector3 += new Vector3((float)prop.width / 2f + 0.1f, 0f, 0f);
					}
					else if (flag3)
					{
						vector3 -= new Vector3((float)prop.width / 2f + 0.1f, 0f, 0f);
					}
					else if (flag4)
					{
						vector3 += new Vector3(0f, (float)prop.height / 2f + 0.1f, 0f);
					}
					else if (flag5)
					{
						vector3 -= new Vector3(0f, (float)prop.height / 2f + 0.1f, 0f);
					}
					Vector3 vector4 = new Vector3(0f, 1f, 0f) * 0.2f;
					Vector3 vector5 = new Vector3(1f, 0f, 0f) * 0.3f;
					Quaternion quaternion = Quaternion.identity;
					if (flag4)
					{
						quaternion = Quaternion.AngleAxis(90f, new Vector3(0f, 0f, 1f));
					}
					else if (flag3)
					{
						quaternion = Quaternion.AngleAxis(180f, new Vector3(0f, 0f, 1f));
					}
					else if (flag5)
					{
						quaternion = Quaternion.AngleAxis(-90f, new Vector3(0f, 0f, 1f));
					}
					vector4 = quaternion * vector4;
					vector5 = quaternion * vector5;
					Gizmos.DrawLine(vector3 + vector4, vector3 - vector4);
					Gizmos.DrawLine(vector3 + vector4, vector3 + vector5);
					Gizmos.DrawLine(vector3 - vector4, vector3 + vector5);
				}
			}
		}
		if (showMarker)
		{
			Gizmos.color = Color.red;
			Vector3 vector6 = new Vector3((float)markerPos.X + 0.5f, (float)(-markerPos.Y) - 0.5f, 0f);
			Gizmos.DrawWireCube(position + vector6, new Vector3(1f, 1f, 1f) * 1f);
		}
		if (showOrigin)
		{
			Gizmos.color = Color.blue;
			Vector3 vector7 = new Vector3((float)originPos.X + 0.5f, (float)(-originPos.Y) - 0.5f, 0f);
			Gizmos.DrawWireCube(position + vector7, new Vector3(1f, 1f, 1f) * 1f);
			Vector3 from = new Vector3(Mathf.Min(originPos.X, markerPos.X), -Mathf.Min(originPos.Y, markerPos.Y));
			Vector3 vector8 = new Vector3(Mathf.Max(originPos.X, markerPos.X), -Mathf.Min(originPos.Y, markerPos.Y));
			Vector3 vector9 = new Vector3(Mathf.Min(originPos.X, markerPos.X), -Mathf.Max(originPos.Y, markerPos.Y));
			Vector3 to = new Vector3(Mathf.Max(originPos.X, markerPos.X), -Mathf.Max(originPos.Y, markerPos.Y));
			from += new Vector3(position.x + 0.5f, position.y - 0.5f, 0f);
			vector8 += new Vector3(position.x + 0.5f, position.y - 0.5f, 0f);
			vector9 += new Vector3(position.x + 0.5f, position.y - 0.5f, 0f);
			to += new Vector3(position.x + 0.5f, position.y - 0.5f, 0f);
			Gizmos.DrawLine(from, vector8);
			Gizmos.DrawLine(vector9, to);
			Gizmos.DrawLine(from, vector9);
			Gizmos.DrawLine(vector8, to);
		}
	}

	public void Reset(int w, int h, bool createRoom = true)
	{
		width = w;
		height = h;
		if (cells != null)
		{
			for (int i = 0; i < cells.Length; i++)
			{
				for (int j = 0; j < cells[i].Length; j++)
				{
					UnityEngine.Object.DestroyImmediate(cells[i][j].gameObject);
				}
			}
		}
		List<GameObject> list = new List<GameObject>();
		foreach (Transform item in base.gameObject.transform)
		{
			list.Add(item.gameObject);
		}
		foreach (GameObject item2 in list)
		{
			UnityEngine.Object.DestroyImmediate(item2);
		}
		cells = new SpriteRenderer[height][];
		for (int k = 0; k < height; k++)
		{
			cells[k] = new SpriteRenderer[width];
			for (int l = 0; l < width; l++)
			{
				GameObject gameObject = new GameObject();
				gameObject.name = string.Empty + l + "," + k;
				gameObject.transform.parent = base.transform;
				gameObject.transform.localPosition = new Vector3(l, -k, 0f);
				gameObject.hideFlags = HideFlags.HideAndDontSave | HideFlags.HideInInspector;
				gameObject.AddComponent<TemplateMapTile>();
				SpriteRenderer spriteRenderer = gameObject.AddComponent<SpriteRenderer>();
				spriteRenderer.sprite = emptySprite;
				cells[k][l] = spriteRenderer;
			}
		}
		if (createRoom)
		{
			roomTemplate = ScriptableObject.CreateInstance<RoomTemplate>();
			roomTemplate.Reset(width, height);
		}
		UpdateDoors();
		Refresh();
		GetComponent<BoxCollider2D>().size = new Vector2(width, height);
		GetComponent<BoxCollider2D>().offset = new Vector2((float)width / 2f, (float)(-height) / 2f);
	}

	public void Load(RoomTemplate newRoom)
	{
		roomTemplate = newRoom;
		Reset(newRoom.width, newRoom.height, createRoom: false);
	}

	public void Refresh()
	{
		if (!roomTemplate)
		{
			GetComponent<BoxCollider2D>().size = new Vector2(10f, 10f);
			GetComponent<BoxCollider2D>().offset = new Vector2(5f, -5f);
			return;
		}
		for (int i = 0; i < height; i++)
		{
			for (int j = 0; j < width; j++)
			{
				Refresh(new Point(j, i));
			}
		}
	}

	public void Refresh(Point pos)
	{
		if ((bool)roomTemplate)
		{
			Sprite sprite = emptySprite;
			switch (roomTemplate.At(pos))
			{
			case CellType.Perimeter:
			case CellType.Blocked:
				sprite = wallSprite;
				break;
			case CellType.EntranceMark:
			case CellType.Door:
				sprite = doorSprite;
				break;
			case CellType.Room:
				sprite = groundSprite;
				break;
			case CellType.Pit:
				sprite = pitSprite;
				break;
			case CellType.Shaft:
				sprite = shaftSprite;
				break;
			case CellType.PitShaft:
				sprite = pitShaftSprite;
				break;
			}
			cells[pos.Y][pos.X].sprite = sprite;
		}
	}

	public void PaintBase(Point pos, Sprite spr)
	{
		if ((bool)roomTemplate)
		{
			CellType type = CellType.Rock;
			if (spr == emptySprite)
			{
				type = CellType.Rock;
			}
			else if (spr == wallSprite)
			{
				type = CellType.Perimeter;
			}
			else if (spr == groundSprite)
			{
				type = CellType.Room;
			}
			else if (spr == doorSprite)
			{
				type = CellType.EntranceMark;
			}
			else if (spr == pitSprite)
			{
				type = CellType.Pit;
			}
			else if (spr == pitShaftSprite)
			{
				type = CellType.PitShaft;
			}
			else if (spr == shaftSprite)
			{
				type = CellType.Shaft;
			}
			roomTemplate.Set(pos, type);
			UpdateDoors();
			Refresh(pos);
		}
	}

	public void Resize(int newWidth, int newHeight)
	{
		if (!roomTemplate)
		{
			return;
		}
		int num = roomTemplate.width;
		int num2 = roomTemplate.height;
		CellType[] baseLayout = roomTemplate.baseLayout;
		roomTemplate.width = newWidth;
		roomTemplate.height = newHeight;
		roomTemplate.baseLayout = new CellType[newHeight * newWidth];
		for (int i = 0; i < newHeight; i++)
		{
			for (int j = 0; j < newWidth; j++)
			{
				if (i < num2 && j < num)
				{
					roomTemplate.Set(j, i, baseLayout[i * num + j]);
				}
				else
				{
					roomTemplate.Set(j, i, CellType.Rock);
				}
			}
		}
		foreach (RoomTemplate.Layout layout in roomTemplate.layouts)
		{
			for (int k = 0; k < layout.props.Count; k++)
			{
				if (layout.props[k].pos.X >= newWidth || layout.props[k].pos.Y >= newHeight)
				{
					layout.props.RemoveAt(k--);
				}
			}
		}
		Reset(newWidth, newHeight, createRoom: false);
	}

	public void Displace(int deltaX, int deltaY)
	{
		if (!roomTemplate)
		{
			return;
		}
		CellType[] baseLayout = roomTemplate.baseLayout;
		roomTemplate.baseLayout = new CellType[roomTemplate.height * roomTemplate.width];
		for (int i = 0; i < roomTemplate.height; i++)
		{
			for (int j = 0; j < roomTemplate.width; j++)
			{
				CellType type = CellType.Rock;
				int num = j - deltaX;
				int num2 = i - deltaY;
				if (num >= 0 && num < roomTemplate.width && num2 >= 0 && num2 < roomTemplate.height)
				{
					type = baseLayout[num2 * roomTemplate.width + num];
				}
				roomTemplate.Set(j, i, type);
			}
		}
		foreach (RoomTemplate.Layout layout in roomTemplate.layouts)
		{
			for (int k = 0; k < layout.props.Count; k++)
			{
				layout.props[k].pos = new CPoint(layout.props[k].pos.X + deltaX, layout.props[k].pos.Y + deltaY);
				if (layout.props[k].pos.X <= 0 || layout.props[k].pos.X + layout.props[k].width - 1 >= roomTemplate.width || layout.props[k].pos.Y <= 0 || layout.props[k].pos.Y + layout.props[k].height - 1 >= roomTemplate.height)
				{
					layout.props.RemoveAt(k--);
				}
			}
		}
		UpdateDoors();
		Refresh();
	}

	public void TrimSpace()
	{
		IntRect boundingBox = GetBoundingBox();
		Debug.Log("Bounding Box: " + boundingBox);
		int num = boundingBox.left - boundingBox.left % 2;
		int num2 = boundingBox.top - boundingBox.top % 2;
		int num3 = boundingBox.width + (boundingBox.left - num);
		int num4 = boundingBox.height + (boundingBox.top - num2);
		if (num3 % 2 != 0)
		{
			num3++;
		}
		if (num4 % 2 != 0)
		{
			num4++;
		}
		Displace(-num, -num2);
		Resize(num3, num4);
		Refresh();
	}

	public IntRect GetBoundingBox()
	{
		int num = width;
		int num2 = 0;
		int num3 = height;
		int num4 = 0;
		for (int i = 0; i < height; i++)
		{
			for (int j = 0; j < width; j++)
			{
				if (roomTemplate.At(j, i) != 0)
				{
					num = Mathf.Min(num, j);
					num2 = Mathf.Max(num2, j);
					num3 = Mathf.Min(num3, i);
					num4 = Mathf.Max(num4, i);
				}
			}
		}
		num2++;
		num4++;
		return new IntRect(num, num3, num2 - num + 1, num4 - num3 + 1);
	}

	public void UpdateDoors()
	{
		roomTemplate.doors = new List<CPoint>();
		roomTemplate.doubleDoors = new List<CPoint>();
		for (int i = 0; i < roomTemplate.height; i++)
		{
			for (int j = 0; j < roomTemplate.width; j++)
			{
				if (roomTemplate.At(j, i) != CellType.EntranceMark)
				{
					continue;
				}
				CPoint item = new CPoint(j - 1, i);
				CPoint item2 = new CPoint(j, i - 1);
				if (!roomTemplate.doubleDoors.Contains(item) && !roomTemplate.doubleDoors.Contains(item2))
				{
					roomTemplate.doors.Add(new CPoint(j, i));
					if ((j + 1 < roomTemplate.width && roomTemplate.At(j + 1, i) == CellType.EntranceMark) || (i + 1 < roomTemplate.height && roomTemplate.At(j, i + 1) == CellType.EntranceMark))
					{
						roomTemplate.doubleDoors.Add(new CPoint(j, i));
					}
				}
			}
		}
	}

	public void AddLayout()
	{
		roomTemplate.layouts.Add(new RoomTemplate.Layout());
	}

	public void CloneLayout()
	{
		RoomTemplate.Layout layout = roomTemplate.layouts[editLayout];
		RoomTemplate.Layout layout2 = new RoomTemplate.Layout();
		foreach (RoomTemplate.PropMarker prop in layout.props)
		{
			layout2.props.Add(new RoomTemplate.PropMarker(prop.pos, prop));
		}
		roomTemplate.layouts.Add(layout2);
	}

	public void RemoveLayout()
	{
		if (editLayout >= 0 && editLayout < roomTemplate.layouts.Count)
		{
			roomTemplate.layouts.RemoveAt(editLayout);
			editLayout--;
		}
	}

	public RoomTemplate.PropMarker AddProp(PropMarkerPrototype prototype)
	{
		return AddProp(prototype.propMarker);
	}

	public RoomTemplate.PropMarker AddProp(RoomTemplate.PropMarker protoMarker)
	{
		RoomTemplate.PropMarker propMarker = new RoomTemplate.PropMarker(new CPoint(markerPos), protoMarker);
		roomTemplate.layouts[editLayout].props.Add(propMarker);
		return propMarker;
	}

	public void RemoveProp(RoomTemplate.PropMarker marker)
	{
		roomTemplate.layouts[editLayout].props.Remove(marker);
	}

	public Color GetPropMarkerColor(RoomTemplate.PropMarker marker)
	{
		if (marker.groupIndex == -1 || marker.propInfo != null)
		{
			return new Color(0f, 0f, 0f, 0.2f);
		}
		Color propGroupColor = GetPropGroupColor(marker.groupIndex);
		propGroupColor.a = 0.4f;
		return propGroupColor;
	}

	public Color GetPropGroupColor(int groupIdx)
	{
		return groupIdx switch
		{
			0 => ColorExt.FromValue(4282240061u), 
			1 => ColorExt.FromValue(4284727039u), 
			2 => ColorExt.FromValue(4294961535u), 
			3 => ColorExt.FromValue(4294934399u), 
			4 => ColorExt.FromValue(4288774143u), 
			5 => ColorExt.FromValue(4290090496u), 
			_ => Color.white, 
		};
	}

	public Texture GetPropMarkerTexture(RoomTemplate.PropMarker marker)
	{
		if (getPropMarkerTexture != null)
		{
			return getPropMarkerTexture(marker, this);
		}
		return propAnySprite.texture;
	}
}
public class TemplateMapTile : MonoBehaviour
{
}
[ExecuteInEditMode]
public class TestLoS : MonoBehaviour
{
	public Transform target;

	private void Awake()
	{
		target = Player.Get().transform;
	}

	private void OnDrawGizmos()
	{
		Vector3 vector = base.transform.position.ToGround();
		Vector3 vector2 = target.position.ToGround();
		Gizmos.color = ((!MapLoS.LineOfWalk(vector, vector2)) ? Color.red : Color.green);
		Gizmos.DrawLine(vector + Vector3.up, vector2 + Vector3.up);
	}
}
public class TestReload : MonoBehaviour
{
	private void Update()
	{
		if (Input.GetButton("Fire1"))
		{
			GC.Collect();
			string loadedLevelName = Application.loadedLevelName;
			Application.LoadLevel(loadedLevelName);
		}
	}
}
public class TestRecenter : MonoBehaviour
{
	private void Update()
	{
	}
}
public class LocalizedTexture : MonoBehaviour
{
	public string[] keywords;

	public string[] textureNames;

	private void Start()
	{
		RefreshTextures();
	}

	public void RefreshTextures()
	{
		Material material = GetComponent<Renderer>().material;
		if (keywords.Length == 0 && textureNames.Length >= 1)
		{
			material.mainTexture = GetLocalizedTexture(textureNames[0]);
		}
		else if (keywords.Length > 0 && keywords.Length <= textureNames.Length)
		{
			for (int i = 0; i < keywords.Length; i++)
			{
				material.SetTexture(keywords[i], GetLocalizedTexture(textureNames[i]));
			}
		}
	}

	private Texture GetLocalizedTexture(string texName)
	{
		string language = Translate.GetLanguage();
		Texture texture = Resources.Load<Texture>("LocalizedTextures/" + language + "/" + texName);
		if (texture == null)
		{
			texture = Resources.Load<Texture>("LocalizedTextures/english/" + texName);
		}
		return texture;
	}
}
public class LostFocusOverlay : MonoBehaviour
{
	private Renderer[] renderers;

	private void Awake()
	{
		renderers = GetComponentsInChildren<Renderer>(includeInactive: true);
		Renderer[] array = renderers;
		foreach (Renderer renderer in array)
		{
			renderer.enabled = false;
		}
	}

	private void OnApplicationFocus(bool focusStatus)
	{
		Debug.Log((!focusStatus) ? "Hiding Lost Focus Overlay" : "Showing Lost Focus Overlay");
		if (!focusStatus)
		{
			Renderer[] array = renderers;
			foreach (Renderer renderer in array)
			{
				renderer.enabled = true;
			}
		}
		else
		{
			Renderer[] array2 = renderers;
			foreach (Renderer renderer2 in array2)
			{
				renderer2.enabled = false;
			}
		}
	}
}
public class NotificationOverlay : TimeIndependentBehaviour
{
	private static NotificationOverlay instance;

	private TextLabel TLabel;

	private float timer;

	private bool showing;

	private void Start()
	{
		instance = this;
		TLabel = GetComponent<TextLabel>();
		timer = 0f;
		showing = false;
	}

	private new void Update()
	{
		base.Update();
		if (showing)
		{
			timer -= base.deltaTime;
			if (timer <= 0f)
			{
				TLabel.HideText();
				showing = false;
			}
		}
	}

	public void ShowText(string text, float time)
	{
		timer = time;
		showing = true;
		TLabel.ShowText(text);
	}

	public static void Show(string text, float time = 3f)
	{
		if (instance != null)
		{
			instance.ShowText(text, time);
		}
	}

	public static void Clear()
	{
		instance = null;
	}
}
public class PauseMenu : UIMenu
{
	protected new void Update()
	{
		base.Update();
		if (GameController.Get().Paused != IsShowing())
		{
			ShowMenu(GameController.Get().Paused);
		}
	}

	protected override void OnShow()
	{
		Quaternion localRotation = Player.ForwardDirection.localRotation;
		base.transform.parent.localRotation = localRotation;
	}

	protected override void OnButton(string btnName, UIButton button)
	{
		if (btnName == "btnResume")
		{
			GameController.Get().ExitPause();
		}
		else if (btnName == "btnExit")
		{
			GameController.Get().ExitGame();
		}
	}

	protected override void OnCancel()
	{
		GameController.Get().ExitPause();
	}
}
[RequireComponent(typeof(TextLabel))]
public class UIButton : UILabel
{
}
[RequireComponent(typeof(TextLabel))]
public class UILabel : MonoBehaviour
{
	public string caption = string.Empty;

	private TextLabel textLabel;

	public string Caption
	{
		get
		{
			return caption;
		}
		set
		{
			caption = value;
			textLabel.Text = caption;
		}
	}

	private void Awake()
	{
		textLabel = GetComponent<TextLabel>();
		caption = Translate.Get(caption);
		textLabel.Text = caption;
		textLabel.InitText = caption;
		GetComponent<Renderer>().material.renderQueue += 10;
	}
}
public class UIMenu : TimeIndependentBehaviour
{
	public UIButton[] buttonList;

	public bool animated = true;

	public AudioClip showSound;

	public AudioClip hideSound;

	public AudioClip switchSound;

	public AudioClip selectSound;

	private Vector3[] btnStartScales;

	private int selected;

	private bool showing;

	private float factor;

	private AxisEvents axisVertical = new AxisEvents("Vertical", "Vertical_btn");

	private void Start()
	{
		btnStartScales = new Vector3[buttonList.Length];
		for (int i = 0; i < buttonList.Length; i++)
		{
			ref Vector3 reference = ref btnStartScales[i];
			reference = buttonList[i].transform.localScale;
		}
	}

	protected new void Update()
	{
		base.Update();
		axisVertical.Update();
		if (!showing && !animated)
		{
			return;
		}
		if (animated)
		{
			float num = factor;
			if (showing)
			{
				factor += base.deltaTime * 1.5f;
			}
			else
			{
				factor -= base.deltaTime * 1.5f;
			}
			factor = Mathf.Clamp01(factor);
			float x = Interpolate.EaseInOutCubic(0f, 1f, factor);
			base.transform.localScale = new Vector3(x, 1f, 1f);
			if (!showing && factor <= 0.01f && num > 0.01f)
			{
				ShowRenderers(show: false);
			}
		}
		if (!showing)
		{
			return;
		}
		bool flag = Input.GetKeyDown(KeyCode.DownArrow) || axisVertical.GetDownButtonDown();
		bool flag2 = Input.GetKeyDown(KeyCode.UpArrow) || axisVertical.GetUpButtonDown();
		bool flag3 = InputExt.GetButtonDown(InputExt.Button.Action) || InputExt.GetButtonDown(InputExt.Button.UIAction) || Input.GetKeyDown(KeyCode.Return);
		bool flag4 = InputExt.GetButtonDown(InputExt.Button.Cancel) || GameController.GetBackButtonDown();
		if (flag && selected < buttonList.Length - 1)
		{
			selected = (selected + 1) % buttonList.Length;
			if ((bool)switchSound)
			{
				Utils.PlayClipAt(switchSound, base.transform.position);
			}
		}
		if (flag2 && selected > 0)
		{
			selected = (selected - 1) % buttonList.Length;
			if ((bool)switchSound)
			{
				Utils.PlayClipAt(switchSound, base.transform.position);
			}
		}
		if (flag3)
		{
			if ((bool)selectSound)
			{
				Utils.PlayClipAt(selectSound, base.transform.position);
			}
			OnButton(buttonList[selected].name, buttonList[selected]);
		}
		if (flag4)
		{
			OnCancel();
		}
		for (int i = 0; i < buttonList.Length; i++)
		{
			Vector3 to = btnStartScales[i];
			if (selected == i)
			{
				to.x *= 1.25f;
				to.z *= 1.25f;
			}
			buttonList[i].transform.localScale = Interpolate.Approach(buttonList[i].transform.localScale, to, base.deltaTime * 7f);
		}
	}

	public void ShowMenu(bool show = true)
	{
		if (showing == show)
		{
			return;
		}
		if (!animated || show)
		{
			ShowRenderers(show);
		}
		showing = show;
		if (show)
		{
			selected = 0;
			if ((bool)showSound)
			{
				Utils.PlayClipAt(showSound, base.transform.position);
			}
			OnShow();
		}
		else
		{
			if ((bool)hideSound)
			{
				Utils.PlayClipAt(hideSound, base.transform.position);
			}
			OnHide();
		}
	}

	public void HideMenu()
	{
		ShowMenu(show: false);
	}

	public bool IsShowing()
	{
		return showing;
	}

	private void ShowRenderers(bool show = true)
	{
		Renderer[] componentsInChildren = base.gameObject.GetComponentsInChildren<Renderer>();
		Renderer[] array = componentsInChildren;
		foreach (Renderer renderer in array)
		{
			renderer.enabled = show;
		}
	}

	protected virtual void OnShow()
	{
	}

	protected virtual void OnHide()
	{
	}

	protected virtual void OnButton(string btnName, UIButton button)
	{
	}

	protected virtual void OnCancel()
	{
	}
}
public class AnimTest : MonoBehaviour
{
	public string animName;

	private void Start()
	{
		GetComponent<Animation>().CrossFade(animName);
	}
}
public class AxisEvents
{
	private string axisName;

	private string axisSubstitute;

	private bool downPressed;

	private bool upPressed;

	private bool downJustPressed;

	private bool upJustPressed;

	private bool downJustReleased;

	private bool upJustReleased;

	public AxisEvents(string axisName, string axisSubstitute = "")
	{
		this.axisName = axisName;
		this.axisSubstitute = axisSubstitute;
		downPressed = false;
		upPressed = false;
		downJustPressed = (downJustReleased = false);
		upJustPressed = (upJustReleased = false);
	}

	public bool GetUpButtonDown()
	{
		return upJustPressed;
	}

	public bool GetUpButtonUp()
	{
		return upJustReleased;
	}

	public bool GetUpButton()
	{
		return upPressed;
	}

	public bool GetDownButtonDown()
	{
		return downJustPressed;
	}

	public bool GetDownButtonUp()
	{
		return downJustReleased;
	}

	public bool GetDownButton()
	{
		return downPressed;
	}

	public void Update()
	{
		downJustPressed = (downJustReleased = false);
		upJustPressed = (upJustReleased = false);
		float axisRaw = Input.GetAxisRaw(axisName);
		if (axisRaw < -0.5f)
		{
			if (!downPressed)
			{
				downPressed = true;
				downJustPressed = true;
			}
			if (upPressed)
			{
				upPressed = false;
				upJustReleased = true;
			}
		}
		else if (axisRaw > 0.5f)
		{
			if (downPressed)
			{
				downPressed = false;
				downJustReleased = true;
			}
			if (!upPressed)
			{
				upPressed = true;
				upJustPressed = true;
			}
		}
		else if (axisRaw >= -0.5f && axisRaw <= 0.5f)
		{
			if (downPressed)
			{
				downPressed = false;
				downJustReleased = true;
			}
			if (upPressed)
			{
				upPressed = false;
				upJustReleased = true;
			}
		}
	}
}
namespace Triangulator
{
	public class Delauney
	{
		public static List<Triangle> Triangulate(List<Triangulator.Geometry.Point> Vertex)
		{
			int count = Vertex.Count;
			if (count < 3)
			{
				throw new ArgumentException("Need at least three vertices for triangulation");
			}
			int num = 4 * count;
			double x = Vertex[0].X;
			double y = Vertex[0].Y;
			double num2 = x;
			double num3 = y;
			for (int i = 1; i < count; i++)
			{
				if (Vertex[i].X < x)
				{
					x = Vertex[i].X;
				}
				if (Vertex[i].X > num2)
				{
					num2 = Vertex[i].X;
				}
				if (Vertex[i].Y < y)
				{
					y = Vertex[i].Y;
				}
				if (Vertex[i].Y > num3)
				{
					num3 = Vertex[i].Y;
				}
			}
			double num4 = num2 - x;
			double num5 = num3 - y;
			double num6 = ((!(num4 > num5)) ? num5 : num4);
			double num7 = (num2 + x) * 0.5;
			double num8 = (num3 + y) * 0.5;
			Vertex.Add(new Triangulator.Geometry.Point(num7 - 2.0 * num6, num8 - num6));
			Vertex.Add(new Triangulator.Geometry.Point(num7, num8 + 2.0 * num6));
			Vertex.Add(new Triangulator.Geometry.Point(num7 + 2.0 * num6, num8 - num6));
			List<Triangle> list = new List<Triangle>();
			list.Add(new Triangle(count, count + 1, count + 2));
			for (int j = 0; j < count; j++)
			{
				List<Edge> list2 = new List<Edge>();
				for (int k = 0; k < list.Count; k++)
				{
					if (InCircle(Vertex[j], Vertex[list[k].p1], Vertex[list[k].p2], Vertex[list[k].p3]))
					{
						list2.Add(new Edge(list[k].p1, list[k].p2));
						list2.Add(new Edge(list[k].p2, list[k].p3));
						list2.Add(new Edge(list[k].p3, list[k].p1));
						list.RemoveAt(k);
						k--;
					}
				}
				if (j >= count)
				{
					continue;
				}
				for (int num9 = list2.Count - 2; num9 >= 0; num9--)
				{
					for (int num10 = list2.Count - 1; num10 >= num9 + 1; num10--)
					{
						if (list2[num9].Equals(list2[num10]))
						{
							list2.RemoveAt(num10);
							list2.RemoveAt(num9);
							num10--;
						}
					}
				}
				for (int l = 0; l < list2.Count; l++)
				{
					if (list.Count >= num)
					{
						return list;
					}
					list.Add(new Triangle(list2[l].p1, list2[l].p2, j));
				}
				list2.Clear();
				list2 = null;
			}
			for (int num11 = list.Count - 1; num11 >= 0; num11--)
			{
				if (list[num11].p1 >= count || list[num11].p2 >= count || list[num11].p3 >= count)
				{
					list.RemoveAt(num11);
				}
			}
			Vertex.RemoveAt(Vertex.Count - 1);
			Vertex.RemoveAt(Vertex.Count - 1);
			Vertex.RemoveAt(Vertex.Count - 1);
			list.TrimExcess();
			return list;
		}

		public static void TriangulateEdges(List<Point> points, List<Pair<int, int>> edges)
		{
			edges.Clear();
			List<Triangulator.Geometry.Point> list = new List<Triangulator.Geometry.Point>(points.Count);
			foreach (Point point in points)
			{
				list.Add(new Triangulator.Geometry.Point(point.X, point.Y));
			}
			List<Triangle> list2 = Triangulate(list);
			foreach (Triangle item4 in list2)
			{
				Pair<int, int> item = new Pair<int, int>(Math.Min(item4.p1, item4.p2), Math.Max(item4.p1, item4.p2));
				Pair<int, int> item2 = new Pair<int, int>(Math.Min(item4.p1, item4.p3), Math.Max(item4.p1, item4.p3));
				Pair<int, int> item3 = new Pair<int, int>(Math.Min(item4.p2, item4.p3), Math.Max(item4.p2, item4.p3));
				if (!edges.Contains(item))
				{
					edges.Add(item);
				}
				if (!edges.Contains(item2))
				{
					edges.Add(item2);
				}
				if (!edges.Contains(item3))
				{
					edges.Add(item3);
				}
			}
		}

		private static bool InCircle(Triangulator.Geometry.Point p, Triangulator.Geometry.Point p1, Triangulator.Geometry.Point p2, Triangulator.Geometry.Point p3)
		{
			if (Math.Abs(p1.Y - p2.Y) < double.Epsilon && Math.Abs(p2.Y - p3.Y) < double.Epsilon)
			{
				return false;
			}
			double num4;
			double num5;
			if (Math.Abs(p2.Y - p1.Y) < double.Epsilon)
			{
				double num = (0.0 - (p3.X - p2.X)) / (p3.Y - p2.Y);
				double num2 = (p2.X + p3.X) * 0.5;
				double num3 = (p2.Y + p3.Y) * 0.5;
				num4 = (p2.X + p1.X) * 0.5;
				num5 = num * (num4 - num2) + num3;
			}
			else if (Math.Abs(p3.Y - p2.Y) < double.Epsilon)
			{
				double num6 = (0.0 - (p2.X - p1.X)) / (p2.Y - p1.Y);
				double num7 = (p1.X + p2.X) * 0.5;
				double num8 = (p1.Y + p2.Y) * 0.5;
				num4 = (p3.X + p2.X) * 0.5;
				num5 = num6 * (num4 - num7) + num8;
			}
			else
			{
				double num6 = (0.0 - (p2.X - p1.X)) / (p2.Y - p1.Y);
				double num = (0.0 - (p3.X - p2.X)) / (p3.Y - p2.Y);
				double num7 = (p1.X + p2.X) * 0.5;
				double num2 = (p2.X + p3.X) * 0.5;
				double num8 = (p1.Y + p2.Y) * 0.5;
				double num3 = (p2.Y + p3.Y) * 0.5;
				num4 = (num6 * num7 - num * num2 + num3 - num8) / (num6 - num);
				num5 = num6 * (num4 - num7) + num8;
			}
			double num9 = p2.X - num4;
			double num10 = p2.Y - num5;
			double num11 = num9 * num9 + num10 * num10;
			num9 = p.X - num4;
			num10 = p.Y - num5;
			double num12 = num9 * num9 + num10 * num10;
			return num12 <= num11;
		}
	}
}
namespace Triangulator.Geometry
{
	public class Edge : IEquatable<Edge>
	{
		public int p1;

		public int p2;

		public Edge(int point1, int point2)
		{
			p1 = point1;
			p2 = point2;
		}

		public Edge()
			: this(0, 0)
		{
		}

		public bool Equals(Edge other)
		{
			return (p1 == other.p2 && p2 == other.p1) || (p1 == other.p1 && p2 == other.p2);
		}
	}
	public class Point
	{
		protected double _X;

		protected double _Y;

		public double X
		{
			get
			{
				return _X;
			}
			set
			{
				_X = value;
			}
		}

		public double Y
		{
			get
			{
				return _Y;
			}
			set
			{
				_Y = value;
			}
		}

		public Point(double x, double y)
		{
			_X = x;
			_Y = y;
		}

		public bool Equals2D(Point other)
		{
			return X == other.X && Y == other.Y;
		}
	}
	public class Point<T> : Point
	{
		private T _attr;

		public T Attribute
		{
			get
			{
				return _attr;
			}
			set
			{
				_attr = value;
			}
		}

		public Point(double x, double y, T attribute)
			: base(x, y)
		{
			_attr = attribute;
		}

		public Point(double x, double y)
			: this(x, y, default(T))
		{
		}
	}
	public struct Triangle
	{
		public int p1;

		public int p2;

		public int p3;

		public Triangle(int point1, int point2, int point3)
		{
			p1 = point1;
			p2 = point2;
			p3 = point3;
		}
	}
}
public class FPSCounter : MonoBehaviour
{
	public TextMesh textMesh;

	public bool showFPS;

	public KeyCode toggleFPSKey = KeyCode.F;

	public string toggleFPSButton = string.Empty;

	private float counter;

	private int frames;

	private float fps;

	private float lastTime;

	private float accum;

	private void Start()
	{
		UnityEngine.Object.Destroy(base.gameObject);
		lastTime = Time.realtimeSinceStartup;
	}

	public void LateUpdate()
	{
		if ((toggleFPSKey != 0 && Input.GetKeyDown(toggleFPSKey)) || (toggleFPSButton.Length > 0 && Input.GetButtonDown(toggleFPSButton)))
		{
			showFPS = !showFPS;
		}
		GetComponent<Renderer>().enabled = showFPS;
		float num = Time.realtimeSinceStartup - lastTime;
		counter += num;
		frames++;
		accum += 1f / num;
		if (counter >= 1f)
		{
			fps = accum / (float)frames;
			counter = 0f;
			frames = 0;
			accum = 0f;
			textMesh.text = fps.ToString("0.0") + " FPS";
		}
		lastTime = Time.realtimeSinceStartup;
	}
}
[RequireComponent(typeof(Camera))]
public class FrustumRenderer : MonoBehaviour
{
	private Camera camera;

	private void Start()
	{
		camera = GetComponent<Camera>();
	}

	private void Update()
	{
		Plane[] camPlanes = GeometryUtility.CalculateFrustumPlanes(camera);
		DrawFrustum(camPlanes);
	}

	public static void DrawFrustumOVR(bool leftEye)
	{
		Pvr_UnitySDKManager componentInChildren = Player.GetComponentInChildren<Pvr_UnitySDKManager>();
		float num = 0.1f;
		float num2 = 60f;
		Transform transform = ((!leftEye) ? componentInChildren.transform.Find("Head/RightEye") : componentInChildren.transform.Find("Head/LeftEye"));
		Vector3 zero = Vector3.zero;
	}

	public static void DrawFrustum(Plane[] camPlanes)
	{
		Vector3[] array = new Vector3[4];
		Vector3[] array2 = new Vector3[4];
		Plane plane = camPlanes[1];
		ref Plane reference = ref camPlanes[1];
		reference = camPlanes[2];
		camPlanes[2] = plane;
		for (int i = 0; i < 4; i++)
		{
			ref Vector3 reference2 = ref array[i];
			reference2 = Plane3Intersect(camPlanes[4], camPlanes[i], camPlanes[(i + 1) % 4]);
			ref Vector3 reference3 = ref array2[i];
			reference3 = Plane3Intersect(camPlanes[5], camPlanes[i], camPlanes[(i + 1) % 4]);
		}
		for (int j = 0; j < 4; j++)
		{
			Debug.DrawLine(array[j], array[(j + 1) % 4], Color.red, Time.deltaTime, depthTest: true);
			Debug.DrawLine(array2[j], array2[(j + 1) % 4], Color.blue, Time.deltaTime, depthTest: true);
			Debug.DrawLine(array[j], array2[j], Color.green, Time.deltaTime, depthTest: true);
		}
	}

	private static Vector3 Plane3Intersect(Plane p1, Plane p2, Plane p3)
	{
		return ((0f - p1.distance) * Vector3.Cross(p2.normal, p3.normal) + (0f - p2.distance) * Vector3.Cross(p3.normal, p1.normal) + (0f - p3.distance) * Vector3.Cross(p1.normal, p2.normal)) / Vector3.Dot(p1.normal, Vector3.Cross(p2.normal, p3.normal));
	}
}
public class LookAtTarget : MonoBehaviour
{
	public Transform target;

	public bool inverted;

	public float maxAngle;

	private void Start()
	{
		if (target == null)
		{
			target = GameObject.FindWithTag(Tags.ForwardDirection).transform;
		}
	}

	private void Update()
	{
		if (!(target != null))
		{
			return;
		}
		Vector3 vector = Vector3Ext.GroundVector(target.position, base.transform.position);
		if (inverted)
		{
			vector = -vector;
		}
		vector.Normalize();
		if (maxAngle <= 0f)
		{
			Quaternion rotation = Quaternion.LookRotation(vector, Vector3.up);
			base.transform.rotation = rotation;
			return;
		}
		Vector3 normalized = base.transform.forward.ToGround().normalized;
		float num = Vector3.SignedAngle(normalized, vector, Vector3.up);
		if (Mathf.Abs(num) > maxAngle)
		{
			num = ((!(num > 0f)) ? (num + maxAngle) : (num - maxAngle));
			base.transform.Rotate(Vector3.up, num);
		}
	}
}
public class ObjExporter
{
	public static string MeshToString(MeshFilter mf)
	{
		Mesh mesh = mf.mesh;
		Material[] sharedMaterials = mf.GetComponent<Renderer>().sharedMaterials;
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.Append("g ").Append(mf.name).Append("\n");
		Vector3[] vertices = mesh.vertices;
		for (int i = 0; i < vertices.Length; i++)
		{
			Vector3 vector = vertices[i];
			stringBuilder.Append($"v {vector.x} {vector.y} {vector.z}\n");
		}
		stringBuilder.Append("\n");
		Vector3[] normals = mesh.normals;
		for (int j = 0; j < normals.Length; j++)
		{
			Vector3 vector2 = normals[j];
			stringBuilder.Append($"vn {vector2.x} {vector2.y} {vector2.z}\n");
		}
		stringBuilder.Append("\n");
		Vector2[] uv = mesh.uv;
		for (int k = 0; k < uv.Length; k++)
		{
			Vector3 vector3 = uv[k];
			stringBuilder.Append($"vt {vector3.x} {vector3.y}\n");
		}
		for (int l = 0; l < mesh.subMeshCount; l++)
		{
			stringBuilder.Append("\n");
			stringBuilder.Append("usemtl ").Append(sharedMaterials[l].name).Append("\n");
			stringBuilder.Append("usemap ").Append(sharedMaterials[l].name).Append("\n");
			int[] triangles = mesh.GetTriangles(l);
			for (int m = 0; m < triangles.Length; m += 3)
			{
				stringBuilder.Append(string.Format("f {0}/{0}/{0} {1}/{1}/{1} {2}/{2}/{2}\n", triangles[m] + 1, triangles[m + 1] + 1, triangles[m + 2] + 1));
			}
		}
		return stringBuilder.ToString();
	}

	public static void MeshToFile(MeshFilter mf, string filename)
	{
		using StreamWriter streamWriter = new StreamWriter(filename);
		streamWriter.Write(MeshToString(mf));
	}
}
public class ParticleDie : MonoBehaviour
{
	private ParticleSystem particles;

	private void Start()
	{
		particles = GetComponent<ParticleSystem>();
	}

	private void Update()
	{
		if (!particles.IsAlive(withChildren: true))
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}
}
public static class RandomExt
{
	public static int RandInt(int min, int max)
	{
		return UnityEngine.Random.Range(min, max + 1);
	}

	public static int RandInt(int max)
	{
		return RandInt(0, max);
	}

	public static T Choice<T>(List<T> arrItems)
	{
		return arrItems[UnityEngine.Random.Range(0, arrItems.Count)];
	}

	public static T Choice<T>(T[] arrItems)
	{
		return arrItems[UnityEngine.Random.Range(0, arrItems.Length)];
	}

	public static T WeightedChoice<T>(List<Pair<T, int>> arrItems)
	{
		if (arrItems.Count == 0)
		{
			return default(T);
		}
		if (arrItems.Count == 1)
		{
			return arrItems[0].First;
		}
		int num = 0;
		foreach (Pair<T, int> arrItem in arrItems)
		{
			num += arrItem.Second;
		}
		int num2 = UnityEngine.Random.Range(0, num);
		foreach (Pair<T, int> arrItem2 in arrItems)
		{
			if (arrItem2.Second > num2)
			{
				return arrItem2.First;
			}
			num2 -= arrItem2.Second;
		}
		return arrItems[arrItems.Count - 1].First;
	}

	public static T WeightedChoice<T>(List<Pair<T, float>> arrItems)
	{
		if (arrItems.Count == 0)
		{
			return default(T);
		}
		float num = 0f;
		foreach (Pair<T, float> arrItem in arrItems)
		{
			num += arrItem.Second;
		}
		float num2 = UnityEngine.Random.Range(0f, num);
		foreach (Pair<T, float> arrItem2 in arrItems)
		{
			if (arrItem2.Second > num2)
			{
				return arrItem2.First;
			}
			num2 -= arrItem2.Second;
		}
		return arrItems[arrItems.Count - 1].First;
	}

	public static float Gaussian(float avg = 0f, float stdDev = 1f)
	{
		float num;
		float num3;
		do
		{
			num = 2f * UnityEngine.Random.value - 1f;
			float num2 = 2f * UnityEngine.Random.value - 1f;
			num3 = num * num + num2 * num2;
		}
		while (num3 >= 1f);
		float num4 = Mathf.Sqrt(-2f * Mathf.Log(num3) / num3);
		num4 = num * num4;
		return num4 * stdDev + avg;
	}

	public static float GaussianRange(float min, float max)
	{
		float num = (min + max) / 2f;
		float num2 = (max - num) / 3f;
		float num3;
		do
		{
			num3 = Gaussian(num, num2);
		}
		while (Mathf.Abs(num3 - num) > 3f * num2);
		return num3;
	}
}
public class TileArea
{
	public List<IntRect> rectangles = new List<IntRect>();

	public List<Point> exceptions = new List<Point>();

	public TileArea()
	{
	}

	public TileArea(IntRect rect)
	{
		Add(rect);
	}

	public void Add(IntRect rect)
	{
		if (rect.width == 1 && rect.height == 1 && exceptions.Count > 0)
		{
			Point item = new Point(rect.x, rect.y);
			if (exceptions.Contains(item))
			{
				exceptions.Remove(item);
			}
		}
		for (int i = 0; i < rectangles.Count; i++)
		{
			if (TryJoin(rectangles[i], rect, out var result))
			{
				rectangles.RemoveAt(i);
				Add(result);
				return;
			}
		}
		rectangles.Add(rect);
	}

	public void Add(Point point)
	{
		if (exceptions.Contains(point))
		{
			exceptions.Remove(point);
		}
		Add(new IntRect(point.X, point.Y, 1, 1));
	}

	public void AddException(Point point)
	{
		exceptions.Add(point);
	}

	public bool IsInside(int x, int y)
	{
		return IsInside(new Point(x, y));
	}

	public bool IsInside(Point point)
	{
		foreach (IntRect rectangle in rectangles)
		{
			if (rectangle.Contains(point) && !exceptions.Contains(point))
			{
				return true;
			}
		}
		return false;
	}

	public Point RandomPoint()
	{
		int index = UnityEngine.Random.Range(0, rectangles.Count);
		return new Point(UnityEngine.Random.Range(rectangles[index].x, rectangles[index].xMax), UnityEngine.Random.Range(rectangles[index].y, rectangles[index].yMax));
	}

	private bool TryJoin(IntRect r1, IntRect r2, out IntRect result)
	{
		result = r1;
		int num = Mathf.Min(r1.left, r2.left);
		int num2 = Mathf.Max(r1.left, r2.left);
		int num3 = Mathf.Min(r1.right, r2.right);
		int num4 = Mathf.Max(r1.right, r2.right);
		int num5 = Mathf.Min(r1.top, r2.top);
		int num6 = Mathf.Max(r1.top, r2.top);
		int num7 = Mathf.Min(r1.bottom, r2.bottom);
		int num8 = Mathf.Max(r1.bottom, r2.bottom);
		if ((num3 == num2 && num5 == num6 && num7 == num8) || (num7 == num6 && num == num2 && num3 == num4))
		{
			result = new IntRect(num, num5, num4 - num, num8 - num5);
			return true;
		}
		return false;
	}
}
public class Utils
{
	public static Vector2 Slerp(Vector2 from, Vector2 to, float f)
	{
		if (from == to)
		{
			return from;
		}
		float value = Vector2.Dot(from, to);
		value = Mathf.Clamp(value, -0.999f, 1f);
		double num = Math.Acos(value);
		if (num == 0.0)
		{
			return from;
		}
		double num2 = Math.Sin(num);
		return (float)(Math.Sin((double)(1f - f) * num) / num2) * from + (float)(Math.Sin((double)f * num) / num2) * to;
	}

	public static bool IntersectCircleRectangle(Vector2 circleCenter, float circleRadius, Rect rect)
	{
		Vector2 zero = Vector2.zero;
		zero.x = Mathf.Clamp(circleCenter.x, rect.x, rect.xMax);
		zero.y = Mathf.Clamp(circleCenter.y, rect.y, rect.yMax);
		float num = (circleCenter - zero).SqrMagnitude();
		return num < circleRadius * circleRadius;
	}

	public static Vector2 ProjectPointOnSegment(Vector2 vPoint, Vector2 vStart, Vector2 vEnd)
	{
		float f;
		return ProjectPointOnSegment(vPoint, vStart, vEnd, out f);
	}

	public static Vector2 ProjectPointOnSegment(Vector2 vPoint, Vector2 vStart, Vector2 vEnd, out float f)
	{
		Vector2 vector = vEnd - vStart;
		float num = vector.SqrMagnitude();
		f = Vector2.Dot(vector, vPoint - vStart) / num;
		if (f <= 0f)
		{
			return vStart;
		}
		if (f >= 1f)
		{
			return vEnd;
		}
		return vStart + f * vector;
	}

	public static int ClosestSegmentInPath(List<Vector2> path, Vector2 vPoint)
	{
		Vector2 vProjection;
		float f;
		return ClosestSegmentInPath(path, vPoint, out vProjection, out f);
	}

	public static int ClosestSegmentInPath(List<Vector2> path, Vector2 vPoint, out Vector2 vProjection)
	{
		float f;
		return ClosestSegmentInPath(path, vPoint, out vProjection, out f);
	}

	public static int ClosestSegmentInPath(List<Vector2> path, Vector2 vPoint, out float f)
	{
		Vector2 vProjection;
		return ClosestSegmentInPath(path, vPoint, out vProjection, out f);
	}

	public static int ClosestSegmentInPath(List<Vector2> path, Vector2 vPoint, out Vector2 vProjection, out float f)
	{
		vProjection = vPoint;
		f = 0f;
		if (path.Count < 2)
		{
			return 0;
		}
		float num = float.MaxValue;
		int result = 0;
		for (int i = 0; i < path.Count - 1; i++)
		{
			Vector2 vStart = path[i];
			Vector2 vEnd = path[i + 1];
			float f2;
			Vector2 vector = ProjectPointOnSegment(vPoint, vStart, vEnd, out f2);
			float num2 = (vPoint - vector).SqrMagnitude();
			if (num2 <= num)
			{
				result = i;
				num = num2;
				f = f2;
				vProjection = vector;
			}
		}
		return result;
	}

	public static float DistanceToSegmentSq(Vector2 vPoint, Vector2 vStart, Vector2 vEnd)
	{
		float f;
		Vector2 vector = ProjectPointOnSegment(vPoint, vStart, vEnd, out f);
		return (vPoint - vector).SqrMagnitude();
	}

	public static float GetSlope(float fX1, float fY1, float fX2, float fY2)
	{
		return (fX1 - fX2) / (fY1 - fY2);
	}

	public static float GetSlopeInv(float fX1, float fY1, float fX2, float fY2)
	{
		return (fY1 - fY2) / (fX1 - fX2);
	}

	public static float GetSlope(float fX1, float fY1, float fX2, float fY2, bool bInvert)
	{
		if (bInvert)
		{
			return GetSlopeInv(fX1, fY1, fX2, fY2);
		}
		return GetSlope(fX1, fY1, fX2, fY2);
	}

	public static bool SegmentIntersect(ref Vector2 vStart, ref Vector2 vEnd, ref Vector2 vStart2, ref Vector2 vEnd2, out Vector2 vIntersection)
	{
		vIntersection = Vector2.zero;
		Vector2 vector = vEnd - vStart;
		Vector2 vector2 = vEnd2 - vStart2;
		float num = vector.x * vector2.y - vector.y * vector2.x;
		if (num == 0f)
		{
			return false;
		}
		Vector2 vector3 = vStart2 - vStart;
		float num2 = vector3.x * vector2.y - vector3.y * vector2.x;
		num2 /= num;
		if (num2 < 0f || num2 > 1f)
		{
			return false;
		}
		float num3 = vector3.x * vector.y - vector3.y * vector.x;
		num3 /= num;
		if (num3 < 0f || num3 > 1f)
		{
			return false;
		}
		vector.x *= num2;
		vector.y *= num2;
		vIntersection = vStart + vector;
		return true;
	}

	public static bool SegmentIntersect(ref Vector2 vStart, ref Vector2 vEnd, ref Vector2 vStart2, ref Vector2 vEnd2, ref Vector2 vS, out Vector2 vIntersection)
	{
		vIntersection = Vector2.zero;
		Vector2 vector = vEnd - vStart;
		float num = vector.x * vS.y - vector.y * vS.x;
		if (num == 0f)
		{
			return false;
		}
		Vector2 vector2 = vStart2 - vStart;
		float num2 = vector2.x * vS.y - vector2.y * vS.x;
		num2 /= num;
		if (num2 < 0f || num2 > 1f)
		{
			return false;
		}
		float num3 = vector2.x * vector.y - vector2.y * vector.x;
		num3 /= num;
		if (num3 < 0f || num3 > 1f)
		{
			return false;
		}
		vector.x *= num2;
		vector.y *= num2;
		vIntersection = vStart + vector;
		return true;
	}

	public static bool CheckBoundsInFrustrum(Bounds bounds)
	{
		Camera[] componentsInChildren = Player.Get().GetComponentsInChildren<Camera>();
		Camera[] array = componentsInChildren;
		foreach (Camera camera in array)
		{
			Plane[] planes = GeometryUtility.CalculateFrustumPlanes(camera);
			if (GeometryUtility.TestPlanesAABB(planes, bounds))
			{
				return true;
			}
		}
		return false;
	}

	public static List<Camera> GetPlayerCameras()
	{
		GameObject[] array = GameObject.FindGameObjectsWithTag(Tags.MainCamera);
		List<Camera> list = new List<Camera>();
		for (int i = 0; i < array.Length; i++)
		{
			list.AddRange(array[i].GetComponents<Camera>());
		}
		return list;
	}

	public static AudioSource PlayClipAt(AudioClip clip, Vector3 pos, float minDistance = 1f, float maxDistance = 500f, float spread = 0f, AudioRolloffMode rolloffMode = AudioRolloffMode.Logarithmic)
	{
		GameObject gameObject = new GameObject("TempAudio");
		gameObject.transform.position = pos;
		AudioSource audioSource = gameObject.AddComponent<AudioSource>();
		audioSource.clip = clip;
		audioSource.spatialBlend = 1f;
		audioSource.rolloffMode = rolloffMode;
		audioSource.minDistance = minDistance;
		audioSource.maxDistance = maxDistance;
		audioSource.spread = spread;
		audioSource.Play();
		UnityEngine.Object.Destroy(gameObject, clip.length);
		return audioSource;
	}

	public static bool IsInLayerMask(GameObject obj, LayerMask layerMask)
	{
		int num = 1 << obj.layer;
		if ((layerMask.value & num) > 0)
		{
			return true;
		}
		return false;
	}

	public static int NumberOfSetBits(int i)
	{
		i -= (i >> 1) & 0x55555555;
		i = (i & 0x33333333) + ((i >> 2) & 0x33333333);
		return ((i + (i >> 4)) & 0xF0F0F0F) * 16843009 >> 24;
	}

	public static void GetTypesInNamespace(List<Type> list, string nameSpace)
	{
		list.Clear();
		Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
		Assembly[] array = assemblies;
		foreach (Assembly assembly in array)
		{
			list.AddRange((from t in assembly.GetTypes()
				where string.Equals(t.Namespace, nameSpace, StringComparison.Ordinal)
				select t).ToArray());
		}
	}

	public static Vector3 BezierInterpolate(Vector3 vP1, Vector3 vP2, Vector3 vP3, Vector3 vP4, float param)
	{
		float num = 1f - param;
		float num2 = param * param;
		float num3 = num * num;
		float num4 = num2 * param;
		float num5 = 3f * num2 * num;
		float num6 = 3f * param * num3;
		float num7 = num3 * num;
		return num7 * vP1 + num6 * vP2 + num5 * vP3 + num4 * vP4;
	}

	public static bool IsAncestor(Transform obj, Transform parent)
	{
		Transform parent2 = obj.parent;
		while (parent2 != null)
		{
			if (parent2 == parent)
			{
				return true;
			}
			parent2 = parent2.parent;
		}
		return false;
	}

	public static string WordWrap(string sourceStr, TextMesh textMesh, float wrapLimit)
	{
		if (Translate.GetLanguage() == "chinese")
		{
			return WordWrapPattern(sourceStr, textMesh, wrapLimit, "(?<=[ ])");
		}
		if (Translate.GetLanguage() == "japanese")
		{
			return WordWrapPattern(sourceStr, textMesh, wrapLimit, "(?<=[ ,])", canSplitParts: true);
		}
		Quaternion rotation = textMesh.transform.rotation;
		textMesh.transform.rotation = Quaternion.identity;
		string text = string.Empty;
		textMesh.text = string.Empty;
		string[] array = sourceStr.Split(' ');
		for (int i = 0; i < array.Length; i++)
		{
			textMesh.text = textMesh.text + array[i] + " ";
			if (textMesh.GetComponent<Renderer>().bounds.extents.x > wrapLimit)
			{
				textMesh.text = text.TrimEnd() + Environment.NewLine + array[i] + " ";
			}
			text = textMesh.text;
		}
		textMesh.transform.rotation = rotation;
		return text;
	}

	public static string WordWrapPattern(string sourceStr, TextMesh textMesh, float wrapLimit, string pattern, bool canSplitParts = false)
	{
		Quaternion rotation = textMesh.transform.rotation;
		textMesh.transform.rotation = Quaternion.identity;
		string text = string.Empty;
		textMesh.text = string.Empty;
		string[] array = Regex.Split(sourceStr, pattern);
		for (int i = 0; i < array.Length; i++)
		{
			float x = textMesh.GetComponent<Renderer>().bounds.extents.x;
			textMesh.text += array[i];
			float x2 = textMesh.GetComponent<Renderer>().bounds.extents.x;
			if (x2 > wrapLimit)
			{
				if (canSplitParts && x2 - x > wrapLimit)
				{
					float num = (x2 - x) / (float)array[i].Length;
					int num2 = Mathf.FloorToInt(wrapLimit / num);
					string text2 = array[i].Substring(0, num2);
					string text3 = array[i].Substring(num2, array[i].Length - num2);
					textMesh.text = text.TrimEnd() + Environment.NewLine + text2 + Environment.NewLine + text3;
				}
				else
				{
					textMesh.text = text.TrimEnd() + Environment.NewLine + array[i];
				}
			}
			text = textMesh.text;
		}
		textMesh.transform.rotation = rotation;
		return text;
	}

	public static bool IsPlayerVisible(Transform enemyTransform, float maxAngle = 85f, bool checkOnlyAngle = false, float maxDistance = 16f, float yDelta = 0f)
	{
		float angleToPoint = GetAngleToPoint(enemyTransform, Player.GetPos());
		if (Mathf.Abs(angleToPoint) <= maxAngle)
		{
			if (checkOnlyAngle)
			{
				return true;
			}
			Vector3 position = Player.GetLook().position;
			Vector3 direction = position - (enemyTransform.position + Vector3.up * yDelta);
			if (direction.sqrMagnitude > maxDistance * maxDistance)
			{
				return false;
			}
			float magnitude = direction.magnitude;
			direction /= magnitude;
			if (Physics.Raycast(enemyTransform.position + Vector3.up * yDelta, direction, out var hitInfo, magnitude))
			{
				return hitInfo.collider.gameObject == Player.Get();
			}
			return true;
		}
		return false;
	}

	public static float GetAngleToPoint(Transform refTransform, Vector3 targetPoint)
	{
		Vector3 vec = targetPoint - refTransform.position;
		vec = vec.GroundNormalize();
		return Vector3.Angle(refTransform.forward, vec);
	}

	public static bool IsAnyButtonDown()
	{
		if (Input.GetKey(KeyCode.Joystick1Button0) || Input.GetKey(KeyCode.Joystick1Button1) || Input.GetKey(KeyCode.Joystick1Button2) || Input.GetKey(KeyCode.Joystick1Button3) || Input.GetKey(KeyCode.Joystick1Button4) || Input.GetKey(KeyCode.Joystick1Button5) || Input.GetKey(KeyCode.Joystick1Button6) || Input.GetKey(KeyCode.Joystick1Button7) || Input.GetKey(KeyCode.Joystick1Button8) || Input.GetKey(KeyCode.Joystick1Button9))
		{
			return true;
		}
		return false;
	}
}
public class WarmUp : MonoBehaviour
{
	public GameObject[] toInstantiate;

	private int frameCounter;

	private void Awake()
	{
		GetComponent<MeshRenderer>().enabled = true;
		for (int i = 0; i < toInstantiate.Length; i++)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(toInstantiate[i]);
			gameObject.transform.parent = base.transform;
			gameObject.transform.localPosition = Vector3.zero;
		}
	}

	private void Start()
	{
		GameObject gameObject = GameObject.FindWithTag(Tags.MainCamera);
		if (gameObject != null)
		{
			base.transform.position = gameObject.transform.position + gameObject.transform.forward * 7f;
		}
	}

	private void Update()
	{
		frameCounter++;
		if (frameCounter > 3)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}
}
