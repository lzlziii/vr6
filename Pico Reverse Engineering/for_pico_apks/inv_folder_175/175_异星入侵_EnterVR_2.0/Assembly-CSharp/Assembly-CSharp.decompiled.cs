using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using System.Timers;
using System.Xml;
using CurvedUI;
using DG.Tweening;
using DG.Tweening.Core;
using DG.Tweening.Plugins.Core.PathCore;
using DG.Tweening.Plugins.Options;
using DigitalOpus.MB.Core;
using ExitGames.Client.Photon;
using Newtonsoft.Json;
using OOLitJson;
using Photon.Chat;
using Photon.Pun;
using Photon.Pun.Demo.Cockpit;
using Photon.Pun.Demo.Shared;
using Photon.Pun.Demo.SlotRacer.Utils;
using Photon.Pun.UtilityScripts;
using Photon.Realtime;
using Simplex;
using UnityEngine;
using UnityEngine.AI;
using UnityEngine.Audio;
using UnityEngine.EventSystems;
using UnityEngine.Events;
using UnityEngine.PostProcessing;
using UnityEngine.Rendering;
using UnityEngine.SceneManagement;
using UnityEngine.UI;
using UnityEngine.XR;
using UnityEngine.XR.Interaction.Toolkit;
using UnityStandardAssets.CrossPlatformInput;

[assembly: CompilationRelaxations(8)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: AssemblyVersion("0.0.0.0")]
public class ScrollingUVs : MonoBehaviour
{
	public int materialIndex;

	public Vector2 uvAnimationRate = new Vector2(1f, 0f);

	public string textureName = "_MainTex";

	public bool ScrollBump = true;

	public string bumpName = "_BumpMap";

	private Vector2 uvOffset = Vector2.zero;

	private void LateUpdate()
	{
		uvOffset += uvAnimationRate * Time.deltaTime;
		if (GetComponent<Renderer>().enabled)
		{
			GetComponent<Renderer>().materials[materialIndex].SetTextureOffset(textureName, uvOffset);
			if (ScrollBump)
			{
				GetComponent<Renderer>().materials[materialIndex].SetTextureOffset(bumpName, uvOffset);
			}
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Image Effects/Blur/Blur")]
public class BlurEffect : MonoBehaviour
{
	public int iterations = 3;

	public float blurSpread = 0.6f;

	public Shader blurShader;

	private static Material m_Material;

	protected Material material
	{
		get
		{
			if (m_Material == null)
			{
				m_Material = new Material(blurShader);
				m_Material.hideFlags = HideFlags.DontSave;
			}
			return m_Material;
		}
	}

	protected void OnDisable()
	{
		if ((bool)m_Material)
		{
			UnityEngine.Object.DestroyImmediate(m_Material);
		}
	}

	protected void Start()
	{
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
		else if (!blurShader || !material.shader.isSupported)
		{
			base.enabled = false;
		}
	}

	public void FourTapCone(RenderTexture source, RenderTexture dest, int iteration)
	{
		float num = 0.5f + (float)iteration * blurSpread;
		Graphics.BlitMultiTap(source, dest, material, new Vector2(0f - num, 0f - num), new Vector2(0f - num, num), new Vector2(num, num), new Vector2(num, 0f - num));
	}

	private void DownSample4x(RenderTexture source, RenderTexture dest)
	{
		float num = 1f;
		Graphics.BlitMultiTap(source, dest, material, new Vector2(0f - num, 0f - num), new Vector2(0f - num, num), new Vector2(num, num), new Vector2(num, 0f - num));
	}

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		int width = source.width / 4;
		int height = source.height / 4;
		RenderTexture renderTexture = RenderTexture.GetTemporary(width, height, 0);
		DownSample4x(source, renderTexture);
		for (int i = 0; i < iterations; i++)
		{
			RenderTexture temporary = RenderTexture.GetTemporary(width, height, 0);
			FourTapCone(renderTexture, temporary, i);
			RenderTexture.ReleaseTemporary(renderTexture);
			renderTexture = temporary;
		}
		Graphics.Blit(renderTexture, destination);
		RenderTexture.ReleaseTemporary(renderTexture);
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Image Effects/Color Adjustments/Color Correction (Ramp)")]
public class ColorCorrectionEffect : ImageEffectBase
{
	public Texture textureRamp;

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		base.material.SetTexture("_RampTex", textureRamp);
		Graphics.Blit(source, destination, base.material);
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Image Effects/Color Adjustments/Contrast Stretch")]
public class ContrastStretchEffect : MonoBehaviour
{
	public float adaptationSpeed = 0.02f;

	public float limitMinimum = 0.2f;

	public float limitMaximum = 0.6f;

	private RenderTexture[] adaptRenderTex = new RenderTexture[2];

	private int curAdaptIndex;

	public Shader shaderLum;

	private Material m_materialLum;

	public Shader shaderReduce;

	private Material m_materialReduce;

	public Shader shaderAdapt;

	private Material m_materialAdapt;

	public Shader shaderApply;

	private Material m_materialApply;

	protected Material materialLum
	{
		get
		{
			if (m_materialLum == null)
			{
				m_materialLum = new Material(shaderLum);
				m_materialLum.hideFlags = HideFlags.HideAndDontSave;
			}
			return m_materialLum;
		}
	}

	protected Material materialReduce
	{
		get
		{
			if (m_materialReduce == null)
			{
				m_materialReduce = new Material(shaderReduce);
				m_materialReduce.hideFlags = HideFlags.HideAndDontSave;
			}
			return m_materialReduce;
		}
	}

	protected Material materialAdapt
	{
		get
		{
			if (m_materialAdapt == null)
			{
				m_materialAdapt = new Material(shaderAdapt);
				m_materialAdapt.hideFlags = HideFlags.HideAndDontSave;
			}
			return m_materialAdapt;
		}
	}

	protected Material materialApply
	{
		get
		{
			if (m_materialApply == null)
			{
				m_materialApply = new Material(shaderApply);
				m_materialApply.hideFlags = HideFlags.HideAndDontSave;
			}
			return m_materialApply;
		}
	}

	private void Start()
	{
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
		else if (!shaderAdapt.isSupported || !shaderApply.isSupported || !shaderLum.isSupported || !shaderReduce.isSupported)
		{
			base.enabled = false;
		}
	}

	private void OnEnable()
	{
		for (int i = 0; i < 2; i++)
		{
			if (!adaptRenderTex[i])
			{
				adaptRenderTex[i] = new RenderTexture(1, 1, 0);
				adaptRenderTex[i].hideFlags = HideFlags.HideAndDontSave;
			}
		}
	}

	private void OnDisable()
	{
		for (int i = 0; i < 2; i++)
		{
			UnityEngine.Object.DestroyImmediate(adaptRenderTex[i]);
			adaptRenderTex[i] = null;
		}
		if ((bool)m_materialLum)
		{
			UnityEngine.Object.DestroyImmediate(m_materialLum);
		}
		if ((bool)m_materialReduce)
		{
			UnityEngine.Object.DestroyImmediate(m_materialReduce);
		}
		if ((bool)m_materialAdapt)
		{
			UnityEngine.Object.DestroyImmediate(m_materialAdapt);
		}
		if ((bool)m_materialApply)
		{
			UnityEngine.Object.DestroyImmediate(m_materialApply);
		}
	}

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		RenderTexture renderTexture = RenderTexture.GetTemporary(source.width / 1, source.height / 1);
		Graphics.Blit(source, renderTexture, materialLum);
		while (renderTexture.width > 1 || renderTexture.height > 1)
		{
			int num = renderTexture.width / 2;
			if (num < 1)
			{
				num = 1;
			}
			int num2 = renderTexture.height / 2;
			if (num2 < 1)
			{
				num2 = 1;
			}
			RenderTexture temporary = RenderTexture.GetTemporary(num, num2);
			Graphics.Blit(renderTexture, temporary, materialReduce);
			RenderTexture.ReleaseTemporary(renderTexture);
			renderTexture = temporary;
		}
		CalculateAdaptation(renderTexture);
		materialApply.SetTexture("_AdaptTex", adaptRenderTex[curAdaptIndex]);
		Graphics.Blit(source, destination, materialApply);
		RenderTexture.ReleaseTemporary(renderTexture);
	}

	private void CalculateAdaptation(Texture curTexture)
	{
		int num = curAdaptIndex;
		curAdaptIndex = (curAdaptIndex + 1) % 2;
		float value = 1f - Mathf.Pow(1f - adaptationSpeed, 30f * Time.deltaTime);
		value = Mathf.Clamp(value, 0.01f, 1f);
		materialAdapt.SetTexture("_CurTex", curTexture);
		materialAdapt.SetVector("_AdaptParams", new Vector4(value, limitMinimum, limitMaximum, 0f));
		Graphics.SetRenderTarget(adaptRenderTex[curAdaptIndex]);
		GL.Clear(clearDepth: false, clearColor: true, Color.black);
		Graphics.Blit(adaptRenderTex[num], adaptRenderTex[curAdaptIndex], materialAdapt);
	}
}
[ExecuteInEditMode]
[RequireComponent(typeof(Camera))]
[AddComponentMenu("Image Effects/Bloom and Glow/Glow (Deprecated)")]
public class GlowDeprecated : MonoBehaviour
{
	public float glowIntensity = 1.5f;

	public int blurIterations = 3;

	public float blurSpread = 0.7f;

	public Color glowTint = new Color(1f, 1f, 1f, 0f);

	public Shader compositeShader;

	private Material m_CompositeMaterial;

	public Shader blurShader;

	private Material m_BlurMaterial;

	public Shader downsampleShader;

	private Material m_DownsampleMaterial;

	protected Material compositeMaterial
	{
		get
		{
			if (m_CompositeMaterial == null)
			{
				m_CompositeMaterial = new Material(compositeShader);
				m_CompositeMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return m_CompositeMaterial;
		}
	}

	protected Material blurMaterial
	{
		get
		{
			if (m_BlurMaterial == null)
			{
				m_BlurMaterial = new Material(blurShader);
				m_BlurMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return m_BlurMaterial;
		}
	}

	protected Material downsampleMaterial
	{
		get
		{
			if (m_DownsampleMaterial == null)
			{
				m_DownsampleMaterial = new Material(downsampleShader);
				m_DownsampleMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return m_DownsampleMaterial;
		}
	}

	protected void OnDisable()
	{
		if ((bool)m_CompositeMaterial)
		{
			UnityEngine.Object.DestroyImmediate(m_CompositeMaterial);
		}
		if ((bool)m_BlurMaterial)
		{
			UnityEngine.Object.DestroyImmediate(m_BlurMaterial);
		}
		if ((bool)m_DownsampleMaterial)
		{
			UnityEngine.Object.DestroyImmediate(m_DownsampleMaterial);
		}
	}

	protected void Start()
	{
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
			return;
		}
		if (downsampleShader == null)
		{
			UnityEngine.Debug.Log("No downsample shader assigned! Disabling glow.");
			base.enabled = false;
			return;
		}
		if (!blurMaterial.shader.isSupported)
		{
			base.enabled = false;
		}
		if (!compositeMaterial.shader.isSupported)
		{
			base.enabled = false;
		}
		if (!downsampleMaterial.shader.isSupported)
		{
			base.enabled = false;
		}
	}

	public void FourTapCone(RenderTexture source, RenderTexture dest, int iteration)
	{
		float num = 0.5f + (float)iteration * blurSpread;
		Graphics.BlitMultiTap(source, dest, blurMaterial, new Vector2(num, num), new Vector2(0f - num, num), new Vector2(num, 0f - num), new Vector2(0f - num, 0f - num));
	}

	private void DownSample4x(RenderTexture source, RenderTexture dest)
	{
		downsampleMaterial.color = new Color(glowTint.r, glowTint.g, glowTint.b, glowTint.a / 4f);
		Graphics.Blit(source, dest, downsampleMaterial);
	}

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		glowIntensity = Mathf.Clamp(glowIntensity, 0f, 10f);
		blurIterations = Mathf.Clamp(blurIterations, 0, 30);
		blurSpread = Mathf.Clamp(blurSpread, 0.5f, 1f);
		int width = source.width / 4;
		int height = source.height / 4;
		RenderTexture renderTexture = RenderTexture.GetTemporary(width, height, 0);
		DownSample4x(source, renderTexture);
		float num = Mathf.Clamp01((glowIntensity - 1f) / 4f);
		blurMaterial.color = new Color(1f, 1f, 1f, 0.25f + num);
		for (int i = 0; i < blurIterations; i++)
		{
			RenderTexture temporary = RenderTexture.GetTemporary(width, height, 0);
			FourTapCone(renderTexture, temporary, i);
			RenderTexture.ReleaseTemporary(renderTexture);
			renderTexture = temporary;
		}
		Graphics.Blit(source, destination);
		BlitGlow(renderTexture, destination);
		RenderTexture.ReleaseTemporary(renderTexture);
	}

	public void BlitGlow(RenderTexture source, RenderTexture dest)
	{
		compositeMaterial.color = new Color(1f, 1f, 1f, Mathf.Clamp01(glowIntensity));
		Graphics.Blit(source, dest, compositeMaterial);
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Image Effects/Color Adjustments/Grayscale")]
public class GrayscaleEffect : ImageEffectBase
{
	public Texture textureRamp;

	public float rampOffset;

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		base.material.SetTexture("_RampTex", textureRamp);
		base.material.SetFloat("_RampOffset", rampOffset);
		Graphics.Blit(source, destination, base.material);
	}
}
[RequireComponent(typeof(Camera))]
[AddComponentMenu("")]
public class ImageEffectBase : MonoBehaviour
{
	public Shader shader;

	private Material m_Material;

	protected Material material
	{
		get
		{
			if (m_Material == null)
			{
				m_Material = new Material(shader);
				m_Material.hideFlags = HideFlags.HideAndDontSave;
			}
			return m_Material;
		}
	}

	protected virtual void Start()
	{
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
		else if (!shader || !shader.isSupported)
		{
			base.enabled = false;
		}
	}

	protected virtual void OnDisable()
	{
		if ((bool)m_Material)
		{
			UnityEngine.Object.DestroyImmediate(m_Material);
		}
	}
}
[AddComponentMenu("")]
public class ImageEffects
{
	public static void RenderDistortion(Material material, RenderTexture source, RenderTexture destination, float angle, Vector2 center, Vector2 radius)
	{
		if (source.texelSize.y < 0f)
		{
			center.y = 1f - center.y;
			angle = 0f - angle;
		}
		Matrix4x4 value = Matrix4x4.TRS(Vector3.zero, Quaternion.Euler(0f, 0f, angle), Vector3.one);
		material.SetMatrix("_RotationMatrix", value);
		material.SetVector("_CenterRadius", new Vector4(center.x, center.y, radius.x, radius.y));
		material.SetFloat("_Angle", angle * ((float)Math.PI / 180f));
		Graphics.Blit(source, destination, material);
	}

	[Obsolete("Use Graphics.Blit(source,dest) instead")]
	public static void Blit(RenderTexture source, RenderTexture dest)
	{
		Graphics.Blit(source, dest);
	}

	[Obsolete("Use Graphics.Blit(source, destination, material) instead")]
	public static void BlitWithMaterial(Material material, RenderTexture source, RenderTexture dest)
	{
		Graphics.Blit(source, dest, material);
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Image Effects/Blur/Motion Blur (Color Accumulation)")]
[RequireComponent(typeof(Camera))]
public class MotionBlur : ImageEffectBase
{
	public float blurAmount = 0.8f;

	public bool extraBlur;

	private RenderTexture accumTexture;

	protected override void Start()
	{
		if (!SystemInfo.supportsRenderTextures)
		{
			base.enabled = false;
		}
		else
		{
			base.Start();
		}
	}

	protected override void OnDisable()
	{
		base.OnDisable();
		UnityEngine.Object.DestroyImmediate(accumTexture);
	}

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		if (accumTexture == null || accumTexture.width != source.width || accumTexture.height != source.height)
		{
			UnityEngine.Object.DestroyImmediate(accumTexture);
			accumTexture = new RenderTexture(source.width, source.height, 0);
			accumTexture.hideFlags = HideFlags.HideAndDontSave;
			Graphics.Blit(source, accumTexture);
		}
		if (extraBlur)
		{
			RenderTexture temporary = RenderTexture.GetTemporary(source.width / 4, source.height / 4, 0);
			accumTexture.MarkRestoreExpected();
			Graphics.Blit(accumTexture, temporary);
			Graphics.Blit(temporary, accumTexture);
			RenderTexture.ReleaseTemporary(temporary);
		}
		blurAmount = Mathf.Clamp(blurAmount, 0f, 0.92f);
		base.material.SetTexture("_MainTex", accumTexture);
		base.material.SetFloat("_AccumOrig", 1f - blurAmount);
		accumTexture.MarkRestoreExpected();
		Graphics.Blit(source, accumTexture, base.material);
		Graphics.Blit(accumTexture, destination);
	}
}
[ExecuteInEditMode]
[RequireComponent(typeof(Camera))]
[AddComponentMenu("Image Effects/Noise/Noise and Scratches")]
public class NoiseEffect : MonoBehaviour
{
	public bool monochrome = true;

	private bool rgbFallback;

	public float grainIntensityMin = 0.1f;

	public float grainIntensityMax = 0.2f;

	public float grainSize = 2f;

	public float scratchIntensityMin = 0.05f;

	public float scratchIntensityMax = 0.25f;

	public float scratchFPS = 10f;

	public float scratchJitter = 0.01f;

	public Texture grainTexture;

	public Texture scratchTexture;

	public Shader shaderRGB;

	public Shader shaderYUV;

	private Material m_MaterialRGB;

	private Material m_MaterialYUV;

	private float scratchTimeLeft;

	private float scratchX;

	private float scratchY;

	protected Material material
	{
		get
		{
			if (m_MaterialRGB == null)
			{
				m_MaterialRGB = new Material(shaderRGB);
				m_MaterialRGB.hideFlags = HideFlags.HideAndDontSave;
			}
			if (m_MaterialYUV == null && !rgbFallback)
			{
				m_MaterialYUV = new Material(shaderYUV);
				m_MaterialYUV.hideFlags = HideFlags.HideAndDontSave;
			}
			if (rgbFallback || monochrome)
			{
				return m_MaterialRGB;
			}
			return m_MaterialYUV;
		}
	}

	protected void Start()
	{
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
		else if (shaderRGB == null || shaderYUV == null)
		{
			UnityEngine.Debug.Log("Noise shaders are not set up! Disabling noise effect.");
			base.enabled = false;
		}
		else if (!shaderRGB.isSupported)
		{
			base.enabled = false;
		}
		else if (!shaderYUV.isSupported)
		{
			rgbFallback = true;
		}
	}

	protected void OnDisable()
	{
		if ((bool)m_MaterialRGB)
		{
			UnityEngine.Object.DestroyImmediate(m_MaterialRGB);
		}
		if ((bool)m_MaterialYUV)
		{
			UnityEngine.Object.DestroyImmediate(m_MaterialYUV);
		}
	}

	private void SanitizeParameters()
	{
		grainIntensityMin = Mathf.Clamp(grainIntensityMin, 0f, 5f);
		grainIntensityMax = Mathf.Clamp(grainIntensityMax, 0f, 5f);
		scratchIntensityMin = Mathf.Clamp(scratchIntensityMin, 0f, 5f);
		scratchIntensityMax = Mathf.Clamp(scratchIntensityMax, 0f, 5f);
		scratchFPS = Mathf.Clamp(scratchFPS, 1f, 30f);
		scratchJitter = Mathf.Clamp(scratchJitter, 0f, 1f);
		grainSize = Mathf.Clamp(grainSize, 0.1f, 50f);
	}

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		SanitizeParameters();
		if (scratchTimeLeft <= 0f)
		{
			scratchTimeLeft = UnityEngine.Random.value * 2f / scratchFPS;
			scratchX = UnityEngine.Random.value;
			scratchY = UnityEngine.Random.value;
		}
		scratchTimeLeft -= Time.deltaTime;
		Material material = this.material;
		material.SetTexture("_GrainTex", grainTexture);
		material.SetTexture("_ScratchTex", scratchTexture);
		float num = 1f / grainSize;
		material.SetVector("_GrainOffsetScale", new Vector4(UnityEngine.Random.value, UnityEngine.Random.value, (float)Screen.width / (float)grainTexture.width * num, (float)Screen.height / (float)grainTexture.height * num));
		material.SetVector("_ScratchOffsetScale", new Vector4(scratchX + UnityEngine.Random.value * scratchJitter, scratchY + UnityEngine.Random.value * scratchJitter, (float)Screen.width / (float)scratchTexture.width, (float)Screen.height / (float)scratchTexture.height));
		material.SetVector("_Intensity", new Vector4(UnityEngine.Random.Range(grainIntensityMin, grainIntensityMax), UnityEngine.Random.Range(scratchIntensityMin, scratchIntensityMax), 0f, 0f));
		Graphics.Blit(source, destination, material);
	}
}
[ExecuteInEditMode]
[RequireComponent(typeof(Camera))]
[AddComponentMenu("Image Effects/Rendering/Screen Space Ambient Occlusion")]
public class SSAOEffect : MonoBehaviour
{
	public enum SSAOSamples
	{
		Low,
		Medium,
		High
	}

	public float m_Radius = 0.4f;

	public SSAOSamples m_SampleCount = SSAOSamples.Medium;

	public float m_OcclusionIntensity = 1.5f;

	public int m_Blur = 2;

	public int m_Downsampling = 2;

	public float m_OcclusionAttenuation = 1f;

	public float m_MinZ = 0.01f;

	public Shader m_SSAOShader;

	private Material m_SSAOMaterial;

	public Texture2D m_RandomTexture;

	private bool m_Supported;

	private static Material CreateMaterial(Shader shader)
	{
		if (!shader)
		{
			return null;
		}
		return new Material(shader)
		{
			hideFlags = HideFlags.HideAndDontSave
		};
	}

	private static void DestroyMaterial(Material mat)
	{
		if ((bool)mat)
		{
			UnityEngine.Object.DestroyImmediate(mat);
			mat = null;
		}
	}

	private void OnDisable()
	{
		DestroyMaterial(m_SSAOMaterial);
	}

	private void Start()
	{
		if (!SystemInfo.supportsImageEffects || !SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.Depth))
		{
			m_Supported = false;
			base.enabled = false;
			return;
		}
		CreateMaterials();
		if (!m_SSAOMaterial || m_SSAOMaterial.passCount != 5)
		{
			m_Supported = false;
			base.enabled = false;
		}
		else
		{
			m_Supported = true;
		}
	}

	private void OnEnable()
	{
		GetComponent<Camera>().depthTextureMode |= DepthTextureMode.DepthNormals;
	}

	private void CreateMaterials()
	{
		if (!m_SSAOMaterial && m_SSAOShader.isSupported)
		{
			m_SSAOMaterial = CreateMaterial(m_SSAOShader);
			m_SSAOMaterial.SetTexture("_RandomTexture", m_RandomTexture);
		}
	}

	[ImageEffectOpaque]
	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		if (!m_Supported || !m_SSAOShader.isSupported)
		{
			base.enabled = false;
			return;
		}
		CreateMaterials();
		m_Downsampling = Mathf.Clamp(m_Downsampling, 1, 6);
		m_Radius = Mathf.Clamp(m_Radius, 0.05f, 1f);
		m_MinZ = Mathf.Clamp(m_MinZ, 1E-05f, 0.5f);
		m_OcclusionIntensity = Mathf.Clamp(m_OcclusionIntensity, 0.5f, 4f);
		m_OcclusionAttenuation = Mathf.Clamp(m_OcclusionAttenuation, 0.2f, 2f);
		m_Blur = Mathf.Clamp(m_Blur, 0, 4);
		RenderTexture renderTexture = RenderTexture.GetTemporary(source.width / m_Downsampling, source.height / m_Downsampling, 0);
		float fieldOfView = GetComponent<Camera>().fieldOfView;
		float farClipPlane = GetComponent<Camera>().farClipPlane;
		float num = Mathf.Tan(fieldOfView * ((float)Math.PI / 180f) * 0.5f) * farClipPlane;
		float x = num * GetComponent<Camera>().aspect;
		m_SSAOMaterial.SetVector("_FarCorner", new Vector3(x, num, farClipPlane));
		int num2;
		int num3;
		if ((bool)m_RandomTexture)
		{
			num2 = m_RandomTexture.width;
			num3 = m_RandomTexture.height;
		}
		else
		{
			num2 = 1;
			num3 = 1;
		}
		m_SSAOMaterial.SetVector("_NoiseScale", new Vector3((float)renderTexture.width / (float)num2, (float)renderTexture.height / (float)num3, 0f));
		m_SSAOMaterial.SetVector("_Params", new Vector4(m_Radius, m_MinZ, 1f / m_OcclusionAttenuation, m_OcclusionIntensity));
		bool num4 = m_Blur > 0;
		Graphics.Blit(num4 ? null : source, renderTexture, m_SSAOMaterial, (int)m_SampleCount);
		if (num4)
		{
			RenderTexture temporary = RenderTexture.GetTemporary(source.width, source.height, 0);
			m_SSAOMaterial.SetVector("_TexelOffsetScale", new Vector4((float)m_Blur / (float)source.width, 0f, 0f, 0f));
			m_SSAOMaterial.SetTexture("_SSAO", renderTexture);
			Graphics.Blit(null, temporary, m_SSAOMaterial, 3);
			RenderTexture.ReleaseTemporary(renderTexture);
			RenderTexture temporary2 = RenderTexture.GetTemporary(source.width, source.height, 0);
			m_SSAOMaterial.SetVector("_TexelOffsetScale", new Vector4(0f, (float)m_Blur / (float)source.height, 0f, 0f));
			m_SSAOMaterial.SetTexture("_SSAO", temporary);
			Graphics.Blit(source, temporary2, m_SSAOMaterial, 3);
			RenderTexture.ReleaseTemporary(temporary);
			renderTexture = temporary2;
		}
		m_SSAOMaterial.SetTexture("_SSAO", renderTexture);
		Graphics.Blit(source, destination, m_SSAOMaterial, 4);
		RenderTexture.ReleaseTemporary(renderTexture);
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Image Effects/Color Adjustments/Sepia Tone")]
public class SepiaToneEffect : ImageEffectBase
{
	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		Graphics.Blit(source, destination, base.material);
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Image Effects/Displacement/Twirl")]
public class TwirlEffect : ImageEffectBase
{
	public Vector2 radius = new Vector2(0.3f, 0.3f);

	public float angle = 50f;

	public Vector2 center = new Vector2(0.5f, 0.5f);

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		ImageEffects.RenderDistortion(base.material, source, destination, angle, center, radius);
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Image Effects/Displacement/Vortex")]
public class VortexEffect : ImageEffectBase
{
	public Vector2 radius = new Vector2(0.4f, 0.4f);

	public float angle = 50f;

	public Vector2 center = new Vector2(0.5f, 0.5f);

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		ImageEffects.RenderDistortion(base.material, source, destination, angle, center, radius);
	}
}
[ExecuteInEditMode]
public class Water : MonoBehaviour
{
	public enum WaterMode
	{
		Simple,
		Reflective,
		Refractive
	}

	public WaterMode m_WaterMode = WaterMode.Refractive;

	public bool m_DisablePixelLights = true;

	public int m_TextureSize = 256;

	public float m_ClipPlaneOffset = 0.07f;

	public LayerMask m_ReflectLayers = -1;

	public LayerMask m_RefractLayers = -1;

	private Dictionary<Camera, Camera> m_ReflectionCameras = new Dictionary<Camera, Camera>();

	private Dictionary<Camera, Camera> m_RefractionCameras = new Dictionary<Camera, Camera>();

	private RenderTexture m_ReflectionTexture;

	private RenderTexture m_RefractionTexture;

	private WaterMode m_HardwareWaterSupport = WaterMode.Refractive;

	private int m_OldReflectionTextureSize;

	private int m_OldRefractionTextureSize;

	private static bool s_InsideWater;

	public void OnWillRenderObject()
	{
		if (!base.enabled || !GetComponent<Renderer>() || !GetComponent<Renderer>().sharedMaterial || !GetComponent<Renderer>().enabled)
		{
			return;
		}
		Camera current = Camera.current;
		if ((bool)current && !s_InsideWater)
		{
			s_InsideWater = true;
			m_HardwareWaterSupport = FindHardwareWaterSupport();
			WaterMode waterMode = GetWaterMode();
			CreateWaterObjects(current, out var reflectionCamera, out var refractionCamera);
			Vector3 position = base.transform.position;
			Vector3 up = base.transform.up;
			int pixelLightCount = QualitySettings.pixelLightCount;
			if (m_DisablePixelLights)
			{
				QualitySettings.pixelLightCount = 0;
			}
			UpdateCameraModes(current, reflectionCamera);
			UpdateCameraModes(current, refractionCamera);
			if (waterMode >= WaterMode.Reflective)
			{
				float w = 0f - Vector3.Dot(up, position) - m_ClipPlaneOffset;
				Vector4 plane = new Vector4(up.x, up.y, up.z, w);
				Matrix4x4 reflectionMat = Matrix4x4.zero;
				CalculateReflectionMatrix(ref reflectionMat, plane);
				Vector3 position2 = current.transform.position;
				Vector3 position3 = reflectionMat.MultiplyPoint(position2);
				reflectionCamera.worldToCameraMatrix = current.worldToCameraMatrix * reflectionMat;
				Vector4 clipPlane = CameraSpacePlane(reflectionCamera, position, up, 1f);
				Matrix4x4 projection = current.projectionMatrix;
				CalculateObliqueMatrix(ref projection, clipPlane);
				reflectionCamera.projectionMatrix = projection;
				reflectionCamera.cullingMask = -17 & m_ReflectLayers.value;
				reflectionCamera.targetTexture = m_ReflectionTexture;
				GL.SetRevertBackfacing(revertBackFaces: true);
				reflectionCamera.transform.position = position3;
				Vector3 eulerAngles = current.transform.eulerAngles;
				reflectionCamera.transform.eulerAngles = new Vector3(0f - eulerAngles.x, eulerAngles.y, eulerAngles.z);
				reflectionCamera.Render();
				reflectionCamera.transform.position = position2;
				GL.SetRevertBackfacing(revertBackFaces: false);
				GetComponent<Renderer>().sharedMaterial.SetTexture("_ReflectionTex", m_ReflectionTexture);
			}
			if (waterMode >= WaterMode.Refractive)
			{
				refractionCamera.worldToCameraMatrix = current.worldToCameraMatrix;
				Vector4 clipPlane2 = CameraSpacePlane(refractionCamera, position, up, -1f);
				Matrix4x4 projection2 = current.projectionMatrix;
				CalculateObliqueMatrix(ref projection2, clipPlane2);
				refractionCamera.projectionMatrix = projection2;
				refractionCamera.cullingMask = -17 & m_RefractLayers.value;
				refractionCamera.targetTexture = m_RefractionTexture;
				refractionCamera.transform.position = current.transform.position;
				refractionCamera.transform.rotation = current.transform.rotation;
				refractionCamera.Render();
				GetComponent<Renderer>().sharedMaterial.SetTexture("_RefractionTex", m_RefractionTexture);
			}
			if (m_DisablePixelLights)
			{
				QualitySettings.pixelLightCount = pixelLightCount;
			}
			switch (waterMode)
			{
			case WaterMode.Simple:
				Shader.EnableKeyword("WATER_SIMPLE");
				Shader.DisableKeyword("WATER_REFLECTIVE");
				Shader.DisableKeyword("WATER_REFRACTIVE");
				break;
			case WaterMode.Reflective:
				Shader.DisableKeyword("WATER_SIMPLE");
				Shader.EnableKeyword("WATER_REFLECTIVE");
				Shader.DisableKeyword("WATER_REFRACTIVE");
				break;
			case WaterMode.Refractive:
				Shader.DisableKeyword("WATER_SIMPLE");
				Shader.DisableKeyword("WATER_REFLECTIVE");
				Shader.EnableKeyword("WATER_REFRACTIVE");
				break;
			}
			s_InsideWater = false;
		}
	}

	private void OnDisable()
	{
		if ((bool)m_ReflectionTexture)
		{
			UnityEngine.Object.DestroyImmediate(m_ReflectionTexture);
			m_ReflectionTexture = null;
		}
		if ((bool)m_RefractionTexture)
		{
			UnityEngine.Object.DestroyImmediate(m_RefractionTexture);
			m_RefractionTexture = null;
		}
		foreach (KeyValuePair<Camera, Camera> reflectionCamera in m_ReflectionCameras)
		{
			UnityEngine.Object.DestroyImmediate(reflectionCamera.Value.gameObject);
		}
		m_ReflectionCameras.Clear();
		foreach (KeyValuePair<Camera, Camera> refractionCamera in m_RefractionCameras)
		{
			UnityEngine.Object.DestroyImmediate(refractionCamera.Value.gameObject);
		}
		m_RefractionCameras.Clear();
	}

	private void Update()
	{
		if ((bool)GetComponent<Renderer>())
		{
			Material sharedMaterial = GetComponent<Renderer>().sharedMaterial;
			if ((bool)sharedMaterial)
			{
				Vector4 vector = sharedMaterial.GetVector("WaveSpeed");
				float @float = sharedMaterial.GetFloat("_WaveScale");
				Vector4 value = new Vector4(@float, @float, @float * 0.4f, @float * 0.45f);
				double num = (double)Time.timeSinceLevelLoad / 20.0;
				Vector4 value2 = new Vector4((float)Math.IEEERemainder((double)(vector.x * value.x) * num, 1.0), (float)Math.IEEERemainder((double)(vector.y * value.y) * num, 1.0), (float)Math.IEEERemainder((double)(vector.z * value.z) * num, 1.0), (float)Math.IEEERemainder((double)(vector.w * value.w) * num, 1.0));
				sharedMaterial.SetVector("_WaveOffset", value2);
				sharedMaterial.SetVector("_WaveScale4", value);
				Vector3 size = GetComponent<Renderer>().bounds.size;
				Matrix4x4 value3 = Matrix4x4.TRS(s: new Vector3(size.x * value.x, size.z * value.y, 1f), pos: new Vector3(value2.x, value2.y, 0f), q: Quaternion.identity);
				sharedMaterial.SetMatrix("_WaveMatrix", value3);
				value3 = Matrix4x4.TRS(s: new Vector3(size.x * value.z, size.z * value.w, 1f), pos: new Vector3(value2.z, value2.w, 0f), q: Quaternion.identity);
				sharedMaterial.SetMatrix("_WaveMatrix2", value3);
			}
		}
	}

	private void UpdateCameraModes(Camera src, Camera dest)
	{
		if (dest == null)
		{
			return;
		}
		dest.clearFlags = src.clearFlags;
		dest.backgroundColor = src.backgroundColor;
		if (src.clearFlags == CameraClearFlags.Skybox)
		{
			Skybox skybox = src.GetComponent(typeof(Skybox)) as Skybox;
			Skybox skybox2 = dest.GetComponent(typeof(Skybox)) as Skybox;
			if (!skybox || !skybox.material)
			{
				skybox2.enabled = false;
			}
			else
			{
				skybox2.enabled = true;
				skybox2.material = skybox.material;
			}
		}
		dest.farClipPlane = src.farClipPlane;
		dest.nearClipPlane = src.nearClipPlane;
		dest.orthographic = src.orthographic;
		dest.fieldOfView = src.fieldOfView;
		dest.aspect = src.aspect;
		dest.orthographicSize = src.orthographicSize;
	}

	private void CreateWaterObjects(Camera currentCamera, out Camera reflectionCamera, out Camera refractionCamera)
	{
		WaterMode waterMode = GetWaterMode();
		reflectionCamera = null;
		refractionCamera = null;
		if (waterMode >= WaterMode.Reflective)
		{
			if (!m_ReflectionTexture || m_OldReflectionTextureSize != m_TextureSize)
			{
				if ((bool)m_ReflectionTexture)
				{
					UnityEngine.Object.DestroyImmediate(m_ReflectionTexture);
				}
				m_ReflectionTexture = new RenderTexture(m_TextureSize, m_TextureSize, 16);
				m_ReflectionTexture.name = "__WaterReflection" + GetInstanceID();
				m_ReflectionTexture.isPowerOfTwo = true;
				m_ReflectionTexture.hideFlags = HideFlags.DontSave;
				m_OldReflectionTextureSize = m_TextureSize;
			}
			m_ReflectionCameras.TryGetValue(currentCamera, out reflectionCamera);
			if (!reflectionCamera)
			{
				GameObject gameObject = new GameObject("Water Refl Camera id" + GetInstanceID() + " for " + currentCamera.GetInstanceID(), typeof(Camera), typeof(Skybox));
				reflectionCamera = gameObject.GetComponent<Camera>();
				reflectionCamera.enabled = false;
				reflectionCamera.transform.position = base.transform.position;
				reflectionCamera.transform.rotation = base.transform.rotation;
				reflectionCamera.gameObject.AddComponent<FlareLayer>();
				gameObject.hideFlags = HideFlags.HideAndDontSave;
				m_ReflectionCameras[currentCamera] = reflectionCamera;
			}
		}
		if (waterMode < WaterMode.Refractive)
		{
			return;
		}
		if (!m_RefractionTexture || m_OldRefractionTextureSize != m_TextureSize)
		{
			if ((bool)m_RefractionTexture)
			{
				UnityEngine.Object.DestroyImmediate(m_RefractionTexture);
			}
			m_RefractionTexture = new RenderTexture(m_TextureSize, m_TextureSize, 16);
			m_RefractionTexture.name = "__WaterRefraction" + GetInstanceID();
			m_RefractionTexture.isPowerOfTwo = true;
			m_RefractionTexture.hideFlags = HideFlags.DontSave;
			m_OldRefractionTextureSize = m_TextureSize;
		}
		m_RefractionCameras.TryGetValue(currentCamera, out refractionCamera);
		if (!refractionCamera)
		{
			GameObject gameObject2 = new GameObject("Water Refr Camera id" + GetInstanceID() + " for " + currentCamera.GetInstanceID(), typeof(Camera), typeof(Skybox));
			refractionCamera = gameObject2.GetComponent<Camera>();
			refractionCamera.enabled = false;
			refractionCamera.transform.position = base.transform.position;
			refractionCamera.transform.rotation = base.transform.rotation;
			refractionCamera.gameObject.AddComponent<FlareLayer>();
			gameObject2.hideFlags = HideFlags.HideAndDontSave;
			m_RefractionCameras[currentCamera] = refractionCamera;
		}
	}

	private WaterMode GetWaterMode()
	{
		if (m_HardwareWaterSupport < m_WaterMode)
		{
			return m_HardwareWaterSupport;
		}
		return m_WaterMode;
	}

	private WaterMode FindHardwareWaterSupport()
	{
		if (!SystemInfo.supportsRenderTextures || !GetComponent<Renderer>())
		{
			return WaterMode.Simple;
		}
		Material sharedMaterial = GetComponent<Renderer>().sharedMaterial;
		if (!sharedMaterial)
		{
			return WaterMode.Simple;
		}
		string text = sharedMaterial.GetTag("WATERMODE", searchFallbacks: false);
		if (text == "Refractive")
		{
			return WaterMode.Refractive;
		}
		if (text == "Reflective")
		{
			return WaterMode.Reflective;
		}
		return WaterMode.Simple;
	}

	private static float sgn(float a)
	{
		if (a > 0f)
		{
			return 1f;
		}
		if (a < 0f)
		{
			return -1f;
		}
		return 0f;
	}

	private Vector4 CameraSpacePlane(Camera cam, Vector3 pos, Vector3 normal, float sideSign)
	{
		Vector3 point = pos + normal * m_ClipPlaneOffset;
		Matrix4x4 worldToCameraMatrix = cam.worldToCameraMatrix;
		Vector3 lhs = worldToCameraMatrix.MultiplyPoint(point);
		Vector3 rhs = worldToCameraMatrix.MultiplyVector(normal).normalized * sideSign;
		return new Vector4(rhs.x, rhs.y, rhs.z, 0f - Vector3.Dot(lhs, rhs));
	}

	private static void CalculateObliqueMatrix(ref Matrix4x4 projection, Vector4 clipPlane)
	{
		Vector4 b = projection.inverse * new Vector4(sgn(clipPlane.x), sgn(clipPlane.y), 1f, 1f);
		Vector4 vector = clipPlane * (2f / Vector4.Dot(clipPlane, b));
		projection[2] = vector.x - projection[3];
		projection[6] = vector.y - projection[7];
		projection[10] = vector.z - projection[11];
		projection[14] = vector.w - projection[15];
	}

	private static void CalculateReflectionMatrix(ref Matrix4x4 reflectionMat, Vector4 plane)
	{
		reflectionMat.m00 = 1f - 2f * plane[0] * plane[0];
		reflectionMat.m01 = -2f * plane[0] * plane[1];
		reflectionMat.m02 = -2f * plane[0] * plane[2];
		reflectionMat.m03 = -2f * plane[3] * plane[0];
		reflectionMat.m10 = -2f * plane[1] * plane[0];
		reflectionMat.m11 = 1f - 2f * plane[1] * plane[1];
		reflectionMat.m12 = -2f * plane[1] * plane[2];
		reflectionMat.m13 = -2f * plane[3] * plane[1];
		reflectionMat.m20 = -2f * plane[2] * plane[0];
		reflectionMat.m21 = -2f * plane[2] * plane[1];
		reflectionMat.m22 = 1f - 2f * plane[2] * plane[2];
		reflectionMat.m23 = -2f * plane[3] * plane[2];
		reflectionMat.m30 = 0f;
		reflectionMat.m31 = 0f;
		reflectionMat.m32 = 0f;
		reflectionMat.m33 = 1f;
	}
}
[ExecuteInEditMode]
[RequireComponent(typeof(WaterBase))]
public class Displace : MonoBehaviour
{
	public void Awake()
	{
		if (base.enabled)
		{
			OnEnable();
		}
		else
		{
			OnDisable();
		}
	}

	public void OnEnable()
	{
		Shader.EnableKeyword("WATER_VERTEX_DISPLACEMENT_ON");
		Shader.DisableKeyword("WATER_VERTEX_DISPLACEMENT_OFF");
	}

	public void OnDisable()
	{
		Shader.EnableKeyword("WATER_VERTEX_DISPLACEMENT_OFF");
		Shader.DisableKeyword("WATER_VERTEX_DISPLACEMENT_ON");
	}
}
[ExecuteInEditMode]
[RequireComponent(typeof(WaterBase))]
public class GerstnerDisplace : Displace
{
}
public class MeshContainer
{
	public Mesh mesh;

	public Vector3[] vertices;

	public Vector3[] normals;

	public MeshContainer(Mesh m)
	{
		mesh = m;
		vertices = m.vertices;
		normals = m.normals;
	}

	public void Update()
	{
		mesh.vertices = vertices;
		mesh.normals = normals;
	}
}
[ExecuteInEditMode]
[RequireComponent(typeof(WaterBase))]
public class PlanarReflection : MonoBehaviour
{
	public LayerMask reflectionMask;

	public bool reflectSkybox;

	public Color clearColor = Color.grey;

	public string reflectionSampler = "_ReflectionTex";

	public float clipPlaneOffset = 0.07f;

	private Vector3 oldpos = Vector3.zero;

	private Camera reflectionCamera;

	private Material sharedMaterial;

	private Dictionary<Camera, bool> helperCameras;

	public void Start()
	{
		sharedMaterial = ((WaterBase)base.gameObject.GetComponent(typeof(WaterBase))).sharedMaterial;
	}

	private Camera CreateReflectionCameraFor(Camera cam)
	{
		string text = base.gameObject.name + "Reflection" + cam.name;
		GameObject gameObject = GameObject.Find(text);
		if (!gameObject)
		{
			gameObject = new GameObject(text, typeof(Camera));
		}
		if (!gameObject.GetComponent(typeof(Camera)))
		{
			gameObject.AddComponent(typeof(Camera));
		}
		Camera component = gameObject.GetComponent<Camera>();
		component.backgroundColor = clearColor;
		component.clearFlags = (reflectSkybox ? CameraClearFlags.Skybox : CameraClearFlags.Color);
		SetStandardCameraParameter(component, reflectionMask);
		if (!component.targetTexture)
		{
			component.targetTexture = CreateTextureFor(cam);
		}
		return component;
	}

	private void SetStandardCameraParameter(Camera cam, LayerMask mask)
	{
		cam.cullingMask = (int)mask & ~(1 << LayerMask.NameToLayer("Water"));
		cam.backgroundColor = Color.black;
		cam.enabled = false;
	}

	private RenderTexture CreateTextureFor(Camera cam)
	{
		return new RenderTexture(Mathf.FloorToInt((float)cam.pixelWidth * 0.5f), Mathf.FloorToInt((float)cam.pixelHeight * 0.5f), 24)
		{
			hideFlags = HideFlags.DontSave
		};
	}

	public void RenderHelpCameras(Camera currentCam)
	{
		if (helperCameras == null)
		{
			helperCameras = new Dictionary<Camera, bool>();
		}
		if (!helperCameras.ContainsKey(currentCam))
		{
			helperCameras.Add(currentCam, value: false);
		}
		if (!helperCameras[currentCam])
		{
			if (!reflectionCamera)
			{
				reflectionCamera = CreateReflectionCameraFor(currentCam);
			}
			RenderReflectionFor(currentCam, reflectionCamera);
			helperCameras[currentCam] = true;
		}
	}

	public void LateUpdate()
	{
		if (helperCameras != null)
		{
			helperCameras.Clear();
		}
	}

	public void WaterTileBeingRendered(Transform tr, Camera currentCam)
	{
		RenderHelpCameras(currentCam);
		if ((bool)reflectionCamera && (bool)sharedMaterial)
		{
			sharedMaterial.SetTexture(reflectionSampler, reflectionCamera.targetTexture);
		}
	}

	public void OnEnable()
	{
		Shader.EnableKeyword("WATER_REFLECTIVE");
		Shader.DisableKeyword("WATER_SIMPLE");
	}

	public void OnDisable()
	{
		Shader.EnableKeyword("WATER_SIMPLE");
		Shader.DisableKeyword("WATER_REFLECTIVE");
	}

	private void RenderReflectionFor(Camera cam, Camera reflectCamera)
	{
		if (!reflectCamera || ((bool)sharedMaterial && !sharedMaterial.HasProperty(reflectionSampler)))
		{
			return;
		}
		reflectCamera.cullingMask = (int)reflectionMask & ~(1 << LayerMask.NameToLayer("Water"));
		SaneCameraSettings(reflectCamera);
		reflectCamera.backgroundColor = clearColor;
		reflectCamera.clearFlags = (reflectSkybox ? CameraClearFlags.Skybox : CameraClearFlags.Color);
		if (reflectSkybox && (bool)cam.gameObject.GetComponent(typeof(Skybox)))
		{
			Skybox skybox = (Skybox)reflectCamera.gameObject.GetComponent(typeof(Skybox));
			if (!skybox)
			{
				skybox = (Skybox)reflectCamera.gameObject.AddComponent(typeof(Skybox));
			}
			skybox.material = ((Skybox)cam.GetComponent(typeof(Skybox))).material;
		}
		GL.SetRevertBackfacing(revertBackFaces: true);
		Transform transform = base.transform;
		Vector3 eulerAngles = cam.transform.eulerAngles;
		reflectCamera.transform.eulerAngles = new Vector3(0f - eulerAngles.x, eulerAngles.y, eulerAngles.z);
		reflectCamera.transform.position = cam.transform.position;
		Vector3 position = transform.transform.position;
		position.y = transform.position.y;
		Vector3 up = transform.transform.up;
		float w = 0f - Vector3.Dot(up, position) - clipPlaneOffset;
		Vector4 plane = new Vector4(up.x, up.y, up.z, w);
		Matrix4x4 zero = Matrix4x4.zero;
		zero = CalculateReflectionMatrix(zero, plane);
		oldpos = cam.transform.position;
		Vector3 position2 = zero.MultiplyPoint(oldpos);
		reflectCamera.worldToCameraMatrix = cam.worldToCameraMatrix * zero;
		Vector4 clipPlane = CameraSpacePlane(reflectCamera, position, up, 1f);
		Matrix4x4 projectionMatrix = cam.projectionMatrix;
		projectionMatrix = CalculateObliqueMatrix(projectionMatrix, clipPlane);
		reflectCamera.projectionMatrix = projectionMatrix;
		reflectCamera.transform.position = position2;
		Vector3 eulerAngles2 = cam.transform.eulerAngles;
		reflectCamera.transform.eulerAngles = new Vector3(0f - eulerAngles2.x, eulerAngles2.y, eulerAngles2.z);
		reflectCamera.Render();
		GL.SetRevertBackfacing(revertBackFaces: false);
	}

	private void SaneCameraSettings(Camera helperCam)
	{
		helperCam.depthTextureMode = DepthTextureMode.None;
		helperCam.backgroundColor = Color.black;
		helperCam.clearFlags = CameraClearFlags.Color;
		helperCam.renderingPath = RenderingPath.Forward;
	}

	private static Matrix4x4 CalculateObliqueMatrix(Matrix4x4 projection, Vector4 clipPlane)
	{
		Vector4 b = projection.inverse * new Vector4(sgn(clipPlane.x), sgn(clipPlane.y), 1f, 1f);
		Vector4 vector = clipPlane * (2f / Vector4.Dot(clipPlane, b));
		projection[2] = vector.x - projection[3];
		projection[6] = vector.y - projection[7];
		projection[10] = vector.z - projection[11];
		projection[14] = vector.w - projection[15];
		return projection;
	}

	private static Matrix4x4 CalculateReflectionMatrix(Matrix4x4 reflectionMat, Vector4 plane)
	{
		reflectionMat.m00 = 1f - 2f * plane[0] * plane[0];
		reflectionMat.m01 = -2f * plane[0] * plane[1];
		reflectionMat.m02 = -2f * plane[0] * plane[2];
		reflectionMat.m03 = -2f * plane[3] * plane[0];
		reflectionMat.m10 = -2f * plane[1] * plane[0];
		reflectionMat.m11 = 1f - 2f * plane[1] * plane[1];
		reflectionMat.m12 = -2f * plane[1] * plane[2];
		reflectionMat.m13 = -2f * plane[3] * plane[1];
		reflectionMat.m20 = -2f * plane[2] * plane[0];
		reflectionMat.m21 = -2f * plane[2] * plane[1];
		reflectionMat.m22 = 1f - 2f * plane[2] * plane[2];
		reflectionMat.m23 = -2f * plane[3] * plane[2];
		reflectionMat.m30 = 0f;
		reflectionMat.m31 = 0f;
		reflectionMat.m32 = 0f;
		reflectionMat.m33 = 1f;
		return reflectionMat;
	}

	private static float sgn(float a)
	{
		if (a > 0f)
		{
			return 1f;
		}
		if (a < 0f)
		{
			return -1f;
		}
		return 0f;
	}

	private Vector4 CameraSpacePlane(Camera cam, Vector3 pos, Vector3 normal, float sideSign)
	{
		Vector3 point = pos + normal * clipPlaneOffset;
		Matrix4x4 worldToCameraMatrix = cam.worldToCameraMatrix;
		Vector3 lhs = worldToCameraMatrix.MultiplyPoint(point);
		Vector3 rhs = worldToCameraMatrix.MultiplyVector(normal).normalized * sideSign;
		return new Vector4(rhs.x, rhs.y, rhs.z, 0f - Vector3.Dot(lhs, rhs));
	}
}
[RequireComponent(typeof(WaterBase))]
[ExecuteInEditMode]
public class SpecularLighting : MonoBehaviour
{
	public Transform specularLight;

	private WaterBase waterBase;

	public void Start()
	{
		waterBase = (WaterBase)base.gameObject.GetComponent(typeof(WaterBase));
	}

	public void Update()
	{
		if (!waterBase)
		{
			waterBase = (WaterBase)base.gameObject.GetComponent(typeof(WaterBase));
		}
		if ((bool)specularLight && (bool)waterBase.sharedMaterial)
		{
			waterBase.sharedMaterial.SetVector("_WorldLightDir", specularLight.transform.forward);
		}
	}
}
public enum WaterQuality
{
	High = 2,
	Medium = 1,
	Low = 0
}
[ExecuteInEditMode]
public class WaterBase : MonoBehaviour
{
	public Material sharedMaterial;

	public WaterQuality waterQuality = WaterQuality.High;

	public bool edgeBlend = true;

	public void UpdateShader()
	{
		if (waterQuality > WaterQuality.Medium)
		{
			sharedMaterial.shader.maximumLOD = 501;
		}
		else if (waterQuality > WaterQuality.Low)
		{
			sharedMaterial.shader.maximumLOD = 301;
		}
		else
		{
			sharedMaterial.shader.maximumLOD = 201;
		}
		if (!SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.Depth))
		{
			edgeBlend = false;
		}
		if (edgeBlend)
		{
			Shader.EnableKeyword("WATER_EDGEBLEND_ON");
			Shader.DisableKeyword("WATER_EDGEBLEND_OFF");
			if ((bool)Camera.main)
			{
				Camera.main.depthTextureMode |= DepthTextureMode.Depth;
			}
		}
		else
		{
			Shader.EnableKeyword("WATER_EDGEBLEND_OFF");
			Shader.DisableKeyword("WATER_EDGEBLEND_ON");
		}
	}

	public void WaterTileBeingRendered(Transform tr, Camera currentCam)
	{
		if ((bool)currentCam && edgeBlend)
		{
			currentCam.depthTextureMode |= DepthTextureMode.Depth;
		}
	}

	public void Update()
	{
		if ((bool)sharedMaterial)
		{
			UpdateShader();
		}
	}
}
[ExecuteInEditMode]
public class WaterTile : MonoBehaviour
{
	public PlanarReflection reflection;

	public WaterBase waterBase;

	public void Start()
	{
		AcquireComponents();
	}

	private void AcquireComponents()
	{
		if (!reflection)
		{
			if ((bool)base.transform.parent)
			{
				reflection = base.transform.parent.GetComponent<PlanarReflection>();
			}
			else
			{
				reflection = base.transform.GetComponent<PlanarReflection>();
			}
		}
		if (!waterBase)
		{
			if ((bool)base.transform.parent)
			{
				waterBase = base.transform.parent.GetComponent<WaterBase>();
			}
			else
			{
				waterBase = base.transform.GetComponent<WaterBase>();
			}
		}
	}

	public void OnWillRenderObject()
	{
		if ((bool)reflection)
		{
			reflection.WaterTileBeingRendered(base.transform, Camera.current);
		}
		if ((bool)waterBase)
		{
			waterBase.WaterTileBeingRendered(base.transform, Camera.current);
		}
	}
}
public class CharacterBlood : MonoBehaviour
{
	public Material[] mat;

	public GameObject bloodFX;

	private bool startFade;

	private void Start()
	{
		for (int i = 0; i <= mat.Length - 1; i++)
		{
			mat[i].SetOverrideTag("RenderType", "");
			mat[i].SetInt("_SrcBlend", 1);
			mat[i].SetInt("_DstBlend", 0);
			mat[i].SetInt("_ZWrite", 1);
			mat[i].DisableKeyword("_ALPHATEST_ON");
			mat[i].DisableKeyword("_ALPHABLEND_ON");
			mat[i].DisableKeyword("_ALPHAPREMULTIPLY_ON");
			mat[i].renderQueue = -1;
			mat[i].SetColor("_Color", Color.gray);
			mat[i].SetColor("_SpecColor", Color.grey);
			mat[i].SetFloat("_Glossiness", 0.141f);
			mat[i].mainTexture = null;
		}
		bloodFX.SetActive(value: false);
	}

	private void Update()
	{
		if (Input.GetButtonDown("Fire1"))
		{
			for (int i = 0; i <= mat.Length - 1; i++)
			{
				mat[i].SetInt("_SrcBlend", 5);
				mat[i].SetInt("_DstBlend", 10);
				mat[i].EnableKeyword("_ALPHABLEND_ON");
				mat[i].DisableKeyword("_ALPHAPREMULTIPLY_ON");
				mat[i].SetInt("_ZWrite", 0);
				mat[i].DisableKeyword("_ALPHATEST_ON");
				mat[i].renderQueue = 3000;
				mat[i].SetFloat("_Mode", 2f);
				mat[i].SetColor("_Color", Color.red);
				mat[i].SetColor("_SpecColor", Color.red);
			}
			bloodFX.SetActive(value: true);
			startFade = true;
		}
		if (startFade)
		{
			FadeOut();
		}
	}

	private void FadeOut()
	{
		for (int i = 0; i <= mat.Length - 1; i++)
		{
			Color color = mat[i].color;
			if (color.a >= 0f)
			{
				color.a -= 0.1f;
				mat[i].color = color;
			}
		}
	}
}
public class CharacterFire : MonoBehaviour
{
	public Material[] mat;

	public GameObject fireFX;

	public Light ExplodeLight;

	private bool startFade;

	private float t;

	private float fadeStart = 4f;

	private float fadeEnd;

	private float fadeTime = 1f;

	private float pauseTime;

	private Color32 defaultCol;

	private void Start()
	{
		for (int i = 0; i <= mat.Length - 1; i++)
		{
			mat[i].SetOverrideTag("RenderType", "");
			mat[i].SetInt("_SrcBlend", 1);
			mat[i].SetInt("_DstBlend", 0);
			mat[i].SetInt("_ZWrite", 1);
			mat[i].DisableKeyword("_ALPHATEST_ON");
			mat[i].DisableKeyword("_ALPHABLEND_ON");
			mat[i].DisableKeyword("_ALPHAPREMULTIPLY_ON");
			mat[i].renderQueue = -1;
			mat[i].SetColor("_Color", Color.gray);
			mat[i].SetColor("_SpecColor", Color.grey);
			mat[i].SetFloat("_Glossiness", 0.141f);
			mat[i].mainTexture = null;
		}
		fireFX.SetActive(value: false);
	}

	private void Update()
	{
		if (Input.GetButtonDown("Fire1"))
		{
			for (int i = 0; i <= mat.Length - 1; i++)
			{
				mat[i].SetInt("_SrcBlend", 5);
				mat[i].SetInt("_DstBlend", 10);
				mat[i].EnableKeyword("_ALPHABLEND_ON");
				mat[i].DisableKeyword("_ALPHAPREMULTIPLY_ON");
				mat[i].SetInt("_ZWrite", 0);
				mat[i].DisableKeyword("_ALPHATEST_ON");
				mat[i].renderQueue = 3000;
				mat[i].SetFloat("_Mode", 2f);
			}
			StartCoroutine("FadeLight");
			startFade = true;
			fireFX.SetActive(value: true);
		}
		if (startFade)
		{
			FadeOut();
		}
	}

	private void FadeOut()
	{
		for (int i = 0; i <= mat.Length - 1; i++)
		{
			Color color = mat[i].color;
			if (color.a >= 0f)
			{
				color.a -= 0.05f;
				mat[i].color = color;
			}
		}
	}

	private IEnumerator FadeLight()
	{
		while (t < fadeTime)
		{
			if (pauseTime == 0f)
			{
				t += Time.deltaTime;
			}
			ExplodeLight.intensity = Mathf.Lerp(fadeStart, fadeEnd, t / fadeTime);
			yield return 0;
		}
		t = 0f;
	}
}
public class CharacterIce : MonoBehaviour
{
	public float frozenWaitTime;

	public Material[] mat;

	public GameObject freezeFX;

	public GameObject shatterFX;

	public Light freezeLight;

	public GameObject rootNode;

	public GameObject characterSkeleton;

	public Texture iceTexture;

	private bool startFade;

	private float t;

	private float fadeStart = 4f;

	private float fadeEnd;

	private float fadeTime = 1f;

	private float pauseTime;

	private bool freezeWait;

	private void Start()
	{
		for (int i = 0; i <= mat.Length - 1; i++)
		{
			mat[i].SetOverrideTag("RenderType", "");
			mat[i].SetInt("_SrcBlend", 1);
			mat[i].SetInt("_DstBlend", 0);
			mat[i].SetInt("_ZWrite", 1);
			mat[i].DisableKeyword("_ALPHATEST_ON");
			mat[i].DisableKeyword("_ALPHABLEND_ON");
			mat[i].DisableKeyword("_ALPHAPREMULTIPLY_ON");
			mat[i].renderQueue = -1;
			mat[i].SetColor("_Color", Color.gray);
			mat[i].SetColor("_SpecColor", Color.grey);
			mat[i].SetFloat("_Glossiness", 0.141f);
			mat[i].mainTexture = null;
		}
		freezeFX.SetActive(value: false);
		shatterFX.SetActive(value: false);
	}

	private void Update()
	{
		if (Input.GetButtonDown("Fire1"))
		{
			freezeFX.SetActive(value: true);
			for (int i = 0; i <= mat.Length - 1; i++)
			{
				mat[i].SetInt("_SrcBlend", 5);
				mat[i].SetInt("_DstBlend", 10);
				mat[i].EnableKeyword("_ALPHABLEND_ON");
				mat[i].DisableKeyword("_ALPHAPREMULTIPLY_ON");
				mat[i].SetInt("_ZWrite", 0);
				mat[i].DisableKeyword("_ALPHATEST_ON");
				mat[i].renderQueue = 3000;
				mat[i].SetFloat("_Mode", 2f);
				mat[i].SetColor("_Color", Color.white);
				mat[i].SetFloat("_Glossiness", 0.842f);
				mat[i].mainTexture = iceTexture;
			}
			rootNode.GetComponent<Animator>().enabled = false;
			GetComponent<Rigidbody>().constraints = RigidbodyConstraints.FreezePositionX;
			GetComponent<Rigidbody>().constraints = RigidbodyConstraints.FreezePositionY;
			GetComponent<Rigidbody>().constraints = RigidbodyConstraints.FreezePositionZ;
			characterSkeleton.transform.parent = null;
			StartCoroutine("FreezeWait");
			startFade = true;
		}
		if (startFade && freezeWait)
		{
			FadeOut();
		}
	}

	private IEnumerator FreezeWait()
	{
		yield return new WaitForSeconds(frozenWaitTime);
		freezeWait = true;
		GetComponent<Rigidbody>().detectCollisions = false;
		freezeLight.transform.parent = null;
		StartCoroutine("FadeLight");
		shatterFX.SetActive(value: true);
	}

	private void FadeOut()
	{
		for (int i = 0; i <= mat.Length - 1; i++)
		{
			Color color = mat[i].color;
			if (color.a >= 0f)
			{
				color.a -= 0.5f;
				mat[i].color = color;
			}
		}
	}

	private IEnumerator FadeLight()
	{
		while (t < fadeTime)
		{
			if (pauseTime == 0f)
			{
				t += Time.deltaTime;
			}
			freezeLight.intensity = Mathf.Lerp(fadeStart, fadeEnd, t / fadeTime);
			yield return 0;
		}
		t = 0f;
	}
}
public class CUI_CameraRotationOnButtonHeld : MonoBehaviour
{
	[SerializeField]
	private float Sensitivity = 0.5f;

	private Vector3 oldMousePos;

	private bool move = true;

	private void Start()
	{
		oldMousePos = Input.mousePosition;
	}
}
public class CUI_MoveAlong : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
		(base.transform as RectTransform).anchoredPosition = new Vector2((base.transform as RectTransform).anchoredPosition.x + (base.transform as RectTransform).anchoredPosition.x / 100f, (base.transform as RectTransform).anchoredPosition.y);
		if ((base.transform as RectTransform).anchoredPosition.x > (base.transform.parent as RectTransform).rect.width)
		{
			(base.transform as RectTransform).anchoredPosition = new Vector2(20f, (base.transform as RectTransform).anchoredPosition.y);
		}
	}
}
public class CUI_MoveHeartbeat : MonoBehaviour
{
	public float speed;

	public bool wrapAroundParent = true;

	private RectTransform rectie;

	private RectTransform parentRectie;

	private void Start()
	{
		rectie = base.transform as RectTransform;
		parentRectie = base.transform.parent as RectTransform;
	}

	private void Update()
	{
		rectie.anchoredPosition = new Vector2(rectie.anchoredPosition.x - speed * Time.deltaTime, rectie.anchoredPosition.y);
		if (wrapAroundParent && rectie.anchoredPosition.x + rectie.rect.width < 0f)
		{
			rectie.anchoredPosition = new Vector2(parentRectie.rect.width, rectie.anchoredPosition.y);
		}
	}
}
public class CUI_ShowParentCoordinates : MonoBehaviour
{
	private void Start()
	{
		GetComponent<Text>().text = base.transform.parent.GetComponent<RectTransform>().anchoredPosition.ToString();
	}

	private void Update()
	{
	}
}
public class CUI_rotation_anim : MonoBehaviour
{
	public Vector3 Rotation;

	private void Start()
	{
	}

	private void Update()
	{
		base.transform.RotateAround(base.transform.position, base.transform.up, Rotation.y * Time.deltaTime);
		base.transform.RotateAround(base.transform.position, base.transform.right, Rotation.x * Time.deltaTime);
		base.transform.RotateAround(base.transform.position, base.transform.forward, Rotation.z * Time.deltaTime);
	}
}
public class CUI_touchpad : MonoBehaviour
{
	private RectTransform container;

	[SerializeField]
	private RectTransform dot;

	private void Awake()
	{
		container = base.transform as RectTransform;
	}

	private void MoveDotOnTouchpadAxisChanged(object o, ViveInputArgs args)
	{
		dot.anchoredPosition = new Vector2(args.touchpadAxis.x * container.rect.width * 0.5f, args.touchpadAxis.y * container.rect.width * 0.5f);
	}
}
public class RandomMaterial : MonoBehaviour
{
	public Renderer targetRenderer;

	public Material[] materials;

	public void Start()
	{
		ChangeMaterial();
	}

	public void ChangeMaterial()
	{
		targetRenderer.sharedMaterial = materials[UnityEngine.Random.Range(0, materials.Length)];
	}
}
public class UnluckDistanceDisabler : MonoBehaviour
{
	public int _distanceDisable = 1000;

	public Transform _distanceFrom;

	public bool _distanceFromMainCam;

	public float _disableCheckInterval = 10f;

	public float _enableCheckInterval = 1f;

	public bool _disableOnStart;

	public void Start()
	{
		if (_distanceFromMainCam)
		{
			_distanceFrom = Camera.main.transform;
		}
		InvokeRepeating("CheckDisable", _disableCheckInterval + UnityEngine.Random.value * _disableCheckInterval, _disableCheckInterval);
		InvokeRepeating("CheckEnable", _enableCheckInterval + UnityEngine.Random.value * _enableCheckInterval, _enableCheckInterval);
		Invoke("DisableOnStart", 0.01f);
	}

	public void DisableOnStart()
	{
		if (_disableOnStart)
		{
			base.gameObject.SetActive(value: false);
		}
	}

	public void CheckDisable()
	{
		if (base.gameObject.activeInHierarchy && (base.transform.position - _distanceFrom.position).sqrMagnitude > (float)(_distanceDisable * _distanceDisable))
		{
			base.gameObject.SetActive(value: false);
		}
	}

	public void CheckEnable()
	{
		if (!base.gameObject.activeInHierarchy && (base.transform.position - _distanceFrom.position).sqrMagnitude < (float)(_distanceDisable * _distanceDisable))
		{
			base.gameObject.SetActive(value: true);
		}
	}
}
public class LookAtCamera : MonoBehaviour
{
	public Camera lookAtCamera;

	public bool lookOnlyOnAwake;

	public void Start()
	{
		if (lookAtCamera == null)
		{
			lookAtCamera = Camera.main;
		}
		if (lookOnlyOnAwake)
		{
			LookCam();
		}
	}

	public void Update()
	{
		if (!lookOnlyOnAwake)
		{
			LookCam();
		}
	}

	public void LookCam()
	{
		base.transform.LookAt(lookAtCamera.transform);
	}
}
[AddComponentMenu("Camera-Control/Smooth Mouse Orbit - Unluck Software")]
public class SmoothCameraOrbit : MonoBehaviour
{
	public Transform target;

	public Vector3 targetOffset;

	public float distance = 5f;

	public float maxDistance = 20f;

	public float minDistance = 0.6f;

	public float xSpeed = 200f;

	public float ySpeed = 200f;

	public int yMinLimit = -80;

	public int yMaxLimit = 80;

	public int zoomRate = 40;

	public float panSpeed = 0.3f;

	public float zoomDampening = 5f;

	public float autoRotate = 1f;

	public float autoRotateSpeed = 0.1f;

	private float xDeg;

	private float yDeg;

	private float currentDistance;

	private float desiredDistance;

	private Quaternion currentRotation;

	private Quaternion desiredRotation;

	private Quaternion rotation;

	private Vector3 position;

	private float idleTimer;

	private float idleSmooth;

	private void Start()
	{
		Init();
	}

	private void OnEnable()
	{
		Init();
	}

	public void Init()
	{
		if (!target)
		{
			GameObject gameObject = new GameObject("Cam Target");
			gameObject.transform.position = base.transform.position + base.transform.forward * distance;
			target = gameObject.transform;
		}
		currentDistance = distance;
		desiredDistance = distance;
		position = base.transform.position;
		rotation = base.transform.rotation;
		currentRotation = base.transform.rotation;
		desiredRotation = base.transform.rotation;
		xDeg = Vector3.Angle(Vector3.right, base.transform.right);
		yDeg = Vector3.Angle(Vector3.up, base.transform.up);
		position = target.position - (rotation * Vector3.forward * currentDistance + targetOffset);
	}

	private void LateUpdate()
	{
		if (Input.GetMouseButton(2) && Input.GetKey(KeyCode.LeftAlt) && Input.GetKey(KeyCode.LeftControl))
		{
			desiredDistance -= Input.GetAxis("Mouse Y") * 0.02f * (float)zoomRate * 0.125f * Mathf.Abs(desiredDistance);
		}
		else if (Input.GetMouseButton(0))
		{
			xDeg += Input.GetAxis("Mouse X") * xSpeed * 0.02f;
			yDeg -= Input.GetAxis("Mouse Y") * ySpeed * 0.02f;
			yDeg = ClampAngle(yDeg, yMinLimit, yMaxLimit);
			desiredRotation = Quaternion.Euler(yDeg, xDeg, 0f);
			currentRotation = base.transform.rotation;
			rotation = Quaternion.Lerp(currentRotation, desiredRotation, 0.02f * zoomDampening);
			base.transform.rotation = rotation;
			idleTimer = 0f;
			idleSmooth = 0f;
		}
		else
		{
			idleTimer += 0.02f;
			if (idleTimer > autoRotate && autoRotate > 0f)
			{
				idleSmooth += (0.02f + idleSmooth) * 0.005f;
				idleSmooth = Mathf.Clamp(idleSmooth, 0f, 1f);
				xDeg += xSpeed * Time.deltaTime * idleSmooth * autoRotateSpeed;
			}
			yDeg = ClampAngle(yDeg, yMinLimit, yMaxLimit);
			desiredRotation = Quaternion.Euler(yDeg, xDeg, 0f);
			currentRotation = base.transform.rotation;
			rotation = Quaternion.Lerp(currentRotation, desiredRotation, 0.02f * zoomDampening * 2f);
			base.transform.rotation = rotation;
		}
		desiredDistance -= Input.GetAxis("Mouse ScrollWheel") * 0.02f * (float)zoomRate * Mathf.Abs(desiredDistance);
		desiredDistance = Mathf.Clamp(desiredDistance, minDistance, maxDistance);
		currentDistance = Mathf.Lerp(currentDistance, desiredDistance, 0.02f * zoomDampening);
		position = target.position - (rotation * Vector3.forward * currentDistance + targetOffset);
		base.transform.position = position;
	}

	private static float ClampAngle(float angle, float min, float max)
	{
		if (angle < -360f)
		{
			angle += 360f;
		}
		if (angle > 360f)
		{
			angle -= 360f;
		}
		return Mathf.Clamp(angle, min, max);
	}
}
public class FlockChild : MonoBehaviour
{
	[HideInInspector]
	public FlockController _spawner;

	[HideInInspector]
	public Vector3 _wayPoint;

	public float _speed;

	[HideInInspector]
	public bool _dived = true;

	[HideInInspector]
	public float _stuckCounter;

	[HideInInspector]
	public float _damping;

	[HideInInspector]
	public bool _soar = true;

	[HideInInspector]
	public bool _landing;

	[HideInInspector]
	public float _targetSpeed;

	[HideInInspector]
	public bool _move = true;

	public GameObject _model;

	public Transform _modelT;

	[HideInInspector]
	public float _avoidValue;

	[HideInInspector]
	public float _avoidDistance;

	private float _soarTimer;

	private bool _instantiated;

	private static int _updateNextSeed;

	private int _updateSeed = -1;

	[HideInInspector]
	public bool _avoid = true;

	public Transform _thisT;

	public Vector3 _landingPosOffset;

	public void Start()
	{
		FindRequiredComponents();
		Wander(0f);
		SetRandomScale();
		_thisT.position = findWaypoint();
		RandomizeStartAnimationFrame();
		InitAvoidanceValues();
		_speed = _spawner._minSpeed;
		_spawner._activeChildren += 1f;
		_instantiated = true;
		if (_spawner._updateDivisor > 1)
		{
			int num = _spawner._updateDivisor - 1;
			_updateNextSeed++;
			_updateSeed = _updateNextSeed;
			_updateNextSeed %= num;
		}
	}

	public void Update()
	{
		if (_spawner._updateDivisor <= 1 || _spawner._updateCounter == _updateSeed)
		{
			SoarTimeLimit();
			CheckForDistanceToWaypoint();
			RotationBasedOnWaypointOrAvoidance();
			LimitRotationOfModel();
		}
	}

	public void OnDisable()
	{
		CancelInvoke();
		_spawner._activeChildren -= 1f;
	}

	public void OnEnable()
	{
		if (_instantiated)
		{
			_spawner._activeChildren += 1f;
			if (_landing)
			{
				_model.GetComponent<Animation>().Play(_spawner._idleAnimation);
			}
			else
			{
				_model.GetComponent<Animation>().Play(_spawner._flapAnimation);
			}
		}
	}

	public void FindRequiredComponents()
	{
		if (_thisT == null)
		{
			_thisT = base.transform;
		}
		if (_model == null)
		{
			_model = _thisT.Find("Model").gameObject;
		}
		if (_modelT == null)
		{
			_modelT = _model.transform;
		}
	}

	public void RandomizeStartAnimationFrame()
	{
		foreach (AnimationState item in _model.GetComponent<Animation>())
		{
			item.time = UnityEngine.Random.value * item.length;
		}
	}

	public void InitAvoidanceValues()
	{
		_avoidValue = UnityEngine.Random.Range(0.3f, 0.1f);
		if (_spawner._birdAvoidDistanceMax != _spawner._birdAvoidDistanceMin)
		{
			_avoidDistance = UnityEngine.Random.Range(_spawner._birdAvoidDistanceMax, _spawner._birdAvoidDistanceMin);
		}
		else
		{
			_avoidDistance = _spawner._birdAvoidDistanceMin;
		}
	}

	public void SetRandomScale()
	{
		float num = UnityEngine.Random.Range(_spawner._minScale, _spawner._maxScale);
		_thisT.localScale = new Vector3(num, num, num);
	}

	public void SoarTimeLimit()
	{
		if (_soar && _spawner._soarMaxTime > 0f)
		{
			if (_soarTimer > _spawner._soarMaxTime)
			{
				Flap();
				_soarTimer = 0f;
			}
			else
			{
				_soarTimer += _spawner._newDelta;
			}
		}
	}

	public void CheckForDistanceToWaypoint()
	{
		if (!_landing && (_thisT.position - _wayPoint).magnitude < _spawner._waypointDistance + _stuckCounter)
		{
			Wander(0f);
			_stuckCounter = 0f;
		}
		else if (!_landing)
		{
			_stuckCounter += _spawner._newDelta;
		}
		else
		{
			_stuckCounter = 0f;
		}
	}

	public void RotationBasedOnWaypointOrAvoidance()
	{
		Vector3 vector = _wayPoint - _thisT.position;
		if (_targetSpeed > -1f && vector != Vector3.zero)
		{
			Quaternion b = Quaternion.LookRotation(vector);
			_thisT.rotation = Quaternion.Slerp(_thisT.rotation, b, _spawner._newDelta * _damping);
		}
		if (_spawner._childTriggerPos && (_thisT.position - _spawner._posBuffer).magnitude < 1f)
		{
			_spawner.SetFlockRandomPosition();
		}
		_speed = Mathf.Lerp(_speed, _targetSpeed, _spawner._newDelta * 2.5f);
		if (_move)
		{
			_thisT.position += _thisT.forward * _speed * _spawner._newDelta;
			if (_avoid && _spawner._birdAvoid)
			{
				Avoidance();
			}
		}
	}

	public bool Avoidance()
	{
		RaycastHit hitInfo = default(RaycastHit);
		Vector3 forward = _modelT.forward;
		bool result = false;
		Quaternion identity = Quaternion.identity;
		Vector3 zero = Vector3.zero;
		Vector3 zero2 = Vector3.zero;
		zero2 = _thisT.position;
		identity = _thisT.rotation;
		zero = _thisT.rotation.eulerAngles;
		if (Physics.Raycast(_thisT.position, forward + _modelT.right * _avoidValue, out hitInfo, _avoidDistance, _spawner._avoidanceMask))
		{
			zero.y -= (float)_spawner._birdAvoidHorizontalForce * _spawner._newDelta * _damping;
			identity.eulerAngles = zero;
			_thisT.rotation = identity;
			result = true;
		}
		else if (Physics.Raycast(_thisT.position, forward + _modelT.right * (0f - _avoidValue), out hitInfo, _avoidDistance, _spawner._avoidanceMask))
		{
			zero.y += (float)_spawner._birdAvoidHorizontalForce * _spawner._newDelta * _damping;
			identity.eulerAngles = zero;
			_thisT.rotation = identity;
			result = true;
		}
		if (_spawner._birdAvoidDown && !_landing && Physics.Raycast(_thisT.position, -Vector3.up, out hitInfo, _avoidDistance, _spawner._avoidanceMask))
		{
			zero.x -= (float)_spawner._birdAvoidVerticalForce * _spawner._newDelta * _damping;
			identity.eulerAngles = zero;
			_thisT.rotation = identity;
			zero2.y += (float)_spawner._birdAvoidVerticalForce * _spawner._newDelta * 0.01f;
			_thisT.position = zero2;
			result = true;
		}
		else if (_spawner._birdAvoidUp && !_landing && Physics.Raycast(_thisT.position, Vector3.up, out hitInfo, _avoidDistance, _spawner._avoidanceMask))
		{
			zero.x += (float)_spawner._birdAvoidVerticalForce * _spawner._newDelta * _damping;
			identity.eulerAngles = zero;
			_thisT.rotation = identity;
			zero2.y -= (float)_spawner._birdAvoidVerticalForce * _spawner._newDelta * 0.01f;
			_thisT.position = zero2;
			result = true;
		}
		return result;
	}

	public void LimitRotationOfModel()
	{
		Quaternion identity = Quaternion.identity;
		Vector3 zero = Vector3.zero;
		identity = _modelT.localRotation;
		zero = identity.eulerAngles;
		if ((((_soar && _spawner._flatSoar) || (_spawner._flatFly && !_soar)) && _wayPoint.y > _thisT.position.y) || _landing)
		{
			zero.x = Mathf.LerpAngle(_modelT.localEulerAngles.x, 0f - _thisT.localEulerAngles.x, _spawner._newDelta * 1.75f);
			identity.eulerAngles = zero;
			_modelT.localRotation = identity;
		}
		else
		{
			zero.x = Mathf.LerpAngle(_modelT.localEulerAngles.x, 0f, _spawner._newDelta * 1.75f);
			identity.eulerAngles = zero;
			_modelT.localRotation = identity;
		}
	}

	public void Wander(float delay)
	{
		if (!_landing)
		{
			_damping = UnityEngine.Random.Range(_spawner._minDamping, _spawner._maxDamping);
			_targetSpeed = UnityEngine.Random.Range(_spawner._minSpeed, _spawner._maxSpeed);
			Invoke("SetRandomMode", delay);
		}
	}

	public void SetRandomMode()
	{
		CancelInvoke("SetRandomMode");
		if (!_dived && UnityEngine.Random.value < _spawner._soarFrequency)
		{
			Soar();
		}
		else if (!_dived && UnityEngine.Random.value < _spawner._diveFrequency)
		{
			Dive();
		}
		else
		{
			Flap();
		}
	}

	public void Flap()
	{
		if (_move)
		{
			if (_model != null)
			{
				_model.GetComponent<Animation>().CrossFade(_spawner._flapAnimation, 0.5f);
			}
			_soar = false;
			animationSpeed();
			_wayPoint = findWaypoint();
			_dived = false;
		}
	}

	public Vector3 findWaypoint()
	{
		Vector3 zero = Vector3.zero;
		zero.x = UnityEngine.Random.Range(0f - _spawner._spawnSphere, _spawner._spawnSphere) + _spawner._posBuffer.x;
		zero.z = UnityEngine.Random.Range(0f - _spawner._spawnSphereDepth, _spawner._spawnSphereDepth) + _spawner._posBuffer.z;
		zero.y = UnityEngine.Random.Range(0f - _spawner._spawnSphereHeight, _spawner._spawnSphereHeight) + _spawner._posBuffer.y;
		return zero;
	}

	public void Soar()
	{
		if (_move)
		{
			_model.GetComponent<Animation>().CrossFade(_spawner._soarAnimation, 1.5f);
			_wayPoint = findWaypoint();
			_soar = true;
		}
	}

	public void Dive()
	{
		if (_spawner._soarAnimation != null)
		{
			_model.GetComponent<Animation>().CrossFade(_spawner._soarAnimation, 1.5f);
		}
		else
		{
			foreach (AnimationState item in _model.GetComponent<Animation>())
			{
				if (_thisT.position.y < _wayPoint.y + 25f)
				{
					item.speed = 0.1f;
				}
			}
		}
		_wayPoint = findWaypoint();
		_wayPoint.y -= _spawner._diveValue;
		_dived = true;
	}

	public void animationSpeed()
	{
		foreach (AnimationState item in _model.GetComponent<Animation>())
		{
			if (!_dived && !_landing)
			{
				item.speed = UnityEngine.Random.Range(_spawner._minAnimationSpeed, _spawner._maxAnimationSpeed);
			}
			else
			{
				item.speed = _spawner._maxAnimationSpeed;
			}
		}
	}
}
[RequireComponent(typeof(AudioSource))]
public class FlockChildSound : MonoBehaviour
{
	public AudioClip[] _idleSounds;

	public float _idleSoundRandomChance = 0.05f;

	public AudioClip[] _flightSounds;

	public float _flightSoundRandomChance = 0.05f;

	public AudioClip[] _scareSounds;

	public float _pitchMin = 0.85f;

	public float _pitchMax = 1f;

	public float _volumeMin = 0.6f;

	public float _volumeMax = 0.8f;

	private FlockChild _flockChild;

	private AudioSource _audio;

	private bool _hasLanded;

	public void Start()
	{
		_flockChild = GetComponent<FlockChild>();
		_audio = GetComponent<AudioSource>();
		InvokeRepeating("PlayRandomSound", UnityEngine.Random.value + 1f, 1f);
		if (_scareSounds.Length != 0)
		{
			InvokeRepeating("ScareSound", 1f, 0.01f);
		}
	}

	public void PlayRandomSound()
	{
		if (base.gameObject.activeInHierarchy)
		{
			if (!_audio.isPlaying && _flightSounds.Length != 0 && _flightSoundRandomChance > UnityEngine.Random.value && !_flockChild._landing)
			{
				_audio.clip = _flightSounds[UnityEngine.Random.Range(0, _flightSounds.Length)];
				_audio.pitch = UnityEngine.Random.Range(_pitchMin, _pitchMax);
				_audio.volume = UnityEngine.Random.Range(_volumeMin, _volumeMax);
				_audio.Play();
			}
			else if (!_audio.isPlaying && _idleSounds.Length != 0 && _idleSoundRandomChance > UnityEngine.Random.value && _flockChild._landing)
			{
				_audio.clip = _idleSounds[UnityEngine.Random.Range(0, _idleSounds.Length)];
				_audio.pitch = UnityEngine.Random.Range(_pitchMin, _pitchMax);
				_audio.volume = UnityEngine.Random.Range(_volumeMin, _volumeMax);
				_audio.Play();
				_hasLanded = true;
			}
		}
	}

	public void ScareSound()
	{
		if (base.gameObject.activeInHierarchy && _hasLanded && !_flockChild._landing && _idleSoundRandomChance * 2f > UnityEngine.Random.value)
		{
			_audio.clip = _scareSounds[UnityEngine.Random.Range(0, _scareSounds.Length)];
			_audio.volume = UnityEngine.Random.Range(_volumeMin, _volumeMax);
			_audio.PlayDelayed(UnityEngine.Random.value * 0.2f);
			_hasLanded = false;
		}
	}
}
public class FlockController : MonoBehaviour
{
	public FlockChild _childPrefab;

	public int _childAmount = 250;

	public bool _slowSpawn;

	public float _spawnSphere = 3f;

	public float _spawnSphereHeight = 3f;

	public float _spawnSphereDepth = -1f;

	public float _minSpeed = 6f;

	public float _maxSpeed = 10f;

	public float _minScale = 0.7f;

	public float _maxScale = 1f;

	public float _soarFrequency;

	public string _soarAnimation = "Soar";

	public string _flapAnimation = "Flap";

	public string _idleAnimation = "Idle";

	public float _diveValue = 7f;

	public float _diveFrequency = 0.5f;

	public float _minDamping = 1f;

	public float _maxDamping = 2f;

	public float _waypointDistance = 1f;

	public float _minAnimationSpeed = 2f;

	public float _maxAnimationSpeed = 4f;

	public float _randomPositionTimer = 10f;

	public float _positionSphere = 25f;

	public float _positionSphereHeight = 25f;

	public float _positionSphereDepth = -1f;

	public bool _childTriggerPos;

	public bool _forceChildWaypoints;

	public float _forcedRandomDelay = 1.5f;

	public bool _flatFly;

	public bool _flatSoar;

	public bool _birdAvoid;

	public int _birdAvoidHorizontalForce = 1000;

	public bool _birdAvoidDown;

	public bool _birdAvoidUp;

	public int _birdAvoidVerticalForce = 300;

	public float _birdAvoidDistanceMax = 4.5f;

	public float _birdAvoidDistanceMin = 5f;

	public float _soarMaxTime;

	public LayerMask _avoidanceMask = -1;

	public List<FlockChild> _roamers;

	public Vector3 _posBuffer;

	public int _updateDivisor = 1;

	public float _newDelta;

	public int _updateCounter;

	public float _activeChildren;

	public bool _groupChildToNewTransform;

	public Transform _groupTransform;

	public string _groupName = "";

	public bool _groupChildToFlock;

	public Vector3 _startPosOffset;

	public Transform _thisT;

	public void Start()
	{
		_thisT = base.transform;
		if (_positionSphereDepth == -1f)
		{
			_positionSphereDepth = _positionSphere;
		}
		if (_spawnSphereDepth == -1f)
		{
			_spawnSphereDepth = _spawnSphere;
		}
		_posBuffer = _thisT.position + _startPosOffset;
		if (!_slowSpawn)
		{
			AddChild(_childAmount);
		}
		if (_randomPositionTimer > 0f)
		{
			InvokeRepeating("SetFlockRandomPosition", _randomPositionTimer, _randomPositionTimer);
		}
	}

	public void AddChild(int amount)
	{
		if (_groupChildToNewTransform)
		{
			InstantiateGroup();
		}
		for (int i = 0; i < amount; i++)
		{
			FlockChild flockChild = UnityEngine.Object.Instantiate(_childPrefab);
			flockChild._spawner = this;
			_roamers.Add(flockChild);
			AddChildToParent(flockChild.transform);
		}
	}

	public void AddChildToParent(Transform obj)
	{
		if (_groupChildToFlock)
		{
			obj.parent = base.transform;
		}
		else if (_groupChildToNewTransform)
		{
			obj.parent = _groupTransform;
		}
	}

	public void RemoveChild(int amount)
	{
		for (int i = 0; i < amount; i++)
		{
			FlockChild flockChild = _roamers[_roamers.Count - 1];
			_roamers.RemoveAt(_roamers.Count - 1);
			UnityEngine.Object.Destroy(flockChild.gameObject);
		}
	}

	public void Update()
	{
		if (_activeChildren > 0f)
		{
			if (_updateDivisor > 1)
			{
				_updateCounter++;
				_updateCounter %= _updateDivisor;
				_newDelta = Time.deltaTime * (float)_updateDivisor;
			}
			else
			{
				_newDelta = Time.deltaTime;
			}
		}
		UpdateChildAmount();
	}

	public void InstantiateGroup()
	{
		if (!(_groupTransform != null))
		{
			GameObject gameObject = new GameObject();
			_groupTransform = gameObject.transform;
			_groupTransform.position = _thisT.position;
			if (_groupName != "")
			{
				gameObject.name = _groupName;
			}
			else
			{
				gameObject.name = _thisT.name + " Fish Container";
			}
		}
	}

	public void UpdateChildAmount()
	{
		if (_childAmount >= 0 && _childAmount < _roamers.Count)
		{
			RemoveChild(1);
		}
		else if (_childAmount > _roamers.Count)
		{
			AddChild(1);
		}
	}

	public void OnDrawGizmos()
	{
		if (_thisT == null)
		{
			_thisT = base.transform;
		}
		if (!Application.isPlaying && _posBuffer != _thisT.position + _startPosOffset)
		{
			_posBuffer = _thisT.position + _startPosOffset;
		}
		if (_positionSphereDepth == -1f)
		{
			_positionSphereDepth = _positionSphere;
		}
		if (_spawnSphereDepth == -1f)
		{
			_spawnSphereDepth = _spawnSphere;
		}
		Gizmos.color = Color.blue;
		Gizmos.DrawWireCube(_posBuffer, new Vector3(_spawnSphere * 2f, _spawnSphereHeight * 2f, _spawnSphereDepth * 2f));
		Gizmos.color = Color.cyan;
		Gizmos.DrawWireCube(_thisT.position, new Vector3(_positionSphere * 2f + _spawnSphere * 2f, _positionSphereHeight * 2f + _spawnSphereHeight * 2f, _positionSphereDepth * 2f + _spawnSphereDepth * 2f));
	}

	public void SetFlockRandomPosition()
	{
		Vector3 zero = Vector3.zero;
		zero.x = UnityEngine.Random.Range(0f - _positionSphere, _positionSphere) + _thisT.position.x;
		zero.z = UnityEngine.Random.Range(0f - _positionSphereDepth, _positionSphereDepth) + _thisT.position.z;
		zero.y = UnityEngine.Random.Range(0f - _positionSphereHeight, _positionSphereHeight) + _thisT.position.y;
		_posBuffer = zero;
		if (_forceChildWaypoints)
		{
			for (int i = 0; i < _roamers.Count; i++)
			{
				_roamers[i].Wander(UnityEngine.Random.value * _forcedRandomDelay);
			}
		}
	}

	public void destroyBirds()
	{
		for (int i = 0; i < _roamers.Count; i++)
		{
			UnityEngine.Object.Destroy(_roamers[i].gameObject);
		}
		_childAmount = 0;
		_roamers.Clear();
	}
}
public class FlockScare : MonoBehaviour
{
	public LandingSpotController[] landingSpotControllers;

	public float scareInterval = 0.1f;

	public float distanceToScare = 2f;

	public int checkEveryNthLandingSpot = 1;

	public int InvokeAmounts = 1;

	private int lsc;

	private int ls;

	private LandingSpotController currentController;

	private void CheckProximityToLandingSpots()
	{
		IterateLandingSpots();
		if (currentController._activeLandingSpots > 0 && CheckDistanceToLandingSpot(landingSpotControllers[lsc]))
		{
			landingSpotControllers[lsc].ScareAll();
		}
		Invoke("CheckProximityToLandingSpots", scareInterval);
	}

	private void IterateLandingSpots()
	{
		ls += checkEveryNthLandingSpot;
		currentController = landingSpotControllers[lsc];
		int childCount = currentController.transform.childCount;
		if (ls > childCount - 1)
		{
			ls -= childCount;
			if (lsc < landingSpotControllers.Length - 1)
			{
				lsc++;
			}
			else
			{
				lsc = 0;
			}
		}
	}

	private bool CheckDistanceToLandingSpot(LandingSpotController lc)
	{
		Transform child = lc.transform.GetChild(ls);
		if (child.GetComponent<LandingSpot>().landingChild != null && (child.position - base.transform.position).sqrMagnitude < distanceToScare * distanceToScare)
		{
			return true;
		}
		return false;
	}

	private void Invoker()
	{
		for (int i = 0; i < InvokeAmounts; i++)
		{
			float num = scareInterval / (float)InvokeAmounts * (float)i;
			Invoke("CheckProximityToLandingSpots", scareInterval + num);
		}
	}

	private void OnEnable()
	{
		CancelInvoke("CheckProximityToLandingSpots");
		if (landingSpotControllers.Length != 0)
		{
			Invoker();
		}
	}

	private void OnDisable()
	{
		CancelInvoke("CheckProximityToLandingSpots");
	}
}
public class FlockWaypointTrigger : MonoBehaviour
{
	public float _timer = 1f;

	public FlockChild _flockChild;

	public void Start()
	{
		if (_flockChild == null)
		{
			_flockChild = base.transform.parent.GetComponent<FlockChild>();
		}
		float num = UnityEngine.Random.Range(_timer, _timer * 3f);
		InvokeRepeating("Trigger", num, num);
	}

	public void Trigger()
	{
		_flockChild.Wander(0f);
	}
}
public class LandingButtons : MonoBehaviour
{
	public LandingSpotController _landingSpotController;

	public FlockController _flockController;

	public float hSliderValue = 250f;

	public void OnGUI()
	{
		GUI.Label(new Rect(20f, 20f, 125f, 18f), "Landing Spots: " + _landingSpotController.transform.childCount);
		if (GUI.Button(new Rect(20f, 40f, 125f, 18f), "Scare All"))
		{
			_landingSpotController.ScareAll();
		}
		if (GUI.Button(new Rect(20f, 60f, 125f, 18f), "Land In Reach"))
		{
			_landingSpotController.LandAll();
		}
		if (GUI.Button(new Rect(20f, 80f, 125f, 18f), "Land Instant"))
		{
			StartCoroutine(_landingSpotController.InstantLand(0.01f));
		}
		if (GUI.Button(new Rect(20f, 100f, 125f, 18f), "Destroy"))
		{
			_flockController.destroyBirds();
		}
		GUI.Label(new Rect(20f, 120f, 125f, 18f), "Bird Amount: " + _flockController._childAmount);
		_flockController._childAmount = (int)GUI.HorizontalSlider(new Rect(20f, 140f, 125f, 18f), _flockController._childAmount, 0f, 250f);
	}
}
public class LandingSpot : MonoBehaviour
{
	[HideInInspector]
	public FlockChild landingChild;

	[HideInInspector]
	public bool landing;

	private int lerpCounter;

	[HideInInspector]
	public LandingSpotController _controller;

	private bool _idle;

	public Transform _thisT;

	public bool _gotcha;

	public void Start()
	{
		if (_thisT == null)
		{
			_thisT = base.transform;
		}
		if (_controller == null)
		{
			_controller = _thisT.parent.GetComponent<LandingSpotController>();
		}
		if (_controller._autoCatchDelay.x > 0f)
		{
			StartCoroutine(GetFlockChild(_controller._autoCatchDelay.x, _controller._autoCatchDelay.y));
		}
	}

	public void OnDrawGizmos()
	{
		if (_thisT == null)
		{
			_thisT = base.transform;
		}
		if (_controller == null)
		{
			_controller = _thisT.parent.GetComponent<LandingSpotController>();
		}
		Gizmos.color = Color.yellow;
		if (landingChild != null && landing)
		{
			Gizmos.DrawLine(_thisT.position, landingChild._thisT.position);
		}
		if (_thisT.rotation.eulerAngles.x != 0f || _thisT.rotation.eulerAngles.z != 0f)
		{
			_thisT.eulerAngles = new Vector3(0f, _thisT.eulerAngles.y, 0f);
		}
		Gizmos.DrawCube(new Vector3(_thisT.position.x, _thisT.position.y, _thisT.position.z), Vector3.one * _controller._gizmoSize);
		Gizmos.DrawCube(_thisT.position + _thisT.forward * _controller._gizmoSize, Vector3.one * _controller._gizmoSize * 0.5f);
		Gizmos.color = new Color(1f, 1f, 0f, 0.05f);
		Gizmos.DrawWireSphere(_thisT.position, _controller._maxBirdDistance);
	}

	public void LateUpdate()
	{
		if (landingChild == null)
		{
			_gotcha = false;
			_idle = false;
			lerpCounter = 0;
			return;
		}
		if (_gotcha)
		{
			landingChild.transform.position = _thisT.position + landingChild._landingPosOffset;
			RotateBird();
			return;
		}
		if (_controller._flock.gameObject.activeInHierarchy && landing && landingChild != null)
		{
			if (!landingChild.gameObject.activeInHierarchy)
			{
				Invoke("ReleaseFlockChild", 0f);
			}
			float num = Vector3.Distance(landingChild._thisT.position, _thisT.position + landingChild._landingPosOffset);
			if (num < 5f && num > 0.5f)
			{
				if (_controller._soarLand)
				{
					landingChild._model.GetComponent<Animation>().CrossFade(landingChild._spawner._soarAnimation, 0.5f);
					if (num < 2f)
					{
						landingChild._model.GetComponent<Animation>().CrossFade(landingChild._spawner._flapAnimation, 0.5f);
					}
				}
				landingChild._targetSpeed = landingChild._spawner._maxSpeed * _controller._landingSpeedModifier;
				landingChild._wayPoint = _thisT.position + landingChild._landingPosOffset;
				landingChild._damping = _controller._landingTurnSpeedModifier;
				landingChild._avoid = false;
			}
			else if (num <= 0.5f)
			{
				landingChild._wayPoint = _thisT.position + landingChild._landingPosOffset;
				if (num < _controller._snapLandDistance && !_idle)
				{
					_idle = true;
					landingChild._model.GetComponent<Animation>().CrossFade(landingChild._spawner._idleAnimation, 0.55f);
				}
				if (num > _controller._snapLandDistance)
				{
					landingChild._targetSpeed = landingChild._spawner._minSpeed * _controller._landingSpeedModifier;
					landingChild._thisT.position += (_thisT.position + landingChild._landingPosOffset - landingChild._thisT.position) * Time.deltaTime * landingChild._speed * _controller._landingSpeedModifier * 2f;
				}
				else
				{
					_gotcha = true;
				}
				landingChild._move = false;
				RotateBird();
			}
			else
			{
				landingChild._wayPoint = _thisT.position + landingChild._landingPosOffset;
			}
			landingChild._damping += 0.01f;
		}
		StraightenBird();
	}

	public void StraightenBird()
	{
		if (landingChild._thisT.eulerAngles.x != 0f)
		{
			Vector3 eulerAngles = landingChild._thisT.eulerAngles;
			eulerAngles.z = 0f;
			landingChild._thisT.eulerAngles = eulerAngles;
		}
	}

	public void RotateBird()
	{
		if (!_controller._randomRotate || !_idle)
		{
			lerpCounter++;
			Quaternion rotation = landingChild._thisT.rotation;
			Vector3 eulerAngles = rotation.eulerAngles;
			eulerAngles.y = Mathf.LerpAngle(landingChild._thisT.rotation.eulerAngles.y, _thisT.rotation.eulerAngles.y, (float)lerpCounter * Time.deltaTime * _controller._landedRotateSpeed);
			rotation.eulerAngles = eulerAngles;
			landingChild._thisT.rotation = rotation;
		}
	}

	public IEnumerator GetFlockChild(float minDelay, float maxDelay)
	{
		yield return new WaitForSeconds(UnityEngine.Random.Range(minDelay, maxDelay));
		if (!_controller._flock.gameObject.activeInHierarchy || !(landingChild == null))
		{
			yield break;
		}
		FlockChild flockChild = null;
		for (int i = 0; i < _controller._flock._roamers.Count; i++)
		{
			FlockChild flockChild2 = _controller._flock._roamers[i];
			if (flockChild2._landing || flockChild2._dived)
			{
				continue;
			}
			if (!_controller._onlyBirdsAbove)
			{
				if (flockChild == null && _controller._maxBirdDistance > Vector3.Distance(flockChild2._thisT.position, _thisT.position) && _controller._minBirdDistance < Vector3.Distance(flockChild2._thisT.position, _thisT.position))
				{
					flockChild = flockChild2;
					if (!_controller._takeClosest)
					{
						break;
					}
				}
				else if (flockChild != null && Vector3.Distance(flockChild._thisT.position, _thisT.position) > Vector3.Distance(flockChild2._thisT.position, _thisT.position))
				{
					flockChild = flockChild2;
				}
			}
			else if (flockChild == null && flockChild2._thisT.position.y > _thisT.position.y && _controller._maxBirdDistance > Vector3.Distance(flockChild2._thisT.position, _thisT.position) && _controller._minBirdDistance < Vector3.Distance(flockChild2._thisT.position, _thisT.position))
			{
				flockChild = flockChild2;
				if (!_controller._takeClosest)
				{
					break;
				}
			}
			else if (flockChild != null && flockChild2._thisT.position.y > _thisT.position.y && Vector3.Distance(flockChild._thisT.position, _thisT.position) > Vector3.Distance(flockChild2._thisT.position, _thisT.position))
			{
				flockChild = flockChild2;
			}
		}
		if (flockChild != null)
		{
			landingChild = flockChild;
			landing = true;
			landingChild._landing = true;
			if (_controller._autoDismountDelay.x > 0f)
			{
				Invoke("ReleaseFlockChild", UnityEngine.Random.Range(_controller._autoDismountDelay.x, _controller._autoDismountDelay.y));
			}
			_controller._activeLandingSpots++;
		}
		else if (_controller._autoCatchDelay.x > 0f)
		{
			StartCoroutine(GetFlockChild(_controller._autoCatchDelay.x, _controller._autoCatchDelay.y));
		}
	}

	public void InstantLand()
	{
		if (!_controller._flock.gameObject.activeInHierarchy || !(landingChild == null))
		{
			return;
		}
		FlockChild flockChild = null;
		for (int i = 0; i < _controller._flock._roamers.Count; i++)
		{
			FlockChild flockChild2 = _controller._flock._roamers[i];
			if (!flockChild2._landing && !flockChild2._dived)
			{
				flockChild = flockChild2;
			}
		}
		if (flockChild != null)
		{
			landingChild = flockChild;
			landing = true;
			_controller._activeLandingSpots++;
			landingChild._landing = true;
			landingChild._thisT.position = _thisT.position + landingChild._landingPosOffset;
			landingChild._model.GetComponent<Animation>().Play(landingChild._spawner._idleAnimation);
			landingChild._thisT.Rotate(Vector3.up, UnityEngine.Random.Range(0f, 360f));
			if (_controller._autoDismountDelay.x > 0f)
			{
				Invoke("ReleaseFlockChild", UnityEngine.Random.Range(_controller._autoDismountDelay.x, _controller._autoDismountDelay.y));
			}
		}
		else if (_controller._autoCatchDelay.x > 0f)
		{
			StartCoroutine(GetFlockChild(_controller._autoCatchDelay.x, _controller._autoCatchDelay.y));
		}
	}

	public void ReleaseFlockChild()
	{
		if (_controller._flock.gameObject.activeInHierarchy && landingChild != null)
		{
			_gotcha = false;
			lerpCounter = 0;
			if (_controller._featherPS != null)
			{
				_controller._featherPS.position = landingChild._thisT.position;
				_controller._featherPS.GetComponent<ParticleSystem>().Emit(UnityEngine.Random.Range(0, 3));
			}
			landing = false;
			_idle = false;
			landingChild._avoid = true;
			landingChild._damping = landingChild._spawner._maxDamping;
			landingChild._model.GetComponent<Animation>().CrossFade(landingChild._spawner._flapAnimation, 0.2f);
			landingChild._dived = true;
			landingChild._speed = 0f;
			landingChild._move = true;
			landingChild._landing = false;
			landingChild.Flap();
			landingChild._wayPoint = new Vector3(landingChild._wayPoint.x, _thisT.position.y + 10f, landingChild._wayPoint.z);
			if (_controller._autoCatchDelay.x > 0f)
			{
				StartCoroutine(GetFlockChild(_controller._autoCatchDelay.x + 0.1f, _controller._autoCatchDelay.y + 0.1f));
			}
			landingChild = null;
			_controller._activeLandingSpots--;
		}
	}
}
public class LandingSpotController : MonoBehaviour
{
	public bool _randomRotate = true;

	public Vector2 _autoCatchDelay = new Vector2(10f, 20f);

	public Vector2 _autoDismountDelay = new Vector2(10f, 20f);

	public float _maxBirdDistance = 20f;

	public float _minBirdDistance = 5f;

	public bool _takeClosest;

	public FlockController _flock;

	public bool _landOnStart;

	public bool _soarLand = true;

	public bool _onlyBirdsAbove;

	public float _landingSpeedModifier = 0.5f;

	public float _landingTurnSpeedModifier = 5f;

	public Transform _featherPS;

	public Transform _thisT;

	public int _activeLandingSpots;

	public float _snapLandDistance = 0.1f;

	public float _landedRotateSpeed = 0.01f;

	public float _gizmoSize = 0.2f;

	public void Start()
	{
		if (_thisT == null)
		{
			_thisT = base.transform;
		}
		if (_flock == null)
		{
			_flock = (FlockController)UnityEngine.Object.FindObjectOfType(typeof(FlockController));
			UnityEngine.Debug.Log(string.Concat(this, " has no assigned FlockController, a random FlockController has been assigned"));
		}
		if (_landOnStart)
		{
			StartCoroutine(InstantLandOnStart(0.1f));
		}
	}

	public void ScareAll()
	{
		ScareAll(0f, 1f);
	}

	public void ScareAll(float minDelay, float maxDelay)
	{
		for (int i = 0; i < _thisT.childCount; i++)
		{
			if (_thisT.GetChild(i).GetComponent<LandingSpot>() != null)
			{
				_thisT.GetChild(i).GetComponent<LandingSpot>().Invoke("ReleaseFlockChild", UnityEngine.Random.Range(minDelay, maxDelay));
			}
		}
	}

	public void LandAll()
	{
		for (int i = 0; i < _thisT.childCount; i++)
		{
			if (_thisT.GetChild(i).GetComponent<LandingSpot>() != null)
			{
				LandingSpot component = _thisT.GetChild(i).GetComponent<LandingSpot>();
				StartCoroutine(component.GetFlockChild(0f, 2f));
			}
		}
	}

	public IEnumerator InstantLandOnStart(float delay)
	{
		yield return new WaitForSeconds(delay);
		for (int i = 0; i < _thisT.childCount; i++)
		{
			if (_thisT.GetChild(i).GetComponent<LandingSpot>() != null)
			{
				_thisT.GetChild(i).GetComponent<LandingSpot>().InstantLand();
			}
		}
	}

	public IEnumerator InstantLand(float delay)
	{
		yield return new WaitForSeconds(delay);
		for (int i = 0; i < _thisT.childCount; i++)
		{
			if (_thisT.GetChild(i).GetComponent<LandingSpot>() != null)
			{
				_thisT.GetChild(i).GetComponent<LandingSpot>().InstantLand();
			}
		}
	}
}
public class MushroomMon_Ani_Test : MonoBehaviour
{
	public const string IDLE = "Idle";

	public const string RUN = "Run";

	public const string ATTACK = "Attack";

	public const string DAMAGE = "Damage";

	public const string DEATH = "Death";

	private Animation anim;

	private void Start()
	{
		anim = GetComponent<Animation>();
	}

	public void IdleAni()
	{
		anim.CrossFade("Idle");
	}

	public void RunAni()
	{
		anim.CrossFade("Run");
	}

	public void AttackAni()
	{
		anim.CrossFade("Attack");
	}

	public void DamageAni()
	{
		anim.CrossFade("Damage");
	}

	public void DeathAni()
	{
		anim.CrossFade("Death");
	}
}
public class Animation_Test : MonoBehaviour
{
	public const string IDLE = "Anim_Idle";

	public const string RUN = "Anim_Run";

	public const string ATTACK = "Anim_Attack";

	public const string DAMAGE = "Anim_Damage";

	public const string DEATH = "Anim_Death";

	private Animation anim;

	private void Start()
	{
		anim = GetComponent<Animation>();
	}

	public void IdleAni()
	{
		anim.CrossFade("Anim_Idle");
	}

	public void RunAni()
	{
		anim.CrossFade("Anim_Run");
	}

	public void AttackAni()
	{
		anim.CrossFade("Anim_Attack");
	}

	public void DamageAni()
	{
		anim.CrossFade("Anim_Damage");
	}

	public void DeathAni()
	{
		anim.CrossFade("Anim_Death");
	}
}
public class F3DAudioController : MonoBehaviour
{
	public static F3DAudioController instance;

	private float timer_01;

	private float timer_02;

	[Header("Vulcan")]
	public AudioClip[] vulcanHit;

	public AudioClip vulcanShot;

	public float vulcanDelay;

	public float vulcanHitDelay;

	[Header("Solo gun")]
	public AudioClip[] soloGunHit;

	public AudioClip soloGunShot;

	public float soloGunDelay;

	public float soloGunHitDelay;

	[Header("Sniper")]
	public AudioClip[] sniperHit;

	public AudioClip sniperShot;

	public float sniperDelay;

	public float sniperHitDelay;

	[Header("Shot gun")]
	public AudioClip[] shotGunHit;

	public AudioClip shotGunShot;

	public float shotGunDelay;

	public float shotGunHitDelay;

	[Header("Seeker")]
	public AudioClip[] seekerHit;

	public AudioClip seekerShot;

	public float seekerDelay;

	public float seekerHitDelay;

	[Header("Rail gun")]
	public AudioClip[] railgunHit;

	public AudioClip railgunShot;

	public float railgunDelay;

	public float railgunHitDelay;

	[Header("Plasma gun")]
	public AudioClip[] plasmagunHit;

	public AudioClip plasmagunShot;

	public float plasmagunDelay;

	public float plasmagunHitDelay;

	[Header("Plasma beam")]
	public AudioClip plasmabeamOpen;

	public AudioClip plasmabeamLoop;

	public AudioClip plasmabeamClose;

	[Header("Plasma beam heavy")]
	public AudioClip plasmabeamHeavyOpen;

	public AudioClip plasmabeamHeavyLoop;

	public AudioClip plasmabeamHeavyClose;

	[Header("Lightning gun")]
	public AudioClip lightningGunOpen;

	public AudioClip lightningGunLoop;

	public AudioClip lightningGunClose;

	[Header("Flame gun")]
	public AudioClip flameGunOpen;

	public AudioClip flameGunLoop;

	public AudioClip flameGunClose;

	[Header("Laser impulse")]
	public AudioClip[] laserImpulseHit;

	public AudioClip laserImpulseShot;

	public float laserImpulseDelay;

	public float laserImpulseHitDelay;

	private void Awake()
	{
		instance = this;
	}

	private void Update()
	{
		timer_01 += Time.deltaTime;
		timer_02 += Time.deltaTime;
	}

	public void VulcanShot(Vector3 pos)
	{
		if (timer_01 >= vulcanDelay)
		{
			AudioSource audioSource = F3DPool.instance.SpawnAudio(vulcanShot, pos, null);
			if (audioSource != null)
			{
				audioSource.pitch = UnityEngine.Random.Range(0.95f, 1f);
				audioSource.volume = UnityEngine.Random.Range(0.8f, 1f);
				audioSource.minDistance = 5f;
				audioSource.loop = false;
				audioSource.Play();
				timer_01 = 0f;
			}
		}
	}

	public void VulcanHit(Vector3 pos)
	{
		if (timer_02 >= vulcanHitDelay)
		{
			AudioSource audioSource = F3DPool.instance.SpawnAudio(vulcanHit[UnityEngine.Random.Range(0, vulcanHit.Length)], pos, null);
			if (audioSource != null)
			{
				audioSource.pitch = UnityEngine.Random.Range(0.95f, 1f);
				audioSource.volume = UnityEngine.Random.Range(0.6f, 1f);
				audioSource.minDistance = 7f;
				audioSource.loop = false;
				audioSource.Play();
				timer_02 = 0f;
			}
		}
	}

	public void SoloGunShot(Vector3 pos)
	{
		if (timer_01 >= soloGunDelay)
		{
			AudioSource audioSource = F3DPool.instance.SpawnAudio(soloGunShot, pos, null);
			if (audioSource != null)
			{
				audioSource.pitch = UnityEngine.Random.Range(0.95f, 1f);
				audioSource.volume = UnityEngine.Random.Range(0.8f, 1f);
				audioSource.minDistance = 30f;
				audioSource.loop = false;
				audioSource.Play();
				timer_01 = 0f;
			}
		}
	}

	public void SoloGunHit(Vector3 pos)
	{
		if (timer_02 >= soloGunHitDelay)
		{
			AudioSource audioSource = F3DPool.instance.SpawnAudio(soloGunHit[UnityEngine.Random.Range(0, soloGunHit.Length)], pos, null);
			if (audioSource != null)
			{
				audioSource.pitch = UnityEngine.Random.Range(0.95f, 1f);
				audioSource.volume = UnityEngine.Random.Range(0.8f, 1f);
				audioSource.minDistance = 50f;
				audioSource.loop = false;
				audioSource.Play();
				timer_02 = 0f;
			}
		}
	}

	public void SniperShot(Vector3 pos)
	{
		if (timer_01 >= sniperDelay)
		{
			AudioSource audioSource = F3DPool.instance.SpawnAudio(sniperShot, pos, null);
			if (audioSource != null)
			{
				audioSource.pitch = UnityEngine.Random.Range(0.9f, 1f);
				audioSource.volume = UnityEngine.Random.Range(0.8f, 1f);
				audioSource.minDistance = 6f;
				audioSource.loop = false;
				audioSource.Play();
				timer_01 = 0f;
			}
		}
	}

	public void SniperHit(Vector3 pos)
	{
		if (timer_02 >= sniperHitDelay)
		{
			AudioSource audioSource = F3DPool.instance.SpawnAudio(sniperHit[UnityEngine.Random.Range(0, sniperHit.Length)], pos, null);
			if (audioSource != null)
			{
				audioSource.pitch = UnityEngine.Random.Range(0.9f, 1f);
				audioSource.volume = UnityEngine.Random.Range(0.8f, 1f);
				audioSource.minDistance = 8f;
				audioSource.loop = false;
				audioSource.Play();
				timer_02 = 0f;
			}
		}
	}

	public void ShotGunShot(Vector3 pos)
	{
		if (timer_01 >= shotGunDelay)
		{
			AudioSource audioSource = F3DPool.instance.SpawnAudio(shotGunShot, pos, null);
			if (audioSource != null)
			{
				audioSource.pitch = UnityEngine.Random.Range(0.9f, 1f);
				audioSource.volume = UnityEngine.Random.Range(0.8f, 1f);
				audioSource.minDistance = 8f;
				audioSource.loop = false;
				audioSource.Play();
				timer_01 = 0f;
			}
		}
	}

	public void ShotGunHit(Vector3 pos)
	{
		if (timer_02 >= shotGunHitDelay)
		{
			AudioSource audioSource = F3DPool.instance.SpawnAudio(shotGunHit[UnityEngine.Random.Range(0, shotGunHit.Length)], pos, null);
			if (audioSource != null)
			{
				audioSource.pitch = UnityEngine.Random.Range(0.9f, 1f);
				audioSource.volume = UnityEngine.Random.Range(0.8f, 1f);
				audioSource.minDistance = 7f;
				audioSource.loop = false;
				audioSource.Play();
				timer_02 = 0f;
			}
		}
	}

	public void SeekerShot(Vector3 pos)
	{
		if (timer_01 >= seekerDelay)
		{
			AudioSource audioSource = F3DPool.instance.SpawnAudio(seekerShot, pos, null);
			if (audioSource != null)
			{
				audioSource.pitch = UnityEngine.Random.Range(0.8f, 1f);
				audioSource.volume = UnityEngine.Random.Range(0.8f, 1f);
				audioSource.minDistance = 8f;
				audioSource.loop = false;
				audioSource.Play();
				timer_01 = 0f;
			}
		}
	}

	public void SeekerHit(Vector3 pos)
	{
		if (timer_02 >= seekerHitDelay)
		{
			AudioSource audioSource = F3DPool.instance.SpawnAudio(seekerHit[UnityEngine.Random.Range(0, seekerHit.Length)], pos, null);
			if (audioSource != null)
			{
				audioSource.pitch = UnityEngine.Random.Range(0.8f, 1f);
				audioSource.volume = UnityEngine.Random.Range(0.8f, 1f);
				audioSource.minDistance = 25f;
				audioSource.loop = false;
				audioSource.Play();
				timer_02 = 0f;
			}
		}
	}

	public void RailGunShot(Vector3 pos)
	{
		if (timer_01 >= railgunDelay)
		{
			AudioSource audioSource = F3DPool.instance.SpawnAudio(railgunShot, pos, null);
			if (audioSource != null)
			{
				audioSource.pitch = UnityEngine.Random.Range(0.8f, 1f);
				audioSource.volume = UnityEngine.Random.Range(0.8f, 1f);
				audioSource.minDistance = 4f;
				audioSource.loop = false;
				audioSource.Play();
				timer_01 = 0f;
			}
		}
	}

	public void RailGunHit(Vector3 pos)
	{
		if (timer_02 >= railgunHitDelay)
		{
			AudioSource audioSource = F3DPool.instance.SpawnAudio(railgunHit[UnityEngine.Random.Range(0, railgunHit.Length)], pos, null);
			if (audioSource != null)
			{
				audioSource.pitch = UnityEngine.Random.Range(0.8f, 1f);
				audioSource.volume = UnityEngine.Random.Range(0.8f, 1f);
				audioSource.minDistance = 20f;
				audioSource.loop = false;
				audioSource.Play();
				timer_02 = 0f;
			}
		}
	}

	public void PlasmaGunShot(Vector3 pos)
	{
		if (timer_01 >= plasmagunDelay)
		{
			AudioSource audioSource = F3DPool.instance.SpawnAudio(plasmagunShot, pos, null);
			if (audioSource != null)
			{
				audioSource.pitch = UnityEngine.Random.Range(0.8f, 1f);
				audioSource.volume = UnityEngine.Random.Range(0.8f, 1f);
				audioSource.minDistance = 4f;
				audioSource.loop = false;
				audioSource.Play();
				timer_01 = 0f;
			}
		}
	}

	public void PlasmaGunHit(Vector3 pos)
	{
		if (timer_02 >= plasmagunHitDelay)
		{
			AudioSource audioSource = F3DPool.instance.SpawnAudio(plasmagunHit[UnityEngine.Random.Range(0, plasmagunHit.Length)], pos, null);
			if (audioSource != null)
			{
				audioSource.pitch = UnityEngine.Random.Range(0.8f, 1f);
				audioSource.volume = UnityEngine.Random.Range(0.8f, 1f);
				audioSource.minDistance = 50f;
				audioSource.loop = false;
				audioSource.Play();
				timer_02 = 0f;
			}
		}
	}

	public void PlasmaBeamLoop(Vector3 pos, Transform loopParent)
	{
		AudioSource audioSource = F3DPool.instance.SpawnAudio(plasmabeamOpen, pos, null);
		AudioSource audioSource2 = F3DPool.instance.SpawnAudio(plasmabeamLoop, pos, loopParent);
		if (audioSource != null && audioSource2 != null)
		{
			audioSource.pitch = UnityEngine.Random.Range(0.8f, 1f);
			audioSource.volume = UnityEngine.Random.Range(0.8f, 1f);
			audioSource.minDistance = 50f;
			audioSource.loop = false;
			audioSource.Play();
			audioSource2.pitch = UnityEngine.Random.Range(0.95f, 1f);
			audioSource2.volume = UnityEngine.Random.Range(0.95f, 1f);
			audioSource2.loop = true;
			audioSource2.minDistance = 50f;
			audioSource2.Play();
		}
	}

	public void PlasmaBeamClose(Vector3 pos)
	{
		AudioSource audioSource = F3DPool.instance.SpawnAudio(plasmabeamClose, pos, null);
		if (audioSource != null)
		{
			audioSource.pitch = UnityEngine.Random.Range(0.8f, 1f);
			audioSource.volume = UnityEngine.Random.Range(0.8f, 1f);
			audioSource.minDistance = 50f;
			audioSource.loop = false;
			audioSource.Play();
		}
	}

	public void PlasmaBeamHeavyLoop(Vector3 pos, Transform loopParent)
	{
		AudioSource audioSource = F3DPool.instance.SpawnAudio(plasmabeamHeavyOpen, pos, null);
		AudioSource audioSource2 = F3DPool.instance.SpawnAudio(plasmabeamHeavyLoop, pos, loopParent);
		if (audioSource != null && audioSource2 != null)
		{
			audioSource.pitch = UnityEngine.Random.Range(0.8f, 1f);
			audioSource.volume = UnityEngine.Random.Range(0.8f, 1f);
			audioSource.minDistance = 50f;
			audioSource.loop = false;
			audioSource.Play();
			audioSource2.pitch = UnityEngine.Random.Range(0.95f, 1f);
			audioSource2.volume = UnityEngine.Random.Range(0.95f, 1f);
			audioSource2.loop = true;
			audioSource2.minDistance = 50f;
			audioSource2.Play();
		}
	}

	public void PlasmaBeamHeavyClose(Vector3 pos)
	{
		AudioSource audioSource = F3DPool.instance.SpawnAudio(plasmabeamHeavyClose, pos, null);
		if (audioSource != null)
		{
			audioSource.pitch = UnityEngine.Random.Range(0.8f, 1f);
			audioSource.volume = UnityEngine.Random.Range(0.8f, 1f);
			audioSource.minDistance = 50f;
			audioSource.loop = false;
			audioSource.Play();
		}
	}

	public void LightningGunLoop(Vector3 pos, Transform loopParent)
	{
		AudioSource audioSource = F3DPool.instance.SpawnAudio(lightningGunOpen, pos, null);
		AudioSource audioSource2 = F3DPool.instance.SpawnAudio(lightningGunLoop, pos, loopParent.parent);
		if (audioSource != null && audioSource2 != null)
		{
			audioSource.pitch = UnityEngine.Random.Range(0.8f, 1f);
			audioSource.volume = UnityEngine.Random.Range(0.8f, 1f);
			audioSource.minDistance = 50f;
			audioSource.loop = false;
			audioSource.Play();
			audioSource2.pitch = UnityEngine.Random.Range(0.95f, 1f);
			audioSource2.volume = UnityEngine.Random.Range(0.95f, 1f);
			audioSource2.loop = true;
			audioSource2.minDistance = 50f;
			audioSource2.Play();
		}
	}

	public void LightningGunClose(Vector3 pos)
	{
		AudioSource audioSource = F3DPool.instance.SpawnAudio(lightningGunClose, pos, null);
		if (audioSource != null)
		{
			audioSource.pitch = UnityEngine.Random.Range(0.8f, 1f);
			audioSource.volume = UnityEngine.Random.Range(0.8f, 1f);
			audioSource.minDistance = 50f;
			audioSource.loop = false;
			audioSource.Play();
		}
	}

	public void FlameGunLoop(Vector3 pos, Transform loopParent)
	{
		AudioSource audioSource = F3DPool.instance.SpawnAudio(flameGunOpen, pos, null);
		AudioSource audioSource2 = F3DPool.instance.SpawnAudio(flameGunLoop, pos, loopParent.parent);
		if (audioSource != null && audioSource2 != null)
		{
			audioSource.pitch = UnityEngine.Random.Range(0.8f, 1f);
			audioSource.volume = UnityEngine.Random.Range(0.8f, 1f);
			audioSource.minDistance = 50f;
			audioSource.loop = false;
			audioSource.Play();
			audioSource2.pitch = UnityEngine.Random.Range(0.95f, 1f);
			audioSource2.volume = UnityEngine.Random.Range(0.95f, 1f);
			audioSource2.loop = true;
			audioSource2.minDistance = 50f;
			audioSource2.Play();
		}
	}

	public void FlameGunClose(Vector3 pos)
	{
		AudioSource audioSource = F3DPool.instance.SpawnAudio(flameGunClose, pos, null);
		if (audioSource != null)
		{
			audioSource.pitch = UnityEngine.Random.Range(0.8f, 1f);
			audioSource.volume = UnityEngine.Random.Range(0.8f, 1f);
			audioSource.minDistance = 50f;
			audioSource.loop = false;
			audioSource.Play();
		}
	}

	public void LaserImpulseShot(Vector3 pos)
	{
		if (timer_01 >= laserImpulseDelay)
		{
			AudioSource audioSource = F3DPool.instance.SpawnAudio(laserImpulseShot, pos, null);
			if (audioSource != null)
			{
				audioSource.pitch = UnityEngine.Random.Range(0.9f, 1f);
				audioSource.volume = UnityEngine.Random.Range(0.8f, 1f);
				audioSource.minDistance = 20f;
				audioSource.loop = false;
				audioSource.Play();
				timer_01 = 0f;
			}
		}
	}

	public void LaserImpulseHit(Vector3 pos)
	{
		if (timer_02 >= laserImpulseHitDelay)
		{
			AudioSource audioSource = F3DPool.instance.SpawnAudio(laserImpulseHit[UnityEngine.Random.Range(0, plasmagunHit.Length)], pos, null);
			if (audioSource != null)
			{
				audioSource.pitch = UnityEngine.Random.Range(0.8f, 1f);
				audioSource.volume = UnityEngine.Random.Range(0.8f, 1f);
				audioSource.minDistance = 20f;
				audioSource.loop = false;
				audioSource.Play();
				timer_02 = 0f;
			}
		}
	}
}
[RequireComponent(typeof(LineRenderer))]
public class F3DBeam : MonoBehaviour
{
	public LayerMask layerMask;

	public F3DFXType fxType;

	public bool OneShot;

	public Texture[] BeamFrames;

	public float FrameStep;

	public float beamScale;

	public float MaxBeamLength;

	public bool AnimateUV;

	public float UVTime;

	public Transform rayImpact;

	public Transform rayMuzzle;

	private LineRenderer lineRenderer;

	private RaycastHit hitPoint;

	private int frameNo;

	private int FrameTimerID;

	private float beamLength;

	private float initialBeamOffset;

	private void Awake()
	{
		lineRenderer = GetComponent<LineRenderer>();
		if (!AnimateUV && BeamFrames.Length != 0)
		{
			lineRenderer.material.mainTexture = BeamFrames[0];
		}
		initialBeamOffset = UnityEngine.Random.Range(0f, 5f);
	}

	private void OnSpawned()
	{
		if (OneShot)
		{
			Raycast();
		}
		if (BeamFrames.Length > 1)
		{
			Animate();
		}
		switch (fxType)
		{
		case F3DFXType.PlasmaBeam:
			F3DAudioController.instance.PlasmaBeamLoop(base.transform.position, base.transform.parent);
			break;
		case F3DFXType.PlasmaBeamHeavy:
			F3DAudioController.instance.PlasmaBeamHeavyLoop(base.transform.position, base.transform.parent);
			break;
		}
	}

	private void OnDespawned()
	{
		frameNo = 0;
		if (FrameTimerID != -1)
		{
			F3DTime.time.RemoveTimer(FrameTimerID);
			FrameTimerID = -1;
		}
		switch (fxType)
		{
		case F3DFXType.PlasmaBeam:
			F3DAudioController.instance.PlasmaBeamClose(base.transform.position);
			break;
		case F3DFXType.PlasmaBeamHeavy:
			F3DAudioController.instance.PlasmaBeamHeavyClose(base.transform.position);
			break;
		}
	}

	private void Raycast()
	{
		hitPoint = default(RaycastHit);
		Ray ray = new Ray(base.transform.position, base.transform.forward);
		float x = MaxBeamLength * (beamScale / 10f);
		if (Physics.Raycast(ray, out hitPoint, MaxBeamLength, layerMask))
		{
			beamLength = Vector3.Distance(base.transform.position, hitPoint.point);
			lineRenderer.SetPosition(1, new Vector3(0f, 0f, beamLength));
			x = beamLength * (beamScale / 10f);
			switch (fxType)
			{
			case F3DFXType.Sniper:
				F3DFXController.instance.SniperImpact(hitPoint.point + hitPoint.normal * 0.2f);
				ApplyForce(4f);
				break;
			case F3DFXType.RailGun:
				F3DFXController.instance.RailgunImpact(hitPoint.point + hitPoint.normal * 0.2f);
				ApplyForce(7f);
				break;
			case F3DFXType.PlasmaBeam:
				ApplyForce(0.5f);
				break;
			case F3DFXType.PlasmaBeamHeavy:
				ApplyForce(2f);
				break;
			}
			if ((bool)rayImpact)
			{
				rayImpact.position = hitPoint.point - base.transform.forward * 0.5f;
			}
		}
		else
		{
			beamLength = MaxBeamLength;
			lineRenderer.SetPosition(1, new Vector3(0f, 0f, beamLength));
			if ((bool)rayImpact)
			{
				rayImpact.position = base.transform.position + base.transform.forward * beamLength;
			}
		}
		if ((bool)rayMuzzle)
		{
			rayMuzzle.position = base.transform.position + base.transform.forward * 0.1f;
		}
		lineRenderer.material.SetTextureScale("_MainTex", new Vector2(x, 1f));
	}

	private void OnFrameStep()
	{
		lineRenderer.material.mainTexture = BeamFrames[frameNo];
		frameNo++;
		if (frameNo == BeamFrames.Length)
		{
			frameNo = 0;
		}
	}

	private void Animate()
	{
		if (BeamFrames.Length > 1)
		{
			frameNo = 0;
			lineRenderer.material.mainTexture = BeamFrames[frameNo];
			FrameTimerID = F3DTime.time.AddTimer(FrameStep, BeamFrames.Length - 1, OnFrameStep);
			frameNo = 1;
		}
	}

	private void ApplyForce(float force)
	{
		if (hitPoint.rigidbody != null)
		{
			hitPoint.rigidbody.AddForceAtPosition(base.transform.forward * force, hitPoint.point, ForceMode.VelocityChange);
		}
	}

	private void Update()
	{
		if (AnimateUV)
		{
			lineRenderer.material.SetTextureOffset("_MainTex", new Vector2(Time.time * UVTime + initialBeamOffset, 0f));
		}
		if (!OneShot)
		{
			Raycast();
		}
	}
}
[RequireComponent(typeof(LineRenderer))]
public class F3DCurvedBeam : MonoBehaviour
{
	public Transform dest;

	public float beamScale;

	public float UVTime;

	private LineRenderer lineRenderer;

	public int curvePoints;

	public float curveHeight;

	private float initialBeamOffset;

	private void Start()
	{
		lineRenderer = GetComponent<LineRenderer>();
		initialBeamOffset = UnityEngine.Random.Range(0f, 5f);
		lineRenderer.SetVertexCount(curvePoints);
	}

	private void Update()
	{
		lineRenderer.material.SetTextureOffset("_MainTex", new Vector2(Time.time * UVTime + initialBeamOffset, 0f));
		float num = Vector3.Distance(base.transform.position, dest.position);
		lineRenderer.SetPosition(0, base.transform.position);
		float num2 = (float)Math.PI / (float)(curvePoints - 1);
		for (int i = 1; i < curvePoints - 1; i++)
		{
			float num3 = num / (float)(curvePoints - 1) * (float)i;
			Vector3 vector = Vector3.Normalize(dest.position - base.transform.position) * num3;
			float num4 = Mathf.Sin(num2 * (float)i) * curveHeight;
			vector += base.transform.up * num4;
			lineRenderer.SetPosition(i, base.transform.position + vector);
		}
		lineRenderer.SetPosition(curvePoints - 1, dest.position);
		float x = num * (beamScale / 10f);
		lineRenderer.material.SetTextureScale("_MainTex", new Vector2(x, 1f));
	}
}
public class F3DDespawn : MonoBehaviour
{
	public float DespawnDelay;

	public bool DespawnOnMouseUp;

	private AudioSource aSrc;

	private void Awake()
	{
		aSrc = GetComponent<AudioSource>();
	}

	public void OnSpawned()
	{
		if (!DespawnOnMouseUp)
		{
			F3DTime.time.AddTimer(DespawnDelay, 1, DespawnOnTimer);
		}
	}

	public void OnDespawned()
	{
	}

	public void DespawnOnTimer()
	{
		if (aSrc != null)
		{
			if (aSrc.loop)
			{
				DespawnOnMouseUp = true;
				return;
			}
			DespawnOnMouseUp = false;
			Despawn();
		}
		else
		{
			Despawn();
		}
	}

	public void Despawn()
	{
		F3DPool.instance.Despawn(base.transform);
	}

	private void Update()
	{
		if (Input.GetMouseButtonUp(0) && ((aSrc != null && aSrc.loop) || DespawnOnMouseUp))
		{
			Despawn();
		}
	}
}
public enum F3DFXType
{
	Vulcan,
	SoloGun,
	Sniper,
	ShotGun,
	Seeker,
	RailGun,
	PlasmaGun,
	PlasmaBeam,
	PlasmaBeamHeavy,
	LightningGun,
	FlameRed,
	LaserImpulse
}
public class F3DFXController : MonoBehaviour
{
	public static F3DFXController instance;

	private string[] fxTypeName = new string[12]
	{
		"Vulcan", "Sologun", "Sniper", "Shotgun", "Seeker", "Railgun", "Plasmagun", "Plasma beam", "Heavy plasma beam", "Lightning gun",
		"Flamethrower", "Pulse laser"
	};

	private int curSocket;

	private int timerID = -1;

	[Header("Turret setup")]
	public Transform[] TurretSocket;

	public ParticleSystem[] ShellParticles;

	public F3DFXType DefaultFXType;

	[Header("Vulcan")]
	public Transform vulcanProjectile;

	public Transform vulcanMuzzle;

	public Transform vulcanImpact;

	[Header("Solo gun")]
	public Transform soloGunProjectile;

	public Transform soloGunMuzzle;

	public Transform soloGunImpact;

	[Header("Sniper")]
	public Transform sniperBeam;

	public Transform sniperMuzzle;

	public Transform sniperImpact;

	[Header("Shotgun")]
	public Transform shotGunProjectile;

	public Transform shotGunMuzzle;

	public Transform shotGunImpact;

	[Header("Seeker")]
	public Transform seekerProjectile;

	public Transform seekerMuzzle;

	public Transform seekerImpact;

	[Header("Rail gun")]
	public Transform railgunBeam;

	public Transform railgunMuzzle;

	public Transform railgunImpact;

	[Header("Plasma gun")]
	public Transform plasmagunProjectile;

	public Transform plasmagunMuzzle;

	public Transform plasmagunImpact;

	[Header("Plasma beam")]
	public Transform plasmaBeam;

	[Header("Plasma beam heavy")]
	public Transform plasmaBeamHeavy;

	[Header("Lightning gun")]
	public Transform lightningGunBeam;

	[Header("Flame")]
	public Transform flameRed;

	[Header("Laser impulse")]
	public Transform laserImpulseProjectile;

	public Transform laserImpulseMuzzle;

	public Transform laserImpulseImpact;

	private void Awake()
	{
		instance = this;
		for (int i = 0; i < ShellParticles.Length; i++)
		{
			ShellParticles[i].enableEmission = false;
			ShellParticles[i].gameObject.SetActive(value: true);
		}
	}

	private void OnGUI()
	{
		GUIStyle gUIStyle = new GUIStyle(GUI.skin.label);
		gUIStyle.fontSize = 25;
		gUIStyle.fontStyle = FontStyle.Bold;
		gUIStyle.wordWrap = false;
		GUIStyle gUIStyle2 = new GUIStyle(GUI.skin.label);
		gUIStyle2.fontSize = 11;
		gUIStyle2.wordWrap = false;
		GUILayout.BeginArea(new Rect(Screen.width / 2 - 150, Screen.height - 150, 300f, 120f));
		GUILayout.BeginVertical();
		GUILayout.FlexibleSpace();
		GUILayout.BeginHorizontal();
		GUILayout.FlexibleSpace();
		GUILayout.Label(fxTypeName[(int)DefaultFXType], gUIStyle);
		GUILayout.FlexibleSpace();
		GUILayout.EndHorizontal();
		GUILayout.FlexibleSpace();
		GUILayout.BeginHorizontal();
		GUILayout.FlexibleSpace();
		GUILayout.Label("Press Left / Right arrow keys to switch", gUIStyle2);
		GUILayout.FlexibleSpace();
		GUILayout.EndHorizontal();
		GUILayout.FlexibleSpace();
		GUILayout.BeginHorizontal();
		GUILayout.FlexibleSpace();
		if (GUILayout.Button("Previous", GUILayout.Width(90f), GUILayout.Height(30f)))
		{
			PrevWeapon();
		}
		GUILayout.FlexibleSpace();
		if (GUILayout.Button("Next", GUILayout.Width(90f), GUILayout.Height(30f)))
		{
			NextWeapon();
		}
		GUILayout.FlexibleSpace();
		GUILayout.EndHorizontal();
		GUILayout.FlexibleSpace();
		GUILayout.EndVertical();
		GUILayout.EndArea();
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.RightArrow))
		{
			NextWeapon();
		}
		else if (Input.GetKeyDown(KeyCode.LeftArrow))
		{
			PrevWeapon();
		}
	}

	private void NextWeapon()
	{
		if ((int)DefaultFXType < Enum.GetNames(typeof(F3DFXType)).Length - 1)
		{
			Stop();
			DefaultFXType++;
		}
	}

	private void PrevWeapon()
	{
		if (DefaultFXType > F3DFXType.Vulcan)
		{
			Stop();
			DefaultFXType--;
		}
	}

	private void AdvanceSocket()
	{
		curSocket++;
		if (curSocket > 3)
		{
			curSocket = 0;
		}
	}

	public void Fire()
	{
		switch (DefaultFXType)
		{
		case F3DFXType.Vulcan:
			timerID = F3DTime.time.AddTimer(0.05f, Vulcan);
			Vulcan();
			break;
		case F3DFXType.SoloGun:
			timerID = F3DTime.time.AddTimer(0.2f, SoloGun);
			SoloGun();
			break;
		case F3DFXType.Sniper:
			timerID = F3DTime.time.AddTimer(0.3f, Sniper);
			Sniper();
			break;
		case F3DFXType.ShotGun:
			timerID = F3DTime.time.AddTimer(0.3f, ShotGun);
			ShotGun();
			break;
		case F3DFXType.Seeker:
			timerID = F3DTime.time.AddTimer(0.2f, Seeker);
			Seeker();
			break;
		case F3DFXType.RailGun:
			timerID = F3DTime.time.AddTimer(0.2f, RailGun);
			RailGun();
			break;
		case F3DFXType.PlasmaGun:
			timerID = F3DTime.time.AddTimer(0.2f, PlasmaGun);
			PlasmaGun();
			break;
		case F3DFXType.PlasmaBeam:
			PlasmaBeam();
			break;
		case F3DFXType.PlasmaBeamHeavy:
			PlasmaBeamHeavy();
			break;
		case F3DFXType.LightningGun:
			LightningGun();
			break;
		case F3DFXType.FlameRed:
			FlameRed();
			break;
		case F3DFXType.LaserImpulse:
			timerID = F3DTime.time.AddTimer(0.15f, LaserImpulse);
			LaserImpulse();
			break;
		}
	}

	public void Stop()
	{
		if (timerID != -1)
		{
			F3DTime.time.RemoveTimer(timerID);
			timerID = -1;
		}
	}

	private void Vulcan()
	{
		Quaternion quaternion = Quaternion.Euler(UnityEngine.Random.onUnitSphere);
		F3DPool.instance.Spawn(vulcanMuzzle, TurretSocket[curSocket].position, TurretSocket[curSocket].rotation, TurretSocket[curSocket]);
		F3DPool.instance.Spawn(vulcanProjectile, TurretSocket[curSocket].position + TurretSocket[curSocket].forward, quaternion * TurretSocket[curSocket].rotation, null);
		ShellParticles[curSocket].Emit(1);
		F3DAudioController.instance.VulcanShot(TurretSocket[curSocket].position);
		AdvanceSocket();
	}

	public void VulcanImpact(Vector3 pos)
	{
		F3DPool.instance.Spawn(vulcanImpact, pos, Quaternion.identity, null);
		F3DAudioController.instance.VulcanHit(pos);
	}

	private void SoloGun()
	{
		Quaternion quaternion = Quaternion.Euler(UnityEngine.Random.onUnitSphere);
		F3DPool.instance.Spawn(soloGunMuzzle, TurretSocket[curSocket].position, TurretSocket[curSocket].rotation, TurretSocket[curSocket]);
		F3DPool.instance.Spawn(soloGunProjectile, TurretSocket[curSocket].position + TurretSocket[curSocket].forward, quaternion * TurretSocket[curSocket].rotation, null);
		F3DAudioController.instance.SoloGunShot(TurretSocket[curSocket].position);
		AdvanceSocket();
	}

	public void SoloGunImpact(Vector3 pos)
	{
		F3DPool.instance.Spawn(soloGunImpact, pos, Quaternion.identity, null);
		F3DAudioController.instance.SoloGunHit(pos);
	}

	private void Sniper()
	{
		Quaternion quaternion = Quaternion.Euler(UnityEngine.Random.onUnitSphere);
		F3DPool.instance.Spawn(sniperMuzzle, TurretSocket[curSocket].position, TurretSocket[curSocket].rotation, TurretSocket[curSocket]);
		F3DPool.instance.Spawn(sniperBeam, TurretSocket[curSocket].position, quaternion * TurretSocket[curSocket].rotation, null);
		F3DAudioController.instance.SniperShot(TurretSocket[curSocket].position);
		ShellParticles[curSocket].Emit(1);
		AdvanceSocket();
	}

	public void SniperImpact(Vector3 pos)
	{
		F3DPool.instance.Spawn(sniperImpact, pos, Quaternion.identity, null);
		F3DAudioController.instance.SniperHit(pos);
	}

	private void ShotGun()
	{
		Quaternion quaternion = Quaternion.Euler(UnityEngine.Random.onUnitSphere);
		F3DPool.instance.Spawn(shotGunMuzzle, TurretSocket[curSocket].position, TurretSocket[curSocket].rotation, TurretSocket[curSocket]);
		F3DPool.instance.Spawn(shotGunProjectile, TurretSocket[curSocket].position, quaternion * TurretSocket[curSocket].rotation, null);
		F3DAudioController.instance.ShotGunShot(TurretSocket[curSocket].position);
		ShellParticles[curSocket].Emit(1);
		AdvanceSocket();
	}

	private void Seeker()
	{
		Quaternion quaternion = Quaternion.Euler(UnityEngine.Random.onUnitSphere);
		F3DPool.instance.Spawn(seekerMuzzle, TurretSocket[curSocket].position, TurretSocket[curSocket].rotation, TurretSocket[curSocket]);
		F3DPool.instance.Spawn(seekerProjectile, TurretSocket[curSocket].position, quaternion * TurretSocket[curSocket].rotation, null);
		F3DAudioController.instance.SeekerShot(TurretSocket[curSocket].position);
		AdvanceSocket();
	}

	public void SeekerImpact(Vector3 pos)
	{
		F3DPool.instance.Spawn(seekerImpact, pos, Quaternion.identity, null);
		F3DAudioController.instance.SeekerHit(pos);
	}

	private void RailGun()
	{
		Quaternion quaternion = Quaternion.Euler(UnityEngine.Random.onUnitSphere);
		F3DPool.instance.Spawn(railgunMuzzle, TurretSocket[curSocket].position, TurretSocket[curSocket].rotation, TurretSocket[curSocket]);
		F3DPool.instance.Spawn(railgunBeam, TurretSocket[curSocket].position, quaternion * TurretSocket[curSocket].rotation, null);
		F3DAudioController.instance.RailGunShot(TurretSocket[curSocket].position);
		ShellParticles[curSocket].Emit(1);
		AdvanceSocket();
	}

	public void RailgunImpact(Vector3 pos)
	{
		F3DPool.instance.Spawn(railgunImpact, pos, Quaternion.identity, null);
		F3DAudioController.instance.RailGunHit(pos);
	}

	private void PlasmaGun()
	{
		Quaternion quaternion = Quaternion.Euler(UnityEngine.Random.onUnitSphere);
		F3DPool.instance.Spawn(plasmagunMuzzle, TurretSocket[curSocket].position, TurretSocket[curSocket].rotation, TurretSocket[curSocket]);
		F3DPool.instance.Spawn(plasmagunProjectile, TurretSocket[curSocket].position, quaternion * TurretSocket[curSocket].rotation, null);
		F3DAudioController.instance.PlasmaGunShot(TurretSocket[curSocket].position);
		AdvanceSocket();
	}

	public void PlasmaGunImpact(Vector3 pos)
	{
		F3DPool.instance.Spawn(plasmagunImpact, pos, Quaternion.identity, null);
		F3DAudioController.instance.PlasmaGunHit(pos);
	}

	private void PlasmaBeam()
	{
		F3DPool.instance.Spawn(plasmaBeam, TurretSocket[0].position, TurretSocket[0].rotation, TurretSocket[0]);
		F3DPool.instance.Spawn(plasmaBeam, TurretSocket[2].position, TurretSocket[2].rotation, TurretSocket[2]);
	}

	private void PlasmaBeamHeavy()
	{
		F3DPool.instance.Spawn(plasmaBeamHeavy, TurretSocket[0].position, TurretSocket[0].rotation, TurretSocket[0]);
		F3DPool.instance.Spawn(plasmaBeamHeavy, TurretSocket[2].position, TurretSocket[2].rotation, TurretSocket[2]);
	}

	private void LightningGun()
	{
		F3DPool.instance.Spawn(lightningGunBeam, TurretSocket[0].position, TurretSocket[0].rotation, TurretSocket[0]);
		F3DPool.instance.Spawn(lightningGunBeam, TurretSocket[2].position, TurretSocket[2].rotation, TurretSocket[2]);
	}

	private void FlameRed()
	{
		F3DPool.instance.Spawn(flameRed, TurretSocket[0].position, TurretSocket[0].rotation, TurretSocket[0]);
		F3DPool.instance.Spawn(flameRed, TurretSocket[2].position, TurretSocket[2].rotation, TurretSocket[2]);
	}

	private void LaserImpulse()
	{
		Quaternion quaternion = Quaternion.Euler(UnityEngine.Random.onUnitSphere);
		F3DPool.instance.Spawn(laserImpulseMuzzle, TurretSocket[curSocket].position, TurretSocket[curSocket].rotation, TurretSocket[curSocket]);
		F3DPool.instance.Spawn(laserImpulseProjectile, TurretSocket[curSocket].position, quaternion * TurretSocket[curSocket].rotation, null);
		F3DAudioController.instance.LaserImpulseShot(TurretSocket[curSocket].position);
		AdvanceSocket();
	}

	public void LaserImpulseImpact(Vector3 pos)
	{
		F3DPool.instance.Spawn(laserImpulseImpact, pos, Quaternion.identity, null);
		F3DAudioController.instance.LaserImpulseHit(pos);
	}
}
public class F3DFlameThrower : MonoBehaviour
{
	public Light pLight;

	public ParticleSystem heat;

	private int lightState;

	private bool despawn;

	private ParticleSystem ps;

	private void Start()
	{
		ps = GetComponent<ParticleSystem>();
	}

	private void OnSpawned()
	{
		despawn = false;
		F3DAudioController.instance.FlameGunLoop(base.transform.position, base.transform);
		lightState = 1;
		pLight.intensity = 0f;
	}

	private void OnDespawned()
	{
	}

	private void OnDespawn()
	{
		F3DPool.instance.Despawn(base.transform);
	}

	private void Update()
	{
		if (Input.GetMouseButtonUp(0) && !despawn)
		{
			despawn = true;
			F3DTime.time.AddTimer(1f, 1, OnDespawn);
			ps.Stop();
			if ((bool)heat)
			{
				heat.Stop();
			}
			F3DAudioController.instance.FlameGunClose(base.transform.position);
			pLight.intensity = 0.6f;
			lightState = -1;
		}
		if (lightState == 1)
		{
			pLight.intensity = Mathf.Lerp(pLight.intensity, 0.7f, Time.deltaTime * 10f);
			if (pLight.intensity >= 0.5f)
			{
				lightState = 0;
			}
		}
		else if (lightState == -1)
		{
			pLight.intensity = Mathf.Lerp(pLight.intensity, -0.1f, Time.deltaTime * 10f);
			if (pLight.intensity <= 0f)
			{
				lightState = 0;
			}
		}
	}
}
[RequireComponent(typeof(LineRenderer))]
public class F3DLightning : MonoBehaviour
{
	public LayerMask layerMask;

	public Texture[] BeamFrames;

	public float FrameStep;

	public bool RandomizeFrames;

	public int Points;

	public float MaxBeamLength;

	public float beamScale;

	public bool AnimateUV;

	public float UVTime;

	public bool Oscillate;

	public float Amplitude;

	public float OscillateTime;

	public Transform rayImpact;

	public Transform rayMuzzle;

	private LineRenderer lineRenderer;

	private RaycastHit hitPoint;

	private int frameNo;

	private int FrameTimerID;

	private int OscillateTimerID;

	private float beamLength;

	private float initialBeamOffset;

	private void Awake()
	{
		lineRenderer = GetComponent<LineRenderer>();
		if (!AnimateUV && BeamFrames.Length != 0)
		{
			lineRenderer.material.mainTexture = BeamFrames[0];
		}
		initialBeamOffset = UnityEngine.Random.Range(0f, 5f);
	}

	private void OnSpawned()
	{
		if (BeamFrames.Length > 1)
		{
			Animate();
		}
		if (Oscillate && Points > 0)
		{
			OscillateTimerID = F3DTime.time.AddTimer(OscillateTime, OnOscillate);
		}
		if ((bool)F3DAudioController.instance)
		{
			F3DAudioController.instance.LightningGunLoop(base.transform.position, base.transform);
		}
	}

	private void OnDespawned()
	{
		frameNo = 0;
		if (FrameTimerID != -1)
		{
			F3DTime.time.RemoveTimer(FrameTimerID);
			FrameTimerID = -1;
		}
		if (OscillateTimerID != -1)
		{
			F3DTime.time.RemoveTimer(OscillateTimerID);
			OscillateTimerID = -1;
		}
		if ((bool)F3DAudioController.instance)
		{
			F3DAudioController.instance.LightningGunClose(base.transform.position);
		}
	}

	private void Raycast()
	{
		hitPoint = default(RaycastHit);
		Ray ray = new Ray(base.transform.position, base.transform.forward);
		float x = MaxBeamLength * (beamScale / 10f);
		if (Physics.Raycast(ray, out hitPoint, MaxBeamLength, layerMask))
		{
			beamLength = Vector3.Distance(base.transform.position, hitPoint.point);
			if (!Oscillate)
			{
				lineRenderer.SetPosition(1, new Vector3(0f, 0f, beamLength));
			}
			x = beamLength * (beamScale / 10f);
			ApplyForce(0.1f);
			if ((bool)rayImpact)
			{
				rayImpact.position = hitPoint.point - base.transform.forward * 0.5f;
			}
		}
		else
		{
			beamLength = MaxBeamLength;
			if (!Oscillate)
			{
				lineRenderer.SetPosition(1, new Vector3(0f, 0f, beamLength));
			}
			if ((bool)rayImpact)
			{
				rayImpact.position = base.transform.position + base.transform.forward * beamLength;
			}
		}
		if ((bool)rayMuzzle)
		{
			rayMuzzle.position = base.transform.position + base.transform.forward * 0.1f;
		}
		lineRenderer.material.SetTextureScale("_MainTex", new Vector2(x, 1f));
	}

	private float GetRandomNoise()
	{
		return UnityEngine.Random.Range(0f - Amplitude, Amplitude);
	}

	private void OnFrameStep()
	{
		if (RandomizeFrames)
		{
			frameNo = UnityEngine.Random.Range(0, BeamFrames.Length);
		}
		lineRenderer.material.mainTexture = BeamFrames[frameNo];
		frameNo++;
		if (frameNo == BeamFrames.Length)
		{
			frameNo = 0;
		}
	}

	private void OnOscillate()
	{
		int num = (int)(beamLength / 10f * (float)Points);
		if (num < 2)
		{
			lineRenderer.SetVertexCount(2);
			lineRenderer.SetPosition(0, Vector3.zero);
			lineRenderer.SetPosition(1, new Vector3(0f, 0f, beamLength));
			return;
		}
		lineRenderer.SetVertexCount(num);
		lineRenderer.SetPosition(0, Vector3.zero);
		for (int i = 1; i < num - 1; i++)
		{
			lineRenderer.SetPosition(i, new Vector3(GetRandomNoise(), GetRandomNoise(), beamLength / (float)(num - 1) * (float)i));
		}
		lineRenderer.SetPosition(num - 1, new Vector3(0f, 0f, beamLength));
	}

	private void Animate()
	{
		frameNo = 0;
		lineRenderer.material.mainTexture = BeamFrames[frameNo];
		FrameTimerID = F3DTime.time.AddTimer(FrameStep, OnFrameStep);
		frameNo = 1;
	}

	private void ApplyForce(float force)
	{
		if (hitPoint.rigidbody != null)
		{
			hitPoint.rigidbody.AddForceAtPosition(base.transform.forward * force, hitPoint.point, ForceMode.VelocityChange);
		}
	}

	private void Update()
	{
		if (AnimateUV)
		{
			lineRenderer.material.SetTextureOffset("_MainTex", new Vector2(Time.time * UVTime + initialBeamOffset, 0f));
		}
		Raycast();
	}
}
public class F3DMissile : MonoBehaviour
{
	public enum MissileType
	{
		Unguided,
		Guided,
		Predictive
	}

	public MissileType missileType;

	public Transform target;

	public LayerMask layerMask;

	public float detonationDistance;

	public float lifeTime = 5f;

	public float despawnDelay;

	public float velocity = 300f;

	public float alignSpeed = 1f;

	public float RaycastAdvance = 2f;

	public bool DelayDespawn;

	public ParticleSystem[] delayedParticles;

	private ParticleSystem[] particles;

	private new Transform transform;

	private bool isHit;

	private bool isFXSpawned;

	private float timer;

	private Vector3 targetLastPos;

	private Vector3 step;

	private MeshRenderer meshRenderer;

	private void Awake()
	{
		transform = GetComponent<Transform>();
		particles = GetComponentsInChildren<ParticleSystem>();
		meshRenderer = GetComponent<MeshRenderer>();
	}

	public void OnSpawned()
	{
		isHit = false;
		isFXSpawned = false;
		timer = 0f;
		targetLastPos = Vector3.zero;
		step = Vector3.zero;
		meshRenderer.enabled = true;
	}

	public void OnDespawned()
	{
	}

	private void Delay()
	{
		if (particles.Length == 0 || delayedParticles.Length == 0)
		{
			return;
		}
		for (int i = 0; i < particles.Length; i++)
		{
			bool flag = false;
			for (int j = 0; j < delayedParticles.Length; j++)
			{
				if (particles[i] == delayedParticles[j])
				{
					flag = true;
					break;
				}
			}
			particles[i].Stop(withChildren: false);
			if (!flag)
			{
				particles[i].Clear(withChildren: false);
			}
		}
	}

	private void OnMissileDestroy()
	{
		if (F3DPool.instance != null)
		{
			F3DPool.instance.Despawn(transform);
		}
	}

	private void OnHit()
	{
		meshRenderer.enabled = false;
		isHit = true;
		if (DelayDespawn)
		{
			timer = 0f;
			Delay();
		}
	}

	private void Update()
	{
		if (isHit)
		{
			if (!isFXSpawned)
			{
				F3DMissileLauncher.instance.SpawnExplosion(transform.position);
				isFXSpawned = true;
			}
			if (!DelayDespawn || (DelayDespawn && timer >= despawnDelay))
			{
				OnMissileDestroy();
			}
		}
		else
		{
			if (target != null)
			{
				if (missileType == MissileType.Predictive)
				{
					Vector3 vector = F3DPredictTrajectory.Predict(transform.position, target.position, targetLastPos, velocity);
					targetLastPos = target.position;
					transform.rotation = Quaternion.Lerp(transform.rotation, Quaternion.LookRotation(vector - transform.position), Time.deltaTime * alignSpeed);
				}
				else if (missileType == MissileType.Guided)
				{
					transform.rotation = Quaternion.Lerp(transform.rotation, Quaternion.LookRotation(target.position - transform.position), Time.deltaTime * alignSpeed);
				}
			}
			step = transform.forward * Time.deltaTime * velocity;
			if (target != null && missileType != 0 && Vector3.SqrMagnitude(transform.position - target.position) <= detonationDistance)
			{
				OnHit();
			}
			else if (missileType == MissileType.Unguided && Physics.Raycast(transform.position, transform.forward, step.magnitude * RaycastAdvance, layerMask))
			{
				OnHit();
			}
			else if (timer >= lifeTime)
			{
				isFXSpawned = true;
				OnHit();
			}
			transform.position += step;
		}
		timer += Time.deltaTime;
	}
}
[ExecuteInEditMode]
public class F3DParticleScale : MonoBehaviour
{
	[Range(0f, 20f)]
	public float ParticleScale = 1f;

	public bool ScaleGameobject = true;

	private float prevScale;

	private void Start()
	{
		prevScale = ParticleScale;
	}

	private void ScaleShurikenSystems(float scaleFactor)
	{
	}

	private void ScaleTrailRenderers(float scaleFactor)
	{
		TrailRenderer[] componentsInChildren = GetComponentsInChildren<TrailRenderer>();
		foreach (TrailRenderer obj in componentsInChildren)
		{
			obj.startWidth *= scaleFactor;
			obj.endWidth *= scaleFactor;
		}
	}

	private void Update()
	{
	}
}
public class F3DPool : MonoBehaviour
{
	public static F3DPool instance;

	[Header("VFX Pool")]
	public Transform[] poolItems;

	public int[] poolLength;

	[Header("Audio Pool")]
	public Transform audioSourcePrefab;

	public AudioClip[] audioPoolItems;

	public int[] audioPoolLength;

	private Dictionary<Transform, Transform[]> pool;

	private Dictionary<AudioClip, AudioSource[]> audioPool;

	private void Start()
	{
		instance = this;
		if (poolItems.Length != 0)
		{
			pool = new Dictionary<Transform, Transform[]>();
			for (int i = 0; i < poolItems.Length; i++)
			{
				Transform[] array = new Transform[poolLength[i]];
				for (int j = 0; j < poolLength[i]; j++)
				{
					Transform transform = UnityEngine.Object.Instantiate(poolItems[i], Vector3.zero, Quaternion.identity);
					transform.gameObject.SetActive(value: false);
					transform.parent = base.transform;
					array[j] = transform;
				}
				pool.Add(poolItems[i], array);
			}
		}
		if (audioPoolItems.Length == 0)
		{
			return;
		}
		audioPool = new Dictionary<AudioClip, AudioSource[]>();
		for (int k = 0; k < audioPoolItems.Length; k++)
		{
			AudioSource[] array2 = new AudioSource[audioPoolLength[k]];
			for (int l = 0; l < audioPoolLength[k]; l++)
			{
				AudioSource component = UnityEngine.Object.Instantiate(audioSourcePrefab, Vector3.zero, Quaternion.identity).GetComponent<AudioSource>();
				component.clip = audioPoolItems[k];
				component.gameObject.SetActive(value: false);
				component.transform.parent = base.transform;
				array2[l] = component;
			}
			audioPool.Add(audioPoolItems[k], array2);
		}
	}

	public Transform Spawn(Transform obj, Vector3 pos, Quaternion rot, Transform parent)
	{
		for (int i = 0; i < pool[obj].Length; i++)
		{
			if (!pool[obj][i].gameObject.activeSelf)
			{
				Transform obj2 = pool[obj][i];
				obj2.parent = parent;
				obj2.position = pos;
				obj2.rotation = rot;
				obj2.gameObject.SetActive(value: true);
				obj2.BroadcastMessage("OnSpawned", SendMessageOptions.DontRequireReceiver);
				return obj2;
			}
		}
		return null;
	}

	public AudioSource SpawnAudio(AudioClip clip, Vector3 pos, Transform parent)
	{
		for (int i = 0; i < audioPool[clip].Length; i++)
		{
			if (!audioPool[clip][i].gameObject.activeSelf)
			{
				AudioSource obj = audioPool[clip][i];
				obj.transform.parent = parent;
				obj.transform.position = pos;
				obj.gameObject.SetActive(value: true);
				obj.BroadcastMessage("OnSpawned", SendMessageOptions.DontRequireReceiver);
				return obj;
			}
		}
		return null;
	}

	public void Despawn(Transform obj)
	{
		obj.BroadcastMessage("OnDespawned", SendMessageOptions.DontRequireReceiver);
		obj.gameObject.SetActive(value: false);
	}
}
public class F3DPredictTrajectory : MonoBehaviour
{
	public static Vector3 Predict(Vector3 sPos, Vector3 tPos, Vector3 tLastPos, float pSpeed)
	{
		Vector3 vector = (tPos - tLastPos) / Time.deltaTime;
		float projFlightTime = GetProjFlightTime(tPos - sPos, vector, pSpeed);
		if (projFlightTime > 0f)
		{
			return tPos + projFlightTime * vector;
		}
		return tPos;
	}

	private static float GetProjFlightTime(Vector3 dist, Vector3 tVel, float pSpeed)
	{
		float num = Vector3.Dot(tVel, tVel) - pSpeed * pSpeed;
		float num2 = 2f * Vector3.Dot(tVel, dist);
		float num3 = Vector3.Dot(dist, dist);
		float num4 = num2 * num2 - 4f * num * num3;
		if (num4 > 0f)
		{
			return 2f * num3 / (Mathf.Sqrt(num4) - num2);
		}
		return -1f;
	}
}
public class F3DProjectile : MonoBehaviour
{
	public F3DFXType fxType;

	public LayerMask layerMask;

	public float lifeTime = 5f;

	public float despawnDelay;

	public float velocity = 300f;

	public float RaycastAdvance = 2f;

	public bool DelayDespawn;

	public ParticleSystem[] delayedParticles;

	private ParticleSystem[] particles;

	private new Transform transform;

	private RaycastHit hitPoint;

	private bool isHit;

	private bool isFXSpawned;

	private float timer;

	private void Awake()
	{
		transform = GetComponent<Transform>();
		particles = GetComponentsInChildren<ParticleSystem>();
	}

	public void OnSpawned()
	{
		isHit = false;
		isFXSpawned = false;
		timer = 0f;
		hitPoint = default(RaycastHit);
	}

	public void OnDespawned()
	{
	}

	private void Delay()
	{
		if (particles.Length == 0 || delayedParticles.Length == 0)
		{
			return;
		}
		for (int i = 0; i < particles.Length; i++)
		{
			bool flag = false;
			for (int j = 0; j < delayedParticles.Length; j++)
			{
				if (particles[i] == delayedParticles[j])
				{
					flag = true;
					break;
				}
			}
			particles[i].Stop(withChildren: false);
			if (!flag)
			{
				particles[i].Clear(withChildren: false);
			}
		}
	}

	private void OnProjectileDestroy()
	{
		F3DPool.instance.Despawn(transform);
	}

	private void ApplyForce(float force)
	{
		if (hitPoint.rigidbody != null)
		{
			hitPoint.rigidbody.AddForceAtPosition(transform.forward * force, hitPoint.point, ForceMode.VelocityChange);
		}
	}

	private void Update()
	{
		if (isHit)
		{
			if (!isFXSpawned)
			{
				switch (fxType)
				{
				case F3DFXType.Vulcan:
					F3DFXController.instance.VulcanImpact(hitPoint.point + hitPoint.normal * 0.2f);
					ApplyForce(2.5f);
					break;
				case F3DFXType.SoloGun:
					F3DFXController.instance.SoloGunImpact(hitPoint.point + hitPoint.normal * 0.2f);
					ApplyForce(25f);
					break;
				case F3DFXType.Seeker:
					F3DFXController.instance.SeekerImpact(hitPoint.point + hitPoint.normal * 1f);
					ApplyForce(30f);
					break;
				case F3DFXType.PlasmaGun:
					F3DFXController.instance.PlasmaGunImpact(hitPoint.point + hitPoint.normal * 0.2f);
					ApplyForce(25f);
					break;
				case F3DFXType.LaserImpulse:
					F3DFXController.instance.LaserImpulseImpact(hitPoint.point + hitPoint.normal * 0.2f);
					ApplyForce(25f);
					break;
				}
				isFXSpawned = true;
			}
			if (!DelayDespawn || (DelayDespawn && timer >= despawnDelay))
			{
				OnProjectileDestroy();
			}
		}
		else
		{
			Vector3 vector = transform.forward * Time.deltaTime * velocity;
			if (Physics.Raycast(transform.position, transform.forward, out hitPoint, vector.magnitude * RaycastAdvance, layerMask))
			{
				isHit = true;
				if (DelayDespawn)
				{
					timer = 0f;
					Delay();
				}
			}
			else if (timer >= lifeTime)
			{
				OnProjectileDestroy();
			}
			transform.position += vector;
		}
		timer += Time.deltaTime;
	}
}
public class F3DPulsewave : MonoBehaviour
{
	public float FadeOutDelay;

	public float FadeOutTime;

	public float ScaleTime;

	public Vector3 ScaleSize;

	public bool DebugLoop;

	private new Transform transform;

	private MeshRenderer meshRenderer;

	private int timerID = -1;

	private bool isFadeOut;

	private bool isEnabled;

	private Color defaultColor;

	private Color color;

	private int tintColorRef;

	private void Awake()
	{
		transform = GetComponent<Transform>();
		meshRenderer = GetComponent<MeshRenderer>();
		tintColorRef = Shader.PropertyToID("_TintColor");
		defaultColor = meshRenderer.material.GetColor(tintColorRef);
	}

	private void Start()
	{
		if (DebugLoop)
		{
			OnSpawned();
		}
	}

	private void OnSpawned()
	{
		transform.localScale = new Vector3(0f, 0f, 0f);
		isEnabled = true;
		isFadeOut = false;
		timerID = F3DTime.time.AddTimer(FadeOutDelay, OnFadeOut);
		meshRenderer.material.SetColor(tintColorRef, defaultColor);
		color = defaultColor;
	}

	private void OnDespawned()
	{
		if (timerID >= 0)
		{
			F3DTime.time.RemoveTimer(timerID);
			timerID = -1;
		}
	}

	private void OnFadeOut()
	{
		isFadeOut = true;
	}

	private void Update()
	{
		if (!isEnabled)
		{
			return;
		}
		transform.localScale = Vector3.Lerp(transform.localScale, ScaleSize, Time.deltaTime * ScaleTime);
		if (!isFadeOut)
		{
			return;
		}
		color = Color.Lerp(color, new Color(0f, 0f, 0f, -0.1f), Time.deltaTime * FadeOutTime);
		meshRenderer.material.SetColor(tintColorRef, color);
		if (color.a <= 0f)
		{
			isEnabled = false;
			if (DebugLoop)
			{
				OnDespawned();
				OnSpawned();
			}
		}
	}
}
public class F3DRandomize : MonoBehaviour
{
	private new Transform transform;

	private Vector3 defaultScale;

	public bool RandomScale;

	public bool RandomRotation;

	public float MinScale;

	public float MaxScale;

	public float MinRotation;

	public float MaxRotaion;

	private void Awake()
	{
		transform = GetComponent<Transform>();
		defaultScale = transform.localScale;
	}

	private void OnEnable()
	{
		if (RandomScale)
		{
			transform.localScale = defaultScale * UnityEngine.Random.Range(MinScale, MaxScale);
		}
		if (RandomRotation)
		{
			transform.rotation *= Quaternion.Euler(0f, 0f, UnityEngine.Random.Range(MinRotation, MaxRotaion));
		}
	}
}
public class F3DRift : MonoBehaviour
{
	public float RotationSpeed;

	public float MorphSpeed;

	public float MorphFactor;

	private Vector3 dScale;

	private void Start()
	{
		dScale = base.transform.localScale;
	}

	private void Update()
	{
		base.transform.rotation = base.transform.rotation * Quaternion.Euler(0f, 0f, RotationSpeed * Time.deltaTime);
		base.transform.localScale = new Vector3(dScale.x, dScale.y, dScale.z + Mathf.Sin(Time.time * MorphSpeed) * MorphFactor);
	}
}
public class F3DShotgun : MonoBehaviour
{
	private ParticleCollisionEvent[] collisionEvents = new ParticleCollisionEvent[16];

	private void OnParticleCollision(GameObject other)
	{
		int safeCollisionEventSize = GetComponent<ParticleSystem>().GetSafeCollisionEventSize();
		if (collisionEvents.Length < safeCollisionEventSize)
		{
			collisionEvents = new ParticleCollisionEvent[safeCollisionEventSize];
		}
		int num = GetComponent<ParticleSystem>().GetCollisionEvents(other, collisionEvents);
		for (int i = 0; i < num; i++)
		{
			F3DAudioController.instance.ShotGunHit(collisionEvents[i].intersection);
			if ((bool)other.GetComponent<Rigidbody>())
			{
				Vector3 intersection = collisionEvents[i].intersection;
				Vector3 force = collisionEvents[i].velocity.normalized * 50f;
				other.GetComponent<Rigidbody>().AddForceAtPosition(force, intersection);
			}
		}
	}
}
public class F3DTime : MonoBehaviour
{
	private class Timer
	{
		public int id;

		public bool isActive;

		public float rate;

		public int ticks;

		public int ticksElapsed;

		public float last;

		public Action callBack;

		public Timer(int id_, float rate_, int ticks_, Action callback_)
		{
			id = id_;
			rate = ((rate_ < 0f) ? 0f : rate_);
			ticks = ((ticks_ >= 0) ? ticks_ : 0);
			callBack = callback_;
			last = 0f;
			ticksElapsed = 0;
			isActive = true;
		}

		public void Tick()
		{
			last += Time.deltaTime;
			if (isActive && last >= rate)
			{
				last = 0f;
				ticksElapsed++;
				callBack();
				if (ticks > 0 && ticks == ticksElapsed)
				{
					isActive = false;
					time.RemoveTimer(id);
				}
			}
		}
	}

	public static F3DTime time;

	private List<Timer> timers;

	private List<int> removalPending;

	private int idCounter;

	private void Awake()
	{
		time = this;
		timers = new List<Timer>();
		removalPending = new List<int>();
	}

	public int AddTimer(float rate, Action callBack)
	{
		return AddTimer(rate, 0, callBack);
	}

	public int AddTimer(float rate, int ticks, Action callBack)
	{
		Timer timer = new Timer(++idCounter, rate, ticks, callBack);
		timers.Add(timer);
		return timer.id;
	}

	public void RemoveTimer(int timerId)
	{
		removalPending.Add(timerId);
	}

	private void Remove()
	{
		if (removalPending.Count <= 0)
		{
			return;
		}
		foreach (int item in removalPending)
		{
			for (int i = 0; i < timers.Count; i++)
			{
				if (timers[i].id == item)
				{
					timers.RemoveAt(i);
					break;
				}
			}
		}
		removalPending.Clear();
	}

	private void Tick()
	{
		for (int i = 0; i < timers.Count; i++)
		{
			timers[i].Tick();
		}
	}

	private void Update()
	{
		Remove();
		Tick();
	}
}
public class F3DTurret : MonoBehaviour
{
	public Transform hub;

	public Transform barrel;

	private RaycastHit hitInfo;

	private bool isFiring;

	private float hubAngle;

	private float barrelAngle;

	private Vector3 ProjectVectorOnPlane(Vector3 planeNormal, Vector3 vector)
	{
		return vector - Vector3.Dot(vector, planeNormal) * planeNormal;
	}

	private float SignedVectorAngle(Vector3 referenceVector, Vector3 otherVector, Vector3 normal)
	{
		Vector3 lhs = Vector3.Cross(normal, referenceVector);
		return Vector3.Angle(referenceVector, otherVector) * Mathf.Sign(Vector3.Dot(lhs, otherVector));
	}

	private void Track()
	{
		if (hub != null && barrel != null && Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out hitInfo, 500f))
		{
			Vector3 vector = ProjectVectorOnPlane(hub.up, hitInfo.point - hub.position);
			Quaternion b = Quaternion.LookRotation(vector);
			hubAngle = SignedVectorAngle(base.transform.forward, vector, Vector3.up);
			if (hubAngle <= -60f)
			{
				b = Quaternion.LookRotation(Quaternion.Euler(0f, -60f, 0f) * base.transform.forward);
			}
			else if (hubAngle >= 60f)
			{
				b = Quaternion.LookRotation(Quaternion.Euler(0f, 60f, 0f) * base.transform.forward);
			}
			hub.rotation = Quaternion.Slerp(hub.rotation, b, Time.deltaTime * 5f);
			Vector3 vector2 = ProjectVectorOnPlane(hub.right, hitInfo.point - barrel.position);
			Quaternion b2 = Quaternion.LookRotation(vector2);
			barrelAngle = SignedVectorAngle(hub.forward, vector2, hub.right);
			if (barrelAngle < -30f)
			{
				b2 = Quaternion.LookRotation(Quaternion.AngleAxis(-30f, hub.right) * hub.forward);
			}
			else if (barrelAngle > 15f)
			{
				b2 = Quaternion.LookRotation(Quaternion.AngleAxis(15f, hub.right) * hub.forward);
			}
			barrel.rotation = Quaternion.Slerp(barrel.rotation, b2, Time.deltaTime * 5f);
		}
	}

	private void Update()
	{
		Track();
		if (!isFiring && Input.GetKeyDown(KeyCode.Mouse0))
		{
			isFiring = true;
			F3DFXController.instance.Fire();
		}
		if (isFiring && Input.GetKeyUp(KeyCode.Mouse0))
		{
			isFiring = false;
			F3DFXController.instance.Stop();
		}
	}
}
public class F3DWarpJump : MonoBehaviour
{
	public ParticleSystem WarpSpark;

	public Transform ShipPos;

	public float ShipJumpSpeed;

	public Vector3 ShipJumpStartPoint;

	public Vector3 ShipJumpEndPoint;

	public bool SendOnSpawned;

	private bool isWarping;

	private void Start()
	{
		if (SendOnSpawned)
		{
			BroadcastMessage("OnSpawned", SendMessageOptions.DontRequireReceiver);
		}
	}

	public void OnSpawned()
	{
		isWarping = false;
		WarpSpark.transform.localPosition = ShipJumpStartPoint;
		ShipPos.position = WarpSpark.transform.position;
		F3DTime.time.AddTimer(3f, 1, OnWarp);
	}

	private void OnWarp()
	{
		isWarping = true;
	}

	private void ShiftShipPosition()
	{
		WarpSpark.transform.localPosition = Vector3.Lerp(WarpSpark.transform.localPosition, ShipJumpEndPoint, Time.deltaTime * ShipJumpSpeed);
		ShipPos.position = WarpSpark.transform.position;
	}

	private void Update()
	{
		if (isWarping)
		{
			ShiftShipPosition();
		}
	}
}
public class F3DWarpJumpTunnel : MonoBehaviour
{
	private new Transform transform;

	private MeshRenderer meshRenderer;

	public float StartDelay;

	public float FadeDelay;

	public Vector3 ScaleTo;

	public float ScaleTime;

	public float ColorTime;

	public float ColorFadeTime;

	public float RotationSpeed;

	private bool grow;

	private float alpha;

	private int alphaID;

	private void Awake()
	{
		transform = GetComponent<Transform>();
		meshRenderer = GetComponent<MeshRenderer>();
		alphaID = Shader.PropertyToID("_Alpha");
	}

	public void OnSpawned()
	{
		grow = false;
		meshRenderer.material.SetFloat(alphaID, 0f);
		F3DTime.time.AddTimer(StartDelay, 1, ToggleGrow);
		F3DTime.time.AddTimer(FadeDelay, 1, ToggleGrow);
		transform.localScale = new Vector3(1f, 1f, 1f);
		transform.localRotation *= Quaternion.Euler(0f, 0f, UnityEngine.Random.Range(-360, 360));
	}

	private void ToggleGrow()
	{
		grow = !grow;
	}

	private void Update()
	{
		transform.Rotate(0f, 0f, RotationSpeed * Time.deltaTime);
		if (grow)
		{
			transform.localScale = Vector3.Lerp(transform.localScale, ScaleTo, Time.deltaTime * ScaleTime);
			alpha = Mathf.Lerp(alpha, 1f, Time.deltaTime * ColorTime);
			meshRenderer.material.SetFloat(alphaID, alpha);
		}
		else
		{
			alpha = Mathf.Lerp(alpha, 0f, Time.deltaTime * ColorFadeTime);
			meshRenderer.material.SetFloat(alphaID, alpha);
		}
	}
}
public class F3DWarpTunnel : MonoBehaviour
{
	public float MaxRotationSpeed;

	public float AdaptationFactor;

	private float speed;

	private float newSpeed;

	private void Start()
	{
		speed = 0f;
		OnDirectionChange();
	}

	private void OnDirectionChange()
	{
		newSpeed = UnityEngine.Random.Range(0f - MaxRotationSpeed, MaxRotationSpeed);
		F3DTime.time.AddTimer(UnityEngine.Random.Range(1, 5), 1, OnDirectionChange);
	}

	private void Update()
	{
		speed = Mathf.Lerp(speed, newSpeed, Time.deltaTime * AdaptationFactor);
		base.transform.rotation = Quaternion.Lerp(base.transform.rotation, base.transform.rotation * Quaternion.Euler(speed, 0f, 0f), Time.deltaTime);
	}
}
[AddComponentMenu("Mesh/Combine Children")]
public class CombineChildren : MonoBehaviour
{
	public bool generateTriangleStrips = true;

	private void Start()
	{
		Component[] componentsInChildren = GetComponentsInChildren(typeof(MeshFilter));
		Matrix4x4 worldToLocalMatrix = base.transform.worldToLocalMatrix;
		System.Collections.Hashtable hashtable = new System.Collections.Hashtable();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			MeshFilter meshFilter = (MeshFilter)componentsInChildren[i];
			Renderer component = componentsInChildren[i].GetComponent<Renderer>();
			MeshCombineUtility.MeshInstance meshInstance = default(MeshCombineUtility.MeshInstance);
			meshInstance.mesh = meshFilter.sharedMesh;
			if (!(component != null) || !component.enabled || !(meshInstance.mesh != null))
			{
				continue;
			}
			meshInstance.transform = worldToLocalMatrix * meshFilter.transform.localToWorldMatrix;
			Material[] sharedMaterials = component.sharedMaterials;
			for (int j = 0; j < sharedMaterials.Length; j++)
			{
				meshInstance.subMeshIndex = Math.Min(j, meshInstance.mesh.subMeshCount - 1);
				ArrayList arrayList = (ArrayList)hashtable[sharedMaterials[j]];
				if (arrayList != null)
				{
					arrayList.Add(meshInstance);
					continue;
				}
				arrayList = new ArrayList();
				arrayList.Add(meshInstance);
				hashtable.Add(sharedMaterials[j], arrayList);
			}
			component.enabled = false;
		}
		foreach (DictionaryEntry item in hashtable)
		{
			MeshCombineUtility.MeshInstance[] combines = (MeshCombineUtility.MeshInstance[])((ArrayList)item.Value).ToArray(typeof(MeshCombineUtility.MeshInstance));
			if (hashtable.Count == 1)
			{
				if (GetComponent(typeof(MeshFilter)) == null)
				{
					base.gameObject.AddComponent(typeof(MeshFilter));
				}
				if (!GetComponent<MeshRenderer>())
				{
					base.gameObject.AddComponent<MeshRenderer>();
				}
				((MeshFilter)GetComponent(typeof(MeshFilter))).mesh = MeshCombineUtility.Combine(combines, generateTriangleStrips);
				GetComponent<Renderer>().material = (Material)item.Key;
				GetComponent<Renderer>().enabled = true;
			}
			else
			{
				GameObject obj = new GameObject("Combined mesh");
				obj.transform.parent = base.transform;
				obj.transform.localScale = Vector3.one;
				obj.transform.localRotation = Quaternion.identity;
				obj.transform.localPosition = Vector3.zero;
				obj.AddComponent(typeof(MeshFilter));
				obj.AddComponent<MeshRenderer>();
				obj.GetComponent<Renderer>().material = (Material)item.Key;
				((MeshFilter)obj.GetComponent(typeof(MeshFilter))).mesh = MeshCombineUtility.Combine(combines, generateTriangleStrips);
			}
		}
	}
}
public class MeshCombineUtility
{
	public struct MeshInstance
	{
		public Mesh mesh;

		public int subMeshIndex;

		public Matrix4x4 transform;
	}

	public static Mesh Combine(MeshInstance[] combines, bool generateStrips)
	{
		int num = 0;
		int num2 = 0;
		int num3 = 0;
		MeshInstance[] array = combines;
		for (int i = 0; i < array.Length; i++)
		{
			MeshInstance meshInstance = array[i];
			if (!meshInstance.mesh)
			{
				continue;
			}
			num += meshInstance.mesh.vertexCount;
			if (!generateStrips)
			{
				continue;
			}
			int num4 = meshInstance.mesh.GetTriangles(meshInstance.subMeshIndex).Length;
			if (num4 != 0)
			{
				if (num3 != 0)
				{
					num3 = (((num3 & 1) != 1) ? (num3 + 2) : (num3 + 3));
				}
				num3 += num4;
			}
			else
			{
				generateStrips = false;
			}
		}
		if (!generateStrips)
		{
			array = combines;
			for (int i = 0; i < array.Length; i++)
			{
				MeshInstance meshInstance2 = array[i];
				if ((bool)meshInstance2.mesh)
				{
					num2 += meshInstance2.mesh.GetTriangles(meshInstance2.subMeshIndex).Length;
				}
			}
		}
		Vector3[] array2 = new Vector3[num];
		Vector3[] array3 = new Vector3[num];
		Vector4[] array4 = new Vector4[num];
		Vector2[] array5 = new Vector2[num];
		Vector2[] array6 = new Vector2[num];
		Color[] array7 = new Color[num];
		int[] array8 = new int[num2];
		int[] array9 = new int[num3];
		int offset = 0;
		array = combines;
		for (int i = 0; i < array.Length; i++)
		{
			MeshInstance meshInstance3 = array[i];
			if ((bool)meshInstance3.mesh)
			{
				Copy(meshInstance3.mesh.vertexCount, meshInstance3.mesh.vertices, array2, ref offset, meshInstance3.transform);
			}
		}
		offset = 0;
		array = combines;
		for (int i = 0; i < array.Length; i++)
		{
			MeshInstance meshInstance4 = array[i];
			if ((bool)meshInstance4.mesh)
			{
				Matrix4x4 transform = meshInstance4.transform;
				transform = transform.inverse.transpose;
				CopyNormal(meshInstance4.mesh.vertexCount, meshInstance4.mesh.normals, array3, ref offset, transform);
			}
		}
		offset = 0;
		array = combines;
		for (int i = 0; i < array.Length; i++)
		{
			MeshInstance meshInstance5 = array[i];
			if ((bool)meshInstance5.mesh)
			{
				Matrix4x4 transform2 = meshInstance5.transform;
				transform2 = transform2.inverse.transpose;
				CopyTangents(meshInstance5.mesh.vertexCount, meshInstance5.mesh.tangents, array4, ref offset, transform2);
			}
		}
		offset = 0;
		array = combines;
		for (int i = 0; i < array.Length; i++)
		{
			MeshInstance meshInstance6 = array[i];
			if ((bool)meshInstance6.mesh)
			{
				Copy(meshInstance6.mesh.vertexCount, meshInstance6.mesh.uv, array5, ref offset);
			}
		}
		offset = 0;
		array = combines;
		for (int i = 0; i < array.Length; i++)
		{
			MeshInstance meshInstance7 = array[i];
			if ((bool)meshInstance7.mesh)
			{
				Copy(meshInstance7.mesh.vertexCount, meshInstance7.mesh.uv2, array6, ref offset);
			}
		}
		offset = 0;
		array = combines;
		for (int i = 0; i < array.Length; i++)
		{
			MeshInstance meshInstance8 = array[i];
			if ((bool)meshInstance8.mesh)
			{
				CopyColors(meshInstance8.mesh.vertexCount, meshInstance8.mesh.colors, array7, ref offset);
			}
		}
		int num5 = 0;
		int num6 = 0;
		int num7 = 0;
		array = combines;
		for (int i = 0; i < array.Length; i++)
		{
			MeshInstance meshInstance9 = array[i];
			if (!meshInstance9.mesh)
			{
				continue;
			}
			if (generateStrips)
			{
				int[] triangles = meshInstance9.mesh.GetTriangles(meshInstance9.subMeshIndex);
				if (num6 != 0)
				{
					if ((num6 & 1) == 1)
					{
						array9[num6] = array9[num6 - 1];
						array9[num6 + 1] = triangles[0] + num7;
						array9[num6 + 2] = triangles[0] + num7;
						num6 += 3;
					}
					else
					{
						array9[num6] = array9[num6 - 1];
						array9[num6 + 1] = triangles[0] + num7;
						num6 += 2;
					}
				}
				for (int j = 0; j < triangles.Length; j++)
				{
					array9[j + num6] = triangles[j] + num7;
				}
				num6 += triangles.Length;
			}
			else
			{
				int[] triangles2 = meshInstance9.mesh.GetTriangles(meshInstance9.subMeshIndex);
				for (int k = 0; k < triangles2.Length; k++)
				{
					array8[k + num5] = triangles2[k] + num7;
				}
				num5 += triangles2.Length;
			}
			num7 += meshInstance9.mesh.vertexCount;
		}
		Mesh mesh = new Mesh();
		mesh.name = "Combined Mesh";
		mesh.vertices = array2;
		mesh.normals = array3;
		mesh.colors = array7;
		mesh.uv = array5;
		mesh.uv2 = array6;
		mesh.tangents = array4;
		if (generateStrips)
		{
			mesh.SetTriangles(array9, 0);
		}
		else
		{
			mesh.triangles = array8;
		}
		return mesh;
	}

	private static void Copy(int vertexcount, Vector3[] src, Vector3[] dst, ref int offset, Matrix4x4 transform)
	{
		for (int i = 0; i < src.Length; i++)
		{
			dst[i + offset] = transform.MultiplyPoint(src[i]);
		}
		offset += vertexcount;
	}

	private static void CopyNormal(int vertexcount, Vector3[] src, Vector3[] dst, ref int offset, Matrix4x4 transform)
	{
		for (int i = 0; i < src.Length; i++)
		{
			dst[i + offset] = transform.MultiplyVector(src[i]).normalized;
		}
		offset += vertexcount;
	}

	private static void Copy(int vertexcount, Vector2[] src, Vector2[] dst, ref int offset)
	{
		for (int i = 0; i < src.Length; i++)
		{
			dst[i + offset] = src[i];
		}
		offset += vertexcount;
	}

	private static void CopyColors(int vertexcount, Color[] src, Color[] dst, ref int offset)
	{
		for (int i = 0; i < src.Length; i++)
		{
			dst[i + offset] = src[i];
		}
		offset += vertexcount;
	}

	private static void CopyTangents(int vertexcount, Vector4[] src, Vector4[] dst, ref int offset, Matrix4x4 transform)
	{
		for (int i = 0; i < src.Length; i++)
		{
			Vector4 vector = src[i];
			Vector3 vector2 = new Vector3(vector.x, vector.y, vector.z);
			vector2 = transform.MultiplyVector(vector2).normalized;
			dst[i + offset] = new Vector4(vector2.x, vector2.y, vector2.z, vector.w);
		}
		offset += vertexcount;
	}
}
public class F3DBurnoutExample : MonoBehaviour
{
	private MeshRenderer[] turretParts;

	private int BurnoutID;

	private void Start()
	{
		BurnoutID = Shader.PropertyToID("_BurnOut");
		turretParts = GetComponentsInChildren<MeshRenderer>();
	}

	private void Update()
	{
		for (int i = 0; i < turretParts.Length; i++)
		{
			turretParts[i].material.SetFloat(BurnoutID, Mathf.Lerp(0f, 2f, Mathf.Sin(Time.time) / 2f));
		}
	}
}
public class F3DDummyEvent : MonoBehaviour
{
	private void Start()
	{
		BroadcastMessage("OnSpawned", SendMessageOptions.DontRequireReceiver);
	}
}
public class F3DMissileLauncher : MonoBehaviour
{
	public static F3DMissileLauncher instance;

	public Transform missilePrefab;

	public Transform target;

	public Transform explosionPrefab;

	private F3DMissile.MissileType missileType;

	public Text missileTypeLabel;

	private void Start()
	{
		instance = this;
		missileType = F3DMissile.MissileType.Unguided;
		missileTypeLabel.text = "Missile type: Unguided";
	}

	public void SpawnExplosion(Vector3 position)
	{
		F3DPool.instance.Spawn(explosionPrefab, position, Quaternion.identity, null);
	}

	private void ProcessInput()
	{
		if (Input.GetMouseButtonDown(0))
		{
			Transform transform = F3DPool.instance.Spawn(missilePrefab, base.transform.position + Vector3.up * 2f, Quaternion.identity, null);
			if (transform != null)
			{
				F3DMissile component = transform.GetComponent<F3DMissile>();
				component.missileType = missileType;
				if (target != null)
				{
					component.target = target;
				}
			}
		}
		if (Input.GetKeyDown(KeyCode.Alpha1))
		{
			missileType = F3DMissile.MissileType.Unguided;
			missileTypeLabel.text = "Missile type: Unguided";
		}
		else if (Input.GetKeyDown(KeyCode.Alpha2))
		{
			missileType = F3DMissile.MissileType.Guided;
			missileTypeLabel.text = "Missile type: Guided";
		}
		else if (Input.GetKeyDown(KeyCode.Alpha3))
		{
			missileType = F3DMissile.MissileType.Predictive;
			missileTypeLabel.text = "Missile type: Predictive";
		}
	}

	private void Update()
	{
		ProcessInput();
	}
}
public class F3DNebula : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
		base.transform.position -= Vector3.forward * Time.deltaTime * 1000f;
		if (base.transform.position.z < -2150f)
		{
			Vector3 position = base.transform.position;
			position.z = 2150f;
			base.transform.position = position;
			base.transform.rotation = UnityEngine.Random.rotation;
			base.transform.localScale = new Vector3(1f, 1f, 1f) * UnityEngine.Random.Range(200, 800);
		}
	}
}
public class F3DTrailExample : MonoBehaviour
{
	public float Mult;

	public float TimeMult;

	private Vector3 defaultPos;

	private void Start()
	{
		defaultPos = base.transform.position;
	}

	private void Update()
	{
		base.transform.position = defaultPos + new Vector3(Mathf.Sin(Time.time * TimeMult) * Mult, 0f, Mathf.Cos(Time.time * TimeMult) * Mult);
	}
}
public class F3DTurnTable : MonoBehaviour
{
	public float speed;

	private void Start()
	{
	}

	private void Update()
	{
		base.transform.rotation = base.transform.rotation * Quaternion.Euler(0f, speed * Time.deltaTime, 0f);
	}
}
[RequireComponent(typeof(CharacterController))]
public class FPSWalkerEnhanced : MonoBehaviour
{
	public float walkSpeed = 6f;

	public float runSpeed = 11f;

	public bool limitDiagonalSpeed = true;

	public bool toggleRun;

	public float jumpSpeed = 8f;

	public float gravity = 20f;

	public float fallingDamageThreshold = 10f;

	public bool slideWhenOverSlopeLimit;

	public bool slideOnTaggedObjects;

	public float slideSpeed = 12f;

	public bool airControl;

	public float antiBumpFactor = 0.75f;

	public int antiBunnyHopFactor = 1;

	private Vector3 moveDirection = Vector3.zero;

	private bool grounded;

	private CharacterController controller;

	private Transform myTransform;

	private float speed;

	private RaycastHit hit;

	private float fallStartLevel;

	private bool falling;

	private float slideLimit;

	private float rayDistance;

	private Vector3 contactPoint;

	private bool playerControl;

	private int jumpTimer;

	private void Start()
	{
		controller = GetComponent<CharacterController>();
		myTransform = base.transform;
		speed = walkSpeed;
		rayDistance = controller.height * 0.5f + controller.radius;
		slideLimit = controller.slopeLimit - 0.1f;
		jumpTimer = antiBunnyHopFactor;
	}

	private void FixedUpdate()
	{
		float axis = Input.GetAxis("Horizontal");
		float axis2 = Input.GetAxis("Vertical");
		float num = ((axis != 0f && axis2 != 0f && limitDiagonalSpeed) ? 0.7071f : 1f);
		if (grounded)
		{
			bool flag = false;
			if (Physics.Raycast(myTransform.position, -Vector3.up, out hit, rayDistance))
			{
				if (Vector3.Angle(hit.normal, Vector3.up) > slideLimit)
				{
					flag = true;
				}
			}
			else
			{
				Physics.Raycast(contactPoint + Vector3.up, -Vector3.up, out hit);
				if (Vector3.Angle(hit.normal, Vector3.up) > slideLimit)
				{
					flag = true;
				}
			}
			if (falling)
			{
				falling = false;
				if (myTransform.position.y < fallStartLevel - fallingDamageThreshold)
				{
					FallingDamageAlert(fallStartLevel - myTransform.position.y);
				}
			}
			if (!toggleRun)
			{
				speed = (Input.GetButton("Run") ? runSpeed : walkSpeed);
			}
			if ((flag && slideWhenOverSlopeLimit) || (slideOnTaggedObjects && hit.collider.tag == "Slide"))
			{
				Vector3 normal = hit.normal;
				moveDirection = new Vector3(normal.x, 0f - normal.y, normal.z);
				Vector3.OrthoNormalize(ref normal, ref moveDirection);
				moveDirection *= slideSpeed;
				playerControl = false;
			}
			else
			{
				moveDirection = new Vector3(axis * num, 0f - antiBumpFactor, axis2 * num);
				moveDirection = myTransform.TransformDirection(moveDirection) * speed;
				playerControl = true;
			}
			if (!Input.GetButton("Jump"))
			{
				jumpTimer++;
			}
			else if (jumpTimer >= antiBunnyHopFactor)
			{
				moveDirection.y = jumpSpeed;
				jumpTimer = 0;
			}
		}
		else
		{
			if (!falling)
			{
				falling = true;
				fallStartLevel = myTransform.position.y;
			}
			if (airControl && playerControl)
			{
				moveDirection.x = axis * speed * num;
				moveDirection.z = axis2 * speed * num;
				moveDirection = myTransform.TransformDirection(moveDirection);
			}
		}
		moveDirection.y -= gravity * Time.deltaTime;
		grounded = (controller.Move(moveDirection * Time.deltaTime) & CollisionFlags.Below) != 0;
	}

	private void Update()
	{
		if (toggleRun && grounded && Input.GetButtonDown("Run"))
		{
			speed = ((speed == walkSpeed) ? runSpeed : walkSpeed);
		}
	}

	private void OnControllerColliderHit(ControllerColliderHit hit)
	{
		contactPoint = hit.point;
	}

	private void FallingDamageAlert(float fallDistance)
	{
		MonoBehaviour.print("Ouch! Fell " + fallDistance + " units!");
	}
}
[AddComponentMenu("Camera-Control/Smooth Mouse Look")]
public class SmoothMouseLook : MonoBehaviour
{
	public enum RotationAxes
	{
		MouseXAndY,
		MouseX,
		MouseY
	}

	public RotationAxes axes;

	public float sensitivityX = 15f;

	public float sensitivityY = 15f;

	public float minimumX = -360f;

	public float maximumX = 360f;

	public float minimumY = -60f;

	public float maximumY = 60f;

	private float rotationX;

	private float rotationY;

	private List<float> rotArrayX = new List<float>();

	private float rotAverageX;

	private List<float> rotArrayY = new List<float>();

	private float rotAverageY;

	public float frameCounter = 20f;

	private Quaternion originalRotation;

	private Quaternion parentOriginalRotation;

	private void Update()
	{
		if (!Input.GetButton("Look"))
		{
			return;
		}
		if (axes == RotationAxes.MouseXAndY)
		{
			rotAverageY = 0f;
			rotAverageX = 0f;
			rotationY += Input.GetAxis("Mouse Y") * sensitivityY;
			rotationX += Input.GetAxis("Mouse X") * sensitivityX;
			rotArrayY.Add(rotationY);
			rotArrayX.Add(rotationX);
			if ((float)rotArrayY.Count >= frameCounter)
			{
				rotArrayY.RemoveAt(0);
			}
			if ((float)rotArrayX.Count >= frameCounter)
			{
				rotArrayX.RemoveAt(0);
			}
			for (int i = 0; i < rotArrayY.Count; i++)
			{
				rotAverageY += rotArrayY[i];
			}
			for (int j = 0; j < rotArrayX.Count; j++)
			{
				rotAverageX += rotArrayX[j];
			}
			rotAverageY /= rotArrayY.Count;
			rotAverageX /= rotArrayX.Count;
			rotAverageY = ClampAngle(rotAverageY, minimumY, maximumY);
			rotAverageX = ClampAngle(rotAverageX, minimumX, maximumX);
			Quaternion quaternion = Quaternion.AngleAxis(rotAverageY, Vector3.left);
			Quaternion quaternion2 = Quaternion.AngleAxis(rotAverageX, Vector3.up);
			base.transform.localRotation = originalRotation * quaternion;
			base.transform.parent.localRotation = parentOriginalRotation * quaternion2;
		}
		else if (axes == RotationAxes.MouseX)
		{
			rotAverageX = 0f;
			rotationX += Input.GetAxis("Mouse X") * sensitivityX;
			rotArrayX.Add(rotationX);
			if ((float)rotArrayX.Count >= frameCounter)
			{
				rotArrayX.RemoveAt(0);
			}
			for (int k = 0; k < rotArrayX.Count; k++)
			{
				rotAverageX += rotArrayX[k];
			}
			rotAverageX /= rotArrayX.Count;
			rotAverageX = ClampAngle(rotAverageX, minimumX, maximumX);
			Quaternion quaternion3 = Quaternion.AngleAxis(rotAverageX, Vector3.up);
			base.transform.parent.localRotation = parentOriginalRotation * quaternion3;
		}
		else
		{
			rotAverageY = 0f;
			rotationY += Input.GetAxis("Mouse Y") * sensitivityY;
			rotArrayY.Add(rotationY);
			if ((float)rotArrayY.Count >= frameCounter)
			{
				rotArrayY.RemoveAt(0);
			}
			for (int l = 0; l < rotArrayY.Count; l++)
			{
				rotAverageY += rotArrayY[l];
			}
			rotAverageY /= rotArrayY.Count;
			rotAverageY = ClampAngle(rotAverageY, minimumY, maximumY);
			Quaternion quaternion4 = Quaternion.AngleAxis(rotAverageY, Vector3.left);
			base.transform.localRotation = originalRotation * quaternion4;
		}
	}

	private void Start()
	{
		Rigidbody component = GetComponent<Rigidbody>();
		if ((bool)component)
		{
			component.freezeRotation = true;
		}
		originalRotation = base.transform.localRotation;
		parentOriginalRotation = base.transform.parent.localRotation;
	}

	public static float ClampAngle(float angle, float min, float max)
	{
		angle %= 360f;
		if (angle >= -360f && angle <= 360f)
		{
			if (angle < -360f)
			{
				angle += 360f;
			}
			if (angle > 360f)
			{
				angle -= 360f;
			}
		}
		return Mathf.Clamp(angle, min, max);
	}
}
public class SkyboxChanger : MonoBehaviour
{
	public Material[] Skyboxes;

	private Dropdown _dropdown;

	public void Awake()
	{
		_dropdown = GetComponent<Dropdown>();
	}

	public void ChangeSkybox()
	{
		RenderSettings.skybox = Skyboxes[_dropdown.value];
		RenderSettings.skybox.SetFloat("_Rotation", 0f);
	}
}
public class SkyboxRotator : MonoBehaviour
{
	public float RotationPerSecond = 1f;

	private bool _rotate;

	protected void Update()
	{
		if (_rotate)
		{
			RenderSettings.skybox.SetFloat("_Rotation", Time.time * RotationPerSecond);
		}
	}

	public void ToggleSkyboxRotation()
	{
		_rotate = !_rotate;
	}
}
public class FallingBehavior : StateMachineBehaviour
{
	private RaycastHit JumpRay;

	private float dragoFloat;

	private float MaxHeight;

	public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		animator.SetFloat("DragoFloat", 1f);
		animator.GetComponent<DragonController>().MaxHeight = 0f;
		animator.applyRootMotion = false;
		animator.GetComponent<Rigidbody>().drag = 0f;
	}

	public override void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
	}

	public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		if (Physics.Raycast(animator.transform.position, -Vector3.up, out JumpRay, 100f))
		{
			if (animator.GetComponent<DragonController>().MaxHeight < JumpRay.distance)
			{
				animator.GetComponent<DragonController>().MaxHeight = JumpRay.distance;
			}
			float value = Mathf.Lerp(animator.GetFloat("DragoFloat"), JumpRay.distance / animator.GetComponent<DragonController>().MaxHeight - 0.33f, Time.deltaTime * 5f);
			animator.SetFloat("DragoFloat", value);
		}
	}
}
public class FlyBehavior : StateMachineBehaviour
{
	private int restore = 10;

	private Transform dragoTransform;

	public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		animator.SetFloat("DragoFloat", 0f);
		dragoTransform = animator.transform;
	}

	public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		if (!animator.IsInTransition(0) && !animator.applyRootMotion)
		{
			animator.GetComponent<Rigidbody>().drag = Mathf.Lerp(animator.GetComponent<Rigidbody>().drag, restore, Time.deltaTime * 10f);
			if (animator.GetComponent<Rigidbody>().drag > (float)restore - 0.1f)
			{
				animator.applyRootMotion = true;
				animator.GetComponent<Rigidbody>().drag = 0f;
			}
			dragoTransform.position = Vector3.Lerp(dragoTransform.position, dragoTransform.position + animator.velocity * animator.GetFloat("Vertical") / dragoTransform.GetComponent<DragonController>().MaxSpeed / animator.GetFloat("FlySpeed"), Time.deltaTime);
		}
	}

	public override void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
	}
}
public class JumpBehavior : StateMachineBehaviour
{
	private RaycastHit JumpRay;

	private DragonController myDrago;

	private float dragoFloat;

	private float MaxJumpPoint;

	public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		MaxJumpPoint = animator.transform.position.y;
		animator.SetFloat("DragoFloat", 1f);
		animator.SetInteger("DragoInt", 1);
		animator.applyRootMotion = true;
		myDrago = animator.GetComponent<DragonController>();
		myDrago.MaxHeight = 0f;
	}

	public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		if (Physics.Raycast(animator.transform.position, -Vector3.up, out JumpRay, 10f, myDrago.GroundLayer))
		{
			if (MaxJumpPoint - JumpRay.point.y > 0.03f)
			{
				animator.SetInteger("DragoInt", 0);
			}
			else
			{
				animator.SetInteger("DragoInt", 1);
			}
		}
	}
}
public class RandomBehavior : StateMachineBehaviour
{
	public int Range;

	public override void OnStateMachineEnter(Animator animator, int stateMachinePathHash)
	{
		animator.SetInteger("DragoInt", UnityEngine.Random.Range(0, Range));
		if (animator.GetCurrentAnimatorStateInfo(0).IsTag("Idle"))
		{
			animator.GetComponent<DragonController>().Tired++;
			if (animator.GetComponent<DragonController>().Tired >= animator.GetComponent<DragonController>().GotoSleep - 1)
			{
				animator.SetInteger("DragoInt", -1);
				animator.GetComponent<DragonController>().Tired = 0;
			}
		}
	}
}
public class RecoverBehavior : StateMachineBehaviour
{
	private RaycastHit JumpRay;

	private float dragoFloat;

	private float MaxHeight;

	public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		if (animator.GetCurrentAnimatorStateInfo(0).IsName("Locomotion") && !animator.applyRootMotion)
		{
			animator.applyRootMotion = true;
			animator.GetComponent<Rigidbody>().drag = 0f;
		}
	}

	public override void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		if (!animator.applyRootMotion)
		{
			animator.applyRootMotion = true;
			animator.GetComponent<Rigidbody>().drag = 0f;
		}
	}

	public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		animator.applyRootMotion = false;
		if (stateInfo.normalizedTime < 0.9f)
		{
			animator.GetComponent<Rigidbody>().drag = Mathf.Lerp(animator.GetComponent<Rigidbody>().drag, 3f, Time.deltaTime * 10f);
			return;
		}
		animator.applyRootMotion = true;
		animator.GetComponent<Rigidbody>().drag = 0f;
	}
}
public class DragoEyes : MonoBehaviour
{
	public Animator DragoEyesAnims;

	public Transform EyesMesh;

	public Material[] EyesColors;

	private int dragmaterial;

	private int dragoEyes;

	private void Start()
	{
		dragoEyes = 1;
		dragmaterial = 0;
	}

	private void Update()
	{
		DragoEyesAnims.SetInteger("DragoEyes", dragoEyes);
	}

	public void Eyes(int v)
	{
		dragoEyes = v;
	}

	public void ChangeColor(Transform eyes)
	{
		eyes.GetComponent<MeshRenderer>().material = EyesColors[dragmaterial];
		dragmaterial++;
		if (dragmaterial == EyesColors.Length)
		{
			dragmaterial = 0;
		}
	}
}
public class DragoFire : MonoBehaviour
{
	private Animator anim;

	[Header("Dragon Fire")]
	public float FireBallSpeed = 500f;

	public Transform FirePoint;

	public GameObject FireBall;

	public GameObject FireBreath;

	private GameObject firebreathinstance;

	private ParticleSystem.EmissionModule emision;

	private void Start()
	{
		anim = GetComponent<Animator>();
		GameObject gameObject = UnityEngine.Object.Instantiate(FireBreath);
		gameObject.transform.parent = FirePoint;
		gameObject.transform.position = FirePoint.position;
		emision = gameObject.GetComponent<ParticleSystem>().emission;
		emision.rate = new ParticleSystem.MinMaxCurve(0f);
	}

	public void FireAttack(int type)
	{
		if ((bool)FireBall && type == 1 && (anim.GetCurrentAnimatorStateInfo(0).IsTag("Attack Fire") || anim.GetNextAnimatorStateInfo(0).IsTag("Attack Fire") || anim.GetCurrentAnimatorStateInfo(1).IsTag("Attack Fire") || anim.GetNextAnimatorStateInfo(1).IsTag("Attack Fire")))
		{
			GameObject obj = UnityEngine.Object.Instantiate(FireBall);
			obj.transform.position = FirePoint.transform.position;
			Vector3 vector = FirePoint.forward;
			if ((double)anim.GetFloat("UpDown") <= 0.1 && (double)anim.GetFloat("UpDown") >= -0.1)
			{
				vector = new Vector3(FirePoint.forward.x, base.transform.forward.y, FirePoint.forward.z);
			}
			obj.GetComponent<Rigidbody>().AddForce(vector * FireBallSpeed);
		}
		if ((bool)FireBreath && type == 2)
		{
			emision.rate = new ParticleSystem.MinMaxCurve(500f);
		}
		if ((bool)FireBreath && type == 3)
		{
			emision.rate = new ParticleSystem.MinMaxCurve(0f);
		}
	}
}
public class DragonController : MonoBehaviour
{
	private Animator anim;

	private Transform DragoTransform;

	private Rigidbody dragoRigidBody;

	private CapsuleCollider dragoCollider;

	private HashIDsDragons hashs;

	private float speed;

	private float direction;

	private float flyspeed = 1f;

	private float maxSpeed = 1f;

	[HideInInspector]
	public bool Jump;

	[HideInInspector]
	public bool ShiftK;

	[HideInInspector]
	public bool wounded;

	[HideInInspector]
	public bool fly;

	[HideInInspector]
	public bool dodge;

	[HideInInspector]
	public bool fall;

	private float horizontal;

	private float vertical;

	private float upDown;

	private float jumpPoint;

	private float dragoFloat;

	private int dragoInt;

	private float jumpingCurve;

	private bool stand = true;

	private bool grounded;

	[HideInInspector]
	public bool attack1;

	[HideInInspector]
	public bool attack2;

	[HideInInspector]
	public bool Stun;

	private bool fowardPressed;

	public LayerMask GroundLayer;

	public float TurnSpeed = 0.6f;

	public int GotoSleep;

	private RaycastHit hit_Hip;

	private RaycastHit hit_Chest;

	private Vector3 Drago_Hip;

	private Vector3 Drago_Chest;

	private float scaleFactor;

	private Pivots[] pivots;

	private float maxHeight;

	[HideInInspector]
	public int Tired;

	public float JumpPoint
	{
		get
		{
			return jumpPoint;
		}
		set
		{
			jumpPoint = value;
		}
	}

	public float MaxSpeed
	{
		get
		{
			return maxSpeed;
		}
		set
		{
			maxSpeed = value;
		}
	}

	public float MaxHeight
	{
		get
		{
			return maxHeight;
		}
		set
		{
			maxHeight = value;
		}
	}

	public int DragoInt
	{
		get
		{
			return dragoInt;
		}
		set
		{
			dragoInt = value;
		}
	}

	public float DragoFloat
	{
		get
		{
			return dragoFloat;
		}
		set
		{
			dragoFloat = value;
		}
	}

	private void Start()
	{
		anim = GetComponent<Animator>();
		hashs = GetComponent<HashIDsDragons>();
		DragoTransform = base.transform;
		dragoCollider = GetComponent<CapsuleCollider>();
		dragoRigidBody = GetComponent<Rigidbody>();
		Tired = 0;
		pivots = GetComponentsInChildren<Pivots>();
		scaleFactor = DragoTransform.localScale.y;
	}

	private void getButtons()
	{
		fowardPressed = Input.GetKey(KeyCode.W) || Input.GetKey(KeyCode.UpArrow);
		if (CrossPlatformInputManager.GetAxis("Vertical") > 0f)
		{
			fowardPressed = true;
		}
		else
		{
			fowardPressed = false;
		}
		horizontal = CrossPlatformInputManager.GetAxis("Horizontal");
		vertical = CrossPlatformInputManager.GetAxis("Vertical");
		ShiftK = Input.GetKey(KeyCode.LeftShift);
		attack2 = CrossPlatformInputManager.GetButton("Fire2");
		if (Input.GetKeyDown(KeyCode.Q))
		{
			fly = !fly;
			dragoInt = 0;
		}
		dodge = Input.GetKey(KeyCode.E);
		Jump = CrossPlatformInputManager.GetButton("Jump");
		Stun = Input.GetMouseButton(2);
	}

	private void LinkingAnimator(Animator anim_)
	{
		anim_.SetBool(hashs.attack1Hash, attack1);
		anim_.SetBool(hashs.injuredHash, wounded);
		attack1 = false;
		wounded = false;
	}

	private void TurnAmount()
	{
	}

	private void FixPosition()
	{
	}

	private void Falling()
	{
	}

	private bool isJumping(float normalizedtime, bool half)
	{
		if (half)
		{
			if (anim.GetCurrentAnimatorStateInfo(0).IsTag("Jump") && anim.GetCurrentAnimatorStateInfo(0).normalizedTime < normalizedtime)
			{
				return true;
			}
			if (anim.GetNextAnimatorStateInfo(0).IsTag("Jump") && anim.GetNextAnimatorStateInfo(0).normalizedTime < normalizedtime)
			{
				return true;
			}
		}
		else
		{
			if (anim.GetCurrentAnimatorStateInfo(0).IsTag("Jump") && anim.GetCurrentAnimatorStateInfo(0).normalizedTime > normalizedtime)
			{
				return true;
			}
			if (anim.GetNextAnimatorStateInfo(0).IsTag("Jump") && anim.GetNextAnimatorStateInfo(0).normalizedTime > normalizedtime)
			{
				return true;
			}
		}
		return false;
	}

	private bool isJumping()
	{
		if (anim.GetCurrentAnimatorStateInfo(0).IsTag("Jump"))
		{
			return true;
		}
		if (anim.GetNextAnimatorStateInfo(0).IsTag("Jump"))
		{
			return true;
		}
		return false;
	}

	private void Update()
	{
		getButtons();
		FixPosition();
		Falling();
		TurnAmount();
		if (horizontal != 0f || vertical != 0f || Tired >= GotoSleep)
		{
			stand = false;
		}
		else
		{
			stand = true;
		}
		stand = false;
		if (!fly)
		{
			if (Input.GetKeyDown(KeyCode.Alpha1))
			{
				maxSpeed = 1f;
			}
			if (Input.GetKeyDown(KeyCode.Alpha2))
			{
				maxSpeed = 2f;
			}
			if (Input.GetKeyDown(KeyCode.Alpha3))
			{
				maxSpeed = 3f;
			}
		}
		else
		{
			if (Input.GetKeyDown(KeyCode.Alpha1))
			{
				flyspeed = 1f;
			}
			if (Input.GetKeyDown(KeyCode.Alpha2))
			{
				flyspeed = 1.25f;
			}
			if (Input.GetKeyDown(KeyCode.Alpha3))
			{
				flyspeed = 1.35f;
			}
		}
		int num = 1;
		float num2 = 1f;
		if (ShiftK)
		{
			if (maxSpeed != 3f)
			{
				num = 2;
			}
			if (fly)
			{
				num2 = 2f;
				DragoFloat = Mathf.Lerp(DragoFloat, 1f, Time.deltaTime * 5f);
			}
		}
		else if (fly)
		{
			DragoFloat = Mathf.Lerp(DragoFloat, 0f, Time.deltaTime * 5f);
		}
		speed = Mathf.Lerp(speed, maxSpeed * (float)num, Time.deltaTime * 2f);
		direction = Mathf.Lerp(direction, horizontal * num2, Time.deltaTime * 8f);
		if (Jump || attack2 || wounded || Stun)
		{
			stand = false;
		}
		if (fly)
		{
			if (Jump)
			{
				upDown = Mathf.Lerp(upDown, 1f, Time.deltaTime * 2f);
			}
			else if (Input.GetKey(KeyCode.C))
			{
				upDown = Mathf.Lerp(upDown, -1f, Time.deltaTime * 2f);
			}
			else
			{
				upDown = Mathf.Lerp(upDown, 0f, Time.deltaTime * 2f);
			}
		}
		if (grounded)
		{
			fly = false;
			upDown = 0f;
		}
		if (!stand || attack1 || attack2 || Jump || ShiftK)
		{
			Tired = 0;
		}
		LinkingAnimator(anim);
	}
}
public class Fireball : MonoBehaviour
{
	public float Force = 10f;

	public float Radius = 10f;

	public GameObject explotion;

	private void OnTriggerEnter(Collider other)
	{
		Rigidbody component = other.GetComponent<Rigidbody>();
		if ((bool)component)
		{
			component.AddExplosionForce(100f * Force, base.transform.position, 100f * Radius);
		}
		UnityEngine.Object.Destroy(base.gameObject);
		GameObject obj = UnityEngine.Object.Instantiate(explotion);
		obj.transform.position = base.transform.position;
		UnityEngine.Object.Destroy(obj, 2f);
	}
}
public class HashIDsDragons : MonoBehaviour
{
	[HideInInspector]
	public int verticalHash;

	[HideInInspector]
	public int horizontalHash;

	[HideInInspector]
	public int updownHash;

	[HideInInspector]
	public int standHash;

	[HideInInspector]
	public int jumpHash;

	[HideInInspector]
	public int flyHash;

	[HideInInspector]
	public int dodgeHash;

	[HideInInspector]
	public int fallHash;

	[HideInInspector]
	public int groundedHash;

	[HideInInspector]
	public int fowardPressedHash;

	[HideInInspector]
	public int shiftHash;

	[HideInInspector]
	public int flySpeedHash;

	[HideInInspector]
	public int attack1Hash;

	[HideInInspector]
	public int attack2Hash;

	[HideInInspector]
	public int deathHash;

	[HideInInspector]
	public int injuredHash;

	[HideInInspector]
	public int stunnedHash;

	[HideInInspector]
	public int intDragonHash;

	[HideInInspector]
	public int floatDragonHash;

	private void Awake()
	{
		verticalHash = Animator.StringToHash("Vertical");
		horizontalHash = Animator.StringToHash("Horizontal");
		updownHash = Animator.StringToHash("UpDown");
		standHash = Animator.StringToHash("Stand");
		jumpHash = Animator.StringToHash("Jump");
		flyHash = Animator.StringToHash("Fly");
		fallHash = Animator.StringToHash("Fall");
		groundedHash = Animator.StringToHash("Grounded");
		dodgeHash = Animator.StringToHash("Dodge");
		fowardPressedHash = Animator.StringToHash("FowardPressed");
		shiftHash = Animator.StringToHash("Shift");
		flySpeedHash = Animator.StringToHash("FlySpeed");
		deathHash = Animator.StringToHash("Death");
		attack1Hash = Animator.StringToHash("Attack1");
		attack2Hash = Animator.StringToHash("Attack2");
		injuredHash = Animator.StringToHash("Damaged");
		stunnedHash = Animator.StringToHash("Stunned");
		intDragonHash = Animator.StringToHash("DragoInt");
		floatDragonHash = Animator.StringToHash("DragoFloat");
	}
}
public class Pivots : MonoBehaviour
{
}
public class BakeTexturesAtRuntime : MonoBehaviour
{
	public GameObject target;

	private float elapsedTime;

	private MB3_TextureBaker.CreateAtlasesCoroutineResult result = new MB3_TextureBaker.CreateAtlasesCoroutineResult();

	private void OnGUI()
	{
		GUILayout.Label("Time to bake textures: " + elapsedTime);
		if (GUILayout.Button("Combine textures & build combined mesh all at once"))
		{
			MB3_MeshBaker componentInChildren = target.GetComponentInChildren<MB3_MeshBaker>();
			MB3_TextureBaker component = target.GetComponent<MB3_TextureBaker>();
			component.textureBakeResults = ScriptableObject.CreateInstance<MB2_TextureBakeResults>();
			component.resultMaterial = new Material(Shader.Find("Diffuse"));
			float realtimeSinceStartup = Time.realtimeSinceStartup;
			component.CreateAtlases();
			elapsedTime = Time.realtimeSinceStartup - realtimeSinceStartup;
			componentInChildren.ClearMesh();
			componentInChildren.textureBakeResults = component.textureBakeResults;
			componentInChildren.AddDeleteGameObjects(component.GetObjectsToCombine().ToArray(), null, disableRendererInSource: true);
			componentInChildren.Apply();
		}
		if (GUILayout.Button("Combine textures & build combined mesh using coroutine"))
		{
			UnityEngine.Debug.Log("Starting to bake textures on frame " + Time.frameCount);
			MB3_TextureBaker component2 = target.GetComponent<MB3_TextureBaker>();
			component2.textureBakeResults = ScriptableObject.CreateInstance<MB2_TextureBakeResults>();
			component2.resultMaterial = new Material(Shader.Find("Diffuse"));
			component2.onBuiltAtlasesSuccess = OnBuiltAtlasesSuccess;
			StartCoroutine(component2.CreateAtlasesCoroutine(null, result));
		}
	}

	private void OnBuiltAtlasesSuccess()
	{
		UnityEngine.Debug.Log("Calling success callback. baking meshes");
		MB3_MeshBaker componentInChildren = target.GetComponentInChildren<MB3_MeshBaker>();
		MB3_TextureBaker component = target.GetComponent<MB3_TextureBaker>();
		if (result.isFinished && result.success)
		{
			componentInChildren.ClearMesh();
			componentInChildren.textureBakeResults = component.textureBakeResults;
			componentInChildren.AddDeleteGameObjects(component.GetObjectsToCombine().ToArray(), null, disableRendererInSource: true);
			componentInChildren.Apply();
		}
		UnityEngine.Debug.Log("Completed baking textures on frame " + Time.frameCount);
	}
}
public class MB_BatchPrepareObjectsForDynamicBatchingDescription : MonoBehaviour
{
	private void OnGUI()
	{
		GUILayout.Label("This scene is set up to create a combined material and meshes with adjusted UVs so \n objects can share a material and be batched by Unity's static/dynamic batching.\n This scene has added a BatchPrefabBaker component to a Mesh and Material Baker which \n  can bake many prefabs (each of which can have several renderers) in one click.\n The batching tool accepts prefab assets instead of scene objects. \n");
	}
}
public class MB_SwapShirts : MonoBehaviour
{
	public MB3_MeshBaker meshBaker;

	public Renderer[] clothingAndBodyPartsBareTorso;

	public Renderer[] clothingAndBodyPartsBareTorsoDamagedArm;

	public Renderer[] clothingAndBodyPartsHoodie;

	private void OnGUI()
	{
		if (GUILayout.Button("Wear Hoodie"))
		{
			ChangeOutfit(clothingAndBodyPartsHoodie);
		}
		if (GUILayout.Button("Bare Torso"))
		{
			ChangeOutfit(clothingAndBodyPartsBareTorso);
		}
		if (GUILayout.Button("Damaged Arm"))
		{
			ChangeOutfit(clothingAndBodyPartsBareTorsoDamagedArm);
		}
	}

	private void ChangeOutfit(Renderer[] outfit)
	{
		List<GameObject> list = new List<GameObject>();
		foreach (GameObject item in meshBaker.meshCombiner.GetObjectsInCombined())
		{
			Renderer component = item.GetComponent<Renderer>();
			bool flag = false;
			for (int i = 0; i < outfit.Length; i++)
			{
				if (component == outfit[i])
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				list.Add(component.gameObject);
				UnityEngine.Debug.Log("Removing " + component.gameObject);
			}
		}
		List<GameObject> list2 = new List<GameObject>();
		for (int j = 0; j < outfit.Length; j++)
		{
			if (!meshBaker.meshCombiner.GetObjectsInCombined().Contains(outfit[j].gameObject))
			{
				list2.Add(outfit[j].gameObject);
				UnityEngine.Debug.Log("Adding " + outfit[j].gameObject);
			}
		}
		meshBaker.AddDeleteGameObjects(list2.ToArray(), list.ToArray(), disableRendererInSource: true);
		meshBaker.Apply();
	}
}
public class MB_PrepareObjectsForDynamicBatchingDescription : MonoBehaviour
{
	private void OnGUI()
	{
		GUILayout.Label("This scene creates a combined material and meshes with adjusted UVs so objects \n can share a material and be batched by Unity's static/dynamic batching.\n Output has been set to 'bakeMeshAssetsInPlace' on the Mesh Baker\n Position, Scale and Rotation will be baked into meshes so place them appropriately.\n Dynamic batching requires objects with uniform scale. You can fix non-uniform scale here\n After baking you need to duplicate your source prefab assets and replace the  \n meshes and materials with the generated ones.\n");
	}
}
public class MB_DynamicAddDeleteExample : MonoBehaviour
{
	public GameObject prefab;

	private List<GameObject> objsInCombined = new List<GameObject>();

	private MB3_MeshBaker mbd;

	private GameObject[] objs;

	private void Start()
	{
		mbd = GetComponentInChildren<MB3_MeshBaker>();
		int num = 25;
		GameObject[] array = new GameObject[num * num];
		for (int i = 0; i < num; i++)
		{
			for (int j = 0; j < num; j++)
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(prefab);
				array[i * num + j] = gameObject.GetComponentInChildren<MeshRenderer>().gameObject;
				gameObject.transform.position = new Vector3(9f * (float)i, 0f, 9f * (float)j);
				if ((i * num + j) % 3 == 0)
				{
					objsInCombined.Add(array[i * num + j]);
				}
			}
		}
		mbd.AddDeleteGameObjects(array, null, disableRendererInSource: true);
		mbd.Apply();
		objs = objsInCombined.ToArray();
		StartCoroutine(largeNumber());
	}

	private IEnumerator largeNumber()
	{
		while (true)
		{
			yield return new WaitForSeconds(1.5f);
			mbd.AddDeleteGameObjects(null, objs, disableRendererInSource: true);
			mbd.Apply();
			yield return new WaitForSeconds(1.5f);
			mbd.AddDeleteGameObjects(objs, null, disableRendererInSource: true);
			mbd.Apply();
		}
	}

	private void OnGUI()
	{
		GUILayout.Label("Dynamically instantiates game objects. \nRepeatedly adds and removes some of them\n from the combined mesh.");
	}
}
public class MB_Example : MonoBehaviour
{
	public MB3_MeshBaker meshbaker;

	public GameObject[] objsToCombine;

	private void Start()
	{
		meshbaker.AddDeleteGameObjects(objsToCombine, null, disableRendererInSource: true);
		meshbaker.Apply();
	}

	private void LateUpdate()
	{
		meshbaker.UpdateGameObjects(objsToCombine);
		meshbaker.Apply(triangles: false, vertices: true, normals: true, tangents: true, uvs: false, uv2: false, uv3: false, uv4: false, colors: false);
	}

	private void OnGUI()
	{
		GUILayout.Label("Dynamically updates the vertices, normals and tangents in combined mesh every frame.\nThis is similar to dynamic batching. It is not recommended to do this every frame.\nAlso consider baking the mesh renderer objects into a skinned mesh renderer\nThe skinned mesh approach is faster for objects that need to move independently of each other every frame.");
	}
}
public class MB_ExampleMover : MonoBehaviour
{
	public int axis;

	private void Update()
	{
		Vector3 position = new Vector3(5f, 5f, 5f);
		position[axis] *= Mathf.Sin(Time.time);
		base.transform.position = position;
	}
}
public class MB_ExampleSkinnedMeshDescription : MonoBehaviour
{
	private void OnGUI()
	{
		GUILayout.Label("Mesh Renderer objects have been baked into a skinned mesh. Each source object\n is still in the scene (with renderer disabled) and becomes a bone. Any scripts, animations,\n or physics that affect the invisible source objects will be visible in the\nSkinned Mesh. This approach is more efficient than either dynamic batching or updating every frame \n for many small objects that constantly and independently move. \n With this approach pay attention to the SkinnedMeshRenderer Bounds and Animation Culling\nsettings. You may need to write your own script to manage/update these or your object may vanish or stop animating.\n You can update the combined mesh at runtime as objects are added and deleted from the scene.");
	}
}
public class MB_SkinnedMeshSceneController : MonoBehaviour
{
	public GameObject swordPrefab;

	public GameObject hatPrefab;

	public GameObject glassesPrefab;

	public GameObject workerPrefab;

	public GameObject targetCharacter;

	public MB3_MeshBaker skinnedMeshBaker;

	private GameObject swordInstance;

	private GameObject glassesInstance;

	private GameObject hatInstance;

	private void Start()
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(workerPrefab);
		gameObject.transform.position = new Vector3(1.31f, 0.985f, -0.25f);
		Animation component = gameObject.GetComponent<Animation>();
		component.wrapMode = WrapMode.Loop;
		component.cullingType = AnimationCullingType.AlwaysAnimate;
		component.Play("run");
		GameObject[] gos = new GameObject[1] { gameObject.GetComponentInChildren<SkinnedMeshRenderer>().gameObject };
		skinnedMeshBaker.AddDeleteGameObjects(gos, null, disableRendererInSource: true);
		skinnedMeshBaker.Apply();
	}

	private void OnGUI()
	{
		if (GUILayout.Button("Add/Remove Sword"))
		{
			if (swordInstance == null)
			{
				Transform parent = SearchHierarchyForBone(targetCharacter.transform, "RightHandAttachPoint");
				swordInstance = UnityEngine.Object.Instantiate(swordPrefab);
				swordInstance.transform.parent = parent;
				swordInstance.transform.localPosition = Vector3.zero;
				swordInstance.transform.localRotation = Quaternion.identity;
				swordInstance.transform.localScale = Vector3.one;
				GameObject[] gos = new GameObject[1] { swordInstance.GetComponentInChildren<MeshRenderer>().gameObject };
				skinnedMeshBaker.AddDeleteGameObjects(gos, null, disableRendererInSource: true);
				skinnedMeshBaker.Apply();
			}
			else if (skinnedMeshBaker.CombinedMeshContains(swordInstance.GetComponentInChildren<MeshRenderer>().gameObject))
			{
				GameObject[] deleteGOs = new GameObject[1] { swordInstance.GetComponentInChildren<MeshRenderer>().gameObject };
				skinnedMeshBaker.AddDeleteGameObjects(null, deleteGOs, disableRendererInSource: true);
				skinnedMeshBaker.Apply();
				UnityEngine.Object.Destroy(swordInstance);
				swordInstance = null;
			}
		}
		if (GUILayout.Button("Add/Remove Hat"))
		{
			if (hatInstance == null)
			{
				Transform parent2 = SearchHierarchyForBone(targetCharacter.transform, "HeadAttachPoint");
				hatInstance = UnityEngine.Object.Instantiate(hatPrefab);
				hatInstance.transform.parent = parent2;
				hatInstance.transform.localPosition = Vector3.zero;
				hatInstance.transform.localRotation = Quaternion.identity;
				hatInstance.transform.localScale = Vector3.one;
				GameObject[] gos2 = new GameObject[1] { hatInstance.GetComponentInChildren<MeshRenderer>().gameObject };
				skinnedMeshBaker.AddDeleteGameObjects(gos2, null, disableRendererInSource: true);
				skinnedMeshBaker.Apply();
			}
			else if (skinnedMeshBaker.CombinedMeshContains(hatInstance.GetComponentInChildren<MeshRenderer>().gameObject))
			{
				GameObject[] deleteGOs2 = new GameObject[1] { hatInstance.GetComponentInChildren<MeshRenderer>().gameObject };
				skinnedMeshBaker.AddDeleteGameObjects(null, deleteGOs2, disableRendererInSource: true);
				skinnedMeshBaker.Apply();
				UnityEngine.Object.Destroy(hatInstance);
				hatInstance = null;
			}
		}
		if (GUILayout.Button("Add/Remove Glasses"))
		{
			if (glassesInstance == null)
			{
				Transform parent3 = SearchHierarchyForBone(targetCharacter.transform, "NoseAttachPoint");
				glassesInstance = UnityEngine.Object.Instantiate(glassesPrefab);
				glassesInstance.transform.parent = parent3;
				glassesInstance.transform.localPosition = Vector3.zero;
				glassesInstance.transform.localRotation = Quaternion.identity;
				glassesInstance.transform.localScale = Vector3.one;
				GameObject[] gos3 = new GameObject[1] { glassesInstance.GetComponentInChildren<MeshRenderer>().gameObject };
				skinnedMeshBaker.AddDeleteGameObjects(gos3, null, disableRendererInSource: true);
				skinnedMeshBaker.Apply();
			}
			else if (skinnedMeshBaker.CombinedMeshContains(glassesInstance.GetComponentInChildren<MeshRenderer>().gameObject))
			{
				GameObject[] deleteGOs3 = new GameObject[1] { glassesInstance.GetComponentInChildren<MeshRenderer>().gameObject };
				skinnedMeshBaker.AddDeleteGameObjects(null, deleteGOs3, disableRendererInSource: true);
				skinnedMeshBaker.Apply();
				UnityEngine.Object.Destroy(glassesInstance);
				glassesInstance = null;
			}
		}
	}

	public Transform SearchHierarchyForBone(Transform current, string name)
	{
		if (current.name.Equals(name))
		{
			return current;
		}
		for (int i = 0; i < current.childCount; i++)
		{
			Transform transform = SearchHierarchyForBone(current.GetChild(i), name);
			if (transform != null)
			{
				return transform;
			}
		}
		return null;
	}
}
[Serializable]
public class MB_AtlasesAndRects
{
	public Texture2D[] atlases;

	[NonSerialized]
	public List<MB_MaterialAndUVRect> mat2rect_map;

	public string[] texPropertyNames;
}
[Serializable]
public class MB_MultiMaterial
{
	public Material combinedMaterial;

	public List<Material> sourceMaterials = new List<Material>();
}
[Serializable]
public class MB_MaterialAndUVRect
{
	public Material material;

	public Rect atlasRect;

	public string srcObjName;

	public Rect samplingRectMatAndUVTiling;

	public Rect sourceMaterialTiling;

	public Rect samplingEncapsulatinRect;

	public MB_MaterialAndUVRect(Material m, Rect destRect, Rect samplingRectMatAndUVTiling, Rect sourceMaterialTiling, Rect samplingEncapsulatinRect, string objName)
	{
		material = m;
		atlasRect = destRect;
		this.samplingRectMatAndUVTiling = samplingRectMatAndUVTiling;
		this.sourceMaterialTiling = sourceMaterialTiling;
		this.samplingEncapsulatinRect = samplingEncapsulatinRect;
		srcObjName = objName;
	}

	public override int GetHashCode()
	{
		return material.GetInstanceID() ^ samplingEncapsulatinRect.GetHashCode();
	}

	public override bool Equals(object obj)
	{
		if (!(obj is MB_MaterialAndUVRect))
		{
			return false;
		}
		if (material == ((MB_MaterialAndUVRect)obj).material)
		{
			return samplingEncapsulatinRect == ((MB_MaterialAndUVRect)obj).samplingEncapsulatinRect;
		}
		return false;
	}
}
public class MB2_TextureBakeResults : ScriptableObject
{
	public class Material2AtlasRectangleMapper
	{
		private MB2_TextureBakeResults tbr;

		private int[] numTimesMatAppearsInAtlas;

		private MB_MaterialAndUVRect[] matsAndSrcUVRect;

		public Material2AtlasRectangleMapper(MB2_TextureBakeResults res)
		{
			tbr = res;
			matsAndSrcUVRect = res.materialsAndUVRects;
			if (matsAndSrcUVRect == null || matsAndSrcUVRect.Length == 0)
			{
				matsAndSrcUVRect = new MB_MaterialAndUVRect[res.materials.Length];
				for (int i = 0; i < res.materials.Length; i++)
				{
					matsAndSrcUVRect[i] = new MB_MaterialAndUVRect(res.materials[i], res.prefabUVRects[i], new Rect(0f, 0f, 1f, 1f), new Rect(0f, 0f, 1f, 1f), new Rect(0f, 0f, 1f, 1f), "");
				}
				res.materialsAndUVRects = matsAndSrcUVRect;
			}
			numTimesMatAppearsInAtlas = new int[matsAndSrcUVRect.Length];
			for (int j = 0; j < matsAndSrcUVRect.Length; j++)
			{
				if (numTimesMatAppearsInAtlas[j] > 1)
				{
					continue;
				}
				int num = 1;
				for (int k = j + 1; k < matsAndSrcUVRect.Length; k++)
				{
					if (matsAndSrcUVRect[j].material == matsAndSrcUVRect[k].material)
					{
						num++;
					}
				}
				numTimesMatAppearsInAtlas[j] = num;
				if (num <= 1)
				{
					continue;
				}
				for (int l = j + 1; l < matsAndSrcUVRect.Length; l++)
				{
					if (matsAndSrcUVRect[j].material == matsAndSrcUVRect[l].material)
					{
						numTimesMatAppearsInAtlas[l] = num;
					}
				}
			}
		}

		public bool TryMapMaterialToUVRect(Material mat, Mesh m, int submeshIdx, MB3_MeshCombinerSingle.MeshChannelsCache meshChannelCache, Dictionary<int, MB_Utility.MeshAnalysisResult[]> meshAnalysisCache, out Rect rectInAtlas, out Rect encapsulatingRect, out Rect sourceMaterialTilingOut, ref string errorMsg, MB2_LogLevel logLevel)
		{
			if (tbr.materialsAndUVRects.Length == 0 && tbr.materials.Length != 0)
			{
				errorMsg = "The 'Material Bake Result' needs to be re-baked to be compatible with this version of Mesh Baker. Please re-bake using the MB3_TextureBaker.";
				rectInAtlas = default(Rect);
				encapsulatingRect = default(Rect);
				sourceMaterialTilingOut = default(Rect);
				return false;
			}
			if (mat == null)
			{
				rectInAtlas = default(Rect);
				encapsulatingRect = default(Rect);
				sourceMaterialTilingOut = default(Rect);
				errorMsg = $"Mesh {m.name} Had no material on submesh {submeshIdx} cannot map to a material in the atlas";
				return false;
			}
			if (submeshIdx >= m.subMeshCount)
			{
				errorMsg = "Submesh index is greater than the number of submeshes";
				rectInAtlas = default(Rect);
				encapsulatingRect = default(Rect);
				sourceMaterialTilingOut = default(Rect);
				return false;
			}
			int num = -1;
			for (int i = 0; i < matsAndSrcUVRect.Length; i++)
			{
				if (mat == matsAndSrcUVRect[i].material)
				{
					num = i;
					break;
				}
			}
			if (num == -1)
			{
				rectInAtlas = default(Rect);
				encapsulatingRect = default(Rect);
				sourceMaterialTilingOut = default(Rect);
				errorMsg = $"Material {mat.name} could not be found in the Material Bake Result";
				return false;
			}
			if (!tbr.fixOutOfBoundsUVs)
			{
				if (numTimesMatAppearsInAtlas[num] != 1)
				{
					UnityEngine.Debug.LogError("There is a problem with this TextureBakeResults. FixOutOfBoundsUVs is false and a material appears more than once.");
				}
				rectInAtlas = matsAndSrcUVRect[num].atlasRect;
				encapsulatingRect = matsAndSrcUVRect[num].samplingEncapsulatinRect;
				sourceMaterialTilingOut = matsAndSrcUVRect[num].sourceMaterialTiling;
				return true;
			}
			if (!meshAnalysisCache.TryGetValue(m.GetInstanceID(), out var value))
			{
				value = new MB_Utility.MeshAnalysisResult[m.subMeshCount];
				for (int j = 0; j < m.subMeshCount; j++)
				{
					MB_Utility.hasOutOfBoundsUVs(meshChannelCache.GetUv0Raw(m), m, ref value[j], j);
				}
				meshAnalysisCache.Add(m.GetInstanceID(), value);
			}
			bool flag = false;
			if (logLevel >= MB2_LogLevel.trace)
			{
				UnityEngine.Debug.LogWarning($"Trying to find a rectangle in atlas capable of holding tiled sampling rect for mesh {m} using material {mat}");
			}
			for (int k = num; k < matsAndSrcUVRect.Length; k++)
			{
				if (!(matsAndSrcUVRect[k].material == mat))
				{
					continue;
				}
				Rect rect = default(Rect);
				Rect r = value[submeshIdx].uvRect;
				Rect r2 = matsAndSrcUVRect[k].sourceMaterialTiling;
				Rect r3 = matsAndSrcUVRect[k].samplingEncapsulatinRect;
				MB3_UVTransformUtility.Canonicalize(ref r3, 0f, 0f);
				rect = MB3_UVTransformUtility.CombineTransforms(ref r, ref r2);
				if (logLevel >= MB2_LogLevel.trace)
				{
					UnityEngine.Debug.Log("uvR=" + r.ToString("f5") + " matR=" + r2.ToString("f5") + "Potential Rect " + rect.ToString("f5") + " encapsulating=" + r3.ToString("f5"));
				}
				MB3_UVTransformUtility.Canonicalize(ref rect, r3.x, r3.y);
				if (logLevel >= MB2_LogLevel.trace)
				{
					UnityEngine.Debug.Log("Potential Rect Cannonical " + rect.ToString("f5") + " encapsulating=" + r3.ToString("f5"));
				}
				if (MB3_UVTransformUtility.RectContains(ref r3, ref rect))
				{
					if (logLevel >= MB2_LogLevel.trace)
					{
						UnityEngine.Debug.Log(string.Concat("Found rect in atlas capable of containing tiled sampling rect for mesh ", m, " at idx=", k));
					}
					num = k;
					flag = true;
					break;
				}
			}
			if (flag)
			{
				rectInAtlas = matsAndSrcUVRect[num].atlasRect;
				encapsulatingRect = matsAndSrcUVRect[num].samplingEncapsulatinRect;
				sourceMaterialTilingOut = matsAndSrcUVRect[num].sourceMaterialTiling;
				return true;
			}
			rectInAtlas = default(Rect);
			encapsulatingRect = default(Rect);
			sourceMaterialTilingOut = default(Rect);
			errorMsg = $"Could not find a tiled rectangle in the atlas capable of containing the uv and material tiling on mesh {m.name}";
			return false;
		}
	}

	public MB_AtlasesAndRects[] combinedMaterialInfo;

	public Material[] materials;

	public Rect[] prefabUVRects;

	public MB_MaterialAndUVRect[] materialsAndUVRects;

	public Material resultMaterial;

	public MB_MultiMaterial[] resultMaterials;

	public bool doMultiMaterial;

	public bool fixOutOfBoundsUVs;

	public static MB2_TextureBakeResults CreateForMaterialsOnRenderer(GameObject[] gos)
	{
		HashSet<Material> hashSet = new HashSet<Material>();
		for (int i = 0; i < gos.Length; i++)
		{
			if (gos[i] == null)
			{
				UnityEngine.Debug.LogError($"Game object {i} in list of objects to add was null");
				return null;
			}
			Material[] gOMaterials = MB_Utility.GetGOMaterials(gos[i]);
			if (gOMaterials == null)
			{
				UnityEngine.Debug.LogError($"Game object {i} in list of objects to add no renderer");
				return null;
			}
			for (int j = 0; j < gOMaterials.Length; j++)
			{
				hashSet.Add(gOMaterials[j]);
			}
		}
		Material[] array = new Material[hashSet.Count];
		hashSet.CopyTo(array);
		MB2_TextureBakeResults mB2_TextureBakeResults = (MB2_TextureBakeResults)ScriptableObject.CreateInstance(typeof(MB2_TextureBakeResults));
		List<MB_MaterialAndUVRect> list = new List<MB_MaterialAndUVRect>();
		for (int k = 0; k < array.Length; k++)
		{
			if (array[k] != null)
			{
				MB_MaterialAndUVRect item = new MB_MaterialAndUVRect(array[k], new Rect(0f, 0f, 1f, 1f), new Rect(0f, 0f, 1f, 1f), new Rect(0f, 0f, 1f, 1f), new Rect(0f, 0f, 1f, 1f), "");
				if (!list.Contains(item))
				{
					list.Add(item);
				}
			}
		}
		if (array.Length > 1)
		{
			mB2_TextureBakeResults.prefabUVRects = new Rect[list.Count];
			Material[] array2 = (mB2_TextureBakeResults.materials = new Material[list.Count]);
			mB2_TextureBakeResults.resultMaterials = new MB_MultiMaterial[list.Count];
			for (int l = 0; l < list.Count; l++)
			{
				array2[l] = list[l].material;
				mB2_TextureBakeResults.prefabUVRects[l] = new Rect(0f, 0f, 1f, 1f);
				mB2_TextureBakeResults.resultMaterials[l] = new MB_MultiMaterial();
				List<Material> list2 = new List<Material>();
				list2.Add(array2[l]);
				mB2_TextureBakeResults.resultMaterials[l].sourceMaterials = list2;
				mB2_TextureBakeResults.resultMaterials[l].combinedMaterial = array2[l];
			}
			mB2_TextureBakeResults.doMultiMaterial = true;
		}
		else
		{
			mB2_TextureBakeResults.doMultiMaterial = false;
			mB2_TextureBakeResults.prefabUVRects = new Rect[1]
			{
				new Rect(0f, 0f, 1f, 1f)
			};
			Material[] obj = new Material[1] { list[0].material };
			Material[] array2 = obj;
			mB2_TextureBakeResults.materials = obj;
			mB2_TextureBakeResults.resultMaterial = list[0].material;
			mB2_TextureBakeResults.resultMaterials = new MB_MultiMaterial[1]
			{
				new MB_MultiMaterial()
			};
			List<Material> list3 = new List<Material>();
			list3.Add(array2[0]);
			mB2_TextureBakeResults.resultMaterials[0].sourceMaterials = list3;
			mB2_TextureBakeResults.resultMaterials[0].combinedMaterial = list[0].material;
		}
		mB2_TextureBakeResults.materialsAndUVRects = list.ToArray();
		mB2_TextureBakeResults.fixOutOfBoundsUVs = false;
		return mB2_TextureBakeResults;
	}

	public bool ContainsMaterial(Material m)
	{
		if (materialsAndUVRects.Length == 0)
		{
			materialsAndUVRects = new MB_MaterialAndUVRect[materials.Length];
			for (int i = 0; i < materialsAndUVRects.Length; i++)
			{
				materialsAndUVRects[i] = new MB_MaterialAndUVRect(materials[i], prefabUVRects[i], new Rect(0f, 0f, 1f, 1f), new Rect(0f, 0f, 1f, 1f), new Rect(0f, 0f, 1f, 1f), "");
			}
		}
		for (int j = 0; j < materialsAndUVRects.Length; j++)
		{
			if (materialsAndUVRects[j].material == m)
			{
				return true;
			}
		}
		return false;
	}

	public string GetDescription()
	{
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.Append("Shaders:\n");
		HashSet<Shader> hashSet = new HashSet<Shader>();
		if (materialsAndUVRects != null)
		{
			for (int i = 0; i < materialsAndUVRects.Length; i++)
			{
				if (materialsAndUVRects[i].material != null)
				{
					hashSet.Add(materialsAndUVRects[i].material.shader);
				}
			}
		}
		foreach (Shader item in hashSet)
		{
			stringBuilder.Append("  ").Append(item.name).AppendLine();
		}
		stringBuilder.Append("Materials:\n");
		if (materialsAndUVRects != null)
		{
			for (int j = 0; j < materialsAndUVRects.Length; j++)
			{
				if (materialsAndUVRects[j].material != null)
				{
					stringBuilder.Append("  ").Append(materialsAndUVRects[j].material.name).AppendLine();
				}
			}
		}
		return stringBuilder.ToString();
	}
}
public class MB2_UpdateSkinnedMeshBoundsFromBones : MonoBehaviour
{
	private SkinnedMeshRenderer smr;

	private Transform[] bones;

	private void Start()
	{
		smr = GetComponent<SkinnedMeshRenderer>();
		if (smr == null)
		{
			UnityEngine.Debug.LogError("Need to attach MB2_UpdateSkinnedMeshBoundsFromBones script to an object with a SkinnedMeshRenderer component attached.");
			return;
		}
		bones = smr.bones;
		bool updateWhenOffscreen = smr.updateWhenOffscreen;
		smr.updateWhenOffscreen = true;
		smr.updateWhenOffscreen = updateWhenOffscreen;
	}

	private void Update()
	{
		if (smr != null)
		{
			MB3_MeshCombiner.UpdateSkinnedMeshApproximateBoundsFromBonesStatic(bones, smr);
		}
	}
}
public class MB2_UpdateSkinnedMeshBoundsFromBounds : MonoBehaviour
{
	public List<GameObject> objects;

	private SkinnedMeshRenderer smr;

	private void Start()
	{
		smr = GetComponent<SkinnedMeshRenderer>();
		if (smr == null)
		{
			UnityEngine.Debug.LogError("Need to attach MB2_UpdateSkinnedMeshBoundsFromBounds script to an object with a SkinnedMeshRenderer component attached.");
			return;
		}
		if (objects == null || objects.Count == 0)
		{
			UnityEngine.Debug.LogWarning("The MB2_UpdateSkinnedMeshBoundsFromBounds had no Game Objects. It should have the same list of game objects that the MeshBaker does.");
			smr = null;
			return;
		}
		for (int i = 0; i < objects.Count; i++)
		{
			if (objects[i] == null || objects[i].GetComponent<Renderer>() == null)
			{
				UnityEngine.Debug.LogError("The list of objects had nulls or game objects without a renderer attached at position " + i);
				smr = null;
				return;
			}
		}
		bool updateWhenOffscreen = smr.updateWhenOffscreen;
		smr.updateWhenOffscreen = true;
		smr.updateWhenOffscreen = updateWhenOffscreen;
	}

	private void Update()
	{
		if (smr != null && objects != null)
		{
			MB3_MeshCombiner.UpdateSkinnedMeshApproximateBoundsFromBoundsStatic(objects, smr);
		}
	}
}
public class MB3_BatchPrefabBaker : MonoBehaviour
{
	[Serializable]
	public class MB3_PrefabBakerRow
	{
		public GameObject sourcePrefab;

		public GameObject resultPrefab;
	}

	public MB3_PrefabBakerRow[] prefabRows;

	public string outputPrefabFolder;
}
public class MB3_BoneWeightCopier : MonoBehaviour
{
	public GameObject inputGameObject;

	public GameObject outputPrefab;

	public float radius = 0.01f;

	public SkinnedMeshRenderer seamMesh;

	public string outputFolder;
}
public class MB3_DisableHiddenAnimations : MonoBehaviour
{
	public List<Animation> animationsToCull = new List<Animation>();

	private void Start()
	{
		if (GetComponent<SkinnedMeshRenderer>() == null)
		{
			UnityEngine.Debug.LogError("The MB3_CullHiddenAnimations script was placed on and object " + base.name + " which has no SkinnedMeshRenderer attached");
		}
	}

	private void OnBecameVisible()
	{
		for (int i = 0; i < animationsToCull.Count; i++)
		{
			if (animationsToCull[i] != null)
			{
				animationsToCull[i].enabled = true;
			}
		}
	}

	private void OnBecameInvisible()
	{
		for (int i = 0; i < animationsToCull.Count; i++)
		{
			if (animationsToCull[i] != null)
			{
				animationsToCull[i].enabled = false;
			}
		}
	}
}
public class MB3_MeshBaker : MB3_MeshBakerCommon
{
	[SerializeField]
	protected MB3_MeshCombinerSingle _meshCombiner = new MB3_MeshCombinerSingle();

	public override MB3_MeshCombiner meshCombiner => _meshCombiner;

	public void BuildSceneMeshObject()
	{
		_meshCombiner.BuildSceneMeshObject();
	}

	public virtual bool ShowHide(GameObject[] gos, GameObject[] deleteGOs)
	{
		return _meshCombiner.ShowHideGameObjects(gos, deleteGOs);
	}

	public virtual void ApplyShowHide()
	{
		_meshCombiner.ApplyShowHide();
	}

	public override bool AddDeleteGameObjects(GameObject[] gos, GameObject[] deleteGOs, bool disableRendererInSource)
	{
		_meshCombiner.name = base.name + "-mesh";
		return _meshCombiner.AddDeleteGameObjects(gos, deleteGOs, disableRendererInSource);
	}

	public override bool AddDeleteGameObjectsByID(GameObject[] gos, int[] deleteGOinstanceIDs, bool disableRendererInSource)
	{
		_meshCombiner.name = base.name + "-mesh";
		return _meshCombiner.AddDeleteGameObjectsByID(gos, deleteGOinstanceIDs, disableRendererInSource);
	}
}
public abstract class MB3_MeshBakerCommon : MB3_MeshBakerRoot
{
	public List<GameObject> objsToMesh;

	public bool useObjsToMeshFromTexBaker = true;

	public bool clearBuffersAfterBake = true;

	public string bakeAssetsInPlaceFolderPath;

	[HideInInspector]
	public GameObject resultPrefab;

	public abstract MB3_MeshCombiner meshCombiner { get; }

	public override MB2_TextureBakeResults textureBakeResults
	{
		get
		{
			return meshCombiner.textureBakeResults;
		}
		set
		{
			meshCombiner.textureBakeResults = value;
		}
	}

	public override List<GameObject> GetObjectsToCombine()
	{
		if (useObjsToMeshFromTexBaker)
		{
			MB3_TextureBaker component = base.gameObject.GetComponent<MB3_TextureBaker>();
			if (component == null)
			{
				component = base.gameObject.transform.parent.GetComponent<MB3_TextureBaker>();
			}
			if (component != null)
			{
				return component.GetObjectsToCombine();
			}
			UnityEngine.Debug.LogWarning("Use Objects To Mesh From Texture Baker was checked but no texture baker");
			return new List<GameObject>();
		}
		if (objsToMesh == null)
		{
			objsToMesh = new List<GameObject>();
		}
		return objsToMesh;
	}

	public void EnableDisableSourceObjectRenderers(bool show)
	{
		for (int i = 0; i < GetObjectsToCombine().Count; i++)
		{
			GameObject gameObject = GetObjectsToCombine()[i];
			if (gameObject != null)
			{
				Renderer renderer = MB_Utility.GetRenderer(gameObject);
				if (renderer != null)
				{
					renderer.enabled = show;
				}
			}
		}
	}

	public virtual void ClearMesh()
	{
		meshCombiner.ClearMesh();
	}

	public virtual void DestroyMesh()
	{
		meshCombiner.DestroyMesh();
	}

	public virtual void DestroyMeshEditor(MB2_EditorMethodsInterface editorMethods)
	{
		meshCombiner.DestroyMeshEditor(editorMethods);
	}

	public virtual int GetNumObjectsInCombined()
	{
		return meshCombiner.GetNumObjectsInCombined();
	}

	public virtual int GetNumVerticesFor(GameObject go)
	{
		return meshCombiner.GetNumVerticesFor(go);
	}

	public MB3_TextureBaker GetTextureBaker()
	{
		MB3_TextureBaker component = GetComponent<MB3_TextureBaker>();
		if (component != null)
		{
			return component;
		}
		if (base.transform.parent != null)
		{
			return base.transform.parent.GetComponent<MB3_TextureBaker>();
		}
		return null;
	}

	public abstract bool AddDeleteGameObjects(GameObject[] gos, GameObject[] deleteGOs, bool disableRendererInSource = true);

	public abstract bool AddDeleteGameObjectsByID(GameObject[] gos, int[] deleteGOinstanceIDs, bool disableRendererInSource = true);

	public virtual void Apply(MB3_MeshCombiner.GenerateUV2Delegate uv2GenerationMethod = null)
	{
		meshCombiner.name = base.name + "-mesh";
		meshCombiner.Apply(uv2GenerationMethod);
	}

	public virtual void Apply(bool triangles, bool vertices, bool normals, bool tangents, bool uvs, bool uv2, bool uv3, bool uv4, bool colors, bool bones = false, bool blendShapesFlag = false, MB3_MeshCombiner.GenerateUV2Delegate uv2GenerationMethod = null)
	{
		meshCombiner.name = base.name + "-mesh";
		meshCombiner.Apply(triangles, vertices, normals, tangents, uvs, uv2, uv3, uv4, colors, bones, blendShapesFlag, uv2GenerationMethod);
	}

	public virtual bool CombinedMeshContains(GameObject go)
	{
		return meshCombiner.CombinedMeshContains(go);
	}

	public virtual void UpdateGameObjects(GameObject[] gos, bool recalcBounds = true, bool updateVertices = true, bool updateNormals = true, bool updateTangents = true, bool updateUV = false, bool updateUV1 = false, bool updateUV2 = false, bool updateColors = false, bool updateSkinningInfo = false)
	{
		meshCombiner.name = base.name + "-mesh";
		meshCombiner.UpdateGameObjects(gos, recalcBounds, updateVertices, updateNormals, updateTangents, updateUV, updateUV1, updateUV2, updateColors, updateSkinningInfo);
	}

	public virtual void UpdateSkinnedMeshApproximateBounds()
	{
		if (_ValidateForUpdateSkinnedMeshBounds())
		{
			meshCombiner.UpdateSkinnedMeshApproximateBounds();
		}
	}

	public virtual void UpdateSkinnedMeshApproximateBoundsFromBones()
	{
		if (_ValidateForUpdateSkinnedMeshBounds())
		{
			meshCombiner.UpdateSkinnedMeshApproximateBoundsFromBones();
		}
	}

	public virtual void UpdateSkinnedMeshApproximateBoundsFromBounds()
	{
		if (_ValidateForUpdateSkinnedMeshBounds())
		{
			meshCombiner.UpdateSkinnedMeshApproximateBoundsFromBounds();
		}
	}

	protected virtual bool _ValidateForUpdateSkinnedMeshBounds()
	{
		if (meshCombiner.outputOption == MB2_OutputOptions.bakeMeshAssetsInPlace)
		{
			UnityEngine.Debug.LogWarning("Can't UpdateSkinnedMeshApproximateBounds when output type is bakeMeshAssetsInPlace");
			return false;
		}
		if (meshCombiner.resultSceneObject == null)
		{
			UnityEngine.Debug.LogWarning("Result Scene Object does not exist. No point in calling UpdateSkinnedMeshApproximateBounds.");
			return false;
		}
		if (meshCombiner.resultSceneObject.GetComponentInChildren<SkinnedMeshRenderer>() == null)
		{
			UnityEngine.Debug.LogWarning("No SkinnedMeshRenderer on result scene object.");
			return false;
		}
		return true;
	}
}
public class MB3_MeshBakerGrouper : MonoBehaviour
{
	public enum ClusterType
	{
		none,
		grid,
		pie,
		agglomerative
	}

	public MB3_MeshBakerGrouperCore grouper;

	public ClusterType clusterType;

	public GrouperData data = new GrouperData();

	[HideInInspector]
	public Bounds sourceObjectBounds = new Bounds(Vector3.zero, Vector3.one);

	private void OnDrawGizmosSelected()
	{
		if (grouper == null)
		{
			grouper = CreateGrouper(clusterType, data);
		}
		if (grouper.d == null)
		{
			grouper.d = data;
		}
		grouper.DrawGizmos(sourceObjectBounds);
	}

	public MB3_MeshBakerGrouperCore CreateGrouper(ClusterType t, GrouperData data)
	{
		if (t == ClusterType.grid)
		{
			grouper = new MB3_MeshBakerGrouperGrid(data);
		}
		if (t == ClusterType.pie)
		{
			grouper = new MB3_MeshBakerGrouperPie(data);
		}
		if (t == ClusterType.agglomerative)
		{
			MB3_TextureBaker component = GetComponent<MB3_TextureBaker>();
			List<GameObject> gos = ((!(component != null)) ? new List<GameObject>() : component.GetObjectsToCombine());
			grouper = new MB3_MeshBakerGrouperCluster(data, gos);
		}
		if (t == ClusterType.none)
		{
			grouper = new MB3_MeshBakerGrouperNone(data);
		}
		return grouper;
	}
}
public abstract class MB3_MeshBakerRoot : MonoBehaviour
{
	public class ZSortObjects
	{
		public class Item
		{
			public GameObject go;

			public Vector3 point;
		}

		public class ItemComparer : IComparer<Item>
		{
			public int Compare(Item a, Item b)
			{
				return (int)Mathf.Sign(b.point.z - a.point.z);
			}
		}

		public Vector3 sortAxis;

		public void SortByDistanceAlongAxis(List<GameObject> gos)
		{
			if (sortAxis == Vector3.zero)
			{
				UnityEngine.Debug.LogError("The sort axis cannot be the zero vector.");
				return;
			}
			UnityEngine.Debug.Log("Z sorting meshes along axis numObjs=" + gos.Count);
			List<Item> list = new List<Item>();
			Quaternion quaternion = Quaternion.FromToRotation(sortAxis, Vector3.forward);
			for (int i = 0; i < gos.Count; i++)
			{
				if (gos[i] != null)
				{
					Item item = new Item();
					item.point = gos[i].transform.position;
					item.go = gos[i];
					item.point = quaternion * item.point;
					list.Add(item);
				}
			}
			list.Sort(new ItemComparer());
			for (int j = 0; j < gos.Count; j++)
			{
				gos[j] = list[j].go;
			}
		}
	}

	public Vector3 sortAxis;

	[HideInInspector]
	public abstract MB2_TextureBakeResults textureBakeResults { get; set; }

	public virtual List<GameObject> GetObjectsToCombine()
	{
		return null;
	}

	public static bool DoCombinedValidate(MB3_MeshBakerRoot mom, MB_ObjsToCombineTypes objToCombineType, MB2_EditorMethodsInterface editorMethods, MB2_ValidationLevel validationLevel)
	{
		if (mom.textureBakeResults == null)
		{
			UnityEngine.Debug.LogError("Need to set Material Bake Result on " + mom);
			return false;
		}
		if (mom is MB3_MeshBakerCommon)
		{
			MB3_TextureBaker textureBaker = ((MB3_MeshBakerCommon)mom).GetTextureBaker();
			if (textureBaker != null && textureBaker.textureBakeResults != mom.textureBakeResults)
			{
				UnityEngine.Debug.LogWarning("Material Bake Result on this component is not the same as the Material Bake Result on the MB3_TextureBaker.");
			}
		}
		Dictionary<int, MB_Utility.MeshAnalysisResult> dictionary = null;
		if (validationLevel == MB2_ValidationLevel.robust)
		{
			dictionary = new Dictionary<int, MB_Utility.MeshAnalysisResult>();
		}
		List<GameObject> objectsToCombine = mom.GetObjectsToCombine();
		for (int i = 0; i < objectsToCombine.Count; i++)
		{
			GameObject gameObject = objectsToCombine[i];
			if (gameObject == null)
			{
				UnityEngine.Debug.LogError("The list of objects to combine contains a null at position." + i + " Select and use [shift] delete to remove");
				return false;
			}
			for (int j = i + 1; j < objectsToCombine.Count; j++)
			{
				if (objectsToCombine[i] == objectsToCombine[j])
				{
					UnityEngine.Debug.LogError("The list of objects to combine contains duplicates at " + i + " and " + j);
					return false;
				}
			}
			if (MB_Utility.GetGOMaterials(gameObject) == null)
			{
				UnityEngine.Debug.LogError(string.Concat("Object ", gameObject, " in the list of objects to be combined does not have a material"));
				return false;
			}
			Mesh mesh = MB_Utility.GetMesh(gameObject);
			if (mesh == null)
			{
				UnityEngine.Debug.LogError(string.Concat("Object ", gameObject, " in the list of objects to be combined does not have a mesh"));
				return false;
			}
			if (mesh != null && !Application.isEditor && Application.isPlaying && mom.textureBakeResults.doMultiMaterial && validationLevel >= MB2_ValidationLevel.robust)
			{
				if (!dictionary.TryGetValue(mesh.GetInstanceID(), out var value))
				{
					MB_Utility.doSubmeshesShareVertsOrTris(mesh, ref value);
					dictionary.Add(mesh.GetInstanceID(), value);
				}
				if (value.hasOverlappingSubmeshVerts)
				{
					UnityEngine.Debug.LogWarning(string.Concat("Object ", objectsToCombine[i], " in the list of objects to combine has overlapping submeshes (submeshes share vertices). If the UVs associated with the shared vertices are important then this bake may not work. If you are using multiple materials then this object can only be combined with objects that use the exact same set of textures (each atlas contains one texture). There may be other undesirable side affects as well. Mesh Master, available in the asset store can fix overlapping submeshes."));
				}
			}
		}
		List<GameObject> list = objectsToCombine;
		if (mom is MB3_MeshBaker)
		{
			list = mom.GetObjectsToCombine();
			if (list == null || list.Count == 0)
			{
				UnityEngine.Debug.LogError("No meshes to combine. Please assign some meshes to combine.");
				return false;
			}
			if (mom is MB3_MeshBaker && ((MB3_MeshBaker)mom).meshCombiner.renderType == MB_RenderType.skinnedMeshRenderer && !editorMethods.ValidateSkinnedMeshes(list))
			{
				return false;
			}
		}
		editorMethods?.CheckPrefabTypes(objToCombineType, objectsToCombine);
		return true;
	}
}
public class MB3_MultiMeshBaker : MB3_MeshBakerCommon
{
	[SerializeField]
	protected MB3_MultiMeshCombiner _meshCombiner = new MB3_MultiMeshCombiner();

	public override MB3_MeshCombiner meshCombiner => _meshCombiner;

	public override bool AddDeleteGameObjects(GameObject[] gos, GameObject[] deleteGOs, bool disableRendererInSource)
	{
		if (_meshCombiner.resultSceneObject == null)
		{
			_meshCombiner.resultSceneObject = new GameObject("CombinedMesh-" + base.name);
		}
		meshCombiner.name = base.name + "-mesh";
		return _meshCombiner.AddDeleteGameObjects(gos, deleteGOs, disableRendererInSource);
	}

	public override bool AddDeleteGameObjectsByID(GameObject[] gos, int[] deleteGOs, bool disableRendererInSource)
	{
		if (_meshCombiner.resultSceneObject == null)
		{
			_meshCombiner.resultSceneObject = new GameObject("CombinedMesh-" + base.name);
		}
		meshCombiner.name = base.name + "-mesh";
		return _meshCombiner.AddDeleteGameObjectsByID(gos, deleteGOs, disableRendererInSource);
	}
}
public class MB3_TextureBaker : MB3_MeshBakerRoot
{
	public delegate void OnCombinedTexturesCoroutineSuccess();

	public delegate void OnCombinedTexturesCoroutineFail();

	public class CreateAtlasesCoroutineResult
	{
		public bool success = true;

		public bool isFinished;
	}

	public MB2_LogLevel LOG_LEVEL = MB2_LogLevel.info;

	[SerializeField]
	protected MB2_TextureBakeResults _textureBakeResults;

	[SerializeField]
	protected int _atlasPadding = 1;

	[SerializeField]
	protected int _maxAtlasSize = 4096;

	[SerializeField]
	protected bool _resizePowerOfTwoTextures;

	[SerializeField]
	protected bool _fixOutOfBoundsUVs;

	[SerializeField]
	protected int _maxTilingBakeSize = 1024;

	[SerializeField]
	protected MB2_PackingAlgorithmEnum _packingAlgorithm = MB2_PackingAlgorithmEnum.MeshBakerTexturePacker;

	[SerializeField]
	protected bool _meshBakerTexturePackerForcePowerOfTwo = true;

	[SerializeField]
	protected List<ShaderTextureProperty> _customShaderProperties = new List<ShaderTextureProperty>();

	[SerializeField]
	protected List<string> _customShaderPropNames_Depricated = new List<string>();

	[SerializeField]
	protected bool _doMultiMaterial;

	[SerializeField]
	protected Material _resultMaterial;

	[SerializeField]
	protected bool _considerNonTextureProperties = true;

	[SerializeField]
	protected bool _doSuggestTreatment = true;

	public MB_MultiMaterial[] resultMaterials = new MB_MultiMaterial[0];

	public List<GameObject> objsToMesh;

	public OnCombinedTexturesCoroutineSuccess onBuiltAtlasesSuccess;

	public OnCombinedTexturesCoroutineFail onBuiltAtlasesFail;

	public MB_AtlasesAndRects[] OnCombinedTexturesCoroutineAtlasesAndRects;

	public override MB2_TextureBakeResults textureBakeResults
	{
		get
		{
			return _textureBakeResults;
		}
		set
		{
			_textureBakeResults = value;
		}
	}

	public virtual int atlasPadding
	{
		get
		{
			return _atlasPadding;
		}
		set
		{
			_atlasPadding = value;
		}
	}

	public virtual int maxAtlasSize
	{
		get
		{
			return _maxAtlasSize;
		}
		set
		{
			_maxAtlasSize = value;
		}
	}

	public virtual bool resizePowerOfTwoTextures
	{
		get
		{
			return _resizePowerOfTwoTextures;
		}
		set
		{
			_resizePowerOfTwoTextures = value;
		}
	}

	public virtual bool fixOutOfBoundsUVs
	{
		get
		{
			return _fixOutOfBoundsUVs;
		}
		set
		{
			_fixOutOfBoundsUVs = value;
		}
	}

	public virtual int maxTilingBakeSize
	{
		get
		{
			return _maxTilingBakeSize;
		}
		set
		{
			_maxTilingBakeSize = value;
		}
	}

	public virtual MB2_PackingAlgorithmEnum packingAlgorithm
	{
		get
		{
			return _packingAlgorithm;
		}
		set
		{
			_packingAlgorithm = value;
		}
	}

	public bool meshBakerTexturePackerForcePowerOfTwo
	{
		get
		{
			return _meshBakerTexturePackerForcePowerOfTwo;
		}
		set
		{
			_meshBakerTexturePackerForcePowerOfTwo = value;
		}
	}

	public virtual List<ShaderTextureProperty> customShaderProperties
	{
		get
		{
			return _customShaderProperties;
		}
		set
		{
			_customShaderProperties = value;
		}
	}

	public virtual List<string> customShaderPropNames
	{
		get
		{
			return _customShaderPropNames_Depricated;
		}
		set
		{
			_customShaderPropNames_Depricated = value;
		}
	}

	public virtual bool doMultiMaterial
	{
		get
		{
			return _doMultiMaterial;
		}
		set
		{
			_doMultiMaterial = value;
		}
	}

	public virtual Material resultMaterial
	{
		get
		{
			return _resultMaterial;
		}
		set
		{
			_resultMaterial = value;
		}
	}

	public bool considerNonTextureProperties
	{
		get
		{
			return _considerNonTextureProperties;
		}
		set
		{
			_considerNonTextureProperties = value;
		}
	}

	public bool doSuggestTreatment
	{
		get
		{
			return _doSuggestTreatment;
		}
		set
		{
			_doSuggestTreatment = value;
		}
	}

	public override List<GameObject> GetObjectsToCombine()
	{
		if (objsToMesh == null)
		{
			objsToMesh = new List<GameObject>();
		}
		return objsToMesh;
	}

	public MB_AtlasesAndRects[] CreateAtlases()
	{
		return CreateAtlases(null);
	}

	public IEnumerator CreateAtlasesCoroutine(ProgressUpdateDelegate progressInfo, CreateAtlasesCoroutineResult coroutineResult, bool saveAtlasesAsAssets = false, MB2_EditorMethodsInterface editorMethods = null, float maxTimePerFrame = 0.01f)
	{
		MBVersionConcrete mBVersionConcrete = new MBVersionConcrete();
		if (!MB3_TextureCombiner._RunCorutineWithoutPauseIsRunning && (mBVersionConcrete.GetMajorVersion() < 5 || (mBVersionConcrete.GetMajorVersion() == 5 && mBVersionConcrete.GetMinorVersion() < 3)))
		{
			UnityEngine.Debug.LogError("Running the texture combiner as a coroutine only works in Unity 5.3 and higher");
			yield return null;
		}
		OnCombinedTexturesCoroutineAtlasesAndRects = null;
		if (maxTimePerFrame <= 0f)
		{
			UnityEngine.Debug.LogError("maxTimePerFrame must be a value greater than zero");
			coroutineResult.isFinished = true;
			yield break;
		}
		MB2_ValidationLevel validationLevel = (Application.isPlaying ? MB2_ValidationLevel.quick : MB2_ValidationLevel.robust);
		if (!MB3_MeshBakerRoot.DoCombinedValidate(this, MB_ObjsToCombineTypes.dontCare, null, validationLevel))
		{
			coroutineResult.isFinished = true;
			yield break;
		}
		if (_doMultiMaterial && !_ValidateResultMaterials())
		{
			coroutineResult.isFinished = true;
			yield break;
		}
		if (!_doMultiMaterial)
		{
			if (_resultMaterial == null)
			{
				UnityEngine.Debug.LogError("Combined Material is null please create and assign a result material.");
				coroutineResult.isFinished = true;
				yield break;
			}
			Shader shader = _resultMaterial.shader;
			for (int j = 0; j < objsToMesh.Count; j++)
			{
				Material[] gOMaterials = MB_Utility.GetGOMaterials(objsToMesh[j]);
				foreach (Material material in gOMaterials)
				{
					if (material != null && material.shader != shader)
					{
						UnityEngine.Debug.LogWarning(string.Concat("Game object ", objsToMesh[j], " does not use shader ", shader, " it may not have the required textures. If not small solid color textures will be generated."));
					}
				}
			}
		}
		for (int l = 0; l < objsToMesh.Count; l++)
		{
			Material[] gOMaterials2 = MB_Utility.GetGOMaterials(objsToMesh[l]);
			for (int m = 0; m < gOMaterials2.Length; m++)
			{
				if (gOMaterials2[m] == null)
				{
					UnityEngine.Debug.LogError(string.Concat("Game object ", objsToMesh[l], " has a null material. Can't build atlases"));
					coroutineResult.isFinished = true;
					yield break;
				}
			}
		}
		MB3_TextureCombiner combiner = new MB3_TextureCombiner
		{
			LOG_LEVEL = LOG_LEVEL,
			atlasPadding = _atlasPadding,
			maxAtlasSize = _maxAtlasSize,
			customShaderPropNames = _customShaderProperties,
			fixOutOfBoundsUVs = _fixOutOfBoundsUVs,
			maxTilingBakeSize = _maxTilingBakeSize,
			packingAlgorithm = _packingAlgorithm,
			meshBakerTexturePackerForcePowerOfTwo = _meshBakerTexturePackerForcePowerOfTwo,
			resizePowerOfTwoTextures = _resizePowerOfTwoTextures,
			saveAtlasesAsAssets = saveAtlasesAsAssets,
			considerNonTextureProperties = _considerNonTextureProperties
		};
		int num = 1;
		if (_doMultiMaterial)
		{
			num = resultMaterials.Length;
		}
		OnCombinedTexturesCoroutineAtlasesAndRects = new MB_AtlasesAndRects[num];
		for (int n = 0; n < OnCombinedTexturesCoroutineAtlasesAndRects.Length; n++)
		{
			OnCombinedTexturesCoroutineAtlasesAndRects[n] = new MB_AtlasesAndRects();
		}
		for (int i = 0; i < OnCombinedTexturesCoroutineAtlasesAndRects.Length; i++)
		{
			List<Material> allowedMaterialsFilter = null;
			Material combinedMaterial;
			if (_doMultiMaterial)
			{
				allowedMaterialsFilter = resultMaterials[i].sourceMaterials;
				combinedMaterial = resultMaterials[i].combinedMaterial;
			}
			else
			{
				combinedMaterial = _resultMaterial;
			}
			UnityEngine.Debug.Log($"Creating atlases for result material {combinedMaterial} using shader {combinedMaterial.shader}");
			MB3_TextureCombiner.CombineTexturesIntoAtlasesCoroutineResult coroutineResult2 = new MB3_TextureCombiner.CombineTexturesIntoAtlasesCoroutineResult();
			yield return combiner.CombineTexturesIntoAtlasesCoroutine(progressInfo, OnCombinedTexturesCoroutineAtlasesAndRects[i], combinedMaterial, objsToMesh, allowedMaterialsFilter, editorMethods, coroutineResult2, maxTimePerFrame);
			coroutineResult.success = coroutineResult2.success;
			if (!coroutineResult.success)
			{
				coroutineResult.isFinished = true;
				yield break;
			}
		}
		textureBakeResults.doMultiMaterial = _doMultiMaterial;
		textureBakeResults.resultMaterial = _resultMaterial;
		textureBakeResults.resultMaterials = resultMaterials;
		textureBakeResults.fixOutOfBoundsUVs = combiner.fixOutOfBoundsUVs;
		unpackMat2RectMap(textureBakeResults);
		MB3_MeshBakerCommon[] componentsInChildren = GetComponentsInChildren<MB3_MeshBakerCommon>();
		for (int num2 = 0; num2 < componentsInChildren.Length; num2++)
		{
			componentsInChildren[num2].textureBakeResults = textureBakeResults;
		}
		if (LOG_LEVEL >= MB2_LogLevel.info)
		{
			UnityEngine.Debug.Log("Created Atlases");
		}
		coroutineResult.isFinished = true;
		if (coroutineResult.success && onBuiltAtlasesSuccess != null)
		{
			onBuiltAtlasesSuccess();
		}
		if (!coroutineResult.success && onBuiltAtlasesFail != null)
		{
			onBuiltAtlasesFail();
		}
	}

	public MB_AtlasesAndRects[] CreateAtlases(ProgressUpdateDelegate progressInfo, bool saveAtlasesAsAssets = false, MB2_EditorMethodsInterface editorMethods = null)
	{
		MB_AtlasesAndRects[] array = null;
		try
		{
			CreateAtlasesCoroutineResult createAtlasesCoroutineResult = new CreateAtlasesCoroutineResult();
			MB3_TextureCombiner.RunCorutineWithoutPause(CreateAtlasesCoroutine(progressInfo, createAtlasesCoroutineResult, saveAtlasesAsAssets, editorMethods, 1000f), 0);
			if (createAtlasesCoroutineResult.success && textureBakeResults != null)
			{
				array = OnCombinedTexturesCoroutineAtlasesAndRects;
			}
		}
		catch (Exception message)
		{
			UnityEngine.Debug.LogError(message);
		}
		finally
		{
			if (saveAtlasesAsAssets && array != null)
			{
				foreach (MB_AtlasesAndRects mB_AtlasesAndRects in array)
				{
					if (mB_AtlasesAndRects == null || mB_AtlasesAndRects.atlases == null)
					{
						continue;
					}
					for (int j = 0; j < mB_AtlasesAndRects.atlases.Length; j++)
					{
						if (mB_AtlasesAndRects.atlases[j] != null)
						{
							if (editorMethods != null)
							{
								editorMethods.Destroy(mB_AtlasesAndRects.atlases[j]);
							}
							else
							{
								MB_Utility.Destroy(mB_AtlasesAndRects.atlases[j]);
							}
						}
					}
				}
			}
		}
		return array;
	}

	private void unpackMat2RectMap(MB2_TextureBakeResults tbr)
	{
		List<Material> list = new List<Material>();
		List<MB_MaterialAndUVRect> list2 = new List<MB_MaterialAndUVRect>();
		List<Rect> list3 = new List<Rect>();
		for (int i = 0; i < OnCombinedTexturesCoroutineAtlasesAndRects.Length; i++)
		{
			List<MB_MaterialAndUVRect> mat2rect_map = OnCombinedTexturesCoroutineAtlasesAndRects[i].mat2rect_map;
			for (int j = 0; j < mat2rect_map.Count; j++)
			{
				list2.Add(mat2rect_map[j]);
				list.Add(mat2rect_map[j].material);
				list3.Add(mat2rect_map[j].atlasRect);
			}
		}
		tbr.materialsAndUVRects = list2.ToArray();
		tbr.materials = list.ToArray();
	}

	public static void ConfigureNewMaterialToMatchOld(Material newMat, Material original)
	{
		if (original == null)
		{
			UnityEngine.Debug.LogWarning(string.Concat("Original material is null, could not copy properties to ", newMat, ". Setting shader to ", newMat.shader));
			return;
		}
		newMat.shader = original.shader;
		newMat.CopyPropertiesFromMaterial(original);
		ShaderTextureProperty[] shaderTexPropertyNames = MB3_TextureCombiner.shaderTexPropertyNames;
		for (int i = 0; i < shaderTexPropertyNames.Length; i++)
		{
			Vector2 one = Vector2.one;
			Vector2 zero = Vector2.zero;
			if (newMat.HasProperty(shaderTexPropertyNames[i].name))
			{
				newMat.SetTextureOffset(shaderTexPropertyNames[i].name, zero);
				newMat.SetTextureScale(shaderTexPropertyNames[i].name, one);
			}
		}
	}

	private string PrintSet(HashSet<Material> s)
	{
		StringBuilder stringBuilder = new StringBuilder();
		foreach (Material item in s)
		{
			stringBuilder.Append(string.Concat(item, ","));
		}
		return stringBuilder.ToString();
	}

	private bool _ValidateResultMaterials()
	{
		HashSet<Material> hashSet = new HashSet<Material>();
		for (int i = 0; i < objsToMesh.Count; i++)
		{
			if (!(objsToMesh[i] != null))
			{
				continue;
			}
			Material[] gOMaterials = MB_Utility.GetGOMaterials(objsToMesh[i]);
			for (int j = 0; j < gOMaterials.Length; j++)
			{
				if (gOMaterials[j] != null)
				{
					hashSet.Add(gOMaterials[j]);
				}
			}
		}
		HashSet<Material> hashSet2 = new HashSet<Material>();
		for (int k = 0; k < resultMaterials.Length; k++)
		{
			MB_MultiMaterial mB_MultiMaterial = resultMaterials[k];
			if (mB_MultiMaterial.combinedMaterial == null)
			{
				UnityEngine.Debug.LogError("Combined Material is null please create and assign a result material.");
				return false;
			}
			Shader shader = mB_MultiMaterial.combinedMaterial.shader;
			for (int l = 0; l < mB_MultiMaterial.sourceMaterials.Count; l++)
			{
				if (mB_MultiMaterial.sourceMaterials[l] == null)
				{
					UnityEngine.Debug.LogError("There are null entries in the list of Source Materials");
					return false;
				}
				if (shader != mB_MultiMaterial.sourceMaterials[l].shader)
				{
					UnityEngine.Debug.LogWarning(string.Concat("Source material ", mB_MultiMaterial.sourceMaterials[l], " does not use shader ", shader, " it may not have the required textures. If not empty textures will be generated."));
				}
				if (hashSet2.Contains(mB_MultiMaterial.sourceMaterials[l]))
				{
					UnityEngine.Debug.LogError(string.Concat("A Material ", mB_MultiMaterial.sourceMaterials[l], " appears more than once in the list of source materials in the source material to combined mapping. Each source material must be unique."));
					return false;
				}
				hashSet2.Add(mB_MultiMaterial.sourceMaterials[l]);
			}
		}
		if (hashSet.IsProperSubsetOf(hashSet2))
		{
			hashSet2.ExceptWith(hashSet);
			UnityEngine.Debug.LogWarning("There are materials in the mapping that are not used on your source objects: " + PrintSet(hashSet2));
		}
		if (hashSet2.IsProperSubsetOf(hashSet))
		{
			hashSet.ExceptWith(hashSet2);
			UnityEngine.Debug.LogError("There are materials on the objects to combine that are not in the mapping: " + PrintSet(hashSet));
			return false;
		}
		return true;
	}
}
public class MB2_TestShowHide : MonoBehaviour
{
	public MB3_MeshBaker mb;

	public GameObject[] objs;

	private void Update()
	{
		if (Time.frameCount == 100)
		{
			mb.ShowHide(null, objs);
			mb.ApplyShowHide();
			UnityEngine.Debug.Log("should have disappeared");
		}
		if (Time.frameCount == 200)
		{
			mb.ShowHide(objs, null);
			mb.ApplyShowHide();
			UnityEngine.Debug.Log("should show");
		}
	}
}
public class MB2_TestUpdate : MonoBehaviour
{
	public MB3_MeshBaker meshbaker;

	public MB3_MultiMeshBaker multiMeshBaker;

	public GameObject[] objsToMove;

	public GameObject objWithChangingUVs;

	private Vector2[] uvs;

	private Mesh m;

	private void Start()
	{
		meshbaker.AddDeleteGameObjects(objsToMove, null, disableRendererInSource: true);
		meshbaker.AddDeleteGameObjects(new GameObject[1] { objWithChangingUVs }, null, disableRendererInSource: true);
		MeshFilter component = objWithChangingUVs.GetComponent<MeshFilter>();
		m = component.sharedMesh;
		uvs = m.uv;
		meshbaker.Apply();
		multiMeshBaker.AddDeleteGameObjects(objsToMove, null, disableRendererInSource: true);
		multiMeshBaker.AddDeleteGameObjects(new GameObject[1] { objWithChangingUVs }, null, disableRendererInSource: true);
		component = objWithChangingUVs.GetComponent<MeshFilter>();
		m = component.sharedMesh;
		uvs = m.uv;
		multiMeshBaker.Apply();
	}

	private void LateUpdate()
	{
		meshbaker.UpdateGameObjects(objsToMove, recalcBounds: false);
		Vector2[] uv = m.uv;
		for (int i = 0; i < uv.Length; i++)
		{
			uv[i] = Mathf.Sin(Time.time) * uvs[i];
		}
		m.uv = uv;
		meshbaker.UpdateGameObjects(new GameObject[1] { objWithChangingUVs }, recalcBounds: true, updateVertices: true, updateNormals: true, updateTangents: true, updateUV: true);
		meshbaker.Apply(triangles: false, vertices: true, normals: true, tangents: true, uvs: true, uv2: false, uv3: false, uv4: false, colors: false);
		multiMeshBaker.UpdateGameObjects(objsToMove, recalcBounds: false);
		uv = m.uv;
		for (int j = 0; j < uv.Length; j++)
		{
			uv[j] = Mathf.Sin(Time.time) * uvs[j];
		}
		m.uv = uv;
		multiMeshBaker.UpdateGameObjects(new GameObject[1] { objWithChangingUVs }, recalcBounds: true, updateVertices: true, updateNormals: true, updateTangents: true, updateUV: true);
		multiMeshBaker.Apply(triangles: false, vertices: true, normals: true, tangents: true, uvs: true, uv2: false, uv3: false, uv4: false, colors: false);
	}
}
public class MB3_TestAddingRemovingSkinnedMeshes : MonoBehaviour
{
	public MB3_MeshBaker meshBaker;

	public GameObject[] g;

	private void Start()
	{
		StartCoroutine(TestScript());
	}

	private IEnumerator TestScript()
	{
		UnityEngine.Debug.Log("Test 1 adding 0,1,2");
		GameObject[] gos = new GameObject[3]
		{
			g[0],
			g[1],
			g[2]
		};
		meshBaker.AddDeleteGameObjects(gos, null, disableRendererInSource: true);
		meshBaker.Apply();
		meshBaker.meshCombiner.CheckIntegrity();
		yield return new WaitForSeconds(3f);
		UnityEngine.Debug.Log("Test 2 remove 1 and add 3,4,5");
		GameObject[] deleteGOs = new GameObject[1] { g[1] };
		gos = new GameObject[3]
		{
			g[3],
			g[4],
			g[5]
		};
		meshBaker.AddDeleteGameObjects(gos, deleteGOs, disableRendererInSource: true);
		meshBaker.Apply();
		meshBaker.meshCombiner.CheckIntegrity();
		yield return new WaitForSeconds(3f);
		UnityEngine.Debug.Log("Test 3 remove 0,2,5 and add 1");
		deleteGOs = new GameObject[3]
		{
			g[3],
			g[4],
			g[5]
		};
		gos = new GameObject[1] { g[1] };
		meshBaker.AddDeleteGameObjects(gos, deleteGOs, disableRendererInSource: true);
		meshBaker.Apply();
		meshBaker.meshCombiner.CheckIntegrity();
		yield return new WaitForSeconds(3f);
		UnityEngine.Debug.Log("Test 3 remove all remaining");
		deleteGOs = new GameObject[3]
		{
			g[0],
			g[1],
			g[2]
		};
		meshBaker.AddDeleteGameObjects(null, deleteGOs, disableRendererInSource: true);
		meshBaker.Apply();
		meshBaker.meshCombiner.CheckIntegrity();
		yield return new WaitForSeconds(3f);
		UnityEngine.Debug.Log("Test 3 add all");
		meshBaker.AddDeleteGameObjects(g, null, disableRendererInSource: true);
		meshBaker.Apply();
		meshBaker.meshCombiner.CheckIntegrity();
		yield return new WaitForSeconds(1f);
		UnityEngine.Debug.Log("Done");
	}
}
public class MB3_TestBakeAllWithSameMaterial : MonoBehaviour
{
	public GameObject[] listOfObjsToCombineGood;

	public GameObject[] listOfObjsToCombineBad;

	private void Start()
	{
		testCombine();
	}

	private void testCombine()
	{
		MB3_MeshCombinerSingle mB3_MeshCombinerSingle = new MB3_MeshCombinerSingle();
		UnityEngine.Debug.Log("About to bake 1");
		mB3_MeshCombinerSingle.AddDeleteGameObjects(listOfObjsToCombineGood, null);
		mB3_MeshCombinerSingle.Apply();
		mB3_MeshCombinerSingle.UpdateGameObjects(listOfObjsToCombineGood);
		mB3_MeshCombinerSingle.Apply();
		mB3_MeshCombinerSingle.AddDeleteGameObjects(null, listOfObjsToCombineGood);
		mB3_MeshCombinerSingle.Apply();
		UnityEngine.Debug.Log("Did bake 1");
		UnityEngine.Debug.Log("About to bake 2 should get error that one material doesn't match");
		mB3_MeshCombinerSingle.AddDeleteGameObjects(listOfObjsToCombineBad, null);
		mB3_MeshCombinerSingle.Apply();
		UnityEngine.Debug.Log("Did bake 2");
		UnityEngine.Debug.Log("Doing same with multi mesh combiner");
		MB3_MultiMeshCombiner mB3_MultiMeshCombiner = new MB3_MultiMeshCombiner();
		UnityEngine.Debug.Log("About to bake 3");
		mB3_MultiMeshCombiner.AddDeleteGameObjects(listOfObjsToCombineGood, null);
		mB3_MultiMeshCombiner.Apply();
		mB3_MultiMeshCombiner.UpdateGameObjects(listOfObjsToCombineGood);
		mB3_MultiMeshCombiner.Apply();
		mB3_MultiMeshCombiner.AddDeleteGameObjects(null, listOfObjsToCombineGood);
		mB3_MultiMeshCombiner.Apply();
		UnityEngine.Debug.Log("Did bake 3");
		UnityEngine.Debug.Log("About to bake 4  should get error that one material doesn't match");
		mB3_MultiMeshCombiner.AddDeleteGameObjects(listOfObjsToCombineBad, null);
		mB3_MultiMeshCombiner.Apply();
		UnityEngine.Debug.Log("Did bake 4");
	}
}
public class MB3_TestRenderTextureTestHarness : MonoBehaviour
{
	public Texture2D input;

	public bool doColor;

	public Color32 color;

	public Texture2D Create3x3Tex()
	{
		Texture2D texture2D = new Texture2D(3, 3, TextureFormat.ARGB32, mipChain: false);
		Color32[] array = new Color32[texture2D.width * texture2D.height];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = color;
		}
		texture2D.SetPixels32(array);
		texture2D.Apply();
		return texture2D;
	}

	public Texture2D Create3x3Clone()
	{
		Texture2D texture2D = new Texture2D(3, 3, TextureFormat.ARGB32, mipChain: false);
		Color32[] pixels = new Color32[9]
		{
			new Color32(54, 54, 201, byte.MaxValue),
			new Color32(128, 37, 218, byte.MaxValue),
			new Color32(201, 54, 201, byte.MaxValue),
			new Color32(37, 128, 218, byte.MaxValue),
			new Color32(128, 128, byte.MaxValue, byte.MaxValue),
			new Color32(218, 128, 218, byte.MaxValue),
			new Color32(54, 201, 201, byte.MaxValue),
			new Color32(128, 218, 218, byte.MaxValue),
			new Color32(201, 201, 201, byte.MaxValue)
		};
		texture2D.SetPixels32(pixels);
		texture2D.Apply();
		return texture2D;
	}

	public static void TestRender(Texture2D input, Texture2D output)
	{
		int num = 1;
		ShaderTextureProperty[] array = new ShaderTextureProperty[1]
		{
			new ShaderTextureProperty("_BumpMap", norm: false)
		};
		int width = input.width;
		int height = input.height;
		int padding = 0;
		Rect[] rects = new Rect[1]
		{
			new Rect(0f, 0f, 1f, 1f)
		};
		List<MB3_TextureCombiner.MB_TexSet> list = new List<MB3_TextureCombiner.MB_TexSet>();
		MB3_TextureCombiner.MB_TexSet item = new MB3_TextureCombiner.MB_TexSet(new MB3_TextureCombiner.MeshBakerMaterialTexture[1]
		{
			new MB3_TextureCombiner.MeshBakerMaterialTexture(input)
		}, Vector2.zero, Vector2.one);
		list.Add(item);
		GameObject obj = new GameObject("MBrenderAtlasesGO");
		MB3_AtlasPackerRenderTexture mB3_AtlasPackerRenderTexture = obj.AddComponent<MB3_AtlasPackerRenderTexture>();
		obj.AddComponent<Camera>();
		for (int i = 0; i < num; i++)
		{
			Texture2D texture2D = null;
			UnityEngine.Debug.Log("About to render " + array[i].name + " isNormal=" + array[i].isNormalMap);
			mB3_AtlasPackerRenderTexture.LOG_LEVEL = MB2_LogLevel.trace;
			mB3_AtlasPackerRenderTexture.width = width;
			mB3_AtlasPackerRenderTexture.height = height;
			mB3_AtlasPackerRenderTexture.padding = padding;
			mB3_AtlasPackerRenderTexture.rects = rects;
			mB3_AtlasPackerRenderTexture.textureSets = list;
			mB3_AtlasPackerRenderTexture.indexOfTexSetToRender = i;
			mB3_AtlasPackerRenderTexture.isNormalMap = array[i].isNormalMap;
			texture2D = mB3_AtlasPackerRenderTexture.OnRenderAtlas(null);
			UnityEngine.Debug.Log("Created atlas " + array[i].name + " w=" + texture2D.width + " h=" + texture2D.height + " id=" + texture2D.GetInstanceID());
			UnityEngine.Debug.Log(string.Concat("Color ", texture2D.GetPixel(5, 5), " ", Color.red));
			byte[] bytes = texture2D.EncodeToPNG();
			File.WriteAllBytes(Application.dataPath + "/_Experiment/red.png", bytes);
		}
	}
}
public class MB_TextureCombinerRenderTexture
{
	public MB2_LogLevel LOG_LEVEL = MB2_LogLevel.info;

	private Material mat;

	private RenderTexture _destinationTexture;

	private Camera myCamera;

	private int _padding;

	private bool _isNormalMap;

	private bool _fixOutOfBoundsUVs;

	private bool _doRenderAtlas;

	private Rect[] rs;

	private List<MB3_TextureCombiner.MB_TexSet> textureSets;

	private int indexOfTexSetToRender;

	private ShaderTextureProperty _texPropertyName;

	private TextureBlender _resultMaterialTextureBlender;

	private Texture2D targTex;

	private MB3_TextureCombiner combiner;

	public Texture2D DoRenderAtlas(GameObject gameObject, int width, int height, int padding, Rect[] rss, List<MB3_TextureCombiner.MB_TexSet> textureSetss, int indexOfTexSetToRenders, ShaderTextureProperty texPropertyname, TextureBlender resultMaterialTextureBlender, bool isNormalMap, bool fixOutOfBoundsUVs, bool considerNonTextureProperties, MB3_TextureCombiner texCombiner, MB2_LogLevel LOG_LEV)
	{
		LOG_LEVEL = LOG_LEV;
		textureSets = textureSetss;
		indexOfTexSetToRender = indexOfTexSetToRenders;
		_texPropertyName = texPropertyname;
		_padding = padding;
		_isNormalMap = isNormalMap;
		_fixOutOfBoundsUVs = fixOutOfBoundsUVs;
		_resultMaterialTextureBlender = resultMaterialTextureBlender;
		combiner = texCombiner;
		rs = rss;
		Shader shader = ((!_isNormalMap) ? Shader.Find("MeshBaker/AlbedoShader") : Shader.Find("MeshBaker/NormalMapShader"));
		if (shader == null)
		{
			UnityEngine.Debug.LogError("Could not find shader for RenderTexture. Try reimporting mesh baker");
			return null;
		}
		mat = new Material(shader);
		_destinationTexture = new RenderTexture(width, height, 24, RenderTextureFormat.ARGB32);
		_destinationTexture.filterMode = FilterMode.Point;
		myCamera = gameObject.GetComponent<Camera>();
		myCamera.orthographic = true;
		myCamera.orthographicSize = height >> 1;
		myCamera.aspect = width / height;
		myCamera.targetTexture = _destinationTexture;
		myCamera.clearFlags = CameraClearFlags.Color;
		Transform component = myCamera.GetComponent<Transform>();
		component.localPosition = new Vector3((float)width / 2f, (float)height / 2f, 3f);
		component.localRotation = Quaternion.Euler(0f, 180f, 180f);
		_doRenderAtlas = true;
		if (LOG_LEVEL >= MB2_LogLevel.debug)
		{
			UnityEngine.Debug.Log($"Begin Camera.Render destTex w={width} h={height} camPos={component.localPosition}");
		}
		myCamera.Render();
		_doRenderAtlas = false;
		MB_Utility.Destroy(mat);
		MB_Utility.Destroy(_destinationTexture);
		if (LOG_LEVEL >= MB2_LogLevel.debug)
		{
			UnityEngine.Debug.Log("Finished Camera.Render ");
		}
		Texture2D result = targTex;
		targTex = null;
		return result;
	}

	public void OnRenderObject()
	{
		if (!_doRenderAtlas)
		{
			return;
		}
		Stopwatch stopwatch = new Stopwatch();
		stopwatch.Start();
		for (int i = 0; i < rs.Length; i++)
		{
			MB3_TextureCombiner.MeshBakerMaterialTexture meshBakerMaterialTexture = textureSets[i].ts[indexOfTexSetToRender];
			if (LOG_LEVEL >= MB2_LogLevel.trace && meshBakerMaterialTexture.t != null)
			{
				UnityEngine.Debug.Log(string.Concat("Added ", meshBakerMaterialTexture.t, " to atlas w=", meshBakerMaterialTexture.t.width, " h=", meshBakerMaterialTexture.t.height, " offset=", meshBakerMaterialTexture.matTilingRect.min, " scale=", meshBakerMaterialTexture.matTilingRect.size, " rect=", rs[i], " padding=", _padding));
				_printTexture(meshBakerMaterialTexture.t);
			}
			CopyScaledAndTiledToAtlas(textureSets[i], meshBakerMaterialTexture, textureSets[i].obUVoffset, textureSets[i].obUVscale, rs[i], _texPropertyName, _resultMaterialTextureBlender);
		}
		stopwatch.Stop();
		stopwatch.Start();
		if (LOG_LEVEL >= MB2_LogLevel.debug)
		{
			UnityEngine.Debug.Log("Total time for Graphics.DrawTexture calls " + stopwatch.ElapsedMilliseconds.ToString("f5"));
		}
		if (LOG_LEVEL >= MB2_LogLevel.debug)
		{
			UnityEngine.Debug.Log("Copying RenderTexture to Texture2D.");
		}
		Texture2D texture2D = new Texture2D(_destinationTexture.width, _destinationTexture.height, TextureFormat.ARGB32, mipChain: true);
		int num = _destinationTexture.width / 512;
		int num2 = _destinationTexture.height / 512;
		if (num == 0 || num2 == 0)
		{
			if (LOG_LEVEL >= MB2_LogLevel.trace)
			{
				UnityEngine.Debug.Log("Copying all in one shot");
			}
			RenderTexture.active = _destinationTexture;
			texture2D.ReadPixels(new Rect(0f, 0f, _destinationTexture.width, _destinationTexture.height), 0, 0, recalculateMipMaps: true);
			RenderTexture.active = null;
		}
		else if (IsOpenGL())
		{
			if (LOG_LEVEL >= MB2_LogLevel.trace)
			{
				UnityEngine.Debug.Log("OpenGL copying blocks");
			}
			for (int j = 0; j < num; j++)
			{
				for (int k = 0; k < num2; k++)
				{
					RenderTexture.active = _destinationTexture;
					texture2D.ReadPixels(new Rect(j * 512, k * 512, 512f, 512f), j * 512, k * 512, recalculateMipMaps: true);
					RenderTexture.active = null;
				}
			}
		}
		else
		{
			if (LOG_LEVEL >= MB2_LogLevel.trace)
			{
				UnityEngine.Debug.Log("Not OpenGL copying blocks");
			}
			for (int l = 0; l < num; l++)
			{
				for (int m = 0; m < num2; m++)
				{
					RenderTexture.active = _destinationTexture;
					texture2D.ReadPixels(new Rect(l * 512, _destinationTexture.height - 512 - m * 512, 512f, 512f), l * 512, m * 512, recalculateMipMaps: true);
					RenderTexture.active = null;
				}
			}
		}
		texture2D.Apply();
		myCamera.targetTexture = null;
		RenderTexture.active = null;
		targTex = texture2D;
		if (LOG_LEVEL >= MB2_LogLevel.debug)
		{
			UnityEngine.Debug.Log("Total time to copy RenderTexture to Texture2D " + stopwatch.ElapsedMilliseconds.ToString("f5"));
		}
	}

	private Color32 ConvertNormalFormatFromUnity_ToStandard(Color32 c)
	{
		Vector3 zero = Vector3.zero;
		zero.x = (float)(int)c.a * 2f - 1f;
		zero.y = (float)(int)c.g * 2f - 1f;
		zero.z = Mathf.Sqrt(1f - zero.x * zero.x - zero.y * zero.y);
		Color32 result = default(Color32);
		result.a = 1;
		result.r = (byte)((zero.x + 1f) * 0.5f);
		result.g = (byte)((zero.y + 1f) * 0.5f);
		result.b = (byte)((zero.z + 1f) * 0.5f);
		return result;
	}

	private bool IsOpenGL()
	{
		return SystemInfo.graphicsDeviceVersion.StartsWith("OpenGL");
	}

	private void CopyScaledAndTiledToAtlas(MB3_TextureCombiner.MB_TexSet texSet, MB3_TextureCombiner.MeshBakerMaterialTexture source, Vector2 obUVoffset, Vector2 obUVscale, Rect rec, ShaderTextureProperty texturePropertyName, TextureBlender resultMatTexBlender)
	{
		Rect rect = rec;
		if (resultMatTexBlender != null)
		{
			myCamera.backgroundColor = resultMatTexBlender.GetColorIfNoTexture(texSet.mats[0].mat, texturePropertyName);
		}
		else
		{
			myCamera.backgroundColor = MB3_TextureCombiner.GetColorIfNoTexture(texturePropertyName);
		}
		if (source.t == null)
		{
			source.t = combiner._createTemporaryTexture(16, 16, TextureFormat.ARGB32, mipMaps: true);
		}
		rect.y = 1f - (rect.y + rect.height);
		rect.x *= _destinationTexture.width;
		rect.y *= _destinationTexture.height;
		rect.width *= _destinationTexture.width;
		rect.height *= _destinationTexture.height;
		Rect rect2 = rect;
		rect2.x -= _padding;
		rect2.y -= _padding;
		rect2.width += _padding * 2;
		rect2.height += _padding * 2;
		Rect r = source.matTilingRect.GetRect();
		Rect screenRect = default(Rect);
		if (_fixOutOfBoundsUVs)
		{
			Rect r2 = new Rect(obUVoffset.x, obUVoffset.y, obUVscale.x, obUVscale.y);
			r = MB3_UVTransformUtility.CombineTransforms(ref r, ref r2);
			if (LOG_LEVEL >= MB2_LogLevel.trace)
			{
				UnityEngine.Debug.Log("Fixing out of bounds UVs for tex " + source.t);
			}
		}
		Texture2D t = source.t;
		TextureWrapMode wrapMode = t.wrapMode;
		if (r.width == 1f && r.height == 1f && r.x == 0f && r.y == 0f)
		{
			t.wrapMode = TextureWrapMode.Clamp;
		}
		else
		{
			t.wrapMode = TextureWrapMode.Repeat;
		}
		if (LOG_LEVEL >= MB2_LogLevel.trace)
		{
			UnityEngine.Debug.Log(string.Concat("DrawTexture tex=", t.name, " destRect=", rect, " srcRect=", r, " Mat=", mat));
		}
		Rect sourceRect = default(Rect);
		sourceRect.x = r.x;
		sourceRect.y = r.y + 1f - 1f / (float)t.height;
		sourceRect.width = r.width;
		sourceRect.height = 1f / (float)t.height;
		screenRect.x = rect.x;
		screenRect.y = rect2.y;
		screenRect.width = rect.width;
		screenRect.height = _padding;
		Graphics.DrawTexture(screenRect, t, sourceRect, 0, 0, 0, 0, mat);
		sourceRect.x = r.x;
		sourceRect.y = r.y;
		sourceRect.width = r.width;
		sourceRect.height = 1f / (float)t.height;
		screenRect.x = rect.x;
		screenRect.y = rect.y + rect.height;
		screenRect.width = rect.width;
		screenRect.height = _padding;
		Graphics.DrawTexture(screenRect, t, sourceRect, 0, 0, 0, 0, mat);
		sourceRect.x = r.x;
		sourceRect.y = r.y;
		sourceRect.width = 1f / (float)t.width;
		sourceRect.height = r.height;
		screenRect.x = rect2.x;
		screenRect.y = rect.y;
		screenRect.width = _padding;
		screenRect.height = rect.height;
		Graphics.DrawTexture(screenRect, t, sourceRect, 0, 0, 0, 0, mat);
		sourceRect.x = r.x + 1f - 1f / (float)t.width;
		sourceRect.y = r.y;
		sourceRect.width = 1f / (float)t.width;
		sourceRect.height = r.height;
		screenRect.x = rect.x + rect.width;
		screenRect.y = rect.y;
		screenRect.width = _padding;
		screenRect.height = rect.height;
		Graphics.DrawTexture(screenRect, t, sourceRect, 0, 0, 0, 0, mat);
		sourceRect.x = r.x;
		sourceRect.y = r.y + 1f - 1f / (float)t.height;
		sourceRect.width = 1f / (float)t.width;
		sourceRect.height = 1f / (float)t.height;
		screenRect.x = rect2.x;
		screenRect.y = rect2.y;
		screenRect.width = _padding;
		screenRect.height = _padding;
		Graphics.DrawTexture(screenRect, t, sourceRect, 0, 0, 0, 0, mat);
		sourceRect.x = r.x + 1f - 1f / (float)t.width;
		sourceRect.y = r.y + 1f - 1f / (float)t.height;
		sourceRect.width = 1f / (float)t.width;
		sourceRect.height = 1f / (float)t.height;
		screenRect.x = rect.x + rect.width;
		screenRect.y = rect2.y;
		screenRect.width = _padding;
		screenRect.height = _padding;
		Graphics.DrawTexture(screenRect, t, sourceRect, 0, 0, 0, 0, mat);
		sourceRect.x = r.x;
		sourceRect.y = r.y;
		sourceRect.width = 1f / (float)t.width;
		sourceRect.height = 1f / (float)t.height;
		screenRect.x = rect2.x;
		screenRect.y = rect.y + rect.height;
		screenRect.width = _padding;
		screenRect.height = _padding;
		Graphics.DrawTexture(screenRect, t, sourceRect, 0, 0, 0, 0, mat);
		sourceRect.x = r.x + 1f - 1f / (float)t.width;
		sourceRect.y = r.y;
		sourceRect.width = 1f / (float)t.width;
		sourceRect.height = 1f / (float)t.height;
		screenRect.x = rect.x + rect.width;
		screenRect.y = rect.y + rect.height;
		screenRect.width = _padding;
		screenRect.height = _padding;
		Graphics.DrawTexture(screenRect, t, sourceRect, 0, 0, 0, 0, mat);
		Graphics.DrawTexture(rect, t, r, 0, 0, 0, 0, mat);
		t.wrapMode = wrapMode;
	}

	private void _printTexture(Texture2D t)
	{
		if (t.width * t.height > 100)
		{
			UnityEngine.Debug.Log("Not printing texture too large.");
		}
		try
		{
			Color32[] pixels = t.GetPixels32();
			string text = "";
			for (int i = 0; i < t.height; i++)
			{
				for (int j = 0; j < t.width; j++)
				{
					text = string.Concat(text, pixels[i * t.width + j], ", ");
				}
				text += "\n";
			}
			UnityEngine.Debug.Log(text);
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.Log("Could not print texture. texture may not be readable." + ex.ToString());
		}
	}
}
[ExecuteInEditMode]
public class MB3_AtlasPackerRenderTexture : MonoBehaviour
{
	private MB_TextureCombinerRenderTexture fastRenderer;

	private bool _doRenderAtlas;

	public int width;

	public int height;

	public int padding;

	public bool isNormalMap;

	public bool fixOutOfBoundsUVs;

	public bool considerNonTextureProperties;

	public TextureBlender resultMaterialTextureBlender;

	public Rect[] rects;

	public Texture2D tex1;

	public List<MB3_TextureCombiner.MB_TexSet> textureSets;

	public int indexOfTexSetToRender;

	public ShaderTextureProperty texPropertyName;

	public MB2_LogLevel LOG_LEVEL = MB2_LogLevel.info;

	public Texture2D testTex;

	public Material testMat;

	public Texture2D OnRenderAtlas(MB3_TextureCombiner combiner)
	{
		fastRenderer = new MB_TextureCombinerRenderTexture();
		_doRenderAtlas = true;
		Texture2D result = fastRenderer.DoRenderAtlas(base.gameObject, width, height, padding, rects, textureSets, indexOfTexSetToRender, texPropertyName, resultMaterialTextureBlender, isNormalMap, fixOutOfBoundsUVs, considerNonTextureProperties, combiner, LOG_LEVEL);
		_doRenderAtlas = false;
		return result;
	}

	private void OnRenderObject()
	{
		if (_doRenderAtlas)
		{
			fastRenderer.OnRenderObject();
			_doRenderAtlas = false;
		}
	}
}
public class MB3_KMeansClustering
{
	private class DataPoint
	{
		public Vector3 center;

		public GameObject gameObject;

		public int Cluster;

		public DataPoint(GameObject go)
		{
			gameObject = go;
			center = go.transform.position;
			if (go.GetComponent<Renderer>() == null)
			{
				UnityEngine.Debug.LogError("Object does not have a renderer " + go);
			}
		}
	}

	private List<DataPoint> _normalizedDataToCluster = new List<DataPoint>();

	private Vector3[] _clusters = new Vector3[0];

	private int _numberOfClusters;

	public MB3_KMeansClustering(List<GameObject> gos, int numClusters)
	{
		for (int i = 0; i < gos.Count; i++)
		{
			if (gos[i] != null)
			{
				DataPoint item = new DataPoint(gos[i]);
				_normalizedDataToCluster.Add(item);
			}
			else
			{
				UnityEngine.Debug.LogWarning($"Object {i} in list of objects to cluster was null.");
			}
		}
		if (numClusters <= 0)
		{
			UnityEngine.Debug.LogError("Number of clusters must be posititve.");
			numClusters = 1;
		}
		if (_normalizedDataToCluster.Count <= numClusters)
		{
			UnityEngine.Debug.LogError("There must be fewer clusters than objects to cluster");
			numClusters = _normalizedDataToCluster.Count - 1;
		}
		_numberOfClusters = numClusters;
		if (_numberOfClusters <= 0)
		{
			_numberOfClusters = 1;
		}
		_clusters = new Vector3[_numberOfClusters];
	}

	private void InitializeCentroids()
	{
		for (int i = 0; i < _numberOfClusters; i++)
		{
			_normalizedDataToCluster[i].Cluster = i;
		}
		for (int j = _numberOfClusters; j < _normalizedDataToCluster.Count; j++)
		{
			_normalizedDataToCluster[j].Cluster = UnityEngine.Random.Range(0, _numberOfClusters);
		}
	}

	private bool UpdateDataPointMeans(bool force)
	{
		if (AnyAreEmpty(_normalizedDataToCluster) && !force)
		{
			return false;
		}
		Vector3[] array = new Vector3[_numberOfClusters];
		int[] array2 = new int[_numberOfClusters];
		for (int i = 0; i < _normalizedDataToCluster.Count; i++)
		{
			int cluster = _normalizedDataToCluster[i].Cluster;
			array[cluster] += _normalizedDataToCluster[i].center;
			array2[cluster]++;
		}
		for (int j = 0; j < _numberOfClusters; j++)
		{
			_clusters[j] = array[j] / array2[j];
		}
		return true;
	}

	private bool AnyAreEmpty(List<DataPoint> data)
	{
		int[] array = new int[_numberOfClusters];
		for (int i = 0; i < _normalizedDataToCluster.Count; i++)
		{
			array[_normalizedDataToCluster[i].Cluster]++;
		}
		for (int j = 0; j < array.Length; j++)
		{
			if (array[j] == 0)
			{
				return true;
			}
		}
		return false;
	}

	private bool UpdateClusterMembership()
	{
		bool flag = false;
		float[] array = new float[_numberOfClusters];
		for (int i = 0; i < _normalizedDataToCluster.Count; i++)
		{
			for (int j = 0; j < _numberOfClusters; j++)
			{
				array[j] = ElucidanDistance(_normalizedDataToCluster[i], _clusters[j]);
			}
			int num = MinIndex(array);
			if (num != _normalizedDataToCluster[i].Cluster)
			{
				flag = true;
				_normalizedDataToCluster[i].Cluster = num;
			}
		}
		if (!flag)
		{
			return false;
		}
		return true;
	}

	private float ElucidanDistance(DataPoint dataPoint, Vector3 mean)
	{
		return Vector3.Distance(dataPoint.center, mean);
	}

	private int MinIndex(float[] distances)
	{
		int result = 0;
		double num = distances[0];
		for (int i = 0; i < distances.Length; i++)
		{
			if ((double)distances[i] < num)
			{
				num = distances[i];
				result = i;
			}
		}
		return result;
	}

	public List<Renderer> GetCluster(int idx, out Vector3 mean, out float size)
	{
		if (idx < 0 || idx >= _numberOfClusters)
		{
			UnityEngine.Debug.LogError("idx is out of bounds");
			mean = Vector3.zero;
			size = 1f;
			return new List<Renderer>();
		}
		UpdateDataPointMeans(force: true);
		List<Renderer> list = new List<Renderer>();
		mean = _clusters[idx];
		float num = 0f;
		for (int i = 0; i < _normalizedDataToCluster.Count; i++)
		{
			if (_normalizedDataToCluster[i].Cluster == idx)
			{
				float num2 = Vector3.Distance(mean, _normalizedDataToCluster[i].center);
				if (num2 > num)
				{
					num = num2;
				}
				list.Add(_normalizedDataToCluster[i].gameObject.GetComponent<Renderer>());
			}
		}
		mean = _clusters[idx];
		size = num;
		return list;
	}

	public void Cluster()
	{
		bool flag = true;
		bool flag2 = true;
		InitializeCentroids();
		int num = _normalizedDataToCluster.Count * 1000;
		int num2 = 0;
		while (flag2 && flag && num2 < num)
		{
			num2++;
			flag2 = UpdateDataPointMeans(force: false);
			flag = UpdateClusterMembership();
		}
	}
}
public enum EStringTable
{
	String_Hello = 1,
	String_Quit,
	String_Attack,
	String_Start,
	String_Chinese,
	String_English,
	String_Tips,
	Max
}
internal class Animal
{
	public string mName = "";

	public int mAttack;

	public int mHP;

	public float mMoveSpeed;

	public string[] mSkills;

	public string mSkillList
	{
		set
		{
			mSkills = value.Split(',');
		}
	}
}
public class DemoAnimals : MonoBehaviour
{
	private int mCurrentAnimal = 1;

	private Animal mAnimal;

	private OOFormArray mAnimalArray;

	private void SetAnimal(int animalID)
	{
		mAnimal = mAnimalArray.GetObject<Animal>(animalID);
	}

	private void Start()
	{
		mAnimalArray = OOFormArray.ReadFromResources("OOForm/Tables/Animals");
		SetAnimal(mCurrentAnimal);
	}

	private void Update()
	{
	}

	private void PrePage()
	{
		mCurrentAnimal--;
		if (mCurrentAnimal < 1)
		{
			mCurrentAnimal = mAnimalArray.mRowCount - 1;
		}
		SetAnimal(mCurrentAnimal);
	}

	private void NextPage()
	{
		mCurrentAnimal++;
		if (mCurrentAnimal >= mAnimalArray.mRowCount)
		{
			mCurrentAnimal = 1;
		}
		SetAnimal(mCurrentAnimal);
	}

	private void OnGUI()
	{
		if (GUI.Button(new Rect(10f, 50f, 100f, 50f), "<"))
		{
			PrePage();
		}
		GUI.Button(new Rect(110f, 50f, 50f, 50f), mCurrentAnimal.ToString());
		if (GUI.Button(new Rect(160f, 50f, 100f, 50f), ">"))
		{
			NextPage();
		}
		GUI.Label(new Rect(10f, 150f, 100f, 20f), "Name:");
		GUI.Label(new Rect(10f, 180f, 100f, 20f), "Attack:");
		GUI.Label(new Rect(10f, 210f, 100f, 20f), "HP:");
		GUI.Label(new Rect(10f, 240f, 100f, 20f), "MoveSpeed:");
		GUI.Label(new Rect(10f, 270f, 100f, 20f), "Skills:");
		if (mAnimal != null)
		{
			GUI.Button(new Rect(110f, 150f, 100f, 20f), mAnimal.mName);
			GUI.Button(new Rect(110f, 180f, 100f, 20f), mAnimal.mAttack.ToString());
			GUI.Button(new Rect(110f, 210f, 100f, 20f), mAnimal.mHP.ToString());
			GUI.Button(new Rect(110f, 240f, 100f, 20f), mAnimal.mMoveSpeed.ToString());
			GUI.SelectionGrid(new Rect(110f, 270f, mAnimal.mSkills.Length * 50, 20f), 0, mAnimal.mSkills, mAnimal.mSkills.Length);
		}
	}
}
public class DemoGameConfig : MonoBehaviour
{
	private string mSavePath;

	private OOFormArray mForm;

	private bool mIsTick;

	private Rect mWindowRect;

	private void Start()
	{
		mSavePath = Application.dataPath + "/GameConfig.txt";
		if (File.Exists(mSavePath))
		{
			mForm = OOFormArray.ReadFromFile(mSavePath);
		}
		else
		{
			mForm = OOFormArray.ReadFromResources("OOForm/Tables/GameConfig");
		}
		int intValue = mForm.GetInt("Value", "RUN_TIMES") + 1;
		mForm.SetInt(intValue, "Value", "RUN_TIMES");
		Save();
		mIsTick = mForm.GetBool("Value", "IS_TICK");
		mWindowRect = mForm.GetRect("Value", "WINDOW_RECT");
		UnityEngine.Debug.Log(mWindowRect.ToString());
	}

	private void Save()
	{
		mForm.SaveFormFile(mSavePath);
	}

	private void Update()
	{
	}

	private void OnGUI()
	{
		if (GUI.Button(new Rect(10f, 50f, 100f, 50f), "Save"))
		{
			mForm.SetString(DateTime.Now.ToString(), "Value", "SAVE_TIME");
			mForm.SetBool(mIsTick, "Value", "IS_TICK");
			mForm.SetRect(mWindowRect, "Value", "WINDOW_RECT");
			Save();
		}
		GUI.Label(new Rect(10f, 150f, 100f, 20f), "RunTimes:");
		GUI.Label(new Rect(10f, 180f, 100f, 20f), "SaveTime:");
		GUI.Label(new Rect(10f, 210f, 100f, 20f), "Text1:");
		GUI.Label(new Rect(10f, 240f, 100f, 20f), "Text2:");
		GUI.Label(new Rect(10f, 270f, 100f, 20f), "IsTick:");
		GUI.Label(new Rect(110f, 150f, 100f, 20f), mForm.GetString("Value", "RUN_TIMES"));
		GUI.Label(new Rect(110f, 180f, 300f, 20f), mForm.GetString("Value", "SAVE_TIME"));
		mForm.mData[1][3] = GUI.TextField(new Rect(110f, 210f, 300f, 20f), mForm.mData[1][3]);
		mForm.mData[1][4] = GUI.TextField(new Rect(110f, 240f, 300f, 20f), mForm.mData[1][4]);
		mIsTick = GUI.Toggle(new Rect(110f, 270f, 100f, 20f), mIsTick, "");
		mWindowRect = GUI.Window(0, mWindowRect, DoMyWindow, "Drag me and save");
	}

	private void DoMyWindow(int windowID)
	{
		GUI.DragWindow(new Rect(0f, 0f, 200f, 50f));
		GUI.Label(new Rect(10f, 20f, 100f, 20f), "X:" + mWindowRect.x + "  Y:" + mWindowRect.y);
	}
}
public class DemoNetTable : MonoBehaviour
{
	private OOFormArray mFormArray;

	private void Start()
	{
		StartCoroutine(StartGetNetTable());
	}

	private IEnumerator StartGetNetTable()
	{
		string text = "http://ooform.ooroom.com/NetItem.txt";
		UnityEngine.Debug.Log(text);
		WWW www = new WWW(text);
		yield return www;
		UnicodeEncoding unicodeEncoding = new UnicodeEncoding();
		mFormArray = OOFormArray.GetForm(unicodeEncoding.GetString(www.bytes));
	}

	private void Update()
	{
	}

	private void OnGUI()
	{
		if (mFormArray == null)
		{
			return;
		}
		for (int i = 0; i < mFormArray.mRowCount; i++)
		{
			for (int j = 0; j < mFormArray.mColumnCount; j++)
			{
				GUI.Label(new Rect(j * 100 + 100, i * 25 + 100, 100f, 23f), mFormArray.mData[j][i]);
			}
		}
	}
}
public class DemoOtherFormatTable : MonoBehaviour
{
	private OOFormArray mFormArray;

	private void Start()
	{
	}

	private void Update()
	{
	}

	private void OnGUI()
	{
		if (GUI.Button(new Rect(10f, 75f, 150f, 30f), "Animals(CSV)"))
		{
			TextAsset textAsset = Resources.Load("OOForm/OtherFormatTables/AnimalsCSV.csv") as TextAsset;
			mFormArray = OOFormArray.GetFormByCSVString(textAsset.text);
		}
		if (GUI.Button(new Rect(170f, 75f, 150f, 30f), "GameConfig(Json)"))
		{
			TextAsset textAsset2 = Resources.Load("OOForm/OtherFormatTables/GameConfigJson") as TextAsset;
			mFormArray = OOFormArray.GetFormByJsonString(textAsset2.text);
		}
		if (GUI.Button(new Rect(330f, 75f, 150f, 30f), "StringTable(XML)"))
		{
			TextAsset textAsset3 = Resources.Load("OOForm/OtherFormatTables/StringTableXML") as TextAsset;
			mFormArray = OOFormArray.GetFormByXMLString(textAsset3.text);
		}
		if (mFormArray == null)
		{
			return;
		}
		for (int i = 0; i < mFormArray.mRowCount; i++)
		{
			for (int j = 0; j < mFormArray.mColumnCount; j++)
			{
				GUI.Label(new Rect(j * 120 + 100, i * 25 + 150, 100f, 23f), mFormArray.mData[j][i]);
			}
		}
	}
}
public class DemoRuntimeEditTable : MonoBehaviour
{
	private OOFormArray mForm;

	private string mSavePath;

	private void Start()
	{
		mSavePath = Application.dataPath + "/RuntimeTable.txt";
		if (File.Exists(mSavePath))
		{
			mForm = OOFormArray.ReadFromFile(mSavePath);
		}
		else
		{
			mForm = OOFormArray.ReadFromResources("OOForm/Tables/RuntimeTable");
		}
	}

	private void Update()
	{
		if (Input.GetMouseButtonDown(0) && mForm != null)
		{
			int num = UnityEngine.Random.Range(50, 100);
			Rect rect = new Rect(Input.mousePosition.x - (float)(num / 2), (float)Screen.height - (Input.mousePosition.y + (float)(num / 2)), num, num);
			string stringValue = UnityEngine.Random.Range(100, 999).ToString();
			mForm.InsertRow(mForm.mRowCount);
			mForm.SetRect(rect, "rect", mForm.mRowCount - 1);
			mForm.SetString(stringValue, "name", mForm.mRowCount - 1);
			Save();
		}
	}

	private void Save()
	{
		mForm.SaveFormFile(mSavePath);
	}

	private void OnGUI()
	{
		if (mForm == null)
		{
			return;
		}
		for (int i = 1; i < mForm.mRowCount; i++)
		{
			if (GUI.Button(mForm.GetRect("rect", i), mForm.GetString("name", i)))
			{
				mForm.DeleteRow(i);
				Save();
				break;
			}
		}
	}
}
public class StringTableManager
{
	public static SystemLanguage mLanguage = Application.systemLanguage;

	public static OOFormArray mForm = null;

	public static string GetString(object key)
	{
		if (mForm == null)
		{
			mForm = OOFormArray.ReadFromResources("OOForm/Tables/StringTable");
		}
		return mForm.GetString(mLanguage.ToString(), key);
	}
}
public class DemoStringTable : MonoBehaviour
{
	private void Start()
	{
		UnityEngine.Debug.Log(StringTableManager.GetString(EStringTable.String_Quit));
		UnityEngine.Debug.Log(StringTableManager.GetString("String_Attack"));
		UnityEngine.Debug.Log(StringTableManager.mForm.GetString("English", "String_Tips"));
		SetLanguage(SystemLanguage.English);
	}

	private void SetLanguage(SystemLanguage language)
	{
		StringTableManager.mLanguage = language;
	}

	private void OnGUI()
	{
		string text = ((StringTableManager.mLanguage == SystemLanguage.English) ? ("--[" + StringTableManager.GetString("String_English") + "]--") : StringTableManager.GetString("String_English"));
		string text2 = ((StringTableManager.mLanguage == SystemLanguage.Chinese) ? ("--[" + StringTableManager.GetString("String_Chinese") + "]--") : StringTableManager.GetString("String_Chinese"));
		if (GUI.Button(new Rect(10f, 50f, 100f, 50f), text))
		{
			SetLanguage(SystemLanguage.English);
		}
		if (GUI.Button(new Rect(110f, 50f, 100f, 50f), text2))
		{
			SetLanguage(SystemLanguage.Chinese);
		}
		GUI.Label(new Rect(10f, 150f, 200f, 20f), StringTableManager.GetString(1));
		GUI.Label(new Rect(10f, 180f, 200f, 20f), StringTableManager.GetString(EStringTable.String_Quit));
		GUI.Label(new Rect(10f, 210f, 200f, 20f), StringTableManager.GetString(EStringTable.String_Attack.ToString()));
		GUI.Label(new Rect(10f, 240f, 200f, 20f), StringTableManager.GetString("String_Start"));
	}
}
public class OOFormArray
{
	private int _mColumnCount;

	private int _mRowCount;

	public List<List<string>> mData = new List<List<string>>();

	public Dictionary<string, int> mColumnDic;

	public Dictionary<string, int> mRowDic;

	public int mCurrentRow = -1;

	public int mColumnCount => _mColumnCount;

	public int mRowCount => _mRowCount;

	public void SetCurrentRow(int currentRow)
	{
		mCurrentRow = currentRow;
	}

	public void InsertColumn(int _index)
	{
		List<string> list = new List<string>();
		for (int i = 0; i < _mRowCount; i++)
		{
			list.Add("");
		}
		mData.Insert(_index, list);
		_mColumnCount++;
	}

	public void MoveColumnLeft(int columnIndex)
	{
		List<string> value = mData[columnIndex];
		int num = columnIndex - 1;
		if (num < 0)
		{
			num = mColumnCount - 1;
		}
		mData[columnIndex] = mData[num];
		mData[num] = value;
	}

	public void MoveColumnRight(int columnIndex)
	{
		List<string> value = mData[columnIndex];
		int num = columnIndex + 1;
		if (num >= mColumnCount)
		{
			num = 0;
		}
		mData[columnIndex] = mData[num];
		mData[num] = value;
	}

	public void DeleteColumn(int _index)
	{
		mData.RemoveAt(_index);
		_mColumnCount--;
		if (_mColumnCount == 0)
		{
			_mRowCount = 0;
		}
	}

	public void InsertRow(int _index)
	{
		foreach (List<string> mDatum in mData)
		{
			mDatum.Insert(_index, "");
		}
		_mRowCount++;
	}

	public void DeleteRow(int _index)
	{
		foreach (List<string> mDatum in mData)
		{
			mDatum.RemoveAt(_index);
		}
		_mRowCount--;
	}

	private void CheckColumnDic()
	{
		if (_mRowCount >= 1 && _mColumnCount >= 1 && mColumnDic == null)
		{
			RefreshColumnDic();
		}
	}

	public void RefreshColumnDic()
	{
		mColumnDic = new Dictionary<string, int>();
		for (int i = 0; i < _mColumnCount; i++)
		{
			string @string = GetString(i, 0);
			mColumnDic[@string.Split(',')[0]] = i;
		}
	}

	public void AddColumnName(string columnName, int columnIndex)
	{
		mColumnDic[columnName] = columnIndex;
	}

	private void CheckRowDic()
	{
		if (_mRowCount >= 1 && _mColumnCount >= 1 && mRowDic == null)
		{
			RefreshRowDic();
		}
	}

	public void RefreshRowDic()
	{
		mRowDic = new Dictionary<string, int>();
		for (int i = 0; i < _mRowCount; i++)
		{
			string @string = GetString(0, i);
			mRowDic[@string.Split(',')[0]] = i;
		}
	}

	public void AddRowName(string rowName, int rowIndex)
	{
		mRowDic[rowName] = rowIndex;
	}

	public int GetColumn(string columnKey)
	{
		CheckColumnDic();
		if (mColumnDic.ContainsKey(columnKey))
		{
			return mColumnDic[columnKey];
		}
		return -1;
	}

	public int GetRow(string rowKey)
	{
		CheckRowDic();
		if (mRowDic.ContainsKey(rowKey))
		{
			return mRowDic[rowKey];
		}
		return -1;
	}

	private int Object2Int(object obj)
	{
		return (int)obj;
	}

	private string GetStringData(object[] args)
	{
		if (args.Length == 0)
		{
			return "";
		}
		int num = -1;
		int num2 = -1;
		num = ((typeof(int) == args[0].GetType()) ? ((int)args[0]) : ((!(typeof(string) == args[0].GetType())) ? Object2Int(args[0]) : GetColumn((string)args[0])));
		num2 = ((args.Length < 2) ? mCurrentRow : ((typeof(int) == args[1].GetType()) ? ((int)args[1]) : ((!(typeof(string) == args[1].GetType())) ? Object2Int(args[1]) : GetRow((string)args[1]))));
		if (num < _mColumnCount && num >= 0 && num2 < _mRowCount && num2 >= 0)
		{
			return mData[num][num2];
		}
		return "";
	}

	public string GetString(params object[] args)
	{
		return GetStringData(args);
	}

	public int GetInt(params object[] args)
	{
		if (int.TryParse(GetStringData(args), out var result))
		{
			return result;
		}
		return 0;
	}

	public float GetFloat(params object[] args)
	{
		if (float.TryParse(GetStringData(args), out var result))
		{
			return result;
		}
		return 0f;
	}

	public bool GetBool(params object[] args)
	{
		if (bool.TryParse(GetStringData(args), out var result))
		{
			return result;
		}
		return false;
	}

	private float StringToFloat(string str)
	{
		if (float.TryParse(str, out var result))
		{
			return result;
		}
		return 0f;
	}

	public Rect GetRect(params object[] args)
	{
		string stringData = GetStringData(args);
		Rect result = new Rect(0f, 0f, 0f, 0f);
		string[] array = stringData.Split(',');
		if (array.Length >= 1)
		{
			result.x = StringToFloat(array[0]);
		}
		if (array.Length >= 2)
		{
			result.y = StringToFloat(array[1]);
		}
		if (array.Length >= 3)
		{
			result.width = StringToFloat(array[2]);
		}
		if (array.Length >= 4)
		{
			result.height = StringToFloat(array[3]);
		}
		return result;
	}

	public Vector2 GetVector2(params object[] args)
	{
		string stringData = GetStringData(args);
		Vector2 result = new Vector2(0f, 0f);
		string[] array = stringData.Split(',');
		if (array.Length >= 1)
		{
			result.x = StringToFloat(array[0]);
		}
		if (array.Length >= 2)
		{
			result.y = StringToFloat(array[1]);
		}
		return result;
	}

	public Vector3 GetVector3(params object[] args)
	{
		string stringData = GetStringData(args);
		Vector3 result = new Vector3(0f, 0f, 0f);
		string[] array = stringData.Split(',');
		if (array.Length >= 1)
		{
			result.x = StringToFloat(array[0]);
		}
		if (array.Length >= 2)
		{
			result.y = StringToFloat(array[1]);
		}
		if (array.Length >= 3)
		{
			result.y = StringToFloat(array[2]);
		}
		return result;
	}

	public Vector4 GetVector4(params object[] args)
	{
		string stringData = GetStringData(args);
		Vector4 result = new Vector4(0f, 0f, 0f, 0f);
		string[] array = stringData.Split(',');
		if (array.Length >= 1)
		{
			result.x = StringToFloat(array[0]);
		}
		if (array.Length >= 2)
		{
			result.y = StringToFloat(array[1]);
		}
		if (array.Length >= 3)
		{
			result.z = StringToFloat(array[2]);
		}
		if (array.Length >= 4)
		{
			result.w = StringToFloat(array[3]);
		}
		return result;
	}

	public bool SetStringData(string stringValue, object[] args)
	{
		if (args.Length == 0)
		{
			return false;
		}
		int num = -1;
		int num2 = -1;
		num = ((typeof(int) == args[0].GetType()) ? ((int)args[0]) : ((!(typeof(string) == args[0].GetType())) ? Object2Int(args[0]) : GetColumn((string)args[0])));
		num2 = ((args.Length < 2) ? mCurrentRow : ((typeof(int) == args[1].GetType()) ? ((int)args[1]) : ((!(typeof(string) == args[1].GetType())) ? Object2Int(args[1]) : GetRow((string)args[1]))));
		if (num < _mColumnCount && num >= 0 && num2 < _mRowCount && num2 >= 0)
		{
			mData[num][num2] = stringValue;
			return true;
		}
		return false;
	}

	public bool SetString(string stringValue, params object[] args)
	{
		return SetStringData(stringValue, args);
	}

	public bool SetInt(int intValue, params object[] args)
	{
		return SetStringData(intValue.ToString(), args);
	}

	public bool SetFloat(float floatValue, params object[] args)
	{
		return SetStringData(floatValue.ToString(), args);
	}

	public bool SetBool(bool boolValue, params object[] args)
	{
		return SetStringData(boolValue.ToString(), args);
	}

	public bool SetRect(Rect rect, params object[] args)
	{
		string stringValue = rect.x + "," + rect.y + "," + rect.width + "," + rect.height;
		return SetStringData(stringValue, args);
	}

	public bool SetVector2(Vector2 vec2, params object[] args)
	{
		string stringValue = vec2.x + "," + vec2.y;
		return SetStringData(stringValue, args);
	}

	public bool SetVector3(Vector3 vec3, params object[] args)
	{
		string stringValue = vec3.x + "," + vec3.y + "," + vec3.z;
		return SetStringData(stringValue, args);
	}

	public bool SetVector4(Vector4 vec4, params object[] args)
	{
		string stringValue = vec4.x + "," + vec4.y + "," + vec4.z + "," + vec4.w;
		return SetStringData(stringValue, args);
	}

	public static OOFormArray ReadFromResources(string formPath)
	{
		return GetForm(((TextAsset)Resources.Load(formPath)).text);
	}

	public static OOFormArray ReadFromTextAsset(TextAsset asset)
	{
		if (asset != null)
		{
			return GetForm(asset.text);
		}
		return GetForm("");
	}

	public static OOFormArray ReadFromFile(string formPath)
	{
		return GetForm(OOFormTools.ReadFileText(formPath));
	}

	public void SaveFormFile(string fileName)
	{
		OOFormTools.WriteFileText(fileName, ToString());
	}

	public static OOFormArray ReadFromJsonFile(string formPath)
	{
		return GetFormByJsonString(OOFormTools.ReadFileText(formPath));
	}

	public static OOFormArray ReadFromXMLFile(string formPath)
	{
		return GetFormByXMLString(OOFormTools.ReadFileText(formPath));
	}

	public static OOFormArray ReadFormCSVFile(string formPath)
	{
		return GetFormByCSVString(OOFormTools.ReadFileText(formPath));
	}

	public static OOFormArray GetFormByXMLString(string xmlString)
	{
		if (xmlString[0] == '\ufeff')
		{
			xmlString = xmlString.Substring(1);
		}
		OOFormArray oOFormArray = new OOFormArray();
		XmlDocument xmlDocument = new XmlDocument();
		xmlDocument.LoadXml(xmlString);
		oOFormArray.InsertRow(0);
		oOFormArray.InsertColumn(0);
		foreach (XmlNode childNode in xmlDocument.FirstChild.ChildNodes)
		{
			oOFormArray.InsertRow(oOFormArray.mRowCount);
			foreach (XmlAttribute attribute in childNode.Attributes)
			{
				if (oOFormArray.GetColumn(attribute.Name) == -1)
				{
					if (oOFormArray.mColumnDic.Count <= 1)
					{
						oOFormArray.SetString(attribute.Name, 0, 0);
						oOFormArray.AddColumnName(attribute.Name, 0);
					}
					else
					{
						oOFormArray.InsertColumn(oOFormArray.mColumnCount);
						oOFormArray.SetString(attribute.Name, oOFormArray.mColumnCount - 1, 0);
						oOFormArray.AddColumnName(attribute.Name, oOFormArray.mColumnCount - 1);
					}
				}
				oOFormArray.SetString(attribute.Value.ToString(), oOFormArray.GetColumn(attribute.Name), oOFormArray.mRowCount - 1);
			}
		}
		return oOFormArray;
	}

	public static OOFormArray GetFormByJsonString(string jsonString)
	{
		OOFormArray oOFormArray = new OOFormArray();
		List<System.Collections.Hashtable> list = JsonMapper.ToObject<List<System.Collections.Hashtable>>(jsonString);
		oOFormArray.InsertRow(0);
		oOFormArray.InsertColumn(0);
		foreach (System.Collections.Hashtable item in list)
		{
			oOFormArray.InsertRow(oOFormArray.mRowCount);
			foreach (string key in item.Keys)
			{
				if (oOFormArray.GetColumn(key) == -1)
				{
					if (oOFormArray.mColumnDic.Count <= 1)
					{
						oOFormArray.SetString(key, 0, 0);
						oOFormArray.AddColumnName(key, 0);
					}
					else
					{
						oOFormArray.InsertColumn(oOFormArray.mColumnCount);
						oOFormArray.SetString(key, oOFormArray.mColumnCount - 1, 0);
						oOFormArray.AddColumnName(key, oOFormArray.mColumnCount - 1);
					}
				}
				oOFormArray.SetString(item[key].ToString(), oOFormArray.GetColumn(key), oOFormArray.mRowCount - 1);
			}
		}
		return oOFormArray;
	}

	public static string[] GetCSVStringList(string csvLine)
	{
		List<string> list = new List<string>();
		string text = "";
		bool flag = false;
		for (int i = 0; i < csvLine.Length; i++)
		{
			if (csvLine[i] == ',')
			{
				if (!flag)
				{
					list.Add(text);
					text = "";
				}
				else
				{
					text += csvLine[i];
				}
			}
			else if (csvLine[i] == '"')
			{
				if (i != csvLine.Length - 1)
				{
					if (!flag)
					{
						flag = true;
					}
					else if (i + 1 <= csvLine.Length - 1)
					{
						if (csvLine[i + 1] == '"')
						{
							text += "\"";
							i++;
						}
						else if (csvLine[i + 1] == ',')
						{
							flag = false;
						}
					}
				}
				else
				{
					list.Add(text);
					text = "";
					flag = false;
				}
			}
			else
			{
				text += csvLine[i];
			}
		}
		if (text == "")
		{
			if (csvLine.Length > 0 && csvLine[csvLine.Length - 1] == ',')
			{
				list.Add("");
			}
		}
		else
		{
			list.Add(text);
		}
		return list.ToArray();
	}

	public static OOFormArray GetFormByCSVString(string formString)
	{
		OOFormArray oOFormArray = new OOFormArray();
		string[] array = formString.Split('\n');
		int num = 0;
		int num2 = array.Length;
		if (num2 > 0)
		{
			string[] cSVStringList = GetCSVStringList(array[0]);
			num = cSVStringList.Length;
			oOFormArray.InsertRow(0);
			for (int i = 0; i < num; i++)
			{
				oOFormArray.InsertColumn(i);
				oOFormArray.mData[i][0] = cSVStringList[i].Replace("\r", "");
			}
			for (int j = 1; j < num2; j++)
			{
				string[] cSVStringList2 = GetCSVStringList(array[j]);
				int num3 = Mathf.Min(num, cSVStringList2.Length);
				oOFormArray.InsertRow(j);
				for (int k = 0; k < num3; k++)
				{
					oOFormArray.mData[k][j] = cSVStringList2[k].Replace("\r", "");
				}
			}
		}
		return oOFormArray;
	}

	public static OOFormArray GetForm(string formString)
	{
		OOFormArray oOFormArray = new OOFormArray();
		string[] array = formString.Split('\n');
		int num = 0;
		int num2 = array.Length;
		if (num2 > 0)
		{
			string[] array2 = array[0].Split('\t');
			num = array2.Length;
			oOFormArray.InsertRow(0);
			for (int i = 0; i < num; i++)
			{
				oOFormArray.InsertColumn(i);
				oOFormArray.mData[i][0] = array2[i].Replace("\r", "");
			}
			for (int j = 1; j < num2; j++)
			{
				string[] array3 = array[j].Split('\t');
				int num3 = Mathf.Min(num, array3.Length);
				oOFormArray.InsertRow(j);
				for (int k = 0; k < num3; k++)
				{
					oOFormArray.mData[k][j] = array3[k].Replace("\r", "");
				}
			}
		}
		return oOFormArray;
	}

	public override string ToString()
	{
		string text = "";
		for (int i = 0; i < _mRowCount; i++)
		{
			for (int j = 0; j < _mColumnCount; j++)
			{
				text = text + mData[j][i] + "\t";
			}
			text = text.Substring(0, text.Length - 1);
			text += "\r\n";
		}
		if (text.Length > 0)
		{
			text = text.Substring(0, text.Length - 1);
		}
		return text;
	}

	public string ToJsonString()
	{
		List<System.Collections.Hashtable> list = new List<System.Collections.Hashtable>();
		for (int i = 1; i < mRowCount; i++)
		{
			System.Collections.Hashtable hashtable = new System.Collections.Hashtable();
			for (int j = 0; j < mColumnCount; j++)
			{
				string text = mData[j][0];
				string key = text.Split(',')[0];
				if (text.Contains("[float]"))
				{
					hashtable[key] = GetFloat(j, i);
				}
				else if (text.Contains("[int]"))
				{
					hashtable[key] = GetInt(j, i);
				}
				else if (text.Contains("[bool]"))
				{
					hashtable[key] = GetBool(j, i);
				}
				else
				{
					hashtable[key] = GetString(j, i);
				}
			}
			list.Add(hashtable);
		}
		return JsonMapper.ToJson(list);
	}

	public string ToXMLString()
	{
		XmlDocument xmlDocument = new XmlDocument();
		XmlElement xmlElement = xmlDocument.CreateElement("Root");
		xmlDocument.AppendChild(xmlElement);
		for (int i = 1; i < mRowCount; i++)
		{
			XmlElement xmlElement2 = xmlDocument.CreateElement("Data");
			for (int j = 0; j < mColumnCount; j++)
			{
				string text = mData[j][0];
				if (!(text == ""))
				{
					string name = text.Split(',')[0];
					xmlElement2.SetAttribute(name, GetString(j, i));
				}
			}
			xmlElement.AppendChild(xmlElement2);
		}
		return xmlDocument.InnerXml;
	}

	public string ToCSVString()
	{
		string text = "";
		for (int i = 0; i < mRowCount; i++)
		{
			for (int j = 0; j < mColumnCount; j++)
			{
				string @string = GetString(j, i);
				@string = @string.Replace("\"", "\"\"");
				if (@string.Contains(","))
				{
					@string = "\"" + @string + "\"";
				}
				text = text + @string + ",";
			}
			text = text.Substring(0, text.Length - 1);
			text += "\r\n";
		}
		return text.Substring(0, text.Length - 1);
	}

	private string GetJsonString(int rowIndex)
	{
		if (rowIndex >= mRowCount && rowIndex < 1)
		{
			return "{}";
		}
		System.Collections.Hashtable hashtable = new System.Collections.Hashtable();
		for (int i = 0; i < mColumnCount; i++)
		{
			string text = mData[i][0];
			string key = text.Split(',')[0];
			if (text.Contains("[float]"))
			{
				hashtable[key] = GetFloat(i, rowIndex);
			}
			else if (text.Contains("[int]"))
			{
				hashtable[key] = GetInt(i, rowIndex);
			}
			else if (text.Contains("[bool]"))
			{
				hashtable[key] = GetBool(i, rowIndex);
			}
			else
			{
				hashtable[key] = GetString(i, rowIndex);
			}
		}
		return JsonMapper.ToJson(hashtable);
	}

	public T GetObject<T>(int rowIndex)
	{
		return JsonMapper.ToObject<T>(GetJsonString(rowIndex));
	}
}
public class OOFormManager : ScriptableObject
{
	public List<TextAsset> mTableList = new List<TextAsset>();
}
public class OOFormMenuManager : ScriptableObject
{
	public List<OOFormManager> mTableManagerList = new List<OOFormManager>();

	public List<string> mTableMenuItemList = new List<string>();

	public List<TextAsset> mTableList = new List<TextAsset>();

	public List<string> mTableMenuList = new List<string>();
}
public class OOFormTools
{
	public static string ReadFileText(string pathName)
	{
		string result = "";
		if (File.Exists(pathName))
		{
			FileStream fileStream = File.Open(pathName, FileMode.Open);
			byte[] array = new BinaryReader(fileStream).ReadBytes(2);
			Encoding @default = Encoding.Default;
			@default = ((array.Length == 0 || array[0] < 239) ? Encoding.Default : ((array[0] == 239 && array[1] == 187) ? Encoding.UTF8 : ((array[0] == 254 && array[1] == byte.MaxValue) ? Encoding.BigEndianUnicode : ((array[0] != byte.MaxValue || array[1] != 254) ? Encoding.Default : Encoding.Unicode))));
			fileStream.Position = 0L;
			StreamReader streamReader = new StreamReader(fileStream, @default);
			string text = "";
			string text2 = "";
			while ((text = streamReader.ReadLine()) != null)
			{
				text2 = text2 + text + "\n";
			}
			if (text2.Length > 0)
			{
				text2 = text2.Substring(0, text2.Length - 1);
			}
			result = text2;
		}
		else
		{
			UnityEngine.Debug.Log("Cannot Read File");
		}
		return result;
	}

	public static bool WriteFileText(string pathName, string textString)
	{
		new StreamWriter(File.Open(pathName, FileMode.Create), Encoding.Unicode).Write(textString);
		return true;
	}

	public static bool WriteFileText(string pathName, string textString, Encoding encodeType)
	{
		new StreamWriter(File.Open(pathName, FileMode.Create), encodeType).Write(textString);
		return true;
	}

	public static bool CheckDirectory(string pathName)
	{
		if (!Directory.Exists(pathName))
		{
			Directory.CreateDirectory(pathName);
		}
		return true;
	}
}
public class ChannelSelector : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
{
	public string Channel;

	public void SetChannel(string channel)
	{
		Channel = channel;
		GetComponentInChildren<Text>().text = Channel;
	}

	public void OnPointerClick(PointerEventData eventData)
	{
		UnityEngine.Object.FindObjectOfType<ChatGui>().ShowChannel(Channel);
	}
}
[ExecuteInEditMode]
public class ChatAppIdCheckerUI : MonoBehaviour
{
	public Text Description;

	public void Update()
	{
		if (string.IsNullOrEmpty(PhotonNetwork.PhotonServerSettings.AppSettings.AppIdChat))
		{
			if (Description != null)
			{
				Description.text = "<Color=Red>WARNING:</Color>\nPlease setup a Chat AppId in the PhotonServerSettings file.";
			}
		}
		else if (Description != null)
		{
			Description.text = string.Empty;
		}
	}
}
public class ChatGui : MonoBehaviour, IChatClientListener
{
	public string[] ChannelsToJoinOnConnect;

	public string[] FriendsList;

	public int HistoryLengthToFetch;

	private string selectedChannelName;

	public ChatClient chatClient;

	protected internal AppSettings chatAppSettings;

	public GameObject missingAppIdErrorPanel;

	public GameObject ConnectingLabel;

	public RectTransform ChatPanel;

	public GameObject UserIdFormPanel;

	public InputField InputFieldChat;

	public Text CurrentChannelText;

	public Toggle ChannelToggleToInstantiate;

	public GameObject FriendListUiItemtoInstantiate;

	private readonly Dictionary<string, Toggle> channelToggles = new Dictionary<string, Toggle>();

	private readonly Dictionary<string, FriendItem> friendListItemLUT = new Dictionary<string, FriendItem>();

	public bool ShowState = true;

	public GameObject Title;

	public Text StateText;

	public Text UserIdText;

	private static string HelpText = "\n    -- HELP --\nTo subscribe to channel(s):\n\t<color=#E07B00>\\subscribe</color> <color=green><list of channelnames></color>\n\tor\n\t<color=#E07B00>\\s</color> <color=green><list of channelnames></color>\n\nTo leave channel(s):\n\t<color=#E07B00>\\unsubscribe</color> <color=green><list of channelnames></color>\n\tor\n\t<color=#E07B00>\\u</color> <color=green><list of channelnames></color>\n\nTo switch the active channel\n\t<color=#E07B00>\\join</color> <color=green><channelname></color>\n\tor\n\t<color=#E07B00>\\j</color> <color=green><channelname></color>\n\nTo send a private message:\n\t\\<color=#E07B00>msg</color> <color=green><username></color> <color=green><message></color>\n\nTo change status:\n\t\\<color=#E07B00>state</color> <color=green><stateIndex></color> <color=green><message></color>\n<color=green>0</color> = Offline <color=green>1</color> = Invisible <color=green>2</color> = Online <color=green>3</color> = Away \n<color=green>4</color> = Do not disturb <color=green>5</color> = Looking For Group <color=green>6</color> = Playing\n\nTo clear the current chat tab (private chats get closed):\n\t<color=#E07B00>\\clear</color>";

	public int TestLength = 2048;

	private byte[] testBytes = new byte[2048];

	public string UserName { get; set; }

	public void Start()
	{
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		UserIdText.text = "";
		StateText.text = "";
		StateText.gameObject.SetActive(value: true);
		UserIdText.gameObject.SetActive(value: true);
		Title.SetActive(value: true);
		ChatPanel.gameObject.SetActive(value: false);
		ConnectingLabel.SetActive(value: false);
		if (string.IsNullOrEmpty(UserName))
		{
			UserName = "user" + Environment.TickCount % 99;
		}
		chatAppSettings = PhotonNetwork.PhotonServerSettings.AppSettings;
		bool flag = !string.IsNullOrEmpty(chatAppSettings.AppIdChat);
		missingAppIdErrorPanel.SetActive(!flag);
		UserIdFormPanel.gameObject.SetActive(flag);
		if (!flag)
		{
			UnityEngine.Debug.LogError("You need to set the chat app ID in the PhotonServerSettings file in order to continue.");
		}
	}

	public void Connect()
	{
		UserIdFormPanel.gameObject.SetActive(value: false);
		chatClient = new ChatClient(this);
		chatClient.UseBackgroundWorkerForSending = true;
		chatClient.Connect(chatAppSettings.AppIdChat, "1.0", new Photon.Chat.AuthenticationValues(UserName));
		ChannelToggleToInstantiate.gameObject.SetActive(value: false);
		UnityEngine.Debug.Log("Connecting as: " + UserName);
		ConnectingLabel.SetActive(value: true);
	}

	public void OnDestroy()
	{
		if (chatClient != null)
		{
			chatClient.Disconnect();
		}
	}

	public void OnApplicationQuit()
	{
		if (chatClient != null)
		{
			chatClient.Disconnect();
		}
	}

	public void Update()
	{
		if (chatClient != null)
		{
			chatClient.Service();
		}
		if (StateText == null)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
		else
		{
			StateText.gameObject.SetActive(ShowState);
		}
	}

	public void OnEnterSend()
	{
		if (Input.GetKey(KeyCode.Return) || Input.GetKey(KeyCode.KeypadEnter))
		{
			SendChatMessage(InputFieldChat.text);
			InputFieldChat.text = "";
		}
	}

	public void OnClickSend()
	{
		if (InputFieldChat != null)
		{
			SendChatMessage(InputFieldChat.text);
			InputFieldChat.text = "";
		}
	}

	private void SendChatMessage(string inputLine)
	{
		if (string.IsNullOrEmpty(inputLine))
		{
			return;
		}
		if ("test".Equals(inputLine))
		{
			if (TestLength != testBytes.Length)
			{
				testBytes = new byte[TestLength];
			}
			chatClient.SendPrivateMessage(chatClient.AuthValues.UserId, testBytes, forwardAsWebhook: true);
		}
		bool flag = chatClient.PrivateChannels.ContainsKey(selectedChannelName);
		string target = string.Empty;
		if (flag)
		{
			target = selectedChannelName.Split(':')[1];
		}
		if (inputLine[0].Equals('\\'))
		{
			string[] array = inputLine.Split(new char[1] { ' ' }, 2);
			if (array[0].Equals("\\help"))
			{
				PostHelpToCurrentChannel();
			}
			if (array[0].Equals("\\state"))
			{
				int num = 0;
				List<string> list = new List<string>();
				list.Add("i am state " + num);
				string[] array2 = array[1].Split(' ', ',');
				if (array2.Length != 0)
				{
					num = int.Parse(array2[0]);
				}
				if (array2.Length > 1)
				{
					list.Add(array2[1]);
				}
				chatClient.SetOnlineStatus(num, list.ToArray());
			}
			else if ((array[0].Equals("\\subscribe") || array[0].Equals("\\s")) && !string.IsNullOrEmpty(array[1]))
			{
				chatClient.Subscribe(array[1].Split(' ', ','));
			}
			else if ((array[0].Equals("\\unsubscribe") || array[0].Equals("\\u")) && !string.IsNullOrEmpty(array[1]))
			{
				chatClient.Unsubscribe(array[1].Split(' ', ','));
			}
			else if (array[0].Equals("\\clear"))
			{
				ChatChannel channel;
				if (flag)
				{
					chatClient.PrivateChannels.Remove(selectedChannelName);
				}
				else if (chatClient.TryGetChannel(selectedChannelName, flag, out channel))
				{
					channel.ClearMessages();
				}
			}
			else if (array[0].Equals("\\msg") && !string.IsNullOrEmpty(array[1]))
			{
				string[] array3 = array[1].Split(new char[2] { ' ', ',' }, 2);
				if (array3.Length >= 2)
				{
					string target2 = array3[0];
					string message = array3[1];
					chatClient.SendPrivateMessage(target2, message);
				}
			}
			else if ((array[0].Equals("\\join") || array[0].Equals("\\j")) && !string.IsNullOrEmpty(array[1]))
			{
				string[] array4 = array[1].Split(new char[2] { ' ', ',' }, 2);
				if (channelToggles.ContainsKey(array4[0]))
				{
					ShowChannel(array4[0]);
					return;
				}
				chatClient.Subscribe(new string[1] { array4[0] });
			}
			else
			{
				UnityEngine.Debug.Log("The command '" + array[0] + "' is invalid.");
			}
		}
		else if (flag)
		{
			chatClient.SendPrivateMessage(target, inputLine);
		}
		else
		{
			chatClient.PublishMessage(selectedChannelName, inputLine);
		}
	}

	public void PostHelpToCurrentChannel()
	{
		CurrentChannelText.text += HelpText;
	}

	public void DebugReturn(DebugLevel level, string message)
	{
		switch (level)
		{
		case DebugLevel.ERROR:
			UnityEngine.Debug.LogError(message);
			break;
		case DebugLevel.WARNING:
			UnityEngine.Debug.LogWarning(message);
			break;
		default:
			UnityEngine.Debug.Log(message);
			break;
		}
	}

	public void OnConnected()
	{
		if (ChannelsToJoinOnConnect != null && ChannelsToJoinOnConnect.Length != 0)
		{
			chatClient.Subscribe(ChannelsToJoinOnConnect, HistoryLengthToFetch);
		}
		ConnectingLabel.SetActive(value: false);
		UserIdText.text = "Connected as " + UserName;
		ChatPanel.gameObject.SetActive(value: true);
		if (FriendsList != null && FriendsList.Length != 0)
		{
			chatClient.AddFriends(FriendsList);
			string[] friendsList = FriendsList;
			foreach (string text in friendsList)
			{
				if (FriendListUiItemtoInstantiate != null && text != UserName)
				{
					InstantiateFriendButton(text);
				}
			}
		}
		if (FriendListUiItemtoInstantiate != null)
		{
			FriendListUiItemtoInstantiate.SetActive(value: false);
		}
		chatClient.SetOnlineStatus(2);
	}

	public void OnDisconnected()
	{
		ConnectingLabel.SetActive(value: false);
	}

	public void OnChatStateChange(ChatState state)
	{
		StateText.text = state.ToString();
	}

	public void OnSubscribed(string[] channels, bool[] results)
	{
		foreach (string channelName in channels)
		{
			chatClient.PublishMessage(channelName, "says 'hi'.");
			if (ChannelToggleToInstantiate != null)
			{
				InstantiateChannelButton(channelName);
			}
		}
		UnityEngine.Debug.Log("OnSubscribed: " + string.Join(", ", channels));
		ShowChannel(channels[0]);
	}

	private void InstantiateChannelButton(string channelName)
	{
		if (channelToggles.ContainsKey(channelName))
		{
			UnityEngine.Debug.Log("Skipping creation for an existing channel toggle.");
			return;
		}
		Toggle toggle = UnityEngine.Object.Instantiate(ChannelToggleToInstantiate);
		toggle.gameObject.SetActive(value: true);
		toggle.GetComponentInChildren<ChannelSelector>().SetChannel(channelName);
		toggle.transform.SetParent(ChannelToggleToInstantiate.transform.parent, worldPositionStays: false);
		channelToggles.Add(channelName, toggle);
	}

	private void InstantiateFriendButton(string friendId)
	{
		GameObject obj = UnityEngine.Object.Instantiate(FriendListUiItemtoInstantiate);
		obj.gameObject.SetActive(value: true);
		FriendItem component = obj.GetComponent<FriendItem>();
		component.FriendId = friendId;
		obj.transform.SetParent(FriendListUiItemtoInstantiate.transform.parent, worldPositionStays: false);
		friendListItemLUT[friendId] = component;
	}

	public void OnUnsubscribed(string[] channels)
	{
		foreach (string text in channels)
		{
			if (channelToggles.ContainsKey(text))
			{
				UnityEngine.Object.Destroy(channelToggles[text].gameObject);
				channelToggles.Remove(text);
				UnityEngine.Debug.Log("Unsubscribed from channel '" + text + "'.");
				if (text == selectedChannelName && channelToggles.Count > 0)
				{
					IEnumerator<KeyValuePair<string, Toggle>> enumerator = channelToggles.GetEnumerator();
					enumerator.MoveNext();
					ShowChannel(enumerator.Current.Key);
					enumerator.Current.Value.isOn = true;
				}
			}
			else
			{
				UnityEngine.Debug.Log("Can't unsubscribe from channel '" + text + "' because you are currently not subscribed to it.");
			}
		}
	}

	public void OnGetMessages(string channelName, string[] senders, object[] messages)
	{
		if (channelName.Equals(selectedChannelName))
		{
			ShowChannel(selectedChannelName);
		}
	}

	public void OnPrivateMessage(string sender, object message, string channelName)
	{
		InstantiateChannelButton(channelName);
		if (message is byte[] array)
		{
			UnityEngine.Debug.Log("Message with byte[].Length: " + array.Length);
		}
		if (selectedChannelName.Equals(channelName))
		{
			ShowChannel(channelName);
		}
	}

	public void OnStatusUpdate(string user, int status, bool gotMessage, object message)
	{
		UnityEngine.Debug.LogWarning("status: " + $"{user} is {status}. Msg:{message}");
		if (friendListItemLUT.ContainsKey(user))
		{
			FriendItem friendItem = friendListItemLUT[user];
			if (friendItem != null)
			{
				friendItem.OnFriendStatusUpdate(status, gotMessage, message);
			}
		}
	}

	public void OnUserSubscribed(string channel, string user)
	{
		UnityEngine.Debug.LogFormat("OnUserSubscribed: channel=\"{0}\" userId=\"{1}\"", channel, user);
	}

	public void OnUserUnsubscribed(string channel, string user)
	{
		UnityEngine.Debug.LogFormat("OnUserUnsubscribed: channel=\"{0}\" userId=\"{1}\"", channel, user);
	}

	public void AddMessageToSelectedChannel(string msg)
	{
		ChatChannel channel = null;
		if (!chatClient.TryGetChannel(selectedChannelName, out channel))
		{
			UnityEngine.Debug.Log("AddMessageToSelectedChannel failed to find channel: " + selectedChannelName);
		}
		else
		{
			channel?.Add("Bot", msg, 0);
		}
	}

	public void ShowChannel(string channelName)
	{
		if (string.IsNullOrEmpty(channelName))
		{
			return;
		}
		ChatChannel channel = null;
		if (!chatClient.TryGetChannel(channelName, out channel))
		{
			UnityEngine.Debug.Log("ShowChannel failed to find channel: " + channelName);
			return;
		}
		selectedChannelName = channelName;
		CurrentChannelText.text = channel.ToStringMessages();
		UnityEngine.Debug.Log("ShowChannel: " + selectedChannelName);
		foreach (KeyValuePair<string, Toggle> channelToggle in channelToggles)
		{
			channelToggle.Value.isOn = ((channelToggle.Key == channelName) ? true : false);
		}
	}

	public void OpenDashboard()
	{
		Application.OpenURL("https://dashboard.photonengine.com");
	}
}
public class FriendItem : MonoBehaviour
{
	public Text NameLabel;

	public Text StatusLabel;

	public Text Health;

	[HideInInspector]
	public string FriendId
	{
		get
		{
			return NameLabel.text;
		}
		set
		{
			NameLabel.text = value;
		}
	}

	public void Awake()
	{
		Health.text = string.Empty;
	}

	public void OnFriendStatusUpdate(int status, bool gotMessage, object message)
	{
		StatusLabel.text = status switch
		{
			1 => "Invisible", 
			2 => "Online", 
			3 => "Away", 
			4 => "Do not disturb", 
			5 => "Looking For Game/Group", 
			6 => "Playing", 
			_ => "Offline", 
		};
		if (gotMessage)
		{
			string text = string.Empty;
			if (message != null && message is string[] array && array.Length >= 2)
			{
				text = array[1] + "%";
			}
			Health.text = text;
		}
	}
}
public class IgnoreUiRaycastWhenInactive : MonoBehaviour, ICanvasRaycastFilter
{
	public bool IsRaycastLocationValid(Vector2 screenPoint, Camera eventCamera)
	{
		return base.gameObject.activeInHierarchy;
	}
}
[RequireComponent(typeof(ChatGui))]
public class NamePickGui : MonoBehaviour
{
	private const string UserNamePlayerPref = "NamePickUserName";

	public ChatGui chatNewComponent;

	public InputField idInput;

	public void Start()
	{
		chatNewComponent = UnityEngine.Object.FindObjectOfType<ChatGui>();
		string @string = PlayerPrefs.GetString("NamePickUserName");
		if (!string.IsNullOrEmpty(@string))
		{
			idInput.text = @string;
		}
	}

	public void EndEditOnEnter()
	{
		if (Input.GetKey(KeyCode.Return) || Input.GetKey(KeyCode.KeypadEnter))
		{
			StartChat();
		}
	}

	public void StartChat()
	{
		ChatGui chatGui = UnityEngine.Object.FindObjectOfType<ChatGui>();
		chatGui.UserName = idInput.text.Trim();
		chatGui.Connect();
		base.enabled = false;
		PlayerPrefs.SetString("NamePickUserName", chatGui.UserName);
	}
}
public class ScoreHelper : MonoBehaviour
{
	public int Score;

	private int _currentScore;

	private void Start()
	{
	}

	private void Update()
	{
		if (PhotonNetwork.LocalPlayer != null && Score != _currentScore)
		{
			_currentScore = Score;
			PhotonNetwork.LocalPlayer.SetScore(Score);
		}
	}
}
[AddComponentMenu("Pixelplacement/iTweenPath")]
public class iTweenPath : MonoBehaviour
{
	public string pathName = "";

	public Color pathColor = Color.cyan;

	public List<Vector3> nodes = new List<Vector3>
	{
		Vector3.zero,
		Vector3.zero
	};

	public int nodeCount;

	public static Dictionary<string, iTweenPath> paths = new Dictionary<string, iTweenPath>();

	public bool initialized;

	public string initialName = "";

	public bool pathVisible = true;

	public bool bUseGameobjName;

	private void OnEnable()
	{
		if (bUseGameobjName)
		{
			pathName = base.gameObject.name;
		}
		if (!paths.ContainsKey(pathName))
		{
			paths.Add(pathName.ToLower(), this);
		}
	}

	private void OnDisable()
	{
		paths.Remove(pathName.ToLower());
	}

	private void OnDrawGizmosSelected()
	{
		if (pathVisible && nodes.Count > 0)
		{
			iTween.DrawPath(nodes.ToArray(), pathColor);
		}
	}

	public static Vector3[] GetPath(string requestedName)
	{
		requestedName = requestedName.ToLower();
		if (paths.ContainsKey(requestedName))
		{
			return paths[requestedName].nodes.ToArray();
		}
		UnityEngine.Debug.Log("No path with that name (" + requestedName + ") exists! Are you sure you wrote it correctly?");
		return null;
	}

	public static Vector3[] GetPathReversed(string requestedName)
	{
		requestedName = requestedName.ToLower();
		if (paths.ContainsKey(requestedName))
		{
			List<Vector3> range = paths[requestedName].nodes.GetRange(0, paths[requestedName].nodes.Count);
			range.Reverse();
			return range.ToArray();
		}
		UnityEngine.Debug.Log("No path with that name (" + requestedName + ") exists! Are you sure you wrote it correctly?");
		return null;
	}
}
public class ExampleWheelController : MonoBehaviour
{
	private static class Uniforms
	{
		internal static readonly int _MotionAmount = Shader.PropertyToID("_MotionAmount");
	}

	public float acceleration;

	public Renderer motionVectorRenderer;

	private Rigidbody m_Rigidbody;

	private void Start()
	{
		m_Rigidbody = GetComponent<Rigidbody>();
		m_Rigidbody.maxAngularVelocity = 100f;
	}

	private void Update()
	{
		if (Input.GetKey(KeyCode.UpArrow))
		{
			m_Rigidbody.AddRelativeTorque(new Vector3(-1f * acceleration, 0f, 0f), ForceMode.Acceleration);
		}
		else if (Input.GetKey(KeyCode.DownArrow))
		{
			m_Rigidbody.AddRelativeTorque(new Vector3(1f * acceleration, 0f, 0f), ForceMode.Acceleration);
		}
		float value = (0f - m_Rigidbody.angularVelocity.x) / 100f;
		if ((bool)motionVectorRenderer)
		{
			motionVectorRenderer.material.SetFloat(Uniforms._MotionAmount, Mathf.Clamp(value, -0.25f, 0.25f));
		}
	}
}
public class ProjectTestScript : MonoBehaviourPunCallbacks
{
	public VRNpc player;

	public void Start()
	{
		player = VRGlobal.G_GameSystem.CurPlayer;
	}

	public void Update()
	{
		if (!Input.GetKeyDown(KeyCode.J))
		{
			return;
		}
		for (int i = 0; i < VRGlobal.npcLib.Count; i++)
		{
			if (VRGlobal.npcLib[i] is VRMonster || VRGlobal.npcLib[i] is VRBoss)
			{
				Vector3 pos = VRGlobal.npcLib[i].transform.position;
				VRGlobal.npcLib[i].OnDamage(10000f, ref player, sound: true, ref pos);
			}
		}
	}
}
public class ScreenFadeControl : MonoBehaviour
{
	public Material fadeMaterial;

	private void OnCustomPostRender()
	{
		fadeMaterial.SetPass(0);
		GL.PushMatrix();
		GL.LoadOrtho();
		GL.Color(fadeMaterial.color);
		GL.Begin(7);
		GL.Vertex3(0f, 0f, -12f);
		GL.Vertex3(0f, 1f, -12f);
		GL.Vertex3(1f, 1f, -12f);
		GL.Vertex3(1f, 0f, -12f);
		GL.End();
		GL.PopMatrix();
	}
}
public class ScreenFader : MonoBehaviour
{
	public bool fadeIn = true;

	public float fadeTime = 2f;

	public Color fadeColor = new Color(0f, 0f, 0f, 1f);

	public Material fadeMaterial;

	private bool faded;

	private bool lastFadeIn;

	private List<ScreenFadeControl> fadeControls = new List<ScreenFadeControl>();

	private void SetFadersEnabled(bool value)
	{
		foreach (ScreenFadeControl fadeControl in fadeControls)
		{
			fadeControl.enabled = value;
		}
	}

	public IEnumerator FadeOut()
	{
		if (!faded)
		{
			float elapsedTime = 0f;
			Color color = fadeColor;
			color.a = 0f;
			fadeMaterial.color = color;
			while (elapsedTime < fadeTime)
			{
				yield return new WaitForEndOfFrame();
				elapsedTime += Time.deltaTime;
				color.a = Mathf.Clamp01(elapsedTime / fadeTime);
				fadeMaterial.color = color;
			}
		}
		faded = true;
	}

	public IEnumerator FadeIn()
	{
		if (faded)
		{
			float elapsedTime = 0f;
			Color color3 = (fadeMaterial.color = fadeColor);
			Color color = color3;
			while (elapsedTime < fadeTime)
			{
				yield return new WaitForEndOfFrame();
				elapsedTime += Time.deltaTime;
				color.a = 1f - Mathf.Clamp01(elapsedTime / fadeTime);
				fadeMaterial.color = color;
			}
		}
		faded = false;
		SetFadersEnabled(value: false);
	}

	public void Update()
	{
		if (lastFadeIn != fadeIn)
		{
			lastFadeIn = fadeIn;
			StartCoroutine(DoFade());
		}
	}

	public IEnumerator DoFade()
	{
		foreach (ScreenFadeControl fadeControl in fadeControls)
		{
			UnityEngine.Object.Destroy(fadeControl);
		}
		fadeControls.Clear();
		Camera[] allCameras = Camera.allCameras;
		for (int i = 0; i < allCameras.Length; i++)
		{
			ScreenFadeControl screenFadeControl = allCameras[i].gameObject.AddComponent<ScreenFadeControl>();
			screenFadeControl.fadeMaterial = fadeMaterial;
			fadeControls.Add(screenFadeControl);
		}
		if (fadeIn)
		{
			yield return StartCoroutine(FadeIn());
		}
		else
		{
			yield return StartCoroutine(FadeOut());
		}
	}
}
public class LightBeamsControlScript : MonoBehaviour
{
	public GameObject SourceObject;

	public GameObject TargetObject;

	public GameObject RayPrefab;

	public Color RayColor;

	public Vector3 PositionRange = Vector3.zero;

	public float RadiusA;

	public float RadiusB;

	public float WidthA;

	public float WidthB;

	public float FadeSpeed = 1f;

	public int NumRays = 10;

	private int Spawned;

	private float TimeToSpawnAll = 3f;

	private float spawnInterval = 1f;

	private float currentCountdown;

	private RayBehavior[] rays;

	private void setRayValues(RayBehavior ray)
	{
		ray.PositionRange = PositionRange;
		ray.BeginLocation = SourceObject;
		ray.EndLocation = TargetObject;
		ray.BeginColor = RayColor;
		ray.EndColor = RayColor;
		ray.WidthA = WidthA;
		ray.WidthB = WidthB;
		ray.RadiusA = RadiusA;
		ray.RadiusB = RadiusB;
		ray.FadeSpeed = FadeSpeed;
		ray.ResetRay();
	}

	private void SpawnRay()
	{
		if (Spawned < NumRays)
		{
			rays[Spawned] = UnityEngine.Object.Instantiate(RayPrefab).GetComponent<RayBehavior>();
			setRayValues(rays[Spawned]);
		}
		Spawned++;
		currentCountdown = spawnInterval;
	}

	private void Start()
	{
		spawnInterval = TimeToSpawnAll / (float)NumRays;
		rays = new RayBehavior[NumRays];
		SpawnRay();
	}

	private void Update()
	{
		if (Spawned < NumRays)
		{
			if (currentCountdown <= 0f)
			{
				SpawnRay();
			}
			currentCountdown -= Time.deltaTime;
		}
	}
}
public class LookAtBehaviour : MonoBehaviour
{
	public Transform Target;

	private void Start()
	{
	}

	private void Update()
	{
		if (Target != null)
		{
			base.transform.LookAt(Target);
		}
	}
}
public class LookAtCameraBehaviour : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
		if (!(Camera.current == null))
		{
			base.transform.LookAt(new Vector3(Camera.current.transform.position.x, base.transform.position.y, Camera.current.transform.position.z));
		}
	}
}
public class RayBehavior : MonoBehaviour
{
	public GameObject BeginLocation;

	public GameObject EndLocation;

	public Color BeginColor = Color.white;

	public Color EndColor = Color.white;

	public Vector3 PositionRange;

	public float WidthA = 1f;

	public float WidthB = 1f;

	public float RadiusA = 1f;

	public float RadiusB = 1f;

	private LineRenderer Line;

	private Animation Anim;

	private bool changed = true;

	private Vector3 Offset;

	public float AlphaCurve;

	public float FadeSpeed = 1f;

	public void ResetRay()
	{
		Offset = new Vector3(UnityEngine.Random.Range(0f - PositionRange.x, PositionRange.x), UnityEngine.Random.Range(0f - PositionRange.y, PositionRange.y), UnityEngine.Random.Range(0f - PositionRange.z, PositionRange.z));
		changed = true;
	}

	public void UpdateLineData()
	{
		Line.SetPosition(0, BeginLocation.transform.position + Offset * RadiusA);
		Line.SetPosition(1, EndLocation.transform.position + Offset * RadiusB);
		Line.SetWidth(WidthA, WidthB);
	}

	private void Start()
	{
		Line = GetComponent<LineRenderer>();
		Anim = GetComponent<Animation>();
		Anim["RayAlphaCurve"].speed = FadeSpeed;
	}

	private void Update()
	{
		if (changed)
		{
			changed = false;
			UpdateLineData();
		}
		Line.SetColors(new Color(BeginColor.r, BeginColor.g, BeginColor.b, AlphaCurve), new Color(EndColor.r, EndColor.g, EndColor.b, AlphaCurve));
	}
}
public class RotateBehaviour : MonoBehaviour
{
	public Vector3 RotationAmount;

	private void Start()
	{
	}

	private void Update()
	{
		base.transform.Rotate(RotationAmount * Time.deltaTime);
	}
}
public class TexturePan : MonoBehaviour
{
	public float scrollSpeed = 1f;

	private Renderer rend;

	private void Start()
	{
		rend = GetComponent<Renderer>();
	}

	private void Update()
	{
		float y = Time.time * scrollSpeed;
		rend.material.SetTextureOffset("_MainTex", new Vector2(0f, y));
	}
}
public class CustomTerrainScript : MonoBehaviour
{
	public Texture2D Bump0;

	public Texture2D Bump1;

	public Texture2D Bump2;

	public Texture2D Bump3;

	public float Tile0;

	public float Tile1;

	public float Tile2;

	public float Tile3;

	public float Spec0;

	public float Spec1;

	public float Spec2;

	public float Spec3;

	public float terrainSizeX;

	public float terrainSizeZ;

	private void Start()
	{
		Terrain terrain = (Terrain)GetComponent(typeof(Terrain));
		if ((bool)Bump0)
		{
			Shader.SetGlobalTexture("_BumpMap0", Bump0);
		}
		if ((bool)Bump1)
		{
			Shader.SetGlobalTexture("_BumpMap1", Bump1);
		}
		if ((bool)Bump2)
		{
			Shader.SetGlobalTexture("_BumpMap2", Bump2);
		}
		if ((bool)Bump3)
		{
			Shader.SetGlobalTexture("_BumpMap3", Bump3);
		}
		Shader.SetGlobalFloat("_Spec0", Spec0);
		Shader.SetGlobalFloat("_Spec1", Spec1);
		Shader.SetGlobalFloat("_Spec2", Spec2);
		Shader.SetGlobalFloat("_Spec3", Spec3);
		Shader.SetGlobalFloat("_Tile0", Tile0);
		Shader.SetGlobalFloat("_Tile1", Tile1);
		Shader.SetGlobalFloat("_Tile2", Tile2);
		Shader.SetGlobalFloat("_Tile3", Tile3);
		terrainSizeX = terrain.terrainData.size.x;
		terrainSizeZ = terrain.terrainData.size.z;
		Shader.SetGlobalFloat("_TerrainX", terrainSizeX);
		Shader.SetGlobalFloat("_TerrainZ", terrainSizeZ);
	}

	private void Update()
	{
		if ((bool)Bump0)
		{
			Shader.SetGlobalTexture("_BumpMap0", Bump0);
		}
		if ((bool)Bump1)
		{
			Shader.SetGlobalTexture("_BumpMap1", Bump1);
		}
		if ((bool)Bump2)
		{
			Shader.SetGlobalTexture("_BumpMap2", Bump2);
		}
		if ((bool)Bump3)
		{
			Shader.SetGlobalTexture("_BumpMap3", Bump3);
		}
		Shader.SetGlobalFloat("_Spec0", Spec0);
		Shader.SetGlobalFloat("_Spec1", Spec1);
		Shader.SetGlobalFloat("_Spec2", Spec2);
		Shader.SetGlobalFloat("_Spec3", Spec3);
		Shader.SetGlobalFloat("_Tile0", Tile0);
		Shader.SetGlobalFloat("_Tile1", Tile1);
		Shader.SetGlobalFloat("_Tile2", Tile2);
		Shader.SetGlobalFloat("_Tile3", Tile3);
		Shader.SetGlobalFloat("_TerrainX", terrainSizeX);
		Shader.SetGlobalFloat("_TerrainZ", terrainSizeZ);
	}
}
public class AtmoXfade : MonoBehaviour
{
	public enum FadeState
	{
		FadeDark,
		FadeBright
	}

	public Material skyMat;

	public Color skyBright = Color.grey;

	public Color skyDark = Color.black;

	public Light dirLight;

	public Color lightBright = Color.grey;

	public Color lightDark = Color.black;

	public float minLightIntensity = 0.2f;

	public float maxLightIntensity = 0.85f;

	private float curIntensity;

	public bool useRenderFog = true;

	public Color fogBright = Color.grey;

	public Color fogDark = Color.black;

	public float minFog = 0.004f;

	public float maxFog = 0.02f;

	public FadeState fadeState = FadeState.FadeBright;

	public float fadeTime = 80f;

	private void Start()
	{
		if ((bool)skyMat)
		{
			skyMat.SetColor("_Tint", skyBright);
		}
		if ((bool)dirLight)
		{
			dirLight.color = lightBright;
		}
		if (useRenderFog)
		{
			RenderSettings.fog = true;
			RenderSettings.fogColor = fogBright;
		}
		else
		{
			RenderSettings.fog = false;
		}
		curIntensity = maxLightIntensity;
	}

	private void OnTriggerEnter(Collider c)
	{
		if (c.sharedMaterial != null && c.sharedMaterial.name == "Player")
		{
			fadeState = FadeState.FadeDark;
			StartCoroutine(FadeDark());
		}
	}

	private void OnTriggerExit(Collider c)
	{
		if (c.sharedMaterial != null && c.sharedMaterial.name == "Player")
		{
			fadeState = FadeState.FadeBright;
			StartCoroutine(FadeBright());
		}
	}

	private IEnumerator FadeDark()
	{
		float t = 1E-05f;
		while (fadeState == FadeState.FadeDark && curIntensity > minLightIntensity)
		{
			skyMat.SetColor("_Tint", Color.Lerp(skyMat.GetColor("_Tint"), skyDark, t));
			dirLight.color = Color.Lerp(dirLight.color, lightDark, t);
			curIntensity = dirLight.intensity;
			dirLight.intensity = Mathf.SmoothStep(curIntensity, minLightIntensity, t);
			if (useRenderFog)
			{
				RenderSettings.fogColor = Color.Lerp(RenderSettings.fogColor, fogDark, t);
				RenderSettings.fogDensity = Mathf.SmoothStep(RenderSettings.fogDensity, maxFog, t);
			}
			yield return null;
			t += Time.deltaTime / fadeTime;
		}
	}

	private IEnumerator FadeBright()
	{
		float t = 1E-05f;
		while (fadeState == FadeState.FadeBright && curIntensity < maxLightIntensity)
		{
			skyMat.SetColor("_Tint", Color.Lerp(skyMat.GetColor("_Tint"), skyBright, t));
			dirLight.color = Color.Lerp(dirLight.color, lightBright, t);
			curIntensity = dirLight.intensity;
			dirLight.intensity = Mathf.SmoothStep(curIntensity, maxLightIntensity, t);
			if (useRenderFog)
			{
				RenderSettings.fogColor = Color.Lerp(RenderSettings.fogColor, fogBright, t);
				RenderSettings.fogDensity = Mathf.SmoothStep(RenderSettings.fogDensity, minFog, t);
			}
			yield return null;
			t += Time.deltaTime / fadeTime;
		}
	}
}
public class FlickerLight : MonoBehaviour
{
	public float lampSpeed = 0.1f;

	public float intens_Speed = 9f;

	public bool timung;

	public float minIntens = 0.8f;

	public float maxIntens = 3.5f;

	public bool loopEnd;

	public float range_Speed = 12f;

	public float minRange = 2.8f;

	public float maxRange = 13.5f;

	public Color col_Main = Color.white;

	public float col_Speed = 1.5f;

	public Color col_Blend1 = Color.yellow;

	public Color col_Blend2 = Color.red;

	private Color refCol;

	private float intens;

	private float randomIntens;

	private float range;

	private float randomRange;

	private GameObject lamp;

	private void Start()
	{
		lamp = base.gameObject;
		intens = lamp.GetComponent<Light>().intensity;
		range = lamp.GetComponent<Light>().range;
		lamp.GetComponent<Light>().color = col_Main;
		StartCoroutine(Timer());
	}

	private void LateUpdate()
	{
		if (loopEnd)
		{
			StartCoroutine(Timer());
		}
		intens = Mathf.SmoothStep(intens, randomIntens, Time.deltaTime * intens_Speed);
		range = Mathf.SmoothStep(range, randomRange, Time.deltaTime * range_Speed);
		lamp.GetComponent<Light>().intensity = intens;
		lamp.GetComponent<Light>().range = range;
		col_Main = Color.Lerp(col_Main, refCol, Time.deltaTime * col_Speed);
		lamp.GetComponent<Light>().color = col_Main;
	}

	private IEnumerator Timer()
	{
		timung = false;
		randomIntens = UnityEngine.Random.Range(minIntens, maxIntens);
		randomRange = UnityEngine.Random.Range(minRange, maxRange);
		refCol = Color.Lerp(col_Blend1, col_Blend2, UnityEngine.Random.value);
		yield return new WaitForSeconds(lampSpeed);
		timung = true;
		randomIntens = UnityEngine.Random.Range(minIntens, maxIntens);
		randomRange = UnityEngine.Random.Range(minRange, maxRange);
		refCol = Color.Lerp(col_Blend1, col_Blend2, UnityEngine.Random.value);
		yield return new WaitForSeconds(lampSpeed);
		loopEnd = true;
		randomIntens = UnityEngine.Random.Range(minIntens, maxIntens);
		randomRange = UnityEngine.Random.Range(minRange, maxRange);
		refCol = Color.Lerp(col_Blend1, col_Blend2, UnityEngine.Random.value);
		yield return null;
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Image Effects/Desaturate")]
public class DesaturateEffect : ImageEffectBase
{
	public float desaturateAmount;

	public Texture textureRamp;

	public float rampOffsetR;

	public float rampOffsetG;

	public float rampOffsetB;

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		base.material.SetTexture("_RampTex", textureRamp);
		base.material.SetFloat("_Desat", desaturateAmount);
		base.material.SetVector("_RampOffset", new Vector4(rampOffsetR, rampOffsetG, rampOffsetB, 0f));
		ImageEffects.BlitWithMaterial(base.material, source, destination);
	}
}
[ExecuteInEditMode]
public class TerrainRand : MonoBehaviour
{
	public GameObject prefab;

	public int count = 1000;

	public float randomRotationX;

	public float randomRotationY;

	public float randomRotationZ;
}
public class TUI : MonoBehaviour
{
	private void Awake()
	{
		GetComponent<Button>().onClick.AddListener(TestOnc);
	}

	private void Start()
	{
	}

	private void Update()
	{
	}

	public void TestOnc()
	{
		UnityEngine.Debug.Log("xiaoyang.........................TestOnc");
	}
}
public class Test3DTouch : MonoBehaviour, IPointerDownHandler, IEventSystemHandler, IPointerEnterHandler, IPointerClickHandler, IPointerExitHandler, IPointerUpHandler
{
	public Color enterColor = Color.red;

	public Color downColor = Color.blue;

	private Color normalColor;

	private Material mat;

	private void Awake()
	{
		mat = GetComponent<MeshRenderer>().material;
		normalColor = mat.color;
	}

	private void Start()
	{
	}

	public void OnPointerClick(PointerEventData eventData)
	{
		UnityEngine.Debug.Log("OnPointerClick");
	}

	public void OnPointerDown(PointerEventData eventData)
	{
		UnityEngine.Debug.Log("OnPointerDown");
		mat.color = downColor;
	}

	public void OnPointerEnter(PointerEventData eventData)
	{
		UnityEngine.Debug.Log("OnPointerEnter");
		mat.color = enterColor;
	}

	public void OnPointerExit(PointerEventData eventData)
	{
		UnityEngine.Debug.Log("OnPointerExit");
		mat.color = normalColor;
	}

	public void OnPointerUp(PointerEventData eventData)
	{
		mat.color = enterColor;
	}
}
public class SceneTreePack : MonoBehaviour
{
	public bool showLeaf;

	public float windpower;

	public Text treeNumberText;

	public List<GameObject> treePC = new List<GameObject>();

	private List<TreeControll> treeControlls = new List<TreeControll>();

	private int showNumber;

	private int treeCount;

	private void Start()
	{
		treeCount = base.transform.childCount;
		for (int i = 0; i < treeCount; i++)
		{
			treePC.Add(base.transform.GetChild(i).gameObject);
			treeControlls.Add(base.transform.GetChild(i).GetComponent<TreeControll>());
		}
		TreeShowHide(show: true);
	}

	public void TreeShowHide(bool show)
	{
		treePC[showNumber].SetActive(show);
		treeControlls[showNumber].SetWindPower = windpower;
		treeControlls[showNumber].LeafHideShow(showLeaf);
		treeNumberText.text = $"Tree {showNumber + 1}";
	}

	public void ButtonRight()
	{
		TreeShowHide(show: false);
		if (showNumber.Equals(treeCount - 1))
		{
			showNumber = 0;
		}
		else
		{
			showNumber++;
		}
		TreeShowHide(show: true);
	}

	public void ButtonLeft()
	{
		TreeShowHide(show: false);
		if (showNumber.Equals(0))
		{
			showNumber = treeCount - 1;
		}
		else
		{
			showNumber--;
		}
		TreeShowHide(show: true);
	}

	public void SetWindPower(float wind)
	{
		windpower = wind;
		treeControlls[showNumber].SetWindPower = wind;
	}

	public void ShowLeaf(bool show)
	{
		showLeaf = show;
		treeControlls[showNumber].LeafHideShow(showLeaf);
	}
}
public class TreeControll : MonoBehaviour
{
	public Animator treeAni;

	[Range(0f, 1f)]
	public float windPower = 0.5f;

	public bool showLeaf = true;

	public List<GameObject> leafs = new List<GameObject>();

	public float SetWindPower
	{
		set
		{
			windPower = value;
			if (!treeAni.Equals(null))
			{
				treeAni.SetFloat("Wind", windPower);
			}
		}
	}

	public bool ShowLeaf
	{
		set
		{
			showLeaf = value;
			LeafHideShow(showLeaf);
		}
	}

	private void Start()
	{
		LeafHideShow(showLeaf);
	}

	public void LeafHideShow(bool value)
	{
		showLeaf = value;
		if (!leafs.Count.Equals(0))
		{
			int count = leafs.Count;
			for (int i = 0; i < count; i++)
			{
				leafs[i].SetActive(showLeaf);
			}
		}
	}
}
public class VRBreakable : MonoBehaviour
{
	public float explodeForce = 100f;

	public float minPercent = 0.2f;

	public float maxPercent = 0.8f;

	public float RigidbodyMass = 1f;

	public bool canBeBreaked = true;

	public bool isDisappear = true;

	private bool isBreakedAlready;

	public AudioClip clip;

	private void Start()
	{
	}

	public void Explode(float percent)
	{
		if ((percent < maxPercent && percent >= minPercent) || (percent <= 0f && maxPercent == 0f))
		{
			ExplodeFace();
			playSound();
			isBreakedAlready = true;
		}
	}

	public void ExplodeFace()
	{
		if (canBeBreaked)
		{
			base.transform.parent = null;
			MeshCollider component = base.gameObject.GetComponent<MeshCollider>();
			if ((bool)component)
			{
				component.enabled = true;
			}
			Rigidbody rigidbody = base.gameObject.GetComponent<Rigidbody>();
			if (rigidbody == null)
			{
				rigidbody = base.gameObject.AddComponent<Rigidbody>();
			}
			rigidbody.mass = RigidbodyMass;
			rigidbody.isKinematic = false;
			rigidbody.useGravity = true;
			rigidbody.AddExplosionForce(explodeForce, Vector3.zero, 0f);
			if (isDisappear)
			{
				UnityEngine.Object.Destroy(base.gameObject, 3f);
			}
		}
	}

	private void playSound()
	{
		AudioSource audioSource = (AudioSource)base.gameObject.GetComponent("AudioSource");
		if ((bool)audioSource && !audioSource.isPlaying && clip != null)
		{
			audioSource.loop = false;
			audioSource.clip = clip;
			audioSource.rolloffMode = AudioRolloffMode.Linear;
			audioSource.Play();
		}
	}
}
public class VRFaceToCamera : MonoBehaviour
{
	public Transform target;

	private void Start()
	{
	}

	private void Update()
	{
		base.transform.forward = new Vector3(base.transform.position.x - target.transform.position.x, base.transform.position.y - target.transform.position.y, base.transform.position.z - target.transform.position.z);
	}
}
public class VRGameOverTips : MonoBehaviour
{
	public float IntervalTime = 2f;

	public string[] TipContent;

	private float CurIntervalTime;

	private AudioSource audioSource;

	private void Start()
	{
		CurIntervalTime = IntervalTime;
		audioSource = base.gameObject.GetComponent<AudioSource>();
	}

	private void Update()
	{
		if (VRGameSystem.CurGameState == GameState.GS_Fail)
		{
			CurIntervalTime += Time.deltaTime;
			if (CurIntervalTime >= IntervalTime)
			{
				CurIntervalTime = 0f;
				UpdateContent();
			}
		}
	}

	private void UpdateContent()
	{
		if ((bool)audioSource)
		{
			int num = UnityEngine.Random.Range(2, 5);
			Text component = base.gameObject.GetComponent<Text>();
			if ((bool)component)
			{
				component.text = Regex.Unescape(LTLocalization.GetText(TipContent[num]));
			}
		}
		else
		{
			int num2 = UnityEngine.Random.Range(0, TipContent.Length - 1);
			Text component2 = base.gameObject.GetComponent<Text>();
			if ((bool)component2)
			{
				component2.text = Regex.Unescape(LTLocalization.GetText(TipContent[num2]));
			}
		}
	}
}
public class VRLevel2YanZi : VRNpc
{
	private AudioSource dieSource;

	protected bool exp;

	private Light lit;

	private VRActorAction deadFlashAction;

	public bool bIsDamage;

	public string deathAniName = "";

	private bool mIsShowBubbleText;

	protected override bool MyAwake()
	{
		base.transform.localRotation = Quaternion.AngleAxis(180f, Vector3.up);
		m_animation = GetComponent<Animation>();
		base.Camp = EU_CAMP.EU_BAD;
		lit = base.gameObject.GetComponentInChildren<Light>();
		VRGlobal.npcLib.Add(this);
		return base.MyAwake();
	}

	public override bool MyReset()
	{
		dieSource = base.gameObject.GetComponent<AudioSource>();
		return base.MyReset();
	}

	protected override bool MyUpdate(float delta)
	{
		if (bIsDamage)
		{
			deadFlashAction = playEffectAction("deadFlash");
			base.gameObject.GetComponent<FlockChild>()._speed = 0f;
			GameObject dropItem = GetDropItem();
			if (dropItem != null)
			{
				dropItem.GetComponent<VRItemHP>().moveSpeed = 13f;
			}
			m_cunAction = deadFlashAction;
			if (VRGlobal.G_GameSystem.Gate.CurHP > VRGlobal.G_GameSystem.Gate.Hp)
			{
				VRGlobal.G_GameSystem.Gate.CurHP = VRGlobal.G_GameSystem.Gate.Hp;
			}
			VRGlobal.npcLib.Remove(this);
			bIsDamage = false;
			Invoke("TianJiaKongObj", 0.5f);
		}
		return base.MyUpdate(delta);
	}

	public override bool OnDamage(float dmgHP, ref VRNpc killer, bool sound, ref Vector3 pos, bool isAwarded = true)
	{
		if (dmgHP > 10f)
		{
			dieSource.Play();
			bIsDamage = true;
		}
		return true;
	}

	private void TianJiaKongObj()
	{
		VRGlobal.pushFreeEntity(base.gameObject);
	}
}
public class VRSecondAttackState : StateMachineBehaviour
{
	protected VRMonsterLevel2 ply;

	private float timer;

	private VRNpc vrPlayer;

	private VRNpc killer;

	private Vector3 pos;

	private float damage;

	public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		ply = animator.gameObject.GetComponent<VRMonsterLevel2>();
		ply.curNPCState = NPCState.Attack;
		ply.AnimatorClear();
		ply.StopFindPath();
		vrPlayer = ply.Target.GetComponent<VRNpc>();
		if (ply.Hp <= 0f || ply.CurHP <= 0f)
		{
			animator.SetTrigger("Die");
		}
		damage = ply.CurHP;
	}

	public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		if (ply.Hp <= 0f || ply.CurHP <= 0f)
		{
			animator.SetTrigger("Die");
		}
		timer += Time.deltaTime;
		if (timer >= ply.AtkTime && vrPlayer.CurHP > 0f)
		{
			timer = 0f;
			if ((bool)vrPlayer)
			{
				float dmgHP = ply.ATKFinal(ref vrPlayer, 1f);
				pos = Vector3.zero;
				vrPlayer.OnDamage(dmgHP, ref killer, sound: true, ref pos);
				if (ply.mAttackType == AttackType.AT_Explode)
				{
					animator.SetBool("dead", value: true);
					animator.SetTrigger("Die");
				}
			}
		}
		if (ply.CurHP > 0f && damage != ply.CurHP)
		{
			damage = ply.CurHP;
			animator.SetTrigger("Damage");
		}
	}

	public override void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		animator.speed = 1f;
	}
}
public class VRSecondDamageState : StateMachineBehaviour
{
	private VRMonsterLevel2 ply;

	public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		ply = animator.gameObject.GetComponent<VRMonsterLevel2>();
		ply.AnimatorClear();
		ply.StopFindPath();
		if (ply.curNPCState == NPCState.Walk)
		{
			animator.SetTrigger("Walk");
		}
		else if (ply.curNPCState == NPCState.Attack)
		{
			animator.SetTrigger("Atk");
		}
		if (ply.Hp <= 0f || ply.CurHP <= 0f)
		{
			animator.SetTrigger("Die");
		}
	}

	public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		if (ply.Hp <= 0f || ply.CurHP <= 0f)
		{
			animator.SetTrigger("Die");
		}
	}
}
public class VRSecondDeathState : StateMachineBehaviour
{
	private VRMonsterLevel2 ply;

	private VRActorAction deadFlashAction;

	public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		ply = animator.gameObject.GetComponent<VRMonsterLevel2>();
		if ((bool)ply)
		{
			if ((bool)ply.particleSystem)
			{
				ply.PlayParticle();
			}
			ply.curNPCState = NPCState.Dead;
			ply.AnimatorClear();
			ply.StopFindPath();
			deadFlashAction = ply.playEffectAction("deadFlash");
			if (ply.bNeedBulletTime)
			{
				Time.timeScale = 0.8f;
			}
			VRBubbleText component = ply.gameObject.GetComponent<VRBubbleText>();
			if ((bool)component)
			{
				component.SetVisible(visible: false);
			}
			ply.CurHP = 0f;
		}
	}

	public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		if ((bool)ply && ply.CurHP <= 0f)
		{
			AnimatorStateInfo currentAnimatorStateInfo = animator.GetCurrentAnimatorStateInfo(0);
			if (currentAnimatorStateInfo.IsName("die") && currentAnimatorStateInfo.normalizedTime >= 1f)
			{
				ply.gameObject.SetActive(value: false);
				VRGlobal.pushFreeEntity(ply.gameObject);
			}
		}
	}
}
public class VRSecondFlyAtkState : StateMachineBehaviour
{
	protected VRMonsterLevel2 ply;

	private VRNpc vrPlayer;

	private VRNpc killer;

	private Vector3 pos;

	public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		animator.SetTrigger("Die");
		ply = animator.gameObject.GetComponent<VRMonsterLevel2>();
		ply.AnimatorClear();
		animator.SetBool("fly", value: false);
		ply.PauseItweenPath();
		VRNpc tgt = ply.Target.GetComponent<VRNpc>();
		if ((bool)tgt)
		{
			float dmgHP = ply.ATKFinal(ref tgt, 1f);
			VRNpc component = ply.GetComponent<VRNpc>();
			Vector3 zero = Vector3.zero;
			tgt.OnDamage(dmgHP, ref component, sound: true, ref zero);
		}
		ply.CurHP = 0f;
	}

	public override void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
	}
}
public class VRSecondFlyState : StateMachineBehaviour
{
	private VRMonsterLevel2 ply;

	public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		ply = animator.gameObject.GetComponent<VRMonsterLevel2>();
		ply.SetItweenPath();
	}

	public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		if ((bool)ply && (ply.Hp <= 0f || ply.CurHP <= 0f))
		{
			animator.SetTrigger("Die");
		}
	}
}
public class VRSecondInitState : StateMachineBehaviour
{
	protected VRMonsterLevel2 ply;

	public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		ply = animator.gameObject.GetComponent<VRMonsterLevel2>();
		ply.AnimatorClear();
		ply.StopFindPath();
		animator.SetTrigger("Walk");
	}

	public override void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		animator.speed = 1f;
	}
}
public class VRSecondMoveState : StateMachineBehaviour
{
	private VRMonsterLevel2 ply;

	private float damage;

	public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		ply = animator.gameObject.GetComponent<VRMonsterLevel2>();
		ply.curNPCState = NPCState.Walk;
		ply.AnimatorClear();
		ply.SetFindPathDestination();
		if (ply.Hp <= 0f || ply.CurHP <= 0f)
		{
			animator.SetTrigger("Die");
		}
		damage = ply.CurHP;
	}

	public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		if (ply.Hp <= 0f || ply.CurHP <= 0f)
		{
			animator.SetTrigger("Die");
		}
		if (animator.speed != ply.MoveSpeed)
		{
			animator.speed = ply.MoveSpeed;
		}
		if ((bool)ply && ply.CheckReachTarget())
		{
			animator.SetTrigger("Atk");
		}
		if (ply.CurHP > 0f && damage != ply.CurHP)
		{
			damage = ply.CurHP;
			animator.SetTrigger("Damage");
		}
	}

	public override void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		animator.speed = 1f;
	}
}
public class FlowmapAnimator : MonoBehaviour
{
	public float flowSpeed;

	private Material currentMaterial;

	private float cycle;

	private float halfCycle;

	private float flowMapOffset0;

	private float flowMapOffset1;

	private bool hasTide;

	private void Reset()
	{
		flowSpeed = 0.25f;
	}

	private void Start()
	{
		currentMaterial = GetComponent<Renderer>().material;
		cycle = 6f;
		halfCycle = cycle * 0.5f;
		flowMapOffset0 = 0f;
		flowMapOffset1 = halfCycle;
		currentMaterial.SetFloat("halfCycle", halfCycle);
	}

	private void Update()
	{
		flowMapOffset0 += flowSpeed * Time.deltaTime;
		flowMapOffset1 += flowSpeed * Time.deltaTime;
		while (flowMapOffset0 >= cycle)
		{
			flowMapOffset0 -= cycle;
		}
		while (flowMapOffset1 >= cycle)
		{
			flowMapOffset1 -= cycle;
		}
		currentMaterial.SetFloat("flowMapOffset0", flowMapOffset0);
		currentMaterial.SetFloat("flowMapOffset1", flowMapOffset1);
	}
}
public enum WaterMovementType
{
	directional,
	island,
	flowmap,
	still
}
public class WaterPlusScript : MonoBehaviour
{
	public WaterMovementType movementType;

	public Vector2 velocity;

	public float speed;

	public Transform target;

	public bool animatedNormalmaps = true;

	private Texture2D[] normalmapAnimation;

	private Texture2D[] dudvfoamAnimation;

	private float animationValue;

	private Vector3 waterCenter;

	private Material waterMaterial;

	private Vector3 projectedLightDir;

	private Vector2 anisoDirAnimationOffset;

	private int causticsAnimationFrame;

	private float causticsAnimationTime;

	private int normalmapAnimationFrame;

	private float normalmapAnimationTime;

	private void Reset()
	{
		speed = 3f;
		velocity = new Vector2(0.7f, 0f);
	}

	private Light FindTheBrightestDirectionalLight()
	{
		Light light = null;
		Light[] obj = UnityEngine.Object.FindObjectsOfType(typeof(Light)) as Light[];
		List<Light> list = new List<Light>();
		Light[] array = obj;
		foreach (Light light2 in array)
		{
			if (light2.type == LightType.Directional)
			{
				list.Add(light2);
			}
		}
		if (list.Count <= 0)
		{
			return null;
		}
		light = list[0];
		foreach (Light item in list)
		{
			if (item.intensity > light.intensity)
			{
				light = item;
			}
		}
		return light;
	}

	private void Start()
	{
		waterCenter = GetComponent<Renderer>().bounds.center;
		if (movementType == WaterMovementType.directional)
		{
			speed = velocity.magnitude;
		}
		float num = GetComponent<Renderer>().bounds.size.x / base.gameObject.GetComponent<Renderer>().material.GetTextureScale("_MainTex").x;
		speed /= num;
		waterMaterial = GetComponent<Renderer>().material;
		Shader.DisableKeyword("WATER_EDGEBLEND_OFF");
		Shader.EnableKeyword("WATER_EDGEBLEND_ON");
		if (movementType == WaterMovementType.flowmap)
		{
			Shader.DisableKeyword("FLOWMAP_ANIMATION_OFF");
			Shader.EnableKeyword("FLOWMAP_ANIMATION_ON");
			base.gameObject.AddComponent<FlowmapAnimator>().flowSpeed = speed;
		}
		else
		{
			Shader.DisableKeyword("FLOWMAP_ANIMATION_ON");
			Shader.EnableKeyword("FLOWMAP_ANIMATION_OFF");
		}
		Light light = FindTheBrightestDirectionalLight();
		projectedLightDir = light.transform.forward - base.transform.up * Vector3.Dot(base.transform.up, light.transform.forward);
		projectedLightDir.Normalize();
		anisoDirAnimationOffset = Vector2.zero;
		causticsAnimationFrame = 0;
		if (!animatedNormalmaps)
		{
			return;
		}
		normalmapAnimation = new Texture2D[60];
		dudvfoamAnimation = new Texture2D[60];
		for (int i = 0; i < 60; i++)
		{
			string text = "";
			if (i < 10)
			{
				text = "0";
			}
			text += i;
			normalmapAnimation[i] = Resources.Load("water_hm" + text, typeof(Texture2D)) as Texture2D;
			dudvfoamAnimation[i] = Resources.Load("dudv_foam" + text, typeof(Texture2D)) as Texture2D;
			if (null == normalmapAnimation[i])
			{
				UnityEngine.Debug.LogError("unable to find normalmap animation file 'water_normal_" + text + "'. Aborting.");
				animatedNormalmaps = false;
				break;
			}
			if (null == dudvfoamAnimation[i])
			{
				UnityEngine.Debug.LogError("unable to find dudv animation file 'dudv_foam" + text + "'. Aborting.");
				animatedNormalmaps = false;
				break;
			}
		}
		normalmapAnimationFrame = 0;
	}

	private void OnDestroy()
	{
		Shader.DisableKeyword("WATER_EDGEBLEND_ON");
		Shader.EnableKeyword("WATER_EDGEBLEND_OFF");
	}

	private void Update()
	{
		switch (movementType)
		{
		case WaterMovementType.island:
		{
			Vector3 vector = waterCenter - target.position;
			velocity.x = vector.x;
			velocity.y = vector.z;
			velocity = velocity.normalized * speed;
			break;
		}
		case WaterMovementType.still:
			velocity = Vector3.zero;
			break;
		}
		if ((movementType == WaterMovementType.directional) | (movementType == WaterMovementType.island))
		{
			Vector2 textureOffset = waterMaterial.GetTextureOffset("_MainTex");
			Vector2 value = textureOffset + velocity * Time.deltaTime;
			if ((velocity * Time.deltaTime).sqrMagnitude > 1f)
			{
				Vector2 vector2 = velocity * Time.deltaTime;
				Vector2 normalized = vector2.normalized;
				while (vector2.sqrMagnitude > 1f)
				{
					vector2 -= normalized;
				}
				value = textureOffset + vector2;
			}
			waterMaterial.SetTextureOffset("_MainTex", value);
			waterMaterial.SetTextureOffset("_Normalmap", value);
		}
		anisoDirAnimationOffset += new Vector2(projectedLightDir.x, projectedLightDir.z) * Time.deltaTime * 0.01f;
		Vector4 value2 = new Vector4(anisoDirAnimationOffset.x, anisoDirAnimationOffset.y, 0f, 0f);
		waterMaterial.SetVector("anisoDirAnimationOffset", value2);
		int num = causticsAnimationFrame / 16;
		float y = (float)(causticsAnimationFrame % 16 / 4) * 0.25f;
		float x = (float)(causticsAnimationFrame % 16 % 4) * 0.25f;
		Vector4 value3 = new Vector4(x, y, 0.25f, 0.25f);
		Vector4 value4 = num switch
		{
			1 => new Vector4(0f, 1f, 0f, 0f), 
			2 => new Vector4(0f, 0f, 1f, 0f), 
			_ => new Vector4(1f, 0f, 0f, 0f), 
		};
		waterMaterial.SetVector("causticsOffsetAndScale", value3);
		waterMaterial.SetVector("causticsAnimationColorChannel", value4);
		causticsAnimationTime += Time.deltaTime;
		if (causticsAnimationTime >= 0.04f)
		{
			causticsAnimationFrame++;
			causticsAnimationTime = 0f;
			if (causticsAnimationFrame >= 48)
			{
				causticsAnimationFrame = 0;
			}
		}
		if (!animatedNormalmaps)
		{
			return;
		}
		normalmapAnimationTime += Time.deltaTime;
		if (normalmapAnimationTime >= 0.04f)
		{
			normalmapAnimationFrame++;
			normalmapAnimationTime = 0f;
			if (normalmapAnimationFrame >= 60)
			{
				normalmapAnimationFrame = 0;
			}
			waterMaterial.SetTexture("_NormalMap", normalmapAnimation[normalmapAnimationFrame]);
			waterMaterial.SetTexture("_DUDVFoamMap", dudvfoamAnimation[normalmapAnimationFrame]);
		}
	}
}
public class ItemPackage : MonoBehaviour
{
	public enum ItemPackageType
	{
		Unrestricted,
		OneHanded,
		TwoHanded
	}

	public new string name;

	public ItemPackageType packageType;

	public GameObject itemPrefab;

	public GameObject otherHandItemPrefab;

	public GameObject previewPrefab;

	public GameObject fadedPreviewPrefab;
}
public class LinearMapping : MonoBehaviour
{
	public float value;
}
public class SoundPlayOneshot : MonoBehaviour
{
	public AudioClip[] waveFiles;

	private AudioSource thisAudioSource;

	public float volMin;

	public float volMax;

	public float pitchMin;

	public float pitchMax;

	public bool playOnAwake;

	private void Awake()
	{
		thisAudioSource = GetComponent<AudioSource>();
		if (playOnAwake)
		{
			Play();
		}
	}

	public void Play()
	{
		if (thisAudioSource != null && thisAudioSource.isActiveAndEnabled && !Util.IsNullOrEmpty(waveFiles))
		{
			thisAudioSource.volume = UnityEngine.Random.Range(volMin, volMax);
			thisAudioSource.pitch = UnityEngine.Random.Range(pitchMin, pitchMax);
			thisAudioSource.PlayOneShot(waveFiles[UnityEngine.Random.Range(0, waveFiles.Length)]);
		}
	}

	public void Pause()
	{
		if (thisAudioSource != null)
		{
			thisAudioSource.Pause();
		}
	}

	public void UnPause()
	{
		if (thisAudioSource != null)
		{
			thisAudioSource.UnPause();
		}
	}
}
public static class Util
{
	public static float RemapNumber(float num, float low1, float high1, float low2, float high2)
	{
		return low2 + (num - low1) * (high2 - low2) / (high1 - low1);
	}

	public static float RemapNumberClamped(float num, float low1, float high1, float low2, float high2)
	{
		return Mathf.Clamp(RemapNumber(num, low1, high1, low2, high2), Mathf.Min(low2, high2), Mathf.Max(low2, high2));
	}

	public static void ResetTransform(Transform t, bool resetScale = true)
	{
		t.localPosition = Vector3.zero;
		t.localRotation = Quaternion.identity;
		if (resetScale)
		{
			t.localScale = new Vector3(1f, 1f, 1f);
		}
	}

	public static bool IsNullOrEmpty<T>(T[] array)
	{
		if (array == null)
		{
			return true;
		}
		if (array.Length == 0)
		{
			return true;
		}
		return false;
	}
}
public class Example_HandLinstener : MonoBehaviour
{
	public Toggle lcToggle;

	public Toggle lmToggle;

	public Toggle rcToggle;

	public Toggle rmToggle;

	public XRDeviceKeyStruct leftRayActiveHandler;

	private UnityXR_ButtonHandler rightRayActiveHandler;

	private bool rightRayIsShow = true;

	private void Start()
	{
		lcToggle.isOn = true;
		lmToggle.isOn = false;
		rcToggle.isOn = true;
		rmToggle.isOn = false;
	}

	private void OnEnable()
	{
		loadData();
		rightRayActiveHandler.OnButtonDown += rightRayActive;
	}

	private void OnDisable()
	{
		rightRayActiveHandler.OnButtonDown -= rightRayActive;
	}

	private void Update()
	{
		UnityXR_Controller.Instance.HandleSys.ModelActive(XRDeviceType.DT_Left, lcToggle.isOn, lmToggle.isOn);
		UnityXR_Controller.Instance.HandleSys.ModelActive(XRDeviceType.DT_Right, rcToggle.isOn, rmToggle.isOn);
	}

	private void loadData()
	{
		if (rightRayActiveHandler == null)
		{
			UnityXR_InputHandler inputHandler = UnityXR_Controller.Instance.InputSys.GetInputHandler(leftRayActiveHandler.deviceType, leftRayActiveHandler.keyType);
			if (inputHandler is UnityXR_ButtonHandler)
			{
				rightRayActiveHandler = inputHandler as UnityXR_ButtonHandler;
			}
		}
	}

	private void rightRayActive(XRController controller)
	{
		rightRayIsShow = !rightRayIsShow;
		UnityXR_Controller.Instance.HandleSys.RayActive(XRDeviceType.DT_Right, rightRayIsShow);
	}
}
public class Example_InputLinstener : MonoBehaviour
{
	public GameObject logo;

	public Text leftTex;

	public Text rightTex;

	public Text testTex;

	private UnityXR_ButtonHandler leftGrabButton;

	private UnityXR_AxisHandler leftTrigerAxis;

	private UnityXR_ButtonHandler leftPrimary2DAxisClick;

	private UnityXR_ButtonHandler rightTriggerButton;

	private UnityXR_AxisHandler2D rightPrimaryAxis2D;

	private void Awake()
	{
		leftGrabButton = UnityXR_Controller.Instance.InputSys.GetInputHandler(XRDeviceType.DT_Left, XRKeyType.Grip) as UnityXR_ButtonHandler;
		leftTrigerAxis = UnityXR_Controller.Instance.InputSys.GetInputHandler(XRDeviceType.DT_Left, XRKeyType.AxisTrigger) as UnityXR_AxisHandler;
		leftPrimary2DAxisClick = UnityXR_Controller.Instance.InputSys.GetInputHandler(XRDeviceType.DT_Left, XRKeyType.Primary2DAxisClick) as UnityXR_ButtonHandler;
		rightTriggerButton = UnityXR_Controller.Instance.InputSys.GetInputHandler(XRDeviceType.DT_Right, XRKeyType.Trigger) as UnityXR_ButtonHandler;
		rightPrimaryAxis2D = UnityXR_Controller.Instance.InputSys.GetInputHandler(XRDeviceType.DT_Right, XRKeyType.PrimaryAxis2D) as UnityXR_AxisHandler2D;
	}

	private void OnEnable()
	{
		leftGrabButton.OnButtonDown += leftGripButtonDown;
		leftTrigerAxis.OnValueChange += leftTrigerAxisOnValueChange;
		leftPrimary2DAxisClick.OnButtonDown += leftPrimary2DAxisClickDown;
		rightTriggerButton.OnButtonUp += rightTriggerButtonUp;
		rightPrimaryAxis2D.OnValueChange += rightPrimaryAxis2DValueChange;
	}

	private void OnDisable()
	{
		leftGrabButton.OnButtonDown -= leftGripButtonDown;
		leftTrigerAxis.OnValueChange -= leftTrigerAxisOnValueChange;
		leftPrimary2DAxisClick.OnButtonDown -= leftPrimary2DAxisClickDown;
		rightTriggerButton.OnButtonUp -= rightTriggerButtonUp;
		rightPrimaryAxis2D.OnValueChange -= rightPrimaryAxis2DValueChange;
	}

	private void Update()
	{
		string text = "左手Trigger按下的力度：" + leftTrigerAxis.PressValue + "\n";
		text = text + "右手Trigger是否按下：" + rightTriggerButton.IsPressed + "\n";
		text = string.Concat(text, "右手TouchPad按压的轴向：", rightPrimaryAxis2D.AxisValue, "\n");
		testTex.text = text;
		if (leftTrigerAxis.PressValue > 0.6f)
		{
			UnityXR_Controller.Instance.HandleSys.HapticPulse(XRDeviceType.DT_Left, 1f, 0.3f);
		}
		if (rightTriggerButton.IsPressed)
		{
			UnityXR_Controller.Instance.HandleSys.HapticPulse(XRDeviceType.DT_Right, 0.6f, 0.3f);
		}
		if (rightTriggerButton.IsUplift)
		{
			logo.SetActive(!logo.activeSelf);
		}
	}

	private void leftGripButtonDown(XRController controller)
	{
		if (leftTex.text == "leftGrabButton：按下了")
		{
			leftTex.text += "leftGrabButton：按下了\n";
		}
		else
		{
			leftTex.text = "leftGrabButton：按下了";
		}
	}

	private void leftTrigerAxisOnValueChange(XRController controller, float value)
	{
		leftTex.text = "leftTrigerAxis：改变了======" + value;
	}

	private void leftPrimary2DAxisClickDown(XRController controller)
	{
		if (leftTex.text == "leftPrimary2DAxisClick：按下了")
		{
			leftTex.text += "leftPrimary2DAxisClick：按下了\n";
		}
		else
		{
			leftTex.text = "leftPrimary2DAxisClick：按下了";
		}
	}

	private void rightTriggerButtonUp(XRController controller)
	{
		if (rightTex.text == "rightTriggerButton：抬起了")
		{
			rightTex.text += "rightTriggerButton：抬起了\n";
		}
		else
		{
			rightTex.text = "rightTriggerButton：抬起了";
		}
	}

	private void rightPrimaryAxis2DValueChange(XRController controller, Vector2 value)
	{
		rightTex.text = "rightPrimaryAxis2D：改变了======" + value.x + ":" + value.y;
	}
}
public class ArcheryTarget : MonoBehaviour
{
	public UnityEvent onTakeDamage;

	public bool onceOnly;

	public Transform targetCenter;

	public Transform baseTransform;

	public Transform fallenDownTransform;

	public float fallTime = 0.5f;

	private const float targetRadius = 0.25f;

	private bool targetEnabled = true;

	private void ApplyDamage()
	{
		OnDamageTaken();
	}

	private void FireExposure()
	{
		OnDamageTaken();
	}

	private void OnDamageTaken()
	{
		if (targetEnabled)
		{
			onTakeDamage.Invoke();
			StartCoroutine(FallDown());
			if (onceOnly)
			{
				targetEnabled = false;
			}
		}
	}

	private IEnumerator FallDown()
	{
		if ((bool)baseTransform)
		{
			Quaternion startingRot = baseTransform.rotation;
			float startTime = Time.time;
			float rotLerp = 0f;
			while (rotLerp < 1f)
			{
				rotLerp = Util.RemapNumberClamped(Time.time, startTime, startTime + fallTime, 0f, 1f);
				baseTransform.rotation = Quaternion.Lerp(startingRot, fallenDownTransform.rotation, rotLerp);
				yield return null;
			}
		}
		yield return null;
	}
}
public class Arrow : MonoBehaviour
{
	public ParticleSystem glintParticle;

	public Rigidbody arrowHeadRB;

	public Rigidbody shaftRB;

	public PhysicMaterial targetPhysMaterial;

	private Vector3 prevPosition;

	private Quaternion prevRotation;

	private Vector3 prevVelocity;

	private Vector3 prevHeadPosition;

	public SoundPlayOneshot fireReleaseSound;

	public SoundPlayOneshot airReleaseSound;

	public SoundPlayOneshot hitTargetSound;

	private bool inFlight;

	private bool released;

	private bool hasSpreadFire;

	private int travelledFrames;

	private GameObject scaleParentObject;

	private void Start()
	{
	}

	private void FixedUpdate()
	{
		if (released && inFlight)
		{
			prevPosition = base.transform.position;
			prevRotation = base.transform.rotation;
			prevVelocity = GetComponent<Rigidbody>().velocity;
			prevHeadPosition = arrowHeadRB.transform.position;
			travelledFrames++;
		}
	}

	public void ArrowReleased(float inputVelocity)
	{
		inFlight = true;
		released = true;
		airReleaseSound.Play();
		if (glintParticle != null)
		{
			glintParticle.Play();
		}
		if (base.gameObject.GetComponentInChildren<FireSource>().isBurning)
		{
			fireReleaseSound.Play();
		}
		RaycastHit[] array = Physics.SphereCastAll(base.transform.position, 0.01f, base.transform.forward, 0.8f, -5, QueryTriggerInteraction.Ignore);
		for (int i = 0; i < array.Length; i++)
		{
			RaycastHit raycastHit = array[i];
			if (raycastHit.collider.gameObject != base.gameObject && raycastHit.collider.gameObject != arrowHeadRB.gameObject)
			{
				UnityEngine.Object.Destroy(base.gameObject);
				return;
			}
		}
		travelledFrames = 0;
		prevPosition = base.transform.position;
		prevRotation = base.transform.rotation;
		prevHeadPosition = arrowHeadRB.transform.position;
		prevVelocity = GetComponent<Rigidbody>().velocity;
		SetCollisionMode(CollisionDetectionMode.ContinuousDynamic);
		UnityEngine.Object.Destroy(base.gameObject, 30f);
	}

	protected void SetCollisionMode(CollisionDetectionMode newMode, bool force = false)
	{
		Rigidbody[] componentsInChildren = GetComponentsInChildren<Rigidbody>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			if (!componentsInChildren[i].isKinematic || force)
			{
				componentsInChildren[i].collisionDetectionMode = newMode;
			}
		}
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (!inFlight)
		{
			return;
		}
		float sqrMagnitude = GetComponent<Rigidbody>().velocity.sqrMagnitude;
		bool flag = targetPhysMaterial != null && collision.collider.sharedMaterial == targetPhysMaterial && sqrMagnitude > 0.2f;
		if (travelledFrames < 2 && !flag)
		{
			base.transform.position = prevPosition - prevVelocity * Time.deltaTime;
			base.transform.rotation = prevRotation;
			Vector3 vector = Vector3.Reflect(arrowHeadRB.velocity, collision.contacts[0].normal);
			arrowHeadRB.velocity = vector * 0.25f;
			shaftRB.velocity = vector * 0.25f;
			travelledFrames = 0;
			return;
		}
		if (glintParticle != null)
		{
			glintParticle.Stop(withChildren: true);
		}
		FireSource componentInChildren = base.gameObject.GetComponentInChildren<FireSource>();
		FireSource componentInParent = collision.collider.GetComponentInParent<FireSource>();
		if (componentInChildren != null && componentInChildren.isBurning && componentInParent != null)
		{
			if (!hasSpreadFire)
			{
				collision.collider.gameObject.SendMessageUpwards("FireExposure", base.gameObject, SendMessageOptions.DontRequireReceiver);
				hasSpreadFire = true;
			}
		}
		else if (sqrMagnitude > 0.1f)
		{
			collision.collider.gameObject.SendMessageUpwards("ApplyDamage", SendMessageOptions.DontRequireReceiver);
			base.gameObject.SendMessage("HasAppliedDamage", SendMessageOptions.DontRequireReceiver);
		}
		if (flag)
		{
			StickInTarget(collision, travelledFrames < 2);
		}
	}

	private void StickInTarget(Collision collision, bool bSkipRayCast)
	{
		Vector3 direction = prevRotation * Vector3.forward;
		if (!bSkipRayCast)
		{
			RaycastHit[] array = Physics.RaycastAll(prevHeadPosition - prevVelocity * Time.deltaTime, direction, prevVelocity.magnitude * Time.deltaTime * 2f);
			bool flag = false;
			foreach (RaycastHit raycastHit in array)
			{
				if (raycastHit.collider == collision.collider)
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				return;
			}
		}
		UnityEngine.Object.Destroy(glintParticle);
		inFlight = false;
		SetCollisionMode(CollisionDetectionMode.Discrete, force: true);
		shaftRB.velocity = Vector3.zero;
		shaftRB.angularVelocity = Vector3.zero;
		shaftRB.isKinematic = true;
		shaftRB.useGravity = false;
		shaftRB.transform.GetComponent<BoxCollider>().enabled = false;
		arrowHeadRB.velocity = Vector3.zero;
		arrowHeadRB.angularVelocity = Vector3.zero;
		arrowHeadRB.isKinematic = true;
		arrowHeadRB.useGravity = false;
		arrowHeadRB.transform.GetComponent<BoxCollider>().enabled = false;
		hitTargetSound.Play();
		scaleParentObject = new GameObject("Arrow Scale Parent");
		Transform parent = collision.collider.transform;
		if (!collision.collider.gameObject.GetComponent<ExplosionWobble>() && (bool)parent.parent)
		{
			parent = parent.parent;
		}
		scaleParentObject.transform.parent = parent;
		base.transform.parent = scaleParentObject.transform;
		base.transform.rotation = prevRotation;
		base.transform.position = prevPosition;
		base.transform.position = collision.contacts[0].point - base.transform.forward * (0.75f - (Util.RemapNumberClamped(prevVelocity.magnitude, 0f, 10f, 0f, 0.1f) + UnityEngine.Random.Range(0f, 0.05f)));
	}

	private void OnDestroy()
	{
		if (scaleParentObject != null)
		{
			UnityEngine.Object.Destroy(scaleParentObject);
		}
	}
}
public class ArrowHand : MonoBehaviour
{
	private UnityXR_HandPresence hand;

	private UnityXR_HandPresence otherHand;

	private Longbow bow;

	private GameObject currentArrow;

	public GameObject arrowPrefab;

	public Transform arrowNockTransform;

	public float nockDistance = 0.1f;

	public float lerpCompleteDistance = 0.08f;

	public float rotationLerpThreshold = 0.15f;

	public float positionLerpThreshold = 0.15f;

	private bool allowArrowSpawn = true;

	private bool nocked;

	private bool inNockRange;

	private bool arrowLerpComplete;

	public SoundPlayOneshot arrowSpawnSound;

	public int maxArrowCount = 10;

	private List<GameObject> arrowList;

	private void Awake()
	{
		arrowList = new List<GameObject>();
	}

	private void OnAttachedToHand(UnityXR_HandPresence attachedHand)
	{
		hand = UnityXR_Controller.Instance.HandleSys.leftHand;
		otherHand = UnityXR_Controller.Instance.HandleSys.rightHand;
		FindBow();
	}

	private GameObject InstantiateArrow()
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(arrowPrefab, arrowNockTransform.position, arrowNockTransform.rotation);
		gameObject.name = "Bow Arrow";
		gameObject.transform.parent = arrowNockTransform;
		Util.ResetTransform(gameObject.transform);
		arrowList.Add(gameObject);
		while (arrowList.Count > maxArrowCount)
		{
			GameObject gameObject2 = arrowList[0];
			arrowList.RemoveAt(0);
			if ((bool)gameObject2)
			{
				UnityEngine.Object.Destroy(gameObject2);
			}
		}
		return gameObject;
	}

	private void HandAttachedUpdate(UnityXR_HandPresence hand)
	{
		if (bow == null)
		{
			FindBow();
		}
		if (bow == null)
		{
			return;
		}
		if (allowArrowSpawn && currentArrow == null)
		{
			currentArrow = InstantiateArrow();
			arrowSpawnSound.Play();
		}
		float num = Vector3.Distance(base.transform.parent.position, bow.nockTransform.position);
		if (!nocked)
		{
			if (num < rotationLerpThreshold)
			{
				float t = Util.RemapNumber(num, rotationLerpThreshold, lerpCompleteDistance, 0f, 1f);
				arrowNockTransform.rotation = Quaternion.Lerp(arrowNockTransform.parent.rotation, bow.nockRestTransform.rotation, t);
			}
			else
			{
				arrowNockTransform.localRotation = Quaternion.identity;
			}
			if (num < positionLerpThreshold)
			{
				float value = Util.RemapNumber(num, positionLerpThreshold, lerpCompleteDistance, 0f, 1f);
				value = Mathf.Clamp(value, 0f, 1f);
				arrowNockTransform.position = Vector3.Lerp(arrowNockTransform.parent.position, bow.nockRestTransform.position, value);
			}
			else
			{
				arrowNockTransform.position = arrowNockTransform.parent.position;
			}
			if (num < lerpCompleteDistance)
			{
				if (!arrowLerpComplete)
				{
					arrowLerpComplete = true;
					hand.HapticPulse(0.5f, 0.3f);
				}
			}
			else if (arrowLerpComplete)
			{
				arrowLerpComplete = false;
			}
			if (num < nockDistance)
			{
				if (!inNockRange)
				{
					inNockRange = true;
					bow.ArrowInPosition();
				}
			}
			else if (inNockRange)
			{
				inNockRange = false;
			}
			if (num < nockDistance && !nocked)
			{
				if (currentArrow == null)
				{
					currentArrow = InstantiateArrow();
				}
				nocked = true;
				bow.StartNock(this);
				currentArrow.transform.parent = bow.nockTransform;
				Util.ResetTransform(currentArrow.transform);
				Util.ResetTransform(arrowNockTransform);
			}
		}
		if (nocked)
		{
			if (bow.pulled)
			{
				FireArrow();
			}
			else
			{
				arrowNockTransform.rotation = currentArrow.transform.rotation;
				currentArrow.transform.parent = arrowNockTransform;
				Util.ResetTransform(currentArrow.transform);
				nocked = false;
				bow.ReleaseNock();
			}
			bow.StartRotationLerp();
		}
	}

	private void OnDetachedFromHand(UnityXR_HandPresence hand)
	{
		UnityEngine.Object.Destroy(base.gameObject);
	}

	private void FireArrow()
	{
		currentArrow.transform.parent = null;
		Arrow component = currentArrow.GetComponent<Arrow>();
		component.shaftRB.isKinematic = false;
		component.shaftRB.useGravity = true;
		component.shaftRB.transform.GetComponent<BoxCollider>().enabled = true;
		component.arrowHeadRB.isKinematic = false;
		component.arrowHeadRB.useGravity = true;
		component.arrowHeadRB.transform.GetComponent<BoxCollider>().enabled = true;
		component.arrowHeadRB.AddForce(currentArrow.transform.forward * bow.GetArrowVelocity(), ForceMode.VelocityChange);
		component.arrowHeadRB.AddTorque(currentArrow.transform.forward * 10f);
		nocked = false;
		currentArrow.GetComponent<Arrow>().ArrowReleased(bow.GetArrowVelocity());
		bow.ArrowReleased();
		allowArrowSpawn = false;
		Invoke("EnableArrowSpawn", 0.5f);
		StartCoroutine(ArrowReleaseHaptics());
		currentArrow = null;
	}

	private void EnableArrowSpawn()
	{
		allowArrowSpawn = true;
	}

	private IEnumerator ArrowReleaseHaptics()
	{
		yield return new WaitForSeconds(0.05f);
		otherHand.HapticPulse(1f, 0.3f);
		yield return new WaitForSeconds(0.05f);
		otherHand.HapticPulse(0.8f, 0.3f);
		yield return new WaitForSeconds(0.05f);
		otherHand.HapticPulse(0.5f, 0.3f);
		yield return new WaitForSeconds(0.05f);
		otherHand.HapticPulse(0.3f, 0.3f);
	}

	private void OnHandFocusLost(UnityXR_HandPresence hand)
	{
		base.gameObject.SetActive(value: false);
	}

	private void OnHandFocusAcquired(UnityXR_HandPresence hand)
	{
		base.gameObject.SetActive(value: true);
	}

	private void FindBow()
	{
		bow = otherHand.GetComponentInChildren<Longbow>();
	}
}
public class ArrowheadRotation : MonoBehaviour
{
	private void Start()
	{
		float x = UnityEngine.Random.Range(0f, 180f);
		base.transform.localEulerAngles = new Vector3(x, -90f, 90f);
	}
}
public class ExplosionWobble : MonoBehaviour
{
	public void ExplosionEvent(Vector3 explosionPos)
	{
		Rigidbody component = GetComponent<Rigidbody>();
		if ((bool)component)
		{
			component.AddExplosionForce(2000f, explosionPos, 10f);
		}
	}
}
public class FireSource : MonoBehaviour
{
	public GameObject fireParticlePrefab;

	public bool startActive;

	private GameObject fireObject;

	public ParticleSystem customParticles;

	public bool isBurning;

	public float burnTime;

	public float ignitionDelay;

	private float ignitionTime;

	private UnityXR_HandPresence hand;

	public AudioSource ignitionSound;

	public bool canSpreadFromThisSource = true;

	private void Start()
	{
		if (startActive)
		{
			StartBurning();
		}
	}

	private void Update()
	{
		if (burnTime != 0f && Time.time > ignitionTime + burnTime && isBurning)
		{
			isBurning = false;
			if (customParticles != null)
			{
				customParticles.Stop();
			}
			else
			{
				UnityEngine.Object.Destroy(fireObject);
			}
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (isBurning && canSpreadFromThisSource)
		{
			other.SendMessageUpwards("FireExposure", SendMessageOptions.DontRequireReceiver);
		}
	}

	private void FireExposure()
	{
		if (fireObject == null)
		{
			Invoke("StartBurning", ignitionDelay);
		}
		if ((bool)(hand = GetComponentInParent<UnityXR_HandPresence>()))
		{
			hand.HapticPulse(1f, 0.3f);
		}
	}

	private void StartBurning()
	{
		isBurning = true;
		ignitionTime = Time.time;
		if (ignitionSound != null)
		{
			ignitionSound.Play();
		}
		if (customParticles != null)
		{
			customParticles.Play();
		}
		else if (fireParticlePrefab != null)
		{
			fireObject = UnityEngine.Object.Instantiate(fireParticlePrefab, base.transform.position, base.transform.rotation);
			fireObject.transform.parent = base.transform;
		}
	}
}
public class Longbow : MonoBehaviour
{
	public enum Handedness
	{
		Left,
		Right
	}

	public Handedness currentHandGuess;

	private float timeOfPossibleHandSwitch;

	private float timeBeforeConfirmingHandSwitch = 1.5f;

	private bool possibleHandSwitch;

	public Transform pivotTransform;

	public Transform handleTransform;

	private UnityXR_HandPresence hand;

	private ArrowHand arrowHand;

	public Transform nockTransform;

	public Transform nockRestTransform;

	public bool autoSpawnArrowHand = true;

	public ItemPackage arrowHandItemPackage;

	public GameObject arrowHandPrefab;

	public bool nocked;

	public bool pulled;

	private const float minPull = 0.05f;

	private const float maxPull = 0.5f;

	private float nockDistanceTravelled;

	private float hapticDistanceThreshold = 0.01f;

	private float lastTickDistance;

	private const float bowPullPulseStrengthLow = 0.1f;

	private const float bowPullPulseStrengthHigh = 0.5f;

	private Vector3 bowLeftVector;

	public float arrowMinVelocity = 3f;

	public float arrowMaxVelocity = 30f;

	private float arrowVelocity = 30f;

	private float minStrainTickTime = 0.1f;

	private float maxStrainTickTime = 0.5f;

	private float nextStrainTick;

	private bool lerpBackToZeroRotation;

	private float lerpStartTime;

	private float lerpDuration = 0.15f;

	private Quaternion lerpStartRotation;

	private float nockLerpStartTime;

	private Quaternion nockLerpStartRotation;

	public float drawOffset = 0.06f;

	public LinearMapping bowDrawLinearMapping;

	private Vector3 lateUpdatePos;

	private Quaternion lateUpdateRot;

	public SoundBowClick drawSound;

	private float drawTension;

	public SoundPlayOneshot arrowSlideSound;

	public SoundPlayOneshot releaseSound;

	public SoundPlayOneshot nockSound;

	private void OnAttachedToHand(UnityXR_HandPresence attachedHand)
	{
		hand = attachedHand;
	}

	private void HandAttachedUpdate(UnityXR_HandPresence hand)
	{
		EvaluateHandedness();
		if (nocked)
		{
			Vector3 lhs = arrowHand.arrowNockTransform.parent.position - nockRestTransform.position;
			float num = Util.RemapNumberClamped(Time.time, nockLerpStartTime, nockLerpStartTime + lerpDuration, 0f, 1f);
			float num2 = Util.RemapNumberClamped(lhs.magnitude, 0.05f, 0.5f, 0f, 1f);
			Vector3 normalized = (UnityXR_Controller.Instance.HandleSys.GetTransform(XRDeviceType.DT_Left).position + Vector3.down * 0.05f - arrowHand.arrowNockTransform.parent.position).normalized;
			Vector3 normalized2 = (arrowHand.arrowNockTransform.parent.position + normalized * drawOffset * num2 - pivotTransform.position).normalized;
			Vector3 normalized3 = (handleTransform.position - pivotTransform.position).normalized;
			bowLeftVector = -Vector3.Cross(normalized3, normalized2);
			pivotTransform.rotation = Quaternion.Lerp(nockLerpStartRotation, Quaternion.LookRotation(normalized2, bowLeftVector), num);
			if (Vector3.Dot(lhs, -nockTransform.forward) > 0f)
			{
				float num3 = lhs.magnitude * num;
				nockTransform.localPosition = new Vector3(0f, 0f, Mathf.Clamp(0f - num3, -0.5f, 0f));
				nockDistanceTravelled = 0f - nockTransform.localPosition.z;
				arrowVelocity = Util.RemapNumber(nockDistanceTravelled, 0.05f, 0.5f, arrowMinVelocity, arrowMaxVelocity);
				drawTension = Util.RemapNumberClamped(nockDistanceTravelled, 0f, 0.5f, 0f, 1f);
				bowDrawLinearMapping.value = drawTension;
				if (nockDistanceTravelled > 0.05f)
				{
					pulled = true;
				}
				else
				{
					pulled = false;
				}
				if (nockDistanceTravelled > lastTickDistance + hapticDistanceThreshold || nockDistanceTravelled < lastTickDistance - hapticDistanceThreshold)
				{
					ushort num4 = (ushort)Util.RemapNumber(nockDistanceTravelled, 0f, 0.5f, 0.1f, 0.5f);
					hand.HapticPulse((int)num4, 0.3f);
					UnityXR_Controller.Instance.HandleSys.HapticPulse(XRDeviceType.DT_Right, (int)num4, 0.3f);
					drawSound.PlayBowTensionClicks(drawTension);
					lastTickDistance = nockDistanceTravelled;
				}
				if (nockDistanceTravelled >= 0.5f && Time.time > nextStrainTick)
				{
					hand.HapticPulse(0.4f);
					UnityXR_Controller.Instance.HandleSys.HapticPulse(XRDeviceType.DT_Right, 0.4f, 0.3f);
					drawSound.PlayBowTensionClicks(drawTension);
					nextStrainTick = Time.time + UnityEngine.Random.Range(minStrainTickTime, maxStrainTickTime);
				}
			}
			else
			{
				nockTransform.localPosition = new Vector3(0f, 0f, 0f);
				bowDrawLinearMapping.value = 0f;
			}
		}
		else if (lerpBackToZeroRotation)
		{
			float num5 = Util.RemapNumber(Time.time, lerpStartTime, lerpStartTime + lerpDuration, 0f, 1f);
			pivotTransform.localRotation = Quaternion.Lerp(lerpStartRotation, Quaternion.identity, num5);
			if (num5 >= 1f)
			{
				lerpBackToZeroRotation = false;
			}
		}
	}

	public void ArrowReleased()
	{
		nocked = false;
		if (releaseSound != null)
		{
			releaseSound.Play();
		}
		StartCoroutine(ResetDrawAnim());
	}

	private IEnumerator ResetDrawAnim()
	{
		float startTime = Time.time;
		float startLerp = drawTension;
		while (Time.time < startTime + 0.02f)
		{
			float value = Util.RemapNumberClamped(Time.time, startTime, startTime + 0.02f, startLerp, 0f);
			bowDrawLinearMapping.value = value;
			yield return null;
		}
		bowDrawLinearMapping.value = 0f;
	}

	public float GetArrowVelocity()
	{
		return arrowVelocity;
	}

	public void StartRotationLerp()
	{
		lerpStartTime = Time.time;
		lerpBackToZeroRotation = true;
		lerpStartRotation = pivotTransform.localRotation;
		Util.ResetTransform(nockTransform);
	}

	public void StartNock(ArrowHand currentArrowHand)
	{
		arrowHand = currentArrowHand;
		nocked = true;
		nockLerpStartTime = Time.time;
		nockLerpStartRotation = pivotTransform.rotation;
		arrowSlideSound.Play();
		DoHandednessCheck();
	}

	private void EvaluateHandedness()
	{
		if (0 == 0)
		{
			if (possibleHandSwitch && currentHandGuess == Handedness.Left)
			{
				possibleHandSwitch = false;
			}
			if (!possibleHandSwitch && currentHandGuess == Handedness.Right)
			{
				possibleHandSwitch = true;
				timeOfPossibleHandSwitch = Time.time;
			}
			if (possibleHandSwitch && Time.time > timeOfPossibleHandSwitch + timeBeforeConfirmingHandSwitch)
			{
				currentHandGuess = Handedness.Left;
				possibleHandSwitch = false;
			}
		}
		else
		{
			if (possibleHandSwitch && currentHandGuess == Handedness.Right)
			{
				possibleHandSwitch = false;
			}
			if (!possibleHandSwitch && currentHandGuess == Handedness.Left)
			{
				possibleHandSwitch = true;
				timeOfPossibleHandSwitch = Time.time;
			}
			if (possibleHandSwitch && Time.time > timeOfPossibleHandSwitch + timeBeforeConfirmingHandSwitch)
			{
				currentHandGuess = Handedness.Right;
				possibleHandSwitch = false;
			}
		}
	}

	private void DoHandednessCheck()
	{
		if (currentHandGuess == Handedness.Left)
		{
			pivotTransform.localScale = new Vector3(1f, 1f, 1f);
		}
		else
		{
			pivotTransform.localScale = new Vector3(1f, -1f, 1f);
		}
	}

	public void ArrowInPosition()
	{
		DoHandednessCheck();
		if (nockSound != null)
		{
			nockSound.Play();
		}
	}

	public void ReleaseNock()
	{
		nocked = false;
		StartCoroutine(ResetDrawAnim());
	}

	private void ShutDown()
	{
	}

	private void OnHandFocusLost(UnityXR_HandPresence hand)
	{
		base.gameObject.SetActive(value: false);
	}

	private void OnHandFocusAcquired(UnityXR_HandPresence hand)
	{
		base.gameObject.SetActive(value: true);
		OnAttachedToHand(hand);
	}

	private void OnDetachedFromHand(UnityXR_HandPresence hand)
	{
		UnityEngine.Object.Destroy(base.gameObject);
	}

	private void OnDestroy()
	{
		ShutDown();
	}
}
public class SoundBowClick : MonoBehaviour
{
	public AudioClip bowClick;

	public AnimationCurve pitchTensionCurve;

	public float minPitch;

	public float maxPitch;

	private AudioSource thisAudioSource;

	private void Awake()
	{
		thisAudioSource = GetComponent<AudioSource>();
	}

	public void PlayBowTensionClicks(float normalizedTension)
	{
		float num = pitchTensionCurve.Evaluate(normalizedTension);
		thisAudioSource.pitch = (maxPitch - minPitch) * num + minPitch;
		thisAudioSource.PlayOneShot(bowClick);
	}
}
public class UnityXR_HandPresence : MonoBehaviour
{
	[SerializeField]
	private XRController controller;

	[SerializeField]
	private XRRayInteractor xrRay;

	[Header("手柄模型")]
	[SerializeField]
	private Transform prefabParent;

	public GameObject picoNoe2HandModel;

	public GameObject picoNeo3HandModel;

	private GameObject spawnedController;

	private void Awake()
	{
		if (SystemInfo.deviceModel == "Pico Pico Neo 2")
		{
			if ((bool)picoNoe2HandModel)
			{
				spawnedController = UnityEngine.Object.Instantiate(picoNoe2HandModel, prefabParent);
			}
			else
			{
				UnityEngine.Debug.LogError(base.gameObject.name + "找不到 pico neo2 手柄预设体");
			}
		}
		else if (SystemInfo.deviceModel == "Pico Pico Neo 3")
		{
			if ((bool)picoNeo3HandModel)
			{
				spawnedController = UnityEngine.Object.Instantiate(picoNeo3HandModel, prefabParent);
			}
			else
			{
				UnityEngine.Debug.LogError(base.gameObject.name + "找不到 pico neo3 手柄预设体");
			}
		}
		else if ((bool)picoNeo3HandModel)
		{
			spawnedController = UnityEngine.Object.Instantiate(picoNeo3HandModel, prefabParent);
		}
		else
		{
			UnityEngine.Debug.LogError(base.gameObject.name + "找不到手柄预设体");
		}
		SetControllerModel(showController: true, showModel: false);
	}

	public void SetControllerModel(bool showController, bool showModel)
	{
		if ((bool)spawnedController && spawnedController.activeSelf != showController)
		{
			spawnedController.SetActive(showController);
		}
	}

	public void SetRayShow(bool isShow)
	{
		if (xrRay.enabled != isShow)
		{
			xrRay.enabled = isShow;
		}
	}

	public bool HapticPulse(float amplitude, float duration = 1f)
	{
		amplitude = Mathf.Clamp(amplitude, 0f, 1f);
		return controller.SendHapticImpulse(amplitude, duration);
	}

	private void updateHandAnimtion()
	{
	}
}
[CreateAssetMenu(fileName = "UnityXR_AxisHandler")]
public class UnityXR_AxisHandler : UnityXR_InputHandler, ISerializationCallbackReceiver
{
	public enum Axis
	{
		None,
		Trigger,
		Grip
	}

	public delegate void ValueChange(XRController controller, float value);

	[SerializeField]
	private Axis axis;

	private InputFeatureUsage<float> inputFeature;

	private float previousValue;

	public float PressValue => previousValue;

	public event ValueChange OnValueChange;

	public void OnAfterDeserialize()
	{
		inputFeature = new InputFeatureUsage<float>(axis.ToString());
	}

	public void OnBeforeSerialize()
	{
	}

	public override void HandleState(XRController controller)
	{
		float value = GetValue(controller);
		if (value != previousValue)
		{
			previousValue = value;
			this.OnValueChange?.Invoke(controller, value);
		}
	}

	public float GetValue(XRController controller)
	{
		if (controller.inputDevice.TryGetFeatureValue(inputFeature, out var value))
		{
			return value;
		}
		return 0f;
	}
}
[CreateAssetMenu(fileName = "UnityXR_AxisHandler2D")]
public class UnityXR_AxisHandler2D : UnityXR_InputHandler, ISerializationCallbackReceiver
{
	public enum Axis2D
	{
		None,
		Primary2DAxis,
		Secondary2DAxis
	}

	public delegate void ValueChanage(XRController controller, Vector2 value);

	[SerializeField]
	private Axis2D axis;

	private InputFeatureUsage<Vector2> inputFeature;

	private Vector2 previousValue = Vector2.zero;

	public Vector2 AxisValue => previousValue;

	public event ValueChanage OnValueChange;

	public void OnAfterDeserialize()
	{
		inputFeature = new InputFeatureUsage<Vector2>(axis.ToString());
	}

	public void OnBeforeSerialize()
	{
	}

	public override void HandleState(XRController controller)
	{
		Vector2 value = GetValue(controller);
		if (value != previousValue)
		{
			previousValue = value;
			this.OnValueChange?.Invoke(controller, value);
		}
	}

	private Vector2 GetValue(XRController controller)
	{
		if (controller.inputDevice.TryGetFeatureValue(inputFeature, out var value))
		{
			return value;
		}
		return Vector2.zero;
	}
}
[CreateAssetMenu(fileName = "UnityXR_ButtonHandler")]
public class UnityXR_ButtonHandler : UnityXR_InputHandler
{
	public delegate void StateChange(XRController controller);

	[SerializeField]
	private InputHelpers.Button button;

	private bool previousPress;

	private bool isUplift;

	public bool IsPressed => previousPress;

	public bool IsUplift => isUplift;

	public event StateChange OnButtonDown;

	public event StateChange OnButtonUp;

	public override void HandleState(XRController controller)
	{
		if (!controller.inputDevice.IsPressed(button, out var isPressed, controller.axisToPressThreshold))
		{
			return;
		}
		if (previousPress != isPressed)
		{
			previousPress = isPressed;
			isUplift = !isPressed;
			if (isPressed)
			{
				this.OnButtonDown?.Invoke(controller);
			}
			else
			{
				this.OnButtonUp?.Invoke(controller);
			}
		}
		else if (isUplift)
		{
			isUplift = false;
		}
	}
}
public class UnityXR_InputHandler : ScriptableObject
{
	public virtual void HandleState(XRController controller)
	{
	}
}
[CreateAssetMenu(fileName = "UnityXR_KeyCodeHelper")]
public class UnityXR_KeyCodeHelper : ScriptableObject
{
	[Serializable]
	public struct KeyCodeStruct
	{
		public XRKeyType keyType;

		public UnityXR_InputHandler inputHandler;
	}

	[SerializeField]
	private List<KeyCodeStruct> left_XRKeys = new List<KeyCodeStruct>();

	[SerializeField]
	private List<KeyCodeStruct> right_XRKeys = new List<KeyCodeStruct>();

	public UnityXR_InputHandler GetInputHandler(XRDeviceType devicetype, XRKeyType keyType)
	{
		if (devicetype == XRDeviceType.DT_Left)
		{
			for (int i = 0; i < left_XRKeys.Count; i++)
			{
				if (left_XRKeys[i].keyType == keyType)
				{
					return left_XRKeys[i].inputHandler;
				}
			}
		}
		if (devicetype == XRDeviceType.DT_Right)
		{
			for (int j = 0; j < right_XRKeys.Count; j++)
			{
				if (right_XRKeys[j].keyType == keyType)
				{
					return right_XRKeys[j].inputHandler;
				}
			}
		}
		return null;
	}

	public void LeftHandleKeysHandle(XRController left)
	{
		for (int i = 0; i < left_XRKeys.Count; i++)
		{
			left_XRKeys[i].inputHandler.HandleState(left);
		}
	}

	public void RightHandleKeysHandle(XRController right)
	{
		for (int i = 0; i < right_XRKeys.Count; i++)
		{
			right_XRKeys[i].inputHandler.HandleState(right);
		}
	}
}
public class UnityXR_Grab : MonoBehaviour
{
}
public class UnityXR_RayInteractableCollider : XRBaseInteractable
{
	[Header("UnityXR Extension")]
	public XRDeviceKeyStruct xrKeyStruct;

	public UnityEvent buttonDownEvent;

	public UnityEvent buttonUpEvent;

	private UnityXR_ButtonHandler interactionHandler;

	protected override void Awake()
	{
		base.Awake();
		if (UnityXR_Controller.Instance.InputSys.GetInputHandler(xrKeyStruct.deviceType, xrKeyStruct.keyType) is UnityXR_ButtonHandler)
		{
			interactionHandler = UnityXR_Controller.Instance.InputSys.GetInputHandler(xrKeyStruct.deviceType, xrKeyStruct.keyType) as UnityXR_ButtonHandler;
		}
	}

	protected virtual void OnEnable()
	{
		interactionHandler.OnButtonDown += onControllerButtonDown;
		interactionHandler.OnButtonUp += onControllerButtonUp;
	}

	protected virtual void OnDisable()
	{
		interactionHandler.OnButtonDown -= onControllerButtonDown;
		interactionHandler.OnButtonUp -= onControllerButtonUp;
	}

	protected virtual void onControllerButtonDown(XRController controller)
	{
		if (base.enabled && base.isHovered)
		{
			buttonDownEvent?.Invoke();
		}
	}

	protected virtual void onControllerButtonUp(XRController controller)
	{
		if (base.enabled && base.isHovered)
		{
			buttonUpEvent?.Invoke();
		}
	}
}
public class UnityXR_Utility
{
	public const string picoNeo2Device = "Pico Pico Neo 2";

	public const string picoNeo3Device = "Pico Pico Neo 3";
}
[Serializable]
public struct XRDeviceKeyStruct
{
	public XRDeviceType deviceType;

	public XRKeyType keyType;
}
public enum XRDeviceType
{
	DT_Left,
	DT_Right
}
public enum XRKeyType
{
	Menu,
	Grip,
	Trigger,
	PrimaryButton,
	SecondaryButton,
	Primary2DAxisClick,
	AxisGrip,
	AxisTrigger,
	PrimaryAxis2D
}
public class UnityXR_Controller : MonoBehaviour
{
	private static UnityXR_Controller _instance;

	private UnityXR_InputSys _inputSys;

	private UnityXR_HandleSys _handleSys;

	public static UnityXR_Controller Instance
	{
		get
		{
			if (_instance == null)
			{
				_instance = UnityEngine.Object.FindObjectOfType(typeof(UnityXR_Controller)) as UnityXR_Controller;
				if (_instance == null)
				{
					_instance = new GameObject("UnityXR_Controller").AddComponent<UnityXR_Controller>();
					if (_instance == null)
					{
						UnityEngine.Debug.LogError("找不到 UnityXR_Controller 总控脚本");
					}
				}
			}
			return _instance;
		}
	}

	public UnityXR_InputSys InputSys
	{
		get
		{
			if (_inputSys == null)
			{
				_inputSys = UnityEngine.Object.FindObjectOfType(typeof(UnityXR_InputSys)) as UnityXR_InputSys;
				if (_instance == null)
				{
					UnityEngine.Debug.LogError(SceneManager.GetActiveScene().name + "场景找不到 UnityXR_InputSys 输入管理脚本");
				}
			}
			return _inputSys;
		}
	}

	public UnityXR_HandleSys HandleSys
	{
		get
		{
			if (_handleSys == null)
			{
				_handleSys = UnityEngine.Object.FindObjectOfType(typeof(UnityXR_HandleSys)) as UnityXR_HandleSys;
				if (_handleSys == null)
				{
					UnityEngine.Debug.LogError(SceneManager.GetActiveScene().name + "场景找不到 UnityXR_HandleSys 手柄管理脚本");
				}
			}
			return _handleSys;
		}
	}
}
public class UnityXR_HandleSys : MonoBehaviour
{
	public UnityXR_HandPresence leftHand;

	public UnityXR_HandPresence rightHand;

	public Transform GetTransform(XRDeviceType dt)
	{
		return dt switch
		{
			XRDeviceType.DT_Left => leftHand.transform, 
			XRDeviceType.DT_Right => rightHand.transform, 
			_ => null, 
		};
	}

	public void RayActive(XRDeviceType dt, bool isShow)
	{
		switch (dt)
		{
		case XRDeviceType.DT_Left:
			leftHand.SetRayShow(isShow);
			break;
		case XRDeviceType.DT_Right:
			rightHand.SetRayShow(isShow);
			break;
		}
	}

	public void ModelActive(XRDeviceType dt, bool showController, bool showModel)
	{
		switch (dt)
		{
		case XRDeviceType.DT_Left:
			leftHand.SetControllerModel(showController, showModel);
			break;
		case XRDeviceType.DT_Right:
			rightHand.SetControllerModel(showController, showModel);
			break;
		}
	}

	public void HapticPulse(XRDeviceType dt, float amplitude, float duration = 1f)
	{
		switch (dt)
		{
		case XRDeviceType.DT_Left:
			leftHand.HapticPulse(amplitude, duration);
			break;
		case XRDeviceType.DT_Right:
			rightHand.HapticPulse(amplitude, duration);
			break;
		}
	}
}
public class UnityXR_InputSys : MonoBehaviour
{
	[SerializeField]
	private XRController leftController;

	[SerializeField]
	private XRController rightController;

	[SerializeField]
	private UnityXR_KeyCodeHelper keyCodeHelper;

	private void Update()
	{
		HandleInputEvents();
	}

	public UnityXR_InputHandler GetInputHandler(XRDeviceType deviceType, XRKeyType keyType)
	{
		return keyCodeHelper.GetInputHandler(deviceType, keyType);
	}

	public bool GetButtonKeyDown(XRDeviceType type, XRKeyType keyType)
	{
		return false;
	}

	private void HandleInputEvents()
	{
		keyCodeHelper.LeftHandleKeysHandle(leftController);
		keyCodeHelper.RightHandleKeysHandle(rightController);
	}
}
public class HarmViewController : MonoBehaviour
{
	public PostProcessingProfile profile;

	[Range(0f, 1f)]
	public float dmgIncreaseValue = 0.15f;

	[Range(0f, 1f)]
	public float dmgMaxIntensity = 1f;

	public float fadeSpeed = 1f;

	[SerializeField]
	private float curValue;

	private void OnEnable()
	{
		ViewReset();
	}

	private void OnDisable()
	{
		ViewReset();
	}

	private void OnDestroy()
	{
		ViewReset();
	}

	public void OnDamageView(float value)
	{
		if ((bool)profile && !profile.vignette.enabled)
		{
			profile.vignette.enabled = true;
		}
		curValue += value;
		if (curValue > dmgMaxIntensity)
		{
			curValue = dmgMaxIntensity;
		}
		StartCoroutine(dmgFlash());
	}

	public void OnDamageView()
	{
		if ((bool)profile && !profile.vignette.enabled)
		{
			profile.vignette.enabled = true;
		}
		curValue += dmgIncreaseValue;
		if (curValue > dmgMaxIntensity)
		{
			curValue = dmgMaxIntensity;
		}
		StartCoroutine(dmgFlash());
	}

	public void OnRecover()
	{
		if ((bool)profile && !profile.vignette.enabled)
		{
			profile.vignette.enabled = true;
		}
		curValue -= dmgIncreaseValue;
		if (curValue < 0f)
		{
			curValue = 0f;
		}
		StartCoroutine(dmgFlash());
	}

	public void OnDieView(bool isDie)
	{
		if ((bool)profile && profile.colorGrading.enabled != isDie)
		{
			profile.colorGrading.enabled = isDie;
		}
	}

	public void ViewReset()
	{
		curValue = 0f;
		if ((bool)profile && profile.vignette.enabled && profile.vignette.settings.intensity > 0f)
		{
			profile.vignette.SetIntensity(0f);
		}
		if ((bool)profile && profile.colorGrading.enabled)
		{
			profile.colorGrading.enabled = false;
		}
	}

	private IEnumerator dmgFlash()
	{
		while ((bool)profile && profile.vignette.settings.intensity != curValue)
		{
			yield return null;
			if (profile.vignette.settings.intensity < curValue)
			{
				float num = profile.vignette.settings.intensity + Time.deltaTime * fadeSpeed;
				if (num > curValue)
				{
					num = curValue;
				}
				profile.vignette.SetIntensity(num);
			}
			else if (profile.vignette.settings.intensity > curValue)
			{
				float num2 = profile.vignette.settings.intensity - Time.deltaTime * fadeSpeed;
				if (num2 < curValue)
				{
					num2 = curValue;
				}
				profile.vignette.SetIntensity(num2);
			}
		}
	}
}
public class AtmosphereConfig : MonoBehaviour
{
	public Material m_Sky;

	public bool m_Fog;

	public Color m_FogColor;

	public AudioClip m_BGM;

	public AtmosphereConfig[] atmosphereConfigs;

	private void OnEnable()
	{
		RenderSettings.skybox = m_Sky;
		RenderSettings.fog = m_Fog;
		RenderSettings.fogColor = m_FogColor;
		for (int i = 0; i < atmosphereConfigs.Length; i++)
		{
			if (atmosphereConfigs[i] != this)
			{
				atmosphereConfigs[i].gameObject.SetActive(value: false);
			}
		}
	}
}
public class ARLookCamera : MonoBehaviour
{
	public Transform camera;

	private void Start()
	{
	}

	private void LateUpdate()
	{
		base.transform.LookAt(camera);
	}
}
public class PlayerData
{
	private static PlayerData _instance;

	public PlayerField playerField;

	public static PlayerData Instance
	{
		get
		{
			if (_instance == null)
			{
				_instance = new PlayerData();
			}
			return _instance;
		}
	}

	private PlayerData()
	{
		if (playerField == null)
		{
			playerField = new PlayerField();
			playerField.Add(1000, "Player_1", PlayerPrefs.GetInt("playerScore", 0));
			string[] array = ParseManMachineTab();
			for (int i = 0; i < array.Length; i++)
			{
				string[] array2 = array[i].Split(',');
				playerField.Add(int.Parse(array2[0]), array2[1], int.Parse(array2[2]));
			}
		}
	}

	private string[] ParseManMachineTab()
	{
		return Resources.Load<TextAsset>("manmachine/manmachine").text.Split('\n');
	}
}
public class PlayerField
{
	private int[] _id = new int[0];

	private string[] _name = new string[0];

	private int[] _score = new int[0];

	public int this[int id]
	{
		get
		{
			for (int i = 0; i < _id.Length; i++)
			{
				if (id == _id[i])
				{
					return Score[i];
				}
			}
			Add(id, "player_" + _name.Length + 1, 0);
			Sort();
			return _score[_score.Length - 1];
		}
		set
		{
			for (int i = 0; i < _id.Length; i++)
			{
				if (id == _id[i])
				{
					if (!_score.Equals(0))
					{
						_score[i] = value;
					}
					if (id.Equals(1000))
					{
						PlayerPrefs.SetInt("playerScore", value);
					}
				}
			}
		}
	}

	public int[] Id => _id;

	public string[] Name
	{
		get
		{
			return _name;
		}
		set
		{
			_name = value;
		}
	}

	public int[] Score
	{
		get
		{
			return _score;
		}
		set
		{
			_score = value;
		}
	}

	public void Add(int id, string name, int score)
	{
		if (!ContainID(id))
		{
			Array.Resize(ref _id, _id.Length + 1);
			Array.Resize(ref _name, _name.Length + 1);
			Array.Resize(ref _score, _score.Length + 1);
			_id[_id.Length - 1] = id;
			_name[_name.Length - 1] = name;
			_score[_score.Length - 1] = score;
			Sort();
			return;
		}
		throw new Exception($"id:{id} 已存在");
	}

	public bool ContainID(int id)
	{
		for (int i = 0; i < _id.Length; i++)
		{
			if (_id[i].Equals(id))
			{
				return true;
			}
		}
		return false;
	}

	public void Sort()
	{
		for (int i = 0; i < _id.Length; i++)
		{
			for (int j = 0; j < _id.Length - i - 1; j++)
			{
				if (_score[j] < _score[j + 1])
				{
					int num = _id[j];
					_id[j] = _id[j + 1];
					_id[j + 1] = num;
					string text = _name[j];
					_name[j] = _name[j + 1];
					_name[j + 1] = text;
					int num2 = _score[j];
					_score[j] = _score[j + 1];
					_score[j + 1] = num2;
				}
			}
		}
	}

	public int GetLenght()
	{
		return _id.Length;
	}

	public int GetIndex(int id)
	{
		for (int i = 0; i < _id.Length; i++)
		{
			if (id == _id[i])
			{
				return i;
			}
		}
		throw new Exception("找不到指定ID");
	}
}
public class VRClientEncrypt : MonoBehaviour
{
	public GameObject camHead;

	public int maxUseTimes = 3;

	private string saveKeyString = "Times";

	private void Start()
	{
		if (!VRGameSystem.bIsFirstPlay)
		{
			return;
		}
		VREncryptedPlayerPrefs.SetEncryptSeed();
		EnableGame(bEnable: false);
		if (VREncryptedPlayerPrefs.HasKey(saveKeyString))
		{
			int num = int.Parse(VREncryptedPlayerPrefs.GetString(saveKeyString));
			num++;
			if (num > maxUseTimes)
			{
				UnityEngine.Debug.Log("验证失败，游戏退出");
				Application.Quit();
			}
			else
			{
				EnableGame();
				VREncryptedPlayerPrefs.SetString(saveKeyString, num.ToString());
			}
		}
		else
		{
			EnableGame();
			VREncryptedPlayerPrefs.SetString(saveKeyString, "1");
		}
	}

	private void EnableGame(bool bEnable = true)
	{
		if (bEnable)
		{
			Time.timeScale = 1f;
			camHead.SetActive(value: true);
		}
		else
		{
			Time.timeScale = 0f;
			camHead.SetActive(value: false);
		}
	}
}
public class VREncryptedPlayerPrefs
{
	private static string privateKey = "9ETrEsWaFRach3gexaDr";

	[HideInInspector]
	public static string[] keys;

	public static void SetEncryptSeed()
	{
		if (keys == null || keys.Length == 0)
		{
			keys = new string[5];
			keys[0] = "23Wrudre";
			keys[1] = "SP9DupHa";
			keys[2] = "frA5rAS3";
			keys[3] = "tHat2epr";
			keys[4] = "jaw3eDAs";
		}
	}

	public static string Md5(string strToEncrypt)
	{
		byte[] bytes = new UTF8Encoding().GetBytes(strToEncrypt);
		byte[] array = new MD5CryptoServiceProvider().ComputeHash(bytes);
		string text = "";
		for (int i = 0; i < array.Length; i++)
		{
			text += Convert.ToString(array[i], 16).PadLeft(2, '0');
		}
		return text.PadLeft(32, '0');
	}

	public static void SaveEncryption(string key, string type, string value)
	{
		int num = (int)Mathf.Floor(UnityEngine.Random.value * (float)keys.Length);
		string text = keys[num];
		string value2 = Md5(type + "_" + privateKey + "_" + text + "_" + value);
		PlayerPrefs.SetString(key + "_encryption_check", value2);
		PlayerPrefs.SetInt(key + "_used_key", num);
	}

	public static bool CheckEncryption(string key, string type, string value)
	{
		int @int = PlayerPrefs.GetInt(key + "_used_key");
		string text = keys[@int];
		string text2 = Md5(type + "_" + privateKey + "_" + text + "_" + value);
		if (!PlayerPrefs.HasKey(key + "_encryption_check"))
		{
			return false;
		}
		return PlayerPrefs.GetString(key + "_encryption_check") == text2;
	}

	public static void SetInt(string key, int value)
	{
		PlayerPrefs.SetInt(key, value);
		SaveEncryption(key, "int", value.ToString());
	}

	public static void SetFloat(string key, float value)
	{
		PlayerPrefs.SetFloat(key, value);
		SaveEncryption(key, "float", Mathf.Floor(value * 1000f).ToString());
	}

	public static void SetString(string key, string value)
	{
		PlayerPrefs.SetString(key, value);
		SaveEncryption(key, "string", value);
	}

	public static int GetInt(string key)
	{
		return GetInt(key, 0);
	}

	public static float GetFloat(string key)
	{
		return GetFloat(key, 0f);
	}

	public static string GetString(string key)
	{
		return GetString(key, "");
	}

	public static int GetInt(string key, int defaultValue)
	{
		int @int = PlayerPrefs.GetInt(key);
		if (!CheckEncryption(key, "int", @int.ToString()))
		{
			return defaultValue;
		}
		return @int;
	}

	public static float GetFloat(string key, float defaultValue)
	{
		float @float = PlayerPrefs.GetFloat(key);
		if (!CheckEncryption(key, "float", Mathf.Floor(@float * 1000f).ToString()))
		{
			return defaultValue;
		}
		return @float;
	}

	public static string GetString(string key, string defaultValue)
	{
		string @string = PlayerPrefs.GetString(key);
		if (!CheckEncryption(key, "string", @string))
		{
			return defaultValue;
		}
		return @string;
	}

	public static bool HasKey(string key)
	{
		return PlayerPrefs.HasKey(key);
	}

	public static void DeleteKey(string key)
	{
		PlayerPrefs.DeleteKey(key);
		PlayerPrefs.DeleteKey(key + "_encryption_check");
		PlayerPrefs.DeleteKey(key + "_used_key");
	}
}
[RequireComponent(typeof(iTweenPath))]
public class VRiTweenPathMove : MonoBehaviour
{
	public float minMoveSpeed;

	public float maxMoveSpeed;

	public bool lookPos;

	public AudioSource audioSource;

	public AudioClip sound;

	public int[] soundPlayPos;

	private iTweenPath iTweenPath;

	private Vector3[] pathPos;

	private int posIndex;

	private bool isPlaySound;

	private void Awake()
	{
		iTweenPath = GetComponent<iTweenPath>();
	}

	private void Start()
	{
		SetPath();
	}

	private void Update()
	{
		if (lookPos)
		{
			Vector3 vector = pathPos[posIndex];
			vector.y = base.transform.position.y;
			Vector3 b = vector;
			base.transform.position = Vector3.Lerp(base.transform.position, b, 2f * Time.deltaTime);
			Quaternion b2 = Quaternion.LookRotation(vector - base.transform.position);
			b2.x = 0f;
			base.transform.rotation = Quaternion.Slerp(base.transform.rotation, b2, 2f * Time.deltaTime);
		}
		if (Vector3.Distance(base.transform.position, pathPos[posIndex]) < 0.05f)
		{
			posIndex++;
			posIndex %= pathPos.Length;
			for (int i = 0; i < soundPlayPos.Length; i++)
			{
				if (posIndex == soundPlayPos[i])
				{
					isPlaySound = true;
				}
			}
		}
		if (sound != null && isPlaySound)
		{
			if (audioSource != null)
			{
				audioSource.PlayOneShot(sound);
			}
			else
			{
				AudioSource.PlayClipAtPoint(sound, base.transform.position);
			}
			isPlaySound = false;
		}
	}

	private void SetPath()
	{
		pathPos = iTweenPath.GetPath(iTweenPath.pathName);
		if (pathPos != null && pathPos.Length != 0)
		{
			System.Collections.Hashtable hashtable = new System.Collections.Hashtable();
			hashtable.Add("path", pathPos);
			hashtable.Add("easeType", iTween.EaseType.linear);
			hashtable.Add("speed", UnityEngine.Random.Range(minMoveSpeed, maxMoveSpeed));
			hashtable.Add("movetopath", false);
			hashtable.Add("orienttopath", false);
			hashtable.Add("loopType", iTween.LoopType.loop);
			iTween.MoveTo(base.gameObject, hashtable);
		}
	}

	public void SoundPlay(UnityEngine.Object objSound)
	{
		if (objSound != null)
		{
			VRPlaySound component = VRGlobal.getActorEntity(objSound).GetComponent<VRPlaySound>();
			if (component != null)
			{
				component.playSound(base.transform);
			}
		}
	}
}
public class VRDeathEffect : MonoBehaviour
{
	public ParticleSystem[] particleSystems;

	public void Enable(SkinnedMeshRenderer mesh)
	{
		for (int i = 0; i < particleSystems.Length; i++)
		{
			ParticleSystem.ShapeModule shape = particleSystems[i].shape;
			shape.skinnedMeshRenderer = mesh;
		}
		Invoke("DestoryEffect", 2f);
	}

	private void DestoryEffect()
	{
		VRGlobal.pushFreeEntity(base.gameObject);
	}
}
public class VRRagdoll : MonoBehaviour
{
	private Rigidbody[] rigidbodies;

	private List<Collider> colliders;

	private Transform tf;

	private float _impactEndTime;

	private Rigidbody _impactTarget;

	private Vector3 _impactDirection;

	private void Awake()
	{
		tf = base.transform.parent;
		rigidbodies = GetComponentsInChildren<Rigidbody>();
		colliders = GetComponentsInChildren<Collider>().ToList();
		colliders.RemoveAt(0);
	}

	private void FixedUpdate()
	{
		if (Time.time < _impactEndTime)
		{
			_impactTarget.AddForce(_impactDirection * Time.deltaTime * 80f, ForceMode.VelocityChange);
		}
	}

	private bool Raycast(Ray ray, out RaycastHit hit, float distance)
	{
		RaycastHit[] array = Physics.RaycastAll(ray, distance);
		for (int i = 0; i < array.Length; i++)
		{
			RaycastHit raycastHit = array[i];
			if (raycastHit.transform != base.transform && raycastHit.transform.root == base.transform.root)
			{
				hit = raycastHit;
				return true;
			}
		}
		hit = default(RaycastHit);
		return false;
	}

	public void Shot(Ray ray, float distance)
	{
		UnityEngine.Debug.DrawRay(ray.origin, ray.origin + ray.direction * distance, Color.red, 2f);
		if (!Raycast(ray, out var hit, distance))
		{
			Rigidbody rigidbody = hit.rigidbody;
			if (!(rigidbody == null) && !(hit.transform.root != base.transform.root))
			{
				_impactTarget = rigidbody;
				_impactDirection = ray.direction;
				_impactEndTime = Time.time + 0.25f;
			}
		}
	}

	public void Enable()
	{
		for (int i = 0; i < rigidbodies.Length; i++)
		{
			rigidbodies[i].isKinematic = false;
		}
		for (int j = 0; j < colliders.Count; j++)
		{
			colliders[j].enabled = true;
		}
		_impactTarget = rigidbodies[0];
		_impactDirection = base.transform.up * 2f;
		_impactEndTime = Time.time + 0.25f;
	}

	public void Disable()
	{
		for (int i = 0; i < rigidbodies.Length; i++)
		{
			rigidbodies[i].isKinematic = true;
		}
		for (int j = 0; j < colliders.Count; j++)
		{
			colliders[j].enabled = false;
		}
	}
}
public class VRItem : VRGameObject
{
	public PhotonView photonView;

	protected bool used;

	public float moveSpeed = 3f;

	protected VRNpc target;

	public override bool MyReset()
	{
		used = false;
		base.gameObject.SetActive(value: true);
		EnableVisiable(visiable: true);
		EnablePlayerUseEff(visiable: false);
		FindTarget();
		return base.MyReset();
	}

	protected virtual void FindTarget()
	{
		target = VRGlobal.G_GameSystem.Gate;
	}

	protected void EnableVisiable(bool visiable)
	{
		ParticleSystem[] componentsInChildren = base.gameObject.GetComponentsInChildren<ParticleSystem>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			if ((bool)componentsInChildren[i] && !componentsInChildren[i].gameObject.tag.Equals("useeff"))
			{
				componentsInChildren[i].gameObject.SetActive(visiable);
				if (visiable)
				{
					componentsInChildren[i].Play();
				}
				else
				{
					componentsInChildren[i].Stop();
				}
			}
		}
	}

	protected void EnablePlayerUseEff(bool visiable)
	{
		ParticleSystem[] componentsInChildren = base.gameObject.GetComponentsInChildren<ParticleSystem>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			if ((bool)componentsInChildren[i] && componentsInChildren[i].gameObject.tag.Equals("useeff"))
			{
				if (visiable)
				{
					componentsInChildren[i].Play();
				}
				else
				{
					componentsInChildren[i].Stop();
				}
			}
		}
	}

	[PunRPC]
	protected virtual void Destroy()
	{
		bool flag = false;
		ParticleSystem[] componentsInChildren = base.gameObject.GetComponentsInChildren<ParticleSystem>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			if ((bool)componentsInChildren[i] && componentsInChildren[i].gameObject.tag.Equals("useeff"))
			{
				if (componentsInChildren[i].isPlaying && (bool)target && (bool)target && target.CurHP > 0f)
				{
					base.transform.position = target.transform.position;
				}
				else
				{
					flag = true;
				}
			}
		}
		if (flag)
		{
			UnityEngine.Object.Destroy(base.gameObject);
			VRGlobal.pushFreeEntity(base.gameObject);
		}
	}

	protected override bool MyUpdate(float delta)
	{
		if (!used)
		{
			if ((bool)target)
			{
				if (target.CurHP > 0f)
				{
					if ((base.transform.position - target.transform.position).sqrMagnitude <= 0.1f)
					{
						use();
					}
					else
					{
						base.transform.Translate((target.transform.position - base.transform.position).normalized * moveSpeed * delta);
					}
				}
				else
				{
					FindTarget();
				}
			}
			else if (VRGameSystem.CurGameModel == GameModel.GM_Single)
			{
				Destroy();
			}
			else if (VRGameSystem.CurGameModel == GameModel.GM_Multi)
			{
				photonView.RPC("Destroy", RpcTarget.All);
			}
		}
		else if (VRGameSystem.CurGameModel == GameModel.GM_Single)
		{
			Destroy();
		}
		else if (VRGameSystem.CurGameModel == GameModel.GM_Multi)
		{
			photonView.RPC("Destroy", RpcTarget.All);
		}
		return true;
	}

	public virtual bool use()
	{
		AudioSource component = base.gameObject.GetComponent<AudioSource>();
		if (component != null)
		{
			component.Play();
		}
		EnableVisiable(visiable: false);
		EnablePlayerUseEff(visiable: true);
		used = true;
		return true;
	}
}
public class VRItemHP : VRItem
{
	public enum FindType
	{
		FT_Random = 1,
		FT_MinHP
	}

	public FindType findType = FindType.FT_Random;

	public float fSupplyHpRatio = 0.1f;

	protected override bool MyUpdate(float delta)
	{
		if (VRGameSystem.CurGameState == GameState.GS_Fail || VRGameSystem.CurGameState == GameState.GS_End || VRGameSystem.CurGameState == GameState.GS_Finish)
		{
			Destroy();
			return true;
		}
		return base.MyUpdate(delta);
	}

	public override bool MyReset()
	{
		return base.MyReset();
	}

	protected override void FindTarget()
	{
		base.FindTarget();
		if (VRGlobal.G_GameSystem.Gate.CurHP < VRGlobal.G_GameSystem.Gate.Hp)
		{
			target = VRGlobal.G_GameSystem.Gate;
			return;
		}
		if (findType == FindType.FT_Random)
		{
			List<VRNpc> list = new List<VRNpc>();
			for (int i = 0; i < VRGlobal.G_GameSystem.shuijingList.shuijingList.Count; i++)
			{
				VRNpc component = VRGlobal.G_GameSystem.shuijingList.shuijingList[i].shuijingList[0].GetComponent<VRNpc>();
				if (component.CurHP < component.Hp && component.CurHP > 0f)
				{
					list.Add(component);
				}
			}
			if (list.Count > 0)
			{
				target = list[UnityEngine.Random.Range(0, list.Count)];
			}
			return;
		}
		VRNpc vRNpc = null;
		for (int j = 0; j < VRGlobal.G_GameSystem.shuijingList.shuijingList.Count; j++)
		{
			VRNpc component2 = VRGlobal.G_GameSystem.shuijingList.shuijingList[j].shuijingList[0].GetComponent<VRNpc>();
			if (!(component2.CurHP <= 0f) && !(component2.CurHP >= component2.Hp) && (vRNpc == null || component2.CurHP < vRNpc.CurHP))
			{
				vRNpc = component2;
			}
		}
		if (vRNpc == null)
		{
			vRNpc = VRGlobal.G_GameSystem.Gate;
		}
		target = vRNpc;
	}

	public override bool use()
	{
		float value = target.Hp * fSupplyHpRatio;
		target.RecoverHP(value);
		if (VRGameSystem.CurGameModel == GameModel.GM_Single)
		{
			RPCUse();
		}
		else if (VRGameSystem.CurGameModel == GameModel.GM_Multi)
		{
			photonView.RPC("RPCUse", RpcTarget.All);
		}
		return true;
	}

	[PunRPC]
	public void RPCUse()
	{
		base.use();
	}
}
public class VRItem_Shield : VRItem
{
	public float time = 5f;

	public AudioClip[] damageClips;

	public AudioSource audioSource;

	private float timer;

	public override bool MyReset()
	{
		return base.MyReset();
	}

	protected override bool MyUpdate(float delta)
	{
		if (!used)
		{
			if (target != null && target.CurHP > 0f)
			{
				if ((base.transform.position - target.transform.position).sqrMagnitude <= 0.1f)
				{
					use();
				}
				else
				{
					base.transform.Translate((target.transform.position - base.transform.position).normalized * moveSpeed * delta);
				}
			}
		}
		else if (Time.time > timer)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
		return true;
	}

	protected override void FindTarget()
	{
		base.FindTarget();
		if (VRGlobal.G_GameSystem.Gate.CurHP < VRGlobal.G_GameSystem.Gate.Hp)
		{
			target = VRGlobal.G_GameSystem.Gate;
			return;
		}
		List<VRNpc> list = new List<VRNpc>();
		for (int i = 0; i < VRGlobal.G_GameSystem.shuijingList.shuijingList.Count; i++)
		{
			VRNpc component = VRGlobal.G_GameSystem.shuijingList.shuijingList[i].shuijingList[0].GetComponent<VRNpc>();
			if (component.CurHP < component.Hp && component.CurHP > 0f)
			{
				list.Add(component);
			}
		}
		if (list.Count > 0)
		{
			target = list[UnityEngine.Random.Range(0, list.Count)];
		}
	}

	public override bool use()
	{
		((VRGate)target).AddShield(this);
		timer = time + Time.time;
		return base.use();
	}

	public void OnDamage(float value)
	{
		int num = UnityEngine.Random.Range(0, damageClips.Length);
		audioSource.PlayOneShot(damageClips[num]);
	}
}
[CreateAssetMenu(fileName = "Localization", menuName = "Localization", order = 999)]
public class LocalizationScript : ScriptableObject
{
	public List<DicStruct> CNData = new List<DicStruct>();

	public List<DicStruct> ENData = new List<DicStruct>();

	public List<DicStruct> FRData = new List<DicStruct>();

	public List<DicStruct> GEData = new List<DicStruct>();

	public List<DicStruct> ITData = new List<DicStruct>();

	public List<DicStruct> KRData = new List<DicStruct>();

	public List<DicStruct> JPData = new List<DicStruct>();

	public List<DicStruct> RUData = new List<DicStruct>();

	public List<DicStruct> SPData = new List<DicStruct>();

	public List<DicStruct> TWData = new List<DicStruct>();

	public List<DicStruct> GetData(SystemLanguage tempLanguage)
	{
		return tempLanguage switch
		{
			SystemLanguage.English => ENData, 
			SystemLanguage.ChineseSimplified => CNData, 
			SystemLanguage.ChineseTraditional => TWData, 
			SystemLanguage.Japanese => JPData, 
			SystemLanguage.French => FRData, 
			SystemLanguage.German => GEData, 
			SystemLanguage.Italian => ITData, 
			SystemLanguage.Korean => KRData, 
			SystemLanguage.Russian => RUData, 
			SystemLanguage.Spanish => SPData, 
			_ => ENData, 
		};
	}
}
[Serializable]
public class DicStruct
{
	public string key;

	public string value;

	public DicStruct(string k, string v)
	{
		key = k;
		value = v;
	}
}
public class VRNewBieGuideFireBullet : VRNewbieGuideBase
{
	public GameObject target;

	public string strKillWeaponLayer_1 = "";

	public string strKillWeaponLayer_2 = "";

	public override void StartGuide(VRNewbieGuideMgr guideMgr)
	{
		base.StartGuide(guideMgr);
		if (!mGuideMgr || !(mGuideMgr.shouZhi != null))
		{
			return;
		}
		mGuideMgr.shouZhi.SetActive(value: true);
		mGuideMgr.shouZhi.transform.localScale = Vector3.one * shouzhiScaleRatio;
		if ((bool)target)
		{
			VRMuTouItem component = target.GetComponent<VRMuTouItem>();
			if ((bool)component)
			{
				component.bCanAttack = true;
				component.bLitmitKiller = true;
				component.strLimitKillerLayerName_1 = strKillWeaponLayer_1;
				component.strLimitKillerLayerName_2 = strKillWeaponLayer_2;
			}
			mGuideMgr.shouZhi.transform.position = target.transform.position;
			mGuideMgr.shouZhi.transform.position += new Vector3(0f, shouzhiHeightOffset, 0f);
		}
	}

	private void Update()
	{
	}

	public override void EndGuide()
	{
		if ((bool)mGuideMgr && mGuideMgr.shouZhi != null && mGuideMgr.shouZhi.activeSelf)
		{
			mGuideMgr.shouZhi.SetActive(value: false);
		}
		base.EndGuide();
	}

	public override bool CheckEnd()
	{
		return mIsEnd;
	}

	public override void OnMuTouItemExpode(VRNpc owner)
	{
		if (owner.gameObject == target)
		{
			mIsEnd = true;
		}
	}
}
public class VRNewBieGuideFireSkillBullet : VRNewbieGuideBase
{
	public GameObject target;

	public string strKillWeaponLayer_1 = "";

	public string strKillWeaponLayer_2 = "";

	public override void StartGuide(VRNewbieGuideMgr guideMgr)
	{
		base.StartGuide(guideMgr);
		if (!mGuideMgr || !(mGuideMgr.shouZhi != null))
		{
			return;
		}
		mGuideMgr.shouZhi.SetActive(value: true);
		mGuideMgr.shouZhi.transform.localScale = Vector3.one * shouzhiScaleRatio;
		if ((bool)target)
		{
			VRMuTouItem component = target.GetComponent<VRMuTouItem>();
			if ((bool)component)
			{
				component.bCanAttack = true;
				component.bLitmitKiller = true;
				component.strLimitKillerLayerName_1 = strKillWeaponLayer_1;
				component.strLimitKillerLayerName_2 = strKillWeaponLayer_2;
			}
			mGuideMgr.shouZhi.transform.position = target.transform.position;
			mGuideMgr.shouZhi.transform.position += new Vector3(0f, shouzhiHeightOffset, 0f);
		}
	}

	private void Update()
	{
	}

	public override void EndGuide()
	{
		if ((bool)mGuideMgr && mGuideMgr.shouZhi != null && mGuideMgr.shouZhi.activeSelf)
		{
			mGuideMgr.shouZhi.SetActive(value: false);
		}
		base.EndGuide();
	}

	public override bool CheckEnd()
	{
		return mIsEnd;
	}

	public override void OnMuTouItemExpode(VRNpc owner)
	{
		if (owner.gameObject == target)
		{
			mIsEnd = true;
		}
	}
}
public class VRNewBieGuideGrabObj : VRNewbieGuideBase
{
	public GameObject target;

	public override void StartGuide(VRNewbieGuideMgr guideMgr)
	{
		base.StartGuide(guideMgr);
		if ((bool)mGuideMgr && mGuideMgr.shouZhi != null)
		{
			mGuideMgr.shouZhi.SetActive(value: true);
			mGuideMgr.shouZhi.transform.localScale = Vector3.one * shouzhiScaleRatio;
			if ((bool)target)
			{
				mGuideMgr.shouZhi.transform.position = target.transform.position;
				mGuideMgr.shouZhi.transform.position += new Vector3(0f, shouzhiHeightOffset, 0f);
			}
		}
	}

	private void Update()
	{
	}

	public override void EndGuide()
	{
		if ((bool)mGuideMgr && mGuideMgr.shouZhi != null && mGuideMgr.shouZhi.activeSelf)
		{
			mGuideMgr.shouZhi.SetActive(value: false);
		}
		base.EndGuide();
	}

	public override bool CheckEnd()
	{
		return mIsEnd;
	}

	public override void OnGrabObj(GameObject obj)
	{
		if (obj == target)
		{
			mIsEnd = true;
		}
	}
}
public class VRNewbieGuideBase : MonoBehaviour
{
	public VRNewbieGuideBase NextGuide;

	public int ShowTime;

	protected VRNewbieGuideMgr mGuideMgr;

	protected float mShowTimer;

	protected bool mIsEnd;

	public float shouzhiHeightOffset = 2.5f;

	public float shouzhiScaleRatio = 1f;

	public string tipText = "";

	public string audioName;

	public bool isShowWeapon = true;

	private void Start()
	{
	}

	private void Update()
	{
		mShowTimer += Time.deltaTime;
	}

	public virtual bool CheckEnd()
	{
		if (ShowTime >= 0)
		{
			return mShowTimer >= (float)ShowTime;
		}
		return false;
	}

	public virtual void StartGuide(VRNewbieGuideMgr mgr)
	{
		base.gameObject.SetActive(value: true);
		mGuideMgr = mgr;
		mShowTimer = 0f;
		if (tipText.Length > 0)
		{
			tipText = Regex.Unescape(LTLocalization.GetText(tipText));
			VRGlobal.G_GameSystem.uiManager.ShowTips(bShow: true, tipText, bAutoClose: false);
			playAudio(audioName);
		}
	}

	public virtual void EndGuide()
	{
		VRGlobal.G_GameSystem.uiManager.ShowTips(bShow: false);
	}

	public virtual void OnMuTouItemExpode(VRNpc owner)
	{
	}

	public virtual void OnGrabObj(GameObject obj)
	{
	}

	public void playAudio(string str, float fVolume = 1f, bool bLoop = false)
	{
		string text = null;
		text = VRGlobal.G_Language switch
		{
			SystemLanguage.Afrikaans => "Afrikaans", 
			SystemLanguage.Arabic => "Arabic", 
			SystemLanguage.Basque => "Basque", 
			SystemLanguage.Belarusian => "Belarusian", 
			SystemLanguage.Bulgarian => "Bulgarian", 
			SystemLanguage.Catalan => "Catalan", 
			SystemLanguage.Chinese => null, 
			SystemLanguage.Czech => "Czech", 
			SystemLanguage.Danish => "Danish", 
			SystemLanguage.Dutch => "Dutch", 
			SystemLanguage.English => "_en", 
			SystemLanguage.Estonian => "Estonian", 
			SystemLanguage.Faroese => "Faroese", 
			SystemLanguage.Finnish => "Finnish", 
			SystemLanguage.French => "_unknow", 
			SystemLanguage.German => "_unknow", 
			SystemLanguage.Greek => "Greek", 
			SystemLanguage.Hebrew => "Hebrew", 
			SystemLanguage.Hungarian => "Hungarian", 
			SystemLanguage.Icelandic => "Icelandic", 
			SystemLanguage.Indonesian => "Indonesian", 
			SystemLanguage.Italian => "_unknow", 
			SystemLanguage.Japanese => "_unknow", 
			SystemLanguage.Korean => "_unknow", 
			SystemLanguage.Latvian => "Latvian", 
			SystemLanguage.Lithuanian => "Lithuanian", 
			SystemLanguage.Norwegian => "Norwegian", 
			SystemLanguage.Polish => "Polish", 
			SystemLanguage.Portuguese => "Portuguese", 
			SystemLanguage.Romanian => "Romanian", 
			SystemLanguage.Russian => "_unknow", 
			SystemLanguage.SerboCroatian => "SerboCroatian", 
			SystemLanguage.Slovak => "Slovak", 
			SystemLanguage.Slovenian => "Slovenian", 
			SystemLanguage.Spanish => "_unknow", 
			SystemLanguage.Swedish => "Swedish", 
			SystemLanguage.Thai => "Thai", 
			SystemLanguage.Turkish => "Turkish", 
			SystemLanguage.Ukrainian => "Ukrainian", 
			SystemLanguage.Vietnamese => "Vietnamese", 
			SystemLanguage.ChineseSimplified => null, 
			SystemLanguage.ChineseTraditional => null, 
			SystemLanguage.Unknown => "_unknow", 
			_ => null, 
		};
		AudioClip audioClip = null;
		audioClip = ((text == null) ? ((AudioClip)Resources.Load("Actor/Sound/" + str, typeof(AudioClip))) : ((AudioClip)Resources.Load("Actor/Sound/" + str + text, typeof(AudioClip))));
		if ((bool)audioClip)
		{
			if (VRGlobal.G_Language == SystemLanguage.English)
			{
				PlayAudioClip(audioClip, fVolume - 0.5f, bLoop);
			}
			else
			{
				PlayAudioClip(audioClip, fVolume, bLoop);
			}
		}
	}

	protected void PlayAudioClip(AudioClip clip, float fVolume, bool bLoop)
	{
		if (!(clip == null))
		{
			AudioSource audioSource = (AudioSource)base.gameObject.GetComponent("AudioSource");
			if (audioSource == null)
			{
				audioSource = base.gameObject.AddComponent<AudioSource>();
			}
			audioSource.volume = fVolume;
			audioSource.loop = bLoop;
			audioSource.clip = clip;
			audioSource.minDistance = 1f;
			audioSource.maxDistance = 50000000f;
			audioSource.rolloffMode = AudioRolloffMode.Linear;
			audioSource.Play();
		}
	}
}
public class VRNewbieGuideMgr : MonoBehaviour
{
	public static VRNewbieGuideMgr Instance;

	public VRNewbieGuideBase firstGuide;

	public VRNewbieGuideBase mCurGuide;

	public GameObject shouZhi;

	public float delayStartTime;

	private void Awake()
	{
		Instance = this;
		if ((bool)shouZhi && shouZhi.activeSelf)
		{
			shouZhi.SetActive(value: false);
		}
	}

	private void OnDestroy()
	{
		Instance = null;
		VRGlobal.pushFreeEntity(shouZhi);
	}

	private void Update()
	{
		if (mCurGuide == null)
		{
			if ((bool)firstGuide)
			{
				mCurGuide = firstGuide;
				Invoke("DelayStart", delayStartTime);
			}
		}
		else
		{
			if (!mCurGuide.CheckEnd())
			{
				return;
			}
			mCurGuide.EndGuide();
			if ((bool)mCurGuide.NextGuide)
			{
				AudioSource component = mCurGuide.gameObject.GetComponent<AudioSource>();
				if (component != null)
				{
					component.Stop();
				}
				mCurGuide = mCurGuide.NextGuide;
				mCurGuide.StartGuide(this);
			}
			else
			{
				VRGameSystem.CurGameState = GameState.GS_PreStage;
				VRGlobal.G_GameSystem.InitSpawnDynSceneObj();
			}
		}
	}

	public static bool IsRunning()
	{
		if (Instance != null)
		{
			return Instance.mCurGuide != null;
		}
		return false;
	}

	public static void OnMuTouItemExpode(VRNpc owner)
	{
		if (!(Instance == null) && !(Instance.mCurGuide == null))
		{
			Instance.mCurGuide.OnMuTouItemExpode(owner);
		}
	}

	public static void OnGrabObj(GameObject obj)
	{
		if (!(Instance == null) && !(Instance.mCurGuide == null))
		{
			Instance.mCurGuide.OnGrabObj(obj);
		}
	}

	private void DelayStart()
	{
		mCurGuide.StartGuide(this);
	}
}
public class MultPlaysScene : MonoBehaviour
{
	public static MultPlaysScene Instance { get; private set; }

	private void Awake()
	{
		Instance = this;
	}
}
public class SceneStyleManager : MonoBehaviour
{
	public GameObject dayTime_Normal;

	public GameObject dusk_Normal_Darker;

	public GameObject night_Normal;

	public GameObject dayTime_Darker;

	public GameObject night_Darker;

	public GameObject dayTime_Dim;

	public GameObject dusk_Dim;

	public GameObject night_Dim;

	private SceneStyleType curStyle;

	private void Start()
	{
		ResetStyle();
	}

	public void EnterNextStyle()
	{
		switch (curStyle)
		{
		case SceneStyleType.ST_DayTime_Normal:
			curStyle = SceneStyleType.ST_Dusk_Normal;
			break;
		case SceneStyleType.ST_Dusk_Normal:
			curStyle = SceneStyleType.ST_Night_Normal;
			break;
		case SceneStyleType.ST_Night_Normal:
			curStyle = SceneStyleType.ST_DayTime_Darker;
			break;
		case SceneStyleType.ST_DayTime_Darker:
			curStyle = SceneStyleType.ST_Dusk_Darker;
			break;
		case SceneStyleType.ST_Dusk_Darker:
			curStyle = SceneStyleType.ST_Night_Darker;
			break;
		case SceneStyleType.ST_Night_Darker:
			curStyle = SceneStyleType.ST_DayTime_Dim;
			break;
		case SceneStyleType.ST_DayTime_Dim:
			curStyle = SceneStyleType.ST_Dusk_Dim;
			break;
		case SceneStyleType.ST_Dusk_Dim:
			curStyle = SceneStyleType.ST_Night_Dim;
			break;
		case SceneStyleType.ST_Night_Dim:
			curStyle = SceneStyleType.ST_DayTime_Normal;
			break;
		}
		dayTime_Normal.SetActive(curStyle == SceneStyleType.ST_DayTime_Normal);
		dusk_Normal_Darker.SetActive(curStyle == SceneStyleType.ST_Dusk_Normal || curStyle == SceneStyleType.ST_Dusk_Darker);
		night_Normal.SetActive(curStyle == SceneStyleType.ST_Night_Normal);
		dayTime_Darker.SetActive(curStyle == SceneStyleType.ST_DayTime_Darker);
		night_Darker.SetActive(curStyle == SceneStyleType.ST_Night_Darker);
		dayTime_Dim.SetActive(curStyle == SceneStyleType.ST_DayTime_Dim);
		dusk_Dim.SetActive(curStyle == SceneStyleType.ST_Dusk_Dim);
		night_Dim.SetActive(curStyle == SceneStyleType.ST_Night_Dim);
		UnityEngine.Debug.Log("进入下一个场景风格");
	}

	public void ResetStyle()
	{
		curStyle = SceneStyleType.ST_DayTime_Normal;
		if (!dayTime_Normal.activeSelf)
		{
			dayTime_Normal.SetActive(value: true);
		}
		if (dusk_Normal_Darker.activeSelf)
		{
			dusk_Normal_Darker.SetActive(value: false);
		}
		if (night_Normal.activeSelf)
		{
			night_Normal.SetActive(value: false);
		}
		if (dayTime_Darker.activeSelf)
		{
			dayTime_Darker.SetActive(value: false);
		}
		if (night_Darker.activeSelf)
		{
			night_Darker.SetActive(value: false);
		}
		if (dayTime_Dim.activeSelf)
		{
			dayTime_Dim.SetActive(value: false);
		}
		if (dusk_Dim.activeSelf)
		{
			dusk_Dim.SetActive(value: false);
		}
		if (night_Dim.activeSelf)
		{
			night_Dim.SetActive(value: false);
		}
	}
}
public class VRSMBAirAttack : StateMachineBehaviour
{
	protected VRMonster ply;

	public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		ply = animator.gameObject.GetComponent<VRMonster>();
		ply.AnimatorClear();
		animator.SetBool("fly", value: false);
		ply.PauseItweenPath();
		VRBomb componentInChildren = animator.GetComponentInChildren<VRBomb>();
		if (componentInChildren != null)
		{
			VRNpc killer = ply.GetComponent<VRNpc>();
			Vector3 pos = Vector3.zero;
			componentInChildren.OnDamage(1f, ref killer, sound: true, ref pos);
		}
		ply.SetAnimDead();
	}
}
public class VRSMBAirDead : StateMachineBehaviour
{
	private VRMonster ply;

	private VRActorAction deadFlashAction;

	public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		ply = animator.gameObject.GetComponent<VRMonster>();
		ply.StopItweenPath();
		ply.AnimatorClear();
		animator.SetBool("fly", value: false);
		deadFlashAction = ply.playEffectAction("deadFlash");
		ply.CurHP = 0f;
		if ((bool)animator.gameObject.GetComponent<VRBoss>() && VRGlobal.G_GameSystem.CurStageID >= VRGlobal.G_GameSystem.nMaxStageNum)
		{
			VRGameSystem.CurGameState = GameState.GS_Finish;
		}
		Rigidbody rigidbody = animator.gameObject.GetComponent<Rigidbody>();
		if (rigidbody == null)
		{
			rigidbody = animator.gameObject.AddComponent<Rigidbody>();
		}
		if ((bool)rigidbody)
		{
			rigidbody.useGravity = true;
			rigidbody.velocity *= 0f;
		}
		VRBubbleText component = ply.gameObject.GetComponent<VRBubbleText>();
		if ((bool)component)
		{
			component.SetVisible(visible: false);
		}
		VRBomb componentInChildren = ply.GetComponentInChildren<VRBomb>();
		if (componentInChildren != null)
		{
			componentInChildren.Drop();
		}
		ply.Ragdoll(open: true);
		ply.StartCoroutine(OnDeath());
	}

	private IEnumerator OnDeath()
	{
		yield return new WaitForSeconds(2f);
		if (ply is VRBoss || !deadFlashAction || ((bool)deadFlashAction && !deadFlashAction.isRuning))
		{
			VRGlobal.pushFreeEntity(ply.gameObject);
			if (ply is VRBoss)
			{
				ply.stopEffectActionAll();
			}
		}
	}

	public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		if ((bool)ply && ply.CurHP <= 0f && (!deadFlashAction || ((bool)deadFlashAction && !deadFlashAction.isRuning)))
		{
			VRGlobal.pushFreeEntity(ply.gameObject);
		}
	}
}
public class VRSMBAirFly : StateMachineBehaviour
{
	private VRMonster ply;

	public GameObject shoutSound;

	public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		ply = animator.gameObject.GetComponent<VRMonster>();
		ply.AnimatorClear();
		ply.SetItweenPathDest();
	}

	public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		if (animator.speed != ply.MoveSpeed)
		{
			animator.speed = ply.MoveSpeed;
		}
		if ((bool)ply)
		{
			switch (VRUtility.RandomChoose(new float[3] { 900f, 1f, 2f }))
			{
			case 1:
				animator.SetBool("fly", value: false);
				break;
			case 2:
				ply.SoundPlay(shoutSound);
				break;
			case 0:
				break;
			}
		}
	}
}
public class VRSMBAirInjure : StateMachineBehaviour
{
	private VRMonster ply;

	public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		ply = animator.gameObject.GetComponent<VRMonster>();
		ply.AnimatorClear();
		ply.PauseItweenPath();
	}
}
public class VRSMBAirShow : StateMachineBehaviour
{
	private VRMonster ply;

	public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		ply = animator.gameObject.GetComponent<VRMonster>();
		if ((bool)ply)
		{
			ply.AnimatorClear();
		}
	}
}
public class VRSMBAirStand : StateMachineBehaviour
{
	private VRMonster ply;

	public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		ply = animator.gameObject.GetComponent<VRMonster>();
		if ((bool)ply)
		{
			ply.AnimatorClear();
			if (ply.InitShow)
			{
				animator.SetBool("show", value: true);
				ply.InitShow = false;
			}
		}
	}

	public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		if (!ply)
		{
			return;
		}
		if (ply.CheckReachTarget())
		{
			animator.SetBool("attack", value: true);
			return;
		}
		int num = VRUtility.RandomChoose(new float[2] { 900f, 100f });
		if (num != 0 && num == 1)
		{
			animator.SetBool("fly", value: true);
		}
	}
}
public class VRSMBLandAttack : StateMachineBehaviour
{
	protected VRMonster ply;

	public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		ply = animator.gameObject.GetComponent<VRMonster>();
		ply.AnimatorClear();
		animator.SetBool("run", value: false);
		ply.StopFindPath();
		VRBomb componentInChildren = animator.GetComponentInChildren<VRBomb>();
		if (componentInChildren != null)
		{
			VRNpc killer = ply.GetComponent<VRNpc>();
			Vector3 pos = Vector3.zero;
			componentInChildren.OnDamage(1f, ref killer, sound: true, ref pos);
			return;
		}
		VRNpc tgt = ply.Target.GetComponent<VRNpc>();
		if ((bool)tgt)
		{
			float dmgHP = ply.ATKFinal(ref tgt, 1f);
			VRNpc killer2 = ply.GetComponent<VRNpc>();
			Vector3 pos2 = Vector3.zero;
			tgt.OnDamage(dmgHP, ref killer2, sound: true, ref pos2);
			if (ply.mAttackType == AttackType.AT_Explode)
			{
				animator.SetBool("dead", value: true);
			}
			if (tgt.CurHP <= 0f)
			{
				ply.FindTarget();
				ply.SetFindPathDestination();
			}
		}
	}

	public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
	}
}
public class VRSMBLandDead : StateMachineBehaviour
{
	private VRMonster ply;

	private VRActorAction deadFlashAction;

	public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		ply = animator.gameObject.GetComponent<VRMonster>();
		ply.AnimatorClear();
		animator.SetBool("run", value: false);
		ply.StopFindPath();
		deadFlashAction = ply.playEffectAction("deadFlash");
		if (ply.bNeedBulletTime)
		{
			Time.timeScale = 0.8f;
		}
		VRBubbleText component = ply.gameObject.GetComponent<VRBubbleText>();
		if ((bool)component)
		{
			component.SetVisible(visible: false);
		}
		ply.CurHP = 0f;
		VRBomb componentInChildren = ply.GetComponentInChildren<VRBomb>();
		if (componentInChildren != null)
		{
			componentInChildren.Drop();
		}
		ply.SoundPlay(Resources.Load<GameObject>("Prefab/Sound/pk_flybing_death"));
		ply.Ragdoll(open: true);
		ply.StartCoroutine(OnDeath());
	}

	private IEnumerator OnDeath()
	{
		yield return new WaitForSeconds(3f);
		if (!deadFlashAction || ((bool)deadFlashAction && !deadFlashAction.isRuning))
		{
			if (ply.bNeedBulletTime)
			{
				Time.timeScale = 1f;
			}
			ply.GetDropItem();
			VRGlobal.pushFreeEntity(ply.gameObject);
		}
	}

	public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		if (!ply || !(ply.CurHP <= 0f))
		{
			return;
		}
		AnimatorStateInfo currentAnimatorStateInfo = animator.GetCurrentAnimatorStateInfo(0);
		if (currentAnimatorStateInfo.IsName("dead") && currentAnimatorStateInfo.normalizedTime >= 1f && (!deadFlashAction || ((bool)deadFlashAction && !deadFlashAction.isRuning)))
		{
			if (ply.bNeedBulletTime)
			{
				Time.timeScale = 1f;
			}
			ply.GetDropItem();
			VRGlobal.pushFreeEntity(ply.gameObject);
		}
	}
}
public class VRSMBLandDodge : StateMachineBehaviour
{
	private VRMonster ply;

	public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		ply = animator.gameObject.GetComponent<VRMonster>();
		ply.AnimatorClear();
		ply.StopFindPath();
	}

	public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
	}

	public override void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
	}
}
public class VRSMBLandInjure : StateMachineBehaviour
{
	private VRMonster ply;

	public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		ply = animator.gameObject.GetComponent<VRMonster>();
		ply.AnimatorClear();
		ply.StopFindPath();
	}
}
public class VRSMBLandRun : StateMachineBehaviour
{
	private VRMonster ply;

	public GameObject shoutSound;

	public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		ply = animator.gameObject.GetComponent<VRMonster>();
		ply.AnimatorClear();
		ply.SetFindPathDestination();
	}

	public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		if (animator.speed != ply.MoveSpeed)
		{
			animator.speed = ply.MoveSpeed;
		}
		if (!ply)
		{
			return;
		}
		if (ply.Target.CurHP <= 0f)
		{
			ply.FindTarget();
			ply.SetFindPathDestination();
		}
		if (ply.CheckReachTarget())
		{
			VRBlink component = ply.GetComponent<VRBlink>();
			if ((bool)component)
			{
				component.Show();
				component.enabled = false;
			}
			animator.SetBool("attack", value: true);
			return;
		}
		switch (VRUtility.RandomChoose(new float[4] { 900f, 1f, 1f, 2f }))
		{
		case 1:
			animator.SetBool("run", value: false);
			break;
		case 2:
			animator.SetBool("dodge", value: true);
			break;
		case 3:
			ply.SoundPlay(shoutSound);
			break;
		case 0:
			break;
		}
	}

	public override void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		animator.speed = 1f;
	}
}
public class VRSMBLandShow : StateMachineBehaviour
{
	private VRMonster ply;

	public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		ply = animator.gameObject.GetComponent<VRMonster>();
		if ((bool)ply)
		{
			ply.AnimatorClear();
		}
	}

	public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
	}
}
public class VRSMBLandStand : StateMachineBehaviour
{
	private VRMonster ply;

	public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		ply = animator.gameObject.GetComponent<VRMonster>();
		if ((bool)ply)
		{
			ply.AnimatorClear();
			if (ply.InitShow)
			{
				animator.SetBool("show", value: true);
				ply.InitShow = false;
			}
		}
	}

	public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		if (!ply)
		{
			return;
		}
		if (ply.CheckReachTarget())
		{
			animator.SetBool("attack", value: true);
			return;
		}
		switch (VRUtility.RandomChoose(new float[3] { 900f, 100f, 1f }))
		{
		case 1:
			animator.SetBool("run", value: true);
			break;
		case 2:
			animator.SetBool("dodge", value: true);
			break;
		case 0:
			break;
		}
	}
}
public class VRSMBShuiJingBengTa : StateMachineBehaviour
{
	public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		animator.SetBool("posui", value: false);
	}

	public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
	}
}
public class VRSMBShuiJingPoSui : StateMachineBehaviour
{
	public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		if (VRGlobal.G_GameSystem.Gate.CurHP <= 0f)
		{
			animator.SetBool("posui", value: false);
			animator.SetBool("bengta", value: true);
		}
	}
}
public class VRSMBShuiJingYunZhuan : StateMachineBehaviour
{
	public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		if (VRGlobal.G_GameSystem.Gate.CurHP < VRGlobal.G_GameSystem.Gate.Hp * 0.5f)
		{
			animator.SetBool("posui", value: true);
		}
	}
}
public class KMLobbyPanel : MonoBehaviourPunCallbacks, IPunObservable
{
	public Text test;

	public UIRoomPanel roomPanel;

	public GameObject randomBtn;

	public KMRoomSlot roomSlot;

	public Transform slotParent;

	private List<KMRoomSlot> slots = new List<KMRoomSlot>();

	private Dictionary<string, RoomInfo> rooms = new Dictionary<string, RoomInfo>();

	private bool isJoinLobby;

	public bool IsShow => base.gameObject.activeSelf;

	private void Update()
	{
		if (isJoinLobby && !PhotonNetwork.InLobby && PhotonNetwork.IsConnectedAndReady)
		{
			isJoinLobby = false;
			PhotonNetwork.JoinLobby();
		}
		if (!PhotonNetwork.IsConnected)
		{
			Hide(isDisConnect: true);
		}
	}

	public override void OnJoinedLobby()
	{
		UnityEngine.Debug.Log("进入游戏大厅");
		test.text = "进入游戏大厅";
		rooms.Clear();
		PhotonNetwork.GetCustomRoomList(PhotonNetwork.CurrentLobby, null);
	}

	public void Show()
	{
		rooms.Clear();
		OnRoomListUpdate(new List<RoomInfo>());
		isJoinLobby = !PhotonNetwork.InLobby;
		base.gameObject.SetActive(value: true);
	}

	public void Hide(bool isDisConnect)
	{
		if (isDisConnect && PhotonNetwork.IsConnected)
		{
			if (PhotonNetwork.InRoom)
			{
				PhotonNetwork.LeaveRoom();
			}
			if (PhotonNetwork.InLobby)
			{
				PhotonNetwork.LeaveLobby();
			}
			PhotonNetwork.Disconnect();
		}
		for (int i = 0; i < slots.Count; i++)
		{
			if (slots[i] == null)
			{
				slots.RemoveAt(i);
				i--;
				continue;
			}
			if (slots.Count == 0)
			{
				break;
			}
			slots[i].Hide();
		}
		base.gameObject.SetActive(value: false);
	}

	public void CreatRoom()
	{
		int num = 1;
		for (int i = 0; i < rooms.Count; i++)
		{
			string key = "Room_" + num;
			if (!rooms.ContainsKey(key))
			{
				break;
			}
			num++;
		}
		string text = "Room_" + num;
		test.text = "准备加入" + text + "房间";
		PhotonNetwork.JoinOrCreateRoom(text, new RoomOptions
		{
			MaxPlayers = 2
		}, null);
	}

	public void RandomJoinRoom()
	{
		if (rooms.Count > 0)
		{
			string text = "";
			int num = UnityEngine.Random.Range(0, rooms.Count);
			foreach (string key in rooms.Keys)
			{
				if (num == 0)
				{
					text = key;
					break;
				}
				num--;
			}
			if (!string.IsNullOrWhiteSpace(text))
			{
				PhotonNetwork.JoinOrCreateRoom(text, new RoomOptions
				{
					MaxPlayers = 2
				}, null);
			}
			else
			{
				PhotonNetwork.JoinRandomRoom();
			}
		}
		else
		{
			PhotonNetwork.JoinRandomRoom();
		}
	}

	public override void OnJoinedRoom()
	{
		UnityEngine.Debug.Log("进入游戏房间");
		test.text = "进入游戏房间";
		PhotonNetwork.LocalPlayer.SetCustomProperties(new ExitGames.Client.Photon.Hashtable { { "ISDEAD", false } });
		Hide(isDisConnect: false);
		roomPanel.Show();
	}

	public override void OnRoomListUpdate(List<RoomInfo> roomList)
	{
		try
		{
			if ((bool)base.gameObject && !base.gameObject.activeSelf)
			{
				return;
			}
		}
		catch (Exception)
		{
			return;
		}
		for (int i = 0; i < roomList.Count; i++)
		{
			if (roomList[i].PlayerCount == 0 || roomList[i].RemovedFromList)
			{
				if (rooms.ContainsKey(roomList[i].Name))
				{
					rooms.Remove(roomList[i].Name);
				}
			}
			else if (!rooms.ContainsKey(roomList[i].Name))
			{
				rooms.Add(roomList[i].Name, roomList[i]);
			}
			else
			{
				rooms[roomList[i].Name] = roomList[i];
			}
		}
		for (int j = 0; j < slots.Count; j++)
		{
			if (slots[j] == null)
			{
				slots.RemoveAt(j);
				j--;
				continue;
			}
			if (slots.Count == 0)
			{
				break;
			}
			slots[j].Hide();
		}
		bool flag = false;
		foreach (RoomInfo value in rooms.Values)
		{
			if (!flag && value.IsOpen && value.IsVisible && value.PlayerCount < value.MaxPlayers)
			{
				flag = true;
			}
			GetSlot().Show(value);
		}
		randomBtn.gameObject.SetActive(flag);
	}

	private KMRoomSlot GetSlot()
	{
		for (int i = 0; i < slots.Count; i++)
		{
			if (!slots[i].IsShow)
			{
				return slots[i];
			}
		}
		KMRoomSlot kMRoomSlot = UnityEngine.Object.Instantiate(roomSlot, slotParent);
		slots.Add(kMRoomSlot);
		return kMRoomSlot;
	}

	public void OnPhotonSerializeView(PhotonStream stream, PhotonMessageInfo info)
	{
	}
}
public class KMRoomSlot : MonoBehaviour
{
	public Button joinRoomBtn;

	public Text nameText;

	public Text roleAmount;

	public bool IsShow => base.gameObject.activeSelf;

	public RoomInfo curRoom { get; private set; }

	private void Awake()
	{
		joinRoomBtn.onClick.AddListener(JoinRoom);
	}

	private void Update()
	{
		string text = curRoom.Name.Replace("Room", LTLocalization.GetText("Room"));
		nameText.text = text;
		string text2 = LTLocalization.GetText("人数") + ": " + curRoom.PlayerCount + "/" + curRoom.MaxPlayers;
		roleAmount.text = text2;
	}

	private void JoinRoom()
	{
		PhotonNetwork.JoinRoom(curRoom.Name);
	}

	public void Show(RoomInfo room)
	{
		curRoom = room;
		bool active = room.IsOpen && room.IsVisible && room.PlayerCount < room.MaxPlayers;
		joinRoomBtn.gameObject.SetActive(active);
		base.gameObject.SetActive(value: true);
	}

	public void Hide()
	{
		base.gameObject.SetActive(value: false);
	}
}
public class UIRoomPanel : MonoBehaviourPunCallbacks, IPunObservable
{
	public Text test;

	public KMLobbyPanel lobbyPanel;

	public Button startBtn;

	public Text waitMasterStartText;

	public Text roomNameText;

	public Text roleAmountText;

	public bool IsShow => base.gameObject.activeSelf;

	private void Start()
	{
	}

	private void Update()
	{
		string text = "";
		int num = 0;
		Player[] playerList = PhotonNetwork.PlayerList;
		for (int i = 0; i < playerList.Length; i++)
		{
			num++;
			bool isLocal = playerList[i].IsLocal;
			string text2 = Regex.Unescape(LTLocalization.GetText("已准备"));
			text = text + ((num > 1) ? "\n\n" : "") + (isLocal ? "<color=green>" : "") + Regex.Unescape(LTLocalization.GetText("玩家")) + "  " + num + " " + (isLocal ? "</color>" : "") + text2;
		}
		if (num < PhotonNetwork.CurrentRoom.MaxPlayers)
		{
			int num2 = PhotonNetwork.CurrentRoom.MaxPlayers - num;
			for (int j = 0; j < num2; j++)
			{
				num++;
				string text3 = Regex.Unescape(LTLocalization.GetText("待加入"));
				text = text + ((num > 1) ? "\n\n" : "") + Regex.Unescape(LTLocalization.GetText("玩家")) + "  " + num + " " + text3;
			}
		}
		if (PhotonNetwork.IsMasterClient)
		{
			startBtn.gameObject.SetActive(playerList.Length >= PhotonNetwork.CurrentRoom.MaxPlayers);
			if (waitMasterStartText.gameObject.activeSelf)
			{
				waitMasterStartText.gameObject.SetActive(value: false);
			}
		}
		else
		{
			if (startBtn.gameObject.activeSelf)
			{
				startBtn.gameObject.SetActive(value: false);
			}
			if (!waitMasterStartText.gameObject.activeSelf)
			{
				waitMasterStartText.gameObject.SetActive(value: true);
			}
		}
		string text4 = PhotonNetwork.CurrentRoom.Name.Replace("Room", LTLocalization.GetText("Room"));
		roomNameText.text = text4;
		waitMasterStartText.text = Regex.Unescape(LTLocalization.GetText("等待房主开始游戏"));
		roleAmountText.text = text;
	}

	public void Show()
	{
		base.gameObject.SetActive(value: true);
		if (PhotonNetwork.CurrentRoom != null)
		{
			test.text = "进入了" + PhotonNetwork.CurrentRoom.Name + "房间";
		}
		startBtn.gameObject.SetActive(PhotonNetwork.IsMasterClient);
		waitMasterStartText.gameObject.SetActive(!PhotonNetwork.IsMasterClient);
	}

	public void Hide()
	{
		base.gameObject.SetActive(value: false);
	}

	public void OnClickClosePanel()
	{
		if (PhotonNetwork.InRoom)
		{
			PhotonNetwork.LeaveRoom();
		}
	}

	public override void OnLeftRoom()
	{
		UnityEngine.Debug.Log("离开房间");
		test.text = "离开房间";
		base.OnLeftRoom();
		lobbyPanel.Show();
		Hide();
	}

	public void OnClickStartButton()
	{
		PhotonNetwork.CurrentRoom.IsOpen = false;
		VRUIStartMenu_Interactions.Instance.modelPanel.Hide();
		Hide();
		int mDifficulty = (int)VRGlobal.mDifficulty;
		base.photonView.RPC("ReceptionSyncStrMessage", RpcTarget.AllBuffered, mDifficulty);
	}

	[PunRPC]
	public void ReceptionSyncStrMessage(int levelDifficulty)
	{
		VRGameSystem.GameReset(GameModel.GM_Multi, GameState.GS_PreStage);
		VRGlobal.mDifficulty = (DifficultyLevel)levelDifficulty;
		PhotonNetwork.LoadLevel("Level_1_Mult_Plays");
	}

	public void OnPhotonSerializeView(PhotonStream stream, PhotonMessageInfo info)
	{
	}
}
public class UISelectModelPanel : MonoBehaviourPunCallbacks
{
	public GameObject loadUI;

	public GameObject singleUI;

	public GameObject doubleUI;

	public VRUIStartMenu_Interactions uiStartPanel;

	public KMLobbyPanel lobbyPanel;

	public bool IsShow => base.gameObject.activeSelf;

	public void Show()
	{
		singleUI.SetActive(value: true);
		doubleUI.SetActive(value: true);
		loadUI.SetActive(value: false);
		base.gameObject.SetActive(value: true);
		lobbyPanel.Hide(isDisConnect: true);
	}

	public void Hide()
	{
		singleUI.SetActive(value: false);
		doubleUI.SetActive(value: false);
		loadUI.SetActive(value: false);
		base.gameObject.SetActive(value: false);
	}

	public void OnClickCloseButton()
	{
		if (PhotonNetwork.IsConnected)
		{
			if (PhotonNetwork.InRoom)
			{
				PhotonNetwork.LeaveRoom();
			}
			if (PhotonNetwork.InLobby)
			{
				PhotonNetwork.LeaveLobby();
			}
			PhotonNetwork.Disconnect();
		}
		Hide();
	}

	public void OnClickSinglePlay()
	{
		if (PhotonNetwork.IsConnected)
		{
			PhotonNetwork.Disconnect();
		}
		uiStartPanel.SingleGameStart();
	}

	public void OnClickDoublePlay()
	{
		if (PhotonNetwork.IsConnected)
		{
			if (PhotonNetwork.InRoom)
			{
				PhotonNetwork.LeaveRoom();
			}
			if (PhotonNetwork.InLobby)
			{
				PhotonNetwork.LeaveLobby();
			}
			PhotonNetwork.Disconnect();
		}
		PhotonNetwork.ConnectUsingSettings();
		singleUI.SetActive(value: false);
		doubleUI.SetActive(value: false);
		loadUI.SetActive(value: true);
	}

	public override void OnConnectedToMaster()
	{
		base.OnConnectedToMaster();
		UnityEngine.Debug.Log("连接到服务器");
		Hide();
		lobbyPanel.Show();
	}
}
public class VRMainMenuBtn : MonoBehaviour
{
	private Text text;

	public int fontSize = 30;

	public string massage;

	private void Awake()
	{
		text = GetComponent<Text>();
		text.fontSize = fontSize;
	}

	private void Update()
	{
		text.text = LTLocalization.GetText(massage);
	}
}
public class VRPersistance : MonoBehaviour
{
	private void Awake()
	{
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
	}
}
public class VRRetryButton : MonoBehaviour
{
	private Text text;

	public int fontSize = 30;

	private void Start()
	{
		text = GetComponent<Text>();
		text.fontSize = fontSize;
		text.text = LTLocalization.GetText("返回主菜单");
		if (VRGameSystem.CurGameState != GameState.GS_Fail)
		{
			return;
		}
		for (int i = 0; i < UnityXR_Controller.Instance.HandleSys.GetTransform(XRDeviceType.DT_Right).childCount; i++)
		{
			Transform child = UnityXR_Controller.Instance.HandleSys.GetTransform(XRDeviceType.DT_Right).GetChild(i);
			if ((bool)child && child.tag == "GameOverTip")
			{
				child.gameObject.SetActive(value: true);
			}
		}
	}
}
public class VRUIManager : MonoBehaviour
{
	public PhotonView photonview;

	public GameObject rankingList;

	public GameObject[] OpenRankingListCloseObj;

	public GameObject closeBtn;

	public Text OpenRankingListCloseCom;

	[Space]
	public GameObject frams;

	public GameObject stageShow;

	public GameObject TipsShow;

	public GameObject gamePausePanel;

	public GameObject gameOverPanel;

	public GameObject BossWarning;

	public GameObjectInt[] stateObjects;

	private float fTipsDuration = 1f;

	private void Start()
	{
		OpenRankingList(isOpen: false);
		if (VRGameSystem.CurGameState == GameState.GS_Finish || VRGameSystem.CurGameState == GameState.GS_End)
		{
			VRGameSystem.CurGameState = GameState.GS_PreStage;
		}
		if (stageShow.activeSelf)
		{
			stageShow.SetActive(value: false);
		}
		if (TipsShow.activeSelf)
		{
			TipsShow.SetActive(value: false);
		}
		if (gamePausePanel.activeSelf)
		{
			gamePausePanel.SetActive(value: false);
		}
		if (gameOverPanel.activeSelf)
		{
			gameOverPanel.SetActive(value: false);
		}
		if (BossWarning.activeSelf)
		{
			BossWarning.SetActive(value: false);
		}
	}

	public void ShowFrames(bool bShow = true)
	{
		if ((bool)frams)
		{
			frams.SetActive(bShow);
		}
	}

	public void ShowStage(bool bShow, int nStageIndex = 0)
	{
		if (!stageShow)
		{
			return;
		}
		stageShow.SetActive(bShow);
		if (bShow)
		{
			stageShow.GetComponent<VRUIStageShow>().nStageIndex = nStageIndex;
		}
		if (stateObjects != null)
		{
			for (int i = 0; i < stateObjects.Length; i++)
			{
				stateObjects[i].go.SetActive(stateObjects[i].index == nStageIndex);
			}
		}
	}

	public void ShowBossWarning()
	{
		BossWarning.SetActive(value: true);
		Invoke("SpawnBoss", 3f);
		Invoke("HideBossWarning", 5f);
	}

	public void HideBossWarning()
	{
		BossWarning.SetActive(value: false);
	}

	private void SpawnBoss()
	{
		VRGlobal.G_GameSystem.CurCheckPoint.CurTrigger.SpawnBoss();
	}

	public void ShowTips(bool bShow, string textcontext = "", bool bAutoClose = true)
	{
		if ((bool)TipsShow)
		{
			TipsShow.SetActive(bShow);
			if (bShow)
			{
				TipsShow.GetComponent<VRUITips>().TextContext = textcontext;
			}
		}
		if (bShow && bAutoClose)
		{
			Invoke("CloseTips", fTipsDuration);
		}
	}

	public void CloseTips()
	{
		if ((bool)TipsShow)
		{
			ShowTips(bShow: false);
		}
	}

	public void ShowPanel(int index, bool isShow)
	{
		if (rankingList.activeSelf)
		{
			isShow = false;
		}
		if ((index == 0 || index == 1) && gamePausePanel.activeSelf != isShow)
		{
			gamePausePanel.SetActive(isShow);
		}
		if ((index == 0 || index == 2) && gameOverPanel.activeSelf != isShow)
		{
			gameOverPanel.SetActive(isShow);
		}
	}

	public void OnClickBackMainScene()
	{
		if (VRGameSystem.CurGameModel == GameModel.GM_Single)
		{
			backMainScene();
		}
		else if (VRGameSystem.CurGameModel == GameModel.GM_Multi)
		{
			photonview.RPC("backMainScene", RpcTarget.All);
		}
	}

	[PunRPC]
	private void backMainScene()
	{
		VRGameSystem.CurGameState = GameState.GS_NeebieGuide;
		SceneManager.LoadScene(0);
	}

	public void OnClickContinueGame()
	{
		if (VRGameSystem.CurGameModel == GameModel.GM_Single)
		{
			continueGame();
		}
		else if (VRGameSystem.CurGameModel == GameModel.GM_Multi)
		{
			photonview.RPC("continueGame", RpcTarget.All);
		}
	}

	[PunRPC]
	private void continueGame()
	{
		if (TipsShow.activeSelf)
		{
			TipsShow.SetActive(value: false);
		}
		if (VRGlobal.G_GameSystem.isPause)
		{
			VRGlobal.G_GameSystem.OnGameContinue();
		}
	}

	public void OnClickRetryGame()
	{
		if (VRGameSystem.CurGameModel == GameModel.GM_Single)
		{
			VRGameSystem.GameReset(GameModel.GM_Single, GameState.GS_PreStage);
			SceneManager.LoadScene(1);
		}
		else if (VRGameSystem.CurGameModel == GameModel.GM_Multi)
		{
			photonview.RPC("retryGame", RpcTarget.All);
		}
	}

	[PunRPC]
	private void retryGame()
	{
		foreach (Player value in PhotonNetwork.CurrentRoom.Players.Values)
		{
			if ((bool)value.CustomProperties["ISDEAD"])
			{
				ExitGames.Client.Photon.Hashtable propertiesToSet = new ExitGames.Client.Photon.Hashtable { { "ISDEAD", false } };
				value.SetCustomProperties(propertiesToSet);
			}
		}
		VRGameSystem.GameReset(GameModel.GM_Multi, GameState.GS_PreStage);
		PhotonNetwork.LoadLevel("Level_1_Mult_Plays");
	}

	public void OpenRankingList(bool isOpen)
	{
		if (isOpen)
		{
			rankingList.SetActive(value: true);
			for (int i = 0; i < OpenRankingListCloseObj.Length; i++)
			{
				OpenRankingListCloseObj[i].SetActive(value: false);
			}
			closeBtn.SetActive(value: true);
			OpenRankingListCloseCom.enabled = false;
		}
		else
		{
			rankingList.SetActive(value: false);
			for (int j = 0; j < OpenRankingListCloseObj.Length; j++)
			{
				OpenRankingListCloseObj[j].SetActive(value: true);
			}
			closeBtn.SetActive(value: false);
			OpenRankingListCloseCom.enabled = true;
		}
	}

	public void ExitGame()
	{
		Application.Quit();
	}
}
public class VRUIPlayerInfoUI : MonoBehaviour
{
	public int id;

	public Text rankingText;

	public Text nameText;

	public Text scoreText;

	private void Update()
	{
		if (id.Equals(1000))
		{
			rankingText.color = Color.yellow;
			nameText.color = Color.yellow;
			scoreText.color = Color.yellow;
		}
		else
		{
			rankingText.color = Color.white;
			nameText.color = Color.white;
			scoreText.color = Color.white;
		}
	}
}
public class VRUIScoreList : MonoBehaviour
{
	public VRUIPlayerInfoUI[] scoreUIs;

	public Transform scoreUIParent;

	private void OnEnable()
	{
		AddRanking();
	}

	private void AddRanking()
	{
		while (scoreUIs.Length < PlayerData.Instance.playerField.GetLenght())
		{
			VRUIPlayerInfoUI component = UnityEngine.Object.Instantiate(scoreUIs[0].gameObject, scoreUIParent).GetComponent<VRUIPlayerInfoUI>();
			Array.Resize(ref scoreUIs, scoreUIs.Length + 1);
			scoreUIs[scoreUIs.Length - 1] = component;
		}
		for (int i = 0; i < scoreUIs.Length; i++)
		{
			scoreUIs[i].id = PlayerData.Instance.playerField.Id[i];
			scoreUIs[i].nameText.text = PlayerData.Instance.playerField.Name[i];
			scoreUIs[i].scoreText.text = PlayerData.Instance.playerField.Score[i].ToString();
		}
		UpdateSort();
	}

	private void UpdateSort()
	{
		PlayerData.Instance.playerField.Sort();
		for (int i = 0; i < scoreUIs.Length; i++)
		{
			int index = PlayerData.Instance.playerField.GetIndex(scoreUIs[i].id);
			scoreUIs[i].transform.SetSiblingIndex(index);
			if (index + 1 == scoreUIs.Length)
			{
				if (scoreUIs[i].id.Equals(1000))
				{
					scoreUIs[i].rankingText.text = ">10";
					scoreUIs[i].gameObject.SetActive(value: true);
				}
				else
				{
					scoreUIs[i].gameObject.SetActive(value: false);
				}
			}
			else
			{
				scoreUIs[i].rankingText.text = (index + 1).ToString();
				scoreUIs[i].gameObject.SetActive(value: true);
			}
		}
	}
}
public class VRUIStageShow : MonoBehaviour
{
	private Text text;

	public int fontSize = 32;

	public int nStageIndex = 1;

	public int StageIndex
	{
		get
		{
			return nStageIndex;
		}
		set
		{
			nStageIndex = value;
		}
	}

	private void Start()
	{
		text = GetComponent<Text>();
		text.fontSize = fontSize;
	}

	private void Update()
	{
		text.text = LTLocalization.GetText("关卡") + " " + nStageIndex;
	}
}
public class VRUIStartMenu_Interactions : MonoBehaviour
{
	public UISelectModelPanel modelPanel;

	public KMLobbyPanel lobbyPanel;

	public UIRoomPanel roomPanel;

	public ScreenFader screenFader;

	public Toggle tutorialToggle;

	public Text tutorialText;

	public Button startButton;

	public Dropdown languageDropDown;

	public Dropdown modeDropDown;

	public Dropdown difficultyDropDown;

	public Dropdown chooseLevelDropDown;

	public GameObject difficultyObject;

	public Text exit;

	public Text option;

	public Text paihangbang;

	public Text paihang;

	public Text xingming;

	public Text fenshu;

	public Toggle toggleChinese;

	public Toggle toggleEnglish;

	public GameObject optionPanel;

	public UnityXR_RayInteractableCollider interactableCollider;

	private string StartText = "开始游戏";

	private string ModeText_1 = "塔防模式";

	private string ModeText_2 = "无尽模式";

	private string DifficultyText_1 = "简单";

	private string DifficultyText_2 = "困难";

	private string LevelText_1 = "第一章";

	private string curChooseLeve;

	private List<string> DropDownModeTests = new List<string>();

	private List<string> DropDownLanguageTests = new List<string>();

	private List<string> DropDownDifficultyTests = new List<string>();

	private List<string> DroDownChooseLevelTests = new List<string>();

	private bool isOpenDifficulty;

	private static bool isOnePlay = true;

	public static VRUIStartMenu_Interactions Instance { get; private set; }

	private void Awake()
	{
		Instance = this;
		if (VRGameSystem.bIsFirstPlay && isOnePlay)
		{
			VRGlobal.G_Language = Application.systemLanguage;
			isOnePlay = false;
		}
		isOpenDifficulty = bool.Parse(PlayerPrefs.GetString("difficulty", "false"));
		tutorialToggle.onValueChanged.AddListener(delegate(bool isOn)
		{
			VRGlobal.IsOpenTutorial = isOn;
		});
	}

	private void Start()
	{
		tutorialToggle.isOn = VRGlobal.IsOpenTutorial;
		DropDownLanguageTests.Add(GetLanguageString(SystemLanguage.Chinese));
		DropDownLanguageTests.Add(GetLanguageString(SystemLanguage.English));
		DropDownLanguageTests.Add(GetLanguageString(SystemLanguage.ChineseTraditional));
		DropDownLanguageTests.Add(GetLanguageString(SystemLanguage.Japanese));
		DropDownLanguageTests.Add(GetLanguageString(SystemLanguage.German));
		DropDownLanguageTests.Add(GetLanguageString(SystemLanguage.French));
		DropDownLanguageTests.Add(GetLanguageString(SystemLanguage.Spanish));
		DropDownLanguageTests.Add(GetLanguageString(SystemLanguage.Italian));
		DropDownLanguageTests.Add(GetLanguageString(SystemLanguage.Russian));
		DropDownModeTests.Add(ModeText_1);
		DropDownModeTests.Add(ModeText_2);
		DropDownDifficultyTests.Add(DifficultyText_1);
		DropDownDifficultyTests.Add(DifficultyText_2);
		DroDownChooseLevelTests.Add(LevelText_1);
		switch (VRGlobal.G_Language)
		{
		case SystemLanguage.Chinese:
			if ((bool)toggleChinese)
			{
				toggleChinese.isOn = true;
			}
			if ((bool)toggleEnglish)
			{
				toggleEnglish.isOn = false;
			}
			break;
		case SystemLanguage.English:
			if ((bool)toggleChinese)
			{
				toggleChinese.isOn = false;
			}
			if ((bool)toggleEnglish)
			{
				toggleEnglish.isOn = true;
			}
			break;
		}
		InitMenu();
		optionPanel.SetActive(value: false);
		languageDropDown.onValueChanged.AddListener(Dropdown_Language);
		UnityXR_Controller.Instance.HandleSys.RayActive(XRDeviceType.DT_Left, isShow: false);
		roomPanel.Hide();
		lobbyPanel.Hide(isDisConnect: true);
		modelPanel.Hide();
	}

	public void InitMenu()
	{
		UpdateMenu();
		languageDropDown.ClearOptions();
		languageDropDown.AddOptions(DropDownLanguageTests);
		modeDropDown.ClearOptions();
		modeDropDown.AddOptions(DropDownModeTests);
		if (VRGlobal.G_Language == SystemLanguage.Chinese)
		{
			languageDropDown.value = 0;
		}
		else if (VRGlobal.G_Language == SystemLanguage.English)
		{
			languageDropDown.value = 1;
		}
		else if (VRGlobal.G_Language == SystemLanguage.ChineseTraditional)
		{
			languageDropDown.value = 2;
		}
		else if (VRGlobal.G_Language == SystemLanguage.Japanese)
		{
			languageDropDown.value = 3;
		}
		else if (VRGlobal.G_Language == SystemLanguage.German)
		{
			languageDropDown.value = 4;
		}
		else if (VRGlobal.G_Language == SystemLanguage.French)
		{
			languageDropDown.value = 5;
		}
		else if (VRGlobal.G_Language == SystemLanguage.Spanish)
		{
			languageDropDown.value = 6;
		}
		else if (VRGlobal.G_Language == SystemLanguage.Italian)
		{
			languageDropDown.value = 7;
		}
		else if (VRGlobal.G_Language == SystemLanguage.Russian)
		{
			languageDropDown.value = 8;
		}
		if (VRGlobal.mDifficulty == DifficultyLevel.DL_Easy)
		{
			difficultyDropDown.value = 0;
		}
		else if (VRGlobal.mDifficulty == DifficultyLevel.DL_Difficult)
		{
			difficultyDropDown.value = 1;
		}
	}

	public void UpdateMenu()
	{
		LTLocalization.ManualSetLanguage(VRGlobal.G_Language);
		startButton.GetComponentInChildren<Text>().text = Regex.Unescape(LTLocalization.GetText(StartText));
		exit.text = Regex.Unescape(LTLocalization.GetText("离开"));
		option.text = Regex.Unescape(LTLocalization.GetText("选项"));
		paihangbang.text = Regex.Unescape(LTLocalization.GetText("排行榜"));
		paihang.text = Regex.Unescape(LTLocalization.GetText("排行"));
		xingming.text = Regex.Unescape(LTLocalization.GetText("姓名"));
		fenshu.text = Regex.Unescape(LTLocalization.GetText("分数"));
		DropDownDifficultyTests.Clear();
		DropDownDifficultyTests.Add(Regex.Unescape(LTLocalization.GetText(DifficultyText_1)));
		if (isOpenDifficulty)
		{
			DropDownDifficultyTests.Add(Regex.Unescape(LTLocalization.GetText(DifficultyText_2)));
		}
		difficultyObject.SetActive(!isOpenDifficulty);
		difficultyDropDown.ClearOptions();
		difficultyDropDown.AddOptions(DropDownDifficultyTests);
		DroDownChooseLevelTests.Clear();
		DroDownChooseLevelTests.Add(LevelText_1);
		chooseLevelDropDown.ClearOptions();
		chooseLevelDropDown.AddOptions(DroDownChooseLevelTests);
		tutorialText.text = Regex.Unescape(LTLocalization.GetText("新手教程(单机)"));
	}

	public void Button_StartGame()
	{
		modelPanel.Show();
	}

	public void SingleGameStart()
	{
		GameState initState = ((!VRGlobal.IsOpenTutorial) ? GameState.GS_PreStage : GameState.GS_NeebieGuide);
		VRGameSystem.GameReset(GameModel.GM_Single, initState);
		if (curChooseLeve == null)
		{
			SceneManager.LoadScene("Level_1");
			StartCoroutine("LoadScene", "Level_1");
		}
		else
		{
			SceneManager.LoadScene(curChooseLeve);
			StartCoroutine("LoadScene", curChooseLeve);
		}
	}

	private IEnumerator LoadScene(string sceneName)
	{
		screenFader.fadeIn = false;
		yield return new WaitForSeconds(screenFader.fadeTime);
		SceneManager.LoadScene(sceneName);
		screenFader.fadeIn = true;
		yield return new WaitForSeconds(screenFader.fadeTime);
	}

	public void Dropdown_Language(int value)
	{
		SystemLanguage systemLanguage = SystemLanguage.Unknown;
		switch (value)
		{
		case 0:
			systemLanguage = SystemLanguage.ChineseSimplified;
			break;
		case 1:
			systemLanguage = SystemLanguage.English;
			break;
		case 2:
			systemLanguage = SystemLanguage.ChineseTraditional;
			break;
		case 3:
			systemLanguage = SystemLanguage.Japanese;
			break;
		case 4:
			systemLanguage = SystemLanguage.German;
			break;
		case 5:
			systemLanguage = SystemLanguage.French;
			break;
		case 6:
			systemLanguage = SystemLanguage.Spanish;
			break;
		case 7:
			systemLanguage = SystemLanguage.Italian;
			break;
		case 8:
			systemLanguage = SystemLanguage.Russian;
			break;
		}
		if (VRGlobal.G_Language != systemLanguage)
		{
			VRGlobal.G_Language = systemLanguage;
			UpdateMenu();
		}
	}

	public void Dropdown_DifficultyLevel()
	{
		switch (difficultyDropDown.value)
		{
		case 0:
			VRGlobal.mDifficulty = DifficultyLevel.DL_Easy;
			break;
		case 1:
			VRGlobal.mDifficulty = DifficultyLevel.DL_Difficult;
			break;
		}
	}

	public void Dropdown_Mode(int value)
	{
	}

	public void DropDown_Level()
	{
		switch (chooseLevelDropDown.value)
		{
		case 0:
			curChooseLeve = "Level_1";
			break;
		case 1:
			curChooseLeve = "Level_2";
			break;
		}
	}

	public void ChooseChinese()
	{
		if ((bool)toggleChinese && toggleChinese.isOn)
		{
			VRGlobal.G_Language = SystemLanguage.Chinese;
			UpdateMenu();
		}
	}

	public void ChooseEnglish()
	{
		if ((bool)toggleEnglish && toggleEnglish.isOn)
		{
			VRGlobal.G_Language = SystemLanguage.English;
			UpdateMenu();
		}
	}

	private string GetLanguageString(SystemLanguage language)
	{
		return language switch
		{
			SystemLanguage.Afrikaans => "Afrikaans", 
			SystemLanguage.Arabic => "Arabic", 
			SystemLanguage.Basque => "Basque", 
			SystemLanguage.Belarusian => "Belarusian", 
			SystemLanguage.Bulgarian => "Bulgarian", 
			SystemLanguage.Catalan => "Catalan", 
			SystemLanguage.Chinese => "简体中文", 
			SystemLanguage.Czech => "Czech", 
			SystemLanguage.Danish => "Danish", 
			SystemLanguage.Dutch => "Dutch", 
			SystemLanguage.English => "English", 
			SystemLanguage.Estonian => "Estonian", 
			SystemLanguage.Faroese => "Faroese", 
			SystemLanguage.Finnish => "Finnish", 
			SystemLanguage.French => "Français", 
			SystemLanguage.German => "Deutsch", 
			SystemLanguage.Greek => "Greek", 
			SystemLanguage.Hebrew => "Hebrew", 
			SystemLanguage.Hungarian => "Hungarian", 
			SystemLanguage.Icelandic => "Icelandic", 
			SystemLanguage.Indonesian => "Indonesian", 
			SystemLanguage.Italian => "In Italiano", 
			SystemLanguage.Japanese => "日本語", 
			SystemLanguage.Korean => "Korean", 
			SystemLanguage.Latvian => "Latvian", 
			SystemLanguage.Lithuanian => "Lithuanian", 
			SystemLanguage.Norwegian => "Norwegian", 
			SystemLanguage.Polish => "Polish", 
			SystemLanguage.Portuguese => "Portuguese", 
			SystemLanguage.Romanian => "Romanian", 
			SystemLanguage.Russian => "русский", 
			SystemLanguage.SerboCroatian => "SerboCroatian", 
			SystemLanguage.Slovak => "Slovak", 
			SystemLanguage.Slovenian => "Slovenian", 
			SystemLanguage.Spanish => "El español", 
			SystemLanguage.Swedish => "Swedish", 
			SystemLanguage.Thai => "Thai", 
			SystemLanguage.Turkish => "Turkish", 
			SystemLanguage.Ukrainian => "Ukrainian", 
			SystemLanguage.Vietnamese => "Vietnamese", 
			SystemLanguage.ChineseSimplified => "简体中文", 
			SystemLanguage.ChineseTraditional => "繁體中文", 
			SystemLanguage.Unknown => "", 
			_ => null, 
		};
	}

	public void OpenOptionPanel()
	{
		optionPanel.SetActive(value: true);
	}

	public void CloseOptionPanel()
	{
		optionPanel.SetActive(value: false);
	}

	public void ExitGame()
	{
		Application.Quit();
	}

	public void SaveDataToScripteObject(ref LocalizationScript localizationScript, LTLocalizationData languageData)
	{
		switch (LTLocalization.GetLanguageAB(languageData.LanguageType))
		{
		case SystemLanguage.English:
			SetData(ref localizationScript.ENData, languageData.LanguageData);
			break;
		case SystemLanguage.ChineseSimplified:
			SetData(ref localizationScript.CNData, languageData.LanguageData);
			break;
		case SystemLanguage.ChineseTraditional:
			SetData(ref localizationScript.TWData, languageData.LanguageData);
			break;
		case SystemLanguage.Japanese:
			SetData(ref localizationScript.JPData, languageData.LanguageData);
			break;
		case SystemLanguage.French:
			SetData(ref localizationScript.FRData, languageData.LanguageData);
			break;
		case SystemLanguage.German:
			SetData(ref localizationScript.GEData, languageData.LanguageData);
			break;
		case SystemLanguage.Italian:
			SetData(ref localizationScript.ITData, languageData.LanguageData);
			break;
		case SystemLanguage.Korean:
			SetData(ref localizationScript.ENData, languageData.LanguageData);
			break;
		case SystemLanguage.Russian:
			SetData(ref localizationScript.RUData, languageData.LanguageData);
			break;
		case SystemLanguage.Spanish:
			SetData(ref localizationScript.SPData, languageData.LanguageData);
			break;
		}
	}

	private void SetData(ref List<DicStruct> data, Dictionary<string, string> valuePairs)
	{
		data = new List<DicStruct>();
		foreach (string key in valuePairs.Keys)
		{
			data.Add(new DicStruct(key, valuePairs[key]));
		}
	}

	private void Update()
	{
		if (modelPanel.IsShow || lobbyPanel.IsShow || roomPanel.IsShow)
		{
			interactableCollider.enabled = false;
		}
		else
		{
			interactableCollider.enabled = true;
		}
	}

	private void OnDestroy()
	{
		Instance = null;
	}
}
public class VRUITips : MonoBehaviour
{
	private Text text;

	public int fontSize = 32;

	private string textContext = "";

	public GameObject rankingList;

	public string TextContext
	{
		get
		{
			return textContext;
		}
		set
		{
			textContext = value;
		}
	}

	private void Start()
	{
		text = GetComponent<Text>();
		text.fontSize = fontSize;
	}

	private void OnEnable()
	{
		if (VRGlobal.G_GameSystem != null && (VRGameSystem.CurGameState == GameState.GS_End || VRGameSystem.CurGameState == GameState.GS_Fail || VRGameSystem.CurGameState == GameState.GS_Finish))
		{
			PlayerData.Instance.playerField[1000] = PlayerData.Instance.playerField[1000] + VRGlobal.G_GameSystem.GainScore;
		}
	}

	private void Update()
	{
		if (textContext != text.text)
		{
			text.text = textContext;
		}
	}
}
public class LTCSVLoader
{
	private TextReader inStream;

	private List<string> vContent;

	private List<List<string>> table;

	public void ReadFile(string fileName)
	{
		inStream = new StreamReader(fileName, Encoding.GetEncoding("GBK"));
		table = new List<List<string>>();
		for (List<string> lineContentVector = getLineContentVector(); lineContentVector != null; lineContentVector = getLineContentVector())
		{
			List<string> list = new List<string>();
			for (int i = 0; i < lineContentVector.Count; i++)
			{
				list.Add(lineContentVector[i]);
			}
			table.Add(list);
		}
	}

	public void ReadMultiLine(string str)
	{
		inStream = new StringReader(str);
		table = new List<List<string>>();
		for (List<string> lineContentVector = getLineContentVector(); lineContentVector != null; lineContentVector = getLineContentVector())
		{
			List<string> list = new List<string>();
			for (int i = 0; i < lineContentVector.Count; i++)
			{
				list.Add(lineContentVector[i]);
			}
			table.Add(list);
		}
	}

	private int containsNumber(string parentStr, string parameter)
	{
		int num = 0;
		if (parentStr == null || parentStr.Equals(""))
		{
			return 0;
		}
		if (parameter == null || parameter.Equals(""))
		{
			return 0;
		}
		int num2;
		for (num2 = 0; num2 < parentStr.Length; num2++)
		{
			num2 = parentStr.IndexOf(parameter, num2);
			if (num2 <= -1)
			{
				break;
			}
			num2 += parameter.Length;
			num2--;
			num++;
		}
		return num;
	}

	private bool isQuoteAdjacent(string p_String)
	{
		bool result = false;
		if (p_String.Replace("\"\"", "").IndexOf("\"") == -1)
		{
			result = true;
		}
		return result;
	}

	private bool isQuoteContained(string p_String)
	{
		bool result = false;
		if (p_String == null || p_String.Equals(""))
		{
			return false;
		}
		if (p_String.IndexOf("\"") > -1)
		{
			result = true;
		}
		return result;
	}

	private string[] readAtomString(string lineStr)
	{
		string text = "";
		string text2 = "";
		string[] array = new string[2];
		bool flag = false;
		string[] array2 = lineStr.Split(',');
		while (!flag)
		{
			string[] array3 = array2;
			foreach (string text3 in array3)
			{
				if (!text.Equals(""))
				{
					text += ",";
				}
				text += text3;
				text2 = text;
				if (!isQuoteContained(text))
				{
					flag = true;
					break;
				}
				if (!text.StartsWith("\""))
				{
					flag = true;
					break;
				}
				if (!text.StartsWith("\""))
				{
					continue;
				}
				if (containsNumber(text, "\"") % 2 == 0)
				{
					string text4 = text;
					if (text4.EndsWith("\""))
					{
						text4 = text4.Replace("\"\"", "");
						if (text4.Equals(""))
						{
							text = "";
							flag = true;
							break;
						}
						text4 = text4.Substring(1, text4.LastIndexOf("\""));
						if (text4.IndexOf("\"") > -1)
						{
							text4 = text;
							text4 = text4.Substring(1);
							text4 = text4.Substring(0, text4.IndexOf("\"")) + text4.Substring(text4.IndexOf("\"") + 1);
							text = text4;
							flag = true;
						}
						else
						{
							text4 = text;
							text4 = text4.Substring(1, text4.LastIndexOf("\""));
							text4 = text4.Replace("\"\"", "\"");
							text = text4;
							flag = true;
						}
					}
					else
					{
						text4 = text4.Substring(1, text4.IndexOf('"', 1)) + text4.Substring(text4.IndexOf('"', 1) + 1);
						text = text4;
						flag = true;
					}
					break;
				}
				if (!text.Equals("\""))
				{
					string p_String = text.Substring(1);
					if (!isQuoteAdjacent(p_String))
					{
						p_String = text.Substring(1);
						int num = p_String.IndexOf("\"");
						p_String = p_String.Substring(0, num) + p_String.Substring(num + 1);
						text = p_String;
						flag = true;
						break;
					}
				}
			}
		}
		lineStr = ((lineStr.Length <= text2.Length) ? "" : lineStr.Substring(text2.Length));
		if (lineStr.StartsWith(","))
		{
			lineStr = ((lineStr.Length <= 1) ? "" : lineStr.Substring(1));
		}
		array[0] = text;
		array[1] = lineStr;
		return array;
	}

	private bool readCSVNextRecord()
	{
		if (inStream == null)
		{
			return false;
		}
		if (vContent == null)
		{
			vContent = new List<string>();
		}
		vContent.Clear();
		string text = "";
		StringBuilder stringBuilder = new StringBuilder();
		bool flag = false;
		while (!flag)
		{
			string text2 = inStream.ReadLine();
			if (text2 == null)
			{
				stringBuilder = null;
				vContent = null;
				flag = true;
				break;
			}
			if (text2.StartsWith("#"))
			{
				continue;
			}
			if (!stringBuilder.ToString().Equals(""))
			{
				stringBuilder.Append("\r\n");
			}
			stringBuilder.Append(text2);
			string text3 = stringBuilder.ToString();
			if (text3.IndexOf(",") == -1)
			{
				if (containsNumber(text3, "\"") % 2 == 0)
				{
					flag = true;
					break;
				}
				if (text3.StartsWith("\"") && !text3.Equals("\""))
				{
					string p_String = text3.Substring(1);
					if (!isQuoteAdjacent(p_String))
					{
						flag = true;
						break;
					}
				}
				continue;
			}
			string text4 = text3.Replace("\"\"", "");
			switch (text4.LastIndexOf("\""))
			{
			case -1:
				flag = true;
				break;
			default:
			{
				text4 = text4.Replace("\",\"", "");
				int num = text4.LastIndexOf("\"");
				if (num == 0 || text4[num - 1] == ',')
				{
					continue;
				}
				flag = true;
				break;
			}
			case 0:
				continue;
			}
			break;
		}
		if (stringBuilder == null)
		{
			return false;
		}
		text = stringBuilder.ToString();
		if (text != null)
		{
			while (!text.Equals(""))
			{
				string[] array = readAtomString(text);
				string item = array[0];
				text = array[1];
				vContent.Add(item);
			}
		}
		return true;
	}

	private List<string> getLineContentVector()
	{
		if (readCSVNextRecord())
		{
			return vContent;
		}
		return null;
	}

	private List<string> getVContent()
	{
		return vContent;
	}

	public int GetRow()
	{
		if (table == null)
		{
			throw new Exception("table尚未初始化,请检查是否成功读取");
		}
		return table.Count;
	}

	public int GetCol()
	{
		if (table == null)
		{
			throw new Exception("table尚未初始化,请检查是否成功读取");
		}
		if (table.Count == 0)
		{
			throw new Exception("table内容为空");
		}
		return table[0].Count;
	}

	public int GetFirstIndexAtCol(string str, int col)
	{
		if (table == null)
		{
			throw new Exception("table尚未初始化,请检查是否成功读取");
		}
		if (table.Count == 0)
		{
			throw new Exception("table内容为空");
		}
		if (col >= table[0].Count)
		{
			throw new Exception("参数错误：col大于最大行");
		}
		for (int i = 0; i < table.Count; i++)
		{
			if (table[i][col].Equals(str))
			{
				return i;
			}
		}
		return -1;
	}

	public int GetFirstIndexAtRow(string str, int row)
	{
		if (table == null)
		{
			throw new Exception("table尚未初始化,请检查是否成功读取");
		}
		if (table.Count == 0)
		{
			throw new Exception("table内容为空");
		}
		if (row >= table.Count)
		{
			throw new Exception("参数错误：cow大于最大列");
		}
		int count = table[0].Count;
		for (int i = 0; i < count; i++)
		{
			if (table[row][i].Equals(str))
			{
				return i;
			}
		}
		return -1;
	}

	public int[] GetIndexsAtCol(string str, int col)
	{
		if (table == null)
		{
			throw new Exception("table尚未初始化,请检查是否成功读取");
		}
		if (table.Count == 0)
		{
			throw new Exception("table内容为空");
		}
		if (col >= table[0].Count)
		{
			throw new Exception("参数错误：col大于最大行");
		}
		List<int> list = new List<int>();
		for (int i = 0; i < table.Count; i++)
		{
			if (table[i][col].Equals(str))
			{
				list.Add(i);
			}
		}
		return list.ToArray();
	}

	public int[] GetIndexsAtRow(string str, int row)
	{
		if (table == null)
		{
			throw new Exception("table尚未初始化,请检查是否成功读取");
		}
		if (table.Count == 0)
		{
			throw new Exception("table内容为空");
		}
		if (row >= table.Count)
		{
			throw new Exception("参数错误：cow大于最大列");
		}
		int count = table[0].Count;
		List<int> list = new List<int>();
		for (int i = 0; i < count; i++)
		{
			if (table[row][i].Equals(str))
			{
				list.Add(i);
			}
		}
		return list.ToArray();
	}

	public string GetValueAt(int col, int row)
	{
		if (table == null)
		{
			throw new Exception("table尚未初始化,请检查是否成功读取");
		}
		if (table.Count == 0)
		{
			throw new Exception("table内容为空");
		}
		if (row >= table.Count)
		{
			throw new Exception("参数错误：row大于最大列");
		}
		if (col >= table[0].Count)
		{
			throw new Exception("参数错误：col大于最大行");
		}
		return table[row][col];
	}
}
public class LTLocalization
{
	public const string LANGUAGE_ENGLISH = "EN";

	public const string LANGUAGE_CHINESE = "CN";

	public const string LANGUAGE_TRADITIONALCHINESE = "TW";

	public const string LANGUAGE_JAPANESE = "JP";

	public const string LANGUAGE_FRENCH = "FR";

	public const string LANGUAGE_GERMAN = "GE";

	public const string LANGUAGE_ITALY = "IT";

	public const string LANGUAGE_KOREA = "KR";

	public const string LANGUAGE_RUSSIA = "RU";

	public const string LANGUAGE_SPANISH = "SP";

	private const string KEY_CODE = "KEY";

	private const string FILE_PATH = "LTLocalization/localization";

	private SystemLanguage language = SystemLanguage.Chinese;

	private Dictionary<string, string> textData = new Dictionary<string, string>();

	private static LTLocalization mInstance;

	private LTLocalization()
	{
	}

	private static string GetWinReadPath(string fileName)
	{
		return Application.dataPath + "/../" + fileName + ".csv";
	}

	private static string GetWinSavePath(string fileName)
	{
		return Application.dataPath + "/_Game/Resources/LTLocalization/" + fileName + ".txt";
	}

	private List<LTLocalizationData> ReadData()
	{
		List<LTLocalizationData> result = new List<LTLocalizationData>();
		try
		{
			TextAsset textAsset = (TextAsset)Resources.Load("LTLocalization/" + GetLanguageAB(language), typeof(TextAsset));
			if (null == textAsset)
			{
				textAsset = (TextAsset)Resources.Load("LTLocalization/EN", typeof(TextAsset));
			}
			if (null == textAsset)
			{
				UnityEngine.Debug.LogError("未检测到语言配置文件");
			}
			else
			{
				LTLocalizationData lTLocalizationData = (LTLocalizationData)SaveHelper.ReadData(textAsset.text, typeof(LTLocalizationData), isFile: false);
				textData = lTLocalizationData.LanguageData;
			}
		}
		catch (Exception)
		{
		}
		return result;
	}

	private void SetLanguage(SystemLanguage language)
	{
		this.language = language;
	}

	public static void Init()
	{
		mInstance = new LTLocalization();
		mInstance.SetLanguage(Application.systemLanguage);
		mInstance.ReadData();
	}

	public static List<LTLocalizationData> ManualSetLanguage(SystemLanguage setLanguage)
	{
		if (mInstance == null)
		{
			mInstance = new LTLocalization();
		}
		mInstance.SetLanguage(setLanguage);
		return mInstance.ReadData();
	}

	public static string GetText(string key)
	{
		if (mInstance == null)
		{
			Init();
		}
		if (mInstance.textData.ContainsKey(key))
		{
			return mInstance.textData[key];
		}
		List<DicStruct> data = VRGlobal.mLocalizationScript.GetData(mInstance.language);
		int num = data.FindIndex((DicStruct it) => it.key == key);
		if (num != -1)
		{
			return data[num].value;
		}
		return "[NoDefine]" + key;
	}

	private static string GetLanguageAB(SystemLanguage language)
	{
		switch (language)
		{
		case SystemLanguage.Afrikaans:
		case SystemLanguage.Arabic:
		case SystemLanguage.Basque:
		case SystemLanguage.Belarusian:
		case SystemLanguage.Bulgarian:
		case SystemLanguage.Catalan:
			return "EN";
		case SystemLanguage.Chinese:
			return "CN";
		case SystemLanguage.ChineseTraditional:
			return "TW";
		case SystemLanguage.ChineseSimplified:
			return "CN";
		case SystemLanguage.Czech:
		case SystemLanguage.Danish:
		case SystemLanguage.Dutch:
		case SystemLanguage.English:
		case SystemLanguage.Estonian:
		case SystemLanguage.Faroese:
		case SystemLanguage.Finnish:
			return "EN";
		case SystemLanguage.French:
			return "FR";
		case SystemLanguage.German:
			return "GE";
		case SystemLanguage.Greek:
		case SystemLanguage.Hebrew:
		case SystemLanguage.Icelandic:
		case SystemLanguage.Indonesian:
			return "EN";
		case SystemLanguage.Italian:
			return "IT";
		case SystemLanguage.Japanese:
			return "JP";
		case SystemLanguage.Korean:
			return "KR";
		case SystemLanguage.Latvian:
		case SystemLanguage.Lithuanian:
		case SystemLanguage.Norwegian:
		case SystemLanguage.Polish:
		case SystemLanguage.Portuguese:
		case SystemLanguage.Romanian:
			return "EN";
		case SystemLanguage.Russian:
			return "RU";
		case SystemLanguage.SerboCroatian:
		case SystemLanguage.Slovak:
		case SystemLanguage.Slovenian:
			return "EN";
		case SystemLanguage.Spanish:
			return "SP";
		case SystemLanguage.Swedish:
		case SystemLanguage.Thai:
		case SystemLanguage.Turkish:
		case SystemLanguage.Ukrainian:
		case SystemLanguage.Vietnamese:
		case SystemLanguage.Unknown:
			return "EN";
		default:
			return "CN";
		}
	}

	public static SystemLanguage GetLanguageAB(string typeStr)
	{
		return typeStr switch
		{
			"EN" => SystemLanguage.English, 
			"CN" => SystemLanguage.ChineseSimplified, 
			"TW" => SystemLanguage.ChineseTraditional, 
			"JP" => SystemLanguage.Japanese, 
			"FR" => SystemLanguage.French, 
			"GE" => SystemLanguage.German, 
			"IT" => SystemLanguage.Italian, 
			"KR" => SystemLanguage.Korean, 
			"RU" => SystemLanguage.Russian, 
			"SP" => SystemLanguage.Spanish, 
			_ => SystemLanguage.English, 
		};
	}
}
public class LTLocalizationData
{
	public string LanguageType;

	public Dictionary<string, string> LanguageData;

	public override string ToString()
	{
		string text = "LanguageType:" + LanguageType;
		List<string> list = new List<string>(LanguageData.Keys);
		for (int i = 0; i < list.Count; i++)
		{
			text = text + "\nKey:[" + list[i] + "]|Value:[" + LanguageData[list[i]] + "]";
		}
		return text;
	}
}
public static class SaveHelper
{
	private const string M_KEY = "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx";

	public static bool IsFileExist(string filePath)
	{
		return File.Exists(filePath);
	}

	public static bool IsDirectoryExists(string filePath)
	{
		return Directory.Exists(filePath);
	}

	public static void CreateFile(string fileName, string content)
	{
		StreamWriter streamWriter = File.CreateText(fileName);
		streamWriter.Write(content);
		streamWriter.Close();
	}

	public static void CreateDirectory(string filePath)
	{
		if (!IsDirectoryExists(filePath))
		{
			Directory.CreateDirectory(filePath);
		}
	}

	private static string SerializeObject(object pObject)
	{
		_ = string.Empty;
		return JsonConvert.SerializeObject(pObject);
	}

	private static object DeserializeObject(string pString, Type pType)
	{
		return JsonConvert.DeserializeObject(pString, pType);
	}

	private static string RijndaelEncrypt(string pString, string pKey)
	{
		byte[] bytes = Encoding.UTF8.GetBytes(pKey);
		byte[] bytes2 = Encoding.UTF8.GetBytes(pString);
		byte[] array = new RijndaelManaged
		{
			Key = bytes,
			Mode = CipherMode.ECB,
			Padding = PaddingMode.PKCS7
		}.CreateEncryptor().TransformFinalBlock(bytes2, 0, bytes2.Length);
		return Convert.ToBase64String(array, 0, array.Length);
	}

	private static string RijndaelDecrypt(string pString, string pKey)
	{
		byte[] bytes = Encoding.UTF8.GetBytes(pKey);
		byte[] array = Convert.FromBase64String(pString);
		byte[] bytes2 = new RijndaelManaged
		{
			Key = bytes,
			Mode = CipherMode.ECB,
			Padding = PaddingMode.PKCS7
		}.CreateDecryptor().TransformFinalBlock(array, 0, array.Length);
		return Encoding.UTF8.GetString(bytes2);
	}

	public static void SaveData(string fileName, object pObject)
	{
		if (File.Exists(fileName))
		{
			File.Delete(fileName);
		}
		string pString = SerializeObject(pObject);
		pString = RijndaelEncrypt(pString, "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx");
		StreamWriter streamWriter = File.CreateText(fileName);
		streamWriter.Write(pString);
		streamWriter.Close();
	}

	public static object ReadData(string str, Type pType, bool isFile = true)
	{
		string pString;
		if (isFile)
		{
			if (!File.Exists(str))
			{
				return null;
			}
			StreamReader streamReader = File.OpenText(str);
			pString = streamReader.ReadToEnd();
			streamReader.Close();
		}
		else
		{
			pString = str;
		}
		pString = RijndaelDecrypt(pString, "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx");
		return DeserializeObject(pString, pType);
	}
}
public class VRUtility : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}

	public static int RandomChoose(float[] Probs)
	{
		float num = 0f;
		for (int i = 0; i < Probs.Length; i++)
		{
			num += Probs[i];
		}
		float num2 = UnityEngine.Random.value * num;
		for (int j = 0; j < Probs.Length; j++)
		{
			if (num2 < Probs[j])
			{
				return j;
			}
			num2 -= Probs[j];
		}
		return Probs.Length - 1;
	}
}
public enum EU_CAMP
{
	EU_NONE,
	EU_GOOD,
	EU_BAD
}
public class VRActor : VRGameEntity
{
	protected VRActor m_mySelf;

	protected Dictionary<string, VRActorAction> m_ActionLib = new Dictionary<string, VRActorAction>();

	protected VRActorAction m_cunAction;

	public string curAction;

	protected string mPauseAction = "";

	protected bool mLockAction;

	protected List<VRActorAction> m_multiActionList = new List<VRActorAction>();

	public VRActorAction CurAction => m_cunAction;

	public bool LockAction
	{
		get
		{
			return mLockAction;
		}
		set
		{
			mLockAction = value;
		}
	}

	protected virtual void InitActionLib()
	{
		if (m_ActionLib.Count != 0)
		{
			return;
		}
		VRActorAction[] components = base.gameObject.GetComponents<VRActorAction>();
		for (int i = 0; i < components.Length; i++)
		{
			components[i].initActionName();
			if (!m_ActionLib.ContainsKey(components[i].actionName))
			{
				m_ActionLib.Add(components[i].actionName, components[i]);
			}
		}
	}

	protected VRActorAction _getAction(string actionName)
	{
		InitActionLib();
		VRActorAction result = null;
		if (m_ActionLib.Count > 0 && m_ActionLib.ContainsKey(actionName))
		{
			result = m_ActionLib[actionName];
		}
		return result;
	}

	public VRActorAction playAction(string actionName)
	{
		if (mLockAction)
		{
			return null;
		}
		if (m_cunAction != null && m_cunAction.actionName.Equals(actionName))
		{
			return null;
		}
		stopAction();
		m_cunAction = _getAction(actionName);
		if (m_cunAction != null)
		{
			m_cunAction.playAction(ref m_mySelf);
		}
		curAction = actionName;
		return m_cunAction;
	}

	public void stopAction()
	{
		if (m_cunAction != null)
		{
			m_cunAction.stopAction(ref m_mySelf);
			m_cunAction = null;
		}
	}

	public void pauseActtion()
	{
		mPauseAction = curAction;
	}

	public void resumeAction()
	{
		if (mPauseAction.Length > 0)
		{
			playAction(mPauseAction);
		}
	}

	public VRActorAction findAction(string actionName)
	{
		InitActionLib();
		return m_ActionLib[actionName];
	}

	public void pushEffectAction(VRActorAction inAction)
	{
		if (!inAction.isRuning)
		{
			inAction.playAction(ref m_mySelf);
			m_multiActionList.Add(inAction);
		}
	}

	public VRActorAction playEffectAction(string actionName)
	{
		InitActionLib();
		VRActorAction vRActorAction = _getAction(actionName);
		if (vRActorAction != null && !vRActorAction.isRuning)
		{
			vRActorAction.playAction(ref m_mySelf);
			m_multiActionList.Add(vRActorAction);
		}
		return vRActorAction;
	}

	public void stopEffectActionAll()
	{
		for (int i = 0; i < m_multiActionList.Count; i++)
		{
			if (m_multiActionList[i].isRuning)
			{
				m_multiActionList[i].stopAction(ref m_mySelf);
			}
		}
		m_multiActionList.Clear();
	}

	public void stopEffectAction(string actionName)
	{
		int num = 0;
		while (num < m_multiActionList.Count)
		{
			if (m_multiActionList[num].actionName.Equals(actionName))
			{
				m_multiActionList[num].stopAction(ref m_mySelf);
				m_multiActionList.RemoveAt(num);
			}
			else
			{
				num++;
			}
		}
	}

	protected void updateEffectAction(float delta)
	{
		int num = 0;
		while (num < m_multiActionList.Count)
		{
			if (!m_multiActionList[num].isRuning)
			{
				m_multiActionList.RemoveAt(num);
				continue;
			}
			m_multiActionList[num].runAction(delta, ref m_mySelf);
			num++;
		}
	}

	protected override bool MyAwake()
	{
		m_mySelf = this;
		return base.MyAwake();
	}

	protected override bool MyStart()
	{
		return base.MyStart();
	}

	protected override bool MyUpdate(float delta)
	{
		if (m_cunAction != null)
		{
			m_cunAction.runAction(delta, ref m_mySelf);
		}
		updateEffectAction(delta);
		return base.MyUpdate(delta);
	}

	public override bool MyReset()
	{
		base.gameObject.SetActive(value: true);
		return base.MyReset();
	}

	public override bool MyHide()
	{
		stopAction();
		base.gameObject.SetActive(value: false);
		return base.MyHide();
	}
}
public class VRActorActCriticalHitFlash : VRActorAction
{
	public float duration = 2f;

	public bool noInjure;

	private Vector3 hitPos = Vector3.zero;

	private GameObject criticalHitFlash;

	public Vector3 HitPos
	{
		get
		{
			return hitPos;
		}
		set
		{
			hitPos = value;
		}
	}

	public override void initActionName()
	{
		actionName = "criticalHitFlash";
	}

	public override bool playAction(ref VRActor inActor)
	{
		VRNpc vRNpc = inActor as VRNpc;
		if (!inActor)
		{
			return true;
		}
		if (vRNpc.criticalHitFlash != null)
		{
			Vector3 position = ((hitPos.sqrMagnitude == 0f) ? inActor.transform.position : hitPos);
			position.y += 0.5f;
			criticalHitFlash = VRGlobal.getActorEntity(vRNpc.criticalHitFlash);
			if ((bool)criticalHitFlash)
			{
				criticalHitFlash.transform.position = position;
				criticalHitFlash.transform.parent = inActor.transform;
			}
		}
		return base.playAction(ref inActor);
	}

	public override bool stopAction(ref VRActor inActor)
	{
		VRGlobal.pushFreeEntity(criticalHitFlash);
		duration = 1f;
		return base.stopAction(ref inActor);
	}

	public override bool runAction(float delta, ref VRActor inActor)
	{
		duration -= delta * 2f;
		if (duration < 0f)
		{
			duration = 0f;
		}
		if (duration == 0f)
		{
			stopAction(ref inActor);
			return false;
		}
		return base.runAction(delta, ref inActor);
	}
}
public class VRActorActDeadFlash : VRActorAction
{
	public float duration = 2f;

	public bool noInjure;

	public float heightOffset = 0.5f;

	private Vector3 hitPos = Vector3.zero;

	private GameObject deadFlash;

	public override void initActionName()
	{
		actionName = "deadFlash";
	}

	public override bool playAction(ref VRActor inActor)
	{
		VRNpc vRNpc = inActor as VRNpc;
		if (!inActor)
		{
			return true;
		}
		if (vRNpc.deadFlash != null)
		{
			Vector3 position = ((hitPos.sqrMagnitude == 0f) ? inActor.transform.position : hitPos);
			position.y += heightOffset;
			deadFlash = VRGlobal.getActorEntity(vRNpc.deadFlash);
			if ((bool)deadFlash)
			{
				deadFlash.transform.position = position;
			}
		}
		return base.playAction(ref inActor);
	}

	public override bool stopAction(ref VRActor inActor)
	{
		if ((bool)deadFlash && deadFlash.activeSelf)
		{
			VRGlobal.pushFreeEntity(deadFlash);
		}
		duration = 1f;
		return base.stopAction(ref inActor);
	}

	public override bool runAction(float delta, ref VRActor inActor)
	{
		duration -= delta * 2f;
		if (duration < 0f)
		{
			duration = 0f;
		}
		if (duration == 0f)
		{
			stopAction(ref inActor);
			return false;
		}
		return base.runAction(delta, ref inActor);
	}
}
public class VRActorActHitFlash : VRActorAction
{
	private Color m_damagColor = new Color(1f, 0f, 0f, 1f);

	private Color mtlCol = Color.white;

	private float coltimer = 1f;

	public bool noInjure;

	private Vector3 hitPos = Vector3.zero;

	protected Renderer[] m_MyRender;

	public Vector3 HitPos
	{
		get
		{
			return hitPos;
		}
		set
		{
			hitPos = value;
		}
	}

	public override void initActionName()
	{
		actionName = "hitFlash";
	}

	public override bool playAction(ref VRActor inActor)
	{
		VRNpc vRNpc = inActor as VRNpc;
		if (!inActor)
		{
			return true;
		}
		if (vRNpc.blood != null)
		{
			Vector3 vector = ((hitPos.sqrMagnitude == 0f) ? inActor.transform.position : hitPos);
			if (vRNpc.AttackTarget != null)
			{
				Vector3 vector2 = vRNpc.AttackTarget.transform.position - vector;
				vector2.Normalize();
				vector += vector2 * 0.3f;
			}
			vector.y += 0.5f;
			GameObject actorEntity = VRGlobal.getActorEntity(vRNpc.blood);
			actorEntity.transform.position = vector;
			actorEntity.transform.parent = inActor.transform;
		}
		if (m_MyRender == null)
		{
			Renderer[] componentsInChildren = inActor.gameObject.GetComponentsInChildren<SkinnedMeshRenderer>();
			m_MyRender = componentsInChildren;
		}
		if (m_MyRender != null)
		{
			coltimer = 1f;
			for (int i = 0; i < m_MyRender.Length; i++)
			{
				mtlCol = m_MyRender[i].material.color;
			}
		}
		return base.playAction(ref inActor);
	}

	public override bool stopAction(ref VRActor inActor)
	{
		for (int i = 0; i < m_MyRender.Length; i++)
		{
			m_MyRender[i].material.color = mtlCol;
		}
		return base.stopAction(ref inActor);
	}

	public override bool runAction(float delta, ref VRActor inActor)
	{
		coltimer -= delta * 2f;
		if (coltimer < 0f)
		{
			coltimer = 0f;
		}
		for (int i = 0; i < m_MyRender.Length; i++)
		{
			m_MyRender[i].material.color = Color.Lerp(mtlCol, m_damagColor, coltimer);
		}
		if (coltimer == 0f)
		{
			stopAction(ref inActor);
			return false;
		}
		return base.runAction(delta, ref inActor);
	}
}
public class VRActorActSpawnAction : VRActorAction
{
	private GameObject mSpawnEffect;

	public float Height = 1f;

	public float Scale = 1f;

	private float mTimer;

	private MeshRenderer mRenderer;

	public override void initActionName()
	{
		actionName = "spawn";
	}

	public override bool playAction(ref VRActor inActor)
	{
		VRNpc vRNpc = inActor as VRNpc;
		if (!inActor)
		{
			return true;
		}
		if (vRNpc.spawnFlash != null)
		{
			mSpawnEffect = VRGlobal.getActorEntity(vRNpc.spawnFlash);
		}
		if (mSpawnEffect == null)
		{
			return false;
		}
		mSpawnEffect.SetActive(value: true);
		Vector3 vector = new Vector3(0f, Height, 0f);
		mSpawnEffect.transform.position = inActor.transform.position + vector;
		mSpawnEffect.transform.localScale = new Vector3(Scale, Scale, Scale);
		mTimer = 0f;
		ParticleSystem component = mSpawnEffect.GetComponent<ParticleSystem>();
		if (component != null)
		{
			component.startSize *= Scale;
		}
		for (int i = 0; i < mSpawnEffect.transform.childCount; i++)
		{
			component = mSpawnEffect.transform.GetChild(i).GetComponent<ParticleSystem>();
			if (component != null)
			{
				component.startSize *= Scale;
			}
		}
		mRenderer = vRNpc.GetComponentInChildren<MeshRenderer>();
		if (mRenderer != null)
		{
			mRenderer.enabled = false;
		}
		return base.playAction(ref inActor);
	}

	public override bool runAction(float delta, ref VRActor inActor)
	{
		mTimer += delta;
		if (mTimer >= 1f)
		{
			if ((bool)mSpawnEffect && mSpawnEffect.activeSelf)
			{
				VRGlobal.pushFreeEntity(mSpawnEffect);
			}
		}
		else if (mTimer >= 0.5f && mRenderer != null)
		{
			mRenderer.enabled = true;
		}
		return base.runAction(delta, ref inActor);
	}

	public override bool stopAction(ref VRActor inActor)
	{
		if ((bool)mSpawnEffect && mSpawnEffect.activeSelf)
		{
			VRGlobal.pushFreeEntity(mSpawnEffect);
		}
		return base.stopAction(ref inActor);
	}
}
public class VRActorAction : VRGameObject
{
	public string actionName = "auto";

	protected float timer;

	protected bool runing;

	public float Timer => timer;

	public bool isRuning
	{
		get
		{
			return runing;
		}
		set
		{
			runing = value;
		}
	}

	public virtual void initActionName()
	{
	}

	protected override bool MyStart()
	{
		base.enabled = false;
		return base.MyStart();
	}

	protected override bool MyAwake()
	{
		initAction();
		return base.MyAwake();
	}

	public virtual bool initAction()
	{
		return true;
	}

	public virtual bool playAction(ref VRActor inActor)
	{
		runing = true;
		timer = 0f;
		base.enabled = true;
		return true;
	}

	public virtual bool stopAction(ref VRActor inActor)
	{
		base.enabled = false;
		runing = false;
		return true;
	}

	public virtual bool runAction(float delta, ref VRActor inActor)
	{
		timer += delta;
		return true;
	}

	public override void MyLateUpdate()
	{
	}
}
public class VRBlink : MonoBehaviour
{
	public GameObject mBlinkParticlePrefab;

	private GameObject mBlinkParticle;

	public float mShowTime = 5f;

	public float mHideTime = 5f;

	public Vector3 mLocationOffset = Vector3.zero;

	[HideInInspector]
	public bool mIsShow = true;

	private bool mIsFirst = true;

	public GameObject mShowAudioPrefab;

	public GameObject mHideAudioPrefab;

	private void Start()
	{
		if ((bool)mBlinkParticlePrefab)
		{
			mBlinkParticle = UnityEngine.Object.Instantiate(mBlinkParticlePrefab);
			mBlinkParticle.transform.position = base.gameObject.transform.position + mLocationOffset;
			mBlinkParticle.transform.parent = base.gameObject.transform;
		}
		mBlinkParticle.SetActive(value: false);
		base.enabled = false;
	}

	private void Update()
	{
	}

	public void Show()
	{
		if (!base.enabled)
		{
			return;
		}
		VRMonster component = base.gameObject.GetComponent<VRMonster>();
		if ((bool)component && component.CurHP <= 0f)
		{
			return;
		}
		if ((bool)mBlinkParticle)
		{
			ParticleSystem[] componentsInChildren = mBlinkParticle.GetComponentsInChildren<ParticleSystem>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				componentsInChildren[i].Stop();
			}
			mBlinkParticle.SetActive(value: false);
		}
		SkinnedMeshRenderer[] componentsInChildren2 = GetComponentsInChildren<SkinnedMeshRenderer>();
		foreach (SkinnedMeshRenderer skinnedMeshRenderer in componentsInChildren2)
		{
			if ((bool)skinnedMeshRenderer)
			{
				skinnedMeshRenderer.enabled = true;
			}
		}
		MeshRenderer[] componentsInChildren3 = GetComponentsInChildren<MeshRenderer>();
		foreach (MeshRenderer meshRenderer in componentsInChildren3)
		{
			if ((bool)meshRenderer)
			{
				meshRenderer.enabled = true;
			}
		}
		mIsShow = true;
		float time = UnityEngine.Random.Range(mShowTime, mShowTime + 3f);
		if (mIsFirst)
		{
			time = UnityEngine.Random.Range(2f, 5f);
			mIsFirst = false;
		}
		else if ((bool)component)
		{
			component.SoundPlay(mShowAudioPrefab);
		}
		Invoke("Hide", time);
	}

	public void Hide()
	{
		if (!base.enabled)
		{
			return;
		}
		VRMonster component = base.gameObject.GetComponent<VRMonster>();
		if ((bool)component && component.CurHP <= 0f)
		{
			return;
		}
		if ((bool)component)
		{
			component.SoundPlay(mHideAudioPrefab);
		}
		if ((bool)mBlinkParticle)
		{
			ParticleSystem[] componentsInChildren = mBlinkParticle.GetComponentsInChildren<ParticleSystem>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				componentsInChildren[i].Play();
			}
			mBlinkParticle.SetActive(value: true);
		}
		SkinnedMeshRenderer[] componentsInChildren2 = GetComponentsInChildren<SkinnedMeshRenderer>();
		foreach (SkinnedMeshRenderer skinnedMeshRenderer in componentsInChildren2)
		{
			if ((bool)skinnedMeshRenderer)
			{
				skinnedMeshRenderer.enabled = false;
			}
		}
		MeshRenderer[] componentsInChildren3 = GetComponentsInChildren<MeshRenderer>();
		foreach (MeshRenderer meshRenderer in componentsInChildren3)
		{
			if ((bool)meshRenderer)
			{
				meshRenderer.enabled = false;
			}
		}
		mIsShow = false;
		Invoke("Show", mHideTime);
	}
}
public class VRBlood : VRMuzzle
{
	public float vSpeed = 4f;

	private float vs;

	public override bool MyReset()
	{
		vs = vSpeed;
		base.MyReset();
		return base.MyReset();
	}

	protected override bool MyUpdate(float delta)
	{
		if (vSpeed != 0f)
		{
			vs -= 5f * delta;
			Vector3 position = base.transform.position;
			position.y += vs * delta;
			base.transform.position = position;
		}
		return base.MyUpdate(delta);
	}
}
public class VRBomb : VRNpc
{
	protected bool exp;

	public float expTimer = 1f;

	public bool bCanAttack;

	public bool bLitmitKiller;

	public string strLimitKillerLayerName_1 = "";

	public string strLimitKillerLayerName_2 = "";

	private bool isDrop;

	protected override bool MyAwake()
	{
		exp = false;
		base.Camp = EU_CAMP.EU_BAD;
		VRGlobal.interActiveLib.Add(this);
		VRBubbleText component = base.gameObject.GetComponent<VRBubbleText>();
		if ((bool)component)
		{
			component.InitBubbleCanvas();
		}
		return true;
	}

	protected override bool MyUpdate(float delta)
	{
		if (exp)
		{
			expTimer -= delta;
			if (expTimer <= 0f)
			{
				expTimer = 0f;
				MeshRenderer[] componentsInChildren = GetComponentsInChildren<MeshRenderer>();
				foreach (MeshRenderer meshRenderer in componentsInChildren)
				{
					if ((bool)meshRenderer)
					{
						meshRenderer.enabled = false;
					}
				}
			}
			bool flag = true;
			ParticleSystem[] componentsInChildren2 = base.gameObject.GetComponentsInChildren<ParticleSystem>();
			for (int j = 0; j < componentsInChildren2.Length; j++)
			{
				if (componentsInChildren2[j].isPlaying)
				{
					flag = false;
				}
			}
			if (flag)
			{
				VRGlobal.interActiveLib.Remove(this);
				base.gameObject.SetActive(value: false);
			}
		}
		return true;
	}

	public override bool OnDamage(float dmgHP, ref VRNpc killer, bool sound, ref Vector3 pos, bool isAwarded = true)
	{
		if (bCanAttack)
		{
			if (bLitmitKiller)
			{
				if ((bool)(killer as VRPlayer))
				{
					VRPlayer vRPlayer = (VRPlayer)killer;
					if ((bool)vRPlayer && (bool)vRPlayer.CurWeapon && (vRPlayer.CurWeapon.gameObject.layer == LayerMask.NameToLayer(strLimitKillerLayerName_1) || vRPlayer.CurWeapon.gameObject.layer == LayerMask.NameToLayer(strLimitKillerLayerName_2)))
					{
						Invoke("Damage", fDelayTime);
					}
				}
			}
			else
			{
				Invoke("Damage", fDelayTime);
			}
		}
		VRBubbleText component = base.gameObject.GetComponent<VRBubbleText>();
		if ((bool)component)
		{
			component.SetVisible(visible: false);
		}
		if (isAwarded)
		{
			VRGlobal.G_GameSystem.GainScore += killScore;
		}
		return true;
	}

	private void Damage()
	{
		if (exp)
		{
			return;
		}
		base.transform.SetParent(null);
		m_fCurHP = 0f;
		ParticleSystem[] componentsInChildren = base.gameObject.GetComponentsInChildren<ParticleSystem>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].Play();
		}
		AudioSource component = base.gameObject.GetComponent<AudioSource>();
		if (component != null)
		{
			component.Play();
		}
		exp = true;
		base.IsDamaged = true;
		CharacterController component2 = GetComponent<CharacterController>();
		if ((bool)component2)
		{
			component2.enabled = false;
		}
		VRNpc killer = null;
		for (int j = 0; j < VRGlobal.npcLib.Count; j++)
		{
			VRNpc vRNpc = VRGlobal.npcLib[j];
			if ((bool)vRNpc && vRNpc != this && (vRNpc.transform.position - base.transform.position).sqrMagnitude <= atkRange * atkRange)
			{
				Vector3 pos = vRNpc.transform.position;
				if (!(vRNpc is VRBoss) && vRNpc is VRMonster)
				{
					vRNpc.OnDamage(base.Atk * 10f, ref killer, sound: false, ref pos);
				}
				else
				{
					vRNpc.OnDamage(base.Atk, ref killer, sound: false, ref pos);
				}
			}
		}
	}

	public void Drop()
	{
		base.transform.SetParent(null);
		base.gameObject.AddComponent<Rigidbody>();
		isDrop = true;
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (!isDrop)
		{
			return;
		}
		if (collision.gameObject.tag == "waterhitsound")
		{
			Damage();
			return;
		}
		VRNpc component = collision.gameObject.GetComponent<VRNpc>();
		if (component == null || component.CurHP > 0f)
		{
			Invoke("Damage", 0.5f);
		}
	}
}
public class VRBoss : VRMonster, IPunObservable
{
	public GameObject[] mLittleMonsters;

	public string[] mLittleMonsterNames;

	private int mPosIndex;

	[HideInInspector]
	public bool mCanAttack;

	public GameObject mFlyPointsObj;

	private List<Transform> mPoints = new List<Transform>();

	public float mAttackIntervalTime = 2f;

	public GameObject mSpawnEffectPrefab;

	public GameObject mSpawnAudioPrefab;

	public void Init()
	{
		if (VRGameSystem.CurGameModel == GameModel.GM_Single)
		{
			CurPlayerIsDamage(canDamage: true);
		}
		else
		{
			if (VRGameSystem.CurGameModel != GameModel.GM_Multi || !PhotonNetwork.IsMasterClient)
			{
				return;
			}
			List<Player> list = new List<Player>(PhotonNetwork.PlayerList);
			for (int i = 0; i < list.Count; i++)
			{
				if ((bool)list[i].CustomProperties["ISDEAD"])
				{
					list.RemoveAt(i);
					i--;
				}
				if (list.Count <= 0)
				{
					break;
				}
			}
			int num = UnityEngine.Random.Range(0, list.Count);
			for (int j = 0; j < list.Count; j++)
			{
				photonView.RPC("CurPlayerIsDamage", list[j], j == num);
			}
		}
	}

	public override bool MyReset()
	{
		if ((bool)mFlyPointsObj)
		{
			for (int i = 0; i < mFlyPointsObj.transform.childCount; i++)
			{
				mPoints.Add(mFlyPointsObj.transform.GetChild(i));
			}
		}
		else if ((bool)VRBossFlyManager.Instance)
		{
			mPoints.AddRange(VRBossFlyManager.Instance.flyPoints);
		}
		if (mLittleMonsterNames == null)
		{
			mLittleMonsterNames = mLittleMonsters.Select((GameObject it) => it.name).ToArray();
		}
		return base.MyReset();
	}

	protected override bool MyUpdate(float delta)
	{
		if ((bool)VRGlobal.G_GameSystem && (bool)VRGlobal.G_GameSystem.CurPlayer && !VRGlobal.G_GameSystem.CurPlayer.CurCanDamage)
		{
			if ((bool)hpSlider && hpSlider.value != m_fCurHP)
			{
				hpSlider.value = m_fCurHP;
				if (hpSlider.value <= 0f)
				{
					hpSlider.gameObject.SetActive(value: false);
				}
			}
			hpSlider.transform.LookAt(Camera.main.transform);
			return false;
		}
		if (base.AttackTarget == null)
		{
			base.AttackTarget = VRGlobal.findTarget(camp, base.transform, searchRange * searchRange);
		}
		FindTarget();
		if (VRGameSystem.CurGameModel == GameModel.GM_Multi)
		{
			foreach (Player value in PhotonNetwork.CurrentRoom.Players.Values)
			{
				if (value != PhotonNetwork.LocalPlayer)
				{
					photonView.RPC("SyncBoosData", value, base.transform.position, base.transform.rotation);
				}
			}
		}
		return base.MyUpdate(delta);
	}

	public override void SetItweenPathDest()
	{
		if (VRGlobal.G_GameSystem.CurPlayer.CurCanDamage)
		{
			mCanAttack = false;
			base.Anim.SetBool("fly", value: true);
			base.Anim.SetBool("idle", value: false);
			DragonController component = GetComponent<DragonController>();
			if ((bool)component)
			{
				component.attack1 = false;
			}
			if (mPosIndex >= mPoints.Count)
			{
				mPosIndex = 0;
			}
			Vector3[] array = new Vector3[2]
			{
				base.transform.position,
				mPoints[mPosIndex].position
			};
			mPosIndex++;
			if (VRGameSystem.CurGameModel == GameModel.GM_Multi)
			{
				photonView.RPC("SyncPosIndex", RpcTarget.All, mPosIndex);
			}
			if (array.Length >= 0)
			{
				System.Collections.Hashtable hashtable = new System.Collections.Hashtable();
				hashtable.Add("path", array);
				hashtable.Add("easeType", iTween.EaseType.linear);
				hashtable.Add("speed", base.MoveSpeed);
				hashtable.Add("movetopath", true);
				hashtable.Add("orienttopath", true);
				hashtable.Add("oncomplete", "ItweenReachEnd");
				iTween.MoveTo(base.gameObject, hashtable);
				bIsItweenPathNeedResume = true;
			}
		}
	}

	public override void FindTarget()
	{
		if ((bool)VRGlobal.G_GameSystem && (bool)VRGlobal.G_GameSystem.CurPlayer && VRGlobal.G_GameSystem.CurPlayer.CurCanDamage)
		{
			Target = VRGlobal.G_GameSystem.CurPlayer;
			mShootTarget = Target.NavPoint.gameObject;
		}
	}

	public void Idle()
	{
		base.Anim.SetBool("attack", value: false);
		if (mCanAttack)
		{
			base.Anim.SetBool("idle", value: true);
		}
	}

	public override void ItweenReachEnd()
	{
		if (VRGlobal.G_GameSystem.CurPlayer.CurCanDamage)
		{
			mCanAttack = true;
			base.Anim.SetBool("fly", value: false);
			base.Anim.SetBool("idle", value: true);
			Attack();
			mShootTarget = Target.NavPoint.gameObject;
			base.transform.LookAt(mShootTarget.transform);
			float num = UnityEngine.Random.Range(5f, 10f);
			if (VRGameSystem.CurGameModel == GameModel.GM_Single)
			{
				Invoke("SetItweenPathDest", num);
			}
			else if (VRGameSystem.CurGameModel == GameModel.GM_Multi)
			{
				StopAllCoroutines();
				StartCoroutine(RandomTarget(mPosIndex, num));
			}
		}
	}

	private IEnumerator RandomTarget(int posIndex, float wait)
	{
		yield return new WaitForSeconds(wait);
		List<Player> list = new List<Player>(PhotonNetwork.PlayerList);
		for (int i = 0; i < list.Count; i++)
		{
			if ((bool)list[i].CustomProperties["ISDEAD"])
			{
				list.RemoveAt(i);
				i--;
			}
			if (list.Count <= 0)
			{
				break;
			}
		}
		int num = UnityEngine.Random.Range(0, list.Count);
		for (int j = 0; j < list.Count; j++)
		{
			photonView.RPC("SetLocalIsDamage", list[j], j == num, posIndex);
		}
	}

	private void Attack()
	{
		if (VRGlobal.G_GameSystem.CurPlayer.CurCanDamage && mCanAttack)
		{
			base.Anim.SetBool("attack", value: true);
			base.Anim.SetBool("fly", value: false);
			List<Vector3> pos = new List<Vector3>();
			if (GetAttackType(ref pos) == AttackType.AT_OutputMonster)
			{
				base.Anim.SetFloat("attackType", 1f);
				Fire();
			}
			else
			{
				base.Anim.SetFloat("attackType", 0f);
			}
			Invoke("Attack", mAttackIntervalTime);
		}
	}

	private AttackType GetAttackType(ref List<Vector3> pos)
	{
		int count = mPosIndex;
		if (count - 1 < 0)
		{
			count = mPoints.Count;
		}
		for (int i = 0; i < mPoints[count - 1].childCount; i++)
		{
			pos.Add(mPoints[count - 1].GetChild(i).position);
		}
		if (pos.Count > 0)
		{
			return AttackType.AT_OutputMonster;
		}
		return AttackType.AT_AttackRanged;
	}

	public void Fire()
	{
		if (VRGlobal.G_GameSystem.CurPlayer.CurCanDamage && mCanAttack && !(base.CurHP <= 0f) && monsterType == MonsterType.MT_Air)
		{
			List<Vector3> pos = new List<Vector3>();
			switch (GetAttackType(ref pos))
			{
			case AttackType.AT_AttackRanged:
			{
				Vector3 position = mShootTarget.transform.position;
				Vector3 inShotDir = new Vector3(position.x - FiringPoint.position.x, position.y - FiringPoint.position.y, position.z - FiringPoint.position.z);
				float fSpeed = mBulletSpeed;
				Fire(ref inShotDir, FiringPoint, camp, atkRange, fSpeed, this);
				break;
			}
			case AttackType.AT_OutputMonster:
				OutputMonster(pos);
				break;
			}
		}
	}

	public void Fire(ref Vector3 inShotDir, Transform inPos, EU_CAMP inCamp, float ATKRange, float fSpeed, VRNpc owner, bool bIncreaseFireBulletNum = true)
	{
		if (mCanAttack && !(base.CurHP <= 0f))
		{
			Transform transform = null;
			Vector3 inDir = inShotDir.normalized;
			Vector3 inPos2 = ((transform != null) ? transform.position : inPos.transform.position);
			Quaternion quaternion = Quaternion.LookRotation(inDir);
			GameObject bullet = GetBullet(inPos2);
			if (bullet == null)
			{
				VRLogger.LogError("子弹对象为空");
			}
			bullet.transform.position = inPos2;
			Quaternion identity = Quaternion.identity;
			identity.eulerAngles = new Vector3(0f, UnityEngine.Random.Range(-scatteringPlane, scatteringPlane), 0f);
			switch (eBulletFireType)
			{
			case BulletFireType.BFT_Physic:
			{
				VRBulletPhysic component2 = bullet.GetComponent<VRBulletPhysic>();
				component2.Camp = inCamp;
				component2.Pierce = pierce;
				component2.transform.rotation = quaternion * identity;
				component2.fire(ref inPos2, ref inDir, ATKRange, fSpeed.Equals(0f) ? speed : fSpeed, inCamp, owner);
				break;
			}
			case BulletFireType.BFT_Kinematic:
			{
				VRBulletKinematic component = bullet.GetComponent<VRBulletKinematic>();
				component.Camp = inCamp;
				component.Pierce = pierce;
				component.transform.rotation = quaternion * identity;
				inDir = component.transform.forward;
				component.fire(ref inPos2, ref inDir, ATKRange, fSpeed.Equals(0f) ? speed : fSpeed, inCamp, owner);
				break;
			}
			}
		}
	}

	public void OutputMonster(List<Vector3> pos)
	{
		if (!VRGlobal.G_GameSystem.CurPlayer.CurCanDamage || !mCanAttack || base.CurHP <= 0f)
		{
			return;
		}
		for (int i = 0; i < pos.Count; i++)
		{
			BossSpawnMonster(pos[i]);
			if (VRGameSystem.CurGameModel == GameModel.GM_Single)
			{
				SyncSpwanMonsterEff(pos[i]);
				continue;
			}
			photonView.RPC("SyncSpwanMonsterEff", RpcTarget.All, pos[i]);
		}
	}

	private GameObject GetBullet(Vector3 pos)
	{
		if (VRGameSystem.CurGameModel == GameModel.GM_Single)
		{
			return VRGlobal.getActorEntity(BulletPrefab);
		}
		if (VRGameSystem.CurGameModel == GameModel.GM_Multi)
		{
			return PhotonNetwork.Instantiate(BulletPrefab.name, pos, Quaternion.identity, 0);
		}
		return null;
	}

	private void BossSpawnMonster(Vector3 pos)
	{
		GameObject gameObject = null;
		if (VRGameSystem.CurGameModel == GameModel.GM_Single)
		{
			int num = UnityEngine.Random.Range(0, mLittleMonsters.Length);
			gameObject = UnityEngine.Object.Instantiate(mLittleMonsters[num]);
		}
		else if (VRGameSystem.CurGameModel == GameModel.GM_Multi)
		{
			int num2 = UnityEngine.Random.Range(0, mLittleMonsterNames.Length);
			gameObject = PhotonNetwork.Instantiate(mLittleMonsterNames[num2], pos, Quaternion.identity, 0);
		}
		VRGlobal.G_GameSystem.bossHatchMonster.Add(gameObject);
		if (VRGameSystem.CurGameModel == GameModel.GM_Single)
		{
			SetBossSpwqnData();
		}
		else if (VRGameSystem.CurGameModel == GameModel.GM_Multi)
		{
			photonView.RPC("SetBossSpwqnData", RpcTarget.All);
		}
		VRMonster component = gameObject.GetComponent<VRMonster>();
		component.pathType = PathType.Right;
		component.BossSpawnNpc(pos);
	}

	[PunRPC]
	public void SetLocalIsDamage(bool isDamage, int posIndex)
	{
		mPosIndex = posIndex;
		CurPlayerIsDamage(isDamage);
		if (isDamage)
		{
			SetItweenPathDest();
		}
	}

	[PunRPC]
	public void SyncPosIndex(int index)
	{
		mPosIndex = index;
	}

	[PunRPC]
	public void SyncSpwanMonsterEff(Vector3 pos)
	{
		if ((bool)mSpawnEffectPrefab)
		{
			GameObject obj = UnityEngine.Object.Instantiate(mSpawnEffectPrefab);
			obj.transform.position = pos;
			ParticleSystem[] componentsInChildren = obj.GetComponentsInChildren<ParticleSystem>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				componentsInChildren[i].Play();
			}
		}
		if ((bool)mSpawnAudioPrefab)
		{
			SoundPlay(mSpawnAudioPrefab);
		}
	}

	[PunRPC]
	public void SetBossSpwqnData()
	{
		VRGlobal.G_GameSystem.IsHasBossSpwanMonster = true;
	}

	public void OnPhotonSerializeView(PhotonStream stream, PhotonMessageInfo info)
	{
	}

	[PunRPC]
	public void CurPlayerIsDamage(bool canDamage)
	{
		VRGlobal.G_GameSystem.CurPlayer.CurCanDamage = canDamage;
	}

	[PunRPC]
	public void SyncBoosData(Vector3 pos, Quaternion quat)
	{
		if (!VRGlobal.G_GameSystem.CurPlayer.CurCanDamage)
		{
			base.transform.position = pos;
			base.transform.rotation = quat;
		}
	}
}
public class VRBossFlyManager : MonoBehaviour
{
	public Transform[] flyPoints;

	public static VRBossFlyManager Instance { get; private set; }

	private void Awake()
	{
		Instance = this;
	}
}
public enum BubbleType
{
	BT_Text,
	BT_Image,
	BT_Effect
}
public class VRBubbleCavas : MonoBehaviour
{
	private List<string> mContents = new List<string>();

	public Text mContentText;

	public Image mContentImage;

	public GameObject mContentEffect;

	public float mShowTime = 5f;

	public float mIntervalTime = 5f;

	private float mCurHideTime;

	public Vector3 mLocationOffset = Vector3.zero;

	[HideInInspector]
	public BubbleType mBubbleType;

	[HideInInspector]
	public float mShowProbability = 30f;

	[HideInInspector]
	public float mMaxDisShow = 500f;

	[HideInInspector]
	public bool mCanShow = true;

	private void Start()
	{
		if (mBubbleType == BubbleType.BT_Text)
		{
			mContentText.gameObject.SetActive(value: true);
		}
		else if (mBubbleType == BubbleType.BT_Image)
		{
			mContentImage.gameObject.SetActive(value: true);
		}
		else
		{
			mContentEffect.SetActive(value: true);
			mContentEffect.transform.localPosition = Vector3.zero;
		}
		Show();
	}

	private void Update()
	{
		base.transform.forward = new Vector3(base.transform.position.x - Camera.main.transform.position.x, 0f, base.transform.position.z - Camera.main.transform.position.z);
	}

	public void InitContents(ref string[] contents)
	{
		for (int i = 0; i < contents.Length; i++)
		{
			mContents.Add(contents[i]);
		}
	}

	public void Show()
	{
		if (mContents.Count <= 0)
		{
			return;
		}
		if (Vector3.Distance(base.gameObject.transform.position, Camera.main.transform.position) < mMaxDisShow && UnityEngine.Random.Range(1f, 100f) < mShowProbability)
		{
			if (mBubbleType == BubbleType.BT_Text)
			{
				int index = UnityEngine.Random.Range(0, mContents.Count);
				if ((bool)mContentText)
				{
					string text = LTLocalization.GetText(mContents[index]);
					mContentText.text = text;
				}
			}
			else if (mBubbleType == BubbleType.BT_Image)
			{
				mContentImage.enabled = true;
			}
			else if (mBubbleType == BubbleType.BT_Effect)
			{
				mContentEffect.SetActive(value: true);
			}
		}
		float time = UnityEngine.Random.Range(mShowTime, mShowTime + 5f);
		Invoke("Hide", time);
	}

	public void Hide()
	{
		mCurHideTime = 0f;
		if (mBubbleType == BubbleType.BT_Text)
		{
			mContentText.text = "";
		}
		else if (mBubbleType == BubbleType.BT_Image)
		{
			mContentImage.enabled = false;
		}
		else if (mBubbleType == BubbleType.BT_Effect)
		{
			mContentEffect.SetActive(value: false);
		}
		float time = UnityEngine.Random.Range(mIntervalTime, mIntervalTime + 5f);
		Invoke("Show", time);
	}
}
public class VRBubbleText : MonoBehaviour
{
	public string[] mContents;

	public GameObject mBubblePrefab;

	private GameObject mBubbleCanvas;

	public Vector3 mLocationOffset = Vector3.zero;

	private VRNpc mNpc;

	public float mMaxDisShow = 15f;

	public float mShowProbability = 30f;

	private void Start()
	{
		mNpc = base.gameObject.GetComponent<VRNpc>();
	}

	public void InitBubbleCanvas()
	{
	}

	public void SetVisible(bool visible)
	{
		if ((bool)mBubbleCanvas)
		{
			UnityEngine.Object.Destroy(mBubbleCanvas);
			mBubbleCanvas = null;
		}
	}

	private void Update()
	{
	}
}
public class VRBulletKinematic : VRGameEntity
{
	public PhotonView photonView;

	public float rotSpeed;

	protected Vector3 m_startPosition = Vector3.zero;

	protected Vector3 m_startDir = Vector3.zero;

	protected float moveSpace;

	protected float moveSpeed;

	protected float curMoveDist;

	protected VRNpc bulletOwner;

	private bool mExploded;

	protected bool pierce;

	protected List<VRNpc> hitList = new List<VRNpc>();

	public GameObject mExplosionPrefab;

	private bool firstTest = true;

	private float rotOpe;

	public bool Pierce
	{
		get
		{
			return pierce;
		}
		set
		{
			pierce = value;
		}
	}

	protected override bool MyUpdate(float delta)
	{
		if (VRGameSystem.CurGameModel == GameModel.GM_Multi && !photonView.IsMine)
		{
			return false;
		}
		if (show)
		{
			if (!mExploded)
			{
				if (rotSpeed != 0f)
				{
					rotOpe += rotSpeed * delta;
					base.transform.localEulerAngles = new Vector3(0f, rotOpe, 0f);
				}
				Vector3 cpos = base.transform.position;
				float num = delta * moveSpeed;
				curMoveDist += num;
				if (curMoveDist > moveSpace)
				{
					VRGlobal.pushFreeEntity(base.gameObject);
				}
				else
				{
					Vector3 npos = cpos + m_startDir * num;
					base.transform.position = npos;
					Vector3 flydir = npos - cpos;
					flydir.y = 0f;
					flydir.Normalize();
					if (firstTest)
					{
						firstTest = false;
						if (bulletOwner != null)
						{
							Vector3 vector = bulletOwner.transform.position - cpos;
							vector.y = 0f;
							cpos -= flydir * vector.magnitude;
						}
					}
					hitTest(VRGlobal.G_GameSystem.CurPlayer, ref npos, ref cpos, ref flydir);
				}
			}
			if (VRGameSystem.CurGameModel == GameModel.GM_Multi)
			{
				foreach (Player value in PhotonNetwork.CurrentRoom.Players.Values)
				{
					if (value != PhotonNetwork.LocalPlayer)
					{
						photonView.RPC("UpdateData", value, base.transform.position, base.transform.rotation);
					}
				}
			}
			if (mExploded)
			{
				bool flag = true;
				ParticleSystem[] componentsInChildren = base.gameObject.GetComponentsInChildren<ParticleSystem>();
				for (int i = 0; i < componentsInChildren.Length; i++)
				{
					if (componentsInChildren[i].isPlaying)
					{
						flag = false;
					}
				}
				if (flag)
				{
					DestoryBullet();
				}
			}
		}
		return base.MyUpdate(delta);
	}

	[PunRPC]
	public void UpdateData(Vector3 pos, Quaternion qua)
	{
		base.transform.position = pos;
		base.transform.rotation = qua;
	}

	public void DestoryBullet()
	{
		if (VRGameSystem.CurGameModel == GameModel.GM_Single)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
		else if (VRGameSystem.CurGameModel == GameModel.GM_Multi)
		{
			photonView.RPC("RPCDestoryBullet", RpcTarget.All);
		}
	}

	[PunRPC]
	public void RPCDestoryBullet()
	{
		UnityEngine.Object.Destroy(base.gameObject);
	}

	protected bool hitTest(VRNpc tgtnpc, ref Vector3 npos, ref Vector3 cpos, ref Vector3 flydir)
	{
		CharacterController component = tgtnpc.GetComponent<CharacterController>();
		float num = 1f;
		if ((bool)component)
		{
			num = component.radius;
		}
		Vector3 position = tgtnpc.transform.position;
		bool flag = false;
		float num2 = num * num;
		if (Vector3.SqrMagnitude(npos - position) < num2 || Vector3.SqrMagnitude(cpos - position) < num2)
		{
			flag = true;
		}
		if (!flag)
		{
			Vector3 vector = position - cpos;
			vector.y = 0f;
			float num3 = vector.x * flydir.x + vector.z * flydir.z;
			float num4 = num3 * num3;
			float num5 = vector.x * vector.x + vector.z * vector.z;
			if (num2 + num4 >= num5)
			{
				Vector3 vector2 = position - npos;
				vector2.y = 0f;
				float num6 = vector2.x * flydir.x + vector2.z * flydir.z;
				if ((num3 >= 0f && num6 <= 0f) || (num6 >= 0f && num3 <= 0f))
				{
					flag = true;
				}
			}
		}
		if (flag)
		{
			mExploded = true;
			ParticleSystem[] componentsInChildren = base.gameObject.GetComponentsInChildren<ParticleSystem>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				componentsInChildren[i].Stop();
			}
			GameObject gameObject = UnityEngine.Object.Instantiate(mExplosionPrefab);
			if ((bool)gameObject)
			{
				gameObject.transform.position = base.gameObject.transform.position;
				UnityEngine.Object.Destroy(gameObject, 2f);
			}
			AudioSource component2 = base.gameObject.GetComponent<AudioSource>();
			if ((bool)component2)
			{
				component2.Play();
			}
			if (!pierce)
			{
				tgtnpc.OnDamage(bulletOwner.ATKFinal(ref tgtnpc, 1f), ref bulletOwner, sound: true, ref cpos);
				DestoryBullet();
				return true;
			}
			if (!hitList.Find((VRNpc npc) => npc == tgtnpc))
			{
				tgtnpc.OnDamage(bulletOwner.ATKFinal(ref tgtnpc, 1f), ref bulletOwner, sound: true, ref cpos);
				hitList.Add(tgtnpc);
			}
		}
		return false;
	}

	public virtual void fire(ref Vector3 inPos, ref Vector3 inDir, float inMoveSpace, float inMoveSpeed, EU_CAMP inCamp, VRNpc owner)
	{
		curMoveDist = 0f;
		moveSpace = inMoveSpace;
		moveSpeed = inMoveSpeed;
		m_startPosition = inPos;
		m_startDir = inDir;
		base.transform.position = m_startPosition;
		bulletOwner = owner;
		camp = inCamp;
		firstTest = true;
		mExploded = false;
		rotOpe = 0f;
	}

	public override bool MyReset()
	{
		hitList.Clear();
		return base.MyReset();
	}
}
public class VRBulletPhysic : VRGameEntity, IPunObservable
{
	protected VRNpc bulletOwner;

	protected bool pierce;

	protected List<VRNpc> hitList = new List<VRNpc>();

	private bool m_bCheckDestroyBullet;

	public float disappearTime = 3f;

	protected TrailRenderer trail;

	[Header("物理相关组件")]
	[SerializeField]
	private Rigidbody rig;

	private bool isUesd;

	public GameObject insertPrefab;

	[Header("Sync")]
	public PhotonView photonView;

	private Vector3 mPos;

	public bool Pierce
	{
		get
		{
			return pierce;
		}
		set
		{
			pierce = value;
		}
	}

	protected override bool MyAwake()
	{
		trail = base.gameObject.GetComponent<TrailRenderer>();
		if (!rig)
		{
			rig = base.gameObject.GetComponent<Rigidbody>();
		}
		if (VRGameSystem.CurGameModel == GameModel.GM_Multi && !photonView.IsMine && !rig.isKinematic)
		{
			rig.isKinematic = true;
		}
		return base.MyAwake();
	}

	public void VRSetActive(bool active)
	{
		if (VRGameSystem.CurGameModel == GameModel.GM_Single)
		{
			RPCSetActive(active);
		}
		if (VRGameSystem.CurGameModel == GameModel.GM_Multi)
		{
			photonView.RPC("RPCSetActive", RpcTarget.All, active);
		}
	}

	public override bool MyReset()
	{
		if (VRGameSystem.CurGameModel == GameModel.GM_Multi && !photonView.IsMine)
		{
			return false;
		}
		isUesd = false;
		hitList.Clear();
		return base.MyReset();
	}

	protected override bool MyUpdate(float delta)
	{
		if (VRGameSystem.CurGameModel == GameModel.GM_Multi && !photonView.IsMine)
		{
			if (!rig.isKinematic)
			{
				rig.isKinematic = true;
			}
			return true;
		}
		if (rig.velocity.magnitude > 5f)
		{
			base.transform.LookAt(base.transform.position + rig.velocity);
		}
		return base.MyUpdate(delta);
	}

	public void SetTrail(bool isOpen)
	{
		if ((bool)trail)
		{
			if (isOpen)
			{
				trail.Clear();
				trail.enabled = true;
			}
			else
			{
				trail.enabled = false;
			}
		}
	}

	public void DestroyStillBullet()
	{
		if (VRGameSystem.CurGameModel == GameModel.GM_Single)
		{
			RPCDestroyStillBullet();
		}
		if (VRGameSystem.CurGameModel == GameModel.GM_Multi)
		{
			photonView.RPC("RPCDestroyStillBullet", RpcTarget.All);
		}
	}

	public virtual void fire(ref Vector3 inPos, ref Vector3 inDir, float inMoveSpace, float inMoveSpeed, EU_CAMP inCamp, VRNpc owner)
	{
		SetTrail(isOpen: true);
		base.transform.position = inPos;
		bulletOwner = owner;
		camp = inCamp;
		ParticleSystem[] componentsInChildren = base.gameObject.GetComponentsInChildren<ParticleSystem>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].Play();
		}
		if ((bool)rig)
		{
			rig.useGravity = true;
			rig.isKinematic = false;
			rig.velocity = inDir * inMoveSpeed;
			CancelInvoke("DestroyStillBullet");
			Invoke("DestroyStillBullet", disappearTime);
		}
	}

	private void OnTriggerEnter(Collider otherobj)
	{
		if (isUesd || (VRGameSystem.CurGameModel == GameModel.GM_Multi && !photonView.IsMine))
		{
			return;
		}
		ParticleSystem[] componentsInChildren = base.gameObject.GetComponentsInChildren<ParticleSystem>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].Play();
		}
		if (!(otherobj.gameObject.tag == "enemy"))
		{
			return;
		}
		isUesd = true;
		VRNpc componentInParent = otherobj.gameObject.GetComponentInParent<VRNpc>();
		if (!componentInParent)
		{
			return;
		}
		VRBlink component = componentInParent.gameObject.GetComponent<VRBlink>();
		if (component == null || ((bool)component && component.mIsShow))
		{
			ShootNpc(componentInParent);
			if (pierce)
			{
				hitList.Add(componentInParent);
			}
			else if ((bool)trail)
			{
				trail.Clear();
				trail.enabled = false;
			}
		}
		DestroyStillBullet();
	}

	private void OnCollisionEnter(Collision otherobj)
	{
		if (isUesd || (VRGameSystem.CurGameModel == GameModel.GM_Multi && !photonView.IsMine))
		{
			return;
		}
		ParticleSystem[] componentsInChildren = base.gameObject.GetComponentsInChildren<ParticleSystem>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].Play();
		}
		bool flag = false;
		if (otherobj.gameObject.tag == "terrain")
		{
			isUesd = true;
			if ((bool)rig)
			{
				rig.Sleep();
				rig.useGravity = false;
				rig.detectCollisions = false;
			}
			if ((bool)trail)
			{
				trail.Clear();
				trail.enabled = false;
			}
		}
		else if (otherobj.gameObject.tag == "toukui")
		{
			isUesd = true;
			VRLogger.Log("射中头盔，无伤害");
			if ((bool)trail)
			{
				trail.Clear();
				trail.enabled = false;
			}
			if ((bool)rig)
			{
				rig.velocity *= 0.5f;
			}
			if ((bool)otherobj.gameObject.GetComponent<AudioSource>())
			{
				otherobj.gameObject.GetComponent<AudioSource>().Play();
			}
			if (otherobj.gameObject.tag == "waterhitsound")
			{
				DestroyStillBullet();
			}
			DropHelmet(otherobj);
		}
	}

	private void ShootNpc(VRNpc tgtnpc)
	{
		if (bulletOwner == null)
		{
			bulletOwner = VRGlobal.G_GameSystem.CurPlayer;
		}
		float dmgHP = bulletOwner.ATKFinal(ref tgtnpc, 1f);
		Vector3 pos = Vector3.zero;
		tgtnpc.OnDamage(dmgHP, ref bulletOwner, sound: true, ref pos);
	}

	private void DropHelmet(Collision otherobj)
	{
		if (otherobj != null && otherobj.gameObject.tag == "toukui")
		{
			VRBreakable component = otherobj.gameObject.GetComponent<VRBreakable>();
			if ((bool)component)
			{
				component.ExplodeFace();
			}
		}
	}

	public void SetParent(Transform parent)
	{
		base.transform.SetParent(parent);
	}

	public void SetLocalPosition(Vector3 pos)
	{
		base.transform.localPosition = pos;
	}

	public void SetLocalRotation(Quaternion qua)
	{
		base.transform.localRotation = qua;
	}

	public void SetRig(bool isKinematic, bool isUseGravity)
	{
		rig.isKinematic = isKinematic;
		rig.useGravity = isUseGravity;
	}

	public void DisableArrow()
	{
		if (VRGameSystem.CurGameModel == GameModel.GM_Single)
		{
			RPCDisableArrow();
		}
		if (VRGameSystem.CurGameModel == GameModel.GM_Multi)
		{
			photonView.RPC("RPCDisableArrow", RpcTarget.All);
		}
	}

	public void OnPhotonSerializeView(PhotonStream stream, PhotonMessageInfo info)
	{
		if (VRGameSystem.CurGameModel == GameModel.GM_Single)
		{
			return;
		}
		if (stream.IsWriting)
		{
			stream.SendNext(base.transform.position);
			stream.SendNext(base.transform.rotation);
			return;
		}
		mPos = (Vector3)stream.ReceiveNext();
		base.transform.position = Vector3.MoveTowards(base.transform.position, mPos, (mPos - base.transform.position).magnitude);
		base.transform.rotation = (Quaternion)stream.ReceiveNext();
		if ((bool)trail)
		{
			trail.enabled = true;
		}
	}

	[PunRPC]
	public void RPCSetActive(bool active)
	{
		base.gameObject.SetActive(active);
	}

	[PunRPC]
	public void RPCDestroyStillBullet()
	{
		if (base.gameObject.activeSelf)
		{
			if ((bool)rig)
			{
				rig.useGravity = true;
				rig.detectCollisions = true;
			}
			if ((bool)trail)
			{
				trail.Clear();
				trail.enabled = false;
			}
			VRGlobal.pushFreeEntity(base.gameObject);
		}
	}

	[PunRPC]
	public void RPCDisableArrow()
	{
		SetParent(null);
		UnityEngine.Object.Destroy(base.gameObject);
	}
}
public class VRCaoDui : VRNpc
{
	protected bool exp;

	private float expTimer;

	private Light lit;

	public bool bCanAttack;

	protected override bool MyAwake()
	{
		exp = false;
		m_animation = GetComponent<Animation>();
		base.Camp = EU_CAMP.EU_BAD;
		VRGlobal.interActiveLib.Add(this);
		lit = base.gameObject.GetComponentInChildren<Light>();
		base.gameObject.GetComponent<BoxCollider>().enabled = false;
		return true;
	}

	protected override bool MyUpdate(float delta)
	{
		if (exp)
		{
			expTimer -= delta;
			if (expTimer <= 0f)
			{
				expTimer = 0f;
				lit.enabled = false;
				VRGlobal.interActiveLib.Remove(this);
			}
			lit.intensity = 8f * (expTimer * 2f - (float)(int)(expTimer * 2f));
			if (expTimer <= 0f)
			{
				base.gameObject.SetActive(value: false);
			}
		}
		return true;
	}

	private void Damage()
	{
		if (exp)
		{
			return;
		}
		m_fCurHP = 0f;
		ParticleSystem[] componentsInChildren = base.gameObject.GetComponentsInChildren<ParticleSystem>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].Play();
		}
		AudioSource component = base.gameObject.GetComponent<AudioSource>();
		if (component != null)
		{
			component.Play();
		}
		m_animation.CrossFade("meiqiguandonghua", 0f);
		exp = true;
		base.BDamaged = true;
		CharacterController component2 = GetComponent<CharacterController>();
		if ((bool)component2)
		{
			component2.enabled = false;
		}
		VRNpc killer = null;
		for (int j = 0; j < VRGlobal.interActiveLib.Count; j++)
		{
			VRNpc vRNpc = VRGlobal.interActiveLib[j];
			if (EU_CAMP.EU_BAD == vRNpc.Camp && vRNpc != this && !vRNpc.BDamaged && (vRNpc.transform.position - base.transform.position).sqrMagnitude <= atkRange * atkRange)
			{
				Vector3 pos = vRNpc.transform.position;
				vRNpc.FDelayTime = UnityEngine.Random.Range(0.5f, 1.5f);
				vRNpc.OnDamage(vRNpc.Hp * base.Atk, ref killer, sound: false, ref pos);
			}
		}
		lit.enabled = true;
		expTimer = 6.5f;
		base.gameObject.GetComponent<BoxCollider>().enabled = true;
	}

	public override bool OnDamage(float dmgHP, ref VRNpc killer, bool sound, ref Vector3 pos, bool isAwarded = false)
	{
		if (bCanAttack)
		{
			Invoke("Damage", fDelayTime);
		}
		return true;
	}

	private void OnTriggerEnter(Collider other)
	{
		VRNpc vRNpc = other.gameObject.GetComponent<VRGameEntity>() as VRNpc;
		if ((bool)vRNpc && EU_CAMP.EU_BAD == vRNpc.Camp && vRNpc.Hp > 0f)
		{
			vRNpc.OnFireTime = 3f;
		}
	}
}
public class VRCheckPoint : MonoBehaviour
{
	public GameObject needShowTerrain;

	public GameObject[] showObjs;

	private static float finishTimer;

	private float finishDelayTime;

	public GameObject nextCheckPoint;

	public GameObject startTrigger;

	protected VRTrigger curTrigger;

	protected bool activeFlag;

	public GameObject mNeedHideFog;

	[HideInInspector]
	public bool mIsFinish;

	public VRTrigger CurTrigger
	{
		get
		{
			return curTrigger;
		}
		set
		{
			curTrigger = value;
		}
	}

	public bool ActiveFlag
	{
		get
		{
			return activeFlag;
		}
		set
		{
			activeFlag = value;
		}
	}

	private void Awake()
	{
		finishTimer = 0f;
	}

	private void Start()
	{
		base.gameObject.SetActive(value: false);
		base.gameObject.GetComponent<MeshRenderer>().enabled = false;
		if ((bool)needShowTerrain)
		{
			needShowTerrain.SetActive(value: false);
		}
		if (showObjs != null)
		{
			for (int i = 0; i < showObjs.Length; i++)
			{
				showObjs[i].SetActive(value: false);
			}
		}
		for (int j = 0; j < base.transform.childCount; j++)
		{
			Transform child = base.transform.GetChild(j);
			if (child.gameObject.activeSelf)
			{
				child.gameObject.SetActive(value: false);
			}
		}
		if (startTrigger != null)
		{
			startTrigger.GetComponent<MeshRenderer>().enabled = false;
			VRTrigger component = startTrigger.GetComponent<VRTrigger>();
			if (component != null)
			{
				component.theCheckPoint = this;
			}
		}
		for (int k = 0; k < base.transform.childCount; k++)
		{
			Transform child2 = base.transform.GetChild(k);
			if (child2.name.Contains("Warn"))
			{
				GameObject obj = child2.gameObject;
				obj.SetActive(value: false);
				obj.GetComponent<MeshRenderer>().enabled = false;
			}
		}
	}

	private void Update()
	{
		if (VRGlobal.G_GameSystem.isPause || !ActiveFlag)
		{
			return;
		}
		bool flag = true;
		for (int i = 0; i < base.transform.childCount; i++)
		{
			if (base.transform.GetChild(i).gameObject.activeSelf)
			{
				flag = false;
				break;
			}
		}
		if (!flag || VRGlobal.G_GameSystem.IsHasBossSpwanMonster)
		{
			return;
		}
		mIsFinish = true;
		if (nextCheckPoint != null)
		{
			for (int j = 0; j < base.transform.childCount; j++)
			{
				Transform child = base.transform.GetChild(j);
				if (child.name.Contains("Warn"))
				{
					GameObject obj = child.gameObject;
					obj.SetActive(value: false);
					obj.GetComponent<MeshRenderer>().enabled = false;
				}
				ActiveFlag = false;
			}
		}
		else
		{
			finishTimer += Time.deltaTime;
			if (finishTimer > finishDelayTime)
			{
				ActiveFlag = false;
			}
		}
		VRGameSystem.CurGameState = GameState.GS_PreStage;
	}

	public void ShowTerrain()
	{
		if ((bool)needShowTerrain)
		{
			needShowTerrain.SetActive(value: true);
			AudioSource component = needShowTerrain.GetComponent<AudioSource>();
			if ((bool)component)
			{
				component.Play();
			}
			if ((bool)mNeedHideFog)
			{
				mNeedHideFog.SetActive(value: false);
			}
		}
		if (showObjs != null)
		{
			for (int i = 0; i < showObjs.Length; i++)
			{
				showObjs[i].SetActive(value: true);
			}
		}
	}

	public virtual bool startCheckPoint()
	{
		VRGameSystem.CurGameState = GameState.GS_Stage;
		VRGlobal.G_GameSystem.CurCheckPoint = this;
		VRGlobal.G_GameSystem.uiManager.ShowStage(bShow: false);
		VRGameSystem g_GameSystem = VRGlobal.G_GameSystem;
		int curStageID = g_GameSystem.CurStageID + 1;
		g_GameSystem.CurStageID = curStageID;
		if (VRGameSystem.CurGameModel == GameModel.GM_Single)
		{
			if (VRGlobal.G_GameSystem.CurStageID == 7)
			{
				VRGlobal.G_GameSystem.weaponManager.equipWeapon(WeaponType.WT_Crossbow);
			}
		}
		else if (VRGameSystem.CurGameModel == GameModel.GM_Multi)
		{
			VRGlobal.G_GameSystem.StageUnlockObject(VRGlobal.G_GameSystem.CurStageID);
		}
		return realStartCheckPoint();
	}

	public bool realStartCheckPoint()
	{
		ActiveFlag = true;
		base.gameObject.SetActive(value: true);
		if (startTrigger != null)
		{
			startTrigger.SetActive(value: true);
			curTrigger = startTrigger.GetComponent<VRTrigger>();
			curTrigger.ResetNpc();
		}
		return true;
	}

	public void killAllMonster(ref VRNpc killer)
	{
		if (ActiveFlag)
		{
			for (int i = 0; i < VRGlobal.npcLib.Count; i++)
			{
				VRMonster component = VRGlobal.npcLib[i].GetComponent<VRMonster>();
				if ((bool)component)
				{
					Vector3 pos = Vector3.zero;
					component.OnDamage(component.CurHP, ref killer, sound: true, ref pos);
				}
				VRBoss component2 = VRGlobal.npcLib[i].GetComponent<VRBoss>();
				if ((bool)component2)
				{
					Vector3 pos2 = Vector3.zero;
					component2.OnDamage(component2.CurHP, ref killer, sound: true, ref pos2);
				}
			}
		}
		VRGlobal.npcLib.Clear();
	}
}
public class VRCheckPointController : MonoBehaviour
{
	public VRCheckPoint firstCheckPoint;

	public void StartFirstLevel()
	{
		if ((bool)firstCheckPoint)
		{
			firstCheckPoint.startCheckPoint();
		}
	}
}
public class VRDestroyObjTimer
{
	public float mTimer;

	public GameObject mGameObj;

	public VRDestroyObjTimer(GameObject go, float times)
	{
		mTimer = times;
		mGameObj = go;
	}
}
public class VRFreeLib
{
	public Queue<GameObject> freeActorLib = new Queue<GameObject>();
}
public class VRGameEntity : VRGameObject
{
	protected EU_CAMP camp;

	protected bool show;

	public EU_CAMP Camp
	{
		get
		{
			return camp;
		}
		set
		{
			camp = value;
		}
	}

	public bool Show => show;

	public override bool MyReset()
	{
		show = true;
		return base.MyReset();
	}

	public override bool MyHide()
	{
		show = false;
		return base.MyHide();
	}
}
public class VRGameObject : MonoBehaviour
{
	private void Start()
	{
		MyStart();
	}

	private void Update()
	{
		MyUpdate(Time.deltaTime);
	}

	private void Awake()
	{
		MyAwake();
	}

	private void LateUpdate()
	{
		MyLateUpdate();
	}

	protected virtual bool MyAwake()
	{
		return true;
	}

	protected virtual bool MyStart()
	{
		MyReset();
		return true;
	}

	protected virtual bool MyUpdate(float delta)
	{
		return true;
	}

	public virtual bool MyReset()
	{
		return true;
	}

	public virtual bool MyHide()
	{
		return true;
	}

	public virtual bool MyDestroy()
	{
		UnityEngine.Object.Destroy(base.gameObject);
		return true;
	}

	public virtual void MyLateUpdate()
	{
	}
}
public enum GameState
{
	GS_NeebieGuide,
	GS_PreStage,
	GS_Stage,
	GS_Fail,
	GS_Boss,
	GS_Finish,
	GS_End
}
public enum GameModel
{
	GM_Single,
	GM_Multi
}
public enum DifficultyLevel
{
	DL_Easy = 1,
	DL_Difficult
}
public enum SceneStyleType
{
	ST_DayTime_Normal,
	ST_Dusk_Normal,
	ST_Night_Normal,
	ST_DayTime_Darker,
	ST_Dusk_Darker,
	ST_Night_Darker,
	ST_DayTime_Dim,
	ST_Dusk_Dim,
	ST_Night_Dim
}
public enum PathType
{
	Left,
	Centre,
	Right
}
[Serializable]
public class PathShuiJing
{
	public PathType pathType;

	public List<GameObject> shuijingList;
}
[Serializable]
public class ShuiJingList
{
	public List<PathShuiJing> shuijingList;

	public PathShuiJing this[PathType pathType]
	{
		get
		{
			for (int i = 0; i < shuijingList.Count; i++)
			{
				if (shuijingList[i].pathType == pathType)
				{
					return shuijingList[i];
				}
			}
			return null;
		}
	}
}
[Serializable]
public struct GameObjectInt
{
	public int index;

	public GameObject go;
}
public class VRGameSystem : VRActor
{
	private static GameModel _curModel = GameModel.GM_Single;

	private static GameState _curGameState = GameState.GS_PreStage;

	public static bool bIsFirstPlay = true;

	private static bool _gameIsReady = false;

	public GameObject DynSceneObj;

	public VRUIManager uiManager;

	public VRNewbieGuideMgr guideMgr;

	public HarmViewController viewController;

	public GameObject soundObject;

	public VRCheckPoint firstCheckPoint;

	public ShuiJingList shuijingList;

	public List<GameObject> bossHatchMonster = new List<GameObject>();

	public bool IsHasBossSpwanMonster;

	public SceneStyleManager sceneStyleManager;

	public SystemLanguage language = SystemLanguage.Chinese;

	public bool showFPS;

	public int nMaxStageNum = 4;

	public GameObject[] keyExplain;

	public PhotonView photonView;

	public string weaponManagerPrefabName;

	public bool localPlayerIsDie;

	public List<GameObject> gameStartTips = new List<GameObject>();

	private float m_fClearTimer;

	private string mCurBgMusicName = "";

	private bool mCanCheckGameFinish;

	private bool mIsFirstPreStage = true;

	private UnityXR_ButtonHandler pauseKey;

	private static int readyPlayer = 0;

	private GameObject plyFire;

	[SerializeField]
	private VRPlayer m_CurPlayer;

	[SerializeField]
	private VRNpc m_Gate;

	private int m_nCurStageID;

	private VRCheckPoint curCheckPoint;

	private int gainScore;

	[SerializeField]
	private List<int> switchStyleLevel = new List<int>();

	[SerializeField]
	private GameObjectInt[] stageUnlocks;

	[HideInInspector]
	public float MonsterHPBase = 1f;

	[HideInInspector]
	public float MonsterATKBase = 1f;

	[HideInInspector]
	public float MonsterSpeedBase = 1f;

	[HideInInspector]
	public float MonsterBulletBase = 1f;

	[HideInInspector]
	public bool isPause;

	public static GameModel CurGameModel
	{
		get
		{
			return _curModel;
		}
		set
		{
			_curModel = value;
		}
	}

	public static GameState CurGameState
	{
		get
		{
			return _curGameState;
		}
		set
		{
			_curGameState = value;
		}
	}

	public static bool GameIsReady
	{
		get
		{
			return _gameIsReady;
		}
		set
		{
			_gameIsReady = value;
		}
	}

	public static bool IsMasterClient { get; set; }

	public GameObject PlyFire
	{
		get
		{
			return plyFire;
		}
		set
		{
			plyFire = value;
		}
	}

	public VRPlayer CurPlayer => m_CurPlayer;

	public VRNpc Gate
	{
		get
		{
			return m_Gate;
		}
		set
		{
			m_Gate = value;
		}
	}

	public int CurStageID
	{
		get
		{
			return m_nCurStageID;
		}
		set
		{
			m_nCurStageID = value;
		}
	}

	public VRCheckPoint CurCheckPoint
	{
		get
		{
			return curCheckPoint;
		}
		set
		{
			curCheckPoint = value;
		}
	}

	public int GainScore
	{
		get
		{
			return gainScore;
		}
		set
		{
			gainScore = value;
		}
	}

	public WeaponManager weaponManager { get; private set; }

	protected override bool MyAwake()
	{
		VRGlobal.G_GameSystem = this;
		language = VRGlobal.G_Language;
		IsMasterClient = CurGameModel == GameModel.GM_Single || PhotonNetwork.IsMasterClient;
		plyFire = Resources.Load(VRGlobal.GetEffectPath("PlyFire")) as GameObject;
		if (m_CurPlayer == null)
		{
			m_CurPlayer = GameObject.FindWithTag("Player").GetComponent<VRPlayer>();
		}
		initPlayerProperties();
		InitSpawnDynSceneObj();
		initWeapon();
		if (CurGameModel == GameModel.GM_Multi)
		{
			ScenePhotonController.Instance.InitLevel();
		}
		for (int i = 0; i < stageUnlocks.Length; i++)
		{
			stageUnlocks[i].go.SetActive(value: false);
		}
		SetDifficultyLevel(VRGlobal.mDifficulty);
		if ((bool)guideMgr && guideMgr.gameObject.activeSelf)
		{
			guideMgr.gameObject.SetActive(value: false);
		}
		return base.MyAwake();
	}

	private void OnEnable()
	{
		if (pauseKey == null)
		{
			pauseKey = UnityXR_Controller.Instance.InputSys.GetInputHandler(XRDeviceType.DT_Left, XRKeyType.Menu) as UnityXR_ButtonHandler;
		}
		pauseKey.OnButtonDown += OnGamePause;
	}

	private void OnDisable()
	{
		if ((bool)pauseKey)
		{
			pauseKey.OnButtonDown -= OnGamePause;
		}
	}

	protected override bool MyStart()
	{
		if (CurGameModel == GameModel.GM_Multi)
		{
			photonView.RPC("PlayerJoinScene", RpcTarget.AllBuffered);
		}
		for (int i = 0; i < gameStartTips.Count; i++)
		{
			if (!gameStartTips[i].activeSelf)
			{
				gameStartTips[i].SetActive(value: true);
			}
		}
		Invoke("HideGameStartTips", 6f);
		return true;
	}

	protected override bool MyUpdate(float delta)
	{
		if (CurGameModel == GameModel.GM_Multi)
		{
			if (!GameIsReady)
			{
				if ((bool)uiManager)
				{
					uiManager.ShowTips(bShow: true, "等待其他玩家加入游戏", bAutoClose: false);
				}
				return false;
			}
			if (!PhotonNetwork.IsConnected || !PhotonNetwork.InRoom || IsMasterClient != PhotonNetwork.IsMasterClient)
			{
				SceneManager.LoadScene(0);
				return false;
			}
		}
		else if (CurGameModel == GameModel.GM_Single && !GameIsReady)
		{
			return false;
		}
		if (Input.GetKeyDown(KeyCode.P))
		{
			UnityEngine.Debug.LogError(PlayerPrefs.GetInt("playerScore", 0));
		}
		switch (CurGameState)
		{
		case GameState.GS_NeebieGuide:
			OnNewBieGuide();
			break;
		case GameState.GS_PreStage:
			OnPreStage();
			break;
		case GameState.GS_Stage:
			OnStage();
			break;
		case GameState.GS_Fail:
			OnGameFailed();
			break;
		case GameState.GS_Finish:
			OnGameFinish();
			break;
		}
		SetHandRay(isShowHandRay());
		CheckGameFinish();
		manageBgMusic();
		TickClear(delta);
		return base.MyUpdate(delta);
	}

	public static void GameReset(GameModel model, GameState initState)
	{
		switch (model)
		{
		case GameModel.GM_Single:
			GameIsReady = true;
			break;
		case GameModel.GM_Multi:
			GameIsReady = false;
			break;
		}
		readyPlayer = 0;
		CurGameModel = model;
		CurGameState = initState;
	}

	private void HideGameStartTips()
	{
		for (int i = 0; i < gameStartTips.Count; i++)
		{
			if (gameStartTips[i].activeSelf)
			{
				gameStartTips[i].SetActive(value: false);
			}
		}
	}

	public void SetDifficultyLevel(DifficultyLevel level)
	{
		switch (level)
		{
		case DifficultyLevel.DL_Easy:
			if (CurGameModel == GameModel.GM_Single)
			{
				MonsterHPBase = 0.5f;
				MonsterATKBase = 1f;
				MonsterSpeedBase = 1f;
				MonsterBulletBase = 1f;
			}
			else if (CurGameModel == GameModel.GM_Multi)
			{
				MonsterHPBase = 1f;
				MonsterATKBase = 1.5f;
				MonsterSpeedBase = 1.2f;
				MonsterBulletBase = 1f;
			}
			break;
		case DifficultyLevel.DL_Difficult:
			if (CurGameModel == GameModel.GM_Single)
			{
				MonsterHPBase = 1f;
				MonsterATKBase = 1.5f;
				MonsterSpeedBase = 1.2f;
				MonsterBulletBase = 1f;
			}
			else if (CurGameModel == GameModel.GM_Multi)
			{
				MonsterHPBase = 1.8f;
				MonsterATKBase = 2f;
				MonsterSpeedBase = 1.4f;
				MonsterBulletBase = 1f;
			}
			break;
		}
	}

	private void OnNewBieGuide()
	{
		if ((bool)guideMgr && !guideMgr.gameObject.activeSelf)
		{
			guideMgr.gameObject.SetActive(value: true);
		}
		if (uiManager != null)
		{
			uiManager.ShowPanel(0, isShow: false);
		}
		for (int i = 0; i < keyExplain.Length; i++)
		{
			keyExplain[i].SetActive(value: true);
		}
	}

	private void OnPreStage()
	{
		if (isPause)
		{
			return;
		}
		if ((bool)guideMgr && guideMgr.gameObject.activeSelf)
		{
			guideMgr.gameObject.SetActive(value: false);
		}
		if (CurStageID < nMaxStageNum)
		{
			if (uiManager != null)
			{
				uiManager.ShowStage(bShow: true, CurStageID + 1);
			}
			if ((bool)guideMgr && CurStageID == 0 && (bool)sceneStyleManager)
			{
				sceneStyleManager.ResetStyle();
			}
			if (mIsFirstPreStage && (bool)CurCheckPoint && CurCheckPoint.mIsFinish)
			{
				if (switchStyleLevel.Any((int l) => l == CurStageID) && (bool)sceneStyleManager)
				{
					sceneStyleManager.EnterNextStyle();
				}
				if (!IsInvoking("ShowTerrain"))
				{
					Invoke("ShowTerrain", 1f);
					mIsFirstPreStage = false;
				}
			}
			if (!IsInvoking("OnStage"))
			{
				Invoke("OnStage", 3f);
			}
		}
		else
		{
			mCanCheckGameFinish = true;
		}
		if (uiManager != null)
		{
			uiManager.ShowPanel(0, isShow: false);
		}
		for (int i = 0; i < keyExplain.Length; i++)
		{
			keyExplain[i].SetActive(value: false);
		}
	}

	private void OnStage()
	{
		mIsFirstPreStage = true;
		CurGameState = GameState.GS_Stage;
		if (uiManager != null)
		{
			uiManager.ShowStage(bShow: false);
		}
		if ((bool)CurCheckPoint)
		{
			if (!CurCheckPoint.ActiveFlag && (bool)CurCheckPoint.nextCheckPoint)
			{
				CurCheckPoint.nextCheckPoint.GetComponent<VRCheckPoint>().startCheckPoint();
			}
		}
		else
		{
			StartStage();
		}
		GMDebug();
		if (m_Gate.CurHP <= 0f || PlayerIsDead())
		{
			CurGameState = GameState.GS_Fail;
			weaponManager.equipWeapon(WeaponType.WT_None);
		}
	}

	public bool PlayerIsDead()
	{
		if (CurGameModel == GameModel.GM_Single)
		{
			return VRGlobal.G_GameSystem.CurPlayer.CurHP <= 0f;
		}
		_ = CurGameModel;
		_ = 1;
		return false;
	}

	public void OnGameFinish()
	{
		GMDebug_KillAllMonster();
		if ((bool)CurCheckPoint)
		{
			if ((bool)CurCheckPoint.CurTrigger)
			{
				if (CurCheckPoint.CurTrigger.haveNextTrigger())
				{
					CurCheckPoint.CurTrigger.nextTrigger = null;
				}
				CurCheckPoint.CurTrigger = null;
			}
			CurCheckPoint.nextCheckPoint = null;
			CurCheckPoint = null;
		}
		GameObject gameObject = GameObject.FindGameObjectWithTag("weaponcrossbow");
		if ((bool)gameObject)
		{
			gameObject.SetActive(value: false);
		}
		GameObject[] array = GameObject.FindGameObjectsWithTag("BulletBowArrow");
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(value: false);
		}
		GameObject gameObject2 = GameObject.FindGameObjectWithTag("weaponbow");
		if ((bool)gameObject2)
		{
			gameObject2.SetActive(value: false);
		}
		GameObject[] array2 = GameObject.FindGameObjectsWithTag("throwitem");
		foreach (GameObject gameObject3 in array2)
		{
			if ((bool)gameObject3)
			{
				gameObject3.SetActive(value: false);
			}
		}
		if (VRGlobal.mDifficulty == DifficultyLevel.DL_Easy && bIsFirstPlay)
		{
			if (uiManager != null)
			{
				string text = SetRichTextSizeStr(LTLocalization.GetText("恭喜你游戏通关啦解锁了新难度哦"), 18);
				if (CurGameModel == GameModel.GM_Single)
				{
					text += "\n\n";
					if (!PlayerPrefs.HasKey("MaxScore"))
					{
						PlayerPrefs.SetInt("MaxScore", VRGlobal.G_GameSystem.GainScore);
					}
					if (VRGlobal.G_GameSystem.GainScore > PlayerPrefs.GetInt("MaxScore"))
					{
						PlayerPrefs.SetInt("MaxScore", VRGlobal.G_GameSystem.GainScore);
					}
					int @int = PlayerPrefs.GetInt("MaxScore");
					string value = SetRichTextSizeStr(LTLocalization.GetText("历史最高分") + " " + @int, 10) + "\n";
					value = SetRichTextColorStr(value, "#FF9000FF");
					text += value;
					string value2 = SetRichTextSizeStr(LTLocalization.GetText("本次得分") + " " + VRGlobal.G_GameSystem.GainScore, 20);
					value2 = SetRichTextColorStr(value2, "#FFFF00FF");
					text += value2;
				}
				uiManager.ShowTips(bShow: true, text, bAutoClose: false);
				if (PlayerPrefs.GetString("difficulty", "false").Equals("false"))
				{
					PlayerPrefs.SetString("difficulty", "true");
				}
			}
		}
		else if (uiManager != null)
		{
			string text2 = SetRichTextSizeStr(LTLocalization.GetText("恭喜你游戏通关啦"), 18);
			if (CurGameModel == GameModel.GM_Single)
			{
				text2 += "\n\n";
				if (!PlayerPrefs.HasKey("MaxScore"))
				{
					PlayerPrefs.SetInt("MaxScore", VRGlobal.G_GameSystem.GainScore);
				}
				if (VRGlobal.G_GameSystem.GainScore > PlayerPrefs.GetInt("MaxScore"))
				{
					PlayerPrefs.SetInt("MaxScore", VRGlobal.G_GameSystem.GainScore);
				}
				int int2 = PlayerPrefs.GetInt("MaxScore");
				string value3 = SetRichTextSizeStr(LTLocalization.GetText("历史最高分") + " " + int2, 10) + "\n";
				value3 = SetRichTextColorStr(value3, "#FF9000FF");
				text2 += value3;
				string value4 = SetRichTextSizeStr(LTLocalization.GetText("本次得分") + " " + VRGlobal.G_GameSystem.GainScore, 20);
				value4 = SetRichTextColorStr(value4, "#FFFF00FF");
				text2 += value4;
			}
			uiManager.ShowTips(bShow: true, text2, bAutoClose: false);
		}
		if (uiManager != null)
		{
			uiManager.ShowPanel(2, isShow: true);
		}
		weaponManager.equipWeapon(WeaponType.WT_None);
		CurGameState = GameState.GS_End;
	}

	public void OnGamePause(XRController controller)
	{
		if (GameIsReady && CurGameState != 0 && CurGameState != GameState.GS_Fail && CurGameState != GameState.GS_End && CurGameState != GameState.GS_Finish)
		{
			if (CurGameModel == GameModel.GM_Single)
			{
				GamePause();
			}
			else if (!localPlayerIsDie)
			{
				photonView.RPC("GamePause", RpcTarget.All);
			}
		}
	}

	public void OnGameContinue()
	{
		isPause = false;
		for (int i = 0; i < weaponManager.crossBow.Count; i++)
		{
			weaponManager.crossBow[i].gameObject.SetActive(value: true);
		}
		if ((bool)weaponManager.bow)
		{
			weaponManager.bow.gameObject.SetActive(value: true);
		}
		if ((bool)uiManager)
		{
			uiManager.CloseTips();
			uiManager.ShowPanel(1, isShow: false);
		}
	}

	private void OnGameFailed()
	{
		viewController.OnDieView(isDie: true);
		GMDebug_KillAllMonster();
		if ((bool)CurCheckPoint)
		{
			CurCheckPoint.transform.parent.gameObject.SetActive(value: false);
		}
		if ((bool)weaponManager)
		{
			weaponManager.equipWeapon(WeaponType.WT_None);
		}
		GameObject[] array = GameObject.FindGameObjectsWithTag("throwitem");
		foreach (GameObject gameObject in array)
		{
			if ((bool)gameObject)
			{
				gameObject.SetActive(value: false);
			}
		}
		if (!(uiManager != null))
		{
			return;
		}
		string text = SetRichTextSizeStr(LTLocalization.GetText("很遗憾你输啦"), 18);
		if (CurGameModel == GameModel.GM_Single)
		{
			text += "\n\n";
			if (!PlayerPrefs.HasKey("MaxScore"))
			{
				PlayerPrefs.SetInt("MaxScore", VRGlobal.G_GameSystem.GainScore);
			}
			if (VRGlobal.G_GameSystem.GainScore > PlayerPrefs.GetInt("MaxScore"))
			{
				PlayerPrefs.SetInt("MaxScore", VRGlobal.G_GameSystem.GainScore);
			}
			int @int = PlayerPrefs.GetInt("MaxScore");
			string value = SetRichTextSizeStr(LTLocalization.GetText("历史最高分") + " " + @int, 10) + "\n";
			value = SetRichTextColorStr(value, "#FF9000FF");
			text += value;
			string value2 = SetRichTextSizeStr(LTLocalization.GetText("本次得分") + " " + VRGlobal.G_GameSystem.GainScore, 20);
			value2 = SetRichTextColorStr(value2, "#FF9000FF");
			text += value2;
		}
		uiManager.ShowTips(bShow: true, text, bAutoClose: false);
		uiManager.ShowPanel(2, isShow: true);
	}

	private void StartStage()
	{
		if (CurGameModel == GameModel.GM_Single)
		{
			if ((bool)firstCheckPoint)
			{
				firstCheckPoint.startCheckPoint();
			}
		}
		else if (CurGameModel == GameModel.GM_Multi)
		{
			photonView.RPC("StartLevel", RpcTarget.All);
		}
	}

	[PunRPC]
	public void StartLevel()
	{
		if ((bool)ScenePhotonController.Instance.LevelController)
		{
			ScenePhotonController.Instance.LevelController.StartFirstLevel();
		}
	}

	[PunRPC]
	private void GamePause()
	{
		isPause = !isPause;
		if (isPause)
		{
			for (int i = 0; i < weaponManager.crossBow.Count; i++)
			{
				weaponManager.crossBow[i].gameObject.SetActive(value: false);
			}
			if ((bool)weaponManager.bow)
			{
				weaponManager.bow.gameObject.SetActive(value: false);
			}
		}
		else
		{
			for (int j = 0; j < weaponManager.crossBow.Count; j++)
			{
				weaponManager.crossBow[j].gameObject.SetActive(value: true);
			}
			if ((bool)weaponManager.bow)
			{
				weaponManager.bow.gameObject.SetActive(value: true);
			}
		}
		if ((bool)uiManager)
		{
			string text = Regex.Unescape(LTLocalization.GetText("游戏暂停中"));
			uiManager.ShowTips(isPause, text + "...", bAutoClose: false);
			uiManager.ShowPanel(1, isPause);
		}
	}

	[PunRPC]
	public void PlayerJoinScene()
	{
		readyPlayer++;
		if (readyPlayer >= PhotonNetwork.CurrentRoom.PlayerCount)
		{
			GameIsReady = true;
			UnityEngine.Debug.Log("所有玩家都准备好了");
			if ((bool)VRGlobal.G_GameSystem && (bool)VRGlobal.G_GameSystem.uiManager)
			{
				VRGlobal.G_GameSystem.uiManager.CloseTips();
			}
		}
	}

	private void ShowTerrain()
	{
		if ((bool)CurCheckPoint && (bool)CurCheckPoint.nextCheckPoint)
		{
			VRCheckPoint component = CurCheckPoint.nextCheckPoint.GetComponent<VRCheckPoint>();
			if ((bool)component)
			{
				component.ShowTerrain();
			}
		}
	}

	public string SetRichTextColorStr(string value, string hexColor)
	{
		return "<color=" + hexColor + ">" + value + "</color>";
	}

	public string SetRichTextSizeStr(string value, int size)
	{
		return "<size=" + size + ">" + value + "</size>";
	}

	public void SetHandRay(bool isShow)
	{
		UnityXR_Controller.Instance.HandleSys.ModelActive(XRDeviceType.DT_Left, isShow, showModel: false);
		UnityXR_Controller.Instance.HandleSys.ModelActive(XRDeviceType.DT_Right, isShow, showModel: false);
		UnityXR_Controller.Instance.HandleSys.RayActive(XRDeviceType.DT_Left, isShow: false);
		if (CurGameModel == GameModel.GM_Multi)
		{
			if (isPause || CurGameState == GameState.GS_Fail || CurGameState == GameState.GS_End || CurGameState == GameState.GS_Finish)
			{
				UnityXR_Controller.Instance.HandleSys.RayActive(XRDeviceType.DT_Right, isShow: true);
			}
			else
			{
				UnityXR_Controller.Instance.HandleSys.RayActive(XRDeviceType.DT_Right, isShow: false);
			}
		}
		else
		{
			UnityXR_Controller.Instance.HandleSys.RayActive(XRDeviceType.DT_Right, isShow);
		}
	}

	private bool isShowHandRay()
	{
		if (CurGameModel == GameModel.GM_Single)
		{
			if (!isPause && CurGameState != GameState.GS_Fail && CurGameState != GameState.GS_End)
			{
				return CurGameState == GameState.GS_Finish;
			}
			return true;
		}
		if (CurGameModel == GameModel.GM_Multi)
		{
			if (!isPause && !VRGlobal.G_GameSystem.localPlayerIsDie && CurGameState != GameState.GS_Fail && CurGameState != GameState.GS_End)
			{
				return CurGameState == GameState.GS_Finish;
			}
			return true;
		}
		return false;
	}

	private void CheckGameFinish()
	{
		if (CurGameState == GameState.GS_Finish || CurGameState == GameState.GS_End || !mCanCheckGameFinish)
		{
			return;
		}
		bool flag = true;
		for (int i = 0; i < VRGlobal.npcLib.Count; i++)
		{
			VRMonster component = VRGlobal.npcLib[i].GetComponent<VRMonster>();
			if ((bool)component && component.CurHP > 0f)
			{
				flag = false;
			}
		}
		if (flag)
		{
			CurGameState = GameState.GS_Finish;
			weaponManager.equipWeapon(WeaponType.WT_None);
		}
	}

	protected void TickClear(float delta)
	{
	}

	private void initPlayerProperties()
	{
		if ((bool)CurPlayer)
		{
			CurPlayer.Atk = 718f;
			CurPlayer.AtkType = 1;
			CurPlayer.PhyDefBite = 0f;
			CurPlayer.PhyDef = 0f;
			CurPlayer.MagDefBite = 0f;
			CurPlayer.MagDef = 0f;
			CurPlayer.Critic = 0f;
			CurPlayer.CriticReduce = 0f;
			CurPlayer.Doom = 0f;
			CurPlayer.Miss = 0f;
			CurPlayer.Absorb = 0f;
			CurPlayer.DamageBack = 0f;
			CurPlayer.Reel = 0f;
			CurPlayer.ReelReduce = 0f;
			CurPlayer.StopPower = 0f;
			localPlayerIsDie = false;
		}
	}

	private void initWeapon()
	{
		if (CurGameModel == GameModel.GM_Single)
		{
			GameObject gameObject = GameObject.FindGameObjectWithTag("WeaponManager");
			weaponManager = gameObject.GetComponent<WeaponManager>();
		}
		else
		{
			GameObject gameObject2 = PhotonNetwork.Instantiate(weaponManagerPrefabName, Vector3.zero, Quaternion.identity, 0);
			weaponManager = gameObject2.GetComponent<WeaponManager>();
		}
		if ((bool)weaponManager)
		{
			weaponManager.Init();
		}
	}

	protected void playAudio(string str, float fVolume = 1f, bool bLoop = false)
	{
		AudioClip audioClip = (AudioClip)Resources.Load("Actor/Sound/" + str, typeof(AudioClip));
		if ((bool)audioClip)
		{
			PlayAudioClip(audioClip, fVolume, bLoop);
		}
	}

	protected void PlayAudioClip(AudioClip clip, float fVolume, bool bLoop)
	{
		if (!(clip == null) && !(soundObject == null))
		{
			AudioSource audioSource = (AudioSource)soundObject.GetComponent("AudioSource");
			if (audioSource == null)
			{
				audioSource = soundObject.AddComponent<AudioSource>();
			}
			audioSource.volume = fVolume;
			audioSource.loop = bLoop;
			audioSource.clip = clip;
			audioSource.minDistance = 1f;
			audioSource.maxDistance = 50000000f;
			audioSource.rolloffMode = AudioRolloffMode.Linear;
			audioSource.Play();
		}
	}

	public bool setCurrentTrigger(GameObject ct)
	{
		curCheckPoint.CurTrigger = ct.GetComponent<VRTrigger>();
		return true;
	}

	public void GMDebug()
	{
	}

	private void GMDebug_MonsterInjure()
	{
		for (int i = 0; i < VRGlobal.npcLib.Count; i++)
		{
			VRNpc vRNpc = VRGlobal.npcLib[i];
			if ((bool)(vRNpc as VRMonster))
			{
				((VRMonster)vRNpc).DebugMonster(bCriticalHit: false);
			}
		}
	}

	private void GMDebug_MonsterDead()
	{
		for (int i = 0; i < VRGlobal.npcLib.Count; i++)
		{
			VRNpc vRNpc = VRGlobal.npcLib[i];
			if ((bool)(vRNpc as VRMonster))
			{
				((VRMonster)vRNpc).DebugMonster(bCriticalHit: true);
			}
		}
	}

	public void GMDebug_KillAllMonster()
	{
		for (int i = 0; i < VRGlobal.npcLib.Count; i++)
		{
			VRNpc vRNpc = VRGlobal.npcLib[i];
			if (!(vRNpc != null) || vRNpc.Camp != EU_CAMP.EU_BAD)
			{
				continue;
			}
			VRNpc killer = null;
			Vector3 pos = Vector3.zero;
			if (vRNpc.CurHP > 0f)
			{
				for (int j = 0; j < vRNpc.dropItems.Length; j++)
				{
					vRNpc.dropItems[j] = null;
				}
				vRNpc.OnDamage(vRNpc.CurHP, ref killer, sound: true, ref pos, isAwarded: false);
			}
		}
		VRGlobal.npcLib.Clear();
	}

	private void GMDebug_EquipWeaponCrossBow()
	{
	}

	private void GMDebug_WeaponCrossBowReloadBullet()
	{
	}

	private void GMDebug_WeaponCrossBowFireBullet()
	{
	}

	private void manageBgMusic()
	{
		switch (CurGameState)
		{
		case GameState.GS_NeebieGuide:
			if (mCurBgMusicName != "bg_newbie")
			{
				playAudio("bg_newbie", 0.3f, bLoop: true);
				mCurBgMusicName = "bg_newbie";
			}
			break;
		case GameState.GS_PreStage:
			if (mCurBgMusicName != "bg_prestage")
			{
				playAudio("bg_prestage", 0.3f);
				mCurBgMusicName = "bg_prestage";
			}
			break;
		case GameState.GS_Stage:
			if (mCurBgMusicName != "bg_stage" + CurStageID)
			{
				playAudio("bg_stage" + CurStageID, 0.3f, bLoop: true);
				mCurBgMusicName = "bg_stage" + CurStageID;
			}
			break;
		case GameState.GS_Fail:
			if (mCurBgMusicName != "bg_fail")
			{
				playAudio("bg_fail", 0.3f);
				mCurBgMusicName = "bg_fail";
			}
			break;
		case GameState.GS_Finish:
			if (mCurBgMusicName != "bg_finish")
			{
				playAudio("bg_finish", 0.3f);
				mCurBgMusicName = "bg_finish";
			}
			break;
		case GameState.GS_Boss:
			break;
		}
	}

	public void InitSpawnDynSceneObj()
	{
		if (CurGameState == GameState.GS_NeebieGuide)
		{
			return;
		}
		if ((bool)DynSceneObj)
		{
			UnityEngine.Object.Destroy(DynSceneObj);
			DynSceneObj = null;
		}
		if (CurGameModel == GameModel.GM_Multi && !PhotonNetwork.IsMasterClient)
		{
			return;
		}
		if (CurGameModel == GameModel.GM_Single)
		{
			DynSceneObj = VRGlobal.getActorEntity(Resources.Load(VRGlobal.GetSceneModelPath("SceneInteraction")) as GameObject);
		}
		else
		{
			DynSceneObj = VRGlobal.getActorEntity("SceneInteraction", GameModel.GM_Multi, Vector3.zero, Quaternion.identity);
		}
		VRMuTouItem[] componentsInChildren = DynSceneObj.GetComponentsInChildren<VRMuTouItem>();
		foreach (VRMuTouItem vRMuTouItem in componentsInChildren)
		{
			if ((bool)vRMuTouItem)
			{
				vRMuTouItem.bCanAttack = true;
			}
		}
	}

	public void StageUnlockObject(int curLv)
	{
		if (stageUnlocks == null)
		{
			return;
		}
		for (int i = 0; i < stageUnlocks.Length; i++)
		{
			if (stageUnlocks[i].go.activeSelf != curLv >= stageUnlocks[i].index)
			{
				stageUnlocks[i].go.SetActive(curLv >= stageUnlocks[i].index);
			}
		}
	}
}
public class VRGate : VRNpc
{
	public GameObject[] bolts;

	public GameObject shieldEffect;

	private VRItem_Shield shield;

	public override bool MyReset()
	{
		shieldEffect.SetActive(value: false);
		return base.MyReset();
	}

	protected override bool MyUpdate(float delta)
	{
		if (shield != null)
		{
			shieldEffect.SetActive(value: true);
		}
		else
		{
			shieldEffect.SetActive(value: false);
			UnityEngine.Object.Destroy(shield);
		}
		if (base.CurHP <= 0f)
		{
			for (int i = 0; i < bolts.Length; i++)
			{
				bolts[i].SetActive(value: false);
			}
		}
		return base.MyUpdate(delta);
	}

	public override bool OnDamage(float dmgHP, ref VRNpc killer, bool sound, ref Vector3 pos, bool isAwarded = true)
	{
		if (VRGameSystem.CurGameModel == GameModel.GM_Multi && !PhotonNetwork.IsMasterClient)
		{
			return false;
		}
		if (shield != null)
		{
			if (VRGameSystem.CurGameModel == GameModel.GM_Single)
			{
				shieldOnDamage(dmgHP);
			}
			else if (VRGameSystem.CurGameModel == GameModel.GM_Multi)
			{
				photonView.RPC("shieldOnDamage", RpcTarget.All, dmgHP);
			}
			return true;
		}
		return base.OnDamage(dmgHP, ref killer, sound, ref pos, isAwarded);
	}

	[PunRPC]
	private void shieldOnDamage(float dmgHP)
	{
		shield.OnDamage(dmgHP);
	}

	public void AddShield(VRItem_Shield shield)
	{
		if (this.shield != null)
		{
			UnityEngine.Object.Destroy(shield);
		}
		this.shield = shield;
	}
}
public class VRGlobal
{
	public const string playerIsDeadKey = "ISDEAD";

	public static float g_PI360 = 0.0174533f;

	public static float g_2PI = (float)Math.PI * 2f;

	public static VRGameSystem G_GameSystem = null;

	private static SystemLanguage g_Language = SystemLanguage.Chinese;

	public static DifficultyLevel mDifficulty = DifficultyLevel.DL_Easy;

	public static bool IsOpenTutorial = true;

	public static Dictionary<string, VRFreeLib> g_staticGameData = new Dictionary<string, VRFreeLib>();

	public static List<VRNpc> npcLib = new List<VRNpc>();

	public static List<VRNpc> interActiveLib = new List<VRNpc>();

	private static LocalizationScript _localizationScript;

	public static float G_PI360 => g_PI360;

	public static float G_2PI => g_2PI;

	public static SystemLanguage G_Language
	{
		get
		{
			return g_Language;
		}
		set
		{
			g_Language = value;
		}
	}

	public static LocalizationScript mLocalizationScript
	{
		get
		{
			if (_localizationScript == null)
			{
				_localizationScript = Resources.Load<LocalizationScript>("LTLocalization/Localization");
			}
			return _localizationScript;
		}
		set
		{
			_localizationScript = value;
		}
	}

	public static bool inCameraSpace(Vector3 inPos)
	{
		if (Camera.main == null)
		{
			return false;
		}
		Vector3 vector = Camera.main.WorldToViewportPoint(inPos);
		if (vector.z > 0f && vector.x > 0f && vector.x < 1f && vector.y > 0f && vector.y < 1f)
		{
			return true;
		}
		return false;
	}

	public static GameObject getActorEntity(UnityEngine.Object Prefab)
	{
		GameObject gameObject = null;
		VRFreeLib value = null;
		if (g_staticGameData.Count > 0 && g_staticGameData.TryGetValue(Prefab.name, out value) && value.freeActorLib.Count > 0)
		{
			gameObject = value.freeActorLib.Dequeue();
		}
		if (gameObject == null)
		{
			gameObject = (GameObject)UnityEngine.Object.Instantiate(Prefab, Vector3.zero, Quaternion.identity);
			gameObject.name = Prefab.name;
		}
		VRGameObject component = gameObject.GetComponent<VRGameObject>();
		if (component != null)
		{
			component.MyReset();
		}
		gameObject.SetActive(value: true);
		return gameObject;
	}

	public static GameObject getActorEntity(string prefabName, GameModel gameModel, Vector3 pos, Quaternion qua)
	{
		if (gameModel == GameModel.GM_Single)
		{
			return null;
		}
		GameObject gameObject = null;
		VRFreeLib value = null;
		if (g_staticGameData.Count > 0 && g_staticGameData.TryGetValue(prefabName, out value) && value.freeActorLib.Count > 0)
		{
			gameObject = value.freeActorLib.Dequeue();
		}
		if (gameObject == null)
		{
			gameObject = PhotonNetwork.Instantiate(prefabName, pos, qua, 0);
			gameObject.name = prefabName;
		}
		VRGameObject component = gameObject.GetComponent<VRGameObject>();
		if (component != null)
		{
			component.MyReset();
		}
		if (component is VRBulletPhysic)
		{
			(component as VRBulletPhysic).VRSetActive(active: true);
		}
		else
		{
			gameObject.SetActive(value: true);
		}
		gameObject.transform.position = pos;
		gameObject.transform.rotation = qua;
		return gameObject;
	}

	public static void pushFreeEntity(GameObject inActor)
	{
		if ((bool)inActor)
		{
			inActor.SetActive(value: false);
			VRGameObject component = inActor.GetComponent<VRGameObject>();
			if (component != null)
			{
				component.MyHide();
			}
			VRFreeLib value = null;
			if (!g_staticGameData.TryGetValue(inActor.name, out value))
			{
				value = new VRFreeLib();
				g_staticGameData.Add(inActor.name, value);
			}
			value.freeActorLib.Enqueue(inActor);
		}
	}

	public static VRNpc findItemNPC(EU_CAMP camp, Transform src, float inAqrRange)
	{
		float num = 100000000f;
		VRNpc result = null;
		for (int i = 0; i < npcLib.Count; i++)
		{
			VRNpc vRNpc = npcLib[i];
			if (vRNpc.ItemNPC && vRNpc.CurHP > 0f && vRNpc.Camp != camp)
			{
				float sqrMagnitude = (vRNpc.transform.position - src.position).sqrMagnitude;
				if (sqrMagnitude < inAqrRange && sqrMagnitude < num)
				{
					result = vRNpc;
					num = sqrMagnitude;
				}
			}
		}
		return result;
	}

	public static VRNpc findZombieTarget(EU_CAMP camp, Transform src, float inAqrRange)
	{
		float num = 100000000f;
		VRNpc result = null;
		for (int i = 0; i < npcLib.Count; i++)
		{
			VRNpc vRNpc = npcLib[i];
			if ((bool)vRNpc && vRNpc.CurHP > 0f && vRNpc.Camp != camp && !vRNpc.ItemNPC)
			{
				float sqrMagnitude = (vRNpc.transform.position - src.position).sqrMagnitude;
				if (sqrMagnitude < inAqrRange && sqrMagnitude < num)
				{
					result = vRNpc;
					num = sqrMagnitude;
				}
			}
		}
		return result;
	}

	public static VRNpc findTarget(EU_CAMP camp, Transform src, float inAqrRange)
	{
		float num = 100000000f;
		VRNpc result = null;
		for (int i = 0; i < npcLib.Count; i++)
		{
			VRNpc vRNpc = npcLib[i];
			if ((bool)vRNpc && vRNpc.CurHP > 0f && vRNpc.Camp != camp)
			{
				float sqrMagnitude = (vRNpc.transform.position - src.position).sqrMagnitude;
				if (sqrMagnitude < inAqrRange && sqrMagnitude < num)
				{
					result = vRNpc;
					num = sqrMagnitude;
				}
			}
		}
		return result;
	}

	public static bool haveTarget(EU_CAMP camp)
	{
		for (int i = 0; i < npcLib.Count; i++)
		{
			VRNpc vRNpc = npcLib[i];
			if (!vRNpc.ItemNPC && vRNpc.Camp != camp && vRNpc.CurHP > 0f)
			{
				return true;
			}
		}
		return false;
	}

	public static void tickAutoDestroyObject(float delta)
	{
	}

	public static void removeNpc(ref VRActor npc)
	{
		int num = 0;
		while (num < npcLib.Count)
		{
			VRNpc vRNpc = npcLib[num];
			if (vRNpc == npc)
			{
				npcLib.RemoveAt(num);
				continue;
			}
			if (vRNpc.AttackTarget == npc)
			{
				vRNpc.AttackTarget = null;
			}
			num++;
		}
	}

	public static string GetHeroModelPath(string modelName)
	{
		return "Package/Model/Hero/package_" + modelName;
	}

	public static string GetEffectPath(string modelName)
	{
		return "Package/Effect/package_effect_" + modelName;
	}

	public static string GetWeaponPath(string modelName)
	{
		return "Package/Model/Weapon/package_" + modelName;
	}

	public static string GetMonsterModelPath(string modelName)
	{
		return "Package/Model/Monster/package_" + modelName;
	}

	public static string GetSceneModelPath(string modelName)
	{
		return "Package/Model/Scene/package_" + modelName;
	}

	public static string GetSoundPath(string modelName)
	{
		return "Actor/Sound/" + modelName;
	}
}
public class VRJiuTan : VRNpc
{
	protected bool exp;

	private float expTimer;

	private Light lit;

	public bool bCanAttack;

	protected override bool MyAwake()
	{
		exp = false;
		m_animation = GetComponent<Animation>();
		base.Camp = EU_CAMP.EU_BAD;
		VRGlobal.interActiveLib.Add(this);
		lit = base.gameObject.GetComponentInChildren<Light>();
		return true;
	}

	protected override bool MyUpdate(float delta)
	{
		if (exp)
		{
			expTimer -= delta;
			if (expTimer <= 0f)
			{
				expTimer = 0f;
				lit.enabled = false;
				VRGlobal.interActiveLib.Remove(this);
			}
			lit.intensity = 8f * expTimer / 0.3f;
			if (!m_animation.IsPlaying("jiutandonghua"))
			{
				bool flag = true;
				ParticleSystem[] componentsInChildren = base.gameObject.GetComponentsInChildren<ParticleSystem>();
				for (int i = 0; i < componentsInChildren.Length; i++)
				{
					if (componentsInChildren[i].isPlaying)
					{
						flag = false;
					}
				}
				if (flag)
				{
					base.gameObject.SetActive(value: false);
				}
			}
		}
		return true;
	}

	public override bool OnDamage(float dmgHP, ref VRNpc killer, bool sound, ref Vector3 pos, bool isAwarded = true)
	{
		if (bCanAttack)
		{
			Invoke("Damage", fDelayTime);
		}
		return true;
	}

	private void Damage()
	{
		if (exp)
		{
			return;
		}
		m_fCurHP = 0f;
		ParticleSystem[] componentsInChildren = base.gameObject.GetComponentsInChildren<ParticleSystem>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].Play();
		}
		AudioSource component = base.gameObject.GetComponent<AudioSource>();
		if (component != null)
		{
			component.Play();
		}
		m_animation.CrossFade("youtongdonghua", 0f);
		exp = true;
		base.IsDamaged = true;
		CharacterController component2 = GetComponent<CharacterController>();
		if ((bool)component2)
		{
			component2.enabled = false;
		}
		VRNpc killer = null;
		for (int j = 0; j < VRGlobal.npcLib.Count; j++)
		{
			VRNpc vRNpc = VRGlobal.npcLib[j];
			if ((bool)vRNpc && EU_CAMP.EU_BAD == vRNpc.Camp && vRNpc != this && (vRNpc.transform.position - base.transform.position).sqrMagnitude <= atkRange * atkRange)
			{
				Vector3 pos = vRNpc.transform.position;
				vRNpc.OnDamage(vRNpc.Hp * base.Atk, ref killer, sound: false, ref pos);
			}
		}
		for (int k = 0; k < VRGlobal.interActiveLib.Count; k++)
		{
			VRNpc vRNpc2 = VRGlobal.interActiveLib[k];
			if (EU_CAMP.EU_BAD == vRNpc2.Camp && vRNpc2 != this && !vRNpc2.IsDamaged && (vRNpc2.transform.position - base.transform.position).sqrMagnitude <= atkRange * atkRange)
			{
				Vector3 pos2 = vRNpc2.transform.position;
				vRNpc2.FDelayTime = UnityEngine.Random.Range(0.5f, 1.5f);
				vRNpc2.OnDamage(vRNpc2.Hp * base.Atk, ref killer, sound: false, ref pos2);
			}
		}
		lit.enabled = true;
		expTimer = 0.3f;
	}
}
internal class VRLogger : VRSingletonBehaviour<VRLogger>
{
	public enum LOG_TYPE
	{
		LOG,
		WARNNING,
		ERROR
	}

	public struct stLog
	{
		public LOG_TYPE logType;

		public string logText;
	}

	public static bool IsShowLog = false;

	private static List<stLog> mLines = new List<stLog>();

	private static int maxCount = 300;

	private static int fontsize = 9999;

	public static bool IsShowConsole = false;

	private static int unSee = 0;

	private static int unSeeError = 0;

	private static bool isBottom = true;

	private int xPos = 400;

	private int yPos = 300;

	private int wValue = 40;

	private int hValue = 40;

	private string buttonName = "拉";

	private bool bScale;

	public static Dictionary<string, string> mDebugShow = new Dictionary<string, string>();

	public static Vector2 scrollPosition = new Vector2(0f, 0f);

	public string textStr = "";

	private GameObject uiObj;

	private int rightClickCount;

	private float firstRightClickTime;

	private float lastRightClickTime;

	private bool bOpnen;

	public static void SetDebugShow(string name, string v)
	{
		if (mDebugShow.ContainsKey(name))
		{
			mDebugShow[name] = v;
		}
		else
		{
			mDebugShow.Add(name, v);
		}
	}

	public static void DrawBounds(Bounds b)
	{
		Vector3 center = b.center;
		Vector3 vector = b.center - b.extents;
		Vector3 vector2 = b.center + b.extents;
		UnityEngine.Debug.DrawLine(new Vector3(vector.x, vector.y, center.z), new Vector3(vector2.x, vector.y, center.z), Color.red);
		UnityEngine.Debug.DrawLine(new Vector3(vector.x, vector.y, center.z), new Vector3(vector.x, vector2.y, center.z), Color.red);
		UnityEngine.Debug.DrawLine(new Vector3(vector2.x, vector.y, center.z), new Vector3(vector2.x, vector2.y, center.z), Color.red);
		UnityEngine.Debug.DrawLine(new Vector3(vector.x, vector2.y, center.z), new Vector3(vector2.x, vector2.y, center.z), Color.red);
	}

	private void OnApplicationQuit()
	{
		mLines.Clear();
		mLines = null;
	}

	public static void Log(string format, params object[] arr)
	{
	}

	private static void WindowsLog(string format, params object[] arr)
	{
		Console.WriteLine(string.Format(format, arr));
	}

	private static void UnityLog(string format, params object[] arr)
	{
		if (mLines != null)
		{
			string text = string.Format(format, arr);
			text = DateTime.Now.ToLocalTime().ToString("HH:mm:ss(fff)") + ": " + text;
			if (mLines.Count > maxCount)
			{
				mLines.RemoveAt(0);
			}
			if (isBottom)
			{
				stLog item = default(stLog);
				item.logType = LOG_TYPE.LOG;
				item.logText = text;
				mLines.Add(item);
				scrollPosition.y += fontsize;
			}
			VRSingletonBehaviour<VRLogger>.Instance.ToString();
			if (!IsShowConsole)
			{
				unSee++;
			}
		}
	}

	public static void Exception(Exception e)
	{
		UnityException(e);
	}

	private static void WindowsExceiption(Exception e)
	{
		Console.WriteLine(e.StackTrace);
	}

	private static void UnityException(Exception e)
	{
		if (mLines != null)
		{
			string stackTrace = e.StackTrace;
			stackTrace = DateTime.Now.ToLocalTime().ToString("HH:mm:ss(fff)") + ": " + stackTrace;
			if (mLines.Count > maxCount)
			{
				mLines.RemoveAt(0);
			}
			if (isBottom)
			{
				stLog item = default(stLog);
				item.logType = LOG_TYPE.WARNNING;
				item.logText = stackTrace;
				mLines.Add(item);
				scrollPosition.y += fontsize;
			}
			if (!IsShowConsole)
			{
				unSee++;
			}
		}
	}

	public static void LogWarning(string format, params object[] arr)
	{
		if (mLines != null)
		{
			string text = string.Format(format, arr);
			text = DateTime.Now.ToLocalTime().ToString("HH:mm:ss(fff)") + ": " + text;
			if (mLines.Count > maxCount)
			{
				mLines.RemoveAt(0);
			}
			if (isBottom)
			{
				stLog item = default(stLog);
				item.logType = LOG_TYPE.WARNNING;
				item.logText = text;
				mLines.Add(item);
				scrollPosition.y += fontsize;
			}
			VRSingletonBehaviour<VRLogger>.Instance.ToString();
			if (!IsShowConsole)
			{
				unSee++;
			}
		}
	}

	public static void LogError(string format, params object[] arr)
	{
		if (mLines != null)
		{
			format = format.Replace("{}", "[zhongkuohao]");
			string text = string.Format(format, arr);
			text = text.Replace("[zhongkuohao]", "{}");
			text = DateTime.Now.ToLocalTime().ToString("HH:mm:ss(fff)") + ": " + text;
			if (mLines.Count > maxCount)
			{
				mLines.RemoveAt(0);
			}
			if (isBottom)
			{
				stLog item = default(stLog);
				item.logType = LOG_TYPE.ERROR;
				item.logText = text;
				mLines.Add(item);
				scrollPosition.y += fontsize;
			}
			VRSingletonBehaviour<VRLogger>.Instance.ToString();
			if (!IsShowConsole)
			{
				unSee++;
				unSeeError++;
			}
		}
	}

	private void OnGUI()
	{
		if (Application.isEditor && Input.GetKeyDown(KeyCode.F8))
		{
			bOpnen = !bOpnen;
		}
		if (!bOpnen)
		{
			return;
		}
		if (!IsShowLog)
		{
			if (!Input.GetMouseButtonUp(1) || Time.time - lastRightClickTime < 0.1f)
			{
				return;
			}
			if (firstRightClickTime == 0f)
			{
				firstRightClickTime = Time.time;
				rightClickCount = 0;
			}
			rightClickCount++;
			lastRightClickTime = Time.time;
			if (rightClickCount >= 20)
			{
				if (Time.time - firstRightClickTime < 5f)
				{
					IsShowLog = true;
				}
				firstRightClickTime = 0f;
				rightClickCount = 0;
			}
			return;
		}
		if (IsShowConsole)
		{
			unSee = 0;
			unSeeError = 0;
		}
		string text = "Log";
		if (unSee > 0)
		{
			text = text + " (" + unSee + ")";
		}
		if (unSeeError > 0)
		{
			text = text + " (" + unSeeError + ")";
		}
		int num = 155;
		if (VRSingletonBehaviour<VRSystemMonitor>.Instance.IsShowSystem)
		{
			GUILayout.Space(120f);
			num = 185;
		}
		else
		{
			GUILayout.Space(30f);
			num = 57;
		}
		GUILayout.BeginHorizontal();
		if (GUILayout.Button(text, GUILayout.Width(60f), GUILayout.Height(40f)))
		{
			IsShowConsole = !IsShowConsole;
		}
		if (GUILayout.Button("UI", GUILayout.Width(60f), GUILayout.Height(40f)))
		{
			GameObject gameObject = GameObject.Find("UI Root (2D)");
			if (gameObject != null)
			{
				uiObj = gameObject;
			}
			if (uiObj != null)
			{
				uiObj.SetActive(!uiObj.activeSelf);
			}
		}
		GUILayout.EndHorizontal();
		if (!IsShowConsole || mLines.Count == 0)
		{
			return;
		}
		if (GUI.RepeatButton(new Rect(xPos, yPos, wValue, hValue), buttonName))
		{
			bScale = true;
		}
		if (Input.GetMouseButtonUp(0))
		{
			bScale = false;
		}
		if (bScale)
		{
			Vector3 mousePosition = Input.mousePosition;
			xPos = (int)mousePosition.x - wValue / 2;
			yPos = (int)((float)Screen.height - mousePosition.y) - hValue / 2;
			GUILayout.Box("拉伸中...", GUILayout.Width(xPos + 28), GUILayout.Height(yPos - num));
		}
		else
		{
			scrollPosition = GUILayout.BeginScrollView(scrollPosition, GUILayout.Width(xPos + 28), GUILayout.Height(yPos - num));
			int i = 0;
			for (int count = mLines.Count; i < count; i++)
			{
				GUIStyle box = GUI.skin.box;
				box.richText = true;
				box.alignment = TextAnchor.MiddleLeft;
				switch (mLines[i].logType)
				{
				case LOG_TYPE.LOG:
					box.normal.textColor = Color.white;
					box.fontSize = 14;
					break;
				case LOG_TYPE.WARNNING:
					box.normal.textColor = Color.yellow;
					box.fontSize = 14;
					break;
				case LOG_TYPE.ERROR:
					box.normal.textColor = Color.red;
					box.fontSize = 14;
					break;
				}
				GUILayout.Label(mLines[i].logText, box);
				GUILayout.Space(-8f);
			}
			GUILayout.EndScrollView();
		}
		int num2 = 1;
		foreach (KeyValuePair<string, string> item in mDebugShow)
		{
			string key = item.Key;
			string value = item.Value;
			GUI.Label(new Rect(xPos + 50, 50 + 20 * num2, 300f, 20f), $"{key}: {value}");
			num2++;
		}
	}
}
public enum AniState
{
	AS_Stand,
	AS_Run,
	AS_Dodge,
	AS_Show,
	AS_Injure,
	AS_Dead,
	AS_Attack
}
public enum MonsterType
{
	MT_Land,
	MT_Air
}
public enum AttackType
{
	AT_Attack,
	AT_Explode,
	AT_AttackRanged,
	AT_OutputMonster
}
public class VRMonster : VRNpc
{
	public PathType pathType;

	private NavMeshAgent m_agent;

	private VRNpc m_target;

	private Vector3 agentDestination;

	private Animator m_anim;

	protected float initHP;

	protected float initATK;

	protected float initMoveSpeed;

	protected bool initProp;

	[SerializeField]
	private bool m_bInitShow;

	private float m_fNavStopDist = 1.5f;

	private float m_fNavStopDist_Exploded = 2f;

	public AniState eCurAniState;

	public bool bNeedBulletTime;

	protected bool bIsItweenPathNeedResume;

	public MonsterType monsterType;

	public string strPathName = "";

	public AttackType mAttackType;

	public GameObject BulletPrefab;

	public bool pierce;

	public float speed = 40f;

	public int scatteringPlane;

	public Transform FiringPoint;

	public GameObject mShootTarget;

	public float mBulletSpeed = 5f;

	public BulletFireType eBulletFireType;

	private VRTrigger mMyTrigger;

	private bool mIsShowBubbleText;

	[Header("受到攻击后移速变化系数")]
	public float byHitSpeedCoe = 1f;

	[Header("受到攻击后瞬移的次数")]
	public int byHitTeleportNum;

	protected int canTeleportNum;

	private Vector3[] pathPos;

	private List<Vector3> flyOverPathPos = new List<Vector3>();

	private CharacterController characterController;

	private VRRagdoll ragdoll;

	private iTween tween;

	private bool isPath;

	public NavMeshAgent Agent
	{
		get
		{
			return m_agent;
		}
		set
		{
			m_agent = value;
		}
	}

	public override VRNpc Target
	{
		get
		{
			return m_target;
		}
		set
		{
			m_target = value;
		}
	}

	public Animator Anim
	{
		get
		{
			return m_anim;
		}
		set
		{
			m_anim = value;
		}
	}

	public bool InitProp
	{
		get
		{
			return initProp;
		}
		set
		{
			initProp = value;
		}
	}

	public bool InitShow
	{
		get
		{
			return m_bInitShow;
		}
		set
		{
			m_bInitShow = value;
		}
	}

	public VRTrigger MyTrigger
	{
		get
		{
			return mMyTrigger;
		}
		set
		{
			mMyTrigger = value;
		}
	}

	public override bool MyReset()
	{
		ragdoll = GetComponentInChildren<VRRagdoll>();
		if (!initProp)
		{
			initProp = true;
			initHP = base.Hp;
			initATK = base.Atk;
			initMoveSpeed = base.MoveSpeed;
		}
		Agent = GetComponent<NavMeshAgent>();
		Anim = GetComponent<Animator>();
		base.Hp = VRGlobal.G_GameSystem.MonsterHPBase * initHP;
		base.Atk = VRGlobal.G_GameSystem.MonsterATKBase * initATK;
		base.MoveSpeed = VRGlobal.G_GameSystem.MonsterSpeedBase * initMoveSpeed;
		if ((bool)MyTrigger)
		{
			base.Hp *= MyTrigger.MonsterHPBase_Trigger;
			base.Atk *= MyTrigger.MonsterATKBase_Trigger;
			base.MoveSpeed *= MyTrigger.MonsterSpeedBase_Trigger;
		}
		m_target = VRGlobal.G_GameSystem.Gate;
		FindTarget();
		if ((bool)Agent)
		{
			Agent.speed = base.MoveSpeed;
			Agent.enabled = false;
		}
		characterController = GetComponent<CharacterController>();
		canTeleportNum = byHitTeleportNum;
		Ragdoll(open: false);
		return base.MyReset();
	}

	private void InitBubbleText()
	{
		if (!mIsShowBubbleText)
		{
			VRBubbleText component = base.gameObject.GetComponent<VRBubbleText>();
			if ((bool)component && Vector3.Distance(base.transform.position, Camera.main.transform.position) < component.mMaxDisShow)
			{
				component.InitBubbleCanvas();
				mIsShowBubbleText = true;
			}
		}
	}

	protected override bool MyUpdate(float delta)
	{
		updateAniState();
		InitBubbleText();
		if (Agent != null)
		{
			if (VRGlobal.G_GameSystem.isPause && Agent.speed != 0f)
			{
				Agent.speed = 0f;
				Agent.velocity = Vector3.zero;
				if (characterController != null)
				{
					characterController.enabled = false;
				}
			}
			else if (!VRGlobal.G_GameSystem.isPause && Agent.speed == 0f)
			{
				Agent.speed = base.MoveSpeed;
				if (characterController != null)
				{
					characterController.enabled = true;
				}
			}
		}
		else if (VRGlobal.G_GameSystem.isPause)
		{
			if (tween != null)
			{
				tween.enabled = false;
			}
		}
		else if (tween != null)
		{
			tween.enabled = true;
		}
		if (Anim != null)
		{
			Anim.speed = ((!VRGlobal.G_GameSystem.isPause) ? 1 : 0);
		}
		if (pathPos != null)
		{
			for (int i = 0; i < pathPos.Length; i++)
			{
				if (Vector3.Distance(base.transform.position, pathPos[i]) < 0.1f && !flyOverPathPos.Contains(pathPos[i]))
				{
					flyOverPathPos.Add(pathPos[i]);
				}
			}
		}
		ReloadSetPath();
		return base.MyUpdate(delta);
	}

	public void AnimatorClear()
	{
		if ((bool)Anim)
		{
			if (monsterType == MonsterType.MT_Land)
			{
				Anim.SetBool("dodge", value: false);
			}
			Anim.SetBool("attack", value: false);
		}
	}

	public virtual void FindTarget()
	{
		for (int i = 0; i < VRGlobal.G_GameSystem.shuijingList[pathType].shuijingList.Count; i++)
		{
			if (VRGlobal.G_GameSystem.shuijingList[pathType].shuijingList[i].GetComponent<VRNpc>().CurHP > 0f)
			{
				Target = VRGlobal.G_GameSystem.shuijingList[pathType].shuijingList[i].GetComponent<VRNpc>();
				return;
			}
		}
		Target = VRGlobal.G_GameSystem.Gate;
	}

	public virtual void SetItweenPathDest()
	{
		if (strPathName != "")
		{
			if (bIsItweenPathNeedResume)
			{
				iTween.Resume(base.gameObject);
			}
			else
			{
				pathPos = new Vector3[iTweenPath.GetPath(strPathName).Length];
				pathPos = iTweenPath.GetPath(strPathName);
				if (pathPos.Length < 0)
				{
					return;
				}
				System.Collections.Hashtable hashtable = new System.Collections.Hashtable();
				hashtable.Add("path", pathPos);
				hashtable.Add("easeType", iTween.EaseType.linear);
				hashtable.Add("speed", base.MoveSpeed);
				hashtable.Add("movetopath", true);
				hashtable.Add("orienttopath", true);
				hashtable.Add("oncomplete", "ItweenReachEnd");
				iTween.MoveTo(base.gameObject, hashtable);
				bIsItweenPathNeedResume = true;
			}
		}
		tween = GetComponent<iTween>();
	}

	public void ReloadSetPath()
	{
		if (!(strPathName != "") || isPath || ((!(Target.gameObject != VRGlobal.G_GameSystem.shuijingList[pathType].shuijingList[VRGlobal.G_GameSystem.shuijingList[pathType].shuijingList.Count - 1]) || !(Target.CurHP <= 0f)) && !(Target.gameObject == VRGlobal.G_GameSystem.shuijingList[pathType].shuijingList[VRGlobal.G_GameSystem.shuijingList[pathType].shuijingList.Count - 1])))
		{
			return;
		}
		if (pathPos == null)
		{
			SetItweenPathDest();
		}
		StopItweenPath();
		if (bIsItweenPathNeedResume)
		{
			iTween.Resume(base.gameObject);
		}
		else
		{
			if (pathPos.Length < 0)
			{
				return;
			}
			FindTarget();
			Vector3[] array = new Vector3[1] { base.transform.position };
			for (int i = 0; i < pathPos.Length; i++)
			{
				if (!flyOverPathPos.Contains(pathPos[i]))
				{
					Array.Resize(ref array, array.Length + 1);
					array[^1] = pathPos[i];
				}
			}
			array[^1] = new Vector3(15.5f, 31f, 10f);
			System.Collections.Hashtable hashtable = new System.Collections.Hashtable();
			hashtable.Add("path", array);
			hashtable.Add("easeType", iTween.EaseType.linear);
			hashtable.Add("speed", base.MoveSpeed);
			hashtable.Add("movetopath", true);
			hashtable.Add("orienttopath", true);
			hashtable.Add("oncomplete", "ItweenReachEnd");
			iTween.MoveTo(base.gameObject, hashtable);
			bIsItweenPathNeedResume = true;
			isPath = true;
		}
	}

	public void PauseItweenPath()
	{
		iTween.Pause(base.gameObject);
		bIsItweenPathNeedResume = true;
	}

	public void StopItweenPath()
	{
		iTween.Stop(base.gameObject);
		bIsItweenPathNeedResume = false;
	}

	public virtual void ItweenReachEnd()
	{
		bIsItweenPathNeedResume = false;
		Anim.SetBool("attack", value: true);
	}

	public void SetFindPathDestination()
	{
		if ((bool)Target && Target.CurHP > 0f && (bool)Agent)
		{
			if (Agent.enabled)
			{
				Agent.Resume();
			}
			if (agentDestination != Target.NavPoint.position)
			{
				Agent.enabled = true;
				Agent.SetDestination(Target.NavPoint.position);
				agentDestination = Target.NavPoint.position;
			}
		}
	}

	public void StopFindPath()
	{
		if ((bool)Agent && Agent.enabled)
		{
			Agent.Stop();
		}
	}

	private float GetNavStopDist()
	{
		if (mAttackType == AttackType.AT_Explode)
		{
			return m_fNavStopDist_Exploded;
		}
		return m_fNavStopDist;
	}

	public bool CheckReachTarget()
	{
		if ((bool)Target && (bool)Agent && Agent.enabled && Agent.pathStatus == NavMeshPathStatus.PathComplete && Vector3.Distance(Agent.destination, base.transform.position) <= GetNavStopDist())
		{
			return true;
		}
		return false;
	}

	public void SoundPlay(UnityEngine.Object objSound)
	{
		if (objSound != null)
		{
			VRPlaySound component = VRGlobal.getActorEntity(objSound).GetComponent<VRPlaySound>();
			if (component != null)
			{
				component.playSound(base.transform);
			}
		}
	}

	private void updateAniState()
	{
		AnimatorStateInfo currentAnimatorStateInfo = Anim.GetCurrentAnimatorStateInfo(0);
		if (currentAnimatorStateInfo.IsName("stand"))
		{
			eCurAniState = AniState.AS_Stand;
		}
		if (currentAnimatorStateInfo.IsName("run"))
		{
			eCurAniState = AniState.AS_Run;
		}
		if (currentAnimatorStateInfo.IsName("dodge"))
		{
			eCurAniState = AniState.AS_Dodge;
		}
		if (currentAnimatorStateInfo.IsName("show"))
		{
			eCurAniState = AniState.AS_Show;
		}
		if (currentAnimatorStateInfo.IsName("injure"))
		{
			eCurAniState = AniState.AS_Injure;
		}
		if (currentAnimatorStateInfo.IsName("dead"))
		{
			eCurAniState = AniState.AS_Dead;
		}
		if (currentAnimatorStateInfo.IsName("attack"))
		{
			eCurAniState = AniState.AS_Attack;
		}
	}

	public void DebugMonster(bool bCriticalHit)
	{
		VRNpc killer = null;
		Vector3 pos = Vector3.zero;
		OnDamage(50f, ref killer, sound: true, ref pos);
		VRLogger.Log("MonsterCurHp=" + base.CurHP);
		switch (eCurAniState)
		{
		case AniState.AS_Stand:
			VRLogger.Log("stand");
			break;
		case AniState.AS_Run:
			VRLogger.Log("run");
			break;
		case AniState.AS_Dodge:
			VRLogger.Log("dodge");
			break;
		case AniState.AS_Show:
			VRLogger.Log("show");
			break;
		case AniState.AS_Injure:
			VRLogger.Log("injure");
			break;
		case AniState.AS_Dead:
			VRLogger.Log("dead");
			break;
		case AniState.AS_Attack:
			VRLogger.Log("attack");
			break;
		}
	}

	public override bool OnDamage(float dmgHP, ref VRNpc killer, bool sound, ref Vector3 pos, bool isAwarded = true)
	{
		ByHitBehavior();
		return base.OnDamage(dmgHP, ref killer, sound, ref pos, isAwarded);
	}

	private void ByHitBehavior()
	{
		if (Agent != null && Agent.speed == base.MoveSpeed)
		{
			Agent.speed *= byHitSpeedCoe;
		}
		if (!(Agent != null) || canTeleportNum <= 0)
		{
			return;
		}
		canTeleportNum--;
		if (Agent.path.corners.Length > 2)
		{
			if (Vector3.Distance(base.transform.position, Agent.path.corners[1]) < 5f)
			{
				base.transform.position = Agent.path.corners[2];
			}
			else
			{
				base.transform.position = Agent.path.corners[1];
			}
		}
		else
		{
			base.transform.position = Agent.path.corners[1];
		}
	}

	public void Ragdoll(bool open)
	{
		if (ragdoll != null)
		{
			if (open)
			{
				Anim.enabled = false;
				GetComponent<Collider>().enabled = false;
				ragdoll.Enable();
			}
			else
			{
				Anim.enabled = true;
				GetComponent<Collider>().enabled = true;
				ragdoll.Disable();
			}
		}
	}

	public void SetAnimDead()
	{
		if (VRGameSystem.CurGameModel == GameModel.GM_Single)
		{
			SnycDead();
		}
		else if (VRGameSystem.CurGameModel == GameModel.GM_Multi)
		{
			photonView.RPC("SnycDead", RpcTarget.All);
		}
	}

	[PunRPC]
	public void SnycDead()
	{
		Anim.SetBool("dead", value: true);
	}
}
public enum NPCState
{
	Walk,
	Attack,
	Dead
}
public class VRMonsterLevel2 : VRNpc
{
	public ParticleSystem particleSystem;

	public GameObject zhaDan;

	public NPCState curNPCState;

	private NavMeshAgent m_agent;

	private VRNpc m_target;

	private Vector3 agentDestination;

	private Animator m_anim;

	protected float initHP;

	protected float initATK;

	protected float initMoveSpeed;

	protected bool initProp;

	public float AtkTime = 3f;

	[SerializeField]
	private bool m_bInitShow;

	private float m_fNavStopDist = 2f;

	private float m_fNavStopDist_Exploded = 2.5f;

	public AniState eCurAniState;

	public bool bNeedBulletTime;

	protected bool bIsItweenPathNeedResume;

	public MonsterType monsterType;

	public string strPathName = "";

	public AttackType mAttackType;

	public GameObject BulletPrefab;

	public bool pierce;

	public float speed = 40f;

	public int scatteringPlane;

	public Transform FiringPoint;

	public GameObject mShootTarget;

	public float mBulletSpeed = 5f;

	public BulletFireType eBulletFireType;

	private VRTrigger mMyTrigger;

	private bool mIsShowBubbleText;

	private iTweenPath iTween_Path;

	public NavMeshAgent Agent
	{
		get
		{
			return m_agent;
		}
		set
		{
			m_agent = value;
		}
	}

	public new VRNpc Target
	{
		get
		{
			return m_target;
		}
		set
		{
			m_target = value;
		}
	}

	public Animator Anim
	{
		get
		{
			return m_anim;
		}
		set
		{
			m_anim = value;
		}
	}

	public bool InitProp
	{
		get
		{
			return initProp;
		}
		set
		{
			initProp = value;
		}
	}

	public bool InitShow
	{
		get
		{
			return m_bInitShow;
		}
		set
		{
			m_bInitShow = value;
		}
	}

	public VRTrigger MyTrigger
	{
		get
		{
			return mMyTrigger;
		}
		set
		{
			mMyTrigger = value;
		}
	}

	public override bool MyReset()
	{
		iTween_Path = GetComponent<iTweenPath>();
		if (!initProp)
		{
			initProp = true;
			initHP = base.Hp;
			initATK = base.Atk;
			initMoveSpeed = base.MoveSpeed;
		}
		Agent = GetComponent<NavMeshAgent>();
		Anim = GetComponent<Animator>();
		base.Hp = VRGlobal.G_GameSystem.MonsterHPBase * initHP;
		base.Atk = VRGlobal.G_GameSystem.MonsterATKBase * initATK;
		base.MoveSpeed = VRGlobal.G_GameSystem.MonsterSpeedBase * initMoveSpeed;
		if ((bool)MyTrigger)
		{
			base.Hp *= MyTrigger.MonsterHPBase_Trigger;
			base.Atk *= MyTrigger.MonsterATKBase_Trigger;
			base.MoveSpeed *= MyTrigger.MonsterSpeedBase_Trigger;
		}
		m_target = GameObject.FindGameObjectWithTag("gate").GetComponent<VRNpc>();
		if ((bool)Agent)
		{
			Agent.speed = base.MoveSpeed;
			Agent.enabled = false;
		}
		return base.MyReset();
	}

	protected override bool MyUpdate(float delta)
	{
		updateAniState();
		InitBubbleText();
		return base.MyUpdate(delta);
	}

	public void SetItweenPath()
	{
		Vector3[] path = iTweenPath.GetPath(strPathName);
		if (path != null && path.Length != 0)
		{
			System.Collections.Hashtable hashtable = new System.Collections.Hashtable();
			hashtable.Add("path", path);
			hashtable.Add("easeType", iTween.EaseType.linear);
			hashtable.Add("speed", base.MoveSpeed);
			hashtable.Add("movetopath", true);
			hashtable.Add("orienttopath", true);
			hashtable.Add("oncomplete", "ItweenReachEnd");
			iTween.MoveTo(base.gameObject, hashtable);
		}
	}

	public void PauseItweenPath()
	{
		iTween.Pause(base.gameObject);
		bIsItweenPathNeedResume = true;
	}

	public virtual void ItweenReachEnd()
	{
		bIsItweenPathNeedResume = false;
		Anim.SetTrigger("Atk");
	}

	private void InitBubbleText()
	{
		if (!mIsShowBubbleText)
		{
			VRBubbleText component = base.gameObject.GetComponent<VRBubbleText>();
			if ((bool)component && Vector3.Distance(base.transform.position, Camera.main.transform.position) < component.mMaxDisShow)
			{
				component.InitBubbleCanvas();
				mIsShowBubbleText = true;
			}
		}
	}

	public void AnimatorClear()
	{
		if ((bool)Anim)
		{
			if (monsterType == MonsterType.MT_Land)
			{
				Anim.SetBool("dodge", value: false);
			}
			Anim.SetBool("attack", value: false);
		}
	}

	public void SetFindPathDestination()
	{
		if ((bool)Target && Target.CurHP > 0f && (bool)Agent)
		{
			if (Agent.enabled)
			{
				Agent.Resume();
			}
			if (agentDestination != Target.NavPoint.position)
			{
				Agent.enabled = true;
				Agent.SetDestination(Target.NavPoint.position);
				agentDestination = Target.NavPoint.position;
			}
		}
	}

	public void StopFindPath()
	{
		if ((bool)Agent && Agent.enabled)
		{
			Agent.Stop();
		}
	}

	private float GetNavStopDist()
	{
		if (mAttackType == AttackType.AT_Explode)
		{
			return m_fNavStopDist_Exploded;
		}
		return m_fNavStopDist;
	}

	public bool CheckReachTarget()
	{
		if ((bool)Target && (bool)Agent && Agent.enabled && Agent.pathStatus == NavMeshPathStatus.PathComplete && Vector3.Distance(Agent.destination, base.transform.position) <= GetNavStopDist())
		{
			return true;
		}
		return false;
	}

	public void SoundPlay(UnityEngine.Object objSound)
	{
		if (objSound != null)
		{
			VRPlaySound component = VRGlobal.getActorEntity(objSound).GetComponent<VRPlaySound>();
			if (component != null)
			{
				component.playSound(base.transform);
			}
		}
	}

	public void PlayParticle()
	{
		particleSystem.Play();
		zhaDan.SetActive(value: false);
	}

	private void updateAniState()
	{
		AnimatorStateInfo currentAnimatorStateInfo = Anim.GetCurrentAnimatorStateInfo(0);
		if (currentAnimatorStateInfo.IsName("init"))
		{
			eCurAniState = AniState.AS_Stand;
		}
		if (currentAnimatorStateInfo.IsName("walk"))
		{
			eCurAniState = AniState.AS_Run;
		}
		if (currentAnimatorStateInfo.IsName("damage"))
		{
			eCurAniState = AniState.AS_Injure;
		}
		if (currentAnimatorStateInfo.IsName("die"))
		{
			eCurAniState = AniState.AS_Dead;
		}
		if (currentAnimatorStateInfo.IsName("attack"))
		{
			eCurAniState = AniState.AS_Attack;
		}
	}

	public void DebugMonster(bool bCriticalHit)
	{
		VRNpc killer = null;
		Vector3 pos = Vector3.zero;
		OnDamage(50f, ref killer, sound: true, ref pos);
		VRLogger.Log("MonsterCurHp=" + base.CurHP);
		switch (eCurAniState)
		{
		case AniState.AS_Stand:
			VRLogger.Log("stand");
			break;
		case AniState.AS_Run:
			VRLogger.Log("run");
			break;
		case AniState.AS_Dodge:
			VRLogger.Log("dodge");
			break;
		case AniState.AS_Show:
			VRLogger.Log("show");
			break;
		case AniState.AS_Injure:
			VRLogger.Log("injure");
			break;
		case AniState.AS_Dead:
			VRLogger.Log("dead");
			break;
		case AniState.AS_Attack:
			VRLogger.Log("attack");
			break;
		}
	}
}
public class VRMuTouItem : VRNpc
{
	protected bool exp;

	public float expTimer = 1f;

	public bool bCanAttack;

	public bool bLitmitKiller;

	public string strLimitKillerLayerName_1 = "";

	public string strLimitKillerLayerName_2 = "";

	protected override bool MyAwake()
	{
		exp = false;
		base.Camp = EU_CAMP.EU_BAD;
		VRGlobal.interActiveLib.Add(this);
		if (VRGameSystem.CurGameModel == GameModel.GM_Multi)
		{
			photonView = GetComponent<PhotonView>();
		}
		VRBubbleText component = base.gameObject.GetComponent<VRBubbleText>();
		if ((bool)component)
		{
			component.InitBubbleCanvas();
		}
		return true;
	}

	protected override bool MyUpdate(float delta)
	{
		if (exp)
		{
			expTimer -= delta;
			if (expTimer <= 0f)
			{
				expTimer = 0f;
				MeshRenderer[] componentsInChildren = GetComponentsInChildren<MeshRenderer>();
				foreach (MeshRenderer meshRenderer in componentsInChildren)
				{
					if ((bool)meshRenderer)
					{
						meshRenderer.enabled = false;
					}
				}
			}
			VRNewbieGuideMgr.OnMuTouItemExpode(this);
			bool flag = true;
			ParticleSystem[] componentsInChildren2 = base.gameObject.GetComponentsInChildren<ParticleSystem>();
			for (int j = 0; j < componentsInChildren2.Length; j++)
			{
				if (componentsInChildren2[j].isPlaying)
				{
					flag = false;
				}
			}
			if (flag)
			{
				VRGlobal.interActiveLib.Remove(this);
				base.gameObject.SetActive(value: false);
			}
		}
		return true;
	}

	public override bool OnDamage(float dmgHP, ref VRNpc killer, bool sound, ref Vector3 pos, bool isAwarded = true)
	{
		if (bCanAttack)
		{
			if (bLitmitKiller)
			{
				if ((bool)(killer as VRPlayer))
				{
					VRPlayer vRPlayer = (VRPlayer)killer;
					if ((bool)vRPlayer && (bool)vRPlayer.CurWeapon && (vRPlayer.CurWeapon.gameObject.layer == LayerMask.NameToLayer(strLimitKillerLayerName_1) || vRPlayer.CurWeapon.gameObject.layer == LayerMask.NameToLayer(strLimitKillerLayerName_2)))
					{
						Invoke("Damage", fDelayTime);
					}
				}
			}
			else
			{
				Invoke("Damage", fDelayTime);
			}
		}
		VRBubbleText component = base.gameObject.GetComponent<VRBubbleText>();
		if ((bool)component)
		{
			component.SetVisible(visible: false);
		}
		if (isAwarded)
		{
			VRGlobal.G_GameSystem.GainScore += killScore;
		}
		return true;
	}

	private void Damage()
	{
		if (exp)
		{
			return;
		}
		if (VRGameSystem.CurGameModel == GameModel.GM_Single)
		{
			MuTongDamage();
		}
		else if (VRGameSystem.CurGameModel == GameModel.GM_Multi)
		{
			photonView.RPC("MuTongDamage", RpcTarget.All);
		}
		VRNpc killer = null;
		for (int i = 0; i < VRGlobal.npcLib.Count; i++)
		{
			VRNpc vRNpc = VRGlobal.npcLib[i];
			if ((bool)vRNpc && EU_CAMP.EU_BAD == vRNpc.Camp && vRNpc != this && (vRNpc.transform.position - base.transform.position).sqrMagnitude <= atkRange * atkRange)
			{
				Vector3 pos = vRNpc.transform.position;
				vRNpc.OnDamage(vRNpc.Hp * base.Atk, ref killer, sound: false, ref pos);
			}
		}
		for (int j = 0; j < VRGlobal.interActiveLib.Count; j++)
		{
			VRNpc vRNpc2 = VRGlobal.interActiveLib[j];
			if ((bool)vRNpc2 && EU_CAMP.EU_BAD == vRNpc2.Camp && vRNpc2 != this && !vRNpc2.IsDamaged && (vRNpc2.transform.position - base.transform.position).sqrMagnitude <= atkRange * atkRange)
			{
				Vector3 pos2 = vRNpc2.transform.position;
				vRNpc2.FDelayTime = UnityEngine.Random.Range(0.5f, 1.5f);
				vRNpc2.OnDamage(vRNpc2.Hp * base.Atk, ref killer, sound: false, ref pos2);
			}
		}
	}

	[PunRPC]
	public void MuTongDamage()
	{
		m_fCurHP = 0f;
		ParticleSystem[] componentsInChildren = base.gameObject.GetComponentsInChildren<ParticleSystem>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].Play();
		}
		AudioSource component = base.gameObject.GetComponent<AudioSource>();
		if (component != null)
		{
			component.Play();
		}
		exp = true;
		base.IsDamaged = true;
		CharacterController component2 = GetComponent<CharacterController>();
		if ((bool)component2)
		{
			component2.enabled = false;
		}
		Collider component3 = GetComponent<Collider>();
		if ((bool)component3)
		{
			component3.enabled = false;
		}
	}
}
public class VRMuzzle : VRGameEntity
{
	public Vector2 UV = new Vector2(1f, 1f);

	public float lifeTimer = 1f;

	protected Vector2 m_uvOffset = Vector2.zero;

	public float m_scale = 1f;

	protected float lifeTick;

	protected Vector2 m_uvSpace = Vector2.zero;

	protected override bool MyUpdate(float delta)
	{
		lifeTick -= delta;
		if (lifeTick < 0f)
		{
			VRGlobal.pushFreeEntity(base.gameObject);
			return false;
		}
		base.transform.rotation = Quaternion.LookRotation(base.transform.position - Camera.main.transform.position);
		float num = Mathf.Lerp(m_scale, 0f, lifeTick / lifeTimer);
		base.transform.localScale = new Vector3(num, num, num);
		return base.MyUpdate(delta);
	}

	public override bool MyReset()
	{
		m_uvSpace.x = 1f / UV.x;
		m_uvSpace.y = 1f / UV.y;
		base.MyReset();
		base.transform.localScale = Vector3.zero;
		m_uvOffset.x = (float)UnityEngine.Random.Range(0, (int)UV.x) * m_uvSpace.x;
		m_uvOffset.y = (float)UnityEngine.Random.Range(0, (int)UV.y) * m_uvSpace.y;
		GetComponent<Renderer>().material.SetTextureOffset("_MainTex", m_uvOffset);
		lifeTick = lifeTimer;
		return true;
	}

	public override bool MyHide()
	{
		base.transform.parent = null;
		return base.MyHide();
	}
}
public class VRMuzzleBlade : VRMuzzle
{
	protected Vector3 movedir;

	public Vector3 MoveDir
	{
		get
		{
			return movedir;
		}
		set
		{
			movedir = value;
		}
	}

	protected override bool MyUpdate(float delta)
	{
		lifeTick -= delta;
		if (lifeTick < 0f)
		{
			VRGlobal.pushFreeEntity(base.gameObject);
			return false;
		}
		base.transform.position += movedir * (2f * delta);
		float num = Mathf.Lerp(m_scale, 0f, lifeTick / lifeTimer);
		base.transform.localScale = new Vector3(num, num, num);
		return true;
	}
}
public class VRMuzzleBlood : VRMuzzle
{
	public float vSpeed = 4f;

	private float vs;

	public override bool MyReset()
	{
		vs = vSpeed;
		base.MyReset();
		return base.MyReset();
	}

	protected override bool MyUpdate(float delta)
	{
		if (vSpeed != 0f)
		{
			vs -= 5f * delta;
			Vector3 position = base.transform.position;
			position.y += vs * delta;
			base.transform.position = position;
		}
		return base.MyUpdate(delta);
	}
}
public enum NPCType
{
	NT_None,
	NT_Monster,
	NT_Boss,
	NT_CaoDuo,
	NT_JiuTan
}
public class VRNpc : VRActor
{
	public int killScore = 10;

	public float m_fHp = 100f;

	public float m_fAtk;

	protected NPCType m_eNpcType;

	public float m_fCurHP;

	protected float phyDefBite;

	protected float phyDef;

	protected float magDefBite;

	protected float magDef;

	protected float critic;

	protected float criticReduce;

	protected float doom;

	protected float miss;

	protected float absorb;

	protected float damageBack;

	protected float reel;

	protected float reelReduce;

	protected int atkType;

	public float searchRange = 10f;

	public float atkRange = 2f;

	public float moveSpeed = 1f;

	public Vector3 itemLocationOffset;

	public GameObject shuijingModel;

	public Vector3 byHitDir;

	protected CharacterController m_controller;

	protected Animation m_animation;

	protected Vector3 moveDir = Vector3.zero;

	private VRNpc m_attackTarget;

	private Vector3 atkDir;

	protected bool itemNPC;

	public float StopPower;

	protected float pushBackTimer;

	protected float pushBackPower;

	protected Vector3 pushBackDir = Vector3.zero;

	protected float fDelayTime;

	protected bool m_bIsDamaged;

	[SerializeField]
	private Transform m_NavPoint;

	protected Vector3 initPos;

	protected Quaternion initRot;

	protected Vector3 initScale;

	protected bool bInitPoseSet;

	public UnityEngine.Object dmgSound;

	public UnityEngine.Object deadSound;

	public UnityEngine.Object criticalHitSound;

	protected float stopMove;

	protected string stopMoveAni = "stand";

	protected bool bDamaged;

	protected GameObject fireEffect;

	protected float fireDmgTimer;

	protected float onFireTime;

	public GameObject criticalHitFlash;

	public GameObject spawnFlash;

	public GameObject deadFlash;

	public GameObject blood;

	public Slider hpSlider;

	public GameObject[] dropItems;

	public string[] dropItemNames;

	public int dropItemRatio = 10;

	protected PhotonView photonView;

	public float MoveSpeed
	{
		get
		{
			return moveSpeed;
		}
		set
		{
			moveSpeed = value;
		}
	}

	public virtual VRNpc Target { get; set; }

	public int AtkType
	{
		get
		{
			return atkType;
		}
		set
		{
			atkType = value;
		}
	}

	public float PhyDefBite
	{
		get
		{
			return phyDefBite;
		}
		set
		{
			phyDefBite = value;
		}
	}

	public float PhyDef
	{
		get
		{
			return phyDef;
		}
		set
		{
			phyDef = value;
		}
	}

	public float MagDefBite
	{
		get
		{
			return magDefBite;
		}
		set
		{
			magDefBite = value;
		}
	}

	public float MagDef
	{
		get
		{
			return magDef;
		}
		set
		{
			magDef = value;
		}
	}

	public float Critic
	{
		get
		{
			return critic;
		}
		set
		{
			critic = value;
		}
	}

	public float CriticReduce
	{
		get
		{
			return criticReduce;
		}
		set
		{
			criticReduce = value;
		}
	}

	public float Doom
	{
		get
		{
			return doom;
		}
		set
		{
			doom = value;
		}
	}

	public float Miss
	{
		get
		{
			return miss;
		}
		set
		{
			miss = value;
		}
	}

	public float Absorb
	{
		get
		{
			return absorb;
		}
		set
		{
			absorb = value;
		}
	}

	public float DamageBack
	{
		get
		{
			return damageBack;
		}
		set
		{
			damageBack = value;
		}
	}

	public float Reel
	{
		get
		{
			return reel;
		}
		set
		{
			reel = value;
		}
	}

	public float ReelReduce
	{
		get
		{
			return reelReduce;
		}
		set
		{
			reelReduce = value;
		}
	}

	public float CurHP
	{
		get
		{
			return m_fCurHP;
		}
		set
		{
			m_fCurHP = value;
		}
	}

	public float Atk
	{
		get
		{
			return m_fAtk;
		}
		set
		{
			m_fAtk = value;
		}
	}

	public float Hp
	{
		get
		{
			return m_fHp;
		}
		set
		{
			m_fHp = value;
		}
	}

	public NPCType NpcType
	{
		get
		{
			return m_eNpcType;
		}
		set
		{
			m_eNpcType = value;
		}
	}

	public CharacterController _ActorControl => m_controller;

	public Animation _Animation => m_animation;

	public Vector3 MoveDir
	{
		get
		{
			return moveDir;
		}
		set
		{
			moveDir = value;
		}
	}

	public VRNpc AttackTarget
	{
		get
		{
			return m_attackTarget;
		}
		set
		{
			m_attackTarget = value;
		}
	}

	public float AttackTargetDistSqr
	{
		get
		{
			if (!(m_attackTarget != null))
			{
				return -1f;
			}
			return (m_attackTarget.transform.position - base.transform.position).sqrMagnitude;
		}
	}

	public Vector3 AttackTargetDir
	{
		get
		{
			if (m_attackTarget == null)
			{
				return base.transform.forward;
			}
			atkDir = m_attackTarget.transform.position - base.transform.position;
			atkDir.y = 0f;
			atkDir.Normalize();
			return atkDir;
		}
	}

	public bool ItemNPC
	{
		get
		{
			return itemNPC;
		}
		set
		{
			itemNPC = value;
		}
	}

	public float FDelayTime
	{
		get
		{
			return fDelayTime;
		}
		set
		{
			fDelayTime = value;
		}
	}

	public bool IsDamaged
	{
		get
		{
			return m_bIsDamaged;
		}
		set
		{
			m_bIsDamaged = value;
		}
	}

	public Transform NavPoint
	{
		get
		{
			return m_NavPoint;
		}
		set
		{
			m_NavPoint = value;
		}
	}

	public float StopMove
	{
		get
		{
			return stopMove;
		}
		set
		{
			stopMove = value;
		}
	}

	public string StopMoveAni
	{
		get
		{
			return stopMoveAni;
		}
		set
		{
			stopMoveAni = value;
		}
	}

	public bool BDamaged
	{
		get
		{
			return bDamaged;
		}
		set
		{
			bDamaged = value;
		}
	}

	public float OnFireTime
	{
		get
		{
			return onFireTime;
		}
		set
		{
			if (CurHP > 0f)
			{
				onFireTime = value;
				if (fireEffect == null)
				{
					fireEffect = VRGlobal.getActorEntity(VRGlobal.G_GameSystem.PlyFire);
				}
			}
		}
	}

	public void SetInitPose()
	{
		initPos = base.transform.position;
		initRot = base.transform.rotation;
		initScale = base.transform.localScale;
		bInitPoseSet = true;
	}

	public GameObject GetDropItem()
	{
		if (VRGameSystem.CurGameModel == GameModel.GM_Single)
		{
			GameObject gameObject = CalcDropItem();
			if ((bool)gameObject)
			{
				GameObject actorEntity = VRGlobal.getActorEntity(gameObject);
				if ((bool)actorEntity)
				{
					actorEntity.transform.position = base.transform.position + itemLocationOffset;
					return actorEntity;
				}
			}
		}
		else if (VRGameSystem.CurGameModel == GameModel.GM_Multi)
		{
			string dropItemName = GetDropItemName();
			if (!string.IsNullOrWhiteSpace(dropItemName))
			{
				GameObject actorEntity2 = VRGlobal.getActorEntity(dropItemName, GameModel.GM_Multi, Vector3.zero, Quaternion.identity);
				if ((bool)actorEntity2)
				{
					actorEntity2.transform.position = base.transform.position + itemLocationOffset;
					return actorEntity2;
				}
			}
		}
		return null;
	}

	public GameObject CalcDropItem()
	{
		if (dropItems.Length == 0)
		{
			return null;
		}
		if (UnityEngine.Random.Range(0, 100) < dropItemRatio)
		{
			return dropItems[UnityEngine.Random.Range(0, dropItems.Length)];
		}
		return null;
	}

	public string GetDropItemName()
	{
		if (dropItemNames.Length == 0)
		{
			return null;
		}
		if (UnityEngine.Random.Range(0, 100) < dropItemRatio)
		{
			return dropItemNames[UnityEngine.Random.Range(0, dropItemNames.Length)];
		}
		return null;
	}

	public Transform findTransform(Transform p, string tn)
	{
		if (p.gameObject.activeSelf)
		{
			if (p.gameObject.name == tn)
			{
				return p;
			}
			int childCount = p.childCount;
			for (int i = 0; i < childCount; i++)
			{
				Transform transform = findTransform(p.GetChild(i), tn);
				if (transform != null)
				{
					return transform;
				}
			}
		}
		return null;
	}

	protected override bool MyAwake()
	{
		m_animation = GetComponentInChildren<Animation>();
		m_controller = GetComponent<CharacterController>();
		if (NavPoint == null)
		{
			NavPoint = base.transform;
		}
		if (VRGameSystem.CurGameModel == GameModel.GM_Multi)
		{
			photonView = GetComponent<PhotonView>();
		}
		return base.MyAwake();
	}

	protected override bool MyUpdate(float delta)
	{
		if ((bool)hpSlider && hpSlider.value != m_fCurHP)
		{
			hpSlider.value = m_fCurHP;
			if (hpSlider.value <= 0f)
			{
				hpSlider.gameObject.SetActive(value: false);
			}
		}
		onFireTime -= delta;
		if (onFireTime <= 0f || CurHP <= 0f)
		{
			onFireTime = 0f;
			if (fireEffect != null)
			{
				VRGlobal.pushFreeEntity(fireEffect);
				fireEffect = null;
			}
		}
		else
		{
			fireDmgTimer -= delta;
			if (fireDmgTimer <= 0f)
			{
				fireDmgTimer = 1f;
				VRNpc killer = null;
				Vector3 pos = base.transform.position;
				float num = Hp * 0.2f;
				if (num > 1000f)
				{
					num = 1000f;
				}
				OnDamage(num, ref killer, sound: false, ref pos);
			}
		}
		if (fireEffect != null)
		{
			Vector3 position = base.transform.position;
			position.y += 1f;
			fireEffect.transform.position = position;
		}
		bool result = base.MyUpdate(delta);
		stopMove -= delta;
		if (stopMove < 0f)
		{
			stopMove = 0f;
			stopMoveAni = "stand";
		}
		if (pushBackTimer > 0f && m_fCurHP > 0f)
		{
			pushBackTimer -= delta;
			Vector3 motion = pushBackDir * (pushBackPower * delta);
			motion.y = -1f;
			_ActorControl.Move(motion);
		}
		return result;
	}

	protected override bool MyStart()
	{
		return base.MyStart();
	}

	public override bool MyReset()
	{
		AttackTarget = null;
		m_fCurHP = m_fHp;
		if ((bool)hpSlider)
		{
			hpSlider.maxValue = m_fHp;
		}
		if (bInitPoseSet)
		{
			base.transform.position = initPos;
			base.transform.rotation = initRot;
			base.transform.localScale = initScale;
		}
		if (base.gameObject.tag == "gate")
		{
			VRGlobal.npcLib.Add(this);
		}
		return base.MyReset();
	}

	public override bool MyHide()
	{
		AttackTarget = null;
		return base.MyHide();
	}

	public float ATKFinal(ref VRNpc tgt, float coe)
	{
		float num = 1f;
		if (atkType == 1)
		{
			float num2 = phyDefBite - tgt.phyDef;
			num = ((!(num2 >= 0f)) ? (1f / (1f - num2 / 100f)) : (1f + num2 / 100f));
		}
		else if (atkType == 2)
		{
			float num3 = magDefBite - tgt.magDef;
			num = ((!(num3 >= 0f)) ? (1f / (1f - num3 / 100f)) : (1f + num3 / 100f));
		}
		int num4 = (int)(UnityEngine.Random.Range(0.8f, 1.2f) * coe * num * Atk);
		if (num4 < 1)
		{
			num4 = 1;
		}
		return num4;
	}

	public virtual void RecoverHP(float value)
	{
		m_fCurHP += value;
		if (m_fCurHP > Hp)
		{
			m_fCurHP = Hp;
		}
		if (VRGameSystem.CurGameModel == GameModel.GM_Multi)
		{
			photonView.RPC("UpdateHp", RpcTarget.All, m_fCurHP);
		}
	}

	public virtual bool OnDamage(float dmgHP, ref VRNpc killer, bool sound, ref Vector3 pos, bool isAwarded = true)
	{
		DragonController component = GetComponent<DragonController>();
		if ((bool)component)
		{
			component.wounded = true;
		}
		bool flag = true;
		if (dmgHP < 0f)
		{
			dmgHP = 0f - dmgHP;
			flag = false;
		}
		Vector3 position = base.transform.position;
		if (killer != null && flag)
		{
			AttackTarget = killer;
			float num = 1f - Mathf.Abs(1f / (1f + (killer.reel - reelReduce) * 0.01f));
			if (num > 0f && UnityEngine.Random.Range(0f, 1f) <= num && VRGlobal.inCameraSpace(position))
			{
				stopMove = 3f;
				stopMoveAni = "stand";
			}
			float num2 = ((miss > 100f) ? 100f : miss);
			float num3 = ((killer.doom > 100f) ? 100f : killer.doom);
			float num4 = 1f / (1f + (num2 - num3) / 100f);
			if (num4 < 1f)
			{
				num4 *= 100f;
				if (UnityEngine.Random.Range(0, 100) > (int)num4)
				{
					VRGlobal.inCameraSpace(position);
					if (VRGameSystem.CurGameModel == GameModel.GM_Multi)
					{
						photonView.RPC("UpdateHp", RpcTarget.All, m_fCurHP);
					}
					return true;
				}
			}
		}
		if (m_fCurHP > 0f)
		{
			playEffectAction("hitFlash");
			float num5 = 0f;
			num5 += dmgHP;
			m_fCurHP -= dmgHP;
			VRGlobal.inCameraSpace(position);
			if (killer != null && flag)
			{
				float num6 = (killer.critic - criticReduce) / 500f;
				if (num6 > 1f || (num6 > 0f && UnityEngine.Random.Range(0f, 1f) <= num6))
				{
					num5 += dmgHP;
					m_fCurHP -= dmgHP;
					VRLogger.Log("出暴击了");
					playEffectAction("criticalHitFlash");
					if (sound && criticalHitSound != null)
					{
						VRPlaySound component2 = VRGlobal.getActorEntity(criticalHitSound).GetComponent<VRPlaySound>();
						if (component2 != null)
						{
							component2.playSound(base.transform);
						}
					}
				}
			}
			if (num5 > 0f && killer != null && killer.CurHP > 0f && flag)
			{
				float num7 = killer.Absorb * num5 / 10000f;
				if (num7 > 0f)
				{
					if (num7 < 1f)
					{
						num7 = 1f;
					}
					killer.CurHP += num7;
					if (killer.CurHP > killer.Hp)
					{
						killer.CurHP = killer.Hp;
					}
					VRGlobal.inCameraSpace(position);
				}
				float num8 = damageBack * num5 / 10000f;
				if (num8 > 0f)
				{
					if (num8 < 1f)
					{
						num8 = 1f;
					}
					VRNpc killer2 = this;
					Vector3 pos2 = killer2.transform.position;
					killer.OnDamage(0f - num8, ref killer2, sound, ref pos2);
				}
			}
			GateBreaked();
			if (m_fCurHP <= 0f)
			{
				m_fCurHP = 0f;
				if (isAwarded)
				{
					VRGlobal.G_GameSystem.GainScore += killScore;
				}
				VRBubbleText component3 = base.gameObject.GetComponent<VRBubbleText>();
				if ((bool)component3)
				{
					component3.SetVisible(visible: false);
				}
				if (sound && deadSound != null)
				{
					VRPlaySound component4 = VRGlobal.getActorEntity(deadSound).GetComponent<VRPlaySound>();
					if (component4 != null)
					{
						component4.playSound(base.transform);
					}
				}
				m_fCurHP = 0f;
				if (this is VRMonster)
				{
					if (VRGameSystem.CurGameModel == GameModel.GM_Single)
					{
						PlayMonsterDeadAnim();
					}
					else if (VRGameSystem.CurGameModel == GameModel.GM_Multi)
					{
						foreach (Player value in PhotonNetwork.CurrentRoom.Players.Values)
						{
							photonView.RPC("PlayMonsterDeadAnim", value);
						}
					}
				}
				OnDeath();
			}
			else
			{
				if (sound && dmgSound != null)
				{
					VRPlaySound component5 = VRGlobal.getActorEntity(dmgSound).GetComponent<VRPlaySound>();
					if (component5 != null)
					{
						component5.playSound(base.transform);
					}
				}
				if (this is VRMonster)
				{
					if (VRGameSystem.CurGameModel == GameModel.GM_Single)
					{
						MonsterInjureAnim();
					}
					else if (VRGameSystem.CurGameModel == GameModel.GM_Multi)
					{
						photonView.RPC("MonsterInjureAnim", RpcTarget.All);
					}
				}
				if (AttackTarget == null && killer != null)
				{
					AttackTarget = killer;
				}
				if (killer != null && killer.StopPower > 0f)
				{
					pushBackTimer = 0.1f;
					pushBackPower = killer.StopPower;
					pushBackDir = base.transform.position - killer.transform.position;
					pushBackDir.Normalize();
				}
			}
			if (VRGameSystem.CurGameModel == GameModel.GM_Multi)
			{
				photonView.RPC("UpdateHp", RpcTarget.All, m_fCurHP);
			}
			return true;
		}
		if (VRGameSystem.CurGameModel == GameModel.GM_Multi)
		{
			photonView.RPC("UpdateHp", RpcTarget.All, m_fCurHP);
		}
		return false;
	}

	protected virtual void OnDeath()
	{
	}

	[PunRPC]
	public virtual void UpdateHp(float value)
	{
		if (!(this is VRPlayer))
		{
			m_fCurHP = value;
		}
	}

	private void GateBreaked()
	{
		if (base.gameObject.tag == "gate")
		{
			float num = CurHP / Hp;
			if (VRGameSystem.CurGameModel == GameModel.GM_Single)
			{
				GateHitSync(num);
			}
			else if (VRGameSystem.CurGameModel == GameModel.GM_Multi)
			{
				photonView.RPC("GateHitSync", RpcTarget.All, num);
			}
		}
	}

	[PunRPC]
	public void GateHitSync(float percent)
	{
		foreach (Transform componentInChild in shuijingModel.GetComponentInChildren<Transform>())
		{
			if ((bool)componentInChild)
			{
				VRBreakable component = componentInChild.gameObject.GetComponent<VRBreakable>();
				if ((bool)component)
				{
					component.Explode(percent);
				}
			}
		}
	}

	[PunRPC]
	public void MonsterInjureAnim()
	{
		VRMonster vRMonster = (VRMonster)this;
		if (!vRMonster.Anim)
		{
			vRMonster.Anim = GetComponent<Animator>();
		}
		vRMonster.Anim.CrossFadeInFixedTime("injure", 0.01f);
	}

	[PunRPC]
	public void PlayMonsterDeadAnim()
	{
		VRMonster vRMonster = (VRMonster)this;
		if (!vRMonster.Anim)
		{
			vRMonster.Anim = GetComponent<Animator>();
		}
		if (VRGlobal.G_GameSystem.bossHatchMonster.Contains(base.gameObject))
		{
			VRGlobal.G_GameSystem.bossHatchMonster.Remove(base.gameObject);
			if (VRGlobal.G_GameSystem.bossHatchMonster.Count == 0)
			{
				if (VRGameSystem.CurGameModel == GameModel.GM_Single)
				{
					ClearBossSpqanMonster();
				}
				else if (VRGameSystem.CurGameModel == GameModel.GM_Multi)
				{
					photonView.RPC("ClearBossSpqanMonster", RpcTarget.All);
				}
			}
		}
		vRMonster.Anim.CrossFadeInFixedTime("dead", 0.01f);
	}

	[PunRPC]
	public void ClearBossSpqanMonster()
	{
		VRGlobal.G_GameSystem.IsHasBossSpwanMonster = false;
	}

	public void BossSpawnNpc(Vector3 pos)
	{
		RPCBossSpawn(pos);
	}

	[PunRPC]
	private void RPCBossSpawn(Vector3 pos)
	{
		base.gameObject.SetActive(value: true);
		MyReset();
		base.transform.position = pos;
		base.enabled = true;
		base.Camp = EU_CAMP.EU_BAD;
		VRGlobal.npcLib.Add(this);
		CharacterController component = base.gameObject.GetComponent<CharacterController>();
		if ((bool)component)
		{
			component.enabled = true;
		}
		if ((bool)GetComponent<VRActorActSpawnAction>())
		{
			playAction("spawn");
		}
		if (!(this as VRBoss))
		{
			return;
		}
		AudioSource[] components = VRGlobal.G_GameSystem.GetComponents<AudioSource>();
		for (int i = 0; i < components.Length; i++)
		{
			if (components[i].clip != null && components[i].clip.name == "warning")
			{
				components[i].Play();
			}
		}
	}
}
public class VRNpcSpawn : VRGameEntity
{
	public GameObject spawnPlayer(UnityEngine.Object inPrefab, Vector3 inPos, Quaternion inRot)
	{
		GameObject obj = (GameObject)inPrefab;
		obj.SetActive(value: true);
		VRNpc component = obj.GetComponent<VRNpc>();
		component.Camp = EU_CAMP.EU_GOOD;
		component.transform.position = inPos;
		component.transform.rotation = inRot;
		VRGlobal.npcLib.Add(component);
		return obj;
	}

	protected override bool MyStart()
	{
		return base.MyStart();
	}
}
public class VRPlaySound : VRGameEntity
{
	public AudioSource soundPlayer;

	public AudioClip[] sound;

	public bool playSound(Transform inFather)
	{
		if (sound.Length != 0)
		{
			AudioClip audioClip = sound[UnityEngine.Random.Range(0, sound.Length)];
			if (audioClip != null)
			{
				base.transform.parent = inFather;
				base.transform.localPosition = Vector3.zero;
				soundPlayer.rolloffMode = AudioRolloffMode.Linear;
				soundPlayer.clip = audioClip;
				soundPlayer.Play();
			}
		}
		return true;
	}

	protected override bool MyUpdate(float delta)
	{
		if (!soundPlayer.isPlaying)
		{
			VRGlobal.pushFreeEntity(base.gameObject);
			return false;
		}
		return base.MyUpdate(delta);
	}

	public override bool MyHide()
	{
		base.transform.parent = null;
		soundPlayer.clip = null;
		return base.MyHide();
	}
}
public class VRPlayer : VRNpc
{
	public HarmViewController viewController;

	protected float initATK;

	private bool _curCanDamage = true;

	private VRWeapon m_CurWeaponObj;

	public bool CurCanDamage
	{
		get
		{
			return _curCanDamage;
		}
		set
		{
			_curCanDamage = value;
		}
	}

	public VRWeapon CurWeapon
	{
		get
		{
			return m_CurWeaponObj;
		}
		set
		{
			m_CurWeaponObj = value;
		}
	}

	protected override bool MyAwake()
	{
		base.MyAwake();
		return true;
	}

	protected override bool MyUpdate(float delta)
	{
		return base.MyUpdate(delta);
	}

	public override bool MyReset()
	{
		initATK = base.Atk;
		VRGlobal.npcLib.Add(this);
		base.MyReset();
		return true;
	}

	public override bool OnDamage(float dmgHP, ref VRNpc killer, bool sound, ref Vector3 pos, bool isAwarded = true)
	{
		if (!CurCanDamage)
		{
			return true;
		}
		viewController.OnDamageView(dmgHP / base.Hp);
		return base.OnDamage(dmgHP, ref killer, sound, ref pos, isAwarded: false);
	}

	protected override void OnDeath()
	{
		if (VRGameSystem.CurGameModel == GameModel.GM_Multi)
		{
			DealPlayerDead();
		}
		base.OnDeath();
		viewController.OnDieView(isDie: true);
	}

	public bool EquipWeapon(VRWeapon weapon)
	{
		if (CurWeapon != weapon)
		{
			CurWeapon = weapon;
			base.Atk = initATK * weapon.AtkAdjustRatio;
			return true;
		}
		return false;
	}

	public void DealPlayerDead()
	{
		ExitGames.Client.Photon.Hashtable propertiesToSet = new ExitGames.Client.Photon.Hashtable { { "ISDEAD", true } };
		PhotonNetwork.LocalPlayer.SetCustomProperties(propertiesToSet);
		VRGlobal.G_GameSystem.localPlayerIsDie = true;
		VRGlobal.G_GameSystem.weaponManager.equipWeapon(WeaponType.WT_None);
		bool flag = true;
		foreach (Player value in PhotonNetwork.CurrentRoom.Players.Values)
		{
			if (!(bool)value.CustomProperties["ISDEAD"])
			{
				CurCanDamage = false;
				photonView.RPC("BeComeBossTarget", value);
				flag = false;
				break;
			}
		}
		if (flag)
		{
			photonView.RPC("GameFiald", RpcTarget.All);
		}
	}

	[PunRPC]
	public void BeComeBossTarget()
	{
		CurCanDamage = true;
		for (int i = 0; i < VRGlobal.npcLib.Count; i++)
		{
			if (VRGlobal.npcLib[i] is VRBoss)
			{
				(VRGlobal.npcLib[i] as VRBoss).SetItweenPathDest();
			}
		}
	}

	[PunRPC]
	private void GameFiald()
	{
		VRGlobal.G_GameSystem.weaponManager.equipWeapon(WeaponType.WT_None);
		VRGameSystem.CurGameState = GameState.GS_Fail;
	}

	public bool ReloadBullet()
	{
		if (CurWeapon == null || CurWeapon.eCurWeaponType == WeaponType.WT_None)
		{
			return false;
		}
		CurWeapon.reloadBullet();
		return true;
	}

	public bool FireBullet()
	{
		if (CurWeapon == null || CurWeapon.eCurWeaponType == WeaponType.WT_None)
		{
			return false;
		}
		base.Critic = 0f;
		StopPower = 0f;
		Vector3 inShotDir = CurWeapon.GetShortDir();
		float fSpeed = CurWeapon.speed * CurWeapon.SpeedAddition;
		CurWeapon.fire(ref inShotDir, CurWeapon.transform, camp, atkRange, fSpeed, (VRNpc)m_mySelf);
		return true;
	}

	public bool FireSkillBullet(bool bCriticalHit = true)
	{
		if (CurWeapon == null || CurWeapon.eCurWeaponType == WeaponType.WT_None)
		{
			return false;
		}
		if (bCriticalHit)
		{
			base.Critic = 1000f;
		}
		Vector3 inShotDir = CurWeapon.GetShortDir();
		float fSpeed = CurWeapon.speed * CurWeapon.SpeedAddition * CurWeapon.SkillSpeedAddition;
		CurWeapon.fireSkill(ref inShotDir, CurWeapon.transform, camp, atkRange, fSpeed, (VRNpc)m_mySelf);
		return true;
	}
}
public class VRSceneItweenMoveObj : MonoBehaviour
{
	public float fMoveSpeed = 1f;

	private void SetItweenPath()
	{
		Vector3[] path = iTweenPath.GetPath(base.gameObject.name);
		if (path != null && path.Length != 0)
		{
			System.Collections.Hashtable hashtable = new System.Collections.Hashtable();
			hashtable.Add("path", path);
			hashtable.Add("easeType", iTween.EaseType.linear);
			hashtable.Add("speed", fMoveSpeed);
			hashtable.Add("movetopath", true);
			hashtable.Add("orienttopath", true);
			hashtable.Add("oncomplete", "ItweenReachEnd");
			iTween.MoveTo(base.gameObject, hashtable);
		}
	}

	private void ItweenReachEnd()
	{
		SetItweenPath();
	}

	private void Start()
	{
		SetItweenPath();
	}

	private void Update()
	{
	}
}
public class VRSingletonRoot : MonoBehaviour
{
	private static GameObject singletonRoot;

	public static GameObject GetSingletonRootObj()
	{
		if (singletonRoot == null)
		{
			singletonRoot = new GameObject("_SingletonRoot");
			UnityEngine.Object.DontDestroyOnLoad(singletonRoot);
		}
		return singletonRoot;
	}
}
public class VRSingletonBehaviour<T> : MonoBehaviour where T : MonoBehaviour
{
	private static T mInstance;

	private static bool mApplicationIsQuitting = false;

	private static object mLock = new object();

	public static T Instance
	{
		get
		{
			if (mApplicationIsQuitting)
			{
				return null;
			}
			lock (mLock)
			{
				if (mInstance == null)
				{
					mInstance = (T)UnityEngine.Object.FindObjectOfType(typeof(T));
					if (UnityEngine.Object.FindObjectsOfType(typeof(T)).Length > 1)
					{
						VRLogger.LogError("[Singleton] Something went really wrong  - there should never be more than 1 singleton! Reopenning the scene might fix it.");
						return mInstance;
					}
					if (mInstance == null)
					{
						GameObject obj = new GameObject();
						mInstance = obj.AddComponent<T>();
						obj.name = "(Singleton)_" + typeof(T).ToString();
					}
				}
				return mInstance;
			}
		}
	}

	public static void CreateInstane()
	{
		if (Instance == null)
		{
			UnityEngine.Debug.LogError("Create Timer Instance Failed!");
		}
	}

	protected virtual void Awake()
	{
		if (!mInstance)
		{
			mInstance = this as T;
		}
		base.transform.parent = VRSingletonRoot.GetSingletonRootObj().transform;
	}

	protected virtual void OnDestroy()
	{
		mApplicationIsQuitting = true;
		mInstance = null;
	}
}
public class VRSingleton<T> where T : class, new()
{
	private static T mInstance;

	private static object mLock = new object();

	public static T Instance
	{
		get
		{
			lock (mLock)
			{
				if (mInstance == null)
				{
					mInstance = new T();
				}
				return mInstance;
			}
		}
	}
}
public class VRSupplyCreature : VRNpc
{
	protected bool exp;

	private Light lit;

	private VRActorAction deadFlashAction;

	private bool bIsDamage;

	public string strPathName = "";

	public string deathAniName = "";

	public bool isLookPathPos = true;

	public bool isMovetopath = true;

	public iTween.LoopType loopType;

	private TweenerCore<Vector3, DG.Tweening.Plugins.Core.PathCore.Path, PathOptions> core;

	private bool mIsShowBubbleText;

	protected override bool MyAwake()
	{
		base.transform.localRotation = Quaternion.AngleAxis(180f, Vector3.up);
		m_animation = GetComponent<Animation>();
		base.Camp = EU_CAMP.EU_BAD;
		lit = base.gameObject.GetComponentInChildren<Light>();
		VRGlobal.npcLib.Add(this);
		return base.MyAwake();
	}

	public override bool MyReset()
	{
		SetItweenPath();
		return base.MyReset();
	}

	private void InitBubbleText()
	{
		if (!mIsShowBubbleText)
		{
			VRBubbleText component = base.gameObject.GetComponent<VRBubbleText>();
			if ((bool)component && Vector3.Distance(base.transform.position, Camera.main.transform.position) < component.mMaxDisShow)
			{
				component.InitBubbleCanvas();
				mIsShowBubbleText = true;
			}
		}
	}

	protected override bool MyUpdate(float delta)
	{
		if (bIsDamage && m_animation != null && !m_animation.IsPlaying(deathAniName) && (!deadFlashAction || ((bool)deadFlashAction && !deadFlashAction.isRuning)))
		{
			if (VRGlobal.G_GameSystem.Gate.CurHP > VRGlobal.G_GameSystem.Gate.Hp)
			{
				VRGlobal.G_GameSystem.Gate.CurHP = VRGlobal.G_GameSystem.Gate.Hp;
			}
			VRGlobal.npcLib.Remove(this);
			VRGlobal.pushFreeEntity(base.gameObject);
		}
		else if (bIsDamage && (!deadFlashAction || ((bool)deadFlashAction && !deadFlashAction.isRuning)))
		{
			if (VRGlobal.G_GameSystem.Gate.CurHP > VRGlobal.G_GameSystem.Gate.Hp)
			{
				VRGlobal.G_GameSystem.Gate.CurHP = VRGlobal.G_GameSystem.Gate.Hp;
			}
			VRGlobal.npcLib.Remove(this);
			VRGlobal.pushFreeEntity(base.gameObject);
		}
		InitBubbleText();
		return base.MyUpdate(delta);
	}

	private void SetItweenPath()
	{
		if ((VRGameSystem.CurGameModel == GameModel.GM_Multi && !PhotonNetwork.IsMasterClient) || strPathName == "")
		{
			return;
		}
		Vector3[] path = iTweenPath.GetPath(strPathName);
		if (path != null && path.Length != 0)
		{
			if (base.name.Contains("Sparrow Prefab"))
			{
				core = base.transform.DOPath(path, UnityEngine.Random.Range(base.MoveSpeed - 1f, base.MoveSpeed + 3.5f) * 10f, DG.Tweening.PathType.CatmullRom);
				core.SetLookAt(0.001f);
				core.SetEase(Ease.Linear);
				core.SetLoops(1);
				core.OnComplete(ItweenReachEnd);
			}
			else
			{
				System.Collections.Hashtable hashtable = new System.Collections.Hashtable();
				hashtable.Add("path", path);
				hashtable.Add("easeType", iTween.EaseType.linear);
				hashtable.Add("speed", base.MoveSpeed);
				hashtable.Add("movetopath", isMovetopath);
				hashtable.Add("orienttopath", isLookPathPos);
				hashtable.Add("loopType", loopType);
				hashtable.Add("oncomplete", "ItweenReachEnd");
				iTween.MoveTo(base.gameObject, hashtable);
			}
		}
	}

	private void ItweenReachEnd()
	{
		if (!isLookPathPos)
		{
			if (deadSound != null)
			{
				VRPlaySound component = VRGlobal.getActorEntity(deadSound).GetComponent<VRPlaySound>();
				if (component != null)
				{
					component.playSound(base.transform);
				}
			}
			deadFlashAction = playEffectAction("deadFlash");
		}
		SetItweenPath();
	}

	public override bool OnDamage(float dmgHP, ref VRNpc killer, bool sound, ref Vector3 pos, bool isAwarded = true)
	{
		if (m_fCurHP > 0f)
		{
			if (VRGameSystem.CurGameModel == GameModel.GM_Single)
			{
				DeadAction();
			}
			else if (VRGameSystem.CurGameModel == GameModel.GM_Multi)
			{
				photonView.RPC("DeadAction", RpcTarget.All);
			}
			if (isAwarded)
			{
				VRGlobal.G_GameSystem.GainScore += killScore;
			}
			GetDropItem();
			return true;
		}
		return false;
	}

	[PunRPC]
	public void DeadAction()
	{
		if (m_animation != null)
		{
			m_animation.CrossFade(deathAniName);
		}
		if (deadSound != null)
		{
			VRPlaySound component = VRGlobal.getActorEntity(deadSound).GetComponent<VRPlaySound>();
			if (component != null)
			{
				component.playSound(base.transform);
			}
		}
		deadFlashAction = playEffectAction("deadFlash");
		if (m_animation == null)
		{
			base.transform.GetChild(0).gameObject.SetActive(value: false);
		}
		m_fCurHP = 0f;
		CharacterController component2 = GetComponent<CharacterController>();
		if ((bool)component2)
		{
			component2.enabled = false;
		}
		VRBubbleText component3 = base.gameObject.GetComponent<VRBubbleText>();
		if ((bool)component3)
		{
			component3.SetVisible(visible: false);
		}
		iTween.Stop(base.gameObject);
		if (core != null)
		{
			core.Kill();
		}
		if ((bool)lit)
		{
			lit.enabled = false;
		}
		bIsDamage = true;
		FallOff();
	}

	private void FallOff()
	{
		Rigidbody component = base.transform.GetComponent<Rigidbody>();
		if (component != null)
		{
			component.isKinematic = false;
			component.useGravity = true;
		}
	}
}
internal class VRSystemMonitor : VRSingletonBehaviour<VRSystemMonitor>
{
	private double mUpdateInterval = 0.5;

	private double mLastInterval;

	private int mFrames;

	public double fps;

	private double mLowestFrames = 99.0;

	private float mLastCalTime;

	public bool IsShowSystem;

	public Resolution[] resolutions = Screen.resolutions;

	private void Start()
	{
		float realtimeSinceStartup = Time.realtimeSinceStartup;
		mLastInterval = realtimeSinceStartup;
		mFrames = 0;
	}

	private void Update()
	{
		float realtimeSinceStartup = Time.realtimeSinceStartup;
		mFrames++;
		double num = realtimeSinceStartup;
		if (num > mLastInterval + mUpdateInterval)
		{
			fps = (double)mFrames / (num - mLastInterval);
			mFrames = 0;
			mLastInterval = num;
		}
	}

	private void OnGUI()
	{
		GUILayout.Space(0f);
		GUILayout.BeginHorizontal();
		string text = "C";
		if (!IsShowSystem)
		{
			text = "O";
		}
		if (GUILayout.Button(text, GUILayout.Width(23f), GUILayout.Height(23f)))
		{
			IsShowSystem = !IsShowSystem;
		}
		GUIStyle box = GUI.skin.box;
		box.richText = true;
		box.alignment = TextAnchor.MiddleLeft;
		box.fontSize = 14;
		if (IsShowSystem)
		{
			GUILayout.Label(string.Concat(string.Concat(string.Concat(string.Concat(string.Concat(string.Concat(string.Concat(string.Concat(string.Concat(string.Concat(string.Concat(string.Concat(string.Concat("" + $"分辨率:<color=#00ffffff>{Screen.width}x{Screen.height}</color>,", $"内存:<color=#00ffffff>{SystemInfo.systemMemorySize}</color>,"), $"显存:<color=#00ffffff>{SystemInfo.graphicsMemorySize}</color>,"), string.Format("deltaTime:<color=#00ffffff>{0}</color>,", Time.deltaTime.ToString("f4"))), string.Format("游戏运行时间:<color=#00ffffff>{0}</color>,", Time.realtimeSinceStartup.ToString("f1"))), $"设备唯一id:<color=#ff00ffff>{SystemInfo.deviceUniqueIdentifier}</color>\n"), $"显卡:<color=#ffff00ff>{SystemInfo.graphicsDeviceName}</color>,"), $"显卡版本:<color=#ffff00ff>{SystemInfo.graphicsDeviceVersion}</color>,"), $"Shader版本:<color=#ffff00ff>{SystemInfo.graphicsShaderLevel}</color>\n"), $"操作系统:<color=#3ca5acff>{SystemInfo.operatingSystem}</color>\n"), $"CPU架构:<color=#3b9fe5ff>{SystemInfo.processorType}</color>,"), $"CPU核心数:<color=#3b9fe5ff>{SystemInfo.processorCount}</color>\n"), $"持久保存路径:<color=#8b7decff>{Application.persistentDataPath}</color>\n"), $"内部资源路径:<color=#8b7decff>{Application.streamingAssetsPath}</color>\n"), box);
		}
		box.fontSize = 12;
		float realtimeSinceStartup = Time.realtimeSinceStartup;
		if (realtimeSinceStartup - mLastCalTime > 10f)
		{
			mLastCalTime = realtimeSinceStartup;
			mLowestFrames = 99.0;
		}
		if (fps < mLowestFrames)
		{
			mLowestFrames = fps;
			mLastCalTime = realtimeSinceStartup;
		}
		GUILayout.Label(string.Format("FPS:<color=#00ffffff>{0}</color>(<color=#ff0000ff>{1}</color>)", fps.ToString("f2"), mLowestFrames.ToString("f2")), box);
		box.fontSize = 14;
		GUILayout.EndHorizontal();
	}
}
public class VRTerrain : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}

	private void Active()
	{
	}
}
public class VRTrigger : MonoBehaviour
{
	public GameObject nextTrigger;

	protected bool activeFlag;

	[HideInInspector]
	public VRCheckPoint theCheckPoint;

	public float MonsterHPBase_Trigger = 1f;

	public float MonsterATKBase_Trigger = 1f;

	public float MonsterSpeedBase_Trigger = 1f;

	public float MonsterBulletBase_Trigger = 1f;

	public bool ActiveFlag => activeFlag;

	public bool haveNextTrigger()
	{
		return nextTrigger == null;
	}

	private void Start()
	{
		for (int i = 0; i < base.gameObject.transform.childCount; i++)
		{
			Transform child = base.gameObject.transform.GetChild(i);
			child.gameObject.SetActive(value: false);
			VRNpc component = child.GetComponent<VRNpc>();
			if (component != null)
			{
				component.Camp = EU_CAMP.EU_BAD;
				component.SetInitPose();
			}
		}
		if (nextTrigger != null)
		{
			nextTrigger.SetActive(value: false);
			nextTrigger.GetComponent<MeshRenderer>().enabled = false;
			VRTrigger component2 = nextTrigger.GetComponent<VRTrigger>();
			if (component2 != null)
			{
				component2.theCheckPoint = theCheckPoint;
			}
		}
	}

	private void Update()
	{
		if (activeFlag)
		{
			Active();
			return;
		}
		bool flag = true;
		for (int i = 0; i < base.transform.childCount; i++)
		{
			if (base.transform.GetChild(i).gameObject.activeSelf)
			{
				flag = false;
			}
		}
		if (flag && !VRGlobal.G_GameSystem.IsHasBossSpwanMonster)
		{
			if ((bool)nextTrigger)
			{
				nextTrigger.SetActive(value: true);
				theCheckPoint.CurTrigger = nextTrigger.GetComponent<VRTrigger>();
				theCheckPoint.CurTrigger.ResetNpc();
				VRGlobal.G_GameSystem.setCurrentTrigger(nextTrigger);
			}
			base.gameObject.SetActive(value: false);
		}
	}

	public void ResetNpc()
	{
		for (int i = 0; i < base.gameObject.transform.childCount; i++)
		{
			Transform child = base.gameObject.transform.GetChild(i);
			child.gameObject.SetActive(value: true);
			child.gameObject.GetComponent<VRNpc>().MyReset();
		}
		activeFlag = true;
		Start();
	}

	private void OnTriggerEnter(Collider other)
	{
		if (activeFlag && other != null && other.gameObject.GetComponent<VRGameEntity>() as VRPlayer == VRGlobal.G_GameSystem.CurPlayer)
		{
			Active();
		}
	}

	private void Active()
	{
		for (int i = 0; i < VRGlobal.G_GameSystem.CurCheckPoint.transform.childCount; i++)
		{
			Transform child = VRGlobal.G_GameSystem.CurCheckPoint.transform.GetChild(i);
			if (child.name.Contains("Warn"))
			{
				GameObject obj = child.gameObject;
				obj.SetActive(value: true);
				obj.GetComponent<MeshRenderer>().enabled = true;
			}
		}
		activeFlag = false;
		for (int j = 0; j < base.gameObject.transform.childCount; j++)
		{
			Transform npc = base.gameObject.transform.GetChild(j);
			VRMonster component = npc.gameObject.GetComponent<VRMonster>();
			if ((bool)component)
			{
				component.MyTrigger = this;
			}
			VRBoss component2 = npc.gameObject.GetComponent<VRBoss>();
			if (component2 == null)
			{
				SpawnNpc(ref npc);
			}
			else
			{
				component2.Init();
				VRGlobal.G_GameSystem.uiManager.ShowBossWarning();
			}
			if (npc.gameObject.name == "kulouBoos")
			{
				VRGlobal.G_GameSystem.uiManager.ShowBossWarning();
			}
		}
	}

	public void SpawnBoss()
	{
		for (int i = 0; i < base.gameObject.transform.childCount; i++)
		{
			Transform npc = base.gameObject.transform.GetChild(i);
			VRBoss component = npc.gameObject.GetComponent<VRBoss>();
			if (component != null)
			{
				component.MyTrigger = this;
				SpawnNpc(ref npc);
			}
		}
	}

	public static void SpawnNpc(ref Transform npc, bool playAction = true, string initAction = "", bool bAdjustLSCCAtckRange = true)
	{
		npc.gameObject.SetActive(value: true);
		VRNpc component = npc.gameObject.GetComponent<VRNpc>();
		component.MyReset();
		component.enabled = true;
		VRGlobal.npcLib.Add(component);
		VRBlink component2 = npc.gameObject.GetComponent<VRBlink>();
		if ((bool)component2)
		{
			component2.enabled = true;
			component2.Show();
		}
		VRBoss component3 = npc.gameObject.GetComponent<VRBoss>();
		if ((bool)component3)
		{
			component3.SetItweenPathDest();
		}
		CharacterController component4 = npc.gameObject.GetComponent<CharacterController>();
		if ((bool)component4)
		{
			component4.enabled = true;
		}
		if ((bool)component.GetComponent<VRActorActSpawnAction>())
		{
			component.playAction("spawn");
		}
		if (!(component as VRBoss))
		{
			return;
		}
		AudioSource[] components = VRGlobal.G_GameSystem.GetComponents<AudioSource>();
		for (int i = 0; i < components.Length; i++)
		{
			if (components[i].clip != null && components[i].clip.name == "warning")
			{
				components[i].Play();
			}
		}
	}
}
public class VRUIBlink : MonoBehaviour
{
	public GameObject mTarget;

	public float mTimeForOneBlink = 1.5f;

	private void Start()
	{
		Show();
	}

	private void Update()
	{
	}

	public void Show()
	{
		Image component = mTarget.GetComponent<Image>();
		if ((bool)component)
		{
			component.enabled = true;
		}
		Invoke("Hide", mTimeForOneBlink);
	}

	public void Hide()
	{
		Image component = mTarget.GetComponent<Image>();
		if ((bool)component)
		{
			component.enabled = false;
		}
		Invoke("Show", 0.5f);
	}
}
public class VRThrowableWeapon : VRActor
{
	public float fAtk = 100f;

	private void OnCollisionEnter(Collision otherobj)
	{
		if (otherobj.gameObject.tag == "enemy")
		{
			VRNpc component = otherobj.gameObject.GetComponent<VRNpc>();
			if ((bool)component)
			{
				Vector3 pos = base.transform.position;
				VRNpc killer = null;
				component.OnDamage(fAtk, ref killer, sound: true, ref pos);
			}
			return;
		}
		Rigidbody component2 = GetComponent<Rigidbody>();
		if ((bool)component2)
		{
			component2.velocity *= 0.5f;
		}
		if ((bool)otherobj.gameObject.GetComponent<AudioSource>())
		{
			otherobj.gameObject.GetComponent<AudioSource>().Play();
		}
	}
}
public enum BulletFireType
{
	BFT_Kinematic,
	BFT_Physic
}
public enum WeaponType
{
	WT_None,
	WT_Crossbow,
	WT_LongBow
}
public class VRWeapon : VRGameEntity
{
	public PhotonView photonView;

	public UnityEngine.Object muzzlePrefab;

	protected int idxMuzzle;

	protected Transform[] muzzlePos;

	protected Light gunlit;

	protected float gunlitTimer;

	public BulletFireType eBulletFireType = BulletFireType.BFT_Physic;

	public float speed = 40f;

	public int shotNum = 1;

	public int scatteringPlane;

	public bool pierce;

	public UnityEngine.Object BulletPrefab;

	public string bulletPrefabName;

	public float vOffset;

	public UnityEngine.Object fireSound;

	public WeaponType eCurWeaponType;

	public int nBulletCapcity = 2;

	public int nCurFireBulletNum;

	private float mSpeedAddition = 1f;

	public float SkillSpeedAddition = 1f;

	public float AtkAdjustRatio = 1f;

	public float SpeedAddition
	{
		get
		{
			return mSpeedAddition;
		}
		set
		{
			mSpeedAddition = value;
		}
	}

	public int getShotNumFinal(VRNpc owner)
	{
		return shotNum;
	}

	protected override bool MyUpdate(float delta)
	{
		if (VRGameSystem.CurGameModel == GameModel.GM_Multi && !photonView.IsMine)
		{
			return false;
		}
		if (gunlit != null)
		{
			gunlitTimer -= delta;
			if (gunlitTimer <= 0f)
			{
				gunlit.enabled = false;
				gunlitTimer = 0f;
			}
			gunlit.intensity = gunlitTimer * 8f / 0.2f;
		}
		return true;
	}

	protected override bool MyAwake()
	{
		if (VRGameSystem.CurGameModel == GameModel.GM_Multi && !photonView.IsMine)
		{
			return false;
		}
		gunlit = base.gameObject.GetComponentInChildren<Light>();
		if (muzzlePos == null)
		{
			Transform transform = null;
			Transform transform2 = null;
			Transform[] componentsInChildren = base.gameObject.GetComponentsInChildren<Transform>();
			if (componentsInChildren != null)
			{
				for (int i = 0; i < componentsInChildren.Length; i++)
				{
					if (componentsInChildren[i].name == "Bip001 L fire")
					{
						transform = componentsInChildren[i];
					}
					else if (componentsInChildren[i].name == "Bip001 R fire")
					{
						transform2 = componentsInChildren[i];
					}
				}
			}
			if (transform != null && transform2 != null)
			{
				muzzlePos = new Transform[2];
				muzzlePos[0] = transform;
				muzzlePos[1] = transform2;
			}
			else if (transform != null || transform2 != null)
			{
				muzzlePos = new Transform[1];
				muzzlePos[0] = ((transform != null) ? transform : transform2);
			}
		}
		return base.MyAwake();
	}

	protected virtual void showMuzzle(ref Vector3 pos, ref Quaternion rot)
	{
		if (VRGameSystem.CurGameModel == GameModel.GM_Multi && !photonView.IsMine)
		{
			return;
		}
		if (muzzlePrefab != null)
		{
			GameObject actorEntity = VRGlobal.getActorEntity(muzzlePrefab);
			actorEntity.transform.rotation = rot;
			actorEntity.transform.position = pos;
			actorEntity.transform.parent = base.transform;
		}
		if (fireSound != null)
		{
			if (VRGameSystem.CurGameModel == GameModel.GM_Single)
			{
				PlayFireSound(pos);
			}
			else if (VRGameSystem.CurGameModel == GameModel.GM_Multi)
			{
				photonView.RPC("PlayFireSound", RpcTarget.All, pos);
			}
		}
	}

	[PunRPC]
	public void PlayFireSound(Vector3 pos)
	{
		getFireSound(pos).GetComponent<VRPlaySound>().playSound(base.transform);
	}

	private GameObject getFireSound(Vector3 pos)
	{
		if (VRGameSystem.CurGameModel == GameModel.GM_Single)
		{
			GameObject actorEntity = VRGlobal.getActorEntity(fireSound);
			actorEntity.transform.position = pos;
			return actorEntity;
		}
		if (VRGameSystem.CurGameModel == GameModel.GM_Multi)
		{
			return VRGlobal.getActorEntity(fireSound.name, GameModel.GM_Multi, pos, Quaternion.identity);
		}
		return null;
	}

	public virtual void reloadBullet()
	{
		nCurFireBulletNum = 0;
	}

	public virtual bool IsNeedReloadBullet()
	{
		return nCurFireBulletNum >= nBulletCapcity;
	}

	protected virtual GameObject GetBulletObj(Vector3 pos, Quaternion qua)
	{
		if (VRGameSystem.CurGameModel == GameModel.GM_Single)
		{
			return VRGlobal.getActorEntity(BulletPrefab);
		}
		if (VRGameSystem.CurGameModel == GameModel.GM_Multi)
		{
			return VRGlobal.getActorEntity(bulletPrefabName, GameModel.GM_Multi, pos, qua);
		}
		return null;
	}

	public virtual bool fire(ref Vector3 inShotDir, Transform inPos, EU_CAMP inCamp, float ATKRange, float fSpeed, VRNpc owner, bool bIncreaseFireBulletNum = true)
	{
		if (bIncreaseFireBulletNum)
		{
			nCurFireBulletNum++;
		}
		Transform transform = null;
		if (muzzlePos != null && muzzlePos.Length != 0)
		{
			transform = muzzlePos[idxMuzzle];
			idxMuzzle++;
			idxMuzzle %= muzzlePos.Length;
		}
		Vector3 forward = inShotDir;
		Vector3 inPos2 = ((transform != null) ? transform.position : inPos.transform.position);
		Quaternion rot = Quaternion.LookRotation(forward);
		if (getShotNumFinal(owner) == 1)
		{
			GameObject gameObject = null;
			gameObject = GetBulletObj(inPos2, base.transform.rotation);
			gameObject.transform.position = inPos2;
			Quaternion identity = Quaternion.identity;
			identity.eulerAngles = new Vector3(0f, UnityEngine.Random.Range(-scatteringPlane, scatteringPlane), 0f);
			switch (eBulletFireType)
			{
			case BulletFireType.BFT_Physic:
			{
				VRBulletPhysic component2 = gameObject.GetComponent<VRBulletPhysic>();
				component2.Camp = inCamp;
				component2.Pierce = pierce;
				component2.transform.rotation = rot * identity;
				forward = component2.transform.forward;
				component2.SetTrail(isOpen: true);
				component2.fire(ref inPos2, ref forward, ATKRange, fSpeed.Equals(0f) ? speed : fSpeed, inCamp, owner);
				break;
			}
			case BulletFireType.BFT_Kinematic:
			{
				VRBulletKinematic component = gameObject.GetComponent<VRBulletKinematic>();
				component.Camp = inCamp;
				component.Pierce = pierce;
				component.transform.rotation = rot * identity;
				forward = component.transform.forward;
				component.fire(ref inPos2, ref forward, ATKRange, fSpeed.Equals(0f) ? speed : fSpeed, inCamp, owner);
				break;
			}
			}
		}
		else
		{
			float num = (float)scatteringPlane * 2f / (float)(getShotNumFinal(owner) - 1);
			for (int i = 0; i < getShotNumFinal(owner); i++)
			{
				GameObject gameObject2 = null;
				gameObject2 = GetBulletObj(inPos2, base.transform.rotation);
				gameObject2.transform.position = inPos2;
				Quaternion identity2 = Quaternion.identity;
				identity2.eulerAngles = new Vector3(0f, (float)(-scatteringPlane) + num * (float)i, 0f);
				switch (eBulletFireType)
				{
				case BulletFireType.BFT_Physic:
				{
					VRBulletPhysic component4 = gameObject2.GetComponent<VRBulletPhysic>();
					component4.Camp = inCamp;
					component4.Pierce = pierce;
					component4.transform.rotation = rot * identity2;
					component4.SetTrail(isOpen: true);
					forward = component4.transform.forward;
					component4.fire(ref inPos2, ref forward, ATKRange, fSpeed.Equals(0f) ? speed : fSpeed, inCamp, owner);
					break;
				}
				case BulletFireType.BFT_Kinematic:
				{
					VRBulletKinematic component3 = gameObject2.GetComponent<VRBulletKinematic>();
					component3.Camp = inCamp;
					component3.Pierce = pierce;
					component3.transform.rotation = rot * identity2;
					forward = component3.transform.forward;
					component3.fire(ref inPos2, ref forward, ATKRange, fSpeed.Equals(0f) ? speed : fSpeed, inCamp, owner);
					break;
				}
				}
			}
		}
		showMuzzle(ref inPos2, ref rot);
		if (gunlit != null)
		{
			gunlit.enabled = true;
			gunlitTimer = 0.2f;
		}
		OnWeaponFireEnd();
		return false;
	}

	public virtual bool fireSkill(ref Vector3 inShotDir, Transform inPos, EU_CAMP inCamp, float ATKRange, float fSpeed, VRNpc owner)
	{
		return fire(ref inShotDir, inPos, inCamp, ATKRange, fSpeed, owner);
	}

	protected virtual void OnWeaponFireEnd()
	{
	}

	public virtual Vector3 GetShortDir()
	{
		return base.transform.forward;
	}

	public virtual void HideWeaponEff()
	{
	}
}
public class VRWeaponCrossBow : VRWeapon
{
	private VRGrabCrossBow interActObj;

	private ParticleSystem skillEff;

	private float m_fUsingDuration;

	private float m_fUsingTimer;

	private bool m_nLastUsing;

	public float fSkillTriggerMinTime = 1f;

	private Animation anim;

	private Transform inPos;

	private EU_CAMP inCamp;

	private float ATKRange;

	private float fSpeed;

	private VRNpc owner;

	private bool bIncreaseFireBulletNum;

	protected override bool MyAwake()
	{
		if (anim == null)
		{
			anim = GetComponent<Animation>();
		}
		if (VRGameSystem.CurGameModel == GameModel.GM_Multi && !photonView.IsMine)
		{
			return false;
		}
		return base.MyAwake();
	}

	public override bool MyReset()
	{
		if (VRGameSystem.CurGameModel == GameModel.GM_Multi && !photonView.IsMine)
		{
			return false;
		}
		if (interActObj == null)
		{
			interActObj = GetComponent<VRGrabCrossBow>();
		}
		ParticleSystem[] componentsInChildren = base.gameObject.GetComponentsInChildren<ParticleSystem>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			if (componentsInChildren[i].gameObject.name == "skillEff")
			{
				skillEff = componentsInChildren[i];
			}
		}
		if ((bool)skillEff)
		{
			skillEff.gameObject.SetActive(value: false);
		}
		return base.MyReset();
	}

	protected override bool MyUpdate(float delta)
	{
		if (VRGameSystem.CurGameModel == GameModel.GM_Multi && !photonView.IsMine)
		{
			return false;
		}
		if ((bool)interActObj)
		{
			VRGlobal.G_GameSystem.CurPlayer.EquipWeapon(this);
			if (interActObj.InReadyShoot())
			{
				m_fUsingTimer += delta;
				m_nLastUsing = true;
				if (m_fUsingTimer > fSkillTriggerMinTime)
				{
					if ((bool)skillEff)
					{
						skillEff.gameObject.SetActive(value: true);
					}
					interActObj.Vibrate();
				}
			}
			else
			{
				m_fUsingDuration = m_fUsingTimer;
				m_fUsingTimer = 0f;
				if (m_fUsingDuration > fSkillTriggerMinTime)
				{
					VRGlobal.G_GameSystem.CurPlayer.FireSkillBullet(bCriticalHit: false);
					m_nLastUsing = false;
				}
				else if (m_nLastUsing)
				{
					interActObj.Vibrate();
					if (IsNeedReloadBullet())
					{
						VRGlobal.G_GameSystem.CurPlayer.ReloadBullet();
					}
					else if (!anim.IsPlaying("sheji"))
					{
						VRGlobal.G_GameSystem.CurPlayer.FireBullet();
					}
					m_nLastUsing = false;
				}
			}
		}
		return base.MyUpdate(delta);
	}

	public override bool IsNeedReloadBullet()
	{
		return false;
	}

	public override bool fire(ref Vector3 inShotDir, Transform inPos, EU_CAMP inCamp, float ATKRange, float fSpeed, VRNpc owner, bool bIncreaseFireBulletNum)
	{
		if (VRGameSystem.CurGameModel == GameModel.GM_Multi)
		{
			if (!photonView.IsMine)
			{
				return false;
			}
			photonView.RPC("PlayShootAnim", RpcTarget.All);
		}
		else if (VRGameSystem.CurGameModel == GameModel.GM_Single)
		{
			PlayShootAnim();
		}
		this.inPos = inPos;
		this.inCamp = inCamp;
		this.ATKRange = ATKRange;
		this.fSpeed = fSpeed;
		this.owner = owner;
		this.bIncreaseFireBulletNum = bIncreaseFireBulletNum;
		return true;
	}

	[PunRPC]
	public void PlayShootAnim()
	{
		anim["sheji"].speed = 1f;
		anim.Play("sheji");
	}

	public override bool fireSkill(ref Vector3 inShotDir, Transform inPos, EU_CAMP inCamp, float ATKRange, float fSpeed, VRNpc owner)
	{
		if (VRGameSystem.CurGameModel == GameModel.GM_Multi && !photonView.IsMine)
		{
			return false;
		}
		if ((bool)skillEff && skillEff.gameObject.activeSelf)
		{
			skillEff.gameObject.SetActive(value: false);
		}
		scatteringPlane = 1;
		shotNum = 3;
		return fire(ref inShotDir, inPos, inCamp, ATKRange, fSpeed, owner, bIncreaseFireBulletNum: false);
	}

	protected override void OnWeaponFireEnd()
	{
		scatteringPlane = 0;
		shotNum = 1;
	}

	public void OnShejiFireEnable()
	{
		if (VRGameSystem.CurGameModel != GameModel.GM_Multi || photonView.IsMine)
		{
			Vector3 inShotDir = GetShortDir();
			base.fire(ref inShotDir, inPos, inCamp, ATKRange, fSpeed, owner, bIncreaseFireBulletNum);
		}
	}

	public override void HideWeaponEff()
	{
		if ((bool)skillEff && skillEff.gameObject.activeSelf)
		{
			skillEff.gameObject.SetActive(value: false);
		}
	}
}
public class VRWeaponLongBow : VRWeapon
{
	[Space]
	public VR_GrabbedWeapon interActObj;

	public string arrowPrefabName;

	public GameObject arrowPrefab;

	public GameObject boneLine;

	public GameObject boneLineInitPos;

	public GameObject skillEff;

	[SerializeField]
	private VRBulletPhysic currentArrow;

	public float fMaxPullDist = 0.5f;

	public float fPullSpeed = 1f;

	public float fArrowBornInterval = 0.5f;

	public float activeSkillTimer = 1f;

	public AudioSource pk_sound;

	private float dajianDistance = 0.1f;

	private float curUsingTimer;

	private bool isSwpanArrow = true;

	private bool isAttached;

	private Vector3 ShotDir = Vector3.zero;

	private float fLastDist;

	private Transform ArrowContrlObj
	{
		get
		{
			if ((bool)UnityXR_Controller.Instance.HandleSys && (bool)interActObj)
			{
				switch (interActObj.weaponHand)
				{
				case XRDeviceType.DT_Left:
					return UnityXR_Controller.Instance.HandleSys.GetTransform(XRDeviceType.DT_Right);
				case XRDeviceType.DT_Right:
					return UnityXR_Controller.Instance.HandleSys.GetTransform(XRDeviceType.DT_Left);
				}
			}
			return null;
		}
	}

	public void AttachArrowToBow()
	{
		currentArrow.SetParent(boneLine.transform);
		currentArrow.SetLocalPosition(Vector3.zero);
		currentArrow.SetLocalRotation(Quaternion.identity);
		isAttached = true;
	}

	public void AttachArrowToHand()
	{
		isAttached = false;
		currentArrow.SetParent(ArrowContrlObj.transform);
		currentArrow.SetLocalPosition(Vector3.zero);
		currentArrow.SetLocalRotation(Quaternion.identity);
		boneLine.transform.position = boneLineInitPos.transform.position;
		interActObj.transform.localRotation = Quaternion.Euler(interActObj.equipRotation.x, interActObj.equipRotation.y, interActObj.equipRotation.z);
		base.transform.localRotation = Quaternion.identity;
	}

	private void AttachArrowToController()
	{
		if ((VRGameSystem.CurGameModel != GameModel.GM_Multi || photonView.IsMine) && VRGameSystem.CurGameState != GameState.GS_Finish && VRGameSystem.CurGameState != GameState.GS_End && VRGameSystem.CurGameState != GameState.GS_Fail && currentArrow == null && isSwpanArrow)
		{
			GameObject arrowObj = GetArrowObj(ArrowContrlObj.transform.position, ArrowContrlObj.transform.rotation);
			currentArrow = arrowObj.GetComponent<VRBulletPhysic>();
			currentArrow.SetRig(isKinematic: true, isUseGravity: false);
			currentArrow.SetParent(ArrowContrlObj.transform);
			currentArrow.SetLocalPosition(Vector3.zero);
			currentArrow.SetLocalRotation(Quaternion.identity);
			currentArrow.SetTrail(isOpen: false);
			fLastDist = 0f;
			isSwpanArrow = false;
		}
	}

	private void OnEnable()
	{
		isSwpanArrow = true;
	}

	private void OnDisable()
	{
		if (VRGameSystem.CurGameModel == GameModel.GM_Single)
		{
			DisableCurrentArrow();
		}
		else
		{
			photonView.RPC("DisableCurrentArrow", RpcTarget.All);
		}
	}

	[PunRPC]
	public void DisableCurrentArrow()
	{
		StopAllCoroutines();
		if ((bool)currentArrow)
		{
			currentArrow.DisableArrow();
			boneLine.transform.position = boneLineInitPos.transform.position;
			isSwpanArrow = true;
			currentArrow = null;
		}
	}

	protected override bool MyUpdate(float delta)
	{
		if (VRGameSystem.CurGameModel == GameModel.GM_Multi && !photonView.IsMine)
		{
			return false;
		}
		if ((bool)currentArrow)
		{
			if (!currentArrow.gameObject.activeSelf)
			{
				currentArrow.gameObject.SetActive(value: true);
			}
			VRGlobal.G_GameSystem.CurPlayer.EquipWeapon(this);
			if (!isAttached && Mathf.Abs(Vector3.Distance(boneLineInitPos.transform.position, ArrowContrlObj.position)) <= dajianDistance)
			{
				AttachArrowToBow();
			}
			if (isAttached)
			{
				if (interActObj.IsShoot())
				{
					Vibrate(1f);
					if (isAttached)
					{
						Fire();
					}
				}
				else if (interActObj.InReadyShoot())
				{
					AimBow();
					PullString();
				}
				else
				{
					if ((bool)pk_sound && pk_sound.isPlaying)
					{
						pk_sound.Pause();
					}
					if (Mathf.Abs(Vector3.Distance(boneLineInitPos.transform.position, ArrowContrlObj.position)) > dajianDistance)
					{
						AttachArrowToHand();
					}
				}
			}
			else if ((bool)pk_sound && pk_sound.isPlaying)
			{
				pk_sound.Stop();
			}
		}
		else
		{
			isAttached = false;
			AttachArrowToController();
		}
		SkillEffect();
		return base.MyUpdate(delta);
	}

	private void AimBow()
	{
		if ((VRGameSystem.CurGameModel != GameModel.GM_Multi || photonView.IsMine) && isAttached)
		{
			Vector3 eulerAngles = Quaternion.LookRotation(interActObj.grabPos.position - ArrowContrlObj.position, interActObj.grabPos.TransformDirection(Vector3.forward)).eulerAngles;
			Vector3 eulerAngles2 = base.transform.rotation.eulerAngles;
			base.transform.rotation = Quaternion.Euler(eulerAngles.x, eulerAngles.y, eulerAngles2.z);
		}
	}

	public void SkillEffect()
	{
		if (!isAttached)
		{
			if (skillEff.gameObject.activeSelf)
			{
				skillEff.gameObject.SetActive(value: false);
			}
		}
		else if ((bool)interActObj && fLastDist >= fMaxPullDist / 2f)
		{
			curUsingTimer += Time.deltaTime;
			if (curUsingTimer > activeSkillTimer && (bool)skillEff)
			{
				skillEff.gameObject.SetActive(value: true);
			}
			Vibrate(0.6f);
		}
		else
		{
			if ((bool)skillEff && skillEff.gameObject.activeSelf)
			{
				skillEff.gameObject.SetActive(value: false);
			}
			curUsingTimer = 0f;
		}
	}

	private void PullString()
	{
		if (VRGameSystem.CurGameModel == GameModel.GM_Multi && !photonView.IsMine)
		{
			return;
		}
		float magnitude = (boneLineInitPos.transform.position - ArrowContrlObj.position).magnitude;
		if (magnitude > fMaxPullDist)
		{
			magnitude = fMaxPullDist;
		}
		if ((bool)pk_sound)
		{
			if (magnitude >= fLastDist + 0.005f)
			{
				if (!pk_sound.isPlaying)
				{
					pk_sound.Play();
				}
			}
			else if (pk_sound.isPlaying)
			{
				pk_sound.Pause();
			}
		}
		boneLine.transform.localPosition = boneLineInitPos.transform.localPosition + new Vector3(0f, 0f, (0f - fPullSpeed) * magnitude);
		fLastDist = magnitude;
	}

	private void Fire()
	{
		if ((VRGameSystem.CurGameModel != GameModel.GM_Multi || photonView.IsMine) && !(currentArrow == null))
		{
			isAttached = false;
			ShotDir = currentArrow.transform.forward;
			if (skillEff.gameObject.activeSelf)
			{
				VRGlobal.G_GameSystem.CurPlayer.FireSkillBullet();
			}
			else
			{
				VRGlobal.G_GameSystem.CurPlayer.FireBullet();
			}
			base.SpeedAddition = (boneLineInitPos.transform.position - ArrowContrlObj.transform.position).magnitude;
			boneLine.transform.position = boneLineInitPos.transform.position;
			interActObj.transform.localRotation = Quaternion.Euler(interActObj.equipRotation.x, interActObj.equipRotation.y, interActObj.equipRotation.z);
			base.transform.localRotation = Quaternion.identity;
			StartCoroutine(SetSwpanArrow(fArrowBornInterval));
		}
	}

	private IEnumerator SetSwpanArrow(float secend)
	{
		PhotonNetwork.Destroy(currentArrow.gameObject);
		currentArrow = null;
		yield return new WaitForSeconds(secend);
		isSwpanArrow = true;
	}

	public void Vibrate(float fDist)
	{
		if (VRGameSystem.CurGameModel != GameModel.GM_Multi || photonView.IsMine)
		{
			interActObj.AllHandVibrate();
		}
	}

	public override Vector3 GetShortDir()
	{
		return ShotDir;
	}

	public override bool fire(ref Vector3 inShotDir, Transform inPos, EU_CAMP inCamp, float ATKRange, float fSpeed, VRNpc owner, bool bIncreaseFireBulletNum)
	{
		return base.fire(ref inShotDir, inPos, inCamp, ATKRange, fSpeed, owner, bIncreaseFireBulletNum);
	}

	public override bool fireSkill(ref Vector3 inShotDir, Transform inPos, EU_CAMP inCamp, float ATKRange, float fSpeed, VRNpc owner)
	{
		if ((bool)skillEff && skillEff.gameObject.activeSelf)
		{
			skillEff.gameObject.SetActive(value: false);
		}
		return fire(ref inShotDir, inPos, inCamp, ATKRange, fSpeed, owner, bIncreaseFireBulletNum: false);
	}

	public override bool IsNeedReloadBullet()
	{
		return false;
	}

	protected override GameObject GetBulletObj(Vector3 pos, Quaternion qua)
	{
		return base.GetBulletObj(pos, qua);
	}

	protected virtual GameObject GetArrowObj(Vector3 pos, Quaternion qua)
	{
		if (VRGameSystem.CurGameModel == GameModel.GM_Single)
		{
			return VRGlobal.getActorEntity(arrowPrefab);
		}
		if (VRGameSystem.CurGameModel == GameModel.GM_Multi)
		{
			return VRGlobal.getActorEntity(arrowPrefabName, GameModel.GM_Multi, pos, qua);
		}
		return null;
	}

	public override void HideWeaponEff()
	{
		if ((bool)skillEff && skillEff.gameObject.activeSelf)
		{
			skillEff.gameObject.SetActive(value: false);
		}
	}
}
public class VRWeaponMelee : VRWeapon
{
	protected override void showMuzzle(ref Vector3 pos, ref Quaternion rot)
	{
		if (muzzlePrefab != null)
		{
			GameObject actorEntity = VRGlobal.getActorEntity(muzzlePrefab);
			actorEntity.transform.rotation = rot;
			actorEntity.transform.position = pos;
			actorEntity.transform.parent = base.transform;
			Vector3 eulerAngles = actorEntity.transform.eulerAngles;
			eulerAngles.x = 90f + (float)UnityEngine.Random.Range(-10, 10);
			eulerAngles.y += UnityEngine.Random.Range(-45, 45);
			actorEntity.transform.eulerAngles = eulerAngles;
			VRMuzzleBlade component = actorEntity.GetComponent<VRMuzzleBlade>();
			Vector3 moveDir = actorEntity.transform.TransformDirection(new Vector3(0f, 1f, 0f));
			moveDir.y = 0f;
			component.MoveDir = moveDir;
		}
		if (fireSound != null)
		{
			GameObject actorEntity2 = VRGlobal.getActorEntity(fireSound);
			actorEntity2.transform.position = pos;
			actorEntity2.GetComponent<VRPlaySound>().playSound(base.transform);
		}
	}

	public override bool fire(ref Vector3 inShotDir, Transform inPos, EU_CAMP inCamp, float ATKRange, float fSpeed, VRNpc owner, bool bIncreaseFireBulletNum)
	{
		if (muzzlePos.Length != 0)
		{
			idxMuzzle++;
			idxMuzzle %= muzzlePos.Length;
			Vector3 position = owner.transform.position;
			Vector3 forward = inShotDir;
			Vector3 pos = inPos.position;
			pos.y += vOffset;
			pos.x = position.x;
			pos.z = position.z;
			Quaternion rot = Quaternion.LookRotation(forward);
			showMuzzle(ref pos, ref rot);
			for (int i = 0; i < VRGlobal.npcLib.Count; i++)
			{
				VRNpc tgt = VRGlobal.npcLib[i];
				if (inCamp != tgt.Camp && inRange(tgt, ATKRange))
				{
					Vector3 pos2 = tgt.transform.position;
					tgt.OnDamage(owner.ATKFinal(ref tgt, 1f), ref owner, sound: true, ref pos2);
				}
			}
			for (int j = 0; j < VRGlobal.interActiveLib.Count; j++)
			{
				VRNpc tgt2 = VRGlobal.interActiveLib[j];
				if (inRange(tgt2, ATKRange))
				{
					Vector3 pos3 = tgt2.transform.position;
					tgt2.OnDamage(owner.ATKFinal(ref tgt2, 1f), ref owner, sound: true, ref pos3);
				}
			}
			if (gunlit != null)
			{
				gunlit.enabled = true;
				gunlitTimer = 0.3f;
			}
		}
		return false;
	}

	public bool inRange(VRNpc npc, float ATKRange)
	{
		Vector3 rhs = npc.transform.position - base.transform.position;
		if (npc.CurHP > 0f && rhs.sqrMagnitude <= ATKRange * ATKRange && Vector3.Dot(base.transform.TransformDirection(new Vector3(0f, 0f, 1f)), rhs) >= 0f)
		{
			return true;
		}
		return false;
	}
}
public class WeaponManager : MonoBehaviour
{
	public PhotonView photonView;

	[Space]
	[Header("默认值")]
	public WeaponType defaultWeapon;

	[Space]
	[Header("当前值")]
	public WeaponType curWeaponType;

	[Space]
	[Header("游戏中的武器")]
	public List<VR_GrabbedWeapon> crossBow = new List<VR_GrabbedWeapon>();

	public VR_GrabbedWeapon bow;

	[Space]
	[Header("切换武器的按键")]
	public XRDeviceKeyStruct switchWeapon;

	private UnityXR_ButtonHandler switchWeaponHandler;

	public void Init()
	{
		loadData();
		if (VRGameSystem.CurGameModel == GameModel.GM_Single)
		{
			equipWeapon(WeaponType.WT_LongBow);
		}
		else
		{
			equipWeapon(WeaponType.WT_Crossbow);
		}
	}

	private void Update()
	{
		if (VRGameSystem.CurGameState == GameState.GS_Finish || VRGameSystem.CurGameState == GameState.GS_End || VRGameSystem.CurGameState == GameState.GS_Fail)
		{
			return;
		}
		if (VRGameSystem.CurGameModel == GameModel.GM_Single)
		{
			if (VRGlobal.G_GameSystem.CurStageID < 11)
			{
				return;
			}
		}
		else if (VRGameSystem.CurGameModel == GameModel.GM_Multi && (!photonView.IsMine || VRGlobal.G_GameSystem.localPlayerIsDie))
		{
			return;
		}
		if (!VRGlobal.G_GameSystem.isPause && switchWeaponHandler.IsUplift)
		{
			switch (curWeaponType)
			{
			case WeaponType.WT_Crossbow:
				equipWeapon(WeaponType.WT_LongBow);
				break;
			case WeaponType.WT_LongBow:
				equipWeapon(WeaponType.WT_Crossbow);
				break;
			case WeaponType.WT_None:
				break;
			}
		}
	}

	public void equipWeapon(WeaponType weapon)
	{
		curWeaponType = weapon;
		if (weapon == WeaponType.WT_LongBow)
		{
			bow.Equip();
		}
		else
		{
			bow.Unwield(base.transform);
		}
		for (int i = 0; i < crossBow.Count; i++)
		{
			if (weapon == WeaponType.WT_Crossbow)
			{
				crossBow[i].Equip();
			}
			else
			{
				crossBow[i].Unwield(base.transform);
			}
		}
	}

	private void loadData()
	{
		if (UnityXR_Controller.Instance.InputSys.GetInputHandler(switchWeapon.deviceType, switchWeapon.keyType) is UnityXR_ButtonHandler)
		{
			switchWeaponHandler = UnityXR_Controller.Instance.InputSys.GetInputHandler(switchWeapon.deviceType, switchWeapon.keyType) as UnityXR_ButtonHandler;
			return;
		}
		UnityEngine.Debug.LogError(string.Concat(base.gameObject.name, "切换武器的按键种类当前为：", switchWeapon.keyType, "；此类型不是button输入事件"));
	}

	private void OnValidate()
	{
		while (crossBow.Count > 2)
		{
			crossBow.RemoveAt(crossBow.Count - 1);
		}
	}
}
public class iTween : MonoBehaviour
{
	private delegate float EasingFunction(float start, float end, float Value);

	private delegate void ApplyTween();

	public enum EaseType
	{
		easeInQuad,
		easeOutQuad,
		easeInOutQuad,
		easeInCubic,
		easeOutCubic,
		easeInOutCubic,
		easeInQuart,
		easeOutQuart,
		easeInOutQuart,
		easeInQuint,
		easeOutQuint,
		easeInOutQuint,
		easeInSine,
		easeOutSine,
		easeInOutSine,
		easeInExpo,
		easeOutExpo,
		easeInOutExpo,
		easeInCirc,
		easeOutCirc,
		easeInOutCirc,
		linear,
		spring,
		easeInBounce,
		easeOutBounce,
		easeInOutBounce,
		easeInBack,
		easeOutBack,
		easeInOutBack,
		easeInElastic,
		easeOutElastic,
		easeInOutElastic,
		punch
	}

	public enum LoopType
	{
		none,
		loop,
		pingPong
	}

	public enum NamedValueColor
	{
		_Color,
		_SpecColor,
		_Emission,
		_ReflectColor
	}

	public static class Defaults
	{
		public static float time = 1f;

		public static float delay = 0f;

		public static NamedValueColor namedColorValue = NamedValueColor._Color;

		public static LoopType loopType = LoopType.none;

		public static EaseType easeType = EaseType.easeOutExpo;

		public static float lookSpeed = 3f;

		public static bool isLocal = false;

		public static Space space = Space.Self;

		public static bool orientToPath = false;

		public static Color color = Color.white;

		public static float updateTimePercentage = 0.05f;

		public static float updateTime = 1f * updateTimePercentage;

		public static int cameraFadeDepth = 999999;

		public static float lookAhead = 0.05f;

		public static bool useRealTime = false;

		public static Vector3 up = Vector3.up;
	}

	private class CRSpline
	{
		public Vector3[] pts;

		public CRSpline(params Vector3[] pts)
		{
			this.pts = new Vector3[pts.Length];
			Array.Copy(pts, this.pts, pts.Length);
		}

		public Vector3 Interp(float t)
		{
			int num = pts.Length - 3;
			int num2 = Mathf.Min(Mathf.FloorToInt(t * (float)num), num - 1);
			float num3 = t * (float)num - (float)num2;
			Vector3 vector = pts[num2];
			Vector3 vector2 = pts[num2 + 1];
			Vector3 vector3 = pts[num2 + 2];
			Vector3 vector4 = pts[num2 + 3];
			return 0.5f * ((-vector + 3f * vector2 - 3f * vector3 + vector4) * (num3 * num3 * num3) + (2f * vector - 5f * vector2 + 4f * vector3 - vector4) * (num3 * num3) + (-vector + vector3) * num3 + 2f * vector2);
		}
	}

	public static List<System.Collections.Hashtable> tweens = new List<System.Collections.Hashtable>();

	private static GameObject cameraFade;

	public string id;

	public string type;

	public string method;

	public EaseType easeType;

	public float time;

	public float delay;

	public LoopType loopType;

	public bool isRunning;

	public bool isPaused;

	public string _name;

	private float runningTime;

	private float percentage;

	private float delayStarted;

	private bool kinematic;

	private bool isLocal;

	private bool loop;

	private bool reverse;

	private bool wasPaused;

	private bool physics;

	private System.Collections.Hashtable tweenArguments;

	private Space space;

	private EasingFunction ease;

	private ApplyTween apply;

	private AudioSource audioSource;

	private Vector3[] vector3s;

	private Vector2[] vector2s;

	private Color[,] colors;

	private float[] floats;

	private Rect[] rects;

	private CRSpline path;

	private Vector3 preUpdate;

	private Vector3 postUpdate;

	private NamedValueColor namedcolorvalue;

	private float lastRealTime;

	private bool useRealTime;

	private Transform thisTransform;

	public static void Init(GameObject target)
	{
		MoveBy(target, Vector3.zero, 0f);
	}

	public static void CameraFadeFrom(float amount, float time)
	{
		if ((bool)cameraFade)
		{
			CameraFadeFrom(Hash("amount", amount, "time", time));
		}
		else
		{
			UnityEngine.Debug.LogError("iTween Error: You must first add a camera fade object with CameraFadeAdd() before atttempting to use camera fading.");
		}
	}

	public static void CameraFadeFrom(System.Collections.Hashtable args)
	{
		if ((bool)cameraFade)
		{
			ColorFrom(cameraFade, args);
		}
		else
		{
			UnityEngine.Debug.LogError("iTween Error: You must first add a camera fade object with CameraFadeAdd() before atttempting to use camera fading.");
		}
	}

	public static void CameraFadeTo(float amount, float time)
	{
		if ((bool)cameraFade)
		{
			CameraFadeTo(Hash("amount", amount, "time", time));
		}
		else
		{
			UnityEngine.Debug.LogError("iTween Error: You must first add a camera fade object with CameraFadeAdd() before atttempting to use camera fading.");
		}
	}

	public static void CameraFadeTo(System.Collections.Hashtable args)
	{
		if ((bool)cameraFade)
		{
			ColorTo(cameraFade, args);
		}
		else
		{
			UnityEngine.Debug.LogError("iTween Error: You must first add a camera fade object with CameraFadeAdd() before atttempting to use camera fading.");
		}
	}

	public static void ValueTo(GameObject target, System.Collections.Hashtable args)
	{
		args = CleanArgs(args);
		if (!args.Contains("onupdate") || !args.Contains("from") || !args.Contains("to"))
		{
			UnityEngine.Debug.LogError("iTween Error: ValueTo() requires an 'onupdate' callback function and a 'from' and 'to' property.  The supplied 'onupdate' callback must accept a single argument that is the same type as the supplied 'from' and 'to' properties!");
			return;
		}
		args["type"] = "value";
		if (args["from"].GetType() == typeof(Vector2))
		{
			args["method"] = "vector2";
		}
		else if (args["from"].GetType() == typeof(Vector3))
		{
			args["method"] = "vector3";
		}
		else if (args["from"].GetType() == typeof(Rect))
		{
			args["method"] = "rect";
		}
		else if (args["from"].GetType() == typeof(float))
		{
			args["method"] = "float";
		}
		else
		{
			if (!(args["from"].GetType() == typeof(Color)))
			{
				UnityEngine.Debug.LogError("iTween Error: ValueTo() only works with interpolating Vector3s, Vector2s, floats, ints, Rects and Colors!");
				return;
			}
			args["method"] = "color";
		}
		if (!args.Contains("easetype"))
		{
			args.Add("easetype", EaseType.linear);
		}
		Launch(target, args);
	}

	public static void FadeFrom(GameObject target, float alpha, float time)
	{
		FadeFrom(target, Hash("alpha", alpha, "time", time));
	}

	public static void FadeFrom(GameObject target, System.Collections.Hashtable args)
	{
		ColorFrom(target, args);
	}

	public static void FadeTo(GameObject target, float alpha, float time)
	{
		FadeTo(target, Hash("alpha", alpha, "time", time));
	}

	public static void FadeTo(GameObject target, System.Collections.Hashtable args)
	{
		ColorTo(target, args);
	}

	public static void ColorFrom(GameObject target, Color color, float time)
	{
		ColorFrom(target, Hash("color", color, "time", time));
	}

	public static void ColorFrom(GameObject target, System.Collections.Hashtable args)
	{
		Color color = default(Color);
		Color color2 = default(Color);
		args = CleanArgs(args);
		if (!args.Contains("includechildren") || (bool)args["includechildren"])
		{
			foreach (Transform item in target.transform)
			{
				System.Collections.Hashtable hashtable = (System.Collections.Hashtable)args.Clone();
				hashtable["ischild"] = true;
				ColorFrom(item.gameObject, hashtable);
			}
		}
		if (!args.Contains("easetype"))
		{
			args.Add("easetype", EaseType.linear);
		}
		if ((bool)target.GetComponent<Image>())
		{
			color2 = (color = target.GetComponent<Image>().color);
		}
		else if ((bool)target.GetComponent<Text>())
		{
			color2 = (color = target.GetComponent<Text>().material.color);
		}
		else if ((bool)target.GetComponent<Renderer>())
		{
			color2 = (color = target.GetComponent<Renderer>().material.color);
		}
		else if ((bool)target.GetComponent<Light>())
		{
			color2 = (color = target.GetComponent<Light>().color);
		}
		if (args.Contains("color"))
		{
			color = (Color)args["color"];
		}
		else
		{
			if (args.Contains("r"))
			{
				color.r = (float)args["r"];
			}
			if (args.Contains("g"))
			{
				color.g = (float)args["g"];
			}
			if (args.Contains("b"))
			{
				color.b = (float)args["b"];
			}
			if (args.Contains("a"))
			{
				color.a = (float)args["a"];
			}
		}
		if (args.Contains("amount"))
		{
			color.a = (float)args["amount"];
			args.Remove("amount");
		}
		else if (args.Contains("alpha"))
		{
			color.a = (float)args["alpha"];
			args.Remove("alpha");
		}
		if ((bool)target.GetComponent<Image>())
		{
			target.GetComponent<Image>().color = color;
		}
		else if ((bool)target.GetComponent<Text>())
		{
			target.GetComponent<Text>().material.color = color;
		}
		else if ((bool)target.GetComponent<Renderer>())
		{
			target.GetComponent<Renderer>().material.color = color;
		}
		else if ((bool)target.GetComponent<Light>())
		{
			target.GetComponent<Light>().color = color;
		}
		args["color"] = color2;
		args["type"] = "color";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void ColorTo(GameObject target, Color color, float time)
	{
		ColorTo(target, Hash("color", color, "time", time));
	}

	public static void ColorTo(GameObject target, System.Collections.Hashtable args)
	{
		args = CleanArgs(args);
		if (!args.Contains("includechildren") || (bool)args["includechildren"])
		{
			foreach (Transform item in target.transform)
			{
				System.Collections.Hashtable hashtable = (System.Collections.Hashtable)args.Clone();
				hashtable["ischild"] = true;
				ColorTo(item.gameObject, hashtable);
			}
		}
		if (!args.Contains("easetype"))
		{
			args.Add("easetype", EaseType.linear);
		}
		args["type"] = "color";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void AudioFrom(GameObject target, float volume, float pitch, float time)
	{
		AudioFrom(target, Hash("volume", volume, "pitch", pitch, "time", time));
	}

	public static void AudioFrom(GameObject target, System.Collections.Hashtable args)
	{
		args = CleanArgs(args);
		AudioSource audioSource;
		if (args.Contains("audiosource"))
		{
			audioSource = (AudioSource)args["audiosource"];
		}
		else
		{
			if (!target.GetComponent<AudioSource>())
			{
				UnityEngine.Debug.LogError("iTween Error: AudioFrom requires an AudioSource.");
				return;
			}
			audioSource = target.GetComponent<AudioSource>();
		}
		Vector2 vector = default(Vector2);
		Vector2 vector2 = default(Vector2);
		vector.x = (vector2.x = audioSource.volume);
		vector.y = (vector2.y = audioSource.pitch);
		if (args.Contains("volume"))
		{
			vector2.x = (float)args["volume"];
		}
		if (args.Contains("pitch"))
		{
			vector2.y = (float)args["pitch"];
		}
		audioSource.volume = vector2.x;
		audioSource.pitch = vector2.y;
		args["volume"] = vector.x;
		args["pitch"] = vector.y;
		if (!args.Contains("easetype"))
		{
			args.Add("easetype", EaseType.linear);
		}
		args["type"] = "audio";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void AudioTo(GameObject target, float volume, float pitch, float time)
	{
		AudioTo(target, Hash("volume", volume, "pitch", pitch, "time", time));
	}

	public static void AudioTo(GameObject target, System.Collections.Hashtable args)
	{
		args = CleanArgs(args);
		if (!args.Contains("easetype"))
		{
			args.Add("easetype", EaseType.linear);
		}
		args["type"] = "audio";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void Stab(GameObject target, AudioClip audioclip, float delay)
	{
		Stab(target, Hash("audioclip", audioclip, "delay", delay));
	}

	public static void Stab(GameObject target, System.Collections.Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "stab";
		Launch(target, args);
	}

	public static void LookFrom(GameObject target, Vector3 looktarget, float time)
	{
		LookFrom(target, Hash("looktarget", looktarget, "time", time));
	}

	public static void LookFrom(GameObject target, System.Collections.Hashtable args)
	{
		args = CleanArgs(args);
		Vector3 eulerAngles = target.transform.eulerAngles;
		if (args["looktarget"].GetType() == typeof(Transform))
		{
			target.transform.LookAt((Transform)args["looktarget"], ((Vector3?)args["up"]) ?? Defaults.up);
		}
		else if (args["looktarget"].GetType() == typeof(Vector3))
		{
			target.transform.LookAt((Vector3)args["looktarget"], ((Vector3?)args["up"]) ?? Defaults.up);
		}
		if (args.Contains("axis"))
		{
			Vector3 eulerAngles2 = target.transform.eulerAngles;
			switch ((string)args["axis"])
			{
			case "x":
				eulerAngles2.y = eulerAngles.y;
				eulerAngles2.z = eulerAngles.z;
				break;
			case "y":
				eulerAngles2.x = eulerAngles.x;
				eulerAngles2.z = eulerAngles.z;
				break;
			case "z":
				eulerAngles2.x = eulerAngles.x;
				eulerAngles2.y = eulerAngles.y;
				break;
			}
			target.transform.eulerAngles = eulerAngles2;
		}
		args["rotation"] = eulerAngles;
		args["type"] = "rotate";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void LookTo(GameObject target, Vector3 looktarget, float time)
	{
		LookTo(target, Hash("looktarget", looktarget, "time", time));
	}

	public static void LookTo(GameObject target, System.Collections.Hashtable args)
	{
		args = CleanArgs(args);
		if (args.Contains("looktarget") && args["looktarget"].GetType() == typeof(Transform))
		{
			Transform transform = (Transform)args["looktarget"];
			args["position"] = new Vector3(transform.position.x, transform.position.y, transform.position.z);
			args["rotation"] = new Vector3(transform.eulerAngles.x, transform.eulerAngles.y, transform.eulerAngles.z);
		}
		args["type"] = "look";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void MoveTo(GameObject target, Vector3 position, float time)
	{
		MoveTo(target, Hash("position", position, "time", time));
	}

	public static void MoveTo(GameObject target, System.Collections.Hashtable args)
	{
		args = CleanArgs(args);
		if (args.Contains("position") && args["position"].GetType() == typeof(Transform))
		{
			Transform transform = (Transform)args["position"];
			args["position"] = new Vector3(transform.position.x, transform.position.y, transform.position.z);
			args["rotation"] = new Vector3(transform.eulerAngles.x, transform.eulerAngles.y, transform.eulerAngles.z);
			args["scale"] = new Vector3(transform.localScale.x, transform.localScale.y, transform.localScale.z);
		}
		args["type"] = "move";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void MoveFrom(GameObject target, Vector3 position, float time)
	{
		MoveFrom(target, Hash("position", position, "time", time));
	}

	public static void MoveFrom(GameObject target, System.Collections.Hashtable args)
	{
		args = CleanArgs(args);
		bool flag = ((!args.Contains("islocal")) ? Defaults.isLocal : ((bool)args["islocal"]));
		if (args.Contains("path"))
		{
			Vector3[] array2;
			if (args["path"].GetType() == typeof(Vector3[]))
			{
				Vector3[] array = (Vector3[])args["path"];
				array2 = new Vector3[array.Length];
				Array.Copy(array, array2, array.Length);
			}
			else
			{
				Transform[] array3 = (Transform[])args["path"];
				array2 = new Vector3[array3.Length];
				for (int i = 0; i < array3.Length; i++)
				{
					array2[i] = array3[i].position;
				}
			}
			if (array2[^1] != target.transform.position)
			{
				Vector3[] array4 = new Vector3[array2.Length + 1];
				Array.Copy(array2, array4, array2.Length);
				if (flag)
				{
					array4[^1] = target.transform.localPosition;
					target.transform.localPosition = array4[0];
				}
				else
				{
					array4[^1] = target.transform.position;
					target.transform.position = array4[0];
				}
				args["path"] = array4;
			}
			else
			{
				if (flag)
				{
					target.transform.localPosition = array2[0];
				}
				else
				{
					target.transform.position = array2[0];
				}
				args["path"] = array2;
			}
		}
		else
		{
			Vector3 vector;
			Vector3 vector2 = ((!flag) ? (vector = target.transform.position) : (vector = target.transform.localPosition));
			if (args.Contains("position"))
			{
				if (args["position"].GetType() == typeof(Transform))
				{
					vector = ((Transform)args["position"]).position;
				}
				else if (args["position"].GetType() == typeof(Vector3))
				{
					vector = (Vector3)args["position"];
				}
			}
			else
			{
				if (args.Contains("x"))
				{
					vector.x = (float)args["x"];
				}
				if (args.Contains("y"))
				{
					vector.y = (float)args["y"];
				}
				if (args.Contains("z"))
				{
					vector.z = (float)args["z"];
				}
			}
			if (flag)
			{
				target.transform.localPosition = vector;
			}
			else
			{
				target.transform.position = vector;
			}
			args["position"] = vector2;
		}
		args["type"] = "move";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void MoveAdd(GameObject target, Vector3 amount, float time)
	{
		MoveAdd(target, Hash("amount", amount, "time", time));
	}

	public static void MoveAdd(GameObject target, System.Collections.Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "move";
		args["method"] = "add";
		Launch(target, args);
	}

	public static void MoveBy(GameObject target, Vector3 amount, float time)
	{
		MoveBy(target, Hash("amount", amount, "time", time));
	}

	public static void MoveBy(GameObject target, System.Collections.Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "move";
		args["method"] = "by";
		Launch(target, args);
	}

	public static void ScaleTo(GameObject target, Vector3 scale, float time)
	{
		ScaleTo(target, Hash("scale", scale, "time", time));
	}

	public static void ScaleTo(GameObject target, System.Collections.Hashtable args)
	{
		args = CleanArgs(args);
		if (args.Contains("scale") && args["scale"].GetType() == typeof(Transform))
		{
			Transform transform = (Transform)args["scale"];
			args["position"] = new Vector3(transform.position.x, transform.position.y, transform.position.z);
			args["rotation"] = new Vector3(transform.eulerAngles.x, transform.eulerAngles.y, transform.eulerAngles.z);
			args["scale"] = new Vector3(transform.localScale.x, transform.localScale.y, transform.localScale.z);
		}
		args["type"] = "scale";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void ScaleFrom(GameObject target, Vector3 scale, float time)
	{
		ScaleFrom(target, Hash("scale", scale, "time", time));
	}

	public static void ScaleFrom(GameObject target, System.Collections.Hashtable args)
	{
		args = CleanArgs(args);
		Vector3 localScale;
		Vector3 vector = (localScale = target.transform.localScale);
		if (args.Contains("scale"))
		{
			if (args["scale"].GetType() == typeof(Transform))
			{
				localScale = ((Transform)args["scale"]).localScale;
			}
			else if (args["scale"].GetType() == typeof(Vector3))
			{
				localScale = (Vector3)args["scale"];
			}
		}
		else
		{
			if (args.Contains("x"))
			{
				localScale.x = (float)args["x"];
			}
			if (args.Contains("y"))
			{
				localScale.y = (float)args["y"];
			}
			if (args.Contains("z"))
			{
				localScale.z = (float)args["z"];
			}
		}
		target.transform.localScale = localScale;
		args["scale"] = vector;
		args["type"] = "scale";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void ScaleAdd(GameObject target, Vector3 amount, float time)
	{
		ScaleAdd(target, Hash("amount", amount, "time", time));
	}

	public static void ScaleAdd(GameObject target, System.Collections.Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "scale";
		args["method"] = "add";
		Launch(target, args);
	}

	public static void ScaleBy(GameObject target, Vector3 amount, float time)
	{
		ScaleBy(target, Hash("amount", amount, "time", time));
	}

	public static void ScaleBy(GameObject target, System.Collections.Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "scale";
		args["method"] = "by";
		Launch(target, args);
	}

	public static void RotateTo(GameObject target, Vector3 rotation, float time)
	{
		RotateTo(target, Hash("rotation", rotation, "time", time));
	}

	public static void RotateTo(GameObject target, System.Collections.Hashtable args)
	{
		args = CleanArgs(args);
		if (args.Contains("rotation") && args["rotation"].GetType() == typeof(Transform))
		{
			Transform transform = (Transform)args["rotation"];
			args["position"] = new Vector3(transform.position.x, transform.position.y, transform.position.z);
			args["rotation"] = new Vector3(transform.eulerAngles.x, transform.eulerAngles.y, transform.eulerAngles.z);
			args["scale"] = new Vector3(transform.localScale.x, transform.localScale.y, transform.localScale.z);
		}
		args["type"] = "rotate";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void RotateFrom(GameObject target, Vector3 rotation, float time)
	{
		RotateFrom(target, Hash("rotation", rotation, "time", time));
	}

	public static void RotateFrom(GameObject target, System.Collections.Hashtable args)
	{
		args = CleanArgs(args);
		bool flag = ((!args.Contains("islocal")) ? Defaults.isLocal : ((bool)args["islocal"]));
		Vector3 vector;
		Vector3 vector2 = ((!flag) ? (vector = target.transform.eulerAngles) : (vector = target.transform.localEulerAngles));
		if (args.Contains("rotation"))
		{
			if (args["rotation"].GetType() == typeof(Transform))
			{
				vector = ((Transform)args["rotation"]).eulerAngles;
			}
			else if (args["rotation"].GetType() == typeof(Vector3))
			{
				vector = (Vector3)args["rotation"];
			}
		}
		else
		{
			if (args.Contains("x"))
			{
				vector.x = (float)args["x"];
			}
			if (args.Contains("y"))
			{
				vector.y = (float)args["y"];
			}
			if (args.Contains("z"))
			{
				vector.z = (float)args["z"];
			}
		}
		if (flag)
		{
			target.transform.localEulerAngles = vector;
		}
		else
		{
			target.transform.eulerAngles = vector;
		}
		args["rotation"] = vector2;
		args["type"] = "rotate";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void RotateAdd(GameObject target, Vector3 amount, float time)
	{
		RotateAdd(target, Hash("amount", amount, "time", time));
	}

	public static void RotateAdd(GameObject target, System.Collections.Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "rotate";
		args["method"] = "add";
		Launch(target, args);
	}

	public static void RotateBy(GameObject target, Vector3 amount, float time)
	{
		RotateBy(target, Hash("amount", amount, "time", time));
	}

	public static void RotateBy(GameObject target, System.Collections.Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "rotate";
		args["method"] = "by";
		Launch(target, args);
	}

	public static void ShakePosition(GameObject target, Vector3 amount, float time)
	{
		ShakePosition(target, Hash("amount", amount, "time", time));
	}

	public static void ShakePosition(GameObject target, System.Collections.Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "shake";
		args["method"] = "position";
		Launch(target, args);
	}

	public static void ShakeScale(GameObject target, Vector3 amount, float time)
	{
		ShakeScale(target, Hash("amount", amount, "time", time));
	}

	public static void ShakeScale(GameObject target, System.Collections.Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "shake";
		args["method"] = "scale";
		Launch(target, args);
	}

	public static void ShakeRotation(GameObject target, Vector3 amount, float time)
	{
		ShakeRotation(target, Hash("amount", amount, "time", time));
	}

	public static void ShakeRotation(GameObject target, System.Collections.Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "shake";
		args["method"] = "rotation";
		Launch(target, args);
	}

	public static void PunchPosition(GameObject target, Vector3 amount, float time)
	{
		PunchPosition(target, Hash("amount", amount, "time", time));
	}

	public static void PunchPosition(GameObject target, System.Collections.Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "punch";
		args["method"] = "position";
		args["easetype"] = EaseType.punch;
		Launch(target, args);
	}

	public static void PunchRotation(GameObject target, Vector3 amount, float time)
	{
		PunchRotation(target, Hash("amount", amount, "time", time));
	}

	public static void PunchRotation(GameObject target, System.Collections.Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "punch";
		args["method"] = "rotation";
		args["easetype"] = EaseType.punch;
		Launch(target, args);
	}

	public static void PunchScale(GameObject target, Vector3 amount, float time)
	{
		PunchScale(target, Hash("amount", amount, "time", time));
	}

	public static void PunchScale(GameObject target, System.Collections.Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "punch";
		args["method"] = "scale";
		args["easetype"] = EaseType.punch;
		Launch(target, args);
	}

	private void GenerateTargets()
	{
		switch (type)
		{
		case "value":
			switch (method)
			{
			case "float":
				GenerateFloatTargets();
				apply = ApplyFloatTargets;
				break;
			case "vector2":
				GenerateVector2Targets();
				apply = ApplyVector2Targets;
				break;
			case "vector3":
				GenerateVector3Targets();
				apply = ApplyVector3Targets;
				break;
			case "color":
				GenerateColorTargets();
				apply = ApplyColorTargets;
				break;
			case "rect":
				GenerateRectTargets();
				apply = ApplyRectTargets;
				break;
			}
			break;
		case "color":
		{
			string text = method;
			if (text == "to")
			{
				GenerateColorToTargets();
				apply = ApplyColorToTargets;
			}
			break;
		}
		case "audio":
		{
			string text = method;
			if (text == "to")
			{
				GenerateAudioToTargets();
				apply = ApplyAudioToTargets;
			}
			break;
		}
		case "move":
			switch (method)
			{
			case "to":
				if (tweenArguments.Contains("path"))
				{
					GenerateMoveToPathTargets();
					apply = ApplyMoveToPathTargets;
				}
				else
				{
					GenerateMoveToTargets();
					apply = ApplyMoveToTargets;
				}
				break;
			case "by":
			case "add":
				GenerateMoveByTargets();
				apply = ApplyMoveByTargets;
				break;
			}
			break;
		case "scale":
			switch (method)
			{
			case "to":
				GenerateScaleToTargets();
				apply = ApplyScaleToTargets;
				break;
			case "by":
				GenerateScaleByTargets();
				apply = ApplyScaleToTargets;
				break;
			case "add":
				GenerateScaleAddTargets();
				apply = ApplyScaleToTargets;
				break;
			}
			break;
		case "rotate":
			switch (method)
			{
			case "to":
				GenerateRotateToTargets();
				apply = ApplyRotateToTargets;
				break;
			case "add":
				GenerateRotateAddTargets();
				apply = ApplyRotateAddTargets;
				break;
			case "by":
				GenerateRotateByTargets();
				apply = ApplyRotateAddTargets;
				break;
			}
			break;
		case "shake":
			switch (method)
			{
			case "position":
				GenerateShakePositionTargets();
				apply = ApplyShakePositionTargets;
				break;
			case "scale":
				GenerateShakeScaleTargets();
				apply = ApplyShakeScaleTargets;
				break;
			case "rotation":
				GenerateShakeRotationTargets();
				apply = ApplyShakeRotationTargets;
				break;
			}
			break;
		case "punch":
			switch (method)
			{
			case "position":
				GeneratePunchPositionTargets();
				apply = ApplyPunchPositionTargets;
				break;
			case "rotation":
				GeneratePunchRotationTargets();
				apply = ApplyPunchRotationTargets;
				break;
			case "scale":
				GeneratePunchScaleTargets();
				apply = ApplyPunchScaleTargets;
				break;
			}
			break;
		case "look":
		{
			string text = method;
			if (text == "to")
			{
				GenerateLookToTargets();
				apply = ApplyLookToTargets;
			}
			break;
		}
		case "stab":
			GenerateStabTargets();
			apply = ApplyStabTargets;
			break;
		}
	}

	private void GenerateRectTargets()
	{
		rects = new Rect[3];
		rects[0] = (Rect)tweenArguments["from"];
		rects[1] = (Rect)tweenArguments["to"];
	}

	private void GenerateColorTargets()
	{
		colors = new Color[1, 3];
		colors[0, 0] = (Color)tweenArguments["from"];
		colors[0, 1] = (Color)tweenArguments["to"];
	}

	private void GenerateVector3Targets()
	{
		vector3s = new Vector3[3];
		vector3s[0] = (Vector3)tweenArguments["from"];
		vector3s[1] = (Vector3)tweenArguments["to"];
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateVector2Targets()
	{
		vector2s = new Vector2[3];
		vector2s[0] = (Vector2)tweenArguments["from"];
		vector2s[1] = (Vector2)tweenArguments["to"];
		if (tweenArguments.Contains("speed"))
		{
			Vector3 a = new Vector3(vector2s[0].x, vector2s[0].y, 0f);
			Vector3 b = new Vector3(vector2s[1].x, vector2s[1].y, 0f);
			float num = Math.Abs(Vector3.Distance(a, b));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateFloatTargets()
	{
		floats = new float[3];
		floats[0] = (float)tweenArguments["from"];
		floats[1] = (float)tweenArguments["to"];
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(floats[0] - floats[1]);
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateColorToTargets()
	{
		if ((bool)GetComponent<Image>())
		{
			colors = new Color[1, 3];
			colors[0, 0] = (colors[0, 1] = GetComponent<Image>().color);
		}
		else if ((bool)GetComponent<Text>())
		{
			colors = new Color[1, 3];
			colors[0, 0] = (colors[0, 1] = GetComponent<Text>().material.color);
		}
		else if ((bool)GetComponent<Renderer>())
		{
			colors = new Color[GetComponent<Renderer>().materials.Length, 3];
			for (int i = 0; i < GetComponent<Renderer>().materials.Length; i++)
			{
				colors[i, 0] = GetComponent<Renderer>().materials[i].GetColor(namedcolorvalue.ToString());
				colors[i, 1] = GetComponent<Renderer>().materials[i].GetColor(namedcolorvalue.ToString());
			}
		}
		else if ((bool)GetComponent<Light>())
		{
			colors = new Color[1, 3];
			colors[0, 0] = (colors[0, 1] = GetComponent<Light>().color);
		}
		else
		{
			colors = new Color[1, 3];
		}
		if (tweenArguments.Contains("color"))
		{
			for (int j = 0; j < colors.GetLength(0); j++)
			{
				colors[j, 1] = (Color)tweenArguments["color"];
			}
		}
		else
		{
			if (tweenArguments.Contains("r"))
			{
				for (int k = 0; k < colors.GetLength(0); k++)
				{
					colors[k, 1].r = (float)tweenArguments["r"];
				}
			}
			if (tweenArguments.Contains("g"))
			{
				for (int l = 0; l < colors.GetLength(0); l++)
				{
					colors[l, 1].g = (float)tweenArguments["g"];
				}
			}
			if (tweenArguments.Contains("b"))
			{
				for (int m = 0; m < colors.GetLength(0); m++)
				{
					colors[m, 1].b = (float)tweenArguments["b"];
				}
			}
			if (tweenArguments.Contains("a"))
			{
				for (int n = 0; n < colors.GetLength(0); n++)
				{
					colors[n, 1].a = (float)tweenArguments["a"];
				}
			}
		}
		if (tweenArguments.Contains("amount"))
		{
			for (int num = 0; num < colors.GetLength(0); num++)
			{
				colors[num, 1].a = (float)tweenArguments["amount"];
			}
		}
		else if (tweenArguments.Contains("alpha"))
		{
			for (int num2 = 0; num2 < colors.GetLength(0); num2++)
			{
				colors[num2, 1].a = (float)tweenArguments["alpha"];
			}
		}
	}

	private void GenerateAudioToTargets()
	{
		vector2s = new Vector2[3];
		if (tweenArguments.Contains("audiosource"))
		{
			audioSource = (AudioSource)tweenArguments["audiosource"];
		}
		else if ((bool)GetComponent<AudioSource>())
		{
			audioSource = GetComponent<AudioSource>();
		}
		else
		{
			UnityEngine.Debug.LogError("iTween Error: AudioTo requires an AudioSource.");
			Dispose();
		}
		vector2s[0] = (vector2s[1] = new Vector2(audioSource.volume, audioSource.pitch));
		if (tweenArguments.Contains("volume"))
		{
			vector2s[1].x = (float)tweenArguments["volume"];
		}
		if (tweenArguments.Contains("pitch"))
		{
			vector2s[1].y = (float)tweenArguments["pitch"];
		}
	}

	private void GenerateStabTargets()
	{
		if (tweenArguments.Contains("audiosource"))
		{
			audioSource = (AudioSource)tweenArguments["audiosource"];
		}
		else if ((bool)GetComponent<AudioSource>())
		{
			audioSource = GetComponent<AudioSource>();
		}
		else
		{
			base.gameObject.AddComponent<AudioSource>();
			audioSource = GetComponent<AudioSource>();
			audioSource.playOnAwake = false;
		}
		audioSource.clip = (AudioClip)tweenArguments["audioclip"];
		if (tweenArguments.Contains("pitch"))
		{
			audioSource.pitch = (float)tweenArguments["pitch"];
		}
		if (tweenArguments.Contains("volume"))
		{
			audioSource.volume = (float)tweenArguments["volume"];
		}
		time = audioSource.clip.length / audioSource.pitch;
	}

	private void GenerateLookToTargets()
	{
		vector3s = new Vector3[3];
		vector3s[0] = thisTransform.eulerAngles;
		if (tweenArguments.Contains("looktarget"))
		{
			if (tweenArguments["looktarget"].GetType() == typeof(Transform))
			{
				thisTransform.LookAt((Transform)tweenArguments["looktarget"], ((Vector3?)tweenArguments["up"]) ?? Defaults.up);
			}
			else if (tweenArguments["looktarget"].GetType() == typeof(Vector3))
			{
				thisTransform.LookAt((Vector3)tweenArguments["looktarget"], ((Vector3?)tweenArguments["up"]) ?? Defaults.up);
			}
		}
		else
		{
			UnityEngine.Debug.LogError("iTween Error: LookTo needs a 'looktarget' property!");
			Dispose();
		}
		vector3s[1] = thisTransform.eulerAngles;
		thisTransform.eulerAngles = vector3s[0];
		if (tweenArguments.Contains("axis"))
		{
			switch ((string)tweenArguments["axis"])
			{
			case "x":
				vector3s[1].y = vector3s[0].y;
				vector3s[1].z = vector3s[0].z;
				break;
			case "y":
				vector3s[1].x = vector3s[0].x;
				vector3s[1].z = vector3s[0].z;
				break;
			case "z":
				vector3s[1].x = vector3s[0].x;
				vector3s[1].y = vector3s[0].y;
				break;
			}
		}
		vector3s[1] = new Vector3(clerp(vector3s[0].x, vector3s[1].x, 1f), clerp(vector3s[0].y, vector3s[1].y, 1f), clerp(vector3s[0].z, vector3s[1].z, 1f));
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateMoveToPathTargets()
	{
		Vector3[] array2;
		if (tweenArguments["path"].GetType() == typeof(Vector3[]))
		{
			Vector3[] array = (Vector3[])tweenArguments["path"];
			if (array.Length == 1)
			{
				UnityEngine.Debug.LogError("iTween Error: Attempting a path movement with MoveTo requires an array of more than 1 entry!");
				Dispose();
			}
			array2 = new Vector3[array.Length];
			Array.Copy(array, array2, array.Length);
		}
		else
		{
			Transform[] array3 = (Transform[])tweenArguments["path"];
			if (array3.Length == 1)
			{
				UnityEngine.Debug.LogError("iTween Error: Attempting a path movement with MoveTo requires an array of more than 1 entry!");
				Dispose();
			}
			array2 = new Vector3[array3.Length];
			for (int i = 0; i < array3.Length; i++)
			{
				array2[i] = array3[i].position;
			}
		}
		bool flag;
		int num;
		if (thisTransform.position != array2[0])
		{
			if (!tweenArguments.Contains("movetopath") || (bool)tweenArguments["movetopath"])
			{
				flag = true;
				num = 3;
			}
			else
			{
				flag = false;
				num = 2;
			}
		}
		else
		{
			flag = false;
			num = 2;
		}
		vector3s = new Vector3[array2.Length + num];
		if (flag)
		{
			vector3s[1] = thisTransform.position;
			num = 2;
		}
		else
		{
			num = 1;
		}
		Array.Copy(array2, 0, vector3s, num, array2.Length);
		vector3s[0] = vector3s[1] + (vector3s[1] - vector3s[2]);
		vector3s[vector3s.Length - 1] = vector3s[vector3s.Length - 2] + (vector3s[vector3s.Length - 2] - vector3s[vector3s.Length - 3]);
		if (vector3s[1] == vector3s[vector3s.Length - 2])
		{
			Vector3[] array4 = new Vector3[vector3s.Length];
			Array.Copy(vector3s, array4, vector3s.Length);
			array4[0] = array4[^3];
			array4[^1] = array4[2];
			vector3s = new Vector3[array4.Length];
			Array.Copy(array4, vector3s, array4.Length);
		}
		path = new CRSpline(vector3s);
		if (tweenArguments.Contains("speed"))
		{
			float num2 = PathLength(vector3s);
			time = num2 / (float)tweenArguments["speed"];
		}
	}

	private void GenerateMoveToTargets()
	{
		vector3s = new Vector3[3];
		if (isLocal)
		{
			vector3s[0] = (vector3s[1] = thisTransform.localPosition);
		}
		else
		{
			vector3s[0] = (vector3s[1] = thisTransform.position);
		}
		if (tweenArguments.Contains("position"))
		{
			if (tweenArguments["position"].GetType() == typeof(Transform))
			{
				Transform transform = (Transform)tweenArguments["position"];
				vector3s[1] = transform.position;
			}
			else if (tweenArguments["position"].GetType() == typeof(Vector3))
			{
				vector3s[1] = (Vector3)tweenArguments["position"];
			}
		}
		else
		{
			if (tweenArguments.Contains("x"))
			{
				vector3s[1].x = (float)tweenArguments["x"];
			}
			if (tweenArguments.Contains("y"))
			{
				vector3s[1].y = (float)tweenArguments["y"];
			}
			if (tweenArguments.Contains("z"))
			{
				vector3s[1].z = (float)tweenArguments["z"];
			}
		}
		if (tweenArguments.Contains("orienttopath") && (bool)tweenArguments["orienttopath"])
		{
			tweenArguments["looktarget"] = vector3s[1];
		}
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateMoveByTargets()
	{
		vector3s = new Vector3[6];
		vector3s[4] = thisTransform.eulerAngles;
		vector3s[0] = (vector3s[1] = (vector3s[3] = thisTransform.position));
		if (tweenArguments.Contains("amount"))
		{
			vector3s[1] = vector3s[0] + (Vector3)tweenArguments["amount"];
		}
		else
		{
			if (tweenArguments.Contains("x"))
			{
				vector3s[1].x = vector3s[0].x + (float)tweenArguments["x"];
			}
			if (tweenArguments.Contains("y"))
			{
				vector3s[1].y = vector3s[0].y + (float)tweenArguments["y"];
			}
			if (tweenArguments.Contains("z"))
			{
				vector3s[1].z = vector3s[0].z + (float)tweenArguments["z"];
			}
		}
		thisTransform.Translate(vector3s[1], space);
		vector3s[5] = thisTransform.position;
		thisTransform.position = vector3s[0];
		if (tweenArguments.Contains("orienttopath") && (bool)tweenArguments["orienttopath"])
		{
			tweenArguments["looktarget"] = vector3s[1];
		}
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateScaleToTargets()
	{
		vector3s = new Vector3[3];
		vector3s[0] = (vector3s[1] = thisTransform.localScale);
		if (tweenArguments.Contains("scale"))
		{
			if (tweenArguments["scale"].GetType() == typeof(Transform))
			{
				Transform transform = (Transform)tweenArguments["scale"];
				vector3s[1] = transform.localScale;
			}
			else if (tweenArguments["scale"].GetType() == typeof(Vector3))
			{
				vector3s[1] = (Vector3)tweenArguments["scale"];
			}
		}
		else
		{
			if (tweenArguments.Contains("x"))
			{
				vector3s[1].x = (float)tweenArguments["x"];
			}
			if (tweenArguments.Contains("y"))
			{
				vector3s[1].y = (float)tweenArguments["y"];
			}
			if (tweenArguments.Contains("z"))
			{
				vector3s[1].z = (float)tweenArguments["z"];
			}
		}
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateScaleByTargets()
	{
		vector3s = new Vector3[3];
		vector3s[0] = (vector3s[1] = thisTransform.localScale);
		if (tweenArguments.Contains("amount"))
		{
			vector3s[1] = Vector3.Scale(vector3s[1], (Vector3)tweenArguments["amount"]);
		}
		else
		{
			if (tweenArguments.Contains("x"))
			{
				vector3s[1].x *= (float)tweenArguments["x"];
			}
			if (tweenArguments.Contains("y"))
			{
				vector3s[1].y *= (float)tweenArguments["y"];
			}
			if (tweenArguments.Contains("z"))
			{
				vector3s[1].z *= (float)tweenArguments["z"];
			}
		}
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateScaleAddTargets()
	{
		vector3s = new Vector3[3];
		vector3s[0] = (vector3s[1] = thisTransform.localScale);
		if (tweenArguments.Contains("amount"))
		{
			vector3s[1] += (Vector3)tweenArguments["amount"];
		}
		else
		{
			if (tweenArguments.Contains("x"))
			{
				vector3s[1].x += (float)tweenArguments["x"];
			}
			if (tweenArguments.Contains("y"))
			{
				vector3s[1].y += (float)tweenArguments["y"];
			}
			if (tweenArguments.Contains("z"))
			{
				vector3s[1].z += (float)tweenArguments["z"];
			}
		}
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateRotateToTargets()
	{
		vector3s = new Vector3[3];
		if (isLocal)
		{
			vector3s[0] = (vector3s[1] = thisTransform.localEulerAngles);
		}
		else
		{
			vector3s[0] = (vector3s[1] = thisTransform.eulerAngles);
		}
		if (tweenArguments.Contains("rotation"))
		{
			if (tweenArguments["rotation"].GetType() == typeof(Transform))
			{
				Transform transform = (Transform)tweenArguments["rotation"];
				vector3s[1] = transform.eulerAngles;
			}
			else if (tweenArguments["rotation"].GetType() == typeof(Vector3))
			{
				vector3s[1] = (Vector3)tweenArguments["rotation"];
			}
		}
		else
		{
			if (tweenArguments.Contains("x"))
			{
				vector3s[1].x = (float)tweenArguments["x"];
			}
			if (tweenArguments.Contains("y"))
			{
				vector3s[1].y = (float)tweenArguments["y"];
			}
			if (tweenArguments.Contains("z"))
			{
				vector3s[1].z = (float)tweenArguments["z"];
			}
		}
		vector3s[1] = new Vector3(clerp(vector3s[0].x, vector3s[1].x, 1f), clerp(vector3s[0].y, vector3s[1].y, 1f), clerp(vector3s[0].z, vector3s[1].z, 1f));
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateRotateAddTargets()
	{
		vector3s = new Vector3[5];
		vector3s[0] = (vector3s[1] = (vector3s[3] = thisTransform.eulerAngles));
		if (tweenArguments.Contains("amount"))
		{
			vector3s[1] += (Vector3)tweenArguments["amount"];
		}
		else
		{
			if (tweenArguments.Contains("x"))
			{
				vector3s[1].x += (float)tweenArguments["x"];
			}
			if (tweenArguments.Contains("y"))
			{
				vector3s[1].y += (float)tweenArguments["y"];
			}
			if (tweenArguments.Contains("z"))
			{
				vector3s[1].z += (float)tweenArguments["z"];
			}
		}
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateRotateByTargets()
	{
		vector3s = new Vector3[4];
		vector3s[0] = (vector3s[1] = (vector3s[3] = thisTransform.eulerAngles));
		if (tweenArguments.Contains("amount"))
		{
			vector3s[1] += Vector3.Scale((Vector3)tweenArguments["amount"], new Vector3(360f, 360f, 360f));
		}
		else
		{
			if (tweenArguments.Contains("x"))
			{
				vector3s[1].x += 360f * (float)tweenArguments["x"];
			}
			if (tweenArguments.Contains("y"))
			{
				vector3s[1].y += 360f * (float)tweenArguments["y"];
			}
			if (tweenArguments.Contains("z"))
			{
				vector3s[1].z += 360f * (float)tweenArguments["z"];
			}
		}
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateShakePositionTargets()
	{
		vector3s = new Vector3[4];
		vector3s[3] = thisTransform.eulerAngles;
		vector3s[0] = thisTransform.position;
		if (tweenArguments.Contains("amount"))
		{
			vector3s[1] = (Vector3)tweenArguments["amount"];
			return;
		}
		if (tweenArguments.Contains("x"))
		{
			vector3s[1].x = (float)tweenArguments["x"];
		}
		if (tweenArguments.Contains("y"))
		{
			vector3s[1].y = (float)tweenArguments["y"];
		}
		if (tweenArguments.Contains("z"))
		{
			vector3s[1].z = (float)tweenArguments["z"];
		}
	}

	private void GenerateShakeScaleTargets()
	{
		vector3s = new Vector3[3];
		vector3s[0] = thisTransform.localScale;
		if (tweenArguments.Contains("amount"))
		{
			vector3s[1] = (Vector3)tweenArguments["amount"];
			return;
		}
		if (tweenArguments.Contains("x"))
		{
			vector3s[1].x = (float)tweenArguments["x"];
		}
		if (tweenArguments.Contains("y"))
		{
			vector3s[1].y = (float)tweenArguments["y"];
		}
		if (tweenArguments.Contains("z"))
		{
			vector3s[1].z = (float)tweenArguments["z"];
		}
	}

	private void GenerateShakeRotationTargets()
	{
		vector3s = new Vector3[3];
		vector3s[0] = thisTransform.eulerAngles;
		if (tweenArguments.Contains("amount"))
		{
			vector3s[1] = (Vector3)tweenArguments["amount"];
			return;
		}
		if (tweenArguments.Contains("x"))
		{
			vector3s[1].x = (float)tweenArguments["x"];
		}
		if (tweenArguments.Contains("y"))
		{
			vector3s[1].y = (float)tweenArguments["y"];
		}
		if (tweenArguments.Contains("z"))
		{
			vector3s[1].z = (float)tweenArguments["z"];
		}
	}

	private void GeneratePunchPositionTargets()
	{
		vector3s = new Vector3[5];
		vector3s[4] = thisTransform.eulerAngles;
		vector3s[0] = thisTransform.position;
		vector3s[1] = (vector3s[3] = Vector3.zero);
		if (tweenArguments.Contains("amount"))
		{
			vector3s[1] = (Vector3)tweenArguments["amount"];
			return;
		}
		if (tweenArguments.Contains("x"))
		{
			vector3s[1].x = (float)tweenArguments["x"];
		}
		if (tweenArguments.Contains("y"))
		{
			vector3s[1].y = (float)tweenArguments["y"];
		}
		if (tweenArguments.Contains("z"))
		{
			vector3s[1].z = (float)tweenArguments["z"];
		}
	}

	private void GeneratePunchRotationTargets()
	{
		vector3s = new Vector3[4];
		vector3s[0] = thisTransform.eulerAngles;
		vector3s[1] = (vector3s[3] = Vector3.zero);
		if (tweenArguments.Contains("amount"))
		{
			vector3s[1] = (Vector3)tweenArguments["amount"];
			return;
		}
		if (tweenArguments.Contains("x"))
		{
			vector3s[1].x = (float)tweenArguments["x"];
		}
		if (tweenArguments.Contains("y"))
		{
			vector3s[1].y = (float)tweenArguments["y"];
		}
		if (tweenArguments.Contains("z"))
		{
			vector3s[1].z = (float)tweenArguments["z"];
		}
	}

	private void GeneratePunchScaleTargets()
	{
		vector3s = new Vector3[3];
		vector3s[0] = thisTransform.localScale;
		vector3s[1] = Vector3.zero;
		if (tweenArguments.Contains("amount"))
		{
			vector3s[1] = (Vector3)tweenArguments["amount"];
			return;
		}
		if (tweenArguments.Contains("x"))
		{
			vector3s[1].x = (float)tweenArguments["x"];
		}
		if (tweenArguments.Contains("y"))
		{
			vector3s[1].y = (float)tweenArguments["y"];
		}
		if (tweenArguments.Contains("z"))
		{
			vector3s[1].z = (float)tweenArguments["z"];
		}
	}

	private void ApplyRectTargets()
	{
		rects[2].x = ease(rects[0].x, rects[1].x, percentage);
		rects[2].y = ease(rects[0].y, rects[1].y, percentage);
		rects[2].width = ease(rects[0].width, rects[1].width, percentage);
		rects[2].height = ease(rects[0].height, rects[1].height, percentage);
		tweenArguments["onupdateparams"] = rects[2];
		if (percentage == 1f)
		{
			tweenArguments["onupdateparams"] = rects[1];
		}
	}

	private void ApplyColorTargets()
	{
		colors[0, 2].r = ease(colors[0, 0].r, colors[0, 1].r, percentage);
		colors[0, 2].g = ease(colors[0, 0].g, colors[0, 1].g, percentage);
		colors[0, 2].b = ease(colors[0, 0].b, colors[0, 1].b, percentage);
		colors[0, 2].a = ease(colors[0, 0].a, colors[0, 1].a, percentage);
		tweenArguments["onupdateparams"] = colors[0, 2];
		if (percentage == 1f)
		{
			tweenArguments["onupdateparams"] = colors[0, 1];
		}
	}

	private void ApplyVector3Targets()
	{
		vector3s[2].x = ease(vector3s[0].x, vector3s[1].x, percentage);
		vector3s[2].y = ease(vector3s[0].y, vector3s[1].y, percentage);
		vector3s[2].z = ease(vector3s[0].z, vector3s[1].z, percentage);
		tweenArguments["onupdateparams"] = vector3s[2];
		if (percentage == 1f)
		{
			tweenArguments["onupdateparams"] = vector3s[1];
		}
	}

	private void ApplyVector2Targets()
	{
		vector2s[2].x = ease(vector2s[0].x, vector2s[1].x, percentage);
		vector2s[2].y = ease(vector2s[0].y, vector2s[1].y, percentage);
		tweenArguments["onupdateparams"] = vector2s[2];
		if (percentage == 1f)
		{
			tweenArguments["onupdateparams"] = vector2s[1];
		}
	}

	private void ApplyFloatTargets()
	{
		floats[2] = ease(floats[0], floats[1], percentage);
		tweenArguments["onupdateparams"] = floats[2];
		if (percentage == 1f)
		{
			tweenArguments["onupdateparams"] = floats[1];
		}
	}

	private void ApplyColorToTargets()
	{
		for (int i = 0; i < colors.GetLength(0); i++)
		{
			colors[i, 2].r = ease(colors[i, 0].r, colors[i, 1].r, percentage);
			colors[i, 2].g = ease(colors[i, 0].g, colors[i, 1].g, percentage);
			colors[i, 2].b = ease(colors[i, 0].b, colors[i, 1].b, percentage);
			colors[i, 2].a = ease(colors[i, 0].a, colors[i, 1].a, percentage);
		}
		if ((bool)GetComponent<Image>())
		{
			GetComponent<Image>().color = colors[0, 2];
		}
		else if ((bool)GetComponent<Text>())
		{
			GetComponent<Text>().material.color = colors[0, 2];
		}
		else if ((bool)GetComponent<Renderer>())
		{
			for (int j = 0; j < colors.GetLength(0); j++)
			{
				GetComponent<Renderer>().materials[j].SetColor(namedcolorvalue.ToString(), colors[j, 2]);
			}
		}
		else if ((bool)GetComponent<Light>())
		{
			GetComponent<Light>().color = colors[0, 2];
		}
		if (percentage != 1f)
		{
			return;
		}
		if ((bool)GetComponent<Image>())
		{
			GetComponent<Image>().color = colors[0, 1];
		}
		else if ((bool)GetComponent<Text>())
		{
			GetComponent<Text>().material.color = colors[0, 1];
		}
		else if ((bool)GetComponent<Renderer>())
		{
			for (int k = 0; k < colors.GetLength(0); k++)
			{
				GetComponent<Renderer>().materials[k].SetColor(namedcolorvalue.ToString(), colors[k, 1]);
			}
		}
		else if ((bool)GetComponent<Light>())
		{
			GetComponent<Light>().color = colors[0, 1];
		}
	}

	private void ApplyAudioToTargets()
	{
		vector2s[2].x = ease(vector2s[0].x, vector2s[1].x, percentage);
		vector2s[2].y = ease(vector2s[0].y, vector2s[1].y, percentage);
		audioSource.volume = vector2s[2].x;
		audioSource.pitch = vector2s[2].y;
		if (percentage == 1f)
		{
			audioSource.volume = vector2s[1].x;
			audioSource.pitch = vector2s[1].y;
		}
	}

	private void ApplyStabTargets()
	{
	}

	private void ApplyMoveToPathTargets()
	{
		preUpdate = thisTransform.position;
		float value = ease(0f, 1f, percentage);
		if (isLocal)
		{
			thisTransform.localPosition = path.Interp(Mathf.Clamp(value, 0f, 1f));
		}
		else
		{
			thisTransform.position = path.Interp(Mathf.Clamp(value, 0f, 1f));
		}
		if (tweenArguments.Contains("orienttopath") && (bool)tweenArguments["orienttopath"])
		{
			float num = ((!tweenArguments.Contains("lookahead")) ? Defaults.lookAhead : ((float)tweenArguments["lookahead"]));
			float value2 = ease(0f, 1f, Mathf.Min(1f, percentage + num));
			tweenArguments["looktarget"] = path.Interp(Mathf.Clamp(value2, 0f, 1f));
		}
		postUpdate = thisTransform.position;
		if (physics)
		{
			thisTransform.position = preUpdate;
			GetComponent<Rigidbody>().MovePosition(postUpdate);
		}
	}

	private void ApplyMoveToTargets()
	{
		preUpdate = thisTransform.position;
		vector3s[2].x = ease(vector3s[0].x, vector3s[1].x, percentage);
		vector3s[2].y = ease(vector3s[0].y, vector3s[1].y, percentage);
		vector3s[2].z = ease(vector3s[0].z, vector3s[1].z, percentage);
		if (isLocal)
		{
			thisTransform.localPosition = vector3s[2];
		}
		else
		{
			thisTransform.position = vector3s[2];
		}
		if (percentage == 1f)
		{
			if (isLocal)
			{
				thisTransform.localPosition = vector3s[1];
			}
			else
			{
				thisTransform.position = vector3s[1];
			}
		}
		postUpdate = thisTransform.position;
		if (physics)
		{
			thisTransform.position = preUpdate;
			GetComponent<Rigidbody>().MovePosition(postUpdate);
		}
	}

	private void ApplyMoveByTargets()
	{
		preUpdate = thisTransform.position;
		Vector3 eulerAngles = default(Vector3);
		if (tweenArguments.Contains("looktarget"))
		{
			eulerAngles = thisTransform.eulerAngles;
			thisTransform.eulerAngles = vector3s[4];
		}
		vector3s[2].x = ease(vector3s[0].x, vector3s[1].x, percentage);
		vector3s[2].y = ease(vector3s[0].y, vector3s[1].y, percentage);
		vector3s[2].z = ease(vector3s[0].z, vector3s[1].z, percentage);
		thisTransform.Translate(vector3s[2] - vector3s[3], space);
		vector3s[3] = vector3s[2];
		if (tweenArguments.Contains("looktarget"))
		{
			thisTransform.eulerAngles = eulerAngles;
		}
		postUpdate = thisTransform.position;
		if (physics)
		{
			thisTransform.position = preUpdate;
			GetComponent<Rigidbody>().MovePosition(postUpdate);
		}
	}

	private void ApplyScaleToTargets()
	{
		vector3s[2].x = ease(vector3s[0].x, vector3s[1].x, percentage);
		vector3s[2].y = ease(vector3s[0].y, vector3s[1].y, percentage);
		vector3s[2].z = ease(vector3s[0].z, vector3s[1].z, percentage);
		thisTransform.localScale = vector3s[2];
		if (percentage == 1f)
		{
			thisTransform.localScale = vector3s[1];
		}
	}

	private void ApplyLookToTargets()
	{
		vector3s[2].x = ease(vector3s[0].x, vector3s[1].x, percentage);
		vector3s[2].y = ease(vector3s[0].y, vector3s[1].y, percentage);
		vector3s[2].z = ease(vector3s[0].z, vector3s[1].z, percentage);
		if (isLocal)
		{
			thisTransform.localRotation = Quaternion.Euler(vector3s[2]);
		}
		else
		{
			thisTransform.rotation = Quaternion.Euler(vector3s[2]);
		}
	}

	private void ApplyRotateToTargets()
	{
		preUpdate = thisTransform.eulerAngles;
		vector3s[2].x = ease(vector3s[0].x, vector3s[1].x, percentage);
		vector3s[2].y = ease(vector3s[0].y, vector3s[1].y, percentage);
		vector3s[2].z = ease(vector3s[0].z, vector3s[1].z, percentage);
		if (isLocal)
		{
			thisTransform.localRotation = Quaternion.Euler(vector3s[2]);
		}
		else
		{
			thisTransform.rotation = Quaternion.Euler(vector3s[2]);
		}
		if (percentage == 1f)
		{
			if (isLocal)
			{
				thisTransform.localRotation = Quaternion.Euler(vector3s[1]);
			}
			else
			{
				thisTransform.rotation = Quaternion.Euler(vector3s[1]);
			}
		}
		postUpdate = thisTransform.eulerAngles;
		if (physics)
		{
			thisTransform.eulerAngles = preUpdate;
			GetComponent<Rigidbody>().MoveRotation(Quaternion.Euler(postUpdate));
		}
	}

	private void ApplyRotateAddTargets()
	{
		preUpdate = thisTransform.eulerAngles;
		vector3s[2].x = ease(vector3s[0].x, vector3s[1].x, percentage);
		vector3s[2].y = ease(vector3s[0].y, vector3s[1].y, percentage);
		vector3s[2].z = ease(vector3s[0].z, vector3s[1].z, percentage);
		thisTransform.Rotate(vector3s[2] - vector3s[3], space);
		vector3s[3] = vector3s[2];
		postUpdate = thisTransform.eulerAngles;
		if (physics)
		{
			thisTransform.eulerAngles = preUpdate;
			GetComponent<Rigidbody>().MoveRotation(Quaternion.Euler(postUpdate));
		}
	}

	private void ApplyShakePositionTargets()
	{
		if (isLocal)
		{
			preUpdate = thisTransform.localPosition;
		}
		else
		{
			preUpdate = thisTransform.position;
		}
		Vector3 eulerAngles = default(Vector3);
		if (tweenArguments.Contains("looktarget"))
		{
			eulerAngles = thisTransform.eulerAngles;
			thisTransform.eulerAngles = vector3s[3];
		}
		if (percentage == 0f)
		{
			thisTransform.Translate(vector3s[1], space);
		}
		if (isLocal)
		{
			thisTransform.localPosition = vector3s[0];
		}
		else
		{
			thisTransform.position = vector3s[0];
		}
		float num = 1f - percentage;
		vector3s[2].x = UnityEngine.Random.Range((0f - vector3s[1].x) * num, vector3s[1].x * num);
		vector3s[2].y = UnityEngine.Random.Range((0f - vector3s[1].y) * num, vector3s[1].y * num);
		vector3s[2].z = UnityEngine.Random.Range((0f - vector3s[1].z) * num, vector3s[1].z * num);
		if (isLocal)
		{
			thisTransform.localPosition += vector3s[2];
		}
		else
		{
			thisTransform.position += vector3s[2];
		}
		if (tweenArguments.Contains("looktarget"))
		{
			thisTransform.eulerAngles = eulerAngles;
		}
		postUpdate = thisTransform.position;
		if (physics)
		{
			thisTransform.position = preUpdate;
			GetComponent<Rigidbody>().MovePosition(postUpdate);
		}
	}

	private void ApplyShakeScaleTargets()
	{
		if (percentage == 0f)
		{
			thisTransform.localScale = vector3s[1];
		}
		thisTransform.localScale = vector3s[0];
		float num = 1f - percentage;
		vector3s[2].x = UnityEngine.Random.Range((0f - vector3s[1].x) * num, vector3s[1].x * num);
		vector3s[2].y = UnityEngine.Random.Range((0f - vector3s[1].y) * num, vector3s[1].y * num);
		vector3s[2].z = UnityEngine.Random.Range((0f - vector3s[1].z) * num, vector3s[1].z * num);
		thisTransform.localScale += vector3s[2];
	}

	private void ApplyShakeRotationTargets()
	{
		preUpdate = thisTransform.eulerAngles;
		if (percentage == 0f)
		{
			thisTransform.Rotate(vector3s[1], space);
		}
		thisTransform.eulerAngles = vector3s[0];
		float num = 1f - percentage;
		vector3s[2].x = UnityEngine.Random.Range((0f - vector3s[1].x) * num, vector3s[1].x * num);
		vector3s[2].y = UnityEngine.Random.Range((0f - vector3s[1].y) * num, vector3s[1].y * num);
		vector3s[2].z = UnityEngine.Random.Range((0f - vector3s[1].z) * num, vector3s[1].z * num);
		thisTransform.Rotate(vector3s[2], space);
		postUpdate = thisTransform.eulerAngles;
		if (physics)
		{
			thisTransform.eulerAngles = preUpdate;
			GetComponent<Rigidbody>().MoveRotation(Quaternion.Euler(postUpdate));
		}
	}

	private void ApplyPunchPositionTargets()
	{
		preUpdate = thisTransform.position;
		Vector3 eulerAngles = default(Vector3);
		if (tweenArguments.Contains("looktarget"))
		{
			eulerAngles = thisTransform.eulerAngles;
			thisTransform.eulerAngles = vector3s[4];
		}
		if (vector3s[1].x > 0f)
		{
			vector3s[2].x = punch(vector3s[1].x, percentage);
		}
		else if (vector3s[1].x < 0f)
		{
			vector3s[2].x = 0f - punch(Mathf.Abs(vector3s[1].x), percentage);
		}
		if (vector3s[1].y > 0f)
		{
			vector3s[2].y = punch(vector3s[1].y, percentage);
		}
		else if (vector3s[1].y < 0f)
		{
			vector3s[2].y = 0f - punch(Mathf.Abs(vector3s[1].y), percentage);
		}
		if (vector3s[1].z > 0f)
		{
			vector3s[2].z = punch(vector3s[1].z, percentage);
		}
		else if (vector3s[1].z < 0f)
		{
			vector3s[2].z = 0f - punch(Mathf.Abs(vector3s[1].z), percentage);
		}
		thisTransform.Translate(vector3s[2] - vector3s[3], space);
		vector3s[3] = vector3s[2];
		if (tweenArguments.Contains("looktarget"))
		{
			thisTransform.eulerAngles = eulerAngles;
		}
		postUpdate = thisTransform.position;
		if (physics)
		{
			thisTransform.position = preUpdate;
			GetComponent<Rigidbody>().MovePosition(postUpdate);
		}
	}

	private void ApplyPunchRotationTargets()
	{
		preUpdate = thisTransform.eulerAngles;
		if (vector3s[1].x > 0f)
		{
			vector3s[2].x = punch(vector3s[1].x, percentage);
		}
		else if (vector3s[1].x < 0f)
		{
			vector3s[2].x = 0f - punch(Mathf.Abs(vector3s[1].x), percentage);
		}
		if (vector3s[1].y > 0f)
		{
			vector3s[2].y = punch(vector3s[1].y, percentage);
		}
		else if (vector3s[1].y < 0f)
		{
			vector3s[2].y = 0f - punch(Mathf.Abs(vector3s[1].y), percentage);
		}
		if (vector3s[1].z > 0f)
		{
			vector3s[2].z = punch(vector3s[1].z, percentage);
		}
		else if (vector3s[1].z < 0f)
		{
			vector3s[2].z = 0f - punch(Mathf.Abs(vector3s[1].z), percentage);
		}
		thisTransform.Rotate(vector3s[2] - vector3s[3], space);
		vector3s[3] = vector3s[2];
		postUpdate = thisTransform.eulerAngles;
		if (physics)
		{
			thisTransform.eulerAngles = preUpdate;
			GetComponent<Rigidbody>().MoveRotation(Quaternion.Euler(postUpdate));
		}
	}

	private void ApplyPunchScaleTargets()
	{
		if (vector3s[1].x > 0f)
		{
			vector3s[2].x = punch(vector3s[1].x, percentage);
		}
		else if (vector3s[1].x < 0f)
		{
			vector3s[2].x = 0f - punch(Mathf.Abs(vector3s[1].x), percentage);
		}
		if (vector3s[1].y > 0f)
		{
			vector3s[2].y = punch(vector3s[1].y, percentage);
		}
		else if (vector3s[1].y < 0f)
		{
			vector3s[2].y = 0f - punch(Mathf.Abs(vector3s[1].y), percentage);
		}
		if (vector3s[1].z > 0f)
		{
			vector3s[2].z = punch(vector3s[1].z, percentage);
		}
		else if (vector3s[1].z < 0f)
		{
			vector3s[2].z = 0f - punch(Mathf.Abs(vector3s[1].z), percentage);
		}
		thisTransform.localScale = vector3s[0] + vector3s[2];
	}

	private IEnumerator TweenDelay()
	{
		delayStarted = Time.time;
		yield return new WaitForSeconds(delay);
		if (wasPaused)
		{
			wasPaused = false;
			TweenStart();
		}
	}

	private void TweenStart()
	{
		CallBack("onstart");
		if (!loop)
		{
			ConflictCheck();
			GenerateTargets();
		}
		if (type == "stab")
		{
			audioSource.PlayOneShot(audioSource.clip);
		}
		if (type == "move" || type == "scale" || type == "rotate" || type == "punch" || type == "shake" || type == "curve" || type == "look")
		{
			EnableKinematic();
		}
		isRunning = true;
	}

	private IEnumerator TweenRestart()
	{
		if (delay > 0f)
		{
			delayStarted = Time.time;
			yield return new WaitForSeconds(delay);
		}
		loop = true;
		TweenStart();
	}

	private void TweenUpdate()
	{
		apply();
		CallBack("onupdate");
		UpdatePercentage();
	}

	private void TweenComplete()
	{
		isRunning = false;
		if (percentage > 0.5f)
		{
			percentage = 1f;
		}
		else
		{
			percentage = 0f;
		}
		apply();
		if (type == "value")
		{
			CallBack("onupdate");
		}
		if (loopType == LoopType.none)
		{
			Dispose();
		}
		else
		{
			TweenLoop();
		}
		CallBack("oncomplete");
	}

	private void TweenLoop()
	{
		DisableKinematic();
		switch (loopType)
		{
		case LoopType.loop:
			percentage = 0f;
			runningTime = 0f;
			apply();
			StartCoroutine("TweenRestart");
			break;
		case LoopType.pingPong:
			reverse = !reverse;
			runningTime = 0f;
			StartCoroutine("TweenRestart");
			break;
		}
	}

	public static Rect RectUpdate(Rect currentValue, Rect targetValue, float speed)
	{
		return new Rect(FloatUpdate(currentValue.x, targetValue.x, speed), FloatUpdate(currentValue.y, targetValue.y, speed), FloatUpdate(currentValue.width, targetValue.width, speed), FloatUpdate(currentValue.height, targetValue.height, speed));
	}

	public static Vector3 Vector3Update(Vector3 currentValue, Vector3 targetValue, float speed)
	{
		Vector3 vector = targetValue - currentValue;
		currentValue += vector * speed * Time.deltaTime;
		return currentValue;
	}

	public static Vector2 Vector2Update(Vector2 currentValue, Vector2 targetValue, float speed)
	{
		Vector2 vector = targetValue - currentValue;
		currentValue += vector * speed * Time.deltaTime;
		return currentValue;
	}

	public static float FloatUpdate(float currentValue, float targetValue, float speed)
	{
		float num = targetValue - currentValue;
		currentValue += num * speed * Time.deltaTime;
		return currentValue;
	}

	public static void FadeUpdate(GameObject target, System.Collections.Hashtable args)
	{
		args["a"] = args["alpha"];
		ColorUpdate(target, args);
	}

	public static void FadeUpdate(GameObject target, float alpha, float time)
	{
		FadeUpdate(target, Hash("alpha", alpha, "time", time));
	}

	public static void ColorUpdate(GameObject target, System.Collections.Hashtable args)
	{
		CleanArgs(args);
		Color[] array = new Color[4];
		if (!args.Contains("includechildren") || (bool)args["includechildren"])
		{
			foreach (Transform item in target.transform)
			{
				ColorUpdate(item.gameObject, args);
			}
		}
		float num;
		if (args.Contains("time"))
		{
			num = (float)args["time"];
			num *= Defaults.updateTimePercentage;
		}
		else
		{
			num = Defaults.updateTime;
		}
		if ((bool)target.GetComponent<Image>())
		{
			array[0] = (array[1] = target.GetComponent<Image>().color);
		}
		else if ((bool)target.GetComponent<Text>())
		{
			array[0] = (array[1] = target.GetComponent<Text>().material.color);
		}
		else if ((bool)target.GetComponent<Renderer>())
		{
			array[0] = (array[1] = target.GetComponent<Renderer>().material.color);
		}
		else if ((bool)target.GetComponent<Light>())
		{
			array[0] = (array[1] = target.GetComponent<Light>().color);
		}
		if (args.Contains("color"))
		{
			array[1] = (Color)args["color"];
		}
		else
		{
			if (args.Contains("r"))
			{
				array[1].r = (float)args["r"];
			}
			if (args.Contains("g"))
			{
				array[1].g = (float)args["g"];
			}
			if (args.Contains("b"))
			{
				array[1].b = (float)args["b"];
			}
			if (args.Contains("a"))
			{
				array[1].a = (float)args["a"];
			}
		}
		array[3].r = Mathf.SmoothDamp(array[0].r, array[1].r, ref array[2].r, num);
		array[3].g = Mathf.SmoothDamp(array[0].g, array[1].g, ref array[2].g, num);
		array[3].b = Mathf.SmoothDamp(array[0].b, array[1].b, ref array[2].b, num);
		array[3].a = Mathf.SmoothDamp(array[0].a, array[1].a, ref array[2].a, num);
		if ((bool)target.GetComponent<Image>())
		{
			target.GetComponent<Image>().color = array[3];
		}
		else if ((bool)target.GetComponent<Text>())
		{
			target.GetComponent<Text>().material.color = array[3];
		}
		else if ((bool)target.GetComponent<Renderer>())
		{
			target.GetComponent<Renderer>().material.color = array[3];
		}
		else if ((bool)target.GetComponent<Light>())
		{
			target.GetComponent<Light>().color = array[3];
		}
	}

	public static void ColorUpdate(GameObject target, Color color, float time)
	{
		ColorUpdate(target, Hash("color", color, "time", time));
	}

	public static void AudioUpdate(GameObject target, System.Collections.Hashtable args)
	{
		CleanArgs(args);
		Vector2[] array = new Vector2[4];
		float num;
		if (args.Contains("time"))
		{
			num = (float)args["time"];
			num *= Defaults.updateTimePercentage;
		}
		else
		{
			num = Defaults.updateTime;
		}
		AudioSource audioSource;
		if (args.Contains("audiosource"))
		{
			audioSource = (AudioSource)args["audiosource"];
		}
		else
		{
			if (!target.GetComponent<AudioSource>())
			{
				UnityEngine.Debug.LogError("iTween Error: AudioUpdate requires an AudioSource.");
				return;
			}
			audioSource = target.GetComponent<AudioSource>();
		}
		array[0] = (array[1] = new Vector2(audioSource.volume, audioSource.pitch));
		if (args.Contains("volume"))
		{
			array[1].x = (float)args["volume"];
		}
		if (args.Contains("pitch"))
		{
			array[1].y = (float)args["pitch"];
		}
		array[3].x = Mathf.SmoothDampAngle(array[0].x, array[1].x, ref array[2].x, num);
		array[3].y = Mathf.SmoothDampAngle(array[0].y, array[1].y, ref array[2].y, num);
		audioSource.volume = array[3].x;
		audioSource.pitch = array[3].y;
	}

	public static void AudioUpdate(GameObject target, float volume, float pitch, float time)
	{
		AudioUpdate(target, Hash("volume", volume, "pitch", pitch, "time", time));
	}

	public static void RotateUpdate(GameObject target, System.Collections.Hashtable args)
	{
		CleanArgs(args);
		Vector3[] array = new Vector3[4];
		Vector3 eulerAngles = target.transform.eulerAngles;
		float num;
		if (args.Contains("time"))
		{
			num = (float)args["time"];
			num *= Defaults.updateTimePercentage;
		}
		else
		{
			num = Defaults.updateTime;
		}
		bool flag = ((!args.Contains("islocal")) ? Defaults.isLocal : ((bool)args["islocal"]));
		if (flag)
		{
			array[0] = target.transform.localEulerAngles;
		}
		else
		{
			array[0] = target.transform.eulerAngles;
		}
		if (args.Contains("rotation"))
		{
			if (args["rotation"].GetType() == typeof(Transform))
			{
				Transform transform = (Transform)args["rotation"];
				array[1] = transform.eulerAngles;
			}
			else if (args["rotation"].GetType() == typeof(Vector3))
			{
				array[1] = (Vector3)args["rotation"];
			}
		}
		array[3].x = Mathf.SmoothDampAngle(array[0].x, array[1].x, ref array[2].x, num);
		array[3].y = Mathf.SmoothDampAngle(array[0].y, array[1].y, ref array[2].y, num);
		array[3].z = Mathf.SmoothDampAngle(array[0].z, array[1].z, ref array[2].z, num);
		if (flag)
		{
			target.transform.localEulerAngles = array[3];
		}
		else
		{
			target.transform.eulerAngles = array[3];
		}
		if (target.GetComponent<Rigidbody>() != null)
		{
			Vector3 eulerAngles2 = target.transform.eulerAngles;
			target.transform.eulerAngles = eulerAngles;
			target.GetComponent<Rigidbody>().MoveRotation(Quaternion.Euler(eulerAngles2));
		}
	}

	public static void RotateUpdate(GameObject target, Vector3 rotation, float time)
	{
		RotateUpdate(target, Hash("rotation", rotation, "time", time));
	}

	public static void ScaleUpdate(GameObject target, System.Collections.Hashtable args)
	{
		CleanArgs(args);
		Vector3[] array = new Vector3[4];
		float num;
		if (args.Contains("time"))
		{
			num = (float)args["time"];
			num *= Defaults.updateTimePercentage;
		}
		else
		{
			num = Defaults.updateTime;
		}
		array[0] = (array[1] = target.transform.localScale);
		if (args.Contains("scale"))
		{
			if (args["scale"].GetType() == typeof(Transform))
			{
				Transform transform = (Transform)args["scale"];
				array[1] = transform.localScale;
			}
			else if (args["scale"].GetType() == typeof(Vector3))
			{
				array[1] = (Vector3)args["scale"];
			}
		}
		else
		{
			if (args.Contains("x"))
			{
				array[1].x = (float)args["x"];
			}
			if (args.Contains("y"))
			{
				array[1].y = (float)args["y"];
			}
			if (args.Contains("z"))
			{
				array[1].z = (float)args["z"];
			}
		}
		array[3].x = Mathf.SmoothDamp(array[0].x, array[1].x, ref array[2].x, num);
		array[3].y = Mathf.SmoothDamp(array[0].y, array[1].y, ref array[2].y, num);
		array[3].z = Mathf.SmoothDamp(array[0].z, array[1].z, ref array[2].z, num);
		target.transform.localScale = array[3];
	}

	public static void ScaleUpdate(GameObject target, Vector3 scale, float time)
	{
		ScaleUpdate(target, Hash("scale", scale, "time", time));
	}

	public static void MoveUpdate(GameObject target, System.Collections.Hashtable args)
	{
		CleanArgs(args);
		Vector3[] array = new Vector3[4];
		Vector3 position = target.transform.position;
		float num;
		if (args.Contains("time"))
		{
			num = (float)args["time"];
			num *= Defaults.updateTimePercentage;
		}
		else
		{
			num = Defaults.updateTime;
		}
		bool flag = ((!args.Contains("islocal")) ? Defaults.isLocal : ((bool)args["islocal"]));
		if (flag)
		{
			array[0] = (array[1] = target.transform.localPosition);
		}
		else
		{
			array[0] = (array[1] = target.transform.position);
		}
		if (args.Contains("position"))
		{
			if (args["position"].GetType() == typeof(Transform))
			{
				Transform transform = (Transform)args["position"];
				array[1] = transform.position;
			}
			else if (args["position"].GetType() == typeof(Vector3))
			{
				array[1] = (Vector3)args["position"];
			}
		}
		else
		{
			if (args.Contains("x"))
			{
				array[1].x = (float)args["x"];
			}
			if (args.Contains("y"))
			{
				array[1].y = (float)args["y"];
			}
			if (args.Contains("z"))
			{
				array[1].z = (float)args["z"];
			}
		}
		array[3].x = Mathf.SmoothDamp(array[0].x, array[1].x, ref array[2].x, num);
		array[3].y = Mathf.SmoothDamp(array[0].y, array[1].y, ref array[2].y, num);
		array[3].z = Mathf.SmoothDamp(array[0].z, array[1].z, ref array[2].z, num);
		if (args.Contains("orienttopath") && (bool)args["orienttopath"])
		{
			args["looktarget"] = array[3];
		}
		if (args.Contains("looktarget"))
		{
			LookUpdate(target, args);
		}
		if (flag)
		{
			target.transform.localPosition = array[3];
		}
		else
		{
			target.transform.position = array[3];
		}
		if (target.GetComponent<Rigidbody>() != null)
		{
			Vector3 position2 = target.transform.position;
			target.transform.position = position;
			target.GetComponent<Rigidbody>().MovePosition(position2);
		}
	}

	public static void MoveUpdate(GameObject target, Vector3 position, float time)
	{
		MoveUpdate(target, Hash("position", position, "time", time));
	}

	public static void LookUpdate(GameObject target, System.Collections.Hashtable args)
	{
		CleanArgs(args);
		Vector3[] array = new Vector3[5];
		float num;
		if (args.Contains("looktime"))
		{
			num = (float)args["looktime"];
			num *= Defaults.updateTimePercentage;
		}
		else if (args.Contains("time"))
		{
			num = (float)args["time"] * 0.15f;
			num *= Defaults.updateTimePercentage;
		}
		else
		{
			num = Defaults.updateTime;
		}
		array[0] = target.transform.eulerAngles;
		if (args.Contains("looktarget"))
		{
			if (args["looktarget"].GetType() == typeof(Transform))
			{
				target.transform.LookAt((Transform)args["looktarget"], ((Vector3?)args["up"]) ?? Defaults.up);
			}
			else if (args["looktarget"].GetType() == typeof(Vector3))
			{
				target.transform.LookAt((Vector3)args["looktarget"], ((Vector3?)args["up"]) ?? Defaults.up);
			}
			array[1] = target.transform.eulerAngles;
			target.transform.eulerAngles = array[0];
			array[3].x = Mathf.SmoothDampAngle(array[0].x, array[1].x, ref array[2].x, num);
			array[3].y = Mathf.SmoothDampAngle(array[0].y, array[1].y, ref array[2].y, num);
			array[3].z = Mathf.SmoothDampAngle(array[0].z, array[1].z, ref array[2].z, num);
			target.transform.eulerAngles = array[3];
			if (args.Contains("axis"))
			{
				array[4] = target.transform.eulerAngles;
				switch ((string)args["axis"])
				{
				case "x":
					array[4].y = array[0].y;
					array[4].z = array[0].z;
					break;
				case "y":
					array[4].x = array[0].x;
					array[4].z = array[0].z;
					break;
				case "z":
					array[4].x = array[0].x;
					array[4].y = array[0].y;
					break;
				}
				target.transform.eulerAngles = array[4];
			}
		}
		else
		{
			UnityEngine.Debug.LogError("iTween Error: LookUpdate needs a 'looktarget' property!");
		}
	}

	public static void LookUpdate(GameObject target, Vector3 looktarget, float time)
	{
		LookUpdate(target, Hash("looktarget", looktarget, "time", time));
	}

	public static float PathLength(Transform[] path)
	{
		Vector3[] array = new Vector3[path.Length];
		float num = 0f;
		for (int i = 0; i < path.Length; i++)
		{
			array[i] = path[i].position;
		}
		Vector3[] pts = PathControlPointGenerator(array);
		Vector3 a = Interp(pts, 0f);
		int num2 = path.Length * 20;
		for (int j = 1; j <= num2; j++)
		{
			float t = (float)j / (float)num2;
			Vector3 vector = Interp(pts, t);
			num += Vector3.Distance(a, vector);
			a = vector;
		}
		return num;
	}

	public static float PathLength(Vector3[] path)
	{
		float num = 0f;
		Vector3[] pts = PathControlPointGenerator(path);
		Vector3 a = Interp(pts, 0f);
		int num2 = path.Length * 20;
		for (int i = 1; i <= num2; i++)
		{
			float t = (float)i / (float)num2;
			Vector3 vector = Interp(pts, t);
			num += Vector3.Distance(a, vector);
			a = vector;
		}
		return num;
	}

	public static Texture2D CameraTexture(Color color)
	{
		Texture2D texture2D = new Texture2D(Screen.width, Screen.height, TextureFormat.ARGB32, mipChain: false);
		Color[] array = new Color[Screen.width * Screen.height];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = color;
		}
		texture2D.SetPixels(array);
		texture2D.Apply();
		return texture2D;
	}

	public static void PutOnPath(GameObject target, Vector3[] path, float percent)
	{
		target.transform.position = Interp(PathControlPointGenerator(path), percent);
	}

	public static void PutOnPath(Transform target, Vector3[] path, float percent)
	{
		target.position = Interp(PathControlPointGenerator(path), percent);
	}

	public static void PutOnPath(GameObject target, Transform[] path, float percent)
	{
		Vector3[] array = new Vector3[path.Length];
		for (int i = 0; i < path.Length; i++)
		{
			array[i] = path[i].position;
		}
		target.transform.position = Interp(PathControlPointGenerator(array), percent);
	}

	public static void PutOnPath(Transform target, Transform[] path, float percent)
	{
		Vector3[] array = new Vector3[path.Length];
		for (int i = 0; i < path.Length; i++)
		{
			array[i] = path[i].position;
		}
		target.position = Interp(PathControlPointGenerator(array), percent);
	}

	public static Vector3 PointOnPath(Transform[] path, float percent)
	{
		Vector3[] array = new Vector3[path.Length];
		for (int i = 0; i < path.Length; i++)
		{
			array[i] = path[i].position;
		}
		return Interp(PathControlPointGenerator(array), percent);
	}

	public static void DrawLine(Vector3[] line)
	{
		if (line.Length != 0)
		{
			DrawLineHelper(line, Defaults.color, "gizmos");
		}
	}

	public static void DrawLine(Vector3[] line, Color color)
	{
		if (line.Length != 0)
		{
			DrawLineHelper(line, color, "gizmos");
		}
	}

	public static void DrawLine(Transform[] line)
	{
		if (line.Length != 0)
		{
			Vector3[] array = new Vector3[line.Length];
			for (int i = 0; i < line.Length; i++)
			{
				array[i] = line[i].position;
			}
			DrawLineHelper(array, Defaults.color, "gizmos");
		}
	}

	public static void DrawLine(Transform[] line, Color color)
	{
		if (line.Length != 0)
		{
			Vector3[] array = new Vector3[line.Length];
			for (int i = 0; i < line.Length; i++)
			{
				array[i] = line[i].position;
			}
			DrawLineHelper(array, color, "gizmos");
		}
	}

	public static void DrawLineGizmos(Vector3[] line)
	{
		if (line.Length != 0)
		{
			DrawLineHelper(line, Defaults.color, "gizmos");
		}
	}

	public static void DrawLineGizmos(Vector3[] line, Color color)
	{
		if (line.Length != 0)
		{
			DrawLineHelper(line, color, "gizmos");
		}
	}

	public static void DrawLineGizmos(Transform[] line)
	{
		if (line.Length != 0)
		{
			Vector3[] array = new Vector3[line.Length];
			for (int i = 0; i < line.Length; i++)
			{
				array[i] = line[i].position;
			}
			DrawLineHelper(array, Defaults.color, "gizmos");
		}
	}

	public static void DrawLineGizmos(Transform[] line, Color color)
	{
		if (line.Length != 0)
		{
			Vector3[] array = new Vector3[line.Length];
			for (int i = 0; i < line.Length; i++)
			{
				array[i] = line[i].position;
			}
			DrawLineHelper(array, color, "gizmos");
		}
	}

	public static void DrawLineHandles(Vector3[] line)
	{
		if (line.Length != 0)
		{
			DrawLineHelper(line, Defaults.color, "handles");
		}
	}

	public static void DrawLineHandles(Vector3[] line, Color color)
	{
		if (line.Length != 0)
		{
			DrawLineHelper(line, color, "handles");
		}
	}

	public static void DrawLineHandles(Transform[] line)
	{
		if (line.Length != 0)
		{
			Vector3[] array = new Vector3[line.Length];
			for (int i = 0; i < line.Length; i++)
			{
				array[i] = line[i].position;
			}
			DrawLineHelper(array, Defaults.color, "handles");
		}
	}

	public static void DrawLineHandles(Transform[] line, Color color)
	{
		if (line.Length != 0)
		{
			Vector3[] array = new Vector3[line.Length];
			for (int i = 0; i < line.Length; i++)
			{
				array[i] = line[i].position;
			}
			DrawLineHelper(array, color, "handles");
		}
	}

	public static Vector3 PointOnPath(Vector3[] path, float percent)
	{
		return Interp(PathControlPointGenerator(path), percent);
	}

	public static void DrawPath(Vector3[] path)
	{
		if (path.Length != 0)
		{
			DrawPathHelper(path, Defaults.color, "gizmos");
		}
	}

	public static void DrawPath(Vector3[] path, Color color)
	{
		if (path.Length != 0)
		{
			DrawPathHelper(path, color, "gizmos");
		}
	}

	public static void DrawPath(Transform[] path)
	{
		if (path.Length != 0)
		{
			Vector3[] array = new Vector3[path.Length];
			for (int i = 0; i < path.Length; i++)
			{
				array[i] = path[i].position;
			}
			DrawPathHelper(array, Defaults.color, "gizmos");
		}
	}

	public static void DrawPath(Transform[] path, Color color)
	{
		if (path.Length != 0)
		{
			Vector3[] array = new Vector3[path.Length];
			for (int i = 0; i < path.Length; i++)
			{
				array[i] = path[i].position;
			}
			DrawPathHelper(array, color, "gizmos");
		}
	}

	public static void DrawPathGizmos(Vector3[] path)
	{
		if (path.Length != 0)
		{
			DrawPathHelper(path, Defaults.color, "gizmos");
		}
	}

	public static void DrawPathGizmos(Vector3[] path, Color color)
	{
		if (path.Length != 0)
		{
			DrawPathHelper(path, color, "gizmos");
		}
	}

	public static void DrawPathGizmos(Transform[] path)
	{
		if (path.Length != 0)
		{
			Vector3[] array = new Vector3[path.Length];
			for (int i = 0; i < path.Length; i++)
			{
				array[i] = path[i].position;
			}
			DrawPathHelper(array, Defaults.color, "gizmos");
		}
	}

	public static void DrawPathGizmos(Transform[] path, Color color)
	{
		if (path.Length != 0)
		{
			Vector3[] array = new Vector3[path.Length];
			for (int i = 0; i < path.Length; i++)
			{
				array[i] = path[i].position;
			}
			DrawPathHelper(array, color, "gizmos");
		}
	}

	public static void DrawPathHandles(Vector3[] path)
	{
		if (path.Length != 0)
		{
			DrawPathHelper(path, Defaults.color, "handles");
		}
	}

	public static void DrawPathHandles(Vector3[] path, Color color)
	{
		if (path.Length != 0)
		{
			DrawPathHelper(path, color, "handles");
		}
	}

	public static void DrawPathHandles(Transform[] path)
	{
		if (path.Length != 0)
		{
			Vector3[] array = new Vector3[path.Length];
			for (int i = 0; i < path.Length; i++)
			{
				array[i] = path[i].position;
			}
			DrawPathHelper(array, Defaults.color, "handles");
		}
	}

	public static void DrawPathHandles(Transform[] path, Color color)
	{
		if (path.Length != 0)
		{
			Vector3[] array = new Vector3[path.Length];
			for (int i = 0; i < path.Length; i++)
			{
				array[i] = path[i].position;
			}
			DrawPathHelper(array, color, "handles");
		}
	}

	public static void CameraFadeDepth(int depth)
	{
		if ((bool)cameraFade)
		{
			cameraFade.transform.position = new Vector3(cameraFade.transform.position.x, cameraFade.transform.position.y, depth);
		}
	}

	public static void CameraFadeDestroy()
	{
		if ((bool)cameraFade)
		{
			UnityEngine.Object.Destroy(cameraFade);
		}
	}

	public static void CameraFadeSwap(Sprite texture)
	{
		if ((bool)cameraFade)
		{
			cameraFade.GetComponent<Image>().sprite = texture;
		}
	}

	public static GameObject CameraFadeAdd(Sprite texture, int depth)
	{
		if ((bool)cameraFade)
		{
			return null;
		}
		cameraFade = new GameObject("iTween Camera Fade");
		cameraFade.transform.position = new Vector3(0.5f, 0.5f, depth);
		cameraFade.AddComponent<Image>();
		cameraFade.GetComponent<Image>().sprite = texture;
		cameraFade.GetComponent<Image>().color = new Color(0.5f, 0.5f, 0.5f, 0f);
		return cameraFade;
	}

	public static GameObject CameraFadeAdd(Sprite texture)
	{
		if ((bool)cameraFade)
		{
			return null;
		}
		cameraFade = new GameObject("iTween Camera Fade");
		cameraFade.transform.position = new Vector3(0.5f, 0.5f, Defaults.cameraFadeDepth);
		cameraFade.AddComponent<Image>();
		cameraFade.GetComponent<Image>().sprite = texture;
		cameraFade.GetComponent<Image>().color = new Color(0.5f, 0.5f, 0.5f, 0f);
		return cameraFade;
	}

	public static GameObject CameraFadeAdd()
	{
		if ((bool)cameraFade)
		{
			return null;
		}
		cameraFade = new GameObject("iTween Camera Fade");
		cameraFade.transform.position = new Vector3(0.5f, 0.5f, Defaults.cameraFadeDepth);
		cameraFade.AddComponent<Image>();
		cameraFade.GetComponent<Image>().sprite = null;
		cameraFade.GetComponent<Image>().color = Color.black;
		return cameraFade;
	}

	public static void Resume(GameObject target)
	{
		Component[] components = target.GetComponents<iTween>();
		components = components;
		for (int i = 0; i < components.Length; i++)
		{
			((iTween)components[i]).enabled = true;
		}
	}

	public static void Resume(GameObject target, bool includechildren)
	{
		Resume(target);
		if (!includechildren)
		{
			return;
		}
		foreach (Transform item in target.transform)
		{
			Resume(item.gameObject, includechildren: true);
		}
	}

	public static void Resume(GameObject target, string type)
	{
		Component[] components = target.GetComponents<iTween>();
		components = components;
		for (int i = 0; i < components.Length; i++)
		{
			iTween iTween2 = (iTween)components[i];
			if ((iTween2.type + iTween2.method).Substring(0, type.Length).ToLower() == type.ToLower())
			{
				iTween2.enabled = true;
			}
		}
	}

	public static void Resume(GameObject target, string type, bool includechildren)
	{
		Component[] components = target.GetComponents<iTween>();
		components = components;
		for (int i = 0; i < components.Length; i++)
		{
			iTween iTween2 = (iTween)components[i];
			if ((iTween2.type + iTween2.method).Substring(0, type.Length).ToLower() == type.ToLower())
			{
				iTween2.enabled = true;
			}
		}
		if (!includechildren)
		{
			return;
		}
		foreach (Transform item in target.transform)
		{
			Resume(item.gameObject, type, includechildren: true);
		}
	}

	public static void Resume()
	{
		for (int i = 0; i < tweens.Count; i++)
		{
			Resume((GameObject)tweens[i]["target"]);
		}
	}

	public static void Resume(string type)
	{
		ArrayList arrayList = new ArrayList();
		for (int i = 0; i < tweens.Count; i++)
		{
			GameObject value = (GameObject)tweens[i]["target"];
			arrayList.Insert(arrayList.Count, value);
		}
		for (int j = 0; j < arrayList.Count; j++)
		{
			Resume((GameObject)arrayList[j], type);
		}
	}

	public static void Pause(GameObject target)
	{
		Component[] components = target.GetComponents<iTween>();
		components = components;
		for (int i = 0; i < components.Length; i++)
		{
			iTween iTween2 = (iTween)components[i];
			if (iTween2.delay > 0f)
			{
				iTween2.delay -= Time.time - iTween2.delayStarted;
				iTween2.StopCoroutine("TweenDelay");
			}
			iTween2.isPaused = true;
			iTween2.enabled = false;
		}
	}

	public static void Pause(GameObject target, bool includechildren)
	{
		Pause(target);
		if (!includechildren)
		{
			return;
		}
		foreach (Transform item in target.transform)
		{
			Pause(item.gameObject, includechildren: true);
		}
	}

	public static void Pause(GameObject target, string type)
	{
		Component[] components = target.GetComponents<iTween>();
		components = components;
		for (int i = 0; i < components.Length; i++)
		{
			iTween iTween2 = (iTween)components[i];
			if ((iTween2.type + iTween2.method).Substring(0, type.Length).ToLower() == type.ToLower())
			{
				if (iTween2.delay > 0f)
				{
					iTween2.delay -= Time.time - iTween2.delayStarted;
					iTween2.StopCoroutine("TweenDelay");
				}
				iTween2.isPaused = true;
				iTween2.enabled = false;
			}
		}
	}

	public static void Pause(GameObject target, string type, bool includechildren)
	{
		Component[] components = target.GetComponents<iTween>();
		components = components;
		for (int i = 0; i < components.Length; i++)
		{
			iTween iTween2 = (iTween)components[i];
			if ((iTween2.type + iTween2.method).Substring(0, type.Length).ToLower() == type.ToLower())
			{
				if (iTween2.delay > 0f)
				{
					iTween2.delay -= Time.time - iTween2.delayStarted;
					iTween2.StopCoroutine("TweenDelay");
				}
				iTween2.isPaused = true;
				iTween2.enabled = false;
			}
		}
		if (!includechildren)
		{
			return;
		}
		foreach (Transform item in target.transform)
		{
			Pause(item.gameObject, type, includechildren: true);
		}
	}

	public static void Pause()
	{
		for (int i = 0; i < tweens.Count; i++)
		{
			Pause((GameObject)tweens[i]["target"]);
		}
	}

	public static void Pause(string type)
	{
		ArrayList arrayList = new ArrayList();
		for (int i = 0; i < tweens.Count; i++)
		{
			GameObject value = (GameObject)tweens[i]["target"];
			arrayList.Insert(arrayList.Count, value);
		}
		for (int j = 0; j < arrayList.Count; j++)
		{
			Pause((GameObject)arrayList[j], type);
		}
	}

	public static int Count()
	{
		return tweens.Count;
	}

	public static int Count(string type)
	{
		int num = 0;
		for (int i = 0; i < tweens.Count; i++)
		{
			System.Collections.Hashtable hashtable = tweens[i];
			if (((string)hashtable["type"] + (string)hashtable["method"]).Substring(0, type.Length).ToLower() == type.ToLower())
			{
				num++;
			}
		}
		return num;
	}

	public static int Count(GameObject target)
	{
		Component[] components = target.GetComponents<iTween>();
		return components.Length;
	}

	public static int Count(GameObject target, string type)
	{
		int num = 0;
		Component[] components = target.GetComponents<iTween>();
		components = components;
		for (int i = 0; i < components.Length; i++)
		{
			iTween iTween2 = (iTween)components[i];
			if ((iTween2.type + iTween2.method).Substring(0, type.Length).ToLower() == type.ToLower())
			{
				num++;
			}
		}
		return num;
	}

	public static void Stop()
	{
		for (int i = 0; i < tweens.Count; i++)
		{
			Stop((GameObject)tweens[i]["target"]);
		}
		tweens.Clear();
	}

	public static void Stop(string type)
	{
		ArrayList arrayList = new ArrayList();
		for (int i = 0; i < tweens.Count; i++)
		{
			GameObject value = (GameObject)tweens[i]["target"];
			arrayList.Insert(arrayList.Count, value);
		}
		for (int j = 0; j < arrayList.Count; j++)
		{
			Stop((GameObject)arrayList[j], type);
		}
	}

	public static void StopByName(string name)
	{
		ArrayList arrayList = new ArrayList();
		for (int i = 0; i < tweens.Count; i++)
		{
			GameObject value = (GameObject)tweens[i]["target"];
			arrayList.Insert(arrayList.Count, value);
		}
		for (int j = 0; j < arrayList.Count; j++)
		{
			StopByName((GameObject)arrayList[j], name);
		}
	}

	public static void Stop(GameObject target)
	{
		Component[] components = target.GetComponents<iTween>();
		components = components;
		for (int i = 0; i < components.Length; i++)
		{
			((iTween)components[i]).Dispose();
		}
	}

	public static void Stop(GameObject target, bool includechildren)
	{
		Stop(target);
		if (!includechildren)
		{
			return;
		}
		foreach (Transform item in target.transform)
		{
			Stop(item.gameObject, includechildren: true);
		}
	}

	public static void Stop(GameObject target, string type)
	{
		Component[] components = target.GetComponents<iTween>();
		components = components;
		for (int i = 0; i < components.Length; i++)
		{
			iTween iTween2 = (iTween)components[i];
			if ((iTween2.type + iTween2.method).Substring(0, type.Length).ToLower() == type.ToLower())
			{
				iTween2.Dispose();
			}
		}
	}

	public static void StopByName(GameObject target, string name)
	{
		Component[] components = target.GetComponents<iTween>();
		components = components;
		for (int i = 0; i < components.Length; i++)
		{
			iTween iTween2 = (iTween)components[i];
			if (iTween2._name == name)
			{
				iTween2.Dispose();
			}
		}
	}

	public static void Stop(GameObject target, string type, bool includechildren)
	{
		Component[] components = target.GetComponents<iTween>();
		components = components;
		for (int i = 0; i < components.Length; i++)
		{
			iTween iTween2 = (iTween)components[i];
			if ((iTween2.type + iTween2.method).Substring(0, type.Length).ToLower() == type.ToLower())
			{
				iTween2.Dispose();
			}
		}
		if (!includechildren)
		{
			return;
		}
		foreach (Transform item in target.transform)
		{
			Stop(item.gameObject, type, includechildren: true);
		}
	}

	public static void StopByName(GameObject target, string name, bool includechildren)
	{
		Component[] components = target.GetComponents<iTween>();
		components = components;
		for (int i = 0; i < components.Length; i++)
		{
			iTween iTween2 = (iTween)components[i];
			if (iTween2._name == name)
			{
				iTween2.Dispose();
			}
		}
		if (!includechildren)
		{
			return;
		}
		foreach (Transform item in target.transform)
		{
			StopByName(item.gameObject, name, includechildren: true);
		}
	}

	public static System.Collections.Hashtable Hash(params object[] args)
	{
		System.Collections.Hashtable hashtable = new System.Collections.Hashtable(args.Length / 2);
		if (args.Length % 2 != 0)
		{
			UnityEngine.Debug.LogError("Tween Error: Hash requires an even number of arguments!");
			return null;
		}
		for (int i = 0; i < args.Length - 1; i += 2)
		{
			hashtable.Add(args[i], args[i + 1]);
		}
		return hashtable;
	}

	private iTween(System.Collections.Hashtable h)
	{
		tweenArguments = h;
	}

	private void Awake()
	{
		thisTransform = base.transform;
		RetrieveArgs();
		lastRealTime = Time.realtimeSinceStartup;
	}

	private IEnumerator Start()
	{
		if (delay > 0f)
		{
			yield return StartCoroutine("TweenDelay");
		}
		TweenStart();
	}

	private void Update()
	{
		if (!isRunning || physics)
		{
			return;
		}
		if (!reverse)
		{
			if (percentage < 1f)
			{
				TweenUpdate();
			}
			else
			{
				TweenComplete();
			}
		}
		else if (percentage > 0f)
		{
			TweenUpdate();
		}
		else
		{
			TweenComplete();
		}
	}

	private void FixedUpdate()
	{
		if (!isRunning || !physics)
		{
			return;
		}
		if (!reverse)
		{
			if (percentage < 1f)
			{
				TweenUpdate();
			}
			else
			{
				TweenComplete();
			}
		}
		else if (percentage > 0f)
		{
			TweenUpdate();
		}
		else
		{
			TweenComplete();
		}
	}

	private void LateUpdate()
	{
		if (tweenArguments.Contains("looktarget") && isRunning && (type == "move" || type == "shake" || type == "punch"))
		{
			LookUpdate(base.gameObject, tweenArguments);
		}
	}

	private void OnEnable()
	{
		if (isRunning)
		{
			EnableKinematic();
		}
		if (isPaused)
		{
			isPaused = false;
			if (delay > 0f)
			{
				wasPaused = true;
				ResumeDelay();
			}
		}
	}

	private void OnDisable()
	{
		DisableKinematic();
	}

	private static void DrawLineHelper(Vector3[] line, Color color, string method)
	{
		Gizmos.color = color;
		for (int i = 0; i < line.Length - 1; i++)
		{
			if (method == "gizmos")
			{
				Gizmos.DrawLine(line[i], line[i + 1]);
			}
			else if (method == "handles")
			{
				UnityEngine.Debug.LogError("iTween Error: Drawing a line with Handles is temporarily disabled because of compatability issues with Unity 2.6!");
			}
		}
	}

	private static void DrawPathHelper(Vector3[] path, Color color, string method)
	{
		Vector3[] pts = PathControlPointGenerator(path);
		Vector3 to = Interp(pts, 0f);
		Gizmos.color = color;
		int num = path.Length * 20;
		for (int i = 1; i <= num; i++)
		{
			float t = (float)i / (float)num;
			Vector3 vector = Interp(pts, t);
			if (method == "gizmos")
			{
				Gizmos.DrawLine(vector, to);
			}
			else if (method == "handles")
			{
				UnityEngine.Debug.LogError("iTween Error: Drawing a path with Handles is temporarily disabled because of compatability issues with Unity 2.6!");
			}
			to = vector;
		}
	}

	private static Vector3[] PathControlPointGenerator(Vector3[] path)
	{
		int num = 2;
		Vector3[] array = new Vector3[path.Length + num];
		Array.Copy(path, 0, array, 1, path.Length);
		array[0] = array[1] + (array[1] - array[2]);
		array[^1] = array[^2] + (array[^2] - array[^3]);
		if (array[1] == array[^2])
		{
			Vector3[] array2 = new Vector3[array.Length];
			Array.Copy(array, array2, array.Length);
			array2[0] = array2[^3];
			array2[^1] = array2[2];
			array = new Vector3[array2.Length];
			Array.Copy(array2, array, array2.Length);
		}
		return array;
	}

	private static Vector3 Interp(Vector3[] pts, float t)
	{
		int num = pts.Length - 3;
		int num2 = Mathf.Min(Mathf.FloorToInt(t * (float)num), num - 1);
		float num3 = t * (float)num - (float)num2;
		Vector3 vector = pts[num2];
		Vector3 vector2 = pts[num2 + 1];
		Vector3 vector3 = pts[num2 + 2];
		Vector3 vector4 = pts[num2 + 3];
		return 0.5f * ((-vector + 3f * vector2 - 3f * vector3 + vector4) * (num3 * num3 * num3) + (2f * vector - 5f * vector2 + 4f * vector3 - vector4) * (num3 * num3) + (-vector + vector3) * num3 + 2f * vector2);
	}

	private static void Launch(GameObject target, System.Collections.Hashtable args)
	{
		if (!args.Contains("id"))
		{
			args["id"] = GenerateID();
		}
		if (!args.Contains("target"))
		{
			args["target"] = target;
		}
		tweens.Insert(0, args);
		target.AddComponent<iTween>();
	}

	private static System.Collections.Hashtable CleanArgs(System.Collections.Hashtable args)
	{
		System.Collections.Hashtable hashtable = new System.Collections.Hashtable(args.Count);
		System.Collections.Hashtable hashtable2 = new System.Collections.Hashtable(args.Count);
		foreach (DictionaryEntry arg in args)
		{
			hashtable.Add(arg.Key, arg.Value);
		}
		foreach (DictionaryEntry item in hashtable)
		{
			if (item.Value.GetType() == typeof(int))
			{
				float num = (int)item.Value;
				args[item.Key] = num;
			}
			if (item.Value.GetType() == typeof(double))
			{
				float num2 = (float)(double)item.Value;
				args[item.Key] = num2;
			}
		}
		foreach (DictionaryEntry arg2 in args)
		{
			hashtable2.Add(arg2.Key.ToString().ToLower(), arg2.Value);
		}
		args = hashtable2;
		return args;
	}

	private static string GenerateID()
	{
		return Guid.NewGuid().ToString();
	}

	private void RetrieveArgs()
	{
		foreach (System.Collections.Hashtable tween in tweens)
		{
			if ((GameObject)tween["target"] == base.gameObject)
			{
				tweenArguments = tween;
				break;
			}
		}
		id = (string)tweenArguments["id"];
		type = (string)tweenArguments["type"];
		_name = (string)tweenArguments["name"];
		method = (string)tweenArguments["method"];
		if (tweenArguments.Contains("time"))
		{
			time = (float)tweenArguments["time"];
		}
		else
		{
			time = Defaults.time;
		}
		if (GetComponent<Rigidbody>() != null)
		{
			physics = true;
		}
		if (tweenArguments.Contains("delay"))
		{
			delay = (float)tweenArguments["delay"];
		}
		else
		{
			delay = Defaults.delay;
		}
		if (tweenArguments.Contains("namedcolorvalue"))
		{
			if (tweenArguments["namedcolorvalue"].GetType() == typeof(NamedValueColor))
			{
				namedcolorvalue = (NamedValueColor)tweenArguments["namedcolorvalue"];
			}
			else
			{
				try
				{
					namedcolorvalue = (NamedValueColor)Enum.Parse(typeof(NamedValueColor), (string)tweenArguments["namedcolorvalue"], ignoreCase: true);
				}
				catch
				{
					UnityEngine.Debug.LogWarning("iTween: Unsupported namedcolorvalue supplied! Default will be used.");
					namedcolorvalue = NamedValueColor._Color;
				}
			}
		}
		else
		{
			namedcolorvalue = Defaults.namedColorValue;
		}
		if (tweenArguments.Contains("looptype"))
		{
			if (tweenArguments["looptype"].GetType() == typeof(LoopType))
			{
				loopType = (LoopType)tweenArguments["looptype"];
			}
			else
			{
				try
				{
					loopType = (LoopType)Enum.Parse(typeof(LoopType), (string)tweenArguments["looptype"], ignoreCase: true);
				}
				catch
				{
					UnityEngine.Debug.LogWarning("iTween: Unsupported loopType supplied! Default will be used.");
					loopType = LoopType.none;
				}
			}
		}
		else
		{
			loopType = LoopType.none;
		}
		if (tweenArguments.Contains("easetype"))
		{
			if (tweenArguments["easetype"].GetType() == typeof(EaseType))
			{
				easeType = (EaseType)tweenArguments["easetype"];
			}
			else
			{
				try
				{
					easeType = (EaseType)Enum.Parse(typeof(EaseType), (string)tweenArguments["easetype"], ignoreCase: true);
				}
				catch
				{
					UnityEngine.Debug.LogWarning("iTween: Unsupported easeType supplied! Default will be used.");
					easeType = Defaults.easeType;
				}
			}
		}
		else
		{
			easeType = Defaults.easeType;
		}
		if (tweenArguments.Contains("space"))
		{
			if (tweenArguments["space"].GetType() == typeof(Space))
			{
				space = (Space)tweenArguments["space"];
			}
			else
			{
				try
				{
					space = (Space)Enum.Parse(typeof(Space), (string)tweenArguments["space"], ignoreCase: true);
				}
				catch
				{
					UnityEngine.Debug.LogWarning("iTween: Unsupported space supplied! Default will be used.");
					space = Defaults.space;
				}
			}
		}
		else
		{
			space = Defaults.space;
		}
		if (tweenArguments.Contains("islocal"))
		{
			isLocal = (bool)tweenArguments["islocal"];
		}
		else
		{
			isLocal = Defaults.isLocal;
		}
		if (tweenArguments.Contains("ignoretimescale"))
		{
			useRealTime = (bool)tweenArguments["ignoretimescale"];
		}
		else
		{
			useRealTime = Defaults.useRealTime;
		}
		GetEasingFunction();
	}

	private void GetEasingFunction()
	{
		switch (easeType)
		{
		case EaseType.easeInQuad:
			ease = easeInQuad;
			break;
		case EaseType.easeOutQuad:
			ease = easeOutQuad;
			break;
		case EaseType.easeInOutQuad:
			ease = easeInOutQuad;
			break;
		case EaseType.easeInCubic:
			ease = easeInCubic;
			break;
		case EaseType.easeOutCubic:
			ease = easeOutCubic;
			break;
		case EaseType.easeInOutCubic:
			ease = easeInOutCubic;
			break;
		case EaseType.easeInQuart:
			ease = easeInQuart;
			break;
		case EaseType.easeOutQuart:
			ease = easeOutQuart;
			break;
		case EaseType.easeInOutQuart:
			ease = easeInOutQuart;
			break;
		case EaseType.easeInQuint:
			ease = easeInQuint;
			break;
		case EaseType.easeOutQuint:
			ease = easeOutQuint;
			break;
		case EaseType.easeInOutQuint:
			ease = easeInOutQuint;
			break;
		case EaseType.easeInSine:
			ease = easeInSine;
			break;
		case EaseType.easeOutSine:
			ease = easeOutSine;
			break;
		case EaseType.easeInOutSine:
			ease = easeInOutSine;
			break;
		case EaseType.easeInExpo:
			ease = easeInExpo;
			break;
		case EaseType.easeOutExpo:
			ease = easeOutExpo;
			break;
		case EaseType.easeInOutExpo:
			ease = easeInOutExpo;
			break;
		case EaseType.easeInCirc:
			ease = easeInCirc;
			break;
		case EaseType.easeOutCirc:
			ease = easeOutCirc;
			break;
		case EaseType.easeInOutCirc:
			ease = easeInOutCirc;
			break;
		case EaseType.linear:
			ease = linear;
			break;
		case EaseType.spring:
			ease = spring;
			break;
		case EaseType.easeInBounce:
			ease = easeInBounce;
			break;
		case EaseType.easeOutBounce:
			ease = easeOutBounce;
			break;
		case EaseType.easeInOutBounce:
			ease = easeInOutBounce;
			break;
		case EaseType.easeInBack:
			ease = easeInBack;
			break;
		case EaseType.easeOutBack:
			ease = easeOutBack;
			break;
		case EaseType.easeInOutBack:
			ease = easeInOutBack;
			break;
		case EaseType.easeInElastic:
			ease = easeInElastic;
			break;
		case EaseType.easeOutElastic:
			ease = easeOutElastic;
			break;
		case EaseType.easeInOutElastic:
			ease = easeInOutElastic;
			break;
		}
	}

	private void UpdatePercentage()
	{
		if (useRealTime)
		{
			runningTime += Time.realtimeSinceStartup - lastRealTime;
		}
		else
		{
			runningTime += Time.deltaTime;
		}
		if (reverse)
		{
			percentage = 1f - runningTime / time;
		}
		else
		{
			percentage = runningTime / time;
		}
		lastRealTime = Time.realtimeSinceStartup;
	}

	private void CallBack(string callbackType)
	{
		if (tweenArguments.Contains(callbackType) && !tweenArguments.Contains("ischild"))
		{
			GameObject gameObject = ((!tweenArguments.Contains(callbackType + "target")) ? base.gameObject : ((GameObject)tweenArguments[callbackType + "target"]));
			if (tweenArguments[callbackType].GetType() == typeof(string))
			{
				gameObject.SendMessage((string)tweenArguments[callbackType], tweenArguments[callbackType + "params"], SendMessageOptions.DontRequireReceiver);
				return;
			}
			UnityEngine.Debug.LogError("iTween Error: Callback method references must be passed as a String!");
			UnityEngine.Object.Destroy(this);
		}
	}

	private void Dispose()
	{
		for (int i = 0; i < tweens.Count; i++)
		{
			if ((string)tweens[i]["id"] == id)
			{
				tweens.RemoveAt(i);
				break;
			}
		}
		UnityEngine.Object.Destroy(this);
	}

	private void ConflictCheck()
	{
		Component[] components = GetComponents<iTween>();
		components = components;
		for (int i = 0; i < components.Length; i++)
		{
			iTween iTween2 = (iTween)components[i];
			if (iTween2.type == "value")
			{
				break;
			}
			if (!iTween2.isRunning || !(iTween2.type == type))
			{
				continue;
			}
			if (iTween2.method != method)
			{
				break;
			}
			if (iTween2.tweenArguments.Count != tweenArguments.Count)
			{
				iTween2.Dispose();
				break;
			}
			foreach (DictionaryEntry tweenArgument in tweenArguments)
			{
				if (!iTween2.tweenArguments.Contains(tweenArgument.Key))
				{
					iTween2.Dispose();
					return;
				}
				if (!iTween2.tweenArguments[tweenArgument.Key].Equals(tweenArguments[tweenArgument.Key]) && (string)tweenArgument.Key != "id")
				{
					iTween2.Dispose();
					return;
				}
			}
			Dispose();
		}
	}

	private void EnableKinematic()
	{
	}

	private void DisableKinematic()
	{
	}

	private void ResumeDelay()
	{
		StartCoroutine("TweenDelay");
	}

	private float linear(float start, float end, float value)
	{
		return Mathf.Lerp(start, end, value);
	}

	private float clerp(float start, float end, float value)
	{
		float num = 0f;
		float num2 = 360f;
		float num3 = Mathf.Abs((num2 - num) * 0.5f);
		float num4 = 0f;
		float num5 = 0f;
		if (end - start < 0f - num3)
		{
			num5 = (num2 - start + end) * value;
			return start + num5;
		}
		if (end - start > num3)
		{
			num5 = (0f - (num2 - end + start)) * value;
			return start + num5;
		}
		return start + (end - start) * value;
	}

	private float spring(float start, float end, float value)
	{
		value = Mathf.Clamp01(value);
		value = (Mathf.Sin(value * (float)Math.PI * (0.2f + 2.5f * value * value * value)) * Mathf.Pow(1f - value, 2.2f) + value) * (1f + 1.2f * (1f - value));
		return start + (end - start) * value;
	}

	private float easeInQuad(float start, float end, float value)
	{
		end -= start;
		return end * value * value + start;
	}

	private float easeOutQuad(float start, float end, float value)
	{
		end -= start;
		return (0f - end) * value * (value - 2f) + start;
	}

	private float easeInOutQuad(float start, float end, float value)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return end * 0.5f * value * value + start;
		}
		value -= 1f;
		return (0f - end) * 0.5f * (value * (value - 2f) - 1f) + start;
	}

	private float easeInCubic(float start, float end, float value)
	{
		end -= start;
		return end * value * value * value + start;
	}

	private float easeOutCubic(float start, float end, float value)
	{
		value -= 1f;
		end -= start;
		return end * (value * value * value + 1f) + start;
	}

	private float easeInOutCubic(float start, float end, float value)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return end * 0.5f * value * value * value + start;
		}
		value -= 2f;
		return end * 0.5f * (value * value * value + 2f) + start;
	}

	private float easeInQuart(float start, float end, float value)
	{
		end -= start;
		return end * value * value * value * value + start;
	}

	private float easeOutQuart(float start, float end, float value)
	{
		value -= 1f;
		end -= start;
		return (0f - end) * (value * value * value * value - 1f) + start;
	}

	private float easeInOutQuart(float start, float end, float value)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return end * 0.5f * value * value * value * value + start;
		}
		value -= 2f;
		return (0f - end) * 0.5f * (value * value * value * value - 2f) + start;
	}

	private float easeInQuint(float start, float end, float value)
	{
		end -= start;
		return end * value * value * value * value * value + start;
	}

	private float easeOutQuint(float start, float end, float value)
	{
		value -= 1f;
		end -= start;
		return end * (value * value * value * value * value + 1f) + start;
	}

	private float easeInOutQuint(float start, float end, float value)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return end * 0.5f * value * value * value * value * value + start;
		}
		value -= 2f;
		return end * 0.5f * (value * value * value * value * value + 2f) + start;
	}

	private float easeInSine(float start, float end, float value)
	{
		end -= start;
		return (0f - end) * Mathf.Cos(value * ((float)Math.PI / 2f)) + end + start;
	}

	private float easeOutSine(float start, float end, float value)
	{
		end -= start;
		return end * Mathf.Sin(value * ((float)Math.PI / 2f)) + start;
	}

	private float easeInOutSine(float start, float end, float value)
	{
		end -= start;
		return (0f - end) * 0.5f * (Mathf.Cos((float)Math.PI * value) - 1f) + start;
	}

	private float easeInExpo(float start, float end, float value)
	{
		end -= start;
		return end * Mathf.Pow(2f, 10f * (value - 1f)) + start;
	}

	private float easeOutExpo(float start, float end, float value)
	{
		end -= start;
		return end * (0f - Mathf.Pow(2f, -10f * value) + 1f) + start;
	}

	private float easeInOutExpo(float start, float end, float value)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return end * 0.5f * Mathf.Pow(2f, 10f * (value - 1f)) + start;
		}
		value -= 1f;
		return end * 0.5f * (0f - Mathf.Pow(2f, -10f * value) + 2f) + start;
	}

	private float easeInCirc(float start, float end, float value)
	{
		end -= start;
		return (0f - end) * (Mathf.Sqrt(1f - value * value) - 1f) + start;
	}

	private float easeOutCirc(float start, float end, float value)
	{
		value -= 1f;
		end -= start;
		return end * Mathf.Sqrt(1f - value * value) + start;
	}

	private float easeInOutCirc(float start, float end, float value)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return (0f - end) * 0.5f * (Mathf.Sqrt(1f - value * value) - 1f) + start;
		}
		value -= 2f;
		return end * 0.5f * (Mathf.Sqrt(1f - value * value) + 1f) + start;
	}

	private float easeInBounce(float start, float end, float value)
	{
		end -= start;
		float num = 1f;
		return end - easeOutBounce(0f, end, num - value) + start;
	}

	private float easeOutBounce(float start, float end, float value)
	{
		value /= 1f;
		end -= start;
		if (value < 0.36363637f)
		{
			return end * (7.5625f * value * value) + start;
		}
		if (value < 0.72727275f)
		{
			value -= 0.54545456f;
			return end * (7.5625f * value * value + 0.75f) + start;
		}
		if ((double)value < 0.9090909090909091)
		{
			value -= 0.8181818f;
			return end * (7.5625f * value * value + 0.9375f) + start;
		}
		value -= 21f / 22f;
		return end * (7.5625f * value * value + 63f / 64f) + start;
	}

	private float easeInOutBounce(float start, float end, float value)
	{
		end -= start;
		float num = 1f;
		if (value < num * 0.5f)
		{
			return easeInBounce(0f, end, value * 2f) * 0.5f + start;
		}
		return easeOutBounce(0f, end, value * 2f - num) * 0.5f + end * 0.5f + start;
	}

	private float easeInBack(float start, float end, float value)
	{
		end -= start;
		value /= 1f;
		float num = 1.70158f;
		return end * value * value * ((num + 1f) * value - num) + start;
	}

	private float easeOutBack(float start, float end, float value)
	{
		float num = 1.70158f;
		end -= start;
		value -= 1f;
		return end * (value * value * ((num + 1f) * value + num) + 1f) + start;
	}

	private float easeInOutBack(float start, float end, float value)
	{
		float num = 1.70158f;
		end -= start;
		value /= 0.5f;
		if (value < 1f)
		{
			num *= 1.525f;
			return end * 0.5f * (value * value * ((num + 1f) * value - num)) + start;
		}
		value -= 2f;
		num *= 1.525f;
		return end * 0.5f * (value * value * ((num + 1f) * value + num) + 2f) + start;
	}

	private float punch(float amplitude, float value)
	{
		float num = 9f;
		if (value == 0f)
		{
			return 0f;
		}
		if (value == 1f)
		{
			return 0f;
		}
		float num2 = 0.3f;
		num = num2 / ((float)Math.PI * 2f) * Mathf.Asin(0f);
		return amplitude * Mathf.Pow(2f, -10f * value) * Mathf.Sin((value * 1f - num) * ((float)Math.PI * 2f) / num2);
	}

	private float easeInElastic(float start, float end, float value)
	{
		end -= start;
		float num = 1f;
		float num2 = num * 0.3f;
		float num3 = 0f;
		float num4 = 0f;
		if (value == 0f)
		{
			return start;
		}
		if ((value /= num) == 1f)
		{
			return start + end;
		}
		if (num4 == 0f || num4 < Mathf.Abs(end))
		{
			num4 = end;
			num3 = num2 / 4f;
		}
		else
		{
			num3 = num2 / ((float)Math.PI * 2f) * Mathf.Asin(end / num4);
		}
		return 0f - num4 * Mathf.Pow(2f, 10f * (value -= 1f)) * Mathf.Sin((value * num - num3) * ((float)Math.PI * 2f) / num2) + start;
	}

	private float easeOutElastic(float start, float end, float value)
	{
		end -= start;
		float num = 1f;
		float num2 = num * 0.3f;
		float num3 = 0f;
		float num4 = 0f;
		if (value == 0f)
		{
			return start;
		}
		if ((value /= num) == 1f)
		{
			return start + end;
		}
		if (num4 == 0f || num4 < Mathf.Abs(end))
		{
			num4 = end;
			num3 = num2 * 0.25f;
		}
		else
		{
			num3 = num2 / ((float)Math.PI * 2f) * Mathf.Asin(end / num4);
		}
		return num4 * Mathf.Pow(2f, -10f * value) * Mathf.Sin((value * num - num3) * ((float)Math.PI * 2f) / num2) + end + start;
	}

	private float easeInOutElastic(float start, float end, float value)
	{
		end -= start;
		float num = 1f;
		float num2 = num * 0.3f;
		float num3 = 0f;
		float num4 = 0f;
		if (value == 0f)
		{
			return start;
		}
		if ((value /= num * 0.5f) == 2f)
		{
			return start + end;
		}
		if (num4 == 0f || num4 < Mathf.Abs(end))
		{
			num4 = end;
			num3 = num2 / 4f;
		}
		else
		{
			num3 = num2 / ((float)Math.PI * 2f) * Mathf.Asin(end / num4);
		}
		if (value < 1f)
		{
			return -0.5f * (num4 * Mathf.Pow(2f, 10f * (value -= 1f)) * Mathf.Sin((value * num - num3) * ((float)Math.PI * 2f) / num2)) + start;
		}
		return num4 * Mathf.Pow(2f, -10f * (value -= 1f)) * Mathf.Sin((value * num - num3) * ((float)Math.PI * 2f) / num2) * 0.5f + end + start;
	}

	public static Vector3[] InterpPath(Vector3[] path)
	{
		Vector3[] pts = PathControlPointGenerator(path);
		List<Vector3> list = new List<Vector3>();
		Vector3 item = Interp(pts, 0f);
		list.Add(item);
		int num = path.Length * 20;
		for (int i = 1; i <= num; i++)
		{
			float t = (float)i / (float)num;
			Vector3 item2 = Interp(pts, t);
			list.Add(item2);
		}
		return list.ToArray();
	}
}
public class ActiveSyncScript : MonoBehaviour, IPunObservable
{
	public List<GameObject> targets = new List<GameObject>();

	public void OnPhotonSerializeView(PhotonStream stream, PhotonMessageInfo info)
	{
		if (stream.IsWriting)
		{
			for (int i = 0; i < targets.Count; i++)
			{
				stream.SendNext(targets[i].activeSelf);
			}
		}
		else
		{
			for (int j = 0; j < targets.Count; j++)
			{
				targets[j].SetActive((bool)stream.ReceiveNext());
			}
		}
	}
}
public class PhotonSyncScript : MonoBehaviourPun, IPunObservable
{
	public enum SyncType
	{
		ST_NetWork = 1,
		ST_MasterClient
	}

	public SyncType syncType = SyncType.ST_NetWork;

	public bool isSyncPostion;

	public bool isSyncRotation;

	public bool isLerp = true;

	private bool m_active;

	private Vector3 m_position;

	private Quaternion m_rotation;

	private float lerpSpeed = 10f;

	private void Start()
	{
		m_position = base.transform.position;
		m_rotation = base.transform.rotation;
	}

	private void Update()
	{
		if (!PhotonNetwork.IsConnected)
		{
			return;
		}
		if (syncType == SyncType.ST_NetWork)
		{
			if (!base.photonView.IsMine)
			{
				SyncData();
			}
		}
		else if (syncType == SyncType.ST_MasterClient && !PhotonNetwork.IsMasterClient)
		{
			SyncData();
		}
	}

	public void OnPhotonSerializeView(PhotonStream stream, PhotonMessageInfo info)
	{
		if (syncType == SyncType.ST_NetWork)
		{
			if (stream.IsWriting)
			{
				if (isSyncPostion)
				{
					stream.SendNext(base.transform.position);
				}
				if (isSyncRotation)
				{
					stream.SendNext(base.transform.rotation);
				}
			}
			else
			{
				if (isSyncPostion)
				{
					m_position = (Vector3)stream.ReceiveNext();
				}
				if (isSyncRotation)
				{
					m_rotation = (Quaternion)stream.ReceiveNext();
				}
			}
		}
		else
		{
			if (syncType != SyncType.ST_MasterClient)
			{
				return;
			}
			if (PhotonNetwork.IsMasterClient)
			{
				if (isSyncPostion)
				{
					stream.SendNext(base.transform.position);
				}
				if (isSyncRotation)
				{
					stream.SendNext(base.transform.rotation);
				}
			}
			else
			{
				if (isSyncPostion)
				{
					m_position = (Vector3)stream.ReceiveNext();
				}
				if (isSyncRotation)
				{
					m_rotation = (Quaternion)stream.ReceiveNext();
				}
			}
		}
	}

	private void SyncData()
	{
		if (isSyncPostion)
		{
			if (isLerp)
			{
				base.transform.position = Vector3.Lerp(base.transform.position, m_position, Time.deltaTime * lerpSpeed);
			}
			else
			{
				base.transform.position = m_position;
			}
		}
		if (isSyncRotation)
		{
			if (isLerp)
			{
				base.transform.rotation = Quaternion.Lerp(base.transform.rotation, m_rotation, Time.deltaTime * lerpSpeed);
			}
			else
			{
				base.transform.rotation = m_rotation;
			}
		}
	}
}
public class ScenePhotonController : MonoBehaviourPunCallbacks, IPunObservable
{
	public static ScenePhotonController _instance;

	[Header("玩家位置")]
	public Transform playerRig;

	public Transform[] playerPos;

	[Header("头部模型")]
	public string[] headPrefabNames;

	public Transform playerHead;

	[Header("关卡预制体")]
	public string levelPrefabName;

	public Transform levelParent;

	private VRCheckPointController _levelController;

	public static ScenePhotonController Instance
	{
		get
		{
			if (_instance == null)
			{
				_instance = UnityEngine.Object.FindObjectOfType(typeof(ScenePhotonController)) as ScenePhotonController;
			}
			return _instance;
		}
	}

	public VRCheckPointController LevelController
	{
		get
		{
			if (_levelController == null)
			{
				_levelController = UnityEngine.Object.FindObjectOfType(typeof(VRCheckPointController)) as VRCheckPointController;
			}
			return _levelController;
		}
	}

	private void Awake()
	{
		if (VRGameSystem.CurGameModel != 0)
		{
			CreatPlayerHead();
		}
	}

	private void CreatPlayerHead()
	{
		GameObject obj = PhotonNetwork.Instantiate(headPrefabNames[UnityEngine.Random.Range(0, headPrefabNames.Length)], Vector3.zero, Quaternion.identity, 0);
		obj.transform.SetParent(playerHead);
		obj.transform.localRotation = Quaternion.identity;
		obj.transform.localPosition = Vector3.zero;
		Player[] playerList = PhotonNetwork.PlayerList;
		for (int i = 0; i < playerList.Length; i++)
		{
			if (playerList[i].IsLocal)
			{
				playerRig.position = playerPos[i].position;
			}
		}
	}

	public void InitLevel()
	{
		if (PhotonNetwork.IsMasterClient)
		{
			PhotonNetwork.Instantiate(levelPrefabName, Vector3.zero, Quaternion.identity, 0).transform.SetParent(levelParent);
		}
	}

	public void OnPhotonSerializeView(PhotonStream stream, PhotonMessageInfo info)
	{
	}
}
public class VRGrabCrossBow : VR_GrabbedWeapon
{
	private float collisionForce = 800f;

	private void Awake()
	{
		if (VRGameSystem.CurGameModel != GameModel.GM_Multi || photonView.IsMine)
		{
			loadData();
		}
	}

	public override void Vibrate()
	{
		if (VRGameSystem.CurGameModel != GameModel.GM_Multi || photonView.IsMine)
		{
			base.Vibrate();
		}
	}

	protected override void loadData()
	{
		if (VRGameSystem.CurGameModel != GameModel.GM_Multi || photonView.IsMine)
		{
			base.loadData();
		}
	}
}
public class VRGrabLongBow : VR_GrabbedWeapon
{
	public float impactMagnifier = 1000f;

	public int vibrateDuration = 1;

	private float collisionForce;

	private void Awake()
	{
		if (VRGameSystem.CurGameModel != GameModel.GM_Multi || photonView.IsMine)
		{
			loadData();
		}
	}

	public void Vibrate(float fDist)
	{
		if ((VRGameSystem.CurGameModel != GameModel.GM_Multi || photonView.IsMine) && base.IsEquip)
		{
			collisionForce = fDist * impactMagnifier;
		}
	}
}
public class VR_GrabbedWeapon : MonoBehaviour
{
	public PhotonView photonView;

	public Transform grabPos;

	public bool rayIsShow;

	[Header("武器默认放置在哪个手（0：左手；1：右手）")]
	public XRDeviceType weaponHand = XRDeviceType.DT_Right;

	[Header("射击的触发键")]
	public XRDeviceKeyStruct shootKey;

	[Header("武器特效的触发键")]
	public XRDeviceKeyStruct effectKey;

	[SerializeField]
	protected UnityXR_AxisHandler effectKeyHandler;

	[SerializeField]
	protected UnityXR_InputHandler shootKeyHandler;

	public Vector3 equipRotation;

	public bool IsEquip { get; private set; }

	public virtual void Equip()
	{
		IsEquip = true;
		Transform parent = UnityXR_Controller.Instance.HandleSys.GetTransform(weaponHand);
		grabPos.SetParent(parent);
		grabPos.localPosition = Vector3.zero;
		grabPos.localRotation = Quaternion.Euler(equipRotation.x, equipRotation.y, equipRotation.z);
		grabPos.gameObject.SetActive(value: true);
	}

	public virtual void Unwield(Transform parent)
	{
		IsEquip = false;
		grabPos.SetParent(parent);
		grabPos.gameObject.SetActive(value: false);
	}

	public virtual bool InReadyShoot()
	{
		if (VRGameSystem.CurGameModel == GameModel.GM_Multi && !photonView.IsMine)
		{
			return false;
		}
		if ((object)effectKeyHandler != null)
		{
			return effectKeyHandler.PressValue > 0.5f;
		}
		return false;
	}

	public virtual bool IsShoot()
	{
		if (VRGameSystem.CurGameModel == GameModel.GM_Multi && !photonView.IsMine)
		{
			return false;
		}
		if ((object)shootKeyHandler != null)
		{
			return (shootKeyHandler as UnityXR_ButtonHandler).IsUplift;
		}
		return false;
	}

	public virtual void Vibrate()
	{
		if ((VRGameSystem.CurGameModel != GameModel.GM_Multi || photonView.IsMine) && IsEquip)
		{
			UnityXR_Controller.Instance.HandleSys.HapticPulse(weaponHand, 0.8f, 0.3f);
		}
	}

	public virtual void AllHandVibrate()
	{
		if ((VRGameSystem.CurGameModel != GameModel.GM_Multi || photonView.IsMine) && IsEquip)
		{
			UnityXR_Controller.Instance.HandleSys.HapticPulse(XRDeviceType.DT_Left, 0.8f, 0.3f);
			UnityXR_Controller.Instance.HandleSys.HapticPulse(XRDeviceType.DT_Right, 0.8f, 0.3f);
		}
	}

	protected virtual void loadData()
	{
		if (VRGameSystem.CurGameModel != GameModel.GM_Multi || photonView.IsMine)
		{
			if (UnityXR_Controller.Instance.InputSys.GetInputHandler(effectKey.deviceType, effectKey.keyType) is UnityXR_AxisHandler)
			{
				effectKeyHandler = UnityXR_Controller.Instance.InputSys.GetInputHandler(effectKey.deviceType, effectKey.keyType) as UnityXR_AxisHandler;
			}
			else
			{
				UnityEngine.Debug.LogError(string.Concat(base.gameObject.name, "“武器射击”的按键种类当前为：", effectKey.keyType, "；此类型不是Axis输入事件"));
			}
			if ((bool)UnityXR_Controller.Instance.InputSys.GetInputHandler(shootKey.deviceType, shootKey.keyType))
			{
				shootKeyHandler = UnityXR_Controller.Instance.InputSys.GetInputHandler(shootKey.deviceType, shootKey.keyType);
				return;
			}
			UnityEngine.Debug.LogError(string.Concat(base.gameObject.name, "“武器射击开火”的按键种类当前为：", shootKey.keyType, "；此类型不是button输入事件"));
		}
	}
}
public class ShootArrow : MonoBehaviour
{
	public VRBulletPhysic arrow;

	public float speed = 100f;

	public Transform targetPos;

	public int type;

	public VRBulletPhysic curArrow;

	public VRNpc npc;

	public void Update()
	{
		if (Input.GetKeyDown(KeyCode.Space))
		{
			curArrow = UnityEngine.Object.Instantiate(arrow);
			curArrow.transform.position = targetPos.position;
			curArrow.transform.rotation = targetPos.rotation;
		}
		else if (Input.GetKeyDown(KeyCode.J) && (bool)curArrow)
		{
			Vector3 inPos = curArrow.transform.position;
			Vector3 inDir = curArrow.transform.forward;
			curArrow.fire(ref inPos, ref inDir, 2f, speed, EU_CAMP.EU_BAD, npc);
		}
	}
}
public class TestArrow : MonoBehaviour
{
	public Rigidbody rig;

	public float disappearTime = 5f;

	public void Fire(int type, float speed)
	{
		if ((bool)rig)
		{
			rig.useGravity = true;
			rig.isKinematic = false;
			if (type == 0)
			{
				rig.AddForce(base.transform.forward * speed, ForceMode.Impulse);
			}
			else
			{
				rig.velocity = base.transform.forward * speed;
			}
			CancelInvoke("DestroyStillBullet");
			Invoke("DestroyStillBullet", disappearTime);
		}
	}

	private void OnCollisionEnter(Collision otherobj)
	{
		if (otherobj.gameObject.tag == "terrain")
		{
			UnityEngine.Debug.LogError("碰到了地形：" + otherobj.gameObject.name);
			if ((bool)rig)
			{
				rig.Sleep();
				rig.useGravity = false;
				rig.detectCollisions = false;
			}
		}
	}

	private void DestroyStillBullet()
	{
		UnityEngine.Object.Destroy(base.gameObject);
	}
}
public class DecalDestroyer : MonoBehaviour
{
	public float lifeTime = 5f;

	private IEnumerator Start()
	{
		yield return new WaitForSeconds(lifeTime);
		UnityEngine.Object.Destroy(base.gameObject);
	}
}
public class ExtinguishableFire : MonoBehaviour
{
	public ParticleSystem fireParticleSystem;

	public ParticleSystem smokeParticleSystem;

	protected bool m_isExtinguished;

	private const float m_FireStartingTime = 2f;

	private void Start()
	{
		m_isExtinguished = true;
		smokeParticleSystem.Stop();
		fireParticleSystem.Stop();
		StartCoroutine(StartingFire());
	}

	public void Extinguish()
	{
		if (!m_isExtinguished)
		{
			m_isExtinguished = true;
			StartCoroutine(Extinguishing());
		}
	}

	private IEnumerator Extinguishing()
	{
		fireParticleSystem.Stop();
		smokeParticleSystem.time = 0f;
		smokeParticleSystem.Play();
		for (float elapsedTime = 0f; elapsedTime < 2f; elapsedTime += Time.deltaTime)
		{
			float num = Mathf.Max(0f, 1f - elapsedTime / 2f);
			fireParticleSystem.transform.localScale = Vector3.one * num;
			yield return null;
		}
		yield return new WaitForSeconds(2f);
		smokeParticleSystem.Stop();
		fireParticleSystem.transform.localScale = Vector3.one;
		yield return new WaitForSeconds(4f);
		StartCoroutine(StartingFire());
	}

	private IEnumerator StartingFire()
	{
		smokeParticleSystem.Stop();
		fireParticleSystem.time = 0f;
		fireParticleSystem.Play();
		for (float elapsedTime = 0f; elapsedTime < 2f; elapsedTime += Time.deltaTime)
		{
			float num = Mathf.Min(1f, elapsedTime / 2f);
			fireParticleSystem.transform.localScale = Vector3.one * num;
			yield return null;
		}
		fireParticleSystem.transform.localScale = Vector3.one;
		m_isExtinguished = false;
	}
}
public class GunAim : MonoBehaviour
{
	public int borderLeft;

	public int borderRight;

	public int borderTop;

	public int borderBottom;

	private Camera parentCamera;

	private bool isOutOfBounds;

	private void Start()
	{
		parentCamera = GetComponentInParent<Camera>();
	}

	private void Update()
	{
		float x = Input.mousePosition.x;
		float y = Input.mousePosition.y;
		if (x <= (float)borderLeft || x >= (float)(Screen.width - borderRight) || y <= (float)borderBottom || y >= (float)(Screen.height - borderTop))
		{
			isOutOfBounds = true;
		}
		else
		{
			isOutOfBounds = false;
		}
		if (!isOutOfBounds)
		{
			base.transform.LookAt(parentCamera.ScreenToWorldPoint(new Vector3(x, y, 5f)));
		}
	}

	public bool GetIsOutOfBounds()
	{
		return isOutOfBounds;
	}
}
public class GunShoot : MonoBehaviour
{
	public float fireRate = 0.25f;

	public float weaponRange = 20f;

	public Transform gunEnd;

	public ParticleSystem muzzleFlash;

	public ParticleSystem cartridgeEjection;

	public GameObject metalHitEffect;

	public GameObject sandHitEffect;

	public GameObject stoneHitEffect;

	public GameObject waterLeakEffect;

	public GameObject waterLeakExtinguishEffect;

	public GameObject[] fleshHitEffects;

	public GameObject woodHitEffect;

	private float nextFire;

	private Animator anim;

	private GunAim gunAim;

	private void Start()
	{
		anim = GetComponent<Animator>();
		gunAim = GetComponentInParent<GunAim>();
	}

	private void Update()
	{
		if (Input.GetButtonDown("Fire1") && Time.time > nextFire && !gunAim.GetIsOutOfBounds())
		{
			nextFire = Time.time + fireRate;
			muzzleFlash.Play();
			cartridgeEjection.Play();
			anim.SetTrigger("Fire");
			if (Physics.Raycast(gunEnd.position, gunEnd.forward, out var hitInfo, weaponRange))
			{
				HandleHit(hitInfo);
			}
		}
	}

	private void HandleHit(RaycastHit hit)
	{
		if (hit.collider.sharedMaterial != null)
		{
			switch (hit.collider.sharedMaterial.name)
			{
			case "Metal":
				SpawnDecal(hit, metalHitEffect);
				break;
			case "Sand":
				SpawnDecal(hit, sandHitEffect);
				break;
			case "Stone":
				SpawnDecal(hit, stoneHitEffect);
				break;
			case "WaterFilled":
				SpawnDecal(hit, waterLeakEffect);
				SpawnDecal(hit, metalHitEffect);
				break;
			case "Wood":
				SpawnDecal(hit, woodHitEffect);
				break;
			case "Meat":
				SpawnDecal(hit, fleshHitEffects[UnityEngine.Random.Range(0, fleshHitEffects.Length)]);
				break;
			case "Character":
				SpawnDecal(hit, fleshHitEffects[UnityEngine.Random.Range(0, fleshHitEffects.Length)]);
				break;
			case "WaterFilledExtinguish":
				SpawnDecal(hit, waterLeakExtinguishEffect);
				SpawnDecal(hit, metalHitEffect);
				break;
			}
		}
	}

	private void SpawnDecal(RaycastHit hit, GameObject prefab)
	{
		UnityEngine.Object.Instantiate(prefab, hit.point, Quaternion.LookRotation(hit.normal)).transform.SetParent(hit.collider.transform);
	}
}
public class ParticleCollision : MonoBehaviour
{
	private List<ParticleCollisionEvent> m_CollisionEvents = new List<ParticleCollisionEvent>();

	private ParticleSystem m_ParticleSystem;

	private void Start()
	{
		m_ParticleSystem = GetComponent<ParticleSystem>();
	}

	private void OnParticleCollision(GameObject other)
	{
		int collisionEvents = m_ParticleSystem.GetCollisionEvents(other, m_CollisionEvents);
		for (int i = 0; i < collisionEvents; i++)
		{
			ExtinguishableFire component = m_CollisionEvents[i].colliderComponent.GetComponent<ExtinguishableFire>();
			if (component != null)
			{
				component.Extinguish();
			}
		}
	}
}
[Serializable]
public class ParticleExamples
{
	public string title;

	[TextArea]
	public string description;

	public bool isWeaponEffect;

	public GameObject particleSystemGO;

	public Vector3 particlePosition;

	public Vector3 particleRotation;
}
public class ParticleMenu : MonoBehaviour
{
	public ParticleExamples[] particleSystems;

	public GameObject gunGameObject;

	private int currentIndex;

	private GameObject currentGO;

	public Transform spawnLocation;

	public Text title;

	public Text description;

	public Text navigationDetails;

	private void Start()
	{
		Navigate(0);
		currentIndex = 0;
	}

	public void Navigate(int i)
	{
		currentIndex = (particleSystems.Length + currentIndex + i) % particleSystems.Length;
		if (currentGO != null)
		{
			UnityEngine.Object.Destroy(currentGO);
		}
		currentGO = UnityEngine.Object.Instantiate(particleSystems[currentIndex].particleSystemGO, spawnLocation.position + particleSystems[currentIndex].particlePosition, Quaternion.Euler(particleSystems[currentIndex].particleRotation));
		gunGameObject.SetActive(particleSystems[currentIndex].isWeaponEffect);
		title.text = particleSystems[currentIndex].title;
		description.text = particleSystems[currentIndex].description;
		navigationDetails.text = currentIndex + 1 + " out of " + particleSystems.Length.ToString();
	}
}
public class Readme : ScriptableObject
{
	[Serializable]
	public class Section
	{
		public string heading;

		public string text;

		public string linkText;

		public string url;
	}

	public Texture2D icon;

	public string title;

	public Section[] sections;

	public bool loadedLayout;
}
public class TorchSlider : MonoBehaviour
{
	public GameObject TorcheObj;

	public GUISkin SkinSlider;

	private void OnGUI()
	{
		GUI.Label(new Rect(25f, 25f, 150f, 30f), "Light Intensity", SkinSlider.label);
		TorcheObj.GetComponent<Torchelight>().IntensityLight = GUI.HorizontalSlider(new Rect(25f, 50f, 150f, 30f), TorcheObj.GetComponent<Torchelight>().IntensityLight, 0f, TorcheObj.GetComponent<Torchelight>().MaxLightIntensity, SkinSlider.horizontalSlider, SkinSlider.horizontalSliderThumb);
	}
}
public class Torchslider2 : MonoBehaviour
{
	public GameObject TorcheObj;

	public Camera MainCamera;

	public GUISkin SkinSlider;

	private GameObject Torch;

	private float Intensity_Light;

	private bool CameraRendering;

	private void OnGUI()
	{
		GUI.Label(new Rect(25f, 25f, 150f, 30f), "Light Intensity", SkinSlider.label);
		Intensity_Light = GUI.HorizontalSlider(new Rect(25f, 50f, 150f, 30f), Intensity_Light, 0f, TorcheObj.GetComponent<Torchelight>().MaxLightIntensity, SkinSlider.horizontalSlider, SkinSlider.horizontalSliderThumb);
		CameraRendering = GUI.Toggle(new Rect(25f, 80f, 150f, 30f), CameraRendering, "Deferred lighting");
		if (CameraRendering)
		{
			MainCamera.renderingPath = RenderingPath.DeferredLighting;
		}
		else
		{
			MainCamera.renderingPath = RenderingPath.Forward;
		}
	}

	private void Update()
	{
		GameObject[] array = GameObject.FindGameObjectsWithTag("TagLight");
		for (int i = 0; i < array.Length; i++)
		{
			array[i].GetComponent<Torchelight>().IntensityLight = Intensity_Light;
		}
	}
}
public class Torchelight : MonoBehaviour
{
	public GameObject TorchLight;

	public GameObject MainFlame;

	public GameObject BaseFlame;

	public GameObject Etincelles;

	public GameObject Fumee;

	public float MaxLightIntensity;

	public float IntensityLight;

	private void Start()
	{
		TorchLight.GetComponent<Light>().intensity = IntensityLight;
		MainFlame.GetComponent<ParticleSystem>().emissionRate = IntensityLight * 20f;
		BaseFlame.GetComponent<ParticleSystem>().emissionRate = IntensityLight * 15f;
		Etincelles.GetComponent<ParticleSystem>().emissionRate = IntensityLight * 7f;
		Fumee.GetComponent<ParticleSystem>().emissionRate = IntensityLight * 12f;
	}

	private void Update()
	{
		if (IntensityLight < 0f)
		{
			IntensityLight = 0f;
		}
		if (IntensityLight > MaxLightIntensity)
		{
			IntensityLight = MaxLightIntensity;
		}
		TorchLight.GetComponent<Light>().intensity = IntensityLight / 2f + Mathf.Lerp(IntensityLight - 0.1f, IntensityLight + 0.1f, Mathf.Cos(Time.time * 30f));
		TorchLight.GetComponent<Light>().color = new Color(Mathf.Min(IntensityLight / 1.5f, 1f), Mathf.Min(IntensityLight / 2f, 1f), 0f);
		MainFlame.GetComponent<ParticleSystem>().emissionRate = IntensityLight * 20f;
		BaseFlame.GetComponent<ParticleSystem>().emissionRate = IntensityLight * 15f;
		Etincelles.GetComponent<ParticleSystem>().emissionRate = IntensityLight * 7f;
		Fumee.GetComponent<ParticleSystem>().emissionRate = IntensityLight * 12f;
	}
}
namespace LPHailSet
{
	public class DemoSceneController : MonoBehaviour
	{
		public GameObject sunLight;

		public Color btnActiveColor;

		public GameObject[] buttons;

		public GameObject btnWind;

		public GameObject btnNoWind;

		public GameObject[] listSystems;

		public GameObject windZone;

		private string activeStrength = "soft";

		public GameObject activeBtnStrength;

		public GameObject activeBtnWind;

		private void Awake()
		{
			activeBtnStrength.GetComponent<Image>().color = btnActiveColor;
			btnNoWind.GetComponent<Image>().color = btnActiveColor;
		}

		private void UpdateActiveSystem()
		{
			int num = 0;
			switch (activeStrength)
			{
			case "soft":
				num = 0;
				break;
			case "medium":
				num = 1;
				break;
			case "heavy":
				num = 2;
				break;
			}
			listSystems[0].SetActive(value: false);
			listSystems[1].SetActive(value: false);
			listSystems[2].SetActive(value: false);
			listSystems[num].SetActive(value: true);
		}

		public void SetSoft()
		{
			activeStrength = "soft";
			UpdateActiveSystem();
			activeBtnStrength.GetComponent<Image>().color = Color.black;
			activeBtnStrength = buttons[0];
			activeBtnStrength.GetComponent<Image>().color = btnActiveColor;
		}

		public void SetMedium()
		{
			activeStrength = "medium";
			UpdateActiveSystem();
			activeBtnStrength.GetComponent<Image>().color = Color.black;
			activeBtnStrength = buttons[1];
			activeBtnStrength.GetComponent<Image>().color = btnActiveColor;
		}

		public void SetHeavy()
		{
			activeStrength = "heavy";
			UpdateActiveSystem();
			activeBtnStrength.GetComponent<Image>().color = Color.black;
			activeBtnStrength = buttons[2];
			activeBtnStrength.GetComponent<Image>().color = btnActiveColor;
		}

		public void SetWind()
		{
			windZone.SetActive(value: true);
			btnNoWind.GetComponent<Image>().color = Color.black;
			btnWind.GetComponent<Image>().color = btnActiveColor;
		}

		public void SetNoWind()
		{
			windZone.SetActive(value: false);
			btnWind.GetComponent<Image>().color = Color.black;
			btnNoWind.GetComponent<Image>().color = btnActiveColor;
		}
	}
}
namespace DigitalRuby.RainMaker
{
	public class DemoScript : MonoBehaviour
	{
		private enum RotationAxes
		{
			MouseXAndY,
			MouseX,
			MouseY
		}

		public RainScript RainScript;

		public Toggle MouseLookToggle;

		public Toggle FlashlightToggle;

		public Slider RainSlider;

		public Light Flashlight;

		public GameObject Sun;

		private RotationAxes axes;

		private float sensitivityX = 15f;

		private float sensitivityY = 15f;

		private float minimumX = -360f;

		private float maximumX = 360f;

		private float minimumY = -60f;

		private float maximumY = 60f;

		private float rotationX;

		private float rotationY;

		private Quaternion originalRotation;

		private void UpdateRain()
		{
			if (RainScript != null)
			{
				if (Input.GetKeyDown(KeyCode.Alpha1))
				{
					RainScript.RainIntensity = 0f;
				}
				else if (Input.GetKeyDown(KeyCode.Alpha2))
				{
					RainScript.RainIntensity = 0.2f;
				}
				else if (Input.GetKeyDown(KeyCode.Alpha3))
				{
					RainScript.RainIntensity = 0.5f;
				}
				else if (Input.GetKeyDown(KeyCode.Alpha4))
				{
					RainScript.RainIntensity = 0.8f;
				}
			}
		}

		private void UpdateMovement()
		{
			float num = 5f * Time.deltaTime;
			if (Input.GetKey(KeyCode.W))
			{
				Camera.main.transform.Translate(0f, 0f, num);
			}
			else if (Input.GetKey(KeyCode.S))
			{
				Camera.main.transform.Translate(0f, 0f, 0f - num);
			}
			if (Input.GetKey(KeyCode.A))
			{
				Camera.main.transform.Translate(0f - num, 0f, 0f);
			}
			else if (Input.GetKey(KeyCode.D))
			{
				Camera.main.transform.Translate(num, 0f, 0f);
			}
			if (Input.GetKeyDown(KeyCode.F))
			{
				FlashlightToggle.isOn = !FlashlightToggle.isOn;
			}
		}

		private void UpdateMouseLook()
		{
			if (Input.GetKeyDown(KeyCode.Space) || Input.GetKeyDown(KeyCode.M))
			{
				MouseLookToggle.isOn = !MouseLookToggle.isOn;
			}
			if (MouseLookToggle.isOn)
			{
				if (axes == RotationAxes.MouseXAndY)
				{
					rotationX += Input.GetAxis("Mouse X") * sensitivityX;
					rotationY += Input.GetAxis("Mouse Y") * sensitivityY;
					rotationX = ClampAngle(rotationX, minimumX, maximumX);
					rotationY = ClampAngle(rotationY, minimumY, maximumY);
					Quaternion quaternion = Quaternion.AngleAxis(rotationX, Vector3.up);
					Quaternion quaternion2 = Quaternion.AngleAxis(rotationY, -Vector3.right);
					base.transform.localRotation = originalRotation * quaternion * quaternion2;
				}
				else if (axes == RotationAxes.MouseX)
				{
					rotationX += Input.GetAxis("Mouse X") * sensitivityX;
					rotationX = ClampAngle(rotationX, minimumX, maximumX);
					Quaternion quaternion3 = Quaternion.AngleAxis(rotationX, Vector3.up);
					base.transform.localRotation = originalRotation * quaternion3;
				}
				else
				{
					rotationY += Input.GetAxis("Mouse Y") * sensitivityY;
					rotationY = ClampAngle(rotationY, minimumY, maximumY);
					Quaternion quaternion4 = Quaternion.AngleAxis(0f - rotationY, Vector3.right);
					base.transform.localRotation = originalRotation * quaternion4;
				}
			}
		}

		public void RainSliderChanged(float val)
		{
			RainScript.RainIntensity = val;
		}

		public void MouseLookChanged(bool val)
		{
			MouseLookToggle.isOn = val;
		}

		public void FlashlightChanged(bool val)
		{
			FlashlightToggle.isOn = val;
			Flashlight.enabled = val;
		}

		public void DawnDuskSliderChanged(float val)
		{
			Sun.transform.rotation = Quaternion.Euler(val, 0f, 0f);
		}

		public void FollowCameraChanged(bool val)
		{
			RainScript.FollowCamera = val;
		}

		private void Start()
		{
			originalRotation = base.transform.localRotation;
			RainScript rainScript = RainScript;
			float rainIntensity = (RainSlider.value = 0.5f);
			rainScript.RainIntensity = rainIntensity;
			RainScript.EnableWind = true;
		}

		private void Update()
		{
			UpdateRain();
			UpdateMovement();
			UpdateMouseLook();
		}

		public static float ClampAngle(float angle, float min, float max)
		{
			if (angle < -360f)
			{
				angle += 360f;
			}
			if (angle > 360f)
			{
				angle -= 360f;
			}
			return Mathf.Clamp(angle, min, max);
		}
	}
	public class DemoScript2D : MonoBehaviour
	{
		public Slider RainSlider;

		public RainScript2D RainScript;

		private void Start()
		{
			RainScript2D rainScript = RainScript;
			float rainIntensity = (RainSlider.value = 0.5f);
			rainScript.RainIntensity = rainIntensity;
			RainScript.EnableWind = true;
		}

		private void Update()
		{
			Vector3 vector = Camera.main.ViewportToWorldPoint(Vector3.zero);
			float num = Camera.main.ViewportToWorldPoint(Vector3.one).x - vector.x;
			if (Input.GetKey(KeyCode.LeftArrow))
			{
				Camera.main.transform.Translate(Time.deltaTime * (0f - num * 0.1f), 0f, 0f);
			}
			else if (Input.GetKey(KeyCode.RightArrow))
			{
				Camera.main.transform.Translate(Time.deltaTime * (num * 0.1f), 0f, 0f);
			}
		}

		public void RainSliderChanged(float val)
		{
			RainScript.RainIntensity = val;
		}

		public void CollisionToggleChanged(bool val)
		{
			RainScript.CollisionMask = (val ? (-1) : 0);
		}
	}
	public class DemoScriptStartRainOnSpaceBar : MonoBehaviour
	{
		public BaseRainScript RainScript;

		private void Start()
		{
			if (!(RainScript == null))
			{
				RainScript.EnableWind = false;
			}
		}

		private void Update()
		{
			if (!(RainScript == null) && Input.GetKeyDown(KeyCode.Space))
			{
				RainScript.RainIntensity = ((RainScript.RainIntensity == 0f) ? 1f : 0f);
				RainScript.EnableWind = !RainScript.EnableWind;
			}
		}
	}
	public class BaseRainScript : MonoBehaviour
	{
		[Tooltip("Camera the rain should hover over, defaults to main camera")]
		public Camera Camera;

		[Tooltip("Whether rain should follow the camera. If false, rain must be moved manually and will not follow the camera.")]
		public bool FollowCamera = true;

		[Tooltip("Light rain looping clip")]
		public AudioClip RainSoundLight;

		[Tooltip("Medium rain looping clip")]
		public AudioClip RainSoundMedium;

		[Tooltip("Heavy rain looping clip")]
		public AudioClip RainSoundHeavy;

		[Tooltip("AudoMixer used for the rain sound")]
		public AudioMixerGroup RainSoundAudioMixer;

		[Tooltip("Intensity of rain (0-1)")]
		[Range(0f, 1f)]
		public float RainIntensity;

		[Tooltip("Rain particle system")]
		public ParticleSystem RainFallParticleSystem;

		[Tooltip("Particles system for when rain hits something")]
		public ParticleSystem RainExplosionParticleSystem;

		[Tooltip("Particle system to use for rain mist")]
		public ParticleSystem RainMistParticleSystem;

		[Tooltip("The threshold for intensity (0 - 1) at which mist starts to appear")]
		[Range(0f, 1f)]
		public float RainMistThreshold = 0.5f;

		[Tooltip("Wind looping clip")]
		public AudioClip WindSound;

		[Tooltip("Wind sound volume modifier, use this to lower your sound if it's too loud.")]
		public float WindSoundVolumeModifier = 0.5f;

		[Tooltip("Wind zone that will affect and follow the rain")]
		public WindZone WindZone;

		[Tooltip("X = minimum wind speed. Y = maximum wind speed. Z = sound multiplier. Wind speed is divided by Z to get sound multiplier value. Set Z to lower than Y to increase wind sound volume, or higher to decrease wind sound volume.")]
		public Vector3 WindSpeedRange = new Vector3(50f, 500f, 500f);

		[Tooltip("How often the wind speed and direction changes (minimum and maximum change interval in seconds)")]
		public Vector2 WindChangeInterval = new Vector2(5f, 30f);

		[Tooltip("Whether wind should be enabled.")]
		public bool EnableWind = true;

		protected LoopingAudioSource audioSourceRainLight;

		protected LoopingAudioSource audioSourceRainMedium;

		protected LoopingAudioSource audioSourceRainHeavy;

		protected LoopingAudioSource audioSourceRainCurrent;

		protected LoopingAudioSource audioSourceWind;

		protected Material rainMaterial;

		protected Material rainExplosionMaterial;

		protected Material rainMistMaterial;

		private float lastRainIntensityValue = -1f;

		private float nextWindTime;

		protected virtual bool UseRainMistSoftParticles => true;

		private void UpdateWind()
		{
			if (EnableWind && WindZone != null && WindSpeedRange.y > 1f)
			{
				WindZone.gameObject.SetActive(value: true);
				if (FollowCamera)
				{
					WindZone.transform.position = Camera.transform.position;
				}
				if (!Camera.orthographic)
				{
					WindZone.transform.Translate(0f, WindZone.radius, 0f);
				}
				if (nextWindTime < Time.time)
				{
					WindZone.windMain = UnityEngine.Random.Range(WindSpeedRange.x, WindSpeedRange.y);
					WindZone.windTurbulence = UnityEngine.Random.Range(WindSpeedRange.x, WindSpeedRange.y);
					if (Camera.orthographic)
					{
						int num = UnityEngine.Random.Range(0, 2);
						WindZone.transform.rotation = Quaternion.Euler(0f, (num == 0) ? 90f : (-90f), 0f);
					}
					else
					{
						WindZone.transform.rotation = Quaternion.Euler(UnityEngine.Random.Range(-30f, 30f), UnityEngine.Random.Range(0f, 360f), 0f);
					}
					nextWindTime = Time.time + UnityEngine.Random.Range(WindChangeInterval.x, WindChangeInterval.y);
					audioSourceWind.Play(WindZone.windMain / WindSpeedRange.z * WindSoundVolumeModifier);
				}
			}
			else
			{
				if (WindZone != null)
				{
					WindZone.gameObject.SetActive(value: false);
				}
				audioSourceWind.Stop();
			}
			audioSourceWind.Update();
		}

		private void CheckForRainChange()
		{
			if (lastRainIntensityValue == RainIntensity)
			{
				return;
			}
			lastRainIntensityValue = RainIntensity;
			if (RainIntensity <= 0.01f)
			{
				if (audioSourceRainCurrent != null)
				{
					audioSourceRainCurrent.Stop();
					audioSourceRainCurrent = null;
				}
				if (RainFallParticleSystem != null)
				{
					ParticleSystem.EmissionModule emission = RainFallParticleSystem.emission;
					emission.enabled = false;
					RainFallParticleSystem.Stop();
				}
				if (RainMistParticleSystem != null)
				{
					ParticleSystem.EmissionModule emission2 = RainMistParticleSystem.emission;
					emission2.enabled = false;
					RainMistParticleSystem.Stop();
				}
				return;
			}
			LoopingAudioSource loopingAudioSource = ((RainIntensity >= 0.67f) ? audioSourceRainHeavy : ((!(RainIntensity >= 0.33f)) ? audioSourceRainLight : audioSourceRainMedium));
			if (audioSourceRainCurrent != loopingAudioSource)
			{
				if (audioSourceRainCurrent != null)
				{
					audioSourceRainCurrent.Stop();
				}
				audioSourceRainCurrent = loopingAudioSource;
				audioSourceRainCurrent.Play(1f);
			}
			if (RainFallParticleSystem != null)
			{
				ParticleSystem.EmissionModule emission3 = RainFallParticleSystem.emission;
				bool flag2 = (RainFallParticleSystem.GetComponent<Renderer>().enabled = true);
				emission3.enabled = flag2;
				if (!RainFallParticleSystem.isPlaying)
				{
					RainFallParticleSystem.Play();
				}
				ParticleSystem.MinMaxCurve rateOverTime = emission3.rateOverTime;
				rateOverTime.mode = ParticleSystemCurveMode.Constant;
				float constantMin = (rateOverTime.constantMax = RainFallEmissionRate());
				rateOverTime.constantMin = constantMin;
				emission3.rateOverTime = rateOverTime;
			}
			if (RainMistParticleSystem != null)
			{
				ParticleSystem.EmissionModule emission4 = RainMistParticleSystem.emission;
				bool flag2 = (RainMistParticleSystem.GetComponent<Renderer>().enabled = true);
				emission4.enabled = flag2;
				if (!RainMistParticleSystem.isPlaying)
				{
					RainMistParticleSystem.Play();
				}
				float num2 = ((!(RainIntensity < RainMistThreshold)) ? MistEmissionRate() : 0f);
				ParticleSystem.MinMaxCurve rateOverTime2 = emission4.rateOverTime;
				rateOverTime2.mode = ParticleSystemCurveMode.Constant;
				float constantMin = (rateOverTime2.constantMax = num2);
				rateOverTime2.constantMin = constantMin;
				emission4.rateOverTime = rateOverTime2;
			}
		}

		protected virtual void Start()
		{
			if (Camera == null)
			{
				Camera = Camera.main;
			}
			audioSourceRainLight = new LoopingAudioSource(this, RainSoundLight, RainSoundAudioMixer);
			audioSourceRainMedium = new LoopingAudioSource(this, RainSoundMedium, RainSoundAudioMixer);
			audioSourceRainHeavy = new LoopingAudioSource(this, RainSoundHeavy, RainSoundAudioMixer);
			audioSourceWind = new LoopingAudioSource(this, WindSound, RainSoundAudioMixer);
			if (RainFallParticleSystem != null)
			{
				ParticleSystem.EmissionModule emission = RainFallParticleSystem.emission;
				emission.enabled = false;
				Renderer component = RainFallParticleSystem.GetComponent<Renderer>();
				component.enabled = false;
				rainMaterial = new Material(component.material);
				rainMaterial.EnableKeyword("SOFTPARTICLES_OFF");
				component.material = rainMaterial;
			}
			if (RainExplosionParticleSystem != null)
			{
				ParticleSystem.EmissionModule emission2 = RainExplosionParticleSystem.emission;
				emission2.enabled = false;
				Renderer component2 = RainExplosionParticleSystem.GetComponent<Renderer>();
				rainExplosionMaterial = new Material(component2.material);
				rainExplosionMaterial.EnableKeyword("SOFTPARTICLES_OFF");
				component2.material = rainExplosionMaterial;
			}
			if (RainMistParticleSystem != null)
			{
				ParticleSystem.EmissionModule emission3 = RainMistParticleSystem.emission;
				emission3.enabled = false;
				Renderer component3 = RainMistParticleSystem.GetComponent<Renderer>();
				component3.enabled = false;
				rainMistMaterial = new Material(component3.material);
				if (UseRainMistSoftParticles)
				{
					rainMistMaterial.EnableKeyword("SOFTPARTICLES_ON");
				}
				else
				{
					rainMistMaterial.EnableKeyword("SOFTPARTICLES_OFF");
				}
				component3.material = rainMistMaterial;
			}
		}

		protected virtual void Update()
		{
			CheckForRainChange();
			UpdateWind();
			audioSourceRainLight.Update();
			audioSourceRainMedium.Update();
			audioSourceRainHeavy.Update();
		}

		protected virtual float RainFallEmissionRate()
		{
			return (float)RainFallParticleSystem.main.maxParticles / RainFallParticleSystem.main.startLifetime.constant * RainIntensity;
		}

		protected virtual float MistEmissionRate()
		{
			return (float)RainMistParticleSystem.main.maxParticles / RainMistParticleSystem.main.startLifetime.constant * RainIntensity * RainIntensity;
		}
	}
	public class LoopingAudioSource
	{
		public AudioSource AudioSource { get; private set; }

		public float TargetVolume { get; private set; }

		public LoopingAudioSource(MonoBehaviour script, AudioClip clip, AudioMixerGroup mixer)
		{
			AudioSource = script.gameObject.AddComponent<AudioSource>();
			if (mixer != null)
			{
				AudioSource.outputAudioMixerGroup = mixer;
			}
			AudioSource.loop = true;
			AudioSource.clip = clip;
			AudioSource.playOnAwake = false;
			AudioSource.volume = 0f;
			AudioSource.Stop();
			TargetVolume = 1f;
		}

		public void Play(float targetVolume)
		{
			if (!AudioSource.isPlaying)
			{
				AudioSource.volume = 0f;
				AudioSource.Play();
			}
			TargetVolume = targetVolume;
		}

		public void Stop()
		{
			TargetVolume = 0f;
		}

		public void Update()
		{
			if (AudioSource.isPlaying)
			{
				float num2 = (AudioSource.volume = Mathf.Lerp(AudioSource.volume, TargetVolume, Time.deltaTime));
				if (num2 == 0f)
				{
					AudioSource.Stop();
				}
			}
		}
	}
	public class RainCollision : MonoBehaviour
	{
		private static readonly Color32 color = new Color32(byte.MaxValue, byte.MaxValue, byte.MaxValue, byte.MaxValue);

		private readonly List<ParticleCollisionEvent> collisionEvents = new List<ParticleCollisionEvent>();

		public ParticleSystem RainExplosion;

		public ParticleSystem RainParticleSystem;

		private void Start()
		{
		}

		private void Update()
		{
		}

		private void Emit(ParticleSystem p, ref Vector3 pos)
		{
			for (int num = UnityEngine.Random.Range(2, 5); num != 0; num--)
			{
				float y = UnityEngine.Random.Range(1f, 3f);
				float z = UnityEngine.Random.Range(-2f, 2f);
				float x = UnityEngine.Random.Range(-2f, 2f);
				float startSize = UnityEngine.Random.Range(0.05f, 0.1f);
				ParticleSystem.EmitParams emitParams = default(ParticleSystem.EmitParams);
				emitParams.position = pos;
				emitParams.velocity = new Vector3(x, y, z);
				emitParams.startLifetime = 0.75f;
				emitParams.startSize = startSize;
				emitParams.startColor = color;
				p.Emit(emitParams, 1);
			}
		}

		private void OnParticleCollision(GameObject obj)
		{
			if (RainExplosion != null && RainParticleSystem != null)
			{
				int num = RainParticleSystem.GetCollisionEvents(obj, collisionEvents);
				for (int i = 0; i < num; i++)
				{
					Vector3 pos = collisionEvents[i].intersection;
					Emit(RainExplosion, ref pos);
				}
			}
		}
	}
	public class RainScript : BaseRainScript
	{
		[Tooltip("The height above the camera that the rain will start falling from")]
		public float RainHeight = 25f;

		[Tooltip("How far the rain particle system is ahead of the player")]
		public float RainForwardOffset = -7f;

		[Tooltip("The top y value of the mist particles")]
		public float RainMistHeight = 3f;

		private void UpdateRain()
		{
			if (!(RainFallParticleSystem != null))
			{
				return;
			}
			if (FollowCamera)
			{
				ParticleSystem.ShapeModule shape = RainFallParticleSystem.shape;
				shape.shapeType = ParticleSystemShapeType.ConeVolume;
				RainFallParticleSystem.transform.position = Camera.transform.position;
				RainFallParticleSystem.transform.Translate(0f, RainHeight, RainForwardOffset);
				RainFallParticleSystem.transform.rotation = Quaternion.Euler(0f, Camera.transform.rotation.eulerAngles.y, 0f);
				if (RainMistParticleSystem != null)
				{
					ParticleSystem.ShapeModule shape2 = RainMistParticleSystem.shape;
					shape2.shapeType = ParticleSystemShapeType.Hemisphere;
					Vector3 position = Camera.transform.position;
					position.y += RainMistHeight;
					RainMistParticleSystem.transform.position = position;
				}
			}
			else
			{
				ParticleSystem.ShapeModule shape3 = RainFallParticleSystem.shape;
				shape3.shapeType = ParticleSystemShapeType.Box;
				if (RainMistParticleSystem != null)
				{
					ParticleSystem.ShapeModule shape4 = RainMistParticleSystem.shape;
					shape4.shapeType = ParticleSystemShapeType.Box;
					Vector3 position2 = RainFallParticleSystem.transform.position;
					position2.y += RainMistHeight;
					position2.y -= RainHeight;
					RainMistParticleSystem.transform.position = position2;
				}
			}
		}

		protected override void Start()
		{
			base.Start();
		}

		protected override void Update()
		{
			base.Update();
			UpdateRain();
		}
	}
	public class RainScript2D : BaseRainScript
	{
		private static readonly Color32 explosionColor = new Color32(byte.MaxValue, byte.MaxValue, byte.MaxValue, byte.MaxValue);

		private float cameraMultiplier = 1f;

		private Bounds visibleBounds;

		private float yOffset;

		private float visibleWorldWidth;

		private float initialEmissionRain;

		private Vector2 initialStartSpeedRain;

		private Vector2 initialStartSizeRain;

		private Vector2 initialStartSpeedMist;

		private Vector2 initialStartSizeMist;

		private Vector2 initialStartSpeedExplosion;

		private Vector2 initialStartSizeExplosion;

		private readonly ParticleSystem.Particle[] particles = new ParticleSystem.Particle[2048];

		[Tooltip("The starting y offset for rain and mist. This will be offset as a percentage of visible height from the top of the visible world.")]
		public float RainHeightMultiplier = 0.15f;

		[Tooltip("The total width of the rain and mist as a percentage of visible width")]
		public float RainWidthMultiplier = 1.5f;

		[Tooltip("Collision mask for the rain particles")]
		public LayerMask CollisionMask = -1;

		[Tooltip("Lifetime to assign to rain particles that have collided. 0 for instant death. This can allow the rain to penetrate a little bit beyond the collision point.")]
		[Range(0f, 0.5f)]
		public float CollisionLifeTimeRain = 0.02f;

		[Tooltip("Multiply the velocity of any mist colliding by this amount")]
		[Range(0f, 0.99f)]
		public float RainMistCollisionMultiplier = 0.75f;

		protected override bool UseRainMistSoftParticles => false;

		private void EmitExplosion(ref Vector3 pos)
		{
			for (int num = UnityEngine.Random.Range(2, 5); num != 0; num--)
			{
				float x = UnityEngine.Random.Range(-2f, 2f) * cameraMultiplier;
				float y = UnityEngine.Random.Range(1f, 3f) * cameraMultiplier;
				float startLifetime = UnityEngine.Random.Range(0.1f, 0.2f);
				float startSize = UnityEngine.Random.Range(0.05f, 0.1f) * cameraMultiplier;
				ParticleSystem.EmitParams emitParams = default(ParticleSystem.EmitParams);
				emitParams.position = pos;
				emitParams.velocity = new Vector3(x, y, 0f);
				emitParams.startLifetime = startLifetime;
				emitParams.startSize = startSize;
				emitParams.startColor = explosionColor;
				RainExplosionParticleSystem.Emit(emitParams, 1);
			}
		}

		private void TransformParticleSystem(ParticleSystem p, Vector2 initialStartSpeed, Vector2 initialStartSize)
		{
			if (!(p == null))
			{
				if (FollowCamera)
				{
					p.transform.position = new Vector3(Camera.transform.position.x, visibleBounds.max.y + yOffset, p.transform.position.z);
				}
				else
				{
					p.transform.position = new Vector3(p.transform.position.x, visibleBounds.max.y + yOffset, p.transform.position.z);
				}
				p.transform.localScale = new Vector3(visibleWorldWidth * RainWidthMultiplier, 1f, 1f);
				ParticleSystem.MainModule main = p.main;
				ParticleSystem.MinMaxCurve startSpeed = main.startSpeed;
				ParticleSystem.MinMaxCurve startSize = main.startSize;
				startSpeed.constantMin = initialStartSpeed.x * cameraMultiplier;
				startSpeed.constantMax = initialStartSpeed.y * cameraMultiplier;
				startSize.constantMin = initialStartSize.x * cameraMultiplier;
				startSize.constantMax = initialStartSize.y * cameraMultiplier;
				main.startSpeed = startSpeed;
				main.startSize = startSize;
			}
		}

		private void CheckForCollisionsRainParticles()
		{
			int num = 0;
			bool flag = false;
			if ((int)CollisionMask != 0)
			{
				num = RainFallParticleSystem.GetParticles(particles);
				for (int i = 0; i < num; i++)
				{
					Vector3 vector = particles[i].position + RainFallParticleSystem.transform.position;
					RaycastHit2D raycastHit2D = Physics2D.Raycast(vector, particles[i].velocity.normalized, particles[i].velocity.magnitude * Time.deltaTime);
					if (raycastHit2D.collider != null && ((1 << raycastHit2D.collider.gameObject.layer) & (int)CollisionMask) != 0)
					{
						if (CollisionLifeTimeRain == 0f)
						{
							particles[i].remainingLifetime = 0f;
						}
						else
						{
							particles[i].remainingLifetime = Mathf.Min(particles[i].remainingLifetime, UnityEngine.Random.Range(CollisionLifeTimeRain * 0.5f, CollisionLifeTimeRain * 2f));
							vector += particles[i].velocity * Time.deltaTime;
						}
						flag = true;
					}
				}
			}
			if (RainExplosionParticleSystem != null)
			{
				if (num == 0)
				{
					num = RainFallParticleSystem.GetParticles(particles);
				}
				for (int j = 0; j < num; j++)
				{
					if (particles[j].remainingLifetime < 0.24f)
					{
						Vector3 pos = particles[j].position + RainFallParticleSystem.transform.position;
						EmitExplosion(ref pos);
					}
				}
			}
			if (flag)
			{
				RainFallParticleSystem.SetParticles(particles, num);
			}
		}

		private void CheckForCollisionsMistParticles()
		{
			if (RainMistParticleSystem == null || (int)CollisionMask == 0)
			{
				return;
			}
			int num = RainMistParticleSystem.GetParticles(particles);
			bool flag = false;
			for (int i = 0; i < num; i++)
			{
				if (Physics2D.Raycast(particles[i].position + RainMistParticleSystem.transform.position, particles[i].velocity.normalized, particles[i].velocity.magnitude * Time.deltaTime, CollisionMask).collider != null)
				{
					particles[i].velocity *= RainMistCollisionMultiplier;
					flag = true;
				}
			}
			if (flag)
			{
				RainMistParticleSystem.SetParticles(particles, num);
			}
		}

		protected override void Start()
		{
			base.Start();
			initialEmissionRain = RainFallParticleSystem.emission.rateOverTime.constant;
			initialStartSpeedRain = new Vector2(RainFallParticleSystem.main.startSpeed.constantMin, RainFallParticleSystem.main.startSpeed.constantMax);
			initialStartSizeRain = new Vector2(RainFallParticleSystem.main.startSize.constantMin, RainFallParticleSystem.main.startSize.constantMax);
			if (RainMistParticleSystem != null)
			{
				initialStartSpeedMist = new Vector2(RainMistParticleSystem.main.startSpeed.constantMin, RainMistParticleSystem.main.startSpeed.constantMax);
				initialStartSizeMist = new Vector2(RainMistParticleSystem.main.startSize.constantMin, RainMistParticleSystem.main.startSize.constantMax);
			}
			if (RainExplosionParticleSystem != null)
			{
				initialStartSpeedExplosion = new Vector2(RainExplosionParticleSystem.main.startSpeed.constantMin, RainExplosionParticleSystem.main.startSpeed.constantMax);
				initialStartSizeExplosion = new Vector2(RainExplosionParticleSystem.main.startSize.constantMin, RainExplosionParticleSystem.main.startSize.constantMax);
			}
		}

		protected override void Update()
		{
			base.Update();
			cameraMultiplier = Camera.orthographicSize * 0.25f;
			visibleBounds.min = Camera.main.ViewportToWorldPoint(Vector3.zero);
			visibleBounds.max = Camera.main.ViewportToWorldPoint(Vector3.one);
			visibleWorldWidth = visibleBounds.size.x;
			yOffset = (visibleBounds.max.y - visibleBounds.min.y) * RainHeightMultiplier;
			TransformParticleSystem(RainFallParticleSystem, initialStartSpeedRain, initialStartSizeRain);
			TransformParticleSystem(RainMistParticleSystem, initialStartSpeedMist, initialStartSizeMist);
			TransformParticleSystem(RainExplosionParticleSystem, initialStartSpeedExplosion, initialStartSizeExplosion);
			CheckForCollisionsRainParticles();
			CheckForCollisionsMistParticles();
		}

		protected override float RainFallEmissionRate()
		{
			return initialEmissionRain * RainIntensity;
		}
	}
}
namespace VRTK
{
	public class FramsPerSecondViewer : MonoBehaviour
	{
		public bool displayFPS = true;

		public int targetFPS = 90;

		public int fontSize = 32;

		public Vector3 position = Vector3.zero;

		public Color goodColor = Color.green;

		public Color warnColor = Color.yellow;

		public Color badColor = Color.red;

		private const float updateInterval = 0.5f;

		private int framesCount;

		private float framesTime;

		private Text text;

		private void Start()
		{
			text = GetComponent<Text>();
			text.fontSize = fontSize;
			text.transform.localPosition = position;
		}

		private void Update()
		{
			framesCount++;
			framesTime += Time.unscaledDeltaTime;
			if (!(framesTime > 0.5f))
			{
				return;
			}
			if (text != null)
			{
				if (displayFPS)
				{
					float num = (float)framesCount / framesTime;
					text.text = $"{num:F2} FPS";
					text.color = ((num > (float)(targetFPS - 5)) ? goodColor : ((num > (float)(targetFPS - 30)) ? warnColor : badColor));
				}
				else
				{
					text.text = "";
				}
			}
			framesCount = 0;
			framesTime = 0f;
		}
	}
}
namespace UnityEngine.PostProcessing
{
	public sealed class GetSetAttribute : PropertyAttribute
	{
		public readonly string name;

		public bool dirty;

		public GetSetAttribute(string name)
		{
			this.name = name;
		}
	}
	public sealed class MinAttribute : PropertyAttribute
	{
		public readonly float min;

		public MinAttribute(float min)
		{
			this.min = min;
		}
	}
	public sealed class TrackballAttribute : PropertyAttribute
	{
		public readonly string method;

		public TrackballAttribute(string method)
		{
			this.method = method;
		}
	}
	public sealed class TrackballGroupAttribute : PropertyAttribute
	{
	}
	public sealed class AmbientOcclusionComponent : PostProcessingComponentCommandBuffer<AmbientOcclusionModel>
	{
		private static class Uniforms
		{
			internal static readonly int _Intensity = Shader.PropertyToID("_Intensity");

			internal static readonly int _Radius = Shader.PropertyToID("_Radius");

			internal static readonly int _FogParams = Shader.PropertyToID("_FogParams");

			internal static readonly int _Downsample = Shader.PropertyToID("_Downsample");

			internal static readonly int _SampleCount = Shader.PropertyToID("_SampleCount");

			internal static readonly int _OcclusionTexture1 = Shader.PropertyToID("_OcclusionTexture1");

			internal static readonly int _OcclusionTexture2 = Shader.PropertyToID("_OcclusionTexture2");

			internal static readonly int _OcclusionTexture = Shader.PropertyToID("_OcclusionTexture");

			internal static readonly int _MainTex = Shader.PropertyToID("_MainTex");

			internal static readonly int _TempRT = Shader.PropertyToID("_TempRT");
		}

		private enum OcclusionSource
		{
			DepthTexture,
			DepthNormalsTexture,
			GBuffer
		}

		private const string k_BlitShaderString = "Hidden/Post FX/Blit";

		private const string k_ShaderString = "Hidden/Post FX/Ambient Occlusion";

		private readonly RenderTargetIdentifier[] m_MRT = new RenderTargetIdentifier[2]
		{
			BuiltinRenderTextureType.GBuffer0,
			BuiltinRenderTextureType.CameraTarget
		};

		private OcclusionSource occlusionSource
		{
			get
			{
				if (context.isGBufferAvailable && !base.model.settings.forceForwardCompatibility)
				{
					return OcclusionSource.GBuffer;
				}
				if (base.model.settings.highPrecision && (!context.isGBufferAvailable || base.model.settings.forceForwardCompatibility))
				{
					return OcclusionSource.DepthTexture;
				}
				return OcclusionSource.DepthNormalsTexture;
			}
		}

		private bool ambientOnlySupported
		{
			get
			{
				if (context.isHdr && base.model.settings.ambientOnly && context.isGBufferAvailable)
				{
					return !base.model.settings.forceForwardCompatibility;
				}
				return false;
			}
		}

		public override bool active
		{
			get
			{
				if (base.model.enabled && base.model.settings.intensity > 0f)
				{
					return !context.interrupted;
				}
				return false;
			}
		}

		public override DepthTextureMode GetCameraFlags()
		{
			DepthTextureMode depthTextureMode = DepthTextureMode.None;
			if (occlusionSource == OcclusionSource.DepthTexture)
			{
				depthTextureMode |= DepthTextureMode.Depth;
			}
			if (occlusionSource != OcclusionSource.GBuffer)
			{
				depthTextureMode |= DepthTextureMode.DepthNormals;
			}
			return depthTextureMode;
		}

		public override string GetName()
		{
			return "Ambient Occlusion";
		}

		public override CameraEvent GetCameraEvent()
		{
			if (!ambientOnlySupported || context.profile.debugViews.IsModeActive(BuiltinDebugViewsModel.Mode.AmbientOcclusion))
			{
				return CameraEvent.BeforeImageEffectsOpaque;
			}
			return CameraEvent.BeforeReflections;
		}

		public override void PopulateCommandBuffer(CommandBuffer cb)
		{
			AmbientOcclusionModel.Settings settings = base.model.settings;
			Material mat = context.materialFactory.Get("Hidden/Post FX/Blit");
			Material material = context.materialFactory.Get("Hidden/Post FX/Ambient Occlusion");
			material.shaderKeywords = null;
			material.SetFloat(Uniforms._Intensity, settings.intensity);
			material.SetFloat(Uniforms._Radius, settings.radius);
			material.SetFloat(Uniforms._Downsample, settings.downsampling ? 0.5f : 1f);
			material.SetInt(Uniforms._SampleCount, (int)settings.sampleCount);
			if (!context.isGBufferAvailable && RenderSettings.fog)
			{
				material.SetVector(Uniforms._FogParams, new Vector3(RenderSettings.fogDensity, RenderSettings.fogStartDistance, RenderSettings.fogEndDistance));
				switch (RenderSettings.fogMode)
				{
				case FogMode.Linear:
					material.EnableKeyword("FOG_LINEAR");
					break;
				case FogMode.Exponential:
					material.EnableKeyword("FOG_EXP");
					break;
				case FogMode.ExponentialSquared:
					material.EnableKeyword("FOG_EXP2");
					break;
				}
			}
			else
			{
				material.EnableKeyword("FOG_OFF");
			}
			int width = context.width;
			int height = context.height;
			int num = ((!settings.downsampling) ? 1 : 2);
			int occlusionTexture = Uniforms._OcclusionTexture1;
			cb.GetTemporaryRT(occlusionTexture, width / num, height / num, 0, FilterMode.Bilinear, RenderTextureFormat.ARGB32, RenderTextureReadWrite.Linear);
			cb.Blit(null, occlusionTexture, material, (int)occlusionSource);
			int occlusionTexture2 = Uniforms._OcclusionTexture2;
			cb.GetTemporaryRT(occlusionTexture2, width, height, 0, FilterMode.Bilinear, RenderTextureFormat.ARGB32, RenderTextureReadWrite.Linear);
			cb.SetGlobalTexture(Uniforms._MainTex, occlusionTexture);
			cb.Blit(occlusionTexture, occlusionTexture2, material, (occlusionSource == OcclusionSource.GBuffer) ? 4 : 3);
			cb.ReleaseTemporaryRT(occlusionTexture);
			occlusionTexture = Uniforms._OcclusionTexture;
			cb.GetTemporaryRT(occlusionTexture, width, height, 0, FilterMode.Bilinear, RenderTextureFormat.ARGB32, RenderTextureReadWrite.Linear);
			cb.SetGlobalTexture(Uniforms._MainTex, occlusionTexture2);
			cb.Blit(occlusionTexture2, occlusionTexture, material, 5);
			cb.ReleaseTemporaryRT(occlusionTexture2);
			if (context.profile.debugViews.IsModeActive(BuiltinDebugViewsModel.Mode.AmbientOcclusion))
			{
				cb.SetGlobalTexture(Uniforms._MainTex, occlusionTexture);
				cb.Blit(occlusionTexture, BuiltinRenderTextureType.CameraTarget, material, 8);
				context.Interrupt();
			}
			else if (ambientOnlySupported)
			{
				cb.SetRenderTarget(m_MRT, BuiltinRenderTextureType.CameraTarget);
				cb.DrawMesh(GraphicsUtils.quad, Matrix4x4.identity, material, 0, 7);
			}
			else
			{
				RenderTextureFormat format = (context.isHdr ? RenderTextureFormat.DefaultHDR : RenderTextureFormat.Default);
				int tempRT = Uniforms._TempRT;
				cb.GetTemporaryRT(tempRT, context.width, context.height, 0, FilterMode.Bilinear, format);
				cb.Blit(BuiltinRenderTextureType.CameraTarget, tempRT, mat, 0);
				cb.SetGlobalTexture(Uniforms._MainTex, tempRT);
				cb.Blit(tempRT, BuiltinRenderTextureType.CameraTarget, material, 6);
				cb.ReleaseTemporaryRT(tempRT);
			}
			cb.ReleaseTemporaryRT(occlusionTexture);
		}
	}
	public sealed class BloomComponent : PostProcessingComponentRenderTexture<BloomModel>
	{
		private static class Uniforms
		{
			internal static readonly int _AutoExposure = Shader.PropertyToID("_AutoExposure");

			internal static readonly int _Threshold = Shader.PropertyToID("_Threshold");

			internal static readonly int _Curve = Shader.PropertyToID("_Curve");

			internal static readonly int _PrefilterOffs = Shader.PropertyToID("_PrefilterOffs");

			internal static readonly int _SampleScale = Shader.PropertyToID("_SampleScale");

			internal static readonly int _BaseTex = Shader.PropertyToID("_BaseTex");

			internal static readonly int _BloomTex = Shader.PropertyToID("_BloomTex");

			internal static readonly int _Bloom_Settings = Shader.PropertyToID("_Bloom_Settings");

			internal static readonly int _Bloom_DirtTex = Shader.PropertyToID("_Bloom_DirtTex");

			internal static readonly int _Bloom_DirtIntensity = Shader.PropertyToID("_Bloom_DirtIntensity");
		}

		private const int k_MaxPyramidBlurLevel = 16;

		private readonly RenderTexture[] m_BlurBuffer1 = new RenderTexture[16];

		private readonly RenderTexture[] m_BlurBuffer2 = new RenderTexture[16];

		public override bool active
		{
			get
			{
				if (base.model.enabled && base.model.settings.bloom.intensity > 0f)
				{
					return !context.interrupted;
				}
				return false;
			}
		}

		public void Prepare(RenderTexture source, Material uberMaterial, Texture autoExposure)
		{
			BloomModel.BloomSettings bloom = base.model.settings.bloom;
			BloomModel.LensDirtSettings lensDirt = base.model.settings.lensDirt;
			Material material = context.materialFactory.Get("Hidden/Post FX/Bloom");
			material.shaderKeywords = null;
			material.SetTexture(Uniforms._AutoExposure, autoExposure);
			int width = context.width / 2;
			int num = context.height / 2;
			RenderTextureFormat format = (Application.isMobilePlatform ? RenderTextureFormat.Default : RenderTextureFormat.DefaultHDR);
			float num2 = Mathf.Log(num, 2f) + bloom.radius - 8f;
			int num3 = (int)num2;
			int num4 = Mathf.Clamp(num3, 1, 16);
			float thresholdLinear = bloom.thresholdLinear;
			material.SetFloat(Uniforms._Threshold, thresholdLinear);
			float num5 = thresholdLinear * bloom.softKnee + 1E-05f;
			material.SetVector(value: new Vector3(thresholdLinear - num5, num5 * 2f, 0.25f / num5), nameID: Uniforms._Curve);
			material.SetFloat(Uniforms._PrefilterOffs, bloom.antiFlicker ? (-0.5f) : 0f);
			float num6 = 0.5f + num2 - (float)num3;
			material.SetFloat(Uniforms._SampleScale, num6);
			if (bloom.antiFlicker)
			{
				material.EnableKeyword("ANTI_FLICKER");
			}
			RenderTexture renderTexture = context.renderTextureFactory.Get(width, num, 0, format);
			Graphics.Blit(source, renderTexture, material, 0);
			RenderTexture renderTexture2 = renderTexture;
			for (int i = 0; i < num4; i++)
			{
				m_BlurBuffer1[i] = context.renderTextureFactory.Get(renderTexture2.width / 2, renderTexture2.height / 2, 0, format);
				int pass = ((i == 0) ? 1 : 2);
				Graphics.Blit(renderTexture2, m_BlurBuffer1[i], material, pass);
				renderTexture2 = m_BlurBuffer1[i];
			}
			for (int num7 = num4 - 2; num7 >= 0; num7--)
			{
				RenderTexture renderTexture3 = m_BlurBuffer1[num7];
				material.SetTexture(Uniforms._BaseTex, renderTexture3);
				m_BlurBuffer2[num7] = context.renderTextureFactory.Get(renderTexture3.width, renderTexture3.height, 0, format);
				Graphics.Blit(renderTexture2, m_BlurBuffer2[num7], material, 3);
				renderTexture2 = m_BlurBuffer2[num7];
			}
			RenderTexture renderTexture4 = renderTexture2;
			for (int j = 0; j < 16; j++)
			{
				if (m_BlurBuffer1[j] != null)
				{
					context.renderTextureFactory.Release(m_BlurBuffer1[j]);
				}
				if (m_BlurBuffer2[j] != null && m_BlurBuffer2[j] != renderTexture4)
				{
					context.renderTextureFactory.Release(m_BlurBuffer2[j]);
				}
				m_BlurBuffer1[j] = null;
				m_BlurBuffer2[j] = null;
			}
			context.renderTextureFactory.Release(renderTexture);
			uberMaterial.SetTexture(Uniforms._BloomTex, renderTexture4);
			uberMaterial.SetVector(Uniforms._Bloom_Settings, new Vector2(num6, bloom.intensity));
			if (lensDirt.intensity > 0f && lensDirt.texture != null)
			{
				uberMaterial.SetTexture(Uniforms._Bloom_DirtTex, lensDirt.texture);
				uberMaterial.SetFloat(Uniforms._Bloom_DirtIntensity, lensDirt.intensity);
				uberMaterial.EnableKeyword("BLOOM_LENS_DIRT");
			}
			else
			{
				uberMaterial.EnableKeyword("BLOOM");
			}
		}
	}
	public sealed class BuiltinDebugViewsComponent : PostProcessingComponentCommandBuffer<BuiltinDebugViewsModel>
	{
		private static class Uniforms
		{
			internal static readonly int _DepthScale = Shader.PropertyToID("_DepthScale");

			internal static readonly int _TempRT = Shader.PropertyToID("_TempRT");

			internal static readonly int _Opacity = Shader.PropertyToID("_Opacity");

			internal static readonly int _MainTex = Shader.PropertyToID("_MainTex");

			internal static readonly int _TempRT2 = Shader.PropertyToID("_TempRT2");

			internal static readonly int _Amplitude = Shader.PropertyToID("_Amplitude");

			internal static readonly int _Scale = Shader.PropertyToID("_Scale");
		}

		private enum Pass
		{
			Depth,
			Normals,
			MovecOpacity,
			MovecImaging,
			MovecArrows
		}

		private class ArrowArray
		{
			public Mesh mesh { get; private set; }

			public int columnCount { get; private set; }

			public int rowCount { get; private set; }

			public void BuildMesh(int columns, int rows)
			{
				Vector3[] array = new Vector3[6]
				{
					new Vector3(0f, 0f, 0f),
					new Vector3(0f, 1f, 0f),
					new Vector3(0f, 1f, 0f),
					new Vector3(-1f, 1f, 0f),
					new Vector3(0f, 1f, 0f),
					new Vector3(1f, 1f, 0f)
				};
				int num = 6 * columns * rows;
				List<Vector3> list = new List<Vector3>(num);
				List<Vector2> list2 = new List<Vector2>(num);
				for (int i = 0; i < rows; i++)
				{
					for (int j = 0; j < columns; j++)
					{
						Vector2 item = new Vector2((0.5f + (float)j) / (float)columns, (0.5f + (float)i) / (float)rows);
						for (int k = 0; k < 6; k++)
						{
							list.Add(array[k]);
							list2.Add(item);
						}
					}
				}
				int[] array2 = new int[num];
				for (int l = 0; l < num; l++)
				{
					array2[l] = l;
				}
				mesh = new Mesh
				{
					hideFlags = HideFlags.DontSave
				};
				mesh.SetVertices(list);
				mesh.SetUVs(0, list2);
				mesh.SetIndices(array2, MeshTopology.Lines, 0);
				mesh.UploadMeshData(markNoLongerReadable: true);
				columnCount = columns;
				rowCount = rows;
			}

			public void Release()
			{
				GraphicsUtils.Destroy(mesh);
				mesh = null;
			}
		}

		private const string k_ShaderString = "Hidden/Post FX/Builtin Debug Views";

		private ArrowArray m_Arrows;

		public override bool active
		{
			get
			{
				if (!base.model.IsModeActive(BuiltinDebugViewsModel.Mode.Depth) && !base.model.IsModeActive(BuiltinDebugViewsModel.Mode.Normals))
				{
					return base.model.IsModeActive(BuiltinDebugViewsModel.Mode.MotionVectors);
				}
				return true;
			}
		}

		public override DepthTextureMode GetCameraFlags()
		{
			BuiltinDebugViewsModel.Mode mode = base.model.settings.mode;
			DepthTextureMode depthTextureMode = DepthTextureMode.None;
			switch (mode)
			{
			case BuiltinDebugViewsModel.Mode.Normals:
				depthTextureMode |= DepthTextureMode.DepthNormals;
				break;
			case BuiltinDebugViewsModel.Mode.MotionVectors:
				depthTextureMode |= DepthTextureMode.Depth | DepthTextureMode.MotionVectors;
				break;
			case BuiltinDebugViewsModel.Mode.Depth:
				depthTextureMode |= DepthTextureMode.Depth;
				break;
			}
			return depthTextureMode;
		}

		public override CameraEvent GetCameraEvent()
		{
			if (base.model.settings.mode != BuiltinDebugViewsModel.Mode.MotionVectors)
			{
				return CameraEvent.BeforeImageEffectsOpaque;
			}
			return CameraEvent.BeforeImageEffects;
		}

		public override string GetName()
		{
			return "Builtin Debug Views";
		}

		public override void PopulateCommandBuffer(CommandBuffer cb)
		{
			BuiltinDebugViewsModel.Settings settings = base.model.settings;
			Material material = context.materialFactory.Get("Hidden/Post FX/Builtin Debug Views");
			material.shaderKeywords = null;
			if (context.isGBufferAvailable)
			{
				material.EnableKeyword("SOURCE_GBUFFER");
			}
			switch (settings.mode)
			{
			case BuiltinDebugViewsModel.Mode.Depth:
				DepthPass(cb);
				break;
			case BuiltinDebugViewsModel.Mode.Normals:
				DepthNormalsPass(cb);
				break;
			case BuiltinDebugViewsModel.Mode.MotionVectors:
				MotionVectorsPass(cb);
				break;
			}
			context.Interrupt();
		}

		private void DepthPass(CommandBuffer cb)
		{
			Material mat = context.materialFactory.Get("Hidden/Post FX/Builtin Debug Views");
			BuiltinDebugViewsModel.DepthSettings depth = base.model.settings.depth;
			cb.SetGlobalFloat(Uniforms._DepthScale, 1f / depth.scale);
			cb.Blit(null, BuiltinRenderTextureType.CameraTarget, mat, 0);
		}

		private void DepthNormalsPass(CommandBuffer cb)
		{
			Material mat = context.materialFactory.Get("Hidden/Post FX/Builtin Debug Views");
			cb.Blit(null, BuiltinRenderTextureType.CameraTarget, mat, 1);
		}

		private void MotionVectorsPass(CommandBuffer cb)
		{
			Material material = context.materialFactory.Get("Hidden/Post FX/Builtin Debug Views");
			BuiltinDebugViewsModel.MotionVectorsSettings motionVectors = base.model.settings.motionVectors;
			int num = Uniforms._TempRT;
			cb.GetTemporaryRT(num, context.width, context.height, 0, FilterMode.Bilinear);
			cb.SetGlobalFloat(Uniforms._Opacity, motionVectors.sourceOpacity);
			cb.SetGlobalTexture(Uniforms._MainTex, BuiltinRenderTextureType.CameraTarget);
			cb.Blit(BuiltinRenderTextureType.CameraTarget, num, material, 2);
			if (motionVectors.motionImageOpacity > 0f && motionVectors.motionImageAmplitude > 0f)
			{
				int tempRT = Uniforms._TempRT2;
				cb.GetTemporaryRT(tempRT, context.width, context.height, 0, FilterMode.Bilinear);
				cb.SetGlobalFloat(Uniforms._Opacity, motionVectors.motionImageOpacity);
				cb.SetGlobalFloat(Uniforms._Amplitude, motionVectors.motionImageAmplitude);
				cb.SetGlobalTexture(Uniforms._MainTex, num);
				cb.Blit(num, tempRT, material, 3);
				cb.ReleaseTemporaryRT(num);
				num = tempRT;
			}
			if (motionVectors.motionVectorsOpacity > 0f && motionVectors.motionVectorsAmplitude > 0f)
			{
				PrepareArrows();
				float num2 = 1f / (float)motionVectors.motionVectorsResolution;
				float x = num2 * (float)context.height / (float)context.width;
				cb.SetGlobalVector(Uniforms._Scale, new Vector2(x, num2));
				cb.SetGlobalFloat(Uniforms._Opacity, motionVectors.motionVectorsOpacity);
				cb.SetGlobalFloat(Uniforms._Amplitude, motionVectors.motionVectorsAmplitude);
				cb.DrawMesh(m_Arrows.mesh, Matrix4x4.identity, material, 0, 4);
			}
			cb.SetGlobalTexture(Uniforms._MainTex, num);
			cb.Blit(num, BuiltinRenderTextureType.CameraTarget);
			cb.ReleaseTemporaryRT(num);
		}

		private void PrepareArrows()
		{
			int motionVectorsResolution = base.model.settings.motionVectors.motionVectorsResolution;
			int num = motionVectorsResolution * Screen.width / Screen.height;
			if (m_Arrows == null)
			{
				m_Arrows = new ArrowArray();
			}
			if (m_Arrows.columnCount != num || m_Arrows.rowCount != motionVectorsResolution)
			{
				m_Arrows.Release();
				m_Arrows.BuildMesh(num, motionVectorsResolution);
			}
		}

		public override void OnDisable()
		{
			if (m_Arrows != null)
			{
				m_Arrows.Release();
			}
			m_Arrows = null;
		}
	}
	public sealed class ChromaticAberrationComponent : PostProcessingComponentRenderTexture<ChromaticAberrationModel>
	{
		private static class Uniforms
		{
			internal static readonly int _ChromaticAberration_Amount = Shader.PropertyToID("_ChromaticAberration_Amount");

			internal static readonly int _ChromaticAberration_Spectrum = Shader.PropertyToID("_ChromaticAberration_Spectrum");
		}

		private Texture2D m_SpectrumLut;

		public override bool active
		{
			get
			{
				if (base.model.enabled && base.model.settings.intensity > 0f)
				{
					return !context.interrupted;
				}
				return false;
			}
		}

		public override void OnDisable()
		{
			GraphicsUtils.Destroy(m_SpectrumLut);
			m_SpectrumLut = null;
		}

		public override void Prepare(Material uberMaterial)
		{
			ChromaticAberrationModel.Settings settings = base.model.settings;
			Texture2D texture2D = settings.spectralTexture;
			if (texture2D == null)
			{
				if (m_SpectrumLut == null)
				{
					m_SpectrumLut = new Texture2D(3, 1, TextureFormat.RGB24, mipChain: false)
					{
						name = "Chromatic Aberration Spectrum Lookup",
						filterMode = FilterMode.Bilinear,
						wrapMode = TextureWrapMode.Clamp,
						anisoLevel = 0,
						hideFlags = HideFlags.DontSave
					};
					Color[] pixels = new Color[3]
					{
						new Color(1f, 0f, 0f),
						new Color(0f, 1f, 0f),
						new Color(0f, 0f, 1f)
					};
					m_SpectrumLut.SetPixels(pixels);
					m_SpectrumLut.Apply();
				}
				texture2D = m_SpectrumLut;
			}
			uberMaterial.EnableKeyword("CHROMATIC_ABERRATION");
			uberMaterial.SetFloat(Uniforms._ChromaticAberration_Amount, settings.intensity * 0.03f);
			uberMaterial.SetTexture(Uniforms._ChromaticAberration_Spectrum, texture2D);
		}
	}
	public sealed class ColorGradingComponent : PostProcessingComponentRenderTexture<ColorGradingModel>
	{
		private static class Uniforms
		{
			internal static readonly int _LutParams = Shader.PropertyToID("_LutParams");

			internal static readonly int _NeutralTonemapperParams1 = Shader.PropertyToID("_NeutralTonemapperParams1");

			internal static readonly int _NeutralTonemapperParams2 = Shader.PropertyToID("_NeutralTonemapperParams2");

			internal static readonly int _HueShift = Shader.PropertyToID("_HueShift");

			internal static readonly int _Saturation = Shader.PropertyToID("_Saturation");

			internal static readonly int _Contrast = Shader.PropertyToID("_Contrast");

			internal static readonly int _Balance = Shader.PropertyToID("_Balance");

			internal static readonly int _Lift = Shader.PropertyToID("_Lift");

			internal static readonly int _InvGamma = Shader.PropertyToID("_InvGamma");

			internal static readonly int _Gain = Shader.PropertyToID("_Gain");

			internal static readonly int _Slope = Shader.PropertyToID("_Slope");

			internal static readonly int _Power = Shader.PropertyToID("_Power");

			internal static readonly int _Offset = Shader.PropertyToID("_Offset");

			internal static readonly int _ChannelMixerRed = Shader.PropertyToID("_ChannelMixerRed");

			internal static readonly int _ChannelMixerGreen = Shader.PropertyToID("_ChannelMixerGreen");

			internal static readonly int _ChannelMixerBlue = Shader.PropertyToID("_ChannelMixerBlue");

			internal static readonly int _Curves = Shader.PropertyToID("_Curves");

			internal static readonly int _LogLut = Shader.PropertyToID("_LogLut");

			internal static readonly int _LogLut_Params = Shader.PropertyToID("_LogLut_Params");

			internal static readonly int _ExposureEV = Shader.PropertyToID("_ExposureEV");
		}

		private const int k_InternalLogLutSize = 32;

		private const int k_CurvePrecision = 128;

		private const float k_CurveStep = 1f / 128f;

		private Texture2D m_GradingCurves;

		private Color[] m_pixels = new Color[256];

		public override bool active
		{
			get
			{
				if (base.model.enabled)
				{
					return !context.interrupted;
				}
				return false;
			}
		}

		private float StandardIlluminantY(float x)
		{
			return 2.87f * x - 3f * x * x - 0.27509508f;
		}

		private Vector3 CIExyToLMS(float x, float y)
		{
			float num = 1f;
			float num2 = num * x / y;
			float num3 = num * (1f - x - y) / y;
			float x2 = 0.7328f * num2 + 0.4296f * num - 0.1624f * num3;
			float y2 = -0.7036f * num2 + 1.6975f * num + 0.0061f * num3;
			float z = 0.003f * num2 + 0.0136f * num + 0.9834f * num3;
			return new Vector3(x2, y2, z);
		}

		private Vector3 CalculateColorBalance(float temperature, float tint)
		{
			float num = temperature / 55f;
			float num2 = tint / 55f;
			float x = 0.31271f - num * ((num < 0f) ? 0.1f : 0.05f);
			float y = StandardIlluminantY(x) + num2 * 0.05f;
			Vector3 vector = new Vector3(0.949237f, 1.03542f, 1.08728f);
			Vector3 vector2 = CIExyToLMS(x, y);
			return new Vector3(vector.x / vector2.x, vector.y / vector2.y, vector.z / vector2.z);
		}

		private static Color NormalizeColor(Color c)
		{
			float num = (c.r + c.g + c.b) / 3f;
			if (Mathf.Approximately(num, 0f))
			{
				return new Color(1f, 1f, 1f, c.a);
			}
			Color result = default(Color);
			result.r = c.r / num;
			result.g = c.g / num;
			result.b = c.b / num;
			result.a = c.a;
			return result;
		}

		private static Vector3 ClampVector(Vector3 v, float min, float max)
		{
			return new Vector3(Mathf.Clamp(v.x, min, max), Mathf.Clamp(v.y, min, max), Mathf.Clamp(v.z, min, max));
		}

		public static Vector3 GetLiftValue(Color lift)
		{
			Color color = NormalizeColor(lift);
			float num = (color.r + color.g + color.b) / 3f;
			float x = (color.r - num) * 0.1f + lift.a;
			float y = (color.g - num) * 0.1f + lift.a;
			float z = (color.b - num) * 0.1f + lift.a;
			return ClampVector(new Vector3(x, y, z), -1f, 1f);
		}

		public static Vector3 GetGammaValue(Color gamma)
		{
			Color color = NormalizeColor(gamma);
			float num = (color.r + color.g + color.b) / 3f;
			gamma.a *= ((gamma.a < 0f) ? 0.8f : 5f);
			float b = Mathf.Pow(2f, (color.r - num) * 0.5f) + gamma.a;
			float b2 = Mathf.Pow(2f, (color.g - num) * 0.5f) + gamma.a;
			float b3 = Mathf.Pow(2f, (color.b - num) * 0.5f) + gamma.a;
			float x = 1f / Mathf.Max(0.01f, b);
			float y = 1f / Mathf.Max(0.01f, b2);
			float z = 1f / Mathf.Max(0.01f, b3);
			return ClampVector(new Vector3(x, y, z), 0f, 5f);
		}

		public static Vector3 GetGainValue(Color gain)
		{
			Color color = NormalizeColor(gain);
			float num = (color.r + color.g + color.b) / 3f;
			gain.a *= ((gain.a > 0f) ? 3f : 1f);
			float x = Mathf.Pow(2f, (color.r - num) * 0.5f) + gain.a;
			float y = Mathf.Pow(2f, (color.g - num) * 0.5f) + gain.a;
			float z = Mathf.Pow(2f, (color.b - num) * 0.5f) + gain.a;
			return ClampVector(new Vector3(x, y, z), 0f, 4f);
		}

		public static void CalculateLiftGammaGain(Color lift, Color gamma, Color gain, out Vector3 outLift, out Vector3 outGamma, out Vector3 outGain)
		{
			outLift = GetLiftValue(lift);
			outGamma = GetGammaValue(gamma);
			outGain = GetGainValue(gain);
		}

		public static Vector3 GetSlopeValue(Color slope)
		{
			Color color = NormalizeColor(slope);
			float num = (color.r + color.g + color.b) / 3f;
			slope.a *= 0.5f;
			float x = (color.r - num) * 0.1f + slope.a + 1f;
			float y = (color.g - num) * 0.1f + slope.a + 1f;
			float z = (color.b - num) * 0.1f + slope.a + 1f;
			return ClampVector(new Vector3(x, y, z), 0f, 2f);
		}

		public static Vector3 GetPowerValue(Color power)
		{
			Color color = NormalizeColor(power);
			float num = (color.r + color.g + color.b) / 3f;
			power.a *= 0.5f;
			float b = (color.r - num) * 0.1f + power.a + 1f;
			float b2 = (color.g - num) * 0.1f + power.a + 1f;
			float b3 = (color.b - num) * 0.1f + power.a + 1f;
			float x = 1f / Mathf.Max(0.01f, b);
			float y = 1f / Mathf.Max(0.01f, b2);
			float z = 1f / Mathf.Max(0.01f, b3);
			return ClampVector(new Vector3(x, y, z), 0.5f, 2.5f);
		}

		public static Vector3 GetOffsetValue(Color offset)
		{
			Color color = NormalizeColor(offset);
			float num = (color.r + color.g + color.b) / 3f;
			offset.a *= 0.5f;
			float x = (color.r - num) * 0.05f + offset.a;
			float y = (color.g - num) * 0.05f + offset.a;
			float z = (color.b - num) * 0.05f + offset.a;
			return ClampVector(new Vector3(x, y, z), -0.8f, 0.8f);
		}

		public static void CalculateSlopePowerOffset(Color slope, Color power, Color offset, out Vector3 outSlope, out Vector3 outPower, out Vector3 outOffset)
		{
			outSlope = GetSlopeValue(slope);
			outPower = GetPowerValue(power);
			outOffset = GetOffsetValue(offset);
		}

		private TextureFormat GetCurveFormat()
		{
			if (SystemInfo.SupportsTextureFormat(TextureFormat.RGBAHalf))
			{
				return TextureFormat.RGBAHalf;
			}
			return TextureFormat.RGBA32;
		}

		private Texture2D GetCurveTexture()
		{
			if (m_GradingCurves == null)
			{
				m_GradingCurves = new Texture2D(128, 2, GetCurveFormat(), mipChain: false, linear: true)
				{
					name = "Internal Curves Texture",
					hideFlags = HideFlags.DontSave,
					anisoLevel = 0,
					wrapMode = TextureWrapMode.Clamp,
					filterMode = FilterMode.Bilinear
				};
			}
			ColorGradingModel.CurvesSettings curves = base.model.settings.curves;
			curves.hueVShue.Cache();
			curves.hueVSsat.Cache();
			for (int i = 0; i < 128; i++)
			{
				float t = (float)i * (1f / 128f);
				float r = curves.hueVShue.Evaluate(t);
				float g = curves.hueVSsat.Evaluate(t);
				float b = curves.satVSsat.Evaluate(t);
				float a = curves.lumVSsat.Evaluate(t);
				m_pixels[i] = new Color(r, g, b, a);
				float a2 = curves.master.Evaluate(t);
				float r2 = curves.red.Evaluate(t);
				float g2 = curves.green.Evaluate(t);
				float b2 = curves.blue.Evaluate(t);
				m_pixels[i + 128] = new Color(r2, g2, b2, a2);
			}
			m_GradingCurves.SetPixels(m_pixels);
			m_GradingCurves.Apply(updateMipmaps: false, makeNoLongerReadable: false);
			return m_GradingCurves;
		}

		private bool IsLogLutValid(RenderTexture lut)
		{
			if (lut != null && lut.IsCreated())
			{
				return lut.height == 32;
			}
			return false;
		}

		private RenderTextureFormat GetLutFormat()
		{
			if (SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.ARGBHalf))
			{
				return RenderTextureFormat.ARGBHalf;
			}
			return RenderTextureFormat.ARGB32;
		}

		private void GenerateLut()
		{
			ColorGradingModel.Settings settings = base.model.settings;
			if (!IsLogLutValid(base.model.bakedLut))
			{
				GraphicsUtils.Destroy(base.model.bakedLut);
				base.model.bakedLut = new RenderTexture(1024, 32, 0, GetLutFormat())
				{
					name = "Color Grading Log LUT",
					hideFlags = HideFlags.DontSave,
					filterMode = FilterMode.Bilinear,
					wrapMode = TextureWrapMode.Clamp,
					anisoLevel = 0
				};
			}
			Material material = context.materialFactory.Get("Hidden/Post FX/Lut Generator");
			material.SetVector(Uniforms._LutParams, new Vector4(32f, 0.00048828125f, 1f / 64f, 1.032258f));
			material.shaderKeywords = null;
			ColorGradingModel.TonemappingSettings tonemapping = settings.tonemapping;
			switch (tonemapping.tonemapper)
			{
			case ColorGradingModel.Tonemapper.Neutral:
			{
				material.EnableKeyword("TONEMAPPING_NEUTRAL");
				float num = tonemapping.neutralBlackIn * 20f + 1f;
				float num2 = tonemapping.neutralBlackOut * 10f + 1f;
				float num3 = tonemapping.neutralWhiteIn / 20f;
				float num4 = 1f - tonemapping.neutralWhiteOut / 20f;
				float t = num / num2;
				float t2 = num3 / num4;
				float y = Mathf.Max(0f, Mathf.LerpUnclamped(0.57f, 0.37f, t));
				float z = Mathf.LerpUnclamped(0.01f, 0.24f, t2);
				float w = Mathf.Max(0f, Mathf.LerpUnclamped(0.02f, 0.2f, t));
				material.SetVector(Uniforms._NeutralTonemapperParams1, new Vector4(0.2f, y, z, w));
				material.SetVector(Uniforms._NeutralTonemapperParams2, new Vector4(0.02f, 0.3f, tonemapping.neutralWhiteLevel, tonemapping.neutralWhiteClip / 10f));
				break;
			}
			case ColorGradingModel.Tonemapper.ACES:
				material.EnableKeyword("TONEMAPPING_FILMIC");
				break;
			}
			material.SetFloat(Uniforms._HueShift, settings.basic.hueShift / 360f);
			material.SetFloat(Uniforms._Saturation, settings.basic.saturation);
			material.SetFloat(Uniforms._Contrast, settings.basic.contrast);
			material.SetVector(Uniforms._Balance, CalculateColorBalance(settings.basic.temperature, settings.basic.tint));
			CalculateLiftGammaGain(settings.colorWheels.linear.lift, settings.colorWheels.linear.gamma, settings.colorWheels.linear.gain, out var outLift, out var outGamma, out var outGain);
			material.SetVector(Uniforms._Lift, outLift);
			material.SetVector(Uniforms._InvGamma, outGamma);
			material.SetVector(Uniforms._Gain, outGain);
			CalculateSlopePowerOffset(settings.colorWheels.log.slope, settings.colorWheels.log.power, settings.colorWheels.log.offset, out var outSlope, out var outPower, out var outOffset);
			material.SetVector(Uniforms._Slope, outSlope);
			material.SetVector(Uniforms._Power, outPower);
			material.SetVector(Uniforms._Offset, outOffset);
			material.SetVector(Uniforms._ChannelMixerRed, settings.channelMixer.red);
			material.SetVector(Uniforms._ChannelMixerGreen, settings.channelMixer.green);
			material.SetVector(Uniforms._ChannelMixerBlue, settings.channelMixer.blue);
			material.SetTexture(Uniforms._Curves, GetCurveTexture());
			Graphics.Blit(null, base.model.bakedLut, material, 0);
		}

		public override void Prepare(Material uberMaterial)
		{
			if (base.model.isDirty || !IsLogLutValid(base.model.bakedLut))
			{
				GenerateLut();
				base.model.isDirty = false;
			}
			uberMaterial.EnableKeyword(context.profile.debugViews.IsModeActive(BuiltinDebugViewsModel.Mode.PreGradingLog) ? "COLOR_GRADING_LOG_VIEW" : "COLOR_GRADING");
			RenderTexture bakedLut = base.model.bakedLut;
			uberMaterial.SetTexture(Uniforms._LogLut, bakedLut);
			uberMaterial.SetVector(Uniforms._LogLut_Params, new Vector3(1f / (float)bakedLut.width, 1f / (float)bakedLut.height, (float)bakedLut.height - 1f));
			float value = Mathf.Exp(base.model.settings.basic.postExposure * 0.6931472f);
			uberMaterial.SetFloat(Uniforms._ExposureEV, value);
		}

		public void OnGUI()
		{
			RenderTexture bakedLut = base.model.bakedLut;
			GUI.DrawTexture(new Rect(context.viewport.x * (float)Screen.width + 8f, 8f, bakedLut.width, bakedLut.height), bakedLut);
		}

		public override void OnDisable()
		{
			GraphicsUtils.Destroy(m_GradingCurves);
			GraphicsUtils.Destroy(base.model.bakedLut);
			m_GradingCurves = null;
			base.model.bakedLut = null;
		}
	}
	public sealed class DepthOfFieldComponent : PostProcessingComponentRenderTexture<DepthOfFieldModel>
	{
		private static class Uniforms
		{
			internal static readonly int _DepthOfFieldTex = Shader.PropertyToID("_DepthOfFieldTex");

			internal static readonly int _DepthOfFieldCoCTex = Shader.PropertyToID("_DepthOfFieldCoCTex");

			internal static readonly int _Distance = Shader.PropertyToID("_Distance");

			internal static readonly int _LensCoeff = Shader.PropertyToID("_LensCoeff");

			internal static readonly int _MaxCoC = Shader.PropertyToID("_MaxCoC");

			internal static readonly int _RcpMaxCoC = Shader.PropertyToID("_RcpMaxCoC");

			internal static readonly int _RcpAspect = Shader.PropertyToID("_RcpAspect");

			internal static readonly int _MainTex = Shader.PropertyToID("_MainTex");

			internal static readonly int _CoCTex = Shader.PropertyToID("_CoCTex");

			internal static readonly int _TaaParams = Shader.PropertyToID("_TaaParams");

			internal static readonly int _DepthOfFieldParams = Shader.PropertyToID("_DepthOfFieldParams");
		}

		private const string k_ShaderString = "Hidden/Post FX/Depth Of Field";

		private RenderTexture m_CoCHistory;

		private const float k_FilmHeight = 0.024f;

		public override bool active
		{
			get
			{
				if (base.model.enabled)
				{
					return !context.interrupted;
				}
				return false;
			}
		}

		public override DepthTextureMode GetCameraFlags()
		{
			return DepthTextureMode.Depth;
		}

		private float CalculateFocalLength()
		{
			DepthOfFieldModel.Settings settings = base.model.settings;
			if (!settings.useCameraFov)
			{
				return settings.focalLength / 1000f;
			}
			float num = context.camera.fieldOfView * ((float)Math.PI / 180f);
			return 0.012f / Mathf.Tan(0.5f * num);
		}

		private float CalculateMaxCoCRadius(int screenHeight)
		{
			float num = (float)base.model.settings.kernelSize * 4f + 6f;
			return Mathf.Min(0.05f, num / (float)screenHeight);
		}

		private bool CheckHistory(int width, int height)
		{
			if (m_CoCHistory != null && m_CoCHistory.IsCreated() && m_CoCHistory.width == width)
			{
				return m_CoCHistory.height == height;
			}
			return false;
		}

		private RenderTextureFormat SelectFormat(RenderTextureFormat primary, RenderTextureFormat secondary)
		{
			if (SystemInfo.SupportsRenderTextureFormat(primary))
			{
				return primary;
			}
			if (SystemInfo.SupportsRenderTextureFormat(secondary))
			{
				return secondary;
			}
			return RenderTextureFormat.Default;
		}

		public void Prepare(RenderTexture source, Material uberMaterial, bool antialiasCoC, Vector2 taaJitter, float taaBlending)
		{
			DepthOfFieldModel.Settings settings = base.model.settings;
			RenderTextureFormat format = RenderTextureFormat.DefaultHDR;
			RenderTextureFormat format2 = SelectFormat(RenderTextureFormat.R8, RenderTextureFormat.RHalf);
			float num = CalculateFocalLength();
			float num2 = Mathf.Max(settings.focusDistance, num);
			float num3 = (float)source.width / (float)source.height;
			float num4 = num * num / (settings.aperture * (num2 - num) * 0.024f * 2f);
			float num5 = CalculateMaxCoCRadius(source.height);
			Material material = context.materialFactory.Get("Hidden/Post FX/Depth Of Field");
			material.SetFloat(Uniforms._Distance, num2);
			material.SetFloat(Uniforms._LensCoeff, num4);
			material.SetFloat(Uniforms._MaxCoC, num5);
			material.SetFloat(Uniforms._RcpMaxCoC, 1f / num5);
			material.SetFloat(Uniforms._RcpAspect, 1f / num3);
			RenderTexture renderTexture = context.renderTextureFactory.Get(context.width, context.height, 0, format2, RenderTextureReadWrite.Linear);
			Graphics.Blit(null, renderTexture, material, 0);
			if (antialiasCoC)
			{
				material.SetTexture(Uniforms._CoCTex, renderTexture);
				float z = (CheckHistory(context.width, context.height) ? taaBlending : 0f);
				material.SetVector(Uniforms._TaaParams, new Vector3(taaJitter.x, taaJitter.y, z));
				RenderTexture temporary = RenderTexture.GetTemporary(context.width, context.height, 0, format2);
				Graphics.Blit(m_CoCHistory, temporary, material, 1);
				context.renderTextureFactory.Release(renderTexture);
				if (m_CoCHistory != null)
				{
					RenderTexture.ReleaseTemporary(m_CoCHistory);
				}
				renderTexture = (m_CoCHistory = temporary);
			}
			RenderTexture renderTexture2 = context.renderTextureFactory.Get(context.width / 2, context.height / 2, 0, format);
			material.SetTexture(Uniforms._CoCTex, renderTexture);
			Graphics.Blit(source, renderTexture2, material, 2);
			RenderTexture renderTexture3 = context.renderTextureFactory.Get(context.width / 2, context.height / 2, 0, format);
			Graphics.Blit(renderTexture2, renderTexture3, material, (int)(3 + settings.kernelSize));
			Graphics.Blit(renderTexture3, renderTexture2, material, 7);
			uberMaterial.SetVector(Uniforms._DepthOfFieldParams, new Vector3(num2, num4, num5));
			if (context.profile.debugViews.IsModeActive(BuiltinDebugViewsModel.Mode.FocusPlane))
			{
				uberMaterial.EnableKeyword("DEPTH_OF_FIELD_COC_VIEW");
				context.Interrupt();
			}
			else
			{
				uberMaterial.SetTexture(Uniforms._DepthOfFieldTex, renderTexture2);
				uberMaterial.SetTexture(Uniforms._DepthOfFieldCoCTex, renderTexture);
				uberMaterial.EnableKeyword("DEPTH_OF_FIELD");
			}
			context.renderTextureFactory.Release(renderTexture3);
		}

		public override void OnDisable()
		{
			if (m_CoCHistory != null)
			{
				RenderTexture.ReleaseTemporary(m_CoCHistory);
			}
			m_CoCHistory = null;
		}
	}
	public sealed class DitheringComponent : PostProcessingComponentRenderTexture<DitheringModel>
	{
		private static class Uniforms
		{
			internal static readonly int _DitheringTex = Shader.PropertyToID("_DitheringTex");

			internal static readonly int _DitheringCoords = Shader.PropertyToID("_DitheringCoords");
		}

		private Texture2D[] noiseTextures;

		private int textureIndex;

		private const int k_TextureCount = 64;

		public override bool active
		{
			get
			{
				if (base.model.enabled)
				{
					return !context.interrupted;
				}
				return false;
			}
		}

		public override void OnDisable()
		{
			noiseTextures = null;
		}

		private void LoadNoiseTextures()
		{
			noiseTextures = new Texture2D[64];
			for (int i = 0; i < 64; i++)
			{
				noiseTextures[i] = Resources.Load<Texture2D>("Bluenoise64/LDR_LLL1_" + i);
			}
		}

		public override void Prepare(Material uberMaterial)
		{
			if (++textureIndex >= 64)
			{
				textureIndex = 0;
			}
			float value = Random.value;
			float value2 = Random.value;
			if (noiseTextures == null)
			{
				LoadNoiseTextures();
			}
			Texture2D texture2D = noiseTextures[textureIndex];
			uberMaterial.EnableKeyword("DITHERING");
			uberMaterial.SetTexture(Uniforms._DitheringTex, texture2D);
			uberMaterial.SetVector(Uniforms._DitheringCoords, new Vector4((float)context.width / (float)texture2D.width, (float)context.height / (float)texture2D.height, value, value2));
		}
	}
	public sealed class EyeAdaptationComponent : PostProcessingComponentRenderTexture<EyeAdaptationModel>
	{
		private static class Uniforms
		{
			internal static readonly int _Params = Shader.PropertyToID("_Params");

			internal static readonly int _Speed = Shader.PropertyToID("_Speed");

			internal static readonly int _ScaleOffsetRes = Shader.PropertyToID("_ScaleOffsetRes");

			internal static readonly int _ExposureCompensation = Shader.PropertyToID("_ExposureCompensation");

			internal static readonly int _AutoExposure = Shader.PropertyToID("_AutoExposure");

			internal static readonly int _DebugWidth = Shader.PropertyToID("_DebugWidth");
		}

		private ComputeShader m_EyeCompute;

		private ComputeBuffer m_HistogramBuffer;

		private readonly RenderTexture[] m_AutoExposurePool = new RenderTexture[2];

		private int m_AutoExposurePingPing;

		private RenderTexture m_CurrentAutoExposure;

		private RenderTexture m_DebugHistogram;

		private static uint[] s_EmptyHistogramBuffer;

		private bool m_FirstFrame = true;

		private const int k_HistogramBins = 64;

		private const int k_HistogramThreadX = 16;

		private const int k_HistogramThreadY = 16;

		public override bool active
		{
			get
			{
				if (base.model.enabled && SystemInfo.supportsComputeShaders)
				{
					return !context.interrupted;
				}
				return false;
			}
		}

		public void ResetHistory()
		{
			m_FirstFrame = true;
		}

		public override void OnEnable()
		{
			m_FirstFrame = true;
		}

		public override void OnDisable()
		{
			RenderTexture[] autoExposurePool = m_AutoExposurePool;
			for (int i = 0; i < autoExposurePool.Length; i++)
			{
				GraphicsUtils.Destroy(autoExposurePool[i]);
			}
			if (m_HistogramBuffer != null)
			{
				m_HistogramBuffer.Release();
			}
			m_HistogramBuffer = null;
			if (m_DebugHistogram != null)
			{
				m_DebugHistogram.Release();
			}
			m_DebugHistogram = null;
		}

		private Vector4 GetHistogramScaleOffsetRes()
		{
			EyeAdaptationModel.Settings settings = base.model.settings;
			float num = settings.logMax - settings.logMin;
			float num2 = 1f / num;
			float y = (float)(-settings.logMin) * num2;
			return new Vector4(num2, y, Mathf.Floor((float)context.width / 2f), Mathf.Floor((float)context.height / 2f));
		}

		public Texture Prepare(RenderTexture source, Material uberMaterial)
		{
			EyeAdaptationModel.Settings settings = base.model.settings;
			if (m_EyeCompute == null)
			{
				m_EyeCompute = Resources.Load<ComputeShader>("Shaders/EyeHistogram");
			}
			Material material = context.materialFactory.Get("Hidden/Post FX/Eye Adaptation");
			material.shaderKeywords = null;
			if (m_HistogramBuffer == null)
			{
				m_HistogramBuffer = new ComputeBuffer(64, 4);
			}
			if (s_EmptyHistogramBuffer == null)
			{
				s_EmptyHistogramBuffer = new uint[64];
			}
			Vector4 histogramScaleOffsetRes = GetHistogramScaleOffsetRes();
			RenderTexture renderTexture = context.renderTextureFactory.Get((int)histogramScaleOffsetRes.z, (int)histogramScaleOffsetRes.w, 0, source.format);
			Graphics.Blit(source, renderTexture);
			if (m_AutoExposurePool[0] == null || !m_AutoExposurePool[0].IsCreated())
			{
				m_AutoExposurePool[0] = new RenderTexture(1, 1, 0, RenderTextureFormat.RFloat);
			}
			if (m_AutoExposurePool[1] == null || !m_AutoExposurePool[1].IsCreated())
			{
				m_AutoExposurePool[1] = new RenderTexture(1, 1, 0, RenderTextureFormat.RFloat);
			}
			m_HistogramBuffer.SetData(s_EmptyHistogramBuffer);
			int kernelIndex = m_EyeCompute.FindKernel("KEyeHistogram");
			m_EyeCompute.SetBuffer(kernelIndex, "_Histogram", m_HistogramBuffer);
			m_EyeCompute.SetTexture(kernelIndex, "_Source", renderTexture);
			m_EyeCompute.SetVector("_ScaleOffsetRes", histogramScaleOffsetRes);
			m_EyeCompute.Dispatch(kernelIndex, Mathf.CeilToInt((float)renderTexture.width / 16f), Mathf.CeilToInt((float)renderTexture.height / 16f), 1);
			context.renderTextureFactory.Release(renderTexture);
			settings.highPercent = Mathf.Clamp(settings.highPercent, 1.01f, 99f);
			settings.lowPercent = Mathf.Clamp(settings.lowPercent, 1f, settings.highPercent - 0.01f);
			material.SetBuffer("_Histogram", m_HistogramBuffer);
			material.SetVector(Uniforms._Params, new Vector4(settings.lowPercent * 0.01f, settings.highPercent * 0.01f, Mathf.Exp(settings.minLuminance * 0.6931472f), Mathf.Exp(settings.maxLuminance * 0.6931472f)));
			material.SetVector(Uniforms._Speed, new Vector2(settings.speedDown, settings.speedUp));
			material.SetVector(Uniforms._ScaleOffsetRes, histogramScaleOffsetRes);
			material.SetFloat(Uniforms._ExposureCompensation, settings.keyValue);
			if (settings.dynamicKeyValue)
			{
				material.EnableKeyword("AUTO_KEY_VALUE");
			}
			if (m_FirstFrame || !Application.isPlaying)
			{
				m_CurrentAutoExposure = m_AutoExposurePool[0];
				Graphics.Blit(null, m_CurrentAutoExposure, material, 1);
				Graphics.Blit(m_AutoExposurePool[0], m_AutoExposurePool[1]);
			}
			else
			{
				int autoExposurePingPing = m_AutoExposurePingPing;
				RenderTexture source2 = m_AutoExposurePool[++autoExposurePingPing % 2];
				RenderTexture renderTexture2 = m_AutoExposurePool[++autoExposurePingPing % 2];
				Graphics.Blit(source2, renderTexture2, material, (int)settings.adaptationType);
				m_AutoExposurePingPing = ++autoExposurePingPing % 2;
				m_CurrentAutoExposure = renderTexture2;
			}
			if (context.profile.debugViews.IsModeActive(BuiltinDebugViewsModel.Mode.EyeAdaptation))
			{
				if (m_DebugHistogram == null || !m_DebugHistogram.IsCreated())
				{
					m_DebugHistogram = new RenderTexture(256, 128, 0, RenderTextureFormat.ARGB32)
					{
						filterMode = FilterMode.Point,
						wrapMode = TextureWrapMode.Clamp
					};
				}
				material.SetFloat(Uniforms._DebugWidth, m_DebugHistogram.width);
				Graphics.Blit(null, m_DebugHistogram, material, 2);
			}
			m_FirstFrame = false;
			return m_CurrentAutoExposure;
		}

		public void OnGUI()
		{
			if (!(m_DebugHistogram == null) && m_DebugHistogram.IsCreated())
			{
				GUI.DrawTexture(new Rect(context.viewport.x * (float)Screen.width + 8f, 8f, m_DebugHistogram.width, m_DebugHistogram.height), m_DebugHistogram);
			}
		}
	}
	public sealed class FogComponent : PostProcessingComponentCommandBuffer<FogModel>
	{
		private static class Uniforms
		{
			internal static readonly int _FogColor = Shader.PropertyToID("_FogColor");

			internal static readonly int _Density = Shader.PropertyToID("_Density");

			internal static readonly int _Start = Shader.PropertyToID("_Start");

			internal static readonly int _End = Shader.PropertyToID("_End");

			internal static readonly int _TempRT = Shader.PropertyToID("_TempRT");
		}

		private const string k_ShaderString = "Hidden/Post FX/Fog";

		public override bool active
		{
			get
			{
				if (base.model.enabled && context.isGBufferAvailable && RenderSettings.fog)
				{
					return !context.interrupted;
				}
				return false;
			}
		}

		public override string GetName()
		{
			return "Fog";
		}

		public override DepthTextureMode GetCameraFlags()
		{
			return DepthTextureMode.Depth;
		}

		public override CameraEvent GetCameraEvent()
		{
			return CameraEvent.AfterImageEffectsOpaque;
		}

		public override void PopulateCommandBuffer(CommandBuffer cb)
		{
			FogModel.Settings settings = base.model.settings;
			Material material = context.materialFactory.Get("Hidden/Post FX/Fog");
			material.shaderKeywords = null;
			Color value = (GraphicsUtils.isLinearColorSpace ? RenderSettings.fogColor.linear : RenderSettings.fogColor);
			material.SetColor(Uniforms._FogColor, value);
			material.SetFloat(Uniforms._Density, RenderSettings.fogDensity);
			material.SetFloat(Uniforms._Start, RenderSettings.fogStartDistance);
			material.SetFloat(Uniforms._End, RenderSettings.fogEndDistance);
			switch (RenderSettings.fogMode)
			{
			case FogMode.Linear:
				material.EnableKeyword("FOG_LINEAR");
				break;
			case FogMode.Exponential:
				material.EnableKeyword("FOG_EXP");
				break;
			case FogMode.ExponentialSquared:
				material.EnableKeyword("FOG_EXP2");
				break;
			}
			RenderTextureFormat format = (context.isHdr ? RenderTextureFormat.DefaultHDR : RenderTextureFormat.Default);
			cb.GetTemporaryRT(Uniforms._TempRT, context.width, context.height, 24, FilterMode.Bilinear, format);
			cb.Blit(BuiltinRenderTextureType.CameraTarget, Uniforms._TempRT);
			cb.Blit(Uniforms._TempRT, BuiltinRenderTextureType.CameraTarget, material, settings.excludeSkybox ? 1 : 0);
			cb.ReleaseTemporaryRT(Uniforms._TempRT);
		}
	}
	public sealed class FxaaComponent : PostProcessingComponentRenderTexture<AntialiasingModel>
	{
		private static class Uniforms
		{
			internal static readonly int _QualitySettings = Shader.PropertyToID("_QualitySettings");

			internal static readonly int _ConsoleSettings = Shader.PropertyToID("_ConsoleSettings");
		}

		public override bool active
		{
			get
			{
				if (base.model.enabled && base.model.settings.method == AntialiasingModel.Method.Fxaa)
				{
					return !context.interrupted;
				}
				return false;
			}
		}

		public void Render(RenderTexture source, RenderTexture destination)
		{
			AntialiasingModel.FxaaSettings fxaaSettings = base.model.settings.fxaaSettings;
			Material material = context.materialFactory.Get("Hidden/Post FX/FXAA");
			AntialiasingModel.FxaaQualitySettings fxaaQualitySettings = AntialiasingModel.FxaaQualitySettings.presets[(int)fxaaSettings.preset];
			AntialiasingModel.FxaaConsoleSettings fxaaConsoleSettings = AntialiasingModel.FxaaConsoleSettings.presets[(int)fxaaSettings.preset];
			material.SetVector(Uniforms._QualitySettings, new Vector3(fxaaQualitySettings.subpixelAliasingRemovalAmount, fxaaQualitySettings.edgeDetectionThreshold, fxaaQualitySettings.minimumRequiredLuminance));
			material.SetVector(Uniforms._ConsoleSettings, new Vector4(fxaaConsoleSettings.subpixelSpreadAmount, fxaaConsoleSettings.edgeSharpnessAmount, fxaaConsoleSettings.edgeDetectionThreshold, fxaaConsoleSettings.minimumRequiredLuminance));
			Graphics.Blit(source, destination, material, 0);
		}
	}
	public sealed class GrainComponent : PostProcessingComponentRenderTexture<GrainModel>
	{
		private static class Uniforms
		{
			internal static readonly int _Grain_Params1 = Shader.PropertyToID("_Grain_Params1");

			internal static readonly int _Grain_Params2 = Shader.PropertyToID("_Grain_Params2");

			internal static readonly int _GrainTex = Shader.PropertyToID("_GrainTex");

			internal static readonly int _Phase = Shader.PropertyToID("_Phase");
		}

		private RenderTexture m_GrainLookupRT;

		public override bool active
		{
			get
			{
				if (base.model.enabled && base.model.settings.intensity > 0f && SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.ARGBHalf))
				{
					return !context.interrupted;
				}
				return false;
			}
		}

		public override void OnDisable()
		{
			GraphicsUtils.Destroy(m_GrainLookupRT);
			m_GrainLookupRT = null;
		}

		public override void Prepare(Material uberMaterial)
		{
			GrainModel.Settings settings = base.model.settings;
			uberMaterial.EnableKeyword("GRAIN");
			float realtimeSinceStartup = Time.realtimeSinceStartup;
			float value = Random.value;
			float value2 = Random.value;
			if (m_GrainLookupRT == null || !m_GrainLookupRT.IsCreated())
			{
				GraphicsUtils.Destroy(m_GrainLookupRT);
				m_GrainLookupRT = new RenderTexture(192, 192, 0, RenderTextureFormat.ARGBHalf)
				{
					filterMode = FilterMode.Bilinear,
					wrapMode = TextureWrapMode.Repeat,
					anisoLevel = 0,
					name = "Grain Lookup Texture"
				};
				m_GrainLookupRT.Create();
			}
			Material material = context.materialFactory.Get("Hidden/Post FX/Grain Generator");
			material.SetFloat(Uniforms._Phase, realtimeSinceStartup / 20f);
			Graphics.Blit(null, m_GrainLookupRT, material, settings.colored ? 1 : 0);
			uberMaterial.SetTexture(Uniforms._GrainTex, m_GrainLookupRT);
			uberMaterial.SetVector(Uniforms._Grain_Params1, new Vector2(settings.luminanceContribution, settings.intensity * 20f));
			uberMaterial.SetVector(Uniforms._Grain_Params2, new Vector4((float)context.width / (float)m_GrainLookupRT.width / settings.size, (float)context.height / (float)m_GrainLookupRT.height / settings.size, value, value2));
		}
	}
	public sealed class MotionBlurComponent : PostProcessingComponentCommandBuffer<MotionBlurModel>
	{
		private static class Uniforms
		{
			internal static readonly int _VelocityScale = Shader.PropertyToID("_VelocityScale");

			internal static readonly int _MaxBlurRadius = Shader.PropertyToID("_MaxBlurRadius");

			internal static readonly int _RcpMaxBlurRadius = Shader.PropertyToID("_RcpMaxBlurRadius");

			internal static readonly int _VelocityTex = Shader.PropertyToID("_VelocityTex");

			internal static readonly int _MainTex = Shader.PropertyToID("_MainTex");

			internal static readonly int _Tile2RT = Shader.PropertyToID("_Tile2RT");

			internal static readonly int _Tile4RT = Shader.PropertyToID("_Tile4RT");

			internal static readonly int _Tile8RT = Shader.PropertyToID("_Tile8RT");

			internal static readonly int _TileMaxOffs = Shader.PropertyToID("_TileMaxOffs");

			internal static readonly int _TileMaxLoop = Shader.PropertyToID("_TileMaxLoop");

			internal static readonly int _TileVRT = Shader.PropertyToID("_TileVRT");

			internal static readonly int _NeighborMaxTex = Shader.PropertyToID("_NeighborMaxTex");

			internal static readonly int _LoopCount = Shader.PropertyToID("_LoopCount");

			internal static readonly int _TempRT = Shader.PropertyToID("_TempRT");

			internal static readonly int _History1LumaTex = Shader.PropertyToID("_History1LumaTex");

			internal static readonly int _History2LumaTex = Shader.PropertyToID("_History2LumaTex");

			internal static readonly int _History3LumaTex = Shader.PropertyToID("_History3LumaTex");

			internal static readonly int _History4LumaTex = Shader.PropertyToID("_History4LumaTex");

			internal static readonly int _History1ChromaTex = Shader.PropertyToID("_History1ChromaTex");

			internal static readonly int _History2ChromaTex = Shader.PropertyToID("_History2ChromaTex");

			internal static readonly int _History3ChromaTex = Shader.PropertyToID("_History3ChromaTex");

			internal static readonly int _History4ChromaTex = Shader.PropertyToID("_History4ChromaTex");

			internal static readonly int _History1Weight = Shader.PropertyToID("_History1Weight");

			internal static readonly int _History2Weight = Shader.PropertyToID("_History2Weight");

			internal static readonly int _History3Weight = Shader.PropertyToID("_History3Weight");

			internal static readonly int _History4Weight = Shader.PropertyToID("_History4Weight");
		}

		private enum Pass
		{
			VelocitySetup,
			TileMax1,
			TileMax2,
			TileMaxV,
			NeighborMax,
			Reconstruction,
			FrameCompression,
			FrameBlendingChroma,
			FrameBlendingRaw
		}

		public class ReconstructionFilter
		{
			private RenderTextureFormat m_VectorRTFormat = RenderTextureFormat.RGHalf;

			private RenderTextureFormat m_PackedRTFormat = RenderTextureFormat.ARGB2101010;

			public ReconstructionFilter()
			{
				CheckTextureFormatSupport();
			}

			private void CheckTextureFormatSupport()
			{
				if (!SystemInfo.SupportsRenderTextureFormat(m_PackedRTFormat))
				{
					m_PackedRTFormat = RenderTextureFormat.ARGB32;
				}
			}

			public bool IsSupported()
			{
				return SystemInfo.supportsMotionVectors;
			}

			public void ProcessImage(PostProcessingContext context, CommandBuffer cb, ref MotionBlurModel.Settings settings, RenderTargetIdentifier source, RenderTargetIdentifier destination, Material material)
			{
				int num = (int)(5f * (float)context.height / 100f);
				int num2 = ((num - 1) / 8 + 1) * 8;
				float value = settings.shutterAngle / 360f;
				cb.SetGlobalFloat(Uniforms._VelocityScale, value);
				cb.SetGlobalFloat(Uniforms._MaxBlurRadius, num);
				cb.SetGlobalFloat(Uniforms._RcpMaxBlurRadius, 1f / (float)num);
				int velocityTex = Uniforms._VelocityTex;
				cb.GetTemporaryRT(velocityTex, context.width, context.height, 0, FilterMode.Point, m_PackedRTFormat, RenderTextureReadWrite.Linear);
				cb.Blit(null, velocityTex, material, 0);
				int tile2RT = Uniforms._Tile2RT;
				cb.GetTemporaryRT(tile2RT, context.width / 2, context.height / 2, 0, FilterMode.Point, m_VectorRTFormat, RenderTextureReadWrite.Linear);
				cb.SetGlobalTexture(Uniforms._MainTex, velocityTex);
				cb.Blit(velocityTex, tile2RT, material, 1);
				int tile4RT = Uniforms._Tile4RT;
				cb.GetTemporaryRT(tile4RT, context.width / 4, context.height / 4, 0, FilterMode.Point, m_VectorRTFormat, RenderTextureReadWrite.Linear);
				cb.SetGlobalTexture(Uniforms._MainTex, tile2RT);
				cb.Blit(tile2RT, tile4RT, material, 2);
				cb.ReleaseTemporaryRT(tile2RT);
				int tile8RT = Uniforms._Tile8RT;
				cb.GetTemporaryRT(tile8RT, context.width / 8, context.height / 8, 0, FilterMode.Point, m_VectorRTFormat, RenderTextureReadWrite.Linear);
				cb.SetGlobalTexture(Uniforms._MainTex, tile4RT);
				cb.Blit(tile4RT, tile8RT, material, 2);
				cb.ReleaseTemporaryRT(tile4RT);
				Vector2 vector = Vector2.one * ((float)num2 / 8f - 1f) * -0.5f;
				cb.SetGlobalVector(Uniforms._TileMaxOffs, vector);
				cb.SetGlobalFloat(Uniforms._TileMaxLoop, (int)((float)num2 / 8f));
				int tileVRT = Uniforms._TileVRT;
				cb.GetTemporaryRT(tileVRT, context.width / num2, context.height / num2, 0, FilterMode.Point, m_VectorRTFormat, RenderTextureReadWrite.Linear);
				cb.SetGlobalTexture(Uniforms._MainTex, tile8RT);
				cb.Blit(tile8RT, tileVRT, material, 3);
				cb.ReleaseTemporaryRT(tile8RT);
				int neighborMaxTex = Uniforms._NeighborMaxTex;
				int width = context.width / num2;
				int height = context.height / num2;
				cb.GetTemporaryRT(neighborMaxTex, width, height, 0, FilterMode.Point, m_VectorRTFormat, RenderTextureReadWrite.Linear);
				cb.SetGlobalTexture(Uniforms._MainTex, tileVRT);
				cb.Blit(tileVRT, neighborMaxTex, material, 4);
				cb.ReleaseTemporaryRT(tileVRT);
				cb.SetGlobalFloat(Uniforms._LoopCount, Mathf.Clamp(settings.sampleCount / 2, 1, 64));
				cb.SetGlobalTexture(Uniforms._MainTex, source);
				cb.Blit(source, destination, material, 5);
				cb.ReleaseTemporaryRT(velocityTex);
				cb.ReleaseTemporaryRT(neighborMaxTex);
			}
		}

		public class FrameBlendingFilter
		{
			private struct Frame
			{
				public RenderTexture lumaTexture;

				public RenderTexture chromaTexture;

				private float m_Time;

				private RenderTargetIdentifier[] m_MRT;

				public float CalculateWeight(float strength, float currentTime)
				{
					if (Mathf.Approximately(m_Time, 0f))
					{
						return 0f;
					}
					float num = Mathf.Lerp(80f, 16f, strength);
					return Mathf.Exp((m_Time - currentTime) * num);
				}

				public void Release()
				{
					if (lumaTexture != null)
					{
						RenderTexture.ReleaseTemporary(lumaTexture);
					}
					if (chromaTexture != null)
					{
						RenderTexture.ReleaseTemporary(chromaTexture);
					}
					lumaTexture = null;
					chromaTexture = null;
				}

				public void MakeRecord(CommandBuffer cb, RenderTargetIdentifier source, int width, int height, Material material)
				{
					Release();
					lumaTexture = RenderTexture.GetTemporary(width, height, 0, RenderTextureFormat.R8, RenderTextureReadWrite.Linear);
					chromaTexture = RenderTexture.GetTemporary(width, height, 0, RenderTextureFormat.R8, RenderTextureReadWrite.Linear);
					lumaTexture.filterMode = FilterMode.Point;
					chromaTexture.filterMode = FilterMode.Point;
					if (m_MRT == null)
					{
						m_MRT = new RenderTargetIdentifier[2];
					}
					m_MRT[0] = lumaTexture;
					m_MRT[1] = chromaTexture;
					cb.SetGlobalTexture(Uniforms._MainTex, source);
					cb.SetRenderTarget(m_MRT, lumaTexture);
					cb.DrawMesh(GraphicsUtils.quad, Matrix4x4.identity, material, 0, 6);
					m_Time = Time.time;
				}

				public void MakeRecordRaw(CommandBuffer cb, RenderTargetIdentifier source, int width, int height, RenderTextureFormat format)
				{
					Release();
					lumaTexture = RenderTexture.GetTemporary(width, height, 0, format);
					lumaTexture.filterMode = FilterMode.Point;
					cb.SetGlobalTexture(Uniforms._MainTex, source);
					cb.Blit(source, lumaTexture);
					m_Time = Time.time;
				}
			}

			private bool m_UseCompression;

			private RenderTextureFormat m_RawTextureFormat;

			private Frame[] m_FrameList;

			private int m_LastFrameCount;

			public FrameBlendingFilter()
			{
				m_UseCompression = CheckSupportCompression();
				m_RawTextureFormat = GetPreferredRenderTextureFormat();
				m_FrameList = new Frame[4];
			}

			public void Dispose()
			{
				Frame[] frameList = m_FrameList;
				foreach (Frame frame in frameList)
				{
					frame.Release();
				}
			}

			public void PushFrame(CommandBuffer cb, RenderTargetIdentifier source, int width, int height, Material material)
			{
				int frameCount = Time.frameCount;
				if (frameCount != m_LastFrameCount)
				{
					int num = frameCount % m_FrameList.Length;
					if (m_UseCompression)
					{
						m_FrameList[num].MakeRecord(cb, source, width, height, material);
					}
					else
					{
						m_FrameList[num].MakeRecordRaw(cb, source, width, height, m_RawTextureFormat);
					}
					m_LastFrameCount = frameCount;
				}
			}

			public void BlendFrames(CommandBuffer cb, float strength, RenderTargetIdentifier source, RenderTargetIdentifier destination, Material material)
			{
				float time = Time.time;
				Frame frameRelative = GetFrameRelative(-1);
				Frame frameRelative2 = GetFrameRelative(-2);
				Frame frameRelative3 = GetFrameRelative(-3);
				Frame frameRelative4 = GetFrameRelative(-4);
				cb.SetGlobalTexture(Uniforms._History1LumaTex, frameRelative.lumaTexture);
				cb.SetGlobalTexture(Uniforms._History2LumaTex, frameRelative2.lumaTexture);
				cb.SetGlobalTexture(Uniforms._History3LumaTex, frameRelative3.lumaTexture);
				cb.SetGlobalTexture(Uniforms._History4LumaTex, frameRelative4.lumaTexture);
				cb.SetGlobalTexture(Uniforms._History1ChromaTex, frameRelative.chromaTexture);
				cb.SetGlobalTexture(Uniforms._History2ChromaTex, frameRelative2.chromaTexture);
				cb.SetGlobalTexture(Uniforms._History3ChromaTex, frameRelative3.chromaTexture);
				cb.SetGlobalTexture(Uniforms._History4ChromaTex, frameRelative4.chromaTexture);
				cb.SetGlobalFloat(Uniforms._History1Weight, frameRelative.CalculateWeight(strength, time));
				cb.SetGlobalFloat(Uniforms._History2Weight, frameRelative2.CalculateWeight(strength, time));
				cb.SetGlobalFloat(Uniforms._History3Weight, frameRelative3.CalculateWeight(strength, time));
				cb.SetGlobalFloat(Uniforms._History4Weight, frameRelative4.CalculateWeight(strength, time));
				cb.SetGlobalTexture(Uniforms._MainTex, source);
				cb.Blit(source, destination, material, m_UseCompression ? 7 : 8);
			}

			private static bool CheckSupportCompression()
			{
				if (SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.R8))
				{
					return SystemInfo.supportedRenderTargetCount > 1;
				}
				return false;
			}

			private static RenderTextureFormat GetPreferredRenderTextureFormat()
			{
				RenderTextureFormat[] array = new RenderTextureFormat[3]
				{
					RenderTextureFormat.RGB565,
					RenderTextureFormat.ARGB1555,
					RenderTextureFormat.ARGB4444
				};
				foreach (RenderTextureFormat renderTextureFormat in array)
				{
					if (SystemInfo.SupportsRenderTextureFormat(renderTextureFormat))
					{
						return renderTextureFormat;
					}
				}
				return RenderTextureFormat.Default;
			}

			private Frame GetFrameRelative(int offset)
			{
				int num = (Time.frameCount + m_FrameList.Length + offset) % m_FrameList.Length;
				return m_FrameList[num];
			}
		}

		private ReconstructionFilter m_ReconstructionFilter;

		private FrameBlendingFilter m_FrameBlendingFilter;

		private bool m_FirstFrame = true;

		public ReconstructionFilter reconstructionFilter
		{
			get
			{
				if (m_ReconstructionFilter == null)
				{
					m_ReconstructionFilter = new ReconstructionFilter();
				}
				return m_ReconstructionFilter;
			}
		}

		public FrameBlendingFilter frameBlendingFilter
		{
			get
			{
				if (m_FrameBlendingFilter == null)
				{
					m_FrameBlendingFilter = new FrameBlendingFilter();
				}
				return m_FrameBlendingFilter;
			}
		}

		public override bool active
		{
			get
			{
				MotionBlurModel.Settings settings = base.model.settings;
				if (base.model.enabled && ((settings.shutterAngle > 0f && reconstructionFilter.IsSupported()) || settings.frameBlending > 0f) && SystemInfo.graphicsDeviceType != GraphicsDeviceType.OpenGLES2)
				{
					return !context.interrupted;
				}
				return false;
			}
		}

		public override string GetName()
		{
			return "Motion Blur";
		}

		public void ResetHistory()
		{
			if (m_FrameBlendingFilter != null)
			{
				m_FrameBlendingFilter.Dispose();
			}
			m_FrameBlendingFilter = null;
		}

		public override DepthTextureMode GetCameraFlags()
		{
			return DepthTextureMode.Depth | DepthTextureMode.MotionVectors;
		}

		public override CameraEvent GetCameraEvent()
		{
			return CameraEvent.BeforeImageEffects;
		}

		public override void OnEnable()
		{
			m_FirstFrame = true;
		}

		public override void PopulateCommandBuffer(CommandBuffer cb)
		{
			if (m_FirstFrame)
			{
				m_FirstFrame = false;
				return;
			}
			Material material = context.materialFactory.Get("Hidden/Post FX/Motion Blur");
			Material mat = context.materialFactory.Get("Hidden/Post FX/Blit");
			MotionBlurModel.Settings settings = base.model.settings;
			RenderTextureFormat format = (context.isHdr ? RenderTextureFormat.DefaultHDR : RenderTextureFormat.Default);
			int tempRT = Uniforms._TempRT;
			cb.GetTemporaryRT(tempRT, context.width, context.height, 0, FilterMode.Point, format);
			if (settings.shutterAngle > 0f && settings.frameBlending > 0f)
			{
				reconstructionFilter.ProcessImage(context, cb, ref settings, BuiltinRenderTextureType.CameraTarget, tempRT, material);
				frameBlendingFilter.BlendFrames(cb, settings.frameBlending, tempRT, BuiltinRenderTextureType.CameraTarget, material);
				frameBlendingFilter.PushFrame(cb, tempRT, context.width, context.height, material);
			}
			else if (settings.shutterAngle > 0f)
			{
				cb.SetGlobalTexture(Uniforms._MainTex, BuiltinRenderTextureType.CameraTarget);
				cb.Blit(BuiltinRenderTextureType.CameraTarget, tempRT, mat, 0);
				reconstructionFilter.ProcessImage(context, cb, ref settings, tempRT, BuiltinRenderTextureType.CameraTarget, material);
			}
			else if (settings.frameBlending > 0f)
			{
				cb.SetGlobalTexture(Uniforms._MainTex, BuiltinRenderTextureType.CameraTarget);
				cb.Blit(BuiltinRenderTextureType.CameraTarget, tempRT, mat, 0);
				frameBlendingFilter.BlendFrames(cb, settings.frameBlending, tempRT, BuiltinRenderTextureType.CameraTarget, material);
				frameBlendingFilter.PushFrame(cb, tempRT, context.width, context.height, material);
			}
			cb.ReleaseTemporaryRT(tempRT);
		}

		public override void OnDisable()
		{
			if (m_FrameBlendingFilter != null)
			{
				m_FrameBlendingFilter.Dispose();
			}
		}
	}
	public sealed class ScreenSpaceReflectionComponent : PostProcessingComponentCommandBuffer<ScreenSpaceReflectionModel>
	{
		private static class Uniforms
		{
			internal static readonly int _RayStepSize = Shader.PropertyToID("_RayStepSize");

			internal static readonly int _AdditiveReflection = Shader.PropertyToID("_AdditiveReflection");

			internal static readonly int _BilateralUpsampling = Shader.PropertyToID("_BilateralUpsampling");

			internal static readonly int _TreatBackfaceHitAsMiss = Shader.PropertyToID("_TreatBackfaceHitAsMiss");

			internal static readonly int _AllowBackwardsRays = Shader.PropertyToID("_AllowBackwardsRays");

			internal static readonly int _TraceBehindObjects = Shader.PropertyToID("_TraceBehindObjects");

			internal static readonly int _MaxSteps = Shader.PropertyToID("_MaxSteps");

			internal static readonly int _FullResolutionFiltering = Shader.PropertyToID("_FullResolutionFiltering");

			internal static readonly int _HalfResolution = Shader.PropertyToID("_HalfResolution");

			internal static readonly int _HighlightSuppression = Shader.PropertyToID("_HighlightSuppression");

			internal static readonly int _PixelsPerMeterAtOneMeter = Shader.PropertyToID("_PixelsPerMeterAtOneMeter");

			internal static readonly int _ScreenEdgeFading = Shader.PropertyToID("_ScreenEdgeFading");

			internal static readonly int _ReflectionBlur = Shader.PropertyToID("_ReflectionBlur");

			internal static readonly int _MaxRayTraceDistance = Shader.PropertyToID("_MaxRayTraceDistance");

			internal static readonly int _FadeDistance = Shader.PropertyToID("_FadeDistance");

			internal static readonly int _LayerThickness = Shader.PropertyToID("_LayerThickness");

			internal static readonly int _SSRMultiplier = Shader.PropertyToID("_SSRMultiplier");

			internal static readonly int _FresnelFade = Shader.PropertyToID("_FresnelFade");

			internal static readonly int _FresnelFadePower = Shader.PropertyToID("_FresnelFadePower");

			internal static readonly int _ReflectionBufferSize = Shader.PropertyToID("_ReflectionBufferSize");

			internal static readonly int _ScreenSize = Shader.PropertyToID("_ScreenSize");

			internal static readonly int _InvScreenSize = Shader.PropertyToID("_InvScreenSize");

			internal static readonly int _ProjInfo = Shader.PropertyToID("_ProjInfo");

			internal static readonly int _CameraClipInfo = Shader.PropertyToID("_CameraClipInfo");

			internal static readonly int _ProjectToPixelMatrix = Shader.PropertyToID("_ProjectToPixelMatrix");

			internal static readonly int _WorldToCameraMatrix = Shader.PropertyToID("_WorldToCameraMatrix");

			internal static readonly int _CameraToWorldMatrix = Shader.PropertyToID("_CameraToWorldMatrix");

			internal static readonly int _Axis = Shader.PropertyToID("_Axis");

			internal static readonly int _CurrentMipLevel = Shader.PropertyToID("_CurrentMipLevel");

			internal static readonly int _NormalAndRoughnessTexture = Shader.PropertyToID("_NormalAndRoughnessTexture");

			internal static readonly int _HitPointTexture = Shader.PropertyToID("_HitPointTexture");

			internal static readonly int _BlurTexture = Shader.PropertyToID("_BlurTexture");

			internal static readonly int _FilteredReflections = Shader.PropertyToID("_FilteredReflections");

			internal static readonly int _FinalReflectionTexture = Shader.PropertyToID("_FinalReflectionTexture");

			internal static readonly int _TempTexture = Shader.PropertyToID("_TempTexture");
		}

		private enum PassIndex
		{
			RayTraceStep,
			CompositeFinal,
			Blur,
			CompositeSSR,
			MinMipGeneration,
			HitPointToReflections,
			BilateralKeyPack,
			BlitDepthAsCSZ,
			PoissonBlur
		}

		private bool k_HighlightSuppression;

		private bool k_TraceBehindObjects = true;

		private bool k_TreatBackfaceHitAsMiss;

		private bool k_BilateralUpsample = true;

		private readonly int[] m_ReflectionTextures = new int[5];

		public override bool active
		{
			get
			{
				if (base.model.enabled && context.isGBufferAvailable)
				{
					return !context.interrupted;
				}
				return false;
			}
		}

		public override DepthTextureMode GetCameraFlags()
		{
			return DepthTextureMode.Depth;
		}

		public override void OnEnable()
		{
			m_ReflectionTextures[0] = Shader.PropertyToID("_ReflectionTexture0");
			m_ReflectionTextures[1] = Shader.PropertyToID("_ReflectionTexture1");
			m_ReflectionTextures[2] = Shader.PropertyToID("_ReflectionTexture2");
			m_ReflectionTextures[3] = Shader.PropertyToID("_ReflectionTexture3");
			m_ReflectionTextures[4] = Shader.PropertyToID("_ReflectionTexture4");
		}

		public override string GetName()
		{
			return "Screen Space Reflection";
		}

		public override CameraEvent GetCameraEvent()
		{
			return CameraEvent.AfterFinalPass;
		}

		public override void PopulateCommandBuffer(CommandBuffer cb)
		{
			ScreenSpaceReflectionModel.Settings settings = base.model.settings;
			Camera camera = context.camera;
			int num = ((settings.reflection.reflectionQuality == ScreenSpaceReflectionModel.SSRResolution.High) ? 1 : 2);
			int num2 = context.width / num;
			int num3 = context.height / num;
			float num4 = context.width;
			float num5 = context.height;
			float num6 = num4 / 2f;
			float num7 = num5 / 2f;
			Material material = context.materialFactory.Get("Hidden/Post FX/Screen Space Reflection");
			material.SetInt(Uniforms._RayStepSize, settings.reflection.stepSize);
			material.SetInt(Uniforms._AdditiveReflection, (settings.reflection.blendType == ScreenSpaceReflectionModel.SSRReflectionBlendType.Additive) ? 1 : 0);
			material.SetInt(Uniforms._BilateralUpsampling, k_BilateralUpsample ? 1 : 0);
			material.SetInt(Uniforms._TreatBackfaceHitAsMiss, k_TreatBackfaceHitAsMiss ? 1 : 0);
			material.SetInt(Uniforms._AllowBackwardsRays, settings.reflection.reflectBackfaces ? 1 : 0);
			material.SetInt(Uniforms._TraceBehindObjects, k_TraceBehindObjects ? 1 : 0);
			material.SetInt(Uniforms._MaxSteps, settings.reflection.iterationCount);
			material.SetInt(Uniforms._FullResolutionFiltering, 0);
			material.SetInt(Uniforms._HalfResolution, (settings.reflection.reflectionQuality != 0) ? 1 : 0);
			material.SetInt(Uniforms._HighlightSuppression, k_HighlightSuppression ? 1 : 0);
			float value = num4 / (-2f * Mathf.Tan(camera.fieldOfView / 180f * (float)Math.PI * 0.5f));
			material.SetFloat(Uniforms._PixelsPerMeterAtOneMeter, value);
			material.SetFloat(Uniforms._ScreenEdgeFading, settings.screenEdgeMask.intensity);
			material.SetFloat(Uniforms._ReflectionBlur, settings.reflection.reflectionBlur);
			material.SetFloat(Uniforms._MaxRayTraceDistance, settings.reflection.maxDistance);
			material.SetFloat(Uniforms._FadeDistance, settings.intensity.fadeDistance);
			material.SetFloat(Uniforms._LayerThickness, settings.reflection.widthModifier);
			material.SetFloat(Uniforms._SSRMultiplier, settings.intensity.reflectionMultiplier);
			material.SetFloat(Uniforms._FresnelFade, settings.intensity.fresnelFade);
			material.SetFloat(Uniforms._FresnelFadePower, settings.intensity.fresnelFadePower);
			Matrix4x4 projectionMatrix = camera.projectionMatrix;
			Vector4 value2 = new Vector4(-2f / (num4 * projectionMatrix[0]), -2f / (num5 * projectionMatrix[5]), (1f - projectionMatrix[2]) / projectionMatrix[0], (1f + projectionMatrix[6]) / projectionMatrix[5]);
			Vector3 vector = (float.IsPositiveInfinity(camera.farClipPlane) ? new Vector3(camera.nearClipPlane, -1f, 1f) : new Vector3(camera.nearClipPlane * camera.farClipPlane, camera.nearClipPlane - camera.farClipPlane, camera.farClipPlane));
			material.SetVector(Uniforms._ReflectionBufferSize, new Vector2(num2, num3));
			material.SetVector(Uniforms._ScreenSize, new Vector2(num4, num5));
			material.SetVector(Uniforms._InvScreenSize, new Vector2(1f / num4, 1f / num5));
			material.SetVector(Uniforms._ProjInfo, value2);
			material.SetVector(Uniforms._CameraClipInfo, vector);
			Matrix4x4 matrix4x = default(Matrix4x4);
			matrix4x.SetRow(0, new Vector4(num6, 0f, 0f, num6));
			matrix4x.SetRow(1, new Vector4(0f, num7, 0f, num7));
			matrix4x.SetRow(2, new Vector4(0f, 0f, 1f, 0f));
			matrix4x.SetRow(3, new Vector4(0f, 0f, 0f, 1f));
			Matrix4x4 value3 = matrix4x * projectionMatrix;
			material.SetMatrix(Uniforms._ProjectToPixelMatrix, value3);
			material.SetMatrix(Uniforms._WorldToCameraMatrix, camera.worldToCameraMatrix);
			material.SetMatrix(Uniforms._CameraToWorldMatrix, camera.worldToCameraMatrix.inverse);
			RenderTextureFormat format = (context.isHdr ? RenderTextureFormat.ARGBHalf : RenderTextureFormat.ARGB32);
			int normalAndRoughnessTexture = Uniforms._NormalAndRoughnessTexture;
			int hitPointTexture = Uniforms._HitPointTexture;
			int blurTexture = Uniforms._BlurTexture;
			int filteredReflections = Uniforms._FilteredReflections;
			int finalReflectionTexture = Uniforms._FinalReflectionTexture;
			int tempTexture = Uniforms._TempTexture;
			cb.GetTemporaryRT(normalAndRoughnessTexture, -1, -1, 0, FilterMode.Point, RenderTextureFormat.ARGB32, RenderTextureReadWrite.Linear);
			cb.GetTemporaryRT(hitPointTexture, num2, num3, 0, FilterMode.Bilinear, RenderTextureFormat.ARGBHalf, RenderTextureReadWrite.Linear);
			for (int i = 0; i < 5; i++)
			{
				cb.GetTemporaryRT(m_ReflectionTextures[i], num2 >> i, num3 >> i, 0, FilterMode.Bilinear, format);
			}
			cb.GetTemporaryRT(filteredReflections, num2, num3, 0, (!k_BilateralUpsample) ? FilterMode.Bilinear : FilterMode.Point, format);
			cb.GetTemporaryRT(finalReflectionTexture, num2, num3, 0, FilterMode.Point, format);
			cb.Blit(BuiltinRenderTextureType.CameraTarget, normalAndRoughnessTexture, material, 6);
			cb.Blit(BuiltinRenderTextureType.CameraTarget, hitPointTexture, material, 0);
			cb.Blit(BuiltinRenderTextureType.CameraTarget, filteredReflections, material, 5);
			cb.Blit(filteredReflections, m_ReflectionTextures[0], material, 8);
			for (int j = 1; j < 5; j++)
			{
				int num8 = m_ReflectionTextures[j - 1];
				int num9 = j;
				cb.GetTemporaryRT(blurTexture, num2 >> num9, num3 >> num9, 0, FilterMode.Bilinear, format);
				cb.SetGlobalVector(Uniforms._Axis, new Vector4(1f, 0f, 0f, 0f));
				cb.SetGlobalFloat(Uniforms._CurrentMipLevel, (float)j - 1f);
				cb.Blit(num8, blurTexture, material, 2);
				cb.SetGlobalVector(Uniforms._Axis, new Vector4(0f, 1f, 0f, 0f));
				num8 = m_ReflectionTextures[j];
				cb.Blit(blurTexture, num8, material, 2);
				cb.ReleaseTemporaryRT(blurTexture);
			}
			cb.Blit(m_ReflectionTextures[0], finalReflectionTexture, material, 3);
			cb.GetTemporaryRT(tempTexture, camera.pixelWidth, camera.pixelHeight, 0, FilterMode.Bilinear, format);
			cb.Blit(BuiltinRenderTextureType.CameraTarget, tempTexture, material, 1);
			cb.Blit(tempTexture, BuiltinRenderTextureType.CameraTarget);
			cb.ReleaseTemporaryRT(tempTexture);
		}
	}
	public sealed class TaaComponent : PostProcessingComponentRenderTexture<AntialiasingModel>
	{
		private static class Uniforms
		{
			internal static int _Jitter = Shader.PropertyToID("_Jitter");

			internal static int _SharpenParameters = Shader.PropertyToID("_SharpenParameters");

			internal static int _FinalBlendParameters = Shader.PropertyToID("_FinalBlendParameters");

			internal static int _HistoryTex = Shader.PropertyToID("_HistoryTex");

			internal static int _MainTex = Shader.PropertyToID("_MainTex");
		}

		private const string k_ShaderString = "Hidden/Post FX/Temporal Anti-aliasing";

		private const int k_SampleCount = 8;

		private readonly RenderBuffer[] m_MRT = new RenderBuffer[2];

		private int m_SampleIndex;

		private bool m_ResetHistory = true;

		private RenderTexture m_HistoryTexture;

		public override bool active
		{
			get
			{
				if (base.model.enabled && base.model.settings.method == AntialiasingModel.Method.Taa && SystemInfo.supportsMotionVectors && SystemInfo.supportedRenderTargetCount >= 2)
				{
					return !context.interrupted;
				}
				return false;
			}
		}

		public Vector2 jitterVector { get; private set; }

		public override DepthTextureMode GetCameraFlags()
		{
			return DepthTextureMode.Depth | DepthTextureMode.MotionVectors;
		}

		public void ResetHistory()
		{
			m_ResetHistory = true;
		}

		public void SetProjectionMatrix(Func<Vector2, Matrix4x4> jitteredFunc)
		{
			AntialiasingModel.TaaSettings taaSettings = base.model.settings.taaSettings;
			Vector2 vector = GenerateRandomOffset();
			vector *= taaSettings.jitterSpread;
			context.camera.nonJitteredProjectionMatrix = context.camera.projectionMatrix;
			if (jitteredFunc != null)
			{
				context.camera.projectionMatrix = jitteredFunc(vector);
			}
			else
			{
				context.camera.projectionMatrix = (context.camera.orthographic ? GetOrthographicProjectionMatrix(vector) : GetPerspectiveProjectionMatrix(vector));
			}
			context.camera.useJitteredProjectionMatrixForTransparentRendering = false;
			vector.x /= context.width;
			vector.y /= context.height;
			context.materialFactory.Get("Hidden/Post FX/Temporal Anti-aliasing").SetVector(Uniforms._Jitter, vector);
			jitterVector = vector;
		}

		public void Render(RenderTexture source, RenderTexture destination)
		{
			Material material = context.materialFactory.Get("Hidden/Post FX/Temporal Anti-aliasing");
			material.shaderKeywords = null;
			AntialiasingModel.TaaSettings taaSettings = base.model.settings.taaSettings;
			if (m_ResetHistory || m_HistoryTexture == null || m_HistoryTexture.width != source.width || m_HistoryTexture.height != source.height)
			{
				if ((bool)m_HistoryTexture)
				{
					RenderTexture.ReleaseTemporary(m_HistoryTexture);
				}
				m_HistoryTexture = RenderTexture.GetTemporary(source.width, source.height, 0, source.format);
				m_HistoryTexture.name = "TAA History";
				Graphics.Blit(source, m_HistoryTexture, material, 2);
			}
			material.SetVector(Uniforms._SharpenParameters, new Vector4(taaSettings.sharpen, 0f, 0f, 0f));
			material.SetVector(Uniforms._FinalBlendParameters, new Vector4(taaSettings.stationaryBlending, taaSettings.motionBlending, 6000f, 0f));
			material.SetTexture(Uniforms._MainTex, source);
			material.SetTexture(Uniforms._HistoryTex, m_HistoryTexture);
			RenderTexture temporary = RenderTexture.GetTemporary(source.width, source.height, 0, source.format);
			temporary.name = "TAA History";
			m_MRT[0] = destination.colorBuffer;
			m_MRT[1] = temporary.colorBuffer;
			Graphics.SetRenderTarget(m_MRT, source.depthBuffer);
			GraphicsUtils.Blit(material, context.camera.orthographic ? 1 : 0);
			RenderTexture.ReleaseTemporary(m_HistoryTexture);
			m_HistoryTexture = temporary;
			m_ResetHistory = false;
		}

		private float GetHaltonValue(int index, int radix)
		{
			float num = 0f;
			float num2 = 1f / (float)radix;
			while (index > 0)
			{
				num += (float)(index % radix) * num2;
				index /= radix;
				num2 /= (float)radix;
			}
			return num;
		}

		private Vector2 GenerateRandomOffset()
		{
			Vector2 result = new Vector2(GetHaltonValue(m_SampleIndex & 0x3FF, 2), GetHaltonValue(m_SampleIndex & 0x3FF, 3));
			if (++m_SampleIndex >= 8)
			{
				m_SampleIndex = 0;
			}
			return result;
		}

		private Matrix4x4 GetPerspectiveProjectionMatrix(Vector2 offset)
		{
			float num = Mathf.Tan((float)Math.PI / 360f * context.camera.fieldOfView);
			float num2 = num * context.camera.aspect;
			offset.x *= num2 / (0.5f * (float)context.width);
			offset.y *= num / (0.5f * (float)context.height);
			float num3 = (offset.x - num2) * context.camera.nearClipPlane;
			float num4 = (offset.x + num2) * context.camera.nearClipPlane;
			float num5 = (offset.y + num) * context.camera.nearClipPlane;
			float num6 = (offset.y - num) * context.camera.nearClipPlane;
			Matrix4x4 result = default(Matrix4x4);
			result[0, 0] = 2f * context.camera.nearClipPlane / (num4 - num3);
			result[0, 1] = 0f;
			result[0, 2] = (num4 + num3) / (num4 - num3);
			result[0, 3] = 0f;
			result[1, 0] = 0f;
			result[1, 1] = 2f * context.camera.nearClipPlane / (num5 - num6);
			result[1, 2] = (num5 + num6) / (num5 - num6);
			result[1, 3] = 0f;
			result[2, 0] = 0f;
			result[2, 1] = 0f;
			result[2, 2] = (0f - (context.camera.farClipPlane + context.camera.nearClipPlane)) / (context.camera.farClipPlane - context.camera.nearClipPlane);
			result[2, 3] = (0f - 2f * context.camera.farClipPlane * context.camera.nearClipPlane) / (context.camera.farClipPlane - context.camera.nearClipPlane);
			result[3, 0] = 0f;
			result[3, 1] = 0f;
			result[3, 2] = -1f;
			result[3, 3] = 0f;
			return result;
		}

		private Matrix4x4 GetOrthographicProjectionMatrix(Vector2 offset)
		{
			float orthographicSize = context.camera.orthographicSize;
			float num = orthographicSize * context.camera.aspect;
			offset.x *= num / (0.5f * (float)context.width);
			offset.y *= orthographicSize / (0.5f * (float)context.height);
			float left = offset.x - num;
			float right = offset.x + num;
			float top = offset.y + orthographicSize;
			float bottom = offset.y - orthographicSize;
			return Matrix4x4.Ortho(left, right, bottom, top, context.camera.nearClipPlane, context.camera.farClipPlane);
		}

		public override void OnDisable()
		{
			if (m_HistoryTexture != null)
			{
				RenderTexture.ReleaseTemporary(m_HistoryTexture);
			}
			m_HistoryTexture = null;
			m_SampleIndex = 0;
			ResetHistory();
		}
	}
	public sealed class UserLutComponent : PostProcessingComponentRenderTexture<UserLutModel>
	{
		private static class Uniforms
		{
			internal static readonly int _UserLut = Shader.PropertyToID("_UserLut");

			internal static readonly int _UserLut_Params = Shader.PropertyToID("_UserLut_Params");
		}

		public override bool active
		{
			get
			{
				UserLutModel.Settings settings = base.model.settings;
				if (base.model.enabled && settings.lut != null && settings.contribution > 0f && settings.lut.height == (int)Mathf.Sqrt(settings.lut.width))
				{
					return !context.interrupted;
				}
				return false;
			}
		}

		public override void Prepare(Material uberMaterial)
		{
			UserLutModel.Settings settings = base.model.settings;
			uberMaterial.EnableKeyword("USER_LUT");
			uberMaterial.SetTexture(Uniforms._UserLut, settings.lut);
			uberMaterial.SetVector(Uniforms._UserLut_Params, new Vector4(1f / (float)settings.lut.width, 1f / (float)settings.lut.height, (float)settings.lut.height - 1f, settings.contribution));
		}

		public void OnGUI()
		{
			UserLutModel.Settings settings = base.model.settings;
			GUI.DrawTexture(new Rect(context.viewport.x * (float)Screen.width + 8f, 8f, settings.lut.width, settings.lut.height), settings.lut);
		}
	}
	public sealed class VignetteComponent : PostProcessingComponentRenderTexture<VignetteModel>
	{
		private static class Uniforms
		{
			internal static readonly int _Vignette_Color = Shader.PropertyToID("_Vignette_Color");

			internal static readonly int _Vignette_Center = Shader.PropertyToID("_Vignette_Center");

			internal static readonly int _Vignette_Settings = Shader.PropertyToID("_Vignette_Settings");

			internal static readonly int _Vignette_Mask = Shader.PropertyToID("_Vignette_Mask");

			internal static readonly int _Vignette_Opacity = Shader.PropertyToID("_Vignette_Opacity");
		}

		public override bool active
		{
			get
			{
				if (base.model.enabled)
				{
					return !context.interrupted;
				}
				return false;
			}
		}

		public override void Prepare(Material uberMaterial)
		{
			VignetteModel.Settings settings = base.model.settings;
			uberMaterial.SetColor(Uniforms._Vignette_Color, settings.color);
			if (settings.mode == VignetteModel.Mode.Classic)
			{
				uberMaterial.SetVector(Uniforms._Vignette_Center, settings.center);
				uberMaterial.EnableKeyword("VIGNETTE_CLASSIC");
				float z = (1f - settings.roundness) * 6f + settings.roundness;
				uberMaterial.SetVector(Uniforms._Vignette_Settings, new Vector4(settings.intensity * 3f, settings.smoothness * 5f, z, settings.rounded ? 1f : 0f));
			}
			else if (settings.mode == VignetteModel.Mode.Masked && settings.mask != null && settings.opacity > 0f)
			{
				uberMaterial.EnableKeyword("VIGNETTE_MASKED");
				uberMaterial.SetTexture(Uniforms._Vignette_Mask, settings.mask);
				uberMaterial.SetFloat(Uniforms._Vignette_Opacity, settings.opacity);
			}
		}
	}
	[Serializable]
	public class AmbientOcclusionModel : PostProcessingModel
	{
		public enum SampleCount
		{
			Lowest = 3,
			Low = 6,
			Medium = 10,
			High = 16
		}

		[Serializable]
		public struct Settings
		{
			[Range(0f, 4f)]
			[Tooltip("Degree of darkness produced by the effect.")]
			public float intensity;

			[Min(0.0001f)]
			[Tooltip("Radius of sample points, which affects extent of darkened areas.")]
			public float radius;

			[Tooltip("Number of sample points, which affects quality and performance.")]
			public SampleCount sampleCount;

			[Tooltip("Halves the resolution of the effect to increase performance at the cost of visual quality.")]
			public bool downsampling;

			[Tooltip("Forces compatibility with Forward rendered objects when working with the Deferred rendering path.")]
			public bool forceForwardCompatibility;

			[Tooltip("Enables the ambient-only mode in that the effect only affects ambient lighting. This mode is only available with the Deferred rendering path and HDR rendering.")]
			public bool ambientOnly;

			[Tooltip("Toggles the use of a higher precision depth texture with the forward rendering path (may impact performances). Has no effect with the deferred rendering path.")]
			public bool highPrecision;

			public static Settings defaultSettings
			{
				get
				{
					Settings result = default(Settings);
					result.intensity = 1f;
					result.radius = 0.3f;
					result.sampleCount = SampleCount.Medium;
					result.downsampling = true;
					result.forceForwardCompatibility = false;
					result.ambientOnly = false;
					result.highPrecision = false;
					return result;
				}
			}
		}

		[SerializeField]
		private Settings m_Settings = Settings.defaultSettings;

		public Settings settings
		{
			get
			{
				return m_Settings;
			}
			set
			{
				m_Settings = value;
			}
		}

		public override void Reset()
		{
			m_Settings = Settings.defaultSettings;
		}
	}
	[Serializable]
	public class AntialiasingModel : PostProcessingModel
	{
		public enum Method
		{
			Fxaa,
			Taa
		}

		public enum FxaaPreset
		{
			ExtremePerformance,
			Performance,
			Default,
			Quality,
			ExtremeQuality
		}

		[Serializable]
		public struct FxaaQualitySettings
		{
			[Tooltip("The amount of desired sub-pixel aliasing removal. Effects the sharpeness of the output.")]
			[Range(0f, 1f)]
			public float subpixelAliasingRemovalAmount;

			[Tooltip("The minimum amount of local contrast required to qualify a region as containing an edge.")]
			[Range(0.063f, 0.333f)]
			public float edgeDetectionThreshold;

			[Tooltip("Local contrast adaptation value to disallow the algorithm from executing on the darker regions.")]
			[Range(0f, 0.0833f)]
			public float minimumRequiredLuminance;

			public static FxaaQualitySettings[] presets = new FxaaQualitySettings[5]
			{
				new FxaaQualitySettings
				{
					subpixelAliasingRemovalAmount = 0f,
					edgeDetectionThreshold = 0.333f,
					minimumRequiredLuminance = 0.0833f
				},
				new FxaaQualitySettings
				{
					subpixelAliasingRemovalAmount = 0.25f,
					edgeDetectionThreshold = 0.25f,
					minimumRequiredLuminance = 0.0833f
				},
				new FxaaQualitySettings
				{
					subpixelAliasingRemovalAmount = 0.75f,
					edgeDetectionThreshold = 0.166f,
					minimumRequiredLuminance = 0.0833f
				},
				new FxaaQualitySettings
				{
					subpixelAliasingRemovalAmount = 1f,
					edgeDetectionThreshold = 0.125f,
					minimumRequiredLuminance = 0.0625f
				},
				new FxaaQualitySettings
				{
					subpixelAliasingRemovalAmount = 1f,
					edgeDetectionThreshold = 0.063f,
					minimumRequiredLuminance = 0.0312f
				}
			};
		}

		[Serializable]
		public struct FxaaConsoleSettings
		{
			[Tooltip("The amount of spread applied to the sampling coordinates while sampling for subpixel information.")]
			[Range(0.33f, 0.5f)]
			public float subpixelSpreadAmount;

			[Tooltip("This value dictates how sharp the edges in the image are kept; a higher value implies sharper edges.")]
			[Range(2f, 8f)]
			public float edgeSharpnessAmount;

			[Tooltip("The minimum amount of local contrast required to qualify a region as containing an edge.")]
			[Range(0.125f, 0.25f)]
			public float edgeDetectionThreshold;

			[Tooltip("Local contrast adaptation value to disallow the algorithm from executing on the darker regions.")]
			[Range(0.04f, 0.06f)]
			public float minimumRequiredLuminance;

			public static FxaaConsoleSettings[] presets = new FxaaConsoleSettings[5]
			{
				new FxaaConsoleSettings
				{
					subpixelSpreadAmount = 0.33f,
					edgeSharpnessAmount = 8f,
					edgeDetectionThreshold = 0.25f,
					minimumRequiredLuminance = 0.06f
				},
				new FxaaConsoleSettings
				{
					subpixelSpreadAmount = 0.33f,
					edgeSharpnessAmount = 8f,
					edgeDetectionThreshold = 0.125f,
					minimumRequiredLuminance = 0.06f
				},
				new FxaaConsoleSettings
				{
					subpixelSpreadAmount = 0.5f,
					edgeSharpnessAmount = 8f,
					edgeDetectionThreshold = 0.125f,
					minimumRequiredLuminance = 0.05f
				},
				new FxaaConsoleSettings
				{
					subpixelSpreadAmount = 0.5f,
					edgeSharpnessAmount = 4f,
					edgeDetectionThreshold = 0.125f,
					minimumRequiredLuminance = 0.04f
				},
				new FxaaConsoleSettings
				{
					subpixelSpreadAmount = 0.5f,
					edgeSharpnessAmount = 2f,
					edgeDetectionThreshold = 0.125f,
					minimumRequiredLuminance = 0.04f
				}
			};
		}

		[Serializable]
		public struct FxaaSettings
		{
			public FxaaPreset preset;

			public static FxaaSettings defaultSettings
			{
				get
				{
					FxaaSettings result = default(FxaaSettings);
					result.preset = FxaaPreset.Default;
					return result;
				}
			}
		}

		[Serializable]
		public struct TaaSettings
		{
			[Tooltip("The diameter (in texels) inside which jitter samples are spread. Smaller values result in crisper but more aliased output, while larger values result in more stable but blurrier output.")]
			[Range(0.1f, 1f)]
			public float jitterSpread;

			[Tooltip("Controls the amount of sharpening applied to the color buffer.")]
			[Range(0f, 3f)]
			public float sharpen;

			[Tooltip("The blend coefficient for a stationary fragment. Controls the percentage of history sample blended into the final color.")]
			[Range(0f, 0.99f)]
			public float stationaryBlending;

			[Tooltip("The blend coefficient for a fragment with significant motion. Controls the percentage of history sample blended into the final color.")]
			[Range(0f, 0.99f)]
			public float motionBlending;

			public static TaaSettings defaultSettings
			{
				get
				{
					TaaSettings result = default(TaaSettings);
					result.jitterSpread = 0.75f;
					result.sharpen = 0.3f;
					result.stationaryBlending = 0.95f;
					result.motionBlending = 0.85f;
					return result;
				}
			}
		}

		[Serializable]
		public struct Settings
		{
			public Method method;

			public FxaaSettings fxaaSettings;

			public TaaSettings taaSettings;

			public static Settings defaultSettings
			{
				get
				{
					Settings result = default(Settings);
					result.method = Method.Fxaa;
					result.fxaaSettings = FxaaSettings.defaultSettings;
					result.taaSettings = TaaSettings.defaultSettings;
					return result;
				}
			}
		}

		[SerializeField]
		private Settings m_Settings = Settings.defaultSettings;

		public Settings settings
		{
			get
			{
				return m_Settings;
			}
			set
			{
				m_Settings = value;
			}
		}

		public override void Reset()
		{
			m_Settings = Settings.defaultSettings;
		}
	}
	[Serializable]
	public class BloomModel : PostProcessingModel
	{
		[Serializable]
		public struct BloomSettings
		{
			[Min(0f)]
			[Tooltip("Strength of the bloom filter.")]
			public float intensity;

			[Min(0f)]
			[Tooltip("Filters out pixels under this level of brightness.")]
			public float threshold;

			[Range(0f, 1f)]
			[Tooltip("Makes transition between under/over-threshold gradual (0 = hard threshold, 1 = soft threshold).")]
			public float softKnee;

			[Range(1f, 7f)]
			[Tooltip("Changes extent of veiling effects in a screen resolution-independent fashion.")]
			public float radius;

			[Tooltip("Reduces flashing noise with an additional filter.")]
			public bool antiFlicker;

			public float thresholdLinear
			{
				get
				{
					return Mathf.GammaToLinearSpace(threshold);
				}
				set
				{
					threshold = Mathf.LinearToGammaSpace(value);
				}
			}

			public static BloomSettings defaultSettings
			{
				get
				{
					BloomSettings result = default(BloomSettings);
					result.intensity = 0.5f;
					result.threshold = 1.1f;
					result.softKnee = 0.5f;
					result.radius = 4f;
					result.antiFlicker = false;
					return result;
				}
			}
		}

		[Serializable]
		public struct LensDirtSettings
		{
			[Tooltip("Dirtiness texture to add smudges or dust to the lens.")]
			public Texture texture;

			[Min(0f)]
			[Tooltip("Amount of lens dirtiness.")]
			public float intensity;

			public static LensDirtSettings defaultSettings
			{
				get
				{
					LensDirtSettings result = default(LensDirtSettings);
					result.texture = null;
					result.intensity = 3f;
					return result;
				}
			}
		}

		[Serializable]
		public struct Settings
		{
			public BloomSettings bloom;

			public LensDirtSettings lensDirt;

			public static Settings defaultSettings
			{
				get
				{
					Settings result = default(Settings);
					result.bloom = BloomSettings.defaultSettings;
					result.lensDirt = LensDirtSettings.defaultSettings;
					return result;
				}
			}
		}

		[SerializeField]
		private Settings m_Settings = Settings.defaultSettings;

		public Settings settings
		{
			get
			{
				return m_Settings;
			}
			set
			{
				m_Settings = value;
			}
		}

		public override void Reset()
		{
			m_Settings = Settings.defaultSettings;
		}
	}
	[Serializable]
	public class BuiltinDebugViewsModel : PostProcessingModel
	{
		[Serializable]
		public struct DepthSettings
		{
			[Range(0f, 1f)]
			[Tooltip("Scales the camera far plane before displaying the depth map.")]
			public float scale;

			public static DepthSettings defaultSettings
			{
				get
				{
					DepthSettings result = default(DepthSettings);
					result.scale = 1f;
					return result;
				}
			}
		}

		[Serializable]
		public struct MotionVectorsSettings
		{
			[Range(0f, 1f)]
			[Tooltip("Opacity of the source render.")]
			public float sourceOpacity;

			[Range(0f, 1f)]
			[Tooltip("Opacity of the per-pixel motion vector colors.")]
			public float motionImageOpacity;

			[Min(0f)]
			[Tooltip("Because motion vectors are mainly very small vectors, you can use this setting to make them more visible.")]
			public float motionImageAmplitude;

			[Range(0f, 1f)]
			[Tooltip("Opacity for the motion vector arrows.")]
			public float motionVectorsOpacity;

			[Range(8f, 64f)]
			[Tooltip("The arrow density on screen.")]
			public int motionVectorsResolution;

			[Min(0f)]
			[Tooltip("Tweaks the arrows length.")]
			public float motionVectorsAmplitude;

			public static MotionVectorsSettings defaultSettings
			{
				get
				{
					MotionVectorsSettings result = default(MotionVectorsSettings);
					result.sourceOpacity = 1f;
					result.motionImageOpacity = 0f;
					result.motionImageAmplitude = 16f;
					result.motionVectorsOpacity = 1f;
					result.motionVectorsResolution = 24;
					result.motionVectorsAmplitude = 64f;
					return result;
				}
			}
		}

		public enum Mode
		{
			None,
			Depth,
			Normals,
			MotionVectors,
			AmbientOcclusion,
			EyeAdaptation,
			FocusPlane,
			PreGradingLog,
			LogLut,
			UserLut
		}

		[Serializable]
		public struct Settings
		{
			public Mode mode;

			public DepthSettings depth;

			public MotionVectorsSettings motionVectors;

			public static Settings defaultSettings
			{
				get
				{
					Settings result = default(Settings);
					result.mode = Mode.None;
					result.depth = DepthSettings.defaultSettings;
					result.motionVectors = MotionVectorsSettings.defaultSettings;
					return result;
				}
			}
		}

		[SerializeField]
		private Settings m_Settings = Settings.defaultSettings;

		public Settings settings
		{
			get
			{
				return m_Settings;
			}
			set
			{
				m_Settings = value;
			}
		}

		public bool willInterrupt
		{
			get
			{
				if (!IsModeActive(Mode.None) && !IsModeActive(Mode.EyeAdaptation) && !IsModeActive(Mode.PreGradingLog) && !IsModeActive(Mode.LogLut))
				{
					return !IsModeActive(Mode.UserLut);
				}
				return false;
			}
		}

		public override void Reset()
		{
			settings = Settings.defaultSettings;
		}

		public bool IsModeActive(Mode mode)
		{
			return m_Settings.mode == mode;
		}
	}
	[Serializable]
	public class ChromaticAberrationModel : PostProcessingModel
	{
		[Serializable]
		public struct Settings
		{
			[Tooltip("Shift the hue of chromatic aberrations.")]
			public Texture2D spectralTexture;

			[Range(0f, 1f)]
			[Tooltip("Amount of tangential distortion.")]
			public float intensity;

			public static Settings defaultSettings
			{
				get
				{
					Settings result = default(Settings);
					result.spectralTexture = null;
					result.intensity = 0.1f;
					return result;
				}
			}
		}

		[SerializeField]
		private Settings m_Settings = Settings.defaultSettings;

		public Settings settings
		{
			get
			{
				return m_Settings;
			}
			set
			{
				m_Settings = value;
			}
		}

		public override void Reset()
		{
			m_Settings = Settings.defaultSettings;
		}
	}
	[Serializable]
	public class ColorGradingModel : PostProcessingModel
	{
		public enum Tonemapper
		{
			None,
			ACES,
			Neutral
		}

		[Serializable]
		public struct TonemappingSettings
		{
			[Tooltip("Tonemapping algorithm to use at the end of the color grading process. Use \"Neutral\" if you need a customizable tonemapper or \"Filmic\" to give a standard filmic look to your scenes.")]
			public Tonemapper tonemapper;

			[Range(-0.1f, 0.1f)]
			public float neutralBlackIn;

			[Range(1f, 20f)]
			public float neutralWhiteIn;

			[Range(-0.09f, 0.1f)]
			public float neutralBlackOut;

			[Range(1f, 19f)]
			public float neutralWhiteOut;

			[Range(0.1f, 20f)]
			public float neutralWhiteLevel;

			[Range(1f, 10f)]
			public float neutralWhiteClip;

			public static TonemappingSettings defaultSettings
			{
				get
				{
					TonemappingSettings result = default(TonemappingSettings);
					result.tonemapper = Tonemapper.Neutral;
					result.neutralBlackIn = 0.02f;
					result.neutralWhiteIn = 10f;
					result.neutralBlackOut = 0f;
					result.neutralWhiteOut = 10f;
					result.neutralWhiteLevel = 5.3f;
					result.neutralWhiteClip = 10f;
					return result;
				}
			}
		}

		[Serializable]
		public struct BasicSettings
		{
			[Tooltip("Adjusts the overall exposure of the scene in EV units. This is applied after HDR effect and right before tonemapping so it won't affect previous effects in the chain.")]
			public float postExposure;

			[Range(-100f, 100f)]
			[Tooltip("Sets the white balance to a custom color temperature.")]
			public float temperature;

			[Range(-100f, 100f)]
			[Tooltip("Sets the white balance to compensate for a green or magenta tint.")]
			public float tint;

			[Range(-180f, 180f)]
			[Tooltip("Shift the hue of all colors.")]
			public float hueShift;

			[Range(0f, 2f)]
			[Tooltip("Pushes the intensity of all colors.")]
			public float saturation;

			[Range(0f, 2f)]
			[Tooltip("Expands or shrinks the overall range of tonal values.")]
			public float contrast;

			public static BasicSettings defaultSettings
			{
				get
				{
					BasicSettings result = default(BasicSettings);
					result.postExposure = 0f;
					result.temperature = 0f;
					result.tint = 0f;
					result.hueShift = 0f;
					result.saturation = 1f;
					result.contrast = 1f;
					return result;
				}
			}
		}

		[Serializable]
		public struct ChannelMixerSettings
		{
			public Vector3 red;

			public Vector3 green;

			public Vector3 blue;

			[HideInInspector]
			public int currentEditingChannel;

			public static ChannelMixerSettings defaultSettings
			{
				get
				{
					ChannelMixerSettings result = default(ChannelMixerSettings);
					result.red = new Vector3(1f, 0f, 0f);
					result.green = new Vector3(0f, 1f, 0f);
					result.blue = new Vector3(0f, 0f, 1f);
					result.currentEditingChannel = 0;
					return result;
				}
			}
		}

		[Serializable]
		public struct LogWheelsSettings
		{
			[Trackball("GetSlopeValue")]
			public Color slope;

			[Trackball("GetPowerValue")]
			public Color power;

			[Trackball("GetOffsetValue")]
			public Color offset;

			public static LogWheelsSettings defaultSettings
			{
				get
				{
					LogWheelsSettings result = default(LogWheelsSettings);
					result.slope = Color.clear;
					result.power = Color.clear;
					result.offset = Color.clear;
					return result;
				}
			}
		}

		[Serializable]
		public struct LinearWheelsSettings
		{
			[Trackball("GetLiftValue")]
			public Color lift;

			[Trackball("GetGammaValue")]
			public Color gamma;

			[Trackball("GetGainValue")]
			public Color gain;

			public static LinearWheelsSettings defaultSettings
			{
				get
				{
					LinearWheelsSettings result = default(LinearWheelsSettings);
					result.lift = Color.clear;
					result.gamma = Color.clear;
					result.gain = Color.clear;
					return result;
				}
			}
		}

		public enum ColorWheelMode
		{
			Linear,
			Log
		}

		[Serializable]
		public struct ColorWheelsSettings
		{
			public ColorWheelMode mode;

			[TrackballGroup]
			public LogWheelsSettings log;

			[TrackballGroup]
			public LinearWheelsSettings linear;

			public static ColorWheelsSettings defaultSettings
			{
				get
				{
					ColorWheelsSettings result = default(ColorWheelsSettings);
					result.mode = ColorWheelMode.Log;
					result.log = LogWheelsSettings.defaultSettings;
					result.linear = LinearWheelsSettings.defaultSettings;
					return result;
				}
			}
		}

		[Serializable]
		public struct CurvesSettings
		{
			public ColorGradingCurve master;

			public ColorGradingCurve red;

			public ColorGradingCurve green;

			public ColorGradingCurve blue;

			public ColorGradingCurve hueVShue;

			public ColorGradingCurve hueVSsat;

			public ColorGradingCurve satVSsat;

			public ColorGradingCurve lumVSsat;

			[HideInInspector]
			public int e_CurrentEditingCurve;

			[HideInInspector]
			public bool e_CurveY;

			[HideInInspector]
			public bool e_CurveR;

			[HideInInspector]
			public bool e_CurveG;

			[HideInInspector]
			public bool e_CurveB;

			public static CurvesSettings defaultSettings
			{
				get
				{
					CurvesSettings result = default(CurvesSettings);
					result.master = new ColorGradingCurve(new AnimationCurve(new Keyframe(0f, 0f, 1f, 1f), new Keyframe(1f, 1f, 1f, 1f)), 0f, loop: false, new Vector2(0f, 1f));
					result.red = new ColorGradingCurve(new AnimationCurve(new Keyframe(0f, 0f, 1f, 1f), new Keyframe(1f, 1f, 1f, 1f)), 0f, loop: false, new Vector2(0f, 1f));
					result.green = new ColorGradingCurve(new AnimationCurve(new Keyframe(0f, 0f, 1f, 1f), new Keyframe(1f, 1f, 1f, 1f)), 0f, loop: false, new Vector2(0f, 1f));
					result.blue = new ColorGradingCurve(new AnimationCurve(new Keyframe(0f, 0f, 1f, 1f), new Keyframe(1f, 1f, 1f, 1f)), 0f, loop: false, new Vector2(0f, 1f));
					result.hueVShue = new ColorGradingCurve(new AnimationCurve(), 0.5f, loop: true, new Vector2(0f, 1f));
					result.hueVSsat = new ColorGradingCurve(new AnimationCurve(), 0.5f, loop: true, new Vector2(0f, 1f));
					result.satVSsat = new ColorGradingCurve(new AnimationCurve(), 0.5f, loop: false, new Vector2(0f, 1f));
					result.lumVSsat = new ColorGradingCurve(new AnimationCurve(), 0.5f, loop: false, new Vector2(0f, 1f));
					result.e_CurrentEditingCurve = 0;
					result.e_CurveY = true;
					result.e_CurveR = false;
					result.e_CurveG = false;
					result.e_CurveB = false;
					return result;
				}
			}
		}

		[Serializable]
		public struct Settings
		{
			public TonemappingSettings tonemapping;

			public BasicSettings basic;

			public ChannelMixerSettings channelMixer;

			public ColorWheelsSettings colorWheels;

			public CurvesSettings curves;

			public static Settings defaultSettings
			{
				get
				{
					Settings result = default(Settings);
					result.tonemapping = TonemappingSettings.defaultSettings;
					result.basic = BasicSettings.defaultSettings;
					result.channelMixer = ChannelMixerSettings.defaultSettings;
					result.colorWheels = ColorWheelsSettings.defaultSettings;
					result.curves = CurvesSettings.defaultSettings;
					return result;
				}
			}
		}

		[SerializeField]
		private Settings m_Settings = Settings.defaultSettings;

		public Settings settings
		{
			get
			{
				return m_Settings;
			}
			set
			{
				m_Settings = value;
				OnValidate();
			}
		}

		public bool isDirty { get; internal set; }

		public RenderTexture bakedLut { get; internal set; }

		public override void Reset()
		{
			m_Settings = Settings.defaultSettings;
			OnValidate();
		}

		public override void OnValidate()
		{
			isDirty = true;
		}
	}
	[Serializable]
	public class DepthOfFieldModel : PostProcessingModel
	{
		public enum KernelSize
		{
			Small,
			Medium,
			Large,
			VeryLarge
		}

		[Serializable]
		public struct Settings
		{
			[Min(0.1f)]
			[Tooltip("Distance to the point of focus.")]
			public float focusDistance;

			[Range(0.05f, 32f)]
			[Tooltip("Ratio of aperture (known as f-stop or f-number). The smaller the value is, the shallower the depth of field is.")]
			public float aperture;

			[Range(1f, 300f)]
			[Tooltip("Distance between the lens and the film. The larger the value is, the shallower the depth of field is.")]
			public float focalLength;

			[Tooltip("Calculate the focal length automatically from the field-of-view value set on the camera. Using this setting isn't recommended.")]
			public bool useCameraFov;

			[Tooltip("Convolution kernel size of the bokeh filter, which determines the maximum radius of bokeh. It also affects the performance (the larger the kernel is, the longer the GPU time is required).")]
			public KernelSize kernelSize;

			public static Settings defaultSettings
			{
				get
				{
					Settings result = default(Settings);
					result.focusDistance = 10f;
					result.aperture = 5.6f;
					result.focalLength = 50f;
					result.useCameraFov = false;
					result.kernelSize = KernelSize.Medium;
					return result;
				}
			}
		}

		[SerializeField]
		private Settings m_Settings = Settings.defaultSettings;

		public Settings settings
		{
			get
			{
				return m_Settings;
			}
			set
			{
				m_Settings = value;
			}
		}

		public override void Reset()
		{
			m_Settings = Settings.defaultSettings;
		}
	}
	[Serializable]
	public class DitheringModel : PostProcessingModel
	{
		[Serializable]
		[StructLayout(LayoutKind.Sequential, Size = 1)]
		public struct Settings
		{
			public static Settings defaultSettings => default(Settings);
		}

		[SerializeField]
		private Settings m_Settings = Settings.defaultSettings;

		public Settings settings
		{
			get
			{
				return m_Settings;
			}
			set
			{
				m_Settings = value;
			}
		}

		public override void Reset()
		{
			m_Settings = Settings.defaultSettings;
		}
	}
	[Serializable]
	public class EyeAdaptationModel : PostProcessingModel
	{
		public enum EyeAdaptationType
		{
			Progressive,
			Fixed
		}

		[Serializable]
		public struct Settings
		{
			[Range(1f, 99f)]
			[Tooltip("Filters the dark part of the histogram when computing the average luminance to avoid very dark pixels from contributing to the auto exposure. Unit is in percent.")]
			public float lowPercent;

			[Range(1f, 99f)]
			[Tooltip("Filters the bright part of the histogram when computing the average luminance to avoid very dark pixels from contributing to the auto exposure. Unit is in percent.")]
			public float highPercent;

			[Tooltip("Minimum average luminance to consider for auto exposure (in EV).")]
			public float minLuminance;

			[Tooltip("Maximum average luminance to consider for auto exposure (in EV).")]
			public float maxLuminance;

			[Min(0f)]
			[Tooltip("Exposure bias. Use this to offset the global exposure of the scene.")]
			public float keyValue;

			[Tooltip("Set this to true to let Unity handle the key value automatically based on average luminance.")]
			public bool dynamicKeyValue;

			[Tooltip("Use \"Progressive\" if you want the auto exposure to be animated. Use \"Fixed\" otherwise.")]
			public EyeAdaptationType adaptationType;

			[Min(0f)]
			[Tooltip("Adaptation speed from a dark to a light environment.")]
			public float speedUp;

			[Min(0f)]
			[Tooltip("Adaptation speed from a light to a dark environment.")]
			public float speedDown;

			[Range(-16f, -1f)]
			[Tooltip("Lower bound for the brightness range of the generated histogram (in EV). The bigger the spread between min & max, the lower the precision will be.")]
			public int logMin;

			[Range(1f, 16f)]
			[Tooltip("Upper bound for the brightness range of the generated histogram (in EV). The bigger the spread between min & max, the lower the precision will be.")]
			public int logMax;

			public static Settings defaultSettings
			{
				get
				{
					Settings result = default(Settings);
					result.lowPercent = 45f;
					result.highPercent = 95f;
					result.minLuminance = -5f;
					result.maxLuminance = 1f;
					result.keyValue = 0.25f;
					result.dynamicKeyValue = true;
					result.adaptationType = EyeAdaptationType.Progressive;
					result.speedUp = 2f;
					result.speedDown = 1f;
					result.logMin = -8;
					result.logMax = 4;
					return result;
				}
			}
		}

		[SerializeField]
		private Settings m_Settings = Settings.defaultSettings;

		public Settings settings
		{
			get
			{
				return m_Settings;
			}
			set
			{
				m_Settings = value;
			}
		}

		public override void Reset()
		{
			m_Settings = Settings.defaultSettings;
		}
	}
	[Serializable]
	public class FogModel : PostProcessingModel
	{
		[Serializable]
		public struct Settings
		{
			[Tooltip("Should the fog affect the skybox?")]
			public bool excludeSkybox;

			public static Settings defaultSettings
			{
				get
				{
					Settings result = default(Settings);
					result.excludeSkybox = true;
					return result;
				}
			}
		}

		[SerializeField]
		private Settings m_Settings = Settings.defaultSettings;

		public Settings settings
		{
			get
			{
				return m_Settings;
			}
			set
			{
				m_Settings = value;
			}
		}

		public override void Reset()
		{
			m_Settings = Settings.defaultSettings;
		}
	}
	[Serializable]
	public class GrainModel : PostProcessingModel
	{
		[Serializable]
		public struct Settings
		{
			[Tooltip("Enable the use of colored grain.")]
			public bool colored;

			[Range(0f, 1f)]
			[Tooltip("Grain strength. Higher means more visible grain.")]
			public float intensity;

			[Range(0.3f, 3f)]
			[Tooltip("Grain particle size.")]
			public float size;

			[Range(0f, 1f)]
			[Tooltip("Controls the noisiness response curve based on scene luminance. Lower values mean less noise in dark areas.")]
			public float luminanceContribution;

			public static Settings defaultSettings
			{
				get
				{
					Settings result = default(Settings);
					result.colored = true;
					result.intensity = 0.5f;
					result.size = 1f;
					result.luminanceContribution = 0.8f;
					return result;
				}
			}
		}

		[SerializeField]
		private Settings m_Settings = Settings.defaultSettings;

		public Settings settings
		{
			get
			{
				return m_Settings;
			}
			set
			{
				m_Settings = value;
			}
		}

		public override void Reset()
		{
			m_Settings = Settings.defaultSettings;
		}
	}
	[Serializable]
	public class MotionBlurModel : PostProcessingModel
	{
		[Serializable]
		public struct Settings
		{
			[Range(0f, 360f)]
			[Tooltip("The angle of rotary shutter. Larger values give longer exposure.")]
			public float shutterAngle;

			[Range(4f, 32f)]
			[Tooltip("The amount of sample points, which affects quality and performances.")]
			public int sampleCount;

			[Range(0f, 1f)]
			[Tooltip("The strength of multiple frame blending. The opacity of preceding frames are determined from this coefficient and time differences.")]
			public float frameBlending;

			public static Settings defaultSettings
			{
				get
				{
					Settings result = default(Settings);
					result.shutterAngle = 270f;
					result.sampleCount = 10;
					result.frameBlending = 0f;
					return result;
				}
			}
		}

		[SerializeField]
		private Settings m_Settings = Settings.defaultSettings;

		public Settings settings
		{
			get
			{
				return m_Settings;
			}
			set
			{
				m_Settings = value;
			}
		}

		public override void Reset()
		{
			m_Settings = Settings.defaultSettings;
		}
	}
	[Serializable]
	public class ScreenSpaceReflectionModel : PostProcessingModel
	{
		public enum SSRResolution
		{
			High = 0,
			Low = 2
		}

		public enum SSRReflectionBlendType
		{
			PhysicallyBased,
			Additive
		}

		[Serializable]
		public struct IntensitySettings
		{
			[Tooltip("Nonphysical multiplier for the SSR reflections. 1.0 is physically based.")]
			[Range(0f, 2f)]
			public float reflectionMultiplier;

			[Tooltip("How far away from the maxDistance to begin fading SSR.")]
			[Range(0f, 1000f)]
			public float fadeDistance;

			[Tooltip("Amplify Fresnel fade out. Increase if floor reflections look good close to the surface and bad farther 'under' the floor.")]
			[Range(0f, 1f)]
			public float fresnelFade;

			[Tooltip("Higher values correspond to a faster Fresnel fade as the reflection changes from the grazing angle.")]
			[Range(0.1f, 10f)]
			public float fresnelFadePower;
		}

		[Serializable]
		public struct ReflectionSettings
		{
			[Tooltip("How the reflections are blended into the render.")]
			public SSRReflectionBlendType blendType;

			[Tooltip("Half resolution SSRR is much faster, but less accurate.")]
			public SSRResolution reflectionQuality;

			[Tooltip("Maximum reflection distance in world units.")]
			[Range(0.1f, 300f)]
			public float maxDistance;

			[Tooltip("Max raytracing length.")]
			[Range(16f, 1024f)]
			public int iterationCount;

			[Tooltip("Log base 2 of ray tracing coarse step size. Higher traces farther, lower gives better quality silhouettes.")]
			[Range(1f, 16f)]
			public int stepSize;

			[Tooltip("Typical thickness of columns, walls, furniture, and other objects that reflection rays might pass behind.")]
			[Range(0.01f, 10f)]
			public float widthModifier;

			[Tooltip("Blurriness of reflections.")]
			[Range(0.1f, 8f)]
			public float reflectionBlur;

			[Tooltip("Disable for a performance gain in scenes where most glossy objects are horizontal, like floors, water, and tables. Leave on for scenes with glossy vertical objects.")]
			public bool reflectBackfaces;
		}

		[Serializable]
		public struct ScreenEdgeMask
		{
			[Tooltip("Higher = fade out SSRR near the edge of the screen so that reflections don't pop under camera motion.")]
			[Range(0f, 1f)]
			public float intensity;
		}

		[Serializable]
		public struct Settings
		{
			public ReflectionSettings reflection;

			public IntensitySettings intensity;

			public ScreenEdgeMask screenEdgeMask;

			public static Settings defaultSettings
			{
				get
				{
					Settings result = default(Settings);
					result.reflection = new ReflectionSettings
					{
						blendType = SSRReflectionBlendType.PhysicallyBased,
						reflectionQuality = SSRResolution.Low,
						maxDistance = 100f,
						iterationCount = 256,
						stepSize = 3,
						widthModifier = 0.5f,
						reflectionBlur = 1f,
						reflectBackfaces = false
					};
					result.intensity = new IntensitySettings
					{
						reflectionMultiplier = 1f,
						fadeDistance = 100f,
						fresnelFade = 1f,
						fresnelFadePower = 1f
					};
					result.screenEdgeMask = new ScreenEdgeMask
					{
						intensity = 0.03f
					};
					return result;
				}
			}
		}

		[SerializeField]
		private Settings m_Settings = Settings.defaultSettings;

		public Settings settings
		{
			get
			{
				return m_Settings;
			}
			set
			{
				m_Settings = value;
			}
		}

		public override void Reset()
		{
			m_Settings = Settings.defaultSettings;
		}
	}
	[Serializable]
	public class UserLutModel : PostProcessingModel
	{
		[Serializable]
		public struct Settings
		{
			[Tooltip("Custom lookup texture (strip format, e.g. 256x16).")]
			public Texture2D lut;

			[Range(0f, 1f)]
			[Tooltip("Blending factor.")]
			public float contribution;

			public static Settings defaultSettings
			{
				get
				{
					Settings result = default(Settings);
					result.lut = null;
					result.contribution = 1f;
					return result;
				}
			}
		}

		[SerializeField]
		private Settings m_Settings = Settings.defaultSettings;

		public Settings settings
		{
			get
			{
				return m_Settings;
			}
			set
			{
				m_Settings = value;
			}
		}

		public override void Reset()
		{
			m_Settings = Settings.defaultSettings;
		}
	}
	[Serializable]
	public class VignetteModel : PostProcessingModel
	{
		public enum Mode
		{
			Classic,
			Masked
		}

		[Serializable]
		public struct Settings
		{
			[Tooltip("Use the \"Classic\" mode for parametric controls. Use the \"Masked\" mode to use your own texture mask.")]
			public Mode mode;

			[ColorUsage(false)]
			[Tooltip("Vignette color. Use the alpha channel for transparency.")]
			public Color color;

			[Tooltip("Sets the vignette center point (screen center is [0.5,0.5]).")]
			public Vector2 center;

			[Range(0f, 1f)]
			[Tooltip("Amount of vignetting on screen.")]
			public float intensity;

			[Range(0.01f, 1f)]
			[Tooltip("Smoothness of the vignette borders.")]
			public float smoothness;

			[Range(0f, 1f)]
			[Tooltip("Lower values will make a square-ish vignette.")]
			public float roundness;

			[Tooltip("A black and white mask to use as a vignette.")]
			public Texture mask;

			[Range(0f, 1f)]
			[Tooltip("Mask opacity.")]
			public float opacity;

			[Tooltip("Should the vignette be perfectly round or be dependent on the current aspect ratio?")]
			public bool rounded;

			public static Settings defaultSettings
			{
				get
				{
					Settings result = default(Settings);
					result.mode = Mode.Classic;
					result.color = new Color(0f, 0f, 0f, 1f);
					result.center = new Vector2(0.5f, 0.5f);
					result.intensity = 0.45f;
					result.smoothness = 0.2f;
					result.roundness = 1f;
					result.mask = null;
					result.opacity = 1f;
					result.rounded = false;
					return result;
				}
			}
		}

		[SerializeField]
		private Settings m_Settings = Settings.defaultSettings;

		public Settings settings
		{
			get
			{
				return m_Settings;
			}
			set
			{
				m_Settings = value;
			}
		}

		public void SetIntensity(float value)
		{
			m_Settings.intensity = value;
		}

		public override void Reset()
		{
			m_Settings = Settings.defaultSettings;
		}
	}
	[ImageEffectAllowedInSceneView]
	[RequireComponent(typeof(Camera))]
	[DisallowMultipleComponent]
	[ExecuteInEditMode]
	[AddComponentMenu("Effects/Post-Processing Behaviour", -1)]
	public class PostProcessingBehaviour : MonoBehaviour
	{
		public PostProcessingProfile profile;

		public Func<Vector2, Matrix4x4> jitteredMatrixFunc;

		private Dictionary<Type, KeyValuePair<CameraEvent, CommandBuffer>> m_CommandBuffers;

		private List<PostProcessingComponentBase> m_Components;

		private Dictionary<PostProcessingComponentBase, bool> m_ComponentStates;

		private MaterialFactory m_MaterialFactory;

		private RenderTextureFactory m_RenderTextureFactory;

		private PostProcessingContext m_Context;

		private Camera m_Camera;

		private PostProcessingProfile m_PreviousProfile;

		private bool m_RenderingInSceneView;

		private BuiltinDebugViewsComponent m_DebugViews;

		private AmbientOcclusionComponent m_AmbientOcclusion;

		private ScreenSpaceReflectionComponent m_ScreenSpaceReflection;

		private FogComponent m_FogComponent;

		private MotionBlurComponent m_MotionBlur;

		private TaaComponent m_Taa;

		private EyeAdaptationComponent m_EyeAdaptation;

		private DepthOfFieldComponent m_DepthOfField;

		private BloomComponent m_Bloom;

		private ChromaticAberrationComponent m_ChromaticAberration;

		private ColorGradingComponent m_ColorGrading;

		private UserLutComponent m_UserLut;

		private GrainComponent m_Grain;

		private VignetteComponent m_Vignette;

		private DitheringComponent m_Dithering;

		private FxaaComponent m_Fxaa;

		private List<PostProcessingComponentBase> m_ComponentsToEnable = new List<PostProcessingComponentBase>();

		private List<PostProcessingComponentBase> m_ComponentsToDisable = new List<PostProcessingComponentBase>();

		private void OnEnable()
		{
			m_CommandBuffers = new Dictionary<Type, KeyValuePair<CameraEvent, CommandBuffer>>();
			m_MaterialFactory = new MaterialFactory();
			m_RenderTextureFactory = new RenderTextureFactory();
			m_Context = new PostProcessingContext();
			m_Components = new List<PostProcessingComponentBase>();
			m_DebugViews = AddComponent(new BuiltinDebugViewsComponent());
			m_AmbientOcclusion = AddComponent(new AmbientOcclusionComponent());
			m_ScreenSpaceReflection = AddComponent(new ScreenSpaceReflectionComponent());
			m_FogComponent = AddComponent(new FogComponent());
			m_MotionBlur = AddComponent(new MotionBlurComponent());
			m_Taa = AddComponent(new TaaComponent());
			m_EyeAdaptation = AddComponent(new EyeAdaptationComponent());
			m_DepthOfField = AddComponent(new DepthOfFieldComponent());
			m_Bloom = AddComponent(new BloomComponent());
			m_ChromaticAberration = AddComponent(new ChromaticAberrationComponent());
			m_ColorGrading = AddComponent(new ColorGradingComponent());
			m_UserLut = AddComponent(new UserLutComponent());
			m_Grain = AddComponent(new GrainComponent());
			m_Vignette = AddComponent(new VignetteComponent());
			m_Dithering = AddComponent(new DitheringComponent());
			m_Fxaa = AddComponent(new FxaaComponent());
			m_ComponentStates = new Dictionary<PostProcessingComponentBase, bool>();
			foreach (PostProcessingComponentBase component in m_Components)
			{
				m_ComponentStates.Add(component, value: false);
			}
			base.useGUILayout = false;
		}

		private void OnPreCull()
		{
			m_Camera = GetComponent<Camera>();
			if (profile == null || m_Camera == null)
			{
				return;
			}
			PostProcessingContext postProcessingContext = m_Context.Reset();
			postProcessingContext.profile = profile;
			postProcessingContext.renderTextureFactory = m_RenderTextureFactory;
			postProcessingContext.materialFactory = m_MaterialFactory;
			postProcessingContext.camera = m_Camera;
			m_DebugViews.Init(postProcessingContext, profile.debugViews);
			m_AmbientOcclusion.Init(postProcessingContext, profile.ambientOcclusion);
			m_ScreenSpaceReflection.Init(postProcessingContext, profile.screenSpaceReflection);
			m_FogComponent.Init(postProcessingContext, profile.fog);
			m_MotionBlur.Init(postProcessingContext, profile.motionBlur);
			m_Taa.Init(postProcessingContext, profile.antialiasing);
			m_EyeAdaptation.Init(postProcessingContext, profile.eyeAdaptation);
			m_DepthOfField.Init(postProcessingContext, profile.depthOfField);
			m_Bloom.Init(postProcessingContext, profile.bloom);
			m_ChromaticAberration.Init(postProcessingContext, profile.chromaticAberration);
			m_ColorGrading.Init(postProcessingContext, profile.colorGrading);
			m_UserLut.Init(postProcessingContext, profile.userLut);
			m_Grain.Init(postProcessingContext, profile.grain);
			m_Vignette.Init(postProcessingContext, profile.vignette);
			m_Dithering.Init(postProcessingContext, profile.dithering);
			m_Fxaa.Init(postProcessingContext, profile.antialiasing);
			if (m_PreviousProfile != profile)
			{
				DisableComponents();
				m_PreviousProfile = profile;
			}
			CheckObservers();
			DepthTextureMode depthTextureMode = postProcessingContext.camera.depthTextureMode;
			foreach (PostProcessingComponentBase component in m_Components)
			{
				if (component.active)
				{
					depthTextureMode |= component.GetCameraFlags();
				}
			}
			postProcessingContext.camera.depthTextureMode = depthTextureMode;
			if (!m_RenderingInSceneView && m_Taa.active && !profile.debugViews.willInterrupt)
			{
				m_Taa.SetProjectionMatrix(jitteredMatrixFunc);
			}
		}

		private void OnPreRender()
		{
			if (!(profile == null))
			{
				TryExecuteCommandBuffer(m_DebugViews);
				TryExecuteCommandBuffer(m_AmbientOcclusion);
				TryExecuteCommandBuffer(m_ScreenSpaceReflection);
				TryExecuteCommandBuffer(m_FogComponent);
				if (!m_RenderingInSceneView)
				{
					TryExecuteCommandBuffer(m_MotionBlur);
				}
			}
		}

		private void OnPostRender()
		{
			if (!(profile == null) && !(m_Camera == null) && !m_RenderingInSceneView && m_Taa.active && !profile.debugViews.willInterrupt)
			{
				m_Context.camera.ResetProjectionMatrix();
			}
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (profile == null || m_Camera == null)
			{
				Graphics.Blit(source, destination);
				return;
			}
			bool flag = false;
			bool active = m_Fxaa.active;
			bool flag2 = m_Taa.active && !m_RenderingInSceneView;
			bool num = m_DepthOfField.active && !m_RenderingInSceneView;
			Material material = m_MaterialFactory.Get("Hidden/Post FX/Uber Shader");
			material.shaderKeywords = null;
			RenderTexture renderTexture = source;
			if (flag2)
			{
				RenderTexture renderTexture2 = m_RenderTextureFactory.Get(renderTexture);
				m_Taa.Render(renderTexture, renderTexture2);
				renderTexture = renderTexture2;
			}
			Texture texture = GraphicsUtils.whiteTexture;
			if (m_EyeAdaptation.active)
			{
				flag = true;
				texture = m_EyeAdaptation.Prepare(renderTexture, material);
			}
			material.SetTexture("_AutoExposure", texture);
			if (num)
			{
				flag = true;
				m_DepthOfField.Prepare(renderTexture, material, flag2, m_Taa.jitterVector, m_Taa.model.settings.taaSettings.motionBlending);
			}
			if (m_Bloom.active)
			{
				flag = true;
				m_Bloom.Prepare(renderTexture, material, texture);
			}
			flag |= TryPrepareUberImageEffect(m_ChromaticAberration, material);
			flag |= TryPrepareUberImageEffect(m_ColorGrading, material);
			flag |= TryPrepareUberImageEffect(m_Vignette, material);
			flag |= TryPrepareUberImageEffect(m_UserLut, material);
			Material material2 = (active ? m_MaterialFactory.Get("Hidden/Post FX/FXAA") : null);
			if (active)
			{
				material2.shaderKeywords = null;
				TryPrepareUberImageEffect(m_Grain, material2);
				TryPrepareUberImageEffect(m_Dithering, material2);
				if (flag)
				{
					RenderTexture renderTexture3 = m_RenderTextureFactory.Get(renderTexture);
					Graphics.Blit(renderTexture, renderTexture3, material, 0);
					renderTexture = renderTexture3;
				}
				m_Fxaa.Render(renderTexture, destination);
			}
			else
			{
				flag |= TryPrepareUberImageEffect(m_Grain, material);
				flag |= TryPrepareUberImageEffect(m_Dithering, material);
				if (flag)
				{
					if (!GraphicsUtils.isLinearColorSpace)
					{
						material.EnableKeyword("UNITY_COLORSPACE_GAMMA");
					}
					Graphics.Blit(renderTexture, destination, material, 0);
				}
			}
			if (!flag && !active)
			{
				Graphics.Blit(renderTexture, destination);
			}
			m_RenderTextureFactory.ReleaseAll();
		}

		private void OnGUI()
		{
			if (Event.current.type == EventType.Repaint && !(profile == null) && !(m_Camera == null))
			{
				if (m_EyeAdaptation.active && profile.debugViews.IsModeActive(BuiltinDebugViewsModel.Mode.EyeAdaptation))
				{
					m_EyeAdaptation.OnGUI();
				}
				else if (m_ColorGrading.active && profile.debugViews.IsModeActive(BuiltinDebugViewsModel.Mode.LogLut))
				{
					m_ColorGrading.OnGUI();
				}
				else if (m_UserLut.active && profile.debugViews.IsModeActive(BuiltinDebugViewsModel.Mode.UserLut))
				{
					m_UserLut.OnGUI();
				}
			}
		}

		private void OnDisable()
		{
			foreach (KeyValuePair<CameraEvent, CommandBuffer> value in m_CommandBuffers.Values)
			{
				m_Camera.RemoveCommandBuffer(value.Key, value.Value);
				value.Value.Dispose();
			}
			m_CommandBuffers.Clear();
			if (profile != null)
			{
				DisableComponents();
			}
			m_Components.Clear();
			m_MaterialFactory.Dispose();
			m_RenderTextureFactory.Dispose();
			GraphicsUtils.Dispose();
		}

		public void ResetTemporalEffects()
		{
			m_Taa.ResetHistory();
			m_MotionBlur.ResetHistory();
			m_EyeAdaptation.ResetHistory();
		}

		private void CheckObservers()
		{
			foreach (KeyValuePair<PostProcessingComponentBase, bool> componentState in m_ComponentStates)
			{
				PostProcessingComponentBase key = componentState.Key;
				bool flag = key.GetModel().enabled;
				if (flag != componentState.Value)
				{
					if (flag)
					{
						m_ComponentsToEnable.Add(key);
					}
					else
					{
						m_ComponentsToDisable.Add(key);
					}
				}
			}
			for (int i = 0; i < m_ComponentsToDisable.Count; i++)
			{
				PostProcessingComponentBase postProcessingComponentBase = m_ComponentsToDisable[i];
				m_ComponentStates[postProcessingComponentBase] = false;
				postProcessingComponentBase.OnDisable();
			}
			for (int j = 0; j < m_ComponentsToEnable.Count; j++)
			{
				PostProcessingComponentBase postProcessingComponentBase2 = m_ComponentsToEnable[j];
				m_ComponentStates[postProcessingComponentBase2] = true;
				postProcessingComponentBase2.OnEnable();
			}
			m_ComponentsToDisable.Clear();
			m_ComponentsToEnable.Clear();
		}

		private void DisableComponents()
		{
			foreach (PostProcessingComponentBase component in m_Components)
			{
				PostProcessingModel model = component.GetModel();
				if (model != null && model.enabled)
				{
					component.OnDisable();
				}
			}
		}

		private CommandBuffer AddCommandBuffer<T>(CameraEvent evt, string name) where T : PostProcessingModel
		{
			CommandBuffer value = new CommandBuffer
			{
				name = name
			};
			KeyValuePair<CameraEvent, CommandBuffer> value2 = new KeyValuePair<CameraEvent, CommandBuffer>(evt, value);
			m_CommandBuffers.Add(typeof(T), value2);
			m_Camera.AddCommandBuffer(evt, value2.Value);
			return value2.Value;
		}

		private void RemoveCommandBuffer<T>() where T : PostProcessingModel
		{
			Type typeFromHandle = typeof(T);
			if (m_CommandBuffers.TryGetValue(typeFromHandle, out var value))
			{
				m_Camera.RemoveCommandBuffer(value.Key, value.Value);
				m_CommandBuffers.Remove(typeFromHandle);
				value.Value.Dispose();
			}
		}

		private CommandBuffer GetCommandBuffer<T>(CameraEvent evt, string name) where T : PostProcessingModel
		{
			if (!m_CommandBuffers.TryGetValue(typeof(T), out var value))
			{
				return AddCommandBuffer<T>(evt, name);
			}
			if (value.Key != evt)
			{
				RemoveCommandBuffer<T>();
				return AddCommandBuffer<T>(evt, name);
			}
			return value.Value;
		}

		private void TryExecuteCommandBuffer<T>(PostProcessingComponentCommandBuffer<T> component) where T : PostProcessingModel
		{
			if (component.active)
			{
				CommandBuffer commandBuffer = GetCommandBuffer<T>(component.GetCameraEvent(), component.GetName());
				commandBuffer.Clear();
				component.PopulateCommandBuffer(commandBuffer);
			}
			else
			{
				RemoveCommandBuffer<T>();
			}
		}

		private bool TryPrepareUberImageEffect<T>(PostProcessingComponentRenderTexture<T> component, Material material) where T : PostProcessingModel
		{
			if (!component.active)
			{
				return false;
			}
			component.Prepare(material);
			return true;
		}

		private T AddComponent<T>(T component) where T : PostProcessingComponentBase
		{
			m_Components.Add(component);
			return component;
		}
	}
	public abstract class PostProcessingComponentBase
	{
		public PostProcessingContext context;

		public abstract bool active { get; }

		public virtual DepthTextureMode GetCameraFlags()
		{
			return DepthTextureMode.None;
		}

		public virtual void OnEnable()
		{
		}

		public virtual void OnDisable()
		{
		}

		public abstract PostProcessingModel GetModel();
	}
	public abstract class PostProcessingComponent<T> : PostProcessingComponentBase where T : PostProcessingModel
	{
		public T model { get; internal set; }

		public virtual void Init(PostProcessingContext pcontext, T pmodel)
		{
			context = pcontext;
			model = pmodel;
		}

		public override PostProcessingModel GetModel()
		{
			return model;
		}
	}
	public abstract class PostProcessingComponentCommandBuffer<T> : PostProcessingComponent<T> where T : PostProcessingModel
	{
		public abstract CameraEvent GetCameraEvent();

		public abstract string GetName();

		public abstract void PopulateCommandBuffer(CommandBuffer cb);
	}
	public abstract class PostProcessingComponentRenderTexture<T> : PostProcessingComponent<T> where T : PostProcessingModel
	{
		public virtual void Prepare(Material material)
		{
		}
	}
	public class PostProcessingContext
	{
		public PostProcessingProfile profile;

		public Camera camera;

		public MaterialFactory materialFactory;

		public RenderTextureFactory renderTextureFactory;

		public bool interrupted { get; private set; }

		public bool isGBufferAvailable => camera.actualRenderingPath == RenderingPath.DeferredShading;

		public bool isHdr => camera.allowHDR;

		public int width => camera.pixelWidth;

		public int height => camera.pixelHeight;

		public Rect viewport => camera.rect;

		public void Interrupt()
		{
			interrupted = true;
		}

		public PostProcessingContext Reset()
		{
			profile = null;
			camera = null;
			materialFactory = null;
			renderTextureFactory = null;
			interrupted = false;
			return this;
		}
	}
	[Serializable]
	public abstract class PostProcessingModel
	{
		[SerializeField]
		[GetSet("enabled")]
		private bool m_Enabled;

		public bool enabled
		{
			get
			{
				return m_Enabled;
			}
			set
			{
				m_Enabled = value;
				if (value)
				{
					OnValidate();
				}
			}
		}

		public abstract void Reset();

		public virtual void OnValidate()
		{
		}
	}
	public class PostProcessingProfile : ScriptableObject
	{
		public BuiltinDebugViewsModel debugViews = new BuiltinDebugViewsModel();

		public FogModel fog = new FogModel();

		public AntialiasingModel antialiasing = new AntialiasingModel();

		public AmbientOcclusionModel ambientOcclusion = new AmbientOcclusionModel();

		public ScreenSpaceReflectionModel screenSpaceReflection = new ScreenSpaceReflectionModel();

		public DepthOfFieldModel depthOfField = new DepthOfFieldModel();

		public MotionBlurModel motionBlur = new MotionBlurModel();

		public EyeAdaptationModel eyeAdaptation = new EyeAdaptationModel();

		public BloomModel bloom = new BloomModel();

		public ColorGradingModel colorGrading = new ColorGradingModel();

		public UserLutModel userLut = new UserLutModel();

		public ChromaticAberrationModel chromaticAberration = new ChromaticAberrationModel();

		public GrainModel grain = new GrainModel();

		public VignetteModel vignette = new VignetteModel();

		public DitheringModel dithering = new DitheringModel();
	}
	[Serializable]
	public sealed class ColorGradingCurve
	{
		public AnimationCurve curve;

		[SerializeField]
		private bool m_Loop;

		[SerializeField]
		private float m_ZeroValue;

		[SerializeField]
		private float m_Range;

		private AnimationCurve m_InternalLoopingCurve;

		public ColorGradingCurve(AnimationCurve curve, float zeroValue, bool loop, Vector2 bounds)
		{
			this.curve = curve;
			m_ZeroValue = zeroValue;
			m_Loop = loop;
			m_Range = bounds.magnitude;
		}

		public void Cache()
		{
			if (!m_Loop)
			{
				return;
			}
			int length = curve.length;
			if (length >= 2)
			{
				if (m_InternalLoopingCurve == null)
				{
					m_InternalLoopingCurve = new AnimationCurve();
				}
				Keyframe key = curve[length - 1];
				key.time -= m_Range;
				Keyframe key2 = curve[0];
				key2.time += m_Range;
				m_InternalLoopingCurve.keys = curve.keys;
				m_InternalLoopingCurve.AddKey(key);
				m_InternalLoopingCurve.AddKey(key2);
			}
		}

		public float Evaluate(float t)
		{
			if (curve.length == 0)
			{
				return m_ZeroValue;
			}
			if (!m_Loop || curve.length == 1)
			{
				return curve.Evaluate(t);
			}
			return m_InternalLoopingCurve.Evaluate(t);
		}
	}
	public static class GraphicsUtils
	{
		private static Texture2D s_WhiteTexture;

		private static Mesh s_Quad;

		public static bool isLinearColorSpace => QualitySettings.activeColorSpace == ColorSpace.Linear;

		public static bool supportsDX11
		{
			get
			{
				if (SystemInfo.graphicsShaderLevel >= 50)
				{
					return SystemInfo.supportsComputeShaders;
				}
				return false;
			}
		}

		public static Texture2D whiteTexture
		{
			get
			{
				if (s_WhiteTexture != null)
				{
					return s_WhiteTexture;
				}
				s_WhiteTexture = new Texture2D(1, 1, TextureFormat.ARGB32, mipChain: false);
				s_WhiteTexture.SetPixel(0, 0, new Color(1f, 1f, 1f, 1f));
				s_WhiteTexture.Apply();
				return s_WhiteTexture;
			}
		}

		public static Mesh quad
		{
			get
			{
				if (s_Quad != null)
				{
					return s_Quad;
				}
				Vector3[] vertices = new Vector3[4]
				{
					new Vector3(-1f, -1f, 0f),
					new Vector3(1f, 1f, 0f),
					new Vector3(1f, -1f, 0f),
					new Vector3(-1f, 1f, 0f)
				};
				Vector2[] uv = new Vector2[4]
				{
					new Vector2(0f, 0f),
					new Vector2(1f, 1f),
					new Vector2(1f, 0f),
					new Vector2(0f, 1f)
				};
				int[] triangles = new int[6] { 0, 1, 2, 1, 0, 3 };
				s_Quad = new Mesh
				{
					vertices = vertices,
					uv = uv,
					triangles = triangles
				};
				s_Quad.RecalculateNormals();
				s_Quad.RecalculateBounds();
				return s_Quad;
			}
		}

		public static void Blit(Material material, int pass)
		{
			GL.PushMatrix();
			GL.LoadOrtho();
			material.SetPass(pass);
			GL.Begin(5);
			GL.TexCoord2(0f, 0f);
			GL.Vertex3(0f, 0f, 0.1f);
			GL.TexCoord2(1f, 0f);
			GL.Vertex3(1f, 0f, 0.1f);
			GL.TexCoord2(0f, 1f);
			GL.Vertex3(0f, 1f, 0.1f);
			GL.TexCoord2(1f, 1f);
			GL.Vertex3(1f, 1f, 0.1f);
			GL.End();
			GL.PopMatrix();
		}

		public static void ClearAndBlit(Texture source, RenderTexture destination, Material material, int pass, bool clearColor = true, bool clearDepth = false)
		{
			RenderTexture active = RenderTexture.active;
			RenderTexture.active = destination;
			GL.Clear(clearDepth: false, clearColor, Color.clear);
			GL.PushMatrix();
			GL.LoadOrtho();
			material.SetTexture("_MainTex", source);
			material.SetPass(pass);
			GL.Begin(5);
			GL.TexCoord2(0f, 0f);
			GL.Vertex3(0f, 0f, 0.1f);
			GL.TexCoord2(1f, 0f);
			GL.Vertex3(1f, 0f, 0.1f);
			GL.TexCoord2(0f, 1f);
			GL.Vertex3(0f, 1f, 0.1f);
			GL.TexCoord2(1f, 1f);
			GL.Vertex3(1f, 1f, 0.1f);
			GL.End();
			GL.PopMatrix();
			RenderTexture.active = active;
		}

		public static void Destroy(Object obj)
		{
			if (obj != null)
			{
				Object.Destroy(obj);
			}
		}

		public static void Dispose()
		{
			Destroy(s_Quad);
		}
	}
	public sealed class MaterialFactory : IDisposable
	{
		private Dictionary<string, Material> m_Materials;

		public MaterialFactory()
		{
			m_Materials = new Dictionary<string, Material>();
		}

		public Material Get(string shaderName)
		{
			if (!m_Materials.TryGetValue(shaderName, out var value))
			{
				Shader shader = Shader.Find(shaderName);
				if (shader == null)
				{
					throw new ArgumentException($"Shader not found ({shaderName})");
				}
				value = new Material(shader)
				{
					name = string.Format("PostFX - {0}", shaderName.Substring(shaderName.LastIndexOf("/") + 1)),
					hideFlags = HideFlags.DontSave
				};
				m_Materials.Add(shaderName, value);
			}
			return value;
		}

		public void Dispose()
		{
			Dictionary<string, Material>.Enumerator enumerator = m_Materials.GetEnumerator();
			while (enumerator.MoveNext())
			{
				GraphicsUtils.Destroy(enumerator.Current.Value);
			}
			m_Materials.Clear();
		}
	}
	public sealed class RenderTextureFactory : IDisposable
	{
		private HashSet<RenderTexture> m_TemporaryRTs;

		public RenderTextureFactory()
		{
			m_TemporaryRTs = new HashSet<RenderTexture>();
		}

		public RenderTexture Get(RenderTexture baseRenderTexture)
		{
			return Get(baseRenderTexture.width, baseRenderTexture.height, baseRenderTexture.depth, baseRenderTexture.format, (!baseRenderTexture.sRGB) ? RenderTextureReadWrite.Linear : RenderTextureReadWrite.sRGB, baseRenderTexture.filterMode, baseRenderTexture.wrapMode);
		}

		public RenderTexture Get(int width, int height, int depthBuffer = 0, RenderTextureFormat format = RenderTextureFormat.ARGBHalf, RenderTextureReadWrite rw = RenderTextureReadWrite.Default, FilterMode filterMode = FilterMode.Bilinear, TextureWrapMode wrapMode = TextureWrapMode.Clamp, string name = "FactoryTempTexture")
		{
			RenderTexture temporary = RenderTexture.GetTemporary(width, height, depthBuffer, format, rw);
			temporary.filterMode = filterMode;
			temporary.wrapMode = wrapMode;
			temporary.name = name;
			m_TemporaryRTs.Add(temporary);
			return temporary;
		}

		public void Release(RenderTexture rt)
		{
			if (!(rt == null))
			{
				if (!m_TemporaryRTs.Contains(rt))
				{
					throw new ArgumentException($"Attempting to remove a RenderTexture that was not allocated: {rt}");
				}
				m_TemporaryRTs.Remove(rt);
				RenderTexture.ReleaseTemporary(rt);
			}
		}

		public void ReleaseAll()
		{
			HashSet<RenderTexture>.Enumerator enumerator = m_TemporaryRTs.GetEnumerator();
			while (enumerator.MoveNext())
			{
				RenderTexture.ReleaseTemporary(enumerator.Current);
			}
			m_TemporaryRTs.Clear();
		}

		public void Dispose()
		{
			ReleaseAll();
		}
	}
}
namespace Simplex
{
	public class Noise
	{
		private static int seed;

		private static byte[] perm;

		private static readonly byte[] permOriginal;

		public static int Seed
		{
			get
			{
				return seed;
			}
			set
			{
				if (value == 0)
				{
					perm = new byte[permOriginal.Length];
					permOriginal.CopyTo(perm, 0);
				}
				else
				{
					perm = new byte[512];
					new System.Random(value).NextBytes(perm);
				}
			}
		}

		public static float[] Calc1D(int width, float scale)
		{
			float[] array = new float[width];
			for (int i = 0; i < width; i++)
			{
				array[i] = Generate((float)i * scale) * 128f + 128f;
			}
			return array;
		}

		public static float[,] Calc2D(int width, int height, float scale)
		{
			float[,] array = new float[width, height];
			for (int i = 0; i < width; i++)
			{
				for (int j = 0; j < height; j++)
				{
					array[i, j] = Generate((float)i * scale, (float)j * scale) * 128f + 128f;
				}
			}
			return array;
		}

		public static float[,,] Calc3D(int width, int height, int length, float scale)
		{
			float[,,] array = new float[width, height, length];
			for (int i = 0; i < width; i++)
			{
				for (int j = 0; j < height; j++)
				{
					for (int k = 0; k < length; k++)
					{
						array[i, j, k] = Generate((float)i * scale, (float)j * scale, (float)k * scale) * 128f + 128f;
					}
				}
			}
			return array;
		}

		public static float CalcPixel1D(int x, float scale)
		{
			return Generate((float)x * scale) * 128f + 128f;
		}

		public static float CalcPixel2D(int x, int y, float scale)
		{
			return Generate((float)x * scale, (float)y * scale) * 128f + 128f;
		}

		public static float CalcPixel3D(int x, int y, int z, float scale)
		{
			return Generate((float)x * scale, (float)y * scale, (float)z * scale) * 128f + 128f;
		}

		static Noise()
		{
			seed = 0;
			permOriginal = new byte[512]
			{
				151, 160, 137, 91, 90, 15, 131, 13, 201, 95,
				96, 53, 194, 233, 7, 225, 140, 36, 103, 30,
				69, 142, 8, 99, 37, 240, 21, 10, 23, 190,
				6, 148, 247, 120, 234, 75, 0, 26, 197, 62,
				94, 252, 219, 203, 117, 35, 11, 32, 57, 177,
				33, 88, 237, 149, 56, 87, 174, 20, 125, 136,
				171, 168, 68, 175, 74, 165, 71, 134, 139, 48,
				27, 166, 77, 146, 158, 231, 83, 111, 229, 122,
				60, 211, 133, 230, 220, 105, 92, 41, 55, 46,
				245, 40, 244, 102, 143, 54, 65, 25, 63, 161,
				1, 216, 80, 73, 209, 76, 132, 187, 208, 89,
				18, 169, 200, 196, 135, 130, 116, 188, 159, 86,
				164, 100, 109, 198, 173, 186, 3, 64, 52, 217,
				226, 250, 124, 123, 5, 202, 38, 147, 118, 126,
				255, 82, 85, 212, 207, 206, 59, 227, 47, 16,
				58, 17, 182, 189, 28, 42, 223, 183, 170, 213,
				119, 248, 152, 2, 44, 154, 163, 70, 221, 153,
				101, 155, 167, 43, 172, 9, 129, 22, 39, 253,
				19, 98, 108, 110, 79, 113, 224, 232, 178, 185,
				112, 104, 218, 246, 97, 228, 251, 34, 242, 193,
				238, 210, 144, 12, 191, 179, 162, 241, 81, 51,
				145, 235, 249, 14, 239, 107, 49, 192, 214, 31,
				181, 199, 106, 157, 184, 84, 204, 176, 115, 121,
				50, 45, 127, 4, 150, 254, 138, 236, 205, 93,
				222, 114, 67, 29, 24, 72, 243, 141, 128, 195,
				78, 66, 215, 61, 156, 180, 151, 160, 137, 91,
				90, 15, 131, 13, 201, 95, 96, 53, 194, 233,
				7, 225, 140, 36, 103, 30, 69, 142, 8, 99,
				37, 240, 21, 10, 23, 190, 6, 148, 247, 120,
				234, 75, 0, 26, 197, 62, 94, 252, 219, 203,
				117, 35, 11, 32, 57, 177, 33, 88, 237, 149,
				56, 87, 174, 20, 125, 136, 171, 168, 68, 175,
				74, 165, 71, 134, 139, 48, 27, 166, 77, 146,
				158, 231, 83, 111, 229, 122, 60, 211, 133, 230,
				220, 105, 92, 41, 55, 46, 245, 40, 244, 102,
				143, 54, 65, 25, 63, 161, 1, 216, 80, 73,
				209, 76, 132, 187, 208, 89, 18, 169, 200, 196,
				135, 130, 116, 188, 159, 86, 164, 100, 109, 198,
				173, 186, 3, 64, 52, 217, 226, 250, 124, 123,
				5, 202, 38, 147, 118, 126, 255, 82, 85, 212,
				207, 206, 59, 227, 47, 16, 58, 17, 182, 189,
				28, 42, 223, 183, 170, 213, 119, 248, 152, 2,
				44, 154, 163, 70, 221, 153, 101, 155, 167, 43,
				172, 9, 129, 22, 39, 253, 19, 98, 108, 110,
				79, 113, 224, 232, 178, 185, 112, 104, 218, 246,
				97, 228, 251, 34, 242, 193, 238, 210, 144, 12,
				191, 179, 162, 241, 81, 51, 145, 235, 249, 14,
				239, 107, 49, 192, 214, 31, 181, 199, 106, 157,
				184, 84, 204, 176, 115, 121, 50, 45, 127, 4,
				150, 254, 138, 236, 205, 93, 222, 114, 67, 29,
				24, 72, 243, 141, 128, 195, 78, 66, 215, 61,
				156, 180
			};
			perm = new byte[permOriginal.Length];
			permOriginal.CopyTo(perm, 0);
		}

		internal static float Generate(float x)
		{
			int num = FastFloor(x);
			int num2 = num + 1;
			float num3 = x - (float)num;
			float num4 = num3 - 1f;
			float num5 = 1f - num3 * num3;
			float num6 = num5 * num5;
			float num7 = num6 * num6 * grad(perm[num & 0xFF], num3);
			float num8 = 1f - num4 * num4;
			float num9 = num8 * num8;
			float num10 = num9 * num9 * grad(perm[num2 & 0xFF], num4);
			return 0.395f * (num7 + num10);
		}

		internal static float Generate(float x, float y)
		{
			float num = (x + y) * 0.3660254f;
			float x2 = x + num;
			float x3 = y + num;
			int num2 = FastFloor(x2);
			int num3 = FastFloor(x3);
			float num4 = (float)(num2 + num3) * 0.21132487f;
			float num5 = (float)num2 - num4;
			float num6 = (float)num3 - num4;
			float num7 = x - num5;
			float num8 = y - num6;
			int num9;
			int num10;
			if (num7 > num8)
			{
				num9 = 1;
				num10 = 0;
			}
			else
			{
				num9 = 0;
				num10 = 1;
			}
			float num11 = num7 - (float)num9 + 0.21132487f;
			float num12 = num8 - (float)num10 + 0.21132487f;
			float num13 = num7 - 1f + 0.42264974f;
			float num14 = num8 - 1f + 0.42264974f;
			int num15 = Mod(num2, 256);
			int num16 = Mod(num3, 256);
			float num17 = 0.5f - num7 * num7 - num8 * num8;
			float num18;
			if (num17 < 0f)
			{
				num18 = 0f;
			}
			else
			{
				num17 *= num17;
				num18 = num17 * num17 * grad(perm[num15 + perm[num16]], num7, num8);
			}
			float num19 = 0.5f - num11 * num11 - num12 * num12;
			float num20;
			if (num19 < 0f)
			{
				num20 = 0f;
			}
			else
			{
				num19 *= num19;
				num20 = num19 * num19 * grad(perm[num15 + num9 + perm[num16 + num10]], num11, num12);
			}
			float num21 = 0.5f - num13 * num13 - num14 * num14;
			float num22;
			if (num21 < 0f)
			{
				num22 = 0f;
			}
			else
			{
				num21 *= num21;
				num22 = num21 * num21 * grad(perm[num15 + 1 + perm[num16 + 1]], num13, num14);
			}
			return 40f * (num18 + num20 + num22);
		}

		internal static float Generate(float x, float y, float z)
		{
			float num = (x + y + z) * (1f / 3f);
			float x2 = x + num;
			float x3 = y + num;
			float x4 = z + num;
			int num2 = FastFloor(x2);
			int num3 = FastFloor(x3);
			int num4 = FastFloor(x4);
			float num5 = (float)(num2 + num3 + num4) * (1f / 6f);
			float num6 = (float)num2 - num5;
			float num7 = (float)num3 - num5;
			float num8 = (float)num4 - num5;
			float num9 = x - num6;
			float num10 = y - num7;
			float num11 = z - num8;
			int num12;
			int num13;
			int num14;
			int num15;
			int num16;
			int num17;
			if (num9 >= num10)
			{
				if (num10 >= num11)
				{
					num12 = 1;
					num13 = 0;
					num14 = 0;
					num15 = 1;
					num16 = 1;
					num17 = 0;
				}
				else if (num9 >= num11)
				{
					num12 = 1;
					num13 = 0;
					num14 = 0;
					num15 = 1;
					num16 = 0;
					num17 = 1;
				}
				else
				{
					num12 = 0;
					num13 = 0;
					num14 = 1;
					num15 = 1;
					num16 = 0;
					num17 = 1;
				}
			}
			else if (num10 < num11)
			{
				num12 = 0;
				num13 = 0;
				num14 = 1;
				num15 = 0;
				num16 = 1;
				num17 = 1;
			}
			else if (num9 < num11)
			{
				num12 = 0;
				num13 = 1;
				num14 = 0;
				num15 = 0;
				num16 = 1;
				num17 = 1;
			}
			else
			{
				num12 = 0;
				num13 = 1;
				num14 = 0;
				num15 = 1;
				num16 = 1;
				num17 = 0;
			}
			float num18 = num9 - (float)num12 + 1f / 6f;
			float num19 = num10 - (float)num13 + 1f / 6f;
			float num20 = num11 - (float)num14 + 1f / 6f;
			float num21 = num9 - (float)num15 + 1f / 3f;
			float num22 = num10 - (float)num16 + 1f / 3f;
			float num23 = num11 - (float)num17 + 1f / 3f;
			float num24 = num9 - 1f + 0.5f;
			float num25 = num10 - 1f + 0.5f;
			float num26 = num11 - 1f + 0.5f;
			int num27 = Mod(num2, 256);
			int num28 = Mod(num3, 256);
			int num29 = Mod(num4, 256);
			float num30 = 0.6f - num9 * num9 - num10 * num10 - num11 * num11;
			float num31;
			if (num30 < 0f)
			{
				num31 = 0f;
			}
			else
			{
				num30 *= num30;
				num31 = num30 * num30 * grad(perm[num27 + perm[num28 + perm[num29]]], num9, num10, num11);
			}
			float num32 = 0.6f - num18 * num18 - num19 * num19 - num20 * num20;
			float num33;
			if (num32 < 0f)
			{
				num33 = 0f;
			}
			else
			{
				num32 *= num32;
				num33 = num32 * num32 * grad(perm[num27 + num12 + perm[num28 + num13 + perm[num29 + num14]]], num18, num19, num20);
			}
			float num34 = 0.6f - num21 * num21 - num22 * num22 - num23 * num23;
			float num35;
			if (num34 < 0f)
			{
				num35 = 0f;
			}
			else
			{
				num34 *= num34;
				num35 = num34 * num34 * grad(perm[num27 + num15 + perm[num28 + num16 + perm[num29 + num17]]], num21, num22, num23);
			}
			float num36 = 0.6f - num24 * num24 - num25 * num25 - num26 * num26;
			float num37;
			if (num36 < 0f)
			{
				num37 = 0f;
			}
			else
			{
				num36 *= num36;
				num37 = num36 * num36 * grad(perm[num27 + 1 + perm[num28 + 1 + perm[num29 + 1]]], num24, num25, num26);
			}
			return 32f * (num31 + num33 + num35 + num37);
		}

		private static int FastFloor(float x)
		{
			if (!(x > 0f))
			{
				return (int)x - 1;
			}
			return (int)x;
		}

		private static int Mod(int x, int m)
		{
			int num = x % m;
			if (num >= 0)
			{
				return num;
			}
			return num + m;
		}

		private static float grad(int hash, float x)
		{
			int num = hash & 0xF;
			float num2 = 1f + (float)(num & 7);
			if (((uint)num & 8u) != 0)
			{
				num2 = 0f - num2;
			}
			return num2 * x;
		}

		private static float grad(int hash, float x, float y)
		{
			int num = hash & 7;
			float num2 = ((num < 4) ? x : y);
			float num3 = ((num < 4) ? y : x);
			return ((((uint)num & (true ? 1u : 0u)) != 0) ? (0f - num2) : num2) + ((((uint)num & 2u) != 0) ? (-2f * num3) : (2f * num3));
		}

		private static float grad(int hash, float x, float y, float z)
		{
			int num = hash & 0xF;
			float num2 = ((num < 8) ? x : y);
			float num3 = ((num < 4) ? y : ((num == 12 || num == 14) ? x : z));
			return ((((uint)num & (true ? 1u : 0u)) != 0) ? (0f - num2) : num2) + ((((uint)num & 2u) != 0) ? (0f - num3) : num3);
		}

		private static float grad(int hash, float x, float y, float z, float t)
		{
			int num = hash & 0x1F;
			float num2 = ((num < 24) ? x : y);
			float num3 = ((num < 16) ? y : z);
			float num4 = ((num < 8) ? z : t);
			return ((((uint)num & (true ? 1u : 0u)) != 0) ? (0f - num2) : num2) + ((((uint)num & 2u) != 0) ? (0f - num3) : num3) + ((((uint)num & 4u) != 0) ? (0f - num4) : num4);
		}
	}
}
namespace Photon.Pun.Demo.Shared
{
	public static class DocLinks
	{
		public enum DocTypes
		{
			Doc,
			Api
		}

		public enum Products
		{
			OnPremise,
			Realtime,
			Pun,
			Chat,
			Voice,
			Bolt,
			Quantum
		}

		public enum Versions
		{
			Current,
			V1,
			V2
		}

		public enum Languages
		{
			English,
			Japanese,
			Korean,
			Chinese
		}

		public static Versions Version = Versions.Current;

		public static Languages Language = Languages.English;

		public static Products Product = Products.Pun;

		public static string ApiUrlRoot = "https://doc-api.photonengine.com/{0}/{1}/{2}/{3}";

		public static string DocUrlFormat = "https://doc.photonengine.com/{0}/{1}/{2}/{3}";

		private static Dictionary<Products, string> ProductsFolders = new Dictionary<Products, string>
		{
			{
				Products.Bolt,
				"bolt"
			},
			{
				Products.Chat,
				"chat"
			},
			{
				Products.OnPremise,
				"onpremise"
			},
			{
				Products.Pun,
				"pun"
			},
			{
				Products.Quantum,
				"quantum"
			},
			{
				Products.Realtime,
				"realtime"
			},
			{
				Products.Voice,
				"voice"
			}
		};

		private static Dictionary<Languages, string> ApiLanguagesFolder = new Dictionary<Languages, string>
		{
			{
				Languages.English,
				"en"
			},
			{
				Languages.Japanese,
				"ja-jp"
			},
			{
				Languages.Korean,
				"ko-kr"
			},
			{
				Languages.Chinese,
				"zh-tw"
			}
		};

		private static Dictionary<Languages, string> DocLanguagesFolder = new Dictionary<Languages, string>
		{
			{
				Languages.English,
				"en-us"
			},
			{
				Languages.Japanese,
				"ja-jp"
			},
			{
				Languages.Korean,
				"ko-kr"
			},
			{
				Languages.Chinese,
				"en"
			}
		};

		private static Dictionary<Versions, string> VersionsFolder = new Dictionary<Versions, string>
		{
			{
				Versions.Current,
				"current"
			},
			{
				Versions.V1,
				"v1"
			},
			{
				Versions.V2,
				"v2"
			}
		};

		public static string GetLink(DocTypes type, string reference)
		{
			return type switch
			{
				DocTypes.Api => GetApiLink(reference), 
				DocTypes.Doc => GetDocLink(reference), 
				_ => "https://doc.photonengine.com", 
			};
		}

		public static string GetApiLink(string reference)
		{
			return string.Format(ApiUrlRoot, ApiLanguagesFolder[Language], ProductsFolders[Product], VersionsFolder[Version], reference);
		}

		public static string GetDocLink(string reference)
		{
			return string.Format(DocUrlFormat, DocLanguagesFolder[Language], ProductsFolders[Product], VersionsFolder[Version], reference);
		}
	}
}
namespace Photon.Pun.Demo.Cockpit
{
	public class PunCockpit : MonoBehaviourPunCallbacks
	{
		public static PunCockpit Instance;

		public static bool Embedded;

		public static string EmbeddedGameTitle = "";

		public bool debug;

		public Text Title;

		public Text StateText;

		public Text UserIdText;

		[Header("Demo Integration")]
		public CanvasGroup MinimalCanvasGroup;

		public CanvasGroup MaximalCanvasGroup;

		public GameObject MinimizeButton;

		public GameObject MinimalUIEmbeddHelp;

		[Header("Connection UI")]
		public GameObject ConnectingLabel;

		public GameObject ConnectionPanel;

		public GameObject AdvancedConnectionPanel;

		public Dropdown ConnectAsDropDown;

		[Header("Common UI")]
		public GameObject InfosPanel;

		public GameObject MinimalUiInfosPanel;

		[Header("Lobby UI")]
		public GameObject LobbyPanel;

		public Selectable JoinLobbyButton;

		public RoomListView RoomListManager;

		public FriendListView FriendListManager;

		public GameObject RoomListMatchMakingForm;

		[Header("Game UI")]
		public GameObject GamePanel;

		public PlayerListView PlayerListManager;

		public PlayerDetailsController PlayerDetailsManager;

		public InputField RoomCustomPropertyInputfield;

		[Header("Photon Settings")]
		public string GameVersionOverride = string.Empty;

		public bool ResetBestRegionCodeInPreferences;

		[Header("Room Options")]
		public int MaxPlayers = 4;

		public int PlayerTtl;

		public int EmptyRoomTtl;

		public string Plugins = "";

		public bool PublishUserId = true;

		public bool IsVisible = true;

		public bool IsOpen = true;

		public bool CleanupCacheOnLeave = true;

		public bool DeleteNullProperties;

		[Header("Room Options UI")]
		public IntInputField PlayerTtlField;

		public IntInputField EmptyRoomTtlField;

		public IntInputField MaxPlayersField;

		public StringInputField PluginsField;

		public BoolInputField PublishUserIdField;

		public BoolInputField IsVisibleField;

		public BoolInputField IsOpenField;

		public BoolInputField CleanupCacheOnLeaveField;

		public BoolInputField DeleteNullPropertiesField;

		[Header("Friends Options")]
		public FriendListView.FriendDetail[] FriendsList = new FriendListView.FriendDetail[3]
		{
			new FriendListView.FriendDetail("Joe", "Joe"),
			new FriendListView.FriendDetail("Jane", "Jane"),
			new FriendListView.FriendDetail("Bob", "Bob")
		};

		[Header("Modal window")]
		public CanvasGroup ModalWindow;

		public RegionListView RegionListView;

		public Text RegionListLoadingFeedback;

		private LoadBalancingClient _lbc;

		private bool _regionPingProcessActive;

		private List<Region> RegionsList;

		private string roomNameToEnter;

		public string UserId { get; set; }

		public void Start()
		{
			Instance = this;
			DocLinks.Language = DocLinks.Languages.English;
			DocLinks.Product = DocLinks.Products.Pun;
			DocLinks.Version = DocLinks.Versions.V2;
			ModalWindow.gameObject.SetActive(value: false);
			MaximalCanvasGroup.gameObject.SetActive(value: true);
			UserIdText.text = "";
			StateText.text = "";
			StateText.gameObject.SetActive(value: true);
			UserIdText.gameObject.SetActive(value: true);
			Title.gameObject.SetActive(value: true);
			ConnectingLabel.SetActive(value: false);
			LobbyPanel.SetActive(value: false);
			GamePanel.SetActive(value: false);
			if (string.IsNullOrEmpty(UserId))
			{
				UserId = "user" + Environment.TickCount % 99;
			}
			PlayerTtlField.SetValue(PlayerTtl);
			EmptyRoomTtlField.SetValue(EmptyRoomTtl);
			MaxPlayersField.SetValue(MaxPlayers);
			PluginsField.SetValue(Plugins);
			PublishUserIdField.SetValue(PublishUserId);
			IsVisibleField.SetValue(IsVisible);
			IsOpenField.SetValue(IsOpen);
			CleanupCacheOnLeaveField.SetValue(CleanupCacheOnLeave);
			DeleteNullPropertiesField.SetValue(DeleteNullProperties);
			ConnectAsDropDown.ClearOptions();
			ConnectAsDropDown.AddOptions(FriendsList.Select((FriendListView.FriendDetail x) => x.NickName).ToList());
			if (PhotonNetwork.IsConnected)
			{
				if (PhotonNetwork.Server == ServerConnection.GameServer)
				{
					OnJoinedRoom();
				}
				else if (PhotonNetwork.Server == ServerConnection.MasterServer || PhotonNetwork.Server == ServerConnection.NameServer)
				{
					if (PhotonNetwork.InLobby)
					{
						OnJoinedLobby();
					}
					else
					{
						OnConnectedToMaster();
					}
				}
			}
			else
			{
				SwitchToSimpleConnection();
				if (!Embedded)
				{
					MinimizeButton.SetActive(value: false);
					SwitchtoMaximalPanel();
				}
				else
				{
					Title.text = EmbeddedGameTitle;
					SwitchtoMinimalPanel();
				}
			}
		}

		public void SwitchtoMinimalPanel()
		{
			MinimalCanvasGroup.gameObject.SetActive(value: true);
			MaximalCanvasGroup.alpha = 0f;
			MaximalCanvasGroup.blocksRaycasts = false;
			MaximalCanvasGroup.interactable = false;
		}

		public void SwitchtoMaximalPanel()
		{
			MinimalUIEmbeddHelp.SetActive(value: false);
			MinimalCanvasGroup.gameObject.SetActive(value: false);
			MaximalCanvasGroup.alpha = 1f;
			MaximalCanvasGroup.blocksRaycasts = true;
			MaximalCanvasGroup.interactable = true;
		}

		public void SwitchToAdvancedConnection()
		{
			ConnectionPanel.gameObject.SetActive(value: false);
			AdvancedConnectionPanel.gameObject.SetActive(value: true);
		}

		public void SwitchToSimpleConnection()
		{
			ConnectionPanel.gameObject.SetActive(value: true);
			AdvancedConnectionPanel.gameObject.SetActive(value: false);
		}

		public void ToggleInfosInMinimalPanel()
		{
			MinimalUiInfosPanel.SetActive(!MinimalUiInfosPanel.activeSelf);
		}

		public void RequestInfosPanel(GameObject Parent)
		{
			if (Parent != null)
			{
				InfosPanel.transform.SetParent(Parent.transform, worldPositionStays: false);
			}
		}

		public void OnUserIdSubmited(string userId)
		{
			UserId = userId;
			Connect();
		}

		public void SetPlayerTtlRoomOption(int value)
		{
			PlayerTtl = value;
			if (debug)
			{
				UnityEngine.Debug.Log("PunCockpit:PlayerTtl = " + PlayerTtl);
			}
		}

		public void SetEmptyRoomTtlRoomOption(int value)
		{
			EmptyRoomTtl = value;
			if (debug)
			{
				UnityEngine.Debug.Log("PunCockpit:EmptyRoomTtl = " + EmptyRoomTtl);
			}
		}

		public void SetMaxPlayersRoomOption(int value)
		{
			MaxPlayers = value;
			if (debug)
			{
				UnityEngine.Debug.Log("PunCockpit:MaxPlayers = " + MaxPlayers);
			}
		}

		public void SetPluginsRoomOption(string value)
		{
			Plugins = value;
			if (debug)
			{
				UnityEngine.Debug.Log("PunCockpit:Plugins = " + Plugins);
			}
		}

		public void SetPublishUserId(bool value)
		{
			PublishUserId = value;
			if (debug)
			{
				UnityEngine.Debug.Log("PunCockpit:PublishUserId = " + PublishUserId);
			}
		}

		public void SetIsVisible(bool value)
		{
			IsVisible = value;
			if (debug)
			{
				UnityEngine.Debug.Log("PunCockpit:IsVisible = " + IsVisible);
			}
		}

		public void SetIsOpen(bool value)
		{
			IsOpen = value;
			if (debug)
			{
				UnityEngine.Debug.Log("PunCockpit:IsOpen = " + IsOpen);
			}
		}

		public void SetResetBestRegionCodeInPreferences(bool value)
		{
			ResetBestRegionCodeInPreferences = value;
			if (debug)
			{
				UnityEngine.Debug.Log("PunCockpit:ResetBestRegionCodeInPreferences = " + ResetBestRegionCodeInPreferences);
			}
		}

		public void SetCleanupCacheOnLeave(bool value)
		{
			CleanupCacheOnLeave = value;
			if (debug)
			{
				UnityEngine.Debug.Log("PunCockpit:CleanupCacheOnLeave = " + CleanupCacheOnLeave);
			}
		}

		public void SetDeleteNullProperties(bool value)
		{
			DeleteNullProperties = value;
			if (debug)
			{
				UnityEngine.Debug.Log("PunCockpit:DeleteNullProperties = " + DeleteNullProperties);
			}
		}

		public void PingRegions()
		{
			ModalWindow.gameObject.SetActive(value: true);
			RegionListLoadingFeedback.text = "Connecting to NameServer...";
			_regionPingProcessActive = true;
			if (debug)
			{
				UnityEngine.Debug.Log("PunCockpit:PingRegions:ConnectToNameServer");
			}
			_lbc = new LoadBalancingClient(PhotonNetwork.NetworkingClient.ExpectedProtocol);
			_lbc.AddCallbackTarget(this);
			_lbc.StateChanged += OnStateChanged;
			_lbc.AppId = PhotonNetwork.PhotonServerSettings.AppSettings.AppIdRealtime;
			_lbc.ConnectToNameServer();
		}

		private void Update()
		{
			if (_lbc != null)
			{
				_lbc.Service();
			}
			if (RegionsList == null)
			{
				return;
			}
			if (ModalWindow.gameObject.activeInHierarchy)
			{
				if (Instance.debug)
				{
					UnityEngine.Debug.Log("PunCockpit:OnRegionsPinged");
				}
				RegionListView.OnRegionListUpdate(RegionsList);
			}
			_lbc = null;
			RegionListLoadingFeedback.text = string.Empty;
			RegionsList = null;
		}

		private void OnStateChanged(ClientState previousState, ClientState state)
		{
			if (state == ClientState.ConnectedToNameServer)
			{
				_lbc.StateChanged -= OnStateChanged;
				if (debug)
				{
					UnityEngine.Debug.Log("PunCockpit:OnStateChanged: ClientState.ConnectedToNameServer. Waiting for OnRegionListReceived callback.");
				}
				RegionListLoadingFeedback.text = "Waiting for application Region List...";
			}
		}

		public override void OnRegionListReceived(RegionHandler regionHandler)
		{
			if (Instance.debug)
			{
				UnityEngine.Debug.Log("PunCockpit:OnRegionListReceived: " + regionHandler);
			}
			if (_regionPingProcessActive)
			{
				RegionListLoadingFeedback.text = "Pinging Regions...";
				_regionPingProcessActive = false;
				regionHandler.PingMinimumOfRegions(OnRegionsPinged, null);
			}
		}

		private void OnRegionsPinged(RegionHandler regionHandler)
		{
			RegionsList = regionHandler.EnabledRegions.OrderBy((Region x) => x.Ping).ToList();
		}

		public void CloseRegionListView()
		{
			RegionsList = null;
			if (_lbc != null)
			{
				_lbc.Disconnect();
				_lbc = null;
			}
			_regionPingProcessActive = false;
			RegionListView.ResetList();
			ModalWindow.gameObject.SetActive(value: false);
		}

		public void LoadLevel(string level)
		{
			if (debug)
			{
				UnityEngine.Debug.Log("PunCockpit:LoadLevel(" + level + ")");
			}
			PhotonNetwork.LoadLevel(level);
		}

		public void SetRoomCustomProperty(string value)
		{
			if (debug)
			{
				UnityEngine.Debug.Log("PunCockpit:SetRoomCustomProperty() c0 = " + value);
			}
			PhotonNetwork.CurrentRoom.SetCustomProperties(new ExitGames.Client.Photon.Hashtable { { "C0", value } });
		}

		public void JoinRoom(string roomName)
		{
			RoomListManager.ResetList();
			LobbyPanel.gameObject.SetActive(value: false);
			ConnectingLabel.SetActive(value: true);
			roomNameToEnter = roomName;
			PhotonNetwork.JoinRoom(roomName);
		}

		public void CreateRoom()
		{
			CreateRoom(null, null, LobbyType.Default);
		}

		public void CreateRoom(string roomName, string lobbyName = "MyLobby", LobbyType lobbyType = LobbyType.SqlLobby, string[] expectedUsers = null)
		{
			if (debug)
			{
				object[] obj = new object[8] { "PunCockpit:CreateRoom roomName:", roomName, " lobbyName:", lobbyName, " lobbyType:", lobbyType, " expectedUsers:", null };
				object obj2;
				if (expectedUsers != null)
				{
					obj2 = expectedUsers.ToStringFull();
				}
				else
				{
					obj2 = "null";
				}
				obj[7] = obj2;
				UnityEngine.Debug.Log(string.Concat(obj));
			}
			RoomListManager.ResetList();
			LobbyPanel.gameObject.SetActive(value: false);
			ConnectingLabel.SetActive(value: true);
			RoomOptions roomOptions = GetRoomOptions();
			if (debug)
			{
				UnityEngine.Debug.Log(string.Concat("PunCockpit:Room options  <", roomOptions, ">"));
			}
			TypedLobby typedLobby = new TypedLobby(lobbyName, lobbyType);
			bool flag = PhotonNetwork.CreateRoom(roomName, roomOptions, typedLobby, expectedUsers);
			if (debug)
			{
				UnityEngine.Debug.Log("PunCockpit:CreateRoom() -> " + flag);
			}
		}

		public void JoinRandomRoom()
		{
			PhotonNetwork.JoinRandomRoom();
		}

		public void LeaveRoom()
		{
			PlayerListManager.ResetList();
			GamePanel.gameObject.SetActive(value: false);
			ConnectingLabel.SetActive(value: true);
			PhotonNetwork.LeaveRoom();
		}

		public void Connect()
		{
			ConnectionPanel.gameObject.SetActive(value: false);
			AdvancedConnectionPanel.gameObject.SetActive(value: false);
			PhotonNetwork.AuthValues = new Photon.Realtime.AuthenticationValues();
			PhotonNetwork.AuthValues.UserId = UserId;
			ConnectingLabel.SetActive(value: true);
			PhotonNetwork.ConnectUsingSettings();
		}

		public void ReConnect()
		{
			ConnectionPanel.gameObject.SetActive(value: false);
			AdvancedConnectionPanel.gameObject.SetActive(value: false);
			PhotonNetwork.AuthValues = new Photon.Realtime.AuthenticationValues();
			PhotonNetwork.AuthValues.UserId = UserId;
			ConnectingLabel.SetActive(value: true);
			PhotonNetwork.Reconnect();
		}

		public void ReconnectAndRejoin()
		{
			ConnectionPanel.gameObject.SetActive(value: false);
			AdvancedConnectionPanel.gameObject.SetActive(value: false);
			PhotonNetwork.AuthValues = new Photon.Realtime.AuthenticationValues();
			PhotonNetwork.AuthValues.UserId = UserId;
			ConnectingLabel.SetActive(value: true);
			PhotonNetwork.ReconnectAndRejoin();
		}

		public void ConnectToBestCloudServer()
		{
			PhotonNetwork.NetworkingClient.AppId = PhotonNetwork.PhotonServerSettings.AppSettings.AppIdRealtime;
			ConnectionPanel.gameObject.SetActive(value: false);
			AdvancedConnectionPanel.gameObject.SetActive(value: false);
			PhotonNetwork.AuthValues = new Photon.Realtime.AuthenticationValues();
			PhotonNetwork.AuthValues.UserId = UserId;
			ConnectingLabel.SetActive(value: true);
			if (ResetBestRegionCodeInPreferences)
			{
				ServerSettings.ResetBestRegionCodeInPreferences();
			}
			PhotonNetwork.ConnectToBestCloudServer();
			if (GameVersionOverride != string.Empty)
			{
				PhotonNetwork.GameVersion = GameVersionOverride;
			}
		}

		public void ConnectToRegion(string region)
		{
			if (debug)
			{
				UnityEngine.Debug.Log("PunCockpit:ConnectToRegion(" + region + ")");
			}
			PhotonNetwork.NetworkingClient.AppId = PhotonNetwork.PhotonServerSettings.AppSettings.AppIdRealtime;
			ConnectionPanel.gameObject.SetActive(value: false);
			AdvancedConnectionPanel.gameObject.SetActive(value: false);
			PhotonNetwork.AuthValues = new Photon.Realtime.AuthenticationValues();
			PhotonNetwork.AuthValues.UserId = UserId;
			ConnectingLabel.SetActive(value: true);
			bool flag = PhotonNetwork.ConnectToRegion(region);
			if (GameVersionOverride != string.Empty)
			{
				PhotonNetwork.GameVersion = GameVersionOverride;
			}
			if (debug)
			{
				UnityEngine.Debug.Log("PunCockpit:ConnectToRegion(" + region + ") ->" + flag);
			}
		}

		public void ConnectOffline()
		{
			if (debug)
			{
				UnityEngine.Debug.Log("PunCockpit:ConnectOffline()");
			}
			PhotonNetwork.OfflineMode = true;
		}

		public void JoinLobby()
		{
			if (debug)
			{
				UnityEngine.Debug.Log("PunCockpit:JoinLobby()");
			}
			if (!PhotonNetwork.JoinLobby())
			{
				UnityEngine.Debug.LogError("PunCockpit: Could not joinLobby");
			}
		}

		public void Disconnect()
		{
			if (debug)
			{
				UnityEngine.Debug.Log("PunCockpit:Disconnect()");
			}
			PhotonNetwork.Disconnect();
		}

		public void OpenDashboard()
		{
			Application.OpenURL("https://dashboard.photonengine.com");
		}

		public void OnDropdownConnectAs(int dropdownIndex)
		{
			if (debug)
			{
				UnityEngine.Debug.Log("PunCockpit:OnDropdownConnectAs(" + dropdownIndex + ")");
			}
			UserId = FriendsList[dropdownIndex].UserId;
			PlayerPrefs.SetString("PunUserId", UserId);
			StartCoroutine(OnDropdownConnectAs_CB());
		}

		private IEnumerator OnDropdownConnectAs_CB()
		{
			yield return new WaitForSeconds(0.2f);
			Connect();
		}

		public void OnLobbyToolsViewTabChanged(string tabId)
		{
		}

		public void OnSelectPlayer()
		{
		}

		public override void OnConnected()
		{
			if (debug)
			{
				UnityEngine.Debug.Log("PunCockpit:OnConnected()");
			}
			ConnectingLabel.SetActive(value: false);
			UserIdText.text = "UserId:" + UserId + " Nickname:" + PhotonNetwork.NickName;
		}

		public override void OnDisconnected(DisconnectCause cause)
		{
			if (debug)
			{
				UnityEngine.Debug.Log(string.Concat("PunCockpit:OnDisconnected(", cause, ")"));
			}
			ConnectingLabel.SetActive(value: false);
			UserIdText.text = string.Empty;
			StateText.text = string.Empty;
			GamePanel.gameObject.SetActive(value: false);
			LobbyPanel.gameObject.SetActive(value: false);
			ConnectionPanel.gameObject.SetActive(value: true);
		}

		public override void OnConnectedToMaster()
		{
			if (debug)
			{
				UnityEngine.Debug.Log("PunCockpit:OnConnectedToMaster()");
			}
			StateText.text = "Connected to Master" + (PhotonNetwork.OfflineMode ? " <Color=Red><b>Offline</b></color>" : "");
			SetUpLobbyGenericUI();
		}

		public override void OnJoinedLobby()
		{
			StateText.text = "Connected to Lobby";
			if (debug)
			{
				UnityEngine.Debug.Log("PunCockpit:OnJoinedLobby()");
			}
			SetUpLobbyGenericUI();
		}

		private void SetUpLobbyGenericUI()
		{
			ConnectingLabel.gameObject.SetActive(value: false);
			AdvancedConnectionPanel.gameObject.SetActive(value: false);
			LobbyPanel.gameObject.SetActive(value: true);
			RoomListManager.OnJoinedLobbyCallBack();
			FriendListManager.SetFriendDetails(FriendsList);
			JoinLobbyButton.interactable = !PhotonNetwork.InLobby && !PhotonNetwork.OfflineMode;
			RoomListManager.gameObject.SetActive(!PhotonNetwork.OfflineMode);
			FriendListManager.gameObject.SetActive(!PhotonNetwork.OfflineMode);
			RoomListMatchMakingForm.SetActive(!PhotonNetwork.InLobby);
		}

		public override void OnRoomPropertiesUpdate(ExitGames.Client.Photon.Hashtable propertiesThatChanged)
		{
			if (debug)
			{
				UnityEngine.Debug.Log("PunCockpit:OnRoomPropertiesUpdate() " + propertiesThatChanged.ToStringFull());
			}
			if (propertiesThatChanged.ContainsKey("C0"))
			{
				RoomCustomPropertyInputfield.text = propertiesThatChanged["C0"].ToString();
			}
		}

		public override void OnLeftLobby()
		{
			if (debug)
			{
				UnityEngine.Debug.Log("PunCockpit:OnLeftLobby()");
			}
			RoomListManager.ResetList();
			LobbyPanel.gameObject.SetActive(value: false);
		}

		public override void OnCreateRoomFailed(short returnCode, string message)
		{
			if (debug)
			{
				UnityEngine.Debug.Log("PunCockpit:OnCreateRoomFailed(" + returnCode + "," + message + ")");
			}
		}

		public override void OnJoinRandomFailed(short returnCode, string message)
		{
			if (debug)
			{
				UnityEngine.Debug.Log("PunCockpit:OnJoinRandomFailed(" + returnCode + "," + message + ")");
			}
		}

		public override void OnJoinedRoom()
		{
			StateText.text = "Connected to GameServer " + (PhotonNetwork.OfflineMode ? " <Color=Red><b>Offline</b></color>" : "");
			if (debug)
			{
				UnityEngine.Debug.Log("PunCockpit:OnJoinedRoom()");
			}
			ConnectingLabel.gameObject.SetActive(value: false);
			PlayerListManager.ResetList();
			GamePanel.gameObject.SetActive(value: true);
			PlayerDetailsManager.SetPlayerTarget(PhotonNetwork.LocalPlayer);
		}

		public override void OnJoinRoomFailed(short returnCode, string message)
		{
			if (returnCode == 32749 && !string.IsNullOrEmpty(roomNameToEnter))
			{
				PhotonNetwork.RejoinRoom(roomNameToEnter);
				roomNameToEnter = null;
			}
		}

		public override void OnLeftRoom()
		{
			if (debug)
			{
				UnityEngine.Debug.Log("PunCockpit:OnLeftRoom()");
			}
			GamePanel.gameObject.SetActive(value: false);
			if (PhotonNetwork.OfflineMode)
			{
				ConnectingLabel.gameObject.SetActive(value: false);
				ConnectionPanel.gameObject.SetActive(value: true);
			}
		}

		private RoomOptions GetRoomOptions()
		{
			RoomOptions roomOptions = new RoomOptions();
			roomOptions.MaxPlayers = (byte)MaxPlayers;
			roomOptions.IsOpen = IsOpen;
			roomOptions.IsVisible = IsVisible;
			roomOptions.EmptyRoomTtl = EmptyRoomTtl;
			roomOptions.PlayerTtl = PlayerTtl;
			roomOptions.PublishUserId = PublishUserId;
			roomOptions.CleanupCacheOnLeave = CleanupCacheOnLeave;
			roomOptions.DeleteNullProperties = DeleteNullProperties;
			roomOptions.CustomRoomProperties = new ExitGames.Client.Photon.Hashtable { { "C0", "Hello" } };
			roomOptions.CustomRoomPropertiesForLobby = new string[1] { "C0" };
			return roomOptions;
		}
	}
	[RequireComponent(typeof(Toggle))]
	public class AutoSyncSceneToggle : MonoBehaviour
	{
		private Toggle _toggle;

		private bool registered;

		private void OnEnable()
		{
			_toggle = GetComponent<Toggle>();
			if (!registered)
			{
				registered = true;
				_toggle.onValueChanged.AddListener(ToggleValue);
			}
		}

		private void OnDisable()
		{
			if (_toggle != null)
			{
				registered = false;
				_toggle.onValueChanged.RemoveListener(ToggleValue);
			}
		}

		private void Update()
		{
			if (PhotonNetwork.AutomaticallySyncScene != _toggle.isOn)
			{
				_toggle.isOn = PhotonNetwork.AutomaticallySyncScene;
			}
		}

		public void ToggleValue(bool value)
		{
			PhotonNetwork.AutomaticallySyncScene = value;
		}
	}
	public class BackgroundTimeOutField : MonoBehaviour
	{
		public InputField PropertyValueInput;

		private float _cache;

		private bool registered;

		private void OnEnable()
		{
			if (!registered)
			{
				registered = true;
				PropertyValueInput.onEndEdit.AddListener(OnEndEdit);
			}
		}

		private void OnDisable()
		{
			registered = false;
			PropertyValueInput.onEndEdit.RemoveListener(OnEndEdit);
		}

		private void Update()
		{
			if (PhotonNetwork.KeepAliveInBackground != _cache)
			{
				_cache = PhotonNetwork.KeepAliveInBackground;
				PropertyValueInput.text = _cache.ToString("F1");
			}
		}

		public void OnEndEdit(string value)
		{
			if (Input.GetKey(KeyCode.Return) || Input.GetKey(KeyCode.KeypadEnter) || Input.GetKey(KeyCode.Tab))
			{
				SubmitForm(value.Trim());
			}
			else
			{
				SubmitForm(value);
			}
		}

		public void SubmitForm(string value)
		{
			_cache = float.Parse(value);
			PhotonNetwork.KeepAliveInBackground = _cache;
		}
	}
	[RequireComponent(typeof(Toggle))]
	public class CrcCheckToggle : MonoBehaviour
	{
		private Toggle _toggle;

		private bool registered;

		private void OnEnable()
		{
			_toggle = GetComponent<Toggle>();
			if (!registered)
			{
				registered = true;
				_toggle.onValueChanged.AddListener(ToggleValue);
			}
		}

		private void OnDisable()
		{
			if (_toggle != null)
			{
				registered = false;
				_toggle.onValueChanged.RemoveListener(ToggleValue);
			}
		}

		private void Update()
		{
			if (PhotonNetwork.CrcCheckEnabled != _toggle.isOn)
			{
				_toggle.isOn = PhotonNetwork.CrcCheckEnabled;
			}
		}

		public void ToggleValue(bool value)
		{
			PhotonNetwork.CrcCheckEnabled = value;
		}
	}
	[RequireComponent(typeof(Toggle))]
	public class CurrentRoomIsOpenToggle : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
	{
		private Toggle _toggle;

		private void OnEnable()
		{
			_toggle = GetComponent<Toggle>();
		}

		private void Update()
		{
			if (PhotonNetwork.CurrentRoom == null && _toggle.interactable)
			{
				_toggle.interactable = false;
			}
			else if (PhotonNetwork.CurrentRoom != null && !_toggle.interactable)
			{
				_toggle.interactable = true;
			}
			if (PhotonNetwork.CurrentRoom != null && PhotonNetwork.CurrentRoom.IsOpen != _toggle.isOn)
			{
				UnityEngine.Debug.Log("Update toggle : PhotonNetwork.CurrentRoom.IsOpen = " + PhotonNetwork.CurrentRoom.IsOpen, this);
				_toggle.isOn = PhotonNetwork.CurrentRoom.IsOpen;
			}
		}

		public void ToggleValue(bool value)
		{
			if (PhotonNetwork.CurrentRoom != null)
			{
				UnityEngine.Debug.Log("PhotonNetwork.CurrentRoom.IsOpen = " + value, this);
				PhotonNetwork.CurrentRoom.IsOpen = value;
			}
		}

		public void OnPointerClick(PointerEventData eventData)
		{
			ToggleValue(_toggle.isOn);
		}
	}
	[RequireComponent(typeof(Toggle))]
	public class CurrentRoomIsVisibleToggle : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
	{
		private Toggle _toggle;

		private void OnEnable()
		{
			_toggle = GetComponent<Toggle>();
		}

		private void Update()
		{
			if (PhotonNetwork.CurrentRoom == null && _toggle.interactable)
			{
				_toggle.interactable = false;
			}
			else if (PhotonNetwork.CurrentRoom != null && !_toggle.interactable)
			{
				_toggle.interactable = true;
			}
			if (PhotonNetwork.CurrentRoom != null && PhotonNetwork.CurrentRoom.IsVisible != _toggle.isOn)
			{
				UnityEngine.Debug.Log("Update toggle : PhotonNetwork.CurrentRoom.IsVisible = " + PhotonNetwork.CurrentRoom.IsVisible, this);
				_toggle.isOn = PhotonNetwork.CurrentRoom.IsVisible;
			}
		}

		public void ToggleValue(bool value)
		{
			if (PhotonNetwork.CurrentRoom != null)
			{
				UnityEngine.Debug.Log("PhotonNetwork.CurrentRoom.IsVisible = " + value, this);
				PhotonNetwork.CurrentRoom.IsVisible = value;
			}
		}

		public void OnPointerClick(PointerEventData eventData)
		{
			ToggleValue(_toggle.isOn);
		}
	}
	public class DocLinkButton : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
	{
		public DocLinks.DocTypes Type;

		public string Reference = "getting-started/pun-intro";

		public void Start()
		{
		}

		public void OnPointerClick(PointerEventData pointerEventData)
		{
			Application.OpenURL(DocLinks.GetLink(Type, Reference));
		}
	}
	public class GameVersionField : MonoBehaviour
	{
		public InputField PropertyValueInput;

		private string _cache;

		private bool registered;

		private void OnEnable()
		{
			if (!registered)
			{
				registered = true;
				PropertyValueInput.onEndEdit.AddListener(OnEndEdit);
			}
		}

		private void OnDisable()
		{
			registered = false;
			PropertyValueInput.onEndEdit.RemoveListener(OnEndEdit);
		}

		private void Update()
		{
			if (PhotonNetwork.PhotonServerSettings.AppSettings.AppVersion != _cache)
			{
				_cache = PhotonNetwork.PhotonServerSettings.AppSettings.AppVersion;
				PropertyValueInput.text = _cache;
			}
		}

		public void OnEndEdit(string value)
		{
			if (Input.GetKey(KeyCode.Return) || Input.GetKey(KeyCode.KeypadEnter) || Input.GetKey(KeyCode.Tab))
			{
				SubmitForm(value.Trim());
			}
			else
			{
				SubmitForm(value);
			}
		}

		public void SubmitForm(string value)
		{
			_cache = value;
			PunCockpit.Instance.GameVersionOverride = _cache;
		}
	}
	public class BoolInputField : MonoBehaviour
	{
		[Serializable]
		public class OnSubmitEvent : UnityEvent<bool>
		{
		}

		public Toggle PropertyValueInput;

		public OnSubmitEvent OnSubmit;

		private bool registered;

		private void OnEnable()
		{
			if (!registered)
			{
				registered = true;
				PropertyValueInput.onValueChanged.AddListener(OnValueChanged);
			}
		}

		private void OnDisable()
		{
			registered = false;
			PropertyValueInput.onValueChanged.RemoveListener(OnValueChanged);
		}

		private void OnValueChanged(bool value)
		{
			OnSubmit.Invoke(PropertyValueInput.isOn);
		}

		public void SetValue(bool value)
		{
			PropertyValueInput.isOn = value;
		}
	}
	public class IntInputField : MonoBehaviour
	{
		[Serializable]
		public class OnSubmitEvent : UnityEvent<int>
		{
		}

		public InputField PropertyValueInput;

		public OnSubmitEvent OnSubmit;

		private bool registered;

		private void OnEnable()
		{
			if (!registered)
			{
				registered = true;
				PropertyValueInput.onEndEdit.AddListener(EndEditOnEnter);
			}
		}

		private void OnDisable()
		{
			registered = false;
			PropertyValueInput.onEndEdit.RemoveListener(EndEditOnEnter);
		}

		public void SetValue(int value)
		{
			PropertyValueInput.text = value.ToString();
		}

		public void EndEditOnEnter(string value)
		{
			if (Input.GetKey(KeyCode.Return) || Input.GetKey(KeyCode.KeypadEnter) || Input.GetKey(KeyCode.Tab))
			{
				SubmitForm(value.Trim());
			}
			else
			{
				SubmitForm(value);
			}
		}

		public void SubmitForm(string value)
		{
			int result = 0;
			int.TryParse(value, out result);
			OnSubmit.Invoke(result);
		}
	}
	public class StringInputField : MonoBehaviour
	{
		[Serializable]
		public class OnSubmitEvent : UnityEvent<string>
		{
		}

		public InputField PropertyValueInput;

		public OnSubmitEvent OnSubmit;

		private bool registered;

		private void OnEnable()
		{
			if (!registered)
			{
				registered = true;
				PropertyValueInput.onEndEdit.AddListener(EndEditOnEnter);
			}
		}

		private void OnDisable()
		{
			registered = false;
			PropertyValueInput.onEndEdit.RemoveListener(EndEditOnEnter);
		}

		public void SetValue(string value)
		{
			PropertyValueInput.text = value.ToString();
		}

		public void EndEditOnEnter(string value)
		{
			if (Input.GetKey(KeyCode.Return) || Input.GetKey(KeyCode.KeypadEnter) || Input.GetKey(KeyCode.Tab))
			{
				SubmitForm(value.Trim());
			}
			else
			{
				SubmitForm(value);
			}
		}

		public void SubmitForm(string value)
		{
			OnSubmit.Invoke(value);
		}
	}
	public class ToggleExpand : MonoBehaviour
	{
		public GameObject Content;

		public Toggle Toggle;

		private bool _init;

		private void OnEnable()
		{
			Content.SetActive(Toggle.isOn);
			if (!_init)
			{
				_init = true;
				Toggle.onValueChanged.AddListener(HandleToggleOnValudChanged);
			}
			HandleToggleOnValudChanged(Toggle.isOn);
		}

		private void HandleToggleOnValudChanged(bool value)
		{
			Content.SetActive(value);
		}
	}
	public class LayoutElementMatchSize : MonoBehaviour
	{
		public LayoutElement layoutElement;

		public RectTransform Target;

		public bool MatchHeight = true;

		public bool MatchWidth;

		private void Update()
		{
			if (MatchHeight && layoutElement.minHeight != Target.sizeDelta.y)
			{
				layoutElement.minHeight = Target.sizeDelta.y;
			}
		}
	}
	public class NickNameField : MonoBehaviour
	{
		public InputField PropertyValueInput;

		private string _cache;

		private bool registered;

		private void OnEnable()
		{
			if (!registered)
			{
				registered = true;
				PropertyValueInput.onEndEdit.AddListener(OnEndEdit);
			}
		}

		private void OnDisable()
		{
			registered = false;
			PropertyValueInput.onEndEdit.RemoveListener(OnEndEdit);
		}

		private void Update()
		{
			if (PhotonNetwork.NickName != _cache)
			{
				_cache = PhotonNetwork.NickName;
				PropertyValueInput.text = _cache;
			}
		}

		public void OnEndEdit(string value)
		{
			if (Input.GetKey(KeyCode.Return) || Input.GetKey(KeyCode.KeypadEnter) || Input.GetKey(KeyCode.Tab))
			{
				SubmitForm(value.Trim());
			}
			else
			{
				SubmitForm(value);
			}
		}

		public void SubmitForm(string value)
		{
			_cache = value;
			PhotonNetwork.NickName = _cache;
		}
	}
	public class OnlineDocButton : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
	{
		public string Url = "https://doc.photonengine.com/en-us/pun/v2/getting-started/pun-intro";

		public void OnPointerClick(PointerEventData pointerEventData)
		{
			Application.OpenURL(Url);
		}
	}
	public class SendRateField : MonoBehaviour
	{
		public InputField PropertyValueInput;

		private int _cache;

		private bool registered;

		private void OnEnable()
		{
			if (!registered)
			{
				registered = true;
				PropertyValueInput.onEndEdit.AddListener(OnEndEdit);
			}
		}

		private void OnDisable()
		{
			registered = false;
			PropertyValueInput.onEndEdit.RemoveListener(OnEndEdit);
		}

		private void Update()
		{
			if (PhotonNetwork.SendRate != _cache)
			{
				_cache = PhotonNetwork.SendRate;
				PropertyValueInput.text = _cache.ToString();
			}
		}

		public void OnEndEdit(string value)
		{
			if (Input.GetKey(KeyCode.Return) || Input.GetKey(KeyCode.KeypadEnter) || Input.GetKey(KeyCode.Tab))
			{
				SubmitForm(value.Trim());
			}
			else
			{
				SubmitForm(value);
			}
		}

		public void SubmitForm(string value)
		{
			_cache = int.Parse(value);
			PhotonNetwork.SendRate = _cache;
		}
	}
	public class SendRateOnSerializeField : MonoBehaviour
	{
		public InputField PropertyValueInput;

		private int _cache;

		private bool registered;

		private void OnEnable()
		{
			if (!registered)
			{
				registered = true;
				PropertyValueInput.onEndEdit.AddListener(OnEndEdit);
			}
		}

		private void OnDisable()
		{
			registered = false;
			PropertyValueInput.onEndEdit.RemoveListener(OnEndEdit);
		}

		private void Update()
		{
			if (PhotonNetwork.SerializationRate != _cache)
			{
				_cache = PhotonNetwork.SerializationRate;
				PropertyValueInput.text = _cache.ToString();
			}
		}

		public void OnEndEdit(string value)
		{
			if (Input.GetKey(KeyCode.Return) || Input.GetKey(KeyCode.KeypadEnter) || Input.GetKey(KeyCode.Tab))
			{
				SubmitForm(value.Trim());
			}
			else
			{
				SubmitForm(value);
			}
		}

		public void SubmitForm(string value)
		{
			_cache = int.Parse(PropertyValueInput.text);
			PhotonNetwork.SerializationRate = _cache;
		}
	}
	public class PlayerDetailsController : MonoBehaviourPunCallbacks
	{
		public GameObject ContentPanel;

		public PropertyCell PropertyCellPrototype;

		public Text UpdateStatusText;

		public Transform BuiltInPropertiesPanel;

		public Transform PlayerNumberingExtensionPanel;

		public Transform ScoreExtensionPanel;

		public Transform TeamExtensionPanel;

		public Transform TurnExtensionPanel;

		public Transform CustomPropertiesPanel;

		public GameObject MasterClientToolBar;

		public GameObject NotInRoomLabel;

		private Dictionary<string, PropertyCell> builtInPropsCellList = new Dictionary<string, PropertyCell>();

		private Player _player;

		private void Awake()
		{
			PropertyCellPrototype.gameObject.SetActive(value: false);
		}

		public override void OnEnable()
		{
			base.OnEnable();
			UpdateStatusText.text = string.Empty;
			NotInRoomLabel.SetActive(value: false);
			PlayerNumbering.OnPlayerNumberingChanged += OnPlayerNumberingChanged;
		}

		public void SetPlayerTarget(Player player)
		{
			_player = player;
			ContentPanel.SetActive(value: true);
			NotInRoomLabel.SetActive(value: false);
			ResetList();
			foreach (DictionaryEntry allPlayerBuiltIntProperty in GetAllPlayerBuiltIntProperties())
			{
				AddProperty(ParseKey(allPlayerBuiltIntProperty.Key), allPlayerBuiltIntProperty.Value.ToString(), BuiltInPropertiesPanel);
			}
			AddProperty("Player Number", "#" + player.GetPlayerNumber().ToString("00"), PlayerNumberingExtensionPanel);
			AddProperty("score", player.GetScore().ToString(), ScoreExtensionPanel);
			foreach (DictionaryEntry customProperty in _player.CustomProperties)
			{
				AddProperty(ParseKey(customProperty.Key), customProperty.Value.ToString(), CustomPropertiesPanel);
			}
			MasterClientToolBar.SetActive(PhotonNetwork.CurrentRoom.PlayerCount > 1 && PhotonNetwork.LocalPlayer.IsMasterClient);
		}

		private void AddProperty(string property, string value, Transform parent)
		{
			PropertyCell propertyCell = UnityEngine.Object.Instantiate(PropertyCellPrototype);
			builtInPropsCellList.Add(property, propertyCell);
			propertyCell.transform.SetParent(parent, worldPositionStays: false);
			propertyCell.gameObject.SetActive(value: true);
			propertyCell.AddToList(property, value);
		}

		private string ParseKey(object key)
		{
			if (key.GetType() == typeof(byte))
			{
				switch ((byte)key)
				{
				case byte.MaxValue:
					return "PlayerName";
				case 254:
					return "Inactive";
				case 253:
					return "UserId";
				}
			}
			return key.ToString();
		}

		public void KickOutPlayer()
		{
			PhotonNetwork.CloseConnection(_player);
		}

		public void SetAsMaster()
		{
			PhotonNetwork.SetMasterClient(_player);
		}

		public override void OnPlayerLeftRoom(Player otherPlayer)
		{
			NotInRoomLabel.SetActive(otherPlayer == _player);
			ContentPanel.SetActive(otherPlayer != _player);
		}

		public override void OnMasterClientSwitched(Player newMasterClient)
		{
			MasterClientToolBar.SetActive(_player == newMasterClient);
		}

		public override void OnPlayerPropertiesUpdate(Player target, ExitGames.Client.Photon.Hashtable changedProps)
		{
			if (_player.ActorNumber == target.ActorNumber)
			{
				foreach (DictionaryEntry changedProp in changedProps)
				{
					string text = ParseKey(changedProp.Key);
					if (builtInPropsCellList.ContainsKey(text))
					{
						builtInPropsCellList[text].UpdateInfo(changedProp.Value.ToString());
					}
					else
					{
						AddProperty(text, changedProp.Value.ToString(), CustomPropertiesPanel);
					}
				}
			}
			StartCoroutine("UpdateUIPing");
		}

		private void OnPlayerNumberingChanged()
		{
			if (_player != null)
			{
				builtInPropsCellList["Player Number"].UpdateInfo("#" + _player.GetPlayerNumber().ToString("00"));
			}
		}

		private IEnumerator UpdateUIPing()
		{
			UpdateStatusText.text = "Updated";
			yield return new WaitForSeconds(1f);
			UpdateStatusText.text = string.Empty;
		}

		public void ResetList()
		{
			foreach (KeyValuePair<string, PropertyCell> builtInPropsCell in builtInPropsCellList)
			{
				if (builtInPropsCell.Value != null)
				{
					UnityEngine.Object.Destroy(builtInPropsCell.Value.gameObject);
				}
			}
			builtInPropsCellList = new Dictionary<string, PropertyCell>();
		}

		private ExitGames.Client.Photon.Hashtable GetAllPlayerBuiltIntProperties()
		{
			ExitGames.Client.Photon.Hashtable hashtable = new ExitGames.Client.Photon.Hashtable();
			if (_player != null)
			{
				hashtable["ID"] = _player.ActorNumber;
				hashtable[(byte)253] = ((_player.UserId != null) ? _player.UserId : string.Empty);
				hashtable["NickName"] = ((_player.NickName != null) ? _player.NickName : string.Empty);
				hashtable["IsLocal"] = _player.IsLocal;
				hashtable[(byte)254] = _player.IsInactive;
				hashtable["IsMasterClient"] = _player.IsMasterClient;
			}
			UnityEngine.Debug.Log(hashtable.ToStringFull());
			return hashtable;
		}
	}
	public class InfosPanelPlaceholder : MonoBehaviour
	{
		public PunCockpit Manager;

		private void OnEnable()
		{
			Manager.RequestInfosPanel(base.gameObject);
		}
	}
	public class FriendListCell : MonoBehaviour
	{
		public FriendListView ListManager;

		public Text NameText;

		public GameObject OnlineFlag;

		public GameObject inRoomText;

		public GameObject JoinButton;

		private FriendInfo _info;

		public void RefreshInfo(FriendListView.FriendDetail details)
		{
			NameText.text = details.NickName;
			OnlineFlag.SetActive(value: false);
			inRoomText.SetActive(value: false);
			JoinButton.SetActive(value: false);
		}

		public void RefreshInfo(FriendInfo info)
		{
			_info = info;
			OnlineFlag.SetActive(_info.IsOnline);
			inRoomText.SetActive(_info.IsInRoom);
			JoinButton.SetActive(_info.IsInRoom);
		}

		public void JoinFriendRoom()
		{
			ListManager.JoinFriendRoom(_info.Room);
		}

		public void RemoveFromList()
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}
	public class FriendListView : MonoBehaviourPunCallbacks
	{
		[Serializable]
		public class FriendDetail
		{
			public string NickName;

			public string UserId;

			public FriendDetail(string NickName, string UserId)
			{
				this.NickName = NickName;
				this.UserId = UserId;
			}
		}

		[Serializable]
		public class OnJoinRoomEvent : UnityEvent<string>
		{
		}

		public FriendListCell CellPrototype;

		public Text ContentFeedback;

		public Text UpdateStatusText;

		public OnJoinRoomEvent OnJoinRoom;

		private Dictionary<string, FriendListCell> FriendCellList = new Dictionary<string, FriendListCell>();

		private string[] FriendsLUT = new string[0];

		private void Awake()
		{
			CellPrototype.gameObject.SetActive(value: false);
		}

		public override void OnEnable()
		{
			base.OnEnable();
			UpdateStatusText.text = string.Empty;
			ContentFeedback.text = string.Empty;
		}

		public void SetFriendDetails(FriendDetail[] friendList)
		{
			ResetList();
			List<string> list = new List<string>();
			foreach (FriendDetail friendDetail in friendList)
			{
				if (friendDetail.UserId != PhotonNetwork.LocalPlayer.UserId)
				{
					FriendCellList[friendDetail.UserId] = UnityEngine.Object.Instantiate(CellPrototype);
					FriendCellList[friendDetail.UserId].transform.SetParent(CellPrototype.transform.parent, worldPositionStays: false);
					FriendCellList[friendDetail.UserId].gameObject.SetActive(value: true);
					FriendCellList[friendDetail.UserId].RefreshInfo(friendDetail);
					list.Add(friendDetail.UserId);
				}
			}
			FriendsLUT = Enumerable.ToArray(list);
			FindFriends();
		}

		public void FindFriends()
		{
			PhotonNetwork.FindFriends(FriendsLUT);
			ContentFeedback.text = "Finding Friends...";
		}

		public override void OnFriendListUpdate(List<FriendInfo> friendList)
		{
			StartCoroutine("UpdateUIPing");
			if (friendList.Count == 0)
			{
				ContentFeedback.text = "No Friends Found";
			}
			else
			{
				ContentFeedback.text = string.Empty;
			}
			foreach (FriendInfo friend in friendList)
			{
				if (FriendCellList.ContainsKey(friend.UserId))
				{
					FriendCellList[friend.UserId].RefreshInfo(friend);
				}
			}
		}

		public void OnRoomListUpdateCallBack(List<RoomInfo> roomList)
		{
			PhotonNetwork.FindFriends(FriendsLUT);
		}

		public void JoinFriendRoom(string RoomName)
		{
			OnJoinRoom.Invoke(RoomName);
		}

		private IEnumerator UpdateUIPing()
		{
			UpdateStatusText.text = "Updated";
			yield return new WaitForSeconds(1f);
			UpdateStatusText.text = string.Empty;
		}

		public void ResetList()
		{
			foreach (KeyValuePair<string, FriendListCell> friendCell in FriendCellList)
			{
				if (friendCell.Value != null)
				{
					UnityEngine.Object.Destroy(friendCell.Value.gameObject);
				}
			}
			FriendCellList = new Dictionary<string, FriendListCell>();
		}
	}
	public class PlayerListCell : MonoBehaviour
	{
		public PlayerListView ListManager;

		public Text NumberText;

		public Text NameText;

		public Image ActiveFlag;

		public Color InactiveColor;

		public Color ActiveColor;

		public Text isLocalText;

		public Image isMasterFlag;

		public LayoutElement LayoutElement;

		private Player _player;

		public bool isInactiveCache;

		public void RefreshInfo(ExitGames.Client.Photon.Hashtable changedProps)
		{
			UpdateInfo();
		}

		public void AddToList(Player info, bool animate = false)
		{
			_player = info;
			UpdateInfo();
			if (animate)
			{
				StartCoroutine("Add");
			}
			else
			{
				LayoutElement.minHeight = 30f;
			}
		}

		public void RemoveFromList()
		{
			StartCoroutine("Remove");
		}

		public void OnClick()
		{
			ListManager.SelectPlayer(_player);
		}

		private void UpdateInfo()
		{
			if (string.IsNullOrEmpty(_player.NickName))
			{
				NameText.text = _player.ActorNumber.ToString();
			}
			int playerNumber = _player.GetPlayerNumber();
			NumberText.text = "#" + playerNumber.ToString("00");
			NameText.text = _player.NickName;
			ActiveFlag.color = (_player.IsInactive ? InactiveColor : ActiveColor);
			isLocalText.gameObject.SetActive(_player.IsLocal);
			isMasterFlag.gameObject.SetActive(_player.IsMasterClient);
			if (playerNumber >= 0 && base.transform.GetSiblingIndex() != playerNumber)
			{
				base.transform.SetSiblingIndex(playerNumber + 1);
			}
		}

		private IEnumerator Add()
		{
			isInactiveCache = false;
			LayoutElement.minHeight = 0f;
			while (LayoutElement.minHeight != 30f)
			{
				LayoutElement.minHeight = Mathf.MoveTowards(LayoutElement.minHeight, 30f, 2f);
				yield return new WaitForEndOfFrame();
			}
		}

		private IEnumerator Remove()
		{
			while (LayoutElement.minHeight != 0f)
			{
				LayoutElement.minHeight = Mathf.MoveTowards(LayoutElement.minHeight, 0f, 2f);
				yield return new WaitForEndOfFrame();
			}
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}
	public class PlayerListView : MonoBehaviourPunCallbacks
	{
		public PlayerDetailsController PlayerDetailManager;

		public PlayerListCell CellPrototype;

		public Text PlayerCountsText;

		public Text UpdateStatusText;

		private Dictionary<int, PlayerListCell> playerCellList = new Dictionary<int, PlayerListCell>();

		private void Awake()
		{
			CellPrototype.gameObject.SetActive(value: false);
		}

		public override void OnEnable()
		{
			base.OnEnable();
			UpdateStatusText.text = string.Empty;
			if (PhotonNetwork.CurrentRoom == null)
			{
				return;
			}
			RefreshCount();
			foreach (KeyValuePair<int, Player> player in PhotonNetwork.CurrentRoom.Players)
			{
				if (!playerCellList.ContainsKey(player.Key))
				{
					playerCellList[player.Key] = UnityEngine.Object.Instantiate(CellPrototype);
					playerCellList[player.Key].transform.SetParent(CellPrototype.transform.parent, worldPositionStays: false);
					playerCellList[player.Key].gameObject.SetActive(value: true);
					playerCellList[player.Key].AddToList(player.Value);
				}
			}
		}

		public void SelectPlayer(Player player)
		{
			PlayerDetailManager.SetPlayerTarget(player);
		}

		public override void OnPlayerEnteredRoom(Player newPlayer)
		{
			if (!playerCellList.ContainsKey(newPlayer.ActorNumber))
			{
				playerCellList[newPlayer.ActorNumber] = UnityEngine.Object.Instantiate(CellPrototype.gameObject).GetComponent<PlayerListCell>();
				playerCellList[newPlayer.ActorNumber].transform.SetParent(CellPrototype.transform.parent, worldPositionStays: false);
				playerCellList[newPlayer.ActorNumber].gameObject.SetActive(value: true);
				playerCellList[newPlayer.ActorNumber].AddToList(newPlayer, animate: true);
			}
			else
			{
				playerCellList[newPlayer.ActorNumber].RefreshInfo(null);
			}
			StartCoroutine("UpdateUIPing");
		}

		public override void OnMasterClientSwitched(Player newMasterClient)
		{
			foreach (KeyValuePair<int, Player> player in PhotonNetwork.CurrentRoom.Players)
			{
				playerCellList[player.Key].RefreshInfo(null);
			}
		}

		public override void OnPlayerPropertiesUpdate(Player target, ExitGames.Client.Photon.Hashtable changedProps)
		{
			if (playerCellList.ContainsKey(target.ActorNumber))
			{
				playerCellList[target.ActorNumber].RefreshInfo(changedProps);
			}
			else
			{
				UnityEngine.Debug.LogWarning("PlayerListView: missing Player Ui Cell for " + target, this);
			}
			StartCoroutine("UpdateUIPing");
		}

		public override void OnPlayerLeftRoom(Player otherPlayer)
		{
			if (!PhotonNetwork.PlayerListOthers.Contains(otherPlayer))
			{
				playerCellList[otherPlayer.ActorNumber].RemoveFromList();
				playerCellList.Remove(otherPlayer.ActorNumber);
			}
			else
			{
				playerCellList[otherPlayer.ActorNumber].RefreshInfo(null);
			}
			StartCoroutine("UpdateUIPing");
		}

		private void RefreshCount()
		{
			if (PhotonNetwork.CurrentRoom != null)
			{
				PlayerCountsText.text = PhotonNetwork.CurrentRoom.PlayerCount.ToString("00");
			}
		}

		private IEnumerator UpdateUIPing()
		{
			UpdateStatusText.text = "Updated";
			yield return new WaitForSeconds(1f);
			UpdateStatusText.text = string.Empty;
		}

		public void ResetList()
		{
			foreach (KeyValuePair<int, PlayerListCell> playerCell in playerCellList)
			{
				if (playerCell.Value != null)
				{
					UnityEngine.Object.Destroy(playerCell.Value.gameObject);
				}
			}
			playerCellList = new Dictionary<int, PlayerListCell>();
		}
	}
	public class PropertyCell : MonoBehaviour
	{
		public Text PropertyText;

		public Text ValueText;

		public Image isUpdatedFlag;

		public LayoutElement LayoutElement;

		public void UpdateInfo(string value)
		{
			bool flag = string.Equals(ValueText.text, value);
			ValueText.text = value;
			if (this != null && base.isActiveAndEnabled && flag)
			{
				StartCoroutine(UpdateUIPing());
			}
		}

		public void AddToList(string property, string value, bool animate = false)
		{
			PropertyText.text = property;
			if (animate)
			{
				UpdateInfo(value);
			}
			else
			{
				ValueText.text = value;
				isUpdatedFlag.gameObject.SetActive(value: false);
			}
			if (animate)
			{
				StartCoroutine("Add");
			}
			else
			{
				LayoutElement.minHeight = 30f;
			}
		}

		public void RemoveFromList()
		{
			StartCoroutine("Remove");
		}

		private IEnumerator UpdateUIPing()
		{
			isUpdatedFlag.gameObject.SetActive(value: true);
			yield return new WaitForSeconds(1f);
			isUpdatedFlag.gameObject.SetActive(value: false);
		}

		private IEnumerator Add()
		{
			LayoutElement.minHeight = 0f;
			while (LayoutElement.minHeight != 30f)
			{
				LayoutElement.minHeight = Mathf.MoveTowards(LayoutElement.minHeight, 30f, 2f);
				yield return new WaitForEndOfFrame();
			}
		}

		private IEnumerator Remove()
		{
			while (LayoutElement.minHeight != 0f)
			{
				LayoutElement.minHeight = Mathf.MoveTowards(LayoutElement.minHeight, 0f, 2f);
				yield return new WaitForEndOfFrame();
			}
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}
	public class RegionListCell : MonoBehaviour
	{
		public RegionListView ListManager;

		public Text CodeText;

		public Text IpText;

		public Text PingText;

		public LayoutElement LayoutElement;

		private int _index;

		private Region info;

		public void RefreshInfo(Region info)
		{
			this.info = info;
			CodeText.text = this.info.Code;
			IpText.text = this.info.HostAndPort;
			PingText.text = this.info.Ping + "ms";
		}

		public void AddToList(Region info, int index)
		{
			RefreshInfo(info);
			_index = index;
			StartCoroutine("AnimateAddition");
		}

		public void RemoveFromList()
		{
			StartCoroutine("AnimateRemove");
		}

		private IEnumerator AnimateAddition()
		{
			LayoutElement.minHeight = 0f;
			yield return new WaitForSeconds((float)_index * 0.04f);
			while (LayoutElement.minHeight != 30f)
			{
				LayoutElement.minHeight = Mathf.MoveTowards(LayoutElement.minHeight, 30f, 2f);
				yield return new WaitForEndOfFrame();
			}
		}

		private IEnumerator AnimateRemove()
		{
			while (LayoutElement.minHeight != 0f)
			{
				LayoutElement.minHeight = Mathf.MoveTowards(LayoutElement.minHeight, 0f, 2f);
				yield return new WaitForEndOfFrame();
			}
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}
	public class RegionListView : MonoBehaviour
	{
		public RegionListCell CellPrototype;

		private Dictionary<string, RegionListCell> regionCellList = new Dictionary<string, RegionListCell>();

		public void OnEnable()
		{
			ResetList();
			CellPrototype.gameObject.SetActive(value: false);
		}

		public void OnRegionListUpdate(List<Region> regionList)
		{
			int num = 0;
			foreach (Region region in regionList)
			{
				regionCellList[region.Code] = UnityEngine.Object.Instantiate(CellPrototype);
				regionCellList[region.Code].gameObject.SetActive(value: true);
				regionCellList[region.Code].transform.SetParent(CellPrototype.transform.parent, worldPositionStays: false);
				regionCellList[region.Code].AddToList(region, num);
				num++;
			}
		}

		public void ResetList()
		{
			foreach (KeyValuePair<string, RegionListCell> regionCell in regionCellList)
			{
				if (regionCell.Value != null)
				{
					UnityEngine.Object.Destroy(regionCell.Value.gameObject);
				}
			}
			regionCellList = new Dictionary<string, RegionListCell>();
		}
	}
	public class RoomListCell : MonoBehaviour
	{
		public RoomListView ListManager;

		public Text RoomNameText;

		public Text PlayerCountText;

		public Text OpenText;

		public CanvasGroup JoinButtonCanvasGroup;

		public LayoutElement LayoutElement;

		public RoomInfo info;

		public void RefreshInfo(RoomInfo info)
		{
			this.info = info;
			RoomNameText.text = info.Name;
			PlayerCountText.text = info.PlayerCount + "/" + info.MaxPlayers;
			if (info.IsOpen)
			{
				OpenText.text = "Open";
				OpenText.color = Color.green;
				JoinButtonCanvasGroup.blocksRaycasts = true;
				JoinButtonCanvasGroup.alpha = 1f;
			}
			else
			{
				OpenText.text = "Closed";
				OpenText.color = Color.red;
				JoinButtonCanvasGroup.blocksRaycasts = false;
				JoinButtonCanvasGroup.alpha = 0f;
			}
		}

		public void OnJoinRoomButtonClick()
		{
			ListManager.OnRoomCellJoinButtonClick(info.Name);
		}

		public void AddToList(RoomInfo info, bool animate = false)
		{
			RefreshInfo(info);
			if (animate)
			{
				StartCoroutine("AnimateAddition");
			}
			else
			{
				LayoutElement.minHeight = 30f;
			}
		}

		public void RemoveFromList()
		{
			StartCoroutine("AnimateRemove");
		}

		private IEnumerator AnimateAddition()
		{
			LayoutElement.minHeight = 0f;
			while (LayoutElement.minHeight != 30f)
			{
				LayoutElement.minHeight = Mathf.MoveTowards(LayoutElement.minHeight, 30f, 2f);
				yield return new WaitForEndOfFrame();
			}
		}

		private IEnumerator AnimateRemove()
		{
			while (LayoutElement.minHeight != 0f)
			{
				LayoutElement.minHeight = Mathf.MoveTowards(LayoutElement.minHeight, 0f, 2f);
				yield return new WaitForEndOfFrame();
			}
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}
	public class RoomListView : MonoBehaviourPunCallbacks
	{
		[Serializable]
		public class OnJoinRoomEvent : UnityEvent<string>
		{
		}

		public OnJoinRoomEvent OnJoinRoom;

		public RoomListCell CellPrototype;

		public Text UpdateStatusText;

		public Text ContentFeedback;

		public InputField LobbyNameInputField;

		public InputField SqlQueryInputField;

		private bool _firstUpdate = true;

		private Dictionary<string, RoomListCell> roomCellList = new Dictionary<string, RoomListCell>();

		public override void OnEnable()
		{
			base.OnEnable();
			ResetList();
			CellPrototype.gameObject.SetActive(value: false);
			UpdateStatusText.text = string.Empty;
			ContentFeedback.text = string.Empty;
		}

		public void OnRoomCellJoinButtonClick(string roomName)
		{
			OnJoinRoom.Invoke(roomName);
		}

		public override void OnRoomListUpdate(List<RoomInfo> roomList)
		{
			UpdateStatusText.text = "Updated";
			if (roomList.Count == 0 && !PhotonNetwork.InLobby)
			{
				ContentFeedback.text = "No Room found in lobby " + LobbyNameInputField.text + " Matching: " + SqlQueryInputField.text;
			}
			foreach (RoomInfo room in roomList)
			{
				if (roomCellList.ContainsKey(room.Name))
				{
					if (room.RemovedFromList)
					{
						roomCellList[room.Name].RemoveFromList();
						roomCellList.Remove(room.Name);
					}
					else
					{
						roomCellList[room.Name].RefreshInfo(room);
					}
				}
				else if (!room.RemovedFromList)
				{
					roomCellList[room.Name] = UnityEngine.Object.Instantiate(CellPrototype);
					roomCellList[room.Name].gameObject.SetActive(value: true);
					roomCellList[room.Name].transform.SetParent(CellPrototype.transform.parent, worldPositionStays: false);
					roomCellList[room.Name].AddToList(room, !_firstUpdate);
				}
			}
			StartCoroutine("clearStatus");
			_firstUpdate = false;
		}

		private IEnumerator clearStatus()
		{
			yield return new WaitForSeconds(1f);
			UpdateStatusText.text = string.Empty;
		}

		public void OnJoinedLobbyCallBack()
		{
			_firstUpdate = true;
			ContentFeedback.text = string.Empty;
		}

		public void GetRoomList()
		{
			ResetList();
			TypedLobby typedLobby = new TypedLobby(LobbyNameInputField.text, LobbyType.SqlLobby);
			UnityEngine.Debug.Log("Cockpit: GetCustomRoomList() matchmaking against '" + LobbyNameInputField.text + "' SqlLobby using query :  " + SqlQueryInputField.text);
			PhotonNetwork.GetCustomRoomList(typedLobby, SqlQueryInputField.text);
			ContentFeedback.text = "looking for Rooms in Lobby '" + LobbyNameInputField.text + "' Matching: '" + SqlQueryInputField.text;
		}

		public void ResetList()
		{
			_firstUpdate = true;
			foreach (KeyValuePair<string, RoomListCell> roomCell in roomCellList)
			{
				if (roomCell.Value != null)
				{
					UnityEngine.Object.Destroy(roomCell.Value.gameObject);
				}
			}
			roomCellList = new Dictionary<string, RoomListCell>();
		}
	}
	public class UserIdField : MonoBehaviour
	{
		public PunCockpit Manager;

		public InputField PropertyValueInput;

		private string _cache;

		private bool registered;

		private void OnEnable()
		{
			if (!registered)
			{
				registered = true;
				PropertyValueInput.onEndEdit.AddListener(OnEndEdit);
			}
		}

		private void OnDisable()
		{
			registered = false;
			PropertyValueInput.onEndEdit.RemoveListener(OnEndEdit);
		}

		private void Update()
		{
			if (Manager.UserId != _cache)
			{
				_cache = Manager.UserId;
				PropertyValueInput.text = _cache;
			}
		}

		public void OnEndEdit(string value)
		{
			if (Input.GetKey(KeyCode.Return) || Input.GetKey(KeyCode.KeypadEnter) || Input.GetKey(KeyCode.Tab))
			{
				SubmitForm(value.Trim());
			}
			else
			{
				SubmitForm(value);
			}
		}

		public void SubmitForm(string value)
		{
			_cache = value;
			Manager.UserId = _cache;
		}
	}
	public class AppVersionProperty : MonoBehaviour
	{
		public Text Text;

		private string _cache;

		private void Update()
		{
			if (PhotonNetwork.AppVersion != _cache)
			{
				_cache = PhotonNetwork.AppVersion;
				Text.text = _cache;
			}
		}
	}
	public class BestRegionInPrefsProperty : PropertyListenerBase
	{
		public Text Text;

		private string _cache;

		private void Update()
		{
			if (PhotonNetwork.BestRegionSummaryInPreferences != _cache)
			{
				_cache = PhotonNetwork.BestRegionSummaryInPreferences;
				OnValueChanged();
				if (string.IsNullOrEmpty(_cache))
				{
					Text.text = "n/a";
				}
				else
				{
					Text.text = _cache;
				}
			}
		}
	}
	public class CloudRegionProperty : PropertyListenerBase
	{
		public Text Text;

		private string _cache;

		private void Update()
		{
			if (PhotonNetwork.CloudRegion != _cache)
			{
				_cache = PhotonNetwork.CloudRegion;
				OnValueChanged();
				if (string.IsNullOrEmpty(_cache))
				{
					Text.text = "n/a";
				}
				else
				{
					Text.text = _cache;
				}
			}
		}
	}
	public class CountOfPlayersInRoomProperty : PropertyListenerBase
	{
		public Text Text;

		private int _cache = -1;

		private void Update()
		{
			if (PhotonNetwork.NetworkingClient.Server == ServerConnection.MasterServer)
			{
				if (PhotonNetwork.CountOfPlayersInRooms != _cache)
				{
					_cache = PhotonNetwork.CountOfPlayersInRooms;
					Text.text = _cache.ToString();
					OnValueChanged();
				}
			}
			else if (_cache != -1)
			{
				_cache = -1;
				Text.text = "n/a";
			}
		}
	}
	public class CountOfPlayersOnMasterProperty : PropertyListenerBase
	{
		public Text Text;

		private int _cache = -1;

		private void Update()
		{
			if (PhotonNetwork.NetworkingClient.Server == ServerConnection.MasterServer)
			{
				if (PhotonNetwork.CountOfPlayersOnMaster != _cache)
				{
					_cache = PhotonNetwork.CountOfPlayersOnMaster;
					Text.text = _cache.ToString();
					OnValueChanged();
				}
			}
			else if (_cache != -1)
			{
				_cache = -1;
				Text.text = "n/a";
			}
		}
	}
	public class CountOfPlayersProperty : PropertyListenerBase
	{
		public Text Text;

		private int _cache = -1;

		private void Update()
		{
			if (PhotonNetwork.NetworkingClient.Server == ServerConnection.MasterServer)
			{
				if (PhotonNetwork.CountOfPlayers != _cache)
				{
					_cache = PhotonNetwork.CountOfPlayers;
					Text.text = _cache.ToString();
					OnValueChanged();
				}
			}
			else if (_cache != -1)
			{
				_cache = -1;
				Text.text = "n/a";
			}
		}
	}
	public class CountOfRoomsProperty : PropertyListenerBase
	{
		public Text Text;

		private int _cache = -1;

		private void Update()
		{
			if (PhotonNetwork.NetworkingClient.Server == ServerConnection.MasterServer)
			{
				if (PhotonNetwork.CountOfRooms != _cache)
				{
					_cache = PhotonNetwork.CountOfRooms;
					Text.text = _cache.ToString();
					OnValueChanged();
				}
			}
			else if (_cache != -1)
			{
				_cache = -1;
				Text.text = "n/a";
			}
		}
	}
	public class CurrentRoomAutoCleanupProperty : PropertyListenerBase
	{
		public Text Text;

		private int _cache = -1;

		private void Update()
		{
			if (PhotonNetwork.CurrentRoom != null && PhotonNetwork.CurrentRoom.AutoCleanUp)
			{
				if ((PhotonNetwork.CurrentRoom.AutoCleanUp && _cache != 1) || (!PhotonNetwork.CurrentRoom.AutoCleanUp && _cache != 0))
				{
					_cache = (PhotonNetwork.CurrentRoom.AutoCleanUp ? 1 : 0);
					Text.text = (PhotonNetwork.CurrentRoom.AutoCleanUp ? "true" : "false");
					OnValueChanged();
				}
			}
			else if (_cache != -1)
			{
				_cache = -1;
				Text.text = "n/a";
			}
		}
	}
	public class CurrentRoomEmptyRoomTtlProperty : PropertyListenerBase
	{
		public Text Text;

		private int _cache = -1;

		private void Update()
		{
			if (PhotonNetwork.CurrentRoom != null)
			{
				if (PhotonNetwork.CurrentRoom.EmptyRoomTtl != _cache)
				{
					_cache = PhotonNetwork.CurrentRoom.EmptyRoomTtl;
					Text.text = _cache.ToString();
					OnValueChanged();
				}
			}
			else if (_cache != -1)
			{
				_cache = -1;
				Text.text = "n/a";
			}
		}
	}
	public class CurrentRoomExpectedUsersProperty : PropertyListenerBase
	{
		public Text Text;

		private string[] _cache;

		private void Update()
		{
			if (PhotonNetwork.CurrentRoom == null || PhotonNetwork.CurrentRoom.ExpectedUsers == null)
			{
				if (_cache != null)
				{
					_cache = null;
					Text.text = "n/a";
				}
			}
			else if (_cache == null || (PhotonNetwork.CurrentRoom.ExpectedUsers != null && !PhotonNetwork.CurrentRoom.ExpectedUsers.SequenceEqual(_cache)))
			{
				Text.text = string.Join("\n", PhotonNetwork.CurrentRoom.ExpectedUsers);
				OnValueChanged();
			}
			else if (PhotonNetwork.CurrentRoom.ExpectedUsers == null && _cache != null)
			{
				Text.text = string.Join("\n", PhotonNetwork.CurrentRoom.ExpectedUsers);
				OnValueChanged();
			}
		}
	}
	public class CurrentRoomIsOfflineProperty : PropertyListenerBase
	{
		public Text Text;

		private int _cache = -1;

		private void Update()
		{
			if (PhotonNetwork.CurrentRoom != null)
			{
				if ((PhotonNetwork.CurrentRoom.IsOffline && _cache != 1) || (!PhotonNetwork.CurrentRoom.IsOffline && _cache != 0))
				{
					_cache = (PhotonNetwork.CurrentRoom.IsOffline ? 1 : 0);
					Text.text = (PhotonNetwork.CurrentRoom.IsOffline ? "true" : "false");
					OnValueChanged();
				}
			}
			else if (_cache != -1)
			{
				_cache = -1;
				Text.text = "n/a";
			}
		}
	}
	public class CurrentRoomIsOpenProperty : PropertyListenerBase
	{
		public Text Text;

		private int _cache = -1;

		private void Update()
		{
			if (PhotonNetwork.CurrentRoom != null)
			{
				if ((PhotonNetwork.CurrentRoom.IsOpen && _cache != 1) || (!PhotonNetwork.CurrentRoom.IsOpen && _cache != 0))
				{
					_cache = (PhotonNetwork.CurrentRoom.IsOpen ? 1 : 0);
					Text.text = (PhotonNetwork.CurrentRoom.IsOpen ? "true" : "false");
					OnValueChanged();
				}
			}
			else if (_cache != -1)
			{
				_cache = -1;
				Text.text = "n/a";
			}
		}
	}
	public class CurrentRoomIsVisibleProperty : PropertyListenerBase
	{
		public Text Text;

		private int _cache = -1;

		private void Update()
		{
			if (PhotonNetwork.CurrentRoom != null)
			{
				if ((PhotonNetwork.CurrentRoom.IsVisible && _cache != 1) || (!PhotonNetwork.CurrentRoom.IsVisible && _cache != 0))
				{
					_cache = (PhotonNetwork.CurrentRoom.IsVisible ? 1 : 0);
					Text.text = (PhotonNetwork.CurrentRoom.IsVisible ? "true" : "false");
					OnValueChanged();
				}
			}
			else if (_cache != -1)
			{
				_cache = -1;
				Text.text = "n/a";
			}
		}
	}
	public class CurrentRoomMasterClientIdProperty : PropertyListenerBase
	{
		public Text Text;

		private int _cache = -1;

		private void Update()
		{
			if (PhotonNetwork.CurrentRoom != null)
			{
				if (PhotonNetwork.CurrentRoom.MasterClientId != _cache)
				{
					_cache = PhotonNetwork.CurrentRoom.MasterClientId;
					Text.text = _cache.ToString();
					OnValueChanged();
				}
			}
			else if (_cache != -1)
			{
				_cache = -1;
				Text.text = "n/a";
			}
		}
	}
	public class CurrentRoomMaxPlayersProperty : PropertyListenerBase
	{
		public Text Text;

		private int _cache = -1;

		private void Update()
		{
			if (PhotonNetwork.CurrentRoom != null)
			{
				if (PhotonNetwork.CurrentRoom.MaxPlayers != _cache)
				{
					_cache = PhotonNetwork.CurrentRoom.MaxPlayers;
					Text.text = _cache.ToString();
					OnValueChanged();
				}
			}
			else if (_cache != -1)
			{
				_cache = -1;
				Text.text = "n/a";
			}
		}
	}
	public class CurrentRoomNameProperty : PropertyListenerBase
	{
		public Text Text;

		private string _cache;

		private void Update()
		{
			if (PhotonNetwork.CurrentRoom != null)
			{
				if (PhotonNetwork.CurrentRoom.Name != _cache)
				{
					_cache = PhotonNetwork.CurrentRoom.Name;
					Text.text = _cache.ToString();
					OnValueChanged();
				}
			}
			else if (_cache == null)
			{
				_cache = null;
				Text.text = "n/a";
			}
		}
	}
	public class CurrentRoomPlayerCountProperty : PropertyListenerBase
	{
		public Text Text;

		private int _cache = -1;

		private void Update()
		{
			if (PhotonNetwork.CurrentRoom != null)
			{
				if (PhotonNetwork.CurrentRoom.PlayerCount != _cache)
				{
					_cache = PhotonNetwork.CurrentRoom.PlayerCount;
					Text.text = _cache.ToString();
					OnValueChanged();
				}
			}
			else if (_cache != -1)
			{
				_cache = -1;
				Text.text = "n/a";
			}
		}
	}
	public class CurrentRoomPlayerTtlProperty : PropertyListenerBase
	{
		public Text Text;

		private int _cache = -1;

		private void Update()
		{
			if (PhotonNetwork.CurrentRoom != null)
			{
				if (PhotonNetwork.CurrentRoom.PlayerTtl != _cache)
				{
					_cache = PhotonNetwork.CurrentRoom.PlayerTtl;
					Text.text = _cache.ToString();
					OnValueChanged();
				}
			}
			else if (_cache != -1)
			{
				_cache = -1;
				Text.text = "n/a";
			}
		}
	}
	public class CurrentRoomPropertiesListedInLobbyProperty : PropertyListenerBase
	{
		public Text Text;

		private string[] _cache;

		private void Update()
		{
			if (PhotonNetwork.CurrentRoom != null)
			{
				if (_cache == null || !PhotonNetwork.CurrentRoom.PropertiesListedInLobby.SequenceEqual(_cache))
				{
					_cache = PhotonNetwork.CurrentRoom.PropertiesListedInLobby.Clone() as string[];
					Text.text = string.Join("\n", PhotonNetwork.CurrentRoom.PropertiesListedInLobby);
					OnValueChanged();
				}
			}
			else if (_cache != null)
			{
				_cache = null;
				Text.text = "n/a";
			}
		}
	}
	public class GameVersionProperty : MonoBehaviour
	{
		public Text Text;

		private string _cache;

		private void Update()
		{
			if (PhotonNetwork.GameVersion != _cache)
			{
				_cache = PhotonNetwork.GameVersion;
				Text.text = _cache;
			}
		}
	}
	public class IsConnectedAndReadyProperty : PropertyListenerBase
	{
		public Text Text;

		private int _cache = -1;

		private void Update()
		{
			if ((PhotonNetwork.IsConnectedAndReady && _cache != 1) || (!PhotonNetwork.IsConnectedAndReady && _cache != 0))
			{
				_cache = (PhotonNetwork.IsConnectedAndReady ? 1 : 0);
				Text.text = (PhotonNetwork.IsConnectedAndReady ? "true" : "false");
				OnValueChanged();
			}
		}
	}
	public class IsConnectedProperty : PropertyListenerBase
	{
		public Text Text;

		private int _cache = -1;

		private void Update()
		{
			if ((PhotonNetwork.IsConnected && _cache != 1) || (!PhotonNetwork.IsConnected && _cache != 0))
			{
				_cache = (PhotonNetwork.IsConnected ? 1 : 0);
				Text.text = (PhotonNetwork.IsConnected ? "true" : "false");
				OnValueChanged();
			}
		}
	}
	public class OfflineModeProperty : PropertyListenerBase
	{
		public Text Text;

		private int _cache = -1;

		private void Update()
		{
			if ((PhotonNetwork.OfflineMode && _cache != 1) || (!PhotonNetwork.OfflineMode && _cache != 0))
			{
				_cache = (PhotonNetwork.OfflineMode ? 1 : 0);
				Text.text = (PhotonNetwork.OfflineMode ? "true" : "false");
				OnValueChanged();
			}
		}
	}
	public class PingProperty : PropertyListenerBase
	{
		public Text Text;

		private int _cache = -1;

		private void Update()
		{
			if (PhotonNetwork.IsConnectedAndReady)
			{
				if (PhotonNetwork.GetPing() != _cache)
				{
					_cache = PhotonNetwork.GetPing();
					Text.text = _cache + " ms";
					OnValueChanged();
				}
			}
			else if (_cache != -1)
			{
				_cache = -1;
				Text.text = "n/a";
			}
		}
	}
	public class PropertyListenerBase : MonoBehaviour
	{
		public Graphic UpdateIndicator;

		private YieldInstruction fadeInstruction = new YieldInstruction();

		private float Duration = 1f;

		public void OnValueChanged()
		{
			StartCoroutine(FadeOut(UpdateIndicator));
		}

		private IEnumerator FadeOut(Graphic image)
		{
			float elapsedTime = 0f;
			Color c = image.color;
			while (elapsedTime < Duration)
			{
				yield return fadeInstruction;
				elapsedTime += Time.deltaTime;
				c.a = 1f - Mathf.Clamp01(elapsedTime / Duration);
				image.color = c;
			}
		}
	}
	public class ServerAddressProperty : MonoBehaviour
	{
		public Text Text;

		private string _cache;

		private void Update()
		{
			if (PhotonNetwork.IsConnectedAndReady)
			{
				if (PhotonNetwork.ServerAddress != _cache)
				{
					_cache = PhotonNetwork.ServerAddress;
					Text.text = _cache;
				}
			}
			else if (_cache != "n/a")
			{
				_cache = "n/a";
				Text.text = _cache;
			}
		}
	}
	public class ServerProperty : PropertyListenerBase
	{
		public Text Text;

		private ServerConnection _cache;

		private void Update()
		{
			if (PhotonNetwork.Server != _cache)
			{
				_cache = PhotonNetwork.Server;
				Text.text = PhotonNetwork.Server.ToString();
				OnValueChanged();
			}
		}
	}
	public class PunCockpitEmbed : MonoBehaviourPunCallbacks
	{
		private string PunCockpit_scene = "PunCockpit-Scene";

		public bool EmbeddCockpit = true;

		public string CockpitGameTitle = "";

		public GameObject LoadingIndicator;

		public ConnectAndJoinRandom AutoConnect;

		private void Awake()
		{
			if (LoadingIndicator != null)
			{
				LoadingIndicator.SetActive(value: false);
			}
		}

		private IEnumerator Start()
		{
			PunCockpit.Embedded = EmbeddCockpit;
			PunCockpit.EmbeddedGameTitle = CockpitGameTitle;
			SceneManager.LoadScene(PunCockpit_scene, LoadSceneMode.Additive);
			yield return new WaitForSeconds(1f);
			if (SceneManager.sceneCount == 1)
			{
				AutoConnect.ConnectNow();
				if (LoadingIndicator != null)
				{
					LoadingIndicator.SetActive(value: true);
				}
			}
			else
			{
				UnityEngine.Object.Destroy(AutoConnect);
			}
			yield return 0;
		}

		public override void OnJoinedRoom()
		{
			if (LoadingIndicator != null)
			{
				LoadingIndicator.SetActive(value: false);
			}
			if (PunCockpit.Instance != null)
			{
				PunCockpit.Instance.SwitchtoMinimalPanel();
			}
		}
	}
}
namespace Photon.Pun.Demo.Cockpit.Forms
{
	public class ConnectToRegionUIForm : MonoBehaviour
	{
		[Serializable]
		public class OnSubmitEvent : UnityEvent<string>
		{
		}

		public InputField RegionInput;

		public Dropdown RegionListInput;

		public OnSubmitEvent OnSubmit;

		public void Start()
		{
		}

		public void EndEditOnEnter()
		{
			if (Input.GetKey(KeyCode.Return) || Input.GetKey(KeyCode.KeypadEnter))
			{
				SubmitForm();
			}
		}

		public void SetRegionFromDropDown(int index)
		{
			if (index != 0)
			{
				RegionInput.text = RegionListInput.options[index].text;
				RegionListInput.value = 0;
			}
		}

		public void SubmitForm()
		{
			OnSubmit.Invoke(RegionInput.text);
		}
	}
	public class CreateRoomUiForm : MonoBehaviour
	{
		[Serializable]
		public class OnSubmitEvent : UnityEvent<string, string, LobbyType, string[]>
		{
		}

		public InputField RoomNameInput;

		public InputField LobbyNameInput;

		public InputField ExpectedUsersInput;

		public Dropdown LobbyTypeInput;

		public OnSubmitEvent OnSubmit;

		public void Start()
		{
		}

		public void EndEditOnEnter()
		{
			if (Input.GetKey(KeyCode.Return) || Input.GetKey(KeyCode.KeypadEnter))
			{
				SubmitForm();
			}
		}

		public void SubmitForm()
		{
			LobbyType arg = LobbyType.Default;
			if (LobbyTypeInput.value == 1)
			{
				arg = LobbyType.SqlLobby;
			}
			else if (LobbyTypeInput.value == 2)
			{
				arg = LobbyType.AsyncRandomLobby;
			}
			string[] arg2 = (string.IsNullOrEmpty(ExpectedUsersInput.text) ? null : (from t in ExpectedUsersInput.text.Split(',')
				select t.Trim()).ToArray());
			OnSubmit.Invoke(string.IsNullOrEmpty(RoomNameInput.text) ? null : RoomNameInput.text, string.IsNullOrEmpty(LobbyNameInput.text) ? null : LobbyNameInput.text, arg, arg2);
		}
	}
	public class LoadLevelUIForm : MonoBehaviour
	{
		[Serializable]
		public class OnSubmitEvent : UnityEvent<string>
		{
		}

		public InputField PropertyValueInput;

		public OnSubmitEvent OnSubmit;

		public void Start()
		{
		}

		public void EndEditOnEnter()
		{
			if (Input.GetKey(KeyCode.Return) || Input.GetKey(KeyCode.KeypadEnter))
			{
				SubmitForm();
			}
		}

		public void SubmitForm()
		{
			OnSubmit.Invoke(PropertyValueInput.text);
		}
	}
	public class SetRoomCustomPropertyUIForm : MonoBehaviour
	{
		[Serializable]
		public class OnSubmitEvent : UnityEvent<string>
		{
		}

		public InputField PropertyValueInput;

		public OnSubmitEvent OnSubmit;

		public void Start()
		{
		}

		public void EndEditOnEnter()
		{
			if (Input.GetKey(KeyCode.Return) || Input.GetKey(KeyCode.KeypadEnter))
			{
				SubmitForm();
			}
		}

		public void SubmitForm()
		{
			OnSubmit.Invoke(PropertyValueInput.text);
		}
	}
	public class UserIdUiForm : MonoBehaviour
	{
		[Serializable]
		public class OnSubmitEvent : UnityEvent<string>
		{
		}

		public const string UserIdPlayerPref = "PunUserId";

		public InputField idInput;

		public OnSubmitEvent OnSubmit;

		public void Start()
		{
			string @string = PlayerPrefs.GetString("PunUserId");
			if (!string.IsNullOrEmpty(@string))
			{
				idInput.text = @string;
			}
		}

		public void EndEditOnEnter()
		{
			if (Input.GetKey(KeyCode.Return) || Input.GetKey(KeyCode.KeypadEnter))
			{
				SubmitForm();
			}
		}

		public void SubmitForm()
		{
			PlayerPrefs.SetString("PunUserId", idInput.text);
			OnSubmit.Invoke(idInput.text);
		}
	}
}
namespace Photon.Pun.Demo.PunBasics
{
	public class CameraWork : MonoBehaviour
	{
		[Tooltip("The distance in the local x-z plane to the target")]
		[SerializeField]
		private float distance = 7f;

		[Tooltip("The height we want the camera to be above the target")]
		[SerializeField]
		private float height = 3f;

		[Tooltip("The Smooth time lag for the height of the camera.")]
		[SerializeField]
		private float heightSmoothLag = 0.3f;

		[Tooltip("Allow the camera to be offseted vertically from the target, for example giving more view of the sceneray and less ground.")]
		[SerializeField]
		private Vector3 centerOffset = Vector3.zero;

		[Tooltip("Set this as false if a component of a prefab being instanciated by Photon Network, and manually call OnStartFollowing() when and if needed.")]
		[SerializeField]
		private bool followOnStart;

		private Transform cameraTransform;

		private bool isFollowing;

		private float heightVelocity;

		private float targetHeight = 100000f;

		private void Start()
		{
			if (followOnStart)
			{
				OnStartFollowing();
			}
		}

		private void LateUpdate()
		{
			if (cameraTransform == null && isFollowing)
			{
				OnStartFollowing();
			}
			if (isFollowing)
			{
				Apply();
			}
		}

		public void OnStartFollowing()
		{
			cameraTransform = Camera.main.transform;
			isFollowing = true;
			Cut();
		}

		private void Apply()
		{
			Vector3 vector = base.transform.position + centerOffset;
			float y = base.transform.eulerAngles.y;
			float y2 = cameraTransform.eulerAngles.y;
			y2 = y;
			targetHeight = vector.y + height;
			float y3 = cameraTransform.position.y;
			y3 = Mathf.SmoothDamp(y3, targetHeight, ref heightVelocity, heightSmoothLag);
			Quaternion quaternion = Quaternion.Euler(0f, y2, 0f);
			cameraTransform.position = vector;
			cameraTransform.position += quaternion * Vector3.back * distance;
			cameraTransform.position = new Vector3(cameraTransform.position.x, y3, cameraTransform.position.z);
			SetUpRotation(vector);
		}

		private void Cut()
		{
			float num = heightSmoothLag;
			heightSmoothLag = 0.001f;
			Apply();
			heightSmoothLag = num;
		}

		private void SetUpRotation(Vector3 centerPos)
		{
			Vector3 position = cameraTransform.position;
			Vector3 vector = centerPos - position;
			Quaternion quaternion = Quaternion.LookRotation(new Vector3(vector.x, 0f, vector.z));
			Vector3 forward = Vector3.forward * distance + Vector3.down * height;
			cameraTransform.rotation = quaternion * Quaternion.LookRotation(forward);
		}
	}
	public class GameManager : MonoBehaviourPunCallbacks
	{
		public static GameManager Instance;

		private GameObject instance;

		[Tooltip("The prefab to use for representing the player")]
		[SerializeField]
		private GameObject playerPrefab;

		private void Start()
		{
			Instance = this;
			if (!PhotonNetwork.IsConnected)
			{
				SceneManager.LoadScene("PunBasics-Launcher");
			}
			else if (playerPrefab == null)
			{
				UnityEngine.Debug.LogError("<Color=Red><b>Missing</b></Color> playerPrefab Reference. Please set it up in GameObject 'Game Manager'", this);
			}
			else if (PlayerManager.LocalPlayerInstance == null)
			{
				UnityEngine.Debug.LogFormat("We are Instantiating LocalPlayer from {0}", SceneManagerHelper.ActiveSceneName);
				PhotonNetwork.Instantiate(playerPrefab.name, new Vector3(0f, 5f, 0f), Quaternion.identity, 0);
			}
			else
			{
				UnityEngine.Debug.LogFormat("Ignoring scene load for {0}", SceneManagerHelper.ActiveSceneName);
			}
		}

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.Escape))
			{
				QuitApplication();
			}
		}

		public override void OnPlayerEnteredRoom(Player other)
		{
			UnityEngine.Debug.Log("OnPlayerEnteredRoom() " + other.NickName);
			if (PhotonNetwork.IsMasterClient)
			{
				UnityEngine.Debug.LogFormat("OnPlayerEnteredRoom IsMasterClient {0}", PhotonNetwork.IsMasterClient);
				LoadArena();
			}
		}

		public override void OnPlayerLeftRoom(Player other)
		{
			UnityEngine.Debug.Log("OnPlayerLeftRoom() " + other.NickName);
			if (PhotonNetwork.IsMasterClient)
			{
				UnityEngine.Debug.LogFormat("OnPlayerEnteredRoom IsMasterClient {0}", PhotonNetwork.IsMasterClient);
				LoadArena();
			}
		}

		public override void OnLeftRoom()
		{
			SceneManager.LoadScene("PunBasics-Launcher");
		}

		public void LeaveRoom()
		{
			PhotonNetwork.LeaveRoom();
		}

		public void QuitApplication()
		{
			Application.Quit();
		}

		private void LoadArena()
		{
			if (!PhotonNetwork.IsMasterClient)
			{
				UnityEngine.Debug.LogError("PhotonNetwork : Trying to Load a level but we are not the master Client");
			}
			UnityEngine.Debug.LogFormat("PhotonNetwork : Loading Level : {0}", PhotonNetwork.CurrentRoom.PlayerCount);
			PhotonNetwork.LoadLevel("PunBasics-Room for " + PhotonNetwork.CurrentRoom.PlayerCount);
		}
	}
	public class Launcher : MonoBehaviourPunCallbacks
	{
		[Tooltip("The Ui Panel to let the user enter name, connect and play")]
		[SerializeField]
		private GameObject controlPanel;

		[Tooltip("The Ui Text to inform the user about the connection progress")]
		[SerializeField]
		private Text feedbackText;

		[Tooltip("The maximum number of players per room")]
		[SerializeField]
		private byte maxPlayersPerRoom = 4;

		[Tooltip("The UI Loader Anime")]
		[SerializeField]
		private LoaderAnime loaderAnime;

		private bool isConnecting;

		private string gameVersion = "1";

		private void Awake()
		{
			if (loaderAnime == null)
			{
				UnityEngine.Debug.LogError("<Color=Red><b>Missing</b></Color> loaderAnime Reference.", this);
			}
			PhotonNetwork.AutomaticallySyncScene = true;
		}

		public void Connect()
		{
			feedbackText.text = "";
			isConnecting = true;
			controlPanel.SetActive(value: false);
			if (loaderAnime != null)
			{
				loaderAnime.StartLoaderAnimation();
			}
			if (PhotonNetwork.IsConnected)
			{
				LogFeedback("Joining Room...");
				PhotonNetwork.JoinRandomRoom();
			}
			else
			{
				LogFeedback("Connecting...");
				PhotonNetwork.GameVersion = gameVersion;
				PhotonNetwork.ConnectUsingSettings();
			}
		}

		private void LogFeedback(string message)
		{
			if (!(feedbackText == null))
			{
				Text text = feedbackText;
				text.text = text.text + Environment.NewLine + message;
			}
		}

		public override void OnConnectedToMaster()
		{
			if (isConnecting)
			{
				LogFeedback("OnConnectedToMaster: Next -> try to Join Random Room");
				UnityEngine.Debug.Log("PUN Basics Tutorial/Launcher: OnConnectedToMaster() was called by PUN. Now this client is connected and could join a room.\n Calling: PhotonNetwork.JoinRandomRoom(); Operation will fail if no room found");
				PhotonNetwork.JoinRandomRoom();
			}
		}

		public override void OnJoinRandomFailed(short returnCode, string message)
		{
			LogFeedback("<Color=Red>OnJoinRandomFailed</Color>: Next -> Create a new Room");
			UnityEngine.Debug.Log("PUN Basics Tutorial/Launcher:OnJoinRandomFailed() was called by PUN. No random room available, so we create one.\nCalling: PhotonNetwork.CreateRoom");
			PhotonNetwork.CreateRoom(null, new RoomOptions
			{
				MaxPlayers = maxPlayersPerRoom
			});
		}

		public override void OnDisconnected(DisconnectCause cause)
		{
			LogFeedback("<Color=Red>OnDisconnected</Color> " + cause);
			UnityEngine.Debug.LogError("PUN Basics Tutorial/Launcher:Disconnected");
			loaderAnime.StopLoaderAnimation();
			isConnecting = false;
			controlPanel.SetActive(value: true);
		}

		public override void OnJoinedRoom()
		{
			LogFeedback("<Color=Green>OnJoinedRoom</Color> with " + PhotonNetwork.CurrentRoom.PlayerCount + " Player(s)");
			UnityEngine.Debug.Log("PUN Basics Tutorial/Launcher: OnJoinedRoom() called by PUN. Now this client is in a room.\nFrom here on, your game would be running.");
			if (PhotonNetwork.CurrentRoom.PlayerCount == 1)
			{
				UnityEngine.Debug.Log("We load the 'Room for 1' ");
				PhotonNetwork.LoadLevel("PunBasics-Room for 1");
			}
		}
	}
	public class LoaderAnime : MonoBehaviour
	{
		[Tooltip("Angular Speed in degrees per seconds")]
		public float speed = 180f;

		[Tooltip("Radius os the loader")]
		public float radius = 1f;

		public GameObject particles;

		private Vector3 _offset;

		private Transform _transform;

		private Transform _particleTransform;

		private bool _isAnimating;

		private void Awake()
		{
			_particleTransform = particles.GetComponent<Transform>();
			_transform = GetComponent<Transform>();
		}

		private void Update()
		{
			if (_isAnimating)
			{
				_transform.Rotate(0f, 0f, speed * Time.deltaTime);
				_particleTransform.localPosition = Vector3.MoveTowards(_particleTransform.localPosition, _offset, 0.5f * Time.deltaTime);
			}
		}

		public void StartLoaderAnimation()
		{
			_isAnimating = true;
			_offset = new Vector3(radius, 0f, 0f);
			particles.SetActive(value: true);
		}

		public void StopLoaderAnimation()
		{
			particles.SetActive(value: false);
		}
	}
	public class PlayerAnimatorManager : MonoBehaviourPun
	{
		[SerializeField]
		private float directionDampTime = 0.25f;

		private Animator animator;

		private void Start()
		{
			animator = GetComponent<Animator>();
		}

		private void Update()
		{
			if ((base.photonView.IsMine || !PhotonNetwork.IsConnected) && (bool)animator)
			{
				if (animator.GetCurrentAnimatorStateInfo(0).IsName("Base Layer.Run") && Input.GetButtonDown("Fire2"))
				{
					animator.SetTrigger("Jump");
				}
				float axis = Input.GetAxis("Horizontal");
				float num = Input.GetAxis("Vertical");
				if (num < 0f)
				{
					num = 0f;
				}
				animator.SetFloat("Speed", axis * axis + num * num);
				animator.SetFloat("Direction", axis, directionDampTime, Time.deltaTime);
			}
		}
	}
	public class PlayerManager : MonoBehaviourPunCallbacks, IPunObservable
	{
		[Tooltip("The current Health of our player")]
		public float Health = 1f;

		[Tooltip("The local player instance. Use this to know if the local player is represented in the Scene")]
		public static GameObject LocalPlayerInstance;

		[Tooltip("The Player's UI GameObject Prefab")]
		[SerializeField]
		private GameObject playerUiPrefab;

		[Tooltip("The Beams GameObject to control")]
		[SerializeField]
		private GameObject beams;

		private bool IsFiring;

		public void Awake()
		{
			if (beams == null)
			{
				UnityEngine.Debug.LogError("<Color=Red><b>Missing</b></Color> Beams Reference.", this);
			}
			else
			{
				beams.SetActive(value: false);
			}
			if (base.photonView.IsMine)
			{
				LocalPlayerInstance = base.gameObject;
			}
			UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		}

		public void Start()
		{
			CameraWork component = base.gameObject.GetComponent<CameraWork>();
			if (component != null)
			{
				if (base.photonView.IsMine)
				{
					component.OnStartFollowing();
				}
			}
			else
			{
				UnityEngine.Debug.LogError("<Color=Red><b>Missing</b></Color> CameraWork Component on player Prefab.", this);
			}
			if (playerUiPrefab != null)
			{
				UnityEngine.Object.Instantiate(playerUiPrefab).SendMessage("SetTarget", this, SendMessageOptions.RequireReceiver);
			}
			else
			{
				UnityEngine.Debug.LogWarning("<Color=Red><b>Missing</b></Color> PlayerUiPrefab reference on player Prefab.", this);
			}
			SceneManager.sceneLoaded += OnSceneLoaded;
		}

		public override void OnDisable()
		{
			base.OnDisable();
			SceneManager.sceneLoaded -= OnSceneLoaded;
		}

		public void Update()
		{
			if (base.photonView.IsMine)
			{
				ProcessInputs();
				if (Health <= 0f)
				{
					GameManager.Instance.LeaveRoom();
				}
			}
			if (beams != null && IsFiring != beams.activeInHierarchy)
			{
				beams.SetActive(IsFiring);
			}
		}

		public void OnTriggerEnter(Collider other)
		{
			if (base.photonView.IsMine && other.name.Contains("Beam"))
			{
				Health -= 0.1f;
			}
		}

		public void OnTriggerStay(Collider other)
		{
			if (base.photonView.IsMine && other.name.Contains("Beam"))
			{
				Health -= 0.1f * Time.deltaTime;
			}
		}

		private void CalledOnLevelWasLoaded(int level)
		{
			if (!Physics.Raycast(base.transform.position, -Vector3.up, 5f))
			{
				base.transform.position = new Vector3(0f, 5f, 0f);
			}
			UnityEngine.Object.Instantiate(playerUiPrefab).SendMessage("SetTarget", this, SendMessageOptions.RequireReceiver);
		}

		private void OnSceneLoaded(Scene scene, LoadSceneMode loadingMode)
		{
			CalledOnLevelWasLoaded(scene.buildIndex);
		}

		private void ProcessInputs()
		{
			if (Input.GetButtonDown("Fire1"))
			{
				EventSystem.current.IsPointerOverGameObject();
				if (!IsFiring)
				{
					IsFiring = true;
				}
			}
			if (Input.GetButtonUp("Fire1") && IsFiring)
			{
				IsFiring = false;
			}
		}

		public void OnPhotonSerializeView(PhotonStream stream, PhotonMessageInfo info)
		{
			if (stream.IsWriting)
			{
				stream.SendNext(IsFiring);
				stream.SendNext(Health);
			}
			else
			{
				IsFiring = (bool)stream.ReceiveNext();
				Health = (float)stream.ReceiveNext();
			}
		}
	}
	[RequireComponent(typeof(InputField))]
	public class PlayerNameInputField : MonoBehaviour
	{
		private const string playerNamePrefKey = "PlayerName";

		private void Start()
		{
			string nickName = string.Empty;
			InputField component = GetComponent<InputField>();
			if (component != null && PlayerPrefs.HasKey("PlayerName"))
			{
				nickName = (component.text = PlayerPrefs.GetString("PlayerName"));
			}
			PhotonNetwork.NickName = nickName;
		}

		public void SetPlayerName(string value)
		{
			if (string.IsNullOrEmpty(value))
			{
				UnityEngine.Debug.LogError("Player Name is null or empty");
				return;
			}
			PhotonNetwork.NickName = value;
			PlayerPrefs.SetString("PlayerName", value);
		}
	}
	public class PlayerUI : MonoBehaviour
	{
		[Tooltip("Pixel offset from the player target")]
		[SerializeField]
		private Vector3 screenOffset = new Vector3(0f, 30f, 0f);

		[Tooltip("UI Text to display Player's Name")]
		[SerializeField]
		private Text playerNameText;

		[Tooltip("UI Slider to display Player's Health")]
		[SerializeField]
		private Slider playerHealthSlider;

		private PlayerManager target;

		private float characterControllerHeight;

		private Transform targetTransform;

		private Renderer targetRenderer;

		private Vector3 targetPosition;

		private void Awake()
		{
			base.transform.SetParent(GameObject.Find("Canvas").GetComponent<Transform>(), worldPositionStays: false);
		}

		private void Update()
		{
			if (target == null)
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
			else if (playerHealthSlider != null)
			{
				playerHealthSlider.value = target.Health;
			}
		}

		private void LateUpdate()
		{
			if (targetRenderer != null)
			{
				base.gameObject.SetActive(targetRenderer.isVisible);
			}
			if (targetTransform != null)
			{
				targetPosition = targetTransform.position;
				targetPosition.y += characterControllerHeight;
				base.transform.position = Camera.main.WorldToScreenPoint(targetPosition) + screenOffset;
			}
		}

		public void SetTarget(PlayerManager _target)
		{
			if (_target == null)
			{
				UnityEngine.Debug.LogError("<Color=Red><b>Missing</b></Color> PlayMakerManager target for PlayerUI.SetTarget.", this);
				return;
			}
			target = _target;
			targetTransform = target.GetComponent<Transform>();
			targetRenderer = target.GetComponent<Renderer>();
			CharacterController component = target.GetComponent<CharacterController>();
			if (component != null)
			{
				characterControllerHeight = component.height;
			}
			if (playerNameText != null)
			{
				playerNameText.text = target.photonView.Owner.NickName;
			}
		}
	}
}
namespace Photon.Pun.Demo.SlotRacer
{
	[RequireComponent(typeof(SplineWalker))]
	public class PlayerControl : MonoBehaviourPun, IPunObservable
	{
		public GameObject[] CarPrefabs;

		public float MaximumSpeed = 20f;

		public float Drag = 5f;

		private float CurrentSpeed;

		private float CurrentDistance;

		private GameObject CarInstance;

		private SplineWalker SplineWalker;

		private bool m_firstTake = true;

		private float m_input;

		void IPunObservable.OnPhotonSerializeView(PhotonStream stream, PhotonMessageInfo info)
		{
			if (stream.IsWriting)
			{
				stream.SendNext(CurrentDistance);
				stream.SendNext(CurrentSpeed);
				stream.SendNext(m_input);
				return;
			}
			if (m_firstTake)
			{
				m_firstTake = false;
			}
			CurrentDistance = (float)stream.ReceiveNext();
			CurrentSpeed = (float)stream.ReceiveNext();
			m_input = (float)stream.ReceiveNext();
		}

		private void SetupCarOnTrack(int gridStartIndex)
		{
			SplineWalker.spline = SlotLanes.Instance.GridPositions[gridStartIndex].Spline;
			SplineWalker.currentDistance = SlotLanes.Instance.GridPositions[gridStartIndex].currentDistance;
			SplineWalker.ExecutePositioning();
			CarInstance = UnityEngine.Object.Instantiate(CarPrefabs[gridStartIndex], base.transform.position, base.transform.rotation);
			if (!base.photonView.IsMine)
			{
				CarInstance.SetActive(value: false);
			}
			if (PhotonNetwork.CurrentRoom.PlayerCount == 1)
			{
				m_firstTake = false;
			}
			CarInstance.transform.SetParent(base.transform);
		}

		private void Awake()
		{
			SplineWalker = GetComponent<SplineWalker>();
			m_firstTake = true;
		}

		private IEnumerator Start()
		{
			yield return new WaitUntil(() => base.photonView.Owner.GetPlayerNumber() >= 0);
			SetupCarOnTrack(base.photonView.Owner.GetPlayerNumber());
		}

		private void OnDestroy()
		{
			UnityEngine.Object.Destroy(CarInstance);
		}

		private void Update()
		{
			if (SplineWalker == null || CarInstance == null)
			{
				return;
			}
			if (base.photonView.IsMine)
			{
				m_input = Input.GetAxis("Vertical");
				if (m_input == 0f)
				{
					CurrentSpeed -= Time.deltaTime * Drag;
				}
				else
				{
					CurrentSpeed += m_input;
				}
				CurrentSpeed = Mathf.Clamp(CurrentSpeed, 0f, MaximumSpeed);
				SplineWalker.Speed = CurrentSpeed;
				CurrentDistance = SplineWalker.currentDistance;
			}
			else
			{
				if (m_input == 0f)
				{
					CurrentSpeed -= Time.deltaTime * Drag;
				}
				CurrentSpeed = Mathf.Clamp(CurrentSpeed, 0f, MaximumSpeed);
				SplineWalker.Speed = CurrentSpeed;
				if (CurrentDistance != 0f && SplineWalker.currentDistance != CurrentDistance)
				{
					SplineWalker.Speed += (CurrentDistance - SplineWalker.currentDistance) * Time.deltaTime * 50f;
				}
			}
			if (!m_firstTake && !CarInstance.activeSelf)
			{
				CarInstance.SetActive(value: true);
				SplineWalker.Speed = CurrentSpeed;
				SplineWalker.SetPositionOnSpline(CurrentDistance);
			}
		}
	}
	public class SlotLanes : MonoBehaviour
	{
		public static SlotLanes Instance;

		public SplinePosition[] GridPositions;

		private void Awake()
		{
			Instance = this;
		}
	}
	[ExecuteInEditMode]
	public class SlotRacerSplashScreen : MonoBehaviour
	{
		private string PunCockpit_scene = "PunCockpit-Scene";

		public Text WarningText;

		public GameObject SplashScreen;

		private void Start()
		{
			if (Application.isPlaying)
			{
				UnityEngine.Object.Destroy(SplashScreen);
				UnityEngine.Object.Destroy(this);
			}
		}

		public void Update()
		{
		}
	}
}
namespace Photon.Pun.Demo.SlotRacer.Utils
{
	public static class Bezier
	{
		public static Vector3 GetPoint(Vector3 p0, Vector3 p1, Vector3 p2, float t)
		{
			t = Mathf.Clamp01(t);
			float num = 1f - t;
			return num * num * p0 + 2f * num * t * p1 + t * t * p2;
		}

		public static Vector3 GetFirstDerivative(Vector3 p0, Vector3 p1, Vector3 p2, float t)
		{
			return 2f * (1f - t) * (p1 - p0) + 2f * t * (p2 - p1);
		}

		public static Vector3 GetPoint(Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3, float t)
		{
			t = Mathf.Clamp01(t);
			float num = 1f - t;
			return num * num * num * p0 + 3f * num * num * t * p1 + 3f * num * t * t * p2 + t * t * t * p3;
		}

		public static Vector3 GetFirstDerivative(Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3, float t)
		{
			t = Mathf.Clamp01(t);
			float num = 1f - t;
			return 3f * num * num * (p1 - p0) + 6f * num * t * (p2 - p1) + 3f * t * t * (p3 - p2);
		}
	}
	public enum BezierControlPointMode
	{
		Free,
		Aligned,
		Mirrored
	}
	public class BezierCurve : MonoBehaviour
	{
		public Vector3[] points;

		public Vector3 GetPoint(float t)
		{
			return base.transform.TransformPoint(Bezier.GetPoint(points[0], points[1], points[2], points[3], t));
		}

		public Vector3 GetVelocity(float t)
		{
			return base.transform.TransformPoint(Bezier.GetFirstDerivative(points[0], points[1], points[2], points[3], t)) - base.transform.position;
		}

		public Vector3 GetDirection(float t)
		{
			return GetVelocity(t).normalized;
		}

		public void Reset()
		{
			points = new Vector3[4]
			{
				new Vector3(1f, 0f, 0f),
				new Vector3(2f, 0f, 0f),
				new Vector3(3f, 0f, 0f),
				new Vector3(4f, 0f, 0f)
			};
		}
	}
	public class BezierSpline : MonoBehaviour
	{
		[SerializeField]
		private Vector3[] points;

		[SerializeField]
		private float[] lengths;

		[SerializeField]
		private float[] lengthsTime;

		public float TotalLength;

		[SerializeField]
		private BezierControlPointMode[] modes;

		[SerializeField]
		private bool loop;

		public bool Loop
		{
			get
			{
				return loop;
			}
			set
			{
				loop = value;
				if (value)
				{
					modes[modes.Length - 1] = modes[0];
					SetControlPoint(0, points[0]);
				}
			}
		}

		public int ControlPointCount => points.Length;

		public int CurveCount => (points.Length - 1) / 3;

		private void Awake()
		{
			ComputeLengths();
		}

		public Vector3 GetControlPoint(int index)
		{
			return points[index];
		}

		public void SetControlPoint(int index, Vector3 point)
		{
			if (index % 3 == 0)
			{
				Vector3 vector = point - points[index];
				if (loop)
				{
					if (index == 0)
					{
						points[1] += vector;
						points[points.Length - 2] += vector;
						points[points.Length - 1] = point;
					}
					else if (index == points.Length - 1)
					{
						points[0] = point;
						points[1] += vector;
						points[index - 1] += vector;
					}
					else
					{
						points[index - 1] += vector;
						points[index + 1] += vector;
					}
				}
				else
				{
					if (index > 0)
					{
						points[index - 1] += vector;
					}
					if (index + 1 < points.Length)
					{
						points[index + 1] += vector;
					}
				}
			}
			points[index] = point;
			EnforceMode(index);
		}

		public BezierControlPointMode GetControlPointMode(int index)
		{
			return modes[(index + 1) / 3];
		}

		public void SetControlPointMode(int index, BezierControlPointMode mode)
		{
			int num = (index + 1) / 3;
			modes[num] = mode;
			if (loop)
			{
				if (num == 0)
				{
					modes[modes.Length - 1] = mode;
				}
				else if (num == modes.Length - 1)
				{
					modes[0] = mode;
				}
			}
			EnforceMode(index);
		}

		private void EnforceMode(int index)
		{
			int num = (index + 1) / 3;
			BezierControlPointMode bezierControlPointMode = modes[num];
			if (bezierControlPointMode == BezierControlPointMode.Free || (!loop && (num == 0 || num == modes.Length - 1)))
			{
				return;
			}
			int num2 = num * 3;
			int num3;
			int num4;
			if (index <= num2)
			{
				num3 = num2 - 1;
				if (num3 < 0)
				{
					num3 = points.Length - 2;
				}
				num4 = num2 + 1;
				if (num4 >= points.Length)
				{
					num4 = 1;
				}
			}
			else
			{
				num3 = num2 + 1;
				if (num3 >= points.Length)
				{
					num3 = 1;
				}
				num4 = num2 - 1;
				if (num4 < 0)
				{
					num4 = points.Length - 2;
				}
			}
			Vector3 vector = points[num2];
			Vector3 vector2 = vector - points[num3];
			if (bezierControlPointMode == BezierControlPointMode.Aligned)
			{
				vector2 = vector2.normalized * Vector3.Distance(vector, points[num4]);
			}
			points[num4] = vector + vector2;
		}

		public Vector3 GetPoint(float t)
		{
			int num;
			if (t >= 1f)
			{
				t = 1f;
				num = points.Length - 4;
			}
			else
			{
				t = Mathf.Clamp01(t) * (float)CurveCount;
				num = (int)t;
				t -= (float)num;
				num *= 3;
			}
			return base.transform.TransformPoint(Bezier.GetPoint(points[num], points[num + 1], points[num + 2], points[num + 3], t));
		}

		public Vector3 GetVelocity(float t)
		{
			int num;
			if (t >= 1f)
			{
				t = 1f;
				num = points.Length - 4;
			}
			else
			{
				t = Mathf.Clamp01(t) * (float)CurveCount;
				num = (int)t;
				t -= (float)num;
				num *= 3;
			}
			return base.transform.TransformPoint(Bezier.GetFirstDerivative(points[num], points[num + 1], points[num + 2], points[num + 3], t)) - base.transform.position;
		}

		public Vector3 GetDirection(float t)
		{
			return GetVelocity(t).normalized;
		}

		public void AddCurve()
		{
			Vector3 vector = points[points.Length - 1];
			Array.Resize(ref points, points.Length + 3);
			vector.x += 1f;
			points[points.Length - 3] = vector;
			vector.x += 1f;
			points[points.Length - 2] = vector;
			vector.x += 1f;
			points[points.Length - 1] = vector;
			Array.Resize(ref modes, modes.Length + 1);
			modes[modes.Length - 1] = modes[modes.Length - 2];
			EnforceMode(points.Length - 4);
			if (loop)
			{
				points[points.Length - 1] = points[0];
				modes[modes.Length - 1] = modes[0];
				EnforceMode(0);
			}
		}

		public void Reset()
		{
			points = new Vector3[4]
			{
				new Vector3(1f, 0f, 0f),
				new Vector3(2f, 0f, 0f),
				new Vector3(3f, 0f, 0f),
				new Vector3(4f, 0f, 0f)
			};
			modes = new BezierControlPointMode[2];
		}

		public void ComputeLengths()
		{
			int num = 100;
			int num2 = points.Length * num;
			lengths = new float[num2];
			lengthsTime = new float[num2];
			float num3 = 0f;
			float num4 = 0f;
			Vector3 vector = GetPoint(0f);
			for (int i = 0; i < num2 - 1; i++)
			{
				num4 = 1f * (float)i / (float)num2;
				Vector3 point = GetPoint(num4);
				float magnitude = (point - vector).magnitude;
				num3 += magnitude;
				lengths[i] = num3;
				lengthsTime[i] = num4;
				vector = point;
			}
			TotalLength = num3;
		}

		public Vector3 GetPositionAtDistance(float distance, bool reverse = false)
		{
			if (reverse)
			{
				distance = TotalLength - distance;
			}
			distance = Mathf.Repeat(distance, TotalLength);
			if (distance <= 0f)
			{
				return points[0];
			}
			if (distance >= TotalLength)
			{
				return points[points.Length - 1];
			}
			int i;
			for (i = 0; i < lengths.Length - 1 && lengths[i] < distance; i++)
			{
			}
			float num = (distance - lengths[i - 1]) / (lengths[i] - lengths[i - 1]);
			float num2 = (lengthsTime[i] - lengthsTime[i - 1]) * num;
			return GetPoint(lengthsTime[i] + num2);
		}
	}
	public class Line : MonoBehaviour
	{
		public Vector3 p0;

		public Vector3 p1;
	}
	[ExecuteInEditMode]
	public class SplinePosition : MonoBehaviour
	{
		public BezierSpline Spline;

		public bool reverse;

		public bool lookForward;

		public float currentDistance;

		public float currentClampedDistance;

		private float LastDistance;

		public void SetPositionOnSpline(float position)
		{
			currentDistance = position;
			ExecutePositioning();
		}

		private void Update()
		{
			ExecutePositioning();
		}

		private void ExecutePositioning()
		{
			if (!(Spline == null) && LastDistance != currentDistance)
			{
				LastDistance = currentDistance;
				base.transform.position = Spline.GetPositionAtDistance(currentDistance, reverse);
				if (lookForward)
				{
					base.transform.LookAt(Spline.GetPositionAtDistance(currentDistance + 1f, reverse));
				}
			}
		}
	}
	[ExecuteInEditMode]
	public class SplineWalker : MonoBehaviour
	{
		public BezierSpline spline;

		public float Speed;

		public bool lookForward;

		public bool reverse;

		private float progress;

		public float currentDistance;

		public float currentClampedDistance;

		public void SetPositionOnSpline(float position)
		{
			currentDistance = position;
			ExecutePositioning();
		}

		private void Update()
		{
			currentDistance += Speed * Time.deltaTime;
			ExecutePositioning();
		}

		public void ExecutePositioning()
		{
			if (!(spline == null))
			{
				base.transform.position = spline.GetPositionAtDistance(currentDistance, reverse);
				currentDistance += Speed * Time.deltaTime;
				if (lookForward)
				{
					base.transform.LookAt(spline.GetPositionAtDistance(currentDistance + 1f, reverse));
				}
			}
		}
	}
}
namespace Photon.Pun.Demo.Procedural
{
	public class Block : MonoBehaviour
	{
		public int BlockId { get; set; }

		public int ClusterId { get; set; }
	}
	public class Cluster : MonoBehaviourPunCallbacks
	{
		private string propertiesKey;

		private Dictionary<int, float> propertiesValue;

		public int ClusterId { get; set; }

		public Dictionary<int, GameObject> Blocks { get; private set; }

		public void Awake()
		{
			Blocks = new Dictionary<int, GameObject>();
			propertiesValue = new Dictionary<int, float>();
		}

		private void Start()
		{
			propertiesKey = "Cluster " + ClusterId;
		}

		public void AddBlock(int blockId, GameObject block)
		{
			Blocks.Add(blockId, block);
		}

		public void DestroyCluster()
		{
			foreach (GameObject value in Blocks.Values)
			{
				UnityEngine.Object.Destroy(value);
			}
			Blocks.Clear();
			if (PhotonNetwork.IsMasterClient)
			{
				RemoveClusterFromRoomProperties();
			}
		}

		public void DecreaseBlockHeight(int blockId)
		{
			float y = Blocks[blockId].transform.localScale.y;
			y = Mathf.Max(y - 1f, 0f);
			SetBlockHeightLocal(blockId, y);
		}

		public void IncreaseBlockHeight(int blockId)
		{
			float y = Blocks[blockId].transform.localScale.y;
			y = Mathf.Min(y + 1f, 8f);
			SetBlockHeightLocal(blockId, y);
		}

		public void SetBlockHeightRemote(int blockId, float height)
		{
			GameObject obj = Blocks[blockId];
			Vector3 localScale = obj.transform.localScale;
			Vector3 localPosition = obj.transform.localPosition;
			obj.transform.localScale = new Vector3(localScale.x, height, localScale.z);
			obj.transform.localPosition = new Vector3(localPosition.x, height / 2f, localPosition.z);
		}

		private void SetBlockHeightLocal(int blockId, float height)
		{
			GameObject obj = Blocks[blockId];
			Vector3 localScale = obj.transform.localScale;
			Vector3 localPosition = obj.transform.localPosition;
			obj.transform.localScale = new Vector3(localScale.x, height, localScale.z);
			obj.transform.localPosition = new Vector3(localPosition.x, height / 2f, localPosition.z);
			UpdateRoomProperties(blockId, height);
		}

		private void UpdateRoomProperties(int blockId, float height)
		{
			propertiesValue[blockId] = height;
			ExitGames.Client.Photon.Hashtable propertiesToSet = new ExitGames.Client.Photon.Hashtable { { propertiesKey, propertiesValue } };
			PhotonNetwork.CurrentRoom.SetCustomProperties(propertiesToSet);
		}

		private void RemoveClusterFromRoomProperties()
		{
			ExitGames.Client.Photon.Hashtable propertiesToSet = new ExitGames.Client.Photon.Hashtable { { propertiesKey, null } };
			PhotonNetwork.CurrentRoom.SetCustomProperties(propertiesToSet);
		}

		public override void OnRoomPropertiesUpdate(ExitGames.Client.Photon.Hashtable propertiesThatChanged)
		{
			if (!propertiesThatChanged.ContainsKey(propertiesKey))
			{
				return;
			}
			if (propertiesThatChanged[propertiesKey] == null)
			{
				propertiesValue = new Dictionary<int, float>();
				return;
			}
			propertiesValue = (Dictionary<int, float>)propertiesThatChanged[propertiesKey];
			foreach (KeyValuePair<int, float> item in propertiesValue)
			{
				SetBlockHeightRemote(item.Key, item.Value);
			}
		}
	}
	public class IngameControlPanel : MonoBehaviourPunCallbacks
	{
		private bool isSeedValid;

		private InputField seedInputField;

		private Dropdown worldSizeDropdown;

		private Dropdown clusterSizeDropdown;

		private Dropdown worldTypeDropdown;

		private Button generateWorldButton;

		public void Awake()
		{
			isSeedValid = false;
			seedInputField = GetComponentInChildren<InputField>();
			seedInputField.characterLimit = 10;
			seedInputField.characterValidation = InputField.CharacterValidation.Integer;
			seedInputField.interactable = PhotonNetwork.PhotonServerSettings.StartInOfflineMode;
			seedInputField.onValueChanged.AddListener(delegate(string value)
			{
				if (int.TryParse(value, out var result))
				{
					isSeedValid = true;
					WorldGenerator.Instance.Seed = result;
				}
				else
				{
					isSeedValid = false;
					UnityEngine.Debug.LogError("Invalid Seed entered. Only numeric Seeds are allowed.");
				}
			});
			worldSizeDropdown = GetComponentsInChildren<Dropdown>()[0];
			worldSizeDropdown.interactable = PhotonNetwork.PhotonServerSettings.StartInOfflineMode;
			worldSizeDropdown.onValueChanged.AddListener(delegate(int value)
			{
				switch (value)
				{
				case 0:
					WorldGenerator.Instance.WorldSize = WorldSize.Tiny;
					break;
				case 1:
					WorldGenerator.Instance.WorldSize = WorldSize.Small;
					break;
				case 2:
					WorldGenerator.Instance.WorldSize = WorldSize.Medium;
					break;
				case 3:
					WorldGenerator.Instance.WorldSize = WorldSize.Large;
					break;
				}
			});
			clusterSizeDropdown = GetComponentsInChildren<Dropdown>()[1];
			clusterSizeDropdown.interactable = PhotonNetwork.PhotonServerSettings.StartInOfflineMode;
			clusterSizeDropdown.onValueChanged.AddListener(delegate(int value)
			{
				switch (value)
				{
				case 0:
					WorldGenerator.Instance.ClusterSize = ClusterSize.Small;
					break;
				case 1:
					WorldGenerator.Instance.ClusterSize = ClusterSize.Medium;
					break;
				case 2:
					WorldGenerator.Instance.ClusterSize = ClusterSize.Large;
					break;
				}
			});
			worldTypeDropdown = GetComponentsInChildren<Dropdown>()[2];
			worldTypeDropdown.interactable = PhotonNetwork.PhotonServerSettings.StartInOfflineMode;
			worldTypeDropdown.onValueChanged.AddListener(delegate(int value)
			{
				switch (value)
				{
				case 0:
					WorldGenerator.Instance.WorldType = WorldType.Flat;
					break;
				case 1:
					WorldGenerator.Instance.WorldType = WorldType.Standard;
					break;
				case 2:
					WorldGenerator.Instance.WorldType = WorldType.Mountain;
					break;
				}
			});
			generateWorldButton = GetComponentInChildren<Button>();
			generateWorldButton.interactable = PhotonNetwork.PhotonServerSettings.StartInOfflineMode;
			generateWorldButton.onClick.AddListener(delegate
			{
				if (!PhotonNetwork.InRoom)
				{
					UnityEngine.Debug.LogError("Client is not in a room.");
				}
				else if (!isSeedValid)
				{
					UnityEngine.Debug.LogError("Invalid Seed entered. Only numeric Seeds are allowed.");
				}
				else
				{
					WorldGenerator.Instance.ConfirmAndUpdateProperties();
				}
			});
		}

		public override void OnJoinedRoom()
		{
			seedInputField.interactable = PhotonNetwork.IsMasterClient;
			worldSizeDropdown.interactable = PhotonNetwork.IsMasterClient;
			clusterSizeDropdown.interactable = PhotonNetwork.IsMasterClient;
			worldTypeDropdown.interactable = PhotonNetwork.IsMasterClient;
			generateWorldButton.interactable = PhotonNetwork.IsMasterClient;
		}

		public override void OnMasterClientSwitched(Player newMasterClient)
		{
			seedInputField.interactable = newMasterClient.IsLocal;
			worldSizeDropdown.interactable = newMasterClient.IsLocal;
			clusterSizeDropdown.interactable = newMasterClient.IsLocal;
			worldTypeDropdown.interactable = newMasterClient.IsLocal;
			generateWorldButton.interactable = newMasterClient.IsLocal;
		}

		public override void OnRoomPropertiesUpdate(ExitGames.Client.Photon.Hashtable propertiesThatChanged)
		{
			if (propertiesThatChanged.ContainsKey(WorldGenerator.Instance.SeedPropertiesKey) && propertiesThatChanged.ContainsKey(WorldGenerator.Instance.WorldSizePropertiesKey) && propertiesThatChanged.ContainsKey(WorldGenerator.Instance.ClusterSizePropertiesKey) && propertiesThatChanged.ContainsKey(WorldGenerator.Instance.WorldTypePropertiesKey))
			{
				int num = (int)propertiesThatChanged[WorldGenerator.Instance.SeedPropertiesKey];
				seedInputField.text = num.ToString();
				switch ((WorldSize)propertiesThatChanged[WorldGenerator.Instance.WorldSizePropertiesKey])
				{
				case WorldSize.Tiny:
					worldSizeDropdown.value = 0;
					break;
				case WorldSize.Small:
					worldSizeDropdown.value = 1;
					break;
				case WorldSize.Medium:
					worldSizeDropdown.value = 2;
					break;
				case WorldSize.Large:
					worldSizeDropdown.value = 3;
					break;
				}
				switch ((ClusterSize)propertiesThatChanged[WorldGenerator.Instance.ClusterSizePropertiesKey])
				{
				case ClusterSize.Small:
					clusterSizeDropdown.value = 0;
					break;
				case ClusterSize.Medium:
					clusterSizeDropdown.value = 1;
					break;
				case ClusterSize.Large:
					clusterSizeDropdown.value = 2;
					break;
				}
				switch ((WorldType)propertiesThatChanged[WorldGenerator.Instance.WorldTypePropertiesKey])
				{
				case WorldType.Flat:
					worldTypeDropdown.value = 0;
					break;
				case WorldType.Standard:
					worldTypeDropdown.value = 1;
					break;
				case WorldType.Mountain:
					worldTypeDropdown.value = 2;
					break;
				}
				WorldGenerator.Instance.CreateWorld();
			}
		}
	}
	public class ProceduralController : MonoBehaviour
	{
		private Camera cam;

		public void Awake()
		{
			cam = Camera.main;
		}

		public void Update()
		{
			float axisRaw = Input.GetAxisRaw("Horizontal");
			float axisRaw2 = Input.GetAxisRaw("Vertical");
			if (axisRaw >= 0.1f)
			{
				cam.transform.position += Vector3.right * 10f * Time.deltaTime;
			}
			else if (axisRaw <= -0.1f)
			{
				cam.transform.position += Vector3.left * 10f * Time.deltaTime;
			}
			if (axisRaw2 >= 0.1f)
			{
				cam.transform.position += Vector3.forward * 10f * Time.deltaTime;
			}
			else if (axisRaw2 <= -0.1f)
			{
				cam.transform.position += Vector3.back * 10f * Time.deltaTime;
			}
			if (Input.GetKey(KeyCode.Q))
			{
				cam.transform.position += Vector3.up * 10f * Time.deltaTime;
			}
			else if (Input.GetKey(KeyCode.E))
			{
				cam.transform.position += Vector3.down * 10f * Time.deltaTime;
			}
			if ((!Input.GetMouseButtonDown(0) && !Input.GetMouseButtonDown(1)) || !Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out var hitInfo, 100f))
			{
				return;
			}
			Block component = hitInfo.transform.GetComponent<Block>();
			if (component != null)
			{
				if (Input.GetMouseButtonDown(0))
				{
					WorldGenerator.Instance.DecreaseBlockHeight(component.ClusterId, component.BlockId);
				}
				else if (Input.GetMouseButtonDown(1))
				{
					WorldGenerator.Instance.IncreaseBlockHeight(component.ClusterId, component.BlockId);
				}
			}
		}
	}
	public enum WorldSize
	{
		Tiny = 0x10,
		Small = 0x20,
		Medium = 0x40,
		Large = 0x80
	}
	public enum WorldType
	{
		Flat = 4,
		Standard = 8,
		Mountain = 0x10
	}
	public enum ClusterSize
	{
		Small = 4,
		Medium = 0x10,
		Large = 0x40
	}
	public class WorldGenerator : MonoBehaviour
	{
		public readonly string SeedPropertiesKey = "Seed";

		public readonly string WorldSizePropertiesKey = "WorldSize";

		public readonly string ClusterSizePropertiesKey = "ClusterSize";

		public readonly string WorldTypePropertiesKey = "WorldType";

		private static WorldGenerator instance;

		private Dictionary<int, GameObject> clusterList;

		public Material[] WorldMaterials;

		public static WorldGenerator Instance
		{
			get
			{
				if (instance == null)
				{
					instance = UnityEngine.Object.FindObjectOfType<WorldGenerator>();
				}
				return instance;
			}
		}

		public int Seed { get; set; }

		public WorldSize WorldSize { get; set; }

		public ClusterSize ClusterSize { get; set; }

		public WorldType WorldType { get; set; }

		public void Awake()
		{
			clusterList = new Dictionary<int, GameObject>();
			WorldSize = WorldSize.Tiny;
			ClusterSize = ClusterSize.Small;
			WorldType = WorldType.Standard;
		}

		public void CreateWorld()
		{
			StopAllCoroutines();
			DestroyWorld();
			StartCoroutine(GenerateWorld());
		}

		private void DestroyWorld()
		{
			foreach (GameObject value in clusterList.Values)
			{
				value.GetComponent<Cluster>().DestroyCluster();
				UnityEngine.Object.Destroy(value);
			}
			clusterList.Clear();
		}

		public void ConfirmAndUpdateProperties()
		{
			if (PhotonNetwork.IsMasterClient)
			{
				ExitGames.Client.Photon.Hashtable propertiesToSet = new ExitGames.Client.Photon.Hashtable
				{
					{ SeedPropertiesKey, Seed },
					{
						WorldSizePropertiesKey,
						(int)WorldSize
					},
					{
						ClusterSizePropertiesKey,
						(int)ClusterSize
					},
					{
						WorldTypePropertiesKey,
						(int)WorldType
					}
				};
				PhotonNetwork.CurrentRoom.SetCustomProperties(propertiesToSet);
			}
		}

		public void DecreaseBlockHeight(int clusterId, int blockId)
		{
			Cluster component = clusterList[clusterId].GetComponent<Cluster>();
			if (component != null)
			{
				component.DecreaseBlockHeight(blockId);
			}
		}

		public void IncreaseBlockHeight(int clusterId, int blockId)
		{
			Cluster component = clusterList[clusterId].GetComponent<Cluster>();
			if (component != null)
			{
				component.IncreaseBlockHeight(blockId);
			}
		}

		private IEnumerator GenerateWorld()
		{
			UnityEngine.Debug.Log($"<b>Procedural Demo</b>: Creating world using Seed: {Seed}, World Size: {WorldSize}, Cluster Size: {ClusterSize} and World Type: {WorldType}");
			Noise.Seed = Seed;
			int num = 0;
			for (int i = 0; i < (int)WorldSize; i += (int)Mathf.Sqrt((float)ClusterSize))
			{
				for (int j = 0; j < (int)WorldSize; j += (int)Mathf.Sqrt((float)ClusterSize))
				{
					GameObject gameObject = new GameObject();
					gameObject.name = "Cluster " + num;
					gameObject.transform.SetParent(base.transform);
					gameObject.transform.position = new Vector3(i, 0f, j);
					gameObject.AddComponent<Cluster>().ClusterId = num;
					clusterList.Add(num++, gameObject);
				}
			}
			yield return new WaitForEndOfFrame();
			foreach (GameObject value2 in clusterList.Values)
			{
				Vector3 position = value2.transform.position;
				int num2 = 0;
				for (int k = 0; k < (int)Mathf.Sqrt((float)ClusterSize); k++)
				{
					for (int l = 0; l < (int)Mathf.Sqrt((float)ClusterSize); l++)
					{
						float num3 = Noise.CalcPixel2D((int)position.x + k, (int)position.z + l, 0.02f);
						int num4 = (int)num3 / (int)(256f / (float)WorldType);
						int num5 = (int)num3 / (int)(256f / (float)WorldMaterials.Length);
						GameObject gameObject2 = GameObject.CreatePrimitive(PrimitiveType.Cube);
						gameObject2.name = "Block " + num2;
						gameObject2.transform.SetParent(value2.transform);
						gameObject2.transform.localScale = new Vector3(1f, num4, 1f);
						gameObject2.transform.position = new Vector3(position.x + (float)k, (float)num4 / 2f, position.z + (float)l);
						gameObject2.GetComponent<MeshRenderer>().material = WorldMaterials[num5];
						Block block = gameObject2.AddComponent<Block>();
						block.BlockId = num2;
						block.ClusterId = value2.GetComponent<Cluster>().ClusterId;
						value2.GetComponent<Cluster>().AddBlock(num2++, gameObject2);
					}
				}
				yield return new WaitForEndOfFrame();
			}
			foreach (DictionaryEntry customProperty in PhotonNetwork.CurrentRoom.CustomProperties)
			{
				if (customProperty.Value == null)
				{
					continue;
				}
				string text = customProperty.Key.ToString();
				if (text == SeedPropertiesKey || text == WorldSizePropertiesKey || text == ClusterSizePropertiesKey || text == WorldTypePropertiesKey)
				{
					continue;
				}
				int num6 = text.IndexOf(' ');
				text = text.Substring(num6 + 1, text.Length - (num6 + 1));
				int.TryParse(text, out num);
				if (!clusterList.TryGetValue(num, out var value))
				{
					continue;
				}
				Cluster component = value.GetComponent<Cluster>();
				if (!(component != null))
				{
					continue;
				}
				foreach (KeyValuePair<int, float> item in (Dictionary<int, float>)customProperty.Value)
				{
					component.SetBlockHeightRemote(item.Key, item.Value);
				}
			}
		}
	}
}
namespace Photon.Pun.Demo.Hub
{
	public class DemoHubManager : MonoBehaviour
	{
		private struct DemoData
		{
			public string Title;

			public string Description;

			public string Scene;

			public string TutorialLink;

			public string DocLink;
		}

		public Text TitleText;

		public Text DescriptionText;

		public GameObject OpenSceneButton;

		public GameObject OpenTutorialLinkButton;

		public GameObject OpenDocLinkButton;

		private string MainDemoWebLink = "https://doc.photonengine.com/en-us/pun/v2/getting-started/pun-intro";

		private Dictionary<string, DemoData> _data = new Dictionary<string, DemoData>();

		private string currentSelection;

		private void Awake()
		{
			PunCockpit.Embedded = false;
			OpenSceneButton.SetActive(value: false);
			OpenTutorialLinkButton.SetActive(value: false);
			OpenDocLinkButton.SetActive(value: false);
			_data.Add("DemoBoxes", new DemoData
			{
				Title = "Demo Boxes",
				Description = "Uses ConnectAndJoinRandom script.\n(joins a random room or creates one)\n\nInstantiates simple prefabs.\nSynchronizes positions without smoothing.\nShows that RPCs target a specific object.",
				Scene = "DemoBoxes-Scene"
			});
			_data.Add("DemoWorker", new DemoData
			{
				Title = "Demo Worker",
				Description = "Joins the default lobby and shows existing rooms.\nLets you create or join a room.\nInstantiates an animated character.\nSynchronizes position and animation state of character with smoothing.\nImplements simple in-room Chat via RPC calls.",
				Scene = "DemoWorker-Scene"
			});
			_data.Add("MovementSmoothing", new DemoData
			{
				Title = "Movement Smoothing",
				Description = "Uses ConnectAndJoinRandom script.\nShows several basic ways to synchronize positions between controlling client and remote ones.\nThe TransformView is a good default to use.",
				Scene = "DemoSynchronization-Scene"
			});
			_data.Add("BasicTutorial", new DemoData
			{
				Title = "Basic Tutorial",
				Description = "All custom code for connection, player and scene management.\nAuto synchronization of room levels.\nUses PhotonAnimatoView for Animator synch.\nNew Unity UI all around, for Menus and player health HUD.\nFull step by step tutorial available online.",
				Scene = "PunBasics-Launcher",
				TutorialLink = "https://doc.photonengine.com/en-us/pun/v2/demos-and-tutorials/pun-basics-tutorial/intro"
			});
			_data.Add("OwnershipTransfer", new DemoData
			{
				Title = "Ownership Transfer",
				Description = "Shows how to transfer the ownership of a PhotonView.\nThe owner will send position updates of the GameObject.\nTransfer can be edited per PhotonView and set to Fixed (no transfer), Request (owner has to agree) or Takeover (owner can't object).",
				Scene = "DemoChangeOwner-Scene"
			});
			_data.Add("PickupTeamsScores", new DemoData
			{
				Title = "Pickup, Teams, Scores",
				Description = "Uses ConnectAndJoinRandom script.\nImplements item pickup with RPCs.\nUses Custom Properties for Teams.\nCounts score per player and team.\nUses Player extension methods for easy Custom Property access.",
				Scene = "DemoPickup-Scene"
			});
			_data.Add("Chat", new DemoData
			{
				Title = "Chat",
				Description = "Uses the Chat API.\nSimple UI.\nYou can enter any User ID.\nAutomatically subscribes some channels.\nAllows simple commands via text.\n\nRequires configuration of Chat App ID in ServerSettings.",
				Scene = "DemoChat-Scene",
				DocLink = "http://j.mp/2iwQkPJ"
			});
			_data.Add("RPGMovement", new DemoData
			{
				Title = "RPG Movement",
				Description = "Demonstrates how to use the PhotonTransformView component to synchronize position updates smoothly using inter- and extrapolation.\n\nThis demo also shows how to setup a Mecanim Animator to update animations automatically based on received position updates (without sending explicit animation updates).",
				Scene = "DemoRPGMovement-Scene"
			});
			_data.Add("MecanimAnimations", new DemoData
			{
				Title = "Mecanim Animations",
				Description = "This demo shows how to use the PhotonAnimatorView component to easily synchronize Mecanim animations.\n\nIt also demonstrates another feature of the PhotonTransformView component which gives you more control how position updates are inter-/extrapolated by telling the component how fast the object moves and turns using SetSynchronizedValues().",
				Scene = "DemoMecanim-Scene"
			});
			_data.Add("2DGame", new DemoData
			{
				Title = "2D Game Demo",
				Description = "Synchronizes animations, positions and physics in a 2D scene.",
				Scene = "Demo2DJumpAndRunWithPhysics-Scene"
			});
			_data.Add("FriendsAndAuth", new DemoData
			{
				Title = "Friends & Authentication",
				Description = "Shows connect with or without (server-side) authentication.\n\nAuthentication requires minor server-side setup (in Dashboard).\n\nOnce connected, you can find (made up) friends.\nJoin a room just to see how that gets visible in friends list.",
				Scene = "DemoFriends-Scene"
			});
			_data.Add("TurnBasedGame", new DemoData
			{
				Title = "'Rock Paper Scissor' Turn Based Game",
				Description = "Demonstrate TurnBased Game Mechanics using PUN.\n\nIt makes use of the TurnBasedManager Utility Script",
				Scene = "DemoRPS-Scene"
			});
			_data.Add("Asteroids", new DemoData
			{
				Title = "Asteroids",
				Description = "Simple asteroid game based on the Unity learning asset.\n",
				Scene = "DemoAsteroids-LobbyScene"
			});
			_data.Add("SlotRacer", new DemoData
			{
				Title = "Slot Racer",
				Description = "Simple SlotRacing game.\n",
				Scene = "SlotCar-Scene"
			});
			_data.Add("LoadBalancing", new DemoData
			{
				Title = "Load Balancing",
				Description = "Shows how to use the raw LoadBalancing system.\n\nThis is a simple test scene to connect and join a random room, without using PUN but the actual LoadBalancing api only",
				Scene = "DemoLoadBalancing-Scene"
			});
			_data.Add("PunCockpit", new DemoData
			{
				Title = "Cockpit",
				Description = "Controls most aspect of PUN.\nConnection, Lobby, Room access, Player control",
				Scene = "PunCockpit-Scene"
			});
		}

		public void SelectDemo(string Reference)
		{
			currentSelection = Reference;
			TitleText.text = _data[currentSelection].Title;
			DescriptionText.text = _data[currentSelection].Description;
			OpenSceneButton.SetActive(!string.IsNullOrEmpty(_data[currentSelection].Scene));
			OpenTutorialLinkButton.SetActive(!string.IsNullOrEmpty(_data[currentSelection].TutorialLink));
			OpenDocLinkButton.SetActive(!string.IsNullOrEmpty(_data[currentSelection].DocLink));
		}

		public void OpenScene()
		{
			if (string.IsNullOrEmpty(currentSelection))
			{
				UnityEngine.Debug.LogError("Bad setup, a CurrentSelection is expected at this point");
			}
			else
			{
				SceneManager.LoadScene(_data[currentSelection].Scene);
			}
		}

		public void OpenTutorialLink()
		{
			if (string.IsNullOrEmpty(currentSelection))
			{
				UnityEngine.Debug.LogError("Bad setup, a CurrentSelection is expected at this point");
			}
			else
			{
				Application.OpenURL(_data[currentSelection].TutorialLink);
			}
		}

		public void OpenDocLink()
		{
			if (string.IsNullOrEmpty(currentSelection))
			{
				UnityEngine.Debug.LogError("Bad setup, a CurrentSelection is expected at this point");
			}
			else
			{
				Application.OpenURL(_data[currentSelection].DocLink);
			}
		}

		public void OpenMainWebLink()
		{
			Application.OpenURL(MainDemoWebLink);
		}
	}
	public class ToDemoHubButton : MonoBehaviour
	{
		private static ToDemoHubButton instance;

		private CanvasGroup _canvasGroup;

		public static ToDemoHubButton Instance
		{
			get
			{
				if (instance == null)
				{
					instance = UnityEngine.Object.FindObjectOfType(typeof(ToDemoHubButton)) as ToDemoHubButton;
				}
				return instance;
			}
		}

		public void Awake()
		{
			if (Instance != null && Instance != this)
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}

		public void Start()
		{
			UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
			_canvasGroup = GetComponent<CanvasGroup>();
		}

		public void Update()
		{
			bool num = SceneManager.GetActiveScene().buildIndex == 0;
			if (num && _canvasGroup.alpha != 0f)
			{
				_canvasGroup.alpha = 0f;
				_canvasGroup.interactable = false;
			}
			if (!num && _canvasGroup.alpha != 1f)
			{
				_canvasGroup.alpha = 1f;
				_canvasGroup.interactable = true;
			}
		}

		public void BackToHub()
		{
			PhotonNetwork.Disconnect();
			SceneManager.LoadScene(0);
		}
	}
}
namespace Photon.Pun.Demo.Asteroids
{
	public class AsteroidsGame
	{
		public const float ASTEROIDS_MIN_SPAWN_TIME = 5f;

		public const float ASTEROIDS_MAX_SPAWN_TIME = 10f;

		public const float PLAYER_RESPAWN_TIME = 4f;

		public const int PLAYER_MAX_LIVES = 3;

		public const string PLAYER_LIVES = "PlayerLives";

		public const string PLAYER_READY = "IsPlayerReady";

		public const string PLAYER_LOADED_LEVEL = "PlayerLoadedLevel";

		public static Color GetColor(int colorChoice)
		{
			return colorChoice switch
			{
				0 => Color.red, 
				1 => Color.green, 
				2 => Color.blue, 
				3 => Color.yellow, 
				4 => Color.cyan, 
				5 => Color.grey, 
				6 => Color.magenta, 
				7 => Color.white, 
				_ => Color.black, 
			};
		}
	}
	public class Asteroid : MonoBehaviour
	{
		public bool isLargeAsteroid;

		private bool isDestroyed;

		private PhotonView photonView;

		private Rigidbody rigidbody;

		public void Awake()
		{
			photonView = GetComponent<PhotonView>();
			rigidbody = GetComponent<Rigidbody>();
			if (photonView.InstantiationData != null)
			{
				rigidbody.AddForce((Vector3)photonView.InstantiationData[0]);
				rigidbody.AddTorque((Vector3)photonView.InstantiationData[1]);
				isLargeAsteroid = (bool)photonView.InstantiationData[2];
			}
		}

		public void Update()
		{
			if (photonView.IsMine && (Mathf.Abs(base.transform.position.x) > Camera.main.orthographicSize * Camera.main.aspect || Mathf.Abs(base.transform.position.z) > Camera.main.orthographicSize))
			{
				PhotonNetwork.Destroy(base.gameObject);
			}
		}

		public void OnCollisionEnter(Collision collision)
		{
			if (isDestroyed)
			{
				return;
			}
			if (collision.gameObject.CompareTag("Bullet"))
			{
				if (photonView.IsMine)
				{
					collision.gameObject.GetComponent<Bullet>().Owner.AddScore((!isLargeAsteroid) ? 1 : 2);
					DestroyAsteroidGlobally();
				}
				else
				{
					DestroyAsteroidLocally();
				}
			}
			else if (collision.gameObject.CompareTag("Player") && photonView.IsMine)
			{
				collision.gameObject.GetComponent<PhotonView>().RPC("DestroySpaceship", RpcTarget.All);
				DestroyAsteroidGlobally();
			}
		}

		private void DestroyAsteroidGlobally()
		{
			isDestroyed = true;
			if (isLargeAsteroid)
			{
				int num = UnityEngine.Random.Range(3, 6);
				for (int i = 0; i < num; i++)
				{
					Vector3 vector = Quaternion.Euler(0f, (float)i * 360f / (float)num, 0f) * Vector3.forward * UnityEngine.Random.Range(0.5f, 1.5f) * 300f;
					Vector3 vector2 = UnityEngine.Random.insideUnitSphere * UnityEngine.Random.Range(500f, 1500f);
					object[] data = new object[4]
					{
						vector,
						vector2,
						false,
						PhotonNetwork.Time
					};
					PhotonNetwork.InstantiateSceneObject("SmallAsteroid", base.transform.position + vector.normalized * 10f, Quaternion.Euler(0f, UnityEngine.Random.value * 180f, 0f), 0, data);
				}
			}
			PhotonNetwork.Destroy(base.gameObject);
		}

		private void DestroyAsteroidLocally()
		{
			isDestroyed = true;
			GetComponent<Renderer>().enabled = false;
		}
	}
	public class AsteroidsGameManager : MonoBehaviourPunCallbacks
	{
		public static AsteroidsGameManager Instance;

		public Text InfoText;

		public GameObject[] AsteroidPrefabs;

		public void Awake()
		{
			Instance = this;
		}

		public override void OnEnable()
		{
			base.OnEnable();
			CountdownTimer.OnCountdownTimerHasExpired += OnCountdownTimerIsExpired;
		}

		public void Start()
		{
			InfoText.text = "Waiting for other players...";
			ExitGames.Client.Photon.Hashtable propertiesToSet = new ExitGames.Client.Photon.Hashtable { { "PlayerLoadedLevel", true } };
			PhotonNetwork.LocalPlayer.SetCustomProperties(propertiesToSet);
		}

		public override void OnDisable()
		{
			base.OnDisable();
			CountdownTimer.OnCountdownTimerHasExpired -= OnCountdownTimerIsExpired;
		}

		private IEnumerator SpawnAsteroid()
		{
			while (true)
			{
				yield return new WaitForSeconds(UnityEngine.Random.Range(5f, 10f));
				Vector2 insideUnitCircle = UnityEngine.Random.insideUnitCircle;
				_ = Vector3.zero;
				Vector3 position = ((!(Mathf.Abs(insideUnitCircle.x) > Mathf.Abs(insideUnitCircle.y))) ? new Vector3(insideUnitCircle.x * Camera.main.orthographicSize * Camera.main.aspect, 0f, Mathf.Sign(insideUnitCircle.y) * Camera.main.orthographicSize) : new Vector3(Mathf.Sign(insideUnitCircle.x) * Camera.main.orthographicSize * Camera.main.aspect, 0f, insideUnitCircle.y * Camera.main.orthographicSize));
				position -= position.normalized * 0.1f;
				Vector3 vector = -position.normalized * 1000f;
				Vector3 vector2 = UnityEngine.Random.insideUnitSphere * UnityEngine.Random.Range(500f, 1500f);
				object[] data = new object[3] { vector, vector2, true };
				PhotonNetwork.InstantiateSceneObject("BigAsteroid", position, Quaternion.Euler(UnityEngine.Random.value * 360f, UnityEngine.Random.value * 360f, UnityEngine.Random.value * 360f), 0, data);
			}
		}

		private IEnumerator EndOfGame(string winner, int score)
		{
			for (float timer = 5f; timer > 0f; timer -= Time.deltaTime)
			{
				InfoText.text = string.Format("Player {0} won with {1} points.\n\n\nReturning to login screen in {2} seconds.", winner, score, timer.ToString("n2"));
				yield return new WaitForEndOfFrame();
			}
			PhotonNetwork.LeaveRoom();
		}

		public override void OnDisconnected(DisconnectCause cause)
		{
			SceneManager.LoadScene("DemoAsteroids-LobbyScene");
		}

		public override void OnLeftRoom()
		{
			PhotonNetwork.Disconnect();
		}

		public override void OnMasterClientSwitched(Player newMasterClient)
		{
			if (PhotonNetwork.LocalPlayer.ActorNumber == newMasterClient.ActorNumber)
			{
				StartCoroutine(SpawnAsteroid());
			}
		}

		public override void OnPlayerLeftRoom(Player otherPlayer)
		{
			CheckEndOfGame();
		}

		public override void OnPlayerPropertiesUpdate(Player targetPlayer, ExitGames.Client.Photon.Hashtable changedProps)
		{
			if (changedProps.ContainsKey("PlayerLives"))
			{
				CheckEndOfGame();
			}
			else if (PhotonNetwork.IsMasterClient && changedProps.ContainsKey("PlayerLoadedLevel") && CheckAllPlayerLoadedLevel())
			{
				ExitGames.Client.Photon.Hashtable propertiesToSet = new ExitGames.Client.Photon.Hashtable { 
				{
					"StartTime",
					(float)PhotonNetwork.Time
				} };
				PhotonNetwork.CurrentRoom.SetCustomProperties(propertiesToSet);
			}
		}

		private void StartGame()
		{
			float num = 360f / (float)(int)PhotonNetwork.CurrentRoom.PlayerCount * (float)PhotonNetwork.LocalPlayer.GetPlayerNumber();
			float x = 20f * Mathf.Sin(num * ((float)Math.PI / 180f));
			float z = 20f * Mathf.Cos(num * ((float)Math.PI / 180f));
			Vector3 position = new Vector3(x, 0f, z);
			Quaternion rotation = Quaternion.Euler(0f, num, 0f);
			PhotonNetwork.Instantiate("Spaceship", position, rotation, 0);
			if (PhotonNetwork.IsMasterClient)
			{
				StartCoroutine(SpawnAsteroid());
			}
		}

		private bool CheckAllPlayerLoadedLevel()
		{
			Player[] playerList = PhotonNetwork.PlayerList;
			for (int i = 0; i < playerList.Length; i++)
			{
				if (!playerList[i].CustomProperties.TryGetValue("PlayerLoadedLevel", out var value) || !(bool)value)
				{
					return false;
				}
			}
			return true;
		}

		private void CheckEndOfGame()
		{
			bool flag = true;
			Player[] playerList = PhotonNetwork.PlayerList;
			for (int i = 0; i < playerList.Length; i++)
			{
				if (playerList[i].CustomProperties.TryGetValue("PlayerLives", out var value) && (int)value > 0)
				{
					flag = false;
					break;
				}
			}
			if (!flag)
			{
				return;
			}
			if (PhotonNetwork.IsMasterClient)
			{
				StopAllCoroutines();
			}
			string winner = "";
			int num = -1;
			playerList = PhotonNetwork.PlayerList;
			foreach (Player player in playerList)
			{
				if (player.GetScore() > num)
				{
					winner = player.NickName;
					num = player.GetScore();
				}
			}
			StartCoroutine(EndOfGame(winner, num));
		}

		private void OnCountdownTimerIsExpired()
		{
			StartGame();
		}
	}
	public class Bullet : MonoBehaviour
	{
		public Player Owner { get; private set; }

		public void Start()
		{
			UnityEngine.Object.Destroy(base.gameObject, 3f);
		}

		public void OnCollisionEnter(Collision collision)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}

		public void InitializeBullet(Player owner, Vector3 originalDirection, float lag)
		{
			Owner = owner;
			base.transform.forward = originalDirection;
			Rigidbody component = GetComponent<Rigidbody>();
			component.velocity = originalDirection * 200f;
			component.position += component.velocity * lag;
		}
	}
	public class PlayerOverviewPanel : MonoBehaviourPunCallbacks
	{
		public GameObject PlayerOverviewEntryPrefab;

		private Dictionary<int, GameObject> playerListEntries;

		public void Awake()
		{
			playerListEntries = new Dictionary<int, GameObject>();
			Player[] playerList = PhotonNetwork.PlayerList;
			foreach (Player player in playerList)
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(PlayerOverviewEntryPrefab);
				gameObject.transform.SetParent(base.gameObject.transform);
				gameObject.transform.localScale = Vector3.one;
				gameObject.GetComponent<Text>().color = AsteroidsGame.GetColor(player.GetPlayerNumber());
				gameObject.GetComponent<Text>().text = $"{player.NickName}\nScore: {player.GetScore()}\nLives: {3}";
				playerListEntries.Add(player.ActorNumber, gameObject);
			}
		}

		public override void OnPlayerLeftRoom(Player otherPlayer)
		{
			UnityEngine.Object.Destroy(playerListEntries[otherPlayer.ActorNumber].gameObject);
			playerListEntries.Remove(otherPlayer.ActorNumber);
		}

		public override void OnPlayerPropertiesUpdate(Player targetPlayer, ExitGames.Client.Photon.Hashtable changedProps)
		{
			if (playerListEntries.TryGetValue(targetPlayer.ActorNumber, out var value))
			{
				value.GetComponent<Text>().text = string.Format("{0}\nScore: {1}\nLives: {2}", targetPlayer.NickName, targetPlayer.GetScore(), targetPlayer.CustomProperties["PlayerLives"]);
			}
		}
	}
	public class Spaceship : MonoBehaviour
	{
		public float RotationSpeed = 90f;

		public float MovementSpeed = 2f;

		public float MaxSpeed = 0.2f;

		public ParticleSystem Destruction;

		public GameObject EngineTrail;

		public GameObject BulletPrefab;

		private PhotonView photonView;

		private Rigidbody rigidbody;

		private Collider collider;

		private Renderer renderer;

		private float rotation;

		private float acceleration;

		private float shootingTimer;

		private bool controllable = true;

		public void Awake()
		{
			photonView = GetComponent<PhotonView>();
			rigidbody = GetComponent<Rigidbody>();
			collider = GetComponent<Collider>();
			renderer = GetComponent<Renderer>();
		}

		public void Start()
		{
			Renderer[] componentsInChildren = GetComponentsInChildren<Renderer>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				componentsInChildren[i].material.color = AsteroidsGame.GetColor(photonView.Owner.GetPlayerNumber());
			}
		}

		public void Update()
		{
			if (photonView.IsMine && controllable)
			{
				rotation = Input.GetAxis("Horizontal");
				acceleration = Input.GetAxis("Vertical");
				if (Input.GetButton("Jump") && (double)shootingTimer <= 0.0)
				{
					shootingTimer = 0.2f;
					photonView.RPC("Fire", RpcTarget.AllViaServer, rigidbody.position, rigidbody.rotation);
				}
				if (shootingTimer > 0f)
				{
					shootingTimer -= Time.deltaTime;
				}
			}
		}

		public void FixedUpdate()
		{
			if (photonView.IsMine && controllable)
			{
				Quaternion quaternion = rigidbody.rotation * Quaternion.Euler(0f, rotation * RotationSpeed * Time.fixedDeltaTime, 0f);
				rigidbody.MoveRotation(quaternion);
				Vector3 force = quaternion * Vector3.forward * acceleration * 1000f * MovementSpeed * Time.fixedDeltaTime;
				rigidbody.AddForce(force);
				if (rigidbody.velocity.magnitude > MaxSpeed * 1000f)
				{
					rigidbody.velocity = rigidbody.velocity.normalized * MaxSpeed * 1000f;
				}
				CheckExitScreen();
			}
		}

		private IEnumerator WaitForRespawn()
		{
			yield return new WaitForSeconds(4f);
			photonView.RPC("RespawnSpaceship", RpcTarget.AllViaServer);
		}

		[PunRPC]
		public void DestroySpaceship()
		{
			rigidbody.velocity = Vector3.zero;
			rigidbody.angularVelocity = Vector3.zero;
			collider.enabled = false;
			renderer.enabled = false;
			controllable = false;
			EngineTrail.SetActive(value: false);
			Destruction.Play();
			if (photonView.IsMine && PhotonNetwork.LocalPlayer.CustomProperties.TryGetValue("PlayerLives", out var value))
			{
				PhotonNetwork.LocalPlayer.SetCustomProperties(new ExitGames.Client.Photon.Hashtable { 
				{
					"PlayerLives",
					((int)value > 1) ? ((int)value - 1) : 0
				} });
				if ((int)value > 1)
				{
					StartCoroutine("WaitForRespawn");
				}
			}
		}

		[PunRPC]
		public void Fire(Vector3 position, Quaternion rotation, PhotonMessageInfo info)
		{
			float f = (float)(PhotonNetwork.Time - info.SentServerTime);
			UnityEngine.Object.Instantiate(BulletPrefab, rigidbody.position, Quaternion.identity).GetComponent<Bullet>().InitializeBullet(photonView.Owner, rotation * Vector3.forward, Mathf.Abs(f));
		}

		[PunRPC]
		public void RespawnSpaceship()
		{
			collider.enabled = true;
			renderer.enabled = true;
			controllable = true;
			EngineTrail.SetActive(value: true);
			Destruction.Stop();
		}

		private void CheckExitScreen()
		{
			if (!(Camera.main == null))
			{
				if (Mathf.Abs(rigidbody.position.x) > Camera.main.orthographicSize * Camera.main.aspect)
				{
					rigidbody.position = new Vector3((0f - Mathf.Sign(rigidbody.position.x)) * Camera.main.orthographicSize * Camera.main.aspect, 0f, rigidbody.position.z);
					rigidbody.position -= rigidbody.position.normalized * 0.1f;
				}
				if (Mathf.Abs(rigidbody.position.z) > Camera.main.orthographicSize)
				{
					rigidbody.position = new Vector3(rigidbody.position.x, rigidbody.position.y, (0f - Mathf.Sign(rigidbody.position.z)) * Camera.main.orthographicSize);
					rigidbody.position -= rigidbody.position.normalized * 0.1f;
				}
			}
		}
	}
	public class LobbyMainPanel : MonoBehaviourPunCallbacks
	{
		[Header("Login Panel")]
		public GameObject LoginPanel;

		public InputField PlayerNameInput;

		[Header("Selection Panel")]
		public GameObject SelectionPanel;

		[Header("Create Room Panel")]
		public GameObject CreateRoomPanel;

		public InputField RoomNameInputField;

		public InputField MaxPlayersInputField;

		[Header("Join Random Room Panel")]
		public GameObject JoinRandomRoomPanel;

		[Header("Room List Panel")]
		public GameObject RoomListPanel;

		public GameObject RoomListContent;

		public GameObject RoomListEntryPrefab;

		[Header("Inside Room Panel")]
		public GameObject InsideRoomPanel;

		public Button StartGameButton;

		public GameObject PlayerListEntryPrefab;

		private Dictionary<string, RoomInfo> cachedRoomList;

		private Dictionary<string, GameObject> roomListEntries;

		private Dictionary<int, GameObject> playerListEntries;

		public void Awake()
		{
			PhotonNetwork.AutomaticallySyncScene = true;
			cachedRoomList = new Dictionary<string, RoomInfo>();
			roomListEntries = new Dictionary<string, GameObject>();
			PlayerNameInput.text = "Player " + UnityEngine.Random.Range(1000, 10000);
		}

		public override void OnConnectedToMaster()
		{
			SetActivePanel(SelectionPanel.name);
		}

		public override void OnRoomListUpdate(List<RoomInfo> roomList)
		{
			ClearRoomListView();
			UpdateCachedRoomList(roomList);
			UpdateRoomListView();
		}

		public override void OnLeftLobby()
		{
			cachedRoomList.Clear();
			ClearRoomListView();
		}

		public override void OnCreateRoomFailed(short returnCode, string message)
		{
			SetActivePanel(SelectionPanel.name);
		}

		public override void OnJoinRoomFailed(short returnCode, string message)
		{
			SetActivePanel(SelectionPanel.name);
		}

		public override void OnJoinRandomFailed(short returnCode, string message)
		{
			string roomName = "Room " + UnityEngine.Random.Range(1000, 10000);
			RoomOptions roomOptions = new RoomOptions
			{
				MaxPlayers = 8
			};
			PhotonNetwork.CreateRoom(roomName, roomOptions);
		}

		public override void OnJoinedRoom()
		{
			SetActivePanel(InsideRoomPanel.name);
			if (playerListEntries == null)
			{
				playerListEntries = new Dictionary<int, GameObject>();
			}
			Player[] playerList = PhotonNetwork.PlayerList;
			foreach (Player player in playerList)
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(PlayerListEntryPrefab);
				gameObject.transform.SetParent(InsideRoomPanel.transform);
				gameObject.transform.localScale = Vector3.one;
				gameObject.GetComponent<PlayerListEntry>().Initialize(player.ActorNumber, player.NickName);
				if (player.CustomProperties.TryGetValue("IsPlayerReady", out var value))
				{
					gameObject.GetComponent<PlayerListEntry>().SetPlayerReady((bool)value);
				}
				playerListEntries.Add(player.ActorNumber, gameObject);
			}
			StartGameButton.gameObject.SetActive(CheckPlayersReady());
			ExitGames.Client.Photon.Hashtable propertiesToSet = new ExitGames.Client.Photon.Hashtable { { "PlayerLoadedLevel", false } };
			PhotonNetwork.LocalPlayer.SetCustomProperties(propertiesToSet);
		}

		public override void OnLeftRoom()
		{
			SetActivePanel(SelectionPanel.name);
			foreach (GameObject value in playerListEntries.Values)
			{
				UnityEngine.Object.Destroy(value.gameObject);
			}
			playerListEntries.Clear();
			playerListEntries = null;
		}

		public override void OnPlayerEnteredRoom(Player newPlayer)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(PlayerListEntryPrefab);
			gameObject.transform.SetParent(InsideRoomPanel.transform);
			gameObject.transform.localScale = Vector3.one;
			gameObject.GetComponent<PlayerListEntry>().Initialize(newPlayer.ActorNumber, newPlayer.NickName);
			playerListEntries.Add(newPlayer.ActorNumber, gameObject);
			StartGameButton.gameObject.SetActive(CheckPlayersReady());
		}

		public override void OnPlayerLeftRoom(Player otherPlayer)
		{
			UnityEngine.Object.Destroy(playerListEntries[otherPlayer.ActorNumber].gameObject);
			playerListEntries.Remove(otherPlayer.ActorNumber);
			StartGameButton.gameObject.SetActive(CheckPlayersReady());
		}

		public override void OnMasterClientSwitched(Player newMasterClient)
		{
			if (PhotonNetwork.LocalPlayer.ActorNumber == newMasterClient.ActorNumber)
			{
				StartGameButton.gameObject.SetActive(CheckPlayersReady());
			}
		}

		public override void OnPlayerPropertiesUpdate(Player targetPlayer, ExitGames.Client.Photon.Hashtable changedProps)
		{
			if (playerListEntries == null)
			{
				playerListEntries = new Dictionary<int, GameObject>();
			}
			if (playerListEntries.TryGetValue(targetPlayer.ActorNumber, out var value) && changedProps.TryGetValue("IsPlayerReady", out var value2))
			{
				value.GetComponent<PlayerListEntry>().SetPlayerReady((bool)value2);
			}
			StartGameButton.gameObject.SetActive(CheckPlayersReady());
		}

		public void OnBackButtonClicked()
		{
			if (PhotonNetwork.InLobby)
			{
				PhotonNetwork.LeaveLobby();
			}
			SetActivePanel(SelectionPanel.name);
		}

		public void OnCreateRoomButtonClicked()
		{
			string text = RoomNameInputField.text;
			text = (text.Equals(string.Empty) ? ("Room " + UnityEngine.Random.Range(1000, 10000)) : text);
			byte.TryParse(MaxPlayersInputField.text, out var result);
			result = (byte)Mathf.Clamp(result, 2, 8);
			RoomOptions roomOptions = new RoomOptions
			{
				MaxPlayers = result
			};
			PhotonNetwork.CreateRoom(text, roomOptions);
		}

		public void OnJoinRandomRoomButtonClicked()
		{
			SetActivePanel(JoinRandomRoomPanel.name);
			PhotonNetwork.JoinRandomRoom();
		}

		public void OnLeaveGameButtonClicked()
		{
			PhotonNetwork.LeaveRoom();
		}

		public void OnLoginButtonClicked()
		{
			string text = PlayerNameInput.text;
			if (!text.Equals(""))
			{
				PhotonNetwork.LocalPlayer.NickName = text;
				PhotonNetwork.ConnectUsingSettings();
			}
			else
			{
				UnityEngine.Debug.LogError("Player Name is invalid.");
			}
		}

		public void OnRoomListButtonClicked()
		{
			if (!PhotonNetwork.InLobby)
			{
				PhotonNetwork.JoinLobby();
			}
			SetActivePanel(RoomListPanel.name);
		}

		public void OnStartGameButtonClicked()
		{
			PhotonNetwork.CurrentRoom.IsOpen = false;
			PhotonNetwork.CurrentRoom.IsVisible = false;
			PhotonNetwork.LoadLevel("DemoAsteroids-GameScene");
		}

		private bool CheckPlayersReady()
		{
			if (!PhotonNetwork.IsMasterClient)
			{
				return false;
			}
			Player[] playerList = PhotonNetwork.PlayerList;
			for (int i = 0; i < playerList.Length; i++)
			{
				if (playerList[i].CustomProperties.TryGetValue("IsPlayerReady", out var value))
				{
					if (!(bool)value)
					{
						return false;
					}
					continue;
				}
				return false;
			}
			return true;
		}

		private void ClearRoomListView()
		{
			foreach (GameObject value in roomListEntries.Values)
			{
				UnityEngine.Object.Destroy(value.gameObject);
			}
			roomListEntries.Clear();
		}

		public void LocalPlayerPropertiesUpdated()
		{
			StartGameButton.gameObject.SetActive(CheckPlayersReady());
		}

		private void SetActivePanel(string activePanel)
		{
			LoginPanel.SetActive(activePanel.Equals(LoginPanel.name));
			SelectionPanel.SetActive(activePanel.Equals(SelectionPanel.name));
			CreateRoomPanel.SetActive(activePanel.Equals(CreateRoomPanel.name));
			JoinRandomRoomPanel.SetActive(activePanel.Equals(JoinRandomRoomPanel.name));
			RoomListPanel.SetActive(activePanel.Equals(RoomListPanel.name));
			InsideRoomPanel.SetActive(activePanel.Equals(InsideRoomPanel.name));
		}

		private void UpdateCachedRoomList(List<RoomInfo> roomList)
		{
			foreach (RoomInfo room in roomList)
			{
				if (!room.IsOpen || !room.IsVisible || room.RemovedFromList)
				{
					if (cachedRoomList.ContainsKey(room.Name))
					{
						cachedRoomList.Remove(room.Name);
					}
				}
				else if (cachedRoomList.ContainsKey(room.Name))
				{
					cachedRoomList[room.Name] = room;
				}
				else
				{
					cachedRoomList.Add(room.Name, room);
				}
			}
		}

		private void UpdateRoomListView()
		{
			foreach (RoomInfo value in cachedRoomList.Values)
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(RoomListEntryPrefab);
				gameObject.transform.SetParent(RoomListContent.transform);
				gameObject.transform.localScale = Vector3.one;
				gameObject.GetComponent<RoomListEntry>().Initialize(value.Name, (byte)value.PlayerCount, value.MaxPlayers);
				roomListEntries.Add(value.Name, gameObject);
			}
		}
	}
	public class LobbyTopPanel : MonoBehaviour
	{
		private readonly string connectionStatusMessage = "    Connection Status: ";

		[Header("UI References")]
		public Text ConnectionStatusText;

		public void Update()
		{
			ConnectionStatusText.text = connectionStatusMessage + PhotonNetwork.NetworkClientState;
		}
	}
	public class PlayerListEntry : MonoBehaviour
	{
		[Header("UI References")]
		public Text PlayerNameText;

		public Image PlayerColorImage;

		public Button PlayerReadyButton;

		public Image PlayerReadyImage;

		private int ownerId;

		private bool isPlayerReady;

		public void OnEnable()
		{
			PlayerNumbering.OnPlayerNumberingChanged += OnPlayerNumberingChanged;
		}

		public void Start()
		{
			if (PhotonNetwork.LocalPlayer.ActorNumber != ownerId)
			{
				PlayerReadyButton.gameObject.SetActive(value: false);
				return;
			}
			ExitGames.Client.Photon.Hashtable propertiesToSet = new ExitGames.Client.Photon.Hashtable
			{
				{ "IsPlayerReady", isPlayerReady },
				{ "PlayerLives", 3 }
			};
			PhotonNetwork.LocalPlayer.SetCustomProperties(propertiesToSet);
			PhotonNetwork.LocalPlayer.SetScore(0);
			PlayerReadyButton.onClick.AddListener(delegate
			{
				isPlayerReady = !isPlayerReady;
				SetPlayerReady(isPlayerReady);
				ExitGames.Client.Photon.Hashtable propertiesToSet2 = new ExitGames.Client.Photon.Hashtable { { "IsPlayerReady", isPlayerReady } };
				PhotonNetwork.LocalPlayer.SetCustomProperties(propertiesToSet2);
				if (PhotonNetwork.IsMasterClient)
				{
					UnityEngine.Object.FindObjectOfType<LobbyMainPanel>().LocalPlayerPropertiesUpdated();
				}
			});
		}

		public void OnDisable()
		{
			PlayerNumbering.OnPlayerNumberingChanged -= OnPlayerNumberingChanged;
		}

		public void Initialize(int playerId, string playerName)
		{
			ownerId = playerId;
			PlayerNameText.text = playerName;
		}

		private void OnPlayerNumberingChanged()
		{
			Player[] playerList = PhotonNetwork.PlayerList;
			foreach (Player player in playerList)
			{
				if (player.ActorNumber == ownerId)
				{
					PlayerColorImage.color = AsteroidsGame.GetColor(player.GetPlayerNumber());
				}
			}
		}

		public void SetPlayerReady(bool playerReady)
		{
			PlayerReadyButton.GetComponentInChildren<Text>().text = (playerReady ? "Ready!" : "Ready?");
			PlayerReadyImage.enabled = playerReady;
		}
	}
	public class RoomListEntry : MonoBehaviour
	{
		public Text RoomNameText;

		public Text RoomPlayersText;

		public Button JoinRoomButton;

		private string roomName;

		public void Start()
		{
			JoinRoomButton.onClick.AddListener(delegate
			{
				if (PhotonNetwork.InLobby)
				{
					PhotonNetwork.LeaveLobby();
				}
				PhotonNetwork.JoinRoom(roomName);
			});
		}

		public void Initialize(string name, byte currentPlayers, byte maxPlayers)
		{
			roomName = name;
			RoomNameText.text = name;
			RoomPlayersText.text = currentPlayers + " / " + maxPlayers;
		}
	}
}
namespace Photon.Realtime.Demo
{
	public class ConnectAndJoinRandomLb : MonoBehaviour, IConnectionCallbacks, IMatchmakingCallbacks, ILobbyCallbacks
	{
		public string AppId;

		private LoadBalancingClient lbc;

		private ConnectionHandler ch;

		public Text StateUiText;

		public void Start()
		{
			lbc = new LoadBalancingClient();
			lbc.AppId = AppId;
			lbc.AddCallbackTarget(this);
			lbc.ConnectToNameServer();
			ch = base.gameObject.GetComponent<ConnectionHandler>();
			if (ch != null)
			{
				ch.Client = lbc;
				ch.StartFallbackSendAckThread();
			}
		}

		public void Update()
		{
			LoadBalancingClient loadBalancingClient = lbc;
			if (loadBalancingClient != null)
			{
				loadBalancingClient.Service();
				Text stateUiText = StateUiText;
				string text = loadBalancingClient.State.ToString();
				if (stateUiText != null && !stateUiText.text.Equals(text))
				{
					stateUiText.text = "State: " + text;
				}
			}
		}

		public void OnConnected()
		{
		}

		public void OnConnectedToMaster()
		{
			UnityEngine.Debug.Log("OnConnectedToMaster");
			lbc.OpJoinRandomRoom();
		}

		public void OnDisconnected(DisconnectCause cause)
		{
			UnityEngine.Debug.Log(string.Concat("OnDisconnected(", cause, ")"));
		}

		public void OnCustomAuthenticationResponse(Dictionary<string, object> data)
		{
		}

		public void OnCustomAuthenticationFailed(string debugMessage)
		{
		}

		public void OnRegionListReceived(RegionHandler regionHandler)
		{
			UnityEngine.Debug.Log("OnRegionListReceived");
			regionHandler.PingMinimumOfRegions(OnRegionPingCompleted, null);
		}

		public void OnRoomListUpdate(List<RoomInfo> roomList)
		{
		}

		public void OnLobbyStatisticsUpdate(List<TypedLobbyInfo> lobbyStatistics)
		{
		}

		public void OnJoinedLobby()
		{
		}

		public void OnLeftLobby()
		{
		}

		public void OnFriendListUpdate(List<FriendInfo> friendList)
		{
		}

		public void OnCreatedRoom()
		{
		}

		public void OnCreateRoomFailed(short returnCode, string message)
		{
		}

		public void OnJoinedRoom()
		{
			UnityEngine.Debug.Log("OnJoinedRoom");
		}

		public void OnJoinRoomFailed(short returnCode, string message)
		{
		}

		public void OnJoinRandomFailed(short returnCode, string message)
		{
			UnityEngine.Debug.Log("OnJoinRandomFailed");
			lbc.OpCreateRoom(new EnterRoomParams());
		}

		public void OnLeftRoom()
		{
		}

		private void OnRegionPingCompleted(RegionHandler regionHandler)
		{
			UnityEngine.Debug.Log("OnRegionPingCompleted " + regionHandler.BestRegion);
			UnityEngine.Debug.Log("RegionPingSummary: " + regionHandler.SummaryToCache);
			lbc.ConnectToRegionMaster(regionHandler.BestRegion.Code);
		}
	}
}
namespace Photon.Chat.UtilityScripts
{
	public class EventSystemSpawner : MonoBehaviour
	{
		private void Start()
		{
			if (UnityEngine.Object.FindObjectOfType<EventSystem>() == null)
			{
				GameObject obj = new GameObject("EventSystem");
				obj.AddComponent<EventSystem>();
				obj.AddComponent<StandaloneInputModule>();
			}
		}
	}
	public class OnStartDelete : MonoBehaviour
	{
		private void Start()
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}
	[RequireComponent(typeof(Text))]
	public class TextButtonTransition : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler
	{
		private Text _text;

		public Selectable Selectable;

		public Color NormalColor = Color.white;

		public Color HoverColor = Color.black;

		public void Awake()
		{
			_text = GetComponent<Text>();
		}

		public void OnEnable()
		{
			_text.color = NormalColor;
		}

		public void OnDisable()
		{
			_text.color = NormalColor;
		}

		public void OnPointerEnter(PointerEventData eventData)
		{
			if (Selectable == null || Selectable.IsInteractable())
			{
				_text.color = HoverColor;
			}
		}

		public void OnPointerExit(PointerEventData eventData)
		{
			if (Selectable == null || Selectable.IsInteractable())
			{
				_text.color = NormalColor;
			}
		}
	}
	[RequireComponent(typeof(Text))]
	public class TextToggleIsOnTransition : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler
	{
		public Toggle toggle;

		private Text _text;

		public Color NormalOnColor = Color.white;

		public Color NormalOffColor = Color.black;

		public Color HoverOnColor = Color.black;

		public Color HoverOffColor = Color.black;

		private bool isHover;

		public void OnEnable()
		{
			_text = GetComponent<Text>();
			OnValueChanged(toggle.isOn);
			toggle.onValueChanged.AddListener(OnValueChanged);
		}

		public void OnDisable()
		{
			toggle.onValueChanged.RemoveListener(OnValueChanged);
		}

		public void OnValueChanged(bool isOn)
		{
			_text.color = ((!isOn) ? (isHover ? NormalOffColor : NormalOffColor) : (isHover ? HoverOnColor : HoverOnColor));
		}

		public void OnPointerEnter(PointerEventData eventData)
		{
			isHover = true;
			_text.color = (toggle.isOn ? HoverOnColor : HoverOffColor);
		}

		public void OnPointerExit(PointerEventData eventData)
		{
			isHover = false;
			_text.color = (toggle.isOn ? NormalOnColor : NormalOffColor);
		}
	}
}
namespace SFS2XExamples.Panel
{
	public class Panel : MonoBehaviour
	{
		[Tooltip("IP address or domain name of the SmartFoxServer 2X instance")]
		public string Host = "127.0.0.1";

		[Tooltip("TCP port listened by the SmartFoxServer 2X instance; used for regular socket connection in all builds except WebGL")]
		public int TcpPort = 9933;

		public Animator cameraAnimator;

		public InputField ipInput;

		public InputField portInput;

		private static Settings globalSettings;

		private void Start()
		{
			Application.runInBackground = true;
			if (globalSettings == null)
			{
				globalSettings = Settings.Instance;
				ipInput.text = (Settings.ipAddress = Host);
				InputField inputField = portInput;
				int num = (Settings.port = TcpPort);
				inputField.text = num.ToString();
			}
			else
			{
				ipInput.text = Settings.ipAddress;
				portInput.text = Settings.port.ToString();
				cameraAnimator.SetBool("showExamples", value: true);
				cameraAnimator.speed = 1000f;
			}
		}

		public void OnDownloadSmartFoxServer2XButtonClick()
		{
			Application.OpenURL("http://smartfoxserver.com/download/sfs2x#p=installer");
		}

		public void OnDownloadLatestPatchButtonClick()
		{
			Application.OpenURL("http://smartfoxserver.com/download/sfs2x#p=updates");
		}

		public void OnShowExamplesButtonClick()
		{
			Settings.ipAddress = ipInput.text;
			Settings.port = int.Parse(portInput.text);
			cameraAnimator.speed = 1f;
			cameraAnimator.SetBool("showExamples", value: true);
		}

		public void OnVisitTheLiveExamplesButtonClick()
		{
			Application.OpenURL("http://smartfoxserver.com/overview/demo#unity");
		}

		public void OnIntroductionToSFS2XUnityButtonClick()
		{
			Application.OpenURL("http://docs2x.smartfoxserver.com/ExamplesUnity/introduction");
		}

		public void OnSmartFoxServer2XDocumentationButtonClick()
		{
			Application.OpenURL("http://docs2x.smartfoxserver.com/");
		}

		public void OnSFS2XUnityVideoTutorialsButtonClick()
		{
			Application.OpenURL("http://genesisrage.net/tutorials/unity-smartfox");
		}

		public void OnSFS2XLicensingOptionsButtonClick()
		{
			Application.OpenURL("http://www.smartfoxserver.com/products/sfs2x#p=licensing");
		}

		public void OnGoBackButtonClick()
		{
			cameraAnimator.speed = 1f;
			cameraAnimator.SetBool("showExamples", value: false);
		}

		public void OnExample01ConnectorButtonClick()
		{
			Application.LoadLevel("01 Connector");
		}

		public void OnExample02LobbyButtonClick()
		{
			Application.LoadLevel("02 Lobby");
		}

		public void OnExample03BuddyMessengerButtonClick()
		{
			Application.LoadLevel("03 BuddyMessenger");
		}

		public void OnExample04TrisButtonClick()
		{
			Application.LoadLevel("04 TrisLogin");
		}

		public void OnExample05ObjectMovementButtonClick()
		{
			Application.LoadLevel("05 ObjectMovementConnection");
		}

		public void OnExample06FirstPersonShooterButtonClick()
		{
			Application.LoadLevel("06 FPSLogin");
		}

		public void OnExample07MMORoomDemoButtonClick()
		{
			Application.LoadLevel("07 MMORoomDemoConnection");
		}

		public void OnExample08SpaceWarButtonClick()
		{
			Application.LoadLevel("08 SpaceWarGame");
		}

		public void OnExample09AdvancedConnectorButtonClick()
		{
			Application.LoadLevel("09 AdvancedConnector");
		}
	}
	public class Settings : MonoBehaviour
	{
		public static string ipAddress = "127.0.0.1";

		public static int port = 9933;

		private static Settings instance;

		public static Settings Instance
		{
			get
			{
				if (instance != null)
				{
					return instance;
				}
				instance = new GameObject("Settings").AddComponent<Settings>();
				return instance;
			}
		}

		private void Awake()
		{
			if (instance == null)
			{
				instance = this;
				UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
			}
			else
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}

		private void OnGUI()
		{
			if (Application.loadedLevelName != "Panel")
			{
				GUIStyle gUIStyle = new GUIStyle();
				gUIStyle.fontSize = 16;
				gUIStyle.normal.textColor = Color.white;
				if (Application.loadedLevelName == "03 BuddyMessenger")
				{
					GUI.Label(new Rect(Screen.width / 2 - 130, 25f, 250f, 30f), "Press ESC to return to the main menu", gUIStyle);
				}
				else
				{
					GUI.Label(new Rect(Screen.width / 2 - 130, Screen.height - 50, 250f, 30f), "Press ESC to return to the main menu", gUIStyle);
				}
			}
		}

		private void Update()
		{
			if (Application.loadedLevelName != "Panel" && Input.GetKeyDown(KeyCode.Escape))
			{
				GameObject gameObject = GameObject.Find("SmartFoxConnection");
				if (gameObject == null)
				{
					gameObject = GameObject.Find("ConnectionPanel");
				}
				if (gameObject == null)
				{
					gameObject = GameObject.Find("Controller");
				}
				if (gameObject == null)
				{
					gameObject = GameObject.Find("Main Camera");
				}
				if (gameObject == null)
				{
					gameObject = GameObject.Find("UI");
				}
				gameObject.SendMessage("Disconnect");
				Cursor.visible = true;
				Cursor.lockState = CursorLockMode.None;
				Application.LoadLevel("Panel");
			}
		}
	}
}
namespace OOLitJson
{
	public enum JsonType
	{
		None,
		Object,
		Array,
		String,
		Int,
		Long,
		Double,
		Boolean
	}
	public interface IJsonWrapper : IList, ICollection, IEnumerable, IOrderedDictionary, IDictionary
	{
		bool IsArray { get; }

		bool IsBoolean { get; }

		bool IsDouble { get; }

		bool IsInt { get; }

		bool IsLong { get; }

		bool IsObject { get; }

		bool IsString { get; }

		bool GetBoolean();

		double GetDouble();

		int GetInt();

		JsonType GetJsonType();

		long GetLong();

		string GetString();

		void SetBoolean(bool val);

		void SetDouble(double val);

		void SetInt(int val);

		void SetJsonType(JsonType type);

		void SetLong(long val);

		void SetString(string val);

		string ToJson();

		void ToJson(JsonWriter writer);
	}
	public class JsonData : IJsonWrapper, IList, ICollection, IEnumerable, IOrderedDictionary, IDictionary, IEquatable<JsonData>
	{
		private IList<JsonData> inst_array;

		private bool inst_boolean;

		private double inst_double;

		private int inst_int;

		private long inst_long;

		private IDictionary<string, JsonData> inst_object;

		private string inst_string;

		private string json;

		private JsonType type;

		private IList<KeyValuePair<string, JsonData>> object_list;

		public int Count => EnsureCollection().Count;

		public bool IsArray => type == JsonType.Array;

		public bool IsBoolean => type == JsonType.Boolean;

		public bool IsDouble => type == JsonType.Double;

		public bool IsInt => type == JsonType.Int;

		public bool IsLong => type == JsonType.Long;

		public bool IsObject => type == JsonType.Object;

		public bool IsString => type == JsonType.String;

		int ICollection.Count => Count;

		bool ICollection.IsSynchronized => EnsureCollection().IsSynchronized;

		object ICollection.SyncRoot => EnsureCollection().SyncRoot;

		bool IDictionary.IsFixedSize => EnsureDictionary().IsFixedSize;

		bool IDictionary.IsReadOnly => EnsureDictionary().IsReadOnly;

		ICollection IDictionary.Keys
		{
			get
			{
				EnsureDictionary();
				IList<string> list = new List<string>();
				foreach (KeyValuePair<string, JsonData> item in object_list)
				{
					list.Add(item.Key);
				}
				return (ICollection)list;
			}
		}

		ICollection IDictionary.Values
		{
			get
			{
				EnsureDictionary();
				IList<JsonData> list = new List<JsonData>();
				foreach (KeyValuePair<string, JsonData> item in object_list)
				{
					list.Add(item.Value);
				}
				return (ICollection)list;
			}
		}

		bool IJsonWrapper.IsArray => IsArray;

		bool IJsonWrapper.IsBoolean => IsBoolean;

		bool IJsonWrapper.IsDouble => IsDouble;

		bool IJsonWrapper.IsInt => IsInt;

		bool IJsonWrapper.IsLong => IsLong;

		bool IJsonWrapper.IsObject => IsObject;

		bool IJsonWrapper.IsString => IsString;

		bool IList.IsFixedSize => EnsureList().IsFixedSize;

		bool IList.IsReadOnly => EnsureList().IsReadOnly;

		object IDictionary.this[object key]
		{
			get
			{
				return EnsureDictionary()[key];
			}
			set
			{
				if (!(key is string))
				{
					throw new ArgumentException("The key has to be a string");
				}
				JsonData value2 = ToJsonData(value);
				this[(string)key] = value2;
			}
		}

		object IOrderedDictionary.this[int idx]
		{
			get
			{
				EnsureDictionary();
				return object_list[idx].Value;
			}
			set
			{
				EnsureDictionary();
				JsonData value2 = ToJsonData(value);
				KeyValuePair<string, JsonData> keyValuePair = object_list[idx];
				inst_object[keyValuePair.Key] = value2;
				KeyValuePair<string, JsonData> value3 = new KeyValuePair<string, JsonData>(keyValuePair.Key, value2);
				object_list[idx] = value3;
			}
		}

		object IList.this[int index]
		{
			get
			{
				return EnsureList()[index];
			}
			set
			{
				EnsureList();
				JsonData value2 = ToJsonData(value);
				this[index] = value2;
			}
		}

		public JsonData this[string prop_name]
		{
			get
			{
				EnsureDictionary();
				if (inst_object.Keys.Contains(prop_name))
				{
					return inst_object[prop_name];
				}
				return null;
			}
			set
			{
				EnsureDictionary();
				KeyValuePair<string, JsonData> keyValuePair = new KeyValuePair<string, JsonData>(prop_name, value);
				if (inst_object.ContainsKey(prop_name))
				{
					for (int i = 0; i < object_list.Count; i++)
					{
						if (object_list[i].Key == prop_name)
						{
							object_list[i] = keyValuePair;
							break;
						}
					}
				}
				else
				{
					object_list.Add(keyValuePair);
				}
				inst_object[prop_name] = value;
				json = null;
			}
		}

		public JsonData this[int index]
		{
			get
			{
				EnsureCollection();
				if (type == JsonType.Array)
				{
					return inst_array[index];
				}
				return object_list[index].Value;
			}
			set
			{
				EnsureCollection();
				if (type == JsonType.Array)
				{
					inst_array[index] = value;
				}
				else
				{
					KeyValuePair<string, JsonData> keyValuePair = object_list[index];
					KeyValuePair<string, JsonData> value2 = new KeyValuePair<string, JsonData>(keyValuePair.Key, value);
					object_list[index] = value2;
					inst_object[keyValuePair.Key] = value;
				}
				json = null;
			}
		}

		public JsonData()
		{
		}

		public JsonData(bool boolean)
		{
			type = JsonType.Boolean;
			inst_boolean = boolean;
		}

		public JsonData(double number)
		{
			type = JsonType.Double;
			inst_double = number;
		}

		public JsonData(int number)
		{
			type = JsonType.Int;
			inst_int = number;
		}

		public JsonData(long number)
		{
			type = JsonType.Long;
			inst_long = number;
		}

		public JsonData(object obj)
		{
			if (obj is bool)
			{
				type = JsonType.Boolean;
				inst_boolean = (bool)obj;
				return;
			}
			if (obj is double)
			{
				type = JsonType.Double;
				inst_double = (double)obj;
				return;
			}
			if (obj is int)
			{
				type = JsonType.Int;
				inst_int = (int)obj;
				return;
			}
			if (obj is long)
			{
				type = JsonType.Long;
				inst_long = (long)obj;
				return;
			}
			if (obj is string)
			{
				type = JsonType.String;
				inst_string = (string)obj;
				return;
			}
			throw new ArgumentException("Unable to wrap the given object with JsonData");
		}

		public JsonData(string str)
		{
			type = JsonType.String;
			inst_string = str;
		}

		public static implicit operator JsonData(bool data)
		{
			return new JsonData(data);
		}

		public static implicit operator JsonData(double data)
		{
			return new JsonData(data);
		}

		public static implicit operator JsonData(int data)
		{
			return new JsonData(data);
		}

		public static implicit operator JsonData(long data)
		{
			return new JsonData(data);
		}

		public static implicit operator JsonData(string data)
		{
			return new JsonData(data);
		}

		public static explicit operator bool(JsonData data)
		{
			if (data.type != JsonType.Boolean)
			{
				throw new InvalidCastException("Instance of JsonData doesn't hold a double");
			}
			return data.inst_boolean;
		}

		public static explicit operator double(JsonData data)
		{
			if (data.type != JsonType.Double)
			{
				throw new InvalidCastException("Instance of JsonData doesn't hold a double");
			}
			return data.inst_double;
		}

		public static explicit operator int(JsonData data)
		{
			if (data.type != JsonType.Int)
			{
				throw new InvalidCastException("Instance of JsonData doesn't hold an int");
			}
			return data.inst_int;
		}

		public static explicit operator long(JsonData data)
		{
			if (data.type != JsonType.Long)
			{
				throw new InvalidCastException("Instance of JsonData doesn't hold an int");
			}
			return data.inst_long;
		}

		public static explicit operator string(JsonData data)
		{
			if (data.type != JsonType.String)
			{
				throw new InvalidCastException("Instance of JsonData doesn't hold a string");
			}
			return data.inst_string;
		}

		void ICollection.CopyTo(Array array, int index)
		{
			EnsureCollection().CopyTo(array, index);
		}

		void IDictionary.Add(object key, object value)
		{
			JsonData value2 = ToJsonData(value);
			EnsureDictionary().Add(key, value2);
			KeyValuePair<string, JsonData> item = new KeyValuePair<string, JsonData>((string)key, value2);
			object_list.Add(item);
			json = null;
		}

		void IDictionary.Clear()
		{
			EnsureDictionary().Clear();
			object_list.Clear();
			json = null;
		}

		bool IDictionary.Contains(object key)
		{
			return EnsureDictionary().Contains(key);
		}

		IDictionaryEnumerator IDictionary.GetEnumerator()
		{
			return ((IOrderedDictionary)this).GetEnumerator();
		}

		void IDictionary.Remove(object key)
		{
			EnsureDictionary().Remove(key);
			for (int i = 0; i < object_list.Count; i++)
			{
				if (object_list[i].Key == (string)key)
				{
					object_list.RemoveAt(i);
					break;
				}
			}
			json = null;
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return EnsureCollection().GetEnumerator();
		}

		bool IJsonWrapper.GetBoolean()
		{
			if (type != JsonType.Boolean)
			{
				throw new InvalidOperationException("JsonData instance doesn't hold a boolean");
			}
			return inst_boolean;
		}

		double IJsonWrapper.GetDouble()
		{
			if (type != JsonType.Double)
			{
				throw new InvalidOperationException("JsonData instance doesn't hold a double");
			}
			return inst_double;
		}

		int IJsonWrapper.GetInt()
		{
			if (type != JsonType.Int)
			{
				throw new InvalidOperationException("JsonData instance doesn't hold an int");
			}
			return inst_int;
		}

		long IJsonWrapper.GetLong()
		{
			if (type != JsonType.Long)
			{
				throw new InvalidOperationException("JsonData instance doesn't hold a long");
			}
			return inst_long;
		}

		string IJsonWrapper.GetString()
		{
			if (type != JsonType.String)
			{
				throw new InvalidOperationException("JsonData instance doesn't hold a string");
			}
			return inst_string;
		}

		void IJsonWrapper.SetBoolean(bool val)
		{
			type = JsonType.Boolean;
			inst_boolean = val;
			json = null;
		}

		void IJsonWrapper.SetDouble(double val)
		{
			type = JsonType.Double;
			inst_double = val;
			json = null;
		}

		void IJsonWrapper.SetInt(int val)
		{
			type = JsonType.Int;
			inst_int = val;
			json = null;
		}

		void IJsonWrapper.SetLong(long val)
		{
			type = JsonType.Long;
			inst_long = val;
			json = null;
		}

		void IJsonWrapper.SetString(string val)
		{
			type = JsonType.String;
			inst_string = val;
			json = null;
		}

		string IJsonWrapper.ToJson()
		{
			return ToJson();
		}

		void IJsonWrapper.ToJson(JsonWriter writer)
		{
			ToJson(writer);
		}

		int IList.Add(object value)
		{
			return Add(value);
		}

		void IList.Clear()
		{
			EnsureList().Clear();
			json = null;
		}

		bool IList.Contains(object value)
		{
			return EnsureList().Contains(value);
		}

		int IList.IndexOf(object value)
		{
			return EnsureList().IndexOf(value);
		}

		void IList.Insert(int index, object value)
		{
			EnsureList().Insert(index, value);
			json = null;
		}

		void IList.Remove(object value)
		{
			EnsureList().Remove(value);
			json = null;
		}

		void IList.RemoveAt(int index)
		{
			EnsureList().RemoveAt(index);
			json = null;
		}

		IDictionaryEnumerator IOrderedDictionary.GetEnumerator()
		{
			EnsureDictionary();
			return new OrderedDictionaryEnumerator(object_list.GetEnumerator());
		}

		void IOrderedDictionary.Insert(int idx, object key, object value)
		{
			string text = (string)key;
			JsonData value2 = (this[text] = ToJsonData(value));
			KeyValuePair<string, JsonData> item = new KeyValuePair<string, JsonData>(text, value2);
			object_list.Insert(idx, item);
		}

		void IOrderedDictionary.RemoveAt(int idx)
		{
			EnsureDictionary();
			inst_object.Remove(object_list[idx].Key);
			object_list.RemoveAt(idx);
		}

		private ICollection EnsureCollection()
		{
			if (type == JsonType.Array)
			{
				return (ICollection)inst_array;
			}
			if (type == JsonType.Object)
			{
				return (ICollection)inst_object;
			}
			throw new InvalidOperationException("The JsonData instance has to be initialized first");
		}

		private IDictionary EnsureDictionary()
		{
			if (type == JsonType.Object)
			{
				return (IDictionary)inst_object;
			}
			if (type != 0)
			{
				throw new InvalidOperationException("Instance of JsonData is not a dictionary");
			}
			type = JsonType.Object;
			inst_object = new Dictionary<string, JsonData>();
			object_list = new List<KeyValuePair<string, JsonData>>();
			return (IDictionary)inst_object;
		}

		private IList EnsureList()
		{
			if (type == JsonType.Array)
			{
				return (IList)inst_array;
			}
			if (type != 0)
			{
				throw new InvalidOperationException("Instance of JsonData is not a list");
			}
			type = JsonType.Array;
			inst_array = new List<JsonData>();
			return (IList)inst_array;
		}

		private JsonData ToJsonData(object obj)
		{
			if (obj == null)
			{
				return null;
			}
			if (obj is JsonData)
			{
				return (JsonData)obj;
			}
			return new JsonData(obj);
		}

		private static void WriteJson(IJsonWrapper obj, JsonWriter writer)
		{
			if (obj.IsString)
			{
				writer.Write(obj.GetString());
			}
			else if (obj.IsBoolean)
			{
				writer.Write(obj.GetBoolean());
			}
			else if (obj.IsDouble)
			{
				writer.Write(obj.GetDouble());
			}
			else if (obj.IsInt)
			{
				writer.Write(obj.GetInt());
			}
			else if (obj.IsLong)
			{
				writer.Write(obj.GetLong());
			}
			else if (obj.IsArray)
			{
				writer.WriteArrayStart();
				foreach (JsonData item in (IEnumerable)obj)
				{
					WriteJson(item, writer);
				}
				writer.WriteArrayEnd();
			}
			else
			{
				if (!obj.IsObject)
				{
					return;
				}
				writer.WriteObjectStart();
				foreach (DictionaryEntry item2 in (IDictionary)obj)
				{
					writer.WritePropertyName((string)item2.Key);
					WriteJson((JsonData)item2.Value, writer);
				}
				writer.WriteObjectEnd();
			}
		}

		public int Add(object value)
		{
			JsonData value2 = ToJsonData(value);
			json = null;
			return EnsureList().Add(value2);
		}

		public void Clear()
		{
			if (IsObject)
			{
				((IDictionary)this).Clear();
			}
			else if (IsArray)
			{
				((IList)this).Clear();
			}
		}

		public bool Equals(JsonData x)
		{
			if (x == null)
			{
				return false;
			}
			if (x.type != type)
			{
				return false;
			}
			return type switch
			{
				JsonType.None => true, 
				JsonType.Object => inst_object.Equals(x.inst_object), 
				JsonType.Array => inst_array.Equals(x.inst_array), 
				JsonType.String => inst_string.Equals(x.inst_string), 
				JsonType.Int => inst_int.Equals(x.inst_int), 
				JsonType.Long => inst_long.Equals(x.inst_long), 
				JsonType.Double => inst_double.Equals(x.inst_double), 
				JsonType.Boolean => inst_boolean.Equals(x.inst_boolean), 
				_ => false, 
			};
		}

		public JsonType GetJsonType()
		{
			return type;
		}

		public void SetJsonType(JsonType type)
		{
			if (this.type != type)
			{
				switch (type)
				{
				case JsonType.Object:
					inst_object = new Dictionary<string, JsonData>();
					object_list = new List<KeyValuePair<string, JsonData>>();
					break;
				case JsonType.Array:
					inst_array = new List<JsonData>();
					break;
				case JsonType.String:
					inst_string = null;
					break;
				case JsonType.Int:
					inst_int = 0;
					break;
				case JsonType.Long:
					inst_long = 0L;
					break;
				case JsonType.Double:
					inst_double = 0.0;
					break;
				case JsonType.Boolean:
					inst_boolean = false;
					break;
				}
				this.type = type;
			}
		}

		public string ToJson()
		{
			if (json != null)
			{
				return json;
			}
			StringWriter stringWriter = new StringWriter();
			JsonWriter jsonWriter = new JsonWriter(stringWriter);
			jsonWriter.Validate = false;
			WriteJson(this, jsonWriter);
			json = stringWriter.ToString();
			return json;
		}

		public void ToJson(JsonWriter writer)
		{
			bool validate = writer.Validate;
			writer.Validate = false;
			WriteJson(this, writer);
			writer.Validate = validate;
		}

		public override string ToString()
		{
			return type switch
			{
				JsonType.Array => "JsonData array", 
				JsonType.Boolean => inst_boolean.ToString(), 
				JsonType.Double => inst_double.ToString(), 
				JsonType.Int => inst_int.ToString(), 
				JsonType.Long => inst_long.ToString(), 
				JsonType.Object => "JsonData object", 
				JsonType.String => inst_string, 
				_ => "Uninitialized JsonData", 
			};
		}
	}
	internal class OrderedDictionaryEnumerator : IDictionaryEnumerator, IEnumerator
	{
		private IEnumerator<KeyValuePair<string, JsonData>> list_enumerator;

		public object Current => Entry;

		public DictionaryEntry Entry
		{
			get
			{
				KeyValuePair<string, JsonData> current = list_enumerator.Current;
				return new DictionaryEntry(current.Key, current.Value);
			}
		}

		public object Key => list_enumerator.Current.Key;

		public object Value => list_enumerator.Current.Value;

		public OrderedDictionaryEnumerator(IEnumerator<KeyValuePair<string, JsonData>> enumerator)
		{
			list_enumerator = enumerator;
		}

		public bool MoveNext()
		{
			return list_enumerator.MoveNext();
		}

		public void Reset()
		{
			list_enumerator.Reset();
		}
	}
	public class JsonException : ApplicationException
	{
		public JsonException()
		{
		}

		internal JsonException(ParserToken token)
			: base($"Invalid token '{token}' in input string")
		{
		}

		internal JsonException(ParserToken token, Exception inner_exception)
			: base($"Invalid token '{token}' in input string", inner_exception)
		{
		}

		internal JsonException(int c)
			: base($"Invalid character '{(char)c}' in input string")
		{
		}

		internal JsonException(int c, Exception inner_exception)
			: base($"Invalid character '{(char)c}' in input string", inner_exception)
		{
		}

		public JsonException(string message)
			: base(message)
		{
		}

		public JsonException(string message, Exception inner_exception)
			: base(message, inner_exception)
		{
		}
	}
	internal struct PropertyMetadata
	{
		public MemberInfo Info;

		public bool IsField;

		public Type Type;
	}
	internal struct ArrayMetadata
	{
		private Type element_type;

		private bool is_array;

		private bool is_list;

		public Type ElementType
		{
			get
			{
				if (element_type == null)
				{
					return typeof(JsonData);
				}
				return element_type;
			}
			set
			{
				element_type = value;
			}
		}

		public bool IsArray
		{
			get
			{
				return is_array;
			}
			set
			{
				is_array = value;
			}
		}

		public bool IsList
		{
			get
			{
				return is_list;
			}
			set
			{
				is_list = value;
			}
		}
	}
	internal struct ObjectMetadata
	{
		private Type element_type;

		private bool is_dictionary;

		private IDictionary<string, PropertyMetadata> properties;

		public Type ElementType
		{
			get
			{
				if (element_type == null)
				{
					return typeof(JsonData);
				}
				return element_type;
			}
			set
			{
				element_type = value;
			}
		}

		public bool IsDictionary
		{
			get
			{
				return is_dictionary;
			}
			set
			{
				is_dictionary = value;
			}
		}

		public IDictionary<string, PropertyMetadata> Properties
		{
			get
			{
				return properties;
			}
			set
			{
				properties = value;
			}
		}
	}
	internal delegate void ExporterFunc(object obj, JsonWriter writer);
	public delegate void ExporterFunc<T>(T obj, JsonWriter writer);
	internal delegate object ImporterFunc(object input);
	public delegate TValue ImporterFunc<TJson, TValue>(TJson input);
	public delegate IJsonWrapper WrapperFactory();
	public class JsonMapper
	{
		private static int max_nesting_depth;

		private static IFormatProvider datetime_format;

		private static IDictionary<Type, ExporterFunc> base_exporters_table;

		private static IDictionary<Type, ExporterFunc> custom_exporters_table;

		private static IDictionary<Type, IDictionary<Type, ImporterFunc>> base_importers_table;

		private static IDictionary<Type, IDictionary<Type, ImporterFunc>> custom_importers_table;

		private static IDictionary<Type, ArrayMetadata> array_metadata;

		private static readonly object array_metadata_lock;

		private static IDictionary<Type, IDictionary<Type, MethodInfo>> conv_ops;

		private static readonly object conv_ops_lock;

		private static IDictionary<Type, ObjectMetadata> object_metadata;

		private static readonly object object_metadata_lock;

		private static IDictionary<Type, IList<PropertyMetadata>> type_properties;

		private static readonly object type_properties_lock;

		private static JsonWriter static_writer;

		private static readonly object static_writer_lock;

		static JsonMapper()
		{
			array_metadata_lock = new object();
			conv_ops_lock = new object();
			object_metadata_lock = new object();
			type_properties_lock = new object();
			static_writer_lock = new object();
			max_nesting_depth = 100;
			array_metadata = new Dictionary<Type, ArrayMetadata>();
			conv_ops = new Dictionary<Type, IDictionary<Type, MethodInfo>>();
			object_metadata = new Dictionary<Type, ObjectMetadata>();
			type_properties = new Dictionary<Type, IList<PropertyMetadata>>();
			static_writer = new JsonWriter();
			datetime_format = DateTimeFormatInfo.InvariantInfo;
			base_exporters_table = new Dictionary<Type, ExporterFunc>();
			custom_exporters_table = new Dictionary<Type, ExporterFunc>();
			base_importers_table = new Dictionary<Type, IDictionary<Type, ImporterFunc>>();
			custom_importers_table = new Dictionary<Type, IDictionary<Type, ImporterFunc>>();
			RegisterBaseExporters();
			RegisterBaseImporters();
		}

		private static void AddArrayMetadata(Type type)
		{
			if (array_metadata.ContainsKey(type))
			{
				return;
			}
			ArrayMetadata value = default(ArrayMetadata);
			value.IsArray = type.IsArray;
			if (type.GetInterface("System.Collections.IList") != null)
			{
				value.IsList = true;
			}
			PropertyInfo[] properties = type.GetProperties();
			foreach (PropertyInfo propertyInfo in properties)
			{
				if (!(propertyInfo.Name != "Item"))
				{
					ParameterInfo[] indexParameters = propertyInfo.GetIndexParameters();
					if (indexParameters.Length == 1 && indexParameters[0].ParameterType == typeof(int))
					{
						value.ElementType = propertyInfo.PropertyType;
					}
				}
			}
			lock (array_metadata_lock)
			{
				try
				{
					array_metadata.Add(type, value);
				}
				catch (ArgumentException)
				{
				}
			}
		}

		private static void AddObjectMetadata(Type type)
		{
			if (object_metadata.ContainsKey(type))
			{
				return;
			}
			ObjectMetadata value = default(ObjectMetadata);
			if (type.GetInterface("System.Collections.IDictionary") != null)
			{
				value.IsDictionary = true;
			}
			value.Properties = new Dictionary<string, PropertyMetadata>();
			PropertyInfo[] properties = type.GetProperties();
			foreach (PropertyInfo propertyInfo in properties)
			{
				if (propertyInfo.Name == "Item")
				{
					ParameterInfo[] indexParameters = propertyInfo.GetIndexParameters();
					if (indexParameters.Length == 1 && indexParameters[0].ParameterType == typeof(string))
					{
						value.ElementType = propertyInfo.PropertyType;
					}
				}
				else
				{
					PropertyMetadata value2 = default(PropertyMetadata);
					value2.Info = propertyInfo;
					value2.Type = propertyInfo.PropertyType;
					value.Properties.Add(propertyInfo.Name, value2);
				}
			}
			FieldInfo[] fields = type.GetFields();
			foreach (FieldInfo fieldInfo in fields)
			{
				PropertyMetadata value3 = default(PropertyMetadata);
				value3.Info = fieldInfo;
				value3.IsField = true;
				value3.Type = fieldInfo.FieldType;
				value.Properties.Add(fieldInfo.Name, value3);
			}
			lock (object_metadata_lock)
			{
				try
				{
					object_metadata.Add(type, value);
				}
				catch (ArgumentException)
				{
				}
			}
		}

		private static void AddTypeProperties(Type type)
		{
			if (type_properties.ContainsKey(type))
			{
				return;
			}
			IList<PropertyMetadata> list = new List<PropertyMetadata>();
			PropertyInfo[] properties = type.GetProperties();
			foreach (PropertyInfo propertyInfo in properties)
			{
				if (!(propertyInfo.Name == "Item"))
				{
					PropertyMetadata item = default(PropertyMetadata);
					item.Info = propertyInfo;
					item.IsField = false;
					list.Add(item);
				}
			}
			FieldInfo[] fields = type.GetFields();
			foreach (FieldInfo info in fields)
			{
				PropertyMetadata item2 = default(PropertyMetadata);
				item2.Info = info;
				item2.IsField = true;
				list.Add(item2);
			}
			lock (type_properties_lock)
			{
				try
				{
					type_properties.Add(type, list);
				}
				catch (ArgumentException)
				{
				}
			}
		}

		private static MethodInfo GetConvOp(Type t1, Type t2)
		{
			lock (conv_ops_lock)
			{
				if (!conv_ops.ContainsKey(t1))
				{
					conv_ops.Add(t1, new Dictionary<Type, MethodInfo>());
				}
			}
			if (conv_ops[t1].ContainsKey(t2))
			{
				return conv_ops[t1][t2];
			}
			MethodInfo method = t1.GetMethod("op_Implicit", new Type[1] { t2 });
			lock (conv_ops_lock)
			{
				try
				{
					conv_ops[t1].Add(t2, method);
					return method;
				}
				catch (ArgumentException)
				{
					return conv_ops[t1][t2];
				}
			}
		}

		private static object ReadValue(Type inst_type, JsonReader reader)
		{
			reader.Read();
			if (reader.Token == JsonToken.ArrayEnd)
			{
				return null;
			}
			if (reader.Token == JsonToken.Null)
			{
				if (!inst_type.IsClass)
				{
					throw new JsonException($"Can't assign null to an instance of type {inst_type}");
				}
				return null;
			}
			if (reader.Token == JsonToken.Double || reader.Token == JsonToken.Int || reader.Token == JsonToken.Long || reader.Token == JsonToken.String || reader.Token == JsonToken.Boolean)
			{
				Type type = reader.Value.GetType();
				if (inst_type.IsAssignableFrom(type))
				{
					return reader.Value;
				}
				if (custom_importers_table.ContainsKey(type) && custom_importers_table[type].ContainsKey(inst_type))
				{
					return custom_importers_table[type][inst_type](reader.Value);
				}
				if (base_importers_table.ContainsKey(type) && base_importers_table[type].ContainsKey(inst_type))
				{
					return base_importers_table[type][inst_type](reader.Value);
				}
				if (inst_type.IsEnum)
				{
					return Enum.ToObject(inst_type, reader.Value);
				}
				MethodInfo convOp = GetConvOp(inst_type, type);
				if (convOp != null)
				{
					return convOp.Invoke(null, new object[1] { reader.Value });
				}
				throw new JsonException($"Can't assign value '{reader.Value}' (type {type}) to type {inst_type}");
			}
			object obj = null;
			if (reader.Token == JsonToken.ArrayStart)
			{
				AddArrayMetadata(inst_type);
				ArrayMetadata arrayMetadata = array_metadata[inst_type];
				if (!arrayMetadata.IsArray && !arrayMetadata.IsList)
				{
					throw new JsonException($"Type {inst_type} can't act as an array");
				}
				IList list;
				Type elementType;
				if (!arrayMetadata.IsArray)
				{
					list = (IList)Activator.CreateInstance(inst_type);
					elementType = arrayMetadata.ElementType;
				}
				else
				{
					list = new ArrayList();
					elementType = inst_type.GetElementType();
				}
				while (true)
				{
					object value = ReadValue(elementType, reader);
					if (reader.Token == JsonToken.ArrayEnd)
					{
						break;
					}
					list.Add(value);
				}
				if (arrayMetadata.IsArray)
				{
					int count = list.Count;
					obj = Array.CreateInstance(elementType, count);
					for (int i = 0; i < count; i++)
					{
						((Array)obj).SetValue(list[i], i);
					}
				}
				else
				{
					obj = list;
				}
			}
			else if (reader.Token == JsonToken.ObjectStart)
			{
				AddObjectMetadata(inst_type);
				ObjectMetadata objectMetadata = object_metadata[inst_type];
				obj = Activator.CreateInstance(inst_type);
				while (true)
				{
					reader.Read();
					if (reader.Token == JsonToken.ObjectEnd)
					{
						break;
					}
					string key = (string)reader.Value;
					if (objectMetadata.Properties.ContainsKey(key))
					{
						PropertyMetadata propertyMetadata = objectMetadata.Properties[key];
						if (propertyMetadata.IsField)
						{
							((FieldInfo)propertyMetadata.Info).SetValue(obj, ReadValue(propertyMetadata.Type, reader));
							continue;
						}
						PropertyInfo propertyInfo = (PropertyInfo)propertyMetadata.Info;
						if (propertyInfo.CanWrite)
						{
							propertyInfo.SetValue(obj, ReadValue(propertyMetadata.Type, reader), null);
						}
						else
						{
							ReadValue(propertyMetadata.Type, reader);
						}
					}
					else if (!objectMetadata.IsDictionary)
					{
						ReadValue(typeof(object), reader);
					}
					else
					{
						((IDictionary)obj).Add(key, ReadValue(objectMetadata.ElementType, reader));
					}
				}
			}
			return obj;
		}

		private static IJsonWrapper ReadValue(WrapperFactory factory, JsonReader reader)
		{
			reader.Read();
			if (reader.Token == JsonToken.ArrayEnd || reader.Token == JsonToken.Null)
			{
				return null;
			}
			IJsonWrapper jsonWrapper = factory();
			if (reader.Token == JsonToken.String)
			{
				jsonWrapper.SetString((string)reader.Value);
				return jsonWrapper;
			}
			if (reader.Token == JsonToken.Double)
			{
				jsonWrapper.SetDouble((double)reader.Value);
				return jsonWrapper;
			}
			if (reader.Token == JsonToken.Int)
			{
				jsonWrapper.SetInt((int)reader.Value);
				return jsonWrapper;
			}
			if (reader.Token == JsonToken.Long)
			{
				jsonWrapper.SetLong((long)reader.Value);
				return jsonWrapper;
			}
			if (reader.Token == JsonToken.Boolean)
			{
				jsonWrapper.SetBoolean((bool)reader.Value);
				return jsonWrapper;
			}
			if (reader.Token == JsonToken.ArrayStart)
			{
				jsonWrapper.SetJsonType(JsonType.Array);
				while (true)
				{
					IJsonWrapper value = ReadValue(factory, reader);
					if (reader.Token == JsonToken.ArrayEnd)
					{
						break;
					}
					jsonWrapper.Add(value);
				}
			}
			else if (reader.Token == JsonToken.ObjectStart)
			{
				jsonWrapper.SetJsonType(JsonType.Object);
				while (true)
				{
					reader.Read();
					if (reader.Token == JsonToken.ObjectEnd)
					{
						break;
					}
					string key = (string)reader.Value;
					jsonWrapper[key] = ReadValue(factory, reader);
				}
			}
			return jsonWrapper;
		}

		private static void RegisterBaseExporters()
		{
			base_exporters_table[typeof(byte)] = delegate(object obj, JsonWriter writer)
			{
				writer.Write(Convert.ToInt32((byte)obj));
			};
			base_exporters_table[typeof(char)] = delegate(object obj, JsonWriter writer)
			{
				writer.Write(Convert.ToString((char)obj));
			};
			base_exporters_table[typeof(DateTime)] = delegate(object obj, JsonWriter writer)
			{
				writer.Write(Convert.ToString((DateTime)obj, datetime_format));
			};
			base_exporters_table[typeof(decimal)] = delegate(object obj, JsonWriter writer)
			{
				writer.Write((decimal)obj);
			};
			base_exporters_table[typeof(sbyte)] = delegate(object obj, JsonWriter writer)
			{
				writer.Write(Convert.ToInt32((sbyte)obj));
			};
			base_exporters_table[typeof(short)] = delegate(object obj, JsonWriter writer)
			{
				writer.Write(Convert.ToInt32((short)obj));
			};
			base_exporters_table[typeof(ushort)] = delegate(object obj, JsonWriter writer)
			{
				writer.Write(Convert.ToInt32((ushort)obj));
			};
			base_exporters_table[typeof(uint)] = delegate(object obj, JsonWriter writer)
			{
				writer.Write(Convert.ToUInt64((uint)obj));
			};
			base_exporters_table[typeof(ulong)] = delegate(object obj, JsonWriter writer)
			{
				writer.Write((ulong)obj);
			};
			base_exporters_table[typeof(float)] = delegate(object obj, JsonWriter writer)
			{
				writer.Write((float)obj);
			};
		}

		private static void RegisterBaseImporters()
		{
			ImporterFunc importer = (object input) => Convert.ToByte((int)input);
			RegisterImporter(base_importers_table, typeof(int), typeof(byte), importer);
			importer = (object input) => Convert.ToUInt64((int)input);
			RegisterImporter(base_importers_table, typeof(int), typeof(ulong), importer);
			importer = (object input) => Convert.ToSByte((int)input);
			RegisterImporter(base_importers_table, typeof(int), typeof(sbyte), importer);
			importer = (object input) => Convert.ToInt16((int)input);
			RegisterImporter(base_importers_table, typeof(int), typeof(short), importer);
			importer = (object input) => Convert.ToUInt16((int)input);
			RegisterImporter(base_importers_table, typeof(int), typeof(ushort), importer);
			importer = (object input) => Convert.ToUInt32((int)input);
			RegisterImporter(base_importers_table, typeof(int), typeof(uint), importer);
			importer = (object input) => Convert.ToSingle((int)input);
			RegisterImporter(base_importers_table, typeof(int), typeof(float), importer);
			importer = (object input) => Convert.ToSingle((float)(double)input);
			RegisterImporter(base_importers_table, typeof(double), typeof(float), importer);
			importer = (object input) => Convert.ToDouble((int)input);
			RegisterImporter(base_importers_table, typeof(int), typeof(double), importer);
			importer = (object input) => Convert.ToDecimal((double)input);
			RegisterImporter(base_importers_table, typeof(double), typeof(decimal), importer);
			importer = (object input) => Convert.ToUInt32((long)input);
			RegisterImporter(base_importers_table, typeof(long), typeof(uint), importer);
			importer = (object input) => Convert.ToChar((string)input);
			RegisterImporter(base_importers_table, typeof(string), typeof(char), importer);
			importer = (object input) => Convert.ToDateTime((string)input, datetime_format);
			RegisterImporter(base_importers_table, typeof(string), typeof(DateTime), importer);
		}

		private static void RegisterImporter(IDictionary<Type, IDictionary<Type, ImporterFunc>> table, Type json_type, Type value_type, ImporterFunc importer)
		{
			if (!table.ContainsKey(json_type))
			{
				table.Add(json_type, new Dictionary<Type, ImporterFunc>());
			}
			table[json_type][value_type] = importer;
		}

		private static void WriteValue(object obj, JsonWriter writer, bool writer_is_private, int depth)
		{
			if (depth > max_nesting_depth)
			{
				throw new JsonException($"Max allowed object depth reached while trying to export from type {obj.GetType()}");
			}
			if (obj == null)
			{
				writer.Write(null);
				return;
			}
			if (obj is IJsonWrapper)
			{
				if (writer_is_private)
				{
					writer.TextWriter.Write(((IJsonWrapper)obj).ToJson());
				}
				else
				{
					((IJsonWrapper)obj).ToJson(writer);
				}
				return;
			}
			if (obj is string)
			{
				writer.Write((string)obj);
				return;
			}
			if (obj is double)
			{
				writer.Write((double)obj);
				return;
			}
			if (obj is int)
			{
				writer.Write((int)obj);
				return;
			}
			if (obj is bool)
			{
				writer.Write((bool)obj);
				return;
			}
			if (obj is long)
			{
				writer.Write((long)obj);
				return;
			}
			if (obj is Array)
			{
				writer.WriteArrayStart();
				foreach (object item in (Array)obj)
				{
					WriteValue(item, writer, writer_is_private, depth + 1);
				}
				writer.WriteArrayEnd();
				return;
			}
			if (obj is IList)
			{
				writer.WriteArrayStart();
				foreach (object item2 in (IList)obj)
				{
					WriteValue(item2, writer, writer_is_private, depth + 1);
				}
				writer.WriteArrayEnd();
				return;
			}
			if (obj is IDictionary)
			{
				writer.WriteObjectStart();
				foreach (DictionaryEntry item3 in (IDictionary)obj)
				{
					writer.WritePropertyName((string)item3.Key);
					WriteValue(item3.Value, writer, writer_is_private, depth + 1);
				}
				writer.WriteObjectEnd();
				return;
			}
			Type type = obj.GetType();
			if (custom_exporters_table.ContainsKey(type))
			{
				custom_exporters_table[type](obj, writer);
				return;
			}
			if (base_exporters_table.ContainsKey(type))
			{
				base_exporters_table[type](obj, writer);
				return;
			}
			if (obj is Enum)
			{
				Type underlyingType = Enum.GetUnderlyingType(type);
				if (underlyingType == typeof(long) || underlyingType == typeof(uint) || underlyingType == typeof(ulong))
				{
					writer.Write((ulong)obj);
				}
				else
				{
					writer.Write((int)obj);
				}
				return;
			}
			AddTypeProperties(type);
			IList<PropertyMetadata> list = type_properties[type];
			writer.WriteObjectStart();
			foreach (PropertyMetadata item4 in list)
			{
				if (item4.IsField)
				{
					writer.WritePropertyName(item4.Info.Name);
					WriteValue(((FieldInfo)item4.Info).GetValue(obj), writer, writer_is_private, depth + 1);
					continue;
				}
				PropertyInfo propertyInfo = (PropertyInfo)item4.Info;
				if (propertyInfo.CanRead)
				{
					writer.WritePropertyName(item4.Info.Name);
					WriteValue(propertyInfo.GetValue(obj, null), writer, writer_is_private, depth + 1);
				}
			}
			writer.WriteObjectEnd();
		}

		public static string ToJson(object obj)
		{
			lock (static_writer_lock)
			{
				static_writer.Reset();
				WriteValue(obj, static_writer, writer_is_private: true, 0);
				return static_writer.ToString();
			}
		}

		public static void ToJson(object obj, JsonWriter writer)
		{
			WriteValue(obj, writer, writer_is_private: false, 0);
		}

		public static JsonData ToObject(JsonReader reader)
		{
			return (JsonData)ToWrapper(() => new JsonData(), reader);
		}

		public static JsonData ToObject(TextReader reader)
		{
			JsonReader reader2 = new JsonReader(reader);
			return (JsonData)ToWrapper(() => new JsonData(), reader2);
		}

		public static JsonData ToObject(string json)
		{
			return (JsonData)ToWrapper(() => new JsonData(), json);
		}

		public static T ToObject<T>(JsonReader reader)
		{
			return (T)ReadValue(typeof(T), reader);
		}

		public static T ToObject<T>(TextReader reader)
		{
			JsonReader reader2 = new JsonReader(reader);
			return (T)ReadValue(typeof(T), reader2);
		}

		public static T ToObject<T>(string json)
		{
			JsonReader reader = new JsonReader(json);
			return (T)ReadValue(typeof(T), reader);
		}

		public static IJsonWrapper ToWrapper(WrapperFactory factory, JsonReader reader)
		{
			return ReadValue(factory, reader);
		}

		public static IJsonWrapper ToWrapper(WrapperFactory factory, string json)
		{
			JsonReader reader = new JsonReader(json);
			return ReadValue(factory, reader);
		}

		public static void RegisterExporter<T>(ExporterFunc<T> exporter)
		{
			ExporterFunc value = delegate(object obj, JsonWriter writer)
			{
				exporter((T)obj, writer);
			};
			custom_exporters_table[typeof(T)] = value;
		}

		public static void RegisterImporter<TJson, TValue>(ImporterFunc<TJson, TValue> importer)
		{
			ImporterFunc importer2 = (object input) => importer((TJson)input);
			RegisterImporter(custom_importers_table, typeof(TJson), typeof(TValue), importer2);
		}

		public static void UnregisterExporters()
		{
			custom_exporters_table.Clear();
		}

		public static void UnregisterImporters()
		{
			custom_importers_table.Clear();
		}
	}
	public enum JsonToken
	{
		None,
		ObjectStart,
		PropertyName,
		ObjectEnd,
		ArrayStart,
		ArrayEnd,
		Int,
		Long,
		Double,
		String,
		Boolean,
		Null
	}
	public class JsonReader
	{
		private static IDictionary<int, IDictionary<int, int[]>> parse_table;

		private Stack<int> automaton_stack;

		private int current_input;

		private int current_symbol;

		private bool end_of_json;

		private bool end_of_input;

		private Lexer lexer;

		private bool parser_in_string;

		private bool parser_return;

		private bool read_started;

		private TextReader reader;

		private bool reader_is_owned;

		private object token_value;

		private JsonToken token;

		public bool AllowComments
		{
			get
			{
				return lexer.AllowComments;
			}
			set
			{
				lexer.AllowComments = value;
			}
		}

		public bool AllowSingleQuotedStrings
		{
			get
			{
				return lexer.AllowSingleQuotedStrings;
			}
			set
			{
				lexer.AllowSingleQuotedStrings = value;
			}
		}

		public bool EndOfInput => end_of_input;

		public bool EndOfJson => end_of_json;

		public JsonToken Token => token;

		public object Value => token_value;

		static JsonReader()
		{
			PopulateParseTable();
		}

		public JsonReader(string json_text)
			: this(new StringReader(json_text), owned: true)
		{
		}

		public JsonReader(TextReader reader)
			: this(reader, owned: false)
		{
		}

		private JsonReader(TextReader reader, bool owned)
		{
			if (reader == null)
			{
				throw new ArgumentNullException("reader");
			}
			parser_in_string = false;
			parser_return = false;
			read_started = false;
			automaton_stack = new Stack<int>();
			automaton_stack.Push(65553);
			automaton_stack.Push(65543);
			lexer = new Lexer(reader);
			end_of_input = false;
			end_of_json = false;
			this.reader = reader;
			reader_is_owned = owned;
		}

		private static void PopulateParseTable()
		{
			parse_table = new Dictionary<int, IDictionary<int, int[]>>();
			TableAddRow(ParserToken.Array);
			TableAddCol(ParserToken.Array, 91, 91, 65549);
			TableAddRow(ParserToken.ArrayPrime);
			TableAddCol(ParserToken.ArrayPrime, 34, 65550, 65551, 93);
			TableAddCol(ParserToken.ArrayPrime, 91, 65550, 65551, 93);
			TableAddCol(ParserToken.ArrayPrime, 93, 93);
			TableAddCol(ParserToken.ArrayPrime, 123, 65550, 65551, 93);
			TableAddCol(ParserToken.ArrayPrime, 65537, 65550, 65551, 93);
			TableAddCol(ParserToken.ArrayPrime, 65538, 65550, 65551, 93);
			TableAddCol(ParserToken.ArrayPrime, 65539, 65550, 65551, 93);
			TableAddCol(ParserToken.ArrayPrime, 65540, 65550, 65551, 93);
			TableAddRow(ParserToken.Object);
			TableAddCol(ParserToken.Object, 123, 123, 65545);
			TableAddRow(ParserToken.ObjectPrime);
			TableAddCol(ParserToken.ObjectPrime, 34, 65546, 65547, 125);
			TableAddCol(ParserToken.ObjectPrime, 125, 125);
			TableAddRow(ParserToken.Pair);
			TableAddCol(ParserToken.Pair, 34, 65552, 58, 65550);
			TableAddRow(ParserToken.PairRest);
			TableAddCol(ParserToken.PairRest, 44, 44, 65546, 65547);
			TableAddCol(ParserToken.PairRest, 125, 65554);
			TableAddRow(ParserToken.String);
			TableAddCol(ParserToken.String, 34, 34, 65541, 34);
			TableAddRow(ParserToken.Text);
			TableAddCol(ParserToken.Text, 91, 65548);
			TableAddCol(ParserToken.Text, 123, 65544);
			TableAddRow(ParserToken.Value);
			TableAddCol(ParserToken.Value, 34, 65552);
			TableAddCol(ParserToken.Value, 91, 65548);
			TableAddCol(ParserToken.Value, 123, 65544);
			TableAddCol(ParserToken.Value, 65537, 65537);
			TableAddCol(ParserToken.Value, 65538, 65538);
			TableAddCol(ParserToken.Value, 65539, 65539);
			TableAddCol(ParserToken.Value, 65540, 65540);
			TableAddRow(ParserToken.ValueRest);
			TableAddCol(ParserToken.ValueRest, 44, 44, 65550, 65551);
			TableAddCol(ParserToken.ValueRest, 93, 65554);
		}

		private static void TableAddCol(ParserToken row, int col, params int[] symbols)
		{
			parse_table[(int)row].Add(col, symbols);
		}

		private static void TableAddRow(ParserToken rule)
		{
			parse_table.Add((int)rule, new Dictionary<int, int[]>());
		}

		private void ProcessNumber(string number)
		{
			int result2;
			long result3;
			if ((number.IndexOf('.') != -1 || number.IndexOf('e') != -1 || number.IndexOf('E') != -1) && double.TryParse(number, out var result))
			{
				token = JsonToken.Double;
				token_value = result;
			}
			else if (int.TryParse(number, out result2))
			{
				token = JsonToken.Int;
				token_value = result2;
			}
			else if (long.TryParse(number, out result3))
			{
				token = JsonToken.Long;
				token_value = result3;
			}
			else
			{
				token = JsonToken.Int;
				token_value = 0;
			}
		}

		private void ProcessSymbol()
		{
			if (current_symbol == 91)
			{
				token = JsonToken.ArrayStart;
				parser_return = true;
			}
			else if (current_symbol == 93)
			{
				token = JsonToken.ArrayEnd;
				parser_return = true;
			}
			else if (current_symbol == 123)
			{
				token = JsonToken.ObjectStart;
				parser_return = true;
			}
			else if (current_symbol == 125)
			{
				token = JsonToken.ObjectEnd;
				parser_return = true;
			}
			else if (current_symbol == 34)
			{
				if (parser_in_string)
				{
					parser_in_string = false;
					parser_return = true;
					return;
				}
				if (token == JsonToken.None)
				{
					token = JsonToken.String;
				}
				parser_in_string = true;
			}
			else if (current_symbol == 65541)
			{
				token_value = lexer.StringValue;
			}
			else if (current_symbol == 65539)
			{
				token = JsonToken.Boolean;
				token_value = false;
				parser_return = true;
			}
			else if (current_symbol == 65540)
			{
				token = JsonToken.Null;
				parser_return = true;
			}
			else if (current_symbol == 65537)
			{
				ProcessNumber(lexer.StringValue);
				parser_return = true;
			}
			else if (current_symbol == 65546)
			{
				token = JsonToken.PropertyName;
			}
			else if (current_symbol == 65538)
			{
				token = JsonToken.Boolean;
				token_value = true;
				parser_return = true;
			}
		}

		private bool ReadToken()
		{
			if (end_of_input)
			{
				return false;
			}
			lexer.NextToken();
			if (lexer.EndOfInput)
			{
				Close();
				return false;
			}
			current_input = lexer.Token;
			return true;
		}

		public void Close()
		{
			if (!end_of_input)
			{
				end_of_input = true;
				end_of_json = true;
				if (reader_is_owned)
				{
					reader.Close();
				}
				reader = null;
			}
		}

		public bool Read()
		{
			if (end_of_input)
			{
				return false;
			}
			if (end_of_json)
			{
				end_of_json = false;
				automaton_stack.Clear();
				automaton_stack.Push(65553);
				automaton_stack.Push(65543);
			}
			parser_in_string = false;
			parser_return = false;
			token = JsonToken.None;
			token_value = null;
			if (!read_started)
			{
				read_started = true;
				if (!ReadToken())
				{
					return false;
				}
			}
			while (true)
			{
				if (parser_return)
				{
					if (automaton_stack.Peek() == 65553)
					{
						end_of_json = true;
					}
					return true;
				}
				current_symbol = automaton_stack.Pop();
				ProcessSymbol();
				if (current_symbol == current_input)
				{
					if (!ReadToken())
					{
						break;
					}
					continue;
				}
				int[] array;
				try
				{
					array = parse_table[current_symbol][current_input];
				}
				catch (KeyNotFoundException inner_exception)
				{
					throw new JsonException((ParserToken)current_input, inner_exception);
				}
				if (array[0] != 65554)
				{
					for (int num = array.Length - 1; num >= 0; num--)
					{
						automaton_stack.Push(array[num]);
					}
				}
			}
			if (automaton_stack.Peek() != 65553)
			{
				throw new JsonException("Input doesn't evaluate to proper JSON text");
			}
			if (parser_return)
			{
				return true;
			}
			return false;
		}
	}
	internal class FsmContext
	{
		public bool Return;

		public int NextState;

		public Lexer L;

		public int StateStack;
	}
	internal class Lexer
	{
		private delegate bool StateHandler(FsmContext ctx);

		private static int[] fsm_return_table;

		private static StateHandler[] fsm_handler_table;

		private bool allow_comments;

		private bool allow_single_quoted_strings;

		private bool end_of_input;

		private FsmContext fsm_context;

		private int input_buffer;

		private int input_char;

		private TextReader reader;

		private int state;

		private StringBuilder string_buffer;

		private string string_value;

		private int token;

		private int unichar;

		public bool AllowComments
		{
			get
			{
				return allow_comments;
			}
			set
			{
				allow_comments = value;
			}
		}

		public bool AllowSingleQuotedStrings
		{
			get
			{
				return allow_single_quoted_strings;
			}
			set
			{
				allow_single_quoted_strings = value;
			}
		}

		public bool EndOfInput => end_of_input;

		public int Token => token;

		public string StringValue => string_value;

		static Lexer()
		{
			PopulateFsmTables();
		}

		public Lexer(TextReader reader)
		{
			allow_comments = true;
			allow_single_quoted_strings = true;
			input_buffer = 0;
			string_buffer = new StringBuilder(128);
			state = 1;
			end_of_input = false;
			this.reader = reader;
			fsm_context = new FsmContext();
			fsm_context.L = this;
		}

		private static int HexValue(int digit)
		{
			switch (digit)
			{
			case 65:
			case 97:
				return 10;
			case 66:
			case 98:
				return 11;
			case 67:
			case 99:
				return 12;
			case 68:
			case 100:
				return 13;
			case 69:
			case 101:
				return 14;
			case 70:
			case 102:
				return 15;
			default:
				return digit - 48;
			}
		}

		private static void PopulateFsmTables()
		{
			fsm_handler_table = new StateHandler[28]
			{
				State1, State2, State3, State4, State5, State6, State7, State8, State9, State10,
				State11, State12, State13, State14, State15, State16, State17, State18, State19, State20,
				State21, State22, State23, State24, State25, State26, State27, State28
			};
			fsm_return_table = new int[28]
			{
				65542, 0, 65537, 65537, 0, 65537, 0, 65537, 0, 0,
				65538, 0, 0, 0, 65539, 0, 0, 65540, 65541, 65542,
				0, 0, 65541, 65542, 0, 0, 0, 0
			};
		}

		private static char ProcessEscChar(int esc_char)
		{
			switch (esc_char)
			{
			case 34:
			case 39:
			case 47:
			case 92:
				return Convert.ToChar(esc_char);
			case 110:
				return '\n';
			case 116:
				return '\t';
			case 114:
				return '\r';
			case 98:
				return '\b';
			case 102:
				return '\f';
			default:
				return '?';
			}
		}

		private static bool State1(FsmContext ctx)
		{
			while (ctx.L.GetChar())
			{
				if (ctx.L.input_char == 32 || (ctx.L.input_char >= 9 && ctx.L.input_char <= 13))
				{
					continue;
				}
				if (ctx.L.input_char >= 49 && ctx.L.input_char <= 57)
				{
					ctx.L.string_buffer.Append((char)ctx.L.input_char);
					ctx.NextState = 3;
					return true;
				}
				switch (ctx.L.input_char)
				{
				case 34:
					ctx.NextState = 19;
					ctx.Return = true;
					return true;
				case 44:
				case 58:
				case 91:
				case 93:
				case 123:
				case 125:
					ctx.NextState = 1;
					ctx.Return = true;
					return true;
				case 45:
					ctx.L.string_buffer.Append((char)ctx.L.input_char);
					ctx.NextState = 2;
					return true;
				case 48:
					ctx.L.string_buffer.Append((char)ctx.L.input_char);
					ctx.NextState = 4;
					return true;
				case 102:
					ctx.NextState = 12;
					return true;
				case 110:
					ctx.NextState = 16;
					return true;
				case 116:
					ctx.NextState = 9;
					return true;
				case 39:
					if (!ctx.L.allow_single_quoted_strings)
					{
						return false;
					}
					ctx.L.input_char = 34;
					ctx.NextState = 23;
					ctx.Return = true;
					return true;
				case 47:
					if (!ctx.L.allow_comments)
					{
						return false;
					}
					ctx.NextState = 25;
					return true;
				default:
					return false;
				}
			}
			return true;
		}

		private static bool State2(FsmContext ctx)
		{
			ctx.L.GetChar();
			if (ctx.L.input_char >= 49 && ctx.L.input_char <= 57)
			{
				ctx.L.string_buffer.Append((char)ctx.L.input_char);
				ctx.NextState = 3;
				return true;
			}
			int num = ctx.L.input_char;
			if (num == 48)
			{
				ctx.L.string_buffer.Append((char)ctx.L.input_char);
				ctx.NextState = 4;
				return true;
			}
			return false;
		}

		private static bool State3(FsmContext ctx)
		{
			while (ctx.L.GetChar())
			{
				if (ctx.L.input_char >= 48 && ctx.L.input_char <= 57)
				{
					ctx.L.string_buffer.Append((char)ctx.L.input_char);
					continue;
				}
				if (ctx.L.input_char == 32 || (ctx.L.input_char >= 9 && ctx.L.input_char <= 13))
				{
					ctx.Return = true;
					ctx.NextState = 1;
					return true;
				}
				switch (ctx.L.input_char)
				{
				case 44:
				case 93:
				case 125:
					ctx.L.UngetChar();
					ctx.Return = true;
					ctx.NextState = 1;
					return true;
				case 46:
					ctx.L.string_buffer.Append((char)ctx.L.input_char);
					ctx.NextState = 5;
					return true;
				case 69:
				case 101:
					ctx.L.string_buffer.Append((char)ctx.L.input_char);
					ctx.NextState = 7;
					return true;
				default:
					return false;
				}
			}
			return true;
		}

		private static bool State4(FsmContext ctx)
		{
			ctx.L.GetChar();
			if (ctx.L.input_char == 32 || (ctx.L.input_char >= 9 && ctx.L.input_char <= 13))
			{
				ctx.Return = true;
				ctx.NextState = 1;
				return true;
			}
			switch (ctx.L.input_char)
			{
			case 44:
			case 93:
			case 125:
				ctx.L.UngetChar();
				ctx.Return = true;
				ctx.NextState = 1;
				return true;
			case 46:
				ctx.L.string_buffer.Append((char)ctx.L.input_char);
				ctx.NextState = 5;
				return true;
			case 69:
			case 101:
				ctx.L.string_buffer.Append((char)ctx.L.input_char);
				ctx.NextState = 7;
				return true;
			default:
				return false;
			}
		}

		private static bool State5(FsmContext ctx)
		{
			ctx.L.GetChar();
			if (ctx.L.input_char >= 48 && ctx.L.input_char <= 57)
			{
				ctx.L.string_buffer.Append((char)ctx.L.input_char);
				ctx.NextState = 6;
				return true;
			}
			return false;
		}

		private static bool State6(FsmContext ctx)
		{
			while (ctx.L.GetChar())
			{
				if (ctx.L.input_char >= 48 && ctx.L.input_char <= 57)
				{
					ctx.L.string_buffer.Append((char)ctx.L.input_char);
					continue;
				}
				if (ctx.L.input_char == 32 || (ctx.L.input_char >= 9 && ctx.L.input_char <= 13))
				{
					ctx.Return = true;
					ctx.NextState = 1;
					return true;
				}
				switch (ctx.L.input_char)
				{
				case 44:
				case 93:
				case 125:
					ctx.L.UngetChar();
					ctx.Return = true;
					ctx.NextState = 1;
					return true;
				case 69:
				case 101:
					ctx.L.string_buffer.Append((char)ctx.L.input_char);
					ctx.NextState = 7;
					return true;
				default:
					return false;
				}
			}
			return true;
		}

		private static bool State7(FsmContext ctx)
		{
			ctx.L.GetChar();
			if (ctx.L.input_char >= 48 && ctx.L.input_char <= 57)
			{
				ctx.L.string_buffer.Append((char)ctx.L.input_char);
				ctx.NextState = 8;
				return true;
			}
			int num = ctx.L.input_char;
			if (num == 43 || num == 45)
			{
				ctx.L.string_buffer.Append((char)ctx.L.input_char);
				ctx.NextState = 8;
				return true;
			}
			return false;
		}

		private static bool State8(FsmContext ctx)
		{
			while (ctx.L.GetChar())
			{
				if (ctx.L.input_char >= 48 && ctx.L.input_char <= 57)
				{
					ctx.L.string_buffer.Append((char)ctx.L.input_char);
					continue;
				}
				if (ctx.L.input_char == 32 || (ctx.L.input_char >= 9 && ctx.L.input_char <= 13))
				{
					ctx.Return = true;
					ctx.NextState = 1;
					return true;
				}
				int num = ctx.L.input_char;
				if (num == 44 || num == 93 || num == 125)
				{
					ctx.L.UngetChar();
					ctx.Return = true;
					ctx.NextState = 1;
					return true;
				}
				return false;
			}
			return true;
		}

		private static bool State9(FsmContext ctx)
		{
			ctx.L.GetChar();
			int num = ctx.L.input_char;
			if (num == 114)
			{
				ctx.NextState = 10;
				return true;
			}
			return false;
		}

		private static bool State10(FsmContext ctx)
		{
			ctx.L.GetChar();
			int num = ctx.L.input_char;
			if (num == 117)
			{
				ctx.NextState = 11;
				return true;
			}
			return false;
		}

		private static bool State11(FsmContext ctx)
		{
			ctx.L.GetChar();
			int num = ctx.L.input_char;
			if (num == 101)
			{
				ctx.Return = true;
				ctx.NextState = 1;
				return true;
			}
			return false;
		}

		private static bool State12(FsmContext ctx)
		{
			ctx.L.GetChar();
			int num = ctx.L.input_char;
			if (num == 97)
			{
				ctx.NextState = 13;
				return true;
			}
			return false;
		}

		private static bool State13(FsmContext ctx)
		{
			ctx.L.GetChar();
			int num = ctx.L.input_char;
			if (num == 108)
			{
				ctx.NextState = 14;
				return true;
			}
			return false;
		}

		private static bool State14(FsmContext ctx)
		{
			ctx.L.GetChar();
			int num = ctx.L.input_char;
			if (num == 115)
			{
				ctx.NextState = 15;
				return true;
			}
			return false;
		}

		private static bool State15(FsmContext ctx)
		{
			ctx.L.GetChar();
			int num = ctx.L.input_char;
			if (num == 101)
			{
				ctx.Return = true;
				ctx.NextState = 1;
				return true;
			}
			return false;
		}

		private static bool State16(FsmContext ctx)
		{
			ctx.L.GetChar();
			int num = ctx.L.input_char;
			if (num == 117)
			{
				ctx.NextState = 17;
				return true;
			}
			return false;
		}

		private static bool State17(FsmContext ctx)
		{
			ctx.L.GetChar();
			int num = ctx.L.input_char;
			if (num == 108)
			{
				ctx.NextState = 18;
				return true;
			}
			return false;
		}

		private static bool State18(FsmContext ctx)
		{
			ctx.L.GetChar();
			int num = ctx.L.input_char;
			if (num == 108)
			{
				ctx.Return = true;
				ctx.NextState = 1;
				return true;
			}
			return false;
		}

		private static bool State19(FsmContext ctx)
		{
			while (ctx.L.GetChar())
			{
				switch (ctx.L.input_char)
				{
				case 34:
					ctx.L.UngetChar();
					ctx.Return = true;
					ctx.NextState = 20;
					return true;
				case 92:
					ctx.StateStack = 19;
					ctx.NextState = 21;
					return true;
				}
				ctx.L.string_buffer.Append((char)ctx.L.input_char);
			}
			return true;
		}

		private static bool State20(FsmContext ctx)
		{
			ctx.L.GetChar();
			int num = ctx.L.input_char;
			if (num == 34)
			{
				ctx.Return = true;
				ctx.NextState = 1;
				return true;
			}
			return false;
		}

		private static bool State21(FsmContext ctx)
		{
			ctx.L.GetChar();
			switch (ctx.L.input_char)
			{
			case 117:
				ctx.NextState = 22;
				return true;
			case 34:
			case 39:
			case 47:
			case 92:
			case 98:
			case 102:
			case 110:
			case 114:
			case 116:
				ctx.L.string_buffer.Append(ProcessEscChar(ctx.L.input_char));
				ctx.NextState = ctx.StateStack;
				return true;
			default:
				return false;
			}
		}

		private static bool State22(FsmContext ctx)
		{
			int num = 0;
			int num2 = 4096;
			ctx.L.unichar = 0;
			while (ctx.L.GetChar())
			{
				if ((ctx.L.input_char >= 48 && ctx.L.input_char <= 57) || (ctx.L.input_char >= 65 && ctx.L.input_char <= 70) || (ctx.L.input_char >= 97 && ctx.L.input_char <= 102))
				{
					ctx.L.unichar += HexValue(ctx.L.input_char) * num2;
					num++;
					num2 /= 16;
					if (num == 4)
					{
						ctx.L.string_buffer.Append(Convert.ToChar(ctx.L.unichar));
						ctx.NextState = ctx.StateStack;
						return true;
					}
					continue;
				}
				return false;
			}
			return true;
		}

		private static bool State23(FsmContext ctx)
		{
			while (ctx.L.GetChar())
			{
				switch (ctx.L.input_char)
				{
				case 39:
					ctx.L.UngetChar();
					ctx.Return = true;
					ctx.NextState = 24;
					return true;
				case 92:
					ctx.StateStack = 23;
					ctx.NextState = 21;
					return true;
				}
				ctx.L.string_buffer.Append((char)ctx.L.input_char);
			}
			return true;
		}

		private static bool State24(FsmContext ctx)
		{
			ctx.L.GetChar();
			int num = ctx.L.input_char;
			if (num == 39)
			{
				ctx.L.input_char = 34;
				ctx.Return = true;
				ctx.NextState = 1;
				return true;
			}
			return false;
		}

		private static bool State25(FsmContext ctx)
		{
			ctx.L.GetChar();
			switch (ctx.L.input_char)
			{
			case 42:
				ctx.NextState = 27;
				return true;
			case 47:
				ctx.NextState = 26;
				return true;
			default:
				return false;
			}
		}

		private static bool State26(FsmContext ctx)
		{
			while (ctx.L.GetChar())
			{
				if (ctx.L.input_char == 10)
				{
					ctx.NextState = 1;
					return true;
				}
			}
			return true;
		}

		private static bool State27(FsmContext ctx)
		{
			while (ctx.L.GetChar())
			{
				if (ctx.L.input_char == 42)
				{
					ctx.NextState = 28;
					return true;
				}
			}
			return true;
		}

		private static bool State28(FsmContext ctx)
		{
			while (ctx.L.GetChar())
			{
				if (ctx.L.input_char != 42)
				{
					if (ctx.L.input_char == 47)
					{
						ctx.NextState = 1;
						return true;
					}
					ctx.NextState = 27;
					return true;
				}
			}
			return true;
		}

		private bool GetChar()
		{
			if ((input_char = NextChar()) != -1)
			{
				return true;
			}
			end_of_input = true;
			return false;
		}

		private int NextChar()
		{
			if (input_buffer != 0)
			{
				int result = input_buffer;
				input_buffer = 0;
				return result;
			}
			return reader.Read();
		}

		public bool NextToken()
		{
			fsm_context.Return = false;
			while (true)
			{
				if (!fsm_handler_table[state - 1](fsm_context))
				{
					throw new JsonException(input_char);
				}
				if (end_of_input)
				{
					return false;
				}
				if (fsm_context.Return)
				{
					break;
				}
				state = fsm_context.NextState;
			}
			string_value = string_buffer.ToString();
			string_buffer.Remove(0, string_buffer.Length);
			token = fsm_return_table[state - 1];
			if (token == 65542)
			{
				token = input_char;
			}
			state = fsm_context.NextState;
			return true;
		}

		private void UngetChar()
		{
			input_buffer = input_char;
		}
	}
	internal enum ParserToken
	{
		None = 65536,
		Number,
		True,
		False,
		Null,
		CharSeq,
		Char,
		Text,
		Object,
		ObjectPrime,
		Pair,
		PairRest,
		Array,
		ArrayPrime,
		Value,
		ValueRest,
		String,
		End,
		Epsilon
	}
	internal enum Condition
	{
		InArray,
		InObject,
		NotAProperty,
		Property,
		Value
	}
	internal class WriterContext
	{
		public int Count;

		public bool InArray;

		public bool InObject;

		public bool ExpectingValue;

		public int Padding;
	}
	public class JsonWriter
	{
		private static NumberFormatInfo number_format;

		private WriterContext context;

		private Stack<WriterContext> ctx_stack;

		private bool has_reached_end;

		private char[] hex_seq;

		private int indentation;

		private int indent_value;

		private StringBuilder inst_string_builder;

		private bool pretty_print;

		private bool validate;

		private TextWriter writer;

		public int IndentValue
		{
			get
			{
				return indent_value;
			}
			set
			{
				indentation = indentation / indent_value * value;
				indent_value = value;
			}
		}

		public bool PrettyPrint
		{
			get
			{
				return pretty_print;
			}
			set
			{
				pretty_print = value;
			}
		}

		public TextWriter TextWriter => writer;

		public bool Validate
		{
			get
			{
				return validate;
			}
			set
			{
				validate = value;
			}
		}

		static JsonWriter()
		{
			number_format = NumberFormatInfo.InvariantInfo;
		}

		public JsonWriter()
		{
			inst_string_builder = new StringBuilder();
			writer = new StringWriter(inst_string_builder);
			Init();
		}

		public JsonWriter(StringBuilder sb)
			: this(new StringWriter(sb))
		{
		}

		public JsonWriter(TextWriter writer)
		{
			if (writer == null)
			{
				throw new ArgumentNullException("writer");
			}
			this.writer = writer;
			Init();
		}

		private void DoValidation(Condition cond)
		{
			if (!context.ExpectingValue)
			{
				context.Count++;
			}
			if (!validate)
			{
				return;
			}
			if (has_reached_end)
			{
				throw new JsonException("A complete JSON symbol has already been written");
			}
			switch (cond)
			{
			case Condition.InArray:
				if (!context.InArray)
				{
					throw new JsonException("Can't close an array here");
				}
				break;
			case Condition.InObject:
				if (!context.InObject || context.ExpectingValue)
				{
					throw new JsonException("Can't close an object here");
				}
				break;
			case Condition.NotAProperty:
				if (context.InObject && !context.ExpectingValue)
				{
					throw new JsonException("Expected a property");
				}
				break;
			case Condition.Property:
				if (!context.InObject || context.ExpectingValue)
				{
					throw new JsonException("Can't add a property here");
				}
				break;
			case Condition.Value:
				if (!context.InArray && (!context.InObject || !context.ExpectingValue))
				{
					throw new JsonException("Can't add a value here");
				}
				break;
			}
		}

		private void Init()
		{
			has_reached_end = false;
			hex_seq = new char[4];
			indentation = 0;
			indent_value = 4;
			pretty_print = false;
			validate = true;
			ctx_stack = new Stack<WriterContext>();
			context = new WriterContext();
			ctx_stack.Push(context);
		}

		private static void IntToHex(int n, char[] hex)
		{
			for (int i = 0; i < 4; i++)
			{
				int num = n % 16;
				if (num < 10)
				{
					hex[3 - i] = (char)(48 + num);
				}
				else
				{
					hex[3 - i] = (char)(65 + (num - 10));
				}
				n >>= 4;
			}
		}

		private void Indent()
		{
			if (pretty_print)
			{
				indentation += indent_value;
			}
		}

		private void Put(string str)
		{
			if (pretty_print && !context.ExpectingValue)
			{
				for (int i = 0; i < indentation; i++)
				{
					writer.Write(' ');
				}
			}
			writer.Write(str);
		}

		private void PutNewline()
		{
			PutNewline(add_comma: true);
		}

		private void PutNewline(bool add_comma)
		{
			if (add_comma && !context.ExpectingValue && context.Count > 1)
			{
				writer.Write(',');
			}
			if (pretty_print && !context.ExpectingValue)
			{
				writer.Write('\n');
			}
		}

		private void PutString(string str)
		{
			Put(string.Empty);
			writer.Write('"');
			int length = str.Length;
			for (int i = 0; i < length; i++)
			{
				switch (str[i])
				{
				case '\n':
					writer.Write("\\n");
					continue;
				case '\r':
					writer.Write("\\r");
					continue;
				case '\t':
					writer.Write("\\t");
					continue;
				case '"':
				case '\\':
					writer.Write('\\');
					writer.Write(str[i]);
					continue;
				case '\f':
					writer.Write("\\f");
					continue;
				case '\b':
					writer.Write("\\b");
					continue;
				}
				if (str[i] >= ' ' && str[i] <= '~')
				{
					writer.Write(str[i]);
					continue;
				}
				IntToHex(str[i], hex_seq);
				writer.Write("\\u");
				writer.Write(hex_seq);
			}
			writer.Write('"');
		}

		private void Unindent()
		{
			if (pretty_print)
			{
				indentation -= indent_value;
			}
		}

		public override string ToString()
		{
			if (inst_string_builder == null)
			{
				return string.Empty;
			}
			return inst_string_builder.ToString();
		}

		public void Reset()
		{
			has_reached_end = false;
			ctx_stack.Clear();
			context = new WriterContext();
			ctx_stack.Push(context);
			if (inst_string_builder != null)
			{
				inst_string_builder.Remove(0, inst_string_builder.Length);
			}
		}

		public void Write(bool boolean)
		{
			DoValidation(Condition.Value);
			PutNewline();
			Put(boolean ? "true" : "false");
			context.ExpectingValue = false;
		}

		public void Write(decimal number)
		{
			DoValidation(Condition.Value);
			PutNewline();
			Put(Convert.ToString(number, number_format));
			context.ExpectingValue = false;
		}

		public void Write(double number)
		{
			DoValidation(Condition.Value);
			PutNewline();
			string text = Convert.ToString(number, number_format);
			Put(text);
			if (text.IndexOf('.') == -1 && text.IndexOf('E') == -1)
			{
				writer.Write(".0");
			}
			context.ExpectingValue = false;
		}

		public void Write(int number)
		{
			DoValidation(Condition.Value);
			PutNewline();
			Put(Convert.ToString(number, number_format));
			context.ExpectingValue = false;
		}

		public void Write(long number)
		{
			DoValidation(Condition.Value);
			PutNewline();
			Put(Convert.ToString(number, number_format));
			context.ExpectingValue = false;
		}

		public void Write(string str)
		{
			DoValidation(Condition.Value);
			PutNewline();
			if (str == null)
			{
				Put("null");
			}
			else
			{
				PutString(str);
			}
			context.ExpectingValue = false;
		}

		public void Write(ulong number)
		{
			DoValidation(Condition.Value);
			PutNewline();
			Put(Convert.ToString(number, number_format));
			context.ExpectingValue = false;
		}

		public void WriteArrayEnd()
		{
			DoValidation(Condition.InArray);
			PutNewline(add_comma: false);
			ctx_stack.Pop();
			if (ctx_stack.Count == 1)
			{
				has_reached_end = true;
			}
			else
			{
				context = ctx_stack.Peek();
				context.ExpectingValue = false;
			}
			Unindent();
			Put("]");
		}

		public void WriteArrayStart()
		{
			DoValidation(Condition.NotAProperty);
			PutNewline();
			Put("[");
			context = new WriterContext();
			context.InArray = true;
			ctx_stack.Push(context);
			Indent();
		}

		public void WriteObjectEnd()
		{
			DoValidation(Condition.InObject);
			PutNewline(add_comma: false);
			ctx_stack.Pop();
			if (ctx_stack.Count == 1)
			{
				has_reached_end = true;
			}
			else
			{
				context = ctx_stack.Peek();
				context.ExpectingValue = false;
			}
			Unindent();
			Put("}");
		}

		public void WriteObjectStart()
		{
			DoValidation(Condition.NotAProperty);
			PutNewline();
			Put("{");
			context = new WriterContext();
			context.InObject = true;
			ctx_stack.Push(context);
			Indent();
		}

		public void WritePropertyName(string property_name)
		{
			DoValidation(Condition.Property);
			PutNewline();
			PutString(property_name);
			if (pretty_print)
			{
				if (property_name.Length > context.Padding)
				{
					context.Padding = property_name.Length;
				}
				for (int num = context.Padding - property_name.Length; num >= 0; num--)
				{
					writer.Write(' ');
				}
				writer.Write(": ");
			}
			else
			{
				writer.Write(':');
			}
			context.ExpectingValue = true;
		}
	}
}
namespace UnityStandardAssets.Water
{
	[ExecuteInEditMode]
	public class WaterBasic : MonoBehaviour
	{
		private void Update()
		{
			Renderer component = GetComponent<Renderer>();
			if ((bool)component)
			{
				Material sharedMaterial = component.sharedMaterial;
				if ((bool)sharedMaterial)
				{
					Vector4 vector = sharedMaterial.GetVector("WaveSpeed");
					float @float = sharedMaterial.GetFloat("_WaveScale");
					float num = Time.time / 20f;
					Vector4 vector2 = vector * (num * @float);
					Vector4 value = new Vector4(Mathf.Repeat(vector2.x, 1f), Mathf.Repeat(vector2.y, 1f), Mathf.Repeat(vector2.z, 1f), Mathf.Repeat(vector2.w, 1f));
					sharedMaterial.SetVector("_WaveOffset", value);
				}
			}
		}
	}
}
namespace UnityStandardAssets.ImageEffects
{
	public enum AAMode
	{
		FXAA2,
		FXAA3Console,
		FXAA1PresetA,
		FXAA1PresetB,
		NFAA,
		SSAA,
		DLAA
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Other/Antialiasing")]
	public class Antialiasing : PostEffectsBase
	{
		public AAMode mode = AAMode.FXAA3Console;

		public bool showGeneratedNormals;

		public float offsetScale = 0.2f;

		public float blurRadius = 18f;

		public float edgeThresholdMin = 0.05f;

		public float edgeThreshold = 0.2f;

		public float edgeSharpness = 4f;

		public bool dlaaSharp;

		public Shader ssaaShader;

		private Material ssaa;

		public Shader dlaaShader;

		private Material dlaa;

		public Shader nfaaShader;

		private Material nfaa;

		public Shader shaderFXAAPreset2;

		private Material materialFXAAPreset2;

		public Shader shaderFXAAPreset3;

		private Material materialFXAAPreset3;

		public Shader shaderFXAAII;

		private Material materialFXAAII;

		public Shader shaderFXAAIII;

		private Material materialFXAAIII;

		public Material CurrentAAMaterial()
		{
			Material material = null;
			return mode switch
			{
				AAMode.FXAA3Console => materialFXAAIII, 
				AAMode.FXAA2 => materialFXAAII, 
				AAMode.FXAA1PresetA => materialFXAAPreset2, 
				AAMode.FXAA1PresetB => materialFXAAPreset3, 
				AAMode.NFAA => nfaa, 
				AAMode.SSAA => ssaa, 
				AAMode.DLAA => dlaa, 
				_ => null, 
			};
		}

		public override bool CheckResources()
		{
			CheckSupport(needDepth: false);
			materialFXAAPreset2 = CreateMaterial(shaderFXAAPreset2, materialFXAAPreset2);
			materialFXAAPreset3 = CreateMaterial(shaderFXAAPreset3, materialFXAAPreset3);
			materialFXAAII = CreateMaterial(shaderFXAAII, materialFXAAII);
			materialFXAAIII = CreateMaterial(shaderFXAAIII, materialFXAAIII);
			nfaa = CreateMaterial(nfaaShader, nfaa);
			ssaa = CreateMaterial(ssaaShader, ssaa);
			dlaa = CreateMaterial(dlaaShader, dlaa);
			if (!ssaaShader.isSupported)
			{
				NotSupported();
				ReportAutoDisable();
			}
			return isSupported;
		}

		public void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources())
			{
				Graphics.Blit(source, destination);
			}
			else if (mode == AAMode.FXAA3Console && materialFXAAIII != null)
			{
				materialFXAAIII.SetFloat("_EdgeThresholdMin", edgeThresholdMin);
				materialFXAAIII.SetFloat("_EdgeThreshold", edgeThreshold);
				materialFXAAIII.SetFloat("_EdgeSharpness", edgeSharpness);
				Graphics.Blit(source, destination, materialFXAAIII);
			}
			else if (mode == AAMode.FXAA1PresetB && materialFXAAPreset3 != null)
			{
				Graphics.Blit(source, destination, materialFXAAPreset3);
			}
			else if (mode == AAMode.FXAA1PresetA && materialFXAAPreset2 != null)
			{
				source.anisoLevel = 4;
				Graphics.Blit(source, destination, materialFXAAPreset2);
				source.anisoLevel = 0;
			}
			else if (mode == AAMode.FXAA2 && materialFXAAII != null)
			{
				Graphics.Blit(source, destination, materialFXAAII);
			}
			else if (mode == AAMode.SSAA && ssaa != null)
			{
				Graphics.Blit(source, destination, ssaa);
			}
			else if (mode == AAMode.DLAA && dlaa != null)
			{
				source.anisoLevel = 0;
				RenderTexture temporary = RenderTexture.GetTemporary(source.width, source.height);
				Graphics.Blit(source, temporary, dlaa, 0);
				Graphics.Blit(temporary, destination, dlaa, (!dlaaSharp) ? 1 : 2);
				RenderTexture.ReleaseTemporary(temporary);
			}
			else if (mode == AAMode.NFAA && nfaa != null)
			{
				source.anisoLevel = 0;
				nfaa.SetFloat("_OffsetScale", offsetScale);
				nfaa.SetFloat("_BlurRadius", blurRadius);
				Graphics.Blit(source, destination, nfaa, showGeneratedNormals ? 1 : 0);
			}
			else
			{
				Graphics.Blit(source, destination);
			}
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Bloom and Glow/Bloom")]
	public class Bloom : PostEffectsBase
	{
		public enum LensFlareStyle
		{
			Ghosting,
			Anamorphic,
			Combined
		}

		public enum TweakMode
		{
			Basic,
			Complex
		}

		public enum HDRBloomMode
		{
			Auto,
			On,
			Off
		}

		public enum BloomScreenBlendMode
		{
			Screen,
			Add
		}

		public enum BloomQuality
		{
			Cheap,
			High
		}

		public TweakMode tweakMode;

		public BloomScreenBlendMode screenBlendMode = BloomScreenBlendMode.Add;

		public HDRBloomMode hdr;

		private bool doHdr;

		public float sepBlurSpread = 2.5f;

		public BloomQuality quality = BloomQuality.High;

		public float bloomIntensity = 0.5f;

		public float bloomThreshold = 0.5f;

		public Color bloomThresholdColor = Color.white;

		public int bloomBlurIterations = 2;

		public int hollywoodFlareBlurIterations = 2;

		public float flareRotation;

		public LensFlareStyle lensflareMode = LensFlareStyle.Anamorphic;

		public float hollyStretchWidth = 2.5f;

		public float lensflareIntensity;

		public float lensflareThreshold = 0.3f;

		public float lensFlareSaturation = 0.75f;

		public Color flareColorA = new Color(0.4f, 0.4f, 0.8f, 0.75f);

		public Color flareColorB = new Color(0.4f, 0.8f, 0.8f, 0.75f);

		public Color flareColorC = new Color(0.8f, 0.4f, 0.8f, 0.75f);

		public Color flareColorD = new Color(0.8f, 0.4f, 0f, 0.75f);

		public Texture2D lensFlareVignetteMask;

		public Shader lensFlareShader;

		private Material lensFlareMaterial;

		public Shader screenBlendShader;

		private Material screenBlend;

		public Shader blurAndFlaresShader;

		private Material blurAndFlaresMaterial;

		public Shader brightPassFilterShader;

		private Material brightPassFilterMaterial;

		public override bool CheckResources()
		{
			CheckSupport(needDepth: false);
			screenBlend = CheckShaderAndCreateMaterial(screenBlendShader, screenBlend);
			lensFlareMaterial = CheckShaderAndCreateMaterial(lensFlareShader, lensFlareMaterial);
			blurAndFlaresMaterial = CheckShaderAndCreateMaterial(blurAndFlaresShader, blurAndFlaresMaterial);
			brightPassFilterMaterial = CheckShaderAndCreateMaterial(brightPassFilterShader, brightPassFilterMaterial);
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		public void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources())
			{
				Graphics.Blit(source, destination);
				return;
			}
			doHdr = false;
			if (hdr == HDRBloomMode.Auto)
			{
				doHdr = source.format == RenderTextureFormat.ARGBHalf && GetComponent<Camera>().allowHDR;
			}
			else
			{
				doHdr = hdr == HDRBloomMode.On;
			}
			doHdr = doHdr && supportHDRTextures;
			BloomScreenBlendMode bloomScreenBlendMode = screenBlendMode;
			if (doHdr)
			{
				bloomScreenBlendMode = BloomScreenBlendMode.Add;
			}
			RenderTextureFormat format = (doHdr ? RenderTextureFormat.ARGBHalf : RenderTextureFormat.Default);
			int width = source.width / 2;
			int height = source.height / 2;
			int width2 = source.width / 4;
			int height2 = source.height / 4;
			float num = 1f * (float)source.width / (1f * (float)source.height);
			float num2 = 0.001953125f;
			RenderTexture temporary = RenderTexture.GetTemporary(width2, height2, 0, format);
			RenderTexture temporary2 = RenderTexture.GetTemporary(width, height, 0, format);
			if (quality > BloomQuality.Cheap)
			{
				Graphics.Blit(source, temporary2, screenBlend, 2);
				RenderTexture temporary3 = RenderTexture.GetTemporary(width2, height2, 0, format);
				Graphics.Blit(temporary2, temporary3, screenBlend, 2);
				Graphics.Blit(temporary3, temporary, screenBlend, 6);
				RenderTexture.ReleaseTemporary(temporary3);
			}
			else
			{
				Graphics.Blit(source, temporary2);
				Graphics.Blit(temporary2, temporary, screenBlend, 6);
			}
			RenderTexture.ReleaseTemporary(temporary2);
			RenderTexture renderTexture = RenderTexture.GetTemporary(width2, height2, 0, format);
			BrightFilter(bloomThreshold * bloomThresholdColor, temporary, renderTexture);
			if (bloomBlurIterations < 1)
			{
				bloomBlurIterations = 1;
			}
			else if (bloomBlurIterations > 10)
			{
				bloomBlurIterations = 10;
			}
			for (int i = 0; i < bloomBlurIterations; i++)
			{
				float num3 = (1f + (float)i * 0.25f) * sepBlurSpread;
				RenderTexture temporary4 = RenderTexture.GetTemporary(width2, height2, 0, format);
				blurAndFlaresMaterial.SetVector("_Offsets", new Vector4(0f, num3 * num2, 0f, 0f));
				Graphics.Blit(renderTexture, temporary4, blurAndFlaresMaterial, 4);
				RenderTexture.ReleaseTemporary(renderTexture);
				renderTexture = temporary4;
				temporary4 = RenderTexture.GetTemporary(width2, height2, 0, format);
				blurAndFlaresMaterial.SetVector("_Offsets", new Vector4(num3 / num * num2, 0f, 0f, 0f));
				Graphics.Blit(renderTexture, temporary4, blurAndFlaresMaterial, 4);
				RenderTexture.ReleaseTemporary(renderTexture);
				renderTexture = temporary4;
				if (quality > BloomQuality.Cheap)
				{
					if (i == 0)
					{
						Graphics.SetRenderTarget(temporary);
						GL.Clear(clearDepth: false, clearColor: true, Color.black);
						Graphics.Blit(renderTexture, temporary);
					}
					else
					{
						temporary.MarkRestoreExpected();
						Graphics.Blit(renderTexture, temporary, screenBlend, 10);
					}
				}
			}
			if (quality > BloomQuality.Cheap)
			{
				Graphics.SetRenderTarget(renderTexture);
				GL.Clear(clearDepth: false, clearColor: true, Color.black);
				Graphics.Blit(temporary, renderTexture, screenBlend, 6);
			}
			if (lensflareIntensity > Mathf.Epsilon)
			{
				RenderTexture temporary5 = RenderTexture.GetTemporary(width2, height2, 0, format);
				if (lensflareMode == LensFlareStyle.Ghosting)
				{
					BrightFilter(lensflareThreshold, renderTexture, temporary5);
					if (quality > BloomQuality.Cheap)
					{
						blurAndFlaresMaterial.SetVector("_Offsets", new Vector4(0f, 1.5f / (1f * (float)temporary.height), 0f, 0f));
						Graphics.SetRenderTarget(temporary);
						GL.Clear(clearDepth: false, clearColor: true, Color.black);
						Graphics.Blit(temporary5, temporary, blurAndFlaresMaterial, 4);
						blurAndFlaresMaterial.SetVector("_Offsets", new Vector4(1.5f / (1f * (float)temporary.width), 0f, 0f, 0f));
						Graphics.SetRenderTarget(temporary5);
						GL.Clear(clearDepth: false, clearColor: true, Color.black);
						Graphics.Blit(temporary, temporary5, blurAndFlaresMaterial, 4);
					}
					Vignette(0.975f, temporary5, temporary5);
					BlendFlares(temporary5, renderTexture);
				}
				else
				{
					float num4 = 1f * Mathf.Cos(flareRotation);
					float num5 = 1f * Mathf.Sin(flareRotation);
					float num6 = hollyStretchWidth * 1f / num * num2;
					blurAndFlaresMaterial.SetVector("_Offsets", new Vector4(num4, num5, 0f, 0f));
					blurAndFlaresMaterial.SetVector("_Threshhold", new Vector4(lensflareThreshold, 1f, 0f, 0f));
					blurAndFlaresMaterial.SetVector("_TintColor", new Vector4(flareColorA.r, flareColorA.g, flareColorA.b, flareColorA.a) * flareColorA.a * lensflareIntensity);
					blurAndFlaresMaterial.SetFloat("_Saturation", lensFlareSaturation);
					temporary.DiscardContents();
					Graphics.Blit(temporary5, temporary, blurAndFlaresMaterial, 2);
					temporary5.DiscardContents();
					Graphics.Blit(temporary, temporary5, blurAndFlaresMaterial, 3);
					blurAndFlaresMaterial.SetVector("_Offsets", new Vector4(num4 * num6, num5 * num6, 0f, 0f));
					blurAndFlaresMaterial.SetFloat("_StretchWidth", hollyStretchWidth);
					temporary.DiscardContents();
					Graphics.Blit(temporary5, temporary, blurAndFlaresMaterial, 1);
					blurAndFlaresMaterial.SetFloat("_StretchWidth", hollyStretchWidth * 2f);
					temporary5.DiscardContents();
					Graphics.Blit(temporary, temporary5, blurAndFlaresMaterial, 1);
					blurAndFlaresMaterial.SetFloat("_StretchWidth", hollyStretchWidth * 4f);
					temporary.DiscardContents();
					Graphics.Blit(temporary5, temporary, blurAndFlaresMaterial, 1);
					for (int j = 0; j < hollywoodFlareBlurIterations; j++)
					{
						num6 = hollyStretchWidth * 2f / num * num2;
						blurAndFlaresMaterial.SetVector("_Offsets", new Vector4(num6 * num4, num6 * num5, 0f, 0f));
						temporary5.DiscardContents();
						Graphics.Blit(temporary, temporary5, blurAndFlaresMaterial, 4);
						blurAndFlaresMaterial.SetVector("_Offsets", new Vector4(num6 * num4, num6 * num5, 0f, 0f));
						temporary.DiscardContents();
						Graphics.Blit(temporary5, temporary, blurAndFlaresMaterial, 4);
					}
					if (lensflareMode == LensFlareStyle.Anamorphic)
					{
						AddTo(1f, temporary, renderTexture);
					}
					else
					{
						Vignette(1f, temporary, temporary5);
						BlendFlares(temporary5, temporary);
						AddTo(1f, temporary, renderTexture);
					}
				}
				RenderTexture.ReleaseTemporary(temporary5);
			}
			int pass = (int)bloomScreenBlendMode;
			screenBlend.SetFloat("_Intensity", bloomIntensity);
			screenBlend.SetTexture("_ColorBuffer", source);
			if (quality > BloomQuality.Cheap)
			{
				RenderTexture temporary6 = RenderTexture.GetTemporary(width, height, 0, format);
				Graphics.Blit(renderTexture, temporary6);
				Graphics.Blit(temporary6, destination, screenBlend, pass);
				RenderTexture.ReleaseTemporary(temporary6);
			}
			else
			{
				Graphics.Blit(renderTexture, destination, screenBlend, pass);
			}
			RenderTexture.ReleaseTemporary(temporary);
			RenderTexture.ReleaseTemporary(renderTexture);
		}

		private void AddTo(float intensity_, RenderTexture from, RenderTexture to)
		{
			screenBlend.SetFloat("_Intensity", intensity_);
			to.MarkRestoreExpected();
			Graphics.Blit(from, to, screenBlend, 9);
		}

		private void BlendFlares(RenderTexture from, RenderTexture to)
		{
			lensFlareMaterial.SetVector("colorA", new Vector4(flareColorA.r, flareColorA.g, flareColorA.b, flareColorA.a) * lensflareIntensity);
			lensFlareMaterial.SetVector("colorB", new Vector4(flareColorB.r, flareColorB.g, flareColorB.b, flareColorB.a) * lensflareIntensity);
			lensFlareMaterial.SetVector("colorC", new Vector4(flareColorC.r, flareColorC.g, flareColorC.b, flareColorC.a) * lensflareIntensity);
			lensFlareMaterial.SetVector("colorD", new Vector4(flareColorD.r, flareColorD.g, flareColorD.b, flareColorD.a) * lensflareIntensity);
			to.MarkRestoreExpected();
			Graphics.Blit(from, to, lensFlareMaterial);
		}

		private void BrightFilter(float thresh, RenderTexture from, RenderTexture to)
		{
			brightPassFilterMaterial.SetVector("_Threshhold", new Vector4(thresh, thresh, thresh, thresh));
			Graphics.Blit(from, to, brightPassFilterMaterial, 0);
		}

		private void BrightFilter(Color threshColor, RenderTexture from, RenderTexture to)
		{
			brightPassFilterMaterial.SetVector("_Threshhold", threshColor);
			Graphics.Blit(from, to, brightPassFilterMaterial, 1);
		}

		private void Vignette(float amount, RenderTexture from, RenderTexture to)
		{
			if ((bool)lensFlareVignetteMask)
			{
				screenBlend.SetTexture("_ColorBuffer", lensFlareVignetteMask);
				to.MarkRestoreExpected();
				Graphics.Blit((from == to) ? null : from, to, screenBlend, (from == to) ? 7 : 3);
			}
			else if (from != to)
			{
				Graphics.SetRenderTarget(to);
				GL.Clear(clearDepth: false, clearColor: true, Color.black);
				Graphics.Blit(from, to);
			}
		}
	}
	public enum LensflareStyle34
	{
		Ghosting,
		Anamorphic,
		Combined
	}
	public enum TweakMode34
	{
		Basic,
		Complex
	}
	public enum HDRBloomMode
	{
		Auto,
		On,
		Off
	}
	public enum BloomScreenBlendMode
	{
		Screen,
		Add
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Bloom and Glow/BloomAndFlares (3.5, Deprecated)")]
	public class BloomAndFlares : PostEffectsBase
	{
		public TweakMode34 tweakMode;

		public BloomScreenBlendMode screenBlendMode = BloomScreenBlendMode.Add;

		public HDRBloomMode hdr;

		private bool doHdr;

		public float sepBlurSpread = 1.5f;

		public float useSrcAlphaAsMask = 0.5f;

		public float bloomIntensity = 1f;

		public float bloomThreshold = 0.5f;

		public int bloomBlurIterations = 2;

		public bool lensflares;

		public int hollywoodFlareBlurIterations = 2;

		public LensflareStyle34 lensflareMode = LensflareStyle34.Anamorphic;

		public float hollyStretchWidth = 3.5f;

		public float lensflareIntensity = 1f;

		public float lensflareThreshold = 0.3f;

		public Color flareColorA = new Color(0.4f, 0.4f, 0.8f, 0.75f);

		public Color flareColorB = new Color(0.4f, 0.8f, 0.8f, 0.75f);

		public Color flareColorC = new Color(0.8f, 0.4f, 0.8f, 0.75f);

		public Color flareColorD = new Color(0.8f, 0.4f, 0f, 0.75f);

		public Texture2D lensFlareVignetteMask;

		public Shader lensFlareShader;

		private Material lensFlareMaterial;

		public Shader vignetteShader;

		private Material vignetteMaterial;

		public Shader separableBlurShader;

		private Material separableBlurMaterial;

		public Shader addBrightStuffOneOneShader;

		private Material addBrightStuffBlendOneOneMaterial;

		public Shader screenBlendShader;

		private Material screenBlend;

		public Shader hollywoodFlaresShader;

		private Material hollywoodFlaresMaterial;

		public Shader brightPassFilterShader;

		private Material brightPassFilterMaterial;

		public override bool CheckResources()
		{
			CheckSupport(needDepth: false);
			screenBlend = CheckShaderAndCreateMaterial(screenBlendShader, screenBlend);
			lensFlareMaterial = CheckShaderAndCreateMaterial(lensFlareShader, lensFlareMaterial);
			vignetteMaterial = CheckShaderAndCreateMaterial(vignetteShader, vignetteMaterial);
			separableBlurMaterial = CheckShaderAndCreateMaterial(separableBlurShader, separableBlurMaterial);
			addBrightStuffBlendOneOneMaterial = CheckShaderAndCreateMaterial(addBrightStuffOneOneShader, addBrightStuffBlendOneOneMaterial);
			hollywoodFlaresMaterial = CheckShaderAndCreateMaterial(hollywoodFlaresShader, hollywoodFlaresMaterial);
			brightPassFilterMaterial = CheckShaderAndCreateMaterial(brightPassFilterShader, brightPassFilterMaterial);
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources())
			{
				Graphics.Blit(source, destination);
				return;
			}
			doHdr = false;
			if (hdr == HDRBloomMode.Auto)
			{
				doHdr = source.format == RenderTextureFormat.ARGBHalf && GetComponent<Camera>().allowHDR;
			}
			else
			{
				doHdr = hdr == HDRBloomMode.On;
			}
			doHdr = doHdr && supportHDRTextures;
			BloomScreenBlendMode pass = screenBlendMode;
			if (doHdr)
			{
				pass = BloomScreenBlendMode.Add;
			}
			RenderTextureFormat format = (doHdr ? RenderTextureFormat.ARGBHalf : RenderTextureFormat.Default);
			RenderTexture temporary = RenderTexture.GetTemporary(source.width / 2, source.height / 2, 0, format);
			RenderTexture temporary2 = RenderTexture.GetTemporary(source.width / 4, source.height / 4, 0, format);
			RenderTexture temporary3 = RenderTexture.GetTemporary(source.width / 4, source.height / 4, 0, format);
			RenderTexture temporary4 = RenderTexture.GetTemporary(source.width / 4, source.height / 4, 0, format);
			float num = 1f * (float)source.width / (1f * (float)source.height);
			float num2 = 0.001953125f;
			Graphics.Blit(source, temporary, screenBlend, 2);
			Graphics.Blit(temporary, temporary2, screenBlend, 2);
			RenderTexture.ReleaseTemporary(temporary);
			BrightFilter(bloomThreshold, useSrcAlphaAsMask, temporary2, temporary3);
			temporary2.DiscardContents();
			if (bloomBlurIterations < 1)
			{
				bloomBlurIterations = 1;
			}
			for (int i = 0; i < bloomBlurIterations; i++)
			{
				float num3 = (1f + (float)i * 0.5f) * sepBlurSpread;
				separableBlurMaterial.SetVector("offsets", new Vector4(0f, num3 * num2, 0f, 0f));
				RenderTexture obj = ((i == 0) ? temporary3 : temporary2);
				Graphics.Blit(obj, temporary4, separableBlurMaterial);
				obj.DiscardContents();
				separableBlurMaterial.SetVector("offsets", new Vector4(num3 / num * num2, 0f, 0f, 0f));
				Graphics.Blit(temporary4, temporary2, separableBlurMaterial);
				temporary4.DiscardContents();
			}
			if (lensflares)
			{
				if (lensflareMode == LensflareStyle34.Ghosting)
				{
					BrightFilter(lensflareThreshold, 0f, temporary2, temporary4);
					temporary2.DiscardContents();
					Vignette(0.975f, temporary4, temporary3);
					temporary4.DiscardContents();
					BlendFlares(temporary3, temporary2);
					temporary3.DiscardContents();
				}
				else
				{
					hollywoodFlaresMaterial.SetVector("_threshold", new Vector4(lensflareThreshold, 1f / (1f - lensflareThreshold), 0f, 0f));
					hollywoodFlaresMaterial.SetVector("tintColor", new Vector4(flareColorA.r, flareColorA.g, flareColorA.b, flareColorA.a) * flareColorA.a * lensflareIntensity);
					Graphics.Blit(temporary4, temporary3, hollywoodFlaresMaterial, 2);
					temporary4.DiscardContents();
					Graphics.Blit(temporary3, temporary4, hollywoodFlaresMaterial, 3);
					temporary3.DiscardContents();
					hollywoodFlaresMaterial.SetVector("offsets", new Vector4(sepBlurSpread * 1f / num * num2, 0f, 0f, 0f));
					hollywoodFlaresMaterial.SetFloat("stretchWidth", hollyStretchWidth);
					Graphics.Blit(temporary4, temporary3, hollywoodFlaresMaterial, 1);
					temporary4.DiscardContents();
					hollywoodFlaresMaterial.SetFloat("stretchWidth", hollyStretchWidth * 2f);
					Graphics.Blit(temporary3, temporary4, hollywoodFlaresMaterial, 1);
					temporary3.DiscardContents();
					hollywoodFlaresMaterial.SetFloat("stretchWidth", hollyStretchWidth * 4f);
					Graphics.Blit(temporary4, temporary3, hollywoodFlaresMaterial, 1);
					temporary4.DiscardContents();
					if (lensflareMode == LensflareStyle34.Anamorphic)
					{
						for (int j = 0; j < hollywoodFlareBlurIterations; j++)
						{
							separableBlurMaterial.SetVector("offsets", new Vector4(hollyStretchWidth * 2f / num * num2, 0f, 0f, 0f));
							Graphics.Blit(temporary3, temporary4, separableBlurMaterial);
							temporary3.DiscardContents();
							separableBlurMaterial.SetVector("offsets", new Vector4(hollyStretchWidth * 2f / num * num2, 0f, 0f, 0f));
							Graphics.Blit(temporary4, temporary3, separableBlurMaterial);
							temporary4.DiscardContents();
						}
						AddTo(1f, temporary3, temporary2);
						temporary3.DiscardContents();
					}
					else
					{
						for (int k = 0; k < hollywoodFlareBlurIterations; k++)
						{
							separableBlurMaterial.SetVector("offsets", new Vector4(hollyStretchWidth * 2f / num * num2, 0f, 0f, 0f));
							Graphics.Blit(temporary3, temporary4, separableBlurMaterial);
							temporary3.DiscardContents();
							separableBlurMaterial.SetVector("offsets", new Vector4(hollyStretchWidth * 2f / num * num2, 0f, 0f, 0f));
							Graphics.Blit(temporary4, temporary3, separableBlurMaterial);
							temporary4.DiscardContents();
						}
						Vignette(1f, temporary3, temporary4);
						temporary3.DiscardContents();
						BlendFlares(temporary4, temporary3);
						temporary4.DiscardContents();
						AddTo(1f, temporary3, temporary2);
						temporary3.DiscardContents();
					}
				}
			}
			screenBlend.SetFloat("_Intensity", bloomIntensity);
			screenBlend.SetTexture("_ColorBuffer", source);
			Graphics.Blit(temporary2, destination, screenBlend, (int)pass);
			RenderTexture.ReleaseTemporary(temporary2);
			RenderTexture.ReleaseTemporary(temporary3);
			RenderTexture.ReleaseTemporary(temporary4);
		}

		private void AddTo(float intensity_, RenderTexture from, RenderTexture to)
		{
			addBrightStuffBlendOneOneMaterial.SetFloat("_Intensity", intensity_);
			Graphics.Blit(from, to, addBrightStuffBlendOneOneMaterial);
		}

		private void BlendFlares(RenderTexture from, RenderTexture to)
		{
			lensFlareMaterial.SetVector("colorA", new Vector4(flareColorA.r, flareColorA.g, flareColorA.b, flareColorA.a) * lensflareIntensity);
			lensFlareMaterial.SetVector("colorB", new Vector4(flareColorB.r, flareColorB.g, flareColorB.b, flareColorB.a) * lensflareIntensity);
			lensFlareMaterial.SetVector("colorC", new Vector4(flareColorC.r, flareColorC.g, flareColorC.b, flareColorC.a) * lensflareIntensity);
			lensFlareMaterial.SetVector("colorD", new Vector4(flareColorD.r, flareColorD.g, flareColorD.b, flareColorD.a) * lensflareIntensity);
			Graphics.Blit(from, to, lensFlareMaterial);
		}

		private void BrightFilter(float thresh, float useAlphaAsMask, RenderTexture from, RenderTexture to)
		{
			if (doHdr)
			{
				brightPassFilterMaterial.SetVector("threshold", new Vector4(thresh, 1f, 0f, 0f));
			}
			else
			{
				brightPassFilterMaterial.SetVector("threshold", new Vector4(thresh, 1f / (1f - thresh), 0f, 0f));
			}
			brightPassFilterMaterial.SetFloat("useSrcAlphaAsMask", useAlphaAsMask);
			Graphics.Blit(from, to, brightPassFilterMaterial);
		}

		private void Vignette(float amount, RenderTexture from, RenderTexture to)
		{
			if ((bool)lensFlareVignetteMask)
			{
				screenBlend.SetTexture("_ColorBuffer", lensFlareVignetteMask);
				Graphics.Blit(from, to, screenBlend, 3);
			}
			else
			{
				vignetteMaterial.SetFloat("vignetteIntensity", amount);
				Graphics.Blit(from, to, vignetteMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Bloom and Glow/Bloom (Optimized)")]
	public class BloomOptimized : PostEffectsBase
	{
		public enum Resolution
		{
			Low,
			High
		}

		public enum BlurType
		{
			Standard,
			Sgx
		}

		[Range(0f, 1.5f)]
		public float threshold = 0.25f;

		[Range(0f, 2.5f)]
		public float intensity = 0.75f;

		[Range(0.25f, 5.5f)]
		public float blurSize = 1f;

		private Resolution resolution;

		[Range(1f, 4f)]
		public int blurIterations = 1;

		public BlurType blurType;

		public Shader fastBloomShader;

		private Material fastBloomMaterial;

		public override bool CheckResources()
		{
			CheckSupport(needDepth: false);
			fastBloomMaterial = CheckShaderAndCreateMaterial(fastBloomShader, fastBloomMaterial);
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		private void OnDisable()
		{
			if ((bool)fastBloomMaterial)
			{
				UnityEngine.Object.DestroyImmediate(fastBloomMaterial);
			}
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources())
			{
				Graphics.Blit(source, destination);
				return;
			}
			int num = ((resolution == Resolution.Low) ? 4 : 2);
			float num2 = ((resolution == Resolution.Low) ? 0.5f : 1f);
			fastBloomMaterial.SetVector("_Parameter", new Vector4(blurSize * num2, 0f, threshold, intensity));
			source.filterMode = FilterMode.Bilinear;
			int width = source.width / num;
			int height = source.height / num;
			RenderTexture renderTexture = RenderTexture.GetTemporary(width, height, 0, source.format);
			renderTexture.filterMode = FilterMode.Bilinear;
			Graphics.Blit(source, renderTexture, fastBloomMaterial, 1);
			int num3 = ((blurType != 0) ? 2 : 0);
			for (int i = 0; i < blurIterations; i++)
			{
				fastBloomMaterial.SetVector("_Parameter", new Vector4(blurSize * num2 + (float)i * 1f, 0f, threshold, intensity));
				RenderTexture temporary = RenderTexture.GetTemporary(width, height, 0, source.format);
				temporary.filterMode = FilterMode.Bilinear;
				Graphics.Blit(renderTexture, temporary, fastBloomMaterial, 2 + num3);
				RenderTexture.ReleaseTemporary(renderTexture);
				renderTexture = temporary;
				temporary = RenderTexture.GetTemporary(width, height, 0, source.format);
				temporary.filterMode = FilterMode.Bilinear;
				Graphics.Blit(renderTexture, temporary, fastBloomMaterial, 3 + num3);
				RenderTexture.ReleaseTemporary(renderTexture);
				renderTexture = temporary;
			}
			fastBloomMaterial.SetTexture("_Bloom", renderTexture);
			Graphics.Blit(source, destination, fastBloomMaterial, 0);
			RenderTexture.ReleaseTemporary(renderTexture);
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Image Effects/Blur/Blur")]
	public class Blur : MonoBehaviour
	{
		[Range(0f, 10f)]
		public int iterations = 3;

		[Range(0f, 1f)]
		public float blurSpread = 0.6f;

		public Shader blurShader;

		private static Material m_Material;

		protected Material material
		{
			get
			{
				if (m_Material == null)
				{
					m_Material = new Material(blurShader);
					m_Material.hideFlags = HideFlags.DontSave;
				}
				return m_Material;
			}
		}

		protected void OnDisable()
		{
			if ((bool)m_Material)
			{
				UnityEngine.Object.DestroyImmediate(m_Material);
			}
		}

		protected void Start()
		{
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
			else if (!blurShader || !material.shader.isSupported)
			{
				base.enabled = false;
			}
		}

		public void FourTapCone(RenderTexture source, RenderTexture dest, int iteration)
		{
			float num = 0.5f + (float)iteration * blurSpread;
			Graphics.BlitMultiTap(source, dest, material, new Vector2(0f - num, 0f - num), new Vector2(0f - num, num), new Vector2(num, num), new Vector2(num, 0f - num));
		}

		private void DownSample4x(RenderTexture source, RenderTexture dest)
		{
			float num = 1f;
			Graphics.BlitMultiTap(source, dest, material, new Vector2(0f - num, 0f - num), new Vector2(0f - num, num), new Vector2(num, num), new Vector2(num, 0f - num));
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			int width = source.width / 4;
			int height = source.height / 4;
			RenderTexture renderTexture = RenderTexture.GetTemporary(width, height, 0);
			DownSample4x(source, renderTexture);
			for (int i = 0; i < iterations; i++)
			{
				RenderTexture temporary = RenderTexture.GetTemporary(width, height, 0);
				FourTapCone(renderTexture, temporary, i);
				RenderTexture.ReleaseTemporary(renderTexture);
				renderTexture = temporary;
			}
			Graphics.Blit(renderTexture, destination);
			RenderTexture.ReleaseTemporary(renderTexture);
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Blur/Blur (Optimized)")]
	public class BlurOptimized : PostEffectsBase
	{
		public enum BlurType
		{
			StandardGauss,
			SgxGauss
		}

		[Range(0f, 2f)]
		public int downsample = 1;

		[Range(0f, 10f)]
		public float blurSize = 3f;

		[Range(1f, 4f)]
		public int blurIterations = 2;

		public BlurType blurType;

		public Shader blurShader;

		private Material blurMaterial;

		public override bool CheckResources()
		{
			CheckSupport(needDepth: false);
			blurMaterial = CheckShaderAndCreateMaterial(blurShader, blurMaterial);
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		public void OnDisable()
		{
			if ((bool)blurMaterial)
			{
				UnityEngine.Object.DestroyImmediate(blurMaterial);
			}
		}

		public void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources())
			{
				Graphics.Blit(source, destination);
				return;
			}
			float num = 1f / (1f * (float)(1 << downsample));
			blurMaterial.SetVector("_Parameter", new Vector4(blurSize * num, (0f - blurSize) * num, 0f, 0f));
			source.filterMode = FilterMode.Bilinear;
			int width = source.width >> downsample;
			int height = source.height >> downsample;
			RenderTexture renderTexture = RenderTexture.GetTemporary(width, height, 0, source.format);
			renderTexture.filterMode = FilterMode.Bilinear;
			Graphics.Blit(source, renderTexture, blurMaterial, 0);
			int num2 = ((blurType != 0) ? 2 : 0);
			for (int i = 0; i < blurIterations; i++)
			{
				float num3 = (float)i * 1f;
				blurMaterial.SetVector("_Parameter", new Vector4(blurSize * num + num3, (0f - blurSize) * num - num3, 0f, 0f));
				RenderTexture temporary = RenderTexture.GetTemporary(width, height, 0, source.format);
				temporary.filterMode = FilterMode.Bilinear;
				Graphics.Blit(renderTexture, temporary, blurMaterial, 1 + num2);
				RenderTexture.ReleaseTemporary(renderTexture);
				renderTexture = temporary;
				temporary = RenderTexture.GetTemporary(width, height, 0, source.format);
				temporary.filterMode = FilterMode.Bilinear;
				Graphics.Blit(renderTexture, temporary, blurMaterial, 2 + num2);
				RenderTexture.ReleaseTemporary(renderTexture);
				renderTexture = temporary;
			}
			Graphics.Blit(renderTexture, destination);
			RenderTexture.ReleaseTemporary(renderTexture);
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Image Effects/Color Adjustments/Color Correction (Curves, Saturation)")]
	public class ColorCorrectionCurves : PostEffectsBase
	{
		public enum ColorCorrectionMode
		{
			Simple,
			Advanced
		}

		public AnimationCurve redChannel = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(1f, 1f));

		public AnimationCurve greenChannel = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(1f, 1f));

		public AnimationCurve blueChannel = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(1f, 1f));

		public bool useDepthCorrection;

		public AnimationCurve zCurve = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(1f, 1f));

		public AnimationCurve depthRedChannel = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(1f, 1f));

		public AnimationCurve depthGreenChannel = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(1f, 1f));

		public AnimationCurve depthBlueChannel = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(1f, 1f));

		private Material ccMaterial;

		private Material ccDepthMaterial;

		private Material selectiveCcMaterial;

		private Texture2D rgbChannelTex;

		private Texture2D rgbDepthChannelTex;

		private Texture2D zCurveTex;

		public float saturation = 1f;

		public bool selectiveCc;

		public Color selectiveFromColor = Color.white;

		public Color selectiveToColor = Color.white;

		public ColorCorrectionMode mode;

		public bool updateTextures = true;

		public Shader colorCorrectionCurvesShader;

		public Shader simpleColorCorrectionCurvesShader;

		public Shader colorCorrectionSelectiveShader;

		private bool updateTexturesOnStartup = true;

		private new void Start()
		{
			base.Start();
			updateTexturesOnStartup = true;
		}

		private void Awake()
		{
		}

		public override bool CheckResources()
		{
			CheckSupport(mode == ColorCorrectionMode.Advanced);
			ccMaterial = CheckShaderAndCreateMaterial(simpleColorCorrectionCurvesShader, ccMaterial);
			ccDepthMaterial = CheckShaderAndCreateMaterial(colorCorrectionCurvesShader, ccDepthMaterial);
			selectiveCcMaterial = CheckShaderAndCreateMaterial(colorCorrectionSelectiveShader, selectiveCcMaterial);
			if (!rgbChannelTex)
			{
				rgbChannelTex = new Texture2D(256, 4, TextureFormat.ARGB32, mipChain: false, linear: true);
			}
			if (!rgbDepthChannelTex)
			{
				rgbDepthChannelTex = new Texture2D(256, 4, TextureFormat.ARGB32, mipChain: false, linear: true);
			}
			if (!zCurveTex)
			{
				zCurveTex = new Texture2D(256, 1, TextureFormat.ARGB32, mipChain: false, linear: true);
			}
			rgbChannelTex.hideFlags = HideFlags.DontSave;
			rgbDepthChannelTex.hideFlags = HideFlags.DontSave;
			zCurveTex.hideFlags = HideFlags.DontSave;
			rgbChannelTex.wrapMode = TextureWrapMode.Clamp;
			rgbDepthChannelTex.wrapMode = TextureWrapMode.Clamp;
			zCurveTex.wrapMode = TextureWrapMode.Clamp;
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		public void UpdateParameters()
		{
			CheckResources();
			if (redChannel != null && greenChannel != null && blueChannel != null)
			{
				for (float num = 0f; num <= 1f; num += 0.003921569f)
				{
					float num2 = Mathf.Clamp(redChannel.Evaluate(num), 0f, 1f);
					float num3 = Mathf.Clamp(greenChannel.Evaluate(num), 0f, 1f);
					float num4 = Mathf.Clamp(blueChannel.Evaluate(num), 0f, 1f);
					rgbChannelTex.SetPixel((int)Mathf.Floor(num * 255f), 0, new Color(num2, num2, num2));
					rgbChannelTex.SetPixel((int)Mathf.Floor(num * 255f), 1, new Color(num3, num3, num3));
					rgbChannelTex.SetPixel((int)Mathf.Floor(num * 255f), 2, new Color(num4, num4, num4));
					float num5 = Mathf.Clamp(zCurve.Evaluate(num), 0f, 1f);
					zCurveTex.SetPixel((int)Mathf.Floor(num * 255f), 0, new Color(num5, num5, num5));
					num2 = Mathf.Clamp(depthRedChannel.Evaluate(num), 0f, 1f);
					num3 = Mathf.Clamp(depthGreenChannel.Evaluate(num), 0f, 1f);
					num4 = Mathf.Clamp(depthBlueChannel.Evaluate(num), 0f, 1f);
					rgbDepthChannelTex.SetPixel((int)Mathf.Floor(num * 255f), 0, new Color(num2, num2, num2));
					rgbDepthChannelTex.SetPixel((int)Mathf.Floor(num * 255f), 1, new Color(num3, num3, num3));
					rgbDepthChannelTex.SetPixel((int)Mathf.Floor(num * 255f), 2, new Color(num4, num4, num4));
				}
				rgbChannelTex.Apply();
				rgbDepthChannelTex.Apply();
				zCurveTex.Apply();
			}
		}

		private void UpdateTextures()
		{
			UpdateParameters();
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources())
			{
				Graphics.Blit(source, destination);
				return;
			}
			if (updateTexturesOnStartup)
			{
				UpdateParameters();
				updateTexturesOnStartup = false;
			}
			if (useDepthCorrection)
			{
				GetComponent<Camera>().depthTextureMode |= DepthTextureMode.Depth;
			}
			RenderTexture renderTexture = destination;
			if (selectiveCc)
			{
				renderTexture = RenderTexture.GetTemporary(source.width, source.height);
			}
			if (useDepthCorrection)
			{
				ccDepthMaterial.SetTexture("_RgbTex", rgbChannelTex);
				ccDepthMaterial.SetTexture("_ZCurve", zCurveTex);
				ccDepthMaterial.SetTexture("_RgbDepthTex", rgbDepthChannelTex);
				ccDepthMaterial.SetFloat("_Saturation", saturation);
				Graphics.Blit(source, renderTexture, ccDepthMaterial);
			}
			else
			{
				ccMaterial.SetTexture("_RgbTex", rgbChannelTex);
				ccMaterial.SetFloat("_Saturation", saturation);
				Graphics.Blit(source, renderTexture, ccMaterial);
			}
			if (selectiveCc)
			{
				selectiveCcMaterial.SetColor("selColor", selectiveFromColor);
				selectiveCcMaterial.SetColor("targetColor", selectiveToColor);
				Graphics.Blit(renderTexture, destination, selectiveCcMaterial);
				RenderTexture.ReleaseTemporary(renderTexture);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Image Effects/Color Adjustments/Color Correction (3D Lookup Texture)")]
	public class ColorCorrectionLookup : PostEffectsBase
	{
		public Shader shader;

		private Material material;

		public Texture3D converted3DLut;

		public string basedOnTempTex = "";

		public override bool CheckResources()
		{
			CheckSupport(needDepth: false);
			material = CheckShaderAndCreateMaterial(shader, material);
			if (!isSupported || !SystemInfo.supports3DTextures)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		private void OnDisable()
		{
			if ((bool)material)
			{
				UnityEngine.Object.DestroyImmediate(material);
				material = null;
			}
		}

		private void OnDestroy()
		{
			if ((bool)converted3DLut)
			{
				UnityEngine.Object.DestroyImmediate(converted3DLut);
			}
			converted3DLut = null;
		}

		public void SetIdentityLut()
		{
			int num = 16;
			Color[] array = new Color[num * num * num];
			float num2 = 1f / (1f * (float)num - 1f);
			for (int i = 0; i < num; i++)
			{
				for (int j = 0; j < num; j++)
				{
					for (int k = 0; k < num; k++)
					{
						array[i + j * num + k * num * num] = new Color((float)i * 1f * num2, (float)j * 1f * num2, (float)k * 1f * num2, 1f);
					}
				}
			}
			if ((bool)converted3DLut)
			{
				UnityEngine.Object.DestroyImmediate(converted3DLut);
			}
			converted3DLut = new Texture3D(num, num, num, TextureFormat.ARGB32, mipChain: false);
			converted3DLut.SetPixels(array);
			converted3DLut.Apply();
			basedOnTempTex = "";
		}

		public bool ValidDimensions(Texture2D tex2d)
		{
			if (!tex2d)
			{
				return false;
			}
			if (tex2d.height != Mathf.FloorToInt(Mathf.Sqrt(tex2d.width)))
			{
				return false;
			}
			return true;
		}

		public void Convert(Texture2D temp2DTex, string path)
		{
			if ((bool)temp2DTex)
			{
				int num = temp2DTex.width * temp2DTex.height;
				num = temp2DTex.height;
				if (!ValidDimensions(temp2DTex))
				{
					UnityEngine.Debug.LogWarning("The given 2D texture " + temp2DTex.name + " cannot be used as a 3D LUT.");
					basedOnTempTex = "";
					return;
				}
				Color[] pixels = temp2DTex.GetPixels();
				Color[] array = new Color[pixels.Length];
				for (int i = 0; i < num; i++)
				{
					for (int j = 0; j < num; j++)
					{
						for (int k = 0; k < num; k++)
						{
							int num2 = num - j - 1;
							array[i + j * num + k * num * num] = pixels[k * num + i + num2 * num * num];
						}
					}
				}
				if ((bool)converted3DLut)
				{
					UnityEngine.Object.DestroyImmediate(converted3DLut);
				}
				converted3DLut = new Texture3D(num, num, num, TextureFormat.ARGB32, mipChain: false);
				converted3DLut.SetPixels(array);
				converted3DLut.Apply();
				basedOnTempTex = path;
			}
			else
			{
				UnityEngine.Debug.LogError("Couldn't color correct with 3D LUT texture. Image Effect will be disabled.");
			}
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources() || !SystemInfo.supports3DTextures)
			{
				Graphics.Blit(source, destination);
				return;
			}
			if (converted3DLut == null)
			{
				SetIdentityLut();
			}
			int width = converted3DLut.width;
			converted3DLut.wrapMode = TextureWrapMode.Clamp;
			material.SetFloat("_Scale", (float)(width - 1) / (1f * (float)width));
			material.SetFloat("_Offset", 1f / (2f * (float)width));
			material.SetTexture("_ClutTex", converted3DLut);
			Graphics.Blit(source, destination, material, (QualitySettings.activeColorSpace == ColorSpace.Linear) ? 1 : 0);
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Image Effects/Color Adjustments/Color Correction (Ramp)")]
	public class ColorCorrectionRamp : ImageEffectBase
	{
		public Texture textureRamp;

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			base.material.SetTexture("_RampTex", textureRamp);
			Graphics.Blit(source, destination, base.material);
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Color Adjustments/Contrast Enhance (Unsharp Mask)")]
	public class ContrastEnhance : PostEffectsBase
	{
		[Range(0f, 1f)]
		public float intensity = 0.5f;

		[Range(0f, 0.999f)]
		public float threshold;

		private Material separableBlurMaterial;

		private Material contrastCompositeMaterial;

		[Range(0f, 1f)]
		public float blurSpread = 1f;

		public Shader separableBlurShader;

		public Shader contrastCompositeShader;

		public override bool CheckResources()
		{
			CheckSupport(needDepth: false);
			contrastCompositeMaterial = CheckShaderAndCreateMaterial(contrastCompositeShader, contrastCompositeMaterial);
			separableBlurMaterial = CheckShaderAndCreateMaterial(separableBlurShader, separableBlurMaterial);
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources())
			{
				Graphics.Blit(source, destination);
				return;
			}
			int width = source.width;
			int height = source.height;
			RenderTexture temporary = RenderTexture.GetTemporary(width / 2, height / 2, 0);
			Graphics.Blit(source, temporary);
			RenderTexture temporary2 = RenderTexture.GetTemporary(width / 4, height / 4, 0);
			Graphics.Blit(temporary, temporary2);
			RenderTexture.ReleaseTemporary(temporary);
			separableBlurMaterial.SetVector("offsets", new Vector4(0f, blurSpread * 1f / (float)temporary2.height, 0f, 0f));
			RenderTexture temporary3 = RenderTexture.GetTemporary(width / 4, height / 4, 0);
			Graphics.Blit(temporary2, temporary3, separableBlurMaterial);
			RenderTexture.ReleaseTemporary(temporary2);
			separableBlurMaterial.SetVector("offsets", new Vector4(blurSpread * 1f / (float)temporary2.width, 0f, 0f, 0f));
			temporary2 = RenderTexture.GetTemporary(width / 4, height / 4, 0);
			Graphics.Blit(temporary3, temporary2, separableBlurMaterial);
			RenderTexture.ReleaseTemporary(temporary3);
			contrastCompositeMaterial.SetTexture("_MainTexBlurred", temporary2);
			contrastCompositeMaterial.SetFloat("intensity", intensity);
			contrastCompositeMaterial.SetFloat("threshold", threshold);
			Graphics.Blit(source, destination, contrastCompositeMaterial);
			RenderTexture.ReleaseTemporary(temporary2);
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Image Effects/Color Adjustments/Contrast Stretch")]
	public class ContrastStretch : MonoBehaviour
	{
		[Range(0.0001f, 1f)]
		public float adaptationSpeed = 0.02f;

		[Range(0f, 1f)]
		public float limitMinimum = 0.2f;

		[Range(0f, 1f)]
		public float limitMaximum = 0.6f;

		private RenderTexture[] adaptRenderTex = new RenderTexture[2];

		private int curAdaptIndex;

		public Shader shaderLum;

		private Material m_materialLum;

		public Shader shaderReduce;

		private Material m_materialReduce;

		public Shader shaderAdapt;

		private Material m_materialAdapt;

		public Shader shaderApply;

		private Material m_materialApply;

		protected Material materialLum
		{
			get
			{
				if (m_materialLum == null)
				{
					m_materialLum = new Material(shaderLum);
					m_materialLum.hideFlags = HideFlags.HideAndDontSave;
				}
				return m_materialLum;
			}
		}

		protected Material materialReduce
		{
			get
			{
				if (m_materialReduce == null)
				{
					m_materialReduce = new Material(shaderReduce);
					m_materialReduce.hideFlags = HideFlags.HideAndDontSave;
				}
				return m_materialReduce;
			}
		}

		protected Material materialAdapt
		{
			get
			{
				if (m_materialAdapt == null)
				{
					m_materialAdapt = new Material(shaderAdapt);
					m_materialAdapt.hideFlags = HideFlags.HideAndDontSave;
				}
				return m_materialAdapt;
			}
		}

		protected Material materialApply
		{
			get
			{
				if (m_materialApply == null)
				{
					m_materialApply = new Material(shaderApply);
					m_materialApply.hideFlags = HideFlags.HideAndDontSave;
				}
				return m_materialApply;
			}
		}

		private void Start()
		{
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
			else if (!shaderAdapt.isSupported || !shaderApply.isSupported || !shaderLum.isSupported || !shaderReduce.isSupported)
			{
				base.enabled = false;
			}
		}

		private void OnEnable()
		{
			for (int i = 0; i < 2; i++)
			{
				if (!adaptRenderTex[i])
				{
					adaptRenderTex[i] = new RenderTexture(1, 1, 0);
					adaptRenderTex[i].hideFlags = HideFlags.HideAndDontSave;
				}
			}
		}

		private void OnDisable()
		{
			for (int i = 0; i < 2; i++)
			{
				UnityEngine.Object.DestroyImmediate(adaptRenderTex[i]);
				adaptRenderTex[i] = null;
			}
			if ((bool)m_materialLum)
			{
				UnityEngine.Object.DestroyImmediate(m_materialLum);
			}
			if ((bool)m_materialReduce)
			{
				UnityEngine.Object.DestroyImmediate(m_materialReduce);
			}
			if ((bool)m_materialAdapt)
			{
				UnityEngine.Object.DestroyImmediate(m_materialAdapt);
			}
			if ((bool)m_materialApply)
			{
				UnityEngine.Object.DestroyImmediate(m_materialApply);
			}
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			RenderTexture renderTexture = RenderTexture.GetTemporary(source.width / 1, source.height / 1);
			Graphics.Blit(source, renderTexture, materialLum);
			while (renderTexture.width > 1 || renderTexture.height > 1)
			{
				int num = renderTexture.width / 2;
				if (num < 1)
				{
					num = 1;
				}
				int num2 = renderTexture.height / 2;
				if (num2 < 1)
				{
					num2 = 1;
				}
				RenderTexture temporary = RenderTexture.GetTemporary(num, num2);
				Graphics.Blit(renderTexture, temporary, materialReduce);
				RenderTexture.ReleaseTemporary(renderTexture);
				renderTexture = temporary;
			}
			CalculateAdaptation(renderTexture);
			materialApply.SetTexture("_AdaptTex", adaptRenderTex[curAdaptIndex]);
			Graphics.Blit(source, destination, materialApply);
			RenderTexture.ReleaseTemporary(renderTexture);
		}

		private void CalculateAdaptation(Texture curTexture)
		{
			int num = curAdaptIndex;
			curAdaptIndex = (curAdaptIndex + 1) % 2;
			float value = 1f - Mathf.Pow(1f - adaptationSpeed, 30f * Time.deltaTime);
			value = Mathf.Clamp(value, 0.01f, 1f);
			materialAdapt.SetTexture("_CurTex", curTexture);
			materialAdapt.SetVector("_AdaptParams", new Vector4(value, limitMinimum, limitMaximum, 0f));
			Graphics.SetRenderTarget(adaptRenderTex[curAdaptIndex]);
			GL.Clear(clearDepth: false, clearColor: true, Color.black);
			Graphics.Blit(adaptRenderTex[num], adaptRenderTex[curAdaptIndex], materialAdapt);
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Edge Detection/Crease Shading")]
	public class CreaseShading : PostEffectsBase
	{
		public float intensity = 0.5f;

		public int softness = 1;

		public float spread = 1f;

		public Shader blurShader;

		private Material blurMaterial;

		public Shader depthFetchShader;

		private Material depthFetchMaterial;

		public Shader creaseApplyShader;

		private Material creaseApplyMaterial;

		public override bool CheckResources()
		{
			CheckSupport(needDepth: true);
			blurMaterial = CheckShaderAndCreateMaterial(blurShader, blurMaterial);
			depthFetchMaterial = CheckShaderAndCreateMaterial(depthFetchShader, depthFetchMaterial);
			creaseApplyMaterial = CheckShaderAndCreateMaterial(creaseApplyShader, creaseApplyMaterial);
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources())
			{
				Graphics.Blit(source, destination);
				return;
			}
			int width = source.width;
			int height = source.height;
			float num = 1f * (float)width / (1f * (float)height);
			float num2 = 0.001953125f;
			RenderTexture temporary = RenderTexture.GetTemporary(width, height, 0);
			RenderTexture renderTexture = RenderTexture.GetTemporary(width / 2, height / 2, 0);
			Graphics.Blit(source, temporary, depthFetchMaterial);
			Graphics.Blit(temporary, renderTexture);
			for (int i = 0; i < softness; i++)
			{
				RenderTexture temporary2 = RenderTexture.GetTemporary(width / 2, height / 2, 0);
				blurMaterial.SetVector("offsets", new Vector4(0f, spread * num2, 0f, 0f));
				Graphics.Blit(renderTexture, temporary2, blurMaterial);
				RenderTexture.ReleaseTemporary(renderTexture);
				renderTexture = temporary2;
				temporary2 = RenderTexture.GetTemporary(width / 2, height / 2, 0);
				blurMaterial.SetVector("offsets", new Vector4(spread * num2 / num, 0f, 0f, 0f));
				Graphics.Blit(renderTexture, temporary2, blurMaterial);
				RenderTexture.ReleaseTemporary(renderTexture);
				renderTexture = temporary2;
			}
			creaseApplyMaterial.SetTexture("_HrDepthTex", temporary);
			creaseApplyMaterial.SetTexture("_LrDepthTex", renderTexture);
			creaseApplyMaterial.SetFloat("intensity", intensity);
			Graphics.Blit(source, destination, creaseApplyMaterial);
			RenderTexture.ReleaseTemporary(temporary);
			RenderTexture.ReleaseTemporary(renderTexture);
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Camera/Depth of Field (Lens Blur, Scatter, DX11)")]
	public class DepthOfField : PostEffectsBase
	{
		public enum BlurType
		{
			DiscBlur,
			DX11
		}

		public enum BlurSampleCount
		{
			Low,
			Medium,
			High
		}

		public bool visualizeFocus;

		public float focalLength = 10f;

		public float focalSize = 0.05f;

		public float aperture = 0.5f;

		public Transform focalTransform;

		public float maxBlurSize = 2f;

		public bool highResolution;

		public BlurType blurType;

		public BlurSampleCount blurSampleCount = BlurSampleCount.High;

		public bool nearBlur;

		public float foregroundOverlap = 1f;

		public Shader dofHdrShader;

		private Material dofHdrMaterial;

		public Shader dx11BokehShader;

		private Material dx11bokehMaterial;

		public float dx11BokehThreshold = 0.5f;

		public float dx11SpawnHeuristic = 0.0875f;

		public Texture2D dx11BokehTexture;

		public float dx11BokehScale = 1.2f;

		public float dx11BokehIntensity = 2.5f;

		private float focalDistance01 = 10f;

		private ComputeBuffer cbDrawArgs;

		private ComputeBuffer cbPoints;

		private float internalBlurWidth = 1f;

		private Camera cachedCamera;

		public override bool CheckResources()
		{
			CheckSupport(needDepth: true);
			dofHdrMaterial = CheckShaderAndCreateMaterial(dofHdrShader, dofHdrMaterial);
			if (supportDX11 && blurType == BlurType.DX11)
			{
				dx11bokehMaterial = CheckShaderAndCreateMaterial(dx11BokehShader, dx11bokehMaterial);
				CreateComputeResources();
			}
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		private void OnEnable()
		{
			cachedCamera = GetComponent<Camera>();
			cachedCamera.depthTextureMode |= DepthTextureMode.Depth;
		}

		private void OnDisable()
		{
			ReleaseComputeResources();
			if ((bool)dofHdrMaterial)
			{
				UnityEngine.Object.DestroyImmediate(dofHdrMaterial);
			}
			dofHdrMaterial = null;
			if ((bool)dx11bokehMaterial)
			{
				UnityEngine.Object.DestroyImmediate(dx11bokehMaterial);
			}
			dx11bokehMaterial = null;
		}

		private void ReleaseComputeResources()
		{
			if (cbDrawArgs != null)
			{
				cbDrawArgs.Release();
			}
			cbDrawArgs = null;
			if (cbPoints != null)
			{
				cbPoints.Release();
			}
			cbPoints = null;
		}

		private void CreateComputeResources()
		{
			if (cbDrawArgs == null)
			{
				cbDrawArgs = new ComputeBuffer(1, 16, ComputeBufferType.DrawIndirect);
				int[] data = new int[4] { 0, 1, 0, 0 };
				cbDrawArgs.SetData(data);
			}
			if (cbPoints == null)
			{
				cbPoints = new ComputeBuffer(90000, 28, ComputeBufferType.Append);
			}
		}

		private float FocalDistance01(float worldDist)
		{
			return cachedCamera.WorldToViewportPoint((worldDist - cachedCamera.nearClipPlane) * cachedCamera.transform.forward + cachedCamera.transform.position).z / (cachedCamera.farClipPlane - cachedCamera.nearClipPlane);
		}

		private void WriteCoc(RenderTexture fromTo, bool fgDilate)
		{
			dofHdrMaterial.SetTexture("_FgOverlap", null);
			if (nearBlur && fgDilate)
			{
				int width = fromTo.width / 2;
				int height = fromTo.height / 2;
				RenderTexture temporary = RenderTexture.GetTemporary(width, height, 0, fromTo.format);
				Graphics.Blit(fromTo, temporary, dofHdrMaterial, 4);
				float num = internalBlurWidth * foregroundOverlap;
				dofHdrMaterial.SetVector("_Offsets", new Vector4(0f, num, 0f, num));
				RenderTexture temporary2 = RenderTexture.GetTemporary(width, height, 0, fromTo.format);
				Graphics.Blit(temporary, temporary2, dofHdrMaterial, 2);
				RenderTexture.ReleaseTemporary(temporary);
				dofHdrMaterial.SetVector("_Offsets", new Vector4(num, 0f, 0f, num));
				temporary = RenderTexture.GetTemporary(width, height, 0, fromTo.format);
				Graphics.Blit(temporary2, temporary, dofHdrMaterial, 2);
				RenderTexture.ReleaseTemporary(temporary2);
				dofHdrMaterial.SetTexture("_FgOverlap", temporary);
				fromTo.MarkRestoreExpected();
				Graphics.Blit(fromTo, fromTo, dofHdrMaterial, 13);
				RenderTexture.ReleaseTemporary(temporary);
			}
			else
			{
				fromTo.MarkRestoreExpected();
				Graphics.Blit(fromTo, fromTo, dofHdrMaterial, 0);
			}
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources())
			{
				Graphics.Blit(source, destination);
				return;
			}
			if (aperture < 0f)
			{
				aperture = 0f;
			}
			if (maxBlurSize < 0.1f)
			{
				maxBlurSize = 0.1f;
			}
			focalSize = Mathf.Clamp(focalSize, 0f, 2f);
			internalBlurWidth = Mathf.Max(maxBlurSize, 0f);
			focalDistance01 = (focalTransform ? (cachedCamera.WorldToViewportPoint(focalTransform.position).z / cachedCamera.farClipPlane) : FocalDistance01(focalLength));
			dofHdrMaterial.SetVector("_CurveParams", new Vector4(1f, focalSize, 1f / (1f - aperture) - 1f, focalDistance01));
			RenderTexture renderTexture = null;
			RenderTexture renderTexture2 = null;
			RenderTexture renderTexture3 = null;
			RenderTexture renderTexture4 = null;
			float num = internalBlurWidth * foregroundOverlap;
			if (visualizeFocus)
			{
				WriteCoc(source, fgDilate: true);
				Graphics.Blit(source, destination, dofHdrMaterial, 16);
			}
			else if (blurType == BlurType.DX11 && (bool)dx11bokehMaterial)
			{
				if (highResolution)
				{
					internalBlurWidth = ((internalBlurWidth < 0.1f) ? 0.1f : internalBlurWidth);
					num = internalBlurWidth * foregroundOverlap;
					renderTexture = RenderTexture.GetTemporary(source.width, source.height, 0, source.format);
					RenderTexture temporary = RenderTexture.GetTemporary(source.width, source.height, 0, source.format);
					WriteCoc(source, fgDilate: false);
					renderTexture3 = RenderTexture.GetTemporary(source.width >> 1, source.height >> 1, 0, source.format);
					renderTexture4 = RenderTexture.GetTemporary(source.width >> 1, source.height >> 1, 0, source.format);
					Graphics.Blit(source, renderTexture3, dofHdrMaterial, 15);
					dofHdrMaterial.SetVector("_Offsets", new Vector4(0f, 1.5f, 0f, 1.5f));
					Graphics.Blit(renderTexture3, renderTexture4, dofHdrMaterial, 19);
					dofHdrMaterial.SetVector("_Offsets", new Vector4(1.5f, 0f, 0f, 1.5f));
					Graphics.Blit(renderTexture4, renderTexture3, dofHdrMaterial, 19);
					if (nearBlur)
					{
						Graphics.Blit(source, renderTexture4, dofHdrMaterial, 4);
					}
					dx11bokehMaterial.SetTexture("_BlurredColor", renderTexture3);
					dx11bokehMaterial.SetFloat("_SpawnHeuristic", dx11SpawnHeuristic);
					dx11bokehMaterial.SetVector("_BokehParams", new Vector4(dx11BokehScale, dx11BokehIntensity, Mathf.Clamp(dx11BokehThreshold, 0.005f, 4f), internalBlurWidth));
					dx11bokehMaterial.SetTexture("_FgCocMask", nearBlur ? renderTexture4 : null);
					Graphics.SetRandomWriteTarget(1, cbPoints);
					Graphics.Blit(source, renderTexture, dx11bokehMaterial, 0);
					Graphics.ClearRandomWriteTargets();
					if (nearBlur)
					{
						dofHdrMaterial.SetVector("_Offsets", new Vector4(0f, num, 0f, num));
						Graphics.Blit(renderTexture4, renderTexture3, dofHdrMaterial, 2);
						dofHdrMaterial.SetVector("_Offsets", new Vector4(num, 0f, 0f, num));
						Graphics.Blit(renderTexture3, renderTexture4, dofHdrMaterial, 2);
						Graphics.Blit(renderTexture4, renderTexture, dofHdrMaterial, 3);
					}
					Graphics.Blit(renderTexture, temporary, dofHdrMaterial, 20);
					dofHdrMaterial.SetVector("_Offsets", new Vector4(internalBlurWidth, 0f, 0f, internalBlurWidth));
					Graphics.Blit(renderTexture, source, dofHdrMaterial, 5);
					dofHdrMaterial.SetVector("_Offsets", new Vector4(0f, internalBlurWidth, 0f, internalBlurWidth));
					Graphics.Blit(source, temporary, dofHdrMaterial, 21);
					Graphics.SetRenderTarget(temporary);
					ComputeBuffer.CopyCount(cbPoints, cbDrawArgs, 0);
					dx11bokehMaterial.SetBuffer("pointBuffer", cbPoints);
					dx11bokehMaterial.SetTexture("_MainTex", dx11BokehTexture);
					dx11bokehMaterial.SetVector("_Screen", new Vector3(1f / (1f * (float)source.width), 1f / (1f * (float)source.height), internalBlurWidth));
					dx11bokehMaterial.SetPass(2);
					Graphics.DrawProceduralIndirectNow(MeshTopology.Points, cbDrawArgs);
					Graphics.Blit(temporary, destination);
					RenderTexture.ReleaseTemporary(temporary);
					RenderTexture.ReleaseTemporary(renderTexture3);
					RenderTexture.ReleaseTemporary(renderTexture4);
				}
				else
				{
					renderTexture = RenderTexture.GetTemporary(source.width >> 1, source.height >> 1, 0, source.format);
					renderTexture2 = RenderTexture.GetTemporary(source.width >> 1, source.height >> 1, 0, source.format);
					num = internalBlurWidth * foregroundOverlap;
					WriteCoc(source, fgDilate: false);
					source.filterMode = FilterMode.Bilinear;
					Graphics.Blit(source, renderTexture, dofHdrMaterial, 6);
					renderTexture3 = RenderTexture.GetTemporary(renderTexture.width >> 1, renderTexture.height >> 1, 0, renderTexture.format);
					renderTexture4 = RenderTexture.GetTemporary(renderTexture.width >> 1, renderTexture.height >> 1, 0, renderTexture.format);
					Graphics.Blit(renderTexture, renderTexture3, dofHdrMaterial, 15);
					dofHdrMaterial.SetVector("_Offsets", new Vector4(0f, 1.5f, 0f, 1.5f));
					Graphics.Blit(renderTexture3, renderTexture4, dofHdrMaterial, 19);
					dofHdrMaterial.SetVector("_Offsets", new Vector4(1.5f, 0f, 0f, 1.5f));
					Graphics.Blit(renderTexture4, renderTexture3, dofHdrMaterial, 19);
					RenderTexture renderTexture5 = null;
					if (nearBlur)
					{
						renderTexture5 = RenderTexture.GetTemporary(source.width >> 1, source.height >> 1, 0, source.format);
						Graphics.Blit(source, renderTexture5, dofHdrMaterial, 4);
					}
					dx11bokehMaterial.SetTexture("_BlurredColor", renderTexture3);
					dx11bokehMaterial.SetFloat("_SpawnHeuristic", dx11SpawnHeuristic);
					dx11bokehMaterial.SetVector("_BokehParams", new Vector4(dx11BokehScale, dx11BokehIntensity, Mathf.Clamp(dx11BokehThreshold, 0.005f, 4f), internalBlurWidth));
					dx11bokehMaterial.SetTexture("_FgCocMask", renderTexture5);
					Graphics.SetRandomWriteTarget(1, cbPoints);
					Graphics.Blit(renderTexture, renderTexture2, dx11bokehMaterial, 0);
					Graphics.ClearRandomWriteTargets();
					RenderTexture.ReleaseTemporary(renderTexture3);
					RenderTexture.ReleaseTemporary(renderTexture4);
					if (nearBlur)
					{
						dofHdrMaterial.SetVector("_Offsets", new Vector4(0f, num, 0f, num));
						Graphics.Blit(renderTexture5, renderTexture, dofHdrMaterial, 2);
						dofHdrMaterial.SetVector("_Offsets", new Vector4(num, 0f, 0f, num));
						Graphics.Blit(renderTexture, renderTexture5, dofHdrMaterial, 2);
						Graphics.Blit(renderTexture5, renderTexture2, dofHdrMaterial, 3);
					}
					dofHdrMaterial.SetVector("_Offsets", new Vector4(internalBlurWidth, 0f, 0f, internalBlurWidth));
					Graphics.Blit(renderTexture2, renderTexture, dofHdrMaterial, 5);
					dofHdrMaterial.SetVector("_Offsets", new Vector4(0f, internalBlurWidth, 0f, internalBlurWidth));
					Graphics.Blit(renderTexture, renderTexture2, dofHdrMaterial, 5);
					Graphics.SetRenderTarget(renderTexture2);
					ComputeBuffer.CopyCount(cbPoints, cbDrawArgs, 0);
					dx11bokehMaterial.SetBuffer("pointBuffer", cbPoints);
					dx11bokehMaterial.SetTexture("_MainTex", dx11BokehTexture);
					dx11bokehMaterial.SetVector("_Screen", new Vector3(1f / (1f * (float)renderTexture2.width), 1f / (1f * (float)renderTexture2.height), internalBlurWidth));
					dx11bokehMaterial.SetPass(1);
					Graphics.DrawProceduralIndirectNow(MeshTopology.Points, cbDrawArgs);
					dofHdrMaterial.SetTexture("_LowRez", renderTexture2);
					dofHdrMaterial.SetTexture("_FgOverlap", renderTexture5);
					dofHdrMaterial.SetVector("_Offsets", 1f * (float)source.width / (1f * (float)renderTexture2.width) * internalBlurWidth * Vector4.one);
					Graphics.Blit(source, destination, dofHdrMaterial, 9);
					if ((bool)renderTexture5)
					{
						RenderTexture.ReleaseTemporary(renderTexture5);
					}
				}
			}
			else
			{
				source.filterMode = FilterMode.Bilinear;
				if (highResolution)
				{
					internalBlurWidth *= 2f;
				}
				WriteCoc(source, fgDilate: true);
				renderTexture = RenderTexture.GetTemporary(source.width >> 1, source.height >> 1, 0, source.format);
				renderTexture2 = RenderTexture.GetTemporary(source.width >> 1, source.height >> 1, 0, source.format);
				int pass = ((blurSampleCount == BlurSampleCount.High || blurSampleCount == BlurSampleCount.Medium) ? 17 : 11);
				if (highResolution)
				{
					dofHdrMaterial.SetVector("_Offsets", new Vector4(0f, internalBlurWidth, 0.025f, internalBlurWidth));
					Graphics.Blit(source, destination, dofHdrMaterial, pass);
				}
				else
				{
					dofHdrMaterial.SetVector("_Offsets", new Vector4(0f, internalBlurWidth, 0.1f, internalBlurWidth));
					Graphics.Blit(source, renderTexture, dofHdrMaterial, 6);
					Graphics.Blit(renderTexture, renderTexture2, dofHdrMaterial, pass);
					dofHdrMaterial.SetTexture("_LowRez", renderTexture2);
					dofHdrMaterial.SetTexture("_FgOverlap", null);
					dofHdrMaterial.SetVector("_Offsets", Vector4.one * (1f * (float)source.width / (1f * (float)renderTexture2.width)) * internalBlurWidth);
					Graphics.Blit(source, destination, dofHdrMaterial, (blurSampleCount == BlurSampleCount.High) ? 18 : 12);
				}
			}
			if ((bool)renderTexture)
			{
				RenderTexture.ReleaseTemporary(renderTexture);
			}
			if ((bool)renderTexture2)
			{
				RenderTexture.ReleaseTemporary(renderTexture2);
			}
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Camera/Depth of Field (deprecated)")]
	public class DepthOfFieldDeprecated : PostEffectsBase
	{
		public enum Dof34QualitySetting
		{
			OnlyBackground = 1,
			BackgroundAndForeground
		}

		public enum DofResolution
		{
			High = 2,
			Medium,
			Low
		}

		public enum DofBlurriness
		{
			Low = 1,
			High = 2,
			VeryHigh = 4
		}

		public enum BokehDestination
		{
			Background = 1,
			Foreground,
			BackgroundAndForeground
		}

		private static int SMOOTH_DOWNSAMPLE_PASS = 6;

		private static float BOKEH_EXTRA_BLUR = 2f;

		public Dof34QualitySetting quality = Dof34QualitySetting.OnlyBackground;

		public DofResolution resolution = DofResolution.Low;

		public bool simpleTweakMode = true;

		public float focalPoint = 1f;

		public float smoothness = 0.5f;

		public float focalZDistance;

		public float focalZStartCurve = 1f;

		public float focalZEndCurve = 1f;

		private float focalStartCurve = 2f;

		private float focalEndCurve = 2f;

		private float focalDistance01 = 0.1f;

		public Transform objectFocus;

		public float focalSize;

		public DofBlurriness bluriness = DofBlurriness.High;

		public float maxBlurSpread = 1.75f;

		public float foregroundBlurExtrude = 1.15f;

		public Shader dofBlurShader;

		private Material dofBlurMaterial;

		public Shader dofShader;

		private Material dofMaterial;

		public bool visualize;

		public BokehDestination bokehDestination = BokehDestination.Background;

		private float widthOverHeight = 1.25f;

		private float oneOverBaseSize = 0.001953125f;

		public bool bokeh;

		public bool bokehSupport = true;

		public Shader bokehShader;

		public Texture2D bokehTexture;

		public float bokehScale = 2.4f;

		public float bokehIntensity = 0.15f;

		public float bokehThresholdContrast = 0.1f;

		public float bokehThresholdLuminance = 0.55f;

		public int bokehDownsample = 1;

		private Material bokehMaterial;

		private Camera _camera;

		private RenderTexture foregroundTexture;

		private RenderTexture mediumRezWorkTexture;

		private RenderTexture finalDefocus;

		private RenderTexture lowRezWorkTexture;

		private RenderTexture bokehSource;

		private RenderTexture bokehSource2;

		private void CreateMaterials()
		{
			dofBlurMaterial = CheckShaderAndCreateMaterial(dofBlurShader, dofBlurMaterial);
			dofMaterial = CheckShaderAndCreateMaterial(dofShader, dofMaterial);
			bokehSupport = bokehShader.isSupported;
			if (bokeh && bokehSupport && (bool)bokehShader)
			{
				bokehMaterial = CheckShaderAndCreateMaterial(bokehShader, bokehMaterial);
			}
		}

		public override bool CheckResources()
		{
			CheckSupport(needDepth: true);
			dofBlurMaterial = CheckShaderAndCreateMaterial(dofBlurShader, dofBlurMaterial);
			dofMaterial = CheckShaderAndCreateMaterial(dofShader, dofMaterial);
			bokehSupport = bokehShader.isSupported;
			if (bokeh && bokehSupport && (bool)bokehShader)
			{
				bokehMaterial = CheckShaderAndCreateMaterial(bokehShader, bokehMaterial);
			}
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		private void OnDisable()
		{
			UnityStandardAssets.ImageEffects.Quads.Cleanup();
		}

		private void OnEnable()
		{
			_camera = GetComponent<Camera>();
			_camera.depthTextureMode |= DepthTextureMode.Depth;
		}

		private float FocalDistance01(float worldDist)
		{
			return _camera.WorldToViewportPoint((worldDist - _camera.nearClipPlane) * _camera.transform.forward + _camera.transform.position).z / (_camera.farClipPlane - _camera.nearClipPlane);
		}

		private int GetDividerBasedOnQuality()
		{
			int result = 1;
			if (resolution == DofResolution.Medium)
			{
				result = 2;
			}
			else if (resolution == DofResolution.Low)
			{
				result = 2;
			}
			return result;
		}

		private int GetLowResolutionDividerBasedOnQuality(int baseDivider)
		{
			int num = baseDivider;
			if (resolution == DofResolution.High)
			{
				num *= 2;
			}
			if (resolution == DofResolution.Low)
			{
				num *= 2;
			}
			return num;
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources())
			{
				Graphics.Blit(source, destination);
				return;
			}
			if (smoothness < 0.1f)
			{
				smoothness = 0.1f;
			}
			bokeh = bokeh && bokehSupport;
			float num = (bokeh ? BOKEH_EXTRA_BLUR : 1f);
			bool flag = quality > Dof34QualitySetting.OnlyBackground;
			float num2 = focalSize / (_camera.farClipPlane - _camera.nearClipPlane);
			if (simpleTweakMode)
			{
				focalDistance01 = (objectFocus ? (_camera.WorldToViewportPoint(objectFocus.position).z / _camera.farClipPlane) : FocalDistance01(focalPoint));
				focalStartCurve = focalDistance01 * smoothness;
				focalEndCurve = focalStartCurve;
				flag = flag && focalPoint > _camera.nearClipPlane + Mathf.Epsilon;
			}
			else
			{
				if ((bool)objectFocus)
				{
					Vector3 vector = _camera.WorldToViewportPoint(objectFocus.position);
					vector.z /= _camera.farClipPlane;
					focalDistance01 = vector.z;
				}
				else
				{
					focalDistance01 = FocalDistance01(focalZDistance);
				}
				focalStartCurve = focalZStartCurve;
				focalEndCurve = focalZEndCurve;
				flag = flag && focalPoint > _camera.nearClipPlane + Mathf.Epsilon;
			}
			widthOverHeight = 1f * (float)source.width / (1f * (float)source.height);
			oneOverBaseSize = 0.001953125f;
			dofMaterial.SetFloat("_ForegroundBlurExtrude", foregroundBlurExtrude);
			dofMaterial.SetVector("_CurveParams", new Vector4(simpleTweakMode ? (1f / focalStartCurve) : focalStartCurve, simpleTweakMode ? (1f / focalEndCurve) : focalEndCurve, num2 * 0.5f, focalDistance01));
			dofMaterial.SetVector("_InvRenderTargetSize", new Vector4(1f / (1f * (float)source.width), 1f / (1f * (float)source.height), 0f, 0f));
			int dividerBasedOnQuality = GetDividerBasedOnQuality();
			int lowResolutionDividerBasedOnQuality = GetLowResolutionDividerBasedOnQuality(dividerBasedOnQuality);
			AllocateTextures(flag, source, dividerBasedOnQuality, lowResolutionDividerBasedOnQuality);
			Graphics.Blit(source, source, dofMaterial, 3);
			Downsample(source, mediumRezWorkTexture);
			Blur(mediumRezWorkTexture, mediumRezWorkTexture, DofBlurriness.Low, 4, maxBlurSpread);
			if (bokeh && (BokehDestination.Foreground & bokehDestination) != 0)
			{
				dofMaterial.SetVector("_Threshhold", new Vector4(bokehThresholdContrast, bokehThresholdLuminance, 0.95f, 0f));
				Graphics.Blit(mediumRezWorkTexture, bokehSource2, dofMaterial, 11);
				Graphics.Blit(mediumRezWorkTexture, lowRezWorkTexture);
				Blur(lowRezWorkTexture, lowRezWorkTexture, bluriness, 0, maxBlurSpread * num);
			}
			else
			{
				Downsample(mediumRezWorkTexture, lowRezWorkTexture);
				Blur(lowRezWorkTexture, lowRezWorkTexture, bluriness, 0, maxBlurSpread);
			}
			dofBlurMaterial.SetTexture("_TapLow", lowRezWorkTexture);
			dofBlurMaterial.SetTexture("_TapMedium", mediumRezWorkTexture);
			Graphics.Blit(null, finalDefocus, dofBlurMaterial, 3);
			if (bokeh && (BokehDestination.Foreground & bokehDestination) != 0)
			{
				AddBokeh(bokehSource2, bokehSource, finalDefocus);
			}
			dofMaterial.SetTexture("_TapLowBackground", finalDefocus);
			dofMaterial.SetTexture("_TapMedium", mediumRezWorkTexture);
			Graphics.Blit(source, flag ? foregroundTexture : destination, dofMaterial, visualize ? 2 : 0);
			if (flag)
			{
				Graphics.Blit(foregroundTexture, source, dofMaterial, 5);
				Downsample(source, mediumRezWorkTexture);
				BlurFg(mediumRezWorkTexture, mediumRezWorkTexture, DofBlurriness.Low, 2, maxBlurSpread);
				if (bokeh && (BokehDestination.Foreground & bokehDestination) != 0)
				{
					dofMaterial.SetVector("_Threshhold", new Vector4(bokehThresholdContrast * 0.5f, bokehThresholdLuminance, 0f, 0f));
					Graphics.Blit(mediumRezWorkTexture, bokehSource2, dofMaterial, 11);
					Graphics.Blit(mediumRezWorkTexture, lowRezWorkTexture);
					BlurFg(lowRezWorkTexture, lowRezWorkTexture, bluriness, 1, maxBlurSpread * num);
				}
				else
				{
					BlurFg(mediumRezWorkTexture, lowRezWorkTexture, bluriness, 1, maxBlurSpread);
				}
				Graphics.Blit(lowRezWorkTexture, finalDefocus);
				dofMaterial.SetTexture("_TapLowForeground", finalDefocus);
				Graphics.Blit(source, destination, dofMaterial, visualize ? 1 : 4);
				if (bokeh && (BokehDestination.Foreground & bokehDestination) != 0)
				{
					AddBokeh(bokehSource2, bokehSource, destination);
				}
			}
			ReleaseTextures();
		}

		private void Blur(RenderTexture from, RenderTexture to, DofBlurriness iterations, int blurPass, float spread)
		{
			RenderTexture temporary = RenderTexture.GetTemporary(to.width, to.height);
			if (iterations > DofBlurriness.Low)
			{
				BlurHex(from, to, blurPass, spread, temporary);
				if (iterations > DofBlurriness.High)
				{
					dofBlurMaterial.SetVector("offsets", new Vector4(0f, spread * oneOverBaseSize, 0f, 0f));
					Graphics.Blit(to, temporary, dofBlurMaterial, blurPass);
					dofBlurMaterial.SetVector("offsets", new Vector4(spread / widthOverHeight * oneOverBaseSize, 0f, 0f, 0f));
					Graphics.Blit(temporary, to, dofBlurMaterial, blurPass);
				}
			}
			else
			{
				dofBlurMaterial.SetVector("offsets", new Vector4(0f, spread * oneOverBaseSize, 0f, 0f));
				Graphics.Blit(from, temporary, dofBlurMaterial, blurPass);
				dofBlurMaterial.SetVector("offsets", new Vector4(spread / widthOverHeight * oneOverBaseSize, 0f, 0f, 0f));
				Graphics.Blit(temporary, to, dofBlurMaterial, blurPass);
			}
			RenderTexture.ReleaseTemporary(temporary);
		}

		private void BlurFg(RenderTexture from, RenderTexture to, DofBlurriness iterations, int blurPass, float spread)
		{
			dofBlurMaterial.SetTexture("_TapHigh", from);
			RenderTexture temporary = RenderTexture.GetTemporary(to.width, to.height);
			if (iterations > DofBlurriness.Low)
			{
				BlurHex(from, to, blurPass, spread, temporary);
				if (iterations > DofBlurriness.High)
				{
					dofBlurMaterial.SetVector("offsets", new Vector4(0f, spread * oneOverBaseSize, 0f, 0f));
					Graphics.Blit(to, temporary, dofBlurMaterial, blurPass);
					dofBlurMaterial.SetVector("offsets", new Vector4(spread / widthOverHeight * oneOverBaseSize, 0f, 0f, 0f));
					Graphics.Blit(temporary, to, dofBlurMaterial, blurPass);
				}
			}
			else
			{
				dofBlurMaterial.SetVector("offsets", new Vector4(0f, spread * oneOverBaseSize, 0f, 0f));
				Graphics.Blit(from, temporary, dofBlurMaterial, blurPass);
				dofBlurMaterial.SetVector("offsets", new Vector4(spread / widthOverHeight * oneOverBaseSize, 0f, 0f, 0f));
				Graphics.Blit(temporary, to, dofBlurMaterial, blurPass);
			}
			RenderTexture.ReleaseTemporary(temporary);
		}

		private void BlurHex(RenderTexture from, RenderTexture to, int blurPass, float spread, RenderTexture tmp)
		{
			dofBlurMaterial.SetVector("offsets", new Vector4(0f, spread * oneOverBaseSize, 0f, 0f));
			Graphics.Blit(from, tmp, dofBlurMaterial, blurPass);
			dofBlurMaterial.SetVector("offsets", new Vector4(spread / widthOverHeight * oneOverBaseSize, 0f, 0f, 0f));
			Graphics.Blit(tmp, to, dofBlurMaterial, blurPass);
			dofBlurMaterial.SetVector("offsets", new Vector4(spread / widthOverHeight * oneOverBaseSize, spread * oneOverBaseSize, 0f, 0f));
			Graphics.Blit(to, tmp, dofBlurMaterial, blurPass);
			dofBlurMaterial.SetVector("offsets", new Vector4(spread / widthOverHeight * oneOverBaseSize, (0f - spread) * oneOverBaseSize, 0f, 0f));
			Graphics.Blit(tmp, to, dofBlurMaterial, blurPass);
		}

		private void Downsample(RenderTexture from, RenderTexture to)
		{
			dofMaterial.SetVector("_InvRenderTargetSize", new Vector4(1f / (1f * (float)to.width), 1f / (1f * (float)to.height), 0f, 0f));
			Graphics.Blit(from, to, dofMaterial, SMOOTH_DOWNSAMPLE_PASS);
		}

		private void AddBokeh(RenderTexture bokehInfo, RenderTexture tempTex, RenderTexture finalTarget)
		{
			if (!bokehMaterial)
			{
				return;
			}
			Mesh[] meshes = UnityStandardAssets.ImageEffects.Quads.GetMeshes(tempTex.width, tempTex.height);
			RenderTexture.active = tempTex;
			GL.Clear(clearDepth: false, clearColor: true, new Color(0f, 0f, 0f, 0f));
			GL.PushMatrix();
			GL.LoadIdentity();
			bokehInfo.filterMode = FilterMode.Point;
			float num = (float)bokehInfo.width * 1f / ((float)bokehInfo.height * 1f);
			float num2 = 2f / (1f * (float)bokehInfo.width);
			num2 += bokehScale * maxBlurSpread * BOKEH_EXTRA_BLUR * oneOverBaseSize;
			bokehMaterial.SetTexture("_Source", bokehInfo);
			bokehMaterial.SetTexture("_MainTex", bokehTexture);
			bokehMaterial.SetVector("_ArScale", new Vector4(num2, num2 * num, 0.5f, 0.5f * num));
			bokehMaterial.SetFloat("_Intensity", bokehIntensity);
			bokehMaterial.SetPass(0);
			Mesh[] array = meshes;
			foreach (Mesh mesh in array)
			{
				if ((bool)mesh)
				{
					Graphics.DrawMeshNow(mesh, Matrix4x4.identity);
				}
			}
			GL.PopMatrix();
			Graphics.Blit(tempTex, finalTarget, dofMaterial, 8);
			bokehInfo.filterMode = FilterMode.Bilinear;
		}

		private void ReleaseTextures()
		{
			if ((bool)foregroundTexture)
			{
				RenderTexture.ReleaseTemporary(foregroundTexture);
			}
			if ((bool)finalDefocus)
			{
				RenderTexture.ReleaseTemporary(finalDefocus);
			}
			if ((bool)mediumRezWorkTexture)
			{
				RenderTexture.ReleaseTemporary(mediumRezWorkTexture);
			}
			if ((bool)lowRezWorkTexture)
			{
				RenderTexture.ReleaseTemporary(lowRezWorkTexture);
			}
			if ((bool)bokehSource)
			{
				RenderTexture.ReleaseTemporary(bokehSource);
			}
			if ((bool)bokehSource2)
			{
				RenderTexture.ReleaseTemporary(bokehSource2);
			}
		}

		private void AllocateTextures(bool blurForeground, RenderTexture source, int divider, int lowTexDivider)
		{
			foregroundTexture = null;
			if (blurForeground)
			{
				foregroundTexture = RenderTexture.GetTemporary(source.width, source.height, 0);
			}
			mediumRezWorkTexture = RenderTexture.GetTemporary(source.width / divider, source.height / divider, 0);
			finalDefocus = RenderTexture.GetTemporary(source.width / divider, source.height / divider, 0);
			lowRezWorkTexture = RenderTexture.GetTemporary(source.width / lowTexDivider, source.height / lowTexDivider, 0);
			bokehSource = null;
			bokehSource2 = null;
			if (bokeh)
			{
				bokehSource = RenderTexture.GetTemporary(source.width / (lowTexDivider * bokehDownsample), source.height / (lowTexDivider * bokehDownsample), 0, RenderTextureFormat.ARGBHalf);
				bokehSource2 = RenderTexture.GetTemporary(source.width / (lowTexDivider * bokehDownsample), source.height / (lowTexDivider * bokehDownsample), 0, RenderTextureFormat.ARGBHalf);
				bokehSource.filterMode = FilterMode.Bilinear;
				bokehSource2.filterMode = FilterMode.Bilinear;
				RenderTexture.active = bokehSource2;
				GL.Clear(clearDepth: false, clearColor: true, new Color(0f, 0f, 0f, 0f));
			}
			source.filterMode = FilterMode.Bilinear;
			finalDefocus.filterMode = FilterMode.Bilinear;
			mediumRezWorkTexture.filterMode = FilterMode.Bilinear;
			lowRezWorkTexture.filterMode = FilterMode.Bilinear;
			if ((bool)foregroundTexture)
			{
				foregroundTexture.filterMode = FilterMode.Bilinear;
			}
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Edge Detection/Edge Detection")]
	public class EdgeDetection : PostEffectsBase
	{
		public enum EdgeDetectMode
		{
			TriangleDepthNormals,
			RobertsCrossDepthNormals,
			SobelDepth,
			SobelDepthThin,
			TriangleLuminance
		}

		public EdgeDetectMode mode = EdgeDetectMode.SobelDepthThin;

		public float sensitivityDepth = 1f;

		public float sensitivityNormals = 1f;

		public float lumThreshold = 0.2f;

		public float edgeExp = 1f;

		public float sampleDist = 1f;

		public float edgesOnly;

		public Color edgesOnlyBgColor = Color.white;

		public Shader edgeDetectShader;

		private Material edgeDetectMaterial;

		private EdgeDetectMode oldMode = EdgeDetectMode.SobelDepthThin;

		public override bool CheckResources()
		{
			CheckSupport(needDepth: true);
			edgeDetectMaterial = CheckShaderAndCreateMaterial(edgeDetectShader, edgeDetectMaterial);
			if (mode != oldMode)
			{
				SetCameraFlag();
			}
			oldMode = mode;
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		private new void Start()
		{
			oldMode = mode;
		}

		private void SetCameraFlag()
		{
			if (mode == EdgeDetectMode.SobelDepth || mode == EdgeDetectMode.SobelDepthThin)
			{
				GetComponent<Camera>().depthTextureMode |= DepthTextureMode.Depth;
			}
			else if (mode == EdgeDetectMode.TriangleDepthNormals || mode == EdgeDetectMode.RobertsCrossDepthNormals)
			{
				GetComponent<Camera>().depthTextureMode |= DepthTextureMode.DepthNormals;
			}
		}

		private void OnEnable()
		{
			SetCameraFlag();
		}

		[ImageEffectOpaque]
		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources())
			{
				Graphics.Blit(source, destination);
				return;
			}
			Vector2 vector = new Vector2(sensitivityDepth, sensitivityNormals);
			edgeDetectMaterial.SetVector("_Sensitivity", new Vector4(vector.x, vector.y, 1f, vector.y));
			edgeDetectMaterial.SetFloat("_BgFade", edgesOnly);
			edgeDetectMaterial.SetFloat("_SampleDistance", sampleDist);
			edgeDetectMaterial.SetVector("_BgColor", edgesOnlyBgColor);
			edgeDetectMaterial.SetFloat("_Exponent", edgeExp);
			edgeDetectMaterial.SetFloat("_Threshold", lumThreshold);
			Graphics.Blit(source, destination, edgeDetectMaterial, (int)mode);
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Displacement/Fisheye")]
	public class Fisheye : PostEffectsBase
	{
		[Range(0f, 1.5f)]
		public float strengthX = 0.05f;

		[Range(0f, 1.5f)]
		public float strengthY = 0.05f;

		public Shader fishEyeShader;

		private Material fisheyeMaterial;

		public override bool CheckResources()
		{
			CheckSupport(needDepth: false);
			fisheyeMaterial = CheckShaderAndCreateMaterial(fishEyeShader, fisheyeMaterial);
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources())
			{
				Graphics.Blit(source, destination);
				return;
			}
			float num = 5f / 32f;
			float num2 = (float)source.width * 1f / ((float)source.height * 1f);
			fisheyeMaterial.SetVector("intensity", new Vector4(strengthX * num2 * num, strengthY * num, strengthX * num2 * num, strengthY * num));
			Graphics.Blit(source, destination, fisheyeMaterial);
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Rendering/Global Fog")]
	internal class GlobalFog : PostEffectsBase
	{
		[Tooltip("Apply distance-based fog?")]
		public bool distanceFog = true;

		[Tooltip("Exclude far plane pixels from distance-based fog? (Skybox or clear color)")]
		public bool excludeFarPixels = true;

		[Tooltip("Distance fog is based on radial distance from camera when checked")]
		public bool useRadialDistance;

		[Tooltip("Apply height-based fog?")]
		public bool heightFog = true;

		[Tooltip("Fog top Y coordinate")]
		public float height = 1f;

		[Range(0.001f, 10f)]
		public float heightDensity = 2f;

		[Tooltip("Push fog away from the camera by this amount")]
		public float startDistance;

		public Shader fogShader;

		private Material fogMaterial;

		public override bool CheckResources()
		{
			CheckSupport(needDepth: true);
			fogMaterial = CheckShaderAndCreateMaterial(fogShader, fogMaterial);
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		[ImageEffectOpaque]
		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources() || (!distanceFog && !heightFog))
			{
				Graphics.Blit(source, destination);
				return;
			}
			Camera component = GetComponent<Camera>();
			Transform transform = component.transform;
			float nearClipPlane = component.nearClipPlane;
			float farClipPlane = component.farClipPlane;
			float fieldOfView = component.fieldOfView;
			float aspect = component.aspect;
			Matrix4x4 identity = Matrix4x4.identity;
			float num = fieldOfView * 0.5f;
			Vector3 vector = transform.right * nearClipPlane * Mathf.Tan(num * ((float)Math.PI / 180f)) * aspect;
			Vector3 vector2 = transform.up * nearClipPlane * Mathf.Tan(num * ((float)Math.PI / 180f));
			Vector3 vector3 = transform.forward * nearClipPlane - vector + vector2;
			float num2 = vector3.magnitude * farClipPlane / nearClipPlane;
			vector3.Normalize();
			vector3 *= num2;
			Vector3 vector4 = transform.forward * nearClipPlane + vector + vector2;
			vector4.Normalize();
			vector4 *= num2;
			Vector3 vector5 = transform.forward * nearClipPlane + vector - vector2;
			vector5.Normalize();
			vector5 *= num2;
			Vector3 vector6 = transform.forward * nearClipPlane - vector - vector2;
			vector6.Normalize();
			vector6 *= num2;
			identity.SetRow(0, vector3);
			identity.SetRow(1, vector4);
			identity.SetRow(2, vector5);
			identity.SetRow(3, vector6);
			Vector3 position = transform.position;
			float num3 = position.y - height;
			float z = ((num3 <= 0f) ? 1f : 0f);
			float y = (excludeFarPixels ? 1f : 2f);
			fogMaterial.SetMatrix("_FrustumCornersWS", identity);
			fogMaterial.SetVector("_CameraWS", position);
			fogMaterial.SetVector("_HeightParams", new Vector4(height, num3, z, heightDensity * 0.5f));
			fogMaterial.SetVector("_DistanceParams", new Vector4(0f - Mathf.Max(startDistance, 0f), y, 0f, 0f));
			FogMode fogMode = RenderSettings.fogMode;
			float fogDensity = RenderSettings.fogDensity;
			float fogStartDistance = RenderSettings.fogStartDistance;
			float fogEndDistance = RenderSettings.fogEndDistance;
			bool flag = fogMode == FogMode.Linear;
			float num4 = (flag ? (fogEndDistance - fogStartDistance) : 0f);
			float num5 = ((Mathf.Abs(num4) > 0.0001f) ? (1f / num4) : 0f);
			Vector4 value = default(Vector4);
			value.x = fogDensity * 1.2011224f;
			value.y = fogDensity * 1.442695f;
			value.z = (flag ? (0f - num5) : 0f);
			value.w = (flag ? (fogEndDistance * num5) : 0f);
			fogMaterial.SetVector("_SceneFogParams", value);
			fogMaterial.SetVector("_SceneFogMode", new Vector4((float)fogMode, useRadialDistance ? 1 : 0, 0f, 0f));
			int num6 = 0;
			CustomGraphicsBlit(passNr: (!distanceFog || !heightFog) ? (distanceFog ? 1 : 2) : 0, source: source, dest: destination, fxMaterial: fogMaterial);
		}

		private static void CustomGraphicsBlit(RenderTexture source, RenderTexture dest, Material fxMaterial, int passNr)
		{
			RenderTexture.active = dest;
			fxMaterial.SetTexture("_MainTex", source);
			GL.PushMatrix();
			GL.LoadOrtho();
			fxMaterial.SetPass(passNr);
			GL.Begin(7);
			GL.MultiTexCoord2(0, 0f, 0f);
			GL.Vertex3(0f, 0f, 3f);
			GL.MultiTexCoord2(0, 1f, 0f);
			GL.Vertex3(1f, 0f, 2f);
			GL.MultiTexCoord2(0, 1f, 1f);
			GL.Vertex3(1f, 1f, 1f);
			GL.MultiTexCoord2(0, 0f, 1f);
			GL.Vertex3(0f, 1f, 0f);
			GL.End();
			GL.PopMatrix();
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Image Effects/Color Adjustments/Grayscale")]
	public class Grayscale : ImageEffectBase
	{
		public Texture textureRamp;

		[Range(-1f, 1f)]
		public float rampOffset;

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			base.material.SetTexture("_RampTex", textureRamp);
			base.material.SetFloat("_RampOffset", rampOffset);
			Graphics.Blit(source, destination, base.material);
		}
	}
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("")]
	public class ImageEffectBase : MonoBehaviour
	{
		public Shader shader;

		private Material m_Material;

		protected Material material
		{
			get
			{
				if (m_Material == null)
				{
					m_Material = new Material(shader);
					m_Material.hideFlags = HideFlags.HideAndDontSave;
				}
				return m_Material;
			}
		}

		protected virtual void Start()
		{
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
			else if (!shader || !shader.isSupported)
			{
				base.enabled = false;
			}
		}

		protected virtual void OnDisable()
		{
			if ((bool)m_Material)
			{
				UnityEngine.Object.DestroyImmediate(m_Material);
			}
		}
	}
	[AddComponentMenu("")]
	public class ImageEffects
	{
		public static void RenderDistortion(Material material, RenderTexture source, RenderTexture destination, float angle, Vector2 center, Vector2 radius)
		{
			if (source.texelSize.y < 0f)
			{
				center.y = 1f - center.y;
				angle = 0f - angle;
			}
			Matrix4x4 value = Matrix4x4.TRS(Vector3.zero, Quaternion.Euler(0f, 0f, angle), Vector3.one);
			material.SetMatrix("_RotationMatrix", value);
			material.SetVector("_CenterRadius", new Vector4(center.x, center.y, radius.x, radius.y));
			material.SetFloat("_Angle", angle * ((float)Math.PI / 180f));
			Graphics.Blit(source, destination, material);
		}

		[Obsolete("Use Graphics.Blit(source,dest) instead")]
		public static void Blit(RenderTexture source, RenderTexture dest)
		{
			Graphics.Blit(source, dest);
		}

		[Obsolete("Use Graphics.Blit(source, destination, material) instead")]
		public static void BlitWithMaterial(Material material, RenderTexture source, RenderTexture dest)
		{
			Graphics.Blit(source, dest, material);
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Image Effects/Blur/Motion Blur (Color Accumulation)")]
	[RequireComponent(typeof(Camera))]
	public class MotionBlur : ImageEffectBase
	{
		[Range(0f, 0.92f)]
		public float blurAmount = 0.8f;

		public bool extraBlur;

		private RenderTexture accumTexture;

		protected override void Start()
		{
			if (!SystemInfo.supportsRenderTextures)
			{
				base.enabled = false;
			}
			else
			{
				base.Start();
			}
		}

		protected override void OnDisable()
		{
			base.OnDisable();
			UnityEngine.Object.DestroyImmediate(accumTexture);
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (accumTexture == null || accumTexture.width != source.width || accumTexture.height != source.height)
			{
				UnityEngine.Object.DestroyImmediate(accumTexture);
				accumTexture = new RenderTexture(source.width, source.height, 0);
				accumTexture.hideFlags = HideFlags.HideAndDontSave;
				Graphics.Blit(source, accumTexture);
			}
			if (extraBlur)
			{
				RenderTexture temporary = RenderTexture.GetTemporary(source.width / 4, source.height / 4, 0);
				accumTexture.MarkRestoreExpected();
				Graphics.Blit(accumTexture, temporary);
				Graphics.Blit(temporary, accumTexture);
				RenderTexture.ReleaseTemporary(temporary);
			}
			blurAmount = Mathf.Clamp(blurAmount, 0f, 0.92f);
			base.material.SetTexture("_MainTex", accumTexture);
			base.material.SetFloat("_AccumOrig", 1f - blurAmount);
			accumTexture.MarkRestoreExpected();
			Graphics.Blit(source, accumTexture, base.material);
			Graphics.Blit(accumTexture, destination);
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Noise/Noise And Grain (Filmic)")]
	public class NoiseAndGrain : PostEffectsBase
	{
		public float intensityMultiplier = 0.25f;

		public float generalIntensity = 0.5f;

		public float blackIntensity = 1f;

		public float whiteIntensity = 1f;

		public float midGrey = 0.2f;

		public bool dx11Grain;

		public float softness;

		public bool monochrome;

		public Vector3 intensities = new Vector3(1f, 1f, 1f);

		public Vector3 tiling = new Vector3(64f, 64f, 64f);

		public float monochromeTiling = 64f;

		public FilterMode filterMode = FilterMode.Bilinear;

		public Texture2D noiseTexture;

		public Shader noiseShader;

		private Material noiseMaterial;

		public Shader dx11NoiseShader;

		private Material dx11NoiseMaterial;

		private static float TILE_AMOUNT = 64f;

		private Mesh mesh;

		private void Awake()
		{
			mesh = new Mesh();
		}

		public override bool CheckResources()
		{
			CheckSupport(needDepth: false);
			noiseMaterial = CheckShaderAndCreateMaterial(noiseShader, noiseMaterial);
			if (dx11Grain && supportDX11)
			{
				dx11NoiseMaterial = CheckShaderAndCreateMaterial(dx11NoiseShader, dx11NoiseMaterial);
			}
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources() || null == noiseTexture)
			{
				Graphics.Blit(source, destination);
				if (null == noiseTexture)
				{
					UnityEngine.Debug.LogWarning("Noise & Grain effect failing as noise texture is not assigned. please assign.", base.transform);
				}
				return;
			}
			softness = Mathf.Clamp(softness, 0f, 0.99f);
			if (dx11Grain && supportDX11)
			{
				dx11NoiseMaterial.SetFloat("_DX11NoiseTime", Time.frameCount);
				dx11NoiseMaterial.SetTexture("_NoiseTex", noiseTexture);
				dx11NoiseMaterial.SetVector("_NoisePerChannel", monochrome ? Vector3.one : intensities);
				dx11NoiseMaterial.SetVector("_MidGrey", new Vector3(midGrey, 1f / (1f - midGrey), -1f / midGrey));
				dx11NoiseMaterial.SetVector("_NoiseAmount", new Vector3(generalIntensity, blackIntensity, whiteIntensity) * intensityMultiplier);
				if (softness > Mathf.Epsilon)
				{
					RenderTexture temporary = RenderTexture.GetTemporary((int)((float)source.width * (1f - softness)), (int)((float)source.height * (1f - softness)));
					DrawNoiseQuadGrid(source, temporary, dx11NoiseMaterial, noiseTexture, mesh, monochrome ? 3 : 2);
					dx11NoiseMaterial.SetTexture("_NoiseTex", temporary);
					Graphics.Blit(source, destination, dx11NoiseMaterial, 4);
					RenderTexture.ReleaseTemporary(temporary);
				}
				else
				{
					DrawNoiseQuadGrid(source, destination, dx11NoiseMaterial, noiseTexture, mesh, monochrome ? 1 : 0);
				}
				return;
			}
			if ((bool)noiseTexture)
			{
				noiseTexture.wrapMode = TextureWrapMode.Repeat;
				noiseTexture.filterMode = filterMode;
			}
			noiseMaterial.SetTexture("_NoiseTex", noiseTexture);
			noiseMaterial.SetVector("_NoisePerChannel", monochrome ? Vector3.one : intensities);
			noiseMaterial.SetVector("_NoiseTilingPerChannel", monochrome ? (Vector3.one * monochromeTiling) : tiling);
			noiseMaterial.SetVector("_MidGrey", new Vector3(midGrey, 1f / (1f - midGrey), -1f / midGrey));
			noiseMaterial.SetVector("_NoiseAmount", new Vector3(generalIntensity, blackIntensity, whiteIntensity) * intensityMultiplier);
			if (softness > Mathf.Epsilon)
			{
				RenderTexture temporary2 = RenderTexture.GetTemporary((int)((float)source.width * (1f - softness)), (int)((float)source.height * (1f - softness)));
				DrawNoiseQuadGrid(source, temporary2, noiseMaterial, noiseTexture, mesh, 2);
				noiseMaterial.SetTexture("_NoiseTex", temporary2);
				Graphics.Blit(source, destination, noiseMaterial, 1);
				RenderTexture.ReleaseTemporary(temporary2);
			}
			else
			{
				DrawNoiseQuadGrid(source, destination, noiseMaterial, noiseTexture, mesh, 0);
			}
		}

		private static void DrawNoiseQuadGrid(RenderTexture source, RenderTexture dest, Material fxMaterial, Texture2D noise, Mesh mesh, int passNr)
		{
			RenderTexture.active = dest;
			fxMaterial.SetTexture("_MainTex", source);
			GL.PushMatrix();
			GL.LoadOrtho();
			fxMaterial.SetPass(passNr);
			BuildMesh(mesh, source, noise);
			Transform obj = Camera.main.transform;
			Vector3 position = obj.position;
			Quaternion rotation = obj.rotation;
			obj.position = Vector3.zero;
			obj.rotation = Quaternion.identity;
			Graphics.DrawMeshNow(mesh, Matrix4x4.identity);
			obj.position = position;
			obj.rotation = rotation;
			GL.PopMatrix();
		}

		private static void BuildMesh(Mesh mesh, RenderTexture source, Texture2D noise)
		{
			float noiseSize = (float)noise.width * 1f;
			float num = 1f * (float)source.width / TILE_AMOUNT;
			float num2 = 1f * (float)source.width / (1f * (float)source.height);
			float num3 = 1f / num;
			float num4 = num3 * num2;
			int num5 = (int)Mathf.Ceil(num);
			int num6 = (int)Mathf.Ceil(1f / num4);
			if (mesh.vertices.Length != num5 * num6 * 4)
			{
				Vector3[] array = new Vector3[num5 * num6 * 4];
				Vector2[] array2 = new Vector2[num5 * num6 * 4];
				int[] array3 = new int[num5 * num6 * 6];
				int num7 = 0;
				int num8 = 0;
				for (float num9 = 0f; num9 < 1f; num9 += num3)
				{
					for (float num10 = 0f; num10 < 1f; num10 += num4)
					{
						array[num7] = new Vector3(num9, num10, 0.1f);
						array[num7 + 1] = new Vector3(num9 + num3, num10, 0.1f);
						array[num7 + 2] = new Vector3(num9 + num3, num10 + num4, 0.1f);
						array[num7 + 3] = new Vector3(num9, num10 + num4, 0.1f);
						array2[num7] = new Vector2(0f, 0f);
						array2[num7 + 1] = new Vector2(1f, 0f);
						array2[num7 + 2] = new Vector2(1f, 1f);
						array2[num7 + 3] = new Vector2(0f, 1f);
						array3[num8] = num7;
						array3[num8 + 1] = num7 + 1;
						array3[num8 + 2] = num7 + 2;
						array3[num8 + 3] = num7;
						array3[num8 + 4] = num7 + 2;
						array3[num8 + 5] = num7 + 3;
						num7 += 4;
						num8 += 6;
					}
				}
				mesh.vertices = array;
				mesh.uv2 = array2;
				mesh.triangles = array3;
			}
			BuildMeshUV0(mesh, num5, num6, noiseSize, noise.width);
		}

		private static void BuildMeshUV0(Mesh mesh, int width, int height, float noiseSize, int noiseWidth)
		{
			float num = noiseSize / ((float)noiseWidth * 1f);
			float num2 = 1f / noiseSize;
			Vector2[] array = new Vector2[width * height * 4];
			int num3 = 0;
			for (int i = 0; i < width * height; i++)
			{
				float f = UnityEngine.Random.Range(0f, noiseSize);
				float f2 = UnityEngine.Random.Range(0f, noiseSize);
				f = Mathf.Floor(f) * num2;
				f2 = Mathf.Floor(f2) * num2;
				array[num3] = new Vector2(f, f2);
				array[num3 + 1] = new Vector2(f + num * num2, f2);
				array[num3 + 2] = new Vector2(f + num * num2, f2 + num * num2);
				array[num3 + 3] = new Vector2(f, f2 + num * num2);
				num3 += 4;
			}
			mesh.uv = array;
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Noise/Noise and Scratches")]
	public class NoiseAndScratches : MonoBehaviour
	{
		public bool monochrome = true;

		private bool rgbFallback;

		[Range(0f, 5f)]
		public float grainIntensityMin = 0.1f;

		[Range(0f, 5f)]
		public float grainIntensityMax = 0.2f;

		[Range(0.1f, 50f)]
		public float grainSize = 2f;

		[Range(0f, 5f)]
		public float scratchIntensityMin = 0.05f;

		[Range(0f, 5f)]
		public float scratchIntensityMax = 0.25f;

		[Range(1f, 30f)]
		public float scratchFPS = 10f;

		[Range(0f, 1f)]
		public float scratchJitter = 0.01f;

		public Texture grainTexture;

		public Texture scratchTexture;

		public Shader shaderRGB;

		public Shader shaderYUV;

		private Material m_MaterialRGB;

		private Material m_MaterialYUV;

		private float scratchTimeLeft;

		private float scratchX;

		private float scratchY;

		protected Material material
		{
			get
			{
				if (m_MaterialRGB == null)
				{
					m_MaterialRGB = new Material(shaderRGB);
					m_MaterialRGB.hideFlags = HideFlags.HideAndDontSave;
				}
				if (m_MaterialYUV == null && !rgbFallback)
				{
					m_MaterialYUV = new Material(shaderYUV);
					m_MaterialYUV.hideFlags = HideFlags.HideAndDontSave;
				}
				if (rgbFallback || monochrome)
				{
					return m_MaterialRGB;
				}
				return m_MaterialYUV;
			}
		}

		protected void Start()
		{
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
			else if (shaderRGB == null || shaderYUV == null)
			{
				UnityEngine.Debug.Log("Noise shaders are not set up! Disabling noise effect.");
				base.enabled = false;
			}
			else if (!shaderRGB.isSupported)
			{
				base.enabled = false;
			}
			else if (!shaderYUV.isSupported)
			{
				rgbFallback = true;
			}
		}

		protected void OnDisable()
		{
			if ((bool)m_MaterialRGB)
			{
				UnityEngine.Object.DestroyImmediate(m_MaterialRGB);
			}
			if ((bool)m_MaterialYUV)
			{
				UnityEngine.Object.DestroyImmediate(m_MaterialYUV);
			}
		}

		private void SanitizeParameters()
		{
			grainIntensityMin = Mathf.Clamp(grainIntensityMin, 0f, 5f);
			grainIntensityMax = Mathf.Clamp(grainIntensityMax, 0f, 5f);
			scratchIntensityMin = Mathf.Clamp(scratchIntensityMin, 0f, 5f);
			scratchIntensityMax = Mathf.Clamp(scratchIntensityMax, 0f, 5f);
			scratchFPS = Mathf.Clamp(scratchFPS, 1f, 30f);
			scratchJitter = Mathf.Clamp(scratchJitter, 0f, 1f);
			grainSize = Mathf.Clamp(grainSize, 0.1f, 50f);
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			SanitizeParameters();
			if (scratchTimeLeft <= 0f)
			{
				scratchTimeLeft = UnityEngine.Random.value * 2f / scratchFPS;
				scratchX = UnityEngine.Random.value;
				scratchY = UnityEngine.Random.value;
			}
			scratchTimeLeft -= Time.deltaTime;
			Material material = this.material;
			material.SetTexture("_GrainTex", grainTexture);
			material.SetTexture("_ScratchTex", scratchTexture);
			float num = 1f / grainSize;
			material.SetVector("_GrainOffsetScale", new Vector4(UnityEngine.Random.value, UnityEngine.Random.value, (float)Screen.width / (float)grainTexture.width * num, (float)Screen.height / (float)grainTexture.height * num));
			material.SetVector("_ScratchOffsetScale", new Vector4(scratchX + UnityEngine.Random.value * scratchJitter, scratchY + UnityEngine.Random.value * scratchJitter, (float)Screen.width / (float)scratchTexture.width, (float)Screen.height / (float)scratchTexture.height));
			material.SetVector("_Intensity", new Vector4(UnityEngine.Random.Range(grainIntensityMin, grainIntensityMax), UnityEngine.Random.Range(scratchIntensityMin, scratchIntensityMax), 0f, 0f));
			Graphics.Blit(source, destination, material);
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	public class PostEffectsBase : MonoBehaviour
	{
		protected bool supportHDRTextures = true;

		protected bool supportDX11;

		protected bool isSupported = true;

		private List<Material> createdMaterials = new List<Material>();

		protected Material CheckShaderAndCreateMaterial(Shader s, Material m2Create)
		{
			if (!s)
			{
				UnityEngine.Debug.Log("Missing shader in " + ToString());
				base.enabled = false;
				return null;
			}
			if (s.isSupported && (bool)m2Create && m2Create.shader == s)
			{
				return m2Create;
			}
			if (!s.isSupported)
			{
				NotSupported();
				UnityEngine.Debug.Log("The shader " + s.ToString() + " on effect " + ToString() + " is not supported on this platform!");
				return null;
			}
			m2Create = new Material(s);
			createdMaterials.Add(m2Create);
			m2Create.hideFlags = HideFlags.DontSave;
			return m2Create;
		}

		protected Material CreateMaterial(Shader s, Material m2Create)
		{
			if (!s)
			{
				UnityEngine.Debug.Log("Missing shader in " + ToString());
				return null;
			}
			if ((bool)m2Create && m2Create.shader == s && s.isSupported)
			{
				return m2Create;
			}
			if (!s.isSupported)
			{
				return null;
			}
			m2Create = new Material(s);
			createdMaterials.Add(m2Create);
			m2Create.hideFlags = HideFlags.DontSave;
			return m2Create;
		}

		private void OnEnable()
		{
			isSupported = true;
		}

		private void OnDestroy()
		{
			RemoveCreatedMaterials();
		}

		private void RemoveCreatedMaterials()
		{
			while (createdMaterials.Count > 0)
			{
				Material obj = createdMaterials[0];
				createdMaterials.RemoveAt(0);
				UnityEngine.Object.Destroy(obj);
			}
		}

		protected bool CheckSupport()
		{
			return CheckSupport(needDepth: false);
		}

		public virtual bool CheckResources()
		{
			UnityEngine.Debug.LogWarning("CheckResources () for " + ToString() + " should be overwritten.");
			return isSupported;
		}

		protected void Start()
		{
			CheckResources();
		}

		protected bool CheckSupport(bool needDepth)
		{
			isSupported = true;
			supportHDRTextures = SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.ARGBHalf);
			supportDX11 = SystemInfo.graphicsShaderLevel >= 50 && SystemInfo.supportsComputeShaders;
			if (!SystemInfo.supportsImageEffects || !SystemInfo.supportsRenderTextures)
			{
				NotSupported();
				return false;
			}
			if (needDepth && !SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.Depth))
			{
				NotSupported();
				return false;
			}
			if (needDepth)
			{
				GetComponent<Camera>().depthTextureMode |= DepthTextureMode.Depth;
			}
			return true;
		}

		protected bool CheckSupport(bool needDepth, bool needHdr)
		{
			if (!CheckSupport(needDepth))
			{
				return false;
			}
			if (needHdr && !supportHDRTextures)
			{
				NotSupported();
				return false;
			}
			return true;
		}

		public bool Dx11Support()
		{
			return supportDX11;
		}

		protected void ReportAutoDisable()
		{
			UnityEngine.Debug.LogWarning("The image effect " + ToString() + " has been disabled as it's not supported on the current platform.");
		}

		private bool CheckShader(Shader s)
		{
			UnityEngine.Debug.Log("The shader " + s.ToString() + " on effect " + ToString() + " is not part of the Unity 3.2+ effects suite anymore. For best performance and quality, please ensure you are using the latest Standard Assets Image Effects (Pro only) package.");
			if (!s.isSupported)
			{
				NotSupported();
				return false;
			}
			return false;
		}

		protected void NotSupported()
		{
			base.enabled = false;
			isSupported = false;
		}

		protected void DrawBorder(RenderTexture dest, Material material)
		{
			RenderTexture.active = dest;
			bool flag = true;
			GL.PushMatrix();
			GL.LoadOrtho();
			for (int i = 0; i < material.passCount; i++)
			{
				material.SetPass(i);
				float y;
				float y2;
				if (flag)
				{
					y = 1f;
					y2 = 0f;
				}
				else
				{
					y = 0f;
					y2 = 1f;
				}
				float x = 0f + 1f / ((float)dest.width * 1f);
				float y3 = 0f;
				float y4 = 1f;
				GL.Begin(7);
				GL.TexCoord2(0f, y);
				GL.Vertex3(0f, y3, 0.1f);
				GL.TexCoord2(1f, y);
				GL.Vertex3(x, y3, 0.1f);
				GL.TexCoord2(1f, y2);
				GL.Vertex3(x, y4, 0.1f);
				GL.TexCoord2(0f, y2);
				GL.Vertex3(0f, y4, 0.1f);
				float x2 = 1f - 1f / ((float)dest.width * 1f);
				x = 1f;
				y3 = 0f;
				y4 = 1f;
				GL.TexCoord2(0f, y);
				GL.Vertex3(x2, y3, 0.1f);
				GL.TexCoord2(1f, y);
				GL.Vertex3(x, y3, 0.1f);
				GL.TexCoord2(1f, y2);
				GL.Vertex3(x, y4, 0.1f);
				GL.TexCoord2(0f, y2);
				GL.Vertex3(x2, y4, 0.1f);
				x = 1f;
				y3 = 0f;
				y4 = 0f + 1f / ((float)dest.height * 1f);
				GL.TexCoord2(0f, y);
				GL.Vertex3(0f, y3, 0.1f);
				GL.TexCoord2(1f, y);
				GL.Vertex3(x, y3, 0.1f);
				GL.TexCoord2(1f, y2);
				GL.Vertex3(x, y4, 0.1f);
				GL.TexCoord2(0f, y2);
				GL.Vertex3(0f, y4, 0.1f);
				x = 1f;
				y3 = 1f - 1f / ((float)dest.height * 1f);
				y4 = 1f;
				GL.TexCoord2(0f, y);
				GL.Vertex3(0f, y3, 0.1f);
				GL.TexCoord2(1f, y);
				GL.Vertex3(x, y3, 0.1f);
				GL.TexCoord2(1f, y2);
				GL.Vertex3(x, y4, 0.1f);
				GL.TexCoord2(0f, y2);
				GL.Vertex3(0f, y4, 0.1f);
				GL.End();
			}
			GL.PopMatrix();
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	internal class PostEffectsHelper : MonoBehaviour
	{
		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			UnityEngine.Debug.Log("OnRenderImage in Helper called ...");
		}

		private static void DrawLowLevelPlaneAlignedWithCamera(float dist, RenderTexture source, RenderTexture dest, Material material, Camera cameraForProjectionMatrix)
		{
			RenderTexture.active = dest;
			material.SetTexture("_MainTex", source);
			bool flag = true;
			GL.PushMatrix();
			GL.LoadIdentity();
			GL.LoadProjectionMatrix(cameraForProjectionMatrix.projectionMatrix);
			float f = cameraForProjectionMatrix.fieldOfView * 0.5f * ((float)Math.PI / 180f);
			float num = Mathf.Cos(f) / Mathf.Sin(f);
			float aspect = cameraForProjectionMatrix.aspect;
			float num2 = aspect / (0f - num);
			float num3 = aspect / num;
			float num4 = 1f / (0f - num);
			float num5 = 1f / num;
			float num6 = 1f;
			num2 *= dist * num6;
			num3 *= dist * num6;
			num4 *= dist * num6;
			num5 *= dist * num6;
			float z = 0f - dist;
			for (int i = 0; i < material.passCount; i++)
			{
				material.SetPass(i);
				GL.Begin(7);
				float y;
				float y2;
				if (flag)
				{
					y = 1f;
					y2 = 0f;
				}
				else
				{
					y = 0f;
					y2 = 1f;
				}
				GL.TexCoord2(0f, y);
				GL.Vertex3(num2, num4, z);
				GL.TexCoord2(1f, y);
				GL.Vertex3(num3, num4, z);
				GL.TexCoord2(1f, y2);
				GL.Vertex3(num3, num5, z);
				GL.TexCoord2(0f, y2);
				GL.Vertex3(num2, num5, z);
				GL.End();
			}
			GL.PopMatrix();
		}

		private static void DrawBorder(RenderTexture dest, Material material)
		{
			RenderTexture.active = dest;
			bool flag = true;
			GL.PushMatrix();
			GL.LoadOrtho();
			for (int i = 0; i < material.passCount; i++)
			{
				material.SetPass(i);
				float y;
				float y2;
				if (flag)
				{
					y = 1f;
					y2 = 0f;
				}
				else
				{
					y = 0f;
					y2 = 1f;
				}
				float x = 0f + 1f / ((float)dest.width * 1f);
				float y3 = 0f;
				float y4 = 1f;
				GL.Begin(7);
				GL.TexCoord2(0f, y);
				GL.Vertex3(0f, y3, 0.1f);
				GL.TexCoord2(1f, y);
				GL.Vertex3(x, y3, 0.1f);
				GL.TexCoord2(1f, y2);
				GL.Vertex3(x, y4, 0.1f);
				GL.TexCoord2(0f, y2);
				GL.Vertex3(0f, y4, 0.1f);
				float x2 = 1f - 1f / ((float)dest.width * 1f);
				x = 1f;
				y3 = 0f;
				y4 = 1f;
				GL.TexCoord2(0f, y);
				GL.Vertex3(x2, y3, 0.1f);
				GL.TexCoord2(1f, y);
				GL.Vertex3(x, y3, 0.1f);
				GL.TexCoord2(1f, y2);
				GL.Vertex3(x, y4, 0.1f);
				GL.TexCoord2(0f, y2);
				GL.Vertex3(x2, y4, 0.1f);
				x = 1f;
				y3 = 0f;
				y4 = 0f + 1f / ((float)dest.height * 1f);
				GL.TexCoord2(0f, y);
				GL.Vertex3(0f, y3, 0.1f);
				GL.TexCoord2(1f, y);
				GL.Vertex3(x, y3, 0.1f);
				GL.TexCoord2(1f, y2);
				GL.Vertex3(x, y4, 0.1f);
				GL.TexCoord2(0f, y2);
				GL.Vertex3(0f, y4, 0.1f);
				x = 1f;
				y3 = 1f - 1f / ((float)dest.height * 1f);
				y4 = 1f;
				GL.TexCoord2(0f, y);
				GL.Vertex3(0f, y3, 0.1f);
				GL.TexCoord2(1f, y);
				GL.Vertex3(x, y3, 0.1f);
				GL.TexCoord2(1f, y2);
				GL.Vertex3(x, y4, 0.1f);
				GL.TexCoord2(0f, y2);
				GL.Vertex3(0f, y4, 0.1f);
				GL.End();
			}
			GL.PopMatrix();
		}

		private static void DrawLowLevelQuad(float x1, float x2, float y1, float y2, RenderTexture source, RenderTexture dest, Material material)
		{
			RenderTexture.active = dest;
			material.SetTexture("_MainTex", source);
			bool flag = true;
			GL.PushMatrix();
			GL.LoadOrtho();
			for (int i = 0; i < material.passCount; i++)
			{
				material.SetPass(i);
				GL.Begin(7);
				float y3;
				float y4;
				if (flag)
				{
					y3 = 1f;
					y4 = 0f;
				}
				else
				{
					y3 = 0f;
					y4 = 1f;
				}
				GL.TexCoord2(0f, y3);
				GL.Vertex3(x1, y1, 0.1f);
				GL.TexCoord2(1f, y3);
				GL.Vertex3(x2, y1, 0.1f);
				GL.TexCoord2(1f, y4);
				GL.Vertex3(x2, y2, 0.1f);
				GL.TexCoord2(0f, y4);
				GL.Vertex3(x1, y2, 0.1f);
				GL.End();
			}
			GL.PopMatrix();
		}
	}
	internal class Quads
	{
		private static Mesh[] meshes;

		private static int currentQuads;

		private static bool HasMeshes()
		{
			if (meshes == null)
			{
				return false;
			}
			Mesh[] array = meshes;
			foreach (Mesh mesh in array)
			{
				if (null == mesh)
				{
					return false;
				}
			}
			return true;
		}

		public static void Cleanup()
		{
			if (meshes == null)
			{
				return;
			}
			for (int i = 0; i < meshes.Length; i++)
			{
				if (null != meshes[i])
				{
					UnityEngine.Object.DestroyImmediate(meshes[i]);
					meshes[i] = null;
				}
			}
			meshes = null;
		}

		public static Mesh[] GetMeshes(int totalWidth, int totalHeight)
		{
			if (HasMeshes() && currentQuads == totalWidth * totalHeight)
			{
				return meshes;
			}
			int num = 10833;
			int num2 = (currentQuads = totalWidth * totalHeight);
			meshes = new Mesh[Mathf.CeilToInt(1f * (float)num2 / (1f * (float)num))];
			int num3 = 0;
			int num4 = 0;
			for (num3 = 0; num3 < num2; num3 += num)
			{
				int triCount = Mathf.FloorToInt(Mathf.Clamp(num2 - num3, 0, num));
				meshes[num4] = GetMesh(triCount, num3, totalWidth, totalHeight);
				num4++;
			}
			return meshes;
		}

		private static Mesh GetMesh(int triCount, int triOffset, int totalWidth, int totalHeight)
		{
			Mesh mesh = new Mesh();
			mesh.hideFlags = HideFlags.DontSave;
			Vector3[] array = new Vector3[triCount * 4];
			Vector2[] array2 = new Vector2[triCount * 4];
			Vector2[] array3 = new Vector2[triCount * 4];
			int[] array4 = new int[triCount * 6];
			for (int i = 0; i < triCount; i++)
			{
				int num = i * 4;
				int num2 = i * 6;
				int num3 = triOffset + i;
				float num4 = Mathf.Floor(num3 % totalWidth) / (float)totalWidth;
				float num5 = Mathf.Floor(num3 / totalWidth) / (float)totalHeight;
				array[num + 3] = (array[num + 2] = (array[num + 1] = (array[num] = new Vector3(num4 * 2f - 1f, num5 * 2f - 1f, 1f))));
				array2[num] = new Vector2(0f, 0f);
				array2[num + 1] = new Vector2(1f, 0f);
				array2[num + 2] = new Vector2(0f, 1f);
				array2[num + 3] = new Vector2(1f, 1f);
				array3[num] = new Vector2(num4, num5);
				array3[num + 1] = new Vector2(num4, num5);
				array3[num + 2] = new Vector2(num4, num5);
				array3[num + 3] = new Vector2(num4, num5);
				array4[num2] = num;
				array4[num2 + 1] = num + 1;
				array4[num2 + 2] = num + 2;
				array4[num2 + 3] = num + 1;
				array4[num2 + 4] = num + 2;
				array4[num2 + 5] = num + 3;
			}
			mesh.vertices = array;
			mesh.triangles = array4;
			mesh.uv = array2;
			mesh.uv2 = array3;
			return mesh;
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Other/Screen Overlay")]
	public class ScreenOverlay : PostEffectsBase
	{
		public enum OverlayBlendMode
		{
			Additive,
			ScreenBlend,
			Multiply,
			Overlay,
			AlphaBlend
		}

		public OverlayBlendMode blendMode = OverlayBlendMode.Overlay;

		public float intensity = 1f;

		public Texture2D texture;

		public Shader overlayShader;

		private Material overlayMaterial;

		public override bool CheckResources()
		{
			CheckSupport(needDepth: false);
			overlayMaterial = CheckShaderAndCreateMaterial(overlayShader, overlayMaterial);
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources())
			{
				Graphics.Blit(source, destination);
				return;
			}
			Vector4 value = new Vector4(1f, 0f, 0f, 1f);
			overlayMaterial.SetVector("_UV_Transform", value);
			overlayMaterial.SetFloat("_Intensity", intensity);
			overlayMaterial.SetTexture("_Overlay", texture);
			Graphics.Blit(source, destination, overlayMaterial, (int)blendMode);
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Rendering/Screen Space Ambient Occlusion")]
	public class ScreenSpaceAmbientOcclusion : MonoBehaviour
	{
		public enum SSAOSamples
		{
			Low,
			Medium,
			High
		}

		[Range(0.05f, 1f)]
		public float m_Radius = 0.4f;

		public SSAOSamples m_SampleCount = SSAOSamples.Medium;

		[Range(0.5f, 4f)]
		public float m_OcclusionIntensity = 1.5f;

		[Range(0f, 4f)]
		public int m_Blur = 2;

		[Range(1f, 6f)]
		public int m_Downsampling = 2;

		[Range(0.2f, 2f)]
		public float m_OcclusionAttenuation = 1f;

		[Range(1E-05f, 0.5f)]
		public float m_MinZ = 0.01f;

		public Shader m_SSAOShader;

		private Material m_SSAOMaterial;

		public Texture2D m_RandomTexture;

		private bool m_Supported;

		private static Material CreateMaterial(Shader shader)
		{
			if (!shader)
			{
				return null;
			}
			return new Material(shader)
			{
				hideFlags = HideFlags.HideAndDontSave
			};
		}

		private static void DestroyMaterial(Material mat)
		{
			if ((bool)mat)
			{
				UnityEngine.Object.DestroyImmediate(mat);
				mat = null;
			}
		}

		private void OnDisable()
		{
			DestroyMaterial(m_SSAOMaterial);
		}

		private void Start()
		{
			if (!SystemInfo.supportsImageEffects || !SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.Depth))
			{
				m_Supported = false;
				base.enabled = false;
				return;
			}
			CreateMaterials();
			if (!m_SSAOMaterial || m_SSAOMaterial.passCount != 5)
			{
				m_Supported = false;
				base.enabled = false;
			}
			else
			{
				m_Supported = true;
			}
		}

		private void OnEnable()
		{
			GetComponent<Camera>().depthTextureMode |= DepthTextureMode.DepthNormals;
		}

		private void CreateMaterials()
		{
			if (!m_SSAOMaterial && m_SSAOShader.isSupported)
			{
				m_SSAOMaterial = CreateMaterial(m_SSAOShader);
				m_SSAOMaterial.SetTexture("_RandomTexture", m_RandomTexture);
			}
		}

		[ImageEffectOpaque]
		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!m_Supported || !m_SSAOShader.isSupported)
			{
				base.enabled = false;
				return;
			}
			CreateMaterials();
			m_Downsampling = Mathf.Clamp(m_Downsampling, 1, 6);
			m_Radius = Mathf.Clamp(m_Radius, 0.05f, 1f);
			m_MinZ = Mathf.Clamp(m_MinZ, 1E-05f, 0.5f);
			m_OcclusionIntensity = Mathf.Clamp(m_OcclusionIntensity, 0.5f, 4f);
			m_OcclusionAttenuation = Mathf.Clamp(m_OcclusionAttenuation, 0.2f, 2f);
			m_Blur = Mathf.Clamp(m_Blur, 0, 4);
			RenderTexture renderTexture = RenderTexture.GetTemporary(source.width / m_Downsampling, source.height / m_Downsampling, 0);
			float fieldOfView = GetComponent<Camera>().fieldOfView;
			float farClipPlane = GetComponent<Camera>().farClipPlane;
			float num = Mathf.Tan(fieldOfView * ((float)Math.PI / 180f) * 0.5f) * farClipPlane;
			float x = num * GetComponent<Camera>().aspect;
			m_SSAOMaterial.SetVector("_FarCorner", new Vector3(x, num, farClipPlane));
			int num2;
			int num3;
			if ((bool)m_RandomTexture)
			{
				num2 = m_RandomTexture.width;
				num3 = m_RandomTexture.height;
			}
			else
			{
				num2 = 1;
				num3 = 1;
			}
			m_SSAOMaterial.SetVector("_NoiseScale", new Vector3((float)renderTexture.width / (float)num2, (float)renderTexture.height / (float)num3, 0f));
			m_SSAOMaterial.SetVector("_Params", new Vector4(m_Radius, m_MinZ, 1f / m_OcclusionAttenuation, m_OcclusionIntensity));
			bool num4 = m_Blur > 0;
			Graphics.Blit(num4 ? null : source, renderTexture, m_SSAOMaterial, (int)m_SampleCount);
			if (num4)
			{
				RenderTexture temporary = RenderTexture.GetTemporary(source.width, source.height, 0);
				m_SSAOMaterial.SetVector("_TexelOffsetScale", new Vector4((float)m_Blur / (float)source.width, 0f, 0f, 0f));
				m_SSAOMaterial.SetTexture("_SSAO", renderTexture);
				Graphics.Blit(null, temporary, m_SSAOMaterial, 3);
				RenderTexture.ReleaseTemporary(renderTexture);
				RenderTexture temporary2 = RenderTexture.GetTemporary(source.width, source.height, 0);
				m_SSAOMaterial.SetVector("_TexelOffsetScale", new Vector4(0f, (float)m_Blur / (float)source.height, 0f, 0f));
				m_SSAOMaterial.SetTexture("_SSAO", temporary);
				Graphics.Blit(source, temporary2, m_SSAOMaterial, 3);
				RenderTexture.ReleaseTemporary(temporary);
				renderTexture = temporary2;
			}
			m_SSAOMaterial.SetTexture("_SSAO", renderTexture);
			Graphics.Blit(source, destination, m_SSAOMaterial, 4);
			RenderTexture.ReleaseTemporary(renderTexture);
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Image Effects/Color Adjustments/Sepia Tone")]
	public class SepiaTone : ImageEffectBase
	{
		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			Graphics.Blit(source, destination, base.material);
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Rendering/Sun Shafts")]
	public class SunShafts : PostEffectsBase
	{
		public enum SunShaftsResolution
		{
			Low,
			Normal,
			High
		}

		public enum ShaftsScreenBlendMode
		{
			Screen,
			Add
		}

		public SunShaftsResolution resolution = SunShaftsResolution.Normal;

		public ShaftsScreenBlendMode screenBlendMode;

		public Transform sunTransform;

		public int radialBlurIterations = 2;

		public Color sunColor = Color.white;

		public Color sunThreshold = new Color(0.87f, 0.74f, 0.65f);

		public float sunShaftBlurRadius = 2.5f;

		public float sunShaftIntensity = 1.15f;

		public float maxRadius = 0.75f;

		public bool useDepthTexture = true;

		public Shader sunShaftsShader;

		private Material sunShaftsMaterial;

		public Shader simpleClearShader;

		private Material simpleClearMaterial;

		public override bool CheckResources()
		{
			CheckSupport(useDepthTexture);
			sunShaftsMaterial = CheckShaderAndCreateMaterial(sunShaftsShader, sunShaftsMaterial);
			simpleClearMaterial = CheckShaderAndCreateMaterial(simpleClearShader, simpleClearMaterial);
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources())
			{
				Graphics.Blit(source, destination);
				return;
			}
			if (useDepthTexture)
			{
				GetComponent<Camera>().depthTextureMode |= DepthTextureMode.Depth;
			}
			int num = 4;
			if (resolution == SunShaftsResolution.Normal)
			{
				num = 2;
			}
			else if (resolution == SunShaftsResolution.High)
			{
				num = 1;
			}
			Vector3 vector = Vector3.one * 0.5f;
			vector = ((!sunTransform) ? new Vector3(0.5f, 0.5f, 0f) : GetComponent<Camera>().WorldToViewportPoint(sunTransform.position));
			int width = source.width / num;
			int height = source.height / num;
			RenderTexture temporary = RenderTexture.GetTemporary(width, height, 0);
			sunShaftsMaterial.SetVector("_BlurRadius4", new Vector4(1f, 1f, 0f, 0f) * sunShaftBlurRadius);
			sunShaftsMaterial.SetVector("_SunPosition", new Vector4(vector.x, vector.y, vector.z, maxRadius));
			sunShaftsMaterial.SetVector("_SunThreshold", sunThreshold);
			if (!useDepthTexture)
			{
				RenderTextureFormat format = (GetComponent<Camera>().allowHDR ? RenderTextureFormat.DefaultHDR : RenderTextureFormat.Default);
				RenderTexture renderTexture = (RenderTexture.active = RenderTexture.GetTemporary(source.width, source.height, 0, format));
				GL.ClearWithSkybox(clearDepth: false, GetComponent<Camera>());
				sunShaftsMaterial.SetTexture("_Skybox", renderTexture);
				Graphics.Blit(source, temporary, sunShaftsMaterial, 3);
				RenderTexture.ReleaseTemporary(renderTexture);
			}
			else
			{
				Graphics.Blit(source, temporary, sunShaftsMaterial, 2);
			}
			DrawBorder(temporary, simpleClearMaterial);
			radialBlurIterations = Mathf.Clamp(radialBlurIterations, 1, 4);
			float num2 = sunShaftBlurRadius * 0.0013020834f;
			sunShaftsMaterial.SetVector("_BlurRadius4", new Vector4(num2, num2, 0f, 0f));
			sunShaftsMaterial.SetVector("_SunPosition", new Vector4(vector.x, vector.y, vector.z, maxRadius));
			for (int i = 0; i < radialBlurIterations; i++)
			{
				RenderTexture temporary3 = RenderTexture.GetTemporary(width, height, 0);
				Graphics.Blit(temporary, temporary3, sunShaftsMaterial, 1);
				RenderTexture.ReleaseTemporary(temporary);
				num2 = sunShaftBlurRadius * (((float)i * 2f + 1f) * 6f) / 768f;
				sunShaftsMaterial.SetVector("_BlurRadius4", new Vector4(num2, num2, 0f, 0f));
				temporary = RenderTexture.GetTemporary(width, height, 0);
				Graphics.Blit(temporary3, temporary, sunShaftsMaterial, 1);
				RenderTexture.ReleaseTemporary(temporary3);
				num2 = sunShaftBlurRadius * (((float)i * 2f + 2f) * 6f) / 768f;
				sunShaftsMaterial.SetVector("_BlurRadius4", new Vector4(num2, num2, 0f, 0f));
			}
			if (vector.z >= 0f)
			{
				sunShaftsMaterial.SetVector("_SunColor", new Vector4(sunColor.r, sunColor.g, sunColor.b, sunColor.a) * sunShaftIntensity);
			}
			else
			{
				sunShaftsMaterial.SetVector("_SunColor", Vector4.zero);
			}
			sunShaftsMaterial.SetTexture("_ColorBuffer", temporary);
			Graphics.Blit(source, destination, sunShaftsMaterial, (screenBlendMode != 0) ? 4 : 0);
			RenderTexture.ReleaseTemporary(temporary);
		}
	}
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Camera/Tilt Shift (Lens Blur)")]
	internal class TiltShift : PostEffectsBase
	{
		public enum TiltShiftMode
		{
			TiltShiftMode,
			IrisMode
		}

		public enum TiltShiftQuality
		{
			Preview,
			Normal,
			High
		}

		public TiltShiftMode mode;

		public TiltShiftQuality quality = TiltShiftQuality.Normal;

		[Range(0f, 15f)]
		public float blurArea = 1f;

		[Range(0f, 25f)]
		public float maxBlurSize = 5f;

		[Range(0f, 1f)]
		public int downsample;

		public Shader tiltShiftShader;

		private Material tiltShiftMaterial;

		public override bool CheckResources()
		{
			CheckSupport(needDepth: true);
			tiltShiftMaterial = CheckShaderAndCreateMaterial(tiltShiftShader, tiltShiftMaterial);
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources())
			{
				Graphics.Blit(source, destination);
				return;
			}
			tiltShiftMaterial.SetFloat("_BlurSize", (maxBlurSize < 0f) ? 0f : maxBlurSize);
			tiltShiftMaterial.SetFloat("_BlurArea", blurArea);
			source.filterMode = FilterMode.Bilinear;
			RenderTexture renderTexture = destination;
			if ((float)downsample > 0f)
			{
				renderTexture = RenderTexture.GetTemporary(source.width >> downsample, source.height >> downsample, 0, source.format);
				renderTexture.filterMode = FilterMode.Bilinear;
			}
			int num = (int)quality;
			num *= 2;
			Graphics.Blit(source, renderTexture, tiltShiftMaterial, (mode == TiltShiftMode.TiltShiftMode) ? num : (num + 1));
			if (downsample > 0)
			{
				tiltShiftMaterial.SetTexture("_Blurred", renderTexture);
				Graphics.Blit(source, destination, tiltShiftMaterial, 6);
			}
			if (renderTexture != destination)
			{
				RenderTexture.ReleaseTemporary(renderTexture);
			}
		}
	}
	[ImageEffectAllowedInSceneView]
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Color Adjustments/Tonemapping")]
	public class Tonemapping : PostEffectsBase
	{
		public enum TonemapperType
		{
			SimpleReinhard,
			UserCurve,
			Hable,
			Photographic,
			OptimizedHejiDawson,
			AdaptiveReinhard,
			AdaptiveReinhardAutoWhite
		}

		public enum AdaptiveTexSize
		{
			Square16 = 0x10,
			Square32 = 0x20,
			Square64 = 0x40,
			Square128 = 0x80,
			Square256 = 0x100,
			Square512 = 0x200,
			Square1024 = 0x400
		}

		public TonemapperType type = TonemapperType.Photographic;

		public AdaptiveTexSize adaptiveTextureSize = AdaptiveTexSize.Square256;

		public AnimationCurve remapCurve;

		private Texture2D curveTex;

		public float exposureAdjustment = 1.5f;

		public float middleGrey = 0.4f;

		public float white = 2f;

		public float adaptionSpeed = 1.5f;

		public Shader tonemapper;

		public bool validRenderTextureFormat = true;

		private Material tonemapMaterial;

		private RenderTexture rt;

		private RenderTextureFormat rtFormat = RenderTextureFormat.ARGBHalf;

		public override bool CheckResources()
		{
			CheckSupport(needDepth: false, needHdr: true);
			tonemapMaterial = CheckShaderAndCreateMaterial(tonemapper, tonemapMaterial);
			if (!curveTex && type == TonemapperType.UserCurve)
			{
				curveTex = new Texture2D(256, 1, TextureFormat.ARGB32, mipChain: false, linear: true);
				curveTex.filterMode = FilterMode.Bilinear;
				curveTex.wrapMode = TextureWrapMode.Clamp;
				curveTex.hideFlags = HideFlags.DontSave;
			}
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		public float UpdateCurve()
		{
			float num = 1f;
			if (remapCurve.keys.Length < 1)
			{
				remapCurve = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(2f, 1f));
			}
			if (remapCurve != null)
			{
				if (remapCurve.length > 0)
				{
					num = remapCurve[remapCurve.length - 1].time;
				}
				for (float num2 = 0f; num2 <= 1f; num2 += 0.003921569f)
				{
					float num3 = remapCurve.Evaluate(num2 * 1f * num);
					curveTex.SetPixel((int)Mathf.Floor(num2 * 255f), 0, new Color(num3, num3, num3));
				}
				curveTex.Apply();
			}
			return 1f / num;
		}

		private void OnDisable()
		{
			if ((bool)rt)
			{
				UnityEngine.Object.DestroyImmediate(rt);
				rt = null;
			}
			if ((bool)tonemapMaterial)
			{
				UnityEngine.Object.DestroyImmediate(tonemapMaterial);
				tonemapMaterial = null;
			}
			if ((bool)curveTex)
			{
				UnityEngine.Object.DestroyImmediate(curveTex);
				curveTex = null;
			}
		}

		private bool CreateInternalRenderTexture()
		{
			if ((bool)rt)
			{
				return false;
			}
			rtFormat = (SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.RGHalf) ? RenderTextureFormat.RGHalf : RenderTextureFormat.ARGBHalf);
			rt = new RenderTexture(1, 1, 0, rtFormat);
			rt.hideFlags = HideFlags.DontSave;
			return true;
		}

		[ImageEffectTransformsToLDR]
		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources())
			{
				Graphics.Blit(source, destination);
				return;
			}
			exposureAdjustment = ((exposureAdjustment < 0.001f) ? 0.001f : exposureAdjustment);
			if (type == TonemapperType.UserCurve)
			{
				float value = UpdateCurve();
				tonemapMaterial.SetFloat("_RangeScale", value);
				tonemapMaterial.SetTexture("_Curve", curveTex);
				Graphics.Blit(source, destination, tonemapMaterial, 4);
				return;
			}
			if (type == TonemapperType.SimpleReinhard)
			{
				tonemapMaterial.SetFloat("_ExposureAdjustment", exposureAdjustment);
				Graphics.Blit(source, destination, tonemapMaterial, 6);
				return;
			}
			if (type == TonemapperType.Hable)
			{
				tonemapMaterial.SetFloat("_ExposureAdjustment", exposureAdjustment);
				Graphics.Blit(source, destination, tonemapMaterial, 5);
				return;
			}
			if (type == TonemapperType.Photographic)
			{
				tonemapMaterial.SetFloat("_ExposureAdjustment", exposureAdjustment);
				Graphics.Blit(source, destination, tonemapMaterial, 8);
				return;
			}
			if (type == TonemapperType.OptimizedHejiDawson)
			{
				tonemapMaterial.SetFloat("_ExposureAdjustment", 0.5f * exposureAdjustment);
				Graphics.Blit(source, destination, tonemapMaterial, 7);
				return;
			}
			bool flag = CreateInternalRenderTexture();
			RenderTexture temporary = RenderTexture.GetTemporary((int)adaptiveTextureSize, (int)adaptiveTextureSize, 0, rtFormat);
			Graphics.Blit(source, temporary);
			int num = (int)Mathf.Log((float)temporary.width * 1f, 2f);
			int num2 = 2;
			RenderTexture[] array = new RenderTexture[num];
			for (int i = 0; i < num; i++)
			{
				array[i] = RenderTexture.GetTemporary(temporary.width / num2, temporary.width / num2, 0, rtFormat);
				num2 *= 2;
			}
			RenderTexture source2 = array[num - 1];
			Graphics.Blit(temporary, array[0], tonemapMaterial, 1);
			if (type == TonemapperType.AdaptiveReinhardAutoWhite)
			{
				for (int j = 0; j < num - 1; j++)
				{
					Graphics.Blit(array[j], array[j + 1], tonemapMaterial, 9);
					source2 = array[j + 1];
				}
			}
			else if (type == TonemapperType.AdaptiveReinhard)
			{
				for (int k = 0; k < num - 1; k++)
				{
					Graphics.Blit(array[k], array[k + 1]);
					source2 = array[k + 1];
				}
			}
			adaptionSpeed = ((adaptionSpeed < 0.001f) ? 0.001f : adaptionSpeed);
			tonemapMaterial.SetFloat("_AdaptionSpeed", adaptionSpeed);
			rt.MarkRestoreExpected();
			Graphics.Blit(source2, rt, tonemapMaterial, flag ? 3 : 2);
			middleGrey = ((middleGrey < 0.001f) ? 0.001f : middleGrey);
			tonemapMaterial.SetVector("_HdrParams", new Vector4(middleGrey, middleGrey, middleGrey, white * white));
			tonemapMaterial.SetTexture("_SmallTex", rt);
			if (type == TonemapperType.AdaptiveReinhard)
			{
				Graphics.Blit(source, destination, tonemapMaterial, 0);
			}
			else if (type == TonemapperType.AdaptiveReinhardAutoWhite)
			{
				Graphics.Blit(source, destination, tonemapMaterial, 10);
			}
			else
			{
				UnityEngine.Debug.LogError("No valid adaptive tonemapper type found!");
				Graphics.Blit(source, destination);
			}
			for (int l = 0; l < num; l++)
			{
				RenderTexture.ReleaseTemporary(array[l]);
			}
			RenderTexture.ReleaseTemporary(temporary);
		}
	}
	internal class Triangles
	{
		private static Mesh[] meshes;

		private static int currentTris;

		private static bool HasMeshes()
		{
			if (meshes == null)
			{
				return false;
			}
			for (int i = 0; i < meshes.Length; i++)
			{
				if (null == meshes[i])
				{
					return false;
				}
			}
			return true;
		}

		private static void Cleanup()
		{
			if (meshes == null)
			{
				return;
			}
			for (int i = 0; i < meshes.Length; i++)
			{
				if (null != meshes[i])
				{
					UnityEngine.Object.DestroyImmediate(meshes[i]);
					meshes[i] = null;
				}
			}
			meshes = null;
		}

		private static Mesh[] GetMeshes(int totalWidth, int totalHeight)
		{
			if (HasMeshes() && currentTris == totalWidth * totalHeight)
			{
				return meshes;
			}
			int num = 21666;
			int num2 = (currentTris = totalWidth * totalHeight);
			meshes = new Mesh[Mathf.CeilToInt(1f * (float)num2 / (1f * (float)num))];
			int num3 = 0;
			int num4 = 0;
			for (num3 = 0; num3 < num2; num3 += num)
			{
				int triCount = Mathf.FloorToInt(Mathf.Clamp(num2 - num3, 0, num));
				meshes[num4] = GetMesh(triCount, num3, totalWidth, totalHeight);
				num4++;
			}
			return meshes;
		}

		private static Mesh GetMesh(int triCount, int triOffset, int totalWidth, int totalHeight)
		{
			Mesh mesh = new Mesh();
			mesh.hideFlags = HideFlags.DontSave;
			Vector3[] array = new Vector3[triCount * 3];
			Vector2[] array2 = new Vector2[triCount * 3];
			Vector2[] array3 = new Vector2[triCount * 3];
			int[] array4 = new int[triCount * 3];
			for (int i = 0; i < triCount; i++)
			{
				int num = i * 3;
				int num2 = triOffset + i;
				float num3 = Mathf.Floor(num2 % totalWidth) / (float)totalWidth;
				float num4 = Mathf.Floor(num2 / totalWidth) / (float)totalHeight;
				array[num + 2] = (array[num + 1] = (array[num] = new Vector3(num3 * 2f - 1f, num4 * 2f - 1f, 1f)));
				array2[num] = new Vector2(0f, 0f);
				array2[num + 1] = new Vector2(1f, 0f);
				array2[num + 2] = new Vector2(0f, 1f);
				array3[num] = new Vector2(num3, num4);
				array3[num + 1] = new Vector2(num3, num4);
				array3[num + 2] = new Vector2(num3, num4);
				array4[num] = num;
				array4[num + 1] = num + 1;
				array4[num + 2] = num + 2;
			}
			mesh.vertices = array;
			mesh.triangles = array4;
			mesh.uv = array2;
			mesh.uv2 = array3;
			return mesh;
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Image Effects/Displacement/Twirl")]
	public class Twirl : ImageEffectBase
	{
		public Vector2 radius = new Vector2(0.3f, 0.3f);

		[Range(0f, 360f)]
		public float angle = 50f;

		public Vector2 center = new Vector2(0.5f, 0.5f);

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			ImageEffects.RenderDistortion(base.material, source, destination, angle, center, radius);
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Camera/Vignette and Chromatic Aberration")]
	public class VignetteAndChromaticAberration : PostEffectsBase
	{
		public enum AberrationMode
		{
			Simple,
			Advanced
		}

		public AberrationMode mode;

		public float intensity = 0.036f;

		public float chromaticAberration = 0.2f;

		public float axialAberration = 0.5f;

		public float blur;

		public float blurSpread = 0.75f;

		public float luminanceDependency = 0.25f;

		public float blurDistance = 2.5f;

		public Shader vignetteShader;

		public Shader separableBlurShader;

		public Shader chromAberrationShader;

		private Material m_VignetteMaterial;

		private Material m_SeparableBlurMaterial;

		private Material m_ChromAberrationMaterial;

		public override bool CheckResources()
		{
			CheckSupport(needDepth: false);
			m_VignetteMaterial = CheckShaderAndCreateMaterial(vignetteShader, m_VignetteMaterial);
			m_SeparableBlurMaterial = CheckShaderAndCreateMaterial(separableBlurShader, m_SeparableBlurMaterial);
			m_ChromAberrationMaterial = CheckShaderAndCreateMaterial(chromAberrationShader, m_ChromAberrationMaterial);
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources())
			{
				Graphics.Blit(source, destination);
				return;
			}
			int width = source.width;
			int height = source.height;
			bool flag = Mathf.Abs(blur) > 0f || Mathf.Abs(intensity) > 0f;
			float num = 1f * (float)width / (1f * (float)height);
			RenderTexture renderTexture = null;
			RenderTexture renderTexture2 = null;
			if (flag)
			{
				renderTexture = RenderTexture.GetTemporary(width, height, 0, source.format);
				if (Mathf.Abs(blur) > 0f)
				{
					renderTexture2 = RenderTexture.GetTemporary(width / 2, height / 2, 0, source.format);
					Graphics.Blit(source, renderTexture2, m_ChromAberrationMaterial, 0);
					for (int i = 0; i < 2; i++)
					{
						m_SeparableBlurMaterial.SetVector("offsets", new Vector4(0f, blurSpread * 0.001953125f, 0f, 0f));
						RenderTexture temporary = RenderTexture.GetTemporary(width / 2, height / 2, 0, source.format);
						Graphics.Blit(renderTexture2, temporary, m_SeparableBlurMaterial);
						RenderTexture.ReleaseTemporary(renderTexture2);
						m_SeparableBlurMaterial.SetVector("offsets", new Vector4(blurSpread * 0.001953125f / num, 0f, 0f, 0f));
						renderTexture2 = RenderTexture.GetTemporary(width / 2, height / 2, 0, source.format);
						Graphics.Blit(temporary, renderTexture2, m_SeparableBlurMaterial);
						RenderTexture.ReleaseTemporary(temporary);
					}
				}
				m_VignetteMaterial.SetFloat("_Intensity", 1f / (1f - intensity) - 1f);
				m_VignetteMaterial.SetFloat("_Blur", 1f / (1f - blur) - 1f);
				m_VignetteMaterial.SetTexture("_VignetteTex", renderTexture2);
				Graphics.Blit(source, renderTexture, m_VignetteMaterial, 0);
			}
			m_ChromAberrationMaterial.SetFloat("_ChromaticAberration", chromaticAberration);
			m_ChromAberrationMaterial.SetFloat("_AxialAberration", axialAberration);
			m_ChromAberrationMaterial.SetVector("_BlurDistance", new Vector2(0f - blurDistance, blurDistance));
			m_ChromAberrationMaterial.SetFloat("_Luminance", 1f / Mathf.Max(Mathf.Epsilon, luminanceDependency));
			if (flag)
			{
				renderTexture.wrapMode = TextureWrapMode.Clamp;
			}
			else
			{
				source.wrapMode = TextureWrapMode.Clamp;
			}
			Graphics.Blit(flag ? renderTexture : source, destination, m_ChromAberrationMaterial, (mode != AberrationMode.Advanced) ? 1 : 2);
			RenderTexture.ReleaseTemporary(renderTexture);
			RenderTexture.ReleaseTemporary(renderTexture2);
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Image Effects/Displacement/Vortex")]
	public class Vortex : ImageEffectBase
	{
		public Vector2 radius = new Vector2(0.4f, 0.4f);

		public float angle = 50f;

		public Vector2 center = new Vector2(0.5f, 0.5f);

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			ImageEffects.RenderDistortion(base.material, source, destination, angle, center, radius);
		}
	}
}
namespace HeurekaGames
{
	public static class Extensions
	{
		public static Vector2 YZ(this Vector3 v)
		{
			return new Vector2(v.x, v.z);
		}

		public static Vector2[] YZ(this Vector3[] v)
		{
			Vector2[] array = new Vector2[v.Length];
			for (int i = 0; i < v.Length; i++)
			{
				array[i] = new Vector2(v[i].x, v[i].z);
			}
			return array;
		}

		public static float Remap(this float value, float from1, float to1, float from2, float to2)
		{
			return (value - from1) / (to1 - from1) * (to2 - from2) + from2;
		}

		public static string ToCamelCase(this string camelCaseString)
		{
			return Regex.Replace(camelCaseString, "([a-z](?=[A-Z])|[A-Z](?=[A-Z][a-z]))", "$1 ").Trim();
		}

		public static void SetComponentRecursively<T>(this GameObject gameObject, bool tf) where T : Component
		{
			T[] componentsInChildren = gameObject.GetComponentsInChildren<T>();
			foreach (T obj in componentsInChildren)
			{
				try
				{
					PropertyInfo property = typeof(T).GetProperty("enabled");
					if (null != property && property.CanWrite)
					{
						property.SetValue(obj, tf, null);
						continue;
					}
					Console.WriteLine("BLABLA");
					UnityEngine.Debug.Log("Property does not exist, or cannot write");
				}
				catch (NullReferenceException ex)
				{
					UnityEngine.Debug.Log("The property does not exist in MyClass." + ex.Message);
				}
			}
		}

		public static void CastList<T>(this List<T> targetList)
		{
			targetList = targetList.Cast<T>().ToList();
		}

		public static bool Has<T>(this Enum type, T value)
		{
			try
			{
				return ((int)(object)type & (int)(object)value) == (int)(object)value;
			}
			catch
			{
				return false;
			}
		}

		public static bool Is<T>(this Enum type, T value)
		{
			try
			{
				return (int)(object)type == (int)(object)value;
			}
			catch
			{
				return false;
			}
		}

		public static T Add<T>(this Enum type, T value)
		{
			try
			{
				return (T)(object)((int)(object)type | (int)(object)value);
			}
			catch (Exception innerException)
			{
				throw new ArgumentException($"Could not append value from enumerated type '{typeof(T).Name}'.", innerException);
			}
		}

		public static T Remove<T>(this Enum type, T value)
		{
			try
			{
				return (T)(object)((int)(object)type & ~(int)(object)value);
			}
			catch (Exception innerException)
			{
				throw new ArgumentException($"Could not remove value from enumerated type '{typeof(T).Name}'.", innerException);
			}
		}

		public static Color ModifiedAlpha(this Color color, float alpha)
		{
			Color result = color;
			result.a = alpha;
			return result;
		}
	}
	public class Singleton<T> : MonoBehaviour where T : MonoBehaviour
	{
		private static T _instance;

		private static object _lock = new object();

		private static bool applicationIsQuitting = false;

		public static T Instance
		{
			get
			{
				if (applicationIsQuitting)
				{
					UnityEngine.Debug.LogWarning(string.Concat("[Singleton] Instance '", typeof(T), "' already destroyed on application quit. Won't create again - returning null."));
					return null;
				}
				lock (_lock)
				{
					if (_instance == null)
					{
						_instance = (T)UnityEngine.Object.FindObjectOfType(typeof(T));
						if (UnityEngine.Object.FindObjectsOfType(typeof(T)).Length > 1)
						{
							UnityEngine.Debug.LogError("[Singleton] Something went really wrong  - there should never be more than 1 singleton! Reopenning the scene might fix it.");
							return _instance;
						}
						if (_instance == null)
						{
							GameObject obj = new GameObject();
							_instance = obj.AddComponent<T>();
							obj.name = "(singleton) " + typeof(T).ToString();
							UnityEngine.Debug.Log(string.Concat("[Singleton] An instance of ", typeof(T), " was created."));
						}
						else
						{
							UnityEngine.Debug.Log("[Singleton] Using instance already created: " + _instance.gameObject.name);
						}
					}
					return _instance;
				}
			}
		}

		public void OnDestroy()
		{
			applicationIsQuitting = true;
		}
	}
}
namespace DigitalOpus.MB.Core
{
	public class MBVersionConcrete : MBVersionInterface
	{
		private Vector2 _HALF_UV = new Vector2(0.5f, 0.5f);

		public string version()
		{
			return "3.19";
		}

		public int GetMajorVersion()
		{
			return int.Parse(Application.unityVersion.Split('.')[0]);
		}

		public int GetMinorVersion()
		{
			return int.Parse(Application.unityVersion.Split('.')[1]);
		}

		public bool GetActive(GameObject go)
		{
			return go.activeInHierarchy;
		}

		public void SetActive(GameObject go, bool isActive)
		{
			go.SetActive(isActive);
		}

		public void SetActiveRecursively(GameObject go, bool isActive)
		{
			go.SetActive(isActive);
		}

		public UnityEngine.Object[] FindSceneObjectsOfType(Type t)
		{
			return UnityEngine.Object.FindObjectsOfType(t);
		}

		public bool IsRunningAndMeshNotReadWriteable(Mesh m)
		{
			if (Application.isPlaying)
			{
				return !m.isReadable;
			}
			return false;
		}

		public Vector2[] GetMeshUV1s(Mesh m, MB2_LogLevel LOG_LEVEL)
		{
			if (LOG_LEVEL >= MB2_LogLevel.warn)
			{
				MB2_Log.LogDebug("UV1 does not exist in Unity 5+");
			}
			Vector2[] array = m.uv;
			if (array.Length == 0)
			{
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug(string.Concat("Mesh ", m, " has no uv1s. Generating"));
				}
				if (LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning(string.Concat("Mesh ", m, " didn't have uv1s. Generating uv1s."));
				}
				array = new Vector2[m.vertexCount];
				for (int i = 0; i < array.Length; i++)
				{
					array[i] = _HALF_UV;
				}
			}
			return array;
		}

		public Vector2[] GetMeshUV3orUV4(Mesh m, bool get3, MB2_LogLevel LOG_LEVEL)
		{
			Vector2[] array = ((!get3) ? m.uv4 : m.uv3);
			if (array.Length == 0)
			{
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug(string.Concat("Mesh ", m, " has no uv", get3 ? "3" : "4", ". Generating"));
				}
				array = new Vector2[m.vertexCount];
				for (int i = 0; i < array.Length; i++)
				{
					array[i] = _HALF_UV;
				}
			}
			return array;
		}

		public void MeshClear(Mesh m, bool t)
		{
			m.Clear(t);
		}

		public void MeshAssignUV3(Mesh m, Vector2[] uv3s)
		{
			m.uv3 = uv3s;
		}

		public void MeshAssignUV4(Mesh m, Vector2[] uv4s)
		{
			m.uv4 = uv4s;
		}

		public Vector4 GetLightmapTilingOffset(Renderer r)
		{
			return r.lightmapScaleOffset;
		}

		public Transform[] GetBones(Renderer r)
		{
			if (r is SkinnedMeshRenderer)
			{
				return ((SkinnedMeshRenderer)r).bones;
			}
			if (r is MeshRenderer)
			{
				return new Transform[1] { r.transform };
			}
			UnityEngine.Debug.LogError("Could not getBones. Object does not have a renderer");
			return null;
		}
	}
	[Serializable]
	public class GrouperData
	{
		public bool clusterOnLMIndex;

		public bool clusterByLODLevel;

		public Vector3 origin;

		public Vector3 cellSize;

		public int pieNumSegments = 4;

		public Vector3 pieAxis = Vector3.up;

		public int height = 1;

		public float maxDistBetweenClusters = 1f;
	}
	[Serializable]
	public abstract class MB3_MeshBakerGrouperCore
	{
		public GrouperData d;

		public abstract Dictionary<string, List<Renderer>> FilterIntoGroups(List<GameObject> selection);

		public abstract void DrawGizmos(Bounds sourceObjectBounds);

		public void DoClustering(MB3_TextureBaker tb)
		{
			Dictionary<string, List<Renderer>> dictionary = FilterIntoGroups(tb.GetObjectsToCombine());
			UnityEngine.Debug.Log("Found " + dictionary.Count + " cells with Renderers. Creating bakers.");
			if (d.clusterOnLMIndex)
			{
				Dictionary<string, List<Renderer>> dictionary2 = new Dictionary<string, List<Renderer>>();
				foreach (string key4 in dictionary.Keys)
				{
					List<Renderer> gaws = dictionary[key4];
					Dictionary<int, List<Renderer>> dictionary3 = GroupByLightmapIndex(gaws);
					foreach (int key5 in dictionary3.Keys)
					{
						string key = key4 + "-LM-" + key5;
						dictionary2.Add(key, dictionary3[key5]);
					}
				}
				dictionary = dictionary2;
			}
			if (d.clusterByLODLevel)
			{
				Dictionary<string, List<Renderer>> dictionary4 = new Dictionary<string, List<Renderer>>();
				foreach (string key6 in dictionary.Keys)
				{
					foreach (Renderer r in dictionary[key6])
					{
						if (r == null)
						{
							continue;
						}
						bool flag = false;
						LODGroup componentInParent = r.GetComponentInParent<LODGroup>();
						if (componentInParent != null)
						{
							LOD[] lODs = componentInParent.GetLODs();
							for (int i = 0; i < lODs.Length; i++)
							{
								if (Array.Find(lODs[i].renderers, (Renderer x) => x == r) != null)
								{
									flag = true;
									string key2 = $"{key6}_LOD{i}";
									if (!dictionary4.TryGetValue(key2, out var value))
									{
										value = new List<Renderer>();
										dictionary4.Add(key2, value);
									}
									if (!value.Contains(r))
									{
										value.Add(r);
									}
								}
							}
						}
						if (!flag)
						{
							string key3 = $"{key6}_LOD0";
							if (!dictionary4.TryGetValue(key3, out var value2))
							{
								value2 = new List<Renderer>();
								dictionary4.Add(key3, value2);
							}
							if (!value2.Contains(r))
							{
								value2.Add(r);
							}
						}
					}
				}
				dictionary = dictionary4;
			}
			foreach (string key7 in dictionary.Keys)
			{
				List<Renderer> list = dictionary[key7];
				if (list.Count > 1)
				{
					AddMeshBaker(tb, key7, list);
				}
			}
		}

		private Dictionary<int, List<Renderer>> GroupByLightmapIndex(List<Renderer> gaws)
		{
			Dictionary<int, List<Renderer>> dictionary = new Dictionary<int, List<Renderer>>();
			for (int i = 0; i < gaws.Count; i++)
			{
				List<Renderer> list = null;
				if (dictionary.ContainsKey(gaws[i].lightmapIndex))
				{
					list = dictionary[gaws[i].lightmapIndex];
				}
				else
				{
					list = new List<Renderer>();
					dictionary.Add(gaws[i].lightmapIndex, list);
				}
				list.Add(gaws[i]);
			}
			return dictionary;
		}

		private void AddMeshBaker(MB3_TextureBaker tb, string key, List<Renderer> gaws)
		{
			int num = 0;
			for (int i = 0; i < gaws.Count; i++)
			{
				Mesh mesh = MB_Utility.GetMesh(gaws[i].gameObject);
				if (mesh != null)
				{
					num += mesh.vertexCount;
				}
			}
			GameObject gameObject = new GameObject("MeshBaker-" + key);
			gameObject.transform.position = Vector3.zero;
			MB3_MeshBakerCommon mB3_MeshBakerCommon;
			if (num >= 65535)
			{
				mB3_MeshBakerCommon = gameObject.AddComponent<MB3_MultiMeshBaker>();
				mB3_MeshBakerCommon.useObjsToMeshFromTexBaker = false;
			}
			else
			{
				mB3_MeshBakerCommon = gameObject.AddComponent<MB3_MeshBaker>();
				mB3_MeshBakerCommon.useObjsToMeshFromTexBaker = false;
			}
			mB3_MeshBakerCommon.textureBakeResults = tb.textureBakeResults;
			mB3_MeshBakerCommon.transform.parent = tb.transform;
			for (int j = 0; j < gaws.Count; j++)
			{
				mB3_MeshBakerCommon.GetObjectsToCombine().Add(gaws[j].gameObject);
			}
		}
	}
	[Serializable]
	public class MB3_MeshBakerGrouperNone : MB3_MeshBakerGrouperCore
	{
		public MB3_MeshBakerGrouperNone(GrouperData d)
		{
			base.d = d;
		}

		public override Dictionary<string, List<Renderer>> FilterIntoGroups(List<GameObject> selection)
		{
			UnityEngine.Debug.Log("Filtering into groups none");
			Dictionary<string, List<Renderer>> dictionary = new Dictionary<string, List<Renderer>>();
			List<Renderer> list = new List<Renderer>();
			for (int i = 0; i < selection.Count; i++)
			{
				if (selection[i] != null)
				{
					list.Add(selection[i].GetComponent<Renderer>());
				}
			}
			dictionary.Add("MeshBaker", list);
			return dictionary;
		}

		public override void DrawGizmos(Bounds sourceObjectBounds)
		{
		}
	}
	[Serializable]
	public class MB3_MeshBakerGrouperGrid : MB3_MeshBakerGrouperCore
	{
		public MB3_MeshBakerGrouperGrid(GrouperData d)
		{
			base.d = d;
		}

		public override Dictionary<string, List<Renderer>> FilterIntoGroups(List<GameObject> selection)
		{
			Dictionary<string, List<Renderer>> dictionary = new Dictionary<string, List<Renderer>>();
			if (d.cellSize.x <= 0f || d.cellSize.y <= 0f || d.cellSize.z <= 0f)
			{
				UnityEngine.Debug.LogError("cellSize x,y,z must all be greater than zero.");
				return dictionary;
			}
			UnityEngine.Debug.Log("Collecting renderers in each cell");
			foreach (GameObject item in selection)
			{
				if (item == null)
				{
					continue;
				}
				Renderer component = item.GetComponent<Renderer>();
				if (component is MeshRenderer || component is SkinnedMeshRenderer)
				{
					Vector3 position = component.transform.position;
					position.x = Mathf.Floor((position.x - d.origin.x) / d.cellSize.x) * d.cellSize.x;
					position.y = Mathf.Floor((position.y - d.origin.y) / d.cellSize.y) * d.cellSize.y;
					position.z = Mathf.Floor((position.z - d.origin.z) / d.cellSize.z) * d.cellSize.z;
					List<Renderer> list = null;
					string key = position.ToString();
					if (dictionary.ContainsKey(key))
					{
						list = dictionary[key];
					}
					else
					{
						list = new List<Renderer>();
						dictionary.Add(key, list);
					}
					if (!list.Contains(component))
					{
						list.Add(component);
					}
				}
			}
			return dictionary;
		}

		public override void DrawGizmos(Bounds sourceObjectBounds)
		{
			Vector3 cellSize = d.cellSize;
			if (cellSize.x <= 1E-05f || cellSize.y <= 1E-05f || cellSize.z <= 1E-05f)
			{
				return;
			}
			Vector3 vector = sourceObjectBounds.center - sourceObjectBounds.extents;
			Vector3 origin = d.origin;
			origin.x %= cellSize.x;
			origin.y %= cellSize.y;
			origin.z %= cellSize.z;
			vector.x = Mathf.Round(vector.x / cellSize.x) * cellSize.x + origin.x;
			vector.y = Mathf.Round(vector.y / cellSize.y) * cellSize.y + origin.y;
			vector.z = Mathf.Round(vector.z / cellSize.z) * cellSize.z + origin.z;
			if (vector.x > sourceObjectBounds.center.x - sourceObjectBounds.extents.x)
			{
				vector.x -= cellSize.x;
			}
			if (vector.y > sourceObjectBounds.center.y - sourceObjectBounds.extents.y)
			{
				vector.y -= cellSize.y;
			}
			if (vector.z > sourceObjectBounds.center.z - sourceObjectBounds.extents.z)
			{
				vector.z -= cellSize.z;
			}
			Vector3 vector2 = vector;
			if (Mathf.CeilToInt(sourceObjectBounds.size.x / cellSize.x + sourceObjectBounds.size.y / cellSize.y + sourceObjectBounds.size.z / cellSize.z) > 200)
			{
				Gizmos.DrawWireCube(d.origin + cellSize / 2f, cellSize);
				return;
			}
			while (vector.x < sourceObjectBounds.center.x + sourceObjectBounds.extents.x)
			{
				vector.y = vector2.y;
				while (vector.y < sourceObjectBounds.center.y + sourceObjectBounds.extents.y)
				{
					vector.z = vector2.z;
					while (vector.z < sourceObjectBounds.center.z + sourceObjectBounds.extents.z)
					{
						Gizmos.DrawWireCube(vector + cellSize / 2f, cellSize);
						vector.z += cellSize.z;
					}
					vector.y += cellSize.y;
				}
				vector.x += cellSize.x;
			}
		}
	}
	[Serializable]
	public class MB3_MeshBakerGrouperPie : MB3_MeshBakerGrouperCore
	{
		public MB3_MeshBakerGrouperPie(GrouperData data)
		{
			d = data;
		}

		public override Dictionary<string, List<Renderer>> FilterIntoGroups(List<GameObject> selection)
		{
			Dictionary<string, List<Renderer>> dictionary = new Dictionary<string, List<Renderer>>();
			if (d.pieNumSegments == 0)
			{
				UnityEngine.Debug.LogError("pieNumSegments must be greater than zero.");
				return dictionary;
			}
			if (d.pieAxis.magnitude <= 1E-06f)
			{
				UnityEngine.Debug.LogError("Pie axis must have length greater than zero.");
				return dictionary;
			}
			d.pieAxis.Normalize();
			Quaternion quaternion = Quaternion.FromToRotation(d.pieAxis, Vector3.up);
			UnityEngine.Debug.Log("Collecting renderers in each cell");
			foreach (GameObject item in selection)
			{
				if (item == null)
				{
					continue;
				}
				Renderer component = item.GetComponent<Renderer>();
				if (!(component is MeshRenderer) && !(component is SkinnedMeshRenderer))
				{
					continue;
				}
				Vector3 vector = component.transform.position - d.origin;
				vector.Normalize();
				vector = quaternion * vector;
				float num = 0f;
				if (Mathf.Abs(vector.x) < 0.0001f && Mathf.Abs(vector.z) < 0.0001f)
				{
					num = 0f;
				}
				else
				{
					num = Mathf.Atan2(vector.z, vector.x) * 57.29578f;
					if (num < 0f)
					{
						num = 360f + num;
					}
				}
				int num2 = Mathf.FloorToInt(num / 360f * (float)d.pieNumSegments);
				List<Renderer> list = null;
				string key = "seg_" + num2;
				if (dictionary.ContainsKey(key))
				{
					list = dictionary[key];
				}
				else
				{
					list = new List<Renderer>();
					dictionary.Add(key, list);
				}
				if (!list.Contains(component))
				{
					list.Add(component);
				}
			}
			return dictionary;
		}

		public override void DrawGizmos(Bounds sourceObjectBounds)
		{
			if (!(d.pieAxis.magnitude < 0.1f) && d.pieNumSegments >= 1)
			{
				float magnitude = sourceObjectBounds.extents.magnitude;
				DrawCircle(d.pieAxis, d.origin, magnitude, 24);
				Quaternion quaternion = Quaternion.FromToRotation(Vector3.up, d.pieAxis);
				Quaternion quaternion2 = Quaternion.AngleAxis(180f / (float)d.pieNumSegments, Vector3.up);
				Vector3 vector = quaternion2 * Vector3.forward;
				for (int i = 0; i < d.pieNumSegments; i++)
				{
					Vector3 vector2 = quaternion * vector;
					Gizmos.DrawLine(d.origin, d.origin + vector2 * magnitude);
					vector = quaternion2 * vector;
					vector = quaternion2 * vector;
				}
			}
		}

		public static void DrawCircle(Vector3 axis, Vector3 center, float radius, int subdiv)
		{
			Quaternion quaternion = Quaternion.AngleAxis(360 / subdiv, axis);
			Vector3 vector = new Vector3(axis.y, 0f - axis.x, axis.z);
			vector.Normalize();
			vector *= radius;
			for (int i = 0; i < subdiv + 1; i++)
			{
				Vector3 vector2 = quaternion * vector;
				Gizmos.DrawLine(center + vector, center + vector2);
				vector = vector2;
			}
		}
	}
	[Serializable]
	public class MB3_MeshBakerGrouperKMeans : MB3_MeshBakerGrouperCore
	{
		public int numClusters = 4;

		public Vector3[] clusterCenters = new Vector3[0];

		public float[] clusterSizes = new float[0];

		public MB3_MeshBakerGrouperKMeans(GrouperData data)
		{
			d = data;
		}

		public override Dictionary<string, List<Renderer>> FilterIntoGroups(List<GameObject> selection)
		{
			Dictionary<string, List<Renderer>> dictionary = new Dictionary<string, List<Renderer>>();
			List<GameObject> list = new List<GameObject>();
			int num = 20;
			foreach (GameObject item in selection)
			{
				if (!(item == null))
				{
					GameObject gameObject = item;
					Renderer component = gameObject.GetComponent<Renderer>();
					if (component is MeshRenderer || component is SkinnedMeshRenderer)
					{
						list.Add(gameObject);
					}
				}
			}
			if (list.Count > 0 && num > 0 && num < list.Count)
			{
				MB3_KMeansClustering mB3_KMeansClustering = new MB3_KMeansClustering(list, num);
				mB3_KMeansClustering.Cluster();
				clusterCenters = new Vector3[num];
				clusterSizes = new float[num];
				for (int i = 0; i < num; i++)
				{
					List<Renderer> cluster = mB3_KMeansClustering.GetCluster(i, out clusterCenters[i], out clusterSizes[i]);
					if (cluster.Count > 0)
					{
						dictionary.Add("Cluster_" + i, cluster);
					}
				}
			}
			return dictionary;
		}

		public override void DrawGizmos(Bounds sceneObjectBounds)
		{
			if (clusterCenters != null && clusterSizes != null && clusterCenters.Length == clusterSizes.Length)
			{
				for (int i = 0; i < clusterSizes.Length; i++)
				{
					Gizmos.DrawWireSphere(clusterCenters[i], clusterSizes[i]);
				}
			}
		}
	}
	[Serializable]
	public class MB3_MeshBakerGrouperCluster : MB3_MeshBakerGrouperCore
	{
		public MB3_AgglomerativeClustering cluster;

		private float _lastMaxDistBetweenClusters;

		public float _ObjsExtents;

		private List<MB3_AgglomerativeClustering.ClusterNode> _clustersToDraw = new List<MB3_AgglomerativeClustering.ClusterNode>();

		private float[] _radii;

		public MB3_MeshBakerGrouperCluster(GrouperData data, List<GameObject> gos)
		{
			d = data;
		}

		public override Dictionary<string, List<Renderer>> FilterIntoGroups(List<GameObject> selection)
		{
			Dictionary<string, List<Renderer>> dictionary = new Dictionary<string, List<Renderer>>();
			for (int i = 0; i < _clustersToDraw.Count; i++)
			{
				MB3_AgglomerativeClustering.ClusterNode clusterNode = _clustersToDraw[i];
				List<Renderer> list = new List<Renderer>();
				for (int j = 0; j < clusterNode.leafs.Length; j++)
				{
					Renderer component = cluster.clusters[clusterNode.leafs[j]].leaf.go.GetComponent<Renderer>();
					if (component is MeshRenderer || component is SkinnedMeshRenderer)
					{
						list.Add(component);
					}
				}
				if (list.Count > 1)
				{
					dictionary.Add("Cluster_" + i, list);
				}
			}
			return dictionary;
		}

		public void BuildClusters(List<GameObject> gos, ProgressUpdateDelegate progFunc)
		{
			if (gos.Count == 0)
			{
				UnityEngine.Debug.LogWarning("No objects to cluster");
				return;
			}
			if (cluster == null)
			{
				cluster = new MB3_AgglomerativeClustering();
			}
			List<MB3_AgglomerativeClustering.item_s> list = new List<MB3_AgglomerativeClustering.item_s>();
			int i;
			for (i = 0; i < gos.Count; i++)
			{
				if (gos[i] != null && list.Find((MB3_AgglomerativeClustering.item_s x) => x.go == gos[i]) == null)
				{
					MB3_AgglomerativeClustering.item_s item_s = new MB3_AgglomerativeClustering.item_s();
					item_s.go = gos[i];
					item_s.coord = gos[i].transform.position;
					list.Add(item_s);
				}
			}
			cluster.items = list;
			cluster.agglomerate(progFunc);
			_BuildListOfClustersToDraw();
		}

		private void _BuildListOfClustersToDraw()
		{
			_clustersToDraw.Clear();
			if (cluster.clusters == null)
			{
				return;
			}
			List<MB3_AgglomerativeClustering.ClusterNode> list = new List<MB3_AgglomerativeClustering.ClusterNode>();
			float num = 1f;
			for (int i = 0; i < cluster.clusters.Length; i++)
			{
				MB3_AgglomerativeClustering.ClusterNode clusterNode = cluster.clusters[i];
				if (clusterNode.distToMergedCentroid <= d.maxDistBetweenClusters && clusterNode.leaf == null)
				{
					_clustersToDraw.Add(clusterNode);
				}
				if (clusterNode.distToMergedCentroid > num)
				{
					num = clusterNode.distToMergedCentroid;
				}
			}
			for (int j = 0; j < _clustersToDraw.Count; j++)
			{
				list.Add(_clustersToDraw[j].cha);
				list.Add(_clustersToDraw[j].chb);
			}
			for (int k = 0; k < list.Count; k++)
			{
				_clustersToDraw.Remove(list[k]);
			}
			_radii = new float[_clustersToDraw.Count];
			for (int l = 0; l < _radii.Length; l++)
			{
				MB3_AgglomerativeClustering.ClusterNode clusterNode2 = _clustersToDraw[l];
				Bounds bounds = new Bounds(clusterNode2.centroid, Vector3.one);
				for (int m = 0; m < clusterNode2.leafs.Length; m++)
				{
					Renderer component = cluster.clusters[clusterNode2.leafs[m]].leaf.go.GetComponent<Renderer>();
					if (component != null)
					{
						bounds.Encapsulate(component.bounds);
					}
				}
				_radii[l] = bounds.extents.magnitude;
			}
			_ObjsExtents = num + 1f;
			if (_ObjsExtents < 2f)
			{
				_ObjsExtents = 2f;
			}
		}

		public override void DrawGizmos(Bounds sceneObjectBounds)
		{
			if (cluster != null && cluster.clusters != null)
			{
				if (_lastMaxDistBetweenClusters != d.maxDistBetweenClusters)
				{
					_BuildListOfClustersToDraw();
					_lastMaxDistBetweenClusters = d.maxDistBetweenClusters;
				}
				for (int i = 0; i < _clustersToDraw.Count; i++)
				{
					Gizmos.color = Color.white;
					Gizmos.DrawWireSphere(_clustersToDraw[i].centroid, _radii[i]);
				}
			}
		}
	}
	public interface TextureBlender
	{
		bool DoesShaderNameMatch(string shaderName);

		void OnBeforeTintTexture(Material sourceMat, string shaderTexturePropertyName);

		Color OnBlendTexturePixel(string shaderPropertyName, Color pixelColor);

		bool NonTexturePropertiesAreEqual(Material a, Material b);

		void SetNonTexturePropertyValuesOnResultMaterial(Material resultMaterial);

		Color GetColorIfNoTexture(Material m, ShaderTextureProperty texPropertyName);
	}
	public class TextureBlenderFallback : TextureBlender
	{
		private bool m_doTintColor;

		private Color m_tintColor;

		private Color m_defaultColor = Color.white;

		public bool DoesShaderNameMatch(string shaderName)
		{
			return true;
		}

		public void OnBeforeTintTexture(Material sourceMat, string shaderTexturePropertyName)
		{
			if (shaderTexturePropertyName.Equals("_MainTex"))
			{
				m_doTintColor = true;
				m_tintColor = Color.white;
				if (sourceMat.HasProperty("_Color"))
				{
					m_tintColor = sourceMat.GetColor("_Color");
				}
			}
			else
			{
				m_doTintColor = false;
			}
		}

		public Color OnBlendTexturePixel(string shaderPropertyName, Color pixelColor)
		{
			if (m_doTintColor)
			{
				return new Color(pixelColor.r * m_tintColor.r, pixelColor.g * m_tintColor.g, pixelColor.b * m_tintColor.b, pixelColor.a * m_tintColor.a);
			}
			return pixelColor;
		}

		public bool NonTexturePropertiesAreEqual(Material a, Material b)
		{
			if (_compareColor(a, b, m_defaultColor, "_Color"))
			{
				return true;
			}
			return false;
		}

		public void SetNonTexturePropertyValuesOnResultMaterial(Material resultMaterial)
		{
			if (resultMaterial.HasProperty("_Color"))
			{
				resultMaterial.SetColor("_Color", m_defaultColor);
			}
		}

		public Color GetColorIfNoTexture(Material mat, ShaderTextureProperty texProperty)
		{
			if (texProperty.isNormalMap)
			{
				return new Color(0.5f, 0.5f, 1f);
			}
			if (texProperty.name.Equals("_MainTex"))
			{
				if (mat != null && mat.HasProperty("_Color"))
				{
					try
					{
						return mat.GetColor("_Color");
					}
					catch (Exception)
					{
					}
				}
			}
			else if (texProperty.name.Equals("_SpecGlossMap"))
			{
				if (mat != null && mat.HasProperty("_SpecColor"))
				{
					try
					{
						Color color = mat.GetColor("_SpecColor");
						if (mat.HasProperty("_Glossiness"))
						{
							try
							{
								color.a = mat.GetFloat("_Glossiness");
							}
							catch (Exception)
							{
							}
						}
						UnityEngine.Debug.LogWarning(color);
						return color;
					}
					catch (Exception)
					{
					}
				}
			}
			else if (texProperty.name.Equals("_MetallicGlossMap"))
			{
				if (mat != null && mat.HasProperty("_Metallic"))
				{
					try
					{
						float @float = mat.GetFloat("_Metallic");
						Color result = new Color(@float, @float, @float);
						if (mat.HasProperty("_Glossiness"))
						{
							try
							{
								result.a = mat.GetFloat("_Glossiness");
							}
							catch (Exception)
							{
							}
						}
						return result;
					}
					catch (Exception)
					{
					}
				}
			}
			else
			{
				if (texProperty.name.Equals("_ParallaxMap"))
				{
					return new Color(0f, 0f, 0f, 0f);
				}
				if (texProperty.name.Equals("_OcclusionMap"))
				{
					return new Color(1f, 1f, 1f, 1f);
				}
				if (texProperty.name.Equals("_EmissionMap"))
				{
					if (mat != null && mat.HasProperty("_EmissionScaleUI"))
					{
						if (mat.HasProperty("_EmissionColor") && mat.HasProperty("_EmissionColorUI"))
						{
							try
							{
								Color color2 = mat.GetColor("_EmissionColor");
								Color color3 = mat.GetColor("_EmissionColorUI");
								float float2 = mat.GetFloat("_EmissionScaleUI");
								if (color2 == new Color(0f, 0f, 0f, 0f) && color3 == new Color(1f, 1f, 1f, 1f))
								{
									return new Color(float2, float2, float2, float2);
								}
								return color3;
							}
							catch (Exception)
							{
							}
						}
						else
						{
							try
							{
								float float3 = mat.GetFloat("_EmissionScaleUI");
								return new Color(float3, float3, float3, float3);
							}
							catch (Exception)
							{
							}
						}
					}
				}
				else if (texProperty.name.Equals("_DetailMask"))
				{
					return new Color(0f, 0f, 0f, 0f);
				}
			}
			return new Color(1f, 1f, 1f, 0f);
		}

		public static bool _compareColor(Material a, Material b, Color defaultVal, string propertyName)
		{
			Color color = defaultVal;
			Color color2 = defaultVal;
			if (a.HasProperty(propertyName))
			{
				color = a.GetColor(propertyName);
			}
			if (b.HasProperty(propertyName))
			{
				color2 = b.GetColor(propertyName);
			}
			if (color != color2)
			{
				return false;
			}
			return true;
		}

		public static bool _compareFloat(Material a, Material b, float defaultVal, string propertyName)
		{
			float num = defaultVal;
			float num2 = defaultVal;
			if (a.HasProperty(propertyName))
			{
				num = a.GetFloat(propertyName);
			}
			if (b.HasProperty(propertyName))
			{
				num2 = b.GetFloat(propertyName);
			}
			if (num != num2)
			{
				return false;
			}
			return true;
		}
	}
	public class TextureBlenderLegacyBumpDiffuse : TextureBlender
	{
		private bool doColor;

		private Color m_tintColor;

		private Color m_defaultTintColor = Color.white;

		public bool DoesShaderNameMatch(string shaderName)
		{
			if (shaderName.Equals("Legacy Shaders/Bumped Diffuse"))
			{
				return true;
			}
			if (shaderName.Equals("Bumped Diffuse"))
			{
				return true;
			}
			return false;
		}

		public void OnBeforeTintTexture(Material sourceMat, string shaderTexturePropertyName)
		{
			if (shaderTexturePropertyName.EndsWith("_MainTex"))
			{
				doColor = true;
				m_tintColor = sourceMat.GetColor("_Color");
			}
			else
			{
				doColor = false;
			}
		}

		public Color OnBlendTexturePixel(string propertyToDoshaderPropertyName, Color pixelColor)
		{
			if (doColor)
			{
				return new Color(pixelColor.r * m_tintColor.r, pixelColor.g * m_tintColor.g, pixelColor.b * m_tintColor.b, pixelColor.a * m_tintColor.a);
			}
			return pixelColor;
		}

		public bool NonTexturePropertiesAreEqual(Material a, Material b)
		{
			return TextureBlenderFallback._compareColor(a, b, m_defaultTintColor, "_Color");
		}

		public void SetNonTexturePropertyValuesOnResultMaterial(Material resultMaterial)
		{
			resultMaterial.SetColor("_Color", Color.white);
		}

		public Color GetColorIfNoTexture(Material m, ShaderTextureProperty texPropertyName)
		{
			if (texPropertyName.name.Equals("_BumpMap"))
			{
				return new Color(0.5f, 0.5f, 1f);
			}
			if (texPropertyName.name.Equals("_MainTex") && m != null && m.HasProperty("_Color"))
			{
				try
				{
					return m.GetColor("_Color");
				}
				catch (Exception)
				{
				}
			}
			return new Color(1f, 1f, 1f, 0f);
		}
	}
	public class TextureBlenderLegacyDiffuse : TextureBlender
	{
		private bool doColor;

		private Color m_tintColor;

		private Color m_defaultTintColor = Color.white;

		public bool DoesShaderNameMatch(string shaderName)
		{
			if (shaderName.Equals("Legacy Shaders/Diffuse"))
			{
				return true;
			}
			if (shaderName.Equals("Diffuse"))
			{
				return true;
			}
			return false;
		}

		public void OnBeforeTintTexture(Material sourceMat, string shaderTexturePropertyName)
		{
			if (shaderTexturePropertyName.EndsWith("_MainTex"))
			{
				doColor = true;
				m_tintColor = sourceMat.GetColor("_Color");
			}
			else
			{
				doColor = false;
			}
		}

		public Color OnBlendTexturePixel(string propertyToDoshaderPropertyName, Color pixelColor)
		{
			if (doColor)
			{
				return new Color(pixelColor.r * m_tintColor.r, pixelColor.g * m_tintColor.g, pixelColor.b * m_tintColor.b, pixelColor.a * m_tintColor.a);
			}
			return pixelColor;
		}

		public bool NonTexturePropertiesAreEqual(Material a, Material b)
		{
			return TextureBlenderFallback._compareColor(a, b, m_defaultTintColor, "_Color");
		}

		public void SetNonTexturePropertyValuesOnResultMaterial(Material resultMaterial)
		{
			resultMaterial.SetColor("_Color", Color.white);
		}

		public Color GetColorIfNoTexture(Material m, ShaderTextureProperty texPropertyName)
		{
			if (texPropertyName.name.Equals("_MainTex") && m != null && m.HasProperty("_Color"))
			{
				try
				{
					return m.GetColor("_Color");
				}
				catch (Exception)
				{
				}
			}
			return new Color(1f, 1f, 1f, 0f);
		}
	}
	public class TextureBlenderStandardMetallic : TextureBlender
	{
		private enum Prop
		{
			doColor,
			doMetallic,
			doEmission,
			doNone
		}

		private Color m_tintColor;

		private Color m_emission;

		private Prop propertyToDo = Prop.doNone;

		private Color m_defaultColor = Color.white;

		private float m_defaultMetallic;

		private float m_defaultGlossiness = 0.5f;

		private Color m_defaultEmission = Color.black;

		public bool DoesShaderNameMatch(string shaderName)
		{
			return shaderName.Equals("Standard");
		}

		public void OnBeforeTintTexture(Material sourceMat, string shaderTexturePropertyName)
		{
			if (shaderTexturePropertyName.Equals("_MainTex"))
			{
				propertyToDo = Prop.doColor;
				if (sourceMat.HasProperty(shaderTexturePropertyName))
				{
					m_tintColor = sourceMat.GetColor("_Color");
				}
				else
				{
					m_tintColor = m_defaultColor;
				}
			}
			else if (shaderTexturePropertyName.Equals("_MetallicGlossMap"))
			{
				propertyToDo = Prop.doMetallic;
			}
			else if (shaderTexturePropertyName.Equals("_EmissionMap"))
			{
				propertyToDo = Prop.doEmission;
				if (sourceMat.HasProperty(shaderTexturePropertyName))
				{
					m_emission = sourceMat.GetColor("_EmissionColor");
				}
				else
				{
					m_emission = m_defaultEmission;
				}
			}
			else
			{
				propertyToDo = Prop.doNone;
			}
		}

		public Color OnBlendTexturePixel(string propertyToDoshaderPropertyName, Color pixelColor)
		{
			if (propertyToDo == Prop.doColor)
			{
				return new Color(pixelColor.r * m_tintColor.r, pixelColor.g * m_tintColor.g, pixelColor.b * m_tintColor.b, pixelColor.a * m_tintColor.a);
			}
			if (propertyToDo == Prop.doMetallic)
			{
				return pixelColor;
			}
			if (propertyToDo == Prop.doEmission)
			{
				return new Color(pixelColor.r * m_emission.r, pixelColor.g * m_emission.g, pixelColor.b * m_emission.b, pixelColor.a * m_emission.a);
			}
			return pixelColor;
		}

		public bool NonTexturePropertiesAreEqual(Material a, Material b)
		{
			if (!TextureBlenderFallback._compareColor(a, b, m_defaultColor, "_Color"))
			{
				return false;
			}
			if (!TextureBlenderFallback._compareFloat(a, b, m_defaultMetallic, "_Metallic"))
			{
				return false;
			}
			if (!TextureBlenderFallback._compareFloat(a, b, m_defaultGlossiness, "_Glossiness"))
			{
				return false;
			}
			if (!TextureBlenderFallback._compareColor(a, b, m_defaultEmission, "_EmissionColor"))
			{
				return false;
			}
			return true;
		}

		public void SetNonTexturePropertyValuesOnResultMaterial(Material resultMaterial)
		{
			resultMaterial.SetColor("_Color", m_defaultColor);
			resultMaterial.SetFloat("_Metallic", m_defaultMetallic);
			resultMaterial.SetFloat("_Glossiness", m_defaultGlossiness);
			if (resultMaterial.GetTexture("_EmissionMap") == null)
			{
				resultMaterial.SetColor("_EmissionColor", Color.black);
			}
			else
			{
				resultMaterial.SetColor("_EmissionColor", Color.white);
			}
		}

		public Color GetColorIfNoTexture(Material mat, ShaderTextureProperty texPropertyName)
		{
			if (texPropertyName.name.Equals("_BumpMap"))
			{
				return new Color(0.5f, 0.5f, 1f);
			}
			if (texPropertyName.Equals("_MainTex"))
			{
				if (mat != null && mat.HasProperty("_Color"))
				{
					try
					{
						return mat.GetColor("_Color");
					}
					catch (Exception)
					{
					}
				}
			}
			else if (texPropertyName.name.Equals("_MetallicGlossMap"))
			{
				if (!(mat != null) || !mat.HasProperty("_Metallic"))
				{
					return new Color(0f, 0f, 0f, 0.5f);
				}
				try
				{
					float @float = mat.GetFloat("_Metallic");
					Color result = new Color(@float, @float, @float);
					if (mat.HasProperty("_Glossiness"))
					{
						try
						{
							result.a = mat.GetFloat("_Glossiness");
						}
						catch (Exception)
						{
						}
					}
					return result;
				}
				catch (Exception)
				{
				}
			}
			else
			{
				if (texPropertyName.name.Equals("_ParallaxMap"))
				{
					return new Color(0f, 0f, 0f, 0f);
				}
				if (texPropertyName.name.Equals("_OcclusionMap"))
				{
					return new Color(1f, 1f, 1f, 1f);
				}
				if (texPropertyName.name.Equals("_EmissionMap"))
				{
					if (mat != null)
					{
						if (!mat.HasProperty("_EmissionColor"))
						{
							return Color.black;
						}
						try
						{
							return mat.GetColor("_EmissionColor");
						}
						catch (Exception)
						{
						}
					}
				}
				else if (texPropertyName.name.Equals("_DetailMask"))
				{
					return new Color(0f, 0f, 0f, 0f);
				}
			}
			return new Color(1f, 1f, 1f, 0f);
		}
	}
	public class TextureBlenderStandardSpecular : TextureBlender
	{
		private enum Prop
		{
			doColor,
			doSpecular,
			doEmission,
			doNone
		}

		private Color m_tintColor;

		private Color m_emission;

		private Prop propertyToDo = Prop.doNone;

		private Color m_defaultColor = Color.white;

		private Color m_defaultSpecular = Color.black;

		private float m_defaultGlossiness = 0.5f;

		private Color m_defaultEmission = Color.black;

		public bool DoesShaderNameMatch(string shaderName)
		{
			return shaderName.Equals("Standard (Specular setup)");
		}

		public void OnBeforeTintTexture(Material sourceMat, string shaderTexturePropertyName)
		{
			if (shaderTexturePropertyName.Equals("_MainTex"))
			{
				propertyToDo = Prop.doColor;
				if (sourceMat.HasProperty(shaderTexturePropertyName))
				{
					m_tintColor = sourceMat.GetColor("_Color");
				}
				else
				{
					m_tintColor = m_defaultColor;
				}
			}
			else if (shaderTexturePropertyName.Equals("_MetallicGlossMap"))
			{
				propertyToDo = Prop.doSpecular;
			}
			else if (shaderTexturePropertyName.Equals("_EmissionMap"))
			{
				propertyToDo = Prop.doEmission;
				if (sourceMat.HasProperty(shaderTexturePropertyName))
				{
					m_emission = sourceMat.GetColor("_EmissionColor");
				}
				else
				{
					m_emission = m_defaultEmission;
				}
			}
			else
			{
				propertyToDo = Prop.doNone;
			}
		}

		public Color OnBlendTexturePixel(string propertyToDoshaderPropertyName, Color pixelColor)
		{
			if (propertyToDo == Prop.doColor)
			{
				return new Color(pixelColor.r * m_tintColor.r, pixelColor.g * m_tintColor.g, pixelColor.b * m_tintColor.b, pixelColor.a * m_tintColor.a);
			}
			if (propertyToDo == Prop.doSpecular)
			{
				return pixelColor;
			}
			if (propertyToDo == Prop.doEmission)
			{
				return new Color(pixelColor.r * m_emission.r, pixelColor.g * m_emission.g, pixelColor.b * m_emission.b, pixelColor.a * m_emission.a);
			}
			return pixelColor;
		}

		public bool NonTexturePropertiesAreEqual(Material a, Material b)
		{
			if (!TextureBlenderFallback._compareColor(a, b, m_defaultColor, "_Color"))
			{
				return false;
			}
			if (!TextureBlenderFallback._compareColor(a, b, m_defaultSpecular, "_SpecColor"))
			{
				return false;
			}
			if (!TextureBlenderFallback._compareFloat(a, b, m_defaultGlossiness, "_Glossiness"))
			{
				return false;
			}
			if (!TextureBlenderFallback._compareColor(a, b, m_defaultEmission, "_EmissionColor"))
			{
				return false;
			}
			return true;
		}

		public void SetNonTexturePropertyValuesOnResultMaterial(Material resultMaterial)
		{
			resultMaterial.SetColor("_Color", m_defaultColor);
			resultMaterial.SetColor("_SpecColor", m_defaultSpecular);
			resultMaterial.SetFloat("_Glossiness", m_defaultGlossiness);
			if (resultMaterial.GetTexture("_EmissionMap") == null)
			{
				resultMaterial.SetColor("_EmissionColor", Color.black);
			}
			else
			{
				resultMaterial.SetColor("_EmissionColor", Color.white);
			}
		}

		public Color GetColorIfNoTexture(Material mat, ShaderTextureProperty texPropertyName)
		{
			if (texPropertyName.name.Equals("_BumpMap"))
			{
				return new Color(0.5f, 0.5f, 1f);
			}
			if (texPropertyName.name.Equals("_MainTex"))
			{
				if (mat != null && mat.HasProperty("_Color"))
				{
					try
					{
						return mat.GetColor("_Color");
					}
					catch (Exception)
					{
					}
				}
			}
			else if (texPropertyName.name.Equals("_SpecGlossMap"))
			{
				bool flag = false;
				if (mat != null && mat.HasProperty("_SpecColor"))
				{
					try
					{
						Color color = mat.GetColor("_SpecColor");
						if (mat.HasProperty("_Glossiness"))
						{
							try
							{
								flag = true;
								color.a = mat.GetFloat("_Glossiness");
							}
							catch (Exception)
							{
							}
						}
						UnityEngine.Debug.LogWarning(color);
						return color;
					}
					catch (Exception)
					{
					}
				}
				if (!flag)
				{
					return m_defaultSpecular;
				}
			}
			else
			{
				if (texPropertyName.name.Equals("_ParallaxMap"))
				{
					return new Color(0f, 0f, 0f, 0f);
				}
				if (texPropertyName.name.Equals("_OcclusionMap"))
				{
					return new Color(1f, 1f, 1f, 1f);
				}
				if (texPropertyName.name.Equals("_EmissionMap"))
				{
					if (mat != null)
					{
						if (!mat.HasProperty("_EmissionColor"))
						{
							return Color.black;
						}
						try
						{
							return mat.GetColor("_EmissionColor");
						}
						catch (Exception)
						{
						}
					}
				}
				else if (texPropertyName.name.Equals("_DetailMask"))
				{
					return new Color(0f, 0f, 0f, 0f);
				}
			}
			return new Color(1f, 1f, 1f, 0f);
		}
	}
	public delegate void ProgressUpdateDelegate(string msg, float progress);
	public enum MB_ObjsToCombineTypes
	{
		prefabOnly,
		sceneObjOnly,
		dontCare
	}
	public enum MB_OutputOptions
	{
		bakeIntoPrefab,
		bakeMeshsInPlace,
		bakeTextureAtlasesOnly,
		bakeIntoSceneObject
	}
	public enum MB_RenderType
	{
		meshRenderer,
		skinnedMeshRenderer
	}
	public enum MB2_OutputOptions
	{
		bakeIntoSceneObject,
		bakeMeshAssetsInPlace,
		bakeIntoPrefab
	}
	public enum MB2_LightmapOptions
	{
		preserve_current_lightmapping,
		ignore_UV2,
		copy_UV2_unchanged,
		generate_new_UV2_layout,
		copy_UV2_unchanged_to_separate_rects
	}
	public enum MB2_PackingAlgorithmEnum
	{
		UnitysPackTextures,
		MeshBakerTexturePacker,
		MeshBakerTexturePacker_Fast
	}
	public enum MB2_ValidationLevel
	{
		none,
		quick,
		robust
	}
	public interface MB2_EditorMethodsInterface
	{
		void Clear();

		void SetReadFlags(ProgressUpdateDelegate progressInfo);

		void SetReadWriteFlag(Texture2D tx, bool isReadable, bool addToList);

		void AddTextureFormat(Texture2D tx, bool isNormalMap);

		void SaveAtlasToAssetDatabase(Texture2D atlas, ShaderTextureProperty texPropertyName, int atlasNum, Material resMat);

		void SetMaterialTextureProperty(Material target, ShaderTextureProperty texPropName, string texturePath);

		void SetNormalMap(Texture2D tx);

		bool IsNormalMap(Texture2D tx);

		string GetPlatformString();

		void SetTextureSize(Texture2D tx, int size);

		bool IsCompressed(Texture2D tx);

		void CheckBuildSettings(long estimatedAtlasSize);

		bool CheckPrefabTypes(MB_ObjsToCombineTypes prefabType, List<GameObject> gos);

		bool ValidateSkinnedMeshes(List<GameObject> mom);

		void CommitChangesToAssets();

		void Destroy(UnityEngine.Object o);
	}
	public enum MB2_LogLevel
	{
		none,
		error,
		warn,
		info,
		debug,
		trace
	}
	public class MB2_Log
	{
		public static void Log(MB2_LogLevel l, string msg, MB2_LogLevel currentThreshold)
		{
			if (l <= currentThreshold)
			{
				if (l == MB2_LogLevel.error)
				{
					UnityEngine.Debug.LogError(msg);
				}
				if (l == MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning($"frm={Time.frameCount} WARN {msg}");
				}
				if (l == MB2_LogLevel.info)
				{
					UnityEngine.Debug.Log($"frm={Time.frameCount} INFO {msg}");
				}
				if (l == MB2_LogLevel.debug)
				{
					UnityEngine.Debug.Log($"frm={Time.frameCount} DEBUG {msg}");
				}
				if (l == MB2_LogLevel.trace)
				{
					UnityEngine.Debug.Log($"frm={Time.frameCount} TRACE {msg}");
				}
			}
		}

		public static string Error(string msg, params object[] args)
		{
			string arg = string.Format(msg, args);
			string text = $"f={Time.frameCount} ERROR {arg}";
			UnityEngine.Debug.LogError(text);
			return text;
		}

		public static string Warn(string msg, params object[] args)
		{
			string arg = string.Format(msg, args);
			string text = $"f={Time.frameCount} WARN {arg}";
			UnityEngine.Debug.LogWarning(text);
			return text;
		}

		public static string Info(string msg, params object[] args)
		{
			string arg = string.Format(msg, args);
			string text = $"f={Time.frameCount} INFO {arg}";
			UnityEngine.Debug.Log(text);
			return text;
		}

		public static string LogDebug(string msg, params object[] args)
		{
			string arg = string.Format(msg, args);
			string text = $"f={Time.frameCount} DEBUG {arg}";
			UnityEngine.Debug.Log(text);
			return text;
		}

		public static string Trace(string msg, params object[] args)
		{
			string arg = string.Format(msg, args);
			string text = $"f={Time.frameCount} TRACE {arg}";
			UnityEngine.Debug.Log(text);
			return text;
		}
	}
	public class ObjectLog
	{
		private int pos;

		private string[] logMessages;

		private void _CacheLogMessage(string msg)
		{
			if (logMessages.Length != 0)
			{
				logMessages[pos] = msg;
				pos++;
				if (pos >= logMessages.Length)
				{
					pos = 0;
				}
			}
		}

		public ObjectLog(short bufferSize)
		{
			logMessages = new string[bufferSize];
		}

		public void Log(MB2_LogLevel l, string msg, MB2_LogLevel currentThreshold)
		{
			MB2_Log.Log(l, msg, currentThreshold);
			_CacheLogMessage(msg);
		}

		public void Error(string msg, params object[] args)
		{
			_CacheLogMessage(MB2_Log.Error(msg, args));
		}

		public void Warn(string msg, params object[] args)
		{
			_CacheLogMessage(MB2_Log.Warn(msg, args));
		}

		public void Info(string msg, params object[] args)
		{
			_CacheLogMessage(MB2_Log.Info(msg, args));
		}

		public void LogDebug(string msg, params object[] args)
		{
			_CacheLogMessage(MB2_Log.LogDebug(msg, args));
		}

		public void Trace(string msg, params object[] args)
		{
			_CacheLogMessage(MB2_Log.Trace(msg, args));
		}

		public string Dump()
		{
			StringBuilder stringBuilder = new StringBuilder();
			int num = 0;
			if (logMessages[logMessages.Length - 1] != null)
			{
				num = pos;
			}
			for (int i = 0; i < logMessages.Length; i++)
			{
				int num2 = (num + i) % logMessages.Length;
				if (logMessages[num2] == null)
				{
					break;
				}
				stringBuilder.AppendLine(logMessages[num2]);
			}
			return stringBuilder.ToString();
		}
	}
	public interface MBVersionInterface
	{
		string version();

		int GetMajorVersion();

		int GetMinorVersion();

		bool GetActive(GameObject go);

		void SetActive(GameObject go, bool isActive);

		void SetActiveRecursively(GameObject go, bool isActive);

		UnityEngine.Object[] FindSceneObjectsOfType(Type t);

		bool IsRunningAndMeshNotReadWriteable(Mesh m);

		Vector2[] GetMeshUV3orUV4(Mesh m, bool get3, MB2_LogLevel LOG_LEVEL);

		void MeshClear(Mesh m, bool t);

		void MeshAssignUV3(Mesh m, Vector2[] uv3s);

		void MeshAssignUV4(Mesh m, Vector2[] uv4s);

		Vector4 GetLightmapTilingOffset(Renderer r);

		Transform[] GetBones(Renderer r);
	}
	public class MBVersion
	{
		private static MBVersionInterface _MBVersion;

		private static MBVersionInterface _CreateMBVersionConcrete()
		{
			return (MBVersionInterface)Activator.CreateInstance(typeof(MBVersionConcrete));
		}

		public static string version()
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			return _MBVersion.version();
		}

		public static int GetMajorVersion()
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			return _MBVersion.GetMajorVersion();
		}

		public static int GetMinorVersion()
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			return _MBVersion.GetMinorVersion();
		}

		public static bool GetActive(GameObject go)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			return _MBVersion.GetActive(go);
		}

		public static void SetActive(GameObject go, bool isActive)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			_MBVersion.SetActive(go, isActive);
		}

		public static void SetActiveRecursively(GameObject go, bool isActive)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			_MBVersion.SetActiveRecursively(go, isActive);
		}

		public static UnityEngine.Object[] FindSceneObjectsOfType(Type t)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			return _MBVersion.FindSceneObjectsOfType(t);
		}

		public static bool IsRunningAndMeshNotReadWriteable(Mesh m)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			return _MBVersion.IsRunningAndMeshNotReadWriteable(m);
		}

		public static Vector2[] GetMeshUV3orUV4(Mesh m, bool get3, MB2_LogLevel LOG_LEVEL)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			return _MBVersion.GetMeshUV3orUV4(m, get3, LOG_LEVEL);
		}

		public static void MeshClear(Mesh m, bool t)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			_MBVersion.MeshClear(m, t);
		}

		public static void MeshAssignUV3(Mesh m, Vector2[] uv3s)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			_MBVersion.MeshAssignUV3(m, uv3s);
		}

		public static void MeshAssignUV4(Mesh m, Vector2[] uv4s)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			_MBVersion.MeshAssignUV4(m, uv4s);
		}

		public static Vector4 GetLightmapTilingOffset(Renderer r)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			return _MBVersion.GetLightmapTilingOffset(r);
		}

		public static Transform[] GetBones(Renderer r)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			return _MBVersion.GetBones(r);
		}
	}
	public class MB2_TexturePacker
	{
		private class PixRect
		{
			public int x;

			public int y;

			public int w;

			public int h;

			public PixRect()
			{
			}

			public PixRect(int xx, int yy, int ww, int hh)
			{
				x = xx;
				y = yy;
				w = ww;
				h = hh;
			}
		}

		private class Image
		{
			public int imgId;

			public int w;

			public int h;

			public int x;

			public int y;

			public Image(int id, int tw, int th, int padding, int minImageSizeX, int minImageSizeY)
			{
				imgId = id;
				w = Mathf.Max(tw + padding * 2, minImageSizeX);
				h = Mathf.Max(th + padding * 2, minImageSizeY);
			}

			public Image(Image im)
			{
				imgId = im.imgId;
				w = im.w;
				h = im.h;
				x = im.x;
				y = im.y;
			}
		}

		private class ImgIDComparer : IComparer<Image>
		{
			public int Compare(Image x, Image y)
			{
				if (x.imgId > y.imgId)
				{
					return 1;
				}
				if (x.imgId == y.imgId)
				{
					return 0;
				}
				return -1;
			}
		}

		private class ImageHeightComparer : IComparer<Image>
		{
			public int Compare(Image x, Image y)
			{
				if (x.h > y.h)
				{
					return -1;
				}
				if (x.h == y.h)
				{
					return 0;
				}
				return 1;
			}
		}

		private class ImageWidthComparer : IComparer<Image>
		{
			public int Compare(Image x, Image y)
			{
				if (x.w > y.w)
				{
					return -1;
				}
				if (x.w == y.w)
				{
					return 0;
				}
				return 1;
			}
		}

		private class ImageAreaComparer : IComparer<Image>
		{
			public int Compare(Image x, Image y)
			{
				int num = x.w * x.h;
				int num2 = y.w * y.h;
				if (num > num2)
				{
					return -1;
				}
				if (num == num2)
				{
					return 0;
				}
				return 1;
			}
		}

		private class ProbeResult
		{
			public int w;

			public int h;

			public Node root;

			public bool fitsInMaxSize;

			public float efficiency;

			public float squareness;

			public void Set(int ww, int hh, Node r, bool fits, float e, float sq)
			{
				w = ww;
				h = hh;
				root = r;
				fitsInMaxSize = fits;
				efficiency = e;
				squareness = sq;
			}

			public float GetScore(bool doPowerOfTwoScore)
			{
				float num = (fitsInMaxSize ? 1f : 0f);
				if (doPowerOfTwoScore)
				{
					return num * 2f + efficiency;
				}
				return squareness + 2f * efficiency + num;
			}
		}

		private class Node
		{
			public Node[] child = new Node[2];

			public PixRect r;

			public Image img;

			private bool isLeaf()
			{
				if (child[0] == null || child[1] == null)
				{
					return true;
				}
				return false;
			}

			public Node Insert(Image im, bool handed)
			{
				int num;
				int num2;
				if (handed)
				{
					num = 0;
					num2 = 1;
				}
				else
				{
					num = 1;
					num2 = 0;
				}
				if (!isLeaf())
				{
					Node node = child[num].Insert(im, handed);
					if (node != null)
					{
						return node;
					}
					return child[num2].Insert(im, handed);
				}
				if (img != null)
				{
					return null;
				}
				if (r.w < im.w || r.h < im.h)
				{
					return null;
				}
				if (r.w == im.w && r.h == im.h)
				{
					img = im;
					return this;
				}
				child[num] = new Node();
				child[num2] = new Node();
				int num3 = r.w - im.w;
				int num4 = r.h - im.h;
				if (num3 > num4)
				{
					child[num].r = new PixRect(r.x, r.y, im.w, r.h);
					child[num2].r = new PixRect(r.x + im.w, r.y, r.w - im.w, r.h);
				}
				else
				{
					child[num].r = new PixRect(r.x, r.y, r.w, im.h);
					child[num2].r = new PixRect(r.x, r.y + im.h, r.w, r.h - im.h);
				}
				return child[num].Insert(im, handed);
			}
		}

		public MB2_LogLevel LOG_LEVEL = MB2_LogLevel.info;

		private ProbeResult bestRoot;

		public bool doPowerOfTwoTextures = true;

		private static void printTree(Node r, string spc)
		{
			if (r.child[0] != null)
			{
				printTree(r.child[0], spc + "  ");
			}
			if (r.child[1] != null)
			{
				printTree(r.child[1], spc + "  ");
			}
		}

		private static void flattenTree(Node r, List<Image> putHere)
		{
			if (r.img != null)
			{
				r.img.x = r.r.x;
				r.img.y = r.r.y;
				putHere.Add(r.img);
			}
			if (r.child[0] != null)
			{
				flattenTree(r.child[0], putHere);
			}
			if (r.child[1] != null)
			{
				flattenTree(r.child[1], putHere);
			}
		}

		private static void drawGizmosNode(Node r)
		{
			Vector3 size = new Vector3(r.r.w, r.r.h, 0f);
			Gizmos.DrawWireCube(new Vector3((float)r.r.x + size.x / 2f, (float)(-r.r.y) - size.y / 2f, 0f), size);
			if (r.img != null)
			{
				Gizmos.color = Color.blue;
				size = new Vector3(r.img.w, r.img.h, 0f);
				Gizmos.DrawCube(new Vector3((float)r.img.x + size.x / 2f, (float)(-r.img.y) - size.y / 2f, 0f), size);
			}
			if (r.child[0] != null)
			{
				Gizmos.color = Color.red;
				drawGizmosNode(r.child[0]);
			}
			if (r.child[1] != null)
			{
				Gizmos.color = Color.green;
				drawGizmosNode(r.child[1]);
			}
		}

		private static Texture2D createFilledTex(Color c, int w, int h)
		{
			Texture2D texture2D = new Texture2D(w, h);
			for (int i = 0; i < w; i++)
			{
				for (int j = 0; j < h; j++)
				{
					texture2D.SetPixel(i, j, c);
				}
			}
			texture2D.Apply();
			return texture2D;
		}

		public void DrawGizmos()
		{
			if (bestRoot != null)
			{
				drawGizmosNode(bestRoot.root);
			}
		}

		private bool Probe(Image[] imgsToAdd, int idealAtlasW, int idealAtlasH, float imgArea, int maxAtlasDim, ProbeResult pr)
		{
			Node node = new Node();
			node.r = new PixRect(0, 0, idealAtlasW, idealAtlasH);
			for (int i = 0; i < imgsToAdd.Length; i++)
			{
				if (node.Insert(imgsToAdd[i], handed: false) == null)
				{
					return false;
				}
				if (i != imgsToAdd.Length - 1)
				{
					continue;
				}
				int x = 0;
				int y = 0;
				GetExtent(node, ref x, ref y);
				bool fits;
				float num6;
				float num7;
				if (doPowerOfTwoTextures)
				{
					int num = Mathf.Min(CeilToNearestPowerOfTwo(x), maxAtlasDim);
					int num2 = Mathf.Min(CeilToNearestPowerOfTwo(y), maxAtlasDim);
					if (num2 < num / 2)
					{
						num2 = num / 2;
					}
					if (num < num2 / 2)
					{
						num = num2 / 2;
					}
					fits = x <= maxAtlasDim && y <= maxAtlasDim;
					float num3 = Mathf.Max(1f, (float)x / (float)maxAtlasDim);
					float num4 = Mathf.Max(1f, (float)y / (float)maxAtlasDim);
					float num5 = (float)num * num3 * (float)num2 * num4;
					num6 = 1f - (num5 - imgArea) / num5;
					num7 = 1f;
				}
				else
				{
					num6 = 1f - ((float)(x * y) - imgArea) / (float)(x * y);
					num7 = ((x >= y) ? ((float)y / (float)x) : ((float)x / (float)y));
					fits = x <= maxAtlasDim && y <= maxAtlasDim;
				}
				pr.Set(x, y, node, fits, num6, num7);
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug("Probe success efficiency w=" + x + " h=" + y + " e=" + num6 + " sq=" + num7 + " fits=" + fits.ToString());
				}
				return true;
			}
			UnityEngine.Debug.LogError("Should never get here.");
			return false;
		}

		private void GetExtent(Node r, ref int x, ref int y)
		{
			if (r.img != null)
			{
				if (r.r.x + r.img.w > x)
				{
					x = r.r.x + r.img.w;
				}
				if (r.r.y + r.img.h > y)
				{
					y = r.r.y + r.img.h;
				}
			}
			if (r.child[0] != null)
			{
				GetExtent(r.child[0], ref x, ref y);
			}
			if (r.child[1] != null)
			{
				GetExtent(r.child[1], ref x, ref y);
			}
		}

		private int StepWidthHeight(int oldVal, int step, int maxDim)
		{
			if (doPowerOfTwoTextures && oldVal < maxDim)
			{
				return oldVal * 2;
			}
			int num = oldVal + step;
			if (num > maxDim && oldVal < maxDim)
			{
				num = maxDim;
			}
			return num;
		}

		public int RoundToNearestPositivePowerOfTwo(int x)
		{
			int num = (int)Mathf.Pow(2f, Mathf.RoundToInt(Mathf.Log(x) / Mathf.Log(2f)));
			if (num == 0 || num == 1)
			{
				num = 2;
			}
			return num;
		}

		public int CeilToNearestPowerOfTwo(int x)
		{
			int num = (int)Mathf.Pow(2f, Mathf.Ceil(Mathf.Log(x) / Mathf.Log(2f)));
			if (num == 0 || num == 1)
			{
				num = 2;
			}
			return num;
		}

		public Rect[] GetRects(List<Vector2> imgWidthHeights, int maxDimension, int padding, out int outW, out int outH)
		{
			return _GetRects(imgWidthHeights, maxDimension, padding, 2 + padding * 2, 2 + padding * 2, 2 + padding * 2, 2 + padding * 2, out outW, out outH, 0);
		}

		private Rect[] _GetRects(List<Vector2> imgWidthHeights, int maxDimension, int padding, int minImageSizeX, int minImageSizeY, int masterImageSizeX, int masterImageSizeY, out int outW, out int outH, int recursionDepth)
		{
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log($"_GetRects numImages={imgWidthHeights.Count}, maxDimension={maxDimension}, padding={padding}, minImageSizeX={minImageSizeX}, minImageSizeY={minImageSizeY}, masterImageSizeX={masterImageSizeX}, masterImageSizeY={masterImageSizeY}, recursionDepth={recursionDepth}");
			}
			if (recursionDepth > 10)
			{
				UnityEngine.Debug.LogError("Maximum recursion depth reached. Couldn't find packing for these textures.");
				outW = 0;
				outH = 0;
				return new Rect[0];
			}
			float num = 0f;
			int num2 = 0;
			int num3 = 0;
			Image[] array = new Image[imgWidthHeights.Count];
			for (int i = 0; i < array.Length; i++)
			{
				Image image = (array[i] = new Image(i, (int)imgWidthHeights[i].x, (int)imgWidthHeights[i].y, padding, minImageSizeX, minImageSizeY));
				num += (float)(image.w * image.h);
				num2 = Mathf.Max(num2, image.w);
				num3 = Mathf.Max(num3, image.h);
			}
			if ((float)num3 / (float)num2 > 2f)
			{
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug("Using height Comparer");
				}
				Array.Sort(array, new ImageHeightComparer());
			}
			else if ((double)((float)num3 / (float)num2) < 0.5)
			{
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug("Using width Comparer");
				}
				Array.Sort(array, new ImageWidthComparer());
			}
			else
			{
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug("Using area Comparer");
				}
				Array.Sort(array, new ImageAreaComparer());
			}
			int num4 = (int)Mathf.Sqrt(num);
			int num6;
			int num5;
			if (doPowerOfTwoTextures)
			{
				num6 = (num5 = RoundToNearestPositivePowerOfTwo(num4));
				if (num2 > num6)
				{
					num6 = CeilToNearestPowerOfTwo(num6);
				}
				if (num3 > num5)
				{
					num5 = CeilToNearestPowerOfTwo(num5);
				}
			}
			else
			{
				num6 = num4;
				num5 = num4;
				if (num2 > num4)
				{
					num6 = num2;
					num5 = Mathf.Max(Mathf.CeilToInt(num / (float)num2), num3);
				}
				if (num3 > num4)
				{
					num6 = Mathf.Max(Mathf.CeilToInt(num / (float)num3), num2);
					num5 = num3;
				}
			}
			if (num6 == 0)
			{
				num6 = 1;
			}
			if (num5 == 0)
			{
				num5 = 1;
			}
			int num7 = (int)((float)num6 * 0.15f);
			int num8 = (int)((float)num5 * 0.15f);
			if (num7 == 0)
			{
				num7 = 1;
			}
			if (num8 == 0)
			{
				num8 = 1;
			}
			int num9 = 2;
			int num10 = num6;
			int num11 = num5;
			while (num9 >= 1 && num11 < num4 * 1000)
			{
				bool flag = false;
				num9 = 0;
				num10 = num6;
				while (!flag && num10 < num4 * 1000)
				{
					ProbeResult probeResult = new ProbeResult();
					if (LOG_LEVEL >= MB2_LogLevel.trace)
					{
						UnityEngine.Debug.Log("Probing h=" + num11 + " w=" + num10);
					}
					if (Probe(array, num10, num11, num, maxDimension, probeResult))
					{
						flag = true;
						if (bestRoot == null)
						{
							bestRoot = probeResult;
						}
						else if (probeResult.GetScore(doPowerOfTwoTextures) > bestRoot.GetScore(doPowerOfTwoTextures))
						{
							bestRoot = probeResult;
						}
						continue;
					}
					num9++;
					num10 = StepWidthHeight(num10, num7, maxDimension);
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug("increasing Width h=" + num11 + " w=" + num10);
					}
				}
				num11 = StepWidthHeight(num11, num8, maxDimension);
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug("increasing Height h=" + num11 + " w=" + num10);
				}
			}
			outW = 0;
			outH = 0;
			if (doPowerOfTwoTextures)
			{
				outW = Mathf.Min(CeilToNearestPowerOfTwo(bestRoot.w), maxDimension);
				outH = Mathf.Min(CeilToNearestPowerOfTwo(bestRoot.h), maxDimension);
				if (outH < outW / 2)
				{
					outH = outW / 2;
				}
				if (outW < outH / 2)
				{
					outW = outH / 2;
				}
			}
			else
			{
				outW = bestRoot.w;
				outH = bestRoot.h;
			}
			if (bestRoot == null)
			{
				return null;
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				MB2_Log.LogDebug("Best fit found: atlasW=" + outW + " atlasH" + outH + " w=" + bestRoot.w + " h=" + bestRoot.h + " efficiency=" + bestRoot.efficiency + " squareness=" + bestRoot.squareness + " fits in max dimension=" + bestRoot.fitsInMaxSize.ToString());
			}
			List<Image> list = new List<Image>();
			flattenTree(bestRoot.root, list);
			list.Sort(new ImgIDComparer());
			if (list.Count != array.Length)
			{
				UnityEngine.Debug.LogError("Result images not the same lentgh as source");
			}
			int minImageSizeX2 = minImageSizeX;
			int minImageSizeY2 = minImageSizeY;
			bool flag2 = false;
			float num12 = (float)padding / (float)outW;
			if (bestRoot.w > maxDimension)
			{
				num12 = (float)padding / (float)maxDimension;
				float num13 = (float)maxDimension / (float)bestRoot.w;
				if (LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Packing exceeded atlas width shrinking to " + num13);
				}
				for (int j = 0; j < list.Count; j++)
				{
					Image image2 = list[j];
					if ((float)image2.w * num13 < (float)masterImageSizeX)
					{
						if (LOG_LEVEL >= MB2_LogLevel.debug)
						{
							UnityEngine.Debug.Log("Small images are being scaled to zero. Will need to redo packing with larger minTexSizeX.");
						}
						flag2 = true;
						minImageSizeX2 = Mathf.CeilToInt((float)minImageSizeX / num13);
					}
					int num14 = (int)((float)(image2.x + image2.w) * num13);
					image2.x = (int)(num13 * (float)image2.x);
					image2.w = num14 - image2.x;
				}
				outW = maxDimension;
			}
			float num15 = (float)padding / (float)outH;
			if (bestRoot.h > maxDimension)
			{
				num15 = (float)padding / (float)maxDimension;
				float num16 = (float)maxDimension / (float)bestRoot.h;
				if (LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Packing exceeded atlas height shrinking to " + num16);
				}
				for (int k = 0; k < list.Count; k++)
				{
					Image image3 = list[k];
					if ((float)image3.h * num16 < (float)masterImageSizeY)
					{
						if (LOG_LEVEL >= MB2_LogLevel.debug)
						{
							UnityEngine.Debug.Log("Small images are being scaled to zero. Will need to redo packing with larger minTexSizeY.");
						}
						flag2 = true;
						minImageSizeY2 = Mathf.CeilToInt((float)minImageSizeY / num16);
					}
					int num17 = (int)((float)(image3.y + image3.h) * num16);
					image3.y = (int)(num16 * (float)image3.y);
					image3.h = num17 - image3.y;
				}
				outH = maxDimension;
			}
			Rect[] array2;
			if (!flag2)
			{
				array2 = new Rect[list.Count];
				for (int l = 0; l < list.Count; l++)
				{
					Image image4 = list[l];
					Rect rect = (array2[l] = new Rect((float)image4.x / (float)outW + num12, (float)image4.y / (float)outH + num15, (float)image4.w / (float)outW - num12 * 2f, (float)image4.h / (float)outH - num15 * 2f));
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug("Image: " + l + " imgID=" + image4.imgId + " x=" + rect.x * (float)outW + " y=" + rect.y * (float)outH + " w=" + rect.width * (float)outW + " h=" + rect.height * (float)outH + " padding=" + padding);
					}
				}
			}
			else
			{
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					UnityEngine.Debug.Log("==================== REDOING PACKING ================");
				}
				bestRoot = null;
				array2 = _GetRects(imgWidthHeights, maxDimension, padding, minImageSizeX2, minImageSizeY2, masterImageSizeX, masterImageSizeY, out outW, out outH, recursionDepth + 1);
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				MB2_Log.LogDebug("Done GetRects");
			}
			return array2;
		}

		public void RunTestHarness()
		{
			int num = 32;
			int min = 126;
			int max = 2046;
			List<Vector2> list = new List<Vector2>();
			for (int i = 0; i < num; i++)
			{
				list.Add(new Vector2(UnityEngine.Random.Range(min, max), UnityEngine.Random.Range(min, max) * 5));
			}
			doPowerOfTwoTextures = true;
			LOG_LEVEL = MB2_LogLevel.trace;
			int padding = 1;
			GetRects(list, 4096, padding, out var _, out var _);
		}
	}
	[Serializable]
	public class MB3_AgglomerativeClustering
	{
		[Serializable]
		public class ClusterNode
		{
			public item_s leaf;

			public ClusterNode cha;

			public ClusterNode chb;

			public int height;

			public float distToMergedCentroid;

			public Vector3 centroid;

			public int[] leafs;

			public int idx;

			public ClusterNode(item_s ii, int index)
			{
				leaf = ii;
				idx = index;
				leafs = new int[1];
				leafs[0] = index;
				centroid = ii.coord;
				height = 0;
			}

			public ClusterNode(ClusterNode a, ClusterNode b, int index, int h, float dist, ClusterNode[] clusters)
			{
				cha = a;
				chb = b;
				idx = index;
				leafs = new int[a.leafs.Length + b.leafs.Length];
				Array.Copy(a.leafs, leafs, a.leafs.Length);
				Array.Copy(b.leafs, 0, leafs, a.leafs.Length, b.leafs.Length);
				Vector3 zero = Vector3.zero;
				for (int i = 0; i < leafs.Length; i++)
				{
					zero += clusters[leafs[i]].centroid;
				}
				centroid = zero / leafs.Length;
				height = h;
				distToMergedCentroid = dist;
			}
		}

		[Serializable]
		public class item_s
		{
			public GameObject go;

			public Vector3 coord;
		}

		public List<item_s> items = new List<item_s>();

		public ClusterNode[] clusters;

		private float euclidean_distance(Vector3 a, Vector3 b)
		{
			return Vector3.Distance(a, b);
		}

		public void agglomerate(ProgressUpdateDelegate progFunc)
		{
			if (items.Count <= 1)
			{
				clusters = new ClusterNode[0];
				return;
			}
			clusters = new ClusterNode[items.Count * 2 - 1];
			for (int i = 0; i < items.Count; i++)
			{
				clusters[i] = new ClusterNode(items[i], i);
			}
			float[][] array = new float[items.Count * 2 - 1][];
			for (int j = 0; j < array.Length; j++)
			{
				array[j] = new float[items.Count * 2 - 1];
			}
			int num = items.Count;
			List<ClusterNode> list = new List<ClusterNode>();
			for (int k = 0; k < num; k++)
			{
				list.Add(clusters[k]);
				for (int l = 0; l < num; l++)
				{
					array[k][l] = euclidean_distance(clusters[k].centroid, clusters[l].centroid);
				}
			}
			int num2 = 0;
			new Timer().Start();
			while (list.Count > 1)
			{
				num2++;
				float num3 = 1E+16f;
				int num4;
				int num5 = (num4 = -1);
				for (int m = 0; m < list.Count; m++)
				{
					for (int n = 0; n < list.Count; n++)
					{
						if (m != n)
						{
							int idx = list[m].idx;
							int idx2 = list[n].idx;
							float num6 = array[idx][idx2];
							if (num6 < num3)
							{
								num3 = num6;
								num5 = idx;
								num4 = idx2;
							}
						}
					}
				}
				num++;
				ClusterNode clusterNode = new ClusterNode(clusters[num5], clusters[num4], num - 1, num2, num3, clusters);
				list.Remove(clusters[num5]);
				list.Remove(clusters[num4]);
				clusters[num - 1] = clusterNode;
				list.Add(clusterNode);
				for (int num7 = 0; num7 < num - 1; num7++)
				{
					array[num - 1][num7] = euclidean_distance(clusters[num - 1].centroid, clusters[num7].centroid);
					array[num7][num - 1] = euclidean_distance(clusters[num7].centroid, clusters[num - 1].centroid);
				}
				progFunc?.Invoke("Creating clusters:", (float)(items.Count - list.Count) / (float)items.Count);
			}
		}

		public int TestRun(List<GameObject> gos)
		{
			List<item_s> list = new List<item_s>();
			for (int i = 0; i < gos.Count; i++)
			{
				item_s item_s = new item_s();
				item_s.go = gos[i];
				item_s.coord = gos[i].transform.position;
				list.Add(item_s);
			}
			items = list;
			if (items.Count > 0)
			{
				agglomerate(null);
			}
			return 0;
		}
	}
	public class MB3_CopyBoneWeights
	{
		public static void CopyBoneWeightsFromSeamMeshToOtherMeshes(float radius, Mesh seamMesh, Mesh[] targetMeshes)
		{
			List<int> list = new List<int>();
			if (seamMesh == null)
			{
				UnityEngine.Debug.LogError($"The SeamMesh cannot be null");
				return;
			}
			if (seamMesh.vertexCount == 0)
			{
				UnityEngine.Debug.LogError("The seam mesh has no vertices. Check that the Asset Importer for the seam mesh does not have 'Optimize Mesh' checked.");
				return;
			}
			Vector3[] vertices = seamMesh.vertices;
			BoneWeight[] boneWeights = seamMesh.boneWeights;
			Vector3[] normals = seamMesh.normals;
			Vector4[] tangents = seamMesh.tangents;
			Vector2[] uv = seamMesh.uv;
			if (uv.Length != vertices.Length)
			{
				UnityEngine.Debug.LogError("The seam mesh needs uvs to identify which vertices are part of the seam. Vertices with UV > .5 are part of the seam. Vertices with UV < .5 are not part of the seam.");
				return;
			}
			for (int i = 0; i < uv.Length; i++)
			{
				if (uv[i].x > 0.5f && uv[i].y > 0.5f)
				{
					list.Add(i);
				}
			}
			UnityEngine.Debug.Log($"The seam mesh has {seamMesh.vertices.Length} vertices of which {list.Count} are seam vertices.");
			if (list.Count == 0)
			{
				UnityEngine.Debug.LogError("None of the vertices in the Seam Mesh were marked as seam vertices. To mark a vertex as a seam vertex the UV must be greater than (.5,.5). Vertices with UV less than (.5,.5) are excluded.");
				return;
			}
			bool flag = false;
			for (int j = 0; j < targetMeshes.Length; j++)
			{
				if (targetMeshes[j] == null)
				{
					UnityEngine.Debug.LogError($"Mesh {j} was null");
					flag = true;
				}
				if (radius < 0f)
				{
					UnityEngine.Debug.LogError("radius must be zero or positive.");
				}
			}
			if (flag)
			{
				return;
			}
			for (int k = 0; k < targetMeshes.Length; k++)
			{
				Mesh obj = targetMeshes[k];
				Vector3[] vertices2 = obj.vertices;
				BoneWeight[] boneWeights2 = obj.boneWeights;
				Vector3[] normals2 = obj.normals;
				Vector4[] tangents2 = obj.tangents;
				int num = 0;
				for (int l = 0; l < vertices2.Length; l++)
				{
					for (int m = 0; m < list.Count; m++)
					{
						int num2 = list[m];
						if (Vector3.Distance(vertices2[l], vertices[num2]) <= radius)
						{
							num++;
							boneWeights2[l] = boneWeights[num2];
							vertices2[l] = vertices[num2];
							if (normals2.Length == vertices2.Length && normals.Length == normals.Length)
							{
								normals2[l] = normals[num2];
							}
							if (tangents2.Length == vertices2.Length && tangents.Length == vertices.Length)
							{
								tangents2[l] = tangents[num2];
							}
						}
					}
				}
				if (num > 0)
				{
					targetMeshes[k].vertices = vertices2;
					targetMeshes[k].boneWeights = boneWeights2;
					targetMeshes[k].normals = normals2;
					targetMeshes[k].tangents = tangents2;
				}
				UnityEngine.Debug.Log(string.Format("Copied boneweights for {1} vertices in mesh {0} that matched positions in the seam mesh.", targetMeshes[k].name, num));
			}
		}
	}
	[Serializable]
	public abstract class MB3_MeshCombiner
	{
		public delegate void GenerateUV2Delegate(Mesh m, float hardAngle, float packMargin);

		public class MBBlendShapeKey
		{
			public int gameObjecID;

			public int blendShapeIndexInSrc;

			public MBBlendShapeKey(int srcSkinnedMeshRenderGameObjectID, int blendShapeIndexInSource)
			{
				gameObjecID = srcSkinnedMeshRenderGameObjectID;
				blendShapeIndexInSrc = blendShapeIndexInSource;
			}

			public override bool Equals(object obj)
			{
				if (!(obj is MBBlendShapeKey) || obj == null)
				{
					return false;
				}
				MBBlendShapeKey mBBlendShapeKey = (MBBlendShapeKey)obj;
				if (gameObjecID == mBBlendShapeKey.gameObjecID)
				{
					return blendShapeIndexInSrc == mBBlendShapeKey.blendShapeIndexInSrc;
				}
				return false;
			}

			public override int GetHashCode()
			{
				return (23 * 31 + gameObjecID) * 31 + blendShapeIndexInSrc;
			}
		}

		public class MBBlendShapeValue
		{
			public GameObject combinedMeshGameObject;

			public int blendShapeIndex;
		}

		[SerializeField]
		protected MB2_LogLevel _LOG_LEVEL = MB2_LogLevel.info;

		[SerializeField]
		protected MB2_ValidationLevel _validationLevel = MB2_ValidationLevel.robust;

		[SerializeField]
		protected string _name;

		[SerializeField]
		protected MB2_TextureBakeResults _textureBakeResults;

		[SerializeField]
		protected GameObject _resultSceneObject;

		[SerializeField]
		protected Renderer _targetRenderer;

		[SerializeField]
		protected MB_RenderType _renderType;

		[SerializeField]
		protected MB2_OutputOptions _outputOption;

		[SerializeField]
		protected MB2_LightmapOptions _lightmapOption = MB2_LightmapOptions.ignore_UV2;

		[SerializeField]
		protected bool _doNorm = true;

		[SerializeField]
		protected bool _doTan = true;

		[SerializeField]
		protected bool _doCol;

		[SerializeField]
		protected bool _doUV = true;

		[SerializeField]
		protected bool _doUV3;

		[SerializeField]
		protected bool _doUV4;

		[SerializeField]
		protected bool _doBlendShapes;

		[SerializeField]
		protected bool _recenterVertsToBoundsCenter;

		[SerializeField]
		public bool _optimizeAfterBake = true;

		[SerializeField]
		public float uv2UnwrappingParamsHardAngle = 60f;

		[SerializeField]
		public float uv2UnwrappingParamsPackMargin = 0.005f;

		protected bool _usingTemporaryTextureBakeResult;

		public static bool EVAL_VERSION => false;

		public virtual MB2_LogLevel LOG_LEVEL
		{
			get
			{
				return _LOG_LEVEL;
			}
			set
			{
				_LOG_LEVEL = value;
			}
		}

		public virtual MB2_ValidationLevel validationLevel
		{
			get
			{
				return _validationLevel;
			}
			set
			{
				_validationLevel = value;
			}
		}

		public string name
		{
			get
			{
				return _name;
			}
			set
			{
				_name = value;
			}
		}

		public virtual MB2_TextureBakeResults textureBakeResults
		{
			get
			{
				return _textureBakeResults;
			}
			set
			{
				_textureBakeResults = value;
			}
		}

		public virtual GameObject resultSceneObject
		{
			get
			{
				return _resultSceneObject;
			}
			set
			{
				_resultSceneObject = value;
			}
		}

		public virtual Renderer targetRenderer
		{
			get
			{
				return _targetRenderer;
			}
			set
			{
				if (_targetRenderer != null && _targetRenderer != value)
				{
					UnityEngine.Debug.LogWarning("Previous targetRenderer was not null. Combined mesh may be being used by more than one Renderer");
				}
				_targetRenderer = value;
			}
		}

		public virtual MB_RenderType renderType
		{
			get
			{
				return _renderType;
			}
			set
			{
				_renderType = value;
			}
		}

		public virtual MB2_OutputOptions outputOption
		{
			get
			{
				return _outputOption;
			}
			set
			{
				_outputOption = value;
			}
		}

		public virtual MB2_LightmapOptions lightmapOption
		{
			get
			{
				return _lightmapOption;
			}
			set
			{
				_lightmapOption = value;
			}
		}

		public virtual bool doNorm
		{
			get
			{
				return _doNorm;
			}
			set
			{
				_doNorm = value;
			}
		}

		public virtual bool doTan
		{
			get
			{
				return _doTan;
			}
			set
			{
				_doTan = value;
			}
		}

		public virtual bool doCol
		{
			get
			{
				return _doCol;
			}
			set
			{
				_doCol = value;
			}
		}

		public virtual bool doUV
		{
			get
			{
				return _doUV;
			}
			set
			{
				_doUV = value;
			}
		}

		public virtual bool doUV1
		{
			get
			{
				return false;
			}
			set
			{
			}
		}

		public virtual bool doUV3
		{
			get
			{
				return _doUV3;
			}
			set
			{
				_doUV3 = value;
			}
		}

		public virtual bool doUV4
		{
			get
			{
				return _doUV4;
			}
			set
			{
				_doUV4 = value;
			}
		}

		public virtual bool doBlendShapes
		{
			get
			{
				return _doBlendShapes;
			}
			set
			{
				_doBlendShapes = value;
			}
		}

		public virtual bool recenterVertsToBoundsCenter
		{
			get
			{
				return _recenterVertsToBoundsCenter;
			}
			set
			{
				_recenterVertsToBoundsCenter = value;
			}
		}

		public bool optimizeAfterBake
		{
			get
			{
				return _optimizeAfterBake;
			}
			set
			{
				_optimizeAfterBake = value;
			}
		}

		public virtual bool doUV2()
		{
			if (_lightmapOption != MB2_LightmapOptions.copy_UV2_unchanged && _lightmapOption != 0)
			{
				return _lightmapOption == MB2_LightmapOptions.copy_UV2_unchanged_to_separate_rects;
			}
			return true;
		}

		public abstract int GetLightmapIndex();

		public abstract void ClearBuffers();

		public abstract void ClearMesh();

		public abstract void DestroyMesh();

		public abstract void DestroyMeshEditor(MB2_EditorMethodsInterface editorMethods);

		public abstract List<GameObject> GetObjectsInCombined();

		public abstract int GetNumObjectsInCombined();

		public abstract int GetNumVerticesFor(GameObject go);

		public abstract int GetNumVerticesFor(int instanceID);

		public abstract Dictionary<MBBlendShapeKey, MBBlendShapeValue> BuildSourceBlendShapeToCombinedIndexMap();

		public virtual void Apply()
		{
			Apply(null);
		}

		public abstract void Apply(GenerateUV2Delegate uv2GenerationMethod);

		public abstract void Apply(bool triangles, bool vertices, bool normals, bool tangents, bool uvs, bool uv2, bool uv3, bool uv4, bool colors, bool bones = false, bool blendShapeFlag = false, GenerateUV2Delegate uv2GenerationMethod = null);

		public abstract void UpdateGameObjects(GameObject[] gos, bool recalcBounds = true, bool updateVertices = true, bool updateNormals = true, bool updateTangents = true, bool updateUV = false, bool updateUV2 = false, bool updateUV3 = false, bool updateUV4 = false, bool updateColors = false, bool updateSkinningInfo = false);

		public abstract bool AddDeleteGameObjects(GameObject[] gos, GameObject[] deleteGOs, bool disableRendererInSource = true);

		public abstract bool AddDeleteGameObjectsByID(GameObject[] gos, int[] deleteGOinstanceIDs, bool disableRendererInSource);

		public abstract bool CombinedMeshContains(GameObject go);

		public abstract void UpdateSkinnedMeshApproximateBounds();

		public abstract void UpdateSkinnedMeshApproximateBoundsFromBones();

		public abstract void CheckIntegrity();

		public abstract void UpdateSkinnedMeshApproximateBoundsFromBounds();

		public static void UpdateSkinnedMeshApproximateBoundsFromBonesStatic(Transform[] bs, SkinnedMeshRenderer smr)
		{
			Vector3 position = bs[0].position;
			Vector3 position2 = bs[0].position;
			for (int i = 1; i < bs.Length; i++)
			{
				Vector3 position3 = bs[i].position;
				if (position3.x < position2.x)
				{
					position2.x = position3.x;
				}
				if (position3.y < position2.y)
				{
					position2.y = position3.y;
				}
				if (position3.z < position2.z)
				{
					position2.z = position3.z;
				}
				if (position3.x > position.x)
				{
					position.x = position3.x;
				}
				if (position3.y > position.y)
				{
					position.y = position3.y;
				}
				if (position3.z > position.z)
				{
					position.z = position3.z;
				}
			}
			Vector3 vector = (position + position2) / 2f;
			Vector3 vector2 = position - position2;
			Matrix4x4 worldToLocalMatrix = smr.worldToLocalMatrix;
			Bounds localBounds = new Bounds(worldToLocalMatrix * vector, worldToLocalMatrix * vector2);
			smr.localBounds = localBounds;
		}

		public static void UpdateSkinnedMeshApproximateBoundsFromBoundsStatic(List<GameObject> objectsInCombined, SkinnedMeshRenderer smr)
		{
			Bounds b = default(Bounds);
			Bounds bounds = default(Bounds);
			if (MB_Utility.GetBounds(objectsInCombined[0], out b))
			{
				bounds = b;
				for (int i = 1; i < objectsInCombined.Count; i++)
				{
					if (MB_Utility.GetBounds(objectsInCombined[i], out b))
					{
						bounds.Encapsulate(b);
						continue;
					}
					UnityEngine.Debug.LogError("Could not get bounds. Not updating skinned mesh bounds");
					return;
				}
				smr.localBounds = bounds;
			}
			else
			{
				UnityEngine.Debug.LogError("Could not get bounds. Not updating skinned mesh bounds");
			}
		}

		protected virtual bool _CreateTemporaryTextrueBakeResult(GameObject[] gos)
		{
			_usingTemporaryTextureBakeResult = true;
			_textureBakeResults = MB2_TextureBakeResults.CreateForMaterialsOnRenderer(gos);
			return true;
		}
	}
	[Serializable]
	public class MB3_MeshCombinerSingle : MB3_MeshCombiner
	{
		[Serializable]
		public class MB_DynamicGameObject : IComparable<MB_DynamicGameObject>
		{
			public int instanceID;

			public string name;

			public int vertIdx;

			public int blendShapeIdx;

			public int numVerts;

			public int numBlendShapes;

			public int[] indexesOfBonesUsed = new int[0];

			public int lightmapIndex = -1;

			public Vector4 lightmapTilingOffset = new Vector4(1f, 1f, 0f, 0f);

			public Vector3 meshSize = Vector3.one;

			public bool show = true;

			public bool invertTriangles;

			public int[] submeshTriIdxs;

			public int[] submeshNumTris;

			public int[] targetSubmeshIdxs;

			public Rect[] uvRects;

			public Rect[] encapsulatingRect;

			public Rect[] sourceMaterialTiling;

			public Rect[] obUVRects;

			public int[][] _submeshTris;

			public bool _beingDeleted;

			public int _triangleIdxAdjustment;

			public Transform[] _tmpCachedBones;

			public Matrix4x4[] _tmpCachedBindposes;

			public BoneWeight[] _tmpCachedBoneWeights;

			public int[] _tmpIndexesOfSourceBonesUsed;

			public int CompareTo(MB_DynamicGameObject b)
			{
				return vertIdx - b.vertIdx;
			}
		}

		public class MeshChannels
		{
			public Vector3[] vertices;

			public Vector3[] normals;

			public Vector4[] tangents;

			public Vector2[] uv0raw;

			public Vector2[] uv0modified;

			public Vector2[] uv2;

			public Vector2[] uv3;

			public Vector2[] uv4;

			public Color[] colors;

			public BoneWeight[] boneWeights;

			public Matrix4x4[] bindPoses;

			public int[] triangles;

			public MBBlendShape[] blendShapes;
		}

		[Serializable]
		public class MBBlendShapeFrame
		{
			public float frameWeight;

			public Vector3[] vertices;

			public Vector3[] normals;

			public Vector3[] tangents;
		}

		[Serializable]
		public class MBBlendShape
		{
			public int gameObjectID;

			public string name;

			public int indexInSource;

			public MBBlendShapeFrame[] frames;
		}

		public class MeshChannelsCache
		{
			private MB3_MeshCombinerSingle mc;

			protected Dictionary<int, MeshChannels> meshID2MeshChannels = new Dictionary<int, MeshChannels>();

			private Vector2 _HALF_UV = new Vector2(0.5f, 0.5f);

			internal MeshChannelsCache(MB3_MeshCombinerSingle mcs)
			{
				mc = mcs;
			}

			internal Vector3[] GetVertices(Mesh m)
			{
				if (!meshID2MeshChannels.TryGetValue(m.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(m.GetInstanceID(), value);
				}
				if (value.vertices == null)
				{
					value.vertices = m.vertices;
				}
				return value.vertices;
			}

			internal Vector3[] GetNormals(Mesh m)
			{
				if (!meshID2MeshChannels.TryGetValue(m.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(m.GetInstanceID(), value);
				}
				if (value.normals == null)
				{
					value.normals = _getMeshNormals(m);
				}
				return value.normals;
			}

			internal Vector4[] GetTangents(Mesh m)
			{
				if (!meshID2MeshChannels.TryGetValue(m.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(m.GetInstanceID(), value);
				}
				if (value.tangents == null)
				{
					value.tangents = _getMeshTangents(m);
				}
				return value.tangents;
			}

			internal Vector2[] GetUv0Raw(Mesh m)
			{
				if (!meshID2MeshChannels.TryGetValue(m.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(m.GetInstanceID(), value);
				}
				if (value.uv0raw == null)
				{
					value.uv0raw = _getMeshUVs(m);
				}
				return value.uv0raw;
			}

			internal Vector2[] GetUv0Modified(Mesh m)
			{
				if (!meshID2MeshChannels.TryGetValue(m.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(m.GetInstanceID(), value);
				}
				if (value.uv0modified == null)
				{
					value.uv0modified = null;
				}
				return value.uv0modified;
			}

			internal Vector2[] GetUv2(Mesh m)
			{
				if (!meshID2MeshChannels.TryGetValue(m.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(m.GetInstanceID(), value);
				}
				if (value.uv2 == null)
				{
					value.uv2 = _getMeshUV2s(m);
				}
				return value.uv2;
			}

			internal Vector2[] GetUv3(Mesh m)
			{
				if (!meshID2MeshChannels.TryGetValue(m.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(m.GetInstanceID(), value);
				}
				if (value.uv3 == null)
				{
					value.uv3 = MBVersion.GetMeshUV3orUV4(m, get3: true, mc.LOG_LEVEL);
				}
				return value.uv3;
			}

			internal Vector2[] GetUv4(Mesh m)
			{
				if (!meshID2MeshChannels.TryGetValue(m.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(m.GetInstanceID(), value);
				}
				if (value.uv4 == null)
				{
					value.uv4 = MBVersion.GetMeshUV3orUV4(m, get3: false, mc.LOG_LEVEL);
				}
				return value.uv4;
			}

			internal Color[] GetColors(Mesh m)
			{
				if (!meshID2MeshChannels.TryGetValue(m.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(m.GetInstanceID(), value);
				}
				if (value.colors == null)
				{
					value.colors = _getMeshColors(m);
				}
				return value.colors;
			}

			internal Matrix4x4[] GetBindposes(Renderer r)
			{
				Mesh mesh = MB_Utility.GetMesh(r.gameObject);
				if (!meshID2MeshChannels.TryGetValue(mesh.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(mesh.GetInstanceID(), value);
				}
				if (value.bindPoses == null)
				{
					value.bindPoses = _getBindPoses(r);
				}
				return value.bindPoses;
			}

			internal BoneWeight[] GetBoneWeights(Renderer r, int numVertsInMeshBeingAdded)
			{
				Mesh mesh = MB_Utility.GetMesh(r.gameObject);
				if (!meshID2MeshChannels.TryGetValue(mesh.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(mesh.GetInstanceID(), value);
				}
				if (value.boneWeights == null)
				{
					value.boneWeights = _getBoneWeights(r, numVertsInMeshBeingAdded);
				}
				return value.boneWeights;
			}

			internal int[] GetTriangles(Mesh m)
			{
				if (!meshID2MeshChannels.TryGetValue(m.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(m.GetInstanceID(), value);
				}
				if (value.triangles == null)
				{
					value.triangles = m.triangles;
				}
				return value.triangles;
			}

			internal MBBlendShape[] GetBlendShapes(Mesh m, int gameObjectID)
			{
				return new MBBlendShape[0];
			}

			private Color[] _getMeshColors(Mesh m)
			{
				Color[] array = m.colors;
				if (array.Length == 0)
				{
					if (mc.LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug(string.Concat("Mesh ", m, " has no colors. Generating"));
					}
					if (mc.LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning(string.Concat("Mesh ", m, " didn't have colors. Generating an array of white colors"));
					}
					array = new Color[m.vertexCount];
					for (int i = 0; i < array.Length; i++)
					{
						array[i] = Color.white;
					}
				}
				return array;
			}

			private Vector3[] _getMeshNormals(Mesh m)
			{
				Vector3[] normals = m.normals;
				if (normals.Length == 0)
				{
					if (mc.LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug(string.Concat("Mesh ", m, " has no normals. Generating"));
					}
					if (mc.LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning(string.Concat("Mesh ", m, " didn't have normals. Generating normals."));
					}
					Mesh mesh = UnityEngine.Object.Instantiate(m);
					mesh.RecalculateNormals();
					normals = mesh.normals;
					MB_Utility.Destroy(mesh);
				}
				return normals;
			}

			private Vector4[] _getMeshTangents(Mesh m)
			{
				Vector4[] array = m.tangents;
				if (array.Length == 0)
				{
					if (mc.LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug(string.Concat("Mesh ", m, " has no tangents. Generating"));
					}
					if (mc.LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning(string.Concat("Mesh ", m, " didn't have tangents. Generating tangents."));
					}
					Vector3[] vertices = m.vertices;
					Vector2[] uv0Raw = GetUv0Raw(m);
					Vector3[] normals = _getMeshNormals(m);
					array = new Vector4[m.vertexCount];
					for (int i = 0; i < m.subMeshCount; i++)
					{
						int[] triangles = m.GetTriangles(i);
						_generateTangents(triangles, vertices, uv0Raw, normals, array);
					}
				}
				return array;
			}

			private Vector2[] _getMeshUVs(Mesh m)
			{
				Vector2[] array = m.uv;
				if (array.Length == 0)
				{
					if (mc.LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug(string.Concat("Mesh ", m, " has no uvs. Generating"));
					}
					if (mc.LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning(string.Concat("Mesh ", m, " didn't have uvs. Generating uvs."));
					}
					array = new Vector2[m.vertexCount];
					for (int i = 0; i < array.Length; i++)
					{
						array[i] = _HALF_UV;
					}
				}
				return array;
			}

			private Vector2[] _getMeshUV2s(Mesh m)
			{
				Vector2[] array = m.uv2;
				if (array.Length == 0)
				{
					if (mc.LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug(string.Concat("Mesh ", m, " has no uv2s. Generating"));
					}
					if (mc.LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning(string.Concat("Mesh ", m, " didn't have uv2s. Generating uv2s."));
					}
					array = new Vector2[m.vertexCount];
					for (int i = 0; i < array.Length; i++)
					{
						array[i] = _HALF_UV;
					}
				}
				return array;
			}

			public static Matrix4x4[] _getBindPoses(Renderer r)
			{
				if (r is SkinnedMeshRenderer)
				{
					return ((SkinnedMeshRenderer)r).sharedMesh.bindposes;
				}
				if (r is MeshRenderer)
				{
					Matrix4x4 identity = Matrix4x4.identity;
					return new Matrix4x4[1] { identity };
				}
				UnityEngine.Debug.LogError("Could not _getBindPoses. Object does not have a renderer");
				return null;
			}

			public static BoneWeight[] _getBoneWeights(Renderer r, int numVertsInMeshBeingAdded)
			{
				if (r is SkinnedMeshRenderer)
				{
					return ((SkinnedMeshRenderer)r).sharedMesh.boneWeights;
				}
				if (r is MeshRenderer)
				{
					BoneWeight boneWeight = default(BoneWeight);
					int num2 = (boneWeight.boneIndex3 = 0);
					int num4 = (boneWeight.boneIndex2 = num2);
					int boneIndex = (boneWeight.boneIndex1 = num4);
					boneWeight.boneIndex0 = boneIndex;
					boneWeight.weight0 = 1f;
					float num7 = (boneWeight.weight3 = 0f);
					float weight = (boneWeight.weight2 = num7);
					boneWeight.weight1 = weight;
					BoneWeight[] array = new BoneWeight[numVertsInMeshBeingAdded];
					for (int i = 0; i < array.Length; i++)
					{
						array[i] = boneWeight;
					}
					return array;
				}
				UnityEngine.Debug.LogError("Could not _getBoneWeights. Object does not have a renderer");
				return null;
			}

			private void _generateTangents(int[] triangles, Vector3[] verts, Vector2[] uvs, Vector3[] normals, Vector4[] outTangents)
			{
				int num = triangles.Length;
				int num2 = verts.Length;
				Vector3[] array = new Vector3[num2];
				Vector3[] array2 = new Vector3[num2];
				for (int i = 0; i < num; i += 3)
				{
					int num3 = triangles[i];
					int num4 = triangles[i + 1];
					int num5 = triangles[i + 2];
					Vector3 vector = verts[num3];
					Vector3 vector2 = verts[num4];
					Vector3 vector3 = verts[num5];
					Vector2 vector4 = uvs[num3];
					Vector2 vector5 = uvs[num4];
					Vector2 vector6 = uvs[num5];
					float num6 = vector2.x - vector.x;
					float num7 = vector3.x - vector.x;
					float num8 = vector2.y - vector.y;
					float num9 = vector3.y - vector.y;
					float num10 = vector2.z - vector.z;
					float num11 = vector3.z - vector.z;
					float num12 = vector5.x - vector4.x;
					float num13 = vector6.x - vector4.x;
					float num14 = vector5.y - vector4.y;
					float num15 = vector6.y - vector4.y;
					float num16 = num12 * num15 - num13 * num14;
					if (num16 == 0f)
					{
						UnityEngine.Debug.LogError("Could not compute tangents. All UVs need to form a valid triangles in UV space. If any UV triangles are collapsed, tangents cannot be generated.");
						return;
					}
					float num17 = 1f / num16;
					Vector3 vector7 = new Vector3((num15 * num6 - num14 * num7) * num17, (num15 * num8 - num14 * num9) * num17, (num15 * num10 - num14 * num11) * num17);
					Vector3 vector8 = new Vector3((num12 * num7 - num13 * num6) * num17, (num12 * num9 - num13 * num8) * num17, (num12 * num11 - num13 * num10) * num17);
					array[num3] += vector7;
					array[num4] += vector7;
					array[num5] += vector7;
					array2[num3] += vector8;
					array2[num4] += vector8;
					array2[num5] += vector8;
				}
				for (int j = 0; j < num2; j++)
				{
					Vector3 vector9 = normals[j];
					Vector3 vector10 = array[j];
					Vector3 normalized = (vector10 - vector9 * Vector3.Dot(vector9, vector10)).normalized;
					outTangents[j] = new Vector4(normalized.x, normalized.y, normalized.z);
					outTangents[j].w = ((Vector3.Dot(Vector3.Cross(vector9, vector10), array2[j]) < 0f) ? (-1f) : 1f);
				}
			}
		}

		public struct BoneAndBindpose
		{
			public Transform bone;

			public Matrix4x4 bindPose;

			public BoneAndBindpose(Transform t, Matrix4x4 bp)
			{
				bone = t;
				bindPose = bp;
			}

			public override bool Equals(object obj)
			{
				if (obj is BoneAndBindpose && bone == ((BoneAndBindpose)obj).bone && bindPose == ((BoneAndBindpose)obj).bindPose)
				{
					return true;
				}
				return false;
			}

			public override int GetHashCode()
			{
				return (bone.GetInstanceID() % int.MaxValue) ^ (int)bindPose[0, 0];
			}
		}

		[SerializeField]
		protected List<GameObject> objectsInCombinedMesh = new List<GameObject>();

		[SerializeField]
		private int lightmapIndex = -1;

		[SerializeField]
		private List<MB_DynamicGameObject> mbDynamicObjectsInCombinedMesh = new List<MB_DynamicGameObject>();

		private Dictionary<int, MB_DynamicGameObject> _instance2combined_map = new Dictionary<int, MB_DynamicGameObject>();

		[SerializeField]
		private Vector3[] verts = new Vector3[0];

		[SerializeField]
		private Vector3[] normals = new Vector3[0];

		[SerializeField]
		private Vector4[] tangents = new Vector4[0];

		[SerializeField]
		private Vector2[] uvs = new Vector2[0];

		[SerializeField]
		private Vector2[] uv2s = new Vector2[0];

		[SerializeField]
		private Vector2[] uv3s = new Vector2[0];

		[SerializeField]
		private Vector2[] uv4s = new Vector2[0];

		[SerializeField]
		private Color[] colors = new Color[0];

		[SerializeField]
		private Matrix4x4[] bindPoses = new Matrix4x4[0];

		[SerializeField]
		private Transform[] bones = new Transform[0];

		[SerializeField]
		internal MBBlendShape[] blendShapes = new MBBlendShape[0];

		[SerializeField]
		private Mesh _mesh;

		private int[][] submeshTris = new int[0][];

		private BoneWeight[] boneWeights = new BoneWeight[0];

		private GameObject[] empty = new GameObject[0];

		private int[] emptyIDs = new int[0];

		public override MB2_TextureBakeResults textureBakeResults
		{
			set
			{
				if (mbDynamicObjectsInCombinedMesh.Count > 0 && _textureBakeResults != value && _textureBakeResults != null && LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("If material bake result is changed then objects currently in combined mesh may be invalid.");
				}
				_textureBakeResults = value;
			}
		}

		public override MB_RenderType renderType
		{
			set
			{
				if (value == MB_RenderType.skinnedMeshRenderer && _renderType == MB_RenderType.meshRenderer && boneWeights.Length != verts.Length)
				{
					UnityEngine.Debug.LogError("Can't set the render type to SkinnedMeshRenderer without clearing the mesh first. Try deleteing the CombinedMesh scene object.");
				}
				_renderType = value;
			}
		}

		public override GameObject resultSceneObject
		{
			set
			{
				if (_resultSceneObject != value)
				{
					_targetRenderer = null;
					if (_mesh != null && _LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning("Result Scene Object was changed when this mesh baker component had a reference to a mesh. If mesh is being used by another object make sure to reset the mesh to none before baking to avoid overwriting the other mesh.");
					}
				}
				_resultSceneObject = value;
			}
		}

		private MB_DynamicGameObject instance2Combined_MapGet(int gameObjectID)
		{
			return _instance2combined_map[gameObjectID];
		}

		private void instance2Combined_MapAdd(int gameObjectID, MB_DynamicGameObject dgo)
		{
			_instance2combined_map.Add(gameObjectID, dgo);
		}

		private void instance2Combined_MapRemove(int gameObjectID)
		{
			_instance2combined_map.Remove(gameObjectID);
		}

		private bool instance2Combined_MapTryGetValue(int gameObjectID, out MB_DynamicGameObject dgo)
		{
			return _instance2combined_map.TryGetValue(gameObjectID, out dgo);
		}

		private int instance2Combined_MapCount()
		{
			return _instance2combined_map.Count;
		}

		private void instance2Combined_MapClear()
		{
			_instance2combined_map.Clear();
		}

		private bool instance2Combined_MapContainsKey(int gameObjectID)
		{
			return _instance2combined_map.ContainsKey(gameObjectID);
		}

		public override int GetNumObjectsInCombined()
		{
			return mbDynamicObjectsInCombinedMesh.Count;
		}

		public override List<GameObject> GetObjectsInCombined()
		{
			List<GameObject> list = new List<GameObject>();
			list.AddRange(objectsInCombinedMesh);
			return list;
		}

		public Mesh GetMesh()
		{
			if (_mesh == null)
			{
				_mesh = new Mesh();
			}
			return _mesh;
		}

		public Transform[] GetBones()
		{
			return bones;
		}

		public override int GetLightmapIndex()
		{
			if (lightmapOption == MB2_LightmapOptions.generate_new_UV2_layout || lightmapOption == MB2_LightmapOptions.preserve_current_lightmapping)
			{
				return lightmapIndex;
			}
			return -1;
		}

		public override int GetNumVerticesFor(GameObject go)
		{
			return GetNumVerticesFor(go.GetInstanceID());
		}

		public override int GetNumVerticesFor(int instanceID)
		{
			if (instance2Combined_MapTryGetValue(instanceID, out var dgo))
			{
				return dgo.numVerts;
			}
			return -1;
		}

		public override Dictionary<MBBlendShapeKey, MBBlendShapeValue> BuildSourceBlendShapeToCombinedIndexMap()
		{
			Dictionary<MBBlendShapeKey, MBBlendShapeValue> dictionary = new Dictionary<MBBlendShapeKey, MBBlendShapeValue>();
			for (int i = 0; i < blendShapes.Length; i++)
			{
				MBBlendShapeValue mBBlendShapeValue = new MBBlendShapeValue();
				mBBlendShapeValue.combinedMeshGameObject = _targetRenderer.gameObject;
				mBBlendShapeValue.blendShapeIndex = i;
				dictionary.Add(new MBBlendShapeKey(blendShapes[i].gameObjectID, blendShapes[i].indexInSource), mBBlendShapeValue);
			}
			return dictionary;
		}

		private void _initialize()
		{
			if (mbDynamicObjectsInCombinedMesh.Count == 0)
			{
				lightmapIndex = -1;
			}
			if (_mesh == null)
			{
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug("_initialize Creating new Mesh");
				}
				_mesh = GetMesh();
			}
			if (instance2Combined_MapCount() != objectsInCombinedMesh.Count)
			{
				instance2Combined_MapClear();
				for (int i = 0; i < mbDynamicObjectsInCombinedMesh.Count; i++)
				{
					if (mbDynamicObjectsInCombinedMesh[i] != null)
					{
						if (objectsInCombinedMesh.Count == mbDynamicObjectsInCombinedMesh.Count && objectsInCombinedMesh[i] != null)
						{
							instance2Combined_MapAdd(objectsInCombinedMesh[i].GetInstanceID(), mbDynamicObjectsInCombinedMesh[i]);
						}
						else
						{
							instance2Combined_MapAdd(mbDynamicObjectsInCombinedMesh[i].instanceID, mbDynamicObjectsInCombinedMesh[i]);
						}
					}
				}
				boneWeights = _mesh.boneWeights;
				submeshTris = new int[_mesh.subMeshCount][];
				for (int j = 0; j < submeshTris.Length; j++)
				{
					submeshTris[j] = _mesh.GetTriangles(j);
				}
			}
			if (mbDynamicObjectsInCombinedMesh.Count <= 0 || mbDynamicObjectsInCombinedMesh[0].indexesOfBonesUsed.Length != 0 || renderType != MB_RenderType.skinnedMeshRenderer || boneWeights.Length == 0)
			{
				return;
			}
			for (int k = 0; k < mbDynamicObjectsInCombinedMesh.Count; k++)
			{
				MB_DynamicGameObject mB_DynamicGameObject = mbDynamicObjectsInCombinedMesh[k];
				HashSet<int> hashSet = new HashSet<int>();
				for (int l = mB_DynamicGameObject.vertIdx; l < mB_DynamicGameObject.vertIdx + mB_DynamicGameObject.numVerts; l++)
				{
					if (boneWeights[l].weight0 > 0f)
					{
						hashSet.Add(boneWeights[l].boneIndex0);
					}
					if (boneWeights[l].weight1 > 0f)
					{
						hashSet.Add(boneWeights[l].boneIndex1);
					}
					if (boneWeights[l].weight2 > 0f)
					{
						hashSet.Add(boneWeights[l].boneIndex2);
					}
					if (boneWeights[l].weight3 > 0f)
					{
						hashSet.Add(boneWeights[l].boneIndex3);
					}
				}
				mB_DynamicGameObject.indexesOfBonesUsed = new int[hashSet.Count];
				hashSet.CopyTo(mB_DynamicGameObject.indexesOfBonesUsed);
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Baker used old systems that duplicated bones. Upgrading to new system by building indexesOfBonesUsed");
			}
		}

		private bool _collectMaterialTriangles(Mesh m, MB_DynamicGameObject dgo, Material[] sharedMaterials, OrderedDictionary sourceMats2submeshIdx_map)
		{
			int num = m.subMeshCount;
			if (sharedMaterials.Length < num)
			{
				num = sharedMaterials.Length;
			}
			dgo._submeshTris = new int[num][];
			dgo.targetSubmeshIdxs = new int[num];
			for (int i = 0; i < num; i++)
			{
				if (textureBakeResults.doMultiMaterial)
				{
					if (!sourceMats2submeshIdx_map.Contains(sharedMaterials[i]))
					{
						UnityEngine.Debug.LogError("Object " + dgo.name + " has a material that was not found in the result materials maping. " + sharedMaterials[i]);
						return false;
					}
					dgo.targetSubmeshIdxs[i] = (int)sourceMats2submeshIdx_map[sharedMaterials[i]];
				}
				else
				{
					dgo.targetSubmeshIdxs[i] = 0;
				}
				dgo._submeshTris[i] = m.GetTriangles(i);
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug("Collecting triangles for: " + dgo.name + " submesh:" + i + " maps to submesh:" + dgo.targetSubmeshIdxs[i] + " added:" + dgo._submeshTris[i].Length, LOG_LEVEL);
				}
			}
			return true;
		}

		private bool _collectOutOfBoundsUVRects2(Mesh m, MB_DynamicGameObject dgo, Material[] sharedMaterials, OrderedDictionary sourceMats2submeshIdx_map, Dictionary<int, MB_Utility.MeshAnalysisResult[]> meshAnalysisResults, MeshChannelsCache meshChannelCache)
		{
			if (textureBakeResults == null)
			{
				UnityEngine.Debug.LogError("Need to bake textures into combined material");
				return false;
			}
			if (meshAnalysisResults.TryGetValue(m.GetInstanceID(), out var value))
			{
				dgo.obUVRects = new Rect[sharedMaterials.Length];
				for (int i = 0; i < dgo.obUVRects.Length; i++)
				{
					dgo.obUVRects[i] = value[i].uvRect;
				}
			}
			else
			{
				int subMeshCount = m.subMeshCount;
				int num = subMeshCount;
				if (sharedMaterials.Length < subMeshCount)
				{
					num = sharedMaterials.Length;
				}
				dgo.obUVRects = new Rect[num];
				value = new MB_Utility.MeshAnalysisResult[subMeshCount];
				for (int j = 0; j < subMeshCount; j++)
				{
					MB_Utility.hasOutOfBoundsUVs(meshChannelCache.GetUv0Raw(m), m, ref value[j], j);
					Rect uvRect = value[j].uvRect;
					if (j < num)
					{
						dgo.obUVRects[j] = uvRect;
					}
				}
				meshAnalysisResults.Add(m.GetInstanceID(), value);
			}
			return true;
		}

		private bool _validateTextureBakeResults()
		{
			if (textureBakeResults == null)
			{
				UnityEngine.Debug.LogError("Material Bake Results is null. Can't combine meshes.");
				return false;
			}
			if ((textureBakeResults.materialsAndUVRects == null || textureBakeResults.materialsAndUVRects.Length == 0) && (textureBakeResults.materials == null || textureBakeResults.materials.Length == 0))
			{
				UnityEngine.Debug.LogError("Material Bake Results has no materials in material to sourceUVRect map. Try baking materials. Can't combine meshes.");
				return false;
			}
			if (textureBakeResults.doMultiMaterial)
			{
				if (textureBakeResults.resultMaterials == null || textureBakeResults.resultMaterials.Length == 0)
				{
					UnityEngine.Debug.LogError("Material Bake Results has no result materials. Try baking materials. Can't combine meshes.");
					return false;
				}
			}
			else if (textureBakeResults.resultMaterial == null)
			{
				UnityEngine.Debug.LogError("Material Bake Results has no result material. Try baking materials. Can't combine meshes.");
				return false;
			}
			return true;
		}

		private bool _validateMeshFlags()
		{
			if (mbDynamicObjectsInCombinedMesh.Count > 0 && ((!_doNorm && doNorm) || (!_doTan && doTan) || (!_doCol && doCol) || (!_doUV && doUV) || (!_doUV3 && doUV3) || (!_doUV4 && doUV4)))
			{
				UnityEngine.Debug.LogError("The channels have changed. There are already objects in the combined mesh that were added with a different set of channels.");
				return false;
			}
			_doNorm = doNorm;
			_doTan = doTan;
			_doCol = doCol;
			_doUV = doUV;
			_doUV3 = doUV3;
			_doUV4 = doUV4;
			return true;
		}

		private bool _showHide(GameObject[] goToShow, GameObject[] goToHide)
		{
			if (goToShow == null)
			{
				goToShow = empty;
			}
			if (goToHide == null)
			{
				goToHide = empty;
			}
			_initialize();
			for (int i = 0; i < goToHide.Length; i++)
			{
				if (!instance2Combined_MapContainsKey(goToHide[i].GetInstanceID()))
				{
					if (LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning(string.Concat("Trying to hide an object ", goToHide[i], " that is not in combined mesh. Did you initially bake with 'clear buffers after bake' enabled?"));
					}
					return false;
				}
			}
			for (int j = 0; j < goToShow.Length; j++)
			{
				if (!instance2Combined_MapContainsKey(goToShow[j].GetInstanceID()))
				{
					if (LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning(string.Concat("Trying to show an object ", goToShow[j], " that is not in combined mesh. Did you initially bake with 'clear buffers after bake' enabled?"));
					}
					return false;
				}
			}
			for (int k = 0; k < goToHide.Length; k++)
			{
				_instance2combined_map[goToHide[k].GetInstanceID()].show = false;
			}
			for (int l = 0; l < goToShow.Length; l++)
			{
				_instance2combined_map[goToShow[l].GetInstanceID()].show = true;
			}
			return true;
		}

		private bool _addToCombined(GameObject[] goToAdd, int[] goToDelete, bool disableRendererInSource)
		{
			if (!_validateTextureBakeResults())
			{
				return false;
			}
			if (!_validateMeshFlags())
			{
				return false;
			}
			if (!ValidateTargRendererAndMeshAndResultSceneObj())
			{
				return false;
			}
			if (outputOption != MB2_OutputOptions.bakeMeshAssetsInPlace && renderType == MB_RenderType.skinnedMeshRenderer)
			{
				if (_targetRenderer == null || !(_targetRenderer is SkinnedMeshRenderer))
				{
					UnityEngine.Debug.LogError("Target renderer must be set and must be a SkinnedMeshRenderer");
					return false;
				}
				if (((SkinnedMeshRenderer)targetRenderer).sharedMesh != _mesh)
				{
					UnityEngine.Debug.LogError("The combined mesh was not assigned to the targetRenderer. Try using buildSceneMeshObject to set up the combined mesh correctly");
				}
			}
			if (_doBlendShapes && renderType != MB_RenderType.skinnedMeshRenderer)
			{
				UnityEngine.Debug.LogError("If doBlendShapes is set then RenderType must be skinnedMeshRenderer.");
				UnityEngine.Debug.LogError("Copying blend shapes does not work in versions of Unity < 5");
				return false;
			}
			GameObject[] _goToAdd;
			if (goToAdd == null)
			{
				_goToAdd = empty;
			}
			else
			{
				_goToAdd = (GameObject[])goToAdd.Clone();
			}
			int[] array = ((goToDelete != null) ? ((int[])goToDelete.Clone()) : emptyIDs);
			if (_mesh == null)
			{
				DestroyMesh();
			}
			MB2_TextureBakeResults.Material2AtlasRectangleMapper material2AtlasRectangleMapper = new MB2_TextureBakeResults.Material2AtlasRectangleMapper(textureBakeResults);
			_initialize();
			if (_mesh.vertexCount > 0 && _instance2combined_map.Count == 0)
			{
				UnityEngine.Debug.LogWarning("There were vertices in the combined mesh but nothing in the MeshBaker buffers. If you are trying to bake in the editor and modify at runtime, make sure 'Clear Buffers After Bake' is unchecked.");
			}
			int num = 1;
			if (textureBakeResults.doMultiMaterial)
			{
				num = textureBakeResults.resultMaterials.Length;
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				MB2_Log.LogDebug("==== Calling _addToCombined objs adding:" + _goToAdd.Length + " objs deleting:" + array.Length + " fixOutOfBounds:" + textureBakeResults.fixOutOfBoundsUVs.ToString() + " doMultiMaterial:" + textureBakeResults.doMultiMaterial.ToString() + " disableRenderersInSource:" + disableRendererInSource.ToString(), LOG_LEVEL);
			}
			OrderedDictionary orderedDictionary = null;
			if (textureBakeResults.doMultiMaterial)
			{
				orderedDictionary = new OrderedDictionary();
				for (int j = 0; j < num; j++)
				{
					MB_MultiMaterial mB_MultiMaterial = textureBakeResults.resultMaterials[j];
					for (int k = 0; k < mB_MultiMaterial.sourceMaterials.Count; k++)
					{
						if (mB_MultiMaterial.sourceMaterials[k] == null)
						{
							UnityEngine.Debug.LogError("Found null material in source materials for combined mesh materials " + j);
							return false;
						}
						if (!orderedDictionary.Contains(mB_MultiMaterial.sourceMaterials[k]))
						{
							orderedDictionary.Add(mB_MultiMaterial.sourceMaterials[k], j);
						}
					}
				}
			}
			if (submeshTris.Length != num)
			{
				submeshTris = new int[num][];
				for (int l = 0; l < submeshTris.Length; l++)
				{
					submeshTris[l] = new int[0];
				}
			}
			int num2 = 0;
			int[] array2 = new int[num];
			int num3 = 0;
			List<MB_DynamicGameObject>[] array3 = null;
			HashSet<int> hashSet = new HashSet<int>();
			HashSet<BoneAndBindpose> hashSet2 = new HashSet<BoneAndBindpose>();
			if (renderType == MB_RenderType.skinnedMeshRenderer && array.Length != 0)
			{
				array3 = _buildBoneIdx2dgoMap();
			}
			for (int m = 0; m < array.Length; m++)
			{
				if (instance2Combined_MapTryGetValue(array[m], out var dgo))
				{
					num2 += dgo.numVerts;
					num3 += dgo.numBlendShapes;
					if (renderType == MB_RenderType.skinnedMeshRenderer)
					{
						for (int n = 0; n < dgo.indexesOfBonesUsed.Length; n++)
						{
							if (array3[dgo.indexesOfBonesUsed[n]].Contains(dgo))
							{
								array3[dgo.indexesOfBonesUsed[n]].Remove(dgo);
								if (array3[dgo.indexesOfBonesUsed[n]].Count == 0)
								{
									hashSet.Add(dgo.indexesOfBonesUsed[n]);
								}
							}
						}
					}
					for (int num4 = 0; num4 < dgo.submeshNumTris.Length; num4++)
					{
						array2[num4] += dgo.submeshNumTris[num4];
					}
				}
				else if (LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Trying to delete an object that is not in combined mesh");
				}
			}
			List<MB_DynamicGameObject> list = new List<MB_DynamicGameObject>();
			Dictionary<int, MB_Utility.MeshAnalysisResult[]> dictionary = new Dictionary<int, MB_Utility.MeshAnalysisResult[]>();
			MeshChannelsCache meshChannelsCache = new MeshChannelsCache(this);
			int num5 = 0;
			int[] array4 = new int[num];
			int num6 = 0;
			Dictionary<Transform, int> dictionary2 = new Dictionary<Transform, int>();
			for (int num7 = 0; num7 < bones.Length; num7++)
			{
				dictionary2.Add(bones[num7], num7);
			}
			int i;
			for (i = 0; i < _goToAdd.Length; i++)
			{
				if (!instance2Combined_MapContainsKey(_goToAdd[i].GetInstanceID()) || Array.FindIndex(array, (int o) => o == _goToAdd[i].GetInstanceID()) != -1)
				{
					MB_DynamicGameObject mB_DynamicGameObject = new MB_DynamicGameObject();
					GameObject gameObject = _goToAdd[i];
					Material[] gOMaterials = MB_Utility.GetGOMaterials(gameObject);
					if (gOMaterials == null)
					{
						UnityEngine.Debug.LogError("Object " + gameObject.name + " does not have a Renderer");
						_goToAdd[i] = null;
						return false;
					}
					Mesh mesh = MB_Utility.GetMesh(gameObject);
					if (mesh == null)
					{
						UnityEngine.Debug.LogError("Object " + gameObject.name + " MeshFilter or SkinedMeshRenderer had no mesh");
						_goToAdd[i] = null;
						return false;
					}
					if (MBVersion.IsRunningAndMeshNotReadWriteable(mesh))
					{
						UnityEngine.Debug.LogError("Object " + gameObject.name + " Mesh Importer has read/write flag set to 'false'. This needs to be set to 'true' in order to read data from this mesh.");
						_goToAdd[i] = null;
						return false;
					}
					Rect[] array5 = new Rect[gOMaterials.Length];
					Rect[] array6 = new Rect[gOMaterials.Length];
					Rect[] array7 = new Rect[gOMaterials.Length];
					string errorMsg = "";
					for (int num8 = 0; num8 < gOMaterials.Length; num8++)
					{
						if (!material2AtlasRectangleMapper.TryMapMaterialToUVRect(gOMaterials[num8], mesh, num8, meshChannelsCache, dictionary, out array5[num8], out array6[num8], out array7[num8], ref errorMsg, LOG_LEVEL))
						{
							UnityEngine.Debug.LogError(errorMsg);
							_goToAdd[i] = null;
							return false;
						}
					}
					if (!(_goToAdd[i] != null))
					{
						continue;
					}
					list.Add(mB_DynamicGameObject);
					mB_DynamicGameObject.name = $"{_goToAdd[i].ToString()} {_goToAdd[i].GetInstanceID()}";
					mB_DynamicGameObject.instanceID = _goToAdd[i].GetInstanceID();
					mB_DynamicGameObject.uvRects = array5;
					mB_DynamicGameObject.encapsulatingRect = array6;
					mB_DynamicGameObject.sourceMaterialTiling = array7;
					mB_DynamicGameObject.numVerts = mesh.vertexCount;
					if (_doBlendShapes)
					{
						mB_DynamicGameObject.numBlendShapes = mesh.blendShapeCount;
					}
					Renderer renderer = MB_Utility.GetRenderer(gameObject);
					if (renderType == MB_RenderType.skinnedMeshRenderer)
					{
						_CollectBonesToAddForDGO(mB_DynamicGameObject, dictionary2, hashSet, hashSet2, renderer, meshChannelsCache);
					}
					if (lightmapIndex == -1)
					{
						lightmapIndex = renderer.lightmapIndex;
					}
					if (lightmapOption == MB2_LightmapOptions.preserve_current_lightmapping)
					{
						if (lightmapIndex != renderer.lightmapIndex && LOG_LEVEL >= MB2_LogLevel.warn)
						{
							UnityEngine.Debug.LogWarning("Object " + gameObject.name + " has a different lightmap index. Lightmapping will not work.");
						}
						if (!MBVersion.GetActive(gameObject) && LOG_LEVEL >= MB2_LogLevel.warn)
						{
							UnityEngine.Debug.LogWarning("Object " + gameObject.name + " is inactive. Can only get lightmap index of active objects.");
						}
						if (renderer.lightmapIndex == -1 && LOG_LEVEL >= MB2_LogLevel.warn)
						{
							UnityEngine.Debug.LogWarning("Object " + gameObject.name + " does not have an index to a lightmap.");
						}
					}
					mB_DynamicGameObject.lightmapIndex = renderer.lightmapIndex;
					mB_DynamicGameObject.lightmapTilingOffset = MBVersion.GetLightmapTilingOffset(renderer);
					if (!_collectMaterialTriangles(mesh, mB_DynamicGameObject, gOMaterials, orderedDictionary))
					{
						return false;
					}
					mB_DynamicGameObject.meshSize = renderer.bounds.size;
					mB_DynamicGameObject.submeshNumTris = new int[num];
					mB_DynamicGameObject.submeshTriIdxs = new int[num];
					if (textureBakeResults.fixOutOfBoundsUVs && !_collectOutOfBoundsUVRects2(mesh, mB_DynamicGameObject, gOMaterials, orderedDictionary, dictionary, meshChannelsCache))
					{
						return false;
					}
					num5 += mB_DynamicGameObject.numVerts;
					num6 += mB_DynamicGameObject.numBlendShapes;
					for (int num9 = 0; num9 < mB_DynamicGameObject._submeshTris.Length; num9++)
					{
						array4[mB_DynamicGameObject.targetSubmeshIdxs[num9]] += mB_DynamicGameObject._submeshTris[num9].Length;
					}
					mB_DynamicGameObject.invertTriangles = IsMirrored(gameObject.transform.localToWorldMatrix);
				}
				else
				{
					if (LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning("Object " + _goToAdd[i].name + " has already been added");
					}
					_goToAdd[i] = null;
				}
			}
			for (int num10 = 0; num10 < _goToAdd.Length; num10++)
			{
				if (_goToAdd[num10] != null && disableRendererInSource)
				{
					MB_Utility.DisableRendererInSource(_goToAdd[num10]);
					if (LOG_LEVEL == MB2_LogLevel.trace)
					{
						UnityEngine.Debug.Log("Disabling renderer on " + _goToAdd[num10].name + " id=" + _goToAdd[num10].GetInstanceID());
					}
				}
			}
			int num11 = verts.Length + num5 - num2;
			int num12 = bindPoses.Length + hashSet2.Count - hashSet.Count;
			int[] array8 = new int[num];
			int num13 = blendShapes.Length + num6 - num3;
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Verts adding:" + num5 + " deleting:" + num2 + " submeshes:" + array8.Length + " bones:" + num12 + " blendShapes:" + num13);
			}
			for (int num14 = 0; num14 < array8.Length; num14++)
			{
				array8[num14] = submeshTris[num14].Length + array4[num14] - array2[num14];
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug("    submesh :" + num14 + " already contains:" + submeshTris[num14].Length + " tris to be Added:" + array4[num14] + " tris to be Deleted:" + array2[num14]);
				}
			}
			if (num11 > 65534)
			{
				UnityEngine.Debug.LogError("Cannot add objects. Resulting mesh will have more than 64k vertices. Try using a Multi-MeshBaker component. This will split the combined mesh into several meshes. You don't have to re-configure the MB2_TextureBaker. Just remove the MB2_MeshBaker component and add a MB2_MultiMeshBaker component.");
				return false;
			}
			Vector3[] destinationArray = null;
			Vector4[] destinationArray2 = null;
			Vector2[] destinationArray3 = null;
			Vector2[] destinationArray4 = null;
			Vector2[] destinationArray5 = null;
			Vector2[] destinationArray6 = null;
			Color[] destinationArray7 = null;
			MBBlendShape[] array9 = null;
			Vector3[] destinationArray8 = new Vector3[num11];
			if (_doNorm)
			{
				destinationArray = new Vector3[num11];
			}
			if (_doTan)
			{
				destinationArray2 = new Vector4[num11];
			}
			if (_doUV)
			{
				destinationArray3 = new Vector2[num11];
			}
			if (_doUV3)
			{
				destinationArray5 = new Vector2[num11];
			}
			if (_doUV4)
			{
				destinationArray6 = new Vector2[num11];
			}
			if (doUV2())
			{
				destinationArray4 = new Vector2[num11];
			}
			if (_doCol)
			{
				destinationArray7 = new Color[num11];
			}
			if (_doBlendShapes)
			{
				array9 = new MBBlendShape[num13];
			}
			BoneWeight[] array10 = new BoneWeight[num11];
			Matrix4x4[] array11 = new Matrix4x4[num12];
			Transform[] array12 = new Transform[num12];
			int[][] array13 = null;
			array13 = new int[num][];
			for (int num15 = 0; num15 < array13.Length; num15++)
			{
				array13[num15] = new int[array8[num15]];
			}
			for (int num16 = 0; num16 < array.Length; num16++)
			{
				MB_DynamicGameObject dgo2 = null;
				if (instance2Combined_MapTryGetValue(array[num16], out dgo2))
				{
					dgo2._beingDeleted = true;
				}
			}
			mbDynamicObjectsInCombinedMesh.Sort();
			int num17 = 0;
			int num18 = 0;
			int[] array14 = new int[num];
			int num19 = 0;
			for (int num20 = 0; num20 < mbDynamicObjectsInCombinedMesh.Count; num20++)
			{
				MB_DynamicGameObject mB_DynamicGameObject2 = mbDynamicObjectsInCombinedMesh[num20];
				if (!mB_DynamicGameObject2._beingDeleted)
				{
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug("Copying obj in combined arrays idx:" + num20, LOG_LEVEL);
					}
					Array.Copy(verts, mB_DynamicGameObject2.vertIdx, destinationArray8, num17, mB_DynamicGameObject2.numVerts);
					if (_doNorm)
					{
						Array.Copy(normals, mB_DynamicGameObject2.vertIdx, destinationArray, num17, mB_DynamicGameObject2.numVerts);
					}
					if (_doTan)
					{
						Array.Copy(tangents, mB_DynamicGameObject2.vertIdx, destinationArray2, num17, mB_DynamicGameObject2.numVerts);
					}
					if (_doUV)
					{
						Array.Copy(uvs, mB_DynamicGameObject2.vertIdx, destinationArray3, num17, mB_DynamicGameObject2.numVerts);
					}
					if (_doUV3)
					{
						Array.Copy(uv3s, mB_DynamicGameObject2.vertIdx, destinationArray5, num17, mB_DynamicGameObject2.numVerts);
					}
					if (_doUV4)
					{
						Array.Copy(uv4s, mB_DynamicGameObject2.vertIdx, destinationArray6, num17, mB_DynamicGameObject2.numVerts);
					}
					if (doUV2())
					{
						Array.Copy(uv2s, mB_DynamicGameObject2.vertIdx, destinationArray4, num17, mB_DynamicGameObject2.numVerts);
					}
					if (_doCol)
					{
						Array.Copy(colors, mB_DynamicGameObject2.vertIdx, destinationArray7, num17, mB_DynamicGameObject2.numVerts);
					}
					if (_doBlendShapes)
					{
						Array.Copy(blendShapes, mB_DynamicGameObject2.blendShapeIdx, array9, num18, mB_DynamicGameObject2.numBlendShapes);
					}
					if (renderType == MB_RenderType.skinnedMeshRenderer)
					{
						Array.Copy(boneWeights, mB_DynamicGameObject2.vertIdx, array10, num17, mB_DynamicGameObject2.numVerts);
					}
					for (int num21 = 0; num21 < num; num21++)
					{
						int[] array15 = submeshTris[num21];
						int num22 = mB_DynamicGameObject2.submeshTriIdxs[num21];
						int num23 = mB_DynamicGameObject2.submeshNumTris[num21];
						if (LOG_LEVEL >= MB2_LogLevel.debug)
						{
							MB2_Log.LogDebug("    Adjusting submesh triangles submesh:" + num21 + " startIdx:" + num22 + " num:" + num23, LOG_LEVEL);
						}
						for (int num24 = num22; num24 < num22 + num23; num24++)
						{
							array15[num24] -= num19;
						}
						Array.Copy(array15, num22, array13[num21], array14[num21], num23);
					}
					mB_DynamicGameObject2.vertIdx = num17;
					mB_DynamicGameObject2.blendShapeIdx = num18;
					for (int num25 = 0; num25 < array14.Length; num25++)
					{
						mB_DynamicGameObject2.submeshTriIdxs[num25] = array14[num25];
						array14[num25] += mB_DynamicGameObject2.submeshNumTris[num25];
					}
					num18 += mB_DynamicGameObject2.numBlendShapes;
					num17 += mB_DynamicGameObject2.numVerts;
				}
				else
				{
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug("Not copying obj: " + num20, LOG_LEVEL);
					}
					num19 += mB_DynamicGameObject2.numVerts;
				}
			}
			if (renderType == MB_RenderType.skinnedMeshRenderer)
			{
				_CopyBonesWeAreKeepingToNewBonesArrayAndAdjustBWIndexes(hashSet, hashSet2, array12, array11, array10, num2);
			}
			for (int num26 = mbDynamicObjectsInCombinedMesh.Count - 1; num26 >= 0; num26--)
			{
				if (mbDynamicObjectsInCombinedMesh[num26]._beingDeleted)
				{
					instance2Combined_MapRemove(mbDynamicObjectsInCombinedMesh[num26].instanceID);
					objectsInCombinedMesh.RemoveAt(num26);
					mbDynamicObjectsInCombinedMesh.RemoveAt(num26);
				}
			}
			verts = destinationArray8;
			if (_doNorm)
			{
				normals = destinationArray;
			}
			if (_doTan)
			{
				tangents = destinationArray2;
			}
			if (_doUV)
			{
				uvs = destinationArray3;
			}
			if (_doUV3)
			{
				uv3s = destinationArray5;
			}
			if (_doUV4)
			{
				uv4s = destinationArray6;
			}
			if (doUV2())
			{
				uv2s = destinationArray4;
			}
			if (_doCol)
			{
				colors = destinationArray7;
			}
			if (_doBlendShapes)
			{
				blendShapes = array9;
			}
			if (renderType == MB_RenderType.skinnedMeshRenderer)
			{
				boneWeights = array10;
			}
			int num27 = bones.Length - hashSet.Count;
			bindPoses = array11;
			bones = array12;
			submeshTris = array13;
			int num28 = 0;
			foreach (BoneAndBindpose item in hashSet2)
			{
				array12[num27 + num28] = item.bone;
				array11[num27 + num28] = item.bindPose;
				num28++;
			}
			for (int num29 = 0; num29 < list.Count; num29++)
			{
				MB_DynamicGameObject mB_DynamicGameObject3 = list[num29];
				GameObject gameObject2 = _goToAdd[num29];
				int num30 = num17;
				int index = num18;
				Mesh mesh2 = MB_Utility.GetMesh(gameObject2);
				Matrix4x4 localToWorldMatrix = gameObject2.transform.localToWorldMatrix;
				Matrix4x4 matrix4x = localToWorldMatrix;
				float num32 = (matrix4x[2, 3] = 0f);
				float value = (matrix4x[1, 3] = num32);
				matrix4x[0, 3] = value;
				destinationArray8 = meshChannelsCache.GetVertices(mesh2);
				Vector3[] array16 = null;
				Vector4[] array17 = null;
				if (_doNorm)
				{
					array16 = meshChannelsCache.GetNormals(mesh2);
				}
				if (_doTan)
				{
					array17 = meshChannelsCache.GetTangents(mesh2);
				}
				if (renderType != MB_RenderType.skinnedMeshRenderer)
				{
					for (int num34 = 0; num34 < destinationArray8.Length; num34++)
					{
						int num35 = num30 + num34;
						verts[num30 + num34] = localToWorldMatrix.MultiplyPoint3x4(destinationArray8[num34]);
						if (_doNorm)
						{
							normals[num35] = matrix4x.MultiplyPoint3x4(array16[num34]);
							normals[num35] = normals[num35].normalized;
						}
						if (_doTan)
						{
							float w = array17[num34].w;
							Vector3 vector = matrix4x.MultiplyPoint3x4(array17[num34]);
							vector.Normalize();
							tangents[num35] = vector;
							tangents[num35].w = w;
						}
					}
				}
				else
				{
					if (_doNorm)
					{
						array16.CopyTo(normals, num30);
					}
					if (_doTan)
					{
						array17.CopyTo(tangents, num30);
					}
					destinationArray8.CopyTo(verts, num30);
				}
				int subMeshCount = mesh2.subMeshCount;
				if (mB_DynamicGameObject3.uvRects.Length < subMeshCount)
				{
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug("Mesh " + mB_DynamicGameObject3.name + " has more submeshes than materials");
					}
					subMeshCount = mB_DynamicGameObject3.uvRects.Length;
				}
				else if (mB_DynamicGameObject3.uvRects.Length > subMeshCount && LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Mesh " + mB_DynamicGameObject3.name + " has fewer submeshes than materials");
				}
				if (_doUV)
				{
					_copyAndAdjustUVsFromMesh(mB_DynamicGameObject3, mesh2, num30, meshChannelsCache);
				}
				if (doUV2())
				{
					_copyAndAdjustUV2FromMesh(mB_DynamicGameObject3, mesh2, num30, meshChannelsCache);
				}
				if (_doUV3)
				{
					destinationArray5 = meshChannelsCache.GetUv3(mesh2);
					destinationArray5.CopyTo(uv3s, num30);
				}
				if (_doUV4)
				{
					destinationArray6 = meshChannelsCache.GetUv4(mesh2);
					destinationArray6.CopyTo(uv4s, num30);
				}
				if (_doCol)
				{
					destinationArray7 = meshChannelsCache.GetColors(mesh2);
					destinationArray7.CopyTo(colors, num30);
				}
				if (_doBlendShapes)
				{
					array9 = meshChannelsCache.GetBlendShapes(mesh2, mB_DynamicGameObject3.instanceID);
					array9.CopyTo(blendShapes, index);
				}
				if (renderType == MB_RenderType.skinnedMeshRenderer)
				{
					Renderer renderer2 = MB_Utility.GetRenderer(gameObject2);
					_AddBonesToNewBonesArrayAndAdjustBWIndexes(mB_DynamicGameObject3, renderer2, num30, array12, array10, meshChannelsCache);
				}
				for (int num36 = 0; num36 < array14.Length; num36++)
				{
					mB_DynamicGameObject3.submeshTriIdxs[num36] = array14[num36];
				}
				for (int num37 = 0; num37 < mB_DynamicGameObject3._submeshTris.Length; num37++)
				{
					int[] array18 = mB_DynamicGameObject3._submeshTris[num37];
					for (int num38 = 0; num38 < array18.Length; num38++)
					{
						array18[num38] += num30;
					}
					if (mB_DynamicGameObject3.invertTriangles)
					{
						for (int num39 = 0; num39 < array18.Length; num39 += 3)
						{
							int num40 = array18[num39];
							array18[num39] = array18[num39 + 1];
							array18[num39 + 1] = num40;
						}
					}
					int num41 = mB_DynamicGameObject3.targetSubmeshIdxs[num37];
					array18.CopyTo(submeshTris[num41], array14[num41]);
					mB_DynamicGameObject3.submeshNumTris[num41] += array18.Length;
					array14[num41] += array18.Length;
				}
				mB_DynamicGameObject3.vertIdx = num17;
				mB_DynamicGameObject3.blendShapeIdx = num18;
				instance2Combined_MapAdd(gameObject2.GetInstanceID(), mB_DynamicGameObject3);
				objectsInCombinedMesh.Add(gameObject2);
				mbDynamicObjectsInCombinedMesh.Add(mB_DynamicGameObject3);
				num17 += destinationArray8.Length;
				if (_doBlendShapes)
				{
					num18 += array9.Length;
				}
				for (int num42 = 0; num42 < mB_DynamicGameObject3._submeshTris.Length; num42++)
				{
					mB_DynamicGameObject3._submeshTris[num42] = null;
				}
				mB_DynamicGameObject3._submeshTris = null;
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug("Added to combined:" + mB_DynamicGameObject3.name + " verts:" + destinationArray8.Length + " bindPoses:" + array11.Length, LOG_LEVEL);
				}
			}
			if (lightmapOption == MB2_LightmapOptions.copy_UV2_unchanged_to_separate_rects)
			{
				_copyUV2unchangedToSeparateRects();
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				MB2_Log.LogDebug("===== _addToCombined completed. Verts in buffer: " + verts.Length, LOG_LEVEL);
			}
			return true;
		}

		private void _copyAndAdjustUVsFromMesh(MB_DynamicGameObject dgo, Mesh mesh, int vertsIdx, MeshChannelsCache meshChannelsCache)
		{
			Vector2[] uv0Raw = meshChannelsCache.GetUv0Raw(mesh);
			bool flag = true;
			if (!textureBakeResults.fixOutOfBoundsUVs)
			{
				Rect rect = new Rect(0f, 0f, 1f, 1f);
				bool flag2 = true;
				for (int i = 0; i < textureBakeResults.materialsAndUVRects.Length; i++)
				{
					if (textureBakeResults.materialsAndUVRects[i].atlasRect != rect)
					{
						flag2 = false;
						break;
					}
				}
				if (flag2)
				{
					flag = false;
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						UnityEngine.Debug.Log("All atlases have only one texture in atlas UVs will be copied without adjusting");
					}
				}
			}
			if (flag)
			{
				int[] array = new int[uv0Raw.Length];
				for (int j = 0; j < array.Length; j++)
				{
					array[j] = -1;
				}
				bool flag3 = false;
				for (int k = 0; k < dgo.targetSubmeshIdxs.Length; k++)
				{
					int[] array2 = ((dgo._submeshTris == null) ? mesh.GetTriangles(k) : dgo._submeshTris[k]);
					DRect r = new DRect(dgo.uvRects[k]);
					DRect t = ((!textureBakeResults.fixOutOfBoundsUVs) ? new DRect(0.0, 0.0, 1.0, 1.0) : new DRect(dgo.obUVRects[k]));
					DRect r2 = new DRect(dgo.sourceMaterialTiling[k]);
					DRect t2 = new DRect(dgo.encapsulatingRect[k]);
					DRect r3 = MB3_UVTransformUtility.InverseTransform(ref t2);
					DRect r4 = MB3_UVTransformUtility.InverseTransform(ref t);
					DRect r5 = MB3_UVTransformUtility.CombineTransforms(ref t, ref r2);
					DRect r6 = MB3_UVTransformUtility.CombineTransforms(ref r5, ref r3);
					DRect r7 = MB3_UVTransformUtility.CombineTransforms(ref r4, ref r6);
					Rect rect2 = MB3_UVTransformUtility.CombineTransforms(ref r7, ref r).GetRect();
					foreach (int num in array2)
					{
						if (array[num] == -1)
						{
							array[num] = k;
							Vector2 vector = uv0Raw[num];
							vector.x = rect2.x + vector.x * rect2.width;
							vector.y = rect2.y + vector.y * rect2.height;
							uvs[vertsIdx + num] = vector;
						}
						if (array[num] != k)
						{
							flag3 = true;
						}
					}
				}
				if (flag3 && LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning(dgo.name + "has submeshes which share verticies. Adjusted uvs may not map correctly in combined atlas.");
				}
			}
			else
			{
				uv0Raw.CopyTo(uvs, vertsIdx);
			}
			if (LOG_LEVEL >= MB2_LogLevel.trace)
			{
				UnityEngine.Debug.Log($"_copyAndAdjustUVsFromMesh copied {uv0Raw.Length} verts");
			}
		}

		private void _copyAndAdjustUV2FromMesh(MB_DynamicGameObject dgo, Mesh mesh, int vertsIdx, MeshChannelsCache meshChannelsCache)
		{
			Vector2[] uv = meshChannelsCache.GetUv2(mesh);
			if (lightmapOption == MB2_LightmapOptions.preserve_current_lightmapping)
			{
				Vector4 lightmapTilingOffset = dgo.lightmapTilingOffset;
				Vector2 vector = new Vector2(lightmapTilingOffset.x, lightmapTilingOffset.y);
				Vector2 vector2 = new Vector2(lightmapTilingOffset.z, lightmapTilingOffset.w);
				Vector2 vector3 = default(Vector2);
				for (int i = 0; i < uv.Length; i++)
				{
					vector3.x = vector.x * uv[i].x;
					vector3.y = vector.y * uv[i].y;
					uv2s[vertsIdx + i] = vector2 + vector3;
				}
				if (LOG_LEVEL >= MB2_LogLevel.trace)
				{
					UnityEngine.Debug.Log("_copyAndAdjustUV2FromMesh copied and modify for preserve current lightmapping " + uv.Length);
				}
			}
			else
			{
				uv.CopyTo(uv2s, vertsIdx);
				if (LOG_LEVEL >= MB2_LogLevel.trace)
				{
					UnityEngine.Debug.Log("_copyAndAdjustUV2FromMesh copied without modifying " + uv.Length);
				}
			}
		}

		public override void UpdateSkinnedMeshApproximateBounds()
		{
			UpdateSkinnedMeshApproximateBoundsFromBounds();
		}

		public override void UpdateSkinnedMeshApproximateBoundsFromBones()
		{
			if (outputOption == MB2_OutputOptions.bakeMeshAssetsInPlace)
			{
				if (LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Can't UpdateSkinnedMeshApproximateBounds when output type is bakeMeshAssetsInPlace");
				}
			}
			else if (bones.Length == 0)
			{
				if (verts.Length != 0 && LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("No bones in SkinnedMeshRenderer. Could not UpdateSkinnedMeshApproximateBounds.");
				}
			}
			else if (_targetRenderer == null)
			{
				if (LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Target Renderer is not set. No point in calling UpdateSkinnedMeshApproximateBounds.");
				}
			}
			else if (!_targetRenderer.GetType().Equals(typeof(SkinnedMeshRenderer)))
			{
				if (LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Target Renderer is not a SkinnedMeshRenderer. No point in calling UpdateSkinnedMeshApproximateBounds.");
				}
			}
			else
			{
				MB3_MeshCombiner.UpdateSkinnedMeshApproximateBoundsFromBonesStatic(bones, (SkinnedMeshRenderer)targetRenderer);
			}
		}

		public override void UpdateSkinnedMeshApproximateBoundsFromBounds()
		{
			if (outputOption == MB2_OutputOptions.bakeMeshAssetsInPlace)
			{
				if (LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Can't UpdateSkinnedMeshApproximateBoundsFromBounds when output type is bakeMeshAssetsInPlace");
				}
			}
			else if (verts.Length == 0 || mbDynamicObjectsInCombinedMesh.Count == 0)
			{
				if (verts.Length != 0 && LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Nothing in SkinnedMeshRenderer. Could not UpdateSkinnedMeshApproximateBoundsFromBounds.");
				}
			}
			else if (_targetRenderer == null)
			{
				if (LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Target Renderer is not set. No point in calling UpdateSkinnedMeshApproximateBoundsFromBounds.");
				}
			}
			else if (!_targetRenderer.GetType().Equals(typeof(SkinnedMeshRenderer)))
			{
				if (LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Target Renderer is not a SkinnedMeshRenderer. No point in calling UpdateSkinnedMeshApproximateBoundsFromBounds.");
				}
			}
			else
			{
				MB3_MeshCombiner.UpdateSkinnedMeshApproximateBoundsFromBoundsStatic(objectsInCombinedMesh, (SkinnedMeshRenderer)targetRenderer);
			}
		}

		private int _getNumBones(Renderer r)
		{
			if (renderType == MB_RenderType.skinnedMeshRenderer)
			{
				if (r is SkinnedMeshRenderer)
				{
					return ((SkinnedMeshRenderer)r).bones.Length;
				}
				if (r is MeshRenderer)
				{
					return 1;
				}
				UnityEngine.Debug.LogError("Could not _getNumBones. Object does not have a renderer");
				return 0;
			}
			return 0;
		}

		private Transform[] _getBones(Renderer r)
		{
			return MBVersion.GetBones(r);
		}

		public override void Apply(GenerateUV2Delegate uv2GenerationMethod)
		{
			bool flag = false;
			if (renderType == MB_RenderType.skinnedMeshRenderer)
			{
				flag = true;
			}
			Apply(triangles: true, vertices: true, _doNorm, _doTan, _doUV, doUV2(), _doUV3, _doUV4, doCol, flag, doBlendShapes, uv2GenerationMethod);
		}

		public virtual void ApplyShowHide()
		{
			if (_validationLevel >= MB2_ValidationLevel.quick && !ValidateTargRendererAndMeshAndResultSceneObj())
			{
				return;
			}
			if (_mesh != null)
			{
				if (renderType == MB_RenderType.meshRenderer)
				{
					MBVersion.MeshClear(_mesh, t: true);
					_mesh.vertices = verts;
				}
				int[][] submeshTrisWithShowHideApplied = GetSubmeshTrisWithShowHideApplied();
				if (textureBakeResults.doMultiMaterial)
				{
					_mesh.subMeshCount = submeshTrisWithShowHideApplied.Length;
					for (int i = 0; i < submeshTrisWithShowHideApplied.Length; i++)
					{
						_mesh.SetTriangles(submeshTrisWithShowHideApplied[i], i);
					}
				}
				else
				{
					_mesh.triangles = submeshTrisWithShowHideApplied[0];
				}
				if (LOG_LEVEL >= MB2_LogLevel.trace)
				{
					UnityEngine.Debug.Log("ApplyShowHide");
				}
			}
			else
			{
				UnityEngine.Debug.LogError("Need to add objects to this meshbaker before calling ApplyShowHide");
			}
		}

		public override void Apply(bool triangles, bool vertices, bool normals, bool tangents, bool uvs, bool uv2, bool uv3, bool uv4, bool colors, bool bones = false, bool blendShapesFlag = false, GenerateUV2Delegate uv2GenerationMethod = null)
		{
			if (_validationLevel >= MB2_ValidationLevel.quick && !ValidateTargRendererAndMeshAndResultSceneObj())
			{
				return;
			}
			if (_mesh != null)
			{
				if (LOG_LEVEL >= MB2_LogLevel.trace)
				{
					UnityEngine.Debug.Log($"Apply called tri={triangles} vert={vertices} norm={normals} tan={tangents} uv={uvs} col={colors} uv3={uv3} uv4={uv4} uv2={uv2} bone={bones} blendShape{blendShapes} meshID={_mesh.GetInstanceID()}");
				}
				if (triangles || _mesh.vertexCount != verts.Length)
				{
					if (triangles && !vertices && !normals && !tangents && !uvs && !colors && !uv3 && !uv4 && !uv2 && !bones)
					{
						MBVersion.MeshClear(_mesh, t: true);
					}
					else
					{
						MBVersion.MeshClear(_mesh, t: false);
					}
				}
				if (vertices)
				{
					Vector3[] array = verts;
					if (verts.Length != 0)
					{
						if (_recenterVertsToBoundsCenter && _renderType == MB_RenderType.meshRenderer)
						{
							array = new Vector3[verts.Length];
							Vector3 vector = verts[0];
							Vector3 vector2 = verts[0];
							for (int i = 1; i < verts.Length; i++)
							{
								Vector3 vector3 = verts[i];
								if (vector.x < vector3.x)
								{
									vector.x = vector3.x;
								}
								if (vector.y < vector3.y)
								{
									vector.y = vector3.y;
								}
								if (vector.z < vector3.z)
								{
									vector.z = vector3.z;
								}
								if (vector2.x > vector3.x)
								{
									vector2.x = vector3.x;
								}
								if (vector2.y > vector3.y)
								{
									vector2.y = vector3.y;
								}
								if (vector2.z > vector3.z)
								{
									vector2.z = vector3.z;
								}
							}
							Vector3 vector4 = (vector + vector2) / 2f;
							for (int j = 0; j < verts.Length; j++)
							{
								array[j] = verts[j] - vector4;
							}
							targetRenderer.transform.position = vector4;
						}
						else
						{
							targetRenderer.transform.position = Vector3.zero;
						}
					}
					_mesh.vertices = array;
				}
				if (triangles && (bool)_textureBakeResults)
				{
					if (_textureBakeResults == null)
					{
						UnityEngine.Debug.LogError("Material Bake Result was not set.");
					}
					else
					{
						int[][] submeshTrisWithShowHideApplied = GetSubmeshTrisWithShowHideApplied();
						if (_textureBakeResults.doMultiMaterial)
						{
							_mesh.subMeshCount = submeshTrisWithShowHideApplied.Length;
							for (int k = 0; k < submeshTrisWithShowHideApplied.Length; k++)
							{
								_mesh.SetTriangles(submeshTrisWithShowHideApplied[k], k);
							}
						}
						else
						{
							_mesh.triangles = submeshTrisWithShowHideApplied[0];
						}
					}
				}
				if (normals)
				{
					if (_doNorm)
					{
						_mesh.normals = this.normals;
					}
					else
					{
						UnityEngine.Debug.LogError("normal flag was set in Apply but MeshBaker didn't generate normals");
					}
				}
				if (tangents)
				{
					if (_doTan)
					{
						_mesh.tangents = this.tangents;
					}
					else
					{
						UnityEngine.Debug.LogError("tangent flag was set in Apply but MeshBaker didn't generate tangents");
					}
				}
				if (uvs)
				{
					if (_doUV)
					{
						_mesh.uv = this.uvs;
					}
					else
					{
						UnityEngine.Debug.LogError("uv flag was set in Apply but MeshBaker didn't generate uvs");
					}
				}
				if (colors)
				{
					if (_doCol)
					{
						_mesh.colors = this.colors;
					}
					else
					{
						UnityEngine.Debug.LogError("color flag was set in Apply but MeshBaker didn't generate colors");
					}
				}
				if (uv3)
				{
					if (_doUV3)
					{
						MBVersion.MeshAssignUV3(_mesh, uv3s);
					}
					else
					{
						UnityEngine.Debug.LogError("uv3 flag was set in Apply but MeshBaker didn't generate uv3s");
					}
				}
				if (uv4)
				{
					if (_doUV4)
					{
						MBVersion.MeshAssignUV4(_mesh, uv4s);
					}
					else
					{
						UnityEngine.Debug.LogError("uv4 flag was set in Apply but MeshBaker didn't generate uv4s");
					}
				}
				if (uv2)
				{
					if (doUV2())
					{
						_mesh.uv2 = uv2s;
					}
					else
					{
						UnityEngine.Debug.LogError("uv2 flag was set in Apply but lightmapping option was set to " + lightmapOption);
					}
				}
				bool flag = false;
				if (renderType != MB_RenderType.skinnedMeshRenderer && lightmapOption == MB2_LightmapOptions.generate_new_UV2_layout)
				{
					if (uv2GenerationMethod != null)
					{
						uv2GenerationMethod(_mesh, uv2UnwrappingParamsHardAngle, uv2UnwrappingParamsPackMargin);
						if (LOG_LEVEL >= MB2_LogLevel.trace)
						{
							UnityEngine.Debug.Log("generating new UV2 layout for the combined mesh ");
						}
					}
					else
					{
						UnityEngine.Debug.LogError("No GenerateUV2Delegate method was supplied. UV2 cannot be generated.");
					}
					flag = true;
				}
				else if (renderType == MB_RenderType.skinnedMeshRenderer && lightmapOption == MB2_LightmapOptions.generate_new_UV2_layout && LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("UV2 cannot be generated for SkinnedMeshRenderer objects.");
				}
				if (renderType != MB_RenderType.skinnedMeshRenderer && lightmapOption == MB2_LightmapOptions.generate_new_UV2_layout && !flag)
				{
					UnityEngine.Debug.LogError("Failed to generate new UV2 layout. Only works in editor.");
				}
				if (renderType == MB_RenderType.skinnedMeshRenderer)
				{
					if (verts.Length == 0)
					{
						targetRenderer.enabled = false;
					}
					else
					{
						targetRenderer.enabled = true;
					}
					bool updateWhenOffscreen = ((SkinnedMeshRenderer)targetRenderer).updateWhenOffscreen;
					((SkinnedMeshRenderer)targetRenderer).updateWhenOffscreen = true;
					((SkinnedMeshRenderer)targetRenderer).updateWhenOffscreen = updateWhenOffscreen;
				}
				if (bones)
				{
					_mesh.bindposes = bindPoses;
					_mesh.boneWeights = boneWeights;
				}
				if (triangles || vertices)
				{
					if (LOG_LEVEL >= MB2_LogLevel.trace)
					{
						UnityEngine.Debug.Log("recalculating bounds on mesh.");
					}
					_mesh.RecalculateBounds();
				}
				_ = _optimizeAfterBake;
			}
			else
			{
				UnityEngine.Debug.LogError("Need to add objects to this meshbaker before calling Apply or ApplyAll");
			}
		}

		public int[][] GetSubmeshTrisWithShowHideApplied()
		{
			bool flag = false;
			for (int i = 0; i < mbDynamicObjectsInCombinedMesh.Count; i++)
			{
				if (!mbDynamicObjectsInCombinedMesh[i].show)
				{
					flag = true;
					break;
				}
			}
			if (flag)
			{
				int[] array = new int[submeshTris.Length];
				int[][] array2 = new int[submeshTris.Length][];
				for (int j = 0; j < mbDynamicObjectsInCombinedMesh.Count; j++)
				{
					MB_DynamicGameObject mB_DynamicGameObject = mbDynamicObjectsInCombinedMesh[j];
					if (mB_DynamicGameObject.show)
					{
						for (int k = 0; k < mB_DynamicGameObject.submeshNumTris.Length; k++)
						{
							array[k] += mB_DynamicGameObject.submeshNumTris[k];
						}
					}
				}
				for (int l = 0; l < array2.Length; l++)
				{
					array2[l] = new int[array[l]];
				}
				int[] array3 = new int[array2.Length];
				for (int m = 0; m < mbDynamicObjectsInCombinedMesh.Count; m++)
				{
					MB_DynamicGameObject mB_DynamicGameObject2 = mbDynamicObjectsInCombinedMesh[m];
					if (!mB_DynamicGameObject2.show)
					{
						continue;
					}
					for (int n = 0; n < submeshTris.Length; n++)
					{
						int[] array4 = submeshTris[n];
						int num = mB_DynamicGameObject2.submeshTriIdxs[n];
						int num2 = num + mB_DynamicGameObject2.submeshNumTris[n];
						for (int num3 = num; num3 < num2; num3++)
						{
							array2[n][array3[n]] = array4[num3];
							array3[n]++;
						}
					}
				}
				return array2;
			}
			return submeshTris;
		}

		public override void UpdateGameObjects(GameObject[] gos, bool recalcBounds = true, bool updateVertices = true, bool updateNormals = true, bool updateTangents = true, bool updateUV = false, bool updateUV2 = false, bool updateUV3 = false, bool updateUV4 = false, bool updateColors = false, bool updateSkinningInfo = false)
		{
			_updateGameObjects(gos, recalcBounds, updateVertices, updateNormals, updateTangents, updateUV, updateUV2, updateUV3, updateUV4, updateColors, updateSkinningInfo);
		}

		private void _updateGameObjects(GameObject[] gos, bool recalcBounds, bool updateVertices, bool updateNormals, bool updateTangents, bool updateUV, bool updateUV2, bool updateUV3, bool updateUV4, bool updateColors, bool updateSkinningInfo)
		{
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("UpdateGameObjects called on " + gos.Length + " objects.");
			}
			_initialize();
			if (_mesh.vertexCount > 0 && _instance2combined_map.Count == 0)
			{
				UnityEngine.Debug.LogWarning("There were vertices in the combined mesh but nothing in the MeshBaker buffers. If you are trying to bake in the editor and modify at runtime, make sure 'Clear Buffers After Bake' is unchecked.");
			}
			MeshChannelsCache meshChannelCache = new MeshChannelsCache(this);
			for (int i = 0; i < gos.Length; i++)
			{
				_updateGameObject(gos[i], updateVertices, updateNormals, updateTangents, updateUV, updateUV2, updateUV3, updateUV4, updateColors, updateSkinningInfo, meshChannelCache);
			}
			if (recalcBounds)
			{
				_mesh.RecalculateBounds();
			}
		}

		private void _updateGameObject(GameObject go, bool updateVertices, bool updateNormals, bool updateTangents, bool updateUV, bool updateUV2, bool updateUV3, bool updateUV4, bool updateColors, bool updateSkinningInfo, MeshChannelsCache meshChannelCache)
		{
			MB_DynamicGameObject dgo = null;
			if (!instance2Combined_MapTryGetValue(go.GetInstanceID(), out dgo))
			{
				UnityEngine.Debug.LogError("Object " + go.name + " has not been added");
				return;
			}
			Mesh mesh = MB_Utility.GetMesh(go);
			if (dgo.numVerts != mesh.vertexCount)
			{
				UnityEngine.Debug.LogError("Object " + go.name + " source mesh has been modified since being added. To update it must have the same number of verts");
				return;
			}
			if (_doUV && updateUV)
			{
				_copyAndAdjustUVsFromMesh(dgo, mesh, dgo.vertIdx, meshChannelCache);
			}
			if (doUV2() && updateUV2)
			{
				_copyAndAdjustUV2FromMesh(dgo, mesh, dgo.vertIdx, meshChannelCache);
			}
			if (renderType == MB_RenderType.skinnedMeshRenderer && updateSkinningInfo)
			{
				Renderer renderer = MB_Utility.GetRenderer(go);
				BoneWeight[] array = meshChannelCache.GetBoneWeights(renderer, dgo.numVerts);
				Transform[] array2 = _getBones(renderer);
				int num = dgo.vertIdx;
				bool flag = false;
				for (int i = 0; i < array.Length; i++)
				{
					if (array2[array[i].boneIndex0] != bones[boneWeights[num].boneIndex0])
					{
						flag = true;
						break;
					}
					boneWeights[num].weight0 = array[i].weight0;
					boneWeights[num].weight1 = array[i].weight1;
					boneWeights[num].weight2 = array[i].weight2;
					boneWeights[num].weight3 = array[i].weight3;
					num++;
				}
				if (flag)
				{
					UnityEngine.Debug.LogError("Detected that some of the boneweights reference different bones than when initial added. Boneweights must reference the same bones " + dgo.name);
				}
			}
			Matrix4x4 localToWorldMatrix = go.transform.localToWorldMatrix;
			if (updateVertices)
			{
				Vector3[] vertices = meshChannelCache.GetVertices(mesh);
				for (int j = 0; j < vertices.Length; j++)
				{
					verts[dgo.vertIdx + j] = localToWorldMatrix.MultiplyPoint3x4(vertices[j]);
				}
			}
			float num3 = (localToWorldMatrix[2, 3] = 0f);
			float value = (localToWorldMatrix[1, 3] = num3);
			localToWorldMatrix[0, 3] = value;
			if (_doNorm && updateNormals)
			{
				Vector3[] array3 = meshChannelCache.GetNormals(mesh);
				for (int k = 0; k < array3.Length; k++)
				{
					int num5 = dgo.vertIdx + k;
					normals[num5] = localToWorldMatrix.MultiplyPoint3x4(array3[k]);
					normals[num5] = normals[num5].normalized;
				}
			}
			if (_doTan && updateTangents)
			{
				Vector4[] array4 = meshChannelCache.GetTangents(mesh);
				for (int l = 0; l < array4.Length; l++)
				{
					int num6 = dgo.vertIdx + l;
					float w = array4[l].w;
					Vector3 vector = localToWorldMatrix.MultiplyPoint3x4(array4[l]);
					vector.Normalize();
					tangents[num6] = vector;
					tangents[num6].w = w;
				}
			}
			if (_doCol && updateColors)
			{
				Color[] array5 = meshChannelCache.GetColors(mesh);
				for (int m = 0; m < array5.Length; m++)
				{
					colors[dgo.vertIdx + m] = array5[m];
				}
			}
			if (_doUV3 && updateUV3)
			{
				Vector2[] uv = meshChannelCache.GetUv3(mesh);
				for (int n = 0; n < uv.Length; n++)
				{
					uv3s[dgo.vertIdx + n] = uv[n];
				}
			}
			if (_doUV4 && updateUV4)
			{
				Vector2[] uv2 = meshChannelCache.GetUv4(mesh);
				for (int num7 = 0; num7 < uv2.Length; num7++)
				{
					uv4s[dgo.vertIdx + num7] = uv2[num7];
				}
			}
		}

		public bool ShowHideGameObjects(GameObject[] toShow, GameObject[] toHide)
		{
			return _showHide(toShow, toHide);
		}

		public override bool AddDeleteGameObjects(GameObject[] gos, GameObject[] deleteGOs, bool disableRendererInSource = true)
		{
			int[] array = null;
			if (deleteGOs != null)
			{
				array = new int[deleteGOs.Length];
				for (int i = 0; i < deleteGOs.Length; i++)
				{
					if (deleteGOs[i] == null)
					{
						UnityEngine.Debug.LogError("The " + i + "th object on the list of objects to delete is 'Null'");
					}
					else
					{
						array[i] = deleteGOs[i].GetInstanceID();
					}
				}
			}
			return AddDeleteGameObjectsByID(gos, array, disableRendererInSource);
		}

		public override bool AddDeleteGameObjectsByID(GameObject[] gos, int[] deleteGOinstanceIDs, bool disableRendererInSource)
		{
			if (validationLevel > MB2_ValidationLevel.none)
			{
				if (gos != null)
				{
					for (int i = 0; i < gos.Length; i++)
					{
						if (gos[i] == null)
						{
							UnityEngine.Debug.LogError("The " + i + "th object on the list of objects to combine is 'None'. Use Command-Delete on Mac OS X; Delete or Shift-Delete on Windows to remove this one element.");
							return false;
						}
						if (validationLevel < MB2_ValidationLevel.robust)
						{
							continue;
						}
						for (int j = i + 1; j < gos.Length; j++)
						{
							if (gos[i] == gos[j])
							{
								UnityEngine.Debug.LogError(string.Concat("GameObject ", gos[i], " appears twice in list of game objects to add"));
								return false;
							}
						}
					}
				}
				if (deleteGOinstanceIDs != null && validationLevel >= MB2_ValidationLevel.robust)
				{
					for (int k = 0; k < deleteGOinstanceIDs.Length; k++)
					{
						for (int l = k + 1; l < deleteGOinstanceIDs.Length; l++)
						{
							if (deleteGOinstanceIDs[k] == deleteGOinstanceIDs[l])
							{
								UnityEngine.Debug.LogError("GameObject " + deleteGOinstanceIDs[k] + "appears twice in list of game objects to delete");
								return false;
							}
						}
					}
				}
			}
			if (_usingTemporaryTextureBakeResult && gos != null && gos.Length != 0)
			{
				MB_Utility.Destroy(_textureBakeResults);
				_textureBakeResults = null;
				_usingTemporaryTextureBakeResult = false;
			}
			if (_textureBakeResults == null && gos != null && gos.Length != 0 && gos[0] != null && !_CreateTemporaryTextrueBakeResult(gos))
			{
				return false;
			}
			BuildSceneMeshObject(gos);
			if (!_addToCombined(gos, deleteGOinstanceIDs, disableRendererInSource))
			{
				UnityEngine.Debug.LogError("Failed to add/delete objects to combined mesh");
				return false;
			}
			if (targetRenderer != null)
			{
				if (renderType == MB_RenderType.skinnedMeshRenderer)
				{
					((SkinnedMeshRenderer)targetRenderer).bones = bones;
					UpdateSkinnedMeshApproximateBoundsFromBounds();
				}
				targetRenderer.lightmapIndex = GetLightmapIndex();
			}
			return true;
		}

		public override bool CombinedMeshContains(GameObject go)
		{
			return objectsInCombinedMesh.Contains(go);
		}

		public override void ClearBuffers()
		{
			verts = new Vector3[0];
			normals = new Vector3[0];
			tangents = new Vector4[0];
			uvs = new Vector2[0];
			uv2s = new Vector2[0];
			uv3s = new Vector2[0];
			uv4s = new Vector2[0];
			colors = new Color[0];
			bones = new Transform[0];
			bindPoses = new Matrix4x4[0];
			boneWeights = new BoneWeight[0];
			submeshTris = new int[0][];
			if (blendShapes == null)
			{
				blendShapes = new MBBlendShape[0];
			}
			else
			{
				for (int i = 0; i < blendShapes.Length; i++)
				{
					blendShapes[i].frames = new MBBlendShapeFrame[0];
				}
			}
			mbDynamicObjectsInCombinedMesh.Clear();
			objectsInCombinedMesh.Clear();
			instance2Combined_MapClear();
			if (_usingTemporaryTextureBakeResult)
			{
				MB_Utility.Destroy(_textureBakeResults);
				_textureBakeResults = null;
				_usingTemporaryTextureBakeResult = false;
			}
			if (LOG_LEVEL >= MB2_LogLevel.trace)
			{
				MB2_Log.LogDebug("ClearBuffers called");
			}
		}

		public override void ClearMesh()
		{
			if (_mesh != null)
			{
				MBVersion.MeshClear(_mesh, t: false);
			}
			else
			{
				_mesh = new Mesh();
			}
			ClearBuffers();
		}

		public override void DestroyMesh()
		{
			if (_mesh != null)
			{
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug("Destroying Mesh");
				}
				MB_Utility.Destroy(_mesh);
			}
			_mesh = new Mesh();
			ClearBuffers();
		}

		public override void DestroyMeshEditor(MB2_EditorMethodsInterface editorMethods)
		{
			if (_mesh != null)
			{
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug("Destroying Mesh");
				}
				editorMethods.Destroy(_mesh);
			}
			_mesh = new Mesh();
			ClearBuffers();
		}

		public bool ValidateTargRendererAndMeshAndResultSceneObj()
		{
			if (_resultSceneObject == null)
			{
				if (_LOG_LEVEL >= MB2_LogLevel.error)
				{
					UnityEngine.Debug.LogError("Result Scene Object was not set.");
				}
				return false;
			}
			if (_targetRenderer == null)
			{
				if (_LOG_LEVEL >= MB2_LogLevel.error)
				{
					UnityEngine.Debug.LogError("Target Renderer was not set.");
				}
				return false;
			}
			if (_targetRenderer.transform.parent != _resultSceneObject.transform)
			{
				if (_LOG_LEVEL >= MB2_LogLevel.error)
				{
					UnityEngine.Debug.LogError("Target Renderer game object is not a child of Result Scene Object was not set.");
				}
				return false;
			}
			if (_renderType == MB_RenderType.skinnedMeshRenderer)
			{
				if (!(_targetRenderer is SkinnedMeshRenderer))
				{
					if (_LOG_LEVEL >= MB2_LogLevel.error)
					{
						UnityEngine.Debug.LogError("Render Type is skinned mesh renderer but Target Renderer is not.");
					}
					return false;
				}
				if (((SkinnedMeshRenderer)_targetRenderer).sharedMesh != _mesh)
				{
					if (_LOG_LEVEL >= MB2_LogLevel.error)
					{
						UnityEngine.Debug.LogError("Target renderer mesh is not equal to mesh.");
					}
					return false;
				}
			}
			if (_renderType == MB_RenderType.meshRenderer)
			{
				if (!(_targetRenderer is MeshRenderer))
				{
					if (_LOG_LEVEL >= MB2_LogLevel.error)
					{
						UnityEngine.Debug.LogError("Render Type is mesh renderer but Target Renderer is not.");
					}
					return false;
				}
				MeshFilter component = _targetRenderer.GetComponent<MeshFilter>();
				if (_mesh != component.sharedMesh)
				{
					if (_LOG_LEVEL >= MB2_LogLevel.error)
					{
						UnityEngine.Debug.LogError("Target renderer mesh is not equal to mesh.");
					}
					return false;
				}
			}
			return true;
		}

		public static Renderer BuildSceneHierarch(MB3_MeshCombinerSingle mom, GameObject root, Mesh m, bool createNewChild = false, GameObject[] objsToBeAdded = null)
		{
			if (mom._LOG_LEVEL >= MB2_LogLevel.trace)
			{
				UnityEngine.Debug.Log("Building Scene Hierarchy createNewChild=" + createNewChild);
			}
			MeshFilter meshFilter = null;
			MeshRenderer meshRenderer = null;
			SkinnedMeshRenderer skinnedMeshRenderer = null;
			Transform transform = null;
			if (root == null)
			{
				UnityEngine.Debug.LogError("root was null.");
				return null;
			}
			if (mom.textureBakeResults == null)
			{
				UnityEngine.Debug.LogError("textureBakeResults must be set.");
				return null;
			}
			if (root.GetComponent<Renderer>() != null)
			{
				UnityEngine.Debug.LogError("root game object cannot have a renderer component");
				return null;
			}
			if (!createNewChild)
			{
				if (mom.targetRenderer != null)
				{
					transform = mom.targetRenderer.transform;
				}
				else
				{
					Renderer[] componentsInChildren = root.GetComponentsInChildren<Renderer>();
					if (componentsInChildren.Length > 1)
					{
						UnityEngine.Debug.LogError("Result Scene Object had multiple child objects with renderers attached. Only one allowed. Try using a game object with no children as the Result Scene Object.");
						return null;
					}
					if (componentsInChildren.Length == 1)
					{
						if (componentsInChildren[0].transform.parent != root.transform)
						{
							UnityEngine.Debug.LogError("Target Renderer is not an immediate child of Result Scene Object. Try using a game object with no children as the Result Scene Object..");
							return null;
						}
						transform = componentsInChildren[0].transform;
					}
				}
			}
			if (transform != null && transform.parent != root.transform)
			{
				transform = null;
			}
			GameObject gameObject;
			if (transform == null)
			{
				gameObject = new GameObject(mom.name + "-mesh");
				gameObject.transform.parent = root.transform;
				transform = gameObject.transform;
			}
			gameObject = transform.gameObject;
			if (mom.renderType == MB_RenderType.skinnedMeshRenderer)
			{
				MeshRenderer component = gameObject.GetComponent<MeshRenderer>();
				if (component != null)
				{
					MB_Utility.Destroy(component);
				}
				MeshFilter component2 = gameObject.GetComponent<MeshFilter>();
				if (component2 != null)
				{
					MB_Utility.Destroy(component2);
				}
				skinnedMeshRenderer = gameObject.GetComponent<SkinnedMeshRenderer>();
				if (skinnedMeshRenderer == null)
				{
					skinnedMeshRenderer = gameObject.AddComponent<SkinnedMeshRenderer>();
				}
			}
			else
			{
				SkinnedMeshRenderer component3 = gameObject.GetComponent<SkinnedMeshRenderer>();
				if (component3 != null)
				{
					MB_Utility.Destroy(component3);
				}
				meshFilter = gameObject.GetComponent<MeshFilter>();
				if (meshFilter == null)
				{
					meshFilter = gameObject.AddComponent<MeshFilter>();
				}
				meshRenderer = gameObject.GetComponent<MeshRenderer>();
				if (meshRenderer == null)
				{
					meshRenderer = gameObject.AddComponent<MeshRenderer>();
				}
			}
			if (mom.textureBakeResults.doMultiMaterial)
			{
				Material[] array = new Material[mom.textureBakeResults.resultMaterials.Length];
				for (int i = 0; i < array.Length; i++)
				{
					array[i] = mom.textureBakeResults.resultMaterials[i].combinedMaterial;
				}
				if (mom.renderType == MB_RenderType.skinnedMeshRenderer)
				{
					skinnedMeshRenderer.sharedMaterial = null;
					skinnedMeshRenderer.sharedMaterials = array;
					skinnedMeshRenderer.bones = mom.GetBones();
					bool updateWhenOffscreen = skinnedMeshRenderer.updateWhenOffscreen;
					skinnedMeshRenderer.updateWhenOffscreen = true;
					skinnedMeshRenderer.updateWhenOffscreen = updateWhenOffscreen;
				}
				else
				{
					meshRenderer.sharedMaterial = null;
					meshRenderer.sharedMaterials = array;
				}
			}
			else if (mom.renderType == MB_RenderType.skinnedMeshRenderer)
			{
				skinnedMeshRenderer.sharedMaterials = new Material[1] { mom.textureBakeResults.resultMaterial };
				skinnedMeshRenderer.sharedMaterial = mom.textureBakeResults.resultMaterial;
				skinnedMeshRenderer.bones = mom.GetBones();
			}
			else
			{
				meshRenderer.sharedMaterials = new Material[1] { mom.textureBakeResults.resultMaterial };
				meshRenderer.sharedMaterial = mom.textureBakeResults.resultMaterial;
			}
			if (mom.renderType == MB_RenderType.skinnedMeshRenderer)
			{
				skinnedMeshRenderer.sharedMesh = m;
				skinnedMeshRenderer.lightmapIndex = mom.GetLightmapIndex();
			}
			else
			{
				meshFilter.sharedMesh = m;
				meshRenderer.lightmapIndex = mom.GetLightmapIndex();
			}
			if (mom.lightmapOption == MB2_LightmapOptions.preserve_current_lightmapping || mom.lightmapOption == MB2_LightmapOptions.generate_new_UV2_layout)
			{
				gameObject.isStatic = true;
			}
			if (objsToBeAdded != null && objsToBeAdded.Length != 0 && objsToBeAdded[0] != null)
			{
				bool flag = true;
				bool flag2 = true;
				string tag = objsToBeAdded[0].tag;
				int layer = objsToBeAdded[0].layer;
				for (int j = 0; j < objsToBeAdded.Length; j++)
				{
					if (objsToBeAdded[j] != null)
					{
						if (!objsToBeAdded[j].tag.Equals(tag))
						{
							flag = false;
						}
						if (objsToBeAdded[j].layer != layer)
						{
							flag2 = false;
						}
					}
				}
				if (flag)
				{
					root.tag = tag;
					gameObject.tag = tag;
				}
				if (flag2)
				{
					root.layer = layer;
					gameObject.layer = layer;
				}
			}
			gameObject.transform.parent = root.transform;
			if (mom.renderType == MB_RenderType.skinnedMeshRenderer)
			{
				return skinnedMeshRenderer;
			}
			return meshRenderer;
		}

		public void BuildSceneMeshObject(GameObject[] gos = null, bool createNewChild = false)
		{
			if (_resultSceneObject == null)
			{
				_resultSceneObject = new GameObject("CombinedMesh-" + base.name);
			}
			_targetRenderer = BuildSceneHierarch(this, _resultSceneObject, GetMesh(), createNewChild, gos);
		}

		private bool IsMirrored(Matrix4x4 tm)
		{
			Vector3 lhs = tm.GetRow(0);
			Vector3 rhs = tm.GetRow(1);
			Vector3 rhs2 = tm.GetRow(2);
			lhs.Normalize();
			rhs.Normalize();
			rhs2.Normalize();
			if (!(Vector3.Dot(Vector3.Cross(lhs, rhs), rhs2) >= 0f))
			{
				return true;
			}
			return false;
		}

		public override void CheckIntegrity()
		{
			if (renderType == MB_RenderType.skinnedMeshRenderer)
			{
				for (int i = 0; i < mbDynamicObjectsInCombinedMesh.Count; i++)
				{
					MB_DynamicGameObject mB_DynamicGameObject = mbDynamicObjectsInCombinedMesh[i];
					HashSet<int> hashSet = new HashSet<int>();
					HashSet<int> hashSet2 = new HashSet<int>();
					for (int j = mB_DynamicGameObject.vertIdx; j < mB_DynamicGameObject.vertIdx + mB_DynamicGameObject.numVerts; j++)
					{
						hashSet.Add(boneWeights[j].boneIndex0);
						hashSet.Add(boneWeights[j].boneIndex1);
						hashSet.Add(boneWeights[j].boneIndex2);
						hashSet.Add(boneWeights[j].boneIndex3);
					}
					for (int k = 0; k < mB_DynamicGameObject.indexesOfBonesUsed.Length; k++)
					{
						hashSet2.Add(mB_DynamicGameObject.indexesOfBonesUsed[k]);
					}
					hashSet2.ExceptWith(hashSet);
					if (hashSet2.Count > 0)
					{
						UnityEngine.Debug.LogError("The bone indexes were not the same. " + hashSet.Count + " " + hashSet2.Count);
					}
					for (int l = 0; l < mB_DynamicGameObject.indexesOfBonesUsed.Length; l++)
					{
						if (l < 0 || l > bones.Length)
						{
							UnityEngine.Debug.LogError("Bone index was out of bounds.");
						}
					}
					if (renderType == MB_RenderType.skinnedMeshRenderer && mB_DynamicGameObject.indexesOfBonesUsed.Length < 1)
					{
						UnityEngine.Debug.Log("DGO had no bones");
					}
				}
			}
			if (doBlendShapes && renderType != MB_RenderType.skinnedMeshRenderer)
			{
				UnityEngine.Debug.LogError("Blend shapes can only be used with skinned meshes.");
			}
		}

		private void _ZeroArray(Vector3[] arr, int idx, int length)
		{
			for (int i = idx; i < length; i++)
			{
				arr[i] = Vector3.zero;
			}
		}

		private List<MB_DynamicGameObject>[] _buildBoneIdx2dgoMap()
		{
			List<MB_DynamicGameObject>[] array = new List<MB_DynamicGameObject>[bones.Length];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = new List<MB_DynamicGameObject>();
			}
			for (int j = 0; j < mbDynamicObjectsInCombinedMesh.Count; j++)
			{
				MB_DynamicGameObject mB_DynamicGameObject = mbDynamicObjectsInCombinedMesh[j];
				for (int k = 0; k < mB_DynamicGameObject.indexesOfBonesUsed.Length; k++)
				{
					array[mB_DynamicGameObject.indexesOfBonesUsed[k]].Add(mB_DynamicGameObject);
				}
			}
			return array;
		}

		private void _CollectBonesToAddForDGO(MB_DynamicGameObject dgo, Dictionary<Transform, int> bone2idx, HashSet<int> boneIdxsToDelete, HashSet<BoneAndBindpose> bonesToAdd, Renderer r, MeshChannelsCache meshChannelCache)
		{
			Matrix4x4[] array = (dgo._tmpCachedBindposes = meshChannelCache.GetBindposes(r));
			BoneWeight[] array2 = (dgo._tmpCachedBoneWeights = meshChannelCache.GetBoneWeights(r, dgo.numVerts));
			Transform[] array3 = (dgo._tmpCachedBones = _getBones(r));
			HashSet<int> hashSet = new HashSet<int>();
			for (int i = 0; i < array2.Length; i++)
			{
				hashSet.Add(array2[i].boneIndex0);
				hashSet.Add(array2[i].boneIndex1);
				hashSet.Add(array2[i].boneIndex2);
				hashSet.Add(array2[i].boneIndex3);
			}
			int[] array4 = new int[hashSet.Count];
			hashSet.CopyTo(array4);
			for (int j = 0; j < array4.Length; j++)
			{
				bool flag = false;
				int num = array4[j];
				if (bone2idx.TryGetValue(array3[num], out var value) && array3[num] == bones[value] && !boneIdxsToDelete.Contains(value) && array[num] == bindPoses[value])
				{
					flag = true;
				}
				if (!flag)
				{
					BoneAndBindpose item = new BoneAndBindpose(array3[num], array[num]);
					if (!bonesToAdd.Contains(item))
					{
						bonesToAdd.Add(item);
					}
				}
			}
			dgo._tmpIndexesOfSourceBonesUsed = array4;
		}

		private void _CopyBonesWeAreKeepingToNewBonesArrayAndAdjustBWIndexes(HashSet<int> boneIdxsToDeleteHS, HashSet<BoneAndBindpose> bonesToAdd, Transform[] nbones, Matrix4x4[] nbindPoses, BoneWeight[] nboneWeights, int totalDeleteVerts)
		{
			if (boneIdxsToDeleteHS.Count > 0)
			{
				int[] array = new int[boneIdxsToDeleteHS.Count];
				boneIdxsToDeleteHS.CopyTo(array);
				Array.Sort(array);
				int[] array2 = new int[bones.Length];
				int num = 0;
				int num2 = 0;
				for (int i = 0; i < bones.Length; i++)
				{
					if (num2 < array.Length && array[num2] == i)
					{
						num2++;
						array2[i] = -1;
						continue;
					}
					array2[i] = num;
					nbones[num] = bones[i];
					nbindPoses[num] = bindPoses[i];
					num++;
				}
				int num3 = boneWeights.Length - totalDeleteVerts;
				for (int j = 0; j < num3; j++)
				{
					nboneWeights[j].boneIndex0 = array2[nboneWeights[j].boneIndex0];
					nboneWeights[j].boneIndex1 = array2[nboneWeights[j].boneIndex1];
					nboneWeights[j].boneIndex2 = array2[nboneWeights[j].boneIndex2];
					nboneWeights[j].boneIndex3 = array2[nboneWeights[j].boneIndex3];
				}
				for (int k = 0; k < mbDynamicObjectsInCombinedMesh.Count; k++)
				{
					MB_DynamicGameObject mB_DynamicGameObject = mbDynamicObjectsInCombinedMesh[k];
					for (int l = 0; l < mB_DynamicGameObject.indexesOfBonesUsed.Length; l++)
					{
						mB_DynamicGameObject.indexesOfBonesUsed[l] = array2[mB_DynamicGameObject.indexesOfBonesUsed[l]];
					}
				}
			}
			else
			{
				Array.Copy(bones, nbones, bones.Length);
				Array.Copy(bindPoses, nbindPoses, bindPoses.Length);
			}
		}

		private void _AddBonesToNewBonesArrayAndAdjustBWIndexes(MB_DynamicGameObject dgo, Renderer r, int vertsIdx, Transform[] nbones, BoneWeight[] nboneWeights, MeshChannelsCache meshChannelCache)
		{
			Transform[] tmpCachedBones = dgo._tmpCachedBones;
			Matrix4x4[] tmpCachedBindposes = dgo._tmpCachedBindposes;
			BoneWeight[] tmpCachedBoneWeights = dgo._tmpCachedBoneWeights;
			int[] array = new int[tmpCachedBones.Length];
			for (int i = 0; i < dgo._tmpIndexesOfSourceBonesUsed.Length; i++)
			{
				int num = dgo._tmpIndexesOfSourceBonesUsed[i];
				for (int j = 0; j < nbones.Length; j++)
				{
					if (tmpCachedBones[num] == nbones[j] && tmpCachedBindposes[num] == bindPoses[j])
					{
						array[num] = j;
						break;
					}
				}
			}
			for (int k = 0; k < tmpCachedBoneWeights.Length; k++)
			{
				int num2 = vertsIdx + k;
				nboneWeights[num2].boneIndex0 = array[tmpCachedBoneWeights[k].boneIndex0];
				nboneWeights[num2].boneIndex1 = array[tmpCachedBoneWeights[k].boneIndex1];
				nboneWeights[num2].boneIndex2 = array[tmpCachedBoneWeights[k].boneIndex2];
				nboneWeights[num2].boneIndex3 = array[tmpCachedBoneWeights[k].boneIndex3];
				nboneWeights[num2].weight0 = tmpCachedBoneWeights[k].weight0;
				nboneWeights[num2].weight1 = tmpCachedBoneWeights[k].weight1;
				nboneWeights[num2].weight2 = tmpCachedBoneWeights[k].weight2;
				nboneWeights[num2].weight3 = tmpCachedBoneWeights[k].weight3;
			}
			for (int l = 0; l < dgo._tmpIndexesOfSourceBonesUsed.Length; l++)
			{
				dgo._tmpIndexesOfSourceBonesUsed[l] = array[dgo._tmpIndexesOfSourceBonesUsed[l]];
			}
			dgo.indexesOfBonesUsed = dgo._tmpIndexesOfSourceBonesUsed;
			dgo._tmpIndexesOfSourceBonesUsed = null;
			dgo._tmpCachedBones = null;
			dgo._tmpCachedBindposes = null;
			dgo._tmpCachedBoneWeights = null;
		}

		private void _copyUV2unchangedToSeparateRects()
		{
			int padding = 16;
			List<Vector2> list = new List<Vector2>();
			float num = 1E+11f;
			float num2 = 0f;
			for (int i = 0; i < mbDynamicObjectsInCombinedMesh.Count; i++)
			{
				float magnitude = mbDynamicObjectsInCombinedMesh[i].meshSize.magnitude;
				if (magnitude > num2)
				{
					num2 = magnitude;
				}
				if (magnitude < num)
				{
					num = magnitude;
				}
			}
			float num3 = 1000f;
			float num4 = 10f;
			float num5 = 0f;
			float num6 = 1f;
			if (num2 - num > num3 - num4)
			{
				num6 = (num3 - num4) / (num2 - num);
				num5 = num4 - num * num6;
			}
			else
			{
				num6 = num3 / num2;
			}
			for (int j = 0; j < mbDynamicObjectsInCombinedMesh.Count; j++)
			{
				float magnitude2 = mbDynamicObjectsInCombinedMesh[j].meshSize.magnitude;
				magnitude2 = magnitude2 * num6 + num5;
				Vector2 item = Vector2.one * magnitude2;
				list.Add(item);
			}
			int outW;
			int outH;
			Rect[] rects = new MB2_TexturePacker
			{
				doPowerOfTwoTextures = false
			}.GetRects(list, 8192, padding, out outW, out outH);
			for (int k = 0; k < mbDynamicObjectsInCombinedMesh.Count; k++)
			{
				MB_DynamicGameObject mB_DynamicGameObject = mbDynamicObjectsInCombinedMesh[k];
				float x;
				float num7 = (x = uv2s[mB_DynamicGameObject.vertIdx].x);
				float y;
				float num8 = (y = uv2s[mB_DynamicGameObject.vertIdx].y);
				int num9 = mB_DynamicGameObject.vertIdx + mB_DynamicGameObject.numVerts;
				for (int l = mB_DynamicGameObject.vertIdx; l < num9; l++)
				{
					if (uv2s[l].x < num7)
					{
						num7 = uv2s[l].x;
					}
					if (uv2s[l].x > x)
					{
						x = uv2s[l].x;
					}
					if (uv2s[l].y < num8)
					{
						num8 = uv2s[l].y;
					}
					if (uv2s[l].y > y)
					{
						y = uv2s[l].y;
					}
				}
				Rect rect = rects[k];
				for (int m = mB_DynamicGameObject.vertIdx; m < num9; m++)
				{
					uv2s[m].x = (uv2s[m].x - num7) / (x - num7) * rect.width + rect.x;
					uv2s[m].y = (uv2s[m].y - num8) / (y - num8) * rect.height + rect.y;
				}
			}
		}
	}
	[Serializable]
	public class MB3_MultiMeshCombiner : MB3_MeshCombiner
	{
		[Serializable]
		public class CombinedMesh
		{
			public MB3_MeshCombinerSingle combinedMesh;

			public int extraSpace = -1;

			public int numVertsInListToDelete;

			public int numVertsInListToAdd;

			public List<GameObject> gosToAdd;

			public List<int> gosToDelete;

			public List<GameObject> gosToUpdate;

			public bool isDirty;

			public CombinedMesh(int maxNumVertsInMesh, GameObject resultSceneObject, MB2_LogLevel ll)
			{
				combinedMesh = new MB3_MeshCombinerSingle();
				combinedMesh.resultSceneObject = resultSceneObject;
				combinedMesh.LOG_LEVEL = ll;
				extraSpace = maxNumVertsInMesh;
				numVertsInListToDelete = 0;
				numVertsInListToAdd = 0;
				gosToAdd = new List<GameObject>();
				gosToDelete = new List<int>();
				gosToUpdate = new List<GameObject>();
			}

			public bool isEmpty()
			{
				List<GameObject> list = new List<GameObject>();
				list.AddRange(combinedMesh.GetObjectsInCombined());
				for (int i = 0; i < gosToDelete.Count; i++)
				{
					for (int j = 0; j < list.Count; j++)
					{
						if (list[j].GetInstanceID() == gosToDelete[i])
						{
							list.RemoveAt(j);
							break;
						}
					}
				}
				if (list.Count == 0)
				{
					return true;
				}
				return false;
			}
		}

		private static GameObject[] empty = new GameObject[0];

		private static int[] emptyIDs = new int[0];

		public Dictionary<int, CombinedMesh> obj2MeshCombinerMap = new Dictionary<int, CombinedMesh>();

		[SerializeField]
		public List<CombinedMesh> meshCombiners = new List<CombinedMesh>();

		[SerializeField]
		private int _maxVertsInMesh = 65535;

		public override MB2_LogLevel LOG_LEVEL
		{
			get
			{
				return _LOG_LEVEL;
			}
			set
			{
				_LOG_LEVEL = value;
				for (int i = 0; i < meshCombiners.Count; i++)
				{
					meshCombiners[i].combinedMesh.LOG_LEVEL = value;
				}
			}
		}

		public override MB2_ValidationLevel validationLevel
		{
			get
			{
				return _validationLevel;
			}
			set
			{
				_validationLevel = value;
				for (int i = 0; i < meshCombiners.Count; i++)
				{
					meshCombiners[i].combinedMesh.validationLevel = _validationLevel;
				}
			}
		}

		public int maxVertsInMesh
		{
			get
			{
				return _maxVertsInMesh;
			}
			set
			{
				if (obj2MeshCombinerMap.Count <= 0)
				{
					if (value < 3)
					{
						UnityEngine.Debug.LogError("Max verts in mesh must be greater than three.");
					}
					else if (value > 65535)
					{
						UnityEngine.Debug.LogError("Meshes in unity cannot have more than 65535 vertices.");
					}
					else
					{
						_maxVertsInMesh = value;
					}
				}
			}
		}

		public override int GetNumObjectsInCombined()
		{
			return obj2MeshCombinerMap.Count;
		}

		public override int GetNumVerticesFor(GameObject go)
		{
			CombinedMesh value = null;
			if (obj2MeshCombinerMap.TryGetValue(go.GetInstanceID(), out value))
			{
				return value.combinedMesh.GetNumVerticesFor(go);
			}
			return -1;
		}

		public override int GetNumVerticesFor(int gameObjectID)
		{
			CombinedMesh value = null;
			if (obj2MeshCombinerMap.TryGetValue(gameObjectID, out value))
			{
				return value.combinedMesh.GetNumVerticesFor(gameObjectID);
			}
			return -1;
		}

		public override List<GameObject> GetObjectsInCombined()
		{
			List<GameObject> list = new List<GameObject>();
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				list.AddRange(meshCombiners[i].combinedMesh.GetObjectsInCombined());
			}
			return list;
		}

		public override int GetLightmapIndex()
		{
			if (meshCombiners.Count > 0)
			{
				return meshCombiners[0].combinedMesh.GetLightmapIndex();
			}
			return -1;
		}

		public override bool CombinedMeshContains(GameObject go)
		{
			return obj2MeshCombinerMap.ContainsKey(go.GetInstanceID());
		}

		private bool _validateTextureBakeResults()
		{
			if (textureBakeResults == null)
			{
				UnityEngine.Debug.LogError("Material Bake Results is null. Can't combine meshes.");
				return false;
			}
			if (textureBakeResults.materialsAndUVRects == null || textureBakeResults.materialsAndUVRects.Length == 0)
			{
				UnityEngine.Debug.LogError("Material Bake Results has no materials in material to sourceUVRect map. Try baking materials. Can't combine meshes.");
				return false;
			}
			if (textureBakeResults.doMultiMaterial)
			{
				if (textureBakeResults.resultMaterials == null || textureBakeResults.resultMaterials.Length == 0)
				{
					UnityEngine.Debug.LogError("Material Bake Results has no result materials. Try baking materials. Can't combine meshes.");
					return false;
				}
			}
			else if (textureBakeResults.resultMaterial == null)
			{
				UnityEngine.Debug.LogError("Material Bake Results has no result material. Try baking materials. Can't combine meshes.");
				return false;
			}
			return true;
		}

		public override void Apply(GenerateUV2Delegate uv2GenerationMethod)
		{
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				if (meshCombiners[i].isDirty)
				{
					meshCombiners[i].combinedMesh.Apply(uv2GenerationMethod);
					meshCombiners[i].isDirty = false;
				}
			}
		}

		public override void Apply(bool triangles, bool vertices, bool normals, bool tangents, bool uvs, bool uv2, bool uv3, bool uv4, bool colors, bool bones = false, bool blendShapesFlag = false, GenerateUV2Delegate uv2GenerationMethod = null)
		{
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				if (meshCombiners[i].isDirty)
				{
					meshCombiners[i].combinedMesh.Apply(triangles, vertices, normals, tangents, uvs, uv2, uv3, uv4, colors, bones, blendShapesFlag, uv2GenerationMethod);
					meshCombiners[i].isDirty = false;
				}
			}
		}

		public override void UpdateSkinnedMeshApproximateBounds()
		{
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				meshCombiners[i].combinedMesh.UpdateSkinnedMeshApproximateBounds();
			}
		}

		public override void UpdateSkinnedMeshApproximateBoundsFromBones()
		{
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				meshCombiners[i].combinedMesh.UpdateSkinnedMeshApproximateBoundsFromBones();
			}
		}

		public override void UpdateSkinnedMeshApproximateBoundsFromBounds()
		{
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				meshCombiners[i].combinedMesh.UpdateSkinnedMeshApproximateBoundsFromBounds();
			}
		}

		public override void UpdateGameObjects(GameObject[] gos, bool recalcBounds = true, bool updateVertices = true, bool updateNormals = true, bool updateTangents = true, bool updateUV = false, bool updateUV2 = false, bool updateUV3 = false, bool updateUV4 = false, bool updateColors = false, bool updateSkinningInfo = false)
		{
			if (gos == null)
			{
				UnityEngine.Debug.LogError("list of game objects cannot be null");
				return;
			}
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				meshCombiners[i].gosToUpdate.Clear();
			}
			for (int j = 0; j < gos.Length; j++)
			{
				CombinedMesh value = null;
				obj2MeshCombinerMap.TryGetValue(gos[j].GetInstanceID(), out value);
				if (value != null)
				{
					value.gosToUpdate.Add(gos[j]);
				}
				else
				{
					UnityEngine.Debug.LogWarning(string.Concat("Object ", gos[j], " is not in the combined mesh."));
				}
			}
			for (int k = 0; k < meshCombiners.Count; k++)
			{
				if (meshCombiners[k].gosToUpdate.Count > 0)
				{
					meshCombiners[k].isDirty = true;
					GameObject[] gos2 = meshCombiners[k].gosToUpdate.ToArray();
					meshCombiners[k].combinedMesh.UpdateGameObjects(gos2, recalcBounds, updateVertices, updateNormals, updateTangents, updateUV, updateUV2, updateUV3, updateUV4, updateColors, updateSkinningInfo);
				}
			}
		}

		public override bool AddDeleteGameObjects(GameObject[] gos, GameObject[] deleteGOs, bool disableRendererInSource = true)
		{
			int[] array = null;
			if (deleteGOs != null)
			{
				array = new int[deleteGOs.Length];
				for (int i = 0; i < deleteGOs.Length; i++)
				{
					if (deleteGOs[i] == null)
					{
						UnityEngine.Debug.LogError("The " + i + "th object on the list of objects to delete is 'Null'");
					}
					else
					{
						array[i] = deleteGOs[i].GetInstanceID();
					}
				}
			}
			return AddDeleteGameObjectsByID(gos, array, disableRendererInSource);
		}

		public override bool AddDeleteGameObjectsByID(GameObject[] gos, int[] deleteGOinstanceIDs, bool disableRendererInSource = true)
		{
			if (_usingTemporaryTextureBakeResult && gos != null && gos.Length != 0)
			{
				MB_Utility.Destroy(_textureBakeResults);
				_textureBakeResults = null;
				_usingTemporaryTextureBakeResult = false;
			}
			if (_textureBakeResults == null && gos != null && gos.Length != 0 && gos[0] != null && !_CreateTemporaryTextrueBakeResult(gos))
			{
				return false;
			}
			if (!_validate(gos, deleteGOinstanceIDs))
			{
				return false;
			}
			_distributeAmongBakers(gos, deleteGOinstanceIDs);
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				MB2_Log.LogDebug(string.Concat("MB2_MultiMeshCombiner.AddDeleteGameObjects numCombinedMeshes: ", meshCombiners.Count, " added:", gos, " deleted:", deleteGOinstanceIDs, " disableRendererInSource:", disableRendererInSource.ToString(), " maxVertsPerCombined:", _maxVertsInMesh));
			}
			return _bakeStep1(gos, deleteGOinstanceIDs, disableRendererInSource);
		}

		private bool _validate(GameObject[] gos, int[] deleteGOinstanceIDs)
		{
			if (_validationLevel == MB2_ValidationLevel.none)
			{
				return true;
			}
			if (_maxVertsInMesh < 3)
			{
				UnityEngine.Debug.LogError("Invalid value for maxVertsInMesh=" + _maxVertsInMesh);
			}
			_validateTextureBakeResults();
			if (gos != null)
			{
				for (int i = 0; i < gos.Length; i++)
				{
					if (gos[i] == null)
					{
						UnityEngine.Debug.LogError("The " + i + "th object on the list of objects to combine is 'None'. Use Command-Delete on Mac OS X; Delete or Shift-Delete on Windows to remove this one element.");
						return false;
					}
					if (_validationLevel < MB2_ValidationLevel.robust)
					{
						continue;
					}
					for (int j = i + 1; j < gos.Length; j++)
					{
						if (gos[i] == gos[j])
						{
							UnityEngine.Debug.LogError(string.Concat("GameObject ", gos[i], "appears twice in list of game objects to add"));
							return false;
						}
					}
					if (!obj2MeshCombinerMap.ContainsKey(gos[i].GetInstanceID()))
					{
						continue;
					}
					bool flag = false;
					if (deleteGOinstanceIDs != null)
					{
						for (int k = 0; k < deleteGOinstanceIDs.Length; k++)
						{
							if (deleteGOinstanceIDs[k] == gos[i].GetInstanceID())
							{
								flag = true;
							}
						}
					}
					if (!flag)
					{
						UnityEngine.Debug.LogError(string.Concat("GameObject ", gos[i], " is already in the combined mesh ", gos[i].GetInstanceID()));
						return false;
					}
				}
			}
			if (deleteGOinstanceIDs != null && _validationLevel >= MB2_ValidationLevel.robust)
			{
				for (int l = 0; l < deleteGOinstanceIDs.Length; l++)
				{
					for (int m = l + 1; m < deleteGOinstanceIDs.Length; m++)
					{
						if (deleteGOinstanceIDs[l] == deleteGOinstanceIDs[m])
						{
							UnityEngine.Debug.LogError("GameObject " + deleteGOinstanceIDs[l] + "appears twice in list of game objects to delete");
							return false;
						}
					}
					if (!obj2MeshCombinerMap.ContainsKey(deleteGOinstanceIDs[l]))
					{
						UnityEngine.Debug.LogWarning("GameObject with instance ID " + deleteGOinstanceIDs[l] + " on the list of objects to delete is not in the combined mesh.");
					}
				}
			}
			return true;
		}

		private void _distributeAmongBakers(GameObject[] gos, int[] deleteGOinstanceIDs)
		{
			if (gos == null)
			{
				gos = empty;
			}
			if (deleteGOinstanceIDs == null)
			{
				deleteGOinstanceIDs = emptyIDs;
			}
			if (resultSceneObject == null)
			{
				resultSceneObject = new GameObject("CombinedMesh-" + base.name);
			}
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				meshCombiners[i].extraSpace = _maxVertsInMesh - meshCombiners[i].combinedMesh.GetMesh().vertexCount;
			}
			for (int j = 0; j < deleteGOinstanceIDs.Length; j++)
			{
				CombinedMesh value = null;
				if (obj2MeshCombinerMap.TryGetValue(deleteGOinstanceIDs[j], out value))
				{
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug("MB2_MultiMeshCombiner.Removing " + deleteGOinstanceIDs[j] + " from meshCombiner " + meshCombiners.IndexOf(value));
					}
					value.numVertsInListToDelete += value.combinedMesh.GetNumVerticesFor(deleteGOinstanceIDs[j]);
					value.gosToDelete.Add(deleteGOinstanceIDs[j]);
				}
				else
				{
					UnityEngine.Debug.LogWarning("Object " + deleteGOinstanceIDs[j] + " in the list of objects to delete is not in the combined mesh.");
				}
			}
			for (int k = 0; k < gos.Length; k++)
			{
				GameObject gameObject = gos[k];
				int vertexCount = MB_Utility.GetMesh(gameObject).vertexCount;
				CombinedMesh combinedMesh = null;
				for (int l = 0; l < meshCombiners.Count; l++)
				{
					if (meshCombiners[l].extraSpace + meshCombiners[l].numVertsInListToDelete - meshCombiners[l].numVertsInListToAdd > vertexCount)
					{
						combinedMesh = meshCombiners[l];
						if (LOG_LEVEL >= MB2_LogLevel.debug)
						{
							MB2_Log.LogDebug(string.Concat("MB2_MultiMeshCombiner.Added ", gos[k], " to combinedMesh ", l), LOG_LEVEL);
						}
						break;
					}
				}
				if (combinedMesh == null)
				{
					combinedMesh = new CombinedMesh(maxVertsInMesh, _resultSceneObject, _LOG_LEVEL);
					_setMBValues(combinedMesh.combinedMesh);
					meshCombiners.Add(combinedMesh);
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug("MB2_MultiMeshCombiner.Created new combinedMesh");
					}
				}
				combinedMesh.gosToAdd.Add(gameObject);
				combinedMesh.numVertsInListToAdd += vertexCount;
			}
		}

		private bool _bakeStep1(GameObject[] gos, int[] deleteGOinstanceIDs, bool disableRendererInSource)
		{
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				CombinedMesh combinedMesh = meshCombiners[i];
				if (combinedMesh.combinedMesh.targetRenderer == null)
				{
					combinedMesh.combinedMesh.resultSceneObject = _resultSceneObject;
					combinedMesh.combinedMesh.BuildSceneMeshObject(gos, createNewChild: true);
					if (_LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug("BuildSO combiner {0} goID {1} targetRenID {2} meshID {3}", i, combinedMesh.combinedMesh.targetRenderer.gameObject.GetInstanceID(), combinedMesh.combinedMesh.targetRenderer.GetInstanceID(), combinedMesh.combinedMesh.GetMesh().GetInstanceID());
					}
				}
				else if (combinedMesh.combinedMesh.targetRenderer.transform.parent != resultSceneObject.transform)
				{
					UnityEngine.Debug.LogError("targetRender objects must be children of resultSceneObject");
					return false;
				}
				if (combinedMesh.gosToAdd.Count > 0 || combinedMesh.gosToDelete.Count > 0)
				{
					combinedMesh.combinedMesh.AddDeleteGameObjectsByID(combinedMesh.gosToAdd.ToArray(), combinedMesh.gosToDelete.ToArray(), disableRendererInSource);
					if (_LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug("Baked combiner {0} obsAdded {1} objsRemoved {2} goID {3} targetRenID {4} meshID {5}", i, combinedMesh.gosToAdd.Count, combinedMesh.gosToDelete.Count, combinedMesh.combinedMesh.targetRenderer.gameObject.GetInstanceID(), combinedMesh.combinedMesh.targetRenderer.GetInstanceID(), combinedMesh.combinedMesh.GetMesh().GetInstanceID());
					}
				}
				Renderer renderer = combinedMesh.combinedMesh.targetRenderer;
				Mesh mesh = combinedMesh.combinedMesh.GetMesh();
				if (renderer is MeshRenderer)
				{
					renderer.gameObject.GetComponent<MeshFilter>().sharedMesh = mesh;
				}
				else
				{
					((SkinnedMeshRenderer)renderer).sharedMesh = mesh;
				}
			}
			for (int j = 0; j < meshCombiners.Count; j++)
			{
				CombinedMesh combinedMesh2 = meshCombiners[j];
				for (int k = 0; k < combinedMesh2.gosToDelete.Count; k++)
				{
					obj2MeshCombinerMap.Remove(combinedMesh2.gosToDelete[k]);
				}
			}
			for (int l = 0; l < meshCombiners.Count; l++)
			{
				CombinedMesh combinedMesh3 = meshCombiners[l];
				for (int m = 0; m < combinedMesh3.gosToAdd.Count; m++)
				{
					obj2MeshCombinerMap.Add(combinedMesh3.gosToAdd[m].GetInstanceID(), combinedMesh3);
				}
				if (combinedMesh3.gosToAdd.Count > 0 || combinedMesh3.gosToDelete.Count > 0)
				{
					combinedMesh3.gosToDelete.Clear();
					combinedMesh3.gosToAdd.Clear();
					combinedMesh3.numVertsInListToDelete = 0;
					combinedMesh3.numVertsInListToAdd = 0;
					combinedMesh3.isDirty = true;
				}
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				string text = "Meshes in combined:";
				for (int n = 0; n < meshCombiners.Count; n++)
				{
					text = text + " mesh" + n + "(" + meshCombiners[n].combinedMesh.GetObjectsInCombined().Count + ")\n";
				}
				text = text + "children in result: " + resultSceneObject.transform.childCount;
				MB2_Log.LogDebug(text, LOG_LEVEL);
			}
			if (meshCombiners.Count > 0)
			{
				return true;
			}
			return false;
		}

		public override Dictionary<MBBlendShapeKey, MBBlendShapeValue> BuildSourceBlendShapeToCombinedIndexMap()
		{
			Dictionary<MBBlendShapeKey, MBBlendShapeValue> dictionary = new Dictionary<MBBlendShapeKey, MBBlendShapeValue>();
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				for (int j = 0; j < meshCombiners[i].combinedMesh.blendShapes.Length; j++)
				{
					MB3_MeshCombinerSingle.MBBlendShape mBBlendShape = meshCombiners[i].combinedMesh.blendShapes[j];
					MBBlendShapeValue mBBlendShapeValue = new MBBlendShapeValue();
					mBBlendShapeValue.combinedMeshGameObject = meshCombiners[i].combinedMesh.targetRenderer.gameObject;
					mBBlendShapeValue.blendShapeIndex = j;
					dictionary.Add(new MBBlendShapeKey(mBBlendShape.gameObjectID, mBBlendShape.indexInSource), mBBlendShapeValue);
				}
			}
			return dictionary;
		}

		public override void ClearBuffers()
		{
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				meshCombiners[i].combinedMesh.ClearBuffers();
			}
		}

		public override void ClearMesh()
		{
			DestroyMesh();
		}

		public override void DestroyMesh()
		{
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				if (meshCombiners[i].combinedMesh.targetRenderer != null)
				{
					MB_Utility.Destroy(meshCombiners[i].combinedMesh.targetRenderer.gameObject);
				}
				meshCombiners[i].combinedMesh.ClearMesh();
			}
			obj2MeshCombinerMap.Clear();
			meshCombiners.Clear();
		}

		public override void DestroyMeshEditor(MB2_EditorMethodsInterface editorMethods)
		{
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				if (meshCombiners[i].combinedMesh.targetRenderer != null)
				{
					editorMethods.Destroy(meshCombiners[i].combinedMesh.targetRenderer.gameObject);
				}
				meshCombiners[i].combinedMesh.ClearMesh();
			}
			obj2MeshCombinerMap.Clear();
			meshCombiners.Clear();
		}

		private void _setMBValues(MB3_MeshCombinerSingle targ)
		{
			targ.validationLevel = _validationLevel;
			targ.renderType = renderType;
			targ.outputOption = MB2_OutputOptions.bakeIntoSceneObject;
			targ.lightmapOption = lightmapOption;
			targ.textureBakeResults = textureBakeResults;
			targ.doNorm = doNorm;
			targ.doTan = doTan;
			targ.doCol = doCol;
			targ.doUV = doUV;
			targ.doUV3 = doUV3;
			targ.doUV4 = doUV4;
			targ.doBlendShapes = doBlendShapes;
			targ.optimizeAfterBake = base.optimizeAfterBake;
			targ.recenterVertsToBoundsCenter = recenterVertsToBoundsCenter;
			targ.uv2UnwrappingParamsHardAngle = uv2UnwrappingParamsHardAngle;
			targ.uv2UnwrappingParamsPackMargin = uv2UnwrappingParamsPackMargin;
		}

		public override void CheckIntegrity()
		{
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				meshCombiners[i].combinedMesh.CheckIntegrity();
			}
		}
	}
	[Serializable]
	public class ShaderTextureProperty
	{
		public string name;

		public bool isNormalMap;

		public ShaderTextureProperty(string n, bool norm)
		{
			name = n;
			isNormalMap = norm;
		}

		public static string[] GetNames(List<ShaderTextureProperty> props)
		{
			string[] array = new string[props.Count];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = props[i].name;
			}
			return array;
		}
	}
	[Serializable]
	public class MB3_TextureCombiner
	{
		public class MeshBakerMaterialTexture
		{
			public Texture2D t;

			public float texelDensity;

			public DRect encapsulatingSamplingRect;

			public DRect matTilingRect;

			public MeshBakerMaterialTexture()
			{
			}

			public MeshBakerMaterialTexture(Texture2D tx)
			{
				t = tx;
			}

			public MeshBakerMaterialTexture(Texture2D tx, Vector2 o, Vector2 s, float texelDens)
			{
				t = tx;
				matTilingRect = new DRect(o, s);
				texelDensity = texelDens;
			}
		}

		public class MatAndTransformToMerged
		{
			public Material mat;

			public DRect obUVRectIfTilingSame = new DRect(0f, 0f, 1f, 1f);

			public DRect samplingRectMatAndUVTiling;

			public DRect materialTiling;

			public string objName;

			public MatAndTransformToMerged(Material m)
			{
				mat = m;
			}

			public override bool Equals(object obj)
			{
				if (obj is MatAndTransformToMerged)
				{
					MatAndTransformToMerged matAndTransformToMerged = (MatAndTransformToMerged)obj;
					if (matAndTransformToMerged.mat == mat && matAndTransformToMerged.obUVRectIfTilingSame == obUVRectIfTilingSame)
					{
						return true;
					}
				}
				return false;
			}

			public override int GetHashCode()
			{
				return mat.GetHashCode() ^ obUVRectIfTilingSame.GetHashCode() ^ samplingRectMatAndUVTiling.GetHashCode();
			}
		}

		public class SamplingRectEnclosesComparer : IComparer<MatAndTransformToMerged>
		{
			public int Compare(MatAndTransformToMerged x, MatAndTransformToMerged y)
			{
				if (x.samplingRectMatAndUVTiling.Equals(y.samplingRectMatAndUVTiling))
				{
					return 0;
				}
				if (x.samplingRectMatAndUVTiling.Encloses(y.samplingRectMatAndUVTiling))
				{
					return -1;
				}
				return 1;
			}
		}

		public class MB_TexSet
		{
			public MeshBakerMaterialTexture[] ts;

			public List<MatAndTransformToMerged> mats;

			public List<GameObject> gos;

			public bool allTexturesUseSameMatTiling;

			public Vector2 obUVoffset = new Vector2(0f, 0f);

			public Vector2 obUVscale = new Vector2(1f, 1f);

			public int idealWidth;

			public int idealHeight;

			public DRect obUVrect => new DRect(obUVoffset, obUVscale);

			public MB_TexSet(MeshBakerMaterialTexture[] tss, Vector2 uvOffset, Vector2 uvScale)
			{
				ts = tss;
				obUVoffset = uvOffset;
				obUVscale = uvScale;
				allTexturesUseSameMatTiling = false;
				mats = new List<MatAndTransformToMerged>();
				gos = new List<GameObject>();
			}

			public bool IsEqual(object obj, bool fixOutOfBoundsUVs, bool considerNonTextureProperties, TextureBlender resultMaterialTextureBlender)
			{
				if (!(obj is MB_TexSet))
				{
					return false;
				}
				MB_TexSet mB_TexSet = (MB_TexSet)obj;
				if (mB_TexSet.ts.Length != ts.Length)
				{
					return false;
				}
				for (int i = 0; i < ts.Length; i++)
				{
					if (ts[i].matTilingRect != mB_TexSet.ts[i].matTilingRect)
					{
						return false;
					}
					if (ts[i].t != mB_TexSet.ts[i].t)
					{
						return false;
					}
					if (considerNonTextureProperties && resultMaterialTextureBlender != null && !resultMaterialTextureBlender.NonTexturePropertiesAreEqual(mats[0].mat, mB_TexSet.mats[0].mat))
					{
						return false;
					}
				}
				if (fixOutOfBoundsUVs && obUVoffset != mB_TexSet.obUVoffset)
				{
					return false;
				}
				if (fixOutOfBoundsUVs && obUVscale != mB_TexSet.obUVscale)
				{
					return false;
				}
				return true;
			}

			public void CalcInitialFullSamplingRects(bool fixOutOfBoundsUVs)
			{
				DRect encapsulatingSamplingRect = new DRect(0f, 0f, 1f, 1f);
				for (int i = 0; i < ts.Length; i++)
				{
					if (ts[i].t != null)
					{
						DRect r = ts[i].matTilingRect;
						DRect r2 = ((!fixOutOfBoundsUVs) ? new DRect(0.0, 0.0, 1.0, 1.0) : obUVrect);
						ts[i].encapsulatingSamplingRect = MB3_UVTransformUtility.CombineTransforms(ref r2, ref r);
						encapsulatingSamplingRect = ts[i].encapsulatingSamplingRect;
					}
				}
				for (int j = 0; j < ts.Length; j++)
				{
					if (ts[j].t == null)
					{
						ts[j].encapsulatingSamplingRect = encapsulatingSamplingRect;
					}
				}
			}

			public void CalcMatAndUVSamplingRectsIfAllMatTilingSame()
			{
				if (!allTexturesUseSameMatTiling)
				{
					UnityEngine.Debug.LogError("All textures must use same material tiling to calc full sampling rects");
				}
				DRect r = new DRect(0f, 0f, 1f, 1f);
				for (int i = 0; i < ts.Length; i++)
				{
					if (ts[i].t != null)
					{
						r = ts[i].matTilingRect;
					}
				}
				for (int j = 0; j < mats.Count; j++)
				{
					mats[j].materialTiling = r;
					mats[j].samplingRectMatAndUVTiling = MB3_UVTransformUtility.CombineTransforms(ref mats[j].obUVRectIfTilingSame, ref r);
				}
			}

			public bool AllTexturesAreSameForMerge(MB_TexSet other, bool considerNonTextureProperties, TextureBlender resultMaterialTextureBlender)
			{
				if (other.ts.Length != ts.Length)
				{
					return false;
				}
				if (!other.allTexturesUseSameMatTiling || !allTexturesUseSameMatTiling)
				{
					return false;
				}
				int num = -1;
				for (int i = 0; i < ts.Length; i++)
				{
					if (ts[i].t != other.ts[i].t)
					{
						return false;
					}
					if (num == -1 && ts[i].t != null)
					{
						num = i;
					}
					if (considerNonTextureProperties && resultMaterialTextureBlender != null && !resultMaterialTextureBlender.NonTexturePropertiesAreEqual(mats[0].mat, other.mats[0].mat))
					{
						return false;
					}
				}
				if (num != -1)
				{
					for (int j = 0; j < ts.Length; j++)
					{
						if (ts[j].t != other.ts[j].t)
						{
							return false;
						}
					}
				}
				return true;
			}

			internal string GetDescription()
			{
				StringBuilder stringBuilder = new StringBuilder();
				stringBuilder.AppendFormat("[GAME_OBJS=");
				for (int i = 0; i < gos.Count; i++)
				{
					stringBuilder.AppendFormat("{0},", gos[i].name);
				}
				stringBuilder.AppendFormat("MATS=");
				for (int j = 0; j < mats.Count; j++)
				{
					stringBuilder.AppendFormat("{0},", mats[j].mat.name);
				}
				stringBuilder.Append("]");
				return stringBuilder.ToString();
			}

			internal string GetMatSubrectDescriptions()
			{
				StringBuilder stringBuilder = new StringBuilder();
				for (int i = 0; i < mats.Count; i++)
				{
					stringBuilder.AppendFormat("\n    {0}={1},", mats[i].mat.name, mats[i].samplingRectMatAndUVTiling);
				}
				return stringBuilder.ToString();
			}
		}

		public class CombineTexturesIntoAtlasesCoroutineResult
		{
			public bool success = true;

			public bool isFinished;
		}

		public static bool DO_INTEGRITY_CHECKS = false;

		public MB2_LogLevel LOG_LEVEL = MB2_LogLevel.info;

		public static ShaderTextureProperty[] shaderTexPropertyNames = new ShaderTextureProperty[19]
		{
			new ShaderTextureProperty("_MainTex", norm: false),
			new ShaderTextureProperty("_BumpMap", norm: true),
			new ShaderTextureProperty("_Normal", norm: true),
			new ShaderTextureProperty("_BumpSpecMap", norm: false),
			new ShaderTextureProperty("_DecalTex", norm: false),
			new ShaderTextureProperty("_Detail", norm: false),
			new ShaderTextureProperty("_GlossMap", norm: false),
			new ShaderTextureProperty("_Illum", norm: false),
			new ShaderTextureProperty("_LightTextureB0", norm: false),
			new ShaderTextureProperty("_ParallaxMap", norm: false),
			new ShaderTextureProperty("_ShadowOffset", norm: false),
			new ShaderTextureProperty("_TranslucencyMap", norm: false),
			new ShaderTextureProperty("_SpecMap", norm: false),
			new ShaderTextureProperty("_SpecGlossMap", norm: false),
			new ShaderTextureProperty("_TranspMap", norm: false),
			new ShaderTextureProperty("_MetallicGlossMap", norm: false),
			new ShaderTextureProperty("_OcclusionMap", norm: false),
			new ShaderTextureProperty("_EmissionMap", norm: false),
			new ShaderTextureProperty("_DetailMask", norm: false)
		};

		[SerializeField]
		protected MB2_TextureBakeResults _textureBakeResults;

		[SerializeField]
		protected int _atlasPadding = 1;

		[SerializeField]
		protected int _maxAtlasSize = 1;

		[SerializeField]
		protected bool _resizePowerOfTwoTextures;

		[SerializeField]
		protected bool _fixOutOfBoundsUVs;

		[SerializeField]
		protected int _maxTilingBakeSize = 1024;

		[SerializeField]
		protected bool _saveAtlasesAsAssets;

		[SerializeField]
		protected MB2_PackingAlgorithmEnum _packingAlgorithm;

		[SerializeField]
		protected bool _meshBakerTexturePackerForcePowerOfTwo = true;

		[SerializeField]
		protected List<ShaderTextureProperty> _customShaderPropNames = new List<ShaderTextureProperty>();

		[SerializeField]
		protected bool _normalizeTexelDensity;

		[SerializeField]
		protected bool _considerNonTextureProperties;

		protected TextureBlender resultMaterialTextureBlender;

		protected TextureBlender[] textureBlenders = new TextureBlender[0];

		protected List<Texture2D> _temporaryTextures = new List<Texture2D>();

		public static bool _RunCorutineWithoutPauseIsRunning = false;

		private int __step2_CalculateIdealSizesForTexturesInAtlasAndPadding;

		private Rect[] __createAtlasesMBTexturePacker;

		public MB2_TextureBakeResults textureBakeResults
		{
			get
			{
				return _textureBakeResults;
			}
			set
			{
				_textureBakeResults = value;
			}
		}

		public int atlasPadding
		{
			get
			{
				return _atlasPadding;
			}
			set
			{
				_atlasPadding = value;
			}
		}

		public int maxAtlasSize
		{
			get
			{
				return _maxAtlasSize;
			}
			set
			{
				_maxAtlasSize = value;
			}
		}

		public bool resizePowerOfTwoTextures
		{
			get
			{
				return _resizePowerOfTwoTextures;
			}
			set
			{
				_resizePowerOfTwoTextures = value;
			}
		}

		public bool fixOutOfBoundsUVs
		{
			get
			{
				return _fixOutOfBoundsUVs;
			}
			set
			{
				_fixOutOfBoundsUVs = value;
			}
		}

		public int maxTilingBakeSize
		{
			get
			{
				return _maxTilingBakeSize;
			}
			set
			{
				_maxTilingBakeSize = value;
			}
		}

		public bool saveAtlasesAsAssets
		{
			get
			{
				return _saveAtlasesAsAssets;
			}
			set
			{
				_saveAtlasesAsAssets = value;
			}
		}

		public MB2_PackingAlgorithmEnum packingAlgorithm
		{
			get
			{
				return _packingAlgorithm;
			}
			set
			{
				_packingAlgorithm = value;
			}
		}

		public bool meshBakerTexturePackerForcePowerOfTwo
		{
			get
			{
				return _meshBakerTexturePackerForcePowerOfTwo;
			}
			set
			{
				_meshBakerTexturePackerForcePowerOfTwo = value;
			}
		}

		public List<ShaderTextureProperty> customShaderPropNames
		{
			get
			{
				return _customShaderPropNames;
			}
			set
			{
				_customShaderPropNames = value;
			}
		}

		public bool considerNonTextureProperties
		{
			get
			{
				return _considerNonTextureProperties;
			}
			set
			{
				_considerNonTextureProperties = value;
			}
		}

		public static void RunCorutineWithoutPause(IEnumerator cor, int recursionDepth)
		{
			if (recursionDepth == 0)
			{
				_RunCorutineWithoutPauseIsRunning = true;
			}
			if (recursionDepth > 20)
			{
				UnityEngine.Debug.LogError("Recursion Depth Exceeded.");
				return;
			}
			while (cor.MoveNext())
			{
				object current = cor.Current;
				if (!(current is YieldInstruction) && current != null && current is IEnumerator)
				{
					RunCorutineWithoutPause((IEnumerator)cor.Current, recursionDepth + 1);
				}
			}
			if (recursionDepth == 0)
			{
				_RunCorutineWithoutPauseIsRunning = false;
			}
		}

		public bool CombineTexturesIntoAtlases(ProgressUpdateDelegate progressInfo, MB_AtlasesAndRects resultAtlasesAndRects, Material resultMaterial, List<GameObject> objsToMesh, List<Material> allowedMaterialsFilter, MB2_EditorMethodsInterface textureEditorMethods = null)
		{
			CombineTexturesIntoAtlasesCoroutineResult combineTexturesIntoAtlasesCoroutineResult = new CombineTexturesIntoAtlasesCoroutineResult();
			RunCorutineWithoutPause(_CombineTexturesIntoAtlases(progressInfo, combineTexturesIntoAtlasesCoroutineResult, resultAtlasesAndRects, resultMaterial, objsToMesh, allowedMaterialsFilter, textureEditorMethods), 0);
			return combineTexturesIntoAtlasesCoroutineResult.success;
		}

		public IEnumerator CombineTexturesIntoAtlasesCoroutine(ProgressUpdateDelegate progressInfo, MB_AtlasesAndRects resultAtlasesAndRects, Material resultMaterial, List<GameObject> objsToMesh, List<Material> allowedMaterialsFilter, MB2_EditorMethodsInterface textureEditorMethods = null, CombineTexturesIntoAtlasesCoroutineResult coroutineResult = null, float maxTimePerFrame = 0.01f)
		{
			if (!_RunCorutineWithoutPauseIsRunning && (MBVersion.GetMajorVersion() < 5 || (MBVersion.GetMajorVersion() == 5 && MBVersion.GetMinorVersion() < 3)))
			{
				UnityEngine.Debug.LogError("Running the texture combiner as a coroutine only works in Unity 5.3 and higher");
				yield return null;
			}
			coroutineResult.success = true;
			coroutineResult.isFinished = false;
			if (maxTimePerFrame <= 0f)
			{
				UnityEngine.Debug.LogError("maxTimePerFrame must be a value greater than zero");
				coroutineResult.isFinished = true;
			}
			else
			{
				yield return _CombineTexturesIntoAtlases(progressInfo, coroutineResult, resultAtlasesAndRects, resultMaterial, objsToMesh, allowedMaterialsFilter, textureEditorMethods);
				coroutineResult.isFinished = true;
			}
		}

		private static bool InterfaceFilter(Type typeObj, object criteriaObj)
		{
			return typeObj.ToString() == criteriaObj.ToString();
		}

		private void _LoadTextureBlenders()
		{
			string filterCriteria = "DigitalOpus.MB.Core.TextureBlender";
			TypeFilter filter = InterfaceFilter;
			List<Type> list = new List<Type>();
			Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
			foreach (Assembly assembly in assemblies)
			{
				IEnumerable enumerable = null;
				try
				{
					enumerable = assembly.GetTypes();
				}
				catch (Exception ex)
				{
					ex.Equals(null);
				}
				if (enumerable == null)
				{
					continue;
				}
				Type[] types = assembly.GetTypes();
				foreach (Type type in types)
				{
					if (type.FindInterfaces(filter, filterCriteria).Length != 0)
					{
						list.Add(type);
					}
				}
			}
			List<TextureBlender> list2 = new List<TextureBlender>();
			foreach (Type item2 in list)
			{
				if (!item2.IsAbstract && !item2.IsInterface)
				{
					TextureBlender item = (TextureBlender)Activator.CreateInstance(item2);
					list2.Add(item);
				}
			}
			textureBlenders = list2.ToArray();
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log($"Loaded {textureBlenders.Length} TextureBlenders.");
			}
		}

		private bool _CollectPropertyNames(Material resultMaterial, List<ShaderTextureProperty> texPropertyNames)
		{
			int i;
			for (i = 0; i < texPropertyNames.Count; i++)
			{
				ShaderTextureProperty shaderTextureProperty = _customShaderPropNames.Find((ShaderTextureProperty x) => x.name.Equals(texPropertyNames[i].name));
				if (shaderTextureProperty != null)
				{
					_customShaderPropNames.Remove(shaderTextureProperty);
				}
			}
			if (resultMaterial == null)
			{
				UnityEngine.Debug.LogError("Please assign a result material. The combined mesh will use this material.");
				return false;
			}
			string text = "";
			for (int j = 0; j < shaderTexPropertyNames.Length; j++)
			{
				if (resultMaterial.HasProperty(shaderTexPropertyNames[j].name))
				{
					text = text + ", " + shaderTexPropertyNames[j].name;
					if (!texPropertyNames.Contains(shaderTexPropertyNames[j]))
					{
						texPropertyNames.Add(shaderTexPropertyNames[j]);
					}
					if (resultMaterial.GetTextureOffset(shaderTexPropertyNames[j].name) != new Vector2(0f, 0f) && LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning("Result material has non-zero offset. This is may be incorrect.");
					}
					if (resultMaterial.GetTextureScale(shaderTexPropertyNames[j].name) != new Vector2(1f, 1f) && LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning("Result material should have tiling of 1,1");
					}
				}
			}
			for (int k = 0; k < _customShaderPropNames.Count; k++)
			{
				if (resultMaterial.HasProperty(_customShaderPropNames[k].name))
				{
					text = text + ", " + _customShaderPropNames[k].name;
					texPropertyNames.Add(_customShaderPropNames[k]);
					if (resultMaterial.GetTextureOffset(_customShaderPropNames[k].name) != new Vector2(0f, 0f) && LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning("Result material has non-zero offset. This is probably incorrect.");
					}
					if (resultMaterial.GetTextureScale(_customShaderPropNames[k].name) != new Vector2(1f, 1f) && LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning("Result material should probably have tiling of 1,1.");
					}
				}
				else if (LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Result material shader does not use property " + _customShaderPropNames[k].name + " in the list of custom shader property names");
				}
			}
			return true;
		}

		private IEnumerator _CombineTexturesIntoAtlases(ProgressUpdateDelegate progressInfo, CombineTexturesIntoAtlasesCoroutineResult result, MB_AtlasesAndRects resultAtlasesAndRects, Material resultMaterial, List<GameObject> objsToMesh, List<Material> allowedMaterialsFilter, MB2_EditorMethodsInterface textureEditorMethods)
		{
			Stopwatch sw = new Stopwatch();
			sw.Start();
			try
			{
				_temporaryTextures.Clear();
				textureEditorMethods?.Clear();
				if (objsToMesh == null || objsToMesh.Count == 0)
				{
					UnityEngine.Debug.LogError("No meshes to combine. Please assign some meshes to combine.");
					result.success = false;
					yield break;
				}
				if (_atlasPadding < 0)
				{
					UnityEngine.Debug.LogError("Atlas padding must be zero or greater.");
					result.success = false;
					yield break;
				}
				if (_maxTilingBakeSize < 2 || _maxTilingBakeSize > 4096)
				{
					UnityEngine.Debug.LogError("Invalid value for max tiling bake size.");
					result.success = false;
					yield break;
				}
				progressInfo?.Invoke("Collecting textures for " + objsToMesh.Count + " meshes.", 0.01f);
				List<ShaderTextureProperty> texPropertyNames = new List<ShaderTextureProperty>();
				if (!_CollectPropertyNames(resultMaterial, texPropertyNames))
				{
					result.success = false;
					yield break;
				}
				if (_considerNonTextureProperties)
				{
					_LoadTextureBlenders();
					resultMaterialTextureBlender = FindMatchingTextureBlender(resultMaterial.shader.name);
					if (resultMaterialTextureBlender != null)
					{
						if (LOG_LEVEL >= MB2_LogLevel.debug)
						{
							UnityEngine.Debug.Log("Using _considerNonTextureProperties found a TextureBlender for result material. Using: " + resultMaterialTextureBlender);
						}
					}
					else
					{
						if (LOG_LEVEL >= MB2_LogLevel.error)
						{
							UnityEngine.Debug.LogWarning("Using _considerNonTextureProperties could not find a TextureBlender that matches the shader on the result material. Using the Fallback Texture Blender.");
						}
						resultMaterialTextureBlender = new TextureBlenderFallback();
					}
				}
				yield return __CombineTexturesIntoAtlases(progressInfo, result, resultAtlasesAndRects, resultMaterial, texPropertyNames, objsToMesh, allowedMaterialsFilter, textureEditorMethods);
			}
			finally
			{
				MB3_TextureCombiner mB3_TextureCombiner = this;
				mB3_TextureCombiner._destroyTemporaryTextures();
				textureEditorMethods?.SetReadFlags(progressInfo);
				if (mB3_TextureCombiner.LOG_LEVEL >= MB2_LogLevel.debug)
				{
					UnityEngine.Debug.Log("Total time to create atlases " + sw.ElapsedMilliseconds.ToString("f5"));
				}
			}
		}

		private IEnumerator __CombineTexturesIntoAtlases(ProgressUpdateDelegate progressInfo, CombineTexturesIntoAtlasesCoroutineResult result, MB_AtlasesAndRects resultAtlasesAndRects, Material resultMaterial, List<ShaderTextureProperty> texPropertyNames, List<GameObject> objsToMesh, List<Material> allowedMaterialsFilter, MB2_EditorMethodsInterface textureEditorMethods)
		{
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("__CombineTexturesIntoAtlases texture properties in shader:" + texPropertyNames.Count + " objsToMesh:" + objsToMesh.Count + " _fixOutOfBoundsUVs:" + _fixOutOfBoundsUVs.ToString());
			}
			progressInfo?.Invoke("Collecting textures ", 0.01f);
			List<MB_TexSet> distinctMaterialTextures = new List<MB_TexSet>();
			List<GameObject> usedObjsToMesh = new List<GameObject>();
			yield return __Step1_CollectDistinctMatTexturesAndUsedObjects(result, objsToMesh, allowedMaterialsFilter, texPropertyNames, textureEditorMethods, distinctMaterialTextures, usedObjsToMesh);
			if (!result.success)
			{
				yield break;
			}
			if (MB3_MeshCombiner.EVAL_VERSION)
			{
				bool flag = true;
				for (int i = 0; i < distinctMaterialTextures.Count; i++)
				{
					for (int j = 0; j < distinctMaterialTextures[i].mats.Count; j++)
					{
						if (!distinctMaterialTextures[i].mats[j].mat.shader.name.EndsWith("Diffuse") && !distinctMaterialTextures[i].mats[j].mat.shader.name.EndsWith("Bumped Diffuse"))
						{
							UnityEngine.Debug.LogError("The free version of Mesh Baker only works with Diffuse and Bumped Diffuse Shaders. The full version can be used with any shader. Material " + distinctMaterialTextures[i].mats[j].mat.name + " uses shader " + distinctMaterialTextures[i].mats[j].mat.shader.name);
							flag = false;
						}
					}
				}
				if (!flag)
				{
					result.success = false;
					yield break;
				}
			}
			bool[] allTexturesAreNullAndSameColor = new bool[texPropertyNames.Count];
			yield return __Step2_CalculateIdealSizesForTexturesInAtlasAndPadding(result, distinctMaterialTextures, texPropertyNames, allTexturesAreNullAndSameColor, textureEditorMethods);
			if (result.success)
			{
				int _step2_CalculateIdealSizesForTexturesInAtlasAndPadding = __step2_CalculateIdealSizesForTexturesInAtlasAndPadding;
				yield return __Step3_BuildAndSaveAtlasesAndStoreResults(result, progressInfo, distinctMaterialTextures, texPropertyNames, allTexturesAreNullAndSameColor, _step2_CalculateIdealSizesForTexturesInAtlasAndPadding, textureEditorMethods, resultAtlasesAndRects, resultMaterial);
			}
		}

		private IEnumerator __Step1_CollectDistinctMatTexturesAndUsedObjects(CombineTexturesIntoAtlasesCoroutineResult result, List<GameObject> allObjsToMesh, List<Material> allowedMaterialsFilter, List<ShaderTextureProperty> texPropertyNames, MB2_EditorMethodsInterface textureEditorMethods, List<MB_TexSet> distinctMaterialTextures, List<GameObject> usedObjsToMesh)
		{
			Stopwatch stopwatch = new Stopwatch();
			stopwatch.Start();
			bool flag = false;
			Dictionary<int, MB_Utility.MeshAnalysisResult[]> dictionary = new Dictionary<int, MB_Utility.MeshAnalysisResult[]>();
			for (int i = 0; i < allObjsToMesh.Count; i++)
			{
				GameObject gameObject = allObjsToMesh[i];
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					UnityEngine.Debug.Log("Collecting textures for object " + gameObject);
				}
				if (gameObject == null)
				{
					UnityEngine.Debug.LogError("The list of objects to mesh contained nulls.");
					result.success = false;
					yield break;
				}
				Mesh mesh = MB_Utility.GetMesh(gameObject);
				if (mesh == null)
				{
					UnityEngine.Debug.LogError("Object " + gameObject.name + " in the list of objects to mesh has no mesh.");
					result.success = false;
					yield break;
				}
				Material[] gOMaterials = MB_Utility.GetGOMaterials(gameObject);
				if (gOMaterials == null)
				{
					UnityEngine.Debug.LogError("Object " + gameObject.name + " in the list of objects has no materials.");
					result.success = false;
					yield break;
				}
				if (!dictionary.TryGetValue(mesh.GetInstanceID(), out var value))
				{
					value = new MB_Utility.MeshAnalysisResult[mesh.subMeshCount];
					for (int j = 0; j < mesh.subMeshCount; j++)
					{
						MB_Utility.hasOutOfBoundsUVs(mesh, ref value[j], j);
						if (_normalizeTexelDensity)
						{
							value[j].submeshArea = GetSubmeshArea(mesh, j);
						}
					}
					dictionary.Add(mesh.GetInstanceID(), value);
				}
				if (_fixOutOfBoundsUVs && LOG_LEVEL >= MB2_LogLevel.trace)
				{
					UnityEngine.Debug.Log(string.Concat("Mesh Analysis for object ", gameObject, " numSubmesh=", value.Length, " HasOBUV=", value[0].hasOutOfBoundsUVs.ToString(), " UVrectSubmesh0=", value[0].uvRect));
				}
				for (int k = 0; k < gOMaterials.Length; k++)
				{
					Material material = gOMaterials[k];
					if (allowedMaterialsFilter != null && !allowedMaterialsFilter.Contains(material))
					{
						continue;
					}
					flag = flag || value[k].hasOutOfBoundsUVs;
					if (material.name.Contains("(Instance)"))
					{
						UnityEngine.Debug.LogError("The sharedMaterial on object " + gameObject.name + " has been 'Instanced'. This was probably caused by a script accessing the meshRender.material property in the editor.  The material to UV Rectangle mapping will be incorrect. To fix this recreate the object from its prefab or re-assign its material from the correct asset.");
						result.success = false;
						yield break;
					}
					if (_fixOutOfBoundsUVs && !MB_Utility.AreAllSharedMaterialsDistinct(gOMaterials) && LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning("Object " + gameObject.name + " uses the same material on multiple submeshes. This may generate strange resultAtlasesAndRects especially when used with fix out of bounds uvs. Try duplicating the material.");
					}
					MeshBakerMaterialTexture[] array = new MeshBakerMaterialTexture[texPropertyNames.Count];
					for (int l = 0; l < texPropertyNames.Count; l++)
					{
						Texture2D texture2D = null;
						Vector2 s = Vector2.one;
						Vector2 o = Vector2.zero;
						float texelDens = 0f;
						if (material.HasProperty(texPropertyNames[l].name))
						{
							Texture texture = material.GetTexture(texPropertyNames[l].name);
							if (texture != null)
							{
								if (!(texture is Texture2D))
								{
									UnityEngine.Debug.LogError("Object " + gameObject.name + " in the list of objects to mesh uses a Texture that is not a Texture2D. Cannot build atlases.");
									result.success = false;
									yield break;
								}
								texture2D = (Texture2D)texture;
								TextureFormat format = texture2D.format;
								bool flag2 = false;
								if (!Application.isPlaying && textureEditorMethods != null)
								{
									flag2 = textureEditorMethods.IsNormalMap(texture2D);
								}
								if ((format != TextureFormat.ARGB32 && format != TextureFormat.RGBA32 && format != TextureFormat.BGRA32 && format != TextureFormat.RGB24 && format != TextureFormat.Alpha8) || flag2)
								{
									if (Application.isPlaying && _packingAlgorithm != MB2_PackingAlgorithmEnum.MeshBakerTexturePacker_Fast)
									{
										UnityEngine.Debug.LogError(string.Concat("Object ", gameObject.name, " in the list of objects to mesh uses Texture ", texture2D.name, " uses format ", format, " that is not in: ARGB32, RGBA32, BGRA32, RGB24, Alpha8 or DXT. These textures cannot be resized at runtime. Try changing texture format. If format says 'compressed' try changing it to 'truecolor'"));
										result.success = false;
										yield break;
									}
									texture2D = (Texture2D)material.GetTexture(texPropertyNames[l].name);
								}
							}
							if (texture2D != null && _normalizeTexelDensity)
							{
								texelDens = ((value[l].submeshArea != 0f) ? ((float)(texture2D.width * texture2D.height) / value[l].submeshArea) : 0f);
							}
							s = material.GetTextureScale(texPropertyNames[l].name);
							o = material.GetTextureOffset(texPropertyNames[l].name);
						}
						array[l] = new MeshBakerMaterialTexture(texture2D, o, s, texelDens);
					}
					Vector2 uvScale = new Vector2(value[k].uvRect.width, value[k].uvRect.height);
					Vector2 uvOffset = new Vector2(value[k].uvRect.x, value[k].uvRect.y);
					MB_TexSet setOfTexs = new MB_TexSet(array, uvOffset, uvScale);
					MatAndTransformToMerged item = new MatAndTransformToMerged(material);
					setOfTexs.mats.Add(item);
					MB_TexSet mB_TexSet = distinctMaterialTextures.Find((MB_TexSet x) => x.IsEqual(setOfTexs, _fixOutOfBoundsUVs, _considerNonTextureProperties, resultMaterialTextureBlender));
					if (mB_TexSet != null)
					{
						setOfTexs = mB_TexSet;
					}
					else
					{
						distinctMaterialTextures.Add(setOfTexs);
					}
					if (!setOfTexs.mats.Contains(item))
					{
						setOfTexs.mats.Add(item);
					}
					if (!setOfTexs.gos.Contains(gameObject))
					{
						setOfTexs.gos.Add(gameObject);
						if (!usedObjsToMesh.Contains(gameObject))
						{
							usedObjsToMesh.Add(gameObject);
						}
					}
				}
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log($"Step1_CollectDistinctTextures collected {distinctMaterialTextures.Count} sets of textures fixOutOfBoundsUV={_fixOutOfBoundsUVs} considerNonTextureProperties={_considerNonTextureProperties}");
			}
			MergeOverlappingDistinctMaterialTexturesAndCalcMaterialSubrects(distinctMaterialTextures, fixOutOfBoundsUVs);
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Total time Step1_CollectDistinctTextures " + stopwatch.ElapsedMilliseconds.ToString("f5"));
			}
		}

		private IEnumerator __Step2_CalculateIdealSizesForTexturesInAtlasAndPadding(CombineTexturesIntoAtlasesCoroutineResult result, List<MB_TexSet> distinctMaterialTextures, List<ShaderTextureProperty> texPropertyNames, bool[] allTexturesAreNullAndSameColor, MB2_EditorMethodsInterface textureEditorMethods)
		{
			Stopwatch stopwatch = new Stopwatch();
			stopwatch.Start();
			for (int i = 0; i < texPropertyNames.Count; i++)
			{
				bool flag = true;
				bool flag2 = true;
				for (int j = 0; j < distinctMaterialTextures.Count; j++)
				{
					if (distinctMaterialTextures[j].ts[i].t != null)
					{
						flag = false;
						break;
					}
					if (!_considerNonTextureProperties)
					{
						continue;
					}
					for (int k = j + 1; k < distinctMaterialTextures.Count; k++)
					{
						Color colorIfNoTexture = resultMaterialTextureBlender.GetColorIfNoTexture(distinctMaterialTextures[j].mats[0].mat, texPropertyNames[i]);
						Color colorIfNoTexture2 = resultMaterialTextureBlender.GetColorIfNoTexture(distinctMaterialTextures[k].mats[0].mat, texPropertyNames[i]);
						if (colorIfNoTexture != colorIfNoTexture2)
						{
							flag2 = false;
							break;
						}
					}
				}
				allTexturesAreNullAndSameColor[i] = flag && flag2;
				if (LOG_LEVEL >= MB2_LogLevel.trace)
				{
					UnityEngine.Debug.Log($"AllTexturesAreNullAndSameColor prop: {texPropertyNames[i].name} val:{allTexturesAreNullAndSameColor[i]}");
				}
			}
			int num = _atlasPadding;
			if (distinctMaterialTextures.Count == 1 && !_fixOutOfBoundsUVs)
			{
				if (LOG_LEVEL >= MB2_LogLevel.info)
				{
					UnityEngine.Debug.Log("All objects use the same textures in this set of atlases. Original textures will be reused instead of creating atlases.");
				}
				num = 0;
			}
			else
			{
				if (allTexturesAreNullAndSameColor.Length != texPropertyNames.Count)
				{
					UnityEngine.Debug.LogError("allTexturesAreNullAndSameColor array must be the same length of texPropertyNames.");
				}
				for (int l = 0; l < distinctMaterialTextures.Count; l++)
				{
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						UnityEngine.Debug.Log("Calculating ideal sizes for texSet TexSet " + l + " of " + distinctMaterialTextures.Count);
					}
					MB_TexSet mB_TexSet = distinctMaterialTextures[l];
					mB_TexSet.idealWidth = 1;
					mB_TexSet.idealHeight = 1;
					int num2 = 1;
					int num3 = 1;
					if (mB_TexSet.ts.Length != texPropertyNames.Count)
					{
						UnityEngine.Debug.LogError("length of arrays in each element of distinctMaterialTextures must be texPropertyNames.Count");
					}
					for (int m = 0; m < texPropertyNames.Count; m++)
					{
						MeshBakerMaterialTexture meshBakerMaterialTexture = mB_TexSet.ts[m];
						if (!meshBakerMaterialTexture.matTilingRect.size.Equals(Vector2.one) && distinctMaterialTextures.Count > 1 && LOG_LEVEL >= MB2_LogLevel.warn)
						{
							UnityEngine.Debug.LogWarning(string.Concat("Texture ", meshBakerMaterialTexture.t, "is tiled by ", meshBakerMaterialTexture.matTilingRect.size, " tiling will be baked into a texture with maxSize:", _maxTilingBakeSize));
						}
						if (!mB_TexSet.obUVscale.Equals(Vector2.one) && distinctMaterialTextures.Count > 1 && _fixOutOfBoundsUVs && LOG_LEVEL >= MB2_LogLevel.warn)
						{
							UnityEngine.Debug.LogWarning(string.Concat("Texture ", meshBakerMaterialTexture.t, "has out of bounds UVs that effectively tile by ", mB_TexSet.obUVscale, " tiling will be baked into a texture with maxSize:", _maxTilingBakeSize));
						}
						if (!allTexturesAreNullAndSameColor[m] && meshBakerMaterialTexture.t == null)
						{
							if (LOG_LEVEL >= MB2_LogLevel.trace)
							{
								UnityEngine.Debug.Log("No source texture creating a 16x16 texture.");
							}
							meshBakerMaterialTexture.t = _createTemporaryTexture(16, 16, TextureFormat.ARGB32, mipMaps: true);
							if (_considerNonTextureProperties && resultMaterialTextureBlender != null)
							{
								Color colorIfNoTexture3 = resultMaterialTextureBlender.GetColorIfNoTexture(mB_TexSet.mats[0].mat, texPropertyNames[m]);
								if (LOG_LEVEL >= MB2_LogLevel.trace)
								{
									UnityEngine.Debug.Log("Setting texture to solid color " + colorIfNoTexture3);
								}
								MB_Utility.setSolidColor(meshBakerMaterialTexture.t, colorIfNoTexture3);
							}
							else
							{
								Color colorIfNoTexture4 = GetColorIfNoTexture(texPropertyNames[m]);
								MB_Utility.setSolidColor(meshBakerMaterialTexture.t, colorIfNoTexture4);
							}
							if (fixOutOfBoundsUVs)
							{
								meshBakerMaterialTexture.encapsulatingSamplingRect = mB_TexSet.obUVrect;
							}
							else
							{
								meshBakerMaterialTexture.encapsulatingSamplingRect = new DRect(0f, 0f, 1f, 1f);
							}
						}
						if (!(meshBakerMaterialTexture.t != null))
						{
							continue;
						}
						Vector2 adjustedForScaleAndOffset2Dimensions = GetAdjustedForScaleAndOffset2Dimensions(meshBakerMaterialTexture, mB_TexSet.obUVoffset, mB_TexSet.obUVscale);
						if ((int)(adjustedForScaleAndOffset2Dimensions.x * adjustedForScaleAndOffset2Dimensions.y) > num2 * num3)
						{
							if (LOG_LEVEL >= MB2_LogLevel.trace)
							{
								UnityEngine.Debug.Log(string.Concat("    matTex ", meshBakerMaterialTexture.t, " ", adjustedForScaleAndOffset2Dimensions, " has a bigger size than ", num2, " ", num3));
							}
							num2 = (int)adjustedForScaleAndOffset2Dimensions.x;
							num3 = (int)adjustedForScaleAndOffset2Dimensions.y;
						}
					}
					if (_resizePowerOfTwoTextures)
					{
						if (num2 <= num * 5)
						{
							UnityEngine.Debug.LogWarning(string.Format("Some of the textures have widths close to the size of the padding. It is not recommended to use _resizePowerOfTwoTextures with widths this small.", mB_TexSet.ToString()));
						}
						if (num3 <= num * 5)
						{
							UnityEngine.Debug.LogWarning(string.Format("Some of the textures have heights close to the size of the padding. It is not recommended to use _resizePowerOfTwoTextures with heights this small.", mB_TexSet.ToString()));
						}
						if (IsPowerOfTwo(num2))
						{
							num2 -= num * 2;
						}
						if (IsPowerOfTwo(num3))
						{
							num3 -= num * 2;
						}
						if (num2 < 1)
						{
							num2 = 1;
						}
						if (num3 < 1)
						{
							num3 = 1;
						}
					}
					if (LOG_LEVEL >= MB2_LogLevel.trace)
					{
						UnityEngine.Debug.Log("    Ideal size is " + num2 + " " + num3);
					}
					mB_TexSet.idealWidth = num2;
					mB_TexSet.idealHeight = num3;
				}
			}
			if (distinctMaterialTextures.Count > 1 && _packingAlgorithm != MB2_PackingAlgorithmEnum.MeshBakerTexturePacker_Fast)
			{
				for (int n = 0; n < distinctMaterialTextures.Count; n++)
				{
					for (int num4 = 0; num4 < texPropertyNames.Count; num4++)
					{
						Texture2D t = distinctMaterialTextures[n].ts[num4].t;
						if (t != null)
						{
							textureEditorMethods?.AddTextureFormat(t, texPropertyNames[num4].isNormalMap);
						}
					}
				}
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Total time Step2 Calculate Ideal Sizes " + stopwatch.ElapsedMilliseconds.ToString("f5"));
			}
			__step2_CalculateIdealSizesForTexturesInAtlasAndPadding = num;
			yield break;
		}

		private IEnumerator __Step3_BuildAndSaveAtlasesAndStoreResults(CombineTexturesIntoAtlasesCoroutineResult result, ProgressUpdateDelegate progressInfo, List<MB_TexSet> distinctMaterialTextures, List<ShaderTextureProperty> texPropertyNames, bool[] allTexturesAreNullAndSameColor, int _padding, MB2_EditorMethodsInterface textureEditorMethods, MB_AtlasesAndRects resultAtlasesAndRects, Material resultMaterial)
		{
			Stopwatch sw = new Stopwatch();
			sw.Start();
			int numAtlases = texPropertyNames.Count;
			StringBuilder report = new StringBuilder();
			if (numAtlases > 0)
			{
				report = new StringBuilder();
				report.AppendLine("Report");
				for (int i = 0; i < distinctMaterialTextures.Count; i++)
				{
					MB_TexSet mB_TexSet = distinctMaterialTextures[i];
					report.AppendLine("----------");
					report.Append("This set of textures will be resized to:" + mB_TexSet.idealWidth + "x" + mB_TexSet.idealHeight + "\n");
					for (int j = 0; j < mB_TexSet.ts.Length; j++)
					{
						if (mB_TexSet.ts[j].t != null)
						{
							report.Append("   [" + texPropertyNames[j].name + " " + mB_TexSet.ts[j].t.name + " " + mB_TexSet.ts[j].t.width + "x" + mB_TexSet.ts[j].t.height + "]");
							if (mB_TexSet.ts[j].matTilingRect.size != Vector2.one || mB_TexSet.ts[j].matTilingRect.min != Vector2.zero)
							{
								report.AppendFormat(" material scale {0} offset{1} ", mB_TexSet.ts[j].matTilingRect.size.ToString("G4"), mB_TexSet.ts[j].matTilingRect.min.ToString("G4"));
							}
							if (mB_TexSet.obUVscale != Vector2.one || mB_TexSet.obUVoffset != Vector2.zero)
							{
								report.AppendFormat(" obUV scale {0} offset{1} ", mB_TexSet.obUVscale.ToString("G4"), mB_TexSet.obUVoffset.ToString("G4"));
							}
							report.AppendLine("");
						}
						else
						{
							report.Append("   [" + texPropertyNames[j].name + " null ");
							if (allTexturesAreNullAndSameColor[j])
							{
								report.Append("no atlas will be created all textures null]\n");
							}
							else
							{
								report.AppendFormat("a 16x16 texture will be created]\n");
							}
						}
					}
					report.AppendLine("");
					report.Append("Materials using:");
					for (int k = 0; k < mB_TexSet.mats.Count; k++)
					{
						report.Append(mB_TexSet.mats[k].mat.name + ", ");
					}
					report.AppendLine("");
				}
			}
			progressInfo?.Invoke("Creating txture atlases.", 0.1f);
			GC.Collect();
			Texture2D[] atlases = new Texture2D[numAtlases];
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("time Step 3 Create And Save Atlases part 1 " + sw.ElapsedMilliseconds.ToString("f5"));
			}
			Rect[] array;
			if (_packingAlgorithm == MB2_PackingAlgorithmEnum.UnitysPackTextures)
			{
				array = __CreateAtlasesUnityTexturePacker(progressInfo, numAtlases, distinctMaterialTextures, texPropertyNames, allTexturesAreNullAndSameColor, resultMaterial, atlases, textureEditorMethods, _padding);
			}
			else if (_packingAlgorithm == MB2_PackingAlgorithmEnum.MeshBakerTexturePacker)
			{
				yield return __CreateAtlasesMBTexturePacker(progressInfo, numAtlases, distinctMaterialTextures, texPropertyNames, allTexturesAreNullAndSameColor, resultMaterial, atlases, textureEditorMethods, _padding);
				array = __createAtlasesMBTexturePacker;
			}
			else
			{
				array = __CreateAtlasesMBTexturePackerFast(progressInfo, numAtlases, distinctMaterialTextures, texPropertyNames, allTexturesAreNullAndSameColor, resultMaterial, atlases, textureEditorMethods, _padding);
			}
			float num = sw.ElapsedMilliseconds;
			AdjustNonTextureProperties(resultMaterial, texPropertyNames, distinctMaterialTextures, _considerNonTextureProperties, textureEditorMethods);
			progressInfo?.Invoke("Building Report", 0.7f);
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.AppendLine("---- Atlases ------");
			for (int l = 0; l < numAtlases; l++)
			{
				if (atlases[l] != null)
				{
					stringBuilder.AppendLine("Created Atlas For: " + texPropertyNames[l].name + " h=" + atlases[l].height + " w=" + atlases[l].width);
				}
				else if (allTexturesAreNullAndSameColor[l])
				{
					stringBuilder.AppendLine("Did not create atlas for " + texPropertyNames[l].name + " because all source textures were null.");
				}
			}
			report.Append(stringBuilder.ToString());
			List<MB_MaterialAndUVRect> list = new List<MB_MaterialAndUVRect>();
			for (int m = 0; m < distinctMaterialTextures.Count; m++)
			{
				List<MatAndTransformToMerged> mats = distinctMaterialTextures[m].mats;
				new Rect(0f, 0f, 1f, 1f);
				Rect rect = distinctMaterialTextures[m].ts[0].encapsulatingSamplingRect.GetRect();
				for (int n = 0; n < mats.Count; n++)
				{
					MB_MaterialAndUVRect item = new MB_MaterialAndUVRect(mats[n].mat, array[m], mats[n].samplingRectMatAndUVTiling.GetRect(), mats[n].materialTiling.GetRect(), rect, mats[n].objName);
					if (!list.Contains(item))
					{
						list.Add(item);
					}
				}
			}
			resultAtlasesAndRects.atlases = atlases;
			resultAtlasesAndRects.texPropertyNames = ShaderTextureProperty.GetNames(texPropertyNames);
			resultAtlasesAndRects.mat2rect_map = list;
			progressInfo?.Invoke("Restoring Texture Formats & Read Flags", 0.8f);
			_destroyTemporaryTextures();
			textureEditorMethods?.SetReadFlags(progressInfo);
			if (report != null && LOG_LEVEL >= MB2_LogLevel.info)
			{
				UnityEngine.Debug.Log(report.ToString());
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Time Step 3 Create And Save Atlases part 3 " + ((float)sw.ElapsedMilliseconds - num).ToString("f5"));
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Total time Step 3 Create And Save Atlases " + sw.ElapsedMilliseconds.ToString("f5"));
			}
		}

		private IEnumerator __CreateAtlasesMBTexturePacker(ProgressUpdateDelegate progressInfo, int numAtlases, List<MB_TexSet> distinctMaterialTextures, List<ShaderTextureProperty> texPropertyNames, bool[] allTexturesAreNullAndSameColor, Material resultMaterial, Texture2D[] atlases, MB2_EditorMethodsInterface textureEditorMethods, int _padding)
		{
			Rect[] uvRects;
			if (distinctMaterialTextures.Count == 1 && !_fixOutOfBoundsUVs)
			{
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					UnityEngine.Debug.Log("Only one image per atlas. Will re-use original texture");
				}
				uvRects = new Rect[1]
				{
					new Rect(0f, 0f, 1f, 1f)
				};
				for (int i = 0; i < numAtlases; i++)
				{
					MeshBakerMaterialTexture meshBakerMaterialTexture = distinctMaterialTextures[0].ts[i];
					atlases[i] = meshBakerMaterialTexture.t;
					resultMaterial.SetTexture(texPropertyNames[i].name, atlases[i]);
					resultMaterial.SetTextureScale(texPropertyNames[i].name, meshBakerMaterialTexture.matTilingRect.size);
					resultMaterial.SetTextureOffset(texPropertyNames[i].name, meshBakerMaterialTexture.matTilingRect.min);
				}
			}
			else
			{
				List<Vector2> list = new List<Vector2>();
				for (int j = 0; j < distinctMaterialTextures.Count; j++)
				{
					list.Add(new Vector2(distinctMaterialTextures[j].idealWidth, distinctMaterialTextures[j].idealHeight));
				}
				MB2_TexturePacker mB2_TexturePacker = new MB2_TexturePacker();
				mB2_TexturePacker.doPowerOfTwoTextures = _meshBakerTexturePackerForcePowerOfTwo;
				int atlasSizeX = 1;
				int atlasSizeY = 1;
				int num = _maxAtlasSize;
				uvRects = mB2_TexturePacker.GetRects(list, num, _padding, out atlasSizeX, out atlasSizeY);
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					UnityEngine.Debug.Log("Generated atlas will be " + atlasSizeX + "x" + atlasSizeY + " (Max atlas size for platform: " + num + ")");
				}
				for (int propIdx = 0; propIdx < numAtlases; propIdx++)
				{
					Texture2D texture2D;
					if (allTexturesAreNullAndSameColor[propIdx])
					{
						texture2D = null;
						if (LOG_LEVEL >= MB2_LogLevel.debug)
						{
							UnityEngine.Debug.Log("=== Not creating atlas for " + texPropertyNames[propIdx].name + " because textures are null and default value parameters are the same.");
						}
					}
					else
					{
						if (LOG_LEVEL >= MB2_LogLevel.debug)
						{
							UnityEngine.Debug.Log("=== Creating atlas for " + texPropertyNames[propIdx].name);
						}
						GC.Collect();
						progressInfo?.Invoke("Creating Atlas '" + texPropertyNames[propIdx].name + "'", 0.01f);
						Color[][] atlasPixels = new Color[atlasSizeY][];
						for (int k = 0; k < atlasPixels.Length; k++)
						{
							atlasPixels[k] = new Color[atlasSizeX];
						}
						bool isNormalMap = false;
						if (texPropertyNames[propIdx].isNormalMap)
						{
							isNormalMap = true;
						}
						for (int texSetIdx = 0; texSetIdx < distinctMaterialTextures.Count; texSetIdx++)
						{
							MB_TexSet mB_TexSet = distinctMaterialTextures[texSetIdx];
							if (LOG_LEVEL >= MB2_LogLevel.trace)
							{
								UnityEngine.Debug.Log(string.Format("Adding texture {0} to atlas {1}", (mB_TexSet.ts[propIdx].t == null) ? "null" : mB_TexSet.ts[propIdx].t.ToString(), texPropertyNames[propIdx]));
							}
							Rect rect = uvRects[texSetIdx];
							Texture2D t = mB_TexSet.ts[propIdx].t;
							int targX = Mathf.RoundToInt(rect.x * (float)atlasSizeX);
							int targY = Mathf.RoundToInt(rect.y * (float)atlasSizeY);
							int num2 = Mathf.RoundToInt(rect.width * (float)atlasSizeX);
							int num3 = Mathf.RoundToInt(rect.height * (float)atlasSizeY);
							if (num2 == 0 || num3 == 0)
							{
								UnityEngine.Debug.LogError("Image in atlas has no height or width");
							}
							textureEditorMethods?.SetReadWriteFlag(t, isReadable: true, addToList: true);
							progressInfo?.Invoke(string.Concat("Copying to atlas: '", mB_TexSet.ts[propIdx].t, "'"), 0.02f);
							DRect encapsulatingSamplingRect = mB_TexSet.ts[propIdx].encapsulatingSamplingRect;
							yield return CopyScaledAndTiledToAtlas(mB_TexSet.ts[propIdx], mB_TexSet, texPropertyNames[propIdx], encapsulatingSamplingRect, targX, targY, num2, num3, _fixOutOfBoundsUVs, _maxTilingBakeSize, atlasPixels, atlasSizeX, isNormalMap, progressInfo);
						}
						yield return numAtlases;
						progressInfo?.Invoke("Applying changes to atlas: '" + texPropertyNames[propIdx].name + "'", 0.03f);
						texture2D = new Texture2D(atlasSizeX, atlasSizeY, TextureFormat.ARGB32, mipChain: true);
						for (int l = 0; l < atlasPixels.Length; l++)
						{
							texture2D.SetPixels(0, l, atlasSizeX, 1, atlasPixels[l]);
						}
						texture2D.Apply();
						if (LOG_LEVEL >= MB2_LogLevel.debug)
						{
							UnityEngine.Debug.Log("Saving atlas " + texPropertyNames[propIdx].name + " w=" + texture2D.width + " h=" + texture2D.height);
						}
					}
					atlases[propIdx] = texture2D;
					progressInfo?.Invoke("Saving atlas: '" + texPropertyNames[propIdx].name + "'", 0.04f);
					if (_saveAtlasesAsAssets && textureEditorMethods != null)
					{
						textureEditorMethods.SaveAtlasToAssetDatabase(atlases[propIdx], texPropertyNames[propIdx], propIdx, resultMaterial);
					}
					else
					{
						resultMaterial.SetTexture(texPropertyNames[propIdx].name, atlases[propIdx]);
					}
					resultMaterial.SetTextureOffset(texPropertyNames[propIdx].name, Vector2.zero);
					resultMaterial.SetTextureScale(texPropertyNames[propIdx].name, Vector2.one);
					_destroyTemporaryTextures();
				}
			}
			__createAtlasesMBTexturePacker = uvRects;
		}

		private Rect[] __CreateAtlasesMBTexturePackerFast(ProgressUpdateDelegate progressInfo, int numAtlases, List<MB_TexSet> distinctMaterialTextures, List<ShaderTextureProperty> texPropertyNames, bool[] allTexturesAreNullAndSameColor, Material resultMaterial, Texture2D[] atlases, MB2_EditorMethodsInterface textureEditorMethods, int _padding)
		{
			Rect[] array;
			if (distinctMaterialTextures.Count == 1 && !_fixOutOfBoundsUVs)
			{
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					UnityEngine.Debug.Log("Only one image per atlas. Will re-use original texture");
				}
				array = new Rect[1]
				{
					new Rect(0f, 0f, 1f, 1f)
				};
				for (int i = 0; i < numAtlases; i++)
				{
					MeshBakerMaterialTexture meshBakerMaterialTexture = distinctMaterialTextures[0].ts[i];
					atlases[i] = meshBakerMaterialTexture.t;
					resultMaterial.SetTexture(texPropertyNames[i].name, atlases[i]);
					resultMaterial.SetTextureScale(texPropertyNames[i].name, meshBakerMaterialTexture.matTilingRect.size);
					resultMaterial.SetTextureOffset(texPropertyNames[i].name, meshBakerMaterialTexture.matTilingRect.min);
				}
			}
			else
			{
				List<Vector2> list = new List<Vector2>();
				for (int j = 0; j < distinctMaterialTextures.Count; j++)
				{
					list.Add(new Vector2(distinctMaterialTextures[j].idealWidth, distinctMaterialTextures[j].idealHeight));
				}
				MB2_TexturePacker obj = new MB2_TexturePacker
				{
					doPowerOfTwoTextures = _meshBakerTexturePackerForcePowerOfTwo
				};
				int outW = 1;
				int outH = 1;
				int num = _maxAtlasSize;
				array = obj.GetRects(list, num, _padding, out outW, out outH);
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					UnityEngine.Debug.Log("Generated atlas will be " + outW + "x" + outH + " (Max atlas size for platform: " + num + ")");
				}
				GameObject gameObject = null;
				try
				{
					gameObject = new GameObject("MBrenderAtlasesGO");
					MB3_AtlasPackerRenderTexture mB3_AtlasPackerRenderTexture = gameObject.AddComponent<MB3_AtlasPackerRenderTexture>();
					gameObject.AddComponent<Camera>();
					if (_considerNonTextureProperties && LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning("Blend Non-Texture Properties has limited functionality when used with Mesh Baker Texture Packer Fast.");
					}
					for (int k = 0; k < numAtlases; k++)
					{
						Texture2D texture2D = null;
						if (allTexturesAreNullAndSameColor[k])
						{
							texture2D = null;
							if (LOG_LEVEL >= MB2_LogLevel.debug)
							{
								UnityEngine.Debug.Log("Not creating atlas for " + texPropertyNames[k].name + " because textures are null and default value parameters are the same.");
							}
						}
						else
						{
							GC.Collect();
							progressInfo?.Invoke("Creating Atlas '" + texPropertyNames[k].name + "'", 0.01f);
							if (LOG_LEVEL >= MB2_LogLevel.debug)
							{
								UnityEngine.Debug.Log("About to render " + texPropertyNames[k].name + " isNormal=" + texPropertyNames[k].isNormalMap);
							}
							mB3_AtlasPackerRenderTexture.LOG_LEVEL = LOG_LEVEL;
							mB3_AtlasPackerRenderTexture.width = outW;
							mB3_AtlasPackerRenderTexture.height = outH;
							mB3_AtlasPackerRenderTexture.padding = _padding;
							mB3_AtlasPackerRenderTexture.rects = array;
							mB3_AtlasPackerRenderTexture.textureSets = distinctMaterialTextures;
							mB3_AtlasPackerRenderTexture.indexOfTexSetToRender = k;
							mB3_AtlasPackerRenderTexture.texPropertyName = texPropertyNames[k];
							mB3_AtlasPackerRenderTexture.isNormalMap = texPropertyNames[k].isNormalMap;
							mB3_AtlasPackerRenderTexture.fixOutOfBoundsUVs = _fixOutOfBoundsUVs;
							mB3_AtlasPackerRenderTexture.considerNonTextureProperties = _considerNonTextureProperties;
							mB3_AtlasPackerRenderTexture.resultMaterialTextureBlender = resultMaterialTextureBlender;
							texture2D = mB3_AtlasPackerRenderTexture.OnRenderAtlas(this);
							if (LOG_LEVEL >= MB2_LogLevel.debug)
							{
								UnityEngine.Debug.Log("Saving atlas " + texPropertyNames[k].name + " w=" + texture2D.width + " h=" + texture2D.height + " id=" + texture2D.GetInstanceID());
							}
						}
						atlases[k] = texture2D;
						progressInfo?.Invoke("Saving atlas: '" + texPropertyNames[k].name + "'", 0.04f);
						if (_saveAtlasesAsAssets && textureEditorMethods != null)
						{
							textureEditorMethods.SaveAtlasToAssetDatabase(atlases[k], texPropertyNames[k], k, resultMaterial);
						}
						else
						{
							resultMaterial.SetTexture(texPropertyNames[k].name, atlases[k]);
						}
						resultMaterial.SetTextureOffset(texPropertyNames[k].name, Vector2.zero);
						resultMaterial.SetTextureScale(texPropertyNames[k].name, Vector2.one);
						_destroyTemporaryTextures();
					}
				}
				catch (Exception exception)
				{
					UnityEngine.Debug.LogException(exception);
				}
				finally
				{
					if (gameObject != null)
					{
						MB_Utility.Destroy(gameObject);
					}
				}
			}
			return array;
		}

		private Rect[] __CreateAtlasesUnityTexturePacker(ProgressUpdateDelegate progressInfo, int numAtlases, List<MB_TexSet> distinctMaterialTextures, List<ShaderTextureProperty> texPropertyNames, bool[] allTexturesAreNullAndSameColor, Material resultMaterial, Texture2D[] atlases, MB2_EditorMethodsInterface textureEditorMethods, int _padding)
		{
			Rect[] array;
			if (distinctMaterialTextures.Count == 1 && !_fixOutOfBoundsUVs)
			{
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					UnityEngine.Debug.Log("Only one image per atlas. Will re-use original texture");
				}
				array = new Rect[1]
				{
					new Rect(0f, 0f, 1f, 1f)
				};
				for (int i = 0; i < numAtlases; i++)
				{
					MeshBakerMaterialTexture meshBakerMaterialTexture = distinctMaterialTextures[0].ts[i];
					atlases[i] = meshBakerMaterialTexture.t;
					resultMaterial.SetTexture(texPropertyNames[i].name, atlases[i]);
					resultMaterial.SetTextureScale(texPropertyNames[i].name, meshBakerMaterialTexture.matTilingRect.size);
					resultMaterial.SetTextureOffset(texPropertyNames[i].name, meshBakerMaterialTexture.matTilingRect.min);
				}
			}
			else
			{
				long num = 0L;
				int w = 1;
				int h = 1;
				array = null;
				for (int j = 0; j < numAtlases; j++)
				{
					Texture2D texture2D = null;
					if (allTexturesAreNullAndSameColor[j])
					{
						texture2D = null;
					}
					else
					{
						if (LOG_LEVEL >= MB2_LogLevel.debug)
						{
							UnityEngine.Debug.LogWarning("Beginning loop " + j + " num temporary textures " + _temporaryTextures.Count);
						}
						for (int k = 0; k < distinctMaterialTextures.Count; k++)
						{
							MB_TexSet mB_TexSet = distinctMaterialTextures[k];
							int idealWidth = mB_TexSet.idealWidth;
							int idealHeight = mB_TexSet.idealHeight;
							Texture2D texture2D2 = mB_TexSet.ts[j].t;
							if (texture2D2 == null)
							{
								texture2D2 = (mB_TexSet.ts[j].t = _createTemporaryTexture(idealWidth, idealHeight, TextureFormat.ARGB32, mipMaps: true));
								if (_considerNonTextureProperties && resultMaterialTextureBlender != null)
								{
									Color colorIfNoTexture = resultMaterialTextureBlender.GetColorIfNoTexture(mB_TexSet.mats[0].mat, texPropertyNames[j]);
									if (LOG_LEVEL >= MB2_LogLevel.trace)
									{
										UnityEngine.Debug.Log("Setting texture to solid color " + colorIfNoTexture);
									}
									MB_Utility.setSolidColor(texture2D2, colorIfNoTexture);
								}
								else
								{
									Color colorIfNoTexture2 = GetColorIfNoTexture(texPropertyNames[j]);
									MB_Utility.setSolidColor(texture2D2, colorIfNoTexture2);
								}
							}
							progressInfo?.Invoke("Adjusting for scale and offset " + texture2D2, 0.01f);
							textureEditorMethods?.SetReadWriteFlag(texture2D2, isReadable: true, addToList: true);
							texture2D2 = GetAdjustedForScaleAndOffset2(mB_TexSet.ts[j], mB_TexSet.obUVoffset, mB_TexSet.obUVscale);
							if (texture2D2.width != idealWidth || texture2D2.height != idealHeight)
							{
								progressInfo?.Invoke(string.Concat("Resizing texture '", texture2D2, "'"), 0.01f);
								if (LOG_LEVEL >= MB2_LogLevel.debug)
								{
									UnityEngine.Debug.LogWarning("Copying and resizing texture " + texPropertyNames[j].name + " from " + texture2D2.width + "x" + texture2D2.height + " to " + idealWidth + "x" + idealHeight);
								}
								texture2D2 = _resizeTexture(texture2D2, idealWidth, idealHeight);
							}
							mB_TexSet.ts[j].t = texture2D2;
						}
						Texture2D[] array2 = new Texture2D[distinctMaterialTextures.Count];
						for (int l = 0; l < distinctMaterialTextures.Count; l++)
						{
							Texture2D texture2D3 = distinctMaterialTextures[l].ts[j].t;
							num += texture2D3.width * texture2D3.height;
							if (_considerNonTextureProperties)
							{
								texture2D3 = TintTextureWithTextureCombiner(texture2D3, distinctMaterialTextures[l], texPropertyNames[j]);
							}
							array2[l] = texture2D3;
						}
						textureEditorMethods?.CheckBuildSettings(num);
						if (Math.Sqrt(num) > 3500.0 && LOG_LEVEL >= MB2_LogLevel.warn)
						{
							UnityEngine.Debug.LogWarning("The maximum possible atlas size is 4096. Textures may be shrunk");
						}
						texture2D = new Texture2D(1, 1, TextureFormat.ARGB32, mipChain: true);
						progressInfo?.Invoke("Packing texture atlas " + texPropertyNames[j].name, 0.25f);
						if (j == 0)
						{
							progressInfo?.Invoke("Estimated min size of atlases: " + Math.Sqrt(num).ToString("F0"), 0.1f);
							if (LOG_LEVEL >= MB2_LogLevel.info)
							{
								UnityEngine.Debug.Log("Estimated atlas minimum size:" + Math.Sqrt(num).ToString("F0"));
							}
							_addWatermark(array2);
							if (distinctMaterialTextures.Count == 1 && !_fixOutOfBoundsUVs)
							{
								array = new Rect[1]
								{
									new Rect(0f, 0f, 1f, 1f)
								};
								texture2D = _copyTexturesIntoAtlas(array2, _padding, array, array2[0].width, array2[0].height);
							}
							else
							{
								int maximumAtlasSize = 4096;
								array = texture2D.PackTextures(array2, _padding, maximumAtlasSize, makeNoLongerReadable: false);
							}
							if (LOG_LEVEL >= MB2_LogLevel.info)
							{
								UnityEngine.Debug.Log("After pack textures atlas size " + texture2D.width + " " + texture2D.height);
							}
							w = texture2D.width;
							h = texture2D.height;
							texture2D.Apply();
						}
						else
						{
							progressInfo?.Invoke("Copying Textures Into: " + texPropertyNames[j].name, 0.1f);
							texture2D = _copyTexturesIntoAtlas(array2, _padding, array, w, h);
						}
					}
					atlases[j] = texture2D;
					if (_saveAtlasesAsAssets)
					{
						textureEditorMethods?.SaveAtlasToAssetDatabase(atlases[j], texPropertyNames[j], j, resultMaterial);
					}
					resultMaterial.SetTextureOffset(texPropertyNames[j].name, Vector2.zero);
					resultMaterial.SetTextureScale(texPropertyNames[j].name, Vector2.one);
					_destroyTemporaryTextures();
					GC.Collect();
				}
			}
			return array;
		}

		private void _addWatermark(Texture2D[] texToPack)
		{
		}

		private Texture2D _addWatermark(Texture2D texToPack)
		{
			return texToPack;
		}

		private Texture2D _copyTexturesIntoAtlas(Texture2D[] texToPack, int padding, Rect[] rs, int w, int h)
		{
			Texture2D texture2D = new Texture2D(w, h, TextureFormat.ARGB32, mipChain: true);
			MB_Utility.setSolidColor(texture2D, Color.clear);
			for (int i = 0; i < rs.Length; i++)
			{
				Rect rect = rs[i];
				Texture2D texture2D2 = texToPack[i];
				int x = Mathf.RoundToInt(rect.x * (float)w);
				int y = Mathf.RoundToInt(rect.y * (float)h);
				int num = Mathf.RoundToInt(rect.width * (float)w);
				int num2 = Mathf.RoundToInt(rect.height * (float)h);
				if (texture2D2.width != num && texture2D2.height != num2)
				{
					texture2D2 = MB_Utility.resampleTexture(texture2D2, num, num2);
					_temporaryTextures.Add(texture2D2);
				}
				texture2D.SetPixels(x, y, num, num2, texture2D2.GetPixels());
			}
			texture2D.Apply();
			return texture2D;
		}

		private bool IsPowerOfTwo(int x)
		{
			return (x & (x - 1)) == 0;
		}

		private void MergeOverlappingDistinctMaterialTexturesAndCalcMaterialSubrects(List<MB_TexSet> distinctMaterialTextures, bool fixOutOfBoundsUVs)
		{
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("MergeOverlappingDistinctMaterialTexturesAndCalcMaterialSubrects");
			}
			int num = 0;
			for (int i = 0; i < distinctMaterialTextures.Count; i++)
			{
				MB_TexSet mB_TexSet = distinctMaterialTextures[i];
				int num2 = -1;
				bool flag = true;
				DRect dRect = default(DRect);
				for (int j = 0; j < mB_TexSet.ts.Length; j++)
				{
					if (num2 != -1)
					{
						if (mB_TexSet.ts[j].t != null && dRect != mB_TexSet.ts[j].matTilingRect)
						{
							flag = false;
						}
					}
					else if (mB_TexSet.ts[j].t != null)
					{
						num2 = j;
						dRect = mB_TexSet.ts[j].matTilingRect;
					}
				}
				if (flag)
				{
					mB_TexSet.allTexturesUseSameMatTiling = true;
					continue;
				}
				if (LOG_LEVEL <= MB2_LogLevel.info)
				{
					UnityEngine.Debug.Log($"Textures in material(s) do not all use the same material tiling. This set of textures will not be considered for merge: {mB_TexSet.GetDescription()} ");
				}
				mB_TexSet.allTexturesUseSameMatTiling = false;
			}
			for (int k = 0; k < distinctMaterialTextures.Count; k++)
			{
				MB_TexSet mB_TexSet2 = distinctMaterialTextures[k];
				DRect obUVRectIfTilingSame = ((!fixOutOfBoundsUVs) ? new DRect(0.0, 0.0, 1.0, 1.0) : new DRect(mB_TexSet2.obUVoffset, mB_TexSet2.obUVscale));
				for (int l = 0; l < mB_TexSet2.mats.Count; l++)
				{
					mB_TexSet2.mats[l].obUVRectIfTilingSame = obUVRectIfTilingSame;
					mB_TexSet2.mats[l].objName = distinctMaterialTextures[k].gos[0].name;
				}
				mB_TexSet2.CalcInitialFullSamplingRects(fixOutOfBoundsUVs);
				if (mB_TexSet2.allTexturesUseSameMatTiling)
				{
					mB_TexSet2.CalcMatAndUVSamplingRectsIfAllMatTilingSame();
				}
			}
			List<int> list = new List<int>();
			for (int m = 0; m < distinctMaterialTextures.Count; m++)
			{
				MB_TexSet mB_TexSet3 = distinctMaterialTextures[m];
				for (int n = m + 1; n < distinctMaterialTextures.Count; n++)
				{
					MB_TexSet mB_TexSet4 = distinctMaterialTextures[n];
					if (!mB_TexSet4.AllTexturesAreSameForMerge(mB_TexSet3, _considerNonTextureProperties, resultMaterialTextureBlender))
					{
						continue;
					}
					double num3 = 0.0;
					double num4 = 0.0;
					DRect dRect2 = default(DRect);
					int num5 = -1;
					for (int num6 = 0; num6 < mB_TexSet3.ts.Length; num6++)
					{
						if (mB_TexSet3.ts[num6].t != null && num5 == -1)
						{
							num5 = num6;
						}
					}
					if (num5 != -1)
					{
						DRect uvRect = mB_TexSet4.mats[0].samplingRectMatAndUVTiling;
						for (int num7 = 1; num7 < mB_TexSet4.mats.Count; num7++)
						{
							uvRect = MB3_UVTransformUtility.GetEncapsulatingRect(ref uvRect, ref mB_TexSet4.mats[num7].samplingRectMatAndUVTiling);
						}
						DRect uvRect2 = mB_TexSet3.mats[0].samplingRectMatAndUVTiling;
						for (int num8 = 1; num8 < mB_TexSet3.mats.Count; num8++)
						{
							uvRect2 = MB3_UVTransformUtility.GetEncapsulatingRect(ref uvRect2, ref mB_TexSet3.mats[num8].samplingRectMatAndUVTiling);
						}
						dRect2 = MB3_UVTransformUtility.GetEncapsulatingRect(ref uvRect, ref uvRect2);
						num3 += dRect2.width * dRect2.height;
						num4 += uvRect.width * uvRect.height + uvRect2.width * uvRect2.height;
					}
					else
					{
						dRect2 = new DRect(0f, 0f, 1f, 1f);
					}
					if (num3 < num4)
					{
						num++;
						StringBuilder stringBuilder = null;
						if (LOG_LEVEL >= MB2_LogLevel.info)
						{
							stringBuilder = new StringBuilder();
							stringBuilder.AppendFormat("About To Merge:\n   TextureSet1 {0}\n   TextureSet2 {1}\n", mB_TexSet4.GetDescription(), mB_TexSet3.GetDescription());
							if (LOG_LEVEL >= MB2_LogLevel.trace)
							{
								for (int num9 = 0; num9 < mB_TexSet4.mats.Count; num9++)
								{
									stringBuilder.AppendFormat("tx1 Mat {0} matAndMeshUVRect {1} fullSamplingRect {2}\n", mB_TexSet4.mats[num9].mat, mB_TexSet4.mats[num9].samplingRectMatAndUVTiling, mB_TexSet4.ts[0].encapsulatingSamplingRect);
								}
								for (int num10 = 0; num10 < mB_TexSet3.mats.Count; num10++)
								{
									stringBuilder.AppendFormat("tx2 Mat {0} matAndMeshUVRect {1} fullSamplingRect {2}\n", mB_TexSet3.mats[num10].mat, mB_TexSet3.mats[num10].samplingRectMatAndUVTiling, mB_TexSet3.ts[0].encapsulatingSamplingRect);
								}
							}
						}
						for (int num11 = 0; num11 < mB_TexSet3.gos.Count; num11++)
						{
							if (!mB_TexSet4.gos.Contains(mB_TexSet3.gos[num11]))
							{
								mB_TexSet4.gos.Add(mB_TexSet3.gos[num11]);
							}
						}
						for (int num12 = 0; num12 < mB_TexSet3.mats.Count; num12++)
						{
							mB_TexSet4.mats.Add(mB_TexSet3.mats[num12]);
						}
						mB_TexSet4.mats.Sort(new SamplingRectEnclosesComparer());
						for (int num13 = 0; num13 < mB_TexSet4.ts.Length; num13++)
						{
							mB_TexSet4.ts[num13].encapsulatingSamplingRect = dRect2;
						}
						if (!list.Contains(m))
						{
							list.Add(m);
						}
						if (LOG_LEVEL < MB2_LogLevel.debug)
						{
							break;
						}
						if (LOG_LEVEL >= MB2_LogLevel.trace)
						{
							stringBuilder.AppendFormat("=== After Merge TextureSet {0}\n", mB_TexSet4.GetDescription());
							for (int num14 = 0; num14 < mB_TexSet4.mats.Count; num14++)
							{
								stringBuilder.AppendFormat("tx1 Mat {0} matAndMeshUVRect {1} fullSamplingRect {2}\n", mB_TexSet4.mats[num14].mat, mB_TexSet4.mats[num14].samplingRectMatAndUVTiling, mB_TexSet4.ts[0].encapsulatingSamplingRect);
							}
							DRect r = mB_TexSet4.ts[0].encapsulatingSamplingRect;
							MB3_UVTransformUtility.Canonicalize(ref r, 0.0, 0.0);
							for (int num15 = 0; num15 < mB_TexSet4.mats.Count; num15++)
							{
								DRect r2 = mB_TexSet4.mats[num15].samplingRectMatAndUVTiling;
								MB3_UVTransformUtility.Canonicalize(ref r2, r.x, r.y);
								Rect rect = default(Rect);
								DRect r3 = mB_TexSet4.mats[num15].obUVRectIfTilingSame;
								DRect r4 = mB_TexSet4.mats[num15].materialTiling;
								Rect rect2 = r.GetRect();
								rect = MB3_UVTransformUtility.CombineTransforms(ref r3, ref r4).GetRect();
								MB3_UVTransformUtility.Canonicalize(ref rect, (float)r.x, (float)r.y);
								if (!mB_TexSet4.ts[0].encapsulatingSamplingRect.Encloses(mB_TexSet4.mats[num15].samplingRectMatAndUVTiling))
								{
									stringBuilder.AppendFormat(string.Concat("mesh ", mB_TexSet4.mats[num15].objName, "\n uv=", r3, "\n mat=", r4.GetRect().ToString("f5"), "\n samplingRect=", mB_TexSet4.mats[num15].samplingRectMatAndUVTiling.GetRect().ToString("f4"), "\n samplingRectCannonical=", r2.GetRect().ToString("f4"), "\n potentialRect (cannonicalized)=", rect.ToString("f4"), "\n encapsulatingRect ", mB_TexSet4.ts[0].encapsulatingSamplingRect.GetRect().ToString("f4"), "\n encapsulatingRectCannonical=", rect2.ToString("f4"), "\n\n"));
									stringBuilder.AppendFormat(string.Format("Integrity check failed. " + mB_TexSet4.mats[num15].objName + " Encapsulating rect cannonical failed to contain samplingRectMatAndUVTiling cannonical\n"));
								}
							}
						}
						UnityEngine.Debug.Log(stringBuilder.ToString());
						break;
					}
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						UnityEngine.Debug.Log($"Considered merging {mB_TexSet4.GetDescription()} and {mB_TexSet3.GetDescription()} but there was not enough overlap. It is more efficient to bake these to separate rectangles.");
					}
				}
			}
			for (int num16 = list.Count - 1; num16 >= 0; num16--)
			{
				distinctMaterialTextures.RemoveAt(list[num16]);
			}
			list.Clear();
			if (LOG_LEVEL >= MB2_LogLevel.info)
			{
				UnityEngine.Debug.Log($"MergeOverlappingDistinctMaterialTexturesAndCalcMaterialSubrects complete merged {num}");
			}
		}

		private Vector2 GetAdjustedForScaleAndOffset2Dimensions(MeshBakerMaterialTexture source, Vector2 obUVoffset, Vector2 obUVscale)
		{
			if (source.matTilingRect.x == 0.0 && source.matTilingRect.y == 0.0 && source.matTilingRect.width == 1.0 && source.matTilingRect.height == 1.0)
			{
				if (!_fixOutOfBoundsUVs)
				{
					return new Vector2(source.t.width, source.t.height);
				}
				if (obUVoffset.x == 0f && obUVoffset.y == 0f && obUVscale.x == 1f && obUVscale.y == 1f)
				{
					return new Vector2(source.t.width, source.t.height);
				}
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log(string.Concat("GetAdjustedForScaleAndOffset2Dimensions: ", source.t, " ", obUVoffset, " ", obUVscale));
			}
			float num = (float)source.encapsulatingSamplingRect.width * (float)source.t.width;
			float num2 = (float)source.encapsulatingSamplingRect.height * (float)source.t.height;
			if (num > (float)_maxTilingBakeSize)
			{
				num = _maxTilingBakeSize;
			}
			if (num2 > (float)_maxTilingBakeSize)
			{
				num2 = _maxTilingBakeSize;
			}
			if (num < 1f)
			{
				num = 1f;
			}
			if (num2 < 1f)
			{
				num2 = 1f;
			}
			return new Vector2(num, num2);
		}

		public Texture2D GetAdjustedForScaleAndOffset2(MeshBakerMaterialTexture source, Vector2 obUVoffset, Vector2 obUVscale)
		{
			if (source.matTilingRect.x == 0.0 && source.matTilingRect.y == 0.0 && source.matTilingRect.width == 1.0 && source.matTilingRect.height == 1.0)
			{
				if (!_fixOutOfBoundsUVs)
				{
					return source.t;
				}
				if (obUVoffset.x == 0f && obUVoffset.y == 0f && obUVscale.x == 1f && obUVscale.y == 1f)
				{
					return source.t;
				}
			}
			Vector2 adjustedForScaleAndOffset2Dimensions = GetAdjustedForScaleAndOffset2Dimensions(source, obUVoffset, obUVscale);
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.LogWarning(string.Concat("GetAdjustedForScaleAndOffset2: ", source.t, " ", obUVoffset, " ", obUVscale));
			}
			float x = adjustedForScaleAndOffset2Dimensions.x;
			float y = adjustedForScaleAndOffset2Dimensions.y;
			float num = (float)source.matTilingRect.width;
			float num2 = (float)source.matTilingRect.height;
			float num3 = (float)source.matTilingRect.x;
			float num4 = (float)source.matTilingRect.y;
			if (_fixOutOfBoundsUVs)
			{
				num *= obUVscale.x;
				num2 *= obUVscale.y;
				num3 = (float)(source.matTilingRect.x * (double)obUVscale.x + (double)obUVoffset.x);
				num4 = (float)(source.matTilingRect.y * (double)obUVscale.y + (double)obUVoffset.y);
			}
			Texture2D texture2D = _createTemporaryTexture((int)x, (int)y, TextureFormat.ARGB32, mipMaps: true);
			for (int i = 0; i < texture2D.width; i++)
			{
				for (int j = 0; j < texture2D.height; j++)
				{
					float u = (float)i / x * num + num3;
					float v = (float)j / y * num2 + num4;
					texture2D.SetPixel(i, j, source.t.GetPixelBilinear(u, v));
				}
			}
			texture2D.Apply();
			return texture2D;
		}

		internal static DRect GetSourceSamplingRect(MeshBakerMaterialTexture source, Vector2 obUVoffset, Vector2 obUVscale)
		{
			DRect r = source.matTilingRect;
			DRect r2 = new DRect(obUVoffset, obUVscale);
			return MB3_UVTransformUtility.CombineTransforms(ref r, ref r2);
		}

		private Texture2D TintTextureWithTextureCombiner(Texture2D t, MB_TexSet sourceMaterial, ShaderTextureProperty shaderPropertyName)
		{
			if (LOG_LEVEL >= MB2_LogLevel.trace)
			{
				UnityEngine.Debug.Log($"Blending texture {t.name} mat {sourceMaterial.mats[0].mat} with non-texture properties using TextureBlender {resultMaterialTextureBlender}");
			}
			resultMaterialTextureBlender.OnBeforeTintTexture(sourceMaterial.mats[0].mat, shaderPropertyName.name);
			t = _createTextureCopy(t);
			for (int i = 0; i < t.height; i++)
			{
				Color[] pixels = t.GetPixels(0, i, t.width, 1);
				for (int j = 0; j < pixels.Length; j++)
				{
					pixels[j] = resultMaterialTextureBlender.OnBlendTexturePixel(shaderPropertyName.name, pixels[j]);
				}
				t.SetPixels(0, i, t.width, 1, pixels);
			}
			t.Apply();
			return t;
		}

		public IEnumerator CopyScaledAndTiledToAtlas(MeshBakerMaterialTexture source, MB_TexSet sourceMaterial, ShaderTextureProperty shaderPropertyName, DRect srcSamplingRect, int targX, int targY, int targW, int targH, bool _fixOutOfBoundsUVs, int maxSize, Color[][] atlasPixels, int atlasWidth, bool isNormalMap, ProgressUpdateDelegate progressInfo = null)
		{
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log(string.Concat("CopyScaledAndTiledToAtlas: ", source.t, " inAtlasX=", targX, " inAtlasY=", targY, " inAtlasW=", targW, " inAtlasH=", targH));
			}
			float num = targW;
			float num2 = targH;
			float num3 = (float)srcSamplingRect.width;
			float num4 = (float)srcSamplingRect.height;
			float num5 = (float)srcSamplingRect.x;
			float num6 = (float)srcSamplingRect.y;
			int w = (int)num;
			int h = (int)num2;
			Texture2D texture2D = source.t;
			if (texture2D == null)
			{
				if (LOG_LEVEL >= MB2_LogLevel.trace)
				{
					UnityEngine.Debug.Log("No source texture creating a 16x16 texture.");
				}
				texture2D = _createTemporaryTexture(16, 16, TextureFormat.ARGB32, mipMaps: true);
				num3 = 1f;
				num4 = 1f;
				if (_considerNonTextureProperties && resultMaterialTextureBlender != null)
				{
					Color colorIfNoTexture = resultMaterialTextureBlender.GetColorIfNoTexture(sourceMaterial.mats[0].mat, shaderPropertyName);
					if (LOG_LEVEL >= MB2_LogLevel.trace)
					{
						UnityEngine.Debug.Log("Setting texture to solid color " + colorIfNoTexture);
					}
					MB_Utility.setSolidColor(texture2D, colorIfNoTexture);
				}
				else
				{
					Color colorIfNoTexture2 = GetColorIfNoTexture(shaderPropertyName);
					MB_Utility.setSolidColor(texture2D, colorIfNoTexture2);
				}
			}
			if (_considerNonTextureProperties && resultMaterialTextureBlender != null)
			{
				texture2D = TintTextureWithTextureCombiner(texture2D, sourceMaterial, shaderPropertyName);
			}
			texture2D = _addWatermark(texture2D);
			for (int k = 0; k < w; k++)
			{
				if (progressInfo != null && w > 0)
				{
					progressInfo("CopyScaledAndTiledToAtlas " + ((float)k / (float)w * 100f).ToString("F0"), 0.2f);
				}
				for (int l = 0; l < h; l++)
				{
					float u = (float)k / num * num3 + num5;
					float v = (float)l / num2 * num4 + num6;
					atlasPixels[targY + l][targX + k] = texture2D.GetPixelBilinear(u, v);
				}
			}
			for (int m = 0; m < w; m++)
			{
				for (int n = 1; n <= atlasPadding; n++)
				{
					atlasPixels[targY - n][targX + m] = atlasPixels[targY][targX + m];
					atlasPixels[targY + h - 1 + n][targX + m] = atlasPixels[targY + h - 1][targX + m];
				}
			}
			for (int num7 = 0; num7 < h; num7++)
			{
				for (int num8 = 1; num8 <= _atlasPadding; num8++)
				{
					atlasPixels[targY + num7][targX - num8] = atlasPixels[targY + num7][targX];
					atlasPixels[targY + num7][targX + w + num8 - 1] = atlasPixels[targY + num7][targX + w - 1];
				}
			}
			for (int i = 1; i <= _atlasPadding; i++)
			{
				for (int j = 1; j <= _atlasPadding; j++)
				{
					atlasPixels[targY - j][targX - i] = atlasPixels[targY][targX];
					atlasPixels[targY + h - 1 + j][targX - i] = atlasPixels[targY + h - 1][targX];
					atlasPixels[targY + h - 1 + j][targX + w + i - 1] = atlasPixels[targY + h - 1][targX + w - 1];
					atlasPixels[targY - j][targX + w + i - 1] = atlasPixels[targY][targX + w - 1];
					yield return null;
				}
				yield return null;
			}
		}

		public Texture2D _createTemporaryTexture(int w, int h, TextureFormat texFormat, bool mipMaps)
		{
			Texture2D texture2D = new Texture2D(w, h, texFormat, mipMaps);
			MB_Utility.setSolidColor(texture2D, Color.clear);
			_temporaryTextures.Add(texture2D);
			return texture2D;
		}

		internal Texture2D _createTextureCopy(Texture2D t)
		{
			Texture2D texture2D = MB_Utility.createTextureCopy(t);
			_temporaryTextures.Add(texture2D);
			return texture2D;
		}

		private Texture2D _resizeTexture(Texture2D t, int w, int h)
		{
			Texture2D texture2D = MB_Utility.resampleTexture(t, w, h);
			_temporaryTextures.Add(texture2D);
			return texture2D;
		}

		private void _destroyTemporaryTextures()
		{
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Destroying " + _temporaryTextures.Count + " temporary textures");
			}
			for (int i = 0; i < _temporaryTextures.Count; i++)
			{
				MB_Utility.Destroy(_temporaryTextures[i]);
			}
			_temporaryTextures.Clear();
		}

		public void SuggestTreatment(List<GameObject> objsToMesh, Material[] resultMaterials, List<ShaderTextureProperty> _customShaderPropNames)
		{
			this._customShaderPropNames = _customShaderPropNames;
			StringBuilder stringBuilder = new StringBuilder();
			Dictionary<int, MB_Utility.MeshAnalysisResult[]> dictionary = new Dictionary<int, MB_Utility.MeshAnalysisResult[]>();
			for (int i = 0; i < objsToMesh.Count; i++)
			{
				GameObject gameObject = objsToMesh[i];
				if (gameObject == null)
				{
					continue;
				}
				Material[] gOMaterials = MB_Utility.GetGOMaterials(objsToMesh[i]);
				if (gOMaterials.Length > 1)
				{
					stringBuilder.AppendFormat("\nObject {0} uses {1} materials. Possible treatments:\n", objsToMesh[i].name, gOMaterials.Length);
					stringBuilder.AppendFormat("  1) Collapse the submeshes together into one submesh in the combined mesh. Each of the original submesh materials will map to a different UV rectangle in the atlas(es) used by the combined material.\n");
					stringBuilder.AppendFormat("  2) Use the multiple materials feature to map submeshes in the source mesh to submeshes in the combined mesh.\n");
				}
				Mesh mesh = MB_Utility.GetMesh(gameObject);
				if (!dictionary.TryGetValue(mesh.GetInstanceID(), out var value))
				{
					value = new MB_Utility.MeshAnalysisResult[mesh.subMeshCount];
					MB_Utility.doSubmeshesShareVertsOrTris(mesh, ref value[0]);
					for (int j = 0; j < mesh.subMeshCount; j++)
					{
						MB_Utility.hasOutOfBoundsUVs(mesh, ref value[j], j);
						value[j].hasOverlappingSubmeshTris = value[0].hasOverlappingSubmeshTris;
						value[j].hasOverlappingSubmeshVerts = value[0].hasOverlappingSubmeshVerts;
					}
					dictionary.Add(mesh.GetInstanceID(), value);
				}
				for (int k = 0; k < gOMaterials.Length; k++)
				{
					if (value[k].hasOutOfBoundsUVs)
					{
						DRect dRect = new DRect(value[k].uvRect);
						stringBuilder.AppendFormat("\nObject {0} submesh={1} material={2} uses UVs outside the range 0,0 .. 1,1 to create tiling that tiles the box {3},{4} .. {5},{6}. This is a problem because the UVs outside the 0,0 .. 1,1 rectangle will pick up neighboring textures in the atlas. Possible Treatments:\n", gameObject, k, gOMaterials[k], dRect.x.ToString("G4"), dRect.y.ToString("G4"), (dRect.x + dRect.width).ToString("G4"), (dRect.y + dRect.height).ToString("G4"));
						stringBuilder.AppendFormat("    1) Ignore the problem. The tiling may not affect result significantly.\n");
						stringBuilder.AppendFormat("    2) Use the 'fix out of bounds UVs' feature to bake the tiling and scale the UVs to fit in the 0,0 .. 1,1 rectangle.\n");
						stringBuilder.AppendFormat("    3) Use the Multiple Materials feature to map the material on this submesh to its own submesh in the combined mesh. No other materials should map to this submesh. This will result in only one texture in the atlas(es) and the UVs should tile correctly.\n");
						stringBuilder.AppendFormat("    4) Combine only meshes that use the same (or subset of) the set of materials on this mesh. The original material(s) can be applied to the result\n");
					}
				}
				if (value[0].hasOverlappingSubmeshVerts)
				{
					stringBuilder.AppendFormat("\nObject {0} has submeshes that share vertices. This is a problem because each vertex can have only one UV coordinate and may be required to map to different positions in the various atlases that are generated. Possible treatments:\n", objsToMesh[i]);
					stringBuilder.AppendFormat(" 1) Ignore the problem. The vertices may not affect the result.\n");
					stringBuilder.AppendFormat(" 2) Use the Multiple Materials feature to map the submeshs that overlap to their own submeshs in the combined mesh. No other materials should map to this submesh. This will result in only one texture in the atlas(es) and the UVs should tile correctly.\n");
					stringBuilder.AppendFormat(" 3) Combine only meshes that use the same (or subset of) the set of materials on this mesh. The original material(s) can be applied to the result\n");
				}
			}
			Dictionary<Material, List<GameObject>> dictionary2 = new Dictionary<Material, List<GameObject>>();
			for (int l = 0; l < objsToMesh.Count; l++)
			{
				if (!(objsToMesh[l] != null))
				{
					continue;
				}
				Material[] gOMaterials2 = MB_Utility.GetGOMaterials(objsToMesh[l]);
				for (int m = 0; m < gOMaterials2.Length; m++)
				{
					if (gOMaterials2[m] != null)
					{
						if (!dictionary2.TryGetValue(gOMaterials2[m], out var value2))
						{
							value2 = new List<GameObject>();
							dictionary2.Add(gOMaterials2[m], value2);
						}
						if (!value2.Contains(objsToMesh[l]))
						{
							value2.Add(objsToMesh[l]);
						}
					}
				}
			}
			List<ShaderTextureProperty> list = new List<ShaderTextureProperty>();
			for (int n = 0; n < resultMaterials.Length; n++)
			{
				_CollectPropertyNames(resultMaterials[n], list);
				foreach (Material key in dictionary2.Keys)
				{
					for (int num = 0; num < list.Count; num++)
					{
						if (!key.HasProperty(list[num].name))
						{
							continue;
						}
						Texture texture = key.GetTexture(list[num].name);
						if (texture != null)
						{
							Vector2 textureOffset = key.GetTextureOffset(list[num].name);
							Vector3 vector = key.GetTextureScale(list[num].name);
							if (textureOffset.x < 0f || textureOffset.x + vector.x > 1f || textureOffset.y < 0f || textureOffset.y + vector.y > 1f)
							{
								stringBuilder.AppendFormat("\nMaterial {0} used by objects {1} uses texture {2} that is tiled (scale={3} offset={4}). If there is more than one texture in the atlas  then Mesh Baker will bake the tiling into the atlas. If the baked tiling is large then quality can be lost. Possible treatments:\n", key, PrintList(dictionary2[key]), texture, vector, textureOffset);
								stringBuilder.AppendFormat("  1) Use the baked tiling.\n");
								stringBuilder.AppendFormat("  2) Use the Multiple Materials feature to map the material on this object/submesh to its own submesh in the combined mesh. No other materials should map to this submesh. The original material can be applied to this submesh.\n");
								stringBuilder.AppendFormat("  3) Combine only meshes that use the same (or subset of) the set of textures on this mesh. The original material can be applied to the result.\n");
							}
						}
					}
				}
			}
			string text = "";
			text = ((stringBuilder.Length != 0) ? ("====== There are possible problems with these meshes that may prevent them from combining well. TREATMENT SUGGESTIONS (copy and paste to text editor if too big) =====\n" + stringBuilder.ToString()) : "====== No problems detected. These meshes should combine well ====\n  If there are problems with the combined meshes please report the problem to digitalOpus.ca so we can improve Mesh Baker.");
			UnityEngine.Debug.Log(text);
		}

		private TextureBlender FindMatchingTextureBlender(string shaderName)
		{
			for (int i = 0; i < textureBlenders.Length; i++)
			{
				if (textureBlenders[i].DoesShaderNameMatch(shaderName))
				{
					return textureBlenders[i];
				}
			}
			return null;
		}

		private void AdjustNonTextureProperties(Material mat, List<ShaderTextureProperty> texPropertyNames, List<MB_TexSet> distinctMaterialTextures, bool considerTintColor, MB2_EditorMethodsInterface editorMethods)
		{
			if (mat == null || texPropertyNames == null)
			{
				return;
			}
			if (_considerNonTextureProperties)
			{
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					UnityEngine.Debug.Log("Adjusting non texture properties using TextureBlender for shader: " + mat.shader.name);
				}
				resultMaterialTextureBlender.SetNonTexturePropertyValuesOnResultMaterial(mat);
				return;
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Adjusting non texture properties on result material");
			}
			for (int i = 0; i < texPropertyNames.Count; i++)
			{
				string name = texPropertyNames[i].name;
				if (name.Equals("_MainTex") && mat.HasProperty("_Color"))
				{
					try
					{
						if (considerTintColor)
						{
							mat.SetColor("_Color", Color.white);
						}
					}
					catch (Exception)
					{
					}
				}
				if (name.Equals("_BumpMap") && mat.HasProperty("_BumpScale"))
				{
					try
					{
						mat.SetFloat("_BumpScale", 1f);
					}
					catch (Exception)
					{
					}
				}
				if (name.Equals("_ParallaxMap") && mat.HasProperty("_Parallax"))
				{
					try
					{
						mat.SetFloat("_Parallax", 0.02f);
					}
					catch (Exception)
					{
					}
				}
				if (name.Equals("_OcclusionMap") && mat.HasProperty("_OcclusionStrength"))
				{
					try
					{
						mat.SetFloat("_OcclusionStrength", 1f);
					}
					catch (Exception)
					{
					}
				}
				if (!name.Equals("_EmissionMap"))
				{
					continue;
				}
				if (mat.HasProperty("_EmissionColor"))
				{
					try
					{
						mat.SetColor("_EmissionColor", new Color(0f, 0f, 0f, 0f));
					}
					catch (Exception)
					{
					}
				}
				if (mat.HasProperty("_EmissionScaleUI"))
				{
					try
					{
						mat.SetFloat("_EmissionScaleUI", 1f);
					}
					catch (Exception)
					{
					}
				}
			}
			editorMethods?.CommitChangesToAssets();
		}

		public static Color GetColorIfNoTexture(ShaderTextureProperty texProperty)
		{
			if (texProperty.isNormalMap)
			{
				return new Color(0.5f, 0.5f, 1f);
			}
			if (texProperty.name.Equals("_ParallaxMap"))
			{
				return new Color(0f, 0f, 0f, 0f);
			}
			if (texProperty.name.Equals("_OcclusionMap"))
			{
				return new Color(1f, 1f, 1f, 1f);
			}
			if (texProperty.name.Equals("_EmissionMap"))
			{
				return new Color(0f, 0f, 0f, 0f);
			}
			if (texProperty.name.Equals("_DetailMask"))
			{
				return new Color(0f, 0f, 0f, 0f);
			}
			return new Color(1f, 1f, 1f, 0f);
		}

		private Color32 ConvertNormalFormatFromUnity_ToStandard(Color32 c)
		{
			Vector3 zero = Vector3.zero;
			zero.x = (float)(int)c.a * 2f - 1f;
			zero.y = (float)(int)c.g * 2f - 1f;
			zero.z = Mathf.Sqrt(1f - zero.x * zero.x - zero.y * zero.y);
			Color32 result = default(Color32);
			result.a = 1;
			result.r = (byte)((zero.x + 1f) * 0.5f);
			result.g = (byte)((zero.y + 1f) * 0.5f);
			result.b = (byte)((zero.z + 1f) * 0.5f);
			return result;
		}

		private float GetSubmeshArea(Mesh m, int submeshIdx)
		{
			if (submeshIdx >= m.subMeshCount || submeshIdx < 0)
			{
				return 0f;
			}
			Vector3[] vertices = m.vertices;
			int[] indices = m.GetIndices(submeshIdx);
			float num = 0f;
			for (int i = 0; i < indices.Length; i += 3)
			{
				Vector3 vector = vertices[indices[i]];
				Vector3 vector2 = vertices[indices[i + 1]];
				Vector3 vector3 = vertices[indices[i + 2]];
				num += Vector3.Cross(vector2 - vector, vector3 - vector).magnitude / 2f;
			}
			return num;
		}

		private string PrintList(List<GameObject> gos)
		{
			StringBuilder stringBuilder = new StringBuilder();
			for (int i = 0; i < gos.Count; i++)
			{
				stringBuilder.Append(string.Concat(gos[i], ","));
			}
			return stringBuilder.ToString();
		}
	}
	public struct DRect
	{
		public double x;

		public double y;

		public double width;

		public double height;

		public Vector2 min => new Vector2((float)x, (float)y);

		public Vector2 max => new Vector2((float)(x + width), (float)(y + width));

		public Vector2 size => new Vector2((float)width, (float)width);

		public DRect(Rect r)
		{
			x = r.x;
			y = r.y;
			width = r.width;
			height = r.height;
		}

		public DRect(Vector2 o, Vector2 s)
		{
			x = o.x;
			y = o.y;
			width = s.x;
			height = s.y;
		}

		public DRect(float xx, float yy, float w, float h)
		{
			x = xx;
			y = yy;
			width = w;
			height = h;
		}

		public DRect(double xx, double yy, double w, double h)
		{
			x = xx;
			y = yy;
			width = w;
			height = h;
		}

		public Rect GetRect()
		{
			return new Rect((float)x, (float)y, (float)width, (float)height);
		}

		public override bool Equals(object obj)
		{
			DRect dRect = (DRect)obj;
			if (dRect.x == x && dRect.y == y && dRect.width == width && dRect.height == height)
			{
				return true;
			}
			return false;
		}

		public static bool operator ==(DRect a, DRect b)
		{
			return a.Equals(b);
		}

		public static bool operator !=(DRect a, DRect b)
		{
			return !a.Equals(b);
		}

		public override string ToString()
		{
			return string.Format("(x={0},y={1},w={2},h={3})", x.ToString("F5"), y.ToString("F5"), width.ToString("F5"), height.ToString("F5"));
		}

		public bool Encloses(DRect smallToTestIfFits)
		{
			double num = smallToTestIfFits.x;
			double num2 = smallToTestIfFits.y;
			double num3 = smallToTestIfFits.x + smallToTestIfFits.width;
			double num4 = smallToTestIfFits.y + smallToTestIfFits.height;
			double num5 = x;
			double num6 = y;
			double num7 = x + width;
			double num8 = y + height;
			if (num5 <= num && num <= num7 && num5 <= num3 && num3 <= num7 && num6 <= num2 && num2 <= num8 && num6 <= num4)
			{
				return num4 <= num8;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return x.GetHashCode() ^ y.GetHashCode() ^ width.GetHashCode() ^ height.GetHashCode();
		}
	}
	public class MB3_UVTransformUtility
	{
		public static void Test()
		{
			DRect t = new DRect(0.5, 0.5, 2.0, 2.0);
			DRect t2 = new DRect(0.25, 0.25, 3.0, 3.0);
			DRect r = InverseTransform(ref t);
			DRect r2 = InverseTransform(ref t2);
			DRect r3 = CombineTransforms(ref t, ref r2);
			UnityEngine.Debug.Log(r);
			UnityEngine.Debug.Log(r3);
			UnityEngine.Debug.Log("one mat trans " + TransformPoint(ref t, new Vector2(1f, 1f)));
			UnityEngine.Debug.Log("one inv mat trans " + TransformPoint(ref r, new Vector2(1f, 1f)).ToString("f4"));
			UnityEngine.Debug.Log("zero " + TransformPoint(ref r3, new Vector2(0f, 0f)).ToString("f4"));
			UnityEngine.Debug.Log("one " + TransformPoint(ref r3, new Vector2(1f, 1f)).ToString("f4"));
		}

		public static float TransformX(DRect r, double x)
		{
			return (float)(r.width * x + r.x);
		}

		public static DRect CombineTransforms(ref DRect r1, ref DRect r2)
		{
			return new DRect(r1.x * r2.width + r2.x, r1.y * r2.height + r2.y, r1.width * r2.width, r1.height * r2.height);
		}

		public static Rect CombineTransforms(ref Rect r1, ref Rect r2)
		{
			return new Rect(r1.x * r2.width + r2.x, r1.y * r2.height + r2.y, r1.width * r2.width, r1.height * r2.height);
		}

		public static void Canonicalize(ref DRect r, double minX, double minY)
		{
			r.x -= Mathf.FloorToInt((float)r.x);
			if (r.x < minX)
			{
				r.x += Mathf.CeilToInt((float)minX);
			}
			r.y -= Mathf.FloorToInt((float)r.y);
			if (r.y < minY)
			{
				r.y += Mathf.CeilToInt((float)minY);
			}
		}

		public static void Canonicalize(ref Rect r, float minX, float minY)
		{
			r.x -= Mathf.FloorToInt(r.x);
			if (r.x < minX)
			{
				r.x += Mathf.CeilToInt(minX);
			}
			r.y -= Mathf.FloorToInt(r.y);
			if (r.y < minY)
			{
				r.y += Mathf.CeilToInt(minY);
			}
		}

		public static DRect InverseTransform(ref DRect t)
		{
			DRect result = default(DRect);
			result.x = (0.0 - t.x) / t.width;
			result.y = (0.0 - t.y) / t.height;
			result.width = 1.0 / t.width;
			result.height = 1.0 / t.height;
			return result;
		}

		public static DRect GetEncapsulatingRect(ref DRect uvRect1, ref DRect uvRect2)
		{
			double x = uvRect1.x;
			double y = uvRect1.y;
			double num = uvRect1.x + uvRect1.width;
			double num2 = uvRect1.y + uvRect1.height;
			double x2 = uvRect2.x;
			double y2 = uvRect2.y;
			double num3 = uvRect2.x + uvRect2.width;
			double num4 = uvRect2.y + uvRect2.height;
			double num5;
			double num6 = (num5 = x);
			double num7;
			double num8 = (num7 = y);
			if (x2 < num6)
			{
				num6 = x2;
			}
			if (x < num6)
			{
				num6 = x;
			}
			if (y2 < num8)
			{
				num8 = y2;
			}
			if (y < num8)
			{
				num8 = y;
			}
			if (num3 > num5)
			{
				num5 = num3;
			}
			if (num > num5)
			{
				num5 = num;
			}
			if (num4 > num7)
			{
				num7 = num4;
			}
			if (num2 > num7)
			{
				num7 = num2;
			}
			return new DRect(num6, num8, num5 - num6, num7 - num8);
		}

		public static bool RectContains(ref DRect bigRect, ref DRect smallToTestIfFits)
		{
			double x = smallToTestIfFits.x;
			double y = smallToTestIfFits.y;
			double num = smallToTestIfFits.x + smallToTestIfFits.width;
			double num2 = smallToTestIfFits.y + smallToTestIfFits.height;
			double num3 = bigRect.x - 0.009999999776482582;
			double num4 = bigRect.y - 0.009999999776482582;
			double num5 = bigRect.x + bigRect.width + 0.019999999552965164;
			double num6 = bigRect.y + bigRect.height + 0.019999999552965164;
			if (num3 <= x && x <= num5 && num3 <= num && num <= num5 && num4 <= y && y <= num6 && num4 <= num2)
			{
				return num2 <= num6;
			}
			return false;
		}

		public static bool RectContains(ref Rect bigRect, ref Rect smallToTestIfFits)
		{
			float x = smallToTestIfFits.x;
			float y = smallToTestIfFits.y;
			float num = smallToTestIfFits.x + smallToTestIfFits.width;
			float num2 = smallToTestIfFits.y + smallToTestIfFits.height;
			float num3 = bigRect.x - 0.01f;
			float num4 = bigRect.y - 0.01f;
			float num5 = bigRect.x + bigRect.width + 0.02f;
			float num6 = bigRect.y + bigRect.height + 0.02f;
			if (num3 <= x && x <= num5 && num3 <= num && num <= num5 && num4 <= y && y <= num6 && num4 <= num2)
			{
				return num2 <= num6;
			}
			return false;
		}

		internal static Vector2 TransformPoint(ref DRect r, Vector2 p)
		{
			return new Vector2((float)(r.width * (double)p.x + r.x), (float)(r.height * (double)p.y + r.y));
		}
	}
	public class MB_Utility
	{
		public struct MeshAnalysisResult
		{
			public Rect uvRect;

			public bool hasOutOfBoundsUVs;

			public bool hasOverlappingSubmeshVerts;

			public bool hasOverlappingSubmeshTris;

			public float submeshArea;
		}

		private class MB_Triangle
		{
			private int submeshIdx;

			private int[] vs = new int[3];

			public bool isSame(object obj)
			{
				MB_Triangle mB_Triangle = (MB_Triangle)obj;
				if (vs[0] == mB_Triangle.vs[0] && vs[1] == mB_Triangle.vs[1] && vs[2] == mB_Triangle.vs[2] && submeshIdx != mB_Triangle.submeshIdx)
				{
					return true;
				}
				return false;
			}

			public bool sharesVerts(MB_Triangle obj)
			{
				if ((vs[0] == obj.vs[0] || vs[0] == obj.vs[1] || vs[0] == obj.vs[2]) && submeshIdx != obj.submeshIdx)
				{
					return true;
				}
				if ((vs[1] == obj.vs[0] || vs[1] == obj.vs[1] || vs[1] == obj.vs[2]) && submeshIdx != obj.submeshIdx)
				{
					return true;
				}
				if ((vs[2] == obj.vs[0] || vs[2] == obj.vs[1] || vs[2] == obj.vs[2]) && submeshIdx != obj.submeshIdx)
				{
					return true;
				}
				return false;
			}

			public void Initialize(int[] ts, int idx, int sIdx)
			{
				vs[0] = ts[idx];
				vs[1] = ts[idx + 1];
				vs[2] = ts[idx + 2];
				submeshIdx = sIdx;
				Array.Sort(vs);
			}
		}

		public static Texture2D createTextureCopy(Texture2D source)
		{
			Texture2D texture2D = new Texture2D(source.width, source.height, TextureFormat.ARGB32, mipChain: true);
			texture2D.SetPixels(source.GetPixels());
			return texture2D;
		}

		public static bool ArrayBIsSubsetOfA(object[] a, object[] b)
		{
			for (int i = 0; i < b.Length; i++)
			{
				bool flag = false;
				for (int j = 0; j < a.Length; j++)
				{
					if (a[j] == b[i])
					{
						flag = true;
						break;
					}
				}
				if (!flag)
				{
					return false;
				}
			}
			return true;
		}

		public static Material[] GetGOMaterials(GameObject go)
		{
			if (go == null)
			{
				return null;
			}
			Material[] array = null;
			Mesh mesh = null;
			MeshRenderer component = go.GetComponent<MeshRenderer>();
			if (component != null)
			{
				array = component.sharedMaterials;
				MeshFilter component2 = go.GetComponent<MeshFilter>();
				if (component2 == null)
				{
					throw new Exception(string.Concat("Object ", go, " has a MeshRenderer but no MeshFilter."));
				}
				mesh = component2.sharedMesh;
			}
			SkinnedMeshRenderer component3 = go.GetComponent<SkinnedMeshRenderer>();
			if (component3 != null)
			{
				array = component3.sharedMaterials;
				mesh = component3.sharedMesh;
			}
			if (array == null)
			{
				UnityEngine.Debug.LogError("Object " + go.name + " does not have a MeshRenderer or a SkinnedMeshRenderer component");
				return null;
			}
			if (mesh == null)
			{
				UnityEngine.Debug.LogError("Object " + go.name + " has a MeshRenderer or SkinnedMeshRenderer but no mesh.");
				return null;
			}
			if (mesh.subMeshCount < array.Length)
			{
				UnityEngine.Debug.LogWarning(string.Concat("Object ", go, " has only ", mesh.subMeshCount, " submeshes and has ", array.Length, " materials. Extra materials do nothing."));
				Material[] array2 = new Material[mesh.subMeshCount];
				Array.Copy(array, array2, array2.Length);
				array = array2;
			}
			return array;
		}

		public static Mesh GetMesh(GameObject go)
		{
			if (go == null)
			{
				return null;
			}
			MeshFilter component = go.GetComponent<MeshFilter>();
			if (component != null)
			{
				return component.sharedMesh;
			}
			SkinnedMeshRenderer component2 = go.GetComponent<SkinnedMeshRenderer>();
			if (component2 != null)
			{
				return component2.sharedMesh;
			}
			UnityEngine.Debug.LogError("Object " + go.name + " does not have a MeshFilter or a SkinnedMeshRenderer component");
			return null;
		}

		public static void SetMesh(GameObject go, Mesh m)
		{
			if (go == null)
			{
				return;
			}
			MeshFilter component = go.GetComponent<MeshFilter>();
			if (component != null)
			{
				component.sharedMesh = m;
				return;
			}
			SkinnedMeshRenderer component2 = go.GetComponent<SkinnedMeshRenderer>();
			if (component2 != null)
			{
				component2.sharedMesh = m;
			}
		}

		public static Renderer GetRenderer(GameObject go)
		{
			if (go == null)
			{
				return null;
			}
			MeshRenderer component = go.GetComponent<MeshRenderer>();
			if (component != null)
			{
				return component;
			}
			SkinnedMeshRenderer component2 = go.GetComponent<SkinnedMeshRenderer>();
			if (component2 != null)
			{
				return component2;
			}
			return null;
		}

		public static void DisableRendererInSource(GameObject go)
		{
			if (go == null)
			{
				return;
			}
			MeshRenderer component = go.GetComponent<MeshRenderer>();
			if (component != null)
			{
				component.enabled = false;
				return;
			}
			SkinnedMeshRenderer component2 = go.GetComponent<SkinnedMeshRenderer>();
			if (component2 != null)
			{
				component2.enabled = false;
			}
		}

		public static bool hasOutOfBoundsUVs(Mesh m, ref Rect uvBounds)
		{
			MeshAnalysisResult putResultHere = default(MeshAnalysisResult);
			bool result = hasOutOfBoundsUVs(m, ref putResultHere);
			uvBounds = putResultHere.uvRect;
			return result;
		}

		public static bool hasOutOfBoundsUVs(Mesh m, ref MeshAnalysisResult putResultHere, int submeshIndex = -1, int uvChannel = 0)
		{
			if (m == null)
			{
				putResultHere.hasOutOfBoundsUVs = false;
				return putResultHere.hasOutOfBoundsUVs;
			}
			return hasOutOfBoundsUVs(uvChannel switch
			{
				0 => m.uv, 
				1 => m.uv2, 
				2 => new Vector2[0], 
				_ => new Vector2[0], 
			}, m, ref putResultHere, submeshIndex);
		}

		public static bool hasOutOfBoundsUVs(Vector2[] uvs, Mesh m, ref MeshAnalysisResult putResultHere, int submeshIndex = -1)
		{
			if (uvs.Length == 0)
			{
				putResultHere.hasOutOfBoundsUVs = false;
				putResultHere.uvRect = default(Rect);
				return putResultHere.hasOutOfBoundsUVs;
			}
			if (submeshIndex >= m.subMeshCount)
			{
				putResultHere.hasOutOfBoundsUVs = false;
				putResultHere.uvRect = default(Rect);
				return putResultHere.hasOutOfBoundsUVs;
			}
			float num;
			float x;
			float num2;
			float y;
			if (submeshIndex >= 0)
			{
				int[] triangles = m.GetTriangles(submeshIndex);
				if (triangles.Length == 0)
				{
					putResultHere.hasOutOfBoundsUVs = false;
					putResultHere.uvRect = default(Rect);
					return putResultHere.hasOutOfBoundsUVs;
				}
				num = (x = uvs[triangles[0]].x);
				num2 = (y = uvs[triangles[0]].y);
				foreach (int num3 in triangles)
				{
					if (uvs[num3].x < num)
					{
						num = uvs[num3].x;
					}
					if (uvs[num3].x > x)
					{
						x = uvs[num3].x;
					}
					if (uvs[num3].y < num2)
					{
						num2 = uvs[num3].y;
					}
					if (uvs[num3].y > y)
					{
						y = uvs[num3].y;
					}
				}
			}
			else
			{
				num = (x = uvs[0].x);
				num2 = (y = uvs[0].y);
				for (int j = 0; j < uvs.Length; j++)
				{
					if (uvs[j].x < num)
					{
						num = uvs[j].x;
					}
					if (uvs[j].x > x)
					{
						x = uvs[j].x;
					}
					if (uvs[j].y < num2)
					{
						num2 = uvs[j].y;
					}
					if (uvs[j].y > y)
					{
						y = uvs[j].y;
					}
				}
			}
			Rect uvRect = default(Rect);
			uvRect.x = num;
			uvRect.y = num2;
			uvRect.width = x - num;
			uvRect.height = y - num2;
			if (x > 1f || num < 0f || y > 1f || num2 < 0f)
			{
				putResultHere.hasOutOfBoundsUVs = true;
			}
			else
			{
				putResultHere.hasOutOfBoundsUVs = false;
			}
			putResultHere.uvRect = uvRect;
			return putResultHere.hasOutOfBoundsUVs;
		}

		public static void setSolidColor(Texture2D t, Color c)
		{
			Color[] pixels = t.GetPixels();
			for (int i = 0; i < pixels.Length; i++)
			{
				pixels[i] = c;
			}
			t.SetPixels(pixels);
			t.Apply();
		}

		public static Texture2D resampleTexture(Texture2D source, int newWidth, int newHeight)
		{
			TextureFormat format = source.format;
			if (format == TextureFormat.ARGB32 || format == TextureFormat.RGBA32 || format == TextureFormat.BGRA32 || format == TextureFormat.RGB24 || format == TextureFormat.Alpha8 || format == TextureFormat.DXT1)
			{
				Texture2D texture2D = new Texture2D(newWidth, newHeight, TextureFormat.ARGB32, mipChain: true);
				float num = newWidth;
				float num2 = newHeight;
				for (int i = 0; i < newWidth; i++)
				{
					for (int j = 0; j < newHeight; j++)
					{
						float u = (float)i / num;
						float v = (float)j / num2;
						texture2D.SetPixel(i, j, source.GetPixelBilinear(u, v));
					}
				}
				texture2D.Apply();
				return texture2D;
			}
			UnityEngine.Debug.LogError("Can only resize textures in formats ARGB32, RGBA32, BGRA32, RGB24, Alpha8 or DXT");
			return null;
		}

		public static bool AreAllSharedMaterialsDistinct(Material[] sharedMaterials)
		{
			for (int i = 0; i < sharedMaterials.Length; i++)
			{
				for (int j = i + 1; j < sharedMaterials.Length; j++)
				{
					if (sharedMaterials[i] == sharedMaterials[j])
					{
						return false;
					}
				}
			}
			return true;
		}

		public static int doSubmeshesShareVertsOrTris(Mesh m, ref MeshAnalysisResult mar)
		{
			MB_Triangle mB_Triangle = new MB_Triangle();
			MB_Triangle mB_Triangle2 = new MB_Triangle();
			int[][] array = new int[m.subMeshCount][];
			for (int i = 0; i < m.subMeshCount; i++)
			{
				array[i] = m.GetTriangles(i);
			}
			bool flag = false;
			bool flag2 = false;
			for (int j = 0; j < m.subMeshCount; j++)
			{
				int[] array2 = array[j];
				for (int k = j + 1; k < m.subMeshCount; k++)
				{
					int[] array3 = array[k];
					for (int l = 0; l < array2.Length; l += 3)
					{
						mB_Triangle.Initialize(array2, l, j);
						for (int n = 0; n < array3.Length; n += 3)
						{
							mB_Triangle2.Initialize(array3, n, k);
							if (mB_Triangle.isSame(mB_Triangle2))
							{
								flag2 = true;
								break;
							}
							if (mB_Triangle.sharesVerts(mB_Triangle2))
							{
								flag = true;
								break;
							}
						}
					}
				}
			}
			if (flag2)
			{
				mar.hasOverlappingSubmeshVerts = true;
				mar.hasOverlappingSubmeshTris = true;
				return 2;
			}
			if (flag)
			{
				mar.hasOverlappingSubmeshVerts = true;
				mar.hasOverlappingSubmeshTris = false;
				return 1;
			}
			mar.hasOverlappingSubmeshTris = false;
			mar.hasOverlappingSubmeshVerts = false;
			return 0;
		}

		public static bool GetBounds(GameObject go, out Bounds b)
		{
			if (go == null)
			{
				UnityEngine.Debug.LogError("go paramater was null");
				b = new Bounds(Vector3.zero, Vector3.zero);
				return false;
			}
			Renderer renderer = GetRenderer(go);
			if (renderer == null)
			{
				UnityEngine.Debug.LogError("GetBounds must be called on an object with a Renderer");
				b = new Bounds(Vector3.zero, Vector3.zero);
				return false;
			}
			if (renderer is MeshRenderer)
			{
				b = renderer.bounds;
				return true;
			}
			if (renderer is SkinnedMeshRenderer)
			{
				b = renderer.bounds;
				return true;
			}
			UnityEngine.Debug.LogError("GetBounds must be called on an object with a MeshRender or a SkinnedMeshRenderer.");
			b = new Bounds(Vector3.zero, Vector3.zero);
			return false;
		}

		public static void Destroy(UnityEngine.Object o)
		{
			if (Application.isPlaying)
			{
				UnityEngine.Object.Destroy(o);
			}
			else
			{
				UnityEngine.Object.DestroyImmediate(o, allowDestroyingAssets: false);
			}
		}
	}
}
namespace MagicalFX
{
	[RequireComponent(typeof(Rigidbody))]
	public class FX_AddForceForward : MonoBehaviour
	{
		public float Force = 300f;

		private void Start()
		{
			Rigidbody component = GetComponent<Rigidbody>();
			if ((bool)component)
			{
				component.AddForce(base.transform.forward * Force);
			}
		}

		private void Update()
		{
		}
	}
	public class FX_Camera : MonoBehaviour
	{
		private Vector3 positionTemp;

		private Vector3 forcePower;

		private void Start()
		{
			CameraEffect.CameraFX = this;
			positionTemp = base.transform.position;
		}

		public void Shake(Vector3 power)
		{
			forcePower = -power;
		}

		private void Update()
		{
			forcePower = Vector3.Lerp(forcePower, Vector3.zero, Time.deltaTime * 5f);
			base.transform.position = positionTemp + new Vector3(Mathf.Cos(Time.time * 80f) * forcePower.x, Mathf.Cos(Time.time * 80f) * forcePower.y, Mathf.Cos(Time.time * 80f) * forcePower.z);
		}
	}
	public static class CameraEffect
	{
		public static FX_Camera CameraFX;

		public static void Shake(Vector3 power)
		{
			if (CameraFX != null)
			{
				CameraFX.Shake(power);
			}
		}
	}
	public class FX_HitSpawner : MonoBehaviour
	{
		public GameObject FXSpawn;

		public bool DestoyOnHit;

		public bool FixRotation;

		public float LifeTimeAfterHit = 1f;

		public float LifeTime;

		private void Start()
		{
		}

		private void Spawn()
		{
			if (FXSpawn != null)
			{
				Quaternion rotation = base.transform.rotation;
				if (!FixRotation)
				{
					rotation = FXSpawn.transform.rotation;
				}
				GameObject gameObject = UnityEngine.Object.Instantiate(FXSpawn, base.transform.position, rotation);
				if (LifeTime > 0f)
				{
					UnityEngine.Object.Destroy(gameObject.gameObject, LifeTime);
				}
			}
			if (DestoyOnHit)
			{
				UnityEngine.Object.Destroy(base.gameObject, LifeTimeAfterHit);
				if ((bool)base.gameObject.GetComponent<Collider>())
				{
					base.gameObject.GetComponent<Collider>().enabled = false;
				}
			}
		}

		private void OnTriggerEnter(Collider other)
		{
			Spawn();
		}

		private void OnCollisionEnter(Collision collision)
		{
			Spawn();
		}
	}
	public class FX_LifeTime : MonoBehaviour
	{
		public float LifeTime = 3f;

		public GameObject SpawnAfterDead;

		private float timeTemp;

		private void Start()
		{
			if (SpawnAfterDead == null)
			{
				UnityEngine.Object.Destroy(base.gameObject, LifeTime);
			}
			else
			{
				timeTemp = Time.time;
			}
		}

		private void Update()
		{
			if (SpawnAfterDead != null && Time.time > timeTemp + LifeTime)
			{
				UnityEngine.Object.Destroy(base.gameObject);
				UnityEngine.Object.Instantiate(SpawnAfterDead, base.transform.position, SpawnAfterDead.transform.rotation);
			}
		}
	}
	[RequireComponent(typeof(Rigidbody))]
	public class FX_Mover : MonoBehaviour
	{
		public float Speed = 1f;

		public Vector3 Noise = Vector3.zero;

		public float Damping = 0.3f;

		private Quaternion direction;

		private void Start()
		{
			direction = Quaternion.LookRotation(base.transform.forward * 1000f);
			base.transform.Rotate(new Vector3(UnityEngine.Random.Range(0f - Noise.x, Noise.x), UnityEngine.Random.Range(0f - Noise.y, Noise.y), UnityEngine.Random.Range(0f - Noise.z, Noise.z)));
		}

		private void LateUpdate()
		{
			base.transform.rotation = Quaternion.Lerp(base.transform.rotation, direction, Damping);
			base.transform.position += base.transform.forward * Speed * Time.deltaTime;
		}
	}
	public class FX_MoverRandom : MonoBehaviour
	{
		public float Speed = 1f;

		public Vector3 Noise = Vector3.zero;

		private void Start()
		{
		}

		private void FixedUpdate()
		{
			base.transform.position += base.transform.forward * Speed * Time.fixedDeltaTime;
			base.transform.position += new Vector3(UnityEngine.Random.Range(0f - Noise.x, Noise.x), UnityEngine.Random.Range(0f - Noise.y, Noise.y), UnityEngine.Random.Range(0f - Noise.z, Noise.z)) * Time.fixedDeltaTime;
		}
	}
	public class FX_ParticlePreview : MonoBehaviour
	{
		public GameObject[] Particles;

		public float RotationSpeed = 3f;

		public int Index;

		public Texture2D logo;

		private void Start()
		{
		}

		public void AddParticle(Vector3 position)
		{
			if (Input.GetKeyDown(KeyCode.UpArrow))
			{
				Index++;
				if (Index >= Particles.Length || Index < 0)
				{
					Index = 0;
				}
			}
			if (Input.GetKeyDown(KeyCode.DownArrow))
			{
				Index--;
				if (Index < 0)
				{
					Index = Particles.Length - 1;
				}
			}
			if (Index >= Particles.Length || Index < 0)
			{
				Index = 0;
			}
			if (Index >= 0 && Index < Particles.Length && Particles.Length != 0)
			{
				UnityEngine.Object.Instantiate(Particles[Index], position, Particles[Index].transform.rotation);
			}
		}

		private void Update()
		{
			base.transform.Rotate(Vector3.up * RotationSpeed * Time.deltaTime);
			RaycastHit hitInfo = default(RaycastHit);
			if (Input.GetButtonDown("Fire1") && Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out hitInfo, 1000f))
			{
				AddParticle(hitInfo.point + Vector3.up);
			}
		}

		private void OnGUI()
		{
			string text = "";
			if (Index >= 0 && Index < Particles.Length && Particles.Length != 0)
			{
				text = Particles[Index].name;
			}
			GUI.Label(new Rect(30f, 30f, Screen.width, 100f), "Change FX : Key Up / Down \nCurrent FX " + text);
			if (GUI.Button(new Rect(30f, 90f, 200f, 30f), "Next"))
			{
				Index++;
				AddParticle(Vector3.up);
			}
			if (GUI.Button(new Rect(30f, 130f, 200f, 30f), "Prev"))
			{
				Index--;
				AddParticle(Vector3.up);
			}
			if ((bool)logo)
			{
				GUI.DrawTexture(new Rect(Screen.width - logo.width - 30, 30f, logo.width, logo.height), logo);
			}
		}
	}
	public class FX_Position : MonoBehaviour
	{
		public Vector3 Offset = new Vector3(0f, 0.001f, 0f);

		public bool Normal;

		public SpawnMode Mode;

		private void Start()
		{
		}

		private void Awake()
		{
			if (Normal)
			{
				PlaceNormal(base.transform.position);
			}
		}

		public void PlaceNormal(Vector3 position)
		{
			if (Physics.Raycast(position, -Vector3.up * 100f, out var hitInfo))
			{
				base.transform.position = hitInfo.point + Offset;
				base.transform.forward = hitInfo.normal;
			}
			else
			{
				base.transform.position = position + Offset;
			}
		}
	}
	public enum SpawnMode
	{
		Static,
		OnDirection
	}
	public class FX_RandomRotation : MonoBehaviour
	{
		public Vector3 Rotation;

		private void Start()
		{
			base.transform.Rotate(new Vector3(UnityEngine.Random.Range(0f - Rotation.x, Rotation.x), UnityEngine.Random.Range(0f - Rotation.y, Rotation.y), UnityEngine.Random.Range(0f - Rotation.z, Rotation.z)));
		}
	}
	public class FX_RandomScale : MonoBehaviour
	{
		public float ScaleMin;

		public float ScaleMax = 1f;

		private void Start()
		{
			base.transform.localScale *= UnityEngine.Random.Range(ScaleMin, ScaleMax);
		}

		private void Update()
		{
		}
	}
	public class FX_Rotation : MonoBehaviour
	{
		public Vector3 Speed = Vector3.up;

		private void Start()
		{
		}

		private void FixedUpdate()
		{
			base.transform.Rotate(Speed);
		}
	}
	public class FX_ShakeCamera : MonoBehaviour
	{
		public Vector3 Power = Vector3.up;

		private void Start()
		{
			CameraEffect.Shake(Power);
		}
	}
	public class FX_SpawnDirection : MonoBehaviour
	{
		public int Number = 10;

		public float Frequency = 1f;

		public bool FixRotation;

		public bool Normal;

		public GameObject FXSpawn;

		public float LifeTime;

		public float TimeSpawn;

		private float timeTemp;

		public bool UseObjectForward = true;

		public Vector3 Direction = Vector3.forward;

		private int counter;

		private void Start()
		{
			counter = 0;
			timeTemp = Time.time;
			if (!(TimeSpawn <= 0f))
			{
				return;
			}
			for (int i = 0; i < Number - 1; i++)
			{
				if (UseObjectForward)
				{
					Direction = base.transform.forward;
				}
				Spawn(base.transform.position + Direction * Frequency * i);
			}
			UnityEngine.Object.Destroy(base.gameObject);
		}

		private void Update()
		{
			if (counter >= Number - 1)
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
			if (TimeSpawn > 0f && Time.time > timeTemp + TimeSpawn)
			{
				if (UseObjectForward)
				{
					Direction = base.transform.forward;
				}
				Spawn(base.transform.position + Direction * Frequency * counter);
				counter++;
				timeTemp = Time.time;
			}
		}

		private void Spawn(Vector3 position)
		{
			if (FXSpawn != null)
			{
				Quaternion rotation = base.transform.rotation;
				if (!FixRotation)
				{
					rotation = FXSpawn.transform.rotation;
				}
				GameObject gameObject = UnityEngine.Object.Instantiate(FXSpawn, position, rotation);
				if (Normal)
				{
					gameObject.transform.forward = base.transform.forward;
				}
				if (LifeTime > 0f)
				{
					UnityEngine.Object.Destroy(gameObject.gameObject, LifeTime);
				}
			}
		}
	}
	public class FX_Spawner : MonoBehaviour
	{
		public bool FixRotation;

		public bool Normal;

		public GameObject FXSpawn;

		public float LifeTime;

		public float TimeSpawn;

		private float timeTemp;

		private void Start()
		{
			timeTemp = Time.time;
			if (FXSpawn != null && TimeSpawn <= 0f)
			{
				Quaternion rotation = base.transform.rotation;
				if (!FixRotation)
				{
					rotation = FXSpawn.transform.rotation;
				}
				GameObject gameObject = UnityEngine.Object.Instantiate(FXSpawn, base.transform.position, rotation);
				if (Normal)
				{
					gameObject.transform.forward = base.transform.forward;
				}
				if (LifeTime > 0f)
				{
					UnityEngine.Object.Destroy(gameObject.gameObject, LifeTime);
				}
			}
		}

		private void Update()
		{
			if (!(TimeSpawn > 0f) || !(Time.time > timeTemp + TimeSpawn))
			{
				return;
			}
			UnityEngine.Debug.Log("spawn");
			if (FXSpawn != null)
			{
				Quaternion rotation = base.transform.rotation;
				if (!FixRotation)
				{
					rotation = FXSpawn.transform.rotation;
				}
				GameObject gameObject = UnityEngine.Object.Instantiate(FXSpawn, base.transform.position, rotation);
				if (Normal)
				{
					gameObject.transform.forward = base.transform.forward;
				}
				if (LifeTime > 0f)
				{
					UnityEngine.Object.Destroy(gameObject.gameObject, LifeTime);
				}
			}
			timeTemp = Time.time;
		}
	}
	public class RainFall : MonoBehaviour
	{
		public GameObject Skill;

		public float AreaSize = 20f;

		public int MaxSpawn = 1000;

		public float Duration = 3f;

		public float DropRate;

		private float timeTemp;

		private float timeTempDuration;

		private int count;

		public bool isRaining;

		private void Start()
		{
			timeTemp = Time.time;
		}

		private void Spawn(Vector3 position)
		{
			if (!(Skill == null))
			{
				UnityEngine.Object.Instantiate(Skill, position, Skill.transform.rotation);
			}
		}

		public void StartRain()
		{
			isRaining = true;
			timeTempDuration = Time.time;
		}

		private void Update()
		{
			if (!isRaining)
			{
				return;
			}
			if (count < MaxSpawn && Time.time < timeTempDuration + Duration)
			{
				if (Time.time > timeTemp + DropRate)
				{
					timeTemp = Time.time;
					count++;
					Spawn(base.transform.position + new Vector3(UnityEngine.Random.Range(0f - AreaSize, AreaSize), 0f, UnityEngine.Random.Range(0f - AreaSize, AreaSize)));
				}
			}
			else
			{
				isRaining = false;
			}
		}
	}
	public class RaisingWall : MonoBehaviour
	{
		public GameObject Skill;

		public float Offset = -7f;

		public float Distance = 2f;

		private void Start()
		{
			if (Skill != null)
			{
				FX_SpawnDirection component = Skill.GetComponent<FX_SpawnDirection>();
				if ((bool)component)
				{
					Offset = -(int)((float)component.Number / 2f);
				}
			}
			Raising();
		}

		private void Raising()
		{
			if (Skill != null)
			{
				UnityEngine.Object.Instantiate(Skill, base.transform.position + base.transform.forward * Distance + base.transform.right * Offset, Skill.transform.rotation).transform.forward = base.transform.right;
			}
		}
	}
	public class Wizard : MonoBehaviour
	{
		public GameObject[] Skills;

		private Vector3 positionLook;

		public int Index;

		public bool Showtime;

		public float Delay = 1f;

		public float RandomSize = 10f;

		public bool RandomSkill;

		private float timeTemp;

		private void Start()
		{
			timeTemp = Time.time;
		}

		private void Update()
		{
			if (Showtime)
			{
				if (Time.time >= timeTemp + Delay)
				{
					if (Physics.Raycast(new Ray(base.transform.position + new Vector3(UnityEngine.Random.Range(0f - RandomSize, RandomSize), 0f, UnityEngine.Random.Range(0f - RandomSize, RandomSize)), -Vector3.up), out var hitInfo, 100f))
					{
						positionLook = hitInfo.point;
					}
					Quaternion rotation = Quaternion.LookRotation((positionLook - base.transform.position).normalized);
					rotation.eulerAngles = new Vector3(0f, rotation.eulerAngles.y, 0f);
					base.transform.rotation = rotation;
					if (RandomSkill)
					{
						Index = UnityEngine.Random.Range(0, Skills.Length);
					}
					else
					{
						Index++;
					}
					Deploy();
					timeTemp = Time.time;
				}
			}
			else
			{
				Aim();
				if (Input.GetButtonDown("Fire1"))
				{
					Deploy();
				}
			}
		}

		private void Deploy()
		{
			if (Index >= Skills.Length || Index < 0)
			{
				Index = 0;
			}
			FX_Position component = Skills[Index].GetComponent<FX_Position>();
			if ((bool)component)
			{
				if (component.Mode == SpawnMode.Static)
				{
					Place(Skills[Index]);
				}
				if (component.Mode == SpawnMode.OnDirection)
				{
					PlaceDirection(Skills[Index]);
				}
			}
			else
			{
				Shoot(Skills[Index]);
			}
		}

		private void Aim()
		{
			if (Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out var hitInfo, 100f))
			{
				positionLook = hitInfo.point;
			}
			Quaternion b = Quaternion.LookRotation((positionLook - base.transform.position).normalized);
			b.eulerAngles = new Vector3(0f, b.eulerAngles.y, 0f);
			base.transform.rotation = Quaternion.Lerp(base.transform.rotation, b, 0.5f);
		}

		private void Shoot(GameObject skill)
		{
			UnityEngine.Object.Instantiate(skill, base.transform.position + Vector3.up * 0.5f + base.transform.forward, skill.transform.rotation).transform.forward = (positionLook - base.transform.position).normalized;
		}

		private void Place(GameObject skill)
		{
			UnityEngine.Object.Instantiate(skill, positionLook, skill.transform.rotation);
		}

		private void PlaceDirection(GameObject skill)
		{
			FX_Position component = UnityEngine.Object.Instantiate(skill, base.transform.position + base.transform.forward, skill.transform.rotation).GetComponent<FX_Position>();
			if (component.Mode == SpawnMode.OnDirection)
			{
				component.transform.forward = base.transform.forward;
			}
		}

		private void OnGUI()
		{
			string text = "";
			if (Index >= 0 && Index < Skills.Length && Skills.Length != 0)
			{
				text = Skills[Index].name;
			}
			GUI.Label(new Rect(30f, 30f, Screen.width, 100f), text ?? "");
			if (GUI.Button(new Rect(30f, Screen.height - 40, 100f, 30f), "Prev"))
			{
				Index--;
			}
			if (GUI.Button(new Rect(140f, Screen.height - 40, 100f, 30f), "Next"))
			{
				Index++;
			}
			if (GUI.Button(new Rect(250f, Screen.height - 40, 100f, 30f), "Show time"))
			{
				Showtime = !Showtime;
			}
			if (Index < 0)
			{
				Index = Skills.Length - 1;
			}
		}
	}
}
namespace IL3DN
{
	public class IL3DN_ChangeWalkingSound : MonoBehaviour
	{
		public AudioClip[] footStepsOverride;

		public AudioClip jumpSound;

		public AudioClip landSound;
	}
	[Serializable]
	public class IL3DN_SimpleMouseLook
	{
		public float XSensitivity = 2f;

		public float YSensitivity = 2f;

		public bool clampVerticalRotation = true;

		public float MinimumX = -90f;

		public float MaximumX = 90f;

		public bool smooth;

		public float smoothTime = 5f;

		public bool lockCursor = true;

		private Quaternion m_CharacterTargetRot;

		private Quaternion m_CameraTargetRot;

		private bool m_cursorIsLocked = true;

		public void Init(Transform character, Transform camera)
		{
			m_CharacterTargetRot = character.localRotation;
			m_CameraTargetRot = camera.localRotation;
		}

		public void LookRotation(Transform character, Transform camera)
		{
			float y = Input.GetAxis("Mouse X") * XSensitivity;
			float num = Input.GetAxis("Mouse Y") * YSensitivity;
			m_CharacterTargetRot *= Quaternion.Euler(0f, y, 0f);
			m_CameraTargetRot *= Quaternion.Euler(0f - num, 0f, 0f);
			if (clampVerticalRotation)
			{
				m_CameraTargetRot = ClampRotationAroundXAxis(m_CameraTargetRot);
			}
			if (smooth)
			{
				character.localRotation = Quaternion.Slerp(character.localRotation, m_CharacterTargetRot, smoothTime * Time.deltaTime);
				camera.localRotation = Quaternion.Slerp(camera.localRotation, m_CameraTargetRot, smoothTime * Time.deltaTime);
			}
			else
			{
				character.localRotation = m_CharacterTargetRot;
				camera.localRotation = m_CameraTargetRot;
			}
			UpdateCursorLock();
		}

		public void SetCursorLock(bool value)
		{
			lockCursor = value;
			if (!lockCursor)
			{
				Cursor.lockState = CursorLockMode.None;
				Cursor.visible = true;
			}
		}

		public void UpdateCursorLock()
		{
			if (lockCursor)
			{
				InternalLockUpdate();
			}
		}

		private void InternalLockUpdate()
		{
			if (Input.GetKeyUp(KeyCode.Escape))
			{
				m_cursorIsLocked = false;
			}
			else if (Input.GetMouseButtonUp(0))
			{
				m_cursorIsLocked = true;
			}
			if (m_cursorIsLocked)
			{
				Cursor.lockState = CursorLockMode.Locked;
				Cursor.visible = false;
			}
			else if (!m_cursorIsLocked)
			{
				Cursor.lockState = CursorLockMode.None;
				Cursor.visible = true;
			}
		}

		private Quaternion ClampRotationAroundXAxis(Quaternion q)
		{
			q.x /= q.w;
			q.y /= q.w;
			q.z /= q.w;
			q.w = 1f;
			float value = 114.59156f * Mathf.Atan(q.x);
			value = Mathf.Clamp(value, MinimumX, MaximumX);
			q.x = Mathf.Tan((float)Math.PI / 360f * value);
			return q;
		}
	}
	[ExecuteInEditMode]
	public class IL3DN_Wind : MonoBehaviour
	{
		private float WindGizmo = 0.5f;

		private void Update()
		{
			Shader.SetGlobalVector("WindDirection", base.transform.rotation * Vector3.back);
		}

		private void OnDrawGizmos()
		{
			_ = (base.transform.position + base.transform.forward).normalized;
			Gizmos.color = Color.green;
			Vector3 up = base.transform.up;
			Vector3 right = base.transform.right;
			Vector3 vector = base.transform.position + base.transform.forward * (WindGizmo * 5f);
			Vector3 vector2 = base.transform.position + base.transform.forward * (WindGizmo * 2.5f);
			Vector3 vector3 = base.transform.position + base.transform.forward * (WindGizmo * 0f);
			float windGizmo = WindGizmo;
			Vector3 vector4 = base.transform.forward * WindGizmo;
			Gizmos.DrawLine(vector3, vector3 - vector4 + up * windGizmo);
			Gizmos.DrawLine(vector3, vector3 - vector4 - up * windGizmo);
			Gizmos.DrawLine(vector3, vector3 - vector4 + right * windGizmo);
			Gizmos.DrawLine(vector3, vector3 - vector4 - right * windGizmo);
			Gizmos.DrawLine(vector3, vector3 - vector4 * 2f);
			Gizmos.DrawLine(vector2, vector2 - vector4 + up * windGizmo);
			Gizmos.DrawLine(vector2, vector2 - vector4 - up * windGizmo);
			Gizmos.DrawLine(vector2, vector2 - vector4 + right * windGizmo);
			Gizmos.DrawLine(vector2, vector2 - vector4 - right * windGizmo);
			Gizmos.DrawLine(vector2, vector2 - vector4 * 2f);
			Gizmos.DrawLine(vector, vector - vector4 + up * windGizmo);
			Gizmos.DrawLine(vector, vector - vector4 - up * windGizmo);
			Gizmos.DrawLine(vector, vector - vector4 + right * windGizmo);
			Gizmos.DrawLine(vector, vector - vector4 - right * windGizmo);
			Gizmos.DrawLine(vector, vector - vector4 * 2f);
		}
	}
}
namespace DG.Tweening
{
	[AddComponentMenu("DOTween/DOTween Animation")]
	public class DOTweenAnimation : ABSAnimationComponent
	{
		public float delay;

		public float duration = 1f;

		public Ease easeType = Ease.OutQuad;

		public AnimationCurve easeCurve = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(1f, 1f));

		public LoopType loopType;

		public int loops = 1;

		public string id = "";

		public bool isRelative;

		public bool isFrom;

		public bool isIndependentUpdate;

		public bool autoKill = true;

		public bool isActive = true;

		public bool isValid;

		public Component target;

		public DOTweenAnimationType animationType;

		public TargetType targetType;

		public TargetType forcedTargetType;

		public bool autoPlay = true;

		public bool useTargetAsV3;

		public float endValueFloat;

		public Vector3 endValueV3;

		public Vector2 endValueV2;

		public Color endValueColor = new Color(1f, 1f, 1f, 1f);

		public string endValueString = "";

		public Rect endValueRect = new Rect(0f, 0f, 0f, 0f);

		public Transform endValueTransform;

		public bool optionalBool0;

		public float optionalFloat0;

		public int optionalInt0;

		public RotateMode optionalRotationMode;

		public ScrambleMode optionalScrambleMode;

		public string optionalString;

		private bool _tweenCreated;

		private int _playCount = -1;

		private void Awake()
		{
			if (isActive && isValid && (animationType != DOTweenAnimationType.Move || !useTargetAsV3))
			{
				CreateTween();
				_tweenCreated = true;
			}
		}

		private void Start()
		{
			if (!_tweenCreated)
			{
				CreateTween();
				_tweenCreated = true;
			}
		}

		private void OnDestroy()
		{
			if (tween != null && tween.IsActive())
			{
				tween.Kill();
			}
			tween = null;
		}

		public void CreateTween()
		{
			if (target == null)
			{
				UnityEngine.Debug.LogWarning($"{base.gameObject.name} :: This tween's target is NULL, because the animation was created with a DOTween Pro version older than 0.9.255. To fix this, exit Play mode then simply select this object, and it will update automatically", base.gameObject);
				return;
			}
			if (forcedTargetType != 0)
			{
				this.targetType = forcedTargetType;
			}
			if (this.targetType == TargetType.Unset)
			{
				this.targetType = TypeToDOTargetType(target.GetType());
			}
			switch (animationType)
			{
			case DOTweenAnimationType.Move:
				if (useTargetAsV3)
				{
					isRelative = false;
					if (endValueTransform == null)
					{
						UnityEngine.Debug.LogWarning($"{base.gameObject.name} :: This tween's TO target is NULL, a Vector3 of (0,0,0) will be used instead", base.gameObject);
						endValueV3 = Vector3.zero;
					}
					else if (this.targetType == TargetType.RectTransform)
					{
						RectTransform rectTransform = endValueTransform as RectTransform;
						if (rectTransform == null)
						{
							UnityEngine.Debug.LogWarning($"{base.gameObject.name} :: This tween's TO target should be a RectTransform, a Vector3 of (0,0,0) will be used instead", base.gameObject);
							endValueV3 = Vector3.zero;
						}
						else
						{
							RectTransform rectTransform2 = target as RectTransform;
							if (rectTransform2 == null)
							{
								UnityEngine.Debug.LogWarning($"{base.gameObject.name} :: This tween's target and TO target are not of the same type. Please reassign the values", base.gameObject);
							}
							else
							{
								endValueV3 = DOTweenUtils46.SwitchToRectTransform(rectTransform, rectTransform2);
							}
						}
					}
					else
					{
						endValueV3 = endValueTransform.position;
					}
				}
				switch (this.targetType)
				{
				case TargetType.RectTransform:
					tween = ((RectTransform)target).DOAnchorPos3D(endValueV3, duration, optionalBool0);
					break;
				case TargetType.Transform:
					tween = ((Transform)target).DOMove(endValueV3, duration, optionalBool0);
					break;
				case TargetType.Rigidbody2D:
					tween = ((Rigidbody2D)target).DOMove(endValueV3, duration, optionalBool0);
					break;
				case TargetType.Rigidbody:
					tween = ((Rigidbody)target).DOMove(endValueV3, duration, optionalBool0);
					break;
				}
				break;
			case DOTweenAnimationType.LocalMove:
				tween = base.transform.DOLocalMove(endValueV3, duration, optionalBool0);
				break;
			case DOTweenAnimationType.Rotate:
				switch (this.targetType)
				{
				case TargetType.Transform:
					tween = ((Transform)target).DORotate(endValueV3, duration, optionalRotationMode);
					break;
				case TargetType.Rigidbody2D:
					tween = ((Rigidbody2D)target).DORotate(endValueFloat, duration);
					break;
				case TargetType.Rigidbody:
					tween = ((Rigidbody)target).DORotate(endValueV3, duration, optionalRotationMode);
					break;
				}
				break;
			case DOTweenAnimationType.LocalRotate:
				tween = base.transform.DOLocalRotate(endValueV3, duration, optionalRotationMode);
				break;
			case DOTweenAnimationType.Scale:
				_ = this.targetType;
				tween = base.transform.DOScale(optionalBool0 ? new Vector3(endValueFloat, endValueFloat, endValueFloat) : endValueV3, duration);
				break;
			case DOTweenAnimationType.UIWidthHeight:
				tween = ((RectTransform)target).DOSizeDelta(optionalBool0 ? new Vector2(endValueFloat, endValueFloat) : endValueV2, duration);
				break;
			case DOTweenAnimationType.Color:
				isRelative = false;
				switch (this.targetType)
				{
				case TargetType.SpriteRenderer:
					tween = ((SpriteRenderer)target).DOColor(endValueColor, duration);
					break;
				case TargetType.Renderer:
					tween = ((Renderer)target).material.DOColor(endValueColor, duration);
					break;
				case TargetType.Image:
					tween = ((Image)target).DOColor(endValueColor, duration);
					break;
				case TargetType.Text:
					tween = ((Text)target).DOColor(endValueColor, duration);
					break;
				case TargetType.Light:
					tween = ((Light)target).DOColor(endValueColor, duration);
					break;
				}
				break;
			case DOTweenAnimationType.Fade:
				isRelative = false;
				switch (this.targetType)
				{
				case TargetType.SpriteRenderer:
					tween = ((SpriteRenderer)target).DOFade(endValueFloat, duration);
					break;
				case TargetType.Renderer:
					tween = ((Renderer)target).material.DOFade(endValueFloat, duration);
					break;
				case TargetType.Image:
					tween = ((Image)target).DOFade(endValueFloat, duration);
					break;
				case TargetType.Text:
					tween = ((Text)target).DOFade(endValueFloat, duration);
					break;
				case TargetType.Light:
					tween = ((Light)target).DOIntensity(endValueFloat, duration);
					break;
				case TargetType.CanvasGroup:
					tween = ((CanvasGroup)target).DOFade(endValueFloat, duration);
					break;
				}
				break;
			case DOTweenAnimationType.Text:
			{
				TargetType targetType = this.targetType;
				if (targetType == TargetType.Text)
				{
					tween = ((Text)target).DOText(endValueString, duration, optionalBool0, optionalScrambleMode, optionalString);
				}
				break;
			}
			case DOTweenAnimationType.PunchPosition:
				switch (this.targetType)
				{
				case TargetType.RectTransform:
					tween = ((RectTransform)target).DOPunchAnchorPos(endValueV3, duration, optionalInt0, optionalFloat0, optionalBool0);
					break;
				case TargetType.Transform:
					tween = ((Transform)target).DOPunchPosition(endValueV3, duration, optionalInt0, optionalFloat0, optionalBool0);
					break;
				}
				break;
			case DOTweenAnimationType.PunchScale:
				tween = base.transform.DOPunchScale(endValueV3, duration, optionalInt0, optionalFloat0);
				break;
			case DOTweenAnimationType.PunchRotation:
				tween = base.transform.DOPunchRotation(endValueV3, duration, optionalInt0, optionalFloat0);
				break;
			case DOTweenAnimationType.ShakePosition:
				switch (this.targetType)
				{
				case TargetType.RectTransform:
					tween = ((RectTransform)target).DOShakeAnchorPos(duration, endValueV3, optionalInt0, optionalFloat0, optionalBool0);
					break;
				case TargetType.Transform:
					tween = ((Transform)target).DOShakePosition(duration, endValueV3, optionalInt0, optionalFloat0, optionalBool0);
					break;
				}
				break;
			case DOTweenAnimationType.ShakeScale:
				tween = base.transform.DOShakeScale(duration, endValueV3, optionalInt0, optionalFloat0);
				break;
			case DOTweenAnimationType.ShakeRotation:
				tween = base.transform.DOShakeRotation(duration, endValueV3, optionalInt0, optionalFloat0);
				break;
			case DOTweenAnimationType.CameraAspect:
				tween = ((Camera)target).DOAspect(endValueFloat, duration);
				break;
			case DOTweenAnimationType.CameraBackgroundColor:
				tween = ((Camera)target).DOColor(endValueColor, duration);
				break;
			case DOTweenAnimationType.CameraFieldOfView:
				tween = ((Camera)target).DOFieldOfView(endValueFloat, duration);
				break;
			case DOTweenAnimationType.CameraOrthoSize:
				tween = ((Camera)target).DOOrthoSize(endValueFloat, duration);
				break;
			case DOTweenAnimationType.CameraPixelRect:
				tween = ((Camera)target).DOPixelRect(endValueRect, duration);
				break;
			case DOTweenAnimationType.CameraRect:
				tween = ((Camera)target).DORect(endValueRect, duration);
				break;
			}
			if (tween == null)
			{
				return;
			}
			if (isFrom)
			{
				((Tweener)tween).From(isRelative);
			}
			else
			{
				tween.SetRelative(isRelative);
			}
			tween.SetTarget(base.gameObject).SetDelay(delay).SetLoops(loops, loopType)
				.SetAutoKill(autoKill)
				.OnKill(delegate
				{
					tween = null;
				});
			if (isSpeedBased)
			{
				tween.SetSpeedBased();
			}
			if (easeType == Ease.INTERNAL_Custom)
			{
				tween.SetEase(easeCurve);
			}
			else
			{
				tween.SetEase(easeType);
			}
			if (!string.IsNullOrEmpty(id))
			{
				tween.SetId(id);
			}
			tween.SetUpdate(isIndependentUpdate);
			if (hasOnStart)
			{
				if (onStart != null)
				{
					tween.OnStart(onStart.Invoke);
				}
			}
			else
			{
				onStart = null;
			}
			if (hasOnPlay)
			{
				if (onPlay != null)
				{
					tween.OnPlay(onPlay.Invoke);
				}
			}
			else
			{
				onPlay = null;
			}
			if (hasOnUpdate)
			{
				if (onUpdate != null)
				{
					tween.OnUpdate(onUpdate.Invoke);
				}
			}
			else
			{
				onUpdate = null;
			}
			if (hasOnStepComplete)
			{
				if (onStepComplete != null)
				{
					tween.OnStepComplete(onStepComplete.Invoke);
				}
			}
			else
			{
				onStepComplete = null;
			}
			if (hasOnComplete)
			{
				if (onComplete != null)
				{
					tween.OnComplete(onComplete.Invoke);
				}
			}
			else
			{
				onComplete = null;
			}
			if (autoPlay)
			{
				tween.Play();
			}
			else
			{
				tween.Pause();
			}
			if (hasOnTweenCreated && onTweenCreated != null)
			{
				onTweenCreated.Invoke();
			}
		}

		public override void DOPlay()
		{
			DOTween.Play(base.gameObject);
		}

		public override void DOPlayBackwards()
		{
			DOTween.PlayBackwards(base.gameObject);
		}

		public override void DOPlayForward()
		{
			DOTween.PlayForward(base.gameObject);
		}

		public override void DOPause()
		{
			DOTween.Pause(base.gameObject);
		}

		public override void DOTogglePause()
		{
			DOTween.TogglePause(base.gameObject);
		}

		public override void DORewind()
		{
			_playCount = -1;
			DOTweenAnimation[] components = base.gameObject.GetComponents<DOTweenAnimation>();
			for (int num = components.Length - 1; num > -1; num--)
			{
				Tween tween = components[num].tween;
				if (tween != null && tween.IsInitialized())
				{
					components[num].tween.Rewind();
				}
			}
		}

		public override void DORestart(bool fromHere = false)
		{
			_playCount = -1;
			if (tween == null)
			{
				if (DG.Tweening.Core.Debugger.logPriority > 1)
				{
					DG.Tweening.Core.Debugger.LogNullTween(tween);
				}
				return;
			}
			if (fromHere && isRelative)
			{
				ReEvaluateRelativeTween();
			}
			DOTween.Restart(base.gameObject);
		}

		public override void DOComplete()
		{
			DOTween.Complete(base.gameObject);
		}

		public override void DOKill()
		{
			DOTween.Kill(base.gameObject);
			tween = null;
		}

		public void DOPlayById(string id)
		{
			DOTween.Play(base.gameObject, id);
		}

		public void DOPlayAllById(string id)
		{
			DOTween.Play(id);
		}

		public void DOPlayBackwardsById(string id)
		{
			DOTween.PlayBackwards(base.gameObject, id);
		}

		public void DOPlayBackwardsAllById(string id)
		{
			DOTween.PlayBackwards(id);
		}

		public void DOPlayForwardById(string id)
		{
			DOTween.PlayForward(base.gameObject, id);
		}

		public void DOPlayForwardAllById(string id)
		{
			DOTween.PlayForward(id);
		}

		public void DOPlayNext()
		{
			DOTweenAnimation[] components = GetComponents<DOTweenAnimation>();
			while (_playCount < components.Length - 1)
			{
				_playCount++;
				DOTweenAnimation dOTweenAnimation = components[_playCount];
				if (dOTweenAnimation != null && dOTweenAnimation.tween != null && !dOTweenAnimation.tween.IsPlaying() && !dOTweenAnimation.tween.IsComplete())
				{
					dOTweenAnimation.tween.Play();
					break;
				}
			}
		}

		public void DORewindAndPlayNext()
		{
			_playCount = -1;
			DOTween.Rewind(base.gameObject);
			DOPlayNext();
		}

		public void DORestartById(string id)
		{
			_playCount = -1;
			DOTween.Restart(base.gameObject, id);
		}

		public void DORestartAllById(string id)
		{
			_playCount = -1;
			DOTween.Restart(id);
		}

		public List<Tween> GetTweens()
		{
			List<Tween> list = new List<Tween>();
			DOTweenAnimation[] components = GetComponents<DOTweenAnimation>();
			foreach (DOTweenAnimation dOTweenAnimation in components)
			{
				list.Add(dOTweenAnimation.tween);
			}
			return list;
		}

		public static TargetType TypeToDOTargetType(Type t)
		{
			string text = t.ToString();
			int num = text.LastIndexOf(".");
			if (num != -1)
			{
				text = text.Substring(num + 1);
			}
			if (text.IndexOf("Renderer") != -1 && text != "SpriteRenderer")
			{
				text = "Renderer";
			}
			return (TargetType)Enum.Parse(typeof(TargetType), text);
		}

		private void ReEvaluateRelativeTween()
		{
			if (animationType == DOTweenAnimationType.Move)
			{
				((Tweener)tween).ChangeEndValue(base.transform.position + endValueV3, snapStartValue: true);
			}
			else if (animationType == DOTweenAnimationType.LocalMove)
			{
				((Tweener)tween).ChangeEndValue(base.transform.localPosition + endValueV3, snapStartValue: true);
			}
		}
	}
	public static class DOTweenAnimationExtensions
	{
		public static bool IsSameOrSubclassOf<T>(this Component t)
		{
			return t is T;
		}
	}
}
namespace CurvedUI
{
	public class CUI_AnimateCurvedFillOnStart : MonoBehaviour
	{
		private void Update()
		{
			CurvedUISettings component = GetComponent<CurvedUISettings>();
			Text componentInChildren = GetComponentInChildren<Text>();
			if (Time.time < 1.5f)
			{
				component.RingFill = Mathf.PerlinNoise(Time.time * 30.23234f, Time.time * 30.2313f) * 0.15f;
				componentInChildren.text = "Accesing Mainframe...";
			}
			else if (Time.time < 2.5f)
			{
				component.RingFill = Mathf.Clamp(component.RingFill + Time.deltaTime * 3f, 0f, 1f);
				componentInChildren.text = "Mainframe Active";
			}
		}
	}
	public class CUI_CameraController : MonoBehaviour
	{
		public static CUI_CameraController instance;

		[SerializeField]
		private Transform CameraObject;

		[SerializeField]
		private float rotationMargin = 25f;

		private void Awake()
		{
			instance = this;
		}
	}
	public class CUI_ChangeValueOnHold : MonoBehaviour, IPointerDownHandler, IEventSystemHandler, IPointerUpHandler, IPointerEnterHandler, IPointerExitHandler
	{
		private bool pressed;

		[SerializeField]
		private Image bg;

		[SerializeField]
		private Color SelectedColor;

		[SerializeField]
		private Color NormalColor;

		[SerializeField]
		private CanvasGroup IntroCG;

		[SerializeField]
		private CanvasGroup MenuCG;

		private void Update()
		{
			ChangeVal();
			if (Input.GetButtonDown("Jump"))
			{
				pressed = true;
			}
			if (Input.GetButtonUp("Jump"))
			{
				pressed = false;
			}
		}

		private void ChangeVal()
		{
			if (GetComponent<Slider>().normalizedValue == 1f)
			{
				IntroCG.alpha -= Time.deltaTime;
				MenuCG.alpha += Time.deltaTime;
			}
			else
			{
				GetComponent<Slider>().normalizedValue += (pressed ? Time.deltaTime : (0f - Time.deltaTime));
			}
			if (IntroCG.alpha > 0f)
			{
				IntroCG.blocksRaycasts = true;
			}
			else
			{
				IntroCG.blocksRaycasts = false;
			}
		}

		public void OnPointerDown(PointerEventData data)
		{
			pressed = true;
		}

		public void OnPointerUp(PointerEventData data)
		{
			pressed = false;
		}

		public void OnPointerEnter(PointerEventData data)
		{
			bg.color = SelectedColor;
			bg.GetComponent<CurvedUIVertexEffect>().TesselationRequired = true;
		}

		public void OnPointerExit(PointerEventData data)
		{
			bg.color = NormalColor;
			bg.GetComponent<CurvedUIVertexEffect>().TesselationRequired = true;
		}
	}
	public class CUI_GunController : MonoBehaviour
	{
		[SerializeField]
		private CurvedUISettings ControlledCanvas;

		[SerializeField]
		private Transform LaserBeamTransform;

		private void Update()
		{
			Ray ray = new Ray(base.transform.position, base.transform.forward);
			if ((bool)ControlledCanvas)
			{
				ControlledCanvas.CustomControllerRay = ray;
			}
			float num = 10000f;
			if (Physics.Raycast(ray, out var hitInfo, num))
			{
				int num2 = 0;
				if (hitInfo.transform.GetComponent<CurvedUIRaycaster>() != null)
				{
					num2 = hitInfo.transform.GetComponent<CurvedUIRaycaster>().GetObjectsUnderPointer().FindAll((GameObject x) => x.GetComponent<Graphic>() != null && x.GetComponent<Graphic>().depth != -1)
						.Count;
				}
				num = ((num2 == 0) ? 10000f : Vector3.Distance(hitInfo.point, base.transform.position));
			}
			LaserBeamTransform.localScale = LaserBeamTransform.localScale.ModifyZ(num);
			if (Input.GetMouseButton(0))
			{
				LaserBeamTransform.localScale = LaserBeamTransform.localScale.ModifyX(0.75f).ModifyY(0.75f);
			}
			else
			{
				LaserBeamTransform.localScale = LaserBeamTransform.localScale.ModifyX(0.2f).ModifyY(0.2f);
			}
		}
	}
	public class CUI_GunMovement : MonoBehaviour
	{
		[SerializeField]
		private CurvedUISettings mySettings;

		[SerializeField]
		private Transform pivot;

		[SerializeField]
		private float sensitivity = 0.1f;

		private Vector3 lastMouse;

		private void Start()
		{
			lastMouse = Input.mousePosition;
		}

		private void Update()
		{
			Vector3 vector = Input.mousePosition - lastMouse;
			lastMouse = Input.mousePosition;
			pivot.localEulerAngles += new Vector3(0f - vector.y, vector.x, 0f) * sensitivity;
			Ray customControllerRay = new Ray(base.transform.position, base.transform.forward);
			mySettings.CustomControllerRay = customControllerRay;
		}
	}
	public class CUI_OrientOnCurvedSpace : MonoBehaviour
	{
		private CurvedUISettings mySettings;

		private void Awake()
		{
			mySettings = GetComponentInParent<CurvedUISettings>();
		}

		private void Update()
		{
			base.transform.position = mySettings.CanvasToCurvedCanvas(base.transform.parent.localPosition);
			base.transform.rotation = Quaternion.LookRotation(mySettings.CanvasToCurvedCanvasNormal(base.transform.parent.localPosition));
		}
	}
	public class CUI_PerlinNoisePosition : MonoBehaviour
	{
		public float samplingSpeed = 1f;

		public Vector2 Range;

		private RectTransform rectie;

		private void Start()
		{
			rectie = base.transform as RectTransform;
		}

		private void Update()
		{
			rectie.anchoredPosition = new Vector2(Mathf.PerlinNoise(Time.time * samplingSpeed, Time.time * samplingSpeed).Remap(0f, 1f, 0f - Range.x, Range.x), Mathf.PerlinNoise(Time.time * samplingSpeed * 1.333f, Time.time * samplingSpeed * 0.888f).Remap(0f, 1f, 0f - Range.y, Range.y));
		}
	}
	public class CUI_PerlinNoiseRotation : MonoBehaviour
	{
		public float samplingSpeed = 1f;

		public float maxrotation = 60f;

		private RectTransform rectie;

		private void Start()
		{
			rectie = base.transform as RectTransform;
		}

		private void Update()
		{
			rectie.localEulerAngles = new Vector3(0f, 0f, Mathf.PerlinNoise(Time.time * samplingSpeed, Time.time * samplingSpeed).Remap(0f, 1f, 0f - maxrotation, maxrotation));
		}
	}
	public class CUI_RaycastToCanvas : MonoBehaviour
	{
		private CurvedUISettings mySettings;

		private void Start()
		{
			mySettings = GetComponentInParent<CurvedUISettings>();
		}

		private void Update()
		{
			Vector2 o_positionOnCanvas = Vector2.zero;
			mySettings.RaycastToCanvasSpace(Camera.main.ScreenPointToRay(Input.mousePosition), out o_positionOnCanvas);
			base.transform.localPosition = o_positionOnCanvas;
		}
	}
	public class CUI_RiseChildrenOverTime : MonoBehaviour
	{
		private float current;

		public float Speed = 10f;

		public float RiseBy = 50f;

		private void Start()
		{
		}

		private void Update()
		{
			current += Speed * Time.deltaTime;
			if (Mathf.RoundToInt(current) >= base.transform.childCount)
			{
				current = 0f;
			}
			if (Mathf.RoundToInt(current) < 0)
			{
				current = base.transform.childCount - 1;
			}
			for (int i = 0; i < base.transform.childCount; i++)
			{
				if (Mathf.RoundToInt(current) == i)
				{
					base.transform.GetChild(i).localPosition = base.transform.GetChild(i).localPosition.ModifyZ(0f - RiseBy);
				}
				else
				{
					base.transform.GetChild(i).localPosition = base.transform.GetChild(i).localPosition.ModifyZ(0f);
				}
			}
		}
	}
	public class CUI_TMPChecker : MonoBehaviour
	{
		[SerializeField]
		private GameObject testMsg;

		[SerializeField]
		private GameObject enabledMsg;

		[SerializeField]
		private GameObject disabledMsg;

		private void Start()
		{
			testMsg.gameObject.SetActive(value: false);
			enabledMsg.gameObject.SetActive(value: false);
			disabledMsg.gameObject.SetActive(value: true);
		}
	}
	public class CUI_ViveButtonState : MonoBehaviour
	{
		private enum ViveButton
		{
			Trigger,
			TouchpadTouch,
			TouchpadPress,
			Grip,
			Menu
		}

		[SerializeField]
		private Color ActiveColor = Color.green;

		[SerializeField]
		private Color InActiveColor = Color.gray;

		[SerializeField]
		private ViveButton ShowStateFor;
	}
	public class CUI_ViveHapticPulse : MonoBehaviour
	{
		private float PulseStrength;

		public void SetPulseStrength(float newStr)
		{
			PulseStrength = Mathf.Clamp(newStr, 0f, 1f);
		}

		public void TriggerPulse()
		{
		}
	}
	public class CUI_ViveLaserBeam : MonoBehaviour
	{
		[SerializeField]
		private Transform LaserBeamTransform;

		[SerializeField]
		private Transform LaserBeamDot;

		protected void Update()
		{
			Ray ray = new Ray(base.transform.position, base.transform.forward);
			if (!LaserBeamTransform || !LaserBeamDot)
			{
				return;
			}
			float num = 10000f;
			if (Physics.Raycast(ray, out var hitInfo, num))
			{
				num = Vector3.Distance(hitInfo.point, base.transform.position);
				if (hitInfo.transform.GetComponent<CurvedUIRaycaster>() != null)
				{
					num = ((hitInfo.transform.GetComponent<CurvedUIRaycaster>().GetObjectsUnderPointer().FindAll((GameObject x) => x.GetComponent<Graphic>() != null && x.GetComponent<Graphic>().depth != -1)
						.Count == 0) ? 10000f : Vector3.Distance(hitInfo.point, base.transform.position));
				}
			}
			LaserBeamTransform.localScale = LaserBeamTransform.localScale.ModifyZ(num);
		}
	}
	public class CUI_WorldSpaceCursorFollow : MonoBehaviour
	{
		private CurvedUISettings mySettings;

		private void Start()
		{
			mySettings = GetComponentInParent<CurvedUISettings>();
			mySettings.WorldSpaceMouseInCanvasSpace -= (mySettings.transform as RectTransform).rect.size / 2f;
		}

		private void Update()
		{
			base.transform.localPosition = mySettings.WorldSpaceMouseInCanvasSpace;
		}
	}
	public class CUI_WorldSpaceMouseMultipleCanvases : MonoBehaviour
	{
		[SerializeField]
		private List<CurvedUISettings> ControlledCanvases;

		[SerializeField]
		private Transform WorldSpaceMouse;

		[SerializeField]
		private CurvedUISettings MouseCanvas;

		private void Start()
		{
		}

		private void Update()
		{
			Vector3 vector = MouseCanvas.CanvasToCurvedCanvas(WorldSpaceMouse.localPosition);
			Ray customControllerRay = new Ray(Camera.main.transform.position, vector - Camera.main.transform.position);
			foreach (CurvedUISettings controlledCanvase in ControlledCanvases)
			{
				controlledCanvase.CustomControllerRay = customControllerRay;
			}
			if (Input.GetButton("Fire2"))
			{
				Vector2 o_positionOnCanvas = Vector2.zero;
				MouseCanvas.RaycastToCanvasSpace(new Ray(Camera.main.transform.position, Camera.main.transform.forward), out o_positionOnCanvas);
				MouseCanvas.WorldSpaceMouseInCanvasSpace = o_positionOnCanvas;
			}
			UnityEngine.Debug.DrawRay(customControllerRay.GetPoint(0f), customControllerRay.direction * 1000f, Color.cyan);
		}
	}
	public class CUI_ZChangeOnHover : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler
	{
		public float restZ;

		public float OnHoverZ = -50f;

		private bool Zoomed;

		private void Update()
		{
			(base.transform as RectTransform).anchoredPosition3D = (base.transform as RectTransform).anchoredPosition3D.ModifyZ(Mathf.Clamp(Zoomed ? ((base.transform as RectTransform).anchoredPosition3D.z + Time.deltaTime * (OnHoverZ - restZ) * 6f) : ((base.transform as RectTransform).anchoredPosition3D.z - Time.deltaTime * (OnHoverZ - restZ) * 6f), OnHoverZ, restZ));
		}

		public void OnPointerEnter(PointerEventData eventData)
		{
			Zoomed = true;
		}

		public void OnPointerExit(PointerEventData eventData)
		{
			Zoomed = false;
		}
	}
	public class CUI_draggable : MonoBehaviour, IBeginDragHandler, IEventSystemHandler, IEndDragHandler, IDragHandler
	{
		private Vector2 savedVector;

		public void OnBeginDrag(PointerEventData data)
		{
			UnityEngine.Debug.Log("OnBeginDrag");
			Vector2 newPos = Vector2.zero;
			RaycastPosition(out newPos);
			savedVector = new Vector2((base.transform as RectTransform).localPosition.x, (base.transform as RectTransform).localPosition.y) - newPos;
		}

		public void OnDrag(PointerEventData data)
		{
			Vector2 newPos = Vector2.zero;
			RaycastPosition(out newPos);
			(base.transform as RectTransform).localPosition = newPos + savedVector;
		}

		public void OnEndDrag(PointerEventData data)
		{
			UnityEngine.Debug.Log("OnEndDrag");
		}

		private void RaycastPosition(out Vector2 newPos)
		{
			if (GetComponentInParent<CurvedUISettings>().Controller == CurvedUISettings.CurvedUIController.MOUSE)
			{
				GetComponentInParent<CurvedUISettings>().RaycastToCanvasSpace(Camera.main.ScreenPointToRay(Input.mousePosition), out newPos);
			}
			else if (GetComponentInParent<CurvedUISettings>().Controller == CurvedUISettings.CurvedUIController.GAZE)
			{
				GetComponentInParent<CurvedUISettings>().RaycastToCanvasSpace(Camera.main.ScreenPointToRay(new Vector2((float)Screen.width / 2f, (float)Screen.height / 2f)), out newPos);
			}
			else
			{
				newPos = Vector2.zero;
			}
		}
	}
	public class CUI_guntarget : MonoBehaviour
	{
		[SerializeField]
		private GameObject Model;

		[SerializeField]
		private ParticleSystem emitter;

		[SerializeField]
		private CanvasGroup cgroup;

		[SerializeField]
		private CUI_PerlinNoisePosition perlinPos;

		[SerializeField]
		private Text scoreLabel;

		private int score;

		private bool dead;

		public void OnShot()
		{
			if (!dead)
			{
				dead = true;
				perlinPos.enabled = false;
				emitter.Simulate(1f);
				Model.gameObject.SetActive(value: false);
				StartCoroutine(ShotRoutine());
				score++;
				scoreLabel.text = score.ToString();
			}
		}

		private IEnumerator ShotRoutine()
		{
			emitter.Play();
			yield return new WaitForSeconds(2f);
			emitter.Stop();
			emitter.time = 0f;
			emitter.startLifetime = emitter.startLifetime;
			Respawn();
		}

		private void Respawn()
		{
			Model.gameObject.SetActive(value: true);
			(base.transform as RectTransform).anchoredPosition = Vector2.zero;
			perlinPos.samplingSpeed += perlinPos.samplingSpeed * 0.1f;
			perlinPos.enabled = true;
			dead = false;
		}
	}
	public class CUI_inventory_paralax : MonoBehaviour
	{
		[SerializeField]
		private Transform front;

		[SerializeField]
		private Transform back;

		private Vector3 initFG;

		private Vector3 initBG;

		public float change = 50f;

		private void Start()
		{
			initFG = front.position;
			initBG = back.position;
		}

		private void Update()
		{
			front.position = front.position.ModifyX(initFG.x + Input.mousePosition.x.Remap(0f, Screen.width, 0f - change, change));
			back.position = back.position.ModifyX(initBG.x - Input.mousePosition.x.Remap(0f, Screen.width, 0f - change, change));
			front.position = front.position.ModifyY(initFG.y + Input.mousePosition.y.Remap(0f, Screen.height, 0f - change, change) * (float)(Screen.height / Screen.width));
			back.position = back.position.ModifyY(initBG.y - Input.mousePosition.y.Remap(0f, Screen.height, 0f - change, change) * (float)(Screen.height / Screen.width));
		}
	}
	public class CurvedUIInputFieldCaret : MonoBehaviour, ISelectHandler, IEventSystemHandler, IDeselectHandler
	{
		private InputField myField;

		private RectTransform myCaret;

		private Color origCaretColor;

		private Color origSelectionColor;

		private bool selected;

		private bool selectingText;

		public Color CaretColor
		{
			get
			{
				return origCaretColor;
			}
			set
			{
				origCaretColor = value;
			}
		}

		public Color SelectionColor
		{
			get
			{
				return origSelectionColor;
			}
			set
			{
				origSelectionColor = value;
			}
		}

		public float CaretBlinkRate
		{
			get
			{
				return myField.caretBlinkRate;
			}
			set
			{
				myField.caretBlinkRate = value;
			}
		}

		private void Awake()
		{
			myField = GetComponent<InputField>();
		}

		private void Update()
		{
			if (selected)
			{
				UpdateCaret();
			}
		}

		public void OnSelect(BaseEventData eventData)
		{
			if (myCaret == null)
			{
				CreateCaret();
			}
			selected = true;
			myCaret.gameObject.SetActive(value: true);
			StartCoroutine(CaretBlinker());
		}

		public void OnDeselect(BaseEventData eventData)
		{
			selected = false;
			myCaret.gameObject.SetActive(value: false);
		}

		private IEnumerator CaretBlinker()
		{
			while (selected)
			{
				myCaret.gameObject.SetActive(selectingText || !myCaret.gameObject.activeSelf);
				yield return new WaitForSeconds(0.5f / myField.caretBlinkRate);
			}
		}

		private void CreateCaret()
		{
			GameObject gameObject = new GameObject("CurvedUICaret");
			gameObject.AddComponent<RectTransform>();
			gameObject.AddComponent<Image>();
			gameObject.AddComponent<CurvedUIVertexEffect>();
			gameObject.transform.SetParent(base.transform);
			gameObject.transform.localScale = Vector3.one;
			(gameObject.transform as RectTransform).anchoredPosition3D = Vector3.zero;
			(gameObject.transform as RectTransform).pivot = new Vector2(0f, 0.5f);
			gameObject.GetComponent<Image>().color = myField.caretColor;
			myCaret = gameObject.transform as RectTransform;
			gameObject.transform.SetAsFirstSibling();
			myField.customCaretColor = true;
			origCaretColor = myField.caretColor;
			myField.caretColor = new Color(0f, 0f, 0f, 0f);
			origSelectionColor = myField.selectionColor;
			myField.selectionColor = new Color(0f, 0f, 0f, 0f);
			gameObject.gameObject.SetActive(value: false);
		}

		private void UpdateCaret()
		{
			if (myCaret == null)
			{
				CreateCaret();
			}
			Vector2 localPositionInText = GetLocalPositionInText(myField.caretPosition);
			RectTransform rectTransform = (RectTransform)myField.transform.Find(myField.name + " Input Caret");
			if (myField.selectionFocusPosition != myField.selectionAnchorPosition)
			{
				selectingText = true;
				float num = GetLocalPositionInText(myField.selectionAnchorPosition).x - GetLocalPositionInText(myField.selectionFocusPosition).x;
				localPositionInText = ((num < 0f) ? GetLocalPositionInText(myField.selectionAnchorPosition) : GetLocalPositionInText(myField.selectionFocusPosition));
				num = Mathf.Abs(num);
				myCaret.sizeDelta = new Vector2(num, (rectTransform == null) ? 10f : rectTransform.rect.height);
				myCaret.anchoredPosition = localPositionInText.ModifyVectorY(0f);
				myCaret.GetComponent<Image>().color = origSelectionColor;
			}
			else
			{
				selectingText = false;
				myCaret.sizeDelta = new Vector2(myField.caretWidth, (rectTransform == null) ? 10f : rectTransform.rect.height);
				myCaret.anchoredPosition = localPositionInText.ModifyVectorY(0f);
				myCaret.GetComponent<Image>().color = origCaretColor;
			}
		}

		private Vector2 GetLocalPositionInText(int charNo)
		{
			if (myField.isFocused)
			{
				TextGenerator cachedTextGenerator = myField.textComponent.cachedTextGenerator;
				if (charNo > cachedTextGenerator.characterCount - 1)
				{
					charNo = cachedTextGenerator.characterCount - 1;
				}
				if (charNo > 0)
				{
					UICharInfo uICharInfo = cachedTextGenerator.characters[charNo - 1];
					float x = (uICharInfo.cursorPos.x + uICharInfo.charWidth) / myField.textComponent.pixelsPerUnit;
					float y = uICharInfo.cursorPos.y / myField.textComponent.pixelsPerUnit;
					return new Vector2(x, y);
				}
				UICharInfo uICharInfo2 = cachedTextGenerator.characters[charNo];
				float x2 = uICharInfo2.cursorPos.x / myField.textComponent.pixelsPerUnit;
				float y2 = uICharInfo2.cursorPos.y / myField.textComponent.pixelsPerUnit;
				return new Vector2(x2, y2);
			}
			return Vector2.zero;
		}
	}
	public class CurvedUIPointerEventData : PointerEventData
	{
		public enum ControllerType
		{
			NONE = -1,
			VIVE
		}

		public GameObject Controller;

		public Vector2 TouchPadAxis = Vector2.zero;

		public CurvedUIPointerEventData(EventSystem eventSystem)
			: base(eventSystem)
		{
		}
	}
	public class CurvedUIRaycaster : GraphicRaycaster
	{
		[SerializeField]
		private bool showDebug;

		private Canvas myCanvas;

		private CurvedUISettings mySettings;

		private Vector3 cyllinderMidPoint;

		private List<GameObject> lastHovered;

		private Vector2 lastCanvasPos = Vector2.zero;

		protected override void Awake()
		{
			base.Awake();
			myCanvas = GetComponent<Canvas>();
			mySettings = GetComponent<CurvedUISettings>();
			cyllinderMidPoint = new Vector3(0f, 0f, 0f - mySettings.GetCyllinderRadiusInCanvasSpace());
			if (myCanvas.worldCamera == null && Camera.main != null)
			{
				myCanvas.worldCamera = Camera.main;
			}
		}

		protected override void Start()
		{
			CreateCollider();
		}

		public override void Raycast(PointerEventData eventData, List<RaycastResult> resultAppendList)
		{
			if (!mySettings.Interactable)
			{
				return;
			}
			if (myCanvas.worldCamera == null)
			{
				UnityEngine.Debug.LogWarning("CurvedUIRaycaster requires Canvas to have a world camera reference to process events!", myCanvas.gameObject);
			}
			Camera worldCamera = myCanvas.worldCamera;
			Ray ray3D;
			switch (mySettings.Controller)
			{
			case CurvedUISettings.CurvedUIController.MOUSE:
				ray3D = worldCamera.ScreenPointToRay(eventData.position);
				break;
			case CurvedUISettings.CurvedUIController.GAZE:
			{
				ray3D = new Ray(worldCamera.transform.position, worldCamera.transform.forward);
				bool flag = false;
				foreach (GameObject item in eventData.hovered)
				{
					if (item == eventData.selectedObject)
					{
						flag = true;
						break;
					}
				}
				if (!flag)
				{
					eventData.selectedObject = null;
				}
				foreach (GameObject item2 in eventData.hovered)
				{
					if (item2 == null)
					{
						continue;
					}
					Graphic component = item2.GetComponent<Graphic>();
					if (item2.GetComponent<Selectable>() != null && component != null && component.depth != -1 && component.raycastTarget)
					{
						if (eventData.selectedObject != item2)
						{
							eventData.selectedObject = item2;
						}
						break;
					}
				}
				if (eventData.IsPointerMoving() && eventData.pointerDrag != null && !eventData.dragging && ShouldStartDrag(eventData.pressPosition, eventData.position, EventSystem.current.pixelDragThreshold, eventData.useDragThreshold))
				{
					ExecuteEvents.Execute(eventData.pointerDrag, eventData, ExecuteEvents.beginDragHandler);
					eventData.dragging = true;
				}
				break;
			}
			case CurvedUISettings.CurvedUIController.WORLD_MOUSE:
				ray3D = new Ray(worldCamera.transform.position, mySettings.CanvasToCurvedCanvas(mySettings.WorldSpaceMouseInCanvasSpace) - myCanvas.worldCamera.transform.position);
				break;
			case CurvedUISettings.CurvedUIController.CUSTOM_RAY:
			case CurvedUISettings.CurvedUIController.VIVE:
				ray3D = mySettings.CustomControllerRay;
				break;
			default:
				ray3D = default(Ray);
				break;
			}
			if (mySettings.Angle != 0 && mySettings.enabled)
			{
				Vector2 o_canvasPos = eventData.position;
				int myLayerMask = -1;
				if (mySettings.RaycastMyLayerOnly)
				{
					myLayerMask = 1 << base.gameObject.layer;
				}
				switch (mySettings.Shape)
				{
				case CurvedUISettings.CurvedUIShape.CYLINDER:
					if (!RaycastToCyllinderCanvas(ray3D, out o_canvasPos, OutputInCanvasSpace: false, myLayerMask))
					{
						return;
					}
					break;
				case CurvedUISettings.CurvedUIShape.CYLINDER_VERTICAL:
					if (!RaycastToCyllinderVerticalCanvas(ray3D, out o_canvasPos, OutputInCanvasSpace: false, myLayerMask))
					{
						return;
					}
					break;
				case CurvedUISettings.CurvedUIShape.RING:
					if (!RaycastToRingCanvas(ray3D, out o_canvasPos, OutputInCanvasSpace: false, myLayerMask))
					{
						return;
					}
					break;
				case CurvedUISettings.CurvedUIShape.SPHERE:
					if (!RaycastToSphereCanvas(ray3D, out o_canvasPos, OutputInCanvasSpace: false, myLayerMask))
					{
						return;
					}
					break;
				}
				eventData.position = o_canvasPos;
				if (mySettings.Controller == CurvedUISettings.CurvedUIController.VIVE)
				{
					eventData.delta = o_canvasPos - lastCanvasPos;
					lastCanvasPos = o_canvasPos;
				}
			}
			lastHovered = eventData.hovered;
			base.Raycast(eventData, resultAppendList);
		}

		public virtual bool RaycastToCyllinderCanvas(Ray ray3D, out Vector2 o_canvasPos, bool OutputInCanvasSpace = false, int myLayerMask = -1)
		{
			if (showDebug)
			{
				UnityEngine.Debug.DrawLine(ray3D.origin, ray3D.GetPoint(1000f), Color.red);
			}
			RaycastHit hitInfo = default(RaycastHit);
			if (Physics.Raycast(ray3D, out hitInfo, float.PositiveInfinity, myLayerMask))
			{
				Vector3 vector = myCanvas.transform.worldToLocalMatrix.MultiplyPoint3x4(hitInfo.point);
				Vector3 normalized = (vector - cyllinderMidPoint).normalized;
				float value = 0f - AngleSigned(normalized.ModifyY(0f), (mySettings.Angle < 0) ? Vector3.back : Vector3.forward, Vector3.up);
				Vector2 size = myCanvas.GetComponent<RectTransform>().rect.size;
				Vector2 vector2 = new Vector3(0f, 0f, 0f);
				vector2.x = value.Remap((float)(-mySettings.Angle) / 2f, (float)mySettings.Angle / 2f, (0f - size.x) / 2f, size.x / 2f);
				vector2.y = vector.y;
				if (OutputInCanvasSpace)
				{
					o_canvasPos = vector2;
				}
				else
				{
					o_canvasPos = myCanvas.worldCamera.WorldToScreenPoint(myCanvas.transform.localToWorldMatrix.MultiplyPoint3x4(vector2));
				}
				if (showDebug)
				{
					UnityEngine.Debug.DrawLine(hitInfo.point, hitInfo.point.ModifyY(hitInfo.point.y + 10f), Color.green);
					UnityEngine.Debug.DrawLine(hitInfo.point, myCanvas.transform.localToWorldMatrix.MultiplyPoint3x4(cyllinderMidPoint), Color.yellow);
				}
				return true;
			}
			o_canvasPos = Vector2.zero;
			return false;
		}

		public virtual bool RaycastToCyllinderVerticalCanvas(Ray ray3D, out Vector2 o_canvasPos, bool OutputInCanvasSpace = false, int myLayerMask = -1)
		{
			if (showDebug)
			{
				UnityEngine.Debug.DrawLine(ray3D.origin, ray3D.GetPoint(1000f), Color.red);
			}
			RaycastHit hitInfo = default(RaycastHit);
			if (Physics.Raycast(ray3D, out hitInfo, float.PositiveInfinity, myLayerMask))
			{
				Vector3 vector = myCanvas.transform.worldToLocalMatrix.MultiplyPoint3x4(hitInfo.point);
				Vector3 normalized = (vector - cyllinderMidPoint).normalized;
				float value = 0f - AngleSigned(normalized.ModifyX(0f), (mySettings.Angle < 0) ? Vector3.back : Vector3.forward, Vector3.left);
				Vector2 size = myCanvas.GetComponent<RectTransform>().rect.size;
				Vector2 vector2 = new Vector3(0f, 0f, 0f);
				vector2.y = value.Remap((float)(-mySettings.Angle) / 2f, (float)mySettings.Angle / 2f, (0f - size.y) / 2f, size.y / 2f);
				vector2.x = vector.x;
				if (OutputInCanvasSpace)
				{
					o_canvasPos = vector2;
				}
				else
				{
					o_canvasPos = myCanvas.worldCamera.WorldToScreenPoint(myCanvas.transform.localToWorldMatrix.MultiplyPoint3x4(vector2));
				}
				if (showDebug)
				{
					UnityEngine.Debug.DrawLine(hitInfo.point, hitInfo.point.ModifyY(hitInfo.point.y + 10f), Color.green);
					UnityEngine.Debug.DrawLine(hitInfo.point, myCanvas.transform.localToWorldMatrix.MultiplyPoint3x4(cyllinderMidPoint), Color.yellow);
				}
				return true;
			}
			o_canvasPos = Vector2.zero;
			return false;
		}

		public virtual bool RaycastToRingCanvas(Ray ray3D, out Vector2 o_canvasPos, bool OutputInCanvasSpace = false, int myLayerMask = -1)
		{
			RaycastHit hitInfo = default(RaycastHit);
			if (Physics.Raycast(ray3D, out hitInfo, float.PositiveInfinity, myLayerMask))
			{
				Vector3 trans = myCanvas.transform.worldToLocalMatrix.MultiplyPoint3x4(hitInfo.point);
				Vector3 normalized = trans.ModifyZ(0f).normalized;
				Vector2 size = myCanvas.GetComponent<RectTransform>().rect.size;
				float num = 0f - AngleSigned(normalized.ModifyZ(0f), Vector3.up, Vector3.back);
				Vector2 vector = new Vector2(0f, 0f);
				if (showDebug)
				{
					UnityEngine.Debug.Log("angle: " + num);
				}
				if (num < 0f)
				{
					vector.x = num.Remap(0f, -mySettings.Angle, (0f - size.x) / 2f, size.x / 2f);
				}
				else
				{
					vector.x = num.Remap(360f, 360 - mySettings.Angle, (0f - size.x) / 2f, size.x / 2f);
				}
				vector.y = trans.magnitude.Remap((float)mySettings.RingExternalDiameter * 0.5f * (1f - mySettings.RingFill), (float)mySettings.RingExternalDiameter * 0.5f, (0f - size.y) * 0.5f * (float)((!mySettings.RingFlipVertical) ? 1 : (-1)), size.y * 0.5f * (float)((!mySettings.RingFlipVertical) ? 1 : (-1)));
				if (OutputInCanvasSpace)
				{
					o_canvasPos = vector;
				}
				else
				{
					o_canvasPos = myCanvas.worldCamera.WorldToScreenPoint(myCanvas.transform.localToWorldMatrix.MultiplyPoint3x4(vector));
				}
				return true;
			}
			o_canvasPos = Vector2.zero;
			return false;
		}

		public virtual bool RaycastToSphereCanvas(Ray ray3D, out Vector2 o_canvasPos, bool OutputInCanvasSpace = false, int myLayerMask = -1)
		{
			RaycastHit hitInfo = default(RaycastHit);
			if (Physics.Raycast(ray3D, out hitInfo, float.PositiveInfinity, myLayerMask))
			{
				Vector2 size = myCanvas.GetComponent<RectTransform>().rect.size;
				float num = (mySettings.PreserveAspect ? mySettings.GetCyllinderRadiusInCanvasSpace() : (size.x / 2f));
				Vector3 vector = myCanvas.transform.worldToLocalMatrix.MultiplyPoint3x4(hitInfo.point);
				Vector3 vector2 = new Vector3(0f, 0f, mySettings.PreserveAspect ? (0f - num) : 0f);
				Vector3 normalized = (vector - vector2).normalized;
				Vector3 vector3 = Vector3.Cross(normalized, normalized.ModifyY(0f)).normalized * ((normalized.y < 0f) ? 1 : (-1));
				float num2 = 0f - AngleSigned(normalized.ModifyY(0f), (mySettings.Angle > 0) ? Vector3.forward : Vector3.back, (mySettings.Angle > 0) ? Vector3.up : Vector3.down);
				float num3 = 0f - AngleSigned(normalized, normalized.ModifyY(0f), vector3);
				float num4 = (float)Mathf.Abs(mySettings.Angle) * 0.5f;
				float num5 = Mathf.Abs(mySettings.PreserveAspect ? (num4 * size.y / size.x) : ((float)mySettings.VerticalAngle * 0.5f));
				Vector2 vector4 = new Vector2(num2.Remap(0f - num4, num4, (0f - size.x) * 0.5f, size.x * 0.5f), num3.Remap(0f - num5, num5, (0f - size.y) * 0.5f, size.y * 0.5f));
				if (showDebug)
				{
					UnityEngine.Debug.Log("h: " + num2 + " / v: " + num3 + " poc: " + vector4);
					UnityEngine.Debug.DrawRay(myCanvas.transform.localToWorldMatrix.MultiplyPoint3x4(vector2), myCanvas.transform.localToWorldMatrix.MultiplyVector(normalized) * Mathf.Abs(num), Color.red);
					UnityEngine.Debug.DrawRay(myCanvas.transform.localToWorldMatrix.MultiplyPoint3x4(vector2), myCanvas.transform.localToWorldMatrix.MultiplyVector(vector3) * 300f, Color.magenta);
				}
				if (OutputInCanvasSpace)
				{
					o_canvasPos = vector4;
				}
				else
				{
					o_canvasPos = myCanvas.worldCamera.WorldToScreenPoint(myCanvas.transform.localToWorldMatrix.MultiplyPoint3x4(vector4));
				}
				return true;
			}
			o_canvasPos = Vector2.zero;
			return false;
		}

		protected Collider CreateCollider()
		{
			List<Collider> list = new List<Collider>();
			list.AddRange(GetComponents<Collider>());
			for (int i = 0; i < list.Count; i++)
			{
				UnityEngine.Object.Destroy(list[i]);
			}
			if (!mySettings.BlocksRaycasts)
			{
				return null;
			}
			if (mySettings.Shape == CurvedUISettings.CurvedUIShape.SPHERE && !mySettings.PreserveAspect && mySettings.VerticalAngle == 0)
			{
				return null;
			}
			switch (mySettings.Shape)
			{
			case CurvedUISettings.CurvedUIShape.CYLINDER:
			{
				if (GetComponent<MeshFilter>() == null)
				{
					base.gameObject.AddComponent<MeshFilter>();
				}
				MeshFilter component2 = GetComponent<MeshFilter>();
				MeshCollider meshCollider2 = base.gameObject.AddComponent<MeshCollider>();
				Mesh sharedMesh2 = (component2.mesh = CreateCyllinderColliderMesh());
				meshCollider2.sharedMesh = sharedMesh2;
				return meshCollider2;
			}
			case CurvedUISettings.CurvedUIShape.CYLINDER_VERTICAL:
			{
				if (GetComponent<MeshFilter>() == null)
				{
					base.gameObject.AddComponent<MeshFilter>();
				}
				MeshFilter component3 = GetComponent<MeshFilter>();
				MeshCollider meshCollider3 = base.gameObject.AddComponent<MeshCollider>();
				Mesh sharedMesh3 = (component3.mesh = CreateCyllinderColliderMesh(vertical: true));
				meshCollider3.sharedMesh = sharedMesh3;
				return meshCollider3;
			}
			case CurvedUISettings.CurvedUIShape.RING:
			{
				BoxCollider boxCollider = base.gameObject.AddComponent<BoxCollider>();
				boxCollider.size = new Vector3(mySettings.RingExternalDiameter, mySettings.RingExternalDiameter, 1f);
				return boxCollider;
			}
			case CurvedUISettings.CurvedUIShape.SPHERE:
			{
				if (GetComponent<MeshFilter>() == null)
				{
					base.gameObject.AddComponent<MeshFilter>();
				}
				MeshFilter component = GetComponent<MeshFilter>();
				MeshCollider meshCollider = base.gameObject.AddComponent<MeshCollider>();
				Mesh sharedMesh = (component.mesh = CreateSphereColliderMesh());
				meshCollider.sharedMesh = sharedMesh;
				return meshCollider;
			}
			default:
				return null;
			}
		}

		private Mesh CreateCyllinderColliderMesh(bool vertical = false)
		{
			Mesh mesh = new Mesh();
			Vector3[] array = new Vector3[4];
			(myCanvas.transform as RectTransform).GetWorldCorners(array);
			mesh.vertices = array;
			if (vertical)
			{
				array[0] = myCanvas.transform.worldToLocalMatrix.MultiplyPoint3x4(mesh.vertices[1]);
				array[1] = myCanvas.transform.worldToLocalMatrix.MultiplyPoint3x4(mesh.vertices[2]);
				array[2] = myCanvas.transform.worldToLocalMatrix.MultiplyPoint3x4(mesh.vertices[0]);
				array[3] = myCanvas.transform.worldToLocalMatrix.MultiplyPoint3x4(mesh.vertices[3]);
			}
			else
			{
				array[0] = myCanvas.transform.worldToLocalMatrix.MultiplyPoint3x4(mesh.vertices[1]);
				array[1] = myCanvas.transform.worldToLocalMatrix.MultiplyPoint3x4(mesh.vertices[0]);
				array[2] = myCanvas.transform.worldToLocalMatrix.MultiplyPoint3x4(mesh.vertices[2]);
				array[3] = myCanvas.transform.worldToLocalMatrix.MultiplyPoint3x4(mesh.vertices[3]);
			}
			mesh.vertices = array;
			List<Vector3> list = new List<Vector3>();
			int num = Mathf.Max(8, Mathf.RoundToInt((float)(mySettings.BaseCircleSegments * Mathf.Abs(mySettings.Angle)) / 360f));
			for (int i = 0; i < num; i++)
			{
				list.Add(Vector3.Lerp(mesh.vertices[0], mesh.vertices[2], (float)i * 1f / (float)(num - 1)));
				list.Add(Vector3.Lerp(mesh.vertices[1], mesh.vertices[3], (float)i * 1f / (float)(num - 1)));
			}
			if (mySettings.Angle != 0)
			{
				Rect rect = myCanvas.GetComponent<RectTransform>().rect;
				float cyllinderRadiusInCanvasSpace = GetComponent<CurvedUISettings>().GetCyllinderRadiusInCanvasSpace();
				for (int j = 0; j < list.Count; j++)
				{
					Vector3 value = list[j];
					if (vertical)
					{
						float f = list[j].y / rect.size.y * (float)mySettings.Angle * ((float)Math.PI / 180f);
						value.y = Mathf.Sin(f) * cyllinderRadiusInCanvasSpace;
						value.z += Mathf.Cos(f) * cyllinderRadiusInCanvasSpace - cyllinderRadiusInCanvasSpace;
						list[j] = value;
					}
					else
					{
						float f2 = list[j].x / rect.size.x * (float)mySettings.Angle * ((float)Math.PI / 180f);
						value.x = Mathf.Sin(f2) * cyllinderRadiusInCanvasSpace;
						value.z += Mathf.Cos(f2) * cyllinderRadiusInCanvasSpace - cyllinderRadiusInCanvasSpace;
						list[j] = value;
					}
				}
			}
			mesh.vertices = list.ToArray();
			List<int> list2 = new List<int>();
			for (int k = 0; k < list.Count / 2 - 1; k++)
			{
				if (vertical)
				{
					list2.Add(k * 2);
					list2.Add(k * 2 + 1);
					list2.Add(k * 2 + 2);
					list2.Add(k * 2 + 1);
					list2.Add(k * 2 + 3);
					list2.Add(k * 2 + 2);
				}
				else
				{
					list2.Add(k * 2 + 2);
					list2.Add(k * 2 + 1);
					list2.Add(k * 2);
					list2.Add(k * 2 + 2);
					list2.Add(k * 2 + 3);
					list2.Add(k * 2 + 1);
				}
			}
			mesh.triangles = list2.ToArray();
			return mesh;
		}

		private Mesh CreateSphereColliderMesh()
		{
			Mesh mesh = new Mesh();
			Vector3[] array = new Vector3[4];
			(myCanvas.transform as RectTransform).GetWorldCorners(array);
			List<Vector3> list = new List<Vector3>(array);
			for (int i = 0; i < list.Count; i++)
			{
				list[i] = mySettings.transform.worldToLocalMatrix.MultiplyPoint3x4(list[i]);
			}
			if (mySettings.Angle != 0)
			{
				int count = list.Count;
				for (int j = 0; j < count; j += 4)
				{
					ModifyQuad(list, j, mySettings.GetTesslationSize(UnmodifiedByQuality: true));
				}
				list.RemoveRange(0, count);
				float num = mySettings.VerticalAngle;
				float num2 = mySettings.Angle;
				Vector2 size = (myCanvas.transform as RectTransform).rect.size;
				float num3 = mySettings.GetCyllinderRadiusInCanvasSpace();
				if (mySettings.PreserveAspect)
				{
					num = (float)mySettings.Angle * (size.y / size.x);
				}
				else
				{
					num3 = size.x / 2f;
				}
				for (int k = 0; k < list.Count; k++)
				{
					float num4 = (list[k].x / size.x).Remap(-0.5f, 0.5f, (180f - num2) / 2f - 90f, 180f - (180f - num2) / 2f - 90f);
					num4 *= (float)Math.PI / 180f;
					float num5 = (list[k].y / size.y).Remap(-0.5f, 0.5f, (180f - num) / 2f, 180f - (180f - num) / 2f);
					num5 *= (float)Math.PI / 180f;
					list[k] = new Vector3(Mathf.Sin(num5) * Mathf.Sin(num4) * num3, (0f - num3) * Mathf.Cos(num5), Mathf.Sin(num5) * Mathf.Cos(num4) * num3 + (mySettings.PreserveAspect ? (0f - num3) : 0f));
				}
			}
			mesh.vertices = list.ToArray();
			List<int> list2 = new List<int>();
			for (int l = 0; l < list.Count; l += 4)
			{
				list2.Add(l);
				list2.Add(l + 1);
				list2.Add(l + 2);
				list2.Add(l + 3);
				list2.Add(l);
				list2.Add(l + 2);
			}
			mesh.triangles = list2.ToArray();
			return mesh;
		}

		private float AngleSigned(Vector3 v1, Vector3 v2, Vector3 n)
		{
			return Mathf.Atan2(Vector3.Dot(n, Vector3.Cross(v1, v2)), Vector3.Dot(v1, v2)) * 57.29578f;
		}

		private bool ShouldStartDrag(Vector2 pressPos, Vector2 currentPos, float threshold, bool useDragThreshold)
		{
			if (!useDragThreshold)
			{
				return true;
			}
			return (pressPos - currentPos).sqrMagnitude >= threshold * threshold;
		}

		public void RebuildCollider()
		{
			cyllinderMidPoint = new Vector3(0f, 0f, 0f - mySettings.GetCyllinderRadiusInCanvasSpace());
			CreateCollider();
		}

		public List<GameObject> GetObjectsUnderPointer()
		{
			if (lastHovered == null)
			{
				lastHovered = new List<GameObject>();
			}
			return lastHovered;
		}

		private void ModifyQuad(List<Vector3> verts, int vertexIndex, Vector2 requiredSize)
		{
			List<Vector3> list = new List<Vector3>();
			for (int i = 0; i < 4; i++)
			{
				list.Add(verts[vertexIndex + i]);
			}
			Vector3 vector = list[2] - list[1];
			Vector3 vector2 = list[1] - list[0];
			int num = Mathf.CeilToInt(vector.magnitude * (1f / Mathf.Max(1f, requiredSize.x)));
			int num2 = Mathf.CeilToInt(vector2.magnitude * (1f / Mathf.Max(1f, requiredSize.y)));
			float y = 0f;
			for (int j = 0; j < num2; j++)
			{
				float num3 = ((float)j + 1f) / (float)num2;
				float x = 0f;
				for (int k = 0; k < num; k++)
				{
					float num4 = ((float)k + 1f) / (float)num;
					verts.Add(TesselateQuad(list, x, y));
					verts.Add(TesselateQuad(list, x, num3));
					verts.Add(TesselateQuad(list, num4, num3));
					verts.Add(TesselateQuad(list, num4, y));
					x = num4;
				}
				y = num3;
			}
		}

		private Vector3 TesselateQuad(List<Vector3> quad, float x, float y)
		{
			Vector3 zero = Vector3.zero;
			List<float> list = new List<float>
			{
				(1f - x) * (1f - y),
				(1f - x) * y,
				x * y,
				x * (1f - y)
			};
			for (int i = 0; i < 4; i++)
			{
				zero += quad[i] * list[i];
			}
			return zero;
		}
	}
	[RequireComponent(typeof(Canvas))]
	public class CurvedUISettings : MonoBehaviour
	{
		public enum CurvedUIShape
		{
			CYLINDER,
			RING,
			SPHERE,
			CYLINDER_VERTICAL
		}

		public enum CurvedUIController
		{
			MOUSE,
			GAZE,
			WORLD_MOUSE,
			CUSTOM_RAY,
			VIVE
		}

		[SerializeField]
		private CurvedUIShape shape;

		[SerializeField]
		private CurvedUIController controller;

		[SerializeField]
		private float quality = 1f;

		[SerializeField]
		private bool interactable = true;

		[SerializeField]
		private bool blocksRaycasts = true;

		[SerializeField]
		private bool raycastMyLayerOnly;

		[SerializeField]
		private int angle = 90;

		[SerializeField]
		private bool preserveAspect = true;

		[SerializeField]
		private int vertAngle = 90;

		[SerializeField]
		private float ringFill = 0.5f;

		[SerializeField]
		private int ringExternalDiamater = 1000;

		[SerializeField]
		private bool ringFlipVertical;

		private int baseCircleSegments = 24;

		private Vector2 savedRectSize;

		private float savedRadius;

		private Canvas myCanvas;

		private Ray customControllerRay;

		private Vector3 lastMouseOnScreenPos = Vector2.zero;

		private Vector2 worldSpaceMouseInCanvasSpace = Vector2.zero;

		private Vector2 lastWorldSpaceMouseOnCanvas = Vector2.zero;

		private Vector2 worldSpaceMouseOnCanvasDelta = Vector2.zero;

		private float worldSpaceMouseSensitivity = 1f;

		public Ray CustomControllerRay
		{
			get
			{
				return customControllerRay;
			}
			set
			{
				customControllerRay = value;
				if (Controller != CurvedUIController.CUSTOM_RAY)
				{
					UnityEngine.Debug.LogWarning("A custom ray has been supplied, but CurvedUI canvas is not set to Custom Ray mode.");
				}
			}
		}

		public Vector2 WorldSpaceMouseInCanvasSpace
		{
			get
			{
				return worldSpaceMouseInCanvasSpace;
			}
			set
			{
				worldSpaceMouseInCanvasSpace = value;
				lastWorldSpaceMouseOnCanvas = value;
			}
		}

		public Vector2 WorldSpaceMouseInCanvasSpaceDelta => worldSpaceMouseInCanvasSpace - lastWorldSpaceMouseOnCanvas;

		public float WorldSpaceMouseSensitivity
		{
			get
			{
				return worldSpaceMouseSensitivity;
			}
			set
			{
				worldSpaceMouseSensitivity = value;
			}
		}

		public int BaseCircleSegments => baseCircleSegments;

		public int Angle
		{
			get
			{
				return angle;
			}
			set
			{
				if (angle != value)
				{
					SetUIAngle(value);
				}
			}
		}

		public float Quality
		{
			get
			{
				return quality;
			}
			set
			{
				if (quality != value)
				{
					quality = value;
					SetUIAngle(angle);
				}
			}
		}

		public CurvedUIShape Shape
		{
			get
			{
				return shape;
			}
			set
			{
				if (shape != value)
				{
					shape = value;
					SetUIAngle(angle);
				}
			}
		}

		public int VerticalAngle
		{
			get
			{
				return vertAngle;
			}
			set
			{
				if (vertAngle != value)
				{
					vertAngle = value;
					SetUIAngle(angle);
				}
			}
		}

		public float RingFill
		{
			get
			{
				return ringFill;
			}
			set
			{
				if (ringFill != value)
				{
					ringFill = value;
					SetUIAngle(angle);
				}
			}
		}

		public float SavedRadius
		{
			get
			{
				if (savedRadius == 0f)
				{
					savedRadius = GetCyllinderRadiusInCanvasSpace();
				}
				return savedRadius;
			}
		}

		public int RingExternalDiameter
		{
			get
			{
				return ringExternalDiamater;
			}
			set
			{
				if (ringExternalDiamater != value)
				{
					ringExternalDiamater = value;
					SetUIAngle(angle);
				}
			}
		}

		public bool RingFlipVertical
		{
			get
			{
				return ringFlipVertical;
			}
			set
			{
				if (ringFlipVertical != value)
				{
					ringFlipVertical = value;
					SetUIAngle(angle);
				}
			}
		}

		public bool PreserveAspect
		{
			get
			{
				return preserveAspect;
			}
			set
			{
				if (preserveAspect != value)
				{
					preserveAspect = value;
					SetUIAngle(angle);
				}
			}
		}

		public bool Interactable
		{
			get
			{
				return interactable;
			}
			set
			{
				if (interactable != value)
				{
					interactable = value;
				}
			}
		}

		public bool BlocksRaycasts
		{
			get
			{
				return blocksRaycasts;
			}
			set
			{
				if (blocksRaycasts != value)
				{
					blocksRaycasts = value;
					if (Application.isPlaying && GetComponent<CurvedUIRaycaster>() != null)
					{
						GetComponent<CurvedUIRaycaster>().RebuildCollider();
					}
				}
			}
		}

		public CurvedUIController Controller
		{
			get
			{
				return controller;
			}
			set
			{
				if (controller != value)
				{
					controller = value;
					SetUIAngle(angle);
				}
			}
		}

		public bool RaycastMyLayerOnly
		{
			get
			{
				return raycastMyLayerOnly;
			}
			set
			{
				raycastMyLayerOnly = value;
			}
		}

		private void Awake()
		{
			if (Application.isPlaying && Controller == CurvedUIController.VIVE)
			{
				UnityEngine.Debug.LogWarning("Add CURVEDUI_VIVE to your platform custom defines to enable Vive support in CurvedUI.");
			}
		}

		private void Start()
		{
			if (Application.isPlaying)
			{
				GraphicRaycaster component = GetComponent<GraphicRaycaster>();
				if (component != null)
				{
					if (!(component is CurvedUIRaycaster))
					{
						UnityEngine.Object.Destroy(component);
						base.gameObject.AddComponent<CurvedUIRaycaster>();
					}
				}
				else
				{
					base.gameObject.AddComponent<CurvedUIRaycaster>();
				}
			}
			if (myCanvas == null)
			{
				myCanvas = GetComponent<Canvas>();
			}
			savedRadius = GetCyllinderRadiusInCanvasSpace();
		}

		private void OnEnable()
		{
			Graphic[] componentsInChildren = GetComponentsInChildren<Graphic>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				componentsInChildren[i].SetAllDirty();
			}
		}

		private void OnDisable()
		{
			Graphic[] componentsInChildren = GetComponentsInChildren<Graphic>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				componentsInChildren[i].SetAllDirty();
			}
		}

		private void Update()
		{
			if ((base.transform as RectTransform).rect.size != savedRectSize)
			{
				savedRectSize = (base.transform as RectTransform).rect.size;
				SetUIAngle(angle);
			}
			if (savedRectSize.x == 0f || savedRectSize.y == 0f)
			{
				UnityEngine.Debug.LogError("CurvedUI: Your Canvas size must be bigger than 0!");
			}
			if (Controller == CurvedUIController.WORLD_MOUSE)
			{
				if (Input.touchCount > 0)
				{
					worldSpaceMouseOnCanvasDelta = Input.GetTouch(0).deltaPosition * worldSpaceMouseSensitivity;
				}
				else
				{
					worldSpaceMouseOnCanvasDelta = new Vector2((Input.mousePosition - lastMouseOnScreenPos).x, (Input.mousePosition - lastMouseOnScreenPos).y) * worldSpaceMouseSensitivity;
					lastMouseOnScreenPos = Input.mousePosition;
				}
				lastWorldSpaceMouseOnCanvas = worldSpaceMouseInCanvasSpace;
				worldSpaceMouseInCanvasSpace += worldSpaceMouseOnCanvasDelta;
			}
		}

		private void SetUIAngle(int newAngle)
		{
			if (myCanvas == null)
			{
				myCanvas = GetComponent<Canvas>();
			}
			if (newAngle == 0)
			{
				newAngle = 1;
			}
			angle = newAngle;
			savedRadius = GetCyllinderRadiusInCanvasSpace();
			CurvedUIVertexEffect[] componentsInChildren = GetComponentsInChildren<CurvedUIVertexEffect>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				componentsInChildren[i].TesselationRequired = true;
			}
			Graphic[] componentsInChildren2 = GetComponentsInChildren<Graphic>();
			for (int i = 0; i < componentsInChildren2.Length; i++)
			{
				componentsInChildren2[i].SetVerticesDirty();
			}
			if (Application.isPlaying && GetComponent<CurvedUIRaycaster>() != null)
			{
				GetComponent<CurvedUIRaycaster>().RebuildCollider();
			}
		}

		private Vector3 CanvasToCyllinder(Vector3 pos)
		{
			float f = pos.x / savedRectSize.x * (float)Angle * ((float)Math.PI / 180f);
			pos.x = Mathf.Sin(f) * (SavedRadius + pos.z);
			pos.z += Mathf.Cos(f) * (SavedRadius + pos.z) - (SavedRadius + pos.z);
			return pos;
		}

		private Vector3 CanvasToCyllinderVertical(Vector3 pos)
		{
			float f = pos.y / savedRectSize.y * (float)Angle * ((float)Math.PI / 180f);
			pos.y = Mathf.Sin(f) * (SavedRadius + pos.z);
			pos.z += Mathf.Cos(f) * (SavedRadius + pos.z) - (SavedRadius + pos.z);
			return pos;
		}

		private Vector3 CanvasToRing(Vector3 pos)
		{
			float num = pos.y.Remap(savedRectSize.y * 0.5f * (float)(RingFlipVertical ? 1 : (-1)), (0f - savedRectSize.y) * 0.5f * (float)(RingFlipVertical ? 1 : (-1)), (float)RingExternalDiameter * (1f - RingFill) * 0.5f, (float)RingExternalDiameter * 0.5f);
			float f = (pos.x / savedRectSize.x).Remap(-0.5f, 0.5f, (float)Math.PI / 2f, (float)angle * ((float)Math.PI / 180f) + (float)Math.PI / 2f);
			pos.x = num * Mathf.Cos(f);
			pos.y = num * Mathf.Sin(f);
			return pos;
		}

		private Vector3 CanvasToSphere(Vector3 pos)
		{
			float num = SavedRadius;
			float num2 = VerticalAngle;
			if (PreserveAspect)
			{
				num2 = (float)angle * (savedRectSize.y / savedRectSize.x);
				num += ((Angle > 0) ? (0f - pos.z) : pos.z);
			}
			else
			{
				num = savedRectSize.x / 2f + pos.z;
				if (num2 == 0f)
				{
					return Vector3.zero;
				}
			}
			float num3 = (pos.x / savedRectSize.x).Remap(-0.5f, 0.5f, (float)(180 - angle) / 2f - 90f, 180f - (float)(180 - angle) / 2f - 90f);
			num3 *= (float)Math.PI / 180f;
			float num4 = (pos.y / savedRectSize.y).Remap(-0.5f, 0.5f, (180f - num2) / 2f, 180f - (180f - num2) / 2f);
			num4 *= (float)Math.PI / 180f;
			pos.z = Mathf.Sin(num4) * Mathf.Cos(num3) * num;
			pos.y = (0f - num) * Mathf.Cos(num4);
			pos.x = Mathf.Sin(num4) * Mathf.Sin(num3) * num;
			if (PreserveAspect)
			{
				pos.z -= num;
			}
			return pos;
		}

		public void AddEffectToChildren()
		{
			Graphic[] componentsInChildren = GetComponentsInChildren<Graphic>(includeInactive: true);
			foreach (Graphic graphic in componentsInChildren)
			{
				if (graphic.GetComponent<CurvedUIVertexEffect>() == null)
				{
					graphic.gameObject.AddComponent<CurvedUIVertexEffect>();
					graphic.SetAllDirty();
				}
			}
			InputField[] componentsInChildren2 = GetComponentsInChildren<InputField>(includeInactive: true);
			foreach (InputField inputField in componentsInChildren2)
			{
				if (inputField.GetComponent<CurvedUIInputFieldCaret>() == null)
				{
					inputField.gameObject.AddComponent<CurvedUIInputFieldCaret>();
				}
			}
		}

		public Vector3 VertexPositionToCurvedCanvas(Vector3 pos)
		{
			return Shape switch
			{
				CurvedUIShape.CYLINDER => CanvasToCyllinder(pos), 
				CurvedUIShape.CYLINDER_VERTICAL => CanvasToCyllinderVertical(pos), 
				CurvedUIShape.RING => CanvasToRing(pos), 
				CurvedUIShape.SPHERE => CanvasToSphere(pos), 
				_ => Vector3.zero, 
			};
		}

		public Vector3 CanvasToCurvedCanvas(Vector3 pos)
		{
			pos = VertexPositionToCurvedCanvas(pos);
			if (float.IsNaN(pos.x) || float.IsInfinity(pos.x))
			{
				return Vector3.zero;
			}
			return base.transform.localToWorldMatrix.MultiplyPoint3x4(pos);
		}

		public Vector3 CanvasToCurvedCanvasNormal(Vector3 pos)
		{
			pos = VertexPositionToCurvedCanvas(pos);
			switch (Shape)
			{
			case CurvedUIShape.CYLINDER:
				return base.transform.localToWorldMatrix.MultiplyVector((pos - new Vector3(0f, 0f, 0f - GetCyllinderRadiusInCanvasSpace())).ModifyY(0f)).normalized;
			case CurvedUIShape.CYLINDER_VERTICAL:
				return base.transform.localToWorldMatrix.MultiplyVector((pos - new Vector3(0f, 0f, 0f - GetCyllinderRadiusInCanvasSpace())).ModifyX(0f)).normalized;
			case CurvedUIShape.RING:
				return -base.transform.forward;
			case CurvedUIShape.SPHERE:
			{
				Vector3 vector = (PreserveAspect ? new Vector3(0f, 0f, 0f - GetCyllinderRadiusInCanvasSpace()) : Vector3.zero);
				return base.transform.localToWorldMatrix.MultiplyVector(pos - vector).normalized;
			}
			default:
				return Vector3.zero;
			}
		}

		public bool RaycastToCanvasSpace(Ray ray, out Vector2 o_positionOnCanvas)
		{
			CurvedUIRaycaster component = GetComponent<CurvedUIRaycaster>();
			o_positionOnCanvas = Vector2.zero;
			return Shape switch
			{
				CurvedUIShape.CYLINDER => component.RaycastToCyllinderCanvas(ray, out o_positionOnCanvas, OutputInCanvasSpace: true), 
				CurvedUIShape.CYLINDER_VERTICAL => component.RaycastToCyllinderVerticalCanvas(ray, out o_positionOnCanvas, OutputInCanvasSpace: true), 
				CurvedUIShape.RING => component.RaycastToRingCanvas(ray, out o_positionOnCanvas, OutputInCanvasSpace: true), 
				CurvedUIShape.SPHERE => component.RaycastToSphereCanvas(ray, out o_positionOnCanvas, OutputInCanvasSpace: true), 
				_ => false, 
			};
		}

		public float GetCyllinderRadiusInCanvasSpace()
		{
			float result = ((!PreserveAspect) ? ((base.transform as RectTransform).rect.size.x * 0.5f / Mathf.Sin(Mathf.Clamp(angle, -180f, 180f) * 0.5f * ((float)Math.PI / 180f))) : ((shape != CurvedUIShape.CYLINDER_VERTICAL) ? ((base.transform as RectTransform).rect.size.x / ((float)Math.PI * 2f * ((float)angle / 360f))) : ((base.transform as RectTransform).rect.size.y / ((float)Math.PI * 2f * ((float)angle / 360f)))));
			if (angle != 0)
			{
				return result;
			}
			return 0f;
		}

		public Vector2 GetTesslationSize(bool UnmodifiedByQuality = false)
		{
			Vector2 size = GetComponent<RectTransform>().rect.size;
			float num = size.x;
			float y = size.y;
			if (Angle != 0 || (!PreserveAspect && vertAngle != 0))
			{
				switch (shape)
				{
				case CurvedUIShape.CYLINDER:
				case CurvedUIShape.RING:
				case CurvedUIShape.CYLINDER_VERTICAL:
					num = Mathf.Min(size.x / 4f, size.x / (Mathf.Abs(angle).Remap(0f, 360f, 0f, 1f) * (float)baseCircleSegments));
					y = Mathf.Min(size.y / 4f, size.y / (Mathf.Abs(angle).Remap(0f, 360f, 0f, 1f) * (float)baseCircleSegments));
					break;
				case CurvedUIShape.SPHERE:
					num = Mathf.Min(size.x / 4f, size.x / (Mathf.Abs(angle).Remap(0f, 360f, 0f, 1f) * (float)baseCircleSegments * 0.5f));
					y = ((!PreserveAspect) ? ((VerticalAngle == 0) ? 10000f : (size.y / (Mathf.Abs(VerticalAngle).Remap(0f, 180f, 0f, 1f) * (float)baseCircleSegments * 0.5f))) : (num * size.y / size.x));
					break;
				}
			}
			return new Vector2(num, y) / (UnmodifiedByQuality ? 1f : Mathf.Clamp(Quality, 0.01f, 10f));
		}

		public void SetAllChildrenDirty(bool recalculateCurveOnly = false)
		{
			CurvedUIVertexEffect[] componentsInChildren = GetComponentsInChildren<CurvedUIVertexEffect>();
			foreach (CurvedUIVertexEffect curvedUIVertexEffect in componentsInChildren)
			{
				if (recalculateCurveOnly)
				{
					curvedUIVertexEffect.SetDirty();
				}
				else
				{
					curvedUIVertexEffect.CurvingRequired = true;
				}
			}
		}
	}
	public class CurvedUIVertexEffect : BaseMeshEffect
	{
		private VertexHelper SavedVertexHelper;

		private List<UIVertex> SavedVerteees;

		[Tooltip("Check to skip tesselation pass on this object. CurvedUI will not create additional vertices to make this object have a smoother curve. Checking this can solve some issues if you create your own procedural mesh for this object. Default false.")]
		public bool DoNotTesselate;

		private bool tesselationRequired = true;

		private bool curvingRequired = true;

		private float angle = 90f;

		private bool TransformMisaligned;

		private Canvas myCanvas;

		private CurvedUISettings mySettings;

		private Matrix4x4 CanvasToWorld;

		private Matrix4x4 CanvasToLocal;

		private Matrix4x4 MyToWorld;

		private Matrix4x4 MyToLocal;

		[SerializeField]
		[HideInInspector]
		private Vector3 savedPos;

		[SerializeField]
		[HideInInspector]
		private Vector3 savedUp;

		[SerializeField]
		[HideInInspector]
		private Vector2 savedRectSize;

		[SerializeField]
		[HideInInspector]
		private Color savedColor;

		[SerializeField]
		[HideInInspector]
		private Vector2 savedTextUV0;

		[SerializeField]
		[HideInInspector]
		private float savedFill;

		private List<UIVertex> tesselatedVerts;

		private Graphic myGraphic;

		private Image myImage;

		private Text myText;

		public bool TesselationRequired
		{
			get
			{
				return tesselationRequired;
			}
			set
			{
				tesselationRequired = value;
			}
		}

		public bool CurvingRequired
		{
			get
			{
				return curvingRequired;
			}
			set
			{
				curvingRequired = value;
			}
		}

		public override void ModifyMesh(VertexHelper vh)
		{
			if (!IsActive())
			{
				return;
			}
			if (mySettings == null)
			{
				FindParentSettings();
			}
			if (mySettings == null || !mySettings.enabled)
			{
				return;
			}
			CheckTextFontMaterial();
			if (tesselationRequired || curvingRequired || SavedVertexHelper == null || SavedVertexHelper.currentVertCount == 0)
			{
				SavedVerteees = new List<UIVertex>();
				vh.GetUIVertexStream(SavedVerteees);
				ModifyVerts(SavedVerteees);
				if (SavedVertexHelper == null)
				{
					SavedVertexHelper = new VertexHelper();
				}
				else
				{
					SavedVertexHelper.Clear();
				}
				if (SavedVerteees.Count % 4 == 0)
				{
					for (int i = 0; i < SavedVerteees.Count; i += 4)
					{
						SavedVertexHelper.AddUIVertexQuad(new UIVertex[4]
						{
							SavedVerteees[i],
							SavedVerteees[i + 1],
							SavedVerteees[i + 2],
							SavedVerteees[i + 3]
						});
					}
				}
				else
				{
					SavedVertexHelper.AddUIVertexTriangleStream(SavedVerteees);
				}
				SavedVertexHelper.GetUIVertexStream(SavedVerteees);
				curvingRequired = false;
			}
			vh.Clear();
			vh.AddUIVertexTriangleStream(SavedVerteees);
		}

		protected override void OnEnable()
		{
			FindParentSettings();
			myGraphic = GetComponent<Graphic>();
			if ((bool)myGraphic)
			{
				myGraphic.RegisterDirtyMaterialCallback(TesselationRequiredCallback);
				myGraphic.SetVerticesDirty();
			}
			myText = GetComponent<Text>();
			if ((bool)myText)
			{
				myText.RegisterDirtyVerticesCallback(TesselationRequiredCallback);
				Font.textureRebuilt += FontTextureRebuiltCallback;
			}
		}

		protected override void OnDisable()
		{
			if ((bool)myGraphic)
			{
				myGraphic.UnregisterDirtyMaterialCallback(TesselationRequiredCallback);
			}
			if ((bool)myText)
			{
				myText.UnregisterDirtyVerticesCallback(TesselationRequiredCallback);
				Font.textureRebuilt -= FontTextureRebuiltCallback;
			}
		}

		private void TesselationRequiredCallback()
		{
			tesselationRequired = true;
		}

		private void FontTextureRebuiltCallback(Font fontie)
		{
			if (myText.font == fontie)
			{
				tesselationRequired = true;
			}
		}

		private void Update()
		{
			if (!tesselationRequired)
			{
				if ((base.transform as RectTransform).rect.size != savedRectSize)
				{
					tesselationRequired = true;
				}
				else if (myGraphic != null)
				{
					if (myGraphic.color != savedColor)
					{
						tesselationRequired = true;
						savedColor = myGraphic.color;
					}
					else if (myImage != null && myImage.fillAmount != savedFill)
					{
						tesselationRequired = true;
						savedFill = myImage.fillAmount;
					}
				}
			}
			if (!tesselationRequired && !curvingRequired)
			{
				Vector3 a = mySettings.transform.worldToLocalMatrix.MultiplyPoint3x4(base.transform.position);
				if (!a.AlmostEqual(savedPos) && (mySettings.Shape != 0 || (double)Mathf.Pow(a.x - savedPos.x, 2f) > 1E-05 || (double)Mathf.Pow(a.z - savedPos.z, 2f) > 1E-05))
				{
					savedPos = a;
					curvingRequired = true;
				}
				Vector3 normalized = mySettings.transform.worldToLocalMatrix.MultiplyVector(base.transform.up).normalized;
				if (!savedUp.AlmostEqual(normalized, 0.0001))
				{
					bool flag = normalized.AlmostEqual(Vector3.up.normalized);
					bool flag2 = savedUp.AlmostEqual(Vector3.up.normalized);
					if ((!flag && flag2) || (flag && !flag2))
					{
						tesselationRequired = true;
					}
					savedUp = normalized;
					curvingRequired = true;
				}
			}
			if ((bool)myGraphic && (tesselationRequired || curvingRequired))
			{
				myGraphic.SetVerticesDirty();
			}
		}

		private void CheckTextFontMaterial()
		{
			if ((bool)myText && myText.cachedTextGenerator.verts.Count > 0 && myText.cachedTextGenerator.verts[0].uv0 != savedTextUV0)
			{
				savedTextUV0 = myText.cachedTextGenerator.verts[0].uv0;
				tesselationRequired = true;
			}
		}

		private void FindParentSettings()
		{
			if (mySettings == null)
			{
				mySettings = GetComponentInParent<CurvedUISettings>();
				if (!(mySettings == null))
				{
					myCanvas = mySettings.GetComponent<Canvas>();
					angle = mySettings.Angle;
					myImage = GetComponent<Image>();
				}
			}
		}

		private void ModifyVerts(List<UIVertex> verts)
		{
			if (verts == null || verts.Count == 0)
			{
				return;
			}
			CanvasToWorld = myCanvas.transform.localToWorldMatrix;
			CanvasToLocal = myCanvas.transform.worldToLocalMatrix;
			MyToWorld = base.transform.localToWorldMatrix;
			MyToLocal = base.transform.worldToLocalMatrix;
			if (tesselationRequired || !Application.isPlaying)
			{
				TesselateGeometry(verts);
				tesselatedVerts = new List<UIVertex>(verts);
				savedRectSize = (base.transform as RectTransform).rect.size;
				tesselationRequired = false;
			}
			angle = mySettings.Angle;
			float cyllinderRadiusInCanvasSpace = mySettings.GetCyllinderRadiusInCanvasSpace();
			Vector2 size = (myCanvas.transform as RectTransform).rect.size;
			int count = verts.Count;
			if (tesselatedVerts != null)
			{
				UIVertex[] array = new UIVertex[tesselatedVerts.Count];
				for (int i = 0; i < tesselatedVerts.Count; i++)
				{
					array[i] = CurveVertex(tesselatedVerts[i], angle, cyllinderRadiusInCanvasSpace, size);
				}
				verts.AddRange(array);
				verts.RemoveRange(0, count);
			}
			else
			{
				UIVertex[] array2 = new UIVertex[verts.Count];
				for (int j = 0; j < count; j++)
				{
					array2[j] = CurveVertex(verts[j], angle, cyllinderRadiusInCanvasSpace, size);
				}
				verts.AddRange(array2);
				verts.RemoveRange(0, count);
			}
		}

		private UIVertex CurveVertex(UIVertex input, float cylinder_angle, float radius, Vector2 canvasSize)
		{
			Vector3 position = input.position;
			position = CanvasToLocal.MultiplyPoint3x4(MyToWorld.MultiplyPoint3x4(position));
			if (mySettings.Shape == CurvedUISettings.CurvedUIShape.CYLINDER && mySettings.Angle != 0)
			{
				float f = position.x / canvasSize.x * cylinder_angle * ((float)Math.PI / 180f);
				radius += position.z;
				position.x = Mathf.Sin(f) * radius;
				position.z += Mathf.Cos(f) * radius - radius;
			}
			else if (mySettings.Shape == CurvedUISettings.CurvedUIShape.CYLINDER_VERTICAL && mySettings.Angle != 0)
			{
				float f2 = position.y / canvasSize.y * cylinder_angle * ((float)Math.PI / 180f);
				radius += position.z;
				position.y = Mathf.Sin(f2) * radius;
				position.z += Mathf.Cos(f2) * radius - radius;
			}
			else if (mySettings.Shape == CurvedUISettings.CurvedUIShape.RING)
			{
				float num = 0f;
				float num2 = position.y.Remap(canvasSize.y * 0.5f * (float)(mySettings.RingFlipVertical ? 1 : (-1)), (0f - canvasSize.y) * 0.5f * (float)(mySettings.RingFlipVertical ? 1 : (-1)), (float)mySettings.RingExternalDiameter * (1f - mySettings.RingFill) * 0.5f, (float)mySettings.RingExternalDiameter * 0.5f);
				float f3 = (position.x / canvasSize.x).Remap(-0.5f, 0.5f, (float)Math.PI / 2f, cylinder_angle * ((float)Math.PI / 180f) + (float)Math.PI / 2f) - num;
				position.x = num2 * Mathf.Cos(f3);
				position.y = num2 * Mathf.Sin(f3);
			}
			else if (mySettings.Shape == CurvedUISettings.CurvedUIShape.SPHERE && mySettings.Angle != 0)
			{
				float num3 = mySettings.VerticalAngle;
				float num4 = 0f - position.z;
				if (mySettings.PreserveAspect)
				{
					num3 = cylinder_angle * (canvasSize.y / canvasSize.x);
				}
				else
				{
					radius = canvasSize.x / 2f;
					if (num3 == 0f)
					{
						return input;
					}
				}
				float num5 = (position.x / canvasSize.x).Remap(-0.5f, 0.5f, (180f - cylinder_angle) / 2f - 90f, 180f - (180f - cylinder_angle) / 2f - 90f);
				num5 *= (float)Math.PI / 180f;
				float num6 = (position.y / canvasSize.y).Remap(-0.5f, 0.5f, (180f - num3) / 2f, 180f - (180f - num3) / 2f);
				num6 *= (float)Math.PI / 180f;
				position.z = Mathf.Sin(num6) * Mathf.Cos(num5) * (radius + num4);
				position.y = (0f - (radius + num4)) * Mathf.Cos(num6);
				position.x = Mathf.Sin(num6) * Mathf.Sin(num5) * (radius + num4);
				if (mySettings.PreserveAspect)
				{
					position.z -= radius;
				}
			}
			input.position = MyToLocal.MultiplyPoint3x4(CanvasToWorld.MultiplyPoint3x4(position));
			return input;
		}

		private void TesselateGeometry(List<UIVertex> verts)
		{
			Vector2 tesslationSize = mySettings.GetTesslationSize();
			TransformMisaligned = !savedUp.AlmostEqual(Vector3.up.normalized);
			TrisToQuads(verts);
			if (myText == null && !DoNotTesselate)
			{
				int count = verts.Count;
				for (int i = 0; i < count; i += 4)
				{
					ModifyQuad(verts, i, tesslationSize);
				}
				verts.RemoveRange(0, count);
			}
		}

		private void ModifyQuad(List<UIVertex> verts, int vertexIndex, Vector2 requiredSize)
		{
			UIVertex[] array = new UIVertex[4];
			for (int i = 0; i < 4; i++)
			{
				array[i] = verts[vertexIndex + i];
			}
			Vector3 vector = array[2].position - array[1].position;
			Vector3 vector2 = array[1].position - array[0].position;
			if (myImage != null && myImage.type == Image.Type.Filled)
			{
				vector = ((vector.x > (array[3].position - array[0].position).x) ? vector : (array[3].position - array[0].position));
				vector2 = ((vector2.y > (array[2].position - array[3].position).y) ? vector2 : (array[2].position - array[3].position));
			}
			int num = 1;
			int num2 = 1;
			if (TransformMisaligned || mySettings.Shape == CurvedUISettings.CurvedUIShape.SPHERE || mySettings.Shape == CurvedUISettings.CurvedUIShape.CYLINDER_VERTICAL)
			{
				num2 = Mathf.CeilToInt(vector2.magnitude * (1f / Mathf.Max(1f, requiredSize.y)));
			}
			if (TransformMisaligned || mySettings.Shape != CurvedUISettings.CurvedUIShape.CYLINDER_VERTICAL)
			{
				num = Mathf.CeilToInt(vector.magnitude * (1f / Mathf.Max(1f, requiredSize.x)));
			}
			bool flag = false;
			bool flag2 = false;
			float y = 0f;
			for (int j = 0; j < num2 || !flag; j++)
			{
				flag = true;
				float num3 = ((float)j + 1f) / (float)num2;
				float x = 0f;
				for (int k = 0; k < num || !flag2; k++)
				{
					flag2 = true;
					float num4 = ((float)k + 1f) / (float)num;
					verts.Add(TesselateQuad(array, x, y));
					verts.Add(TesselateQuad(array, x, num3));
					verts.Add(TesselateQuad(array, num4, num3));
					verts.Add(TesselateQuad(array, num4, y));
					x = num4;
				}
				y = num3;
			}
		}

		private void TrisToQuads(List<UIVertex> verts)
		{
			int num = 0;
			int count = verts.Count;
			UIVertex[] array = new UIVertex[count / 6 * 4];
			for (int i = 0; i < count; i += 6)
			{
				array[num++] = verts[i];
				array[num++] = verts[i + 1];
				array[num++] = verts[i + 2];
				array[num++] = verts[i + 4];
			}
			verts.AddRange(array);
			verts.RemoveRange(0, count);
		}

		private UIVertex TesselateQuad(UIVertex[] quad, float x, float y)
		{
			UIVertex result = default(UIVertex);
			float[] array = new float[4]
			{
				(1f - x) * (1f - y),
				(1f - x) * y,
				x * y,
				x * (1f - y)
			};
			Vector2 zero = Vector2.zero;
			Vector2 zero2 = Vector2.zero;
			Vector3 zero3 = Vector3.zero;
			for (int i = 0; i < 4; i++)
			{
				zero += quad[i].uv0 * array[i];
				zero2 += quad[i].uv1 * array[i];
				zero3 += quad[i].position * array[i];
			}
			result.position = zero3;
			result.color = quad[0].color;
			result.uv0 = zero;
			result.uv1 = zero2;
			result.normal = quad[0].normal;
			result.tangent = quad[0].tangent;
			return result;
		}

		public void SetDirty()
		{
			TesselationRequired = true;
		}
	}
	public static class CalculationMethods
	{
		public static bool AlmostEqual(this Vector3 a, Vector3 b, double accuracy = 0.01)
		{
			return (double)Vector3.SqrMagnitude(a - b) < accuracy;
		}

		public static float Remap(this float value, float from1, float to1, float from2, float to2)
		{
			return (value - from1) / (to1 - from1) * (to2 - from2) + from2;
		}

		public static float Remap(this int value, float from1, float to1, float from2, float to2)
		{
			return ((float)value - from1) / (to1 - from1) * (to2 - from2) + from2;
		}

		public static double Remap(this double value, double from1, double to1, double from2, double to2)
		{
			return (value - from1) / (to1 - from1) * (to2 - from2) + from2;
		}

		public static float Clamp(this float value, float min, float max)
		{
			return Mathf.Clamp(value, min, max);
		}

		public static float Clamp(this int value, int min, int max)
		{
			return Mathf.Clamp(value, min, max);
		}

		public static int ToInt(this float value)
		{
			return Mathf.RoundToInt(value);
		}

		public static int FloorToInt(this float value)
		{
			return Mathf.FloorToInt(value);
		}

		public static int CeilToInt(this float value)
		{
			return Mathf.FloorToInt(value);
		}

		public static Vector3 ModifyX(this Vector3 trans, float newVal)
		{
			trans = new Vector3(newVal, trans.y, trans.z);
			return trans;
		}

		public static Vector3 ModifyY(this Vector3 trans, float newVal)
		{
			trans = new Vector3(trans.x, newVal, trans.z);
			return trans;
		}

		public static Vector3 ModifyZ(this Vector3 trans, float newVal)
		{
			trans = new Vector3(trans.x, trans.y, newVal);
			return trans;
		}

		public static Vector2 ModifyVectorX(this Vector2 trans, float newVal)
		{
			trans = new Vector3(newVal, trans.y);
			return trans;
		}

		public static Vector2 ModifyVectorY(this Vector2 trans, float newVal)
		{
			trans = new Vector3(trans.x, newVal);
			return trans;
		}

		public static void ResetTransform(this Transform trans)
		{
			trans.localPosition = Vector3.zero;
			trans.localRotation = new Quaternion(0f, 0f, 0f, 0f);
			trans.localScale = Vector3.one;
		}
	}
	public class CurvedUIViveController : MonoBehaviour
	{
	}
	public struct ViveInputArgs
	{
		public uint controllerIndex;

		public float buttonPressure;

		public Vector2 touchpadAxis;
	}
	public delegate void ViveInputEvent(object sender, ViveInputArgs e);
	public class CurvedUIViveInputModule : BaseInputModule
	{
		public override void Process()
		{
		}
	}
	[ExecuteInEditMode]
	public class CurvedUITMP : MonoBehaviour
	{
	}
}
